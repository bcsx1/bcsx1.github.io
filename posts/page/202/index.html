<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4827a25afcc6af189b48c0ff7a733a9/" rel="bookmark">
			kettle （ 第六章 SQL文件的输出）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SQL文件是一个包含SQL语句的文本文件，后缀用“.sql”表示。SQL文件输出是将数据生成可执行的SQL语句，并装载至后缀为“.sql”的文本文件中。
为了使用SQL语句生成数据，需要对MySQL的“demodb”数据库“2020年1月月考数学成绩”表中的数据，使用SQL文件输出组件，迁移和装载至“2020年1月_月考数学成绩.sql”文件。
一、创建转换
二、配置控件
1、表输入
连接数据库，并填写相应SQL语句，获取数据库中的数据。
2、SQL文件输出
“一般”选项卡中，配置如下。
“内容”选项卡中，配置如下。
三、执行结果
SQL文件用记事本打开，如下。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ead18ca5ce8d4718b7b170860f814c2f/" rel="bookmark">
			el-table使用sortable.js实现动态表头拖拽行拖拽列功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;template&gt; &lt;!-- 行列拖拽案例 --&gt; &lt;div style="padding: 20px"&gt; &lt;el-table row-key="id" :key="tableKey" :header-cell-style="{ background: '#4faeef', color: '#c1def3', 'text-align': 'center', }" :data="tableData" &gt; &lt;el-table-column type="selection" width="60" align="center"&gt; &lt;/el-table-column&gt; &lt;el-table-column v-for="(item, index) in tableHeaerList" :key="index" :width="item.width" :label="item.label" :prop="item.prop" &gt; &lt;template slot-scope="scoped"&gt; &lt;span v-if="item.prop === 'custom'"&gt;自定义列内容&lt;/span&gt; &lt;span v-else&gt;{{ scoped.row[scoped.column.property] }}&lt;/span&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;/el-table&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import Sortable from "sortablejs"; export default { name: "index", data() { return { tableKey: "", //拖拽排序后，将mykey赋随机值，使表格重绘（重绘后需重新挂载拖拽监听事件） tableData: [ { id: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ead18ca5ce8d4718b7b170860f814c2f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/789fa48a20d1ef6a2523228dac9d8495/" rel="bookmark">
			LeetCode：234（Python）—— 回文链表（简单）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		回文链表 概述：给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false 。 输入：head = [1,2,2,1] 输出：true 输入：head = [1,2] 输出：false 方法一：遍历+检索 思路：核心思路是把单链表存储出来，然后进行回文数的判断即可。 # 遍历+检索 # 核心思路是把单链表存储出来，然后进行回文数的判断即可。 class Solution: def isPalindrome(self, head: Optional[ListNode]) -&gt; bool: ans = [] while head: ans.append(head.val) head = head.next return ans == ans[::-1] 方法二：递归 思路：指向头尾两个节点，然后依次判断即可。 # 递归 # 指向头尾两个节点，然后依次判断即可。 class Solution: def isPalindrome(self, head: Optional[ListNode]) -&gt; bool: self.front_pointer = head def recursively_check(current_node = head): if current_node is not None: if not recursively_check(current_node.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/789fa48a20d1ef6a2523228dac9d8495/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/408cbff4f44cd92c2ebc0adbff926714/" rel="bookmark">
			commit报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PS C:\Users\jm030476\Desktop\sema-pc&gt; git commit -m "feat: 过滤"
internal/process/esm_loader.js:74
internalBinding('errors').triggerUncaughtException(
^
Error [ERR_UNSUPPORTED_ESM_URL_SCHEME]: Only file and data URLs are supported by the default ESM loader. Received protocol 'node:' er. Received proto
at Loader.defaultResolve [as _resolve] (internal/modules/esm/resolve.js:750:11)
at Loader.resolve (internal/modules/esm/loader.js:85:40)
at Loader.getModuleJob (internal/modules/esm/loader.js:229:28)
at ModuleWrap.&lt;anonymous&gt; (internal/modules/esm/module_job.js:51:40)
at link (internal/modules/esm/module_job.js:50:36) {
code: 'ERR_UNSUPPORTED_ESM_URL_SCHEME'
}
husky - pre-commit hook exited with code 1 (error)
解决：
node版本问题，同组的版本号不一致，更换版本号就可以了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39c518b3fa99bbeb4bf8a2bf8a44d803/" rel="bookmark">
			STM32H7B0 同时启用D-Cache与ADC dma
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 使用STM32H7B0刷4.3寸屏幕，不开启D-Cache的话，是会卡顿的
同时项目需要使用ADC dma采样，然而开启D-Cache之后，dma外设改变内部RAM后，并没有更改Cache内的数据吗，导致CPU无法正确得到RAM内的最新采样数据
解决这个问题的办法很简单,就是在处理采样数据 之前，调用SCB_InvalidateDCache_by_Addr函数。
需要注意的是
1、这个函数的形参addr和dsize：
addr ： 操作的地址一定要是32字节对齐的。
dsize ：一定要是32字节的整数倍
2、DMA外设指向的数组需要32字节对齐
以下是使用示例
//DMA外设指向的数组需要32字节对齐 static uint32_t ADC_Value[DEPTH_ADC][ADC_NUM] __attribute__ ((aligned (32))) = {0}; void Sample_Task() { HAL_ADC_Stop_DMA(&amp;hadc1)； SCB_InvalidateDCache_by_Addr((uint32_t *)&amp;ADC_Value,ADC_NUM * DEPTH_ADC * 4); //这里对采样数据进行处理 HAL_ADC_Start_DMA(&amp;hadc1, (uint32_t*)&amp;ADC_Value, ADC_NUM * DEPTH_ADC); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a776b8b3b884440b2738358c8a18d95f/" rel="bookmark">
			（vsCode） sqlite3可视化工具的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vsCode - sqlite3可视化工具的使用
1.安装扩展 SQLite
因此，我们将引入一个名为 SQLite的扩展。
尝试照常从VScode Marketplace安装：搜索SQLite 安装扩展
2.如何使用SQLite：
打开命令选项板，然后输入 sql。
具体操作：如何打开命令选项板：
Windows：Ctrl Shift P
Mac：Command Shift P
在搜索结果中选择 SQLite：打开数据库。
将选择文件：*.db 屏幕上似乎什么也没有发生:
仔细查看"资源管理器"选项卡
有" SQLITE EXPLORER"项
此处将显示每个表和列。
如果要查看在表中注册的数据，请单击每个表名旁边的"？"。
可以在VS Code上使用SQLite，无需其他工具。
当然，即使您不使用VScode，也有一个很棒的工具叫做DB Browser for SQLite，都可以用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a9b6c3ed384268701969fff4d7731bf/" rel="bookmark">
			程序的翻译环境【编译&amp;&amp;链接的过程】【详解】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本期介绍🍖
主要介绍：代码是如何一步步的转化成可执行城西的，详细介绍了编译和链接的过程，特别是在编译还可分为预编译、编译、汇编三个阶段，介绍每个阶段分别干什么。👀。
文章目录 一、概述🍖二、编译与链接的过程🍖2.1 预编译 / 预处理🍖2.2 编译🍖2.3 汇编🍖2.4 链接🍖 三、程序执行时的过程🍖四、总结🍖 一、概述🍖 在ANSIC规定任何一个C语言代码都会经过下面两个环境：
翻译环境：将源代码转换成可执行的机器指令。执行环境：实际执行代码。 而今天主要讲述的是翻译环境，也就是编译和链接这两个部分。想必大家在学习《C语言》第一章时就听过这样子的一个说法：一个程序必然需要经过编译和链接这两个阶段才能生成一个可执行的代码，计算机才能执行。书上给出的原因是：我们所编写的原代码（也就是以.c为后缀的文件）计算机是看不懂的，它只能读懂二进制的代码。所以必须经过人为的翻译，使其转换成计算机可以读懂的代码。事实也确实如此，不过我还需要补充几点：如下图所示。
每一个源文件（.c）都会单独经过编译器操作生成一个与之对应的目标文件（.obj） 那有人就要这么问了：为什么一个项目中会存在多个源文件？ 那是因为，当项目组在开发一个软件的时候，是不可能只存在一个源文件，不然大家怎么协同啊，你写完我写，我写完再他写，是不是太浪费时间了呀。所以在一个工程当中大家是分模块写的（也就是.c文件），你写你的模块，我写我的模块，最后再把所有模块合并成完整的项目。
下面我们来证明一些是否真是每一个源文件都会生成自己所对应的目标文件。
在该项目的文件路径底下，当调试过后test.c和Add.c会分别生成test.obj和Add.obj这两个目标文件。
链接器会把所有目标文件加上链接库一起合并生成一个可执行的程序（.exe的文件） 注意：在VS中使用的编译器是cl.exe，而链接器是link.exe的工具。
二、编译与链接的过程🍖 通过上面的学习我们知道一个源程序想要转换成可执行程序，就必须经过编译和链接两个过程。但编译这个阶段其实没有想象中的这么简单，它还可以细分为三个阶段：预编译（预处理）、编译、汇编。如下图所示：
至于每一个阶段都干了些上面这是我们今天重点想要论述的。而由于VS是集成开发环境（也就是说，这种开发环境省略了按步进行调试，是直接一步到位的，中间过程我们无法获取），是无法观测到编译期间的每一步细节的，所以后面我们会使用gcc编译器来进行演示。
2.1 预编译 / 预处理🍖 预编译这个阶段只干三件事：
将#include涉及的头文件包含到文件中来对#define所定义的符号进行替换，然后删除定义语句删除注释行 可以见得，其实预编译期间只进行了文本操作，譬如头文件的拷贝，字符的替换，语句的删除。注意：预编译期间是不会对源文件进行任何的修改的，它只会对源文件进行相应的处理，然后生成一个新的文件，使之继续进行接下来的编译操作。下面我们来演示证明一下：
可见，预处理阶段会将#include所涉及的文件整个的包含到我们的文件当中来。
可以看出，预编译后#define MAX 100与代码中的MAX进行了替换，然后删除了原定义语句，注释也进行了删除。
2.2 编译🍖 编译阶段笼统的来说：就是把C语言代码转换成汇编代码。不过这个过程较为复杂，需要进行词法分析、语法分析、语义分析、符号汇总，最终才能转换成汇编代码。下面来演示一下，通过对上一个编译生成的test.i文件进行汇编操作，如下所示：
可以见的，经过编译操作后确实将C语言代码转换成汇编代码。今天重点还需要来讲下 “符号汇总”，因为这一步操作会为后期 “汇编” 和 “链接” 所服务，最终达成某些目的。符号汇总会将代码中所有的全局符号汇总到一起。就譬如上面代码中汇总的全局符号如下图所示：
2.3 汇编🍖 汇编操作大致来说就是把汇编代码转换成二进制代码（计算机可以执行的代码）。下面来演示一下结果：
汇编操作除了会将汇编代码转换成二进制代码，还会形成符号表。所谓的符号表，就是给之前编译期间汇总的全局符号关联一个地址，并制成一张表。下面来举个例子：
至于这张表制出来到底有什么用，你会在链接期间知晓。
2.4 链接🍖 链接期间会做两件事：
合并段表 至于什么是合并段表呢？我们需要知道，在gcc中其实后缀为.o的文件都是以elf的格式来组织文件内容。elf格式的存放习惯会将整个文件分成很多段，每一段都存放不同类型的数据。而链接操作会把多个目标文件加上链接库一起，把相同类型的数据合并到同一段中，最终合并成可执行文件。如下图所示：
注意：此处由多个目标文件和链接库合并成的可执行文件，数据存储的格式也是elf格式。
符号表的合并与重定位 符号表的合并与重定位顾名思义，就是将之前每一个目标文件形成的符号表进行合并和删选，最终形成唯一一张表与可执行程序对应。那为什么要形成这样一张符号表呢？为的是能够在链接期间跨文件的寻找函数或者全局变量，同样也是为之后执行代码时能够通过符号表中存放的地址来对函数进行调用。如下所示：
但注意：当Add函数定义不存在时，那么最终合并重定位的符号表中，Add所关联的地址就是无效地址，会在符号表进行审核时，出现链接性错误。如下图所示：
三、程序执行时的过程🍖 程序必须载入内存当中才能执行起来。在有操作系统的环境中，一般由操作系统来完成。在独立的环境中，一般是由人工手动载入内存当中的，或者时通过烧录软件将代码置入内存中的。程序执行开始，首先会调用main函数。开始执行程序代码，这时会创建一个临时的调用堆栈，用于存储函数调用和返回时所需的各种参数，以及创建的局部变量。（也就是函数栈帧的创建与销毁）终止程序。 四、总结🍖 这份博客👍如果对你有帮助，给博主一个免费的点赞以示鼓励欢迎各位🔎点赞👍评论收藏⭐️，谢谢！！！
如果有什么疑问或不同的见解，欢迎评论区留言欧👀。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5dd084f178e4365e60052c4c6e4da8d4/" rel="bookmark">
			element-ui中table表格标签编辑功能的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目场景： 表格实现编辑功能。在实际开发过程中，我们表格的表头往往很多，有的还会发生变化，所以本文参考一位博主的代码结合自己的项目进行了改编。
参考原文链接：vue element-ui实现table表格可编辑修改
代码展示 &lt;template&gt; &lt;div class="st-table"&gt; &lt;el-table :data="tableData" border style="width: 100%"&gt; &lt;el-table-column v-for="(item, index) in columns" :key="index" fixed :prop="item.prop" :label="item.label" width="180"&gt; &lt;template slot-scope="scope"&gt; &lt;input type="text" v-model="scope.row[item.prop]" v-show="scope.row.iseditor" /&gt; &lt;span v-show="!scope.row.iseditor"&gt;{{scope.row.date}}&lt;/span&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;el-table-column label="操作" width="180"&gt; &lt;template slot-scope="scope"&gt; &lt;el-button type="warning" @click="edit(scope.row, scope)"&gt;编辑&lt;/el-button&gt; &lt;el-button type="danger" @click="save(scope.row)"&gt;保存&lt;/el-button&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;/el-table&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: 'HelloWorld', data () { return { columns:[ {prop:'date',label:'时间',width:'150'}, {prop:'name',label:'姓名',width:'150'}, {prop:'address',label:'地址',width:'150'}, ], tableData: [ { date: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5dd084f178e4365e60052c4c6e4da8d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cef41d1ed38b3386b6405fe9dc519374/" rel="bookmark">
			linux服务器监控性能测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、服务器实时内存监控 1、top：能够实时监控系统的运行状态，并且可以按照cpu以及内存等进行排序。
输入：top -help就可以出现下面的例子：
命令例子：top -hv | -bcHiOSs -d secs -n max -u|U user -p pid(s) -o field -w [cols]
其中主要关注cpu：%Cpu(s)
%Cpu(s): 0.0 us, 0.3 sy, 0.0 ni（使用的cpu）, 99.7 id（空闲的cpu）, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st
和内存
KiB Mem : 995676 total, 62368 free, 763360 used, 169948 buff/cache
a、在显示结果后可以输入大写的C和M就会按照cpu和内存的大小进行排序，按Z就可以彩色显示结果
b、top -p 指定显示某个进程的使用资源情况，如top -p 1，有多个则用,隔开如top -p 1,2
2、vmstat
可以监控操作系统的进程状态，cpu、内存、磁盘等信息。
vmstat 1 2前面的参数是时间间隔：每隔1秒，后面参数：显示2次
3、free
free -h
二、服务器实时cpu监控 1、mpstat
最大特点是可以监控多核cpu中每个计算核心的统计数据（比如你cpu有8核，可以使用mpstat -p 7表示第八个cpu的使用情况）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cef41d1ed38b3386b6405fe9dc519374/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef4d7066041110fdd3e43a9b7d608bbb/" rel="bookmark">
			MySQL插入汉字报错的解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 MySQL插入汉字报错的原因是字符集的问题，MySQL默认使用的是Latin（拉丁文）字符集，可以在创建数据库时指定其字符集：CREATE DATABASE test DEFAULT CHARACTER SET utf8
或者修改MySQL的配置文件，可以参考以下步骤：
1、在开始页面搜索服务，并打开。 2、找到MySQL，双击查看属性中可执行文件的路径。 3、在文件管理器中按照上述路径对my.ini先进行备份，再在记事本中打开my.ini ，修改相关配置。 找到[mysql]，在下面新增default-character-set=utf8
找到[mysqlld]，在下面新增character-set-server=utf8
注意对修改的文件要进行保存。
4、重新启动MySQL服务器。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46445532ad3c5ec53a1b2485352dcd47/" rel="bookmark">
			C提高01-数据类型，typedef,void,sizeof用法，变量赋值，内存分区，栈区，堆区，全局静态区，extern和static区别，const全局和局部变量区别，字符串常量区
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以下内容详情
01 数据类型基本概念 数据类型基本概念:
1.类型是对数据的抽象
2.类型相同的数据具有相同的表示形式，存储格式以及相关操作
3.程序中所有的数据都必定属于某种数据类型
4.数据类型可以理解为创建变量的模具：固定大小内存的别名
02 typedef用法 1.给一个已知类型起别名 原始代码：
#include&lt;stdio.h&gt; #include&lt;string.h&gt; #include&lt;stdlib.h&gt; struct Person { char name[64]; int age; }; void test01() { struct Person p; } int main() { test01(); system("pause"); return EXIT_SUCCESS; } 通过typedef起别名简化代码：
#include&lt;stdio.h&gt; #include&lt;string.h&gt; #include&lt;stdlib.h&gt; struct Person { char name[64]; int age; }; typedef struct Person myPerson; void test01() { myPerson p; } int main() { test01(); system("pause"); return EXIT_SUCCESS; } 进一步简化：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/46445532ad3c5ec53a1b2485352dcd47/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/327e000f9e2081f74616f50d021f867c/" rel="bookmark">
			深入理解计算机系统(CSAPP) 第一章 (1.3 节有问题待解决)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.1 信息就是位 + 上下文 位即比特，其值为 0 或 1。上下文即解释比特序列的方法。
系统中的所有信息 —— 包括磁盘文件、内存中的程序、内存中存放的用户数据以及网络上传送的数据，都是由一串比特序列表示的。相同的比特序列在不同的场景中有着不同的含义，比如同样一串序列可以表示一个正数、浮点数、字符或者机器指令。
1.2 程序被其他程序翻译成不同的格式 一个用 C 语言描述的文本文件(hello.c)，必须经过四个步骤才能变为一个可执行文件(hello)：
预处理阶段(产出 hello.i 文件)：预处理器根据以字符 ‘#’ 开头的命令修改 C 代码，比如展开头文件，处理宏(#define, #ifndef 等)。 对应命令：gcc -o hello.i -E hello.c; 编译阶段(产出 hello.s 文件)：将 C代码编译为汇编代码。 对应命令：gcc -o hello.s -S hello.i; 汇编阶段(产出 hello.o 文件)：将汇编代码翻译为机器语言指令，并打包为一个可重定位目标程序(relocatable object pragram)格式的文件。 对应命令：gcc -o hello.o -c hello.s 链接阶段(产出 hello 文件)：将一个或多个可重定位目标程序按照某种方式链接为可执行目标文件。 对应命令：gcc -o hello hello.o 1.3 了解编译系统工作是大有益处的 这一小节主要是提出问题。这里先记下来，后面整理答案。
性能优化相关的：
switch VS 一连串 if-else，谁更快？函数调用的开销有多大？while-loop VS for-loop ，谁更快？指针引用 VS 数组索引，谁更快？将循环求和的值存入本地变量 VS 存入通过引用传递过来的参数，谁更快？重新排列算术表达式的括号就能让函数变快？ 链接相关：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/327e000f9e2081f74616f50d021f867c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4dd8ab8c9a522651b8fbfe9ceb5bc5ce/" rel="bookmark">
			Android 接入穿山甲激励视频广告步骤与错误总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.先去穿山甲官网，注册登录账号
2.侧边栏-&gt;广告变现-&gt;流量-&gt;应用-&gt;新建应用
3.侧边栏-&gt;广告变现-&gt;流量-&gt;代码位-&gt;新建代码位
4. 侧边栏-&gt;接入中心-&gt;SDK下载与接入文档
下载SDK，可以一边看文档一边写代码，一边参考SDK代码
打开页面如下：在工程配置那按照步骤集成SDK
在激励视频广告那按照步骤集成激励视频广告
5.详细步骤总结 一、SDK配置 1.从下载的SDK中复制open_ad_sdk.arr到 libs目录下
2. 在app的 build.gradle 中添加如下代码：
android { repositories { flatDir { dirs 'libs' } } } dependencies { implementation(name: 'open_ad_sdk', ext: 'aar') } 3.添加权限
&lt;!--穿山甲--&gt; &lt;!-- 必要权限 --&gt; &lt;uses-permission android:name="android.permission.INTERNET" /&gt; &lt;!-- 可选权限 --&gt; &lt;uses-permission android:name="android.permission.READ_PHONE_STATE" /&gt; &lt;uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" /&gt; &lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" /&gt; &lt;uses-permission android:name="android.permission.ACCESS_WIFI_STATE" /&gt; &lt;uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" /&gt; &lt;uses-permission android:name="android.permission.REQUEST_INSTALL_PACKAGES" /&gt; &lt;uses-permission android:name="android.permission.VIBRATE" /&gt; &lt;!-- suppress DeprecatedClassUsageInspection --&gt; &lt;uses-permission android:name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4dd8ab8c9a522651b8fbfe9ceb5bc5ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d18e3029eebad281f083418681b85f7/" rel="bookmark">
			OceanBase-概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 背景产品家族分布式数据库社区版（当前为V4.0）企业版公有云 总结核心功能适用场景 工具体系迁移评估工具OMA迁移工具OMS开发工具ODC 权限管理运维工具OCP 生态产品图数据库时序数据库 背景 前段时间学习了下tidb的体系架构，了解了其运行原理；今儿了解下OceanBase；
产品家族 先看下官网：https://www.oceanbase.com/
在OceanBase的产品分类里，一共有三大块，分布式数据库、工具体系、生态产品；（一个产品好不好用周边很关键）；
分布式数据库 社区版（当前为V4.0） 介绍：兼容 MySQL 的单机分布式一体化数据库，具有原生分布式架构，支持金融级高可用、透明水平扩展、分布式事务、多租户和语法兼容等企业级特性。OceanBase 内核通过大规模商用场景的考验，已服务众多行业客户；面向未来携手社区生态伙伴，共建开源开放的数据库内核和生态。
为什么选择社区版？
稳定可信赖 支持超大事务RTO&lt;30s允许时钟偏差达到2s，动态修改时钟； 海量数据高性能 海量数据，支持在线事务处理OLTP和在线分析处理OLAP的线性扩展；TPC-C测试第一 大幅提升KV能力 支持OBKV，具备HBase模型和Table模型的NoSQL能力；相对HBase，二级索引下OBKV性能指数级提升； 更低的存储和运维成本 支持部署运行在PC服务器和低端SSD；高存储压缩率降低存储成本；无中心化设计原生多租户支持主流生态产品（prometheus、canal） 及时响应的社区支持 文档完善（阿里的文档没几个完善的） 兼容MySQL开源生态 这个是核心，最起码现在主流还是MySQL 产品架构
OceanBase 社区版数据库内核开源， 与 MySQL 兼容，对接虚拟化和大数据技术及产品，支持多种图形化的开发工具、运维监控工具和数据迁移工具；同时社区版提供开放的接口和丰富的生态能力，支持企业或个人更好的实现定制化业务需求。
整体架构
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-3qLZ8Chw-1670410851150)(https://images.5ycode.com/images/OceanBase%E6%9E%B6%E6%9E%84%E5%9B%BE.jpeg-1)]
OBProxy: 为应用程序屏蔽了OB内部的分区和副本分布等细节；应用程序发起请求后，由OBProxy转发SQL请求到合适的OBServer节点；OBProxy是无状态的服务多个OBProxy节点通过负载均衡对应用提供统一的网络地址； OBServer: OB的一个集群由若干节点组成，这些节点分属于若干个可用区（zone）;zone是一个逻辑概念，即可以表示集群内具有相似硬件属性的一组节点（可以是一个城市，可以是一个机房，可以是一个机柜，也可以是一台服务器）一个OB集群内，可以创建多个隔离的数据库“实例”（租户），每个租户是一个独立的数据库，租户可以选择MySQL模式或Oracle模式；一个observer内，可以有多个属于不同租户的虚拟容器叫资源单元（unit），每个资源单元的资源都是独立的；一个租户在多个节点上的资源单元（unit）组成一个资源池；OB中，一个表的数据可以按照一定的规则水平拆分为多个分片，每个分片叫做一个表分区，一行数据只能属于一个分区；一个表的分区可以分布在一个可用区内的多个节点上，每个物理分区有一个用于存储数据的存储层对象tablet，用于存储有序的数据；tablet中的数据修改时，会记录redo到tablet对应的日志流里，每个日知录服务了其他所在节点上的多个tablet，为了容灾，每个日志流及tablet有多个副本；副本分散在不同的可用区里；有且只有一个副本接收修改操作，通过Multi-Paxos分布式共识实现副本之间的强一致性； 我们类比一下
传统数据库（MySQL）OceanBase数据库物理机集群固定配置的虚拟机资源单元（固定配置）集群资源池MySQL实例租户（MySQL兼容或Oracle兼容）分区表（单节点）表分区（多节点，多分区）binlogredo-&gt;日志流 客户案例
携程旅行：没说具体业务，只是探索通过 OceanBase 社区版方案来替换原有 MySQL 方案；读性能提升2倍，写性能提升3倍；，节省2/3的存储；快手：也没说具体业务，也是解决线上MySQL分片过多带来的高运维成本；数据同步延迟减少3/4,存储成本降低至1/4；翼支付：消息中心，存储从72T–&gt;17T； 企业版 OceanBase 企业版（OceanBase Database）是一款完全自研的企业级原生分布式数据库，在普通硬件上实现金融级高可用，首创“三地五中心”城市级故障自动无损容灾新标准，刷新 TPC-C 标准测试，单集群规模超过 1500 节点，具有云原生、强一致性、高度兼容 Oracle/MySQL 等特性。
为什么选择企业版
高可用： 三地五中心金融无损RPO=0,RTO&lt;30S数据零丢失 高兼容 高度兼容Oracle和MySQL 水平扩展 透明水平扩展快速的扩缩容准内存处理架构实现高性能支持集群节点超千单集群最大数据量超3PB（真实业务）最大单表行数达万亿级（真实业务） 低成本 基于LSM-Tree的高压缩引擎存储成本降低70%~90%；支持多租户同集群可为多个独立业务提供服务（资源隔离） 实时HTAP ”同一份数据，同一个引擎“，同时支持在线实时交易和实时分析；”一份数据“的多副本可以存储成多种形态，用于不同工作负载，保证数据一致性； 安全可靠 代码级可控自研分布式一体化架构大规模金融核心场景9年可靠性验证；数据存储和通信全链路透明加密 产品架构
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d18e3029eebad281f083418681b85f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59d67071432b44630fe70a7e4c735f7c/" rel="bookmark">
			【总】设置el-cascader级联结构为2级时，只有第2级可勾选且点击label就可选中，且绑定值直接为第2级id数据。(popper-class属性可用来区分多个级联)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		el-cascader组件通用属性配置（主要通过popper-class属性设置和区分多个级联组件）：
props属性的常用取值：
expandTrigger: 'hover', // 鼠标悬浮展开子级框emitPath: false // v-model的绑定值，直接是最后一级的value值，不包含父级。children: 'stock_data', // 设置子级的数组名为stock_data字段（默认组件读children字段），注意：如果children为空数组，组件也会渲染（点击展开为空白框），因此若children为空数组，需让后台直接不要返回该属性字段或返回值改为undefind！checkStrictly: false // 该属性默认为true, 即多级数据，用户只能勾选最后一级，设置为false, 用户可以选择任意一级。 点击label就可以选中原理：设置el-radio（单选）或el-checkbox（多选）的宽度width为100%，然后设置对应label文本的宽度为 - 90%即可。
&lt;!--template中的级联组件--&gt; &lt;el-cascader v-model="listQuery.store_id" :options="warehouseList" ref="cascaderStore" popper-class="custom_cascader" :props="{ label: 'storeroom_name', value: 'storeroom_id', children: 'store_list', checkStrictly: true, expandTrigger: 'hover', emitPath: false }" filterable clearable placeholder="请选择仓库库房" &gt; &lt;/el-cascader&gt; 无论几级，点击label就可以选中：
// 点击label就可以选中，其中：custom_cascader为自定义级联组件类名。 // 单选 .custom_cascader .el-cascader-panel .el-cascader-menu .el-radio { width: 100% !important; } // 多选 .custom_cascader .el-cascader-panel .el-cascader-menu .el-checkbox { width: 100% !important; } // 设置单/多选的label宽度 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/59d67071432b44630fe70a7e4c735f7c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56abeb3ba460c854cb97f4b0db6e1a7f/" rel="bookmark">
			vue中监听checkbox(复选框)选中的事件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用click点击选中，打印出来是false，后面改用change，打印出来就是true了
@click理解 @click执行时间为点击的那一瞬间，而不是点击之后。而点击的那一瞬间复选框的值也确实是false
@change理解 @change则是在状态改变之后触发
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2bf2499275b5138125084329ab84e9b/" rel="bookmark">
			从零开始学习JMETER性能测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从零开始学习JMETER性能测试
顶级 Jmeter 讲座通过实时示例解释负载测试，包括材料和查询支持
课程英文名：Learn JMETER from Scratch on Live Apps Performance Testing
此视频教程共17.0小时，中英双语字幕，画质清晰无水印，源码附件全
下载地址 课程编号：334
百度网盘地址：https://pan.baidu.com/s/1ivLIGKt_3R0wncmCswMTRg?pwd=vd1h
不限速！！! 阿里云盘地址：https://www.aliyundrive.com/s/G3xWY7tzmdv
课程内容 你会学到什么
在本课程结束时，您将能够了解如何将负载加载到 Web 应用程序和 REST API 上
您将清楚地了解 Jmeter 工具中用于编写负载测试用例的所有功能
将获得有关在给定负载下监视应用程序性能的知识
您将完成有关 Jmeter 插件插件的知识，以使报告更有效
[Selenium] 与 Jmeter 的集成
将了解 Jmeter 的 [Beanshell] 脚本基础知识
本课程包括：
8.5小时点播视频
2 篇文章
4 可下载资源
在手机和电视上访问
结业证书
要求 ******您无需具备任何负载测试经验即可开始本课程*********一切从头开始
虽然这些是在线讲座。您将获得终身讲师支持。您可以在讨论板中发布您的查询或直接与我联系，将在 12 小时内回复
包括性能测试在内的所有安装设置都是课程的一部分
理论资料、代码转储和面试指南可供下载
加入我们的 Jmeter 培训社区，与（3000 多名学生）一起学习，这在 Udemy 上的任何其他 Jmeter 在线课程中都看不到
描述 更新： 课程于 7 月全面更新，最新的 Jmeter 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e2bf2499275b5138125084329ab84e9b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2a11ec290191d983b47a58233f3e344/" rel="bookmark">
			samba搭建（基于centos7）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		samba 基础组管理文件权限管理基本命令安装及配置 sambalinux连接 samba 配置详解global配置特定目录共享shell 自动创建用户 基础 SMB：Server Message Block 服务器消息块，IBM发布，最早是 DOS 网络文件共享协议
CIFS：Common Internet File System，微软基于 SMB 发布
SAMBA：1991 年 Andrew Tridgell，实现 Windows 和 Unix 想通
SAMBA 的功能：
共享文件和打印，实现在线编辑实现登录 SAMBA 用户的身份认证可以进行NetBIOS名称解析外围设备共享 注：windows共享使用的是445、139
1、samba账户实现原理
包： samba-common-tools
工具： smbpasswd pdbedit
用户数据库： /var/lib/samba/private/passdb.tdb
samba 用户必须是 linux 用户，建议使用 /sbin/nologin
2、添加 samba 账户
基本命令：
0）、添加不可登录的操作系统账号
# useradd -s /sbin/nologin username
1）、添加 samba 用户
# smbpasswd -a &lt;user&gt;
# 或者
# pdbedit -a -u &lt;user&gt;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c2a11ec290191d983b47a58233f3e344/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2120533bc4ed50e745933285d4ebc7d7/" rel="bookmark">
			QGIS获取行政区geojson数据以及数据乱码修复
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装QGIS 1.下载 访问下面的地址，直接下载安装
https://qgis.org/zh-Hans/site/
2.设置QGIS语言 点击Settings-&gt;Options
点击General，然后按图示选择对应选项。
点击确定，然后等待一会儿，关闭软件重新打开就好了。 安装Quick OSM插件 输入QuickOSM，点击安装插件
防乱码设置（更改系统编码为utf-8） 注意：更改之后会重启，请先保存重要文件
Windows10 搜索框输入语言，点击进入或者点击Windows设置-&gt;时间和语言-&gt;语言
点击管理语言设置
点击更改系统区域设置，勾选使用utf-8，然后点击确定，按提示重启系统
Windows11 搜索框输入语言，点击进入或者点击Windows设置-&gt;时间和语言-&gt;语言和区域点击管理语言设置
点击更改系统区域设置，勾选使用utf-8，然后点击确定，按提示重启系统
获取行政区的地理信息数据 点击矢量-&gt;QuickOSM-&gt; QuickOSM
点击快速查询，右边按图示选择。最后点击运行查询。此插件使用的是OpenStreetMap数据源，小部分地区有村庄的边界。
当下面进度显示查询成功时，关闭此插件。
QGIS此时会显示行政区轮廓，数据会有一些不精准的地方，要手动删除
最终得到的地图。包含村镇数据，如果有不想要的，那么手动编辑即可。
右键点击图层，选择导出-&gt;要素另存为
按图示选择
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e710eca4cd93766c1b7a38f90d1fac1a/" rel="bookmark">
			JVM的内存区域都说不清楚真能找到好工作吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 对于 Java 程序员来说，在虚拟机自动内存管理机制下，不再需要像 C/C++程序开发程序员这样为每一个 new 操作去写对应的 delete/free 操作，不容易出现内存泄漏和内存溢出问题。正是因为 Java 程序员把内存控制权利交给 Java 虚拟机，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那么排查错误将会是一个非常艰巨的任务。
运行时数据区域 jdk1.8之前：
在jdk1.8之后方法区被安排到了直接内存区域的元空间中。
线程私有的：
程序计数器虚拟机栈本地方法栈 线程共享的：
堆方法区直接内存 (非运行时数据区的一部分) 程序计数器 程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的信号指示器。字节码解释器工作通过改变这个计数器的值来选取下一条需要执行的字节码指令，分子、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成
另外，为了线程切换后能恢复到正确的执行位置，每条线程都需要一个独立的程序计数器，个线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”内存
主要有两个作用：
1.字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。
2.在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。
虚拟机栈 Java虚拟机栈,早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈。其内部保存一个个的栈帧,对应着一次次的Java方法调用，其生命周期和线程一致，且线程私有的。
Java虚拟机栈的作用：主管Java程序运行，它保存方法的局部变量、部分结果、并参与方法的调用和返回。每个线程都有自己的栈，栈中的数栈帧的据都是以格式存在。
栈的特点(优点)：
​ 栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器​ JVM直接对java栈的操作只有两种：每个方法执行，伴随着进栈(入栈，压栈)​ 执行结束后的出栈工作​ 对于栈来说不存在垃圾回收问题 本地方法栈 本地方法栈的功能和特点类似于虚拟机栈，均具有线程隔离的特点以及都能抛出栈溢出异常和OutOfMemoryError异常。不同的是，本地方法栈服务的对象是JVM执行的native方法，而虚拟机栈服务的是JVM执行的java方法。
方法区 方法区（Method Area）与Java堆一样，是各个线程共享的内存区域。方法区在JVM启动的时候被创建，并且它的实际的物理内存空间中和Java堆区一样都可以是不连续的。方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展。方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误：ava.lang.OutofMemoryError：PermGen space 或者java.lang.OutOfMemoryError:Metaspace
比如加载大量的第三方的jar包，Tomcat部署的工程过多（30~50个）,大量动态的生成反射类。关闭JVM就会释放这个区域的内存。
堆 栈是运行时的单位，而堆是存储单位：栈解决程序运行问题，即程序如何执行，或者说如何处理数据。堆解决的是数 据存储问题，即数据怎么放，放在哪儿。堆区的大小是可以调节的，但是Java堆区在JVM启动时就被创建，其大小也就确定了。并且是JVM中管理的最大的一块内存空间。在堆中创建的对象要等到GC的发生才能被移除。
经研究表明70%-99%的对象属于临时对象，为了提高GC的性能，Hotspotx虚拟机又将堆区进行了进一步划分。被分为三部分：新生区、养老区、永久区 。将对象根据存活概率进行分类，对存活时间长的对象，放到固定区，从而减少扫描垃圾时间及GC频率。针对分类进行不同的垃圾回收算法，对算法扬长避短。为此，堆空间才被分为新生代和老年代，并将生命周期很短的对象放在新生代，将生命周期很长的对象放在老年代，因为在每次GC时，垃圾回收器都会去判断当前对象是否可以被回收，而这些生命周期很长的对象每次都被垃圾回收器扫描，但每次都不回收，故而可以将这些对象放在老年代，并减少对老年代的GC次数，从而将GC的重心放在新生代上。 通过两个JVM参数可以设置堆的初始内存和最大内存：
-Xms：设置堆的初始内存
-Xmx：设置堆的最大内存
默认情况下
初始内存大小：物理电脑内存大小 / 64 最大内存大小：物理电脑内存大小 / 4 一旦堆区中的内存大小超过“-Xmx"所指定的最大内存时，将会抛出OutOfMemoryError异常。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a72117b8efa8a387e63b8f902414b2d8/" rel="bookmark">
			Mac 安装mysql8.0
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 确认下载的版本 并下载dmg文件
官网下载dmg安装文件 ，查看自己电脑用的是什么芯片 选择对应版本的安装包，终端命令：
uname -a
参考：http://www.yaotu.net/biancheng/13817.html
系统偏好设置里是 英特尔的i7处理器
并且查询到的是X86_64
选择适合自己电脑的安装包或者源码
2. 安装
双击打开下载到的文件 mysql-8.0.31-macos12-x86_64.dmg(或 mysql-8.0.31-macos12-arm64.dmg) 打开后是有一个pkg安装文件 继续双击这个pkg文件
如果弹窗提示安装失败 无权限安装 无法安装非法文件等， 则需要去 系统偏好设置 - 安全性与隐私 里 允许安装未知来源文件：
（1）
一路确认、同意，选择密码类型 “Use Strong Password Encryption“、”Use Legacy Password Encryption" 二选一，Strong是强密码 Legacy据说是兼容5.几的版本，选Legacy稳一点
（2） 选择密码方式之后，会有一个设置root密码界面，输入自定义的密码(默认用户名是root)
3. 查看是否安装成功 是否启动成功
安装成功后 可以在 系统偏好设置 里找到MySQL
点击进入MySQL，可以看到程序运行状态，下图左侧是红色图标，表示未启动，点击右侧的启动按钮即可启动
绿色表示运行中，点击右侧按钮可以停止 Navicat或者其他数据库工具 尝试连接本地数据库：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9289f9affa1ad40709c7d83c83d07222/" rel="bookmark">
			【Bug解决记录】类文件具有错误的版本 61.0, 应为 52.0
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天用测试类调试MyBatis-plus的时候遇到了这个bug，初步思路是jdk版本不对应，把项目的jdk版本和Setting里的jdk版本都设置为同一版本，但没有作用
也尝试过更换maven版本，但也没效果
最终查博客找到了原因所在：
先附上bug描述
Error:(5, 38) java: 无法访问org.springframework.stereotype.Repository
错误的类文件: /D:/Envirement/maven/apache-maven-3.8.4/maven-repo/org/springframework/spring-context/6.0.2/spring-context-6.0.2.jar!/org/springframework/stereotype/Repository.class
类文件具有错误的版本 61.0, 应为 52.0
请删除该文件或确保该文件位于正确的类路径子目录中。
原因：SpringApplication该类的版本是61（我的情况），与本地52的版本不符，所以编译打包就会报错
解决方案：
1、升级本地的JDK版本到17及以上
2、降低依赖，不用spring6（SpringBoot3依赖的是Spring6）
参考博客：
【JAVA】类文件具有错误的版本 61.0, 应为 52.0
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a08a60f603d46e012a3ae6da94e90ab5/" rel="bookmark">
			ubuntu扩容根目录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		挂载新硬盘，比如500GB
查看硬盘信息，根目录/dev/mapper/ubuntu–vg-ubuntu–lv，格式为ext4
fdisk -l查看，/dev/sdb为新挂载的500GB
根目录磁盘类型为gpt，使用工具 gdisk，如果分区是 mbr，使用工具 fdisk
查看新分区情况，多了一个/dev/sdb1的500G分区
格式化新分区/dev/sdb1
创建物理卷
查看卷组，得知: 系统分区的卷组名称为 ubuntu-vg
加入卷组
查看新卷组信息，得知: Free PE / Size为 132862 / 518.99 GiB，132862(等会下面用到这个参数)用于拓展
逻辑卷扩容
查看逻辑卷大小，得知: LV Size 已经变成 538.99 GiB
扩容文件系统，如果文件系统是 xfs 格式用 xfs_growfs ，我这里是 ext4 格式用resize2fs
查看扩容结果
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd515a652e4ecbed76f930a67fbb9f60/" rel="bookmark">
			Solidity智能合约开发 — 3.2-合约的fallback和函数重载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.fallback 函数 每个智能合约有且仅有一个未命名的函数，称为fallback函数，没有参数且没有返回值，可见性必须是 external，且可以是 virtual的（即可以被重载），也可以有修改器 modifier。
fallback执行条件:
如果在一个合约的调用中，没有其他函数与给定的函数标识符匹配时（或没有提供调用数据）,fallback函数会被执行；当合约收到以太时，fallback函数会被执行。 执行条件1：如果在一个合约的调用中，没有其他函数与给定的函数标识符匹配时（或没有提供调用数据）,fallback函数会被执行
// SPDX-License-Identifier: MIT pragma solidity ^0.8.7; //基合约实现 contract TestFallback { string message; //构造函数，初始化状态变量message constructor() { message = "hello"; } fallback() external { message = "fallback"; } //调用此合约中不存在的函数 function testFallback() external returns (bytes memory) { // 调用不存在的函数getMsgNew() bytes memory method = abi.encodeWithSignature("getMsgNew()"); (bool success, bytes memory returnData) = address(this).call(method); require(success, "get fail"); return returnData; } //调用此合约中已存在函数，但是没有传递参数 function testFallbackWithNoParam() external returns (bytes memory) { // 调用已存在的函数setMsg()，未传递参数 bytes memory method = abi.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd515a652e4ecbed76f930a67fbb9f60/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1b27d1b3f9e40d6d4ce00dcb6ac3cbc/" rel="bookmark">
			H5~页面存储，移动端页面适配，元素的拖拽
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		H5页面存储(本地存储)
Cookie
进行页面事件的临时存储，将用户的信息存储在本地本质是一个文本文件，使用的原因是前后端交互时采用的是http协议，Cookie也是在http请求中，进行用户跟踪的一种手段，工作流程是：
1.客户端第一次想服务器发送请求时，没有cookie信息
2.当服务器端就是到客户端的请求后，生成cookie，在cookie中保留客户的相关信息
3.服务器将cookie连同其他的信息一起响应给客户端，客户端就是到cookie后将其保留在本地
4.当客户端再次向服务器发起请求时，会将本地的cookie信息一起发送给服务器。服务器会解析cookie中的信息，决定用户是否要登录
Cookie特点
1.在服务器端生成，保留在客户端
2.体积小，存储上限是4k
3.大量使用cookie会带来性能浪费
4.对字符编码格式支持较差
html5提供的Web Storage
特点
1.只在客户端使用，不与服务器发生通信
2.存储数据的格式：键值对（key --- value）
3.大小的限制：每个域名5M
使用方法：
setItem(key.value)：设置值
getItem(key)：获取值
removeItem(kye)：删除键
clear()：清空所有
存储内容：
文本，图像，json、数组、样式文件（凡是可以序列化为字符串的数据都可以存储）
是浏览器存储数据的一种机制
（1）localStorage：将数据持久存储在本地，除非用户手动删除
（2）sessionStorage：临时存储数据，属于会话级别，当会话结束后（页面关闭）清除存储的数据
IndexDB
特点
1.是浏览器上用于临时存储数据的非关系型数据库
2.没有存储上限：存储空间不小于250M
3.不仅可以存放字符串，还可以存放二进制数据
4.存放数据的格式：key ---value
使用方式：
objectStore.createIndex(key,value) --- 创建index
objectStore.get(key) --- 获取数据
一、移动端页面适配
1、什么是移动端页面适配？
​ 移动端适配是让页面在不同的移动设备上都合理展示
2、移动端页面适配的设计方向
​ （1）0 适配：使用合理的 flex 布局 + 媒体查询做微调
​ （2）等比缩放：基于一个尺寸的屏幕做设计，其他屏幕等比缩放
二、0 适配
1、简介：
就是根本不需要适配，基于设计稿使用 flex 做布局后也能在其他设备上合理展示。
​ 手机屏幕的逻辑像素一般在 320px ~ 428px 这个范围，手机页面最常见的布局就是水平均分排列和两栏布局（如下图所示）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e1b27d1b3f9e40d6d4ce00dcb6ac3cbc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8fceda2938788e5a32b6639e4a4adefe/" rel="bookmark">
			PL/SQL详述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.PL/SQL简介 PL/SQL语言（Procedural Language/SQL，过程化SQL语言）是Oracle推出的过程化的SQL编程语言，使用PL/SQL可以为SQL语言引入结构化的程序处理能力，例如可以在PL/SQL中定义常量、变量、游标、存储过程等，可以使用条件、循环等流程控制语句。
PL/SQL的这种特性使得开发人员可以在数据库中添加业务逻辑，并且由于业务逻辑与数据均位于数据库服务器端，比客户端编写的业务逻辑能提供更好的性能。
PL/SQL是一种块结构的语言，它将一组语句放在一个块中，一次性发送给服务器，PL/SQL引擎分析收到的PL/SQL语句块中的内容，把其中的过程控制语句由PL/SQL引擎自身去执行，把PL/SQL块中的SQL语句交给服务器的SQL语句执行器执行。
PL/SQL块发送给服务器后，先被编译然后执行，对于有名称的PL/SQL块（如存储过程、函数、触发器、程序包）可以单独编译，永久的存储在数据库中，随时准备执行。
两个注意点：
1.在 END; 结束符的下一行开头加“/”作为结束标志。
2.运行 SET SERVEROUTPUT ON; 语句。激活dbms_output包。 2.PL/SQL程序结构：（仅展示代码部分） PL/SQL程序结构_月应是绝色306的博客-CSDN博客https://blog.csdn.net/qq_62687015/article/details/128119296?spm=1001.2014.3001.5501
--变量的定义和初始化。 SET SERVEROUTPUT ON; DECLARE --声明部分标识 v_job VARCHAR2(9); v_count BINARY_INTEGER DEFAULT 0; v_total_sal NUMBER(9,2):=0; v_date DATE:=SYSDATE; c_tax_rate CONSTANT NUMBER(3,2):=8.25; v_valid BOOLEAN NOT NULL:=TRUE; BEGIN v_job:='MANAGER'; --在程序中赋值 DBMS_OUTPUT.PUT_LINE(v_job); --输出变量v_job的值 DBMS_OUTPUT.PUT_LINE(v_count); --输出变量v_count的值 DBMS_OUTPUT.PUT_LINE(v_date); --输出变量v_date的值 DBMS_OUTPUT.PUT_LINE(c_tax_rate); --输出变量c_tax_rate的值 END; --使用SELECT INTO语句赋值变量 SET SERVEROUTPUT ON; DECLARE --声明部分标识 v_job VARCHAR2(9); v_count BINARY_INTEGER DEFAULT 0; v_total_sal NUMBER(9,2):=0; v_date DATE:=SYSDATE; c_tax_rate CONSTANT NUMBER(3,2):=8.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8fceda2938788e5a32b6639e4a4adefe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7709b73c913658d2158abc9afa181c9a/" rel="bookmark">
			【树莓派】raspberry pi控制超声波测距
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、超声波1、模块介绍2、工作原理 二、gettimeofday函数三、树莓派控制超声波测距 一、超声波 1、模块介绍 简介：
超声波传感器模块上面通常有两个超声波元器件，一个用于发射，一个用于接收。
硬件:
电路板上有4个引脚：
VCC（正级）
Trig（触发）
Echo（回应）
GND（接地-负极）
主要参数：
工作电压与电流：5V、15mA感测距离：2~400cm感测角度：不大于15°被测物体的面积：不要小于50cm²，且尽量平整具备温度补偿电路 在超声波模块的触发脚位输入10微秒以上的高电位，即可发射超声波，发射超声波之后，与接收到传回的超声波之前，“响应”脚位呈现高电位。因此，程序可以从“响应”脚位的高位脉冲持续时间，换算出被测物的距离。
2、工作原理 触发信号（Trig）：我们从图中可以看出这个引脚有一个持续10微秒的高电平，从而激发T发波
模块内部发出的信号：这个就是Trig所发出的波的具体形状
输出回响信号（Echo）：在Trig引脚发波的过程中，Echo一直维持高电平状态，从而得出波在空气中跑的时间
白话来说：
T（发波），R（接受）
先给 Trig 引脚发送一个 10us（微秒）的 TTL（高电平）
T就可以发波了，发出的是循环 8 个 40KHz 的脉冲
波发出去后，Echo 引脚就会一直维持高电平，也就是说波在空中传播的过程是一直维持高电平
那么就可以根据Echo 引脚的高电平维持时间，超声波在空气中的物理性质的传输速度，就可以算出障碍物跟发波点的距离
即超声波能在空气中1秒能跑多远，那么就可以通过Echo 引脚的高电平维持时间，换算距离了
二、gettimeofday函数 作用：
把得到从1970年1月1日0时0分0秒到现在的秒数返回到第一个参数指向的结构体中，第二个参数是关于时区，如果不用，填入NULL，简单的说就是获取时间。
函数原型：
#include &lt;sys/time.h&gt; int gettimeofday(struct timeval *tv, struct timezone *tz); int settimeofday(const struct timeval *tv, const struct timezone *tz); 参数介绍：
函数的参数为两个结构体指针
tv：是保存获取时间结果的结构体
tz：用于保存时区结果
timeval结构体： struct timeval { time_t tv_sec; /* seconds */ suseconds_t tv_usec; /* microseconds */ }; timezone结构体： struct timezone { int tz_minuteswest; /* minutes west of Greenwich */ int tz_dsttime; /* type of DST correction */ }; 如果不用timezone结构体，若不使用，tz则传入NULL即可。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7709b73c913658d2158abc9afa181c9a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/607bcd898e46f5bbbbef86db5eeaa343/" rel="bookmark">
			@Value注入不生效，@Value注入静态变量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 转载地址：
@Value注入不生效，@Value注入静态变量_若等无在的博客-CSDN博客_static @value生效
感谢原作者，自己拿过来当笔记用。
当使用@Value注入配置参数时报错，报错原因不一定是@Value注入失败。
可能是用到配置参数的地方需要的是静态配置参数。所以解决办法是改成get()获取。
改正前：
private static final Auth auth = Auth.create(ACCESS_KEY, SECRET_KEY); 改正后：
private Auth getAuth() { return Auth.create(ACCESS_KEY, SECRET_KEY);// 密钥 } 另一个问题：springboot中直接使用@value注解加载静态变量是不生效的。
解决办法是使用set()方法注入：
private static String domain;//域名 @Value("${qiniu.DOMAIN}") private void setDomain(String domain){ this.domain = domain; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53eb3dcfbb4c210bcd4fe1a985d7c946/" rel="bookmark">
			Hadoop
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、简述 hadoop1.x的HDFS默认块大小为64MB；hadoop2.x的默认块大小为128MB。
1）文件块：Block，datanode中存放数据最小逻辑单元，默认块大小为64M，便于管理，不受磁盘限制，数据可在datanode的总block中进行冗余备份，存储的副本数量要少于datanode节点的数量，当一个或多个块出现故障，用户可以直接去其他地方读取数据副本；
2）NameNode：管理文件系统的命名空间，属于管理者角色，维护文件系统树内所有文件和目录，记录每个文件在各个DataNode上的位置和副本信息，并协调客户端对文件的访问；
3）DataNode：负责处理文件系统客户端的文件读写请求，存储并检索数据块，并定期向NameNode发送所存储的块的列表，属于工作者角色。负责所在物理节点的存储管理，按照一次写入，多次读取的原则，存储文件按照Block块进行存储；
4）Secondary NameNode：相当于NameNode的快照，也称之为二级NameNode，能够周期性的备份NameNode，记录NameNode上的元数据等。为防止NameNode进程出现故障，起到备份作用；
Hadoop的优势
1）高可靠性：因为Hadoop假设计算元素和存储会出现故障，因为它维护多个工作数据副本，在出现故障时可以对失败的节点重新分布处理。
2）高扩展性：在集群间分配任务数据，可方便的扩展数以千计的节点。
3）高效性：在MapReduce的思想下，Hadoop是并行工作的，以加快任务处理速度。
4）高容错性：自动保存多份副本数据，并且能够自动将失败的任务重新分配。
hadoop缺点：
1）低时间延迟的数据访问：要求在例如几十毫秒内完成数据访问的应用，不适合在HDFS上运行，HDFS虽然有强大的高数据吞吐量，但是以提高时间延迟为代价，可以使用HBase满足低延迟的访问需求；
2）无法高效存储大量小文件：大量小文件会造成整个文件系统的目录树和索引目录相对较大，而这些的元数据都会存放在namenode节点；
Hadoop组成
1）Hadoop HDFS：一个高可靠、高吞吐量的分布式文件系统。
2）Hadoop MapReduce：一个分布式的离线并行计算框架。
3）Hadoop Common：支持其他模块的工具模块。
4）Hadoop YARN：作业调度与集群资源管理的框架（Hadoop2.x增加）。
Hadoop1.x 时 代 ，Hadoop中 的MapReduce同时处理业务逻辑运算和资源的调度，耦合性较大。在Hadoop2.x时 代，增加 了Yarn。Yarn只负责资 源 的 调 度 ，MapReduce 只负责运算。Hadoop3.x在组成上没有变化
运行模式
（1）本地模式（默认模式）：
不需要启用单独进程，直接可以运行，测试和开发时使用。
（2）伪分布式模式：
等同于完全分布式，只有一个节点。
（3）完全分布式模式：
多个节点一起运行。
二、功能介绍 Hadoop HDFS架构概述
1）NameNode（nn）：存储文件的元数据，如文件名，文件目录结构，文件属性（生成时间、副本数、文件权限），以及每个文件的块列表和块所在的DataNode等。
2）DataNode(dn)：负责数据的读写操作和复制操作，在本地文件系统存储文件块数据，以及块数据的校验和。DataNode之间会进行通信，复制数据块，保证数据的冗余性。
3）Secondary NameNode(2nn)：用来监控HDFS状态的辅助后台程序，每隔一段时间获取HDFS元数据的快照。（定期合并文件系统镜像和编辑日志，然后把合并后的传给NameNode，替换其镜像，并清空编辑日志，类似于CheckPoint机制），但NameNode失效后仍需要手工将其设置成主机
Checkpoint过程
1、secondary namenode请求namenode是否需要checkpoint，或者条件触发进行同步
2、secondary namenode发送checkpoint请求
3、滚动正在写的edits文件及fsimages文件，拷贝到secondary namenode加载到内存并合并（采用http GET）
4、secondary namenode逐步执行edits文件中的操作生成新的fsimages快照文件并拷贝到namenode（http POST）
5、Namenode节点将新接收的fsimages文件替换旧的fsimages，步骤3产生新的edits.new文件替换旧的edits文件
HDFS写文件
1.客户端将文件写入本地磁盘的 HDFS Client 文件中
2.当临时文件大小达到一个 block 大小时，HDFS client 通知 NameNode，申请写入文件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/53eb3dcfbb4c210bcd4fe1a985d7c946/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf70f8e2554b813acdf1b2cb2bb1f18b/" rel="bookmark">
			JS原生——编写简易计算器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一个非常适合新手练习的小案例！！！ 使用JS的ES5语法+HTML+CSS及企业级代码规范，方便后续良好的代码习惯养成！！！ 先来看一下样式吧！！！（后附代码） 👇👇👇👇
一、设计思路 实现功能：加减乘除运输、清空、清空末位结构：整体使用table表格，按钮部分使用button给对应的属性值在JS中获取，输入框/输出框使用input给固定的长度及不可编辑。样式：可自行设计修改。逻辑：因为使用了eval()方法在首位及末位默认不可输入运算符，运算符的下一位不能是运算符。 二、关于代码规范方面需要注意的 在ES5中为防止代码命名污染全局。参照函数是独立作用域的原则使用立即执行函数形成独立的作用域即模块化编程。在ES5中不宜频繁操作DOM元素使用传参的方式传入获取父级，其他子级在父级下操作。创建 init（初始化函数）来统一管理其他函数。尽量遵照一个功能及一个函数原则可提起工具函数。（😳这个案例函数不复杂没做） 三、使用到的JS方法 基础的for循环。Number()转换数字格式。+=复合赋值运算符。.length获取字符串长度substr() 方法可在字符串中抽取从 start 下标开始的指定数目的字符。slice() 方法可通过指定的开始和结束位置，提取字符串的某个部分，并以新的字符串返回被提取的部分。 eval()将可运算的表达式进行运算。
四、代码部分 1、HTML &lt;div class="calculator"&gt; &lt;table&gt; &lt;tr&gt; &lt;td colspan="5"&gt;&lt;input type="text" class="result" disabled="disabled"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;button value="7"&gt;7&lt;/button&gt;&lt;/td&gt; &lt;td&gt;&lt;button value="8"&gt;8&lt;/button&gt;&lt;/td&gt; &lt;td&gt;&lt;button value="9"&gt;9&lt;/button&gt;&lt;/td&gt; &lt;td&gt;&lt;button class="del-button ac"&gt;AC&lt;/button&gt;&lt;/td&gt; &lt;td&gt;&lt;button class="del-button c"&gt;C&lt;/button&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;button value="4"&gt;4&lt;/button&gt;&lt;/td&gt; &lt;td&gt;&lt;button value="5"&gt;5&lt;/button&gt;&lt;/td&gt; &lt;td&gt;&lt;button value="6"&gt;6&lt;/button&gt;&lt;/td&gt; &lt;td&gt;&lt;button value="-" class="operator"&gt;-&lt;/button&gt;&lt;/td&gt; &lt;td&gt;&lt;button value="*" class="operator"&gt;*&lt;/button&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;button value="1"&gt;1&lt;/button&gt;&lt;/td&gt; &lt;td&gt;&lt;button value="2"&gt;2&lt;/button&gt;&lt;/td&gt; &lt;td&gt;&lt;button value="3"&gt;3&lt;/button&gt;&lt;/td&gt; &lt;td rowspan="2"&gt;&lt;button value="+" class="add operator"&gt;+&lt;/button&gt;&lt;/td&gt; &lt;td&gt;&lt;button value="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf70f8e2554b813acdf1b2cb2bb1f18b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1295a015f16c58228488e9ad899c9f5b/" rel="bookmark">
			编译Sophus报错: error: implicitly-declared 的参考解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、问题描述 自己在编译Sophus时遇到如下错误：
/home/wong/Datum/third_party/Sophus-1.0.0-template/Sophus-1.0.0/test/core/test_so2.cpp:82:31: error: implicitly-declared ‘Eigen::Map&lt;const Sophus::SO2&lt;double&gt; &gt;::Map(const Eigen::Map&lt;const Sophus::SO2&lt;double&gt; &gt;&amp;)’ is deprecated [-Werror=deprecated-copy] 82 | Eigen::Map&lt;SO2Type const&gt; const_shallow_copy = map_of_const_so2; 二、解决方法 在 CMakeLists.txt 中添加如下语句：
set(CMAKE_CXX_FLAGS "-Wno-error=deprecated-declarations -Wno-deprecated-declarations ") 这里是我添加之后的CMakeLists.txt
SET(PROJECT_NAME Sophus) PROJECT(${PROJECT_NAME}) CMAKE_MINIMUM_REQUIRED(VERSION 2.8) SET( CMAKE_VERBOSE_MAKEFILE ON) ################################################################################ # Release by default # Turn on Debug with "-DCMAKE_BUILD_TYPE=Debug" IF( NOT CMAKE_BUILD_TYPE ) SET( CMAKE_BUILD_TYPE Release ) ENDIF() set(CMAKE_CXX_STANDARD 14) IF("${CMAKE_CXX_COMPILER_ID}" STREQUAL "Clang") SET(CMAKE_CXX_FLAGS_DEBUG "-O0 -g") SET(CMAKE_CXX_FLAGS_RELEASE "-O3") SET(CMAKE_CXX_FLAGS "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1295a015f16c58228488e9ad899c9f5b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1d071d454568081300815ad978b1297/" rel="bookmark">
			tensorflow的GPU加速计算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考 tensorflow的GPU加速计算 - 云+社区 - 腾讯云
一、概述 tensorflow程序可以通过tf.device函数来指定运行每一个操作的设备，这个设备可以是本地的CPU或者GPU，也可以是某一台远程的服务器。tensorflow会给每一个可用的设备一个名称，tf.device函数可以通过设备的名称来指定执行运算的设备，比如CPU在tensorflow中的名称为/cpu:0。在默认情况下，即使机器有多CPU，tensorflow也不会区分它们，所有CPU都使用/cpu:0作为名称。而一台机器上不同为/gpu:0，第二个GPU名称为/gpu:1，以此类推。
tensorflow提供了一个快捷的方式来查看运行每一个运算的设备。在生成会话时，可以通过设置log_device_placement参数来打印运行每一个运算的设备。以下程序展示了如何使用log_device_placement这个参数。
import tensorflow as tf a = tf.constant([1.0, 2.0, 3.0], shape=[3], name='a') b = tf.constant([1.0, 2.0, 3.0], shape=[3], name='b') c = a + b # 通过log_device_placement参数来输出运行每一个运算的设备。 sess = tf.Session(config=tf.ConfigProto(log_device_placement=True)) print sess.run(c) ''' 在没有GPU的机器上运行以上代码可以得到类似以下的输出。 Device mapping: no known devices. add: (Add): /job:localhost/replacement/replica:0/task:0/cpu:0 b: (Add): /job:localhost/replacement/replica:0/task:0/cpu:0 a: (Add): /job:localhost/replacement/replica:0/task:0/cpu:0 [2. 4. 6.] ''' 在以上代码中，tensorflow程序会生成会话时加入了参数log_device_placement=True，所以程序会将运行每一个操作的设备输出到屏幕。于是除了可以看到最后的计算结果，还可以看到类似"add: (Add): /job:localhost/replacement/replica:0/task:0/cpu:0
"这样的输出。这些输出显示了执行每一个运算的设备。比如加法操作add是通过CPU来运行的，因为它的设备名称中包含了/cpu:0。
在配置好GPU环境的tensorflow中，如果操作没有明确地指定运行设备，那么tensorflow会优先选择GPU。比如将以上代码在亚马逊(Amazon Web Services, AWS)的g2.8xlarge实例上运行时，会得到类似以下的运行结果。
Device mapping: /job:localhost/replica:0/task:0/gpu:0 -&gt; device: 0, name: GRID K520, pci bus id： 0000：00：03.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d1d071d454568081300815ad978b1297/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ebe1e0a424b4f46eff205830935f801d/" rel="bookmark">
			JSP实现数据传递和保存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
掌握request和response的使用
获取表单提交的数据
get与post的区别
解决中文乱码
内置对象
内置对象request的其他方法
在请求中存取属性
转发与重定向
举个例子（在请求中存取属性，转发与重定向）
转发与重定向的区别
使用session对象保存用户名
session的工作方式
session会话的清除和过期
使用cookie自动填写用户名
application实现计数器
三个对象对比
掌握request和response的使用 获取表单提交的数据 通过内置对象request的getParameter（String name）方法，可以获取表单提交的数据，如下图：
创建一个jsp页面(userCreate.jsp)，如下图所示：
他的运行结果如下图
具体代码如下：
&lt;%@ page language="java" import="java.util.*" pageEncoding="UTF-8"%&gt; &lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt; &lt;html xmlns="http://www.w3.org/1999/xhtml"&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt; &lt;title&gt;用户注册&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;table class="tb" border="0" cellspacing="5" cellpadding="0" align="center"&gt; &lt;tr&gt;&lt;td align="center" colspan="2" style="text-align:center;" class="text_tabledetail2"&gt;用户注册&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt; &lt;td class="text_tabledetail2"&gt;用户名&lt;/td&gt; &lt;td&gt;&lt;input type="text" name="username" value=""/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ebe1e0a424b4f46eff205830935f801d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b31cf7752430becfbc9db0dd5b33b2d6/" rel="bookmark">
			联想笔记本重装系统按f几，教你重装如何进入bios
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		联想笔记本重装系统按f几进入bios呢？在给笔记本重装系统的时候，通常我们的方法都是用u盘制作系统盘。但有一个问题，就是u盘重装是需要先在电脑的bios上设置u盘启动项的，很多朋友不知道如何操作，这里就和大家讲讲联想笔记本重装系统按f几设置启动项吧。
方法：
大多数联想笔记本进入bios的快捷键是F12或Fn+F12，但是很多朋友操作的时候依然无法进入bios界面，很可能是操作的方法不对。正常来说在u盘插到电脑上，开机后就要连续不断的按快捷键，这样一般就能够进入到bios设置了。
进入到bios的启动管理菜单页面，我们可以用键盘的方向键控制光标进行移动，移动到EFI USB选项上然后按下回车键，这个选项就是uefi的引导模式。上方的USB HDD是legacy模式模式，注意别选到这个了。
操作完上述步骤后就能看到启动菜单了，在启动菜单里面选择boot menu然后回车，就能进入到u盘的启动模式了。
需要注意的是不同主板有不同的快捷键，如果你是其它型号的主板的话，快捷键就不一定是F12了，可以参考自己主板型号相应的常用快捷键，一般多试几个基本也都能进入bios界面。
最后要注意的是电脑重装系统默认会把C盘系统盘给格式化，所以C盘和桌面如果有重要文件的话一定要备份起来，其它盘正常操作下不会受到影响，但是如果操作不当也有风险，所以最好是全盘文件都用另一个u盘都备份一下。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51785848575b62bee613652436169ffa/" rel="bookmark">
			Windows下虚拟机VMwares安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 虚拟机作为工作以及学习的工具，是很多人必不可少的一款软件，今天就给大家讲一讲如何将虚拟机成功安装上系统，其中呢也将部分问题在文章中表达，因为很多人表示出现了一些问题，却没有办法解决，所以写了这一篇内容，同时对有需要的人可能也是一份助力！
接下来不多说了，直接进入主题，确认电脑的磁盘空间大于40-60G，准备一个 ISO系统文件，和VMware 虚拟机工具。系统可以在MSDN进行下载，VMware虚拟机工具 可以在其官网下载，建议下载 VMware Workstation PRO 16或者 VMware 15 X ，兼容性更好一些。小编使用的VMware Workstation PRO 16，同时下载了一个 windows 10 x64位系统。（需要win7 win8 什么都可以）两者的下载流程不做演示，比较简单。
如下是官网下载链接： https://customerconnect.vmware.com/en/downloads/#products_atoz
安装步骤 双击打开 VMware Workstation PRO 16 安装程序，等待片刻加载，即可进入此界面，并可以点击 下一步
一直默认下一步，可以于图三自己修改安装路径
输入秘钥，安装完成。
ZF3R0-FHED2-M80TY-8QYGC-NPKYF
YF390-0HF8P-M81RQ-2DXQE-M2UT6
ZF71R-DMX85-08DQY-8YMNC-PPHV8
至此安装完成
总结 1、进入官网 https://customerconnect.vmware.com/en/downloads/#products_atoz下载自己需要的vmware workstation 版本安装包。
2、点开安装包，一直默认下一步，根据需要修改安装路径。
3、安装完成。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d05682afabce579dca6f00845fd39d75/" rel="bookmark">
			使用yoloV3与视像头实现实时的目标检测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一部分：使用已有的模型实时监测目标 第一步：根据官网安装darknet框架Darknet: Open Source Neural Networks in C 第二步： 修改Makefie文件，由于我没有用到GPU，所以将GPU设置为0。按照我之前安装的opencv步骤安装opencv3.2.0，链接
再将OPENCV设置为1，如果没有安装opencv打开摄像头的时候会报错。
GPU=0
CUDNN=0
OPENCV=1
OPENMP=0
DEBUG=0
按照自己电脑的配置修改完Makefile文件之后，重新编译
cd darknet
make 运行程序：
./darknet detector demo cfg/coco.data cfg/yolov3.cfg yolov3.weights ./darknet detector demo cfg/coco.data cfg/yolov3-tiny.cfg yolov3-tiny.weights -c 1
第二部分：训练自己的图片集，可以参考网站：https://karbo.online/dl/yolo_starter/ 第一：下载所需要的训练集，参考官网
在script/目录下有有一个voc_label.py文件，内容如下，将此文件拷贝到darknet目录下。
import xml.etree.ElementTree as ET import pickle import os from os import listdir, getcwd from os.path import join sets=[('2012', 'train'), ('2012', 'val'), ('2007', 'train'), ('2007', 'val'), ('2007', 'test')] classes = ["aeroplane", "bicycle", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d05682afabce579dca6f00845fd39d75/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2492ac34a4f6502620a368e3596fb70/" rel="bookmark">
			【vue例子】vue实现侧边栏点击top，动画滚动到顶端
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 实现滚动页面的时候，显示侧边固定定位的top，点击top实现动画向上滚动到顶部 话不多说，直接上代码 &lt;a class="scroll-to-top" @click="toTop"&gt; &lt;i class="fa fa-angle-double-up"&gt;&lt;/i&gt; &lt;/a&gt; //样式可以自己写 &lt;script&gt; export default { data() { return { i: 0 } }, mounted() { window.addEventListener('scroll', this.handleScroll, true) }, methods: { // 点击滚动向上 handleScroll() { // 获取页面顶部的高度，要写！！这样页面滚动的时候才能获取到页面滚动距离顶部的高度 const scrollTop = document.documentElement.scrollTop || document.body.scrollTop const scrollBox = document.querySelector('.scroll-to-top') scrollTop &gt; 300 ? scrollBox.style.opacity = 1 : scrollBox.style.opacity = 0 // const scroll = scrollTop - this.i this.i = scrollTop }, toTop() { let top = document.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2492ac34a4f6502620a368e3596fb70/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a291dac0382e0fb400da374760bb36a6/" rel="bookmark">
			浅析磁传感器HALL、AMR、GMR、TMR技术（转载）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		磁传感器广泛用于现代工业、汽车和电子产品中以感应磁场强度来测量电流、位置、角度、速度等物理参数。在现有技术中，磁传感器包含霍尔（Hall）元件、各向异性磁电阻AMR（Anisotropic Magneto resistance， AMR）元件、巨磁电阻GMR（Giant Magneto resistance， GMR）元件及隧道磁电阻TMR（Tunnel Magneto Resistance）。
Hall元件是集成hall效益片的磁性敏感元件。有平面hall，也有垂直hall。 以霍尔元件为敏感元件的磁传感器通常使用聚磁环结构来放大磁场，提高霍尔输出灵敏度，从而增加了传感器的体积和重量，同时霍尔元件的功耗偏大，是mA级别的。
AMR元件其灵敏度（sensitivity）比霍尔元件高很多，但是其线性范围窄，容易磁饱和，同时以AMR为敏感元件的磁传感器需要设置Set/Reset线圈对其进行预设/复位操作，造成其制造工艺的复杂，线圈结构的设置在增加尺寸的同时也增加了功耗。
巨磁电阻GMR元件与AMR元件的结构不同，它由中间带隔离层的两层铁磁体组成。GMR相对于AMR有更好的灵敏度，且磁场工作范围更宽。
TMR（Tunnel Magneto Resistance）元件是近年来新型磁电阻效应传感器，其利用的是磁性多层膜材料的隧道磁电阻效应对磁场进行感应，比之前所发现并实际应用的AMR元件和GMR元件具有更大的电阻变化率。我们通常也用磁隧道结（Magnetic Tunnel Junction，MTJ）来代指TMR元件，MTJ元件相对于霍尔元件具有更好的温度稳定性，更高的灵敏度，更低的功耗，更好的线性度，不需要额外的聚磁环结构；相对于AMR元件具有更好的温度稳定性，更高的灵敏度，更宽的线性范围，不需要额外的set/reset线圈结构；相对于GMR元件具有更好的温度稳定性，更高的灵敏度，更低的功耗，更宽的线性范围。
下表是hall元件、AMR元件、GMR元件以及TMR元件的技术参数对比。
hall元件、AMR元件、GMR元件以及TMR元件技术，这四种技术原理上不同，各自都有自身的优势。HALL效益元件，主要有开关型hal、线性hall、三轴hall，主要应用于BLDC电机位置检测、速度传感器、位置检测、电流传感器、角度传感器、磁编码器、位置传感器等。覆盖上述所hall器件。 AMR、GMR与TMR主要应用于角度传感器，磁编码器 ，TMR技术性能比GMR有优势，TMA应工艺原因，价格稍高一点。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf4758f6266116decefcfabde3e994cf/" rel="bookmark">
			用MybatisPlus代码生成器生成代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者简介 作者名：编程界明世隐
简介：CSDN博客专家，从事软件开发多年，精通Java、JavaScript，博主也是从零开始一步步把学习成长、深知学习和积累的重要性，喜欢跟广大ADC一起打野升级，欢迎您关注，期待与您一起学习、成长、起飞！QQ群：798379137，欢迎大家加入！
【特别注意】适用版本：mybatis-plus-generator 3.5.1 以下版本
一、创建Springboot项目 在之前的IDEA专栏中，已有文章【创建Springboot项目】，就不另外说明了。
二、导入相关依赖 打开pom.xml 填入以下依赖
&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.4.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt; &lt;version&gt;3.4.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.freemarker&lt;/groupId&gt; &lt;artifactId&gt;freemarker&lt;/artifactId&gt; &lt;version&gt;2.3.30&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.6&lt;/version&gt; &lt;/dependency&gt; 三、拉代码生成器代码 直接到【官网拉代码】
注意的地方：
全局配置里面的路径数据源的配置包配置里面的模块配置（默认配置也可以修改） pc.setParent("com.wms") .setEntity("entity") .setMapper("mapper") .setService("service") .setServiceImpl("service.impl") .setController("controller"); 策略配置里面父类相关可以删除 四、配置数据库连接 yml server: port: 8090 spring: datasource: url: jdbc:mysql://localhost:3306/ming?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false&amp;serverTimezone=GMT%2B8 driver-class-name: com.mysql.jdbc.Driver username: root password: root Logging: level: com.wms: debug 五、建表 DROP TABLE IF EXISTS `user`; CREATE TABLE `user` ( `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '主键', `no` varchar(20) DEFAULT NULL COMMENT '账号', `name` varchar(100) NOT NULL COMMENT '名字', `password` varchar(20) NOT NULL COMMENT '密码', `age` int(11) DEFAULT NULL, `sex` int(11) DEFAULT NULL COMMENT '性别', `phone` varchar(20) DEFAULT NULL COMMENT '电话', `role_id` int(11) DEFAULT NULL COMMENT '角色 0超级管理员，1管理员，2普通账号', `isValid` varchar(4) DEFAULT 'Y' COMMENT '是否有效，Y有效，其他无效', PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8; 六、生成代码 右键代码生成器类，点击执行，在终端控制台输入对应的表名
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf4758f6266116decefcfabde3e994cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dda1e05fa3986d582b17c03024ae1a35/" rel="bookmark">
			[Cortex-M3]-2-map文件解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[Cortex-M3]-1-启动流程-启动文件[Cortex-M3]-2-map文件解析[Cortex-M3]-3-分散加载文件解析（.sct）[Cortex-M3]-4-如何在内嵌RAM中运行程序 目录
1 几个问题
1.1 什么是map文件
1.2 如何查看编译出的程序和数据的信息
1.3 如何生成map文件
1.4 map文件里面有哪些信息
2 map文件信息详解
2.1 Section Cross References 2.2 Removing Unused input sections from the image 2.3 Image Symbol Table 2.4 Memory Map of the image 2.4.1 几个重点部分 2.4.1 详细内容标题 2.5 Image component sizes 1 几个问题 1.1 什么是map文件 map文件就是通过编译器编译之后，程序、数据及IO空间的一种映射文件。
一般情况下，遇到内存越界，或者是溢出等情况，可以先进行map文件的分析。因为从map文件，可以了解到一些函数的大小，以及其入口等等重要信息。
1.2 如何查看编译出的程序和数据的信息 以上的编译log即能表现出编译出的程序和数据的信息，其实这些数据都是一些单模块的汇总，在map文件里面都有详细描述。
1.3 如何生成map文件 需要对输出信息进行配置，接下来对工程进行百编译，即可生成map文件
主要包含配置：
Memory Map：内存映射
Callgraph：图像映射
Symbols：符号
Cross Reference：交叉引用
Size Info：大小信息
Totals Info：统计信息
Unused Section Info：未调用模块信息
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dda1e05fa3986d582b17c03024ae1a35/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed8f26b00e582317f3491d6b14333d15/" rel="bookmark">
			五个分层维度：SpringBoot工程分层实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		欢迎大家关注公众号「JAVA前线」查看更多精彩分享文章，主要包括源码分析、实际应用、架构思维、职场分享、产品思考等等，同时欢迎大家加我微信「java_front」一起交流学习
1 分层思想 计算机领域有一句话：计算机中任何问题都可通过增加一个虚拟层解决。这句体现了分层思想重要性，分层思想同样适用于Java工程架构。
分层优点是每层只专注本层工作，可以类比设计模式单一职责原则，或者经济学比较优势原理，每层只做本层最擅长的事情。
分层缺点是层之间通信时，需要通过适配器，翻译成本层或者下层可以理解的信息，通信成本有所增加。
我认为工程分层需要从五个维度思考：
(1) 单一 每层只处理一类事情，满足单一职责原则
(2) 降噪 信息在每一层进行传输，满足最小知识原则，只向下层传输必要信息
(3) 适配 每层都需要一个适配器，翻译信息为本层或者下层可以理解的信息
(4) 业务 业务对象可以整合业务逻辑，例如使用充血模型整合业务
(5) 数据 数据对象尽量纯净，尽量不要聚合业务
1.2 九层结构 综上所述SpringBoot工程可以分为九层：
工具层：util整合层：integration基础层：infrastructure服务层：service领域层：domain门面层：facade控制层：controller客户端：client启动层：boot 2 分层详解 创建测试项目user-demo-service：
user-demo-service -user-demo-service-boot -user-demo-service-client -user-demo-service-controller -user-demo-service-domain -user-demo-service-facade -user-demo-service-infrastructure -user-demo-service-integration -user-demo-service-service -user-demo-service-util 2.1 util 工具层承载工具代码
不依赖本项目其它模块
只依赖一些通用工具包
user-demo-service-util -/src/main/java -date -DateUtil.java -json -JSONUtil.java -validate -BizValidator.java 2.2 infrastructure 基础层核心是承载数据访问，entity实体对象承载在本层。
2.2.1 项目结构 代码层分为两个领域：
player：运动员game：比赛 每个领域具有两个子包：
entitymapper user-demo-service-infrastructure -/src/main/java -player -entity -PlayerEntity.java -mapper -PlayerEntityMapper.java -game -entity -GameEntity.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed8f26b00e582317f3491d6b14333d15/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/442bdf5b3366bfeab281448f7d5dbc60/" rel="bookmark">
			优化 ｜ 线性规划的历史、模型及案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：李崇楠，北京交通大学研究生在读，交通运输规划与管理专业，研究方向：运输组织优化
本文为《线性规划入门电子书》第一章内容。《线性规划入门电子书》是「运筹OR帷幄」优化理论科普丛书系列的第一本，已上线Github，欢迎亲朋好友们一睹为快！
本章带领读者走进线性规划的世界。首先介绍线性规划的历史，读者将了解到在线性规划领域作出杰出贡献的学者及其成就 ；接下来的内容为线性规划的基本概念 ，模型假设和“标准形”，并介绍了将一个一般的线性规划模型转化为标准形的技巧；最后给出了若干线性规划案例。
1. 线性规划的历史 1939年，苏联学者Kantorovich为前苏联政府解决优化问题时提出了极值问题，并且提出了解乘数法的新方法，可惜他的工作在当时并未引起足够的重视。事实上，他所提出的问题正是线性规划的雏形。
与此同时，美国的线性规划却获得了飞快的发展。1941年，Hitchcock提出运输问题；1945年，Stigler提出了营养问题；1945年，Koopmans提出了经济问题。而奠定线性规划整套理论方法的，还要说是G.B.Dantzig，他被誉为“线性规划之父”。他在1947年担任美国空军审计官的数学顾问，为找到解决问题的机制化工具，提出了“在一组线性方程或不等式约束下，求某一线性形式极小值问题的数学模型”，这便是“线性规划”（linear programming）这一经典优化模型。而“线性规划”这一名字的由来是在之后1948年，Koopmans和Dantzig在海滩散步时共同想出的。1947年夏天，Dantzig提出了单纯形算法。这个算法在后来被评为20世纪最伟大的算法之一。
尽管单纯形法(Simplex method)作为解决线性规划的有效方法在学术界具有统治地位，但是1971年，Klee和Minty两位学者构造出一个例子，该例子下单纯形法的运作需要访问指数数量级别的顶点，也就是说，在最坏情况下，单纯形法是一个指数时间算法(exponential-time algorithm)。Dantzig在得知这个消息后感叹到他的噩梦到来了，单纯形法并不是在任何情况下都是高效可行的。那么，是否有更加高效的算法，比如多项式时间算法(polynomial-time algorithm)，来解决线性规划问题呢？8年后，即1979年，L.G.Khachiyan发明了椭球算法(ellipsoid method)，这是第一个解决线性规划问题的多项式时间算法。但是，这个算法虽然理论上是多项式时间运行，但是算法被证明是不切实际的，这个算法的杰出贡献是在理论层面告诉世人，线性规划是可以用多项式时间算法来解决的，同时也启发了学者在更加深入的优化领域进行算法开发。1984年，N.Karmarkar发明了内点算法(interior point method)，这是线性规划第一个实际可用的多项式时间算法。
2. 线性规划模型 2.1 基本概念 线性规划是一类经典的优化模型。与一般的优化模型类型，线性规划模型也有目标函数，决策变量和约束条件。那决定这个优化模型是线性规划的因素是什么呢？下面我们将以一个例子展开介绍。
上述模型为典型的线性规划模型，式(1.1)是目标函数， 是决策变量，式(1.2)-(1.4)为约束条件，其中式(1.2)和式(1.3)为线性约束，式(1.4)为非负约束。可以发现，对线性规划模型而言，目标函数和约束条件都是线性函数。线性函数可以理解为每一项未知数(变量)的最高次数为1，即不会出现等未知数次数超过1的情况。
2.2 模型假设 线性规划作为一类数学模型，含有以下三种假设：
1.比例假设
在线性规划中，目标函数的系数是固定的常数，但是在现实生活中不见得如此，比如考虑目标函数是计算采购蔬菜计划的总花费。那么可能会面对“2元钱1个，3元钱2个”的这种促销，这时线性规划的目标函数就无法表示。
2.非负假设
线性规划的决策变量要求时非负数，但是不要求是非负整数，所以可以取小数。这同样有局限性，依然以采购蔬菜的问题为例，如果需要买土豆，但是土豆只能按整袋来卖的话，那么表示买土豆数量的决策变量就只能取整数了。
3.确定性假设
线性规划中像是目标函数的系数，线性约束中的常数与决策变量的系数，都是已知且保持不变的常数。但是有些参数在实际中是会变化的，通常参数变化的范围是已知的，这就涉及到鲁棒优化(robust optimization)、随机优化(stochastic optimization)等领域的内容了。
2.3 线性规划的标准形 在线性规划中，根据目标函数是试图取得最大还是取得最小，能够分成“最大化问题”与“最小化问题”两种问题。此外，线性约束根据决策变量的线性表达式和常数项之间的连接符为“大于等于”“等于”“小于等于”，又可以分为“大于等于约束”“等于约束”“小于等于约束”。因此，线性规划可以有不同的形式，这不利于定理、算法的表示及推导。为解决这一问题，引入线性规划的标准形。
观察上面的模型可以看到，线性规划的标准形具有如下特点：
（1）目标函数要取得最大值
（2）所有的决策变量都要满足非负约束（nonnegativity constraint）
（3）线性约束均为等式约束（equality constraint）
如果有一个非标准形的线性规划，那么如何等效地转化为标准形呢？这里要强调所谓“等效”的概念，即最优解是不变的，或转化后问题的最优解能够通过一定的方式推出原问题的最优解。
下面我们介绍将一个线性规划模型转换为标准形式的技巧。
3. 线性规划标准形式的转换技巧 针对如下线性规划问题，我们将使用一些技巧，将它转化为线性规划模型的标准形式。
与标准形进行对比，观察到有如下的差别：
（1）目标函数是最小化，而不是最大化。
（2）线性约束中有大于等于约束，有小于等于约束。
（3）决策变量无约束，我们称之为自由变量。
（4）目标函数含有绝对值项，这是一个很难处理的要点，需要一定技巧才能化解。
下面逐一介绍转化为标准形的技巧。
1.目标函数最大化
针对目标函数是最小化的模型，我们可以将原问题的目标函数乘以负一，并最大化这个新的目标函数。在本例中，目标函数可以转化为
2.消除不等式约束
我们可以看到第一个约束条件是“小于等于约束”，第二个约束条件是“大于等于约束”。在这里我们分别引入松弛变量（slack variable）进行转化。松弛变量均满足非负约束。对“小于等于约束”，我们加上一个松弛变量；对“大于等于约束”，我们减去一个松弛变量。这样两个不等式约束都转换成了等式约束：
3.消除自由变量
在本例中，变量没有约束。针对这类无约束变量，我们需要引入两个非负变量来表示它：。但是这个例子的目标函数中，对取绝对值，所以此处对的转换还需要进一步的操作。
4.消除绝对值符号
在转换的时候，我们需要对绝对值符号内的项进行正负号判断，将原本含有绝对值符号的式子拆分成两个不含绝对值符号的式子。考虑到绝对值符号可能出现在目标函数中，也可能出现在约束条件中，接下来我们给出两种示例。
(1)目标函数中有绝对值符号
本例中目标函数值的第三项含有绝对值符号,其中为自由变量。我们引入两个变量,定义为:
由变量定义可知，一定都是非负的，并且,。读者可以令取某一具体的数值来验证。 (2)约束条件中有绝对值符号
如有以下约束。可以将其转化为：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/442bdf5b3366bfeab281448f7d5dbc60/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21ede81f2591d2b529fc24b9c783361b/" rel="bookmark">
			uni-app云开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		uniCloud 是 DCloud 联合阿里云、腾讯云，为开发者提供的基于 serverless 模式和 js 编程的云开发平台。
云开发web控制台地址 https://unicloud.dcloud.net.cn
开发成本大幅下降、开发效率大幅提升、上线和迭代速度大幅提速；如果你是新创公司，将无需雇佣php或java等服务器工程师，每年至少节省几十万；如果你已拥有掌握php和js的全栈，那么改用新的技术栈，一样可以大幅提升开发效率、降低成本；你只需专注于你的业务，其他什么服务器运维、弹性扩容、大并发承载、防DDoS攻击，全都不需要操心；除了开发成本，云资源租用成本也将大幅下降如果不发布Web版，你将不需要购买备案域名。小程序和App可以免域名使用服务器； uni-app的使用 --- 创建一个云函数项目
--- 代码里边的各项内容
--- 关联云服务空间
在关联云服务空间时候必须要先登录HBuilder而且注册云空间的开发者
--- 在控制台操作
第一次进入需要创建账号，并且需要申请开发者，在申请完开发者，接着创建云空间
--- 在云函数库里创建一个空云函数表【JSON格式】
点击上边的名字后进入这个页面，如果需要一个空的云函数表则无需选择其他，填入名称A后点击创建
--- 创建第一条数据
创建第一条数据的时候，需要注意，这里的数据是json格式的
--- 配置表结构
注意：如果要实现增删改查，需要在里边的false变为true
在配置表结构时，需要注意前边你创建第一条数据时写了那些数据名称，例如name，tel需要在表结构中显示，否则会导致你使用的时候值没有出现。
--- 使用云空间
在关联时如果没有这个名称，需要你去创建，点击新增会跳转到创建页面。
--- 页面创建云函数
在index.js里边
'use strict';
exports.main = async (event, context) =&gt; {
//event为客户端上传的参数
console.log('event : ', event)
//返回数据给客户端
return {...event,msg:"来自云空间的问候"}
}; 在pages/index.vue里边【运行在内置浏览器】
&lt;template&gt;
&lt;view class="content"&gt;
&lt;button @click="call"&gt;呼叫服务器&lt;/button&gt;
&lt;unicloud-db ref="udb"
v-slot:default="{data, loading, error, options}" collection="concat"&gt;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21ede81f2591d2b529fc24b9c783361b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22f5ba17e1095127d5e2cc9ab2fa7eac/" rel="bookmark">
			工业级数据分发服务DDS之安全篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 引出问题分析问题解决问题官方标准安全插件域级安全域内安全基于RTPS协议的安全 RTI方案安全插件的特性支持的加解密算法用于数据流保护的密码算法用于密钥交换的密码算法用于数字签名的密码算法RTPS-HMAC-Only插件用于数据流保护的加密算法 分布式系统安全参考声明 引出问题 在DDS系统中，我们在以数据为中心的发布-订阅模型中有一组发布者和订阅者。例如，让我们分析下图所示的系统，其中我们有以下节点:
Alice：发布Topic-T的合法应用程序，允许发布信息。Bob：订阅Topic-T的合法应用程序，允许访问信息。Eve：未经授权订阅Topic-T的窃听者，执行未经授权的订阅（1）。Trudy：未经授权发布数据的入侵者，执行未经授权的发布（2）。Mallory：一个恶意的内部人员(例如，被授权订阅数据但不能发布)，试图执行篡改和重播（3）。Trent：合法订阅和发布数据的监控服务。
因为AliceBob和Trent是合法的应用程序，所以它们应该能够按照设计的方式进行通信。而对于非法程序Eve和Trudy，他们是不能执行任何操作的。但是这里面的Mallory是系统内部人士，只有有限权限，那么他就不能做未经授权的操作。
分析问题 未授权订阅者
未经授权的订阅(又称窃听)意味着能够在未经授权的情况下读取敏感数据。
首先以Eve为原型，解释未经授权的窃听者，说明Eve能够在未经授权的情况下读取到敏感数据。假设Eve是系统之外的一个节点，他本不应该出现，也不应该获取到系统中的任何数据，但是在一个不安全的网络中，Eve和Alice可以实现发布订阅。由于DDS和RTPS标准没有专门解决安全性问题，所以没有定义任何机制来验证Eve是否被授权订阅Topic-T。
窃听有时候并不会造成严重的后果，但是当Topic-T携带非常敏感的数据时，就必须对他进行保护，防止窃听。
未授权发布者
未经授权发布是指未经授权将数据发布到DDS系统中。
以Trudy为原型，一个可以发布Topic-T数据的发布节点。在一个不安全的场景中，Trudy和Bob会互相发现对方，然后Trudy会开始向Bob发送数据。因此Bob会收到Alice的数据，也会收到Trudy的数据，这样的系统存在很大的安全隐患。
截胡篡改
篡改包括在将数据发送给合法订阅者之前拦截和修改数据。
当系统中存在敏感信息时，Mallory可以截胡消息，并对其进行修改，然后再发不出去，由于Bob分不清消息的来源是否可靠，造成严重的问题。
当Mallory订阅系统中的主题Topic-T，那么他就可以将消息以高频率发不出去，造成Bob严重的资源消耗，甚至是宕机。
跨域攻击
如果监控服务加入一个被恶意domainparticipant攻击的域，上述所有威胁都可能跨越DDS域。
解决问题 引入安全插件：
安全插件提供了保护数据机密性的机制，保证只有经过授权的订阅者才能订阅Topic-T并解析发布给它的数据。安全插件提供了认证发布者和订阅者应用程序的机制，防止来自外部的未经授权的发布。此外，安全插件设置了访问控制机制，以防止未经授权的发布者。安全插件设置了保护数据完整性的机制，从而可以防止篡改和攻击。 官方标准 为了解决DDS安全的问题，OMG定义了DDS安全规范标准，该规范为符合DDS的实现定义了安全模型和服务插件接口(Service Plugin Interface)服务体系框架。DDS安全模型是通过DDS实现调用服务插件接口来实现的。
规范中服务插件接口，支持即插即用的安全性，并且能够实现DDS应用程序之间互操作。
服务插件接口允许用户自定义DDS框架中用于信息保证的行为和技术，例如，自定义身份验证、访问控制、加密、消息身份验证、数字签名、日志记录和数据标记等。
认证服务插件，认证DDS应用程序，包括在参与者之间执行相互身份验证和建立共享秘密的功能。访问控制服务插件，对域、主题等实施访问控制。加密服务插件，维护数据的完整性和机密性，包括加密、解密、哈希、数字签名等。日志服务插件，支持审计所有DDS安全相关的事件。数据标记服务插件，提供向数据添加标记的方法。 安全插件 DDS安全插件主要实现两个方面的保护。其一是域级安全防护，保护DDS域免受外来者的攻击。其二是域内安全防护。
域级安全 域级安全是一个相当简单的模型，将安全范围控制在域内，由开发者或维护者决定域的成员，被包含在域内的成员在域内允许执行任何被授权的操作。域内成员对topic的访问权限也由其域身份所决定。但是站在域的内部看，域内就像是一个没有经过安全防护的网络。此安全协议的目标是防止出现未经授权的域参与者的出现（在不考虑域内访问控制规则的情况下）。
基于域的安全防护可以达到如下效果：
1）检测针对消息的篡改和注入，即完整性保护;
2）保护消息内容，及加密性保护；
关于域级别的安全防护需要明确的一点是，域级别的安全防护一般通过TLS 或 DTLS来实现，即通过传输层的安全特性来实现安全域。
域内安全 域内安全遵循最小权限原则(Principle of Least Privilege)，提供了更高级的保护类型，这意味着参与者为了完成任务，不能做未经授权的事情。最小权限原则基于每个主题和分区的读写访问规则。在定义这些访问规则之后，安全插件将约束对每个topic和partition的读、写权限。
上面图，其中三个参与者(P1、P2和P3)拥有发布和订阅蓝色主题的权限，而只有P1对红色Topic有发布和订阅权限——P2对蓝色主题有订阅权限，但P3没有访问它的权限。这个场景表明，域内部的保护适用于特定的主题和分区，并不是每个DomainParticipant都被允许发布或订阅每个主题或分区。可以分别为每个主题或者分区设置访问规则，进而实现机密性和完整性的要求。因此，对于每个域，都可以根据需要在每个主题或每个分区上配置不同的防护规则。
基于RTPS协议的安全 为了防止在域中出现未经授权的操作，DDS安全规范对RTPS协议进行了安全增强。由于开放的网络，任何人都可以加入其中并开始接收数据，因此惟一可用的保护机制是保护RTPS消息本身。
安全插件将添加信息并修改RTPS消息以保护它们。在RTPS级别应用的所有保护都基于对称加密，这是一次性加密一对多分发所必需的。因此，发送方和接收方都需要知道密钥。身份验证过程结束后，参与者交换密钥，使用Diffie-Hellman（一种确保共享KEY安全 穿越 不安全网络的方法，它是OAKLEY的一个组成部分。）建立共享秘密。对于身份验证，参与者使用非对称密码学。
完整性保护
通过向原始消息追加消息验证码(MAC)来保护消息的完整性。默认情况下，该代码的长度为16字节。MAC的内容取决于原始消息的内容以及密钥。您需要密钥来创建和验证MAC。因此，发送方和接收方都需要知道密钥。发送方和所有接收方都使用相同的密钥。如果在接收端验证MAC失败，就意味着数据完整性遭到了破坏。
机密性保护
MAC提供完整性保护，因此攻击者将无法篡改数据，因为对数据的修改将被检测为未能通过MAC验证。然而，MAC本身不保护机密性。如果需要保密，则必须在数据通过网络发送之前对其进行加密。加密字节由消息和密钥生成。因此，发送方和接收方都需要知道相同的密钥。
加密本身并不能保证数据的完整性。因此，安全插件计算经过加密的数据的MAC，并将其包含在结果消息中。在实践中，DDS安全规范定义了完整性保护和机密性以及完整性保护。
遵循OMG数据分发服务(DDS)标准的理念，DDS安全规范遵循以数据为中心的模型，其中所有内容都是分布式的。这意味着所有加入DDS域的合法参与者都将执行所需的保护。这就是它们彼此之间可以进行通信的方式(它们执行相同类型的保护)，同时阻止外部人员参与(因为这种保护)。换句话说，如果一个参与者不执行所需的保护，它将无法与安全域中的其他参与者通信。
来源认证保护
还可以强制数据源身份验证。例如，如果您有一个与多个datareader匹配的DataWriter，那么所有的读取器都从同一个写入器接收数据。因此，所有的读取器都需要知道用于加密和解密数据以及计算和验证MAC的相同的秘密密钥。如果这个秘密密钥在数百个读取器之间共享，那么所有这些读取器都拥有重现MAC的加密和计算的知识，因为该密钥与写入器使用的密钥相同。换句话说，读取器可以冒充写入器，从而破坏访问控制机制。如果读者之间互不信任，您可以设置来源身份验证保护。
这种类型的保护需要在系统中使用额外的密钥。更具体地说，除了发送方密钥之外，每个发送方-接收方对还将有一个特定于接收方的密钥。注意，datawriter和datareader都可以充当发送方和接收方。此外，RTPS消息和子消息将附加额外的mac(每个接收器一个)。
在前面的例子中，DataWriter将附加一个包含额外的特定于接收器的MAC的列表到通用MAC。然后，在常规的通用MAC验证之后，每个DataReader必须在该列表中找到它的特定于接收器的MAC，并验证特定于接收器的MAC是用它专门为自己和DataWriter之间使用而创建的秘密密钥计算的。通过验证公共MAC, DataReader可以相信数据没有被任何没有发送方密钥的人篡改过，因为生成公共MAC需要这个密钥。通过验证接收方特定MAC, DataReader可以验证发送数据的匹配DataWriter，因为它是与接收方特定密钥共享的唯一实体。
RTI方案 RTI DDS通过安全插件的机制实现诸如认证、加密等安全功能。安全插件支持可插拔的方式满足数据总线安全要求，每个安全插件覆盖不同的安全范围,主要包含以下几个方面：
身份认证：提供针对调用DDS接口的应用程序或用户的身份认证。还包括通信双方相互认证和共享密钥的基础设施；访问控制：提供针对DDS实体可执行操作的访问控制决策；数据加解密：实现加解密算法、hash算法、签名算法等。还包括从共享密钥衍生密钥的算法；日志记录：审计所有安全相关的事件，以此增强系统的透明度，保证系统的可用性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/22f5ba17e1095127d5e2cc9ab2fa7eac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9f636eb7c6aab36136fcde53e38c3c4/" rel="bookmark">
			（超简单可复制）Python实现：有四个数字1、2、3、4，能组成哪些互不相同且无重复数字的三位数？各是多少？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文只回答有哪些，而不回答有几个，因为作者不会。所谓超简单是作者认为的超简单，因为作者很菜。
一、代码 for i in range(1,5):
for j in range(1,5):
if j==i:continue
for k in range(1,5):
if k==j or k==i:continue
else:
print("{0:},{1:},{2:}".format(i,j,k),end='/')
print()
二、说明 1. 3个for循环，因为有3位数
2.range(1,5)，因为是4个数字1，2，3，4，而range取不到最后一位
2. 2个if，并且用continue结束当次循环，因为3位数本身3个数字不能重复
3. end='/'，因为要分隔各个3位数
4."{0:},{1:},{2:}".format(i,j,k)，分号左侧0，1，2说明i，j，k放入的顺序，不然报错
*5.print()，因为要换行
三、输出 1,2,3/1,2,4/1,3,2/1,3,4/1,4,2/1,4,3/
2,1,3/2,1,4/2,3,1/2,3,4/2,4,1/2,4,3/
3,1,2/3,1,4/3,2,1/3,2,4/3,4,1/3,4,2/
4,1,2/4,1,3/4,2,1/4,2,3/4,3,1/4,3,2/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d60564ca1d237dbf16e862649713b059/" rel="bookmark">
			一个死锁问题分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题： 源程序来源于GItHub:recipes/Factory_deadlock.cc at master · chenshuo/recipes (github.com)
加了编译选项REPRODUCE_BUG后会导致死锁，为什么会死锁呢？
个人分析： 这个程序一开始没有看懂，主要是有个知识点自己忽略了：
对象的析构是同步的，当最后一个指向x的shared_ptr离开其作用域的时候，x会同时在同一个线程析构。这个线程不一定是对象诞生的线程。
主要过程为：
main线程创建了一个Stock对象叫MS，该对象地址为0x56354caa90c0由于该对象的引用计数为0，于是立即调用定制的析构函数deleteStock主线程在deleteStock中会休眠500毫秒，此时thrB线程创建了一个Stock对象也叫MS，该对象地址为0x7f3020000b20，这个对象覆盖了之前main线程创建的对象在哈希表中的位置。main线程从休眠中醒来，继续执行，发现此时指向thrB线程创建的Stock对象的引用计数值为2。main线程再次休眠500毫秒。thrB线程执行结束，发现其创建的Stock对象的引用计数值为1（在main线程中），所以该对象不会在thrB中析构。main线程从休眠中唤醒，发现此时指向thrB线程创建的Stock对象【0x7f3020000b20】的引用计数值为1。离开作用域后，引用计数为0，这个对象要在main线程中被析构。main线程里面再次调用定制的析构函数deleteStock，于是导致死锁。 main: Stock[0x56354caa90c0] MS main: stock 0x56354caa90c0 main: deleteStock[0x56354caa90c0] thrB: Stock[0x7f3020000b20] MS thrB: stockB 0x7f3020000b20 use_count = 2 thrB: stockB destructs use_count = 1 main: deleteStock[0x7f3020000b20] WARNING: mutex_ is already locked by this thread, deadlock will happen. 如果没有互斥锁的话，结果会这样：
main: Stock[0x55c6ae0d40c0] MS main: stock 0x55c6ae0d40c0 main: deleteStock[0x55c6ae0d40c0] thrB: Stock[0x7fa980000b20] MS thrB: stockB 0x7fa980000b20 use_count = 2 thrB: stockB destructs use_count = 1 main: deleteStock[0x7fa980000b20] main: ~Stock[0x7fa980000b20] MS main: ~Stock[0x55c6ae0d40c0] MS main :~Thread 参考文献： C++ shared_ptr相关技术 - 简书 (jianshu.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d60564ca1d237dbf16e862649713b059/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56f2e0b00f7b38b37c937708e5fa8f15/" rel="bookmark">
			第7讲 | 流程驱动与机器人流程自动化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有了来自流程挖掘和分析技术的洞察力诊断，下一个重要步骤就是流程所有者可以将这些诊断转化为实际行动来改进流程。
目录
1、 流程驱动
2、机器人流程自动化
3、RPA的应用示例
1、 流程驱动 流程驱动是面向业务行为的流程挖掘
流程挖掘提供了从信息系统的可用事件数据中提取流程知识的技术，这项技术已成功应用于不同行业来解决流程相关的问题。近年来，流程挖掘学科的重点逐渐转向支持持续的流程管理和实际的流程改进。相关技术也逐渐成为研究热点，例如预测性监控技术可用于监测和影响正在运行的案例。然而，从有见地的诊断到实际行为的转换依然需要用户进行处理（即"行为部分"缺失，超出了当今流程挖掘工具的范围）。为此，流程驱动（以行为为导向的流程挖掘）支持可操作流程的持续管理和操作的自动执行，以改进流程。
面向业务行为流程挖掘的必要性
可操作流程是全天候进行的，因此需要持续的流程管理。为了正确管理操作流程，必须重复应用流程挖掘技术，而不是仅仅关注流程挖掘诊断的一次性报告。这种重复的应用不仅可以识别更多相关的问题，还可以在动态变化的环境中持续改进操作流程。相反，一次性报告可能在当前情况下关注的问题比较片面，也无法处理新出现的问题。
如何实现流程驱动？
一般来说面向业务行为的流程挖掘技术框架包含两个组件：（1）约束监视器，它可以将事件流转换为约束实例流。此类实例描述了是否违反约束的情况。（2）行动引擎，它可以将约束实例流转化为行为实例流，其中每个行为实例描述信息系统要执行的事务，以便减轻违规行为造成的风险。通过上述两步的操作就实现了流程挖掘驱动的实际运营。
2、机器人流程自动化 什么是自动化？
自动化描述了减少人为干预流程的广泛技术。通过预先确定决策标准和相关操作并让机器执行它们，减少了人类的工作量。自动化使用控制系统来操作设备，如机械、工厂流程，锅炉、电话网络的切换，船舶、飞机的转向和稳定等，从而最大限度地减少人为干预。
机器人流程自动化
机器人流程自动化(Robotic Process Automation, RPA)是一种自动化业务流程的软件技术，其目的是代替人类完成简单、重复的工作以提高工作效率、减少失误操作。利用这项技术，人们可以构建、部署和管理机器人来模仿人类与计算机进行交互。机器人可以理解数字显示器上的内容、执行打字操作、进行导航系统，还可以完成一些常规工作。RPA是一项有益的技术，因为机器人可以比人更快、更稳定地执行各种任务。
RPA优点
- RPA简化了工作流程，使组织变得灵活且响应迅速。
- RPA是非侵入性的，可以快速实施，以加速数字化转型。
- 机器人通常成本低且易于实施，无需自定义软件或深度系统集成。
自动化—流程挖掘
如何通过流程挖掘改善自动化是流程挖掘产业的重要课题
自动化系统可能会不时的面临瓶颈，识别瓶颈并提高性能是使用流程挖掘可以解决的挑战之一。通过合规性检查，可以根据自动化流程中生成的实时日志来检测自动化运行过程中的合规性。因此，自动化流程执行中出现的任何瓶颈都可以得到改善。
3、RPA的应用示例 以李某为例，他是一家金融机构的基金经理。他有一个简单的日常任务，需要查询公司的所有计费系统并复制信息，使所有的工作系统反映相同的数据。他的工作很简单确很乏味，也容易出现许多人为失误。因此公司现在想找到一种方法，使这个过程自动化，以便系统及时准确地更新所有的信息。
上述任务可以通过RPA轻松处理。RPA提供与不同信息系统互动的代理，从而部分地取代人类。使用人工智能（AI）和机器学习（ML），可以以一种相当稳健的方式完成。例如，当一些应用程序的网络界面改变时，RPA代理应继续正常工作。AI/ML的使用有助于解释不断变化的界面，从而与传统的 "屏幕截取"（也称为Web抓取或Web收集）有很大不同。另外，AI/ML还可以模仿人类在组合不同应用程序时的行为（即自动配置解决方案）。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/957e6173770ff6ce120929ba4716eba3/" rel="bookmark">
			guava本地缓存CacheLoader使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近代码里看到有部分关于guava写本地缓存的，学习记录一下。
首先guava的本地缓存可以理解成一个缓存map，以kv的形式存数据，不会持久化，没有支持分布式。比redis使用起来方便，不用引入额外的组件。如果是单机缓存的话，可以首先选择使用这种缓存方式。
Guava cache的设计来源于CurrentHashMap，是线程安全的，可以按照多种策略来清理存储在其中的缓存值且保持很高的并发读写性能。常见应用场景：对性能有非常高的要求、不经常变化、占用内存不大、有访问整个集合的需求、数据允许不时时一致。
Guava cache的优点 多种清理和淘汰策略
支持并发（采用Segment做分区，线程安全）
更新锁定（对同一个key，只让一个请求去读源并回填缓存，其他请求阻塞等待）
集成数据源（一般我们在业务中操作缓存，都会操作缓存和数据源两部分GuavaCache的get可以集成数据源，在从缓存中读取不到时可以从数据源中读取数据并回填缓存）
使用方法 引入依赖
&lt;dependency&gt; &lt;groupId&gt;com.google.guava&lt;/groupId&gt; &lt;artifactId&gt;guava&lt;/artifactId&gt; &lt;version&gt;30.1.1-jre&lt;/version&gt; &lt;/dependency&gt; 抽象类
//引入数据库DAO //定义缓存的map格式 public LoadingCache&lt;Long,String&gt; testCache //初始化 @PostConstruct private void init(){ testCache = CacheBuilder.newBuilder() // 初始大小 .initialCapacity(1000) // 缓存池大小 .maximumSize(1000) // 设置时间对象没有被读/写访问则对象从内存中删除 .expireAfterWrite(100, TimeUnit.MINUTES) //设置时间刷新缓存 .refreshAfterWrite(60,TimeUnit.SECONDS) // 移除监听器 .removalListener( new RemovalListener&lt;Long, String&gt;() { @Override public void onRemoval(RemovalNotification&lt;Long, String&gt; rn) { handleRemove.accept(rn.getKey()); } }) .recordStats() .build( new CacheLoader&lt;Long, String&gt;() { //第一次加载 @Override public String load(Long aLong) throws Exception { return handleNotExist.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/957e6173770ff6ce120929ba4716eba3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ace1d7f2c1c682c41d9e6b2021ffb79d/" rel="bookmark">
			sql字符串和数字转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		字符串转数字 convert(int,'123') cast('123' as int) 数字转字符串
convert(varchar(50),123)
cast(123 as varchar(50))
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/717e496ea8af7e5e4aabae620a3102a8/" rel="bookmark">
			车牌识别 easypr &#43; openvc3.4.15 &#43; uos（ubuntu）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开发环境：uos20（ubuntu） + qt5.15.2 + opencv3.4.15 + easyRP1.6
参考：
1、https://blog.csdn.net/m0_56051805/article/details/126277628
2、https://blog.csdn.net/u012020854/article/details/111049724
代码结果如下图
运行结果
注意事项:
1、需要将easyPR中的model文件拷贝到可执行程序目录下。
2、在可执行程序目录下新建文件夹plate，将车牌图片放到plate目录下。
完整代码包下载地址
[https://download.csdn.net/download/chc_office/87244315]
代码包括opencv库、easyPR源码及使用方法。别的代码往往还需要自行编译opencv库。许多调用easyPR的都是windows上的例子，少有qt+ubuntu的。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/201/">«</a>
	<span class="pagination__item pagination__item--current">202/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/203/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>