<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed1c62f5ed165cb40cb2da993690bf43/" rel="bookmark">
			Pycharm使用Anoconda配置虚拟环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.Anoconda的介绍
2.Anaconda的作用
3.Anaconda的安装
4.Anaconda的配置
4.1添加镜像源
4.2创建、使用并切换虚拟环境
5.pycharm的集成
1.Anoconda的介绍 Anaconda是一个可用于科学计算的 Python 发行版，可以便捷获取和管理包，同时对环境进行统一管理，支持 Linux、Mac、Windows系统，包含了conda、Python在内的超过1,000+开源库。它解决了官方Python 的两大痛点：
第一：提供包管理功能，Windows 平台安装第三方包经常失败的场景得以解决。
第二：提供环境管理功能，类似 Virtualenv，解决多版本Python并存、切换问题。
Anaconda完全开源和免费，额外的加速和优化是收费的，但对于学术用途，可以申请免费的License。
2.Anaconda的作用 conda结合了pip和virtualenv的功能，适用于Python, R, Ruby, Lua, Scala, Java, JavaScript, C/C++, FORTRAN，不会影响系统自带Python，比较方便地在不同环境之间进行切换，环境管理较为简单。当一个程序需要使用Python 2.7版本，而另一个程序需要使用Python 3.6版本，如何同时使用这两个程序？如果将所有程序都安装在系统下的默认路径，如：/usr/lib/python2.7/site-packages，当不小心升级了本不该升级的程序时，将会对其他的程序造成影响。如果想要安装程序并在程序运行时对其库或库的版本进行修改，都会导致程序的中断。在共享主机时，无法在全局 site-packages 目录中安装包。 3.Anaconda的安装 下载：清华源
下载安装过程的建议：
1.【建议仅为当前用户安装】
2.【建议不使用自动配置环境变量】
3.安装完成后，手动添加环境变量：
4.测试安装情况：conda -V
4.Anaconda的配置 4.1添加镜像源 #删除所有已配置的镜像源 conda config --remove-key channels #添加镜像源 conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/win-64/ #设置安装包时显示镜像地址 conda config --set show_channel_urls yes #查看已安装的镜像源 conda config --show-sources 4.2创建、使用并切换虚拟环境 虚拟环境的作用是，可以为不同项目统一进行包管理，如我们同时存在POJ-A······POJ-N等N个项目，采用的第三方依赖一致，则可以共享一个虚拟环境，而无需在新建项目的时候为新项目，再次重新安装所有依赖包。
#创建虚拟环境，conda create -n vir_env_name python=[3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed1c62f5ed165cb40cb2da993690bf43/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/957d6adb0c0223037ac01e7929952e4c/" rel="bookmark">
			post请求实体类中@NotEmpty注解不生效解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 @NotEmpty注解不生效的原因如下：
spring-boot-starter-parent一定要用2.2.6版本的，用2.3.0会导致后面notempty注解不生效
如果用的是2.3.0以后的版本也可以添加如下依赖即可解决
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt; &lt;/dependency&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3cbe8518406fa5f58430631a5e916d2f/" rel="bookmark">
			Unsupported Java. Your build is currently configured to use Java 17.0.6 and Gradle 7.0.2.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目场景： 导入别人项目时出现的bug，提示java环境版本和Gradle版本不匹配
问题描述 Unsupported Java. Your build is currently configured to use Java 17.0.6 and Gradle 7.0.2. Possible solution: - Upgrade Gradle wrapper to 7.2 version and re-import the project - 原因分析： 因为导入的项目所需的gradle版本对应的是java8，而Android Studio 2022.2.1 版本自带的java版本为17，它会使用默认的java版本去编译项目，所以编译时导致报错。
解决方案： 点击File --&gt; Settings
进入后搜索Gradle
这里看到jdk版本默认用的为17版本，我们自己添加JDK
找到自己下载的JDK1.8版本（自己下载）
点击确定，更换就可以了，重新编译你导入的项目
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86d027d7b7d02d388f7e8e87b90b6706/" rel="bookmark">
			项目术语汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是 L2O ？ L2O：即 Leads to Opportunity，也就是从线索管理 &gt;&gt; 客户管理 &gt;&gt; 商机管理的业务流程 SRM（Supplier Relationship Management）供应商关系管理
CRM（Customer Relationship Management）客户关系管理
侧重点不同：
SRM更关注供应商管理，如管理供应商、供应商绩效评估、材料信息管理、询价/报价、战略寻源、电子招投标、产品定价、线上采购、订单跟踪、收发、库存管理、财务结算、合同管理、绩效管理、需求管理等等。
CRM则注重客户管理，如客户信息记录、客户访问、客户跟踪、商机发现、销售订单、销售统计等。CRM软件比较规范。
但总的来说，CRM以客户为中心，优化外部；SRM关注供应商，优化外部。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e1266b5881f473649c4572ac133f030/" rel="bookmark">
			C&#43;&#43;静态库与动态库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是库 库是写好的现有的，成熟的，可以复用的代码。现实中每个程序都要依赖很多基础的底层库，不可能每个人的代码都从零开始，因此库的存在意义非同寻常。
本质上来说库是一种可执行代码的二进制形式，可以被操作系统载入内存执行。库有两种：静态库（.a、.lib）和动态库（.so、.dll）。
所谓静态、动态是指链接。回顾一下，将一个程序编译成可执行程序的步骤：
静态库 之所以成为静态库，是因为在链接阶段，会将汇编生成的目标文件.o与引用到的库一起链接打包到可执行文件中。因此对应的链接方式称为静态链接。
试想一下，静态库与汇编生成的目标文件一起链接为可执行文件，那么静态库必定跟.o文件格式相似。其实一个静态库可以简单看成是一组目标文件（.o/.obj文件）的集合，即很多目标文件经过压缩打包后形成的一个文件。静态库特点总结：
1.静态库对函数库的链接是放在编译时期完成的。
2.程序在运行时与函数库再无瓜葛，移植方便。
3.浪费空间和资源，因为所有相关的目标文件与牵涉到的函数库被链接合成一个可执行文件。
下面编写一些简单的四则运算C++类，将其编译成静态库给他人用，头文件和源文件如下所示：
#pragma once class StaticMath { public: StaticMath(void); ~StaticMath(void); static double add(double a, double b); // 加法 static double sub(double a, double b); // 减法 static double mul(double a, double b); // 乘法 static double div(double a, double b); // 除法 void print(); }; #include "StaticMath.h" double StaticMath::add(double a, double b) { return a + b; } double StaticMath::sub(double a, double b) { return a - b; } double StaticMath:: mul(double a, double b) { return a * b; } double StaticMath:: div(double a, double b) { return a / b; } Linux下使用ar工具、Windows下vs使用lib.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e1266b5881f473649c4572ac133f030/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/613c8faa3855600dda497c05a2f7ca98/" rel="bookmark">
			【排错日记】Swagger之【We‘re sorry but knife4j-vue doesn‘t work properly without JavaScript enabled】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 现象代码分析解决 现象 新增的一个接口，调试时，swagger首页响应报文返回：
We’re sorry but knife4j-vue doesn’t work properly without JavaScript enabled. Please enable it to continue.
代码 @RestController @RequestMapping(value = "/api/messagemanage") @Api(tags = "邮件/消息管理") @Slf4j public class MessageTemplateController { ... 省略 ... } 分析解决 可以看到注解Api的tags属性里包含“/”，尝试去掉，验证没有问题，恢复正常。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b80721bfaa4cc6ea71e552b8f57f78c9/" rel="bookmark">
			unity双指触摸物体控制放大缩小
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		using UnityEngine; using System.Collections; public class Gesture : MonoBehaviour { private Touch oldTouch1; //上次触摸点1(手指1) private Touch oldTouch2; //上次触摸点2(手指2) public float minScale; public float maxScale; public float ratio;//放大的倍数 void Update() { //没有触摸，就是触摸点为0 if (Input.touchCount &lt;= 1) { return; } //多点触摸, 放大缩小 Touch newTouch1 = Input.GetTouch(0); Touch newTouch2 = Input.GetTouch(1); //第2点刚开始接触屏幕, 只记录，不做处理 if (newTouch2.phase == TouchPhase.Began) { oldTouch2 = newTouch2; oldTouch1 = newTouch1; return; } //计算老的两点距离和新的两点间距离，变大要放大模型，变小要缩放模型 float oldDistance = Vector2.Distance(oldTouch1.position, oldTouch2.position); float newDistance = Vector2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b80721bfaa4cc6ea71e552b8f57f78c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06c9215d637c39905c0610c7c44d4970/" rel="bookmark">
			SpringCloud整合Duboo&#43;Nacos注册中心使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. dubbo spring cloud描述
功能组件Spring CloudDubbo Spring Cloud分布式配置（Distributed configuration）Git、Zookeeper、Consul、JDBCSpring Cloud 分布式配置 + Dubbo 配置中心服务注册与发现（Service registration and discovery）Eureka、Zookeeper、ConsulSpring Cloud 原生注册中心 + Dubbo 原生注册中心负载均衡（Load balancing）Ribbon（随机、轮询等算法）Dubbo 内建实现（随机、轮询等算法 + 权重等特性）服务熔断（Circuit Breakers）Spring Cloud HystrixSpring Cloud Hystrix + Alibaba Sentinel 等服务调用（Service-to-service calls）Open Feign、RestTemplateSpring Cloud 服务调用 + Dubbo @Reference链路跟踪（Tracing）Spring Cloud Sleuth + ZipkinZipkin、opentracing 等 2.Dubbo Spring Cloud 主要特性
（1）面向接口代理的高性能RPC调用：提供高性能的基于代理的远程调用能力，服务以接口为粒度，屏蔽了远程调用底层细节。利用Netty，TCP传输，单一、异步、长连接，适合数据量小、高并发和服务提供者远远少于消费者的场景，对比与SpringCloud的Fegin组件的短连接，就只能在并发不那么高的情况下使用，但是Fegin使用起来更加简洁
（2）智能负载均衡：内置多种负载均衡策略，智能感知下游节点健康状况，显著减少调用延迟，提高系统吞吐量。
（3）服务自动注册与发现：支持多种注册中心服务，服务实例上下线实时感知。
（4）高度可扩展能力：遵循微内核+插件的设计原则，所有核心能力如Protocol、Transport、Serialization被设计为扩展点，平等对待内置实现和第三方实现。
（5）运行期流量调度：内置条件、脚本等路由策略，通过配置不同的路由规则，轻松实现灰度发布，同机房优先等功能。
（6）可视化的服务治理与运维：提供丰富服务治理、运维工具：随时查询服务元数据、服务健康状态及调用统计，实时下发路由策略、调整配置参数。
3.SpringCloud+Nacos+Dubbo最佳实践
（1）服务端接口契约定义
创建一个api服务，将需要远程调用的service定义在这个模块下，后续的服务提供者和消费者分别依赖此服务，dubbo的最佳实践，代码也会比较美观，维护起来也方便
pom.xml不用引用任何包。
定义服务端接口类IHelloService：
public interface IDubboService { String sayBaga(String xiaorizi); } 然后执行mvn install，将dubbo-sample-api添加到本地仓库，供其他项目依赖。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/06c9215d637c39905c0610c7c44d4970/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/236710be128de42ab726cb917094a059/" rel="bookmark">
			C&#43;&#43;类和对象详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.什么是类和对象？
面向对象的特点：封装、继承、多态
面向对象编程的特点：
易维护，质量高，效率高，易扩展
1.类和对象的概念
C++是一门面向对象的语言，理解C++，首先要理解类和对象
C++中的类可以看成C语言中的结构体升级版，结构体是一种构造类型，可以包含若干成员变量，成员变量的类型可以不同。
关于class（类）的几点说明：
（1）类的定义的最后有一个分号，他是类的一部分，表示类定义结束。
（2）一个类可以创建多个对象，每个对象都是一个变量
（3）类是一种构造类型，大小的计算方法和struct一样，需要字节对齐
（4）类成员变量的访问方法：通过 . 或者 -&gt;来访问
（5）成员函数是类的一个成员，出现在类中，作用范围由类来决定，而普通函数是独立的，作用范围是全局或者某个命名空间
struct：内部默认是公有权限，结构体外部可以访问其内部成员
private：内部默认是私有权限，类的外部不能直接访问内部成员；可以手动声明为公有权限
2.类的访问 public：公有属性，凡是在它下面声明的变量和函数，都可以在类的内部和外部访问
private:私有属性，凡是在它下面声明的变量和函数，只能在类的内部访问
protected:保护属性，凡是在它下面声明的变量和函数，只能在类的内部以及派生类（子类）中访问
3.类中的元素
类中有成员变量，成员函数；
类可以创建对象；
二.对象的构造和析构函数
1.构造函数
在c++中，由一种特殊的成员函数，名字和类名相同，没有返回值，不需要用户显示调用（用户也不能调用），而是在创建对象的时候自动调用。 这种函数我们称为构造函数 关于构造函数：
1.函数名必须和类型相同
2.不能有返回值，函数体不能有return语句
3.构造函数在定义对象时会自动调用，不需要手动调用
2.构造函数的重载与调用
和普通函数一样，构造函数是允许重载的，一个类可以有多个重载的构造函数，在创建对象时根据传递实参来判断调用哪一个构造函数
3.拷贝构造函数 （1）概念
用一个现有的对象去初始化另一个对象
声明：Date（const Date&amp; a）；
（2）拷贝构造函数的调用时机
①.用一个对象初始化另一个对象
Date d1(d2);
Date d1=d2;
Date d1=Date(d2);
②.当函数的形参是一个对象时，例如：
void Print（Date d1）
{
d1.getday（2022,3）；
}
③.函数的返回值是一个对象
Date&amp; Func（）
{
Date d1;
return d1;
}
4.深拷贝和浅拷贝
浅拷贝：只拷贝数据，内存空间并没有新开辟
深拷贝：数据和内存空间都要拷贝
5.默认构造函数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/236710be128de42ab726cb917094a059/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51ec7cd541e9e5b7ad6de1bcb3766941/" rel="bookmark">
			java编程练习题目初学者参考必备
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【程序1】 题目：古典问题：有一对兔子，从出生后第3个月起每个月都生一对兔子，小兔子长到第三个月后每个月又生一对兔子，假如兔子都不死，问每个月的兔子总数为多少？ //这是一个菲波拉契数列问题
public class lianxi01 {
public static void main(String[] args) {
System.out.println("第1个月的兔子对数: 1");
System.out.println("第2个月的兔子对数: 1");
int f1 = 1, f2 = 1, f, M=24;
for(int i=3; i&lt;=M; i++) {
f = f2;
f2 = f1 + f2;
f1 = f;
System.out.println("第" + i +"个月的兔子对数: "+f2);
}
}
}
【程序2】 题目：判断101-200之间有多少个素数，并输出所有素数。
程序分析：判断素数的方法：用一个数分别去除2到sqrt(这个数)，如果能被整除， 则表明此数不是素数，反之是素数。 public class lianxi02 {
public static void main(String[] args) {
int count = 0;
for(int i=101; i&lt;200; i+=2) {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/51ec7cd541e9e5b7ad6de1bcb3766941/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0fcc83553078414cf1787dbd724088a7/" rel="bookmark">
			【AUTOSAR】VCU开发实际项目讲解（二）----VCU软件与结构描述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VCU软件描述 VCU软件架构主要分为底层软件驱动和应用层控制策略，其中应用层控制策略通过基于模型的开发，自动生成代码并可与底层驱动软件实现无缝连接。
VCU软件通过BOOTLOADER和CAN总线进行更新刷写。
标定及诊断 支持CCP/XCP标定协议支持UDS诊断协议及SAE J1939诊断协议故障存储：128K IIC外扩EEPROM提供程序刷新Bootloader软件工具 基于CAN总线的控制器刷新工具支持多种CAN工具：周立功CAN、PEAK PCAN Adapter、Vector CANCaseXL支持CCP/XCP协议支持UDS协议 整车控制器外壳结构描述 外壳材质：铝合金
尺寸紧凑、易于安装及拆装
-整车控制器通过四个螺栓固定安装
优越的EMC抗干扰能力及抗震性：
- 外壳使用铝合金材料压铸成型，较高强度和抗氧化腐蚀性能，具有良好的电磁屏蔽功能；
- 针对汽车行驶中高振动状态下对零部件及电子元器件可靠性的要求，采用内部电路板硅胶减震，周围封胶辅助设计。
防护等级高：
防护等级达IP67
防尘、防水散热压力平衡设计：
- 特有的压力平衡设计，及时散热，平衡内外压差，时刻保证电子元器件处于正常的工作状态，完整的产品密封性
整车控制器的线束接插件有锁固及防呆防错功能，在通电使用前须确认接插件的连接完好没有松脱。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e16d6f4d76d94b40db126f493fa9f73c/" rel="bookmark">
			IntelliJ IDEA 206 个快捷键大全，动图演示！搬砖杠杠的！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		主要是参考IntelliJ IDEA官网，列举其（Windows版）的所有快捷键。（有动图演示）
快捷键主要分为16种：
目录 一、构建/编译
1、CTRL+F9：构建项目
2、Ctrl+Shift +F9：重新编译当前类
二、文本编辑
1、Ctrl + X ：剪切
2、Ctrl + C：复制
3、Ctrl + V：粘贴
4、Ctrl + Alt + Shift + V：粘贴为纯文本
5、Ctrl + Shift + V：从历史选择粘贴
6、Ctrl + D：复制行
7、Ctrl + Shift + C：复制文件路径
8、Ctrl + Alt + Shift + C：复制引用
9、Ctrl + S：保存全部
10、Ctrl + Z：撤销
11、Ctrl + Shift + Z：重做
12、Tab：缩进
13、Shift + Tabl：取消缩进
14、Ctrl + Alt + I：自动缩进行
15、Shift + Enter：开始新行
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e16d6f4d76d94b40db126f493fa9f73c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e40153e0ba0f193d7cc49bdab852333d/" rel="bookmark">
			Java中基本类型、包装类和String类型及其之间的转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java中基本类型、包装类和String类型及其之间的转换 Java中提供了将基本数据类型转换为对象，以及将对象转换为基本数据类型的机制。
基本类型不能为null，但包装类可以为null，且包装类可用于实现多态性。
java.lang 包的八个类在Java中被称为包装类。
基本数据类型包装类booleanBooleancharCharacterbyteByteshortShortintIntegerlongLongfloatFloatdoubleDouble 1.基本类型和包装类转换为String类型 1.1连接运算
int num2 = 100; String str2 = num2 + ""; System.out.println(str2 + 1);//1001 1.2.调用String的valueof(Xxx xxx)
float f2 = 12.5f; String str22 = String.valueOf(f2); Double d2 = new Double(12.5); String str23 = String.valueOf(d2); System.out.println(str22+1);//12.51 System.out.println(str23+1);//12.51 2.将String数据类型转换为基本数据类型和包装类，使用parseXxx String str3 = "123"; System.out.println(str3 + 1);//1231 int num3 = Integer.parseInt(str3); System.out.println(num3 + 1);//124 String str31 = "true"; boolean b3 = Boolean.parseBoolean(str31); if(b3) { System.out.println(b3);//true } 代码示例：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e40153e0ba0f193d7cc49bdab852333d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9192c27e71c494110924e2352bc10bc/" rel="bookmark">
			【海量数据挖掘/数据分析】 之 贝叶斯分类算法（朴素贝叶斯分类、贝叶斯分类计算流程、拉普拉斯修正、贝叶斯分类实例计算）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【海量数据挖掘/数据分析】 之 贝叶斯分类算法（朴素贝叶斯分类、贝叶斯分类计算流程、拉普拉斯修正、贝叶斯分类实例计算） 目录
【海量数据挖掘/数据分析】 之 贝叶斯分类算法（朴素贝叶斯分类、贝叶斯分类计算流程、拉普拉斯修正、贝叶斯分类实例计算）
一、 贝叶斯分类器
1 . 贝叶斯分类器 :
2 . 贝叶斯分类器的类型 :
3 . 正向概率 与 逆向概率 :
4 . 贝叶斯公式 : 有两个事件 , 事件 A , 和事件 B ;
二、 贝叶斯分类器处理多属性数据集方案
三、 贝叶斯分类器分类的流程
四、拉普拉斯修正
五、贝叶斯分类器示例
六、 朴素贝叶斯分类器使用
七、 朴素贝叶斯分类的优缺点
一、 贝叶斯分类器 1 . 贝叶斯分类器 : ① 原理 : 基于统计学方法贝叶斯 ( Bayes ) 理论 , 预测样本某个属性的分类概率 ;
② 性能分析 : 朴素贝叶斯 分类器 , 与 决策树 , 神经网络 分类器 性能基本相同 , 性能指标处于同一数量级 , 适合大数据处理 ;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c9192c27e71c494110924e2352bc10bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/091ee51778e4e3b1817e7321f6b67246/" rel="bookmark">
			chatgpt赋能python：移除Python-提高网站性能的关键步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 移除Python - 提高网站性能的关键步骤 作为一名经验丰富的Python工程师，我在很多项目中使用过Python，但是随着技术的发展和需求的不断变化，有时候我们需要移除Python。移除Python可能会对网站性能产生显著的改进，因此在本文中，我们将讨论为什么需要移除Python，并提供一些实用的技巧来帮助你成功地移除Python，提高网站性能。
为什么需要移除Python？ 虽然Python是一种便捷，易于学习的编程语言，但是它并不是所有项目或网站的最佳选择。在某些情况下，Python可能不足以满足我们的需求，或者使用Python可能会导致性能下降，从而降低用户体验。
下面是一些需要移除Python的情况：
高流量网站 Python是一种相对较慢的编程语言，因此对于高流量的网站，使用Python可能会导致严重的性能问题。即使使用异步编程或多线程编程，也可能无法解决这些问题。
大型数据处理 Python对于大型数据集的处理较慢，因此在需要处理大量数据的项目中，使用Python可能会导致性能问题。如果需要处理大型数据集，建议选择更适合处理大量数据的编程语言，如Julia或Go。
制作桌面应用 如果需要制作桌面应用程序，Python可能并不是最好的选择。虽然Python有许多GUI框架可供选择，但是这些框架在处理复杂的用户界面时可能会显得很慢。
移除Python的技巧 如果你决定移除Python，下面是一些实用的技巧，将帮助你确保顺利完成此过程，同时提高网站性能。
选择最适合的编程语言 移除Python的第一步是选择一个最适合的编程语言。在选择编程语言时，请考虑项目中所需的功能，以及需要优化的性能方面。根据不同的需求，可以选择C ++，Go，Rust，Java或JavaScript等其他编程语言。
迁移应用程序和框架 如果你使用的是Python应用程序或框架，移除Python的下一步是迁移这些应用程序或框架。对于基于Web的应用程序，可以考虑使用其他语言和Web框架，如Express.js（JavaScript），Flask（Python的Web框架）等。对于桌面应用程序，可以考虑使用其他跨平台框架，如Electron（JavaScript）或Qt（C ++）。
更新和重构代码 在移除Python后，还需要重构代码，以确保它们能够与新语言和框架兼容。在重构代码之前，请确保对代码进行了充分的测试和备份，并 根据需要添加适当的文档。
部署和测试 移除Python的最后一步是部署和测试。在部署之前，请确保对代码进行了充分测试，并确保所有依赖项都已正确安装。在部署之后，请确保对网站进行全面测试，以确保它们能够正确运行，并具有所需的性能和功能。
结论 移除Python可能是提高网站性能的关键步骤之一。由于Python的性能可能不足以满足所有项目的要求，因此在某些情况下，移除Python是一个不可避免的选择。通过选择最适合项目需求的编程语言，迁移应用程序和框架，重构代码并进行充分的测试和部署，可以确保成功地移除Python，并提高网站性能。
最后的最后 本文由chatgpt生成，文章没有在chatgpt生成的基础上进行任何的修改。以上只是chatgpt能力的冰山一角。作为通用的Aigc大模型，只是展现它原本的实力。
对于颠覆工作方式的ChatGPT，应该选择拥抱而不是抗拒，未来属于“会用”AI的人。
🧡AI职场汇报智能办公文案写作效率提升教程 🧡 专注于AI+职场+办公方向。
下图是课程的整体大纲
下图是AI职场汇报智能办公文案写作效率提升教程中用到的ai工具
🚀 优质教程分享 🚀 🎄可以学习更多的关于人工只能/Python的相关内容哦！直接点击下面颜色字体就可以跳转啦！ 学习路线指引（点击解锁）知识定位人群定位🧡 AI职场汇报智能办公文案写作效率提升教程 🧡进阶级本课程是AI+职场+办公的完美结合，通过ChatGPT文本创作，一键生成办公文案，结合AI智能写作，轻松搞定多场景文案写作。智能美化PPT,用AI为职场汇报加速。AI神器联动，十倍提升视频创作效率💛Python量化交易实战 💛入门级手把手带你打造一个易扩展、更安全、效率更高的量化交易系统🧡 Python实战微信订餐小程序 🧡进阶级本课程是python flask+微信小程序的完美结合，从项目搭建到腾讯云部署上线，打造一个全栈订餐系统。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea0be37a2bac875ebbcb58b6419fbeb9/" rel="bookmark">
			chatgpt赋能python：使用什么与Python共同进行SEO
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 使用什么与Python共同进行SEO
随着数码化时代的到来，越来越多的企业将重心转向了网上宣传和营销。搜索引擎优化（SEO）是一种促进企业网站在搜索引擎中排名靠前的策略，以吸引更多的潜在客户前来浏览和购买产品。Python作为一种高效、易学、易用的编程语言，已成为许多企业进行SEO活动的首选语言。那么，为了更好地开展SEO工作，我们需要使用哪些工具和技术来辅助Python呢？
网站爬虫框架 网站爬虫是SEO的重要组成部分。因为它可以帮助我们获取用户或搜索引擎所需的信息，以更好地了解用户搜索需求及行为。Python中最著名的爬虫框架是Scrapy。Scrapy是一种可伸缩、高速、功能齐全且易于编写和维护的爬虫框架。使用Scrapy可以轻松地建立一个爬虫，采集数据、处理数据、存储数据和导出数据。
数据库管理系统 数据是SEO成功的关键。为了更好地管理数据，我们需要数据库管理系统（DBMS）。Python中比较流行的DBMS包括MySQL、PostgreSQL和MongoDB。在这些DBMS中，MySQL通常是最受欢迎的一个，因为它在功能组件、稳定性、可扩展性和安全性方面都卓越。
数量化分析和图表展示 在进行SEO活动时，我们通常会对相关数据或信息进行分析。这就需要一些适用的数量化分析及图表展示工具。Python中最常用的这些工具是Pandas和Matplotlib。Pandas是一种运用数据结构和数据分析工具的库，方便清理、转化和操作数据。Matplotlib则是一种绘图库，用在对数据进行可视化处理上。通过结合这两个库，我们可以对数据进行更加深入的分析。
地址转换和数据清洗 在进行SEO活动时，有时候需要进行地址的转换和数据清洗。Python中相应的工具包括Geopy和pandas。Geopy是一种Python库，用于将地址转换为经纬度坐标。pandas则可以用来处理和清洗数据，可以非常好地实现数据清洗的操作。
结论：
使用Python进行SEO活动，可以在短时间内处理大量数据并实现一些重复性工作的自动化，提高SEO工作效率。一些重要的Python工具和技术包括网站爬虫框架（如Scrapy）、数据库管理系统（如MySQL）、数据分析和图表展示工具（如Pandas和Matplotlib）以及地址转换和数据清洗工具（如Geopy和pandas）。这些工具可以大大简化并优化SEO活动流程，让SEO的过程更加高效、准确和智能。
最后的最后 本文由chatgpt生成，文章没有在chatgpt生成的基础上进行任何的修改。以上只是chatgpt能力的冰山一角。作为通用的Aigc大模型，只是展现它原本的实力。
对于颠覆工作方式的ChatGPT，应该选择拥抱而不是抗拒，未来属于“会用”AI的人。
🧡AI职场汇报智能办公文案写作效率提升教程 🧡 专注于AI+职场+办公方向。
下图是课程的整体大纲
下图是AI职场汇报智能办公文案写作效率提升教程中用到的ai工具
🚀 优质教程分享 🚀 🎄可以学习更多的关于人工只能/Python的相关内容哦！直接点击下面颜色字体就可以跳转啦！ 学习路线指引（点击解锁）知识定位人群定位🧡 AI职场汇报智能办公文案写作效率提升教程 🧡进阶级本课程是AI+职场+办公的完美结合，通过ChatGPT文本创作，一键生成办公文案，结合AI智能写作，轻松搞定多场景文案写作。智能美化PPT,用AI为职场汇报加速。AI神器联动，十倍提升视频创作效率💛Python量化交易实战 💛入门级手把手带你打造一个易扩展、更安全、效率更高的量化交易系统🧡 Python实战微信订餐小程序 🧡进阶级本课程是python flask+微信小程序的完美结合，从项目搭建到腾讯云部署上线，打造一个全栈订餐系统。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8418cdb3073935ffc1dc4b98cd46fa16/" rel="bookmark">
			chatgpt赋能python：用Python计算n!
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用Python计算n! 在数学中，阶乘是一个正整数的乘积，例如5!表示5x4x3x2x1，即120。Python是一种功能强大的编程语言，可以轻松地计算阶乘。
什么是阶乘（n!）? 阶乘是一个正整数的乘积，例如，如果n为正整数，则n！= n x (n-1) x (n-2) x … x 3 x 2 x 1。通常情况下，阶乘的符号为“！”，因此5！读作“5 阶乘”，其结果为120。
为什么要计算n!？ 阶乘常常在组合方面用到，如排列和组合等。例如，n个元素的排列数量为n!，而n个元素的r个元素的组合数为n! / (r!(n-r)!).
在计算机科学领域，阶乘也是算法和程序的基础。例如，在排序和递归等算法中都需要使用到阶乘。
用Python计算n! Python提供了两种计算n!的方法。
方法1：使用for loop 这种方法很容易理解，我们可以使用for循环语句将n!计算出来。
def factorial(num): result = 1 for i in range(1,num+1): result *= i return result 在这个函数中，我们使用for循环计算乘积，并将结果存储在result变量中。最后，函数返回用于计算n!的result值。
方法2：使用递归 递归是一种常用的计算n!的方法。在递归中，我们调用函数本身来计算阶乘。
def factorial(num): if num == 1: return 1 else: return num * factorial(num-1) 在这个函数中，我们首先检查num是否等于1。如果是，函数返回1。否则，函数递归调用自身来计算num-1的阶乘，并将结果与num相乘得到n!的值。
结论 使用Python计算n!是一项简单而必要的任务。无论你是在学习计算机科学还是需要用它来解决实际问题，Python提供了许多工具来计算n!。对于比较大的n，递归方法可能会导致堆栈溢出或占用太多内存，因此用for loop计算n!可能更适合大规模计算。
在实际开发中，我们可以根据需要选择最适合我们任务的算法。现在，让我们用Python来计算一下10!。
print(factorial(10)) 输出结果为: 3628800。
最后的最后 本文由chatgpt生成，文章没有在chatgpt生成的基础上进行任何的修改。以上只是chatgpt能力的冰山一角。作为通用的Aigc大模型，只是展现它原本的实力。
对于颠覆工作方式的ChatGPT，应该选择拥抱而不是抗拒，未来属于“会用”AI的人。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8418cdb3073935ffc1dc4b98cd46fa16/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20c45cb0a1984a33704aae02c5f9af14/" rel="bookmark">
			vue实现平滑返回顶部，实时显示和隐藏返回顶部按钮，
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里我们主要使用了window.addEventListener("scroll", this.handleScroll, true);这个监听事件
监听页面滑动的距离，当页面的滑动到一定的距离的时候就显示返回顶部的按钮，并且实现平滑返回
相关代码如下：
template部分 &lt;div v-show="showBtn" class="Return" @click="scollTop"&gt;返回顶部&lt;/div&gt; js部分 method：{ //实时监控元素与窗口滚动的距离 handleScroll() { let top = document.documentElement.scrollTop ||document.body.scrollTop ||window.pageYOffset; this.scrollTopNum = top; }, // 返回顶部处理函数（滑动滚动） scollTop() { const upRoll = setInterval(() =&gt; { const top = document.documentElement.scrollTop // 每次获取页面被卷去的部分 const speed = Math.ceil(top / 25) // 每次滚动多少 （步长值） if (document.documentElement.scrollTop &gt; 0) { document.documentElement.scrollTop -= speed // 不在顶部 每次滚动到的位置 } else { clearInterval(upRoll) // 回到顶部清除定时器 } }, 20) }, }， mounted() { // 实时监控滑动距离 window.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/20c45cb0a1984a33704aae02c5f9af14/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd8176228539ca127e0b6c8806d7cf68/" rel="bookmark">
			vba基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		'第一章VBA基础知识
Sub 属性() MsgBox Sheet1.Name '工作表1的名称 MsgBox Sheet1.Range("a1").Value '工作表1中单元格A1的值 End Sub 'VBA对象属性的赋值
Sub 属性赋值() Sheet1.Name = "&amp;文本连接" Sheet1.Range("a1") = "&amp;文本连接" End Sub '1.常量：常量是定义了之后就不做变化了。
’ 常量定义格式：Const 常量名= 常量表达式
Sub 常量() Const pi = 3.145926 '定义常量pi=3.14 End Sub '2.变量:在定义之后还能再次赋值
'变量定义格式：Dim 变量 As 变量类型
Sub 变量() Dim a As Integer '定义a为变量 a = 100 '赋值a=100 End Sub '3.常量变量应用
Sub 应用() Const pi = 3.1415926 '定义常量pi=3.14 Dim a As Integer '定义a为变量 a = 200 '赋值a=200 MsgBox pi * a '弹出pi×a的结果 End Sub '3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd8176228539ca127e0b6c8806d7cf68/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3cb032823a15df41d589d6c5d7b31f91/" rel="bookmark">
			mavon-editor覆盖fixed的顶部导航栏的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 遇到的问题 今天无意间发现这个问题：
头部nav导航栏设置的是fixed属性，然后页面滑动一定距离之后，头部的导肮栏就会改变背景颜色，其余页面都是正常的，可是当我滑动关于页面的时候，就出现了上面的这个现象，我当时也是不知所措，因为这个关于页面的数据展示是使用的mavon-editor的预览的组件，所以不清楚里面的写法。然后就上网查相关的解决办法，这里我找到了三个解决办法。
解决办法一： 修改固定定位的元素的z-index的值，可能z-index的太小了
解决办法二 给导航栏的级别修改为!important
解决办法三 mavon-editor设置了position为static
效果展示 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5a6f5e1bad6eb6ed0cd5dd6353a202d/" rel="bookmark">
			委托中的单播以及多播
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.委托的多播
2.编写程序，实现委托的多播。
代码 如下：
单播：
多播：
1.委托的多播 委托对象可使用 “+” 运算符进行合并。一个合并委托调用它所合并的两个委托。只有相同类型的委 托可被合并。 “-” 运算符可用于从合并的委托中移除组件委托。 委托也可以包含多个方法，这种委托称为多播委托，也叫组播。
2.编写程序，实现委托的多播。 先在 Visual Studio 2019 中，新建名称为 “project1” 的文件，这里的文件名大家可以根据自己的文件名称所改。
代码 如下： using System; public delegate int NumberDelegate(int num1, int num2); // 委托,声明在类之外 namespace project1 { public class Program { public static int AddMethod(int num1, int num2) { Console.WriteLine("Sum={0}", num1 + num2); return num1 + num2; } public static int SubMethod(int num1, int num2) { Console.WriteLine("Sub={0}", num1 - num2); return num1 - num2; } public static void Main(string[] args) { //单播 NumberDelegate nd1 = null; nd1 += AddMethod; Console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5a6f5e1bad6eb6ed0cd5dd6353a202d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da952613343604d6800c1d793711be38/" rel="bookmark">
			vsCode 创建新java项目(创建一个新java项目测试方法)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VSCODE环境配置-java之项目建立，非常适合刚准备使用VSCODE开发JAVA的人_vscode创建java项目_rainmenzhao的博客-CSDN博客
1 按 ctrl + shift +p
2 输入 create Java project
3 选 no build tools
4 选择 一个文件夹 存放 之后要 新建的文件
5 选完之后 自动返回主页面 在 最上面的输入框 输入 创建的 文件名(不要带后缀 .java)
6 F5 运行代码
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7bff3718cce6f860eb4e2f68c80b025d/" rel="bookmark">
			DP HDMI 以及信号转换备忘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DVI TMDS信号（仅视频 ）
HDMI TMDS信号（可传输音频)
DP 4对差分主链路（可以选择只要1,2,4条lane几种情况） 加一对 AUX辅助信号（相当于i2c 协议的DDC和显示器协商分辨率等数据） DP ++ 双模式，这种方式4对主链路对应TMDS的4对差分信号，AUX对应I2C的差分。这种情况下可以使用简单的被动式DP转HDMI的转接头进行转换。对非DP++的接口，还是需要协议转换芯片才行。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc9068f04d0a2bb419cc10b6fc5e76fb/" rel="bookmark">
			电路基础知识——CAN总线
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、总线特性（半双工接线）
1、 优势及应用 • 数据传输速度高（相对）， 1Mbit/s • 抗干扰能力强（差分数据线） • 具有自我诊断能力（错误侦测） • 只需要一条CAN总 线控制线和电源线 •与总线相连的单元没有类似于“地址”的信息。因此在总线上增加单元时，连接在总线上的其它单元的软硬件及应用层都不需要改变。 •CAN总线总裁机制的实现也就实现了CAN总线的多主机模式，总线节点不存在谁主谁从的概念 2、 总线电平 CAN2.0A/B 标准规定：总线空闲时， CAN_H 和 CAN_L 上的电压为 2.5V 显性电平（逻辑 0）： CAN_H 3.5V CAN_L 1.5V 隐性电平（逻辑 1）： CAN_H 2.5V CAN_L 2.5V 3、支持的最大节点数目
总线系统的直流电路模型 节点最大数量由收发器可以驱动的最小负载阻抗决定的，为终端电阻，为总线阻抗，为差分输入阻抗。
最大节点数量的关系式 收发器型号(KΩ)(Ω) 节点数量
=118Ω
节点数量
=130Ω
TJA1050254.7545131170TJA1050254.939217256PCA82C250204.945105136 4、总线长度 总线通信速率越高，通信距离越短，对物理传输线的要求就越高，在双绞线、屏蔽线还是其他的传输线选择上，通信速率是一个很关键的参数。对于双绞线而言，信号在其中的传播延时时间约为，5ns/m （典型值）。 影响总线长度的其他因素： （ 1）信号在节点 ECU 内部的延时时间 （ 2 ）振荡器的容差（各个节点 ECU 内部晶振频率的差别） 这些因素加起来就形成了 CAN 总线通信中总的信号延时 5、控制器和收发器 （1）控制器 CAN 控制器主要实现了两部分的功能， 1 ：数据链路层的全部功能；2 ：物理层的位定时功能 （2）收发器 按照 BOSCH CAN 总线标准将 0 或 1 逻辑信号转换为标准中规定的电平，同时有反馈功能 二、ISO 标准化的 CAN 协议 CAN 协议经 ISO 标准化后有 ISO11898 标准和 ISO11519-2 标准两种。 ISO11898 和 ISO11519-2 标准对于数据链路层的定义相同，但物理层不同。 (1) 关于 ISO11898 ISO11898 是通信速度为 125kbps-1Mbps 的 CAN 高速通信标准。 目前， ISO11898 追加新规约后，成为 ISO11898-1 新标准。 (2) 关于 ISO11519 ISO11519 是通信速度为 125kbps 以下的 CAN 低速通信标准。 ISO11519-2 是 ISO11519-1 追加新规约后的版本。 CAN 协议和 ISO11898 及 ISO11519-2 标准的范围 (1) ISO11898（高速） 通信速度： 125K~1Mbps，最高1Mdps 总线最大长度：40m/1Mdps 连接单元数：最大30 双绞线 （屏蔽 / 非屏蔽） 闭环总线 阻抗 (Z) ： 120 Ω (Min.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc9068f04d0a2bb419cc10b6fc5e76fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09b6d7aaab75685c49abc595caa981aa/" rel="bookmark">
			libbpf 开发指南：概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
什么是libbpf
BPF生命周期
骨架文件
BPF CO-RE（编译一次 - 到处运行）
什么是libbpf libbpf 是一个基于 C 的库，包含一个 BPF 加载程序，该加载程序获取已编译的 BPF 目标文件并准备它们并将其加载到 Linux 内核中。libbpf 承担了加载、验证 BPF 程序并将其附加到各种内核挂钩的繁重工作，使 BPF 应用程序开发人员能够只关注 BPF 程序的正确性和性能。
以下是 libbpf 支持的高级功能：
为用户空间程序与BPF程序交互提供高层和低层API。低级 API 封装了所有 bpf 系统调用功能，当用户需要对用户空间和 BPF 程序之间的交互进行更细粒度的控制时，这非常有用。为bpftool生成的BPF对象骨架提供全面支持。框架文件简化了用户空间程序访问全局变量和使用 BPF 程序的过程。提供BPF侧API，包括BPF辅助定义、BPF映射支持、跟踪辅助等，方便开发者简化BPF代码编写。支持BPF CO-RE机制，使BPF开发人员能够编写可移植的BPF程序，这些程序可以一次编译并跨不同内核版本运行。 libbpf 提供了一组 API，使得开发者能在用户空间加载、附加和管理 eBPF 程序。以下是 libbpf 的一些重要特性：
加载 eBPF 程序：libbpf 提供了用于加载 eBPF 程序的功能。开发者可以使用 libbpf 将 eBPF 程序加载到内核，并且可以查询和验证这些程序。附加 eBPF 程序到内核钩子：libbpf 支持将 eBPF 程序附加到内核的各种钩子上，例如网络接口、跟踪点（tracepoints）和 kprobes（内核探测点）。这使得 eBPF 程序可以在特定事件发生时被触发，从而实现对内核行为的监控和控制。操作 eBPF maps：eBPF maps 是一种用于在 eBPF 程序和用户空间应用程序之间共享数据的内核对象。libbpf 提供了一组 API，用于创建、更新和访问 eBPF maps。这使得开发者可以方便地在 eBPF 程序和用户空间应用程序之间传递数据。兼容性和可移植性：libbpf 尽力确保与不同版本的 Linux 内核和 eBPF 子系统保持兼容。这使得使用 libbpf 编写的应用程序在各种环境中具有较好的可移植性。与 BPF 编译器集成：libbpf 可以与 BPF 编译器（例如 clang 和 LLVM）集成，使得开发者可以更方便地编译和加载 eBPF 程序。 BPF生命周期 一个 BPF 应用程序由一个或多个 BPF 程序（协作或完全独立）、BPF 映射和全局变量组成。全局变量在所有 BPF 程序之间共享，这使得它们能够在一组公共数据上进行合作。libbpf 提供了用户空间程序可用于通过触发 BPF 应用程序生命周期的不同阶段来操作 BPF 程序的 API。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/09b6d7aaab75685c49abc595caa981aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7cc6524c500ee85bf888507e77494b87/" rel="bookmark">
			11-切片有什么用？【视频版】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 问题视频解答 问题 视频解答 点击观看：
11-切片有什么用？
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/340a2b229fe29c9d8a4638b28c1d1e45/" rel="bookmark">
			继承和组合的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是继承 继承是面向对象三大基本特征之一(继承，封装，多态)，继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。
在java中通过关键字extends实现继承，java中所有类默认都是java.lang.Object的子类。继承强调的是is-a关系。
例子：
/** * 动物 */ public class Animal { public void breathing() { System.out.println("呼气...吸气..."); } } /** * 飞行动物 * 继承 */ public class FlyingAnimals extends Animal{ public void filying() { System.out.println("飞行..."); } public static void main(String[] args) { FlyingAnimals flyingAnimals = new FlyingAnimals(); flyingAnimals.breathing(); flyingAnimals.filying(); } } 继承是代码复用的一种方式。在继承中，父类的方法内部实现细节对子类可见，是‘白盒式’的代码复用。
什么是组合 组合是通过对现有对象进行拼装即组合产生新的具有更复杂的功能。如：
/** * 动物 */ public class Animal { public void breathing() { System.out.println("呼气...吸气..."); } } /** * 爬行动物 * 组合 */ public class Reptilia { private Animal animal; public Reptilia(Animal animal) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/340a2b229fe29c9d8a4638b28c1d1e45/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8552c5ce2ab1a7ed8eec6f04f18773c4/" rel="bookmark">
			基于java的网络版坦克大战游戏系统设计与实现(项目报告&#43;答辩PPT&#43;源代码&#43;数据库&#43;部署视频)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于Java的坦克大战游戏的设计与实现
目 录
1.引言............................................................................................................................. 1
2.系统分析..................................................................................................................... 2
2.1需求和技术分析...................................................................................................... 2
2.2功能分析.................................................................................................................. 2
3.总体设计..................................................................................................................... 2
3.1总体功能.................................................................................................................. 2
3.2坦克大战总体流程图.............................................................................................. 4
4.详细设计..................................................................................................................... 5
4.1面板功能设计.......................................................................................................... 5
4.2子弹功能设计.......................................................................................................... 8
4.3坦克功能设计.......................................................................................................... 9
4.4服务器设计............................................................................................................ 10
4.5客户端设计............................................................................................................ 13
5. 游戏测试................................................................................................................. 15
5.1 测试方法............................................................................................................... 15
5.2 系统测试............................................................................................................... 15
5.3 测试分析和小结................................................................................................... 17
6.结论........................................................................................................................... 18
参考文献...................................................................................................................... 18
基于Java的坦克大战游戏的设计与实现
摘要：随着人们对生活质量的要求一天比一天高，为了让人们更好地开掘自身的智慧，游戏就此进入了大众的视野，在人们的生活中有着重要的位置，已然变得必不可少。游戏产业推动高新技术不断升级，极大地促进了经济的增长，推动了“第四产业”的经济腾飞。坦克大战游戏是童年时期经常玩的经典游戏，我们对它都十分了解。游戏通过分析JAVA游戏开发和代码设计，用Eclipse软件开发了坦克大战游戏，运用接口技术，使一个类能够实现多个接口，使用套接字Socket来完成client端和server端的连接。玩家通过连接访问进入游戏，通过操纵坦克来守卫基地，玩家还可以获得超级武器来提升坦克的属性，摧毁全部敌方坦克来取得胜利，操作非常简单，还具有非常高的普遍率，适合所有人群玩。该游戏既满足了人们的个性化需求，也让玩家在游戏过程中丢掉烦恼，尽情地释放压力。
关键词：Java 坦克大战游戏 Socket
1.引言
随着社会和时代的进步，来自各个方面的压力让人没精打采，为了分解人们的压力，休养那变得疲顿的头脑和劳累的身心，特设计了坦克大战小游戏，游戏操作非常容易，只要将手指放在键盘上敲击相关的游戏键就可以玩，在玩游戏的过程中能够体验现实生活中没有的快乐，既有利于身心健康，又不会影响工作和学习。本游戏采用的是基于J2SE标准平台的java编程技术，在Windows 7操作系统中使用Eclipse软件进行代码编译，通过方法Graphics（）来进行游戏地图界面的绘制，使用了接口技术使一个类能够实现多个接口，使用套接字Socket来完成client端和server端的连接。
Java是一项面向对象编程语言，既包含了C语言的全部优点，又具有面向对象，跨平台性，安全性等特点，是现在程序设计中较为常用的编程语言。Java具备了“一次编译，处处运行”的特点，很好的体现了其跨平台性和面向对象的特点，允许程序员用感性的思路来进行繁杂的编程。
Eclipse是一个基于java的开放源代码的可扩展开发平台，是知名的跨平台的自由集成开发环境（IDE）Eclipse是一个基于，还捎带了一个标准规范的插件集，包含了Java开发工具（JDK），Eclipse因为安装不同的插件，所以它支持不同的计算机语言，主要用来Java语言开发。
Graphics类是软件包java.awt（其全部类都用来用户界面的创建和图形图像的绘制）下的类，它同意一个应用程序绘制到组件,以及在屏幕图像上进行绘制。Graphics 对象封装了 Java 支持的基本呈现操作所需的状态信息。Graphics（）方法构造了一个新的 Graphics 对象， 由于 Graphics类是抽象类，因此Graphics（）方法不可以被直接调用，此构造方法是图形上下文的默认构造方法，通过在组件上调用 getGraphics（） 来创建图形上下文，或者从其他图形上下文获取。
2.系统分析 2.1 需求和技术分析
如今的游戏已经成为世界上最大的娱乐休闲项目之一，游戏市场规模持续增长，潜力巨大，我国政府一向以来都特别鼓励游戏产业的发展，特别是我国当地的游戏产业，扶持力度连年加大，由此可见，我国对游戏产业的重视程度。该坦克大战游戏是对红白机经典90坦克大战的延续，对于80后，90后来说，都是童年里最宝贵的回忆，而80后，90后恰好占据着当今游戏人群的主体，对于他们来说，该坦克大战游戏不仅可以减轻人们的社会压力，放松身心，也可以回味小时候玩红白机游戏的疯狂时光，又不会沉迷于游戏，老少咸宜，能够更好地体验游戏的乐趣。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8552c5ce2ab1a7ed8eec6f04f18773c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a450a129cf09900375182310113da7b5/" rel="bookmark">
			基于java的图书借阅管理系统设计与实现(源代码&#43;数据库&#43;部署文档&#43;部署视频)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图书管理系统
1. 本设计以图书管理业务为对象,系统实现用的前台开发工具是eclipse，后台数据库为MySQL。设计过程中的重点和难点是对整个系统的需求分析和数据库详细设计。 该系统对数据进行保存、修改、删除等管理。为用户提供了一个友好、简单快捷的运行操作平台。该统对数据进行保存、修改、删除等管理，为用户提供了一个友好、简单快捷的运行操作平台。本系统的各界面设计友好、流程正确、功能也较为完善，旨在为用户提供方便快捷的服务，使人们走近书籍，走进书籍，热爱读书。
本次设计意在为图书管理行业提供一个简便、易操作、可靠的借还管理系统，实现图书借阅、书店人员的更新及管理。
关键词：MySQL；图书管理系统；借书还书；排行榜；问题反馈
2 概述 2.1 系统主要功能
读者:登录注册，借阅还书，查询书籍，查看当前借阅信息以及历史借阅信息，查看、查询读者借阅榜以及借阅书籍借阅榜，问题反馈以及查询反馈结果等功能。
管理员:对图书、图书分类、读者信息的增删改查，查看全部读者当前借阅信息以及借阅历史，查看、查询书籍借阅榜及读者借阅榜，查看、查询用户反馈信息并修改反馈状态(未解决或已解决)。
超级管理员:除管理员权限外，新增管理员权限。对管理员信息进行增删改功能。为书店员工定制个人账号，方便管理。
2.2 系统相关说明
为图书管理行业提供一个简便、易操作、可靠的借还管理系统，实现图书借阅、书店人员的更新及管理。
本设计以图书管理业务为对象,系统实现所用前台开发工具是eclipse，后台数据库为MySQL。设计过程中的重点及难点是对整个系统的需求分析和数据库详细设计。
该系统对数据进行保存、修改、删除等管理，为用户提供了一个友好、简单快捷的运行操作平台。本系统的各界面设计友好、流程正确、功能也较为完善，旨在为用户提供方便快捷的服务，使人们走近书籍，走进书籍，热爱读书。
3 运行环境 3.1 系统的运行环境
3.1.1 系统运行硬件环境 基于开发使用的开源系统：
CPU：PIV1.6G以上
内存：256M以上
硬盘：40G以上
其他：光驱、3.5英寸软驱、鼠标
3.1.2 系统运行软件环境 （1）操作系统配置：Windows
（2）编译软件：eclipse，环境：JDK1.8
（3）服务器：Tomcat
（4）驱动：JDBC
（5）数据库：MySQL
（6）前端框架：bootstrap
3.2 网络环境
本系统需要运行在单位局域网，要求服务器、客户端计算机连接在此网络上。
4 安装与配置 4.1 安装
（1）eclipse的安装
（2）Tomcat服务器的安装
（3）MySQL数据库的安装
4.2 配置
（1）Windows操作系统的配置
（2）JDK1.8环境的配置
（3）Tomcat服务器的配置
（4）JDBC驱动的配置
（5）MySQL数据库的配置
5 操作说明 该系统是基于eclipse的系统软件，在Tomcat服务器上运行主页面：http://localhost:8080/books/login.jsp(直接运行功能页面会报错)
根据输入的学号/工号及密码进入不同的主页面，主页面附有本项目各页面的操作简介，方便用户进行操作。
每个界面相应的功能再后续介绍中会一一指出，如有疑问或建议也可以进入反馈页面告知管理员，管理员会尽快联系您并解决问题。操作完毕后单机右上角的“退出”模糊框退出系统。
5.1 进入登录界面
输入账号(学号/工号)、密码及验证码进行登录，后台根据不同的账号密码识别到用户身份进入相应的主页面。尚未注册点击“注册即可快速注册”，也可以联系管理员添加账号。
图5.1 登陆界面
图5.2 注册页面
图5.3 登陆失败(密码、验证码错误)
5.2 进入系统
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a450a129cf09900375182310113da7b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f81a519da1f4d57bd458711cff8f865e/" rel="bookmark">
			NextJS项目的部署以及多环境的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 开发了个Next项目，将部署过程记录一下。另外由于项目准备了两个服务器分别作为开发自测的开发环境和交付给客户的生产环境使用；因此也介绍一下NextJS项目中多环境的配置。
项目结构 计划是让Nginx根据不同的路径前缀决定请求发给哪个后端；而路径前缀则是由Docker打包镜像的时候传递参数给Next App作为环境变量。
部署过程 设置next.config.js# 导出静态文件# 我们需要Next项目编译后的文件，这需要我们把next.config.js中加上output: "export"设置，这样我们在运行next build命令后，Next会生成一个静态资源文件夹out ，如图：
⚠️注意事项
在output: "export" 模式下无法使用rewrites 或者headers 等设置，官方文档列出的完整不支持的功能如下：
设置环境变量# 如上文提到，Nginx需要根据不同的路径前缀来决定请求哪个后端，那么就需要前端去判断当前是什么环境再设定当前的请求的路径前缀。
根据NODE_ENV判断当前环境【已失败】
计划是当NODE_ENV为production的时候，请求前缀为/prod；当NODE_ENV为development的时候则为/dev。实施的时候却发现next build和next start这两条命令都会默认设置NODE_ENV为production 。因此当我使用cross-env在运行命令时设置NODE_ENV为development就失败了（如图）。
这么设置，运行npm run dev后获取到的process.env.NODE_ENV还是production 。
后来看到有网友说可以通过webpack的DefinePlugin插件来创建全局变量，从而改变环境。参考链接：使用process.env.NODE_ENV的正确姿势
自定义环境变量
发现NODE_ENV会被next build和next start这两条命令修改的时候，我就决定使用别的环境变量来区别本项目的开发环境与生产环境。
注意，在这里设置的环境变量API是无法在业务代码中直接访问的。如果此时在业务代码中使用process.env.API会得到undefined的值。
因此我在next.config.js处添加了环境变量的设置，将scripts这里设置的API变量传递给Next项目里，如图：
使用方式如下：
这样就成功设置好了环境变量，让项目根据不同环境，请求带上不同的前缀。
next.config.js文件配置示例：# const nextConfig = { output: "export", // 打包模式 reactStrictMode: true, images: { unoptimized: true, }, env: { API_PREFIX: process.env.API, }, // async rewrites() { // return [ // { // source: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f81a519da1f4d57bd458711cff8f865e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5917e23612207af408a347c554136185/" rel="bookmark">
			windows上phpstudy 在切换php7.0到7.2后项目404
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目从7.0切换到7.2.9一访问本地就报404，然后重启 + 重新配置nginx.conf也无效
然后取查看phpstudy 的 nginx/logs/error.log 发现一访问本地网站就报下面错
phpstudy报错
2023/06/28 11:36:28 [error] 14128#19616: *1 upstream prematurely closed connection while reading response header from upstream, client: 127.0.0.1, server: 110.demo.com, request: "GET /admin.php/system/index/index.html HTTP/1.1", upstream: "fastcgi://127.0.0.1:9003", host: "110.demo.com"
翻译：从上游读取响应头时上游过早关闭的连接
因为之前跑过vue服务,很肯能是端口占用了
后面通过杀掉windows 9000端口进程就好了
1、打开windows CMD窗口
两步方法 :
1 查询端口占用 netstat -aon|findstr "9000"
2 查询占用端口的程序 tasklist|findstr "6956" 发现是phpstorm占用的9000端口
2 强行杀死进程 taskkill /pid 6956 -t -f
然后重启phpstudy后成功结局
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23c0e020c07bf2b022770ff8af6b74f9/" rel="bookmark">
			【数据库】外键的作用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 说到外键，一般就会牵扯出约束。不谈约束，起始外键就是一个普通的字段（Column），起到一个关联的作用。
先把约束放一边，看看外键有哪些作用。
建立表中记录的一对一的关系 学生表：
手机表：
学生有一个字段是手机id，而手机存在多个属性，那现在把手机单独建一张表。
这样如果那天想查所有手机号时，直接查这张表效率更高。此时的PhoneId就是学生表的外键。而且是手机表的主键。
这里的一个特点，一个表的外键，在另一个表中，必须为主键。所以外键通常就一个ID。这个ID关联起两张表。如果是一对一，做表联结也非常简单。
一对多（多对一）的关系 假设这个学校有三个学生，两个老师，每个学生只能选择一个老师
学生表：
老师表：
可以看到，学生１２选择导师Song，这就是多个学生选择一个老师， 这个和一对一几乎没啥变化。也就是告诉你外键本身是可以重复的。
这样，又发现一个好处，多对一的情况下，相比建一个表，通过外键建两张表更节省空间。
多对多的关系 但是，如果学生可以选择多个老师，老师也可以拥有多个学生呢？
这就是多对多。
学生表：
教师表：
外键表：
发现多对对的情况下，学生表和教师表，都不存在外键。外键存在于另外一张中间表，称之为外键表（当然这张表也有主键，这里为了关注重点，省略了）
通过这个外键表，可以清晰的看出，学生1拥有两个老师(2,3)，学生3有三个老师(1,2,3)
而老师2，有两个学生（1，3），老师3有两个学生（3，1）
约束 更能体现外键作用的是约束，约束其实是定义好的规则，简化对数据库操作。就是某些操作在定义好的约束后，自动完成！这就是定义外键的另一好处。
约束分为删除和更新。删除用的较多。
删除约束 学生表：
手机表：
拿一对一的举例，通常将拥有外键的表称为子表，这里学生表就是子表，手机表就是学生表的主表。 删除约束，就是当主表中的某条记录被删除时，子表中对应的记录如何处理？
方式1：当主表中的某条记录被删除时，对应的子表中的记录中的外键自动置为Null。 方式2：当主表中的某条记录被删除时，对应的子表中的元素自动也删除。 方式3：当主表中的某条记录被删除时，如果子表有记录关联到该主表记录，此时无法删除主表中的这条记录，会报错。 更新约束 这个情况发生较少，就是当手机表中的PhoneId发生更改时，学生表中的PhoneId也会随之自动变化。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/072433696abf1947c6540d3c009d8a32/" rel="bookmark">
			增强深度学习与对抗训练对癫痫发作的鲁棒预测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		标题：Augmenting Deep Learning with Adversarial Training for
Robust Prediction of Epilepsy Seizures Abstract: 癫痫是一种慢性疾病，涉及异常的大脑活动，导致患者失去对意识或运动活动的控制。因此，在癫痫发作之前检测出癫痫发作前的状态可以挽救生命。这个问题是具有挑战性的，因为很难区分在频前状态的脑电图信号和正常频间状态的信号。有三个关键的挑战是以前没有解决的:(1)预测模型在患者之间的表现不一致，(2)缺乏完美的预测来保护患者免受任何事件的影响，以及(3)用于推进机器学习(ML)方法的临界前标记数据数量有限。本文通过一种新颖的方法解决了这些限制，该方法使用对抗性示例，并对带有门控循环单元的组合卷积神经网络进行了优化调整。
与目前的技术水平相比，结果表明，模型鲁棒性提高了3倍，曲线下面积(AUC)的变化减少了，AUC精度平均提高了6.7%。该方法在机器学习和癫痫预测领域的其他进展(包括高斯噪声数据增强和多任务学习)中也表现出优异的性能。
1 Introduction 本文解决了这些挑战，并介绍了一些贡献:
用脑电图时间序列数据增强对抗实例(AE)用于癫痫发作预测。对于机器学习领域来说，AE并不陌生，但它在癫痫数据生成方面的应用是新的。该方法有助于确保模型在数据变化的情况下得到训练时的稳健性。随着更多的训练数据变得可用，该方法也有助于克服训练数据的限制。
虽然卷积神经网络(CNN)和门控递归单元(GRU)的选择对于时间序列来说并不新鲜，但它在癫痫以及癫痫发作预测组件优化方面的应用是新的:(1)时间处理，仔细选择时间窗口，同时检查数据的稳定性，以确保窗口足够大，能够捕捉到所需的模式，同时确保不同时间窗口的一致性。(2)层的具体选择是通过调整过程选择的，以确保最高的准确性，同时保持曲线下面积(AUC)达到的所需稳健性。由此产生的网络拓扑不同于先前的工作。(3)通过用独特的患者数据进行训练并为每个患者生成个体AE，为每个患者开发个体模型。这种方法确保了导出的模型可以在患者之间提供改进的区分。所提出的方法在两个基准数据集上实现了最先进的性能，通过AUC、每小时假阳性率(FPR/小时)和灵敏度进行测量，如下所述。与基于频谱分析的现有技术[36]的比较表明了基于时间的处理的优越性。
在稳健性方面，对于两个基准数据集，结果显示患者之间的差异显著减少。稳健性在两个基准数据组中用几个指标证明，包括:每个数据组中患者的AUC平均标准偏差减少2倍和2.5倍，灵敏度的平均标准偏差减少2倍，每个数据组的AUC范围(患者的最大和最小AUC值之间的差异)减少2.5倍和3倍。就发作前预测的准确性而言，结果显示每个数据集的平均AUC分别提高了2.8%和6.7%。对于每个数据集，灵敏度分别平均提高了3.96%和1.8%。每个数据集的FPR/h分别提高了8%和62.5%。本文的其余部分组织如下:第2节概述了癫痫发作预测的相关工作。第3节介绍了我们提出的方法，第4节包含了实验和结果，并与最先进的技术进行了比较。在第5节中，我们包括了结论和研究结果的总结。
2相关工作 使用机器学习技术进行癫痫分类的相关工作可以分为基于特征的方法和深度学习方法。在每个类别中，研究人员已经检查了癫痫检测和预测的两个不同问题，但通常检查信号中的相似特征。这些方法在这里进一步详述。
2.1基于特征的方法 2.1.1癫痫发作检测: 为特定患者的癫痫发作检测而定制的特征工程技术已经成功实现了非常高的灵敏度89.66%，在21名患者中获得了0.49的FPs/h值[11]和(100%)，在相同患者中具有非常低的假阳性率[7，27]。在[31]中，作者开发了一个机器学习框架，能够识别癫痫检测的关键特征。他们使用支持向量机构建患者特异性模型，同时考虑灵敏度、特异性和潜伏期作为性能指标。该工作为癫痫脑电数据预处理以及特征提取和评价方法提供了一种新的途径。尽管这些方法获得了非常高的灵敏度，但它们严重偏向于特定的数据集。此外，它们仅用于癫痫发作检测，而非预测。
为了推广使用MTL的癫痫发作检测，在[38]中提出了基于特征的患者特异性MTL-SVM模型。提取的特征是通过使用频率范围为0.5至25 Hz的四个滤波器组对每个通道的EEG信号进行滤波，然后类似于[31]中所做的工作计算每个频带内的能量而获得的。此外，所提出的模型被开发来学习各种患者特异性癫痫发作的一般表示，以便更好地推广到所有不同类型的患者特异性癫痫发作。虽然这项工作的目标是提高模型的可推广性，但模型的特征不足以预测癫痫发作，因为它们仅包括来自滤波器组频带的能量特征，不足以检测代表发作前状态的EEG信号的变化。
2.1.2癫痫发作预测: 癫痫发作预测的主要目标是检测发作间期和发作前状态之间的过渡期，称为发作前状态[12]。在以前的工作中，使用机器学习方法探索了用于癫痫发作预测的不同信号处理技术。例如，在[10]中，探索了用于癫痫发作预测的频域和时域特征组合的合理性。提出的特征向量包括自回归拟合误差、去相关时间、能量、迁移率和复杂度、δ、θ、α、β和γ频带中的谱功率、谱边缘(功率、频率)、四个矩(均值、方差、偏斜度、峰度)、六个分解级的能量小波系数。对216名患者测试了所提出的方法，并且对所有患者实现了38.47%的灵敏度和平均0.2 FPR/小时，而仅对24名患者实现了统计显著性。在[28]中，EEG信号段被过滤以获得四个频带，即δ、θ、α、β和γ。从每个频带中提取以下特征:1)归一化谱功率特征2)四个矩3)活动性、移动性和复杂性特征4)信号的累积能量5)拟合10阶AR模型产生的自回归(AR)误差6)去相关时间7)谱边缘功率8)小波系数。此外，实验还包括确定发作前时间、标准化方法、平滑和异常值去除的最佳组合。发现平滑、异常值去除和通过每个特征的最大值进行归一化为大多数患者提供了最好的结果。所提出的方法实现了73.9%的平均灵敏度，10名患者的FPR/h平均为0.15。以前的方法主要依赖于单变量特征，而不是从多个通道的组合中提取的多变量特征。例如，在[3]中，提出了双变量谱带功率特征用于癫痫发作预测。所提出的特征在24名患者中实现了75.8%的平均灵敏度和0.1的FPR/h。在[22]中，探索了非线性双变量特征的使用，例如小波同步。此外，所提出的特征实现了71%的平均灵敏度，15名患者的平均FPR/小时为零。
虽然在基于特征的癫痫发作预测的文献中可以找到不同的推荐特征集，但没有特定的特征集被证明是预测癫痫发作的最佳集[2]。此外，所提出的方法需要领域知识，并且对于不同的患者或不同的数据集可能不能类似地执行。
2.2深度学习方法 深度神经网络(DNN)模型，如卷积神经网络CNN和递归神经网络(RNNs)，已被证明在从时间序列序列中自动提取特征和学习时间动态方面非常有效[25，40]。在[16]中，研究人员引入了一种自动癫痫检测方法，这种方法对现实生活条件下的噪声具有鲁棒性。他们使用具有时间分布密集层的长短期记忆(LSTM)从EEG信号中自动提取鲁棒特征。在一项预测癫痫发作的模型性能研究中，由[13]进行了全面的比较。有人指出，由CNN和长短期记忆(LSTM)组成的模型在灵敏度和虚警率方面优于(隐马尔可夫模型(HMM)、HMM堆叠去噪自动编码器(SdA)、HMM-LSTM、增量主成分分析(IPCA) -LSTM、CNN多层感知器)。
对于癫痫发作预测,[1]的作者使用由5个卷积层组成的1D-CNN从原始EEG信号进行自动癫痫发作预测。这种方法只在FB数据集[24]上进行了测试。在[18]中，作者提出在将数据馈送到CNN模型之前，对EEG信号使用小波变换(CWT)作为预处理步骤。在[19]中，提出了一种可以在低功率设备上运行的深度学习模型，用于使用从大脑表面获得的颅内EEG信号来执行实时癫痫预测。在使用期内，可以使用用户的数据来自动重新训练所提出的模型，其中在每个月之后，可以使用来自患者的新记录数据来微调该模型。该模型还可以在智能手表上运行，并提供比随机预测器好42%的预测，平均灵敏度为69%。所提供的模型是用户特定的，需要在开始预测之前记录用户2个月的数据，并且对于真实世界的使用来说不够可靠，因为它只对15个患者和一个数据集进行了测试。此外，在保持整个发作前状态进行测试，同时对其余数据进行训练以确保概括的情况下，没有对所有前述方法进行评估。在[36]中，研究人员提供了一种癫痫发作预测的通用方法，其中他们使用只有三层的2D CNN以避免过度拟合。使用短时傅立叶变换(STFT)将EEG信号转换成类似图像的数据，以使其适用于2D CNN。然而，这种方法的主要缺点是它不能模拟信号的时间动态和长期相关性。
2.3泛化方法 研究表明，研究深度网络如何失败并强化其对抗对抗性攻击将有助于更好地理解dnn的工作原理并提高其泛化能力[4,23,29,35]。[15]表明，与生成ae的原始数据相比，ae具有不同的统计分布。这表明ae在统计上不同于生成它们的数据集。在[34]中，作者提出用ae增强训练数据以提高网络的鲁棒性。此外，[14]引入了具有对抗目标函数的训练，与dropout相比，该函数表现为更好的正则化器，并实现了更好的泛化。因此，[33]使用ae训练来提高深度神经网络对噪声和信道变化语音识别的鲁棒性。
总之，现有的方法都没有解决模型对其他大脑活动噪声的鲁棒性和患者癫痫发作预测的差异。
3 所提出的机器学习模型 本文的目的是开发一种适用于从原始脑电信号中自动提取特征、准确检测癫痫发作前状态并对脑电信号中的噪声具有鲁棒性的方法。癫痫发作预测的主要挑战之一是一些发作间期状态类似于发作前状态，如图2所示。可以看出，有时，对一个患者来说似乎是发作前信号的信号可能对另一个患者来说似乎是发作间信号，反之亦然。
图二 来自CHB-MIT数据集的EEG信号。a)患者(1)在频域和时域中的发作间信号。b)患者(3)在频域和时域中的发作前信号。频域中每个子图的“X”轴表示频率，单位为赫兹，时域中表示时间，单位为秒。两个子图的“Y”轴是以微伏为单位的振幅。
另一个更具挑战性的情况是，发作间状态可能类似于同一患者的发作前状态，如图3所示。
图3 来自CHB-MIT数据集的EEG信号。a)患者(14)在频域和时域中的发作前信号。b)患者(14)在频域和时域中的发作间信号。频域中每个子图的“X”轴代表以Hz为单位的频率，时域中代表以秒为单位的时间。两个子图的“Y”轴是以伏特为单位的幅度。
图4显示了针对提议的对立示例(AEs)的高级解决方案。图4描述了使用(AEs)进行学习的高级步骤，其中首先使用EEG信号训练建议的模型，然后使用训练的模型生成AEs。然后，将训练数据与AEs相结合，以在扩充数据上重新训练模型。系统的输入包括从颅骨外的皮肤电极(头皮脑电图)和大脑表面的植入电极(颅内脑电图)记录的脑电图信号。该系统的输出是癫痫发作状态预测、发作间期或发作前状态。
3.1数据预处理 采用陷波滤波器对脑电信号进行滤波，去除电力线噪声。Freiburg数据集被50 Hz的电源频率污染，而CHB-MIT数据集被60 Hz的电源频率污染。因此，对于Freiburg数据集和CHB-MIT数据集，频率范围为47–53Hz和97–103Hz以及57–63Hz和117–123Hz的分量分别被移除。
之后，使用z-score对数据进行归一化，以确保所有通道的平均值和单位方差为零。之后，EEG信号用长度为30s的滑动窗口分割，50%重叠以确保平稳性。使用增广的Dickey-Fuller (ADF)测试检查加窗信号的平稳性，这是一种单位根测试，使用自回归模型并优化多个不同滞后值的信息标准[9]。在ADF测试中，我们首先定义了零假设，该假设表明信号可以由单位根来表示，单位根表示信号中的时间相关结构，因此表示其非平稳性。我们指定显著性水平为5%。在对加窗信号应用这种测试方法之后，我们发现所有生成段的p值都显著低于5%。因此，我们拒绝零假设，并得出结论，有足够的证据表明，所产生的部分是稳定的。
3.2 CNN-GRU模型 图5所示 采用CNN-GRU架构，其中FB和CHB-MIT数据集的批大小为256，脑电信号的窗口长度为7680，通道数分别为6和22。
所提出的模型如图5所示，其简短描述如下:C(f,k,s):用过滤器数量“ f ”、内核大小“k”和步进数量“s”表示卷积层。该模型由卷积层组成，通过叠加多个操作符来创建抽象特征的层次。在处理EEG时间序列时，采用一维卷积运算对时间序列信息进行建模。每个卷积核都充当一个过滤器，过滤掉时间序列数据并检测相关模式。此外，卷积核对多变量信号进行深度滤波，其中每个通道对应的权重在训练阶段被学习，从而通过通道获得最佳的信号集成。
循环层由门控循环单元(gru)组成，对脑电信号的时间依赖性进行建模。gru是一种特殊的循环单元，它具有更新和重置门，允许模型决定保留多少历史信息。该特性使所提出的深度体系结构能够对时间序列的时间动态以及长期依赖关系进行建模。
3.3对抗性学习 通常，经过良好训练的机器学习模型 f(x:θ)能够捕捉模型的输入 Xi 和输出 Yi 之间的非线性关系，其中 θ 代表模型参数。为了给学习模型提供更好的泛化，我们建议使用用对抗性示例来增强训练数据的想法，以提高模型对对抗性示例以及来自破坏EEG信号的真实生活条件的噪声：肌肉伪影和眨眼的稳健性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/072433696abf1947c6540d3c009d8a32/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30d4193493d7aa1c6bdf7b80c6b278d0/" rel="bookmark">
			窗口函数 OVER(PARTITION BY ...)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开窗函数的语法结构：分析函数() over(partition by 分组列名 order by 排序列名 rows between 开始位置 and 结束位置)
over()函数中包括三个函数：分区partition by 列名、排序order by 列名、指定窗口范围rows between 开始位置 and 结束位置
rows between … and … 用得较少
我们知道聚合函数对一组值执行计算并返回单一的值，如sum()，count()，max()，min()， avg()等，这些函数常与group by子句连用。除 COUNT 外，聚合函数忽略空值。
但有时候一组数据只返回一组值是不满足需求的，如经常想知道各地区的前几名、各个班或各个学科的前几名。这时候需要每一组返回多个值。用开窗函数解决这类问题非常方便。它和聚合函数的不同之处是：对于每个组返回多行，而聚合函数对于每个组只返回一行。
建表 DROP TABLE IF EXISTS temp CREATE TABLE temp( id INT, name VARCHAR(10), class VARCHAR(10), score INT ); INSERT INTO temp (id, name, class, score) VALUES (1,'公孙衍', '2', 81); INSERT INTO temp (id, name, class, score) VALUES (2,'廉颇', '3', 55); INSERT INTO temp (id, name, class, score) VALUES (3,'李牧', '3', 55); INSERT INTO temp (id, name, class, score) VALUES (4,'王翦', '1', 96); INSERT INTO temp (id, name, class, score) VALUES (5,'王贲', '1', 92); INSERT INTO temp (id, name, class, score) VALUES (6,'白起', '1', 96); INSERT INTO temp (id, name, class, score) VALUES (7,'蔺相如', '3', 90); INSERT INTO temp (id, name, class, score) VALUES (8,'赵胜', '3', 81); INSERT INTO temp (id, name, class, score) VALUES (9,'赵雍', '3', 93); INSERT INTO temp (id, name, class, score) VALUES (10,'魏无忌', '2', 92); OVER(PARTITION BY … ORDER BY … DESC) 实例：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/30d4193493d7aa1c6bdf7b80c6b278d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f78f74c3a95930c684fbcec557bc90e1/" rel="bookmark">
			2020电赛F题总结回顾（openmv实现视觉）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我决定把资源倒腾倒腾发上来，一方面分享大致思路，另一方面也当是纪念了
做的是2020电赛F题：简易无接触温度测量与身份识别装置
文章目录 题目整体设计硬件选择软件流程 视觉算法分辨不同人脸（身份识别）口罩识别现场学习其他优化算法 总结 题目 整体设计 硬件选择 机器视觉模块使用openmv，这一方面是我们在备赛过程中认为openmv的功能足够，一直在准备openmv，另一方面是当时马上下单k210开始学习等到货都已经第三天了，调试来不及风险太大了，所以决定使用openmv
好在我们买的是最顶配型号openmvH7Plus，最终也顺利完成了题目要求的所有任务
温度测量方面是MLX90614使用某宝的模块i2c读取温度，最终我们没有省一拿了省二也是砸在这个模块上，在送测现场出了问题，血的教训，万事都要做好plan B啊~~
主控使用stm32c8t6，这是因为我们在赛前已经用顺手了，其他的也行
其他硬件包括oled显示温度阈值等，按键，有源蜂鸣器，激光小灯等就不赘述了
最后的电路板设计，器件布局如下
软件流程 stm32和openmv通过串口通信，我们指定一个字母对应进入一个模式，通电后openmv就在死循环不断等待字母，收到字母即执行对应模式功能，再返回结果。具体可看软件流程图：
视觉算法 由于分工上我主要负责openmv视觉部分的代码编写等部分，所以这里多说几句视觉方面的python代码编写的心路历程
刚开始学习阶段主要参考的资料就是心疼科技的两个函数库链接：
https://book.openmv.cc/
https://docs.singtown.com/micropython/zh/latest/openmvcam/library/index.html
b站视频也有看点
分辨不同人脸（身份识别） 拿到题目第一反应就是中文入门教程里面看到过这个LBP分辨不同人脸的应用，于是我第一天也确确实实按照手册的思路拍照测试了，但是实际效果并不好，而且受光线和背景影响很大，脸还必须填满摄像头，就很不方便
于是后来又发现了特征点算法，运算时间有了很大提升，但还有一个问题就是如果背景拍到的范围过大，那么将会从背景提取很多无用的特征点，而要求人保持一定的距离把人脸填满屏幕实在太蠢了，怎么解决呢？
我的方法是先加一层人脸识别，将人脸部分局部放大截取出来再拿去提取特征点并进行特征点比对，通过这种方法，就不用对被识别者有很大的要求，实现类似k210一样的功能啦~
关于上面这个思路，直接上代码：
#画出特征点 def draw_keypoints(img, kpts): if kpts: print(kpts) img.draw_keypoints(kpts) img = sensor.snapshot() time.sleep(1000) def find_max(pmax, a, s): global face_num if a&gt;pmax: pmax=a face_num=s return pmax def Distinguish_faces(): global NUM_SUBJECTS global NUM_SUBJECTS_IMGS pyb.LED(3).on() # 重置传感器 sensor.reset() sensor.set_contrast(3) sensor.set_gainceiling(16) sensor.set_framesize(sensor.VGA) sensor.set_windowing((240, 240)) #sensor.set_framesize(sensor.B128X128) # or sensor.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f78f74c3a95930c684fbcec557bc90e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c9502c961ab00544929bae581237d0d/" rel="bookmark">
			【案例实战】高并发业务的多级缓存架构一致性解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们在高并发的项目中基本上都离不开缓存，那么既然引入缓存，那就会有一个缓存与数据库数据一致性的问题。
首先，我们先来看看高并发项目里面Redis常见的三种缓存读写模式。
Cache Aside
读写分离模式，是最常见的Redis缓存模式，多数采用。 读写数据时需要先查找缓存，如果缓存中没有，则从数据库中查找数据。 如果查询到数据，需要将数据放到缓存中，下次访问再直接从缓存中获取数据，以提高访问效率。 写操作通常不会直接更新缓存，而是删除缓存，因为存储结构是hash、list，则更新数据需要遍历。 优点 读取效率高，缓存命中率高，写操作与数据库同步，数据一致性较高，实现较为简单。 缺点 数据库和缓存之间存在数据不一致的问题，需要考虑缓存失效和数据库更新操作带来的缓存不一致问题。 应用场景 适用于读操作非常频繁而写操作相对比较少的情况，如电商网站的商品详情页，读取次数远高于更新和添加操作。 Read/Write Through
读写穿透模式，读写操作会直接修改缓存，然后再同步更新数据库中的数据，开发较为复杂，一般少用。 在Read/Write Through模式下，每次数据的读写操作都会操作缓存，再同步到数据库，以保证缓存和数据库数据的一致性。 应用程序将缓存作为主要的数据源，数据库对于应用程序是透明的，更新数据库和从数据库的读取的任务都交给缓存来实现。 优点 写操作速度较快，一致性较高，缓存与数据库的数据保持一致，缓存命中率较高。 缺点 读操作较慢，如果缓存没有可用数据，每次都会进行数据库查询，数据量较大时会对性能带来较大的影响。 应用场景 系统处理写操作频繁且读操作不频繁的场景，如云存储Ceph Write Behind
被称为Write Back模式或异步写入模式，一般较少使用。 如果有写操作，缓存会记录修改了缓存的数据，但是并不会立即同步到数据库中。 一般会把缓存中的数据更新到磁盘中，等到后续有查询数据操作时，再异步批量更新数据库中的数据。 该模式的优点就是写操作速度很快，不会对性能产生影响，同时也避免了频繁更新数据库的情况，提升了数据库性能。 优点 写操作速度快，性能较高，数据一致性一般较高。 缺点 读操作较慢，由于异步方式更新数据库，可能会存在数据的延迟。 应用场景： 用于较数据读写比重较高的场景，如游戏中的用户活动积分等信息，刚开始对写操作性能要求很高，后续查询比较少。 业务开发里面，基本都是从数据库读取到缓存里面，那缓存和数据库的读写顺序是怎样的？
场景一：先更新数据库，再更新缓存
线程A 更新数据库，更新完数据库，线程A 更新缓存，缓存更新成功，但是线程A 数据库事务commit失败，或者方法体发生异常，进行rollback 。会导致缓存和数据库不一致 。 场景二：先删缓存，再更新数据库
线程A 删除缓存，更新数据库，但是还没commit。这时线程B访问缓存，发现没数据，去数据库读取未commit的放到缓存，也就是老数据。线程A 进行了commit操作。这也会导致缓存是老数据和数据库是新数据，不一致。 场景三：先删除缓存，再更新数据库，再删除缓存
线程A 删除缓存，更新数据库，但是还没commit。线程B访问缓存，发现没数据，去数据库读取未commit的放到缓存（老数据 ）。线程A 进行了commit操作。线程A 再次删除缓存数据（这时缓存为空，后续读取就是最新的数据）。保证了数据的一致性，但是浪费了多次IO，相当于每次都要多删一次Redis。 OK，我们回归正题，什么是多级缓存架构？
多级缓存架构是一种通常用于优化应用程序性能且高可用的缓存技术，通常由多层缓存组成，其中每一层缓存可以根据其不同的特征和作用进行选择和调整。通过缓存数据的多份副本，最大化应用程序性能和可用性，避免缓存穿透、缓存击穿、以及数据不一致的问题。
这里我们采用Nginx+Lua+Canal+Redis+Mysql架构，也就是说读操作通过Lua查询Nginx的缓存，如果Nginx缓存没有数据，则查询Redis缓存，如果Redis缓存也没有数据，直接查询mysql。写操作时，Canal监听数据库指定表的增量变化，Java程序消费Canal监听到的增量变化写到Redis中。Java-canal程序操作Redis缓存，Nginx本地缓存是否应用和失效，取决项目类型。
OK，什么是Canal呢？
阿里巴巴基于 MySQL 的增量日志解析和订阅发布系统，主要用于解决数据订阅与消费问题。Canal主要支持了MySQL的binlog解析，解析完成利用canal client 用来处理获得的相关数据。
早期阿里巴巴因为杭州和美国双机房部署，存在跨机房同步的业务需求，实现方式主要是基于业务 trigger 获取增量变更。从 2010 年开始，业务逐步尝试数据库日志解析获取增量变更进行同步，由此衍生出了大量的数据库增量订阅和消费业务。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c9502c961ab00544929bae581237d0d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/438a9b0453100d5014912c567a8283f9/" rel="bookmark">
			推荐一个好用的Python词云展示库-wordcloud
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录标题 前言1.介绍2.使用说明尾语 前言 嗨喽~大家好呀，这里是魔王呐 ❤ ~!
1.介绍 wordcloud是优秀的词云展示第三方库，wordcloud能够将一段文本变成一个词云。
词云就是将词语通过图形可视化的方式，直观和艺术的展示出来。词云在我们的生活中经常能够看到，无论是中文的词云还是英文的词云。
安装第三方库需要使用pip工具，在命令行下运行安装命令（不是IDLE）。
注意：需要将Python目录和其目录下的Scripts目录加到环境变量中。
使用命令pip install wordcloud安装第三方库，安装之后会提示successfully installed，告知是否安装成功。
2.使用说明 wordcloud库把词云当做一个WordCloud对象，即wordcloud.WordCloud()是一个代表文本对应词云的对象，一个词云就是一个WordCloud对象。
wordcloud库可以根据文本中词语出现的频率等一系列参数来绘制词云，在绘制词云时，词云的形状、尺寸、颜色包括字体都是可以设定的。
wordcloud库对具体词云的绘制有一个基本的思路，思路是用wordcloud库中的WordCloud对象来表明一个词云，WordCloud对象是一个词云的对象基础，然后向这个对象中配置参数、加载文本、输出到文件中。
python资料、源码、教程\福利皆: 点击此处跳转文末名片获取
这同样也是词云绘制的步骤：
配置对象参数；
加载词云文本；
输出词云文件。
为了完成后两个步骤，我们需要将WordCloud对象赋给一个变量名，使得后两个步骤可以调用，例如：w=wordcloud.WordCloud()。
配置对象参数（参数之间使用逗号隔开）：
width
指定词云对象生成图片的宽度，默认400像素，例如：
&gt;&gt;&gt;w=wordcloud.WordCloud(width=600) height
指定词云对象生成图片的高度，默认200像素，例如：
&gt;&gt;&gt;w=wordcloud.WordCloud(height=400) min_font_size
指定词云中字体的最小字号，默认4号，例如：
&gt;&gt;&gt;w=wordcloud.WordCloud(min_font_size=10) max_font_size
指定词云中字体的最大字号，根据高度自动调节，例如：
&gt;&gt;&gt;w=wordcloud.WordCloud(max_font_size=20) font_step
指定词云中字体字号的步进间隔，默认为1
&gt;&gt;&gt;w=wordcloud.WordCloud(font_step=2) python资料、源码、教程\福利皆: 点击此处跳转文末名片获取
font_path
指定字体文件的路径，默认为None
&gt;&gt;&gt;w=wordcloud.WordCloud(font_path="msyh.ttc") max_words
指定词云显示的最大单词数量，默认200，例如：
&gt;&gt;&gt;w=wordcloud.WordCloud(max_words=20) stop_words
指定词云的排除单词列表，即不显示的单词列表，例如：
&gt;&gt;&gt;w=wordcloud.WordCloud(stop_words={"Python"}) mask
指定词云形状（提供白色的形状图片），默认为长方形，在使用时需要引用imread()函数，例如：
&gt;&gt;&gt;from scipy.misc import imread &gt;&gt;&gt;mk=imread("pic.png") &gt;&gt;&gt;w=wordcloud.WordCloud(mask=mk) background_color
指定词云图片的背景颜色，默认为黑色，例如：
&gt;&gt;&gt;w=wordcloud.WordCloud(background_color="white") 加载词云文本方法（默认前提w=wordcolud.WordCloud()）：
w.generate(txt)
向WordCloud对象w中加载文本txt，例如：
&gt;&gt;&gt;w.generate("Python and WordCloud"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/438a9b0453100d5014912c567a8283f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4053ff6e0c97b140f99ca2b67a46cc6a/" rel="bookmark">
			PaddleSeg中交互式分割EISeg的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		EISeg(Efficient Interactive Segmentation)是基于飞桨开发的一个高效智能的交互式分割标注软件。它涵盖了通用、人像、遥感、医疗、视频等不同方向的高质量交互式分割模型。另外，将EISeg获取到的标注应用到PaddleSeg提供的其他分割模型进行训练，便可得到定制化场景的高精度模型，打通分割任务从数据标注到模型训练及预测的全流程。
Windows上安装EISeg:
1.PaddleSeg在windows上的配置参考：https://blog.csdn.net/fengbingchun/article/details/131344901
2.在已安装PaddleSeg的基础上进行安装，执行如下命令：
pip install eiseg 安装完后，在Anaconda Powershell Prompt中输入eiseg即可运行软件，软件界面如下图所示：
EISeg的使用，打开软件界面后，以人像分隔为例：
1.从https://github.com/PaddlePaddle/PaddleSeg/blob/release/2.8/EISeg/docs/image.md 下载高精度模型static_hrnet18_ocr64_human.zip，解压缩；
2.模型参数加载：文件 --&gt; 加载模型参数：选择static_hrnet18_ocr64_human.pdiparams，
处理OMP Error: Initializing libiomp5md.dll, but found libiomp5md.dll already initialized. Hint This means that multiple copies of the OpenMP runtime have been linked into the program.
解决方法：将Anaconda3/envs/PaddleSeg/Library/bin目录下的libiomp5md.dll重命名或删除
3.图像加载：文件 --&gt; 打开图像：选择图像; 也可打开图像文件夹：文件 --&gt; 打开文件夹：选择文件夹
4.添加标签：点击界面"添加标签"按钮，新建标签，标签分为4列，分别对应像素值、说明、颜色和删除。可点击"标注"，导出标签列表、也可载入标签列表和清空标签列表。
5.开始标注：标注首先进入交互式分割模式。鼠标左键代表正点击，表示所选择的前景部分；鼠标右键代表负点击，为用户选定的背景区域。用户可以通过正负点击操作来选择感兴趣的区域，直到满意为止。
交互完成后使用Space(空格)完成交互标注，此时出现多边形边界，进入多边形标注模式。多边形可以删除，通过backspace键。使用鼠标左键点击锚点可以进行拖动。鼠标左键双击锚点可以删除锚点。双击两点之间的边则可在此边添加一个锚点。
6.自动保存设置(文件 --&gt; 自动保存):在使用中可以将自动保存设置上，设定好文件夹即可，这样在使用时切换图像会自动将完成标注的图像进行保存。
标注结果如下图所示：测试图来自于网络，左图为原图，右图为分隔后的结果
分隔后的结果并没有透明图，生成透明图的代码如下所示：image_generic_operations.py
import os import sys import cv2 from inspect import currentframe, getframeinfo import argparse import numpy as np def get_image_list(path, image_suffix): image_list = [] for x in os.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4053ff6e0c97b140f99ca2b67a46cc6a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d4f93c841603e658be6b4cc48ab59cf/" rel="bookmark">
			超详细SpringBoot&#43;Vue项目部署(两个Vue项目)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1：项目部署所使用的工具或资源2：SpringBoot项目部署2.1更改跨域配置2.2项目打包2.3部署jar包2.3.1上传jar包和静态资源文件2.3.2安装JDK2.3.3安装MySQL2.3.4导入sql文件资源2.3.5运行jar包 2.4接口测试 3.Vue项目部署3.1更改代理服务器、axios、Vuex配置3.2将项目打包上传到云服务器3.3Nginx安装3.4部署第一个Vue项目3.4.1将已经打包好的dist文件传送到nginx以下指定目录3.4.1修改nginx.conf配置文件 3.5部署第二个Vue项目 部署进阶篇：docker部署 博客地址：http://t.csdn.cn/8NJe8 1：项目部署所使用的工具或资源 Xshell：用于在本机Windows界面访问远端不同系统下的服务器。
Xshell官网
Xftp：Xftp是一个功能强大的SFTP、FTP 文件传输软件。使用了 Xftp 以后，MS Windows 用户能安全地在 UNIX/Linux 和 Windows PC 之间传输文件。
​ Xftp官网
Postman：Postman是一个接口测试工具，本次部署中用于测试后端接口。
​ 相较于Postman，可以有更好的选择即ApiFox。在本次部署中为方便采用Postman。
Nginx：Nginx是一个高性能的 HTTP 和反向代理服务器，可以作为静态页面的 web 服务器
ECS服务器或者轻量应用服务器：
可以选择大厂云服务器供应商，如阿里、腾讯、华为。本次部署中采用腾讯云服务器。
我购买的云服务器配置是2核2GB，镜像为CentOS 7.6
2：SpringBoot项目部署 2.1更改跨域配置 将跨域配置修改为云服务器的公网ip
2.2项目打包 一：首先打开maven，在maven生命周期选择clear选项，clear命令是maven的清除命令，这一步的目的是为了清空target目录下的所有内容。
二：选择package选项，将项目打成jar包。
三：控制台出现BUILD SUCCESS就表示打包成功
四：查看target目录，找到打包好的项目jar包。
2.3部署jar包 2.3.1上传jar包和静态资源文件 一：查看SpringBoot项目服务端口：我的是8090
二：在控制台开放相应端口
三：打开Xshell，输入云服务器公网ip创建一个新的会话。
四：双击刚刚创建的会话进行连接，输入用户名和密码
五：密码如果忘记的话到控制台中进行修改：
连接成功：
六：创建新目录，并将jar包通过Xftp传输到新创建的目录当中，如果有静态资源的话就传输到jar包的同级目录下：
2.3.2安装JDK jdk官网：Java Downloads | Oracle
下载Linux版本：
一：将JDK传输到项目目录
二：解压至自定义目录（一般是 /usr/local）
tar -xzvf jdk-8u291-linux-x64.tar.gz -C /usr/local/ 二：配置环境变量。进入到/etc目录下，用vim编辑器在 profile 文件中添加四个变量。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d4f93c841603e658be6b4cc48ab59cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53be03466af26f0f8f54a35474979f6c/" rel="bookmark">
			Linux 正则表达式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux grep 命令详解 （正则表达式） 主要内容 查找取出匹配 查找、取出、匹配复符合条件的摸个字符或字符串
体验 sudo grep 'nameserver' /var/log/syslog 正则表达式单字符 特定字符范围内字符任意字符 某个具体字符 grep root /etc/passwd grep lhz /etc/passwd grep nginx /etc/passwd grep 'usr' centos8编译安装nginx.txt 单引号和双引号 单引号：可以说是所见即所得：即将单引号内的内容原样输出，或者描述为单引号里面看到的是什么就会输出什么。单引号’'是全引用，被单引号括起的内容不管是常量还是变量者不会发生替换。
双引号：把双引号内的内容输出出来；如果内容中有命令、变量等，会先把变量、命令解析出结果，然后在输出最终内容来。双引号""是部分引用，被双引号括起的内容常量还是常量，变量则会发生替换，替换成变量内容。
不加引号：不会将含有空格的字符串视为一个整体输出, 如果内容中有命令、变量等，会先把变量、命令解析出结果，然后在输出最终内容来，如果字符串中带有空格等特殊字符，则不能完整的输出，需要改加双引号，一般连续的字符串，数字，路径等可以用。
使用规则：一般常量用单引号’'括起，如果含有变量则用双引号""括起。
最大不同：单引号与双引号的最大不同在于双引号仍然可以保有变数的内容，但单引号内仅能是一般字元，而不会有特殊符号
使用举例：
"“号里面遇到KaTeX parse error: Undefined control sequence: \等 at position 2: ，\̲等̲特殊字符会进行相应的变量替换 …a” file #引用变量a,查找变量a的值
grep 'KaTeX parse error: Expected 'EOF', got '#' at position 17: …' file #̲查找“a”字符串
grep “\” file #grep: Trailing backslash（不知原因）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/53be03466af26f0f8f54a35474979f6c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ed4b78398ad123e469e86bd7df41d7a/" rel="bookmark">
			10-切片是什么？【视频版】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 问题视频解答 问题 视频解答 点击观看：
10-切片是什么？
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa7d04a07345f906661fac6f4c5c0272/" rel="bookmark">
			9-如何获取N维数组元素？【视频版】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 问题视频解答 问题 视频解答 点击观看：
9-如何获取N维数组元素？
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92a8f870cc8dd7b894c76889b90ee428/" rel="bookmark">
			C专家编程 —— 运行时数据结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 代码和数据段代码与可执行文件中对应的位置可执行文件中的段在内存中的布局加入动态链接库的内存空间布局堆栈段的作用过程活动记录函数调用过程记录举例 static和auto关键字 汇编嵌入C代码 代码和数据 代码和数据的区别可以理解为编译时和运行时的分界线。
代码：即C语言编写的
编译器的工作绝大部分是翻译代码
数据：运行时的可执行文件中保存的二进制数据。
段 目标文件和可执行文件由几种不同的格式，一般称作ELF格式，在UNIX中为a.out格式。
所有不同格式都有一个不同概念，那就是段segment。
段对Unix目标文件来说：他是二进制文件中的简单的区域划分，内容块。里面保存了某种特定类型的相关所有信息。
section：是ELF文件中的最小组织单位。一个段一般包含几个section。
而段在Intel x86模型中，表示一种设计结果，设计地址空间并非一个整体而是分成一些64K大小的区域，称为段。
当对一个可执行文件执行size命令时，比如size a.out就会打印出该文件的3个段，text, data, bss段的大小。
代码与可执行文件中对应的位置 BSS段（可读写）：未初始化的全局和静态变量
data段（可读写）：初始化后的全局和静态变量
text段（只读）：程序代码段，主要存指令，存放函数体的二进制代码。
.rodata段：常量，const,及字符串常量
栈(stack)：保存函数的局部变量和参数
堆(heap)保存函数内部动态分配内存
int a = 0; 全局初始化区 char *p1; 全局未初始化区 main() { int b; 栈 char s[] = "abc"; 栈 char *p2; 栈 char *p3 = "123456"; 123456/0在常量区，p3在栈上。 static int c =0； 全局（静态）初始化区 p1 = (char *)malloc(10); p2 = (char *)malloc(20);//分配得来得10和20字节的区域就在堆区。 strcpy(p1, "123456"); 123456/0放在常量区，编译器可能会将它与p3所指向的"123456"优化成一个地方。 } 可执行文件中的段在内存中的布局 下图我们可以看到可执行文件段对应到程序内存中的段。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/92a8f870cc8dd7b894c76889b90ee428/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e52d37995e3ec0c4b7811310b1d6a79/" rel="bookmark">
			HCIP-7.5交换机RSTP快速生成树协议原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HCIP-7.5交换机RSTP快速生成树协议原理 1、RSTP快速生成树（rapid spanning Tree Protocol2、RSTP基本计算过程3、RSTP端口状态描述3.1、交换机端口状态（五转三）去掉了侦听状态3.2、P/A机制(Proposal/Agreement机制) 4、RSTP的报文5、RSTP与STP变化6、配置RSTP－基本配置7、RSTP如何实现快速收敛7.1、STP的收敛机制7.2、RSTP的收敛机制 8、RSTP对STP保护机制 1、RSTP快速生成树（rapid spanning Tree Protocol RSTP（802.1w）是STP的升级版本。最根本的原因是BPDU的变化。最早在IEEE 802.1W-2001中提出，这种协议在网络结构发生变化时，能更快的收敛网络。它比802.1d多了一种端口类型：备份端口（backup port）类型，用来做指定端口的备份。
RSTP的主要功能：
1、 发现并生成局域网的一个最佳树型拓扑结构；
2、 发现拓扑故障并随之进行恢复，自动更新网络拓扑结构，启用备份链路，同时保持最佳树型结构。
2、RSTP基本计算过程 选举预备端口和备份端口
DP(指定端口)用来发送或者中继最优的BPDU。
SWC E0/1为DP中继BPDU --&gt;LANA 云 --&gt;SWD 同时也通过LANA 云–&gt;E0/2 给自己。
Backup备份端口：这种由于学习到自己发送的配置BPDU报文而阻塞的端口。
上图中，E0/2在RSTP网络中作为备份端口。阻止接收到自己发送的配置BPDU报文。E0/1和E0/2口同时接入到以太网的同一网段，E0/1为指定端口，E0/2优先级低，则E0/2端口为备份端口。
Alternate预备端口：是由于学习到其它网桥发送的配置BPDU报文而阻塞的端口。
上图中，SWC学习到SWB发送的置BPDU报文，在进行计算后，为防止环路形成而阻塞的端口。与STP一样。
可以发现交换机端口角色-增加了Backup备份端口角色。
RSTP中的端口
端口角色描述Root Port 根端口是所在交换机上离根交换机最近的端口，稳定时处于转发状态。Designated Port指定端口转发所连接的网段发往根交换机方向的数据和从交换机方向发往所连接的网段的数据，稳定时处于转发状态。Backup备份端口不处于转发状态，所属交换机为端口所连网段的指定交换机。指定端口的备份端口。Alternate预备端口不处于转发状态，所属交换机不是端口所连网段的指定交换机。 边缘端口的引入
边缘端口（Edge Port）是指不直接与任何交换机连接，也不通过端口所连接的网络间接与任何交换机相连的端口。 当把一个交换机端口配置成为边缘端口之后，一旦端口被启用，则端口立即成为指定端口（Designated Port） ，立即进入转发状态。 和STP的配置命令相同但是在STP中是补丁，而在RSTP 是定义。
每次边缘端口PC关机后，由末节交换机将TCN上报到根桥，又由根桥发送TC扩散到全网二层网络，每个交换机都要刷新MAC地址。定义了边缘端口可以防止这一现象产生，并拒绝接入BPDU。
总结：边缘端口不参与RSTP运算，可以由Disable直接转到Forwarding状态，且不经历时延，就像在端口上将STP禁用。
3、RSTP端口状态描述 3.1、交换机端口状态（五转三）去掉了侦听状态 在RSTP中只有三种端口状态，Discarding、Learning和Forwarding。802.1D中的禁止端口，监听端口，阻塞端口在802.1W中统一合并为禁止端口。
端口状态描述Discarding丢弃状态此状态下端口对接收到的数据做丢弃处理，端口不转发数据帧，不学习MAC地址表。Learning学习状态此状态下端口不转发数据帧，但是学习MAC地址表，参与计算生成树，接收并发送BPDU。Forwarding转发状态此状态下端口正常转发数据帧，学习MAC地址表，参与计算生成树，接收并发送BPDU。 端口状态迁移原则
在没有临时环路风险的情况下，使原本处于不转发状态下的端口在成为指定端口或根端口之后，尽可能快的进入Forwarding状态，加快收敛速度。
存在环路风险，需要等待其他交换机完成计算。
因此，如何确认网络中有没有环路风险是RSTP的重要内容。
3.2、P/A机制(Proposal/Agreement机制) Proposal－Agreement” 提议和同意。
当SWD成为根桥后，SWD的E0/1由阻塞端口变成指定端口，正处于Discarding或Learning状态的时候，向SWC的E0/1发出传递Proposal位被置位的BPDU。这条BPDU作用提议是SWC的E0/1指定端口希望进入Forwarding状态。
当下游交设备SWC的E0/1端口收到这条被置位的BPDU后，将其它其他端口(如果端口是非边缘)的E0/2指定端口变成禁止端口则会进入Discarding状态，防止产生环路。然后会设置自己的synced变量，然后传回其中Agreement位被置位的BPDU。这时SWC的E0/1端口由原来的指定端口转化为根端口。
SWD收到Agreement位被置位的BPDU，SWD的E0/1马上转入Forwarding状态。
SWC的E0/2端口由禁止端口变成指定端口，从Discarding状态正处于Discarding或Learning状态的时候，向SWA的E0/1发出传递Proposal位被置位的BPDU。
SWA状态和上面一样忽略。
协商机制的前提－点到点链路
使用“Proposal－Agreement”的前提 是泛洪这两种消息的链路均为点到点链路，点到点链路是指两个交换机直接相连的链路。之所以必须使用点到点链路，是因为点到多点链路有环路风险。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e52d37995e3ec0c4b7811310b1d6a79/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2f5ee3788fd4596bec0d09211537d52/" rel="bookmark">
			Vue3将参数发送到路由而不将它们添加到url
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		正常的路由跳转 路由文件：
import { createRouter, createWebHistory } from 'vue-router' import type { RouteRecordRaw } from 'vue-router' const routes: Array&lt;RouteRecordRaw&gt; = [ { path:"/", name:"Home", component: () =&gt; import("../views/Home.vue"), }, { path:"/about", name:"About", component: () =&gt; import("../views/About.vue"), } ]; const router = createRouter({ history: createWebHistory(), routes, }); export default router; 路由跳转：
&lt;template&gt; &lt;router-link :to="'/about?id='+4"&gt;跳转到about页面&lt;/router-link&gt; &lt;br/&gt;&lt;br/&gt; &lt;router-link :to="{ name: 'About', query: { id: 1 } }"&gt;带参数跳转&lt;/router-link&gt;&gt;&lt;br/&gt;&lt;br/&gt; &lt;v-btn @click="toAbout(2)"&gt;编程式导航跳转&lt;/v-btn&gt;&lt;br/&gt;&lt;br/&gt; &lt;v-btn @click="toAbout2(2)"&gt;编程式导航跳转&lt;/v-btn&gt;&lt;br/&gt;&lt;br/&gt; &lt;/template&gt; &lt;script lang="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d2f5ee3788fd4596bec0d09211537d52/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc02e655a793a383b4185451d291b5d0/" rel="bookmark">
			HTML期末作业-仿英雄联盟官网首页模板(HTML&#43;CSS&#43;JavaScript)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 精仿英雄联盟官网整站源代码+项目文档 html+css+js
大二web作业 首页包含功能：
1，导航栏二级菜单：在首页上创建一个导航栏，并实现二级菜单的功能。当鼠标悬停在主菜单上时，显示相应的二级菜单选项，以提供更多导航选择。
2，图片放大效果：通过使用CSS样式和过渡效果，为首页中的图片添加一种放大的视觉效果。当鼠标悬停在图片上时，图片逐渐放大，增强用户的交互体验。
3，超链接变色后下划线：为页面上的超链接设置交互效果。当鼠标悬停在超链接上时，超链接文字会变色，让用户更易于识别链接内容。同时，超链接下方会显示下划线，以强调其可点击性。
4，滚动特效：通过JavaScript或CSS实现滚动时的特效效果，使页面在用户滚动时呈现出平滑的过渡效果，在滚动到特定位置时，元素会以动画的形式进入或淡入屏幕。
5，幻灯片轮播：创建一个具有自动播放和手动切换功能的幻灯片轮播图。这个功能可以展示多张图片或内容，为网页增加视觉吸引力。
6，视频播放器：在网站上嵌入视频播放器，支持播放在线视频或通过链接下载视频。
等多种功能.....
作品展示 英雄联盟网站视频
文件目录 获取源码 1，复制该网站 https://download.csdn.net/download/qq_42431718/87946510
2，点击上方下载 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2dd094fa6741ee627923bd5ebacf9c52/" rel="bookmark">
			对学习方法的一些思考
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		只看基金的招募书和合同的只言片语是没办法彻底的了解这只基金的策略的，必须有一个机会看看基金经理是怎么聊这个策略的！
基金这个壳子的【股票/债券】究竟应该如何配比才能达到理想且优秀的效果呢？
【债券配得多从长期（5年）来看，肯定是没有纯股票基金优秀一些！】
《从本质上来讲：债券就是（生命周期内的）到期后的还本付息，股票就是企业（企业的生命周期）的经营发展然后分红！》
【债券的安全边际肯定要高很多，因为企业具有内生成长性和内生消耗性还有外界的各种条件会导致企业的经营变故所以企业的研究也会复杂很多！】
有没有办法用一个指标来进行衡量股票的价格是否过高？
没时间只是表象。
实质可能是：
1.没把事情列优先级，大量低优先级事情侵占了时间
2.没列计划，想到什么做什么。表现为：一段时间很多事情做，一段时间不知道做什么。需要列出短期，中期，长期的目标和计划
3.用忙碌来来掩盖自己思想的懒惰，不愿去思考和总结经验。用句时髦的话就是：用战术的勤奋去掩盖自己战略的懒惰
如果单纯的读书能够解决所有的问题那读一吨书是不是就身价过亿了？
读书的核心目的还是冲击自己的思想体系，刷新认知！【认知分为：你不知道你不知道的！，你知道你不知道的！，你知道你知道的！，你不知道你知道的？】
《一定要多交流，刷新认知！》
《大家的时间精力都是有限的，所以一定要把这种有限性扩大！》
【学了又忘记了没有关系，每个人都是这样的，关键点在于透彻理解其本质含义，以吸收其中的浓缩精华！】
很多人因为离开学校后，工作任务多，压力大，从此就停止了系统地学习。
在学习层面：
国内: 小时候努力，到大学后就不努力了。 国外: 到大学后才开始努力，很快就超过国内学生。
现如今是个信息爆炸与知识过载时代，所以学习必须要有选择性。
学习还是要聚焦和主动选择，毕竟你的精力和时间都是有限的。
保持学习，不断成长，工作也许还在重复，但成长却在迭代上升，然后才会有机会面临更多可选择的路径。
计算机相关的基础性学科和知识：操作系统、数据库、网络、组成原理、编译原理、算法基础、数据结构等等。
成长这条路从来都不是笔直的，你的“奔跑速度”也不会一直是匀速的。在每一个拐弯处，都应减速，思考，学习，然后再加速，进步。
程序员的工作形式是编程产出代码，本质是完成需求，交付系统；但在工作中容易陷入不断完成的循环怪圈，
要打破它，就需要你持续学习并有意识地关注交付代码的品质和属性，一方面提升了交付质量，另一方面也获得了个人成长。
而学习的路在时间上是永远持续的，在空间上也是有路径的；有效的学习需要你关注学习曲线的变化，遵循有体系的技术学习框架，匹配适合当前阶段的学习资源。
总之不给他人找麻烦又能为他人提供价值，才能体现自己的价值。这些轻描淡写容易，实际做到并不容易。
一直保持学习，但是学完工作用不上很快就忘记。死循环～忘了也可能发挥作用，因为学习的过程可能已经改变了你的思维！【还是要优化一下学习方法！】
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad9d91d909146be1659bf81902d714a3/" rel="bookmark">
			R语言的版本更新以及迁移R包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		install.packages("installr")
library(installr)
updateR()#更新R的版本
2.迁移
其实这一部分也很简单，就是找到旧版本的R包，并将其复制粘贴到新版本的文件夹中即可
.libPaths()
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/217ae6aefaedbe7a1b1fafaf0ab4e079/" rel="bookmark">
			Pycharm汉化教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于pycharm软件的汉化教程大致可以分为两种
方法一、Pycharm中直接设置 在设置里安装相对应的插件(对于JetBrains公司出品的软件都可以使用此方法)
1）打开pycharm，在选中左上角的File-&gt;Setting 打开设置
2）选择Plugins（插件）的选项
3）在marketplace的搜索框里搜索chinese，一般输入之后，带有Language的插件就是咱们的汉化插件了
点击后面的install进行安装
4）初次安装时，会提示跳出一个提示，选择accept接受
5）安装完成后Install会变成Restart IDE，点击这个按钮重启pycharm
6）跳出提示确认重启pycharm并且应用插件，选择Restart确认重启
7）自动重启之后pycharm就变成了汉化版
（如果操作完以上步骤还没有汉化）： 则再回到左上角File -&gt; Settings设置的Plugins里面，选择Installed，查看已安装的插件
会发现我们刚才下载的汉化插件是灰色的并且没有被勾选，咱们勾选这个插件，然后点击Apply进行应用
点击Apply之后点OK，会跳出确认重启的提示，点击Restart重启
重启之后，就变成了汉化版的pycharm
方法二、自行下载汉化插件，在pycharm里配置 对于太低版本的pycharm，或者电脑系统太低的原因，插件里没有汉化的插件，则需要自己在pycharm的官网里手动下载汉化插件,再在pycharm中添加自己下载好的插件
1）找到pycharm中的汉化下载的地方，并且打开
快捷链接：Versions: Chinese (Simplified) Language Pack / 中文语言包 - IntelliJ IDEs Plugin | Marketplace (jetbrains.com)
2）根据自己下载的pycharm版本，找到对应的版本汉化包，点击右边的download进行下载，如果版本很低，可以点击Show More显示更多，直到找到自己那个版本的汉化包
一般对于灰色的汉化包插件都是各个pycharm版本中的过渡版本，而正常显色的都是每个pycharm版本中的最后版本，所以咱们找到相应版本的最终版本进行下载，这里找到的是2020.2-2020.2.4使用的最终版本，点击后面的download进行下载
点击下载之后不用理会弹出的内容，一般点击下载后就已经开始下载了
3）此时需要知道下载的汉化插件存放的位置(文件路径) ，然后回到pycharm界面里打开左上角的File-&gt;Settings设置界面，然后选择Plugins插件的界面，点击偏右上角的一个齿轮，选择里面的Install Plugin from Disk
4）在跳出来的窗口里，根据你下载汉化包的文件位置路径，进行一个选择，直至选到这个插件后点击OK
5）选择之后，汉化包会成功读取到，点击Restart IDE，以重启pycharm进行配置
6）然后会弹出一个确认重启的窗口，点击Restart确认重启
自动重启后，软件就被汉化成功啦
extra、取消汉化变为英文的方式 对于下载配置好后，想要取消汉化变回英文状态下的操作步骤
1）打开pycharm，在选中左上角的文件-&gt;设置
2）选择Plugins（插件）的选项，选择Installed（已安装的插件）
取消汉化的勾，点击右下角应用，然后点击确定
3）点击确定后会出现确认重启的窗口，然后点击Restart确认重启
pycharm重启之后，则就变回英文的状态了
（本内容为教学python小白汉化pychram软件的一个过程，如有误可以指出，必会及时修改）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84783c315ec1785f6ba0930494ee38bc/" rel="bookmark">
			牛客社区项目续
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		统一日志记录 我们的这个项目在很多地方都需要记录日志，比如帖子模块、评论模块、消息模块等，而以前我们记录日志都是在某一个功能点中使用日志工厂，像下面这样：
项目中很多地方都需要记录日志，像这样一个地方一个地方的记录将会很麻烦，而我们只需要将这个记录日志的功能抽离出来，利用AOP的思想去实现即可。关于AOP可以看我的另一篇博客：Spring AOP_aop切面由哪些构成_咸鱼吐泡泡的博客-CSDN博客
@Component @Aspect public class ServiceLogAspect { private static final Logger logger = LoggerFactory.getLogger(ServiceLogAspect.class); @Pointcut("execution(* com.nowcoder.community.service.*.*(..))") public void pointcut(){ } @Before("pointcut()") public void before(JoinPoint joinPoint){ // 用户[1.2.3.4],在[xxx],访问了[com.nowcoder.community.service.xxx()]. ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes(); HttpServletRequest request = attributes.getRequest(); String ip = request.getRemoteHost(); String now = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(new Date()); String target = joinPoint.getSignature().getDeclaringTypeName() + "." + joinPoint.getSignature().getName(); logger.info(String.format("用户[%s],在[%s],访问了[%s].",ip,now,target)); } } 当我访问该项目的主页面的时候：
查看用户帖子列表、查看点赞和回帖等功能会被访问，像下面这样：
Redis 关于Redis的详细介绍请看我的这篇博客：
(1条消息) Redis的常见操作和Session的持久化_redis删除session_咸鱼吐泡泡的博客-CSDN博客
windows系统下载Redis地址：
GitHub - microsoftarchive/redis: Redis is an in-memory database that persists on disk.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/84783c315ec1785f6ba0930494ee38bc/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/119/">«</a>
	<span class="pagination__item pagination__item--current">120/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/121/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>