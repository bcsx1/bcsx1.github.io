<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3297e7a4f0e7cf0c18971364844c7bb/" rel="bookmark">
			【error】svn 清理以下路径失败 原始内容不存在
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 目前我们这边的内网代码是通过 TortoiseSVN 进行版本管理的，平时用着也挺好的，没碰到什么大问题。
但是，今天碰到了一个比较棘手的问题，在这里做一下记录，以方便自己和有需要的朋友在之后碰到该类问题时有个参考。
现象 具体的错误现象如下图所示：
原因 导致上述现象的步骤如下：
从最外层目录点击的更新，由于文件数量巨多，导致长时间处于检查状态；点击了取消更新按钮；取消响应太慢，直接从任务管理器关闭 TortoiseSVN 进程；
经过以上步骤后，再次更新就出现了该现象，不管从哪一级目录更新都是一样的错误。 解决方案 通过查找资料，发现碰到这种现象的人还是蛮多的，但是，现在网上找出来的资料中，绝大部分都是建议使用 sqlite3 进行数据库清理，数据库位于时选择的那个本地目录下的 .svn 文件夹中，名称为 wc.db
注意：.svn 文件夹一般是隐藏文件夹，需要设置显示。
通过一个sqlite可视化工具见wc.db文件打开，找到 WORK_QUEUE 表；
右键该表，选择“清空”，然后保存 wc.db。
用上面修改过的 wc.db 替换 .svn 下的 同名文件，然后再次执行清理指令，即可解决问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/384eb0e7dbc5ee6082e92685bf0568a9/" rel="bookmark">
			Java 中 Long 类型数据相除，结果保留两位小数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 调用 Long 类型的 doubleValue() 方法，以及 String.format() 方法即可
public class LongFormatPercent { public static void main(String[] args) { Long a = 5L; Long b = 15L; String percentFormat = String.format("%.2f", ((a.doubleValue() / b.doubleValue()) * 100)) + "%"; System.out.println(percentFormat); } } 运行结果如下：
33.33% 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e998d8ac7343ffe223ba3237cc3bb7f6/" rel="bookmark">
			【计算机网络】第 3 课 - 计算机网络体系结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		欢迎来到博主 Apeiron 的博客，祝您旅程愉快 ！ 时止则止，时行则行。动静不失其时，其道光明。
目录
1、常见的计算机网络体系结构
2、计算机网络体系结构分层的必要性
2.1、物理层
2.2、数据链路层
2.3、网路层
2.4、运输层
2.5、应用层
3、计算机网络体系结构中的专业术语
4、总结 1、常见的计算机网络体系结构 为了使不同体系结构的计算机网络都能互连，国际标准化组织于 1977 年成立了专门机构研究该问题。不久，他们就提出了一个试图使各种计算机在世界范围内互连成网的标准框架，也就是著名的 “开放系统互连参考模型”，简称为 OSI（Open Systems Interconnection）。
到了 20 世纪 90 年代初期，虽然整套的 OSI 国际标准都已经制订出来了，但这时因特网已抢先在全世界覆盖了相当大的范围。因特网从 1983 年开始使用 TCP/IP 协议族，并逐步演变成 TCP/IP 参考模型。
在过去制订标准的组织中往往以专家、学者为主。但现在，许多公司都纷纷挤进各种各样的标准化组织，使得技术标准有着浓厚的商业气息。一个新标准的出现，有时不一定反映出其技术水平是最先进的，而是往往有着一定的市场背景。从这种意义上说，能够占领市场的就是标准。
OSI 标准失败的原因可归纳为：
① OSI 的专家们缺乏实际经验，它们在完成 OSI 标准时没有商业驱动力
② OSI 的协议实现起来过分复杂，而且运行效率很低
③ OSI 标准的制订周期太长，因而使得按 OSI 标准生产的设备无法及时进入市场 ④ OSI 的层次划分也不太合理，有些功能在多个层次中重复出现
TCP/IP 体系结构的网络接口层并没有规定什么具体的内容，这样做的目的是 可以互连全世界各种不同的网络接口，例如有线的以太网接口，无线局域网的 WIFI 接口，而不限定使用一种或几种网络接口。因此，本质上 TCP/IP 体系结构只有上面的三层。
IP 协议是 TCP/IP 体系结构网际层的核心协议。TCP 和 UDP 是 TCP/IP 体系结构运输层的两个重要协议。 TCP/IP 体系结构的应用层包含了大量的应用层协议，例如 HTTP，SMTP，DNS，RTP 等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e998d8ac7343ffe223ba3237cc3bb7f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed9122607e94886a3d9ea1e627933af4/" rel="bookmark">
			2023年JRebel最新激活方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		亲测使用方法2激活成功。 JRebel介绍# JRebel是一款JVM插件，它使得Java代码修改后不用重启系统，立即生效。IDEA上原生是不支持热部署的，一般更新了 Java 文件后要手动重启 Tomcat 服务器，修改才能生效；所以推荐使用 JRebel 插件进行热部署。
JRebel安装方式# 1.插件仓库安装（推荐）# 1、打开IDEA，选择File—&gt;Settings—&gt;Plugins—&gt;在右侧选择Marketplace，
2、在搜索框输入jrebel—&gt;选择搜索结果—&gt;点击Install（安装），如下图。
2.下载zip文件包进行安装# 下载地址：官网下载
按照以下操作步骤进行安装：
1、下载插件。
2、下载后，打开IDEA，选择File—&gt;Settings—&gt;Plugins—&gt;设置按钮—&gt;Installed Plugin from Disk（从文件夹选择已下载的插件安装）。
安装完成后根据提示重新启动IDEA.
JRebel激活# 安装之后需要重启IDEA，JRebel插件会提示需要激活，点击Jrebel Activation进行激活。
激活方式有两种：# 1、注册地址填写激活网址 + 生成的GUID（不支持最新4.2版本） 激活版本 &lt; jrebel版本 2022.4.2
2、本地地址 + 生成的GUID 支持 jrebel版本 2022.4.2
方法1： 1. 安装JRebel插件后，注册地址填写激活网址 + 生成的GUID，邮箱随便填写，然后直接激活即可
激活网址列表，尽量用排序靠前的
http://jrebel-license.jiweichengzhu.com/{GUID}
https://jrebel.qekang.com/{GUID}
GUID可以使用在线GUID地址在线生成，然后替换{GUID}就行。
2.下面邮箱地址可随便输入。
3.选择我同意
4.提交
出现下方提示则激活成功，如果没有出现下面提示，请确定自己的网络通畅，然后再次点击激活，如果还不行：
1、检查插件版本
2、更换uuid重新尝试
3、使用激活方法2 重新尝试。
方法2： 方法2与方法1类似，只不过最新版的2022.4.2 这个版本的jrebel应该是更改了激活方式 qekang方式激活不成功。
1.前置步骤均一致，在填入Team URL时，填入以下内容
http://127.0.0.1:8888/{GUID}
GUID可以使用在线GUID地址在线生成，然后替换{GUID}就行。
2.下面邮箱地址可随便输入。
3.选择我同意
4.提交
如果报Unable to connect to license server.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed9122607e94886a3d9ea1e627933af4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd94c8bbf3077e73f4d557cec7c7889a/" rel="bookmark">
			quartus工具篇——PLL IP核的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		quartus工具篇——PLL IP核的使用 1、PLL简介 PLL(Phase-Locked Loop,相位锁环)是FPGA中非常重要的时钟管理单元,其主要功能包括:
频率合成 - PLL可以生成比输入时钟频率高的时钟信号。频率分频 - PLL也可以输出分频后的较低频率时钟。减小时钟抖动 - PLL可以过滤输入时钟中的噪声和抖动。锁相输出 - PLL可以使多个时钟保持一定的相位关系。时钟复用 - 一个PLL可以驱动多个时钟域。 PLL的工作原理是通过控制环路内VCO的相位和频率实现以上功能。
在FPGA中,PLL广泛用于:
生成界面、存储等需要的各种工作时钟将外部时钟处理后提供低抖动时钟实现模块间的时钟域同步 PLL提供时钟的稳定性和灵活性,是FPGA设计中必不可少的时钟管理机制
2、具体实现配置 选中点击打开后会出现以下配置界面，配置自己芯片的时钟频率，我这里配置的是50MHZ
取消勾选掉多余的信号
按照下列步骤配置输出的时钟频率，我这里配置了三个时钟clk c0、clk c1、clk c2，分别是10MHZ、20MHZ、300MHZ
生成文件，勾选生成对应的文件、我这里多勾选了bsf文件，是这个PLL ip核的波形文件、PLL_inst.v是实例化的部分，其他的文件这里不做过多的叙述
点击finish生成，这里生成了PLL的实现文件，我们可以将之前勾选的文件添加进项目中
生成的文件位置会在你创建项目的目录下，我们将PLL_inst初始化文件添加进来：
PLL_inst.v文件内容，会存放实例化模块，方便我们进行调用和仿真，我们只需要将我们的信号与PLL信号进行联通就行，如下列所示，c0将生成10MHZ的时钟、c1将生成20MHZ的时钟、c2将生成300MHZ的时钟
PLL	PLL_inst ( .inclk0 ( inclk0_sig ), .c0 ( c0_sig ), .c1 ( c1_sig ), .c2 ( c2_sig ) ); 3、使用配置的PLL进行仿真 仿真代码：
// Copyright (C) 2018 Intel Corporation. All rights reserved. // Your use of Intel Corporation's design tools, logic functions // and other software and tools, and its AMPP partner logic // functions, and any output files from any of the foregoing // (including device programming or simulation files), and any // associated documentation or information are expressly subject // to the terms and conditions of the Intel Program License // Subscription Agreement, the Intel Quartus Prime License Agreement, // the Intel FPGA IP License Agreement, or other applicable license // agreement, including, without limitation, that your use is for // the sole purpose of programming logic devices manufactured by // Intel and sold by Intel or its authorized distributors.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd94c8bbf3077e73f4d557cec7c7889a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a12e5804437b9fbfa1fab4c66316030/" rel="bookmark">
			小程序进入webView进行微信公众号授权获取用户openId，用来判断用户是否关注与当前小程序关联的公众号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、至少需要两个页面，一个是授权入口页面（这里我以index首页为例），一个是webView页面 2、在index中跳转到webView页面 3、webView中的内容很简单，就是一个&lt;web-view&gt; &lt;/web-view&gt; 组件，里面的src就是要前往授权的路径，https://open.weixin.qq.com/connect/oauth2/authorize?appid=wx520c15f417810387&amp;redirect_uri=https%3A%2F%2Fchong.qq.com%2Fphp%2Findex.php%3Fd%3D%26c%3DwxAdapter%26m%3DmobileDeal%26showwxpaytitle%3D1%26vb2ctag%3D4_2030_5_1194_60&amp;response_type=code&amp;scope=snsapi_base&amp;state=123#wechat_redirect 文档：网页授权 | 微信开放文档
4、参数介绍： 4.1 appid：为公众号的appid，前期可以去申请测试公众号，地址：微信公众平台
4.2 redirect_uri：由后端提供，在这里面进行授权
4.3 response_type：授权获取到的code值，这里默认为code，后端会根据这个code来获取openId
4.4 scope：有两种类型，snsapi_base和snsapi_userinfo，前者不需要用户确认，后者需要，后者获取到的用户信息更加丰富，具体看网页授权 | 微信开放文档
4.5 state：为一个h5页面的地址，后端会将获取到的openId参数携带地址最后，授权后调用相关API自动返回或手动返回到小程序
5、第四点中的state参数中h5页面内的内容 6、整体流程 1、进入index首页
2、自动或手动进入到webView页面 3、webView中的src自动跳转进行授权
4、进入h5页面
5、返回到小程序
7、注意点：1、需要在测试公众号内手动去配置第4步中redirect_uri参数的域名，2、h5页面需要部署到服务器 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5045e05568ef44db005ceeeca3212322/" rel="bookmark">
			Python手动下载第三方库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第三方库网址（https://www.lfd.uci.edu/~gohlke/pythonlibs/）(https://pypi.org/)搜索自己想要下载的库下载自己电脑、版本所对应的whl文件（有时whl文件要与python相对应，例如python3.9，对应下载的文件名字里有cp39）将下载的whl文件保存到Python目录下的Scripts文件夹里。通常你会希望将它放在项目的一个特定目录下，以便在项目中使用它。通常建议将whl文件放在项目根目录下的一个特定文件夹，比如"libs"、"packages"或者"third-party"等目录。在所在文件夹里打开cmd输入pip install 下载的文件名.whl成功下载到自己本地的python库里 pip命令实际的下载源头是 https://pypi.org/ 里面的包
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27fe4c31e79c26f5df1bafa957f3b5d6/" rel="bookmark">
			vivado 生成网表文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. 把需要生成网表文件的模块设置位顶层
2. Tools -&gt; setting -&gt; synthesis
3. 进行综合
4. 综合完成后打开综合完成的设计
5. 进入 Tcl Console 界面
1. 生成引脚描述文件.v
2. 生成网表文件.edf
1. 把需要生成网表文件的模块设置位顶层 2. Tools -&gt; setting -&gt; synthesis 在 more options* 中填入：-mode out_of_context
3. 进行综合 4. 综合完成后打开综合完成的设计 5. 进入 Tcl Console 界面 依次输入以下命令：
1. 生成引脚描述文件.v write_verilog -mode synth_stub &lt;目录&gt;文件名.v
例如：write_verilog -mode synth_stub D:/CHENFANG/ldpc23/Net_List/LDPC_encoder.v
2. 生成网表文件.edf write_edif -security_mode all &lt;目录&gt;文件名.edf
例如：write_edif -security_mode all D:/CHENFANG/ldpc23/Net_List/LDPC_encoder.edf
以上是模块包含IP核的情况，其他情况如果输入错误，会有提示。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3516d4abf97cc339fbbf4e11d08f103f/" rel="bookmark">
			一看就懂的 CUDA安装教程及Pytorch GPU版本安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.先查看电脑的GPU支持的CUDA版本
（1）下载CUDA （2）安装CUDA
（3）查看CUDA是否安装成功 2. 下载cuDNN，配置 （1）首先注册的NVIDIA账户 （2）安装配置 （3）验证是否安装成功 3.Pytorch GPU版本安装 （1）方法1使用命令直接安装
(2) 方法2：到官网下载文件到本地再安装
总共需要安装两个文件：CUDA和cuDNN
1.先查看电脑的GPU支持的CUDA版本 在cmd中输入命令nvidia-smi, 可以看到CUDA最高支持12.0版本 ，可以安装12.0以下的版本
（1）下载CUDA CUDA各版本选择链接如下：我安装的是11.6.0版本
CUDA Toolkit Archive | NVIDIA Developer
（2）安装CUDA 双击安装，这个是安装临时路径，不改变，直接确定
如果出现下面安装失败的界面，把电脑杀毒软件关闭，我的电脑是 关闭360 就可以安装成功了。
选择自定义安装
不要勾选Visual Studio
记录下面三个安装目录，如果后续环境变量没有自动添加，则需要手动添加下面三个路径到环境变量中。 安装完毕
查看环境变量是否添加进去，右键我的电脑-&gt;属性-&gt;高级系统设置-高级 可以看到，已经添加成功 （3）查看CUDA是否安装成功 查看CUDA是否安装成功，执行下面的第一个命令，第二个命令查看环境变量配置
2. 下载cuDNN，配置 （1）首先注册的NVIDIA账户 链接如下：需要先注册NVIDIA账户，然后就可以下载了 https://developer.nvidia.com/rdp/cudnn-download
注册成功后跳转到如下的下载界面，选择版本
选择window （2）安装配置 下载后解压，将这三个文件夹复制到CUDA的安装目录中 下图是复制成功的界面，默认安装路径也显示如下 添加下面的四个路径到环境变量中 （3）验证是否安装成功 验证是否安装成功 ，在命令行中进入下面的目录，分别执行图中的exe文件，使用命令.\xxxx.exe执行。
看到下面中的PASS ，代表安装成功了
至此CUDA安装结束。
3.Pytorch GPU版本安装 （1）方法1使用命令直接安装 Previous PyTorch Versions | PyTorch torch和torchvision版本要和CUDA版本对应 # ROCM 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3516d4abf97cc339fbbf4e11d08f103f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bfa17bee71a630ca12eb480467bfb150/" rel="bookmark">
			Python 办公自动化｜从 Excel 到 Word
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 我们讲解了如何从 Word 表格中提取指定数据并按照格式保存到 Excel 中，今天我们将再次以一位读者提出的真实需求来讲解如何 使用 Python 从 Excel 中计算、整理数据并写入 Word 中，其实并不难，主要就是以下两步：
openpyxl 读取 Excel 获取内容docx 读写 Word 文件 那我们开始吧！
需求确认 首先来看下我们需要处理的 Excel 部分数据，因涉及隐私已经将数据 皮卡丘化
可以看到数据非常多，并且还存在重复数据。而我们要做的就是对每一列的数据按照一定的规则进行计算、整理并使用 Python 自动填入到 Word 中，大致的要求如下
上面仅是部分要求，真实需要填入 word 中的数据要更多！
除了对按照格式进行处理并存入 Word 中指定位置之外，还有一个需求：最终输出的 word 文件名还需要按照一定规则生成：
OK，需求分析完毕，接下来看 Python 如何解决！
Python 实现 首先我们使用 Python 对该 Excel 进行解析
from openpyxl import load_workbook import os # 获取桌面的路径 def GetDesktopPath(): return os.path.join(os.path.expanduser("~"), 'Desktop') path = GetDesktopPath() + '/资料/' # 形成文件夹的路径便后续重复使用 workbook = load_workbook(filename=path + '数据.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bfa17bee71a630ca12eb480467bfb150/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab689c2fbc4eede15056840ebfe2e04e/" rel="bookmark">
			RecyclerView 一次性加载大量数据时（2000条音频数据），导致UI线程卡顿，频繁GC的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述： 公司项目有这么一个需求，扫描sdCard或U盘的音频数据，并分类展示出来，当数据量比较大时（2000多条数据以上），显示列表慢和滑动列表会很卡。
问题的寻找过程： 当时想的就是因为数据过多导致页面绘制的时候卡主线程了。
因为我是通过RecyclerView展示数据的，接着就想到一次性加载2000多条数据会卡顿，那我就分批加载，我将2000多条数据按每100条一批，显示到RecyclerView中，然后发现问题依然存在。被这个问题困住了，试了各种分页加载，依然得不到解决。
后来排查在adapter的onCreateViewHolder() 和 onBindViewHolder()中打了个计数的Log，发现2000多条数据，每条数据加载的时候都会调用onCreateViewHolder()和onBindViewHolder()。这就有问题了，根据官方API的说明，RecyclerView只会 create当前显示的Item，其他的未显示的都是通过ViewHolder的复用来显示的，我想我已经发现问题所在了。
然后我就想是不是我adapter写的有问题呢 ，经过和其他页面RecyclerView 的adapter的对比，却发现并没有什么不同，这让我又开始苦恼起来。
经过和其他页面的一步步的对比，最终发现原来是activity中的布局文件中，RecyclerView 的父布局使用了android:layout_weight百分比例属性设置宽度，导致RecyclerView 的每一条数据都会创建一个Item，在数据量小的时候发现不了，等数据量达到一定程度的时候就会导致由于创建的View过多，程序运行过程中产生了大量的垃圾数据，所以才会导致进程不断的发生GC，因而影响了UI主线程。
出现问题的布局文件： &lt;LinearLayout
android:layout_width="0dp"
android:layout_height="match_parent"
android:layout_weight="1"&gt;
&lt;RecyclerView
android:layout_width="match_parent" android:layout_height="match_parent" /&gt;
&lt;/LinearLayout&gt;
解决办法： 1、子布局和父布局的宽度和高度不使用layout_weight设置百分比相对宽高，因此去掉此属性后，问题就解决了。
2、经过百度发现
//设置 这个可以避免以上问题 但也意味着失去了本身设计用来提供支持WRAP_CONTENT的功能了mRecyclerView.getLayoutManager().setAutoMeasureEnabled(false);
貌似也能解决，不过我还没有试过。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30ad79bb1fe5afd007c4edf8ee99f4ef/" rel="bookmark">
			oh-my-zsh详细安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以下以root用户安装
1、yum install zsh 2、sh -c "$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)"
3、下载插件
git clone https://gitee.com/phpxxo/zsh-autosuggestions.git (zsh-autosuggestions) 历史命名补全
拷到/root/.oh-my-zsh/plugins/
git clone https://github.com/zsh-users/zsh-syntax-highlighting.git
拷到/root/.oh-my-zsh/plugins/
4、修改 ~/.zshrc
plugins=(git zsh-autosuggestions zsh-syntax-highlighting)
ZSH_THEME="random" （随机样式）
5、生效 source ~/.zshrc
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c6d696b7f15a3d0955acde7947976d4/" rel="bookmark">
			安装教程cuda，cuDNN，pytorch，详细全面版，亲测可用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里写自定义目录标题 一、[查看自己电脑又没有装cuda，以及可以装cuda什么版本（每个电脑有个可以安装的最高版本，可以安装最高版本及以下的所有版本）]二、[安装cuda]在ubantu安装可以参考下面连接 三、[卸载并重装cuda]四、[接着三，安装pytorch] 最新，最新，2023.7.22，现在方便多了，直接安装完cuda，然后进入pytorch：[链接](https://pytorch.org/)，直接一键安装。 2023.7.24，如何在anaconda的虚拟环境中，安装cuda及其系列，直接在prompt中，激活你想安装的虚拟环境，然后执行 conda install pytorch torchvision torchaudio cudatoolkit=11.7 注意：建议在下之前，先将本文看一遍再安装，不然可能做许多重复工作，参考的链接为每个标题的超链接
还有在建虚拟环境时，python版本也要考虑后续的需求，过高的版本可能会导致后面有些库没有对应版本
一、[查看自己电脑又没有装cuda，以及可以装cuda什么版本（每个电脑有个可以安装的最高版本，可以安装最高版本及以下的所有版本）] 参考链接
注意：如果没有安装成功，nvcc -V 会报错，但是本人也遇到过开始报错，重启电脑后就正常了
二、[安装cuda] 参考链接
注意：如果需要安装cuDNN的话，需要提前看看，你想下的cuda有没有对应版本的cuDNN，没有就需要就需要降低cuda版本
如果你需要安装pytorch，应该注意cuDNN的版本问题，因为在离线下载pytorch时，会考虑到，具体参考四、
在ubantu安装可以参考下面连接 参考链接
其中在对~/.bashrc-Linux环境变量配置编辑操作时可参考参考链接
三、[卸载并重装cuda] 参考链接
有时候会遇到装错cuda版本，cuda是需要卸载在重新安装，按照链接卸载后，按照二，正常安装即可
四、[接着三，安装pytorch] 参考链接
注意：如果需要安装cuDNN的话，需要提前看看，你想下的cuda有没有对应版本的cuDNN，没有就需要就需要降低cuda版本
如果网络不好，一直不成功建议离线下载
参考链接
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd2520e8e720b237fca96313a5edfdbd/" rel="bookmark">
			JS获取各种屏幕的宽度和高度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 JS获取各种屏幕的宽度和高度 描述用法网页可见区域宽document.body.clientWidth网页可见区域高document.body.clientHeight网页可见区域宽document.body.offsetWidth (包括边线的宽)网页可见区域高document.body.offsetHeight (包括边线的高)网页正文全文宽document.body.scrollWidth网页正文全文高document.body.scrollHeight网页被卷去的高document.body.scrollTop网页被卷去的左document.body.scrollLeft网页正文部分上window.screenTop网页正文部分左window.screenLeft屏幕分辨率的高window.screen.height屏幕分辨率的宽window.screen.width屏幕可用工作区高度window.screen.availHeight屏幕可用工作区宽度window.screen.availWidth client与offset为只读属性，scroll为可读写属性 属性说明clientWidth获取元素可视部分的宽度，即 CSS 的 width 和 padding 属性值之和，元素边框和滚动条不包括在内，也不包含任何可能的滚动区域clientHeight获取元素可视部分的高度，即 CSS 的 height 和 padding 属性值之和，元素边框和滚动条不包括在内，也不包含任何可能的滚动区域offsetWidth元素在页面中占据的宽度总和，包括 width、padding、border 以及滚动条的宽度offsetHeight元素在页面中占据的高度总和，包括 height、padding、border 以及滚动条的宽度scrollWidth当元素设置了 overflow:visible 样式属性时，元素的总宽度，也称滚动宽度。在默认状态下，如果该属性值大于 clientWidth 属性值，则元素会显示滚动条，以便能够翻阅被隐藏的区域scrollHeight当元素设置了 overflow:visible 样式属性时，元素的总高度，也称滚动高度。在默认状态下，如果该属性值大于 clientWidth 属性值，则元素会显示滚动条，以便能够翻阅被隐藏的区域 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25d189cde64ebe8225309597571b4b6d/" rel="bookmark">
			gitignore的匹配规则（全）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		.gitignore文件可能我们一般不会太在意，或者去编辑他。但是其实其中有很多规则。
一.直接写一个文件名，也就是一串英文。如下：dist 所有名叫dist的文件和文件夹都会被匹配，无论被埋的多深。
二.带斜杠，有3个位置，前/中/后 斜杠表示，从当前.gitignore文件所在位置出发。
1.前的时候： 也就是同级目录下的dist，当然也可能是文件夹和文件。
把.gitignore移到b文件下，效果如下。
2.中间的时候 也就是找到a目录下的dist文件或者文件夹了。
3.末尾的时候 表示只匹配名为dist 的文件夹。其中a下面的dist文件夹被排除了，但是b下面的dist文件没有。
三。功能符号的使用 1.星号* *表示除斜杠外的所有，其中1.jpg和2.jpg全被被排除了。
那什么叫排除斜杠呢，如下例子。
其中a文件夹下面的1.jpg没有被排除。原因是：
因为*不匹配斜杠
而1.jpg的完整路径是：a/dist/1.jpg 而上面写的是a/*.jpg，其中的斜杠匹配不了。
2.两个星号：** 那如果要匹配a目录下所有的jpg，不管埋的多深。这里需要两个星号：**，
如上，表示a目录下无论多少层级都可以匹配了。
3.问号：？ 问号：？表示一个字符。其中，名叫1.jpg的文件被忽略，但是11.jpg就不会
反言之，两个问号表示两个字符
4.正则表示 [0-9]在这里表示一个字符，取值为0-9，因此11.jpg就不行，a.jpg也不行。
5.感叹号：！ 这里我全匹配了a下面的所有带有后缀的文件，但是！表示除了。那所以1.txt在前面的规则基础上不被排除了。
这样做的还是很有实际意义的。
因为如果这个a目录是一个静态资源，不用感叹号去排除其中的一个文件，那整个目录都不会被跟踪，在服务器上，就没有a这个目录，有可能报错。
那如果我们需要这个目录，但是不要其中的图片等资源文件。
6.补充 .keepgit 一般做法是：
在a目录下，创建一个.keepgit文件，然后在.gitignore中写。这样就保证服务器中不至于没有a目录。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f761a516848d30445d4389f056138eb5/" rel="bookmark">
			centos8安装mysql8
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文主要介绍如何在Centos8下安装Mysql。
一、下载Mysql 使用wget命令下载mysql安装包。确保系统已经安装了wget，如果没有安装，执行 yum install wget 安装。
wget https://repo.mysql.com/mysql80-community-release-el6-1.noarch.rpm 二、安装、启动Mysql服务 1.安装mysql（rpm可以看成一个压缩包，先安装rpm，安装路径：/etc/yum.repos.d/） rpm -ivh mysql80-community-release-el6-1.noarch.rpm 2.安装mysql服务（重点） yum -y install mysql-server 如果安装过程中出现GPG验证不通过的错误（不是必现问题，无意间发现，从网上找到了解决方案，查看解决方案地址），可以通过尝试执行以下命令：(要安装对应的gpg)
rpm --import https://repo.mysql.com/RPM-GPG-KEY-mysql-2022 3.安装完成后启动mysql服务： systemctl start mysqld 备注：
mysql配置文件存放目录：/etc/my.cnf
mysql安装目录：/var/lib/mysql
至此，mysql安装完成了！
三、Mysql连接设置 1. 如果安装的是mysql8 初始密码为空。如果安装的是MySQL5.7会有一个默认密码，密码路径：/var/log/mysqld.log。我们可以通过grep命令查看默认密码，并登录mysql进行密码修改。 grep 'temporary password' /var/log/mysqld.log 2.使用临时密码登录MySQL： mysql -uroot -p .+Vsf3Rpl7u) 3.可以将mysql密码安全校验强度改为低风险（如果是mysql8不需要设置直接修改密码） set global validate_password_policy=LOW; 4.修改mysql密码为：123456789 ALTER USER 'root'@'localhost' IDENTIFIED BY '123456789'; 5.设置mysql可以远程访问 首先将3306添加到防火墙，添加端口后需要重启防火墙才能生效
# 开启防火墙 systemctl start firewalld # 查看防火墙 firewall-cmd --list-all #添加端口到防火墙 firewall-cmd --zone=public --add-port=3306/tcp --permanent #重新加载防火墙 firewall-cmd --reload 6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f761a516848d30445d4389f056138eb5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53ae00d57dee970ecd0e11316696b2d3/" rel="bookmark">
			VUE pc端-移动端-ipad端适配（原理转化为VW布局）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		设备宽度=100vw
1vw = 750px/100px = 7.5px
100px = 1/7.5*100vw 1.引入 postcss-px-to-viewport 插件（将class转换为vw） npm install postcss-loader postcss-px-to-viewport --save-dev 2.在根目录下新建 .postcssrc.js 文件，引入下面代码 module.exports = { "plugins": { "postcss-px-to-viewport": { //把px单位转换为vw、vh、vmin或者vmax这样的视窗单位，也是vw适配方案的核心插件之一。 viewportWidth: 375, //视窗的宽度 viewportHeight: 1600, //视窗的高度 unitPrecision: 3, //将px转化为视窗单位值的小数位数 viewportUnit: 'vw', //指定要转换成的视窗单位值 selectorBlackList: ['.ignore', '.hairlines', '.vant'], //指定不转换视窗单位值得类，可以自定义，可以无限添加 minPixelValue: 1, //小于等于1px不转换为视窗单位 mediaQuery: false, //允许在媒体查询中使用px }, } } 3.引入 style-vw-loader 插件（将行内样式转换为vw） npm install style-vw-loader --save-dev 4.在根目录下新建 vue.config.js 文件，引入下面代码 module.exports = { publicPath: "./", chainWebpack: (config) =&gt; { config.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/53ae00d57dee970ecd0e11316696b2d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/153203fe93a7b02f24a04fb441836da2/" rel="bookmark">
			链表经典问题之回文链表（c&#43;&#43;、Java）力扣leetcode234
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		判断一个链表是否为回文链表。
方法一：快慢指针（无栈） 思路：
如果链表节点为偶数个，快指针指向null，慢指针在中间位置，后半段直接反转；
如果链表节点为奇数个，快指针指向最后一个节点，慢指针在中间位置，然后+1，后半段反转；
之后快指针移动到第一个节点，在逐个移动快慢指针，进行比较。
我盲写报错一堆，改了好久bug
以下是cpp的代码实现：（Java只需在此基础上改动一下语法就好，注释有写）
//redefinition of 'slow' 重复定义 ListNode* newslow=reserve(slow);才行 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: bool isPalindrome(ListNode* head) { ListNode *fast=head,*slow=head;//Java中把*去掉 while(fast!=nullptr&amp;&amp;fast-&gt;next!=nullptr)//Java中-&gt;改为. { fast=fast-&gt;next-&gt;next; slow=slow-&gt;next; } if(fast!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/153203fe93a7b02f24a04fb441836da2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e8cb50c6d5bee9dc82f5d5f4e1afd3b/" rel="bookmark">
			C语言程序设计之猜数字游戏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		//猜数字游戏
//电脑产生一个随机数（1-100）
//猜数字，根据输入的数字 输出“猜大了”/“猜小了” 直到猜对了结束
首先我们先设计前半部分，防止我们猜数一次之后就游戏结束退出了，我们来设置一个循环入口，进入以后我们需要先做选择，这样定义一个函数menu（）作为菜单，这样一进去就要进行选择，所以我们使用do…while进行循环，
#include&lt;stdio.h&gt; void menu() { printf("********************\n"); printf("********1.play*******\n"); printf("********0.exit*******\n"); printf("********************\n"); } int main() { int input = 0; do { menu(); printf("请选择：&gt;"); scanf("%d", &amp;input); switch (input) { case 1: printf("猜数字游戏\n"); break; case 0: printf("退出游戏！"); break; default: printf("选择错误，请重新选择！\n"); break; } } while (input); { } return 0; } 实现的初步效果如图：
当选择1.play时，便需要开始游戏，这样我们再来设计一个game（）函数，然后在case1对应位置添加game（）函数，首先我们先设置生成随机数，代码如下：
#include&lt;stdio.h&gt; void menu() { printf("********************\n"); printf("********1.play*******\n"); printf("********0.exit*******\n"); printf("********************\n"); } game() { //生成随机数： rand()函数用于生成一个0~RAND_MAX(最大值32767）的随机数 int ret = rand(); printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e8cb50c6d5bee9dc82f5d5f4e1afd3b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5aebb1c936e9ccebcdc7df591281e9c1/" rel="bookmark">
			Linux环境快速搭建RocketMQ集群模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.上传rocketmq-all-4.7.1-bin-release文件夹到 /apps/svc下 进入apps/svc文件夹下 （三台机器相同操作）
cd /apps/svc
创建对应的文件夹
mkdir rocketmq
mkdir rocketmq/data #存放消息路径
mkdir rocketmq/data/commitlog
#消费队列存储路径存储路径
mkdir rocketmq/data/consumerqueue
#消息索引存储路径
mkdir rocketmq/data/index
2.修改rocketmq的配置文件:broker-a.properties broker-b.properties broker-c.properties #进入到mq配置文件
cd /apps/svc/rocketmq-all-4.7.1-bin-release/conf/2m-noslave/
因为有3个master主节点，所以主节点1启动依赖broker-a.properties，主节点2启动依赖broker-b.properties，主节点3启动依赖broker-c.properties （分别对应三台机器）
配置文件如下：
#所属集群名字
brokerClusterName=rocketmq-cluster
#broker名字，注意此处不同的配置文件填写的不一样
brokerName=broker-a
#0 表示 Master， &gt;0 表示 Slave
brokerId=0
#nameServer地址，分号分割 注意填写三台机器对应ip namesrvAddr=127.0.0.1:9876;127.0.0.1:9876;127.0.0.1:9876
#在发送消息时，自动创建服务器不存在的topic，默认创建的队列数
defaultTopicQueueNums=6
#是否允许 Broker 自动创建Topic，建议线下开启，线上关闭
autoCreateTopicEnable=true
#是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭
autoCreateSubscriptionGroup=true
#Broker 对外服务的监听端口
listenPort=10911
#删除文件时间点，默认凌晨 0点
deleteWhen=00
#文件保留时间，默认 48 小时
fileReservedTime=120
#commitLog每个文件的大小默认1G
mapedFileSizeCommitLog=1073741824
#ConsumeQueue每个文件默认存30W条，根据业务情况调整
mapedFileSizeConsumeQueue=300000
#destroyMapedFileIntervalForcibly=120000
#redeleteHangedFileInterval=120000
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5aebb1c936e9ccebcdc7df591281e9c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e314bbd998286797dd028f9a92cb710a/" rel="bookmark">
			Web Worker的概念、用法、使用场景
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​
目录
1. 简介
2. 适用场景
2.1 复杂计算
2.2 后台下载
2.3 数据处理
2.4 实时通信
3. 代码示例
3.1 Worker特性检测
3.2 Worker API
3.3 SharedWorker API
3.4 创建 JavaScript 文件
3.5 创建 Web Worker
4. 总结
1. 简介 Web Worker 使得在一个独立于 Web 应用程序主执行线程的后台线程中运行脚本操作成为可能。这样做的好处是可以在独立线程中执行费时的处理任务，使主线程（通常是 UI 线程）的运行不会被阻塞/放慢。
2. 适用场景 2.1 复杂计算 当涉及到大量计算或复杂的数据处理时，可以将这些操作放在 Web Worker 中进行，避免阻塞主线程。例如，图像处理、音频处理、视频处理等。
2.2 后台下载 当需要下载大量数据时，可以使用 Web Worker 在后台进行数据的下载和处理，以避免阻塞用户界面。例如，从服务器获取大量数据并进行处理之后再展示给用户。
2.3 数据处理 当需要对大量数据进行处理或者排序时，可以使用 Web Worker 将处理逻辑放在后台线程中进行，提高处理的效率。
2.4 实时通信 可以使用 Web Worker 来处理实时通信的逻辑。在主线程可以与 Web Worker 进行通信，从而实现实时的数据交换。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e314bbd998286797dd028f9a92cb710a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/833278ddab5d568cc141bda264270c1c/" rel="bookmark">
			【Java多线程】【wait 和 notify】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、wait() 方法 2、notify() 方法
notifyAll()方法
3、小结
线程之间是 抢占式执行的，调度是无序的，再实际开发中，要求协调多个线程之间的执行先后顺序；
wait()：让当前对象进入等待状态notify()/notifyAll()：唤醒在当前对象上的等待的线程 wait()、notify()、notifyAll()都是 Object类方法
1、wait() 方法 wait() 方法是Object类的方法，用于将当前线程置于等待状态，并且会释放当前线程所持有的锁；
主要做的事情：
解锁：释放当前的锁（前提拥有锁）阻塞等待：当前线程进入等待状态满足条件或收到通知，就唤醒，重新尝试获取锁 结束条件：
notify唤醒：其他线程调用该对象的notify方法；wait()等待超时：wait()可以指定等待时间，超时就自动唤醒其他线程调用该线程的 interrupted方法，导致wait抛异常； 2、notify() 方法 用于唤醒 一个正在等待的该对象锁的线程，如果有多个线程在等待该对象锁，则只会唤醒其中一个线程，具体是哪一个由JVM调度决定；
使用：
必须在同步块中调用，并且必须拥有该对象的锁（与wait()的对象是同一个）；也是在 synchronized 中使用，必须先执行 wait，在执行 notify 才有效果，没先执行wait，notify 执行无效果；执行notify方法后，当前线程不会立即释放该对象锁，等调用notify方法的线程执行完毕，才会释放锁 notifyAll()方法 与notify()唤醒一个线程不同，notifyAll()是唤醒所有等待该对象锁的线程，同步竞争；
3、小结 wait()和notify()方法虽然可以实现线程之间的协作，但使用不当可能会导致线程死锁或者线程饥饿的问题。
特点
wait()
notify()
执行条件
必须在 synchronized 代码块中
必须在 synchronized 代码块中
对象锁
调用前必须先获得对象锁
调用前必须先获得对象锁
释放锁
是
否
执行
执行后进入 等待状态，等待唤醒
唤醒后，进入竞争锁，继续执行
必须在wait执行后，调用才有效果，没有先执行wait，等于打空
中断
抛出InterruptedException异常
不会出现异常
线程状态
进入等待状态
从等待返回运行状态
代码演示：
public static void main(String[] args) throws InterruptedException { Object locker = new Object(); // Thread thread1 = new Thread(()-&gt;{ System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/833278ddab5d568cc141bda264270c1c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f533af9f6287e6aa2cf7a2dc29c7a631/" rel="bookmark">
			六边形架构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		六边形架构 微服务系统架构微服务定义微服务系统设计 传统分层架构六边形架构参考资料 微服务系统架构 需求描述做什么的问题，架构描述怎么做的问题(描述组成系统的各部件及其之间的关系)
微服务定义 下面的定义来自周志明老师的 凤凰架构
微服务是一种通过多个小型服务组合来构建单个应用的架构风格，这些服务围绕业务能力而非特定的技术标准来构建。各个服务可以采用不同的编程语言，不同的数据存储技术，运行在不同的进程之中。服务采取轻量级的通信机制和自动化的部署机制实现通信与运维。
微服务系统设计 在讨论如何设计一个微服务之前，我们可以先想一想如何描述一个系统。
当我们在讨论微服务系统架构时，很多人都会把架构粗犷的理解为根据系统需求划分为几个模块的服务，这是不对的。站在工程的角度，我们描述一个系统的角度应该是立体的。主要使用 “4+1” 视图来进行描述.
那么，什么是 “4+1” 视图呢？
4+1架构模型：（逻辑、实现、进程、部署） + 场景
整理如下，
四种视图并不互斥，可互相组合。
架构可以描述一个软件的质量属性，我们评价一个系统主要可以从以下几个方向进行评估，
可维护性，可测试性，可部署性
安全性，可靠性，可扩展性
当我们学习如何描述一个系统的架构之后才可以慢慢观察如何对系统架构进行设计，
如果是微服务的系统架构设计，从较高的视角来看，我们可以从两个点思考，
根据需求描述，把他转换成一堆服务的组合，（如何把一个系统分解成不通过的服务）把服务确定之后，如何建立服务之间的通信？ 在思考这两个问题之前，我们需要矫正自己的认知，
系统设计描绘的是系统的实现而不是需求, 而软件工程就是把一个系统的需求转换成一个系统的架构 如果解决了上面的两个问题，我们就需要针对单个微服务进行设计。因此又引申出三个问题。
我们如何对服务进行详细的设计？如何衡量一个微服务的系统设计优劣？怎样描述一个微服务系统程序？ 这就需要我们回到微服务的代码结构去思考！
传统分层架构 微服务时代，具体到微服务组件的设计。国内常用的还是使用传统的分层架构。
分层架构(逻辑视图)：表示层（用户接口或外部API)，业务逻辑层，持久层
| - Web | - Controller | - Domain | - Service | - Persistence | - Repository 开发问题：有些人会把Web层写的很臃肿，导致domain层没啥逻辑，失去了Web层可替换的优点
传统分层架构的优点和缺点
缺点：不支持客户端，不支持多数据库（（同一个功能不支持两个数据库）MySQL -&gt; Oracle 行吗？），领域层依赖持久层优点：开发简单 什么业务场景适合使用传统分层架构？ 需要快速构建的新应用程序 传统IT部门和流程的企业或业务应用程序 具有尚不了解其他架构的经验不足的开发人员的团队 需要严格的可维护性和可测试性标准的应用 六边形架构 what is 六边形架构，我们应该怎么去使用它？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f533af9f6287e6aa2cf7a2dc29c7a631/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13229784924be396f26aaca8280c599d/" rel="bookmark">
			shell脚本之ssh批量登录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自动化运维脚本 前提条件——nmap、expect、sshpass 1.安装nmap扫描工具 eg. https://blog.csdn.net/smli_ng/article/details/105964486 └─# apt-get install -y nmap 2.安装expect自动化交互语言 └─# apt-get install -y expect eg. https://www.jianshu.com/p/32de653aa05a 3.安装sshpass非交互式登录工具 └─# apt-get install -y sshpass eg. sshpass -p 123456 ssh -p 1000 root@远程服务器IP地址 端口探测——scan_hosts #!/bin/bash #22 Port Scan DATE=`date +%F-%R` read -p "please input tager host: " host nmap -sS -p 22 -T4 $host | grep "Nmap scan report for" | awk '{print $5}' &gt;&gt;./host_status/scan_host_$DATE.txt &amp;&amp; cp ./host_status/scan_host_$DATE.txt ip.txt while read host_up do echo "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13229784924be396f26aaca8280c599d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/309fd7fe8a7fe587dcc01b3d850193d7/" rel="bookmark">
			IDE远程调试阿里云服务器部署的war包程序（超详细图文教程）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、阿里云服务器配置远程调试
二、IDE配置远程调试
三、使用远程调试
四、常见问题汇总
一、阿里云服务器配置远程调试 第一步：在tomcat安装目录的bin目录中，找到catalina.sh文件，并进行编辑。
第二步：进入catalina.sh文件后，在开头添加如下配置，注意我这里开放的远程调试端口是5005端口，具体选择哪个端口进行远程调试根据自己的需要，但是不要使用将要被调试的应用程序提供服务的端口作为远程调试的端口。
CATALINA_OPTS="-agentlib:jdwp=transport=dt_socket,address=5005,suspend=n,server=y" 二、IDE配置远程调试 第一步：点击IDE工具栏中的run，然后选择Edit Configurations。
第二步：第一步完成后进入如下图弹框，点击+号，选择Remote JVM Debug。
第三步：第二步完成后进入如下弹框，进行图片中的操作，然后点击Apply，最后点击OK，此时IDE配置完成。
三、使用远程调试 如下图：
到此，远程调试结束。
四、常见问题汇总 虽然按照了上述步骤进行了操作，但是实践过程中往往会出现各种各样的问题，以下是作者本人在配置远程调试过程中遇到的问题，希望对你也能提供帮助。
1、连接超时错误
报错信息：
Unable to open debugger port (****:5005): java.net.ConnectException "Connection time out" 解决思路：
首先在终端通过ping命令确保你配置在IDE中的IP地址是可以访问的。
其次在阿里云平台找到对应的服务器查看安全组规则，确保远程调试的端口在安全组中进行了添加并开启。
解决方法：
（1）如果在你的终端配置的IP地址是不可以访问的，那就要确定你配置的是否是服务器的公网IP，这个在阿里云平台找到对应的服务器是可以看到的。
（2）如果没有在安全组中配置远程调试的端口，此时就需要进行配置。具体安全组配置步骤查看阿里云服务器开放端口的正确方式（超详细图文教程）_阿里云开放端口_思涛的博客的博客-CSDN博客
2、拒绝连接错误
报错信息：
Unable to open debugger port : java.net.ConnectException "Connection refused: connect" 解决思路：
首先在终端通过如下命令检查配置的远程调试端口是否可以访问。（注意：我这里使用的是Mac系统，若为Windows系统可以自行查找相应的命令）
// 127.0.0.0 替换为IDE配置的IP // 5005 替换为配置的远程调试端口号 nc -vz 127.0.0.0 5005 若可以访问则出现succeeded，否则出现Connection refused。
其次在服务器的终端通过如下命令查看端口状态。
netstat -an|grep 5005 cp 0 0 127.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/309fd7fe8a7fe587dcc01b3d850193d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61f2191d33ad1b4aa797961dc84a575e/" rel="bookmark">
			【Java面试题汇总】设计模式篇（2023版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		导航： 【黑马Java笔记+踩坑汇总】JavaSE+JavaWeb+SSM+SpringBoot+瑞吉外卖+SpringCloud+黑马旅游+谷粒商城+学成在线+设计模式+牛客面试题
目录
谈谈你对设计模式的理解？
谈谈你对单例模式的理解？
手写一下单例模式
谈谈你对工厂模式的理解？
谈谈你对代理模式的理解？
谈谈你对模板模式的理解？
谈谈你对观察者模式的理解？
职责链模式
谈谈JDK中用到的设计模式？
谈谈Spring中用到的设计模式？
谈谈你对设计模式的理解？ 关键字：总结的设计经验、通用解决方案、维护性通用性扩展性、降低复杂度、具体问题具体分析；七大原则、三种类型。
设计模式：
设计模式是程序员在面对同类软件工程设计问题所总结出来的有用的经验。模式不是代码，而是某类问题的通用解决方案，设计模式（Design pattern）代表了最佳实践。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。
设计模式的本质提高软件的维护性、通用性和扩展性，并降低软件的复杂度。
过度地使用设计模式可能会导致代码的过度抽象，增加了代码的维护难度和学习成本。因此，在使用设计模式时需要根据具体的项目需要和实际情况进行选择。
七大原则：
单一职责原则：一个类应该只负责一项职责。提高可读性维护性、降低耦合。接口隔离原则：类之间的依赖关系应该建立在最小的接口上。例如实现类只能用到接口的部分方法，为了降低冗余提高可维护性，对原接口进行合理的拆分和组合。依赖倒转原则：高层模块不应该直接依赖于低层模块，两者都应该依赖于抽象。即详细应该依赖于抽象。在调用链上，调用者属于高层，被调用者属于低层。例如controller层不能直接依赖于service层，他们都应该依赖于抽象，即service接口。里氏代换原则：子类引用指向父类对象后功能未变，子类中尽量不要重写父类的方法。开闭原则：软件对扩展开放，对修改关闭。提高扩展性和可维护性。迪米特法则：最少知道原则，一个类对自己依赖的类知道的越少越好，只与直接的朋友（成员变量，方法参数，方法返回值的类）通信。合成复用原则：尽量使用聚合或组合的方式，而不是使用继承。也就是把需要用到的类作为本类的参数、成员变量、局部变量。 类之间关系：
依赖：我用到了你，我就依赖你。例如你是我的成员变量、成员方法的参数返回值中间变量等。泛化：泛化就是继承。实现：实现类实现了接口。关联：类与类之间的关系，可以一对一、零对一、一对多等。例如学生和学号是关联的。聚合：整体和部分可以分割。例如电脑USB接口聚合了鼠标，鼠标是电脑的成员方法。组合：整体和部分不能分割。例如把鼠标焊死在电脑上，他们就是组合关系了。 设计模式类型：
创建型模式：用于对象的创建，包括单例、工厂等模式。结构型模式：用于描述对象之间的组合关系，包括代理、享元等模式行为型模式：用于描述对象之间的通信和责任分配。包括模版方法、观察者、责任链等模式 谈谈你对单例模式的理解？ 关键字：概念（一个实例、一个静态方法）、实现方案、优缺点（节省资源、避免重复创建对象、管理全局变量、注意线程安全）、场景（重量级对象）
保证一个类只有一个实例，并且只提供一个取得对象实例的静态方法。
实现方式： 饿汉：构造器私有化、类内部创建私有静态常对象、静态公共方法返回这个实例。线程安全（类加载器加载类是线程安全的），没用到会浪费内存（类加载过程会给类变量赋初值）。懒汉：类内部创建私有静态对象引用、静态公共方法判空再实例化再返回。懒加载，线程不安全，可以方法加synchronized锁实现同步但效率低。双重检查：优化懒汉，类内部引用volatile修饰，双层判空中间synchronized类级别锁。线程安全，延时加载，效率高，推荐。静态内部类：在静态内部类里面创建实例。线程安全，延时加载，效率高，推荐。枚举：提倡。枚举类的常量是单例的。 优点：
节省资源：单例模式实例只有一个，可以避免重复创建对象，从而节省了资源，提高了系统性能。管理全局变量：单例模式可以用于管理全局状态和变量，方便在整个系统中共享数据。简化系统架构：使用单例模式可以简化系统架构，减少类的数量和接口的复杂度。 缺点：
可能引发并发问题：单例模式在多线程中使用时，需要保证线程安全，否则可能会引发并发问题。内存泄漏问题：单例对象是类变量，属于GC Roots，它和它引用的对象即使不再被引用，也不会被JVM垃圾回收。可能增加系统复杂性：过度使用单例模式可能会增加系统复杂性，导致代码难以维护。难以调试：由于单例模式全局共享状态，可能会导致调试过程中的问题难以定位和测试。 使用场景：
需要频繁的进行创建和销毁的对象、创建对象时耗时过多或耗费资源过多但又经常用到的对象（即：重量级对象）、工具类对象、频繁访问数据库或文件的对象（比如数据源、session 工厂等）JDK中 java.lang.Runtime类就是饿汉式单例模式。 手写一下单例模式 实现方式： 饿汉懒汉、双重检查、静态内部类、枚举。
饿汉（静态常量版）：线程安全，没用到会浪费内存。
public class Singleton { // 1、构造器私有化 private Singleton() { } // 2、类的内部创建对象 private static final Singleton instance = new Singleton(); // 3、向外暴露一个静态的公共方法 public static Singleton getInstance() { return instance; } } 懒汉（同步方法版）：懒加载，线程安全，但效率低（每次获取实例都要加锁），不推荐。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61f2191d33ad1b4aa797961dc84a575e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82cff8c6ee1340568f5bcc8c1f91946d/" rel="bookmark">
			C语言程序设计之循环练习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		//编写代码实现，模拟用户登录情形，并且只能登录3次
//（只允许输入三次密码。如果密码正确则提示登陆成功，如果三次均错误则退出程序）
#include&lt;stdio.h&gt; #include&lt;string.h&gt; int main() { int i = 0; char password[20] = { 0 }; for (i = 0; i &lt; 3; i++) { printf("请输入密码:&gt;"); scanf("%s", password);//此处不需要取地址，数组名本身就是地址 //if(password=="abcdef") 错误！ 比较两个字符串是否相等，不能用==，而应该使用 strcmp函数 if (strcmp(password, "abcdef") == 0)//如果返回值是0，表示两个字符串相等 //对应头文件#include&lt;stralign.h&gt; { printf("登陆成功！\n"); break; } else { printf("密码错误！\n"); } } if (i==3) { printf("三次密码均输入错误，登陆失败！"); } return 0; } 只是做一个简单的联系，实际应用的登录问题肯定要比这复杂得多，可以看出，我们这里设置了默认密码为abcdef，输入的密码与其做比对，相同则输入正确，不同则输入错误.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83f6e0a288163d2dca0d0ccc7c15a3fd/" rel="bookmark">
			脑电信号处理与特征提取——1. 脑电、诱发电位和事件相关电位（胡理）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、 脑电、诱发电位和事件相关电位
1.1 EEG基本知识
1.2 经典的ERPs成分及研究
1.2.1 ERPs命名规则及分类
1.2.2 常见的脑电成分
1.2.3 P300及Oddball范式
1.2.4 N400成分
一、 脑电、诱发电位和事件相关电位 1.1 EEG基本知识 EEG(Electroencephalogram)：脑细胞的自发性、节律性、综合性的电活动。
脑电信号的频率、波幅、位相是脑电信号的基本特征。
周期与频率即是指一个波离开基线到回到基线所花的时间（可以把基线理解为波上下波动所围绕的一条水平线，这是人为定义的一条线，准确定义是：脑波上下偏移的中心轴线）。
基线是人为定义的，且随着人的生理状态而发生改变，如精神极度紧张、呼吸不稳等因素会导致基线不稳，在小儿发育过程中，由于脑功能还不完善，也会出现基线不稳的情况。扯的有点远，关于基线，只需要知道它是一条人为定义的中心轴线即可。下图中红色箭头所指直线即为基线。
波幅指的是一个波的波峰到波谷的距离。因为脑电的基线会因为环境变换而动荡，所以不能简单的依据基线定义波幅。如上图绿色箭头所指直线所示，将两个波谷最低点连接起来，然后取波峰对应的点作直线到波谷最低点连成的直线上，线段的长度即为波幅。正常人脑电图波幅一般为10-100μV，波幅代表了脑电位的强度，波幅大小还与参与同步放电的神经元数目以及同步程度有关。举个例子来说，音乐会上唱歌的观众越多（神经元数目），且唱同一首歌且同一句（同步程度），那么场外记录到的声音越清晰明朗。
位相即指一个横轴代表时间，纵轴代表电位的脑电波，在某一时间点其在基线上或者下的位置，反映的是一个瞬时状态。以基线为标准，朝上的波称为负向波（负性波），朝下的波为正向波（正性波），再次注意负向波与正向波的定义，在后面分析脑电波的时候会经常遇到。如果两个波在某个瞬间位相一致，我们称之为同相位，如果相差180°，我们称之为位相倒置，好比两个人唱歌完全不在一个调上。
幅值：10~100uV
特点：自发性（无时无刻都在产生）、随机性（赋值正负随机变化，无规律性）、节律性（特定频率delta,theta,alpha,beta,gamma,比如图中闭眼的时候会出现α波）、节律性（脑电中样式相同、周期一致、而且是重复出现的活动）
频率和赋值之间有一定的关系。 δ：深度睡眠状态。低频高幅
θ：正常人在深度放松或浅睡眠状态下才会出现，觉醒时候出现属于不正常情况（但青年女性有时候会出现低幅度的）。
α：通常在放松状态下，闭目养神时候出现。人在清醒状态下闭眼时候常出现（犯困）。 β：紧张、精力集中时候才会出现。 ERPs的定义
事件相关脑电位（Event-Related Potentials，ERP）是基于脑电信号提取的，ERP包含在EEG之中，EEG泛指大脑产生的所有电信号，而ERP可以简单理解为EEG当中我们想要的、特定的一部分。
ERP是比自发脑电更弱，一般只有2到10微伏，通常淹埋在自发脑电中，所以ERP需要使用一定的技术手段才能从EEG中提取出来，ERP具有恒定的波形和潜伏期，因此才能够通过叠加平均的方式进行分离。
所有的ERP波形都是时间锁定和相位锁定的。时间锁定是指大脑对刺激事件的反应相对于基线的变化出现在同一时间段内，即潜伏期恒定；相位锁定是指大脑对刺激反应的能量值基于基线的变化方向一致，即波形恒定。
EEG和ERP都是脑电波，ERP是我们因为研究需要，通过技术手段将实验任务中具体刺激物出现时的EEG片段截取出来，再将这些EEG片段进行叠加平均后形成的具有恒定波形和潜伏期的脑电波。
通过叠加平均的方式对ERP成分分离有两个重要的前提条件。第一个是在静息状态时我们大脑神经元放电交错复杂且无规律，EEG波形不锁时也不锁相，在进行多次叠加平均后可近似抵消趋于平稳；第二个由任务事件引发的成分是锁时锁相的，在进行叠加的时候不会被抵消，如下图中将波形进行叠加平均后，ERP成分被很好地分离出来。
ERP的两个重要特点：波形恒定、潜伏期恒定（所以可以直接叠加） 。
得到一个ERP波，需要关注两个值：峰值、潜伏期。
1.2 经典的ERPs成分及研究 1.2.1 ERPs命名规则及分类 视觉刺激： 视觉一般在40ms后会出现，而听觉是直接出现。即听觉会比视觉先做出反应。 听觉刺激：
体感刺激：（通常用电刺激）
1.2.2 常见的脑电成分 1.2.3 P300及Oddball范式 P300：300ms出现的一个正向波。 实线：注意实验，虚线：非注意实验。
概率越小，P300越明显波幅越大。靶与非靶均是反比。 靶刺激和非靶刺激同概率，均会产生P300,但非靶刺激弱，只不过仅仅关注靶刺激的，不关注非靶刺激。
新奇刺激不同于其他类型的刺激，比较新奇。新奇刺激主要产生P3a,其他产生P3b
P3a出现位置比较靠前，也比P3b较短。
1.2.4 N400成分 与语言相关。出现在400ms左右的波形。上负下正。
语义不匹配或者冲突时候诱发N
运动性失语症：是大脑左半球额叶损伤，即大脑S区损坏所导致的综合征，患者虽然发音器官并没有毛病，却失去了说话的能力，患者仍保留听懂别人说话，以及写字，和阅读的能力。
感受性失语症：不能理解口语或书面语，特别是不能理解或说出口语及说不出物体的名称和性质。
但进一步研究发现，与P300相似，N400也有许多子成分，分别与不同的认知过程相关，有彼此不同的脑内源。而且也发现N400不仅与语言加工有关，面孔、画图等非语言刺激也能诱发N400。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37757def6d7e770e5009b5925c1d0182/" rel="bookmark">
			【LoRa】【BLOOMZ】用peft训练bloomz保存检查点，保存和加载的权重不一致？？？adapter_model.bin只有4kb？？？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 最近用peft的lora对bloomz做训练，参考的https://github.com/linhduongtuan/BLOOM-LORA，训练了1轮后发现，结果没有任何变化，用几个检查点做了测试结果也是没有任何变化。
我的神经病一触即发
能看到检查点中adapter_model.bin只有4kb，这明显什么都没有保存。
4.0K ./bloomz7b1-patent-full/checkpoint-2600/adapter_config.json 4.0K ./bloomz7b1-patent-full/checkpoint-2600/adapter_model.bin 31M ./bloomz7b1-patent-full/checkpoint-2600/optimizer.pt 16K ./bloomz7b1-patent-full/checkpoint-2600/rng_state.pth 4.0K ./bloomz7b1-patent-full/checkpoint-2600/scheduler.pt 20K ./bloomz7b1-patent-full/checkpoint-2600/trainer_state.json 4.0K ./bloomz7b1-patent-full/checkpoint-2600/training_args.bin 狂找原因
有两篇帖子能作为参考
https://github.com/huggingface/peft/issues/503和model.save_pretrained() produced a corrupted adapter_model.bin (only 443 B) with alpaca-lora · Issue #286 · huggingface/peft · GitHub
都是解决保存和加载不一致的问题
但最终，我的解决办法是把这几行注释就可以了
# old_state_dict = model.state_dict # model.state_dict = ( # lambda self, *_, **__: get_peft_model_state_dict(self, old_state_dict()) # ).__get__(model, type(model)) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dddf6199820213a1a2913b0054d7bef2/" rel="bookmark">
			C&#43;&#43;实现五子棋（含步骤 结尾附完整代码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用C++实现五子棋大概分为以下四个步骤：
1.创建棋盘和游戏界面 2.实现棋子的绘制和落子 3.实现胜负判断和游戏结束 4.实现悔棋和重新开始功能 1.创建棋盘和游戏界面
首先，我们需要创建一个棋盘和游戏界面，可以使用Qt框架来实现。具体步骤如下：
1.1 创建Qt项目，并在主窗口中添加一个QGraphicsView控件，用于显示游戏界面。
1.2 在QGraphicsView中添加一个QGraphicsScene，用于绘制棋盘和棋子。
1.3 在QGraphicsScene中添加一个QPixmapItem，用于显示棋盘的背景图片。
1.4 将棋盘分成15行15列，使用QGraphicsRectItem绘制棋盘的格子。
示例代码如下：
// 创建一个棋盘场景 QGraphicsScene* scene = new QGraphicsScene(this); // 添加背景图片 QPixmap pixmap(":/images/board.png"); QGraphicsPixmapItem* pixmapItem = new QGraphicsPixmapItem(pixmap); scene-&gt;addItem(pixmapItem); // 绘制棋盘的格子 const int kBoardSize = 15; const int kCellSize = 40; const int kMargin = 20; for (int i = 0; i &lt; kBoardSize; i++) { for (int j = 0; j &lt; kBoardSize; j++) { QGraphicsRectItem* rectItem = new QGraphicsRectItem( kMargin + i * kCellSize, kMargin + j * kCellSize, kCellSize, kCellSize); rectItem-&gt;setPen(QPen(Qt::black, 1)); rectItem-&gt;setBrush(QBrush(Qt::white)); scene-&gt;addItem(rectItem); } } // 将场景添加到视图中 ui-&gt;graphicsView-&gt;setScene(scene); 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dddf6199820213a1a2913b0054d7bef2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce2b7bac21a46a2d0c10712d924d9cbc/" rel="bookmark">
			plt.imshow()和plt.show()的区别?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 plt.imshow()：
plt.imshow()用于显示图像数据或二维数组（也可以是三维数组，表示RGB图像）。当你有一个二维数组或图像数据时，你可以使用plt.imshow()将其可视化为图像。它将数组中的每个元素的值映射为一个颜色，并将这些颜色排列成图像的形式。plt.imshow()可以接受许多参数，用于控制图像的外观，例如颜色映射（colormap）、插值方法等。 plt.show()：
plt.show()用于显示所有已创建的图形。在使用Matplotlib绘制图形时，图形被存储在内存中，但不会自动显示在屏幕上。为了在屏幕上显示图形，你需要调用plt.show()函数。通常，在你创建完所有的图形之后，调用plt.show()一次，它会同时显示所有的图形窗口。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91720c3bfc1fe3c70d6a5039e72fb9e9/" rel="bookmark">
			C语言基础：预处理指令的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文结合工作经验，研究C语言中常见的预处理指令的用法。
文章目录 1 预处理指令概念2 常见的预处理指令2.1 #include包含头文件2.2 #define定义宏2.2.1 类对象宏（object-like macro）2.2.2 类函数宏（function-like macro） 2.3 条件编译 3 总结 1 预处理指令概念 编译器编译C代码的第一个阶段就是预处理。预处理阶段会对预处理指令进行处理，将C代码“翻译”成另一个样子，为后续的编译、汇编、链接过程做准备。下面每个章节会研究一些常见的预处理指令。
2 常见的预处理指令 2.1 #include包含头文件 #include应该是最常见的预处理指令了，基本上每个C文件都会通过include包含若干头文件，或者头文件嵌套包含头文件。在预处理阶段，编译器会将include包含的头文件展开，写到C文件中。例如下面的C文件包含了一个头文件。
//demo.c #include "demo_type.h" uint8 demo(uint8 a,uint8 b) { return a + b; } //demo_type.h typedef unsigned char uint8; 经过预处理过程，头文件的内容被展开到了C文件include的地方，这个头文件就不再需要了。
//预处理后的demo.c typedef unsigned char uint8; uint8 demo(uint8 a,uint8 b) { return a + b; } 由此，这个C文件就可以使用头文件中定义的类型了。
再进一步思考，增量式编译的编译器会对包含了修改过的头文件的C文件重新编译，因此C文件不要包含多余的头文件，以免增加编译时间。
对于头文件嵌套的情况，会一层一层展开来。
2.2 #define定义宏 2.2.1 类对象宏（object-like macro） 通过#define可以定义一个宏，预处理阶段的时候，如果在代码中遇到一个宏，就会将其替换成宏所对应的内容。首先看一下不用宏定义的代码，例如如下代码：
//circle.c float cal_area(float radius) { return 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91720c3bfc1fe3c70d6a5039e72fb9e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76a6b152862cbb06cb4bac2387d898dd/" rel="bookmark">
			JavaScript与TypeScript的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JavaScript和TypeScript是两种不同的编程语言，在一些方面有一些区别。
1. 类型系统：JavaScript是一种动态类型语言，变量的类型是在运行时确定的，并且可以随时更改。而TypeScript引入了静态类型系统，可以在编译时检查代码中的类型错误，提供更严格的类型检查和类型提示。
2. 类型注解：在JavaScript中，不需要显式声明变量的类型，可以直接赋值。而在TypeScript中，可以使用类型注解来显式声明变量的类型，如: `let num: number = 10;`，通过类型注解可以更清晰地指定变量的类型。
3. ECMAScript标准支持：JavaScript是基于ECMAScript标准的脚本语言，而TypeScript是在JavaScript基础上进行扩展的。TypeScript支持ECMAScript的各个版本，并添加了一些额外的语言特性和功能。
4. 编译器和工具支持：JavaScript可以直接在浏览器或者Node.js环境中运行，而TypeScript需要通过编译器将TypeScript代码编译成JavaScript代码，然后才能运行。TypeScript提供了强大的编译器和开发工具支持，如类型检查、自动补全、重构等。
5. 生态系统：JavaScript有一个庞大的生态系统，有很多现成的第三方库和框架可供使用。TypeScript可以无缝地使用JavaScript生态系统中的库和框架，并提供了额外的类型声明文件来支持类型检查。
总之，TypeScript是JavaScript的一个超集，它在JavaScript基础上添加了静态类型系统和一些新的语言特性，提供了更好的开发体验和代码质量保证。但是JavaScript仍然是一种非常流行和常用的语言，具有广泛的应用和支持。根据具体的项目需求和团队技术栈，可以选择适合的语言来开发。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c41f2f9f42979fddc1bda5d3c39c716/" rel="bookmark">
			javascript算法之数组反转浅谈
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文主要介绍了javascript算法之数组反转，文章围绕主题展开详细的内容介绍，具有一定的参考价值，需要的小伙伴可以参考一下
1.数组反转 1.1 leecode题目-旋转数组 给你一个数组，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。
示例：
输入: nums = [1,2,3,4,5,6,7], k = 3
输出: [5,6,7,1,2,3,4]
解释:
向右轮转 1 步: [7,1,2,3,4,5,6]
向右轮转 2 步: [6,7,1,2,3,4,5]
向右轮转 3 步: [5,6,7,1,2,3,4]
1.2 分析题目 数组元素有序轮转，即轮转位置k,意味着，每个元素向后移k位，且长度n-k~n-1位置的元素会被挪移至最前方；k为非负整数，所以，不存在向左轮转; 1.3解题思路 在不使用额外数组的前提下，我们可以有如下思考， 设数组长度为length，则
需要轮转k位，即数组的最后k位会进行挪移至数组前方，即，当我们反转数组后，可以得知[0,k-1],[k,lenth-1]这两个数组,即为轮转之后的对应数组，但是，两个数组中的元素排序是反的；接下来，依次反转[0,k-1],[k,lenth-1]，这两个数组，得到的数组就是答案了 1.4 代码 1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
const reverseArray = (nums, start, end) =&gt; {
while (start &lt; end) {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c41f2f9f42979fddc1bda5d3c39c716/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a7f0aaa41f861bd6d474aec22b7ec82/" rel="bookmark">
			Linux驱动开发实战(一)——设备驱动模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言设备驱动模型概述设备驱动模型的功能sysfs文件系统sysfs文件系统的目录结构 设备驱动模型的核心数据结构kobject结构体设备属性kobj_type 注册kobject到sysfs中的实例设备驱动模型结构kset集合kset与kobject的关系kset相关的操作函数注册kobject到sysfs中的实例实例测试 设备驱动模型的三大组件总线总线属性和总线方法设备驱动 小结 前言 在早期的Linux内核中并没有为设备驱动提供统一的设备模型。随着内核的不断扩大及系统更加复杂，编写一个驱动程序越来越困难，所以在Linux2.6内核中添加了一个统一的设备模型。这样，写设备驱动程序就稍微容易一些了。本章将对设备模型进行详细的介绍。
设备驱动模型概述 设备驱动模型比较复杂，Linux系统将设备和驱动归一到设备驱动模型中来管理。设备驱动模型的提出，解决了以前编写驱动程序没有统一方法的局面。设备驱动模型给各种驱动程序提供了很多辅助性的函数，这些函数经过严格测试，可以很大程度上地提高驱动开发人员的工作效率。
设备驱动模型的功能 Linux内核早期的版本为编写驱动程序提供了简单的功能：分配内存、分配I/O地址、分配中断请求等。写好驱动后，直接把程序加入到内核的相关初始化函数中，这是一个非常复杂的过程，所以开发驱动程序并不简单。并且，没有统一的设备驱动模型。几乎每一种设备驱动程序都需要自己完成所有的工作，驱动程序中不免会产生错误和大量的重复代码。
有了设备驱动模型后，现在的情况就不一样了。设备驱动模型提供了硬件的抽象，内核使用该抽象可以完成很多硬件重复的工作。这样很多重复的代码就不需要编写和调试了，编写驱动程序的难度就有所下降。这些抽象包括如下几个方面：
1.电源管理
电源管理一直是内核的一个组成部分，在笔记本和嵌入式系统中更是如此，它们使用电池来供电。简单地说，电源管理就是当系统的某些设备不需要工作时，暂时的以最低电耗的方式挂起设备，以节省系统的电能。电源管理的一个重要功能是：在省电模式下，使系统中的设备以一定的先后顺序挂起；在全速工作模式下，使系统中的设备以一定的先后顺序恢复运行。
例如：一条总线上连接了A、B、C三个设备，只有当A、B、C三个设备都挂起时，总线才能挂起。当A、B、C三个设备中的任何一个恢复以前，总线必须恢复。总之，设备驱动模型使得电源管理子系统能够以正确的顺序遍历系统上的设备。
2.即插即用设备支持
越来越多的设备可以即插即用了，最常用的设备就是U盘，甚至连(移动)硬盘也可以即插即用。这种即插即用机制，使得用户可以根据自己的需要安装和卸载设备。设备驱动模型自动捕捉插拔信号，加载驱动程序，使内核容易与设备进行通信。
3.与用户空间的通信
用户空间程序通过sysfs虚拟文件系统访问设备的相关信息。这些信息被组织成层次结构，用sysfs虚拟文件系统来表示。用户通过对sysfs文件系统的操作，就能控制设备，或者从系统中读出设备的当前信息。
sysfs文件系统 sysfs文件系统是Linux众多文件系统中的一个。在Linux系统中，每个文件系统都有其特殊的用途。例如ext2用于快速读写存储文件；ext3用来记录日志文件。
Linux设备驱动模型由大量的数据结构和算法组成。这些数据结构之间的关系非常的复杂，多数结构之间通过指针相互关联，构成树形或者网状关系。显示这种关系的最好方法是利用一种树形的文件系统，但是这种文件系统需要具有其他文件系统没有的功能，例如显示内核中的一些关于设备、驱动和总线的信息。为了达到这个目的，Linux内核开发者创建了一种新的文件系统，这就是sysfs文件系统。
1.sys概述
sysfs文件系统是Linux2.6内核的一个新特性，其是一个只存在于内存中的文件系统。内核通过这个文件系统将信息导出到用户空间中。sysfs文件系统的目录之间的关系非常复杂，各目录与文件之间既有树形结构，又有目录关系。
在内核中，这种关系由设备驱动模型来表示。在sysfs文件系统中产生的文件大多数是ASCII文件，通常每个文件有一个值，也可叫属性文件。文件的ASCII码特性保证了被导出信息的准确性，而且易于访问，这些特点使sysfs成为2.6内核最直观，最有用的特性之一。
2.sysfs文件系统与内核结构的关系
sysfs文件系统是内核对象（kobject）、属性（kobj_type）及它们的相互关系的一种表现机制。用户可以从sysfs文件系统中读出内核的数据，也可以将用户空间的数据写入内核中。这是sysfs文件系统非常重要的特性，通过这个特性，用户空间的数据就能够传送到内核空间中，从而设置驱动程序的属性和状态。下表揭示了内核中的数据结构与sysfs文件系统的关系。
sysfs文件系统的目录结构 sysfs文件系统中包含了一些重要的目录，这些目录中包含了与设备和驱动等相关的信息，现对其详细介绍如下：
1.sysfs文件系统的目录
sysfs文件系统与其他文件系统一样，由目录、文件、链接组成。与其他文件系统不同的是，sysfs文件系统表示的内容与其他文件系统中的内容不同。另外，sysfs文件系统只存在于内存中，动态的表示着内核的数据结构。
sysfs文件系统挂接了一些子目录，这些目录代表了注册sysfs中的主要子系统。
要查看这些子目录和文件，可以使用ls命令，命令执行如下：
当设备启动时，设备驱动模型会注册kobject对象，并在sysfs文件系统中产生以上的目录。现对其中的主要目录所包含的信息进行说明。
2. block目录
块目录包含了在系统中发现的每个块设备的子目录，每个块设备对应一个子目录。每个块设备的目录中有各种属性，描述了设备的各种信息。例如设备的大小、设备号等。块设备目录中有一个表示I/O调度器的目录，这个目录中提供了一些属性文件。它们是关于设备请求队列信息和一些可调整的特性。用户和管理员可以用它们优化性能，包括用它们动态改变I/O调度器。块设备的每个分区表示为块设备的子目录，这些目录中包含了分区的读写属性。
3. bus目录
总线目录包含了在内核中注册而得到支持的每个物理总线的子目录，例如ide、pci、scsi、i2c和pnp总线等。使用ls命令可以查看bus目录的结构信息，如下所示：
ls命令列出了注册到系统中的总线，其中每个目录中的结构都大同小异。这里以usb目录为例，分析其目录的结构关系。使用cd usb命令，进入usb目录，然后使用ls命令列出usb目录中包含的目录和文件，如下所示：
usb目录中包含了devices和drivers目录。devices目录包含了USB总线下所有设备的列表，这些列表实际上是指向设备目录中相应设备的符号链接。使用ls命令查看如下所示。
其中1-0:1.0和2-0：1.0是USB设备的名字，这些名字由USB协议规范来定义。可以看出devices目录下包含的是符号链接，其指向/sys/devices目录下的相应硬件设备。硬件的设备文件是在/sys/devices/目录及其子目录下，这个链接的目的是为了构建sysfs文件系统的层次结构。
drivers目录包含了USB总线下注册时所有驱动程序的目录。每个驱动目录中有允许查看和操作设备参数的属性文件，和指向该设备所绑定的物理设备的符号链接。
class目录
类目录中的子目录表示每一个注册到内核中的设备类。例如固件类(firmware)、混杂设备类（misc）、图形类(graphics)、声音类(sound)和输入类(input)等。这些类如下所示。
类对象只包含一些设备的总称，例如网络类包含一切的网络设备，集中在/sys/class/net目录下。输入设备类包含一切的输入设备，如鼠标、键盘和触摸板等，它们集中在/sys/class/input目录下。关于类的详细概述将在后面讲述。
设备驱动模型的核心数据结构 设备驱动模型由几个核心的数据结构组成，分别是kobject、kset和subsystem。这些结构使设备驱动模型组成了一个层次结构。该层次结构将驱动、设备和总线等联系起来，形成一个完整的设备模型。下面分别对这些结构进行详细的介绍。
kobject结构体 宏观上来说，设备驱动模型是一个设备和驱动组成的层次结构。例如一条总线上挂接了很多设备，总线在Linux中也是一种设备，为了表述清楚，这里将其命名为A。在A总线上挂接了一个USB控制器硬件B，在B上挂接了设备C和D，当然如果C和D是一种可以挂接其他设备的父设备，那么在C和D设备下也可以挂接其他设备，但这里认为它们是普通设备。另外在A总线上还挂接了E和F设备，则这些设备的关系如下图所示。
在sysfs文件系统，这些设备使用树形目录来表示，如下所示。
树形结构中每个目录与一个kobject对象相对应，其包含了目录的组织结构和名字等信息。在Linux系统中，kobject结构体是组成设备驱动模型的基本结构。最初它作为设备的一个引用计数使用，随着系统功能的增加，它的任务也越来越多。kobject提供了最基本的设备对象管理能力，每一个在内核中注册的kobject对象都对应于sysfs文件系统中的一个目录。kobject结构体的定义如下：
1.kobject结构体
kobject结构体的定义如下：
struct kobject{ const char *name; /*kobject的名称*/ struct list_head entry; /*连接下一个kobject结构*/ struct kobject *parent; /*指向父kobject结构体，如果存在父亲*/ struct kset *kset; /*指向kset集合*/ struct kobj_type *ktype; /*指向kobject的类型描述符*/ struct sysfs_dirent *sd; /*对应sysfs的文件目录*/ struct kref kref; /*kobject的引用计数*/ unsigned int state_initialized:1; /*该kobject对象是否初始化的位*/ unsigned int state_in_sysfs:1; /*是否已经加入sysfs中*/ unsigned int state_add_uevent_sent:1; unsigned int state_remove_uevent_sent:1; } 下面对kobject的几个重要成员介绍如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a7f0aaa41f861bd6d474aec22b7ec82/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5ff4304da0f463603dcb7a8ba80fa4e/" rel="bookmark">
			C# 父类实现的 IEquatable＜T＞ 接口，重写的相等性判断函数都能被子类继承
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实验代码 Son s1 = new(), s2 = new(); Console.WriteLine("_ = s1 == s2"); _ = s1 == s2; Console.WriteLine(); Console.WriteLine("_ = s1 != s2;"); _ = s1 != s2; Console.WriteLine(); Console.WriteLine("_ = s1.Equals(s2);"); _ = s1.Equals(s2); Console.WriteLine(); Console.WriteLine("_ = ((object)s1).Equals(s2);"); _ = ((object)s1).Equals(s2); Console.WriteLine(); Console.WriteLine("s1 is IEquatable&lt;Father&gt;"); Console.WriteLine(s1 is IEquatable&lt;Father&gt;); Console.WriteLine(); Console.WriteLine("s1.GetHashCode()"); Console.WriteLine(s1.GetHashCode()); Console.WriteLine(); public class Father : IEquatable&lt;Father&gt; { public virtual int A { get; set; } public virtual int B { get; set; } public override bool Equals(object?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5ff4304da0f463603dcb7a8ba80fa4e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dca402bf96c42b80b6207b0907616ba4/" rel="bookmark">
			文字超出一行显示展开按钮，点击展开全部显示，点击收起只显示一行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;template&gt;
&lt;view&gt;
&lt;text class="content" :class="{ 'expand': isExpanded }"&gt;{{ content }}&lt;/text&gt;
&lt;view v-if="showExpandButton" class="expand-button" @tap="toggleExpand"&gt;
{{ isExpanded ? '收起' : '展开' }}
&lt;/view&gt;
&lt;/view&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
data() {
return {
content: '这里是你的文字内容，可以是很长的一段文字...',
isExpanded: false,
showExpandButton: false,
};
},
mounted() {
// 在 mounted 钩子中计算文字是否超过一行，从而决定是否显示展开按钮
this.$nextTick(() =&gt; {
const query = uni.createSelectorQuery().in(this);
query
.select('.content')
.boundingClientRect((rect) =&gt; {
// 这里根据文字的实际高度和 view 的高度来判断是否显示展开按钮
this.showExpandButton = rect.height &gt; 40; // 假设一行高度是40px
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dca402bf96c42b80b6207b0907616ba4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21acbe4c72a2904900946ddce7bb8622/" rel="bookmark">
			Python实现我的世界小游戏源代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这篇文章主要介绍了Python实现我的世界小游戏源代码,代码简单易懂，对大家的学习或工作具有一定的参考借鉴价值，需要的朋友可以参考下
我的世界小游戏使用方法：
移动
前进：W，后退：S，向左：A，向右：D，环顾四周:鼠标，跳起：空格键，切换飞行模式:Tab;
选择建筑材料
砖：1，草：2，沙子：3，删除建筑：鼠标左键单击，创建建筑块：鼠标右键单击
ESC退出程序。
完整程序包请通过文末地址下载，程序运行截图如下：
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21acbe4c72a2904900946ddce7bb8622/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9548ce45ec4534bf80e676344970ea82/" rel="bookmark">
			Ubuntu20.04根目录扩容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 由于初始给虚拟机分配的容量太小，后面文件变多之后系统会出现“文件系统根目录上磁盘空间不足”的提示，所以需要给根目录进行扩容，在VMware中进行扩容的具体步骤如下。
1.关闭虚拟机，在设置中扩展硬盘容量
2.查看磁盘是否扩容，发现没有挂载上去，容量还是之前的40G
df -Th 3.下载gparted工具
sudo apt-get install gparted 4.在应用程序中打开gparted工具
5.选择根目录的挂载分区，右键调整大小，就可以把未分配的磁盘容量分配到根目录中（图片中已经是扩容完成之后）
6.再次查看磁盘容量大小，发现容量变为78G，已经成功挂载
df -Th 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e16d2b325c5d4cdb4cc277ec004b2bb/" rel="bookmark">
			osgEarth的Rex引擎原理分析（一二九）地图下载器实现原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目标：（七十二）中问题148
java版本：
String iPath="http://online2.map.bdimg.com/tile/?qt=tile&amp;x=4&amp;y=4&amp;z=5&amp;styles=pl&amp;udt=20171031&amp;scaler=1&amp;p=1"; try { //对资源链接 URL url=new URL(iPath); //打开输入流 InputStream inputStream=url.openStream(); //对网上资源进行下载转换位图图片 bitmap= BitmapFactory.decodeStream(inputStream); inputStream.close(); //再一次打开 inputStream=url.openStream(); File file=new File(Environment.getExternalStorageDirectory()+"/haha.jpg"); FileOutputStream fileOutputStream=new FileOutputStream(file); int hasRead=0; while((hasRead=inputStream.read())!=-1){ fileOutputStream.write(hasRead); } fileOutputStream.close(); inputStream.close(); } catch (MalformedURLException e) { e.printStackTrace(); } catch (IOException e) { Log.v("111","2222"); } c++版本
osgEarth::ReadResult r = URI("/storage/emulated/0/Android/data/com.example.testnativecplusplus/tests/mb_tiles_test.earth").readString( 0 ); std::stringstream in( r.getString() ); osgEarth::URIContext uriContext( 0 ); osg::ref_ptr&lt;osgEarth::XmlDocument&gt; doc = osgEarth::XmlDocument::load( in, uriContext ); osgEarth::Config docConf = doc-&gt;getConfig(); osgEarth::Config conf; conf = docConf.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e16d2b325c5d4cdb4cc277ec004b2bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab1d10829895123961d07791db162a1d/" rel="bookmark">
			Action过滤器（ActionFilter）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、基本使用 首先需要定义一个Action过滤器类，如命名为：MyActionFilter，继承IActionFilter(同步)或IAsyncActionFilter(异步)接口，这里以IAsyncActionFilter为例，如图：
然后在Program.cs中注册自定义的Action过滤器：
1
2
3
4
builder.Services.Configure&lt;MvcOptions&gt;(options =&gt; {
//注册自定义的Actioin过滤器
options.Filters.Add&lt;MyActionFilter&gt;();
});
控制台输出如下：
如果添加多个Action过滤器呢? 效果是什么样的？这里添加了三个Action过滤器
1
2
3
4
5
6
builder.Services.Configure&lt;MvcOptions&gt;(options =&gt; {
//注册自定义的Actioin过滤器
options.Filters.Add&lt;MyActionFilter&gt;();
options.Filters.Add&lt;MyActionFilter2&gt;();
options.Filters.Add&lt;MyActionFilter3&gt;();
});
MyActionFilter2：
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
public class MyActionFilter2 : IAsyncActionFilter
{
public async Task OnActionExecutionAsync(ActionExecutingContext context, ActionExecutionDelegate next)
{
Console.WriteLine("MyActionFilter2 Begin");
//执行真正要执行的Action
ActionExecutedContext nextContext = await next();
//通过Exception判断Action是否执行成功
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab1d10829895123961d07791db162a1d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86dc8ebc6abf4af1fcc4a19a9a355f02/" rel="bookmark">
			less详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		less基础详解_less写法_James.Huang1的博客-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03fcc7d59e28c62160d8c216cd7fb4d9/" rel="bookmark">
			Unity 之 错误的停止协程的方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 相信很多人都会这样开启一个协程
StartCoroutine(Cor_1()); 这样确实没啥毛病，那么怎么关掉这个协程呢，是不是在想也是一样的传cor_1()这个参数，然后start对应stop,试着输入stopCor....诶，代码提示有这个方法喔，然后写下了这样的代码
StopCoroutine(”Cor_1“); 结果你会发现这个协程并没有被停下来。。。那该咋办呢？我在网上找了这样一篇文章，感觉很有用，大家可以参考下
Unity 之 关于停止协程的五种方式解析
个人觉得最好的方法就是定义一个Coroutine类型的变量，然后对它赋值，想停止时也对它操作就好了
private Coroutine _taskExitCoroutine; _taskExitCoroutine = StartCoroutine(PlayUpdateExitTime()); StopCoroutine(_taskExitCoroutine); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6a253d4717e3ae0e1484608243e4484/" rel="bookmark">
			JAVA集合比较器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求，将岗位按照热门、推荐、正常排序
由于设计的是字典，且键值不管按照倒叙还是正序都无法满足需求（别问我为什么，问以前设计的人）
一是按照修改sql
看了很多文章，一般都是加FIELD，但是存的char类型，不知道为什么没有不生效
select * from ttt where type = 2 ORDER BY FIELD('status',1,0,2); 对集合进行修改，新加比较器
List&lt;KjEnterprisePost&gt; postList = kjEnterprisePostMapper.selectKjEnterprisePostList(kjEnterprisePost); //比较器 热门 -- 推荐 -- 正常 Comparator&lt;KjEnterprisePost&gt; comparator = new Comparator&lt;KjEnterprisePost&gt;() { List&lt;String&gt; orderList = Arrays.asList("2", "3", "1"); @Override public int compare(KjEnterprisePost post1, KjEnterprisePost post2) { String sysPublish1 = post1.getKjSysPublish(); String sysPublish2 = post2.getKjSysPublish(); int index1 = orderList.indexOf(sysPublish1); int index2 = orderList.indexOf(sysPublish2); return Integer.compare(index1, index2); } }; // 使用比较器对postList集合进行排序 Collections.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d6a253d4717e3ae0e1484608243e4484/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01ac399fe03c865549e4d1c65ee1519f/" rel="bookmark">
			Ubuntu系统上检测DNS服务器的多种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​
在Ubuntu系统上检测DNS服务器的方法如下，并附带实际的例子和优点：
参考：
https://www.howtouseubuntu.com/network/how-to-check-dns-server-in-ubuntu/
### 方法一：使用nslookup命令检查DNS解析
- 命令示例：nslookup example.com
优点：
- 简单易用，可以快速查询指定域名的解析信息。
- 提供详细的解析结果，包括域名、IP地址和对应的DNS服务器。
### 方法二：通过dig命令获取DNS记录
- 命令示例：dig example.com A
优点：
- 可以查询各类DNS记录，包括A、CNAME、MX等。
- 提供更全面的DNS信息，有利于深入分析和故障排除。
### 方法三：使用host命令检查域名解析
- 命令示例：host example.com
优点：
- 简单直观，直接返回域名的IP地址。
- 适用于快速验证域名是否解析正确。
### 方法四：检查resolv.conf文件配置
- 命令示例：cat /etc/resolv.conf
优点：
- 可以一次性查看系统的DNS解析配置，包括DNS服务器地址。
- 可以直接编辑文件来修改DNS服务器配置。
### 方法五：测试DNS服务器的连通性
- 命令示例：ping 8.8.8.8
优点：
- 可以测试系统与DNS服务器的连通性，确认是否可以正常通信。
这些方法在Ubuntu系统上检测DNS服务器的有效性和配置情况非常有用。使用nslookup和host命令可以快速验证单个域名的解析情况，适合快速定位问题。而使用dig命令可以更全面地查询各类DNS记录，有助于深入了解DNS配置。检查resolv.conf文件配置和测试DNS服务器连通性则更多用于确认系统的DNS配置和网络连通性。
希望这些方法能帮助您更好地检测和优化DNS服务器配置。
我们整理了一份Linux学习的pdf文件，放在下面的路径，可以自提：
https://www.howtouselinux.com/post/linux-commands-for-linux-beginners-cheat-sheet
​
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89f9a1724f1b5b33af9ea497683ab402/" rel="bookmark">
			HashMap 的底层实现（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据结构 JDK1.8 之前 HashMap 底层是 数组和链表 结合在一起使用也就是 链表散列。HashMap 通过 key 的 hashcode 经过hash方法处理过后得到 hash 值，然后通过 (n - 1) &amp; hash 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。
hash+数组的所组成的结构叫做散列表。
在最好的情况下我们可以直接O(1)的时间复杂度就能直接查出来，虽然说一个好的hash算法能够平均分布从而减少冲突的概率，但是冲突始终是无法避免的。
在Java中int类型是4个字节，也就是32个二进制位组成，那它们发生冲突的概率是4,294,967,296分之一。对于这一点我们不用太过于担心，但是实际情况是我们结构中是一个数组，但是我们生成的int值它的取值范围则是-2^31 ~ 2^31-1 ，而我们计算机的内容空间是一个有限的，不可能分配这么大一块连续的内存空间，像HashMap默认容量也就16个，那就极有可能会发生hash冲突了。
如何解决散列冲突问题呢？
链地址法不论是在我们HashMap还是Redis中都是通过这种方案来解决Hash冲突的。在散列表中，每个“桶”或者“槽”会对应一条链表，所有散列值相同的元素我们都放到相同槽位对应的链表中。
看下图：
当插入的时候，我们只要通过散列函数计算出对应的散列槽位，将其插入到对应链表中即可，所以插入的时间复杂度是O(1)。当查找、删除一个元素时，我们同样通过散列函数计算出对应的槽，然后遍历链表查找或者删除。那查找或删除操作的时间复杂度是多少呢？
实际上，这两个操作的时间复杂度跟链表的长度 k 成正比，也就是 O(k)。对于散列比较均匀的散列函数来说，理论上讲，k=n/m，其中 n 表示散列中数据的个数，m 表示散列表中“槽”的个数。
这个是一般状态下的链地址法，而在JDK7中HashMap就是这么实现的，但是到了JDK8就发生了一些改变，我们先来说说为什么要改?
第一印象肯定是对比两者的时间复杂度，链表最差是O(N)而红黑树是稳定的O(log(N)) ，能得出来的结论大部分场景下红黑树的查询效率比链表高和更加稳定。但是树形结构的增删改成本会更高一点，涉及到了树的不断左旋右旋。红黑树之后说。
将高十六位无符号右移之后与低十六位做异或运算使得高十六位的特征与低十六位的特征进行了混合得到的新的数值中就高位与低位的信息都被保留了 ，而在这里采用异或运算而不采用&amp; ，| 运算的原因是 异或运算能更好的保留各部分的特征，如果采用&amp;运算计算出来的值会向1靠拢，采用|运算计算出来的值会向0靠拢，通过这种方式我们可以进一步提升hashcode的离散性，使得结果分布更加均匀，也能减少hash碰撞。
事实上除了右移和异或之外hashmap获取下标前还有一步操作。它就是按位与&amp;，那按位与是做什么用的呢？我们来看下面一段代码：
final V putVal(int hash, K key, V value, boolean onlyIfAbsent,boolean evict) { Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89f9a1724f1b5b33af9ea497683ab402/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e088e342369fc7513f7f4b3aacee3cbe/" rel="bookmark">
			【ThinkPHP6 - 连接 SQLite 及遇到的一些问题】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简易小项目，需要做个人员报道表格，后台需要查看与导出，这时就想到不用 MySQL 了，直接使用 SQLite 。
一、 连接配置 以下是 ThinkPHP6 的数据库连接配置
&lt;?php return [ // 默认使用的数据库连接配置 'default' =&gt; 'sqlite', // 自定义时间查询规则 'time_query_rule' =&gt; [], // 自动写入时间戳字段 // true为自动识别类型 false关闭 // 字符串则明确指定时间字段类型 支持 int timestamp datetime date 'auto_timestamp' =&gt; true, // 时间字段取出后的默认时间格式 'datetime_format' =&gt; 'Y-m-d H:i:s', // 时间字段配置 配置格式：create_time,update_time 'datetime_field' =&gt; '', // 数据库连接配置信息 'connections' =&gt; [ 'sqlite' =&gt; [ // 数据库类型 'type' =&gt; 'sqlite', // 数据库名 # 这里替换成自己的 SQLite 数据库文件路径 'dsn' =&gt; 'sqlite:/doc/sql/sqlite.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e088e342369fc7513f7f4b3aacee3cbe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9164c6188620fa66f04f368d54776242/" rel="bookmark">
			Hadoop笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Hadoop概念 Hadoop是一个软件，这个软件包含三个模块 HDFS: Hadoop分布式文件系统MapReduce:分布式计算系统Yarn:分布式资源调度系统 资源网址 apache的资源包下载 https://archive.apache.org/dist/ Hadoop-3.1.4官网 https://hadoop.apache.org/docs/r3.1.4/ HDFS文件系统 概述 HDFS的全称：Hadoop分布式文件系统HDFS合适存储大容量数据，合适存储大文件HDFS可以将一些廉价的计算机进行整合，形成一个完整的存储系统，并且对外提供统一的访问路径 特性 HDFS在存储数据时将文件进行切分，切分成多个block（128=134217728字节），每一个block会有多个副本（默认3个副本）HDFS在读取文件的时候，不能保证实时性，HDFS在存储大体量数据时，速度慢，时间长，一般适合一次写入多次读取,所以不适合做网盘HDFS只适合存大文件，不适合存小文件，因为每在HDFS上存储一个文件，namenode的内存就会记录一条元数据，每条元数据大概150字节，小文件过多，元数据过多，则会大量占用namenode内存HDFS不支持文件的随机修改，只支持文件的追加写入HDFS的存储可以近乎无限扩展 HDFS的架构 HDFS是主从架构，主节点是namenode，从节点是datanode
![image.png](https://img-blog.csdnimg.cn/img_convert/48c4ea7411ad75879d6233821e3d84dd.png#averageHue=#fbfbfb&amp;clientId=u7f919bba-9188-4&amp;from=paste&amp;height=212&amp;id=uacd450c9&amp;originHeight=212&amp;originWidth=465&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=29806&amp;status=done&amp;style=none&amp;taskId=ud652cce0-3c84-4faf-b259-277086da4fb&amp;title=&amp;width=465) HDFS角色的功能
NameNode 保存整个HDFS集群的元数据 NameNode需要知道每一个DataNode上block的信息客户端在上传或者下载文件时，需要从NameNode设置或者获取元数据信息NameNode的元数据信息是保存在内存中，但是会定时保存到硬盘（Secondary NameNode） DataNode 保存具体文件数据要定时与NameNode之间发送心跳包要定时向NameNode汇报Block信息客户端要下载或者上传文件时，具体的文件操作是和DataNode进行交互 Seconday NameNode 辅助NameNode进行元数据管理(元数据持久化存储，保存到硬盘) Client Client负责上传文件和下载文件的发起工作Client在上传文件时会对文件进行切片 HDFS的切片机制 HDFS的BLOCK只是一个逻辑单位
假如BLOCK的大小设置为128M，意思是这个BLOCK最大是128M
BLOCK的大小可以通过：hdfs-site.xml中的dfs.blocksize参数来进行设置
HDFS的副本机制 HDFS的每个BLOCK都会有多个副本，默认是3个
HDFS的副本数可以通过hdfs-site.xml中的dfs.replication参数来进行设置
HDFS的NameSpace HDFS会给每一个存储的文件提供一个统一的访问路径 #格式 hdfs://namenode:port/dir-a/dir-b/dir-c/file.data。 #使用1-使用绝对前缀方式 hdfs://node1:8020/dir/a.txt hadoop fs -put a.txt hdfs://node1:8020/dir #使用1-使用相对前缀方式 /dir/a.txt hadoop fs -put a.txt /dir HDFS的元数据 在HDFS中，Namenode管理的元数据具有两种类型： 1、文件自身属性信息 文件名称、权限，修改时间，文件大小，副本数，数据块大小。 2、文件块位置映射信息 记录文件块和DataNode之间的映射信息，即哪个块位于哪个节点上。 HDFS的机架感知 第一个BLOCK副本会存储在离客户端最近的一台主机上，如果客户端就是集群中的主机，则直接存在客户端所在主机，如果Client不在集群范围内或者不在同一个子网，则会在集群中随机选一个机架，在该机架中随机选一个健康（心跳正常，硬盘容量正常）的主机，将这个BLOCK存入第二个BLOCK副本会存入另外一个机架（随机选择），会在该机架上随机选一台健康的主机，将数据存入第三个BLOCK副本会在第二个BLOCK副本的机架上随机选择另外一台健康主机，将BLOCK数据存入 HDFS目录规划 目录说明/source用于存储原始采集数据/common用于存储公共数据集，例如：IP库、省份信息、经纬度等/workspace工作空间，存储各团队计算出来的结果数据/tmp存储临时数据，每周清理一次/warehouse/warehouse存储hive数据仓库中的数据 HDFS集群命令 # 一键操作命令 stop-dfs.sh start-dfs.sh HDFS的shell命令 #格式 hadoop fs -命令 参数 #该命令可以操作任何文件系统 hdfs dfs -命令 #该命令只能操作HDFS文件系统 #文件的上传 hadoop fs -put a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9164c6188620fa66f04f368d54776242/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1f4c471e49a1ba4bc3f23b32137ea35/" rel="bookmark">
			java用户名和密码授权链接elasticsearch
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java链接es,有用户名和密码的链接情况。先添加依赖
&lt;!--es数据库连接--&gt; &lt;dependency&gt; &lt;groupId&gt;org.elasticsearch&lt;/groupId&gt; &lt;artifactId&gt;elasticsearch&lt;/artifactId&gt; &lt;version&gt;7.17.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt; &lt;artifactId&gt;elasticsearch-rest-high-level-client&lt;/artifactId&gt; &lt;version&gt;7.17.2&lt;/version&gt; &lt;/dependency&gt; 用RestClientBuilder进行链接
private static final String HOST = "127.0.0.1"; private static final int PORT = 9200; private static final String username = "elastic"; private static final String password = "elastic"; public static RestHighLevelClient getClient(){ final BasicCredentialsProvider credentialsProvider = new BasicCredentialsProvider(); credentialsProvider.setCredentials(AuthScope.ANY, new UsernamePasswordCredentials(username, password)); RestClientBuilder builder = RestClient.builder(new HttpHost(HOST, PORT)) .setHttpClientConfigCallback(new RestClientBuilder.HttpClientConfigCallback() { public HttpAsyncClientBuilder customizeHttpClient( HttpAsyncClientBuilder httpClientBuilder) { httpClientBuilder.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a1f4c471e49a1ba4bc3f23b32137ea35/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4bce2e7fc28807b16f66dd7dd289cf8/" rel="bookmark">
			shell入门学习-环境变量的配置文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、在shell中，有四个主要的环境变量配置文件：
①：/etc/profile:系统级别的配置文件，对所有用户生效。
②：/etc/bashrc:系统级别的配置文件，但它仅对bash shell生效。当用户启动一个新的交互式bash shell时，该文件会被读取，并设置bash shell特定的环境变量和执行一些系统级别的初始化操作。
③：~/.bash_profile或~/.bash_login:这是用户级别的配置文件。
④：~/.bashrc:系统级别的配置文件。当用户启动一个新的交互式bash shell时，该文件会被读取，并设置bash shell特定的环境变量和执行一些系统级别的初始化操作。
注意:系统级别的配置文件是系统自带的，用户级别的环境变量配置文件是在创建用户时从/etc/skel/目录复制的。
2.环境变量编辑练习——修改历史记录数的大小
①、打开环境变量配置文件，命令如图所示:
②、修改profile中的历史记录数的大小
③、使/etc/profile中编辑的数据重新生效，命令如下:
3.删除变量
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/110/">«</a>
	<span class="pagination__item pagination__item--current">111/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/112/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>