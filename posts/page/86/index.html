<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1834ec06efa507ed133379319622f9bb/" rel="bookmark">
			js如何向数组中添加值，如何向javascript数组中添加元素
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 原文地址：https://www.toymoban.com/diary/js/90.html
js如何向数组中添加值，如何向javascript数组中添加元素 1、使用 push 方法。例： &lt;script type="text/javascript"&gt; var arr = []; arr.push('a','b','c'); console.log(arr); //输出内容：["a","b","c"] &lt;/script&gt; 2、使用 unshift 是，在数组前添加元素。例： &lt;script type="text/javascript"&gt; var arr = ['a']; arr.unshift('b','c','d'); console.log(arr); //输出内容：["b","c","d","a"] &lt;/script&gt; 3、使用 splice 是，从数组中添加/删除项目。例： &lt;script type="text/javascript"&gt; var arr = ['a','b','c','d']; arr.splice(2,0,'f'); console.log(arr); //输出内容：["a","b","f","c","d"] &lt;/script&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a37316e7c5966d481d3fce793f92fac/" rel="bookmark">
			阿里云主机Mysql数据库出现 mysql CREATE command denied to user 权限问题 怎么解决？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 原文地址：https://www.toymoban.com/diary/mysql/97.html
mysql CREATE command denied to user 问题解决方案 mysql UPDATE command denied to user 问题解决方案 解决方案主要针对：阿里云虚拟主机数据库满了，清空了某个表的数据后，发现数据库有时候回出现 以上问题，应该怎么解决？
解决方案1 最简单的，就是备份数据库后，重建一个数据库导入就可以了。
解决方案2 重新赋予权限就可以了。
mysql &gt; grant all privileges on 数据库.* to 用户名; mysql &gt; flush privileges;//刷新权限表 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11ebbd3188b01e5718081fca4dceab71/" rel="bookmark">
			Html阴影box-shadow多个兼容方式,box-shadow透明度如何设置？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Html阴影box-shadow多个兼容方式,box-shadow透明度如何设置？ 原文地址:https://www.toymoban.com/diary/share/98.html
阴影 box-shadow 多个兼容方式 不同浏览器的兼容方式如下： .box_shadow{ background-color: #eee; filter: progid:DXImageTransform.Microsoft.Shadow(color='#969696', Direction=135, Strength=5);/*for ie6,7,8*/ -moz-box-shadow:2px 2px 5px #969696;/*firefox*/ -webkit-box-shadow:2px 2px 5px #969696;/*webkit*/ box-shadow:2px 2px 5px #969696;/*opera或ie9*/ behavior: url(PIE.htc);/*IE8*/ } 注：IE8下支持。使用 PIE.HTC 插件 点击下载
透明度设置方式如下： 使用 rgba
.box_shadow { box-shadow:0 4px 4px rgba(0, 0, 0, 0.4); } box-shadow 使用说明 box-shadow : 0px 1px 2px rgba(0, 0, 0, 0.4);
0px 表示阴影的 x 坐标
1px 表示阴影的 y 坐标
2px 表示阴影的模糊程度
rgba(0, 0, 0, 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/11ebbd3188b01e5718081fca4dceab71/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1bc0cd5da0b731054e960abe70e87e61/" rel="bookmark">
			Tp6 多应用下路由有些没有效果，这是为什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文地址：https://www.toymoban.com/diary/thinkphp/38.html
问题描述 开启多应用后，在公共路由上的一些路由无法使用，或者出现错误信息：当前访问路由未定义或不匹配。然后一直按照 tp5.1 的规格去研究并没有什么用。
Tp6.0 路由说明 1、多应用下使用多个子域名或者独立域名访问是通过 config/app.php 文件去配置的。
'domain_bind' =&gt; [ 'blog' =&gt; 'blog', // blog子域名绑定到blog应用 'shop.tp.com' =&gt; 'shop', // 完整域名绑定 '*' =&gt; 'home', // 二级泛域名绑定到home应用], 2、每个应用的路由，都是有单独的配置文件的。
├─app 应用目录 │ ├─index 主应用 │ │ ├─controller 控制器目录 │ │ ├─model 模型目录 │ │ ├─view 视图目录 │ │ ├─config 配置目录 │ │ ├─route 路由目录 │ │ └─ ... 更多类库目录 │ ├─public WEB目录（对外访问目录） │ ├─admin.php 后台入口文件 │ ├─index.php 入口文件 │ ├─router.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1bc0cd5da0b731054e960abe70e87e61/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3adb4250a0b40be61300ad4306c4c1d7/" rel="bookmark">
			The IDE is running low on memory and this might affect performance.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		The IDE is running low on memory and this might affect performance. Please consider increasing available heap.
IDE 内存不足，这可能会影响性能。请考虑增加可用堆。
保存即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1189010f13f0554225a407e3817dd1d8/" rel="bookmark">
			获取SQL语句表名，判断DDL类型（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.使用druid解析sql语句 引入依赖
&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.9&lt;/version&gt; &lt;/dependency&gt; 2.处理sql语句 复杂的语句可能无法处理，但是大部分复杂的语句还是可以处理的
//处理sql语句 去除ROW开头到结尾的字符串，去除换行符等，否则解析会报错 String sqlDDl = "drop table if exists test_table05;" + "create table test_table15 (id int comment '自增ID',phone varchar(255) comment '手机号');" + "ROW FORMAT DELIMITED FIELDS TERMINATED BY ',' stored AS textfile;"; sqlDDl = sqlDDl.replaceAll("\r|\n"," ").replaceAll("(?i)ROW.*?(?=;)", " "); “ . ”表示任意字符，“ * ”表示前面表达式匹配任意次，“ ? ”表示非贪婪模式，“ .*?” 是满足条件的情况只匹配一次，即懒惰匹配，“ ?&lt;=A ” 表示以A开头、不替换A，“ ?=B ”表示以B结尾、不替换B，“(?i)”表示不区分大小写，“\r|\n” 表示换行符
3.获取sql语句的表名和ddl类型 //解析数据库获取表名 List&lt;String&gt; tableList = new ArrayList&lt;&gt;(); try { SQLStatementParser parser = SQLParserUtils.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1189010f13f0554225a407e3817dd1d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ecae608e4a50f556517457a7a9a76fef/" rel="bookmark">
			二叉树的概念、存储及遍历
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、二叉树的概念 1、二叉树的定义 二叉树（ binary tree）是 n 个结点的有限集合，该集合或为空集（空二叉树），或由一个根结点与两棵互不相交的，称为根结点的左子树、右子树的二叉树构成。
二叉树的特点是：
（1）每个结点最多有两棵子树，故二叉树中不存在度大于 2 的结点。
（2）二叉树是有序的，其次序不能任意颠倒，即使树中的某个结点只有一棵子树，也要区分它是左子树还是右子树。
二叉树具有以下 5 种基本形态：
1、
2、特殊的二叉树 在实际应用中，常会用到以下几种特殊的二叉树。
1.斜树 所有的结点都只有左子树的二叉树称为左斜树，所有的结点都只有右子树的二叉树称为右斜树,在斜树中，每层只有一个结点，因此斜树的结点个数与其深度相同.
2.满二叉树 在一棵二叉树中，若所有的分支结点都存在左子树和右子树，且所有的叶子都在同一层上，则称为满二叉树。
其特点是：
叶子只能出现在最下一层只有度为 0、度为 2 的结点 由于满二叉树的特性可知：满二叉树在同样深度的二叉树中结点个数、叶结点个数最多。
3.完全二叉树 对一棵具 n 个结点的二叉树按层序编号，若编号为 i 的结点与同样深度的满二叉树中编号 i 的结点在二叉树中的位置完全相同，则称为完全二叉树，那么显然有：满二叉树是完全二叉树
其特点是：
(1)若i ≤ n / 2, 则结点i为分支结点，否则为叶子结点。
(2)叶子结点只可能在层次最大的两层上出现。对于最大层次中的叶子结点，都依次排列在该层最左边的位置上。
(3)若有度为1的结点，则只可能有一个，且该结点只有左孩子而无右孩子(重要特征)。
(4)按层序编号后，一旦出现某结点(编号为i)为叶子结点或只有左孩子，则编号大于i 的结点均为叶子结点。
(5)若n为奇数，则每个分支结点都有左孩子和右孩子;若n为偶数，则编号最大的分支结点(编号为n / 2 )只有左孩子，没有右孩子，其余分支结点左、右孩子都有。
简单来说，在满二叉树中，从最后一个结点开始，连续去掉任意个的结点，即是一棵完全二叉树
3、二叉树的性质
1.非空二叉树的第 i 层上行最多有 个结点
2.在一棵深度为 k 的二叉树中，最多有 个结点，最少有 k 个结点
推论：深度为 k 且具 个结点的二叉树一定是满二叉树，但深度为 k 具有 k 个结点的二叉树不一定是斜树
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ecae608e4a50f556517457a7a9a76fef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/482a11939d0f2ed45b240aafe3cf2bba/" rel="bookmark">
			linux部署页面内容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/bin：该目录包含了常用的二进制可执行文件，如ls、cp、mv、rm等等。
/boot：该目录包含了启动Linux系统所需的文件，如内核文件和引导加载程序。
/dev：该目录包含了所有设备文件，如硬盘、光驱、鼠标、键盘等等。
/etc：该目录包含了系统的配置文件，如网络配置、用户账户、安全设置等等。
/home：该目录是所有普通用户的主目录，每个用户都有一个单独的子目录，用于存储用户的文件和配置信息。
/lib：该目录包含了程序所需的共享库文件。
/media：该目录包含了可移动设备（如CD、DVD、U盘）挂载的目录。
/mnt：该目录包含了文件系统挂载的目录。
/opt：该目录包含了可选的应用程序和第三方软件。
/proc：该目录包含了进程信息和内核信息。
/root：该目录是root用户的主目录。
/sbin：该目录包含了系统管理员使用的二进制可执行文件，如fdisk、ifconfig等等。
/tmp：该目录包含了临时文件。
/usr：该目录包含了系统的共享文件和程序，如应用程序、库文件、文档、头文件等等。
/var：该目录包含了系统运行时产生的变化数据，如日志文件、缓存文件、数据库等等。
1.用户名:
2.密码:
3.查看系统
cat /etc/os-release 4.ubantu 工具包 apt CentOS 工具包 yum
下载文件
curl -O https://nodejs.org/dist/v16.17.0/node-v16.17.0-linux-x64.tar.xz 解压文件
tar -xvf node-v16.17.0-linux-x64.tar.xz 在根目录
node
ln -s /download/nodejs/bin/node /usr/local/bin/ npm
ln -s /download/nodejs/bin/npm /usr/local/bin/ 检查
node -v #v16.17.0 5.下载node版本
6.配置文件
轻量服务器 是在防火墙里 (放行端口) 云服务器 安全组 (放行端口) 前台挂起
npm run start 后台挂起
nohub npm run start 启动
nohub node serve.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/482a11939d0f2ed45b240aafe3cf2bba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66261b67236caddb0267ec20f11216b5/" rel="bookmark">
			node.js 文件重命名||文件复制||删除||追加 增删改查
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文件重命名
//文件处理 const fs = require("fs") //文件路径 const pathToFile = path.join(__dirname, "/src/a.js") const newPathToFile = path.join(__dirname, "/src/b.js") //文件重命名 fs.rename(pathToFile, newPathToFile, function(err) { if (err) { throw err } else { console.log("Successfully renamed the file!") } }) 文件复制 参考:https://itbilu.com/nodejs/core/41cswxaTx.html
//文件处理 const fs = require("fs") //文件复制 function copyIt(from, to) { fs.writeFileSync(to, fs.readFileSync(from)); //fs.createReadStream(src).pipe(fs.createWriteStream(dst));大文件复制 } const pathToFile = path.join(__dirname, "/src/a.js") const newPathToFile = path.join(__dirname, "/src/b.js") copyIt(pathToFile,newPathToFile); 文件读取
// 异步读取文件 fs.readFile('./test.txt', 'utf8', function(err, data){ console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/66261b67236caddb0267ec20f11216b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/737ab4f116434c1a4cf380f142055484/" rel="bookmark">
			JS深拷贝详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.这里实现了深拷贝是因为在基本数据类型String Number 都可以实现深拷贝因为它只有一层 ，且每次改变的变量的值都是改变整个变量这样在堆中又开辟了一个内存空间，没有嵌套的情况下直接修改整个变量的方法在对象和方法中也适用
var a = 1 var b = a a 打印结果为 1 b 打印结果为 1 a = 2 a 打印结果为 2 b 打印结果为 1 2.这里实现了深拷贝的原因与第1条是一样的，因为改成a变量整个值，所以在堆中又开辟了一个新空间
var a = [1,2,3] var b = a a 打印结果为 (3) [1, 2, 3] b 打印结果为 (3) [1, 2, 3] a = [3,2,1] a 打印结果为 (3) [3, 2, 1] b 打印结果为 (3) [1, 2, 3] 3.这里没有实现深拷贝是因为 这里的a是引用数据类型，且修改a的值时改变的是下标0的数据，并没有整个a变量全部修改，所以并没有开辟新的内存空间，导致a和b都指向了同一个堆，故而打印的结果是一样的
var a = [1,2,3] var b = a a 打印结果为 (3) [1, 2, 3] b 打印结果为 (3) [1, 2, 3] a[0] = 2 a 打印结果为 (3) [2, 2, 3] b 打印结果为 (3) [2, 2, 3] 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/737ab4f116434c1a4cf380f142055484/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85fe275330b8e9e1b8298c0fcbc4a160/" rel="bookmark">
			平滑加权轮询算法java实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实现代码 /** * 功能描述: 平滑加权轮询算法 * * @author zhang pu * @date 11:46 2023/9/22 */ public static void smoothnessWeightPollLoadBalance() { Server serverA = new Server("127.0.0.1", 5, 0); Server serverB = new Server("127.0.0.2", 3, 0); Server serverC = new Server("127.0.0.3", 2, 0); List&lt;Server&gt; serverList = new ArrayList&lt;&gt;(); serverList.add(serverA); serverList.add(serverB); serverList.add(serverC); int i = 0; //模拟10个请求 while (i &lt; 10) { for (Server server : serverList) { server.setCurrentWeight(server.getCurrentWeight() + server.getWeight()); } Collections.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/85fe275330b8e9e1b8298c0fcbc4a160/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/846bff46d839390fb76619a09cc5d571/" rel="bookmark">
			使用docker-compose部署RocketMQ5.x 单机部署&#43;配置参数详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用docker-compose部署RocketMQ5.x 单机部署+配置参数详解 镜像拉取拉取RocketMQ服务镜像（使用apache/rocketmq镜像包含NameServer+Broker+Proxy...）拉取RocketMQ控制台镜像（rocketmq-dashboard） 安装docker-compose v2版本并赋予权限（已经安装跳过这一步）比对docker版本对应的Compose file format创建需要挂载的文件夹和文件创建NameServer需要挂载的文件夹和文件创建挂载文件夹创建挂载文件 创建Broker需要挂载的文件夹和文件创建的挂载文件夹创建broker.conf文件拷贝容器内Broker启动脚本到宿主机（如果不需要自定义堆内存可以跳过） 编写docker-compose.yml文件启动服务Broker配置详解 镜像拉取 提前先拉取需要的镜像文件，避免后面部署的时候出现镜像拉取失败的问题。
拉取RocketMQ服务镜像（使用apache/rocketmq镜像包含NameServer+Broker+Proxy…） 镜像地址： https://hub.docker.com/r/apache/rocketmq/tags
我在部署的时候最新发行版是5.1.0可以根据需求自行选择一个5.x的版本，部署流程不会有太大改变。
docker pull apache/rocketmq:5.1.0 拉取RocketMQ控制台镜像（rocketmq-dashboard） 拉取最新版即可
docker pull apacherocketmq/rocketmq-dashboard:latest 安装docker-compose v2版本并赋予权限（已经安装跳过这一步） 这里使用compose v2版本
1、下载(使用get.daocloud.io国内链接下载)
sudo curl -L "https://get.daocloud.io/docker/compose/releases/download/v2.15.1/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose 2、添加执行权限
chmod +x /usr/local/bin/docker-compose 3、验证
# docker Compose v2版本命令 docker compose version Docker Compose version v2.15.1 # docker Compose v1版本命令 docker-compose -version 4、删除docker-compose
sudo rm /usr/local/bin/docker-compose 比对docker版本对应的Compose file format 编写前先比对一下自己的docker版本对应的Compose file format，我的docker用的版本比较新这里可以用3.8或者直接写3也行
https://docs.docker.com/compose/compose-file/compose-versioning/
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/846bff46d839390fb76619a09cc5d571/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4075b51897b289bfbc052351f5b0c7b/" rel="bookmark">
			MySQL数据库定时备份 Shell脚本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 创建以下文件夹
mkdir /home/mysql/ mkdir /home/mysql/db mkdir /home/mysql/log 2. 在home/mysql 文件夹内创建 Shell脚本
vim BackUpMysql.sh 3. 复制以下内容放入BackUpMysql.sh
注意:需要把数据库信息配置成你自己的
#!/bin/bash PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin export PATH #数据库ip DBHOST='你的数据库ip' #数据库用户名 DBUSER='你的数据库用户名' #数据库用密码 DBPASSWD='你的数据库用密码' #需要备份的数据库，多个数据库用空格分开 DBNAME='你的数据库名字' #备份时间 backtime=`date +%Y-%m-%d_%H%M%S` #备份路径（当前目录） BACKPATH=$(dirname $(readlink -f $0)) echo $BACKPATH #日志备份路径 LOGPATH="${BACKPATH}/log" #数据备份路径 DBPATH="${BACKPATH}/db" #创建备份目录 [ ! -d "${LOGPATH}" ] &amp;&amp; mkdir -p "${LOGPATH}" [ ! -d "${DBPATH}" ] &amp;&amp; mkdir -p "${DBPATH}" #日志记录头部 echo "备份时间为${backtime},备份数据库表 ${DBNAME} 开始" &gt;&gt; ${LOGPATH}/mysqlback.log #正式备份数据库 for table in $DBNAME; do source=`mysqldump -u ${DBUSER} -h${DBHOST} -p${DBPASSWD} ${table}&gt; ${LOGPATH}/${backtime}.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c4075b51897b289bfbc052351f5b0c7b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42145e46091f889fffb6f6ef8695a30b/" rel="bookmark">
			java获取中文拼音
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要在Java中获取中文拼音，您可以使用第三方库，如Pinyin4j或Hanyu Pinyin。以下是使用Pinyin4j库的示例代码：
首先，需要下载并添加Pinyin4j库到您的Java项目中。可以在Maven或Gradle中添加依赖，或者手动下载JAR文件并将其包含在您的项目中。
Maven依赖：
&lt;dependency&gt;
&lt;groupId&gt;com.belerweb&lt;/groupId&gt;
&lt;artifactId&gt;pinyin4j&lt;/artifactId&gt;
&lt;version&gt;2.5.1&lt;/version&gt;
&lt;/dependency&gt;
Gradle依赖：
implementation 'com.belerweb:pinyin4j:2.5.1'
然后，你可以使用以下代码来获取中文拼音：
import net.sourceforge.pinyin4j.PinyinHelper;
public class ChinesePinyinExample {
public static void main(String[] args) {
String chineseText = "你好，世界！";
// 将中文文本转换为拼音数组
String[] pinyinArray = PinyinHelper.toHanyuPinyinStringArray(chineseText);
// 打印拼音结果
for (String pinyin : pinyinArray) {
System.out.print(pinyin + " ");
}
}
}
在上面的示例中，我们首先导入了PinyinHelper类，然后将中文文本转换为拼音数组。最后，我们循环遍历拼音数组并打印出拼音。
Pinyin4j库支持不同的拼音输出格式，你可以根据自己的需求进行设置。此外，中文的拼音可能有多音字，因此您可能需要处理多个拼音结果的情况。
使用Pinyin4j库，可以轻松地获取中文文本的拼音。如果你需要更高级的功能，也可以探索其他Java拼音库或自定义拼音转换器。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbdcec755c0dd59277c573bdd2b2078a/" rel="bookmark">
			minio报错SignatureDoesNotMatch解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		minio报错SignatureDoesNotMatch解决方案 问题背景解决方案Lyric： 请不要把分手 问题背景 minio获取私有链接秘钥报错SignatureDoesNotMatch
&lt;Error&gt; &lt;Code&gt;SignatureDoesNotMatch&lt;/Code&gt; &lt;Message&gt;The request signature we calculated does not match the signature you provided. Check your key and signing method.&lt;/Message&gt; &lt;Key&gt;836988913707909120.pdf&lt;/Key&gt; &lt;BucketName&gt;english&lt;/BucketName&gt; &lt;Resource&gt;836988913707909120.pdf&lt;/Resource&gt; &lt;RequestId&gt;17871A50E48C3ED3&lt;/RequestId&gt; &lt;HostId&gt;d81c53e4-6ba8-45a4-9918-764ac5fe0122&lt;/HostId&gt; &lt;/Error&gt; 解决方案 minio获取public访问类型的时候，不用区分ip，但是使用private的时候会区分ip，MinioClient在设置endpoint时获取私有链接，如果访问使用nginx就会报以上错误，minio官方也提出了解决方案，按照推荐配置，加入红框的配置
最后，我的配置如下
#minio服务 upstream minioserver { server 192.168.128.102:9007; server 192.168.128.103:9007; server 192.168.128.104:9007; server 192.168.128.105:9007; } location / { proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; proxy_set_header X-NginX-Proxy true; # This is necessary to pass the correct IP to be hashed real_ip_header X-Real-IP; proxy_connect_timeout 300; # To support websockets in MinIO versions released after January 2023 proxy_http_version 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bbdcec755c0dd59277c573bdd2b2078a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d9abbda3ed5242a1bb708d984be22c6/" rel="bookmark">
			onlyoffice介绍和代码集成
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		onlyoffice介绍和代码集成 1.onlyoffice介绍2.onlyoffice安装3.代码集成3.1前端代码3.2 后端代码 3.3 其他博客文章 1.onlyoffice介绍 onlyoffice可以实现网页对word,excle,ppt等文件的在线预览和编辑，详情请参考官方网址onlyoffice官网
2.onlyoffice安装 参考链接onlyoffice离线安装
3.代码集成 3.1前端代码 &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;hello onlyoffice&lt;/title&gt; &lt;!-- onlyoffice服务器安装好后，提供的api.js--&gt; &lt;script type="text/javascript" src="http://{{ip}}:8311/web-apps/apps/api/documents/api.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body style="height: 900px;"&gt; &lt;div id="placeholder" &gt;&lt;/div&gt; &lt;script type="text/javascript"&gt; var docEditor = new DocsAPI.DocEditor("placeholder",{ "document":{ "fileType": "docx", "key": Date.now()+'', // 保证文档的唯一，可以用uuid "permissions":{ "edit": true // false 为只读，true 可以编辑 }, "title":"onlyoffice-demo.docx", "url":"http://{{ip:port}}/1691505725878.docx" // 编辑或查看的文档地址 }, "documentType":"text", // doc为text ，excle为spreadsheet，ppt为presentation "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d9abbda3ed5242a1bb708d984be22c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a403717b17ac31aa16f7bee5412f0743/" rel="bookmark">
			摸鱼也摸鱼之在线数独自动求解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 在发现被老板CPU之后，大家想做的基本上都是摸鱼，像我这种没什么手法的人不可能摸鱼打MOBA游戏，所以只能选择数独这种对时间要求不怎么急促的小游戏。然而，有时候搞半天才发现从一开始就错了，这让我很苦恼，看来有必要对这一摸鱼行动进行再次摸鱼。
平台 偶然发现的在线数独页游[在线数独 (sudoku-cn.com)]
方案 浏览器安装油猴插件，并新建一个油猴脚本，其内容如下：
// ==UserScript== // @name 右键自动解答数独 // @namespace http://tampermonkey.net/ // @version 0.1 // @description try to take over the world! // @author You // @match https://sudoku-cn.com/ // @icon data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw== // @grant none // ==/UserScript== (function() { 'use strict'; let board = []; let over = false; let hang=[]; let lie=[]; let mid=[]; function getQuestion() { hang=[]; lie=[]; mid=[]; for(let i=0;i&lt;9;i++){ hang.push([false,false,false,false,false,false,false,false,false]); lie.push([false,false,false,false,false,false,false,false,false]); mid.push([false,false,false,false,false,false,false,false,false]); } board=[]; let str="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a403717b17ac31aa16f7bee5412f0743/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7fef1cb6daf9c483b304c6556be4297a/" rel="bookmark">
			java调用ffmpeg，剪切minio的视频并上传到minio
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 java调用ffmpeg，剪切minio的视频并上传到minio前提代码如下完整程序包 java调用ffmpeg，剪切minio的视频并上传到minio 前提 需要在安装minio并且本地安装ffmpeg中间件。
ffmpeg的安装查看文章
添加链接描述
代码如下 package com.example.springbootdemo.controller; import cn.hutool.core.io.FileUtil; import cn.hutool.core.io.IoUtil; import cn.hutool.core.util.IdUtil; import cn.hutool.core.util.RuntimeUtil; import cn.hutool.http.HttpResponse; import cn.hutool.http.HttpUtil; import com.example.springbootdemo.util.MinioUtil; import com.example.springbootdemo.vo.CutUrlVideoRequest; import com.example.springbootdemo.vo.CutVideoRequest; import org.springframework.beans.BeanUtils; import org.springframework.beans.factory.annotation.Value; import org.springframework.web.bind.annotation.*; import java.io.File; import java.util.ArrayList; import java.util.List; /** * 视频剪辑测试 * * @author zhangzheng * @date 2023/9/20 16:56 **/ @RestController @RequestMapping("/video") public class FfmpegController { @Value("${video.path}") private String videoPath; /** * 剪切E:\video\test.mp4 到 videoPath 中，并上传到minio中，返回minio的方位地址 * 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7fef1cb6daf9c483b304c6556be4297a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/277d84e9d0592b493b28e181450aa043/" rel="bookmark">
			ffmpeg arm64版离线安装（适用于麒麟系统）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.ffmpeg的作用 ffmpeg相当于视频剪辑的中间件。
2.ffmpeg arm64版离线安装部署 2.1 下载离线版本 打开网页 John Van Sickle - FFmpeg Static Builds ，找到ffmpeg-release-arm64-static.tar.xz，点击下载
2.2 解压，拖到服务器。 将ffmpeg-release-arm64-static.tar.xz解压出来，并将解压出来的文件夹命名为ffmpeg6,并拖到服务器对应文件夹，比如 /software ，然后执行命令赋权， chmod -R 777 /software/ffmpeg6 2.3 配置环境变量 vim /etc/profile 在最后一行加上 export PATH=$PATH:/software/ffmpeg6/
2.3 校验 输入命令 ffmpeg -version ,有输出说明安装成功
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c715377a8333e50d5e8ec8a433ac916/" rel="bookmark">
			婚礼请柬电子版制作源码系统 带完整搭建教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		来了来了，今天要给大家分享的这款源码系统可就厉害了。对于新手来说，想要制作一个小程序或是一张电子的邀请函会有点难度，需要花费一点时间。但是今天小编介绍的这款婚礼请柬电子版制作源码系统可以帮你一键式生成，功能强大，内容可以自己DIY，还有海量模板可以选择。
婚礼请柬电子版制作源码系统功能：
音乐播放功能：在请柬中可以添加音乐，使得请柬更具吸引力。自动幻灯片轮播功能：请柬中可以包含多张图片或文字描述，并采用幻灯片轮播的方式展示，增加了互动性和动态感。自动识别pc和移动设备：请柬模板能够有效识别并适应不同的设备，包括PC和移动设备。朋友圈分享指定略缩图：用户可以通过分享等方式将请柬发送到朋友圈或者好友，并且可以指定一个略缩图，以便让分享更加美观和吸引人。请柬加载预载效果：在加载请柬时，可以添加预载效果，让用户等待的时间更加愉悦。请柬留言支持特殊字符过滤功能：在请柬的留言部分，可以支持对特殊字符进行过滤，以维护留言的整洁和规范。请柬首页支持留言轮播功能：请柬的首页可以设置留言轮播功能，让最新的留言能够得到更好的展示。留言轮播开通滑块控制功能：对于留言轮播功能，可以开通滑块控制功能，以便用户更好地控制轮播的速度和节奏。地图功能：在请柬中可以添加地图功能，帮助宾客更好地找到婚礼的地点。 源码下载地址：春哥技术博客---易企秀H5场景秀源码系统
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19027a18c6f39db0a5f3bbb515154ea9/" rel="bookmark">
			【全网最全】2023研赛F题思路代码等资料获取入口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
问题1思路
问题2思路
问题3思路
问题4思路
一定要点击文末的卡片链接，因为这是资料获取入口
强对流降水临近预报
我国地域辽阔，自然条件复杂，因此灾害性天气种类繁多，地区差异大。其中，雷雨大风、冰雹、龙卷、短时强降水等强对流天气是造成经济损失、危害生命安全最严重的一类灾害性天气[1]。以2022年为例，我国强对流天气引发风雹灾害造成的死亡失踪人数和直接经济损失分别占73%和69%。由于强对流天气具有突发性和局地性强、生命史短、灾害重等特点，其短时（0~12小时）和临近（0~2小时）预报通常也是天气预报业务中的难点。
传统强对流天气临近预报主要依靠雷达等观测资料，结合风暴识别、追踪技术进行雷达外推预报，即通过外推的方法得到未来时刻的雷达反射率因子，并进一步使用雷达反射率因子和降水之间的经验性关系（即Z-R关系）估计未来时刻的降水量[2]。近年来，随着大数据的积累和计算机算力的发展，人工智能及深度学习技术发展迅速。深度学习方法是一类数据驱动的方法，理论上其性能随着训练数据量增大而提升，因此很适合有大量雷达观测数据积累的短临预报领域。目前国际上主要有两类基于深度学习的短临预报模型，一类基于卷积神经网络（Convolutional Neural Networks, CNNs），如U-Net等模型[3]；另一类基于循环神经网络（Recurrent Neural Networks, RNNs），如ConvLSTM、DGMR等模型[4, 5]。
雨滴在降落过程中受到空气阻力作用，形状可呈扁球形或馒头形，并且一般来说越大的雨滴越扁。因此，雨滴对水平偏振（电场振动方向在水平面内）的电磁波和垂直偏振（电场振动方向在垂直平面内）的电磁波的反射特征是不一样的。传统雷达仅能发射和接收一个偏振方向上的电磁波，而新型的双偏振雷达可同时发射和接收在水平和垂直两个偏振方向的电磁波，可以根据两个偏振方向上的回波的强度差别、相位关系等信息获得降水粒子的大小、相态、含水量等信息[6]，这些信息被统称为微物理信息。近年来研究表明，双偏振雷达变量反映的微物理信息里包含了对流系统的演变状态、空间动力结构等关键信息[7, 8]。因此，双偏振雷达变量的应用，理论上对于强对流预报有重要意义。
名词解释：
双偏振雷达: 一种新型的气象探测雷达，能够提供比传统雷达更丰富的物理信息。它通过测量降水粒子对水平和垂直两个方向上的电磁波的反射情况，来获取降水粒子的大小、相态、含水量等信息。这些信息被统称为微物理信息，能够帮助我们更好地预测强对流天气。双偏振雷达最常用的三个变量为：1）ZH，水平反射率因子，即水平方向的回波强度，单位通常为dBZ，主要反映降水的强弱；2）ZDR，差分反射率，即水平和垂直方向回波强度的差异，主要反映了观测区域的降水粒子大小；3）KDP，比差分相移，即单位距离上降水粒子导致的水平和垂直方向回波的相位差，主要反映了液态含水量。Z-R关系：雷达反射率和降水之间的经验性关系，通常表述为，其中R为降水量，Z为雷达反射率，和为经验性参数，通常在不同地区及不同降水类型下有差异。 附件数据：
NJU-CPOL双偏振雷达数据：降水格点数据：后续思路和代码更新见文末参考[1] 为了更好地应用双偏振雷达改进强对流降水短临预报，请回答以下问题：
问题1思路 2023华为杯研究生数学建模F题问题1：如何有效应用双偏振变量改进强对流预报，仍是目前气象预报的重点难点问题。请利用题目提供的数据，建立可提取用于强对流临近预报双偏振雷达资料中微物理特征信息的数学模型。临近预报的输入为前面一小时（10帧）的雷达观测量（ZH 、ZDR、KDP），输出为后续一小时（10帧）的ZH预报。
要建立一个数学模型来提取双偏振雷达资料中的微物理特征信息以改进强对流预报，可以使用深度学习方法，特别是卷积神经网络（CNN）或循环神经网络（RNN）。以下是一个可能的方法：
数据准备：
收集包括雷达观测数据（ZH、ZDR、KDP）和后续一小时内的ZH预报的历史数据集。确保数据集包含各种强对流天气事件的样本，以涵盖不同的气象条件。
对雷达观测数据进行预处理，包括归一化和标准化，以确保数据的一致性和可比性。
模型架构：
在深度学习中，可以选择使用卷积神经网络（CNN）或循环神经网络（RNN）的变种，具体取决于数据的时间序列性质。以下是一种可能的模型架构：
输入: (10帧) ZH, ZDR, KDP
|
├── Conv层 + ReLU激活函数
├── Conv层 + ReLU激活函数
├── LSTM层 (如果选择RNN) 或更多Conv层 (如果选择CNN)
├── 全连接层
├── 输出层
输出: (10帧) 预测的ZH
这个模型包括卷积层来捕获空间信息，以及LSTM层（或更多卷积层）来处理时间序列信息。全连接层和输出层用于产生ZH的预测值。
训练模型：
将数据集分为训练集、验证集和测试集。
使用均方误差（MSE）或其他适当的损失函数来训练模型，以最小化预测ZH与观测ZH之间的差异。
通过反向传播算法来更新模型参数，以使损失最小化。
评估模型：
使用验证集来监测模型的性能，可以计算均方根误差（RMSE）等指标来评估模型的准确性。
在测试集上进行评估以验证模型的泛化能力。
预测：
在实际应用中，使用模型来进行强对流降水预报。将前一小时的雷达观测数据输入到模型中，以获得未来一小时的ZH预报。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/19027a18c6f39db0a5f3bbb515154ea9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4e47cad3a70ec3627c96ce5678cdb64/" rel="bookmark">
			会议通知邀请函制作系统源码 带完整搭建教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好啊，今天给大家带来的是一款会议通知邀请函的制作系统源码，操作简单，十分好上手，大家可以来看看哦！
会议通知邀请函制作系统源码的功能：
制作自定义邀请函：通过可视化编辑器，可以自定义邀请函的外观和内容，包括颜色、字体、图片等。自定义表单：可以添加自定义的表单字段，例如姓名、电子邮件、手机号码等，以便收集受邀者的信息。发送邀请函：可以将邀请函以电子邮件或短信的形式发送给受邀者，同时可以设置发送时间和发送方式。跟踪活动：可以跟踪受邀者是否查看了邀请函，是否接受了邀请，以及是否参加。提醒功能：可以为受邀者设置提醒，提醒他们即将到来的会议或活动。数据分析：可以查看有关活动和邀请的统计数据，例如已发送的邀请数量、已接受的邀请数量等。 以下是部分代码图：
页面图展示：
源码下载地址：春哥技术博客--易企秀H5场景秀源码系统
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e3be393bb50ee69da818bf850bb7ed3/" rel="bookmark">
			Nginx的proxy_pass、root、alias的说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、代理配置
1、root：
root配置代理路径时，会在代理的地址后拼接配置字段：
location /static {
root static/image;
}
在访问http://ip:port/static/*.*时会映射到http://ip:port/static/static/image/*.*
2、alias（只能用于location）:
alias配置代理路径时，直接替换代理地址：
location /static {
alias static/image;
}
在访问http://ip:port/static/*.*时会映射到http://ip:port/static/image/*.*
3、proxy_pass：
proxy_pass配置代理路径时，直接替换整个代理路径，包括ip地址的端口等：
location /static {
proxy_pass http://ip_two:port_two/static;
}
在访问http://ip:port/static/*.*时会映射到http://ip_two:port_two/static/static/*.*
代理路径后不带斜杠时，配置路径会替代原本的ip和端口等，并拼接代理地址。
代理路径后带斜杠时，配置路径会替代原本的ip和端口等，不拼接代理地址。
location /static/ {
proxy_pass http://ip_two:port_two/abc/;
}
在访问http://ip:port/static/*.*时会映射到http://ip_two:port_two/abc/*.*
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0389c84396fc1671f8ca48de12bb7ac6/" rel="bookmark">
			2-python：标识符命名
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、常量与变量 ①常量：程序中值不发生改变的元素。
PI=3.1415926 ②变量：程序中值发生改变或者可以发生改变的元素。
A=9 a=4 a=A print(a) 二、标识符命名 Python语言允许采用大写字母、小写字母、下划线（_）等字符及其组合给变量命名，但名字的首字符不能是数字，中间不能出现空格，长度没有限制。在标识符中，字母大小写是有区分的。
例1：s1, num, pai_567。
例2：1df，s un作为标识符程序会报错。
例3：num和Num是两个不同的标识符。
变量就像一间教室，变量名相当于教室的门牌号，内容相当于与教室对应的班级。下图中，z201、z202、z203、z204为变量名，高一1班、高一2班、高一3班、高一4班则为每个变量对应存储的内容。
三、保留字 保留字，也称为关键字，指被编程语言内部定义并保留使用的标识符。程序员编写程序不能定义与保留字相同的标识符（变量）。
每种程序设计语言都有一套保留字，保留字一般用来构成程序整体框架、表达关键值和具有结构性的复杂语义等。掌握一门编程语言首先要熟记其所对应的保留字。
Python3.X保留字列表（33个）。保留字与内置函数不同。
Python保留字 andelifimportraiseaselseinreturnassertexceptistrybreakfinallylambdawhileclassfornonlocalwithcontinuefromnotyielddefglobalorTruedelifpassFalseNone 保留字None——None表示不存在的意思；None是一个特殊的常量；None和False不同；None不是0；None不是空字符串；None有自己的数据类型NoneType；你可以将None赋值给任何变量，但是你不能创建其他NoneType对象。
a=none b=[none,3,blue] 补：内建函数help()，help函数可以用来查看任意数据的信息。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4a843a34172c00fbb2817d7c6e2fcd7/" rel="bookmark">
			老版本chrome浏览器版本下载地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://www.slimjet.com/chrome/google-chrome-old-version.php
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a801e3d36aba1f0618864fc71bd305e7/" rel="bookmark">
			最优化方法——Matlab实现黄金分割法一维搜索
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 黄金分割法一维搜索原理算法流程： Matlab代码命令行窗口结果打印：更换匿名函数： 《最优化方法》教材上写成表的答案：黄金分割法的一些性质 黄金分割法一维搜索原理 若保留区间为[x1,b],我们得到的结果是一致的.
该方法称为黄金分割法,实际计算取近似值: x1=a+0.382(b – a), x2=a+0.618(b – a),
所以黄金分割法又称为0.618法.
黄金分割法每次缩小区间的比例是一致的，每次将区间长度缩小到原来的0.618倍.
算法流程： 黄金分割法也称作0.618法，一维指的是只含有一个未知量的情况。
Matlab代码 用matlab实现黄金分割法求解f(x)=x^2-x+2在（-1,3）上的最小值：
clc,clear,close all; a = -1; b =3; ep = 0.08*(b-a); x = a:0.1:b; f_x = x.^2-x+2; plot(x, f_x, 'linewidth', 1.5) axis([-1, 3, 0, 8]) title('f(x)=x^2-x+2') grid on; flag = 0; cnt = 0; pause(0.5) while 1 fprintf('第%d次迭代：\n', cnt) if flag==0 x2 = a + 0.618*(b-a); f2 = x2.^2-x2+2; x1 = a + b - x2; f1 = x1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a801e3d36aba1f0618864fc71bd305e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b23c96225e9a20ab3bd1b9c0adccd0b0/" rel="bookmark">
			Linux：GlusterFS 集群
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GlusterFS介绍 1）Glusterfs是一个开源的分布式文件系统,是Scale存储的核心,能够处理千数量级的客户端.在传统的解决 方案中Glusterfs能够灵活的结合物理的,虚拟的和云资源去体现高可用和企业级的性能存储.
2）Glusterfs通过TCP/IP或InfiniBand RDMA网络链接将客户端的存储资块源聚集在一起,使用单一的全局命名空间来管理数据,磁盘和内存资源.
3）Glusterfs基于堆叠的用户空间设计,可以为不同的工作负载提供高优的性能.
4）Glusterfs支持运行在任何标准IP网络上标准应用程序的标准客户端，如下图1所示，用户可以在全局统一的命名空间中使用NFS/CIFS等标准协议来访问应用数据.
Glusterfs主要特征
扩展性和高性能
高可用
全局统一命名空间
弹性hash算法
弹性卷管理
基于标准协议 工作原理：
1) 首先是在客户端， 用户通过glusterfs的mount point 来读写数据， 对于用户来说，集群系统的存在对用户是完全透明的，用户感觉不到是操作本地系统还是远端的集群系统。
2) 用户的这个操作被递交给 本地linux系统的VFS来处理。
3) VFS 将数据递交给FUSE 内核文件系统:在启动 glusterfs 客户端以前，需要想系统注册一个实际的文件系统FUSE,如上图所示，该文件系统与ext3在同一个层次上面， ext3 是对实际的磁盘进行处理， 而fuse 文件系统则是将数据通过/dev/fuse 这个设备文件递交给了glusterfs client端。所以， 我们可以将 fuse文件系统理解为一个代理。
4) 数据被fuse 递交给Glusterfs client 后， client 对数据进行一些指定的处理（所谓的指定，是按照client 配置文件据来进行的一系列处理， 我们在启动glusterfs client 时需要指定这个文件。
5) 在glusterfs client的处理末端，通过网络将数据递交给 Glusterfs Server，并且将数据写入到服务器所控制的存储设备上。
常用卷类型
分布（distributed）
复制（replicate）
条带（striped）
基本卷：
(1) distribute volume：分布式卷
(2) stripe volume：条带卷
(3) replica volume：复制卷 复合卷：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b23c96225e9a20ab3bd1b9c0adccd0b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0989327d0203cbf6d80e18f6a91fd846/" rel="bookmark">
			有手就会的动图录制神器GifCam,GIF专用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、GifCam是什么？二、使用步骤1.下载安装(下载地址见结尾)2.如何使用 总结 前言 在工作学习中，我们经常以动态图的形式展示项目效果，本文就给各位浅浅介绍一款GIF录制神器 GifCam。
一、GifCam是什么？ GifCam是一款免费软件，用于创建动画图像或gif。它的工作原理就像照相机或屏幕记录器一样，它会为你想要的区域拍摄一系列照片。之后，它会将它们保存为动画图像或AVI文件，便于共享和播放。虽然该工具有多种用途，易于操作，但它只适用于Windows。
二、使用步骤 1.下载安装(下载地址见结尾) 启动GifCam软件，调整录制框位置，窗口大小（顶部会有窗口尺寸显示，方便辨认窗口是否合适）。
2.如何使用 移动录制框到我们想生成gif 的界面上,点击单帧然后移动录制框到第二个界面
点击保存(右键可以选择多个选项我们选择默认就好),将图片保存到文件夹你会发现其实图片是不动的，我们需要选择打开方式为浏览器否则看不到效果
制作玩的图片我们也可以在保存前进行编辑，例如添加文字等
总结 GifCam 的使用场景也很多，使用这个软件你可以用它来制作幽默的 GIF 图片，分享到社交媒体上；你还可以用它来记录你的游戏过程，展示你的游戏技巧；甚至你可以用它来制作简单的教学视频，展示如何完成一项任务。
只要你想要把屏幕上的内容录制下来并分享给他人，GifCam 都是一个非常好的选择！。
gifcam下载地址
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a0b6b06e619864ae360d0112350de1b/" rel="bookmark">
			在Mysql中，什么是回表，什么是覆盖索引，索引下推？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是回表查询？ 通俗的讲就是，如果索引的列在 select 所需获得的列中（因为在 mysql 中索引是根据索引列的值进行排序的，所以索引节点中存在该列中的部分值）或者根据一次索引查询就能获得记录就不需要回表，如果 select 所需获得列中有大量的非索引列，索引就需要到表中找到相应的列的信息，这就叫回表。
InnoDB聚集索引的叶子节点存储行记录，因此， InnoDB必须要有，且只有一个聚集索引：
（1）如果表定义了主键，则PK就是聚集索引；
（2）如果表没有定义主键，则第一个非空唯一索引（not NULL unique）列是聚集索引；
（3）否则，InnoDB会创建一个隐藏的row-id作为聚集索引；
先创建一张表，sql 语句如下：
create table xttblog( id int primary key, k int not null, name varchar(16), index (k) )engine = InnoDB; 然后，我们再执行下面的 SQL 语句，插入几条测试数据。
INSERT INTO xttblog(id, k, name) VALUES(1, 2, 'xttblog'), (2, 1, '业余草'), (3, 3, '业余草公众号'); 假设，现在我们要查询出 id 为 2 的数据。那么执行 select * from xttblog where ID = 2; 这条 SQL 语句就不需要回表。原因是根据主键的查询方式，则只需要搜索 ID 这棵 B+ 树。主键是唯一的，根据这个唯一的索引，MySQL 就能确定搜索的记录。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a0b6b06e619864ae360d0112350de1b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3d8f6cc67f13d9bc48176800782669d/" rel="bookmark">
			五大常用软件架构分析方案（图文&#43;优缺对比）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、分层架构
分层架构（layered architecture）是最常见的软件架构，也是事实上的标准架构。如果你不知道要用什么架构，那就用它。
这种架构将软件分成若干个水平层，每一层都有清晰的角色和分工，不需要知道其他层的细节。层与层之间通过接口通信。
虽然没有明确约定，软件一定要分成多少层，但是四层的结构最常见。
表现层（presentation）：用户界面，负责视觉和用户互动业务层（business）：实现业务逻辑持久层（persistence）：提供数据，SQL 语句就放在这一层数据库（database） ：保存数据 有的软件在逻辑层和持久层之间，加了一个服务层（service），提供不同业务逻辑需要的一些通用接口。
用户的请求将依次通过这四层的处理，不能跳过其中任何一层。
优点
结构简单，容易理解和开发不同技能的程序员可以分工，负责不同的层，天然适合大多数软件公司的组织架构每一层都可以独立测试，其他层的接口通过模拟解决 缺点
一旦环境变化，需要代码调整或增加功能时，通常比较麻烦和费时部署比较麻烦，即使只修改一个小地方，往往需要整个软件重新部署，不容易做持续发布软件升级时，可能需要整个服务暂停扩展性差。用户请求大量增加时，必须依次扩展每一层，由于每一层内部是耦合的，扩展会很困难 二、事件驱动架构
事件（event）是状态发生变化时，软件发出的通知。
事件驱动架构（event-driven architecture）就是通过事件进行通信的软件架构。它分成四个部分。
事件队列（event queue）：接收事件的入口
分发器（event mediator）：将不同的事件分发到不同的业务逻辑单元事件通道（event channel）：分发器与处理器之间的联系渠道事件处理器（event processor）：实现业务逻辑，处理完成后会发出事件，触发下一步操作 对于简单的项目，事件队列、分发器和事件通道，可以合为一体，整个软件就分成事件代理和事件处理器两部分。
优点
分布式的异步架构，事件处理器之间高度解耦，软件的扩展性好适用性广，各种类型的项目都可以用性能较好，因为事件的异步本质，软件不易产生堵塞事件处理器可以独立地加载和卸载，容易部署 缺点
涉及异步编程（要考虑远程通信、失去响应等情况），开发相对复杂难以支持原子性操作，因为事件通过会涉及多个处理器，很难回滚分布式和异步特性导致这个架构较难测试 三、微核架构
微核架构（microkernel architecture）又称为"插件架构"（plug-in architecture），指的是软件的内核相对较小，主要功能和业务逻辑都通过插件实现。
内核（core）通常只包含系统运行的最小功能。插件则是互相独立的，插件之间的通信，应该减少到最低，避免出现互相依赖的问题。
优点
良好的功能延伸性（extensibility），需要什么功能，开发一个插件即可功能之间是隔离的，插件可以独立的加载和卸载，使得它比较容易部署，可定制性高，适应不同的开发需要可以渐进式地开发，逐步增加功能 缺点
扩展性（scalability）差，内核通常是一个独立单元，不容易做成分布式开发难度相对较高，因为涉及到插件与内核的通信，以及内部的插件登记机制 四、微服务架构
微服务架构（microservices architecture）是服务导向架构（service-oriented architecture，缩写 SOA）的升级。
每一个服务就是一个独立的部署单元（separately deployed unit）。这些单元都是分布式的，互相解耦，通过远程通信协议（比如REST、SOAP）联系。
微服务架构分成三种实现模式。
RESTful API 模式：服务通过 API 提供，云服务就属于这一类RESTful 应用模式：服务通过传统的网络协议或者应用协议提供，背后通常是一个多功能的应用程序，常见于企业内部集中消息模式：采用消息代理（message broker），可以实现消息队列、负载均衡、统一日志和异常处理，缺点是会出现单点失败，消息代理可能要做成集群 优点
扩展性好，各个服务之间低耦合容易部署，软件从单一可部署单元，被拆成了多个服务，每个服务都是可部署单元容易开发，每个组件都可以进行持续集成式的开发，可以做到实时部署，不间断地升级易于测试，可以单独测试每一个服务 缺点
由于强调互相独立和低耦合，服务可能会拆分得很细。这导致系统依赖大量的微服务，变得很凌乱和笨重，性能也会不佳。一旦服务之间需要通信（即一个服务要用到另一个服务），整个架构就会变得复杂。典型的例子就是一些通用的 Utility 类，一种解决方案是把它们拷贝到每一个服务中去，用冗余换取架构的简单性。分布式的本质使得这种架构很难实现原子性操作，交易回滚会比较困难。 五、云架构
云结构（cloud architecture）主要解决扩展性和并发的问题，是最容易扩展的架构。
它的高扩展性，主要原因是没使用中央数据库，而是把数据都复制到内存中，变成可复制的内存数据单元。然后，业务处理能力封装成一个个处理单元（prcessing unit）。访问量增加，就新建处理单元；访问量减少，就关闭处理单元。由于没有中央数据库，所以扩展性的最大瓶颈消失了。由于每个处理单元的数据都在内存里，最好要进行数据持久化。
这个模式主要分成两部分：处理单元（processing unit）和虚拟中间件（virtualized middleware）。
处理单元：实现业务逻辑虚拟中间件：负责通信、保持sessions、数据复制、分布式处理、处理单元的部署。 虚拟中间件又包含四个组件。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c3d8f6cc67f13d9bc48176800782669d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea00c201de2d440116a7afd1a2571166/" rel="bookmark">
			UTC时间是什么以及时间转换指令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		UTC（Coordinated Universal Time）是一种全球标准的时间标准，用于协调世界各地的时间。它是以原子钟为基础，通过国际原子时（International Atomic Time）进行精确测量和保持。
与其他时间标准相比，UTC 的特点是具有高度的精确性和稳定性，并且不受地理位置的影响。它是基于原子时钟的计量系统，通过不断校准和同步来确保时间的一致性。
UTC 广泛被用作全球范围内的协调时间，许多计算机和通信系统都以其为基准进行时间同步。在 UTC 时间中，一天被划分为24小时，每小时划分为60分钟，每分钟划分为60秒，与我们常见的时间单位制是一致的。
需要注意的是，UTC 是没有夏令时调整的，因此在应用时要考虑到所在地的时区和夏令时的影响，以便将 UTC 时间转换为当地时间。
指令：在 macOS 上将 UTC 时间转换为北京时间
date -r $((1693901411 + 28800)) "+%Y-%m-%d %H:%M:%S" # UTC时间是1693901411，加上八小时时差 $((1693901411 + 28800)) 将 UTC 时间戳加上 28800 秒（8小时），得到北京时间对应的时间戳。然后通过 "+%Y-%m-%d %H:%M:%S" 指定输出的日期时间格式。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be53e2bef131eebb421a3ad33b8584e7/" rel="bookmark">
			unity UniversalMediaPlayer 播放视频demo (附带插件)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		UniversalMediaPlayer 播放视频demo (附带插件)
demo只是一个简单的播放
可直接使用//自己扩展内容
下载地址：https://download.csdn.net/download/qq_31578301/20220404
20230921补充
1：检查是否安装VLC播放器
2：如在开发机上能播放，但部署机器上播放不了，检查是否安装vlc播放器并检查是否是6
4位的
有问题留言
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/356bf407d71344b18f596abd9c951172/" rel="bookmark">
			JS_H5关闭当前页面，微信浏览器关闭当前页面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 微信浏览器
WeixinJSBridge.call('closeWindow') 其它浏览器
window.close() 判断是否微信浏览器
var ua = window.navigator.userAgent.toLowerCase(); if (ua.match(/MicroMessenger/i) == 'micromessenger') { console.log('是微信浏览器'); } else { console.log('不是微信浏览器'); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5656a0f4e798e9eeb0e45302629f42b/" rel="bookmark">
			openEuler安装MySQL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、环境配置
1、基础环境
2、创建组、用户
3、准备目录
二、安装数据库
1、安装
2、编辑my.cnf
3、启动
本文中使用系统为：openEuler 22.03 (LTS-SP1)
一、环境配置 1、基础环境 #root用户下 #防火墙 systemctl stop firewalld systemctl disable firewalld ##防火墙仅安装测试或测试环境，实际是否关闭按相应使用环境进行设置 # selinux sed -i 's/SELINUX=enforcing/SELINUX=disabled/g' /etc/sysconfig/selinux #可用getenforce查看是否为disable 2、创建组、用户 groupadd mysql useradd -g mysql mysql passwd mysql #设置mysql用户密码 3、准备目录 mkdir -p /data/mysql/{data,log,tmp,run} chown mysql:mysql /data/mysql -R ########### 实际环境可挂载独立数据盘或采用逻辑卷 二、安装数据库 1、安装 yum源配置可参考之前文档 dnf list mysql-server #查看可安装的mysql版本 #安装 dnf install mysql-server rpm -qa|grep mysql-server #检查是否已安装 2、编辑my.cnf 步骤一 vim /etc/my.cnf 在文件中写入如下内容： [mysqld_safe] log-error=/data/mysql/log/mysql.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5656a0f4e798e9eeb0e45302629f42b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9438e7f2dceed7980dcb157ed15becec/" rel="bookmark">
			【Fmri入门学习01】将fMRI 4D-nii文件转化为3D-nii文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用mricron-dcm2nii完成nii格式转换 1.软件下载
mricron直接百度就可以下载，下载之后使用其中的dcm2niigui.exe做格式转换
2.具体操作
原本的nii数据为4D格式，要选择时间点，有时放在MATLAB里面操作会报错
第一步：选择输出格式为SPM8（3D NIFIT nii）
第二步：直接把要做格式转换的nii数据拖到dcm2nii中
直接点击ok后就可以转换了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22ccefa33eecfe0895505bc85eecaa4c/" rel="bookmark">
			VsCode 编辑代码 上一步 下一步 快捷键
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		个人经验：
我是按 Ctrl + Shit + P 调出搜索框，然后搜 go back.
看到个类似快捷键的东西：
我的是 Alt + 左右键，左退回，右下一步。方法应该是通用的吧。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e148dc3835d907bc249b7a4a800f5617/" rel="bookmark">
			安全基础 --- 过滤情况下实现弹窗展现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用mafia对弹窗进行过滤 maifa = (new URL(location).searchParams.get('mafia') || '1+1'); // 使用URL对象获取当前页面的URL，并从中提取参数“mafia”的值，如果URL中无“mafia”这个参数，则默认设置值为'1+1'(如果参数值存在为真，则将其赋值给maifa变量，否则将'1+1'赋值给mafia变量) mafia = mafia.slice(0,50); // 将这个参数截取0-50位 mafia = mafia.replace(/[\`\'\"+\-\!\\\[\]]/gi,'_'); // 查看是否匹配这样的正则，匹配的话，将其置为下划线 mafia = mafia.replace(/alert|confirm|prompt/g,'_'); // 如果有alert,confirm,prompt，也将其置为下划线 eval(mafia); // eval对mafia该函数求值并返回结果 PS：代码已分析
解析代码
从代码中可看出，过滤了(`)，(')，(")，(+)，(-)，(!)；以及 过滤了弹窗函数alert，confirm，prompt这三个。
PS：弹窗最常用的三个函数，为alert，confirm，prompt，都可实现弹窗
payload:alert(1337) payload:confirm(1337) payload:prompt(1337) 绕过限制 （1）Function Function构造函数创建一个新的Function对象。直接调用此构造函数可用动态创建函数，创建的函数只能在全局作用域中运行。
// Function实现弹窗 Function(/ALERT(1337)/.source.toLowerCase())() // 使用toLowerCase()方法将传递进来的ALERT(1337)参数转成小写，然后用最后的()执行 （2）eval 利用30进制来绕过。
parseInt(*string*,*radix*)解析一个字符并返回指定基数的十进制整数，radix是2-36之间的整数，表示被解析的字符串基数。
string：将被解析的值。若不是字符串，将其转为字符串（使用toString抽象操作）。radix(可选)：2-36，表示字符串基数。例：指定16表示被解析值是十六进制数。 parseInt('1234',5) // 将'123'看做5进制数，返回十进制数38 =》1*5^2 + 2*5^1 + 3*5^0 为何使用30进制？
parseInt('alert',30) a 11 t 30 --&gt; 0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F.... // alert中，最大的字母是t，t对应的数字是30，所以使用30进制 例：使用29进制，t无法转换 parseInt('alert',29) // 261984 261984.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e148dc3835d907bc249b7a4a800f5617/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7db308ff509d5fb7c1328727736338dd/" rel="bookmark">
			Idea配置JavaWeb项目 2023最新 (图文详细版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.新建项目 到这里就创建成功了，下面进行配置运行环境！ 2.配置运行环境 3.运行结果 到这里就配置成功了，开启你的JavaWeb之旅吧（求一个一键三连啦(*￣︶￣)） 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba059e3e1a4d1bee34d4a999adb0dd0a/" rel="bookmark">
			adb指令合集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		adb文件管理指令 1.复制设备里的文件到电脑
adb pull &lt;设备里的文件路径&gt; [电脑上的目录]
电脑上的目录 参数可以省略，默认复制到当前目录
例：adb pull /data/tsplogtool /home/jxq/文档/场景魔方
2.复制电脑里的文件到设备
adb push &lt;电脑上的文件路径&gt; &lt;设备里的目录&gt;
例：adb push 1.png /mnt/user/10/emulated/10/Movies
3.列出指定目录的内容
adb shell ls [options] &lt;directory&gt;
[options] 显示列表
无 列出目录下的所有文件和目录-a 列出目录下的所有文件(包括隐藏的)-i 列出目录下的所有文件和索引编号-s 列出目录下的所有文件和文件大小-n 列出目录下的所有文件及其 UID和 GID-R 列出目录下的所有子目录中的文件 切换到目标目录
adb shell cd &lt;directory&gt; 5.删除文件或目录
adb shell rm [options] &lt;files or directory&gt;
[options] 显示列表
无 删除文件-f 强制删除文件，系统不提示-r 强制删除指定目录中的所有文件和子目录-d 删除指定目录，即使它是一个非空目录-i 交互式删除，删除前提示 创建目录
adb shell mkdir [options] &lt;directory-name&gt; 无 创建指定目录-m 创建指定目录并赋予读写权限-p 创建指定目录及其父目录 7.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba059e3e1a4d1bee34d4a999adb0dd0a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15180695ae7651f88a4324246d419c0e/" rel="bookmark">
			Git仓库简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、工作区、暂存区、仓库 工作区：电脑里能看到的目录。
暂存区：工作区有一个隐藏目录.git，是Git的版本库，Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。
仓库：远程服务器中的项目。
2、git版本控制 git版本控制一般有两个命令 reset 和 revert。reset 代表将当前节点“销毁”（回退，节点还存在），就像不存在一样；revert 代表创建一个新的节点，其中记录我要删除当前节点。其中reset 中有 三个参数需要注意：
--mixed 默认参数，重置暂存区的文件与上一次的提交(commit)保持一致，工作区文件内容保持不变。 --soft 回退到某个版本。 --hard 撤销工作区中所有未提交的修改内容，将暂存区与工作区都回到上一次版本，并删除之前的所有信息提交。 执行 git reset HEAD
执行 git revert HEAD
撤销修改： 对文件做了修改，现在需要撤销修改：
git restore &lt;文件名&gt; 或者 git checkout -- 文件名 如果文件已经add，但还没commit，可以使用以下命令，撤销add，恢复到上一步状态：
"git restore --staged &lt;file&gt; 或者 git reset HEAD 文件名 如果已经commit，需要删除文件，
1、被提交到仓库的某个文件需要删除，可以使用 git rm 命令： git rm &lt;file&gt; git commit -m "" 2、如果只想从暂存区删除文件，本地工作区不做出改变，可以： git rm --cached &lt;file&gt; 3、分支管理 3.1 创建/删除分支 一般 master 分支用于发布版本，开发都是其他他分支上进行，也会存在一些 bugFix 分支，feature 分支用于开发未来的功能。创建分支有以下三种命令：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/15180695ae7651f88a4324246d419c0e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/643526edc41472d31e5ee4572fe8481c/" rel="bookmark">
			获取剪贴板内容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;u-popup :show="show" mode="center" @close="close"&gt; &lt;view style="max-width: 600rpx;max-height:1000rpx;" class="text-center"&gt; &lt;text&gt;{{clipboard}}&lt;/text&gt; &lt;/view&gt; &lt;/u-popup&gt; clipboard:'',
show:false,
getClipboardContent() { const observer = new MutationObserver(() =&gt; { if (navigator.clipboard.readText) { this.show=true const content = navigator.clipboard.readText(); content.then(res=&gt;{ // console.log("Clipboard content:", res); this.clipboard=res }) } }); observer.observe(document, { characterData: true, subtree: true, }); }, close(){ this.show=false }, 使用onLoad调取方法
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7675d0e1df7f9482665a747fbfe63b33/" rel="bookmark">
			FFmpeg采集摄像头图像并推流至RTSP/RTMP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在很典型的一种应用场景：把流推送到RTSP、RTMP、HLS服务器，由服务器转发给其他用户观看。很多开发者也是调用FFmpeg API来实现推流的，用FFmpeg 做一个推流器很简单，调用流程跟输出文件的基本相同，稍微修改就可以做出一个采集+编码+推流的软件。这里，我先假设读者已经会用FFmpeg API保存或录制文件，但没有实现过推流功能，我将给大家说一下做推流跟录制文件的区别，还有说一下要注意的几个问题，希望能帮助大家在开发推流功能时减少一些问题的出现。
首先，做推流和录制文件都需要调用到封装器对象的接口，我们需要定义一个封装器（或叫混合器）：
AVFormatContext* m_outputAVFormatCxt;
创建封装器对象，根据输入的协议类型生成对应的封装器。
比如，对于RTSP，我们生成如下的推流封装器：
res = avformat_alloc_output_context2(&amp;m_outputAVFormatCxt, NULL, "rtsp", m_outputUrl.c_str());
对于RTMP，生成封装器的代码如下：
res = avformat_alloc_output_context2(&amp;m_outputAVFormatCxt, NULL, "flv", m_outputUrl.c_str());
其中，上面的m_outputUrl是推流地址。
然后，向封装器添加要发送的流（视频、音频），设置每个流的属性。假如我们要推送的流来源于一个文件，那就要先把文件的流枚举出来，获得每个流的信息，然后把这几个流“插入”到封装器里面，这样封装器才能识别这些流的格式。下面是从文件提取流的信息并添加到封装器的代码：
AVOutputFormat* fmt = m_outputAVFormatCxt-&gt;oformat; // fmt-&gt;video_codec = AV_CODEC_ID_H264; //	fmt-&gt;audio_codec = AV_CODEC_ID_AAC; for (int i = 0; i &lt; m_inputAVFormatCxt-&gt;nb_streams; i++) { AVStream *in_stream = m_inputAVFormatCxt-&gt;streams[i]; if(in_stream-&gt;codec-&gt;codec_type != AVMEDIA_TYPE_VIDEO &amp;&amp; in_stream-&gt;codec-&gt;codec_type != AVMEDIA_TYPE_AUDIO) //忽略掉不是视频和音频的流 { continue; } AVStream *out_stream = avformat_new_stream(m_outputAVFormatCxt, in_stream-&gt;codec-&gt;codec); if (!out_stream) { TRACE("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7675d0e1df7f9482665a747fbfe63b33/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ef40ebbe52c639af9bdce655ae1b2be/" rel="bookmark">
			Redis数据库（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		不能使用Save,应为会阻塞redis中的所有，全都写入到rdb文件中，有严重的时间问题
一般来说使用Bgsave
使用lastsave返回上一次的时间戳，并且通过data -d @那个时间戳进行时间反转成我们可以认识的时间格式
对于RDB和aof两种操作来说，可以一起使用，对于RDB的作用可以类似于版本保存，留着做备份用，而aof这类可以当作保留当前状态，实时的那种状态，两者结合起来可以相互补充，应为RDB会比较快，但是数据不够全面，aof可以弥补数据全面的问题，但是对于存储的空间要求很大，增加到一定级别时，会对于性能产生较大的影响，这时，使用rdb进行部分保存会比较好，当然aof里面也有对于指令进行压缩的功能，但是实际上来说，效果可能并不是特别的好，在某些时候，rdb可以做的比较好
对于rdb如何关闭，一般是在配置文件中，对于save ""这一项的注释解开，然后对于aof这个来说
需要设置appendonly no
应为aof的优先级比rdb的优先级更高，两者都开启的状态下，优先执行aof，如果
对于内存只想开启高性能缓存模式，不受redis的打扰，那就两者都进行关闭
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c88e372f1a52746dc2d295186cf77a6/" rel="bookmark">
			AOF的相关配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Redis6保存文件的位置与RDB保存文件的位置一样，都是通过Redis.conf配置文件的dir配置
BASE和INCR表示基础和增量文件，
关闭rdb使用save ""
关闭aof使用appendonly no
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b205ba7eaed6308ee0f6ff334aca4616/" rel="bookmark">
			无法打开VS code解决办法之一
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记录一个VS code沙雕问题
vs code 的默认插件安装目录是一个快捷方式(也有可能我之前因为硬盘没空间移动Visual studio的所有Nuget包的时候建了一个快捷方式有关)，但是VS code默认安装或生成的快捷方式指向路径不对，然后就打不开，也没弹窗
解决办法，打开cmd，把vs code的code.exe拖进去运行，看他返回什么报错，比如我这里就是一个stupid mistake
我自己给他新建一个快捷方式就行了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fff5b33aafe3e506800a37d8b044368c/" rel="bookmark">
			大语言模型处理时间序列：Time-Series Forecasting with Pre-Trained LLMs
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本期将继续介绍一篇利用大语言模型进行时间序列预测任务的工作。文章下载地址为https://arxiv.org/pdf/2308.08469.pdf 。
1. 前期提要 大家都知道预训练大型语言模型（LLMs）具有强大的表示学习能力和少样本学习，但要利用LLM处理时间序列，需要解决两个关键问题：
1） 如何将时间序列数据输入LLMs： 为了将时间序列输入到LLM，需要对齐进行tokenize，近期的研究工作（Zhang等人，2023年）强调通过‘’patching‘’的方式对时间序列、图像、音频等各类数据进行torkenize都是非常有效的。PatchTST方法（这个后期博文会进行介绍）基于通道独立性的思想将多变量时间序列数据视为多个单变量时间序列，将单个序列划分成不同的patch。而一些基于transformer的时间序列预测相关的工作强调了整合时间信息可以增强模型的预测性能，因此本篇文章一种新方法，使用patch和通道独立思想的同时对时序信息进行整合。
2） 如何在不破坏LLM固有特性的情况下对其进行微调使其能够适配时间序列任务： 构建像InstructGPT和ChatGPT这些对话系统时，通常利用有监督微调将模型与基于指令的数据进行对其，使得大模型熟悉数据的格式和特性。基于此，本篇文章提出了一种两阶段微调方法，首先通过监督微调将模型与时间序列的特性进行对其，引导LLM适应时间序列，接下来以下游预测任务为导向进一步对模型进行微调，从而保障不破坏语言模型固有特性的基础上使得模型能够更好地适配配各类不同域的数据（ Cross-Modality Knowledge Transfer）及不同的下游任务（In-Modality Knowledge Transfer）。
2. 方法介绍 给定完整且均匀采样的多变量时间序列，利用长度为的窗口以步长1进行移动，将数据分成不同的窗口数据，其中每个窗口中数据可进一步分为历史数据窗口和未来数据窗口。对于每个时间步t， 代表一个M维向量。此方法的目标是利用过去数据来预测未来数据，以GPT-2为backbone，下面具体此方法的训练和微调步骤
Instance Normalization： 这里作者采用了标准的instance noramlization，即在对于每个窗口内序列的各个序列，根据其均值和标准差进行z-score标准化。
Patching and Channel-Independence： 接下来，采用patchTST相同的思想，首先将多变量序列视作多个单个变量序列（即认为通道间相互独立）由单个模型进行处理。相比于通道混合的方式来提取通道间的相关性，patchTST通过不同序列共享模型参数的方式来捕捉通道间的关联，能够避免过拟合。然后，将每个序列分成指定长度的多个patch作为llm的基础分析单元token，这些patch可以是相互重叠的，也可以为不重叠的，具体可根据数据输入长度调整。patching的操作，在增大输入数据历史时间跨度的同时并不会增加输入token的长度，能够有效提升效率。
Three Encodings： 获得上述的基础token后，有必要进一步对其进行编码，使其变成LLM能够兼容的形式，文中采用的是一维卷积层，位置编码采用的是与NLP模型中的标准形式（关于时间序列位置编码下次会专门出一篇博文来进行介绍）。相比于NLP模型，获取时间序列数据token时通常面临两个挑战：1）每个分段涵盖多个时间戳，2）每个时间戳都带有各种时间属性，如分钟、小时、星期几、日期和月份。对于第一个问题，文章将时间戳引入token中，针对于第二个问题，借鉴NLP中构建token方式，论文为分钟/小时/日期/月份等时间相关属性构建了可训练和查找的embedding，并将各个属性的embedding相加作为最终的temporal embedding，保存patch内的时间相关信息。最终，每个patch对应的最终token由三部分组成：经过一位卷积层的token+position embedding+temporal embedding。
Pre-Trained LLM and PEFT： 论文使用了GPT-2作为backbone。为了保留模型的基本知识，论文冻结了大部分参数，特别是Transformer模块内的多头注意力和前馈层所涉及的参数。论文融合了两种参数高效微调技术（PEFT），层归一化调整（ Layer Normalization Tuning ）和 LoRA（LowRank Adaptation）来提高模型面对未知数据的泛化性能和灵活性。对于可训练的部分参数，论文采用了两阶段微调的方式。1）Supervised Fine-tuning: Autoregressive 首先第一阶段以自回归形式进行有监督微调，来使得模型适配时序数据，这是因为GPT-2是一个因果语言模型（这里的因果是指以自回归的形式，仅利用历史数据进行预测，并不会采用未来的数据）。这样既保留了语言模型本身的知识，又使模型能够适应时间序列数据。在这个阶段模型输出为patch形式，这里可以利用一个线性层来改变输出的维度。2）Downstream Fine-tuning: Forecasting 接下来，针对下游预测任务进行微调，文章在前部分迭代中采用线性微调策略（仅调整最后的线性输出层），而在后一阶段的迭代中采用完全微调的策略（调整所有可训练参数）。这个阶段的模型输出也位patch形式，可以将其展平后再输入线性层获取指定维度。
3. 实验效果 论文主要利用了如下五个数据集来比较所提方法与现有sota算法在长序列预测和少样本预测任务上的性能，具体参数设置细节大家可以去看论文，目前好像并未找到论文代码。
推荐阅读：
我的2022届互联网校招分享
我的2021总结
浅谈算法岗和开发岗的区别
互联网校招研发薪资汇总
2022届互联网求职现状，金9银10快变成铜9铁10！！
公众号：AI蜗牛车
保持谦逊、保持自律、保持进步
发送【蜗牛】获取一份《手把手AI项目》（AI蜗牛车著）
发送【1222】获取一份不错的leetcode刷题笔记
发送【AI四大名著】获取四本经典AI电子书
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3805131cc0c37bcc123d9ce290080753/" rel="bookmark">
			python爬虫爬取电影数据并做可视化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		思路： 1、发送请求，解析html里面的数据
2、保存到csv文件
3、数据处理
4、数据可视化
需要用到的库：
import requests,csv #请求库和保存库 import pandas as pd #读取csv文件以及操作数据 from lxml import etree #解析html库 from pyecharts.charts import * #可视化库 注意：后续用到分词库jieba以及词频统计库nltk 环境： 解释器: python 3.10.5
编辑器：VsCode -jupyter-notebook
使用ipynb文件的扩展名 vscode会提示安装jupyter插件
一、发送请求、获取html #请求的网址 url='https://ssr1.scrape.center/page/1' #请求头 headers={ "User-Agent": "Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.0.0 Safari/537.36" } #发起请求，获取文本数据 reponse=requests.get(url,url,headers=headers) print(reponse) 二、使用xpath提取html里面的数据并存到csv #创建csv文件 with open('电影数据.csv',mode='w',encoding='utf-8',newline='') as f: #创建csv对象 csv_save=csv.writer(f) #创建标题 csv_save.writerow(['电影名','电影上映地','电影时长','上映时间','电影评分']) for page in range(1,11): #传播关键1到10页的页数 #请求的网址 url='https://ssr1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3805131cc0c37bcc123d9ce290080753/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b803b91daec81f40b0e3db8ce5d55dc/" rel="bookmark">
			联合关系抽取论文（一）——TPLinker
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TPLinker: Single-stage Joint Extraction of Entities and Relations Through Token Pair Linking——COLING2020 论文代码链接解决了什么问题关系重叠问题暴露偏差问题 TPLinger介绍基础方法提出的标注框架解码过程 TPLinker的实验结果总结 论文代码链接 论文链接
代码链接
paperwithcode
解决了什么问题 关系重叠问题 Normal：两个实体一个关系，正常且普通SEO（SingleEntityOverlap）：一个实体与其他实体存在关系EPO（EntityPairOverlap）：一对实体存在多个关系
暴露偏差问题 暴露偏差问题指的是在关系抽取任务中，训练阶段输入的是gold entity(ground truth entity)，而在预测阶段是实体识别模型预测的实体。
例如基于解码器的方法，在训练时，使用真值token作为上下文。而在推理时，模型生成的前一个token作为上下文输入。基于分解的方法将 gold实体(ground truth entity)作为特定的输入，在训练过程中指导模型提取对象实体和关系，而在推理时，输入的核心实体由模型给出。 导致训练和推理之间存在差距。
TPLinger介绍 基础方法 TPLinker整体标注Tag框架是基于token pair进行的，其本质上就是一个span矩阵。这种方法也可以成为Multi-Head方法。
Multi-Head方法重点在于构建一个==[batch_size, seq_len, seq_len, hidden]==维度的矩阵（后续成为table），相当于每一个token embedding都逐个乘以sequence中的其他token embedding，得到token与其他所有token之间一种交互特征，每一个单元格都可以代表一个token pair，进而通过其他方提取实体关系及关系类型。
提出的标注框架 TPLinker将联合抽取任务转化为Token Pair Linking问题。给定一个句子，两个位置p1，p2和一个特定的关系r，TPLinker回答三个Yes / No伪问题：
" p1和p2分别是否是同一个实体的起点和终点? "，
" p1和p2分别是否是两个具有r关系的实体的起点? "，
" p1和p2分别是否是两个具有r关系的实体的终点? "。
为此设计了一个为每个关系标注3个token链接矩阵的握手标注方案来回答上述3个问题。我们在上述提到的table为基础，构建了如下的标注框架。
紫色标注：EH to EH，表示一个实体的头尾。如两个实体：New York City:M(New, City) =1; De Blasio:M(De, Blasio) =1。红色标注：SH to OH，表示subject和object的头部token间的关系。如下图中三元组(New York City, mayor,De Blasio)，标注方式就是红色(New, De)=2。蓝色标注：ST to OT，表示subject和object的尾部token间的关系。如下图中三元组(New York City, mayor,De Blasio)，标注方式就是蓝色(City, Blasio)=2。 其中的1和2的区别就是关系方向的问题。我们看到在下三角矩阵当中也有1存在，文章为了为防止稀疏计算，下三角矩阵不参与计算；虽然实体标注不会存在于下三角矩阵种，但关系标注是会存在的。如果关系存在于下三角，则将其转置到上三角，并有“标记1”变为“标记2”。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b803b91daec81f40b0e3db8ce5d55dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6b7acdc0c802f3070c1146f6765bfc8/" rel="bookmark">
			Linux命令:ssh命令（远程登录）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ssh命令 远程登录
1、查看SSH客户端版本 有的时候需要确认一下SSH客户端及其相应的版本号。使用ssh -V命令可以得到版本号。需要注意的是，Linux一般自带的是OpenSSH: 下面的例子即表明该系统正在使用OpenSSH：
$ ssh -V OpenSSH_3.9p1, OpenSSL 0.9.7a Feb 19 2003 下面的例子表明该系统正在使用SSH2：
$ ssh -V ssh: SSH Secure Shell 3.2.9.1 (non-commercial version) on i686-pc-linux-gnu 2、连接到远程主机： 命令格式 ：
ssh name@remoteserver #或者 ssh remoteserver -l name 说明：以上两种方式都可以远程登录到远程主机，server代表远程主机，name为登录远程主机的用户名。
3、连接到远程主机指定的端口： 命令格式：
ssh name@remoteserver -p 2222 #或者 ssh remoteserver -l name -p 2222 说明：p 参数指定端口号，通常在路由里做端口映射时，我们不会把22端口直接映射出去，而是转换成其他端口号，这时就需要使用-p端口号命令格式。
4、通过远程主机1跳到远程主机2： 命令格式：
ssh -t remoteserver1 ssh remoteserver2 说明：当远程主机remoteserver2无法直接到达时，可以使用-t参数，然后由remoteserver1跳转到remoteserver2。在此过程中要先输入remoteserver1的密码，然后再输入remoteserver2的密码，然后就可以操作remoteserver2了。
5、通过SSH运行远程shell命令： 命令格式：
ssh -l name remoteserver ‘command' 说明：连接到远程主机，并执行远程主机的command命令。例如：查看远程主机的内存使用情况。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d6b7acdc0c802f3070c1146f6765bfc8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b099876dc844db36f51c591941b08699/" rel="bookmark">
			java: Annotation processing is not supported for module cycles.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java: Annotation processing is not supported for module cycles. Please ensure that all modules from cycle [xxx,xxx] are excluded from annotation processing
模块循环是指两个或多个模块之间存在相互依赖的情况。
解决办法：消除模块循环依赖
去里面把互相依赖的包删掉
解决报错
当然后面发现依赖原因是我建包的时候就建错地方了才发生了依赖循环
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/85/">«</a>
	<span class="pagination__item pagination__item--current">86/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/87/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>