<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2a453841c54513025f7c670d488a861/" rel="bookmark">
			端口漏洞复习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近两周要回学校，无聊把端口漏洞过一遍吧，这对于以后的安全运维是必备知识啊。 端口号端口说明攻击技巧21/22/69ftp/tftp：文件传输协议爆破\嗅探\溢出\后门22ssh：远程连接爆破OpenSSH；28个退格23telnet：远程连接爆破\嗅探25smtp：邮件服务邮件伪造53DNS：域名系统DNS区域传输\DNS劫持\DNS缓存投毒\DNS欺骗\利用DNS隧道技术刺透防火墙67/68dhcp劫持\欺骗110pop3爆破139samba爆破\未授权访问\远程代码执行143imap爆破161snmp爆破389ldap注入攻击\未授权访问512/513/514linux r直接使用rlogin873rsync未授权访问1080socket爆破：进行内网渗透1352lotus爆破：弱口令\信息泄漏：源代码1433mssql爆破：使用系统用户登录\注入攻击1521oracle爆破：TNS\注入攻击2049nfs配置不当2181zookeeper未授权访问3306mysql爆破\拒绝服务\注入3389rdp爆破\Shift后门4848glassfish爆破：控制台弱口令\认证绕过5000sybase/DB2爆破\注入5432postgresql缓冲区溢出\注入攻击\爆破：弱口令5632pcanywhere拒绝服务\代码执行5900vnc爆破：弱口令\认证绕过6379redis未授权访问\爆破：弱口令7001weblogicJava反序列化\控制台弱口令\控制台部署webshell80/443/8080web常见web攻击\控制台爆破\对应服务器版本漏洞8069zabbix远程命令执行9090websphere控制台爆破：控制台弱口令\Java反序列9200/9300elasticsearch远程代码执行11211memcacache未授权访问27017mongodb爆破\未授权访问
转载于:https://www.cnblogs.com/itworks/p/7476169.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2acdeac6bb6970507216365767ec030e/" rel="bookmark">
			Pycharm调用Pyspark API配置，小记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、pyspark安装
参见
http://blog.csdn.net/zjjfjcs/article/details/77748726 注意： 需要配置环境变量： $ sudo vim /etc/profile
在文件末尾添加：
export SPARK_HOME=$YOUR_SPARK_HOME #$YOUR_SPARK_HOME是spark的安装路径，如/local/spark-2.2.0
export PATH=$SPARK_HOME/bin:$PATH
2、在sys.path中添加pyspark路径
&lt;1&gt;方法一：程序中动态导入
import sys sys.path.add('$YOUR_SPARK_HOME/python') 这种方法在程序运行完后失效，不同的py文件中也不能使用 &lt;2&gt;方法二：设定为默认路径
（此方法参考网址http://blog.sina.com.cn/s/blog_59ba44680100z0mt.html）
在/usr/local/lib/python2.7/dist-packages中找到以.pth结尾的任意文件，在末尾加入路径即可：
如：在easy-install.pth文件结尾加入：
$YOUR_SPARK_HOME/python 重启pycharm即可。 3、测试
打开Pycharm创建一个py程序：
内容如下：
from pyspark.sql import SparkSession spark = SparkSession.builder \ .master("local") \ .appName("Word Count") \ .config("spark.some.config.option", "some-value") \ .getOrCreate() 执行结果如下： 说明配置成功！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba688d9f0dbdd4f95d6cd9236814ef86/" rel="bookmark">
			C# WinForm Label 控件拓展—变色字体、超链接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：
以前做项目需要实现在文本类控件中加入超链接文字段的功能，在网上查了不少资料基本没有找到比较理想的实现方法，最后无奈只好自己实现了...
需求：
拓展Label控件，使其文本中的文字可以有多种颜色，添加下划线、做成超链、点击变色。变色文字的格局（间距、字体大小、换行）必须与原来一致。（注意做出改变的是部分文字，非整个文本）效果图如下：
图1
图2 图3 图1为WinForm原生Label的预览效果，图2、图3为拓展后的预览效果。 实现原理：
（1）准确测量文字区域
需要准确测量出文字段的大小才能保证文字格局的不变，GDI+已经自带了这种功能，可以得到指定文字段的System.Drawing.Region对象。但直接通过System.Drawing.Region对象获取的数据进行绘制的效果不太理想（未深入尝试），所以才有了（2）。
（2）异或刷前景
改变局部文字颜色的一种方法：①计算异或相关的颜色值，对局部区域做一次异或填充②绘制所有文字 ③使用与第一步同样的颜色对局部区域再做一次异或填充。
实现上述方法的条件：已知填充的区域、能控制整体文字绘制。
（3）开窗
底部加一层Label，在底部Label做变色，添加下划线效果，上层Label对变色部分开窗。--不算是个好方法，下滑线只能全局设置。
源码：
https://download.csdn.net/download/u013113678/32897102
例子:
/// /// 应用程序的主入口点。 /// [STAThread] static void Main() { string exaple = @"It's a truth universally acknowledged, that a single man in possession of a good fortune must be in want of a wife. 凡是有钱的单身汉，总想娶位太太， 这已经成了一条举世公认的真理。"; Form form = new Form(); var cLabel = new ColorLabel(); Font font = new System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba688d9f0dbdd4f95d6cd9236814ef86/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b2e28464669af934dab5d91dd198a69/" rel="bookmark">
			vortex-vwload
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 用法
Usage: vwload [options] database file ...
Options:
-a --attributes attr,... List of attributes to load (default: all)
-B --rollback on/off Roll back on failure
-c --cluster Cluster mode
-C --charset s Input character set (default: no conversion)
-d --dateformat format|attr=format,...
Set date format for attribute
-e --escape c Escape character to use (default: none)
-E --escapes Interpret data escape sequences
-f --fdelim c Field delimiter to use (default: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b2e28464669af934dab5d91dd198a69/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9fca0fbc7d9e54b62b6e91355e6227d3/" rel="bookmark">
			hive INSERT OVERWRITE table  could not be cleaned up.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		create table maats.account_channel ROW FORMAT DELIMITED FIELDS TERMINATED BY '^' STORED AS TEXTFILE as select distinct a.account,b.channel from maats.register a join maats.install b on a.device = b.device; INSERT OVERWRITE table maats.account_channel select distinct a.account,b.channel from maats.register a join maats.install b on a.device = b.device; hvie 1.1 第一次在create table 时没有加 STORED AS TEXTFILE 结果 INSERT OVERWRITE table 命令就只能执行一次,后面就报错,lz 就很奇怪,因为之前是可以的,记得hive默认是textFile格式的文件, beeline中可以,但是 hive -e 不可以, 转载于:https://www.cnblogs.com/rocky-AGE-24/p/7470825.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8b724fee6d5919ddb80da58a02e2a7b/" rel="bookmark">
			2.5 unity实战 飞机大战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Unity飞机大战 一,场景布置 1,模拟飞行场景, 做一个地图的循环轮播,这里需要两张地图进行循环轮播,这样视觉不容易看出变化. a,设置天空盒: Window-lighting-Setting-skybox material选择 b,灯光调控(有时候图片背景较暗,物体在上面显示有些看不清楚,这时就需要调控灯光了) 点击Directional Light -更改Mode-选择realtime c,控制地图轮播(在外面调控地图播放速度也可以内部直接赋值) public class BackGroundScroll : MonoBehaviour { float bgSpeed=2f; //背景的速度 float bgMaxSize=30f; //背景移动的最大距离 Vector3 bgStartPosition; //初始位置 private void Start() { bgStartPosition = transform.position; //将物体的位置作为初始位置 } private void Update() { //设置一个位移距离,使用Mathf.Repeat()重复生成 //函数Mathf.Repeat(t : float, length : float),循环数值t，0到length之间。 //t值永远不会大于length的值，也永远不会小于0。 //数值从0+t一直加到length.循环重复.如果t为负数,length不断减少,减到0,重复. float bgNewPositiopn = Mathf.Repeat(-Time.time * bgSpeed, bgMaxSize); //相对位移,位移方向就是z轴,不断赋值Position. transform.position = bgStartPosition + bgNewPositiopn * Vector3.forward; } } 二,设置玩家飞机 1,飞机位移以及相关知识点 a,飞机位移 float playerSpeed=6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b8b724fee6d5919ddb80da58a02e2a7b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/081d0fb86b4ffb6dbb06b59c9467e95e/" rel="bookmark">
			在Linux 或mac Bash &amp; zsh 通过上下键快速查找历史命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1 首先在该用户家目录（home directory）下新建一个 .inputrc 文件，并在其中写入以下配置，如下：
root@tenggeer ~]# cat .inputrc “\e[A”: history-search-backward “\e[B”:history-search-forward set show-all-if-ambiguous on set completion-ignore-case on
如果以上做法失败，则可以参考stackoverflow: How do I change bash history completion to complete what’s already on the line? 在~/.bashrc 中添加如下内容（注意空格）：
if [[ $- == *i* ]] then bind '"\e[A": history-search-backward' bind '"\e[B": history-search-forward' fi 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95c3bce54ab893746885fdd57878ba67/" rel="bookmark">
			七层登陆
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习完了三层结构后我就想一下子去完成机房的个人重构，然而在我准备完成的时候我就遇到了一个问题，那就是登陆过程中的所需要的七层结构，然后我就在网上查询于是就敲出了我自已的七层登陆，然后我就总结了一下。话不多说请先看图！ 七层登陆UML图： 具体分解 Entity层 主要的作用是作为封装数据，为其他层调用其数据！
DAL: sqlHelper层： IDAL: Factory: BLL: Facade: UI: 配置文件： 最后基本上是通过我这么敲打然后根据UML中 的逻辑关系进行引用，最后成功的登陆了！ 于是我的七层登陆完成了！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f44a9b37aa041bc61730878549e93483/" rel="bookmark">
			Chang the PATH
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Change the PATH root@ld-pc:/home/ld# echo $PATH /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/opt/jdk1.8.0_131/bin root@ld-pc:/home/ld# vim /etc/environment root@ld-pc:/home/ld# 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5bf1d62c63e86cf33a876b1415127627/" rel="bookmark">
			su: Authentication failure
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ld@ld-pc:~$ su Password: su: Authentication failure ld@ld-pc:~$ sudo passwd root [sudo] password for ld: Enter new UNIX password: Retype new UNIX password: passwd: password updated successfully ld@ld-pc:~$ su Password: root@ld-pc:/home/ld# ls 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5dcd79c7beefef37a24d9b8a86fc3c9/" rel="bookmark">
			问题：在Keil vision5.18调试STM32代码usart.c时，提示如下错误：
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 compiling usart.c... ..\SYSTEM\usart\usart.c(41): error: #260-D: explicit type is missing ("int" assumed) _sys_exit(int x) ..\SYSTEM\usart\usart.c: 0 warnings, 1 error 分析：
#if 1 #pragma import(__use_no_semihosting) Struct __FILE { int handle; }; FILE __stdout; _sys_exit(int x) { x = x; } int fputc(int ch, FILE *f) { while((USART1-&gt;SR&amp;0X40)==0); USART1-&gt;DR = (u8) ch; return ch; } #endif 定义 _sys_exit(int x) 以避免使用半主机模式,函数没有返回类型，假定其返回类型为int，可以写为void void _sys_exit(int x) ，否则编译器会默认为返回int类型，故会出现上述警告。 解决办法：应该写成void _sys_exit(int x) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36e06a6f2bcf48823f406d6713a41dd1/" rel="bookmark">
			《对软件工程课程的期望》
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自我介绍：
各位老师，同学大家好。我是软件三班 李德帅，大三了我希望通过这学期学习软件工程这门课，拓展丰富自己的知识领域，提升自己的对软件编程的思维和素质，并且还要在与小组成员在今后的研发工程过程中锻炼自己谈话水平，对事物的处理水平和提高自己的团队意识，希望今后的工程规划中能够在老师的帮助下获得成长！
我的目标：
每周在学习软件工程和与队员们相处10个小时左右，好好攻克自己对学习的傲慢性格
我的问题：
1.软件工程的目标是最小的成本、最高的质量、最短的开发时间开发软件产品，不知道这样对于我们即将毕业的大三学生来说，如果以后自己组成团队在这条路上能走的很远么？
2.软件工程团队最核心的是代码的编译人员，是否所得的工资也相对会比较多？
3.对于软件工程，软件开发这方向我对未来还是很迷茫，现在年轻人都从事IT行业，我想知道软件工程未来前景怎么样？
4.代码真的要做到完美没有BUG吗？
5.我现在的目标是对软件工程这方面获得更多的认知，我想听听老师的建议，多学习哪方面的语言，或者哪种语言在软件工程中最为常用？
实践项目完成后学习到的能力的预期：
通过上一学期软件工程的学习，使我了解到了很多以前都不知道的知识。软件工程概述、软件开发过程模式等等，这些让我对软件工程这门课有了新的认识。
对项目课程的期望：
马上就要步入社会了，我希望通过学习这门课的同时，学习与同学、组员、老师领导沟通与交流，提高自己的社交和处理事务的能力。
对项目的愿景规划：
有始有终，善始善终
做好每一次项目，处理好每一串代码，维护好每一位组员关系。
转载于:https://www.cnblogs.com/lds18341211674/p/7460053.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4ef99e08a5437dbbbf3ecf2d8db764e/" rel="bookmark">
			datastage-报错收集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题一：
ODBC_Connector_21: Schema reconciliation detected a size mismatch for column longdrive_time. When reading database column DFLOAT into column SFLOAT, truncation, loss of precision, data corruption or padding can occur. (CC_DBSchemaRules::reportSizeMismatch, file CC_DBSchemaRules.cpp, line 1,768)
解决方法：源输入的column longdrive_time 精度转换为sfloat， 源数据库转换数据类型的函数为flat4（） 降低精度
问题二:
Transformer_2: Error when checking operator: Could not find input field "longdrive_time".
解决方法：抽取数据的控件中，1，缺该字段 2，字段命名和column列表中的字段名不一致
问题三:
ODBC_Connector_21,0: Execution failed on statement
解决方法：该控件中的SQL语法有错误
问题4：oracle_dwstage,0: The OCI function OCIStmtExecute returned status 1. Error code: 12899, Error message: ORA-12899: value too large for column.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c4ef99e08a5437dbbbf3ecf2d8db764e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d1feae23212df2002d0985f5240f5a4/" rel="bookmark">
			Python 3实现k-邻近算法以及 iris 数据集分类应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 这个周基本在琢磨这个算法以及自己利用Python3 实现自主编程实现该算法。持续时间比较长，主要是Pyhton可能还不是很熟练，走了很多路，基本是一边写一边学。不过，总算是基本搞出来了。不多说，进入正题。
1. K-邻近算法 1.1 基本原理 k近邻法(k-nearest neighbor, k-NN)是1967年由Cover T和Hart P提出的一种基本分类与回归方法。它的工作原理是：存
在一个样本数据集合，也称作为训练样本集，并且样本集中每个数据都存在标签，即我们知道样本集中每一个数据与所属分
类的对应关系。输入没有标签的新数据后，将新的数据的每个特征与样本集中数据对应的特征进行比较，然后算法提取样本
最相似数据(最近邻)的分类标签。一般来说，我们只选择样本数据集中前k个最相似的数据，这就是k-近邻算法中k的出处，
通常k是不大于20的整数。最后，选择k个最相似数据中出现次数最多的分类，作为新数据的分类。
1.2 一个例子 先来看一个图： 在这个图里面，我们可以看到有第三种颜色标记的标签，蓝色正方形，红色三角形以及一个未知类型的绿色原点。那么如何判断这
个绿色点是属于蓝色家族的还是红色家族的呢？
邻近的思想就是计算这个绿色的点分别到它附近的点的距离，距离近就判定属于这个类型，那么K-邻近就是让待分类的这个点与所
有的已经分类点的距离，然后选取K个点，统计待分类的这个绿色点属于哪个类别的数量比较多，就最终判定这个点属于哪一个。
再回到图，首先是K=3，可以看到实线里面有两个红点，一个蓝点，那么判定这个绿家伙属于红色的三角形类型。接着，选取了近
距离绿色点最近的5个点，这时，会发现，蓝色系占得更多，所以，判定这个绿家伙是属于蓝色正方形的类型。
从这个例子可以看出来，K-邻近的几个基本关键点有：
点之间的距离计算
欧式距离： d12=∑i=1n(x1i−x2i)−−−−−−−−−−−√ 曼哈顿距离：
两个向量 a(x11,xx12,⋯,x1n) 与 b(x21,xx22,⋯,x2n) 的曼哈顿距离为： d12=∑k=1n|x1k−x2k| 其他 参考http://www.cnblogs.com/xbinworld/archive/2012/09/24/2700572.html
里面有着更加详细的关于距离的介绍。
距离排序 在这个计算的过程中，需要将最终的计算进行一个排序的。为下一步操作做好准备。
K的选择 很明显，对于这算法，K的选取决定了整个算法分类预测的准确性，可以说是其核心参数。从上面的例子也可以看出来，K=3和K=5得到的决然不同的结果的。
1.3 算法步骤 （1）初始化距离 （2）计算待分类样本和每个训练集的距离 （3）排序 （4）选取K个最邻近的数据 （5）计算K个训练样本的每类标签出现的概率 （6）将待分类样本归为出现概率最大的标签，分类结束。
2. Python实现K-邻近算法 2.1 K-邻近函数 def mykNN(testData, trainData, label, K): # testData 待分类的数据集 # trainData 已经分类好的数据集 # label trainData数据集里面的分类标签 # K是knn算法中的K # testData=[101,20] # testData=np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d1feae23212df2002d0985f5240f5a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f908343974734dfd5f8039cdbb517cd/" rel="bookmark">
			机器学习实战之KMeans算法pandas实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这次写的恶心死我了，第一次随机选中心点的代码有问题还是怎么的，导致第一轮过完，可能会出现某个中心点根本就完全不合适，没有任何一个点会标记为这个中心点，然后报错。导致我的这个代码时灵时不灵，开始完全想不到bug的原因。 而且虽然用pandas来自己实现确实能帮忙巩固pandas的知识，但我还是觉得以前是走入了误区。机器学习重要的部分应该是对理论的理解和轮子的使用，至于书中的代码，理解下理论实现的具体过程就行了，自己在这费心费力造轮子实在是意义不大，虽然在造的过程中也能加深理解，但事倍功半 所以还是决定以后学习就结合西瓜书的理论，实战中的实现思路和sklearn的代码实现了
import numpy as np import pandas as pd from pandas import DataFrame,Series path = r'C:\Users\36955\Downloads\mlp\Ch10\testSet2.txt' data = pd.read_csv(path,sep='\t',header=None) def randCent(dataSet, k): n = dataSet.shape[1] centroids = DataFrame(np.zeros((k,n))) data_min = dataSet.min(0) data_range = dataSet.max(0)-data_min for j in range(n): minJ = data_min[j] rangeJ = float(data_range[j]) centroids.iloc[:,j] = minJ + rangeJ * np.random.rand(k,1) return centroids def distEclud(vecA, vecB): return np.sqrt(np.sum(np.power(vecA - vecB, 2))) def kMeans(data,k): m = data.shape[0] clusterAssment = DataFrame(np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f908343974734dfd5f8039cdbb517cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b5444449c13cd30d4ff61338f924f4c/" rel="bookmark">
			java虚拟机动态类型语言支持
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这篇博客是根据《深入理解java虚拟机》的讲解和本人对动态类型语言的一些认识，来深度剖析一下java虚拟机对动态类型语言的支持！
什么是动态类型语言 在讲解java虚拟机对动态类型语言支持之前，我们首先要弄明白动态类型语言是什么？它与java语言、java虚拟机有什么关系？那么接下来先回答第一个问题，什么是动态类型语言：动态类型语言的关键特征是它的类型检查的主体过程是在运行期而不是编译器，满足这个特征的语言有很多，常用的包括： APL、JavaScript、python、Ruby、Groovy等。相对的在编译期就进行类型检查过程的语言（C++和Java等）就是最常用的静态类型语言。大家可能对上面定义过于概念化，那我们不妨通过几个例子以最浅显的方式说明什么是“在编译器/运行期进行”和什么是“类型检查”。首先看下面这段简单的Java代码：它是否能正常编译和运行呢？
public static void main(String[] args) { int i = 10; int j = 0; int v = i/j; } 这段代码相信大家再熟悉不过了，它可以正常编译，但是会运行时会报ArithmeticException异常。在Java虚拟机中规范中明确规定了ArithmeticException是一个运行异常，通俗一点说，运行时异常只要代码不运行到这一行就不会有问题。与运行异常相对应的是编译时异常，接下来看一下编译时异常的例子：
public static void main(String[] args) { FileInputStream fis = null; fis = new FileInputStream("test.txt"); } 上面这个例子中 fis = new FileInputStream("test.txt")会抛出IOException异常，这是一个编译时异常，如果不做try-catch处理，编译都通不过。通过上面两个例子就是想说明有些检查是在运行期进行的，有些检查是在编译器进行的。接下来再举一个例子来解释“类型检查”，例如下面这一句非常简单的代码：
obj = Demo(); obj.function(); 上面代码中假设Demo是一个类，且里面有function方法，这两行对于Java说，相信大家都知道是无法编译的更别提执行了。但是类似的代码在JavaScript或者Python中情况则不一样，是可以编译并且可以执行的。这种差别产生的原因在于动态类型语言中，变量obj本身是没有类型的，变量obj的值才具有类型，这是因为动态类型语言在运行期确定类型的，而Java或者静态类型语言是编译器确定类型的。孰好孰坏不知道，应该是各有所长吧。
JDK1.7与动态类型 在介绍完动态类型，回到Java语言、虚拟机和动态类型语言之间的关系。其实Java虚拟机层面对动态类型语言的支持一直都有所欠缺，主要表现在方法调用方面：JDK1.7以前的字节码指令集中，4条方法调用指令（invokevirtual , invokespecial , invokestatic ,invokeinterface）的第一条参数都是被调用的方法的符号引用，前面已经提到过，方法的符号引用在编译时产生，而动态类型语言是在动态运行期才能确定接受者的类型。因此这也就是JDK1.7中invokedynamic指令以及java.lang.invoke包出现要解决的问题。
java.lang.invoke包
JDK1.7中新加入的java.lang.invoke包的主要目的就是在之前单纯依靠符号引用来确定的目标方法这种方式以外，提供一种新的动态确定目标方法的机制，称之为MethodHandle。其实MethodHandle就是类似C/C++中的函数指针，或者C#中的委托。举个例子，如果我们要实现一个带有函数参数的排序函数，用函数指针的方如下： void sort(int list[], const int size , int (*compare)(int, int)) int (*compare)(int, int)) 但Java语言就做不到这点，即没有办法把一个函数作为参数进行传递。普遍的做法是设计一个带有compare()方法的Comparator接口，以实现了这个接口的对象作为参数。不过，在拥有Method Handle之后，Java语言也可以拥有类似于函数指针或者委托的方法别名的工具了。如下代码演示了MethodHandle的基本用法，无论obj是何种类型，都可以正确的调用到println()方法。 package demo; import java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b5444449c13cd30d4ff61338f924f4c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad6722201439f8f6aa8af37cfd179caa/" rel="bookmark">
			第十个Java程序，简单的验证登陆。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 第十个Java程序，简单的验证登陆。
代码如下：
package learn; import java.util.Scanner; public class Login { public static void main(String[] args) { // TODO Auto-generated method stub Scanner scan=new Scanner(System.in); System.out.println("请输入登陆用户名："); String name=scan.nextLine(); System.out.println("请输入登陆密码："); String num=scan.nextLine(); if(!name.equals("abcde")) System.out.println("用户名不存在。"); else if(!num.equals("123456789")) System.out.println("密码错误"); else System.out.println("登陆成功!"); } } 结果如下： 请输入登陆用户名：13请输入登陆密码：132用户名不存在。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7853fb83b8578d3915466ccfbdcf1976/" rel="bookmark">
			第九个Java程序，判断是否为闰年。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 第九个Java程序，判断是否为闰年。
代码如下：
package learn; import java.util.Scanner; public class JudgeYear { public static void main(String[] args) { // TODO Auto-generated method stub System.out.println("请输入一个年份："); Scanner scan=new Scanner(System.in); int year ; year=scan.nextInt(); if(year%4==0&amp;&amp;year%100!=0||year%400==0) { System.out.println(year+"是闰年。"); } else { System.out.println(year+"不是闰年。"); } } } 结果如下：请输入一个年份： 2012 2012是闰年。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a91681b95af74dabe2d7e810722e0eee/" rel="bookmark">
			怎么判断是不是堆序列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 堆的存储 一般都用数组来表示堆，i结点的父结点下标就为(i – 1) / 2。它的左右子结点下标分别为2 * i + 1和2 * i + 2。如第0个结点左右子结点下标分别为1和2。
先画出完全二叉树结构，判断是否满足 最大堆：左右孩子都比父节点小 最小堆：左右孩子都比父节点大 例如：下面的序列中，（）是堆 正确答案: A 1,2,8,4,3,9,10,5 1,5,10,6,7,8,9,2 9,8,7,6,4,8,2,1 9,8,7,6,5,4,3,7 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d25d5a3382d776a1037109d984d7f77/" rel="bookmark">
			第五个Java程序，对字母进行大小写转换。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 第五个Java程序，对字母进行大小写转换。
代码如下：
package learn; import java.util.Scanner; public class WordChange { public static void main(String[] args) { // TODO Auto-generated method stub Scanner in=new Scanner(System.in); System.out.println("请输出你要转换的字母："); char c=in.next().charAt(0); if(c&gt;='A'&amp;&amp;c&lt;='Z'){ c+=32; System.out.println("这个大写"+(char)(c-32)+"被转换成为"+c); } else if(c&gt;='a'&amp;&amp;c&lt;='z'){ c-=32; System.out.println("这个小写"+(char)(c+32)+"被转换成为"+c); } else{ System.out.println("这不是字母"); } } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/acc168e46e3aae5ea94ef4a9a860742c/" rel="bookmark">
			第四个Java程序，获取浮点类型的最大值和最小值。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 第四个Java程序，获取浮点类型的最大值和最小值，
代码如下：
package learn; public class FloatDouble { public static void main(String[] args) { // TODO Auto-generated method stub float float_max=java.lang.Float.MAX_VALUE; float float_min=java.lang.Float.MIN_VALUE; double double_max=java.lang.Double.MAX_VALUE; double double_min=java.lang.Double.MIN_VALUE; System.out.println("单精度浮点数的最大值为："+float_max); System.out.println("单精度浮点数的最小值为："+float_min); System.out.println("双精度浮点数的最大值为："+double_max); System.out.println("双精度浮点数的最小值为："+double_min); } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91cb394da0f41820d8b1ffbce8d83e18/" rel="bookmark">
			数据库优化目的和方向
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 数据库优化的目的： 一、避免出现页面出现访问错误： 1、由于数据库连接timeout产生页面5xx错误 2、由于慢查询造成页面无法加载 3、由于阻塞造成数据无法提交 二、增加数据库的稳定性 很多数据库问题都是由于低效的查询引起的 三、优化用户体验 1、流畅页面的访问速度 2、良好的网站功能体验 优化的方向： SQL及索引，数据库表结构，系统配置，硬件 1、从左到右成本逐渐增高，效果逐渐变差 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e86976dd80aa1ba8e19b9c44a477d41e/" rel="bookmark">
			java种设计模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		创建型模式 这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。 1.工厂模式（Factory Pattern） 2.抽象工厂模式（Abstract Factory Pattern） 3.单例模式（Singleton Pattern） 4.建造者模式（Builder Pattern） 5.原型模式（Prototype Pattern）
结构型模式 这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。 6.适配器模式（Adapter Pattern） 7.桥接模式（Bridge Pattern） 8.过滤器模式（Filter、Criteria Pattern） 9.组合模式（Composite Pattern） 10.装饰器模式（Decorator Pattern） 11.外观模式（Facade Pattern） 12.享元模式（Flyweight Pattern） 13.代理模式（Proxy Pattern）
行为型模式 这些设计模式特别关注对象之间的通信。 14.责任链模式（Chain of Responsibility Pattern） 15.命令模式（Command Pattern） 16.解释器模式（Interpreter Pattern） 17.迭代器模式（Iterator Pattern） 18.中介者模式（Mediator Pattern） 19.备忘录模式（Memento Pattern） 20.观察者模式（Observer Pattern） 21.状态模式（State Pattern） 22.空对象模式（Null Object Pattern） 23.策略模式（Strategy Pattern） 24.模板模式（Template Pattern） 25.访问者模式（Visitor Pattern）
J2EE 模式 这些设计模式特别关注表示层。这些模式是由 Sun Java Center 鉴定的。 26.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e86976dd80aa1ba8e19b9c44a477d41e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47b8a05e67c7b0c9f90a9d69706a3132/" rel="bookmark">
			抽奖算法的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 最近的一个业务需求是开发一个抽奖管理功能，要求在一个奖池中放一堆奖品，分别给它们设置不同的数量和概率，在奖品没有发完的情况下，概率高的被抽中的几率就大，反之则低。另外，概率为0的不能被抽中，概率为100则一定要被抽中。
这里只讨论下其中的核心算法的设计及一个示例函数，算法之外的系统控制暂不提及。
实现抽奖的方法应该有很多，没有仔细去考察和搜索那些非常复杂的算法，这里仅做了一个简单的假设，并在此基础上推出后面所有的控制逻辑。
1. 基本假设 假设系统生成一个1到100之间的随机整数R，C为1到100之间的一个任意整数，那么R小于C的概率为C/100。
暂且不去从数学上论证这个假设是否真的成立，我们仅从直观上来看，R是随机的，它的值不论是多少，取到1-100之间任意一个整数的概率都是一样的。
但C越小，R落入0-C之间的概率也会越小，所以我们大致上可以用C来控制某个奖品的概率。Good!
2. 实现逻辑 有了上面的假设，我们就可以考虑实现一个奖池内不同奖品配置情况下的控制逻辑。
首先我们把奖池中的奖品做一个过滤，剔除掉那些不满足条件的奖品，比如概率为0的、已经发完的等等。剩下的奖品都是可以被抽中的，只是概率大小不同而已。
OK，下面我们来设置一些概念，以方便后面的行文。
假设有N个奖品，它们都以100为满概率，那么它们总共的概率空间为O=N*100；
如果这N个奖品的概率分别为C1,C2,C3...Cn，那么他们总共的中奖概率空间就是H=C1+C2+C3+...+Cn，因为Cn总是小于等于100，所以
H总是小于等于O。
我们把以上这些参数在后台配置好，当抽奖行为发生时，我们让系统生成一个随机数R，1&lt;=R&lt;=O，那么当R&lt;=C时，我们就认为中奖了，否则就不中奖。Good10!
在判断出是否中奖后，我们就可以进一步判断中了什么奖。
首先把奖品以数组形式A按概率从小到大进行排序，然后求出每个奖品在总中奖概率空间H中的中奖区间，并且把各区间的最大值保存成一个数组D。
例如有a和b两个奖品，概率分别为20和30,那么a的概率空间为20，中奖区间为1-20；而b的概率空间为30，但它的中奖区间是20-50，这样D就是(1,20,50)。
然后我们再把D从小到大排序并循环，当R小于20时，我们认为a被抽中；R小于50时，认为b被抽中。Good11!
这里有个问题，就是为什么不直接把R跟a和b的概率比较，而要比较它们各自中间区间的最大值？
因为我们设想的情况是，不仅某种奖品概率调大时其抽中的几率增大，而且所有奖品的概率都调大时，它们被抽中的几率都增大。
如果直接把R跟奖品各自的概率比较，根据我们上面的逻辑，它们总的中奖空间H=2×100=200，只要R的值小于200，我们就已经认为中奖了；但是当a和b两种奖品的概率为99时，只有当R小于100时它们才会被抽中，R落在100到200之间将不被认为中奖，这显然是不对的。
搞清楚了上面的逻辑，剩下的就是处理一些特殊情况了。
比如，如果某些奖品的概率为100，这就是我们之前说的存在满概率奖品。按我们的设想，当有百分百中奖的奖品时，我们一定要这种奖品被抽中。
处理这个问题，我的方法是把奖品按概率分成两组，一组是满概率奖品，一组是非满概率奖品。当满概率奖品组不为空时，从中随机取出一个作为被抽中的奖品放出，直到这些奖品被抽完。
到此为止整个逻辑基本结束，可以着手写代码了。Good101!
作者：codemarker 链接：http://www.jianshu.com/p/1d0316eaa35a 來源：简书 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57478795d6e00b5d865394aafec13ebe/" rel="bookmark">
			rocketMQ简单总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 rocketMQ简单总结 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e943c73576cfcaf816b6326825bc4a3/" rel="bookmark">
			Android下载网络图片资源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从网络下载图片资源在各种APP中很常见，比如很多APP都有广告轮番功能，这些广告图片通常是从服务器获取的，这里就需要从服务器上下载图片资源并显示。
一、获取网络图片并下载到本地：
代码：MainActivity.java：
package com.example.androidt11; import java.io.File; import java.io.FileOutputStream; import java.io.IOException; import java.io.InputStream; import java.net.MalformedURLException; import java.net.URL; import android.app.Activity; import android.content.Intent; import android.graphics.Bitmap; import android.graphics.BitmapFactory; import android.os.Bundle; import android.os.Environment; import android.os.Handler; import android.os.Message; import android.view.View; import android.view.View.OnClickListener; import android.widget.Button; import android.widget.EditText; import android.widget.ImageView; public class MainActivity extends Activity { private EditText editText; private Button button; private ImageView imageView; private Bitmap bitmap; //手柄更新的作用 Handler handler=new Handler(){ public void handleMessage(Message msg) { if(msg.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e943c73576cfcaf816b6326825bc4a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd078f331951f892f6fef1e441560f7e/" rel="bookmark">
			MRI数据格式转换——基于Nipype/FreeSurfer
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 将数据转换为Nifti格式
a. 用MRICro的MRIConvert进行数据格式的转换
b. 用FreeSurfer’的 mri_convert函数，鉴于大多数的scanner格式默认为DICOM，这里我们介绍怎样将DICOM格式转换为Nifiti格式。
首先需要确认文件夹的结构，假设dicom文件存放在一个名为raw_data的文件夹内，其结构类型如下：
raw_dicom |-- sub001 | |-- t1w_3d_MPRAGE | | |-- 00001.dcm | | |-- ... | | |-- 00176.dcm | |-- fmri_run1_long | | |-- 00001.dcm | | |-- ... | | |-- 00240.dcm | |-- fmri_run2_long | |-- ... |-- sub0.. |-- sub010 批量进行格式转换的代码如下：
TUTORIAL_DIR=~/nipype_tutorial # location of experiment folder RAW_DIR=$TUTORIAL_DIR/raw_dicom # location of raw data folder T1_FOLDER=t1w_3d_MPRAGE # dicom folder containing anatomical scan FUNC_FOLDER1=fmri_run1_long # dicom folder containing 1st functional scan FUNC_FOLDER2=fmri_run2_long # dicom folder containing 2nd functional scan DATA_DIR=$TUTORIAL_DIR/data # location of output folder for id in $(seq -w 1 10) do mkdir -p $DATA_DIR/sub0$id mri_convert $RAW_DIR/sub0$id/$T1_FOLDER/00001.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd078f331951f892f6fef1e441560f7e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45607de9ddfdc493b8ec07056a2605f5/" rel="bookmark">
			resin4.0.53安装部署文档
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		resin4.0.53安装部署文档 1.下载安装包 wget http://caucho.com/download/resin-4.0.53.tar.gz 2.解压安装 tar xzvf resin-4.0.53.tar.gz cd resin-4.0.53 ./configure --prefix=/data/resin-4.0.53 make &amp;&amp; make install 3.配置resin.properties cd /data/resin-4.0.53/conf vim resin.properties 将app_servers参数改为127.0.0.1:6852
注释app.http和web.http
一定要注释app.http,app_servers参数改不改也可以,因为我们会在resin.xml中不使用它,不改的话,会有歧义
4.配置resin.xml,修改端口与部署war包 vim resin.xml 删除id不是app的cluster,只保留app cluster,其余不需要,此cluster的示例配置如下:
&lt;cluster id="app"&gt; &lt;!-- &lt;server-multi id-prefix="app-" address-list="${app_servers}" port="6800"/&gt; --&gt; &lt;server id="app" address="127.0.0.1" port="6852" &gt; &lt;watchdog-port&gt;4852&lt;/watchdog-port&gt; &lt;http address="*" port="8852"/&gt; &lt;/server&gt; &lt;host-default&gt; &lt;!-- creates the webapps directory for .war expansion --&gt; &lt;web-app-deploy path="webapps" expand-preserve-fileset="WEB-INF/work/**" multiversion-routing="${webapp_multiversion_routing}" path-suffix="${elastic_webapp?resin.id:''}"/&gt; &lt;/host-default&gt; &lt;!-- the default host, matching any host name --&gt; &lt;host id="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/45607de9ddfdc493b8ec07056a2605f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8337ae784deb9c61b64cdb2681424b7c/" rel="bookmark">
			Kaggle:Bag of Words Meets Bags of Popcorn 学习记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Kaggle案例分析：Bag of Words Meets Bags of Popcorn-part1*
项目表述： 这是一个关于情感分析的话题。Google的Word2Vec（文本深度表示模型）是一个由深度学习驱动的方法。旨在获取words内部的含义。Word2Vec试图理解单词之间的含义与语义关系， 它类似于recurrent neural nets(递归神经网络)或者深度神经网络, 但是计算效率更高.情感分析是机器学习领域的一个具有挑战性的任务。 part1：基础的自然语言处理。 part2：讲述如何用Word2Vec来训练一个模型以及如何使用得到的词向量来做情感分析。本教程所采用的数据集为IMDB情感分析数据集,它包含了10万条电影评论。 本文处理流程主要包含以下几个模块:利用pd.read_csv读取数据 –&gt; 利用BeautifulSoup包去除评论中的HTML标签 –&gt; 用正则化re去除评论中的标点符号 –&gt; 将评论中所有大写字母换成小写 –&gt; import pandas as pd train = pd.read_csv ('labeledTrainData.tsv',header= 0, delimiter= '\t',quoting= 3) print(train.review[0]) "With all this stuff going down at the moment with MJ i've started listening to his music, watching the odd documentary here and there, watched The Wiz and watched Moonwalker again. Maybe i just want to get a certain insight into this guy who i thought was really cool in the eighties just to maybe make up my mind whether he is guilty or innocent.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8337ae784deb9c61b64cdb2681424b7c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa3db1b24e97e14d988d0db6cc66459f/" rel="bookmark">
			ffmpeg推送AAC音频处理ADTS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原来取rtmp流如：rtmp://live.hkstv.hk.lxdns.com/live/hks
或者录播保存的文件，它们的aac音频包都没有ADTS头部，
但客户提供的一个http流：http://cntv.hls.cdn.myqcloud.com/asp/hls/850/0303000a/3/default/1ee473b960054ae29256751f50033d34/850.m3u8
它的每个aac音频包有adts头，
不去掉头直接调用ffmpeg的av_interleaved_write_frame会失败的，
简单去掉7字节adts头，接口调用成功了，但fms地址播放没有声音，用vlc播放器有断续的声音。
用ffmpeg可执行程序推送要对音频加上-bsf:a aac_adtstoasc才能推送，但视频还是有问题的。
原因是音频输出流中的codec的extra_data为空，要分配2字节的空间，将音频采样率和音频通道数设置进去。
out_stream2-&gt;codec-&gt;extradata = (uint8_t*)av_malloc(2);
out_stream2-&gt;codec-&gt;extradata_size = 2;
unsigned char dsi1[2];
unsigned int sampling_frequency_index = (unsigned int)get_sr_index((unsigned int)out_stream2-&gt;codec-&gt;sample_rate);
make_dsi(sampling_frequency_index, (unsigned int)out_stream2-&gt;codec-&gt;channels, dsi1 ); memcpy(out_stream2-&gt;codec-&gt;extradata, dsi1, 2);
这个get_sr_index就是根据采样率返回下标，与adts的sampling_frequency_index定义相同，如48000返回3
void make_dsi(unsigned int sampling_frequency_index, unsigned int channel_configuration, unsigned char* dsi )
{ unsigned int object_type = 2; // AAC LC by default dsi[0] = (object_type&lt;&lt;3) | (sampling_frequency_index&gt;&gt;1); dsi[1] = ((sampling_frequency_index&amp;1)&lt;&lt;7) | (channel_configuration&lt;&lt;3);
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2a5e0671a0234808da6dc06b96a1eb2/" rel="bookmark">
			Unity 利用AndroidJavaClass 获取jar实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在unity中，每个封装好的jar中的实例或者方法都是可以在C#中直接访问到，下面就做一个简单的例子
首先获得UnityPlayer：
var playerCls = new AndroidJavaClass("com.unity3d.player.UnityPlayer"); 由此可以获得当前activity： var activity = playerCls.GetStatic&lt;AndroidJavaObject&gt;("currentActivity"); 同时还可以获得applicationContext： var applicationContext = activity.Call&lt;AndroidJavaObject&gt;("getApplicationContext"); 接下来获取jar中的某个实例和方法： 首先拿到当前jar 中 某个类：
var jar = new AndroidJavaClass("com.xxx.xxx.xxx.xxx");然后如果有实例，可以通过以下语句获得： var instance= jar.CallStatic&lt;AndroidJavaObject&gt;("getInstance"); 成功获得实例后，就可以调用此类中任意可以访问到的方法了，例如： instance.Call&lt;int&gt;("init", applicationContext , activity); 在这里是访问了一个方法名为init，接收applicationContext，activity两个参数，并且返回int类型的函数，在这里要着重注意函数的类型，用相应的方法才能访问到，否则会出现异常错误。 一个简单的访问Android的方法，如有雷同，纯属巧合。如有更好见解，欢迎指正！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97f282895b1ea011de911fd92e9299d3/" rel="bookmark">
			Linux下安装绿色版oracle客户端
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一步:上传以下所需安装包到相对应目录
oracle-instantclient11.2-basic-11.2.0.1.0-1.x86_64.rpm
oracle-instantclient11.2-devel-11.2.0.1.0-1.x86_64.rpm
oracle-instantclient11.2-sqlplus-11.2.0.1.0-1.x86_64.rpm
第二步：进行rpm包安装
第三步：进入到相对应目录（该rpm包安装完后会把东西放到下面红框目录下）
cd /usr/lib/oracle/11.2/client64
然后新建目录mkdir –P network/admin
再从原有数据库服务端拷贝listener.ora，sqlnet.ora，tnsnames.ora三个文件到这个目录(/usr/lib/oracle/11.2/client64/network/admin)下。
第四步：配置环境变量
注意：想让哪个用户能连，就配置哪个用户家目录下的.bashrc文件
比如咱们配置boco用户的。那就
cd /home/boco
vi .bashrc
然后增加以下语句：
export LD_LIBRARY_PATH=/usr/local/lib:/usr/lib/oracle/11.2/client64/lib
export ORACLE_HOME=/usr/lib/oracle/11.2/client64
export TNS_ADMIN=/usr/lib/oracle/11.2/client64/network/admin
export PATH=/usr/sbin:$PATH
export PATH=$ORACLE_HOME/bin:$PATH
最后使用以下命令使配置的环境变量生效
source /home/boco/.bashrc
第五步：配置tnsnames.ora文件
vi tnsnames.ora文件
增加如下红框配置：
第六步：测试连接
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94deed652df9ccb71a364b4431e16db0/" rel="bookmark">
			Android 解决Could not find com.android.tools.build:gradle
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 异常 Error:Could not find com.android.tools.build:gradle:2.2.2. Searched in the following locations: https://repo1.maven.org/maven2/com/android/tools/build/gradle/2.2.2/gradle-2.2.2.pom https://repo1.maven.org/maven2/com/android/tools/build/gradle/2.2.2/gradle-2.2.2.jar Required by: :ListViewAnimations-master:unspecified 解决方法 在项目的根目录的build.gradle文件中的buildscript-&gt;repositories节点下添加jcenter(),然后更新依赖。
buildscript { repositories { jcenter() mavenCentral() } dependencies { classpath 'com.android.tools.build:gradle:2.2.2' } } allprojects { repositories { jcenter() mavenCentral() } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8fd35868efc102f2c8a19830c29fa8a7/" rel="bookmark">
			MATLAB利用散点进行函数曲线拟合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Matlab是一个很强大的数据处理软件，是人们进行数据分析的得力助手。一般我们做社会调研或科学研究时，会得到很多实验数据。当需要研究两个变量之间的关系时，经常要用到曲线拟合。曲线拟合不仅能给出拟合后的关系式，还能用图形直观的展现出变量之间的关系。 其实用matlab做曲线拟合很便捷，下面将以两个变量(y=f(x))为例详细介绍。
1、运行Matlab软件。
在工作空间中存入变量的实验数据。具体如下：
可以直接用矩阵来存放数据，直接在命令窗口输入
x=[数据x1，数据x2，...,数据xn];
y=[数据y1，数据y2，...,数据yn];
当数据较多时，可以从excel，txt等文件中导入。
2、把数据存入工作空间后，在命令窗口中输入cftool,回车运行。
3、在这个拟合工具窗口的左边，选择变量，即分别选择x,y。
4、选择拟合的曲线类型，一般是线性拟合，高斯曲线，平滑曲线等，根据需要选择。
选择完后会自动完成拟合，并且给出拟合函数表达式。
5、点击菜单栏中的“file”，选择“print to figure"进行画图。
6、在图形窗口中，可以对图形显示模式进行修改，如添加标题，坐标名称等。
7、最后得到比较完整的图形曲线。点击”file"中的“save"进行保存。
这个过程中有一个注意事项：x和y的数据维度必须保持一致。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b596b5944e3bd67d25d33af92621501f/" rel="bookmark">
			用vue构建项目笔记7(在vue中引用公共过滤器filter)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在实际项目开发中，在某一组件中声明的全局过滤器Vue.filter并不能在其他组件中使用，所以，我认为只要调用两次以上或者可能会被调用两次以上的过滤器，就应该写入统一个过滤器文件中，方便统一调用。下面是如果创建并调用统一的过滤器的方法：
1.在公用js文件夹中新建文件filters.js
2.在filters.js中使用es6写法写入（因为我用的是vue-cli，自带babel组件一套，可以自动转换es6写法到es5，所以不用考虑兼容性）
let formatDate = time =&gt; { if(time){ return time.slice(5,16) } } export { formatDate }3.找到main.js引入 import * as filters from './assets/js/filters.js' Object.keys(filters).forEach(key =&gt; { Vue.filter(key, filters[key]) })4.在组件中使用 &lt;h2&gt;时间：&lt;span&gt;{{createTime | formatDate(createTime)}}&lt;/span&gt;&lt;/h2&gt;我这个是制作了一个时间截取的过滤器，比较简陋，真正厉害的应该是输入格式自动返回对应时间，但是我这暂时没必要这么做，根据项目需求自定义即可。 其实这种简单的截取字符串直接在标签上写入也可以，这只是举个例子
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1884820a8fc6c8910ff485e14324031c/" rel="bookmark">
			typedef enum 和enum详细用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		枚举（enum）通过一种简单的途径，把一串名字与一串整形值联系在一起。可以代替#define声明 枚举一般形式：
enum 可选标签{ 内容.....}可选定义变量定义；
其中“”内容.....”是一些标识符的列表，可能有一些整型值赋给它们。
enum ASN{MON=7, TUE, WED=10, THU, FRI}; 1.ASN为是一个标识符，可以看成这个集合的名字，是一个可选项，即是可有可无的项。
2. 缺省情况下，整型值从0开始。如果对列表中的某个标识符进行赋值，那么紧接其后的那个标识符的值比所赋的值大一，然后类推。
3.以；结束
enum可以通过枚举名加点通过枚举的元素访问枚举数值。例：
int i = (int)ASN.MON;枚举值虽然是int类型的，但是也必须进行显示的强制转换。
只可以把枚举值赋予变量，不可以直接把元素的数值直接赋值给枚举变量，除非强制转换
enum DAY
{
MON=1, TUE, WED, THU, FRI, SAT, SUN
};
enum DAY good_day, bad_day; //变量good_day和bad_day的类型均为枚举型enum DAY
enum //跟第一个定义不同的是，此处的标号DAY省略，这是允许的。
{
saturday,
sunday = 0,
monday,
tuesday,
wednesday,
thursday,
friday
} workday; //变量workday的类型为枚举型enum DAY
enum BOOLEAN { false, true } end_flag, match_flag; //定义枚举类型并声明了两个枚举型变量
typedef enum用法
typedef enum workday
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1884820a8fc6c8910ff485e14324031c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50ad61b463bce9440a5c315bcb298457/" rel="bookmark">
			使用cuFFT实现大整数乘法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		序言 在某些场合，我们可能需要使用远超内置整型范围的整数进行运算，比如公钥加密等。如果使用最原始的竖式计算，那么时间复杂度是 T(n2) ，其中n是相乘的两个整数的位数。使用Karatsuba算法优化，时间复杂度可以降至 T(nlog23)≈T(n1.585) 。而如果使用快速傅里叶变换（FFT），则可以优化到 T(nlogn) 。
原理 整数乘法与多项式 一个整数，我们可以把它表示成一个多项式。比如长度为n的十进制整数 a0a1a2a3...an−1 写成多项式： A(x)=a0xn−1+a1xn−2+...+an−2x+an−1 整数2345，写成多项式就是： A(x)=2x3+3x2+4x+5 这样一来，整数乘法就变成了多项式的乘法。比如2345*123，就变成了： ×+=2x5+2x5+4x4+3x4+7x4+2x3+6x3+6x3+4x3+16x3+3x2+x2+9x2+8x2+5x222x2+4x+2x+12x+10x22x+531515 （这时会发现结果多项式中的某些系数大于10，只要做进位处理即可得到288435，就是2345*123的结果。）
很显然，这样直接计算的时间复杂度是 T(n2) （假设两个多项式次数均为n-1）。
为了简洁，还可以把多项式系数抽出来表示成向量的形式： (2,7,16,22,22,15) ，这是多项式的系数表示法。
对于一个n-1次多项式A(x)，它由n个系数 a0,a1,a2,...,an−1 决定。如果对n个不同的x进行求值，就能得到n个不同的点： (x0,A(x0)),(x1,A(x1)),...,(xn−1,A(xn−1)) 。 反过来，只要我们知道y=A(x)上n个不同的点，那么我们就可以通过对这n个点插值求得A(x)的n个系数。
n个各异点跟n个系数一样都可以确定唯一的一个n-1次多项式。这种用n个各异的点表示多项式的方法称为多项式的点值表示法。
多项式乘法与卷积 把多项式乘法结果 C(x)=A(x)∗B(x) 的系数用公式描述出来： ci=∑k=0iakbi−k 如果学习过信号处理，你可能会觉得这个公式很眼熟。没错，这就是卷积公式。多项式乘法实际上就是在做卷积。 比如 (2,3,4,5) 跟 (1,2,3) 做卷积：
2345321 (2∗1) 2345321 (2,2×2+3×1) 2345321 (2,7,2×3+3×2+4×1) 2345321 (2,7,16,3×3+4×2+5×1) 2345321 (2,7,16,22,4×3+5×2) 2345321 (2,7,16,22,22,5×3)=(2,7,16,22,22,15) 卷积与快速傅里叶变换 卷积的计算方法有很多种，这里主要介绍使用快速傅里叶变换的方法。这个方法利用了以下结论：
时域上的卷积等价于频域上的点乘-&gt;系数表示下的多项式乘法等价于点值表示下的点乘
设n-1次多项式A(x)、B(x)它们各有n个系数，以及2n-2次多项式C(x)=A(x)*B(x)，它有2n-1个系数。
对A(x)、B(x)求值，得到点值表示下的A(x)、B(x)： A(x):(x0,A(x0)),(x1,A(x1)),...(x2n−2,A(x2n−2))B(x):(x0,B(x0)),(x1,B(x1)),...(x2n−2,B(x2n−2)) 需要注意，尽管A(x)和B(x)的系数只有n个，但是这里使用了2n-1个点来表示，有n-1个点是“多余”的。这是因为C(x)是2n-2次多项式，需要2n-1个点来表示。 因为 C(xk)=A(xk)∗B(xk)) ，那么可以计算得到C(x)的点值表示： C(x):(x0,A(x0)∗B(x0)),(x1,A(x1)∗B(x1)),...(x2n−2,A(x2n−2)∗B(x2n−2)) 也就是说，在点值表示下A(x)*B(x)的计算就是点乘。2n-1个点的点乘的时间复杂度是 T(n) 。比系数表示下的多项式乘法 T(n2) 的复杂度低得多。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/50ad61b463bce9440a5c315bcb298457/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/889514adeedeba9da342d3b5ff82ba1d/" rel="bookmark">
			关于GetOverlappedResult函数的一些知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前在写重叠I\O的代码的时候，记得那时是从网络上拷贝的代码例子。在关于重叠操作的等待结果时，一般都是如下的过程：
先 调用waitformultipleobject或waitforsingleobject函数来等待某一个I\O请求绑定的事件对象的激活。等到激活事件对象后，再调用GetOverlappedResult函数取得重叠I\O的结果，这里GetOverlappedResult的返回值一般都是TRUE（即重叠操作成功）。
代码如下：
rc = ReadFile(hFile,buf,300,&amp;numread,&amp;overlap); //因为是overlapped操作，ReadFile会将读文件请求放入读队列之后立即返回（false）， //而不会等到文件读完才返回(true) if (rc) { //文件真是被读完了，rc为true // 或当数据被放入cache中，或操作系统认为它可以很快速地取得数据，rc为true } else { if (GetLastError() == ERROR_IO_PENDING) {//当错误是ERROR_IO_PENDING,那意味着读文件的操作还在进行中 //等候，直到文件读完 WaitForSingleObject(hFile, INFINITE); rc = GetOverlappedResult(hFile,&amp;overlap,&amp;numread,FALSE); //上面二条语句完成的功能与下面一条语句的功能等价： // GetOverlappedResult(hFile,&amp;overlap,&amp;numread,TRUE); } else { //出错了 } } CloseHandle(hFile); 如果这样做也可以，不用关心一些关于getoverlappedresult函数的细节。
现在深入研究下getoverlappedresult函数的细节：
BOOL
WINAPI
GetOverlappedResult(
HANDLE hFile,
LPOVERLAPPED lpOverlapped,
LPDWORD lpNumberOfBytesTransferred,
BOOL bWait
)
下面是OVERLAPPED的结构定义：
typedef struct _OVERLAPPED { DWORD Internal; DWORD InternalHigh; DWORD Offset; DWORD OffsetHigh; HANDLE hEvent; } OVERLAPPED; 其函数实现的伪代码为：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/889514adeedeba9da342d3b5ff82ba1d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d612a00bea5c9561d5c505d7f9450392/" rel="bookmark">
			组合数算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、概念 什么是组合数呢？
从m个不同元素中取出n（n≤m）个元素的所有组合的个数，叫做从m个不同元素中取出n个元素的组合数（Combination）。 组合数基本公式为： Cnm=m!n!(m−n)! 线性写法为：c(m,n) = m!/((m-n)!*n!) 现实生活中彩票的概率计算就涉及到组合数，比如双色球中红球选择需要从 01~33 红球中选出6个，组合结果为 c(33,6) = 1107568.
二、计算方式 由于计算机数据存储方式的限制，阶乘的计算，如果是long int型只能正确计算到12左右的阶乘，如果用double型只能正确计算170左右的阶乘，当然这些只是大概，需要结合实际平台进行验证。
所以采用阶乘计算稍大数组合数是不合适的，而且效率不高，但是可以先对公式进行转换然后再进行计算： 1.对公式两边取自然对数 ln(Cnm)=ln(m!n!(m−n)!) 2.根据对数性质进行转换 ln(Cnm)=ln(m!)−ln(n!)−ln((m−n)!) ln(Cnm)=∑i=1mln(i)−∑i=1nln(i)−∑i=1m−nln(i) 由于 ∑i=1mln(i)=∑i=1nln(i)+∑i=n+1mln(i) 去除相同项 ln(Cnm)=∑i=n+1mln(i)−∑i=1m−nln(i) 到这就已经将阶乘转换成对数连加，极大的降低了运算的复杂度。另外，依据组合数性质： Cnm=Cm−nm 当 n &gt; m/2 时，n 相对于 m - n 是一个较大的数，此时可以取 n = m - n进行计算。
3.进行计算 以第2步得到的公式计算出 ln(Cnm) 的值，然后再取反对数就可以得到组合数结果了。 用这种方法计算组合数，如果只计算ln(C(m,n))的话，n可以取到整型数据的极限值65535，
ln(C(65535,32767)) = 45419.6 而计算时间可以达到毫秒级。当然，如果要取反对数得到最终的组合数的话，m的取值就不能达到这么大了，但是这种算法仍然可以保证m取到1000以上。
4.该算法OC实现代码
/** 组合数计算 @param totalNum C(m,n) 中 m @param requireNum C(m,n) 中 n @return 组合数结果 */ + (NSInteger)selectFromTotalNum:(NSInteger)totalNum requireNum:(NSInteger)requireNum{ if (totalNum &lt; requireNum) { return 0; } if (requireNum &lt; totalNum / 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d612a00bea5c9561d5c505d7f9450392/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ef411ce1ddc742ec7a4fabb51a4dcd5/" rel="bookmark">
			cURL请求接口出现name lookup timed out
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 cURL遇到Length Required错误 php curl获取网页内容加载失败时错误信息： curl_error ： name lookup timed out curl_errno ： 6 由于curl先解析IPV6，再解析IPV4域名的。 解决方法有三种， 一，代码中设置curl默认访问为IPv4 curl_setopt($ch, CURLOPT_IPRESOLVE, CURL_IPRESOLVE_V4); 二，修改服务器DNS # cat /etc/resolv.conf | grep names nameserver 218.85.157.99 nameserver 218.85.152.99 改为 nameserver 114.114.114.114 nameserver 8.8.8.8 三，服务器禁用IPv6 四，写服务器hosts对应关系 以上四个方法即可解决这个问题。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfa14288dfcc7ec2315ccca5cb4920ac/" rel="bookmark">
			大数据风控用了什么模型？有效性如何？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目前贷款的风控因为每一个样本的收集都需要放款来收集，想想每人放一万，一个亿也就只能放1万人，所以样本量不会太大。所以所谓大数据风控主要是大在特征的数据上。很多时候是用了很多传统上不怎么敢用的特征。比如传统风控比较害怕missing value 比较害怕不稳定的特征 这些都是大数据风控需要解决的。
说到模型，既然是特征多，样本少，那就需要一个非常抗过拟合的模型。另外如果是单独针对反欺诈而不是信用，因为问题比较非线性，所以需要一个有非线性能力的模型。满足这两者要求的都可以。
当然上面说到的只是针对预测贷款用户好坏的二分类问题，至于很多风控领域的其他问题，就有不同的解决方案了。
说到有效性。据我所知目前市场上有一些非常小额短期的产品已经可以完全按照一个模型放款并盈利了。完全不需要人参与。这类产品通过小额解决了样本少的问题。通过短期解决了收集label慢的问题。所以还不太容易推广到大额长期产品上去。 由于题主提出的问题围绕着风控模型，而讨论模型必定和实际的应用场景和数据源相关，因此就前四个问题一并回答。
首先金融科技公司大致分为三类，基于线上垂直领域（教育、医疗、电商）、基于特定客群（学生、蓝领、白领）、基于线下场景（车贷、租房）。不同公司在数据维度、授信客群、产品上都有较大区别。基本而言，风险主要集中于信用风险及欺诈风险。
在此简单介绍下消费信贷产品在贷款各个环节风控主要模型对两类风险的把控。
一、模型在信用风险的用途：
1.授信准入阶段
首先是授信准入阶段，此阶段最重要的模型是进件评分卡模型，数据来源主要分为申请信息、历史消费信息、外部信息（例如多投借贷、公积金等）。常用模型包含LR、Xgboost、FFM等。不同模型的选取由是否需要在线更新、可解释性、线上部署环境等多种因素决定。LR的研究非常成熟，有完整的工业分布式解决方案和在线增量学习的理论基础，包括各种带正则项的变种，是非常理想的建模方法，很多时候它还会作为基准型，用于评价复杂模型的提升效果。
一般的线性模型会遇到两个问题：
一是非线性特征的学习，比如年龄。一般使用的方法是进行变量离散化，把年龄分成不同的段或者使用稀疏编码或者自编码等算法对品类或者其他信息进行重构。
二是交互影响，例如收入特征和年龄特征的交叉。高收入的中年人是干爹和干妈，高收入的年轻人是高富帅和白富美，两者的特点完全不一样。所以我们也会使用Xgboost等模型加工非线性特征，或使用FM/FFM类算法学习交叉特征，以此提升模型拟合能力。
此外在这个环节需要注意的是，由于很多公司的数据维度是有限的，分数低的用户并不一定是逾期风险较高的，而可能仅仅是留下数据较少的用户，随着业务的逐步扩张，怎么再去找更多的维度或者在原有数据维度上构建更细腻度的特征来刻画之前无法覆盖的用户群体是关键。
其次由于黑产的猖獗，时刻需要提防刷分、养号的用户，最好的解决方式是通过分析异常群体的行为，构建有区分度的特征或者引入更多数据维度使得可以更加细腻的刻画正常用户的行为，最后还需要结合产品去完善模型。
业务扩张的时候，客群的分布可能发生较大变化，引起的概念漂移也是值得关注的。
2.用户生命周期阶段
当用户准入后需要进行用户生命周期管理，常用到模型是行为评分卡。
和准入阶段不一样，在这个阶段，用户由于大多已经有过至少一次的还款行为，因此可以在数据维度加入借贷数据。
除此之外，需要考虑如何调整额度和息费，保证优质的用户得到更低的息费和更高的额度，而数据表现较差的用户需要用更高的息费来覆盖风险。
但不顾风险的一味最求高收益和不求收益的低风险都是没有意义的。定价模型的重点在于对用户需求和风险的合理预估，调整各个用户群体的息费和额度档次。实则可以看成对资金在不同风险回报的分配，使得在一定的风险下，总体风险收益最大化，技术上会涉及很多带约束的优化问题。
3.催收阶段
最后一个阶段，一小部分用户会逾期进入催收阶段。
这个时期重点是失联修复和催收评分卡，即刻画用户经过一定的催收动作后还款的可能性。
失联修复很好理解，就是通过各种社交数据，建立起关系网络找出与欠款人可能相关的人或者欠款人的其他联系方式。而催收评分卡需要使用到催收数据，催收数据大多是文本音频类型文件备份，因此对这种非结构类型数据的挖掘是这个阶段的核心。
催收的时机，是催收成功最重要的因素。由于催收资源有限，我们需要按照一定的分配规则来分配催收资源。在逾期的较早时期，应该将更多的资源放在较难催收的用户上，而其他的用户可能由于是忘记还款或者其他的非恶意拖欠原因没有还钱，可能给予一段时间会自我救赎；而在催收晚期，则需要放置更多催收资源在能够催回的用户上，尽最大可能降低损失。
二、模型在反欺诈风险方面的用途：
除了上述的信用风险，还有一块较大的职责就是欺诈风险。
现阶段，业界更多关注的是有组织参与的中介欺诈，常见的如批注、盗号、薅羊毛、养号、套现等诸多行为的识别。由于是团伙作案，更多是基于社交网络的社团发现算法来对中介的识别，或者是利用套现中的地址集中性相似性等特点来识别中介，或使用时间序列算法来分析用户的历史行为轨迹，手机传感器信息等生物指纹数据来核实身份。
欺诈风险的难点有别于信用风险，在较多场景下很难定义好坏用户。因此关键在于标签的获得。通常需要同案件调查人员配合，因为他们能够准确定义欺诈，同时能够还原犯罪手法，针对于模型Y变量定义，X变量设计都很有帮助。
其次，由于对抗性强，因此如何检测未发现的欺诈模式和模型的更新速度更加关键。目前这一块工作业界发展都比较滞后。
最后，授信客群的变化或者欺诈团伙作案手法的变化导致原有模型可能失效，加上风险的滞后性，最新可用的训练数据可能已经离目前较远，如何从最新的数据获取模式与旧的数据模式的遗忘是难点。
三、补充
最后，补充如下几点模型评测的注意事项：
1. 由于线下训练环境和线上真实用户群体存在差异，模型的泛化能力很重要，需要确保模型学习到的是有区分度的模式而不是数据中的噪音。
2. 线下使用评测指标主要是刻画准确度与区分度的ks、auc、洛伦兹曲线和Lift曲线等和模型稳定性指标psi。
3. 客群逾期率的高低和公司产品的形态有重要关系，短期提升可以通过反欺诈技术得到改善、而中长期需要依托信用风险模型、但最终还得看产品的授信客群，面向不同客群的风控模型的指标对比试没有意义的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9ed4d7fc3bdb238103e660bb8e0c92e/" rel="bookmark">
			iOS中使用OpenGL 实现增高功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		功能效果 demo示例 功能分析 功能：渲染一张传入的图片 -&gt; 手动选择编辑区域 -&gt; 通过滑块来编辑区域的增高或者缩短
OpenGL原理：
因为OpenGL 只能绘制三角形，所以在处理图像或者图形的时候我们需要将被处理的对象用三角行来分割转换为三角形和顶点的组成的对象。
OpenGL里面坐标是以左下角为原点X轴向上为正，Y轴向右为正
功能实现 渲染图片拆分图片：
拆分方法1：通过图形看出是一个矩形，而矩形是可以分成两个三角形和四个顶点，通过此可以用GL渲染出图片。
拆分三角形 这样拆分之后虽然可以正常渲染，但是带来的问题是我的四个顶点都是死的，也就是四个顶点必须是画布的四个顶点，改变顶点的坐标后只能导致整张画布的变动，而不是某一个区域的变动，拉伸的话也是整张图片的拉伸，所以想要实现局部处理的话这种分割方式不可行。 拆分方法2：将整张图片先拆分为三个矩形，然后再把每个矩形拆分成两个三角形，得到6个三角形，8个顶点，如下图：
拆分2 这样一来就可以保证中间的矩形的高度可以任意变化而上下两部分的高度不变只改变位置，也就是说我们这个DEMO中所做的任何拉伸操作都是对中间矩形的操作，换而言之就是改变最上面的矩形和最下面的矩形之间的距离来达到对中间区域的拉伸和压缩的目的。根据拆分的方式我们用顶点的坐标创建一个数组 //顶点数组 GLfloat vertices[] = { -1.2, -1.2, //左下 1.2, -1.2, //右下 -1.2, -0.4, //小矩形左下 1.2, -0.4, //小矩形右下 -1.2, 0.4, //小矩形左上 1.2, 0.4, //小矩形右上 -1.2, 1.2, //左上 1.2, 1.2, //右上 }; //填充纹理的数组 GLfloat texCoords[] = { 0, 0, //左下 //下标为 0 1 1, 0, //右下 //下标为2 3 0, 1.0/3.0, //小矩形左下 //下标为4 5 1, 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c9ed4d7fc3bdb238103e660bb8e0c92e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7d21c8212319c75b98f1fa90330ce6b/" rel="bookmark">
			sdp分辨率设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Y字段：为十进制整数字符串，表示SSRC值。格式如下：Dddddddddd(第一位为历史或实时媒体
流的标识位，1为历史，0为实时)。
f字段：f--v／编码格式／分辨率／帧率／码率类型／码率大小a／编码格式／码率大小／采样率
各项具体含义：
——v：后续参数为视频的参数；各参数问以“／”分割；
——编码格式(十进制整数字符串表示)：
1：MPEG～4；2：H．264；3：SVAC；4：3GP。
—分辨率(十进制整数字符串表示)：
1：QCIF；2：CIF；3：4CIF；4：D1；5：720P；6：1080P／1。
——帧率(十进制整数字符串表示)：o～99
——码率类型(十进制整数字符串表示)：
1：固定码率(CBR)；2：可变码率(VBR)。
一～码率大小(十进制整数字符串表示)：o～100000(如1表示1 kbps)
——a：后续参数为音频的参数t各参数间以⋯／’分割；
——编码格式(十进制整数字符串表示)：
l：G．711；2：G．723．1；3：G．729；4：G．722．1。
一码率大小(十进制整数字符串)：
音频编码码率：1：5．3 kbps(G．723．1中使用)；
2：6．3 kbps(G．723．1中使用)；
3：8 kbps(G．729中使用)；
4：1 6 kbps(G．722．1中使用)；
5：24 kbps(G．722．1中使用)；
6：32 kbps(G．722．1中使用)；
7：48 kbps(G．722．1中使用)；
8：64 kbps(G．71l中使用)。
～采样率(十进制整数字符串表示)：
1：8 kHz(G．71l、G．723．1或G．729中使用)；
2：14 kHz(G．722．1中使用)；
3：16 kHz(G．722．1中使用)；
4：32 kHz(G．722．1中使用)。
注1：字符串说明
本节中使用的“十进制整数字符串”的含义为⋯o’～“4294967296”之间的十进制数字字符串。
注2：参数分割标识
各参数间以“／”分割，参数间的分割符“／”不能省略；若两个分割符⋯／’间的某参数为空时(即两个分割符“／”
直接将相连时)表示无该参数值；
注3：f字段说明
使用f字段时，应保证视频和音频参数的结构完整性，即在任何时候，f字段的结构都应是完整的结构：
kv／编码格式／分辨率／帧率／码率类型／码率大小a／编码格式／码率大4'／采样率
若只有视频时，音频中的各参数项可以不填写，但应保持“a／／／”的结构：
f—v／编码格式／分辨率／帧率／码率类型／码率大小a／／／
若只有音频时也类似处理，视频中的各参数项可以不填写，但应保持“v／／／／／”的结构：
{一v／／／／／a／编码格式／码率大d"／采样率
f字段中视、音频参数段之间不需空格分割。
注4：SSRC的使用
SIP服务器产生SSRC值，并在发往视频输出(解码器)的Invite中携带这个值．视频输出(解码器)返回的200
OK中带回该值。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95439c0214b98216fa9b16521b21f559/" rel="bookmark">
			对新课程的学习与期望
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我希望这门课可以让我熟练的掌握网站开发的知识，我希望学完这门课后我可以创建出一个我网站，我计划每周在这门课上花费13个小时，每个礼拜的周一到周五的晚上花两个小时学习高级网站开发。
转载于:https://www.cnblogs.com/zhanghongjian/p/7405106.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b60effdaffba5cf9687798f5eee91f5/" rel="bookmark">
			排序算法四：归并排序基本原理以及Python实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 基本原理 归并排序建立在归并操作上的一种算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。归并排序是将两
个已经有序的序列合成一个有序的序列的过程。
因此，对于一个待排序的序列来说，首先要将其进行分割，得到有序的子序列，再进行归并操作，最终得到有序的序列。
归并的基本思想
假设有两个有序的序列，需要合成一个序列。其实就是不断的比较两个序列开头的元素大小就可以。
if a[0] &gt; b[0]
将a[0]存入另一个设置好的空序列C中 else 将b[0]存入另一个设置好的空序列C中 if length（a）==0 或者length（b）==0
上述操作结束 总体的思想就是不断的比较两个序列的第一个元素并存入第三个序列中，再释放原序列中的第一个元素。
分割的基本思想
分割就是将原序列不断的进行分割，以便得到有序的子序列，进行归并操作。整理介绍二分割。就是在序列的中间进行分割。
显然，对于比较长的序列需要进行多次的分割操作，使得每个子序列的元素个数只有一个。只有这样，才能得到有序的子序列，进
行归并操作。
这样话就需要对原序列进行一个递归的分割操作。得到最终的我们需要的子序列。
一个例子
这里有一个随机生成的包含了10个元素的待排序的序列
[92,79,37,39,98,62,64,33,9,5] 按照上述的基本思想，其分割和归并的流程为： 从上面可以很清楚的看到，首先需要进行分割，然后对分割的子序列进行一个归并操作，最终得到排序完成 的新序列。
2. Python实现 归并操作实现
def mergeTwoArray(a,b): m=a.__len__() n=b.__len__() c=[] while m&gt;0 and n&gt;0: if a[0]&lt;b[0]: c.append(a[0]) a.pop(0) m=a.__len__() #k+=1 else: c.append(b[0]) b.pop(0) n=b.__len__() while m&gt;0 and n==0: c.append(a[0]) a.pop(0) m=a.__len__() while n&gt;0 and m==0: c.append(b[0]) b.pop(0) n=b.__len__() return c 归并排序实现
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b60effdaffba5cf9687798f5eee91f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e905dfffe4e49890e59f557b92024463/" rel="bookmark">
			使用XMLWorkerHelper.getInstance().parseXHtml生成PDF时中文不显示或乱码问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题环境: idea+tomcat
代码片段： String fontPath=getFontPath(); htmlString="&lt;html&gt;&lt;style&gt;body{font-family:pingfang sc light;}&lt;/style&gt;&lt;body&gt;第一页1p开始&lt;/body&gt;&lt;/html&gt;"; document.open(); try { XMLWorkerHelper.getInstance().parseXHtml(writer,document, new ByteArrayInputStream(htmlString.getBytes()), null, Charset.forName("UTF-8"),new XMLWorkerFontProvider(fontPath)); } catch (IOException e) { e.printStackTrace(); throw new PDFException("PDF文件生成异常",e); }finally { document.close(); } 问题点： 项目部署后生成的pdf内中文内容为乱码或者不显示
问题跟踪（debug）： 情景一：通过本地main函数调用方法，获取到htmlString.getBytes长度为94位。 运行结果：pdf内容显示正常
情景二：tomcat运行项目，在项目中调用方法，获取到获取到htmlString.getBytes长度为89位。 运行结果：pdf内容中文部分出现问题
结果思考： idea默认编码方式已调整为UTF-8，所以在后期开发中对于编码问题很少重视，而tomcat并没有调整编码方式，所以导致跑main函数时一切正常，而tomcat运行后出现问题
解决方案： htmlString.getBytes()更改为htmlString.getBytes(“UTF-8”)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f58a5e4679a1fb90548ce2840f4b432f/" rel="bookmark">
			iOS VIPER架构实践(二)：VIPER详解与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一篇文章对VIPER进行了简单的介绍，这篇文章将从VIPER的源头开始，比较现有的几种VIPER实现，对VIPER进行进一步的职责剖析，并对各种细节实现问题进行挖掘和探讨。最后给出两个完整的VIPER实现，并且提供快速生成VIPER代码的模板。
Demo和轮子的github地址是：ZIKViper，路由工具：ZIKRouter。有用请点个star~ 注意，Demo需要先用pod install安装一下依赖库。
两个实现展示了以下问题的解决方案：
如何彻底地解决不同模块之间的耦合如何在一个模块里引入子模块子模块和父模块之间如何通信如何对模块进行依赖注入面向接口的路由工具 目录 起源Clean Architecture Enterprise Business RulesApplication Business RulesInterface AdaptersFrameworks &amp; Drivers总结现有的各种VIPER实现 Brigade团队的实现 争议Rambler&amp;Co团队的实现 争议Uber团队的实现 各部分职责数据驱动争议其他设计方案一：最完整的VIPER ViewPresenterInteractorServiceWireframeRouterAdapterBuilder模块间解耦子模块 子模块的来源通信方式依赖注入映射到MVC方案二：允许适当耦合 ViewPresenterInteractor路由和依赖注入总结Demo和代码模板参考 起源 VIPER架构，最初是2013年在MutualMobile的技术博客上，由Jeff Gilbert 和 Conrad Stoll 提出的。他们的博客网站有过一次迁移，原文地址已经失效，这是迁移后的博文：MEET VIPER: MUTUAL MOBILE’S APPLICATION OF CLEAN ARCHITECTURE FOR IOS APPS。
这是文章中提出的架构示意图：
Wireframe可以看作是Router的另一种表达。可以看到，VIPER之间的关系已经很明确了。之后，作者在2014年在objc.io上发表了另一篇更详细的介绍文章：Architecting iOS Apps with VIPER。
在作者的第一篇文章里，阐述了VIPER是在接触到了Uncle Bob的Clean Architecture后，对Clean Architecture的一次实践。因此，VIPER真正的源头应该是Clean Architecture。
Clean Architecture 由Uncle Bob在2011年提出的Clean Architecture，是一个平台无关的抽象架构。想要详细学习的，可以阅读作者的原文：Clean Architecture，翻译：干净的架构The Clean Architecture。
它通过梳理软件中不同层之间的依赖关系，提出了一个自外向内，单向依赖的架构，如下图所示：
越靠近内层，越变得抽象，越接近设计的核心。越靠近外层，越和具体的平台和实现技术相关。内层的部分完全不知道外层的存在和实现方式，代码只能从外层向内层引用，目的是为了实现层与层之间的隔离。将不同抽象程度的层进行隔离，做到了把业务规则和具体实现分离开。你可以把外层看作是内层的delegate，外层只能通过内层提供的delegate接口来使用内层。
Enterprise Business Rules 代表了这个软件项目的业务规则。由数据实体体现，是一些可以在不同的程序应用之间共享的数据结构。
Application Business Rules 代表了本应用所使用的一些业务规则。封装和实现了用到的业务功能，会将各种实体的数据结构转为在用例中传递的实体类，但是和具体的数据库技术或者UI无关。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f58a5e4679a1fb90548ce2840f4b432f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91ce0c91fe5b92b0dc3694d6e936fabb/" rel="bookmark">
			Git十周岁之际，Linus Torvalds大谈Git开发故事
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		十年前，BitMover决定停止BitKeeper对Linux核心开发的支持，顿时Linux核心开发受到严峻的挑战。Linus Torvalds整个周末不见人影，隔周却如变戏法般的带着Git出现。
Linus Torvalds在2002年起，使用BitMover的版本控制软件BitKeeper管理Linux核心开发，而因为BitKeeper除商业付费版本，仅提供可免费使用但不允许修改释出的精简版本，引起开源社群的不满，如自由软件之父Richard Stallman也严厉批评Linus Torvalds使用非自由软件开发Linux核心。
在2005年Samba文件服务器开发人Andrew Tridgell写了链接BitKeeper存储库的简单程序，被BitKeeper创办人Larry McVoy指控对BitKeeper进行逆向工程，因此决定停止BitKeeper对Linux的支持。顿时Linux核心开发受到严峻的挑战。而Linus Torvalds秉持“自己的版本控制自己写”精神，整个周末不见人影，隔周却如变戏法版的带着Git出现。在Git诞生十周年的近日，Linus Torvalds接受Linux基金会的访问，谈论他对版本控制系统的想法及开发Git的过程。
为何你创造了Git？ 我一直不喜欢做源代码管理，我觉得那是计算机领域中最无趣的一件事（也许数据库管理跟它有的比），我非常讨厌源代码管理。不过BitKeeper（简称BK）出现后，改变我对源代码控制的想法。BK做对了大部分事情，它在本机端有一份完整的存储库，而且采取分布式的做法非常了不起。分布式源代码控制解决了源代码控制常碰到的问题——谁有资格改变源代码。借着提供存储库给每个使用者，BK解决了这个问题。
不过BK也有些缺陷，比方说某些技术决策引起了些问题（像是让人头痛的重新命名），但最大的缺点在于BK不是开放源代码，所以很多人不愿意使用。有几位我们重要的维护人员因为BK可以免费用在开源项目上而使用它，但BK始终没有普遍的被使用，尽管他帮助了Linux核心开发，但BK仍有不足之处。
Andrew Tridgell违反BK使用原则，对BK开始进行逆向工程。我花了几个礼拜（或是几个月），居中协调Tridgell跟Larry McVoy，不过显然没有多大帮助，从那一刻起我决定放弃使用BK，但是我也不想回到以前没有BK的日子。在那时虽然也有一些源代码控制软件想采用分布式的做法，但都没有成气候，它们离我想表现的要求还差一大截，同时我担心源代码完整性即作业流程上的问题，索性决定自己写一个版本控制系统。
你是怎么做到这件事的？花了整个周末熬夜还是在一般时间内把Git搞定？ 其实，你可以去Git源代码的存储库看它如何逐渐成形。我大概花一天让Git能达到自己管理自己的程度（self-hosting），之后我就开始用Git跟Git提交程序代码了。我的大部分工作是在白天完成的，不过也有几天工作到深夜。我觉得最有趣的地方在看到Git如何快速的成形。在Gi t树的第一次提交并没有写很多程序，但是已经实现作出提交程序代码的基本功能。写Git并不会很难，比较难的是思考如何Git组织档案的方式。
我想强调，Git从无到有大概花了我十天（包含我第一次用Git提交核心程序代码），而且我也不是焚膏继晷的完成Git。这都取决于对Git的基本概念是否很清楚，早在着手写Git前，我已经看到其他源代码控制系统的缺陷。我只是不想重蹈覆辙。
Git有满足你的期待吗？它有哪些地方不足？ 我很喜欢Git，他运作的非常好而且满足所有我的需求。他掌管了许多计划并且以超乎想象的速度在成长。不过看看CVS和RCS还存在着，可见在使用者转用其他源代码控制系统上还是有些惰性，不过迟早有一天Git都会取代它们。
你认为Git被广为接受的原因在？ 我想很多人使用其他源代码控制软件都碰到跟我类似的问题，而这些问题让我十分火光，在使用上要修正的几个小问题就让人抓狂。在Git未问世前，没有比较好的解决方法。许多人还不清楚分布式版本控制的好处，甚至还为此争吵不休。不过只要用过Git，一定无法回头用其他东西。因为用Git备份源代码简单又可靠，而且也不必担心测试存储库是否会影响到中间存储库。
Git会一直存在吗？在未来十年内会有其他版本控制系统出现吗？你会不会是那个系统的开发者？ 我不会是那个系统的开发者，也许在十年内我们会看到类似的新东西出现，不过我敢保证，它一定会长得很像Git。Git并非十全十美，但是Git的基本设计做得非常完整，这是其他源代码管理做不到的，我没有装客气。
为什么Git在Linux上运行的很顺？ 一部分原因在于Git是为我们的工作流程量身打造，另一部分是我提了很多次Git的分布式设计，再重复几次都不为过。Git是为有效处理庞大的项目而生，像是Linux。它可以处理大家以前觉得很“困难”的事，不过那些对我来说像是家常便饭。
举个例子，使用其他源代码控制系统要执行合并是非常麻烦的事情，你得精心策划，因为合并兹事体大。这我没有办法接受，因为我每天都要执行一堆合并。使用Git合并只需几分钟。所以基本上Git是为了满足我的需求而写出来的。
很多人说Git是给聪明人用的，Andrew Morton（Linux核心开发者）甚至说：“Git的设计让使用者觉得自己比想象中的笨。”，对此你有什么样的回应？ 这种说法在过去说得通，不过现在不再是了。大家会这样想会有一些原因，但是只有一个原因站得住脚：“同一件事情，Git提供太多方法达成。”
你可以使用Git去做很多事。Git有许多规则，规范你该如何使用Git，而这些规则跟技术关联没有那么强，反而比较着重在多人协作下如何发挥Git的功能。Git是个强大的工具，所以很多人一开始被它吓到，而因为Git的功能是如此强大，每次你都可以用不同的方法完成相同的事情。但一般来说，学习Git的最好方法是从基本开始，熟悉基础后再去摸索不一样的东西。
Git被认为很复杂是有它的历史因素在。其中一个原因是一开始他的确很复杂。一开始使用Git做核心方面的工作时，用户需要配置一些脚本。当时大部分工作都花在开发核心上，比较没有精力去顾及让Git易于使用。诚然，Git是很复杂，不过那也只是头一年左右的事情。
另外一个大家觉得他很复杂的原因是Git与众不同。很多人用CVS十几年，但Git跟CVS可是天差地别，不仅概念上不同，指令也不一样。Git从来没有想要模仿CVS，甚至想要反其道而行。如果你用类似CVS系统一段时间了，会觉得Git很复杂，甚至特立独行。比方说，为什么Git的版本编号不是"1.3.1"，像CVS那样递增的数字不是很好吗？为什么编号是恐怖的40字符HEX吗？
但Git并不是特立独行，而是这些改进是必须的。某些人觉得复杂的原因是时代的递嬗，使用CVS的时代已经过去了。现在很多工程师也许会搞不清楚CVS的操作方法，只是因为他们先学了Git。
如果没有Git，Linux核心的发展会跟现在一样好吗？ 不过一定会有人写出类似Git的分布式源代码控制系统，我们绝对需要像Git的东西。
你对GitHub有什么样的想法？ GitHub提供很棒的程序代码托管服务，这方面我对它没有什么抱怨，不过我对GitHub比较有意见的地方是，GitHub作为一个开发平台，他的提交，拉取要求、议题追踪等功能运行的不是很好。GitHub有太多限制，跟核心比还差得远。一部分的原因是核心如何被建立，另一部分原因是GitHub的接口会养成用户的坏习惯。因为GitHub接口的设计，在GitHub上提交会有质量不好的提交讯息等。在这方面他们做了些改善，不过永远不会像Linux核心的东西。
你觉得Git/GitHub最有趣的用途是？ 使用它们建立一个新的项目非常简单。以前要开启一个项目很让人头疼，但是用Git或GitHub去建立小型项目实在轻而易举。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75ee4a400ecd727dbf13cdb155c20ae6/" rel="bookmark">
			Linux 修改环境变量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		查看PATH：echo $PATH 以添加mongodb server为列
修改方法一： export PATH=/usr/local/mongodb/bin:$PATH
配置完后可以通过echo $PATH查看配置结果。 生效方法：立即生效 有效期限：临时改变，只能在当前的终端窗口中有效，当前窗口关闭后就会恢复原有的path配置 用户局限：仅对当前用户
修改方法二： 通过修改.bashrc文件:
vim ~/.bashrc 在最后一行添上： export PATH=/usr/local/mongodb/bin:$PATH
生效方法：（有以下两种） 1、关闭当前终端窗口，重新打开一个新终端窗口就能生效 2、输入“source ~/.bashrc”命令，立即生效 有效期限：永久有效 用户局限：仅对当前用户
修改方法三: 通过修改profile文件:
vim /etc/profile /export PATH //找到设置PATH的行，添加 export PATH=/usr/local/mongodb/bin:$PATH
生效方法：系统重启 有效期限：永久有效 用户局限：对所有用户
修改方法四: 通过修改environment文件:
vim /etc/environment PATH=”/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games”中加入“:/usr/local/mongodb/bin”
生效方法：系统重启 有效期限：永久有效 用户局限：对所有用户
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09905f11011900a70c719dbab688704d/" rel="bookmark">
			【C&#43;&#43;】C&#43;&#43;大数之运算符重载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、实验项目内容 Modify the “HugeInteger” Class. The new class should also provide the following overloaded operator capabilities: . Overload the addition operator (+), the subtraction operator (-), the multiplication operator (*) and the division operator (/). . Overload output operator (&lt;&lt;). . Overload all the relational and equality operators. You can use the following code to test your class design.
// HugeInt test program. #include &lt;iostream&gt; #include "Hugeint.h" using namespace std; int main() { HugeInt n1( 7654321 ); HugeInt n2( 7891234 ); HugeInt n3( "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/09905f11011900a70c719dbab688704d/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/527/">«</a>
	<span class="pagination__item pagination__item--current">528/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/529/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>