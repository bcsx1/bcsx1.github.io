<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39dcafe55efef518ae2fe4941a35e09e/" rel="bookmark">
			CS109: Probability for Computer Scientists, Summer 2022笔记合集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		维生素C吃多了会上火-个人CSDN博文目录
目录 课程链接课程笔记 课程链接 CS109: Probability for Computer Scientists, Summer 2022
课程笔记 1.CS109: Probability for Computer Scientists笔记1
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a178472119193c89db4e1cd32f04a376/" rel="bookmark">
			内网横向移动——SNMP信息收集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SNMP协议被称为信息的金矿，经常被错误配置，如果可以通过SNMP的安全认证，则可以获取非常丰富的设备信息，且低版本SNMP报文以明文传输，容易被抓包分析。本文主要介绍SNMP的工作原理，以及利用其进行内网横向移动的常见方法。
文章目录 一、相关概念(一) 基本介绍(二) 工作原理1.安全认证方式2.OID &amp; MIB 二、工具使用(一) SNMP扫描(二) 信息获取 一、相关概念 (一) 基本介绍 SNMP (Simple Network Management Protocol) 即简单网络管理协议，默认端口为161/udp和162/udp，该协议通常用于网络监控应用 (PRTG、Zabbix、OpManager等)，用以监控管理网络中运行的服务器、主机和设备。
SNMP版本分为v1、v2c和v3，基本区别：
SNMPv1：协议操作简单，信息传输效率低，仅使用团体字进行身份认证，通信过程中报文以明文传输，造成很大的安全隐患SNMPv2c：在v1的基础上增加了一些协议操作，丰富了数据类型，提高了传输效率，但仍然存在安全问题SNMPv3：增加了基于用户的安全认证和基于视图的访问控制模型，对通信报文进行加密处理，安全认证使用密码，对用户组或团体字实现不同访问权限控制 (二) 工作原理 SNMP管理结构中分为SNMP管理器、SNMP代理和被管理设备3个部分，每一个被管理设备运行着SNMP代理，SNMP代理相当于运行在被管理设备上的网络管理模块，负责定期收集本地设备信息。SNMP管理器通常集成在网络监控应用中，通过“读”操作，与SNMP代理之间采用轮询的方式搜集信息，同时如果设备出现异常，SNMP代理则通过自陷的方式向管理器发出通知，SNMP管理器也可以通过“写”操作修改设备配置信息，更新设备状态，然后将信息整理显示在图形化界面，从而对设备运行状态、性能进行监控和管理。
1.安全认证方式 SNMPv1和v2c版本中，SNMP管理器和代理之间使用团体字进行安全认证，分为“读”和“读/写”两种团体字，分别作为读取信息和写入信息的认证方式，“读”团体字缺省值为public，“读/写”团体字缺省值为private。SNMP代理收到请求数据包后，读取团体字和版本信息，认证成功则进行相应操作，认证失败则不作响应。通信报文以明文传输，通过抓包分析就可以得到团体字信息。
SNMPv3版本中，增加了基于用户的安全认证和基于视图的访问控制模型，安全认证使用密码，对用户组或团体字实现不同访问权限控制，也就是说身份认证是通过用户配置的密码，而团体字仅用于区分访问权限，且通信报文进行加密处理，极大提高了安全性能。
2.OID &amp; MIB OID (Object Identifier) 即对象标识符，以层次化树形结构标识信息节点，由ITU和ISO/IEC制定标准，广泛应用于SNMP、LDAP、X.509等多种协议。SNMP OID定义了所有可能与被管理设备控制和状态相关的数据对象类型，OID树形结构节点信息庞大复杂，一些分支结构集合映射为MIB (Management Information Base)，即管理信息数据库，这样便于统一标准和个性化定制信息，而OID即用于标识MIB分层结构中的对象类型。
MIB有多种标准，对应于OID不同的树形结构分支，不同的标准定义了不同的数据对象类型，目前通用MIB中使用最广泛的是MIB-II {1.3.6.1.2.1}，还有一些企业定制化的信息管理节点 {1.3.6.1.4.1}，目前已有超过5000家企业向IANA申请OID信息节点 (具体参见 IANA)，用作其产品信息管理，OID树形结构如下所示：
OID有多种表达形式，如下所示：
# ASN.1表达 {iso(1) identified-organization(3) dod(6) internet(1) private(4) enterprise(1)} {1 3 6 1 4 1} # OID-IRI表达 /ISO/Identified-Organization/6/1/4/1 # 点号表达 1.3.6.1.4.1 # 名称表达 iso.org.dod.internet.private.enterprises # 缩略表达 SNMPv2-SMI::enterprises SNMPv2-SMI::enterprises.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a178472119193c89db4e1cd32f04a376/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60083611f50c317d7ba088005d240584/" rel="bookmark">
			mysql不是内部或外部命令，也不是可运行的程序或批处理文件解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		依次排查原因
1.**首先可能是环境变量没有配好。**cmd命令行是需要环境变量的。
右击我的电脑–高级系统设置–环境变量–系统变量–Path(点击，添加MySQL的bin目录)
我这里的bin目录是
添加完毕后。
2 启动cmd。注意这里要用管理员启动。
输入cmd，右键–以管理员身份运行。
cd跳转到bin目录下。
输入mysql -uroot -p
再输入密码，就进来了
尝试过程
我首先去“此电脑”→ o→“管理”→ o→“服务”→ o→“MySQL80”，先尝试手动启动MySQL80服务，出现了上述图片的情况。
重启电脑，再次重复步骤1，同样的情况。（× n 次 imes n次cdots×n次）
在网上找教程，尝试创建安装路径下的my.ini文件，接着在PowerShell窗口依次运行了
mysqld -remove
mysqld -install
mysqld --initialize
网上说一般到这就可以解决了，but not me(hhh)。传送门
查看端口3306端口情况：
在PowerShell输入：
netstat -ano
端口占用，发现没有占用3306端口的进程，失败。
将NETWORK SERVICE添加到Administrators组中：“此电脑”→ o→“管理”→ o→“系统工具”→ o→“本地用户和组”→ o→“组”，在Administrators中添加了"NETWORK SERVICE"，保存，重复步骤2，没用。
顺便发一个修改时区的命令
//---------&gt;解决MySQL时区问题
连接数据库，输入mysql -hlocalhost -uroot -p回车输入密码
输入show variables like’%time_zone’;回车，显示时区配置
输入set global time_zone = ‘+8:00’;回车
最后 深知大多数初中级Java工程师，想要提升技能，往往是自己摸索成长或者是报班学习，但对于培训机构动则近万的学费，着实压力不小。自己不成体系的自学效果低效又漫长，而且极易碰到天花板技术停滞不前！
因此收集整理了一份《Java开发全套学习资料》送给大家，初衷也很简单，就是希望能够帮助到想自学提升又不知道该从何学起的朋友，同时减轻大家的负担。
小编已加密：aHR0cHM6Ly9kb2NzLnFxLmNvbS9kb2MvRFVrVm9aSGxQZUVsTlkwUnc==出于安全原因，我们把网站通过base64编码了，大家可以通过base64解码把网址获取下来。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be36ae9a35810ad52c4d32b64a092c3b/" rel="bookmark">
			@PutMapping、@PatchMapping、@DeleteMapping解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		@PutMapping、@PatchMapping、@DeleteMapping解析 1. @PutMapping put请求是从客户端向服务端发送数据，但与post不同的是，put真正的目的其实是执行大规模的替换操作，而不是更新操作。
假如，我们有一个订单，我想要更新某个订单的地址信息，这时，我们就可用put请求来完成操作。
@PutMapping("/{orderID}") public Order putOrder(@RequestBody Order order){ return repo.save(order) //服务端用来保存更新的order } 从语义上讲，put意味着"将数据放到这个URL上"，其本质就是替换已有的数据。我们如果省略了订单上的某个属性，那么该属性的值就应该被NULL所替代，甚至订单中的某个物品的实体数据也应一起重新设置，否则它们将从订单中移除。
2. @PatchMapping patch的目的是对资源数据打补丁或局部更新，举个栗子：
@PatchMapping(path="/{orderId}",consumes="application/json") public Order patchOrder(@PathVariable("orderId") Long orderId, @RequestBody Order patch){ Order order = repo.findById(orderId).get(); if(patch.getDeliveryName()!=null){ order.setDeliveryName(patch.getDeliveryName()); } ...... //下列都是类似的代码 return repo.save(order); } 上面的代码中，允许我们，只有当修改的内容非null时，才在本地数据库中的对应属性上修改，如果客户端没有改动，则属性不动，即对资源数据进行一个局部属性的更新，不会直接对整个实体进行更新。
注意，在GetMapping和PatchMapping中，引用的路径请求都是要变更的资源。
3. @DeleteMapping 有些时候，有的数据可能不再需要了，客户端可以通过HTTP DELETE请求来要移除某个资源。
而 @DeleteMapping 注解就能够非常便捷的声明能够处理DELETE请求的方法。举个栗子：
我们想要有一个能够删除订单资源的API，下面的方法就能实现这一点：
@DeleteMapping("/{orderId}") @ResponseStatus(code=HttpStatus.NO_CONTENT) public void deleteOrder(@PathVariable("orderId") Long orderId){ try{ repo.deleteById(orderId); }catch(EmptyResultDataAccessException e){} } 在这个方法中，真正负责删除订单的是里面的代码，@DeleteMapping指定deleteOrder()方法处理针对“/orders/{orderId}的DELETE请求。
在该方法中，需要注意的是，@ResponseStatus注解确保的是HTTP状态码为204。对于已经不存在的资源，我们没有必要返回任何的资源数据给客户端，因此DELETE请求中通常没有响应体，我们要以HTTP状态码的形式让客户端知道不要期望得到任何的内容。
最后 深知大多数初中级Java工程师，想要提升技能，往往是自己摸索成长或者是报班学习，但对于培训机构动则近万的学费，着实压力不小。自己不成体系的自学效果低效又漫长，而且极易碰到天花板技术停滞不前！
因此收集整理了一份《Java开发全套学习资料》送给大家，初衷也很简单，就是希望能够帮助到想自学提升又不知道该从何学起的朋友，同时减轻大家的负担。
小编已加密：aHR0cHM6Ly9kb2NzLnFxLmNvbS9kb2MvRFVrVm9aSGxQZUVsTlkwUnc==出于安全原因，我们把网站通过base64编码了，大家可以通过base64解码把网址获取下来。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/737a5810808b11de494a83522c5daa73/" rel="bookmark">
			为什么要配置jdk环境变量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们知道配置jdk环境变量时，需要经过3个步骤 1）新建JAVA_HOME
2）新建classpath
3）在path中添加bin文件
但是我们不知道的是classpath从jdk1.4之后完全可以不用配置
首先，我们得明白为什么要配置jdk环境变量
在编译和运行java程序时必须经过两个步骤
1）将原文件编译成字节码
2）解释执行平台无关的字节码程序
上面这两个步骤分别需要使用java和javac两个命令，启动Windows操作系统的命令行窗口时，依次输入java和javac命令，将看到以下输出（没有配置jdk环境变量）
这意味着还不能使用这两个命令，这是因为：虽然已经在计算机里安装jdk，而jdk安装路径下也包含了java和javac命令，但计算机不知道去哪里找这两个命令。
计算机如何查找命令？Windows操作系统根据Path环境变量来进行查找。Path环境变量的值是一系列路径，Windows操作系统将在这一系列的路径中一次查找命令，如果能找到这个命令，则该命令是可执行的：否则将出现’XXX‘不是内部或外部命令，也不是可运行的程序或批处理文件。（Windows操作系统不区分大小设置Path或PATH并没有区别）
同理，classpath环境变量的作用是什么呢？当使用“java Java类名”命令来运行Java程序时，jre到哪里去搜索这个Java类呢？可能会有人说，当然是当前路径啊，这个回答很聪明。但是jdk1.4以前版本的jdk都没有设计这个功能
如果使用jdk1.4以前版本的jdk，则需要在classpath环境变量中添加点（.），用来告诉JRE需要在当前路径下搜索Java类，除此之外，编译和运行Java程序还需要JDK的lib路径下dt.jar和tools.jar文件中的Java类，因此还需要把这两个文件也添加到classpath环境变量里
现在基本流行用的jdk版本都是jdk8或往上，所以classpath可以不用配置
群主已测，无误
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3eefb621a6f88c600c4bddab0a7a073f/" rel="bookmark">
			keepalived&#43;lvs&#43;tomcat&#43;nfs架构部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、实验环境准备
二、配置负载调度器lvs(主192.168.59.11，备192.168.59.10)
安装ipvsadm工具
配置VIP地址(主192.168.59.100)
调整内核(proc)响应参数
配置负载分配
lvs2（备192.168.59.10）相同配置 （把上面再执行一遍）
三、部署共享存储（NFS：192.168.59.14）
安装nfs和rpcbind
创建共享目录并设置权限
输入页面内容
设置共享目录并发布共享
备lvs：192.168.59.10相同配置
四、部署节点服务器(tomcat1,tomcat2)
配置虚拟VIP地址(vip：192.168.59.100) {两台节点服务器都需要配置}
启动lo:0网卡，添加VIP本地访问路由
设置系统自动识别，并设置执行权限
调整内核的arp响应参数以阻止更新VIP的MAC地址，避免发生冲突
安装tomcat、nfs、rpcbind
web2和web1一样的配置，但是注意修改IP
web1：挂载共享目录
web2：挂载共享目录
到这里我们小小的测试以下
五、部署keepalived
修改配置文件keepalived.conf（这步主备lvs操作一致）
配置主lvs（192.168.59.11）
配置备lvs（192.168.59.10）
六、最终测试
总结
一、实验环境准备 DR服务器(LVS)：主-192.168.59.11 备-192.168.59.10 tomcat1：192.168.59.12 tomcat2：192.168.59.13 VIP(虚拟回环)：192.168.59.100 NFS：192.168.59.14 客户端：192.168.59.90 因为是在内网环境中我们需要配置本地yum仓库，并且关闭防火墙
#!/bin/bash ########关闭防火墙############ systemctl stop firewalld systemctl disable firewalld setenforce 0 #######yum仓库######### mount /dev/cdrom /mnt mkdir /etc/yum.repos.d/bak mv /etc/yum.repos.d/*.repo /etc/yum.repos.d/bak touch /etc/yum.repos.d/local.repo echo " [local] name=local baseurl=file:///mnt enabled=1 gpgcheck=0 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3eefb621a6f88c600c4bddab0a7a073f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b2df688677b6a8ea6eb0bcb470015b3/" rel="bookmark">
			FFMPEG常用命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		FFmpeg编码和支持 FFmpeg源代码中包含的编码格式很多，常见不常见的都可以在编译皮质列表中见到，可以通过的编译配置命令： ./configure --list-encoders 常见的编码器的格式有：AAC，AC3，H.264，H.265、MPEG4、MPEG2VIDEO、PCM以及FLV1的编码器支持
FFmpeg的解码器支持，解码的主要作用是在输入的时候进行解码，也可以理解为将压缩过的编码进行解压缩，其可以通过编译配置命令查询。 ./configure --list-decoders 通过查询相关命令可以发现常见的编码格式有：H.264、H.265、MPEG4以及MP3
FFmpeg的封装支持，其封装指将压缩后的编码封装到容器序列中，常见的容器格式可以通过配置命令查询： ./configure --list-muxers 从封装（复用）格式所使用的的信息可以看到，FFmpeg支撑生成裸流文件，如H.264，AAC，PCM以及常见的某些格式：MP3、MP4，FLV，M3U8
FFmpeg的解封装支持，解封装支持是指将读入的容器格式解开，将里面压缩的音频流，视频流以及字幕流、数据流提取出来，通过配置相关命令： ./configure --list-demuxers 从解封装的格式信息可以看到，支持解封状的的信息特别多有：MP3、MP4，FLV、MOV，AVI、（image）
FFmpeg的通信协议支持，FFmepg不仅仅支持本地的多媒体支持处理，而且还支持网络流媒体处理，相关的流媒体协议可以通过配置命令查询： ./configure --list-protocols 从协议的信息中可以看到，其支持的相关的信息包括，MMS，HTTP，HTTPS，HLS（M3U8），RTMP以及RTP甚至TCP和UTP
FFmpeg工具的使用基础 FFmpeg中常用的工具主要有FFmpeg、ffprobe，ffplay；他们分别作为多媒体的编解码工具，内容分析工具以及播放器。
ffmpeg:是一个非常快速的视频和音频转换器，也可以从实时音频/视频源中获取。它还可以在任意采样率之间进行转换，并使用高质量的多相滤波器动态调整视频大小.
ffmpeg信息查询的部分的主要参数具体如下所示： usage:ffmpege [options] [[ infile options] -i infile] ... {[outfile options] outfiles}... #执行命令 ffmget -formats 查看当前使用ffmpeg支持封装和解封装支持的格式 D. = Demuxing supported .E = Muxing supported -- D 3dostr 3DO STR E 3g2 3GP2 (3GPP2 file format) E 3gp 3GP (3GPP file format) D 4xm 4X Technologies E a64 a64 - video for Commodore 64 D aa Audible AA format files D aac raw ADTS AAC (Advanced Audio Coding) DE ac3 raw AC-3 D acm Interplay ACM D act ACT Voice file format D adf Artworx Data Format D adp ADP D ads Sony PS2 ADS E adts ADTS AAC (Advanced Audio Coding) DE adx CRI ADX ffmpeg -encoders 可以查看是否支持某种编码格式 V.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b2df688677b6a8ea6eb0bcb470015b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef8d1faa037b6d9089cae0cd7f4c2ff9/" rel="bookmark">
			Java 实现单例模式的七种写法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		单例模式（Singleton Pattern） 是一种常用的软件设计模式，该模式的主要目的是确保某一个类只有一个实例存在。当你希望在整个系统中，某个类只能出现一个实例时，单例对象就能派上用场。
比如，某个服务器程序的配置信息存放在一个文件中，客户端通过一个 AppConfig 的类来读取配置文件的信息。如果在程序运行期间，有很多地方都需要使用配置文件的内容，也就是说，很多地方都需要创建 AppConfig 对象的实例，这就导致系统中存在多个 AppConfig 的实例对象，而这样会严重浪费内存资源，尤其是在配置文件内容很多的情况下。
事实上，类似 AppConfig 这样的类，我们希望在程序运行期间只存在一个实例对象。
在 Java中，单例设计模式分类两种：
饿汉式：类加载就会导致该单实例对象被创建懒汉式：类加载不会导致该单实例对象被创建，而是首次使用该对象时才会创建 在 Java中，我们可以用多种方法来实现单例模式：
1. 饿汉式-方式1（静态变量方式）
2. 饿汉式-方式2（静态代码块方式）
3. 懒汉式-方式1（线程不安全） 4. 懒汉式-方式2（线程安全）
5. 懒汉式-方式3（双重检查锁）
6. 懒汉式-方式4（静态内部类方式）
7. 枚举方式
1. 饿汉式-方式1（静态变量方式） /** * 饿汉式 * 静态变量创建类的对象 */ public class Singleton { // 私有构造方法 private Singleton() { } // 在成员位置创建该类的对象 private static Singleton instance = new Singleton(); // 对外提供静态方法获取该对象 public static Singleton getInstance() { return instance; } } 说明：该方式在成员位置声明Singleton类型的静态变量，并创建Singleton类的对象instance。 instance对象是随着类的加载而创建的。如果该对象足够大的话，而一直没有使用就会造成内存 的浪费。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef8d1faa037b6d9089cae0cd7f4c2ff9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6af7d3ab8cac8e0113d6967531a83a5d/" rel="bookmark">
			gitlab CI/CD 持续集成 部署 一文到底
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		gitlab CI/CD (tip: 要了解一下gitlab ci yml的语法 、 shell 脚本 、Liunx的基本命令)
第一部分、准备Linux操作系统 安装Linux操作系统或使用虚拟机 注意是64位 CentOS 7 以上版本
采用虚拟机的时候网络适配器要选择NAT 否则虚拟机每次重启IP地址都会变换 后面需要改很多地方的服务器IP地址
第二部分、在Liunx系统上搭建docker环境 1、使用官方的安装脚本命令 curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun 2、安装后使用命令 systemctl start docker 启动docker
3、使用命令 systemctl status docker 查看docker状态（绿色为正在运行）
4、安装所需要的软件包 sudo yum install -y yum-utils device-mapper-persistent-data lvm2
5、配置阿里云的镜像仓库进行加速
yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 6、重新启动docker 7、运行 docker run hello-world 阿里云镜像配置成功情况如下图
可能会出现运行 docker run hello-world 后长时间停留在 Unable to find image 'hello-world:latest' locally 不往下进行 需要Ctrl+C 进行退出 现在阿里云镜像可能没有配置成功 需要手动配置一下
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6af7d3ab8cac8e0113d6967531a83a5d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32a5425d711469f4ecdb794b974ad06a/" rel="bookmark">
			华为悦盒烧写Ubuntu系统刷机教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 随着网络电视的发展，机顶盒出现在我们每家每户的日常生活中，用电视机顶盒打造一个小电脑，价格低廉，功耗低，供研究学习使用是一个非常好的选择。本文章以华为ec6108v9系列的机顶盒为例，为它安装上linux系统，详细描述NAS系统打造过程。
一、前期准备 本机window7以上的系统
华为悦盒EC6108V9（HI3798MV100） 4G版 可下载编译好的固件刷机
串口助手XCOM v2.6 ：检测串口连接是否正常
华为Hitool：烧录软件，将系统镜像写入主板的emmc的。
二、操作步骤 1.拆机 把板子拆下来之后，找到板上接串口的四个小孔分别是：VCC、TX、RX、GND 可能需要的材料：CH340 USB转TTL串口模块、网线、母对公杜邦线(3根)
或者使用PL2303 USB转TTL串口模块（win10需要额外下载一个它的驱动）
将串口模块与其盒子的TX、RX、GND三个小孔焊接起来
串口是否连接正确的方式是通过串口助手检验串口是否能接受发送消息。
2.串口烧写软件 连接好之后如图（网线、电源线、HDMI、串口）
在windows中查看串口驱动
启动hitool串口烧写软件选择芯片Hi3798MV100，进入界面 修改PC与板端设置
本机PC服务器ip为自己windows电脑的ip，板端ip默认为X.X.X.0（两者在同一个局域网段中）
如电脑ip为192.168.1.3，板端ip则为192.168.1.0
选择烧写EMMC，浏览.xml文件
插上网线，断电，开始烧写
它会提示你是否上电，上电之后进度条开始加载
等待7分钟左右录入成功
这是几次刷机时的图（最好不要下载最新版本的hi3798mv100-20220530，它目前还没有更新相应的hi3798mv100海思NAS系统WIFI驱动） 因此当时我们安装的是hi3798mv100-20220530，后来重新刷了一遍hi3798mv100-20220403
烧写成功之后，登录路由器查看板端的ip地址，有线ip:192.168.3.15
而后安装了一个wifi驱动，它的无线ip为192.168.3.17
访问板端ip地址进入主页面
通过远程连接软件，即可直接操作Linux系统（有线、无线均能通过ssh远程连接）
感谢神雕大佬的技术支持。 如果身边有闲置的机顶盒，也可以尝试尝试啦！
两个工具的安装网址：
http://xz.w10a.com/small/HiTool.7z
https://histb.com/
参考神雕大佬教程：
https://www.right.com.cn/FORUM/thread-7269215-1-1.html
https://www.znds.com/tv-1212880-1-1.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/157b82c465697c393084506d78f06b73/" rel="bookmark">
			2.5_2 Teradata数据库 -- 常用系统表之 DBC.Columns 表字段信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一.前言二.数据字典三. DBC.Columns : ColumnType 映射关系3.1 思路及步骤3.2 特殊类型的表 Method ,Function 四.ColumnType 映射关系汇总五.SQL获取字段信息（结论）附录DBC.Columns建表语句VARCHAR 字段长度测试长度、精度、标度编码方式对比 (ASCII/IOS8859-1/UNICODE/UTF-8/GBK)UTF-8和Unicode与GBK的关系 相关文章参考文章 相关链接
目录 DBC.Columns 提供有关表 (Table)或视图 (View))的列、存储过程(Produce)的参数、用户定义类型的属性、用户定义方法 (Method)的参数、宏 (Macro)和用户定义的函数 (Function)的信息
参考（Teradata Database Data Dictionary：Teradata数据库数据字典）
DBC.Columnsv 与上视图结构类似，本文没有深入研究。
一.前言 在进行推送工作时，一般从S层推送原表至下游服务器
每次都需要通过SHOW TABLE的方式获取原表的建表语句，在通过手工处理
例：
SHOW TABLE SDDL.ACS_DQ01; CREATE MULTISET TABLE SDDL.ACS_DQ01 ,NO FALLBACK , NO BEFORE JOURNAL, NO AFTER JOURNAL, CHECKSUM = DEFAULT, DEFAULT MERGEBLOCKRATIO ( SRC_SYS CHAR(3) CHARACTER SET UNICODE CASESPECIFIC TITLE '源系统简码', SRC_OWNER VARCHAR(50) CHARACTER SET UNICODE CASESPECIFIC TITLE '所属用户', TABLE_NAME VARCHAR(200) CHARACTER SET UNICODE CASESPECIFIC TITLE '源系统表名', COL_NAME VARCHAR(100) CHARACTER SET UNICODE CASESPECIFIC TITLE '字段英文名', COL_DESC VARCHAR(4000) CHARACTER SET UNICODE CASESPECIFIC TITLE '字段描述', COL_ID INTEGER TITLE '字段顺序', COL_DATA_TYPE VARCHAR(50) CHARACTER SET UNICODE CASESPECIFIC TITLE '字段数据类型', COL_DATA_LENGTH BIGINT TITLE '字段数据长度', COL_DATA_SCALE INTEGER TITLE '字段数据精度', DATA_DT_SRC DATE FORMAT 'YYYY-MM-DD' TITLE '源系统数据日期', REC_SEQ BIGINT TITLE '记录条数') NO PRIMARY INDEX ; 清洗第一步（Notepad++）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/157b82c465697c393084506d78f06b73/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ddbad1b7175de2fdb11a5bfafe8fa1ab/" rel="bookmark">
			LAA ： random fourier features的又一应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在论文NFormer: Robust Person Re-identification with Neighbor Transformer中的Landmark Agent Attention是对random fourier features 随机傅里叶特征 的又一在attention 降维上的应用：
与测量高维表示向量之间的相似性不同，我们提出了一种更有效的方法来获得近似的亲和矩阵A。其关键思想是将高维表示向量z映射到低维编码空间，从而使等式（3）中的亲和性计算更加高效，这是受随机傅里叶特征启发的:
方形的水平方向为矩阵的第一维度，数值方向为第二维度。(The horizontal side of the rectangles indicates the first dimension of the according matrices, while the vertical side indicates the second dimension. )
输入由 z ∈ R N × d z ∈ R^{N×d} z∈RN×d表示, the query, key and value 矩阵 q , k , v ∈ R N × d q, k, v ∈ R^{ N×d} q,k,v∈RN×d 由线性映射生成.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ddbad1b7175de2fdb11a5bfafe8fa1ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7f978478ad503882b47a1edbb24696a/" rel="bookmark">
			关于Java实例化对象写在构造函数外面和里面的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java中new出来的对象都存在堆内存中，指向对象的变量存在于栈中，而new对象的常量在方法区。如以下例子：
Integer inte = new Integer(10);
我们首先要知道：关于无参构造中的作用：
1、无参构造方法一般是用来初始化变量或者对象的等; 2、Java会自动给每个类添加一个默认的无参构造方法，但在自己有写有参构造的情况下，最好再添加一个无参构造方法，否则程序报错。
那么我们在写代码的过程中，会有两种方式去创建对象，其中第一种就是：先声明实例变量，然后在无参构造中创建对象；第二种是：直接new对象。我们要知道这两者的区别是，如以下例子：
1、前者（被注释的内容）是先在栈空间中申请了变量的存储空间，只有当调用无参构造的时候，才会将无参构造的对象在堆内存中申请存储空间；
2、而后者则是同时在栈与堆中申请了内存空间。
虽说两者所占内存空间是相同的，但是在以后的开发中代码越写越多的情况下，如若每次都直接初始化对象，后面发现有的方法不需要使用了，这样就会导致内存溢出。所以一般都是先声明变量，告诉自己已经有这个对象了，先不需要实例化这个对象。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f04479fd7dfe34ba909872255e8c6f43/" rel="bookmark">
			【ArcGIS小技巧】ArcMap启动太慢？清理一下ArcToolbox的缓存可以加速
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果你也想赚钱，实现财务自由，但接触不到优质的人脉和资源，可以到公June浩：**成长home**，发"资源" ，就会看到我吐血整理的168条保姆级零基础吸金秘籍，跟着我一起亲历毕业5年、创业3年、从0到1000万的嗨翻全场的爆发式成长全过程。
ArcMap使用时间稍微长一些以后，启动就会变得非常非常慢，让人质疑自己的电脑已经跟不上时代也追不上时间了，很恼人的有木有！
最近才发现了一个未被别人发掘到的ArcMap加速方法，就是清理Toolbox中的结果文件。如果使用工具箱较多的话，该文件夹中的文件总计可以达到几百兆，会很显著拖慢程序的运行速度。
我的本机缓存地址是“C:\Users\esa72\AppData\Roaming\ESRI\Desktop10.5\ArcToolbox\History”，将该目录下的所有文件统统删除即可，根据电脑不同，缓存的地址可能也会不同，自己找找看！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec34e43a2f68e8ce6aca47ae8f584150/" rel="bookmark">
			计算机视觉基础学习-图像拼接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、基础理解 首先本文介绍的图像拼接并非对尺寸相同的图片进行简单拼接，而是基于全景图的拼接
普通相机拍摄图像时，无法兼顾相机视场与视场中单个物体的分辨率问题，而全景相机普遍价格昂贵，
不适用于低成本的一般性场景。为了使用普通相机获取宽视角，甚至是 360°全景图像，人们提出了图像拼接技术。图像拼接技术是指将含有重叠部分的两幅或多幅图像，通过图像预处理、图像配准和图像融合技术，拼接成一幅包含各图像信息的高分辨率、宽视角图像的技术。
图像拼接是将同一场景的多个重叠图像拼接成较大的图像的一种方法
基本思想：图像拼接并非简单的将两张有共同区域的图像把相同的区域重合起来，由于两张图像拍摄的角度与位置不同，虽然有共同的区域，但拍摄时相机的内参与外参均不相同，所以简单的覆盖拼接是不合理的。因此，对于图像拼接需要以一张图像为基准对另外一张图像进行相应的变换（透视变换），然后将透视变换后的图像进行简单的平移后与基准图像的共同区域进行重合。
图像拼接技术就是将数张有重叠部分的图像（可能是不同时间、不同视角或者不同传感器获得的）拼成一幅无缝的全景图或高分辨率图像的技术。图像拼接在医学成像、计算机视觉、卫星数据、军事目标自动识别等领域具有重要意义。
图像配准（image alignment）和图像融合是图像拼接的两个关键技术。图像配准是图像融合的基础,而且图像配准算法的计算量一般非常大,因此图像拼接技术的发展很大程度上取决于图像配准技术的创新。早期的图像配准技术主要采用点匹配法,这类方法速度慢、精度低,而且常常需要人工选取初始匹配点,无法适应大数据量图像的融合。图像拼接的方法很多,不同的算法步骤会有一定差异,但大致的过程是相同的。
2、图像拼接基础步骤 图像拼接技术的基本流程为：图像采集与获取、图像预处理、图像配准、图像融合等。
图像获取——指使用各类图像采集设备进行图像采集和获取。方式有平移式获取、旋转式获取、手持式获取等图像预处理——是图像配准前的预备工作，消除影响图像配准精度的无关信息，提升图像配准效率。图像预处理包括图像去噪、几何校正、均匀颜色等。图像预处理的目的是提高配准精度、降低配准难度，包括调整灰度差异、去噪、几何修正以及将两幅图像投影到同一坐标系等基本操作图像配准——将多幅图像进行匹配、叠加的过程。图像配准的精度十分重要，因此算法既要保证配准精度，又不能计算量过大。应当能够估计待拼接图像之间可能存在的缩放、旋转、仿射变换、投影变换以及亮度和颜色等变化。是计算出两幅图像间的空间变换模型并进行空间变换，使两幅图像的重叠部分在空间上对准，是图像拼接的关键．图像之间的空间变换关系包括: 平移、旋转、尺度缩放、仿射变换、投影变换，其中投影变换更具有普遍性图像融合——是由于进行图像配准操作，可能由于算法误差累积、色彩差异等原因，导致圖像出现拼接缝隙，以及整幅图像的颜色亮度差异。因此在图像配准处理后需要进行图像融合处理，矫正差异，消除缝隙，才能使拼接的图像更加自然。图像融合的目的是得到无缝的高质量图像．在不损失原始图像信息的前提下，消除接缝与亮度差异，实现拼接边界的平滑过渡． 其中，图像配准是其中最关键的一步
3、图像配准技术 图像配准是计算出两幅图像间的空间变换模型并进行空间变换，使两幅图像的重叠部分在空间上对准，是图像拼接的关键．图像之间的空间变换关系包括: 平移、旋转、尺度缩放、仿射变换、投影变换，其中投影变换更具有普遍性。
图像拼接的关键是精确找出相邻两张图像中重叠部分的位置，然后确定两张图像的变换关系‚即图像配准。由于视角、 拍摄时间、分辨率、光照强度、传感器类型等的差异‚待拼接的 图像往往存在平移、旋转、尺度变化、透视形变、色差、扭曲、运 动目标遮挡等差别‚配准的目的就是找出一种最能描述待拼接 图像之间映射关系的变换模型。目前常用的一些空间变换模 型有平移变换、刚性变换、仿射变换以及投影变换等。
假设图像 f1( x，y) 、f2( x，y) 存在投影变换关系，则用以下齐次方程表示:
其中: m0、m1、m3 和 m4 共同表示旋转角度和缩放尺度; m2 和 m5 分别表示 x 方向与 y 方向上的平移量; m6 和 m7 分别表示 x 方向和 y 方向上的变形量．图像配准的关键是用上式确定空间变换模型 M 的参数．
根据各参数的意义及不同变换模型的特点‚对矩阵 Ｍ 作 相应简化就可以得到各变换模型的参数矩阵。
图像配准技术分类如下，图像配准可以分为基于频域和基于空间域的。
3.1 基于频域的 基于频域的图像配准方法主要利用傅里叶变换把图像先变换到频域再做处理。
这类方法需要在频域中进行计算，以便找到一对图像之间的最佳变换参数。这些算法利用相位相关的特性来配准图像。
基于傅里叶梅林变换(Fourier-MellinTransform,FMT)的图像配准算法就是一种比较典型的基于频域的图像配准算法，该算法的
优点是速度比较快。Kuglin和Mines提出的相位相关法1以及Castro和Morandi提出的扩展相位相关法都是基于频域的图像配准算法。
基于频域的算法可克服相关性噪声和频率噪声, 可以大大减小几何失真对匹配性能的影响‚计算速度快,对小平移量、旋转及变尺度图像的拼接较适合,但是在两张图像重叠部分不大的情况下结果较差
使用互功率谱来检测变换。
(a)和(b)源图像，它们之间有位移；
(c )和(d)是(a)和(b)的光谱；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec34e43a2f68e8ce6aca47ae8f584150/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17b00cdd4ff982032f7a1d0fe127223b/" rel="bookmark">
			Redis缓存入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		官方网站：Redis Redis下载地址：Releases · tporadowski/redis · GitHub。 Redis可视化工具 Redis Desktop Manager 一、下载 Redis Desktop Manager 百度网盘：redis-desktop-manager-0.8.8.384.exe
文件名称：redis-desktop-manager-0.8.8.384.exe
开发：
1.在NuGet中引用：Microsoft.Extensions.Caching.StackExchangeRedis
2.在AppSetting.json中配置Redis连接字符串RedisConnection
{ "ConnectionStrings": { "RedisConnection": "127.0.0.1:6379" } } 3.在Program中注册服务
//注册Redis服务 builder.Services.AddSingleton&lt;IConnectionMultiplexer&gt;(opt =&gt; ConnectionMultiplexer.Connect(builder.Configuration.GetConnectionString("RedisConnection"))); 4.在客户端使用Redis，设置缓存
using StackExchange.Redis; using System.Reflection.Metadata; using System.Text.Json; using WebApplication1.Models; namespace WebApplication1.Data { public class RedisPlatformRepo : IPlatformRepo { private IConnectionMultiplexer _redis; //依赖注入连接复用 public RedisPlatformRepo(IConnectionMultiplexer redis) { _redis = redis; } //创建Redis键值对 public async Task createPlatform(Platform plat) { if (plat == null) { throw new ArgumentNullException(nameof(plat)); } var db = _redis.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/17b00cdd4ff982032f7a1d0fe127223b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5cfa230ff390db7e949108c7234acbc/" rel="bookmark">
			无人机飞控算法-姿态估计-欧拉角-旋转矩阵-四元数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		# 无人机飞控算法-姿态估计 此系列记录了我理解的卡尔曼滤波从0到1的过程，从姿态估计到位置估计，我们从核心点一个个出发，并结合实际模块的应用来一一揭开卡尔曼滤波的神秘面纱。
提示：在系列文章中，我参考了大量CSDN，知乎，简书等其他朋友的各种文档资料，并从中获益良多，对此表示非常感谢！在更新的过程中不免出现很多错误，希望大家能够及时指出和交流，一起学习，一起进步！
@TOC
前言 作为一个非控制类出生的通信工程师，半路出家，还是挺困难的，需要学习的知识很多，主要是卡尔曼滤波方面的，包含微积分、线性代数、概率统计论、信号与系统、控制论等等。在无人机里飞控是其中重要的组成部分之一，而飞控的核心就是算法，主要包括姿态估计算法，导航控制算法，PID控制算法，路径规划算法等。此系列从姿态估计算法入手，通过IMU的姿态解算来学习姿态估计算法究竟是为何物。
推荐：学习基础知识我推荐一下3blue1brown，在B站上可以搜索到他们的课程，讲的很生动，可以帮您快速理解一些核心知识。
一、姿态估计是什么？ 想象一下，你拿着一根平衡杆，走在独木桥上，你该如何操控你手里的平衡杆才能使你不掉下去呢？从主观意识着想，其实挺简单的，如果身子往左倾斜，我们就把杆子向右移，如果身子往右倾斜，我们就把杆子向左移。要实现这个目的，首先我们是不是要知道身体现在究竟是左倾斜还是右倾斜呢？这就是姿态估计（Attitude Estimator）。那如何检测姿态呢？这就需要传感器了，在人类的身上，大脑充当了这个角色，在机器上，我们通过惯性测量单元（IMU）来测量姿态。
二、惯性测量单元（IMU） 1.陀螺仪 陀螺仪是利用高速回转体的动量矩敏感壳体相对惯性空间绕正交于自转轴的一个或二个轴的角运动检测装置。利用其他原理制成的角运动检测装置起同样功能的也称陀螺仪。陀螺仪可感测一轴或多轴的旋转角速度，可精准感测自由空间中的复杂移动动作，因此，陀螺仪成为追踪物体移动方位与旋转动作的必要运动传感器。不像加速器与电子罗盘，陀螺仪不须借助任何如重力或磁场等的外在力量，能够自主性的发挥其功能。所以，从理论上讲只用陀螺仪是可以完成姿态导航的任务的。陀螺仪的特性就是高频特性好，可以测量高速的旋转运动。缺点是存在零点漂移，容易受温度/加速度等的影响。
2.加速度计 加速器可用来感测线性加速度与倾斜角度，单一或多轴加速器可感应结合线性与重力加速度的幅度与方向。含加速器的产品，可提供有限的运动感测功能。加速度计的低频特性好，可以测量低速的静态加速度。在我们的飞行器上，就是对重力加速度g（也就是前面说的静态加速度）的测量和分析，其它瞬间加速度可以忽略。记住这一点对姿态解算融合理解非常重要。当我们把加速度计拿在手上随意转动时，我们看的是重力加速度在三个轴上的分量值。加速度计在自由落体时，其输出为0。为什么会这样呢？这里涉及到加速度计的设计原理：加速度计测量加速度是通过比力来测量，而不是通过加速度。
3.磁力计 电子罗盘也叫数字指南针，磁力计，是利用地磁场来定北极的一种方法。现在一般有用磁阻传感器和磁通门加工而成的电子罗盘。电子罗盘可由地球的磁场来感测方向。运用电子罗盘的消费性电子产品应用，包含在手机的地图应用程序显示正确方向，或为导航应用程序提供前进方向数据。然而，电子设备或建筑材料的磁场干扰，比地球磁场来得强，导致电子罗盘传感器的输出值，较容易受到各种环境因素的影响，尤其在室内更是如此，因此，电子罗盘须要透过频繁的校正，才能维持前进方向数据的准确度。
在捷联式惯导中，一般集成6轴陀螺仪和加速度计，有一些也集成了磁力计，但是一般情况下，我们都使用外部磁力计，因为磁力计在内部很容易受到电磁干扰。
三、欧拉角 1.坐标系 在描述姿态角度的时候一定要确定好坐标系，旋转轴，旋转顺序，旋转方向，如果不确定好这些，那最后得到的旋转矩阵一定是千姿百态，保证你看的眼花缭乱，不明所以，一会又对了，一会儿又错了。关于坐标系的概念和分类大家可以去看相关文档,这里我们只讲和飞控相关的坐标系.
参考坐标系（导航系） 在飞控里常用的导航坐标系有两种：东北天和北东地。
东北天 东北天用ENU表示XYZ轴
北东地 北东地用NED表示XYZ轴
载体坐标系（机体系） 在飞控里常用的载体坐标系也有两种：右前上和前右下。
右前上 右前上表示载体坐标系的XYZ轴
前右下 前右下表示载体坐标系的XYZ轴
对应关系 ENU对应右前上
NED对应前右下
一般在惯导里用ENU较多，在控制领域里用的NED较多，飞控里也用的NED坐标系。
2.欧拉角和姿态角 欧拉角是描述旋转的一种方式，那姿态角呢？姿态角属于欧拉角的一种特殊形式，我们一般定义姿态角为偏航（Yaw），俯仰（Pitch），横滚（Roll）。在不同的载体坐标系里，姿态角对应也不一样。
ENU-右前上 右前上坐标系下，Z对应偏航，Y对应横滚，X对应俯仰。所以在常用的姿态旋转顺序（Yaw-Pitch-Roll）中，对应的旋转方式为（Z-X-Y）。
NED-前右下 前右下坐标系下，Z对应偏航，Y对应俯仰，X对应横滚。所以在常用的姿态旋转顺序（Yaw-Pitch-Roll）中，对应的旋转方式为（Z-Y-X）。前右下的旋转如下图：
注意这里的姿态角方向都遵循 右手定则。 3.旋转规则 旋转规则分两种：
Proper Euler angles (z-x-z, x-y-x, y-z-y, z-y-z, x-z-x, y-x-y) 经典欧拉角Tait–Bryan angles (x-y-z, y-z-x, z-x-y, x-z-y, z-y-x, y-x-z) 卡尔丹角 每种规则都使用了3个变量描述三次旋转过程中的旋转角度, 差别在于Proper Euler angles只涉及两个转轴.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5cfa230ff390db7e949108c7234acbc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac0914d0b567f28d2cbbe00346a8a9e9/" rel="bookmark">
			keepalive安装部署步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、基础环境准备：
防火墙添加规则（VRRP协议通信，所有节点都要执行）：
firewall-cmd --direct --permanent --add-rule ipv4 filter INPUT 0 --in-interface em1 --destination 224.0.0.18 --protocol vrrp -j ACCEPT
配置生效命令：
firewall-cmd —reload
seliunx：
查看状态：/usr/sbin/sestatus -v
sed -i “s/^SELINUX=.*/SELINUX=disabled/g” /etc/selinux/config
防火墙重启
ystemctl start/stop/restart firewalld
二、keepalive的安装
yum install -y keepalived
配置keepalived:
/etc/keepalived/keepalived.conf
主节点：
! Configuration File for keepalived
vrrp_script checkService
{
script “/etc/keepalived/traefik.sh”
interval 10
}
vrrp_instance VI_1 {
state BACKUP
interface ens160 #网卡
virtual_router_id 79 #id不能重复
priority 101
nopreempt
advert_int 1
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac0914d0b567f28d2cbbe00346a8a9e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/082a046de21f380b67fb45557714a3f3/" rel="bookmark">
			数据库分库分表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，今天跟大家聊聊分库分表。
什么是分库分表
为什么需要分库分表
如何分库分表
什么时候开始考虑分库分表
分库分表会导致哪些问题
分库分表中间件简介
1. 什么是分库分表 分库：就是一个数据库分成多个数据库，部署到不同机器。
分表：就是一个数据库表分成多个表。
2. 为什么需要分库分表 2.1 为什么需要分库呢？ 如果业务量剧增，数据库可能会出现性能瓶颈，这时候我们就需要考虑拆分数据库。从这几方面来看：
磁盘存储
业务量剧增，MySQL单机磁盘容量会撑爆，拆成多个数据库，磁盘使用率大大降低。
并发连接支撑
我们知道数据库连接是有限的。在高并发的场景下，大量请求访问数据库，MySQL单机是扛不住的！当前非常火的微服务架构出现，就是为了应对高并发。它把订单、用户、商品等不同模块，拆分成多个应用，并且把单个数据库也拆分成多个不同功能模块的数据库（订单库、用户库、商品库），以分担读写压力。
2.2 为什么需要分表？ 数据量太大的话，SQL的查询就会变慢。如果一个查询SQL没命中索引，千百万数据量级别的表可能会拖垮整个数据库。
即使SQL命中了索引，如果表的数据量超过一千万的话，查询也是会明显变慢的。这是因为索引一般是B+树结构，数据千万级别的话，B+树的高度会增高，查询就变慢啦。
小伙伴们是否还记得，MySQL的B+树的高度怎么计算的呢？ 顺便复习一下吧
InnoDB存储引擎最小储存单元是页，一页大小就是16k。B+树叶子存的是数据，内部节点存的是键值+指针。索引组织表通过非叶子节点的二分查找法以及指针确定数据在哪个页中，进而再去数据页中找到需要的数据，B+树结构图如下：
假设B+树的高度为2的话，即有一个根结点和若干个叶子结点。这棵B+树的存放总记录数为=根结点指针数*单个叶子节点记录行数。
如果一行记录的数据大小为1k，那么单个叶子节点可以存的记录数 =16k/1k =16.
非叶子节点内存放多少指针呢？我们假设主键ID为bigint类型，长度为8字节(面试官问你int类型，一个int就是32位，4字节)，而指针大小在InnoDB源码中设置为6字节，所以就是 8+6=14 字节，16k/14B =16*1024B/14B = 1170
因此，一棵高度为2的B+树，能存放1170 * 16=18720条这样的数据记录。同理一棵高度为3的B+树，能存放1170 *1170 *16 =21902400，大概可以存放两千万左右的记录。B+树高度一般为1-3层，如果B+到了4层，查询的时候会多查磁盘的次数，SQL就会变慢。
因此单表数据量太大，SQL查询会变慢，所以就需要考虑分表啦。
3. 如何分库分表 3.1 垂直拆分 3.1.1 垂直分库
在业务发展初期，业务功能模块比较少，为了快速上线和迭代，往往采用单个数据库来保存数据。数据库架构如下：
但是随着业务蒸蒸日上，系统功能逐渐完善。这时候，可以按照系统中的不同业务进行拆分，比如拆分成用户库、订单库、积分库、商品库，把它们部署在不同的数据库服务器，这就是垂直分库。
垂直分库，将原来一个单数据库的压力分担到不同的数据库，可以很好应对高并发场景。数据库垂直拆分后的架构如下：
3.1.2 垂直分表
如果一个单表包含了几十列甚至上百列，管理起来很混乱，每次都select *的话，还占用IO资源。这时候，我们可以将一些不常用的、数据较大或者长度较长的列拆分到另外一张表。
比如一张用户表，它包含user_id、user_name、mobile_no、age、email、nickname、address、user_desc，如果email、address、user_desc等字段不常用，我们可以把它拆分到另外一张表，命名为用户详细信息表。这就是垂直分表
3.2 水平拆分 3.2.1 水平分库
水平分库是指，将表的数据量切分到不同的数据库服务器上，每个服务器具有相同的库和表，只是表中的数据集合不一样。它可以有效的缓解单机单库的性能瓶颈和压力。
用户库的水平拆分架构如下：
3.2.2 水平分表
如果一个表的数据量太大，可以按照某种规则（如hash取模、range），把数据切分到多张表去。
一张订单表，按时间range拆分如下：
3.3. 水平分库分表策略 分库分表策略一般有几种，使用与不同的场景：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/082a046de21f380b67fb45557714a3f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb079f100a340d44fa97f6772fab212d/" rel="bookmark">
			k8s编译nginx文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.要求 通过explain定义deployment类型的控制器跑一个nginx的pod，要做端口映射，要能够在宿主机外面访问
2. 编写用一个资源文件用来运行nginx pod root@k8s-master manifest]# vim nginx-pod.yml [root@k8s-master manifest]# kubectl apply -f nginx-pod.yml deployment.apps/nginx-pod created [root@k8s-master manifest]# cat nginx-pod.yml apiVersion: apps/v1 kind: Deployment metadata: labels: app: mushuang app: test name: nginx-pod namespace: dev spec: replicas: 3 selector: matchLabels: app: nginxlab template: metadata: labels: app: nginxlab name: containerlab namespace: dev spec: containers: - name: nginx image: nginx:latest imagePullPolicy: IfNotPresent [root@k8s-master manifest]# [root@k8s-master manifest]# kubectl get -f nginx-pod.yml NAME READY UP-TO-DATE AVAILABLE AGE nginx-pod 3/3 3 3 34s [root@k8s-master manifest]# kubectl get pods -n dev //已经跑起来了 NAME READY STATUS RESTARTS AGE nginx-pod-76d6c9b8c-hus7d 1/1 Running 0 44s nginx-pod-76d6c9b8c-3dhjd 1/1 Running 0 44s nginx-pod-76d6c9b8c-dhasi 1/1 Running 0 44s [root@k8s-master manifest]# 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb079f100a340d44fa97f6772fab212d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64b8e1210e50460da8a7510c10ef3a69/" rel="bookmark">
			通俗易懂讲PID，附参数调试口诀
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.彻底理解PID
//
1.1
PID定义
PID，就是“比例（proportional）、积分（integral）、微分（derivative）”，是一种很常见的控制算法。在工程实际中，应用最为广泛的调节器控制规律为比例、积分、微分控制，简称PID控制，又称PID调节。它以其结构简单、稳定性好、工作可靠、调整方便而成为工业控制的主要技术之一。
PID已经有107年的历史了，它并不是什么很神圣的东西，大家一定都见过PID的实际应用。比如四轴飞行器，再比如平衡小车......还有汽车的定速巡航、3D打印机上的温度控制器....就是类似于这种：需要将某一个物理量“保持稳定”的场合（比如维持平衡，稳定温度、转速等），PID都会派上大用场。
1.2
例题说明
比如，我想控制一个“热得快”，让一锅水的温度保持在50℃，这么简单的任务，为啥要用到微积分的理论呢？
这不是so easy嘛~ 小于50度就让它加热，大于50度就断电，不就行了？几行代码用Arduino分分钟写出来。但是在大多数场合中，用“开关量”来控制一个物理量，就显得比较简单粗暴了。有时候，是无法保持稳定的。因为单片机、传感器不是无限快的，采集、控制需要时间。而且，控制对象具有惯性。比如你将一个加热器拔掉，它的“余热”（即热惯性）可能还会使水温继续升高一小会。
这是需要PID算法：它可以将需要控制的物理量带到目标附近、它可以“预见”这个量的变化趋势、它也可以消除因为散热、阻力等因素造成的静态误差等。
1.3
算法解释
你应该已经知道了，P，I，D是三种不同的调节作用，既可以单独使用（P，I，D），也可以两个两个用（PI，PD），也可以三个一起用（PID）。这三种作用有什么区别呢？我们先只说PID控制器的三个最基本的参数：kP,kI,kD。
（1）KP
P就是比例的意思。它的作用最明显，原理也最简单。我们先说这个：需要控制的量，比如水温，有它现在的『当前值』，也有我们期望的『目标值』。当两者差距不大时，就让加热器“轻轻地”加热一下。要是当前温度比目标温度低得多，就让加热器“开足马力”加热，尽快让水温到达目标附近。这就是P的作用。
实际写程序时，就让偏差（目标减去当前）与调节装置的“调节力度”，建立一个一次函数的关系，就可以实现最基本的“比例”控制了~kP越大，调节作用越激进，kP调小会让调节作用更保守。要是你正在制作一个平衡车，有了P的作用，你会发现，平衡车在平衡角度附近来回“狂抖”，比较难稳住。
（2）KD
刚才我们有了P的作用。你不难发现，只有P好像不能让平衡车站起来，水温也控制得晃晃悠悠，好像整个系统不是特别稳定，总是在“抖动”。你心里设想一个弹簧：现在在平衡位置上。拉它一下，然后松手。这时它会震荡起来。因为阻力很小，它可能会震荡很长时间，才会重新停在平衡位置。请想象一下：要是把上图所示的系统浸没在水里，同样拉它一下 ：这种情况下，重新停在平衡位置的时间就短得多。
我们需要一个控制作用，让被控制的物理量的“变化速度”趋于0，即类似于“阻尼”的作用。D的作用就是让物理量的速度趋于0，只要什么时候，这个量具有了速度，D就向相反的方向用力，尽力刹住这个变化。kD参数越大，向速度相反方向刹车的力道就越强。
（3）KI
还是以热水为例。假如有个人把我们的加热装置带到了非常冷的地方，开始烧水了。需要烧到50℃。在P的作用下，水温慢慢升高。直到升高到45℃时，他发现了一个不好的事情：天气太冷，水散热的速度，和P控制的加热的速度相等了。于是，水温永远地停留在45℃，永远到不了50℃。
设置一个积分量。只要偏差存在，就不断地对偏差进行积分（累加），并反应在调节力度上。这样一来，即使45℃和50℃相差不太大，但是随着时间的推移，只要没达到目标温度，这个积分量就不断增加。系统就会慢慢意识到：还没有到达目标温度，该增加功率啦！到了目标温度后，假设温度没有波动，积分值就不会再变动。这时，加热功率仍然等于散热功率。但是，温度是稳稳的50℃。kI的值越大，积分时乘的系数就越大，积分效果越明显。
所以，I的作用就是，减小静态情况下的误差，让受控物理量尽可能接近目标值。I在使用时还有个问题：需要设定积分限制。防止在刚开始加热时，就把积分量积得太大，难以控制。
//
2.PID参数调整口诀
//
参数整定找最佳，从小到大顺序查
先是比例后积分，最后再把微分加
曲线振荡很频繁，比例度盘要放大
曲线漂浮绕大湾，比例度盘往小扳
曲线偏离回复慢，积分时间往下降
曲线波动周期长，积分时间再加长
曲线振荡频率快，先把微分降下来
动差大来波动慢。微分时间应加长
理想曲线两个波，前高后低四比一
一看二调多分析，调节质量不会低
若要反应增快，增大P减小I
若要反应减慢，减小P增大I
如果比例太大，会引起系统震荡
如果积分太大，会引起系统迟钝
本文完全转载，原文链接：【技术讲堂】通俗易懂讲PID，附参数调试口诀_控制 (sohu.com)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1e7474d5edde036d75e37ec4d1f157a/" rel="bookmark">
			docker安装DM8
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近学习了一下docker安装DM8。以下是部分笔记。
1.DM8的docker镜像获取 产品下载 | 达梦数据库 (dameng.com) 这里有DM8的docker镜像下载。经测试可以在centos下使用。因此建议首先在centos环境下使用。在unbuntu下这个镜像会无法加载，暂时未了解到应该如何解决，可能需要自己做镜像。
2.docker的安装和测试 docker中文社区,docker帮助,docker手册,docker教程,docker安装手册 - docker中文社区 这里可以参考手册。
这里我们使用的是脚本安装的方法。
更新yum包
sudo yum update
执行docker安装脚本
curl -sSL https://get.docker.com/ | sh
启动docker服务
sudo service docker start
确认docker安装成功
sudo docker run hello-world 这里会报错实际上是因为网络长城的原因，所以我们在国内操作国外镜像可能无法正常拉取，这需要我们为docker设置国内的阿里云镜像加速器。
3.阿里云镜像加速器 创建文件daemon.json文件并添加阿里云镜像
touch /etc/docker/daemon.json
vim /etc/docker/daemon.json
{
"registry-mirrors": ["https://alzgoonw.mirror.aliyuncs.com"]
}
然后重启docker
systemctl restart docker
sudo systemctl status docker
此时我们再重新拉取hello-world镜像，就可以成功了。
docker run hello-world
4.DM8的docker镜像安装 拷贝安装包到 /opt 目录下，执行以下命令导入安装包：
docker load -i dm8_20220822_rev166351_x86_rh6_64_ctm.tar
导入完成后，可以使用 docker images 查看导入的镜像。
镜像导入后，使用 docker run 启动容器，启动命令如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f1e7474d5edde036d75e37ec4d1f157a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/031934ba90f337c151071e465628d215/" rel="bookmark">
			Centos7 glibc库升级到2.23（实测可行）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注意：Centos 为了稳定使用的glibc版本通常比较低。而安装有些程序需要依赖新版本。升级glibc需要慎重，因很多人升级失败后导致系统不能用了。
本人亲测，升级了多台机器，全部升级成功。
glibc简介 glibc是GNU发布的libc库，即c运行库。glibc是linux系统中最底层的api，几乎其它任何运行库都会依赖于glibc。glibc除了封装linux操作系统所提供的系统服务外，它本身也提供了许多其它一些必要功能服务的实现。由于 glibc 囊括了几乎所有的 UNIX 通行的标准，可以想见其内容包罗万象。而就像其他的 UNIX 系统一样，其内含的档案群分散于系统的树状目录结构中，像一个支架一般撑起整个操作系统。
查看系统glibc库版本可使用如下命令:
$ strings /lib64/libc.so.6 |grep GLIBC_ 大家在遇到glibc库问题时候，可以先考虑下为什么要升级GLIBC库，能够通过其他影响性相对小的方式：
在低版本的系统编译自己的产品，如果自己的产品确实不需要新版才支持的新特性用版本高的系统来编译，比如ubuntu，和centos的新版，但可能需要部署到较低版本，那么可以考虑用mock等技术制作更好的安装包，把依赖打入包内利用容器技术，如Docker，在低版本的操作系统内，轻量级的隔离出一个虚拟运行环境，适应你的程序。 确认无法解决，再考虑升级GLIBC库，我升级该库是由于在tensorflow1.13.1版本运行报错：
ImportError: /lib64/libm.so.6: version `GLIBC_2.23' not found 升级步骤 1、 首先下载对应版本的安装包 # wget https://ftp.gnu.org/gnu/glibc/glibc-2.23.tar.gz 2、解压、新建编译目录目录 # tar xf glibc-2.23.tar.gz # cd glibc-2.23/ # mkdir glibc-build # cd glibc-build (一定要在新建的目录中操作) 3、安装 # ../configure --prefix=/usr # make # make install 在make install 时可能会跳出错误（类似的应该是因为软链接的版本不对造成的）
gawk '/\.gnu\.glibc-stub\./ { \ sub(/\.gnu\.glibc-stub\./, "", $2); \ stubs[$2] = 1; } \ END { for (s in stubs) print "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/031934ba90f337c151071e465628d215/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/610cef8dcbedcf8a8a20b530e2852164/" rel="bookmark">
			关于STM32G071RB的ADC采集误差问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 G0系列控制器在开启ADC采集后，因为开启ADC采集功能时，内部ADC处理电路会向管脚泄露一些电荷，在管脚上面形成毛刺，即便将ADC的采集管脚接地，测量ADC采集使用的管脚也会产生较大的尖刺，如下图
2 由于尖刺的影响，会对采集的数值造成偏差，影响了采集精度
3 通过勘误手册得知，这个问题属于G0控制器本身的问题
4 勘误手册提出的解决办法
5 勘误手册提出的解决办法-翻译
6 程序解决办法
可以使用HAL库的校准函数，修正尖峰带来的ADC采集值偏差
7 通过校准函数修正后，测量得到的数值是：
8 测试环境
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24141656d07ff2ae03f18b2e75b3d4be/" rel="bookmark">
			传统语音增强——最小均方(LMS)自适应滤波算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、语音降噪的意义
语音降噪主要研究如何利用信号处理技术消除信号中的强噪声干扰，从而提高输出信噪比以提取出有用信号的技术。消除信号中噪声污染的通常方法是让受污染的信号通过一个能抑制噪声而让信号相对不变的滤波器，此滤波器从信号不可检测的噪声场中取得输入，将此输入加以滤波，抵消其中的原始噪声，从而达到提高信噪比的目的。
然而，由于干扰通常都是随机的，从带噪语音中提取完全纯净的语音几乎不可能。在这种情况下，语音增强的目的主要有两个：一是改进语音质量，消除背景噪声，使听者乐于接受，不感觉疲劳，这是一种主观度量；二是提高语音可懂度，这是一种客观度量。这两个目的往往不能兼得，所以实际应用中总是视具体情况而有所侧重的。
根据语音和噪声的特点，出现了很多种语音增强算法。比较常用的有谱减法、维纳滤波法、卡尔曼滤波法、自适应滤波法等。此外，随着科学技术的发展又出现了一些新的增强技术，如基于神经网络的语音增强、基于HMM的语音增强、基于听觉感知的语音增强、基于多分辨率分析的语音增强、基于语音产生模型的线性滤波法、基于小波变换的语音增强方法、梳状滤波法、自相关法、基于语音模型的语音增强方法等。
二、LMS自适应滤波器原理
在信号处理中，对一个受到加性噪声污染的信号通常采用自适应滤波器进行降噪。自适应滤波器具有自动调节自身参数的能力，故它的设计要求，或对信号和噪声的先验知识需求较少。
所谓自适应滤波器就是利用前一时刻已获得的滤波器参数等结果，自动地调节现时刻的滤波器参数，以适应信号和噪声未知的随机变化的统计特性，从而实现最优滤波。因此，无论在信噪比（Signal to Noise Ratio,SNR）方面还是在语音可懂度方面，自适应滤波器都能获得较大的提高。
最小均方（LMS）自适应算法就是以已知期望响应和滤波器输出信号之间误差的方均值最小为准的，依据输入信号在迭代过程中估计梯度矢量，并更新权系数以达到最优的自适应迭代算法。LMS算法是一种梯度最速下降方法，其显著的优点是它的简单性，这种算法不需要计算相应的相关函数，也不需要进行矩阵运算。最简单的LMS滤波器结构下图所示，该结构最简单且易于实现而应用广泛。
滤波器的输出y（n)表示为
其中，X（n)为输入矢量，X（n)=[x（n)，x（n-1)，…，x（n-N+1)]^T，T为转置符，n为时间序列，W（n)为权系数矢量，W（n)=[w0（n),w1（n-1),…wN-1（n)]^T，N为滤波器阶数。
因此，对于LMS滤波结构，其误差为e(n)=d(n)-y(n)
方均误差ε表示为e=E[e^2(n)]=E[d(n)-y(n)]^2
代入y（n）到上式，有ε=E[d^2(n)]+W^T(n)RW(n)-2PW(n)
其中，R（n)=E[X（n)+X^T（n)]是NxN的自相关矩阵，它是输入信号采样值间的自相关矩阵；P=E[d（n)X^T（n)]为互相关矢量，代表理想信号d（n)与输入矢量X（n)的相关性。
在均方误差e达到最小时，得到最佳权系数W*=[w0*，w1*，…，wN-1*]T。它满足下列方程
如果矩阵R是满秩的，R^(-1)存在，可得到权系数的最佳值满足W*=R^(-1)P
其完整的矩阵表示式为
显然，φx(m)=E[x(n)x(n-m)]是x(n)的自相关值，φxd(R)=E[x(n)(n-k)]是x（n）与d(n）的互相关值。R和P的计算，要求出期望值E[·]，在实际运算中不易实现。为此，对于一些在线或实时应用场合，多使用迭代算法，对每次采样值求出较佳权系数，称为采样值对采样值迭代算法。迭代算法可以避免复杂的R^(-1)和P的运算，又能实时求得近似解，因而切实可行。
LMS算法的基本设置
三、语音质量的性能指标
语音质量包括两方面内容：可懂度和自然度。前者对应语音的辨识水平。而后者则是衡量语音中字、单词和句的自然流畅程度。总体上看可以将语音质量评价分为两大类：主观评价和客观评价。
（1）主观评价
主观评价以人为主体来评价语音的质量。主观评价方法的优点是符合人类听话时对语音质量的感觉，目前得到了广泛的应用。常用的方法有平均意见得分（Mean Opinion Score，MOS)、诊断韵字测试（Diagnostic Rhyme Test,DRT）、诊断满意度测量（Diagnostic Acceptability Measure,DAM）等。语音质量的主观评价要求大量的人、大量次数的测听实验，以便能得到普遍接受的结果。但是由于主观评价耗费大、经历时间长，因此语音质量的主观评价不容易实现。
为了克服主观评价缺点，人们寻求一种能够方便、快捷地给出语音质量评价的客观评价方法。不过值得注意的是，研究语音客观评价的目的不是要用客观评价来完全替代主观评价，而是使客观评价成为一种既方便快捷又能够准确预测出主观评价价值的语音质量评价手段。尽管客观评价具有省时省力等优点，但它还不能反映人对语音质量的全部感觉，而且当前的大多客观评价方法都是以语音信号的时域、频域及变换域等特征参量作为评价依据，没有涉及语义、语法、语调等影响语音质量主观评价的重要因素。
（2）客观评价
语音质量客观评价方法采用某个特定的参数去表征语音通过增强或编码系统后的失真程度，并以此来评估处理系统的性能优劣。
1）信噪比（Signal-to-Noise Ratio,SNR）
SNR一直是衡量针对宽带噪声失真的语音增强计算的常规方法，其定义如下：
但要计算信噪比必须知道纯净语音信号，但在实际应用中这是不可能的。因此，SNR
主要用于纯净语音信号和噪声信号都是已知的算法的仿真中。信噪比计算整个时间轴上的语
音信号与噪声信号的平均功率之比。由于语音信号是一种缓慢变化的短时平稳信号，因而在
不同时间段上的信噪比也应不一样。为了改善上面的问题，可以采用分段信噪比。
2) PESQ (Perceptual Evaluation of Speech Quality)
2001年2月，ITU-T推出了P.862标准《窄带电话网络端到端语音质量和话音编解码器质量的客观评价方法》，推荐使用语音质量感知评价（PESQ）算法，该建议是基于输入-输出方式的典型算法，效果良好。
PESQ算法需要带噪的衰减信号和一个原始的参考信号。开始时将两个待比较的语音信号经过电平调整、输入滤波器滤波、时间对准和补偿、听觉变换之后，分别提取两路信号的参数，综合其时频特性，得到PESQ分数，最终将这个分数映射到主观平均意见分（MOS）。PESQ得分范围在-0.5～4.5之间。得分越高表示语音质量越好。
四、LMS语音增强实验
信噪比计算函数SNR_Calc
名称：SNR_Calc
功能：计算信噪比。
调用格式：
snr=SNR_Calc(x,xn)
说明：输入信号x是输入的纯净语音信号；xn是输入的含噪信号。输出参数snr是计算的信噪比。
函数程序如下：
function snr=SNR_Calc(I,In) % 计算带噪语音信号的信噪比 % I 是纯语音信号 % In 是带噪的语音信号 % 信噪比计算公式是 % snr=10*log10(Esignal/Enoise) I=I(:)'; % 把数据转为一列 In=In(:)'; Ps=sum((I-mean(I)).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/24141656d07ff2ae03f18b2e75b3d4be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f354991a588495e3f471d7d3c408b789/" rel="bookmark">
			【目标检测算法】YOLO-V5实战检测VOC2007数据集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、项目克隆与环境配置1. 下载源码2. 安装依赖包 二、自定义数据集导入和预训练权重1. 导入自定义数据集2. 获得预训练权重 三、修改配置文件1. data目录中的yaml文件2. model目录中的yaml文件 四、开始训练 train.py1. 必须修改的参数2. 利用tensorbord查看参数3. 训练结果4. 检测训练后的网络5. 自己标定一个新的图片来验证6. 开启摄像头 参考博客：
目标检测—教你利用yolov5训练自己的目标检测模型
YOLOv5跑通VOC2007数据集
一、项目克隆与环境配置 1. 下载源码 下载yolov5源代码
2. 安装依赖包 Python 3.8 or later with all requirements.txt dependencies installed, including torch&gt;=1.7. To install run:
根据官网的要求，在pycharm的控制台安装依赖文件。
pip install -r requirements.txt 二、自定义数据集导入和预训练权重 【数据集的制作】VOC2007数据集格式的转换(voc2yolo)与划分
这里我们使用上次制作的VOC2007数据集。
├── data：如果是训练自己的数据集的话，那么就需要修改其中的yaml文件。但是自己的数据集不建议放在这个路径下面，而是建议把数据集放到yolov5项目的同级目录下面。
1. 导入自定义数据集 根据前面介绍的，我们把数据集放到yolov5项目的同级目录下面。
2. 获得预训练权重 从官网下载预训练权重，我们总不可能从头开始训练我们所有的参数。根据你任务的要求，来选择是使用大模型还是小模型。这里选择了yolov5s.pt
在源代码同级目录下新建weights文件夹，放入我们下载好的yolov5s.pt。
三、修改配置文件 有了预先训练的模型和数据集，就可以开始训练YOLOV5对象检测模型了。这需要修改两个YAML文件中的参数。
一个是data目录中对应的yaml文件，一个是model目录文件中对应的yaml文件。
1. data目录中的yaml文件 修改数据集中的类
复制一份yaml文件，并命名为自己的文件，
train: P:/Project_Python/yolov5-voc/VOCdevkit/VOC2007/train.txt val: P:/Project_Python/yolov5-voc/VOCdevkit/VOC2007/val.txt test: P:/Project_Python/yolov5-voc/VOCdevkit/VOC2007/test.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f354991a588495e3f471d7d3c408b789/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e60d6cc85cb7d25df65fc45da9cb1cb/" rel="bookmark">
			RecyclerView 瀑布流 自动换行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 代码后面有附上
dependencies { .....使用这个东西 implementation 'com.google.android.flexbox:flexbox:3.0.0' } ##关键代码
//设置布局管理器 FlexboxLayoutManager flexboxLayoutManager = new FlexboxLayoutManager(this); //flexDirection 属性决定主轴的方向（即项目的排列方向）。类似 LinearLayout 的 vertical 和 horizontal。 flexboxLayoutManager.setFlexDirection(FlexDirection.ROW); //主轴为水平方向，起点在左端。 //flexWrap 默认情况下 Flex 跟 LinearLayout 一样，都是不带换行排列的，但是flexWrap属性可以支持换行排列。 flexboxLayoutManager.setFlexWrap(FlexWrap.WRAP); //按正常方向换行 //justifyContent 属性定义了项目在主轴上的对齐方式。 flexboxLayoutManager.setJustifyContent(JustifyContent.FLEX_START); //交叉轴的起点对齐。 recyclerView.setLayoutManager(flexboxLayoutManager); GitHub地址：https://github.com/20RenGY/FlexboxDemo 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c1b108d01abb2f3d4de7a0b8354931f/" rel="bookmark">
			Linux 中 安装 docker-compose
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目的：主要用户在运行容器的时候，执行定义好的yml文件
Compose 是用于定义和运行多容器 Docker 应用程序的工具。通过 Compose，您可以使用 YML 文件来配置应用程序需要的所有服务。然后，使用一个命令，就可以从 YML 文件配置中创建并启动所有服务。
Compose 使用的三个步骤：
使用 Dockerfile 定义应用程序的环境。使用 docker-compose.yml 定义构成应用程序的服务，这样它们可以在隔离环境中一起运行。最后，执行 docker-compose up 命令来启动并运行整个应用程序。 安装方式 一、在线安装
1、不同版本直接下载 curl -SL https://github.com/docker/compose/releases/download/1.16.1/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose curl -SL "https://github.com/docker/compose/releases/download/1.27.4/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose curl -SL https://github.com/docker/compose/releases/download/v2.9.0/docker-compose-linux-x86_64 -o /usr/local/bin/docker-compose（直接github下载会更快） curl -SL https://github.com/docker/compose/releases/download/v2.10.2/docker-compose-linux-x86_64 -o /usr/local/bin/docker-compose 2、chmod +x /usr/local/bin/docker-compose 3、docker-compose --version 二、通过pip在线安装
1、安装python-pip yum -y install epel-release yum -y install python-pip 2、安装docker-compose pip install docker-compose 3、docker-compose -v 三、离线安装（推荐）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c1b108d01abb2f3d4de7a0b8354931f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a3929b74e204ac579233f7caf54a8bf/" rel="bookmark">
			LeetCode刷题指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 使用指南每日一题学习计划刷题界面左边右边 竞赛 刷题攻略LeetCode Cookbook《剑指Offer》代码随想录 力扣，作为一个国内外的程序员都用作准备面试的刷题网站，对正在阅读这篇指南的你应该都不陌生。随着力扣社区越做越好，各种有关求职、技术的讨论贴以及企业招聘信息都活跃在这个平台上。当你想要借助力扣刷题，提升代码能力、在面试中脱颖而出，却无从着手时，这篇文章可以作为你的入门指南。 使用指南 这部分包括了力扣的关键功能以及一些实用技巧，适合从未或者较少使用力扣刷题的人们快速入门。需要刷题路线的同学可以直接跳转到第二部分【刷题攻略】。
每日一题 首先屹立在题库之首的是力扣官方的每日一题。每日一题的难度分布和整个题库相同，且往往评论区中会有大佬们凌晨撰写的最新题解，所以作为 CV 工程师根本不用担心做不出来 [\doge]。每月完成所有的每日一题打卡任务，还可以获得独一无二的月度刷题勋章。面对全站两千多道题（这个数字甚至还在快速膨胀），不知从何着手的话，不如就从每日一题开始立下目标吧！
学习计划 力扣学习计划广场提供了一些免费的刷题计划，包括：
专项突破：算法、数据结构、动态规划、SQL等（SQL 很多题目需要会员，如果你还是学生并且想要充值会员的话一定要先认证教育优惠资质！）；综合提升：剑指 Offer、力扣杯竞赛真题集；企业真题：你能想到的国内大中厂。 每日任务量大概是两三道题，适合作为每日一题的补充或是用于针对性训练。
刷题界面 左边 收藏：一些经典题目或者暂时未解决的问题都可以收藏起来！收藏支持创建文件夹（需要在收藏题目的时候创建，而不是在个人资料里），便于分类管理，像我自己的收藏里有这几个文件夹：数据结构、好难啊、不愧是我[\doge]中英文切换：有些题目描述（特别是序号较大的新题）往往是机翻。所以当阅读中文题目令人感到困惑时，一定要参考一下英文原题描述！（顺便到评论区听取骂声一片哈哈）提交记录标记：所有提交记录都可以做上标记和描述，在右侧编辑区可以拉取标记过的代码。例如同一道题的不同解法，简单写上思路方便日后再看，咱当初就是靠这个复习数据结构的。题解标签：搜索题解时，可以按照语言和知识点进行标签筛选，如果热门题解并没有说人话，或者你正在使用小语种刷题，又或者想要查看特定解法时，标签筛选是效率最高的方法！ 右边 快速获取标记代码：点击右上方的小旗，就可以快速拉取曾经被标记过的提交记录！编辑器设置：点击右上方的小 i 和齿轮可以进行一些简单的设置，力扣自带的编辑器还是很不错的，熟悉一些快捷键可以加快码的速度~语言设置：左上角可以选择语言，点击小 i 标识可以查看力扣编译器对语言的支持程度；我习惯用 C++ 做题，力扣支持 C++17 标准，大部分头文件不需要包含就可以直接使用。Dark Side：喜欢熬夜刷题的小伙伴们都知道切换到黑夜模式的重要性，但是黑夜模式并不在编辑器设置中，而是在点击头像的 Dark Side 按钮里！笔记：编辑区右下角有个悬浮的笔记标志，支持 MarkDown 格式的笔记记录，把你的奇思妙想都记下来吧！ 竞赛 每周天上午 10：30-12：00 都会有各个企业冠名的力扣竞赛，双周周六晚上有 22：00-00：00的夜猫子赛场，力扣官方还会常常举办力扣杯（有个人赛和团队赛）。每场比赛一个半小时，四道题，一般是 2 Easy + 1 Median + 1Hard。参与就可以得到积分（可用于换取力扣周边礼品），手速够快的话还能获得企业奖品，当然更重要的是内推或简历免筛的机会！如果觉得自己剑已经磨练好的话，速来力扣竞赛击剑×小试牛刀✓！ 可以用于模拟面试环境~
刷题攻略 力扣里都是面试真题，企业也往往将其作为面试题库。不过鉴于大家都不屑于将题目全部刷完 [\doge]，且网上相关的算法刷题攻略也层出不穷，这里我推荐几个靠谱的刷题攻略：
LeetCode Cookbook 这本书的 在线地址，PDF永久更新地址。全书用 Golang 作为示例语言将LeetCode经典的两千题详细解析，质量和完成度双高，不仅仅适用于 go 选手。其中手册开头还有将题号按照不同知识点分类的索引，需要专项突破的同学可以作为参考。
《剑指Offer》 这是一本经典的知名互联网大厂的面试题集，使用 C/ C++（主要是 C）实现，力扣上已有现成的相关合集。书的前半部分还有关于面试流程的经验指导，是面试向的工具书，见证了许许多多职场人的成长，可以说是非常实用了！
代码随想录 Carl 哥用丰富详实的语言配以生动形象的图示，详细解释了很多基础算法的原理，帮助大家记忆理解更加深刻。有多语言实现，很适合入门参考。GitHub仓库；此外，代码随想录还有微信公众号、B站视频以及实体书。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a3929b74e204ac579233f7caf54a8bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25f0dbc941218d509e6198c83d0e35db/" rel="bookmark">
			Ubuntu查看系统配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 查看操作系统 cat /etc/issue 查看处理器 lscpu 查看显卡 nvidia-smi 查看内存 free -m 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc76392923577f7fca13a664a05f25d8/" rel="bookmark">
			解决python通过pip install 安装时所遇到的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.在pip install时，由于网速过慢导致安装失败，因此选择了豆瓣源来加速下载。
pip install （库名） -i http://pypi.douban.com/simple --trusted-host pypi.douban.com 2.随后，产生了如下问题：
ERROR: Could not install packages due to an OSError: [WinError 5] 拒绝访问。: ‘...’ Consider using the --user option or check the permissions. 随后通过以下方法但仍未解决问题：
(15条消息) 解决ERROR: Could not install packages due to an EnvironmentError: [WinError 5] 拒绝访问_BRYTLEVSON的博客-CSDN博客
(15条消息) PermissionError: [WinError 5] 拒绝访问。解决办法_成都—大数据开发工程师—杨洋的博客-CSDN博客_permissionerror winerror5
3.最后删除了anaconda/Lib/sit-packages下的部分文件（前缀为~的文件）解决了问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c0d1250eed45b3689c8c2f9cf765fb3/" rel="bookmark">
			模型线上线下一致性问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		线下可能很好，但是线上表现并不如意，对于这种线上线下一致性问题，是机器学习模型在上线之后经常遇到的问题。
围绕着这个问题，从多个角度来考虑该问题。
1 特征维度 数据作为模型的输入，决定着模型的上限。一般一致性问题在数据的表现为：
1.1 线上线下的处理方式不同 针对同样的特征输入，离线和在线的处理方式不同，如input_schema配置没对齐、特征抽取不一致等，这是最容易出现的情况。
解决方法
一般是离线和在线共用同一套特征抽取框架，同时每次模型上线前先生成一批待校验的一致性样本，对比每条样本在离线打分和在线打分的gap，小于一定阈值（如1e-6）算一致性通过
1.2 特征更新延迟性 user侧和item侧的特征一般以正排方式储存在key-value载体中，根据特征类型的不同更新时效性也可以分为：
长期更新：user的年龄、性别、婚否、是否有孩子等长期比较稳定的用户画像特征天级更新：user最近7天/14天在该appid上的pv个数、click个数、conv个数、ctr、cvr等按天统计的中长期兴趣特征小时级更新：user的精准兴趣、广泛兴趣、app安装列表等按小时统计的近实时特征实时更新：user最近互动过的adid、appid、industry_id，item实时反馈特征，session序列特征 对于天级更新、小时级更新和实时更新这些对时效性比较敏感的特征，如果出现了更新延迟，线上实验效果的衰减也是特别厉害的。
1.3 线上特征源获取缺失 线上特征的获取由于来源和计算方式不同会有多种通路，比如文件、redis、rpc服务、透传等，每种通路一旦某个环节出现问题，特征就取不到或者取错，对线上预估的影响也是很大的
解决方法： 搭建特征监控体系
对每一个线上服务使用到的特征建立空值率、top取值分布、时效性、ctr/cvr分布等多个维度的监控也是很有必要的，可以及时发现出问题的特征并加以修复。
2 训练维度 除了特征外另一个重要的排查方向就是离线训练结果是否存在问题，可以从三个方面进行排查。
训练集和测试集是否出现了数据重叠。评估函数是否可靠。是否出现特征穿越，特别是与label强相关的统计类和行为序列特征出现穿越，相当于开了个上帝视角；训练集过拟合是否存在 3 线上结果不置信 上面根据离线情况提供了几种不置信的检测思路，那么线上也同样面对同样的置信问题。
线上指标统计时间窗口：不同指标达到可置信水平的统计窗口有较大区别，这跟业务和指标稳定性有很大关系，比如广告主价值指标的置信时间窗口往往要比收入/ecpm要长不少，因为天级波动比较大。而ctcvr指标则跟归因是否有延迟相关，一般要等好几个归因周期才能置信；
实验分桶是否随机：ABtest实验关键在于流量划分正交，流过每一层的流量必须重新的均匀划分。不正交结果必然不置信，可以通过划分AABB实验桶来判断流量划分是否出现问题。
线上serving检查
4 训练样本分布变化 比如特征来源有的来自base模型，有的来自实验模型，导致数据分布，特征都不一致，对应的必然不行。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44e631fac3ff2434fb94881f3b8e8bdf/" rel="bookmark">
			自动补齐命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 自动补齐命令
[root@containerd ~]#yum install -y epel-release bash-completion [root@containerd ~]#source /usr/share/bash-completion/bash_completion [root@containerd ~]#source &lt;(nerdctl completion bash) [root@containerd ~]#echo "source &lt;(nerdctl completion bash)" &gt;&gt; ~/.bashrc [root@containerd ~]#source ~/.bashrc [root@containerd ~]#nerdctl r rm rmi run [root@containerd ~]#nerdctl r 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f76fe04bafc26e0680546712b16c6792/" rel="bookmark">
			小程序面试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.请谈谈微信小程序主要目录和文件的作用？
App.js 项目的入口文件，写入全局的公共方法，像本地存储的数据；App.json 底部tab, 标题栏和路等设置；App.wxss 公共样式，引入iconfont等；pages 里面包含一个个具体的页面；index.json (配置当前页面标题和引入组件等)；index.wxml (页面结构--模板文件)；index.wxss (页面样式表)；index.js (页面的逻辑，请求和数据处理等)；project.config.json 项目配置文件，用得最多的就是配置是否开启https校验； 2 请谈谈wxml与标准的html的异同？到其他
相同:都是用来描述页面的结构；
不同:
多了一些 wx:if 这样的属性以及 {{ }} 这样的表达式循环遍历：小程序是wx:for="list"，vue是v-for="inforin list"调用data模型：小程序是this.data.unifo，vue是this.unifoWXML仅能在微信小程序开发者工具中预览，而HTML可以在浏览器内预览都由标签、属性等构成；标签名字不一样，且小程序标签更少，单一标签更多；组件封装不同， WXML对组件进行了重新封装，小程序运行在JS Core内，没有DOM树和window对象，小程序中无法使用window对象和document对象。 3.请谈谈WXSS和CSS的异同？
相同:都是用来描述页面的样子；
不同:
WXSS 具有 CSS 大部分的特性，也做了一些扩充和修改；WXSS新增了尺寸单位，WXSS 在底层支持新的尺寸单位rpx；WXSS 仅支持部分 CSS 选择器；WXSS 提供全局样式与局部样式 4.你是怎么封装微信小程序的数据请求的？
1.在根目录下创建api目录及index.js文件和request.js文件；
2.在request.js 封装基础的get, post 和 put，delete方法和一个请求公共的方法，创建函数设置请求体，带上token和异常处理等；
3.根据页面数据请求的需要, 导出增删改查4个方法
4.index.js--------------&gt;是写请求接口的,引入4个方法,并根据不同接口使用不同函数
5.在具体的页面中导入；
5 小程序页面间有哪些传递数据的方法？
使用全局变量实现数据传递 在app.js中可以定义全局变量globalData， 旧页面将要传递的数据赋值存放在里面，新页面调用全局变量获取传递数据值。
使用的时候通过getApp()拿到存储的信息这种方式一般适用于多个页面或者全部页面都需要获取使用同一个数据，比如一开始进入首页就获取到的用户信息等； // app.js App({ // 全局变量 globalData: { name: null } }) //pageA.js ··· getApp().globalData.name = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f76fe04bafc26e0680546712b16c6792/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad204ec168dfb99dc9cca100302db284/" rel="bookmark">
			浅谈C语言预处理指令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一次写这种博客的文章，结合《C primer Plus》以及自己的一些理解编写，如有写的不对的地方还望指出。
在C语言中，预处理指令大致包含#include、#define、#if、#ifdef、#ifndef、#else、#elif、#endif、#undef、#line、#error、#pragma等，下面就来细细 地了解一下各自的用法和语法明细。
1. #define指令主要用于定义明示常量（也称为符号常量），如我们写一个：
#define TWO 2 其中TWO就是一个宏，2是替换体，也叫做替换列表，我们通常会将宏写成大写，下面再介绍 类函数宏的时候也是如此，大写的目的除了表明这是一个宏定义，在检查程序时方便外，还提醒我们在使用的时候要注意这是一个宏，要小心使用，这一点在类函数宏中尤其明显，定义有误就和预期不太一样，当然这都在后面会有介绍。编译器只因在程序中多看了宏一眼，就会用替换体代替宏，值得注意的是在旧版的C要求指令一行从#开始，#和其他指令之间不能有空格，但这一要求在ANSI以及之后的标准都放开了，也就是说你可以在#加个空格或制表符，具体操作会在#if系列说到。
从宏到替换体的过程叫宏展开。在使用标准C注释时，注释部分会被代替为一个空格，这是编译器的使命，如：
#define/*这是一个注释*/TWO 2 ==&gt; #define TWO 2 其实我们可以把宏定义的替换体看做是记号字符串，C预处理器视宏定义的替换体成单独的“词”，用空白把这些词分开，如：
#define SIX 2 * 3 #define SIX 2*3 这是两个不同的定义，第一个表达式中的替换题包括2、*、3三个记号，而第二个表达式中包含了2*3这一个记号，虽然记号不同，但并不能就这么改变SIX的宏定义，如果我们还是想改变SIX的宏定义，就需要用到下一个预处理指令：#undef。我们不仅可以用#define来定义一个明示常量，还可以用来定义一个“函数“，我们来看一下下面的一个例子：
#define MEAN(X, Y) (((X) + (Y)) / 2) 我们定义了这么一个类函数宏之后就可以像一个函数一样调用了，比如我传进一个MEAN(2, 2),那么就会得到一个结果：2。注意在此处我是将每一个参数都加了一个括号的，那么不加括号的后果是什么呢？我们来看一下。我们写一个如下所示的类函数宏：
#define SQUARE(X) x*x 我们传进一个2+3，也就是说我们这么写：SQUARE(2+3)，大家觉得结果会是什么呢？25还是11呢？答案是11，为什么呢？因为在运行时，编译器不会好心到帮你算好结果，什么样的表达式传进还什么样的表达式传出，还是原来的配方还是原来的味道，该表达式编译器会解释为：2+3*2+3，根据优先级，*是高于+的，所以会先计算2*3，就是2+6+3，结果就是11啦。所以在用的时候要注意到这一点。那么这么写和自己写个函数相比有什么优势呢？宏的一个优点是不用担心变量类型，熟悉C++的小伙伴们知道template模板，可以定义个类模板，函数模板，不用管变量类型，用的时候再告诉就行了。宏也一样，它在定义时是不需要写变量类型的，上面的定义一样，我在函数里传进一个float，int等都一样计算，若是要写一个函数的话，就需要更具不同的变量类型定义好几个函数，用宏写一行就可以了。另一个优点在于宏是内联的，在执行时是在代码中插入宏的定义的，而函数在被调用时是跳转的，比方说main里执行到哪个函数，就暂时先把main里放一边，跳到该子函数的定义处先执行，完了再回到main中执行。这样就花费了时间（跳转的过程时间较顺序执行的时间长一些），而且分配了内存给子函数，又耗时间又耗内存，谁有愿意干这种吃力不讨好的事呢？但注意的是只调用一次两次这两种方法所耗时间差的并不多，因为计算机执行的速度非常快，但当同一个函数要调用十几二十几次的时候，省时省内存的优势就很明显了。
2. #include是一个文件包含指令，该指令会把后面的文件内容包含到当前的文件中，其形式有两种：
#include &lt;stdio.h&gt; #include "mystring.h" #include "/usr/proj/myarray.h" //查找/usr/proj目录 其区别在于：第一行的文件包含是告诉预处理器在标准系统目录中查找该文件，第二行告诉编译器现在当前目录中或者在文件名中指
定的其他目录中(具体代码实现见第三行)查找该文件，如果找不到就在标准系统目录下查找，头文件的重要性不言而喻，平时大家也要将
自己写的好的，常用的保存起来，方便复用，这里就不加赘述了。
3. #undef是一个用于取消已经#define过的指令，之前也提到过，要想重定义一个宏，要么等它的声明周期过了，要么先释放再定义，
当然，如果自己不知道该宏是否定义过也可以先#undef一下，免得出错
5. #if系列，这里我将#if、#ifdef、#ifndef、#else、#elif、#endif称为#if系列，其用法也很简单，类似于if判断
/*此处写为缩进格式，方便和if对应以及看着方便舒服，若编译器不支持还是都顶格写*/ #ifdef MAVIS #define NUM 2 //定义过MAVIS就执行该语句，否则执行下面的的语句 #define ADD(X, Y) X+Y #else #define NUM 3 #define SUB(X, Y) X-Y #endif 与if相同的地方在于它的语意以及#else可以省略，不同地地方在于它不需要写花括号,并且#endif是不可少的。至于#ifndef其语意和#ifdef相反，ifndef是if not define的缩写，顾名思义，就是没定义啥就执行，否则就执行其他的，同样，在结尾处也需要加#endif。这两个常见的用法在于当我需要根据现实情况(如：在不同系统中需要定义不同的值或包含不同的文件)需要选择定义或包含头文件时，可以先#define一个宏，然后再写#ifdef或#ifndef，根据情况选择保留#define（相当于定义了）还是注释掉#define（相当于未定义）。最后的#if、#elif就类似于if、else if了，是条件选择，如：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad204ec168dfb99dc9cca100302db284/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cdb72e392e9d66c42b3490f6920ef26a/" rel="bookmark">
			k8s实战入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Namespace是kubernetes系统中的一种非常重要资源，它的主要作用是用来实现多套环境的资源隔离或者多租户的资源隔离。
默认情况下，kubernetes集群中的所有的Pod都是可以相互访问的。
测试：kubernetes集群中的所有的Pod都是可以相互访问的
标签操作
进入容器：kubectl exec --help Usage: kubectl exec (POD | TYPE/NAME) [-c CONTAINER] [flags] -- COMMAND [args...] [options] [root@k8s-master ~]# kubectl get pods NAME READY STATUS RESTARTS AGE apache-855464645-4zxf2 1/1 Running 2 (115m ago) 22h [root@k8s-master ~]# kubectl exec apache-855464645-4zxf2 -it -- bash root@apache-855464645-4zxf2:/usr/local/apache2# ls bin cgi-bin error icons logs build conf htdocs include modules root@apache-855464645-4zxf2:/usr/local/apache2# 查看sleep在busybody里的位置 [root@k8s-node2 ~]# docker run -it --rm busybox Unable to find image 'busybox:latest' locally latest: Pulling from library/busybox 5cc84ad355aa: Pull complete Digest: sha256:5acba83a746c7608ed544dc1533b87c737a0b0fb730301639a0179f9344b1678 Status: Downloaded newer image for busybox:latest / # which slep / # which sleep /bin/sleep / # exit [root@k8s-node2 ~]# 在容器里执行命令方法： [root@k8s-master ~]# kubectl explain pods.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cdb72e392e9d66c42b3490f6920ef26a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7badf8212784bbf5f7c65918ccae3d4b/" rel="bookmark">
			kubernetes快速部署及常用命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.2 kubernetes简介 kubernetes，是一个全新的基于容器技术的分布式架构领先方案，是谷歌严格保密十几年的秘密武器----Borg系统的一个开源版本，于2014年9月发布第一个版本，2015年7月发布第一个正式版本。
kubernetes的本质是一组服务器集群，它可以在集群的每个节点上运行特定的程序，来对节点中的容器进行管理。目的是实现资源管理的自动化，主要提供了如下的主要功能：
自我修复：一旦某一个容器崩溃，能够在1秒中左右迅速启动新的容器弹性伸缩：可以根据需要，自动对集群中正在运行的容器数量进行调整服务发现：服务可以通过自动发现的形式找到它所依赖的服务负载均衡：如果一个服务起动了多个容器，能够自动实现请求的负载均衡版本回退：如果发现新发布的程序版本有问题，可以立即回退到原来的版本存储编排：可以根据容器自身的需求自动创建存储卷 1.3 kubernetes组件 一个kubernetes集群主要是由**控制节点(master)、工作节点(node)**构成，每个节点上都会安装不同的组件。
master：集群的控制平面，负责集群的决策 ( 管理 )
ApiServer : 资源操作的唯一入口，接收用户输入的命令，提供认证、授权、API注册和发现等机制
Scheduler : 负责集群资源调度，按照预定的调度策略将Pod调度到相应的node节点上
ControllerManager : 负责维护集群的状态，比如程序部署安排、故障检测、自动扩展、滚动更新等
Etcd ：负责存储集群中各种资源对象的信息
node：集群的数据平面，负责为容器提供运行环境 ( 干活 )
Kubelet : 负责维护容器的生命周期，即通过控制docker，来创建、更新、销毁容器
KubeProxy : 负责提供集群内部的服务发现和负载均衡
Docker : 负责节点上容器的各种操作
下面，以部署一个nginx服务来说明kubernetes系统各个组件调用关系：
首先要明确，一旦kubernetes环境启动之后，master和node都会将自身的信息存储到etcd数据库中一个nginx服务的安装请求会首先被发送到master节点的apiServer组件apiServer组件会调用scheduler组件来决定到底应该把这个服务安装到哪个node节点上在此时，它会从etcd中读取各个node节点的信息，然后按照一定的算法进行选择，并将结果告知apiServerapiServer调用controller-manager去调度Node节点安装nginx服务kubelet接收到指令后，会通知docker，然后由docker来启动一个nginx的podpod是kubernetes的最小操作单元，容器必须跑在pod中至此，一个nginx服务就运行了，如果需要访问nginx，就需要通过kube-proxy来对pod产生访问的代理 1.4 kubernetes概念 Master：集群控制节点，每个集群需要至少一个master节点负责集群的管控
Node：工作负载节点，由master分配容器到这些node工作节点上，然后node节点上的docker负责容器的运行
Pod：kubernetes的最小控制单元，容器都是运行在pod中的，一个pod中可以有1个或者多个容器
Controller：控制器，通过它来实现对pod的管理，比如启动pod、停止pod、伸缩pod的数量等等
Service：pod对外服务的统一入口，下面可以维护者同一类的多个pod
Label：标签，用于对pod进行分类，同一类pod会拥有相同的标签
NameSpace：命名空间，用来隔离pod的运行环境
2.安装要求 在开始之前，部署Kubernetes集群机器需要满足以下几个条件：
-至少3台机器，操作系统 CentOS7+
硬件配置：2GB或更多RAM，2个CPU或更多CPU，硬盘20GB或更多集群中所有机器之间网络互通可以访问外网，需要拉取镜像禁止swap分区 环境
名称IP系统k8s-master192.168.106.16centos8k8s-node1192.168.106.20centos8k8s-node2192.168.106.21centos8 //以下的操作所有主机都要做 //关闭所有主机的防火墙，selinux [root@k8s-master ~]# systemctl disable --now firewalld Removed /etc/systemd/system/multi-user.target.wants/firewalld.service. Removed /etc/systemd/system/dbus-org.fedoraproject.FirewallD1.service. [root@k8s-master ~]# setenforce 0 [root@k8s-master ~]# vim /etc/selinux/config [root@k8s-node1 ~]# systemctl disable --now firewalld Removed /etc/systemd/system/multi-user.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7badf8212784bbf5f7c65918ccae3d4b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29cc30be7dc2ee0a4766339f73a9331f/" rel="bookmark">
			springboot集成统一认证服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		springboot集成统一认证服务 配置文件配置属性 # 统一认证登录 # cas服务地址 cas.loginServer=https://xxx.xxx.xxx/cas #cas服务端的登录地址 cas.validateServer=https://xxx.xxx.xxx/cas #当前服务器的地址(客户端) cas.serverName=当前服务地址 配置类 （1）配置类1
import org.jasig.cas.client.authentication.DefaultGatewayResolverImpl; import org.jasig.cas.client.authentication.GatewayResolver; import org.jasig.cas.client.util.AbstractCasFilter; import org.jasig.cas.client.util.CommonUtils; import org.jasig.cas.client.validation.Assertion; import org.springframework.beans.factory.annotation.Value; import org.springframework.core.annotation.Order; import org.springframework.stereotype.Component; import javax.servlet.*; import javax.servlet.annotation.WebFilter; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import javax.servlet.http.HttpSession; import java.io.IOException; import java.util.Arrays; /** * @author Administrator */ @Order(3) @Component @WebFilter(filterName = "AuthenticationFilter", urlPatterns = "/*", initParams = {}) public class AuthenticationFilter extends AbstractCasFilter { @Value("${cas.serverName}") private String serverName ; @Value("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29cc30be7dc2ee0a4766339f73a9331f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ecef8a8e240287f73366fe6fa048eb0b/" rel="bookmark">
			【JS】实现图片每秒自动切换效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
&lt;meta charset="UTF-8"&gt;
&lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;
&lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
&lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;img src="./图/pro01.jpg" alt="" id="pic"&gt;
&lt;script&gt;
var num = 1
function move(){
//一共7张图片，到第7张图片，回到第一张
if(num&gt;7){
num = 1
}
document.getElementById("pic").src = `./图/pro0${num}.jpg`
num++
}
//每秒调用一次函数
setInterval(move,1000);
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33b281a87dd14a01a7b2cd8accc290f7/" rel="bookmark">
			在makefile中打印输出信息的方法(转)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在makefile中打印输出信息的方法是：$(warning xxxxx)或者$(error xxxxx)
输出变量方式为：$(warning $(XXX))
打印放在一般位置(非目标:依赖:规则的地方)make时解析makefile时就输出, 放在生成目标的规则中,make 目标被执行.
指定执行目录下的Makefile 或makefile
make obj -C path
指定执行某个makefile文件
make obj - f path/xxx.mk 转自：https://blog.csdn.net/saxihuangxing/article/details/78737346
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d8ce1abba3cf6ff5567666599587142/" rel="bookmark">
			小程序全局变量与组件内部实时监听全局变量的改变
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： 小程序的全局变量的设置与修改，并且在页面内部、组件内部实时监听我们全局变量的改动，来实现我们的一些功能效果，比如全局弹框，比如全局loadding效果等等。 实现效果： 请求后台前展示loadding,
请求后台后关闭loadding
实现步骤： 1、全局变量的设置与修改 app.js中配置： App({ //全局监听loadding状态 watch:function(method){ var obj = this.globalData; //注意，这里的comLoadding对应的是globalData定义的变量 Object.defineProperty(obj,"comLoadding", { configurable: true, enumerable: true, set: function (value) { //_comLoadding 是自己起的名字，只要和get里面的保持统一就行，方法内部使用变量 this._comLoadding = value; method(value); }, get:function(){ return this._comLoadding } }) }, globalData: { comLoadding:false } }) 2、页面内部监听与修改 监听方法： onLoad: function (options) { /** * @tip：loadding的控制状态与全局的控制字段连接 * 1、组件初始化 * 2、绑定组件内部watch * @time 2022.9.7 * @author zwh * ---------------------START-------------------------- * */ const self = this; // 注意：watchBack后面要重新绑定this,否则下边的this找不到 getApp().
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d8ce1abba3cf6ff5567666599587142/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66e9ac99bb7c45a432704a0562436275/" rel="bookmark">
			js前端下载文件流或根据url下载图片文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文件流下载
// 请求图片接口时加上responseType: 'blob' async downImg() { const res = await test() // 请求接口 let blob = new Blob([res.data]); let objectUrl = URL.createObjectURL(blob) let aLink = document.createElement('a'); aLink.href = objectUrl; aLink.download = Date.now() + '.jpg' document.body.appendChild(aLink) let event = new MouseEvent('click') aLink.dispatchEvent(event) document.body.removeChild(aLink) } 根据url下载
async downImg() { let url = "填写图片地址" fetch(url).then(res =&gt; res.blob()).then(blob =&gt; { // 将链接地址字符内容转变成blob地址 const aLink = document.createElement('a') aLink.href = URL.createObjectURL(blob) // 文件名字 aLink.download = Date.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/66e9ac99bb7c45a432704a0562436275/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d94da04d1992e71a7492015aea0a4440/" rel="bookmark">
			pycharm配置pytest运行环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一步 配置 file-&gt;Settings-&gt; Python intergrated Tools-&gt;Testings-&gt;Default test runner下拉框选择pytest 第二步 调试 点击右上角，弹出页面弹框，选择运行文件，点击 -（减号）删除
如果运行时还是Python3运行，则需要执行上一步删除后，在执行下一步save
如果还是不能运行，那只可能是下面这个，自行脑补哪里错了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fdacd3c5b421a2802830b399285cc205/" rel="bookmark">
			求链表的相交节点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目:给定两个可能成环的单链表,头结点head1 head2.
请实现一函数,如果两个链表相交,请返回相交的一个节点,如果不相交,返回null.
我们了解一下求链表成环节点的题目.-----&gt;给定链表的头结点,返回链表的成环节点,没有返回null.
首先这道题目分别有两种做法,一种是空间复杂度为O(N)的一种
public static Node LoopNode1(Node head){ if(head==null){ return head; } Set&lt;Node&gt; set = new HashSet&lt;&gt;(); while(head!=null){ if(set.contains(head)){ return head; }else{ set.add(head); head = head.next; } } return null; } 首先使用Set 如果集合内存在当前节点,那么就返回,如果不存在就放进集合内.
因为如果是有环链表的成环节点早晚会遍历到.但是如果是无环链表就会遍历到null.
同时我们还有空间复杂度为O(1) 的方法
public static Node LoopNode(Node head){ if(head==null || head.next==null || head.next.next==null){ return null; } Node slow = head.next; Node fast = head.next.next; while(slow!=fast){ if(fast.next==null || fast.next.next==null){ return null; } slow = slow.next; fast = fast.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fdacd3c5b421a2802830b399285cc205/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ff47efa02fe8c0a3287a85acbd612a1/" rel="bookmark">
			MySQL中delete与truncate区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		delete：
1.可以带条件删除
2.支持事务，要么提交事务，要么回滚
3.删除大量数据慢，只删除数据不回收高水位线
4.为数据操作语言（DML）
truncate：
1.为数据定义语言(DDL)
2.不在事务控制里，DDL语句执行前会提交前面所有未提交事务
3.清理大量数据快，回收高水位线
4.不能带条件删除
高水位线扩展：
一张表设置某个字段为主键自增时，delete删除字段后新增数据时主键的字段从被删除之后新增，truncate则从头开始；
delete：
truncate：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f47e645a973060b168b8355b2a76f3c8/" rel="bookmark">
			【学习记录】报错Failed to introspect Class [org.mybatis.spring.SqlSessionTemplate] from ClassLoader
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.起因：在进行mybatis-spring整合编程学习中，出现了标题那样的报错，出现了好几个错误，最后将罪魁祸首定位到这个报错上。
2.过程：我先检查了xml文档中的bean的设置是否出错，一个个检查语法，命名，扫描路径，都未发现异常；之后检查测试类中有无编写错误，也确定没有。因为自己才疏学浅，只能到百度上查找错误的解决方法；我查询到了这篇文章
springboot启动失败！Failed to introspect Class！_过悟的博客-CSDN博客
给了我启示，是导入的依赖包产生了冲突。想到这个项目是我用来学习mybatis和spring的整合使用的，而报错处有SqlSessionTemplate，所以我猜测可能是与这个有关的依赖包。最后在依赖包中查看
我首先想到最有可能是这俩包冲突了，于是尝试着在pom中将mybatis依赖删除，最后，奇迹发生，程序的正确结果出来了！
3.结：a.不害怕错误，就怕止步不前，学海无涯，以苦作舟。 b.在spring和mybatis的整合包和mybatis的单独依赖包之间，我认为最好还是只存在其中一个，一面发生了像我这里这样子的错误。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3235ae627dc6b3b7c92d5df2d88f3bb/" rel="bookmark">
			【读点论文】 MoCoViT: Mobile Convolutional Vision Transformer，将ghost模块与transformer的编码器结合在一起
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MoCoViT: Mobile Convolutional Vision Transformer Abstract 最近，Transformer网络在各种视觉任务中取得了令人印象深刻的结果。然而，它们中的大多数计算成本很高，不适合实际的移动应用程序。在这项工作中，本文提出了移动卷积视觉转换器(MoCoViT)，通过将transformer引入移动卷积网络来利用这两种架构的优势，从而提高了性能和效率。
与最近的视觉transformer的研究不同，MoCoViT中的移动transformer块是为移动设备精心设计的，非常轻量化，通过两个主要的修改完成:移动自我注意(MoSA)模块和移动前馈网络(MoFFN)。MoSA通过分支共享方案简化了注意力图的计算，而MoFFN在transformer中充当移动版MLP，进一步大大减少了计算量。
综合实验证实，本文提出的MoCoViT家族在各种视觉任务上优于最先进的便携式cnn和transformer神经架构。在ImageNet分类上，它在147M FLOPs时达到74.5%的top-1准确率，比MobileNetV3获得1.2%的计算更少。在COCO对象检测任务上，MoCoViT在RetinaNet框架下比GhostNet高出2.1 AP。
论文地址：[2205.12635v1] MoCoViT: Mobile Convolutional Vision Transformer (arxiv.org)
Introduction (Vision transformer, ViT)在图像分类、目标检测[Microsoft coco: Common objects in context]、语义分割等任务上的性能都比CNNs有显著提升。然而，这些性能的提高通常以较高的计算成本为代价。例如，DeiT需要超过10G的multi - add来执行一个图像分类任务。如此高的计算资源需求超出了许多移动设备的能力，例如智能手机和自动驾驶汽车。
为了缓解这种问题，Swin[Swin transformer: Hierarchical vision transformer using shifted windows]将每个标记的注意区域从完全注意限制为局部注意，其中输入被分割为子窗口，并且自我注意只在每个窗口内执行。twin[Twins: Revisiting the design of spatial attention in vision transformers]提出了空间可分离的自我注意，将局部分组的自我注意和全局下采样的注意分别应用在两个连续的块上。不幸的是，复杂性仍然太大，无法部署在移动设备上。
在过去的几年里，针对移动视觉任务的卷积神经网络(CNN)的设计已经取得了很大的进展。例如，MobileNets利用深度卷积和点卷积来近似普通卷积层，并取得了相当的性能。ShuffleNet进一步提出了一种信道混洗操作，以增强紧凑模型的性能GhostNet设计了一个Ghost模块，通过廉价的操作生成丰富的功能图。
在这项工作中，本文寻求为移动设备设计一种轻量级的transformer，并在复杂性和性能之间取得良好的平衡。一些研究人员[LeVit,Mobilevit,Cvt,Mobile-former]首次尝试将CNNs的强度与transformer相结合，开发轻型transformer。
在[Cvt]中，将MobileNetV2块和变压器块串联在一起，并开发了一个MobileNetV2块来学习全局表示。但与移动cnn相比，MobileVit仍然相对沉重。在[Mobile-former]中提出了Mobile-Former，它是MobileNet和Transformer的并行设计，在两者之间采用双向桥进行通信。
与以往的工作不同，本文提出了一种非常高效的移动transformer块(MTB)。该模块是为移动视觉任务精心设计的，由两个关键组件组成:移动自我注意(MoSA)和移动前馈网络(MoFFN)。
在MoSA中，在查询、键和值的计算中，线性层被轻量级的Ghost模块代替。此外，在计算过程中利用分支共享机制实现权值的重用。因此，MoSA比普通的自我关注更有效。对于多层感知(Multi Layer Perception, MLP)，其复杂性在变压器块中不可忽视。
MoFFN的产生就是为了解决这个问题。用高效的Ghost模块替换MLP中的上投影和下投影线性层，形成MoFFN。在此基础上，本文提出了移动卷积视觉转换器(MoCoViT)，这是一种用于移动应用的新架构，将CNN块和MTB块串联在一起。为了达到复杂度和性能的最佳权衡，CNN块被放置在早期阶段，而MTB块只在最后阶段使用。
为了验证MoCoViT的有效性，本文在各种视觉任务上进行了一系列的实验，如ImageNet-1K分类，以及COCO上的目标检测和实例分割。大量实验结果表明，MoCoViT的性能优于其他最先进的轻量级CNN网络和轻量级transformer，如MobileNetV3, GhostNet和Mobile-Former。如下图所示，MoCoViT在FLOPs范围为40M ~ 300M时获得最好的结果。
MoCoViT与高效CNNs在准确率方面的比较。比较是在ImageNet分类上进行的。MoCoViT始终优于SOTA高效cnn。
具体来说，MoCoViT在ImageNet-1K上实现了74.5%的top-1准确率，147M FLOPs，比MobileNetV3高1.2%，比GhostNet高0.6%。总结起来，本文的工作贡献如下:
本文提出了一种用于移动设备的极其轻量级的transformer块。在block内部，精心设计了Mobile Self-Attention和Mobile前馈网络，旨在实现复杂性和性能之间的最佳权衡。
本文提出MoCoViT，一个有效的架构，结合CNN和transformer的优势，并在各种视觉任务上实现SOTA性能。
Related Work Light-weight Convolutional Neural Networks (CNNs): MobileNetV2提出了一种在反向瓶颈结构中利用深度卷积和点卷积对局部滤波器处理进行建模的有效方法。ShufflenetV2提出了利用组卷积和信道卷积简化点卷积的shuffle算法。其他有效的运算符包括Butterfly transform、GhostNet中廉价的线性变换，以及AdderNet中使用廉价的加法来交换大量的乘法。MixConv探索了多个内核大小的混合，而Sandglass则翻转了反向剩余块的结构。effentnet和TinyNet研究了深度、宽度和分辨率的复合标度。 Vision Transformers (ViT): ViT采用标准transformer编码器，将图像直接分解为一组不重叠的patch序列，构建了无卷积的图像分类器。虽然它收获了有希望的结果，但当只在中型ImageNet上从头开始训练时，数据需求大的transformer和表现最好的CNNs[33]之间仍然存在差距。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3235ae627dc6b3b7c92d5df2d88f3bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec49f4a0ba616f3edfddca2798671226/" rel="bookmark">
			c语言学习，使用文档来查找学习库函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
资源推荐
使用文档来查找学习库函数
以www.cplusplus.com学习为例
msdn
http://zh.cppreference.com——c/c++的官网
资源推荐 www.cplusplus.com ​​​​​​ ​​​​​​ http://zh.cppreference.com——c/c++的官网
软件：msdn
使用文档来查找学习库函数 以www.cplusplus.com学习为例 以学习“strcpy"为例
直接搜索进去
由学习文档我们知道了strcpy函数作用是复制字符串，返回类型是char类型。用法是：strcpy(字符串1，字符串2），字符串1是目的地，字符串2是要被复制给字符串1的。
msdn 这个是软件，可以直接在官网下载
v http://zh.cppreference.com——c/c++的官网 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5042ebfe6216705ed0e7c33f35207872/" rel="bookmark">
			【Java毕设项目合集】26款Java毕设项目合集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 最新最全的JAVA项目合集来啦，看完这26套毕设不再发愁
最近UP整理了一些Java项目，从初级练手项目到企业级电商项目，全部配备源码及笔记，如果你能全部吃透，直接成神，各个大厂都为你打开大门！ 大家都知道学习编程必须要做的就是敲代码和做项目练手了，那项目有难有易，很多小伙伴不知道从哪里找项目来练习，今日我们来看一下初级项目中都有哪些能让我们来练手。当然，为了满足小伙伴们开学练手项目，特推出了本套视频课程！
【Java毕设合集】26套毕设系统（附源码课件）任意挑选，允许白嫖！手把手教学，助你快速毕业！Java_Java项目_Java课设_Java开发_毕业设计https://www.bilibili.com/video/BV1zg411S7na?spm_id_from=333.999.0.0&amp;vd_source=3dc17743417209d9d759a231450c3c50之前做过很多java毕设项目， 我整理下这些资源， 希望能帮助我的同学们！平时我们可以多练习。如果你平时不懂这项技术，你可以问我。欢迎给我留言需要学习这个项目的小伙伴可以有更多关于我的信息，方便大家交流！ 项目包括： 叮当书城项目 在线考试系统
网上订餐项目 图书管理系统
学生宿舍管理 记账系统项目
学生成绩在线管理 物业管理系统
教务查询系统 学籍管理项目
学生成绩管理 宠物领养系统
家教系统项目 健身房管理
进销存管理 精品课程网站
酒店客房管理 人力资源管理
销售评价系统 新冠疫情统计
饮食分享平台
项目亮点：
使用快速开发框架，完全模拟企业项目组开发中如何进行配合
有完整的视频教学和全套的资料，源码
靠人不如靠自己，高分毕业，毕设不求人。做出完整完美的项目也是简历上一道靓丽的成绩哦。刚入门或者正在学习Java的友友们也可以跟着做为练手项目去学习~
需要源码资料的友友们一键三连，评论或者私信我获取资料哦 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd3cdce05846e936ea1cd8995bb2200b/" rel="bookmark">
			【Tools】i1Profiler3.5安装教程详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		00. 目录 文章目录 00. 目录01. i1Profiler概述02. i1Profiler特征03. i1Profiler安装04. i1Profiler官方安装说明05. i1Profiler版本说明06. 附录 01. i1Profiler概述 X-Rite 的 i1 软件解决方案非常适合寻求最大程度控制色彩的成像专业人士。为所有设备（包括扫描仪、显示器、投影仪、RGB 和 CMYK+ 打印机）创建自定义配置文件可确保一致、可预测和可重复的结果，同时节省宝贵的时间和金钱。i1Profiler 软件具有基本模式和高级模式，可实现专业校准和配置设备，以及显示器和打印机的质量保证控制。
i1Profiler 软件提供校准自动化与全方位配置选项的完美平衡，以实现显示器和打印机的创造性色彩控制。
02. i1Profiler特征 打印机
支持最准确的打印机配置文件的高补丁计数图表 - 非常适合美术打印和打样通过使用线性化功能，随着时间和运行之间保持颜色正确通过闪光灯和环境光测量捕捉真实色彩，以实现完美的色彩匹配利用荧光增白剂补偿 (OBC) 功能 监视器
提供无限的伽马、白点和亮度设置使用参考配置文件进行工作组匹配优化灰平衡以获得更中性和更清晰的灰色利用色度适应公式实现不同显示器更紧密的视觉匹配 独特的能力
创建最高质量的专业色彩配置文件补偿纸张中的荧光增白剂使用高级控件控制黑色分离使用白点编辑微调配置文件 03. i1Profiler安装 3.1 双击i1ProfilerSetup.exe
3.2 默认，选择确定
3.3 选择我接受协议，然后点击下一步
3.4 选择下一步
3.5 点击下一步
3.6 点击安装
3.7 安装过程显示
3.8 选择安装
3.9 选择安装
3.10 选择立即重启电脑，完成安装
3.11 启动之后的界面
04. i1Profiler官方安装说明 在 Windows 上安装 i1Profiler 软件
在安装 i1Profiler 软件套件之前，请查看所需的系统环境。要从 DVD 或下载安装 i1Profiler 软件套件，请按照以下步骤操作。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd3cdce05846e936ea1cd8995bb2200b/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/234/">«</a>
	<span class="pagination__item pagination__item--current">235/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/236/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>