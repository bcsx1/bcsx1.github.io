<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0a370b5ca94688474fa33b46ff44e61/" rel="bookmark">
			【Android Studio】代码字体颜色插件ChroMOTERIAL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近看到有人的编译器上代码五颜六色，看着还不错。于是自己也想试试，就动手搞了一番，尝试下这花里胡哨的操作！！！
效果图 插件使用 1、插件下载 setting-&gt;Plugins -&gt;搜索目标插件-&gt;install-&gt;restart 即可~
2、字体设置 end 技术可以菜，但操作不能不花里胡哨！ 哈哈 溜溜球。。。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d07de3b58052d2413d124d7ef70c3c11/" rel="bookmark">
			[2023]自动化测试框架完整指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		所有软件在提供给用户之前都必须经过测试。软件测试是开发生命周期中必不可少的一步因为它确保用户必须收到符合其开发目的的高质量产品。每个企业都优先考虑测试;因此，大多数人更愿意从手动测试转向自动化。因此，自动化测试框架是任何软件测试过程的基础。
任何自动化测试的成功都取决于测试框架的使用。旨在优化其敏捷流程并提供更高的测试自动化投资回报率的 QA 团队必须减少测试和维护费用。
本文提供了自动化测试框架的完整指南。让我们讨论定义自动化测试框架、它的重要性、对自动化框架的需求、它们的类型以及最流行的自动化框架。
一、什么是自动化测试框架? 自动化测试框架是一组用于设计和编写有效测试用例的指南或标准。框架由各种程序和工具组成，旨在帮助 QA 专家更快、更有效地进行测试。该框架可能包括编码标准、处理测试数据的技术、对象存储库、存储测试结果的过程以及访问外部资源的说明等指南。
测试人员仍然可以在不遵守这些标准的情况下编写或记录测试。尽管采用有组织的框架提供了额外的好处，否则这些好处会被遗漏。因此，使用有效的自动化测试框架可以通过在早期阶段轻松识别错误来提高软件质量，从而减少执行手动测试所需的时间和精力。
二、自动化测试框架的重要性 自动化测试框架的使用已成为现代软件开发和测试过程中必不可少的，因为它允许在不同场景中重用代码，并有助于为团队编写标准化测试脚本。框架还有助于避免人为干预、提高测试覆盖率并促进团队协作。
自动化测试框架对于使用各种构建重复运行相同的测试脚本以分析应用程序并验证输出非常有用。总的来说，使用自动化测试框架是解决所有问题的综合软件质量保证策略的关键组成部分。
采用自动化测试框架的一些优势：代码的可重用性、维护成本低、持续测试代码、最少的人工干预、提高效率、最大测试覆盖率、整个测试套件的一致策略
三、为什么我们需要自动化测试框架? 在当前场景下，测试自动化的需求正在快速增长，整个世界都在走向自动化。在计划和执行中使用自动化测试框架有很多好处，其中一些如下所示：
1、有助于资源优化，即更容易根据组织要求利用各种资源。
2、提供结构化开发技术以保证设计的一致性并减少对测试用例的依赖。
3、以最少的人为干预提供准确的根本原因分析。
4、减少编写和运行测试脚本的时间。
5、通过根据测试场景自动决定运行哪个测试来减少对团队的依赖。
6、动态调整测试范围以响应对测试计划或系统环境的修改。
7、支持在不同的浏览器、设备和平台组合上进行并行测试。
8、最大限度地减少报告生成、本地配置和错误控制方面的挑战。
9、组织可以将左移测试的想法付诸行动。
10、可观的长期投资回报率。
四、自动化测试框架的类型 有六种流行的自动化测试框架类别，每种都有独特的设计和一系列优点和缺点。您可以使用以下一种或多种自动化测试框架进行测试：模块化驱动的自动化测试框架、数据驱动的自动化测试框架、线性自动化测试框架、关键字驱动的测试框架、混合测试框架、库架构测试框架
1、模块化驱动的自动化测试框架
为了使模块化驱动的测试框架发挥作用，必须存在特定的模块。为了从自动化测试中获得最佳结果，您需要为每个模块开发不同的脚本并使用它们。
如果更改应用程序的操作，模块将不会受到影响。除非手动更改测试脚本，否则它们是安全的。通过合并多个模块产生高水平的模块化，提供具有成本效益的管理方法。高生产率。
优点：代码的可重用性、可扩展性、高效、模块化方法
缺点：复杂性增加、缺乏灵活性、需要技术知识
2、数据驱动的自动化测试框架
测试人员可以自由存储测试数据，因为测试数据和脚本逻辑使用数据驱动的测试框架分离。测试人员需要使用不同的数据集多次测试应用程序的特性或功能。并且通过使用这个测试框架，测试数据不需要硬编码脚本就变得容易了。
通过数据驱动的测试框架，测试人员可以存储输入/输出参数并将其传递给来自外部数据源的测试脚本，例如 excel 电子表格、文本文件、CSV 文件、SQL 表或 ODBC 存储库。
优点：测试速度快、高度可扩展、更好的灵活性、需要更少的测试脚本
缺点：增加设置时间、需要高水平的技术知识、故障排除很麻烦
3、线性自动化测试框架
与之前相比，线性脚本由一个人手动执行，他精心记录程序的每个阶段。它通常被称为“录制和回放”框架，需要很长时间才能运行。它可能是一种简单的记录方法，不需要自动化技能，但它不允许脚本重用。将来要执行该框架，您需要手动编写测试脚本，这会增加维护过程的时间。
优点：简单、执行速度快、高度灵活
缺点：高维护、更多冗余、一次性使用
4、关键字驱动的测试框架
关键字驱动测试框架是数据驱动测试框架的扩展，它将您的测试数据提取到外部源并安全地保留代码集。这些代码，也称为“关键字”，可以更改测试脚本并从测试框架中得出额外的结论。此外，这些关键字有效地确定了每个程序执行的任务。
优点：改进的可重用性、低维护、更具可扩展性
缺点：复杂性会随着时间的推移而增加、高开发时间、需要深厚的自动化测试知识
5、混合测试框架
自动化测试框架已经开始合并和重叠，就像现在大多数测试程序的情况一样。混合框架结合了上述任何一种，以利用其优势并最大限度地减少其缺点。
每个应用程序都是独一无二的，测试程序也应该如此。随着越来越多的团队转向敏捷方法，必须建立灵活的自动化测试框架。为了获得最好的测试结果，混合框架非常重要。
优点：更快的测试执行、高扩展性、降低成本
缺点：高度复杂，即需要高级技术知识、需要完全脚本化的测试
6、库架构测试框架
库架构测试框架识别在每个测试脚本中共享特征的任务，使测试人员可以根据保存在库中的功能对相似的任务进行分组。这使得代码更容易在各种测试脚本中重用。当应用程序的不同组件具有相似的功能时，此框架很有用。
优点：高复用性、高性价比、改进的可扩展性、高长期投资回报率
缺点：更多开发时间、复杂的、需要高水平的技术知识
五、自动化测试框架的热门示例 没有惊喜!鉴于对它们不断增长的需求，许多自动化测试框架都可用。我们列出了它们以及它们提供的功能。如果您认为它可以帮助您更好地进行自动化测试，请尝试一下。
1. Selenium
Selenium是一个用于自动化 Web 浏览器的开源软件套件。它允许开发人员编写能够以模拟人类行为的方式与网站交互的脚本，例如单击按钮、填写表格和在页面之间导航。Selenium 通常用于Web 应用程序测试，并支持多种编程语言，包括 Python、Java、C# 和 Ruby。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d07de3b58052d2413d124d7ef70c3c11/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6fc351c1c76bcd09b8e77b35ac68712c/" rel="bookmark">
			Spring Boot接收从前端传过来的数据常用方式以及处理的技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 角度1：是否是json格式的数据 前端传递过来的数据类型，老师这里会把它分为两个主要的方向： 第1个方向：非json格式的数据第2个方向：json格式的数据非json格式的数据 方式1：直接可以将控制层方法的参数名称和请求的参数名称保持一致来进行接收。 场景：数据量（参数个数）比较小，&lt;=3个参数优点：简单缺点：如果参数比较多，如果我们还是把每个前端传输过来参数，在后端用单独的一个参数去接收会比较麻烦。注意： 因为我们这里涉及到与前端进行通信，所以项目必须要添加spring-web依赖。为了构建业务的场景，我们得有一个数据的载体，即实体类User.java。案例： 代码 /* * 非json格式 * 第1种方式：如果有数据从前端过来，后端直接把这些数据都当成（看作是）字符串。 * 如： * String username：如果你前端传输过来的用户名，后端直接看成字符串来接收。 * String password：如果你前端传输过来的密码，后端直接看成字符串来接收。 */ @RequestMapping("add1") public String add1(String username,String password){ System.out.println("username = "+username); System.out.println("password = "+ password); return "success"; } 支持get请求，如下图所示：支持post请求，如下图所示：方式2：把前端传输过来的参数，后端封装成一个实体类。 注意： 前端提交的参数名称，需要和后端实体类的属性名称保持一致。代码： ​ /* * 非json格式 * 第2种方式：把前端传输过来的参数，后端封装成一个实体类。 * 如： * 把前端传输过来的参数，（后端）封装到User user实体类中。 */ @RequestMapping("add2") public String add2(User user){ System.out.println(user); return "success"; } ​ 支持get请求，同上
支持post请求，同上
方式3：restful风格的请求与数据提交 —— 需要使用{变量名称}语法来声明RestFul的参数列表，通过一个注解@PathVariable指定参数的映射规则。
概述 思想路 RestFul风格：只关注数据的的内容。应用场景 数据量不大数据的安全性没有严格要求get请求 以前：localhost:8080/users/add1?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6fc351c1c76bcd09b8e77b35ac68712c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab8cf7ff0452aff9dc33d2a330e83400/" rel="bookmark">
			Mockito单元测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Mockito Mockito简介Maven依赖实际使用场景相关注意点
1.Mockito简介 是什么--用 Java 编写的用于单元测试的最流行的 Mocking 框架在哪里 --mockito维护地址https://github.com/mockito/mockito 2.Maven依赖(Java) &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter-engine&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mockito&lt;/groupId&gt; &lt;artifactId&gt;mockito-core&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mockito&lt;/groupId&gt; &lt;artifactId&gt;mockito-inline&lt;/artifactId&gt; &lt;/dependency&gt; 3.实际使用场景 研发阶段针对相关需求开发的代码进行针对性的mock模拟测试
针对单项目修改 但是存在多项目依赖的情况可以使用该框架进行数据模拟
代码块中相关名词解释
@Mock--用户对主体服务中需要调用的对象进行标注，用于生成虚拟对象 @Mock(lenient = true)--标注该虚拟对象可多次调用多次使用 @BeforeAll--在执行对应的测试方法前 提前调用做一些初始化工作 given(api.xxx()).willReturn(response)--针对某个方法的调用设定返回值 静态参数调用-即api.xxx(Request request)方法内的逻辑依赖于入参 given(api.xxx(Mockito.any(xxx.class)).willReturn(response) 动态参数调用-即api.xxx(Request request)方法中的参数在逻辑中依赖前后关系生成，即不关注动态调用中的参数结构 构造具体的response信息 Assertions.assertEquals(a,b)--断言校验a值和b值是否相等 @Mock注解标注的api+given()方法结合使用 1.等同于不调用given()虚拟对象的具体方法中的信息 2.willReturn用于定义返回体,便于真实待测试方法使用该返回体往后执行 @RunWith(MockitoJUnitRunner.Silent.class) @Slf4j @ExtendWith(MockitoExtension.class) class MockServiceTest { public SpringUtil springUtil; @Mock private AccountApi accountApi; @Mock private ProductApi productApi; @Mock private NotifyApi notifyApi; @Mock(lenient = true) public static DefaultListableBeanFactory factory; private static final Long ACCOUNT_ID = 1L; private static final Long PRODUCT_ID = 2L; private static final Long NOTIFY_ID = 3L; @BeforeAll static void setup(){ log.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab8cf7ff0452aff9dc33d2a330e83400/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c05af70381afef931edcd2f320c77ec5/" rel="bookmark">
			Redis配置远程访问
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		修改redis.conf配置文件
注释掉bind 127.0.0.1这一行即可；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08be502d9795015e22d845a93aa815e0/" rel="bookmark">
			详解超链接＜a＞href属性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 语法规范 &lt;a href = ""&gt;&lt;/a&gt; 2 href作用 href属性规定链接的目标地址（URL）
3 href取值问题 （1）绝对URL-其可以跳转到另外一个网址
（2）相对URL-其指向站点内的某个文件
eg（href = "index.html")
（3）锚URL-指向页面中的锚
eg:
其可以指向本页面你设置锚的任意位置
特例
href = "#top"或者href = "#"链接都直接可以返回页面顶部
4 注意点 当href取空值时，什么也不执行，动作发生之后，会刷新页面
当href取”javascript：；“时，代表会执行一段空的javascript代码
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0ad3cc71e23b2a46f1b0602f60aef74/" rel="bookmark">
			Python-线性回归的sklearn实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python-线性回归的sklearn实现 前言一、绘制一条直线（普通方法）1.通过一段区间绘制一条直线2.通过两点绘制一条直线(1)代码(2)求斜率（数学公式） 二、线性回归sklearn实现1.利用sklearn线性回归求直线斜率ps.增加一个点，第三个点(3,6)确定模型 二、生成回归模型数据集1.回归生成器2.利用线性回归模型对生成线性回归数据集进行拟合 三、糖尿病数据集的线性回归分析1.糖尿病数据集介绍2.代码实战 前言 hello大家好这里是小L😊， 这学期开启机器学习之旅。在这里想和大家一起学习一起进步。💪
这次笔记内容：学习线性回归的sklearn实现
一、绘制一条直线（普通方法） 线性回归最后要找的是一条直线
1.通过一段区间绘制一条直线 import numpy as np import matplotlib.pyplot as plt %matplotlib inline #生成位于区间(-6,6)的等间隔100个点 x=np.linspace(-6,6,100) #生成对应函数 y=0.5*x+2 #绘制直线图形 plt.plot(x,y,color='red') 2.通过两点绘制一条直线 (1)代码 #已知两点(2,3),(6,5)绘制一条直线 x=np.array([2,6]) y=np.array([3,5]) plt.plot(x,y,marker='d') (2)求斜率（数学公式） k=(y[0]-y[1])/(x[0]-x[1]) k 二、线性回归sklearn实现 1.利用sklearn线性回归求直线斜率 sklearn.linear_model.LinearRegression(
)
超参数
fit_ intercept：截距，是否计算该模型截距。（除非数据标准化之后可false. ）normalize：标准化false，标准化一般在建模之前做(sklearn.preprocessing.StandardScale)。copy_X：原始的x还在，中间的用另一个存在。如false不要原来的x,新数据覆盖旧数据。n_jobs：计算时设置任务点数，若-1最快的速度。 属性
intercept_ ：截距coef_ ：系数Theta0到Theta(n-1),第几个自变量前面的系数，没有截距 方法
fit 训练predict预测score模型评估get_params返回超参数的值set_params修改超参数的值重新训练 x=np.array([2,6]) y=np.array([3,5]) #导入sklearn中的线性回归模块 from sklearn.linear_model import LinearRegression #线性回归模型实例化 lr=LinearRegression() #模型训练 x=x.reshape(-1,1)#或者：x=np.array([[2],[6]])二维矩阵两层[],每个自变量x 特征的数目需要一样，并且与y行数相对应 lr.fit(x,y) print("过两点(2,3)与(6,5)的直线斜率为:{},截距项为:{:.2f}".format(lr.coef_,lr.intercept_)) #模型预测 x_test=np.array([3,4,5]).reshape(-1,1) y_predict=lr.predict(x_test) #模型评估——计算R方值（在因变量中占多少比例可由模型解释） lr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b0ad3cc71e23b2a46f1b0602f60aef74/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8afbb47359afc5dfe97da52b94e8ad2b/" rel="bookmark">
			Redis缓存击穿问题及解决思路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.什么是缓存击穿 缓存击穿问题也叫热点Key问题，就是一个被高并发访问并且缓存重建业务较复杂的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击。
逻辑分析：假设线程1在查询缓存之后，本来应该去查询数据库，然后把这个数据重新加载到缓存的，此时只要线程1走完这个逻辑，其他线程就都能从缓存中加载这些数据了，但是假设在线程1没有走完的时候，后续的线程2，线程3，线程4同时过来访问当前这个方法， 那么这些线程都不能从缓存中查询到数据，那么他们就会同一时刻来访问查询缓存，都没查到，接着同一时间去访问数据库，同时的去执行数据库代码，对数据库访问压力过大
二.解决缓存击穿的方法 常见的解决方案有两种：
互斥锁
逻辑过期
2.1互斥锁 解决方案一、使用锁来解决：
因为锁能实现互斥性。假设线程过来，只能一个人一个人的来访问数据库，从而避免对于数据库访问压力过大，但这也会影响查询的性能，因为此时会让查询的性能从并行变成了串行，我们可以采用tryLock方法 + double check来解决这样的问题。
假设现在线程1过来访问，他查询缓存没有命中，但是此时他获得到了锁的资源，那么线程1就会一个人去执行逻辑，假设现在线程2过来，线程2在执行过程中，并没有获得到锁，那么线程2就可以进行到休眠，直到线程1把锁释放后，线程2获得到锁，然后再来执行逻辑，此时就能够从缓存中拿到数据了。
2.2逻辑过期 解决方案二、逻辑过期方案
方案分析：我们之所以会出现这个缓存击穿问题，主要原因是在于我们对key设置了过期时间，假设我们不设置过期时间，其实就不会有缓存击穿的问题，但是不设置过期时间，这样数据不就一直占用我们内存了吗，我们可以采用逻辑过期方案。
我们把过期时间设置在 redis的value中，注意：这个过期时间并不会直接作用于redis，而是我们后续通过逻辑去处理。
假设线程1去查询缓存，然后从value中判断出来当前的数据已经过期了，此时线程1去获得互斥锁，那么其他线程会进行阻塞，获得了锁的线程他会开启一个 线程去进行 以前的重构数据的逻辑，直到新开的线程完成这个逻辑后，才释放锁， 而线程1直接进行返回，假设现在线程3过来访问，由于线程线程2持有着锁，所以线程3无法获得锁，线程3也直接返回数据，只有等到新开的线程2把重建数据构建完后，其他线程才能走返回正确的数据。
这种方案巧妙在于，异步的构建缓存，缺点在于在构建完缓存之前，返回的都是脏数据。
2.3两种方案进行对比 互斥锁方案：由于保证了互斥性，所以数据一致，且实现简单，因为仅仅只需要加一把锁而已，也没其他的事情需要操心，所以没有额外的内存消耗，缺点在于有锁就有死锁问题的发生，且只能串行执行性能肯定受到影响
逻辑过期方案： 线程读取过程中不需要等待，性能好，有一个额外的线程持有锁去进行重构数据，但是在重构数据完成前，其他的线程只能返回之前的数据，且实现起来麻烦
三.利用互斥锁解决缓存击穿问题 核心思路：相较于原来从缓存中查询不到数据后直接查询数据库而言，现在的方案是 进行查询之后，如果从缓存没有查询到数据，则进行互斥锁的获取，获取互斥锁后，判断是否获得到了锁，如果没有获得到，则休眠，过一会再进行尝试，直到获取到锁为止，才能进行查询
如果获取到了锁的线程，再去进行查询，查询后将数据写入redis，再释放锁，返回数据，利用互斥锁就能保证只有一个线程去执行操作数据库的逻辑，防止缓存击穿
操作锁的代码：
核心思路：利用redis的setnx方法来表示获取锁。
该方法含义是redis中如果没有这个key，则插入成功，返回1，在stringRedisTemplate中返回true； 如果有这个key则插入失败，则返回0，在stringRedisTemplate返回false。
我们可以通过true，或者是false，来表示是否有线程成功插入key，成功插入的key的线程我们认为他就是获得到锁的线程。
//加锁 private boolean tryLock(String key) { Boolean flag = stringRedisTemplate.opsForValue().setIfAbsent(key, "1", 10, TimeUnit.SECONDS); return BooleanUtil.isTrue(flag); } //释放锁 private void unlock(String key) { stringRedisTemplate.delete(key); } 操作代码：
public Shop queryWithMutex(Long id) { //Redis前缀+id String key = CACHE_SHOP_KEY + id; // 1、从redis中查询商铺缓存 String shopJson = stringRedisTemplate.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8afbb47359afc5dfe97da52b94e8ad2b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bffdba42d1885eb2038ef5abfa2a814e/" rel="bookmark">
			Java中的正则表达式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 定义
1. 主要的3个类
2. 使用正则表达式的两种办法
快速查找表
1. 匹配符号
2. 元字符
3. 量词
4. Groups组的使用
5. 综合上表的快速查找表
常用应用实例(持续更新)
1. 表达式中与之匹配的常用方法例子
2. 邮箱地址
3. Pattern类实例
4. 电话号码
定义 正则表达式定义了字符串的模式。正则表达式可以用来搜索、编辑或处理文本。正则表达式并不仅限于某一种语言，但是在每种语言中有细微的差别。Java的正则表示与Perl最为相似。在Java 1.4中对String类进行了扩展，提供了一个可以进行regex模式匹配的方法。
import java.util.regex.*; 1. 主要的3个类 - Pattern(模式) : Pattern类没有任何公共构造函数，我们使用它的公共静态方法compile()通过传递正则表达式参数来创建Pattern对象。
Pattern pattern = Pattern.compile(".xx."); Pattern使用方法 : https://pingfangx.github.io/java-tutorials/essential/regex/pattern.html
- Matcher(匹配) : Matcher类没有任何公共构造函数，我们使用Pattern对象匹配方法得到一个Matcher对象，该方法将输入的字符串作为参数。然后我们使用matches()方法，根据输入的String是否与regex模式匹配，返回boolean结果。
Matcher matcher = pattern.matcher("MxxY"); Matcher使用方法 : https://pingfangx.github.io/java-tutorials/essential/regex/matcher.html
- PatternSyntaxException(语法不正确异常) : 正则表达式语法不正确则会抛出该异常。
// 错误语法用于测试异常 pattern = Pattern.compile("*xx*"); // 输出 Exception in thread "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bffdba42d1885eb2038ef5abfa2a814e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e68606732030e9426ca70d1277951c0/" rel="bookmark">
			UE4制作媒体播放材质
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		媒体播放材质 用文件媒体源资源在关卡内的静态网格体上播放视频文件。
【官方文档】
要求 ▶ 支持UE4版本：4.18以上。▶ 支持视频格式：MP4、AVI、WMA。 操作流程 一、准备工作 ▶ 创建Movies电影文件夹，并把视频文件放到文件夹里。 1、在内容浏览器（Content Browser） 中，展开源面板（Sources Panel），然后在 内容（Content） 下创建一个名为 电影（Movies） 的文件夹。
2、右键单击 电影（Movies） 文件夹并选择 在资源管理器中显示（Show in Explorer），查找文件所在硬盘位置。
3、将视频文件拖至项目的内容/电影（Content/Movies） 文件夹中（为了将视频与项目一起打包，视频文件必须放在项目的 内容/电影（Content/Movies） 文件夹中。）。
二、创建媒体源资产加载视频文件 方法一 直接把视频文件拖到UE4的 电影（Movies） 文件夹内，软件会自动添加媒体源资产文件，并自动指定视频文件路径。
方法二 创建文件媒体源（File Media Source） 作用：用来加载视频文件。1、在电影（Movies） 文件夹上右键单击 ，在 媒体（Media） 下选择 文件媒体源（File Media Source）。
或者选择电影（Movies） 文件夹，在文件夹内右键创建
2、然后指定视频文件。
三、创建媒体播放器（Media Player） 在 电影（Movies） 文件夹中再次单击右键，并在 媒体（Media） 下选择 媒体播放器（Media Player）。在弹出的面板中 启用 视频输出媒体纹理资源（Video out Media Texture asset） 选项，然后单击 确定（OK），这样将创建一个 媒体纹理（Media Texture） 资源，并自动将其指定给我们正在创建的媒体播放器。此媒体纹理负责播放媒体内容，我们可以使用它来创建一个 材质，该材质将应用于关卡中的静态网格体。注意：这个播放器跟你平时看电影用的播放器是一样的，你需要打开这个播放器并播放里面的视频，场景里才会显示有视频播放的效果，不然是不会有播放效果的。想不用手动打开播放器，需要在关卡蓝图里设置（下面有说明）。 四、预览播放视频文件 双击**媒体播放器（Media Player）**文件，打开 MyPlayer 媒体播放器资源。 五、制作媒体材质 六、用蓝图控制视频播放 （一） 使视频在运行场景时自动循环播放 1、打开关卡蓝图2、在事件列表里添加【序列】节点
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e68606732030e9426ca70d1277951c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ebc61906df271444f21918a318620068/" rel="bookmark">
			电脑开机报警声音原因讲解！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Award BIOS 的报警及含义： 1短 系统正常启动2短 常规错误，只需进入COMOS设置中重新修改1长1短 内存或主板出错1长2短 键盘控制器错误1长3短 显卡或显示器错误1长9短 主板BIOS损坏不断的长声响 内存有问题不断的短声响 电源、显示器或声卡没有连接好重复的短声响 电源故障 对于AMI的 BIOS报警及含义
1短 内存刷新失败2短 内存ECC效验错误3短 640KB常规内存检查失败4短 系统时钟出错5短 CPU错误7短 系统实模式错误，无法切换到保护模式8短 显存错误9短 BIOS检测错误1长3短 内存错误1长8短 显示测试错误 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b324290a20404b391b0594ca1d6bfaec/" rel="bookmark">
			训练跑一半不动了，停在data = self._data_queue.get(timeout=timeout)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		可能是第三方库导致的线程问题，可以num_workers设置为0，但是太慢，github上说卸载conda安装的opencv-python 用pip install 安装，cv2是第三方库，可能是其导致的线程问题，也可能是dataloader里的数据有点问题，导致的线程出错啥的，所以我
1、重新装了opencv-python
2、numworks设置成2，就好使了，8还是不行，4也不行，也没有筛选不好的数据，数据应该是没啥问题，而且numworkers设置成4感觉比8快好多？
pip install opencv-python --user(--user是为了避免权限不够报错的问题)
另一种方式：换成torch1.8就也可以
一个调试经验：当程序不动时可以ctrl + c然后看终端里是在哪一行里代码停止的，来看程序卡到哪里
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80bebb61a115b6185d8fca4450787965/" rel="bookmark">
			Python爬虫实战100案例之001
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们可以利用爬虫来找到指定网站来获取我们想要获取的信息
比如我们想要获得王者荣耀和英雄联盟所有英雄的头像以及他们的名字
为了简便快捷我们可以写一个程序来快速的获取我们想要的
王者荣耀英雄头像获取
首先找到王者荣耀官网 然后依次选择 游戏资料 和 英雄资料
在该页面操作键盘上的 F12
然后依次点击 网络 和 停用缓存 以及左上角的刷新键 然后在过滤中输入 json 双击下方的 herolist.json 第二个文件
并复制该网址 备用
下载完成后 选择用记事本打开 途中的 ename 即为她的英文名 cname 为中文名
然后 依次点击图片 标头 复制请求网址 打开Pycharm输入 res 为赋予后面 requests.get的变量 而requests.get 意为请求访问刚刚保存以用来备用的网址；
print意为打印 输入 然后运行可以得到下面的 ename 以及 cname
import requests res = requests.get("https://pvp.qq.com/web201605/js/herolist.json") print(res.json()) 然后编写代码让他的角色显示的更清晰
取结果中的 ename 以及 cnema再给予变量
然后print 打印 结果获得 中文名cname 以及英文名 ename
给中文名和英文名一个变量 然后通过res给予的变量找到英雄的中英文名
然后 请求打开文件夹 并保存 最后运行就可以了
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/80bebb61a115b6185d8fca4450787965/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6581ad69c50c5773464747067446d960/" rel="bookmark">
			CentOS7&#43;VMware 14的安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🐧CentOS7的虚拟机安装教程 🌴一、WMware虚拟机的安装🐳步骤一：WMware安装教程： 🌴二、下载CentOS7系统光盘🚀三、安装步骤🐳步骤一：创建CentOS7环境🐳步骤二：CentOS7 系统安装 🌴一、WMware虚拟机的安装 🐬VMware 12 百度网盘下载：
链接：https://pan.baidu.com/s/1h_Agi9ILWv7qz97DILVUkw?pwd=safr
提取码：safr
🐬VMware 14 百度网盘下载：
链接：https://pan.baidu.com/s/1rvmKzjZGMYeTxOrjgofq1g?pwd=q4z8
提取码：q4z8
🐬VMware 16 百度网盘下载：
链接：https://pan.baidu.com/s/17j5VE5BhlJvyGWOsBheTjQ?pwd=zuvt
提取码：zuvt
这里给大家提供VMware 12 和 16 的资源下载，小🐯觉得WMware虚拟软件的版本选择其实没有那么重要，在12和16之间即可，重要的是对系统镜像光盘的选择，装什么系统就得选择什么样的光盘。
🐳步骤一：WMware安装教程： 1.右击选择管理员运行安装包 --&gt; 点击下一步
2.勾选“我接受许可”，点击下一步。
3.点击“更改”选择软件安装的位置，（建议不要安装到C盘）。点击下一步。
4.取消勾选检查产品更新和客户体验改进计划，点击下一步。
5.点击下一步。
6.点击安装。
7.安装中会弹出以下对话框，点击取消。
8.点击完成。
9.最后一个就是输入密钥：
建议支持正版软件。
🌴二、下载CentOS7系统光盘 CentOS-7-x86_64-DVD-1511.iso 镜像光盘下载
链接：https://pan.baidu.com/s/1vkZzgl2HgUQSpcs6GoJZww?pwd=me38
提取码：me38
小🐯提供一种线上下载方式：在阿里云下载 https://mirrors.aliyun.com/centos/镜像光盘。
选择要下载的版本即可。
🚀三、安装步骤 🐳步骤一：创建CentOS7环境 1.创建CentOS7环境
关闭防火墙（非必须，避免安装出现问题），然后启动VMware，选择新建虚拟机，也可以文件-&gt;新建虚拟机。
2.选择自定义，然后下一步。
3.选择版本，默认下一步。
4.选择稍后安装操作系统。
5.选择Linux，和CentOS系统对应的版本，然后下一步。
6.设置虚拟机名称和保存位置，然后下一步。
7.选择处理器数量、内核数量，两者乘积不能大于自己电脑的核心数，例如此电脑是8核。
可以分别选择数量和核心为：8 1,4 2， 2 4，1 8，可以选择数量中等，内核数量根据自己自己电脑内核选择，以下相当于最多可以使用4个处理器，每个处理器提供两个内核。
8.选择分配内容。
通常 &lt;= 电脑内存一半，比如电脑为4G就分配2G或者1G，例如此电脑16G内存，可以分配最多8G，再多不建议。也可以使用推荐内存大小，内存分配多，运行速度更快。
9.推荐设置网络模式为桥接网络。
10.默认即可，下一步。
11.默认即可，下一步。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6581ad69c50c5773464747067446d960/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82d5124559975299279ac5320f0ba43a/" rel="bookmark">
			adc通过采样时间计算总转换时间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3beaf7210a04cb77297f3dd8f78ff46/" rel="bookmark">
			【Android学习】kotlin语言基础知识学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、初始kotlin 二、kotlin编写器 intellij IDEA https://blog.csdn.net/rbx508780/article/details/126647849
在线网站 http://try.kotlinlang.org
3.Android studio https://blog.csdn.net/beita08/article/details/118885114
三、变量和函数 变量 格式：变量名：类型=变量值
两个关键字 1、val关键字：不可变变量 2、var关键字：可变变量 ***不需要表明类型，可以推导出来 也可以显式标记类型， val a = 10 var b = 10 val c : Int = 10 2、函数 格式：fun 函数名（参数名1：参数类型，参数名2：参数类型）：返回值类型{函数主体}
其中参数和返回值类型是可以缺少的
1）关键字fun 所有函数名前面都需要带关键字：fun
main函数是程序的入口，每个程序只能有一个main函数 2）关键字return 表示返回某个函数的值
示例：
package com.example.helloworld fun main() { println("Hello world.This is my first time to learn Kotlin Language!") println("c="+ addFun(2,3)) } //自定义一个相加的函数 fun addFun(a:Int,b:Int):Int{ val c = a+b return c } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b07d15791462cf9eaf1e77e620529ed7/" rel="bookmark">
			【自监督论文阅读笔记】EVA: Exploring the Limits of Masked Visual Representation Learning at Scale
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Abstract： 本文推出了 EVA，这是一个以视觉为中心的基础模型，旨在仅使用可公开访问的数据来探索大规模视觉表示的局限性。EVA 是一种经过预训练的普通 ViT，用于重建 以可见图像块为条件的 屏蔽掉的图像-文本对齐（image-text aligned）的视觉特征。通过这个前置任务，我们可以有效地将 EVA 扩展到 10 亿个参数，并在图像识别、视频动作识别、目标检测、实例分割和语义分割等广泛的代表性视觉下游任务上创造新记录，而无需大量监督训练。
此外，我们观察到 缩放 EVA 的量变导致迁移学习性能的质变，这在其他模型中是不存在的。例如，EVA 在具有挑战性的大词汇量实例分割任务中取得了巨大飞跃：本文的模型在具有超过一千个类别的 LVISv1.0 数据集和只有八十个类别的 COCO 数据集上实现了几乎相同的最先进性能。
除了纯粹的视觉编码器，EVA 还可以作为 以视觉为中心的多模态的支点 来连接图像和文本。我们发现从 EVA 初始化巨型 CLIP 的视觉塔可以 以更少的样本和更少的计算 极大地稳定训练 并优于从头开始的训练，为 扩大 和 加速 多模态基础模型的昂贵训练 提供了新的方向。为了方便未来的研究，本文发布了所有代码和十亿规模的模型。
（Code &amp; Models: https://github.com/baaivision/EVA）
1. Introduction 扩大预训练语言模型 (PLM) [9,63,76] 在过去几年彻底改变了自然语言处理 (NLP)。这一成功的关键在于掩码信号预测 [31、74] 的简单且可扩展的自监督学习任务，利用该任务，Transformer 模型 [101] 可以使用几乎无限的未标记数据扩展到数十亿个参数，并且只需很少的调整就可以很好地泛化到各种下游任务。随着计算、数据和模型规模的进一步扩展，PLM 不仅带来了持续的性能改进 [51、75、76]，而且令人惊讶地出现了上下文学习(in-context learning)能力 [9、25、107、108]。
受 NLP 模型扩展成功的推动，我们还可以将这种成功从语言转化为视觉，即 扩大以视觉为中心的基础模型，该模型有利于视觉和多模态下游任务。最近，掩码图像建模 (MIM) [5, 40, 116] 作为一种可行的视觉模型预训练和缩放方法得到了蓬勃发展。然而，最具竞争力的数十亿级视觉预训练模型 [33、64、71、123] 仍然 严重依赖监督或弱监督训练 以及数亿（通常是公开不可访问的）标记数据。 MIM 在某种程度上仅被用作 严格地监督预训练之前的 初始化阶段 [64]，或者纯 MIM 预训练模型无法在十亿规模的模型大小下实现良好的性能 [117]。我们认为这种差距源于自然图像是原始的且信息稀疏的事实。同时，理想的视觉前置任务 不仅需要 低级几何结构信息的抽象，还需要高级语义的抽象，而像素级恢复任务 很难捕获这些信息[115]。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b07d15791462cf9eaf1e77e620529ed7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02b7ccba5f276587ee3d8047a4a185af/" rel="bookmark">
			Go语言之Gin框架引用静态资源CSS的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 参考资料 Go语言之Gin框架，引用静态js、css文件，达到页面美化、打开网页提醒功能 原创
实践 目录结构 加载 // LoadStatic 加载静态资源 func (api *ApiPost) LoadStatic() { api.Route.Static("/static", "static") } 引入 &lt;!DOCTYPE html&gt; &lt;html lang="zh-cn"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;查询结果&lt;/title&gt; &lt;link rel="stylesheet" href="/static/style.css" type="text/css"&gt; &lt;/head&gt; 效果 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a6cd2285f5b9c2585252f2eae6ad37e/" rel="bookmark">
			简单的C语言航班管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		主要文件有mian.c 、interface.h、interface.c 、user.h、 user.c、userFile、flightMS.h、flightMS.c、flightFile.txt、Makefile
主要功能：实现了一个超级用户和普通用户，超级用户可以增删改查航班，普通用户只可以查询航班，使用makefile进行编译。
main.c 主要是不想在main函数写太多东西，所以直接只调用一个主页面函数，功能都在对应的页面中实现
#include "interface.h" int main(int argc, char *argv[]){ welcomeUI(); return 0; } interface.h 各个页面的头，这样可以让代码有层次感
#include "flightMS.h" #include "user.h" //界面头 //欢迎页面 void welcomeUI(); //用户界面 void userUI(); //登录页面 void loginUI(list_t* head, dclist_t* dchead); //用户注册页面 void enrollUI(list_t* head, dclist_t* dchead); //超级用户航班页面 void rootFlightUI(list_t* head, dclist_t* dchead); //普通用户航班页面 void commonFlightUI(list_t* head, dclist_t* dchead); //添加航班页面 void insertFlightUI(list_t* head, dclist_t* dchead); //修改航班页面 void updataFlightUI(list_t* head, dclist_t* dchead); interface.c 实现头文件中的函数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a6cd2285f5b9c2585252f2eae6ad37e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f30d74c1452e11bff32aa62bbe26d4fa/" rel="bookmark">
			内核模块（编译方法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、向内核添加新功能
1.1 静态加载法：
1.2 动态加载法：
a、新功能源码与Linux内核源码在同一目录结构下时
b、新功能源码与Linux内核源码不在同一目录结构下时
c、主机ubuntu下使用ko文件
d、开发板Linux下使用ko文件
二、内核模块基础代码解析
Linux内核的插件机制——内核模块
三、内核模块的多源文件编程
四、 内核模块信息宏
一、向内核添加新功能 1.1 静态加载法： 即新功能源码与内核其它代码一起编译进uImage文件内
1. 新功能源码与Linux内核源码在同一目录结构下
在linux-3.14/driver/char/目录下编写myhello.c，文件内容如下：
#include &lt;linux/module.h&gt; #include &lt;linux/kernel.h&gt; int __init myhello_init(void) { printk("#####################################################\n"); printk("#####################################################\n"); printk("#####################################################\n"); printk("#####################################################\n"); printk("myhello is running\n"); printk("#####################################################\n"); printk("#####################################################\n"); printk("#####################################################\n"); printk("#####################################################\n"); return 0; } void __exit myhello_exit(void) { printk("myhello will exit\n"); } MODULE_LICENSE("GPL"); module_init(myhello_init); module_exit(myhello_exit); 2. 给新功能代码配置Kconfig
cd ~/fs4412/linux-3.14/drivers/char
vim Kconfig
（就是给make menuconfig中添加一个菜单项） #39行处添加如下内容：
config MY_HELLO
tristate "This is a hello test"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f30d74c1452e11bff32aa62bbe26d4fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4930dbcea711a789b8c6659e8f5ab0a7/" rel="bookmark">
			OpenGL中的基本概念--着色器、光栅化、渲染管线
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 基本概念OpenGL中的渲染管线光栅化参考文献 基本概念 在 OpenGL 中，设置好顶点数据，设置好着色器，调用 drawcall 函数，3D 图形就被绘制出来了。那么在这背后，GPU 做了什么工作呢？其实，从输入的顶点 3D 信息，到输出每个像素点的颜色信息，中间经过了很多步操作。这些操作按照一定的顺序构成了一条图形流水线（Graphics Pipeline），或者叫渲染管线。每个步骤的输入都依赖于前一步骤输出的结果。其中的步骤包括顶点处理（vertex processing）、图元装配（triangle assembly）、光栅化（rasterization）、片段处理（fragment processing）、测试和混合（testing and blending）几个关键步骤。
作者：旷视科技
链接：https://www.zhihu.com/question/29163054/answer/2298413553
来源：知乎
OpenGL中的渲染管线 OpenGL中的整个光栅化渲染管线如下:
输入规范：顶点是什么？ 我们将要渲染的几何图形的类型以一种便于我们使用的光栅化过程的形式指定。
顶点着色器：移动到相机的视角 世界/物体空间→屏幕坐标：我们将输入几何的坐标从世界空间转换到与相机的透视对齐的新空间。
光栅化：三角形内有哪些像素？ 光栅化涉及确定给定图元在屏幕上覆盖的像素，以便我们可以计算每个覆盖像素的颜色。
片段着色器：每个像素是什么颜色？ 对于图元覆盖的每个给定像素，计算预期颜色。对于初学者，我们可能只是将每个像素着色为特定颜色，例如红色。稍后，片段着色器可用于执行更复杂的每像素计算，例如确定像素是亮还是暗的照明计算。
测试和混合：哪些像素是可见的？ 在这一点上，我们需要执行所谓的深度测试来确定是否已经为更近的物体计算了给定的像素。对于任何给定的透视图，某些几何图形可能会被其前面的其他几何图形隐藏。在光栅化阶段之后，我们将在每个像素的基础上解决这个问题。
光栅化 参考文献 OpenGL中渲染管线、着色器的含义、光栅化图形学渲染基础The Graphics Pipeline 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0cbd6e4dd1b709717ecbde3b6d434263/" rel="bookmark">
			Tomcat本地和在idea目录中详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 这里写目录标题 tomcat本地目录结构 tomcat本地目录结构 bin目录：主要存放tomcat的常用命令
startup、shutdown：用来关闭tomcatconf目录：放置配置文件
web.xml：配置servlet、filter、支持的文件类型等常用组件的配置
server.xml：配置端口号等
context.xml：配置tomcat配置文件所在位置
tomcat-users.xml：用来配置管理tomcat的用户与权限
Catalina目录：可以设置默认加载的项目lib目录：主要用来存放tomcat运行需要加载的jar包logs目录：用来存放tomcat在运行过程中产生的日志文件，非常重要的是在控制台输出的日志。webapps目录：用来存放应用程序，当tomcat启动时会去加载webapps目录下的应用程序。可以以文件夹、war包、jar包的形式发布应用。work目录：用来存放tomcat在运行时的编译后文件，例如JSP编译后的文件。 清空work目录，然后重启tomcat，可以达到清除缓存的作用 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5320c4a8771a8a487a1340fd80de51c/" rel="bookmark">
			深入剖析Tomcat原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		深入剖析Tomcat原理
一、 Tomcat源码部署和运行（intellij IDEA）
1、下载tomcat源码，以tomcat-8为例
链接: https://tomcat.apache.org/
2、源码部署到IDEA中
①创建新的空工程
②解压源码压缩包到该工程的目录（目录名最好是非中文和非空格组成的）下
③创建home文件，并将webapps和conf文件移入home文件中，目的是为了后期配置IDEA运行时参数时方便
④新建pom.xml文件，在其中添加tomcat运行时依赖：
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt; &lt;artifactId&gt;apache‐tomcat‐8.5.42‐src&lt;/artifactId&gt; &lt;name&gt;Tomcat8.5&lt;/name&gt; &lt;version&gt;8.5&lt;/version&gt; &lt;build&gt; &lt;finalName&gt;Tomcat8.5&lt;/finalName&gt; &lt;sourceDirectory&gt;java&lt;/sourceDirectory&gt; &lt;!-- &lt;testSourceDirectory&gt;test&lt;/testSourceDirectory&gt;--&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;java&lt;/directory&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;!--&lt;testResources&gt; &lt;testResource&gt; &lt;directory&gt;test&lt;/directory&gt; &lt;/testResource&gt; &lt;/testResources&gt;--&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;2.3&lt;/version&gt; &lt;configuration&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.easymock&lt;/groupId&gt; &lt;artifactId&gt;easymock&lt;/artifactId&gt; &lt;version&gt;3.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;ant&lt;/groupId&gt; &lt;artifactId&gt;ant&lt;/artifactId&gt; &lt;version&gt;1.7.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;wsdl4j&lt;/groupId&gt; &lt;artifactId&gt;wsdl4j&lt;/artifactId&gt; &lt;version&gt;1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5320c4a8771a8a487a1340fd80de51c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ad6de9e6c6f9e1ff835d574bd4e2070/" rel="bookmark">
			Flutter 生命周期
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Flutter中的生命周期主要包含两部分：
① 组件生命周期
在Flutter开发中，所有的组件和页面都继承自Widget，所以页面的生命周期其实就是Widget的生命周期。
② APP生命周期
主要指应用程序的可见性和响应用户输入的状态。
一、编写Demo 截图 1.1 main.dart APP入口页面创建MaterialApp加载PageA页面 import 'package:flutter/material.dart'; import 'package:learn_flutter/page/PageA.dart'; void main() { runApp(const MyApp()); } class MyApp extends StatelessWidget { const MyApp({Key? key}) : super(key: key); @override Widget build(BuildContext context) { return MaterialApp( title: 'Flutter Demo', theme: ThemeData( primarySwatch: Colors.blue, ), home: const PageA(title: 'PageA'), ); } } 1.2 PageA.dart PageA页面是一个有状态的页面混入WidgetsBindingObserver，监听App生命周期展示一个按钮，点击跳转PageB页面 import 'package:flutter/material.dart'; import 'package:learn_flutter/page/PageB.dart'; class PageA extends StatefulWidget { const PageA({Key? key, required this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ad6de9e6c6f9e1ff835d574bd4e2070/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c9b0ee23e4026d61346858e44db348c/" rel="bookmark">
			解决elasticsearch7.17.3 中的查询报出的异常
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在实体类上加注解
@JsonIgnoreProperties(ignoreUnknown=true)
co.elastic.clients.json.JsonpMappingException: Error deserializing co.elastic.clients.elasticsearch.core.search.Hit: jakarta.json.JsonException: Jackson exception (JSON path: hits.hits[0]._source) (line no=19, column no=19, offset=-1) at co.elastic.clients.json.JsonpMappingException.from0(JsonpMappingException.java:134) at co.elastic.clients.json.JsonpMappingException.from(JsonpMappingException.java:121) at co.elastic.clients.json.ObjectDeserializer.deserialize(ObjectDeserializer.java:206) at co.elastic.clients.json.ObjectDeserializer.deserialize(ObjectDeserializer.java:136) at co.elastic.clients.json.ObjectBuilderDeserializer.deserialize(ObjectBuilderDeserializer.java:85) at co.elastic.clients.json.JsonpDeserializerBase$ArrayDeserializer.deserialize(JsonpDeserializerBase.java:316) at co.elastic.clients.json.JsonpDeserializerBase$ArrayDeserializer.deserialize(JsonpDeserializerBase.java:280) at co.elastic.clients.json.JsonpDeserializer.deserialize(JsonpDeserializer.java:75) at co.elastic.clients.json.ObjectDeserializer$FieldObjectDeserializer.deserialize(ObjectDeserializer.java:71) at co.elastic.clients.json.ObjectDeserializer.deserialize(ObjectDeserializer.java:180) at co.elastic.clients.json.ObjectDeserializer.deserialize(ObjectDeserializer.java:136) at co.elastic.clients.json.JsonpDeserializer.deserialize(JsonpDeserializer.java:75) at co.elastic.clients.json.ObjectBuilderDeserializer.deserialize(ObjectBuilderDeserializer.java:79) at co.elastic.clients.json.ObjectDeserializer$FieldObjectDeserializer.deserialize(ObjectDeserializer.java:71) at co.elastic.clients.json.ObjectDeserializer.deserialize(ObjectDeserializer.java:180) at co.elastic.clients.json.ObjectDeserializer.deserialize(ObjectDeserializer.java:136) at co.elastic.clients.json.JsonpDeserializer.deserialize(JsonpDeserializer.java:75) at co.elastic.clients.json.ObjectBuilderDeserializer.deserialize(ObjectBuilderDeserializer.java:79) at co.elastic.clients.json.DelegatingDeserializer$SameType.deserialize(DelegatingDeserializer.java:43) at co.elastic.clients.json.DelegatingDeserializer$SameType.deserialize(DelegatingDeserializer.java:43) at co.elastic.clients.transport.endpoints.EndpointWithResponseMapperAttr$1.deserialize(EndpointWithResponseMapperAttr.java:56) at co.elastic.clients.transport.rest_client.RestClientTransport.decodeResponse(RestClientTransport.java:328) at co.elastic.clients.transport.rest_client.RestClientTransport.getHighLevelResponse(RestClientTransport.java:294) at co.elastic.clients.transport.rest_client.RestClientTransport.performRequest(RestClientTransport.java:147) at co.elastic.clients.elasticsearch.ElasticsearchClient.search(ElasticsearchClient.java:1458) at com.example.springes.SpringEsApplicationTests.queryAllDocument(SpringEsApplicationTests.java:152) at sun.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c9b0ee23e4026d61346858e44db348c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb4a6ecedb22a47832b100a79fd586f9/" rel="bookmark">
			resnet网络中1*1卷积核如何进行升维和降维
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		左图是resnet34的残差结构，右图是resnet101、152等的残差结构。
右图中，输入图像有256个维度,用64个11256的卷积核对输入图像进行运算，得到64维度，即11卷积核对图像进行了降维。**展开来说：**用一个11256卷积核对图像进行卷积操作是不是得到了一个数，那用64个11256的卷积核对图像进行卷积操作就得到了64个数，也就是64个维度。
也就是说，通道数就是卷积核的个数，进行11的卷积运算可以任意的变换通道数。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/202f1f3f899b7b8114fc45ecc40daccf/" rel="bookmark">
			python ini转json dict转ini
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 from configparser import ConfigParser import json def ini2json(ini_path): """ :param ini_path: ini文件路径 :return:ini文件转变成json """ d = {} cfg = ConfigParser() cfg.read(ini_path) for s in cfg.sections(): print(s) d[s] = dict(cfg.items(s)) return json.dumps(d) def dic2ini(dic, ini_path): """ :param dic: python字典 :param ini_path: ini文件路径 :return:ini文件转变成json """ config = ConfigParser() for key in dic: config.add_section(key) for key1 in dic[key]: config.set(key, key1, dic[key][key1]) config.write(open(ini_path, "w")) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0404c3f7bf3b3c1a686412fe51838533/" rel="bookmark">
			【正点原子FPGA连载】第十章PS SYSMON测量温度电压实验 摘自【正点原子】DFZU2EG_4EV MPSoC之嵌入式Vitis开发指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1）实验平台：正点原子MPSoC开发板
2）平台购买地址：https://detail.tmall.com/item.htm?id=692450874670
3）全套实验源码+手册+视频下载地址： http://www.openedv.com/thread-340252-1-1.html
第十章PS SYSMON测量温度电压实验 系统监视器(System Monitors)是MPSOC中用来测量电压和温度的模块，能够将电压和温度信息提供给系统的其它部分，包括平台管理单元(PMU)，实时处理单元(RPU)和应用处理单元(APU)。MPSOC中有两个SYSMON模块：PL端SYSMON模块和PS端SYSMON模块。
本章我们将使用PS端SYSMON模块，读取芯片的温度电压等信息。本章包括以下几个部分：
1010.1简介
10.2实验任务
10.3硬件设计
10.4软件设计
10.5下载验证
10.1简介 PS SYSMON模块位于PS端低功耗域内，由VCC_PSAUX和VCC_PSADC供电。PS SYSMON能同时测量两个温度和几个固定的电压节点。AXI互联主机通过PS SYSMON和AMS寄存器组控制PS端SYSMON模块。
MPSOC中PS SYSMON和PL SYSMON模块都属于SYSMONE4结构，结构上存在很多相似处。也有许多不同点，例如采样率，参考电压，编程接口，电源域，温度传感器等。PS SYSMON模块框图如下图所示：
图10.1.1 PS SYSMON模块框图
PS SYSMON监测的内部电压节点位于低功耗域和全功耗域，包含内部和IO缓冲区节点。PS中所有电压测量都是单极的，内部电压节点测量范围是03V或06V。PS内部有两个温度传感器，一个物理位置在RPU附近，另外一个在APU附近。在图10.1.1中，软件通过APB SLAVE接口配置PS SYSMON的寄存器。
PS和PL的SYSMON模块各自独立运行。运行模式包括单通道读模式，默认的序列模式和自动序列器模式，SYSMON通常以默认的序列模式运行。在默认模式下，可以通过CONFIG_REG寄存器将SYSMON配置成自定义序列。
单通道读模式一次只能测量一个通道的传感器信号。在使用单通道模式时，先向CONFIG_REG0寄存器[mux_channel]比特位写入通道序号，再将CONFIG_REG1寄存器[sequence_mode]比特位设置成单通道模式，然后等待EOC(end of conversion)中断，当中断触发时，读取相关测量寄存器。
自动序列器模式下，SYSMON模块可以一次或连续的对打开的通道列表进行顺序访问。模拟输入按照固定顺序进行时间多路复用，并且每次只有一路信号送给ADC输入。读取每个通道的测量值时，最大值和最小值都会被存储。测量值也可以在连续测量结果的平均值。
10.2实验任务
本章的实验任务是通过APB Slave接口，读取PS SYSMON测量的芯片温度、供电电压等信息，并通过串口打印出来。
10.3硬件设计
根据实验任务我们可以画出本次实验的系统框图，如下图所示：
图 10.3.1 系统框图
在图 10.3.1中，CPU作为AXI主机连接到SYSMON模块APB Slave接口，读取SYSMON模块采集的温度和电压数据，然后通过串口打印出来。
本次实验在《Hello World》实验中的最小系统上就可以完成，也就是说不需要额外配置PS端或者添加PL端的外设。
打开《hello_world》工程，另存为本次实验工程《ps_sysmon》，导出硬件设计(Hardware)，具体步骤可以参照前面的实验，最后打开Vitis软件。
10.4软件设计
在VITIS软件中新建一个空的应用工程，应用工程名为“ps_sysmon”。然后为应用工程新建一个源文件“main.c”，我们在新建的main.c文件中输入本次实验的代码：
1 #include "xsysmonpsu.h" 2 #include "xparameters.h" 3 #include "xstatus.h" 4 #include "stdio.h" 5 #include "sleep.h" 6 7 #define SYSMON_DEVICE_ID XPAR_XSYSMONPSU_0_DEVICE_ID 8 #define printf xil_printf 9 10 int PS_SYSMON_Test(u16 SysMonDeviceId); 11 static int SysMonPsuFractionToInt(float FloatNum); 12 static XSysMonPsu SysMonInst; //PS SYSMON实例 13 14 int main(void) 15 { 16 xil_printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0404c3f7bf3b3c1a686412fe51838533/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/367d4821267fe0e91b77c837d15f0b0d/" rel="bookmark">
			字符串encodeURIComponent（编码）/decodeURIComponent（解码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引入：
cookie能不能存中文？ * 在tomcat 8 之前 cookie中不能直接存储中文数据。 * 需要将中文数据转码---一般采用URL编码(%E4%B8%E3)（%两位十六进制数） * 在tomcat 8 之后，cookie支持中文数据。特殊字符还是不支持，建议使用URL编码存储URLEncoder.encode(str_date,"utf-8");，URL解码解析URLDecoder.decode(time, "utf-8"); URL（统一资源定位符）编码方法是属于 Global 全局对象的，encodeURI() 和 encodeURIComponent() 方法可以对URI(通用资源标示符)进行编码，以便发送给浏览器，有效的URI中不能包含某些字符，例如空格。而这两个URI编码方法就可以对URI进行编码，它们用特殊的UTF-8编码替换所有无效的字符，从而让浏览器能够接受和理解。
其中 encodeURI() 主要用于整个URI，而 encodeURICompoent() 主要用于对URI中的某一段进行编码。它们的主要区别在于，encodeURI() 不会对本身属于URI的特殊字符进行编码，例如冒号、正斜杠、问号和井字号；而 encodeURIComponent 则会对它发现的任何非标准字符进行编码。
与上述两个方法相对应的两个方法分别是 decodeURI() 和 decodeURIComponent() 。其中，decodeURI() 只能对使用 encodeURI() 替换的字符进行解码。decodeURIComponent() 能够解码使用 encodeURIComponent() 编码的所有字符串。
$(function () { /*var search = location.search; //alert(search);//?id=5 var cid = search.split("=")[1];*/ //获取cid的参数值 var cid = getParameter("cid"); //获取输入框rname的参数值 var rname = getParameter("rname");//得到的是url编码 //判断rname如果不为null且不等于"" if (rname) { //有值 //url解码 rname = window.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/367d4821267fe0e91b77c837d15f0b0d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ad5b48f2ff7e517fd4a11eeec3742ab/" rel="bookmark">
			vant2列表与动态表单
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		//index.vue &lt;template&gt; &lt;div class="equi_container"&gt; &lt;div style="text-align: center;background-color: #bdd2ff;min-height: 3.125rem;color: #fff;line-height: 3.125rem;"&gt; 我的待办&lt;span style="font-size: 10px;"&gt;{{'('+total+'条)'}}&lt;/span&gt; &lt;/div&gt; &lt;van-search v-model="queryParams.search" show-action placeholder="请输入搜索关键词" @search="onSearch" @cancel="onCancel" /&gt; &lt;van-pull-refresh v-if="gettokenflag" v-model="isLoading" @refresh="onRefresh" &gt; &lt;van-list style="height: 100%;" v-model="loading" :finished="finished" finished-text="- 没有更多了 -" @load="loadMore" :offset="130" &gt; &lt;div v-for="(item,index) in myList" @click="handleLink(item)"&gt; &lt;van-cell center :key="index" :title="item.flow_call.flow_call_title" &gt; &lt;template #title&gt; &lt;span class="custom-title"&gt;{{item.flow_call.flow_call_title}}&lt;/span&gt; &lt;/template&gt; &lt;div slot="label"&gt; &lt;span class="sapncla"&gt;流水号:{{item.flow_call.run_serial_num}}&lt;/span&gt; &lt;span class="sapncla"&gt;发起人:{{item.flow_call.initiator}}&lt;/span&gt; &lt;!-- &lt;span class="sapncla"&gt;当前步骤:{{item.current_node.node_name}}&lt;/span&gt; --&gt; &lt;/div&gt; &lt;!-- &lt;div slot="extra"&gt;创建时间:{{item.create_time}}&lt;/div&gt; --&gt; &lt;/van-cell&gt; &lt;van-divider dashed :style="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ad5b48f2ff7e517fd4a11eeec3742ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78bef2d47580573b28b51ee0f6cd28af/" rel="bookmark">
			【elementUI】自定义封装el-upload上传内容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 为实现如图所示功能，点击第一步弹出模态框，第二部将所有文件导入，第三步点击确定的时候上传到后台接口，封装一个组件
1.搭建template
&lt;div style="display: inline-block; margin-left: 10px;"&gt; &lt;el-button type="warning" class="filter-item" icon="el-icon-upload" @click="uploadDialog"&gt;导入&lt;/el-button&gt; &lt;el-dialog title="提示" :visible.sync="uploadBox" width="30%"&gt; &lt;el-upload class="upload-demo" ref="uploadForm" :http-request="upLoad" action multiple drag :before-remove="beforeRemove" :file-list="fileList" :auto-upload="false" :limit="1"&gt; &lt;i class="el-icon-upload"&gt;&lt;/i&gt; &lt;div class="el-upload__text"&gt;点击将文件传入&lt;/div&gt; &lt;/el-upload&gt; &lt;span slot="footer" class="dialog-footer"&gt; &lt;el-button @click="uploadBox = false"&gt;取 消&lt;/el-button&gt; &lt;el-button type="primary" @click="submitUpload"&gt;确 定&lt;/el-button&gt; &lt;/span&gt; &lt;/el-dialog&gt; &lt;/div&gt; 阅读官方文档可知，主要的参数属性为：
action：必选参数，上传的地址，string类型
为实现自定义上传的内容，即上传的网址为后端提供的接口，需要修改如下属性：
http-request:覆盖默认的上传行为，可以自定义上传的实现
为实现第三步，点击确定之后再上传，需要修改的属性为：
auto-upload:是否在选取文件后立即进行上传，改为false
其他限制属性（以本文为例）：
multiple 是否支持多选文件 boolean
drag 是否启用拖拽上传 boolean
before-remove 删除文件之前的钩子，参数为上传的文件和文件列表，若返回 false 或者返回 Promise 且被 reject，则停止删除。 function(file, fileList)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/78bef2d47580573b28b51ee0f6cd28af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1032a337e81d4ae63bd90cbcc5787de1/" rel="bookmark">
			vue3 遇到 reactive响应式失效问题记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		情况简述： 初始化了一个reactive的空数组，之后调用接口，将接口返回的数据赋值给这个reactive，此时发现页面数据并没有更新。（场景：ele-table的dataList）
const dataList = reactive([]); const load = async () =&gt; { const res = await 接口函数（）; //假设请求接口返回的数据 // 方法1 失败，直接赋值丢失了响应性 // dataList = res; // 方法2 这样也是失败 // dataList.concat(res); }; 原因：
直接把一个新的数组赋值给dataList,导致reactive声明的响应式对象由dataList代理
被新的数组所替代,因为在操作代理对象的时候需要有代理对象作为前提,所以失去了响应式
在vue3中不管是对象还是数组都不能直接将整个数据进行赋值，这样会造成reactive定义的响应式失效
就像对象的地址被替换，就不是原来的那个对象了
解决办法：
方法1：创建一个响应式对象，对象的属性是数组 let datalist = reactive({ list: [], }) let arr = [1,2,3] datalist.list = arr 方法2：使用ref函数（ref可以创建任意数据类型，reactive只能创建对象或者数组） const datalist = ref([]) datalist.value = [1, 2, 3] 方法3：数组的push let datalist = reactive([]) let arr = [1, 2, 3] arr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1032a337e81d4ae63bd90cbcc5787de1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c043fec954c0db509451e1791ccdb11e/" rel="bookmark">
			centos7系统参数优化（max_map_count、overcommit_memory、panic_on_oom、oom_kill_allocating_task）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录表 一、修改系统参数二、linux参数之max_map_count三、linux参数之overcommit_memory：案例一 （物理内存的外碎片回收）问题问题分析 四、OOM-killer1、panic_on_oom2、oom_kill_allocating_task3、oom_dump_tasks4、oom_score_adj、oom_adj、oom_score 五、Linux内核调优部分参数说明 一、修改系统参数 系统参数修改可以通过下面三种方式，这里以panic_on_oom为例做个示范：
1、直接写文件（重启后失效）
echo 2&gt; /proc/sys/vm/panic_on_oom 2、通过控制命令（重启后失效）
sysctl vm.panic_on_oom=2 3、修改配置文件（重启后继续生效）
vim /etc/sysctl.conf vm.panic_on_oom=2 #重新加载sysctl.conf，使修改立即生效 sysctl -p 4、查看参数值
sysctl -a|grep vm.panic_on_oom 二、linux参数之max_map_count max_map_count文件包含限制一个进程可以拥有的VMA(虚拟内存区域)的数量，默认值是65536。
虚拟内存区域（VMA）是一个连续的虚拟地址空间区域。
在进程的生命周期中，每当程序尝试在内存中映射文件，链接到共享内存段，或者分配堆空间的时候，这些区域将被创建。
调优这个值将限制进程可拥有VMA的数量。限制一个进程拥有VMA的总数可能导致应用程序出错，因为当进程达到了VMA上线但又只能释放少量的内存给其他的内核进程使用时，操作系统会抛出内存不足的错误。
如果你的操作系统在NORMAL区域仅占用少量的内存，那么调低这个值可以帮助释放内存给内核用。
调整示例，如下调整为默认的4倍，此操作需要root权限
**临时修改：**
[root@localhost ~]# sysctl -w vm.max_map_count=262144 **永久修改：**
直接写到/etc/sysctl.conf中,然后执行sysctl -p
[root@localhost ~]# vim /etc/sysctl.conf vm.max_map_count=262144 [root@localhost ~]# sysctl -p **查看修改结果**
[root@localhost ~]# sysctl -a|grep vm.max_map_count vm.max_map_count = 262144 三、linux参数之overcommit_memory： 内存分配策略：vm.overcommit_memory：
可选值：
0， 表示内核将检查是否有足够的可用内存供应用进程使用；如果有足够的可用内存，内存申请允许；否则，内存申请失败，并把错误返回给应用进程。
1， 表示内核允许分配所有的物理内存，而不管当前的内存状态如何。
2， 表示内核允许分配超过所有物理内存和交换空间总和的内存
查看vm.overcommit_memory值
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c043fec954c0db509451e1791ccdb11e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aaa712f68050c1606424802fd03db5c4/" rel="bookmark">
			【Ubuntu】Ubuntu常见优化设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言配置阿里云镜像设置root用户密码用户组相关安装jdk安装git解压文件 前言 本笔记基于 Ubuntu20.04
因工作需要，需要长期使用Ubuntu系统，在这里记录下Ubuntu系统常见优化设置；笔记长期更新，欢迎收藏； 配置阿里云镜像 更改之前确保已经安装好了vim，默认版本是没有安装的，不然在更改期间再进行安装会失败；跟着步骤走就可以了有条件的建议不改镜像，国内镜像有时候会遇到问题，亲测； cd /etc/apt/ mv sources.list sources.list.back rm -rf sources.list # 内容如下 vim sources.list 文件替换内容如下 deb http://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ trusty-proposed main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiverse deb-src http://mirrors.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aaa712f68050c1606424802fd03db5c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e15ca9b3bc61cb8e5974836c7858296/" rel="bookmark">
			【MifareClassicTool】小米NFC手机模拟加密门禁详细教程(Android手机通用)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mifare官方最新版地址https://www.icaria.de/mct/releases/3.0/
· 资源名称：MifareClassicTool
· 资源分类：Android NFC类软件
· 资源大小：960.5 Kb
· 资源版本：V2.2.3
准备工具：
①、MifareClassicTool 安卓NFC经典工具（本贴下方链接提供）；
②、小米带NFC手机（本人用Mi Note3测试，其它机型未测试）；
③、淘宝一张CUID白卡（简化一点说明：原加密卡经软件解密后写入此CUID白卡后变成非加密卡，从而实现导入手机模拟卡）；
借用原作者“canwe”的叙述，为什么要用CUID呢？
下面科普一下：
淘宝nfc卡片的区别
⑴.UID卡(国外称GEN1)
所有区块可被重复读写
卡片ID可改且使用后门指令更改ID
ID可被重复修改响应后门指令(意味着可被使用后门指令检测是否为克隆卡的机器发现)；
⑵.CUID卡(国外称GEN2)
所有区块可被重复读写
卡片ID可改且使用普通写指令更改ID
ID可被重复修改不响应后门指令(意味着不容易被反克隆系统发现)；
⑶.FUID卡(国外称GEN2)
0区块可写且仅可写入一次
使用普通写指令更改ID
由于0区块锁死后与普通M1卡无异，所以更“反克隆”。
如上，由于手机的NFC功能只能用普通指令写入数据，不能用后门指令写入，因此若要写入0区块，必须买CUID卡，而PN532/ACR122U/PM3则可写入所有卡种。
模拟思路：
众所周知小米手机的NFC功能现在可以模拟门禁卡，非常方便，但是现在好多加密卡，小米是不能模拟的，可能为了安全。这些加密卡一般都是饭卡门禁一体的那种卡片，而门禁一般读取id卡片的0扇区里面的id卡号。
所以要用小米的nfc模拟加密门禁的思路就是，把现有卡片的数据读出，然后把0扇区的数据写入新的白卡中，然后用小米的模拟门禁卡功能模拟卡片。
模拟步骤：
①、启动MCT软件，如图一，点选“读标签”选项；
↑↑↑↑（论坛排版问题所致，第一副图好像怎么都错位的，没办法放前面了。）↑↑↑↑
②、勾选“std.keys”选项；
③、用MCT读取加密门禁卡，下方出现“发现新标签（UID:……）”；
④、点击软件最下方“启动映射并读取标签”按钮；
⑤、映射读取标签后，点选软件右上方“储存”图标；
⑥、软件出现“保存转储“选项，个人可依自身习惯是否修改名称，然后点击”保存”按钮保存标签；
⑦、回到软件主界面，点选“写标签”选项；
⑧、点选“写转储(克隆)”选项，并执行“选择转储”操作；
⑨、勾选刚刚保存的标签，选择后点击软件最下方“选择转储”进行下一步操作（须注意的是，此时需将CUID空白卡至于手机NFC感应区）；
⑩ 、只勾选刚刚“扇区0”数据，然后点击软件最下方“好的”进行最终写入模拟操作；
模拟完成
如果淘宝买专业的nfc读写设备，更可以利用小米的模拟空白卡片功能把加密的饭卡都写入手机或者手环。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9da07ea953da369c45f824317b8b2c86/" rel="bookmark">
			Jetson Xavier NX设备将opencv和tensorrt链接到conda环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注意安装的时候先查看设备旧版本的opencv，卸载干净后再装。 Jetpack4.6
opencv4.1.1
conda安装 过程翻一下之前的博客把，下面是创建环境开始
conda create -n py36 python=3.6.9 OPENCV_EXTRA_MODULES_PATH=/home/ta/open/opencv_contrib-4.1.1/modules #这个是opencv_contrib文件，附加的face等lib库需要用到这个链接内的内容
-DBUILD_SHARED_LIBS=ON #这个决定是否生成 cv2.cpython-36m-aarch64-linux-gnu.so to cv2.so 文件，连接到虚拟环境用
-DOPENCV_GENERATE_PKGCONFIG=ON # 这个决定是否生成opencv.pc的配置文件
-DPYTHON_DEFAULT_EXECUTABLE=/home/nvidia/archiconda3/envs/yolo5/bin/python3.6m #这个决定安装在哪个python上
编译步骤先下载两个opencv的压缩包，具体过程看下之前的文章内的脚本，cmake的内容可以根据实际需求进行添加
cmake \ -DBUILD_opencv_python3=ON \ -DBUILD_opencv_python2=OFF \ -DPYTHON3_EXECUTABLE=/home/nvidia/archiconda3/envs/yolo5/bin/python3.6m \ -DPYTHON_INCLUDE_DIR=/home/nvidia/archiconda3/envs/yolo5/include/python3.6m \ -DPYTHON_LIBRARY=/home/nvidia/archiconda3/envs/yolo5/lib/libpython3.6m.so \ -DPYTHON_NUMPY_INCLUDE_DIRS=/home/nvidia/archiconda3/envs/yolo5/lib/python3.6/site-packages/numpy/core/include \ -DPYTHON_PACKAGES_PATH=/home/nvidia/archiconda3/envs/yolo5/lib/python3.6/site-packages \ -DPYTHON_DEFAULT_EXECUTABLE=/home/nvidia/archiconda3/envs/yolo5/bin/python3.6m \ -DCMAKE_INSTALL_PREFIX=/usr/local \ -DBUILD_EXAMPLES=OFF \ -DOPENCV_GENERATE_PKGCONFIG=ON \ -DCUDA_TOOLKIT_ROOT_DIR=/usr/local/cuda \ -DCMAKE_BUILD_TYPE=RELEASE \ -DOPENCV_ENABLE_NONFREE=1 \ -DWITH_FFMPEG=1 \ -DCUDA_ARCH_BIN=7.2 \ -DCUDA_ARCH_PTX=7.2 \ -DWITH_CUDA=1 \ -DENABLE_FAST_MATH=1 \ -DCUDA_FAST_MATH=1 \ -DWITH_CUBLAS=1 \ -DOPENCV_EXTRA_MODULES_PATH=../../opencv_contrib-4.1.1/modules \ .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9da07ea953da369c45f824317b8b2c86/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54955e0c1e7271fc4123edc1f72e617a/" rel="bookmark">
			查看linux服务命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个很好用,service是个脚本
service --status-all
这个里面也能看到相应的服务
cd /etc/init.d
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca7dd8844f0121724e781488adf6b39a/" rel="bookmark">
			pytorch绘制loss曲线
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 PyTorch 可以通过 Matplotlib 库绘制 loss 曲线，具体实现方法如下：
导入 Matplotlib 库：
import matplotlib.pyplot as plt 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e85827d08e7ccb20112c4dc9564f58dc/" rel="bookmark">
			Vue中引用全局变量的方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 方式一： 一：新建一个global文件 写上需要全局引用的变量。
#glbal.js const gb1=123; const gb2=123; const gb3=123; const gb4=123; export default { gb1,gb2,gb3,gb4 } 二：在main.js中引用global文件
import gb from "@/global/global"; Vue.prototype.$global = gb; 三：在具体文件中引用
console.log(this.$global.gb1); 方式二 在global中写出全局数据以后，再具体使用文件中引用
#glbal.js const gb1=123; const gb2=123; const gb3=123; const gb4=123; export default { gb1,gb2,gb3,gb4 } 具体使用文件中
#在script中引用 import gb from "@/global/global" #然后再需要使用的地方调用 console.log("global===&gt;",gb.gb1) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7ae0ac3961f7c202593f0ef5e983253/" rel="bookmark">
			unity 用代码改变camera projection 下的size
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在Unity中，可以使用代码来更改摄像机的投影大小(orthographic size)。以下是一些示例代码，可以在脚本中使用：
// 获取主摄像机 Camera mainCamera= Camera.main; // 更改摄像机投影大小为 5 mainCamera.orthographicSize = 5f; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f50020ed61b2d48cf064eab4050a9b89/" rel="bookmark">
			MobaXterm详细使用教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这一篇MobaXterm详细使用教程，我们来介绍一下如何设置并用MobaXterm来连接Linux服务器。 MobaXterm 又名 MobaXVT，是一款增强型终端、X 服务器和 Unix 命令集(GNU/ Cygwin)工具箱。
MobaXterm 可以开启多个终端视窗，以最新的 X 服务器为基础的 X.Org，可以轻松地来试用 Unix/Linux 上的 GNU Unix 命令。这样一来，我们可以不用安装虚拟机来试用虚拟环境，然后只要通过 MobaXterm 就可以使用大多数的 linux 命令。MobaXterm 还有很强的扩展能力，可以集成插件来运行 Gcc, Perl、Curl、Tcl / Tk / Expect 等程序。
MobaXterm 分免费开源版和收费专业版。官网提供 MobaXterm 的免费开源版 “Home Edition” 下载, 免费开源版又分绿色免安装版(解压即用)和安装版(需要一步步安装)。MobaXterm 免费版(personal)和专业版(Professional)除了 sessions 数、SSH tunnels 数和其他一些定制化配置外限制外，免费版在终端底部还多了一个 “UNREGISTERED VERSION” 提示。
MobaXterm主要功能：
支持各种连接 SSH，X11，RDP，VNC，FTP，MOSH
支持 Unix 命令(bash，ls，cat，sed，grep，awk，rsync，…)
连接 SSH 终端后支持 SFTP 传输文件
各种丰富的插件(git/dig/aria2…)
可运行 Windows 或软件
MobaXterm详细使用教程（一） 1. 软件的安装
官网下载后解压文件，运行 MobaXterm_Personal_11.1.exe 即可开始安装。第一次打开会自解压，会比较慢，后续就正常了。
2. 创建SSH session
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f50020ed61b2d48cf064eab4050a9b89/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5df2623427c17f7ac91a0a8100c14da9/" rel="bookmark">
			unity 如何判断光标位置在UI上
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在Unity中，您可以使用以下方法来确定光标位置是否在UI元素上：
使用EventSystem.current来获取当前事件系统。使用PointerEventData来获取当前指针事件数据。使用RectTransformUtility.RectangleContainsScreenPoint()方法来检查UI元素是否包含光标位置。 下面是一个示例代码：
using UnityEngine; using UnityEngine.EventSystems; public class Example : MonoBehaviour { pub 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae0ed4e09eff794c5412dbf446e01491/" rel="bookmark">
			git操作之cherry-pick
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当我们在合并分支时，是将源分支的所有内容都合并到目标分支上，有的时候我们可能只需要合并源分支的某次或某几次的提交，这个时候我们就需要使用到git的cherry-pick操作了。cherry-pick翻译成中文就是摘樱桃的意思，也就是有选择性的。
大家看看这张图 （画图水平有限，只能画成这样了，大家将就看看）
图中从master分支中拉出了一条分支叫做dev分支，dev分支上有三次提交记录，如果这个时候直接使用merge操作那么就会将dev分支上的三次提交记录全部合并到master分支上，这个时候我们使用cherry-pick就可以挑选dev分支的某一次或几次提交记录有合并到master分支上。
当前我使用git log --oneline命令查看了我dev分支上的提交记录信息，每一次提交记录前都会有对应的提交版本号，这里我暂且用commitid替代
1、git cherry-pic commitid
去合并某分支的某一次提交记录
2、git cherry-pick commitid1 commitid2 ...
有挑选性的去合并分支的某几次提交记录
3、git cherry-pick commitid1..commitid2
合并提交记录commitid1到commitid2之间的所有的提交记录，但不包含commitid1的这次提交记录
4、git cherry-pick commitid1^..commitid2
合并提交记录commitid1到commitid2之间的所有的提交记录，包含commitid1的这次提交记录
5、git cherry-pick 分支名
合并该分支上最新的一次提交记录
cherry-pick时出现冲突该如何解决？ 1、继续执行cherry-pick 用户手动先手动解决有冲突的文件，然后将文件重新加入暂存区(git add)，第二步使用如下命令让cherry-pick继续执行
git cherry-pick --continue
2、取消cherry-pick 如果认为冲突太多了，不想继续cherry-pick,那么可以使用如下命令取消cherry-pick,这个时候会恢复到cherry-pick前的样子
git cherry-pick --abort
3、发生代码冲突后，退出 cherry pick，但是不回到操作前的样子 git cherry-pick --quit
这种情况属于摆烂行为，一般不会这么用
注意：完成cherry-pick后变更的文件不会在暂存区里出现，也就是使用git status是查看不到的，确认无误后直接使用git push推送到远程库即可
这是是cherry-pick的一部分用法，当然cherry-pick还有其他操作，感兴趣的话大家可以自己拓展一下，这次就给大家分享这么多，非常感谢大家的阅读和支持！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d4ada47396450caeead733406626e34/" rel="bookmark">
			cn.hutool.http.HttpException: Connection reset 问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		场景 项目A给项目B接口发送数据；项目使用的是hutool的http工具类；本地、测试环境均正常，生产出现了错误，明细： cn.hutool.http.HttpException: Connection reset at cn.hutool.http.HttpResponse.init(HttpResponse.java:495) at cn.hutool.http.HttpResponse.initWithDisconnect(HttpResponse.java:468) at cn.hutool.http.HttpResponse.&lt;init&gt;(HttpResponse.java:81) at cn.hutool.http.HttpRequest.doExecute(HttpRequest.java:1130) at cn.hutool.http.HttpRequest.execute(HttpRequest.java:1012) at cn.hutool.http.HttpRequest.execute(HttpRequest.java:988) at com.ylx.review.service.impl.YlxPrePatientServiceImpl.sendYlxStatus(YlxPrePatientServiceImpl.java:142) at com.ylx.web.controller.review.YlxPrePatientController.editSave(YlxPrePatientController.java:260) at com.ylx.web.controller.review.YlxPrePatientController$$FastClassBySpringCGLIB$$2d13b7af.invoke(&lt;generated&gt;) at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218) at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:771) ....... Caused by: java.net.SocketException: Connection reset at java.net.SocketInputStream.read(SocketInputStream.java:210) at java.net.SocketInputStream.read(SocketInputStream.java:141) at java.io.BufferedInputStream.fill(BufferedInputStream.java:246) at java.io.BufferedInputStream.read1(BufferedInputStream.java:286) at java.io.BufferedInputStream.read(BufferedInputStream.java:345) at sun.net.www.http.HttpClient.parseHTTPHeader(HttpClient.java:704) at sun.net.www.http.HttpClient.parseHTTP(HttpClient.java:647) at sun.net.www.http.HttpClient.parseHTTP(HttpClient.java:675) at sun.net.www.protocol.http.HttpURLConnection.getInputStream0(HttpURLConnection.java:1569) at sun.net.www.protocol.http.HttpURLConnection.getInputStream(HttpURLConnection.java:1474) at java.net.HttpURLConnection.getResponseCode(HttpURLConnection.java:480) at cn.hutool.http.HttpConnection.responseCode(HttpConnection.java:470) at cn.hutool.http.HttpResponse.init(HttpResponse.java:492) ... 104 common frames omitted 我的排查步骤(仅供参考) 生产环境接口测试没有问题；在服务器同样可以ping通生产环境，排除白名单问题；使用timeout()设置的超时时间，同样也记录了方法调用时间，均没有问题，并不是超时所导致的异常； 我的解决方法 因为对方服务器接口为put方法，所以我的调用写法为HttpRequest.put(xxxUrl)；
这种写法是没什么问题的，但对方服务器的nginx会把接收到的put方法重置，最后统一修改为post请求即可；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c134778c4daa81786653edb0587d7658/" rel="bookmark">
			pytho中如何输出的一位小数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Python中，要输出一位小数，可以使用以下方式：
num = 3.14159 print("%.1f" % num) 登录后复制 这段代码会输出 3.1，其中 %.1f 表示输出一个小数，保留一位小数。你可以将 num 替换为任何带小数的数字。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e2be8fe05fa073f2adc87a513bef382/" rel="bookmark">
			Python  复制GDB文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		不采用arcpy新建数据库并逐要素类复制的方法，直接用python shutil模块
shutil.copytree(src_fgdb,target_fgdb,ignore=shuilt.ignore_patterns('*.lock))
target_fgdb会自动建立，不能事先存在。
https://www.cnblogs.com/geosnoob/p/13334569.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d05d3992ecff5ac9781900021032171f/" rel="bookmark">
			Sql多张表中检索数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		多张表中检索数据 1.内连接2.跨数据库连接3.自连接4. 多表连接5.复合连接条件6.隐式连接语法7.外连接8.多表外连接9.自外部连接10. USING子句11自然连接12. 交叉连接13.联合 1.内连接 各表分开存放是为了减少重复信息和方便修改，需要时可以根据相互之间的关系连接成相应的合并详情表以满足相应的查询。FROM JOIN ON 语句就是告诉sql： 将哪几张表以什么基础连接/合并起来。
select * from order inner join customers on	order.id = customers.id; -- inner可省略 -- 可起别名 select order_id, customer_id, o.id, last_name from order o join customers c on	o.id = c.id; 2.跨数据库连接 有时需要选取不同库的表的列，其他都一样，就只是WHERE JOIN里对于非现在正在用的库的表要加上库名前缀而已。依然可用别名来简化
use sql_store; select * from order_items oi join sql_inventory.products p on oi.product_id = p.product_id -- 或 use sql_inventory; select * from sql_store.order_items oi join products p on oi.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d05d3992ecff5ac9781900021032171f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6bbf373377caf285377853a9efb3e14a/" rel="bookmark">
			cube-ui使用Upload组件实现压缩图片且通过 Base64 上传
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、访问cube-ui官方文档并将“压缩图片且通过 Base64 上传”部分的代码复制到自己的项目中
https://didi.github.io/cube-ui/#/zh-CN/docs/upload
2、下载所需module（image.js）:https://download.csdn.net/download/qq_52771580/87451959
3、将image.js移至项目中，比如我是在src里建了个modules文件夹，文件路径为：/src/modules/image.js。
4、引入(结合自己的组件位置)，比如我的引入为：import compress from "@/modules/image.js";
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/298e59a90780622d972f66932be5c005/" rel="bookmark">
			一小时搞定python进制转换的办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一，python相关进制转换方法； python分别有二进制，八进制，十进制以及十六进制；
二进制用 0b开头+数字表示 范围内共有0—1两个数字 逢二进一；
例如： 0b110
八进制用 0o开头+数字表示 范围内共有0—7八个数字 逢八进一；
例如： 0o751001
十进制用正常数字表示即可 范围内共有 0 — 9 十个数字 逢十进一；
例如： 64013
十六进制用 0x开头+数字表示 范围内共有 0—9 以及a—f十六个数字；
依此类推 {a = 10 b = 11 ... f = 15 }；
例如： 0xa005f
如果需要十进制转换至二进制 给十进制的数字一个非关键字的字母来代表该十进制表达的数字；
然后输入 print(bin(i0))来进行进制转换；
进行程序；
红框内则是十进制转换为二进制的数字表达方式
依次类推 八进制的转换方式为 print(oct(xx)) ，十进制的转换方式为 print(int(xx))， 十六进制的转换方式为print(hex(xx)) ，释：xx代表的是你付与所需要转换进制数字的变量； 这是八进制的转换； 0o307就是十进制199转换至十六进制的{下图所示}；
这是十六进制的转换； 0xc7 就是十进制199转换至十六进制的{下图所示}；
八进制转至十六进制，十进制，二进制方法同上 只需改变一下赋予变量后的数字表达方式即可；
二，进制转化原理算法 进制转化的计原理计算方法；
1. 计算方式为从右往左数 每个数的位序次方计算完成后依次相加
例如：0b110 计算为 0*2的0次方 + 1*2的1次方 + 1*2的2次方 计算结果为： 1+2+4=7 结果为7
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/298e59a90780622d972f66932be5c005/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ca46f6b428ec4a50a55f2c374247977/" rel="bookmark">
			Java基础——File、FileReader、FileWriter的使用：随想笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、File对象
1、路径的选择
绝对路径父路径+子路径目录名+文件名
………… String dirName = "./src"; //相对路径 String fileName = ""; //文件名 String path = dirName+fileName; //聚合为文件的相对路径 File f = new File(path); //根据路径创建从本机磁盘中读取具体文件信息的File对象 2、可以通过判断是否为文件目录/文件/绝对路径/相对路径等进行操作
if (f.isDirectory()) { String s[] = f.list(); //读取文件目录 for (String filename:s) { path = dirName+"/"+filename; File file = new File(path); if (file.isDirectory()) System.out.print("这是个文件夹"); System.out.println(filename); } } 3、创建文件目录
//创建新文件对象信息 File file = new File("文件目录路径"); //1. 创建单个目录 file.mkdir(); //2. 创建包含父目录及其子目录的方式 file.mkdirs(); 4、删除文件夹与文件
file.delete(); //删除文件和空文件夹 deleteFolder(file); //递归删除非空文件夹 二、FileReader FileReader是从InputStreamReader继承而来，其创建方式也与InputStreamReader相似
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ca46f6b428ec4a50a55f2c374247977/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/180/">«</a>
	<span class="pagination__item pagination__item--current">181/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/182/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>