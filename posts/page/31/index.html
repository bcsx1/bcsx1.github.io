<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62c7e79636d2b4a9c8eaaee190cb033a/" rel="bookmark">
			sql server多表查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		查询目标 现在有学生表和学生选课信息表，stu和stuSelect，stu中包含学生用户名、名字，stuSelect表中包含学生用户名，所选课程名
学生表：
nameusername李明Li Ming李华Li Hua 学生选课表：
usernameCourseNameLi Ming操作系统Li Hua操作系统Li Ming数据结构Li Hua计算机网络 想要达到的效果：
usernameCourseNamenameLi Ming操作系统，数据结构李明Li Hua操作系统，计算机网络李华 查询语句 WITH TempTbl AS ( select stu.username, COALESCE( STUFF((SELECT DISTINCT ','+stuSelect.CourseName FROM stuSelect WHERE stuSelect.username = stu.username FOR XML PATH('')), 1, 1, '') , '') AS right_data FROM stu left JOIN stuSelect ON stuSelect.username = stu.username --如果有where的条件加在这 GROUP BY stu.username ) --定义一个TempTbl 表，查询出stu中所有学生和对应的所有选课。 SELECT * from( select ROW_NUMBER() OVER (ORDER BY RegisDate desc) as row, stu.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/62c7e79636d2b4a9c8eaaee190cb033a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d314d34de7a19a40a90f1ad6db1e1dcf/" rel="bookmark">
			【JMeter】使用内网负载机（Linux）执行JMeter性能测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、背景 ​ 在我们工作中有时候会需要使用客户提供的内网负载机进行性能测试，一般在什么情况下我们需要要求客户提供内网负载机进行性能测试呢？
遇到公网环境下性能测试达到了带宽瓶颈。那么这时，我们就需要考虑在内网环境负载机下来执行我们的性能测试以达到屏蔽带宽影响的目的。
系统对高并发做了防护，例如ddos防护
测试的并发过高导致负载机先达到瓶颈 本节我们介绍在内网负载机下执行JMeter性能测试。
二、准备 我们需要准备一下我们接下来需要用的东西：
ssh连接工具（例如：Xshell、Git Bash，在这里我们使用Git Bash）
apache-jmeter-5.5或以上（JMeter版本过低或java版本过高会导致java版本过高的报错提示）
性能测试脚本
脚本如下：
三、假设 在这里我们先做出一些假设：
被测网站为https://www.baidu.com。（我们一般在测试时测试的域名为http而非https）
负载机处于baidu内网环境中
https://www.baidu.com 在内网中对应的内网ip为10.5.16.8
文章中负载机已安装配置环境，在本文中我们假设未安装任何环境
四、操作步骤 1、连接负载机 首先我们在脚本及jmeter所在文件夹下右键打开Git Bash
连接负载机
shell
ssh root@192.168.2.45 # root为登录的用户，@后为访问负载机ip地址 回车出现
root@192.168.2.45's password:
我们输入密码后回车即可，登录成功
2、检查环境 首先检查java环境
shell
java --version 出现类似以下内容表示环境中存在java
检查jmeter环境
shell
jmeter --version 出现类似以下内容表示环境中存在jmeter
查看Linux内存
shell
free -h 这里我们可以发现我们内存为1.6GB
查看LinuxCPU信息
shell
cat /proc/cpuinfo 这里我们看最后一个processor序号为1，故CPU为2核
查看Linux系统架构
shell
uname -a 这里可以知道系统架构为x86_64
3、测试准备 ​ 在上文中我们说到，假设负载机未安装任何环境。这里我们分别介绍两种方式进行安装。
（1）Java安装（链接下载） 首先我们打开Java官网（其他下载地址也可）https://www.oracle.com/java/technologies/downloads/，选择jdk17（这里我们用jdk17进行演示）
这里我们复制x64 Compressed Archive（具体下载的包取决于之前查询的CPU架构来决定）后的链接：https://download.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d314d34de7a19a40a90f1ad6db1e1dcf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf50a13154a3be5114389ec3962aa44e/" rel="bookmark">
			PADS Layout安全间距检查报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题： 在Pads Layout完成layout后，进行工具-验证设计=安全间距检查时，差分对BAK_FIXCLK_100M_P / BAK_FIXCLK_100M_N的安全间距检查报错，最小为3.94mil，但是应该大于等于5mil；如下两张图：
检查： 但是检查安全间距设置，导线到导线的最小安全间距设置为了3.4mil，照理说安全间距3.94mil&gt;3.4mil，安全间距应该能过才对，为什么却报错了呢？
解决： 在pads layout一键切换到pads router中后，选择网络对象-差分对-差分网络BAK_FIXCLK_100M_N&lt; - &gt; BAK_FIXCLK_100M_P，再右键-特性，可以看到该网络的差分对特性的宽度（线宽）与间隙（线距）都默认为5mil !!!
由此可知：之前安全间距报错是因为：
1、在pads router中画BAK_FIXCLK_100M_N&lt; - &gt; BAK_FIXCLK_100M_P差分对网络时设置的线宽线距为5mil；
2、在pads layout中设置的导线到导线的最小安全间距3.4mil没有对差分对网络BAK_FIXCLK_100M_N&lt; - &gt; BAK_FIXCLK_100M_P的安全间距起作用
3、在pads layout中进行安全间距检查时，普通的走线按照pads layout设置-设计规则-默认-安全间距中的自定义的安全间距去检查，但是在router中设置的差分对网络的线宽线距按照我们自己定义的线宽线距去进行安全间距的检查。
因此，在pads router中，将差分网络的间隙设置为实际最小的3.94或者更小，就可以在后续安全间距检查中顺利检查不报错了，如下图。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ff46344d4925c7d56b73b4e41f8bf63/" rel="bookmark">
			【Linux】之搭建 MySQL 环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、下载 MySQL二、卸载旧的 MySQL三、安装 MySQL四、配置 MySQL 一、下载 MySQL 打开 MySQL 官网：https://www.mysql.com/，然后进入下载页面，默认情况下是进入付费的下载页面，这里我们直接拉倒下面，找到 Community 社区版，一般情况下我们都是使用免费的社区版：
所以我们最终的社区版 MySQL 的官网下载地址就是：https://dev.mysql.com/downloads/，进去后会有很多下载选项，我们只需留意下面标记的几项即可：
最上面的三项：MySQL Yum Repository、MySQL APT Repository、MySQL SUSE Repository 是为 MySQL 在线安装需要下载的安装包。而下面的 MySQL Community Server 则是用于本地下载安装的。
这里，我们直接选择 MySQL Community Server，进入之后我们根据需要选择想要安装的版本，这里我选择 5.7 的版本，同时需要根据自己的 Linux 系统版本选择相应的操作系统选项：
注意：
在 Operating System 栏里选择的是 Linux 的操作系统（CentOS 是属于 Red Hat 系列的），根据自己的系统进行选择；在 OS Version 中选择的是系统指令集版本，MySQL 8 版本之后有分 x86, 64-bit 和 ARM, 64-bit，注意选对。 版本选择完后，我们在安装包下载列表中选择第一个 RPM Bundle：
由于 MySQL 是有多个组件部分组成的，里面有很多依赖关系包，而 Brundle 则为我们打包好了全部安装包组件部分了。RPM Bundle 下面的各个部分，这是为了供某些有特殊需求的人单独下载的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ff46344d4925c7d56b73b4e41f8bf63/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71cbf996a84c6a7cd18c2c78e8da2d06/" rel="bookmark">
			【Python期末】动态爬取B站排行榜数据并进行可视化处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		诚接计算机专业编程作业(C语言、C++、Python、Java、HTML、JavaScript、Vue等)，
标价10RMB/15RMB每份，如有需要请私信与我联系
本文资源下载地址：https://download.csdn.net/download/weixin_47040861/88656269https://download.csdn.net/download/weixin_47040861/88656269
———————————————————————————————————————————
之前B站更新了一次网页端的数据格式，搞得好多旧的Python可视化项目现在无法正常运行了，这里发一个新版本的。
使用前请保证你的Python中包含以下库：
import json import pandas import requests import matplotlib.pyplot as plt from matplotlib import font_manager 1.代码功能： 该代码通过爬取B站排行榜数据后进行处理，使用处理后的数据生成以下四个窗口：
窗口本身可以实现数据表的移动、放大缩小、拉伸、图片形式保存等功能。
2.实现思路 首先定义一个url地址，和一个请求头，相B站服务器发送数据请求： url = 'https://api.bilibili.com/pgc/web/rank/list?day=3&amp;season_type=1&amp;web_location=333.934&amp;w_rid=a349aaf313682586246c710d3b30c6e6&amp;wts=1703309721' # 网址 headers = {'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36 SE 2.X MetaSr 1.0'} #请求头 此时B站服务器会返回一条string格式的数据，使用json库将其处理为对象格式后将其存储在名为 B_date.json 的文件中备用、
这里我还单独存储了一份.json数据在本地，当从服务器获取数据失败时仍能保证程序正常运行。
然后从获取的对象信息中再提取我们需要的数据，包括番剧名称、播放量、评论数、收藏数和综合评分，并将这些数据存储在番剧.xlsx文件中。
最后根据提取的信息绘制四个不同的matplotlib 图表来展示数据分析结果，包括综合评分与播放量的对比、评论数与收藏数的对比、综合评分与收藏数的对比、播放量与评论数的对比。
窗口本身还自带移动表格、放大缩小、调整宽高、保存为图片功能。
如有需要请私信与我联系。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b4b512a04728242f1771de7ad2cb7d3/" rel="bookmark">
			西北农林科技大学毕业论文latex模板(nwafuthesis)简介与使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为规范我校学生学位论文写作格式，有效提升写作效率，教发中心智教团队耿楠教授主持研发完成了“nwafuthesis—西北农林科技大学学位论文LaTeX模板”。
nwafu-Overleaf在线LaTeX编辑编译平台：https://latex.nwafu.edu.cn
(仅限校园网内使用，不支持VPN访问，登录账号为校园统一登录)。
模板源代码开源托管于Gitee平台：https://gitee.com/nwafu_nan/nwafuthesis-l3
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2479548d099bc1d5e72977945d17541/" rel="bookmark">
			Maven工程的继承和聚合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 Maven工程继承关系 1.1 继承的概念 在Maven中，继承指Maven项目之间配置信息的继承，其中一个项目从另一个项目继承配置信息，这样多个项目可以统一配置信息，简化对项目配置的管理和维护。
1.2 继承的作用 统一管理依赖
通常情况下，Maven多模块项目会统一继承一个父工程模块，在父工程中统一管理项目依赖信息，如依赖的jar包、jar包的版本、jdk版本、编译打包插件等。统一依赖版本
版本号由父工程统一管理，在子项目中可以只需要引入依赖的GA信息即可。 1.3 继承的语法 父工程 &lt;groupId&gt;com.giser&lt;/groupId&gt; &lt;artifactId&gt;giser-java&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;!-- 父工程打包方式为pom，用于管理子工程 --&gt; &lt;packaging&gt;pom&lt;/packaging&gt; 子工程 &lt;!-- 使用parent标签指定当前工程的父工程坐标信息 --&gt; &lt;parent&gt; &lt;artifactId&gt;giser-java&lt;/artifactId&gt; &lt;groupId&gt;com.giser&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;!-- 子工程坐标： 由于子工程和父工程的groupId和artifactId一致，则可以省略不写 --&gt; &lt;artifactId&gt;giser-java-common&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt; 1.4 依赖统一管理 使用父工程统一管理依赖信息。
在父工程中，使用dependencyManagement标签声明管理的依赖信息 &lt;properties&gt; &lt;spring.version&gt;6.1.2&lt;/spring.version&gt; &lt;/properties&gt; &lt;!-- 被管理的依赖并没有真正被引入到工程 --&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; 在子工程中，使用父工程中声明的依赖信息
此时在子工程中无需指定版本号，具体版本号由父工程中管理的依赖版本号决定。 &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 2 Maven工程聚合关系 2.1 聚合的概念 Maven聚合是指将多个项目组织到一个父级项目中，以便一起构建和管理的机制。聚合可以帮助我们更好地管理一组相关的子项目，同时简化它们的构建和部署过程。
2.2 聚合的作用 统一管理多个子项目
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e2479548d099bc1d5e72977945d17541/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c35cec82fe6ec6823343aaed91380beb/" rel="bookmark">
			GSON 泛型对象反序列化解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Gson 是一个用于在 Java 对象和 JSON 数据之间进行序列化和反序列化的开源库。它由 Google 开发并提供支持。Gson 的名称是 “Google JSON” 的缩写。
Gson 提供了简单而强大的 API，可以轻松地将 Java 对象转换为 JSON 字符串，并将 JSON 字符串转换回 Java 对象。它支持复杂的对象图，包括嵌套对象、集合、数组等。
它在许多 Java 应用程序中被广泛使用，尤其是在与 Web 服务的数据交互、持久化和配置文件处理等方面。
今天我们主要聊聊， GSON 泛型对象反序列化遇到的问题。
如下，假如我们有以下泛型对象类：
public class NativeParam&lt;T&gt; { private T data; public NativeParam(T data) { this.data = data; } public T getData() { return data; } public void setData(T data) { this.data = data; } }; public class User { /** * 用户id */ private int userId; /** * 昵称 */ private String nickname; public int getUserId() { return userId; } public void setUserId(int userId) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c35cec82fe6ec6823343aaed91380beb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d914a495472bb67246f518752ad4491/" rel="bookmark">
			MyBatis的缓存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.缓存的介绍 为什么使用缓存？
首次访问时，查询数据库，并将数据存储到内存中；再次访问时直接访问缓存，减少IO、硬盘读写次数、提高效率
Mybatis中的一级缓存和二级缓存
一级缓存:
它指的是mybatis中的SqlSession对象的缓存。当我们执行完查询之后，查询的结果会同时存在在SqlSession为我们提供的一块区域中。当我们再次查询同样的数据，mybatis会先去SqlSession中查询是否有，有的话直接拿出来使用。当SqlSession对象消失时，Mybatis的一级缓存也就消失了。
二级缓存：
它指的是Mybatis中SqlSessionFactory对象的缓存，由同一个SqlSessioFactory对象创建的SqlSession共享其缓存。
开启范围清空一级缓存默认开启 sqlSession commit/close二级缓存手动开启mappercommit 2.一级缓存 2.1创建接口和xml文件 public interface UserMapper { User getUserById(Integer id); } &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt; &lt;mapper namespace="com.by.mapper.UserMapper"&gt; &lt;!-- id：和接口的方法名保持一致 resultType：返回值类型 --&gt; &lt;select id="getUserById" parameterType="int" resultType="com.by.pojo.User"&gt; select * from user where id=#{id} &lt;/select&gt; &lt;/mapper&gt; 2.2测试一级缓存 /** * 一级缓存 * @throws IOException */ @Test public void testFirstCache() throws IOException { SqlSession sqlSession1 = sessionFactory.openSession(); UserMapper userMapper = sqlSession1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d914a495472bb67246f518752ad4491/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46d6317a496e2d05df31b855c3583eac/" rel="bookmark">
			【Linux】之远程连接 MySQL 服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 默认情况下，mysql 是只允许本地登录，如果外面的客户端想通过会话终端远程连接登录服务器的 MySQL 的话，会直接提示拒绝连接。
我们可以通过 MySQL 数据库中的 mysql.user 表来查看是否允许远程 IP 访问：
mysql&gt; select host, user from mysql.user; +-----------+---------------+ | host | user | +-----------+---------------+ | localhost | mysql.session | | localhost | mysql.sys | | localhost | root | +-----------+---------------+ 如果查询结果为 127.0.0.1 或者 localhost 或者当前服务器域名，则表示不允许远程连接。下面，我们以 CentOS 7 为例，演示如何连接远程服务器的 MySQL。
二、配置远程链接流程 一、修改 /etc/mysql/my.conf vim /etc/my.cnf 找到 bind-address = 127.0.0.1 这一行，然后改为 bind-address = 0.0.0.0 即可，如果没有这行的话可以跳过这个步骤。
二、为需要远程登录的用户赋予权限 1、给现有用户赋予权限
比如给 root 用户赋予权限，让 root 用户支持远程连接 MySQL 数据库：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/46d6317a496e2d05df31b855c3583eac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a58afe6c392472958e9bf48530570ea8/" rel="bookmark">
			yolo转coco格式（txt格式转json格式）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import os import cv2 import json from tqdm import tqdm from sklearn.model_selection import train_test_split import argparse classes = ['carpetweed', 'morningglory', 'palmer_amaranth'] parser = argparse.ArgumentParser() parser.add_argument('--image_path', default='/home/test/images',type=str, help="path of images") parser.add_argument('--label_path', default='/home/test/labels',type=str, help="path of labels .txt") parser.add_argument('--save_path', type=str,default='/home/rendoudou/datasets/CottonWeedDet3/data.json', help="if not split the dataset, give a path to a json file") arg = parser.parse_args() def yolo2coco(arg): print("Loading data from ", arg.image_path, arg.label_path) assert os.path.exists(arg.image_path) assert os.path.exists(arg.label_path) originImagesDir = arg.image_path originLabelsDir = arg.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a58afe6c392472958e9bf48530570ea8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed20ab32af4c3424db25d2a788b432e0/" rel="bookmark">
			【经典LeetCode算法题目专栏分类】【第11期】递归问题：字母大小写全排列、括号生成
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		《博主简介》
小伙伴们好，我是阿旭。专注于人工智能AI、python、计算机视觉相关分享研究。
✌更多学习资源，可关注公-仲-hao:【阿旭算法与机器学习】，共同学习交流~
👍感谢小伙伴们点赞、关注！
《------往期经典推荐------》
一、AI应用软件开发实战专栏【链接】
二、机器学习实战专栏【链接】，已更新31期，欢迎关注，持续更新中~~
三、深度学习【Pytorch】专栏【链接】
四、【Stable Diffusion绘画系列】专栏【链接】
递归 字母大小写全排列 class Solution:
def letterCasePermutation(self, S: str) -&gt; List[str]:
def DFS(s_list, index):
if index == len(s_list):
res.append(''.join(s_list))
return # 未修改当前字符(字母或者数字)的一条分支 DFS(s_list, index + 1) # 修改当前字母的的另一条分支
if s_list[index].isalpha():
s_list[index] = chr(ord(s_list[index]) ^ 32)
DFS(s_list, index + 1)
res = []
S = list(S)
DFS(S, 0)
return res
# 回溯
class Solution:
def permutation(self, s: str) -&gt; List[str]:
def backtrack(s, cur_s):
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed20ab32af4c3424db25d2a788b432e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce7c792ea72f8dffcaf2b9a91ba16702/" rel="bookmark">
			免费的ChatGPT分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		免费的ChatGPT 以下是一些免费的ChatGPT平台和工具：
零声教学AI助手 零声教育内部使用的ChatGPT，提供智能对话和问题解答功能。
Ora.ai 一个可以自定义的AI聊天机器人，可以根据个人需求进行定制和训练。
ChatGPT 人工智能聊天机器人，提供智能对话和问题解答功能。
通义千问 一个专门响应人类指令的大模型，可以回答各种问题并提供相关信息。
文心AI 一个聚合了AI聊天、AI翻译、AI文档、AI知识库、AI工具的网站，提供多种AI功能和服务。
SparkDesk 讯飞星火认知大模型，提供智能对话和语音识别等功能。
智造喵 免费chatgpt平替，提供类似ChatGPT的智能对话和问题解答功能。
Perplexity AI 一个开源的文本生成模型，可以用于生成自然语言文本。
网址自行检索
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/078f63c5b9b6c4f9c1e3ae8438a37bdf/" rel="bookmark">
			spring boot 3.2&#43; mybatis-plus出现 Invalid value type for attribute ‘factoryBeanObjectT
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 解决办法
修改依赖
&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;3.0.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.5.3.2&lt;/version&gt; &lt;/dependency&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02e3984436ee16c6c2143c725ccc86bb/" rel="bookmark">
			docker搭建kali及安装oneforall
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前期docker的安装这里就不用多说了，直接看后面的代码
安装oneforall
1.安装git和pip3
sudo apt update sudo apt install git python3-pip -y 2.克隆项目
git clone https://gitee.com/shmilylty/OneForAll.git 3.安装相关依赖
cd OneForAll/
sudo apt install python3-dev python3-pip python3-testresources -y sudo python3 -m pip install -U pip setuptools wheel -i https://mirrors.aliyun.com/pypi/simple/ sudo pip3 install --ignore-installed -r requirements.txt -i https://mirrors.aliyun.com/pypi/simple/ python3 oneforall.py --help 4.测试运行
python3 oneforall.py check python3 oneforall.py --target example.com run 查看是否生成文件。
ls results
文件成功生成了，但csv文件在docker里查看起来有些麻烦。
导出文件到mac查看会方便的多。
5.文件导出
经过百度后发现有好几种方案，一种是安装lrzsz，一种是直接使用docker的cp功能。
1.lrzs
实际使用中，mac失败了，windows应该可以成功。
具体操作：
使用apt-get安装lrzs工具包。
apt-get install lrzsz Lrzsz 的rz命令可以把电脑文件导入容器，而sz命令可让文件从容器中导出。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/02e3984436ee16c6c2143c725ccc86bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c220c88e9aba4ca8cdbe3a27d7687b6b/" rel="bookmark">
			leetcode 30. 串联所有单词的子串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目链接：leetcode 30
1.题目 给定一个字符串 s 和一个字符串数组 words。 words 中所有字符串 长度相同。
s 中的 串联子串 是指一个包含 words 中所有字符串以任意顺序排列连接起来的子串。
例如，如果 words = [“ab”,“cd”,“ef”]， 那么 “abcdef”， “abefcd”，“cdabef”， “cdefab”，“efabcd”， 和 “efcdab” 都是串联子串。 “acdbef” 不是串联子串，因为他不是任何 words 排列的连接。
返回所有串联子串在 s 中的开始索引。你可以以 任意顺序 返回答案。
2.示例 1）示例 1：
输入：s = “barfoothefoobarman”, words = [“foo”,“bar”]
输出：[0,9]
解释：因为 words.length == 2 同时 words[i].length == 3，连接的子字符串的长度必须为 6。
子串 “barfoo” 开始位置是 0。它是 words 中以 [“bar”,“foo”] 顺序排列的连接。
子串 “foobar” 开始位置是 9。它是 words 中以 [“foo”,“bar”] 顺序排列的连接。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c220c88e9aba4ca8cdbe3a27d7687b6b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78cc36076c463a4a7f8d2bc9604ef169/" rel="bookmark">
			Leetcode—1099.小于K的两数之和【简单】Plus
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2023每日刷题（六十八） Leetcode—1099.小于K的两数之和 实现代码 class Solution { public: int twoSumLessThanK(vector&lt;int&gt;&amp; nums, int k) { int n = nums.size(); int left = 0, right = n - 1; int sum = 0; int ans = 0; sort(nums.begin(), nums.end()); while(left &lt; right) { sum = nums[left] + nums[right]; if(sum &lt; k) { ans = max(sum, ans); left++; } else { right--; } } if(ans == 0) { return -1; } return ans; } }; 运行结果 之后我会持续更新，如果喜欢我的文章，请记得一键三连哦，点赞关注收藏，你的每一个赞每一份关注每一次收藏都将是我前进路上的无限动力 ！！！↖(▔▽▔)↗感谢支持！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa0266f18ee39c40a964821992f956ae/" rel="bookmark">
			Jenkins 插件管理指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
常用插件
插件安装
已安装插件 installed plugins
常用插件 Docker Plugin： 这个插件让Jenkins能够与Docker容器平台进行集成。它允许在Jenkins构建过程中创建、管理和销毁Docker容器，为需要Docker化的项目提供了极大的便利性。对于需要在容器中构建或部署应用程序的项目，这个插件可以帮助简化流程，提高效率。
Git Plugin： Git插件是Jenkins中最基本和最常用的插件之一。它允许Jenkins与Git版本控制系统集成，通过拉取代码并触发构建来实现持续集成。对于几乎所有需要版本控制的项目，这个插件是不可或缺的，为构建和部署流程提供了必要的代码管理支持。
Email Extension Plugin： 这个插件允许Jenkins发送电子邮件通知，用于向团队成员发送构建状态或错误信息。这对于及时沟通构建状态、问题或错误非常重要，有助于团队成员快速响应和解决任何可能出现的问题。
GitHub Plugin： GitHub插件提供了与GitHub仓库的集成支持，包括Webhook和GitHub事件触发器。对于与GitHub紧密集成的项目，这个插件可以帮助构建CI/CD自动化流程。通过与GitHub的交互，可以触发Jenkins构建，实现自动化测试、构建和部署，从而加快整个开发周期。
插件安装 登录Jenkins，转到Jenkins主页的“Manage Jenkins” &gt; “Plugins”。在“可选插件”标签下，浏览或搜索要安装的插件。选中需要安装的插件，然后点击“安装”或“直接下载并安装”按钮。 已安装插件 installed plugins 已安装插件”页面允许你停用和卸载已安装的插件。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2eee4208adde4c74cb3bea18416a033/" rel="bookmark">
			SaaS、IaaS与PaaS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、SaaS SaaS（Software as a Service，软件即服务）是一种软件分发模型，在这个模型中，软件应用通过互联网作为服务提供给客户。用户不需在本地计算机上安装和运行应用程序，而是通过互联网，通常是一个浏览器来访问和使用软件。SaaS提供商负责维护软件的基础设施、运行时、安全、数据存储和软件的升级。
SaaS有以下几个特点：
订阅模式：用户通常按月或按年订阅服务，而不是购买软件的永久许可证。
集中托管：软件托管在服务提供商的服务器上，用户通过互联网访问。
即时使用：服务通常是即开即用的，不需要传统软件的复杂安装和配置过程。
多租户架构：SaaS应用程序通常是多租户的，意味着多个用户共享相同的应用程序实例，同时保持各自数据的隔离性。
可扩展性：服务提供商可以根据用户需求提供不同级别的服务，用户可以根据自己的需求增加或减少服务。
自动更新：软件维护和更新由服务提供商处理，用户可以自动获得最新版本的软件。
跨平台访问：用户通常只需要一个网页浏览器就可以访问软件，因此SaaS服务可以跨操作系统使用。
SaaS模型的优势包括低初期成本、易于升级和维护、灵活性以及易于远程访问。它已被广泛应用于各个企业应用程序中，如客户关系管理（CRM）、企业资源计划（ERP）、项目管理、人力资源管理、会计、协作工具等。
2、IaaS IaaS（Infrastructure as a Service，基础设施即服务）是一种云计算服务模型，其中提供商提供虚拟化的计算资源作为互联网上的服务。IaaS使用户可以在云中租用IT基础设施，如服务器、网络、存储以及数据中心空间，而无需购买和管理物理硬件。
以下是IaaS主要特点：
资源按需分配：用户根据需求获得处理能力、存储空间和网络组件等资源，而且可以随时增加或减少。这种弹性避免了本地基础设施的前期高昂投入和长期维护。
实用计费模式：用户只需为实际使用的资源付费，类似水电费，这种计费模式有助于减少成本浪费。
管理界面：IaaS通常通过一个图形化的管理控制台或API提供资源管理，用户可以自助服务，轻松配置和管理所需的基础设施。
网络访问：用户可以从任何地方通过互联网访问这些资源，促进了远程工作的便利性。
物理基础设施的抽象化：用户无需关心物理服务器的操作和维护，这些都由云提供商负责。
可扩展性和弹性：IaaS允许用户根据业务需求轻松扩展或缩减基础设施资源。
多租户模型：多个用户共享基础设施资源，但彼此独立，数据和应用相互隔离。
IaaS是企业实现云迁移战略的关键组件之一，它支持了各种计算任务，包括网站托管、数据分析、应用运行等。IaaS提供者包括但不限于Amazon Web Services (AWS)，Microsoft Azure，Google Cloud Platform (GCP)和IBM Cloud。
3、PaaS PaaS（Platform as a Service，平台即服务）是一种云计算服务模型，它提供一个平台和环境，允许开发者构建应用程序和服务。这个平台包括硬件、软件基础架构以及开发、测试、部署、管理、更新应用的工具。用户可以通过互联网访问这个平台，无需直接管理基础的硬件和操作系统。
PaaS的关键特点包括：
开发工具：提供各种开发工具，如源代码编辑器、编译器、调试器等。
中间件：自动管理应用程序所需的中间件，如数据库管理系统、消息队列等。
操作系统：包括维护和更新操作系统。
数据库管理：支持数据库的创建、配置和管理。
网络访问：提供与平台关联的网络资源，例如负载均衡、域名系统(DNS)管理等。
安全性：提供数据安全和备份服务，确保用户数据的安全。
可扩展性：资源可以根据应用需求自动或手动地进行扩展。
集成服务：可能包括与其他云服务（如SaaS或IaaS）的集成。
PaaS为开发者提供了一种方便快捷的方式来创建应用程序，而无需担心相关的基础设施，如服务器和存储设备的购买、配置和管理。这样他们就可以专注于编码和创新，加快开发进程。PaaS通常用于开发、测试、交付和管理软件应用程序。
PaaS的例子包括Heroku、Google App Engine、Microsoft Azure App Services、Red Hat OpenShift等。这些平台能够大幅减少开发时间和成本，同时提高开发团队的效率。
4、CRM CRM（Customer Relationship Management，客户关系管理）是一个用于管理公司与现有客户及潜在客户之间互动的策略，它利用数据分析来改善业务关系，集中重点提升客户服务，维护客户忠诚度，并最终推动销售增长。
CRM系统是实现这种策略的软件工具，它们帮助企业收集客户信息、记录服务请求、管理营销活动和跟踪销售机会，让公司能够在一个集成的平台中处理所有客户相关的操作和分析。这些系统通常包括以下功能：
客户数据管理：收集和存储客户信息，如个人资料、购买历史、交互记录等。
销售管理：追踪潜在和现有客户的销售机会，管理销售管道。
市场营销自动化：设计和执行营销活动，以吸引潜在客户并维护与现有客户的联系。
服务和支持：管理客户服务请求和技术支持，提高服务效率。
数据分析：分析客户数据，提供洞察力以指导决策制定和策略实施。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d2eee4208adde4c74cb3bea18416a033/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d5f3d849f1db8aad156d1c3cdd0bbfb/" rel="bookmark">
			TYPE C 接口知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、Type C 概述
Type-C口有4对TX/RX分线，2对USBD+/D-，一对SBU，2个CC，另外还有4个VBUS和4个地线。
当Type-C接口仅用作传输DP信号时，则可利用4对TX/RX，从而实现4Lane传输，这种模式称为DPonly模式；
Type-C还保留了USB D+/D-，用以接USB2.0设备，同时使用USB D+/D-和上面的DPonly模式配合可实现DP+USB2.0模式；
正常来说USB3.0只需要使用2对TX/RX、USB2.0只需要使用一对D+/D-，所以Type-C接口中总会有一半的接口是多余的；而DP的交替模式则是将DP的差分信号加载到2对“多余”的TX/RX上面，所以也可实现USB3.0+DP的模式。
2条SBU线则是在DP功能启用时，化身为DP协议中的AUX_P/N差分对（它的极性是可以根据正反插方向修改的），负责传输设备的DPCD、EDID等信息（而平时这对引脚一般用不到，可忽略）。
Type优点：双面可插不担心正反、可做USB/雷电高速传输载体，支持 PD快充、音频设备、HDMI传输、调试模式
2、USB 数据类型
2.1 USB端口按数据流向：
•下行端口 (DFP) 向下游发送数据；它通常是设备所连接的 主机或集线器上的端口。DFP 将为 VBUS 供电（主机与设备 之间的电源路径），还可以为 VCONN 供电（为电子标记的电 缆供电）。包含 DFP 的典型应用是集线站。
•上行端口 (UFP) 连接到主机或集线器的 DFP，接收设备或 集线器上的数据。这类端口通常从 VBUS 中取电。包含 UFP 的典型应用是显示监视器。
•双角色数据 (DRD) 端口可以用作 DFP（主机）或 UFP（设 备）。此类端口在连接时的电源角色决定了其初始角色。源 端口承担 DFP 的数据角色，而接收端口承担 UFP 的数据角 色。不过，通过使用 USB PD 数据角色交换功能，可以动态地更改此类端口的数据角色。包含 DRD 端口的典型应用是笔 记本电脑、平板电脑和智能手机。
无数据，充电宝
2.2
USB端口按电源供给分：
消耗VBUS电源端口；从机
提供VBUS电源端口；主机
既能提供和消耗电源的端口；
2.3
TYPE C 驱动 芯片（LDR6020/LDR6282/LDR6023）：DRP/SRC/SNK USB Type-C connector该芯片实现三种模式：从机（slave UFP）主机（DFP）、(DRP 两者自动切换)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d5f3d849f1db8aad156d1c3cdd0bbfb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d57ab5864e8a22534412b7300c8e5d6b/" rel="bookmark">
			求一个3*3矩阵对角线元素之和
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
int main()
{
int m, n, j, k,sum=0;
int a[10][10];
for (m = 0; m &lt;3; m++)
{
for (n = 0; n &lt; 3; n++)
{
scanf("%d", &amp;a[m][n]);
}
}
for (m = 0; m &lt; 3; m++)
{
for (n = 0; n &lt; 3; n++)
{
if (m + n == 2)
{
sum += a[m][n];
}
}
}
printf("%d", sum);
return 0;
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eccefb0b2cb08952b0aecbb02f9ad0dc/" rel="bookmark">
			【C#与Redis】--Redis 数据结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Redis数据结构简介 Redis（Remote Dictionary Server）是一个开源的内存数据存储系统，可以用作数据库、缓存和消息中间件。它支持多种数据结构，使其在不同场景下都能发挥作用。以下是一些常见的Redis数据结构：
字符串（String）： Redis中的基本数据类型之一，可以存储任意二进制数据，比如文本或者序列化的对象。提供了丰富的字符串操作命令，如GET、SET、INCR等。 列表（List）： 有序的字符串元素集合，可以在列表的两端执行插入和删除操作。支持在列表的任意位置进行元素的插入和删除，以及范围查询。 集合（Set）： 无序的字符串元素集合，不允许重复的成员存在。提供了对集合的交集、并集和差集等操作。 有序集合（Sorted Set）： 类似于集合，但每个元素都关联了一个分数（score），通过分数进行排序。支持按照分数范围进行查询，以及对元素进行排名。 哈希表（Hash）： 存储了字段和与字段关联的值之间的映射。适用于存储对象，每个字段可以看作对象的属性，值则是属性的值。 Bitmaps： Redis提供了用于处理位图的数据结构，可以进行位运算操作。常用于记录用户在线状态、统计用户活跃度等。 HyperLogLog： 用于估算集合中元素的基数（不重复元素的数量），在空间上比精确计数更加节省。 地理空间索引（Geospatial Index）： 通过经纬度坐标来表示位置信息，支持对地理位置进行范围查询和排序。 这些数据结构使得Redis成为一种灵活且高性能的存储系统，适用于多种应用场景，包括缓存、队列、计数器、实时排行榜等。通过选择合适的数据结构，可以更好地满足不同业务需求。
二、字符串（String） 在Redis中，字符串（String）是最基本的数据结构之一，它是二进制安全的，可以包含任意类型的数据，比如文本、JSON、甚至是图片。每个字符串都有一个相关联的键（key），通过这个键，可以对字符串进行读取、写入和删除等操作。
以下是一些常用的Redis字符串命令：
SET key value：
设置键key的值为value。 SET mykey "Hello Redis" GET key：
获取键key的值。 GET mykey MSET key1 value1 key2 value2 …：
设置多个键值对。 MSET key1 "value1" key2 "value2" key3 "value3" MGET key1 key2 …：
获取多个键的值。 MGET key1 key2 key3 APPEND key value：
在键key的值后面追加value。 APPEND mykey " World"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eccefb0b2cb08952b0aecbb02f9ad0dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54d9a93e840689486d65a43149311524/" rel="bookmark">
			做APP小程序软件开发需要注意哪些细节?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着移动互联网的快速发展，APP和小程序已成为我们日常生活中不可或缺的一部分。然而，在开发过程中，许多细节常常被忽视，导致用户体验不佳、软件漏洞频发等问题。本文将探讨在APP和小程序开发中需要注意的细节，帮助开发者打造更出色的产品。
一、用户需求与体验
在开发APP或小程序之前，深入了解用户需求至关重要。通过对目标用户进行调研，可以明确产品定位和功能需求。同时，良好的用户体验是吸引用户持续使用产品的关键。开发者应关注用户界面、交互设计、操作流程等方面的细节，确保用户在使用过程中感到顺畅、舒适。
二、数据安全与隐私保护
随着人们对个人隐私的关注度不断提高，数据安全与隐私保护已成为APP和小程序开发的重要考虑因素。开发者应遵循相关法律法规，采取有效的加密和安全措施，确保用户数据不被泄露或滥用。同时，应向用户明确说明数据收集和使用的目的，并给予用户对个人数据的控制权。
三、适配性与性能优化
APP和小程序需要适应不同设备和网络环境，以确保良好的用户体验。开发者应测试产品在不同平台、分辨率和网络环境下的表现，优化性能和响应速度。此外，利用缓存、异步加载等技术可进一步提高产品的响应速度和稳定性。
四、版本控制与更新
随着产品迭代和功能升级，版本控制与更新成为开发过程中的重要环节。开发者应建立完善的版本管理机制，及时发布更新，并确保新旧版本之间的兼容性。同时，通过版本控制可追踪问题和错误，快速定位并修复问题，提升产品质量。
五、运营与维护
APP和小程序上线后，运营与维护同样重要。开发者应定期监控服务器、数据库等基础设施的运行状况，及时处理用户反馈和问题报告。同时，通过收集用户行为数据和反馈信息，不断优化产品功能和用户体验。
综上所述，APP和小程序开发中需要注意的细节包括用户需求与体验、数据安全与隐私保护、适配性与性能优化、版本控制与更新以及运营与维护。在开发过程中关注这些细节，有助于打造出更出色的产品，提升用户体验和用户忠诚度。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbbbfa943ad1111e5454670e43344d4a/" rel="bookmark">
			Day01-Ajax
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.JSON方法 &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;table&gt; &lt;tr&gt; &lt;th&gt;id&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;script&gt; var data = [ { "id": "0001", "name": "张三", "age": 18, "gender": "男" }, { "id": "0002", "name": "李四", "age": 20, "gender": "女" }, { "id": "0003", "name": "王五", "age": 18, "gender": "男" } ] console.log(data); // 将数组对象形式的数据转换为 json 格式 var dataStr = JSON.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bbbbfa943ad1111e5454670e43344d4a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/841ef7b80e2bbe60ef25c982357a2df7/" rel="bookmark">
			C&#43;&#43; 字符串中识别取出非中文字符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		bool isChineseChar(unsigned char c) {
if ((c &amp; 0x80) == 0) {
// ASCII编码字符
return false;
}
// 对于UTF-8编码中的中文字符，其第一个字节的最高位至少有三个1，例如 1110xxxx (E0-EF)
// 而对于单字节的ASCII字符，最高位是0
return true;
}
std::string extractNonChinese(const std::string&amp; input) {
std::string result;
for (size_t i = 0; i &lt; input.size();) {
if (isChineseChar(static_cast&lt;unsigned char&gt;(input[i]))) {
// 计算UTF-8编码的中文字符字节数
unsigned char c = input[i];
int num_bytes = 0;
while (c &amp; 0x80) {
num_bytes++;
c &lt;&lt;= 1;
}
i += num_bytes; // 跳过整个中文字符
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/841ef7b80e2bbe60ef25c982357a2df7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5e5ed9d21376497ae804b304110e486/" rel="bookmark">
			前端八股文（vue篇）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一.谈一谈对MVVM的理解？
二.解释一下对Vue生命周期的理解
三.说一下router与route的区别
四.VueRouter有哪几种导航守卫？
五. Vue的路由两种模式hash模式和history模式的实现原理
六.说一下v-if与v-show的区别
七.vue为什么采用异步渲染
八.组件中写name选项有哪些好处？
九.keep-alive的实现原理是什么
十.说一下Vue SSR实现原理
一.谈一谈对MVVM的理解？ MVVM是Model-View-ViewModel的缩写。MVVM是一种设计思想。Model层代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑。View代表UI组件，他负责将数据模型转换为UI展现出来，View是一个同步View和Model的对象。在MVVM架构下，View和Model之间并没有直接的联系，而是通过ViewModel进行交互，Model和ViewModel之间的交互是双向的，因此View数据的变化会同步到Model中，而Model数据的变化也会立即反应到View上。对于ViewModel通过双向数据绑定把View层和Model层连接了起来，而ViewheModel之间的同步工作完全是自动的，无需人为干涉，因此开发者只需要关注业务逻辑，不需要手动操作DOM，不需要关注数据状态的同步问题，复杂的数据状态维护完全由MVVM来统一管理、 二.解释一下对Vue生命周期的理解 什么是vue生命周期vue生命周期的作用是什么？vue生命周期有几个阶段第一次页面加载会触发哪几个钩子DOM渲染在哪个周期就已经完成多组件（父子组件）中生命周期的调用顺序 1.什么是vue生命周期
对于vue来说，生命周期就是一个vue实例从创建到销毁的过程。
2.vue生命周期的作用是什么
生命周期的过程中会运行着一些叫做生命周期的函数，给予了开发者在不同的生命周期阶段添加业务代码的能力。
其实和回调一个概念，当系统执行到某处时，检查是否含有hook（钩子），有的话就是执行回调。
通俗的说，hook就是在程序中运行，在某个特定的位置，框架的开发者设计好了一个钩子来告诉我们当前程序已经运行到特定的位置了，会触发一个回调函数，并提供给我们，让我们可以在生命周期的特定阶段进行相关业务代码的编写。
3.vue生命周期有几个阶段
他可以分为8个阶段：创建前/后，载入前/后，更新前/后，销毁前/后。
beforeCreate：是new Vue()之后触发的第一钩子，在当前阶段data,methods,computed以及watch上的数据和方法都不能被访问。created：在实例创建完成后发生，当前阶段已经完成了数据观测，也就是可以使用数据，更改数据，在这里更改数据不会触发updated函数。可以做一些初始数据的获取，在当前阶段无法与DOM进行交互，如果非要想，可以通过vm.$nextTick来访问DOM、beforeMount：在挂载之前，在这之前template模板已经导入渲染函数编译。而当前阶段虚拟DOM已经创建完成，即将开始渲染。在此时也可以对数据进行更改，不会触发updated。mounted：在挂载完成后发生，当前阶段，真实的DOM挂载完毕，数据完成双向绑定，可以访问DOm节点，使用$refs属性对DOM进行操作。beforeUpdate：发生在更新之前，也就是响应式数据发生更新，虚拟DOM重新渲染之前被触发，你可以在当前阶段更改数据，不会造成重渲染。updated：发生在更新完成之后，当前阶段组件DOM已经完成更新。要注意的是避免在此期间更改数据，因为这可能导致无限循环的更新。beforeDestory：发生在实例销毁之前，在当前阶段实例完全可以使用，我们可以在这时进行善后收尾工作，比如去除计时器。destoryed：发生在实例销毁之后，这个时候只剩下DOM空壳。组件已被拆解，数据绑定被卸除，监听别移除，子实例也别销毁。 第一次页面加载会触发哪几个钩子
会触发4个钩子，分别是：beforeCreate，created，beforeMount，mounted
DOM渲染在哪个周期就已经完成
DOM渲染是在mounted阶段完成，此阶段真实的DOM挂载完毕，数据完成双向绑定，可以访问到DOM节点。
多组件（父子组件）中生命周期的调用顺序
组件的调用顺序都是先父后子，渲染完成的顺序是先子后父。组件的销毁操作是先父后子，销毁完成的顺序是先子后父。
三.说一下router与route的区别 $route对象表示当前的路由信息，包含了当前URL解析得到的信息。包含当前的路径，参数，query对象等。
$route.path:字符串，对应当前的路由路径，总是解析为绝对路径，如"/foo/bar"。$route.params:一个key/value对象，包含了动态片段和全匹配片段，如果没有路由参数，就是一个空对象。$route.query：一个key/value对象，表示URL查询参数。例如对于路径"/foo?user=1"，则有$route.query.user==1，如果没有查询参数，则是一个空对象。$route.hash:当前路由的hash值（不带#），如果没有hash值，则为空字符串。$route.fullPath:完成解析后的URL，包含查询参数和hash的完整路径。$route.matched:数组，包含当前匹配的路径中所包含的所有片段对应的配置参数对象。$route.name:当前路径名字$route.meta:路由元信息 $route对象出现在多个地方：
组件内的this.$route和route watcher回调（监测变化处理）router.match(location)的返回值scrollBehavior方法的参数导航钩子的参数，例如router.beforeEach导航守卫的钩子函数中，to和from都是这个路由信息对象。 $router对象是全局路由的实例，是router构造方法的实例。
$router对象常用的方法有：
push：向history栈添加一个新的记录go：页面路由跳转前进或者后退replace：替换当前的页面，不会向history栈添加一个新的记录 四.VueRouter有哪几种导航守卫？ 全局前置/钩子：beforeEach，beforeResolve,afterEach路由独享的守卫：beforeEnter组件内的守卫：beforeRouteEnter，beforeRouteUpdate，beforeRouteLeave 五. Vue的路由两种模式hash模式和history模式的实现原理 后面hash值的变化，不会导致浏览器向服务器发出请求，浏览器不发请求，就不会刷新页面；通过监听hashchage事件可以知道hash发生了哪些变化，然后根据hash变化来实现更新页面部分内容的操作。
history模式的实现，主要是HTML5标准发布的两个API了，pushState和replaceState,这两个API
可以在改变URL，但不会发送请求，这样还可以监听URl变化来实现更新页面部分内容的操作。
两种模式的区别：
首先是在URL展示上，hash模式有"#"，history模式没有刷新页面时，hash模式可以正常加载到hash值对应的页面，而history没有处理的话，会返回404，一般需要后端将所有页面都配置重定向到首页路由在兼容性上，hash可以支持低版本浏览器和IE 六.说一下v-if与v-show的区别 共同点：都是动态显示DOM元素
区别点：
手段 v-if是动态的向DOM树内添加或者删除DOM元素
v-show是通过设置DOM元素的display样式属性控制显隐
2.编译过程
v-if切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件
v-show只是简单的基于css切换
3.编译条件
v-if是惰性的，如果初始条件为假，则什么也不做，只有在条件第一次变为真时才开始局部编译。
v-show是任何条件下（首次条件是否为真）都被编译，然后被缓存，而且DOM元素保留
4.性能消耗
v-if有更高的切换消耗
v-show有更高的初始渲染消耗
5.使用场景
v-if使用运营条件不大可能改变
v-show适合频繁切换
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5e5ed9d21376497ae804b304110e486/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de8358a226a75c5b5801c679d088e8e3/" rel="bookmark">
			Maven核心概念
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 Maven工程的GAVP Maven 中的 GAVP 是指 GroupId、ArtifactId、Version、Packaging 等四个属性的缩写，其中前三个是必要的，而 Packaging 属性为可选项。
这四个属性主要为每个项目在maven仓库中做一个标识，方便项目之间相互引用。
GAV
G
即GroupId，格式为com.{公司/BU }.业务线.[子业务线]，最多 4 级。
说明：{公司/BU} 例如：alibaba/taobao/tmall/aliexpress 等 BU 一级；子业务线可选。
例如：com.taobao.tddl 或 com.alibaba.sourcing.multilang
A
即ArtifactID，格式为产品线名-模块名。语义不重复不遗漏，例如：tc-client / uic-api / tair-tool / bookstore
V
即Version版本号格式推荐：主版本号.次版本号.修订号
1） 主版本号：当做了不兼容的 API 修改，或者增加了能改变产品方向的新功能。
2） 次版本号：当做了向下兼容的功能性新增（新增类、接口等）。
3） 修订号：修复 bug，没有修改方法签名的功能加强，保持 API 兼容性。
P
即Packaging，指将项目打包为什么类型的文件，IntelliJ IDEA根据packaging值识别maven项目类型，packaging的可选值如下：
jar（默认值），代表普通的Java工程，打包以后是.jar结尾的文件。packaging 属性为 war，代表Java的web工程，打包以后.war结尾的文件。packaging 属性为 pom，代表不会打包，用来做继承的父工程。 2 Maven工程构建 2.1 构建概念和过程 项目构建是指将源代码、依赖库和资源文件等转换成可执行或可部署的应用程序的过程，在这个过程中包括编译源代码、链接依赖库、打包和部署等多个步骤。
项目构建是软件开发过程中至关重要的一部分，它能够大大提高软件开发效率，主要方便大型项目的自动化构建和部署，大大降低了项目的出错风险和提高开发效率。
常见的构建工具包括 Maven、Gradle、Ant 等。
2.2 构建的方式 2.2.1 命令构建 常用的构建命令如下：
命令描述mvn compile编译项目，生成target文件mvn package打包项目，生成jar或war文件mvn clean清理编译或打包后的项目结构mvn install打包后上传到maven本地仓库mvn deploy只打包，上传到maven私服仓库mvn site生成站点mvn test执行测试源码 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de8358a226a75c5b5801c679d088e8e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e63818898234198f50edf043e3c7dc6/" rel="bookmark">
			基于Javaweb的线上招聘问答系统的设计与实现论文
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘 要 计算机网络发展到现在已经好几十年了，在理论上面已经有了很丰富的基础，并且在现实生活中也到处都在使用，可以说，经过几十年的发展，互联网技术已经把地域信息的隔阂给消除了，让整个世界都可以即时通话和联系，极大的方便了人们的生活。所以说，线上招聘问答系统用计算机技术来进行设计，不仅在管理方面更加的系统化，操作性强，最重要的是关于数据的保存和使用都能节约大量的时间，该系统非常的好用。
线上招聘问答系统管理数据的工具是MySQL，编码的语言是Java，运用的框架是SSM框架。该系统可以实现简历管理，论坛帖子管理，职位招聘管理，职位招聘留言管理，招聘岗位管理，所在行业管理，求职意向管理等功能。
线上招聘问答系统不仅能让操作人员使用更加地方便，并且设计的也很合理，能有效的避免误操作，让数据在录入的环节就符合设计需要，极大的规避了源头性的输入误差，顺利的让数据变得更加可控并且可靠，让出错的几率降到最低。
关键词：线上招聘问答系统；简历；职位招聘
Abstract
Computer networks have been developed for decades, and they have a rich theoretical foundation and are used everywhere in real life. It can be said that after decades of development, Internet technology has transformed regional information. The estrangement between the two has been eliminated, allowing the whole world to communicate and contact in real time, which greatly facilitates people’s lives. Therefore, the online recruitment question and answer system is designed with computer technology.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e63818898234198f50edf043e3c7dc6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6329547be9a9dc30f56be531b3f0133a/" rel="bookmark">
			Windows家庭版/专业版开启Hyper-V及安装虚拟操作系统（windows/linux）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Win11 家庭版/专业版开启Hyper-V 1. 安装Hyper-V2. 启用Hyper-V3. Hyper-V安装虚拟操作系统（windows/linux）3.1 安装/启动Hyper-V3.2 放入光盘映像文件iso Reference Hyper-V是Windows专业版专属功能，但大多数（除商业本）品牌机内置的Windows都是家庭版。只能通过命令开启，方法如下：
Windows专业版请直接阅读启用Hyper-V部分
1. 安装Hyper-V 在桌面空白处右键-新建-文本文档，命名为 hyper-v.cmd
单击这个文件，右键-显示更多选项-编辑
pushd "%~dp0" dir /b %SystemRoot%\servicing\Packages\*Hyper-V*.mum &gt;hyper-v.txt for /f %%i in ('findstr /i . hyper-v.txt 2^&gt;nul') do dism /online /norestart /add-package:"%SystemRoot%\servicing\Packages\%%i" del hyper-v.txt Dism /online /enable-feature /featurename:Microsoft-Hyper-V-All /LimitAccess /ALL 点击文件-保存
单击这个文本文档，右键-以管理员权限运行
等待加载完成即可，成功安装后，输入y并回车即可
2. 启用Hyper-V 点击搜索按钮，输入控制面板，并点击打开
点击程序与功能
点击启用或关闭Windows功能
勾选Hyper-V，Windows虚拟机监控程序平台和虚拟机平台
点击确定
3. Hyper-V安装虚拟操作系统（windows/linux） Windows10系统自带了一个程序，Hyper-V。我们通过这个程序安装windows虚拟机，就像在VMware Workstation上安装Linux操作系统的虚拟机一样。
运行（创建新的虚拟机） （把磁盘设置在C盘以外的地方，减少系统负担）
3.1 安装/启动Hyper-V 控制面板-&gt;程序和功能-&gt;启用或关闭Windows功能。然后给Hyper-V的所有打勾，之后根据提示重启。
也可以cmd中输入命令：bcdedit /set hypervisorlaunchtype on开启Hyper-V（根据提示，决定操作后是否重启电脑）
3.2 放入光盘映像文件iso 这可能需要我们自己下载一个iso文件。打开hyper-V管理器
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6329547be9a9dc30f56be531b3f0133a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3393b17e83bc11d8f095a63e2776b6fa/" rel="bookmark">
			夏令营兵王要整队（C语言）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题意：
三天夏令营，一生军旅情。
你作为一个特种兵兵王，首先要做的就是把小特种兵们按照高矮顺序排好。现在小特种兵们已经在你面前有序从低到高站成两排。你需要做的就是将两个队伍合并在一起，同时保持递增顺序。
输入格式: 两个升序链表。每行第一个数是链表结点数
输出格式: 合并后的新升序链表。
在这里给出一组输入。例如：
3 1 2 4 2 3 6 输出样例: 在这里给出相应的输出。例如：
1 2 3 4 6 代码长度限制
16 KB
时间限制
400 ms
内存限制
64 MB
代码如下（示例）： #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; typedef struct qq{ int k; struct qq *next; }az; az *create(int n){ az *head=(az *)malloc(sizeof(az)),*tail=head; for(int i=0;i&lt;n;i++){ az *p=(az *)malloc(sizeof(az)); p-&gt;next=NULL; scanf("%d",&amp;p-&gt;k); tail-&gt;next=p; tail=tail-&gt;next; } return head; } void swap_link(az *h,az *hh,az *o){ if(o-&gt;next!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3393b17e83bc11d8f095a63e2776b6fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57b6a9e6efb231ba73abb0f39e463471/" rel="bookmark">
			C&#43;&#43; map和vector向量使用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++ map用法 C++ 中 map 提供的是一种键值对容器，里面的数据都是成对出现的,如下图：每一对中的第一个值称之为关键字(key)，每个关键字只能在 map 中出现一次；第二个称之为该关键字的对应值。
map的使用 需要导入头文件 #include &lt;map&gt; // STL头文件没有扩展名.h map对象是一个模版类，需要关键字和存储对象两个模版参数 std::map&lt;int , std::string&gt; person; 定义map类型，是有模板的，他接受三个参数：
第一个参数是键的数据类型
第二个参数是值的数据类型
第三个参数是排序规则，不写的话就按照默认的排序规则，也就是按照键的升序
可以对模版进行类型定义使其使用方便 typedef std::map&lt;int , std::string&gt; MAP_INI_STRING; MAP_INI_STRING person; map的构造 1、map 最基本的构造函数；
std::map&lt;int , std::string&gt; mapPerson; 2、map 添加数据；
insert 函数插入 pair 数据 std::map &lt; int , std::string &gt; mapPerson; mapPerson.insert(pair &lt; int,string &gt; (1,"Jim")); 2)insert 函数插入 value_type 数据
mapPerson.insert(std::map &lt; int, std::string &gt; ::value_type (2, "Tom")); 3)用数组方式插入数据
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57b6a9e6efb231ba73abb0f39e463471/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6ff9b7ef19fa7f98df1d15e4db4202f/" rel="bookmark">
			CSS overflow-anchor
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		overflow-anchor 为了认识这个属性, 我们需要先看一种常见的现象. 即在网页加载中, 图片常常比文字加载更慢, 这样图片加载完成后可能会将文字向下顶. 比如下图演示
&lt;div class="overflow"&gt; &lt;img id="bg" src="" height="150" alt="" srcset=""&gt; Lorem... &lt;/div&gt; const bg = document.getElementById('bg') setTimeout(() =&gt; { bg.src = 'https://www.baidu.com/img/PCtm_d9c8750bed0b3c7d089fa7d55720d6cf.png' }, 3000) 但是如果你把代码拷贝运行, 你却得不到上图的效果, 因为我有一个属性没有告诉你.
其实浏览器厂商早就注意并修复了这个问题, 真实的情况是图片加载后文字也不会向下滚动. 如下图, 注意右边代码中 &lt;img&gt; 标签的 src 有值后文字并没有向下滚动, 这才是浏览器的默认行为.
那究竟是哪个属性起了作用呢? 就是今天的主角 overflow-anchor. 下面的代码是第一个动图对应的代码.
.overflow { height: 300px; overflow: auto; border: 1px solid #111; overflow-anchor: none; font-size: 2em; } ⚠️ 在上面的例子中, 为了演示效果我们先把内容往下滚动了一部分让图片在黑色框框之外. 不然如果一点也不滚动图像就在框框里, 那么图像加载完成后肯定会将文字挤下去.
auto 和 none overflow-anchor 可以是 auto 或 none.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d6ff9b7ef19fa7f98df1d15e4db4202f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80eab35833fb019b7c8da5dd1ce3dc6d/" rel="bookmark">
			MyBatis增删改查基础及其xml文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一.增删改查基础
1.增
增@Insert
获取自增ID
对insert参数进行重命名
2.删
3.改
4.查
1)对MySQL查询结果进行重命名
从MySQL层面--as
从mybatis层面--@Results注解
复用@Results的定义
2)配置自动转换驼峰命名（推荐）
二.Mybatis xml配置文件
指明xml的路径
配置xml内容
xml实现的增删改查
一.增删改查基础 1.增 增@Insert 测试代码：
测试结果：
获取自增ID 测试：
对insert参数进行重命名 2.删 3.改 测试：
4.查 mybatis会根据数据库的字段名和Java对象的属性名，进行映射，如果名称一样就可以进行赋值。
1)对MySQL查询结果进行重命名 从MySQL层面--as 企业中应该避免使用*
当数据库中的名字与Java对象中的名字对应不一致时，重命名映射使用as将两者关联起来。
从mybatis层面--@Results注解 字段与Java属性一样的不用重写
缺点：每写一个新的方法都需要使用@Results重新注解一遍，代码冗余。
复用@Results的定义 2)配置自动转换驼峰命名（推荐） application.properties或者application.yml中配置以下内容
两个文件配置内容如下：
#配置驼峰⾃动转换 mybatis.configuration.log-impl.map-underscore-to-camel-case=true mybatis: configuration: log-impl： map-underscore-to-camel-case: true 二.Mybatis xml配置文件 需要配置数据库；指明xml的路径；写xml的实现
指明xml的路径 # 配置mybatis xml的⽂件路径,在 resources/mapper 创建所有表的 xml ⽂件 mybatis.mapper-locations= classpath:mapper/**Mapper.xml resource路径下要有一个mapper文件夹，mapper文件夹下要有一个文件末尾名为Mapper的xml文件。
配置xml内容 &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;!DOCTYPE mapper PUBLIC "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/80eab35833fb019b7c8da5dd1ce3dc6d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce0701f557ec9787a012d0ec4a49193d/" rel="bookmark">
			2023 华为OD机试（JavaScript）真题【A卷&#43;B卷&#43;C卷&#43;D卷】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		各语言题库： 【Python+JS+Java合集】【超值优惠】：Py/JS/Java合集
【Python】：Python真题题库
【JavaScript】：JavaScript真题题库
【Java】：Java真题题库
【C++】：C++真题题库
【C语言】：C语言真题题库
【面试手撕代码题库】：面试手撕代码题库
【华为od机试面试交流群：830285880】
集中答疑： 0：全网最全题库，400+题目。
1：考试链接上写着【A卷】，对应的就是OD统一考试A卷目录的题目。
2：考试链接上写着【B卷】，对应的就是OD统一考试B卷目录的题目。目前B卷的题目由一部分以前考过的旧题库的题目+一部分全新题目（之前没考过的）题目组成。
3：考试链接上写着【C卷、D卷】。目前由A+B卷的旧题 + 全新题目组成。也就是说C卷和D卷还会考到A+B卷的题目，比例大概是新题1道，旧题2道。
4：【C卷、D卷】的新题有一个特殊点，就是无需自己处理输入和输出，为leetcode模式，实现对应函数逻辑即可。
5：机试没过，半年的冷冻期。
6：订阅专栏后，专栏内所有的文章都可以看，以后再更新新的题目也可以看，每年更新的题目都会更新到一个专栏里面。
7：文章内均有题目+思路+代码。
8：已经订阅过我专栏的同学，推荐新人订阅的可享 8折 优惠，私信我即可！
OD统一考试【C卷】题库 2023Q4新题库【更新中】
（目录可能更新不及时，可以直接搜我的博客）
序号题目考点分值时间1山脉的个数数据结构2002023Q42数据单元的变量替换字符串处理1002023Q43密码输入检测字符串处理1002023Q44找出作弊的人自定义排序1002023Q45转盘寿司单调栈2002023Q46体育场找座位逻辑分析1002023Q475G网络建设并查集2002023Q48中庸行者BFS/DFS2002023Q49会议室占用时间段逻辑模拟1002023Q410小华地图寻宝BFS/DFS2002023Q411CPU算力分配逻辑分析1002023Q412高效货运贪心算法1002023Q413小明的幸运数逻辑模拟1002023Q414跳马问题BFS/DFS2002023Q415掌握单词的个数数据结构1002023Q416计算三叉搜索树的高度树遍历2002023Q417来自异国的客人/幸运数字进制转换1002023Q418石头剪刀布游戏逻辑分析1002023Q419园区参观路径BFS/DFS1002023Q420多线段数据压缩数学知识2002023Q421开源项目热度榜单自定义排序1002023Q422API集群负载统计数据结构1002023Q423机场航班调度自定义排序1002023Q424小明找位置二分法1002023Q425最优的投资方式逻辑分析1002023Q426分配土地数据结构1002023Q427最多购买宝石数目滑动窗口1002023Q428王者荣耀游戏分组回溯算法1002023Q429执行任务赚积分逻辑模拟1002023Q430智能成绩表自定义排序1002023Q431内存冷热标记自定义排序1002023Q432最富裕的小家庭数据结构1002023Q433机器人搬砖二分法1002023Q434剩余银饰的重量逻辑模拟1002023Q435分割均衡字符串逻辑模拟1002023Q436目录待更新 OD统一考试【B卷】题库 目录更新可能不及时，直接点我专栏进去看题即可
序号题目考点分值时间1宜居星球改造计划数据结构2002023Q2 2
需要打开多少监视器
逻辑分析1002023Q23最佳植树距离逻辑分析1002023Q24阿里巴巴找黄金宝箱 I前缀和2002023Q25选修课数据结构1002023Q26五子棋迷逻辑分析1002023Q27代表团坐车动态规划1002023Q28座位调整逻辑分析1002023Q29食堂供餐二分法1002023Q210寻找最大价值的矿堆DFS1002023Q211最长公共后缀逻辑分析1002023Q212模拟消息队列逻辑分析1002023Q213比赛数据结构1002023Q214告警抑制逻辑分析1002023Q215报文重排序字符串处理1002023Q216字符串摘要字符串处理1002023Q217稀疏矩阵逻辑分析1002023Q218AI 识别面板数据结构1002023Q219报文回路数据结构1002023Q220阿里巴巴找黄金宝箱 II数据结构1002023Q221阿里巴巴找黄金宝箱 III数据结构1002023Q222阿里巴巴找黄金宝箱 IV单调栈2002023Q223文件目录大小DFS1002023Q224组装最大可靠性设备动态规划2002023Q225找出两个整数数组中同时出现的整数数据结构1002023Q226通过软盘拷贝文件动态规划2002023Q227代码编辑器逻辑分析2002023Q228数据分类进制问题1002023Q229恢复数字序列滑动窗口1002023Q230阿里巴巴找黄金宝箱 V滑动窗口1002023Q231比赛的冠亚季军排序算法1002023Q232数字游戏逻辑分析1002023Q233经典屏保逻辑分析1002023Q234字符串化繁为简字符串处理2002023Q235数据最节约的备份方法二分法1002023Q236跳格子2逻辑分析1002023Q237跳房子2数据结构1002023Q238支持优先级的队列数据结构1002023Q239乘坐保密电梯回溯法1002023Q240计算最接近的数逻辑分析1002023Q241人气最高的店铺逻辑分析1002023Q242战场索敌DFS2002023Q243二维伞的雨滴效应二叉树1002023Q244跳房子I数据结构1002023Q245分割数组的最大差值逻辑分析1002023Q246生日礼物二分法1002023Q247求最小步数逻辑分析1002023Q248拔河比赛数据结构1002023Q249评论转换输出递归法2002023Q250树状结构查询数据结构2002023Q251不开心的小朋友逻辑分析2002023Q252数字序列比大小逻辑分析2002023Q253符合要求的元组个数 / K 数之和回溯法1002023Q254最小循环子数组KMP算法2002023Q255金字塔 / 微商的收入数据结构1002023Q256矩阵元素边界值字符串处理1002023Q257MELON的难题动态规划2002023Q258矩阵中非1的元素个数BFS2002023Q259计算误码率逻辑分析2002023Q260增强的strstr正则匹配1002023Q261关联子串字符串处理1002023Q262计算礼品发放的最小分组数目双指针1002023Q263字符匹配正则匹配1002023Q2 2022旧题目
序号题目考点分值时间1 德州扑克
数据结构2002022Q1 2
字符串子序列 II
字符串处理1002022Q13 分苹果
位运算1002022Q14 事件推送
数据结构1002022Q15 路灯照明
逻辑模拟1002022Q16 补活未成活胡杨
滑动窗口1002022Q17 统计射击比赛成绩
排序算法1002022Q18 高矮个子排队
排序算法2002022Q19 非严格递增连续数字序列
双指针1002022Q110 最大股票收益
贪心算法2002022Q111 找朋友
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce0701f557ec9787a012d0ec4a49193d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9f448d2b9cf8834c391b85899559e66/" rel="bookmark">
			华为机试（C&#43;&#43;）真题Od【A卷&#43;B卷&#43;C卷&#43;D卷】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		各语言题库： 【Python+JS+Java合集】【超值优惠】：Py/JS/Java合集
【Python】：Python真题题库
【JavaScript】：JavaScript真题题库
【Java】：Java真题题库
【C++】：C++真题题库
【C语言】：C语言真题题库
【面试手撕代码题库】：面试手撕代码题库
【华为od机试面试交流群：830285880】
集中答疑： 0：全网最全题库，400+题目。
1：考试链接上写着【A卷】，对应的就是OD统一考试A卷目录的题目。
2：考试链接上写着【B卷】，对应的就是OD统一考试B卷目录的题目。目前B卷的题目由一部分以前考过的旧题库的题目+一部分全新题目（之前没考过的）题目组成。
3：考试链接上写着【C卷、D卷】。目前由A+B卷的旧题 + 全新题目组成。也就是说C卷和D卷还会考到A+B卷的题目，比例大概是新题1道，旧题2道。
4：【C卷、D卷】的新题有一个特殊点，就是无需自己处理输入和输出，为leetcode模式，实现对应函数逻辑即可。
5：机试没过，半年的冷冻期。
6：订阅专栏后，专栏内所有的文章都可以看，以后再更新新的题目也可以看，每年更新的题目都会更新到一个专栏里面。
7：文章内均有题目+思路+代码。
8：已经订阅过我专栏的同学，推荐新人订阅的可享 8折 优惠，私信我即可！
OD统一考试【C卷题库】 2023Q4新题库【更新中】
（目录可能更新不及时，可以直接搜我的博客）
序号题目考点分值时间1山脉的个数数据结构2002023Q42数据单元的变量替换字符串处理1002023Q43密码输入检测字符串处理1002023Q44找出作弊的人自定义排序1002023Q45转盘寿司单调栈2002023Q46体育场找座位逻辑分析1002023Q475G网络建设并查集2002023Q48中庸行者BFS/DFS2002023Q49会议室占用时间段逻辑模拟1002023Q410小华地图寻宝BFS/DFS2002023Q411CPU算力分配逻辑分析1002023Q412高效货运贪心算法1002023Q413小明的幸运数逻辑模拟1002023Q414跳马问题BFS/DFS2002023Q415掌握单词的个数数据结构1002023Q416计算三叉搜索树的高度树遍历2002023Q417来自异国的客人/幸运数字进制转换1002023Q418石头剪刀布游戏逻辑分析1002023Q419园区参观路径BFS/DFS1002023Q420多线段数据压缩数学知识2002023Q421开源项目热度榜单自定义排序1002023Q422API集群负载统计数据结构1002023Q423机场航班调度自定义排序1002023Q424小明找位置二分法1002023Q425最优的投资方式逻辑分析1002023Q426分配土地数据结构1002023Q427最多购买宝石数目滑动窗口1002023Q428王者荣耀游戏分组回溯算法1002023Q429执行任务赚积分逻辑模拟1002023Q430智能成绩表自定义排序1002023Q431内存冷热标记自定义排序1002023Q432最富裕的小家庭数据结构1002023Q433机器人搬砖二分法1002023Q434剩余银饰的重量逻辑模拟1002023Q435分割均衡字符串逻辑模拟1002023Q436待更新目录 OD统一考试【B卷题库】 序号题目考点分值时间1宜居星球改造计划数据结构2002023Q2 2
需要打开多少监视器
逻辑分析1002023Q23最佳植树距离逻辑分析1002023Q24阿里巴巴找黄金宝箱前缀和2002023Q25选修课数据结构1002023Q26五子棋迷逻辑分析1002023Q27代表团坐车动态规划1002023Q28座位调整逻辑分析1002023Q29食堂供餐二分法1002023Q210寻找最大价值的矿堆DFS1002023Q211最长公共后缀逻辑分析1002023Q212模拟消息队列逻辑分析1002023Q213比赛数据结构1002023Q214告警抑制逻辑分析1002023Q215报文重排序字符串处理1002023Q216字符串摘要字符串处理1002023Q217稀疏矩阵逻辑分析1002023Q218AI 识别面板数据结构1002023Q219报文回路数据结构1002023Q220阿里巴巴找黄金宝箱 II数据结构1002023Q221阿里巴巴找黄金宝箱 III数据结构1002023Q222阿里巴巴找黄金宝箱 IV单调栈2002023Q223文件目录大小DFS1002023Q224组装最大可靠性设备动态规划2002023Q225找出两个整数数组中同时出现的整数数据结构1002023Q226通过软盘拷贝文件动态规划2002023Q227代码编辑器逻辑分析2002023Q228数据分类进制问题1002023Q229恢复数字序列滑动窗口1002023Q230阿里巴巴找黄金宝箱 V滑动窗口1002023Q231比赛的冠亚季军排序算法1002023Q232数字游戏逻辑分析1002023Q233经典屏保逻辑分析1002023Q234字符串化繁为简字符串处理2002023Q235数据最节约的备份方法二分法1002023Q236跳格子2逻辑分析1002023Q237跳房子2数据结构2002023Q238支持优先级的队列数据结构1002023Q239乘坐保密电梯回溯法1002023Q240计算最接近的数逻辑分析1002023Q241人气最高的店铺逻辑分析1002023Q242战场索敌DFS2002023Q243二维伞的雨滴效应二叉树1002023Q244跳房子I数据结构1002023Q245分割数组的最大差值逻辑分析1002023Q246生日礼物二分法1002023Q247求最小步数逻辑分析1002023Q248拔河比赛数据结构1002023Q249评论转换输出递归法2002023Q250树状结构查询数据结构2002023Q251不开心的小朋友逻辑分析2002023Q252数字序列比大小逻辑分析2002023Q253符合要求的元组个数 / K 数之和回溯法1002023Q254最小循环子数组KMP算法2002023Q255金字塔 / 微商的收入数据结构1002023Q256矩阵元素边界值字符串处理1002023Q257MELON的难题动态规划2002023Q258矩阵中非1的元素个数BFS2002023Q259计算误码率逻辑分析2002023Q260增强的strstr正则匹配1002023Q261关联子串字符串处理1002023Q262计算礼品发放的最小分组数目双指针1002023Q263字符匹配正则匹配1002023Q264最小传输时延I Dijkstra算法2002023Q265一种字符串压缩表示的解压正则匹配1002023Q266冠亚军排名排序方法1002023Q267报数游戏逻辑分析1002023Q268找出经过特定点的路径长度逻辑分析1002023Q269按单词下标区间翻转文章内容字符串处理1002023Q270数列描述逻辑分析1002023Q271字符串筛选排序排序方法1002023Q272相对开音节正则匹配1002023Q273字符串变换最小字符串字符串处理1002023Q274VLAN资源池数据结构1002023Q275拼接URL字符串处理1002023Q276执行时长/GPU算力逻辑分析1002023Q277荒岛求生数据结构2002023Q378查字典字符串处理1002023Q379周末爬山BFS2002023Q380最小数字排序方法1002023Q381最长的元音子串字符串处理1002023Q382TLV解析II数据结构1002023Q383玩牌高手逻辑分析2002023Q384最长连续子序列滑动窗口1002023Q385路灯照明II区间合并1002023Q386最多团队排序方法1002023Q387最长的顺子数据结构1002023Q388数字最低位排序排序方法1002023Q389整数编码字符串处理1002023Q390找车位逻辑分析1002023Q391选举拉票线段树2002023Q392单词加密字符串处理1002023Q393购物优先级队列2002023Q394最佳的出牌方法逻辑分析2002023Q395字符串划分数据结构1002023Q396洞穴探险字符串处理1002023Q397最大岛屿体积BFS1002023Q398DNA序列滑动窗口1002023Q399服务启动DFS1002023Q3100最长公共前缀字符串处理1002023Q3101查找舆情热词数据结构1002023Q3102排队游戏二分法2002023Q4103BOSS的收入数据结构1002023Q4104猴子吃桃二分法1002023Q4105滑动窗口最大值滑动窗口1002023Q4106全排列数学问题1002023Q4107编码能力提升计划逻辑处理2002023Q4108水果摊小买卖贪心算法1002023Q4109正整数到excel编号的转换进制转换1002023Q4110反转每对括号间的子串数据结构1002023Q4111模拟工作队列数据结构2002023Q4112删除字符串中出现次数最少的字符字符串处理1002023Q4 2023Q2B卷 旧题目
序号题目分值1德州扑克2002字符串子序列 II1003分苹果1004事件推送1005路灯照明1006补活未成活胡杨1007统计射击比赛成绩1008高矮个子排队2009非严格递增连续数字序列10010最大股票收益20011找朋友20012单词重量10013跳格子游戏20014篮球比赛20015勾股数元组20016太阳能板最大面积10017整数对最小和10018最小传输时延20019热点网站统计20020数大雁10021最长广播效应20022快递运输10023打印任务排序20024高效的任务规划20025乱序整数序列两数之和绝对值最小10026没有回文串20027喊七游戏10028最少面试官20029报文解压缩20030服务失效判断20031跳格子20032任务最优调度20033最长子字符串的长度10034翻牌求最大分10035快速人名查找10036寻找相同子串10037城市聚集度20038计算最大乘积10039磁盘容量排序10040符合要求的结对方式10041数组拼接10042出错的或电路20043分积木20044解密犯罪时间20045仿 LISP 运算20046九宫格按键输入法20047书籍叠放20048移除K位数字后的最小数20049导师请吃火锅20050最长连续方波信号20051最长的指定瑕疵度的元音子串20052数字反转打印10053求字符串中所有整数的最小和10054转骰子20055可以组成网络的服务器20056区间交集20057分月饼20058树形目录删除20059发广播20060简易内存池20061最大社交距离20062机器人走迷宫20063学生方阵20064堆栈中的剩余数字20065贪吃蛇20066组成最大数20067单词搜索/找到它20068找单词20069竖直四子棋20070信道分配20071数字排列20072猜密码20073字符串比较20074数组二叉树20075图像物体的边界20076N进制减法20077斗地主之顺子20078计算疫情扩散时间20079考古问题20080连续出牌数量20081矩形相交面积20082求满足条件的最长子串的长度20083欢乐的周末20084二叉树中序遍历20085最远足迹10086运维日志排序10087观看文艺汇演问题 / 计算最多能看几场演出10088GPU算力 / 执行时长10089水仙花数10090用连续自然数之和来表达整数10091水仙花数II(字符串分割)10092考勤信息10093英文输入法10094找终点10095字符串中找到连续最长数字串10096We Are A Team10097免单统计10098流水线调度10099小朋友排队100100查找接口成功率最优时间段100101数字字符串组合倒序100102密钥格式化100103全量和已占用字符集100104数字涂色100105分糖果100106字符串序列判定100107数组连续和100108字符串排序100109数据分类100110污染水域200111TLV解析I100112迷宫问题100113求解连续序列100114矩阵最大值100115表达式括号匹配100116最大括号深度100117输出指定字母在字符串中的索引100118找到比自己强的人 / 师徒关系100119内存资源分配100120完全二叉树非叶子部分后序遍历100121敏感字段加密100122IPv4地址转换为整数100123正方形数量200124消消乐游戏 / 字符串消除100125判断一组不等式是否满足约束并输出最大差100126最少交换次数100127叠积木200128单词接龙100129查找中位数及众数100130猴子爬山100131约瑟夫问题100132最大矩阵和200133火星文计算100134统计文本数量100135采样过滤200136素数之积100137批量处理任务100138最大时间100139绘图机器 / 计算面积100140连续字母长度100141停车场车辆统计100142数组去重和排序100143用户调度问题100144工号不够用了怎么办100145字符串加密100146最大N个数与最小N个数的和100147靠谱的车1001485键键盘100149分班问题100150最大花费金额100 OD统一考试【A卷】题库 序号题目分值时间1最大化控制资源成本2002022.Q42完美走位1002022.Q43羊、狼、农夫过河2002022.Q44字符串重新排列1002022.Q45租车骑绿岛1002022.Q46无向图染色1002022.Q47单向链表中间节点1002022.Q48等和子数组最小和2002022.Q49最多颜色的车辆1002022.Q410不含101的数1002022.Q411过滤组合字符串2002022.Q412真正的密码1002022.Q413最小调整顺序次数1002022.Q414探索地块建立2002022.Q415模拟商场优惠打折1002022.Q416区间覆盖2002022.Q417二元组个数1002022.Q418最大平分数组2002022.Q419连接器问题2002022.Q420打印机队列1002022.Q421处理器问题1002022.Q422日志首次上报最多积分1002022.Q423简单的自动曝光1002022.Q424获取最大软件版本号1002022.Q425二进制差异数2002022.Q426Excel单元格数值统计1002022.Q427相同数字的积木游戏1002022.Q428开放日活动1002022.Q429投篮大赛1002022.Q430开心消消乐2002022.Q431通信误码1002022.Q432最大报酬1002022.Q433机器人1002022.Q434新学校选址2002022.Q435寻找路径1002022.Q436任务调度1002022.Q437匿名信1002022.Q438密室逃生游戏1002022.Q439快递业务站1002022.Q440对称美学1002022.Q441箱子之字形摆放1002022.Q442数组合并1002022.Q443挑选字符串1002022.Q444优选核酸检测点2002022.Q445最短木板长度1002022.Q446最多获得的短信条数1002022.Q447星际篮球争霸赛1002022.Q448最左侧冗余覆盖子串1002022.Q449端口合并1002022.Q450最大利润1002022.Q451最长的密码1002022.Q452计算数组中心位置1002022.Q453积木最远距离1002022.Q454区间交叠问题1002022.Q455整理扑克牌1002022.Q456分奖金2002022.Q457计算快递业务主站点2002022.Q458去除多余空格2002022.Q459最差产品奖2002022.Q460最多等和不相交连续子序列1002022.Q461货币单位换算1002022.Q462查找单入口空闲区域1002022.Q463预定酒店1002022.Q464基站维护最短距离2002022.Q465士兵过河2002022.Q466查找二叉树节点2002022.Q467硬件产品销售方案1002022.Q468核酸最快检测效率2002022.Q469计算网络信号2002022.Q470异常的打卡记录1002022.Q471删除重复数字后的最大数字2002022.Q472字符串解密1002022.Q473找等值元素1002022.Q474任务总执行时长1002022.Q475水库蓄水问题2002022.Q476单词倒序1002022.Q477找出重复代码1002022.Q478优雅子数组2002022.Q479数字加减游戏1002022.Q480猜字谜1002022.Q481农场施肥1002022.Q482组装新的数组2002022.Q483快速开租建站1002022.Q484统计友好度最大值1002022.Q485荒地建设电站2002022.Q486区块链文件转储系统1002022.Q487新词挖掘1002022.Q488查找充电设备组合1002022.Q489上班之路2002022.Q490简单的解压缩算法2002022.Q491最优高铁城市修建方案2002022.Q492垃圾短信识别2002022.Q493机房布局1002022.Q494静态扫描1002022.Q495快递投放问题1002022.Q496优秀学员统计2002022.Q497人数最多的站点/小火车人数最多所在站点1002022.Q498寻找相似单词1002022.Q499严格递增字符串1002022.Q4100微服务的集成测试2002022.Q4101组合出合法最小数1002022.Q4102信号发射与接收2002022.Q4103Linux发行版数量1002022.Q4104九宫格游戏 / 三阶积幻方1002023.Q1105模拟商场优惠打折II1002022.Q4106日志限流1002022.Q4107最优芯片资源占用1002022.Q4108工单调度策略1002022.Q4109统一限载最小值1002023.Q1110服务中心选址2002023.Q1112实力差距最小总和2002023.Q1113最多组合直角三角形个数2002023.Q1114几何平均值最大子数组1002023.Q1115构建二叉树2002023.Q1116最长回文子串1002023.Q1117大炮攻城2002023.Q1118检测热点字符1002023.Q1119数组限制数1002023.Q1120银行插队1002023.Q1121称砝码2002023.Q1122高速公路休息站充电规划1002023.Q2123超级玛丽过吊桥1002023.Q2124相同数字组成图形的周长2002023.Q2125响应报文时间1002023.Q1126带传送阵的矩阵游离2002023.Q1127猜数字2002023.Q1128西天取经2002023.Q1129购买水果最便宜的方案1002023.Q1130机智的外卖员1002023.Q1131新员工考试1002023.Q1132幻方修复1002023.Q1133天然货仓1002023.Q1134135136 2022.10.01 目标：在12月更新到200题。
每个季度出新题都会更新到这个专栏里。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d9f448d2b9cf8834c391b85899559e66/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a17a96bfe6b51c7b303e1cee4957abd/" rel="bookmark">
			视觉理解与定位 # RPA # Auto-operation
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		正文
参考资料
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed0a9b1eed6668d4ab4579e301a148f2/" rel="bookmark">
			echarts：设置折线图线条和端点的颜色
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、代码
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Echarts折线图&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="main" style="width: 600px;height:400px;"&gt;&lt;/div&gt; &lt;script type="text/javascript" src="/js/echarts/echarts.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; // 基于准备好的dom，初始化echarts实例 var myChart = echarts.init(document.getElementById('main')); // 指定图表的配置项和数据 var option = { title: { text: 'ECharts 入门示例' }, tooltip: {}, legend: { data:['销量'] }, xAxis: { data: ["衬衫","羊毛衫","雪纺衫","裤子","高跟鞋","袜子"] }, yAxis: {}, series: [{//第一条折线图 name: '销量1', type: 'line', data: [5, 20, 36, 10, 10, 20] },{//第二条折线图 name: '销量2', type: 'line', data: [6, 29, 30, 10, 10, 20] },{//第三条折线 name: '销量3', type: 'line', data: [7, 39, 40, 20, 10, 20], lineStyle: {//设置线条颜色 normal: { color: 'red' // 折线线条颜色:红色 } }, itemStyle: {//设置端点颜色 normal: { color: 'red' // 设置线条上点的颜色（和图例的颜色） } } },{ },{ },{ }] }; // 使用刚指定的配置项和数据显示图表。 myChart.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed0a9b1eed6668d4ab4579e301a148f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc4ce760eb06d271fc728085df0065ec/" rel="bookmark">
			centos 安装git
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 CentOS 上安装 Git 的过程相对简单。Git 是一个版本控制系统，广泛用于软件开发和其他版本控制任务。以下是在 CentOS 上安装 Git 的步骤：
1. 打开终端 首先，打开您的 CentOS 系统上的终端。
2. 安装 Git 使用以下命令安装 Git：
sudo yum install git 这个命令将使用 CentOS 的包管理器 yum 来安装 Git。sudo 确保您以管理员权限运行安装。
3. 验证安装 安装完成后，您可以通过运行以下命令来验证 Git 是否已成功安装：
git --version 这将显示安装的 Git 版本，从而确认安装是否成功。
4. 配置 Git（可选） 在安装 Git 之后，您可能还想配置您的 Git 环境。通常，这包括设置您的用户名和电子邮件地址，因为这些信息会被用于 Git 提交。
设置用户名：
git config --global user.name "Your Name" 设置电子邮件地址：
git config --global user.email "youremail@example.com" 将 "Your Name" 和 "youremail@example.com" 替换为您自己的信息。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc4ce760eb06d271fc728085df0065ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80d44dfcc279ebbdee611c1b256f3181/" rel="bookmark">
			【数据结构】无向图的最小生成树（Prime，Kruskal算法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、最小生成树二、Kruskal算法1.方法：2.判断是否成环3.代码实现 三、 Prim算法1.方法：2.代码 四、源码 前言 连通图：在无向图中，若从顶点v1到顶点v2有路径，则称顶点v1与顶点v2是连通的。如果图中任意一对顶点都是连通的，则称此图为连通图
强连通图：在有向图中，若在每一对顶点vi和vj之间都存在一条从vi到vj的路径，也存在一条从vj到vi的路径，则称此图是强连通图
生成树：一个连通图的最小连通子图称作该图的生成树。有n个顶点的连通图的生成树有n个顶点和n-1条边
连通图中的每一棵生成树，都是原图的一个极大无环子图，即：从其中删去任何一条边，生成树就不在连通；反之，在其中引入任何一条新边，都会形成一条回路。
一、最小生成树 若连通图由n个顶点组成，则其生成树必含n个顶点和n-1条边。因此构造最小生成树的准则有三条：
只能使用图中的边来构造最小生成树只能使用恰好n-1条边来连接图中的n个顶点选用的n-1条边不能构成回路 构造最小生成树的方法：Kruskal算法和Prim算法。这两个算法都采用了逐步求解的贪心策略
二、Kruskal算法 里面涉及一些图的代码，不了解的可以参考之前我写的【数据结构】图的创建（邻接矩阵，邻接表）以及深度广度遍历（BFS,DFS）
1.方法： 任给一个有n个顶点的连通网络N={V,E}，
首先构造一个由这n个顶点组成、不含任何边的图G={V,NULL}，其中每个顶点自成一个连通分
量，
其次不断从E中取出权值最小的一条边(若有多条任取其一)，若该边的两个顶点来自不同的连通分
量，则将此边加入到G中。如此重复，直到所有顶点在同一个连通分量上为止。
核心：每次迭代时，选出一条具有最小权值，且两端点不在同一连通分量上的边，加入生成树 2.判断是否成环 我们要保证不能成环需要保证选入某条边之前，这条边两个顶点本身就不连通，换种说法就是两个顶点没有公共的顶点或者不在同一个集合当中，这个时候我们就可以考虑之前学的并查集的知识来解决了，并查集就是解决两个元素的联合与判断是否在一个结合中的数据结构。
不知道小伙伴可以去看看之前我写的【数据结构】并查集的简单实现，合并，查找（C++）
3.代码实现 typedef Graph&lt;V, W, MAX_W, false&gt; Self; //建立边的类，保存边的两个顶点下标和权值 struct Edge { size_t _srci; size_t _dsti; W _w; Edge(size_t srci,size_t dsti,W w) :_srci(srci), _dsti(dsti), _w(w) {} bool operator&gt;(const Edge&amp; e)const { return _w &gt; e._w;//小根堆判断 } }; W Kruskal(Self&amp; minTree) { //minTree为最小生成树，刚开始什么都没有 size_t n = _vertexs.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/80d44dfcc279ebbdee611c1b256f3181/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ed24825dc8133162f2e9104529010ae/" rel="bookmark">
			分布式系统架构设计之分布式数据管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着互联网时代的不断发展，分布式系统架构成为支撑大规模用户和高并发访问的基础。在构建分布式系统时，分布式系统有着一系列的要求以及对应的核心技术，涉及到数据管理、通信安全性、性能优化、可扩展性设计以及架构演进与版本管理等很多方面。
一、分布式数据管理：构建稳健数据基石 在信息技术迅猛发展的今天，大规模分布式系统在应对海量数据和高并发访问方面表现出了超强的优越性。在分布式系统架构中，数据管理是至关重要的一环。
数据一致性的重要性 随着业务规模和系统规模的不断增加和扩大，分布式系统逐渐成为解决大规模数据处理和高并发访问的首选方案。然后，在分布式系统中，数据一致性问题成为系统设计时的一大难题。
在分布式系统中，多个节点同时访问和修改数据，确保这些数据在不同节点上保持一致性变得至关重要，数据一致性直接关系到系统的正确性和可靠性，尤其是对于金融领域、交易领域、库存领域等业务场景尤为关键。
比如，TaoBao 平台，如果一个用户在 TaoBao App 上完成订单支付后，是需要更新对应商品的库存数量、订单状态、物流信息等。当前在 TaoBao 内部，像库存、订单、物流都是不同的团队在负责，部署在不同地域、不同节点、多个节点上，这时的数据更新操作其实是不能直接保证数据一致性的，可能会导致库存数量和实际数量不 Match、用户买家订单状态不准确、物流系统中物流状态不同步更改等问题，一旦出现会严重影响系统的可靠性，同时丧失口碑，造成用户的流失。
数据一致性的挑战 在分布式系统中，数据一致性的挑战主要包括以下三个方面：
节点故障：当系统中的某个节点发生不可快速恢复的故障时，可能会导致该节点上的数据与其他节点不一致。这会要求我们系统能够检测节点故障并采取响应的措施来保障数据的一致性并发修改：多个节点同时对相同的数据进行修改，可能会导致数据冲突和不一致。系统需要设计合适的并发控制策略，以确保数据的正确性网络延迟：在分布式系统中，节点之间通过网络通信进行数据同步。由于网络延迟的存在，可能会导致在不同节点之间的数据同步出现延迟，影响到数据的一致性 分布式事务解决方案 分布式事务的提出是为了解决数据一致性问题。分布式事务十一组事务操作的集合，要么全成功，要么全失败，确保数据在不同节点上都是一致的。
两阶段提交（2PC）： 2PC 是一种经典的分布式事务协议，分为两个阶段： 第一个阶段：协调者询问所有参与者是否可以执行事务第二个阶段：根据投票结果决定是否提交或回滚 尽管 2PC 保证了分布式系统的一致性问题，但是它的这种模式，其同步阻塞的特性会严重影响到性能
补偿事务：补偿事务是一种基于回滚操作的分布式事务协议。当事务发生错误时，系统会执行一系列的补偿操作，将数据恢复到正确的状态。这种方式能够降低同步阻塞的问题，但是需要设计合理有效的补偿方案最终一致性：最终一致性是一种相对弱的一致性，允许系统在一段时间内出现不一致的状态，但最终会收敛到一致的状态，它通过异步复制和版本控制来实现，适用于一些对实时性要求不高的场景 分布式数据管理的核心技术 随着大数据时代的到来，分布式数据管理已成为企业应对海量数据的关键技术，一般包括：
数据分片 在分布式数据库中，数据分片是指将数据分成多个片段，每个片段被存储在不同的计算机上。数据分片技术可以提高数据的可扩展性和可用性，因为每个片段可以独立地存储在不同的计算上，从而避免了单点故障。
以 Hadoop HDFS 为例，它是分布式文件系统，将数据存储在多个节点上，实现了数据的分布式存储和管理。
在 Hadoop HDFS 中，文件被分成多个块，每个块存储在一个独立的节点上。当客户端需要读取文件时，会从 HDFS 的元数据服务器获取文件块的分布情况，然后从不同的节点上读取这些块。这种方式提高了数据可扩展性和可用性，因为文件块可以独立地存储在不同的节点上，从而避免单点故障。
数据复制 为了提高数据的可用性和容错性，分布式数据库通常会使用数据复制技术。是指将数据从一个节点复制到另一个节点，提供数据的冗余性和可用性。当一个节点发生故障时，另一个节点可以接管该节点的任务，从而保障数据的可用性和可靠性。
以 Cassandra 为例，它是开源的分布式数据库，采用了分布式数据复制技术。
在 Cassandra 中，每个节点都保存了整个数据库的副本，当一个节点发生故障是，Cassandra 会检测到并将其从集群中移除，其他节点将继续正常运行并提供服务，保证数据的可用性和可靠性。Cassandra 还支持动态地添加节点，从而实现数据的水平和垂直扩展。
事务处理 事务处理是分布式数据库中的核心技术质疑，可以保证数据的完整性和一致性，事务处理可以确保一系列的数据操作要么全部成功，要么全部失败，避免数据的不一致性。在分布式数据库中，事务可以跨越多个节点进行操作，因此需要采用分布式事务处理技术，确保数据的 ACID 特性。
以 HBas 为例，HBase 是一种分布式列式存储数据库，它支持多个节点的事务处理。
在 HBase 中，事务可以跨越多个节点进行操作，为了保证事务的原子性和一致性，HBase 采用了 Write-Ahead-Logging（WAL）机制：当事务开始时，HBase 会将所有操作记录到 WAL 中，当事务提交时，HBase 会将这些操作应用到实际的数据中，如果事务失败，HBase 可以根据 WAL 中的记录进行回滚操作，以保证数据的完整性和一致性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ed24825dc8133162f2e9104529010ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/321c5740827bdbfeb4ed081d9931cc4f/" rel="bookmark">
			论文推荐：大型语言模型能自我解释吗?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这篇论文的研究主要贡献是对LLM生成解释的优缺点进行了调查。详细介绍了两种方法，一种是做出预测，然后解释它，另一种是产生解释，然后用它来做出预测。
最近的研究发现，即使LLM是在特定数据上训练的，也不能认识到训练的知识与推理上下文之间的联系。
因此一些人认为之为“X链”的方法非常重要。因为要求LLM将任务分解为思维链时，LLM在解决任务的同时检索所训练的现有知识方面表现更好。
LLM有没有能力回答问题，并提供一个解释如何得出结论。或者收到提示词后，LLM有没有能力分解他们的答案？
这篇论文使用两种方法来测试LLM的能力：
做出预测然后解释，或者产生一个解释，并用它来做出预测。
方法对比 思想链生成已被证明是一种较为敏捷的快速工程技术，特别是思想链还有很多优化的变体。思想链对于生成准确的答案是有效的，特别是对于复杂的推理任务，如解决数学问题或复杂的推理任务。
LLM-Generated Self-Explanations论文在情感分析领域对LLM生成的自我解释进行系统分析。
1、解释然后预测 ：Explanation To Prediction
下面的提示是E-P配置的一个示例。左边是SYSTEM描述，其中包含USER请求和LLM生成的ASSISTANT响应。在这个例子中，使用gpt-3.5 turbo，右边是标准模型设置。
上面的Python代码如下：
from openai import OpenAI client = OpenAI() response = client.chat.completions.create( model="gpt-3.5-turbo", messages=[ { "role": "system", "content": "You are a creative and intelligent movie review analyst, whose purpose is to aid in sentiment analysis of movie reviews. You will receive a review, and you must analyze the importance of each word and punctuation in Python tuple format: (&lt;word or punctuation&gt;, &lt;float importance&gt;).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/321c5740827bdbfeb4ed081d9931cc4f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92e69b1bf69180b0afb099390f244816/" rel="bookmark">
			最新版2023 docker 安装Consul
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 之前的版本取消下面的命令
docker pull consul:latest 现在用这个命令替代了
docker pull hashicorp/consul:latest 这样就安装成功了
运行 docker images 来列出本地已有的镜像，确认 hashicorp/consul 的最新版本已经正确下载到本地。
如果镜像存在，运行命令：
docker run --name consul -d -p 8500:8500 -p 8300:8300 -p 8301:8301 -p 8302:8302 -p 8600:8600/udp hashicorp/consul consul agent -dev -client=0.0.0.0 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65c9391f0818da6fe72bba8c039deff6/" rel="bookmark">
			FPC柔性线路板使用UV胶水的优势有哪些？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		UV胶水在FPC柔性线路板的装配中具有明显的优势：
快速固化 UV胶水在紫外线照射后10秒左右迅速固化，因此它能够在短时间内完成连接。这非常有助于实际工业作业中提高生产效率，特别是在需要大批量生产的情况下。
精确控制固化时间 UV胶水的固化时间可以通过紫外线照射的时间进行精确控制。这意味着在对连接点进行调整和对齐后，可以在需要时立即固化。
低温固化 相较于热固化胶水，UV胶水能够在较低的温度下进行固化。这就避免了对FPC和其他敏感组件造成热损害。
透明度 大多UV胶水是透明的，这对于保持FPC柔性线路板的外观和设计有利。透明性有助于保持设备的外观和不阻挡位于FPC上的标记或指示灯。
优异的附着力 UV胶水有着优异的附着力，确保连接点的稳定性。这在FPC柔性线路板的应用中至关重要，因为它们可能需要经历弯曲和变形。
柔韧性 UV胶水具有一定的柔韧性，适应FPC的弯曲和伸展。这有助于保持连接在FPC的使用寿命内。
无溶剂 UV胶水是无溶剂的，这降低了对环境的影响，并使其更适合一些对溶剂敏感的应用。
在实际需要和选择使用时，需要根据UV胶特性选择适用于特定的FPC柔性线路板的应用。并于制造商沟通确定，以达到最理想的效果。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72c29b7dac6656608dc20a9b72fd09fd/" rel="bookmark">
			设计模式之-原型模式，快速掌握原型模式，通俗易懂的理解原型模式以及使用场景
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章目录 设计模式之-6大设计原则简单易懂的理解以及它们的适用场景和代码示列
设计模式之-单列设计模式，5种单例设计模式使用场景以及它们的优缺点
设计模式之-3种常见的工厂模式简单工厂模式、工厂方法模式和抽象工厂模式，每一种模式的概念、使用场景和优缺点。
设计模式之模板方法模式，通俗易懂快速理解，以及模板方法模式的使用场景
设计模式之-建造者模式通俗易懂理解，以及建造者模式的使用场景和示列代码
设计模式之-代理模式，快速掌握理解代理模式，以及代理模式的使用场景
设计模式之-原型模式，快速掌握原型模式，通俗易懂的理解原型模式以及使用场景
设计模式之-中介者模式，快速掌握中介者模式，通俗易懂的讲解中介者模式以及它的使用场景
设计模式之-责任链模式，快速掌握责任链模式，通俗易懂的讲解责任链模式以及它的使用场景
设计模式之-装饰模式，快速掌握装饰模式，通俗易懂的讲解装饰模式以及它的使用场景
文章目录 系列文章目录一、什么是原型模式二、使用场景三、代码示例 一、什么是原型模式 原型模式是一种创建型设计模式，它允许通过复制现有对象来创建新的对象，而无需通过调用构造函数来创建。原型模式通过克隆操作来创建对象，提供了一种更加灵活和高效的对象创建方式。
在现实生活中，原型模式的例子可以是制作玩具的模具。模具（原型对象）定义了玩具的形状和细节，而根据模具可以快速复制出多个相同的玩具（克隆对象）。
二、使用场景 当创建新对象的成本较高时，可以使用原型模式来复制一个现有对象来创建新对象，避免了重复的初始化操作。当需要创建的对象是动态的，并且无法提前确定其具体类型时，可以使用原型模式。通过克隆操作，可以将复制对象的具体类型由运行时动态决定。 三、代码示例 下面是一个通俗易懂的原型模式示例代码，以动物克隆为场景：
// 抽象原型：动物 abstract class Animal implements Cloneable { private String name; public Animal(String name) { this.name = name; } public String getName() { return name; } public abstract Animal clone(); } // 具体原型：猫 class Cat extends Animal { public Cat(String name) { super(name); } @Override public Animal clone() { return new Cat(getName()); } } // 具体原型：狗 class Dog extends Animal { public Dog(String name) { super(name); } @Override public Animal clone() { return new Dog(getName()); } } // 客户端代码 public class Main { public static void main(String[] args) { Animal cat = new Cat("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/72c29b7dac6656608dc20a9b72fd09fd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05691a53b170903367a5715689d42c33/" rel="bookmark">
			前端开发有了 Next.js，还需要后端开发吗 ？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在迅速变化的Web开发领域，选择正确的工具和框架对于打造优秀的用户体验至关重要。Next.js，作为React框架的佼佼者，因其前后端流畅集成而受到广泛欢迎。这就引出了一个有趣的问题：我们真的需要Next.js的后端功能吗？
Next.js 简介 Next.js是一个强大的React框架，简化了服务端渲染React应用的创建过程。它提供了如服务端渲染、高效的客户端导航和自动代码分割等特性，为开发者带来愉悦的体验。
传统的Web应用通常分为前端和后端两部分。后端负责数据处理、存储和业务逻辑，而前端则处理用户界面和交互。然而，Next.js挑战了这一分工，使开发者能够用单一框架来构建前端和后端。
Next.js 后端的优势 服务端渲染（SSR）：Next.js擅长服务端渲染，即在服务器而非用户浏览器中渲染页面，从而提升Web应用性能。这样做的主要好处包括搜索引擎优化（SEO）和更快的首次页面加载速度。
API路由：Next.js允许开发者在前端代码库中轻松集成后端功能。这对于处理服务器端任务（如认证、数据获取等）尤其有用，无需单独的后端服务器。
统一的代码库：使用Next.js同时开发前后端的好处之一是代码库统一。这能改善前后端开发者的沟通，简化项目结构，并缩短开发时间。
自动代码分割：Next.js能够在页面级别自动分割代码，只加载给定页面所需的代码，优化性能。对于有多个路由的大型应用尤为有益。
JAMstack架构：Next.js强调前后端的解耦，并支持JAMstack架构。这种方法可以提供更好的可扩展性、增强安全性和简化部署流程。
何时需要独立后端 复杂业务逻辑：如果应用需要处理复杂的业务逻辑、大量数据处理或广泛的数据库交互，则可能需要专用的后端。
微服务架构：微服务架构将服务拆分为更易管理的独立部分。在这种情况下，拥有独立的后端有助于提高可扩展性和更好的关注点分离。
现有后端系统：如果项目需要与已有的数据库或后端系统交互，维护独立的后端可能更有意义。
结论 在不断变化的Web开发世界中，是否需要Next.js后端主要取决于项目的具体需求。Next.js为创建现代Web应用提供了强大的前后端集成解决方案。尽管在大多数情况下表现出色，但在某些情况下，仍然需要专用的后端。最终，这一选择应根据应用的复杂性、可扩展性需求和集成需求来做出。凭借Next.js的灵活性，开发者可以选择最佳策略以满足他们项目的目标。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d34682ea63d9ef2271f3498c256ec91/" rel="bookmark">
			MATLAB - 四元数（quaternion）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章目录 前言 一、简介 四元数是一种四元超复数，用于三维旋转和定向。
四元数的表示形式为 a+bi+cj+dk，其中 a、b、c 和 d 为实数，i、j 和 k 为基元，满足等式：i2 = j2 = k2 = ijk =-1。
四元数集用 H 表示，定义在实数的四维向量空间 R4 中。H 中的每个元素都有一个基于基元素 i、j 和 k 线性组合的唯一表示。
三维空间中的所有旋转都可以用旋转轴和围绕该轴的角度来描述。与旋转矩阵相比，四元数的优势在于旋转轴和旋转角度易于解释。例如，考虑 R3 中的一个点。要旋转该点，需要定义一个旋转轴和一个旋转角度。
旋转的四元数表示可表示为 ，其中 θ 是旋转角度，[ub、uc 和 ud] 是旋转轴。) ，其中 θ 是旋转角度，[ub、uc 和 ud] 是旋转轴。
二、MATLAB 用法 quat = quaternion() quat = quaternion(A,B,C,D) quat = quaternion(matrix) quat = quaternion(RV, "rotvec") quat = quaternion(RV, "rotvecd") quat = quaternion(RM, "rotmat",PF) quat = quaternion(E, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d34682ea63d9ef2271f3498c256ec91/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b8010e1b1ea262796905c8c4f53dd93/" rel="bookmark">
			springboot鲜花商城小程序-计算机毕设 附源码 84731
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于springboot微信小程序的鲜花商城 摘 要 随着我国经济迅速发展，人们对手机的需求越来越大，各种手机软件也都在被广泛应用，但是对于手机进行数据信息管理，对于手机的各种软件也是备受用户的喜爱，微信小程序的鲜花商城被用户普遍使用，为方便用户能够可以随时进行微信小程序的鲜花商城的数据信息管理，特开发了基于微信小程序的鲜花商城的管理系统。
微信小程序的鲜花商城主要是对系统所要实现的功能进行详细考虑，确定所要实现的功能后进行界面的设计，在这中间还要考虑如何可以更好的将功能及页面进行很好的结合，方便用户可以很容易明了的找到自己所需要的信息，还有系统平台后期的可操作性，通过对信息内容的详细了解进行技术的开发。
微信小程序的鲜花商城的开发利用现有的成熟技术参考，以源代码为模板，分析功能调整与微信小程序的鲜花商城管理的实际需求相结合，讨论了基于微信小程序的鲜花商城管理的使用。 关键词：微信小程序的鲜花商城；JAVA
Flower Mall Based on Spring Boot WeChat Applet Abstract With the rapid development of China's economy, people's demand for mobile phones is increasing, and various mobile software is also widely used. However, for mobile phone data information management, various software for mobile phones is also popular among users. The flower mall of WeChat applets is widely used by users, in order to facilitate users to manage the data information of the flower mall of WeChat applets at any time, A management system for a flower mall based on a WeChat applet has been developed.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b8010e1b1ea262796905c8c4f53dd93/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d68235f7d97f2e6458969b3f54e309e4/" rel="bookmark">
			信号与线性系统翻转课堂笔记8——周期信号的频谱
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		信号与线性系统翻转课堂笔记8——周期性信号的频谱 The Flipped Classroom8 of Signals and Linear Systems 对应教材：《信号与线性系统分析（第五版）》高等教育出版社，吴大正著
一、要点 （1，重点）周期信号频谱的概念及其物理意义；
（2，重点）周期矩形脉冲频谱的形状和特点，了解取样函数及其特点，掌握周期和脉冲宽度变化对周期矩形脉冲频谱的影响；
（3）频带宽度的概念及其在工程实际中的意义。
二、问题与解答 1、取样函数（也称为样本函数）是本课程中另外一个非常重要的信号。在MATLAB中，定义了一个sinc函数来表示取样函数，但是sinc函数的定义方式与教材对取样函数的定义方式略有区别。①请查阅资料以及MATLAB帮助文件，找出这两者定义的差别，并说明如果用sinc函数来求取样函数，应该怎么处理；②基于sinc函数，画出取样函数波形，并总结该函数波形的特点。
2、针对偶对称的周期矩形脉冲（教材图4.3-2），其中T和τ的值自定，利用MATLAB分别画出其单边和双边频谱（幅度谱和相位谱合二为一），单边谱的公式参见课件。①总结单边谱与双边谱的区别与联系，说明已知单边谱，如何画出双边谱；②如何理解双边谱中负频率的物理意义？③如果周期矩形脉冲左移或者右移（使得其不再偶对称），则分别会对其幅度频谱和相位频谱产生何种影响？此时能不能仍然采用幅度谱相位谱合二为一的方式绘制频谱图？
3、上一题中，改变周期矩形脉冲T和τ及其比值T/τ，会对频谱波形产生何种影响，利用MATLAB绘图举例进行分析，根据频谱的物理意义对所得结果进行解释（为什么会增大/减小信号中的高频/低频分量），并据此总结周期矩形脉冲时域脉宽与频谱带宽之间的关系、时域脉冲密度与频谱谱线密度之间的关系。
4、周期矩形脉冲信号的频带宽度是如何定义的？这种定义方式是否适用于任意的周期信号？脉冲宽度的变化对于周期矩形脉冲信号带宽有什么影响？这种影响对于分析和研究信号传输技术具有何种意义（信息是要依靠信号的变化来传输的，变化越快的信号，可以包含越大的信息量，从这个角度进行分析）？
5、
6、
傅里叶级数帕斯瓦尔恒等式的物理意义是什么？周期矩形脉冲信号频谱带宽范围内是否包含了全部的信号功率？
1、取样函数&amp;sinc函数 取样函数（也称为样本函数）是本课程中另外一个非常重要的信号。在MATLAB中，定义了一个sinc函数来表示取样函数，但是sinc函数的定义方式与教材对取样函数的定义方式略有区别。①请查阅资料以及MATLAB帮助文件，找出这两者定义的差别，并说明如果用sinc函数来求取样函数，应该怎么处理；②基于sinc函数，画出取样函数波形，并总结该函数波形的特点。
区别：
1、sinc函数是正孩基函数的缩写，sinc(X)=sin(pix)/(pix)
2、Sa函数是采样函数的缩写，Sa（X）=sin（X）/X
sinc函数和Sa函数之间相互转换：sinc(X)=Sa(pi*x)。
t=-3*pi:pi/100:3*pi; ft=sinc(t/pi); plot (t,ft); grid on; 特点：这是一个偶函数图像，自变量为0时采样函数的值是1，在自变量取pi的非零整数倍时为0，抽样函数在自变量趋近于无穷时函数值趋近于0。
2、单边谱和双边谱 针对偶对称的周期矩形脉冲（教材图4.3-2），其中T和τ的值自定，利用MATLAB分别画出其单边和双边频谱（幅度谱和相位谱合二为一），单边谱的公式参见课件。①总结单边谱与双边谱的区别与联系，说明已知单边谱，如何画出双边谱；②如何理解双边谱中负频率的物理意义？③如果周期矩形脉冲左移或者右移（使得其不再偶对称），则分别会对其幅度频谱和相位频谱产生何种影响？此时能不能仍然采用幅度谱相位谱合二为一的方式绘制频谱图？
T=2; %周期矩形脉冲周期为T tao=1/5; %脉宽为tao E=1; %脉冲高度为E omega=2*pi/T; %Ω=2π/T omega1=0:omega:70*pi; a=(2*E*tao/T).*sin(omega1*tao/2)./(omega1*tao/2); %公式1见PPT fudu1=abs(a); omega2=-70*pi:omega:70*pi; fudu2=(E*tao/T).*sin(omega2*tao/2)./(omega2*tao/2); %公式2见PPT subplot(2,1,1) %画图 stem(omega1,fudu1,'b.'); hold on plot(omega1,fudu1,'r-'); hold off xlabel('\omega1'); ylabel('幅度'); title('单边谱'); subplot(2,1,2) stem(omega2,fudu2,'b.'); hold on plot(omega2,fudu2,'r-'); hold off xlabel('\omega2'); ylabel('幅度'); title('双边谱'); 蓝色部分为公式1：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d68235f7d97f2e6458969b3f54e309e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f75741a4e79193a24385e01ab2a2350a/" rel="bookmark">
			Modbus RTU协议与S7 200 PLC通讯
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Modbus RTU功能码 二、功能码使用与解析实例 01功能码 –读线圈状态 主机发送：01 01 00 01 00 08 6C 0C
从机回复: 01 01 01 2F 10 54
主机解析：01 地址(设备ID)；
01 功能码； 00 01 代表查询的起始线圈地址，即从0001线圈开始查询。 00 08 查询线圈数量。 6C 0C 循环冗余校验。 从机解析：01 地址(设备ID)；
01 功能码； 01 代表后面数据的字节数。 2F 读取以0001线圈开始的8个线圈的状态。0x2F二进制为00101111，对应状态为1111 0100 10 54 循环冗余校验。 02功能码 –-读离散输入寄存器 功能：读离散输入寄存器，位操作，可读单个或多个，类似功能码0X01 03功能码 –-读保持寄存器的值 主机发送：01 03 00 01 00 01 D5 CA
从机回复: 01 03 02 00 01 79 84
主机解析：01 地址(设备ID)；
03 功能码； 00 01 代表查询的起始寄存器地址，即从0001寄存器开始查询。 00 01 查询寄存器数量。 D5 CA 循环冗余校验。 从机解析：01 地址(设备ID)；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f75741a4e79193a24385e01ab2a2350a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6095029653d11f3289cb9c3a44cbee35/" rel="bookmark">
			Kotlin委托的深入解析与实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 在Kotlin编程语言中，委托是一项强大的特性，它能够极大地简化代码，提高代码的可维护性。本文将深入探讨Kotlin中的委托机制，介绍其原理、具体使用方式以及实际应用场景。
委托的原理 委托是一种通过将实际工作委托给其他对象来实现代码重用的机制。在Kotlin中，委托通过关键字 by 来实现。我们将首先了解委托的基本原理，为后续的实例打下基础。
基本语法 Kotlin中的类可以通过关键字 by 委托给其他类。考虑以下示例：
interface Printer { fun printMessage(message: String) } class ConsolePrinter : Printer { override fun printMessage(message: String) { println(message) } } class MessageProcessor(printer: Printer) : Printer by printer fun main() { val consolePrinter = ConsolePrinter() val messageProcessor = MessageProcessor(consolePrinter) messageProcessor.printMessage("Hello, A风格!") } 在上述例子中，MessageProcessor 类通过 by 关键字将实际的打印操作委托给了 ConsolePrinter 类。这种方式使得代码更具灵活性，我们可以轻松地切换不同的打印实现，而不需要修改 MessageProcessor 类的代码。
具体使用示例 接下来，我们将通过实际的示例来演示Kotlin委托的具体使用方式。我们将使用委托来实现属性的延迟初始化，这是委托的一个常见用法。
class LazyProperty(initializer: () -&gt; Int) { val lazyValue: Int by lazy(initializer) } fun main() { val lazyProperty = LazyProperty { println("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6095029653d11f3289cb9c3a44cbee35/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/30/">«</a>
	<span class="pagination__item pagination__item--current">31/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/32/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>