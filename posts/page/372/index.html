<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/def945db318399fbc4747e7b044dcb16/" rel="bookmark">
			zookeeper中上传文件的内容 作为路径的值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 安装Solr 参考
# 目录 /root/solr wget http://archive.apache.org/dist/lucene/solr/8.1.1/solr-8.1.1.tgz tar -zxvf solr-8.1.1.tgz [root@hadoop2 cloud-scripts]# pwd /root/solr/solr-8.1.1/server/scripts/cloud-scripts 上传文件中的数据 参考
[root@hadoop2 cloud-scripts]# pwd /root/solr/solr-8.1.1/server/scripts/cloud-scripts # 上传配置文件 ./zkcli.sh -zkhost 172.31.234.62:2181,171.31.234.76:2182,172.31.234.97:2183 -cmd upconfig -confname myconf -confdir /root/solr/solr-8.1.1/server/solr/configsets/_default/conf/ ./zkcli.sh -zkhost 172.31.234.62:2181,171.31.234.76:2182,172.31.234.97:2183 -cmd upconfig -confname myconf -confdir /root/solr/solr-8.1.1/server/solr/configsets/sample_techproducts_configs/conf/ 上传文件 ./zkcli.sh -zkhost 172.31.234.62:2181,171.31.234.76:2182,172.31.234.97:2183 -cmd putfile /test_file.txt test.txt 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8b33f598e7e50dc6bc09251d64be77a/" rel="bookmark">
			学习笔记：光电耦合器PC817
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PC817中文资料 PC817是常用的线性光耦，广泛应用在测量仪器等电路之间的信号传输。常常在各种要求比较精密的功能电路中被当作耦合器件，具有上下级电路完全隔离的作用，相互不产生影响。前端与负载完全隔壁，增加安全性，减小电路干扰，简化电路设计。
特点：
1 电流传输比（CTR: MIN. 50% at IF=5mA， VCE=5V）
2 高隔离电压：5000V有效值
3 紧凑型双列直插封装。PC817为单通道光耦，PC827为双通道光耦，PC837为三通道，PC847为四通道光耦。
4 线性光耦元件
当输入端加电信号时，发光器发出光线，照射在受光器上，受光器接受光线后导通，产生光电流从输出端输出，实现“电-光-电”转换。普通光电耦合器只能传输数字信号（开关信号），不适合传输模拟信号‘线性光电耦合器是一种新型的光电隔离器件，能够传输连续变化的模拟电压或电流信号，这样随着输入信号的强弱变化会产生相应的光信号，从而使光敏晶体管的导通程度也不同，输出的电压或电流也随之不同。PC817光电耦合器不但可以起到反馈作用还可以起到隔离作用。
pc817主要参数：
光电耦合器
电流传输比：50%（最小值）
高隔离电压：5000V（有效值）
符合UL标准
极限参数
正向电流（ICEO）：50mA
峰值正向电流（ICE max）：1A
反向电压：6V
功耗：70mW
集电极发射极电压：35V
发射极集电极电压：6V
集电极电流：50mA
集电极功耗：150mW
总功耗：200mW
工作温度：－30℃ ～+100℃
集电极发射极饱和电压：0.1V（典型值）
截止频率：80kHz
电流传输比：50%～600%封装：DIP-4
封装
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5e3697bae5759105ce6bfc32375ac16/" rel="bookmark">
			Matlab求解二元一次方程组，结果分数转化小数输出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Matlab求解二元一次方程组
1560*10^(-9)x+y==1.433486002124
157010^(-9)*x+y==1.43324210451274
注意：将符号表达式的值转化为数值型用vpa（）函数
clear all; syms x y; [x y]=solve(1560*10^(-9)*x+y==1.433486002124,1570*10^(-9)*x+y==1.43324210451274); x=vpa(x)； y=vpa(y)； 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/922d3553e3026dac5ad79184a56dabeb/" rel="bookmark">
			检测二维数组内元素是否全相同
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		//检测二维数组内元素是否全相同
function isAllEqual(array) {
if (array.length &gt; 0) {
return !array.some(function (value, index) {
if(index &gt; 0){
return value[0] !== array[index-1][0] || value[1] !== array[index-1][1];
}
});
} else {
return true;
}
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c786d5541d6194fab982d11b15f4aab7/" rel="bookmark">
			HBase---如何将文本数据导入到HBase中
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、HBase中提前创建好表 首先根据文件的内容，创建好列簇
create 'customer',{NAME=&gt;'order'} 文件中的内容如下：
二、在HBase Shell外部输入命令 【注意：这里要指定列，并且文件路径为本地路径——Linux路径】
这里的 \ 代表 换行转义
hbase org.apache.hadoop.hbase.mapreduce.ImportTsv \ -Dimporttsv.separator=, \ -Dimporttsv.columns="HBASE_ROW_KEY,order:order_no,order:order_date" \ customer file:///home/vagrant/hbase_import_data.csv 执行完后，效果图：
三、查看 scan '表名' 数据就进来了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c07d287c864dee6aee3b3d6b98442f2/" rel="bookmark">
			PT1000 电桥测温
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
方案
原理图
电阻值测量
结论
前言 最近做了个温控项目，用到了PT1000温度传感器测温；
需求，±1℃误差；量程0~100℃；
方案 电桥差分放大方案；
原理图 电阻值测量 令 得
结论 T_VEXC 与单片机Vref同一电源供电；电阻箱模拟PT1000组织变化；
测量温度误差不大于0.5℃；符合设计预期；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c73b931c63058b3ac8f3a26a1ef38fee/" rel="bookmark">
			iOS 拖拽手势（UIPanGestureRecognizer）只做竖直/水平方向处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		拖拽手势提供的函数 函数描述open func translation(in view: UIView?) -&gt; CGPoint获取到的是移动后手指在相对坐标系内移动的距离open func setTranslation(_ translation: CGPoint, in view: UIView?)用于设置每次拖拽操作时视图的偏移量，状态切换至end时，要记得清零open func velocity(in view: UIView?) -&gt; CGPoint获得平移时的速度 解决思路 1.创建拖拽手势实例，并依附于视图
let v = UIView.init(frame: .init(x: 100, y: 300, width: 100, height: 100)) v.backgroundColor = .red let p = UIPanGestureRecognizer.init(target: self, action: #selector(handlePan(pan:))) v.addGestureRecognizer(p) 2.实现手势的回调方法
@objc func handlePan(pan: UIPanGestureRecognizer) { if pan.state == .changed || pan.state == .ended { let view = pan.view var viewRect = view?.frame let offset = pan.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c73b931c63058b3ac8f3a26a1ef38fee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1311876f9eea98a43b5d7cb427c47fa/" rel="bookmark">
			Cisco三层交换机的详细配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		**
本文适用于新手小白以及微微基础的同学来用于参考，实验是在Cisco Packet Tracer Student 进行，实验最终效果如图所示，所有命令配置与图中的一致。
使用到的机器型号为：五台电脑，一台服务器，三个普通交换机（2960型号），一个三层交换机（3560-24PS），两台普通服务器（2811）
文章目录 一、什么是三层交换机二、配置交换机步骤1.配置二层交换机2.配置三层交换机 3.配置两台路由器以及最后一台电脑 一、什么是三层交换机 1.三层交换机 = 三层路由+二层交换机
2.工作在OSI网络标准模型的第三层：网络层。
3.特点：一次路由，多次转发。
4.作用：三层交换机的作用是加快大型局域网内部的数据交换，所具有的路由功能也是为这目的服务的
二、配置交换机步骤 1.配置二层交换机 按照要求，我们首先需要配置好三个交换机的五个VLAN区域，方便后续通信，还需将F0/2配置为turnk端口。第一台交换机具体命令如下：
第一台交换机： en //进入特权模式 conf t //进入全局模式 vlan 10 vlan 20 vlan 30 vlan 40 vlan 50 //创建五个vlan区域 exit //退出 int f0/1 //进入F0/1 switchport access vlan 10 //将F0/1划分为VLAN 10 int f0/3 switchport access vlan 20 //将F0/3划分为VLAN 20 int f0/2 switchport mode trunk //将F0/2配置为trunk端口，为交换机与服务器之间的相联 第二台交换机： en conf t vlan 10 vlan 20 vlan 30 vlan 40 vlan 50 //创建五个vlan区域 exit //退出 int f0/1 //进入F0/1 switchport access vlan 30 //将F0/1划分为VLAN 30 int f0/3 switchport access vlan 40 //将F0/3划分为VLAN 40 int f0/2 switchport mode trunk //将F0/2配置为trunk端口，为交换机与服务器之间的相联 第三台交换机 en conf t vlan 10 vlan 20 vlan 30 vlan 40 vlan 50 //创建五个vlan区域 exit //退出 int f0/1 //进入F0/1 switchport access vlan 50 //将F0/1划分为VLAN 10 int f0/2 switchport mode trunk //将F0/2配置为trunk端口，为交换机与服务器之间的相联 至此，三台交换机配置完毕，我们开始三层交换机的配置
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a1311876f9eea98a43b5d7cb427c47fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50415e6f462bd4d61096ca2f2f975ba5/" rel="bookmark">
			AltiumDesigner 把PCB中选中的元器件放在一起
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法一 首先在原理图中选中要放在一起的元件 2.打开PCB，发现PCB中对应的元器件已经被选中
3）然后依次按快捷键：I L 元器件就会放在一个矩形中
方法二 首先在原理图中选中要放在一起的元件 2.此时PCB对应的元器件被选中
3.点击图中此处，在下拉框中选择点击一下Arrange Components Inside Area
4）查看效果
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2910522f0490a0134f5b3761843fd94c/" rel="bookmark">
			Linux查看docker容器日志后退出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通过logs指令查看docker容器的日志 docker logs -f -t --since="2021-07-02" --tail=20 docker_container_name --since : 此参数指定了输出日志开始日期，即只输出指定日期之后的日志。 -f : 查看实时日志 -t : 查看日志产生的日期 -tail=20 : 查看最后的20条日志。 docker_container_name : 容器名称 查看完毕后，ctrl+c即可退出
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3aac553423cc14137c4de171a8bd49c/" rel="bookmark">
			详解keras中的Mask机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一. Mask背景1.2 例子11.2 例子2 二. 原理三. 方式3.1 配置keras.layers.Embedding 层3.2 添加keras.layers.Masking层3.3 自定义 一. Mask背景 在NLP中，mask使用最为常见。在NLP中，许多句子都有着不同的长度，我们往往需要按照一定的长度, 对句子进行填补和截取操作。 一般使用keras.preprocessing.sequence包中的pad_sequences方法, 在句子前面或者后面补0. 但是这些零是我们不需要的, 只是为了组成可以计算的结构才填补的. 因此计算过程中, 我们希望用mask的思想, 既然所有样本现在都具有了统一长度，那就必须告知模型，数据的某些部分实际上是填充，应该忽略。这种机制就是遮盖（Mask）。
1.2 例子1 如图中所示，Hello world只有两个字符，而I am here有三个字符。因此在转化成list的时候，就需要在第一个list中加入0变成与第二个list相同长度。
1.2 例子2 这里用简单的向量来描述padding的原理。假设有一个长度为5的向量：
x=[1,0,3,4,5]
经过padding变成长度为8： x=[1,0,3,4,5,0,0,0]
当你将这个长度为8的向量输入到模型中时，模型并不知道你这个向量究竟是“长度为8的向量”还是“长度为5的向量，填充了3个无意义的0”。为了表示出哪些是有意义的，哪些是padding的，我们还需要一个mask向量（矩阵）：m=[1,1,1,1,1,0,0,0]
这是一个0/1向量（矩阵），用1表示有意义的部分(True)，用0表示无意义的padding部分(False)。
所谓mask，就是x和m的运算，来排除padding带来的效应。比如我们要求x的均值，本来期望的结果是：
a v g ( x ) = 1 + 0 + 3 + 4 + 55 5 = 12.6 avg(x)=\frac{1+0+3+4+55}{5}=12.6 avg(x)=51+0+3+4+55​=12.6
但是由于向量已经经过padding，直接算的话就得到：
a v g ( x ) = 1 + 0 + 3 + 4 + 55 + 0 + 0 + 0 8 = 7.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c3aac553423cc14137c4de171a8bd49c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00cfce979831547c04343161e3546d98/" rel="bookmark">
			cuda : 依赖: cuda-11-1 (＞= 11.1.0) 但是它将不会被安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系统：Ubuntu 20.04
Cuda：11.1
安装程序类型：deb(local)
最后一步出现问题：cuda : 依赖: cuda-11-1 (&gt;= 11.1.0) 但是它将不会被安装
解决依据：https://blog.csdn.net/u012911347/article/details/81191669
方案：
1. 安装aptitude-&gt; sudo apt-get install aptitude
2.将apt-get换成aptitude -&gt; sudo aptitude install cuda
3. 好多冲突，选择了Y，455替换了
4. 重启 -&gt; nvidia-smi
5. nvcc --version 显示版本号，成功
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c6d6e12a072d2e314af68ea14a0734c/" rel="bookmark">
			python编程练习之梯度下降法实例求解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是“梯度下降法” 首先，我们有一个可微分的函数。这个函数就代表着一座山。我们的目标就是找到这个函数的最小值，也就是山底。根据之前的场景假设，最快的下山的方式就是找到当前位置最陡峭的方向，然后沿着此方向向下走，对应到函数中，就是找到给定点的梯度 ，然后朝着梯度相反的方向，就能让函数值下降的最快！因为梯度的方向就是函数之变化最快的方向
所以，我们重复利用这个方法，反复求取梯度，最后就能到达局部的最小值，这就类似于我们下山的过程。而求取梯度就确定了最陡峭的方向，也就是场景中测量方向的手段。
单变量的微分，函数只有一个变量时
多变量的微分，当函数有多个变量的时候，即分别对每个变量进行求微分
梯度：
在单变量的函数中，梯度其实就是函数的微分，代表着函数在某个给定点的切线的斜率
在多变量函数中，梯度是一个向量，向量有方向，梯度的方向就指出了函数在给定点的上升最快的方向
梯度的方向是函数在给定点上升最快的方向，那么梯度的反方向就是函数在给定点下降最快的方向
数学公式：
解释：J是关于Θ的一个函数，我们当前所处的位置为Θ0点，要从这个点走到J的最小值点，也就是山底。首先我们先确定前进的方向，也就是梯度的反向，然后走一段距离的步长，也就是α，走完这个段步长，就到达了Θ1这个点
二、梯度下降法求极值问题 问题：
求
的极小值点
1、初始点：
2、学习率：λ
3、梯度计算：
4、初始值的梯度：
5、更新迭代公式：
6、重复并总结：
7、不断重复迭代过程
三、最小二乘法求线性回归问题（python编程） 定义数据及设置相关数值并进行线性回归
from sklearn import linear_model #可以调用sklearn中的linear_model模块进行线性回归 import numpy as np import matplotlib.pyplot as plt # 定义数据集的大小 即20个数据点 m = 20 # x的坐标以及对应的矩阵 X0 = np.ones((m, 1)) # 生成一个m行1列的向量，其值全是1 X1 = np.arange(1, m+1).reshape(m, 1) # 生成一个m行1列的向量，也就是x1，从1到m X = np.hstack((X0, X1)) # 按照列堆叠形成数组，其实就是样本数据 # 对应的y坐标 Y = np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c6d6e12a072d2e314af68ea14a0734c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da0639fd31b4331429c810c5fcf284c5/" rel="bookmark">
			quartus设计D触发器仿真
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、创建工程二、创建原理图文件三、创建波形文件四、直接调用D触发器仿真 环境：quartus19.1精简版与配套modelsim与组件 一、创建工程 工程路径与名字
选择空项目
直接下一步
选择自己需要的芯片
直接下一步
这是创建工程的详细信息，点完成
这是刚刚创建好工程的页面
二、创建原理图文件 利用组件创建出下列原理图（nand2 input output）
启动综合分析
这里会提示你保存原理图文件
没有出现红色提示就是没错，可以进行下一步
查看硬件电路图（用rtl viewer）
目前我还没懂这一步的意义所在，但是的确每次都需要这样做
三、创建波形文件 插入信号
选中clk那一行，点击时钟信号设置
将Q Q_n设置为0
选中D输入，设置输入
选中对应部分点上面的0或1或者右键设置选中区域的值
这也会提示保存波形文件，保存即可
点击功能仿真
功能仿真结果
时序仿真
结果
四、直接调用D触发器仿真 1、创建工程
同上
2、创建原理图文件
同上
创建如下原理图
元件搜索dff,即D触发器，再加两个input和一个output
3、启动分析与综合
同上
4、创建波形文件
同上
设置D输入信号
功能仿真
时序仿真
如果出现
Run the Fitter, followed by the Timing Analyzer, before running the EDA Netl
意思是前提要运行2个其他的东东，到底是什么东西没弄懂
不过找到了解决办法
①先点击这个
②再点击这个，最后到波形文件的页面点击是时序仿真就行了
可以比较上述两种方式仿真，只要电路图没错，得出结果都一样
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aeb81dcee6488aed33aa9dfc67bab58b/" rel="bookmark">
			SpringBatch自定义Excel文件写入器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一:场景需求
工作中需要对数据库中的数据进行报表导出,所以用到了poi包里的excel工具.为了适配springbatch的reader–&gt;processor–&gt;writer模式,决定将excel写入的方式改造成类似org.springframework.batch.item.file.FlatFileItemWriter的方式,可以很好地利用springbatch的一些特性(比如分片读取并写入以提高效率).更优雅的实现Excel的数据写入;
实现功能:
使用mybatis读取一千条数据,经processor对每一条数据处理后,用ExcelItemWriter写入到Excel中.
二:代码实现
主要类
ExcelAggregator 聚集器:处理每一行数据的处理接口
ExcelLineAggregator 聚集器行处理器实现类
ExcelCellStyleCallback 单元格格式回调接口
ExcelHeaderCallback 表格头信息回调接口
ExcelItemWriter 主要的Excel写入器
1.ExcelAggregator
public interface ExcelAggregator&lt;T&gt; { Object[] aggregate(T item); } 2.ExcelLineAggregator
/** * @author: m * @date: 2020/12/02 * @Description: Excel的行处理器 */ public class ExcelLineAggregator&lt;T&gt; implements ExcelAggregator&lt;T&gt; { private FieldExtractor&lt;T&gt; fieldExtractor = new PassThroughFieldExtractor&lt;T&gt;(); /** * Public setter for the field extractor responsible for splitting an input * object up into an array of objects.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aeb81dcee6488aed33aa9dfc67bab58b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc6b9e55693195ce3844d83d2af6423f/" rel="bookmark">
			Spring RMI反序列化漏洞分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 概况ReadObject流程Jndi注入POC分析server部分client部分恶意类部分整体的攻击流程 概况 漏洞的入口在于Spring-tx-xxx.jar中的JtaTransactionManager重写了ReadObject方法，该方法中的UserTransactionName可控，且初始化UserTransactionName的时候调用了Jndi的lookup方法，导致 Jndi注入的问题。
ReadObject流程 首先是重写的ReadObject函数
private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException { ois.defaultReadObject(); this.jndiTemplate = new JndiTemplate(); this.initUserTransactionAndTransactionManager(); this.initTransactionSynchronizationRegistry(); } 跟入initUserTransactionAndTransactionManager()函数
该函数的作用为初始化UserTransactionName和TransactionManger
protected void initUserTransactionAndTransactionManager() throws TransactionSystemException { if (this.userTransaction == null) { if (StringUtils.hasLength(this.userTransactionName)) { this.userTransaction = this.lookupUserTransaction(this.userTransactionName); this.userTransactionObtainedFromJndi = true; } else { this.userTransaction = this.retrieveUserTransaction(); if (this.userTransaction == null &amp;&amp; this.autodetectUserTransaction) { this.userTransaction = this.findUserTransaction(); } } } 从代码中可以看出如果传入的UserTransactionName不为空则会调用lookupUserTransaction，函数的作用为通过Jndi地址去寻找UserTransaction实例
protected UserTransaction lookupUserTransaction(String userTransactionName) throws TransactionSystemException { try { if (this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc6b9e55693195ce3844d83d2af6423f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb63535f1db00482bec4c56dc2591507/" rel="bookmark">
			7-6 个税查询 (15 分)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 7-6 个税查询 (15 分) 本题目要求读入一人全年工资收入，计算其一年所需纳税额（税率见下图），保留两位小数。 注意：每月有5000元免税额。
输入格式:
输入一年工资数。
输出格式:
输出其工资和应纳税额。
输入样例:
96000 输出样例:
salary=36000.00,tax=1080.00 #include"stdio.h" int main(){ double sum,cnt,tax; scanf("%lf",&amp;sum); if(sum&lt;60000) printf("salary=%.2f,tax=0.00",sum); else{ sum=sum-60000; cnt=sum; if(sum&lt;=36000) tax=sum*0.03; else if(sum&lt;=14400) tax=sum*0.1-2520; else if(sum&lt;=300000) tax=sum*0.2-16910; else if(sum&lt;=420000) tax=sum*0.25-31920; else if(sum&lt;=660000) tax=sum*0.30-52920; else if(sum&lt;=960000) tax=sum*0.35-85920; else tax=sum*0.45-181920; printf("salary=%.2f,tax=%.2f",cnt,tax); } return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2bc3e83414cbedd435df96cbd0c9e78/" rel="bookmark">
			windows 10目标文件夹访问被拒绝（没有权限）或者（你需要来自XXX的权限才能对此文件夹进行更改 ）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简单说明：详情往下看 文件夹右键-属性-安全-添加-高级-立即查找-选择"everyone"-确定-确定-完全控制打勾
以上操作意思是该文件夹添加"everyone"用户所有控制权~everyone的意思就是所有人~当然你也可以添加你自己计算机的管理员权限为完全控制~
windows 10 删除文件夹出现问题： 你需要来自XXX的权限才能对此文件夹进行更改
你需要来自SYSTEM的权限才能对此文件夹进行更改
解决流程：
右击打开此文件夹属性，如下图，点击高级按钮
出现下图，点击更改：
继续，在输入框中输入e，右击按钮检查名称
出现下图，并确认
勾选替换子容器和对象的所有者，应用并确认：
重新打开该文件夹属性，并选择高级
添加：
选择主体：
在输入框中输入e，右击按钮检查名称
勾上完全控制，勾上仅将这些权限应用到此容器中的对象和/或容器 并确定：
点击启用继承button，后会变成禁用继承，勾选箭头，应用并确认：
完成！重新点击删除：
成功：
转载请看原创：你需要来自XXX的权限才能对此文件夹进行更改 win10
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e362d203293613237880f4b80acf2e13/" rel="bookmark">
			idea git commit message 提交消息总是显示以前的记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Setting -&gt; Version Control -&gt; Commit Dialog -&gt; Clear initial commit message
取消勾选即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95fd1e58367232f7ebf387633f152df8/" rel="bookmark">
			循环的三种形式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		循环的三种形式
for 循环：
For（开始位置；循环条件；更改条件）{
循环体}
嵌套for循环：
1.外循环执行1次，内循环执行N次
2.外循环控制行，内循环控制列
While循环：
先判断在执行，如果没满足判断条件，一次也不会执行
While（循环条件）{
循环体}
先判断在执行
Do while循环：
Do{
循环体}while（循环条件）
相同点：都可以解决重复执行的问题
不同点：
For ： 要求：知道开始位置，要循环多少次，变化的规律
While： 要求： 知道循环的条件，满足就执行，不满足就不执行
Do while： 要求：知道循环的条件，保证循环体，最少执行1次
死循环：
本质是因为循环条件永远成立—必须配合break结束循环！！！
死循环形式：
For（int i= 1；i&gt;0 ;i++）{}
For( ; ; ){}
While(true){}
break和continue 概述：
都是用来 结束循环结构的
break：立刻结束
continue：结束这次循环，还能下次循环
break和continue之后不能再出现代码，否则是不可到达的代码
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7bc4c48706b4bd5fc6fdb8680cf7406/" rel="bookmark">
			Linux中消息队列的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是消息队列 消息队列，Unix的通信机制之一，可以理解为是一个存放消息（数据）容器。将消息写入消息队列，然后再从消息队列中取消息，一般来说是先进先出的顺序。可以解决两个进程的读写速度不同（处理数据速度不同），系统耦合等问题，而且消息队列里的消息哪怕进程崩溃了也不会消失。
二、消息队列常用函数和使用流程 消息队列 msgget()、msgsend()、msgrcv()、msgctl()
最简单的消息内存的使用流程
①ftok函数生成键值
②msgget函数创建消息队列
③msgsnd函数往消息队列发送消息
④msgrcv函数从消息队列读取消息
⑤msgctl函数进行删除消息队列
三、消息队列常用函数介绍 1.ftok函数生成键值 每一个消息队列都有一个对应的键值（key）相关联（共享内存、信号量也同样需要）。
头文件：#include&lt;sys/ipc.h&gt;
函数声明： key_t ftok(const char *path ,int id);
参数说明：
path：一个已存在的路径名 id：0~255之间的一个数值，代表项目ID，自己取 返回值：
成功返回键值（相当于32位的int）。出错返回-1
示例：
key_t key = ftok( “/tmp”, 66);
2.msgget函数创建消息队列 头文件：#include&lt;sys/msg.h&gt;
函数声明： int msgget(key_t key,int flag);
参数说明：
key：为ftok生成的键值 flag：为所需要的操作和权限，可以用来控制创建一个消息队列。 IPC_CREAT:创建新的消息队列; IPC_EXCL:与IPC_CREAT一同使用，表示如果要创建的消息队列已经存在，则返回错误; IPC_NOWAIT:读写消息队列要求无法满足时，不阻塞。返回值： 调用成功返回队列标识符,否则返回-1; 在以下两种情况下，将创建一个新的消息队列：
1、如果键的值是IPC_PRIVATE。
2、或者键的值不是IPC_PRIVATE，并且键所对应的消息队列不存在，同时标志中指定IPC_CREAT。
返回值：
成功返回消息队列ID；出错返回-1
示例：
int id = msgget(key,IPC_CREAT|IPC_EXCL|0666);创建一个权限为0666（所有用户可读可写，具体查询linux权限相关内容）的消息队列，并返回一个整形消息队列ID，如果key值已经存在有消息队列了，则出错返回-1。
int id = msgget(key,IPC_CREAT|0666);创建一个权限为0666（所有用户可读可写，具体查询linux权限相关内容）的消息队列，并返回一个消息队列ID，如果key值已经存在有消息队列了，则直接返回一个消息队列ID。
3.msgsnd函数往消息队列发送消息 头文件：#include&lt;sys/msg.h&gt;
函数声明： int msgsend(int msgid, const void *msg_ptr, size_t msg_sz, int msgflg);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f7bc4c48706b4bd5fc6fdb8680cf7406/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be4cc674deb3a81540e6c2c3704797e6/" rel="bookmark">
			矩阵快速幂的原理和构造技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		矩阵和快速幂是两个大家都耳熟能详的概念，我们在学习矩阵快速幂这一概念之前，先稍微复习一下这两个概念。
矩阵乘法 这是矩阵乘法的定义，不难发现，它的大小由前面的行数和后面的列数共同决定，也就是说，矩阵乘法并不符合乘法交换律。这也限制了，如果我们要对一个矩阵反复相乘，这个矩阵应该是一个方阵。至于这点的应用会在下文提到，大家只需要先熟悉一下矩阵乘法的规则。
快速幂 快速幂算法应该也是一个很经典的算法。它的的核心思想就是每一步都把指数分成两半，而相应的底数做平方运算。这样不仅能把非常大的指数给不断变小，所需要执行的循环次数也变小，而最后表示的结果却一直不会变。
单独说这两个知识其实没什么关系，但是有时候我们需要对一个矩阵进行多次相乘，也就是求幂。这时候我们可以把快速幂和矩阵乘法相结合，快速的求出一个矩阵的幂次。
至于这种算法的应用，这里先暂时按下不表，先用代码把这个算法简单实现一下。
为了方便，我们这里直接把矩阵封装成类，所有运算在类里定义。
struct Matrix{ static const int N=15; ll a[N][N]; Matrix(ll e=0){ for (int i=1;i&lt;=n;i++)for (int j=1;j&lt;=n;j++)a[i][j]=e*(i==j); } Matrix mul(Matrix A,Matrix B){ Matrix ans(0); for (int i=1;i&lt;=n;i++){ for (int j=1;j&lt;=n;j++){ for (int k=1;k&lt;=n;k++){ ans.a[i][j]=(ans.a[i][j]+A.a[i][k]*B.a[k][j])%mod; } } } return ans; } Matrix ksm(Matrix A,ll b){ Matrix ans(1); while (b){ if (b&amp;1)ans=mul(ans,A); A=mul(A,A);b&gt;&gt;=1; } return ans; } }tmp; 这个算法的复杂度级别是O（n3logn）
接下来给大家介绍这个算法除了求解完全的板子题以外，还有什么其他作用。
递推式的求解。 提到递推式，斐波那契数列是绕不开的一环。所以我们先从斐波那契数列出发，介绍矩阵快速幂的一种用法。
斐波那契数列的递推规律，F(n)=F(n-1)+F(n-2)；
我们要构造转移矩阵B，不难发现。我们只要让转移矩阵乘递推后项可以成为递推前项就可以了。这样我们就可以把问题转化为转移矩阵的幂次和常数相乘的问题
也就是这张图说的求出转移矩阵的n-1次方然后F（n）实际上就等于转移矩阵的n-1次方的第一行乘初始矩阵的第一列。F(0)=0;所以答案就是转移矩阵的n-1次方的第一行第一列。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be4cc674deb3a81540e6c2c3704797e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbe1aeb6ef0768b8ec9c905c18d98238/" rel="bookmark">
			fairygui简单使用（unity）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文主要是引导怎么从fairygui页面ui编辑到unity的过程，如果想详细的那种，最好下载一个官方案例，里面都有详细的教程。不过这个对于新手来说还是挺好的（因为我刚开始以为是自己创建代码，自己写）
先去官网下载一个gui编辑器：
这是API函数：
创建一个组件：
这个组件就是一个界面ui
开始拼凑界面，所需要的操作需要到官网去查使用方法：
然后将需要用到的东西设置为导出：会在ui右下角出现一个红色小点点
设置为导出后，点击文件的发布设置：
发布界面更具自己需求来进行发布：
打包发布，最好发布到Unity工程的Resources目录，点击全部发布即可
如果是已经创建了unity项目，这个只是新加的，那么可以选择单个发布
允许发布代码：会自动生成ui代码，（最好使用这个方法，简单，后面只需要修改界面参数就行了）
允许发布代码之后，右键创建一个fairgui：
在uipanel上面选择你自己在fairgui里面创建的包和ui组件名字：
ps：如果没有，说明你没打包发布代码或者没有导出
然后在自己挂上去你自己修改的脚本代码：下图为我添加的脚本
using System.Collections; using System.Collections.Generic; using UnityEngine; using FairyGUI; public class test1scr : MonoBehaviour { GList list; //GetChild获取子组件 private void Awake() { //加载test1的包，因为我发布到的是resources/UI UIPackage.AddPackage("UI/test1"); } void Start() { //获取组件下的ui（为main这个组件）的list组件 list = GetComponent&lt;UIPanel&gt;().ui.GetChild("list").asList; //数据源处理（这是一个委托,所以必须有参数int和GObject） list.itemRenderer = listitems; //list数据多少设置 list.numItems = 20; } void listitems(int index, GObject obj) { GButton item = (GButton)obj; //n5为我的text名字 item.GetChild("n5").asTextField.text = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fbe1aeb6ef0768b8ec9c905c18d98238/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1cc0a17ca8eab333291dd3e12df5a3f7/" rel="bookmark">
			变量类型及其在jvm中的存储
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 最近实习生招聘面试，喜欢问jvm的存储结构，这个大家基本都能回答出来（八股文背诵的嫌疑），但是问了几个具体的case，就很多同学都回答不出来或者很模糊。
所以同学们真的了解数据类型在jvm中的存储么？
举例如下：
int a1 = 1; Integer a2 = 1; Integer a3 = 128; Integer a4 = 128; System.out.println(a1==a2); System.out.println(a3==a4); String s1 = "china"; String s2 = new String("china"); 一、基础知识 1.1、变量的分类
成员变量：定义在类中方法(代码块)外的变量。
使用static修饰的成员变量： 静态成员变量位于方法区中(详细请看下文)，是类级别的。
未使用static修饰的成员变量：实例成员变量位于堆空间中(详细请看下文)，是对象级别的。
局部变量 ：除成员变量外都是局部变量位于方法所在的栈帧中(详细请看下文)，是方法级别的。
1.2、JVM的存储结构
栈：位于通用RAM（随机访问存储器），方法执行时创建方法栈帧，存放基本数据类型的变量数据和对象的引用。但对象本身不存放在栈中，而是存放在堆（new出来的对象）或者常量池中（字符串常量对象存放在常量池中）
堆：存放所有new出来的对象
静态域（方法区）：存放静态成员（static定义的）
常量池（方法区）：存放字符串常量、基本类型常量（public static final)
二、局部变量 2.1、基本数据类型
在方法调用时执行到该变量的初始化语句时，直接将该变量的值保存到该方法的栈帧中。
int a1 = 1;
2.2、引用类型
在方法调用时，将引用的堆内存中的值的地址保存到该变量到的栈内存中。对于基本类型的包装类型（符合常量池区间）和String，保存在方法区的常量池。 note：变量名称存储在栈中，变量的值存储要么在常量池，要么在堆中。
Integer a2 = 1; //1存储在常量池 Integer a3 = 128; //128由于超过了常量池的范围，相当于new Integer(128), 存储在堆中 Integer a4 = 128; String s1 = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1cc0a17ca8eab333291dd3e12df5a3f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/543ef0e8548cdc94d6d80ff9d81e3534/" rel="bookmark">
			Javascript实现俄罗斯方块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JS实现俄罗斯方块 视频教程：
JavaScript开发俄罗斯方块
代码地址：
Tetris-based-on-JS
1.初始化布局 我们设置Game为中介者类
你会发现我们的Game.js文件的最外层是用IIFE包裹起来的，因为我们需要知道实际工作中都是多个类进行并行开发的，由于为了上生产，会将代码进行打包部署，也就是将所有的js文件打包为个js文件，如果没有IIEF会造成作用域和命名的冲突，所以我们用IIFE隔离作用域。
(function () { window.Game = function () { this.row = 20; this.col = 12; // 初始化 this.init(); }; Game.prototype.init = function () { // 初始化大表格 var $table = $("&lt;table&gt;&lt;/table"); // 渲染表格 for (var i = 0; i &lt; this.row; i++) { // 创建tr var $tr = $("&lt;tr&gt;&lt;/tr&gt;"); for (var j = 0; j &lt; this.col; j++) { // 创建td var $td = $("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/543ef0e8548cdc94d6d80ff9d81e3534/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8754fc675b128519ea9d38d1456a5936/" rel="bookmark">
			Android App Widget创建步骤 带配置界面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文来自http://blog.csdn.net/chenshaoyang0011 转载请申明文章出处！
Android通知系统是它的一大特色，而其中，AppWidget是其中一个亮点。在开发应用的中，很多时候可以为其添加一个AppWidget显示在桌面中，及时方便的与用户进行
交互。这里就简单的熟悉一下开发一个AppWidget的流程吧。
想要在应用中创建一个AppWidget，至少需要以下几样东西：
1、需要创建一个AppWidgetProviderInfo，来描述AppWidget的元数据。2、需要实现一个自己的AppWidgetProvider对AppWidget进行更新等操作。2、需要布局文件来
描述AppWidget的布局。
那么，下面就开始创建一个AppWidget吧。
一、在AndroidManifest.xml中声明一个AppWidget
首先我们需要在AndroidManifest.xml中声明AppWidgetProvider。格式如下：
[java] view plain copy
&lt;receiver android:name="MyAppWidgetProvider" &gt; &lt;intent-filter&gt; &lt;action android:name="android.appwidget.action.APPWIDGET_UPDATE" /&gt; &lt;/intent-filter&gt; &lt;meta-data android:name="android.appwidget.provider" android:resource="@xml/my_appwidget_info" /&gt; &lt;/receiver&gt; 可以看出AppWidgetProvider实际上就是一个BroadcastReceiver，它接收特定的Broadcast。&lt;meta-data&gt;标签描述了AppWidget所使用的元数据，android:resource则声明了定义元数据的xml文件的位置。
二、添加AppWidgetProviderInfo元数据
AppWidgetProviderInfo描述了AppWidget的本质特性，例如，AppWidget更新的周期，最小的宽度、长度，所使用的布局文件是什么，以及添加AppWidget需要启动的
configuration Activity等。我们需要在XML中来定义AppWidgetProviderInfo对象，这个XML文件应该保存在res/xml文件夹下。下面是一个范例：
[java] view plain copy
&lt;appwidget-provider xmlns:android="http://schemas.android.com/apk/res/android" android:minWidth="294dp" android:minHeight="72dp" android:updatePeriodMillis="86400000" android:previewImage="@drawable/preview" android:initialLayout="@layout/example_appwidget" android:configure="com.example.android.MyAppWidgetConfigure" android:resizeMode="horizontal|vertical"&gt; &lt;/appwidget-provider&gt; &lt;appwidget-provider&gt;需要使用这个标签来定义AppWidgetProviderInfo。下面对范例中使用到的属性做下说明。
minWidth、minHeight定义了AppWidget需要占据的最小的空间。
updatePeriodMillis定义了大概多久AppWidget需要更新一次，这里定义的只是一个大概的时间，系统不能做出精确的保证。
previewImage定义了在用户选择AppWidget时做现实的图标。
initialLayout定义了AppWidget所使用的布局文件。
configure定义了AppWidget在添加的时候需要启动的configuration Activity 用于执行配置的工作。
resizeMode定义了缩放模式。
三、创建AppWidget所使用的布局文件
在创建AppWidget时必须创建一个布局文件，为其提供布局描述。AppWidget创建视图时，需要根据RemoteViews来创建。而出于效率等因素的考虑，很多控件在
RemoteViews中是被支持的。以下列出能在RemoteViews中使用的UI控件：
layout : FrameLayout , LinearLayout , RelativeLayout
widget : AnalogClock , Button , Chronometer , ImageButton , ImageView , ProgressBar , TextView , ViewFlipper , ListView , GridView , StackView , AdapterViewFlipper
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8754fc675b128519ea9d38d1456a5936/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/199c949792e54c34be374e32511472e7/" rel="bookmark">
			acwing-802.区间和(离散化,整数二分,前缀和)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述
假定有一个无限长的数轴，数轴上每个坐标上的数都是 0。
现在，我们首先进行 n 次操作，每次操作将某一位置 x 上的数加 c。
接下来，进行 m 次询问，每个询问包含两个整数 l 和 r，你需要求出在区间 [l,r] 之间的所有数的和。
输入格式
第一行包含两个整数 n 和 m。
接下来 n 行，每行包含两个整数 x 和 c。
再接下来 m 行，每行包含两个整数 l 和 r。
输出格式
共 m 行，每行输出一个询问中所求的区间内数字和。
数据范围
−109≤x≤109 ,
1≤n,m≤105,
−109≤l≤r≤109,
−10000≤c≤10000
输入样例
3 3
1 2
3 6
7 5
1 3
4 6
7 8
输出样例
8
0
5
题解代码
#include&lt;bits/stdc++.h&gt; using namespace std; const int N = 300010; int a[N],pre[N]; vector&lt;int&gt; alls; typedef pair&lt;int,int&gt; pii; vector&lt;pii&gt; add,query; int find(int x){ int l = 0, r = alls.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/199c949792e54c34be374e32511472e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/205677d82c14015c6c89b09d18d69b24/" rel="bookmark">
			2021-04-07
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.自我介绍
我是西安工业大学计科专业的一名学生，极度小白。喜欢刷B站，知乎～希望自己一年后可以熟练掌握自己所学的知识。
2. 学习目标
坚持每天敲代码～熟悉C/JAVA
3. 如何学习编程
看书，看视频 ，刷题。
每天敲1-2小时代码。
4. 每周花费在编程上的时间
10-15个小时
5. 最想进的IT公司
B站
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f9e6c2e1719a67e1bdeb4c3813161fb/" rel="bookmark">
			Mysql 修改索引
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.添加PRIMARY KEY（主键索引） mysql&gt;ALTER TABLE table_name ADD PRIMARY KEY ( column )
2.添加UNIQUE(唯一索引) mysql&gt;ALTER TABLE table_name ADD UNIQUE ( column )
3.添加INDEX(普通索引) mysql&gt;ALTER TABLE table_name ADD INDEX index_name ( column )
4.添加FULLTEXT(全文索引) mysql&gt;ALTER TABLE table_name ADD FULLTEXT ( column)
5.添加多列索引 mysql&gt;ALTER TABLE table_name ADD INDEX index_name ( column1, column2, column3 )
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44fbcb67439d9610944d98b6c7d75454/" rel="bookmark">
			Async的错误处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Async/await作为generator+自动执行器+promise的语法糖，他能够用同步写法写异步代码，同时他捕获错误的方式也十分简单：promise.catch和try-catch。
promise.catch async function foo() { let res = await 1; throw new Error('my error'); } foo().catch(e =&gt; { console.log('catch捕获', e); }); 由于async会返回一个promise，那么对于该promise我们可以链式调用catch，用于捕获抛出的错误。
try-catch async function foo() { try { let res = await 1; throw new Error('my error'); } catch (e) { console.log('catch捕获', e); } } foo(); async函数是同步写法，因此我们也可以用同步代码的错误捕获方式去捕获异步错误：在async中直接用try-catch包裹代码。
需要注意的是，await后面即便是一个promise，并且promise里抛出错误，也是能够用try-catch捕获的。之间我们分析过，promise内的错误是内部处理了，不会抛到外面，但是加了await后却在外面捕获，具体原因没有找到，猜测是await关键字做了一些内部处理。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ecba1a488bd6f4bb29d9ef557eb2338b/" rel="bookmark">
			什么是BGP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.基本概念什么是BGPBGP路由协议的特点IBGP水平分割规则BGP的路由器号(Router-ID)BGP工作原理BGP分类 1.基本概念 自治系统，指的是在同一个组织管理下、使用相同策略的设备的集合；
不同AS通过AS号区分，AS号取值范围1-65535，其中64512-65535时私有AS号；
BGP是一种实现自治系统AS之间的路由可达，并选择最佳路由的矢量性协议。
BGP特点：
BGP能提供承载大批量的路由信息，能够支撑大规模网路
BGP使用TcP作为其传输层协议（监听端口号为179），提高了协议的可靠性
BGP是外部路由协议用来在AS之间传递数据，对稳定性要求非常高
BGP的对等体之间必须逻辑上连通，并进行tcp连接，目的端口179，本地端口任意
BGP对等体和IGP对等体不同，BGP对等体（peer）是指使用TCP建立连接的两端，而非与IGP同概念的直连邻居，只要TCP能够建立连接并不一定需要直连
BGP本身只负责只控制路由，数据转发依然靠静态或IGP路由
BGP支持无类别域间路由CIDR
路由更新时，BGP只发送更新的路由，大大减少了BGP传播路由所占用的带宽
BGP是一种增强的距离矢量路由协议，从设计上避免环路的发生
AS之间：BGP通过携带AS_PATH信息标记途径的AS，带有本地AS号的路由将被丢弃，从而避免域间产生环路
AS内部：BGP在AS内学到的路由不会再通告给AS内的BGP邻居，避免了AS内产生环路
什么是BGP BGP——边界网关协议
是一种实现自治系统AS之间的路由可达，并选择最佳路由的距离矢量路由协议。
什么是AS
自治系统（Autonomous System，AS）：指在同一个组织管理下、使用相同策略的设备的集合。
不同的AS通过AS号区分的，AS号的取值范围165535.其中6451265535是私有AS号。IANA负责AS号的分发。
早期发布的三个版本分别是BGP-1（RFC1105）、BGP-2（RFC1163）、BGP-3（RFC1267），1994年开始使用BGP-4（RFC1771）、2006年之后单薄IPv4网络使用的版本是BGP-4（RFC427），其他网络使用版本是MP-BGP（RFC4760）
BGP路由协议的特点 1.BGP使用TCP作为其传输层协议(监听端口号为179)，提高了协议的可靠性。
2.BGP是外部路由协议，用来在AS之间传递数据，对稳定性要求非常高。因此用TCP协议的高可靠性来保证BGP协议的稳定性。
3.BGP的对等体之间必须逻辑上连通，并进行TCP连接。目的端口号为179，本地端口号任意。
4.BGP对等体和IGP对等体不同，BGP对等体(Peer)是指使用TCP建立连接的两端，而非与IGP同概念的直连邻居，只要TCP能够建立连接并不一定需要直连。
5.BGP本身只负责控制路由，数据转发依然靠静态或IGP路由。
6.BGP支持无类别域间路由CIDR。
7.路由更新时，BGP只发送更新的路由，大大减少了BGP传播路由所占用的带宽，适用于在Internet上传播大量的路由信息。
8.BGP是一种增强的距离矢量路由协议，从设计上避免了环路的发生。
9.AS之间:BGP通过携带AS_Path信息标记途经的AS，带有本地AS号的路由将被丢弃，从而避免了域间产生环路。
10.AS内部:BGP在AS内学到的路由不会再通告给AS内的BGP邻居，避免了AS内产生环路。
11、BGP提供了丰富的路由策略，能够对路由实现灵活的过滤和选择。
12、BGP提供了防止路由振荡的机制（路山衰减），有效提高了Internet网络的稳定性。
13、BGP易于扩展， 能够适应网络新的发展（ipv4单/组播、vpv4单/组插）。主要是通过TLV进行扩展。
IBGP水平分割规则 如图C从E学习到的IBGP路由,由于水平分割规则的限制,不能够传递给B路由器,这将导致B无法学习到F通告的BGP路由。但是为了解决这个问题，E可以通过BGP连接，与B直接形成逻辑连接，达到全网连通的目的。
BGP的路由器号(Router-ID) 1、BGP的Router-ID是一个用于标识BGP设备的32位值,通常是IPv4地址的形式,在BGP会话建立时发送的Open报文中携带。对等体之间建立BGE会话时,每个BGP设备都必须有唯一的Router ID,否则对等体之间不能建立BGP连接。
2、BGP的**Router-ID在BGP网络中必须是唯一的,**可以采用手工配置,也可以让设备自动选取。缺省情况下, BGP选择设备上的Loopback接口的IPv4地址作为BGP的Router-ID,如果设备上没有配置Loopback接口,系统会选择接口中最大的IPv4地址作为BGP的Router-ID.一旦选出Router-ID,除非发生接口地址删除等事件,否则即使配置了更大的地址,也保持原来的Router-ID.
BGP工作原理 BGP对等体的建立、更新和删除等交互过程主要有5种报文、6种状态机和9个原则
BGP的报文:（5种包）
1、Open报文:
Open是TCP连接建立后发送的第一个报文。
用于协商BGP对等体的各项参数,主要包括BGP版本(V4) 、AS号等信息,建立BGP对等体连接。
2、Update报文:
用于在对等体之间交换路由信息。
连接建立后,有路由需要发送或者路由变化时,发送Update通告对端可达或者撤销路由信息及路径属性。
3、Notification报文:
用于中断BGP连接。
当BGP在运行中发现错误时,发送Notification报文通告BGP对端,随后与之相关的邻居关系将被关闭。
4、Keepalive报文:
用于保持BGP连接。(保活作用)
定时发送Keepalive报文以保持BGP对等体关系的有效性。响应收到的正确的Open报文
5、Route-refresh报文:
用于在改变路由策略后软复位（相当于刷新重载）
BGP路由表请求对等体重新发送路由信息，只有支持路由刷新(Route-refresh)能力的BGP设备会发送和响应此报文。
BGP状态机:（6种状态）
BGP对等体的交互过程中存在6种状态机：空闲（Idle）、连接（Connect）、活跃（Active）、Open报文已发送（openSent）、Open报文已确认（OpenConfirm）和连接已建立（Established) 。在BGP对等体建立的过程中，通常可见的3个状态是: Idle、Active和Established。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ecba1a488bd6f4bb29d9ef557eb2338b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13a695eba43579d4b58cd3b864e812e6/" rel="bookmark">
			Linux 无stdio.h等文件的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、引言 安装好Mint Linux后，使用gcc来编译.c文件，却发现各自.h文件缺失，在此记一下解决办法。
二、解决方案 安装build-essential包即可。
参考 【linux】error: stdio.h: No such file or directory_郭老二-CSDN博客build-essential软件包简介 | darkmi’s blog 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ddc31915c9f9887c054e7d74597a77c4/" rel="bookmark">
			java定义一个方法，返回整数数组的元素最大值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java定义一个方法，返回整数数组的元素最大值 /** * 定义一个方法 * 返回整数数组的元素最大值 */ public class Test23 { public static int maxArray(int[]arr){ int max = arr[0]; for (int i = 0; i &lt; arr.length; i++) { if (max&lt;arr[i]){ max = arr[i]; } } return max; } public static void main(String[] args) { int[] arr = {1,2,3,4,5,6,7,8,9}; int max = maxArray(arr); System.out.println(max); } } 执行代码如下：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ecf1f0acc85e1915eaa2a9fb9844b4e6/" rel="bookmark">
			记一个await的错误抛出问题.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 function t1() { return new Promise((resolve, reject) =&gt; { throw new Error('my error'); // resolve('11111'); }); } try { t1(); } catch (e) { console.log('无await的try-catch捕获'); //无法捕获 } async function foo() { try { let res = await t1(); } catch (e) { console.log('有await的try-catch捕获'); //可以捕获 } return Promise.resolve(3); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50642b2313127420ae73ccdf438cf417/" rel="bookmark">
			LIO_SAM的坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.在安装gtsam的时候遇到下述链接的错误：
https://blog.csdn.net/weixin_44023934/article/details/113539840
解决办法也是按照上述的换成版本为GTSAM4.00，就没问题了。
按照上面的做法编译是可以完成了，但是在加载的时候，节点lio_sam_imuPreintegration和lio_sam_mapOptmization
加载不起来，其他两个节点没问题，GTSAM也只有在上述两个节点中用到了，于是考虑是还是GTSAM版本的问题，又换回GTSAM4.02版本，虽然此次还是遇到之前的错误，但是参考下述链接解决了：
https://blog.csdn.net/weixin_44401286/article/details/1086256940
错误出现的原因：因为ROS找到的Eigen版本与gtsam找到的版本不一致造成的，那么解决问题的办法就是使它们一致，即需要使/usr/local/include、/usr/include 这两个文件夹下的eigen版本一致。
直接操作：sudo cp -r /usr/local/include/eigen3* /usr/include
或者sudo cp -r /usr/local/include/eigen3* /usr/include/eigen3
(具体哪个操作管用了，哈哈哈不是很清楚，上述链接的博文中也没说清楚，我自己都试了一下)
现在加载launch文件就没问题了！！！！！
但是播放数据后，lio_sam_mapOptmization节点报错。师弟电脑上跑就没问题，但是在我电脑上就有问题，最后在一个新系统中没有自己安装Eigen，直接采用的系统的版本，安装了GTSAM4.02版本，编译就没问题，就可以正常运行了。所以总结根源还是eigen的问题！！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/539906096dd8826c48efd38bfd934205/" rel="bookmark">
			[MongoDB高可用方案]之副本集(PSS形式)的项目实践二
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 第1章 基本环境和基本优化1.1 准备的服务器1.2 项目实践架构1.3 操作系统环境1.4 操作系统优化 第2章 服务器上部署MongoDB软件及服务2.1 事先生成密钥(不是证书哈)2.2 软件及实例部署前的规划说明2.3 所有服务器部署MongoDB软件2.4 vm-7-201上部署mongodb实例2.5 vm-7-202上部署mongodb实例2.6 vm-7-203上部署mongodb实例 第3章 MongoDB副本集的初始化以及验证3.1 副本集的初始化3.2 创建两管理帐号3.3 各节点集合状态3.4 Navicat客户端工具连接副本集3.5 Navicat客户端上产生测试数据3.6 Primary上删除之前的测试数据3.7 其实还应该为业务创建相关帐号 ？ 第1章 基本环境和基本优化 1.1 准备的服务器 主机名IP地址操作系统角色vm7-201.host.com10.4.7.201/24CentOS 7.9primary 优先级10,初始化时让其成为主(在这个节点上进行初始化),宕服恢复后不抢占主;vm7-202.host.com10.4.7.202/24CentOS 7.9secondary 优先级1,有机会参与new primary的选举;vm7-203.host.com10.4.7.203/24CentOS 7.9secondary 优先级1,有机会参与new primary的选举; 1.2 项目实践架构 三个节点的优先级不一样（一个是最高，另外两个相同），初始化时无论在哪个节点上进行初始化，vm7-201上的mongodb都会成为primary，因为它的优先级最高。当primary宕服后，会随机从另外两个secondary上选举出一个成为new primary，因为它们的优先级是一样的。当宕服的primary恢复后，会抢占primary。因为它的优先级最高。
规划的架构(部署的时候)
primary宕服选举new primary
primary宕服恢复后
1.3 操作系统环境 ### 操作系统版本 [root@vm7-200 ~]# cat /etc/redhat-release;uname -r;uname -m CentOS Linux release 7.9.2009 (Core) 3.10.0-1160.el7.x86_64 x86_64 ### 网卡及配置 [root@vm7-200 ~]# ip addr show ens33 2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:8d:d6:eb brd ff:ff:ff:ff:ff:ff inet 10.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/539906096dd8826c48efd38bfd934205/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12a8dde6fe2bd97f6b2726f6bf7eb693/" rel="bookmark">
			jupyter Notebook显示“No module named numpy” 但anaconda已安装numpy 解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		jupyter Notebook显示“No module named numpy” ，但anaconda经检查已安装numpy。
参考知乎作者的解决方法， 可能原因是使用的python和anaconda的python非同一个。
解决方法：
在jupyter notebook中输入
import os os.sys.executable，查找到正在使用的python的路径（如下图）
然后打开anaconda prompt，如下图输入路径并安装numpy.
（图中安装的是pandas,改成numpy即可）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eddfba6c808019a30efc9f5f697fd012/" rel="bookmark">
			微信支付中的 JSAPI 支付方式,根据code码查询用户的openid
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 微信支付中的 JSAPI 支付方式,根据code码查询用户的openid /** * 根据code查询openID * * @param code 微信用户的 code码 (前台获取后传入) * @param appID 微信公众号的唯一标识(在微信公众号的管理页面可以查看) * @param secret 开发者秘钥 (公众号管理页面获取) * @return */ public String getOpenidByCode(String code,String appID,String secret) { //页面获取openId接口 String getopenid_url = "https://api.weixin.qq.com/sns/oauth2/access_token"; String param = "appid=" + appID + "&amp;secret=" + secret + "&amp;code=" + code + "&amp;grant_type=authorization_code"; //向微信服务器发送get请求获取openIdStr String openIdStr = HttpRequest.sendGet(getopenid_url, param); JSONObject json = JSONObject.parseObject(openIdStr);//转成Json格式 String openId = json.getString("openid");//获取openId return openId; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e05adc41d1200fcf04e5063069288a1/" rel="bookmark">
			亚马逊ABA数据关键词递归函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一种通过bestseller一个ASIN进行反查关键词的方法，
如图 是英国站2021-3-27后台 ABA数据，根据其中之一的ASIN进行反差客户搜索Search Term 关键词，由于一个关键词下有三个ASIN，
大概逻辑思路为：
1，通过一个ASIN反查的多个关键词，再通过得到的关键词 获取其他ASIN，
2，通过获取的AISN再次反查关键词，
以此类推，写一个递归函数，函数调用自己，这样理论上就获取了同类产品的所有Search Term 。
二、函数实现效果
将数据导入到pandas中。
输入一个ASIN B07RKJDK65,可以获取其他相关联的263个ASIN，
总计有1万4千多条数据，包含了5012个Search Term 关键词
也可以大致判断出 该相关的ASIN 主要是针对 camera
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0266f1bb20b23c496fa2db68e39c5f0/" rel="bookmark">
			百度云盘电影无字幕，如何寻找字幕加字幕？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		习惯了直接在百度云盘在线看电影，突然一部电影没有字幕，日文我是一点也听不懂，没办法只能一顿操作猛如虎，最终实现带字幕的电影。
1.首先先寻找相应的字幕：https://subhd.tv/
该网站字幕挺多真是可以下载
2.下载完之后使用百度云盘直接上传到相应电影的文件夹（重点：把字幕的名字和电影的文件名字改为一致，不然可能识别不到）
有的百度云盘有智能字幕有的无法有字幕，这个根据自己的云盘版本和情况而定
3.把相应的字幕进行UTF8 编码，使用txt 或者notepad 都可以，这个根据自己的字幕文件情况，本人下载SRT file 4.如果百度云无法在线识别播放，还可以选择下载下来，放在一个文件夹里，名字一致，然后使用播放器播放
下图为电影以及三种不同语音的字幕文件
使用播放器可以实现字幕直接加载成功！
其他经验静待大家总结！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/606508ab63dbf438845b91a45ca024a8/" rel="bookmark">
			BERT模型调用源码分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://blog.csdn.net/wshzd/article/details/89639392
转
使用BERT的注意事项：需要自己下载BERT源码，然后把解压后的文件夹放到跟目录
使用BERT的目的是：为了获取最后的模型返回向量（就是4）步骤的输出）
使用BERT模型的步骤是：
1）首先加载并且恢复模型的配置参数、模型参数；
2）调用函数convert_single_example生成模型所需要的数据，其实就是input_ids、input_mask、segment_ids；
3）把第二步生成的三个List输入到modeling.BertModel中对应的参数位置input_ids、input_mask、token_type_ids；
4）最后根据NLP任务选择输出的方法是model.get_sequence_output()还是model.get_pooled_output()，其中model.get_sequence_output()的返回数据格式是[batch_size, seq_length, embedding_size]，使用使用seq2seq或者ner；而model.get_pooled_output()输出为
#!/usr/bin/python
-- coding:utf-8 -- import tensorflow as tf
from bert import modeling
from bert import tokenization
import os
一、加载BERT模型 这里是下载下来的bert配置文件 bert_config = modeling.BertConfig.from_json_file(“chinese_L-12_H-768_A-12/bert_config.json”)
创建bert的输入 input_ids=tf.placeholder (shape=[64,128],dtype=tf.int32,name=“input_ids”)
input_mask=tf.placeholder (shape=[64,128],dtype=tf.int32,name=“input_mask”)
segment_ids=tf.placeholder (shape=[64,128],dtype=tf.int32,name=“segment_ids”)
创建bert模型 model = modeling.BertModel(
config=bert_config,
is_training=True,
input_ids=input_ids,
input_mask=input_mask,
token_type_ids=segment_ids,
use_one_hot_embeddings=False # 这里如果使用TPU 设置为True，速度会快些。使用CPU 或GPU 设置为False ，速度会快些。
)
#bert模型参数初始化的地方
init_checkpoint = “chinese_L-12_H-768_A-12/bert_model.ckpt”
use_tpu = False
获取模型中所有的训练参数。 tvars = tf.trainable_variables()
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/606508ab63dbf438845b91a45ca024a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7efe2340ee49b0b01c43079358b361b2/" rel="bookmark">
			伺服电机恒扭矩与恒功率输出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		恒扭矩应该是指速度增加时输出的扭矩不变而功率增大，不是指负载增加时输出的扭矩不变。
同样型号的伺服当然参数是一样的，但是你说的300W伺服就可能有多种型号，由功率不能决定最大输出扭矩，由型号来决定。仔细看下伺服的型号是不是一样的。
就我所接触到的伺服电机都是额定扭矩，即不作扭矩伺服时，其输出扭矩为一恒值，额定功率/额定角速度，当伺服电机运行速度超过额定转速时，其输出扭矩会下降！
伺服有两个运作区间，一个是恒功率区，一个恒扭矩区。一般来讲，50Hz以下是属于恒扭矩区，50Hz以上是属于恒功率区。恒扭矩区，说明伺服在此区间内，输出扭矩是恒定不变的。
买一台伺服驱动带恒扭矩控制功能。 就可以可以通过设定恒扭矩也可以通过通讯方式或者模拟量输出方式显示恒扭矩
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1fef0b90b8663e8b3934b3188450841/" rel="bookmark">
			yii2 oracle 自增字段,yii2 oracle 原生sql分页
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		$sql_list = "SELECT ID, FID, INSID,
FLIGHTNO, DEPNAME, ARRNAME,
to_char(DEPDATE,‘yyyy-MM-dd HH24:mi‘) as DEPDATE,
CHECKID,CERTNAME,CERTTYPE, CERTNO, MOBILE, PRODUCTNAME, PRICE, TOTAL,
ETN,
DEP,ARR,
PAYSTATUS,OSTATUS,
to_char(CREATE_TIME,‘yyyy-MM-dd HH24:mi‘) as CREATE_TIME FROM wx_checkin_insure
where 1=1 and {$time_condition} {$condition_sql}";
$dataProvider = new SqlDataProvider([
‘sql‘ =&gt; $sql_list,
‘params‘ =&gt; [‘:status‘ =&gt; 1],
‘totalCount‘ =&gt; $total,
‘sort‘ =&gt; [
‘attributes‘ =&gt; [
‘age‘,
‘name‘ =&gt; [
‘desc‘ =&gt; [‘CREATE_TIME‘ =&gt; SORT_DESC],
],
],
],
‘pagination‘ =&gt; [
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1fef0b90b8663e8b3934b3188450841/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5824f1d1ba4ef767b619260819b33d64/" rel="bookmark">
			vscode如何debug
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vscode基本的debug操作就不讲了，讲一点进阶的设置。
debug的时候，很容易发现，如果函数调用的是创建对象的方法，那么debug将无法进入。
我一直以为这是vscode不如pycharm的地方，一直到我发现了下面的设置。
只需要在设置里面，添加这一条语句，即可进入调用对象的方法，进行debug.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd2c61baeb45bb2f556b944e19077412/" rel="bookmark">
			深度学习基础——使用keras全连接实现mnist
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述：
一，数据集介绍：
Mnist数据集分为两部分，分别含有60000张训练图片和10000张测试图片，图片内容就是0-9的数字。
每一张图片包含28*28个像素。
注：对于mnist数据集在keras的datasets里面存在直接导入即可，第一次可能需要下载有点慢。
二，使用全连接层实现mnist数据集的分类
1.导入需要的模块
# 常用的科学计算库 import numpy as np # 导入我们所用到的mnist数据集 from keras.datasets import mnist # 导入所用到的序贯模型 from keras.models import Sequential # 导入用到的全连接层和激活函数层 from keras.layers import Dense, Activation # 使用优化器RMSprop from keras.optimizers import RMSprop # 把标签向量化 from keras.utils import np_utils 2.导入数据和数据预处理
对于深度学习网络的过程就是数据获取，数据处理，模型创建与训练，模型测试与评估，模型预测，所以先要对数据做些必要的预处理，像归一化，滤波之类的。
# x shape(60000, 28*28) y shape(10000, ) (x_train, y_train), (x_test, y_test) = mnist.load_data() # 数据预处理 X_train = x_train.reshape(x_train.shape[0], -1) / 255 # normalize X_test = x_test.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd2c61baeb45bb2f556b944e19077412/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e96b18ee6d12f5e14c42df4c082a54c5/" rel="bookmark">
			【PTA】计算全班学生C&#43;&#43;课程的总成绩和平均成绩 (10 分)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 注意：
因为自定义了构造函数，是要有参数的，所以最后为了输出sum要定义参数为0的对象。
#include&lt;iostream&gt; using namespace std; class Student { int grade; static int sum; public: Student(int a) { sum=sum+a; } static void dis() { cout&lt;&lt;sum&lt;&lt;endl&lt;&lt;sum/5; } }; int Student::sum=0; int main() { int a; for(int i=0;i&lt;5;i++) { cin&gt;&gt;a; Student s(a); } Student s(0); s.dis(); return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/deb2018c49aa660a6d7bee6cedcf4c1c/" rel="bookmark">
			＜select＞下拉选择框
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下拉菜单&lt;select&gt;项，分组:
&lt;select name=”course”&gt; &lt;option&gt;课程选择&lt;/option&gt; &lt;optgroup label=”1.DOM基础”&gt; &lt;option value=”1.1”&gt;1.1文档树&lt;/option&gt; &lt;option value=”1.2”&gt;1.2节点操作&lt;/option&gt; &lt;/optgroup&gt; &lt;/select&gt; 创建选项:&lt;option value=’1.2’&gt;1.2节点操作&lt;/option&gt;
var option = Document.createElement(‘option’)
option.value = ‘1.2’;
option.textContent = ‘1.2节点操作’;
或者new Option(‘1.2节点操作’ , ’1.2’);
添加选项:
var option = new Option(‘1.0概述’ , ‘1.0’)
opt11.insertAdjacentElement(option,’beforeBegin’)
或者select.add(option , opt11)
删除选项:
opt12.parentNode.removeChild(opt12)
或者select.remove(2)
select级联下拉选择器
&lt;form name=”course”&gt; &lt;select name=”chapter”&gt; &lt;option&gt;请选择章目录&lt;/option&gt; &lt;/select&gt; &lt;select name=”section”&gt; &lt;option&gt;请选择节目录&lt;/option&gt; &lt;/select&gt; &lt;/form&gt; &lt;script&gt; var chapters = [ { text:’1.DOM基础’ , value:’1’ } , { text:’2.事件模型’ , value:’2’ } ] var sections = { 1:[ { text:’1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/deb2018c49aa660a6d7bee6cedcf4c1c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63814dfc0ddfc0405757359ec4f64bca/" rel="bookmark">
			用VMware Workstation开启虚拟机时显示“此主机支持 AMD-V，但 AMD-V 处于禁用状态.......” 的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在用VMware安装centos时，创建的虚拟机开启失败，显示如下：
解决办法：
重启电脑，在重启过程中长按F2，找到
“VirtualizationTechnology”选项，更改选项设置为Enable，接着按下F10保存设置。（界面鼠标不可用，仔细对应下方键盘的功能）
启动电脑打开VMware开启虚拟机即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0c066f650fd7f67cebcf1f86b9c7c29/" rel="bookmark">
			C#中的ORM框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 什么是ORM ORM：对象关系映射（Object Relational Mapping，简称ORM，或O/RM，或O/R mapping)
用于实现面向对象编程语言里不同类型系统的数据之间的转换
ORM是通过使用描述对象和数据库之间映射的元数据，将程序中的对象与关系数据库相互映射
ORM可以解决数据库与程序间的异构性，比如：在C#中我们使用string表示字符串，而Oracle中可使用varchar2，MySQL中可使用varchar，SQLServer可使用nvarchar。
如果没有ORM我们原始代码如下：
LR_Error pLR_Error = new LR_Error() { ErrorNum = Convert.ToInt32(dr[Table_LR_Error.T_LR_Error_F_ID]), GZBM = dr[Table_LR_Error.T_LR_Error_F_GZBM].ToString(), ParentPath = dr[Table_LR_Error.T_LR_Error_F_ParentPath].ToString(), FileExist = dr[Table_LR_Error.T_LR_Error_F_FileExist].ToString(), }; 2. 目前代码中的ORM都有哪些 2.1 C#中的ORM框架 SqlSugar (国内)Dos.ORM (国内)Chloe (国内)StackExchange/Dapper (国外)Entity Framework (EF) (国外)NHibernate (国外)ServiceStack/ServiceStack.OrmLite (国外)linq2db (国外)Massive (国外)PetaPoco (国外) 2.1.1 SqlSugar SqlSugar是国人开发者开发的一款基于.NET的ORM框架，是可以运行在.NET 4.+ &amp; .NET CORE的高性能、轻量级 ORM框架，众多.NET框架中最容易使用的数据库访问技术。
特点：
开源、免费国内开发者开发、维护；支持.NET Core；支持主流数据库，如：SQL Server,MySql,Oracle,Sqlite等；维护更新及时 2.1.2 PetaPoco PetaPoco：轻量的POCO对象和数据库映射的ORM框架。
特点：
开源、免费 2.1.3 linq2db linq2db也是一款快速、轻量、类型安全的POCO对象和数据库映射的ORM框架。从构架上来说，linq2db是对比如：Dapper、PetaPoco这个的微ORM的进一步封装，但它不像Entity Framework那样笨重。它没有实现状态跟踪，需要自己处理实体的状态更改等。
2.1.4 Dos.ORM Dos.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e0c066f650fd7f67cebcf1f86b9c7c29/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/652d39ed36cc0d79db3a1cd703aa7509/" rel="bookmark">
			qml CheckBox的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 CheckBox { id:checkBox1 x: change_butn.x y: change_butn.y+change_butn.height+ 40 text: qsTr("在此路点处停止") checked: false onCheckedChanged: { if(checkBox1.checked === false){ console.log("Now is false")//console.log()是很多好的调试qml的方式，在QT creator的Application Output栏输出 } else{ console.log("Now is true") } } } 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/371/">«</a>
	<span class="pagination__item pagination__item--current">372/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/373/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>