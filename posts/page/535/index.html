<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e78e055b7bb666b7c459b3e608dc861d/" rel="bookmark">
			Unity 自动打包 Part2—构建IPA文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.介绍
2.Unity代码
3. ipa打包脚本—build.sh
4.打包脚本推荐
5.Feature 2017.5.13 打包上传
6.邮件通知
1.介绍 文章介绍的是unity打包xcode工程完毕后，开启terminal执行打包脚本。
xcode 8.1+，unity5.5+ ， 脚本适用于mac系统。
2.Unity代码 打包完毕最后，调用Buildipa()。
public static string ProjectPath(){ string currentDir = Application.dataPath; int index = currentDir.LastIndexOf ("/"); currentDir = currentDir.Remove (index); index = currentDir.LastIndexOf ("/"); currentDir = currentDir.Remove (index); return currentDir; } public static string XcodePath(){ return ProjectPath () + "/Unity_IOS";//'Unity_IOS'替换为你的xcode工程导出的文件夹名称 } /* 此代码的功能: 打开terminal，执行buildios.sh "osascript" 是apple script，osascript可以主动打开一个terminal，并且在终端显示构建IPA的Log 当然你也可以直接调用shell，下方有例子。我不用shell是因为shell是在后台执行，我看不到详细Log */ public void Buildipa() { Process myCustomProcess = new Process(); myCustomProcess.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e78e055b7bb666b7c459b3e608dc861d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa650c7cd614105665288dd7ddc96286/" rel="bookmark">
			把排序数组转化为高度最小的搜索二叉树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		把排序数组转化为高度最小的搜索二叉树 题目描述： 给一个排序数组（从小到大），将其转换为一棵高度最小的排序二叉树。
样例 给出数组 [1,2,3,4,5,6,7], 返回
4 / \ 2 6 / \ / \ 1 3 5 7 解题思路： 二叉搜索树是左子树的值比根结点小，根结点的值比右子树小的树（假设左右子树都存在的话）。因此利用递归以及二分的思想，把给定的排序数组找到中间值给根结点，中间值前面的给左子树，后面的给右子树，以此类推，当左子树的值比右子树大的时候，递归终止。 代码实现： class Solution {
public:
/**
* @param A: A sorted (increasing order) array
* @return: A tree node
*/
TreeNode *sortedArrayToBST(vector&lt;int&gt; &amp;A) {
// write your code here
if(A.size()==0) return NULL;
else {
return def(A,0,A.size()-1);
}
}
TreeNode* def(vector&lt;int&gt;&amp;A,int left,int right){
if(left&gt;right) return NULL;
int mid=(left+right)/2;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa650c7cd614105665288dd7ddc96286/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b26b726aba21c76ea640a991069c2e7/" rel="bookmark">
			tf.cond 与 tf.control_dependencies 的控制问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题引入 在搜索tf.cond的使用方法时，找到了这样的一个问题：
运行下面的一段tensorflow代码：
pred = tf.constant(True) x = tf.Variable([1]) assign_x_2 = tf.assign(x, [2]) def update_x_2(): with tf.control_dependencies([assign_x_2]): return tf.identity(x) y = tf.cond(pred, update_x_2, lambda: tf.identity(x)) with tf.Session() as session: session.run(tf.initialize_all_variables()) print(y.eval()) 从代码上看，tf.cond经过判断pred的值对x进行更新。但实际上无论在pred = Ture 还是 False，输出的结果都是2，都是pred = tf.constant(True)的情况。
Confused by the behavior of tf.cond
这是怎么回事呢？
顺序执行 先不进行解释，有人在回复中给出了一个可以正确运行的代码，看一下有什么区别：
pred = tf.placeholder(tf.bool, shape=[]) x = tf.Variable([1]) def update_x_2(): with tf.control_dependencies([tf.assign(x, [2])]): return tf.identity(x) y = tf.cond(pred, update_x_2, lambda: tf.identity(x)) with tf.Session() as session: session.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b26b726aba21c76ea640a991069c2e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc3b6628ee82d9144101c4f1686f77ac/" rel="bookmark">
			二叉树的路径和
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		二叉树的路径和 问题描述： 给定一个二叉树，找出所有路径中各节点相加总和等于给定目标值 的路径。
一个有效的路径，指的是从根节点到叶节点的路径。
样例
给定一个二叉树，和 目标值 = 5:
1 / \ 2 4 / \ 2 3 返回：
[ [1, 2, 2], [1, 4] ] 解题思路： 根据前序遍历的思路，利用局部变量的性质，将某条路径上的从根结点到叶子结点的所有结点的值插入到向量中，迭代此向量，若加和等于所给的目标值的值，则把此向量插到另外一个双重向量中，遍历所有的路径，返回双重向量即可。
代码实现： class Solution {
public:
/**
* @param root the root of binary tree
* @param target an integer
* @return all valid paths
*/
vector&lt;vector&lt;int&gt;&gt; binaryTreePathSum(TreeNode *root, int target) {
// Write your code here
vector&lt;vector&lt;int&gt; &gt;paths;
vector&lt;int&gt;path;
vector&lt;int&gt;::iterator it;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc3b6628ee82d9144101c4f1686f77ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a01dd280106ad4660c179180ff0bd7b4/" rel="bookmark">
			【Python】datetime间的比较
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.string转datetime
#字符串转datetime dt = datetime.datetime.strptime('2017-04-19 00:42:44','%Y-%m-%d %H:%M:%S') 2.datetime转string
#datetime转字符串 str = dt.strftime("%Y-%m-%d-%H") 3.datetime的比较 &gt;&gt;&gt; dt1 = datetime.datetime.strptime('2017-04-18 00:40:00','%Y-%m-%d %H:%M:%S') &gt;&gt;&gt; dt2 = datetime.datetime.strptime('2017-04-18 00:20:00','%Y-%m-%d %H:%M:%S') &gt;&gt;&gt; print(dt1 - dt2) 0:20:00 &gt;&gt;&gt; print(dt2 - dt1) -1 day, 23:40:00可以看到，当用较小的时间减较大的时间时，得出的是-1天，23时40分。而不是-20分。 4.datetime比较结果的判断
&gt;&gt;&gt; diff = dt2 - dt1 &gt;&gt;&gt; print(diff) -1 day, 23:40:00 &gt;&gt;&gt; print(diff.days) -1 &gt;&gt;&gt; print(diff.seconds) 85200即比较时要用diff.days比较，小于0则前者较小。 5.具体相差秒数
&gt;&gt;&gt; diff.days * 86400 + diff.seconds -1200 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ddfea823370a20ff66f86f3bef6cc3c/" rel="bookmark">
			【Java】深入理解JVM学习笔记（三） —— GC收集器和内存分配
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		判断对象是否存活 引用计数算法 很多判断对象是否存活的方式就是引用计数算法：给对象添加一个引用计数器，每当一个地方引用它，计数器+1；引用失效，计数器-1。
任何时刻计数器为0的对象是不可能再被使用的。
Java虚拟机没有使用主流的引用计数法管理内存。主要原因是难以解决对象之间相互循环引用的问题
classA.instance = classB classB.instance = classA classA和classB已经不可能再被访问，但是classA和classB互相引用对方，导致计数器永远不可能是0，导致GC无法回收两个对象
可达性分析算法 通过一系列称为”GC Roots”对象作为起始点，从这些节点向下搜索，搜索过的路径称为引用链。
当一个对象的GCRoots没有任何引用链相连时，则证明该对象不可用。
在java中可作为GCRoots对象的是
虚拟机栈（栈帧本地变量表）引用的对象方法区中类属性引用对象方法区中常量引用对象本地方法栈（JNI）中引用对象 引用 Java引用分类(又上到下引用关系依次减弱)
强引用 必须存在的对象类似ObjectA objA = new ObjectA()软引用 有用但非必须的对象在发生内存溢出后，可进行二次回收弱引用 非必须对象无论当前内存是否足够，都会回收掉只被弱关联对象虚引用 是否存在不会对生存时间对其影响 生存或者死亡 判断一个对象死亡，至少经历两次标志过程：如果对象进行可达性分析，GCRoot没有相连的引用链，那么被第一次标记进行筛选；筛选的条件是是否有必要进行finalize()方法；对象没有覆盖finalize()方法或者已经被虚拟机调用过finalize()方法，则该对象没必要销毁；如果这个对象有必要执行finalize()方法，会将它放置在F-Queue队列中，并在稍后由一个虚拟机自动执行、低优先级的Finalizer线程去执行；GC稍后会对F-Queue中的对象进行二次标记
如果对象需要拯救自己不被回收。只要重新与引用链的任何一个对象重新关联为止（例如.this)
注意：自救的机会只能使用一次；一个对象的finalize方法最多只被系统调用一次
private static FinallyProperty escapeGC = null; @Override void finalize() throws Throwable{ super.finalize(); FinallyProperty.escapeGC = this; } 回收方法区 永久代的垃圾回收主要是2个部分:废弃变量和无用的类
废弃变量：与Java堆中的回收类似；例如.没有任何一个地方引用常量池的”abc”字面量，这时发生了内存回收；这个”abc”会被清理出常量池无用的类需要满足的3个条件 java堆中不存在该类的任何实例加载该类的ClassLoader已被回收无法在任何地方通过反射访问该类的方法 垃圾收集算法 标记-清除 在回收之前，首先标志出需要回收的对象，在标志完成后统一回收所有标志对象 后面的算法都是基于”标记-清除”算法的改进
该算法的主要缺点 1. 效率低下：产生过多内存碎片 2. 空间占用过多
复制算法 解决”标记-清除”算法效率问题
将内存划分为容量相等的2个部分，每次只使用其中一块。当这块内存使用完毕，将还存活的对象复制在另一块上面。然后把已使用的空间一次性清理掉。
每次对整个半区进行回收，而不讨论内存碎片等复杂情况，只需移动堆顶指针、按顺序分配内存即可。
标志-整理算法 复制收集算法在对象存活率过高时进行复制操作，影响效率。
根据老年代特点，提出了标志-整理算法；标志过程和标志-清除的过程一样。整理：让所有存活对象向一端移动，然后直接清理掉边界以外的内存
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ddfea823370a20ff66f86f3bef6cc3c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c40b2fada66513d57164265ef69bedb9/" rel="bookmark">
			操作系统进程调度先来先服务FCFS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一，实验的流程图 二，实验代码 注：本代码主要来自豆丁，加入本人的部分修改。。 //本FCFS是用不带都结点的链表完成。当然也可以用其他数据结构 #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; typedef struct PCB //定义进程控制块 { char ID[3]; //进程号 char name[10]; //进程名 char state; //运行状态 int arrivetime; //进程到达时间 int servicetime; //进程服务时间 int starttime; //进程开始时间 int finishtime; //进程完成时间 float turnaroundtime; //进程周转时间 float weightedturnaroundtime; //进程带权周转时间 struct PCB *next; //指向下一个进程的指针 }pcb; int time; //计时器 int n; //进程个数 pcb *head=NULL,*p,*q; //进程的指针 void run_fcfs(pcb *p1) { time=p1-&gt;arrivetime&gt;time?p1-&gt;arrivetime:time; p1-&gt;starttime=time; printf("\n现在时间是%d,开始云行作业%s\n",time,p1-&gt;name); time+=p1-&gt;servicetime; p1-&gt;state='T'; p1-&gt;finishtime=time; p1-&gt;turnaroundtime=p1-&gt;finishtime-p1-&gt;arrivetime; p1-&gt;weightedturnaroundtime=p1-&gt;turnaroundtime/p1-&gt;servicetime; printf("ID 到达时间 开始时间 服务时间 完成时间 周转时间 带权周转时间\n"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c40b2fada66513d57164265ef69bedb9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5896f6e5ac2574424e04702dc94e4e9/" rel="bookmark">
			cmake编译opencv指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
cmake编译opencv指南 用包管理器安装 查看opencv相关的包执行安装编译安装 为什么编译安装下载源码编译脚本执行编译脚本、解决3rdparty下载编译后的设定-环境变量mac下的compile.sh脚本其他问题 cmake编译opencv指南 用包管理器安装 比如ubuntu下是apt-get，mac下是brew。（windows下或许用nuget？）以ubuntu下为例。
查看opencv相关的包 aptitude search opencv 执行安装 发现有很多包。不妨安装绝大多数：
sudo apt-get install libopencv-* sudo apt-get install opencv-data python-opencv 编译安装 为什么编译安装 opencv有些功能放在opencv_contrib中了，即便用包管理器安装了opencv_contrib，有些包还是不能用，一定要自行把opencv和opencv_contrib一起编译。
下载源码 依然以ubuntu16.04为例。
到opencv官网下载。或者用git：
mkdir -p ~/gitwhat #自行建立的目录 cd ~/gitwhat git clone https://github.com/opencv/opencv --depth=1 #depth表示只下载最新commit的代码，减少下载量。 git clone https://github.com/opencv/opencv_contrib --depth=1 cd opencv vim compile.sh #cmake编译参数很多，写到文件中方便些 如果这里要切换版本，那么执行git的切换分支即可。比如指定3.4版：
git branch #查看本地分支，发现之后一个master分支 git branch -r #查看远程分支，发现有个origin/3.4 git checkout -b 3.4 origin/3.4 #切换到远程分支，并且本地分支起名为3.4 对于opencv_contrib也可以这么切换，只不过opencv有2.4版，opencv_contrib没有2.4版
编译脚本 Linux(例如Ubuntu16.04)下，cmake编译脚本compile.sh内容如下：
#!/bin/bash set -x set -e rm -rf build mkdir -p build cd build LOG="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5896f6e5ac2574424e04702dc94e4e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78deeab251710b4f37c1126d82bdf0b7/" rel="bookmark">
			随机生成6位随机数（字母&#43;数字）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 package com.test; public class test { public static void main(String[] args) { String randomcode = ""; // 用字符数组的方式随机 String model = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"; char[] m = model.toCharArray(); for (int j = 0; j &lt; 6; j++) { char c = m[(int) (Math.random() * 36)]; // 保证六位随机数之间没有重复的 if (randomcode.contains(String.valueOf(c))) { j--; continue; } randomcode = randomcode + c; } System.out.println(randomcode); } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5cdbb69718f3aba630f7cf5054dab27/" rel="bookmark">
			浅谈Android源码与设计模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		七大基本原则
单一职责原则、开闭原则、里氏替换原则、依赖倒置原则、接口隔离原则、迪米特法则、组合/聚合优先原则。 一、单例模式 1、恶汉模式：通过预先创建一个实例化的静态对象的方式实现单例。 缺点：增加了应用加载的时间以及存储对象的资源空间（有实例化的静态对象存在的类，ClassLoader会预先加载此类，即使没有被任何地方调用过）。 优点：第一次getInstance不需要创建对象，运行时获取对象的速度快。 2、懒汉模式：在第一次getInstance方法中实例化静态对象，实现单例。 缺点：需要添加synchronized关键字以实现多线程，每次调用getInstance都要进行同步，耗费不必要的资源。第一次getInstance需要创建对象，运行时获取对象的速度稍慢。 优点：只有使用时才会被实例化，一定程度上节约了资源。 3、双重校验锁模式：通过对实例的双重判空，达到实现单例的目的。 缺点：第一次加载反应稍慢。在高并发时有可能出现失败。 优点：资源利用率高，第一次执行getInstance时单例对象才会被实例化，效率高。 4、静态内部类单列模式：getInstance返回静态内部类的静态单例对象。 既实现了线程安全，又延迟了单例的实例化，推荐的单例模式实现方式。 5、安卓中的单例模式 Context中的getSystemServer(String name)，返回的系统服务即是单例。 6、实践 管理类（Manager）、工具类（Utils）等都可以实现成单例模式。 7、优缺点 二、建造者模式 1、使用场景 （1）相同的方法，不同的执行顺序，产生不同的事件结果时。 （2）多个部件都可以装配到一个对象中，但是产生的运行结果又不相同时。 2、安卓中的建造者模式 AlertDialog，其中实现链式调用的关键点是每个setter方法都返回自身，也就是return this。 3、实践 为计算机组装硬件——构建主机、设置操作系统、设置显示器等等。 4、优缺点 三、原型模式 1、使用场景 （1）类初始化需要消耗大量资源，如数据、硬件等，可以通过原型拷贝避免消耗。 （2）类初始化需要非常繁琐的数据准备或访问权限。 （3）保护性拷贝。 2、安卓中的原型模式 ArrayList的Clone方法 3、深拷贝与浅拷贝 浅拷贝是按位拷贝对象，它会创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值；如果属性是内存地址（引用类型），拷贝的就是内存地址 ，因此如果其中一个对象改变了这个地址，就会影响到另一个对象。 深拷贝会拷贝所有的属性,并拷贝属性指向的动态分配的内存。当对象和它所引用的对象一起拷贝时即发生深拷贝。深拷贝相比于浅拷贝速度较慢并且花销较大。 4、实践 用户登录信息的备份与共享。 5、优缺点 四、工厂方法模式 1、使用场景 在任何需要生成复杂对象的地方，都可以使用工厂模式。复杂对象适合使用工厂模式，用new就可以完成创建的对象无序使用工厂模式。 2、安卓中的工厂方法模式 HashSet、ArrayList与Iterator接口之间即是工厂方法模式的关系。 3、实践 安卓中的数据存储类型有：文件、SharedPreference、SQLite， 将每一种数据存储操作封装成产品类。 五、抽象工厂模式 1、使用场景 一个对象族有相同的约束时可以使用抽象工厂模式。 2、安卓中的抽象工厂模式 MediaPlayerFactory：MediaPlayerFactory是安卓底层为创建不同MediaPlayer所定义的一个类。 3、实践 例如：自行车产品族、小汽车产品族、大客车产品族 4、优缺点 5、简单（静态）工厂模式、工厂方法模式、抽象工厂模式区别 简单工厂 ： 用来生产同一等级结构中的任意产品。（对于增加新的产品，无能为力） 工厂方法 ：用来生产同一等级结构中的固定产品。（支持增加任意产品） 抽象工厂 ：用来生产不同产品族的全部产品。（对于增加新的产品，无能为力；支持增加产品族） 六、策略模式 1、使用场景 （1）针对同一类型问题的多种处理方式，仅仅是具体行为有差别时。 （2）需要安全地封装多种同一类型的操作时。 （3）出现同一抽象类有多个子类，而又需要使用if-else或者switch-case来选择具体子类时。 2、安卓中的策略模式 TimeInterpolator(时间插值器) 3、实践 地铁站的收费策略系统 4、优缺点 七、状态模式 1、使用场景 （1）一个对象的行为取决于太多状态，并且它必须在运行时根据状态改变它的行为。 （2）代码中包含大量与对象状态的条件语句，例如，一个操作中含有庞大的多分支语句（if-else或switch-case），且这些分支依赖于该对象的状态。 2、安卓中的状态模式 Wifi的状态管理（蓝牙、MediaPlayer等含有状态机的都一样） 3、实践 用户登录状态系统 4、优缺点 八、责任链模式 1、使用场景 （1）多个对象可以处理同一请求，但具体由哪个对象处理则在运行时动态决定。 （2）在请求处理者不明确的情况下向多个对象中的一个提交下一个请求。 （3）需要动态指定一组对象处理请求。 2、安卓中的责任链模式 Touch事件分发机制，根据onTouchEvent方法返回值的设置，如果是false,那么当前View不是事件的责任人，根据DispatchTouchEvent逻辑继续向下传递事件；如果为true，则当前View消费该事件，并不再向外传递。 3、实践 OrderedBroadcast(有序广播)的接收器，根据设置的不同权限，按顺序处理广播。 九、解释器模式 1、使用场景 用于解释含有终结符与非终结符的文法。 2、Android中的解释器模式 PackageParser解释AndroidManifest.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5cdbb69718f3aba630f7cf5054dab27/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f91533066b70522d7ebc74acefdeb2b5/" rel="bookmark">
			机器学习一些数据集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大数据
大数据
1.https://delicious.com/pskomoroch/dataset
2.http://stackoverflow.com/questions/10843892/download-large-data-for-hadoop
3.http://konect.uni-koblenz.de/
搜狗实验室
http://www.sogou.com/labs/resources.html?v=1
气象数据集
https://www.ncdc.noaa.gov/data-access/quick-links
气候监测数据集
http://cdiac.ornl.gov/ftp/ndp026b
机器学习
亚马逊网络服务数据
http://aws.amazon.com/datasets
航空公司数据(2009年ASA挑战)
http://stat-computing.org/dataexpo/2009/the-data.html
澳大利亚天气
http://www.bom.gov.au/climate/dwo/
因果关系工作台
http://www.causality.inf.ethz.ch/repository.php
Kaggle竞争数据
https://www.kaggle.com/datasets
KDNuggets竞争网站
www.kdnuggets.com/datasets/
机器学习的数据集存储库
http://mldata.org/
医疗保险数据文件
http://go.cms.gov/19xxPN4
微软研究院
http://research.microsoft.com/apps/dp/dl/downloads.aspx
百万歌曲数据集
http://blog.echonest.com/post/3639160982/million-song-dataset
歌曲数据集
http://labrosa.ee.columbia.edu/millionsong/pages/additional-datasets
RDataMining.com R和数据挖掘电子书数据
http://www.rdatamining.com/data
革命分析集合
http://www.revolutionanalytics.com/subscriptions/datasets/
社交网络
http://www.cs.cmu.edu//ancestry.com/~ jelsas /数据
UCI机器学习库
http://archive.ics.uci.edu/ml/
535亿点击
1.http://cnets.indiana.edu/groups/nan/webtraffic/click-dataset
2.http://archive.ics.uci.edu/ml/
3.http://www.ics.uci.edu/~mlearn//MLRepository.htm
机器学习样本数据库
1.http://kdd.ics.uci.edu/
2.http://www.ics.uci.edu/~mlearn/MLRepository.html
关于基金的数据挖掘的网站
http://www.gotofund.com/index.asp
数据生成器的链接
http://www.cse.cuhk.edu.hk/~kdd/data_collection.html
癌症基因
http://www.broad.mit.edu/cgi-bin/cancer/datasets.cgi
金融数据
http://lisp.vse.cz/pkdd99/Challenge/chall.htm
网络
斯坦福大学大型网络数据收集
http://snap.stanford.edu/data/
微软匿名网络数据
http://kdd.ics.uci.edu/databases/msweb/msweb.html
MSNBC匿名网络数据
http://kdd.ics.uci.edu/databases/msnbc/msnbc.html
SyskillWebert Web数据
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f91533066b70522d7ebc74acefdeb2b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1dff3b6ddeb2e9b02254b7528141080f/" rel="bookmark">
			CH340驱动（含各平台）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CH340转串口芯片支持的平台驱动齐全，支持 Windows/Linux/Android/MacOS/WinCE 等各主流系统。下面就给出各平台下驱动官网链接和简要说明，每个平台的安装与使用问题可以参见我的其他博文。
Windows驱动 下载链接：CH340/CH341 Windows 驱动链接
简要说明：CH340/CH341的USB转串口WINDOWS驱动程序的安装包，支持32/64位 Windows 10/8.1/8/7/VISTA/XP，SERVER 2016/2012/2008/2003，2000/ME/98，通过微软数字签名认证，可联网自动识别安装驱动，支持USB转3线和9线串口等，用于随产品发行到最终用户。
Linux驱动 下载链接：CH340/CH341 Linux驱动链接
简要说明：CH340/CH341的USB转串口LINUX驱动程序，随系统进行编译安装，支持各类处理器架构，支持32/64位系统。
Android驱动 下载链接：CH340/CH341 Android驱动链接
简要说明：CH340/CH341的USB转串口安卓免驱应用库，用于Android操作系统3.1及以上版本的USB Host模式，无需加载Android内核驱动，无需root权限操作。包含apk安装程序，lib库文件（Java Driver），App Demo例程(USB转UART Demo工程SDK)。
MacOS驱动 下载链接：CH340/CH341 MAC驱动链接
简要说明：CH340/CH341的USB转串口MAC OS驱动程序的安装包，支持32/64位系统，通过苹果数字签名认证，内有使用说明。
安装使用问题可以发送邮件到 tech@wch.cn 来咨询，也可以给我评论哦~:-D
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5eb178fe0ea4485bf28956ebaf9ebe28/" rel="bookmark">
			Couldn&#39;t run /usr/bin/dumpcap in child process:权限不够
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自：http://j4s0nh4ck.iteye.com/blog/2242640
解决方法：
在ubuntu终端依次输入下边命令：
sudo apt-get install libcap2-bin wireshark
sudo chgrp myusername /usr/bin/dumpcap
sudo chmod 750 /usr/bin/dumpcap
sudo setcap cap_net_raw,cap_net_admin+eip /usr/bin/dumpcap
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68ec550c0d7e51122682a9539dbf5e68/" rel="bookmark">
			Java数组练习(二) 获取数组中的最大值最小值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		思路一：
1.获取最值需要进行比较，每一次比较都会有一个较大的值，因为该值的不确定性，通过一个变量进行临时存储。
2.让数组中的每一个元素都和这个变量中的值进行比较，如果大于变量中的值，就用该变量记录较大值。
3.当所有的元素都比较完成，那么该变量中的存储就是数组中的最大值了。
步骤：
1.定义变量，初始化为数组中的任意一个元素。
2.通过循环语句对数组进行遍历。
3.在变量过程中定义判断条件，如果遍历到的元素比变量中的元素大，就赋值给该变量。
注意：
通过定义一个功能来完成，以便提高代码的复用性。该功能结果为数组中的最大元素，未知内容为数组。
class Test { public static void main(String[] args) { int[] arr1 = {9,5,6,3,1,2,8,7}; int max1 = getMax(arr1); System.out.println("max1="+max1); double[] arr2 = {9.0,5.0,6.0,3.0,1.0,2.0,8.0,7.0}; double max2 = getMax(arr2); System.out.println("max2="+max2); } //获取int类型数组最大值 public static int getMax(int[] arr) { int max = arr[0]; for(int i=0;i&lt;arr.length;i++) { if(arr[i]&gt;max) max = arr[i]; } return max; } //获取double类型数组最大值，功能相似，以重载的形式存在 public static double getMax(double[] arr) { double max = arr[0]; for(int i=0;i&lt;arr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/68ec550c0d7e51122682a9539dbf5e68/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84eabb67b46a15e515539ea1612c3e88/" rel="bookmark">
			ArcGIS Engine中如何调用GP工具（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		相信用过ArcGIS的用户都会有这样一个感受，那就是功能太强大了！尤其是其提供了超过900个地理处理（Geoprocessing，简称GP）工具，可以快速地实现数据分析、数据管理以及数据转换等功能。在ArcGIS Engine的开发过程中也必不可少的会遇到调用GP工具的问题，这也是用户问的最多的一类问题，那么ArcGIS Engine中如何调用GP工具？参数怎么写？有哪些注意事项？如何获取报错信息？今天，就把Engine中调用GP工具的相关问题总结一下，相信一定会让你有所收获。
一、如何调用GP工具？ 调用GP工具的方式有两种：一种是使用Geoprocessing类，工具参数使用IVariantArray方式输入；另一种是使用Geoprocessor托管类，创建工具对象，参数作为该工具对象的属性输入。下面就分别来看下这两种调用方式的具体实现。
使用Geoprocessing类： 主要分为以下几步：
1，添加ESRI.ArcGIS.Geoprocessing引用，仅需要引用该类库 2，创建geoprocessor对象，注意这里的P是大写 3，如果调用自定义工具，需要添加自定义工具箱的路径 4，创建IVariantArray对象，用于存放工具参数 5，调用geoprocessor的Execute方法
下面来看具体代码（以调用Buffer工具为例）：
A，调用系统工具：
IGeoProcessor2 gp = new GeoProcessorClass(); //设置gp.OverwriteOutput是指可以用一个输出执行多次工具 gp.OverwriteOutput = true; IGeoProcessorResult result = new GeoProcessorResultClass(); // Create a variant array to hold the parameter values. IVariantArray parameters = new VarArrayClass(); object sev = null; try { // Populate the variant array with parameter values. parameters.Add(FileGDBPath + "\\LotIds"); parameters.Add(FileGDBPath + "\\LotIds_Buffer"); parameters.Add("100 Feet"); // Execute the tool. result = gp.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/84eabb67b46a15e515539ea1612c3e88/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0258f21f850cf689ff032eb7b7c5cf60/" rel="bookmark">
			正整数分解使得乘积最大问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、问题描述
设n是一个正整数。现在要求将n分解为若干个自然数之和，使得自然数的成绩最大。输出这个最大的乘积。
要求:
（1）要求这些自然数互不相同
（2）要求这些自然数可以是相同的
二、问题分析：
这类题一开始需要我们手写几个数来看看规律。先做第一问，要求自然数互不相同。从5开始写起，5=2+3，6=2+4，7=3+4，8=3+5，9=2+3+4，10=2+3+5，11=2+4+5
发现规律如下：
（1）尽量使得元素是连续的。
（2）如果有多出来的，从后往前均匀分配到各个元素。考虑到一种特殊情况，当多出来的数比前面已有元素的个数大1时（比如8的情况），先给已有元素的最大元素加1，然后再均匀分配到每个元素。
下面举个栗子，看看携程实习生招聘笔试的这道题：
题目描述：乘积最大
有一个整数n，将n分解成若干个不同自然数之和，问如何分解能使这些数的乘积最大，输出这个乘积m。
输入：
一个整数，不超过50
输出
一个整数
样例输入
15
样例输出
144
c++代码实现：
#include&lt;iostream&gt; #include&lt;vector&gt; using namespacestd; int main(){ int num; while(cin&gt;&gt;num){ int flag[100] = {0}; int k=2; int i=0; while(num &gt;= k){ //从2开始分解，依次分解为2，3，4，5...连续的元素 flag[i++] = k; num -= k; k++; } if(num &gt; 0){ //说明有剩余的 if(num == flag[i-1]){ //说明这时候剩余的数正好比已有的元素个数多1，所以要先给最后一个元素加1 flag[i-1]++; num--; } for(int j=i-1;j&gt;=0 &amp;&amp;num&gt;0;j--){ flag[j] ++; num--; } } int result = 1; for(int j = 0;j&lt;i;j++){ result *= flag[j]; } cout&lt;&lt;result&lt;&lt;endl; }//while return 0; } 对于第二问，对于元素可以是相同的
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0258f21f850cf689ff032eb7b7c5cf60/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c3b17729192dcb42bba4292f6757ac7/" rel="bookmark">
			Android小部件Widget----全解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Android应用的Widget介绍 App Widget是应用程序窗口小部件（Widget）是微型的应用程序视图，它可以被嵌入到其它应用程序中（比如桌面）并接收周期性的更新。
首先上一张图来给大家看一看效果。
Widget小部件，通常具备一定的功能；并且通常是和某个应用程序是关联的，通过点击手机桌面上的Widget小部件，会触发启动相对应的应用程序。Widget小部件，通常需要用户手动自行摆放到手机桌面（长按手机桌面，添加“小部件”，从小部件列表中选择）。
很多应用程序APP自带小部件，比如QQ音乐的“听音识曲”。安装了的朋友，长按手机桌面，添加“小部件”，会发现小部件列表中就会有QQ音乐的“听音识曲”。
详细介绍可以参考Android官方文本
二、Widget相关类介绍 1、AppWidgetProvider类 AppWidgetProvider 继承自BroadcastReceiver，它能接收 widget 相关的广播，例如 widget 的更新、删除、开启和禁用等。我们的Android应用程序可以通过一个AppWidgetProvider来发布一个Widget。
通常我们的Android应用程序需要定义一个类，继承AppWidgetProvider。
AppWidgetProvider中的广播处理函数
(1)onUpdate()
当 widget 更新时被执行。同样，当用户首次添加 widget 时，onUpdate() 也会被调用，这样 widget 就能进行必要的设置工作(如果需要的话) 。但是，如果定义了widget 的 configure属性(即android:config，后面会介绍)，那么当用户首次添加 widget 时，onUpdate()不会被调用；之后更新 widget 时，onUpdate才会被调用。
(2)onAppWidgetOptionsChanged()
当 widget 被初次添加 或者 当 widget 的大小被改变时，执行onAppWidgetOptionsChanged()。你可以在该函数中，根据widget 的大小来显示/隐藏某些内容。可以通过getAppWidgetOptions() 来返回 Bundle 对象以读取 widget 的大小信息，Bundle中包括以下信息：
OPTION_APPWIDGET_MIN_WIDTH – 包含 widget 当前宽度的下限，以dp为单位。
OPTION_APPWIDGET_MIN_HEIGHT – 包含 widget 当前高度的下限，以dp为单位。
OPTION_APPWIDGET_MAX_WIDTH – 包含 widget 当前宽度的上限，以dp为单位。
OPTION_APPWIDGET_MAX_HEIGHT – 包含 widget 当前高度的上限，以dp为单位。
onAppWidgetOptionsChanged() 是 Android 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c3b17729192dcb42bba4292f6757ac7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/383ed57ee5e964a1cfac84f68ffd444b/" rel="bookmark">
			网络架构重组--目前三大运营商存在的“僵硬”问题解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		何为僵硬：现在运营商要做网络配置的开通和调整，往往需要几个月的时间，最快也要几个星期。而像阿里巴巴等互联网公司，则要求运营商能够做到分钟级，怎么办？
做网络架构重构，有三大武器：
第一个是SDN（软件定义网络），解决了网络配置的问题，它打破了控制与转发一体的封闭架构，实现了可编程的新纪元。
第二个是NFV（网络功能虚拟化），解决的是网元也就是设备层面的问题，它打破了软硬件一体的封闭网元架构，实现了网络资源的虚拟化。IT资源的虚拟化不新鲜，已经做到很多年了，网络资源的虚拟化还是个新鲜的概念。
第三个是Clouding（云化），是资源的变革，它打破了网络资源和IT资源分离的局面，构筑统一云化的虚拟资源池。
重点变换方向：
第一，弹性&amp;高效 从“互联网应用被动适应网络”向“网络主动、快速、灵活适应互联网应用”，倒过来，不要让互联网应用被动地区适应运营商的网络。像美国著名的视频网站Netflix为了适应运营商的网络，被迫搞了5套编码，分别适应2M、1M、500K的传输速率，让运营商很被动。
第二，大一统 从传统“烟囱式”分省、分专业的网络架构，向“水平集成”的一个中国电信转变。过去，运营商没开一个新业务，就建一个新的业务平台，结果搞成了无数个“烟囱”。2003年韦老主持中国电信业务平台的水平集成，当时业务平台就有2200个，到了去年还剩下700个，这还只是业务平台，不算网管等其他平台。由于平台与平台之间互相不搭架，造成了资源巨大的浪费，跨平台的业务根本就不可能实现。
第三，DC化 从PSTN为核心的组网，向以DC（数据中心）为核心的组网新格局转变。原来中国电信的数据流量大部分来自于交换局，现在则大部分都是从DC来的。据中国电信统计，直挂DC的流量已经占了46%，加上城域网过来的流量，DC已经占了60-70%的流量，这个比例还在不断上升。既然大部分流量都是从DC来的，为什么不以DC为核心？
总之趋势是： 硬件通用化和标准化、软件云化，硬件和软件解耦，摆脱对设备商的过度依赖 read from http://jiyongqing.baijia.baidu.com/article/820687
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53c87cd77409142edabe9905899b1721/" rel="bookmark">
			二叉树的路径和-LintCode
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		描述：
给定一个二叉树，找出所有路径中各节点相加总和等于给定 目标值 的路径。
一个有效的路径，指的是从根节点到叶节点的路径。
样例：
给定一个二叉树，和 目标值 = 5:
1 / \ 2 4 / \ 2 3 返回：
[ [1, 2, 2], [1, 4] ] 思路： 我们遍历从根节点到叶子的所有路径，定义sum为路径经过节点值之和，若sum等于给定值，我们就输出该条路径中的节点组成的vector。 此题中的递归跳出条件为访问完成了叶子节点。 代码： /** * Definition of TreeNode: * class TreeNode { * public: * int val; * TreeNode *left, *right; * TreeNode(int val) { * this-&gt;val = val; * this-&gt;left = this-&gt;right = NULL; * } * } */ class Solution { public: /** * @param root the root of binary tree * @param target an integer * @return all valid paths */ vector&lt;vector&lt;int&gt;&gt; va; void pathsum(TreeNode *root,int sum,int goal,vector&lt;int&gt; v) { if(root-&gt;left==NULL &amp;&amp; root-&gt;right==NULL) { if(sum==goal) va.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/53c87cd77409142edabe9905899b1721/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/929536df9c148f3d4166327581b9e8e0/" rel="bookmark">
			寻找链表相交节点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		思路一：
1、先求出两个链表ListA，ListB的长度LengthA，LengthB。
2、然后先把长的链表头指针先往前走|LengthA - LengthB|步。
3、最后两个链表头指针同步往前走一步，直到指向的对象相同。
代码实现及测试用例：
package com.qiusongde; public class Solution160 { public static void main(String[] args) { ListNode l1 = new ListNode(1); ListNode l2 = new ListNode(2); ListNode l3 = new ListNode(3); l1.next = l2; l2.next = l3; ListNode l4 = new ListNode(4); ListNode l5 = new ListNode(5); l4.next = l5; l5.next = l3; showListNode(l1); showListNode(l4); System.out.println(getIntersectionNode(l1, l4).val); } public static ListNode getIntersectionNode(ListNode headA, ListNode headB) { if(headA == null || headB == null) { return null; } //compute the length of two list int sizeA = length(headA); int sizeB = length(headB); //counteract difference while(sizeA &gt; sizeB) { headA = headA.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/929536df9c148f3d4166327581b9e8e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d21ac90a9801ae29c3340f51ae14cc31/" rel="bookmark">
			基于Python的PIL库学习（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于Python的PIL库的学习（一） 摘要 对于图像识别，大量的工作在于图像的处理，处理效果好，那么才能很好地识别，因此，良好的图像处理是识别的基础。在Python中，有一个优秀的图像处理框架，就是PIL库，本博文会分模块，介绍PIL库中的各种方法，并列举相关例子。
参考：http://pillow-cn.readthedocs.io/zh_CN/latest/reference/index.html
网站上列举了PIL库中所有的模块和方法，但是没有相关的例子，博文中会尽量给出相关的例子和进行简单的讲解。
基于的环境：Win10，Python2.7，PIL 1.1.7。
Image模块 开篇的例子 首先，给出Image模块中的一个简单的例子。例子实现的功能是：读取图片，并进行45°旋转，然后进行可视化。
# -*- coding:utf-8 -*- # Image模块开篇例子 from PIL import Image im = Image.open('test.bmp') # 读取图片 im.rotate(45).show() # 将图片旋转，并用系统自带的图片工具显示图片 程序结果：
创建缩略图 # -*- coding:utf-8 -*- # PIL中创建缩略图(create thumbnails) from PIL import Image import glob,os size = 128,128 for infile in glob.glob("*.jpg"): # glob的作用是文件搜索，返回的是一个列表 file,ext = os.path.splitext(infile) # 将文件的文件名和拓展名分开，用于之后的保存重命名 im = Image.open(infile) im.thumbnail(size,Image.ANTIALIAS) # 等比例缩放 im.save(file+".thumbnail","JPEG") #im.show() # 显示缩略图 #print im.size,im.mode 缩略图不能直接双击打开，而可以使用PIL.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d21ac90a9801ae29c3340f51ae14cc31/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28a71804f0c4d6d164e841a937f662ba/" rel="bookmark">
			linux的netlink接口详解(上)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		内核版本：3.14.38
netlink是一种用于内核态和用户态进程之间进行数据传输的特殊的IPC机制。
特点： 1） 用户态采用socket风格的API 2） 除了预定义的协议类型之外，支持自定义协议类型 3） 异步通讯 4） 支持消息组播 4） 全双工（特别是支持内核主动发起会话） netlink涉及的数据结构： 1） netlink地址结构 struct sockaddr_nl { sa_family_t nl_family; // AF_NETLINK unsigned short nl_pad; // 填充0 unsigned int nl_pid; // 进程ID unsigned int nl_groups; // 多播组mask } NETLINK_ROUTE的多播组定义位于retnetlink.h，RTMGRP_*格式，这里列出常用的几个： RTMGRP_LINK - 当网卡变动时会触发这个多播组，例如插拔网线、增减网卡设备、启用禁用接口等 RTMGRP_IPV4_IFADDR - 当ipv4地址变动时会触发这个多播组，例如修改IP RTMGRP_IPV4_ROUTE - 当ipv4路由变动时会触发这个多播组 RTMGRP_IPV6_IFADDR - 当ipv6地址变动时会触发这个多播组，例如修改IP RTMGRP_IPV6_ROUTE - 当ipv6路由变动时会触发这个多播组 2） netlink消息结构： nlmsghdr + pad + payload + pad + nlmsghdr + pad + payload + pad .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/28a71804f0c4d6d164e841a937f662ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3ab75787eb301dbb3484f3dcadc1469/" rel="bookmark">
			Opencv 简单的美颜实现方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实现方法比较简单，主要实现方案就是先调亮度，再结合高斯模糊与双边模糊进行磨皮，最后进行图像增强（非锐化掩蔽方案 ——Unsharpening Mask）。 直接看代码以及注释：
void whiteFace(Mat&amp; matSelfPhoto,int alpha, int beta) { for (int y = 0; y &lt; matSelfPhoto.rows; y++) { for (int x = 0; x &lt; matSelfPhoto.cols; x++) { for (int c = 0; c &lt; 3; c++) { matSelfPhoto.at&lt;Vec3b&gt;(y, x)[c] = saturate_cast&lt;uchar&gt;(alpha*(matSelfPhoto.at&lt;Vec3b&gt;(y, x)[c]) + beta); } } } } int main() { Mat matResult; Mat src = imread("C:\\Users\\Administrator\\Desktop\\brightness\\test.jpg"); int bilateralFilterVal = 30; // 双边模糊系数 imshow("0000", src); whiteFace(src, 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3ab75787eb301dbb3484f3dcadc1469/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e791bfbad3609a4eee0b2da5d3267108/" rel="bookmark">
			spring pageabe使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java Code Examples for org.springframework.data.web.PageableDefault The following are top voted examples for showing how to use org.springframework.data.web.PageableDefault. These examples are extracted from open source projects. You can vote up the examples you like and your votes will be used in our system to product more good examples. + Save this class to your library Example 1 Project: mini-geocoder File: ReverseGeocodeController.java View source code 9 votes vote down vote up @RequestMapping(value="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e791bfbad3609a4eee0b2da5d3267108/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14a76f66d64c81f9315c3bf119d3ab0e/" rel="bookmark">
			windows下通过cmd命令符窗口查看文件目录结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1）在cmd命令提示符窗口中进入准备操作的文件夹，也可以是整个驱动器的根目录 2）获取目录结构：在当前要操作的文件夹目录下输入命令tree，此时得到目录下树形的目录结构。默认情况下只显示“文件夹”而不显示文件。 3）在tree命令后面加入参数 /f 将以层次的结构显示所有文件夹及文件的名称 4）如何保存上述cmd窗口中显示的内容？ 有的人会觉得在cmd窗口中显示的内容不是很容易操作，有没有方法将其目录结构保存到文档中便于阅读和编辑呢！当然啦！ 在上述使用命令的后面添加“空格”，再添加“&gt;“及文本文档的名称，系统就会将上述显示的内容存入指定的文档中（如果输入了指定路径那么文档存入之规定路径，如果未指 定路径，文本文档就存在当前所在文件夹目录下）。如下图所示，执行后不会显示任何内容，但命令执行的结果保存在文本文档中。 此时看是在”汽车matlab仿真“文件夹下是否多出了filedir.txt文件 可见生成了filedir.txt文件。该文本文件内容为：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7243e76b1ae51cf54d1b58bd7491f313/" rel="bookmark">
			Eclipse 安装插件开发JavaEE
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很多人使用MyEclipse 开发JavaEE，虽然集成了很多功能插件，但是这个MyEclipse感觉有点重（1.52G）。
只是用做学习的话，还是好好贯彻Eclipse 的插件开发的思想吧。
Eclipse只要安装下面四个插件就可以创建 Dynamic Web Project了
Eclipse 插件安装 打开Eclipse，依次选择Help -&gt; Install New SoftWare，在弹出的窗口的 work with 中输入 http://download.eclipse.org/releases/neon (neon是Eclipse版本名)，回车等待一会，就可以看到很多插件，拉到最下面打开 Web, XML, Java EE and OSGi Enterprise Development ，勾选下面所示四个插件，再点击下方的Next 等待安装重启就可以了。其它插件安装类似，只要勾选不同插件即可。
Eclipse 查看已经安装的插件或卸载 还是在Help -&gt; Install New SoftWare，弹出的窗口右下方有 What is already installed？点击这句话，在弹出窗口中就可以浏览所有安装的插件。下方有Uninstall按钮用来卸载插件。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f0bc0931c9db5d24a9228e98ec27b85/" rel="bookmark">
			深入浅出解释FFT（七）——fft求频谱图和功率谱密度图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		频谱图：
声音频率与能量的关系用频谱表示。在实际使用中，频谱图有三种，即线性振幅谱、对数振幅谱、自功率谱。线性振幅谱的纵坐标有明确的物理量纲，是最常用的。对数振幅谱中各谱线的振幅都作了对数计算，所以其纵坐标的单位是dB（分贝）。这个变换的目的是使那些振幅较低的成分相对高振幅成分得以拉高，以便观察掩盖在低幅噪声中的周期信号。自功率谱是先对测量信号作自相关卷积，目的是去掉随机干扰噪声，保留并突出周期性信号，损失了相位特征，然后再作傅里叶变换。自功率谱图使得周期性信号更加突出。
功率谱图：又叫功率谱密度图
功率谱是功率谱密度函数的简称，它定义为单位频带内的信号功率。它表示了信号功率随着频率的变化情况，即信号功率在频域的分布状况。
功率谱表示了信号功率随着频率的变化关系 。　常用于功率信号（区别于能量信号）的表述与分析，其曲线（即功率谱曲线）一般横坐标为频率，纵坐标为功率。 由于功率没有负值，所以功率谱曲线上的纵坐标也没有负数值，功率谱曲线所覆盖的面积在数值上等于信号的总功率（能量）。 时域和频域能量相等。
Parseval 定理 有限上序列x{k}的离散fourier变换是正交变换，满足Parseval能量守恒定理，反映了序列在时域的能量等于其变换域的能量。 关于能量定义：信号幅度平方的积分，如果是数字信号，能量就是各点信号幅度值平方后的求和。 论坛帖子中关于等式关系给出的结论是：
求和 (x(tn)^2)T=RMS^2*Ttotal=求和(P(fn))△f*Ttotal 其中，x(tn)是n个x(t)时域采样数据，T是时间间隔，Ttotal是时间总长， P(fn)是第n个功率谱密度值，△f是FFT频率间隔
最后的结论是相等的，但是信号的能量到底是sum(x.^2)，还是sum(x.^2)*T？按照定义来说是前者没错。但是绝对的能量计算若不跟采样频率（采样间隔）结合起来，又有什么对比作用？
同样1000个点幅值为1，一组波形是1秒内采到的，另一组波形是10秒内采到的，按公式算，信号的能量相等，按sum(x.^2)*T计算，10秒采集到的波形的能量更大。
现实情况中，比较两个波形的能量或有效值，都是采样率相同，采样时间相同，所有不会遇到如此纠结的问题。 生成一组信号：
fs=1000; &gt;&gt; N=1000; &gt;&gt; n=0:N-1; &gt;&gt; t=n/fs; &gt;&gt; x=sin(2*pi*100*t); &gt;&gt; nfft=1024; &gt;&gt; deltF=fs/nfft; &gt;&gt; window=hanning(N); &gt;&gt; %直接法，periodogram函数得到的功率谱密度 &gt;&gt;[Pxx_period,f_period]=periodogram(x,window,nfft,fs); &gt; noverlap=50; &gt;&gt;[Pxx_welch,f_welch]=pwelch(x,window,noverlap,nfft,fs); 12345678910111213 12345678910111213 计算原始信号的有效值为： 0.0224 画出频谱与功率谱密度为： 幅值谱的幅值理论上应为1，不到1的原因是fft变换的点数与采样点数不同所致。 利用FFT幅值谱的平方/N ,画功率谱密度结果跟上右图差不多。
xw=1.633*x.*window'; % 加汉宁窗(恢复系数为1.633)，能量修正系数使加窗后能量保证不变 mag=abs(fft(xw,nfft)); Pxx_1=mag.^2/N/fs; f=(0:nfft/2-1)/nfft*fs; plot(f,Pxx_11(1:512)*2),title('Pxx_11') 12345 12345 关于功率谱密度计算，先做自相关计算，再做FFT也能得到功率谱密度。 最后结果为： summary： 当采样点数=nfft时，deltF*N/fs=1; 功率谱密度直接求和即是频域能量。 用幅值谱的平方估计频域能量时，除完点数，还要除以采样频率。 时域能量要*采样间隔（1/fs） 有效值的平方*采样时间=时域能量；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9a2301f471f21116f3e8862ef181e68/" rel="bookmark">
			matlab中窗函数的使用(一)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		窗函数是频谱分析中一个重要的部分，窗函数修正了由于信号的非周期性并减小了频谱中由于泄露而带来的测量不准确性。
快速傅里叶变换假定了时间信号是周期无限的。但在分析时，我们往往只截取其中的一部分，因此需要加窗以减小泄露。窗函数可以加在时域，也可以加在频域上，但在时域上加窗更为普遍。截断效应带来了泄漏，窗函数是为了减小这个截断效应，其设计成一组加权系数。例如，一个窗函数可以定义为：
w(t)=g(t) -T/2&lt;t&lt;T/2
w(t)=0 其他
g(t)是窗函数，T是窗函数的时间.
待分析的数据x(t)则表示为：
x(t)=w(t)*x(t)'
x(t)'表示原始信号,x(t)表示待分析信号。
加窗在时域上表现的是点乘，因此在频域上则表现为卷积。卷积可以被看成是一个平滑的过程。这个平滑过程可以被看出是由一组具有特定函数形状的滤波器，因此，原始信号中在某一频率点上的能量会结合滤波器的形状表现出来，从而减小泄漏。基于这个原理，人们通常在时域上直接加窗。
大多数的信号分析仪一般使用矩形窗（rectangular），汉宁（hann），flattop和其他的一些窗函数。
矩形窗函数：
w(k)=1
汉宁窗： w(k)=0.5*(1-cos(2*pi*k/(N-1))) 0&lt;=k&lt;=N-1
由于加窗计算中衰减了原始信号的部分能量，因此对于最后的结果还需要加上修正系数。在线性谱分析中，一般使用幅度系数（amplitude correction），在功率谱中，一般使用能量系数（energycorrection）。(这段不清楚在实际中如何用)
matlab中提供了很多窗函数，如下
还提供了显示窗函数的GUI工具，如wvtool可以显示用来显示窗的形状和频域图形，wintool可以打开窗设计和分析工具，如运行
wvtool(hamming(64),hann(64),gausswin(64))
可以对比汉明窗、汉宁窗和高斯窗
简单测试一下加窗的效果如下
可以看到加窗后，频谱泄露确实减少了，但同时信号能量也减小了，这也许就是所说的要使用能量系数吧，如下，这样一来，对比就更明显了，加窗可以有效的减少频谱泄露。
测试代码如下
%% 窗函数测试
function main
clc
close all
Ts = 0.001;
Fs = 1/Ts;
%% 原始信号
t = 0:Ts:pi/2;
yt = sin(2*pi*5*t) + sin(2*pi*10*t) + sin(2*pi*15*t);
[Yf, f] = Spectrum_Calc(yt, Fs);
figure
subplot(211)
plot(t, yt)
xlabel('t')
ylabel('y')
title('原始信号')
subplot(212)
plot(f, Yf)
xlabel('f')
ylabel('|Yf|')
xlim([0 100])
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e9a2301f471f21116f3e8862ef181e68/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed1f0a7251e9f89e5505d01a323e3d88/" rel="bookmark">
			linux下删除文件夹的命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 rmdir 删除空文件夹 rm -r 删除空文件夹或非空文件夹 rm -rf 强制删除文件夹 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d27450a77956993d88139f2725d45e3/" rel="bookmark">
			C&#43;&#43; 函数原型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一，函数原型
函数原型（函数声明）就是告诉编译器这个函数是存在的，让编译器知道这个函数的相关信息。函数原型不要求提供形参名，有类型列表就可以了。避免使用函数原型的方法是，在首次使用函数定义之前定义它，但这并不是总可行的。我们一般把函数声明放在主函数的前面，因为min()函数是应用程序的入口。函数声明是告诉编译器这个函数存在，函数定义是表示该函数如何去做。
二，为什么需要函数原型？
函数原型描述了函数到编译器的接口，它将函数返回值的类型以及参数的类型和数量告诉编译器。例如：看函数原型如何影响下面的函数调用。
double cube(double x); int main() { double val = cube(5.0); return 0; } double cube(double x){ return x * x; } 首先原型告诉编译器，cube()有一个double参数。如果程序没有提供这样的参数，原型将让编译器捕获这样的错误。其次，函数调用结束后，将把返回值放到指定的位置。然后调用函数将从这个位置获取返回值。由于函数原型指出了函数的返回值是double类型，因此编译器知道应检索多少个字节以及如何解释他们。如果没有这些信息，编译器只能进行猜测，但是编译器并不会这么做。
三，函数原型的功能
函数原型可以帮助编译器完成许多的工作，同时，它也可以帮助程序极大的降低程序出错的几率。原型可以确保以下几点：
1，编译器正确处理函数返回值。
2，编译器检索使用的参数数目是否正确。
3，编译器检查使用的参数类型是否正确，如果不正确转换为正确的类型。
int x = 5; double val = cube(x); 首先看上面的函数调用，程序将一个int型的值5传递给cube()。编译器注意到，cube()原型指定一个double类型的参数，因此会将5转换为5.0。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/911f0a4f75a4d86f126474c5129e3d15/" rel="bookmark">
			如何定位CPU占用过高问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 程序运行后出现CPU占用过高，一般是代码有死循环等。top命令可以查看CPU使用情况，找到问题进程。 对CPU使用过高的进程的所有线程进行排序
ps H -e -o pid,tid,pcpu,cmd --sort=pcpu | grep xxx
得到CPU占用率最高的线程的线程号，比如2907进程的线程2909 使用gdb
gdb
gdb&gt;attach 2907
gdb&gt;info threads
列出所有线程信息，发现2909线程编号12 切换线程，bt打印线程栈
gdb&gt;thread 12
gdb&gt;bt
根据打印的信息，重点定位相关代码段。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f83695f6b88b3c7f7b63b9cc866d5126/" rel="bookmark">
			GUI_如何控制在文本框里面只能输入数字字符案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		package cn.itcast_07; import java.awt.FlowLayout; import java.awt.Frame; import java.awt.Label; import java.awt.TextField; import java.awt.event.KeyAdapter; import java.awt.event.KeyEvent; import java.awt.event.WindowAdapter; import java.awt.event.WindowEvent; import java.io.BufferedWriter; import java.io.FileWriter; import java.io.IOException; /* * 你输入的如果是非数字字符,就取消你键盘录入的效果。 */ public class FrameDemo { public static void main(String[] args) { // 创建窗体对象并设置属性 Frame f = new Frame("不能输入非数字字符"); f.setBounds(400, 200, 400, 300); f.setLayout(new FlowLayout()); // 创建Lable标签对象 Label label = new Label("请输入你的QQ号码,不是是非数字,不信你试试:"); // 创建文本框对象 final TextField tf = new TextField(40); // 添加到窗体上 f.add(label); f.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f83695f6b88b3c7f7b63b9cc866d5126/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11c75cdb351889740be8e225ff7262fe/" rel="bookmark">
			如何在K8S平台部署微服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Deploying Micro-services on Kubernetes 本文将介绍如何使用 kubernetes 部署微服务，包括 服务发现，监控，路由，日志。用实际的例子来演示自动化流程。主要分为以下几个部分:
5分钟搭建 K8S 集群
部署 CNI 网络
部署监控服务
部署网关
部署日志服务
部署一个应用
5分钟搭建 K8S 集群 第一次完全手动搭建集群大约花了一周时间，主要的问题是在于
K8S的组件多，每个程序的参数有不少，哪些是关键的参数需要花时间搞清楚。
万恶的墙，代理访问外网比较慢
CNI网络问题，主要是 CNI 网段和云上的局域网网段冲突了，基础知识缺失导致
K8S 的证书和验证方式不清楚
本文相关代码位于github, 欢迎star。
手动部署可以参考我之前的博文，即便是完全熟悉部署流程，不写脚本的情况下，如果纯手动 setup 或者 tear down 一个集群，都是比较耗时间的。直到发现了这个工具 kubeadm, 世界美好了。
这个工具对操作系统有限制， ubuntu 16.04 或 centos 7 以上。其实当初也看到了这个工具， 不过 因为系统限制，并且kubeadm还在alpha版本，又想手动撸一遍部署过程，所以没直接采用。 不过 kubeadm 不建议在生产环境中使用，在 官方文档中的 limitation 中有详细解释.
文档 中第一点就说了， kubeadm部署的是 single master，意味着不是高可用，谨慎使用。 但是作为演示实例再合适不过。
小插曲: 因为最近发布的 k8s 1.6 的 kubeadm 有一个bug，导致用以下步骤安装会有问题，为此社区里有人提了一个patch, 步骤有些多，我写在本文最后了。
kubeadm v1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/11c75cdb351889740be8e225ff7262fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18ceffe806d32c9e174137dcec83a751/" rel="bookmark">
			数据仓库--代理键
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[转]数据仓库设计——代理键 转载 2015-12-06 12:12:22 标签： it 数据仓库 代理键 在关系型数据库设计中，代理键是在当资料表中的候选键都不适合当主键时，例如资料太长，或是意义层面太多，就会用一个attribute来当代理主键，此主键可能是用流水号，来代替可辨识唯一值的主键。
在数据仓库领域有一个概念叫Surrogatekey，中文一般翻译为“代理关键字”。代理关键字一般是指维度表中使用顺序分配的整数值作为主键，也称为“代理键”。代理关键字用于维度表和事实表的连接。
代理关键字的称呼有surrogatekeys，meaningless keys，integer keys，nonnatural keys，artificialkeys，synthetic keys等。与之相对的自然关键字的称呼有natural keys，samatkeys等。
在Kimball的维度建模领域里，是强烈推荐使用代理关键字的。在维度表和事实表的每一个联接中都应该使用代理关键字，而不应该使用自然关键字或者智能关键字（SmartKeys）。数据仓库中的主键不应该是智能的，也就是说，要避免通过主键的值就可以了解一些业务信息。当然，退化维度作为事实表的复合主键之一时例外。
使用代理关键字，有很多优点。
1．使用代理关键字能够使数据仓库环境对操作型环境的变化进行缓冲。也就是说，当数据仓库需要对来自多个操作型系统的数据进行整合时，这些系统中的数据有可能缺乏一致的关键字编码，即有可能出现重复，这时代理关键字可以解决这个问题。
2．使用代理关键字可以带来性能上的优势。和自然关键字相比，代理关键字很小，是整型的，可以减小事实表中记录的长度。这样，同样的IO就可以读取更多的事实表记录。另外，整型字段作为外键联接的效率也很高。
3．使用代理关键字可以建立一些不存在的维度记录，例如“不在促销之列”，“日期待定”，“日期不可用”等维度记录。
4．使用代理关键字可以用来处理缓慢变化维。维度表数据的历史变化信息的保存是数据仓库设计的实施中非常重要的一部分。Kimball的缓慢变化维处理策略的核心就是使用代理关键字。
当然，使用代理关键字也有它的缺点，代理关键字的使用使数据加载变得非常复杂。有关使用代理关键字的维度表和事实表的加载方法在ETLToolkit中有详细的描述。使用代理关键字是一个从长远考虑的策略。
一个实际例子： 1、【问题来源】：http://zhidao.baidu.com/question/101736946.html
2、【问题描述】：​小弟有些不明白数据仓库代理键使用的方法
对于事实表,表a userid(主) deptid pay 1 301 50 2 302 30 3 302 40 4 303 15 维度表,表b deptid deptname groupid groupname 301 销售一部 1 销售区 302 销售二部 1 销售区 303 市场一部 2 市场区 对于用维度表关联只需要 a.deptid=b.deptid就可以了 但我学习了代理键做缓慢维度变化要在唯度表上建立无意义的排序主键 唯度表,表b bid(代) deptid deptname groupid groupname 1 301 销售一部 1 销售区 2 302 销售二部 1 销售区 3 303 市场一部 2 市场区 看网上资料是要事实表与唯度表代理键关联,请问这种如何关联?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/18ceffe806d32c9e174137dcec83a751/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4f2d1ad03a16910f16e253529528c58/" rel="bookmark">
			海量服务实践──手 Q 游戏春节红包项目设计与总结（上篇）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		导语 大哥说，今年手Q游戏的春节红包你来做。那该怎么做？以及怎么做才能让大哥放心？本文从后台的角度出发讲述了这个过程和方法，对于关键的前台部分也有所涉及。
目录 1.需求背景
1.1.红包类别1.2.体验流程1.3.后台需求2.需求分析
2.1.礼包列表2.2.区服信息2.3.领取礼包3.整体方案与项目分解
4.需求开发
4.1.功能需求开发4.2.性能需求开发4.3.容错需求开发4.4.监控需求开发5.系统保障
5.1.系统容灾5.2.过载保护5.3.柔性可用5.4.立体监控6.演习验证
6.1.灰度演习6.2.压测演习6.3.异常演习7.总结
1. 需求背景 1.1.红包类别 2017 年的手 Q 春节游戏红包共有刷一刷/ AR 地图/扫福三种，如下图所示：
1.2.体验流程 虽然红包分三种，但在游戏业务侧这边的体验都是一样：用户得到一个红包卡券，打开后展示一个（刷一刷红包）或者多个（AR 地图红包）游戏的礼包列表，用户选择一个礼包后弹出区服组件，用户确认对应的区服角色信息后会礼包会在 48 个小时内发放到账。体验如下：
1.3.后台需求 游戏红包的设计容量为入口卡券页流量 80k/s，以上体验流程一共涉及三个后台接口：
礼包列表：用户界面的礼包内容需要根据后台接口返回礼包列表进行排序和过滤展示区服选择：用户界面弹出的区服组件需要后台接口返回用户区服角色信息领取礼包：用户点击“确认”按钮领取礼包，后台进行游戏道具发货 2.需求分析 2.1.礼包列表 这个功能使用现有能力比较容易解决。活动共有十种游戏，每个游戏有两种礼包：拉新（面向非注册用户，价值 80 元）/拉活跃（面向注册用户，价值 20 元），一个用户只能获得这两种礼包中的一种，产品策略允许拉新的用户获得价值较低的拉活跃礼包，反之则不允许。页面展示按用户偏好排序十个游戏，每个游戏展示一个拉新礼包或者一个拉活跃礼包。
出于降低除夕当前流量负载和柔性考虑，在红包活动前，十种游戏的礼包内容作为前端静态数据已经预先通过离线包/CDN 下发；红包活动时，后台接口根据用户偏好返回的游戏礼包列表，只是提供前端礼包内容进行过滤和排序，失败了也有前端默认的游戏礼包列表，保障用户体验。
过滤：读取存储，用户有注册的游戏返回活跃礼包，用户没有注册的游戏返回拉新礼包。
排序：一个两层排序，第一层排序读取存储（key 为用户，value 为用户所注册的游戏列表），用户注册的游戏（拉活跃）排在用户没有注册的游戏（拉新）前面；第二层排序，对于拉新游戏列表和拉活跃游戏列表内部，使用神盾算法对用户这10款游戏的偏好再进行二次排序。对于外部接口的依赖只有 CMEM 存储和神盾算法接口，这两个接口以及合并这两种数据给出最终的个性化推荐礼包列表接口都可以平行扩容以支持 100k 级别的 QPS。
2.2.区服信息 这个功能是现有能力。这个角色信息的来源是 IDIP ，但由于该接口较缓慢（2s 左右）且容量较低（低于 10k/s），故后台做了一层缓存，将 IDIP 的区服信息永久性缓存到 CMEM 中，前台也有本地缓存，在实践中，前台缓存命中率为 60%，后台为 35%，多级缓存后走到 IDIP 的请求量只有5%，对 IDIP 影响不大，只需要扩容现有的区服 server 和 CMEM 即可。
2.3.领取礼包 这个功能使用现有能力解决存在困难。游戏中心日常发货的道具和平台比较多，平台分为 IEG-AMS/MP 两种，MP 发货对于发游戏道具和发 Q 币又是两种接口，故我们在架构上使用 Facade 模式，使用 AMS 作为发货 proxy，屏蔽了底层发货的复杂性，向游戏中心提供统一的发货接口，但比较遗憾的是从AMS 到游戏的发货接口都是同步接口，发货能力较低，发货能力最高的王者荣耀也只承诺了 3k/s 的发货速度，明显不足以直接承受 100k/s 级别的红包发货，故这里的核心问题是需要有一个队列来解决生产/消费速度不对等的问题。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4f2d1ad03a16910f16e253529528c58/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc9d3f8ad82d3ca06b9d177da82e6e4f/" rel="bookmark">
			wxml文件错误，错误信息：未找到页面 pages/index/index对应的wxml文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在微信小程序新建项目后会报“wxml文件错误，错误信息：未找到页面 pages/index/index对应的wxml文件”
之前新建没有问题
遇到这种情况，我是在新建项目时将项目目录选择在带有小程序的文件中，应该点击新建文件夹放在一个空白的文件夹下。 确保当前文件下只有一个程序，不然会乱，这样就可以了。
《Kotlin语法基础到实战开发》系列课程视频
http://edu.csdn.net/course/detail/6409?locationNum=7&amp;fps=1&amp;ref=srch&amp;loc=1
http://edu.csdn.net/course/play/6409/123752
《Android版本更新、热更新》系列课程视频
版本更新6.0，7.0统统搞定！！
热修复不在麻烦，再也不用担心上线后出bug！！
http://edu.csdn.net/course/detail/6523
http://edu.csdn.net/course/play/6523/131198
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f067de5dbc978f89e0ed79ef4a20074e/" rel="bookmark">
			jq全屏滚动插件fullpage.js使用方法及move.js
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、fullpage.js引用地址 fullpage.js
二、插件使用方法 &lt;1&gt;引入 1.插入jquery.fullPage.css;
2.插入jquery.js;
3.插入jquery-ui.js;(用于制作动画)
4.插入jquery.fullpage.js;
1 &lt;link rel="stylesheet" href="jquery.fullPage.css"&gt; 2 &lt;script src="jquery-1.11.3.min.js"&gt;&lt;/script&gt; 3 &lt;script src="jquery-ui.js"&gt;&lt;/script&gt; 4 &lt;script src="jquery.fullPage.js"&gt;&lt;/script&gt; &lt;2&gt;html 1 &lt;body&gt; 2 &lt;div id="fullpage"&gt; 3 &lt;div class="section s1"&gt; 4 &lt;img src="img/bc8.jpg" alt=""&gt; 5 &lt;/div&gt; 6 &lt;div class="section s2"&gt; 7 &lt;img src="img/bc8.jpg" alt=""&gt; 8 &lt;/div&gt; 9 &lt;div class="section s3"&gt; 10 &lt;img src="img/bc8.jpg" alt=""&gt; 11 &lt;/div&gt; 12 &lt;div class="section s4"&gt; 13 &lt;img src="img/bc8.jpg" alt=""&gt; 14 &lt;/div&gt; 15 &lt;div class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f067de5dbc978f89e0ed79ef4a20074e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fca7da96af48ee25287354d78b3cb076/" rel="bookmark">
			SimHash
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关键字：字符串降维，汉明匹配，顺序无关
基本原理 simhash是google用于解决海量数据去重的问题，通过降维到hash_code，在通过降维后的code进行两两匹配。 流程如下： - 1、分词，把需要判断文本分词形成这个文章的特征单词。最后形成去掉噪音词的单词序列并为每个词加上权重。
2、hash，通过hash算法把每个词变成hash值，比如“美国”通过hash算法计算为 100101,“51区”通过hash算法计算为 101011。
3、加权，通过 2步骤的hash生成结果，需要按照单词的权重形成加权数字串，比如“美国”的hash值为“100101”，通过加权计算为“4 -4 -4 4 -4 4”；“51区”的hash值为“101011”，通过加权计算为 “ 5 -5 5 -5 5 5”。
4、合并，把上面各个单词算出来的序列值累加，变成只有一个序列串。比如 “美国”的 “4 -4 -4 4 -4 4”，“51区”的 “ 5 -5 5 -5 5 5”， 把每一位进行累加， “4+5 -4+-5 -4+5 4+-5 -4+5 4+5” ==》 “9 -9 1 -1 1 9”。这里作为示例只算了两个单词的，真实计算需要把所有单词的序列串累加。
5、降维，把4步算出来的 “9 -9 1 -1 1 9” 变成 0 1 串，形成我们最终的simhash签名。 如果每一位大于0 记为 1，小于0 记为 0。最后算出结果为：“1 0 1 0 1 1”。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fca7da96af48ee25287354d78b3cb076/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/760e9a34d35b5126259be6acf24bd637/" rel="bookmark">
			51单片机的组成部分
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.中央处理器（CPU)
2.程序存储器（ROM）
3.数据存储器（RAM）
4.定时器 / 计数器 一般包含两个16位的可编程定时器 / 计数器，以实现定时或计数的功能。它也可以产生中断，从而在程序中控制程序的转向
5.并行I / O口 用于和外部设备进行并行的输入/输出通信，以便于处理外部的输入和将运算结果反馈到外部设备
6.全双工串行UART 用于和其他设备间的串行数据传送。
7.中断系统 51包括两个外部中断、两个定时器/计数器中断和一个串行中断。51单片机的中断系统具有两级的优先级别选择
8.时钟振荡电路 用于为单片机提供CPU时钟源。单片机可以采用内部时钟振荡电路或者外部提供时钟源。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1c6e91cd47bbf9d0760b442b3dc1755/" rel="bookmark">
			MyBatis 使用笔记(4) 完结篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前的三篇文章 我讲解了MyBatis的安装、详细配置、Mapper配置讲解， 这篇文章，就来整体的来写个整体的使用流程。
MyBatis使用流程 1.配置MyBatis环境（添加MyBatis、数据库驱动 jar文件） 2.配置mybatis-config.xml (自定义类型映射，数据源，Mapper) 3.编写Mapper的接口和xml文件 4.用SqlSessionFactoryBuilder实例化SqlSessionFactory 5.创建一个会话SqlSession 6.获取Mapper实例 7.使用Mapper接口实例做数据库操作并获得结果 8.关闭SqlSession释放资源
以上 就是MyBatis的使用整体流程。当然 前两项在项目添加MyBatis之后配置一下就可以了 后面的步骤 是每次做数据库操作时都要用的。
前面我也说了 SqlSessionFactory会打开一个到数据库的连接，我们整个程序中连接同一个数据库 就用一个SqlSessionFactory实例即可，那么我们这里就将这个SqlSessionFactory编写成单利形式，让我们项目之后都直接用他就可以了。实例化SqlSessionFactory是需要使用SqlSessionFactoryBuilder，我们来看看我们的获取SqlSessionFactory单利的工具类代码
public class DbUtils { private static volatile SqlSessionFactory sqlSessionFactory; public static SqlSessionFactory obtionSqlSessionFactory() { if( sqlSessionFactory == null ) { synchronized (DbUtils.class) { if(sqlSessionFactory == null ) { sqlSessionFactory = getSqlSessionFactory(); } } } return sqlSessionFactory; } private static SqlSessionFactory getSqlSessionFactory() { String resource = "mybatis-config.xml"; SqlSessionFactory sqlSessionFactory = null; try { InputStream inputStream = Resources.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e1c6e91cd47bbf9d0760b442b3dc1755/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/abc725fe5c8244fac6bc67d977337242/" rel="bookmark">
			设计模式MIxin 特殊的多继承
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、意图 给类增加一些额外功能。在保持单一继承的纯净性，又避免由于单一继承产生的复杂的继承层次结构。类似于JAVA中的Interface（规格继承：只是定义了一些列接口），但是Mixin（属于实现继承）能够有实现方法。
二、图解 对于多继承，如上会存在这样问题： 如果类D对象调用一个方法，在类B、C、D中都没有，而类A中有，那么语言的机制是应该从DBA这条线寻找方法，还是从DCA这条线； 如果类B和类C中存在同样方法时，该调用哪个类中方法？ 一些编程语言支持多继承，如C++、python等等；另外一些则不支持多继承，如Java，ruby等。 在Python中就有Mixin的影子。
class ForkingUDPServer(ForkingMixIn, UDPServer): pass class ForkingTCPServer(ForkingMixIn, TCPServer): pass 基于此类问题，提出两种解决办法：规格继承和实现继承（Mixin）
Mix-in 类是具有以下特征的抽象类： 不能单独生成实例，属于抽象类； 不能继承普通的非Mixin类。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f9e8d3d9baa033253dc439da87a9a73/" rel="bookmark">
			HashMap调优和ConcurrentHashMap分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前谈到了HashMap的存和取，这次来聊一下它的调优，以及多线程下的不用HashMap转用ConcurrentHashMap的一点浅析
重述HashMap工作原理： HashMap是基于hash原理，我们使用put()存储对象，使用get()获取对象当我们给put方法传键值时，他会先调用hashCode方法，用于查找键值在 bucket的位置，进而存储对象的键值对当两个对象的hashCode相同，在存储时候就会发生碰撞，原因就是HashMap采取集成Map和链表的存储方式，继而调用equals比较，没有就存进去，有就把之前的替换掉 HashMap调优： 先贴出HashMap源码普及一下几个概念： public class HashMap&lt;K,V&gt;extends AbstractMap&lt;K,V&gt;implements Map&lt;K,V&gt;, Cloneable, Serializable { // 默认的初始容量（容量为HashMap中桶的数目）是16，且实际容量必须是2的整数次幂。 static final int DEFAULT_INITIAL_CAPACITY = 16; // 最大容量（必须是2的幂且小于2的30次方，传入容量过大将被这个值替换） static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; // 默认加载因子 static final float DEFAULT_LOAD_FACTOR = 0.75f; // 存储数据的Entry数组，长度是2的幂。 // HashMap是采用拉链法实现的，每一个Entry本质上是一个单向链表 transient Entry[] table; // HashMap的大小，它是HashMap保存的键值对的数量 transient int size; // HashMap的阈值，用于判断是否需要调整HashMap的容量（threshold = 容量*加载因子） int threshold; // 加载因子实际大小 final float loadFactor; // HashMap被改变的次数 transient volatile int modCount; 通过以上源码可以看到在源码中定义了一下几个常量： 默认加载因子：这东西说白了就是用来划分整个HashMap容量的百分比，这里默认0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f9e8d3d9baa033253dc439da87a9a73/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9eaaef287d51db6fe37550ede352b4db/" rel="bookmark">
			嵌入式文本编辑器（vi）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.vi的基本操作 进入与离开vi
进入vi可以直接在系统提示字下键入vi＜文档名称＞，vi可以自动载入所要编辑的文档或是开启一个新的文档。如在shell中键入vi hello.c（新建文档）则可进入vi画面。
进入vi后屏幕左方会出现波浪符号，凡是具有该符号就代表此列目前是空的。此时进入的是命令行模式。
要离开vi可以在底行模式下键入“:q”（不保存离开），“:wq”（保存离开）指令则是存
档后再离开（注意冒号）。如图2.2所示。
2. vi中3种模式的切换
（1）命令行模式、底行模式转为插入模式
在命令行模式或底行模式下转入到插入模式有3种方式，如下所示。
特征 ARM 作用
新增 a 从光标所在位置后面开始新增资料，光标后的资料随新增资料向后移动
A 从光标所在行最后面的地方开始新增资料
插入 i 从光标所在位置前面开始插入资料，游标后的资料随新增资料向后移动
I 从光标所在行的第一个非空白字元前面开始插入资料
开始 o 在光标所在行下新增一列，并进入插入模式
O 在光标所在行上方新增一列，并进入插入模式
（2）插入模式转为命令行模式、底行模式
从插入模式转为命令行模式、底行模式比较简单，只需使用［Esc］键即可。
（3）命令行模式与底行模式转换
输入冒号，则为底行模式，使用［Esc］键可以退出底行模式而进入命令行模式。
3.vi的删除、修改与复制 特征 ARM 作用
x 删除光标所在的字符
删除 dd 删除光标所在的行
s 删除光标所在的字符，并进入输入模式
S 删除光标所在的行，并进入输入模式
r 待修改字符修改光标所在的字符，键入r后直接键入待修改字符修改 R 进入取代状态，可移动光标, 向所指位置键入字符，该字符取代原来的 字符，该取代状态直到按［Esc］才结束
yy 复制光标所在的行复制
yny 复制光标所在的行向下n行
p 将缓冲区内的字符粘贴到光标所在位置
4. vi的光标移动 指令 指令作用
0 移动到光标所在行的最前面
$ 移动到光标所在行的最后面
［Ctrl］d 光标向下移动半页
［Ctrl］f 光标向下移动一页
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9eaaef287d51db6fe37550ede352b4db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34d51183e7612ef84a068bc63e184353/" rel="bookmark">
			javascript  跳转页面  关闭当前页面  返回上页面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 //跳转页面
1.window.location.href //跳转到的页面
2.如何有form 表单的话
document.form[0].action = //跳转的action 0 是第一个form 表单
// 关闭当前页面
window.close() ; 关闭当前页面
/ /返回上页面
&lt;a οnclick="JavaScript:history.back(1);" href="#"&gt;返回&lt;/a&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20f67f20965ecbad08aeefd6445a362a/" rel="bookmark">
			spring batch教程 之 配置并运行Job
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring batch整体的架构设计使用如下关系图来进行表示：
虽然Job对象看上去像是对于多个Step的一个简单容器，但是开发者必须要注意许多配置项。此外，Job的运行以及Job运行过程中元数据如何被保存也是需要考虑的。本章将会介绍Job在运行时所需要注意的各种配置项。
1.1 Configuring a Job Job接口 的实现有多个，但是在配置上命名空间存在着不同。必须依赖的只有三项：名称 name，JobRespository 和 Step的列表：
&lt;job id="footballJob"&gt; &lt;step id="playerload" parent="s1" next="gameLoad"/&gt; &lt;step id="gameLoad" parent="s2" next="playerSummarization"/&gt; &lt;step id="playerSummarization" parent="s3"/&gt; &lt;/job&gt; 在这个例子中使用了父类的bean定义来创建step，更多描述step配置的信息可以参考step configuration这一节。XML命名空间默认会使用id为'jobRepository'的引用来作为repository的定义。然而可以向如下显式的覆盖：
&lt;job id="footballJob" job-repository="specialRepository"&gt; &lt;step id="playerload" parent="s1" next="gameLoad"/&gt; &lt;step id="gameLoad" parent="s3" next="playerSummarization"/&gt; &lt;step id="playerSummarization" parent="s3"/&gt; &lt;/job&gt; 此外，job配置的step还包含其他的元素，有并发处理()，显示的流程控制()和外化的流程定义()。 1.1.1 Restartablity 执行批处理任务的一个关键问题是要考虑job被重启后的行为。如果一个 JobExecution 已经存在一个特定的 JobInstance，那么这个job启动时可以认为是“重启”。 理想情况下，所有任务都能够在他们中止的地方启动，但是有许多场景这是不可能的。在这种场景中就要有开发者来决定创建一个新的 JobInstance ，Spring对此也提供了一些帮助。如果job不需要重启，而是总是作为新的 JobInstance 来运行，那么可重启属性可以设置为'false'：
&lt;job id="footballJob" restartable="false"&gt; ... &lt;/job&gt; 设置重启属性restartable为‘false’表示‘这个job不支持再次启动’，重启一个不可重启的job会抛出JobRestartExceptio的异常：
Job job = new SimpleJob(); job.setRestartable(false); JobParameters jobParameters = new JobParameters(); JobExecution firstExecution = jobRepository.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/20f67f20965ecbad08aeefd6445a362a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/395873fb7547a381f39d4731431fdcf2/" rel="bookmark">
			GPS简介和定位过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 GPS简介 1：全名是‘Navigation Satellite Timing And Panging / Global Position System’，其意为“卫星测时测距导航/全球定位 系统”，缩写为‘NAVSTAR/GPS’.简称GPS。 2：组成：1.地面控制部分，主控站，地面天线，监测站。 2.空间部分，由24颗卫星组成 3.用户装置部分,GPS接收机和 卫星天线。 GPS原理 24颗GPS卫星在距离地面12000km的高空，以12小时的周期环绕地球运行，使得在任意时刻，在地面上的任意一点都可以同时 观测到4颗以上的卫星。4颗卫星得到观测点的经纬度和高程。 由于技术等原因，民用GPS定位精度只有100m，引入差分GPS(DGPS)技术。利用基准站对gps进行修正，定位精度可提高至5m GPS模块 市场上大多是符合民用标准，精度为5~100m。一般的GPS模块上电后，会自动搜索卫星信号，并把计算好的数据从串口输出。 大部分GPS模块有两个串行接口（UART），一个用于配置模块，另一个用于输出卫星数据。波特率为4800b/s或9600b/s，高一些的可以达到38400b/s。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77af2c6a11f9087956721a9e44e56112/" rel="bookmark">
			键盘的工作原理和分类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 键盘工作原理 键盘的结构有两种：线性键盘和矩阵键盘。在不同情况下，这两种键盘都有应用 线性键盘由若干个独立的按键组成，每个按键的一端与微机的一个I/O口相连。有多少个按键就要有多少根线与微机的I/O口相连，因为，只适用按键少的场合。 矩阵键盘的按键按N行M列列排列，每个按键占据行列的一个交点，需要的I/O数量是N+M,容许的最大按键数量是N*M。显然矩阵键盘可以减少与微机接口的连线数，简化结构，是一般微机常用的键盘结构。根据矩阵键盘的识键和译键方法的不同，矩阵键盘有可以分为编码键盘和非编码键盘。 非编码键盘：非编码键盘是用软件的方法识键和译键。根据扫描方法的不同，可以分为行扫描法、列扫描法和反转法三种。 编码键盘：编码键盘主要用硬件来实现键的扫描和识别，通常使用8279专用接口芯片，在硬件上要求较高。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c187efae93282ec681fdec139d52f76f/" rel="bookmark">
			VI中显示行号的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ctrl+g就可以显示当前光标所在行在全行中的行号
在编辑器底部输入：
：nu 该行行号
：set nu 所有行号 //:set number 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/809b113f2c4cdb4b2353fe9d402d1189/" rel="bookmark">
			UnityShader学习教程之＜详解uv坐标与加入数学算法控制uv坐标的原理＞
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这三个是我们本篇文章需要解决的内容！
第一，我们首先了解uv坐标是什么，我的理解是uv图的坐标！那uv图是什么，我们可以用一个坐标轴来表示：
上图所示，uv坐标对应的就是坐标轴上的位置和坐标，而map指的就是我们的贴图，正常情况下map和uv是对应的1比1的关系，但是我们希望只采样纹理图的某一部分，这时候我们就应该要修改我们的纹理坐标,做一些数学运算，来达到不同的效果！
Shader "Unlit/任务12详解uv纹理坐标和映射原理"
{
Properties
{
_MainTex ("Texture", 2D) = "white" {}
}
SubShader
{
Tags { "RenderType"="Opaque" }
LOD 100
Pass
{
CGPROGRAM
#pragma vertex vert
#pragma fragment frag
#include "UnityCG.cginc"
struct appdata
{
float4 vertex : POSITION;
float2 uv : TEXCOORD0;
};
struct v2f
{
float2 uv : TEXCOORD0;
float4 vertex : SV_POSITION;
};
sampler2D _MainTex;
float4 _MainTex_ST;
v2f vert (appdata_full v)
{
v2f o;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/809b113f2c4cdb4b2353fe9d402d1189/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60c3cc814ad5d90ed32c00cd6b77fcbd/" rel="bookmark">
			Greasy Fork 用户脚本简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Greasy Fork 简介 用户脚本为您增强对浏览体验的控制权。在安装之后，它们可自动为您访问的网站添加功能，或使其更加易用、更加清新。在 Greasy Fork 上的用户脚本是由其他用户编写并向全世界发表的，您可以免费和轻松地安装。
如何使用 Greasy Fork 第一步：安装一个用户脚本管理器 要使用用户脚本，您首先需要安装一个用户脚本管理器。根据您使用的浏览器不同，可用的用户脚本管理器也有所不同。
Tampermonkey，支持Chrome, Firefox, Microsoft Edge, Safari, Opera Next, MaxthonGreasemonkey，支持Firefox 第二步：安装一个用户脚本 浏览此网站 查找您想尝试的用户脚本。
在您找到想要的用户脚本后，点击用户脚本页面上绿色的安装按钮，您的用户脚本管理器将询问您是否安装。
第三步：使用用户脚本 转至用户脚本适用的网站。它应该已自动启动和生效。在试用用户脚本后，您可以返回用户脚本页面，给用户脚本的作者留下反馈。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/534/">«</a>
	<span class="pagination__item pagination__item--current">535/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/536/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>