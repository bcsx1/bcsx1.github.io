<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5fe4a935afc78633b2c1645f16ae45f9/" rel="bookmark">
			qemu如何退出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 qemu退出的方式 通常可用reboot -f官方文档给出的是ctrl + A 和 X，需要注意ctrl 与 A同时按住抬起后再按X，不要三个键同时按～ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a03984fe6e8e792fecc47d26629b2943/" rel="bookmark">
			原子类AtomicInteger实现浅析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 前言 在多线程程序中，如果多个线程同时更新一个共享变量，可能会出现预料之外的奇怪的值。普通的变量无法在多线程下做到可见性、一致性、原子性，也就无法保证线程安全。在JDK的java.util.concurrent.atomic包中提供许多原子操作类，它们可以简单、 高效、安全地更新一个变量。现在介绍其中的基本类型的原子操作类。
基本数据类型有boolean 、 char 、 byte 、 short 、int 、long 、 float 、double 这8种，但其原子类只有AtomicBoolean AtomicInteger AtomicLong.其他未包含的基本类型可通过一些操作转换成原子类型。如：只取AtomicInteger 的低32位(低位的两字节)可作为short 的原子类，将double放大10n倍将其变为整数，然后就可使用AtomicLong原子类。这3个类的实现基本相同，这里以AtomicInteger为例作说明
2 方法说明 主要API如下
//以原子方式获取旧值并设置新值 public final int getAndSet(int newValue) //以原子方式获取旧值并自增1 public final int getAndIncrement() //以原子方式获取旧值并自减1 public final int getAndDecrement() //以原子方式获取旧值并给当前值加delta public final int getAndAdd(int delta) //以原子方式给当前值自增1并获取新值 public final int incrementAndGet() //以原子方式给当前值自减1并获取新值 public final int decrementAndGet() //以原子方式给当前值加上delta并获取新值 public final int addAndGet(int delta) 3 实现原理 上面的这些API都会使用到Unsafe类的相关方法,可以说原子类的实现关键在于Unsafe。AtomicInteger使用一个int类型的成员变量value来表示原子类所代表的数值, value使用volatile关键字修饰，在多线程环境中能保证其可见性。Unsafe类可以在本地内存中直接操作value.
private volatile int value; AtomicInteger有两个构造方法，带参构造方法用参数指定初始值，无参数构造方法将初始值设为0
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a03984fe6e8e792fecc47d26629b2943/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/547e7e3db2e50e46952683078e39be96/" rel="bookmark">
			pycharm中通过命令行运行程序，进行程序调试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.点击菜单栏run-&gt;edit configurations
2.如果命令行输入python ecode.py --users --items,则在parameters框中输入--users --items
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01a9bc27edacff6e0932e929f34b1235/" rel="bookmark">
			日期数据类型datetime
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.1 datetime说明1.2 实践环境的说明1.3 datetime理解 1.1 datetime说明 类型datetime显示格式年-月-日 时:分:秒有效范围UTC时间： 1000-01-01 00:00:00 至9999-12-31 23:59:59占用空间8字节(bytes)插入方式insert into test2(mydate) values(now());
insert into test2(mydate) values(“2019-04-10 19:40:32”);
insert into test2(mydate) values(20190410194030); 1.2 实践环境的说明 ## 当前数据库的版本和存储引擎 mysql&gt; select @@version,@@default_storage_engine; +------------+--------------------------+ | @@version | @@default_storage_engine | +------------+--------------------------+ | 5.7.28-log | InnoDB | +------------+--------------------------+ 1 row in set (0.00 sec) ## 当前事务的提交方式 mysql&gt; select @@global.autocommit,@@autocommit; +---------------------+--------------+ | @@global.autocommit | @@autocommit | +---------------------+--------------+ | 1 | 1 | +---------------------+--------------+ 1 row in set (0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/01a9bc27edacff6e0932e929f34b1235/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40ef9ecb3b9402058141f7a028b48937/" rel="bookmark">
			Blender2.8基础四：手绘贴图篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、纹理绘制（Texture Paint）模式打开方式 ▶ 打开方式1：
▶ 打开方式2：Ctrl+Tab
二、 ▶ 开启无光模式：
二、各种贴图用法 ▶ 透明贴图 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/755ddc56f0b333b9680c59b647ac9ae7/" rel="bookmark">
			想入门SpringBoot整合MyBatis，看我这一篇就够了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面： MyBatis作为业界优秀的持久层框架，应用广泛，与各类web框架都有着良好的整合性。今天在博客里主要总结一下SpringBoot与MyBatis的整合入门，非常简单，放心看下去吧。
1.添加MyBatis起步依赖 在前几篇博客中提到了，起步依赖算是SpringBoot的一大特点之一。所以大部分优秀的组件与SpringBoot整合额第一步都是添加起步依赖。在pom.xml中添加：
&lt;!--SpringBoot与MyBatis整合第一步：导入MyBatis起步依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.1&lt;/version&gt; &lt;/dependency&gt; 这里的版本我用的1.1.1，大家可以随意~
2.导入MySql坐标，其实也就是导入MySql的相关依赖 &lt;!--SpringBoot与MyBatis整合第二步：导入MySql数据库坐标--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; 3.在SpringBoot的配置文件中添加MySql的连接信息 SpringBoot我认为其相对比与SpringMVC等框架来说，是属于弱配置的框架类型。其之所以是弱配置类型，是因为具有自动配置这一属性，从而极大的减少了我们的繁杂的手动文件配置。但是，对于诸如数据库这一类的配置信息，客制化程度很高，账号密码是多少？是本地还是远程的数据库？这些都是默认配置无法完成的，所以需要在application.properties中进行手动配置如下：
#添加数据库连接信息 spring.datasource.driverClassName=com.mysql.jdbc.Driver spring.datasource.url=jdbc:mysql://127.0.0.1:3306/quming?useUnicode=true&amp;characterEncoding=utf8 spring.datasource.username=root spring.datasource.password=123456 #配置mybatis相关信息 #扫描pojo别名包 mybatis.type-aliases-package=tjq.demo.domain #配置加载MyBatis映射文件 mybatis.mapper-locations=classpath:mapper/*mapper.xml 数据库的连接信息配置其实各个框架都是大同小异的，无非分为驱动、url（数据库地址以及具体链接哪一个库，这里连接的是quming数据库）、用户名、密码这四部分。这里注意一下，新手容易把username写成name，导致后期整合出错。
而MyBatis配置信息就是要告诉程序，去哪儿扫描实体类（pojo），再去哪儿加载实体类与底层数据库的xml映射文件。
4.创建实体bean（或者实体类） 这里稍微提一下MyBatis的ORM思想：Object Relational Mapping，即对象关系映射。把这句话翻译成大白话就是：将实体类对象及其属性与数据库的表直接联系起来，从而实现操作实体类便可以操作数据库。传统的jdbc数据库整合，都是要在Dao层接口的实现类中写SQL语句，配置繁琐复杂。MyBatis将这些交给了mapper配置文件。这里点到为止，不再深挖，有兴趣可以去查看我的另外一篇详细介绍MyBatis的博客。
由于我要去操作的这张表的格式如下：
非常简单，只有idxing、xingshi这两个属性，所以我们也对应着创建相应的实体类即可。注意这里一般为了项目更好地开发，实体类属性名要和表中的属性名保持完全一致。
package tjq.demo.domain; public class user { private Integer idxing; private String xingshi; public Integer getIdxing() { return idxing; } public void setIdxing(Integer idxing) { this.idxing = idxing; } public String getXingshi() { return xingshi; } public void setXingshi(String xingshi) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/755ddc56f0b333b9680c59b647ac9ae7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eaec5b888bd360f9600663f04ef572ce/" rel="bookmark">
			空间复杂度的四种计算情况，超级简单好懂
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		刚接触空间复杂度的时候，可能很多人知道什么是空间复杂度，但是往往不知道怎么计算。
和时间复杂度类似，空间复杂度是对一个算法在运行过程中临时占用存储空间大小的度量，也是使用大O表示法。
1、常量空间
存储空间大小固定，和输入没有关系时，空间复杂度是O(1)
2、线性空间
算法中定义了一个线性集合，如一个列表，并且集合大小和输入规模n成正比，空间复杂度记为O(n)
3、二维空间
算法中定义了一个二维列表集合，并且集合的长和宽都和输入规模n成正比，空间复杂度记为O(nn)/O（nm)
4、递归空间
递归过程就是一个进栈和出栈的过程，当进入一个新函数时，进行入栈操作，把调用的函数和参数信息压入栈中；当函数返回时，执行出栈。
递归的空间复杂度也是线性的，如果递归的深度是n，那么空间复杂度就是O(n)。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/abb4f89a9429016feeca9012534c5a59/" rel="bookmark">
			Windows下通过环境变量设置多个KubeConfig配置文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 复制配置文件只本地 推荐保存在 $HOME/.kube路径下，可命名为config-hw.json或config-aliyun.yaml，建议保留原路径中的config。
新建一个环境变量 环境变量-&gt; 系统变量新建一个名为KUBECONFIG变量。指定Kubernetes配置文件路径和文件名，通过这种方式可以同时指定yaml配置文件和JSON配置文件。例如阿里云Kubernetes配置文件为yaml格式，而华为云Kubernetes配置文件为json格式。
根据需要切换环境 查看当前context kubectl config current-context 查看配置文件中所有参数 kubectl config view 切换cluster # 例如，切换到一个名为 external的上下文 kubectl config use-context external 参考资料 Configure Access to Multiple Clusters 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e52fd28edfbcc8ad5c7b57f7c91735f/" rel="bookmark">
			编程坑太多，List坑刚踩完，Map的坑又踩了好几个
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们提到几个比较容易踩坑的点。作为 List 集合好兄弟 Map，我们也是天天都在使用，一不小心也会踩坑。
今天我就来总结这些常见的坑，再捞自己一手，防止后续同学再继续踩坑。
本文设计知识点如下：
不是所有的 Map 都能包含 null 这个踩坑经历还是发生在实习的时候，那时候有这样一段业务代码，功能很简单，从 XML 中读取相关配置，存入 Map 中。
代码示例如下：
那时候正好有个小需求，需要改动一下这段业务代码。改动的过程中，突然想到 HashMap 并发过程可能导致死锁的问题。
于是改动了一下这段代码，将 HashMap 修改成了 ConcurrentHashMap。
美滋滋提交了代码，然后当天上线的时候，就发现炸了。。。
应用启动过程发生 NPE 问题，导致应用启动失败。
根据异常日志，很快就定位到了问题原因。由于 XML 某一项配置问题，导致读取元素为 null，然后元素置入到 ConcurrentHashMap 中，抛出了空指针异常。
这不科学啊！之前 HashMap 都没问题，都可以存在 null，为什么它老弟 ConcurrentHashMap 就不可以？
翻阅了一下 ConcurrentHashMap#put 方法的源码，开头就看到了对 KV 的判空校验。
看到这里，不知道你有没有疑惑，为什么 ConcurrentHashMap 与 HashMap 设计的判断逻辑不一样？
求助了下万能的 Google，找到 Doug Lea 老爷子的回答：
来源:http://cs.oswego.edu/pipermail/concurrency-interest/2006-May/002485.html 总结一下：
null 会引起歧义，如果 value 为 null，我们无法得知是值为 null，还是 key 未映射具体值？Doug Lea 并不喜欢 null，认为 null 就是个隐藏的炸弹。 上面提到 Josh Bloch 正是 HashMap 作者，他与 Doug Lea 在 null 问题意见并不一致。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e52fd28edfbcc8ad5c7b57f7c91735f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfc5f36da5f3080e2fee39e8ef640958/" rel="bookmark">
			HTML和CSS的分离
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		特别声明：此篇文章由Jekst根据Jonathan Snook的英文文章原名《Decoupling HTML From CSS》进行翻译，整个译文带有我们自己的理解与思想，如果译得不好或不对之处还请同行朋友指点。如需转载此译文，需注明英文出处：http://coding.smashingmagazine.com/2012/04/20/decoupling-html-from-css以及作者相关信息
——作者：Jonathan Snook
——译者：Jekst
多年以来，web标准社区一直在讨论关注点——分离。把CSS样式规则从javascript代码和HTML结构里分离出来。我们确实是这么做的，不是吗？CSS规则放到了独立的文件里，javascript代码放到了另一个独立的文件里，HTML文件就只剩下HTML结构了，这样做既简洁又美观。
CSS Zen Garden向我们证明了我们只需要改变CSS样式文件就能将一个设计转变成多种样式的设计。但是，我们很少注意到这样做的另一面——一个工程里出现这种情况的可能性很大：HTML文档结构的改变。当我们修改了HTML文件后，我们不得不回过头来从新修改CSS文件来适应新的HTML文件。
由此看来，我们并没有真正的将HTML和CSS分开，不是吗？我们不得不在HTML和CSS两个文件里都做修改。
探索方法 在我的职业生涯中，我很高兴能够参与数百个不同的网站和web应用程序的开发。在绝大多数的项目中，我是唯一一个编写HTML和CSS的开发者。我开发了一种开发网站的方法，对我来说，这种方法很好用。
最近两年的时间，我从事于雅虎，参与了 Mail、Messenger、Calendar及其他一些项目的开发。和一个较大的团队一起开发一个较大的项目是一次很棒的经历。一个小团队设计员与一个大团队样式设计师们合作, 为多个团队的工程师建立所有的HTML和CSS。
从多个方面来看，这是我参与过的规模最大的工程：
雅虎拥有大量的用户，仅邮箱用户就达到3亿左右。遍布多个团队的数百人从事HTML和CSS开发。我们开发的组件系统在多个工程间使用 就是在雅虎工作期间，我开始真正的考虑我和团队该怎样去构建网站。我们遇到过哪些难题，又能如何避免他们？
我看过其他人的做法， Nicole Sullivan的Object-Oriented CSS，Jina Bolton的“CSS Workflow” ，和Natalie Downe的“Practical, Maintainable CSS”，还有别人的一些文章，这里只列出了一部分。
根据我的想法，我写了一本关于长表单样式的指南，叫做“Scalable and Modular Architecture for CSS”名字有点长，大家可以简称为“SMACSS”（发音“smacks”）。在我提炼并扩张开发CSS渠道的同时，这份指南也会随之继续扩展用于css开发。
结果我发现设计师（包括我）写得CSS规则和被应用样式的HTML有很大关联。为了更少重构、更灵活开发，我们怎么将HTML和CSS分离呢？
换句话说，在任何元素上，我们怎样避免使用!important，或者避免掉进选择器的陷阱呢？
复用样式 以前，我们给需要加样式的HTML元素使用font标签、应用background属性（指attributes，不是CSS里的background属性，是HTML 标签里的background）。当然，这种方式非常不现实， 因此就出现了CSS。CSS能够使我们从页面的一个部分复用另一部分的样式，实现样式的复用。
比如，一个导航菜单，有一些样式一样的菜单项，在每个项使用行样式是不现实的。因此，我们开始看到的CSS是这样的：
#nav { margin: 0; padding: 0; list-style: none; } #nav li { float: left; } #nav li a { display: block; padding: 5px 10px; background-color: blue; } 无疑每个菜单项添加了float:left属性，链接加上了display:block; padding:5px 10px;样式。很高效，我们要的效果达到了。看到这些CSS规则，大家就可以看到预期的HTML结构：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cfc5f36da5f3080e2fee39e8ef640958/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7272d8eb39ef27b944bf9b2c160ebbc8/" rel="bookmark">
			语义解析 (Text-to-SQL) 技术研究及应用 上篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		欢迎关注"百度NLP"官方微信公众号，及时获取更多自然语言领域技术干货！！！ 语义解析（Semantic Parsing）是自然语言处理技术的核心任务之一，涉及语言学、计算语言学、机器学习以及认知语言等多个学科，在近几年中获得了广泛关注，语义解析任务有助于促进机器语言理解的快速发展。
本文重点介绍语义解析技术中的Text-to-SQL任务，让机器自动将用户输入的自然语言问题转成数据库可操作的SQL查询语句，实现基于数据库的自动问答能力。
任务介绍及研究动机 当前，大量信息存储在结构化和半结构化知识库中，如数据库。对于这类数据的分析和获取需要通过SQL等编程语言与数据库进行交互操作，SQL的使用难度限制了非技术用户，给数据分析和使用带来了较高的门槛。人们迫切需要技术或工具完成自然语言与数据库的交互，因此诞生了Text-to-SQL任务。
我们通过图1中的实例来介绍一下Text-to-SQL任务。该任务包含两部分：Text-to-SQL解析器和SQL执行器。
解析器的输入是给定的数据库和针对该数据库的问题，输出是问题对应的SQL查询语句，如图中红色箭头标示。SQL执行器在数据库上完成该查询语句的执行，及给出问题的最终答案，如图中绿色箭头标示。
SQL执行器有很多成熟的系统，如MySQL，SQLite等，该部分不是本文重点。本文主要介绍解析器，学术界中Text-to-SQL任务默认为Text-to-SQL解析模型。
图1
首先，我们介绍一下术语“数据库”和“SQL查询语句”：
1、数据库由一张或多张表格构成，表格之间的关系通过外键给出。在该实例中，数据库由表 “中国城市”和“2018年宜居城市” 构成，两张表通过外键：“中国城市”的“名称”列和“2018年宜居城市”的“名称”列关联；
2、SQL是数据库查询语言，其构成来自3部分：数据库（如实例SQL查询语句中蓝色标注的成分）、问题（如实例SQL查询语句红色标注的成分）、SQL关键词（如实例SQL查询语句中的Select、From、Where等）。
其次，我们介绍一下Text-to-SQL解析模型。根据SQL的构成，解析器需要完成两个任务，即“问题与数据库的映射”和“SQL生成”。
在问题与数据库的映射中，需要找出问题依赖的表格以及具体的列，如图1实例中，问题“绿化率前5的城市有哪些，分别隶属于哪些省？”依赖的数据库内容包括：表格“中国城市”，具体的列“名称”、“所属省”、“绿化率”（SQL查询语句蓝色标注成分）。
在SQL生成中，结合第一步识别结果以及问题包含信息，生成满足语法的SQL查询语句，如实例中的“Select 名称,所属省 From 中国城市 Where 绿化率 &gt; 30%”。
Text-to-SQL研究进展
Text-to-SQL技术能够有效地辅助人们对海量的数据库进行查询，因其有实用的应用场景，引起了学术界和工业界的广泛关注。我们接下来将从相关数据集和模型两方面介绍该技术的研究进展。
1、数据集介绍
图2给出了Text-to-SQL数据集发展趋势，代表数据集参见表1。
图2
其中术语介绍：
根据包含领域数量，数据集分为单领域和多领域。
根据每个数据库包含表的数量，数据集分为单表和多表模式。在多表模式中，SQL生成涉及到表格的选择。
根据问题复杂度，数据集分为简单问题和复杂问题模式，其中问题复杂度由SQL查询语句涉及到的关键词数量、嵌套层次、子句数量等确定。
根据完整SQL生成所需轮数，数据集分为单轮和多轮。
若SQL生成融进渐进式对话，则数据集增加“结合对话”标记。当前只有CoSQL数据集是融进对话的数据集。
表1
由图2和表1可知，当前主流数据集都是多领域的，这就要求Text-to-SQL解析模型除了满足问题无关外，还要满足领域无关。
2、模型介绍
SQL查询语句是一个符合语法、有逻辑结构的序列，其构成来自三部分：数据库、问题、SQL关键词。
在当前深度学习研究背景下，Text-to-SQL任务可被看作是一个类似于神经机器翻译的序列到序列的生成任务，主要采用Seq2Seq模型框架。基线Seq2Seq模型加入注意力、拷贝等机制后，在单领域数据集上可以达到80%以上的准确率，但在多领域数据集上效果很差，准确率均低于25%。
从编码和解码两个方面进行原因分析。
在编码阶段，问题与数据库之间需要形成很好的对齐或映射关系，即问题中涉及了哪些表格中的哪些元素（包含列名和表格元素值）；同时，问题与SQL语法也需要进行映射，即问题中词语触发了哪些关键词操作（如Group、Order、Select、Where等）、聚合操作（如Min、Max、Count等）等；最后，问题表达的逻辑结构需要表示并反馈到生成的SQL查询语句上，逻辑结构包括嵌套、多子句等。
在解码阶段，SQL语言是一种有逻辑结构的语言，需要保证其语法合理性和可执行性。普通的Seq2Seq框架并不具备建模这些信息的能力。
当前基于Seq2Seq框架，主要有以下几种改进。
1）基于Pointer Network的改进
首先，SQL组成来自三部分：数据库中元素（如表名、列名、表格元素值）、问题中词汇、 SQL关键字。其次，当前公开的多领域数据集为了验证模型数据库无关，在划分训练集和测试集时要求数据库无交叉，这种划分方式导致测试集数据库中很大比例的元素属于未登录词。传统的Seq2Seq模型是解决不好这类问题的。
Pointer Network很好地解决了这一问题，其输出所用到的词表是随输入而变化的。具体做法是利用注意力机制，直接从输入序列中选取单词作为输出。在Text-to-SQL任务中，将问题中词汇、SQL关键词、对应数据库的所有元素作为输入序列，利用Pointer Network从输入序列中拷贝单词作为最终生成SQL的组成元素。
由于Pointer Network可以较好的满足具体数据库无关这一要求，在多领域数据集上的模型大多使用该网络，如Seq2SQL[1]、STAMP[8]、Coarse2Fine[9] 、IRNet[16]等模型。
2）基于Sequence-to-set的改进
在简单问题对应的数据集合上，其SQL查询语句形式简单（仅包含Select和Where关键词），为了解决Seq2Seq模型中顺序错误带来的影响（如“条件1 And 条件2”，预测为“条件2 And 条件1”，属于顺序错误，但对应的SQL是正确的），SQLNet[10]提出了Sequence-to-set模型，基于所有的列预测其属于哪个关键词（即属于Select还是Where，在SQLNet模型中仅预测是否属于Where），针对SQL 中每一个关键词选择概率最高的前K个列。
该模式适用于SQL形式简单的数据集，在WikiSQL和NL2SQL这两个数据集合上使用较多，且衍生出很多相关模型，如TypeSQL[11]、SQLova[12]、X-SQL[13]等。
图3 Sequence-to-Set
3）基于TRANX（自顶向下文法生成）的改进
复杂问题对应的SQL查询语句形式也复杂，涉及到多关键词组合、嵌套、多子句等。并且，测试集合中的某些SQL查询语句形式在训练集合中没有见过，这就要求模型不仅对新数据库具有泛化能力，对新SQL查询语句形式也要有泛化能力。
针对这种情况，需要更多关注生成SQL的逻辑结构。为了保证SQL生成过程中语法合理，一些模型开始探索及使用语法树生成的方法。
TRANX[14]框架借鉴了AST[15]论文思想，根据目标语言的语法构建规约文法，基于该文法可以将生成目标表示为语法树（需要保证生成目标与语法树表示一一对应），然后实现了自顶向下的语法树生成系统，图4给出了该系统流程。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7272d8eb39ef27b944bf9b2c160ebbc8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/333f39c3412476aebd0e19714bce5fd3/" rel="bookmark">
			C&#43;&#43;:log日志
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 日志一般是记录一些程序运行信息的文件，一般是用于快速定位错误所在，追踪程序运行的过程和进度、采集运行环境等作用。说白了简单粗暴点就是程序挂了，可以看到大概在哪里挂的，挂的原因可能有哪些等作用。
最近在github上找了些C++的日志库，做了些简单的使用记录。
一、NanoLog C++ 11 在github上找到的NanoLog有几个版本，不过我只下载了两个星星数量最高的，一个是C++11的，一个是C++17的。
C++11这个比较简单，就一个头文件和源文件，使用起来也比较简单，首先包含头文件NanoLog.hpp，然后通过nanolog::initialize()初始化一个实例，nanolog::initialize的第二个参数和第三个参数是设置日志的存放路径和文件名，第四个参数设置当日志文件大小超过多少Mb的时候会生成新的日志文件，这样可以防止某个日志文件变得特别大，而第一个参数是干嘛的呢？看到它传入的参数有两种：
GuaranteedLogger：提供保证日志行不会被删除。NonGuaranteedLogger：不保证日志记录。使用环缓冲区保存日志行。当环满时，插槽中的前一个日志行将被丢弃。即使环缓冲区已满，也不会阻止生产者。环缓冲区大小-日志行被推入由此参数确定大小的mpsc环缓冲区。由于每条日志行是256字节，所以ring_buffer_size = ring_buffer_size_mb * 1024 * 1024 / 256
使用的程序例子如下：
#include "NanoLog.hpp" int main() { // Ensure initialize is called once prior to logging. // This will create log files like /tmp/nanolog1.txt, /tmp/nanolog2.txt etc. // Log will roll to the next file after every 1MB. // This will initialize the guaranteed logger. nanolog::initialize(nanolog::GuaranteedLogger(), "./", "nanolog", 1); // Or if you want to use the non guaranteed logger - // ring_buffer_size_mb - LogLines are pushed into a mpsc ring buffer whose size // is determined by this parameter.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/333f39c3412476aebd0e19714bce5fd3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a80b704f3957b52d8447fcddc1fa4849/" rel="bookmark">
			Python下载新浪微博视频（流式下载）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 import requests print("开始下载") url = 'https://f.video.weibocdn.com/mMgApeOYlx07CJarSuxq01041200Yve80E010.mp4?label=mp4_720p&amp;template=1280x720.25.0&amp;trans_finger=1f0da16358befad33323e3a1b7f95fc9&amp;Expires=1588682762&amp;ssig=1D6G3huIlC&amp;KID=unistore,video' res = requests.get(url, stream=True) with open('D:/weibo/video/chenyuqi.mp4', "wb") as mp4: for chunk in res.iter_content(chunk_size=1024 * 1024):#当流下载时，用Response.iter_content或许更方便些。requests.get(url)默认是下载在内存中的，下载完成才存到硬盘上，可以用Response.iter_content　来边下载边存硬盘 if chunk: mp4.write(chunk) print("下载结束") 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ffe5e97fc2405ad81f933523351276a/" rel="bookmark">
			到底什么是Pipeline？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在各个领域，有一个词眼出现得越来越频繁，即 Pipeline。
开始接触的时候，百思不得其解，觉得作者在 用个 洋名字 在装 高大上，
其实，鲁迅先生说过一句话，太阳底下没有新鲜事
一切的一切，都是纸老虎，
Pipeline，你 土味一点 你把它 翻译成 一条龙服务
专业一点，叫 它 综合解决方案，就行。
算法或者大数据分析里的
可重复使用，针对新的数据，直接输入数据，可以得到结果。
一个典型的机器学习构建包含若干个过程
1、源数据ETL
2、数据预处理
3、特征选取
4、模型训练与验证
以上四个步骤可以抽象为一个包括多个步骤的流水线式工作，从数据收集开始至输出我们需要的最终结果。因此，对以上多个步骤、进行抽象建模，简化为流水线式工作流程则存在着可行性，对利用spark进行机器学习的用户来说，流水线式机器学习比单个步骤独立建模更加高效、易用。
管道机制在机器学习算法中得以应用的根源在于，参数集在新数据集（比如测试集）上的重复使用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6d9b18a517cca4cf737b0f338d331d9/" rel="bookmark">
			Google的开始
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		具体使用办法
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/167ce1a079f19a66c4bbfced805c44cf/" rel="bookmark">
			Android Sdk Manager not found 解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android Sdk Manager not found 解决方案
Android Sdk Manager not found 经常出现在Android Stdio 中出现
安装安卓证书的时候 报错Android Sdk Manager not found
可以用 flutter config --android-sdk sdk路径
例如我现在的路径是这样的
flutter config --android-sdk D:\flutter\sdk_1
输入完命令后 会告诉你他按照你的命令重新指定的SDK 的路径
在Terminal 中输入命令后 重启 Android Stdio 再安装安卓证书
flutter doctor --android-licenses
解决方案来源:https://www.pianshen.com/article/88761048687/;jsessionid=F751B7D132394B48519AF18C69E02EBD
吃水不忘挖井人，这个问题折磨了我2天！我终于再网上找到方案自主解决了它！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe7e46a62962eddaede9d2bc57e43655/" rel="bookmark">
			【笔试】python刷题笔记（基础）！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据结构与算法框架： 本人在b站的《剑指offer》讲解视频（比较通俗易懂的类型，当时代码能力一般，欢迎交流和批评指正）： https://www.bilibili.com/video/BV145411x76D
https://www.bilibili.com/video/BV1oi4y1G7eJ
1.while True 必须和break结合，无异常时执行try，异常时执行except，break退出循环。 while True: try: do something except: break 2.raw_input()与input() python2 存在raw_input()和input()两个函数
raw_input()将所有输入作为字符串看待，并且返回字符串类型
input()只用于数字的输入，返回所输入数字类型
python3 只存在input()函数，接收任意类型的输入，并且将输入默认为字符串类型处理，返回字符串类型，相当于python2的raw_input().
3.赋值a=b时，如果开辟新地址，b变化不会影响a；如果没有开辟新地址，则a、b做相同变化。 （1）可变对象、不可变对象： 可变对象：址传递，改变值不改变地址。（列表、字典、集合） 不可变对象：值传递，改变值必须改变地址。（数字、字符串、元组） （2）赋值、深拷贝和浅拷贝的区别: （深、浅拷贝分析的是可变对象情形下的的地址） 对于可变对象类型 List、Dictionary、Set，举例：列表alist和a： import copy a=[1,[2,3]] alist=a #赋值 alist=copy.copy(a) #浅拷贝 alist=copy.deepcopy(a) #深拷贝 alist.append(1) alist[0]=2 1）赋值：地址a和alist地址一样；改变alist，a作相同变化，。
2）copy.copy( )浅拷贝: 父对象开辟新地址，子对象地址不变。
3）copy.deepcopy( )深拷贝：父对象和子对象都开辟新地址。
4.链表 单向链表节点的表示：
class Node(object): #单向链表节点类 def __init__(self,data,next = None): self.data = data self.next = next 节点实例化：
node=Node('A',Node('B',Node('C'))) 整体：
5.位运算： a=60,b=13。 n小于0时，用补码表示：
if n &lt; 0: n = n &amp; 0xffffffff 6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe7e46a62962eddaede9d2bc57e43655/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1da690ffd21fdb5088e6f6188fd1b9de/" rel="bookmark">
			ASP.NET Core SignalR.NET 客户端
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、ASP.NET Core SignalR.NET 客户端
Asp.Net Core3.1的SignalR服务端应用，目前仅可以对接PC桌面版本的.Net Core 引用。
二、使用方式
1.创建 .Net Core wpf引用
2.安装客户端包
Install-Package Microsoft.AspNetCore.SignalR.Client 3.链接服务器
public partial class MainWindow : Window { HubConnection connection; public MainWindow() { InitializeComponent(); connection = new HubConnectionBuilder() .WithUrl("http://localhost:53353/ChatHub") .Build(); connection.Closed += async (error) =&gt; { await Task.Delay(new Random().Next(0,5) * 1000); await connection.StartAsync(); }; } private async void connectButton_Click(object sender, RoutedEventArgs e) { connection.On&lt;string, string&gt;("ReceiveMessage", (user, message) =&gt; { this.Dispatcher.Invoke(() =&gt; { var newMessage = $"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1da690ffd21fdb5088e6f6188fd1b9de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93467cdb9ae8e81c43be8854d136b798/" rel="bookmark">
			Asp.Net Core 3.1 SignalR 启动配置变化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Asp.Net Core 3.1 SignalR 启动配置变化
在.net Core 3.1版本不少的api使用方式发生变化。
在Asp.net Core 3.1中SignalR配置方式如下：
using System; using System.Collections.Generic; using System.Linq; using System.Threading.Tasks; using Microsoft.AspNetCore.Builder; using Microsoft.AspNetCore.Hosting; using Microsoft.AspNetCore.HttpsPolicy; using Microsoft.Extensions.Configuration; using Microsoft.Extensions.DependencyInjection; using Microsoft.Extensions.Hosting; using SignalRChat.Hubs; namespace SignalRChat { public class Startup { public Startup(IConfiguration configuration) { Configuration = configuration; } public IConfiguration Configuration { get; } // This method gets called by the runtime. Use this method to add services to the container.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/93467cdb9ae8e81c43be8854d136b798/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b597a072d05dc060f33cb2c2ab2843aa/" rel="bookmark">
			移动web开发——Flex布局详解极其便利之处
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.0传统布局和flex布局对比 1.1传统布局 + 兼容性好
+ 布局繁琐
+ 局限性，不能再移动端很好的布局
1.2 flex布局 + 操作方便，布局极其简单，移动端使用比较广泛+ pc端浏览器支持情况比较差+ IE11或更低版本不支持flex或仅支持部分 1.3 建议 + 如果是pc端页面布局，还是采用传统方式+ 如果是移动端或者是不考虑兼容的pc则采用flex 2.0 flex布局原理 + flex 是 flexible Box 的缩写，意为"弹性布局"，用来为盒状模型提供最大的灵活性，任何一个容器都可以指定为 flex 布局。+ 当我们为父盒子设为 flex 布局以后，子元素的 float、clear 和 vertical-align 属性将失效。+ flex布局又叫伸缩布局 、弹性布局 、伸缩盒布局 、弹性盒布局 + 采用 Flex 布局的元素，称为 Flex 容器（flexcontainer），简称"容器"。它的所有子元素自动成为容器成员，称为 Flex 项目（flexitem），简称"项目"。**总结**：就是通过给父盒子添加flex属性，来控制子盒子的位置和排列方式 3.0 父项常见属性 + flex-direction：设置主轴的方向+ justify-content：设置主轴上的子元素排列方式+ flex-wrap：设置子元素是否换行 + align-content：设置侧轴上的子元素的排列方式（多行）+ align-items：设置侧轴上的子元素排列方式（单行）+ flex-flow：复合属性，相当于同时设置了 flex-direction 和 flex-wrap 3.1 flex-direction设置主轴的方向 + 在 flex 布局中，是分为主轴和侧轴两个方向，同样的叫法有 ： 行和列、x 轴和y 轴+ 默认主轴方向就是 x 轴方向，水平向右+ 默认侧轴方向就是 y 轴方向，水平向下+ 注意： 主轴和侧轴是会变化的，就看 flex-direction 设置谁为主轴，剩下的就是侧轴。而我们的子元素是跟着主轴来排列的 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b597a072d05dc060f33cb2c2ab2843aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/671472403cc4b0c4e1b4ac44b590009c/" rel="bookmark">
			STM32——DAC生成正弦波
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include &lt;stdio.h&gt; #include "math.h" /* int main()//别人的 参考下 { int index=256; double out=0; double pi=3.1415; for (int i = 0; i &lt; index; i++) { out = ((sin((2*i*pi)/index)+1)*2047); printf("the buffer is:%lf",out); } return 0; } */ /* int main(int argc, char const *argv[])//一个完整的周期 { int index=255; float pi = 3.1415; int Fori=0; float outV; for (int Fori = 0; Fori &lt;= index; Fori++) { outV = sin(2*pi/index*Fori)*3300; printf("%lf\t",outV); if(!((Fori+1)%8)) printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/671472403cc4b0c4e1b4ac44b590009c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a80c517e6939c5c8405848665beb9fc/" rel="bookmark">
			接近8000字的Spring/SpringBoot常用注解总结！看完别忘记收藏！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		可以毫不夸张地说，这篇文章介绍的 Spring/SpringBoot 常用注解基本已经涵盖你工作中遇到的大部分常用的场景。对于每一个注解我都说了具体用法，掌握搞懂，使用 SpringBoot 来开发项目基本没啥大问题了！
为什么要写这篇文章？
最近看到网上有一篇关于 SpringBoot 常用注解的文章被转载的比较多，我看了文章内容之后属实觉得质量有点低，并且有点会误导没有太多实际使用经验的人（这些人又占据了大多数）。所以，自己索性花了大概 两天时间简单总结一下了。
整个目录如下，内容有点多：
因为我个人的能力和精力有限，如果有任何不对或者需要完善的地方，请帮忙指出！Guide 哥感激不尽！
@SpringBootApplication
这里先单独拎出@SpringBootApplication 注解说一下，虽然我们一般不会主动去使用它。 Guide 哥：这个注解是 Spring Boot 项目的基石，创建 SpringBoot 项目之后会默认在主类加上。
我们可以把 @SpringBootApplication看作是 @Configuration、@EnableAutoConfiguration、@ComponentScan 注解的集合。
根据 SpringBoot 官网，这三个注解的作用分别是：
@EnableAutoConfiguration：启用 SpringBoot 的自动配置机制
@ComponentScan：扫描被@Component (@Service,@Controller)注解的 bean，注解默认会扫描该类所在的包下所有的类。
@Configuration：允许在 Spring 上下文中注册额外的 bean 或导入其他配置类
2. Spring Bean 相关
2.1. @Autowired
自动导入对象到类中，被注入进的类同样要被 Spring 容器管理比如：Service 类注入到 Controller 类中。
2.2. Component,@Repository,@Service, @Controller
我们一般使用 @Autowired 注解让 Spring 容器帮我们自动装配 bean。要想把类标识成可用于 @Autowired 注解自动装配的 bean 的类,可以采用以下注解实现：
@Component ：通用的注解，可标注任意类为 Spring 组件。如果一个 Bean 不知道属于哪个层，可以使用@Component 注解标注。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a80c517e6939c5c8405848665beb9fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64b08fb9c5dde573ac70db735e114a5d/" rel="bookmark">
			python处理汉字出现的ordinal not in range(128)问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在nlp中我们总会在各种场景下处理汉字，尤其在预处理阶段。
一般常见的报错为“…ordinal not in range(128)”
那么常用解决方法的是以下两个：
1. 在代码开头 #-- coding:utf-8 --
2. 使用sys import sys
reload(sys)
sys.setdefaultencoding(‘utf-8’)
以上两个步骤是比较常规的操作，也能解决99%场景问题，但是总有一些小问题不容易解决，比如utf-8和汉字直接拼接，将汉字以“汉字的形式”写入、以汉字为key获取字典中的value等问题（问题出现的规律还未整理出来）。不过出现一些奇怪的编码问题可以尝试以下两种:
3.使用decode、encode text.decode(‘utf-8’)
4.使用json json.dumps()
欢迎有更系统的解决方案或者解释问题观点的同学们指点~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c43bc83ec90f2da06b168b7b4804f2e/" rel="bookmark">
			SpringBoot搭建WebSocket推送服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先说下简介，这是菜鸟教程上的说明：
WebSocket 是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。 WebSocket 使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。 在 WebSocket API 中，浏览器和服务器只需要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。 现在，很多网站为了实现推送技术，所用的技术都是 Ajax 轮询。轮询是在特定的的时间间隔（如每1秒），由浏览器对服务器发出HTTP请求，然后由服务器返回最新的数据给客户端的浏览器。这种传统的模式带来很明显的缺点，即浏览器需要不断的向服务器发出请求，然而HTTP请求可能包含较长的头部，其中真正有效的数据可能只是很小的一部分，显然这样会浪费很多的带宽等资源。 HTML5 定义的 WebSocket 协议，能更好的节省服务器资源和带宽，并且能够更实时地进行通讯。
在我们企业项目开发过程中，可能会遇到如下业务场景：推送、扫码、聊天、远程投放等。这些业务场景都有一个共同点那就是需要服务器主动发消息至客户端，如果服务器不主动发送消息，那么就需要客户端时时刻刻轮询地发HTTP请求来确认是否有自己的消息，这样的处理方式虽然可以达到解决问题的目的，但是并不优雅，而且频繁的请求也占用了过多的无效资源。目前大部分主流浏览器已经支持webSocket通讯方式，从而实现客户端和服务器实现长连接，服务器主动发消息至客户端，我们利用这一技术可以高效实现实际业务。我就以一个简单的Demo演示SpringBoot实现WebSocket服务。
SpringBoot对websocket的starter
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt; &lt;/dependency&gt; 另外是一些工具jar
&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.47&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;version&gt;3.5&lt;/version&gt; &lt;/dependency&gt; 1.开启SpringBoot对webSocket的支持 /** * @ClassName: WebSocketConfig * @Description: socket配置,打开webSocket的支持 * @author wangzhi * @date 2019年11月25日 */ @Configuration public class WebSocketConfig { @Bean public ServerEndpointExporter serverEndpointExporter() { return new ServerEndpointExporter(); } } 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c43bc83ec90f2da06b168b7b4804f2e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46799be4cffe4a8dd8eeea9d8401b5ba/" rel="bookmark">
			Ubuntu18.04 操作分屏显示快捷键
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		了解快捷键能够提升您的生产力。这里有一些实用的 Ubuntu 快捷键助您像专业人士一样使用 Ubuntu。
您可以用键盘和鼠标组合来使用操作系统。
注意：本文中提到的键盘快捷键适用于 Ubuntu 18.04 GNOME 版。 通常，它们中的大多数（或者全部）也适用于其他的 Ubuntu 版本，但我不能够保证。
实用的 Ubuntu 快捷键 让我们来看一看 Ubuntu GNOME 必备的快捷键吧！通用的快捷键如 Ctrl+C（复制）、Ctrl+V（粘贴）或者 Ctrl+S（保存）不再赘述。
注意：Linux 中的 Super 键即键盘上带有 Windows 图标的键，本文中我使用了大写字母，但这不代表你需要按下 shift 键，比如，T 代表键盘上的 ‘t’ 键，而不代表 Shift+t。
1、 Super 键：打开活动搜索界面
使用 Super 键可以打开活动菜单。如果你只能在 Ubuntu 上使用一个快捷键，那只能是 Super 键。
想要打开一个应用程序？按下 Super 键然后搜索应用程序。如果搜索的应用程序未安装，它会推荐来自应用中心的应用程序。
想要看看有哪些正在运行的程序？按下 Super 键，屏幕上就会显示所有正在运行的 GUI 应用程序。
想要使用工作区吗？只需按下 Super 键，您就可以在屏幕右侧看到工作区选项。
2、 Ctrl+Alt+T：打开 Ubuntu 终端窗口
使用 Ctrl+alt+T 来打开终端窗口
想要打开一个新的终端，您只需使用快捷键 Ctrl+Alt+T。这是我在 Ubuntu 中最喜欢的键盘快捷键。 甚至在我的许多 FOSS 教程中，当需要打开终端窗口是，我都会提到这个快捷键。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/46799be4cffe4a8dd8eeea9d8401b5ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/685a9f22f42b113a310f1675a55339b9/" rel="bookmark">
			C语言·编写一个程序，要求输入ASCII码，打印出字符。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目：编写一个程序，要求输入一个ASCII码值（如66），然后打印输入字符。
#include&lt;stdio.h&gt; int main(void) { int a; printf("请输入一个ASCII\n"); scanf("%d",&amp;a); printf("它是字符\"%c\"\n",a); return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c14fde895f86c29e7a19dd3fefb4b166/" rel="bookmark">
			Android之ERROR: Failed to resolve: com.github.CymChad:BaseRecyclerViewAdapterHelper:2.9.22 Show....问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考：https://blog.csdn.net/qq_33210042/article/details/88925537
1、问题缘由：在此处添加了如下代码：
2、问题详情：
3、解决方法：在如下两处标注处添加代码：maven { url "https://jitpack.io" }
4、最终情况：
5、至此，结束。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/135bd407902060718965f798f02ec799/" rel="bookmark">
			python中time库的使用，time(),ctime(),gmtime(),strftime(),strptime(),perf_counter()
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		time.time() 获取当前时间，表现为1970年起至现在的秒数
date = time.strftime(’%Y_%m_%d’,time.localtime(time.time())) 格式化中，字母的大小写代表的含义不同
import datetime
import time
class GetTime:
@staticmethod
def get_yesterday():
today = datetime.date.today()
yesterday = today + datetime.timedelta(days=-1)
yesterday.isoformat()
return yesterday
@staticmethod def get_today(): today = datetime.date.today() today = str(today) return today @staticmethod def get_tomorrow(): today = datetime.date.today() tomorrow = today + datetime.timedelta(days=1) tomorrow = str(tomorrow) return tomorrow @staticmethod def get_this_monday(): today = datetime.date.today() this_monday = today - datetime.timedelta(days=today.weekday()) this_monday.isoformat() this_monday = str(this_monday) return this_monday @staticmethod def get_this_sunday(): today = datetime.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/135bd407902060718965f798f02ec799/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0a3dc7c754d1a9eea5872bc0046804d/" rel="bookmark">
			有关爬虫加载Ajax数据或请求json数据集的(快速高效)方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说明： 以下内容针对现有网站大部分数据集使用Ajax异步加载数据，导致直接请求下来的html页面没有此部分数据（selenium等前端自动化测试爬虫除外）接下来，针对这些数据集（可能是json或其他格式的数据）做模拟请求，绕过加载html页面的步骤直接拿到数据。
首先，来了解以下http/https请求的构造 HTTP协议（HyperText Transfer Protocol，超文本传输协议）：是一种发布和接收 HTML页面的方法。
HTTPS（Hypertext Transfer Protocol over Secure Socket Layer）简单讲是HTTP的安全版，在HTTP下加入SSL层。
SSL（Secure Sockets Layer 安全套接层）主要用于Web的安全传输协议，在传输层对网络连接进行加密，保障在Internet上数据传输的安全。 HTTP的端口号为80，
HTTPS的端口号为443
基本格式： scheme://host[:port#]/path/…/[?query-string][#anchor]
scheme：协议(例如：http, https, ftp)host：服务器的IP地址或者域名port#：服务器的端口（如果是走协议默认端口，缺省端口80）path：访问资源的路径query-string：参数，发送给http服务器的数据anchor：锚（跳转到网页的指定锚点位置）
例如：ftp://www.ceaqw.cn/page?pageIndex=2http://www.baidu.comhttp://item.jd.com/11936238.html#product-detail 常用的请求报头（此部分来源于网络查找） 1. Host (主机和端口号) Host：对应网址URL中的Web名称和端口号，用于指定被请求资源的Internet主机和端口号，通常属于URL的一部分。
2. Connection (链接类型) Connection：表示客户端与服务连接类型
Client 发起一个包含 Connection:keep-alive 的请求，HTTP/1.1使用 keep-alive 为默认值。
Server收到请求后：
如果 Server 支持 keep-alive，回复一个包含 Connection:keep-alive 的响应，不关闭连接；
如果 Server 不支持 keep-alive，回复一个包含 Connection:close 的响应，关闭连接。
如果client收到包含 Connection:keep-alive 的响应，向同一个连接发送下一个请求，直到一方主动关闭连接。
keep-alive在很多情况下能够重用连接，减少资源消耗，缩短响应时间，比如当浏览器需要多个文件时(比如一个HTML文件和相关的图形文件)，不需要每次都去请求建立连接。
3. Upgrade-Insecure-Requests (升级为HTTPS请求) Upgrade-Insecure-Requests：升级不安全的请求，意思是会在加载 http 资源时自动替换成 https 请求，让浏览器不再显示https页面中的http请求警报。
HTTPS 是以安全为目标的 HTTP 通道，所以在 HTTPS 承载的页面上不允许出现 HTTP 请求，一旦出现就是提示或报错。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d0a3dc7c754d1a9eea5872bc0046804d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/807720a3e283e23eee5f0f17c27b3d0b/" rel="bookmark">
			kali_Linux下安装zlib命令。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 zlib的命令安装就三条 sudo apt-get install ruby sudo apt-get install zlib1g sudo apt-get install zlib1g.dev 用下面这条命令检查是否安装好了，安装好了就会显示出对应的本地路径。
whereis zlib 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1bccb7672ef9ae55dfd315cd7e8cf268/" rel="bookmark">
			【计算机组成原理】溢出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么叫溢出呢？
就是计算出的数超过了缓冲区的范围，导致部分数值丢失的操作。
比如说n+1位定点整数X的补码的表示范围就是：
-2n ≤ X &lt;2n
上面这道例题看上去一点问题也没有奥，但是再一看题干你就会发现：两个正数相加，结果怎么就变成负数了？
同样带着这个问题往下看，
类似的问题又出现了：两个负数相加，结果怎么就变成正数了？
这里就涉及到了一开始提到的溢出问题，
第一道例题产生了正溢出，也就是说两个正整数相加之和大于所能表示的最大的数；
同理，第二道例题产生了负溢出，也就是说两个负整数相加之和小于所能表示的最小的数
在之后的计算中，如果能事先判断好是否会产生溢出，就会省很大的计算量，下面介绍两种方法：
双符号位补码法
对带着符号位的补码进行计算：
①如果计算结果前两位是00，就是正数。
②如果计算结果前两位是11，就是负数。
③如果计算结果前两位是01，就是正溢出。
④如果计算结果前两位是10，就是负溢出。
（注：无论溢出与否，最高位都表示正确的符号）单符号位法
①最高有效位有进位，符号位无进位→正溢出
②最高有效位无进位，符号位有进位→负溢出 下面举例说明双符号位补码法用法，
下面举例说明单符号位法用法，
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b9df17876232c0fa8ab35c1c4dca3fb/" rel="bookmark">
			refineNet_multi-path refinement network for high-resolution semantic seg
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0. 写作目的 好记性不如烂笔头。
1. 问题 下采样导致损失了细节信息。
2. 解决方法 高层的信息和低层的信息都有用。 作者对所有的信息都使用。
3. 模型 具体细节：
2x表示使用两次 RCU。逐层进行使用refineNet，如图2中的C图所示，对于下采样32倍的feature，refineNet只有一个输入。对于其他的refineNet则有两个输入。
Chained Res Pooling： 使用的是 Maxpooling，实验中使用2次pooling，步长为1。 目的在于提取背景上下文。（感觉就是提高感受野，融合全局信息）
模型的不同扩展： 4. 实验结果 在多个实验结果上效果很好。这是实验结果都是使用multi-scale 测试的。
消融实验： 不同扩展模型的实验： 注：文中图片来源于paper。
There may be some mistakes in this blog. So, any suggestions and comments are welcome!
[Reference] paper: https://arxiv.org/abs/1611.06612
code: https://github.com/guosheng/refinenet
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/500147e1bf167711509552a69f660db0/" rel="bookmark">
			7.6.2版本ES报错：org.elasticsearch.client.Cancellable
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【001 】报错：Caused by: java.lang.ClassNotFoundException: org.elasticsearch.client.Cancellable
【002 】 报错说的什么意思？ 类未找到异常 ，找不到的是 org.elasticsearch.client.Cancellable
【003】最终解决： 把低版本的依赖进（ava Low Level REST Client）来即可，同时排除掉低版本的依赖
【依赖如下可解决报错】：
&lt;dependency&gt; &lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt; &lt;artifactId&gt;elasticsearch-rest-client&lt;/artifactId&gt; &lt;version&gt;7.6.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt; &lt;artifactId&gt;elasticsearch-rest-high-level-client&lt;/artifactId&gt; &lt;version&gt;7.6.2&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;elasticsearch-rest-client&lt;/artifactId&gt; &lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; 如果有用点个赞，没用的话路过即可
打开看看 ctrl+N (org.elasticsearch.client.Cancellable) 7.6.2 下面的 只是个属性，确实没有，
再打开类 Cancellable，确实有，那么这个是不是依赖造成的呢？ 结合官网上的说明
The Java High Level REST Client works on top of the Java Low Level REST client
high的是建立在low的基础上，那么引进低的，排除一下依赖
详见官网说明：
https://www.elastic.co/guide/en/elasticsearch/client/java-rest/7.6/java-rest-high.html
6.8.7的有这个接口
报错如下：
官网实际上已有答案 高版本依赖低版本
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81a6a40f468407f57d2376258f62f9db/" rel="bookmark">
			基于canal的实时数据同步架构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		技术背景
数据同步作为数仓建设和数据分析的基础环节，其重要性不言而喻。目前业界最常用的做法是离线按天备份，通过批处理的方式直连业务库，将数据全量导入到数仓。这种方式简单直接，不会担心数据丢失等问题。然而因为是离线操作，每一次导入都是对过去一天的数据镜像，对于实时应用场景，无法及时同步新增数据，而且频繁的读取业务库很容易对业务库造成压力。对于我们的特殊场景：从阿里云跨云同步到AWS，这种大批量的数据同步耗费流量不说，数据同步耗时和网络抖动造成的连接中断、延时等问题更是不可忽视。此外对于大量的分库分表的同步，如果处理不好，还会带来新的问题比如上层业务的分表合并等，那有没有一种更好的方式呢？当然有！我们知道基于binlog的mysql实时主从同步技术已经相当成熟，同样binlog也可以用来做异构数据源之间的数据同步。canal就是这样的系统，用于mysql数据同步到mysql、mq，elasticsearch、mongodb、hbase等系统。在详细介绍基于canal的数据同步系统架构之前，先简单回顾下canal的基本原理。
canal原理
binlog介绍
binlog是Mysql sever层维护的一种二进制日志，与innodb引擎中的redo/undo log是完全不同的日志；其主要是用来记录对mysql数据更新或潜在发生更新的SQL语句，并以"事务"的形式保存在磁盘中；Mysql binlog日志有ROW,Statement,MiXED三种格式：
Row: 仅保存记录被修改细节，不记录sql语句上下文相关信息优点：能非常清晰的记录下每行数据的修改细节，不需要记录上下文相关信息。由于所有的执行的语句在日志中都将以每行记录的修改细节来记录，因此，可能会产生大量的日志内容。
Statement: 每一条会修改数据的sql都会记录在binlog中优点：只需要记录执行语句的细节和上下文环境，避免了记录每一行的变化。但是存在某些函数和存储过程不一定能够保证在slave上和master上执行结果一致。
Mixed:以上两种格式的结合。不过，新版本的MySQL对row level模式也被做了优化，并不是所有的修改都会以row level来记录，像遇到表结构变更的时候就会以statement模式来记录，如果sql语句确实就是update或者delete等修改数据的语句，那么还是会记录所有行的变更；因此，现在一般使用row level即可。
通过变量binlog_format查看当前binlog格式：
binlog的位置由文件和文件的相对位置唯一确定，我们可以通过命令行查询binlog的内容：
数据库的主从复制是binlog的用途之一，其原理为：
MySQL master 将数据变更写入二进制日志
MySQL slave 将 master 的 binary log events 拷贝到它的中继日志(relay log)
MySQL slave 重放 relay log 中事件，将数据变更反映它自己的数据
canal简介
作为阿里巴巴的一个开源项目，canal 不仅在公司内部经受了跨集群、跨国同步的考验，而且已经在很多大型的互联网公司比如美团等都有广泛的应用。
canal是通过模拟成为mysql 的slave的方式，监听mysql 的binlog日志来获取数据并转存到不同的目的地（destination）。
canal架构
canal server是canal的基本部署实例，在实现上一个canal server 部署实例由多个binlog数据通道实例组成的。canal server就是一个jvm运行实例，
binlog数据通道实例由Parser、Sink和store模块组成，完成binlog的解析、过滤和存储一整条链路功能。跟binlog数据通道的关系为：
其中数据通道实例的逻辑拓扑结构可表示为：
canal部署
数据通道实例默认跟数据库实例一一对应，每个通道实例在部署上有自己独立的属性配置目录，目录里面维护两类配置文件：
&lt;mysql-name&gt;-instance.properties：配置数据库的连接信息和过滤配置等信息
canal.properties：作为所有数据通道的公共部分，用于配置全局性的信息，如mq地址、zk地址以及cannal server运行时参数等
canal server负责本实例上的所有数据通道的可用性，采用pull的消费模型供canal客户端读取消息。在部署上面，可以单独部署，在生产环境上，建议采用HA高可用部署方案：
大致步骤为：
1. canal server要启动某个canal instance时都先向zookeeper进行一次尝试启动判断 (实现：创建EPHEMERAL节点，谁创建成功就允许谁启动)
2. 创建zookeeper节点成功后，对应的canal server就启动对应的canal instance，没有创建成功的canal instance就会处于standby状态
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/81a6a40f468407f57d2376258f62f9db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8fc560cc0a57825ce983dd655aa12df1/" rel="bookmark">
			Windows中安装和配置多个Python3环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Windows下可以安装多个Python3环境，例如安装两个Python3环境，一个为Python3.7，另一个为Python3.8.
通过py进行选择 查看可用版本
py -0 # 输出 *号表示选中 -3.8-64 * -3.7-64 选中python 3.7环境
#直接启动python3.7 环境 py -3.7 #使用指定版本运行python脚本 py -3.7 python-script.py 例如，编写一个python脚本用于打印python版本编号
import platform print(platform.python_version()) 控制台输出
py -3.7 .\hello-python.py 3.7.6 py -3.8 .\hello-python.py 3.8.1 修改环境变量 把目标环境的环境变量设置提前，这种方式比较简单直接。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ebf82cc733db8ea7fb353c04e3c7f571/" rel="bookmark">
			Visual Studio Code中指定netcore启动类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 直接编辑csproj文件 例如，原启动类为Program，该类位于Program.cs文件中。更改后的启动类为ProgramTask，该类位于ProgramTask.cs文件中。
&lt;Project Sdk="Microsoft.NET.Sdk"&gt; &lt;PropertyGroup&gt; &lt;OutputType&gt;Exe&lt;/OutputType&gt; &lt;TargetFramework&gt;netcoreapp3.1&lt;/TargetFramework&gt; &lt;!-- &lt;StartupObject&gt;AsyncAwaitDemo.Program&lt;/StartupObject&gt; --&gt; &lt;StartupObject&gt;AsyncAwaitDemo.ProgramTask&lt;/StartupObject&gt; &lt;/PropertyGroup&gt; &lt;/Project&gt; 注意点 StartupObject中应指定类名，而不是文件名。不要写成Program.cs或者ProgramTask.csStartupObject需要包含namespace，不可以只设置Program 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7738236a40a76e4019cfa5b597ac5cd/" rel="bookmark">
			web安全--Xml外部实体注入漏洞(XXE)与防护
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Xml外部实体注入(XXE) 除了json外，xml也是一种常用的数据传输格式。对xml的解析有以下几种常用的方式：DOM，SAX，JDOM，DOM4J，StAX等。然而这几种解析方式都可能会出现外部实体注入漏洞，如微信支付的回调就出现过（见参考资料2）。
XML文档结构包括xml声明，DTD文档类型定义(可选)和文档元素，如下图所示： DTD的作用是定义XML文档的合法构建模块，可以在XML文档内声明，也可以外部引用。当DTD引用外部实体，而外部实体中含有恶意代码时，就可能会在解析xml时执行外部实体中的恶意代码。这就是xml外部实体注入。
举个简单的栗子如下图所示： 这里通过引用外部实体，读取了/etc/passwd。详细的例子见参考资料1。
XXE防护 DOM解析防护(JAXP DocumentBuilderFactory, SAXParserFactory and DOM4J)
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException; // catching unsupported features
DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
String FEATURE = null;
try {
// 首要选择。不允许DTDs，几乎可以阻止所有的XML实体攻击
FEATURE = "http://apache.org/xml/features/disallow-doctype-decl";
dbf.setFeature(FEATURE, true);
} catch (ParserConfigurationException e) {
// This should catch a failed setFeature feature
logger.info("ParserConfigurationException was thrown. The feature '" +
FEATURE + "' is probably not supported by your XML processor.");
} catch (SAXException e) {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7738236a40a76e4019cfa5b597ac5cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ede2b18083047101a0ad4ee0c4a76404/" rel="bookmark">
			从小米科技的创始人、董事长、首席执行官雷军的代码水平说起
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作为小米科技的创始人、董事长和首席执行官，雷军的名字如雷贯耳。那么作为技术员出身的雷军，他的代码水平如何，最近也成为网上的一个热点议题。
伴随这个热点议题一起出现的是雷军写于1994年的RAMinit程序源码。
;
（完整代码附后）
看到那份用汇编语言写的源代码，备感亲切，因为我也喜欢用汇编语言来写程序，而且写过这类DOS下的TSR（Terminate and Stay Resident，常驻内存）程序，也喜欢用.com格式（DOS下有64KB的长度限制）。
评价源代码质量，至少可以从三个指标来衡量，一是算法效率；二是模块化水平，包括函数、过程的封装，全局变量、局部变量的设定等；三是代码可读性，也就是代码风格，如函数、过程、变量的命名规则，特别是注释。后两个指标直接影响到程序的维护和升级。
第一次看源代码，首先感受到的就是代码可读性，这对于汇编语言尤其明显，如果代码没有完善的注释，看代码无异于读天书。
在DOS时代，代码规模不大，可以一个人独立完成，因此代码风格往往凭个人喜好，因人而异。
说到使用汇编语言的牛人，不得不提Anders Hejlsberg（安德斯·海尔斯伯格，1960.12~），用汇编语言写编译器。Turbo Pascal编译器的主要作者，Delphi、C#和TypeScript之父，同时也是.NET创立者。我最直接的感受是，同一个8086汇编源码，用TASM生成的可执行文件会比MASM生成的小，同一个Delphi源码，有Delphi2生成的可执行文件比Delphi5生成的小。
关于Anders Hejlsberg，可以看看李维先生写的《Borland传奇》。《Borland传奇》有电子工业出版社于2003-04 出的第一版和水利电力出版社于2004-06出的第二版，价格均为￥28.00。上Kongfz上查了一下，第一版卖得便宜，第二版比卖得比原价还高。
附完整代码
; RI.ASM Revision 2.12 [ July 12, 1994 ] Revision equ 'V2.12 ' ; ; ************************************************************************** ; * * ; * RAMinit Release 2.0 * ; * Copyright (c) 1989-1994 by Yellow Rose Software Co. * ; * Written by Mr. Leijun * ; * * ; * Function: * ; * Press HotKey to remove all TSR program after this program * ; * * ; ************************************************************************** ; .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ede2b18083047101a0ad4ee0c4a76404/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e882150c5fe7cefc0c5edc0f180314a/" rel="bookmark">
			深度学习 实验七 循环神经网络
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 深度学习 实验七 循环神经网络一、问题描述二、设计简要描述三、程序清单 深度学习 实验七 循环神经网络 一、问题描述 之前见过的所以神经网络（比如全连接网络和卷积神经网络）都有一个主要特点，那就是它们都没有记忆。它们单独处理每个输入，在输入和输入之间没有保存任何状态。对于这样的网络，要想处理数据点的序列或者时间序列，你需要向网络同时展示整个序列，即将序列转换成单个数据点。例如，在实验九词嵌入中就是这么做的：将全部电影评论转换为一个大向量，然后一次性处理。
与此相反，当人在阅读这个句子时，是一个词一个词地阅读（或者说，眼睛一次扫视一次扫视地阅读），同时会记住之前的内容，这让你能够动态理解这个句子所传达的含义，以渐进的方式处理信息，同时保存一个关于所处理的内部模型，这就是循环神经网络，它广泛应用于自然语言处理中，本实验会介绍简单的循环神经网络（SimpleRNN）来处理文本数据，然后改进网络使用LSTM神经网络对比效果。
二、设计简要描述 1. 简单循环神经网络
1.1 循环网络简介
了解循环网络的应用基础知识。
1.2 Keras中的循环层
实现一个简单的RNN层
1.3 数据处理
使用IMDB电影评论的数据，引入一个sequence模块把我们的数据格式化输入到神经网络中。
1.4 搭建自己RNN神经网络
按照如下步骤搭建自己的神经网络并应用上面数据拟合模型
1）从kaeras导入全连接层模块
2）定义一个序列模型
3） 添加一个Embedding层，参数是（max_features,32）
4）添加一个SimpleRNN层，输出维度32
5）添加一个全连接层，输出维度1，激活函数‘sigmoid’
6）编译模型，参数分别是‘rmsprop’,’binary_crossentropy’,[‘acc’]
7）拟合模型，epochs=10.batch_size=128,validation_split=0.2，结果返回给history
1.5 绘制结果
绘制训练损失和准确率率结果。
1.6 模型评估
利用测试数据对模型进行评估。
2. LSTM循环神经网络
2.1 SimpleRNN的缺陷
了解SimpleRNN存在梯度消失的情况，可能导致后续模型无法继续训练。
2.2 LSTM分析
2.3 搭建自己的LSTM神经网络
类似1.4节按照以下步骤搭建自己的LSTM神经网络。
1）从kaeras导入LSTM模块
2）定义一个序列模型
3）添加一个Embedding层，参数是（max_features,32）
4）添加一个LSTM层，输出维度32
5）添加一个全连接层，输出维度1，激活函数‘sigmoid’
6） 编译模型，参数分别是‘rmsprop’,’binary_crossentropy’,[‘acc’]
7）拟合模型，epochs=10.batch_size=128,validation_split=0.2，结果返回给history
2.4 绘制结果
参考1.5节绘制损失值和准确率的结果图。
2.5 模型评估
利用测试数据对模型进行评估。
三、程序清单 # test7_循环神经网络 # 1. 简单循环神经网络 # 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e882150c5fe7cefc0c5edc0f180314a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9be8d75b17debd9aa056250e7512fbe5/" rel="bookmark">
			vba模拟键盘鼠标操作和窗口激活
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		键盘鼠标操作 Public Declare Sub mouse_event Lib "user32" (ByVal dwFlags As Long, _ ByVal dx As Long, ByVal dy As Long, ByVal cButtons As Long, ByVal dwExtraInfo As Long) Public Declare Function GetCursorPos Lib "user32" (lpPoint As POINTAPI) As Long Public Declare Function SetCursorPos Lib "user32" (ByVal x As Long, ByVal y As Long) As Long Public Const MOUSEEVENTF_MOVE = &amp;H1 Public Const MOUSEEVENTF_LEFTDOWN = &amp;H2 Public Const MOUSEEVENTF_LEFTUP = &amp;H4 Public Const MOUSEEVENTF_RIGHTDOWN = &amp;H8 Public Const MOUSEEVENTF_RIGHTUP = &amp;H10 Public Const MOUSEEVENTF_MIDDLEDOWN = &amp;H20 Public Const MOUSEEVENTF_MIDDLEUP = &amp;H40 Public Const MOUSEEVENTF_ABSOLUTE = &amp;H8000 Type POINTAPI x As Long y As Long End Type Sub saveTextFile() Dim Cp As POINTAPI GetCursorPos Cp	'save now cursor's address to Cp SetCursorPos Cp.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9be8d75b17debd9aa056250e7512fbe5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c652e00fce0a0c8179d2902355a356d8/" rel="bookmark">
			ubuntu18.04更新源失败，“无法安全地用该源进行更新，所以默认禁用该源”的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ubuntu18.04更新源失败，“无法安全地用该源进行更新，所以默认禁用该源”的解决办法 今天五一劳动节，放假在家继续劳动。 今天有个网友私信了个问题，说自己的ubuntu18.04系统下无法安装gcc，源无法正常使用：
无论是换成Tsinghua的源还是阿里的源都有同样的问题，一直报如下错误：
这种“无法安全地用该源进行更新，所以默认禁用该源”的错误网上有不少文章给出了解决方案，主要是采用以下两种方案进行排查：
1. 找到没有Release文件的源对应的行，在sources.list文件中删除该行；
2. 删除etc/apt/sources.list.d 目录下的所有文件。
但这次的问题通过以上两种方式操作后没有任何效果。
通过查看报错信息和/etc/apt/sources.list文件可发现，是这位网友在手敲sources.list文件时未按该文件要求的规则进行，导致apt-get update命令无法解析配置，从而报错。
正确的语法规则为：
deb http://mirrors.163.com/ubuntu/ bionic main restricted universe multiverse deb http://mirrors.163.com/ubuntu/ bionic-security main restricted universe multiverse 而这位网友写成了：
deb http://mirrors.163.com/ubuntu/bionic main restricted universe multiverse deb http://mirrors.163.com/ubuntu/bionic-security main restricted universe multiverse 二者仅一个空格之差，却导致了天壤之别，这也同时说明了未理解sources.list中各字段的含义。
（不过很少有人手动去敲这个文件吧，不都是ctrl+c，ctrl+v么~）
将sources.list文件中的配置改正后，再执行以下命令即可正常安装gcc了：
# apt-get update # apt-get install gcc 问题很简单，通过添加一个空格就可解决，但我觉得还是有必要记录下来，一是给类似问题提供一个解决思路，再一个希望能引导大家去深入理解一下linux各项功能实现的背后机理。
最后也希望大家在手敲代码时一定要认真仔细，否则出错真的不好排查。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/394008bd9a6c12a23f79a193db4060e9/" rel="bookmark">
			vue-router的两种模式（hash和history）及区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		URL的hash
URL的hash URL的hash也就是锚点(#), 本质上是改变window.location的href属性. 我们可以通过直接赋值location.hash来改变href, 但是页面不发生刷新
HTML5的history模式：
history接口是HTML5新增的, 它有五种模式改变URL而不刷新页面.
history.pushState()
history.replaceState()
history.go()
补充说明： 上面只演示了三个方法 因为
history.back() 等价于 history.go(-1)
history.forward() 则等价于 history.go(1)
这三个接口等同于浏览器界面的前进后退。 为什么要有hash 和history？
对于Vue这类渐进式前端开发框架，为了构建SPA（单页面应用），需要引入前端路由系统，这也就是Vue-Router存在的意义。前端路由的核心，就在于——改变试图的同时不会向后端发出请求。
为了达到这一目的，浏览器当前提供了一下两种支持：
1：hash - 即地址栏URL中的 # 符号（此hash不是密码学里的散列运算）
比如这个URL：http：//www.abc.com/#/hello,hash的值为#/hello.它的特点在于：hash虽然出现在URL中，但不会被包括在HTTP请求中，对后端完全没有影响，因此改变hash不会重新加载页面。
2：history - 利用了HTML5 History Interface中新增的pushState()和replaceState（）方法。（需要特定浏览器支持）
这两个方法应用于浏览器的历史记录栈，在当前已有的back、forward、go的基础上，它们提供了对历史记录进行修改的功能。只是当它们执行修改时，虽然改变了当前的URL，但浏览器不会即向后端发送请求。
因此可以说，hash模式和histoury模式都是属于浏览器自身的特性，Vue-Router只是利用了这两个特性（通过调用浏览器提供的接口）来实现前端路由
使用场景
一般情景下，hash和histoury都可以，除非你更在意颜值，#符号夹杂在URL里看起来确实有些不太美丽。如果不想要很丑的hash，我们可以用路由的history模式，这种模式充分利用history。pushState API来完成URL跳转二无须重新加载页面。
调用history.pushState()相比于直接修改hash ，存在以下优势：
1：pushState()设置的新URL可以是与当前URL同源的任意URL；而hash只可修改#后面的部分，因此只能设置与当前URL同文档的URL；
2：pushState()设置的新URL可以与当前URL一模一样，这样也会把记录添加到栈中；而hash设置的新值必须与原来不一样才会触发动作将记录添加到栈中；
3：pushState()通过stateObject参数可以添加任意类型的数据到记录中；而hash只可添加短字符串；
4：pushState()可额外设置title属性供后续使用。
当然history也不是样样都好。SPA虽然在浏览器里游刃有余，单真要通过URL向后端发起HTTP请求时，两者的差异就来了。尤其在用户手动输入URL后回车，或者刷新（重启）浏览器的时候。
1：hash 模式下，仅hash符号之前的内容会被包含在请求中，如http://www.abc.com,因此对于后端来说，即使没有做到对路由的全覆盖，也不会返回404错误。
2：history模式下，前端的URL必须和实际向后端发起请求的URL一致。如htttp://www.abc.com/book/id。如果后端缺少对/book/id 的路由处理，将返回404错误
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/623f2c25c1abd29a1da0b154448a8765/" rel="bookmark">
			springboot&#43;vue 旅游信息管理系统（四）景点信息的增加、删除、修改、展示的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		旅游信息管理系统 景点信息的增加、删除、修改、展示的实现 前言
代码已上传至github：https://github.com/kalipoison/travelManageSystem 由于上传文件使用base64编码之后，mysql可能存储不下，小编实验结论是小于20k的文件都可以成功上传
流程
com.gohb.travels.Controller.PlaceController代码如下： package com.gohb.travels.Controller; import com.gohb.travels.entity.Place; import com.gohb.travels.entity.Result; import com.gohb.travels.service.PlaceService; import org.apache.commons.io.FilenameUtils; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.beans.factory.annotation.Value; import org.springframework.util.Base64Utils; import org.springframework.web.bind.annotation.*; import org.springframework.web.multipart.MultipartFile; import java.io.File; import java.io.IOException; import java.text.SimpleDateFormat; import java.util.Date; import java.util.HashMap; import java.util.List; import java.util.Map; @RestController @CrossOrigin @RequestMapping("place") public class PlaceController { @Autowired private PlaceService placeService; @Value("${upload.dir}") private String realPath; /** * 修改景点信息 */ @PostMapping("update") public Result update(MultipartFile pic, Place place) throws IOException { Result result = new Result(); try{ //对接收文件做base64 String picpath = Base64Utils.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/623f2c25c1abd29a1da0b154448a8765/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95be7b44eb373264afa67508b68ca2c3/" rel="bookmark">
			pandas搭配openpyxl进行excel读写操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一：前言 因为有个项目需要批量处理excel 文件，进行分组导出并求和。因此我就想到使用pandas 来进行数据的处理， 使openpyxl 来进行数据的保存，以及导出excel文件并且对excel 文件进行格式化以及美化操作。
二：步骤 2.1 使用pandas进行分组求和 有着像这样的数据
我要做的就n是将每个客户的数据导出到独立的文件夹中，并计算金额
首先，使用
data_g = data.groupby("客户名称")
这样就可以分出每一个客户了。
data_g_sum = data_g["金额"].sum()
保存写入数据
for i in data_g:
i[1].to_excel(dir) # dir为目标xlsx文件路径
2.2 使用openpyxl 进行打开文件并保存文件 2.2.1 如果使用未创建的excel 需要先创建 from openpyxl import Workbook
wb = Workbook() # 创建一个Workbook对象
ws = wb.active # 选取wb对象中活动的对象，默认为第一个sheet
# 或者 ws1 = wb.create_sheet("Sheet", 0) 插入第一张sheet
2.2.2 如果打开已经存在的文件 wb = openpyxl.load_workbook(dir)
sheet = wb.active
2.2.3 保存文件 #使用
wb.save(dir) # dir 为输出的xlsx文件路径
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/95be7b44eb373264afa67508b68ca2c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c5d9b06584ed08e8de8c7d0fff172ef/" rel="bookmark">
			Shell脚本的美元符（$）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Shell脚本最让人头疼的地方就是诡异的语法以及鬼画符一般的特殊符号。这里总结了一下笔者经常见到的美元符的用法：
$? ：上个已执行命令的退出状态码，0~125之间，0即正常退出
$# ：传递给脚本的参数数量
$@或 $*：以一个字符串保存传给脚本的所有参数
$0：脚本本身的名字，如有必要，使用时可结合 ‘basename’ 指令
$1~9：传给脚本的参数，分别对应第几个参数
${大于等于10的数字}：因为$1~9只能处理9个参数，大于9个时，需要加一个花括号
$()：执行括号内的命令
$[ operation ]：美元符+方括号，执行数学表达式，这样就不用担心shell会误解乘号或其他特殊符号
${}：变量取值，同 $+变量
参考资料： Richard Blum 等. Linux命令行与脚本编程大全. 北京：人民邮电出版社，2016.8 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f52ce0a40d8e0589fe66c925010e9e7c/" rel="bookmark">
			硬件电路设计之——DC-DC上电时电压输出尖峰电压
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		硬件电路设计之——DC-DC上电时电压输出尖峰电压 发现问题 在使用XL1509-5.0E时发现，当电源在上电瞬间会出现一个上升到 8V的尖峰电压。使用的STC单片机好像能抗住这个电压，并且不损坏。但是使用的USB过流短路保护芯片的芯片就扛不住了，上电几次 之后就回出现保护芯片电压输出脚和地线之间出现极低的阻值，大概在10Ω左右，同时，芯片会高度发烫（为什么是高度发烫，因为我在摸芯片温度的那一瞬间，我的手被烫了一个泡。就那么一瞬间）。
百思不得其解呀，电源芯片发展的这么多年了，按道理来说不应该会有这个现象啊，各种查找问题。最后发现一个规律，当电源芯片输出的5V上并联电容越大，输出的电压尖峰越嚣张。按道理来说输出的5V上并联的电容越大，上电时需要给电容充电，上升不应该更慢吗？应该是可以把尖峰电压稳稳的摁下来的么？出鬼了还???
最后在网上找到大佬的分析，感觉很有道理。大致是：在电源芯片内部，不管是DC-DC芯片，还是LDO芯片，都是通过电阻分压来获取反馈。当输出上面的电容并联的容值太大，由于电容上电瞬间需要充电，相当于对地短路，大部分电流会流向电容内部，从而导致流到反馈端的电流变小。而反馈端电流变小，便会导致反馈的电压偏低。然后电源芯片一看反馈回来的电压才这么一点，显然和设定的反馈电压不一样呀，肯定得把电压拼命的抬起来！当反馈的电压抬起来之后，输出的电压已经不知道跑到多少电压去了。
电容充电满了之后，反馈上面的电流也正常了，电压也就回到正常状态了。这样上电瞬间的尖峰就出现了。
附上大佬分析的原网址：
LDO输出电压尖峰分析
原因找到了，那么就只剩下对症下药了。既然是电流太猛了，把反馈的电流都强过去了，那么就限制一下呗。找芯片厂家的时候，说需要在芯片输入的地方增加一个10Ω的NTC配合使用。然后查找了一下NTC的使用方法，毕竟这玩意以前也没怎么用过。说NTC在上电瞬间会吸收掉电路中的尖峰电流。
附上原链接：
NTC的作用和选型
这不正好嘛，导致上电瞬间电压尖峰的不正是尖峰电流导致的嘛。既然流得太快容易出问题，那就用NTC限个流，并且将尖峰电流给干掉，那岂不美哉。
在电源芯片的输入端串上10Ω的NTC之后，发现，那个怎么都干不掉，嚣张的不行的尖峰电压，被死死地摁在了5V。虽然在上电的瞬间会稍微抬高那么一点点，差不多在0.3V以内，但是和之前相比来看，基本是没什么问题了。
串上NTC之后的电压波形就像下面的这个草图差不太多。
最后研究，定下来的原理图就是这样子的
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0d123479643bdc16b396d695bf3eed4/" rel="bookmark">
			erlang中的类型表示（-spec,-type）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言-spec 类型规范-type 类型定义类型的注解比类型注解更好的办法 前言 看《erlang程序设计》，第一次接触第九章类型几乎什么都没看懂，简单就掠过去了，后来回锅炒以及看了一些内置模块的源码，来有所悟。下面就是我对类型表示的一些理解。
补充强调：-spec和-type类型表示法，仅仅是一种说明性语法，对实际参数或返回值类型并不做限制，也就是说，它告诉：你这里参数只有这样填入我才能保证你会有这样的输出，否则如果你不按要求来，我虽然接受，但后果自负！！！。
直接上代码（《erlang程序设计》原书代码片段）：
-module(walks). -export([plan_route/2]). -spec plan_route(point(),point()) -&gt; route(). % 类型规范 -type direction() :: north() | south() | east() | west. % 类型定义 -type point() :: {integer() , integer()}. % 类型定义 -type route() :: [{go,direction(),integer()}]. % 类型定义 plan_route(_A,_B)-&gt; % 代码省略。 ... -spec 类型规范 -spec 表示这是对一个函数进行规范，人话就是：说明函数的参数或者返回值的类型。因为erlang的函数定义没有参数类型和返回值类型说明，所以利用-spec 来单独定义。
并且-spec plan_route(point(),point()) -&gt; route(). 这一行仅仅是对函数的规范，没有函数体，所以你还要在再编写一个具体实现的函数。
-type 类型定义 定义-spec具体可以使用的类型。通过上面的代码应该能发现，-spec规范总使用的全是利用-type定义的类型。它有具体的格式：
T1 :: A | B | C ... 也就是T1 代表等下回引用的名称，它可以是A，B，C等中的一个。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e0d123479643bdc16b396d695bf3eed4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b44adf28cca8824735f8434edf67cbb0/" rel="bookmark">
			flask_sqlalchemy常用查询语句总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		flask_sqlalchemy相关查询语句总结： 班级表：
学生表：
返回student表中所有数据并限制返回条数：select……from……limit() result = db.session.query(Student.id,Student.name,Student.gender,Student.age,Student.classes).limit(10).all() 对应的SQL和结果：
SELECT student.id AS student_id, student.name AS student_name, student.gender AS student_gender, student.age AS student_age, student.classes AS student_classes FROM student LIMIT ? OFFSET ? [(1, '张三', 'male', '18', 'java'), (2, '李四', 'female', '19', 'c++'), (3, '王五', 'male', '22', 'php'), (4, '赵六', 'female', '25', 'matalab'), (5, 'lee', 'man', '18', 'python'), (6, '张三', 'male', '18', 'java'), (7, '李四', 'female', '19', 'c++'), (8, '王五', 'male', '22', 'php'), (9, '赵六', 'female', '25', 'matalab'), (10, 'lee', 'man', '18', 'python')] 过滤条件查询： select……from……where ……and…… restult = db.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b44adf28cca8824735f8434edf67cbb0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c20420cf7e51618d3e2685deed35fca/" rel="bookmark">
			Java 定时任务quartz实现方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java 定时任务quartz 1. java自带 java.util.Timer 实现定时任务2. 使用线程池(ScheduledThreadPool-java.util.concurrent.ScheduledExecutorService)实现定时任务3. 使用注解@Scheduled实现定时任务4. 使用Quartz定时任务调度器4.1 Quartz 特点4.2 核心概念4.3 常用对象4.4 实例代码4.5 具体对象和方法4.5.1 ScheduleBuilder的具体对象和常用方法：4.5.2 TriggerBuilder4.5.3 Scheduler4.5.4 StdSchedulerFactory4.5.5 JobDetail4.5.6 JobBuilder 1. java自带 java.util.Timer 实现定时任务 Timer timer = new Timer(); timer.schedule(new TimerTask() { @Override public void run() { System.out.println("schedule--------------" + System.currentTimeMillis()); } }, 10 * 1000, 3 * 1000);// 10秒后执行，执行频率为3秒一次 schedule(TimerTask task, Date time)：安排在指定的时间执行指定的任务。schedule(TimerTask task, Date firstTime, long period) ：安排指定的任务在指定的时间开始进行重复的固定延迟执行。schedule(TimerTask task, long delay) ：安排在指定延迟后执行指定的任务。schedule(TimerTask task, long delay, long period) ：安排指定的任务从指定的延迟后开始进行重复的固定延迟执行。scheduleAtFixedRate(TimerTask task, Date firstTime, long period)：安排指定的任务在指定的时间开始进行重复的固定速率执行。scheduleAtFixedRate(TimerTask task, long delay, long period)：安排指定的任务在指定的延迟后开始进行重复的固定速率执行。 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c20420cf7e51618d3e2685deed35fca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a33e2d928ab7f7a306e0ec318a66294b/" rel="bookmark">
			com.baomidou.mybatisplus.core.MybatisConfiguration.getLanguageDriver(Ljava/lang/Class;)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Factory method 'sqlSessionFactory' threw exception; nested exception is java.lang.NoSuchMethodError: com.baomidou.mybatisplus.core.MybatisConfiguration.getLanguageDriver(Ljava/lang/Class;)Lorg/apache/ibatis/scripting/LanguageDriver;
该问题出现情况，因parent与model版本冲突。
查看parent中的pom文件
查看mybatis plugs的包配置
发现mybatis-spring-boot-starter的依赖mybatis-spring版本为1.3.2，而mybatis-plus-extension的依赖mybatis-spring版本为2.0.2。并且MybatisConfiguration的文件是在mybatis-plus-extension 中。所以，本人觉得降低 mybatis-plus-extension 的版本，使之匹配。
在去查看maven projects
发现没有依赖冲突。
经测试，发现程序运行正常。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/436/">«</a>
	<span class="pagination__item pagination__item--current">437/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/438/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>