<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c2bb75abc3339d7c350b140d792d948/" rel="bookmark">
			golang反射(reflect)struct操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		golang反射(reflect)struct操作 1、信息获取 reflect提供了两种类型来进行访问接口变量的内容：
类型作用ValueOf获取输入参数接口中的数据的值，如果为空则返回0 &lt;- 注意是0TypeOf动态获取输入参数接口中的值的类型，如果为空则返回nil &lt;- 注意是nil 2、示例代码 package main import ( "fmt" "reflect" ) type Person struct { Name string `json:"name"` Count int } func main() { test(Person{ Name: "lei", Count: 2, }) } func test(body interface{}) { //TypeOf会返回目标数据的类型，比如int/float/struct/指针等 typ := reflect.TypeOf(body) //ValueOf返回目标数据的的值 val := reflect.ValueOf(body) if val.Kind() != reflect.Struct { fmt.Println("expect struct") return } fmt.Println(typ) fmt.Println(val) for i := 0; i &lt; val.NumField(); i++ { field := typ.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c2bb75abc3339d7c350b140d792d948/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70532ba50b55313964600def594f4620/" rel="bookmark">
			CGO使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CGO使用 文章目录 CGO使用1、什么是CGO2、CGO环境基础3、开始使用4、类型转换4.1 数值类型4.2 字符串和切片，结构体、联合、枚举 5、静态库的使用5.1. 静态库制作5.2 在golang程序中引入静态库 6、C回调Go函数7、更多介绍
1、什么是CGO CGO是实现Go与C互操作的方式，它是Go语言自带的一个工具来支持C语言函数调用，包括Go调C和C调Go两个过程，C++ 的接口可以用 C 包装一下提供给 golang 调用，被调用的 C 代码可以直接以源代码形式提供或者打包静态库或动态库在编译时链接，推荐使用静态库的方式，这样方便代码隔离，编译的二进制也没有动态库依赖方便发布，其中Go调C的过程比较简单。对于一个在C中定义的函数add，在Go中调用时需要显式的使用C.add调用。其中C是在程序中引入的一个伪包。
2、CGO环境基础 要使用CGO特性，需要安装C/C++构建工具链，在macOS和Linux下是要安装GCC，在windows下是需要安装MinGW工具。同时需要保证环境变量CGO_ENABLED被设置为1，这表示CGO是被启用的状态。在本地构建时CGO_ENABLED默认是启用的，当交叉构建时CGO默认是禁止的。比如要交叉构建ARM环境运行的Go程序，需要手工设置好C/C++交叉构建的工具链，同时开启CGO_ENABLED环境变量。然后通过import "C"语句启用CGO特性。
3、开始使用 先看一个最简单的通过cgo，使golang调用c例子：
package main /* #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; static void Hello(const char* s) { puts(s); } static double Add(int a,double b) { return a+b; } */ import "C" import "fmt" func main() { msg:=C.CString("Hello, World\n") defer C.free(unsafe.Pointer(msg)) //释放内存 C.Hello(msg) fmt.Println(C.Add(C.int(3),C.double(12.5))) } 通过以上代码，可以看到C代码可以直接在golang文件中直接书写，但必须注意代码位置要在import "C" 改伪包头部定义，并以全文注释/**/或以单行注释// 定义C代码范围。
import "C" ：启用CGO特性，
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70532ba50b55313964600def594f4620/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/093a14c7d5874c7fde8cc28c2be44996/" rel="bookmark">
			全国高校计算机能力挑战赛C语言编程题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、
#define _CRT_SECURE_NO_WARNINGS 1 #include&lt;stdio.h&gt; #include&lt;string.h&gt; #include&lt;math.h&gt; //16.输入一行由字符a~z和A~Z组成的字符串，字符串长度 &lt;= 10000，求其中任意两个字符出现次数的差值的绝对值 //输入 : //第一行输入字符串第二行输入两个字符。输出 : //输出这两个字符出现次数的差值的绝对值输入样例 : //AbddeDfacd //A d //输出样例 : //2 //(解释 : 字符串中字符'A'出现了2次，字符'd'出现了4次，则结果为 2 - 4 = 2) //判断输入是否为a-z,A-Z void JudgeInput(char* a,int len) { for (int i = 0; i &lt; len; i++) { if ((*a &gt;= 'a'&amp;&amp;*a &lt;= 'z')||(*a &gt;= 'A'&amp;&amp;*a &lt;= 'Z')) { a++; } else { printf("输入格式不对，请从新运行程序。"); break; } } } //计算出现次数 int FrequencyChar(char* m,int len,char a) { int count = 0; for (int i = 0; i &lt; len; i++) { if (*m == a) { count++; } m++; } return count; } int main() { char arr[10000] = { 0 }; gets(arr); int len = strlen(arr); JudgeInput(arr, len); //	int len = sizeof(arr) / sizeof(arr[0]); char a=0, b=0; scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/093a14c7d5874c7fde8cc28c2be44996/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f35da7373529cafa4dc59c9144698f50/" rel="bookmark">
			企业内部应用实现钉钉免登录及登录成功后推送消息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先要通过钉钉开放平台创建H5微应用，得到企业id（CorpId），和H5微应用凭证：微应用的ID（AgentId）、微应用的唯一标识key（AppKey）、密钥（AppSecret）。
钉钉开放平台链接
https://open-dev.dingtalk.com
钉钉免登录流程：
1、前端通过CorpId获取免登授权码code；
2、后端通过AppKey和AppSecret获取access_token；
3、使用免登授权码code和access_token去获取用户userid；
4、通过access_token和userid去获取用户详情userinfo；
5、拿userinfo信息去和登录用户去比较，如果一致，则免登录成功。
注意事项
因为是企业内部应用免登录，所以不需要鉴权。免登授权码code每次请求返回的数据都不一样，请求一次的时效是5分钟，access_token有效期7200秒，自动续期。
前端代码
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;script src="/webjars/jquery/jquery.min.js"&gt;&lt;/script&gt; &lt;meta name="viewport" content="width=device-width,initial-scale=1 user-scalable=0" /&gt; &lt;script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"&gt;&lt;/script&gt; &lt;!-- 引入JSAPI --&gt; &lt;script src="https://g.alicdn.com/dingding/dingtalk-jsapi/2.10.3/dingtalk.open.js"&gt;&lt;/script&gt; &lt;title&gt;企业内部应用钉钉免登录&lt;/title&gt; &lt;/head&gt; &lt;script type="text/javascript"&gt; function relevance(){ // 此方法必须在钉钉环境下才能执行 dd.ready(function() { // 获取免登授权码code dd.runtime.permission.requestAuthCode({ corpId : "dingxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx" , // 企业id onSuccess : function(result) { var code = result.code; getUserInfo(code); //通过该code可以获取用户身份 }, onFail : function(err) { alert('获取授权码失败: ' + JSON.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f35da7373529cafa4dc59c9144698f50/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3c428a98a8ab3cf490098a3a28eee16/" rel="bookmark">
			redis系列，rdb为什么要这么做？深度剖析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 本人 github 地址本篇文章看点rdb的触发条件bgsave的主流程为什么要fork子进程而不是用子线程去做 rdb保存数据到file的流程 总结 本人 github 地址 github 地址 里面有注释好的代码，下载下来可以方便阅读。
本篇文章看点 rdb什么时候执行，条件是如何触发。rdb为什么用子进程而不是线程。什么是copy on write为什么是fork而不是其它 rdb的触发条件 rdb 有两种触发方式一种是主动触发一种是被动触发
主动触发其实就是两个命令一个是sava 另外一个bgsave, 不同的是save会阻塞主线程，在save没有执行完的情况下,其它命令所有命令只能等待save 执行完才能被执行，redis的执行命令的线程还是单线程，所以一般情况下，请用bgsave代替save，bgsave和被动触发的逻辑相似都是会fork一个子线程来执行，bgsave 带有一个schedule 参数当有其它子进程在执行的时候会滞后执行。被动触发的入口跟之前键过期的入口一样，都是从serverCron这里来触发
save 入口： void saveCommand(client *c) { //判断是否有rdb的子进程在运行 if (server.rdb_child_pid != -1) { addReplyError(c,"Background save already in progress"); return; } rdbSaveInfo rsi, *rsiptr; //这个是跟replication相关逻辑 rsiptr = rdbPopulateSaveInfo(&amp;rsi); //rdb的save主流程 if (rdbSave(server.rdb_filename,rsiptr) == C_OK) { addReply(c,shared.ok); } else { addReply(c,shared.err); } } bgsave 入口：
/* BGSAVE [SCHEDULE] */ void bgsaveCommand(client *c) { int schedule = 0; /* The SCHEDULE option changes the behavior of BGSAVE when an AOF rewrite * is in progress.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c3c428a98a8ab3cf490098a3a28eee16/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42b54711adc7c9a51ce336225548bbbc/" rel="bookmark">
			windows10配置make命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本质上来说windows是没有make命令的，而真正和Linux中make命令有相同作用的是mingw32-make。我们为了使用方便可以直接把mingw32-make改为make。但是如果你在其它的编译软件中想要使用mingw32-make的时候记得把它改成make。
这两篇教程是比较好的，两个结合着看还是挺不错的。
(https://blog.csdn.net/nicholas_liu2017/article/details/78323391)
(https://blog.csdn.net/fuyanhuangyan/article/details/78671042)
把他们的步骤总结一下就是
1、下载安装MinGW：https://osdn.net/projects/mingw/downloads/68260/mingw-get-setup.exe/
2、安装MinGW的时候选择Basic setup下选择mingw32-base包就可以了。
3、打开MinGW的安装目录，打开bin文件夹，将mingw32-make.exe重命名为make.exe。
4、设置环境变量，只需把bin文件夹的路径 C:\MinGW\bin 放到用户变量中去。
5、查看make是否安装成功： 在cmd中输入 make -v。
6、看到以下内容表示安装成功： GNU Make 3.82.90 Built for i686-pc-mingw32 Copyright (C) 1988-2012 Free Software Foundation, Inc. License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt; This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. 另：Cygwin工具使用入门教程
https://blog.csdn.net/chunleixiahe/article/details/55666792
https://www.linuxidc.com/Linux/2019-02/156967.htm
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe30efc761864f4111c2dd83df1643c0/" rel="bookmark">
			基于51单片机的火灾报警装置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这应该算是我本科阶段做的第一个项目，入门单片机的时候拿51做的一个简单的火灾报警装置，由于年代久远，很多细节可能都忘了，不过有什么问题欢迎大家留言，看到后还是会尽力帮大家解决。
写在前面 这个装置用的是最简单的51单片机外加几个简单的传感器，项目大致流程就是：
收集传感器信息 —&gt; 信息处理 —&gt; 执行对应动作
目录 火灾报警装置功能介绍原理图源代码 功能介绍 总览 这是整个装置的总览图， 各种零件标注如下： 1、温度阈值2、烟雾浓度阈值3、实时温度4、实时烟雾浓度5、蜂鸣器用于报警6、黄、红色LED灯指示7、风扇用于疏散烟雾8、烟雾传感器9、温度传感器 功能一：温度实时监测 LCD1602中第二行显示的为当前环境的温度和烟雾浓度这两个数值会随环境变化而实时变化 功能二：两级阈值及报警 LCD1062第一行为温度和烟雾浓度的阈值（上图为一级阈值）
当温度或烟雾浓度超过对应一级阈值后，蜂鸣器会报警，并且亮起黄色警报灯，风扇启动一级转速，同时阈值变为二级阈值（如下图）
当温度或烟雾浓度超过二级阈值后，蜂鸣器持续报警，亮起红色指示灯，风扇全速转动
当温度和烟雾浓度都降到一级阈值以下，自动关闭所有报警措施
一级、二级阈值均可自行设定
功能三：手机远程遥控 本装置装有HC-05蓝牙模块，可与手机通信（当时不是很了解，HC-05不支持IOS，还特意借了个安卓调试）手机通过串口助手连上蓝牙后，装置会不断向手机发送当前的温度和烟雾浓度手机可通过向装置发送0、1、2指令分别控制装置的关闭、一级警报、二级警报。 以上所有图均有动图展示，由于图片过大无法上传，感兴趣的可以到文章底部的github上下载。
原理图 原理图用的是AD17自行绘制的，毕竟不是学这个的，所以画的不是很专业，大致一看即可。github有pdf版和源文件，需要可自己去下载。 源码 源码部分每个模块对应了一个.c文件，共7个： 主逻辑函数main.c蜂鸣器模块Buzzer.c温度模块DS18B20.c蓝牙模块HC-05.c液晶显示LCD1602.c风扇驱动Motor.c烟雾传感模块MQ-2.c main.c #include &lt;reg52.h&gt; sbit LED1 = P2^1; sbit LED2 = P2^2; bit flagOff = 0; unsigned char flagOn = 0; unsigned int preTmp1 = 40; unsigned int preSmk1 = 20; unsigned int preTmp2 = 60; unsigned int preSmk2 = 30; unsigned int bkp[2]; unsigned int smk; unsigned int tmp; unsigned int sum; unsigned char RxdBuf = '4'; unsigned char flag = 0; unsigned char cnt; unsigned char T0RH, T0RL; extern unsigned int getTmp(); extern unsigned int ADC0832(unsigned char); extern void sendData(); extern void openBuzzer(unsigned int); extern void stopBuzzer(); extern void Motor(unsigned char); extern void InitDS18B20(); extern void Display1602(unsigned int,unsigned int,unsigned int,unsigned int);	//显示温度，烟雾值 extern void Init1602(); extern void configUART(unsigned int); void checkSta(); void main() { unsigned int i = 0; unsigned int j = 0; EA = 1; InitDS18B20(); Init1602(); configUART(9600); bkp[0] = getTmp(); bkp[1] = ADC0832(1); for(j=0;j&lt;33000;j++); while(1)	{ for(cnt=0;cnt&lt;50;cnt++)	{ smk = ADC0832(1);	sum=sum+smk;	} smk=sum/50;	sum=0; tmp = getTmp(); if((bkp[0]!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe30efc761864f4111c2dd83df1643c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d35076fc15e3059090d4e2b4ee55272e/" rel="bookmark">
			Java通过Jcraft实现基于SFTP的文件上传、下载、删除
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言一、什么是SFTP？二、使用工具FileZilla（一）配置（二）使用 三、代码部分总结 前言 最近由于安全监管部门的要求，将系统生成的接口文件存储地址NAS模式更换为符合要求的SFTP模式。所以学习了一下Java如何集成SFTP，然后总结下使用经验。
请等米下锅的同学，请直接转到代码部分
一、什么是SFTP？ 安全文件传输协议SFTP(SSH File Transfer Protocol)是文件传输协议(FTP)的安全版本，也是SSH协议的一部分，可通过安全SHELL(SSH)数据流轻松进行数据传输和数据访问。SFTP也被称为SSH文件传输协议。它提供了一个安全的连接来传输文件，并在本地和远程系统上遍历文件系统。SFTP中的加密是通过SSH连接来完成的，文件可以通过WinSCP和SFTP客户端进行传输。
详细参考：什么是SFTP？简述SFTP的工作原理和优势
二、使用工具FileZilla 下载地址
（一）配置 1、点击文件，选择站点管理器。
2、选择SFTP安全文件传输协议，配置host地址，账户，密码，端口号不加默认就是22。
3、点击连接，进入服务器。
（二）使用 点击右键就可以下载、删除了。遇到没有权限的文件，记得给文件赋予权限，或者换到权限更大的root权限。
三、代码部分 ok！进入我们今天的重点部分。我们可以使用插件jcraft来实现java通过SFTP实现对文件的操作。以下是Springboot项目的集成，其他框架的项目亦可。
maven依赖，配置pom.xml &lt;!-- sftp上传依赖包 --&gt; &lt;!-- https://mvnrepository.com/artifact/com.jcraft/jsch --&gt; &lt;dependency&gt; &lt;groupId&gt;com.jcraft&lt;/groupId&gt; &lt;artifactId&gt;jsch&lt;/artifactId&gt; &lt;version&gt;0.1.55&lt;/version&gt; &lt;/dependency&gt; 大家也可以去maven仓库选择不同的版本下载，像我这里就是选择的最新的依赖包。
https://mvnrepository.com/artifact/com.jcraft/jsch
创建配置类SFTPConfigModel /** * 构造SFTP连接的配置类 * @Author:QY */ public class SFTPConfigModel { /** FTP 登录用户名*/ private String userName; /** FTP 登录密码*/ private String passWord; /** 私钥 */ private String privateKey; /** FTP 服务器地址IP地址*/ private String host; /** FTP 端口*/ private int port; /** FTP 指定上传路径*/ private String uploadUrl; /** FTP 指定下载路径*/ private String downloadUrl; public SFTPConfigModel(String userName, String passWord, String privateKey, String host, int port, String uploadUrl, String downloadUrl) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d35076fc15e3059090d4e2b4ee55272e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48e1f160596fb26e4d9fde1ce2ff22bd/" rel="bookmark">
			Linux Mint 20 Ulyana base: Ubuntu 20.04 focal安装xrdp，并通过win10远程桌面访问
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 该文章基于Linux Mint 20 Ulyana，并已经安装了gnome。远程桌面客户端默认使用win10自带的远程桌面
安装步骤 安装xrdp
sudo apt-get -y install xrdp 安装tigervnc
sudo apt-get -y install tigervnc-standalone-server 为root用户设置VNC密码，这里的用户为在远程桌面登录时的用户，修改为自己的用户名
vncpasswd root 修改 xrdp最大连接数（使用默认值，不修改也是可以的） ：vim /etc/xrdp/xrdp.ini （默认是32）：max_bpp=32
如果有防火墙，请关闭或者将相关接口放入放行端口中。这里应该时3389
systemctl stop firewalld.service
设置开机不启动防火墙：
systemctl disable firewalld.servie
关闭SElinux，linuxmint 20中默认关闭。
参考：
https://blog.csdn.net/cunjiu9486/article/details/109073015
查看selinux状态
$ sestatus 如果未安装sestatus我们可以使用以下命令将其安装在Ubuntu，Debian，Kali，Mint中。
$ sudo apt install policycoreutils 启动XRDP
systemctl start xrdp 设置xrdp服务 开机自启动
systemctl enable xrdp 使用win10远程桌面连接
点击连接后出现如下页面，输用户名和密码点击OK，应该就能正常访问了。 （ 这 里 注 意 ： s e s s i o n 选 择 X v n c ） \color{#FF3030}{（这里注意：session选择Xvnc）} （这里注意：session选择Xvnc）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/48e1f160596fb26e4d9fde1ce2ff22bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d124bbfe8dc1b2e95769ff3f5cbeaac/" rel="bookmark">
			大数据架构方案 - Flink&#43;Iceberg实时数据湖
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		导读：Apache Flink是大数据领域非常流行的流批统一的计算引擎，数据湖是顺应云时代发展潮流的新型技术架构。那么，当Apache Flink遇见数据湖时，会碰撞出什么样的火花呢？本次分享主要包括以下核心内容：
数据湖的相关背景介绍
经典业务场景介绍
为什么选择 Apache Iceberg
如何通过 Flink+Iceberg 实现流式入湖
社区未来规划工作
一、数据湖的相关背景介绍 数据湖是个什么概念呢？一般来说我们把一家企业产生的数据都维护在一个平台内，这个平台我们就称之为“数据湖”。
看下面这幅图，这个湖的数据来源多种多样，有的可能是结构化数据，有的可能是非结构数据，有的甚至是二进制数据。有一波人站在湖的入口，用设备在检测水质，这对应着数据湖上的流处理作业；有一批抽水机从湖里面抽水，这对应着数据湖的批处理作业；还有一批人在船头钓鱼或者在岸上捕鱼，这对应着数据科学家从数据湖中通过机器学习的手段来提取数据价值。
我们总结起来，其实数据湖主要有 4 个方面的特点。
第一个特点是存储原始数据，这些原始数据来源非常丰富；
第二个特点是支持多种计算模型；
第三个特点是有完善的数据管理能力，要能做到多种数据源接入，实现不同数据之间的连接，支持 schema 管理和权限管理等；
第四个特点是灵活的底层存储，一般用 ds3、oss、hdfs 这种廉价的分布式文件系统，采用特定的文件格式和缓存，满足对应场景的数据分析需求。
那么开源数据湖架构一般是啥样的呢？这里我画了一个架构图，主要分为四层：
最底下是分布式文件系统，云上用户 S3 和 oss 这种对象存储会用的更多一些，毕竟价格便宜很多；非云上用户一般采用自己维护的 HDFS。
第二层是数据加速层。数据湖架构是一个存储计算彻底分离的架构，如果所有的数据访问都远程读取文件系统上的数据，那么性能和成本开销都很大。如果能把经常访问到的一些热点数据缓存在计算节点本地，这就非常自然的实现了冷热分离，一方面能收获到不错的本地读取性能，另一方面还节省了远程访问的带宽。这一层里面，我们一般会选择开源的 alluxio，或者选择阿里云上的 Jindofs。
第三层就是 Table format 层，主要是把一批数据文件封装成一个有业务意义的 table，提供 ACID、snapshot、schema、partition 等表级别的语义。一般对应这开源的 Delta、Iceberg、Hudi 等项目。对一些用户来说，他们认为Delta、Iceberg、Hudi 这些就是数据湖，其实这几个项目只是数据湖这个架构里面的一环，只是因为它们离用户最近，屏蔽了底层的很多细节，所以才会造成这样的理解。
最上层就是不同计算场景的计算引擎了。开源的一般有 Spark、Flink、Hive、Presto、Hive MR 等，这一批计算引擎是可以同时访问同一张数据湖的表的。
二、经典业务场景介绍 那么，Flink 和数据湖结合可以有哪些经典的应用场景呢？这里我们探讨业务场景时默认选型了 Apache Iceberg 来作为我们的数据湖选型，后面一节会详细阐述选型背后的理由。
首先，Flink+Iceberg 最经典的一个场景就是构建实时的 Data Pipeline。业务端产生的大量日志数据，被导入到 Kafka 这样的消息队列。运用 Flink 流计算引擎执行 ETL后，导入到 Apache Iceberg 原始表中。有一些业务场景需要直接跑分析作业来分析原始表的数据，而另外一些业务需要对数据做进一步的提纯。那么我们可以再新起一个 Flink 作业从 Apache Iceberg 表中消费增量数据，经过处理之后写入到提纯之后的 Iceberg 表中。此时，可能还有业务需要对数据做进一步的聚合，那么我们继续在iceberg 表上启动增量 Flink 作业，将聚合之后的数据结果写入到聚合表中。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d124bbfe8dc1b2e95769ff3f5cbeaac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e53197a56b401f20e977b3817edb55b2/" rel="bookmark">
			golang将静态资源文件打包进二进制文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		默认情况下，将项目打包成二进制的时候是不会加入静态资源文件的，因此在部署的时候还需要捎带上这些文件，比如，一些配置文件，图片，样式表等。
很多时候，这些静态文件是不需要变的，如果能一并加入到二进制文件，就能减少部署时的依赖。
于是有了很多第三方解决方案，将静态资源文件“嵌入”最终的 Go 二进制文件中。最知名的应该是 go-bindata，此外还有很多其他的：
github.com/alecthomas/gobundle github.com/GeertJohan/go.rice github.com/go-playground/statics github.com/gobuffalo/packr github.com/knadh/stuffbin github.com/mjibson/esc github.com/omeid/go-resources github.com/phogolabs/parcello github.com/pyros2097/go-embed github.com/rakyll/statik github.com/shurcooL/vfsgen github.com/UnnoTed/fileb0x github.com/wlbr/templify perkeep.org/pkg/fileembed 从这个列表足以看出需求的广泛性。于是官方决定提供实现，在 go 命令中实现该功能。因为在 Go 命令中添加对嵌入基本功能的直接支持将消除对某些工具的需求，至少可以简化其他工具的实现。
这个功能会在 Go1.16版本中被加入。
01 试用 go embed 通过几个示例快速了解 go embed 的用法。
注意，代码中的 //go embed 是指令，而不是注释。
例 1：内嵌文件 — Web 应用 基于 Echo 框架：
package main import ( _ "embed" "net/http" "github.com/labstack/echo" ) //go:embed static/logo.png var content []byte func main() { e := echo.New() e.GET("/", func(c echo.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e53197a56b401f20e977b3817edb55b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1813eadd1b37e9f762233fdcc933e277/" rel="bookmark">
			python回文字符串_647. 回文子串（Python）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目
难度：★★★☆☆
类型：数组
方法：动态规划
力扣链接请移步本题传送门
更多力扣中等题的解决方案请移步力扣中等题目录
给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。
具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。
示例 1：
输入："abc"
输出：3
解释：三个回文子串: "a", "b", "c"
示例 2：
输入："aaa"
输出：6
解释：6个回文子串: "a", "a", "a", "aa", "aa", "aaa"
提示：
输入的字符串长度不会超过 1000 。
解答
解决回文子串问题主要的有两种方案：中心扩展和动态规划。可以针对这些方法继续做优化。
方法1：中心扩展
遍历字符串每个位置，以每个位置为中心向两边扩展，直到无法组成回文串为止，注意奇偶子串的分别考虑。
class Solution:
def countSubstrings(self, s: str) -&gt; int:
if not s:
return 0
counter = 0
def extent_from(left, right):
c = 0
while left &gt;= 0 and right &lt; len(s) and s[left] == s[right]:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1813eadd1b37e9f762233fdcc933e277/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28e2a8527a21e2c73449cdb1e53d253d/" rel="bookmark">
			python pdfminer的功能_python：pdfminer接口测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录：
简介
pdfparser使用介绍
1 from pdfminer.pdfparser import PDFParser, PDFDocument
pdfparser是一个pdf解析器，里面封装了PDFParser, PDFDocument这两个我们常用的类。PDFParser从文件流中获取PDF对象；它可以通过引用set_document方法设置的PDF文档来处理间接引用；它还可读取每个PDF文件的交叉引用(xref)，一般可以快速定位。由于PDF文件可能很大，通常不会立即加载。因此，PDF文档必须与PDF解析器协作，以便在处理过程中动态导入数据。
1 fp = open(path, 'rb') #以二进制读模式打开
2 praser = PDFParser(fp)
fp为文件流，这里我们使用open打开，产生一个二进制文件。parser是PDFParser的实例，fp为必传参数。parser可以使用的形式有：
Typical usage:
parser = PDFParser(fp)
parser.read_xref()
parser.set_document(doc)
parser.seek(offset)
parser.nextobject()
实例化之后的分析器：
1 #创建一个PDF文档
2 doc = PDFDocument()
doc是PDFDocument的实例化对象，现在的doc像一张白纸，类默认封装很多方法，其中部分是内部方法，供类内调用，我们可以使用的典型方法有：
Typical usage:
doc = PDFDocument()
doc.set_parser(parser)
doc.initialize(password)
obj = doc.getobj(objid)
1 #连接分析器 与文档对象
2 praser.set_document(doc)3 doc.set_parser(praser)
将doc赋给praser，就像给一只钢笔配上了笔记本，单向传参是肯定不行的，因为doc本身封装了很多方法，其本身是需要用到praser这只笔的，所以要把praser传给doc。(praser不是拼写错误，而是在代码中进行区分)
相互传参绑定之后，两个对象都发生了相应的变化，以parser为例：
注意doc上边有一个data的字符串，我们可以发现字符串：%PDF-1.7\n ，这个意思就是当前文本的PDF版本为1.7，PDF文件的具体格式介绍请移步：PDF格式详解。
1 #文档初始化解密
2 #没有密码 就创建一个空的字符串
3 doc.initialize()
PDF文档很多时候是加密的，为了读取相应内容，需要给电脑赋予权限，这里当然是传入密码了，若文档密码很多，可以实例化一个秘密管理器。
导入：from pdfminer.pdfinterp import PDFTextExtractionNotAllowed
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/28e2a8527a21e2c73449cdb1e53d253d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c27f3fe45f4443a51fc3727168c4948d/" rel="bookmark">
			rx文件管理器window_Window停止响应，系统死机，用这7招排除故障，实用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用电脑时，会遇到Window停止响应的情况，鼠标不能动，也不能单击任何内容或输入任何内容，好像一切都停止了。这时，如果重新启动计算机，将丢失所有正在使用的内容。如果计算机上经常发生这种情况，那么会令人沮丧，而且会失去宝贵的时间和生产力。
有各种原因会阻止Windows响应操作命令。由于原因多种多样，因此有多种解决方案。以下是一些排除故障的技巧。
一、运行病毒扫描 如果计算机出现问题，最好先执行病毒扫描。如果Windows Defender没有检测到任何东西，请考虑使用另一种防病毒软件(例如Kaspersky、Norton或Avast)进行仔细检查。请先运行此程序，以确保不是恶意软件导致的问题。
二、更新操作系统 有时Windows本身需要更新。要查看计算机是否需要该更新，请按Win+ I访问设置，然后单击“更新和安全”。计算机所需的任何升级或错误修复将在此处列出。
一旦安装了这些更新，请重新启动计算机，查看Windows是否继续冻结。
三、清除临时文件 大量的临时文件或缓存文件会占用宝贵的内存，这些文件可能会导致Windows运行方式出现问题。要消除这些文件，请继续下面的操作：
1.按Win+ R打开“运行”对话框。
2.在输入框中键入“temp”，然后按Enter。
3.在临时文件列表中，按Ctrl+ A 选中所有文件并删除它们。
四、更新驱动程序 一个过时的旧驱动程序可能是导致Windows死机的罪魁祸首，尝试更新驱动程序，看是否可以解决问题。
1.在屏幕底部的搜索框中键入“设备管理器”。
2.单击出现的应用程序以启动它。
3.每次打开一个硬件选项。
4.右键单击硬件，然后选择“更新驱动程序”。
五、使用内置的疑难解答 1.按Win+ I打开“设置”应用程序。
2.在搜索框中，键入“系统维护”。
3.单击“自动执行推荐的维护任务”选项。
4.单击下一步，然后按照说明进行操作。
5.扫描完成后，重新启动计算机，然后查看问题是否已解决。
六、运行系统文件检查器 系统文件检查器(SFC)通过检查文件的完整性并确定其是否正常工作来扫描计算机。如果找到无法正常工作的文件，它将自动修复该文件。
1.在屏幕底部的搜索框中键入“cmd”。
2.单击“以管理员身份运行”。
3.打开命令提示符后，输入sfc /scannow命令，然后按Enter。
这个扫描过程需要一段时间，请耐心等待，不过，它在后台运行，因此你可以继续进行其它的工作。
七、使用干净启动 干净启动将提供最好的方法来确定是否是某个应用程序或服务引起了计算机问题。
要干净启动计算机，请这样操作：
1.按Win+ R打开“运行”对话框。
2.在框中，键入“MSCONFIG”，然后单击“确定”。
3.选择“引导”选项卡，然后取消选中“安全引导”选项。
4.单击“常规”选项卡。
5.选择“选择性启动”，然后取消选中“加载启动项”选项。
6.单击“服务”选项卡。
7.选中左下角“隐藏所有Microsoft服务”选项，然后单击“全部禁用”。
8.打开“启动”选项卡。
9.单击打开任务管理器。
10.在任务管理器中，右键单击每个启动项以禁用所有启动项。
设置完成后，你将面临一个非常乏味的任务：逐个启用每个启动项。当问题再次出现时，记下你刚刚激活的应用程序，然后可以重新安装或修复该应用程序。如果服务引起了问题，则可以将其禁用。
八、内存检查 如果系统中有任何内存泄漏或内存卡错误，则可以使用“内存检查”命令来确定它们是否存在。
1.按Win+ R打开“运行”对话框。
2.键入“mdsched.exe”，然后单击“确定”。
3.选择是立即运行扫描还是等待下一次重新启动计算机。
运行此检查时，屏幕将变为全蓝，但不要惊慌，这不是错误。如果有错误，会显示一个代码和一些解决方案。
扩展阅读： ■＞＞win10出现故障，在安全模式下安装Windows更新，彻底修复问题 ■＞＞win10下以安全模式启动电脑全攻略，装机、修复电脑故障必备 ■＞＞玩win10，不懂这12种打开系统设置的方法，怎么修电脑故障 更多windows 10操作系统使用技巧，请关注→→#win10玩机技巧#
想了解更多精彩内容，请关注@微课传媒
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f30c5b835fb81b80d702dfdff42fc12/" rel="bookmark">
			[CTF]web进阶之文件上传
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目:web进阶之文件上传
查看题目，底下已经给出了源代码：
服务器对文件进行了白名单设置，允许上传zip、jpg、gif、png文件!我随便上传几张一句话木马图片，均能够上传成功，说明他只对文件的后缀进行验证。上传不难，难的是上传后找不到文件的路径，无法访问。
观察关于目录的代码发现，文件上传后，会随机生成一个MD5目录，把文件放在这个地方，但是MD5目录无法预知，所以难度大大的加大。
通过解读zip文件代码可知，通过zip上传后，服务器会对zip进行解压，放在upload目录下，然后如果这个目录下含有非白名单的文件，就会对该文件进行删除，所以一个办法就是把文件解压到upload目录之外
把一句话PHP代码重新命名，shell.php.xxxxx,压缩成1234.zip文件，然后用010 editor打开，修改压缩包内的文件为…/…/shell.php.xxxxx,保存，这样做的目的是为了解压时把文件解压到根目录下。
上传该文件，成功上传，随后访问shell.php文件，即可得到flag。
另一种构想的方法：我记得一句话，根本就没有绝对的伪随机数。这个题目将1000至9999内的数字随机拿出一个进行MD5加密作为目录，那么可已设想，如果我们能够碰撞出该目录，会不会就能够进行访问了？
我写了一段代码，从999到10000进行循环，然后对i进行MD5加密，构造一个目录，然后进行访问，如果有返回值，则说明存在这个目录。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b856af49382f6c1ae3b3c7d8ff26402/" rel="bookmark">
			Python一看就懂系列(三)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		专栏: python轻奢入门系列
作者: 豆破苍琼
【字符串】 字符串介绍 字符串格式 被单引号或者双引号括起来的数据就是字符串。
字符串输出 """ 字符串输出 """ def printStream(nums): import time for i in range(nums): print('正在持续输出{}次'.format(i)) if i != nums-1: print("等待1秒后...") time.sleep(1) print("完成输出!") printStream(10) 字符串输入 """ 字符串输入 """ name = 'hello world!' count = 3 words = input("学习编程,进入编程世界的第一句话是什么?\n") while True: if words == name: print("恭喜你,进入编程世界!") break else: if count == 0: print("江湖再见!\n") break words = input("很遗憾,你再想想,学习编程,进入编程世界的第一句话是什么?\n") count -=1 字符串常见操作 下标 字符串实际是字符数组,所以支持下标的使用。
切片 """ 字符串切片 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b856af49382f6c1ae3b3c7d8ff26402/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9cdf90da5470307d5f3b10b726da908a/" rel="bookmark">
			python r语言 结合 部署_R语言-数据的重构和整合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		R语言-数据的重构和整合
在数据初步处理过程中，我们时常遇到这样的问题，就是数据包含我们所要的信息，格式却与我们预期的样式不符。我们可能需要在原有数据的基础上进行处理，增加变量的个数或者对数据框进行转置和其他处理。在本节中，我们将介绍R语言的reshape2包的作用，实现数据重构和整合数据集的绝妙的万能工具。由于reshape2包未包含在R的标准安装中，在第一次使用它之前需要使用install.packages(“reashape2”)进行安装。
1.数据的融合
例如：我们想实现如下的转化，具体如下
可以使用reshape2实现，数据的融合。
md
结果展示
2.数据的重铸
R语言可以使用reshape2对数据将其重铸为想要的形状。
dcast()函数读取已融合的数据，并使用特定的公式和数据整合函数将融合的数据重塑。
可以写成如下代码实现，
md2
结果展示
若想实现融合后的数据，转化为原始数据(获取数据时就是这种格式，而非想徒劳的折腾)。
可以写成如下代码实现，
md3
结果展示
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3541c952f834531771b38e08d15d9ae1/" rel="bookmark">
			ECCV2020最佳论文RAFT：Recurrent All-Pairs Field Transforms for Optical Flow
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近做光流相关，看了一些监督和无监督自监督的光流估计。今天介绍一下RAFT（监督学习，目前sota）。
官方代码
背景 在RAFT之前，一些有名的光流估计方法，大都遵循金字塔结构+coarse to fine的预测flow的方式。在多个尺度上预测flow，flow层层迭代，逐步细化，分辨率越来越大。作者任务这种范式存在以下问题：
粗level预测错了，在后面的更细节的level不好修正对小目标快速移动的情况，很难正确预测训练迭代时间长某些迭代优化的模型，没有把权重复用。 RAFT的特点:
始终保持一个高分辨率（1/8）迭代过程，重复使用一个gru blcok。（不同迭代中参数共享），所以模型参数小很多，且能一直迭代没有发散提出一种look up（查询）操作，在每一个迭代中都使用了 all pair attention，但查询操作可以只做一次attention，节省了很多计算量不同于之前方法使用的cost valume。作者使用4D correlation valume。4D是指多个尺度，correlation valume是attention map。 方法 RAFT整个结构，异常简洁。
整个pipeline可以分成3个部分。
feature encodercorrelation valume的构建迭代式update（含有查询look up操作） 总体pipeline：
目标是求第一帧到第二帧的前向光流。首先用feature encoder提出两帧的特征，然后计算attention map，构建4D Correlation Volumes。然后用context encoder提出第一帧的特征。context 特征用于在correlation valume上查询，得到每个位置对应邻域（含多尺度）的相似值，记作corr。corr和flow和context feature送入更新模块，不断得到更正确的光流位置。迭代次数大，光流位置会逐渐收敛到固定点，不会发散。 第一部分的输出是1/8的特征。我们就直接开始讲述第二部分和第三部分。
Correlation Valume 第一帧和第二帧对应的feature encoder的输出是 F 1 , F 2 F_1, F_2 F1​,F2​。然后计算attention map。
c o r r 1 = F 1 T × F 2 , ∈ R h w ∗ h w corr_1 = F_1 ^T \times F_2 , \in R^{hw*hw} corr1​=F1T​×F2​,∈Rhw∗hw
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3541c952f834531771b38e08d15d9ae1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6750e143d4e1ce8ddde8c1c6fcb01c4/" rel="bookmark">
			Dart语言——45分钟快速入门（上）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言视频课程环境准备 安装Dart SDK配置环境变量配置 VSCode 编辑器测试环境 基础语法 代码注释内置数据类型变量与常量 定义变量定义常量 内置类型的常用操作 数值类型字符串布尔类型列表映射 函数 定义函数函数的参数 命名可选参数位置可选参数 匿名函数箭头函数 运算符 算术运算符类型判定运算符条件表达式级联运算符条件成员访问符 分支与循环 条件分支循环语句 基本循环特有循环 关注我的公众号：编程之路从0到1 前言 谷歌推出Flutter跨平台UI框架后，对移动端的开发又产生了新的影响，Flutter采用Dart语言开发，而Flutter为什么选择Dart语言作为唯一的开发语言呢？总的来说，其拥有如下优势
Dart可基于AOT（Ahead Of Time）编译，即编译成平台的本地代码，运行性能高。Dart也可基于JIT（Just In Time）编译，编译快速，可热加载，使开发周期加倍提升（Flutter亚秒级有状态热重载）Dart可以更轻松地创建以60fps运行的流畅动画和转场。Dart在没有锁的情况下进行对象分配和垃圾回收Dart语法结合Java与JavaScript语法特点，几乎没有令人不适的怪异语法，使Java程序员倍感亲切，快速上手 通常来说一门语言要么使用AOT编译，编译慢，开发效率低，或者使用JIT编译，在运行时编译，虽然可以热重载，但是执行效率低，而Dart在这两种之间做出了完美平衡，当开发时使用JIT编译，调试快，所见即所得，开发效率高，当发布时，使用AOT编译，编译成目标平台的本地代码，执行效率高。
视频课程 博主发布的相关视频课程
Flutter全栈式开发之Dart 编程指南
Flutter 全栈式开发指南
快速上手篇可试看
环境准备 安装Dart SDK 官方下载地址
共有三种SDK版本选择
FlutterWebServer 本章仅作为Dart编程语法学习，这里建议安装Server版的SDK，然后选择Windows版本进行下载。
配置环境变量 在Windows上，通过点击下一步即可安装，安装完成后，需将dart-sdk下的的bin目录添加到系统Path环境变量中。这一步骤是通常的命令配置步骤。
配置 VSCode 编辑器 作为Dart语言的学习，不建议下载笨重的IDE，官方提供支持VSCode 编辑器插件，建议使用VSCode 学习。
从 官网下载 VSCode编辑器，安装完成后，启动VSCode并在插件商店中搜索Dart进行插件安装。
测试环境 在VSCode中新建一个test.dart文件，编写如下代码
void main(){ print("hello world!"); } 123 运行后成功在控制台输出hello world!
基础语法 代码注释 Dart中的代码注释基本与Java语言相同
// 单行注释 /* * 多行注释 */ /** * 文档注释 */ /// 使用三个斜杠开头 /// 这是Dart特有的文档注释 123456789101112 内置数据类型 在Dart中，所有能够使用变量引用的都是对象，每个对象都是一个类的实例。数字、函数和 null 也都是对象。所有的对象都继承于Object类。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d6750e143d4e1ce8ddde8c1c6fcb01c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b0ad8a9166af6a47a05f54de3514a0b/" rel="bookmark">
			python怎么查询元素是否在列表中_python怎么判断某一元素是否在列表中
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		定义一个列表，并判断元素是否在列表中。
python学习网，大量的免费python基础教程，欢迎在线学习！
例如：test_list = [ 1, 6, 3, 5, 3, 4 ]
print("查看 4 是否在列表中 ( 使用循环 ) : ")
for i in test_list:
if(i == 4) :
print ("存在")
print("查看 4 是否在列表中 ( 使用 in 关键字 ) : ")
if (4 in test_list):
print ("存在")
以上实例输出结果为：查看 4 是否在列表中 ( 使用循环 ) :
存在
查看 4 是否在列表中 ( 使用 in 关键字 ) :
存在
例如from bisect import bisect_left
# 初始化列表
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b0ad8a9166af6a47a05f54de3514a0b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ff17bc9464bdf6b0a0be5cc04b2fe3d/" rel="bookmark">
			数仓分层概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一层：关系型数据库（mysql、oracle、postgresql...）
第二层：ods层=dwd层 操作性数据，日志数据，或者从关系型数据库直接转移过来的数据（这部分数据好比渔民从池塘里打捞出来未分类的鱼）
第三层：edw层或者dw(数据集市) 轻度汇总或者中度汇总层，可以理解成过滤掉小鱼小虾和不明生物的中间层
第四层：odm层 展示层即聚合数据层，应用层
可以根据业务需求建立自己的tmp层或者公共层
第二张说法：
DW ：data warehouse 翻译成数据仓库
DW数据分层，由下到上为 DWD,DWB,DWS
DWD：data warehouse detail 细节数据层，有的也称为 ODS层，是业务层与数据仓库的隔离层
DWB：data warehouse base 基础数据层，存储的是客观数据，一般用作中间层，可以认为是大量指标的数据层。
DWS：data warehouse service 服务数据层，基于DWB上的基础数据，整合汇总成分析某一个主题域的服务数据，一般是宽表
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59e8d4db37db5c5812e8f5db6f0d8ad8/" rel="bookmark">
			uniapp 安卓和IOS退出App的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 switch (uni.getSystemInfoSync().platform) { case 'android': plus.runtime.quit(); break; case 'ios': plus.ios.import('UIApplication').sharedApplication().performSelector('exit'); break; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9e8963a46532798a9446b4feda4e232/" rel="bookmark">
			拉链表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0x00 前言 本文将会谈一谈在数据仓库中拉链表相关的内容，包括它的原理、设计、以及在我们大数据场景下的实现方式。
全文由下面几个部分组成：
先分享一下拉链表的用途、什么是拉链表。通过一些小的使用场景来对拉链表做近一步的阐释，以及拉链表和常用的切片表的区别。举一个具体的应用场景，来设计并实现一份拉链表，最后并通过一些例子说明如何使用我们设计的这张表（因为现在Hive的大规模使用，我们会以Hive场景下的设计为例）。分析一下拉链表的优缺点，并对前面的提到的一些内容进行补充说明，比如说拉链表和流水表的区别。 0x01 什么是拉链表 拉链表是针对数据仓库设计中表存储数据的方式而定义的，顾名思义，所谓拉链，就是记录历史。记录一个事物从开始，一直到当前状态的所有变化的信息。
我们先看一个示例，这就是一张拉链表，存储的是用户的最基本信息以及每条记录的生命周期。我们可以使用这张表拿到最新的当天的最新数据以及之前的历史数据。
注册日期用户编号手机号码t_start_datet_end_date2017-01-010011111112017-01-019999-12-312017-01-010022222222017-01-012017-01-012017-01-010022333332017-01-029999-12-312017-01-010033333332017-01-019999-12-312017-01-010044444442017-01-012017-01-012017-01-010044324322017-01-022017-01-022017-01-010044324322017-01-039999-12-312017-01-020055555552017-01-022017-01-022017-01-020051151152017-01-039999-12-312017-01-030066666662017-01-039999-12-31 我们暂且不对这张表做细致的讲解，后文会专门来阐述怎么来设计、实现和使用它。
拉链表的使用场景 在数据仓库的数据模型设计过程中，经常会遇到下面这种表的设计：
有一些表的数据量很大，比如一张用户表，大约10亿条记录，50个字段，这种表，即使使用ORC压缩，单张表的存储也会超过100G，在HDFS使用双备份或者三备份的话就更大一些。表中的部分字段会被update更新操作，如用户联系方式，产品的描述信息，订单的状态等等。需要查看某一个时间点或者时间段的历史快照信息，比如，查看某一个订单在历史某一个时间点的状态。表中的记录变化的比例和频率不是很大，比如，总共有10亿的用户，每天新增和发生变化的有200万左右，变化的比例占的很小。 那么对于这种表我该如何设计呢？下面有几种方案可选：
方案一：每天只留最新的一份，比如我们每天用Sqoop抽取最新的一份全量数据到Hive中。方案二：每天保留一份全量的切片数据。方案三：使用拉链表。 为什么使用拉链表 现在我们对前面提到的三种进行逐个的分析。
方案一
这种方案就不用多说了，实现起来很简单，每天drop掉前一天的数据，重新抽一份最新的。
优点很明显，节省空间，一些普通的使用也很方便，不用在选择表的时候加一个时间分区什么的。
缺点同样明显，没有历史数据，先翻翻旧账只能通过其它方式，比如从流水表里面抽。
方案二
每天一份全量的切片是一种比较稳妥的方案，而且历史数据也在。
缺点就是存储空间占用量太大太大了，如果对这边表每天都保留一份全量，那么每次全量中会保存很多不变的信息，对存储是极大的浪费，这点我感触还是很深的......
当然我们也可以做一些取舍，比如只保留近一个月的数据？但是，需求是无耻的，数据的生命周期不是我们能完全左右的。
拉链表
拉链表在使用上基本兼顾了我们的需求。
首先它在空间上做了一个取舍，虽说不像方案一那样占用量那么小，但是它每日的增量可能只有方案二的千分之一甚至是万分之一。
其实它能满足方案二所能满足的需求，既能获取最新的数据，也能添加筛选条件也获取历史的数据。
所以我们还是很有必要来使用拉链表的。
0x02 拉链表的设计和实现 如何设计一张拉链表 下面我们来举个栗子详细看一下拉链表。
我们接上在《漫谈数据仓库之维度建模》中的电商网站的例子，现在以用户的拉链表来说明。
我们先看一下在Mysql关系型数据库里的user表中信息变化。
在2017-01-01这一天表中的数据是：
注册日期用户编号手机号码2017-01-010011111112017-01-010022222222017-01-010033333332017-01-01004444444 在2017-01-02这一天表中的数据是， 用户002和004资料进行了修改，005是新增用户：
注册日期用户编号手机号码备注2017-01-010011111112017-01-01002233333（由222222变成233333）2017-01-010033333332017-01-01004432432（由444444变成432432）2017-01-02005555555（2017-01-02新增） 在2017-01-03这一天表中的数据是， 用户004和005资料进行了修改，006是新增用户：
注册日期用户编号手机号码备注2017-01-01001111111 2017-01-01002233333 2017-01-01003333333 2017-01-01004654321（由432432变成654321）2017-01-02005115115（由555555变成115115）2017-01-03006666666（2017-01-03新增） 如果在数据仓库中设计成历史拉链表保存该表，则会有下面这样一张表，这是最新一天（即2017-01-03）的数据：
注册日期用户编号手机号码t_start_datet_end_date2017-01-010011111112017-01-019999-12-312017-01-010022222222017-01-012017-01-012017-01-010022333332017-01-029999-12-312017-01-010033333332017-01-019999-12-312017-01-010044444442017-01-012017-01-012017-01-010044324322017-01-022017-01-022017-01-010046543212017-01-039999-12-312017-01-020055555552017-01-022017-01-022017-01-020051151152017-01-039999-12-312017-01-030066666662017-01-039999-12-31 说明
t_start_date表示该条记录的生命周期开始时间，t_end_date表示该条记录的生命周期结束时间。t_end_date = '9999-12-31'表示该条记录目前处于有效状态。如果查询当前所有有效的记录，则select * from user where t_end_date = '9999-12-31'。如果查询2017-01-02的历史快照，则select from user where t_start_date &lt;= '2017-01-02' and t_end_date &gt;= '2017-01-02'。（*此处要好好理解，是拉链表比较重要的一块。**） 在Hive中实现拉链表 在现在的大数据场景下，大部分的公司都会选择以Hdfs和Hive为主的数据仓库架构。目前的Hdfs版本来讲，其文件系统中的文件是不能做改变的，也就是说Hive的表智能进行删除和添加操作，而不能进行update。基于这个前提，我们来实现拉链表。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e9e8963a46532798a9446b4feda4e232/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7fedb6c6f2f274cf7a4a0963895b7c4/" rel="bookmark">
			防止缓存雪崩方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		防止缓存雪崩方案 缓存雪崩的危害解决方案代码示例 缓存雪崩的危害 缓存雪崩最乐观的情况是存储层能抗住，但是用户体验会受到影响，数据返回慢，当压力过大时会导致存储层直接挂掉，整个系统都受影响。对于要做到 99.99% 高可用的产品，是绝对不允许缓存雪崩的发生。
解决方案 1）缓存存储高可用。 2）缓存失效时间要设计好。 3）对于一些热门数据的持续读取，这种缓存数据也可以采取定时更新的方式来刷新缓存，避免自动失效。 4）服务限流和接口限流。 5）从数据库获取缓存需要的数据时加锁控制，本地锁或者分布式锁都可以。 代码示例 这里对加锁的方式进行代码讲解，代码如下所示。 public Person get(String id) { Person person = repo.findOne(id); if (person != null) { return person; } synchronized (this) { person = dao.findById(id); repo.save(person); } return person; } 上面是最简单的方式，直接用代码同步块来加锁，当然我们也可以用 Lock 来加锁，加锁的本质还是控制并发量，不要让所有请求瞬时压到数据库上面去，加了锁就意味着性能要丢失一部分。其实我们可以用信号量来做，就是限制并发而已，信号量可以让多个线程同时操作，只要在数据库能够抗住的范围内即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3844cf33393b158374c2b0b7cfe8d383/" rel="bookmark">
			基于麻雀搜索算法优化的SVM数据分类预测 - 附代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于麻雀搜索算法优化的SVM数据分类预测 - 附代码 文章目录 基于麻雀搜索算法优化的SVM数据分类预测 - 附代码1.数据集2.SVM模型建立3.基于麻雀算法优化的SVM4.测试结果5.参考文献：6.Matlab代码7.python代码 摘要：为了提高SVM数据的分类预测准确率，对SVM中惩罚参数和核函数参数利用麻雀搜索算法进行优化。 1.数据集 wine 数据的来源是 UCI 数据库 ， 记录的是在意大利同一区域里三种不同品种的葡萄酒的化学成分分析，数据里含有 178 个样本，每个样本含有 13 个特征分量（化学成分〉，每个样本 的类别标签已给。将这 178 个样本的 50%作为训练集，另 50%作为测试集 ，用训练集对 SVM 进行训练可以得到分类模型，再用得到的模型对测试集进行类别标签预测。
整体数据存储在 chapter_WineClass. mat ，解释如下： classnumber = 3 ，记录类别数目；
wine, 178 × 13 的 一个 double 型的矩阵，记录 178 个样本的 13 个属性；
wine_ labels, 178 × 1的 一个 double 型的列向盘，记录 178 个样本各自的类别标签 。
图1.数据集 2.SVM模型建立 首先需要从原始数据里把训练集和测试集提取出来，然后进行一定的预处理（必要的时候 还需要进行特征提取），之后用训练集对 SVM 进行训练，最后用得到的模型来预测测试集的分类标签。
图2.SVM模型 其中数据预处理采用归一化处理：对训练集和测试集进行归一化预处理，采用的归一化映射如下 。
y = x − x m i n x m a x − x m i n (1) y = \frac{x-x_{min}}{x_{max} - x{min}} \tag{1} y=xmax​−xminx−xmin​​(1)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3844cf33393b158374c2b0b7cfe8d383/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3aa20a26fd361d77fe17ee0aa2ae76b/" rel="bookmark">
			python数字拆分比较大小_整数拆分（Python）,python
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		# 我们都知道有一门数学领域叫组合数学，其中整数的拆分问题是非常有名的，
# 例如 我们有1g、 2g、 3g、 4g、 5g的砝码各一个，问能称出多少的重量，各有多少称法
# 这里我们利用欧拉提出的母函数的概念(当然拉马努金的公式也可以，拉马努金是我非常喜欢的数学家)， 直接带入求解，(1+x)(1+x^2)(1+x^3)(1+x^4)(1+x^5)
def add_poly(L1,L2): #多项式加法，同次项系数相加
R=[]
if len(L1)&gt;len(L2):#默认L2比较长
L1,L2=L2,L1
i=0
while i
R.append(L1[i]+L2[i])#从低次项开始对应相加
i+=1
R=R+L2[len(L1):len(L2)]#较长的多项式高次项直接复制
return R
def multiply_poly(L1,L2):#多项式乘法
if len(L1)&gt;len(L2):
L1,L2=L2,L1
zero=[];R=[]
for i in L1:
T=zero[:]#存储中间产生的结果多项式，每次更新结果多项式的列表长度
for j in L2:#一个单项式乘以多项式的每一项
T.append(i*j)
R=add_poly(R,T)
zero=zero+[0]# 每一个新的多形式都要比前一个多项式次数高1，列表长度增加，所以多补一个0
return R
sum_data = multiply_poly(multiply_poly(multiply_poly(multiply_poly([1, 1, 0, 0, 0, 0], [1, 0, 1, 0, 0, 0]),[1, 0, 0, 1, 0, 0]), [1, 0, 0, 0, 1, 0]), [1, 0, 0, 0, 0, 1])
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a3aa20a26fd361d77fe17ee0aa2ae76b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab7e268ce940e8f46e5f7b5ebdd5f7d9/" rel="bookmark">
			python调库基础_python请求基本库使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		高级用法
http://cn.python-requests.org/zh_CN/latest/user/quickstart.html#url
3.2 requests
源码
def request(method, url, **kwargs):
"""Constructs and sends a :class:`Request `.
:param method: method for the new :class:`Request` object.
:param url: URL for the new :class:`Request` object.
:param params: (optional) Dictionary, list of tuples or bytes to send
in the body of the :class:`Request`.
:param data: (optional) Dictionary, list of tuples, bytes, or file-like
object to send in the body of the :class:`Request`.
:param json: (optional) A JSON serializable Python object to send in the body of the :class:`Request`.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab7e268ce940e8f46e5f7b5ebdd5f7d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/965a9d7a2995fcaa383fbb7f96f05498/" rel="bookmark">
			8086如何计算物理地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		8086中含有存储器。存储器中每一个单元的地址可以用两种方法表示：
1.逻辑地址：其表达形式为“段地址：段内偏移地址”。
2.物理地址：CPU与存储器进行数据交换时在地址总线上提供的20位地址信息称为物理地址。
物理地址=段地址×10H＋段内偏移量
注：H为16进制，CS :代码段寄存器，
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9ddbd732aca1c64f135c831f14ac169/" rel="bookmark">
			Ubuntu如何设置或删除swap虚拟内存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是swap？ swap 简单的说就是将硬盘当内存用，用于解决内存容量不足的情况。
1、如何设置swap？ 1、查看当前系统是否设置了swap 在终端输入以下命令查看是否设置了swap
free -m #swap栏都是 0 0 0 表示没有设置 2、创建 Swap 文件 使用下面命令创建交换文件。因为要分配硬盘空间，需要一点时间。count=4096 表示创建 4GB 的虚拟内存，单位是 M
#创建swap文件 sudo dd if=/dev/zero of=/swapfile count=4096 bs=1M #查看swap文件是否创建好了 ls / | grep swapfile 设置多大的swap合理呢?
物理内存RAMSwap虚拟内存RAM&lt;=2GBSWAP = RAM*23GB&lt;=RAM&lt;=8GBSWAP = RAMRAM&gt;8GBSWAP &lt;=4GB 一般物理内存小于2GB就设置为内存的两倍，小于8GB设置为等于内存，大于8GB的设置小于4GB
3、激活 Swap 文件 以次执行下面的两个命令
sudo chmod 600 /swapfile sudo mkswap /swapfile 执行成功将出现：Setting up swapspace version 1, size = 4 GiB (4294963200 bytes)
no label, UUID=96b10ad3-8a38-4777-9d1e-e0c36a50fcc5
4、开启 Swap sudo swapon /swapfile 执行成功输入free -m 查看内存情况，swap栏显示4GB的swap了
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b9ddbd732aca1c64f135c831f14ac169/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06d7d0882ab350edee022239578759a7/" rel="bookmark">
			python冒号后缩进几个空格_python的代码缩进和冒号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一般语言一样采用{}或者begin...end分隔代码块，而是python中，采用代码缩进和冒号来区分代码之间的层次。
缩进的空白数量是可变的，但是所有代码块语句必须包含相同的缩进空白数量，这个必须严格执行。
有时候代码采用，合理的缩进但是缩进的情况不同，代码的执行结果也不同。有相同的缩进的代码表示这些代码属于同一代码块。
例如：
运行结果：
分割线以上的print("end")未缩进与if对齐，因此它与if属于同一代码块，执行完if的操作，执行输出。
分割线一下的print("end")与print("Hello boy!")保持一致的缩进，则它与print("Hello boy!")属于else之内的代码块。
缩进相同的一组语句构成一个代码块，我们称之代码组。
像if、while、def和class这样的复合语句，首行以关键字开始，以冒号( : )结束，该行之后的一行或多行代码构成代码组。
我们将首行及后面的代码组称为一个子句(clause)
Python多行语句
Python语句中一般以新行作为为语句的结束符。但是我们可以使用斜杠( \)将一行的语句分为多行显示。
语句中包含[], {} 或 () 括号就不需要使用多行连接符
Python代码中一行只能有一个语句，以新行作为为语句的结束符。如果一行含有多个语句将会抛出异常。
该种方式完全是像java在声明变量呀。
Python2中貌似可以用分号分隔，我机器上没有装2.x没有试，亲测Python3下不可以。
正解如下：
Python空行
函数之间或类的方法之间用空行分隔，表示一段新的代码的开始。类和函数入口之间也用一行空行分隔，以突出函数入口的开始。
空行与代码缩进不同，空行并不是Python语法的一部分。书写时不插入空行，Python解释器运行也不会出错。但是空行的作用在于分隔两段不同功能或含义的代码，便于日后代码的维护或重构。
记住：空行也是程序代码的一部分。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc1ec5db8e743c20cda1b2e3bcece86b/" rel="bookmark">
			java全局变量_《深入理解Java虚拟机》第二章
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先讲JVM的基本信息 1) 作者站在内存的角度讲了Java以及JVM在内存管理方面的问题，其中重点讲解Java虚拟机在执行Java程序的过程中将内存划分为五个数据区
介绍了五大内存域 1) 程序计数器：负责选取下一条需要执行的字节码指令，方便线程切换后恢复原来状态 ，因为这个原因需要保证各线程之间互补干扰——线程私有内存。另外，正在执行本地方法时，程序计数器为空，是唯一没规定任何OOM(Out of MemoryError)情况的区域
2) Java虚拟机栈：负责存放局部变量表【基本数据类型、句柄（引用变量）/引用指针】、方法调用时形成的栈帧方法1{调用方法2[调用方法3]}... 栈满会出现StackoverflowError，部分虚拟机会动态扩展扩容，申请不到时出现OOM
问：全局变量存在哪？答：全局变量不是存储在栈中的，而是存储在方法区中的，因为它是“某个类的成员”/成员变量。问： final修饰的变量放哪？答：暂未问： static final 修饰的变量呢？答：暂未 栈的内存管理也是jvm管理的，只是不是gc而已。栈的管理是因为栈本身数据结构的特性，在函数执行完后，不用的数据自动会出栈的，释放出空间。
当然在栈中有共享池/常量池概念如下解释说明
String -Xss：猜测全称是eXtended ，Stack ，Size。规定了每个线程虚拟机栈及堆栈的大小，一般情况下，256k是足够的，此配置将会影响此进程中并发线程数的大小。java实现的swap交换没效果的很可能原因：是调用swap时，调用swap生成栈帧里拷贝了一份新的变量，跟传入时的变量已经脱轨了 3) 堆：所有线程共享、存放所有对象实例以及数组【句柄都在栈中，而数组句柄指向堆中数组的首地址，句柄（引用变量）跟堆对应对象/数组链接后也叫做存放在堆内存中的数组的别名】。
堆内存不够时，会先扩展。若无法扩展，JVM则OOM。
创建一个句柄Person;并不是对象，且存放在Java虚拟机栈中，未连接任何东西要进行初始化，当句柄跟堆内存的对象失去联系时变成了垃圾。 Java堆是垃圾收集器管理的内存区域【GC算法】，Java堆可以在物理存储上是不连续的，逻辑上是连续的。数组大部分被设计成连续内存
-Xms：猜测全称是 eXtended Memory Size , 可扩展的内存大小 。一旦对象容量超过了JAVA堆的初始容量，JAVA堆将会自动扩容到-Xmx大小。-Xmx：猜测全称是 eXtended Memory Max size ,最大可分配内存。虽然说堆内存扩容，在很多情况下，通常将-Xms和-Xmx设置成一样的，因为当堆不够用而发生扩容时，会发生内存抖动影响程序运行时的稳定性。怎么去理解堆共享呢？还记得java内部不同方法运行时可以使用同一个对象进行操作吗？，即就是引用类型，支持在堆里面使用同个数据。如果是栈内部的数据类型传参后修改不是同一个，即没法访问别的栈里面的数据，典型的swap交换实现。【本人参阅资料后总结，以及上面所写的内容】刚好去面试碰到这样的面试题：String str = new String("abc");创建了几个对象? 并且 abc 字符串之前没有用过。这毫无疑问创建了两个对象，一个是new String 创建的一个新的对象，一个是常量“abc”对象的内容创建出的一个新的String对象， 4) 方法区：采用的是元空间技术【从JVM内存中移到计算机内存中】，且各个线程共享。
主要负责存储加载类信息（接口信息、字段信息、方法信息、类名）、静态成员变量、常量【问号点？？?！】
若方法区满了，会抛出OOM异常
在1.7以后，HotSpot【我们平时用的JVM】字符串常量池从方法区移到了堆内存中，并且可以被垃圾收集器回收，这个改动降低了字符串常量池OOM的风险。而在《深入理解Java虚拟机》中并未说从方法区移至堆中。常量池还包括整数包装类型-128到127【终于找到这个点的原理 ~ 叹气】 Integer 5) 本地方法栈：只要调用方法一般用栈，负责本地方法的调用【Java调用C/python】。跟上面的Java虚拟机栈内容相似，栈满都会出现StackOverflowError
下面开始介绍运行常量池、直接内存 首先介绍了运行时常量池【跟HotSpot要区分开来】，他是方法区的一部分
1) 运行时常量池包括Class常量池。用满且无法申请抛出OOM
String 2) 直接内存也叫堆外内存【物理机内存】，是基于NIO【引入了一种基于通道与缓冲区的IO】，通过使用Native函数直接分配堆外内存，然后通过DirectByteBuffer对象作为**这块内存的引用**进行操作且该对象放堆里面，避免Java堆跟Native堆来回复制数据。【JVM虚拟机也就Java堆能够存储对象数据，想要其他地方能够存储数据则需要在本地扩展】
不受堆的内存大小限制，但受物理机总内存限制 谈谈HotSpot 也就是了解大概普遍虚拟机的模型后，书本在此将针对Hotspot进行展开！！！！爷青回
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc1ec5db8e743c20cda1b2e3bcece86b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de2c6563ecd366f5ae60361675a448c8/" rel="bookmark">
			k8s使用secret从私有仓库拉取镜像
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用docker从私有仓库拉取经销,可以使用docker login [私有仓库地址] 然后输入用户名和密码登录后就可以拉取镜像了,但如果使用k8s时,node 节点过多,难道需要跑到每个node节点去执行一次登录么?当然不是.这里就牵扯到k8s中的一个secret的东西.
Secret 有三种类型： Service Account ：用来访问 Kubernetes API，由 Kubernetes 自动创建，并且会自动挂载到 Pod 的/run/secrets/kubernetes.io/serviceaccount 目录中Opaque ：base64编码格式的Secret，用来存储密码、密钥等kubernetes.io/dockerconﬁgjson ：用来存储私有 docker registry 的认证信息 这里主要介绍第三种kubernetes.io/dockerconﬁgjson 如何使用.当使用k8s命令启动pod时,出现了
rpc error: code = Unknown desc = Error response from daemon: pull access denied for 222.212.85.199:12375/gzlt/gzlt, repository does not exist or may require 'docker login'
rpc error: code = Unknown desc = Error response from daemon: pull access denied for 222.212.85.199:12375/gzlt/gzlt, repository does not exist or may require 'docker login' 这样的错误提示,一般就是没有通过身份验证.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de2c6563ecd366f5ae60361675a448c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75142c65f891a93c1dfaa640cd90776b/" rel="bookmark">
			Vivado中备份设计好的block design
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
为了不每次都重新生成block design,避免重复劳动。
可以使用直接复制原始工程的design bd块或者使用tcl脚本生成bd。
流程
复制原始工程的bd文件夹。 （1）对于原工程生成好的bd文件夹位于如下，复制design_1文件夹。
（2）把design_1文件夹放置在新工程的工程文件夹的上一层（或者其他位置），不可放在同一层级（有尾缀为xpr的文件夹），否则导入报错。
如上图所示，放在了bd_backup文件夹中，dev为新工程所在文件夹。
（3）像添加源文件一样，可以直接把design_1文件夹导入即可。
（4）可以看到bd已经导入。
使用tcl脚本生成bd。 （1）在打开bd设计的前提下，在原工程中tcl控制台导出bd的tcl文件。
write_bd_tcl C:/Users/Administrator/Desktop/test/project_4/project_4.srcs/bdtcl.tcl
（2）复制此tcl文件到任意文件夹下。
在新工程中的tcl控制台中source此文件即可。（如果直接在当前目录下，则可以直接使用下述语句）
source bdtcl.tcl
注意：如果不在当前目录下，source后面的tcl文件要加上路径才能添加成功，比如：source C:/Users/Administrator/Desktop/test/project_4/project_4.srcs/bdtcl.tcl
(3)见证奇迹。可以看到bd文件已经导入。
转自：https://www.cnblogs.com/kingstacker/p/11606706.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7165c385d3eec7fbfca018596a7e9845/" rel="bookmark">
			操作系统原理复习题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		操作系统原理 操作系统原理复习1.名词解释1.系统调用2.死锁3.虚拟储存器4.索引节点5.中断6.临界区7.进程8.绝对路径9.资源虚化10.资源抽象记录的成组和分解 2.简答题1.简述进程的三种基本状态及其相互转换2.进程调度的时机有哪些3.I/O软件的四个层次并简述其功能4.简述SPOOLing系统的虚拟设备原理5.资源虚化与资源抽象的区别是什么6.什么叫通道技术？通道技术的作用是什么？7.简述请求页式存储管理的优缺点8.产生死锁的4个必要条件是什么？如何防止死锁的发生9.存储管理的功能是什么？10.I/O软件分为四个层次，试说明以下各个工作是在哪一层完成的11.虚拟存储器大小有什么限制？12.文件操作有哪些13.进程间同步和互斥的含义是什么？分别解决什么问题？14.程序状态字包含哪些主要内容15.什么是输入输出操作16.为实现分页式虚拟存储，页表中至少应包含有哪些内容17.简述请求页式存储管理的优缺点18.虚拟存储器的基本特征是什么？虚拟存储器的容量主要受到什么限制19.段页式管理这种存储管理方式中为什么要设置高速联想寄存器？20.进程和程序有什么区别和联系21.什么是系统调用？简述系统调用的实现过程22.简述操作系统的基本特征。23.试分析引起进程阻塞和唤醒的事件主要有哪些24.简述在操作系统中引入缓冲的主要原因25.以独占设备为例，简述设备分配的过程。26.在操作系统中，P操作和V操作各自的动作是如何定义的。27.二级目录和多级目录的好处28.什么是分页，什么是分段？二者的主要区别是什么。 第一章知识点1.设计现代os的主要目标是2.OS的作用可表现在那几个方面3.为什么说OS实现了对计算机资源的抽象4.实现分时系统的关键问题是什么？问题如何解决？5.OS有哪几大特征？其最基本的特征是什么？6.处理机管理有哪些主要功能？他们的主要任务是什么？7.何谓脱机I/O和联机I/O8.什么是时分复用技术？举例说明它能提高资源利用率的根本原因是什么。9.是什么原因使操作系统具有异步性特征10.内存管理有哪些主要功能？其主要功能是什么？11.设备管理有哪些主要功能？其主要任务是什么？ 第二章知识点1.程序并发执行为什么会失去封闭性和可再现性？2.试说明进程在三个基本状态之间转换的典型原因3.消息队列通信机制有哪几方面功能。4.常见的进程同步问题代码JAVA 第三章知识点1.高级调度与低级调度的主要任务是什么？为什么要引入中级调度？2.在作业调度中应如何确定接纳多少个作业和接纳哪些作业？3.试说明低级调度的主要功能4.在时间片轮转法中，应如何确定时间片的大小？5.为什么说传统的几种调度算法都不能算是公平调度方法？6.保证调度算法是如何做到调度的公平性的7.公平分享调度算法又是如何做到调度的公平性的8.什么是最早截止时间优先调度算法？举例说明。9.什么是最低松弛度优先算法？举例说明。 第四章知识点1.何谓静态链接？静态链接时需要解决两个什么问题？2.何谓装入时动态链接？装入时动态链接方式有何优点？3.在动态分区分配方式中，应如何将各空闲分区链接成空闲分区链。4.为什么要引入动态重定位？如何实现？5.什么是基于动态顺序搜索的动态分区分配算法？它可分为哪几种？6. 什么是基于引索搜索的动态分区分配算法？它可分为几种？7.为什么要引入对换？对换可分为哪几种类型8.什么是页面？什么是物理块？页面的大小应该如何确定？9.什么是页10.在分页系统中是如何实现地址转换的11.具有快表时是如何实现地址变换的12.在具有快表的段页式存储管理方式中，如何实现地址变换？13.为什么说分段系统比分页系统更易于实现信息的共享和保护？14.分页和分段存储管理有何区别？ 第五章1.虚拟存储器有哪些特征？其中最本质的特征是什么？2.在请求分页系统中，页表应包含哪些数据项？每项的作用是什么？3.试说明请求分页系统中的地址变换过程4.在请求分页系统中，常采用哪几种页面置换算法5.在请求分页系统中，产生“抖动”的原因是什么6.在请求段表机制中，因设置哪些段表项。![在这里插入图片描述](https://img-blog.csdnimg.cn/20201228135742948.png)7.说明请求分段系统中的缺页中断处理过程8.如何实现共享分段的分配和回收 第六章1.知识点题型1.与设备无关性的基本含义是什么？为什么要设置该层？2.什么是内存映像I/O?它是如何实现的？3.试说明设备驱动程序具有哪些特点4.在考虑到设备的独立性时，应如何分配独占设备?5.在单缓冲情况下，为什么系统对一块数据的处理时间为max（C,T）+M？6.磁盘访问时间由哪几部分组成？每部分时间该如何计算？ 第七章知识点这章基本都是小题 第八章知识点 填空题 操作系统原理复习 计算机操作系统是方便用户管理和控制计算机软硬件资源的系统软件（或程序集合）
操作系统目前有五大类型（批处理、分时、实时、网络和分布式）和五大功能（作业管理、文件管理、存储管理、设备管理和进程管理）
1.名词解释 1.系统调用 答案：系统调用是为了扩展机器的功能，增强系统能力，方便用户使用而在内核中建立的过程（函数），它是用户程序或其它系统程序获得操作系统服务的唯一途径，系统调用也成为广义指令。
2.死锁 答案：在一个进程集合中的每个进程都在等待只能由该集合中的其它进程才能引发的事件，而无限期陷入僵持的局面
指并发进程彼此互相等待对方所用的资源，而且这些并发进程在得到对方的资源之前不会释放自己所拥有的资源，从而造成大家都想得到资源又得不到资源，个并发进程不能继续向前推进的状态
3.虚拟储存器 答案：在具有层次结构存储器的计算机系统中，采用自动实现部分装入和部分对换功能，为用户提供一个比物理主存容量大，可寻址的模拟“主存储器”，有进程中的目标代码、数据等的虚拟地址组成的虚拟空间称为虚拟存储器。也可解释为仅把作业的一部分装入内存便可运行作业的操作系统；具体的说是指具有调入功能和置换功能，能从逻辑上对内存容量进行扩充的一种存储器系统
4.索引节点 答案：索引节点是一种目录结构组织方式。该方法将查找文件所需的文件名与找到文件后需要访问的文件属性信息分开存放，查找期间仅需加载由文件名和标识文件属性信息存放位置的索引节点号组成的基本目录项。找到目标目录后，才根据索引节点号加载所需文件属性信息项。
5.中断 答案：中断是指程序执行过程中，当发生某个事件时，中止cpu上现行程序的运行，引出处理该事件程序的执行过程
6.临界区 答案：并发进程中与共享变量有关的程序段称为“临界区”
7.进程 答案：进程是一个可并发执行的，具有独立功能的程序关于某个数据集合的一次执行过程，也是操作系统进行资源分配和保护的基本单位
8.绝对路径 答案：从根目录到文件的路径串称为绝对路径
9.资源虚化 答案：资源虚化是指利用一类事物模拟另一类事物，造成另一类事物数量更多或者容量更大的假象
10.资源抽象 答案：资源抽象是指利用软件封装复杂的硬件或软件设施，简化资源应用接口的一种资源管理技术
记录的成组和分解 答案：1.把若干逻辑记录合并成一组，存入一个物理块的工作称为记录的成组
2.从一组中把一个逻辑记录分离出来的工作称为记录的分解
2.简答题 1.简述进程的三种基本状态及其相互转换 答：进程的三种基本状态：就绪，运行和等待
进程状态间的四种转换如下：1.运行态–&gt;等待态：等待使用资源或某事件发生；2.等待态–&gt;就绪态：资源得到满足或者事件发生；3.运行态–&gt;就绪态：运行时间片断或者出现更高优先级进程；4.就绪态–&gt;运行态：CPU空闲时选择一个就绪进程
2.进程调度的时机有哪些 答：进程调度的时机有四种：1.当进程进入等待态时；2.当进程完成其系统调用返回用户态，但不是最有资格获得CPU时；3.当内核完成中断处理，进程返回用户态但不是最有资格而获得CPU时；4.当进程执行结束时；
3.I/O软件的四个层次并简述其功能 答：I/O软件的四个层次：I/O中断处理程序，设备驱动程序，独立于设备的I/O软件，用户空间的I/O软件。中断处理程序的功能时发生中断时查明中断缘由，获取设备状态，唤醒用户进程。设备驱动程序的主要功能：设备初始化，控制设备运行或者退出服务，控制设备与内核之间交换数据，设备出错检测和处理。设备无关I/O软件功能：设备管理功能，缓冲管理错误报告，分配与释放设备，提供与设备无关的，用户空间的I/O软件作用：产生I/O请求，I/O格式化，假脱机
4.简述SPOOLing系统的虚拟设备原理 答：SPooling系统即假脱机系统。将原来以联机方式使用的独占设备改造成脱机使用的虚拟共享设备。在练级方式下，每个需要设备I/O的进程排队等待向设备提交输入输出作业。
5.资源虚化与资源抽象的区别是什么 答：资源虚化与资源抽象的区别在于：资源虚化强调从逻辑上扩充资源数量；而资源抽象强调封装，隐藏软硬件内部细节，简化资源应用结构
6.什么叫通道技术？通道技术的作用是什么？ 通道是一个独立于CPU的转关输入/输出控制的处理机，它控制设备与内容直接进行数据交换，它有自己的通道指令，这些通道指令受CPU启动，并在操作结束时向CPU发中断信号。通道方式进一步减轻了CPU的工作负担，增加了计算机系统的并行工作程序
7.简述请求页式存储管理的优缺点 答：优点：1.虚存量大，适合多道程序运行，用户不必担心内存不够的调度操作。动态页式管理提供了内存与外存统一管理的虚存实现方式，2.内存利用率高，不常用的页面尽量不留在内存3.不要求作业连续存放，有效的解决了碎片问题。与分区化管理比，不需要移动作业，与多重分区比，无零星碎片产生。
8.产生死锁的4个必要条件是什么？如何防止死锁的发生 答：产生死锁的必要条件：1.互斥条件2.占有和等待条件3.不剥夺条件4.循环等待条件
只要破坏产生死锁的四个条件之一既可防止死锁的发生，破坏互斥条件使资源可同时访问而而不是互斥使用，静态分配可以破坏占有和等待条件，破坏不剥夺条件及用有剥夺式调度方法，采用层次分配策略可以破坏循环等待条件。
9.存储管理的功能是什么？ 答：1.内存分配和回收2.内存抽象和映射3.存储隔离和共享4.存储扩展
10.I/O软件分为四个层次，试说明以下各个工作是在哪一层完成的 答：
1.向设备寄存器发写命令、唤醒请求I/O的进程：设备驱动程序
2.设备缓冲区管理、逻辑地址转换为物理地址：操作系统的I/O软件
3.检查设备状态寄存器内容：在I/O中断处理程序
4.将二进制整数转化成ASCII码以便于打印、用户进程请求打印一个输出文件：用户层I/O软件
11.虚拟存储器大小有什么限制？ 答:虚拟存储器是利用外存的一部分（对换区），通过在内外存之间对换进程，从逻辑上扩充内存容量。外存容量远大于内存容量，但能够用来扩充内存容量的外存仅仅是其中的一小部分，因为虚拟存储器的容量受地址总线宽度的制约，地址总线宽度决定了程序可访问的最大地址空间，超过该空间的存储区域或者说是地址是无法访问的
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7165c385d3eec7fbfca018596a7e9845/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8db20620aac1a0a10b5a53dd9921eb6/" rel="bookmark">
			PostgreSQL 常用函数， 比较全面的总结。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PostgreSQL 常用函数 PostgreSQL 内置函数也称为聚合函数，用于对字符串或数字数据执行处理。
下面是所有通用 PostgreSQL 内置函数的列表：
COUNT 函数：用于计算数据库表中的行数。MAX 函数：用于查询某一特定列中最大值。MIN 函数：用于查询某一特定列中最小值。AVG 函数：用于计算某一特定列中平均值。SUM 函数：用于计算数字列所有值的总和。ARRAY 函数：用于输入值(包括null)添加到数组中。Numeric 函数：完整列出一个 SQL 中所需的操作数的函数。String 函数：完整列出一个 SQL 中所需的操作字符的函数。 数学函数 下面是PostgreSQL中提供的数学函数列表，需要说明的是，这些函数中有许多都存在多种形式，区别只是参数类型不同。除非特别指明，任何特定形式的函数都返回和它的参数相同的数据类型。
函数返回类型描述例子结果abs(x) 绝对值abs(-17.4)17.4cbrt(double) 立方根cbrt(27.0)3ceil(double/numeric) 不小于参数的最小的整数ceil(-42.8)-42degrees(double) 把弧度转为角度degrees(0.5)28.6478897565412exp(double/numeric) 自然指数exp(1.0)2.71828182845905floor(double/numeric) 不大于参数的最大整数floor(-42.8)-43ln(double/numeric) 自然对数ln(2.0)0.693147180559945log(double/numeric) 10为底的对数log(100.0)2log(b numeric,x numeric)numeric指定底数的对数log(2.0, 64.0)6.0000000000mod(y, x) 取余数mod(9,4)1pi()double"π"常量pi()3.14159265358979power(a double, b double)double求a的b次幂power(9.0, 3.0)729power(a numeric, b numeric)numeric求a的b次幂power(9.0, 3.0)729radians(double)double把角度转为弧度radians(45.0)0.785398163397448random()double0.0到1.0之间的随机数值random() round(double/numeric) 圆整为最接近的整数round(42.4)42round(v numeric, s int)numeric圆整为s位小数数字round(42.438,2)42.44sign(double/numeric) 参数的符号(-1,0,+1)sign(-8.4)-1sqrt(double/numeric) 平方根sqrt(2.0)1.4142135623731trunc(double/numeric) 截断(向零靠近)trunc(42.8)42trunc(v numeric, s int)numeric截断为s小数位置的数字trunc(42.438,2)42.43 三角函数列表 函数描述acos(x)反余弦asin(x)反正弦atan(x)反正切atan2(x, y)正切 y/x 的反函数cos(x)余弦cot(x)余切sin(x)正弦tan(x)正切 字符串函数和操作符 下面是 PostgreSQL 中提供的字符串操作符列表：
函数返回类型描述例子结果string 丨丨 stringtext字串连接'Post' 丨丨 'greSQL'PostgreSQLbit_length(string)int字串里二进制位的个数bit_length('jose')32char_length(string)int字串中的字符个数char_length('jose')4convert(string using conversion_name)text使用指定的转换名字改变编码。convert('PostgreSQL' using iso_8859_1_to_utf8)'PostgreSQL'lower(string)text把字串转化为小写lower('TOM')tomoctet_length(string)int字串中的字节数octet_length('jose')4overlay(string placing string from int [for int])text替换子字串overlay('Txxxxas' placing 'hom' from 2 for 4)Thomasposition(substring in string)int指定的子字串的位置position('om' in 'Thomas')3substring(string [from int] [for int])text抽取子字串substring('Thomas' from 2 for 3)homsubstring(string from pattern)text抽取匹配 POSIX 正则表达式的子字串substring('Thomas' from '…$')massubstring(string from pattern for escape)text抽取匹配SQL正则表达式的子字串substring('Thomas' from '%#"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8db20620aac1a0a10b5a53dd9921eb6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/816813d2ad84bcabfcf315b50561e618/" rel="bookmark">
			从零开始学PCR技术（五）：试验污染
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PCR 反应最大的特点是具有较大的扩增能力和极高的灵敏度，正因为如此，极其微量的污染即可造成检测结果的假阳性。监控污染，防止污染对检测结果的影响，不仅对实验，对后续生信分析也提出了挑战。
一、污染原因 1. 交叉污染 (1) 容器被污染。
(2) 标本放置时，由于密封不严溢于容器外。
(3) 容器外粘有标本而造成相互间交叉污染。
(4) 标本核酸模板在提取过程中，由于吸样枪污染导致标本间污染。
(5) 有些微生物标本尤其是病毒可随气溶胶或形成气溶胶而扩散，导致彼此间的污染。
2. 试剂污染 PCR 试剂配制过程中，由于加样枪、容器、双蒸水及其它溶液被 PCR 核酸模板污染。
3. 扩增产物污染 这是 PCR 污染最主要的形式，因为：
(1) PCR 产物拷贝量大（一般为 10^13 拷贝/ml），远远高于 PCR 检测数个拷贝的极限，所以极微量的 PCR 产物污染，就可形成假阳性。
(2) 最有可能造成 PCR 产物污染的形式是气溶胶污染。在空气与液体面摩擦时就可形成气溶胶，在操作时比较剧烈地摇动反应管，开盖时、吸样时及污染进样枪的反复吸样都可形成气溶胶而污染。据计算一个气溶胶颗粒可含 48000 拷贝，因而由其造成的污染是一个值得特别重视的问题。
4. 克隆质粒污染 (1) 某些用克隆质粒做阳性对照的检验室，这个问题比较常见。
(2) 克隆质粒在单位容积内含量相当高，另外在纯化过程中需用较多的用具及试剂，而且在活细胞内的质粒，由于活细胞的生长繁殖的简便性及具有很强的生命力，其污染可能性也很大。
二、污染监测 通常使用对照对检测的各个环节进行监控，常用的对照有以下这些。
(一) PCR 中的对照 1. 阳性对照与阴性对照 阳性对照和阴性对照是指在相同的处理条件下，比如一份已知的感染样品和一份已知的未感染样品，都进行了提取和扩增最终获得了阳性结果和阴性结果。阴阳性对照强调处理过程与样品一致，并且有明确的预期结果。
2. 扩增对照 我们通常说的阳性对照和阴性对照指的是扩增试剂盒中附带的不需要提取的阳性对照和阴性对照，更准确的定义应该是扩增阳性对照和扩增阴性对照。扩增阳性对照含有阳性扩增模板，扩增阴性对照应含有阴性扩增模板（基质核酸）。扩增对照只能监控每次扩增过程中的扩增系统是否正常，不能监控采样、提取和每份样品的操作过程。如果是检测 RNA 样品的检测试剂盒，其扩增阳性对照使用质粒，便无法监控反转录过程。
3. 内标（Internal Control, IC） 内标是指在同一反应管中与靶序列共同扩增的一段非靶序列分子。内标有两种形式，一种是使用天然样品中含有的内参基因作为内标，另一种是人工添加的内标。内标的最大特点是与靶序列共同扩增，而其他的对照都是独立扩增。
(1) 内参基因
通常它们在各组织和细胞中的表达相对恒定，在检测基因的表达水平变化时常用它来做参照物。内参基因通常是管家基因（house-keeping gene）因为其表达水平受环境因素影响较小，而且在个体各个生长阶段的几乎全部组织中持续表达变化很小。常用的内参基因包括 GAPDH、β-actin (BETA-actin)、18sRNA、B2M、HPRT 和 TBP 等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/816813d2ad84bcabfcf315b50561e618/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f2e789d3878d1ddc952206cfb194a4b/" rel="bookmark">
			PostgreSQL LOCK（锁）；排它锁（Exclusive Locks）和共享锁（Share Locks）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PostgreSQL LOCK（锁） 锁主要是为了保持数据库数据的一致性，可以阻止用户修改一行或整个表，一般用在并发较高的数据库中。
在多个用户访问数据库的时候若对并发操作不加控制就可能会读取和存储不正确的数据，破坏数据库的一致性。
数据库中有两种基本的锁：排它锁（Exclusive Locks）和共享锁（Share Locks）。
如果数据对象加上排它锁，则其他的事务不能对它读取和修改。
如果加上共享锁，则该数据库对象可以被其他事务读取，但不能修改。
LOCK 命令语法 LOCK 命令基础语法如下：
LOCK [ TABLE ] name IN lock_mode name：要锁定的现有表的名称（可选模式限定）。如果只在表名之前指定，则只锁定该表。如果未指定，则锁定该表及其所有子表（如果有）。lock_mode：锁定模式指定该锁与哪个锁冲突。如果没有指定锁定模式，则使用限制最大的访问独占模式。可能的值是：ACCESS SHARE，ROW SHARE， ROW EXCLUSIVE， SHARE UPDATE EXCLUSIVE， SHARE，SHARE ROW EXCLUSIVE，EXCLUSIVE，ACCESS EXCLUSIVE。 一旦获得了锁，锁将在当前事务的其余时间保持。没有解锁表命令；锁总是在事务结束时释放。
死锁 当两个事务彼此等待对方完成其操作时，可能会发生死锁。尽管 PostgreSQL 可以检测它们并以回滚结束它们，但死锁仍然很不方便。为了防止应用程序遇到这个问题，请确保将应用程序设计为以相同的顺序锁定对象。
咨询锁 PostgreSQL 提供了创建具有应用程序定义含义的锁的方法。这些被称为咨询锁。由于系统不强制使用它们，所以正确使用它们取决于应用程序。咨询锁对于不适合 MVCC 模型的锁定策略非常有用。
例如，咨询锁的一个常见用途是模拟所谓"平面文件"数据管理系统中典型的悲观锁定策略。虽然存储在表中的标志可以用于相同的目的，但是通知锁更快，避免了表膨胀，并且在会话结束时由服务器自动清理。
实例 创建 COMPANY 表（下载 COMPANY SQL 文件 ），数据内容如下：
runoobdb# select * from COMPANY; id | name | age | address | salary ----+-------+-----+-----------+-------- 1 | Paul | 32 | California| 20000 2 | Allen | 25 | Texas | 15000 3 | Teddy | 23 | Norway | 20000 4 | Mark | 25 | Rich-Mond | 65000 5 | David | 27 | Texas | 85000 6 | Kim | 22 | South-Hall| 45000 7 | James | 24 | Houston | 10000 (7 rows) 下面的示例将 runoobdb 数据库中的 COMPANY 表锁定为 ACCESS EXCLUSIVE 模式。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f2e789d3878d1ddc952206cfb194a4b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26632c21835d67bcf51ab3cb5e519ab1/" rel="bookmark">
			PostgreSQL     ：TRANSACTION（事务）,COMMIT确认事件/ROLLBACK回滚事件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PostgreSQL TRANSACTION（事务） TRANSACTION（事务）是数据库管理系统执行过程中的一个逻辑单位，由一个有限的数据库操作序列构成。
数据库事务通常包含了一个序列的对数据库的读/写操作。包含有以下两个目的：
为数据库操作序列提供了一个从失败中恢复到正常状态的方法，同时提供了数据库即使在异常状态下仍能保持一致性的方法。当多个应用程序在并发访问数据库时，可以在这些应用程序之间提供一个隔离方法，以防止彼此的操作互相干扰。 当事务被提交给了数据库管理系统（DBMS），则 DBMS 需要确保该事务中的所有操作都成功完成且其结果被永久保存在数据库中，如果事务中有的操作没有成功完成，则事务中的所有操作都需要回滚，回到事务执行前的状态；同时，该事务对数据库或者其他事务的执行无影响，所有的事务都好像在独立的运行。
事务的属性 事务具有以下四个标准属性，通常根据首字母缩写为 ACID：
原子性（Atomicity）：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。一致性（Consistency）：事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致状态的含义是数据库中的数据应满足完整性约束。隔离性（Isolation）：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。持久性（Durability）：已被提交的事务对数据库的修改应该永久保存在数据库中。 例子 某人要在商店使用电子货币购买100元的东西，当中至少包括两个操作：
该人账户减少 100 元。商店账户增加100元。 支持事务的数据库管理系统就是要确保以上两个操作（整个"事务"）都能完成，或一起取消，否则就会出现 100 元平白消失或出现的情况。
事务控制 使用下面的命令来控制事务：
BEGIN TRANSACTION：开始一个事务。COMMIT：事务确认，或者可以使用 END TRANSACTION 命令。ROLLBACK：事务回滚。 事务控制命令只与 INSERT、UPDATE 和 DELETE 一起使用。他们不能在创建表或删除表时使用，因为这些操作在数据库中是自动提交的。
BEGIN TRANSACTION 命令 事务可以使用 BEGIN TRANSACTION 命令或简单的 BEGIN 命令来启动。此类事务通常会持续执行下去，直到遇到下一个 COMMIT 或 ROLLBACK 命令。不过在数据库关闭或发生错误时，事务处理也会回滚。以下是启动一个事务的简单语法：
BEGIN; 或者 BEGIN TRANSACTION; COMMIT 命令 COMMIT 命令是用于把事务调用的更改保存到数据库中的事务命令，即确认事务。
COMMIT 命令的语法如下：
COMMIT; 或者 END TRANSACTION; ROLLBACK 命令 ROLLBACK 命令是用于撤消尚未保存到数据库的事务命令，即回滚事务。
ROLLBACK 命令的语法如下：
ROLLBACK; 实例 创建 COMPANY 表（下载 COMPANY SQL 文件 ），数据内容如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/26632c21835d67bcf51ab3cb5e519ab1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/852670ab0ac2d9bba1bb18c7f5443e35/" rel="bookmark">
			keil5安装器件包的过程报错：svDConv returned with an error.No uVision SystemViewer file created.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在安装keil5器件库的途中出现如下错误，
报错如图：
出错原因：
1、安装的器件包版本太高
2、keil5软件版本太低
解决原因：
1、下载更低版本的应用单片机的器件包
2、升级keil5软件
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52cc3810bdf1146d1bf032161224b22c/" rel="bookmark">
			PostgreSQL ALTER TABLE 命令、添加，修改，删除表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PostgreSQL ALTER TABLE 命令 在 PostgreSQL 中，ALTER TABLE 命令用于添加，修改，删除一张已经存在表的列。
另外你也可以用 ALTER TABLE 命令添加和删除约束。
语法 用 ALTER TABLE 在一张已存在的表上添加列的语法如下：
ALTER TABLE table_name ADD column_name datatype; 在一张已存在的表上 DROP COLUMN（删除列），语法如下：
ALTER TABLE table_name DROP COLUMN column_name; 修改表中某列的 DATA TYPE（数据类型），语法如下：
ALTER TABLE table_name ALTER COLUMN column_name TYPE datatype; 给表中某列添加 NOT NULL 约束，语法如下：
ALTER TABLE table_name MODIFY column_name datatype NOT NULL; 给表中某列 ADD UNIQUE CONSTRAINT（ 添加 UNIQUE 约束），语法如下：
ALTER TABLE table_name ADD CONSTRAINT MyUniqueConstraint UNIQUE(column1, column2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/52cc3810bdf1146d1bf032161224b22c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d5a12f58c31cc2d81719b4a81da0398/" rel="bookmark">
			学会Swagger，接口调试不再烦恼！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 最近在做一个基于微服务的在线教育项目，由于前后端都是要自己写，所以接口的调试便成了一个比较重要的问题。尤其是在自己一个人开发或者的时候作用显得尤为重要。在写项目的时候我总是喜欢先写后端接口，然后再去处理前端，最后进行整合联调。
大部分的人的开发流程也应该是这样的。在开发的过程中有一个问题一直很困扰我们，**每当我们写完一个接口想要测试它是否按要求返回对象的数据，**以前的做法往往是启动服务，然后在浏览输入对应的接口地址和参数进行数据请求。
这种情况下，当接口没有请求传入的参数或者是参数只有一两个的时候还好，但是当传参多了之后，你会觉得很麻烦。
从另一方面讲，但后端写得接口很多的，在写完之后需要进行修改或者调试的时候，你会发现是自己的controller非常的乱。
再这样的情况下，一款好用的API框架—Swgger稳健上位!
什么是Swagger Swgger是一款可用于设计、构建、文档化并且执行API的框架。是一个规范和完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务。
这是官网对Swagger的介绍：
Swagger UI允许任何人（无论您是开发团队还是最终用户）都可以可视化API资源并与之交互，而无需任何实现逻辑。它是根据您的OpenAPI（以前称为Swagger）规范自动生成的，具有可视化文档，可轻松实现后端实现和客户端使用。
那什么又是RESTful风格呢？
百度百科是这样说的—restful是一种软件架构风格、设计风格，而不是标准，只是提供了一组设计原则和约束条件。它主要用于客户端和服务器交互类的软件。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。
我们可以理解为：它是一种互联网应用程序的API设计理念：URL定位资源，用HTTP动词（GET,POST,DELETE,DETC）描述操作。RESTful可以通过一套统一的接口为 Web，iOS和Android提供服务
Swagger的作用 Swagger可以轻松的创建一个API文档，前后端分离开发模式中，api文档是最好的沟通方式。
Swagger使用方法 1.引入依赖 &lt;!--swagger--&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;scope&gt;provided &lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;scope&gt;provided &lt;/scope&gt; &lt;/dependency&gt; 2.创建swagger的配置类 @Configuration @EnableSwagger2 public class SwaggerConfig { @Bean public Docket webApiConfig(){ return new Docket(DocumentationType.SWAGGER_2) .groupName("分组名称") .apiInfo(webApiInfo()) .select() .paths(Predicates.not(PathSelectors.regex("/admin/.*"))) .paths(Predicates.not(PathSelectors.regex("/error.*"))) .build(); } private ApiInfo webApiInfo(){ return new ApiInfoBuilder() .title("你的借口文档名称") .description("你的接口文档描述") .version("1.0") .contact(new Contact("Helen", "http://atguigu.com", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d5a12f58c31cc2d81719b4a81da0398/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7850b49da91679b2e6c2233d479902f/" rel="bookmark">
			python货币转换编程_Python实现制度转换（货币，温度，长度）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		人民币和美元是世界上通用的两种货币之一，写一个程序进行货币间币值转换，其中：
人民币和美元间汇率固定为：1美元 = 6.78人民币。
程序可以接受人民币或美元输入，转换为美元或人民币输出。人民币采用RMB表示，美元USD表示，符号和数值之间没有空格
示例1：RMB123
示例2：USD20
TempStr = input()
if TempStr[0:3] in ['RMB']:
C = eval(TempStr[3:])/6.78
print("USD{:.2f}".format(C))
elif TempStr[0:3] in['USD']:
F = 6.78*eval(TempStr[3:])
print("RMB{:.2f}".format(F))
温度的刻画有两个不同体系：摄氏度(Celsius)和华氏度(Fabrenheit)。
请编写程序将用户输入华氏度转换为摄氏度，或将输入的摄氏度转换为华氏度。
转换算法如下：(C表示摄氏度、F表示华氏度)
C = ( F - 32 ) / 1.8
F = C * 1.8 + 32
要求如下：
(1) 输入输出的摄氏度采用大写字母C开头，温度可以是整数或小数，如：C12.34指摄氏度12.34度；
(2) 输入输出的华氏度采用大写字母F开头，温度可以是整数或小数，如：F87.65指摄氏度87.65度；
示例1：C12.34
示例2：F87.65
TempStr = input()
if TempStr[0] in['f','F']:
C = (eval(TempStr[1:])-32)/1.8
print("C{:.2f}".format(C))
elif TempStr[0] in['C','c']:
F = 1.8*eval(TempStr[1:])+32
print("F{:.2f}".format(F))
编写一个程序，计算输入数字N的0次方到5次方结果，并依次输出这6个结果，输出结果间用空格分隔。其中：N是一个整数或浮点数。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7850b49da91679b2e6c2233d479902f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b68583128935c7bb493b4bb05699b4c/" rel="bookmark">
			python字符串末尾添加字符_Python-始终将某些字符串附加到列表的末尾
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我碰壁了,需要一些帮助或建议才能使我通过.
我想将某些字符串始终附加在列表的末尾.
所以我们有
List1 = ["sony","cant recall","samsung","dont know","apple","no answer", "toshiba"]
接下来,我们还有另一个列表
List2 = ["dont know", "cant recall","no answer"]
到目前为止,这是我开发的.脚本基本上检查列表1中的单词是否在列表2中(如果找到),则应将特定字符串从列表中的当前位置移到末尾.但是我现在所能做的就是找到字符串及其索引.我不知道如何移动并将找到的字符串附加到列表的末尾.
for p, item in enumerate(list1):
for i, element in enumerate(list2):
if item == element:
print item, p
谢谢！
解决方法:
您可以按照以下方式进行算法：
list1 = [x for x in list1 if not x in list2] + [x for x in list1 if x in list2]
这将导致：
['sony', 'samsung', 'apple', 'toshiba', 'cant recall', 'dont know', 'no answer']
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b68583128935c7bb493b4bb05699b4c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5078efb4e063a3cab6fd136777b2627e/" rel="bookmark">
			npm install 出现错误 ENOENT：no such file or directory,open xxxxxxxxx的解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.具体现象如下如：
2.解决办法：删除node_modules包， package-lock.json 文件后重新安装。
3.如果你只想解决以上问题，看到这里就够了。
4.出现的原因：项目之前安装过node_modules包，后来再次安装时出现此错误，分析原因为前后两次安装的时候包的来源不同。
第二次安装的时候npm config被我修改过，修改为了淘宝源。
网上解决这个问题的资料较少，并且我试了几个，对我不起作用，后来思考我们每次安装包的时候本地会生成一个package-lock.json文件，而此文件也会再我们独立安装某一个包的时候会修改，可能这个包保存了一些信息。打开一看，果然如此：
"acorn": {
"version": "5.7.4",
"resolved": "https://registry.npm.taobao.org/acorn/download/acorn-5.7.4.tgz?cache=0&amp;sync_timestamp=1597235845861&amp;other_urls=https%3A%2F%2Fregistry.npm.taobao.org%2Facorn%2Fdownload%2Facorn-5.7.4.tgz",
"integrity": "sha1-Po2KmUfQWZoXltECJddDL0pKz14=",
"dev": true
},
"acorn-dynamic-import": {
"version": "2.0.2",
"resolved": "https://registry.npm.taobao.org/acorn-dynamic-import/download/acorn-dynamic-import-2.0.2.tgz",
"integrity": "sha1-x1K9IQvvZ5UBtsbLf8hPj0cVjMQ=",
"dev": true,
"requires": {
"acorn": "^4.0.3"
},
"dependencies": {
"acorn": {
"version": "4.0.13",
"resolved": "https://registry.npm.taobao.org/acorn/download/acorn-4.0.13.tgz?cache=0&amp;sync_timestamp=1597235845861&amp;other_urls=https%3A%2F%2Fregistry.npm.taobao.org%2Facorn%2Fdownload%2Facorn-4.0.13.tgz",
"integrity": "sha1-EFSVrlNh1pe9GVyCUZLhrX8lN4c=",
"dev": true
}
}
}
以上截取一部分数据：此内容描述项目及项目所依赖的模块信息。
不同源的这个信息是不一样的，所以，删除这个信息，重新安装的时候会重新生成，且不会再出现上面的错误了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5353de7183b69f727d72ddc10eece41b/" rel="bookmark">
			kafka key的作用_一探究竟，详解Kafka生产者和消费者的工作原理！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		主题和日志 对于每个主题，Kafka群集都会维护一个分区日志，如下所示：
每个分区（Partition）都是有序的(所以每一个Partition内部都是有序的)，不变的记录序列，这些记录连续地附加到结构化的提交日志中。分区中的每个记录均分配有一个称为偏移的顺序ID号，该ID 唯一地标识分区中的每个记录。
每个消费者保留的唯一元数据是该消费者在日志中的偏移量或位置。此偏移量由使用者控制：通常，使用者在读取记录时会线性地推进其偏移量，但实际上，由于位置是由使用者控制的，因此它可以按喜欢的任何顺序使用记录。例如，使用者可以重置到较旧的偏移量以重新处理过去的数据，或者跳到最近的记录并从“现在”开始使用。（类似于游标指针的方式顺序处理数据，并且该指标可以任意移动）
分区的设计结构
提供了负载均衡的能力，实现了系统的高伸缩性。不同的分区能够被放置到不同节点的机器上，而数据的读写操作也都是针对分区这个粒度而进行的，这样每个节点的机器都能独立地执行各自分区的读写请求处理。可以通过添加新的节点机器来增加整体系统的吞吐量。Kafka分区的设计逻辑和ES分片的设计逻辑是相同的。 生产者分区策略 生产者分区策略是 决定生产者将消息发送到哪个分区的算法，
主要有以下几种：
轮询策略：Round-robin 策略，即顺序分配，
轮询策略有非常优秀的负载均衡表现，它总是能保证消息最大限度地被平均分配到所有分区上，故默认情况下它是最合理的分区策略。（默认、常用）随机策略： Randomness 策略。所谓随机就是我们随意地将消息放置到任意一个分区上。消息键保序策略：key-ordering 策略，Kafka 中每条消息都会有自己的key，一旦消息被定义了 Key，那么你就可以保证同一个
Key 的所有消息都进入到相同的分区里面，由于每个分区下的消息处理都是有顺序的 kafka消息的有序性，是采用消息键保序策略来实现的。
一个topic，一个partition(分割)，一个consumer，内部单线程消费，写N个内存queue，然后N个线程分别消费一个内存queue。
通过指定key的方式，具有相同key的消息会分发到同一个partitionpartition会内部对其进行排序，保证其有序性。 Kafka的消息压缩机制 kafka发送进行消息压缩有两个地方，分别是生产端压缩和Broker端压缩。
一般情况下压缩机制：在生产者端解压、Broker端保持、消费者端解压Kafka 支持 4 种压缩算法：GZIP、Snappy 、LZ4，从 2.1.0 开始，Kafka 正式支持 Zstandard
算法（简写为 zstd）。压缩机制本质上以消费者端CPU性能换取节省网络传输带宽以及Kafka Broker端的磁盘占用。 生产者端压缩
生产者压缩通常采用的GZIP算法这样 Producer 启动后生产的每个消息集合都是经 GZIP 压缩过的，故而能很好地节省网络传输带宽以及 Kafka Broker 端的磁盘占用。
配置参数：
&lt;!-- 定义producer的参数 --&gt; &lt;bean id="producerProperties" class="java.util.HashMap"&gt; &lt;constructor-arg&gt; &lt;map&gt; &lt;entry key="bootstrap.servers" value="127.0.0.1:9092"/&gt; &lt;!-- acks表示所有需同步返回确认的节点数，all或者‑1表示分区全部备份节点均需响应，可靠性最 高，但吞吐量会相对降低； 1表示只需分区leader节点响应； 0表示无需等待服务端响应； 大部分业务建议配置1，风控或安全建议配置0 --&gt; &lt;entry key="acks" value="1"/&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5353de7183b69f727d72ddc10eece41b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90dfc423880e4301ddd6c10e405e24f9/" rel="bookmark">
			uniapp、Vue中 image 如何设置默认图片，图片地址加载失败（404）的话就显示默认图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、解决方法（在单层循环中）
HTML：
在image标签当中添加@error，用来监听图片地址加载失败，同时传递参数
&lt;image v-else :src="item" mode="aspectFit" @error="imgerror($event, index)"&gt;&lt;/image&gt; JS：
imgerror(e, index) { this.xiangqingUrl.splice(index, 1) this.xiangqingUrl.splice(index, 0, '/static/img/noimg.png') }, 单层结构默认图片可能因为数组长度没有发生改变，因此Vue不会更新数据，因此我们需要删除一个元素后再新增一个默认图片地址，使得Vue发生数据更新。
二、双层循环嵌套解决方法
HTML：
在image标签当中添加@error，用来监听图片地址加载失败，同时传递参数
&lt;swiper-item v-for="(value , indexs) in item.phonts" :key="indexs" &gt; &lt;video v-if="value.indexOf('mp4') &gt;-1" :src="value" controls&gt;&lt;/video&gt; &lt;image v-else :src="value" mode="aspectFit" @error="imgerror($event, indexs,index)"&gt;&lt;/image&gt;	&lt;/swiper-item&gt; JS：
imgerror(e, indexs,index) { var ps = JSON.parse(JSON.stringify(this.list[index].phonts)) this.$set(this.list[index],this.list[index].phonts,[]) ps[indexs] = '/static/img/noimg.png' this.list[index].phonts = ps }, 解释：因为vue的数据绑定存在一些问题，所以在双层遍历当中会出现数据更新问题，因此我们需要给图片数组重新更换地址
注：如果图片长度不改变，vue默认不会更新，所以我们要把数组赋值为空，然后重新赋值（默认图片地址）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a857fcfa97a2bd5bc57f235f412864c3/" rel="bookmark">
			从零开始学PCR技术（四）：常见问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PCR 反应可能存在问题，比如无扩增条带、有扩增条带但是假阳性、出现非特异性条带或者条带出现拖尾现象，这是因为 PCR 反应存在多个关键环节：1、模板核酸的制备；2、引物的质量与特异性；3、酶的质量；4、PCR 循环条件。任何一个环节出现差错都会导致 PCR 失败。
PCR 常见的四种问题 问题一：假阴性 现象：无扩增条带。
原因：
1.模板
模板中含有杂蛋白质、Taq 酶抑制剂，模板上样量低或模板降解；
在提取制备模板时丢失过多，或吸入酚。
模板核酸变性不彻底。在酶和引物质量好时，不出现扩增带，极有可能是标本的消化处理，模板核酸提取过程出了毛病，因而要配制有效而稳定的消化处理液，其程序亦应固定不宜随意更改。
2.引物
引物质量、引物的浓度、两条引物的浓度是否对称，是 PCR 失败或扩增条带不理想、容易弥散的常见原因;
有些批号的引物质量有问题，两条引物一条浓度高，一条浓度低，造成低效率的不对称扩增;
对策：① 选定一个好的引物合成单位。② 引物的浓度不仅要看 OD 值，更要注重引物原液做琼脂糖凝胶电泳，一定要有引物条带出现，而且两引物带的亮度应大体一致。如一条引物亮度高，一条亮度低，在稀释引物时要平衡其浓度。③ 引物应高浓度小量分装保存，防止多次冻融或长期放冰箱冷藏部分，导致引物变质降解失效。④ 引物设计不合理，如引物长度不够，引物之间形成二聚体等。
3.酶
酶失活，需更换新酶，或新旧两种酶同时使用，以分析是否因酶的活性丧失或不够而导致假阴性。需注意的是有时忘加 Taq 酶或溴乙锭。
4.Mg2+浓度
Mg2+离子浓度对 PCR 扩增效率影响很大，浓度过高可降低 PCR 扩增的特异性，浓度过低则影响 PCR 扩增产量甚至使 PCR 扩增失败而不出扩增条带。
5.反应程序
模板变性不彻底。如变性温度低，变性时间短，极有可能出现假阴性；
退火温度不合适。退火温度过低，可致非特异性扩增而降低特异性扩增效率，退火温度过高影响引物与模板的结合而降低 PCR 扩增效率；
延伸时间不够，每种酶的能力与性质不同，需要根据每种酶的特点设定合适的延伸时间。
酶是否需要热启动等特殊程序。
6.靶序列变异
如靶序列发生突变或缺失，影响引物与模板特异性结合，或因靶序列某段缺失使引物与模板失去互补序列，其 PCR 扩增是不会成功的。
7.反应体积的改变
通常进行 PCR 扩增采用的体积为 20ul、30ul、50ul 或 100ul，应用多大体积进行 PCR 扩增，是根据科研和临床检测不同目的而设定，在做小体积如 20ul 后，再做大体积时，一定要摸索条件，否则容易失败。
问题二：假阳性 现象：出现与目的扩增条带一致的条带。
原因：
靶序列或扩增产物的交叉污染：这种污染有两种原因：一是整个基因组或大片段的交叉污染，导致假阳性。这种假阳性可用以下方法解决：① 操作时应小心轻柔，防止将靶序列吸入加样枪内或溅出离心管外。② 除酶及不能耐高温的物质外，所有试剂或 器材均应高压消毒。所用离心管及进样枪头等均应一次性使用。③ 必要时，在加标本前，反应管和试剂用紫外线照射，以破坏存在的核酸。二是空气中的小片段核酸污染，这些小片段比靶序列短，但有一定的同源性。可互相拼接，与引物互补后，可扩增出 PCR 产物，而导致假阳性的产生，可用巢式 PCR 方法来减轻或消除。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a857fcfa97a2bd5bc57f235f412864c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dcc9f29f84bee4d1d0ed142f202bc399/" rel="bookmark">
			使用cn.hutool.http请求第三方数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一：
* 第三方授权
* 得到第三方token和Expires(过期时间) 说明：请求第三方数据时，需要授权。第三方会给到appid和secret，请求携带appid和secret获取一个token和expires，又了token就又了操作第三方数据的权限。每次操作第三方数据时就需要携带token。
maven坐标
&lt;dependency&gt; &lt;groupId&gt;cn.hutool&lt;/groupId&gt; &lt;artifactId&gt;hutool-all&lt;/artifactId&gt; &lt;version&gt;4.6.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.70&lt;/version&gt; &lt;/dependency&gt; Map&lt;String, Object&gt; params = new HashMap&lt;&gt;(); params.put("appid", authProperties.getAppid()); params.put("secret", authProperties.getSecret()); log.info("AuthUtils.得到配置文件appid和secret"); log.info("appid===:{}", authProperties.getAppid()); log.info("secret===:{}", authProperties.getSecret()); log.info("auth地址===:{}", ipUtil.getOip() + "/auth/token"); String str = HttpRequest.post("183.xxx.xxx.xx:9981" + "/auth/token?appid="+authProperties.getAppid()+"&amp;secret="+authProperties.getSecret()) .timeout(500)//超时，毫秒 .execute().body(); log.info("调用第三方auth传回的json数据{}",str); JSONObject jsonObject = JSON.parseObject(str); JSONObject data = jsonObject.getJSONObject("data"); String token = data.get("token").toString(); String expires = data.get("expires").toString(); System.out.println(token); 二： 发送数据给第三方，请求头放入token，才能权限请求。 Map&lt;String, Object&gt; params = new HashMap&lt;&gt;(); params.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dcc9f29f84bee4d1d0ed142f202bc399/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/062999fb63421808dd190ed895daae33/" rel="bookmark">
			python实现【基数排序】(Radix Sort)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python实现【基数排序】(Radix Sort) 算法原理及介绍 基数排序核心思想是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。
算法过程描述 取得数组中的最大数，并取得位数；arr为原始数组，从最低位开始取每个位组成radix数组；对radix进行计数排序（利用计数排序适用于小范围数的特点）； 算法排序图解如下 python实现代码 def radixSort(arr): n = len(str(max(arr))) # 记录最大值的位数 for k in range(n):#n轮排序 # 每一轮生成10个列表 bucket_list=[[] for i in range(10)]#因为每一位数字都是0~9，故建立10个桶 for i in arr: # 按第k位放入到桶中 bucket_list[i//(10**k)%10].append(i) # 按当前桶的顺序重排列表 arr=[j for i in bucket_list for j in i] return arr 想了解其他排序相关算法可以，看作者的排序算法专栏。
如果喜欢作者，欢迎点赞、收藏及关注，谢谢！
欢迎扫描下面二维码关注公众号:阿旭算法与机器学习， 可以和作者共同学习交流。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/092dc7dd9846543fd36470b1c8338e79/" rel="bookmark">
			python实现【堆排序】(Heap Sort)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python实现【堆排序】(HeapSort) 算法原理及介绍 堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法*。堆实质是一个近似完全二叉树的结构*，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。堆排序可以说是一种利用堆的概念来排序的选择排序。
算法过程描述 将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；
将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；
由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。
算法排序图解如下 python实现代码 def heapify(arr, n, i): # 构建大顶堆 largest = i l = 2 * i + 1 # left = 2*i + 1 r = 2 * i + 2 # right = 2*i + 2 if l &lt; n and arr[i] &lt; arr[l]: largest = l if r &lt; n and arr[largest] &lt; arr[r]: largest = r if largest != i: arr[i], arr[largest] = arr[largest], arr[i] # 交换 heapify(arr, n, largest) def heapSort(arr): n = len(arr) # 构建大顶堆 for i in range(n, -1, -1): heapify(arr, n, i) for i in range(n - 1, 0, -1): # 一个个交换元素 arr[i], arr[0] = arr[0], arr[i] # 交换 heapify(arr, i, 0) return arr 想了解其他排序相关算法可以，看作者的排序算法专栏。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/092dc7dd9846543fd36470b1c8338e79/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/400/">«</a>
	<span class="pagination__item pagination__item--current">401/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/402/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>