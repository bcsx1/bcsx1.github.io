<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2500dff070bc07186ed8859b8dd9429/" rel="bookmark">
			手把手教你使用 idea 生成漂亮的 javadoc 文档
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、打开 idea，点击 Tools-&gt; Generate JavaDoc，这样会打开生成 javadoc 文档的配置页面。
2、进行配置：
标注的是重要的部分，从上往下分别是配置 javadoc 的范围，输出文件夹路径以及命令行参数。
这里的命令行参数很重要，因为只有使用 utf-8 编码才能保证生成时可以正常处理中文字符，所以一定要加上：
-encoding utf-8 -charset utf-8 还可以配置那些注解需要生成，哪些权限类（private、package、protected、public）需要生成等等精细的控制。
还有一点需要注意，即不要勾选“Include test sources”，勾选后，生成时会造成很奇怪的错误。
3、配置好后，点击生成按钮，生成好后就会自动在浏览器打开进行查看咯，是不是很棒O(∩_∩)O~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9cbbed701285ef6441f9a60d3b5e3143/" rel="bookmark">
			Map&lt;K,V&gt;接口及其子类HashMap的基本使用和其两种遍历方法(如何保证键为引用类型的唯一性)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		接口 Map&lt;K,V&gt; 类型参数： K - 此映射所维护的键的类型 V - 映射值的类型 public interface Map&lt;K,V&gt; 已知常用实现类： AbstractMap, EnumMap, HashMap, LinkedHashMap, TreeMap, 将键映射到值的对象。 一个映射不能包含重复的键； 每个键最多只能映射一个值。 通俗的说，键不可以重复，值可以重复(一个值可以被多个键映射) Map接口和Collection接口的不同 * Map是双列的,Collection是单列的 * Map的键唯一,Collection的子体系Set是唯一的 * Map集合的数据结构值针对键有效，跟值无关;Collection集合的数据结构是针对元素有效 HashMap与HashSet的比较 他们的底层都是双列&lt;K,V&gt;存储的，只不过HashSet隐藏了一列v 底层都用哈希算法 Map集合的功能概述 * a:添加功能 * V put(K key,V value):添加元素。 * 如果键是第一次存储，就直接存储元素，返回null * 如果键不是第一次存在，就用值把以前的值替换掉，返回以前的值 * b:删除功能 * void clear():移除所有的键值对元素 * V remove(Object key)：根据键删除键值对元素，并把值返回 * c:判断功能 * boolean containsKey(Object key)：判断集合是否包含指定的键 * boolean containsValue(Object value):判断集合是否包含指定的值 * boolean isEmpty()：判断集合是否为空 * d:获取功能 * Set&lt;Map.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9cbbed701285ef6441f9a60d3b5e3143/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14ca5a1c5160c73c0f032d715ef8d564/" rel="bookmark">
			jQuery完整的事件委托(on())
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
&lt;meta charset="UTF-8"&gt;
&lt;title&gt;jQuery完整的事件委托(on())&lt;/title&gt;
&lt;script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"&gt;&lt;/script&gt;
&lt;script&gt;
$(function () {
$("#box").on("click","div,p,li,span",function (event) {
if(event.target.nodeName.toLowerCase()=="div"){ //nodeName 元素节点名称
if(event.target.id=="div1"){
$(this).css({"background-color":"orange"});
}
else if(event.target.id=="div2"){
$(this).css({"background-color":"yellow"});
}
else if(event.target.id=="div3"){
$(this).css({"background-color":"blue"});
}
else if(event.target.id=="div4"){
$(this).css({"background-color":"pink"});
}
}
if(event.target.nodeName.toLowerCase()=="li"){
$(this).css({"background-color":"red"});
}
if(event.target.nodeName.toLowerCase()=="p"){
$(this).css({"background-color":"black"})
}
if(event.target.nodeName.toLowerCase()=="span"){
$(this).css({"background-color":"green"})
}
})
})
&lt;/script&gt;
&lt;style&gt;
div{ width: 200px;height: 200px;border: 1px solid black; }
p{width: 200px;height: 100px;border: 1px solid black; color: white }
span{width: 400px;height:100px;border: 1px solid black; }
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/14ca5a1c5160c73c0f032d715ef8d564/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18174754c8225aff302c979695e52f7f/" rel="bookmark">
			Hadoop全分布集群搭建（1）——设置主机名与域名解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Hadoop全分布集群搭建设置主机名与域名解析 1各个节点主机名修改2 设置各个节点的域名解析 Hadoop全分布集群搭建——设置主机名与域名解析 1.1各个节点主机名修改 为了方便起见，一般我们需要修改各节点的主机名hostName，这样有助于我们区别该节点电脑的身份。默认安装后所有节点的系统内hostName都是localhost.localdomain。我们将各节点的HostName改为如下方案：
节点名称hostNameIP地址MasterMaster192.168. 101.42Slave1Slave1192.168. 101.40Slave2Slave2192.168. 101.41Slave3Slave3192.168. 101.43 修改主机名的步骤如下：
（1）以root身份登录Master节点，修改/etc/sysconfig/network文件
将HOSTNAME=localhost.localdomain改成HOSTNAME=Master。
（2）修改/etc/hosts文件，设置将Master解析为本机ip，在文件最后增加如下内容：
192.168.101.42 Master
（3）重启系统：reboot，重启后验证hostName，结果显示为Master，即为成功
hostname
（4）验证：若能ping通，证明修改成功
ping Master
（5）同样，去另外三个Slave节点，分别做对应修改即可。步骤同上。
1.2 设置各个节点的域名解析 （1）修改hostname完成之后，修改各个节点的hosts文件保证集群之间能够解析到各节点ip。
1.在Master节点的/etc/hosts文件中，添加如下信息（如果127.0.0.1中有“Master”，先删除）：
192.168.101.42 Master
192.168.101.40 Slave1 192.168.101.41 Slave2 192.168.101.43 Slave3
完成之后，用ping Slave1、ping Slave2、ping Slave3，测试看能否ping通。
（2）每个Slave节点同Master节点，均要对/etc/hosts文件做修改，修改内容同上：
192.168.101.42 Master
192.168.101.40 Slave1 192.168.101.41 Slave2 192.168.101.43 Slave3
后续搭建过程请参考：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6680e70b364ccf9fd27c50398e7009e1/" rel="bookmark">
			linux vnc的默认端口修改
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		linux vnc的默认端口修改 2014-02-08 20:01:28 分类： LINUX
vnc的默认端口是5901，这个说法是不对的。vnc并不是只有一个端口。 以前另一个文章介绍了nvcserver的配置用户的过程，里面提到了桌面号，这个桌面号就可以端口有密切关系 先看看这个配置 VNCSERVERS="1:oracle 2:root" VNCSERVERARGS[1]="-geometry 800x600 -nolisten tcp -nohttpd" ...... 这里是摘自/etc/sysconfig/vncservers里的一段。 这里就配置了2个桌面，一个桌面号是1， 一个是2. vncserver在调用的时候，会根据你的配置来启用server端的监听端口， 从5900开始，加上你的桌面号，比如这里的哦oracle就是5901，root就是5902 所以通过这里的桌面号也是可以达到我们的目的的,根据你的目标端口来设定用户的周面好，虽然可以解决，但是总是感觉有些没有拉干净的感觉，这不是 这次的研究内容，还是找个痛快的方式吧。 这次的研究主要就是颠覆这样的默认规则，直接的深入进去，我要直接修改5900+为15900+ 在网上没有找到比较好的方法和文档，自己动手吧 从vncserver这个启动命令开始吧， [root@redflag1 ~]# which vncserver /usr/bin/vncserver [root@redflag1 ~]# file /usr/bin/vncserver /usr/bin/vncserver: a perl script text executable [root@redflag1 ~]# grep "59" /usr/bin/vncserver -n 18:# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, 118:$vncPort = 5900 + $displayNumber; 238:# n is taken if something is listening on the VNC server port (5900+n) or the 257:# (5900+n) or the X server port (6000+n).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6680e70b364ccf9fd27c50398e7009e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d574c06df82be341e059d34e35989250/" rel="bookmark">
			屏幕内容显示原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 位图图像：
位图又叫点阵图，像素图，光栅图。位图有像素组成，位图的质量与像素分布以及分辨率有关。每个像素点由RGB三种颜色组成 关于ASCII码、UTF-8和Unicode码参考http://blog.csdn.net/qingkongyeyue/article/details/71566389 矢量图：
矢量图使用直线和曲线来描述图形，这些图形的元素是一些点、线、矩形、多边形、圆和弧线等等，它们都是通过数学公式计算获得的。例如一幅花的矢量图形实际上是由线段形成外框轮廓，由外框的颜色以及外框所封闭的颜色决定花显示出的颜色。由于矢量图形可通过公式计算获得，所以矢量图形文件体积一般较小。矢量图形最大的优点是无论放大、缩小或旋转等不会失真；最大的缺点是难以表现色彩层次丰富的逼真图像效果 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22004541bdca9619d9f383fcaa20292c/" rel="bookmark">
			mvn package时设置了maven.test.skip=true依旧执行单元测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		发现自己的maven程序在执行
mvn clean package
mvn package -Dmaven.test.skip=true -Ptest 终端还是打印出单元测试在执行，解决的过程中了解到-DskipTests和-Dmaven.test.skip=true的区别是
-DskipTests，不执行测试用例，但编译测试用例类生成相应的class文件至target/test-classes下。 -Dmaven.test.skip=true，不执行测试用例，也不编译测试用例类。 但是查看target目录，下面依然有test-classes目录，后来通过
mvn clean package -Dmaven.test.skip=true 解决，此时target目录下并无test-classes目录。
参考资料：
http://www.bkjia.com/Javabc/615372.html
http://www.cnblogs.com/frankyou/p/6062179.html
转载于:https://www.cnblogs.com/wendelhuang/p/6837105.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/492793a4d4ae6ae1bf54411a2c73958e/" rel="bookmark">
			virtualbmc 使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		virtualbmc 介绍 通常情况下，我们要使用 IPMI必须使用有带外管理功能的物理机。但是在很多测试环境，我们使用的是虚拟机。virtualbmc是一个可以使用 IPMI命令来控制虚机的openstack 组件。
virtualbmc 安装 pip install virtualbmc virtualbmc 使用 查看环境中的虚拟机
$ virsh list --all Id Name State ---------------------------------------------------- 12 centos7.0-3 running给虚机添加 vmbc
vbmc add centos7.0-3 --port 6230查看 vmbc 信息
$ vbmc list +-------------+--------+---------+------+ | Domain name | Status | Address | Port | +-------------+--------+---------+------+ | centos7.0-3 | down | :: | 6233 | +-------------+--------+---------+------+启动vbmc
$ vbmc start centos7.0-3 启动之后用vmbc list名称查看，Status 会变成 running 状态。
ipmi 控制 虚机
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/492793a4d4ae6ae1bf54411a2c73958e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/506d190a379d1c7c10e83db2e31f1669/" rel="bookmark">
			echarts之基于geojson的自定义地图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		应用场景：需要在平面图或者特殊地理区域上展示数据，比如
geojson作为echarts的地图数据源，能实现简单平面图（如果是立体图就需要研究svg）上的数据交互。优点：技术低，学习起来没难度；缺点：耗时耗力，复杂的平面图有难度。
实现步骤： 1、在 http://geojson.io/ 上画自己需要的平面图并导出为geojson
勾画区域时添加name属性
定义一个js文件 ，变量内容为上面制作的topojson文件
完整简单demo代码如下：
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;title&gt;巡检异常读数地图&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!--&lt;div id="main" style="height: 714px;weight:662px"&gt;&lt;/div&gt;--&gt; &lt;div id="main" style="height:714px"&gt;&lt;/div&gt; &lt;script type="text/JavaScript" src="echarts.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="test2map.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; var testData = [ { name:'区域1',value:'480' }, { name:'区域2',value:'900' }, { name:'区域3',value:'1939' } ]; //获取最大最小值 以便做数据筛选器	var maxData = 0; var minData = 0; for(var i = 0;i&lt;testData.length;i++){ var value = parseInt(testData[i].value); if(value &gt; maxData){ maxData = value; } if(value&lt;minData){ minData = value; } } var option = { tooltip : { trigger : 'item', formatter : '{b}&lt;br/&gt;{c} (人次)' }, toolbox : { show : true, orient : 'vertical', x : 'right', y : 'center', feature : { mark : { show : true }, saveAsImage : { show : true } } }, dataRange : { min : minData*0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/506d190a379d1c7c10e83db2e31f1669/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b5fb20ac2ccb2f567a843b56ac08921/" rel="bookmark">
			微信公众号基本配置时token获取失败原因及解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 微信公众号基本配置时token获取失败原因及解决方法 目前SAE（该服务器拿来专门做微信开发）中获得的所有请求应为来自微信服务器发出的请求，比如有人关注了你的公众号并向你发送了一条信息，微信服务器会把信息推送到你自己的服务器即SAE上。既然我们的服务器是放在网上，那任何一个服务器都可以向你发送请求，包括本地的服务器。这就需要我们知道该请求的真实来源，需要验证该请求的合法性，所以需要在第一次使用的时候验证，以后就不需要了。 如何验证的话在开发文档中有（下图）： 微信会自动发送信息到SAE服务器上，信息中附带如图4个参数，如果只需要验证成功而已，直接把最后的echostr输出即可。它是以GET方式发送的请求，只需写如下代码把echostr返回给微信服务器即可验证成功。 当然，这种方式并不安全，仅用来测试即可。安全的开发文档中有~~ 下图为以前的样式： 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ef0eb801ee3156179f6124592a92c05/" rel="bookmark">
			python解决SNIMissingWarning和InsecurePlatformWarning警告
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在想要获取https站点的资源时，会报出SNIMissingWarning和InsecurePlatformWarning警告
SNIMissingWarning: An HTTPS request has been made, but the SNI (Subject Name Indication) extension to TLS is not available on this platform. This may cause the server to present an incorrect TLS certificate, which can cause validation failures. For more information, see https://urllib3.readthedocs.org/en/latest/security.html#snimissingwarning.
SNIMissingWarning
A true SSLContext object is not available. This prevents urllib3 from configuring SSL appropriately and may cause certain SSL connections to fail. For more information, see https://urllib3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ef0eb801ee3156179f6124592a92c05/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1cf15b6299d9d3fc30dad96dc565ae5/" rel="bookmark">
			链表、栈、队列（链式存储结构的添加，删除，查找，翻转 操作）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		定义： 1.栈是一种先进后出的结构 2.队列是先进先出，如果是用数组实现的话要判断队列是否满，链表的话不存在满的情况 指针用的不多，如果有什么问题或者优化希望可以指点一下。 剩下的都写下代码注释里啦~ 注释比较详细，留着下次写的时候可以复习QAQ /* 下面的栈、队列、链表都是用10个随机生成的数进行的操作 以前写都是用数组写的或者懒一点直接stl，这次用指针写了一次 */ #include&lt;stdio.h&gt; #include&lt;string.h&gt; #include&lt;time.h&gt; #include&lt;stdlib.h&gt; #include&lt;math.h&gt; struct list //封装起来的链表 { struct tree { int node; //权值 tree *next;	//储存下一个元素的地址 }; tree *head; //头指针 void init() //初始化链表 { head=new tree; head=NULL; } void creat() //创建链表 { tree *p=head; for(int i=1;i&lt;=10;i++) { int t=100+rand()%900; //随机生成10个数用于实验 tree *q; //用于记录中间操作 q=new tree; //分配空间 q-&gt;node=t;	//赋值 q-&gt;next=NULL; //避免野指针 if(i==1) //如果头指针没有元素的话第一个给头指针 head=q; else p-&gt;next=q; //这里的p记录的是上一个元素的位置 p=q; //p指针向后移动 } } void show() //输出链表内的元素 { tree *p=head; //因为只是输出所以头指针不移动，用p代替移动 int f=0;	//这个只是用于判断格式，后面的队列那些就没有写这个了 while(p) //判断链表还有没有元素 { if(f) printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f1cf15b6299d9d3fc30dad96dc565ae5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f931a3b62f16d9e440200a59ba5ce685/" rel="bookmark">
			CNN文本分类 论文收集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Sequential Short-Text Classification with Recurrent and Convolutional Neural Networks
Recurrent Convolutional Neural Networks for Text Classification
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d30ba2130dfd6162384b35a8f9d937c/" rel="bookmark">
			如何在pycharm中配置Spark
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因为作业要用到这个SPARK和python, 就着手开始配置，但是搜了一圈还是发现了不少雷。就把我自己的解决办法发上来：
打开pycharm,导入已有的或者新建工程。
2.创建新的run configurition。
如右上角所示，选择edit configurition。
设置环境，创建PYTHONPATH和SPARK_HOME
配置路径如图所示，都可以在Spark安装路径下找到：
4.选择 File-&gt;setting-&gt;你的project-&gt;project structure
右上角Add content root添加：py4j-some-version.zip和pyspark.zip的路径（这两个文件都在Spark中的python文件夹下，自己找一下）
5.保存，ok
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f370547931cf0be0d60983256668e59/" rel="bookmark">
			HTML5实现音频和视频嵌入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介
HTML5未出来之前，在线的音频和视频都是借助Flash或者第三方工具实现的，现在HTML5也支持了这方面的功能。在一个支持HTML5的浏览器中，不需要安装任何插件就能播放音频和视频。原生的支持音频和视频，为HTML5注入了巨大的发展潜力。
html实现音频嵌入(传统方式)：这种方式虽然可以实现，但是要浏览器支持Flash而且并不能实现控制，所以要实现起来很麻烦。
&lt;object height="200" width="200" data="2_1.swf" &gt;&lt;/object&gt; &lt;embed src="2_1.mp4" type=""&gt; 那么也就是说HTML5存在一个很大的问题就是兼容性。 音频
HTML5支持的音频格式：
视频
视频格式：
由上可知，HTML5貌似支持的格式有点少哈，所以当你发现用HTML5放置音频和视频不显示时，应该就是格式不支持的问题。注： MP4有3种编码，mpg4(xdiv),,mpg4(xvid)，avc(h264)， 只有h264才是公认的MP4标准编码(在这也是被坑了，其他格式的只有声音没有图像。)遇到这种问题，就用视频格式转换器，转换一下格式就OK啦。
音频实现起来很简单：这里工具条使用了浏览器默认的工具条。
&lt;audio src="htmls/1.mp3" controls="controls" loop="loop" preload="auto" &gt; 你的浏览器不支持video元素 &lt;/audio&gt; 视频虽然也可以使用浏览器默认的，但无法实现私人订制，所以从学技术的角度讲，还是要学习一下自己做工具实现功能（audio也可参照此方法）。
audioVideo.html
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;网页放置视频&lt;/title&gt; &lt;style type="text/css"&gt; &lt;/style&gt; &lt;script type="text/javascript" src="js/ControlBar.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;audio src="htmls/1.mp3" controls="controls" loop="loop" preload="auto" &gt; 你的浏览器不支持video元素 &lt;/audio&gt; &lt;video id="myPlayer" width="600" height="400" src="htmls/2_1.mp4" controls="controls" loop="loop" poster="3.jpg"&gt; 你的浏览器不支持audio元素 &lt;!-- MP4有3种编码，mpg4(xdiv),,mpg4(xvid)，avc(h264)， 只有h264才是公认的MP4标准编码 --&gt; &lt;/video&gt; &lt;div id="progress"&gt;&lt;/div&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f370547931cf0be0d60983256668e59/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/acece41cae7c3560cf7e0047a08bd6cb/" rel="bookmark">
			C&#43;&#43;中std::sort/std::stable_sort/std::partial_sort的区别及使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		某些算法会重排容器中元素的顺序，如std::sort。调用sort会重排输入序列中的元素，使之有序，它默认是利用元素类型的&lt;运算符来实现排序的。也可以重载sort的默认排序，即通过sort的第三个参数，此参数是一个谓词(predicate)。
谓词是一个可调用的表达式，其返回结果是一个能用作条件的值，即返回一个bool类型的值。标准库算法所使用的谓词分为两类：一元谓词(unary predicate，只接受单一参数)和二元谓词(binary predicate,有两个参数)。接受谓词参数的算法对输入序列中的元素调用谓词。因此，元素类型必须能转换为谓词的参数类型。
接受一个二元谓词参数的sort版本用这个谓词代替&lt;来比较元素。
std::sort：对给定区间所有元素进行排序。
std::stable_sort：对给定区间所有元素进行稳定排序，稳定排序算法能够维持相等元素的原有顺序。
std::partial_sort：对给定区间所有元素进行部分排序。
当容器中的元素是一些标准类型(如int、string)时，可以直接使用函数模板。但其元素是自定义类型或者需要按照其它方式排序时，需要自己来实现，有两种方法：一种是自己写比较函数，另一种是重载类型操作符”&lt;”。std::sort/std::stable_sort/std::partial_sort中最后一个参数可以是函数指针类型或函数对象类型。
std::sort采用类似快速排序算法，复杂度为N*log2(N)；std::stable_sort采用类似归并排序，复杂度为N*log2(N)；std::partial_sort采用类似堆排序，复杂度为N*log(M)。但是在cplusplus中并没有说明每种sort采用的是具体哪种排序算法。
std::sort：Sort elements in range, Sorts the elements in the range [first,last) into ascending order. The elements are compared using operator&lt; for the first version, and comp for the second. Equivalent elements are not guaranteed to keep their original relative order (see stable_sort).
std::stable_sort: Sort elements preserving order of equivalents. Sorts the elements in the range[first,last) into ascending order, like sort, but stable_sort preserves the relative order of the elements with equivalent values.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/acece41cae7c3560cf7e0047a08bd6cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97b98f6d08612d261d5023e3fa4aa7bf/" rel="bookmark">
			《Deep Neural Networks for YouTube Recommendations》学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Google出品，学习一下！ 文章脉络清晰，主要包括六个部分：YouTube使用DNN的背景、整体推荐系统框架、候选集生成（candidate generation）、排序（ranking）、总结、感谢，其中候选集生成和排序是推荐系统框架的重要组成部分。
本文主要学习下整体推荐系统框架、候选集生成（candidate generation）、排序（ranking）这三个部分 1.整体推荐系统框架 ![](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNTA1MTcwMDAyNjcw?x-oss-process=image/format,png) 不得不说一下，好的paper总是那样，看下图片，大概意思就可以明白很多了
（1）首先关注图片中下几个单词millions、hundreds、dozens：表示数据量的级别，全部的video corpus大概是millions级别，经过candidate generation之后大概是hundreds级别，经过ranking之后大概是dozens级别
（2）candidate generation的输入包括millions video corpus、user history and context ,旨在快速高效地筛选部分视频集合
（3）ranking的输入包括hundreds video corpus、user history and context、other candidate sources、video features，旨在得到高精度的TOP N
2.候选集生成 （1）一个思考方式的转变
我们把推荐问题建模成一个“超大规模多分类”问题。即在时刻t，为用户U（上下文信息C）在视频库V中精准的预测出视频i的类别（每个具体的视频视为一个类别，i即为一个类别），用数学公式表达如下：
![](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNTA1MTcxOTQxODA4?x-oss-process=image/format,png) 很显然上式为一个softmax多分类器的形式。向量是user, context&gt;信息的高纬“embedding”，而向量则是视频 j 的embedding向量。所以DNN的目标就是在用户信息和上下文信息为输入条件下学习用户的embedding向量u。
（2）Deep candidate generation model architecture
![](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNTA1MTcyODA1MzY3?x-oss-process=image/format,png) 用户观看历史数据、搜索数据，做一个embedding,加上age、gender特征作为DNN的输入，接下来是几层的全连接层（激活函数是ReLU），训练阶段使用cross-entropy作为优化损失函数，线上阶段根据user vector和video vector通过an approximate nearest neighbor lookup得到TOP N作为输出，也是ranking阶段的输入
（3）标签和输入文本的选择
![](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNTA1MTczNDI2Mzc2?x-oss-process=image/format,png) 上图中，实心黑点表示输入，空心点表示标签。论文中表示，在进行A/B Test的时候，发现(b)这种选择标签和输入比（a）好
个人理解，这也是符号常识的，毕竟人的兴趣是随着时间推移而发生变化的。
3.排序 ![](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNTA1MTczODE3ODky?x-oss-process=image/format,png) 对类别特征（包括单值和多值的）进行Embedding，对连续特征进行Normalizing，训练阶段最后一层是加权的逻辑斯蒂回归，预测阶段直接根据学习到的W得到输出结果。
上面两个部分均发现DNN的深度(depth)对结果影响比较大 4.不定长变为定长Embedding 这块纯属个人理解，如果有错，还望指出
每一个人观看video的id list长度是不一样的，这种情形跟一条文本长度不一样需要做情感分析这种任务类似
由于这篇文章没有开源，有些细节还是需要自己摸索，下面是keras example中lstm_imdb的相关代码，仅供参考学习
from __future__ import print_function import numpy as np np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/97b98f6d08612d261d5023e3fa4aa7bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc0a15c29bd4fe349075863473394a0b/" rel="bookmark">
			大头小头 字节序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 http://blog.csdn.net/zjf82031913/article/details/7245183
字节序的问题涉及硬件架构，目前主要是Motorola的PowerPC系列CPU和Intel的x86系列CPU。PowerPC系列采用big endian方式存储数据，而x86系列则采用little endian方式存储数据。那么究竟什么是big endian，什么又是little endian呢？
为方便理解，摘了INTER手册中的一张图。呵呵。
字节顺序是指占内存多于一个字节类型的数据在内存中的存放顺序，通常有小端、大端两种字节顺序。小端字节序指低字节数据存放在内存低地址处，高字节数据存放在内存高地址处；大端字节序是高字节数据存放在低地址处，低字节数据存放在高地址处。
基于IAX86平台的PC机是小端字节序的，而有的嵌入式平台则是大端字节序的。因而对WORD/DWORD/QWORD等多于1字节类型的数据，在这些嵌入式平台上应该变换其存储顺序。通常我们认为，在空中传输的字节的顺序即网络字节序为标准顺序，考虑到与协议的一致以及与同类其它平台产品的互通，在程序中发数据包时，将主机字节序转换为网络字节序，收数据包处将网络字节序转换为主机字节序。
用文字说明可能比较抽象，下面用图像加以说明。比如数字0x12345678在两种不同字节序CPU中的存储顺序如下所示：
对于0x12345678，
Little endian：高地址&lt;-------&gt;低：存储数据0x12 0x34 0x56 0x78
Big endian： 高地址&lt;-------&gt;低：存储数据0x78 0x56 0x34 0x12
为什么要注意字节序的问题呢？当然，如果你写的程序只在单机环境下面运行，并且不和别人的程序打交道，那么你完全可以忽略字节序的存在。但是，如果你的程序要跟别人的程序产生交互呢？C/C++语言编写的程序里数据存储顺序是跟编译平台所在的CPU相关的，而Java编写的程序则唯一采用big endian方式来存储数据。试想，如果你用C/C++语言在x86平台下编写的程序跟别人的JAVA程序互通时会产生什么结果？就拿上面的0x12345678来说，你的程序传递给别人的一个数据，将指向0x12345678的指针传给了JAVA程序，由于JAVA采取big endian方式存储数据，很自然的它会将你的数据翻译为0x78563412。因此，在你的C程序传给JAVA程序之前有必要进行字节序的转换工作。 所有网络协议也都是采用big endian的方式来传输数据的。所以有时我们也会把big endian方式称之为网络字节序。当两台采用不同字节序的主机通信时，在发送数据之前都必须经过字节序的转换成为网络字节序后再进行传输。 判断小端还是大端规则的方法：
int x = 1; if(*(char *)&amp;x == 1) //取x指针强制转换为char*类型再取值，此时取到的值是int最低字节值 printf("little-endian/n"); else printf("big-endian/n"); 另外补充：
1．BIG-ENDIAN、LITTLE-ENDIAN是跟CPU有关的，每一种CPU不是BIG-ENDIAN就是LITTLE-ENDIAN。IA架构的CPU中是Little-Endian，而PowerPC 、SPARC和Motorola处理器。这其实就是所谓的主机字节序。而网络字节序是指数据在网络上传输时是大头还是小头的，在Internet的网络字节序是BIG-ENDIAN。所谓的JAVA字节序指的是在JAVA虚拟机中多字节类型数据的存放顺序，JAVA字节序也是BIG-ENDIAN。
2．所以在用C/C++写通信程序时，在发送数据前务必用htonl和htons去把整型和短整型的数据进行从主机字节序到网络字节序的转换，而接收数据后对于整型和短整型数据则必须调用ntohl和ntohs实现从网络字节序到主机字节序的转换。如果通信的一方是JAVA程序、一方是C/C++程序时，则需要在C/C++一侧使用以上几个方法进行字节序的转换，而JAVA一侧，则不需要做任何处理，因为JAVA字节序与网络字节序都是BIG-ENDIAN，只要C/C++一侧能正确进行转换即可（发送前从主机序到网络序，接收时反变换）。如果通信的双方都是JAVA，则根本不用考虑字节序的问题了。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f1d00de74dbf2467846d60e30b4682d/" rel="bookmark">
			Android 之Https自签名证书
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Andorid接口请求中，遇到以下报错：java.security.cert.CertPathValidatorException: Trust anchor for certification path not found. 这个问题一般是使用了自签名证书导致的。
总结：对于自制的CA证书，对于客户端/服务端，都可以重写X509TrustManager类里面的方法实现忽略校验操作 对于CA机构颁发的证书，Okhttp默认支持的，可以直接访问。
但是对于自定义的证书就不可以了（如：https ://kyfw.12306.cn/otn/）， 需要加入Trust
下面分两部分来写，一是信任所有证书，二是信任指定证书，访问自签名的网站。
HtttpsURLConnection框架信任所有https证书 使用方法：
//在进行联网请求前调用该类allowAllSSL()方法
FakeX509TrustManager.allowAllSSL();
实现类：
import java.security.KeyManagementException; import java.security.NoSuchAlgorithmException; import java.security.SecureRandom; import java.security.cert.X509Certificate; import javax.net.ssl.HostnameVerifier; import javax.net.ssl.HttpsURLConnection; import javax.net.ssl.SSLContext; import javax.net.ssl.SSLSession; import javax.net.ssl.TrustManager; import javax.net.ssl.X509TrustManager; public class FakeX509TrustManager implements X509TrustManager { private static TrustManager[] trustManagers; private static final X509Certificate[] _AcceptedIssuers = new X509Certificate[] {}; @Override public void checkClientTrusted(java.security.cert.X509Certificate[] x509Certificates, String s) throws java.security.cert.CertificateException { } @Override public void checkServerTrusted(java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f1d00de74dbf2467846d60e30b4682d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a87f465d2e03e808e4ff4182f913a59/" rel="bookmark">
			Codeforces 803C Maximal GCD【思维】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C. Maximal GCD time limit per test 1 second memory limit per test 256 megabytes input standard input output standard output You are given positive integer number n. You should create such strictly increasing sequence of k positive numbers a1, a2, ..., ak, that their sum is equal to n and greatest common divisor is maximal.
Greatest common divisor of sequence is maximum of such numbers that every element of sequence is divisible by them.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a87f465d2e03e808e4ff4182f913a59/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c10a9a73b128cb007a61d99968e60bf/" rel="bookmark">
			《Wide and Deep Learning for Recommender Systems》学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		顾名思义，Google提出的这篇文章将Wide Model和Deep Model结合起来进行，思路非常值得学习。
![](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNTAyMTM1NjExMzQ5?x-oss-process=image/format,png) 1.Wide Model 首先说一下Wide Model,就是上图中左边的那一部分，是一个简单的逻辑回归模型。这一部分比较简单，不多有一个新的思路就是交叉特征：
![](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNTAyMTQwMDE3NjE3?x-oss-process=image/format,png) 论文中一个比较形象的例子
For binary features, a cross-product transformation (e.g.,AND(gender=female, language=en)") is 1 if and only if the constituent features (\gender=female" and \language=en") are all 1, and 0 otherwise.
对应的开源代码如下：
wide_columns = [ gender, native_country, education, occupation, workclass, relationship, age_buckets, tf.contrib.layers.crossed_column([education, occupation], hash_bucket_size=int(1e4)), tf.contrib.layers.crossed_column([native_country, occupation], hash_bucket_size=int(1e4)), tf.contrib.layers.crossed_column([age_buckets, education, occupation], hash_bucket_size=int(1e6))] 2.Deep Model Deep Model是最上图中右边的部分，首先是一个embedding层，然后是两层的神经网络，最后是一个softmax。整体上看上去清晰明了，开源的代码中实现的也比较简单，有时间的话还是要研究研究源码。
公式表示如下，其中l是层数，W是系数，b是偏置，f是激活函数
![](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNTAyMTQxNTM4NjEw?x-oss-process=image/format,png) 对应的开源代码如下：
deep_columns = [ tf.contrib.layers.embedding_column(workclass, dimension=8), tf.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c10a9a73b128cb007a61d99968e60bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cda378d3be778107b98d6a3dd12aaf8a/" rel="bookmark">
			Codeforces803C Maximal GCD
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		链接 http://codeforces.com/problemset/problem/803/C
题目大意 给你两个数 n k ，让你求一个恰好含有 k 个数的严格上升数列，使得∑ai=n。且这个数列的 gcd 最大。无解输出 −1 题解 考虑枚举 gcd=d ，对于一个很大的 d 可能会无解，而且这时比d更大的任何数作为 gcd 也肯定无解。 考虑一个 gcd=d 有解，怎样构造一个数列呢，可以直接贪心 1 2 3 4 5 ... ，然后到第 k 个数的时候，用n减去前面的和作为第 k 个数。 枚举gcd=d，有解肯定就是 d∑ki=1i≤n 然后二分就行了 注意爆 long long ！
代码 //数学小题 #include &lt;cstdio&gt; #include &lt;algorithm&gt; #define ll long long using namespace std; ll N, lim, K, A, list[1000000]; void gao(ll d) { ll i, s=0; for(i=1;i&lt;K;i++)printf("%I64d ",i*d),s+=i*d; printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cda378d3be778107b98d6a3dd12aaf8a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3e23603628901f6301e146e3a55d75d/" rel="bookmark">
			C&#43;&#43;11中的std::call_once
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		某些场景下，我们需要代码只被执行一次，比如单例类的初始化，考虑到多线程安全，需要进行加锁控制。C++11中提供的call_once可以很好的满足这种需求，使用又非常简单。
头文件#include&lt;mutex&gt;
template &lt;class Fn, class... Args&gt;
void call_once (once_flag&amp; flag, Fn&amp;&amp; fn, Args&amp;&amp;...args);
第一个参数是std::once_flag的对象(once_flag是不允许修改的，其拷贝构造函数和operator=函数都声明为delete)，第二个参数可调用实体，即要求只执行一次的代码，后面可变参数是其参数列表。
call_once保证函数fn只被执行一次，如果有多个线程同时执行函数fn调用，则只有一个活动线程(active call)会执行函数，其他的线程在这个线程执行返回之前会处于”passive execution”(被动执行状态)——不会直接返回，直到活动线程对fn调用结束才返回。对于所有调用函数fn的并发线程，数据可见性都是同步的(一致的)。
如果活动线程在执行fn时抛出异常，则会从处于”passive execution”状态的线程中挑一个线程成为活动线程继续执行fn，依此类推。一旦活动线程返回，所有”passive execution”状态的线程也返回,不会成为活动线程。(实际上once_flag相当于一个锁，使用它的线程都会在上面等待，只有一个线程允许执行。如果该线程抛出异常，那么从等待中的线程中选择一个，重复上面的流程)。
static std::once_flag oc; // 用于call_once的局部静态变量
Singleton* Singleton::m_instance;
Singleton* Singleton::getInstance() {
std::call_once(oc, [&amp;] () { m_instance = newSingleton(); });
return m_instance;
}
还有一个要注意的地方是 once_flag的生命周期，它必须要比使用它的线程的生命周期要长。所以通常定义成全局变量比较好。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/521f84209de0f7e4b9fc339bb60550d0/" rel="bookmark">
			CodeForces 731 B.Coupons and Discounts（水~）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Description n天，第i天需要ai个披萨，有两种买法，第一种是一次买俩，第二种是连续两天一天买一个总共两个，当天买的披萨必须当天吃，买多了就浪费了，问是否会浪费 Input 第一行一整数n表示天数，之后n个整数a[i]表示每天所需的披萨数量(1&lt;=n&lt;=2e5,0&lt;=a[i]&lt;=1e4) Output 如果存在不浪费的方案则输出YES，否则输出NO Sample Input 4 1 2 1 2 Sample Output YES Solution 前i-1天都解决了的情况下，如果a[i]为奇且a[i+1]为0，那么就一定会浪费，输出NO，否则a[i+1]–，最后判断a[n]为奇为偶，为奇则输出NO，为偶则输出YES Code
#include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;cmath&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;map&gt; #include&lt;set&gt; #include&lt;ctime&gt; using namespace std; typedef long long ll; #define INF 0x3f3f3f3f #define maxn 222222 int n,a[maxn]; int main() { while(~scanf("%d",&amp;n)) { for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); int gg=0; for(int i=1;i&lt;n;i++) if(a[i]&amp;1) { if(!a[i+1]) { gg=1; break; } else a[i+1]--; } if(a[n]&amp;1)gg=1; printf("%s\n",gg?"NO":"YES"); } return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c6045c88fc90b9b943db2ad5e57496f/" rel="bookmark">
			C#窗体向另一个窗体实时传值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、功能展示 有时需要将子界面的内容传递到父界面，方法有好几种。经常用的是通过委托实现。具体的效果如下：
【说明】点击父界面上“打开子界面”button，则会弹出子界面。父界面与子界面如上图所示。
【说明】在子界面的textBox框内输入待返回至父界面的内容，点击“将内容返回”button，则父界面的textBox将会展示返回的内容。具体如上图所示
2、代码分析 里面应用了委托（delegate）和事件（event）。委托就是前端开发中最常用的“回调方法”（callback），event是一种注册机制，将动作与委托关联。
为了实现以上功能，首先先编写子窗体的定义。代码如下：
public partial class Form2 : Form { //第二步：声明一个委托类型的事件 public event setTextValue setFormTextValue; public Form2() { InitializeComponent(); } private void button1_Click(object sender, EventArgs e) { //第三步：准备相关数据。 setFormTextValue(this.textBox1.Text); } } // 第一步：声明一个委托。（根据自己的需求） public delegate void setTextValue(string textValue); 第一步：先在子窗体中定义一个委托。根据实际需求定义委托 第二步：在子窗体中声明一个event，将委托与动作关联
第三步：在具体的事件中实现event
以上三步参见Form2的代码
父窗体的代码如下：
public partial class Form1 : Form { public Form1() { InitializeComponent(); } private void button1_Click(object sender, EventArgs e) { Form2 form2 = new Form2(); //第四步：初始化事件 form2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c6045c88fc90b9b943db2ad5e57496f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7924c9dd67a873d524b6a859dba02b2e/" rel="bookmark">
			C&#43;&#43;实现一行一行读取文本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 #include&lt;iostream&gt; #include&lt;fstream&gt; #include&lt;string&gt; int main(int argv,char *arg[]) { fstream f("dictionary.txt");//创建一个fstream文件流对象 vector&lt;string&gt; words; //创建一个vector&lt;string&gt;对象 string line; //保存读入的每一行 while(getline(f,line))//会自动把\n换行符去掉 { words.push_back(line); } //dictionary.txt在csdn里面可以下载，里面有4万多个单词，相当于一个字典 cout &lt;&lt; "共有单词数目:" &lt;&lt; words.size() &lt;&lt; endl; return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9347879f60243379ba529920ced40416/" rel="bookmark">
			c# 设置禁止改变窗体大小
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C#的窗口默认是可以进行最大化、最小化或调整大小等操作，但有时候我们不想让他的大小发生变化（如图1），下面就介绍一下如何禁止修改窗口大小的方式。
（图1）
点击窗口，选择【属性】界面。在这里可以对窗口的很多设置进行调整。找到【FormBorderStyle】选项，在选项列表中选择【FixedDialog】（如图2），这样就可以固定窗口大小，禁止对窗口的自由调整了。
（图2）
接下来隐藏窗口的最大化和最小化按钮，选项中我们找到【MaximizeBox】和【MinimizeBox】，这两个选项默认的都是【true】，这里都修改为【false】（如图3）。
（图3）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56d1a5916f8a76f3c965a41bf9f96653/" rel="bookmark">
			wifi信号扫描探测软件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		windows系统
netsport
https://www.netspotapp.com/
xirrus wi-fi inspector
https://www.xirrus.com/free-tools/
inSSIDer4
http://www.metageek.com/support/downloads/
android手机
http://www.wifianalyzer.info/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2413861230a7ca31fbec9ea8907603e/" rel="bookmark">
			基于FFMPEG的RTP推流H264和AAC文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在本文中主要讲如何用FFMPEG编写RTP的推流程序和打视音频时间戳上的问题 PS：文中代码基于LINUX
一. 文件的打开和输出流的打开 用avformat_open_input分别打开视音频文件，用avformat_alloc_output_context2打开输出的RTP流，注意，这里用的选项是rtp_mpegts，代表的是传输的视音频数据会打包成TS流的形式进行发送。rtp一个端口只能传输一路数据，所以我这里开了两个rtp端口，分别传输视音频数据。
avformat_open_input(&amp;ifmt_ctx_v, in_filename_v, 0, 0)； avformat_open_input(&amp;ifmt_ctx_a, in_filename_a, 0, 0)； avformat_alloc_output_context2(ofmt_ctx, NULL, "rtp_mpegts", NULL); avformat_alloc_output_context2(ofmt_ctx+1, NULL, "rtp_mpegts", NULL); 二. 读取视音频数据并打上时间戳 av_compare_ts两个不同时基的时间戳，谁的比较大。 通过av_compare_ts决定要读取音频数据还是视频数据，当音频时间戳比较大的时候就读取视频数据，当视频时间戳比较大的时候就读取音频时间戳。
1. 视频时间戳 AVRational time_base = in_stream-&gt;time_base;//{ 1, 1000 }; AVRational r_framerate1 = in_stream-&gt;r_frame_rate; AVRational time_base_q = { 1, AV_TIME_BASE }; //Duration between 2 frames (us) int64_t calc_duration = (double)(AV_TIME_BASE) / av_q2d(r_framerate1); //内部时间戳 pkt.pts = av_rescale_q(vframe_index*calc_duration, time_base_q, time_base); pkt.dts = pkt.pts; pkt.duration = av_rescale_q(calc_duration, time_base_q, time_base); pkt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a2413861230a7ca31fbec9ea8907603e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cebd021e5ca2fc9abf5392529453f6fb/" rel="bookmark">
			FindBoost.cmake
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		# Distributed under the OSI-approved BSD 3-Clause License. See accompanying # file Copyright.txt or https://cmake.org/licensing for details. #.rst: # FindBoost # --------- # # Find Boost include dirs and libraries # # Use this module by invoking find_package with the form:: # # find_package(Boost # [version] [EXACT] # Minimum or EXACT version e.g. 1.36.0 # [REQUIRED] # Fail with error if Boost is not found # [COMPONENTS &lt;libs&gt;...] # Boost libraries by their canonical name # ) # e.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cebd021e5ca2fc9abf5392529453f6fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ee7bb62e6b9f33dfc9e0d84f296ae99/" rel="bookmark">
			理解ip地址和端口号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IP地址是一个规定，现在使用的是IPv4，既由4个0-255之间的数字组成，在计算机内部存储时只需要4个字节即可。在计算机中，IP地址是分配给网卡的，每个网卡有一个唯一的IP地址，如果一个计算机有多个网卡，则该台计算机则拥有多个不同的IP地址，在同一个网络内部，IP地址不能相同。IP地址的概念类似于电话号码、身份证这样的概念。
由于IP地址不方便记忆，所以有专门创造了域名(Domain Name)的概念，其实就是给IP取一个字符的名字，例如163.com、sina.com等。IP和域名之间存在一定的对应关系。如果把IP地址类比成身份证号的话，那么域名就是你的姓名。一台拥有IP地址的主机可以提供许多服务，比如Web服务、FTP服务、SMTP服务等，这些服务完全可以通过1个IP地址来实现。那么，主机是怎样区分不同的网络服务呢？显然不能只靠IP地址，因为IP 地址与网络服务的关系是一对多的关系。实际上是通过“IP地址+端口号”来区分不同的服务的。 其实在网络中只能使用IP地址进行数据传输，所以在传输以前，需要把域名转换为IP，这个由称作DNS的服务器专门来完成。 所以在网络编程中，可以使用IP或域名来标识网络上的一台设备。
为了在一台设备上可以运行多个程序，人为的设计了端口(Port)的概念，类似的例子是公司内部的分机号码。规定一个设备有216个，也就是65536个端口，每个端口对应一个唯一的程序。每个网络程序，无论是客户端还是服务器端，都对应一个或多个特定的端口号。由于0-1024之间多被操作系统占用，所以实际编程时一般采用1024以后的端口号。 下面是一些常见的服务对应的端口：
ftp：23，telnet：23，smtp：25，dns：53，http：80，https：443
使用端口号，可以找到一台设备上唯一的一个程序。 所以如果需要和某台计算机建立连接的话，只需要知道IP地址或域名即可，但是如果想和该台计算机上的某个程序交换数据的话，还必须知道该程序使用的端口号。
数据传输方式 在网络上，不管是有线传输还是无线传输，数据传输的方式有两种：
TCP(Transfer Control Protocol) 传输控制协议方式，该传输方式是一种稳定可靠的传送方式，类似于现实中的打电话。只需要建立一次连接，就可以多次传输数据。就像电话只需要拨一次号，就可以实现一直通话一样，如果你说的话不清楚，对方会要求你重复，保证传输的数据可靠。 使用该种方式的优点是稳定可靠，缺点是建立连接和维持连接的代价高，传输速度不快。
UDP(User Datagram Protocol) 用户数据报协议方式，该传输方式不建立稳定的连接，类似于发短信息。每次发送数据都直接发送。发送多条短信，就需要多次输入对方的号码。该传输方式不可靠，数据有可能收不到，系统只保证尽力发送。 使用该种方式的优点是开销小，传输速度快，缺点是数据有可能会丢失。 在实际的网络编程中，大家可以根据需要选择任何一种传输方式，或组合使用这两种方式实现数据的传递。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc2ab5b45cc935cf8748ce0034410e12/" rel="bookmark">
			c# DevExpress.XtraTreeList 树形节点的上下移动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 //向上 private void btnMoveUp_Click(object sender, EventArgs e) { this.treeFile.Columns["LastWriteTime"].SortOrder = SortOrder.None; TreeListNode FocuesNode = this.treeFile.FocusedNode; treeFile.BeginUpdate(); int PrevNodeIndex = this.treeFile.GetNodeIndex(FocuesNode.PrevNode); treeFile.SetNodeIndex(FocuesNode, PrevNodeIndex); treeFile.EndUpdate(); } //向下 private void btnMoveDown_Click(object sender, EventArgs e) { this.treeFile.Columns["LastWriteTime"].SortOrder = SortOrder.None; TreeListNode FocuesNode = this.treeFile.FocusedNode; treeFile.BeginUpdate(); int PrevNodeIndex = this.treeFile.GetNodeIndex(FocuesNode.NextNode); treeFile.SetNodeIndex(FocuesNode, PrevNodeIndex); treeFile.EndUpdate(); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a23d35fd9e6597817a4b80b68cda544c/" rel="bookmark">
			几个前端时间插件总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		几个前端时间插件总结 几个前端时间插件总结 总结一下几款时间插件，分别是
- [ ] jeDate 手册http://www.jemui.com/jedate/
- [ ] bootstrap-datetimepicker 下载地址
- [ ] My97DatePicker 下载地址
- [ ] jQuery UI 插件Datepicker 下载地址
手机端的：http://blog.csdn.net/libin_1/article/details/50706030#comments
并没有哪款完全超越另外一款，主要还是看是否合适吧。
首先说一下现在项目就在用的 jeDate吧。
jeDate eDate除了包含日期范围限制、开始日期设定、自定义日期格式、时间戳转换、当天的前后若干天返回、时分秒选择、智能响应、自动纠错、节日识别，操作等常规功能外，还拥有更多趋近完美的解决方案。
目前只适合PC端。
因为是最近新出的，功能比较完善，支持风格切换，显示节假日，还有很多强大的功能。
如上图所看到的，jeDate 的界面这个样子，值得一提的是，一般时间的input 输入框 是设置为只读的。所以需要其时间插件内部提供清空 调用功能。而下面要说的 bootstrap-datetimepicker 就没有提供这个功能，需要自己修改实现。
同其他插件不同的地方在于，下方有时分秒的选项。点击进入相应的设置界面。需要注意的是 js 中调用方法设置前面后面时间相互制约的限制
代码如下
var startDate = jeDate({ dateCell:"#start-date", format:"YYYY-MM-DD hh:mm:ss", isTime:true, isinitVal:true, minDate:jeDate.now(0), choosefun:function(val) { endDate.config.minDate = val; requireDate.config.minDate = val; $("#start-date").blur(); }, okfun:function(val) { endDate.config.minDate = val; requireDate.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a23d35fd9e6597817a4b80b68cda544c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/303ac795d92ee8a42c4bd3897014f395/" rel="bookmark">
			Android 系统在程序中设置以太网的DHCP 和静态IP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近项目上有需求要在项目中修改以太网的DHCP和静态IP，在网上看了很多这方便的Demo，发现都不够全面，正好我们公司有个自己集成的EthernetManager的android源码，在源码中，找到了如何修改以太网的DHCP和静态IP，在此分享出来，让后人少踩坑！
先说下使用权限问题：
&lt;!-- android:sharedUserId="android.uid.system" 使其成为系统应用--&gt;
使用这个权限需要系统对应的三个文件:
signapk.jar
platform.x509.pem platform.pk8
并在cmd中用以下命令签名
java -jar signapk.jar platform.x509.pem platform.pk8 pubwin_box_v1.1.apk pubwin_box_v1.1_signed.apk
具体重新签名步骤：
1 创建一个目录 2 整理必须的文件： 密钥文件：进入build/target/product/security ,找到【platform.pk8】和【platform.x509.pem】系统默认使用的密钥。 signapk工具：进入build\tools\signapk找到SignApk.java，运行 javac或者直接mm编译。 signapk.jar的源码位置build/tools/signapk，编译以后生成的文件路径：out/host/linux-x86/framework/signapk.jar 3.执行命令: java -jar signapk.jar platform.x509.pem platform.pk8 your.apk your_signed.apk 这条命令的意义是：通过signapk.jar这个可执行jar包，以“platform.x509.pem”这个公钥文件和“platform.pk8”这个私钥文件对“your.apk”进行签名，签名后的文件保存为“your_signed.apk”。 对于此处所使用的私钥和公钥的生成方式，这里就不做进一步介绍了。可以参考 http://blog.csdn.net/absurd/article/details/5002763（我是直接从源码中找到的，若有需要，请加我QQ 786914253获取）
接下来就是将源码中的classes.jar放入项目中获取隐藏API，至于如何获取和放入项目中，请参考这篇文章：http://blog.csdn.net/hudashi/article/details/8184442（我选的是方式二）
这样就可以获得EthernetManager类了，记得一定要将classes.jar置顶，要不然接下来的代码会报错.
以下就是设置DHCP和静态IP代码：
mEthManager = (EthernetManager) getSystemService(Context.ETHERNET_SERVICE);
if (isFuck) {
//DHCP模式
mIpAssignment=IpAssignment.DHCP;
mEthManager.setConfiguration(new IpConfiguration(mIpAssignment,
ProxySettings.NONE, null, null));
} else {
//STATIC模式
mIpAssignment=IpAssignment.STATIC;
mStaticIpConfiguration = new StaticIpConfiguration();
int result = validateIpConfigFields(mStaticIpConfiguration);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/303ac795d92ee8a42c4bd3897014f395/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1030093b15591f187c0a19c652b6ac75/" rel="bookmark">
			Vue.js新手入门指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在逛各大网站，论坛，以及像SegmentFault等编程问答社区，发现Vue.js异常火爆，重复性的提问和内容也很多，楼主自己也趁着这个大前端的热潮，着手学习了一段时间的Vue.js，目前用它正在做自己的结业项目。
在做的过程中也对Vue.js的官方文档以及其各种特性有了许多认识。作为一个之前以PHP+模版引擎为主的开发，从一个从未接触过除HTML+CSS+JavaScript+JQuery以外的前端技术的人到现在可以独立使用Vue.js以及各种附属的UI库来开发项目，我总结了一些知识和经验想与大家分享。
下面我就以问答的形式来分享吧。这里假设你仅仅只掌握了HTML+CSS+JavaScript，如果你对JQuery这个前端库，以及各种后端模版语言比如说PHP，JSP还有所了解并且使用过的话那就太好了。
1.Vue.js是什么？ Vue.js（读音 /vjuː/, 类似于 view） 是一套构建用户界面的 渐进式框架。与其他重量级框架不同的是，Vue 采用自底向上增量开发的设计。Vue 的核心库只关注视图层，并且非常容易学习，非常容易与其它库或已有项目整合。另一方面，Vue 完全有能力驱动采用单文件组件和 Vue 生态系统支持的库开发的复杂单页应用。
Vue.js 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。
如果你是有经验的前端开发者，想知道 Vue.js 与其它库/框架的区别，查看对比其它框架。
这是官网的介绍，是不是觉得非常的抽象非常的官方？看完之后可能还是有很多人不是很懂这个框架到底是用来做什么的，什么是“渐进式框架”？什么是“自底向上增量开发”？什么是“视图层”？什么是“单文件组件”？什么是“复杂的单页应用？”第二段话里面“响应的数据绑定和组合的视图组件”这又是个啥？还有最后一段话，“Vue.js 与其它库/框架的区别”究竟是什么？
不要担心，如果你慢慢看完这里面的所有问答，一定会对前面那些可能你从未听说过的专业术语有一种恍然大悟的感觉。
2.Vue.js到底是什么？ 想必现在能看到我这篇文章的人，都是用着APP或者网页版知乎在阅读把。Vue.js就是一个用于搭建类似于网页版知乎这种表单项繁多，且内容需要根据用户的操作进行修改的网页版应用。
3.单页应用程序（SPA） 顾名思义，单页应用一般指的就是一个页面就是应用，当然也可以是一个子应用，比如说知乎的一个页面就可以视为一个子应用。单页应用程序中一般交互处理非常多，而且页面中的内容需要根据用户的操作动态变化。
4.你前面说的网页版知乎我也可以用JQuery写啊，为什么要用Vue.js呢？ 讲到JQuery，就不得不说到JavaScript的DOM操作了。如果你用JQuery来开发一个知乎，那么你就需要用JQuery中的各种DOM操作方法去操作HTML的DOM结构了。
现在我们把一个网页应用抽象一下，那么HTML中的DOM其实就是视图，一个网页就是通过DOM的组合与嵌套，形成了最基本的视图结构，再通过CSS的修饰，在基本的视图结构上“化妆”让他们看起来更加美观。最后涉及到交互部分，就需要用到JavaScript来接受用户的交互请求，并且通过事件机制来响应用户的交互操作，并且在事件的处理函数中进行各种数据的修改，比如说修改某个DOM中的innerHTML或者innerText部分。
我们把HTML中的DOM就可以与其他的部分独立开来划分出一个层次，这个层次就叫做视图层。
Vue 的核心库只关注视图层 我们为什么要把视图层抽取出来并且单独去关注它呢？
因为在像知乎这种页面元素非常多，结构很庞大的网页中，数据和视图如果全部混杂在一起，像传统开发一样全部混合在HTML中，那么要对它们进行处理会十分的费劲，并且如果其中有几个结构之间存在藕断丝连的关系，那么会导致代码上出现更大的问题，这什么问题呢？
你是否还记得你当初写JQuery的时候，有写过$('#xxx').parent().parent().parent()这种代码呢？当你第一次写的时候，你觉得页面元素不多，不就是找这个元素的爸爸的爸爸的爸爸吗，我大不了在注释里面写清楚这个元素的爸爸的爸爸的爸爸不就好了。但是万一过几天之后你的项目组长或者你的产品经理突然对你做的网页提出修改要求，这个修改要求将会影响页面的结构，也就是DOM的关联与嵌套层次要发生改变，那么$('#xxx').parent().parent().parent()可能就会变成$('#xxx').parent().parent().parent().parent().parent()了。
这还不算什么，等以后产品迭代越来越快，修改越来越多，而且页面中类似的关联和嵌套DOM元素不止一个，那么修改起来将非常费劲。而且JQuery选择器查找页面元素以及DOM操作本身也是有性能损失的，可能到时候打开这个页面，会变得越来越卡，而你却无从下手。
当你在编写项目的时候遇到了这种问题，你一定会抱怨，为什么世上会有HTML这种像盗梦空间一样的需要无数div嵌套才能做出页面的语言，为什么当初学JQuery看中的是它简洁的DOM操作，现在却一点也不觉得它有多简洁，难道我学的是假的JQuery？为什么写个代码这么难，你想砸电脑，你想一键盘拍在产品狗的脑袋上，责怪他天天改需求才让你原本花清香茶清味的代码变得如此又臭又长。
这个时候如果你学过Vue.js，那么这些抱怨将不复存在。
5.Vue.js为什么能让基于网页的前端应用程序开发起来这么方便？ 因为Vue.js有声明式，响应式的数据绑定，与组件化的开发，并且还使用了Virtual DOM这个看名字就觉得高大上的技术。
可是这些名词都是啥？
6.响应式的数据绑定 这里的响应式不是@media 媒体查询中的响应式布局，而是指vue.js会自动对页面中某些数据的变化做出响应。至于是如何响应的，大家可以先把下面这段代码随便粘贴到一个扩展名为html的文件然后用浏览器打开，随便在文本框里面输入一些文字，观察一下页面变化。
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;vue.js测试 - 代码之美专栏&lt;/title&gt; &lt;!-- author:昌维 代码之美 https://zhuanlan.zhihu.com/codes --&gt; &lt;script src="https://unpkg.com/vue/dist/vue.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt; &lt;input type="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1030093b15591f187c0a19c652b6ac75/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f31a9ead7704fbd05aac0d0cd253d82b/" rel="bookmark">
			几经周转--尘埃落定(国美入职记)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		离开软通动力之后，我再次投放求职潮水当中，各种情节，我已是久经杀场...三天弄个到2天之内弄到3-4个Offer不在话下.....值得一提的是，此次重新求职，让我下定决定从事大数据行业，不应为别的就想让自己活得更轻松一些，不想让自己沦为传说中的码农一族....
如果简历投递阶段，我基本锁定在大数据行业，App断然放弃....sayonara!!! 也许是机缘巧合之下，或许是同事的悄然建议，我居然再次接到了亿阳信通的面试通知，关键是这次的面试经历出奇的顺利，面试流程与前一次无异....记忆犹新的仍然是久违的智商测试，哈哈.....不到2个小时的时间，我便和部门领导聊了起来，过程很和谐，大致估计到自己Offer没问题，因为自己会的东西实在太多，一般公司领导都喜欢全能型的人才，这是我在小公司待过后，最大的一笔心得和收获.....,，面试第一天是亿阳，第二天是京东最后一天便是可爱的美信科技....记得当时是2016年的6月中旬....我毅然从软通离职后，便全力投入大数据行业...从此开启自己的大数据腾飞之旅....,周一开始的面试，周三便陆续接到了各公司的Offer及入职通知..记忆犹新的还是咱们亿阳信通，这家入职流程走的极慢，领导审批流程就得走2-3天，然后就是各种证明和体检报表，最后实在是耐不住内心的煎熬，最终决定，除非找不到Job,否则最好不要去亿阳这家公司，于是便有了，不管亿阳助理怎么催我的资料，我都是一个字"拖"...,终于在周五的上午，我接到了美信科技的Offer及入职通知，这家公司到时爽快，直接让我过去入职，什么资料都可以后补，内心感觉这才是我想要去的公司，效率永远第一位;这样才不会白白耗费我宝贵的生命啊......虽然中间有些小插曲，但是我最终如愿进入了一家互联网公司,并顺利走上了自己梦寐以求，却稍有波折的大数据行业!!说到这里，不得不提到当时，美信面试我的Leader，记得当时面试时，领导表现的很和谐，但是和所有面试经历一样，在面试官面前表现自己最自信的一面，是每个求职者的必备技能，因此和面试官的面试聊天过程，体现很正式，记得当时我穿的是一件西服...！好吧，这位面试官就是我时任领导------付士涛，来自亚信大数据中心--BDX部门，感谢领导的慧眼，我有幸成为美信网络的一名大数据工程师，可惜不善言辞的我，在后来的工作生活中，并没有太过愉快的经历。这或许是每个技术型人才的通病，又或许这只是我自身的诟病罢了!好吧，岂能尽如人意，但求无愧于心......跟随自己的内心走吧!!!情商明显是我的硬伤，但愿后期可补....但不补，只要心存善念应该也无伤大雅....,因为此刻的我仍在美信网络就职（后来公司改革，已更名为国美互联网）,不能写太过关于公司的事迹，因为这与我写回忆录的初衷相违背.....还是“待到重阳日，还来旧菊花”吧...感谢涛哥，感谢美信,感谢国美互联网!!还有最重要的一点，我的薪水也正式突破20k...真是值得开心的一件事，继续努力吧...
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37bf352deccd1c56d172b84aed872a57/" rel="bookmark">
			JAVA多线程不安全问题解决方案（多线程并发同一资源）。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引例：吃苹果比赛，3个人同时吃50个苹果，谁先拿到谁就吃，每个哦ing过都有编号。
问题：
多线程同时执行的时候可能出现不安全问题
当3个人同时拿到一个苹果，他们的编号就一样，当时主要看是谁先吃掉苹果
除非拿到苹果和吃掉苹果是连续同步执行，没有其他的线程干扰
方案一：
设置同步代码块（同步锁）。
synchronized(共享资源){
同步执行代码；
}
class Apple implements Runnable{ private int num=50; public void run() { for(int i=0;i&lt;50;i++){ synchronized (this) {//!!!解决了不安全问题，这里的this表示Apple共同资源 //同步代码块 //—————————————————————————————————————————————— if(num&gt;0){ try { //导致一个资源信息被多个用户同时拿到 Thread.sleep(10); } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } System.out.println(Thread.currentThread().getName()+"吃了编号为"+num+"的苹果"); num--; //—————————————————————————————————————————————————— } } } } } //Thread.currentThread().getName() 拿到当前线程的引用和名称 public class ImplementDemo { public static void main(String[] args) { Apple a=new Apple(); new Thread(a,"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37bf352deccd1c56d172b84aed872a57/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/786515cea7f741892ed723562c5792e4/" rel="bookmark">
			OGRE学习系列三：基础教程1    你的第一个场景
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文翻译自官网基础教程一，由于本人英文水平有限，翻译出错难以避免，因此英文水平较高者可直接查看英文原文。
教程介绍：
第一节教程将包含构建OGRE场景的一些基础要素。首先需要关注的就是SceneManager，SceneNode，和Entity。一个实体（Enitity）就是以三维网格表示的任何东西。一个场景节点（SceneNode）用来连接目标到场景中，场景管理器（SceneManager）组织管理所有的内容，它跟踪场景中的实体和节点，并决定如何显示他们。
我们从解释OGRE中的一些基本概念开始。别着急，第一节教程比其余教程多一些概念解释，一旦你开始后续的教程，就变得更快了。我们将构建足够多的东西，我们只是需要先打一下基础，我们才能够在后续的学习中立足于此。
这部教程中的全部源文件都在这里。
在学习这篇教程的过程中，无论你遇到什么问题，都可以Po到帮助版块。
//===============================================================
一、预备知识
本节教程假设你已经知道如何配置OGRE工程，并已经成功编译通过。如果在这方面需要帮助，请阅读Setting Up An Application。
本节内容目录列表：
1、预备知识
2、OGRE是如何工作的
2.1、场景管理器
2.2、场景节点
2.3、实体
3、构建场景
4、坐标系统
5、添加另一个实体
6、更多实体
7、更多场景节点
8、改变一个实体的尺度
9、旋转一个实体
10、OGRE环境
10.1、依赖库和插件
10.1.1、主要依赖库
10.1.2、插件
10.1.3、第三方插件
10.1.4、测试VS release
10.2、配置文件
10.2.1、插件配置
10.2.2、资源配置
10.2.3、媒体配置
10.2.4、OGRE配置
10.2.5、Quake 3设置配置
11、总结
12、下一节
//====================================================================================
二、OGRE是如何工作的
下面为OGRE场景的一些基本要素做出简单介绍。
1）场景管理器（SceneManager）
出现在屏幕上的一切内容都由SceneManager进行管理。SceneManager追踪屏幕中的物体的位置和一些其他属性。SceneManager同时也管理你添加到场景中的任何相机。SceneManager有多种类型，有些管理器关注于渲染地形，一些其他的管理器专注于渲染BSP地图。不同类型的场景管理器（SceneManager）可以在这里查看。
2）场景节点（SceneNode）
场景节点保存连接到这个节点上的所有物体的信息。一个你场景中的实体，只有连接到场景节点（SceneNode）中之后才会被渲染。另外，在你的场景中，场景节点并不是可见的物体，它仅仅包含一些简要信息，如位置和方向。仅仅当它被连接到某种物体上时，如一个实体，这些信息才会被用来在场景中渲染一个真正的物体。
场景节点（SceneNodes）可以连接多个物体，也许我们想要一个光源在场景中跟随着一个角色。为了做到这一点，我们可以同时将角色实体和光源连接在同一个场景节点中，这样会使他们共享同一份相同的位置信息。我们甚至可以将一个场景节点连接在另一个场景节点上，这种做法在许多情况下非常有用。想象一下，你想在一个角色的手中放置一个工具，你不会想把这个工具连接在整个角色的场景节点上。然而，你可以使用一个场景节点代表他们的手，然后把这个场景节点连接到角色的主要场景节点上，然后连接工具实体到这个”子“场景节点。更多复杂的场景节点应用将会在后续内容中介绍。
最后要记得场景节点的位置通常与他们的父节点相关，而且每一个场景管理器创建一个根节点，所有其他场景节点都与此根节点相连接。
3）实体（Enitity）
实体是一种类型的你可以在场景中进行渲染的物体。它可是3D 网格代表的任何物体，甚至地形目标也是巨大的实体。但是，如光线、广告牌、微粒、相机等场景要素并非实体。OGRE使用了一种众所周知的设计模型，这种模型分离了渲染目标的信息，比如位置信息。这意味着你并不不用直接在场景中防止实体。而是，放置一个场景节点在场景中，然后在这个节点上连接一个实体。随后使用场景节点上存储的各种信息来渲染这个实体。
三、构建场景
终于可以在我们的场景中构建物体了，首先我们要做的就是打开灯光，添加下列代码到TutorialApplication::createScene：
mSceneMgr-&gt;setAmbientLight(Ogre::ColorValue(0.5,0.5,0.5));
此处，setAmbientLight方法需要一个Ogre::ColorValue，这三个值分别代表颜色空间三通道中的红、绿和蓝。他们的范围是0到1.
此处，mSceneMgr是一个变量，定义在BaseApplication中，其中有很多变量，如mCamera，继承自BaseApplication。后面用到他们的时候我们再进行介绍。
我们要做的下一件事就是让SceneManager创建一个实体。
Ogre::Entity* ogreEntity=mSceneMgr-&gt;createEntity("ogrehead.mesh");
传入此函数的参数必须是一个可以由Ogre资源管理器加载的Mesh。目前，资源加载是BaseApplication为我们管理的众多内容之一。后续教程里会进行解释。
现在我们有了一个实体，我们需要创建一个场景节点，这样才能让这个实体在我们的场景中显示出来，每一个场景管理器都有一个根节点，这个根节点有一个方法叫做createChildSceneNode，这个方法可以返回一个新的连接在根节点上的场景节点。老版本的OGRE中，你会被要求为你的实体和场景节点提供一个唯一的名字。现在这个是可选项，如果你不提供名称，OGRE会自动生成。
Ogre::SceneNode* ogreNode=mSceneMgr-&gt;getRootSceneNode()-&gt;createChildSceneNode();
我们保存了createChildSceneNode()方法返回的场景节点指针，因此我们可以将它与我们的实体连接。
ogreNode-&gt;attachObject(ogreEntity);
灯光在下一节教程中会被详细提及，此处我们依然会添加一个简单的灯光到这个场景中，新的灯光目标依然可以从场景管理器中请求得到，在灯光被创建时，我们给它一个唯一的名字。
Ogre::Light* light=mSceneMgr-&gt;createLight("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/786515cea7f741892ed723562c5792e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbda515199135e92902bb2ddbfc0d188/" rel="bookmark">
			Matlab常用的标记符号和颜色
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 http://blog.csdn.net/u012463017/article/details/46774059 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a322b4e1f459ceff19fc80cd6b836a1/" rel="bookmark">
			LintCode 二叉树的路径和
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.描述
给定一个二叉树，找出所有路径中各节点相加总和等于给定 目标值 的路径。
一个有效的路径，指的是从根节点到叶节点的路径。
哪家公司问你的这个题？ Airbnb Alibaba Amazon Apple Baidu Bloomberg Cisco Dropbox Ebay Facebook Google Hulu Intel Linkedin Microsoft NetEase Nvidia Oracle Pinterest Snapchat Tencent Twitter Uber Xiaomi Yahoo Yelp Zenefits 感谢您的反馈 样例 给定一个二叉树，和 目标值 = 5:
1 / \ 2 4 / \ 2 3 返回：
[ [1, 2, 2], [1, 4] ] 2.分析
首先找到叶子节点，这样从根节点到叶子结点才是路径，随后判断该路径一路上的节点值
之和是否等于给定目标值。
3.代码
/**
* Definition of TreeNode:
* class TreeNode {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5a322b4e1f459ceff19fc80cd6b836a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a00ed4e59897486d3d42fc70bdc9008/" rel="bookmark">
			c&#43;&#43; STL的list用法总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		头文件
#include&lt;list&gt;
声明一个int型的list：list&lt;int&gt; a；
1、list的构造函数
list&lt;int&gt;a{1,2,3} list&lt;int&gt;a(n) //声明一个n个元素的列表，每个元素都是0 list&lt;int&gt;a(n, m) //声明一个n个元素的列表，每个元素都是m list&lt;int&gt;a(first, last) //声明一个列表，其元素的初始值来源于由区间所指定的序列中的元素，first和last是迭代器 2、begin()和end() 通过调用list容器的成员函数begin()得到一个指向容器起始位置的iterator，可以调用list容器的end()函数来得到list末端下一位置
3、push_back()和push_front()
使用list的成员函数push_back和push_front插入一个元素到list中。其中push_back()是从list的末端插入，而push_front()是从list的头部插入。
4、empty()
判断list是否为空
5、resize()
调用resize(n)将list的长度改为只容纳n个元素，超出的元素将被删除。如果n比list原来的长度长，那么默认超出的部分元素置为0。也可以用resize(n, m)的方式将超出的部分赋值为m。
例子：
list&lt;int&gt;b{1, 2, 3, 4}; b.resize(2); list中输出元素：1,2 list&lt;int&gt;b{1, 2, 3, 4}; b.resize(6); list中输出元素：1,2,3,4,0,0 list&lt;int&gt;b{1, 2, 3, 4}; b.resize(6,9); list中输出元素：1,2,3,4,9,9 6、clear()
清空list中的所有元素
7、front()和back()
通过front()可以获得list容器中的头部元素，通过back()可以获得list容器的最后一个元素。注意：当list元素为空时，这时候调用front()和back()不会报错。因此在编写程序时，最好先调用empty()函数判断list是否为空，再调用front()和back()函数。
8、pop_back()和pop_front()
使用pop_back()可以删掉尾部第一个元素，pop_front()可以删掉头部第一个元素。注意：list必须不为空，如果当list为空的时候调用pop_back()和pop_front()会使程序崩掉。
9、assign()
有两种使用情况：
（1）a.assign(n, val):将a中的所有元素替换成n个val元素
例如：
list&lt;int&gt;b{1,2,3,4,5}; b.assign(5,10); b中的元素变为10, 10, 10, 10, 10 （2）a.assign(b.begin(), b.end())
list&lt;int&gt;a{6,7,8,9}; list&lt;int&gt;b{1,2,3,4,5}; b.assign(a.begin(),a.end()); b中的元素变为6,7,8,9
10、swap()
交换两个链表。a.swap(b)和swap(a, b)，都可以完成a链表和b链表的交换。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a00ed4e59897486d3d42fc70bdc9008/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/336bf375711ae651a5236bad16fcc486/" rel="bookmark">
			字符串（含特殊符号）入库mesql报错：Incorrect string value: &#39;\xF0\x90\x8D\x83...&#39; for column
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		json字符串解析 批量导入mysql数据库的过程中报错 Incorrect string value: '\xF0\x90\x8D\x83...' for column；
解决方案：
才疏学浅的我，替换掉了特殊字符；
/** * 将emoji表情替换成* * * @param source * @return 过滤的字符串 */ public static String filterEmoji(String source) { if(StringUtils.isNotBlank(source)){ return source.replaceAll("[\\ud800\\udc00-\\udbff\\udfff\\ud800-\\udfff]", "*"); }else{ return source; } }
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56d7ee18a9d32820c889e99fda4c30ad/" rel="bookmark">
			python logging添加filter例子
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		例子一
def filter(self, record): """Our custom record filtering logic. Built-in filtering logic (via logging.Filter) is too limiting. """ if not self.filters: return True matched = False rname = record.name # shortcut for name in self.filters: if rname == name or rname.startswith(name+'.'): matched = True return matched 例子二 def _create_log_handlers(stream): """Create and return a default list of logging.Handler instances. Format WARNING messages and above to display the logging level, and messages strictly below WARNING not to display it.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/56d7ee18a9d32820c889e99fda4c30ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f58e84f960289f25fa541688a37ccb52/" rel="bookmark">
			运行yarn宕机（pyspark任务，通过O…
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 添加fair调度器以后，pyspark任务能成功提交到与big2不同的big1机子上，但是big1机子宕机了…… 回头查日志，是这样的： ERROR org.apache.hadoop.yarn.server.nodemanager.NodeManager: RECEIVED SIGNAL 15: SIGTERM 2台运行节点node在vmware里面都增加到4GB的内存以后，pyspark运行所在的机子终于不宕机了。 （后面成功配好后，实际运行pyspark时，用$ top 命令查看资源占用的时候，计算节点整个4GB，会占掉2.5GB，怪不得会宕机，看来2GB内存确实不够） 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c36e5ba39c17c676c4b7697d2bc58677/" rel="bookmark">
			安卓权限配置时出现“Permission is only granted to system apps”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 解决方法点击这里 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eba73f440773aa9cb9e49b0cfcf864a8/" rel="bookmark">
			java 开始小结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1. 如果没有发出请求，可能是js有bug 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df1e253815876082eb4f0a1b22cb3447/" rel="bookmark">
			c# DEV 关于gridcontrol 控件，gridview 列为RepositoryItemtextedit获取值的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先说下，gridview 里添加行，然后编辑列对应的值，当鼠标移开列，值是会消失的，这时候应该绑定个空的datatable，datatable dt=new datatable(); gridControl1.DataSource=dt；这样你编辑数据的时候是会显示出来的。
添加行代码：
#region 新增行事件
private void gridView1_InitNewRow(object sender, DevExpress.XtraGrid.Views.Grid.InitNewRowEventArgs e)
{
ColumnView View = sender as ColumnView;
View.SetRowCellValue(e.RowHandle, View.Columns[0], gridView1.GetRowCellValue
(gridView1.GetRowHandle(gridView1.RowCount - 2), gridView1.Columns[0])); //复制最后一行的数据到新行 }
#endregion
//新增行按钮
private void bbtnAdd_ItemClick(object sender, DevExpress.XtraBars.ItemClickEventArgs e)
{ gridView1.AddNewRow();
gridView1.OptionsBehavior.Editable = true;
}
// 读取repositoryItemTextEdit(文本框和textbox差不多)的值：
repositoryItemTextEdit.NullText = Convert.ToString(gridView1.GetRowCellValue(gridView1.FocusedRowHandle, "WLMC"));
说明下：gridView1.GetRowCellValue(gridView1.FocusedRowHandle, "WLMC")); //获取列FileName 为 WLMC的值；
判断是否为空：
if (OriginalUtil.IsNullOrEmpty(rptWLMC.NullText) || rptWLMC.NullText == "System.DBNull.Value")
{ MsgBox.Warning("物料名称不能为空！");
return;
}
OriginalUtil.IsNullOrEmpty(）是自定义类方法。你们可以用rptWLMC.NullText==“”；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be74742d57eae962e0bdcd3f39f7f14f/" rel="bookmark">
			取模和取余的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 a对b取余（取模）的过程 1. c = a/b (对a/b的值取整) 2. r = a - b*c （r为取余或取模的结果） ※取余和取模的差别就在于取整的方法，取余是向0的方向舍入，取模的时候向无穷小的方向舍入。 因此 ①当a和b符号相同时，a/b为正数，0与无穷小为同一方向。取模与取余相同。 如9/5 = 1.8 向0的方向舍入为1（即c = 1），取余结果为4。向无穷小的方向舍入为1（即c = 1），取模结果为4。 ②当a和b符号不同时，a/b为负数，0与无穷小为不同方向。取模与取余不同。 如-9/5 = -1.8 向0的方向舍入为-1（即c = -1），取余结果为4。向无穷小的方向舍入为-2（即c = -2），取模结果为4。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc508437d8d248e0f190b51bdc9af36a/" rel="bookmark">
			springmvc&gt;&gt;&gt;ssm添加跨域&gt;&gt;基于maven
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在pom.xml文件中添加
&lt;!-- 跨域过滤器相关 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.thetransactioncompany&lt;/groupId&gt; &lt;artifactId&gt;java-property-utils&lt;/artifactId&gt; &lt;version&gt;1.9.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt; &lt;artifactId&gt;gson&lt;/artifactId&gt; &lt;version&gt;2.6.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/com.thetransactioncompany/cors-filter --&gt;
&lt;dependency&gt;
&lt;groupId&gt;com.thetransactioncompany&lt;/groupId&gt;
&lt;artifactId&gt;cors-filter&lt;/artifactId&gt;
&lt;version&gt;1.3.2&lt;/version&gt;
&lt;/dependency&gt;
&lt;!-- 跨域过滤器相关 --&gt; 之后在web.xml中添加
&lt;filter&gt; &lt;description&gt;跨域过滤器&lt;/description&gt; &lt;filter-name&gt;CORS&lt;/filter-name&gt; &lt;filter-class&gt;com.thetransactioncompany.cors.CORSFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;cors.allowOrigin&lt;/param-name&gt; &lt;param-value&gt;*&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;cors.supportedMethods&lt;/param-name&gt; &lt;param-value&gt;GET, POST, HEAD, PUT, DELETE&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;cors.supportedHeaders&lt;/param-name&gt; &lt;param-value&gt;Accept, Origin, X-Requested-With, Content-Type, Last-Modified&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;cors.exposedHeaders&lt;/param-name&gt; &lt;param-value&gt;Set-Cookie&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;cors.supportsCredentials&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CORS&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 即可解决前端访问后端的跨域问题
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28035ffa25d90657ca619efe12b943ce/" rel="bookmark">
			C# NPOI Excel固定模板写入数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		导出数据触发： &lt;div&gt; &lt;input type="button" value="导出" onclick="ImportExcel()" /&gt; &lt;/div&gt;
后台实现：
//Excel模板 string TempletFileName = context.Server.MapPath("..../UploadFile/test.xls"); HSSFWorkbook wk = null; using (FileStream fs = File.Open(TempletFileName, FileMode.Open, FileAccess.Read, FileShare.ReadWrite)) { //把xls文件读入workbook变量里，之后就可以关闭了 wk = new HSSFWorkbook(fs); fs.Close(); } HSSFSheet sheet1 = (HSSFSheet)wk.GetSheetAt(0); DoctorBLL bll = new DoctorBLL(); DataTable exportTable = bll.GetExportQuestionTable(); if (exportTable != null) { int nRow = 2; string nextFirstTxt = string.Empty; for (int i = 0; i &lt; exportTable.Rows.Count; i++) { IRow row = sheet1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/28035ffa25d90657ca619efe12b943ce/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/533/">«</a>
	<span class="pagination__item pagination__item--current">534/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/535/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>