<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8fe903c85d7cd129cd5b5ed0efa42a1c/" rel="bookmark">
			Maven安装及配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.下载 Maven – Download Apache Maven
2.安装 maven压缩包解压到一个没有中文，空格或其他特殊字符的文件夹内即可使用。
3.配置环境变量 1.右键此电脑-&gt;属性-&gt;高级系统设置-&gt;环境变量 2.新建系统变量MAVEN_HOME 3.编辑系统变量Path，添加变量值%MAVEN_HOME%\bin 4.验证安装是否成功，win+R运行cmd，输入mvn -v，如图所示则配置成功 4.配置本地仓库 1.在maven的安装目录下创建一个repository文件夹用作本地仓库（一般习惯将仓库地址和maven安装目录放置在一起）。 2.修改本地仓库地址 (1)在Maven安装目录conf目录下找到settings.xml配置文件打开 (2)找到 &lt;localRepository&gt;标签节点并将其改为本地仓库地址 5.配置私服 (1)在Maven安装目录conf目录下找到settings.xml配置文件打开 (2)找到 &lt;mirrors&gt;标签节点并将其改为如下: 将原有注释
//阿里云 &lt;mirror&gt; &lt;id&gt;aliyunmaven&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorO&gt; &lt;name&gt;阿里云公共仓库&lt;/name&gt; &lt;url&gt;https://maven.aliyun.com/repository/public&lt;/url&gt; &lt;/mirror&gt; ## 或 //网易 &lt;mirror&gt; &lt;id&gt;nexus-163&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;name&gt;Nexus 163&lt;/name&gt; &lt;url&gt;http://mirrors.163.com/maven/repository/maven-public/&lt;/url&gt; &lt;/mirror&gt; ## 或 //腾讯云 &lt;mirror&gt; &lt;id&gt;nexus-tencentyun&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;name&gt;Nexus tencentyun&lt;/name&gt; &lt;url&gt;http://mirrors.cloud.tencent.com/nexus/repository/maven-public/&lt;/url&gt; &lt;/mirror&gt; 6.项目结构 没有的 java 或 resources、或 webapp 要添加进去
7.IDEA配置 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-0GG400qK-1675758562809)(null)]
本地获取,添加 -DarchetypeCatalog=internal
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-USnCWraM-1675758552834)(C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230207110348941.png)]
8.pom文件配置 &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8fe903c85d7cd129cd5b5ed0efa42a1c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35aa92a71194f6a929e5ef1b41f14f6d/" rel="bookmark">
			单线程 Redis 如此之快的 4 个原因
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 作为内存中数据存储，Redis 以其速度和性能着称，通常被用作大多数后端服务的缓存解决方案。
但是，在内部，Redis 采用单线程架构。
为什么单线程设计依然会有这么高的性能？如果利用多线程并发处理请求不是更好吗？
在本文中，让我们深入探讨为什么 Redis 才有单线程架构，依然如此之快，主要从下面4个方面讲解。
内存数据存储
优良的数据结构
单线程架构
非阻塞IO
让我们一一剖析。
内存数据存储 访问 RAM 比磁盘快几个数量级
Redis 是一个基于内存存储数据，也就是上面表的RAM。
Redis 中的每个读写操作都等同于从命中 RAM（随机存取存储器）的变量中读取和写入。
访问 RAM 比直接访问磁盘快几个数量级，因此，Redis 比其他数据存储快得多。
优良的数据结构 作为内存中的数据存储，Redis 利用各种底层数据结构来高效地存储数据，而无需担心如何将它们持久化到持久存储中。
例如，Redis 列表是使用链表实现的，该链表允许在列表的头部和尾部附近进行恒定时间 O(1) 的插入和删除。
另一方面，Redis 排序集是通过跳跃列表实现的，它可以实现更快的查询和插入。
简而言之，无需担心持久化数据，Redis 中的数据可以更有效地存储，以便通过不同的数据结构进行快速检索。
更多C++后台开发技术点知识内容包括C/C++，Linux，Nginx，ZeroMQ，MySQL，Redis，MongoDB，ZK，流媒体，音视频开发，Linux内核，TCP/IP，协程，DPDK多个高级知识点。
C/C++Linux服务器开发高级架构师/C++后台开发架构师免费学习地址
【文章福利】另外还整理一些C++后台开发架构师 相关学习资料，面试题，教学视频，以及学习路线图，免费分享有需要的可以点击领取
单线程架构 单线程进程
Redis 的写入和读取速度极快，CPU 使用率对 Redis 来说从来都不是问题。
根据 Redis 官方文档，在普通 Linux 系统上运行时，Redis 每秒可以传递多达 100 万个请求。
然而，瓶颈主要来自网络 I/O。Redis 中的处理时间主要浪费在等待网络 I/O 上。
虽然多线程架构允许应用程序通过上下文切换并发处理任务，但 Redis 的性能提升是微乎其微的，因为大多数线程最终会在 I/O 中被阻塞。
通过采用单线程架构，Redis有下面的几个好处：
最小化由于线程创建或销毁引起的 CPU 消耗
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/35aa92a71194f6a929e5ef1b41f14f6d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a2b5188f266306267e0e4deb3b9f9c4/" rel="bookmark">
			iOS App 上架App Store及提交审核详细教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上架App Store审核分7步进行：
目录
一、上传ipa到App Store
二、设置APP各项信息提交审核
1、安装iOS上架辅助软件Appuploader
2、申请iOS发布证书（p12）
3、申请iOS发布描述文件（mobileprovision）
4、打包ipa
5、上传ipa到iTunes Connect
6、TestFlight方式安装到苹果手机测试
7、设置APP各项信息提交审核
前四布我们之前都做了，详见这篇博客：利用Appuploader在window上申请IOS开发所需要的证书及描述文件，我们主要看后面几步。
一、上传ipa到App Store 1、上传ipa前先登录iTunes Connect，点击我的APP进入创建一个APP
https://itunesconnect.apple.com/login，其实就是现在的app store connect
2、进入点击左上角+号选择新建APP，选择平台iOS，
应用名称：APP的名称
语言：APP的语言，中文还是英文。
套装ID：（应用id、appid、包名，跟申请证书使用的要保持一致）
sku：不能写中文，自己用拼音随便编一个，好识别就行，如app叫淘宝，就输入taobao。
用户访问权限：选完全访问权限
创建APP，先进行下一步上传IPA文件，其他相关信息暂时不用填写
3、上传ipa之前、需要先配置上传专用密码
APP专用密码app-specific password是专门用于上传ipa文件的一种密码，是一种苹果的安全机制！现在苹果开发者账号开启了双重认证，提交ipa文件时候都需要这个密码！其特点：
（1）不会失效
（2）可以生成多个（忘记了可以重新申请）
（3）不同的APP上架通用（无需重复生成）
下面是生成步骤：
（1）、首先打开apple id管理中心：:管理你的 Apple ID
登录苹果开发者账号
（2）、登录进去后找到安全项目，点击生成专用密码。
密码标签随便输入，123，app等之类的都行。
（3）、点击创建生成，（注意密码标签不是专用密码，是由苹果系统生成的一串密码）专用密码就是下面这个样子的密码，把这个密码复制，打开Appuploader
如果是Appuploader软件进行上传ipa（Appuploader软件可以帮助在Windows电脑直接申请iOS证书和上传ipa）
4、打开AU软件点击右上角（下图箭头处）
进入设置，把上传专用密码复制上去，同时勾选上保存密码，点击Save保存，然后再回去提交ipa上传就可以正常上传了。
5、选择刚打包的ipa包
Appuploader将自动上传你的IPA，包如果很大需要上传一段时间，当出现以下提示时 说明上传成功。
如果进度条红色说明上传失败，根据提示，找解决方案。
常见错误方案解决：上传ipa常见错误解决方案
6、上传成功后到后台查看上传的版本
登录iTunes Connect https://itunesconnect.apple.com/login后台查看上传的ipa
二、设置APP各项信息提交审核 1、ipa上传及测试后，配置App Store后台各项信息！
在App Store项，先选择第一项APP信息、需要设置两个地方。
（1）隐私政策网址：可直接填写我们官网链接http://blog.applicationloader.net/blog/zh/3721.html或者自己的网站！
也可参考这个教程，做一份正规的隐私政策链接：隐私政策链接模板教程
副标题：可写可不写
类别：根据自己APP类型选。
注意：主要类型是必填项，必须选一种
2、再选择左边的第二项价格与销售范围
价格时间表：免费APP就设置为免费、收费的app就根据情况设置价格。
销售范围：如果只是上架到中国就选中国、也可以全选所有地区，影响不大，设置好储存。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a2b5188f266306267e0e4deb3b9f9c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7d2e42b7313c124a66664f218c283ea/" rel="bookmark">
			docker最简化安装activemq
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		docker rm -f activemq
docker run --name activemq -itd -h mq \
--restart always \
--privileged \
-e 'ACTIVEMQ_CONFIG_MINMEMORY=1024' \
-e 'ACTIVEMQ_ADMIN_LOGIN=admin' \
-e 'ACTIVEMQ_ADMIN_PASSWORD=Pinming@1024' \
-e 'ACTIVEMQ_CONFIG_MAXMEMORY=4096' \
-p 8161:8161 -p 61616:61616 -p 61613:61613 \
-v /app/app/activemq/mq-data:/data/activemq \
-v /app/app/activemq/log:/var/log/activemq \
swr.cn-east-3.myhuaweicloud.com/syh/activemq:5.17.1
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5bbf7a33bd076bdb96ac4392541ffb0f/" rel="bookmark">
			台式机和笔记本 如何选择
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		台式机：
1、.在相同价格下合同等价位的笔记本相比，台式机的性价比高得多；
2、机箱的散热更好，性能比较稳定；
3、台式机有功能强大的双核、三核、四核等性能强劲的处理器，而笔记本只能用专用的CPU；可以配置大屏幕的显示器，显示效果好。
笔记本：
1、体积小，方便携带，移动性强；
2、耗电量少，可以节省很多用电；
3、辐射量少，对人体健康减少辐射。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e05aeaf73c7e02a2f15a7626e25da13/" rel="bookmark">
			Pixel 、Xiaomi root刷机-降级版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Pixel前言刷机步骤下载手机对应版本的官方镜像包面具的版本尽量要是最新版 最后Xiaomi解锁OEM锁小米稳定版系统刷为小米开发版安装Mask Pixel 因为我是第一次root这东西，跟着网上的博主一步步走，但是某些文章热度高但是讲解的不完整，导致我root失败直接变砖
这里我结合一个博主的版本(https://sspai.com/post/57922、https://sspai.com/post/57923)加上我的入坑道路给大家一个完整的root指南！！
前言 注意在此之前如果你是谷歌手机，你的开发者选项里面的OEM解锁 一定是可以打开的，不然在现阶段来说是root不了的！
如果在此之前你的手机已经开不了机或者开机界面卡死可以从下面刷机步骤进行对应版本刷机，完成后会将手机刷回正常状态
刷机步骤 下载手机对应版本的官方镜像包 我的文章主要是起一个实战经验总结作用，然后补充原作者没有说明的地方，所有大家还是结合我的文章和原作者文章一起看～
这个链接是google工具需要电脑连接国外的网络才能使用。并且需要用谷歌浏览器或者Edge浏览器，不然你同样进不去这个网站！
下载地址：https://developers.google.com/android/images如何查看自己手机要下的版本：设置-&gt;关于手机-&gt;版本号（我的是RQ3A.210905.001）我的设备是Pixel 3 所以就下载对应下面的RQ3A.210905.001这个版本，这一步一定不能错！！这就是我第一次手机变砖的原因！(2e414dda6a829af4881ef47b89d84dd8d1643b3d4256e6a62fdc2dd865442542) 下载完后的文件如下：
windows用户：打开cmd终端执行这里flash-all.bat程序
Mac、linux用户: 打开shell终端执行这里flash-all.sh程序
然后什么也不用管等待10分钟就可以正常使用了
刷机回正常手机后，这里可以选择刷以前的旧版本目前（最旧也就只能Android9）：https://flash.android.com/ 通过usb连接好需要刷机的设备，下方会有一个出厂映像版本选择，自己想刷哪个版本的就选哪个。
如果就想使用最新版Android进行root也是ok的。不过可能市面上很多逆向工具可能用不了，或者有点麻烦
面具的版本尽量要是最新版 因为现在好多文章都是几年前的文章了，mask软件更新很快，之前我跟着一个博主下了一个老版本的面具，不是卡死在加载中，就是直接安装按钮就没有 github地址：https://github.com/topjohnwu/Magisk/releases 同样是外网网站需要翻墙！ 刷完机后这里有个一键搭建逆向（root）环境的工具-&gt; https://github.com/cxf-boluo/magisk_All -&gt; 点我
工具说明：
集成工具：MT管理器、Igniter、启用webView调试、HTTPCanary、proxydroid、SSLping集成模块：lsposed、Shamiko开机自启动：frida-server android-server默认抓包证书从用户证书存储移动到系统目录下 如果root后连接wifi后出现不能访问那么在pc端执行下面命令：
adb shell settings put global captive_portal_https_url https://www.google.cn/generate_204
最后 记录下Android系统出场的文件系统吧
$ adb shell blueline:/ $ su blueline:/ # ls acct debug_ramdisk metadata sdcard apex default.prop mnt storage bin dev odm sys bugreports dsp oem system cache etc persist system_ext config init postinstall vendor d init.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e05aeaf73c7e02a2f15a7626e25da13/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57815404a4dcab7c5e095bee27cc6a34/" rel="bookmark">
			OkHttp源码笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OkHttp中的Request
文章目录 1 Request2 RealCall3 Call.enqueue()4 AsyncCall 1 Request 在RealCall中的内部类ApplicationInterceptorChain中
private final Request request; 在构造方法中，初始化了该request
ApplicationInterceptorChain(int index, Request request, boolean forWebSocket) { this.index = index; this.request = request; this.forWebSocket = forWebSocket; } 并在RealCall中的getResponseWithInterceptorChain方法中创建了该对象
private Response getResponseWithInterceptorChain(boolean forWebSocket) throws IOException { Interceptor.Chain chain = new ApplicationInterceptorChain(0, originalRequest, forWebSocket); return chain.proceed(originalRequest); } 而RealCall中的originalRequest变量是在构造方法中被赋值的
protected RealCall(OkHttpClient client, Request originalRequest) { this.client = client; this.originalRequest = originalRequest; } 也就是说，创建RealCall对象，需要Request对象。
2 RealCall 在OkHttpClient类中创建了RealCall
@Override public Call newCall(Request request) { return new RealCall(this, request); } 在OkHttpCall中，调用了该newCall方法。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57815404a4dcab7c5e095bee27cc6a34/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10a64ac843816fb5de284803cef8d51f/" rel="bookmark">
			vuex实现查询和删除
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		配置vuex模块 vue2中使用npm i vuex@3 查询流程: 组件获取数据---&gt;向vuex的actions派发动作---&gt;在actions的函数中向后台接口发起的异步请求---&gt;actions向mutations提交state的请求，同时将从服务器端获取的数据传递过去---&gt;获取state的值(即将服务器端的响应数据赋给state属性)---&gt;在组件中通过vuex的getters获取state中的数据并渲染到el-table中。 删除流程: 组件要删除数据---&gt;向vuex的actions派发删除动作，同时将id传过去---&gt;在actions的函数中向后台接口发起删除的异步请求---&gt;actions向mutations提交修改state的请求，同时将从服务器端获取的数据传递过去---&gt;修改state的值(即将服务器端的响应数据赋给state属性)---&gt;在组件中通过vuex的getters获取state中的数据并渲染到el-table中。 stroe文件夹下面store.js文件，创建一个vuex原型 import Vue from "vue"; import Vuex from 'vuex' import axios from "axios"; Vue.use(Vuex) //-----创建Store对象------- export default new Vuex.Store({ state:{ userList:[]//是Store中维护的全局数组，用来保存服务器端相应的数据 }, getters:{//类似于计算属性，用来获取state中定义的属性值 getUserList(state){//函数参数默认为state return state.userList } }, mutations:{//可以修改state属性值的方法，代码只能是同步的.所修改state属性的值得方法必须放在这里 setUserList(state,res){//修改state属性的值得方法，第一个参数必须是state，剩下的参数是调用该方法是传递的参数 state.userList = res.data console.log(state.userList) } }, actions:{//定义异步的代码，可以间接的修改state中的属性的值(即在actions中的方法中通过commit调用mutations中的方法来修改state属性值) getUserList(context){ //查询 axios.get('/api/find').then(res=&gt;{//向后台接口发送异步请求 context.commit('setUserList',res) }); }, delUserList(context,row){ //删除 axios.delete('/api/delUser',{ data:{ userId:row.userId } }).then(res=&gt;{ context.commit('setUserList',res.data) }).catch(e=&gt;{ console.log(e) }) } }, modules:{} }) 删除按钮 &lt;el-button size="mini" type="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/10a64ac843816fb5de284803cef8d51f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b2123ccba13fb19210f529c3e647020/" rel="bookmark">
			CAN总线详解（转载）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、简介
CAN是控制器局域网络(Controller Area Network, CAN)的简称，是一种能够实现分布式实时控制的串行通信网络。
优点：
传输速度最高到1Mbps，通信距离最远到10km，无损位仲裁机制，多主结构。近些年来，CAN控制器价格越来越低。
Ø 低成本：ECUs通过单个CAN接口进行通信，布线成本低。
Ø 高集成：CAN总线系统允许在所有ECUs上进行集中错误诊断和配置。
Ø 可靠性：该系统对子系统的故障和电磁干扰具有很强的鲁棒性，是汽车控制系统的理想选择。
Ø 高效率：可以通过id对消息进行优先级排序，以便最高优先级的id不被中断。
Ø 灵活性：每个ECU包含一个用于CAN总线收发芯片，随意添加CAN总线节点。
原文链接：https://blog.csdn.net/qq_31710263/article/details/97015748
CAN总线网络主要挂在CAN_H和CAN_L，各个节点通过这两条线实现信号的串行差分传输，为了避免信号的反射和干扰，还需要在CAN_H和CAN_L之间接上120欧姆的终端电阻。为什么是120Ω，因为电缆的特性阻抗为120Ω，为了模拟无限远的传输线 3、CAN收发器
CAN收发器的作用是负责逻辑电平和信号电平之间的转换。
即从CAN控制芯片输出逻辑电平到CAN收发器，然后经过CAN收发器内部转换将逻辑电平转换为差分信号输出到CAN总线上，CAN总线上的节点都可以决定自己是否需要总线上的数据。具体的引脚定义如下：
4、CAN信号表示
CAN总线采用不归零码位填充技术，也就是说CAN总线上的信号有两种不同的信号状态，分别是显性的(Dominant)逻辑0和隐形的(recessive)逻辑1，信号每一次传输完后不需要返回到逻辑0(显性)的电平。
显性与隐性电平的解释：
CAN的数据总线有两条，一条是黄色的CAN_High,一条是绿色的CAN_Low。当没有数据发送时，两条线的电平一样都为2.5V，称为静电平，也就是隐性电平。当有信号发送时，CAN_High的电平升高1V，即3.5V，CAN_Low的电平降低1V，即1.5V。
按照定义的：
CAN_H-CAN_L &lt; 0.5V 时候为隐性的，逻辑信号表现为"逻辑1"- 高电平。
CAN_H-CAN_L &gt; 0.9V 时候为显性的，逻辑信号表现为"逻辑0"- 低电平。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71db9d9822779d64be366bdde923e8a4/" rel="bookmark">
			vue2使用swiper制作轮播图 修改轮播图样式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		修改swiper轮播图基础样式：前进后退按钮或分页器样式
安装与使用swiper vue2项目只能使用swiper版本6及6以下，最稳定的版本5.4.5
npm install swiper@5.4.5 --save npm install vue-awesome-swiper@3.1.3 --save 1. 在文件中引入 import { swiper, swiperSlide } from "vue-awesome-swiper"; import "swiper/css/swiper.css"; export default { name: "", components: { swiper, swiperSlide }, } 2. 在文件中使用 &lt;div class="swiper-page"&gt;//设置轮播图外层基本样式：大小，背景颜色等 &lt;div class="container-list"&gt;//设置相对定位，用于定位左右箭头 &lt;swiper :options="swiperOptions"&gt; &lt;swiper-slide v-for="(item, index) in slideList" :key="index"&gt; &lt;div class="container"&gt; &lt;div&gt;{{ item.detail }}&lt;/div&gt; &lt;/div&gt; &lt;/swiper-slide&gt; &lt;/swiper&gt; //分页、左右箭头，样式名字需与配置项、css中类名相同 &lt;div class="swiper-pagination1" slot="pagination"&gt;&lt;/div&gt; &lt;div class="swiper-button-next1" slot="button-next"&gt;&lt;/div&gt; &lt;div class="swiper-button-prev1" slot="button-prev"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 分页、左右箭头放到外面表示可以放置在轮播图外面，但需要在最外层添加一层div，设置相对定位position: relative
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/71db9d9822779d64be366bdde923e8a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24d920141c5ccee1a7d19b0b37940df1/" rel="bookmark">
			堆内存溢出定位（Heap Dump）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		配置 jvm 参数，内存溢出时会自动HeapDump（指定 dump 文件路径是可选的）
-Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/home 或者用 jmap
jmap -dump:format=b,file=&lt;filename.hprof&gt; &lt;pid&gt; 必要时将dump文件从容器中拷贝到物理机
# docker cp &lt;container_name&gt;:&lt;container_path&gt; &lt;local_path&gt; docker cp 4d09feaf6483:/home/java_pid8.hprof /work # kubectl cp default/POD_NAME:bin/FILE_NAME /Users/username/FILE_NAME kubectl cp default/docker-sample-799db6c8d7-mqwww:/home/java_pid8.hprof /home/K8S/java_pid8.hprof MAT(Memory Analyzer Tool) 定位堆内存溢出问题 下载安装 MAT(Memory Analyzer Tool)，这个软件是 eclipse 基金会搞的。
打开 MAT -&gt; File -&gt; Open Heap Dump -&gt; 选择对应 .hprof 文件
点击查看 leak suspects（泄露嫌疑人），分析内存泄露
点击这个 Problem Suspect1 的 Details，在 Shortest Paths To the Accumulation Point （到达累积点的最短路径）点击 java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/24d920141c5ccee1a7d19b0b37940df1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad0814dec734356fb551c0a8caab8239/" rel="bookmark">
			python代码缩进
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.python中采用代码缩进和冒号“;”来区分代码支架的层次。
2.缩进可以使用空格（4格空格作为一个缩进量）或者tab键（一个tab键作为一个缩进量）实现
3.行尾的冒号和下一行的缩进表示一个代码块的开始，而缩进结束，则表示一个代码快的结束
4.同一级别的代码块的缩进量必须相同，如果不采用合理的代码缩进，将会出现SyntaxError异常
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9777edc3dc9c36334a432acc9f8cf375/" rel="bookmark">
			SPSS聚类分析（含k-均值聚类，系统聚类和二阶聚类）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇博客主要是根据 1、聚类的基本知识点_哔哩哔哩_bilibili系列视频进行的学习记录 一、SPSS聚类分析的基本知识点 1、什么是聚类分析? 聚类分析(Cluster analysis)又叫做群集分析,通过一些属性将对象或变量 分成不同的组别，在 同一类下的对象或变量在这些属性上具有一些相似的特点。 两种聚类类型 对个案（样品、对象、被试）进行分类——Q型聚类。 对变量进行分类——R型聚类。 或者换一种说法：
样本聚类又称Q型聚类，它针对实测量进行分类，将特征相近的实测量分为一类，特征差异较大的实察量分在不同的类。 变量聚类又称R型聚类，它针对变量分类，将性质相近的变量分为一类，将性质差异较大的变量分在不同的类。 例如：
对每一行进行聚类——Q型聚类 对每一列进行聚类——R型聚类（比如车重和油箱进行聚类） 2、SPSS聚类分析的方法。 (1） 快速聚类(k-均值聚类）:最简单的聚类方法，只能对 连续数据进行聚类，只能对样品进行聚类，适合 大样本聚类，不能自动确定类别数量。 (2） 系统聚类:可以对个案、变量进行聚类，可以对连续变量或分类变量进行聚类，适合样本容量较小的情况，不能自动确定类别数量。 (3) 二阶聚类:最 智能的聚类方法，可以对个案进行聚类，可以对 连续变量＋分类变量进行聚类，适合 大样本聚类， 能自动确定类别数量。 二、聚类分析的SPSS实操 1.k-均值聚类。 (1）操作要点。 首先把数据标准化。（SPSS： 分析-&gt;统计描述-&gt;描述） 聚类数:根据计算结果来定。 迭代数:可以改大一些。 保存:“聚类成员和"与"聚类中心的距离” 选项:“ANOVA”和“每个个案聚类信息” (2）结果解读: a、读最终聚类中心能够反映分出来的这两类的特点，可以自己起名字。 b、ANOVA显示两个或者多个类别的群体在聚类的各个变量上是否有差异，有差异说明聚类相对成功。 c、个案数显示两个或者多个类别的群体各有多少个被试。最好比较均匀，不要有类别太少。 (3)三线表的制作 SPSS步骤： 1. 数据标准化：分析-&gt;统计描述-&gt;描述 2. 分析-&gt;分类 -&gt; K-均值聚类 选变量、聚类数（多尝试几个）、迭代（次数大一些，比如99次）、保存（聚类变量、与聚类中心的距离）、选项（√ANOVA表——给出每个类别之间有没有差异，我们是希望不同类别之间是有差异的，√每个类别的聚类信息） 根据聚类中心我们看看能不能自己起名字 最终聚类中心
聚类
1
2
Zscore(Income)
.97179
-.51186
Zscore(Children)
-.45904
.24179
Zscore(Family_Quotient)
1.11281
-.58614
ANOVA
聚类
误差
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9777edc3dc9c36334a432acc9f8cf375/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d6c29c5f3dae1217e19aa0efe296b49/" rel="bookmark">
			python 出现 docx.opc.exceptions.PackageNotFoundError: Package not found at ‘./word源文件.docx‘ 的解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一个在jupyter环境中调试好的处理word文档的程序，重新放到.py文件中不行了，出现docx.opc.exceptions.PackageNotFoundError: Package not found at './word源文件.docx' 报错，很是纳闷，网上找到不少解决方法去试，都没有解决。
from docx import Document import datetime import pandas as pd doc = Document(r'word源文件.docx') 最后，我先打开vscode，然后选择打开 文件夹，在编辑器的边栏打开.py程序，程序正常运行了。
遇到此类问题的朋友可以试试。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ae65c02661362f11f7361c01288c9db/" rel="bookmark">
			压测时「数据库指标」不会看，没关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		测试：我压测的时候，主要要关注哪些日志或者指标信息？ 开发：服务资源、数据库、es、redis 长期沉迷于业务逻辑测试的我，突然就蒙圈了，数据库、es、redis虽然日常有大概知道那是「what」，但是现在要进行压测的时候，具体要观察数据库的“what”，还真是一头雾水～ 于是我就开始了一顿「知识恶补」和「不耻下问」的道路， 以下为个人工作过程实践总结，仅供分享学习～ NO1：了解数据库类型 数据库 类型 特点 Mysql 关系型数据库管理系统 作为数据的主数据库存储，存放持久化数据，读取速度慢 Elasticsearch （简称ES） 非关系型数据库 是一个实时的搜索引擎，使用场景：大数据量下的检索，数据分析，日志分析，实时、高并发低延迟的场景应用较多 Redis 非关系型的数据库 读取速度快，但不支持事务，关系复杂的场景不适用redis，可以用来配合关系型数据库做缓存，以及一些持久化数据，适用于一些高并发读写 NO2：了解公司内部数据库使用场景 了解负责的系统在不同场景下使用的数据库类型。 查询频率高且存在数据变动，主要存储在 Elasticsearch（ES）内 查询频率高但是数据基本不变，主要存储在redis内 mysql是主数据库 三者的数据关系如下： NO3. 数据库核心关注指标 CPU、内存使用率、磁盘占用空间 CPU、内存、磁盘这三项是能够看到的最直观的性能指标，也是数据库运行状态的整体体现。一旦数据库服务器这三项出现不正常的波动，必然会影响项目的稳定与性能。所以在进行性能压测时，首要关注的指标数据有这三个。 在个人近期的性能专项实践中，由于性能相关知识不够深和广，所以提前跟开发「确认」压测过程中重点「关注」并「记录」数据库的CPU、内存使用率2个指标，其中Redis 除了关注CPU、内存使用率还需要关注并记录缓存命中率 图为阿里云提供的Redis的性能基础数据 压测时记录：
1. MySQL：CPU使用率、内存使用率
2. ES：CPU使用率、内存使用率
3. Redis：CPU使用率、内存使用率、缓存命中率
将上面数据的截图记录下来，最后将多轮的压测数据量化，观察数据库的指标变化是否存在异常。
数据库的性能指标还有很多，例如连接池的使用、慢请求、key监控等等，这个就后续慢慢学习进步～ 努力的意义
当好运降临在自己身上时
你会觉得“我配”
而不是看着好事落在别人身上
然后愤愤地说“我呸”
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5af9bc4ec03468e663ad83d10e64842b/" rel="bookmark">
			安装mmvc、mmdet并测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
基本信息
服务器信息
版本选择
CUDA、Pytorch对应关系
mmvc、cuda、pytorch对应关系
MMDetection 和 MMCV 版本兼容性
安装
安装mmcv
安装 MMDetection
基本信息 服务器信息 （不知道为什么本地就是按不上）
镜像
PyTorch 1.8.1
Python 3.8
Cuda 11.1
GPU
RTX 3060 * 1
显存:12GB
CPU
7核 Intel(R) Xeon(R) CPU E5-2680 v4 @ 2.40GHz
内存:20GB
版本选择 CUDA、Pytorch对应关系 Previous PyTorch Versions | PyTorch
mmvc、cuda、pytorch对应关系 https://github.com/open-mmlab/mmcv#install-with-pip
Previous PyTorch Versions | PyTorch
本人选择cuda11.1+pytorch1.8（采用服务器可以选择不用安装）
conda install pytorch==1.8.0 torchvision==0.9.0 torchaudio==0.8.0 cudatoolkit=11.1 -c pytorch -c conda-forge MMDetection 和 MMCV 版本兼容性 mmdetection/get_started.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5af9bc4ec03468e663ad83d10e64842b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6cf0a3f6bbaacf236309e833a47ba7f0/" rel="bookmark">
			指令格式之定长操作码和扩展操作码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 学习来源:王道计算机考研 计算机组成原理 4.1指令格式
一.定长操作码 操作码长度固定,若操作码n位,可以表示2^n条指令
二.扩展操作码 这个例子假设地址码为4位,所以:
三地址指令 地址码共16种状态,留下1种
二地址指令 由于空出一个四位地址码,所以多了四位操作码的空间,共有1*2^4种状态,留下4种
一地址指令 又空出一个四位地址码,共有4*2^4=64种状态,留下2种
零地址指令 空出最后一个四位地址码,共2*2^4种状态
例题: 某计算机指令字长16位,地址码6位,指令有无地址,一地址,二地址共三种格式,设有N条二地址指令,有M条无地址指令,问一地址指令最多有多少条?
解析: ①二地址指令地址码共占用6+6=12位,所以剩余4位可以作为操作码,共有2^4=16种状态
题目给出二地址指令有N条,那么留下了(16-N)种状态给一地址指令扩展用
②零地址指令共M条,假设一地址指令留下了x种状态给零地址,那么x*2^6=M,得出x=M/2^6
综上可知,二地址指令最多有(16-N)*2^6-M/2^6条
更详细的解释: 假设指令字长为16位，操作数的地址码为6位，指令有零地址、一地址、二地址三种格式......
三.指令操作码总结 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/659c0aa4a60cbf2880f10c9c4e1196db/" rel="bookmark">
			蓝桥杯 python 最二数字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题描述
如果一个整数的某个数位包含 2 ，则称这个数为一个“最2数字”。例如：102、2021 都是最2数字。
请问在 1（含） 到 2021（含） 中，有多少个最2数字。
答案提交
这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。
​ans = 0 #定义全局变量记录“最2数字”个数 for i in range(1,2022): #遍历 a = str(i) #遍历的数字转换成字符串形式 if str(2) in a: #判断字符串里是否有2 ans +=1 print(ans) #输出564 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52b4bca0a594ac11a35c09bf5b6331b9/" rel="bookmark">
			R语言Bootstrap(自举法，自抽样法)估计回归置信区间分析股票收益
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近我们被客户要求撰写关于Bootstrap的研究报告，包括一些图形和统计输出。
介绍 假设你做了一个简单的回归，现在你有了你的 . 您想知道它是否与（例如）零显着不同。一般来说，人们会查看他们选择的软件报告的统计数据或 p.value。问题是，这个 p.value 计算依赖于因变量的分布。如果没有不同的说明，您的软件假定为正态分布，那是怎么回事？
相关视频：什么是Bootstrap自抽样及应用R语言线性回归预测置信区间实例 什么是Bootstrap自抽样及R语言Bootstrap线性回归预测置信区间
，时长05:38
例如，（95%）置信区间是 ,1.96 来自正态分布。
建议不要这样做，bootstrapping* 的优点在于它没有分布的问题，它适用于高斯、柯西或其他的分布。
40年前电脑计算速度很慢，现在不是了。你仍然可以保留你的分布假设，但至少要看看当你放松假设的时候会发生什么。做到这一点的方法是使用Bootstrap法，这个想法很直观和简单。
约翰-福克斯写道："总体对样本来说，就像样本对引导程序样本一样"。但这是什么意思呢？你对来自样本的估计​​，应该是对 "真实"​​，即总体的估计​​，而这是未知的。现在从样本中抽取一个样本，我们称这个样本为Bootstrap样本，根据这个（Bootstrap）样本来估计你的情况，现在这个新的估计是对你原来的估计​​，也就是来自原始数据的那个。为了清楚起见，假设你有3个观测值，第一个是{x=0.7,y=0.6}，第二个是{x=A,y=B}，第三个是{x=C,y=D}，现在，从样本中抽出的一个例子是洗牌排序：第一个是{x=A,y=B}，第二个是{x=0.7，y=0.6}，第三个是{什么什么}。这种 "洗牌 "就是我们所说的bootstrap样本，注意，任何观察值都可以被选择一次以上，或者根本不被选择，也就是说，我们是用替换法取样。现在我们再次估计同一统计量x=C,y=D​​​​​​​}。这种 "洗牌 "就是我们所说的bootstrap样本，注意，任何观察值都可以被选择一次以上，或者根本不被选择，也就是说，我们是用替换法取样。现在我们再次估计同一统计量​​​​​​​​​（在我们的例子中）。
​​​​​​​
重复这个样本和估计很多次，你就有了许多Bootstrap估计，现在你可以检查表现。你可以用它来做一件事，就是为你的估计值自举Bootstrap置信区间（CI），而不需要基本的分布假设。
在 R
在 R 中，“boot”包可以解决问题：
library #加载软件包 # 现在我们需要我们想要估计的函数 # 在我们的例子中，是β。 bfun = function(da,b,fola){ # b是bootstrap样本的随机指数 return(lm$coef[2]) # 这是对β系数的解释 } # 现在你可以进行自举了。 bt = boot # R是多少个bootstrap样本 plot hist 您可以放大在每个bootstrap程序中选择了哪些索引，确切的排列是什么，可以使用函数 bay 来做到这一点：
zot = boot.array dim(zo) # 大小应该是R(bootstrap样本数)乘以n(你的数据的NROW) hist # 这是每一个指数的频率，对于第一个bootstrap运行，所以在这个直方图中，一个Y值比如说是3 #意味着在这个特定的bootstrap样本中，X值观察被选择了3次 自己编写代码 ​​​​​​​如果您可以自己编写代码，就可以更好地理解它，对于像bootstrap置信区间这样的简单问题，它更加简单和快捷：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/52b4bca0a594ac11a35c09bf5b6331b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c97803bacb2bd6fe40bc05f91ffde3dd/" rel="bookmark">
			【正本清源】Synchronized 源码全解之偏向锁的获取（基于 Openjdk12）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 BasicObjectLockBasicLockoopDescmarkOopDesc偏向锁偏向锁的获取 monitorenter源码验证(bytecodeInterpreter.cpp) 基于 hotspot 源码深度解析 Synchronized 偏向锁原理。欢迎友好交流，最好附带源码作为论据。 BasicObjectLock 包装了锁对象的头部和锁对象的引用。
class BasicObjectLock { friend class VMStructs; private: // 保存了被替换下来的对象的头部 BasicLock _lock; // the lock, must be double word aligned // oop java 对象的引用 // typedef class oopDesc* oop; oop _obj; // object holds the lock; public: // Manipulation oop obj() const { return _obj; } void set_obj(oop obj) { _obj = obj; } BasicLock* lock() { return &amp;_lock; } static int size() { return sizeof(BasicObjectLock)/wordSize; } void oops_do(OopClosure* f) { f-&gt;do_oop(&amp;_obj); } static int obj_offset_in_bytes() { return offset_of(BasicObjectLock, _obj); } static int lock_offset_in_bytes() { return offset_of(BasicObjectLock, _lock); } }; BasicLock class BasicLock { friend class VMStructs; friend class JVMCIVMStructs; private: volatile markOop _displaced_header; // 被替换下来的对象头部 public: markOop displaced_header() const { return _displaced_header; } void set_displaced_header(markOop header) { _displaced_header = header; } void print_on(outputStream* st) const; void move_to(oop obj, BasicLock* dest); static int displaced_header_offset_in_bytes() { return offset_of(BasicLock, _displaced_header); } }; oopDesc hotspot/src/share/vm/oops/oop.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c97803bacb2bd6fe40bc05f91ffde3dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84e0ee0ad0a0a1cebb363b459acc305c/" rel="bookmark">
			前端实现简单SQL语句的增删改查----入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.增 insert 向数据库中插入新的数据 使用set里设置新数据的值,没有顺序关系 insert into student set age=30,sex="男",username='李青'
2.删 delete 从数据库中删除数据 # 删除一条数据 delete from student where id=11
# 删除满足条件的数据 delete from student where id&gt;6
# 没有指定条件,删除全部数据 delete from student
3.改 update 更新数据库中的数据 语法:update 表名 set 字段1=值1,字段2=值2,...where修改条件 注意:一定要加where条件,不然就是全部修改
update student set age=20,sex="女" where id=11
不加条件,则是全部修改,比如把所有人的年龄+1
update student set age = age + 1
4.查 select 从数据库中查询数据 基本语法:select 字段1,字段2,...form 表名 #1 查询所有学生表的全部信息
select * from student
#2 查询所有学生的姓名和年龄
select username,age from student
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/84e0ee0ad0a0a1cebb363b459acc305c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ff7b90d8e00f3164fddb1c919d7ef1f/" rel="bookmark">
			mybatis常用的3种批量更新方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方案一(个人推荐)
使用dual虚拟表,将需要更新的数据当做一张表,然后通过join来达到批量更新的目的
&lt;update id="updateDeviceStatusBatch"&gt;
update deviceinfo
join (
&lt;foreach collection="list" item="item" separator=" union all "&gt;
SELECT #{item.serialno} as serialno, #{item.lastLongitude} as lastLongitude, #{item.lastLatitude} as lastLatitude,
#{item.updateDate} as update_date,#{item.iccd} AS iccd,#{item.simNo} AS version FROM dual
&lt;/foreach&gt;
) b
on b.serialno = deviceinfo.serialNo
set deviceinfo.lastLongitude = (case when b.lastLongitude is null then deviceinfo.lastLongitude else b.lastLongitude end),
deviceinfo.lastLatitude = (case when b.lastLatitude is null then deviceinfo.lastLatitude else b.lastLatitude end),
deviceinfo.update_by = b.update_by,
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ff7b90d8e00f3164fddb1c919d7ef1f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06776519ea2602cae09ad6e89168867f/" rel="bookmark">
			在CentOS 7.7 x86_64上从python3安装pip3
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		线上发现一台服务器只安装python 3.7.3，但是没有安装pip3，这样就无法安装Python的各种包，分析是从二进制包安装的，并不完整。如果从python的源码包安装的话，默认是包含pip3的。
问题：
有python 3.7但是没有pip3，如何安装pip3呢？
解决方法：
下载下面的脚本
wget https://bootstrap.pypa.io/get-pip.py
python3 get-pip.py
测试
pip3 -V
pip 20.3.4 from /usr/local/lib/python3.7/site-packages/pip (python 3.7)
which pip3
/usr/local/bin/pip3
python3 -V
Python 3.7.3
which python3
/usr/local/bin/python3
现在就可以愉快地通过pip3安装各种python包了.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b20b6a817e90eafa9100e667939d693/" rel="bookmark">
			[golang Web开发] 5.golang web开发:会话控制(Cookie,Session),处理静态资源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http是无状态协议,服务器不能记录浏览器的访问状态，也就是说服务器不能区分中两次请求是否由一个客户端发出.这样的设计严重阻碍的 Web 程序的设计,如：在进行网购时，买了一条裤子，又买了一个手机,由于 http协议是无状态的，如果不通过其他手段,服务器是不能知道用户到底买了什么,而cookie就是解决方案之一.
一.Cookie 1.简介 Cookie 实际上就是服务器保存在浏览器上的一段信息,浏览器有了Cookie之后，每次向服务器发送请求时都会同时将该信息发送给服务器，服务器收到请求后，就可以根据该信息处理请求
Cookie类型如下: 2.cookie的运行原理 (1).第一次向服务器发送请求时在服务器端创建 Cookie
(2).将在服务器端创建的Cookie以响应头的方式发送给浏览器
(3).以后再发送请求时,浏览器就会携带着该Cookie
(4).服务器得到Cookie之后根据Cookie的信息来区分不同的用户
3.创建cookie并将它发送给浏览器 4.获取cookie 5.cookie的用途 (1).广告推荐
(2).免登录
二.Session 1.简介 Cookie有一个非常大的局限，就是如果Cookie 很多，则无形的增加了客户端与服务端的数据传输量,而且由于浏览器对Cookie 数量的限制，注定不能在Cookie 中保存过多的信息,于是 Session 出现
Session的作用就是在服务器端保存一些用户的数据，然后传递给用户一个特殊的 Cookie, 这个Cookie对应着这个服务器中的一个Session,通过它就可以获取到保存用户信息的 Session ，进而就知道是哪个用户在发送请求
当然，由于 Session 存储在服务器中，肯定会消耗服务器的资源，所以 Session 一般都会有一个过期时间，服务器一般会定期检查并删除过期的 Session ，如果后来该用户再次访问服务器，可能就会面临重新登录等等措施，然后服务器新建一个 Session ，将 Session ID 通过 Cookie 的形式传送给客户端
2.运行原理 (1).第一次向服务器发送请求时创建Session,给它设置一个全局唯一的 ID （可以通过 UUID 生成）
(2).创建一个Cookie,将Cookie 的Value 设置为 Session 的ID值，并将 Cookie 发送给浏览器 · (3).以后再发送请求浏览器就会携带着该 Cookie
(4).服务器获取Cookie并根据它的 Value 值找到服务器中对应的 Session,也就知道了请求是哪个用户发的
3.实现 Session一般需要三个组件配合完成，它们分别是 Manager、Provider 和 Session 三个类（接口）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b20b6a817e90eafa9100e667939d693/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ef019fcfd2f63454529479d019aa78f/" rel="bookmark">
			anaconda安装时候报错：File or directory already exists
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述： Anaconda3 will now be installed into this location:
/home/LIST_2080Ti/anaconda3
- Press ENTER to confirm the location
- Press CTRL-C to abort the installation
- Or specify a different location below
[/home/LIST_2080Ti/anaconda3] &gt;&gt;&gt; /home/LIST_2080Ti/njh/anaconda3
ERROR: File or directory already exists: '/home/LIST_2080Ti/njh/anaconda3'
If you want to update an existing installation, use the -u option.
解决方案： 其实你只要把你文件夹里的那个anaconda3文件夹删除就行了。
因为我想把anaconda3建在自己的文件夹之下。所以需要修改一下路径。
而自己设定路径的时候，必须随便设置一个没有的文件夹才行。
比如你的文件目录是这样的：/home/LIST_2080Ti/njh/anaconda3
你需要把你的文件目录中的最后一层删掉，而在设定路径的时候设置为：
/home/LIST_2080Ti/njh/anaconda3即可。
如下图所示，
删掉你的目录里面的anaconda3文件夹，而在右面的地址设定时候保留即可。 参考文章：
anaconda安装出现directory 路径 already exits问题应该这么办_KryHan的博客-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e5354a0ace3baa8618536321e271510/" rel="bookmark">
			unity3d调用安卓java
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、unity3d调用java
unity里面想要获取安卓设备的唯一ID，必须通过原生的java接口来获取。
首先创建一个安卓库文件工程，里面新建一个java类，并从UnityPlayerMainActivity类派生，如下代码所示：
public class AndroidPlugin extends UnityPlayerMainActivity { private static String unitygameobjectName = "_main"; //Unity 中对应挂脚本对象的名称 private static AndroidPlugin thisActivity=null; public final static int FILECHOOSER_RESULTCODE = 19238467; protected static ValueCallback&lt;Uri&gt; _uploadMessages; protected static ValueCallback&lt;Uri[]&gt; _uploadCallback; protected static String _cameraPhotoPath; protected static final String LOG_TAG = "AndroidPlugin"; private static final String TAG = "AndroidPlugin"; private int _textureId = 0; private SurfaceTexture _surfaceTexture; private IjkMediaPlayer player = null; private Texture2DExt mTexture2DExt; private Texture2D mUnityTexture; private FBO mFBO; private float[] mMVPMatrix = new float[16]; private MyPluginCallbackListener _listener; public static Activity getUnityActivity_() { return thisActivity;//UnityPlayer.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e5354a0ace3baa8618536321e271510/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22688ace540b779e5c2063c72ca7a997/" rel="bookmark">
			Selenium4.0&#43;Python3系列（二） - 元素定位那些事
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、写在前面 今天一实习生小孩问我，说哥你自动化学了多久才会的，咋学的？
自学三个月吧，真的是硬磕呀，当时没人给讲😅！
其实，学什么都一样，真的就是你想改变的决心有多强罢了。
二、元素定位 这部分内容可以说是重中之重了，也是大部分写web自动化的同学，必会入门技能之一了。
1、常见八种定位元素方法 我们还是直接来看源代码吧，示例如下：
# Licensed to the Software Freedom Conservancy (SFC) under one # or more contributor license agreements. See the NOTICE file # distributed with this work for additional information # regarding copyright ownership. The SFC licenses this file # to you under the Apache License, Version 2.0 (the # "License"); you may not use this file except in compliance # with the License.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/22688ace540b779e5c2063c72ca7a997/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7a98fdaab19c6afa740bf0ccb3c2f13/" rel="bookmark">
			Spring Boot 整合 Canal
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 canal 是阿里巴巴旗下的一款开源项目，纯Java开发。基于数据库增量日志解析，提供增量数据订阅&amp;消费，目前主要支持了MySQL（也支持mariaDB）。
canal [kə’næl]，译意为水道/管道/沟渠，主要用途是基于 MySQL 数据库增量日志解析，提供增量数据订阅和消费。
基于日志增量订阅和消费的业务包括
数据库镜像数据库实时备份索引构建和实时维护(拆分异构索引、倒排索引等)业务 cache 刷新带业务逻辑的增量数据处理 当前的 canal 支持源端 MySQL 版本包括 5.1.x , 5.5.x , 5.6.x , 5.7.x , 8.0.x
Canal工作原理 Canal工作原理
canal 模拟 MySQL slave 的交互协议，伪装自己为 MySQL slave ，向 MySQL master 发送 dump
协议。MySQL master 收到 dump 请求，开始推送 binary log 给 slave (即 canal )。canal 解析 binary log 对象(原始为 byte 流)。 Canal架构 server 代表一个 canal 运行实例，对应于一个 jvminstance 对应于一个数据队列 （1个 canal server 对应 1…n 个 instance )instance 下的子模块：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a7a98fdaab19c6afa740bf0ccb3c2f13/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7ba0ea67ae7e4741363f3f60f91143e/" rel="bookmark">
			ubuntu设置默认内核启动的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文介绍ubuntu设置默认内核启动的方法。
参考如下图，修改grub文件：
修改后，执行：sudo update-grub &amp;&amp; reboot
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12ef35a3f5f23f0a9abbd3b7d3e435c2/" rel="bookmark">
			用vue制作一个返回顶部div，在顶部时该div隐藏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 &lt;template&gt; &lt;div class="back-to-top" v-show="showBackToTop" @click="backToTop"&gt; 返回顶部 &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { showBackToTop: false, }; }, mounted() { window.addEventListener("scroll", this.handleScroll); }, methods: { handleScroll() { if (window.scrollY &gt; window.innerHeight / 2) { this.showBackToTop = true; } else { this.showBackToTop = false; } }, backToTop() { window.scrollTo({ top: 0, behavior: "smooth" }); }, }, }; &lt;/script&gt; &lt;style&gt; .back-to-top { position: fixed; bottom: 20px; right: 20px; background-color: lightgray; padding: 10px 20px; cursor: pointer; } &lt;/style&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d39c3bd226a7c2a98afd6b013426ed58/" rel="bookmark">
			青龙&#43;WxPusher实现资产推送
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.首先注册WXpusher：
https://wxpusher.zjiecode.com/admin/login
扫码注册创建应用
确定完就会出现一个token，一定先复制保存起来，因为只显示一次，没存后期就只能重置了。
关闭后，这个页面有二维码和链接，链接是长期固定的（不建议往外发），二维码是临时的，可以发给要接收通知的人，他们关注下这个号，允许接收通知即可。
接收的人关注之后会在你这个应用的 用户管理-用户列表 里展示出来
WxPusher配置就可以了，下面开始配置青龙
我这里用的是KR的库
在面板配置变量：
WP_APP_TOKEN_ONE 然后执行任务报错：notify.sendNotifybyWxPucher is not a function!
这里的报错 是说 notify中的 sendNotifybyWxPucher这个方法没找到，所以找到对应的notify文件如下notify 是当前目录的sendNotify 文件，去找对应的sendNotify文件 在 sendNotify文件中搜索sendNotifybyWxPucher 方法，发现没有
于是去脚本的开源出找到 sendNotify.js 文件，发现KR提供的版本中是有这个sendNotifybyWxPucher方法的，于是将其内容替换为最新版：https://github.com/KingRan/KR/blob/main/sendNotify.js
sendNotify中是需要读取对应的CK_WxPusherUid.json 文件
跟着一步步找，发现需要读取文件中的 pt_pin 和 Uid两个值
所以在ql/data/scripts 下增加文件：CK_WxPusherUid.json
文件内容：
[ { "pt_pin": "JD_COOKIE中的pt_pin=的值不包含';'", "Uid": "WxPusher用户ID自行百度" } ] 拉库任务中取消拉 sendNotify
将 sendNotify | 删除掉
如果还是会覆盖就重新建两个js文件
new_bean_change_pro.js文件
将 kR 库的 jd_bean_change_pro.js 文件内容复制过去
然后把下面的 sendNotify 改为 newsendNotify
然后新建 newsendNotify.js 文件
找到 最新版的 sendNotify.js 文件将其内容复制进去
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d39c3bd226a7c2a98afd6b013426ed58/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ddd3891d7e813f48d945691e660cbd2/" rel="bookmark">
			|，&amp;与||，&amp;&amp;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从运算符种类来看，两者是完全不同的运算符。
||是逻辑运算符，表示逻辑或；
&amp;&amp;是逻辑运算符，表示逻辑与；
|是位运算符，表示按位或；
&amp;是位运算符，表示按位与。
逻辑运算符的优先级比位运算符优先级低。
逻辑表达式和位运算表达式具体的表达式值不一样，位运算顾名思义是要先把数换算为二进制然后进行|或&amp;运算，逻辑则直接进行。
if,while,for等条件判断，必须使用逻辑运算符，因为逻辑运算符，顾名思义，本来就是用来逻辑判断，符合语义，提高代码可读性，避免出错。
C语言没有布尔逻辑类型true和false，使用非0表示真，0值表示假，导致了逻辑判断无法类型检查，任何表达式值都可以作为逻辑判断，当出现混用时，无法提示，因此务必小心。
0 | 2 = 2 // 条件判断为真，但是值却不一样
0 || 2 = 1 // 条件判断为真，但是值却不一样
1 &amp; 2 = 0 // 条件判断为假
首先，将里面的数字换成2进制：1的2进制为001（或者0001等）；2的2进制为010（或者001等0）
然后，按照逻辑运算计算：
001 0001
&amp; 010 &amp; 0010
_______ _______
000 0000
最后，将所得的结果再换成10进制数，就得到答案 0
1 &amp;&amp; 2 = 1 // 此时条件判断为真
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb8388ae655ad101b9d92000dfc27723/" rel="bookmark">
			类实例化记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include &lt;iostream&gt; using namespace std; class complex{ public: complex();//无参构造函数，一个类中可以有多个构造函数 complex(double real, double imag); public: //声明运算符重载 complex operator+(const complex &amp;A) const; //Const表示参数不会变化 void display() const; private: double m_real; //实部 double m_imag; //虚部 }; complex::complex(): m_real(0.0), m_imag(0.0){ } //无参构造函数定义，初始化列表的定义方式 complex::complex(double real, double imag): m_real(real), m_imag(imag){ }//有参构造函数定义 //实现运算符重载 complex complex::operator+(const complex &amp;A) const{ complex B; B.m_real = this-&gt;m_real + A.m_real; B.m_imag = this-&gt;m_imag + A.m_imag; return B; } void complex::display() const{ cout&lt;&lt;m_real&lt;&lt;" + "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb8388ae655ad101b9d92000dfc27723/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/213038ee09b178aea6e208170cfa7b9b/" rel="bookmark">
			Python-Sklearn内置数据集介绍与“三板斧”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python-Sklearn内置数据集介绍与“三板斧” 前言一、sklearn相关介绍1. sklearn简介2. sklearn基本操作 二、鸢尾花数据集（iris）1. 数据集相关介绍2. 导入iris数据集，加载数据3. 查看数据集基本信息相关操作4. 转化数据框，生成表格 三、波士顿房价数据集（boston）1. 数据集相关介绍2. 导入boston数据集，加载数据3. 查看数据集基本信息相关操作4. 转化数据框，生成表格 四、手写数字数据集（digits）1. 数据集相关介绍2. 导入digits数据集，加载数据3. 查看数据集基本信息相关操作4. 矩阵可视化,显示图片 五、sklearn“三板斧”1. 实例化举例• Modelclass中基本通用方法2. fit举例3. fit_transform举例fit_predict举例 六、模型的保存（持久化）七、查找文件储存位置os 前言 上学期学习了专业课数据挖掘，打算利用寒假时间在CSDN上复习整理数据挖掘的相关笔记进行复习巩固相关理论与代码，与下学期的机器学习相结合。在这里想和大家一起学习一起进步。
首先对sklearn中的内置数据集进行了解，以鸢尾花数据集（iris）和波士顿房价数据集（boston）以及手写数字数据集（digits）为例，学习查看sklearn中自带数据集的相关概论以及数据预处理。接下来将对这几个数据集做相关处理。
一、sklearn相关介绍 1. sklearn简介 sklearn是scikit-learn的简称，是基于 Python 语言的第三方模块，是简单高效的数据挖掘和数据分析工具。sklearn库集成了一些常用的机器学习方法 ，在进行机器学习任务时，并不需要实现算法，只需要简单的调用sklearn库中提供的模块就能完成大多数的机器学习任务。因此我认为sklearn可以比喻成一个调包侠，我们需要理解并熟练运用有关代码。sklearn库是在Numpy、Scipy和matplotib的基础 上开发而成的，因此在介绍sklearn的安装前，需要先安装这些依赖库。 2. sklearn基本操作 scikit-learn分别为6大类：
• 分类Classification
• 回归Regression
• 聚类Clustering
• 降维Dimensionality reduction
• 模型选择Model selection
• 数据预处理Preprocessing
二、鸢尾花数据集（iris） 1. 数据集相关介绍 • iris鸢尾花数据集,分类数据集，查看内置数据集
• 因变量：Iris-Setosa刚毛鸢尾花；Iris-Versicolour变色鸢尾花；Iris-Virginica佛吉尼亚鸢尾花
• 自变量：萼片长度（cm）；萼片宽度（cm）；花瓣长度（cm）；花瓣宽度（cm）
2. 导入iris数据集，加载数据 import sklearn#导入sklearn包 from sklearn.datasets import load_iris#导入自带iris数据集集,iris数据集分类问题 iris = load_iris()#导入iris数据集，加载数据 #iris 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/213038ee09b178aea6e208170cfa7b9b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2295b8217a8933946cdb927590efd341/" rel="bookmark">
			Python-sklearn数据预处理（单/多个数据集数据标准化、稳健标准化、缺失值填补）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python-sklearn数据预处理（单/多个数据集数据标准化、稳健标准化、缺失值填补） 前言一、 三板斧1. 概念2.实操代码（1）导入boston数据集（2）三板斧举例 二、数值型变量的标准化1.概念2.实操代码(1)对`单个数据集`进行标准化(2)在`多个数据集`上使用相同的标准化变换(3)将特征变量缩放至特定范围(4)数据的正则化—求单位向量(5)考虑异常值标准化—稳健标准化 三、缺失值的填补 前言 hello大家好这里是小L😊，上一篇简单地介绍sklearn相关概念以及其常见的三个内置数据集（iris、boston、digits），对sklearn内置数据集有一定了解🙌
这次笔记内容:简单复习上篇笔记sklearn三板斧（具体可看上一篇笔记），学习sklearn数据预处理部分👉其中包括不同情况下的数据标准化以及遇到异常值或缺失值情况该如何对数据进行处理👈数据集用sklearn内置数据及进行举例🌷。
小L希望可以在这里与大家一起进步！💪
一、 三板斧 1. 概念 三板斧分为三个步骤：实例化–&gt;fit 拟合–&gt;transform转化 or Predict预测，我的理解是选择/构建模型-&gt;训练模型-&gt;将新数据集放入训练好的模型中。就好比把大象放入冰箱需要三个步骤：打开冰箱–&gt;把大象放入冰箱–&gt;关闭冰箱门。
2.实操代码 （1）导入boston数据集 导入boston数据集 from sklearn.datasets import load_boston boston=load_boston() 转化为数据框 import pandas as pd boston_df = pd.DataFrame(boston.data,columns=boston.feature_names) boston_df （2）三板斧举例 数据预处理 from sklearn.preprocessing import StandardScaler#预处理（可去除量缸影响） std= StandardScaler(with_mean=False)#实例化 std.fit(boston.data)#训练 std.transform(boston.data)#转化或预测predict 在模型了解这块有两个小tip🙋
🚩利用help()可进行模型查询，里面会进行对查询模型的详细解答，可着重查看Parameters参数部分，部分结果如图。例如：
help(StandardScaler) #模型查询 🚩在实例化后查看、设置模型参数
from sklearn.preprocessing import StandardScaler std =StandardScaler() std.get_params()#查看当前参数 std.set_params(copy=False)#设置参数值 std.get_params()#再次查看参数 设置好参数后进行模型训练
std.fit(boston.data) 最后结果
std.scale_#boston有13个特征 std.mean_#标准化后的期望 boston_df.describe() 岭回归 from sklearn .linear_model import Ridge#岭回归 ridge = Ridge() ridge.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2295b8217a8933946cdb927590efd341/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34307a7087030aceaf4593826c4b0b67/" rel="bookmark">
			Mysql和ES数据同步方案汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在实际项目开发中，我们经常将Mysql作为业务数据库，ES作为查询数据库，用来实现读写分离，缓解Mysql数据库的查询压力，应对海量数据的复杂查询。这其中有一个很重要的问题，就是如何实现Mysql数据库和ES的数据同步，今天和大家聊聊Mysql和ES数据同步的各种方案。
一、Mysql和ES各自的特点 为什么选用Mysql MySQL 在关系型数据库历史上并没有特别优势的位置，Oracle/DB2/PostgreSQL(Ingres) 三老比 MySQL 开发早了 20 来年, 但是乘着 2000 年的互联网东风, LAMP 架构得到迅速的使用，特别在中国，大部分新兴企业的 IT 系统主数据沉淀于 MySQL 中。
核心特点：开源免费、高并发、稳定、支持事务、支持SQL查询
高并发能力：MySQL 内核特征特别适合高并发简单 SQL 操作 ，链接轻量化(线程模式)，优化器、执行器、事务引擎相对简单粗暴，存储引擎做得比较细致
稳定性好：主数据库最大的要求就是稳定、不丢数据，MySQL 内核特征反倒让其特点鲜明，从而达到很好的稳定性，主备系统也很早就 ready ,应对崩溃情况下的快速切换，innodb 存储引擎也保障了 MySQL 下盘稳定
操作便捷：良好、便捷的用户体验(相比 PostgreSQL) , 让应用开发者非常容易上手 ,学习成本较低
开源生态：MySQL 是一款开源产品，让上下游厂商围绕其构建工具相对简单，HAproxy、分库分表中间件让其实用性大大加强，同时开源的特质让其有大量的用户
为什么选用 ES ES 几个显著的特点，能够有效补足 MySQL 在企业级数据操作场景的缺陷，而这也是我们将其选择作为下游数据源重要原因
核心特点：支持分词检索，多维筛选性能好，支持海量数据查询文本搜索能力：ES 是基于倒排索引实现的搜索系统，配合多样的分词器，在文本模糊匹配搜索上表现得比较好，业务场景广泛多维筛选性能好：亿级规模数据使用宽表预构建(消除 join)，配合全字段索引，使 ES 在多维筛选能力上具备压倒性优势，而这个能力是诸如
CRM, BOSS, MIS 等企业运营系统核心诉求，加上文本搜索能力，独此一家开源和商业并行：ES
开源生态非常活跃，具备大量的用户群体，同时其背后也有独立的商业公司支撑，而这让用户根据自身特点有了更加多样、渐进的选择 二、数据同步方案 1.同步双写 这是一种最为简单的方式，在将数据写到mysql时，同时将数据写到ES。
伪代码：
/** * 新增商品 */ @Transactional(rollbackFor = Exception.class) public void addGoods(GoodsDto goodsDto) { //1、保存Mysql Goods goods = new Goods(); BeanUtils.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/34307a7087030aceaf4593826c4b0b67/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bdc5913026c6aed5f67a60ade88d43bc/" rel="bookmark">
			linux 常用操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、查找、显示、比较
1、查找 source* 文件，在 xxx 查找 xxx
2、在终端显示文件第10行
3、比较两个文件内容的差别
二、进程
1、查看进程
2、杀死进程
3、前后台切换 ctrl+z、&amp;、jobs、fg、bg
4、文件描述符
三、网络
1、查看网络ip、网关
2、查看端口被进程使用情况
3、配置网络
四、更新、下载
1、修改源，更新本地软件列表
2、查找、下载、卸载
五、环境变量
1、临时添加环境变量
2、永久添加环境变量
六、服务操作
七、解包解压、压缩打包
八、创建用户
九、防火墙
一、查找、显示、比较 1、查找 source* 文件，在 xxx 查找 xxx sudo find . -maxdepth 4 -name "sources*" # 从当前目录开始，最大深度4，查找 source* 文件 find * | grep source* # 在所有子目录下搜索 source* find /etc | grep source* 2、在终端显示文件第10行 head -10 | tail -1 # 第10行：前10行的最后一行 3、比较两个文件内容的差别 diff file1 file2 二、进程 1、查看进程 ps aux # 查看所有正在执行的进程 ps ajx # j显示父id ps ax # 显示 ps a # 显示当前文件夹下正在执行的进程 2、杀死进程 kill [pid] kill -9 [pid] // 强制杀死 kill -9 [-pid] // 杀死进程组 3、前后台切换 ctrl+z、&amp;、jobs、fg、bg .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bdc5913026c6aed5f67a60ade88d43bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/884cd5b1b372f1fb5f6ea0b02b658fbe/" rel="bookmark">
			testbench常用语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		与可综合Verilog代码所不同的是，testbench Verilog是在计算机主机上的仿真器中执行的。testbench Verilog的许多构造与C语言相似，我们可在代码中包括复杂的语言结构和顺序语句的算法。
1 always块和initial块
Verilog有两种进程语句：always块和initial块。always块内的进程语句，可用来模拟抽象的电路。
出于模拟的目的，always块可以包括：用以指定与不同结构之间的传播延迟等同的时序结构；或等待指定事件的时序结构。敏感列表有时可忽略。比方说，我们用下面的代码片段来模拟时钟信号，该信号每20个时间单位在0~1间变换一次，且永远执行下去。
always
begin
clk=1;
#20;
clk=0;
#20);
end
initial块内也有进程语句，但是仅在仿真之初被执行。其简单语法如下：
initial
begin
进程语句;
end
initail块常用于设置变量的初始值。注意，initial块不可被综合。
2 进程语句
进程语句应用于initial块、always块、function和task之中。最常用的进程语句为：
· 阻塞赋值
· 非阻塞赋值
· if表达式
· case表达式
· 循环表达式
我们讨论过阻塞和阻塞赋值，if和case语句。
Verilog支持的循环结构有：for、while、repeat和forever。for循环的简单语法为：
for([initial_assignment]; [end_condition]; [step_assignment])
begin
[procedural_statements;]
end
举个例子，我们可以使用下面的语句来清除16位寄存器文件的内容：
integer i;
. . .
for(i=0; i&lt;16; i=i+1)
reg_file[i]=0;
注意当循环体内只有一条语句的话，begin和end限定词可以略去。
while循环的简单语法如下：
while([end_condition])
begin
[procedural_statements;]
end
循环体内的语句连续重复执行，直到达到指定的终止条件[end_condition]为止。比方说上面的清寄存器文件的操作可以使用while循环来描述：
integer i;
. . .
while(i&lt;16)
begin
reg_file[i]=0;
i=i+1;
en
repeat循环的简单语法如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/884cd5b1b372f1fb5f6ea0b02b658fbe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01f42597711277d85babf4986e321c96/" rel="bookmark">
			解决UOS缺少term.h和curses.h的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近因信创换成了UOS，学习Linux，遇到问题
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;curses.h&gt;
#include &lt;term.h&gt;
int main()
{
int nrows,ncolumns;
setupterm(NULL,fileno(stdout),(int *)0);
nrows=tigetnum(“lines”);
ncolumns=tigetnum(“cols”);
printf(“This terminal has %d columns and %d row\n”);
exit(0);
}
编译 gcc -o testterm testterm.c
提示缺少 &lt;curses.h&gt;和&lt;term.h&gt;，经检查/usr/include，确实没有这两个库，于是进行安装libncurses-dev
sudo apt-get install libncurses5-dev
请输入密码:
验证成功
正在读取软件包列表… 完成
正在分析软件包的依赖关系树
正在读取状态信息… 完成
将会同时安装下列软件：
libncurses-dev
…
完成后，重新编译，提示新的错误
undefined reference to setupterm' undefined reference to tigetnum’
…
collect2: error: ld returned 1 exit status
因为不是标准库，需要修改编译命令，加-l，即
gcc -o testterm testterm.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/01f42597711277d85babf4986e321c96/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f30964c736ca8eb014148a4c9391bb2/" rel="bookmark">
			Idea热加载插件JRebel激活及使用教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在 Java 开发领域，热部署一直是一个难以解决的问题，目前的 Java 虚拟机只能实现方法体的修改热部署，例如使用devtool来实现热部署，但是在功能上它也有所限制，如果新增方法或者修改方法参数后，热部署是不生效的。因此对于整个类的结构修改，仍然需要重启虚拟机，对类重新加载才能完成更新操作。对于某些大型的应用来说，每次的重启都需要花费大量的时间成本。
因此，在这里为大家带来一款Idea集成的热加载插件-JRbel。但是这个插件是需要收费的，故在这里为大家带来激活使用的详细教程，手把手教学一波。亲测可用！
Jrbel插件下载 首先在Idea中找到setting-&gt;plugins，在MarketPlace中搜索该插件。
点击“应用”后，按要求重启一下Idea，使下载的Jrebel插件生效。
这个时候在Idea主界面侧边栏上就有Jrebel的安装指南出现了。
然后我们根据Jrebel的安装指南进行安装即可。
激活Jrebel 安装第一步就需要对Jrebel进行激活，这里笔者推荐第一种激活方式。
然后我们需要配置license server地址，这里我们通过一个JrebelBrainsLicenseServerforJava的激活jar包来实现，通过将jar包放在服务器上运行，然后就可以通过我们自己的服务器来作为license server地址了。jar报地址来源于链接: https://pan.baidu.com/s/1rrn-6F26JpD5RSsbJV3-hQ 密码: dscu。也可以在笔者资源里自行获取。
如果放在服务器上，特别是腾讯云，阿里云之类的，记得开放服务器防火墙，安全组策略以及Linux系统防火墙上的1008端口。没有服务器也不要紧，用自己电脑也可。只不过不能一直把jar包运行着。
通过java的命令运行jar包。
java -jar JrebelBrainsLicenseServerforJava-1.0-SNAPSHOT-jar-with-dependencies.jar -p 1008 &amp; C:\Users\young\Desktop\开源工具集&gt;java -jar JrebelBrainsLicenseServerforJava-1.0-SNAPSHOT-jar-with-dependencies.jar -p 1008 &amp; 2023-02-05 11:00:30.612:INFO:oejs.Server:jetty-8.y.z-SNAPSHOT 2023-02-05 11:00:31.107:INFO:oejs.AbstractConnector:Started SelectChannelConnector@0.0.0.0:1008 License Server started at http://localhost:1008 JetBrains Activation address was: http://localhost:1008/ JRebel Activation address was: http://localhost:1008/{tokenname}, with any email. 这里jar包就运行成功了，可以看到，JRebel地址还需要一个{tokenname}，这里可以通过GUIDS在线获取工具进行获取。得到一个随机的tokenname值，如果过时了，重新刷新生成即可。
然后填入最终的license server地址：
http://192.168.98.1:1008/ fab341e4-f267-41df-ad7d-d37a3952e710 注意：的是这里要添加上jar包的开放端口1008 然后输入一个可用的邮箱地址，即可。点击激活便可成功！
但是到这还没完，虽然现在 Jrebel就能正常使用了，但很多人往往用不到几天就提示激活失败, 无法使用了，甚至jar包结束运行后激活就失败了。原因在于Jrebel激活之后默认是联网使用的 , 在该模式下 , Jrebel会一直联网监测激活信息。所以要调为离线使用的，操作方法就是进入Jrebel设置中点击Work offile 按钮即可。使其变为离线模式即可。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f30964c736ca8eb014148a4c9391bb2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4b3fbab160820097d86f5a9360ba838/" rel="bookmark">
			ssh反向代理实现内网穿透【亲测可用】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常用内网穿透方式
1、网卡层映射，包括购买公网ip
推荐指数：👍🏻👍🏻👍🏻👍🏻👍🏻。
缺点：主要申请困难。
2、自己搭建内网穿透服务。
推荐指数：👍🏻👍🏻👍🏻👍🏻。
非常的实用，自己需要一台公网ip的主机，可以购买阿里云服务器、腾讯云服务器，推荐这款45元一年的
3、使用三方平台提供的端口映射、内网穿透服务
推荐指数：👍🏻👍🏻👍🏻
使用cpolar、ngrok、花生壳等三方提供的服务。
缺点：复杂场景问题排查困难，不是很稳定，我这边主要用了这3款打包服务器每天凌晨3点老是容易断开，与官方排查了一周未解决。
本文在文镜老哥的指导下，使用第2种ssh反向代理的方式，通过内网打包服务器，借助外网服务器，实现在家访问我们的打包服务。
一、实现打包机器无密码登录到外网机器 1、添加打包机器ssh公钥到外网服务器 在打包服务器上生成公钥 (一路回车即可生成)
ssh-keygen 会生成id_rsa.pub文件，这是打包服务器smb服务截图：
这是打包服务器ssh服务截图：
复制打包机器的公钥
cat id_rsa.pub 添加到外网机器的authorized_keys中。
终端切换到外网服务器
cd ../../ cd root/.ssh/ 使用vim命令粘贴上去保存
vim authorized_keys esc退出，然后wq保存
验证：在打包机器上登录外网服务器看是否需要输入密码
ssh root@81.68.175.xx 这里打包机器不用输入密码就可登录，这步验证成功
2、ssh远程连接一段时间会失效的问题 光不输入密码就能登录，仍然存在一个问题，我们的远程登录终端是有超时时间的，这里我们在打包机器上设置重连。
在本地客户端操作：
1.进入/etc/ssh/中：cd /etc/ssh/
2.修改ssh_config文件（sudo vim ssh_config），在末尾添加ServerAliveInterval 30，意思是30s会发送一次向服务器连接的请求，以保持会话始终在线。
3.保存退出(:wq)
验证: 放一段时间不操作，我们的终端仍然是保持链接状态，这步就成功了。
二、在打包服务器上建立打包机器到外网机器的反向代理 1、内网端口映射到外网 [核心] 映射打包机器的8080端口到外网服务器9000端口
ssh -CqTnN -R 81.68.175.xx:9000:127.0.0.1:8080 root@81.68.175.xx &amp; 备注：末尾的&amp;表示后台执行
2、打开公网服务器网管开关 查看内网服务：正常
启动打包机器的jenkins服务（端口号8080），然后查看本地服务是否存在
curl http://127.0.0.1:8080 查看外网服务：异常
然后我们再访问可能出现访问失败的问题如下：
curl http://81.68.175.xx:9000/ linux解决ssh tunnels端口不能转发问题
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e4b3fbab160820097d86f5a9360ba838/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba6bcf835f19c6d8408e4a5911473932/" rel="bookmark">
			【Unity】[帮助文档] AddForce函数详解，参数ForceMode（Acceleration、Force、Impulse 和 VelocityChange）的选择
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 经常忘，经常查，倒不如我自己写一篇给自己方便参考，毕竟每次都在某N站查出来的都是不知道互抄到哪一年的机翻文章。
本文涉及代码与测试参考unity版本为2021.3，
AddForce 用于对rigidbody组件对象添加力的作用。
其参数决定了添加力的作用方式，因此参数不同，其获得的效果（动量、动能）也不同。
另外unity重力加速度默认为9.81左右，随着物体的状况会有改变。使用Debug.Log("Gravity: " + Physics.gravity);查看重力加速度（重力加速度也有方向！所以也是Vector3）。
要点 你需要了解并理解以下内容
力是矢量，有方向，因此调用时的第一个参数是Vector3类型
无论选什么参数施力，力都不会自动应用于后续帧。它只会在您调用AddForce函数的那一刻应用。区别仅在于它如何计算要施加多少力，而不在于它如何施加力。 https://answers.unity.com/questions/696068/difference-between-forcemodeforceaccelerationimpul.html
使用 AddForce 时，不用手动使用 Time.deltaTime 或
fixedDeltaTime，其内部的物理函数会自动将时间纳入计算。
https://answers.unity.com/questions/1752181/does-addforce-with-forcemodeforce-use-timedeltatim.html
物理相关的代码最好在fixUpdate函数而不是update内进行，因为fixupdate的时间间隔是固定的，update的时间间隔取决于帧率，且每次都不确定。
持续的力（fixUpdate内的持续调用）使用Force、Acceleration参数，单次的力使用Impulse参数，对速度的改变使用VelocityChange参数
ForceMode Force（力）： 通过 AddForce 函数添加力，单位为 N。如果我们在FixUpdate内持续调用AddForce(Vector3.up *100,ForceMode.Force)，那一秒内的50次调用（默认情况下FixUpdate 0.02秒调用一次）即为对该物体产生一个向上的100N的力持续一秒。
这两行代码是一样的
rigidbody.AddForce(Vector3.forward*1.0f,ForceMode.Force); rigidbody.velocity += Vector3.forward*1.0f * Time.fixedDeltaTime / (rigidbody.mass); Impulse（冲量）： 通过 AddForce 函数添加冲量，单位为 N /s（牛顿每秒）。冲量是一个在一瞬间产生的力，AddForce(Vector3.up *100,ForceMode.Impulse)调用1次与AddForce(Vector3.up *100,ForceMode.Force) 调用50次（一秒）的总力一样。
这两行代码是一样的
rigidbody.AddForce(Vector3.forward*1.0f,ForceMode.Impulse); rigidbody.velocity += Vector3.forward*1.0f / rigidbody.mass; Acceleration（加速度）： 通过 AddForce 函数添加加速度。忽略对象的质量，AddForce(Vector3.left*100,ForceMode.Acceleration)在fixupdate内执行一秒（默认50次），即视作一秒内物体保持了一个向左的100的加速度，静止的物体会在一秒后速度变为100.
这两行代码是一样的
rigidbody.AddForce(Vector3.forward*1.0f,ForceMode.Acceleration); rigidbody.velocity += Vector3.forward*1.0f * Time.fixedDeltaTime; VelocityChange（变速）： 通过 AddForce 函数添加的速度变化，单位为 m/s。忽略对象的质量，速度变化是一个直接改变物体速度的量，它可以在一次调用后立即影响物体的运动状态。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba6bcf835f19c6d8408e4a5911473932/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18e65cc8e085013d95c912021ca0303e/" rel="bookmark">
			【2】MyBatisPlus DML操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		字段映射与表名映射
问题一：当数据库表字段与编码属性设计不同步 如password与pwd 可以用mp的TableField里面的value属性即可关联
问题二：编码添加了数据库中不存在的字段属性 如“是否在线”一类的属性明显不需要放入数据库，但是在查询时候java需要在数据库中查，此时sql会报错
同样用TableField里面的exist=false即可
问题三：采用默认查询开放了更多的字段查看权限 如想要查整张表，但是命令会把密码也查了，操作不安全
TableField使用select属性设定它为false 则在查询过程中就不会被查询
问题四：表名与编码开发设计不同步 与问题一相似解，在类上面加一个TableName（“数据库表名”） TableId见下面
如果觉得每次都要在属性上面一行加@TableXX不方便 可以在yml里面统一设置
1、yml文件
spring: datasource: type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/mybatisplus_db?serverTimezone=UTC username: root password: 123456 spring: datasource: type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/mybatisplus_db?serverTimezone=UTC username: root password: 123456 mapper-locations: classpath:mybatis/mapper/*.xml main: banner-mode: off mybatis-plus: global-config: banner: false db-config: id-type: assign_id logic-delete-field: deleted logic-delete-value: 1 logic-not-delete-value: 0 configuration: #开启mp的日志（输出到控制台） log-impl: org.apache.ibatis.logging.stdout.StdOutImpl # table-prefix: //增
@Test void testSave(){ User user = new User(); user.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/18e65cc8e085013d95c912021ca0303e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0844e239cf6db6d0f3ab6485b317bcc4/" rel="bookmark">
			Unity动画分层和遮罩
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		动画分层和遮罩 Weight：权重 当动画同时播放时，如果选择的是叠加状态，会根据权重决定叠加的比例
Mask 动画遮罩，该层动画全部都会受该遮罩的影响
Blending：混合方式 Override：覆盖方式，播放该层动画时忽略其他层信息Additive：叠加方式，会和其它层动画叠加播放 Sync：是否同步其它层 主要用于直接从另一个层复制状态过来，在该层中进行修改
适用于比如正常状态下有待机走路跑步等等动作，但是受伤状态下动作会改变，可以利用同步层方便我们进行编辑
选择后会多一个Source Layer表示你要复制哪一层的状态
Timing 当选中Sync同步其它层时，该参数激活
选中，会采用折中方案调整同步层上的动画时长（基于权重计算）
不选中，动画时长将使用原始层做为母版
IK Pass 反向动力学
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76c2d9d04934fa8ec120c7aaa7972226/" rel="bookmark">
			2023 项目探秘：从零开始编译Asepirte
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 Aseprite是收费软件，请大家尊重版权，尊重开发者的创作成果。
Aseprite 官网
Asepirte 简介 Aseprite是一款用于像素作画的软件。可用于游戏精灵(Sprite)或者像素背景等一切像素艺术的创作。
准备工作 下载Visual Studio Installer安装CMake下载Ninja下载Aseprite 源码下载Skia 具体操作 1. 下载Visual Studio Installer，建议安装Visual Studio 2019及以上版本 这里选择Visual Studio Professional 2022，在选择面板里勾选上Desktop development with C++，右方侧栏不必改动。为避免出现差错，增大编译成功可能，建议勾选Windows 10 SDK (10.0.18362.0)。
2. 安装CMake，配置ninja 注意：安装时要勾选将CMake添加到环境变量，若未选择，可自行添加，方法如下：
找到cmake.exe（默认为"C:\Program Files\CMake\bin"），复制路径，将路径拷贝到Path环境变量中
将先前下载好的Ninja-**.zip中的ninja.exe解压到CMake目录中，使其与cmake.exe同目录
3. 准备源码和Skia库 将Aseprite源码解压到一个目录下（例如：这里解压到D盘，即：D:\Asepirte），同时在该目录下创建一个build文件夹，即：D:\Aseprite\build
将Skia-**.zip解压，使其与Aseprite同目录，即：D:\Skia
完成上述操作后，你的目录应该如下：
4. 编译 首先，管理员运行cmd，将路径切到build文件夹
调用VS开发者命令提示符（这里使用默认路径，若不同，可自行查找VsDevCmd.bat）
call "C:\Program Files\Microsoft Visual Studio\2022\Professional\Common7\Tools\VsDevCmd.bat" -arch=x64
接下来调用CMake生成项目文件
注意！一定要先将环境变量中的MinGW删除，Aseprite编译不支持MinGW
cmake -DCMAKE_BUILD_TYPE=RelWithDebInfo -DLAF_BACKEND=skia -DSKIA_DIR=D:\Skia -DSKIA_LIBRARY_DIR=D:\Skia\out\Release-x64 -DSKIA_LIBRARY=D:\Skia\out\Release-x64\skia.lib -G Ninja ..
当显示“-- Build files have been written to: D:/Aseprite/build”时，即表明生成项目文件成功。接下来进行编译：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/76c2d9d04934fa8ec120c7aaa7972226/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dba52f742d0d8eb0449f77b0dd5bdcd0/" rel="bookmark">
			大海捞针 Skia(C&#43;&#43;) 第 2 期：“Hello, Skia!”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		内容简介 本期将带领大家完成最经典的程序——“Hello, Skia!”。图形库表现方式主要以图像为主，因此，我们将会以图像的形式完成第一个项目。
关键词：文字、PNG图像、文件流
具体操作 1. 预编译头与静态库配置 打开Visual Studio，新建控制台项目(Console Project)，添加预编译头(Precompiled Header)。
在你的预编译头文件(默认为pch.h)中添加对应头文件。
本期我们需要的头文件如下：
#ifndef PCH_H #define PCH_H // Skia #include &lt;include/core/SkCanvas.h&gt; #include &lt;include/core/SkBitmap.h&gt; #include &lt;include/core/SkPaint.h&gt; #include &lt;include/core/SkTypeface.h&gt; #include &lt;include/core/SkFont.h&gt; #include &lt;include/codec/SkCodec.h&gt; #include &lt;include/core/SkImageEncoder.h&gt; // Skia Depency // Skia依赖于Direct的一些库，按照如下复制即可 #include &lt;d3d12.h&gt; #pragma comment(lib, "D3D12.lib") #include &lt;d3dcompiler.h&gt; #pragma comment(lib, "d3dcompiler.lib") #pragma comment(lib, "Opengl32.lib") #ifdef _DEBUG #include &lt;dxgi1_3.h&gt; #pragma comment(lib, "DXGI.lib") #endif // _DEBUG // C++ #include &lt;Windows.h&gt; #endif //PCH_H 接着，在项目管理中，链接静态库skia.lib。
2. 编写代码 代码如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dba52f742d0d8eb0449f77b0dd5bdcd0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91bea8f6ac3db09f9247ba5d33f5ad7d/" rel="bookmark">
			采用层次遍历的方法输出值为x的结点的所有祖先
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 #采用层次遍历的方法输出值为x的结点的所有祖先 #我觉得这个代码看看就好，一般很难想得出结点两个属性一个为当前结点的引用一个是当前结点的双亲结点 #设置一个属性为当前结点的引用好理解，为什么要设置双亲结点的引用？因为想通过设置双亲结点的引用来依次输出祖先结点，一旦找到了值为x的结点，通过这个pre就可以输出所有祖先结点 #程序的重点仍然是找到值为x的结点，仍然借用队列进行判断 #代码的运算过程：出队一个结点 #如果这个结点的值为x，那么设置一个指针q，通过移动指针把祖先结点全部移动到一个列表里 #如果这个结点的值不为x，如果他的左孩子结点不为空，就以这个左孩子结点为基础，立足于这个结点，这个结点作为新队列中的结点pre，这个新节点的引用就是这个结点 #生成完这个结点之后把他进队，留待之后调用 #采用层次遍历的方法输出值为x的结点的所有祖先 #我觉得这个代码看看就好，一般很难想得出结点两个属性一个为当前结点的引用一个是当前结点的双亲结点 #设置一个属性为当前结点的引用好理解，为什么要设置双亲结点的引用？因为想通过设置双亲结点的引用来依次输出祖先结点，一旦找到了值为x的结点，通过这个pre就可以输出所有祖先结点 #程序的重点仍然是找到值为x的结点，仍然借用队列进行判断 #代码的运算过程：出队一个结点 #如果这个结点的值为x，那么设置一个指针q，通过移动指针把祖先结点全部移动到一个列表里 #如果这个结点的值不为x，如果他的左孩子结点不为空，就以这个左孩子结点为基础，立足于这个结点，这个结点作为新队列中的结点pre，这个新节点的引用就是这个结点 #生成完这个结点之后把他进队，留待之后调用 from collections import deque class QNode: def __init__(self,p,pre): self.node=p self.pre=pre def Ancestor4(bt,x): res=[] qu=deque() qu.append(QNode(bt.b,None)) while len(qu)&gt;0: p=qu.popleft() if p.node.data==x: q=p.pre while q!=None: res.append(q.node.data) q=q.pre return res if p.node.lchild!=None: qu.append(QNode(p.node.lchild,p)) if p.node.rchild!=None: qu.append(QNode(p.node.rchild,p)) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07ca4287b1e7dd7242d10ba2bf7aa194/" rel="bookmark">
			Web漏洞之CSRF(跨站请求伪造漏洞）详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们知道了同源策略可以隔离各个站点之间的 DOM 交互、页面数据和网络通信，虽然严格的同源策略会带来更多的安全，但是也束缚了 Web。这就需要在安全和自由之间找到一个平衡点，所以我们默认页面中可以引用任意第三方资源，然后又引入 CSP 策略来加以限制；默认 XMLHttpRequest 和 Fetch 不能跨站请求资源，然后又通过 CORS 策略来支持其跨域。
所以安全性降低了，为了更好的技术应用，同时也带来了更多的安全隐患，如XSS，CSRF。
目录： 什么是CSRF
CSRF攻击过程
CSRF分类
CSRF攻击原理
CSRF漏洞挖掘
CSRF攻击的防御
写在前面：本篇文章将带大家详细了解Web漏洞之CSRF(跨站请求伪造漏洞），文章内容较长，请内心阅读。后面会持续更新Web漏洞系列文章，感兴趣的可以关注我！ 一、什么是CSRF？ 跨站请求伪造，冒用Cookie中的信息，发起请求攻击。 CSRF（Cross-site request forgery）跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。 二、CSRF攻击过程 满足了上面的必要条件才可以触发 当用户已经登录成功了一个网站
然后通过被诱导进了第三方网站「钓鱼网站」
跳转过去了自动提交表单，冒用受害者信息
后台则正常走逻辑将用户提交的表单信息进行处理
三、CSRF分类 CSRF(Cross-Site Request Forgery)，跟XSS漏洞攻击一样，存在巨大的危害性。
你可以这么来理解：攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作，比如以你的名义发送邮件、发消息，盗取你的账号，添加系统管理员，甚至于购买商品、虚拟货币转账等
1. GET型： 如果一个网站某个地方的功能，比如用户修改邮箱是通过GET请求进行修改的。如：/user.php?id=1&amp;email=123@163.com ，这个链接的意思是用户id=1将邮箱修改为123@163.com。当我们把这个链接修改为 /user.php?id=1&amp;email=abc@163.com ，然后通过各种手段发送给被攻击者，诱使被攻击者点击我们的链接，当用户刚好在访问这个网站，他同时又点击了这个链接，那么悲剧发生了。这个用户的邮箱被修改为 abc@163.com 了
2.POST型： 在普通用户的眼中，点击网页-&gt;打开试看视频-&gt;购买视频是一个很正常的一个流程。可是在攻击者的眼中可以算正常，但又不正常的，当然不正常的情况下，是在开发者安全意识不足所造成的。攻击者在购买处抓到购买时候网站处理购买(扣除)用户余额的地址。比如：/coures/user/handler/25332/buy.php 。通过提交表单，buy.php处理购买的信息，这里的25532为视频ID。那么攻击者现在构造一个链接，链接中包含以下内容
&lt;form action=/coures/user/handler/25332/buy method=POST&gt; &lt;input type="text" name="xx" value="xx" /&gt; &lt;/form&gt; &lt;script&gt; document.forms[0].submit(); &lt;/script&gt; 当用户访问该页面后，表单会自动提交，相当于模拟用户完成了一次POST操作，自动购买了id为25332的视频，从而导致受害者余额扣除
四、CSRF攻击原理 用户输入账号信息请求登录A网站。
A网站验证用户信息，通过验证后返回给用户一个cookie
在未退出网站A之前，在同一浏览器中请求了黑客构造的恶意网站B
B网站收到用户请求后返回攻击性代码，构造访问A网站的语句
浏览器收到攻击性代码后，在用户不知情的情况下携带cookie信息请求了A网站。此时A网站不知道这是由B发起的。那么这时黑客就可以进行一下骚操作了！
两个条件：a 用户访问站点A并产生了cookie
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07ca4287b1e7dd7242d10ba2bf7aa194/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/880493a16fc7a16855e66bf368858977/" rel="bookmark">
			安卓免root抓包--利用vmos虚拟机实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文链接：https://mp.weixin.qq.com/s/D7rG7UUICCRsVucx3uKz3A
安卓免root抓包–利用vmos虚拟机实现 原创 杨博文 [波纹库](javascript:void(0)😉 2022-03-23 20:00
收录于合集
#虚拟机2个
#学习5个
#root2个
#抓包2个
#安卓2个
先求波关注，里面还有很多优质的资源
波纹库
all in all
5篇原创内容
公众号
文章很详细，希望可以耐心看完，保证可以学会抓包，不再走冤枉路，小编在之前看过太多类似文章，折腾了太久才搞懂的，写这篇文章就是不想希望你们像小编一样再花时间折磨自己，也希望你们学到抓包后的快乐 会抓包的可以直接跳到第四点去看演示，以抓取京东wskey为例
1、 免root抓包需要的文件 vmos 登录即会员版小黄鸟Root Explorer（re管理器） 文件的下载链接已经放在公众号的关键词内 发送抓包文件即可获得对应下载链接
2、 抓包原理及方法介绍 真机为自己抓包用的手机，虚拟机为在真机内安装的vmos的虚拟机通过在虚拟机内运行抓包所需的应用，然后在真机内开启小黄鸟进行抓包，从而实现免root抓包注意：很多人以为在虚拟机内要安装小黄鸟，然后直接运行小黄鸟来抓包，这是一个极大的误区，是无法进行抓包的，否则因为在这里可以浪费极多的时间，或者接下来无法进行抓包的操作 3、 安装教程 3.1 真机安装vmos虚拟机和小黄鸟 3.2 在真机内打开小黄鸟，然后导出证书 在小黄鸟页面的左上角打开菜单
在左下角打开设置
记下证书保存的路径，把证书导入虚拟机要用到
存储位置：内部储存/HttpCanary/cert/
3.3 虚拟机安装Root Explorer 3.4 将证书导入虚拟机并利用MT管理器把证书放置系统证书目录下 虚拟机要开启root权限/超级用户权限 打开虚拟机文件传输，选择我要导入，选择文件，找到证书位置 （内部储存/HttpCanary/cert/），导入即可 打开Root Explorer，同意赋予超级用户/root权限，找到导入的证书位置（在VMOSfiletransferstatio目录内），然后复制证书到系统目录内：/system/etc/security/cacerts/ 至此，抓包所需的条件已经搞定，可开始快乐抓包
3.5 虚拟机启动要抓包的应用，然后返回真机启动小黄鸟，在设置内把目标应用选为vmos pro 3.6 返回小黄鸟主页面，点击左下角小飞机图案即可开始抓包 注：虚拟机是不用安装和启动小黄鸟的，只需在真机内安装并启动，虚拟机内是运行要抓包的应用，这个是大部分人的误区 3.7 安装证书若无网，则可在虚拟机内使用xp插件来关闭SSL验证，则可有网（小编未遇见此情况，可自行测试） 虚拟机开启xposed框架，安装JustTrustMe、JustMePlush、TrustMeAlready三个插件，并在xp框架内勾选此插件
JustMePlush需要在xp框架，打开模块勾选要抓包的APP，再返回真机运行Httpcanary即可有网抓包
4、 实例演示 按顺序从左往右演示
&lt;&lt;&lt; 左右滑动见更多 &gt;&gt;&gt;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/880493a16fc7a16855e66bf368858977/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2bd55b695ec4740e8eff9a5bd97ea825/" rel="bookmark">
			ResUnet&#43;&#43;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ResUnet++是一种用于结肠镜图像分割的改进ResUnet架构。总的来说本文的贡献在于
1）本文提出了一种新的resunet++架构，它是一种利用残差块，SE模块，ASPP模块和注意力块的语义分割神经网络
2）创建了新的数据集。
ResUnet++
提出的resunet++体系结构利用了残差块、SE模块、ASPP模块和注意力块
残差块在层上传播信息，允许建立一个更深层次的神经网络，可以解决每个编码器中的退化问题（梯度消失的问题）。这提高了信道的相互依赖性，同时降低了计算成本。提出的resunet++架构包含一个茎块，后面跟着三个编码器块、ASPP和三个解码器块。
提出的ResUnet++的体系框架结构图如下所示：
每个编码器块由两个连续的3x3的卷积块和一个单位映射组成，每个卷积块包括BN层，Relu层和卷积层。在编码器块的第一卷积层应用跨步卷积层将特征映射的空间维数降低一半。编码器块的输出通过SE模块传递。ASPP充当了一个桥梁，扩大了卷积核的视野，以包括更广泛的背景。
解码器相对应的也由残差单元组成，在每个解码器单元之前，注意力模块增加了特征映射的有效性。接下来是对较低级别的特征映射进行上采样，并与对应编码路径的特征映射进行连接。解码器的输出通过ASPP模块进行连接，最后应用1x1的Sigmod激活卷积，得到分割图。
残差单元
深度神经网络的训练相对具有挑战性。随着网络深度的增加，训练深度神经网络可以提高准确率。但是同时过深的网络会造成梯度消失的问题。残差单元使得网络易于训练，单元内部的残差连接有助于在不退化的情况下传播信息。
SE模块
SE模块通过使用通道之间的精确建模相互依赖关系重新校准特征响应，SE模块的目标是为了能够确保网络能够增加其对相关特征的敏感性，并抑制不必要的特征。这个目标分两步实现。第一步是压缩(全局信息嵌入)，通过使用全局平均池来生成按通道的统计信息来压缩每个通道。第二步是激励(有源校准)，旨在完全捕获通道依赖性。在提出的体系结构中，挤压和激励块与剩余块叠加在一起，以增加对不同数据集的有效泛化，提高网络的性能。
ASPP模块
ASPP模块的思想来自于空间金字塔池化，它成功的在多个尺度上重新采样特征。在ASPP模块中，上下文信息以不同的比例和输入特征图中许多不同膨胀系数的膨胀卷积进行融合。
结论
在本文中，我们提出了resunet++，这是一种解决结肠镜检查中发现的结肠直肠息肉更精确分割需求的架构。所建议的体系结构利用了残差单元和SE模块、ASPP和注意力单元。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/184/">«</a>
	<span class="pagination__item pagination__item--current">185/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/186/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>