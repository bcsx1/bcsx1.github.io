<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b55779fd8068129830393b4022bbad82/" rel="bookmark">
			makefile  在makefile中打印输出信息的方法是
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Makefile &amp; Android.mk文件中如何输出打印信息 在makefile中打印输出信息的方法是：$(warning xxxxx)或者$(error xxxxx)
输出变量方式为：$(warning $(XXX))
打印放在一般位置(非目标:依赖:规则的地方)make时解析makefile时就输出, 放在生成目标的规则中,make 目标被执行. 指定执行目录下的Makefile 或makefile
make obj -C path
指定执行某个makefile文件
make obj - f path/xxx.mk 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/729218d048ddbb7a2d02a878fd3176ce/" rel="bookmark">
			微信公众号支付从前端到后台（小白教程）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		耗时一个星期终于搞定微信支付，对于第一次涉足前端、微信支付的我来说，这并非易事，闲话少说，下面我用最通俗的语言来描述一下：
第一部分 微信公众号后台 1、申请微信公众号（需要营业执照），开发者认证（300两），微信支付申请。申请过程不细讲，按照引导一步步完善信息，接下来用到的所有配置项如果没有开放，就要对应向微信申请。 2、程序员直接看“开发”部分。首先“开发”–“基本配置”中开发者ID(AppID)、开发者密码(AppSecret)这两项是需要记录下来的，接下来的很多地方需要这两个数值来请求微信的接口，IP白名单需要把服务器的IP加进去，只有加进去的服务器，才能成功调取到微信的access_token（这个值是将来请求微信接口时，获取用户OpenId、用户基本信息之类的数据时所必须的）。其它暂时不需要配置。 3、其次“开发”–“开发者工具”。开发者文档（看得懂的直接忽略本文章）；web开发者工具就是一个类似浏览器的软件，微信授权登陆的时候实际上是直接登陆微信的链接，但是这个链接仅限在手机微信打开没办法调试，这样开发者就需要在电脑使用开发者工具打开这些链接建议使用;其它选项先忽略。 4、接口权限，只要开通了微信支付，该有的都有了。
第二部分 后台 1、集成后台SDK，可以通过“微信支付”–“使用教程”–“公众号支付”–SDK与DEMO下载，选择对应的后台类型下载，下面的都是java版的解读。 2、微信公众号支付SDK集成到Java程序中。首先通过maven引入代码如下： &lt;dependency&gt; &lt;groupId&gt;com.github.wxpay&lt;/groupId&gt; &lt;artifactId&gt;wxpay-sdk&lt;/artifactId&gt; &lt;version&gt;0.0.3&lt;/version&gt; &lt;/dependency&gt; 3、在微信官方下载的java版SDK中，\src\main\java\com\github\wxpay\sdk路径下的七个函数复制出来放到自己的工具类备用。其它文件中的内容都可以忽略，因为maven引用中已经将所有需要的jar包都已经导入。很关键的一点，在readme.md文件中很详细的介绍了一些常用的方法，其中就有统一支付的调用方法。 4、从WXPay中不难找到，其中就有统一支付的Java代码，以及要传入的参数，试着将微信公众号中提供的openId绑定调用，即可收到返回信息，统一支付有两种模式，分别是trade_type=NATIVE时（即扫码支付）trade_type=JSAPI时即为公众号发起的支付，区别在于，前者返回一串二维码字符串，通过qrcode二维码编译成二维码之后，可供用户扫码支付；后者会调用微信自带的接口，跳出密码输入框，让用户输入密码之后支付。下面针对传入trade_type=JSAPI之后需要做的操作。 5、上一步传入JSAPI的同时，需要传入的参数还有prepay_id、用户openid 等，prepay_id、用户openid 是通过微信的另一个接口，将用户授权登陆获取的token传入获取的，具体授权，以及授权后如何利用token获取prepay_id、openid可以参照微信提供的文档共有三次请求，特别注意其中一些接口调用次数有限，需要自行存储在缓存。拿到这些参数之后，接下来就是前端的工作了 https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421140842
第三部分 前端 ———-未完待续———-
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ebfefc81ead3ecd8bf66ac98b4a06cb7/" rel="bookmark">
			关于eclipse中xml文件的注释快捷键
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		eclipse中编辑java文件时，注释的快捷键为 "CTRL + / "，编辑xml文件时，该快捷键无效。
eclipse XML 注释：CTRL + SHIFT + /
撤销注释：CTRL + SHIFT + \
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7beb0b7d6fdda1e456e30a51c2470589/" rel="bookmark">
			jquery.fullPage.js全屏滚动插件的使用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		兼容性:
支持 IE8+ 及其他现代浏览器。 主要功能：
1.支持鼠标滚动；
2.支持前进后退键盘控制;
3.多个回调函数;
4.支持手机.移动设备;
5.支持窗口缩放自动调整;
6.可设置滚动宽度、背景颜色、滚动速度、循环选项、回调、文本对齐方式等等;
7.支持CSS3动画;
github下载地址：https://github.com/alvarotrigo/fullPage.js
滚屏里面的效果，都是写在回调函数中的；
配置表:
1.选项
选项 类型 默认值 说明 verticalCentered 字符串 true 内容是否垂直居中 resize 布尔值 false 字体是否随着窗口缩放而缩放 slidesColor 函数 无 设置背景颜色 anchors 数组 无 定义锚链接 scrollingSpeed 整数 700 滚动速度，单位为毫秒 easing 字符串 easeInQuart 滚动动画方式 menu 布尔值 false 绑定菜单，设定的相关属性与 anchors 的值对应后，菜单可以控制滚动 navigation 布尔值 false 是否显示项目导航 navigationPosition 字符串 right 项目导航的位置，可选 left 或 right navigationColor 字符串 #000 项目导航的颜色 navigationTooltips 数组 空 项目导航的 tip slidesNavigation 布尔值 false 是否显示左右滑块的项目导航 slidesNavPosition 字符串 bottom 左右滑块的项目导航的位置，可选 top 或 bottom controlArrowColor 字符串 #fff 左右滑块的箭头的背景颜色 loopBottom 布尔值 false 滚动到最底部后是否滚回顶部 loopTop 布尔值 false 滚动到最顶部后是否滚底部 loopHorizontal 布尔值 true 左右滑块是否循环滑动 autoScrolling 布尔值 true 是否使用插件的滚动方式，如果选择 false，则会出现浏览器自带的滚动条 scrollOverflow 布尔值 false 内容超过满屏后是否显示滚动条 css3 布尔值 false 是否使用 CSS3 transforms 滚动 paddingTop 字符串 0 与顶部的距离 paddingBottom 字符串 0 与底部距离 fixedElements 字符串 无 normalScrollElements 无 keyboardScrolling 布尔值 true 是否使用键盘方向键导航 touchSensitivity 整数 5 continuousVertical 布尔值 false 是否循环滚动，与 loopTop 及 loopBottom 不兼容 animateAnchor 布尔值 true normalScrollElementTouchThreshold 整数 5 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7beb0b7d6fdda1e456e30a51c2470589/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2be25667a86187ffe0b9a61dd3c8573d/" rel="bookmark">
			CSS3
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、CSS3背景
CSS3 允许您为元素使用多个背景图像。 实例 为 body 元素设置两幅背景图片： body { background-image:url(bg_flower.gif),url(bg_flower_2.gif); } CSS3 background-origin 属性 background-origin 属性规定背景图片的定位区域。
背景图片可以放置于 content-box、padding-box 或 border-box 区域。
新的背景属性 属性 描述 CSS background-clip 规定背景的绘制区域。 3 background-origin 规定背景图片的定位区域。 3 background-size 规定背景图片的尺寸。 3 二、 新的文本属性 属性 描述 CSS hanging-punctuation 规定标点字符是否位于线框之外。 3 punctuation-trim 规定是否对标点字符进行修剪。 3 text-align-last 设置如何对齐最后一行或紧挨着强制换行符之前的行。 3 text-emphasis 向元素的文本应用重点标记以及重点标记的前景色。 3 text-justify 规定当 text-align 设置为 "justify" 时所使用的对齐方法。 3 text-outline 规定文本的轮廓。 3 text-overflow 规定当文本溢出包含元素时发生的事情。 3 text-shadow 向文本添加阴影。 3 text-wrap 规定文本的换行规则。 3 word-break 规定非中日韩文本的换行规则。 3 word-wrap 允许对长的不可分割的单词进行分割并换行到下一行。 3 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4eebde1dda22abc22884ab1fb437f6bf/" rel="bookmark">
			CSS基础知识温习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、伪元素 伪元素 W3C："W3C" 列指示出该属性在哪个 CSS 版本中定义（CSS1 还是 CSS2）。 属性 描述 CSS :first-letter 向文本的第一个字母添加特殊样式。 1 :first-line 向文本的首行添加特殊样式。 1 :before 在元素之前添加内容。 2 :after 在元素之后添加内容。 2 1、:first-line 伪元素 "first-line" 伪元素用于向文本的首行设置特殊样式。
在下面的例子中，浏览器会根据 "first-line" 伪元素中的样式对 p 元素的第一行文本进行格式化：
实例 p:first-line { color:#ff0000; font-variant:small-caps; } 注释："first-line" 伪元素只能用于块级元素。 注释：下面的属性可应用于 "first-line" 伪元素：
font color background word-spacing letter-spacing text-decoration vertical-align text-transform line-height clear
2、:first-letter 伪元素 "first-letter" 伪元素用于向文本的首字母设置特殊样式：
p:first-letter { color:#ff0000; font-size:xx-large; } 注释："first-letter" 伪元素只能用于块级元素。 注释：下面的属性可应用于 "first-letter" 伪元素： font color background margin padding border text-decoration vertical-align (仅当 float 为 none 时) text-transform line-height float clear 多个伪元素可以结合使用 p:first-letter { color:#ff0000; font-size:xx-large; } p:first-line { color:#0000ff; font-variant:small-caps; } 3、CSS2 - :before 伪元素 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4eebde1dda22abc22884ab1fb437f6bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7769cc1cd9c3f7ca7a2f793646069880/" rel="bookmark">
			Spring配置文件头及xsd文件解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最初Spring配置文件的头部声明如下：
Xml代码 &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;!DOCTYPE beans PUBLIC "-//SPRING//DTD BEAN 2.0//EN" "http://www.springframework.org/dtd/spring-beans-2.0.dtd"&gt; &lt;beans&gt; &lt;/beans&gt; 说明： 1、第一行表示xml声明，任何格式良好的xml文档都必须第一行是声明。相当于告诉解析器这个是xml文档，你给我用xml解析器解析。 2、dtd声明，表示该xml里的元素和属性等需符合spring-beans-2.0.dtd这个文档类型定义标准。 DTD：文件的文件型别定义（Document Type Definition）可以看成一个或者多个 XML 文件的模板，在这里可以定义 XML 文件中的元素、元素的属性、元素的排列方式、元素包含的内容等等。 因为DTD的一些局限性，以及XML Schema对数据类型和命名空间的支持。XML Schema很快会将 DTD 取而代之
被XML Schema 取代后的Spring 配置：
Xml代码 &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd"&gt; &lt;/beans&gt; XML Schema命名空间作用： 1、避免命名冲突，像Java中的package一样 2、将不同作用的标签分门别类（像Spring中的tx命名空间针对事务类的标签，context命名空间针对组件的标签） 代码解释： 1、xmlns="http://www.springframework.org/schema/beans" 声明xml文件默认的命名空间，表示未使用其他命名空间的所有标签的默认命名空间。 2、xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 声明XML Schema 实例，声明后就可以使用 schemaLocation 属性了 3、xmlns:aop="http://www.springframework.org/schema/aop" 声明前缀为aop的命名空间，后面的URL用于标示命名空间的地址不会被解析器用于查找信息。其惟一的作用是赋予命名空间一个惟一的名称。当命名空间被定义在元素的开始标签中时，所有带有相同前缀的子元素都会与同一个命名空间相关联。 4、xsi:schemaLocation=" http://www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7769cc1cd9c3f7ca7a2f793646069880/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e52301bd052c453f17398d4d7855d7d0/" rel="bookmark">
			【深度相机系列四】深度相机原理揭秘--结构光（iPhone X 齐刘海原理）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文已经首发在个人微信公共号：计算机视觉life（微信号CV_life），欢迎关注！
导读
结构光法：为解决双目匹配问题而生
深度图效果：结构光vs.双目
投射图案的编码方式
直接编码 时分复用编码
空分复用编码
Kinect1原理 iPhone X原深感相机是缩小版的更强大的Kinect1
结构光法优缺点总结
------------------------------------------------------------------
结构光法：为解决双目匹配问题而生
前面文章《深度相机原理揭秘--双目立体视觉》中提到基于双目立体视觉的深度相机对环境光照强度比较敏感，且比较依赖图像本身的特征，因此在光照不足、缺乏纹理等情况下很难提取到有效鲁棒的特征，从而导致匹配误差增大甚至匹配失败。
而基于结构光法的深度相机就是为了解决上述双目匹配算法的复杂度和鲁棒性问题而提出的，其他处理步骤和双目立体视觉类似，本文不再赘述。结构光法不依赖于物体本身的颜色和纹理，采用了主动投影已知图案的方法来实现快速鲁棒的匹配特征点，能够达到较高的精度，也大大扩展了适用范围。
结构光深度相机原理示意图（注意E端发射的带图案的光源）
深度图效果：结构光vs.双目
下图左是普通双目立体视觉深度相机拍摄的图像和对应的深度图结果；下图右是结构光法的深度相机投射的图案及对应的深度图结果，明显可以观察到在同样的场景下结构光法得到的深度图更完整，细节更丰富，效果大大好于双目立体视觉法。
双目立体视觉（左）和结构光（右）深度相机拍摄的图像和对应的深度图
投射图案的编码方式
结构光法投射的图案需要进行精心设计和编码，结构光编码的方式有很多种，一般分为如下几大类：
1、直接编码（direct coding）
根据图像灰度或者颜色信息编码，需要很宽的光谱范围。
优势：对所有点都进行了编码，理论上可以达到较高的分辨率。
缺点：受环境噪音影响较大，测量精度较差。
直接编码原理示意图
2、时分复用编码（time multiplexing coding）
顾名思义，该技术方案需要投影N个连续序列的不同编码光，接收端根据接收到N个连续的序列图像来每个识别每个编码点。投射的编码光有二进制码（最常用）、N进制码、灰度+相移等方案。
该方案的优点：测量精度很高（最高可达微米级）；可得到较高分辨率深度图（因为有大量的3D投影点）；受物体本身颜色影响很小（采用二进制编码）。
缺点：比较适合静态场景，不适用于动态场景；计算量较大（因为识别一个编码点需要计算连续N次投影）。
时分复用编码原理示意图
3、空分复用编码（spatial multiplexing coding
根据周围邻域内的一个窗口内所有的点的分布来识别编码。
该技术的优势：适用于运动物体。
缺点：不连续的物体表面可能产生错误的窗口解码（因为遮挡）。
空分复用编码原理示意图
Kinect1原理
业界比较有名的结构光方案就是以色列PrimeSense公司的Light Coding的技术，该方案最早被应用于Microsoft的明星产品Kinect1（Kinect2是基于TOF的技术）上。下面以Kinect1为例，介绍一下其工作原理。
Microsoft和PrimeSense合作的Kinect1
Kinect1的红外IR发射端投射人眼不可见的伪随机散斑红外光点到物体上，每个伪随机散斑光点和它周围窗口内的点集在空间分布中的每个位置都是唯一且已知的。这是因为Kinect1的存储器中已经预储存了所有的数据。
Kinect1投影的伪随机散斑
这些散斑投影在被观察物体上的大小和形状根据物体和相机的距离和方向而不同。如下图所示。
Kinect1根据三种不同的距离使用了三种不同尺寸的散斑，如下图所示。这样的目的是为了在远中近三种距离内都能得到相对较好的测量精度：
近距离(0.8 – 1.2 m)：可以获得较高的测量精度
中距离(1.2 – 2.0 m)：可以获得中等的测量精度
远距离(2.0 – 3.5 m)：可以获得较低的测量精度
Kinect1测量精度如下：
spatial x/y resolution: 3mm @2m distance
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e52301bd052c453f17398d4d7855d7d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02a41c2d92fc3970d63691d3d57f7912/" rel="bookmark">
			Android中实现 滑动时将指定View定位在顶部
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考一：
在项目开发中遇到这样的需求，需要实现scrollview顶部的悬停效果，实现原理非常简单，下面小编通过本文给大家分享实例代码，需要的朋友参考下
因项目中的需要实现ScrollView顶部的悬停，也不是太难便自己实现功能，话不多说，先上效果图
红色text一到顶上便会悬浮在上面，不会跟随scrollview的滑动而上滑。
原理：
原理其实很简单就是对view的gone和visible，写两个相同的要置顶的view，一个设置为gone，一个为visible，当可见的view超出屏幕范围的时候，将不可以的view设置为visible，不可见的view 与scrollview要同级，这样滑动的时候不会影响到view的位置。
直接上代码
? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 &lt;?xml version= "1.0" encoding= "utf-8" ?&gt; &lt;RelativeLayout xmlns:android= "http://schemas.android.com/apk/res/android" android:layout_width= "match_parent" android:layout_height= "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/02a41c2d92fc3970d63691d3d57f7912/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc2c12e10b80fc2ce7d4e820888adabe/" rel="bookmark">
			解锁css3新姿势之transform3D各属性及transform兼容之矩阵写法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		闲来无事，整理一下可以打造炫酷网站的一些transform的属性
1. 矩阵transform:matrix() 这个矩阵哥们是有些厉害的，不得不多说两句，这哥们可以同时写上缩放，旋转，拉伸，位移等变形；详细内容见下面 2.transform-style:preserve-3d;创造3D空间 3.transform:rotate;2D旋转； 4.transform:scale(倍数)，缩放函数，取值正数，负数，小数； 5.transform:skew(xdeg,ydeg);拉伸函数或者斜切； 6.transform:translate();位移； 7.transform:可以同时有多种变形的样式混写
矩阵transform:matrix(),可以同时写上缩放，旋转，拉伸，位移等变形； 如果变形不用矩阵来写的话，不兼容ie9以下，js也不会获取到deg度数；
所以用矩阵来用数字值来表达度数，让js动态获取；
transform:matrix(a,b,c,d,e,f);martrix共有6个值； 初始值是matrix(1,0,0,1,0,0); 兼容ie9，需要另写声明：
filter:progid:DXImageTransform.Microsoft.Matrix(M11=1,M12=0,M21=0,M22=1,SizingMethod='auto expand'); ie矩阵下没有e和f两个值，即没有位移的值；具体位移可用定位来写；
其中：M11==a;M12==b,M21=c,M22=d 矩阵实现缩放； x轴的缩放：a=x*a c=x*c e=x*e; y轴的缩放：b=y*b d=y*d f=y*f;d 如果只有缩放效果的话，那么只写a,d的值即可 如果有别的效果的话，matrix就不是默认值了，乘以相应的值即可；
.box{ width:300px; height: 400px; border:1px solid red; margin: 50px auto 0; font-size: 100px; color:#fff; line-height: 400px; text-align: center; } .div1{ width:300px; height: 400px; background: blue; transition: 3s; } .div1{ transform:matrix(0.5,0,0,0.5,0,0); filter:progid:DXImageTransform.Microsoft.Matrix(M11=0.5,M12=0,M21=0,M22=0.5,SizingMethod='auto expand'); 矩阵实现位移； transform:matrix(a,b,c,d,e,f);只需要改变ef的值 x轴的位移：x+e; y轴的位移：y+f; 位移数值可以不用加px单位 如果至实现 x和 y位移100px的话，matrix代码如下
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc2c12e10b80fc2ce7d4e820888adabe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8889a60bb9ed3ad6f1b247820ccfbf9d/" rel="bookmark">
			vue踩坑之全局使用axios
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： Vue 原本有一个官方推荐的 ajax 插件 vue-resource，但是自从 Vue 更新到 2.0 之后，尤雨溪宣布停止更新vue-resource，并推荐大家使用axios之后，越来越多的 Vue 项目，都选择 axios 来完成 ajax 请求，而大型项目会使用 Vuex 来管理数据
之前一直使用的是 vue-resource插件，在主入口文件引入import VueResource from 'vue-resource'之后，直接使用Vue.use(VueResource)之后即可将该插件全局引用了；
初用axios时，无脑的按照上面的步骤进行全局引用，结果当时是惨惨的。 看了看文档，Axios 是一个基于 promise 的 HTTP 库
axios并没有install 方法，所以是不能使用vue.use()方法的。 那么难道每个文件都要来引用一次？解决方法有很多种： 1.结合 vue-axios使用 2. axios 改写为 Vue 的原型属性 3.结合 Vuex的action 结合 vue-axios使用 看了vue-axios的源码，它是按照vue插件的方式去写的。那么结合vue-axios，就可以去使用vue.use方法了
首先在主入口文件main.js中引用
import axios from 'axios' import VueAxios from 'vue-axios' Vue.use(VueAxios,axios); 之后就可以使用了，在组件文件中的methods里去使用了
getNewsList(){ this.axios.get('api/getNewsList').then((response)=&gt;{ this.newsList=response.data.data; }).catch((response)=&gt;{ console.log(response); }) }, axios 改写为 Vue 的原型属性 首先在主入口文件main.js中引用，之后挂在vue的原型链上
import axios from 'axios' Vue.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8889a60bb9ed3ad6f1b247820ccfbf9d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2162e84f6d37ca8e447102c4e46d343/" rel="bookmark">
			(class file version 53.0), Java Runtime versions up to 52.0错误的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		遇到这个错误是在Apache Tomcat上部署应用程序的时候遇到的，具体的错误描述是：
java.lang.UnsupportedClassVersionError: HelloWorld has been compiled by a more recent version of the Java Runtime (class file version 53.0), this version of the Java Runtime only recognizes class file versions up to 52.0 at java.lang.ClassLoader.defineClass1(Native Method) ...... ...... at sun.launcher.LauncherHelper.checkAndLoadMain(LauncherHelper.java:495)
主要的内容是：
has been compiled by a more recent version of the Java Runtime (class file version 53.0), this version of the Java Runtime only recognizes class file versions up to 52.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2162e84f6d37ca8e447102c4e46d343/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/afab6b3da0333760d8c426fe4484ec61/" rel="bookmark">
			hibernate系列十七:Criteria查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Criteria查询是Hibernate提供的另一种查询方式，与HQL基于字符串的查询形式完全不同。Hibernate提供了org.Hibernate.Criteria接口、org.hibernate.criterion.Criterion接口和org.hibernate.criterion .Restrictions类等Criteria API，用于支持在运行时动态生成查询语句。
1. 条件查询
使用Criteria查询包括以下步骤：
(1)使用Session接口的createCriteria()方法创建Criteria对象。
(2)使用Restrictions类提供的静态方法设置查询条件，这些静态方法返回Criterion对象，一个Criterion对象代表一个查询条件。Criteria接口的add()方法用来添加查询条件。
(3)使用Criteria接口的list()方法执行查询语句，list()方法返回java．util．List类型的结果，List集合中的每个元素都是持久化对象。
接下来通过示例来说明。
案例1 查询男学生 package com.obtk.test; import java.util.List; import org.hibernate.Criteria; import org.hibernate.HibernateException; import org.hibernate.Session; import org.hibernate.criterion.Restrictions; import com.obtk.entitys.StudentEntity; import com.obtk.utils.HiberUtil; public class CriteraTest1 { public static void main(String[] args) { Session session=null; try { session=HiberUtil.getSession(); Criteria cri=session.createCriteria(StudentEntity.class); cri=cri.add(Restrictions.eq("gender", "男")); List&lt;StudentEntity&gt; stuList=cri.list(); for(StudentEntity stu : stuList){ System.out.println(stu.getStuId()+"\t"+stu.getStuName()+"\t"+stu.getGender()); } } catch (HibernateException e) { e.printStackTrace(); }finally{ HiberUtil.closeSession(); } } } 案例2 多条件查询，链式编程
package com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/afab6b3da0333760d8c426fe4484ec61/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/360419816e03dbd5fef672fd485faaa8/" rel="bookmark">
			点击按钮切换图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;选显卡切换&lt;/title&gt; &lt;style type="text/css"&gt; .img0 { height: 300px; width: 700px; } .ul0 { list-style: none; } .ul0 li { float: left; padding: 5px; background: gray; margin: 5px; width: 40px; text-align: center; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="main"&gt; &lt;img src="img/aaaa.jpg" class="img0" id="img0" /&gt; &lt;ul class="ul0"&gt; &lt;li οnclick="change1()"&gt;1&lt;/li&gt; &lt;li οnclick="change2()"&gt;2&lt;/li&gt; &lt;li οnclick="change3()"&gt;3&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; function change1() { var img = document.getElementById("img0") // img.setAttribute("src","img/aaaa.jpg"); img.src = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/360419816e03dbd5fef672fd485faaa8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69de1aaf68eada2427af47fa978a85e3/" rel="bookmark">
			汉诺塔问题解答
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		汉诺塔的盘子移动过程中目的将盘子从A（初始盘）借助B（借用盘）移动到C（目标盘）。整个过程注意把握两点： 一：一次递归调用中三个盘子分别起到了什么作用。 二：调用以后三个盘子的角色又变换成了什么。 详细分析： （n=2）两个盘子的情况下： 1.第一次调用find函数A盘代表初始盘，B盘代表目标盘，C盘代表借用盘。 2.按照Find函数Find（n, A, B, C）的排列顺序即，A的位置为初始盘，B的位置为借用盘C的位置为目标盘，故第一次调用Find函数的时候传值顺序为find（n-1，A，C, B,）； 3.此刻第一次调用已经结束，ABC三个盘的盘片数为A只有n号盘，B有n-1号个盘子，C为0个。 4.此刻调用mov（）函数，将A上的n号盘移动到C。 5.此刻第二次调用find函数，但是其中ABC角色已经发生了变化但是Find函数的位置（初始盘，借用盘，目标盘）没有变。故此刻为借用C盘将B盘上的N-1个盘移动到A盘上。再次调用Find函数时传值为find（n-1，B，A, C）。
注意： 1.盘片的功能确定，剩余盘片数所在的盘为初始盘，C盘永远为目标盘，空盘为借用盘。 2.把握一点，函数Find（n剩余盘片数，A初始盘，B借用盘，C目标盘）即可。
#include &lt;stdio.h&gt; int i=1; bool mov (int n,char A,char C) { printf("第%d次,将%d号盘%c------&gt;%c\n",i,n,A,C); i++; return true ; } bool find(int n,char A,char B,char C) { if (n==1) mov (1,A,C); else { //盘多的为初始盘， // 1.借c把上A上的盘移动到b上，此时A为初始盘，B为目标盘，C为借用盘 // 2.把第N个盘从A移动到C上，此时只有一个、n号盘 // 3.把B借用A移动到c ，此时A为借用盘B为初始盘，C为目标盘 find (n-1,A,C,B); mov(n,A,C); find (n-1,B,A,C); } return true; } int main() { int n; char A='A',B='B',C='C'; printf ("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/69de1aaf68eada2427af47fa978a85e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89da764a4e2183a1ab29112e783c0b8b/" rel="bookmark">
			spring Security4 和 oauth2整合 注解&#43;xml混合使用（基础运行篇）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring Security4 和 oauth2整合 最近项目中需要用到oauth2，到网上找了好多资料，全是乱七八糟的，东拼西凑，终于跑出来了一版，xml的方式太乱了，跑不了，还是用注解方式，并把一些关键配置提到xml中。
git地址：https://gitee.com/ffch/OauthUmp
spring Security4 和 oauth2整合 注解+xml混合使用（基础运行篇）
spring Security4 和 oauth2整合 注解+xml混合使用（进阶篇）
spring Security4 和 oauth2整合 注解+xml混合使用（授权码篇）
spring Security4 和 oauth2整合 注解+xml混合使用（注意事项篇）
spring Security4 和 oauth2整合 注解+xml混合使用（替换6位的授权码）
spring Security4 和 oauth2整合 注解+xml混合使用（替换用户名密码认证）
spring Security4 和 oauth2整合 注解+xml混合使用（验证码等额外数据验证）
网上已有的注解版方案（运行有问题，后面修正） 链接：http://www.yiibai.com/spring-security/secure-spring-rest-api-using-oauth2.html
这个链接没说是springmvc或者springboot使用，反正我是用springmvc使用了，可以用，我这里搬过来，同时写上自己的代码。后面会修改。
pom.xml
&lt;properties&gt; &lt;spring.version&gt;4.0.5.RELEASE&lt;/spring.version&gt; &lt;jsonlib.version&gt;2.4&lt;/jsonlib.version&gt; &lt;spring.security.version&gt;4.0.1.RELEASE&lt;/spring.security.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.10&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;${spring.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89da764a4e2183a1ab29112e783c0b8b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f9bf832d13a390b79dfa62cee2715d8/" rel="bookmark">
			iOS Technical support web site
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		iOS program design &amp; system consultation if you have any question,please contact me with no hesitate Email:quwx1983625@21cn.com TEL：+44 7 8975 4662 1
Address:
ANHUI Chuzhou dingyuanxian outangzhen qingliulu 1hao9chuang1shi
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96189bffacd190297814d88bda4caeba/" rel="bookmark">
			Linux档案与目录管理命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.目录操作 cd（变换目录）
pwd（显示目录所在目录） -P：显示出确实的路径，非使用链接（link）路径。
mkdir（建立新目录） -m：配置文件档案的权限
-p：递归创建目录
rmkdir（删除空目录）
-p：连同上层空目录一起删除
2.档案管理 1&gt;.ls：档案与目录的检视
ls -al --full-time [目录(不加默认为当前目录）]
2&gt;.cp：复制档案或目录 cp [选项] [源文件] [目标文件]
注：复制需要有r（read）的权限，复制后文档通常为指令操作者本身。
对于一些特殊权限档案需要加上-a 或者 -p等可以完整复制档案权限的选项，若拷贝给其他使用者，也需要注意档案的权限，否则其他人无法改动。
对于连接档，直接cp拷贝的是源文件，要拷贝链接则需要用到-d。
3&gt;.rm：移除档案或目录 rm [-fir] [档案/目录]
-f: force，强制移除；
-i：互动模式，删除前询问；
-r：递归删除（慎用！）
4&gt;.mv：移动档案或目录 mv [-fiu] [源文件] [目的文件]
-f：强制，如果已存在，直接覆盖；
-i：询问；
-u：更新（update）
3.档案内容查阅 1&gt;.cat(concatenate) tac 反向列示
2&gt;. nl（添加行号打印） nl [-nbw]档案
-b：列出行号的指定方式
-b a : 不论是否为空行，也列出行号
-b t ：不列出空行（默认）；
-n：列出行号的方法
-n ln：行号在屏幕左方显示；
-n rn：显示在字段最右方，且不加0；
-n rz：显示在字段最右方，且加0；
-w：行号字段占用位数。
3&gt;.可翻页检视
a. more（一页一页翻动） 空格：下翻一行；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96189bffacd190297814d88bda4caeba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bdc8c5b795175a24f6b67fdcea3c3371/" rel="bookmark">
			css 简单的点击按钮更换展示的图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		//设置一张图片
&lt;img id="img" src="img/139-15040Q15102.jpg" class="img"/&gt;
&lt;br /&gt;
//设置控件
&lt;button style="background-color: red;" class="but1" id="but1" οnclick="btn1()"&gt;1&lt;/button&gt;
&lt;button class="but1" id="but2" οnclick="btn2()"&gt;2&lt;/button&gt;
&lt;button class="but1" id="but3" οnclick="btn3()"&gt;3&lt;/button&gt;
//调用js
&lt;script&gt;
//查找控件并且赋于值
var but1 = document.getElementById("but1");
var but2 = document.getElementById("but2");
var but3 = document.getElementById("but3");
var img = document.getElementById("img");
//点击事件的监听
function btn1(){
but1.style.backgroundColor="red";
but2.style.backgroundColor="white"
but3.style.backgroundColor="white"
img.src="img/139-15040Q15102.jpg";
}
function btn2(){
but2.style.backgroundColor="red";
but1.style.backgroundColor="white"
but3.style.backgroundColor="white"
img.src="img/139-150423095403.jpg";
}
function btn3(){
but3.style.backgroundColor="red";
but2.style.backgroundColor="white"
but1.style.backgroundColor="white"
img.src="img/144-3-1440x900.jpg"
}
&lt;/script&gt;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43c014f59dbe5844bf47c38f8016625b/" rel="bookmark">
			常引用(const type&amp;)的特性及引用的本质
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		//所以引用的本质是常指针类型 type* const p
//之所以const只修饰p代表它所指向的地址是固定的 //而*p也就是代表着内容(变量的值)是可以更改的
//这符合引用的性质
//引用的本质是，是对常指针 type * const p 的再次包装
#include "stdafx.h" #include &lt;iostream&gt; using namespace std; #if 0 ----常引用 const 引用有较多使用。它可以防止对象的值被随意修改。因而具有一些特性。 (1)const 对象的引用必须是 const 的,将普通引用绑定到 const 对象是不合法的。 既然对象是 const 的,表示不能被修改。引用当然也不能修改,必须使用 const 引用。 所以 const int a = 1; int &amp;b = a; 这种写法是不合法的，编译通不过。 (2)const 引用可使用相关类型的对象(常量、非同类型的变量或表达式)初始化。 这个是 const 引用与普通引用最大的区别。const int &amp;a = 2; 是合法的。 double a = 3.14; const int &amp;b = a; 也是合法的 #endif struct T{int* p;}; struct TT{double &amp;a;}; int _tmain(int argc, _TCHAR* argv[]) { double val = 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43c014f59dbe5844bf47c38f8016625b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87e38ce1496e9d5cec14e37826870972/" rel="bookmark">
			引用(&amp;)与指针(*)的定义要求
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 引用(&amp;)与指针(*)的定义要求
#include "stdafx.h" #include &lt;iostream&gt; using namespace std; #if 0 把引用&amp; 想成是一种声明而不是一种类型 记忆成不能对int&amp; 这种格式进行任何加*或者加&amp;操作 所以不能定义引用的引用 C++把引用只限制到了一级的层面 int&amp; &amp;ra=a; //这种做法是错误的 也不能定义引用的指针 int&amp; *ra=a; 也不能定义引用数组 int a,b,c; int&amp; array[]={a,b,c}; //array 相当于int*类型 也就是整个可以替换成int&amp; * cout&lt;&lt;"----------------------------------"&lt;&lt;endl; 但可以定义指针的引用 int p; int *a=&amp;p; int* &amp;ra=a;//是指针类型的引用 也可以叫指针的引用 也可以定义指针的指针 int p; int* a=&amp;p; int** ra=&amp;a; 也可以定义指针数组(也就是二级指针) int a,b,c; int* array[]={&amp;a,&amp;b,&amp;c}; //array 相当于int** 也可以定义数组的引用 int a[]={1,2,3,4,5}; int (&amp;ra)[5]=a; #endif int _tmain(int argc, _TCHAR* argv[]) { return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6eeebfbb47378f44ffc69259442c4444/" rel="bookmark">
			利用引用交换俩指针的指向关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		利用引用交换俩指针的指向关系
#include "stdafx.h" #include &lt;iostream&gt; using namespace std; #if 0 可以通过一级指针修改0级指针的内容,可以通过二级指针修改 一级指针的指向,可以通过N级指针修改N-1级指针的指向 void Swap(char* x,char* y) { char* t = x; x = y; y = t; } 这个方法并不能改变原有指针的指向关系,相当于在栈上新开 辟俩个空间x y 存放着字符串的指针,也就是指向俩个字符串 通过相互赋值改变的只是 新开辟空间的指向,而在调用结束后 空间就会销毁,并没有回传给原指针,所以改变不了原指针的 指向关系 void Swap(char** x, char** y) { char* t = *x; *x = *y; *y = t; } 利用二级指针(升*)的方法,也就是在栈上新开辟俩个空间,存放 着字符串指针的地址,它们也就是字符串的指针的指针,指向的是 俩个指针,所以改变其内容就是直接改变原指针中的内容,实现了 更改指向关系 #endif void Swap(char* &amp;x, char* &amp;y)//指针的引用 此引用为指针类型 { char* t = x; x = y; y = t; } //传引用相当于直接对原指针进行操作 所以直接进行交换即可 //相当于扩展到main函数 扩展了其作用域 int _tmain(int argc, _TCHAR* argv[]) { int a; int &amp;ra = a; int* p; int* &amp;rp = p; //指针的引用(别名) char* pstr = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6eeebfbb47378f44ffc69259442c4444/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dbaf81cf679aa93338a42e702570a905/" rel="bookmark">
			引用(&amp;)的用法规则及传参
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用法规则 1.引用没有定义,是一种关系型声明 声明它和原有某一变量(实体)的关系。故而类型与原类型保持一致，且不分配内存。与被引用的变量有相同的地址。
2.声明的时候必须初始化，一经声明，不可变更。
3.可对引用，再次引用。多次引用的结果，是某一变量具有多个别名。
4.&amp;符号前有数据类型时，是引用。其它皆为取地址 //&amp;在等号左边(&amp;=)为引用 //&amp;在等号右边(=&amp;)为取地址
#include "stdafx.h" #include &lt;iostream&gt; using namespace std; int _tmain(int argc, _TCHAR* argv[]) { int a = 1234; int &amp;ra = a; //表示a的别名(声明关系) //int &amp;ra; 声明的时候必须初始化,不能之后在初始化 cout &lt;&lt; sizeof(a) &lt;&lt;" "&lt;&lt; sizeof(ra) &lt;&lt; endl;//大小相等 cout &lt;&lt; &amp;a &lt;&lt; "--" &lt;&lt; &amp;ra &lt;&lt; endl; //此时&amp;为取地址 地址相同 int &amp;rra = a; //a的多个别名 int &amp;rrra = rra; cout &lt;&lt; a &lt;&lt; "	" &lt;&lt; ra &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dbaf81cf679aa93338a42e702570a905/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba6afe7a2d8de0b079e2af9f0f33a537/" rel="bookmark">
			Simpy笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Environment功能: manage simulation time &amp; schedule events processing Simulation可执行直到在某时刻env.run(until=10)/全部事件执行完成env.run()/特定事件发生后，例如：
import simpy def my_proc(env): yield env.timeout(1) env=simpy.Environment() proc=env.process(my_proc(env)) env.run(until=proc) Pycharm快捷键： Run: Fn+Shift+F10
Event 功能：(simpy.events.Event): 预定行为，futures or promises Event e的生命周期：not triggered (in memory)-&gt;triggered (in event queue)-&gt;processed-&gt;call its callbacks (执行e的回调函数)
注：process前可添加callbacks； trigger前可设置返回值，然后通过语句Event.value或在process中用value=yield Event获取返回值。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/539e1109145ceefa1c953114d1cd062f/" rel="bookmark">
			Windows下载mingw安装器安装gcc/make组件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网站：http://www.mingw.org/（网站排版可能会发生变化）
选择 download installer下载软件安装包管理器mingw-get-setup.exe或者mingw-w64-install.exe（这个软件是下载安装各个插件的管理工具，之后下载各个包需要联网，也可以在网站下载所需要的单个软件包进行解压使用）
等待倒计时结束下载文件，下载完成后运行安装
选择安装目录，Continue
继续
Basic setup选择mingw32-base，这个meta包提供了基本的gcc安装，并且包括c编译器，链接器和其他二进制工具，运行库和windows的API支持，mingw32-make和debugger.other组件可以根据需要手动添加
菜单栏installation—apply changes
选择Apply，安装过程中如果出现某些包download错误，可以重复apply
安装完成后可参考上一篇文档添加“系统环境变量”构建C语言编译环境
附：
1）mingw-get管理器或官网下载make-3.82.90-2-mingw32-cvs-20120902-bin.tar.lzma打包到安装目录的bin目录可支持WIndows环境下Makefile工程编译
2）mingw-get管理器或官网下载gdb-7.6.1-1-mingw32-bin.tar.lzma打包到安装目录的bin目录可支持gdb调试
3）http://www.vim.org/download.php网站可以下载Windows版本vim编辑器安装之后添加环境变量命令行使用
4）以上搭配可以在Windows的cmd命令行构建出实现类似linux命令行的编译环境
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ec6a171f0518e0f6727d1fad2e60cff/" rel="bookmark">
			sublime text3 安装插件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下载并安装sublime text3 1、官方网址下载：http://www.sublimetext.com/2
2、也可以下载我的免安装版本，直接解压就可以使用：https://pan.baidu.com/s/1nwCwHy5
相关链接：
Sublime Text 不提醒更新的方法 安装Package Control组件 按Ctrl+`调出console（或者点击view-&gt;show console）粘贴以下代码到底部命令行并回车：(以下代码参见https://sublime.wbond.net/installation)
import urllib.request,os,hashlib; h = '7183a2d3e96f11eeadd761d777e62404' + 'e330c659d4bb41d3bdf022e94cab3cd0'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://sublime.wbond.net/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); print('Error validating download (got %s instead of %s), please try manual install' % (dh, h)) if dh != h else open(os.path.join( ipp, pf), 'wb' ).write(by)重启 Sublime破解码： ** 注册Sublime Text可以让更新提示不再跳出：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ec6a171f0518e0f6727d1fad2e60cff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3be2467f7e55228fddf1f81f8c232cab/" rel="bookmark">
			responsebody.contentLength()获取到的值为-1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 最近在使用OKhttp下载文件的时候出现了一个奇怪的现象，responsebody.contentLength()获取到的值为-1 经常抓包分析，发现服务器会随机的对下发的资源做GZip操作，而此时就没有相应的content-length，解决方法很简单，在Header中加入：Request.Builder().addHeader("Accept-Encoding", "identity") 这样强迫服务器不走压缩，问题就得到了解决。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56dc301ab3f2df80d9491c1ed6d2805d/" rel="bookmark">
			支付宝 APP登录 获取用户信息  PHP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		支付宝APP登录服务端流程如下： 1、换取授权访问令牌 2、查询用户信息
APP调用sdk组装授权登录请求（系统交互流程），成功后，支付宝会返回 auth_code，利用此 auth_code 请求 PHP，PHP接收到参数后，先利用 auth_code 获取到 授权访问令牌 access_token（接口文档），再根据 access_token 来获取用户信息（接口文档）。
具体代码如下：
try { $code = trim($_POST['auth_code']); if (empty($code)) { throw new Exception('缺少参数', 0); } //获取access_token $aop = new AopClient (); $aop-&gt;gatewayUrl = 'https://openapi.alipay.com/gateway.do'; $aop-&gt;appId = $alipay_config['app_id']; $aop-&gt;rsaPrivateKey = trim($alipay_config['application_private']); $aop-&gt;format = 'json'; $aop-&gt;charset = 'UTF-8'; $aop-&gt;signType = 'RSA2'; $aop-&gt;alipayrsaPublicKey = trim($alipay_config['alipay_public']); $aop-&gt;apiVersion = '1.0'; $request = new AlipaySystemOauthTokenRequest(); $request-&gt;setGrantType("authorization_code"); $request-&gt;setCode($code); $result = $aop-&gt;execute($request); $responseNode = str_replace("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/56dc301ab3f2df80d9491c1ed6d2805d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7949b67e911eccfeaeb6772f36d8c7d4/" rel="bookmark">
			主成分分析（PCA）一次讲个够
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PCA 简介
多元统计分析中普遍存在的困难中，有一个困难是多元数据的可视化。matlab 中的 plot 可以显示两个变量之间的关系，plot3 和surf 可以显示三维的不同。但是当有多于3个变量时，要可视化变量之间的关系就很困难了。
幸运的是，在一组多变量的数据中，很多变量常常是一起变动的。一个原因是很多变量是同一个驱动影响的结果。在很多系统中，只有少数几个这样的驱动，但是多余的仪器使我们测量了很多的系统变量。当这种情况发生的时候，你需要处理的就是冗余的信息。而你可以通过用一个简单的新变量代替这组变量来简化此问题。
PCA 是一种较为常用的降维技术，PCA 的思想是将n维特征映射到k维上，这k维是全新的正交特征。这k维特征称为主元，是重新构造出来的k维特征。在 PCA 中，数据从原来的坐标系转换到新的坐标系下，新的坐标系的选择与数据本身是密切相关的。其中，第一个新坐标轴选择的是原始数据中方差最大的方向，第二个新坐标轴选取的是与第一个坐标轴正交且具有最大方差的方向，依次类推，我们可以取到这样的k个坐标轴。
PCA 操作流程
去均值，即每一位特征减去各自的平均值（当然，为避免量纲以及数据数量级差异带来的影响，先标准化是必要的）计算协方差矩阵计算协方差矩阵的特征值与特征向量对特征值从大到小排序保留最大的k个特征向量将数据转换到k个特征向量构建的新空间中 PCA 实例
考虑到实例的简洁性，这里只用二维数据。
假设二维数据为 data:
取均值：
去均值矩阵： 计算其协方差矩阵： 计算协方差矩阵的特征值和特征向量： 特征值为：
特征向量为：
对特征值进行排序（只有两个特征）
选择最大的特征值对应的特征向量：
转换到新的空间
由此，便实现了 PCA 降维操作。
MATLAB 实现 PCA
上面已经对 PCA 的算法过程做了详细说明，这里只针对 MATLAB 中的 PCA 函数作介绍并加以实例说明(详情也可参考 MATLAB 的PCA 文档，官方文档更加细致)：
[coef,score,latent] = pca(x); x：为要输入的 n 维原始数据。带入这个 matlab 自带函数，将会生成新的 n 维加工后的数据（即 score）。此数据与之前的 n 维原始数据一一对应。
score：生成的n维加工后的数据存在 score 里。它是对原始数据进行的分析，进而在新的坐标系下获得的数据。他将这 n 维数据按贡献率由大到小排列。（即在改变坐标系的情况下，又对 n 维数据排序）。
latent：是一维列向量，每一个数据是对应 score 里相应维的贡献率，因为数据有 n 维所以列向量有n个数据。由大到小排列（因为 score 也是按贡献率由大到小排列）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7949b67e911eccfeaeb6772f36d8c7d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f1155117920b8de47c6a4a0ec39ac17/" rel="bookmark">
			本地windows环境，phpStudy上wordPress的部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 （一）下载phpStudy的压缩包
下载网址：http://phpstudy.net/download.html
选择33MB的解压版
（二）下载wordPress压缩包
最新的wordPress压缩包下载：https://wordpress.org/latest.zip
或者上wordPress官网下载：https://wordpress.org/download/
（三）phpStudy安装
直接解压phpStudy的压缩包，然后点击其中的.exe文件，解压目标文件夹保持默认即可，也可以自行更改文件夹。然后等待安装成功即可！
→ 安装完成后，在托盘右下角就可以看到它的图标了：
（四）在phpStudy上添加wordPress项目
在phpStudy的图标上鼠标右键点击，在菜单中点击“网站根目录”，删除其中的 l.php 和 phpinfo.php。
再把刚才解压的wordPress的文件夹里的所有文件复制黏贴到这个网站根目录中;
（五）新建wordPress数据库
打开 http://localhost/phpMyAdmin ，使用用户名 root ，密码 root ，登录。
登录后，单击上方的 tab 中的 SQL，输入如下代码，并单击“执行”按钮：
create database wordPress; 这时就创建好了一个wordPress数据库了。
（六）安装wordPress
打开http://localhost，开始安装wordPress数据库：
数据库名：wordPress
账户密码都是root
其他不需要修改
然后确认安装...
接着填写相关信息：
① 用户名确定后不能修改，只在后台显示，之后的博客前台可以设置“昵称”
② 密码默认是自动生成的复杂密码，安全性高，也可以自己设置，记得要好好保存！
③ 邮箱必填，不验证，是之后可以修改的。可以用来接收博客收到的评论消息。
（七）完成
完成后自动跳转到http://localhost/wp-admin/，也就是管理界面，可以开始管理wordPress项目了。
以上就是本地的windoows环境下，在phpStudy上部署wordPress的过程。
学习网址：http://gitbook.cn/gitchat/column/5a16601f13c02f4a35c9f8ad（《Gitchat-白宦成的达人课》） 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/586a81ae3ded43e5f0d3e2a1e416c7ca/" rel="bookmark">
			sklearn库中的标准数据集及基本功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【sklearn库】 sklearn是scikit-learn的简称，是一个基于Python的第三方模块。sklearn库集成了一些常用的机器学习方法，在进行机器学习任务是，并不需要实现算法，只需要简单的调用sklearn库中提供的模块就能完成大多数的机器学习任务。
sklearn库是在numpy、scipy、matplotlib的基础上开发而成的，在安装sklearn之前需要先安装这些依赖库。
Numpy（Numerical python的缩写）是一个开源的Python科学计算库。
Scipy库是sklearn库的基础，它是基于Numpy的一个集成了多种数学算法和函数的Python模块。
matplotlib是基于Numpy的一套Python工具包，它提供了大量的数据绘图工具。
【sklearn库中的标准数据集】 数据集总览
数据集名称
调用方式
适用算法
数据规模
小
波士顿房价数据集
load_boston()
回归
506*13
鸢尾花数据集
load_iris()
分类
150*4
数
据
糖尿病数据集
load_diabetes()
回归
442*10
集
手写数字数据集
load_digits()
分类
5620*64
大
Olivetti 脸部图像数据集
fetch_olivetti_faces()
降维
400*64*64
数
新闻分类数据集
fetch_20newsgroups()
分类
-
据
带标签的人脸数据集
fetch_lfw_people()
分类；降维
-
集
路透社新闻语料数据集
fetch_rcv1()
分类
804414*47236
注：小数据集可以直接使用，大数据集要在调用时程序自动下载（一次即可）。
【波士顿房价数据集】 波士顿房价数据集包含506组数据，每条数据包含房屋以及房屋周围的详细信息。其中包括城镇犯罪率、一氧化氮浓度、住宅平均房间数、到中心区域的加权距离以及自住房平均房价等。因此，波士顿房价数据集能够应用到回归问题上。
-----------------------波士顿房价数据集-----------------------
波士顿房价数据集-属性描述
CRIM：城镇人均犯罪率。
ZN：住宅用地超过 25000 sq.ft. 的比例。
INDUS：城镇非零售商用土地的比例。
CHAS：查理斯河空变量（如果边界是河流，则为1；否则为0）
NOX：一氧化氮浓度。
RM：住宅平均房间数。
AGE：1940 年之前建成的自用房屋比例。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/586a81ae3ded43e5f0d3e2a1e416c7ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b66f4adbd358133b59104cef019d796/" rel="bookmark">
			Node&#43;OCR（图像文字识别）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开发目的 这算是node应用的第二个小应用吧，主要目的是熟悉node和express框架。原理很简单：在node搭建的环境下引用第三方包处理图片数据并返回给前台信息。 实现效果，百度提供的图片识别，经过测试识别车牌号等规范文字数字还是比较准确的
环境需求 1.Express 是一个非常流行的node.js的web框架。基于connect(node中间件框架)。提供了很多便于处理http请求等web开发相关的扩展。 2.OCR： 通用文字识别 Node SDK目录结构：
├── src │ ├── auth //授权相关类 │ ├── http //Http通信相关类 │ ├── client //公用类 │ ├── util //工具类 │ └── const //常量类 ├── AipOcr.js //通用文字识别交互类 ├── index.js //入口文件 └── package.json //npm包描述文件 支持 node 版本 4.0+ 直接使用node开发包步骤如下： 1.在官方网站下载node SDK压缩包。 2.将下载的aip-node-sdk-version.zip解压后，复制到工程文件夹中。 3.进入目录，运行npm install安装sdk依赖库 4.把目录当做模块依赖 其中，version为版本号，添加完成后，用户就可以在工程中使用通用文字识别 Node SDK。 直接使用npm安装依赖： npm install baidu-aip-sdk（尝试没有成功）
AipOcrClient是Optical Character Recognition的node客户端，为使用Optical Character Recognition的开发人员提供了一系列的交互方法。 用户可以参考如下代码新建一个AipOcrClient： var AipOcrClient = require("baidu-aip-sdk").ocr; // 设置APPID/AK/SK var APP_ID = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b66f4adbd358133b59104cef019d796/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9480bc6070a72638f6c0a9730d5a54f/" rel="bookmark">
			提问的智慧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在黑客世界里，当提出一个技术问题时，你能得到怎样的回答？这取决于挖出答案的难度，同样取决于你提问的方法。本指南旨在帮助你提高发问技巧，以获取你最想要的答案。
首先你必须明白，黑客们只偏爱艰巨的任务，或者能激发他们思维的好问题。 如若不然，我们还来干吗？如果你有值得我们反复咀嚼玩味的好问题，我们自会对你感激不尽。好问题是激励，是厚礼，可以提高我们的理解力，而且通常会暴露我们以前从没意识到或者思考过的问题。对黑客而言，“问得好！”是发自内心的大力称赞。
尽管黑客们有蔑视简单问题和不友善的坏名声，有时看起来似乎我们对新手，对知识贫乏者怀有敌意，但其实不是那样的。
我们不想掩饰对这样一些人的蔑视--他们不愿思考，或者在发问前不去完成他们应该做的事。这种人只会谋杀时间--他们只愿索取，从不付出，无端消耗我们的时间，而我们本可以把时间用在更有趣的问题或者更值得回答的人身上。 我们称这样的人为“失败者”（由于历史原因，我们有时把它拼作“lusers”）。
我们在很大程度上属于志愿者，从繁忙的生活中抽出时间来解惑答疑，而且时常被提问淹没。所以我们无情的滤掉一些话题，特别是抛弃那些看起来象失败者的家伙，以便更高效的利用时间来回答胜利者的问题。
如果你觉得我们过于傲慢的态度让你不爽，让你委屈，不妨设身处地想想。我们并没有要求你向我们屈服--事实上，我们中的大多数人最喜欢公平交易不过了，只要你付出小小努力来满足最起码的要求，我们就会欢迎你加入到我们的文化中来。但让我们帮助那些不愿意帮助自己的人是没有 意义的。如果你不能接受这种“歧视”，我们建议你花点钱找家商业公司签个技术支持协议得了，别向黑客乞求帮助。
如果你决定向我们求助，当然不希望被视为失败者，更不愿成为失败者中的一员。立刻得到有效答案的最好方法，就是象胜利者那样提问 —— 聪明、自信、有解决问题的思路，只是偶尔在特定的问题上需要获得一点帮助。
（欢迎对本指南提出改进意见。任何建议请E-mail至esr@thyrsus.com，然而 请注意，本文并非网络礼节的通用指南，我通常会拒绝无助于在技术论坛得到有用答案的建议。） （当然，如果你写中文，最好还是寄DHGrand@hotmail.com;-）
= 提问之前 =
在通过电邮、新闻组或者聊天室提出技术问题前，检查你有没有做到：
1. 通读手册，试着自己找答案。 2. 在FAQ里找答案（一份维护得好的FAQ可以包罗万象:）。 3. 在网上搜索（个人推荐google~~~）。 4. 向你身边精于此道的朋友打听。
当你提出问题的时候，首先要说明在此之前你干了些什么；这将有助于树立你的形象：你不是一个妄图不劳而获的乞讨者，不愿浪费别人的时间。如果提问者能从答案中学到东西，我们更乐于回答他的问题。
周全的思考，准备好你的问题，草率的发问只能得到草率的回答，或者根本得不到任何答案。越表现出在寻求帮助前为解决问题付出的努力，你越能得到实质性的帮助。
小心别问错了问题。如果你的问题基于错误的假设，普通黑客（J. Random Hacker）通常会用无意义的字面解释来答复你，心里想着“蠢问题...”，希望着你会从问题的回答（而非你想得到的答案）中汲取教训。
决不要自以为够资格得到答案，你没这种资格。毕竟你没有为这种服务支付任何报酬。你要自己去“挣”回一个答案，靠提出一个有内涵的，有趣的，有思维激励作用的问题--一个对社区的经验有潜在贡献的问题，而不仅仅是被动的从他人处索要知识--去挣到这个答案。
另一方面，表明你愿意在找答案的过程中做点什么，是一个非常好的开端。“谁能给点提示？”、“我这个例子里缺了什么？”以及“我应该检查什么地方？”比“请把确切的过程贴出来”更容易得到答复。因为你显得只要有人指点正确的方向，你就有完成它的能力和决心。
= 怎样提问 =
- 谨慎选择论坛 小心选择提问的场合。如果象下面描述的那样，你很可能被忽略掉或者被看作失败者：
1. 在风马牛不相及的论坛贴出你的问题 2. 在探讨高级技巧的论坛张贴非常初级的问题；反之亦然 3. 在太多的不同新闻组交叉张贴
- 用辞贴切，语法正确，拼写无误 我们从经验中发现，粗心的写作者通常也是马虎的思考者（我敢打包票）。 回答粗心大意者的问题很不值得，我们宁愿把时间耗在别处。
正确的拼写，标点符号和大小写很重要。 更一般的说，如果你的提问写得象个半文盲，你很有可能被忽视。
如果你在使用非母语的论坛提问，你可以犯点拼写和语法上的小错--但决不能在思考上马虎（没错，我们能弄清两者的分别）
- 使用含义丰富，描述准确的标题 在邮件列表或者新闻组中，大约50字以内的主题标题是抓住资深专家注意力 的黄金时机。别用喋喋不休的“帮帮忙”（更别说“救命啊！！！！！”这 样让人反感的话）来浪费这个机会。不要妄想用你的痛苦程度来打动我们， 别用空格代替问题的描述，哪怕是极其简短的描述。
蠢问题： 救命啊！我的膝上机不能正常显示了！ 聪明问题： XFree86 4.1下鼠标光标变形，Fooware MV1005的显示芯片。
如果你在回复中提出问题，记得要修改内容标题，表明里面有一个问题。一个看起来象“Re：测试”或者“Re：新bug”的问题很难引起足够重视。另外，引用并删减前文的内容，给新来的读者留下线索。
- 精确描述，信息量大
1. 谨慎明确的描述症状。 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d9480bc6070a72638f6c0a9730d5a54f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab27530728d586862fb2b1394c499e3f/" rel="bookmark">
			ssm框架下JUnit测试报错，跪求办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		严重: Caught exception while allowing TestExecutionListener [org.springframework.test.context.support.DependencyInjectionTestExecutionListener@3020ad] to prepare test instance [com.test.MapperTest@e8c7db] java.lang.IllegalStateException: Failed to load ApplicationContext at org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate.loadContext(DefaultCacheAwareContextLoaderDelegate.java:124) at org.springframework.test.context.support.DefaultTestContext.getApplicationContext(DefaultTestContext.java:83) at org.springframework.test.context.support.DependencyInjectionTestExecutionListener.injectDependencies(DependencyInjectionTestExecutionListener.java:117) at org.springframework.test.context.support.DependencyInjectionTestExecutionListener.prepareTestInstance(DependencyInjectionTestExecutionListener.java:83) at org.springframework.test.context.TestContextManager.prepareTestInstance(TestContextManager.java:230) at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.createTest(SpringJUnit4ClassRunner.java:228) at org.springframework.test.context.junit4.SpringJUnit4ClassRunner$1.runReflectiveCall(SpringJUnit4ClassRunner.java:287) at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12) at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.methodBlock(SpringJUnit4ClassRunner.java:289) at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:247) at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:94) at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290) at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71) at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288) at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58) at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268) at org.springframework.test.context.junit4.statements.RunBeforeTestClassCallbacks.evaluate(RunBeforeTestClassCallbacks.java:61) at org.springframework.test.context.junit4.statements.RunAfterTestClassCallbacks.evaluate(RunAfterTestClassCallbacks.java:70) at org.junit.runners.ParentRunner.run(ParentRunner.java:363) at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.run(SpringJUnit4ClassRunner.java:191) at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:50) at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:467) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:683) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:390) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:197) Caused by: org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab27530728d586862fb2b1394c499e3f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09eeb6927ac79dd1771706af6e360387/" rel="bookmark">
			RS485芯片介绍及典型应用电路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、RS485基本知识
RS-485接口芯片已广泛应用于工业控制、仪器、仪表、多媒体网络、机电一体化产品等诸多领域。可用于RS-485接口的芯片种类也越来越多。如何在种类繁多的接口芯片中找到最合适的芯片，是摆在每一个使用者面前的一个问题。RS-485接口在不同的使用场合，对芯片的要求和使用方法也有所不同。使用者在芯片的选型和电路的设计上应考虑哪些因素，由于某些芯片的固有特性，通信中有些故障甚至还需要在软件上作相应调整，如此等等。希望本文对解决RS-485接口的某些常见问题有所帮助。
1 RS-485接口标准
传输方式：差分
传输介质：双绞线
标准节点数：32
最远通信距离：1200m 共模电压最大、最小值：+12V；-7V
差分输入范围：-7V～+12V
接收器输入灵敏度：±200mV
接收器输入阻抗：≥12kΩ
2 节点数及半双工和全双工通信
2.1 节点数
所谓节点数，即每个RS-485接口芯片的驱动器能驱动多少个标准RS-485负载。根据规定，标准RS-485接口的输入阻抗为≥12kΩ，相应的标准驱动节点数为32。为适应更多节点的通信场合，有些芯片的输入阻抗设计成1/2负载（≥24kΩ）、1/4负载（≥48kΩ）甚至1/8负载（≥96kΩ），相应的节点数可增加到64、128和256。表1为一些常见芯片的节点数。
表1
节点数 型 号32SN75176，SN75276，SN75179，SN75180，MAX485，MAX488，MAX49064SN75LBC184128MAX487，MAX1487256MAX1482，MAX1483，MAX3080～MAX3089 2.2 半双工和全双工 RS-485接口可连接成半双工和全双工两种通信方式。半双工通信的芯片有SN75176、SN75276、SN75LBC184、MAX485、MAX 1487、MAX3082、MAX1483等；
全双工通信的芯片有SN75179、SN75180、MAX488~MAX491、MAX1482等。 （a）半双工通信电路
（b）全双工通信电路
3 应用中的常见问题
3.1 抗雷击和抗静电冲击
RS-485接口芯片在使用、焊接或设备的运输途中都有可能受到静电的冲击而损坏。在传输线架设于户外的使用场合，接口芯片乃至整个系统还有可能遭致雷电的袭击。选用抗静电或抗雷击的芯片可有效避免此类损失，常见的芯片有MAX485E、MAX487E、MAX1487E等。特别值得一提的是SN75LBC184，它不但能抗雷电的冲击而且能承受高达8kV的静电放电冲击，是目前市场上不可多得的一款产品。
3.2 限斜率驱动
由于信号在传输过程中会产生电磁干扰和终端反射，使有效信号和无效信号在传输线上相互迭加，严重时会使通信无法正常进行。为解决这一问题，某些芯片的驱动器设计成限斜率方式，使输出信号边沿不要过陡，以不致于在传输线上产生过多的高频分量，从而有效地扼制干扰的产生。如MAX487、SN75LBC184等都具有此功能。 3.3 故障保护
故障保护技术是近两年产生的，一些新的RS-485芯片都采用了此项技术，如SN75276、MAX3080~MAX3089。什么是故障保护，为什么要有故障保护，如果没有故障保护会产生什么后果？
众所周知，RS-485接口采用的是一种差分传输方式，各节点之间的通信都是通过一对（半双工）或两对（全双工）双绞线作为传输介质。根据RS-485的标准规定，接收器的接收灵敏度为±200mV，即接收端的差分电压大于、等于+200 mV时，接收器输出为高电平；小于、等于-200mV时，接收器输出为低电平；介于±200mV之间时，接收器输出为不确定状态。在总线空闲即传输线上所有节点都为接收状态以及在传输线开路或短路故障时，若不采取特殊措施，则接收器可能输出高电平也可能输出低电平。一旦某个节点的接收器产生低电平就会使串行接收器（UART）找不到起始位，从而引起通信异常，解决此类问题的方法有两种：
（1）使用带故障保护的芯片，它会在总线开路、短路和空闲情况下，使接收器的输出为高电平。确保总线空闲、短路时接收器输出高电平是由改变接收器输入门限来实现的。例如，MAX3080～MAX 3089输入灵敏度为-50mV/-200mV，即差分接收器输入电压UA－B≥-50mV时，接收器输出逻辑高电平；如果UA－B≤-200mV，则输出逻辑低电平。当接收器输入端总线短路或总线上所有发送器被禁止时，接收器差分输入端为0V，从而使接收器输出高电平。同理，SN75276的灵敏度为0mV/-300mV，因而达到故障保护的目的。
（2）若使用不带故障保护的芯片，如SN75176、MAX1487等时，可在软件上作一些处理，从而避免通信异常。即在进入正常的数据通信之前，由主机预先将总线驱动为大于+200mV，并保持一段时间，使所有节点的接收器产生高电平输出。这样，在发出有效数据时，所有接收器能够正确地接收到起始位，进而接收到完整的数据。 3.4 光电隔离
在某些工业控制领域，由于现场情况十分复杂，充分考虑现场的复杂环境，在电路设计中注意了以下三个问题。
二、RS485应用设计
1 SN75176 485芯片DE控制端的设计 由于应用系统中，主机与分机相隔较远，通信线路的总长度往往超过400米，而分机系 统上电或复位又常常不在同一个时刻完成。如果在此时某个75176的DE端电位为“１”，那 么它的485总线输出将会处于发送状态，也就是占用了通信总线，这样其它的分机就无法与 主机进行通信。这种情况尤其表现在某个分机出现异常情况下（死机），会使整个系统通信 崩溃。因此在电路设计时，应保证系统上电复位时75176的DE端电位为“0”。由于8031在复 位期间，I/O口输出高电平，故图2电路的接法有效地解决复位期间分机“咬”总线的问题。 2 隔离光耦电路的参数选取 在应用系统中，由于要对现场情况进行实时监控及响应，通信数据的波特率往往做得较高（通常都在4800波特以上）。限制通信波特率提高的“瓶颈”，并不是现场的导线（现场施工一般使用5类非屏蔽的双绞线），而是在与单片机系统进行信号隔离的光耦电路上。此处采用TIL117。电路设计中可以考虑采用高速光耦，如6N137、6N136等芯片，也可以优化普通光耦电路参数的设计，使之能工作在最佳状态。例如：电阻R2、R3如果选取得较大，将会使光耦的发光管由截止进入饱和变得较慢；如果选取得过小，退出饱和也会很慢，所以这两只电阻的数值要精心选取，不同型号的光耦及驱动电路使得这两个电阻的数值略有差异，这一点在电路设计中要特别慎重，不能随意，通常可以由实验来定。 3 485总线输出电路部分的设计 输出电路的设计要充分考虑到线路上的各种干扰及线路特性阻抗的匹配。由于工程环境比较复杂，现场常有各种形式的干扰源，所以485总线的传输端一定要加有保护措施。在电路设计中采用稳压管D1、D2组成的吸收回路，也可以选用能够抗浪涌的TVS瞬态杂波抑制器件，或者直接选用能抗雷击的485芯片（如SN75LBC184等）。 考虑到线路的特殊情况（如某一台分机的485芯片被击穿短路），为防止总线中其它分机的通信受到影响，在75176的485信号输出端串联了两个20Ω的电阻R10、R11。这样本机的硬件故障就不会使整个总线的通信受到影响。 在应用系统工程的现场施工中，由于通信载体是双绞线，它的特性阻抗为120Ω左右，所以线路设计时，在RS-485网络传输线的始端和末端各应接1只120Ω的匹配电阻（如图1中R8），以减少线路上传输信号的反射。 由于RS-485芯片的特性，接收器的检测灵敏度为± 200mV，即差分输入端VA－VB ≥+200mV，输出逻辑1，VA－VB ≤－200mV，输出逻辑0；而A、B端电位差的绝对值小于200mV时，输出为不确定。如果在总线上所有发送器被禁止时，接收器输出逻辑0，这会误认为通信帧的起始引起工作不正常。解决这个问题的办法是人为地使A端电位高于B两端电位，这样RXD的电平在485总线不发送期间（总线悬浮时）呈现唯一的高电平，8031单片机就不会被误中断而收到乱字符。通过在485电路的A、B输出端加接上拉、下拉电阻R7、R9，即可很好地解决这个问题。 图1 RS485应用典型电路 三、软件的编程 485芯片的软件编程对产品的可靠性也有很大影响。由于485总线是异步半双工的通信总线，在某一个时刻，总线只可能呈现一种状态，所以这种方式一般适用于主机对分机的查询方式通信，总线上必然有一台始终处于主机地位的设备在巡检其它的分机，所以需要制定一套合理的通信协议来协调总线的分时共用。这里采用的是数据包通信方式。通信数据是成帧成包发送的，每包数据都有引导码、长度码、地址码、命令码、内容、校验码等部分组成。 其中引导码是用于同步每一包数据的引导头；长度码是这一包数据的总长度；命令码是主机对分机（或分机应答主机）的控制命令；地址码是分机的本机地址号；“内容”是这一包数据里的各种信息；校验码是这一包数据的校验标志，可以采用奇偶校验、和校验等不同的方式。 在485芯片的通信中，尤其要注意对485控制端DE的软件编程。为了可靠的工作，在485总线状态切换时需要做适当延时，再进行数据的收发。具体的做法是在数据发送状态下，先将控制端置“1”，延时1ms左右的时间，再发送有效的数据，一包数据发送结束后再延时1ms后，将控制端置“0”。这样的处理会使总线在状态切换时，有一个稳定的工作过程。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/09eeb6927ac79dd1771706af6e360387/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b4baa5378e0c3cd79ae8073d2fe44d4/" rel="bookmark">
			C语言标准I/O库中流的读写与定位
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		不同于像read,write这样围绕文件描述符进行直接I/O的函数，C语言标准I/O库中的操作都是围绕流进行的。当我们打开或创建一个文件时，就会将一个流与该文件关联。 在流式的I/O操作中，系统会为操作分配缓冲区，以减少对read、write的调用次数。这是因为read、write是系统调用，调用所耗费的时间要大于普通的函数调用，为什么更耗时我是这样理解的：read、write针对的是文件也即是磁盘中数据的读写操作，而缓冲区则是在内存中开辟的一块空间，显然计算机对于内存的读写操作是要快于磁盘的。通过缓冲区这样的机制，我们可以提高对于文件的频繁读写操作的效率。 流式的I/O并不总是能提高效率，比如我们要将一个远大于缓冲区容量的数据块一次性写入或读出文件时，缓冲区的机制反而会使系统调用的次数增加，使得效率降低。 当打开一个流时，fopen函数会返回一个文件指针(FILE*), FILE对象是一个结构，里面存放着管理一个流所相关的信息，包括用于实际I/O的文件描述符、指向该流缓冲区的指针、缓冲区大小、及缓冲区中当前的字符数等。而标准I/O库中的函数则都是围绕文件指针进行的。
下面用一段代码展示用于流的读写及定位的几个函数的使用方法。
#include &lt;stdio.h&gt; #include &lt;string.h&gt; int main() { FILE *fp; //定义一个文件指针 char s1[10], s2[] = "abc"; long offset; //变量offset用于记录文件偏移量 fp = fopen("text", "w+"); //以读写的方式创建并打开一个文件 fputs(s2, fp); //将s2写入文件 rewind(fp); //将文件位置设置在起始位置 fgets(s1, sizeof(s1), fp); //从文件读取数据到s1 fputs(s1, stdout); //将s1写入标准输出 putchar('\n'); offset = ftell(fp); //获取当前的文件位置 strcpy(s1,"bcd"); fputs(s1, fp); fseek(fp, 0, SEEK_SET); //将文件位置设置为起始位置 //对于文本文件，一定要选用参数SEEK_SET fgets(s1, sizeof(s1), fp); fputs(s1, stdout); putchar('\n'); fseek(fp, offset, SEEK_SET); //将文件位置设置为offset所指位置 fgets(s1, sizeof(s1), fp); fputs(s1, stdout); putchar('\n'); return 0; } 输出结果
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b4baa5378e0c3cd79ae8073d2fe44d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42ddf1bb6411f7af8210a1003f79426c/" rel="bookmark">
			Springboot项目搭建有ftpClientPool的Ftp工具类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 前言 最近项目中用到了FTP，于是自己写了一个FTP工具类，现将其分享出来，供大家借鉴使用。 FTP工具类的实现可以分为两部分： 基于apache commons-pool2的ObjectPool接口构建了ftpClientPool（ftpClient对象池），以达到FTPClient的复用，减少频繁创建FTPClient对象而造成的性能开销； FTP工具类中的方法从ftpClientPool中获取FTPClient，可以实现线程安全的并发访问FTP服务器。 现将其实现细节做如下分享。
2 添加依赖与ftp连接参数 在springboot项目中添加依赖：
&lt;dependency&gt; &lt;groupId&gt;commons-net&lt;/groupId&gt; &lt;artifactId&gt;commons-net&lt;/artifactId&gt; &lt;version&gt;3.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt; &lt;version&gt;2.4.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--添加项目需要的其他依赖...--&gt; 在配置文件application.properties中添加ftp连接参数
#ftp config ftp.enabled=true ftp.host=localhost ftp.port=21 ftp.username=ftpuser ftp.password=ftpuser 3 添加FTP配置类 FTPClient配置类如下：
import javax.annotation.PreDestroy; import org.apache.commons.net.ftp.FTPClient; import org.apache.commons.pool2.ObjectPool; import org.apache.commons.pool2.PooledObject; import org.apache.commons.pool2.PooledObjectFactory; import org.apache.commons.pool2.impl.DefaultPooledObject; import org.apache.commons.pool2.impl.GenericObjectPool; import org.apache.commons.pool2.impl.GenericObjectPoolConfig; import org.springframework.boot.autoconfigure.condition.ConditionalOnClass; import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty; import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.boot.context.properties.EnableConfigurationProperties; import org.springframework.context.annotation.Configuration; import com.wxyh.springbootdemo.common.utils.FtpUtil; import lombok.Data; import lombok.extern.slf4j.Slf4j; /** * FTP配置类 * * @author wxyh */ @Slf4j @Configuration @ConditionalOnClass({GenericObjectPool.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/42ddf1bb6411f7af8210a1003f79426c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b378330473d2970e127120cb9f294985/" rel="bookmark">
			.net实现个人信息登录界面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		新建一个MVC项目，利用HTML、CSS、JS、jQuery、Ajax、jQuery UI等技术设计一个个人信息注册页面。当点击“提交”按钮时，跳转到新的页面显示录入信息。
基本要求：
用户名为6-10个小写字母（小写使用正则式验证，且用户名不能为“wustzz” –通过后台用Ajax技术来检测）；密码为6位数字，确认密码不一致时有提示；籍贯使用级联（jquery实现）；Email必须符合Email格式；手机是11位（假设规定以1569开头）；出生年月使用jQuery UI日历组件设置。
视图代码：
@{
ViewBag.Title = "Index1";
}
&lt;font size="6" face="黑体" color="red"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;请输入个人详细信息&lt;/font&gt;
&lt;script&gt;
function checkpsd1() {
var u = document.getElementById("psd1");
var t = document.getElementById("tip2");
var reg = /^[0-9]{6}$/;
if (u == null || u.value.length == 0) {
t.innerHTML = "密码必填，不能为空";
}
else if (!reg.test(u.value)) {
t.innerHTML = "密码为6位数字";
}
else {
t.innerHTML = "";
}
}
function checkpsd2() {
var u = document.getElementById("psd2");
var t = document.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b378330473d2970e127120cb9f294985/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a957740434c73a557e3b541f482c387/" rel="bookmark">
			Docker实现CentOS容器SSH远程登录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里根据Dockerfile方式构建一个CentOS的可远程SSH的镜像。
Dockerfile文件 在/data/test/sshd_centos/目录下新建Dockerfile文件。注意：目录可以自行设定，但目录下除了Dockerfile文件外建议不要放置别的文件和目录。
vim Dockerfile # 生成的新镜像以centos镜像为基础 FROM centos # 指定作者信息 MAINTAINER by Test # 安装openssh-server RUN yum -y install openssh-server RUN mkdir /var/run/sshd RUN ssh-keygen -t rsa -f /etc/ssh/ssh_host_rsa_key RUN ssh-keygen -t dsa -f /etc/ssh/ssh_host_dsa_key # 指定root密码 RUN /bin/echo 'root:123456'|chpasswd RUN /bin/sed -i 's/.*session.*required.*pam_loginuid.so.*/session optional pam_loginuid.so/g' /etc/pam.d/sshd RUN /bin/echo -e "LANG=\"en_US.UTF-8\"" &gt; /etc/default/local EXPOSE 22 CMD /usr/sbin/sshd -D build镜像 在Dockerfile当前目录执行下面语句，开始构建镜像。注意最后面的点不要忘了，表明是读取当前目录的Dockerfile文件。
docker build -t bigdata/centos-ssh:v1.0.0 . bigdata/centos-ssh:v1.0.0：新生成的镜像名称及版本号
打包成功的话会出现下面的提示，可能时间会有点长，耐心等待。
Successfully built 2d548392b205 查看镜像 docker images 启动容器 docker run -itd -p 10022:22 --name test_centos_1 sshd/centos:v1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a957740434c73a557e3b541f482c387/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e8d78616e175aeeb1045c6a8b407bb3/" rel="bookmark">
			循环、递归、遍历、迭代的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		表示“重复”这个含义的词有很多, 比如 循环(loop), 递归(recursion), 遍历(traversal), 迭代(iterate). 循环算是最基础的概念, 凡是重复执行一段代码, 都可以称之为循环. 大部分的递归, 遍历, 迭代, 都是循环. 递归是重复调用函数自身实现循环。迭代是函数内某段代码实现循环，而迭代与普通循环的区别是：循环代码中参与运算的变量同时是保存结果的变量，当前保存的结果作为下一次循环计算的初始值。
// 迭代，重复一定的算法，达到想要的目的。数学上二分法，牛顿法是很好的迭代例子 function iteration(x){ var sum=1; for(x; x&gt;=1; x--){ sum = sum*x; } } // 递归，自身调用自身的迭代就是递归。
// 但是正式定义好像不是这么说的。这只是我个人理解
function recursion(x){
if(x&gt;1){
return x*recursion(x-1);
}else{
return 1;
}
}
迭代式开发：迭代式开发应该是取自"迭代(数学)"的概念的, 意思是把开发过程划分成若干个小目标, 对每个小目标单独进行设计, 开发, 测试, 逐步地完成整个项目. 而传统的开发过程是纯线性的, 先统一设计, 再统一编码, 再统一测试. 相比于传统开发过程, 迭代式开发更灵活, 能够适应需求的变更, 及时验证设计的可行性等等的...
迭代开发更接近循环的意思，是指多次按照开发，测试，发布这样的周期循环来完成一个软件产品的最终发布。而不是试图一次性完成所有工作，发布最终版本
结论：
循环(loop) - 最基础的概念, 所有重复的行为
递归(recursion) - 在函数内调用自身, 将复杂情况逐步转化成基本情况
(数学)迭代(iterate) - 在多次循环中逐步接近结果
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e8d78616e175aeeb1045c6a8b407bb3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7003640b8604b20086c6856b7b4967b/" rel="bookmark">
			AutoPy教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、AutoPy的介绍和教程
1.1什么是AutoPy？
AutoPy是一个简单的跨平台GUI自动化工具包，适用于Python。它包括用于控制键盘和鼠标，在屏幕上查找颜色和位图以及显示警报的功能 - 所有这些都是以跨平台，高效和简单的方式进行的。适用于Mac OS X，Windows和X11。
二、AutoPy入门
2.1安装：
1、Windows安装包地址：http://pypi.python.org/pypi/autopy/.
2、使用easy_install安装：
Easy_install autopy
3、手动编译GitHub仓库的源码：
git clone git://github.com/msanders/autopy.git
cd autopy
python setup.py build
python setup.py install
2.2Hello World
代码如下：
def hello_theme_world():
autopy.alert.alert("hello,world")
hello_theme_world()
运行结果：
三、教程
3.1控制鼠标
AutoPy包含许多控制鼠标的功能。Document地址：http://www.autopy.org/documentation/
3.2控制鼠标简要教程
Autopy.mouse.move()
import autopy
autopy.mouse.move(1,1)
将鼠标快速移动到指定位置，尽管只导入了autopy，仍然可以使用autopy.mouse模块。为了更真实的移动鼠标，我们使用下面的方法。
Autopy.mouse.smooth_move()
import autopy
autopy.mouse.smooth_move(1,1)
我们可以编写我们自己的函数让鼠标在屏幕上做正弦波移动
import autopy
import math
import time
import random
TWO_PI=math.pi*2.0
def sine_mouse_wave():
'''
让鼠标以正弦波的形式从屏幕左边移到右边
'''
width,height=autopy.screen.get_size()
height/=2
height-=10 #留在屏幕边界
for x in xrange(width):
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f7003640b8604b20086c6856b7b4967b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae2c544c92150cb8e4e2b86a4965c0a2/" rel="bookmark">
			div 垂直居中的六种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		利用CSS进行元素的水平居中，比较简单，行级元素设置其父元素的text-align center，块级元素设置其本身的left 和 right margins为auto即可。本文收集了六种利用css进行元素的垂直居中的方法，每一种适用于不同的情况，在实际的使用过程中选择某一种方法即可。 Line-Height Method 试用：单行文本垂直居中，demo
代码：
html
1 2 3 &lt;div id="parent"&gt; &lt;div id="child"&gt;Text here&lt;/div&gt; &lt;/div&gt; css
1 2 3 #child { line-height: 200px; } 垂直居中一张图片，代码如下
html
1 2 3 &lt;div id="parent"&gt; &lt;img src="image.png" alt="" /&gt; &lt;/div&gt; css
1 2 3 4 5 6 #parent { line-height: 200px; } #parent img { vertical-align: middle; } CSS Table Method 适用：通用，demo
代码：
html
1 2 3 &lt;div id="parent"&gt; &lt;div id="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae2c544c92150cb8e4e2b86a4965c0a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8092f8c33b74f23a9eadb33dd2a0f16/" rel="bookmark">
			Linux中“Argument list too long”解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章作者：Tyan 博客：noahsnail.com | CSDN | 简书
1. 背景 Linux下使用cp，mv，rm等命令时经常会碰到“Argument list too long”错误，这主要是因为这些命令的参数太长，即文件个数过多。
2. 解决方案 “Argument list too long”这个问题的解决主要会用到两个命令，find和xargs。
2.1 问题：要删除test文件夹下以jpg结尾的文件。 命令1为： find test/ -name "*.jpg" | xargs -i rm {} 命令2为： find test/ -name "*.jpg" -exec rm {} \; 2.2 问题：要拷贝test文件夹下以jpg结尾的文件到train目录。 命令1为： find test/ -name "*.jpg" | xargs -i cp {} train 命令2为： find test/ -name "*.jpg" -exec cp {} train \; 3. 命令解析 find test/ -name "*.jpg"是指在test文件夹下查找名为*.jpg的文件。
xargs命令是给其他命令传递参数的一个过滤器，也是组合多个命令的一个工具。-i会将xargs的内容赋值给{}。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b8092f8c33b74f23a9eadb33dd2a0f16/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df390f671c48e0ff1065812cd33cfc05/" rel="bookmark">
			Docker 安装、操作常用命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Docker安装命令 Linux安装Docker // 仅此一条命令就可以搞定 yum -y install docker-io // 启动Docker // 同理，stop、restart意味着停止、重启Docker service docker start // 加入开机启动 chkconfig docker on 安装docker-compose pip install -U docker-compose Docker基本操作命令 创建容器 docker create ubuntu:latest 启动容器 docker start [CONTAINER ID] 新建并启动容器 // 启动容器输出hello world之后，容器自动终止 docker run ubuntu /bin/echo 'hello world' // 启动一个bash终端，允许用户进行交互 // -t 选项让Docker分配一个伪终端并绑定到容器的标准输出上 // -i 让容器的标准输入保持打开 // 使用 Ctrl+d 或 exit 退出容器 docker run -t -i ubuntu:latest /bin/bash // 容器以守护态运行，即后台运行 // -d 选项让Docker以守护态运行 // 运行成功会返回一个唯一的ID docker run -itd ubuntu 终止容器运行 docker stop [CONTAINER ID] 重启容器 docker restart [CONTAINER ID] 查看当前启动的容器信息 docker ps 查看当前终止的容器信息 // 仅显示CONTAINER ID docker ps -a -q //显示终止容器的详细信息 docker ps -a 进入容器 // 当容器使用 -d 选项后台运行之后，需要进入容器，可使用下面命令 // 该命令缺点：当多个窗口同时进入同一个容器时，所有窗口都会同步显示，当某个窗口因命令阻塞时，其他窗口 // 也无法执行操作了 docker attach [CONTAINER ID] // 更好的选择 docker exec -ti [CONTAINER ID] /bin/bash 删除容器 // 该命令可删除处于终止状态的容器，正在运行的容器该命令不奏效 docker rm [CONTAINER ID] // 删除运行中的容器 docker rm -f [CONTAINER ID] 显示更底层的容器或image信息 docker inspect [CONTAINER ID]/[IMAGE ID] 导出容器 // 将容器导出为test.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df390f671c48e0ff1065812cd33cfc05/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0f0d421ed8d6d3fccdbb892a7312c0f/" rel="bookmark">
			CodeForces - 803C(GCD&#43;思维)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Maximal GCD 题目传送门 题意:给你两个数n，k。要你找一个严格连续递增数列，要求序列有k个元素，和为n并且gcd最大。 思路:很容易知道，要使得gcd最大，那么最大公约数必为数列首项，所以其最大公约数一定是n的因子。最好的情况为1d，2d,3d……,kd(d为最大公约数),即有 k*（k+1）/2 个d。因此，我们只需要求出n的因子，找到小于等于n/k*（k+1）/2中最大的因子就是最优的d，然后按照1d，2d,3d……,xd凑出数列即可。
#include &lt;iostream&gt; #include &lt;fstream&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;queue&gt; #include &lt;stack&gt; #include &lt;vector&gt; #include &lt;map&gt; #include &lt;set&gt; #include &lt;cmath&gt; #include &lt;algorithm&gt; #include &lt;functional&gt; #define inf 10000000 using namespace std; typedef long long ll; const int MAXN=5e6+10; const int MAX=1e6+10; const double eps=1e-6; ll n,k; ll s[MAX]; int main(){ #ifdef ONLINE_JUDGE #else freopen("in.txt","r",stdin); //freopen("out.txt","w",stdout); #endif cin&gt;&gt;n&gt;&gt;k; if((double)(k+1)&gt;(double)(2*n/k)){ cout&lt;&lt;-1&lt;&lt;endl; return 0; } int cnt=1; for(int i=1;i&lt;=sqrt(n);i++){ if(n%i==0) s[cnt++]=i,s[cnt++]=n/i; } sort(s+1,s+cnt+1); ll d=2*n/(k*(k+1)); for(int i=cnt-1;i&gt;=1;i--){ if(s[i]&lt;=d){ d=s[i]; break; } } ll sum=0; for(ll i=1;i&lt;=k;i++){ if(i==k){ printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b0f0d421ed8d6d3fccdbb892a7312c0f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee49fea1e3f0a23c0528f4f8983b42c9/" rel="bookmark">
			react  router  path 中通配符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		path属性可以使用通配符。
&lt;Route path="/hello/:name"&gt; // 匹配 /hello/car // 匹配 /hello/bus &lt;Route path="/hello(/:name)"&gt; // 匹配 /hello // 匹配 /hello/car // 匹配 /hello/bus &lt;Route path="/files/*.*"&gt; // 匹配 /files/cat.jpg // 匹配 /files/cat.html &lt;Route path="/files/*"&gt; // 匹配 /files/ // 匹配 /files/a // 匹配 /files/a/b &lt;Route path="/**/*.jpg"&gt; // 匹配 /files/cat.jpg // 匹配 /files/path/to/file.jpg 通配符的规则如下。 （1）:paramName :paramName匹配URL的一个部分，直到遇到下一个/、?、#为止。这个路径参数可以通过this.props.params.paramName取出。 （2）() ()表示URL的这个部分是可选的。 （3）* *匹配任意字符，直到模式里面的下一个字符为止。匹配方式是非贪婪模式。 （4） ** ** 匹配任意字符，直到下一个/、?、#为止。匹配方式是贪婪模式。 path属性也可以使用相对路径（不以/开头），匹配时就会相对于父组件的路径。嵌套路由如果想摆脱这个规则，可以使用绝对路由。 路由匹配规则是从上到下执行，一旦发现匹配，就不再其余的规则了。
&lt;Route path="/comments" ... /&gt; &lt;Route path="/comments" ... /&gt; 上面代码中，路径/comments同时匹配两个规则，第二个规则不会生效。 设置路径参数时，需要特别小心这一点。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee49fea1e3f0a23c0528f4f8983b42c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85693ce631152614b61a123b52fb4878/" rel="bookmark">
			Unity中实现放大镜的功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一个项目中需要实现一个放大镜的功能，对图片或者模型的某一个部分进行局部的放大，但是不能够改变原图片或者原模型的大小和样式，大致效果如下图所示： 相对来说还是比较简单的，借助Unity的UGUI和RenderTexture和以很容易的实现这个功能，具体步骤如下： 1.首先创建一个RenderTexture, 2.在Hierarchy中创建一个摄像机， 将1创建的RenderTexture指定给Camera中的TargetTexture: 3.调整摄像机的位置，设置层级 Culling Mask。剔除不需要在相机中呈现的物体。 4.创建一个Rawimage,用于显示摄像机投影的画面。 将1中创建的RenderTexture指定给 以上方式用于实现3D世界中的放大镜效果很好，但是，如果需要实现UI中界面元素的局部放大，则会稍微复杂一点，具体的方式，我做了一个演示项目，可以在演示项目中查看，地址工程：https://github.com/USuperMe/Mangnifier 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b96a8bbfd0a8d44e3e3988d6471e4642/" rel="bookmark">
			解决点击Docker出现windows 正在查找bash.exe。如果想亲自查找文件，请点击“浏览”的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		window7下安装DockerToolbox时，安装成功后，双击桌面的Docker Quickstart Terminal快捷方式： 会出现以下弹框： 可以猜测到时快捷方式所指定的路径不对（因为本人在安装Docker前已经安装好git了，原因就出在这）。
解决方法 邮件点击这个图标，点击属性，出现下面的图：
在目标 这一个选项处需要填写正确的 Git bash.exe文件位置来启动docker star.sh文件。我的git安装在D:\Git下，Docker Toolbox安装在C盘。所以我这里写的是：
D:\Git\bin\bash.exe –login -i “C:\Program Files\Docker Toolbox\start.sh” 大家可以根据自己的安装配置来调整这块的执行语句。
修改完毕点击引用、确定，再双击图标即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7093c1c6808b8d4035f2d981a10ae290/" rel="bookmark">
			SpringBoot 实现Filter过滤器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpringBoot实现过滤器和SpringMVC上实现没有多大差别，主要的差别就是在过滤器注册上，SpringMVC是通过XML配置文件注册过滤器，而SpringBoot则是通过代码注解的形式进行注册。下面一起看下在SpringBoot上怎么实现Filter过滤器吧。
Filter过滤器具体实现类 /** * 权限验证过滤器 */ public class AuthFilter implements Filter { @Override public void destroy() { // 顾名思义，在销毁时使用 } @Override public void doFilter(ServletRequest arg0, ServletResponse arg1, FilterChain chain) throws IOException, ServletException { HttpServletRequest request = (HttpServletRequest)arg0; HttpServletResponse response = (HttpServletResponse)arg1; if(needLogin(request)) { // 需要登录则跳转到登录Controller response.sendRedirect("login"); return; } chain.doFilter(arg0, arg1); } @Override public void init(FilterConfig config) throws ServletException { // 初始化操作 } /** * 判断是否需要登录 * @param request * @return */ private boolean needLogin(HttpServletRequest request) { //进行是否需要登录的判断操作 return false; } } 这里实现了一个用作权限验证的过滤器，来判断用户是否登录，若没有登陆，则跳转到登录界面，否则继续下面你的操作。Filter的实现及操作都和SpringMVC上一样，这里就不做过多解释了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7093c1c6808b8d4035f2d981a10ae290/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/abf16d87e943ce1231a1ea1721d3ad61/" rel="bookmark">
			基于FFMPEG的视频解码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include &lt;stdio.h&gt; #include &lt;cv.h&gt; #include &lt;highgui.h&gt; #include &lt;cvaux.h&gt; extern "C" { #include &lt;libavcodec/avcodec.h&gt; #include &lt;libavformat/avformat.h&gt; #include &lt;libswscale/swscale.h&gt; }; const char *fileName = "D:\\video\\1.avi"; AVFormatContext *pFormatCtx; int i, videoStream; AVCodecContext *pCodecCtx; AVCodec *pCodec; AVFrame *pFrame; AVFrame *pFrameRGB; AVPacket packet; int frameFinished; int numBytes; uint8_t *buffer; struct SwsContext *img_convert_ctx; int myDecodec(const char *fileName) { // Register all formats and codecs // 初始化ffmpeg库 av_register_all(); // Open video file if(av_open_input_file(&amp;pFormatCtx, fileName, NULL, 0, NULL)!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/abf16d87e943ce1231a1ea1721d3ad61/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/522/">«</a>
	<span class="pagination__item pagination__item--current">523/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/524/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>