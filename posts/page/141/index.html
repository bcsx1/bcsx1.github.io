<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8d9a44b137cb32527a1b9d00745da95/" rel="bookmark">
			Android内存泄漏&amp;leakcanary2.7
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、内存泄漏 1.1 内存泄漏简介 内存泄漏，是指一些对象已经不再需要，但是无法成功被gc回收，导致这部分内存无法释放，造成资源的浪费。当大量的内存泄漏堆积时，严重时还容易间接引发OOM。
例如：当Activity被销毁后，理论上activity已经不再需要，内存空间理应被释放，但是如果有个静态变量持有了这个activity的引用，就会导致gc无法回收activity，造成内存泄漏。
以下代码模拟了上述场景：MainActivity启动了TestActivity，然后再从TestActivity后退到MainActivity，理论上从TestActivity退出后执行了onDestroy()，就不再需要TestActivity，但是因为Utils的静态对象持有了TestActivity，导致TestActivity无法被gc回收，造成内存泄漏。实际开发中应该避免这种写法。
package com.bc.example; public class Utils { public static Context cacheContext; } pulic class MainActivity extends Activity { public void onButtonClick() { Intent intent = new Intent(this, SecondActivity.class); startActivity(intent); } } pulic class SecondActivity extends Activity { @Override public void onCreate() { Utils.cacheContext = this; super.onCreate(); } } 1.2 常见内存泄漏原因 内存泄漏发生的原因：长生命周期对象持有短生命周期对象，导致短生命周期对象在不再需要时无法被gc回收。一般是由于代码bug引起，常见的内存泄漏原因有：
1.2.1 静态变量或单例导致的内存泄漏
例子如1.1中所示。
解决办法：静态变量或单例不要持有activity或view等对象的引用，如果必须持有引用可以改为WeakReference。
1.2.2 内部类导致的内存泄漏
内部类会持有外部类对象的引用，例如：
public class MainActivity extends Activity { /** * 内部类 */ public class InnerClass { } } 上述代码在编译后，生成的内部类MainActivity$InnerClass.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8d9a44b137cb32527a1b9d00745da95/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f32ee725704e69bfecbefbd51cc166c/" rel="bookmark">
			osg-3D世界到屏幕
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		标题 前面记录了3D世界如何绘制,今天讨论一下3D世界怎么呈现到屏幕?
1.(模型视图矩阵)model-view matirx 模型矩阵: 用于描述物体在3D世界中的位置,原理是:把模型上所有的顶点从模型本地坐标系变换(乘以模型矩阵)到世界坐标系.
视图矩阵: 作用是变换整个3D世界到摄像机空间.
(PS:opengl是右手左边系,所以OSG也是右手坐标系,Opengl默认摄像机位置在世界中心(0,0,0)的位置,摄像机默认朝向z轴的负方向.)
但是Opengl中没有把模型矩阵和视图矩阵分离开来,而是用统一的一个矩阵表示,三维物体从本地左边系到摄像机坐标系的变换---模型视图矩阵
//变换向量v到摄像机空间结果为Ve Ve = V * modelViewMatirx;//OSG中矩阵是以行为主(opengl是以列为主),所以向量和矩阵的乘法规则是向量在前矩阵在后 2.(投影矩阵)projection matrix
投影矩阵:是把摄像机空间的三维模型投影显示到二维空间.今天重点介绍一下投影矩阵的原理,以为投影矩阵的理解对于三维开发者有非常重要的意义.
透视投影的原理:
在计算机图形学领域透视投影是作为一种将三维坐标投影为二维坐标的方法,最常用的是正交投影和透视投影.正交投影可以理解为简单的把三维物体沿着摄像机的方向压扁成为二维平面的过程,而透视投影是为了把三维世界更加真实的表现在二维平面的一种算法.
首先要想透视投影成立,需要三个因素:观察者\投影平面\被投影三维物体.三者关系是:假设人眼即为观察者,我们观察的是三维模型在投影平面上的投影,可以用图来表示:
假设三维世界中有一条经过X点的射线R,X和视点的连线在视平面(也是投影平面)上的交点是Xp,那么Xp即为X点在视平面上的投影.那么射线R上的所有点都可以依照上面的方法在投影平面上找到对应的一点Xp,所有的Xp点就构成了射线R的透视投影后的射线Rp.无论三维模型多复杂,投影的方法都是一样的,如下图:
透视投影在原理上对于投影平面的大小以及摄像机的位置都是没有限制的.只是在计算机图形学中,我们需要将三维世界的物体投影到各种屏幕,所以投影平面成为了矩形.并且由于计算效率问题,我们需要指定一个最远平面在三维世界中.并且摄像机的视角也是固定的.所以我们可以根据上面的一段话理解为,计算机图形学是把投影的范围退化成为了一个棱台----这就是透视投影的视截体.
关于投影矩阵的推导.
对称的视锥体：中心对称的视锥体，zz轴位于视锥体的中心；
不对称的视锥体：z轴不在视锥体的中央，就好比我们靠近窗户去观察景色，但没有正对窗户中心。
这里我们也分这两种情况来推导：
情况一：对称的视锥体
第一步：根据相似三角形的性质，有：
第二步：为使视景体内的顶点投影到近平面上，其坐标映射到[-1.0, 1.0]范围内，投影后的点要分别除以width / 2和height / 2，其中width,height分别为近投影平面的宽度与高度，根据第一步结果，有：
第三步：这一步推导深度部分变换，根据第一步和第二步，可以假设投影矩阵具有如下形式：
得到zproj=(A⋅z+B)/z，或A⋅z+B=z⋅zproj 将远平面和近平面z坐标代入上式得（注意注意：在这里，视景体内的深度坐标投影之后，有zproj∈[−1,1]）：
得到：
至此，对称视锥体的透视投影变换矩阵就推导完毕了，最终得到的透视投影变换矩阵为：
情况二：不对称的视锥体
这一情况看起来较上面复杂一些，其实也没复杂多少，首先，深度投影没什么变化；其次，对于不对称视锥体的xx和yy方向上的投影，只要在对称视锥体的投影基础上平移一下即可，其实只有第一步和第二步有所区别，如下：
第一步：投影，按如下方式进行平移lx和ly，
第二步：将近平面(注：z=−znear)的左、右边缘x坐标代入(1)得：
得：
同样，将近平面的上、下边缘y坐标代入(2)得：
这样，最终的投影变换矩阵为：
OpenGL中相关API就需要指定这些参数，来构建投影矩阵，如下：
void glFrustum( GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble znear, GLdouble zfar); //top　——近平面上边缘离中心的距离 //bottom　——近平面下边缘离中心的距离 //left　——近平面左边缘离中心的距离 //right　——近平面右边缘离中心的距离 //znear　——近平面离视点的距离 //zfar　——元平面离视点的距离 参数见上，另外还有一个，本质也是一样的，它应该是设置对称的视锥体的透视投影矩阵，即：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f32ee725704e69bfecbefbd51cc166c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a746e89be5451bde71d18ffe21ebe04/" rel="bookmark">
			Linux单机监控工具--Nmon
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux单机监控工具--Nmon 来自： 软件测试技术分享
往事随凨
2023年05月16日 15:12
Nmon 简要：
开源性能监控工具，用于监控linux系统的资源消耗信息，并能把结果输出到文件中，然后通过nmon_analyser工具产生数据文件与图形化结果。
目录
一、安装软件
二、实时监控
三、数据采集
四、生成分析报表
一、安装软件
1、下载
nmon安装包：
nmon for Linux | Site / Download
选择适合自己系统的版本
centos7_x86_64适合的最新nmon版本为：
nmon16e_mpginc.tar.gz 3.5MB
nmon_analyser工具：
https://www.ibm.com/developerworks/community/wikis/home?lang=en#!/wiki/Power+Systems/page/nmon_analyser
nmon for Linux | Site / Nmon-Analyser
（可用65/66/69）
下载后直接解压出模板（nmon analyser v51_2.xlsm），用于最后制图
2、上传 。。。
3、解压 。。。
tar -zxvf nmon16e_mpginc.tar.gz
4、拷贝并重命名
cp nmon_x86_64_centos /usr/local/bin/nmon
5、授权
cd /usr/local/bin
chmod a+x nmon
6、查看是否安装成功，显示如下界面即安装成功
./nmon
二、实时监控
输入c可显示CPU的信息，“m”对应内存，“n”对应网络，“d”可以查看磁盘信息，“t”可以查看系统的进程信息。结果如下图。
三、数据采集
在实际的性能测试中，我们需要把一段时间之内的数据记录下来，可以使用如下命令
./nmon -f -t -r test -s 1 -c 300
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a746e89be5451bde71d18ffe21ebe04/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2099667fdaee6246ccb454f4efcd4f5f/" rel="bookmark">
			解决微信图标在任务栏显示白纸的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决微信图标在任务栏显示白纸的方法 原文链接：https://blog.csdn.net/weixin_47085737/article/details/122981103
解决微信图标在任务栏显示白纸的方法
在网上找了一下 一共有三种方法
1.图标固定在任务栏再取消就会正常显示 2.运行窗口输入 %APPDATA%\Microsoft\Internet Explorer\Quick Launch\User Pinned\TaskBar
然后把图标异常的快捷方式放入TaskBar中
3.清除图标缓存（两种方法） 3.1 运行窗口输入ie4uinit -show
3.2 新建.txt ------cv代码----更改后缀为.bat----双击运行.bat文件
注：bat文件是dos下的批处理文件。批处理文件是无格式的文本文件，它包含一条或多条命令。
需要cv的代码如下
@echo off
taskkill /f /im explorer.exe
CD /d %userprofile%\AppData\Local
DEL IconCache.db /a
start explorer.exe
cho 完成
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f3d21a12f0e92a30d995b6cdc89c582/" rel="bookmark">
			VBA发送邮件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Sub SaveRangeAsImage()
Dim rng As Range Dim chartObj As ChartObject Dim fileName As String
'设置范围和文件名 Set rng = Range("A1:B3") fileName = "D:\range.png"
'创建图表对象 Set chartObj = ActiveSheet.ChartObjects.Add(0, 0, rng.Width, rng.Height) chartObj.Activate
'将范围复制到图表对象中 rng.CopyPicture Appearance:=xlScreen, Format:=xlPicture chartObj.Chart.Paste
'保存为图片 chartObj.Chart.Export fileName, "PNG"
'延迟1秒 Application.Wait (Now + TimeValue("0:00:01"))
'删除图表对象 chartObj.Delete
End Sub
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9794b4129614016025676453c4c7c7a/" rel="bookmark">
			mysql 改错user表无法登录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		不小心把user表host从%改成#了，无法登录，单机也无法登录。
解决办法
开一个cmd窗口
mysqld --console --skip-grant-tables --shared-memory
再开一个cmd窗口
mysql -uroot -p
两下回车OK
参考来源
https://blog.csdn.net/weixin_56328832/article/details/129369466
参考来源
https://blog.csdn.net/q283614346/article/details/90732968#:~:text=Mysql%208.X%E7%9A%84%E6%96%B9%E6%B3%95%E6%98%AF%E5%9C%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%AD%E4%BD%BF%E7%94%A8%20mysqld%20–console%20–skip-grant-tables%20–shared-memory%20%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%84%B6%E5%90%8Eroot%E5%B0%B1%E5%8F%AF%E4%BB%A5%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95%E4%BA%86%EF%BC%88%E9%9C%80%E8%A6%81%E5%BC%802%E4%B8%AACMD%E7%AA%97%E5%8F%A3%EF%BC%89%E3%80%82%20%E8%AF%A5%E7%AA%97%E5%8F%A3%E4%BD%BF%E7%94%A8,–skip-grant-tables%20–shared-memory%20%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%20%E8%AF%A5%E7%AA%97%E5%8F%A3%E4%BD%BF%E7%94%A8%20mysql%20-uroot%20-p%20%E5%9B%9E%E8%BD%A6%E7%99%BB%E5%BD%95%E5%8D%B3%E5%8F%AF
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51bfa2b04dce50319440f85588a5c64d/" rel="bookmark">
			STM32-内部温度传感器实验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		STM32内部是有温度传感器的，以F1为例，它的温度采集范围是-40度到125度，精度为正负2度，采样通道为ADC1_INI6，上电控制位为TSVREFE位。
温度计算方式为：T(摄氏度) = (V25 - Vsense) / Avg_Slope + 25，其中V25为25摄氏度时的Vsense数值，一般取1.43；Avg_slope为温度与Vsense曲线的平均斜率，一般取0.0043；Vsense是内部传感器采集到的电压值。（以F1为例）
实验要求：ADC1通道16采集芯片内部温度传感器的电压，将电压转算为温度后显示在液晶屏上。
我们通过下表可以知道DMA1通道1的外设对应的就是ADC1的读取。
首先确定我们的最小刻度，Vref = 3.3V，所以0V &lt;= Vin &lt;= 3.3V，所以最小刻度是3.3V / 4096（2^12）。
接下来确定转换时间。采样时间239.5个ADC时钟周期为例，可以得到转换时间为21us。
时间转换公式参考如下公式：Tcvtmin=（12.5+X）周期=(12.5 + X)/(12MHz)=21us。
接下来编写实验代码：
先编写函数文件adc_t.c：
#include "./BSP/ADC_T/adc_t.h" ADC_HandleTypeDef g_adc_handle; void adc_temperature_init(void){ ADC_ChannelConfTypeDef adc_ch_conf; g_adc_handle.Instance = ADC1; g_adc_handle.Init.DataAlign = ADC_DATAALIGN_RIGHT; //右对齐 g_adc_handle.Init.ScanConvMode = ADC_SCAN_DISABLE; //不扫描 g_adc_handle.Init.ContinuousConvMode = DISABLE; //单次模式 g_adc_handle.Init.NbrOfConversion = 1; //转换通道数为1，单通道 g_adc_handle.Init.DiscontinuousConvMode = DISABLE; //不用间断模式 g_adc_handle.Init.NbrOfDiscConversion = 0; //无间断模式则无间断通道 g_adc_handle.Init.ExternalTrigConv = ADC_SOFTWARE_START; //外部软件触发 HAL_ADC_Init(&amp;g_adc_handle); HAL_ADCEx_Calibration_Start(&amp;g_adc_handle); adc_ch_conf.Channel = ADC_CHANNEL_1; adc_ch_conf.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/51bfa2b04dce50319440f85588a5c64d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93b5b9c27405a3186c1d8e5eee142585/" rel="bookmark">
			WebRTC音视频开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、前言 自研实时音视频（RTC）系统的架构在客户端、服务端、运维、测试和质量监控上都存在很多难点
一个实时音视频应用共包括几个环节：采集、编码、前后处理、传输、解码、渲染等很多环节。每一个环节又有更细分的技术模块，比如前后处理环节有美颜、滤镜、回声消除、噪声抑制等，编解码有VP8、VP9、H.264、H.265等。 2、方案 基于WebRTC开发
webRTC是由Google发起的一个实时通讯解决方案。它涵盖了音视频采集、通讯的建立、信息传输、音视频显示等整套的实现方案。
2.1 优点：
1.开源免费
2.包含使用STUN、ICE、TURN、RTP-over-TCP的关键NAT和防火墙穿透技术，并支持代理
3.WebRTC还可以录制音视频到本地文件
4.WebRTC提供音视频加密功能
2.2 缺点：
1.没有对群聊进行专门优化和支持，虽然功能上可以扩展实现群聊，但是需要每个人连接到其他任何一个用户，消耗可想而知。（可采取集中式服务器，每个用户只需要和这个服务器建立一个连接，你可以通过这个服务器控制所有的流量）
2.对Native开发支持不够，webRTC顾名思义，主要面向Web应用，虽然也可以用于Native开发，但是由于涉及到的领域知识（采集、处理、编解码、实时传输等）较多，整个框架设计比较复杂
2.3 媒体服务器
WebRTC被认为是一种点对点技术，浏览器或客户端可以直接通信而无需任何类型的基础设施。此模型足以创建基本应用程序，但难以在其之上实现诸如组通信，媒体流记录，媒体广播或媒体转码之类的功能。因此，需要使用媒体服务器。
媒体服务器好处：
1.扩展了系统性能和功能，来支持更为复杂的应用场景
2.所有媒体流经由媒体服务器可以进行记录
3.可以方便的和第三方系统进行集成
4.可以对媒体流进行额外的加工处理
2.4 架构模式
1.Mesh:每端与其他短互联，群聊人数多的情况下带宽高cpu占用高，不能支持太多人
2.MCU：每个端与服务器相连，服务器负责所有的视频编码、转码、解码、混合等复杂逻辑，每个用户端只要1个连接，可以支持跟多人同时音视频通讯。（服务器压力大，需要较高配置，成本高，延迟问题）
3.SFU：仍然有中心节点服务器，但是中心节点只负责转发，不做太重的处理，服务器的压力会低很多，配置也不象Mixer要求那么高。但是每个用户端需要建立一个连接用于上传自己的视频，同时还要有N-1个连接用于下载其它参与方的视频信息，带宽消耗大（适合1对N）
小结：Mesh首先排除，SFU 相比于 MCU，服务器的压力更小（纯转发，无转码合流），灵活性更好（可选择性开关任意一路数据的上下行等），受到更广泛的欢迎和应用。也可以组合使用 SFU + MCU 的混合方案，以灵活应对不同场景的应用需要。
2.5 服务器开源方案对比 1.Jitsi （SFU） 官网: Free &amp; Open Source Video Conferencing | Jisti Projects gitHub: github.com/jitsi/jitsis:/
使用Java构建的服务端，底层也是使用c/c++,使用Java语言所以性能上没有使用c/c++的表现好
Jitsi 平台是非常活跃的开源视频会议平台，其对标的视频会议产品是zoom，Google meet等视频会议平台。其视频会议功能意见非常完善，包括终端，服务器端，会议桥和录像，屏幕共享，即时消息，SIP网关接入/电话入会等功能
官方提供的移动端SDK不支持自定义UI，自行编译SDK使用的是Rect Native
2.Kurento（MCU/SFU） 文档：https://doc-kurento-zh.readthedocs.io/zh/latest/index.html# gitHub:Kurento · GitHub
使用java和C++
Kurento的主要组件是Kurento媒体服务器(KMS)，Kurento提供的功能包括媒体的处理与传输、音视频实时通信、实时转码、服务器端录制、合流、广播等，它允许WebRTC将非常有趣的功能进行集成，如计算机视觉(识别QR码、面部检测)、实时媒体修正和与RTP(VolP)服务的交互，还可以在单个实例中配置成SFU或MC。
功能丰富，文档齐全,不怎么维护了，活跃度低
安卓使用案例：GitHub - nubomedia-vtt/nubo-test
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/93b5b9c27405a3186c1d8e5eee142585/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8dbb4c1385f2c93427c76a06bf661d78/" rel="bookmark">
			Kubernetes成本管理的当下现状
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于OpenCost的集成，对于Azure Kubernetes Service来说，“Kubernetes运行成本是多少？”这个问题变得更容易回答了。
微软决定将Kubernetes作为Azure的基础服务，这个决定不仅对微软自身有好处，也对Kubernetes生态系统的其他部分有好处。这是因为微软正在投入其工程师和资金，不仅支持和贡献于自己的项目，还支持和贡献于上游工具和能力。
有时这种投资被用作杠杆，旨在改善用户的生态系统，但其他时候，它是为了确保我们能够更经济地运行我们的云原生应用程序，并且对其生态系统的影响最小。
微软在Kubernetes方面的一个关键投资领域是成本管理工具。Kubernetes是一个编排器，根据需求自动扩展和缩减计算资源的使用。这使得很难预测Kubernetes的运行成本，特别是在公共云中，您需要混合使用虚拟服务器类型和计费规则，并且需要满足内存、网络和存储等不断变化的需求。是的，您的应用程序将按照您设置的限制进行扩展，但这会对您的成本产生什么影响呢？
将FinOps添加到Kubernetes 作为工程师，我们通常不会特别关注成本。毕竟，大多数情况下，我们构建和运行的应用程序的账单是别人的问题。但是，同样的情况也适用于运维和安全，直到出现了DevOps和DevSecOps。通过云服务，我们可以使用与监视应用程序性能相同的技术来监视成本，利用越来越重要的FinOps。这门新的学科为我们提供了新的可见性，了解运行我们的代码的成本，并确保这些成本被正确地分配给各个部门。使用FinOps工具，我们能够直接将代码与账单联系起来，而不是将其全部捆绑在一个IT运营费用中。
这就是开源的OpenCost工具开始发挥作用的地方。由Kubernetes的母公司Cloud Native Computing Foundation赞助，OpenCost是一种用于测量和分配Kubernetes应用程序成本的工具，可帮助您控制成本。OpenCost的贡献者来自Kubernetes生态系统的各个方面，监视提供商如New Relic和Grafana Labs在一端，超大规模云提供商AWS、Google Cloud和Azure在另一端。微软已宣布支持Azure Kubernetes Service中的OpenCost，这是Azure的托管Kubernetes平台。
OpenCost允许您深入了解Kubernetes安装和操作，找出哪些容器、Pod、部署等成本最高。像这样实时的成本分配能力，使您能够超越仅仅为性能调整应用程序，而是优化成本。这种方法让您找到最佳平衡点，使用户获得最佳性能，同时成本得到控制。这是一种平衡的行为，可能需要一些时间才能做到完美，但它是您的应用程序的另一个引人注目的调整参数。
在AKS中使用OpenCost 虽然OpenCost将于2023年5月为AKS提供生产支持，但为了帮助您入门，特别为Kubecon EU提供了一个特殊版本。安装后需要进行一些配置，设置适当的权限以便与Azure一起使用。
OpenCost使用Azure消费价格表API获取您账户的实时定价数据。这确保它考虑到适当的折扣，例如使用保留实例。您可以通过向您的账户添加一个Azure角色来设置这一点，该角色将OpenCost作为服务主体访问您的计费详细信息，通过您的计费账户ID。创建此Azure角色后，保存其密钥和密码以供OpenCost使用。您可以通过YAML或Helm配置OpenCost访问此数据，具体取决于您用于设置安装的方式。如果您与Azure有自定义的定价关系，则需要您现有的优惠ID才能通过API访问您的定价。
值得一提的是，OpenCost可以将数据传递给Prometheus，这为您提供了一个时间序列数据库，可以存储来自Kubernetes的信号和来自OpenCost的定价数据。这使得财务信息成为您的可观察性平台的一部分，因此您可以观察等同于高成本的条件，并将其视为故障。甚至还有一个kubectl插件，可以查询有关您的服务的OpenCost数据，因此您可以开始基于历史成本编写操作脚本。
使用成本数据管理Kubernetes 通过OpenCost API实时获取数据，可以基于成本建立自动化管理模型。如果成本飙升，为什么不将其作为Kubernetes自动缩放器KEDA的输入，并将高成本视为可以缩小集群的事件呢？甚至还有像Azure这样的提供商的选项，使用OpenCost作为向用户提供动态定价的方式。
为什么微软要拥抱帮助其客户花费更少而不是更多的工具的引入？这可能是微软别无选择，因为AWS和Google Cloud也是OpenCost项目的合作伙伴。然而，这是一种符合首席执行官萨蒂亚·纳德拉最近声明的变化，他表示微软正在“帮助客户从他们的技术支出中获得更多价值”。通过确保客户可以将其Kubernetes支出与使用情况相一致，就有机会动态优化Azure基础架构的使用。
微软还可以提高客户保留率，从而有机会赢得未来的业务，并同时控制自己的资本支出。运行大型云数据中心是昂贵的，建立新的容量甚至更加昂贵。对于微软和其客户来说，最好的做法是采用一种操作模式，使双方都能按照自己的需求花费，如果不是更少，那么至少是恰到好处的金额。
将OpenCost集成到Azure中，将为微软和客户提供更好的资源使用情况可见性，并允许Azure更加谨慎地规划未来的扩展。考虑到微软对Kubernetes的长期支持承诺，很明显，云原生开发已经来到了我们身边，并且现在受到与任何其他企业平台相同的控制。我们不再进行实验，而是在构建业务和服务，如果它们要为我们和Azure带来利润，那么它们需要以可预测的方式运行。
对于Azure上的Kubernetes来说，未来将会变得无聊，这并不应该让我们感到惊讶。毕竟，Kubernetes是基础设施，无聊是我们为成熟和企业接受而付出的代价。随着我们进入由Kubernetes驱动的未来，有趣的是我们将如何利用这些基础设施以及我们将在其上构建什么。
作者：Simon Bisson
更多资讯及技术干货请关注公号“云原生数据库”
squids.cn，基于公有云基础资源，提供云上 RDS，云备份，云迁移，SQL 窗口门户企业功能，帮助企业快速构建云上数据库融合生态。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8f7ee863a2104c7740326e1eb87b25c/" rel="bookmark">
			Visual Studio 2022 使用技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、常用快捷键
二、界面设置
1. 字体
2. 主题
2.1 下载主题
2.2 更改主题
3. 更改“解决方案管理器”停靠位置
4. 工具栏的设置 5. 显示代码行号
三、相对路径设置
四、C\C++ 相关设置
1. 添加第三方库的方法
方法1: 通过设置项目配置来添加lib库
方法2: 使用编译语句
五、VS命令行工具
六、常见问题解决
1. scanf函数无法正确编译
一、常用快捷键 VS常用快捷键 类别快捷键用途项目Ctrl+Shift+B生成解决方案Ctrl+Alt+L显示解决方案管理器Shift+Alt+A添加项目Shift+Alt+C添加类编辑Ctrl+Enter当前行插入空行Ctrl+Shift+Enter当前行下方插入空行Ctrl+Space使用智能感知Ctrl+K+C注释所选行Ctrl+K+U取消所选行注释Ctrl+K+D对齐所有代码折叠Ctrl + M + O折叠所有代码Ctrl + M + L展开所有代码Ctrl + M + M折叠或展开当前方法调试F5开始调试Ctrl + F5开始执行F9切换断点F10逐过程F11逐语句 二、界面设置 1. 字体 工具 → 选项 → 环境 → 字体和颜色
2. 主题 2.1 下载主题 扩展 → 管理扩展 → 联机 → 搜索 → theme → 选择喜欢的主题
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e8f7ee863a2104c7740326e1eb87b25c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86330ec32217fca8d7f74d1b409de111/" rel="bookmark">
			【Vector VN1630/40 I/O应用】-2-信号发生器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		案例背景(共5页精讲)：该篇博客将告诉您：
将Vector VN1630A/VN1640A CAN/LIN Interface的I/O接口充当一个简易的“信号发生器”使用：高低电平(如TTL电平)和PWM波。用作信号发生器，唤醒ECU控制器（硬件唤醒，如IG），或驱动设备。 目录
1 Vector VN1630A/VN1640A I/O的Digital output介绍
1.1 CANoe/CANalyzer工具的配置Vector I/O
1.2 运行的实际效果
结尾
优质博文推荐阅读（单击下方链接，即可跳转）：
Vector工具链
CAN Matrix DBC
CAN Matrix Arxml
1 Vector VN1630A/VN1640A I/O的Digital output介绍 VN1630A/VN1640A有一个D-SUB9连接器（CH5），用于专门的digital-analog输入/输出任务。引脚(Analog input，Analog GND，Digital input 0，Digital input 1，Digital output，Digital GND)分配见图1-1和图1-2。
图1-1
图1-2
D-SUB9 (CH5 - IO)的DOUT内部“硬件电路”和“技术参数”见下图1-3和下表。
数字输出：
图1-3
Digital output
开漏Open Drain
外部电源高达32 V
电流最大500 mA
短路/过压保护
如上图1-3所示，Digital output开漏电路，当Processor输出低电平时，Digital output处于悬空状态。为了达到可控目的，在DB9（CH5）Digital output口外部上拉电阻，将Digital output上拉至电源（见图1-4）。
驱动电压大小取决于电源电压；驱动电流大小取决于电源电压(V)/电阻(Ω)，单位A。 图1-4
1.1 CANoe/CANalyzer工具的配置Vector I/O 根据博文“【Vector VN1630 IO应用】-1-简易示波器https://blog.csdn.net/qfmzhu/article/details/130661592
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/86330ec32217fca8d7f74d1b409de111/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e458a7b7eabe3506daaf4149aedc59d8/" rel="bookmark">
			springcloud-sentinel,seata
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		技术对比：
限流规则：
seata配置：
springcloud集成：
seata-xa模式：
seata-at模式
区别：
实现AT：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c347bb8de7d241ebe48d25a1db516e5/" rel="bookmark">
			关于网络命令 ping 你了解多少
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、介绍 Ping(Packet Internet Groper)是 Windows、Unix 和 Linux系统下的一个命令。ping 也属于一个通信协议，是 TCP/IP 协议的一部分。
Ping的运作原理是向目标主机传出一个 ICMP（Internet Control Messages Protocol）即因特网信报控制协议的请求回显数据包，并等待接收回显回应数据包。程序会按时间和成功响应的次数估算丢失数据包率（丢包率）和数据包往返时间（网络时延，Round-trip delay time）。
说到 ping 命令，就不得不说的两个网络协议：ARP 协议和 ICMP 协议，下面对这两个协议进行讲解。
2、ARP协议 2.1 ARP简介 ARP 协议是“Address Resolution Protocol”（地址解析协议）的缩写。我们知道，在局域网内，如果两台主机要通信，必须要知道对方的MAC地址。ARP 协议的基本功能就是通过目标设备的IP地址，查询目标设备的 MAC 地址，以保证通信的顺利进行。
对于 TCP/IP 网络，地址解析协议（ARP）提供了一种在 IPv4 地址和各种网络技术使用的硬件地址之间的映射关系。ARP 仅用于 IPv4，IPv6 使用邻居发现协议，它被合并入 ICMPv6。
2.2 ARP帧格式 前面 14 个字节构成标准以太网的首部，前两个字段 DST 和 SRC 分别表示 以太网的目的地址 和 以太网的源地址，以太网的目的地址如果是 ff:ff:ff:ff:ff:ff 全部为 1 表示广播地址，在同一广播域中的所有以太网接口可以接收这些帧。后面紧跟着的是 ARP 请求的长度/类型，ARP 请求 和 ARP 应答这个值为 0x0806。
硬件类型表示硬件地址的类型，硬件地址常见的有 MAC 物理或者以太网地址，对于以太网来说，此值为 1。协议类型 指出映射的协议地址类型，对于 IPv4 地址，这个值是 0x0800。硬件大小和 协议大小 分别指出硬件地址和协议地址的字节数。对于以太网中使用 IPv4 的 ARP 请求或应答，它们的值分别是 6 和 4Op 字段指出如果是 ARP 请求，Op = 1，ARP 应答 ，Op = 2，RARP 请求 Op = 3，RARP 应答，Op = 4。紧跟在 Op 之后的是 发送方硬件地址(MAC 地址)，发送方的协议地址(IPv4 地址)，目的硬件地址（一般为全0，表示目的地址未知） 和 目的协议地址。 ARP 示例报文：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c347bb8de7d241ebe48d25a1db516e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4d155f0c7487d06c052141b0f60991c/" rel="bookmark">
			docker&#43;jenkins&#43;maven&#43;git构建聚合项目，实现自动化部署，走了800个坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		流程 主要的逻辑就是Docker上安装jenkins，然后拉取git上的代码，把git上的代码用Maven打包成jar包，然后在docker运行
这个流程上的难点
一个是聚合项目有可能Maven install的时候失败。
解决办法：在基础模块的pom文件上添加 &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;classifier&gt;exec&lt;/classifier&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 一个是jenkins是在docker上运行的，那么如何git上的代码用Maven打包成jar包，然后在docker运行是个问题
解决办法：用远程shell脚本，直接在宿主机上执行命令，相当于jenkins去git拉代码打包成jar之后，然后把手动jar包变成容器运行的步骤写成脚本让jenkins去执行 Docker安装jenkins 下载Jenkins的Docker镜像：
docker pull jenkins/jenkins:lts在Docker容器中运行Jenkins： docker run -p 8080:8080 -p 50000:5000 --name jenkins \ -u root \ -v /mydata/jenkins_home:/var/jenkins_home \ -d jenkins/jenkins:lts 注意-v之后的“/mydata/jenkins_home”这个很关键，jenkins拉取下来的代码和install之后的代码都会在这个目录下，docker执行的时候也需要在这个目录下。
运行成功后访问该地址登录Jenkins，第一次登录需要输入管理员密码：http://192.168.6.132:8080/
使用管理员密码进行登录，可以使用以下命令从容器启动日志中获取管理密码： docker logs jenkins 1
从日志中获取管理员密码：
选择安装插件方式，这里我们直接安装推荐的插件：
进入插件安装界面，联网等待插件安装：
安装完成后，创建管理员账号：
jenkins安装maven 有一个简单安装的方法，但是对于网络要求很高
通过系统管理-&gt;全局工具配置来进行全局工具的配置
但是这种方式对网络要求比较高，可能下载不下来。可以看下面的方案利用挂载容器来安装maven
注意并不能在docker的jenkins容器里安装maven，这样在重启之后maven就没有了，可以在jenkins的宿主机里安装maven，把maven安装到上面启动jenkins是的/mydata/jenkins_home路径下面，然后在jenkins里配置。
在系统管理-&gt;全局工具配置里，配置MAVEN_HOME，主要这个路径是jenkins容器里的路径，而不是/mydata/jenkins_home路径。
在系统配置-&gt;系统配置里
jenkins连接远程ssh 因为需要执行docker命令，docker又不是在jenkins容器里，所以需要远程shell命令来执行，这块要注意，网上说的ssh plugs插件现在不能安装了，需要另外的办法。
Jenkins安装Publish over SSH插件配置服务器相关信息要先在jenkins所在的机器上生成秘钥。生成方式为： ssh-keygen -t rsa #产生公钥与私钥对 因为没加密码所以一路enter完成。此时在 用户名文件夹/root/.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4d155f0c7487d06c052141b0f60991c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81112f3d8762c0978de4937ee0efdf6e/" rel="bookmark">
			小白到运维工程师自学之路 第十六 （网络概述）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、概念 分层思想
复杂问题简单化
每层的分工更加明确，整个流程更加清晰 二、OSI七层模型 应用层：提供与用户的交互接口
表示层：将数据进行压缩、加密、编码
会话层：建立双方的会话窗口
传输层：实现不同主机的进程通信（防火墙事先定义好的规则）
网络层：进行逻辑寻址
数据链路层：进行物理寻址
物理层：将数据转换成0和1进行传输
TCP/IP五层模型 三、五层模型 1、每层的协议名称
应用层：DNS：域名服务 FTP：文件传输协议 HTTP：超文本传输协议DHCP：动态主机配置协议
传输层：TCP：①、传输控制协议 ②、三次握手建立连接
③、四次挥手断开连接
网络层：IP协议：TCP/IP协议的基础
ARP：地址解析协议
RARP：反向地址解析协议
ICMP：控制报文协议
2、每层的工作设备
应用层：计算机
传输层：防火墙
网络层：路由器
数据链路层：交换机
物理层：网卡
3、协议数据单元
应用层：数据报文
传输层：数据段
网络层：数据包
数据链路层：数据帧
物理层：比特流
4、封装与解封过程
PDU：数据封装过程 头部&gt;数据段（TCP头部）&gt;数据包（TCP头部、IP头部）&gt;数据帧（TCP头部、IP头部、MAC头部）&gt;比特流
交换机传输不通过传输层、应用层 四、IP地址 前三段是网络部分（第三位是1表示网段） 后一段是主机部分
二进制
1=1
2=10
4=100
8=1000
16=10000
32=100000
64=1000000
128=10000000 使用拆数法进行换算 IP地址分类（本地回环地址LO 127.0.0.1验证本地计算机是否正确配置了 TCP/IP）
A类：1-121（一个网络位三个主机位）
B类：128-191（两个网络位两个主机位）
C类：192-233（三个网络位一个主机位）
D类：224-239（用于组播通信的地址）
E类：240-255（用于科学研究）
私有地址
A类：10.0.0.0-10.255.255.255
B类：172.16.0.0-172.31.255.255
C类：192.168.0.0-192.168.255.255 临时配置：命令行设置，设置后会立即生效，重启后生效
永久配置：配置文件设置，设置后重启生效，不会失效 网卡详细：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/81112f3d8762c0978de4937ee0efdf6e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5251aa7787fa0f75d1b2ca30abd63bf5/" rel="bookmark">
			SuperMap单体化操作详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SuperMap房屋单体化步骤 文章目录 SuperMap房屋单体化步骤前言一、数据准备一、单体化一栋楼1.将三维面数据拖拽到三维场景中2.单体化后可视化效果修改 二、单体化每间房1.切割分户2.分层分户3.单体化 前言 单体化处理步骤简单，但是过程比较耗时。房屋单体化时，一般是两种情况，一种是对整栋楼进行单体化（这样处理比较快捷，省时），另一种是对每间房屋进行单体化处理（这种操作步骤比较多，耗时长，但是效果更贴近真实）。
一、数据准备 用SuperMap软件做房屋单体化之前，需要准备好以下数据：
1.倾斜模型
2.正射影像（最好具备，直接在三维场景中绘制三维面有点操作不便）
3.房屋面数据（具备三个字段：底部高程、拉升高度、ID字段）
注：这一步可参考：SuperMap三维模型的按户单体化处理步骤
一、单体化一栋楼 如下图所示，绘制完成房屋数据后，进行每栋楼的单体化处理。
字段属性如下图所示：
1.将三维面数据拖拽到三维场景中 开启编辑模式，选中“风格设置”，高度模式：贴对象（设置绝对高度可生成白膜），数据来自：地上，底部高程：altitude（即G），拉升高度：height（即L），之后关闭编辑模式。
2.单体化后可视化效果修改 首先点击“图层风格”，设置好前景色及背景颜色，点击“确定”.
一般设置完成图层风格颜色较深，可以在“风格设置”中设置透明度（这里取40，即40%的意思，根据自己喜好设置）及填充方式（这里选择填充）。
选择“对象选择风格”，设置前景色、背景色及透明度
最后效果如图所示
二、单体化每间房 1.切割分户 将正射影像加载到地图中，再将房屋面数据拖拽到二维地图中，对面数据进行编辑，点击“对象操作”，选择“画线切割”。
注：必须是二维地图中进行切割操作，按照影像中的位置特征进行分户处理。（切割分户这一步也可以使用ArcMap软件进行，本次不做讲解）
如有一次切割多个面，需要选中其中的面点击“分解”
2.分层分户 在房屋面数据右键，选择“关联浏览属性表”
选中分割完的所有面，右键“复制”、“粘贴”（或者Ctrl+C、Ctrl+V）。粘贴完成之后，下方高亮部分为复制后的面数据（复制粘贴的数据活出现在表格最下方位置），此时该栋楼存在两层数据（具体分多少层以实际情况来分，拉升的高度可以在三维场景中使用测量工具测出），之后需要修改底部高程数据以及拉升高度。
第二层的底部高程为第一层底部高程数值加上拉升高度数值
3.单体化 操作步骤参考“单体化一栋楼”
注：将分割后的二维房屋面数据转换成三维面数据，在三维场景中进行风格设置。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb623ba702cf01b117dc47b7e6c4ac33/" rel="bookmark">
			使用泰勒展开方法线逼近三角函数和反三角函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		泰勒展开 def taylor_approximation(func, x, n): """ 使用泰勒级数展开逼近函数 """ result = 0.0 for i in range(n): coef = func(i) term = coef * math.pow(x, i) result += term return result sin def approximate_sin(x, n): """ 使用泰勒级数展开逼近正弦函数 """ def coef(i): return (-1) ** i / math.factorial(2 * i + 1) return taylor_approximation(coef, x, n) cos def approximate_cos(x, n): """ 使用泰勒级数展开逼近余弦函数 """ def coef(i): return (-1) ** i / math.factorial(2 * i) return taylor_approximation(coef, x, n) tan def approximate_tan(x, n): "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb623ba702cf01b117dc47b7e6c4ac33/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ed22cd0c4b3e59ae9e22aacf15b7f18/" rel="bookmark">
			使用线性插值简化三角函数和反三角函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		def linear_interpolation(x, x0, y0, x1, y1): """ 线性插值函数 """ return y0 + (y1 - y0) * (x - x0) / (x1 - x0) sin 在以下示例中，我们首先定义了插值范围（从0到π/2），然后根据精度要求计算出插值步长。然后，我们找到最接近输入值的插值点，并使用线性插值公式来逼近sin函数的值。
请注意，精度要求（即插值点的个数）越高，逼近的结果越接近sin函数在给定输入值处的精确值。但是，由于使用线性插值，逼近的精度可能有限。如果需要更高精度的逼近结果，可以考虑使用更高阶的插值方法，如二次插值或三次插值。
import math def linear_interpolation(x, x0, y0, x1, y1): """ 线性插值函数 """ return y0 + (y1 - y0) * (x - x0) / (x1 - x0) def approximate_sin(x, precision): """ 使用线性插值逼近sin函数 """ # 定义插值范围 x0 = 0.0 y0 = math.sin(x0) x1 = math.pi / 2 y1 = math.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ed22cd0c4b3e59ae9e22aacf15b7f18/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8638e735269e34f5807b2645ff009c4/" rel="bookmark">
			RecyclerView详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RecyclerView 简称 RV， 是作为 ListView 和 GridView 的加强版出现的，目的是在有限的屏幕之上展示大量的内容，因此 RecyclerView 的复用机制的实现是它的一个核心部分。
RV 常规使用方式如下：
解释说明。
setLayoutManager：必选项，设置 RV 的布局管理器，决定 RV 的显示风格。常用的有线性布局管理器（LinearLayoutManager）、网格布局管理器（GridLayoutManager）、瀑布流布局管理器（StaggeredGridLayoutManager）。
setAdapter：必选项，设置 RV 的数据适配器。当数据发生改变时，以通知者的身份，通知 RV 数据改变进行列表刷新操作。
addItemDecoration：非必选项，设置 RV 中 Item 的装饰器，经常用来设置 Item 的分割线。
setItemAnimator：非必选项，设置 RV 中 Item 的动画。
本课时主要来看下 RV 是如何一步步将每一个 ItemView 显示到屏幕上，然后再分析在显示和滑动过程中，是如何通过缓存复用来提升整体性能的。RV 本质上也是一个自定义控件，所以也符合上节课所讲的自定义控件的规则。因此我们也可以沿着分析其 onMeasure -&gt; onLayout -&gt; onDraw 这 3 个方法的路线来深入研究。
绘制流程分析
onMeasure
RV 的 onMeasure 方法如下：
图中 1 处，表示在 XML 布局文件中，RV 的宽高被设置为 match_parent 或者具体值，那么直接将 skipMeasure 置为 true，并调用 mLayout（传入的 LayoutManager）的 onMeasure 方法测量自身的宽高即可。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e8638e735269e34f5807b2645ff009c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38c205394166e5b28af22d753e001e71/" rel="bookmark">
			修改swiper组件面板指示点的样式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、默认 2、修改颜色 indicator-active-color="#14b2b5"
3、修改形状 .wx-swiper-dots .wx-swiper-dot{ width: 40rpx; height: 10rpx; border-radius: 4rpx; } 4、修改间距 .wx-swiper-dots .wx-swiper-dot:nth-of-type(n+2) { margin-left: 25rpx; } 5、修改位置 /* 顶部 */ .wx-swiper-dots.wx-swiper-dots-horizontal { top: 40rpx; } /* 左上角 */ .wx-swiper-dots.wx-swiper-dots-horizontal { top: 40rpx; width: 90%; text-align: left; } /* 左下角 */ .wx-swiper-dots.wx-swiper-dots-horizontal { width: 90%; text-align: left; } /* 中间 */ .wx-swiper-dots.wx-swiper-dots-horizontal { top: 50%; } /* 右上角 */ .wx-swiper-dots.wx-swiper-dots-horizontal { top: 40rpx; width: 90%; text-align: right; } /* 右下角 */ .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/38c205394166e5b28af22d753e001e71/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/276f23eb32c92a0355c6aa55d8d15ad7/" rel="bookmark">
			必须了解的内存屏障
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一，内存屏障1，概念2，内存屏障的效果3，cpu中的内存屏障 二，JVM中提供的四类内存屏障指令三，volatile 特性1，保证内存可见性定义2，禁止指令重排序3，不保证原子性 一，内存屏障 1，概念 内存屏障是硬件之上、操作系统或JVM之下，对并发作出的最后一层支持。再向下是是硬件提供的支持；向上是操作系统或JVM对内存屏障作出的各种封装。内存屏障是一种标准，各厂商可能采用不同的实现
2，内存屏障的效果 即使指令的执行没有重排序，是按顺序执行的，但由于缓存的存在，仍然会出现数据的非一致性的情况。我们把这种普通读``普通写可以理解为是有延迟的延迟读、延迟写，因此即使读在前、写在后，因为有延迟，然后仍然会出现写在前、读在后的情况。
为了解决上述重排带来的问题，提出了as-if-serial原则，即不管怎么重排序，程序执行的结果在单线程里保持不变。为了遵守as-if-serial原则，我们需要一种特殊的指令来阻止特定的重排，使其保持结果一致，这种指令就是内存屏障。
内存屏障有两个效果：
阻止指令重排序：在插入内存屏障指令后，不管前面与后面任何指令，都不能与内存屏障指令进行重排，保证前后的指令按顺序执行，即保证了顺序性。全局可见：插入的内存屏障，保证了其对内存操作的读写结果会立即写入内存，并对其他CPU核可见，即保证了可见性，解决了普通读写的延迟问题。例如，插入读屏障后，能够删除缓存，后续的读能够立刻读到内存中最新数据（至少当时看起来是最新)。插入写屏障后，能够立刻将缓存中的数据刷新入内存中，使其对其他CPU核可见。 3，cpu中的内存屏障 lfence:读屏障（load fence)，即立刻让CPU Cache失效，从内存中读取数据，并装载入Cache中。
sfence: 写屏障（write fence）, 即立刻进行flush，把缓存中的数据刷入内存中。
mfence: 全屏障 (memory fence)，即读写屏障，保证读写都串行化，确保数据都写入内存并清除缓存。
二，JVM中提供的四类内存屏障指令 loadload：
读读，该屏障用来禁止处理器把上面的volatile读与下面的普通读重排序
storestore：
写写，该屏障可以保证在volatile写之前，其前面的所有普通写操作都已经刷新到主内存中
loadstore：
读写，该屏障用来禁止处理器把上面的volatile读与下面的普通写重排序
storeload：
写读，该屏障的作用是避免volatile与后面可能有的volatile读/写操作重排序
三，volatile 特性 1，保证内存可见性定义 （1）定义：
可见性的定义常见于各种并发场景中，以多线程为例：当一个线程修改了线程共享变量的值，其它线程能够立即得知这个修改。
从性能角度考虑，没有必要在修改后就立即同步修改的值——如果多次修改后才使用，那么只需要最后一次同步即可，在这之前的同步都是性能浪费。因此，实际的可见性定义要弱一些，只需要保证：当一个线程修改了线程共享变量的值，其它线程在使用前，能够得到最新的修改值。
（2）如何保证可见性
Java内存模型中定义的8种工作内存与主内存之间的原子操作
read: 作用于主内存，将变量的值从主内存传输到工作内存，主内存到工作内存load: 作用于工作内存，将read从主内存传输的变量值放入工作内存变量副本中，即数据加载use: 作用于工作内存，将工作内存变量副本的值传递给执行引擎，每当JVM遇到需要该变量的字节码指令时会执行该操作assign: 作用于工作内存，将从执行引擎接收到的值赋值给工作内存变量，每当JVM遇到一个给变量赋值字节码指令时会执行该操作store: 作用于工作内存，将赋值完毕的工作变量的值写回给主内存write: 作用于主内存，将store传输过来的变量值赋值给主内存中的变量
由于上述只能保证单条指令的原子性，针对多条指令的组合性原子保证，没有大面积加锁，所以，JVM提供了另外两个原子指令：lock: 作用于主内存，将一个变量标记为一个线程独占的状态，只是写时候加锁，就只是锁了写变量的过程。unlock: 作用于主内存，把一个处于锁定状态的变量释放，然后才能被其他线程占用 2，禁止指令重排序 （1）定义
重排序并没有严格的定义。整体上可以分为两种：
真·重排序：编译器、底层硬件（CPU等）出于“优化”的目的，按照某种规则将指令重新排序（尽管有时候看起来像乱序）。
伪·重排序：由于缓存同步顺序等问题，看起来指令被重排序了。
（2）问题来源
重排序问题无时无刻不在发生，源自三种场景：
编译器编译时的优化处理器执行时的乱序优化缓存同步顺序（导致可见性问题）
场景1、2属于真·重排序；场景3属于伪·重排序。场景3也属于可见性问题 （3）怎么禁止指令重排序
volatile有关禁止指令重排的行为
当第一个操作是 volatile 读时，不论第二个操作是什么，都不能重排序；这个操作保证了volatile读之后的操作不会被重排到volatile读之前
当第二个操作为 volatile 写时，不论第一个操作是什么，都不能重排序；这个操作保证了volatile写之前的操作不会被重排到volatile写之后
当第一个操作为 volatile 写时，第二个操作为 volatile 读时，不能重排序
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/276f23eb32c92a0355c6aa55d8d15ad7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/468fb9b14148c4fea71ef189c5deb6e1/" rel="bookmark">
			Neo4j如何在启动时指定JDK版本？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先，打开bin文件夹下的neo4j.bat文件，
然后，加入jdk版本的位置即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c33138ebff3dd694b64fbc3c42042888/" rel="bookmark">
			游戏安全2-C,C&#43;&#43; 利用Windows API 获取进程PID
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习目标:
认识进程PID
认识线程TID
FindWindowA
GetWindowThreadProcessId //返回线程TID和进程PID
DWORD GetWindowThreadProcessId( [in] HWND hWnd, [out, optional] LPDWORD lpdwProcessId ); /* 参数 [in] hWnd 类型：HWND 窗口的句柄。 [out, optional] lpdwProcessId 类型： LPDWORD 指向接收进程标识符的变量的指针。 如果此参数不为 NULL， GetWindowThreadProcessId 会将进程的标识符复制到 变量;否则，它不会。 返回值 类型：DWORD 如果函数成功，则返回值是创建窗口的线程的标识符。 如果窗口句柄无效，则返回值为零。 要获得更多的错误信息，请调用 GetLastError。 */ 学习目标:
认识进程PID
认识线程TID FindWindowA
GetWindowThreadProcessId //返回线程TID和进程PID
植物大战僵尸中文版
MainWindow
#include &lt;iostream&gt; #include&lt;Windows.h&gt; int main() { //1 通过窗口标题或者类名 获取目标窗口句柄 //2 通过窗口句柄获取进程的PID,TID HWND h = FindWindowA("MainWindow", "植物大战僵尸中文版"); printf("窗口句柄 h=%p\r\n", h); DWORD pid=0, tid=0; printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c33138ebff3dd694b64fbc3c42042888/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e62ee45ae2bb4e95fcd09169c7b4932c/" rel="bookmark">
			ChatGPT如何改进您的客户数据收集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Chatgpt | Chat | Gpt | 小智Ai | Chat小智 | Gpt小智 | ChatGPT小智Ai | GPT小智 | GPT小智Ai | Chat小智Ai 丨
摘要：在当今数字化时代，客户数据是企业决策的重要依据之一。ChatGPT可以通过优化数据收集方式来帮助企业更好地了解客户需求和行为，从而提高销售和服务质量。本文将介绍ChatGPT如何改进客户数据收集的方法和技巧。
正文：
在当今数字化时代，客户数据是企业决策的重要依据之一。通过收集、分析和利用客户数据，企业可以更好地了解客户需求和行为，从而优化销售和服务策略，提高客户满意度和忠诚度。然而，如何有效地收集客户数据仍然是一个挑战。ChatGPT可以帮助企业改进客户数据收集的方式和方法，提高数据质量和可用性，从而推动企业的发展和壮大。
以下是ChatGPT改进客户数据收集的方法和技巧：
采用多样化的数据收集方式
ChatGPT可以采用多样化的数据收集方式，例如在线调查、电子邮件、社交媒体、电话、面对面访谈等，来收集客户数据。不同的数据收集方式可以覆盖不同的客户群体和行为特征，从而提高数据的全面性和可靠性。同时，ChatGPT可以利用自然语言处理和机器学习等技术，自动化收集和分析客户数据，减少人力成本和提高数据精度。
提高数据安全和隐私保护
客户数据安全和隐私保护是数据收集的重要问题。ChatGPT可以采取一系列措施来保护客户数据的安全和隐私，例如采用安全加密传输和存储技术、建立严格的数据访问和授权机制、遵循相关法规和标准等。这些措施可以增强客户数据的可信度和保密性，提高客户对企业的信任度和满意度。
利用数据可视化和分析工具
ChatGPT可以利用数据可视化和分析工具，例如数据仪表盘、报告、图表等，将客户数据转化为有用的信息和洞察力。这些工具可以帮助企业更好地了解客户需求和行为，发现问题和机会，制定更有效的销售和服务策略。同时，ChatGPT可以通过机器学习和预测分析等技术，预测客户行为和趋势，为企业提供更准确的决策依据。
优化客户反馈收集和分析
客户反馈是客户数据收集的重要来源之一。ChatGPT可以优化客户反馈的收集和分析过程，例如采用在线调查、问卷调查、社交媒体等方式收集客户反馈，采用自然语言处理和情感分析等技术分析客户反馈内容，识别客户需求和不满意点。通过客户反馈，企业可以及时改进产品和服务质量，提高客户满意度和忠诚度。
实施个性化营销和服务
个性化营销和服务是基于客户数据的关键应用之一。ChatGPT可以利用客户数据，制定个性化营销和服务策略，提供符合客户需求和偏好的产品和服务。例如，ChatGPT可以根据客户历史购买记录和行为特征，推荐符合客户兴趣和偏好的产品和服务；可以针对客户特定需求和问题，提供个性化的解决方案和服务体验。通过个性化营销和服务，企业可以提高客户满意度和忠诚度，增加销售和收益。
总结：
通过优化客户数据收集方式和方法，ChatGPT可以帮助企业更好地了解客户需求和行为，制定更有效的销售和服务策略，提高客户满意度和忠诚度。企业可以采用多样化的数据收集方式，提高数据安全和隐私保护，利用数据可视化和分析工具，优化客户反馈收集和分析，实施个性化营销和服务等方法和技巧。通过ChatGPT的支持和帮助，企业可以更好地利用客户数据，推动业务发展和壮大。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2206dfe83f450e8f3a6aaa1a2fa7e36b/" rel="bookmark">
			常见的各种坐标系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、经纬度坐标系
二、地心地固坐标系
将经纬度坐标系下的坐标转换为地心固定坐标系ECEF下的坐标
三、地球惯性坐标系
四、卫星位置计算
五、东北天坐标系
J2000转东北天
地心地固转东北天
六、姿态角求解 七、计算某一时间的儒略日
一、经纬度坐标系 经纬度坐标系是一种地理坐标系统，用于描述地球表面上任意位置的坐标。它是基于地球的自转和赤道的划分而建立的。
经度（Longitude）表示地球表面上一个点相对于本初子午线的东西方向的位置。经度的度量单位是度（°），范围从0°到180°，以东经为正值，西经为负值。本初子午线位于英国伦敦的皇家格林尼治天文台，它被定义为经度0°。
纬度（Latitude）表示地球表面上一个点相对于赤道的北南方向的位置。纬度的度量单位也是度（°），范围从0°到90°，以北纬为正值，南纬为负值。赤道位于纬度0°。
经纬度坐标系统使用经度和纬度的组合来确定地球表面上的特定位置。一个点的经纬度坐标表示为两个数值的组合，例如：40°N，120°E 表示北纬40度，东经120度的位置。
经纬度坐标系统是全球通用的地理坐标系统，广泛应用于导航、地图制作、地理信息系统（GIS）等领域。
二、地心地固坐标系 地心地固坐标系（Geocentric Cartesian Coordinate System）是一种用于描述地球上的位置和方向的坐标系统。它是一种笛卡尔坐标系，其中地球的中心被定义为原点，三个坐标轴固定在地球上，与地球自转轴对齐。
在地心地固坐标系中，三个坐标轴通常被定义如下：
X轴：通过原点和经度为0度的子午线（通常是通过英国伦敦的本初子午线）。Y轴：通过原点、纬度为0度的赤道，与X轴垂直。Z轴：与地球自转轴对齐，指向地球北极，垂直于XY平面。 使用这种坐标系，可以准确描述地球上任意点的位置。例如，通过给定的经度、纬度和高度（相对于海平面），可以确定点在地心地固坐标系中的三维坐标。这对于导航、地理信息系统（GIS）、地图制作和天文学等领域非常重要。
需要注意的是，地心地固坐标系是一个相对于地球的固定坐标系，而非相对于太阳或其他天体的惯性坐标系。它主要用于地球表面的测量和定位，而在宇宙空间中，通常使用其他坐标系，如国际天文学联合会所定义的天球坐标系。
将经纬度坐标系下的坐标转换为地心固定坐标系ECEF下的坐标 （使用椭球体参数和坐标转换公式来进行计算。）
import math # 地球椭球体参数 a = 6378137.0 # 长半轴 f = 1 / 298.257223563 # 扁率 def deg2rad(deg): return deg * (math.pi / 180) def geodetic_to_geocentric(latitude, longitude, altitude): # 将纬度、经度、高度转换为弧度 lat_rad = deg2rad(latitude) lon_rad = deg2rad(longitude) # 计算地球椭球体上的参数 b = a * (1 - f) # 短半轴 e_squared = 1 - (b**2) / (a**2) # 第一偏心率的平方 # 计算地球椭球体上的坐标 N = a / math.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2206dfe83f450e8f3a6aaa1a2fa7e36b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/378bfd02eeae1e69f749eedc932409d8/" rel="bookmark">
			Python数据可视化：WordCloud超详细入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python数据可视化：WordCloud入门 WordCloud是一种很好的展现数据的方式，网上也有不少小工具和在线网页。但是有些不支持中文，有些安装复杂，所以决定用Python实现。主要参考官网，通过官网的例子，讲一下WordCloud的制作。
WordCloud是一种很好的展现数据的方式，网上也有不少小工具和在线网页。
但是有些不支持中文，有些安装复杂，所以决定用Python实现。
主要参考官网，通过官网的例子，讲一下WordCloud的制作。
主要流程 获取内容的路径如果是一段文字，系统自动算频次你也可以直接导入统计好的频次设置字体一般字体路径在C:\Windows\Fonts，你可以选自己喜欢的中文或者英文字体切割中文字符英文字符就不用切割了输入WordCloud的参数背景色字号生成的形状颜色字体大小字体旋转等等生成WordCloud用matplotlib显示图片 效果图 安装库 老规矩，首先，你要安装库。
最基本的两个：
1. pip install wordcloud #这是WordCloud的库 3. pip install matplotlib #显示图像 一个单词构造WordCloud 在这个代码中，我们需要安装一个numpy库
(大部分小伙伴应该都装过，就不用再装了)
1. pip install numpy 这里用这个库，主要是想用数学坐标生成一个简单的背景图案，比如圆形、方形
基本步骤
输入单词用numpy 生成一个形状，下面生成了一个圆形mask输入WordCloud的参数(包括背景色、是否重复、图案形状)用matplotlib显示图片 1. import numpy as np 2. import matplotlib.pyplot as plt 3. from wordcloud import WordCloud 4. text = "square" #输入你要的单词 5. x, y = np.ogrid\[:300, :300\] #快速产生一对数组 6. # 产生一个以(150,150)为圆心,半径为130的圆形mask 7. mask = (x - 150) \*\* 2 + (y - 150) \*\* 2 &gt; 130 \*\* 2 #此时mask是bool型 8.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/378bfd02eeae1e69f749eedc932409d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49f9c83623b0606f0bf6069f1ad9ad4a/" rel="bookmark">
			UE4搭建标准光照环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 由于之前经常会碰到外包那边画完贴图之后，再sp里面看着效果不错，但是导入引擎中之后，不是过亮就是过暗，要么就是反射稍微有些问题。为了解决这个麻烦，通常需要同步给外包一份ue的标准光照环境方便他们导入查看效果。
这个环境有两点要求
中性
反射正确
下面说一下怎么搭建该环境
新建关卡，并打开
此时场景应为全黑环境
然后将天光，天空球，定向光源，反射球，后期这些放入场景内
打组，方便管理。然后设置相应参数
BP_Sky_Sphere参数
DirectionalLight 参数设置
Sky light 参数设置
SphereReflectionCapture参数设置
最后编译反射捕获，切换到Pc模式下，点击构建旁边的下拉箭头，再点编译反射捕获，等待读条完毕即可完成。
场景效果 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ad28c9f07544f915586213d7cfc96e5/" rel="bookmark">
			Playwright_Selenium如何选择及示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Playwright和Selenium都是用于Web UI自动化测试的工具，但是它们有一些不同的特点和功能。
Playwright是由微软开发的一个较新的框架，它使用websockt协议来操作浏览器内核，可以实时获取页面状态，也可以和浏览器双向沟通。它支持多种语言（TypeScript、JavaScript、Python、.NET、Java），多种浏览器（Chromium、WebKit和Firefox），并且可以在Windows、Linux和Mac上运行。它不需要下载浏览器驱动，可以通过命令行安装浏览器，并且启动速度很快。它还提供了一些高级的功能，比如context环境隔离、headless无头模式、无痕模式、wait_for_load_state精准等待、多种内置定位器、元素状态智能判断、iframe对象操作、alert异步监听、文件上传下载处理、多窗口标签监听、事件监听、捕获ajax请求、mock功能、expect断言、录制视频、trace追踪、断点调试等。它还可以生成pytest用例，也可以进行接口测试。总之，Playwright是一个简单方便、功能强大、稳定性高的工具。Selenium是一个出现较早的工具，它使用http协议来自动化Web浏览器，允许开发人员编写与网页和元素交互的测试。它支持更多的语言（C#,Java,Perl,PHP,Python 和Ruby），更多的浏览器（IE（7, 8, 9, 10, 11），Firefox，Safari，Google Chrome，Opera，Edge等），并且也可以在Windows，Linux，Mac上运行。但是它需要下载对应版本的浏览器驱动，并且启动速度较慢。它没有提供像Playwright那样的高级功能，而是需要开发人员自己封装或者导入其他模块来实现。比如元素等待、点击元素等操作、定位报错、元素不在当前屏幕、iframe切换、alert处理、文件上传下载处理、多窗口标签切换、执行JavaScript等。它也没有提供录制视频、trace追踪、断点调试等功能。它只能获取当时的页面状态，不能实时监听或者模拟接口数据。总之，Selenium是一个灵活性高、用户群体大、学习资料多的工具。 根据以上的介绍，我们可以看出Playwright和Selenium各有优缺点。
Playwright的优点是简单方便、功能强大、稳定性高，缺点是相对新，用户群体少，学习资料少。Selenium的优点是灵活性高、用户群体大、学习资料多，缺点是需要自己封装或者导入其他模块来实现一些功能，启动速度慢，稳定性差。 所以，在选择使用哪个工具的时候，需要根据自己的需求和情况来决定。如果你想要快速上手一个简单方便且功能强大的工具，那么Playwright可能更适合你。下面以python使用Playwright采集航班信息https://www.luckyair.net 为示例：
# 使用playwright.chromium from playwright.sync_api import sync_playwright # 设置亿牛云（动态转发隧道代理）爬虫代理加强版 代理IP的用户名和密码 proxy_username = "16IP" proxy_password = "16YUN" with sync_playwright() as p: # 启动chromium浏览器，并设置代理 browser = p.chromium.launch(proxy={"server": f"http://{proxy_username}:{proxy_password}@your_proxy_ip:your_proxy_port"}) # 启动 Chromium browser = p.chromium.launch() # 设置亿牛云（动态转发隧道代理）爬虫代理加强版 代理IP的服务器 context = browser.new_context(proxy={ "server": "http://www.16yun.cn:31000", "username": proxy_username, "password": proxy_password }) # 创建一个新页面 page = context.new_page() # 访问网站 https://www.luckyair.net page.goto("https://www.luckyair.net") # 等待页面加载完成 page.wait_for_load_state("networkidle") # 获取特价机票信息的元素列表 tickets = page.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ad28c9f07544f915586213d7cfc96e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/069fc173435babc8dd02c82cdea15d59/" rel="bookmark">
			六、安装并配置Centos7 虚拟机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考之前的文章进行，使用ios镜像镜像虚拟机安装 启动虚拟机安装，选择第一个选项 Install CentOS 7
语言选择 English，出现问题时方便百度寻求帮助
配置选择安装的软件，选择最小化安装即可 点击 network&amp;host name 设置，将开关打开，这样虚拟机系统就能连上互联网
日期和时间暂时不做设置，后续学习NTP服务时进行配置
完成以上操作配置后，点击 begin Installation 进行安装
root用户与普通用户创建 出现以下界面说明安装完成，选择 reboot 重启 登录系统 输入 ip a ，显示IP信息 这里有个ens33 能够通过dncd自动获取到网卡信息
检查网络是不是通的：ping www.baidu.com 按 Ctrl+C 退出
修改主机名称(做主机规划时用到)，指定模板机的名称
hostnamectl set-hostname sec
退出登录：logout Shell命令 Shell 是一个命令解释器，分为交互式和非交互式两种，
交互式：输入了 ls 命名并回车，系统给你回显信息；称为shell命令，基础的150条 2. 非交互式：#!/bin/bash echo “hello World” ；称为 .sh
静态IP地址配置 指定一个静态IP地址（固定IP地址），不然每次启动IP地址都不一样。
网卡的配置文件：CentOS系统中重要的文件和目录
如果被人入侵了，如何去检查，日常运维中需要监测什么？看重点的文件和目录有没有被篡改，可以写个脚本在后台执行，如果发现这些文件的MD5码发生变化，告警出来。
网卡配置文件地址：/etc/sysconfig/network-scripts/ifcfg-ens33
物理服务器-Dell品牌网卡：em1、em2、em3、em4
云主机（阿里云）：eth0
vim和vi 的知识：文本编辑器
安装 yum：yum install -y vim tree lrzsz wget curl unzip
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/069fc173435babc8dd02c82cdea15d59/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a3e74c1ad4a16f9def6021df7af0a30/" rel="bookmark">
			LitCTF-web-WP(部分)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 CSDN内容合伙人 2023年CSDN新星计划Web安全方向导师。 华为MindSpore截至目前最年轻的优秀开发者 阿里云专家博主、华为网络安全云享专家以及腾讯云自媒体分享计划博主。 吉林师范大学CTF校队——SuD0战队的队长 吉林师范大学网信网安学生负责人 核心粉丝群超过50人 带队里的师傅打了LitCTF，成绩对于初出茅庐的我们来说还不错
[LitCTF 2023]这是什么？SQL ！注一下 ！ SQL注入
输入1看看
id=1
直接sqlmap 跑一下
语法就是
sqlmap.py -u "url" --dbs --batch sqlmap.py -u "url" --D ctftrain --tables --batch .... 一把梭出来
本题flag在ctftrain里面
彩蛋在ctf里
[LitCTF 2023]Ping ping
命令执行的老题了
试试
前端验证，把js关了试试
完事
[LitCTF 2023]Follow me and hack me hackbar
[LitCTF 2023]PHP是世界上最好的语言！！ 这道题值得一说
被之前做过的题带偏思路了
之前做过一道题，类似于菜鸟教程那种界面，可以运行PHP，当运行PHP时会短暂将执行代码存储在后台服务器
实际上直接跑就行了
[LitCTF 2023]作业管理系统 admin/admin
在创建文件的点里写个🐎
拿蚁剑连
慢慢翻
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75aaa7c7c3cafd81776e989ad2a6a07c/" rel="bookmark">
			springcloudAlibaba-getway
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		依赖：
配置：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67aaf6bea4da27812152381851ae87a9/" rel="bookmark">
			zookeeper查看jps有进程，查看状态却是not running
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		查看日志信息，显示拒绝连接
2023-05-15 11:33:08,347 [myid:1] - WARN [WorkerSender[myid=1]:QuorumCnxManager@685] - Cannot open channel to 2 at election address slave1/192.168.3.66:3888
java.net.ConnectException: 拒绝连接 (Connection refused)
at java.net.PlainSocketImpl.socketConnect(Native Method)
at java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:350)
at java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:206)
at java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:188)
at java.net.SocksSocketImpl.connect(SocksSocketImpl.java:392)
at java.net.Socket.connect(Socket.java:589)
at org.apache.zookeeper.server.quorum.QuorumCnxManager.connectOne(QuorumCnxManager.java:656)
at org.apache.zookeeper.server.quorum.QuorumCnxManager.connectOne(QuorumCnxManager.java:713)
at org.apache.zookeeper.server.quorum.QuorumCnxManager.toSend(QuorumCnxManager.java:626)
at org.apache.zookeeper.server.quorum.FastLeaderElection$Messenger$WorkerSender.process(FastLeaderElection.java:477)
at org.apache.zookeeper.server.quorum.FastLeaderElection$Messenger$WorkerSender.run(FastLeaderElection.java:456)
at java.lang.Thread.run(Thread.java:748)
解决办法：关闭防火墙 systemctl stop firewalld
systemctl disable firewalld 再次启动就可以看到状态了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b79482052e3f50c81a4628e6cb6d1cfb/" rel="bookmark">
			本地改变代码但是打包jar包代码没有改变
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：maven项目A要打成Jar包A，依赖了另外一个项目B生成的Jar包B。更改了代码，然后打包项目发现项目没有更新
解决办法：clean时要在总maven依赖下clean后install打包
参考 : Maven项目打包，Jar包不更新的问题_weixin_34014277的博客-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1edce88f2f1be4a43c65474e63ce0714/" rel="bookmark">
			IoT Studio场景最佳实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.使用IoT Studio快速构建可视化应用
在物联网业务场景中设备数据可视化应用是最普遍的需求，阿里云物联网应用开发（IoT Studio）提供了Web可视化开发、移动可视化开发、业务逻辑开发与物联网数据分析等一系列便捷的物联网开发工具，解决物联网开发领域开发链路长、定制化程度高、投入产出比低、技术栈复杂、协同成本高、方案移植困难等问题。
本次物联网场景最佳实践我们用六合一传感器（温度、湿度、二氧化碳、PM2.5、PM10、甲醛）实现家庭环境数据实时采集，通过家中Wi-Fi上报到阿里云IoT物联网平台，借助IoT Studio低代码工具搭建可视化大屏，实时监控家中环境指标变化。
完整内容请点击下方链接查看： IoT Studio场景最佳实践-阿里云开发者社区
版权声明：本文内容由阿里云实名注册用户自发贡献，版权归原作者所有，阿里云开发者社区不拥有其著作权，亦不承担相应法律责任。具体规则请查看《 阿里云开发者社区用户服务协议》和《 阿里云开发者社区知识产权保护指引》。如果您发现本社区中有涉嫌抄袭的内容，填写 侵权投诉表单进行举报，一经查实，本社区将立刻删除涉嫌侵权内容。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/673501c0769a7e7d47d974d384eb8925/" rel="bookmark">
			MySQL数据库——MySQL查看触发器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		查看触发器是指查看数据库中已经存在的触发器的定义、状态和语法信息等。MySQL 中查看触发器的方法包括 SHOW TRIGGERS 语句和查询 information_schema 数据库下的 triggers 数据表等。下面详细介绍这两种查看触发器的方法。
SHOW TRIGGERS语句查看触发器信息 在 MySQL 中，可以通过 SHOW TRIGGERS 语句来查看触发器的基本信息，语法格式如下：
SHOW TRIGGERS; 示例 1
首先创建一个数据表 account，表中有两个字段，分别是 INT 类型的 accnum 和 DECIMAL 类型的 amount。SQL 语句和运行结果如下：
mysql&gt; CREATE TABLE account( -&gt; accnum INT(4), -&gt; amount DECIMAL(10,2)); Query OK, 0 rows affected (0.49 sec) 创建一个名为 trigupdate 的触发器，每次 account 表更新数据之后都向 myevent 数据表中插入一条数据。创建数据表 myevent 的 SQL 语句和运行结果如下：
mysql&gt; CREATE TABLE myevent( -&gt; id INT(11) DEFAULT NULL, -&gt; evtname CHAR(20) DEFAULT NULL); Query OK, 0 rows affected (0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/673501c0769a7e7d47d974d384eb8925/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04691683b9c80e08c7028f19c4ef1acf/" rel="bookmark">
			2023年全国职业院校技能大赛 高等职业教育组（信息安全与评估赛项）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		全国职业院校技能大赛
高等职业教育组
信息安全管理与评估
赛题一
模块一
网络平台搭建与设备安全防护
一、 赛项时间
共计180分钟。
二、 赛项信息
竞赛阶段 任务阶段 竞赛任务 竞赛时间 分值
第一阶段
网络平台搭建与设备安全防护 任务1 网络平台搭建 XX:XX- XX:XX 50
任务2 网络安全设备配置与防护 250
三、 赛项内容
本次大赛，各位选手需要完成三个阶段的任务，其中第一个阶段需要按裁判组专门提供的U盘中的“XXX-答题模板”提交答案。第二、三阶段请根据现场具体题目要求操作。
选手首先需要在U盘的根目录下建立一个名为“GWxx”的文件夹（xx用具体的工位号替代），赛题第一阶段所完成的“XXX-答题模板”放置在文件夹中。
例如：08工位，则需要在U盘根目录下建立“GW08”文件夹，并在“GW08”文件夹下直接放置第一个阶段的所有“XXX-答题模板”文件。
特别说明：只允许在根目录下的“GWxx”文件夹中体现一次工位信息，不允许在其他文件夹名称或文件名称中再次体现工位信息，否则按作弊处理。
(一) 赛项环境设置
某集团公司原在北京建立了总部，在南京设立了分公司。总部设有销售、产品、财务、信息技术4个部门，分公司设有销售、产品、财务3个部门，统一进行IP及业务资源的规划和分配，全网采用OSPF动态路由协议和静态路由协议进行互连互通。公司规模在2023年快速发展，业务数据量和公司访问量增长巨大。为了更好管理数据，提供服务，集团决定建立自己的中型数据中心及业务服务平台，以达到快速、可靠交换数据，以及增强业务部署弹性的目的。集团、分公司的网络结构详见拓扑图。其中总公司使用一台SW交换机用于总部核心和终端高速接入，采用一台BC作为总公司因特网出口；分公司采用一台FW防火墙作为因特网出口设备，一台AC作为分公司核心，同时作为集团有线无线智能一体化控制器，通过与AP高性能企业级AP配合实现集团无线覆盖，总部有一台WEB服务器，为了安全考虑总公司部署了一台WAF对服务器进行web防护。在2023年公司进行IPV6网络改造，内部网络采用双栈模式。Ipv6 网络采用ospf V3实现互通。
网络拓扑图
IP地址规划表
设备名称 接口 IP地址 对端设备 接口
防火墙FW ETH0/1-2 20.1.0.1/30（trust1安全域） SW
eth1/0/1-2
20.1.1.1/30（untrust1安全域） SW 222.22.1.1/29（untrust） SW ETH0/3 20.10.28.1/24(DMZ) WAF Eth0/4-5 20.1.0.13/30
2001:da8:192:168:10:1::1/96 AC Eth1/0/21-22
Loopback1 20.0.0.254/32（trust）
Router-id L2TP Pool 192.168.10.1/26
可用IP数量为20 L2tp VPN地址池 三层交换机SW ETH1/0/4 财务专线 VPN CW AC ETH1/0/4
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04691683b9c80e08c7028f19c4ef1acf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6f58b347e0c5195a01a727d078d7c90/" rel="bookmark">
			java-jwt
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一. JWT 基础解释二. JWT Token 组成三. Java 与 JWT1. java-jwt2. jjwt-root 三. 实际开发中 JWT 的使用 一. JWT 基础解释 先了解几个问题 JSON数据使用base64url编码,只对JSON数据是先扁平化处理再用64个可读无冲突字符来表达,没有加密效果SHA256的摘要只是为JSON数据生成一个“指纹”,防止被篡改,属于完整性范畴,也无任何加密效果摘要不等于签名,签名是用私钥加密摘要,默认情况下Token本身并没有任何加密机制,它依赖于HTTPS的通道保密能力,Token增加加密机制需要自行处理 在介绍JWT之前,我们可以先说一下实现用户验证发展的几个步骤 请求接口时使用http协议,http协议本身是一种无状态的协议,用户登录后,下次再次访问接口,无法判断用户身份,进而提出了Cookie 与Session, cookie是存储在客户端的,如果被截获,可能会出现跨站请求伪造的攻击,session是存在服务端的,但是现在都基于微服务,需要考虑多服务节点情况下session同步问题后续提出了基于token进行用户身份校验 简单说一下token进行用户身份验证的流程： 客户端使用用户名和密码请求登录, 服务端收到请求，验证用户名和密码验证成功后,服务端会签发一个token,并将token返回给客户端客户端收到token后,缓存token,后续向服务端发送请求时在header中携带服务端签发的token服务端收到请求,先对客户端请求中携带的token进行验证优点: cookie是无法跨域的,而token由于没有用到cookie(前提是将token放到请求头中)所以跨域后不会存在信息丢失问题,token机制在服务端不需要存储session信息,因为token自身包含了所有登录用户的信息,因此也就不需要session同步,更适用CDN：可以通过内容分发网络请求服务端的所有资料,更适用于移动端:因为移动端不支持cookie, 既然不使用cookie也就无需考虑CSRF JWT官网链接什么是JWT: JWT是JSON Web Token的简称,就是上述流程当中token的一种具体实现方式,通俗地说,JWT的本质就是一个保存了用户信息的Json字符串,然后进行编码后得到一个JWT token,并且这个JWT token带有签名信息,接收后可以校验是否被篡改,所以可以用于在各方之间安全地将信息作为Json对象传输JWT用户认证执行流程 前端将用户信息发送给后端(建议通过SSL加密的传输(HTTPS)，从而避免敏感信息被嗅探)后端核对用户名和密码成功后,将包含用户信息的数据作为JWT的Payload,将其与JWT Header分别进行Base64编码拼接后签名,形成一个JWT Token,例如lll.zzz.xxx的字符串后端将Token字符串作为登录成功的结果返回给前端,前端在后续请求接口时将Token放入HTTP请求头中的Authorization属性中(解决XSS和XSRF问题),用户退出登录时删除保存的JWT Token后端接收到前端请求后先校验Token是否有效,比如检查签名是否正确,是否过期,token的接收方是否是自己等等 说一下JWT的优点 简洁：JWT Token数据量小，传输速度也很快JWT是跨语言的: 因为JWT Token是以JSON加密形式保存在客户端的，所以，原则上任何web形式都支持不依赖于cookie和session, 不需要在服务端保存会话信息,特别适用于分布式微服务既然不依赖于cookie和session,可以将token缓存到redis等,就不需要考虑session多服务节点的同步问题,及cookie无法跨域的问题,更适用与单点登录, 移动端 二. JWT Token 组成 前面说过JWT的本质就是一个保存了用户信息的Json字符串,编码后得到的一个JWTtoken,这个JWTtoken带有签名信息,接收后可以校验是否被篡改,那么这个Toke是怎么生成的,组成部分有哪些JWT由3部分组成：Header标头,Payload有效载荷和Signature签名, 在传输的时候,将这3部分分别进行Base64编码后连接形成最终传输的字符串 JWTString=Base64(Header).Base64(Payload).HMACSHA256(base64UrlEncode(header)+"."+base64UrlEncode(payload),secret) JWT Header标头,是用来描述JWT元数据的JSON对象,包含alg属性与typ属性,其中alg表示签名使用的算法,默认为HMAC SHA256(写为HS256), typ属性表示令牌的类型,在JWT令牌统一写为JWT,然后使用Base64URL算法将上述这个JSON对象转换为字符串保存,例如 { "alg": "HS256", "typ": "JWT" } Payload有效载荷,是JWT的主体内容部分,也是一个JSON对象,包含需要传递的数据,在JWT中默认有一下七个字段供选择, 这七个预定义字段并不要求强制使用,并且除以上默认字段外,我们还可以自定义私有字段,例如将包含用户信息的数据放到payload中 注意点: 默认情况下JWT只是采用base64算法进行了一次编码,并未加密的,拿到JWT字符串后可以转换回原本的JSON数据,因此不要构建隐私信息字段,比如用户的密码不要保存到JWT中,以防止信息泄露,默认情况下JWT只适合在网络中传输一些非敏感信息
//1.Payload有效载荷默认提供的七个预定义字段,不要求强制使用 iss：发行人 exp：到期时间 sub：主题 aud：用户 nbf：在此之前不可用 iat：发布时间 jti：JWT ID用于标识该JWT //2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d6f58b347e0c5195a01a727d078d7c90/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f530afe95289b850c113acf60ad47e80/" rel="bookmark">
			BGP协议介绍总结（全干货）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
BGP的基本概述
BGP的分类
BGP的工作过程
BGP 与 IGP 交互
BGP 安全性
BGP 的路由优选规则和负载分担
前言 想弄清bgp概念之前，先了解什么是bgp。bgp协议：边界网关协议（Border Gateway Protocol，BGP）是一种用来在路由选择域之间交换网络层可达性信息（Network Layer Reachability Information，NLRI）的路由选择协议。由于不同的管理机构分别控制着他们各自的路由选择域，因此，路由选择域经常被称为自治系统AS（Autonomous System）。现在的Internet是一个由多个自治系统相互连接构成的大网络，BGP作为事实上的Internet外部路由协议标准，被广泛应用于ISP（Internet Service Provider）之间。
BGP的基本概述 1、BGP使用TCP作为其传输层协议（监听端口号为179），提高了协议的可靠性，且不需要专门 机制来确保连接的可控性。BGP进行域间的路由选择，对协议的稳定性要求非常高。因此用TCP协议的高可靠性来保证BGP协议的稳定性。BGP的对等体之间必须在逻辑上连通，并进行TCP连接。目的端口号为179，本地端口号任意。
2、路由更新时，BGP只发送更新的路由，大大减少了BGP传播路由所占用的带宽，适用于在Internet上传播大量的路由信息。
3、BGP从设计上避免了环路的发生。AS之间：BGP通过携带AS路径信息来标记途经的AS，带有本地AS号的路由将被丢弃，从而避免了域间产生环路。AS内部：BGP在AS内学到的路由不再通告给AS内的BGP邻居，避免了AS内产生环路。
4、支持CIDR 无类域间路由
5、BGP提供了丰富的路由策略；提供了防止路由振荡的机制；BGP也易于扩展
BGP的分类 BGP 按照运行方式分为 EBGP（External/Exterior BGP）和 IBGP（Internal/Interior BGP）。 1、EBGP：运行于不同 AS 之间的 BGP 称为 EBGP。为了防止 AS 间产生环路，当 BGP 设备接收 EBGP 对等体发送的路由时，会将带有本地 AS 号的路由丢弃。
2、IBGP：运行于同一 AS 内部的 BGP 称为 IBGP。为了防止 AS 内产生环路， BGP 设备不将从IBGP 对等体学到的路由通告给其他 IBGP 对等体，并与所有 IBGP 对等体建立全连接。为了解决 IBGP 对等体的连接数量太多的问题， BGP 设计了路由反射器和 BGP 联盟。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f530afe95289b850c113acf60ad47e80/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d993904e8730b282169a695cbbf6ab8/" rel="bookmark">
			LitCTF2023 Reverse 题解及复现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一.enbase641.main函数2.换表函数3. check函数4. 解题脚本: 二.snake1. 修复MagicNumber2. 反编译3. 解题脚本 三.For Aiur1. 注意点2. 解包3. 反编译4. 解题脚本 四.程序和人有一个能跑就行了1. fakeflag2. 真flag 五.debase641. encode函数2. 函数逻辑3. 根据程序逻辑得到前16个字符4. 爆破后四个字符得到flag 一.enbase64 1.main函数 经典的base64换表,第10和11行作用重复,12行也没有实际作用,此处的base表根本没有变化
2.换表函数 在17行的base64函数中有一个basechange换表操作
basechange函数关键代码:
result = strcpy(des, table); for ( i = 0; i &lt;= 47; ++i ) { for ( j = 0; j &lt;= 63; ++j ) table[j] = des[key[j]];	//换表1 result = strcpy(des, table);	//换表2 } return result; } 3. check函数 basecheck函数:用于检查input经过加密后是否正确
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d993904e8730b282169a695cbbf6ab8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30654639090743ae4220a2e02b0ade2f/" rel="bookmark">
			教你彻底读懂java中的IO流！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一、IO概念
二、来理解“流”是什么？
三、IO流的分类 • 1、按照流的方向（输出输入都是站在程序所在内存的角度划分的）
四、流的原理以及一共有多少IO流
• 2、java中所有流汇总
五、常见IO流的实战
前言 • I/O 即输入Input/ 输出Output的缩写，其实就是计算机调度把各个存储中（包括内存和外部存储）的数据写入写出的过程；
• java中用“流（stream）”来抽象表示这么一个写入写出的功能，封装成一个“类”，都放在http://java.io这个包里面。
一、IO概念 • I/O 即输入Input/ 输出Output的缩写，其实就是计算机调度把各个存储中（包括内存和外部存储）的数据写入写出的过程；
• java中用“流（stream）”来抽象表示这么一个写入写出的功能，封装成一个“类”，都放在http://java.io这个包里面。
二、来理解“流”是什么？ 通过“流”的形式允许java程序使用相同的方式来访问不同的输入/输出源。stream是从起源（source）到接收的（sink）的有序数据。我们这里把输入/输出源对比成“水桶”，那么流就是“管道”，这个“管道”的粗细、单向性等属性也就是区分了不同“流”的特性。 三、IO流的分类 可以从三个不同的维度进行分类：
• 1、按照流的方向（输出输入都是站在程序所在内存的角度划分的） • 输入流：只能从中读取数据【主要由InputStream和Reader作为基类】
• 输出流：只能向其写入数据【主要由outputStream和Writer作为基类】
在下图中，从磁盘读取数据到内存是输入流，从client读取数据到server是输入流；同样，把内存数据写到磁盘是输出流，把server数据写到client是输出流
• 2、按照流的操作颗粒度划分
• 字节流：以字节为单元，可操作任何数据【主要由InputStream和outPutStream作为基类】
• 字符流：以字符为单元，只能操作纯字符数据，比较方便【主要由Reader和Writer作为基类】
• 3、按照流的角色划分
• 节点流：可以从/向一个特定的IO设备（如磁盘，网络）读/写数据的流，也叫【低级流，主要由】
• 处理流：用于对一个已存在的流进行连接和封装，通过封装后的流来实现数据的读/写功能，也叫【高级流】
四、流的原理以及一共有多少IO流 • 1、流的原理解析
流其实我们可以想象成一个“水管”，源端和目的端就是两个“水桶”，数据是通过这个“水管”进行流动传输的，以InputStream和Reader为例，水管的每个“水滴”就是具体的数据，如果是字节流，那么一个“水滴”就是一个字节，如果是字符流，那么一个“水滴”就是一个字符。
当创建一个流对象的时候，如fis=new FileInputStream（“…\xx\xx.txt”），记录指针来表示当前正准备从哪个“水滴”开始读取，每当程序从InputStream或者Reader里面取出一个或者多个“水滴”后，记录指针自定向后移动；除此之外，InputStream和Reader里面都提供了一些方法来控制记录指针的移动。
如果是处理流的话，就相当于在这个水管上面装了一些“控制阀门”，最终用户只要关心“阀门”具备的能力就行
• 2、java中所有流汇总 http://java.io中子类有40个“流”类，我们用以下表格来综合划分，当然这些流你不用都去花时间一个一个看过来，我们只要熟悉掌握几类常用的“流”就足够了，后续项目中如果用到陌生的“流”，知道原理的话可以快速地去检索学习下就ok了。
五、常见IO流的实战 1、访问操作文件（FileInputStream/FileReader ，FileOutputStream/FileWriter）
FileInputStream中包含以使用FileInputStream为例，类中包含的属性及方法，我们可以在线查看jdk的api文档http://tool.oschina.net/apidocs/apidoc?api=jdk-zh），下面只是截图了FileInputStream的构造方法：
1）使用FileInputStream，从文件读取数据
import java.io.*; public class TestFileImportStream { public static void main(String[] args) { int b=0; FileInputStream in = null; try { in =new FileInputStream("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/30654639090743ae4220a2e02b0ade2f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b51bc9db6c31462afb19df0b9447194f/" rel="bookmark">
			系统开发与运行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系统开发与运行
系统分析与设计
需求分析
需求工程
结构化分析与设计
测试基础知识
系统运行与维护
软件架构介绍
系统分析概述 系统分析是一种问题求解技术，它将一个系统分解成各个组成部分， 目的是研究各个部分如何工作、交互,以实现其系统目标。
目的和任务：
系统分析的主要任务是对现行系统进一步详细调查，将调查中所得到的文档资料集中,对组织内部整体管理状况和信息处理过程进行分析,为系统开发提供所需的资料,并提交系统方案说明书。
系统分析的主要步骤：
(1) 认识、理解当前的现实环境,获得当前系统的“物理模型”。
(2) 从当前系统的“物理模型”抽象出当前系统的“逻辑模型”。
(3) 对当前系统的“逻辑模型”进行分析和优化,建立目标系统的“逻辑模型”。
(4) 对目标系统的逻辑模型具体化（物理化），建立目标系统的物理模型。
系统开发的目的是将现有系统的物理模型转换为目标系统的物理模型。
系统设计 系统设计基本原理：
抽象（重点说明本质方面，忽略非本质方面）；模块化（可组合、分解和更换的单元）；信息隐蔽（将每个程序的成分隐蔽或封装在一个单一的设计模块中）；模块独立（每个模块完成一个相对独立的特定子功能，且与其他模块之间的联系简单）。 模块的设计要求独立性高，就必须高内聚，低耦合，
内聚是指一个模块内部功能之间的相关性，耦合是指多个模块之间的联系。 内聚⭐️⭐️⭐️ 内聚程度从低到高如下表所示：
内聚分类
定义
记忆关键字
偶然内聚。
一个模块内的各处理元素之间没有任何联系
无直接关系。
逻辑内聚 模块内执行若干个逻辑上相似的功能，通过参数确定该模块完成哪一个功能
逻辑相似、参数决定
时间内聚
把需要同时执行的动作组合在一起形成的模块。
同时执行
过程内聚
一个模块完成多个任务，这些任务必须按指定的过程执行
指定的过程顺序
通信内聚1
模块内的所有处理元素都在同一个数据结构上操作,或者各处理使用相同的输入数据或者产生相同的输出数据。
相同数据结构、相同输入输出
顺序内聚
一个模块中的各个处理元素都密切相关于同一功能且必须顺序执行，前一个功能元素的输出就是下一个功能元素的输入。
顺序执行、输入为输
出
功能内聚
最强的内聚，模块内的所有元素共同作用完成一个功能，缺一不可
共同作用、缺一不可
耦合⭐️⭐️⭐️ 耦合程度从低到高如下表所示：
耦合分类
定义
记忆关键字
无直接耦合。
两个模块之间没有直接的关系，它们分别从属于不同模块的控制与调用,不传递任何信息。
无直接关系。
数据耦合。
两个模块之间有调用关系，传递的是简单的数据值，相当于高级语言中的值传递。
传递数据值调用。
标记耦合
两个模块之间传递的是数据结构。
传递数据结构
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b51bc9db6c31462afb19df0b9447194f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71d2fb1bfca879dae57f16030fa14de8/" rel="bookmark">
			面向对象技术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		面向对象技术 面向对象基础
面向对象基本概念
面向对象分析
面向对线设计
面向对象测试
UML 事务
关系
图
设计模式 创建型设计模式
结构型设计模式
行为型设计模式
面向对象基本概念 面向对象基本概念 达成目标具体需要做哪些事情。
对象 : 基本的运行实体,为类的实例，封装了数据和行为的整体，如学生、汽车等真实存在的实体。对象具有清晰的边界、良好定义的行为和可扩展性。消息 : 对象之间进行通信的一种构造称为消息类 : 是对象的抽象，定义了一组大体相似的对象结构，定义了数据和行为,包括实体类（用于对必须存储的信息和相关行为建模的类，是需要长久保存且一直存在的类）、边界类（系统内部与系统外部的业务主角之间进行交互建模的类）、控制类（用于对一个或几个用例所特有的控制行为进行建模，在用例执行过程中被动出现的特定行为的类）。在领域类模型中会涉及描述类自身情况的属性与操作，还会有描述类与类之间的关联，但不会有对象层次的内容。 继承 父类和子类之间共享数据和方法的机制。是类之间的一种关系。多态 不同的对象收到同一个消息时产生完全不同的反应。包括参数多态（不同类型参数多种结构类型）、包含多态（父子类型关系）、过载多态（类似于重载，一型个名字不同含义）、强制多态（强制类型转换）四种类型。多态由继承机制支持。 多态 不同的对象收到同一个消息时产生完全不同的反应。包括参数多态（不同类型参数多种结构类型）、包含多态（父子类型关系）、过载多态（类似于重载，一型个名字不同含义）、强制多态（强制类型转换）四种类型。多态由继承机制支持。 面向对象基本概念 为完成目标，设置 3-5 条坚持做和禁止做的事情。
覆盖：
子类在原有父类接口的基础上，用适合于自己要求的实现去置换父类中的相应实现。即在子类中重定义一个与父类同名同参的方法。ss
函数重载：
与覆盖要区分开，函数重载与子类父类无关，且函数是同名不同参数。
封装：
一种信息隐蔽技术，其目的是使对象的使用者和生产者分离，也就是使其他开发人员无需了解所要使用的软件组件内部的工作机制，只需知道如何使用组件。
静态类型 动态类型
静态类型是指一个对象的类型在编译时就确定；动态类型指对象类型在运行时才能确定。 静态绑定 动态绑定
静态绑定（静态分配）是基于静态类型的，在程序执行前方法已经被绑定；动态绑定是基于动态类型的，运行时根据变量实际引用的对象类型决定调用哪个方法，动态绑定支持多态。 面向对象分析设计 面向对象分析：
是为了确定问题域，理解问题。
包含五个活动：
认定对象（按自然存在的实体确定对象）、组织对象（分析对象关系，抽象成类）、对象间的相互作用（描述各对象在应用系统中的关系）、确定对象的操作（操作，如创建增加删除等）、定义对象的内部信息（属性）。 ...
面向对象设计：
是设计分析模型和实现相应源代码，在目标代码环境中这种源代码可被执行。设计问题域的解决方案。
面向对象程序设计：
用面向对象程序设计语言实现设计方案。详见下午软件设计。
面向对象测试：
与普通测试步骤并无不同。
可分为四个层次：
算法层（测试类中定义的每个方法，类似单元测试）、类层（测试同一个类中所有方法与属性的相互作用，特有的模块测试）、模板层（测试一组协同工作的类之间的相互作用，类似集成测试）、系统层（类似系统测试）。 ...
例（2012年下半年）：38-39.在面向对象技术中，说明一个对象具有多种形态，_39_定义超类与子类之间的关系。
（38）A. 继承
B. 组合
c. 封装
D. 多态
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/71d2fb1bfca879dae57f16030fa14de8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b07f6810616dc8fd4067f1a2ec0faa5/" rel="bookmark">
			[云原生s8s]常用资源YAML详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
Pod资源对象yaml详解
Deployment资源对象详解
Service资源对象yaml详解
Pod资源对象yaml详解 apiVersion: v1 #必选，版本号，例如v1 kind: Pod #必选，指定创建资源的角色/类型 metadata: #必选，资源的元数据/属性 name: string #必选，资源的名字，在同一个namespace中必须唯一 namespace: string #必选，Pod所属的命名空间 labels: #自定义标签,使这个标签在service网络中备案，以便被获知 - name: string #自定义标签名字 annotations: #设置自定义注解列表 - name: string #设置自定义注解名字 spec: #必选，设置该资源的详细定义 containers: #必选，Pod中容器列表 - name: string #必选，容器名称 image: string #必选，容器的镜像名称 imagePullPolicy: [Always | Never | IfNotPresent] #获取镜像的策略 Alawys表示下载镜像 IfnotPresent表示优先使用本地镜像，否则下载镜像，Nerver表示仅使用本地镜像 command: [string] #容器的启动命令列表，如不指定，使用打包时使用的启动命令 args: [string] #容器的启动命令参数列表 workingDir: string #容器的工作目录 volumeMounts: #挂载到容器内部的存储卷配置 - name: string #引用pod定义的共享存储卷的名称，需用volumes[]部分定义的的卷名 mountPath: string #存储卷在容器内mount的绝对路径，应少于512字符 readOnly: boolean #是否为只读模式 ports: #需要暴露的端口库号列表 - name: string #端口号名称 containerPort: int #容器需要监听的端口号 hostPort: int #容器所在主机需要监听的端口号，默认与Container相同 protocol: string #端口协议，支持TCP和UDP，默认TCP env: #容器运行前需设置的环境变量列表 - name: string #环境变量名称 value: string #环境变量的值 resources: #资源限制和请求的设置 limits: #资源限制的设置 cpu: string #Cpu的限制，单位为core数，将用于docker run --cpu-shares参数 memory: string #内存限制，单位可以为Mib/Gib，将用于docker run --memory参数 requests: #资源请求的设置 cpu: string #Cpu请求，容器启动的初始可用数量 memory: string #内存清楚，容器启动的初始可用数量 livenessProbe: #对Pod内个容器健康检查的设置，当探测无响应几次后将自动重启该容器，检查方法有exec、httpGet和tcpSocket，对一个容器只需设置其中一种方法即可 exec: #对Pod容器内检查方式设置为exec方式 command: [string] #exec方式需要制定的命令或脚本 httpGet: #对Pod内个容器健康检查方法设置为HttpGet，需要制定Path、port path: string port: number host: string scheme: string HttpHeaders: - name: string value: string tcpSocket: #对Pod内个容器健康检查方式设置为tcpSocket方式 port: number initialDelaySeconds: 0 #容器启动完成后首次探测的时间，单位为秒 timeoutSeconds: 0 #对容器健康检查探测等待响应的超时时间，单位秒，默认1秒 periodSeconds: 0 #对容器监控检查的定期探测时间设置，单位秒，默认10秒一次 successThreshold: 0 failureThreshold: 0 securityContext: privileged:false restartPolicy: [Always | Never | OnFailure]#Pod的重启策略，Always表示一旦不管以何种方式终止运行，kubelet都将重启，OnFailure表示只有Pod以非0退出码退出才重启，Nerver表示不再重启该Pod nodeSelector: obeject #设置NodeSelector表示将该Pod调度到包含这个label的node上，以key：value的格式指定 imagePullSecrets: #Pull镜像时使用的secret名称，以key：secretkey格式指定 - name: string hostNetwork:false #是否使用主机网络模式，默认为false，如果设置为true，表示使用宿主机网络 volumes: #在该pod上定义共享存储卷列表 - name: string #共享存储卷名称 （volumes类型有很多种） emptyDir: {} #类型为emtyDir的存储卷，与Pod同生命周期的一个临时目录。为空值 hostPath: string #类型为hostPath的存储卷，表示挂载Pod所在宿主机的目录 path: string #Pod所在宿主机的目录，将被用于同期中mount的目录 secret: #类型为secret的存储卷，挂载集群与定义的secre对象到容器内部 scretname: string items: - key: string path: string configMap: #类型为configMap的存储卷，挂载预定义的configMap对象到容器内部 name: string items: - key: string path: string点 Deployment资源对象详解 apiVersion: extensions/v1beta1 kind: Deployment metadata: ----------------------------------------#元数据 annotations: -------------------------------------#注释信息 deployment.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b07f6810616dc8fd4067f1a2ec0faa5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72de552dd31507a2f7e01f5f81a40ebf/" rel="bookmark">
			【精华】百度云JAVA面试经验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		百度云二面，这轮问的问题很抽象，算法题比较多
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/524078d497b5a899497e235cf2cd58ed/" rel="bookmark">
			数据科学中使用的17 种相似性和相异性度量之欧氏距离
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1简介
2距离函数
2.1 L2范数（欧氏距离）
1简介 在数据科学中，相似性度量是一种衡量数据样本如何相互关联或相互接近的方法。另一方面，相异性度量是告诉数据对象有多少是不同的。此外，当相似的数据样本被分组到一个集群中时，这些术语通常用于聚类。所有其他数据样本被分组到不同的样本中。它还用于分类（例如 KNN），其中根据特征的相似性标记数据对象。另一个例子是当我们谈论与其他数据样本相比不同的异常值时（例如，异常检测）。
相似性度量通常表示为一个数值：当数据样本越相似时它就越高。它通常通过转换表示为零和一之间的数字：零表示相似度低（数据对象不相似）。一是相似度高（数据对象非常相似）。
让我们举一个例子，其中每个数据点只包含一个输入特征。这可以被认为是显示三个数据点 A、B 和 C 之间差异性的最简单示例。每个数据样本可以在一个轴上具有单个值（因为我们只有一个输入特征）；让我们将其表示为 x 轴。让我们取两个点，A(0.5)、B(1) 和 C(30)。如您所知，与 C 相比，A 和 B 彼此足够接近。因此，A 和 B 之间的相似性高于 A 和 C 或 B 和 C。换句话说，A 和 B 具有很强的相关性。因此，距离越小，相似度越大。
当且仅当它满足以下四个条件时，给定的距离（例如相异性）才能成为度量：
1- 非负性：对于任意两个不同的观察值 p 和 q，d(p, q) ≥ 0。
2- 对称性：对于所有 p 和 q，d(p, q) = d(q, p)。
3- 三角不等式：对于所有 p、q、r，d(p, q) ≤ d(p, r) + d(r, q)。
4-仅当 p = q 时 d(p, q) = 0。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/524078d497b5a899497e235cf2cd58ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cdf49e22df9b0d48c60c2aca349e07ed/" rel="bookmark">
			数据结构7 -查找
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 顺序（线性）查找 从第一个数开始遍历查找到最后一个数。（有序无序不影响）
//判断数列中是否包含此value 如果找到了，就提示找到，并给出下标值。 public static ArrayList seqSearch(int[] arr, int value){ ArrayList&lt;Integer&gt; result = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; arr.length; i++) { if(arr[i] == value) result.add(i); } return result; } 2. 二分查找 只能对有序数组查找。
1）只查找到一个符合结果的数就行（假设传入的数组是从小到大排列的有序数组）：
/* * 只查找到一个符合结果的数就行 * * 假设传入的数组是从小到大排列的有序数组 * */ public int binarySearch(int[] arr, int left, int right, int findVal){ if(left &gt; right) return -1; int mid = (left + right) / 2; if(findVal &gt; arr[mid]) return binarySearch(arr, mid + 1, right, findVal ); else if(findVal &lt; arr[mid]) return binarySearch(arr, left, mid - 1, findVal ); else return mid; } 2）有多个符合条件的值
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cdf49e22df9b0d48c60c2aca349e07ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59474079b05ddd343d731f4d61567626/" rel="bookmark">
			图解浏览器的基本工作原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 可能每一个前端工程师都想要理解浏览器的工作原理。
我们希望知道从在浏览器地址栏中输入 url 到页面展现的短短几秒内浏览器究竟做了什么；
我们希望了解平时常常听说的各种代码优化方案是究竟为什么能起到优化的作用；
我们希望更细化的了解浏览器的渲染流程。
浏览器的多进程架构 一个好的程序常常被划分为几个相互独立又彼此配合的模块，浏览器也是如此，以 Chrome 为例，它由多个进程组成，每个进程都有自己核心的职责，它们相互配合完成浏览器的整体功能，每个进程中又包含多个线程，一个进程内的多个线程也会协同工作，配合完成所在进程的职责。
对一些前端开发同学来说，进程和线程的概念可能会有些模糊，为了更好的理解浏览器的多进程架构，这里我们简单讨论一下进程和线程。
进程（process）和线程（thread）
进程就像是一个有边界的生产厂间，而线程就像是厂间内的一个个员工，可以自己做自己的事情，也可以相互配合做同一件事情。
当我们启动一个应用，计算机会创建一个进程，操作系统会为进程分配一部分内存，应用的所有状态都会保存在这块内存中，应用也许还会创建多个线程来辅助工作，这些线程可以共享这部分内存中的数据。如果应用关闭，进程会被终结，操作系统会释放相关内存。更生动的示意图如下：
进程（process）和线程（thread)
一个进程还可以要求操作系统生成另一个进程来执行不同的任务，系统会为新的进程分配独立的内存，两个进程之间可以使用 IPC （Inter Process Communication）进行通信。很多应用都会采用这样的设计，如果一个工作进程反应迟钝，重启这个进程不会影响应用其它进程的工作。
进程间通过 IPC 通信
如果对进程及线程的理解还存在疑惑，可以参考下述文章。
进程与线程的一个简单解释 - 阮一峰的网络日志​www.ruanyifeng.com/blog/2013/04/processes_and_threads.html正在上传…重新上传取消
浏览器的架构
有了上面的知识做铺垫，我们可以更合理的讨论浏览器的架构了，其实如果要开发一个浏览器，它可以是单进程多线程的应用，也可以是使用 IPC 通信的多进程应用。
不同浏览器的架构模型
不同浏览器采用了不同的架构模式，这里并不存在标准，本文以 Chrome 为例进行说明 ：
Chrome 采用多进程架构，其顶层存在一个 Browser process 用以协调浏览器的其它进程。
Chrome 的不同进程
具体说来，Chrome 的主要进程及其职责如下：
Browser Process： 负责包括地址栏，书签栏，前进后退按钮等部分的工作；负责处理浏览器的一些不可见的底层操作，比如网络请求和文件访问； Renderer Process： 负责一个 tab 内关于网页呈现的所有事情 Plugin Process： 负责控制一个网页用到的所有插件，如 flash GPU Process 负责处理 GPU 相关的任务 不同进程负责的浏览器区域示意图
Chrome 还为我们提供了「任务管理器」，供我们方便的查看当前浏览器中运行的所有进程及每个进程占用的系统资源，右键单击还可以查看更多类别信息。
通过「页面右上角的三个点点点 --- 更多工具 --- 任务管理器」即可打开相关面板，
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/59474079b05ddd343d731f4d61567626/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c26247a328b614fbab9623a435055fd3/" rel="bookmark">
			SpringMVC 404&amp;&amp;500问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（1）404问题 问题如图：
404原因分析： 通过检查xml文件和controller层之后，我判断这个问题在于xml文件未能正确找到并执行IndexController.java文件 。
在查询过相关的文章后，我得出以下可能存在的原因：
（1）&lt;url-pattern&gt;路径配置不对导致无法找到正确的文件
（2）缺乏依赖的jar包——“SimpleUrlHandlerMapping”或“DispatcherServlet”
通过检查上面的问题，我在java build path 中发现web app Libraries与lib文件相比少了一个jar包，重新导入之后解决了问题。
（2）500问题 500原因分析： 通过上面给出的提示，我判断可能是因为在springmvc-servlet.xml文件中bean设置出现错误或者是IndexController.java文件出现问题导致控制器初始化失败
通过查询相关资料和chatgpt，我得到以下可能的原因：
1.控制器中出错
假设你在Controller方法里面写了一段有语法错误的代码或者对 request 或 response 参数操作不当等，都可能会导致抛出异常，最终返回 500 错误状态码。要解决这个问题，建议排查一下 Controller 方法中的代码是否存在异常。
2.配置文件出错
如果 Spring MVC 的配置文件出现语法、拼写等错误，也有可能导致控制器初始化失败。检查一下配置中是否存在自定义 Bean 或者资源不存在等异常，更改后重新启动应用即可。
3.依赖问题
如果 Spring MVC 相关依赖引入不正确，可能会导致控制器初始化失败。确认依赖版本与使用的 Spring 版本是否匹配，并检查是否缺少必须的依赖。可以通过 Maven 等方式来管理项目依赖。
4.请求量过大（排除在外）
最后解决的方法。。。。。。睡了一觉，重新打开eclipse就好了，期间没有对电脑进行重启。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5bfde4f415d45dca623f5079e15aa33e/" rel="bookmark">
			Torch使两个Dataloader保持一致的打乱顺序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 背景 PYG中，数据类无法自定义，有时候要汇聚多组图数据，此时要求Dateloader的打乱顺序一致使得他们输出相同。
方法 手动对数据进行打乱。
代码 from torch_geometric.loader import DataLoader import random seed=random.randint(0,99999999) print(seed) torch.manual_seed(seed) train_data=train_data.shuffle() torch.manual_seed(seed) seq_train_data=seq_train_data.shuffle() # 创建dataloader1对象 dataloader1 = DataLoader(train_data, batch_size=32, shuffle=False) # 使用相同的随机种子创建dataloader2对象 dataloader2 = DataLoader(seq_train_data,batch_size=32, shuffle=False) for data in zip(dataloader1,dataloader2): print(data[0].y) print(data[1].y) break 结果 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2a5f80999bbc80fb4db7bcc1c3c8e44/" rel="bookmark">
			Vue 3.3“浪客剑心”发布
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击“开发者技术前线”，选择“星标”
让一部分开发者看到未来
| 来自：OSC开源社区（ID：oschina2013)
Vue 3.3 已正式发布，代号 "Rurouni Kenshin"（浪客剑心）。
公告写道，此版本专注于改进开发者使用体验 —— 特别是 SFC&lt;script setup&gt; 与 TypeScript 的结合使用。一同发布的还有 Vue Language Tools 1.6（旧 Volar），解决了 Vue 与 TypeScript 一起使用时许多长期存在的痛点。
升级到 3.3 时，建议同时更新以下依赖项：
volar / vue-tsc@^1.6.4
vite@^4.3.5
@vitejs/plugin-vue@^4.2.0
vue-loader@^17.1.0 (if using webpack or vue-cli)
改进开发者使用 &lt;script setup&gt; + TypeScript 的体验
面向宏支持类型导入和复杂类型
&lt;script setup lang="ts"&gt; import type { Props } from './foo' // imported + intersection type defineProps&lt;Props &amp; { extraProp?: string }&gt;() &lt;/script&gt; 引入泛型组件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2a5f80999bbc80fb4db7bcc1c3c8e44/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/140/">«</a>
	<span class="pagination__item pagination__item--current">141/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/142/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>