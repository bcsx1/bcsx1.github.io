<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58ce73f9eb93526d695349ef6bfd7f9e/" rel="bookmark">
			ceph参数配置--正式使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ceph参数配置 ceph中的可配置参数（日志级别，缓存设置等等）都定义在legacy_config_opts.h中，可以通过ceph daemon命令来查看或者修改这些参数配置。参数配置方式有两种：永久和临时。永久方式，就是在配置文件(如ceph.conf)中添加该参数的配置，重启进程后，参数就生效了。临时方式，就是通过ceph daemon命令设置内存中的参数。
# xxx为 admin_socket = $rundir/$cluster-$id.asok (/run/ceph/ceph-osd.0.asok) ceph daemon xxx config show 例如："log_file"参数可以配置日志文件的路径
Option("log_file", Option::TYPE_STR, Option::LEVEL_BASIC) .set_default("") .set_daemon_default("/var/log/ceph/$cluster-$name.log") .set_description("path to log file") .add_see_also({"log_to_stderr", "err_to_stderr", "log_to_syslog", "err_to_syslog"}), /* 所有选项的头文件包含在src/common/options/legacy_config_opts.h中 xx.cc xx.h文件由对应的xx.yaml配置文件使用src/common/options/y2c.py脚本自动生成 */ #include "global_legacy_options.h" #include "cephfs-mirror_legacy_options.h" #include "mds_legacy_options.h" #include "mds-client_legacy_options.h" #include "mgr_legacy_options.h" #include "mon_legacy_options.h" #include "osd_legacy_options.h" #include "rbd_legacy_options.h" #include "rbd-mirror_legacy_options.h" #include "immutable-object-cache_legacy_options.h" #include "rgw_legacy_options.h" .h文件.cc文件.yamlglobal_legacy_options.hglobal_options.ccglobal.yamlcephfs-mirror_legacy_options.hcephfs-mirror_options.cccephfs-mirror.yamlmds_legacy_options.hmds_options.ccmds.yamlmds-client_legacy_options.hmds-client_options.ccmds-client.yamlmgr_legacy_options.hmgr_options.ccmgr.yamlmon_legacy_options.hmon_options.ccmon.yamlosd_legacy_options.hosd_options.ccosd.yamlrbd_legacy_options.hrbd_options.ccrbd.yamlrbd-mirror_legacy_options.h.hrbd-mirror_options.ccrbd-mirror.yamlimmutable-object-cache_legacy_options.himmutable-object-cache_options.ccimmutable-object-cache.yamlrgw_legacy_options.hrgw_options.ccrgw.yaml 参数是以Option结构体存在(src/common/options.h)，Option结构体的定义如下
struct Option { enum type_t { // 参数值的类型 TYPE_UINT = 0, TYPE_INT = 1, TYPE_STR = 2, TYPE_FLOAT = 3, TYPE_BOOL = 4, TYPE_ADDR = 5, TYPE_ADDRVEC = 6, TYPE_UUID = 7, TYPE_SIZE = 8, TYPE_SECS = 9, TYPE_MILLISECS = 10, }; enum level_t { LEVEL_BASIC = 0, LEVEL_ADVANCED = 1, LEVEL_DEV = 2, LEVEL_UNKNOWN = 3, }; using value_t = std::variant&lt; std::monostate, std::string, uint64_t, int64_t, double, bool, entity_addr_t, entity_addrvec_t, std::chrono::seconds, std::chrono::milliseconds, size_t, uuid_d&gt;; const std::string name; // 参数名 const type_t type; // 参数类型 const level_t level; // 参数级别 std::string desc; // 该参数的含义 std::string long_desc; value_t value; // 参数值 value_t daemon_value; // 有daemon的参数值 std::vector&lt;const char*&gt; services; // services即服务类型，比如"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/58ce73f9eb93526d695349ef6bfd7f9e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3fec99d261c8a3dfbfdc5a00090152c/" rel="bookmark">
			C# 创建Excel并写入内容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在许多应用程序中，需要将数据导出为Excel表格，以便用户可以轻松地查看和分析数据。在本文中，我们将讨论如何使用C#创建Excel表格，并将数据写入该表格。
添加引用 在C#中创建Excel表格，需要使用Microsoft.Office.Interop.Excel命名空间中的类。打开Visual Studio，选择项目，然后右键单击“引用”并选择“添加引用”。在弹出的窗口中，选择“COM”选项卡，然后找到“Microsoft Excel xx.x 对象库”（xx.x是Excel的版本号），并将其选中。然后单击“确定”按钮，即可添加Excel引用。 创建Excel实例 使用以下代码在C#中创建Excel实例。其中，xlApp是Excel的应用程序对象，通过它可以打开、编辑和保存Excel文件。 using Microsoft.Office.Interop.Excel; public static void CreateExcel() { Application xlApp = new Application(); // 隐藏Excel窗口 xlApp.Visible = false; // 禁用警告消息 xlApp.DisplayAlerts = false; Workbook xlWorkBook = xlApp.Workbooks.Add(); Worksheet xlWorkSheet = (Worksheet)xlWorkBook.Worksheets.Item[1]; // 设置Excel表格名称 xlWorkSheet.Name = "MySheet"; // 写入数据 xlWorkSheet.Cells[1, 1] = "Name"; xlWorkSheet.Cells[1, 2] = "Age"; xlWorkSheet.Cells[2, 1] = "John"; xlWorkSheet.Cells[2, 2] = "25"; xlWorkSheet.Cells[3, 1] = "Lisa"; xlWorkSheet.Cells[3, 2] = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c3fec99d261c8a3dfbfdc5a00090152c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0f67e04ad75bd83df96aae7d3e3a06e/" rel="bookmark">
			【unity实践记录】动画层的顺序和混合模式Override/Additive
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		手册上关于层顺序的介绍基本没有，只是一个不明所以的Q&amp;A一带而过：
层的排序是否重要？
是的。层的优先级是按顺序从上到下的。层设置为 override 将始终覆盖先前的层（如果层有遮罩，则基于其遮罩）。
基础层的权重值是否应始终设置为 1？或者在使用其他层时权重是否应为 0？
基础层权重始终为 1，覆盖层将完全覆盖基础层。
（原文：）
Does the ordering of the layers matter?
Yes. Layers are evaluated from top to bottom in order. Layers set to override will always override the previous layers (based on their mask, if they have a mask).
Should the weight value of the base layer always be set to one or should the weight be zero when using another layer?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b0f67e04ad75bd83df96aae7d3e3a06e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01f2d8db539347df825d276171566f23/" rel="bookmark">
			大数据编程实验二：熟悉常用的HDFS操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实验目的
1、理解HDFS在Hadoop体系结构中的角色
2、熟悉使用HDFS操作常用的Shell命令
3、熟悉HDFS操作常用的Java API
实验平台
1、操作系统：Windows
2、Hadoop版本：3.1.3
3、JDK版本：1.8
4、Java IDE：IDEA
实验步骤 前期：一定要先启动hadoop
cd /usr/local/hadoop ./sbin/start-dfs.sh 1、编程实现以下功能，并利用Hadoop提供的Shell命令完成相同任务
1）向 HDFS 中上传任意文本文件，如果指定的文件在 HDFS 中已经存在，则由用户来指定是追加到原有文件末尾还是覆盖原有的文件；
Shell 命令
检查文件是否存在，可以使用如下命令:
cd /usr/local/hadoop ./bin/hdfs dfs -test -e text.txt 执行完上述命令不会输出结果，需要继续输入命令查看结果：
echo $? 如果结果显示文件已经存在，则用户可以选择追加到原来文件末尾或者覆盖原来文件，
具体命令如下：
cd /usr/local/hadoop ./bin/hdfs dfs -appendToFile local.txt text.txt #追加到原文件末尾 ./bin/hdfs dfs -copyFromLocal -f local.txt text.txt #覆盖原来文件，第一种命令形式 ./bin/hdfs dfs -cp -f file:///home/hadoop/local.txt text.txt#覆盖原来文件，第二种命令形式 实际上，也可以不用上述方法，而是采用如下命令来实现：(注意要加上./bin/)
if $(./bin/hdfs dfs -test -e text.txt); then $(./bin/hdfs dfs -appendToFile local.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/01f2d8db539347df825d276171566f23/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/795aaa848b09a85ad64da601c5d67b3b/" rel="bookmark">
			Antd DatePicker 只允许选择当前时间之后的时间 包括时分秒
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求：选择当前时间之后的时间
1.隐藏“此刻”按钮
2.只允许选择当前时间5分钟之后的时间 import moment from 'moment'; let disabledDate = (current:any) =&gt; { return current &amp;&amp; current &lt; moment().subtract(1, 'days').endOf('day'); }; let range = (start:any, end:any) =&gt; { const result = []; for (let i = start; i &lt; end; i++) { result.push(i); } return result; }, let disabledDateTime = (current:any)=&gt;{ if(current){ let today = moment().date(); if(today == current.date()){ let minute = Number(moment().minutes()) let hour = Number(moment().hour()); let finalHour:number,finalMinute:number; if(current.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/795aaa848b09a85ad64da601c5d67b3b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/404833ed2ae00ecc676a5a29b1c57bb8/" rel="bookmark">
			setTimeout 模拟setInterval
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;template&gt; &lt;div&gt; {{nowTime}} &lt;button @click="getNowTime"&gt;开始计时&lt;/button&gt; &lt;button @click="stopTiming"&gt;停止计时&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script setup&gt; import { ref } from 'vue' const nowTime = ref("00:00:00") let timer: any let timerStop = false const getNowTime =()=&gt;{ if (timer) { clearTimeout(timer) timer = null } if (timerStop) { return } const now = new Date(); const hour=now.getHours()&lt;10?"0" + now.getHours():now.getHours(); const minu=now.getMinutes()&lt;10?"0" + now.getMinutes():now.getMinutes(); const sec=now.getSeconds()&lt;10?"0" + now.getSeconds():now.getSeconds() nowTime.value = hour+":"+ minu +":"+sec; timer = setTimeout(getNowTime,1000) } const stopTiming = ()=&gt;{ f (timer) { clearTimeout(timer) timer = null } timerStop = true } &lt;/script&gt; 为什么要用timeout代替interval，这篇文章写的还不错，可以看下
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/404833ed2ae00ecc676a5a29b1c57bb8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62c34e6dff83c26e16d9a19160da5e4d/" rel="bookmark">
			使用kali时可能出现的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何更新源 1、备份原先镜像源
sudo cp /etc/apt/sources.list /etc/apt/sources.list.backup 2、输入“sudo vim /etc/apt/sources.list”命令进入源地址文件
3、按“i”进入插入模式
4、选择一下任何一个源，复制
#aliyun 阿里云 deb http://mirrors.aliyun.com/kali kali-rolling main non-free contrib deb-src http://mirrors.aliyun.com/kali kali-rolling main non-free contrib # ustc 中科大 deb http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib deb-src http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib # tsinghua 清华 deb http://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free deb-src http://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free #浙大源 deb http://mirrors.zju.edu.cn/kali kali-rolling main contrib non-free deb-src http://mirrors.zju.edu.cn/kali kali-rolling main contrib non-free 更新前把系统自带的更新源注释或者删除掉
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/62c34e6dff83c26e16d9a19160da5e4d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/634e0d3bc71ae7a730d073f44f742ef4/" rel="bookmark">
			Require statement not part of import statement.(@typescript-eslint/no-var-requires)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、出现Require statement not part of import statement.(@typescript-eslint/no-var-requires)
二、error An unexpected error occurred: "https://github.com/eligrey/FileSaver.js.git/info/refs?service=git-upload-pack: connect ETIMEDOUT 20.205.243.166:443
三、Vue3 忽略 ts (TypeScript)的无故报错
四、Recommendation: math.div(1, 5) More info and automated migrator: https://sass-lang.com/d/slash-div
五、表单初始化数据提示 Property "xxx" was accessed during render but is not defined on instance. 六、遍历提示错误 'v-model' directives cannot update the iteration variable itself
七、 npm报错：npm ERR! cb.apply is not a function
八、cnpm:无法加载文件，因此在此系统上禁止运行脚本。对注册表项的访问被拒绝。要更改默认作用域的执行策略，请使用“以管理员身份运行”选项启动window powershell。要更改当前用户的执行策略 九、asset size limit: The following asset(s) exceed the recommended size limit (244 KiB).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/634e0d3bc71ae7a730d073f44f742ef4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d6cdfad4fae5319c1ac4c0756fd2607/" rel="bookmark">
			【数据结构和算法】时间复杂度和空间复杂度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、前言
二、时间复杂度
2.1时间复杂度表示形式
2.1.1规则：
3.1如何计算时间复杂度
3.1.1线性阶
3.1.2平方阶
3.1.3对数阶
常见的时间复杂度排序:
三、空间复杂度
3.1Java的基本类型内存占用
一、前言 数据结构和算法是程序的灵魂，这是某位程序员大佬所言，学习了这门，我们便可以在
编程之路越走越远。时间复杂度一般是我们所关心的。
二、时间复杂度 时间复杂度简单的说就是一个程序运行所消耗的时间，叫做时间复杂度，我们无法目测
一个程序具体的时间复杂度，但是我们可以估计大概的时间复杂度。
一段好的代码的就根据算法的时间复杂度，即使在大量数据下也能保持高效的运行速
率，这也是我们学习算法的必要性。
2.1时间复杂度表示形式 一般用O（）来表示算法的时间复杂度，我们叫做大O记法。
2.1.1规则： ①用常数1取代运行时间中的所有的加法常数。比如，一个程序中有十条输出语句
我们不会记成O(10),而是用O(1)来表示。
②如果最高阶项不是1，那么去掉最高阶阶项,因为我们认为数字在后期影响不大。
如O(8n),则时间复杂度应该为O(n)。
③只保留最高阶项，如O(3n^2+6n+2),则时间复杂度为O(n^2)
3.1如何计算时间复杂度 计算时间复杂度主要看执行的次数和输入的关系
3.1.1线性阶 顾名思义，就是输入和输出成正比。
for(int i=0;i&lt;n;i++){ sum+=i; } 当n=1，执行一次，当n=100，执行100次 ，所以当为n时，执行n次，所以时间复杂度为
O(n)
3.1.2平方阶 for(int i=0;i&lt;n;i++){ for(int j=0;j&lt;n;j++){ } } 外层for循环和内层for循环都是时间复杂度时n外层循环一次，内层循环n次，所以时间复杂度是
O(n^2)。
另一种：
for(int i=0;i&lt;n;i++){ for(int j=0;j&lt;i;j++){ } } 外层复杂度是n,内层是1+2+...+n-1+n,所以是n(1+n)/2,由大O法得时间复杂度是O(n^2).
3.1.3对数阶 int i=1;n=100; while(i&lt;n){ i=i*2; } 满足条件时，程序运行了，先设X个2相乘后大于n，则2^X=n，解得X=log2(n),所以时间
复杂度时O(log2(n))，log以2为底，n为真数。
常见的时间复杂度排序: O(1)&lt; O(log2(n))&lt; O(n)&lt; O(nlog2(n)&lt; O(n^2)&lt; O(n^3)&lt; O(2^n)&lt; O(n!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d6cdfad4fae5319c1ac4c0756fd2607/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a525e634099a54d807f0f6d33df4afd7/" rel="bookmark">
			Ubuntu 20.04安装GTSAM库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在Ubuntu 20.04上安装GTSAM的步骤：
1、打开终端，更新软件包列表：
sudo apt-get update 2、安装必要的依赖项：
sudo apt-get install cmake libboost-all-dev libtbb-dev libeigen3-dev 3、下载GTSAM源代码：
git clone https://github.com/borglab/gtsam.git 4、进入gtsam目录，创建build目录：
cd gtsam mkdir build cd build 5、使用CMake生成Makefile：
cmake .. 6、编译GTSAM：
make -j4 7、安装GTSAM：
sudo make install 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/217d3f3f527e39596faf9e237941f36b/" rel="bookmark">
			Vue 数字相加、相减精度丢失处理。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法 一：
// num 是数值，decimals是精度几位 function round(num, decimals) { const factor = Math.pow(10, decimals); return Math.round(num * factor) / factor; } const a = 0.1; const b = 0.2; console.log(round(a + b, 1)); // 0.3 方法 二：
//可以传你要的小数几位 let num = 2 const a = 0.1; const b = 0.2; console.log((a+b).toFixed(num)); // 0.30 方法 三：扩大运算范围：将浮点数转化为整数，相乘或相加后再除回去，可以避免小数位精度的影响。
let num1 = 0.1; let num2 = 0.2; let sum = (num1 * 10 + num2 * 10) / 10; console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/217d3f3f527e39596faf9e237941f36b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91febd6c8b6afbb64eaa4ca4585057a6/" rel="bookmark">
			【LinuxShell】Shell编程之条件语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 引言一、条件测试1.test命令2.文件测试3.整数值比较4.逻辑测试5.字符串比较 二、if语句if单分支语句if双分支语句if多分支语句嵌套if语句case分支语句 三、实验 引言 在简单的Shell脚本程序中，各语句将按先后顺序依次执行，从而实现批处理的自动化过程。然而，单一的顺序结构使得脚本过于机械化，不够智能，难以处理更加灵活的系统任务。
本文主要讲了如何进行条件测试操作，并通过正确使用if语句，使用Shell脚本具有一定的“判断”能力，以根据不同条件来完成不同的管理任务。
一、条件测试 1.test命令 要使 Shell 脚本程序具备一定的“智能”，面临的第一个问题就是如何区分不同的情况以确定执行何种操作。例如，当磁盘使用率超过 95%时，发送告警信息；当备份目录不存在时，能够自动创建；当源码编译程序时，若配置失败则不再继续安装等。
Shell 环境根据命令执行后的返回状态值（$?）来判断是否执行成功，当返回值为 0 时表示成功，否则（非 0 值）表示失败或异常。使用专门的测试工具——test 命令，可以对特定条件进行测试，并根据返回值来判断条件是否成立（返回值为 0 表示条件成立）。
使用 test 测试命令时，包括以下两种形式:
格式1：test 条件表达式 格式2：[ 条件表达式 ] 这两种方式的作用完全相同，但通常后一种形式更为常用，也更贴近编程习惯。需要注意的是，[]中的条件表达式两边都需要有空格。
2.文件测试 文件测试指的是根据给定的路径名称，判断对应的是文件还是目录，或者判断文件是否可读、可写、可执行等。文件测试的常见操作选项如下，使用时将测试对象放在操作选项之后即可。
通常用以下格式进行文件测试：
[ 操作符 文件或目录 ] 注意两端要有空格。
常用的测试操作符
操作符说明-d测试是否为目录(Directory)-e测试目录或文件是否存在(Exist)-f测试是否为文件(File)-r测试当前用户是否有权限读取(Read)-w测试当前用户是否有权限写入(Write)-x测试当前用户是否有权限执行(eXcute) 具体可以用演示如下：
[root@host ~]# ll /etc/passwd -rw-r--r--. 1 root root 2304 3月 22 19:52 /etc/passwd [root@host ~]# test -d /etc/passwd	#测试是否为目录 [root@host ~]# echo $?	1 [root@host ~]# test -e /etc/passwd	#测试目录或文件是否存在 [root@host ~]# echo $?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91febd6c8b6afbb64eaa4ca4585057a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3381335fb5d29d83a085b21828306bc8/" rel="bookmark">
			BUUCTF MISC 61 - 80
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		61、heikediguo 打开题目给的TXT文件发现很像文件的十六进制，导入010查看一下，发现是一个rar文件
将文件另存为rar得到一个加密的压缩包，无任何提示，先尝试四位纯数字爆破
得到一张无法打开的图片，放入010查看
校验发现不是PNG文件，既然文件头有问题，尝试看一下文件尾FF D9
明显是JPG文件尾（PNG文件尾：AE 42 60 82），于是修改文件头为FF D8 FF
62、你能看懂音符吗 题目给出的压缩包无法打开，使用010查看文件
发现文件头格式顺序错误，RAR的文件头为52 61 72 21 1A 07 00（文件尾一般为C4 3D 7B 00 40 07 00）
正常打开后得到一个Word文档，打开后没有有效信息
尝试用formost提取，得到很多文件
在document.xml文件中发现一串奇怪的音符
使用音符在线解密即可
♭♯♪‖¶♬♭♭♪♭‖‖♭♭♬‖♫♪‖♩♬‖♬♬♭♭♫‖♩♫‖♬♪♭♭♭‖¶∮‖‖‖‖♩♬‖♬♪‖♩♫♭♭♭♭♭§‖♩♩♭♭♫♭♭♭‖♬♭‖¶§♭♭♯‖♫∮‖♬¶‖¶∮‖♬♫‖♫♬‖♫♫§=
63、caesar 题目提示凯撒加密，尝试用大佬的穷举脚本跑一下
def change(c,i): num=ord(c) if(num&gt;=33 and num&lt;=126): num=33+(num+i-33)%(94)#126-33=93 return chr(num) def kaisa_jiAmi(string,i): string_new='' for s in string: string_new+=change(s,i) print(string_new) return string_new #本题有种暴力解密感觉 def kaisa_jiEmi(string): for i in range(0,94): print('第'+str(i+1)+'种可能:',end=' ') #区别在于 string 是该对象原本就是字符串类型, 而 str()则是将该对象转换成字符串类型。 kaisa_jiAmi(string,i) #你要知道input输入的数据类型都是string def main(): print('请输入操作，注意不是平常26种:') choice=input('1:恺撒加密,2:凯撒穷举解密.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3381335fb5d29d83a085b21828306bc8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86e4a4202995985221e3d38c01bb467b/" rel="bookmark">
			渗透测试之流程简述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 确定目标 渗透测试分为 白盒测试和 黑盒测试
白盒测试就是在知道目标网站源码和其他一些信息的情况下对其进行渗透，有点类似于代码分析黑盒测试就是只告诉我们这个网站的url，其他什么都不告诉，然后让你去渗透，模拟黑客对网站的渗透 黑盒测试，我们只知道该网站的URL
一般来说，渗透测试的基本流程如下：
确定目标信息收集漏洞探测漏洞利用getshell内网转发内网渗透痕迹清除撰写渗透测试报告 二 信息收集 1.主机扫描
Nmap：一款功能强大的网络扫描和主机检测工具，可以用于收集信息、枚举、漏洞探测和安全扫描。
Wireshark：一款抓包和分析网络流量的工具，可以用于监控和调试网络通信。
Goby：一款新型的漏洞扫描平台，可以快速发现并利用各种漏洞，还可以联动其他工具如Xray和MSF。
2.端口扫描
22——&gt;ssh弱口令
80——&gt;HTTP服务
873——&gt;rsync 未授权访问漏洞
3306——&gt;mysql弱口令
6379——&gt;redis未授权访问漏洞
端口扫描工具有nmap、nikto
在kali中，你可以使用一些命令来查看某个端口是否开放，例如：
netstat -lnt：查看当前kali开放的端口。
lsof -i：直接将开放的端口输出。
nmap：扫描目标主机上开放的端口
3.网站敏感目录和文件
探测目标网站后台目录的工具有： wwwscan 、御剑 、dirsearch
扫描网站目录结构，看看是否可以遍历目录，或者敏感文件泄漏
后台目录：弱口令，万能密码，爆破安装包：获取数据库信息，甚至是网站源码上传目录：截断、上传图片马等mysql管理接口：弱口令、爆破，万能密码，然后脱裤，甚至是拿到shell安装页面 ：可以二次安装进而绕过phpinfo：会把你配置的各种信息暴露出来编辑器：fck、ke、等iis短文件利用：条件比较苛刻 windows、apache等 robots.txt 文件
指定网站中不想被robot访问的目录。这样，我们网站的部分或全部内容就可以不被搜索引擎收录了，或者让搜索引擎只收录指定的内容。
4.旁站和C段扫描
旁站和C段扫描是两种信息收集的方法，用于寻找目标网站或服务器的其他可能存在漏洞的网站或服务器。
旁站指的是和目标网站在同一台服务器上的其他网站1。如果目标网站没有漏洞，可以先攻击旁站，然后提权拿到服务器权限，再攻击目标网站2。常用的旁站查询工具有御剑、bing.com等2。
C段指的是和目标服务器IP处在同一个C段的其他服务器。例如，如果目标服务器IP是192.168.1.100，那么它所在的C段就是192.168.1.*1。找到C段内的主机，可以利用它们作为跳板，攻击目标主机。常用的C段扫描工具有Nmap、Masscan等。
5.网站漏洞扫描
网站漏洞扫描是一种检测网站是否存在安全漏洞的方法，可以通过发送Payload进行漏洞探测，或者通过模拟黑客的攻击手法进行攻击性的安全漏洞扫描。常用的网站漏洞扫描工具有Acunetix Web Vulnerability Scanner（AWVS）、Nikto、Nmap等。
6.网站指纹识别
网站指纹识别是一种通过观察流量跟踪来识别网络浏览客户端的行为（特别是她正在访问的网页）的过程。网站指纹识别可以通过以下几种方式进行：特定文件的MD5、正常页面或错误网页中包含的关键字、请求头信息的关键字匹配、部分URL中包含的关键字、开发语言的识别等。常用的网站指纹识别工具有ZoomEye、WhatWeb等。
7.公司敏感信息网上搜集
8.域名信息的收集
域名信息收集是指通过各种方法获取目标网站或主机的域名、子域名、IP地址等信息，以便进行进一步的渗透测试。域名信息收集的方法有以下几种：
爆破：使用工具如dnsmap对目标域名进行字典攻击，尝试发现子域名。
搜索引擎：使用工具如theharvester或者直接在搜索引擎中输入相关关键词，利用搜索引擎的索引功能查找子域名。
域传送：使用工具如fierce或者dig对目标域名进行DNS区域传送请求，如果目标服务器配置不当，可能会泄露所有的子域名。
Whois查询：使用网站或者工具如whois对目标域名进行Whois查询，可以获取到注册人、注册商、注册时间等信息。
判断域名对应的IP：首先，我们要判断该域名是否存在CDN的情况，我们可以去在线CDN查询网站： 多个地点Ping服务器,网站测速 - 站长工具 。如果查询出的ip数量大于一个的话，则说明该ip地址不是真实的服务器地址。以我的经验来看，如果是2个或者3个，并且这几个地址是同一地区的不同运营商的话，则很有可能这几个地址是服务器的出口地址，该服务器在内网中，通过不同运营商NAT映射供互联网访问，同时采用几个不同的运营商可以负载均衡和热备份。如果是多个ip地址，并且这些ip地址分布在不同地区的话，则基本上可以断定就是采用了CDN了。
三 漏洞探测 SQL注入XSS跨站脚本CSRF跨站请求伪造XXE漏洞SSRF服务端请求伪造漏洞文件包含漏洞文件上传漏洞文件解析漏洞远程代码执行漏洞CORS跨域资源共享漏洞越权访问漏洞目录浏览漏洞和任意文件读取/下载漏洞struts2漏洞JAVA反序列化漏洞 网站漏洞扫描工具
AWVSAppScanOwasp-ZapNessus 四 漏洞利用 不同的漏洞有不同的利用工具，很多时候，通过一个漏洞我们很难拿到网站的webshell，我们往往需要结合几个漏洞来拿webshell。常用的漏洞利用工具如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/86e4a4202995985221e3d38c01bb467b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab445417e8bea29b575f005309e0cfda/" rel="bookmark">
			此主机支持 AMD-V，但 AMD-V 处于禁用状态
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		此主机支持 AMD-V，但 AMD-V 处于禁用状态问题解决 文章目录 此主机支持 AMD-V，但 AMD-V 处于禁用状态问题解决1、问题原因2、解决办法 1、问题原因 我win 10 系统电脑安装VMware虚拟机后，在启动虚拟机时提示以下这个错误：
此主机支持 AMD-V，但 AMD-V 处于禁用状态。
此主机支持 AMD-V，但 AMD-V 处于禁用状态。
如果已在 BIOS/固件设置中禁用 AMD-V，或主机自更改此设置后从未重新启动，则 AMD-V 可能被禁用。
(1) 确认 BIOS/固件设置中启用了 AMD-V。
(2) 如果此 BIOS/固件设置已更改，请重新启动主机。
(3) 如果您在安装 VMware Workstation 之后从未重新启动主机，请重新启动。
(4) 将主机的 BIOS/固件更新至最新版本。
此主机不支持“AMD RVI”硬件辅助的 MMU 虚拟化。
模块“MonitorMode”启动失败。 未能启动虚拟机。
这个提示表示你的电脑是AMD平台的，并且支持AMD-V虚拟化技术，并没有把它使能，而不是电脑出现的故障导致的，不用过于担心，需要在主板中找到相应设置，将SVM功能开启即可。
2、解决办法 解决办法如下：
第一步：重启电脑，在进入系统之前不停点击快捷键进入BIOS(注意：不同型号的电脑进入的快捷方式是不一样的，需要根据自己电脑型号不停点击即可，不清楚的话可以去百度搜索下具体是哪个快捷键)。
进入BIOS后可以看到这个界面，默认是高级的模式。
第二步：此时需要切换为简易模式，点击选择即可，如果不喜欢英文显示，可以选择为中文的显示。
第三步：选择OC选项下的 “CPU 特征”。
进入后出现以下界面，可以看到 SVM Mode 选项后面为【禁止】状态。
点击 SVM Mode，进入后选择键盘上下键将状态设置成【允许】后回车即可。
第四步：设置完成后，点击SETTINGS选项，然后点击右边的 “保存并退出”。
然后进入以下界面，再点击 “储存变更并重新启动”。
最后，会提示你在整个过程中操作变更的选项待确认界面，这个默认完成即可。
到此，设置就完成啦，等待电脑重启完成后就可以去运行打开虚拟机看看是否设置成功。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab445417e8bea29b575f005309e0cfda/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d595ce84e532cf854543854bcfb294be/" rel="bookmark">
			【深度学习】实战 | 一个基于深度学习的自动化阅卷机器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文授权自知乎作者南慕伦，CMU计算机视觉方向，描述了一个自动化阅卷机器，非常有借鉴意义。文末点击阅读原文查看。
背景
我的爸爸妈妈都是一个西南小城的大学老师。自从有记忆的时候开始，每次到他们期末考试的时候，他们就要花上好几天的时间改卷。最近几年，步入中年的他们开始老花了，改卷越来越费力，特别是我妈妈本身就高度近视，所以有时候得让学生帮忙。但是每张试卷四十到六十道选择题，我爸上的还是公共课，学生更多。
今年过年的时候，我刚毕业还没入职，赋闲在家，就请了两个研究生同学跑来家里玩，然后他们也“顺便”改了一下选择题。整个过程非常枯燥，得吃好几碗螺丝粉才能补回来。然后我忽然意识到，我们三个可能是家乡历史上出现过计算机水平最高的三颗大脑，还都是CMU毕业搞智能信息系统的，竟然还要做这种本应该交给计算机干的活儿，于是我自然而然想到了把它自动化。
痛点 答题卡读卡机是很早很早就有的东西了，但是主要有几点原因爸爸妈妈他们学校一直没有用上：
设备太贵
淘宝答题卡读卡器5000元起。加上反腐之后，审计收紧，这种价格的设备需要统一通过政府采购，价格更加高昂，如果要购买这种设备手续非常复杂。
需要专用答题卡
这进一步提升了使用成本，一般一张答题卡的采购价是一毛钱。
使用复杂
爸爸妈妈虽然电脑已经用得很溜了，但是现在已有的软件的操作界面还是让老一辈教师望而却步——所以有的院校得专门雇人来操作答题卡读卡器。
初期调研与设计 刚好我本科接触过图像和视频处理技术，在CMU的时候某个课程项目是识别手写公式转换成Latex，个人有一定的技术积累。刚好签证例行被行政审查，暂时没法入职，过年期间就开始设计这么一个系统。针对上面三点，这个系统需要有以下几个特性，我一并做了调研：
设备尽可能简单易用
之前，在我印象中扫描还是手动模式，需要扫完一张，再放下一张……
直到我到CMU才第一次见识了自动送纸（Auto Document Feeder）扫描仪。
同时我在网上看了一下价格，自动进纸扫描仪最便宜的新品是国产的 清华紫光-F20S，只要1150元包邮，这个价格就算我自己掏腰包也可以承受，而且50张的纸匣已经基本足够一般教学的使用了。
普通打印机就能打印的黑白答题卡
常见的答题卡的框线一般都做成红、绿、蓝三种颜色：
彩色硬纸答题卡 对应计算机中RGB的颜色表示方式，这样在做图像处理的时候，能够用阈值法轻松把框线等非答案的内容筛掉筛掉，只剩下学生填涂的结果。这样，再根据四周的定位块来确定学生的填涂内容。
如果变成黑白的，就需要把学生填涂的内容答案从背景中分离出来，这其实增加了一点难度，但是考虑到之前在CMU的课程设计里做过类似的事情，技术上是可以解决的。
操作步骤尽可能简单
所以我需要尽可能简化使用流程，让使用者少做选择，尽可能只需要三步：选择文件——处理——得到结果
除此之外，我还想整个东西看起来厉害一点。
前面说道我在CMU做过类似的事情，大概的项目效果是把手写公式转换成Latex公式：
手写公式识别 看上去很酷，但实际上做了如下两个假设之后一点也不难：
字符之间没有粘连
同级的字母基本上都保持在一个水平线上
难点就在有的字符是被分成两部分的，需要合并，比如等号，阶乘号和i,j……可以“启发式”合并，或者实在太难可以假设他们不存在好了……（科学就是这么进步的嘛，基础性、积累性的工作靠大部分普通人解决，挑战性的工作由少部分天才解决）
识别这一块，机器学习的库现在封装得太好用了，基本上搜集到数据丢进去无脑训练就行，更何况这个只是机器学习入门必读教程——识别手写数字的升级版。只需要多采集一些手写数据就好了。
当时我搞了这么一个表格，让爸爸妈妈在上课的时候找学生去填：
手写字符采集卡 然后用了一些框线检测的算法和字符提取的算法搞出了个数据集，训练模型的测试效果也还行。
所以我刚开始做的时候野心比较大，想把填涂式改为手写式的答题卡，因为选项最多只有ABCDEFG和勾叉。
实现 有了之前的想法，我就开始动手实现。
答题卡
第一步肯定是核心功能，识别。第一版的答题卡设计我已经找不到了，但是大致思想跟第二版差不多，学号部分也是手写的：
手写版答题卡 不定向选择题之所以设计成这样，是因为实际使用中让学生写多个选项的时候不连笔这个假设很难成立：一方面自然是学生书写习惯的问题；另一方面，即便学生书写没有问题，也可能会因为纸张、扫描仪的问题意外出现一些笔迹的断裂和符号的粘连。
一旦出现笔迹断裂、字母粘连的情况，就需要加入切割算法——这恰恰是验证码中一个比较难解决的问题——更何况，验证码识别器只需要30%的准确率就能凑合用，达到60%的准确率就基本满足需求了，而评卷时的准确率是以人的识别准确率（95%以上）作为标准的。
同时，就算能够成功切割，往往也会引入一些变形，对识别准确率造成负面影响。
所以，这个表格定下来后，大致处理方法是这样：提取出三块最大的矩形，然后利用框线检测方法去掉框线，提取出表格中的字母，标准化（居中、放大、填补边缘）之后利用上次收集的手写字符数据训练分类器并识别。
然而，这时候我才发现，训练出来的模型能够平均达到97%的准确率，但是具体测试总会出现一些匪夷所思的识别错误，有点类似One pixel attack for fooling deep neural networks（针对深度神经网络的单像素攻击）里面提到的问题。虽然97%的准确率也算可以接受了，因为要是我自己来改看走眼一两个很正常，但是我自己很不满意，毕竟如果有人刚好因为一个识别错误冤枉挂了那是很不好的（明明没过的过了那就不管了）。而且有一部分识别错误发生在学号部分，这会导致登记分数的时候需要额外的人工核对工作，尽管把学号改成填涂式能够解决这个问题。
主要原因我估计是数据集不够（总共加起来有效样本才一千来份），加上采集数据时示例字体是我手写的，可能很多人的写法会受到我的影响，然而真正测试的时候则会用自己的写法。再进行大规模采集的话，估计比较困难，所以我最后放弃了手写识别这个想法。
由于基于框线的定位在实际使用中并不是特别让人满意，我也没想出来什么简单可靠的算法，于是我打算另辟蹊径，寻找更好的定位的方法。普通识别卡是在角上放色块，但是色块本身也比较容易受干扰，调试起来也比较麻烦，还是不方便。
经过反复思考，第三版答题卡设计成了这样：
第三版答题卡 没错，就是这么简单粗暴。角上借鉴了二维码的定位块技术。二维码还有一个名称叫做Quick Response Code，原因就在于这三个定位块，它能够让程序很方便地定位二维码的区域。定位这三个方块的算法有很多，具体实现我参照的是这篇文章：OPENCV: QR CODE DETECTION AND EXTRACTION
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d595ce84e532cf854543854bcfb294be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74540c6ba053319e1e8524593d8a551c/" rel="bookmark">
			网课/网校/知识付费/在线教育系统，100%全功能开源，可免费商用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、开源项目简介 酷瓜云课堂，依托腾讯云基础服务架构，采用C扩展框架Phalcon开发，GPL-2.0开源协议，致力开源网课系统，开源网校系统，开源知识付费系统，开源在线教育系统。
酷瓜云课堂 - 网课系统，网校系统，知识付费系统，在线教育系统。不加密不阉割，100%全功能开源，可免费商用。
二、开源协议 使用GPL-2.0开源协议
三、界面展示 后台界面 登录
后台首页
内容管理
运营管理
财务管理
用户管理
系统管理
实用工具
PC端前台 首页
移动端 首页
四、功能概述 酷瓜云课堂，依托腾讯云基础服务架构，GPL-2.0开源协议，不加密不阉割，100%全功能开源在线教育解决方案。
系统功能 实现了点播、直播、专栏、面授、问答、会员、群组、微聊、积分、秒杀等。
项目特色 开源免费
GPL-2.0开源协议，可以免费用于商业，让您免于版权纠纷。
快速安全
基于高性能C扩展Phalcon框架，响应快速，安全可靠。
多端支持
支持 PC，H5，微信小程序，安卓，苹果等终端。
部署便利
容器化部署，屏蔽了环境差异性，部署简单便利。
适用人群 教育机构
拥有自己的师资力量，需要一套完善的网课系统完成线上教学。
企业单位
传媒出版或有培训需要，尝试线上线下相结合，以达到更加多元化效果。
平台用户
在公共平台积累了一定的粉丝，需要一套自主运营的平台，完成商业转型。
个人用户
拥有传授知识的能力或手握高质量的资源，需要一套自主运营的变现平台。
五、技术选型 项目组件 后台框架：phalcon 3.4.5前端框架：layui 2.6.8， layim 3.9.8（已授权）全文检索：xunsearch 1.4.9即时通讯：workerman 3.5.22基础依赖：php7.3， mysql5.7， redis5.0 六、源码地址 https://download.csdn.net/download/weixin_37576193/87732277
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6eb18e0c5f8c9133198e208243ed32a/" rel="bookmark">
			Vscode学习XML约束和解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 XML(eXtensible Markup Language)可扩展标记语言XML用途XML树结构XML标签书写规则约束：规定xml文档的书写规则解析Jsoup使用定位标签内容 XML(eXtensible Markup Language)可扩展标记语言 XML 被设计用来传输和存储数据。HTML 被设计用来显示数据。
XML用途 XML 应用于 Web 开发的许多方面，常用于简化数据的存储和共享。
XML树结构 &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;!---声明---&gt; &lt;note&gt; &lt;!---根标签---&gt; &lt;to&gt;Tove&lt;/to&gt;	&lt;!---节点---&gt; &lt;from&gt;Jani&lt;/from&gt; &lt;heading&gt;Reminder&lt;/heading&gt; &lt;body&gt;Don't forget me this weekend!&lt;/body&gt; &lt;/note&gt; XML标签书写规则 合法的标签名
名称可以包含字母、数字以及其他的字符
名称不能以数字或者标点符号开始
名称不能以字母 xml（或者 XML、Xml 等等）开始
名称不能包含空格合理使用属性 &lt;shop-cart&gt; &lt;!---属性设置, sn代表编号,category代表类别--&gt; &lt;item sn = "771938" category = "电器"&gt; &lt;name&gt;XX空调&lt;/name&gt; &lt;price&gt;2000.00&lt;/price&gt; &lt;/item&gt; &lt;/shop-cart&gt; 有序的子元素适当的注释和缩进特殊字符与CDATA标签
不要使用&lt;这种标签体本身含有的特殊符号，与程序代码的关键字 &lt;!---无效的XML---&gt; &lt;exam&gt; &lt;question&gt; 1 + 4 &lt; 3是否正确？&lt;/question&gt; &lt;question&gt; 3 + 5 &gt; 8是否正确？&lt;/question&gt; &lt;/exam&gt; 使用实体引用(类似于转义字符)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c6eb18e0c5f8c9133198e208243ed32a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ec0e97159a7d45ea0977e74b88c90b8/" rel="bookmark">
			PIE-SAR软件自动化编译与发布
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.背景 SVN版本控制下多人协调编写代码，会经常性的提交新功能，修改完善已有功能。产品经理、测试人员需定期回归测试，确保禅道Bug已经修复，这就需要经常性地打包软件。为了节省编译时间，也方便产品经理可随时去取最新的版本，参考网上的材料，总结自动化编译的流程。
2.目标 无需人工参与，定期自动编译工程，翻译文件，并将生成的库，配置文件复制到指定共享存储目录。
3.自动化脚本 3.1自动化编译脚本 AutomaticCompile_v73.bat
REM ************************************************************************************************ REM * Script to compile the solutions of Viusal Studio 2015 * REM * Created by: IvanLJF * REM * Created 2023.04.16 * REM ************************************************************************************************ REM STEP 1: set environment variables: REM ************************************************************************************************ SET VS2015Compiler="%VS140COMNTOOLS%..\..\Common7\IDE\devenv.com" REM ************************************************************************************************ REM STEP 2: set compile log REM ************************************************************************************************ SET CompileLogName="%~dp0PIE-SAR_v73_CompileResults.log" ECHO [%DATE% %Time%] Start compile sequence &gt;%CompileLogName% ECHO Used compile configuration is %buildAnyCPU% &gt;&gt;%CompileLogName% REM ************************************************************************************************ REM STEP 3: Start compile REM ************************************************************************************************ SET SolutionFileName="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ec0e97159a7d45ea0977e74b88c90b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/acbce011dc7d179a0ff86efb33a2da01/" rel="bookmark">
			centos8 升级 nginx
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、配置nginx源
创建nginx源配置文件
vim /etc/yum.repos.d/nginx.repo 配置nginx源
[nginx-stable] name=nginx stable repo baseurl=http://nginx.org/packages/centos/$releasever/$basearch/ gpgcheck=1 enabled=1 gpgkey=https://nginx.org/keys/nginx_signing.key module_hotfixes=true [nginx-mainline] name=nginx mainline repo baseurl=http://nginx.org/packages/mainline/centos/$releasever/$basearch/ gpgcheck=1 enabled=0 gpgkey=https://nginx.org/keys/nginx_signing.key module_hotfixes=true 2、重新安装nginx
yum install nginx nginx -v nginx -t 3、如果提示如下错误：
module "/usr/lib64/nginx/modules/ngx_http_image_filter_module.so" 可执行如下命令
yum remove nginx-mod* yum install nginx-moudle-* nginx -t nginx -s releoad nginx -v 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42841197fb351ca7a6eaf12fccc80214/" rel="bookmark">
			Linux 中软件包的安装常用指令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 apt 常用指令yum 常用指令 apt 常用指令 apt 与 apt-get 大部分参数通用，但也会有区别
执行 apt 命令时，需要使用 root 用户的身份执行命令，如果报错 无效的操作，那可以加个sudo 试试
更新软件源 sudo apt update 此命令会更新系统中已有的所有软件信息
安装软件包 sudo apt install &lt;packageName&gt;
升级软件包 sudo apt upgrade 注意此命令无法指定软件包，他会自动检查并升级所有安装的软件包，并更新，如果想更新指定软件包可以使用 install 它会更新并安装指定软件包
卸载软件包 sudo apt remave &lt;packageName&gt; 他会删除指定的软件包及其依赖的其他软件包，但它不会删除配置文件和数据，如果你想把那些都删除了可以使用 sudo apt-get remave --purge &lt;packageName&gt;
删除卸载残留 sudo apt autoremove 这个命令同样不能指定软件包，他会删除系统中缺失依赖的软件包和过时的软件包，同样不会删除配置文件和数据，想删除那些可以使用 sudo apt-get autoremave --purge
删除过时软件包 sudo apt autoclean 这个命令会清理本地软件包缓存中的过时软件包
搜索软件包 sudo apt search &lt;packageName&gt; 会搜索系统仓库中与指定名称相匹配的软件包显示详细信息 sudo apt show &lt;packageName&gt; 会显示指定软件包的详细信息，包括软件包的版本、描述、依赖关系等内容
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/42841197fb351ca7a6eaf12fccc80214/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff1cc3d58a397a889ce875c142fce989/" rel="bookmark">
			k8s 部署rocketmq集群
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、前言
二、构建 rockermq镜像
三、构建rocketmq-dashboard镜像
四、rocketmq部署文件
五、rocketmq-dashboard部署文件
六、调整副本数案例
七、附加信息
八、附录
一、前言 由于网上找到的大部分部署方案以及rocketmq-operator都是不能很灵活的调整副本数，毕竟每个副本对应其唯一的配置的文件，不同的broker实例使用的配置文件都是不一样的，都存在差异，一旦副本变化了，就不能很好的和broker 的配置文件内容一 一对应起来。
在这里创建一个基于k8s部署单master以及多master部署rocketmq集群，并且只需要一个broker配置文件，多个broker实例会自动基于该broker配置文件模板，自动生成不同broker实例的broker配置文件，扩容或者伸缩rocketmq集群 nameserver或者broker副本数的时候不需要理会配置文件，仅仅是调整实例的副本即可。
备注：该方案不适合有slave节点的部署方式。
二、构建 rockermq镜像 rocketmq-namesrv和 rocketmq-broker共用同一个镜像，仅仅是启动命令和启动参数不一样，后期可灵活的通过调整启动命令和启动参数来实现不同的效果（比如通过挂载configMap的方式自定义rocketmq的配置文件，而不需要重建rocketmq的镜像。
## docker build -t test/rocketmq:v1 . --no-cache ### 构建rocketmq 镜像 ## cat Dockerfile FROM docker.io/library/openjdk:8u102-jdk AS JDK LABEL "作者"=fanqietudou mail=123456@qq.com RUN rm -vf /etc/localtime \ &amp;&amp; ln -s /usr/share/zoneinfo/Asia/Shanghai /etc/localtime \ &amp;&amp; echo "Asia/Shanghai" &gt; /etc/timezone \ &amp;&amp; export LANG=zh_CN.UTF-8 RUN curl -k https://mirrors.tuna.tsinghua.edu.cn/apache/rocketmq/4.9.4/rocketmq-all-4.9.4-bin-release.zip \ -o /tmp/rocketmq-all-4.9.4-bin-release.zip \ &amp;&amp; unzip /tmp/rocketmq-all-4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ff1cc3d58a397a889ce875c142fce989/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ffb306abaa1b1fa28ee36027768345b/" rel="bookmark">
			k8s 使用skywalking-agent 部署java应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、前言
二、安装docker
1、卸载旧的docker
2、安装docker
三、安装docker-compose
四、使用docker部署SkyWalking
五、制作javaagent镜像
六、应用里配置skywalking-agent
七、验证
一、前言 使用skywalking对k8s集群的java应用监控，通过docker-compose方式部署skywalking集群，创建skywalking-agent镜像，以sidecar的方式部署到k8s集群的java应用中。 注意： 需要注意的是skywalking和skywalking-agent的版本兼容性，若是skywalking和agent的版本不兼容，会无法通过agent成功获取java指标，不能成功上报给skywalking后端
二、安装docker centos 系统安装docker，参考官网：https://docs.docker.com/engine/install/centos/
1、卸载旧的docker 根据实际情况来决定是要卸载当前已运行的docker，卸载docker的方法为：
## 卸载docker命令 sudo yum remove docker \ docker-client \ docker-client-latest \ docker-common \ docker-latest \ docker-latest-logrotate \ docker-logrotate \ docker-engine 2、安装docker ## 安装 docker sudo yum install -y yum-utils sudo yum-config-manager \ --add-repo \ https://download.docker.com/linux/centos/docker-ce.repo sudo yum install docker-ce docker-ce-cli containerd.io docker-compose-plugin ## docker 开机自启动 sudo systemctl start docker &amp;&amp; sudo systemctl enable docker 三、安装docker-compose curl -SL https://github.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ffb306abaa1b1fa28ee36027768345b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/660ab6f0c9055f49149f36e31d030ad0/" rel="bookmark">
			MySQL多线程备份工具mydumper
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、mydumper简介
二、mydumper安装
1、yum安装mydumper
2、源码安装mydumper
三、mydumper参数介绍
四、myloader参数介绍
五、使用例子
一、mydumper简介 mydumper 是一款社区开源的逻辑备份工具。该工具主要由 C 语言编写，目前由 MySQL 、Facebook 等公司人员开发维护。
参考官方介绍，mydumper 主要有以下几点特性：
支持多线程导出数据，速度更快。支持一致性备份。支持将导出文件压缩，节约空间。支持多线程恢复。支持以守护进程模式工作，定时快照和连续二进制日志。支持按照指定大小将备份文件切割。数据与建表语句分离。 mydumper 官网：https://launchpad.net/mydumper
mydumper github： https://github.com/mydumper/mydumper
mydumper下载：https://launchpadlibrarian.net/225370879/mydumper-0.9.1.tar.gz
wget https://launchpadlibrarian.net/225370879/mydumper-0.9.1.tar.gz 二、mydumper安装 1、yum安装mydumper ## RedHat / Centos release=$(curl -Ls -o /dev/null -w %{url_effective} https://github.com/mydumper/mydumper/releases/latest | cut -d'/' -f8) yum install https://github.com/mydumper/mydumper/releases/download/${release}/mydumper-${release:1}.el7.x86_64.rpm yum install https://github.com/mydumper/mydumper/releases/download/${release}/mydumper-${release:1}.el8.x86_64.rpm 2、源码安装mydumper 根据个人使用经验，推荐mydumper-0.9.1版本比较稳定，github上边的比较新，会出现预想不到bug。
# Dependencies for building mydumper yum install -y cmake gcc gcc-c++ git make yum install -y glib2-devel openssl-devel pcre-devel zlib-devel libzstd-devel yum install -y mysql-devel yum install -y Percona-Server-devel-57 yum install -y mariadb-devel wget https://launchpadlibrarian.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/660ab6f0c9055f49149f36e31d030ad0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4952899f49304224548b73ebe30b8943/" rel="bookmark">
			docker安装jira
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、安装docker
二、下载MySQL 驱动
三、下载JIRA 依赖软件
四、编写jira Dockerfile文件
五、创建jira 容器启动文件
六、数据库配置和创建jiradb
七、配置jira和配置许可
八、k8s部署jira文件(附加内容)
一、安装docker 安装docker和docker-compose请参考：https://blog.csdn.net/weixin_44770684/article/details/129227050
二、下载MySQL 驱动 既然默认使用PostgreSQL数据库，若使用MySQL数据库，则需要添加MySQL驱动，
从MySQL官网下载MySQL驱动，具体的驱动版本号需要根据实际使用的数据库版本号，理论上高版本的MySQL 驱动支持低版本的MySQL数据库。
说明：我使用的是mysql 8.0的驱动和MySQL 5.7数据库。
MySQL驱动下载：https://downloads.mysql.com/archives/c-j/ 点击 Archives 菜单可以选择目标版本号的MySQL驱动，我下载的驱动是：mysql-connector-java-8.0.23.jar 。
解压下载的MySQL驱动压缩包，将 MySQL压缩包里面的 mysql-connector-java-8.0.23.jar 文件复制到Dockerfile 文件目录
三、下载JIRA 依赖软件 参考文档说明：https://github.com/qinyuxin99/atlassian-agent 我下载的版本是：atlassian-agent-v1.2.3.tar.gz，解压下载的jira软件包，将 atlassian-agent.jar 文件复制到Dockerfile 文件目录
四、编写jira Dockerfile文件 1、我将jira需要的文件都放在 jira 目录下：
2、 构建jira镜像的Dockerfile文件内容见：
## cat Dockerfile # jira 的基础镜像版本, 需要更换成自己需求的版本号，适用于升级jira FROM atlassian/jira-software:8.16.1 AS jira LABEL creator="@土豆" USER root # 软件包下载地址: https://github.com/qinyuxin99/atlassian-agent COPY atlassian-agent.jar /opt/atlassian/jira/ # jira配置和连接mysql参考文档：https://confluence.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4952899f49304224548b73ebe30b8943/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85158cb94dc61948261d0b53283a416f/" rel="bookmark">
			硬件基础元器件【2.电容篇】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2 电容
文章目录 2.1 电容的主要作用2.2 电容的主要参数2.3 电容的等效模型2.3.1 等效串联电阻ESR2.3.2 等效串联电感ESL2.3.3 电容阻抗的频率特性 2.4 选型要点2.4.1 多层陶瓷电容(MLCC)通用MLCC的分类MLCC选型要点 2.4.2 钽电容2.4.3 电解电容 2.5 电容的主要应用场景2.5.1 去耦电容去耦半径 2.5.2 旁路电容2.5.3 耦合电容 电容是电子设备中不可缺少的电子元器件，应用十分广泛。电容的种类繁多，结构也各不相同，但其基本原理是一样的，都是依靠电荷的相互作用力把电荷存储起来。电容相比于电阻，种类更多，更加复杂。作为电子工程师，需要掌握各种电容的基本原理、基本参数、电气特性、选型方法等。 2.1 电容的主要作用 作为电荷缓冲池
在电路中，电源的负载是动态的，即器件的电流和功耗是不断变化的。为了保证电路稳定工作，可以使用电容作为电荷的缓冲池，保证器件工作电压的稳定。( Δ U = Δ Q C \Delta U = \dfrac{\Delta Q}{C} ΔU=CΔQ​， Δ U \Delta U ΔU表示电容两端电压变化量， Δ Q \Delta Q ΔQ表示电荷变化量，C为电容容值)
用来泄放高频噪声
高速电路中，无时无刻都存在状态改变，从而在电路中产生大量噪声干扰。在电源的传输路径上，需要通过电容将这些高频噪声写放到相对稳定的地平面中，避免干扰器件的正常工作。(根据阻抗公式： Z = 1 j ω C Z=\dfrac{1}{j\omega C} Z=jωC1​，在频率较高时，电容表现为低阻抗)
用于交流耦合
当两个器件通过高速信号相连时，信号想断的器件可能对直流分量有不同的要求。在这种情况下，需要使用电容将信号携带的直流分量在接收端之前滤除。
2.2 电容的主要参数 1、标称电容量
标称电容量为电容的标注值。其实际容值会随着工作频率、工作电压、测量方法等变化而变化。
2、额定电压
指在额定环境温度下，可以连续加在电容两端的最高直流电压有效值。
3、精度
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/85158cb94dc61948261d0b53283a416f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a970e04fbcb7e8472e07af46b3553a65/" rel="bookmark">
			记录手贱删除环境变量Path后的还原方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果电脑没有重启 1. win + r 输入 regedit 回车
找到路径 HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Control\Session Manager\Environment
点击 Path 右键 选择 修改
2. 在弹出的对话框中 Ctrl + A + Ctrl + C 复制 数值数据的值
3. 打开系统属性 &gt; 高级 &gt; 环境变量 &gt; 系统变量 &gt; 新建 &gt; 变量名 Path
在 变量值 里 粘贴刚才复制的值 确定 完成
如果电脑重启了 但是开启了系统还原保护 1. 打开系统属性 &gt; 系统保护 &gt; 系统还原 点击后会出现一个列表 有详细的时间和名字 可以选择恢复
最后! ! ! 你如果像我一样手贱，又没开启系统保护，而你又以为重启就能解决问题的时候 ，那只能像我这样 1. 找一个跟你电脑系统差不多的 去他的环境变量里找到你删除那个相应的环境变量 一个个复制
2. 如果你的某些程序跑不起来了 可以去网上找找关于程序的环境变量配置 或者可以找找同事或者朋友的环境变量配置，对应自己的安装路径，再进行配置
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a970e04fbcb7e8472e07af46b3553a65/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05d9c96556f5a92af92e3f446fb90eaf/" rel="bookmark">
			设计模式之建造者模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		设计模式之建造者模式 1.建造者模式1. 概述2. 结构3. 实例4. 优缺点5. 使用场景6. 模式扩展 2. 创建者模式对比2.1 工厂方法模式VS建造者模式2.2 抽象工厂模式VS建造者模式 1.建造者模式 1. 概述 将一个复杂对象的构建与表示分离，使得同样的构建过程可以创建不同的表示。
分离了构成一个对象所需部件的构造和装配。 从而可以构造出复杂的对象。这个模式适用于：某个对象的构建过程复杂的情况。由于实现了构建和装配的解耦。不同的构建器，相同的装配，也可以做出不同的对象；相同的构建器，不同的装配顺序也可以做出不同的对象。也就是实现了构建算法、装配算法的解耦，实现了更好的复用。建造者模式可以将部件和其组装过程分开，一步一步创建一个复杂的对象。用户只需要指定复杂对象的类型就可以得到该对象，而无须知道其内部的具体构造细节。 2. 结构 建造者模式包含如下角色：
抽象建造者类（Builder）：这个接口规定要实现复杂对象的那些部分的创建，并不涉及具体的部件对象的创建。 具体建造者类（ConcreteBuilder）：实现 Builder 接口，完成复杂产品的各个部件的具体创建方法。在构造过程完成后，提供产品的实例。 产品类（Product）：要创建的复杂对象。 指挥者类（Director）：调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建。 3. 实例 创建共享单车
生产自行车是一个复杂的过程，它包含了车架，车座等组件的生产。而车架又有碳纤维，铝合金等材质的，车座有橡胶，真皮等材质。对于自行车的生产就可以使用建造者模式。
这里Bike是产品，包含车架，车座等组件；Builder是抽象建造者，MobikeBuilder和OfoBuilder是具体的建造者；Director是指挥者。
具体的代码如下：
//自行车类 public class Bike { private String frame; private String seat; public String getFrame() { return frame; } public void setFrame(String frame) { this.frame = frame; } public String getSeat() { return seat; } public void setSeat(String seat) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05d9c96556f5a92af92e3f446fb90eaf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbd2d5e8433b6e7db23edea43e8cc28a/" rel="bookmark">
			window.open跳转携带本地地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在项目中遇到一个问题，在使用window.open 跳转其他项目的时候，地址肉眼观察书写正确，但是跳转的时候就是会携带本地的地址，每次都跳转不过去，后来发现是后端的库里在http前面加了空格，返回前端的时候这个空格不展示，称之为零宽空格，转义字符是%E2%80%8B。
处理办法，就是让后端去掉空格就可以正常跳转了。
https://blog.csdn.net/sufubo/article/details/117223508
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f5a576d8f95e07a227be7f45e78bb53/" rel="bookmark">
			ubuntu设置开机进入命令行或图形界面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1. 开机进入命令行
sudo systemctl set-default multi-user.target sudo reboot 2. 开机进入图形界面
sudo systemctl set-default graphical.target sudo reboot 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4797768df4ad5879eedc80c7a17b4de9/" rel="bookmark">
			opencv之形状匹配/形状场景距离计算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		cv2.matchShapes
通过hub矩来判断两个对象的一致性，有cv2.CONTOURS_MATCH_I1,cv2.CONTOURS_MATCH_I1,cv2.CONTOURS_MATCH_I1三种方法。
cv2.createShapeContextDistanceExtractor()
用于计算形状场景距离，通过使用形状上下文算法在计算距离时，在每个点上附加一个形状上下文描述符，每个点都能够捕获剩余点相对于它的分布特征，从而提供全局鉴别特征。
cv2.createHausdorffDistanceExtractor()
计算图形A内的每一个点，寻找其距离图像B的最短距离，将这个最短距离作为Hausdroff直接距离D1，计算图形B内的每一个点，寻找其距离图像A的最短距离，将这个最短距离作为Hausdroff直接距离D2，将上述D1、D2中的较大者作为Hausdroff距离，容易受极端值的影响。
img1 = cv2.imread("E:/work/images/gb.jpg", 0) _, img1 = cv2.threshold(img1,100, 255, cv2.THRESH_BINARY_INV) c1, f1 = cv2.findContours(img1, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE) cv2.drawContours(img1, c1[0], -1, 127, 2) img2 = cv2.imread("E:/work/images/k.PNG", 0) _, img2 = cv2.threshold(img2,100, 255, cv2.THRESH_BINARY_INV) c2, f2 = cv2.findContours(img2, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE) cv2.drawContours(img2, c2[0], -1, 127, 2) img3 = cv2.imread("E:/work/images/gb_src.jpg", 0) _, img3 = cv2.threshold(img3,100, 255, cv2.THRESH_BINARY_INV) c3, f3 = cv2.findContours(img3, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE) cv2.drawContours(img3, c3[0], -1, 127, 2) sc = cv2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4797768df4ad5879eedc80c7a17b4de9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9baf738ffea8bca985e51eba41bf74b2/" rel="bookmark">
			qnx slog2应用实践小结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 应用场景简介 在QNX系统上开发的应用需要打印日志以帮助开发人员排查相关问题，在C/C++程序中可以使用printf输出到控制台，但很多程序在后台运行，因此借助slog2相关API封装成日志类用于向slog输出日志。
二 QNX slog2简介 1.概述
slog2 是QNX系统提供的一套log机制，slog2info是管理slog的一个进程，可通过slog2info命令获取历史log。
2.slog API
（1）配置log
typedef struct { int num_buffers; // log buffer集 中有多少个buffer const char *buffer_set_name; // log buffer集的名称一般是进程名，slog2info -b 参数使用 uint8_t verbosity_level; // 整个log buffer集中的最小verbosity_level，只有高于verbosity_level的log才会写入log buffer中 slog2_buffer_config_t buffer_config[ SLOG2_MAX_BUFFERS ]; uint32_t max_retries; } slog2_buffer_set_config_t; typedef struct { const char *buffer_name; // slog2 buffer 名称 int num_pages; // 用于定于log buffer的大小，一个page是4kB } slog2_buffer_config_t; （2）创建实例
int slog2_register( slog2_buffer_set_config_t *config, // buffer集的配置结构体 slog2_buffer_t *handles, // 返回操作buffer的handle，后面打印log函数会用到 uint32_t flags ); // 用于指定是否存放到flash中，方便热启时恢复 // 返回值：0 成功，-1 失败 （3）打印日志
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9baf738ffea8bca985e51eba41bf74b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be5c29da40cd97cdcc578046721ee45e/" rel="bookmark">
			uniapp微信小程序页面间传值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、navigateBack返回时传值 //从主页跳转到头图页 toFacePicture() { let vm = this; // 保存当前页面的实例对象 uni.navigateTo({ url: '/pages/activities/create-activities/faceImages', events: { //自定义一个监听器名, data为选择页面返回的数据 selectFacePicture(data) { vm.selectedImageIndex = data.picIndex; console.log("picIndex" + data.picIndex); console.log("picIndex" + vm.selectedImageIndex); } } }) }, //从头图页返回主页| 返回按钮的点击事件处理 goBackToCreate() { const eventChannel = this.getOpenerEventChannel(); let urls = this.getSelectedImgUrlList(); var vm = { picIndex: urls } //注意，这里的第一个参数要和主页面的监听器名称一致 //第二个就是要传的数据，我这里是传了一个对象回去 eventChannel.emit('selectFacePicture', vm); uni.navigateBack(); }, 参考文档：
1.https://juejin.cn/post/6844904191605866503
二、navigateTo跳转时传值 从页面A通过uni.navigateTo跳转至页面B（非tab页），将页面A中的数据传递到页面B。
//页面A let vm = this; // 保存当前页面的实例对象 uni.navigateTo({ url: '/pages/activities/create-activities/faceImages', events: { //自定义一个监听器名 originalSelectedData(data){ console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be5c29da40cd97cdcc578046721ee45e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/286274851fdfb9294a534088702dc9de/" rel="bookmark">
			JavaWeb&#43;JSP&#43;路径问题&#43;跳转（HTML|Servlet|JSP）|这一篇就够了（超详细）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🙈作者简介：练习时长两年半的Java up主
🙉个人主页：老茶icon
🙊 ps:点赞👍是免费的，却可以让写博客的作者开兴好久好久😎
📚系列专栏：Java全栈，计算机系列（火速更新中）
💭 格言：种一棵树最好的时间是十年前，其次是现在
🏡动动小手，点个关注不迷路，感谢宝子们一键三连
目录 课程名：JavaWeb内容/作用：知识点/设计/实验/作业/练习学习：JavaWeb+JSP 环境与设备JSPJSP的组成1.HTML元素*2.Java脚本*3.表达式*4.注释5.指令6.声明7.动作 路径问题绝对路径相对路径 跳转HTML to HTML/JSPHTML to ServletServlet/JSP to Servlet/JSP/HTML请求转发重定向 跳转过程中传递参数总结 课程名：JavaWeb 内容/作用：知识点/设计/实验/作业/练习 学习：JavaWeb+JSP 环境与设备 1.软件：IntelliJ IDEA 2022.3.2
2.环境：Windows 11 and JDK 11
JSP Java Server Pages
使用Java开发，运行在服务器上的页面，称为JSP。
JSP页面的后缀名为.jsp
由于最初由Servlet编写页面，会在Servlet中出现大量的HTML代码，使用极不方便，
由SUN公司主导推出JSP，在HTML页面中嵌入Java代码，简化了页面的编写过程，页面也成为动态页面。
JSP实际是一个java类，具体为一个Servlet，第一次访问某个JSP页面，相当于编译运行Servlet，所以会慢一些。
访问JSP的流程：编译对应的Servlet–&gt;运行Servlet。
JSP的生命周期同Servlet。
使用JSP时，可以导入该依赖，在JSP中方便提示
&lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet.jsp-api&lt;/artifactId&gt; &lt;version&gt;2.3.3&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; JSP的组成 1.HTML元素* 2.Java脚本* &lt;% java代码; %&gt; 3.表达式* 用于在页面中输出变量或字符串。
无需分号。
&lt;%=变量%&gt; 4.注释 jsp注释在访问jsp时不会在浏览器中看到
html注释在访问jsp时会再浏览器中看到
&lt;%--注释--%&gt; 5.指令 &lt;%@ 指令名 属性="值"%&gt; page指令 用于设置当前页面的属性 include指令 用于嵌入其他页面 taglib指令 用于导入其他标签库 6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/286274851fdfb9294a534088702dc9de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/131b878478618b5ade2354ff42229eb8/" rel="bookmark">
			跨考考研零基础一战上岸经验贴
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		❤❤❤❤创作不易，如果对你有帮助，感谢你的点赞分享和收藏❤❤❤❤❤ 写在前面。
本人本科是普通二本院校传统工科专业（能源与动力工程），开始考研之前没有任何编程基础（上过几节课的vb但是根本没听），一战跨考上岸重庆邮电大学。
零基础；跨考；地区不同；三非学生；本科期间无任何奖项经历；属于是debuff叠满了
考研前一年时间才决定跨考，最后自己的分数：总分344；政治73，英一61，数学100，802数据结构110；复试笔试90；最终前几名录取；
乍一看其实没有特别强势的科目，但是每一科成绩都还算可以，所以最终成绩也说得过去。我个人觉得这一点很重要。这也是大家复习的时候要去考虑到的，自己有没有一门非常强势的学科，或者给自己每一科定一个不错的目标分数，不断去补齐并且拔高所有科目。
重点：如果决定跨考，择校！选书！学习！远离全退党等等党口嗨党！！！。只要能脚踏实地来，找到自己合适的学校，就没有什么能阻止你的。
接着就从几个角度来说说考研这一年多的经历吧。
择校经验 在选择学校的时候，当时就考虑到计算机专业近几年考研竞争压力很大，因此在择校的时候就没敢考虑过档次太高的学校。如果实力够的直接报92考408，当时我感觉我一年的时间和能力一年学数一英一408来不及，于是就想选只考一门或者两门的专业课，目光便锁定在了南邮，重邮，杭电这几个热门双非里，因为听说都不怎么歧视跨考，每年收的人很多，跨考的也很多。
然后就开始综合对比这几个学校
以下所有对比仅个人思路，酌情考虑，并不完全准确！！！
计算机能力更重要，这几个学校在就业上面并没有太大可比性，个人能力永远是第一，其次考虑以后主要想在哪里发展。
先说杭电。杭电这几年水涨船高，专业课改考408了，并且生源也越来越好，很多本科92的都有冲杭电的，为了稳妥起见再三考虑放弃了杭电。
再说南邮：南邮最近几点的录取分数线也很高，但是客观来看，因为南邮的专业课均分相对来说高，所以更加比拼数学英语能力，其次南邮的学科评估报告中，计算机是b-，软件是b，相对于重邮来说计算机专业会稍微吃亏一点，南京这个城市也是考研的重灾区，其次南邮报名人数很多，当时也考虑怕南邮太热门导致卷爆。
最后看重邮：当时考虑首先重邮的招生人数很多，分数线最低，细看之后发现专业课均分很低，可能90，100这样。当时觉得只要好好学专业课不会被拉开太大差距；其次重邮的计算机是b+，软件b-；最后就是个人对重庆的感觉更喜欢一点。
虽然考虑到重邮到专业课存在压分现象，但是综合考虑南邮，杭电的考研难度大于重邮，最后求稳选择重邮（结果这一年重邮爆炸了，英一复试线60）。
我现在觉得这些学校的实力主要集中在所属城市，如果非常中意的城市，那实力对比其实不算太重要，因为任何学校的实力肯定在当地的认可度是最高的。如果城市无所谓，再去评价学校的强弱，考研难度走势之类的。
备考经验 1.时间安排最为重要
2.取长补短，查漏补缺
复习建议-时间安排 所谓时间安排，即如何在一年内安排好复习时间，什么阶段做什么事。
就工科考研而言基本可以认定：数学&gt;专业课&gt;英语&gt;政治
数学
数学永远是复习的重中之重，一句话总结：
从决定考研开始，就开始学数学，刷题，到考前一天，还是在学数学，刷题
无论跟哪个老师，网课老师也好，线下老师也好，想学好数学不仅得有好老师，也得有”烂笔头“，无论哪一个知识点都要不断地刷题巩固才能说逐渐掌握，才能在考场上认出题型并且拿到分数。
这里推荐基本我觉得非常不错的教材和老师：
高数：知名老师都可以；书籍强推《李永乐复习全书》
线代：线代之神李永乐；书籍强推《线性代数辅导讲义》–李永乐
概率论：余炳森，王式安各有风格，都比较推荐；书籍推荐《概率论与数理统计》–余炳森
专业课
作为跨考生，专业课真的是非常头疼的内容。
重邮考的是802《数据结构》，作为本科计算机专业最难的书之一，跨考生想要一下子学会基本是不可能的。
因此我从决定考验后，就开始学习c语言，c语言大概学了一个月后，立马着手开始学数据结构。
数据结构从最开始的简单逻辑–到后面特点，算法流程–再到最后代码实现。我用了整整七个月时间。
我全程使用的都是王道的网课视频和《王道数据结构考研辅导》
英语
英语相对来说是个不断积累的过程，比较看重底子。
因此在时间安排上，我最开始只是简单的背大纲单词，到七月份开始才开始刷真题，一直刷到十二月。后期十二月开始背作文模板。
英语相对来说复习资料比较单一，即真题。只要单词词汇量上来了，再把真题反反复复刷一下，英语成绩提升的很快的。
至于大家说的语法，长难句等，各位看个人情况吧，我是简单看了一下语法但是感觉帮助不大于是放弃了。
一方面是想把大部分时间留给数学和专业课，另一方面想长难句投入时间和产出分数的比例太低了。
政治
个人感觉政治是投入时间和产出分数比例最高的学科，这个学科不用下太大功夫就能有比较高的分数。
因此我整个前期什么都没做，在七月份开始我看了一些马原的课，但是个人依然感觉帮助不大，遂之间开始刷选择题，当然结果就是刷一个错一个，但是无所谓，错了之后之间背答案，虽然记住的不多，但是常考点都有了印象，比一步步看书复习快得多。
后期选择题依然如此，刷一道记忆一道，十二月肖四一背就直接上考场了。
同时后期强烈推荐看一下腿姐的冲刺班，押题班，政治考题基本上都是当年热点问题，所以各大机构名师基本上都会压个大概，帮助超级大！！！
复习建议-取长补短 在时间有限的情况下，如何拿到最大的分数是重点！！
比如我刷十套数学题但是每次的压轴题都毫无头绪，我再去学压轴题需要半个月才能拿到10分。但是我用这半个月去学习算法我可以把链表，递归都掌握，在重邮的专业课试卷上可以拿到20分甚至更高。
只是简单的举个例子，用在我自己身上即把英语长难句，政治基础知识的时间全部砍掉，用来学习数学和专业课，而最后我突击英语和政治也可以保证有平均分，即使英语和政治特别好的同学也只能拉开我不足10分，而这分数在数学我一道题就能扳回来。
这一点很多会误解，导致最后英语单科不过线，希望大家能理解到动态过程。
比如前期一定是数学，专业课提分快。但到后期瓶颈期了，数学的压轴题就是难，就是做不出来，这个时候再去补英语政治不是提分更快么？
复试经验 重邮的复试我是线上笔试＋面试两轮
笔试 线上笔试考察的是系统题或者算法，系统题即要手撸一套×××管理系统，不需要UI，只要用控制台互动即可，语言可选c/c++。
这点对于我来说，一开始可给我愁坏了，算法基础太差，代码能力也很弱，一开始以为挂定了！结果笔试题拿了90分（90分在笔试题里算满分，100需要用ccf换）
早早就怕挂，于是早早就开始学。
初始考完没多久，我就又从头学了一遍c，因为初始的时候c大部分内容只是简单了解了解，基本都没有上机敲过。而这一遍把所有内容全部都敲了一下。
重点的指针，结构体，链表，数组这些内容学差不多了，就开始写系统了。
跟着网上的视频学了一遍就开始敲，一开始一周才能敲完一套完整的，但是熟悉了之后只需要一天即可。
这还不够快，因为考试只有三个小时。于是我就整理了一套模板，反复又敲了几遍，两个多小时就可以完成所有内容了。
面试 面试其实是最吃亏的，因为专业能力和知识除了考研考到的，几乎为零。
但是因为初始和笔试的分数够高，所以老师也没有太过为难。问了一些基本的c语言和数据结构知识都答上来了。
重点是一些综合问题：即跨考生一定会面对的：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/131b878478618b5ade2354ff42229eb8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/564ba08ee93522d67d9b5627c9803d0e/" rel="bookmark">
			Win11&#43;VS2019环境下配置点云库PCL1.11.1踩坑（OpenNI2安装和x64 Release模式）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面 参考的这个博主的文章Win10+VS2019环境下配置点云库PCL1.11.1（超详细）写得确实很详细，挺好的，基本可以完全参照走下来。走下来的效果B站有个up展示出来了，在vs2019中配置pcl点云库结果展示！，我详细补充几个我参考该文章遇到的问题，提出来让大家避免踩坑
1 OpenNI2安装问题 原文博主说安装过程会自动弹出OpenNI2的安装，但是要安装在3rdParty下，但是我安装的时候它是自动默认就安装在C盘Program Files目录下了。
解决办法：3rdParty\OpenNI2下有一个msi文件，双击，卸载，然后再重新安装到指定目录下就可以了
安装结果为：
2 X64 Release模式下的配置 基本是在最后一部了，原文博主配的是Debug环境，对于要做工程项目的人来说可能不合适，因此这里说一下Release模式下如何配。
最后一步打开：配置属性文件-链接器-输入-附加依赖项
原文给的是debug模式下的lib文件，release下则需要全部更换，去掉pcl的文件结尾的d，去掉vtk结尾的-gd，pcl未添加d结尾的为release下所需要文件，而vtk未添加gd结尾文件，为release下所需要文件。我是复制粘贴到word里直接全部替换的，这里直接给大家。
pcl_common.lib pcl_features.lib pcl_filters.lib pcl_io.lib pcl_io_ply.lib pcl_kdtree.lib pcl_keypoints.lib pcl_ml.lib pcl_octree.lib pcl_outofcore.lib pcl_people.lib pcl_recognition.lib pcl_registration.lib pcl_sample_consensus.lib pcl_search.lib pcl_segmentation.lib pcl_stereo.lib pcl_surface.lib pcl_tracking.lib pcl_visualization.lib vtkChartsCore-8.2.lib vtkCommonColor-8.2.lib vtkCommonComputationalGeometry-8.2.lib vtkCommonCore-8.2.lib vtkCommonDataModel-8.2.lib vtkCommonExecutionModel-8.2.lib vtkCommonMath-8.2.lib vtkCommonMisc-8.2.lib vtkCommonSystem-8.2.lib vtkCommonTransforms-8.2.lib vtkDICOMParser-8.2.lib vtkDomainsChemistry-8.2.lib vtkDomainsChemistryOpenGL2-8.2.lib vtkdoubleconversion-8.2.lib vtkexodusII-8.2.lib vtkexpat-8.2.lib vtkFiltersAMR-8.2.lib vtkFiltersCore-8.2.lib vtkFiltersExtraction-8.2.lib vtkFiltersFlowPaths-8.2.lib vtkFiltersGeneral-8.2.lib vtkFiltersGeneric-8.2.lib vtkFiltersGeometry-8.2.lib vtkFiltersHybrid-8.2.lib vtkFiltersHyperTree-8.2.lib vtkFiltersImaging-8.2.lib vtkFiltersModeling-8.2.lib vtkFiltersParallel-8.2.lib vtkFiltersParallelImaging-8.2.lib vtkFiltersPoints-8.2.lib vtkFiltersProgrammable-8.2.lib vtkFiltersSelection-8.2.lib vtkFiltersSMP-8.2.lib vtkFiltersSources-8.2.lib vtkFiltersStatistics-8.2.lib vtkFiltersTexture-8.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/564ba08ee93522d67d9b5627c9803d0e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/525e84bf44ce3b1a287fcecdae993a58/" rel="bookmark">
			单片机时钟电路图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6b5ba472a22f116fea9ccb66631348f/" rel="bookmark">
			什么是Python？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python是一种高级编程语言，它被设计成易读易写、具有简洁优美的语法和动态类型的解释型语言。Python由Guido van Rossum在1989年创造，最初目的是作为一种较为简单易学的编程语言，因此Python的语法设计非常简单易懂，入门门槛很低。随着时间的推移，Python越来越受到开发者们的欢迎，成为了一种广泛应用于各种领域的编程语言。
历史背景 Python最初的开发时间可以追溯到1980年代末和1990年代初，这个时期正是计算机硬件的飞速发展，人们对于软件和应用程序的需求也越来越多。Guido van Rossum，Python的创始人，发现当时存在的编程语言在各自的领域中存在不足，他希望能够设计一种能够弥补这些不足的编程语言。
在接下来的几年中，Guido van Rossum不断地改进Python，加入了很多新的特性和功能，并且逐渐发展成一种流行的编程语言。现在，Python已经成为了一种非常受欢迎的编程语言，广泛应用于各种领域，包括Web开发、数据分析、机器学习、人工智能等等。
学习路线 Python作为一种非常流行的编程语言，有很多学习资源和途径。以下是一些适合初学者和进阶学习者的学习路线：
初学者 学习Python基础语法：首先要了解Python的基础语法，如变量、数据类型、运算符、条件语句、循环语句等等。可以通过阅读Python官方文档、在线教程、视频教程等方式进行学习。完成一些简单的练习：通过完成一些简单的练习，可以巩固所学的Python语法知识，同时也可以提高编程能力。可以尝试一些简单的练习，如输出“Hello World”、计算1到100的和等等。学习Python标准库：Python标准库中包含了很多有用的模块和函数，这些函数和模块可以帮助我们完成很多任务，如文件操作、网络编程、数据库操作等等。学习Python标准库可以提高我们的编程能力，并且让我们能够更加高效地完成任务。学习Python第三方库：Python有很多第三方库，这些库包含了各种功能和特性，可以帮助我们完成很多任务。对于初学者来说，可以先学习一些常用的第三方库，如NumPy、Pandas、Matplotlib等等，这些库可以帮助我们进行数据分析和可视化。 参与Python社区：Python拥有一个非常活跃的社区，这个社区包含了很多开发者和爱好者，他们会分享自己的经验和技巧，并且会提供帮助和支持。参与Python社区可以让我们更快地学习和成长，可以通过参与Python论坛、GitHub项目等方式加入Python社区。 进阶学习者 学习Python框架：Python有很多优秀的框架，这些框架可以帮助我们更加高效地完成任务。对于进阶学习者来说，可以学习一些常用的Python框架，如Django、Flask、Scrapy等等，这些框架可以帮助我们进行Web开发、爬虫开发等等。学习Python高级特性：Python有很多高级特性和技巧，如装饰器、生成器、迭代器等等，这些技巧可以帮助我们更加高效地编写Python代码。对于进阶学习者来说，可以学习这些高级特性和技巧，并且尝试将其应用到实际项目中。学习Python数据科学：Python在数据科学领域有很大的应用，可以帮助我们进行数据处理、分析、可视化等等。对于进阶学习者来说，可以学习一些常用的数据科学库和工具，如NumPy、Pandas、Scikit-learn等等，这些库和工具可以帮助我们进行数据科学工作。参与Python开源项目：Python开源项目非常丰富，这些项目包含了各种领域的应用和工具。对于进阶学习者来说，可以参与一些Python开源项目，这可以帮助我们提高编程能力，并且让我们更深入地了解Python。 推荐书籍 以下是一些适合初学者和进阶学习者的Python书籍：
《Python编程从入门到实践》：这本书是一本非常适合初学者的Python书籍，其中包含了很多实例和练习，可以帮助初学者快速掌握Python的基础知识。《Python核心编程》：这本书是一本适合进阶学习者的Python书籍，其中包含了很多Python高级特性和技巧，可以帮助进阶学习者更加深入地了解Python。 《Python数据科学手册》：这本书是一本适合数据科学初学者的Python书籍，其中详细介绍了Python在数据科学领域的应用和常用库的使用。《流畅的Python》：这本书是一本适合进阶学习者的Python书籍，其中深入介绍了Python的高级特性和技巧，可以帮助我们编写更加优雅的Python代码。 学习方法 以下是一些学习Python的方法和技巧：
坚持练习：学习编程语言最重要的就是练习，只有通过实践才能掌握编程语言。可以通过做一些练习题、写一些小项目等方式进行练习。查看文档：Python有非常详细的文档和手册，可以帮助我们更快地掌握Python。可以查看Python官方文档和第三方库的文档，以便更好地理解和应用Python。参加课程：参加Python课程可以帮助我们更加系统地学习Python，可以选择在线课程或者线下培训。参与社区：可以加入Python社区，与其他Python开发者和爱好者交流，分享经验和技巧。 资料推荐 以下是一些学习Python的资料推荐：
Python官方文档：3.11.3 DocumentationPython库手册：PyPI · The Python Package IndexPython代码库：GitHub: Let’s build from here · GitHubPython在线练习平台：Solve Python | HackerRankPython在线课程：Best Python Courses &amp; Certifications [2023] | CourseraPython社区：Our Community | Python.org 总之，学习Python需要坚持练习，查看文档，参加课程和参与社区，这样才能更好地掌握Python。同时，推荐适合自己的Python书籍和资料，可以加速学习的进度。
总结 Python是一种易学易用的编程语言，它具有简洁的语法和丰富的库，可以用于多种应用领域，如数据分析、机器学习、人工智能、Web开发等。学习Python可以从基础语法、常用库、项目实战等方面入手，可以选择在线课程、教材、编程书籍等方式进行学习。在学习过程中需要坚持练习，查看文档，参加课程和参与社区，这样才能更好地掌握Python。
Python拥有强大的生态系统，有丰富的第三方库可以使用，如NumPy、Pandas、Matplotlib、Tensorflow、PyTorch等，这些库为Python在数据科学、机器学习等领域提供了强有力的支持。此外，Python还有一个庞大的社区，这个社区由开发者、用户和爱好者组成，为Python的发展做出了重要贡献。
对于初学者来说，学习Python并不是一件容易的事情，需要耐心和毅力。但是，只要我们坚持不懈，不断练习和学习，就一定能够掌握Python，成为一名合格的Python开发者。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/163ce7a7f4b3a034968d3dc3348965ac/" rel="bookmark">
			Ajax异步请求方法(详细)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用ajax发送异步请求 原生js实现以及jquery ajax实现发送请求
文章目录 使用ajax发送异步请求简介实现方式1.原生js实现1.get请求2.post请求 2.jquery ajax实现1.基本方式2.回调事件 3. jquery中的封装函数1.$.post2.$.get3.$.getJSON4.$.getScript 总结 简介 Ajax即Asynchronous Javascript And XML（异步JavaScript和XML） 使用Ajax技术网页应用能够快速地将增量更新呈现在用户界面上，而不需要重载（刷新）整个页面情况下，能够更新部分网页的技术。
同步和异步
同步互交：指向服务器发送一个请求,需要等待返回,然后才能够发送下一个请求，期间有个等待过程；异步互交：指向服务器发送一个请求,不需要等待返回,随时可以再发送下一个请求，即不需要等待； 实现方式 1.原生js实现 1.get请求 代码如下（示例）：
// 创建请求对象 var xhr = new XMLHttpRequest() // 封装参数对象 var data = {id: 1,name: "张三"} // 配置请求方法，设置请求接口地址 //同步或异步请求：true（异步）或 false（同步） xhr.open('get', 'http://localhost:8080/api?' + JSON.stringify(data),true) //发送请求 xhr.send() // 获取网络请求响应的数据 xhr.onreadystatechange = function () { // 响应完毕，并且请求成功 if (xhr.readyState === 4 &amp;&amp; request.status === 200) { var res = JSON.parse(xhr.responseText) //.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/163ce7a7f4b3a034968d3dc3348965ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f500d03c763aa4a58f8c0a98882bf04/" rel="bookmark">
			你必看的Java实战练手项目（附源码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		嗨喽，大家好，关注我，福利不断！
不管我们要学习哪种语言都希望能第一时间看到成效，能做出实际的东西来，那么这里所说的实际东西当然就是项目啦！不用我说大家也知道，学编程语言不做项目是不行的，自己所学的知识得不到应用，很难有所成长。
那么今天，我在这里就整理了10个java企业级实战项目，这些项目都有完整视频教程和配套源码及学习资料，大家可以从当中选择自己想做的项目进行参考学习练手，你也可以从中寻找灵感去做自己的项目。
java项目配套的学习资料+课件+源码+学习笔记为各位打包好了！！！
废话不多说，直接上干货！
1、Ting域主持人 项目介绍： Ting域主持人项目是一个标准的互联网项目，主要为各种需要主持人的场合提供主持人聘请相关功能。项目包含了前台和后台。前台主要是让新人和婚庆公司搜索相关主持人并进行聘请，在线对主持人下订单。后台是让主持人对自己订单的管理以及管理员对整个平台的管理。
技术架构： Spring、SpringMVC、MyBatis、MyBatisPlus、移动支付、短信验证、RBAC、EasyUI、POI、百度chart
项目亮点： 真实企业项目；已上线项目；包含企业产品经理设计的项目原型；标准互联网项目，包含前后端；完整的第三方平台接入 2、未来出行汽车租赁平台 项目介绍： 未来出行汽车租赁平台是为汽车出租、出售进行管理的平台。管理员平台中可以对租赁人和汽车进行管理。项目包含：客户管理、业务管理、系统管理、汽车管理、租赁人管理等模块。项目中还包含了完善的权限管理相关功能。
技术架构： Spring、SpringMVC、MyBatis、MyBatisPlus、移动支付、短信验证、RBAC、EasyUI、POI、百度chart
项目亮点： 完善的页面资源；汽车租赁业务全部实现；概括能力强。包含了所学的全部技术
3、至尊智能家居 项目介绍： 智能家居随着互联网和物联网的发展逐渐走进千家万户。智能家居的企业和工厂越来越多。至尊智能家居是智能家居企业进行综合管理的内部系统。可以实现智能家居管理、人事行政管理、系统公告、知识管理、任务管理、销售管理、项目管理、统计分析、系统设置、产品资料管理等功能。
技术架构： Spring Boot、SpringMVC、MyBatis、Druid、Logback、Quartz、Shiro、Swagger2、Linux、BootStrap
项目亮点： 使用快速开发框架，真实感受最初进入企业的感觉；小组项目，完全模拟企业项目组开发中如何进行配合；Linux服务器，不仅仅是开发项目，还包含了部署项目
4、百战商城 项目介绍： 百战商城项目是一个大型综合性的B2C平台。完全采用SOA模式架构，使用Dubbo实现服务调用。基于高并发、海量数据环境进行实现。
百战商城分为前后台两套系统。后台系统使用FastDFS实现分布式文件存储主要负责商品管理，商品分类管理，CMS等内容。前台系统使用Redis实现缓存数据查询包含首页服务，搜索服务，单点登录服务、购物车服务，订单服务等。
技术架构： Spring Boot、Spring MVC、MyBatis、Zookeeper、Dubbo、Redis、Solr、RabbitMQ、FastDFS、Nginx、Spring Security、Spring Session、MyBatis Plus、MyCat
项目亮点： 真实大型互联网项目呈现；SOA架构；高并发解决方案；RabbitMQ实现流量削峰和异步消息；使用Solr实现海量数据搜索；Redis缓存穿透、缓存雪崩、缓存击穿解决方案；基于Linux平台部署该项目，企业真实服务器环境；Nginx服务代理、负载均衡；使用Navicat做数据库分库分表及读写分离；FastDFS分布式文件存储；Spring Security 完成权限验证；Spring Session 分布式Session
5、Livegoods房源租赁海选平台 项目介绍： 本项目为前后端分离项目，移动客户端为其平台。作为互联网时代房屋平台，Livegoods拥有完善的房屋租赁资源搜索能力，可以根据城市定位，精确高效的搜索到需要的租赁房源信息。本系统分为租客平台、业主平台、用户管理平台两大功能平台。
技术架构： SpringBoot、SpringMVC、MyBatis、SpringDataMongoDB、SpringData、ElasticSearch、MongoDB、Spring Cloud、ElasticSearch、FastDFS、Nginx、支付
项目亮点： 前后端分离项目，感受目前企业开发最主流的前后端分离开发模式；移动端项目，可以感受Java程序员开发app服务端的实现过程；微服务架构；秒杀系统实现；海量数据搜索；镜像和云
6、数字货币交易所项目 项目介绍： 开源数字货币交易所，基于Java开发的比特币交易所,包含BTC交易所、ETH交易所、数字货币交易所、交易平台、撮合交易引擎等核心模块。项目技术采用业界最流行、社区非常活跃的开源组件Spring Cloud Alibaba来构建我们的交易系统，是行业第一家基于Alibaba技术的大型项目，也是Spring Cloud的最佳实践之一。
项目架构： 后端技术：Spring Cloud Alibaba + Spring Boot + Mybatis Plus + Elasticsearch + Kafka + Mongodb + Zookeeper + RocketMQ + OAuth2、0 + Jwt + Redis + Hutool + Orika + Fst + Swagger-ui + Mycat + Docker + ECS + OSS + 腾讯防水墙
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f500d03c763aa4a58f8c0a98882bf04/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0a2b6c7462c28551c2241b48a4b21dc/" rel="bookmark">
			Ubuntu如何开启SSH服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一次使用SSH服务，因为没有及时记录开启SSH服务的过程，在后来因为系统被我玩崩了，快照之前的系统，导致SSH无法开启，也忘记了如何开启SSH服务，现在将开启过程记录如下，以便查看。
使用的的ubuntu16.0.4LTS系统。
在开启服务之前，其实可以不用考虑本机有没有安装SSH服务，直接安装，但是为了更好的了解过程，一步一步的去开启更好。
1、先试着开启SSH服务
在使用SSH之前，可以先检查SSH服务有没有开启。使用命令：sudo ps -e | grep ssh来查看，如果返回的结果是“xxxx? 00:00:00 sshd”,代表服务开启。那个四个x代表四位数字，每台机数字不一样的，如图：
如果没有反应或者其他结果，再试着开启SSH服务。使用命令sudo /etc/init.d/ssh start来开启服务，如图：
如果是图中结果，说明没有安装SSH服务，此时需要安装 SSH服务，为了能提高安装成功率，建议先更新源：sudo apt-get update更新安装源，如图：
然后安装SSH服务，使用命令：sudo apt-get install openssh-server。如图：
等待安装结束即可。然后再次查看服务有没有启动：sudo ps -e | grep ssh：
有sshd那个东西，说明服务启动了，如果需要再次确认或者没有图中的结果，使用命令来启动:sudo /etc/init.d/ssh start:
看到服务starting了，服务成功开启。另外，还有几条命令需要记住：
sudo service ssh status 查看服务状态：
sudo service ssh stop 关闭服务：
sudo service ssh restart 重启服务
以上是关于如何安装并启动服务的过程。
下面介绍使用ssh客户端远程登录linux系统。本人使用的是win7，登录虚拟机的ubuntu linux。
在查看ip之前，有个地方需要注意一下，当虚拟机设置的linux网络连接方式是仅主机模式时，对应宿主机的虚拟网卡1：WMware Network Adapter VMnet1，
当虚拟机设置的是NAT模式时，对应宿主机的虚拟网卡8：WMware Network Adapter VMnet8，使用桥接模式时，是和宿主机同一个网卡。如图：
知道了这些，当查看linux的ip后，把对应的宿主机虚拟网卡ip设置同一网段即可：
然后ping测试网络是否畅通：
测试通过，然后使用SSH客户端登远程登录linux。前提是已经下载好了ssh客户端，我用的是putty:
个人感觉这款工具体验并不太好，但为什么我在使用，并且在使用之前还被它给教做人，费了老大劲，原因是我就是跟它杠上了，我就不信搞不了它，于是最终我教它怎样做一个乖乖的做一个远程工具。
运行它：在 Host Name(or address)栏输入远程登录的主机的ip，端口号默认22，一般还是查一下，之前介绍的查看SSH服务时说了可以查看服务状态，里面有端口号：
接着Connection type为SSH，下面的Saved Sesssions填写远程登录主机主机名就好，还有一个字体编码，在左侧栏window里的Translation中Receives date……，下拉选择utf-8。如图：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0a2b6c7462c28551c2241b48a4b21dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e35faea461ed65af899d661fc6a8612/" rel="bookmark">
			Springboot Mybatis使用pageHelper实现分页查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以下介绍实战中数据库框架使用的是mybatis，对整合mybatis此处不做介绍。
使用pageHelper实现分页查询其实非常简单，共两步：
一、导入依赖；
二、添加配置；
那么开始，
第一步：
pom.xml添加依赖：
&lt;!--分页插件 pagehelper --&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt; &lt;!-- 特别注意版本问题 --&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;/dependency&gt;&lt;/dependency&gt; 第二步：
aplication.yml添加配置：
#分页pageHelper pagehelper: helper-dialect: mysql reasonable: true support-methods-arguments: true ·helper-dialect:
配置使用哪种数据库语言，不配置的话pageHelper也会自动检测
·reasonable:
配置分页参数合理化功能，默认是false。 #启用合理化时，如果pageNum&lt;1会查询第一页，如果pageNum&gt;总页数会查询最后一页； #禁用合理化时，如果pageNum&lt;1或pageNum&gt;总页数会返回空数据。
·params:
为了支持startPage(Object params)方法，增加了该参数来配置参数映射，用于从对象中根据属性名取值; 可以配置 pageNum,pageSize,count,pageSizeZero,reasonable，不配置映射的用默认值， 默认值为pageNum=pageNum;pageSize=pageSize;count=countSql;reasonable=reasonable;pageSizeZero=pageSizeZero。
·support-methods-arguments:
支持通过Mapper接口参数来传递分页参数，默认值false，分页插件会从查询方法的参数值中，自动根据上面 params 配置的字段中取值，查找到合适的值时就会自动分页。
第三步，
先将需要查询的数据库表建起来，简单填充数据：
然后mapper层写上查询该表数据返回List的方法：
//查询所有 List&lt;User&gt; queryUserInfo(); 在service以及impl也写上相关方法：
//查询所有 List&lt;User&gt; queryUserInfo(); @Override public List&lt;User&gt; queryUserInfo() { return userMapper.queryUserInfo(); } 相关的mapper.xml就不做过多介绍了，就是一个查询。
ok，接下来开始使用分页插件，配合上面的查询实现分页查询：
在userService上添加 分页查询方法2个：
List&lt;User&gt; findAllUserByPageF(int pageNum,int pageSize); PageInfo&lt;User&gt; findAllUserByPageS(int pageNum, int pageSize); userServiceImpl上添加 分页查询实现：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e35faea461ed65af899d661fc6a8612/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03fbfc44e2845bbf1ddd3e03f13d1f01/" rel="bookmark">
			API网关是什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 省流总结： API网关是客户端与服务端之间的桥梁， 服务端一般是多个微服务组成，用户发出一个请求，API网关分发给各个微服务，汇聚结果后返回给用户。 一、是什么？ 是后端服务或数据连接的流量管理器 二、干什么的？ 针对 API 调用应用策略、身份验证和一般访问控制来保护有价值的数据API 网关是您控制对后端系统和服务的访问的方式，并且它旨在优化外部客户端和后端服务之间的通信 三、怎么做的？ 它负责将请求路由到相应的服务，然后向请求者发送回复API 网关在您的数据和 API 之间维护安全连接，并管理您公司内外的 API 流量和请求，包括负载均衡API 网关接收来自客户端的所有 API 调用，并利用请求路由、合成和协议转换将它们路由到正确的微服务。 四、使用API网关的原因： 因为它能够调用多个后端服务并聚合结果客户不必为每项服务发送请求，而是可以将请求发送到 API 网关，然后由 API 网关将请求传递给相关服务API 网关还可以为每个客户端公开不同的 API，这在当今不断变化的环境中是必不可少的今天，大多数企业 API 都是使用网关进行部署的由于微服务使用的增加，API 网关的使用也越来越多， 微服务允许将应用程序解构为几个松散耦合的服务，因为每个微服务都需要自己的功能。微服务使开发、部署和维护应用程序的不同功能变得更加容易，但它们也会使客户更难以快速、安全地访问应用程序。API 网关是此问题的解决方案。网关不是让客户单独请求访问每项微服务，而是请求的单一入口点，它将请求分配给相应的服务，收集结果并将其传递给请求者。API 网关作为连接您的客户与服务的主要代理，该网关支持重要的管理和安全功能，包括身份验证、指标收集、输入验证和响应转换。 五、几点作用： 身份验证： 这样即使客户需要从多个服务访问数据，他们也只需在网关上进行一次身份验证，这可以减少延迟，并确保身份验证过程在整个应用程序中保持一致网关可以使用众多开放标准之一来确定消费者的身份或有效性（即 OAuth、JWT 令牌、API 密匙、HTTP BasIC/ 摘要、SAML 等），也可以使用非标准方法在消息标头或有效负载中查找凭据。API 网关还可以调用其他系统来验证身份，就像警方可以访问犯罪数据库一样API 网关还可以检查传入的 API 消费者中的威胁。他们可以使用 API 防火墙、内容验证和消息完整性检查，包括确定 API 是否被篡改。API 网关还可以将传入 API 的风险评估委派给第三方应用程序，以便作出决定指标收集： 由于所有请求都通过 API 网关，因此它是收集数据分析的理想场所。 例如，API 网关可以测量用户正在发出的请求数量或向每个微服务转发的请求数量API 网关也可用于限制请求。如果用户发送的请求过多，则可以对网关进行编程以拒绝请求，而不是将它们传递给其中一个微服务。输入验证 输入验证是 API 网关，确保所有客户请求都包含完成请求所需的信息，并以正确的格式提供。如果出现差错，网关将拒绝该请求。如果包含所有必要信息，网关将请求路由到负责检索请求信息的微服务。响应转换 响应转换是 API 网关的重要功能。它充当信息的 “转换者”。其中一些数据需要安全保护，然后才能响应外部用户的类似请求，这是网关的工作。 六、优势： 将微服务打包在一起并通过 API 网关访问，可以安全、更快、更轻松地访问您的服务。 通过单一界面方法使您的 API 和后端系统更加安全使用安全和访问控制、限制、路由、中介和 SLA 管理的可扩展策略，让您完全控制 API 执行环境。为您的服务和应用程序用户编写更简单的代码由于来回电话减少，随时间推移，延迟也减少更快、更轻松地访问所有微服务减少每个微服务或负载平衡的工作负载全面的指标收集 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9670e0f259ea2f0359bb26f0bf734deb/" rel="bookmark">
			前端常用知识点总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		html,js等前端相关知识点总结 文章目录 html,js等前端相关知识点总结前言一、简介1.html2.javascript3.css 二、常用知识点1.HTML1.html5文档（基本格式）2.html常用标签 2.js1.js表单验证2.js通过id获取值2.js通过id改变 HTML 内容3.jq通过id获取值 总结 前言 前端即网站前台部分，运行在浏览器上展现给用户浏览的网页。web前端就是利用三大核心 即 html，css，JavaScript分别是网页控件、美化控件代码、增强表现力的脚本语言等技术实现。
一、简介 1.html HTML的全称为超文本标记语言，是一种标记语言。它包括一系列标签，通过这些标签可以将网络上的文档格式统一，使分散的Internet资源连接为一个逻辑整体。HTML文本是由HTML命令组成的描述性文本，HTML命令可以说明文字，图形、动画、声音、表格、链接等。
2.javascript JavaScript 简称“JS” 是一种具有函数优先的轻量级，解释型或即时编译型的编程语言。虽然它是作为开发Web页面的脚本语言而出名，但是它也被用到了很多非浏览器环境中，JavaScript基于原型编程、多范式的动态脚本语言，并且支持面向对象、命令式、声明式、函数式编程范式。
3.css 层叠样式表(英文全称：Cascading Style Sheets)是一种用来表现HTML（标准通用标记语言的一个应用）或XML（标准通用标记语言的一个子集）等文件样式的计算机语言。CSS不仅可以静态地修饰网页，还可以配合各种脚本语言动态地对网页各元素进行格式化。
CSS 能够对网页中元素位置的排版进行像素级精确控制，支持几乎所有的字体字号样式，拥有对网页对象和模型样式编辑的能力。
二、常用知识点 1.HTML 1.html5文档（基本格式） 代码如下（示例）：
&lt;!DOCTYPE html&gt; &lt;-- 声明为 HTML5 文档--&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;标题&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 文档内容.. &lt;/body&gt; &lt;/html&gt; 2.html常用标签 标签描述基础&lt;!DOCTYPE&gt;定义文档类型。&lt; html&gt;定义一个 HTML 文档。&lt; title&gt;为文档定义一个标题。&lt; body&gt;定义文档的主体。&lt; h1&gt; - &lt; h6&gt;定义 HTML 标题。&lt; p&gt;定义一个段落。&lt; br&gt;定义简单的折行(换行)。&lt; hr&gt;定义水平线。&lt;! --&gt;定义一个注释。格式&lt; b&gt;定义粗体文本。&lt; abbr&gt;定义一个缩写。&lt; em&gt;定义强调文本。&lt; i&gt;定义斜体文本。&lt; s&gt;定义加删除线的文本。&lt; strong&gt;定义语气更为强烈的强调文本。&lt; sub&gt;定义下标文本。&lt; sup&gt;定义上标文本。&lt; time&gt;定义一个日期/时间&lt; u&gt;定义下划线文本。表单&lt; form&gt;定义一个 HTML 表单，用于用户输入。&lt; input&gt;定义一个输入控件。&lt; textarea&gt;定义多行的文本输入控件。&lt; button&gt;定义按钮。&lt; select&gt;定义选择列表（下拉列表）。&lt; optgroup&gt;定义选择列表中相关选项的组合。&lt; option&gt;定义选择列表中的选项。&lt; label&gt;定义 input 元素的标注。&lt; fieldset&gt;定义围绕表单中元素的边框。&lt; legend&gt;定义 fieldset 元素的标题。&lt; datalist&gt;规定了 input 元素可能的选项列表。&lt; keygen&gt;规定用于表单的密钥对生成器字段。&lt; output&gt;定义一个计算的结果。框架&lt; iframe&gt;定义内联框架。图像&lt; img&gt;定义图像。&lt; map&gt;定义图像映射。&lt; area&gt;定义图像地图内部的区域。链接&lt; a&gt;定义一个链接&lt; link&gt;定义文档与外部资源的关系。&lt; main&gt;定义文档的主体部分。&lt; nav&gt;定义导航链接。列表&lt; ul&gt;定义一个无序列表。&lt; ol&gt;定义一个有序列表。&lt; li&gt;定义一个列表项。&lt; dl&gt;定义一个定义列表。&lt; dt&gt;定义一个定义定义列表中的项目。&lt; dd&gt;定义定义列表中项目的描述。&lt; menu&gt;定义菜单列表。表格&lt; table&gt;定义一个表格。&lt; caption&gt;定义表格标题。&lt; th&gt;定义表格中的表头单元格。&lt; tr&gt;定义表格中的行。&lt; td&gt;定义表格中的单元。&lt; thead&gt;定义表格中的表头内容。&lt; tbody&gt;定义表格中的主体内容。&lt; tfoot&gt;定义表格中的表注内容（脚注）。&lt; col&gt;定义表格中一个或多个列的属性值。&lt; colgroup&gt;定义表格中供格式化的列组。样式/节&lt; style&gt;定义文档的样式信息。&lt; div&gt;定义文档中的节。&lt; span&gt;定义文档中的节。 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9670e0f259ea2f0359bb26f0bf734deb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2129d893e0d7ddb4a716e6514c2f586e/" rel="bookmark">
			麻雀搜索算法优化BP神经网络预测以及MATLAB代码实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		麻雀搜索算法SSA优化BP神经网络回归预测以及MATLAB代码实现 文章目录 麻雀搜索算法SSA优化BP神经网络回归预测以及MATLAB代码实现1. 麻雀搜索算法SSA原理1.1 算法灵感来源1.2 算法模型描述 2. SSA优化BP神经网络预测算法流程3. SSA优化BP回归预测的MATLAB实现步骤4. 运行结果与图像5. MATLAB代码 1. 麻雀搜索算法SSA原理 麻雀搜索算法是一种较新的智能优化算法，在2020年提出，主要是受麻雀的觅食行为和反捕食行为的启发。算法具有较高的收敛性能与局部搜索能力。
1.1 算法灵感来源 麻雀种群在觅食过程中分为发现者与加入者两部分，分别负责提供种群觅食的方向以及追随并获取食物。当麻雀种群意识到危险时，则会发生反捕食行为并更新种群位置。
1.2 算法模型描述 关于麻雀搜索算法，建立了六个假设规则，在参考文献中给出，故不作说明。
符号说明
N：最大迭代次数 n：种群大小 PD：发现者数量 SD 感应危险的麻雀数量
ST：安全值 R2：预警值（由随机数产生）
算法实现步骤
步骤一：初始化麻雀种群位置与适应度，N，n，PD，SD，ST参数初值。
步骤二：开始循环，iteration&lt;N
步骤三：种群排序，得出当前的最优麻雀个体位置，以及最佳适应度值。（注意对于第一代麻雀而言，求出的为初始最优。最优个体能够优先获取食物）
步骤四：觅食行为，a). 按以下公式更新发现者位置。
X i , j t + 1 = { X i , j t ⋅ exp ⁡ ( − i a ⋅ N ) if R 2 &lt; S T X i , j t + Q ⋅ L if R 2 ≥ S T X_{i, j}^{t+1}=\left\{\begin{array}{ll} X_{i, j}^{t} \cdot \exp \left(\frac{-i}{a \cdot N}\right) &amp; \text { if } R_{2}&lt;S T \\ X_{i, j}^{t}+Q \cdot L &amp; \text { if } R_{2} \geq S T \end{array}\right.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2129d893e0d7ddb4a716e6514c2f586e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd60b271a4132144a63d95193ad075d5/" rel="bookmark">
			【数据结构】详解空间复杂度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Yan英杰的博客
悟已往之不谏 知来者之可追
目录
空间复杂度
​案例1:计算BubbleSort的空间复杂度？ 案例2:计算斐波那契额数列的前N项的空间复杂度
案例3:计算阶乘递归Fac的空间复杂度？
案例4:F1和F2两函数是否使用的同一块空间
案例5:计算该程序的空间复杂度
案例6:经典OJ(难度中等)
空间复杂度 空间复杂度也是一个数学表达式，是对一个算法在运行过程中临时占用存储空间大小的量度 。 空间复杂度计算规则基本跟实践复杂度类似，也使用大O渐进表示法。 注意：函数运行时所需要的栈空间(存储参数、局部变量、一些寄存器信息等)在编译期间已经确定好了，因此空间复杂度主要通过函数在运行时候显式申请的额外空间来确定。 案例1:计算BubbleSort的空间复杂度？ // 1.计算BubbleSort的空间复杂度？ void BubbleSort(int* a, int n) { assert(a); for (size_t end = n; end &gt; 0; --end) { int exchange = 0; for (size_t i = 1; i &lt; end; ++i) { if (a[i - 1] &gt; a[i]) { Swap(&amp;a[i - 1], &amp;a[i]); exchange = 1; } } if (exchange == 0) break; } } 分析: 注： 空间复杂度本质是:计算因为程序导致额外开辟的空间个数 此时，该程序额外开辟了，三个变量，end exchange i，又因为空间复杂度同样使用的是大O表达式，所以我们由此得出，空间复杂度为O(N) 提问:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd60b271a4132144a63d95193ad075d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68d21a6a595ff6d1f202344dca757496/" rel="bookmark">
			vue 自定义鼠标样式为指定图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 cursor: url('../../../public/static/img/map/draw1.png'),auto; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68f1966f158ea77ec4496ae47f4b3870/" rel="bookmark">
			C&#43;&#43;: Log 日志系统（依赖库：Log4Cplus）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、简介 日志系统几乎是每一个实际的软件项目从开发、测试到交付，再到后期的维护过程中极为重要的查看软件代码运行流程、还原错误现场、记录运行错误位置及上下文等的重要依据。一个高性能的日志系统，能够准确记录重要的变量信息，同时又没有冗余的打印导致日志文件记录无效的数据。
日志，可以记录每一时刻软件的运行情况，记录 error 或者 crash 时的信息（时间、关键变量的值、出错位置、线程等）；另一方面，对于概率性 error 事件，可以在重复测试时通过日志来查询错误复现时候的情况。
日志是跟踪和回忆某时刻或者时间段内的程序行为进而定位问题的一种手段。
2、系统设计 软件运行过程中，需要记录的有什么呢？前述已经提到，关键变量的值、运行的位置（哪个文件、哪个函数、处在哪一行）、时间、线程号、进程号、自定义提示信息。
2.1 log 设计 2.1.1 log 级别 Log 级别是什么意思呢？
开发阶段，想尽可能详细地跟踪代码运行过程，可以打印尽可能多的信息到日志文件中；
产品交付客户使用时，为了软件运行更快、客户体验更好，这时候就只需打印关键信息到日志文件了，因为过多的写文件会耗费大量时间，影响软件运行速度。
故而为 LOG 类定义了如下级别：
enum LOGLEVEL { LOG_LEVEL_ALL = 0, LOG_LEVEL_TRACE, LOG_LEVEL_DEBUG, LOG_LEVEL_INFO, LOG_LEVEL_WARN, LOG_LEVEL_ERROR, LOG_LEVEL_FATAL, LOG_LEVEL_OFF, LOG_LEVEL_COUNT } 在软件设计中，可以通过某些方法或者预留一些开关来设置 Log 级别，方便在开发、调试、测试和客户现场灵活地调整日志级别，以获取到有用的日志信息。
2.1.2 log 输出位置 Log 文件可以输出到控制台，也可以输出到指定路径下的某个文件里，也可能有别的需求。比如，开发或调试时，简单的信息直接就打印到软件某个界面上；测试或者交付客户时，最好将日志保存到文件里，这样可以保存尽可能多的信息。因此，进行了如下设计：
enum LOGTARGET { LOG_TARGET_NONE = 0x00, LOG_TARGET_CONSOLE = 0x01, LOG_TARGET_FILE = 0x10 }; 2.1.3 log 作用域 一个软件系统，要在哪儿输出日志呢？只要是你想打印日志的地方，任何一个函数、任何一个文件，都应该而且必须可以打印。也就是说这个 log 类的对象（不妨叫做日志记录器）是全局的。
光是全局就够了吗？你这个文件里有一个全局的日志记录器，输出日志到 file.log 文件里；另一个文件里也有一个日志记录器，也输出到 file.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/68f1966f158ea77ec4496ae47f4b3870/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2f394ea1d354d80cf54f2b3b7a11249/" rel="bookmark">
			C&#43;&#43; : XML 文件解析（依赖库：TinyXml）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		XML 可扩展标记语言（eXtensible Markup Language）。
被设计用来传输和存储数据，不用于表现和展示数据，HTML 则用来表现数据；
独立于软件和硬件的信息传输工具；
主要用到的有可扩展标记语言、可扩展样式语言（XSL）、XBRL和XPath等；
没有预定义，需要自定义标签。
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;!-- 声明 --&gt; &lt;site&gt; &lt;!-- 开始标签 --&gt; &lt;name&gt;RUNOOB&lt;/name&gt; &lt;url&gt;https://www.runoob.com&lt;/url&gt; &lt;logo&gt;runoob-logo.png&lt;/logo&gt; &lt;desc&gt;编程学习网站&lt;/desc&gt; &lt;/site&gt; &lt;!-- 结束标签 --&gt; 用途 通过读取 xml 更新网页数据内容，把数据从 HTML 分离；
以纯文本格式进行存储，简化数据共享；
较好的兼容性，简化了数据传输和平台变更；
树结构 &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;note&gt; &lt;!-- 根元素 --&gt; &lt;to&gt;Tove&lt;/to&gt; &lt;!-- 子元素 --&gt; &lt;from&gt;Jani&lt;/from&gt; &lt;heading&gt;Reminder&lt;/heading&gt; &lt;body&gt;Don't forget me this weekend!&lt;/body&gt; &lt;/note&gt; 必须包含根元素。该元素是所有其他元素的父元素；
所有的元素都可以有文本内容和属性。
语法 声明 &lt;?xml version="1.0" encoding="utf-8"?&gt; 标签 所有的 XML 元素都必须有一个关闭标签 &lt;p&gt;This is a paragraph.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2f394ea1d354d80cf54f2b3b7a11249/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8eac44e73fd0654599272a377c9ed22f/" rel="bookmark">
			2023最新版IDEA创建一个SpringBoot项目 (详细教程)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在IDEA中创建一个SpringBoot项目 springboot是我们java开发中最流行的框架之一，下面我们看看如何在idea中创建一个springboot项目。
文章目录 在IDEA中创建一个SpringBoot项目一、springboot简单介绍二、快速开始1.新建项目2.配置Maven3.测试 总结 一、springboot简单介绍 Spring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。
话不多说直接上教程！
二、快速开始 1.新建项目 1.打开IDEA选择 File-&gt;New-&gt;Project；
如下：
2.选择 Spring Initializr
Spring initializr 是Spring 官方提供的一个用来初始化一个Spring boot 项目的工具。
组名项目名称可自定义
如下：
3.选择Dependencies
Web下面选择Spring Web;
Template Englines下面选择Thymeleaf模板；
SQL下面选择MySQL Driver，JDBC API 和 MyBatis Framework；点击Create
如下：
等待项目创建。
完整目录结构
如下：
2.配置Maven 1.点击右侧的Maven，点击设置，选择Maven Settings进行项目Maven仓库的配置。
如下：
2.勾选上Override,然后选择本地Maven的配置文件，它会根据配置文件自动找到本地仓库位置；
3.测试 1.修改配置文件application.properties为application.yml，配置一下启动端口,默认8080。
如下：
server: port: 8080 2.编写一个控制器–&gt;新建一个test包新建一个index类.添加@Controller注解。
如下：
3.在index里编写index方法
如下：
注意：@RestController = @Controller + @ResponseBody 返回值的数据自动封装为json的数据格式
@RequestMapping ：处理请求地址映射的注解
@Controller public class index { @RequestMapping("/index") @ResponseBody public String index(){ return "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8eac44e73fd0654599272a377c9ed22f/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/147/">«</a>
	<span class="pagination__item pagination__item--current">148/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/149/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>