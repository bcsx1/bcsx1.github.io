<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b3404b961b9978672ea82420be27d5a/" rel="bookmark">
			益聚星荣:微信、抖音、微博都出手了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		日前，中央网信办发布《关于进一步加强娱乐明星网上信息规范相关工作的通知》(下称《通知》)。
近日，微博、抖音、微信等相继发布公告称，将按照《通知》要求，对文娱明星等内容进一步规范。
微信
11月24日，微信安全中心订阅号“微信110”发布公告称，微信平台将进一步规范娱乐明星信息的网上呈现。
抖音
11月24日，抖音安全中心微信公众号发布公告称，抖音将在“饭圈”乱象专项整治的工作基础上，对娱乐明星类内容做进一步的规范管理，严把内容导向，规范信息呈现，加强账号管理，强化舆情监测处置机制，建立文娱领域综合治理的长效机制。
抖音将从娱乐明星内容负面清单入手，完善涉娱乐明星演艺作品类、个人动态类、商业活动类、公告类、公益类、权威发布类等6类信息呈现规则，深化细化文娱领域相关账号在名称信息、分级管控、联合惩戒、注册认证等方面的治理细则，健全涉娱乐明星网上热点舆情的监测处置机制，坚决打击泛娱乐化倾向、低俗炒作现象，抵制流量至上、畸形审美、“饭圈”乱象等不良文化，坚持健康格调品位。
抖音一直致力于打造安全、健康、绿色的网络生态环境，在此呼吁娱乐明星一道为用户提供更优质、健康的内容，为青少年树立阳光、正面的榜样力量。我们也希望与广大网友一起共同维护健康文明的网络空间。
微博
11月23日，新浪微博社区管理官方微博公告称，自5月以来，微博持续推进“清朗”饭圈整治行动，取得明显成效。下一步，微博将积极贯彻落实《通知》有关要求，全面夯实治理成果，在文娱内容生态治理、热搜榜规则等方面与《通知》精神全面对齐。大力支持弘扬社会主义核心价值观，体现健康格调品位的文娱内容。也请广大网友积极参与、广泛监督，共同建设清朗网络空间。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8c589364e7111cabffe79279b02bf6e/" rel="bookmark">
			诚之和:自嗨锅能颠覆海底捞吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为了避免独自外出就食的尴尬，实现独乐乐的满足感，催生了“一人食经济”。
2015年，自热火锅横空出世，一经面世就迅速在自热方便类食品中占据一席之地，特别受到年轻人的青睐，九成以上的消费者年龄在40岁以下。
自热火锅以其新潮、便利等优势备受消费者欢迎。近五年来，市场规模出现井喷式增长（见图1），复合增长率为111%。随着疫情的发生，满足社交隔离、又能饱腹的方便类食品更是受到宅家一族的追捧，自热火锅成为超市里的“断货王”，2020年市场规模接近100亿。
随着市场风口的到来，自热火锅受到了诸多资本的关注。目前市场出现了三方鼎立的局势，传统火锅企业如海底捞、小龙坎等纷纷入局，他们拥有扎实的品牌优势，本生就具有强势的口碑；而像良品铺子、三只松鼠等零食制造商，也扩充产品品类至自热火锅，他们具备渠道优势，可以直达消费者；第三方就是以自热产品起家的新兴品牌，如自嗨锅、莫小仙等，在没有供应商和渠道优势的情况下，大多以代工的方式快速发展，标新立异成为新兴品牌的一把尖刀，吸引眼球、获取流量是可快速复制的晋升之路。
自热火锅市场的前景
为了迎合上班族、学生族等消费群体的快节奏需求，懒人经济乘风而起，方便类食品市场规模也不断扩大，近五年复合增速为6%（见图2）。方便食品主要包括四大品类：方便面、速冻食品、微波食品、自热食品。自热食品进入市场的时间最短，目前处于成长期，仍有广阔的市场空间可以攻掠，自热火锅已成为自热食品中的佼佼者。
自热小火锅不仅食材丰富、色香俱佳、营养多样（见图3），而且摆脱了像方便面这样冲泡类的食品对于热水的依赖，随时随地可以随心享用；与此同时，方便面是油炸压缩而成，不符合现代消费者对于健康的要求，甚至被打上了“垃圾食品”的标签。单纯地追求廉价、方便的时代已经过去，追求健康、品质成为新的标准，因此自热火锅具有对冲泡类食品的替代作用。
自热火锅作为新型消费的典型，可以享受站上流量风口的红利，通过大规模宣传影响消费者心智，采用明星代言、创意广告、节目冠名、网红带货等方式大获流量，刺激消费者的购买欲望，从而带动产品的销量上升，B站、小红书、抖音、快手等各类新渠道媒体也能频繁看到自热产品的身影。自嗨锅从2018年初上市，就是以“半个娱乐圈都在吃”的宣传迅速占领市场，上市三个季度就突破亿元的销售规模。
自热火锅当前山头林立，其中海底捞、自嗨锅、莫小仙位居前三，合计占市场份额的三分之一。长远来看，具有品牌优势的头部企业会充分发挥马太效应，逐步扩大市场份额。
与此同时，自热火锅只是自热食品的冰山一角。既然火锅都能随时随地食用，其他食物也可以照板煮碗，市场上的产品已经包括麻辣烫、米饭、烧烤、螺蛳粉、酸菜鱼、面条等等。像自嗨锅以自热火锅起家，现在已经开始设计研发并上市了多个其他品类，如刚上市15天就荣登销量第一的“画面”系列，就是主打面食。
自热火锅行业的近忧
行业的快速扩张是个机遇，但同时滋生出的隐忧也不可忽视。
一．食品安全与健康
当前，自热火锅的众多中小品牌不具备自建工厂的能力和时间，在效率就是生命的新经济下，大多通过代工厂生产，因此品牌和产品之间，夹着一个代工厂，从而难以对产品质量进行有效把控。为了保留食材的原汁原味，常规包装下，食材的新鲜度就会下降，进而可能存在安全隐患。从对市场的调研可以看出（见图4），消费者对于自热火锅的担忧主要来源于安全与健康。
与此同时，自热食品是通过发热包，就能随时随地给食物加热。而发热包的安全性问题也降低了消费者的热情，操作不当很有可能会引发燃爆，而烫伤食用者、溅射入食物等现象也偶有发生。
现如今，消费的水准不断提高，除满足口腹之欲外，消费者对于食品品质的要求也与日俱增，因此低劣的产品必将被淘汰。
二．政策监管有待完善
自热食品市场爆发式增长可能会引来政策监管，当前相关行业安全标准尚未确立，导致很多原材料和制作工艺都存在一定的不确定风险。在无标准游戏规则的情况下，行业难免参差不齐，进而影响消费者的体验，只有行业进入规范的赛道，才能打开更广阔的空间。
三．竞争日趋激烈
自热火锅自问世以来，快速发展，目前市面上已经至少有350多个自热火锅品牌，竞争格局分散。自热火锅的毛利率很高，大部分的自热产品都是依托于代工厂，而自热火锅上游可选的代工厂众多，因此中游火锅品牌企业选择余地大、议价能力强，平均利润率可达25%左右。加之技术壁垒很低，很容易吸引更多的企业和资本涌入，因此竞争的程度未来可能会更加激烈。
自嗨锅：从网红向长红的奔跑
自嗨锅可以算是自热火锅赛道的一匹黑马，在短短的两年内快速完成五轮融资，目前还未上市，估值已经超过十亿美金。2018年第一款产品上市后，三个季度实现销售破亿，2019年销售额接近8亿元，2020年超过10亿。
在一众新锐和老牌火锅企业的夹击之下，自嗨锅杀出一条血路，成为现象级网红产品。是昙花一现，还是突破长红？这是个问题。
爆款来得快，可能去得也快。自嗨锅虽然方便，但与传统火锅相比，确实不可同日而语。不少消费者就是为了跟随时尚，抱着尝鲜的态度购买，因此复购率可能并不乐观。如果消费者出现审美疲劳，那么市场上多如牛毛的自热产品都有可能成为下一个自嗨锅。
品类多元化、保持新鲜感、实行差异化，是企业长期屹立于快消市场的不二法门。
为了摆脱自嗨锅就是自热火锅的固有形象，自嗨锅更名为“自嗨锅出品”，因为除了自热火锅外，自嗨锅旗下还有画面、臭臭螺等新品。从新产品“画面”，能够看出自嗨锅披荆斩棘的努力。
自嗨锅原先和绝大部分的自热火锅企业一样，依托其他代工厂加工。而从新产品“画面”开始，自嗨锅做出了与众不同的新尝试。为了更好地保留传统面食的风味，自嗨锅在中华面食发源地河南自建工厂。虽然自建工厂需要大量的前期资本投入，且面临着产品快速迭代对生产线的压力，但是能更好地把握产品质量，从而可以避免上文所述的自热火锅行业的短板：安全与品质问题。从长期来看，上下游协同能够降本增效，而依赖代加工就显得短视了。
如果摆脱代工厂，就有可能摆脱同质化竞争，因为想象力再丰富、创新能力再强，相应的代工生产线也不能及时做出变化。
自嗨锅如果能够实现自动化、科技化生产，就可以进一步提升制作工艺和产品的迭代速度，因此这是一个不错的尝试。
除了在味觉上推陈出新外，自嗨锅还在视觉上打造全新体验，发掘一批新锐的年轻设计师，把他们的作品印在“画面”的产品包装上，并保留了设计师的名字，从而形成自己独特、而前卫的品牌标识。
自嗨锅一路高歌猛进，看似风光无两，但要摆脱网红包袱，道阻且长。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69a4b283d223b6822e845529bfce1ec3/" rel="bookmark">
			C# wpf 无边框窗口实现拖动调整大小
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		WPF拖动改变大小系列 第一节 Grid内控件拖动调整大小
第二节 Canvas内控件拖动调整大小
第三节 窗口拖动调整大小（本节）
第四节 附加属性实现拖动调整大小
文章目录 WPF拖动改变大小系列前言一、如何实现？1.继承Adorner2.使用Thumb3.实现拖动逻辑 二、完整代码三、使用示例总结 前言 在《C# wpf Grid中实现控件拖动调整大小》中我们实现了Grid中的控件动态调整大小，对于自定义的无边框窗口也可以使用类似的方式实现。虽然能查到的方案有通过Window Api的和通过WindowChrome实现的，一个是对系统有依赖还一个是依赖.net版本，这里提供一种相对轻量的实现方法。
一、如何实现？ 1.继承Adorner 通过装饰器的方式添加8个方位拖动区域在窗口上，这样既可以不影响控件布局，又可以自由摆放8个拖动控件。通过重写方法，给装饰添加控件。必要的重写的方法如下面示例所示：
public class WindowResizeAdorner : Adorner { //获取装饰器的元素个数 protected override Visual GetVisualChild(int index); //指定装饰器子元素个数 protected override int VisualChildrenCount{get;} //布局，添加的子元素需要手动布局。 protected override Size ArrangeOverride(Size finalSize); } 2.使用Thumb 因为Thumb实现拖动比较容易，有相关事件获取拖动距离。在装饰器中定义8个Thumb，对应8个方位点。
示例代码如下：
//4条边 Thumb _leftThumb, _topThumb, _rightThumb, _bottomThumb; //4个角 Thumb _lefTopThumb, _rightTopThumb, _rightBottomThumb, _leftbottomThumb; 初始化
public WindowResizeAdorner(UIElement adornedElement) : base(adornedElement) { //初始化thumb _leftThumb = new Thumb(); _leftThumb.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/69a4b283d223b6822e845529bfce1ec3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8a0dfe8eceb4a8b58db264ddca4f730/" rel="bookmark">
			高阶导数，，
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这节没啥好说的，背就完了，有一点就是高阶导的记作有点东西，其余的背记公式怼就行了
（三阶之后求导不能用‘′’至于23456的小角标放的位置虽然有些难为某些强迫症患者，但也是为了不引起歧义。最左边红笔写的三次导的复杂形式，以后求偏导可能要用到，因为多次求导时候不一定对同一未知数求导，任重而道远啊，，，，）
规律是有的，背会不难。重点说一下那个莱布尼茨公式。他和二项式定理十分相似。不过是次幂改成了几介导，而零次幂也就是零介导即不用求导直接搬上去。具体函数用莱布尼茨求导时候要注意什么时候u或v求导为零就会简单许多。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3cd388434d0cb9353af8a68bc16b8d3/" rel="bookmark">
			数列极限之收敛数列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先对ε-N定义理解进一步加深。例如作证明极限时，关键要证明出N&gt;n时，代入N的值依然小于n，方法：他的最大整数值加一。有极限的话即收敛，无极限的话即发散。收敛数列：1.收敛数列的极限唯一。 可以用反证法证明。2.收敛数列一定有界。（但反过来不一定成立） 3.收敛数列具有保号性（即数列从某项起Xn≥0,且Xn的极限≥0，也就是符号不变）
4.收敛数列的任一子数列收敛于同一极限。由此也可得知，发散数列的子数列也有可能是收敛的，所以若数列的两个子数列收敛于不同极限时，子数列一定发散。（子数列：可类似自己一样理解通常用Xk表示）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dcec0f749f68afe1d251890905d3e3cc/" rel="bookmark">
			05——svg的坐标系统和坐标系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是svg的坐标系统 众所周知，数学上的坐标系统，大部分是指 笛卡尔直角坐标系 并且：x轴 向右，y轴 向上，角度为 逆时针
在svg中，坐标系统同样也是笛卡尔直角坐标系，x轴 向右 但是：y轴向下，角度为 顺时针
二、什么是svg的坐标系？ 在svg中，共有4种坐标系： 用户 坐标系自身 坐标系前驱 坐标系参考 坐标系 我们来逐个了解一下
1、用户坐标系 即世界坐标系，指的是最原始的svg坐标系
2、自身坐标系 图形 元素或 分组 本身具有 的坐标系
如下图，rect 的坐标系 与 svg坐标系 、用户坐标系都是重合的
3、前驱坐标系 即 父级 坐标系。
自身坐标系 不发生变换 的情况下，和前驱坐标系是重合的。
如下图，rect 变换后 自身坐标系 是 蓝色坐标系，前驱坐标系即 svg 的坐标系（与用户坐标系Ouser重合）
4、参考坐标系 是一种 相对 的概念，没有特指哪个坐标系。
比如上面的图中，用户坐标系 也可以作为 rect 的参考坐标系，只是坐标值要根据实际情况重新计算。
三、综合实例 从头到尾顺一下思路 svg的坐标系为 OA ，也是原始的用户坐标系分组B的坐标系为 OB ，translate(0, 50) 后，OB坐标系 整体下移50像素，注意是OB坐标系本身下移，而不是OB的内容下移rect C的坐标系为OC ，宽高是自己的属性，x、y则是相对于自身坐标系OC的坐标值,OC没有变换，所以与父级坐标系重合rect D的坐标系为 OD ，细节解释同OC由于C、D没有translate，所以OB、OC、OD重合 在这里就可以理解上一篇的疑问了： 上一篇的 rect 的 x 、y是相对 自身坐标系的值，由于自身没有变换，所以rect坐标系与父级坐标系重合，也就是相对父级 g 对应坐标系的值
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dcec0f749f68afe1d251890905d3e3cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27e9c151c0970c9424f09e5b6d150307/" rel="bookmark">
			反射&#43;PROPERTIES文档
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先创建properties文档
一般在resources文件夹下创建
我们可以把它当作一般的文档来进行编辑
接下来我们输入属性对应的值，
username=zhangsan
如图：
接下来，与平常编写Java类一样，我们继续编写读取文件Dome.java
将下面这段代码编写如其中（注意，由于我们没有导入包，所以它会报错），
public class Demo { public static void main(String[] args) { //1.拆功能键属性对象 Properties p = new Properties(); //2.创建输入流 FileInputStream fis; try { fis = new FileInputStream("src\\main\\resources\\db.properties"); //3.将fis流中的所有数据加载到属性对象中 p.load(fis); //4.关闭流对象 fis.close(); } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } //5.获取文件中的值 String username = p.getProperty("username"); System.out.println(username); } } 如下图为正常现象：
我们需要找到相应的jar包，导入后才能运行：
以下是所需的jar包
import java.io.FileInputStream; import java.io.FileNotFoundException; import java.io.IOException; import java.util.Properties; 这些jar包中在jdk中都有，所以我们只需在idea中 选中红色代码处，同时按下enter和alt键就可直接导入 以下是运行成功的结果 记住，学会使用反射和导入propertise，它将在连接数据库中派上大用场。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf0d9b5897b887066598bf97e3b3da81/" rel="bookmark">
			电脑证书错误即上网站打不开提示证书错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上一些网站，老打不开，提示我证书错误；出现网站证书错误，一般有以下几个原因：首先是网站证书过期，其次是系统浏览器自身设置问题，下面为大家介绍下不错的解决方法
最近我上一些网站，老打不开，提示我证书错误，不知道怎么回事，求帮助
出现网站证书错误，一般有以下几个原因：首先是网站证书过期，其次是系统浏览器自身设置问题，再次是电脑可能中毒，最后还有可能是网站问题。解决方法如下：
第一，一般网站的证书均有颁布日期和截止日期，如果证书过期，建议你重新下载证书安装，确保证书的有效期和系统时间相符。
第二，浏览器的安全等级设置过高也有可能导致网页证书错误，解决方法是打开IE浏览器，在顶部菜单中找到“工具”菜单，在工具菜单里面找到“Intel 选项"，切换到“安全”选项卡，将Internet的安全级别设置为中就可以了。同时建议清除浏览器缓存，清除历史记录。
第三，对于中毒，有木马插件等引起的问题，最好更新病毒库后彻底杀毒，可以试着重装系统。
第四，对于原因是网站自身的问题，建议先更换不同的浏览器试试，如果还有此问题的出现那就是网站自身的问题了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2620e80403f703468a629d5e74011248/" rel="bookmark">
			seata事务协调器，seata—AT事务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 启动seata服务1.下载或者解压缩2.修改三个配置文件3.运行seata-server.bat启动服务 添加Seata At事务1.父项目添加seata依赖2.修改三个配置文件:3.新建自动配置类，创建数据源代理4.排除spring自己的配置源5.在业务方法上添加事务注解 seata介绍文档 启动seata服务 1.下载或者解压缩 seata-server-1.3.0
2.修改三个配置文件 registry.conf
向eureka注册
file.conf
seata server运行过程中产生的日志数据，存储到什么位置
seata-server.bat
修改占用内存
3.运行seata-server.bat启动服务 JAVA_HOME环境变量
JDK必须用1.8
bin目录中执行：seata-server.bat
添加Seata At事务 1.父项目添加seata依赖 &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-seata&lt;/artifactId&gt; &lt;version&gt;${spring-cloud-alibaba-seata.version}&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;seata-all&lt;/artifactId&gt; &lt;groupId&gt;io.seata&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.seata&lt;/groupId&gt; &lt;artifactId&gt;seata-all&lt;/artifactId&gt; &lt;version&gt;${seata.version}&lt;/version&gt; &lt;/dependency&gt; 2.修改三个配置文件: application.yml
设置事务组的组名 spring: cloud: alibaba: seata: tx-service-group: order_tx_group registry.conf
指定注册中心的地址 registry { # file 、nacos 、eureka、redis、zk、consul、etcd3、sofa type = "eureka" nacos { serverAddr = "localhost" namespace = "" cluster = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2620e80403f703468a629d5e74011248/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa1e6f98db422e6f8a9b3cbe2c84e3d4/" rel="bookmark">
			openssl源码中的头文件include error
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		源码：https://github.com/openssl/openssl
引用aes.h macros.h
编译报错../include/openssl/macros.h:156:4: error: #error "OPENSSL_API_COMPAT expresses an impossible API compatibility level"
# error "OPENSSL_API_COMPAT expresses an impossible API compatibility level"
查看宏的定义过程，发现缺少头文件
需要增加opensslconf.h opensslv.h
opensslconf.h 包括了configuration.h
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3543d263c50edb489423f3651c2d9d2/" rel="bookmark">
			软考网络工程师备考经验分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面 马上要毕业了，今天整理了一下实验室电脑的文件，看到了当时准备软考时的一些资料，当时考完一直没有时间整理，今天趁着空闲写一篇备考经验。
我参加的是2021年上半年软考中级网络工程师的考试，考试时间是2021年5月29日，我大概是从4月下旬开始准备的。
晒一下我的成绩
备考过程 刷视频教程
我用了大概两周的时间看视频教程过了一下知识点，记了一些笔记（手写笔记，这里就不分享了）。视频教程我前期看的时大涛的课，看到后面觉得有些不容易理解就去看了希赛的，临近考试的时候看了summer的专题课。这里推荐一下summer的课（【精华总结】2021年软考网络工程师专题突破【直击重点+难点+考点】），他的课有重点，易理解。刷题
刷题我用的是软考通，一个免费的刷题软件，这个软件中有软考的所有科目的考试真题和答案解析，并且将各个真题按章节分类。我是看完一个章节的视频之后，就做一章节的题，错的题有记录。敲代码
下午题是手写代码题，所以只能安装ensp进行实操练习。考前冲刺
考前一周，找了一些冲刺题，和专题重点知识点总结进行查漏补缺。 我把当时复习的一些资料放到了这里软考网络工程师复习资料，有需要的自取。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2b8ae042734d851fe67e82ba07d817f/" rel="bookmark">
			C&#43;&#43; 聚合类(Aggregate Class)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++ 聚合类（Aggregate Class） 文章目录 C++ 聚合类（Aggregate Class）概述聚合类定义聚合类的特性value-initialized聚合类的初始化方法 union（聚合）总结 概述 该篇文章是用于梳理在学习聚合类的相关文章过程中总结归纳的相关知识点。用于后续深入理解和使用聚合类进行准备。
聚合类定义 首先看一下C++标准中的定义：
An aggregate is an array or a class (clause 9) with no user-declared constructors (12.1), no private or protected non-static data members (clause 11), no base classes (clause 10), and no virtual functions (10.3). 由以上定义看出满足以下条件的类才可以称之为聚合类
无自定义构造函数；非静态数据成员没有大括号或等号初始化器，即类内没有初始值；无私有或保护的非静态成员；无基类和虚函数。 下面我们举一个简单的例子进行说明：
我们可以提供一个花括号扩起来的成员初始值列表，并用它初始化聚合类的数据成员，初始值的顺序必须与声明的顺序一致，初始值列表的元素个数少于类的成员数量，则靠后的成员被值初始化。
struct Person { std::string name; int height; }; int main() { Person person = {"xiaohong",10}; std::cout &lt;&lt; person.name&lt;&lt;" "&lt;&lt;person.height &lt;&lt; std::endl; system("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e2b8ae042734d851fe67e82ba07d817f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1be52c2b04b45585dbe33f6def189f5/" rel="bookmark">
			漏洞复现，DeDeCMS织梦
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、复现环境
二、复现过程及环境
一、复现环境 PHP 5.6 DeDeCMSV5.7SP2 正式版 (2018-01-09) 二、复现过程及环境 安装 DeDeCMS 首先，利用PHPstudy安装环境 点击网站，进入后再点击创建网站，然后填写域名，可根据自己的需要来填写
回到文件夹，打开
DeDeCMS所在文件夹的uploads路径，把其下所有的文件复制到 studypro文件夹的www目录中即可
域名/install/ 进入安装页面
填写好基本信息
进入网站后台，登录管理员账号
在系统设置中开启会员功能
然后退出管理员账号，注册会员账号，并不设置安全问题，可注册多个 用admin可查看我注册的会员账号，我的user1的mid为2 接下来就是抓包啦 首先你得先有一个抓包工具BURPSUITE，点击文件夹最下方的运行薄荷.vbs 开始抓包， 域名/member/resetpassword.php?dopost=safequestion&amp;safequestion=0.0&amp;safeanswer=&amp;id=2（mid是你抓包的用户的mid，比如我的是2 ）用burp抓包得到key.
域名/member/resetpassword.php?dopost=getpasswd&amp;id=2
跳转到修改密码页面，临时验证码就是key
然后成功修改密码
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2b2c9989e3c967f9d02933aa9eb5212/" rel="bookmark">
			Java使用Hutool工具完成加密解密
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说明 POM 使用Hutool加密解密工具时，引入如下依赖
复制代码 隐藏代码 &lt;dependency&gt; &lt;groupId&gt;cn.hutool&lt;/groupId&gt; &lt;artifactId&gt;hutool-crypto&lt;/artifactId&gt; &lt;version&gt;5.7.15&lt;/version&gt; &lt;/dependency&gt; 对称加密与非对称加密 对称加密 扫VX 领Java资料，前端，测试，python等等资料都有
加密算法 采用单钥密码系统的加密方法，同一个密钥可以同时用作信息的加密和解密，这种加密方法称为对称加密，也称为单密钥加密。常见加密算法 DES(Data Encryption Standard)：即数据加密标准，是一种使用密钥加密的块算法，1977年被美国联邦政府的国家标准局确定为联邦资料处理标准（FIPS），并授权在非密级政府通信中使用，随后该算法在国际上广泛流传开来。AES(Advanced Encryption Standard)：高级加密标准.在密码学中又称Rijndael加密法，是美国联邦政府采用的一种区块加密标准。这个标准用来替代原先的DES，已经被多方分析且广为全世界所使用。特点 加密速度快, 可以加密大文件密文可逆, 一旦密钥文件泄漏，就会导致数据暴露加密后编码表找不到对应字符，出现乱码，一般结合Base64使用 加密模式 ECB(Electronic codebook)：电子密码本。需要加密的消息按照块密码的块大小被分为数个块，并对每个块进行独立加密&lt;br&gt; 优点：可以并行处理数据缺点：同样的原文生成同样的密文，不能很好的保护数据同时加密，原文是一样的，加密出来的密文也是一样的CBC(Cipher-block chaining)：密码块链接。每个明文块先与前一个密文块进行异或后，再进行加密，每个密文块都依赖于它前面的所有明文块&lt;br&gt; 优点：同样的原文生成的密文不一样缺点：串行处理数据 填充模式 当需要按块处理的数据, 数据长度不符合块处理需求时, 按照一定的方法填充满块长的规则
NoPadding不填充 在DES加密算法下, 要求原文长度必须是8byte的整数倍在AES加密算法下, 要求原文长度必须是16byte的整数倍PKCS5Padding 数据块的大小为8位, 不够就补足 Tips：默认情况下, 加密模式和填充模式为：ECB/PKCS5Padding。如果使用CBC模式，需要增加参数初始化向量IV
DES与AES示例代码 复制代码 隐藏代码 public class SymmetricCryptoTest { @Test public void des() { String text = "HelloWorld"; // key：DES模式下，key必须为8位 String key = "12345678"; // iv：偏移量，ECB模式不需要，CBC模式下必须为8位 String iv = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2b2c9989e3c967f9d02933aa9eb5212/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2da4e2ca0a610a137ff04f12fe5f1be3/" rel="bookmark">
			微信给你挖的坑，怎么填上？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以前上班干活用QQ，现在上班干活用微信
以前QQ的个人数据文件夹几十G，现在轮到微信的个人数据文件夹几十G
那微信到底给我们挖了什么坑呢？
答案是硬盘空间占用区大，挖的是：空间清理的坑
如果是QQ，在电脑上的个人文件夹里，聊天过程中收发的图片、语音、视频，都列出来清清楚楚，可以检查重要的文件留下，然后大胆地清理掉不要的图片、视频等。
而微信就不一样，微信电脑版，虽然可以直接在个人文件夹里看到聊天过程中收发的视频，但是图片却被加密，完全看不到。
全是这种被加密过的DAT文件，把dat后缀改成jpg也没用，图片数量巨大，想清理掉没用的又不敢动手，怕删掉了重要的图片，这个可以说是微信给我们挖的最大的坑了。
怎么填上这个抗？
下面介绍一个小工具：《微信电脑版DAT图片格式转JPG格式工具》
可以百度搜索这个工具名字，也可以搜索：天才小网管　DAT
搜索这两个关键字都可以找到该工具，或者在文章末尾的参考资料中可以找到我获取该工具
把这个工具下载到电脑上，解压到文件夹中，然后打开它。
这个工具只有两个格子：
1，第一个框选择一个存放dat文件的文件夹，
2，第二个框选择一个保存转换后的图片的文件夹
3，点击“一键转换”
稍等一下就可以在转换后的文件夹里看到所有的图片了
这样就得到了转换后的JPG图片，然后把重要的图片文件保留下来，没用的JPG图片文件可以删除，而那些dat文件可以放心地清理掉，这样即保存了重要的图片，又清理了没用的图片，达到了我们要清理的目的。
这个坑填得虽然麻烦，但是已是目前的最优解决方案了。
参考资料：
https://www.qinyuanyang.com/post/242.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2313fce5396d96fb217c2e9f32793d9b/" rel="bookmark">
			扫雷解析~
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		扫雷的完成和三子棋极其相似，但是比三子棋需要对二维数组更加了解，同时和三子棋一样，需要提前对代码的实现与需要语言设计，。思路一定要先设计好！！！
我们首先对扫雷游戏的流程进行设
int main() { int choose = 0; srand((unsigned int)time(NULL)); do { meun(); scanf("%d", &amp;choose); switch (choose) { case 1: printf("进入游戏\n"); game(); break; case 0: printf("退出游戏\n"); break; default : printf("输入错误，请重新选择。&gt;\n"); } } while (choose); return 0; } 原理很简单。和三子棋的方法一样。
首先我们需要把游戏的逻辑理清楚，首先我们需要打印菜单，让我们选择是否进入游戏。如果我们中间想退出，或者继续游戏，我们就需要一个循环语句。而do while 语句是最适合的，而我们把选择是否进入游戏的输入变量变成while的循环条件。所以当我们选择退出游戏，输入0时，循环也就结束了。
我们再来观察菜单的设计
void meun() { printf("***** 1.play *******\n"); printf("**************************\n"); printf("***** 0.exit *******\n"); printf("请选择&gt;\n"); } 菜单相信大家都能看懂，这里就不需要过多解释了！
游戏的具体步骤
void game() { //创建数组 char mine[ROWS][COLS] = { 0 };//存放布置好雷的信息 char show[ROWS][COLS] = { 0 };//存放排查出雷的信息 //初始化数组 initboard(mine, ROWS, COLS,'0'); initboard(show, ROWS, COLS, '*'); // 电脑随机设置雷 setmine(mine,ROW,COL); // 打印模板 //Displayboard(mine,ROW,COL); Displayboard(show, ROW, COL); //扫雷 findboom(show, mine, ROW, COL); } 在这里我们首先看二维数组的设置。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2313fce5396d96fb217c2e9f32793d9b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/caf1bc8442d60dcdcebfe2ce247ed37c/" rel="bookmark">
			纯css实现点击切换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近浏览到一款相当震撼我的css，仅仅使用css，就能做出动态点击切换卡片的效果。
html源码
&lt;div class="card"&gt; &lt;input type="radio" name="select" id="slide_1" checked&gt; &lt;input type="radio" name="select" id="slide_2"&gt; &lt;input type="radio" name="select" id="slide_3"&gt; &lt;input type="checkbox" id="slideImg"&gt; &lt;div class="slider"&gt; &lt;label for="slide_1" class="slide slide_1"&gt;&lt;/label&gt; &lt;label for="slide_2" class="slide slide_2"&gt;&lt;/label&gt; &lt;label for="slide_3" class="slide slide_3"&gt;&lt;/label&gt; &lt;/div&gt; &lt;div class="inner_part"&gt; &lt;label for="slideImg" class="img"&gt; &lt;img class="img_1" src="https://c4.wallpaperflare.com/wallpaper/978/131/617/kiz-kulesi-turkey-istanbul-maiden-s-tower-wallpaper-preview.jpg"&gt; &lt;/label&gt; &lt;div class="content content_1"&gt; &lt;div class="title"&gt;İstanbul&lt;/div&gt; &lt;div class="text"&gt; Istanbul, a fascinating city built on two Continents, divided by the Bosphorus Strait. This is one of the greatest cities in the world.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/caf1bc8442d60dcdcebfe2ce247ed37c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ffd8a1294dff00ca53a7e730b6a7cb0d/" rel="bookmark">
			python实现部分排序，给定一个整数数组，编写一个函数，找出索引m和n，只要将索引区间[m,n]的元素排好序，整个数组就是有序的。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、题目描述： 给定一个整数数组，编写一个函数，找出索引m和n，只要将索引区间[m,n]的元素排好序，整个数组就是有序的。注意：n-m尽量最小，也就是说，找出符合条件的最短序列。函数返回值为[m,n]，若不存在这样的m和n（例如整个数组是有序的），请返回[-1,-1]。
示例：
输入： [1,2,4,7,10,11,7,12,6,7,16,18,19]
输出： [3,9]
二、解题思路 将原列表复制到新列表，并排序新列表。遍历2个列表，遇到第一个不等的下标赋给left，之后不等的下标依次更新赋给right，这样就直接找到了m和n。
三、代码实现 #!/usr/bin/python3 # author lzx # python实现 def partSort(input_list): sort_list = [] # 将原列表复制到新列表，并排序新列表 for i in input_list: sort_list.append(int(i)) sort_list.sort() # print(sort_list) left = -1 right = -1 # 遍历2个列表，遇到第一个不等的下标赋给left，之后不等的下标依次更新赋给right for i in range(len(input_list)): if int(input_list[i]) != sort_list[i]: if left == -1: left = i right = i return (left, right) if __name__ == '__main__': input_str = input('请输入待排序序列，逗号隔开：') input_list = input_str.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ffd8a1294dff00ca53a7e730b6a7cb0d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1c2f4663697bf424e9a0c66efc77cb2/" rel="bookmark">
			Java 详解（JVM） 垃圾回收机制原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是垃圾。
二、如何判断垃圾。
三、垃圾回收。
一、什么是垃圾。
首先我们要搞懂什么是垃圾。
在 JVM 的眼中，垃圾就是指那些在堆中存在的，已经“死亡”的对象。而对于“死亡”的定义，我们可以简单的将其理解为“不可能再被任何途径使用的对象”。(通俗的的讲就是在堆中创建的对象不会再次被使用)。
二、如何判断垃圾。
垃圾判断算法：引用判断法，可达性分析法。
引用判断法：
在这种算法中，假设堆中每个对象（不是引用）都有一个引用计数器。当一个对象被创建并且初始化赋值后，该对象的计数器的值就设置为 1，每当有一个地方引用它时，计数器的值就加 1，例如将对象 b 赋值给对象 a，那么 b 被引用，则将 b 引用对象的计数器累加 1。
反之，当引用失效时，例如一个对象的某个引用超过了生命周期（出作用域后）或者被设置为一个新值时，则之前被引用的对象的计数器的值就减 1。而那些引用计数为 0 的对象，就可以称之为垃圾，可以被收集。
特别地，当一个对象被当做垃圾收集时，它引用的任何对象的计数器的值都减 1。
优点：引用计数法实现起来比较简单，对程序不被长时间打断的实时环境比较有利。
缺点：需要额外的空间来存储计数器，难以检测出对象之间的循环引用。
可达性分析法:
可达性分析法也被称之为根搜索法，可达性是指，如果一个对象会被至少一个在程序中的变量通过直接或间接的方式被其他可达的对象引用，则称该对象就是可达的。更准确的说，一个对象只有满足下述两个条件之一，就会被判断为可达的：
对象是属于根集中的对象
对象被一个可达的对象引用
在这里，我们引出了一个专有名词，即根集，其是指正在执行的 Java 程序可以访问的引用变量（注意，不是对象）的集合，程序可以使用引用变量访问对象的属性和调用对象的方法。在 JVM 中，会将以下对象标记为根集中的对象，具体包括：
虚拟机栈（栈帧中的本地变量表）中引用的对象
方法区中的常量引用的对象
方法区中的类静态属性引用的对象
本地方法栈中 JNI（Native 方法）的引用对象
活跃线程（已启动且未停止的 Java 线程）
根集中的对象称之为GC Roots，也就是根对象。可达性分析法的基本思路是：将一系列的根对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，如果一个对象到根对象没有任何引用链相连，那么这个对象就不是可达的，也称之为不可达对象。
如上图所示，形象的展示了可达对象与不可达对象的示例，其中灰色的对象都是不可达对象，表示可以被垃圾收集的对象。在可达性分析法中，对象有两种状态，那么是可达的、要么是不可达的，在判断一个对象的可达性的时候，就需要对对象进行标记。
优点：可以解决循环引用的问题，不需要占用额外的空间
缺点：多线程场景下，其他线程可能会更新已经访问过的对象的引用
引用（Java中的四种引用类型）：
强引用（Strong Reference）：如Object obj = new Object()，这类引用是 Java 程序中最普遍的。只要强引用还存在，垃圾收集器就永远不会回收掉被引用的对象。
软引用（Soft Reference）：它用来描述一些可能还有用，但并非必须的对象。在系统内存不够用时，这类引用关联的对象将被垃圾收集器回收。JDK1.2 之后提供了SoftReference类来实现软引用。
弱引用（Weak Reference）：它也是用来描述非必须对象的，但它的强度比软引用更弱些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在 JDK1.2 之后，提供了WeakReference类来实现弱引用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d1c2f4663697bf424e9a0c66efc77cb2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a46758c7ef059396183ffe674c8574a/" rel="bookmark">
			Python中判断回文数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		判定一个5位数或者4位整数否为回文数
顺读与逆读都一样的数
例如：1，2，3，4，5，6，7，8，9，11，22，33，101，121，222
算法思路1：将该数先摸10后除10的方法一一拆除，当第一个等于倒数第一个，第二个等于倒数第二个时，为回文数
import sys
n = int(input("请输入一个5位数或者4位数:"))
if n &lt; 1000 or n &gt;= 100000:
print("输入数字不合理")
sys.exit() # 输入不合理退出程序
r1 = n % 10
r2 = n // 10 % 10
r3 = n // 100 % 10
r4 = n // 1000 % 10
if n &gt; 10000 and n &lt; 100000: # 5位数
f2 = r4
f1 = n // 10000
else:
f2 = r3
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a46758c7ef059396183ffe674c8574a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e735d96f68cfc7ed58e933179c7c01ba/" rel="bookmark">
			关于idea没有显示log关键字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		导入两个依赖
最关键的步骤(查了好久，原来就是这个原因)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/608b848a8868e4632fd8e9eae9e6eb81/" rel="bookmark">
			vue使用 时间处理插件 Moment.js
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 官网 https://momentjs.bootcss.com/ Moment.js
npm npm install moment --save # npm 总结：Moment.js常见用法总结
项目中引入:
import moment from "moment"; time // 标准时间格式 let str = moment(time).format("yyyy-MM-DD"); console.log(str); //2011-01-01 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bec35ef29f49e1c580523f0e92c29dae/" rel="bookmark">
			Android-Skin-Loader换肤框架剖析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一. 简介1. 基本原理2. LayoutInflater 二. 框架Android-Skin-Loader解析1. android-skin-loader-sample使用教程1.1 xml布局配置1.2 Application初始化1.3 Activity继承 2. android-skin-loader-skin3. android-skin-loader-lib3.1 SkinManager：加载换肤包3.2 SkinInflaterFactory：收集所有可替换皮肤View类3.3 notifySkinUpdate：换肤替换3.4 代码动态换肤 4. 总结5. 拓展拓展一拓展二 一. 简介 换肤功能，是很多公司项目中的重点功能，仅仅会用那是远远不够的，需要对换肤有全面整体的把握，了解底层实现原理，才能在后面的开发中举一反三，事半功倍。
1. 基本原理 对于Android项目来说，皮肤是什么，皮肤就是UI界面，换皮肤无非就是字体颜色、背景图等这些用户看得见的界面。所以换皮肤最为重要的就是换Android工程下res下面的资源文件，也即如下图所在的资源：
Google在Android10（API 29）就已经开始支持深色模式，自定义适配方案是使用资源限定符，就像横向布局适配是添加layout-land资源，高密度资源适配是添加drawable-hdpi资源，其自定义深色模式的适配方案则是在res-night下定义一套资源
在该深色模式资源文件下，所用资源命名和正常资源相同，例如相同的drawable/color/style，那么当系统切换为深色模式时，系统会自动识别并使用res-night下面的资源文件，从而切换为我们想要的深色效果。
换肤功能就类似Google的深色模式，要实现各种换肤功能我们只需要替换对应的资源文件即可，让view布局重新加载新的资源文件。
2. LayoutInflater 首先我们通过上一篇文章了解下 LayoutInflater Factory，通过关于Factory的介绍，我们得出结论：自定义Factory，然后通过setFactory方法设置给系统，那么在系统创建View时则可以进行自定义样式的干预。接下来我们来看看本文研究框架的核心实现原理。
二. 框架Android-Skin-Loader解析 框架 Android-Skin-Loader，官方的版本太旧了，经过改造适配了最新的AndroidX控件以及能正常生成皮肤包，下载地址 Android-Skin-Loader，其工程结构如图
工程中android-skin-loader-sample是一个使用例子，android-skin-loader-skin是一套皮肤包，android-skin-loader-lib为支持换肤的library，下面我们就来一一介绍了。
1. android-skin-loader-sample使用教程 1.1 xml布局配置 在需要换肤的组件上配置skin:enable=“true”
&lt;Button android:layout_width="match_parent" android:layout_height="100dp" android:background="@drawable/news_item_selector" android:textColor="@color/color_sel_skin_btn_text" skin:enable="true" /&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:textColor="@color/news_item_text_color_selector" android:textSize="20sp" skin:enable="true" /&gt; 1.2 Application初始化 public class SkinApplication extends Application { public void onCreate() { super.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bec35ef29f49e1c580523f0e92c29dae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e32bad6a0973512365d9e4c4731ebaf/" rel="bookmark">
			推荐系统（1）-业界推荐系统架构（基于Python）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1介绍 基于这篇文章的学习推荐系统（1）-业界推荐系统架构
2 推荐系统常见架构 2.1基于离线训练的推荐系统架构设计 主要应用场景：手机应用市场、音乐推荐、短视频推荐、资讯、购物 常用算法：逻辑回归（Logistics Regression）、梯度提升决策树（GBDT）和因式分解（FM） 2.2面向深度学习的推荐系统架构设计 主要应用场景：图像处理、自然语言理解、语音识别、在线广告等具有时序行为、多维数据的推荐系统 常用算法：受限玻尔兹曼（RBM）、自编码器（AE）、卷积神经网络（CNN）、深度神经网络（DNN）、宽度学习（Wide&amp;Deep）等 2.3基于在线训练的推荐系统架构设计 主要应用场景：广告和电商等高纬度大数据量、实时性要求很高的推荐系统，例如，新闻事件 常用算法：FTRL-Proximal、AdPredictor、Adaptive Oline Learning 和PBODL等 2.4面向内容的推荐系统架构设计 主要应用场景：新闻资讯，今日头条、抖音、微博、视频音乐、广告购物朋友圈传播资讯、门户网站等 常用算法：NLP自然语言、word2vec、深度学习DNN、OCR等 参考 推荐系统（1）-业界推荐系统架构：https://zhuanlan.zhihu.com/p/93183929
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46e59064c928c78a50abda9d9cf42327/" rel="bookmark">
			MyBatis 的好处是什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、MyBatis 把 sql 语句从 Java 源程序中独立出来，放在单独的 XML 文件中编写，给程序的维护带来了很大便利。
2、MyBatis 封装了底层 JDBC API 的调用细节，并能自动将结果集转换成 Java Bean 对象， 大大简化了 Java 数据库编程的重复工作。
3、因为 MyBatis 需要程序员自己去编写 sql 语句，程序员可以结合数据库自身的特点灵活控制 sql 语句，因此能够实现比 Hibernate 等全自动 orm 框架更高的查询效率，能够完成复杂查询。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f44e8447b44c2da3e8920e94929a8a0c/" rel="bookmark">
			新版-蓝桥杯嵌入式-拓展板 数码管的学习使用；
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.硬件电路 二.CUBEMX引脚配置 三.程序编写 四.观察现象 一、硬件电路 硬件电路虽然看起来很多，很大一坨，但是我们实际需要用到的就是图中用红线标出的三个引脚，我们只需要控制这三个引脚便可以控制这三个数码管。
那我们怎么进行对这三个引脚的控制呢？
当然是进行跳线了！
那怎样进行跳线呢？
如下图：
更多跳线选择方式可以看看这位博主：【国信长天蓝桥杯】CT117E-M4 嵌入式开发板扩展篇 ① 扩展板功能介绍及其与主板的连接_我是鹏老师-CSDN博客
我们只需要将跳线帽将P3,P4进行短接就可以了。短接后的PA1就是数码管上的SER脚，PA2就是数码管上的RCLK脚，PA3就是数码管上的SCK脚。我们后续只需要对这三个引脚进行初始化配置就可以使用了。
二、CUBEMX引脚配置 我们打开官方给的LCD例程中的CUBEMX，寻找到PA1,PA2,PA3三个引脚。选择GPIO_OUTPUT模式，对每一个引脚添加标签（这是一个非常良好的习惯，方面后面对引脚的控制以及自己辨识），将output speed 改为Medium。
如图：
OK! 其他不变，点击 生成代码，打开KIEL；
三、编写程序 添加 .c代码 #include "seg.h" unsigned char Seg7[17] = { 0x3f,0x06,0x5b,0x4f, 0x66,0x6d,0x7d,0x07,0x7f,0x6f,0x77,0x7c, 0x39,0x4f,0x79,0x78,0x00}; void Seg_ShowNum(unsigned char N1,unsigned char N2,unsigned char N3){ unsigned char num,i; num =Seg7[N3]; for(i=0;i&lt;8;i++){ if(num&amp;0x80) SER_H; else SER_L; SCK_H; num&lt;&lt;=1; SCK_L; } num = Seg7[N2]; for(i=0;i&lt;8;i++){ if(num&amp;0x80) SER_H; else SER_L; SCK_H; num&lt;&lt;=1; SCK_L; } num = Seg7[N1]; for(i=0;i&lt;8;i++){ if(num&amp;0x80) SER_H; else SER_L; SCK_H; num&lt;&lt;=1; SCK_L; } RCLK_H; RCLK_L; } 添加.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f44e8447b44c2da3e8920e94929a8a0c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88f757df9efe5ac9f3922926554ee457/" rel="bookmark">
			javascript之运算符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概念：算术运算使用的符号，用于执行两个变量或值的算术运算。 浮点数的精度问题
浮点数值的最高精度是 17 位小数，但在进行算术计算时其精确度远远不如整数。
var result = 0.1 + 0.2; // 结果不是 0.3，而是：0.30000000000000004 console.log(0.07 * 100); // 结果不是 7， 而是：7.000000000000001 所以：不要直接判断两个浮点数是否相等 ! 表达式和返回值 表达式：是由数字、运算符、变量等以能求得数值的有意义排列方法所得的组合 简单理解：是由数字、运算符、变量等组成的式子 表达式最终都会有一个结果，返回给我们，我们成为返回值 递增和递减运算符概述 如果需要反复给数字变量添加或减去1，可以使用 递增（++）和递减（ -- ） 运算符来完成。 在 JavaScript 中， 递增（++）和递减（ -- ） 既可以放在变量前面，也可以放在变量后面。 放在变量前面 时， 我们可以称为 前置递增（递减）运算符 ， 放在变量后面 时，我们可以称为 后置递增（递减）运算符 。 注意：递增和递减运算符必须和变量配合使用。 比较运算符概述 概念：比较运算符（关系运算符）是 两个数据进行比较时所使用的运算符 ，比较运算后，会 返回一个布尔值 （true / false）作为比较运算的结果。 =小结
console.log(18 == '18'); console.log(18 === '18'); 逻辑运算符概述 概念：逻辑运算符是用来进行布尔值运算的运算符，其返回值也是布尔值。后面开发中经常用于多个条件的判断。 逻辑与&amp;&amp;
两边都是 true才返回 true，否则返回 false
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/88f757df9efe5ac9f3922926554ee457/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b672090e0671bb24ffe13100bd6d3de4/" rel="bookmark">
			Ubuntu第一次配置virtualbox报错Kernel driver not installed (rc=-1908)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		完整报错信息如下
Kernel driver not installed (rc=-1908)
The VirtualBox Linux kernel driver is either not loaded or not set up
correctly. Please try setting it up again by executing
‘/sbin/vboxconfig’
as root.
大概意思就是内核驱动没有安装，下面推荐了一个指令可以安装
命令行运行
sudo /sbin/vboxconfig 然后因为UEFI的安全设置，会配置一下，本来直接进入boot，关了这个scure boot，但是后来发现关了以后系统没法启动了。
大概意思就是要你输入一下密码，同意第三方驱动的安装。但是输入密码以后，发现了其他的错误。
大概就是编译失败了，使用dmesg去查看了一下为什么，然后重启一下安装程序。
看了一下dmesg，发现太多了，看不懂。但是现在已经把问题锁定在了modprobe vboxdrv失败。现在就开始解决这个问题。
打开命令行，直接运行
sudo modprobe vboxdrv 发现don’t permit，上网查阅后，发现是boot启动了secure boot，不让修改boot的设置。
重启，狂按F2，进入boot模式
找到secure boot(每个机型可能位置不一样，慢慢找)，选择off。退出boot，启动机器。
再次运行
sudo modprobe vboxdrv 成功启动虚拟机。
发现虚拟机可以运行了，但是CentOS的光盘映像文件不对。在设置里面改了一下光盘映像的位置就可以启动了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1edc8b87347595f48310e4bbf54c736/" rel="bookmark">
			浏览器显示”SSL证书无效”怎么办
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当你浏览网页的时候，网页上显示“​​SSL证书无效​​”，你是不是也曾经遇到过这种情况。为什么网页会出现这种提示？以及​​SSL证书是什么​​？针对这些问题，小编在下面的内容做详细的介绍。
出现这种情况只会发生在https网站上。HTTPS网站是一个经过加密的网站，用户访问该网站，用户数据将会以加密的方式进行传输，HTTPS网站能很好地保护用户的隐私信息，是一个安全可靠的网站。网站服务器只要安装部署了​​SSL证书​​，那么网站就可以启用HTTPS服务，也就是说，用户可以通过HTTPS来去访问你的网站。而出现“SSL证书无效”的提示，是由于SSL证书出现了问题。
出现SSL证书无效有以下这几种情况：
1、SSL证书过期了
SSL证书是有有效期的，只有在有效期内的证书，浏览器才会认为该HTTPS网站是安全的。当你发现浏览器提示“SSL证书无效”你可以查看你的证书是否已经过期了，假如过期了那就赶紧更换你的SSL证书吧。
更换SSL证书你可以找原来的SSL证书申请机构，也可以找其他的SSL证书颁发机构重新申请新的SSL证书，使用新的SSL证书不会对你的HTTPS网站有任何的影响。ssl证书申请
2、SSL证书不受信任
假如你确认SSL证书还在有效期内，那么很有可能是你的SSL证书不是由受信的CA机构所签发的。
浏览器会预先把一些权威的CA机构的根证书导入到计算机系统中受信任列表中，假如你的SSL证书不是由受信任列表中的CA根证书所签名，那么浏览器将不会认为该HTTPS网站是安全的。
由于计算机浏览器存在受信任列表，所以你在申请SSL证书的时候，必须要选择这些受信列表CA机构所签发的证书，否则你的网站就算部署了SSL证书，浏览器也会提示“SSL证书无效”。
3、你的计算机系统时间不正确
假如你检查过SSL证书还没过期，但是浏览器还是显示证书已过期，那么你就要检查一下你的计算机系统时间是不是错误的。
浏览器判断SSL证书是否有效，是根据系统时间计算的。系统时间错误，自然就可能计算出证书是过期的。修改系统时间，HTTPS网站应该就能正常访问了。
4、SSL证书与网站域名不匹配
申请SSL证书其中一个必须的验证步骤就是验证域名，域名验证通过后才会颁发出SSL证书。所以SSL证书是与网站域名一一对应的，A网站的证书不能用于B网站，否则浏览器也会提示“SSL证书无效”。
浏览器显示“SSL证书无效”怎么处理？
这个时候我们应该对浏览器进行一定的调整设置操作了，但是是出现一些比较有风险的情况的话，这个时候只要重新调用和配置就可以了。小编提醒，为了避免ssl证书无效的情况的发生，这个时候我们应该对浏览器进行一定的调整设置操作了，但是是出现一些比较有风险的情况的话，这个时候只要重新调用和配置就可以了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db196ba25204d4e817c0d6abc21300c2/" rel="bookmark">
			B站到处投资，股价暴跌两位数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		11月19日，哔哩哔哩已全资收购奥飞娱乐旗下的有妖气原创漫画平台。有妖气成立于2009年，主营业务包括“有妖气原创漫画梦工厂”网站及“有妖气漫画”APP 运营、网络漫画发表、网络动画制作、动漫版权运营等。本次收购价格为人民币6亿元。
目前，有妖气拥有超3200万用户，平台聚集7万多位原创漫画师，连载原创漫画作品超过4万5千部。在IP方面，旗下作品包括《十万个冷笑话》、《镇魂街》、《雏蜂》、《端脑》等。
值得一提的是，今年以来B站在不少新兴领域都有投资，包括新锐设计师品牌bosie、咖啡品牌鹰集等。在最近三个交易日，B站股价已经下跌约30%。
主要原因有两个：第一是三季报亏损额度加大，而且对四季度的营收指引较低；第二是在公布财报的第二天，就急匆匆地推出了14亿美元（还有可能扩大为16亿美元）的可转债融资方案。
任何正常人都能意识到，在此时此刻进行融资，极不明智：
互联网中概股的市场情绪非常悲观，投资者经不起任何风吹草动。在一年以前，B站这样的公司的再融资会被人哄抢，现在则过了时候。
在三季报公布之后，投资者已经为亏损扩大而感到不满，B站股价也暴跌了两位数。此时宣布进行融资，给投资者带来了“管理层并不在意股价”的恶劣印象。
过去几个季度，B站的对外投资带来了巨大的亏损；还有一部分亏损尚未计入损益表。投资者担心，B站融资是为了加码对外投资，投得越多可能亏得越多。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc3c5be9e6c4200b2aacf793acb7942d/" rel="bookmark">
			一般信道容量的计算方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由 拉 格 朗 日 乘 子 法 对 L = I ( X ; Y ) − λ ∑ i p i 对 p i 求 导 可 得 公 式 ∑ j = 1 m p ( y j / x i ) l o g ( p ( y j / x i ) p ( y i ) ) = l o g 2 e + λ 引 入 C ： ∑ j = 1 m p ( y j / x i ) l o g ( p ( y j / x i ) p ( y i ) ) = C 分 离 定 值 ： ∑ j = 1 m p ( y j / x i ) l o g ( p ( y j / x i ) ) = C + ∑ j = 1 m p ( y j / x i ) l o g ( p ( y i ) ) ∑ j = 1 m p ( y j / x i ) = 1 , ∑ j = 1 m p ( y j / x i ) l o g ( p ( y j / x i ) ) = ∑ j = 1 m p ( y j / x i ) l o g ( p ( y i ) + C ) 求 解 p ( y i ) + C ， 由 转 移 概 率 再 解 出 p i 由拉格朗日乘子法对L=I(X;Y)-\lambda \sum_{i} p_i 对p_i求导可得公式\\ \sum_{j=1}^m p(y_j/x_i)log(\frac{p(y_j/x_i)}{p(y_i)})=log_2e+\lambda \\ 引入C：\sum_{j=1}^m p(y_j/x_i)log(\frac{p(y_j/x_i)}{p(y_i)})=C \\ 分离定值：\sum_{j=1}^m p(y_j/x_i)log(p(y_j/x_i))=C+\sum_{j=1}^m p(y_j/x_i)log(p(y_i))\\ \sum_{j=1}^m p(y_j/x_i)=1,\sum_{j=1}^m p(y_j/x_i)log(p(y_j/x_i))=\sum_{j=1}^m p(y_j/x_i)log(p(y_i)+C)\\ 求解p(y_i)+C，由转移概率再解出p_i 由拉格朗日乘子法对L=I(X;Y)−λi∑​pi​对pi​求导可得公式j=1∑m​p(yj​/xi​)log(p(yi​)p(yj​/xi​)​)=log2​e+λ引入C：j=1∑m​p(yj​/xi​)log(p(yi​)p(yj​/xi​)​)=C分离定值：j=1∑m​p(yj​/xi​)log(p(yj​/xi​))=C+j=1∑m​p(yj​/xi​)log(p(yi​))j=1∑m​p(yj​/xi​)=1,j=1∑m​p(yj​/xi​)log(p(yj​/xi​))=j=1∑m​p(yj​/xi​)log(p(yi​)+C)求解p(yi​)+C，由转移概率再解出pi​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc3c5be9e6c4200b2aacf793acb7942d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7f4abf90eb823d6e6856a806aa3ee29/" rel="bookmark">
			NIO基础知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		NIO基础 一、三大组件 1. Channel 读写数据的双向通道
常见Channel：
FileChannelDatagramChannel：TCP UDP需要用到SocketChannel：客服端、服务端都可以用ServerSocketChannel：服务端可用 2. Buffer 内存缓存区，暂存数据，用来独写数据
常用Buffer：
ByteBuffer MappedByteBufferDirectByteBufferHeapByteBuffer ShortBufferIntBuffer。。。。。。 2.1 ByteBuffer结构 重要属性：
capacity：容量position： 写模式：代表写入数据的指针位置读模式：将位置转换为读取位置 limit： 写模式：写入限制读模式：读取的限制 3. Selector 选择器
3.1 多线程版设计 3.2 缺点 内存占用高线程上下文切换成本高只适合连接少数的场景 3.3 线程池版本 3.4 缺点 阻塞模式下，线程仅能处理一个socket连接仅适合短连接场景 3.5 Selector版本 配合一个线程来管理多个channel，获取这些channel上发生的事件，这些channel工作在非阻塞模式下。调用selector的select() 会阻塞知道channel发生了独写就绪事件，这些事件方法就会返回这些事件交给trhead来处理。适合流量比较低的场景
二、粘包\半包 网络上有多条数据发送给服务端，数据之间使用 \n 进行分割，但是由于某种原因这些数据在接收时被进行了重新组合。
public static void main(String[] args) throws IOException { //test1(); //writer(); ByteBuffer encode = StandardCharsets.UTF_8.encode("hello,world\ni am zhangsan\nwe are family"); split(encode); encode = StandardCharsets.UTF_8.encode(" together . \n 55555"); split(encode); encode = StandardCharsets.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e7f4abf90eb823d6e6856a806aa3ee29/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6c8218ccf7f9e6f6ae66fd35f72b7ad/" rel="bookmark">
			＜input type=“file“＞上传文件到服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题： 如何在浏览器端上传文件（单个文件/文件夹）到服务器？
浏览器：firefox
服务器：虚拟机ubuntu18
1.前端 &lt;li&gt;&lt;a href="#" onclick='openFileDialog()'&gt;选择图片路径&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;input type="file" id="folder2images" style="display: none" onchange='fileSelected()'webkitdirectory/&gt;&lt;/li&gt; 补充：如只想上传单个文件，就把webkitdirectory去掉
2.js function openFileDialog() { $("#folder2images").click(); } function fileSelected(){ var file=document.getElementById("folder2images").files; console.log(file) startFileUpload(file); } //开始上传 function startFileUpload(file) { var uploadURL = "FilesUploadServer"; //手工构造一个form对象 var formData = new FormData(); for(var i=0;i&lt;file.length;i++){ formData.append("file" , file[i]);// 'file' 为HTTP Post里的字段名, file 对浏览器里的File对象;注意：此处如果上传的是文件夹，不能直接formData.append("file" , file);这样后台会接收不到文件 } //手工构造一个请求对象，用这个对象发送表单数据 //设置 progress, load, error, abort 4个事件处理器 var request = new XMLHttpRequest(); request.upload.addEventListener("progress" , window.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f6c8218ccf7f9e6f6ae66fd35f72b7ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74c964261b410099963f3eb3eff292da/" rel="bookmark">
			c#实现登录，注册功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		c#实现登录，注册功能 登录界面： 主窗体为登录界面，输入用户名和密码，单击“登录”按钮时从数据库中读取数据，与输入的用户名、密码验证，验证通过后，登录窗体消失。单击“注册”按钮时窗体中的输入的数据保存到数据库中 。
代码实现： private void button1_Click(object sender, EventArgs e) { //获取界面上用户输入信息 string userName = textBox1.Text; string userPwd = textBox2.Text; //2.运用Connection对象建立与数据库的连接 //(1)定义连接数据库的字符串 string connStr = "server=DESKTOP-XXXX;database=数据库名;uid=账号;pwd=密码";//采用混合身份验证 //(2)创建Connection对象 SqlConnection conn = new SqlConnection(connStr); //(3)打开连接 conn.Open(); //3.利用Command对象执行sql语句 //(1)定义要执行的sql语句 string sql = "select count(1) from 数据表 where userName=@t1 and userPwd=@t2 "; //(2)通过Connection对象和sql语句，创建Command对象 SqlCommand cmd = new SqlCommand(sql, conn); //(3)处理Command对象的参数 cmd.Parameters.Add("@t1", SqlDbType.VarChar).Value = userName; cmd.Parameters.Add("@t2", SqlDbType.VarChar).Value = userPwd; //(4)执行SQL语句 if ((int)cmd.ExecuteScalar() &gt; 0) { Form2 Form2 = new Form2(); userName = textBox1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/74c964261b410099963f3eb3eff292da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0bce80fa671985cfc4485a3c00c8a8b0/" rel="bookmark">
			消息中间件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		消息中间件
kafka 追求高吞吐量，适合产生大数据量的互联网服务的数据收集业务
RocketMQ 可靠性要求很高的金融互联网领域，稳定性高，经历了多次阿里双十一考验
RabbitMQ 性能较好，社区活跃度很高，数据量没这么大，优先选择功能比较完备的RabbitMQ
MQ消息队列（消息中间件）的作用
1.消息通讯
引入消息队列后，把发送邮件,短信不是必须的业务逻辑异步处理
2.应用解耦
引入消息队列
订单系统:用户下单后,订单系统完成持久化处理,将消息写入消息队列,返回用户订单下单成功。
库存系统:订阅下单的消息,获取下单消息,进行库操作。
就算库存系统出现故障,消息队列也能保证消息的可靠投递,不会导致消息丢失
3.流量削峰
流量削峰一般在秒杀活动中应用广泛
场景:秒杀活动，一般会因为流量过大，导致应用挂掉,为了解决这个问题，一般在应用前端加入消息队列。
作用:
1.可以控制活动人数，超过此一定阀值的订单直接丢弃
2.可以缓解短时间的高流量压垮应用(应用程序按自己的最大处理能力获取订单)
1.用户的请求,服务器收到之后,首先写入消息队列,加入消息队列长度超过最大值,则直接抛弃用户请求或跳转到错误页面.
2.秒杀业务根据消息队列中的请求信息，再做后续处理.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e26b890a9c035ae1275144237628698/" rel="bookmark">
			OCRNet 论文解读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		论文：Segmentation Transformer: Object-Contextual Representations for Semantic Segmentation
文章提出一种新的对象上下文特征表示方法，方法本质上是用注意力建立点和对象区域的上下文关系。
背景和动机 获取目标的上下文特征有两种主流方法，一是以ASPP为代表的多尺度模块，ASPP通过对特征图中的点进行稀疏采样获得上下文，这种方式获得上下文既包含前景目标，也可能包含背景。另一种被称为 Relational context，这种方式考虑目标与其他特征点的联系（相似度）。
OCR是一种Relational context方法。在理想状态下，上图红色■目标的OCR上下文信息是车所在区域的特征。简单来讲，在红色块处ASPP通过不同膨胀率的空洞卷积进行多尺度，再在通道维度上整合信息从而得到该处的上下文向量，空洞卷积采样哪些点只依赖参数dilation，不考虑这些点是否属于同一目标，也不考虑属于前景背景等等。而OCR期望更为准确的获得上下文，红色块的上下文向量仅由目标（车）区域的特征信息聚合产生，虽然实际中难以达到这么完美的聚合，（这也是论文开头提到的上限）。
做法 从输入特征到加强的object-contextual特征要经过三步，分别是：
目标区域软划分（soft object regions），根据输入特征，使用softmax得到一个为K类的软分类{ M 1 , . . . , M K M_1,...,M_K M1​,...,MK​}， M k M_k Mk​是一个2D特征图，其中每个值代表着属于第k类的概率，假设上图中的车是第1类，那么期望状态下 M 1 M_1 M1​内 点的值在车的区域值较大，而在其他区域趋近0。计算目标区域表示 （object region representation），得到{ f 1 f_1 f1​,…, f K f_K fK​}， f k f_k fk​代表着第k类目标的特征表示，它是用 M k M_k Mk​与像素级特征的乘积，再在空间维度上求和得到的一个向量。计算得到object-contextual representations。可以简化为注意力机制，对于每个点处的特征向量 x i x_i xi​作为query， f k f_k fk​作为key和vaule，根据 x i x_i xi​和 f k f_k fk​的相似度聚合目标特征表示。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e26b890a9c035ae1275144237628698/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad33e86f4796cc78b35f5ad5dfd41572/" rel="bookmark">
			react中img引入本地图片的2种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、通过import引入（推荐）
以前我们用img引入图片只需要如下即可
但在react中不允许使用这种方式，会报错
import logo from '../assets/images/home/logo.png' &lt;img className={"logoStyle"} src={logo} alt=""/&gt; 二、require方法引入
&lt;img className={"logoStyle"} src={require('../assets/images/home/logo.png')} alt="" /&gt; 区别
第一种引入方式，webpack把当前图片当做资源文件打包，你可以在配置文件里面设置图片加载器，小与多少kb已base64码的格式打包，当大于某个kb大小的时候，webpack会把当前图片 也变编译到你的你的打包目录下面。
第二种引入方式，你在css文件里面可以引用，因为css-loader会把资源文件一起打包， 而在js中这样引入，webpack只会当前的src当做字符串，并不会当做资源文件去处理，这样当你的代码- -旦打包到线上就会出现图片文件路径找不到的问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d039d42572a97b66e75c75bbae88a436/" rel="bookmark">
			数据类型转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 什么是数据类型转换 使用表单、prompt 获取过来的数据默认是字符串类型的，此时就不能直接简单的进行加法运算，而需要转换变量的数据类型。通俗来说，就是 把一种数据类型的变量转换成另外一种数据类型 。 我们通常会实现3种方式的转换： 转换为字符串类型 转换为数字型 转换为布尔型 转换为字符串
toString() 和 String() 使用方式不一样。三种转换方式，我们更喜欢用第三种加号拼接字符串转换方式， 这一种方式也称之为隐式转换。 转换为数字型（重点）
注意 parseInt 和 parseFloat 单词的大小写，这2个是重点 隐式转换是我们在进行算数运算的时候，JS 自动转换了数据类型. 转换为布尔型 代表空、否定的值会被转换为 false ，如 ''、0、NaN、null、undefined 其余值都会被转换为 true console.log(Boolean('')); // false console.log(Boolean(0)); // false console.log(Boolean(NaN)); // false console.log(Boolean(null)); // false console.log(Boolean(undefined)); // false console.log(Boolean('小白')); // true console.log(Boolean(12)); // true 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a7fce6812695b61d6678e48291764ec/" rel="bookmark">
			FFmpeg结构体分析：AVFormatContext连接FFmpeg的桥梁
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AVFormatContext对开发者开放，是连接开发者与FFmpeg内部的桥梁。结构体内部包含有AVInputFormat、AVOutputFormat、AVCodec、AVStream、AVDictionary 、AVClass等。支持设置自定义IO、监听网络中断状态、设置options、直播秒开调优等。
AVFormatContext结构体的源码位于libavformat/avformat.h，具体代码如下：
typedef struct AVFormatContext { // 用于打印日志和设置选项的类 const AVClass *av_class; // 输入容器格式 ff_const59 struct AVInputFormat *iformat; // 输出容器格式 ff_const59 struct AVOutputFormat *oformat; // 私有数据 void *priv_data; /** * I/O 上下文 * * - demuxing: avformat_open_input()之前设置 * - muxing: avformat_write_header()之前设置 */ AVIOContext *pb; // 关于stream属性的Flags int ctx_flags; // 码流的数量 unsigned int nb_streams; // 码流数组 AVStream **streams; // 输入或输出的URL char *url; // 第一帧的开始时间 int64_t start_time; // 码流的时长 int64_t duration; // 码流的码率，单位为bit/s int64_t bit_rate; unsigned int packet_size; int max_delay; int flags; #define AVFMT_FLAG_GENPTS 0x0001 ///&lt; Generate missing pts #define AVFMT_FLAG_IGNIDX 0x0002 ///&lt; Ignore index.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a7fce6812695b61d6678e48291764ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88d2c8f196484041df6466b1872c60cd/" rel="bookmark">
			获取变量数据类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 获取检测变量的数据类型 typeof 可用来获取检测变量的数据类型 var num = 18; console.log(typeof num) // 结果 number 不同类型的返回值 字面量
字面量是在源代码中一个固定值的表示法，通俗来说，就是字面量表示如何表达这个值。 数字字面量：8, 9, 10字符串字面量：'黑马程序员', "大前端"布尔字面量：true，false 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/137eb90477d13b05a24059c62a622e9a/" rel="bookmark">
			javascript之数据类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		变量的数据类型 变量是用来存储值的所在处，它们有名字和数据类型。变量的数据类型决定了如何将代表这些值的位存储到计算机的 内存中。 JavaScript 是一种弱类型或者说动态语言。 这意味着不用提前声明变量的类型，在程序运行过程中，类型会被自动确定。 var age = 10; // 这是一个数字型 var areYouOk = '是的'; // 这是一个字符串 在代码运行时，变量的数据类型是由 JS引擎 根据 = 右边变量值的数据类型来判断 的，运行完毕之后， 变量就确定了数据类型。 JavaScript 拥有动态类型，同时也意味着相同的变量可用作不同的类型： var x = 6; // x 为数字 var x = "Bill"; // x 为字符串 数据类型的分类 JS 把数据类型分为两类： 简单数据类型 （Number,String,Boolean,Undefined,Null）复杂数据类型 （object) 简单数据类型（基本数据类型） JavaScript 中的简单数据类型及其说明如下： 数字型 Number JavaScript 数字类型既可以用来保存整数值，也可以保存小数(浮点数）。 var age = 21; // 整数 var Age = 21.3747; // 小数 数字型进制
最常见的进制有二进制、八进制、十进制、十六进制。
// 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/137eb90477d13b05a24059c62a622e9a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/060ded8e7b139088398257dfe7461e2f/" rel="bookmark">
			React.js框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、框架介绍 基本介绍： React JS编写PC网页、React Native可以使用JavaScript, CSS和HTML创建原生移动应用支持原生ES6语法，并且提供了自定义的JSX语法，也就表明了难于原有系统重构可与其他框架开发并存，比如：支持原生Html+React组件脚手架创建项目： 初始化项目npx create-react-app my-app启动项目npm startJSX语法： 两种类型标签： html标签，以前在js里写html标签得加单引号，现在可以直接在js写普通的html标签组件标签，比如&lt;App /&gt;需要首字符大写占位组件：&lt;Fragment&gt;如果不需要JSX转义：dangerouslySetInnerHTML={{__html:this.state,content}}要在JSX语法里写JS的表达式，必须加花括号{item.id}注释：{/* 注释 */}数据驱动和事件绑定： 定义数据 ：this.stata = {inputValue:'hello world'} 取数据：value={ this.stata.inputValue }事件绑定：onChange={ this.fun.bind(this,index) } 在JSX中传递事件，onChange是函数在处理过程会丢失this，需要绑定对象的this还可以绑定很多其他的JS事件函数定义：fun(e,index) { this.setState( {inputValue : e.target.value} ) } setState方法是异步执行，第二个参数可以传入一个回调函数在渲染完成时执行List迭代：this.state.list.map( (value,index) =&gt; { return &lt;li key={index}&gt;{value}&lt;/li&gt; } )样式定义：className = 'input' import './style.css'组件拆分与组件传值： 组件传递内容：&lt;TodoItem content={value}/&gt; 也可传递函数组件接受内容：&lt;li&gt; {this.props.content} &lt;/li&gt; 都可以从this.props取值props、state和render函数： props可以获取到传递过来的属性、函数等，当props属性的值发生改变，render函数会被执行state代表组件里的数据，组件初始创建时 或 当state数据发生变更，render函数都会被执行一次render函数用来渲染组件中的内容ref对应JSX真实标签的dom结构： ref={ (button)=&gt; {this.buttonElem = button} } this.buttonElem就可以被索引到了ref写在html标签，获取的是dom节点ref写在组件标签上，获取的是组件的js实例生命周期函数： Initialization初始化，执行constructor构造器方法装载props和state数据 super(props); this.state = {};Mounting挂载阶段，执行render方法，以及相应的拦截componentWillMount和componentDidMount(适合用于发送ajax请求--axios库)Updation更新运行阶段，当props和states发生变化会执行相应的流程 props执行componentReceiveProps、shouldComponentUpdate、componentWillUpdate、render、componentDidUpdatestates执行shouldComponentUpdate、componentWillUpdate、render、componentDidUpdateUnmounting卸载阶段，当组件被移除的时候执行componentWillUnmount方法可以根据生命周期的方法去加一些额外的操作；Ant Design / Ant Design Pro组件库： 大量可以使用的组件可以直接使用，非常方便开发Layout页面布局、导航菜单、Icon图标、卡片、对话框、输入框、Message全局信息写style样式的时候需要注意优先级问题，!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/060ded8e7b139088398257dfe7461e2f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d4b18d3c47b6765dc4e1205d54077c4/" rel="bookmark">
			react中 modules.scss的基本使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.下载引入包 npm i scss -D
2.修改样式文件名 将css文件名改成后缀为 .module.scss （React脚手架中的约定，与普通 CSS 作区分）
3.组件中进行使用 导入 import styles from './index.module.scss' &lt;div className={styles.css类名}&gt;&lt;/div&gt; 4.最佳用法 每个组件的根节点使用 CSSModules 形式的类名（ 根元素的类名： root ）
其他所有的子节点，都使用普通的 CSS 类名 :global
index.module.scss
.root { display: 'block'; position: 'absolute'; // 此处，使用 global 包裹其他子节点的类名。此时，这些类名就不会被处理，在 JSX 中使用时，就可以用字符串形式的类名 // 如果不加 :global ，所有类名就必须添加 styles.title 才可以 :global { .title { .text { } span { } } .login-form { ... } } } 组件：
import styles from '.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d4b18d3c47b6765dc4e1205d54077c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09447044d8044144609e4ee07556e68b/" rel="bookmark">
			剑指 Offer 04. 二维数组中的查找
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 思路：
代码：
class Solution { public: bool findNumberIn2DArray(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) { if(matrix.empty() || matrix[0].empty()) return false; int i = 0,j = matrix[0].size() - 1; while(i &lt; matrix.size() &amp;&amp; j &gt;= 0) { int x = matrix[i][j]; if(x == target) return true; if(x &gt; target) j--; else i++; } return false; } }; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e0f67f5c4a96a71f11d4bd1d4a74b94/" rel="bookmark">
			React antd Table 实现单元格点击 表头斜线分组等功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先上成品示意图:
几个关键步骤: 一 定义数据结构: export const data = [ { key: 'row1', beforeUpdateLevel: '等级1', level_1: '保', level_2: '升', level_3: '升', level_4: '未设置', level: 1, // 表示当前行变更前为等级1 }, { key: 'row2', beforeUpdateLevel: '等级2', level_1: '降', level_2: '保', level_3: '升', level_4: '升', level: 2, }, { key: 'row3', beforeUpdateLevel: '等级3', level_1: '降', level_2: '未设置', level_3: '未设置', level_4: '升', level: 3, }, { key: 'row4', beforeUpdateLevel: '等级4', level_1: '降', level_2: '未设置', level_3: '未设置', level_4: '未设置', level: 4, }, ]; 二 实现表头分组: 利用column---&gt;title属性 实现表头对角线分组"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e0f67f5c4a96a71f11d4bd1d4a74b94/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c32f2f677f7df42c037a5496b0922a4b/" rel="bookmark">
			OkHttp源码解析（很细 很长）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 本文是对OkHttp开源库的一个详细解析，如果你觉得自己不够了解OkHttp，想进一步学习一下，相信本文对你会有所帮助。
本文包含了详细的请求流程分析、各大拦截器解读以及自己的一点反思总结，文章很长，欢迎大家一起交流讨论。
使用方法 使用方法十分简单，分别创建一个OkHttpClient对象，一个Request对象，然后利用他们创建一个Call对象，最后调用同步请求execute()方法或者异步请求enqueue()方法来拿到Response。
private final OkHttpClient client = new OkHttpClient(); Request request = new Request.Builder() .url("https://github.com/") .build(); //同步请求 Response response = client.newCall(request).execute(); //todo handle response //异步请求 client.newCall(request).enqueue(new Callback() { @Override public void onFailure(@NotNull Call call, @NotNull IOException e) { //todo handle request failed } @Override public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException { //todo handle Response } }); 基本对象介绍 正如使用方法中所述，我们先后构建了 OkHttpClient对象、Request对象、Call对象，那这些对象都是什么意思，有什么作用呢？这个就需要我们进一步学习了解了。
OkHttpClient 一个请求的配置类，采用了建造者模式，方便用户配置一些请求参数，如配置callTimeout，cookie，interceptor等等。
open class OkHttpClient internal constructor( builder: Builder ) : Cloneable, Call.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c32f2f677f7df42c037a5496b0922a4b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/abf8c923213ef7c9bfa17f63b1b1720d/" rel="bookmark">
			Ubuntu禁止内核更新及开机自动选择内核
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在日常使用中需要选择特定版的内核，可以使用以下方法禁用内核更新及开机自动选内核
禁止内核更新 sudo apt-mark hold linux-image-generic linux-headers-generic 开机自动选择内核 1、GRUB菜单介绍及手动切换内核
开机过程狂点键盘Esc键会进入GRUB菜单，选第0行会直接选择系统自带内核，这里我们选第1行
进入高级选项后会显示系统安装的所有内核，在这里可以选择你需要的内核，我这里选第4项
uname -a 查看下内核版本
2、开机自带选择内核
执行 sudo gedit /etc/default/grub 主要看GRUB_DEFAULT这一选项，在开机过程中GRUB菜单会有两级菜单，每级菜单的索引都是从0开始的，由上面手动切换内核一章中可知，我们需要切换的内核在 “Ubuntu 的高级选项”（索引：1）-&gt; “Ubuntu ,Linux 5.4.0-42-generic”(索引：4)中，故我们在GRUB_DEFAULT这一选项填 "1-&gt;4" 即可。
编辑完后执行 sudo update-grub 重新生成GRUB的启动菜单配置文件
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03e34f6d949bca0af9b69a0720d10c83/" rel="bookmark">
			在VS2017中打开VC&#43;&#43;6.0项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在VS2017中打开低版本项目 一：在VS2017中打开VC++6.0项目中的.dsw文件 二：选择自动升级 三：运行报错 解决方案 点击上方项目-&gt;属性-&gt;(C/C++)-&gt;代码生成 将 启用最小重新生成、启用函数级链接 都选择为是 四：运行报错 解决方案 点击上方项目-&gt;属性-&gt;配置属性-&gt;VC++目录 编辑包含目录与库目录 选择包含目录，点击出现的箭头-&gt;编辑 在计算的值中找到类似 C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt 复制前部分 C:\Program Files (x86)\Windows Kits\10\Include 接下来按如下图所示修改 选择库目录，点击出现的箭头-&gt;编辑 在计算的值中找到类似 C:\Program Files (x86)\Windows Kits\10\lib\10.0.10240.0\ucrt\x86 复制前部分 C:\Program Files (x86)\Windows Kits\10\lib 后续操作与修改包含目录一样。(一直找到x86文件夹) 最后，点击确定，运行，即可解决问题。 每台电脑的10.0.10240.0这串数字不一样，一定要修改为自己计算机的文件路径。 如果还有报错，可以尝试修改调试信息格式为程序数据库 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/995359c517aaf537f7b7edd3a3b69d81/" rel="bookmark">
			图的路径遍历和层级遍历
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图的路径遍历可以得到图的所有路径图，层级遍历可以得到这个图有多少层，方便我们系统逐级加载数据
程序的主要功能
输出路径图。首选获得所有的路径图，以list展示按层级展示(层级之间存在重复字段)。将这些路径图按层级进行归并。由于同一个字段可能以不同层级存在于一个字段，故两个层级之间存在重复字段)按层级展示。将第二步中的字段，从高层开始向下层开始遍历，如果存在重复字段，则删除底层的重复字段。 import lombok.Getter; import lombok.Setter; import lombok.ToString; /** * 节点 */ @Setter @Getter @ToString public class Node { /** * 唯一标识 */ private String id; // 其他字段自行补充 } import lombok.Getter; import lombok.Setter; import lombok.ToString; /** * 边 */ @Setter @Getter @ToString public class Edge { /** * 起点 */ private Node start; /** * 结束 */ private Node end; } import java.util.*; /** * 识别有向图中的所有路径 */ public class Graph { /** * 所有路径图 */ private List&lt;List&lt;Node&gt;&gt; allWay = new ArrayList&lt;&gt;(); /** * 通过线构建图 * * @param edgeList */ public Graph(List&lt;Edge&gt; edgeList) { Map&lt;Node, Set&lt;Node&gt;&gt; map = new HashMap&lt;&gt;(); Set&lt;Node&gt; startSet = new HashSet&lt;&gt;(); Set&lt;Node&gt; startSetBack = new HashSet&lt;&gt;(); Set&lt;Node&gt; endSet = new HashSet&lt;&gt;(); edgeList.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/995359c517aaf537f7b7edd3a3b69d81/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f3d086b739f4e517a9cb063acbc7f18/" rel="bookmark">
			微信图片怎样在pc 端打开查看并导出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微信是我们常用的交流工具，我们在平时聊天中会发送图片产生内存过大的问题，很多小伙伴对此非常头疼，那么我们该怎样处理哪，点点告诉小伙伴们在电脑端怎么去查看导出并删除的方法。
电脑端微信聊天中产生缓存图片该怎样查看？
微信只是把图片在咱们的手机中进行了缓存存储，存储的格式是一种数据文件格式。其后缀为.dat文件。需要解码才可以看到，平常打开都是乱码。只有转换成图片才可以查看。
电脑端微信聊天中产生缓存图片的存储在什么位置？
打开 WeChatImageDatEncryption.exe ，输入图片的位置按回车即可。
如果你没有修改过位置，原来的位置就是在 %USERPROFILE%\Documents\WeChat Files\你的微信名\data
如果确实不知道在哪里，可以打开微信设置，查看通用设置&gt;打开文件夹，在进入到 Data 目录即可。
解密出来的文件会放在 WeChatImageDatEncryption.exe 同级目录的 Data 文件夹里。
软件下载地址：http://www.sdxlp.cn/tool/wechatdat
（内有说明，普通人完全可以自己操作，自己的东西怎样要有点隐私不是？）
软件的好处：在不联网可视化的情况下，批量进行查看，导出，删除，保存。方便快捷，安全实用。
最近好多用过点点软件的小伙伴们，弄到点点的软件后，就是一张一张的给小伙伴们转图片，虽说花钱不多（一张1元），但是微信的缓存图片起码也要千张吧。这就不好啦。人要有良心呀！好东西分享不是让其做违法的事情。希望看到的小伙伴们不要再去上当受骗啦！
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/315/">«</a>
	<span class="pagination__item pagination__item--current">316/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/317/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>