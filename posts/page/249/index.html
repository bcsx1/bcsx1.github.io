<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03748bcd9fba8d085b5a6c8aed9d679a/" rel="bookmark">
			RPC和REST
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、背景 之前leader问我feign支持的是http的rest调用还是tcp/ip的rpc调用，这个问题其实我到现在都不是很清楚，只通过印象记得feign是基于http协议实现的，当时就回答了http，leader说feign确实是一个基于http远程调用服务框架，但是它也支持rpc，其实只要是像调本地接口一样调用远程接口的方式，就是rpc.要记住他们的区别但对于feign也不用把它们分的太死，不过要记住它是基于http协议实现的。
其实这段话当时我挺懵的，主要还是自己对于rpc和rest完全分不清，甚至觉得它们就是一样东西，那么现在就来分别学习一下以及它们之间的区别。
二、RPC调用 RPC是远程调用过程的简写，是一个协议，处于网络通信协议的第五层：会话层，其下就是TCP/IP协议，在建立在其基础上的通信会话协议。RPC定义了交互的模式，而应用程序使用这些模式，来访问其他服务器的方法，并不需要关系具体的网络上的细节。 2.1、RPC基础知识 1.RPC模式 ①RPC采用C/S模式，客户端发送请求，服务端响应。
服务器-客户机，即Client-Server(C/S)结构。C/S结构通常采取两层结构。服务器负责数据的管理，客户端负责完成与用户的交互任务。 ②基于底层的协议，比如TCP/IP模式。
RPC 不等同于 RPC 框架，RPC 是一个概念，是一个分布式通信方式基于 RPC 产生了很多 RPC 框架：Dubbo、Netty、gRPC、BRPC、Thrift、JSON-RPC 等等RPC 框架对 RPC 进行了功能丰富，包括：服务注册、服务发现、服务治理、服务监控、服务负载均衡等功能两台机器之间进行交互，那么肯定离不开网络通信协议，TCP / IP 也就成了绕不开的点，所以先辈们最初想到的方法就是通过 TCP / IP 来实现远程方法的调用 2.设计目的 ①通过固定的协议，调用非本机的方法
②实现不同程序语言之间的通信
③不需要了解底层协议，像本地方法一样调。它完全封装了网络传输，以及其他细节。
2.2、RPC过程详解 从RPC的角度看，应该有服务的提供方，即生产者；还有服务的调用方，即消费者。对消费者来时，在RPC调用过程中，使用第1步、第2步、第3步、第4步是透明的，其他的都是使用RPC框架去封装这些事情。当应用开始调用RPC的方式时，就会去容器中去取Bean对象，所以我们应该首先注册Bean对象到容器中，我们通过Java的动态代理，将代理过程封装到代理对象中，代理对象实现接口，创建实例到容器中。相应的，在调用远程对象的对象方法时，就会调用动态代理中的方法，这就是代理层的作用。代理对象在获取到请求方法、接口和参数时，就会用序列化层，将这些信息封装成一个请求报文，再让通信层向服务端传送报文的内容，然后就到了生产者这块。相应的服务必须有个监听器，来监听来自其他服务的请求，一般都会用容器做消息的监听，就会调用对应的Bean对象的方法，去处理响应的请求。当然，RPC框架不会让容器中的每一个框架都会被调用，所以只有注册了的Bean才会被RPC的请求调用到。然后，通过请求中的类、方法、参数，反射调用对应的Bean，拿到结果之后，通过序列化层，封装好结果报文，服务端的通信层将报文反馈给调用方，调用方解析到返回值，动态代理类返回结果，调用结束。这样，一个完整的RPC调用反馈链条就完成了。 2.2.1、消费者设计 ①代理层：
消费者将对应的接口，通过RPC框架的代理来生成一个对象到Spring容器中。代理层将代理接口生成该接口的对象，该对象处理调用时传过来的对象、方法、参数，通过序列化层封装好，调用网络层。 ②序列化层：
将请求的参数序列化成报文；将返回的报文反序列化成对象； ③网络层：
将报文与服务端通信；接收返回结果。 2.2.2、生产者设计 ①代理层：
一个应用提供服务，必须有一个网络监听的模块，这个模块大多有开源的容器来处理网络上的监听；服务需要注册，只有注册了的服务才可以被调用；注册的服务需要被我们发射调用到，来进行相应的处理。
②序列化层：
就是相应的做请求的反序列化和结果的序列化。
③网络层：
接收客户端报文；将序列化的结果返回给客户端。
2.3、RPC模式总结 2.3.1、模块设计 1.Proxy代理层
用于对象的代理；对象的反射调用；RPC流程的控制。
2.Serialize序列化层
将请求序列化和结果反序列化。
3.Invoke网络模块
主要用于网络通信的相关处理。
4.Container容器组件
这层主要用于代理层监听网络请求。
组成要素 ①三要素：动态代理、序列化与反序列化协议、网络通信协议
②网络通信协议可以是 TCP、UDP，也可以是 HTTP 1.x、HTTP 2，甚至有能力可以是自定义协议
2.3.2、RPC 的演进过程
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/03748bcd9fba8d085b5a6c8aed9d679a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2015acd2e9970acf27740e22d2953409/" rel="bookmark">
			第三方库下载教程（三种方法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、利用Python中的pip进行第三方库的下载
首先我们要搞清楚Python中的pip是个什么东东？pip是一个安装和管理 Python包的工具，可以对python的包进行管理和升级等操作。
具体的方法如下：1、首先是要找到python安装中自带的pip的路径在哪个地方，(我是默认安装的Python3.6，Python中默认的路径为
C:\Users\lenovo\AppData\Local\Programs\Python\Python36\Scripts\pip)
注：如果忘记安装在哪个地方了，可以在电脑里进行全盘搜索Python\Python36\Scripts；
2、打开命令提示符(cmd)，输入路径C:\Users\lenovo\AppData\Local\Programs\Python\Python36\Scripts
\pip install backages(需要下载第三方库的名字)，进行下载。
二、利用PyCharm直接下载
PyCharm是一个Python使用者常用的python IDE(集成开发环境)，带有一整套可以帮助用户在使用Python语言开发时提高其效率的工具，比如调试、
语法高亮、Project管理、代码跳转、智能提示、自动完成、单元测试、版本控制。此外，该IDE提供了一些高级功能，以用于支持Django框架下的专业
Web开发。
1、PyCharm的下载与安装这里就不进行展示，安装好PyCharm后，在菜单栏中点击【File】——【Settings】——【Project：mycode】——【Project Interpreter】，在【Project Interpreter】中选择自己的Python版本，在这样就可以看到本Python版本所安装的第三方库，点击右侧的【+】，进行添加；
2、在搜索栏中输入需要下载的第三方库名称，选择好后，点击【Install Package】，等待下载完成即可。
三、简单粗暴方法(直接插入式……)
直接插入，在这里可不要想歪了哦 ^-^ ! 如果前两种方法都出错了，那就只能简单粗暴霸王硬上弓了，搜索想要安装的第三库的官网进行第三方库包的下载(如果不知道官网，可按照第二种方法在PyCharm中点击需要下载的库，在信息栏中会出现开发者以及官网信息，直接点击网址即可弹出官网)下载并好库包后，把文件夹直接复制到Python的安装目录文件【Lib】下即可(以本人为例C:\Users\lenovo\AppData\Local\Programs\Python\Python36\Lib)。在这里提供一个网站，大部分的Python第三方库都可以在这里下载*.whl文件。
这里以Twisted第三方库为例：
1、打开网页：https://www.lfd.uci.edu/~gohlke/pythonlibs/，在网页中搜索Twisted，如图所示，选择好Python的对应版本进行下载即可；
2、把下载好后的Twisted-18.4.0-cp36-cp36m-win_amd64.whl文件的后缀名.whl改为.zip，然后会得到文件夹，把文件夹里面的内容复制到到Python的安装目录文件【Lib】下即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/adcc9029c56ff795e515efad3645314f/" rel="bookmark">
			软件测试---缺陷、缺陷报告
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		软件缺陷基础概念 定义 从内部看，软件确认是产品开发或者维护过程中存在的错误、毛病等各种问题
从外部看，软件缺陷是系统所需要实现的某种功能的失效或者违背
总的来说，缺陷就是问题，最终表现为所需要的功能没有完全实现，没有满足用户的需求
具体包含（程序、数据、文档） 未达到需求规格说明书中的功能
出现了需求规格说明书中指明不会出现的错误
功能超出了需求规格说明书的范围
未达到需求规格说明书中虽然没有指明，但应该到达的目标
测试人员或者用户认为软件难以理解、不易使用、运行速度慢或最终用户认为不好
表现形式 功能、特性没有实现或者部分实现
设计不合理、功能特性不明确、逻辑不清楚或者存在矛盾
产品实际结果和所期望的结果不一致
没有达到需求规格说明书所规定的性能指标
运行出错、中断、崩溃、界面混乱
数据不正确、精度不够、不完整、格式不统一
用户不能接受的其他问题，超时、界面丑陋
硬件或者系统软件上存在的其他问题
缺陷产生的原因 缺陷不可避免，主要原因如下：
需求解释或者记录错误，用户需求定义错误，需求说明存在错误，编码说明、程序代码有误，硬件或者系统存在错误，文档错误、内容不正确、拼写错误
缺陷产生的根源 交流不充分、软件的复杂性、开发任务的错误、需求的变化、进度压力
缺陷的修复费用 说明测试应该尽早介入
缺陷报告介绍 在测试后，如果发现缺陷，则应该进行缺陷报告
缺陷报告的一些字段及说明 缺陷ID：唯一的缺陷ID，可以根据该ID追踪缺陷
缺陷状态：缺陷状态指缺陷通过一个跟踪修复过程的进展情况
缺陷标题：描述缺陷的标题
缺陷的严重程度：对软件产品的影响程度，分致命、较严重、严重、一般、低
缺陷的优先级：缺陷修复的先后顺序，即那些缺陷优先修正，哪些稍后
缺陷的所属模块：缺陷所属的项目和模块，要能较精确的定位至模块
缺陷记录着：提交缺陷的人员姓名
缺陷提交时间：缺陷提交的时间
缺陷处理人：处理缺陷的处理人
处理结果描述：对处理结果的描述，描述处理情况和代码修改说明
缺陷处理时间：缺陷处理的时间
缺陷验证人：对被处理缺陷验证的验证人（回测者）
验证结果描述：对验证结果的描述（通过、不通过）
缺陷详细描述：缺陷的复现步骤
缺陷环境说明：对测试环境的描述
必要的附件：如涉及到附件的或错误现象的图片等
缺陷报告有如下作用 记录测试结果、方便开发人员进行缺陷的定位、为后期统计缺陷提供依据
缺陷报告内容 缺陷的状态 状态变化 new：测试人员发现缺陷
assigned：由开发经理或者其他人员，将修复职责指定为某位开发人员
开发人员阅读缺陷报告，可能得到如下结果
open：测试人员是正确的，准备修复
dupllcate：与其他bug为同一原因，修正好一个后，这个也就修复了
reject：测试人员理解错误，其实这不是bug
flxed：经过一段时间开发人员修复了bug，就会标记为此状态
postpone：小问题，目前没有时间修复
4. 测试人员检验缺陷状态
closed：再次测试，发现错误已经修复
closed reject的错误，经过沟通核实后，确认无需修复
reopen：原来修复后的缺陷，经过回归测试后又出现了，标记原先的缺陷为此状态
缺陷的跟踪 要点：缺陷从测试人员开始，也应该由测试人员结束
严重程度 严重程度分为五个等级：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/adcc9029c56ff795e515efad3645314f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6b0c4a5362caa5e86b1981839c39e53/" rel="bookmark">
			空间复杂度计算超全整理！！（一起手撕复杂度计算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		承接上文：算法效率与时间复杂度(8条消息) 时间复杂度计算超全整理！！（数据结构和算法的第一步_vpurple__的博客-CSDN博客
目录
0.前言
1.空间复杂度
1.1 大O的渐进表示法
1.2举几个计算空间复杂度的例子
1.2.1 计算冒泡排序的空间复杂度
1.2.1计算阶乘递归的时间复杂度
1.2.3计算用数组实现还有用变量实现的斐波拉契数列的空间复杂度
1.2.4计算用递归实现的斐波拉契数的空间复杂度
2.常见复杂度的对比
0.前言 相比而言现在算法不那么关注空间复杂度，因为现在的设备的存储空间都比较大。
1GB=1024*1024*1024字节 1GB 大概是10亿字节
1MB 大概是100万字节
1GB=1024MB 1MB=1024KB 1KB=1024字节
1.空间复杂度 空间复杂度也是一个数学表达式，是对一个算法在运行过程中临时占用存储空间大小的量度 ，也就是额外占取的空间的大小。
空间复杂度不是程序占用了多少bytes的空间，因为这个也没太大意义，所以空间复杂度算的是变量的个数。 空间复杂度计算规则基本跟实践复杂度类似，也使用大O渐进表示法。 注意：函数运行时所需要的栈空间(存储参数、局部变量、一些寄存器信息等)在编译期间已经确定好了，因此空间复杂度主要通过函数在运行时候显式申请的额外空间来确定。
1.1 大O的渐进表示法 大O符号（Big O notation）：是用于描述函数渐进行为的数学符号。
O()括号里面的数更多的表达的是这个算法的量级，大O是一个估算，并不是准确的执行次数。
推导大O阶方法：
1、用常数1取代运行时间中的所有加法常数。
2、在修改后的运行次数函数中，只保留最高阶项。
3、如果最高阶项系数存在且不是1，则去除与这个项目相乘的常数。得到的结果就是大O阶。
1.2举几个计算空间复杂度的例子 1.2.1 计算冒泡排序的空间复杂度 // 计算BubbleSort的空间复杂度？ void BubbleSort(int* a, int n) { assert(a); for (size_t end = n; end &gt; 0; --end) { int exchange = 0; for (size_t i = 1; i &lt; end; ++i) { if (a[i - 1] &gt; a[i]) { Swap(&amp;a[i - 1], &amp;a[i]); exchange = 1; } } if (exchange == 0) break; } } 冒泡排序的空间复杂度为：O(1)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d6b0c4a5362caa5e86b1981839c39e53/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e8b0beb5a62f7deb21c935a3f922c77/" rel="bookmark">
			【动态系统的建模与分析】频率响应与滤波器-笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Part 1
对于一个线性时不变系统来说，当一个正弦信号通过它时，在稳定的状态下，系统的输出和输入的频率相等。
我们假设一个输入信号为：则输出为：
其中，
比如我们有一个输入为sin0.5t，经过一线性变换、一个积分、一个2的扩大器，就变成了
在图中的表达为：
下面来计算一下，上边的两个响应。
先从正弦波的一般形式入手。
有一个正弦波：
若，那么上式
这就是一个一般的表达形式。
对于一个系统来说，传递函数框图为
而输出 ，输入就是把输入的时间信号做Laplace变换，得
而
对稳定系统来说，
求解k1，k2。
要用到
则
这里要用到欧拉公式：
代入将这两式上式得，
结论：
如积分的Laplace变换为 ，把s=jw代入，得G(jw)
比如
我们还可以看出来，它的振幅响应为，也就是说，当w越大、频率越高时，振幅响应就越低，所以说它是一个低通的滤波器。（低频率的信号可以通过它，而高频率的信号就会被衰减的非常小）
Part 2
上节的重要结论：
应用该结论分析一下一阶系统的频率响应。寻找现象背后的本质。
例子：
它的模为
对于相位变化来说，
在图中的表达为
重点来看振幅响应。
由包含截止频率的图可以看出，这就是一个 在现实生活中有很多这样的例子。
比如冬天在屋里开空调制造热量，室内的温度变化就是一个一阶系统，它对高频的输入就不敏感，假如这时候把空调迅速开关关开，去测量室温，也会是比较平缓的变化，而不是反映出一个高频的输入。
再比如前边介绍过的流体系统，也是一阶系统，水龙头不停的开关关开，液面高度也是平缓变化。
或者说典型的这种电阻电容系统。
它们系统内都带有一种容器，房间、水箱、电容。
从数学角度来讲，这些容器就是“积分”。
而积分的拉氏变换就是 。
如果把s=jw代入，可以看出它的振幅响应其实等于 可以看出w增大，振幅减小。
所以容器带来一种缓冲机制，产生一个延迟。
matlab——simulink
最后再来分析一下频率响应。
这样一个高通滤波器。
可以把反推出的传递函数在simulink里自己做一下看看。
最后，如果把图上的纵坐标改为20log|G(jw)|，则纵坐标数值变为...，这就是博德图
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6bbc3b53dcf37bae046371b3333e9190/" rel="bookmark">
			python第一课（python是什么）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.Python是一门解释性脚本语言
解释性语言：解释型语言，是在运行的时候将程序翻译成机器语言；解释型语言的程序不需要在运行前编译，在运行程序的时候才翻译，专门的解释器负责在每个语句执行的时候解释程序代码，所以解释型语言每执行一次就要翻译一次，与之对应的还有编译性语言。
编译性语言：编译型语言写的程序执行之前，需要一个专门的编译过程，把程序编译成为机器语言的文件，比如exe文件，以后要运行的话就不用重新翻译了，直接使用编译的结果就行了（exe文件），因为翻译只做了一次，运行时不需要翻译，所以编译型语言的程序执行效率一般来说较高。
脚本语言：脚本语言又被称为扩建的语言，或者动态语言，是一种编程语言，用来控制软件应用程序，脚本通常以文本（如ASCII)保存，只在被调用时进行解释或编译。所以一般使用Python来实现特定功能而不是较为复杂的后端。
2.Python是一门跨平台、脚本以及开发应用的编程语言
跨平台：跨平台概念是软件开发中一个重要的概念，即不依赖于操作系统，也不依赖硬件环境。一个操作系统（如Windows）下开发的应用，放到另一个操作系统(如Linux)下依然可以运行。
开发应用：Python较为简单，无法支撑起太复杂的结构，只能用来实现简单功能。
3.Python通常应用于文本处理、数据处理、爬虫、科学计算和统计
由于Python 较为简单，一般无法进行复杂的后端搭建，所以该语言通常用来进行一些简单的文本处理、数据处理等操作。
爬虫：网络爬虫（又称为网页蜘蛛，网络机器人，在FOAF（Friend-of-a-Friend）社区中间，更经常性的被称为网页追逐者），是一种按照一定的规则，自动地抓取万维网信息的程序或者脚本。另外一些不常使用的名字还有蚂蚁、自动索引、模拟程序或者蠕虫。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/939f6526078af0d5c9e30140936af952/" rel="bookmark">
			python和第三方库下载讲解（大家不要误会这个文章和别人的一样，但是那个人就是我以前的号，那个号注销了。）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python的下载安装 1.进入Python的官网， Download Python | Python.org ，这里以下载Windows的Python为例
2.选择下载的版本是3.9.9，双击下载，注意：最新的Python 3.9.9，要求是windows 7以上才行
3.下载完成后点击运行，会出现安装界面，选择Upgrade Now
这个是默认安装路径：C:\Users\fang\AppData\Local\Programs\Python\Python39
每个人都不一样的，要记住自己的安装路径，待会配置环境变量的时候要用到
等待安装
4.出现这个界面就代表安装成功了，点击close
5.运行Python
安装成功后，打开命令提示符窗口（win+R,输入cmd回车），输入python后，如果出现
python’ 不是内部或外部命令，也不是可运行的程序或批处理文件。 说明还没有配置环境变量
配置环境变量 1.先把点击查看，把“隐藏的项目”勾上
2.找到python的安装路径，按照各自的安装路径来，Ctrl+C复制这个路径
3.配置环境变量
步骤：右键此电脑–&gt;选择属性–&gt;选择高级系统设置–&gt;选择右下角的环境变量
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25e9425286eef3d2352ab5aba232db35/" rel="bookmark">
			CSS3实现10种Loading效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CSS3实现了几种常见的Loading效果，都是用html+css实现
第一种：
&lt;div class="loading"&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;/div&gt; .loading{ width: 80px; height: 40px; margin: 0 auto; margin-top:100px; } .loading span{ display: inline-block; width: 8px; height: 100%; border-radius: 4px; background: lightgreen; -webkit-animation: load 1s ease infinite; } @-webkit-keyframes load{ 0%,100%{ height: 40px; background: lightgreen; } 50%{ height: 70px; margin: -15px 0; background: lightblue; } } .loading span:nth-child(2){ -webkit-animation-delay:0.2s; } .loading span:nth-child(3){ -webkit-animation-delay:0.4s; } .loading span:nth-child(4){ -webkit-animation-delay:0.6s; } .loading span:nth-child(5){ -webkit-animation-delay:0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/25e9425286eef3d2352ab5aba232db35/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e48132971047124a0bc51434ed0a9fc2/" rel="bookmark">
			怎么获取某一个dom元素滚动到底部
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		直接看例子
一个表格，在tbody添加了y方向的滚动，并且隐藏了滚动条。
.center_table .right table { width: 100%; border-collapse: collapse; text-align: center; margin-top: 10px; margin-right: 10px; } .center_table .right table thead { display: table; width: 100%; table-layout: fixed; } .center_table .right table tbody { display: block; height: 100px; overflow-y: scroll; -ms-overflow-style: none; /**ie**/ } /**谷歌的隐藏滚动条**/ .center_table .right table tbody::-webkit-scrollbar { display: none; } .center_table .right table tbody tr { display: table; width: 100%; table-layout: fixed; } .center_table .right table tr td { font-size: 10px; font-weight: 600; color: white; padding-left: 10px; padding-top: 3px; } 我在这用js添加了一个自动滚动，那就涉及到滚动到底部的时候要重新回到顶部。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e48132971047124a0bc51434ed0a9fc2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c29fb5df75ca968da2f469208d5fe27/" rel="bookmark">
			怎么判断setInterval的运行状态（是否停止）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		接上篇
补充，有了自动滚动，让他点击的时候停止滚动，再点击继续滚动。怎么实现呢，就想到了setInterval和clearInterval。
添加点击事件：
$(document).ready(function() { let stop1 = setInterval(autoScroll1, 100) //滚动的 $('#autoScroll1').click(function() { // console.log(stop1) if (stop1 != "autoScroll1") { clearInterval(stop1) stop1 = "autoScroll1"; } else { stop1 = setInterval(autoScroll1, 100) } }) function autoScroll1() { document.getElementById('autoScroll1').scrollTop += 1; // let max = document.getElementById('autoScroll1').scrollHeight - (document.getElementById('autoScroll1').screenTop + document.getElementById('autoScroll1').clientHeight); let autoScroll1 = document.getElementById('autoScroll1') //判断是否到滚动条底部，误差为1px let a = autoScroll1.scrollHeight; let b = autoScroll1.scrollTop; let c = autoScroll1.clientHeight; if (b + c &gt;= a - 1) { document.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c29fb5df75ca968da2f469208d5fe27/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1810a373200c294b41bd30b06452bcf/" rel="bookmark">
			ubuntu 同时使用无线网卡和有线网卡
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载于这位博主：文章
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03ec539190313742acf5a27025efb6e3/" rel="bookmark">
			Qt提升自定义控件，找不到头文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Qt提升自定义控件，找不到头文件 问题描述：我自定义了一个搜索控件SearchEdit，然后把一个普通的lineEdit提升为SearchEdit，编译的时候提示我找不到头文件 解决方案：去掉全局包含（只想解决问题的看到这应该就可以解决了，下面是原因分析）
原因分析：双击查看找不到的头文件，发现是include&lt;SearchEdit.h&gt;,这里注意，include&lt;&gt;这种方式头文件不是从当前项目去查找头文件，而是从QT的include头文件去找，这当然找不到，所以我手动改为include"SearchEdit.h",运行确实没问题了，但是这个ui文件是qt自动生成的，我改动界面的时候，这个编译器又把我之前修改的文件给还原了
既然不能修改这，那只能修改界面了，在界面找找有没有关于头文件包含的选项，仔细查找，果然有：
我把这里的全局包含去掉，include&lt;SearchEdit.h&gt;就变成include"SearchEdit.h"了，也就不会报错了
总结：
ui_xxx.h全局包含的时候就是 &lt;&gt;
#include &lt;xxxxxx.h&gt;
不打勾就是 “”
#include “xxxxx.h”
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0c72c8ef56ced45856e1f58b2fbe570/" rel="bookmark">
			mac怎么设置锁屏壁纸，锁屏壁纸和屏幕壁纸不同
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mac屏幕壁纸和锁屏壁纸默认只能设置成一样的，但是有时候我们希望屏幕壁纸和锁屏壁纸不一样，那怎么设置呢？跟紧下面的步骤。
第一步，设置一个屏幕保护程序： 1、点击左上角的 → 系统编好设置： 2、打开“桌面与屏幕保护程序”设置项： 3、选择“屏幕保护程序” 4、选择一个你觉得很棒的屏保： 5、点击“触发角“，设置一个触发角，这样召唤屏保就很方便了： 6、设置触发角，我是设置在右上角的，大家可以按照自己的需求进行设置： 这样屏幕保护就设置好了，也就是我们的第一步。
第二步，设置开启屏保立即锁屏： 1、依然是在系统偏好设置中，打开“安全性与隐私”：
2、可以看到“进入睡眠或开始屏幕保护程序……后要求输入密码”，默认是5分钟：
3、将时间设置为“立即”：
4、这时候如果需要输入密码，输入即可。
大功告成。后面想改变锁屏壁纸，只要改变屏幕保护程序即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf27086e5b653127857862a7604ef5d1/" rel="bookmark">
			linux命令详解3
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		linux命令详解3 linux命令详解3cat （查看文件内容）more和lesshead和tailwcgrep （过滤文本中内容，文本三剑客：sed、awk、grep）压缩打包（gzip、bzip2）gzipbzip2 tar（归档）vim（文本编辑器，win的office word，写字，改内容） linux命令详解3 cat （查看文件内容） 格式：cat 文件名
选项：
-n：显示行号
-A：显示隐藏字符
-b：空行不标序号
“-s”：压缩空行，将多行压缩成一个空行
cat，可以一次看多个文件，谁在前面就先显示
more和less more：
格式：more 文件名
空格：向下一页
回车：向下一行
b：向上 q：退出
less：
格式：less 文件名
空格：向下一页
回车：向下一行
b：向上 q：退出
“/”：查找内容（n：向下，大N向上查找）
head和tail head:
tail：默认显示末尾10行
-n：指定看的行数
tail -f：实时动态跟踪，默认每秒刷新后10行
wc 统计 文件的信息
选项：
-l：显示行
-w：单词数（不是真正的单词）
-c：字节数（空格、tab、回车都占字节数）
grep （过滤文本中内容，文本三剑客：sed、awk、grep） grep配合正则表达式使用
通配符和正则表达式的区别：
通配符：匹配文件名正则表达式：匹配文本中的内容 作用：过滤你想要的文本信息
用法：
选项：
-i：查找时忽略条件的大小写
-v：反向查找
-n：显示行号
-r：递归过滤文件夹中的所有文件
-o：只匹配你想要的东西
标准输入：你用键盘输入的字符
标准输出：屏幕上返回显示的结果，管道符后的命令要支持标准输出
正则表达式：
”^以什么开头“放最前
”$ 以什么结尾”放最后
“^$”表示空白行
压缩打包（gzip、bzip2） gzip 解压缩：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf27086e5b653127857862a7604ef5d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05065226279481e46cc7260bcb49d207/" rel="bookmark">
			XML 外部实体 (XXE) 漏洞及其修复方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是 XXE 攻击？ XXE（XML 外部实体注入）是一种常见的基于 Web 的安全漏洞，它使攻击者能够干扰 Web 应用程序中 XML 数据的处理。 虽然 XML 是开发人员用来在 Web 浏览器和服务器之间传输数据的一种非常流行的格式，但这导致 XXE 成为一个常见的安全漏洞。
XML 需要一个解析器，这通常是漏洞发生的地方。XXE 允许根据文件路径或 URL 的内容来定义实体。当服务器读取 XML 攻击载荷时，会解析外部实体，合并到最终文档中，并将其与内部敏感数据一起返回给用户。 XXE 攻击可能导致内部网络内的端口扫描、服务器端请求伪造 (SSRF)、数据泄露、使用组织的服务器执行拒绝服务 (DoS) 等。因此，实施XXE 预防策略很重要。
这是有关应用程序安全性的一系列广泛指南的一部分
在本文中：
XXE 攻击类型（附代码示例） 十亿笑攻击XXE SSRF 攻击盲目的 XXE 漏洞如何防止 XXE 漏洞 Java中的XXE漏洞PHP 中的 XXE 漏洞Python中的XXE漏洞其他预防技巧XXE 漏洞的真实例子XXE 保护与 Bright XXE 攻击类型（附代码示例） 十亿笑攻击 考虑一个接受 XML 输入并输出结果的 Web 应用程序。请求如下所示：
要求POST http://example.com/xml HTTP/1.1
&lt;mytype&gt;
Hello and welcome to my website!
&lt;/mytype&gt;回复HTTP/1.0 200 OK
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05065226279481e46cc7260bcb49d207/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4614972ad036c9d0e2b1ad394d622785/" rel="bookmark">
			ADB命令用法大全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、ADB简介 Android Debug Bridge，安卓调试桥，它借助adb.exe（Android SDK安装目录platform-tools下），用于电脑端与模拟器或者真实设备交互；使用adb命令需安装Android SDK，并配置环境变量；它是一个C/S架构的应用程序，由三部分组成：
adb client：运行在PC上（为DDMS即IDE工作）adb daemon：守护进程，运行于Emulaoradb server：服务进程，运行在PC，管理adb client和adb daemon之间的通信 server与client通信的端口是5037，adb server与emulator交互时使用的端口有两个：
5554专门用于与Emulator实例的连接5555专门用于与daemon连接 二、常用命令 1.基础用法 查看adb版本： adb version重启adb服务：adb kill-server adb start-server进入shell模式：adb shell退出shell模式：exit查看连接本台PC的设备列表：adb devices（unknown-没有设备；device-连接正常；offline-离线；unauthorized-未认证、需手动在手机上同意授权）查看连接本台PC的设备列表（只展示设备ID）：adb get-serialno 2.安装包相关 安装apk：adb install 安装包路径\包名保留缓存和数据安装：adb install -r 安装包路径\包名卸载apk，不保留数据和缓存：adb uninstall 包名卸载apk，留数据和缓存：adb uninstall -k 包名清除应用数据及缓存：adb shell pm clear 包名查看当前设备已安装的apk列表：adb shell pm list packages -s查看当前设备已安装的第三方apk列表：adb shell pm list packages -3 3.文件相关 电脑push文件到手机：adb push D:/a.txt /sdcard/从手机拉取文件：adb pull /mnt/sdcard/51zxw.txt D:\a.txt 4.截屏录屏 截屏：adb shell screencap /sdcard/sca.png录屏：adb shell screenrecord /sdcard/scr.mp4录屏，指定分辨率：adb shell screenrecord --size 1280*720 /sdcard/scr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4614972ad036c9d0e2b1ad394d622785/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/690df7108b02fd6fd188641fde3fa3ae/" rel="bookmark">
			【图论算法】最小生成树 (Prim 算法、Kruskal 算法)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一个无向图G 的最小生成树(minimum spanning tree) 就是由该图的那些连接 G 的所有顶点的边构成的树，即在最小生成树中边的条数为 |V| - 1，且其总的值最低。最小生成树存在当且仅当 G 是连通的。虽然一个强壮的算法应该指出 G 不连通的情况，但是我们还是假设 G 是连通的。
对于最小生成树问题，贪婪的做法是成立的，这里介绍两种算法，它们的区别在于最小（值的）边如何选取上。
Prim 算法 在该算法的任一时刻，我们都可以看到一组已经添加到树中的顶点，而其余顶点尚未加到树上。此时，算法在每一阶段都可以通过选择边(u, v)，使得(u, v) 的值是所有 u 在树上但 v 不在树上的边的最小值，从而找出一个新的顶点并将它添加到这棵树中。
图1 无向图G 对于图1 中的无向图 G，图2 指出了该算法如何从 v1 开始构建最小生成树。开始时，v1 在构建中的树上，它作为树的根但是没有边。每一步添加一条边和一个顶点到树上。
图2 在每一步之后的 Prim 算法 我们可以看到，Prim 算法基本上与求最短路径的 Dijkstra 算法相同。因此，和前面一样，我们对每一个顶点保留值 dv 和 pv 以及一个指标，标示该顶点是 known 的还是 unknown 的。这里，dv 是连接 v 到一个 known 顶点的最短边的权，而 pv 则是导致 dv 改变的最后的顶点。算法其余部分完全一样，只有一点不同：由于 dv 的定义不同，因此它的更新法则也不同：在每一个顶点 v 被选取之后，对于每一个邻接到 v 的unknown 的 w，dw = min(dw, vw,v)。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/690df7108b02fd6fd188641fde3fa3ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86f1071e10d87feffefa24a06c7c970c/" rel="bookmark">
			线程池的实现原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系统学习性，移步 IT-BLOG
线程池做的工作主要是控制运行的线程数量，处理过程中将任务放入队列，然后在线程创建后启动这些任务，如果线程数超过了最大数量超出数量的线程排队等候，等其他线程执行完毕，再从队列中取出任务来执行。
什么是线程池 线程池（Thread Pool）是一种基于池化思想管理线程的工具，经常出现在多线程服务器中，如MySQL。线程过多会带来额外的开销，其中包括创建销毁线程的开销、调度线程的开销等等，同时也降低了计算机的整体性能。线程池维护多个线程，等待监督管理者分配可并发执行的任务。这种做法，一方面避免了处理任务时创建销毁线程开销的代价，另一方面避免了线程数量膨胀导致的过分调度问题，保证了对内核的充分利用。
Java 中的线程池是运用场景最多的并发框架，几乎所有需要异步或并发执行任务的程序都可以使用线程池。在开发过程中，合理地使用线程池能够带来4个好处：
1）、降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。
2）、提高响应速度。当任务达到时，任务可以不需要等到线程创建就能立即执行。
3）、提高线程的可管理性线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。但是，要做到合理利用线程池，必须对其实现原理了如指掌。
4）、提供更多更强大的功能：线程池具备可拓展性，允许开发人员向其中增加更多的功能。比如延时定时线程池ScheduledThreadPoolExecutor，就允许任务延期执行或定期执行。
线程池解决的问题是什么 线程池解决的核心问题就是资源管理问题。在并发环境下，系统不能够确定在任意时刻中，有多少任务需要执行，有多少资源需要投入。这种不确定性将带来以下若干问题：
【1】频繁申请/销毁资源和调度资源，将带来额外的消耗，可能会非常巨大；
【2】对资源无限申请缺少抑制手段，易引发系统资源耗尽的风险；
【3】系统无法合理管理内部的资源分布，会降低系统的稳定性；
为解决资源分配这个问题，线程池采用了“池化”（Pooling）思想。池化，顾名思义，是为了最大化收益并最小化风险，而将资源统一在一起管理的一种思想。在计算机领域中的表现为：统一管理IT资源，包括服务器、存储、和网络资源等等。除了线程池，还有其他比较典型的几种使用策略包括：
【1】内存池(Memory Pooling)：预先申请内存，提升申请内存速度，减少内存碎片。
【2】连接池(Connection Pooling)：预先申请数据库连接，提升申请连接的速度，降低系统的开销。
【3】实例池(Object Pooling)：循环使用对象，减少资源在初始化和释放时的昂贵损耗。
线程池核心设计与实现 Java中的线程池核心实现类是 ThreadPoolExecutor，还有一个工具类 Excutors。本章基于JDK 1.8的源码来分析Java线程池的核心设计与实现。我们首先来看一下 ThreadPoolExecutor的UML类图，了解下ThreadPoolExecutor的继承关系。
ThreadPoolExecutor 实现的顶层接口是Executor，顶层接口 Executor提供了一种思想：将任务提交和任务执行进行解耦。用户无需关注如何创建线程，如何调度线程来执行任务，用户只需提供 Runnable对象，将任务的运行逻辑提交到执行器(Executor)中，由 Executor框架完成线程的调配和任务的执行部分。
ExecutorService接口增加了一些能力：（1）扩充执行任务的能力，补充可以为一个或一批异步任务生成 Future的方法；（2）提供了管控线程池的方法，比如停止线程池的运行。
AbstractExecutorService则是上层的抽象类，将执行任务的流程串联了起来，保证下层的实现只需关注一个执行任务的方法即可。最下层的实现类 ThreadPoolExecutor实现最复杂的运行部分。
ThreadPoolExecutor将会一方面维护自身的生命周期，另一方面同时管理线程和任务，使两者良好的结合从而执行并行任务。
线程池生命周期 线程池运行的状态，并不是用户显式设置的，而是伴随着线程池的运行，由内部维护。线程池内部使用一个32 位的整数维护两个值：运行状态(runState)和线程数量 (workerCount) 两个参数维护在一起，其中高 3位用于存放线程池状态，低 29 位表示线程数（CAPACITY）。如下代码所示：
// 状态 RUNNING 线程数 = 0 private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0)); // 这里 COUNT_BITS 设置为 29(32-3)，意味着前三位用于存放线程状态，后29位用于存放线程数 private static final int COUNT_BITS = Integer.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/86f1071e10d87feffefa24a06c7c970c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fee1424a639af43657bde6b570eb4825/" rel="bookmark">
			如何写好一份程序员简历实习经历，实用技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很多小伙伴都反映说自己在简历上有一段或几段实习经历，投出去却总是简历被挂，明明自己实力不差，但总是得不到hr的欣赏。其实在hr筛选简历的过程中，喜欢那种简洁明了突出重点能让面试官看一眼就了解你的简历。那种长篇大论却毫无主线的简历是hr们最不喜欢的，试问你是一位面试官，每天要看几十上百份简历，每一份简历都要仔细帮你找重点，看得不心累吗。 写简历TIPS：
1.简历中的重点信息，要有选择地突出，如求职意向/荣誉奖项/实习岗位和重点工作内容，要让HR扫过去，就能马上捕捉到。
2.甚至有些重要内容可以直接加粗，简历一定要符合人的阅读习惯，不要太花里胡哨，建议直接按从上到下的方式以此排列，重点内容在前面，
3.字体和行间距要统一，千万不能出现错别字，写完以后自己检查两遍再投
4.联系方式要正确，不可因此错过面试机会，可以放上电话，邮箱和微信在基本信息里，求职意向要明确，切忌模棱两可
很多小伙伴就字啊问了有没有什么简单使用的办法能让我的简历更容易被面试官看上呢？SATR法则就是面试中最常用也算是最高效的提高简历竞争力办法，为什么说它高效呢，他就像你小学开始使用的总-分-总写作方法一样简单，总-分-总的写作方法是你从小学作文到六级作文都随处可见的万金油！
而STAR法则是在面试，求职，写简历时候的常用利器。深受各大公司面试官的喜欢
虽然STAR法则很常用，但是却很少有程序员们会用在简历上，大家一门心思搞技术，忽略了很重要的一点，不管你技术再牛逼，简历关都过不了，啥用都没有。STAR法则虽然无法帮你提高你的实力，但是它能帮你更好地反映出你的情况，而且容易使得和其他各种竞争者产生区分。下面我们来讲一下怎么在简历中使用SRAT法则来提高自己的竞争力！
STAR法则是什么 START法则是situation-task-action-result四个单词的缩写，这四个单词分别代表如下含义：
✅Situation背景：指的是我们在什么情形下选择这次实践的。
✅Task任务：为了做好这次实践，我们要制定一些任务
✅Action行动：我们为了这次实践做了哪些事情。
✅Result结果：这次实践的结果是什么，我们收获了哪些，达成了哪些目标。
进阶版的STAR法则呢后面还会加一个反思总结。
用通俗的话来讲就是：
1.先一句话总结整个事例，结论先行，让别人有个大概的心理预期
2.描述背景时，可以突出项目的难度，以此证明自己的行动是有效的
3.描述行动时，分条列出自己的做的事情
4.结果要数据化，通过一些数据表明自己的能力
5.反思总结写一写
下面我给个例子让大家参考一下
我在XXX项目中，主要负责后端模块（Situation），独立完成了XXX功能，XXX功能和XXX功能（Task），在完成项目过程中我遇到了XXX难题，通过XXX方法克服了它（Action），并且在原项目上提升了**%（Result）。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d8d93a0f7bd6f8caf4848642b8aa556/" rel="bookmark">
			VMware虚拟机安装Windows 7
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		昨天我总结了win10和win11的教程，今天也把win7总结下，一来方便各位探索Windows7，二来也可以给自己备份。
1、准备工作 首先我们在VMware里面安装Windows7需要做的准备工作。
①VMware Workstation软件
（演示版本：vmware-workstation-full-16.2.0-18760230.exe）
【下载链接】http://ai95.microsoft-cloud.cn/d/9289114-49833935-3c06d9?p=ai95 （访问密码：ai95） ## 支持OneDrive网盘、城通网盘、阿里网盘、百度网盘等下载
②Windows7系统原版镜像文件包
（演示版本：cn_windows_7_ultimate_with_sp1_x64_dvd_u_677408.iso）
【下载链接】http://ai95.microsoft-cloud.cn/d/9289114-49837613-071042?p=ai95 （访问密码：ai95） ## 支持OneDrive网盘、城通网盘、阿里网盘、百度网盘等下载
2、设置虚拟机 我个人喜欢使用”自定义“设置。
选择【自定义】
【2-1】选择向导类型 选择最高的【硬件兼容性】
【2-2】配置硬件兼容性 这里我们先选【稍后安装操作系统】，待会儿还有一些地方需要设置
【2-3】选择安装的操作系统 客户机操作系统选择【Microsoft Windows】，版本我们选【Windows 7 x64】
【2-4】选择操作系统及版本 这里我们可以”重命名虚拟机“，设置好【虚拟机名称】和【安装位置】
【2-5】设置“虚拟机名称”和“安装位置” 固件类型我们选择【BIOS】
【2-6】配置引导固件类型 处理器配置可以【按需配置】
【2-7】配置处理器 内存配置可以【按需配置】
【2-8】配置内存 网络类型选择【使用桥接网络】
【2-9】配置网络类型 控制器类型选择【默认推荐】的就好
【2-10】选择I/O控制器类型 虚拟磁盘类型也选择【默认推荐】的
【2-11】选择磁盘类型 选择【创建新虚拟机硬盘】
【2-12】创建新虚拟机硬盘 【按需配置】磁盘大小
【2-13】配置磁盘大小 确认无误后，点击”下一步“
【2-14】确认磁盘文件位置 点击【完成】
【2-15】虚拟机创建完成 点击【CD/DVD（SATA）】或【编辑虚拟机设置】
【2-16】编辑虚拟机设置 插入【IOS镜像文件】，选择我们之前下载好的【Windows7的镜像】
【2-17】添加IOS镜像文件 到这一步，虚拟机的设置就完成了，接下来我们启动虚拟机来安装Windows7
3、安装Windows7 成功加载Windows7
【3-1】加载界面 设置【安装语言】等
【3-2】安装语言等 点击【现在安装】
【3-3】开始安装 点击勾选【协议条款】
【3-4】勾选协议条款 选择【自定义】安装
【3-5】选择安装类型 若无特殊要求，选择好驱动器后直接点击【下一步】
【3-6】Windows7安装位置 等待Windows7的安装
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d8d93a0f7bd6f8caf4848642b8aa556/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68b13e41952697aaf0b9c9f0f6b77d26/" rel="bookmark">
			Java线程池实验：ArrayBlockingQueue和LinkedBlockingQueue性能测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
性能比较
测试代码
结果展示
ArrayBlockingQueue：
LinkedBlockingDeque：
性能比较 Linked queues typically have higher throughput than array-based queues but less predictable performance in most concurrent applications.
性能比较：是ArrayBlockingQueue优于LinkedBlockingQueue，因为：
ArrayBlockingQueue 采用数组存储队列元素，因此再插入、删除元素时不会产生或销毁任何额外的对象实例，而 LinkedBlockingQueue 每次插入都会生成一个新的结点（Node）对象，这会影响日后 GC 垃圾回收，也会影响性能。
测试1千万个put+take的处理时间，LinkedBlockingQueue 在7000ms左右，ArrayBlockingQueue 在3000ms左右。
测试代码 package chapter09; import java.util.concurrent.*; public class ArrayQueueTest { public static void main(String[] args) throws InterruptedException { // 从队列中取得一个数字就执行一个任务 输出该任务的序列号 执行完毕 计算时间 int taskNum = 10000000; BlockingQueue&lt;Integer&gt; DATA_QUEUE = new ArrayBlockingQueue&lt;&gt;(taskNum); long startTime = System.currentTimeMillis(); for (int i = 0; i &lt; taskNum; i++) { DATA_QUEUE.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/68b13e41952697aaf0b9c9f0f6b77d26/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa0a94d392af6290637a1d9dbc8b9f9f/" rel="bookmark">
			element ui 树形数据Table组件的索引父级和子级各自按各自排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目中使用了element ui 树形数据Table组件，原本做的页面是直接使用了type=index，即每一行索引加一。
后需求说父级和子级要各自安各自排序，翻了文档也没有找到什么方法，只能自己写了。
做完后的效果：
代码如下：
&lt;el-table-column type="index" width="60" label="序号" align="center"&gt; &lt;template slot-scope="scope"&gt; &lt;!-- scope.row.parentId == 0，父级 --&gt; &lt;div v-if="scope.row.parentId == 0"&gt;{{indexList[scope.$index]}}&lt;/div&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;el-table-column prop="taskName" label="任务名称" header-align="center"&gt; &lt;template slot-scope="scope"&gt; &lt;!-- scope.row.parentId != 0，子级 --&gt; &lt;span v-if="scope.row.parentId != 0"&gt; {{indexList[scope.$index]+ '、'}} &lt;/span&gt; &lt;span class="inlin-block"&gt;其他&lt;/span&gt; &lt;/template&gt; &lt;/el-table-column&gt; data() { return { indexList: [],//序号数组 }; }, getList(){ this.indexList = []; listJobTaskComprehensive().then(res =&gt; { if(res.status == 'error'){ this.$message.error('数据查询失败'); this.tableData = []; return } this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa0a94d392af6290637a1d9dbc8b9f9f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c34a909e980aefa41cd519c9324bcb10/" rel="bookmark">
			CAN转换器、CAN 232、CAN 485的接口、指示灯和终端电阻图示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 接口、指示灯和终端电阻 内置120欧姆终端电阻，开盖设置跳线帽启用或关闭120欧姆终端电阻。 如下图所示，开盖将跳线帽短接靠近ON标识一端的两根排针，则启用内置的120欧姆终端电阻；不启用时，可 以将跳线帽安在远离ON标识一端的两根排针上。图中，上面的终端电阻对应RS-485通道，下面的终端电阻对应CAN通道。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fee00f2212d9b27a54d3e637301904a5/" rel="bookmark">
			Skywalking 链路追踪
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		更多内容，前往个人博客
Skywalking 链路追踪 Skywalking 根据官方的解释，Skywalking是一个可观测性平台（Observability Analysis Platform简称 OAP）和应用性能管理系统（Application Performance Management 简称 APM）。提供分布式链路追踪、服务网格（Service Mesh）遥测分析、度量（Metric）聚合和可视化一体化解决方案。
一、APM 系统概述 APM（Application Performance Monitoring）即应用性能管理系统，是对企业系统即时监控以实现对应用程序性能管理和故障管理的系统化的解决方案。应用性能管理，主要指对企业的关键业务应用进行检测、优化、提高企业应用的可靠性和质量，保证用户得到良好的服务，降低 IT拥有的成本。APM系统是可以帮助理解系统行为、用于分析性能问题的工具，以便发生故障的时候，能够快速定位和解决问题**。**
二、分布式链路追踪 随着分布式系统和微服务架构的出现，一次用户的请求会经过多个系统，不同服务之间的调用关系十分复杂，任何一个系统出错都可能影响整个请求的处理结果。以往的监控系统往往只能知道单个系统的健康状况、一次请求的成功失败，无法快速定位失败的根本原因。
除此之外，复杂的分布式系统也面临下面这些问题：
【1】性能分析： 一个服务依赖很多服务，被依赖的服务也依赖了其他服务。如果某个接口耗时突然变长了，那未必是直接调用的下游服务慢了，也可能是下游的下游慢了造成，如何快速定位耗时变长的根本原因呢？
【2】链路梳理： 需求迭代很快，系统之间调用关系变化频繁，靠人工很难梳理清楚系统链路拓扑（系统之间的调用关系）。
为了解决这些问题。Google推出了一个分布式链路追踪系统 Dapper，之后各个互联网公司都参照 Dapper的思想推出了自己的分布式链路追踪系统，而这些系统就是分布式系统下的 APM系统。
三、什么是 OpenTracing 分布式链路跟踪最先由 Google在 Dapper论文中提出，而 OpenTracing 通过提供平台无关、厂商无关的 API，使得开发人员能够方便的添加（或更换）追踪系统的实现。下图是一个分布式调用的例子，客户端发起请求，请求首先到达负载均衡器，接着经过认证服务，订单服务，然后请求资源，最后返回结果。
虽然这种图对于看清各组件的组合关系是很有用的，但是存在如下问题：
【1】不能很好的显示组件的调用时间，是串行调用还是并行调用，如果展现更复杂的调用关系，会更加复杂。
【2】这种图也无法显示调用间的时间间隔以及是否通过定时调用来启动调用。
一种更有效的展现一个调用过程的图：
基于 OpenTracing我们就可以很轻松的构建出上面这幅图。
四、Skywalking 整体架构 Skywalking 提供 Tracing[追踪] 和 Metrics[指标] 数据的获取和聚合。
Metric 的特点是，它是可累加的：他们具有原子性，每个都是一个逻辑计量单元，或者一个时间段内的柱状图。 例如：队列的当前深度可以被定义为一个计量单元，在写入或读取时被更新统计； 输入 HTTP请求的数量可以被定义为一个计数器，用于简单累加； 请求的执行时间可以被定义为一个柱状图，在指定时间片上更新和统计汇总。
Tracing的最大特点就是，它在单次请求的范围内，处理信息。 任何的数据、元数据信息都被绑定到系统中的单个事务上。 例如：一次调用远程服务的 RPC执行过程；一次实际的 SQL查询语句；一次 HTTP请求的业务性ID。
总结，Metric主要用来进行数据的统计，比如 HTTP请求数的计算。Tracing主要包含了某一次请求的链路数据。详细的内容可以查看 Skywalking开发者吴晟翻译的文章，Metrics, tracing 和 logging 的关系 ：链接
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fee00f2212d9b27a54d3e637301904a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd0eda7a6f6b3346d1732638a0ac9510/" rel="bookmark">
			【word2019】公式中如何让连等式等号对齐
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在肝论文，新版的word的公式编辑器中让等号处对齐的方式和旧版不同，从网上查到的对齐方式对于新版均无效。好在尝试几次问题解决了。
第一步：
在右下角的小三角那里 选择 “更改为显示”。
很多朋友未显示“在此字符处对齐”的原因就在于此！
第二步：
在第二个等号前 输入软等号（shift+Enter）。
第三步：
分别在两个等号前 右键–在此字符处对齐（如果没出现该选项参考第一步）。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c44710dd21632992099fa36ac093582/" rel="bookmark">
			Java解决InputStream流重复使用问题【100%解决】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景
我在做上传文件的时候，第一步要读取文件中的数据进行分析校验，第二步，校验通过后需求将源文件上传OSS，然后使用同一个InputStream流，发现上传OSS的文件为0kb了。
本博客同事解决上传OSS文件为0kb等问题
你在网上找的 将InputStream 转化成ByteArrayInputStream 然后再次调用使用，我可以负责任告诉你，没用，已经测试过。以下例句没用的代码：
/** * 转换为字节数组输入流，可以重复消费流中数据 * * @param inputStream * @return * @throws IOException */ public static ByteArrayInputStream toByteArrayInputStream(InputStream inputStream) throws IOException { if (inputStream instanceof ByteArrayInputStream) { return (ByteArrayInputStream) inputStream; } try (ByteArrayOutputStream bos = new ByteArrayOutputStream()) { BufferedInputStream br = new BufferedInputStream(inputStream); byte[] b = new byte[1024]; for (int c; (c = br.read(b)) != -1; ) { bos.write(b, 0, c); } // 主动告知回收 b = null; br.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c44710dd21632992099fa36ac093582/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a266d7bcbb9367640f0bacce5159fe78/" rel="bookmark">
			Mybatis实现Mysql批量插入数据，判断数据是否存在，亲测有效
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先吐槽一波，各大平台的腊鸡文章、误人子弟到处搬运都不知道谁是原创，
还TMD解决不了问题，浪费大把时间。废话不多说直接进入主题。
我们在日常开发中避免不了的，会使用各关系型数据库的批量插入操作，批量插入虽然好用，但是也有诸多的限制，例如：
以下实例
本质上来说这段sq在正常都有值的情况下来讲，没有任何的问题，但是注意看绿色框内的写法，没有做任何的判断，但凡红框内
entity.字段，少了一个或者没有值就会报错 为什么会没有值，接着往下看
重点来了，在ServiceImpl里，这是做了一个String字符串转list《实体类》对象的操作，不是说这种写法有问题，这种写法只适用于String字符串没有null的情况，
例如：
thisList：现在返回的json如下
{
"addr":"",
"name":"zhangsan"
}
用以下代码直接进行转换，入库不会有任何问题
如果，thisList：现在返回的json如下
{
"addr":null,
"name":"zhangsan"
}
哪么在进行
JSON.parseArray（thisList, XyElectricLoad.class）； 操作的时候，会丢失掉value值等于null的，key值
下面写一个简单的例子说明一下
什么样不知道大家看出问题没有 ，看第一句输出我们在进行JSON转换的时候，addr的value为null的值既然丢失了，这里简单解释一下，为什么会丢失，丢失的原因是因为
JSONObject源码里默认设置有一个默认不写入null值的策略，所以呢在JSONObject源码里进行.put实体类对象赋值操作的时候默认就会把value=null的值去清空掉了，所以如果想要返回的String字符串返回null值就需要自己手动去改一下这个策略， SerializerFeature.WriteMapNullValue 关于策略问题，感兴趣的小伙伴可以自行去看源码研究一下，这里不做叙述了。 回到我们的代码里，如果现在没有配置写入null值的策略，直接进行了list转换成实体类对象，进行入库会有什么结果，那么这时候，在以下插入语句中就会报错，会一直提示你第几行的SQL附近出错，请使用正常语法，然而我们的语法并没有问题，要解决这个问题，有两种解决方案
一.就是通过上面说的设置null写入的策略方式，原封不动的进行映射，原样输出原样解析。
如果你不想要这些null值那就用SQL的if标签去做判断
二.是用SQL的if标签去判断是否存在这个值，存在就加入insert语句中插入数据库，没有就不管
到这呢，基本就能解决代码上开发的问题，当然了还有一个比较坑的东西，就是yml文件里配置连接数据库的url后缀了，因为我们使用的是批量插入，所以需要在连接数据库的字串中设置 &amp;allowMultiQueries=true
到此分享就完了，只是一些在工作中踩得坑，所以分享出来，有不对的地方，希望各位大佬在评论区指出。。。。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bad1a83faebdf91bcfa5d6328a05b85b/" rel="bookmark">
			shell批量解压当前文件夹下的zip文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#!/bin/sh for file in `ls train_*.zip` do filename=$(basename "$file") fname="${filename%.*}" echo "Input File: $file" echo "Input File: $filename" echo "Input File: $fname" unzip $file -d $fname done 批量解压，解压到名字为去后缀的文件夹下
参考如下：
如何在Shell脚本中提取文件名和扩展名-木庄网络博客
shell脚本对文件夹下所有压缩文件进行解压 - 知乎
unzip 解压缩文件 命令 - caibaotimes - 博客园
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33e433d38d967c4ba53148ec8696c018/" rel="bookmark">
			关于JS对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是阿凉，今天想给大家浅聊一下关于JS对象(object)的语法，以及JS的增删改查。
对象的语法 定义 无序的数据集合 键值对的集合
写法 let obj = { 'name': 'frank', 'age': 18 } let obj = new Object({'name': 'frank'}) console.log({ 'name': 'frank, 'age': 18 }) 属性名 每个 key 都是对象的属性名（property）
属性值 每个 value 都是对象的属性值
JS中的增删改查 删除属性 delete obj.xxx 或 delete obj['xxx'] 即可删除 obj 的 xxx 属性 请区分「属性值为 undefined」和「不含属性名」 不含属性名 'xxx' in obj === false 含有属性名，但是值为 undefined 'xxx' in obj &amp;&amp; obj.xxx === undefined 注意 obj.xxx === undefined 不能断定 'xxx' 是否为 obj 的属性 查看属性 查看自身所有属性 Object.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/33e433d38d967c4ba53148ec8696c018/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c95cf6093a846b91396753aa73c400d9/" rel="bookmark">
			Android中图片的裁剪与压缩
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、图片的剪裁1.属性介绍 二、图片压缩1.图片质量分类2.图片默认质量3.占用内存4.图片的尺寸压缩或者拉伸 三、Bitmap压缩1.质量压缩2.采样率压缩3.缩放法压缩 一、图片的剪裁 ImageView默认的ScaleType
讲到图片的剪裁,我们首先要介绍一下ImageView默认的ScaleType设置效果
ImageView的ScaleType一共有8种属性:
matrix
center
centerInside
centerCrop
fitCenter(默认)
fitStart
fitEnd
fitXY
有些文章说默认是matrix,是不正确的,其实默认是FIT_CENTER
可以通过ImageView的源码看到默认设置
private void initImageView() { mMatrix = new Matrix(); mScaleType = ScaleType.FIT_CENTER; if (!sCompatDone) { final int targetSdkVersion = mContext.getApplicationInfo().targetSdkVersion; sCompatAdjustViewBounds = targetSdkVersion &lt;= Build.VERSION_CODES.JELLY_BEAN_MR1; sCompatUseCorrectStreamDensity = targetSdkVersion &gt; Build.VERSION_CODES.M; sCompatDrawableVisibilityDispatch = targetSdkVersion &lt; Build.VERSION_CODES.N; sCompatDone = true; } } 1.属性介绍 (1)matrix
不缩放 ,图片与控件 左上角 对齐,当图片大小超过控件时将被 裁剪
(2)center
不缩放 ,图片与控件 中心点 对齐,当图片大小超过控件时将被 裁剪
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c95cf6093a846b91396753aa73c400d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5585af7030034be87020e32ad2b25bb0/" rel="bookmark">
			python eval()函数的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://blog.csdn.net/weixin_42339061/article/details/114361368
1.eval() 函数作用：可以接受一个字符串str作为参数，并把这个参数作为脚本代码来 执行。
2.参数情况：(1)如果参数是一个表达式，eval() 函数将执行表达式；
(2) 如果参数是Javascript语句，eval()将执行 Javascript 语句
3.注意：(如果执行结果是一个值就返回，不是就返回undefined，如果参数不是一
个字符串，则直接返回该参数)
4.语法：eval(string)，
5.案例：
eval("var a=1");//声明一个变量a并赋值1。
eval("2+3");//执行加运算，并返回运算值。
eval("mytest()");//执行mytest()函数。
eval("{b:2}");//声明一个对象。如果想返回此对象，则需要在对象外面再嵌套一层小括如下：eval("({b:2})");
注意：使用eval来解析JSON格式字符串的时候，会将{}解析为代码块，而不是对象的字面量
//1.在JSON格式的字符串前面拼接上 "var o ="
//2.把JSON格式的字符串使用()括起来，就不会将{}解析为代码块，而是表达式
6.函数作用域：eval()函数并不会创建一个新的作用域，并且它的作用域就是它所在的
作用域，有时候需要将eval()函数的作用域设置为全局，当然可以将eval()在全局作用
域中使用，这个时候可以用window.eval()的方式实现。
7.Function和eval有什么区别？
共同点：都可以讲字符串转化为js代码
不同点：Function创建出来的函数，并不会直接调用，只有当手动去调用创建出来的函数的时候才，eval把字符串转化为代码后，直接就执行了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c317f27dc5606e84c247e20a345e0fa/" rel="bookmark">
			gcc与Makefile
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、gcc命令 在linux开发编程过程中，需要对完成的代码进行编译运行，这时我们便需要用到gcc命令，下面我介绍gcc的安装与使用
1.安装 在ubuntu系统下终端中输入下面的命令
sudo apt-get install build-essential 该命令中，sudo表示使用管理员权限安装，需要输入系统的密码，安装完成后可以通过如下指令查看gcc版本
gcc -v 输出结果如下
可以看到我的gcc版本为7.5.0，出现该界面则安装成功.
2.使用 gcc语法如下 g c c ( 选项 ) ( 文件名 ) gcc (选项) (文件名) gcc(选项)(文件名)具体选项如下表
选项作用-o指定生成的输出文件-E仅执行编译预处理-S将C代码转为汇编代码-wall显示警告信息-c仅进行编译操作，不进行链接操作 下面以一个例子介绍gcc使用,首先在ubuntu创建一个test文件夹，并在文件夹下创建test.c文件
mkdir test cd test touch test.c 在test文件夹下可以看到test文件创建成功，打开test.c文件，输入如下代码
#include&lt;stdio.h&gt; #define mynum1 12 #define mynum2 15 int main() { int a = mynum1+mynum2; printf("测试结果为:%d",a); return 0; } 程序编译一般经过这几个步骤：预处理，编译，汇编与链接。在预处理阶段，会处理以#开头的预处理命令，比如#include，#define等命令，处理完成后一般是生成.i文件，利用gcc对test.c进行预处理
gcc -E test.c -o test.i //命令中test.c为源文件，-o参数指定预处理后的输出文件为test.i 打开test.i,找到文件最后，可以看到如下结果
通过gcc -E命令解释了代码中#include，并且替换了#define的内容。
C语言编译的第二个步骤为编译,这一步是将C语言代码（上一步预处理后的.i文件）转换为汇编语言，具体命令如下
gcc -S test.i -o test.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c317f27dc5606e84c247e20a345e0fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26eb8e77d2bd17e531d210493619e466/" rel="bookmark">
			【GitHub】作为读书笔记仓库，Git的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考链接 https://my.oschina.net/bxxfighting/blog/378196
完成时间：2021年11月18日19:08:59
原因：本来是想用CSDN记读书笔记的，发现版权问题不能发布，只能用GitHub了
主要步骤 在GitHub里 New 一个 repository
配置Git
a) 安装完Git后，在开始菜单打开Git Bash，输入ssh-keygen –t rsa –C “邮箱地址”，注意ssh-keygen之间是没有空格的，其他是有空格的
b) 回车之后，让你输入一个保存密钥的地方，直接回车，显示出默认保存路径（一般是用户主目录）
c) 回车之后，密钥就生成了，在上面给出的路径里打开id_rsa.pub（记事本打开），里面就是密钥，以ssh-rsa为开头的（这是公钥）
e) 然后去GitHub，配置一下ssh key。
登录GitHub，点击右上角头像，点击Settings，选择左侧的SSH and GPG Keys，右侧出现New SSH Key的按钮，在Title这一栏填一个名字，名字随意起，之后打开刚才生成的那个文件id_rsa.pub，全选复制里面的内容到Key这一栏中，点击Add SSH Key按钮完成操作，这时邮箱会收到一封确认的邮件，不用管它
f) 验证一下是否设置成功，在git bash下输入如下命令：
ssh –T git@github.com，如果是第一次，输入yes就可以了
g) 现在配置一下用户名和邮箱：
git config –-global user.name “用户名”
git config –-global user.email “邮箱”
Git和Github配置完了，现在开始托管我们的项目。
刚才我们已经在Github上面创建了一个仓库，在本地创建一个目录来管理这个仓库。
a) 在本地新建一个文件夹，命名为reading-notes，右键文件夹，点击Git Bash，输入 git init ，进行初始化
b) 然后增加对我们github上创建的仓库的管理，也就是将本地仓库和远程仓库联系起来：
git remote add origin git@github.com:github账户名/repository名称.git，
c) 先在本地同步一下仓库的内容，命令如下：
git pull git@github.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/26eb8e77d2bd17e531d210493619e466/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c6154020c85c35d6f39eec8b445732b/" rel="bookmark">
			STL之stack
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面 栈(stack)又名堆栈, 它是一种运算受限制的线性表. 其限制是仅允许在表的一端进行插入和删除运算, 这一端称为栈顶, 相对的, 把另一端称为栈底.
向一个栈插入新元素称作进栈, 入栈或压栈, 它是把元素放在栈顶元素上面, 成为新的栈顶元素.
从一个栈删除元素又称为出栈或退栈, 它是删除栈顶元素, 使其相邻元素成为栈顶元素.
使用STL中的stack, 需导入头文件.
#include &lt;stack&gt; using namesapce std; 构造 stack没有像string, vector等过多的带参构造, 且只显式的initializer_list列表初始化.
stack&lt;int&gt; st{ 1, 2, 3 };	//错误 stack&lt;int&gt; st1 = { 1, 2, 3 };	//错误 stack&lt;int&gt; st2(initializer_list&lt;int&gt;{ 1, 2, 3 });	//正确, 这里会 常用的一些构造
stack&lt;int&gt; st;	//构造一个空的堆栈 stack&lt;int&gt; st1(st);	//拷贝构造 deque&lt;int&gt; dq{ 1, 2, 3 }; stack&lt;int&gt; st2(dq);	//虽然stack只支持显式的列表初始化对象, 但可以通过支持列表初始化的deque对象初始化stack 赋值 重载的赋值运算符=.
deque&lt;int&gt; dq{ 1, 2, 3 }; stack&lt;int&gt; st(dq); stack&lt;int&gt; st2 = st;	//注意这里会调用的是赋值构造, 因为st2没有初始化, 即stack(const T&amp; right); stack&lt;int&gt; st3; st3 = st1;	//这样才是赋值操作, 因为st3已经初始化为一个空的stack 大小操作 size成员函数 deque&lt;int&gt; dq{ 1, 2, 3 }; stack&lt;int&gt; st(dq); stack&lt;int&gt;::size_type nSize = st.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c6154020c85c35d6f39eec8b445732b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/111a02333b0be608a431128cdd6127a8/" rel="bookmark">
			Flink 架构——状态管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言
状态的计算是流处理框架要实现的重要功能，因为稍复杂的流处理场景都需要记录状态，然后在新流入数据的基础上不断更新状态。下面的几个场景都需要使用流处理的状态功能：
数据流中的数据有重复，想对重复数据去重，需要记录哪些数据已经流入过应用，当新数据流入时，根据已流入过的数据来判断去重。
检查输入流是否符合某个特定的模式，需要将之前流入的元素以状态的形式缓存下来。比如，判断一个温度传感器数据流中的温度是否在持续上升。
对一个时间窗口内的数据进行聚合分析，分析一个小时内某项指标的75分位或99分位的数值。
一个状态更新和获取的流程如下图所示，一个算子子任务接收输入流，获取对应的状态，根据新的计算结果更新状态。一个简单的例子是对一个时间窗口内输入流的某个整数字段求和，那么当算子子任务接收到新元素时，会获取已经存储在状态中的数值，然后将当前输入加到状态上，并将状态数据更新。
二、状态类型 Flink有两种基本类型的状态：托管状态（Managed State）和原生状态（Raw State）。
两者的区别：Managed State是由Flink管理的，Flink帮忙存储、恢复和优化，Raw State是开发者自己管理的，需要自己序列化。
对Managed State继续细分，它又有两种类型：Keyed State和Operator State。
2.1、Keyed State Flink 为每个键值维护一个状态实例，并将具有相同键的所有数据，都分区到同一个算子任务中，这个任务会维护和处理这个key对应的状态。当任务处理一条数据时，它会自动将状态的访问范围限定为当前数据的key。因此，具有相同key的所有数据都会访问相同的状态。
Flink 提供了以下数据格式来管理和存储键控状态 (Keyed State)：
ValueState：存储单值类型的状态。可以使用 update(T) 进行更新，并通过 T value() 进行检索。
ListState：存储列表类型的状态。可以使用 add(T) 或 addAll(List) 添加元素；并通过 get() 获得整个列表。
ReducingState：用于存储经过 ReduceFunction 计算后的结果，使用 增加元素。
AggregatingState：用于存储经过 AggregatingState 计算后的结果，使用 add(IN) 添加元素。
FoldingState：已被标识为废弃，会在未来版本中移除，官方推荐使用 AggregatingState 代替。
MapState：维护 Map 类型的状态。
2.2、Operator State Operator State可以用在所有算子上，每个算子子任务或者说每个算子实例共享一个状态，流入这个算子子任务的数据可以访问和更新这个状态。
算子状态不能由相同或不同算子的另一个实例访问。
Flink为算子状态提供三种基本数据结构：
ListState：存储列表类型的状态。
UnionListState：存储列表类型的状态，与 ListState 的区别在于：如果并行度发生变化，ListState 会将该算子的所有并发的状态实例进行汇总，然后均分给新的 Task；而 UnionListState 只是将所有并发的状态实例汇总起来，具体的划分行为则由用户进行定义。
BroadcastState：用于广播的算子状态。如果一个算子有多项任务，而它的每项任务状态又都相同，那么这种特殊情况最适合应用广播状态。
# 触发指定id的作业的Savepoint，并将结果存储到指定目录下 bin/flink savepoint :jobId [:targetDirectory] 点机制 为了使 Flink 的状态具有良好的容错性，Flink 提供了检查点机制 (CheckPoints) 。通过检查点机制，Flink 定期在数据流上生成 checkpoint barrier ，当某个算子收到 barrier 时，即会基于当前状态生成一份快照，然后再将该 barrier 传递到下游算子，下游算子接收到该 barrier 后，也基于当前状态生成一份快照，依次传递直至到最后的 Sink 算子上。当出现异常后，Flink 就可以根据最近的一次的快照数据将所有算子恢复到先前的状态。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/111a02333b0be608a431128cdd6127a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b763650c5baf2a6d8934e3246ee41071/" rel="bookmark">
			用django开发一个报修系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于django开发了一个报修系统 实现功能环境前期准备创建项目网页开发页面开发api开发添加报修记录重头戏 报修记录的显示回顾 项目地址完结撒花 实现功能 以下功能建立在原生HTML的基础上
1.用户登录
2.用户添加报修记录
3.维修师对报修记录进行修改
4.退出登录
环境 python 3.8
nginx 1.18.0 (Ubuntu)
MySQL 8.0.26-0ubuntu0.20.04.2
django 3.2.6
uwsgi 9.3.0
阿里云服务器 ubuntu20.04
编辑器
Sublime Text
前期准备 1.安装python
这个不多说，记得把pip添加到环境变量
2.安装django
windows命令行内
pip install django 创建项目 1.创建项目文件
cd到自己指定的文件目录下
django-admin startproject 你自己的项目名称 这里我的项目名称叫backend
此时的文件结构
2.创建app
在项目文件目录下，命令行输入
django-admin startapp app名 这里我创建了一个名为api的app
此时的文件结构
3.修改配置文件
这里只是简单的让网站能够运行起来
鉴于作者水平，更复杂的文件配置这里不能详解
修改项目名称文件夹下的settings.py
在INSTALLED_APPS中添加刚才创建的app,多个app的添加同理
INSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'api', ] ALLOWED_HOSTS 修改为
ALLOWED_HOSTS = ['*'] 表示所有的host均可访问
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b763650c5baf2a6d8934e3246ee41071/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af4b6bdc2691876c76315cdf55d4e5c3/" rel="bookmark">
			stm32学习----正电原子精英板控制电机正反转
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一，硬件
L298N电机驱动模块
小黄电机
接线图
二，代码
main.c
timer.c
三，原理
PWM简介
PWM（Pulse Width Modulation）即脉冲宽度调制，简称脉宽调制。它是利用微处理器的数字输出来对模拟电路进行控制的一种非常有效的技术；它是一种模拟控制方式，根据相应载荷的变化来调制晶体管基极或MOS管栅极的偏置，来实现晶体管或MOS管导通时间的改变，从而实现开关稳压电源输出的改变。
基本原理
PWM就是对逆变电路开关器件的通断进行控制，使输出端得到一系列幅值相等的脉冲，用这些脉冲来代替正弦波或所需要的波形。也可以这样理解，PWM是一种对模拟信号电平进行数字编码的方法。通过高分辨率计数器的使用，方波的占空比被调制用来对一个具体模拟信号的电平进行编码。PWM信号仍然是数字的，因为在给定的任何时刻，满幅值的直流供电要么完全有(ON)，要么完全无(OFF)。电压或电流源是以一种通(ON)或断(OFF)的重复脉冲序列被加到模拟负载上去的。只要带宽足够，任何模拟值都可以使用 PWM 进行编码。
驱动电机正反转原理
通过调节两个通道的占空比，来实现电机的正反转。
四，注意事项
1， GPIO_PinRemapConfig(GPIO_Remap_SWJ_JTAGDisable,ENABLE); //关闭gtag,打开sw(只有加上这句才能实现输出两路PWM原因未知）
2，pwm模式配置的注意，会影响占空比的值
110：PWM模式1。在向上计数时，一旦TIMx_CNT&lt;TIMx_CCR1时通道1为有效电平，否则为无效电平；在向下计数时，一旦TIMx_CNT&gt;TIMx_CCR1时通道1为无效电平(OC1REF=0)，否则为有效电平(OC1REF=1)。
111：PWM模式2。 在向上计数时，一旦TIMx_CNT&lt;TIMx_CCR1时通道1为无效电平，否则为有效电平；在向下计数时，一旦TIMx_CNT&gt;TIMx_CCR1时通道1为有效电平，否则为无效电平。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7bf51f22a9558063d1c1c9654329ddac/" rel="bookmark">
			c语言设计一个简单的学生登录系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
//定义结构体类型
struct student{
int sno;
char name[20];
float score;
};
int make_student(struct student st[]);
void show_student(int n,struct student st[]);
void menu(void);
int main(void)
{
int n,i,p;
int k,l,xh;
float cj;
char xm[20];
//定义结构体变量
struct student st[100];
while(1){
menu();
printf("请选择功能:");
scanf("%d",&amp;k);
switch(k){
case 0:
/* printf("请输入要添加的学生人数:");
scanf("%d",&amp;n);
for(i = 0 ; i &lt; n; i++){
printf("请输入学生信息(sno name score)：");
scanf("%d%s%f",&amp;st[i].sno,st[i].name,&amp;st[i].score);
}
*/
make_student(st);
break;
case 1:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7bf51f22a9558063d1c1c9654329ddac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2164b648a3933a5b5bbb4b68d8d7095/" rel="bookmark">
			关于有道云页面比例问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有道云笔记之前一直是这个样子：
今天上午不知道按了什么键变成了这个样子：
上图的这个页面比例，做笔记看着会很别扭，不太舒服。
出现问题原因：
1、自己误按快捷键导致切换了视图
解决方法：
1、视图选择通栏视图解决
效果：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/711a4fa7e7a26c87a4331bdd72e6dc91/" rel="bookmark">
			springBoot项目改名
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文件夹改名，项目改名，快捷键Shift+F6 pom项目名称修改 这里要增加个名字，否则jenkins自动发布不成功 加上项目名称否则Tomcat容器冲突启动失败 有一个类报错（估计之前创建时候编码吗问题） 先改成gbk2312保存，再转会utf8保存 改包名Shift+F6 启动类名 启动项修改 项目配置里的项目名 上传附件文件夹名，这个路径在发布后tomcat能有访问权限？ 数据库连接修改 用户行政区划与所属部门配置 比如行政区划61，需要配置EPARTMENT_ID与DISTRICT_ID为3079
application.yml的province-id 例如陕西为61
用户表里配置DEPARTMENT_ID与DISTRICT_ID为上面配置的行政区划中存在的字段
增加.gitignoer排除项 .gitignoer内容 HELP.md target/ !.mvn/wrapper/maven-wrapper.jar !**/src/main/**/target/ !**/src/test/**/target/ ### STS ### .apt_generated .classpath .factorypath .project .settings .springBeans .sts4-cache ### IntelliJ IDEA ### .idea *.iws *.iml *.ipr /*.bat ### NetBeans ### /nbproject/private/ /nbbuild/ /dist/ /nbdist/ /.nb-gradle/ build/ !**/src/main/**/build/ !**/src/test/**/build/ ### VS Code ### .vscode/ 以下是针对绿创框架的配置修改 baseCode里是没有mybatis包扫描文件的需要手工加上 注意：dao文件和pojo文件必须创建，并且至少生成1个类mapper否则运行项目会报错
swaggerUI扫描代码修改 访问地址http://localhost:8083/HeBeiZhuanXiangZiJin/swagger-ui.html
swaggerUI支持 访问地址http://localhost:8083/HeBeiZhuanXiangZiJin/doc.html
&lt;dependency&gt; &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt; &lt;artifactId&gt;swagger-bootstrap-ui&lt;/artifactId&gt; &lt;version&gt;1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/711a4fa7e7a26c87a4331bdd72e6dc91/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d57b7b54dbfad47ba3319d30821bc8c/" rel="bookmark">
			OAuth2和JWT
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1.OAuth2授权框架2.OAuth2授权模式2.1 授权码模式(见后文)2.2 密码模式2.3 简化模式2.4 客户端模式 3.OAuth2授权码模式3.1 令牌的刷新 4.JWT4.1 JJWT 1.OAuth2授权框架 OAuth是Open Authorization授权协议的简称，它是一个开放网络标准，目的是让用户授权第三方应用将个人数据提供给另外的应用程序，而无需将个人极为敏感的例如密码等数据暴露给另外的应用程序。目前主流的版本是OAuth2。
特点：设计简单、支持多种授权模式、安全性较高、协议开放自由实现。应用场景：需要集成第三方授权登录的场景，例如用微信、支付宝快速登录功能。 2.OAuth2授权模式 2.1 授权码模式(见后文) 2.2 密码模式 这种模式需要让用户将自己的账户密码暴露给三方应用，这种模式并不安全，虽然属于RFC规范，但是这种场景必须得高度信任这个应用，例如著名权威公司等。
1. 用户向应用客户端暴露自己的用户名、密码。 1. 应用客户端将用户名和密码发送给授权服务器，授权服务器校验并返回令牌。 2.3 简化模式 这种模式使用较少，一般出现在没有服务端的应用，纯前端的应用架构。这种模式浏览器直接向授权服务器申请令牌，令牌直接保存在前端，安全性不高，所以只适合一些安全性不高的场景。
2.4 客户端模式 这种模式抛弃了用户的概念，客户端以自己的名义发起授权请求，这种模式适用于命令行的一些基础应用。
3.OAuth2授权码模式 授权码模式是相对比较安全的一种授权模式，也是应用最广泛的一种模式。这种模式需要客户端、服务端、三方服务器共同协调完成，这种模式需要三方应用客户端通过授权得到一个Code码，客户端拿着这个code请求自己公司的服务端，服务器通过code去三方应用获取一个Access_Token，得到三方的Access_Token以后，服务器就可以调用API获取用户的一些非敏感信息了，例如可以拿到用户的头像、用户名、账号ID、open_id、union_id等。举个微信授权登录的场景：
用户进入我司A应用，用户点击“使用微信登录”，客户端唤起微信授权界面。界面展示“是否在A应用登录微信账户”，页面等待用户点击确认授权。用户点击同意，那么微信后台就会给A应用的客户端一个Code码，或者通过跳转重定向页面在url上带上这个Code码给客户端。客户端将这个Code码发给我司的Java服务器，Java端将Code码、微信应用秘钥等参数，向微信后台发起API调用，拿到Access_Token，此时服务器就已经知道这个用户是谁，就可以给用户颁发自己应用的Token了，也可以拿着这个access_token去微信获取用户信息等。用户在客户端的操作，客户端请求Java服务器的API就会在Authorization的Header里面带上这个Token。 3.1 令牌的刷新 令牌为了安全考虑，一般会有一个时间不长的过期时间，例如2小时等。如果让用户重新走一遍流程虽然这样更安全，但是比较麻烦。所以，一般授权服务器在返回令牌的时候会同时返回两个令牌，一个用于获取用户数据，另一个负责刷新这个access_token，名字一般叫Refresh_Token。
4.JWT JSON Web Token的简称，它是一个RFC 7519开放标准，特点是简介、通过JSON数据格式包装对象信息、安全性高、防篡改。
JWT由三部分组成：
header头部：描述JWT的基本信息(也是一个JSON)，例如类型、签名算法，例如RSA、SHA256等，然后进行Base64加密形成一段字符串。payload载荷内容：也是一个JSON格式，存放Token里面的核心信息，例如用户信息、过期时间等。然后进行Base64加密形成一段字符串。signature签名：将header和payload通过base64加密以后的文本再组合secret私钥和header头里面记录的加密算法进行整体加密，得到一个字符串。注意，这个secret一定要保存在服务端。 4.1 JJWT JWT的Java支持工具库，只需要Maven引入，开箱即用。通过Jwts.builder来生成Token。通过Jwts.parser来解析Token。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d433abe2656e0a37e76fe0dc75727cf6/" rel="bookmark">
			Wav2Lip---嘴型同步模型Wav2Lip
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		嘴型同步模型Wav2Lip 软硬件环境是 ubuntu 18.04 64bit
nvidia GeForce 3090Ti
cuda 11.4
anaconda with python 3.7
简介 2020年，来自印度海德拉巴大学和英国巴斯大学的团队，在ACM MM2020发表了的一篇论文《A Lip Sync Expert Is All You Need for Speech to Lip Generation In The Wild 》，在文章中，他们提出一个叫做Wav2Lip的AI模型，只需要一段人物视频和一段目标语音，就能够让音频和视频合二为一，人物嘴型与音频完全匹配。
快速体验 可以先到作者提供的体验站体验一番，地址是：https://bhaasha.iiit.ac.in/lipsync/example3/
wav2lip
按照上图中的选择视频和音频上传即可同步。
实践 准备环境 首先使用conda创建新的虚拟环境，然后激活这个环境
conda create -n py_video python=3.7 conda activate py_video 接着来到官方网站，使用git克隆代码，或者直接下载源码压缩包解压，安装依赖
git clone https://github.com/Rudrabha/Wav2Lip.git pip install -r requirements.txt 在windows平台上，使用了阿里云的pip源，发现找不到torch 1.1的版本，
后来使用了最新稳定版1.11也没有问题，其它依赖库使用最新版也是ok的。
接下来需要安装ffmpeg，这是音视频处理的神器，ubuntu版本使用apt安装
sudo apt install ffmpeg windows用户的话，可以到 https://github.com/BtbN/FFmpeg-Builds/releases 下载，解压后将bin对应的路径添加到系统环境变量PATH中。
准备素材 下面开始准备素材，我们把官方体验站上的测试视频下载下来，使用下面的命令
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d433abe2656e0a37e76fe0dc75727cf6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b496bd55a98afe76d79f760e8187dd7a/" rel="bookmark">
			JavaScript语法简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		二连更，继续为大家讲一点JS的知识，下面给大家说一下JS语法
表达式与语句 表达式一般都有值，语句可能有也可能没有
语句一般会改变环境，声明，赋值
上面两句话并不绝对
标识符的规则 第一个字符，可以是Unicode字母或$或-或中文
后面的字符，除了上面所说，还可以是数字
if else 语句 推荐的写法
if (表达式) { 语句 } else if (表达式) { 语句 } else { 语句 } while for 语句 for 是 while 循环的方便写法
语法：for(语句1;表达式2;语句3){
循环体
}
先执行语句1
然后判断表达式2
如果为真，执行循环体，然后执行语句3
如果为假，直接退出循环，执行后面的语句
break 和 continue break:退出所有循环
continue:退出当前一次的循环
label 语法
foo: { console.log(1); break foo; console.log('本行不会输出'); } console.log(2); 好咯，今天的内容就到这里咯，下次见！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c5c89fb6b9c594f30a24d61e08df311/" rel="bookmark">
			C#测量工具示意图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 我们在常用的设计软件中，常见的测量工具如图：
测量时，一般是用鼠标拉出一条线，如上图右下红色框内部分。
它的测量结果显示在上图的上半部分，里面有XY坐标，宽度、高度，距离、角度等信息。
缺点是测量时，鼠标松开后，无法直观显示相关结果。
为了解决这个问题，我们可以使用Gdi+，c# WINFORM方式来解决这个问题。 如下图：
里面标注了起始点P1, 终点P2的坐标，还直观地显示了角度、距离等。
测量完成后，如果不再显示测量结果，则隐藏或删除上面所示测量的图形。
这样的优点是，直观+美观。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de4c1655b1043d267ed4a31d14b08b79/" rel="bookmark">
			MYDUMPER源码阅读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、MYDUMPER的地位
2、MyDumper怎么实现备份的一致性
3、源码地址
4、直接从main函数开始分析
5、start_dump函数分析
5.1 代码注解
5.2 流程图讲解
5.3 审计日志佐证
6、create_job_to_dump_table函数
7、new_table_job函数
8、write_table_data_into_file函数
9、write_row_into_file_in_sql_mode函数分析
1、MYDUMPER的地位 MyDumper是一个数据库的逻辑备份工具,和官方的mysqldump,mysqlpump类似。本人多年接触过的MYSQL DBA同事，生产环境首选逻辑备份工具都是MyDumper。
2、MyDumper怎么实现备份的一致性 mysqldump是单线程，备份一致性原理：
FLUSH TABLES WITH READ LOCK
SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ
START TRANSACTION /!40100 WITH CONSISTENT SNAPSHOT
SHOW MASTER STATUS
UNLOCK TABLES
MyDumper的多线程是表级别，那它是怎么获取备份一致性的？决定通过源码了解它的执行流程。
3、源码地址 GitHub - mydumper/mydumper: Official MyDumper project
4、直接从main函数开始分析 调用经过初始化、获取命令行参数后，调用start_dump函数
int main(int argc, char *argv[]) { …… if (daemon_mode) { run_daemon(); } else { start_dump(); } …… } 5、start_dump函数分析 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de4c1655b1043d267ed4a31d14b08b79/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e48899c5832be76d0e15063a3f668df/" rel="bookmark">
			SpringBoot启动流程简要
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 SpringBoot启动流程大概：
初始化SpringApplication 根据项目的配置情况和Conditional条件来推断是否是一个Web应用。读取所有jar包下面spring.factories文件，解析放入缓存，然后读取ApplicationListener为key的监听器，后续在SpringBoot加载的过程中会基于事件发布来做很多扩展通知。 真正的run方法开始执行，记录开始执行时间stopwatch。读取所有的监听器，放入SpringApplicationRunListeners中，以便支持后续的事件发布订阅。发布ApplicationStartingEvent事件，属于是一个Startup开始事件，感兴趣的监听器就会执行具体对应的startup方法。基于监听器，加载yml或者properties文件，再根据配置文件中指定的spring.profiles.active环境来激活指定的环境配置，来设置Environment对象。发布ApplicationEnvironmentPreparedEvent事件，感兴趣的监听器就会触发具体的方法。打印SpringBoot的Logo、Banner（不重要）。实例化Spring的上下文对象：AnnotationConfigServletWebServerApplicationContext。applicationContext#setEnvironment()，将环境变量配置对象Environment设置到上下文中，然后执行ApplicationContextInitializer初始化上下文对象。发布ApplicationContextInitialzedEvent事件，感兴趣的监听器执行对应的容器初始化方法。解析启动类为BeanDefinition对象，以便后续IOC流程。发布ApplicationPreparedEvent事件，感兴趣的监听器执行对应的方法。#refresh()方法执行，和Spring的refresh不同的是，这个子类是AnnotationConfigServletWebServerApplicationContext。在#refresh()方法中，除了执行IOC的流程外，后面还会执行#onRefresh()方法，这个方法里面就会创建servlet容器，注册DispatcherServlet。计算启动总耗时，打印。发布ApplicationStartedEvent事件，感兴趣的监听器执行对应的started方法。发布ApplicationReadyEvent事件，感兴趣的监听器执行对应的就绪方法。回调2个内置的扩展自动触发方法： 回调实现了ApplicationRunner接口的类，且自动执行覆写的run方法。回调实现了CommandLineRunner接口的类，且自动执行覆写的run方法。 如果启动过程中发生了异常，则发布ApplicationFailedEvent，监听器执行具体的异常处理方法。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a262ae172a526a6fbc96f92921bff0b3/" rel="bookmark">
			IDEA2020版Maven依赖成功导入任然报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 这也许是idea的一个bug吧，弄了我半天终于知道是为啥了。
因为我们创建maven工程idea会有一个自带的maven，它的有自己的本地仓库。
而我们创建maven工程通常不会用idea自带的maven，我们会创建一个新的仓库，用来存储jar包。
但是当我们进行build时，首先会默认使用idea自己的本地仓库，这时候就找不到jar（即使你已经看到jar导入成功），所以这里会有两种解决方法，一种是把你的setting.xml设置成本地仓库
第二种是把idea运行交给maven来做，也就是下面这样（把圈起来的勾上）
这个地方有一个注意的点，因为你使用的时maven的jdk（默认设置的），他可能会于你的jdk不符合，就会报这种错，所以我们最好在pom.xml文件中指定一下
[ERROR] Failed to execute goal org.apache.maven.plugins:maven-compiler-plugin:3.1:compile (default-compile) on project gcjgfj: Compilation failure: Compilation failu
这是指定jdk
&lt;build&gt; &lt;pluginManagement&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;!-- 指定maven.compiler.plugin 配置版本，解决编译问题 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.6.0&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;11&lt;/source&gt; &lt;target&gt;11&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;/build&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32cfe95d3c8db1825b7bcfb831b12eca/" rel="bookmark">
			【解决】bash: conda: command not found
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		linux系统下，安装了anaconda了，使用conda创建环境，结果报错：
bash: conda: command not found 这主要是还没把conda列入环境变量，解决方法如下：
1、打开文件 bashrc：
vim ~/.bashrc 2、在弹出的文件末尾加上anaconda的路径：
export PATH=~/home/anaconda3/bin:$PATH 打开文件后按i进入编辑模式，按Esc退出编辑模式，shift+冒号然后输入wq 保存文件并退出
注意：这里是anaconda的安装路径，根据自己的安装路径即可
3、激活环境变量
source ~/.bashrc 执行以上三步后，便可在linux上使用conda命令了!
其实，以上的环境变量配置，相当于在window环境下的环境变量加上环境变量。如在window环境下安装anaconda，安装过程中会提示是否将环境变量加入到path中，如果选上该选项，便可省去很多麻烦，安装完后直接在终端使用conda命令；
如果没有选上，是无法直接使用conda命令的，需要在系统的环境变量中加上安装路径才可以使用conda命令。自动添加的安装路径的步骤：
此电脑–&gt;属性–&gt;高级系统设置–&gt;环境变量–&gt;系统变量–&gt;Path
添加anaconda的安装路径。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/233a58c0e9da5b4407037a8dd27beb6a/" rel="bookmark">
			python菜鸟教程中‘(?P＜value＞\d&#43;)‘的理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 #!/usr/bin/python
# -*- coding: UTF-8 -*-
import re
# 将匹配的数字乘以 2
def double(matched):
value = int(matched.group('value'))
return str(value * 2)
s = 'A23G4HFD567'
print(re.sub('(?P&lt;value&gt;\d+)', double, s))
其中？P可以理解为将字符串s分组处理并命名为value，\d表示数字，+表示不止一个（可以为连起来的一个或多个数字）于是每处理一次变把一组数字从字符串中取出冠以value的名字，再传入double函数处理。
例如下面的例子：
import re s = '130021' res = re.search('(?P&lt;province&gt;\d{2})(?P&lt;city&gt;\d{2})(?P&lt;block&gt;\d{2})',s) print(res.groupdict()) 结果为:
{'province': '13', 'city': '00', 'block': '21'} 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46a497a073178fb25bfd46a2fcfc2ae9/" rel="bookmark">
			C语言 字符串最后一位可用’\0‘标示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/248/">«</a>
	<span class="pagination__item pagination__item--current">249/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/250/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>