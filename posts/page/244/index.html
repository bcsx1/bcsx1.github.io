<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04180b7be6eef13e082cabc4d6f70bdb/" rel="bookmark">
			我真的理解了背包dp问题吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 本章主要整理有关背包dp问题的汇总，其实背包dp应该已经是超级经典的一类问题了，相信很多人已经做过很多背包问题了，模板肯定烂熟于心，但是本人而言，虽然写的很顺手，但是还是把一些模板整理一下，自己写一遍会更加有助于理解吧。而对于背包问题无疑有几个分类01背包，完全背包，多重背包，分组背包等,而这些问题有一个共同点，就是有多个物品，每个物品有着对应的体积和价值，而就是这三类衍生很多很多的问题。
本章题大多来源于ACwing,欢迎大家来这个平台一起学习算法！！
二、题目汇总 我们这里用w[i] (weight)代表一个物品体积，v[i] (value)代表物品价值
①ACwing 2.01背包 (1)题目描述 (2)dp分析 为什么选i的那一个状态是如上的呢？
按照字面理解，假设我们选择了第i个物品，那么我们就相当于选出前(i-1)个物品，但是重量要减去第i个物品的最大价值的一个假背包然后拿假背包的最大价值加上我们第i个背包的价值，就会得到选择i的价值。
状态转移方程：
f [ i ] [ j ] = m a x ( f [ i − 1 ] [ j ] , f [ i − 1 ] [ j − w [ i ] ] + v [ i ] ) f[i][j] = max(f[i - 1][j], f[i - 1][j - w[i]] + v[i]) f[i][j]=max(f[i−1][j],f[i−1][j−w[i]]+v[i])
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04180b7be6eef13e082cabc4d6f70bdb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d612aa07285d4c44196f673d414ef43/" rel="bookmark">
			Project ‘org.springframework.boot:spring-boot-starter-parent’ not found
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Project‘org.springframework.boot:spring-boot-starter-parent’ not found 问题解决：
（1）先查看本地的maven仓库是否已经下载好完整的依赖
（2）查看依赖下载完整，但是在idea的pom.xml文件中显示还是找不到报红，那么可以定位原因，可能是idea缓存的问题：
这时找到项目中：
File----------&gt;Invalidate Caches / Restart…(点击进行重启项目)
同时我还出现了下列问题：
Plugin ‘org.springframework.boot:spring-boot-maven-plugin:’ not found
在创建SpringBoot项目时报错。
查了一些资料，说需要在中加上版本号：
*****
在本地Maven 仓库中找到对应版本号
可以把几个版本号都贴上尝试一下。
最后XXXXXX完美解决。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3df1c4bca5604f8bc55622865801d44c/" rel="bookmark">
			uniapp 微信小程序 button 按钮去除边框
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 给button直接样式编写border:none；在模拟器上没有用
需在样式定义 &amp;::after{
border:none;
}
&lt;button class="btnStyle"&gt; 保存&lt;/button&gt; 样式： .btnStyle{ margin: 0; display: flex; flex-direction: column; justify-content: center; align-items: center; font-size: 26rpx; font-family: PingFang SC; font-weight: 500; color: #666666; border: none; background-color: transparent; &amp;::after{ border:none; } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7bf3f947a5492800676087de5be6640/" rel="bookmark">
			爬虫入门——电影top250爬取
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		爬虫入门（自用） 第一篇 Python 爬虫入门之 电影top250爬取
文章目录 爬虫入门（自用）前言一、前置知识requests库正则表达式(re库) 二、使用步骤1.引入库2.小试牛刀 总结 前言 为了记录一下爬虫学习过程 爬取db电影top250榜单
一、前置知识 requests库 requests是一个python的HTTP客户端库
支持HTTP特性
保持活动和连接池 国际域名和URL Cookie持久性保持 浏览器式SSL验证 不严谨地说,就是能让你的代码能连接到网页。
正则表达式(re库) 正则表达式（或 RE）指定了一组与之匹配的字符串；模块内的函数可以检查某个字符串是否与给定的正则表达式匹配（或者正则表达式是否匹配到字符串，这两种说法含义相同）。
简单来说，因为开发人员在写这个网页源代码的时候，写的代码会比较工整，这样我们容易按某种规律找到想要的信息。举个例子在豆瓣电影top250这里我们想要爬到每部电影的标题，鼠标右键单击网页，打开网页源代码,找到电影标题这里
&lt;div class="info"&gt; &lt;div class="hd"&gt; &lt;a href="https://movie.douban.com/subject/1292052/" class=""&gt; &lt;span class="title"&gt;肖申克的救赎&lt;/span&gt; &lt;span class="title"&gt;&amp;nbsp;/&amp;nbsp;The Shawshank Redemption&lt;/span&gt; &lt;span class="other"&gt;&amp;nbsp;/&amp;nbsp;月黑高飞(港) / 刺激1995(台)&lt;/span&gt; &lt;/a&gt; &lt;div class="info"&gt; &lt;div class="hd"&gt; &lt;a href="https://movie.douban.com/subject/1291546/" class=""&gt; &lt;span class="title"&gt;霸王别姬&lt;/span&gt; &lt;span class="other"&gt;&amp;nbsp;/&amp;nbsp;再见，我的妾 / Farewell My Concubine&lt;/span&gt; &lt;/a&gt; 发现，电影的标题都放在以下这样的结构中
&lt;div class="info"&gt; &lt;div class="hd"&gt; &lt;a href="https://movie.douban.com/subject/1292052/" class=""&gt; &lt;span class="title"&gt; 换言之,只要自己制定一个规则（正则表达式找到以上这种有共性的结构），然后在网页源代码里面找到符合制定规则的就能够定位到想要的信息(电影名字)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c7bf3f947a5492800676087de5be6640/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc5a180d1bbadf00e6052b68cdcd30b1/" rel="bookmark">
			如何用python做游戏（简单易上手版）【送 源码】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		嗨害大家好鸭，我是小熊猫🖤 很多小伙伴后台私信问我说，
“python可以做游戏吗 ？”
“要怎么做呢？”
接下来我就介绍一下，
如何用Python做游戏
有什么python相关报错解答自己不会的、或者源码资料/模块安装/女装大佬精通技巧 都可以来这里：（https://jq.qq.com/?_wv=1027&amp;k=2Q3YTfym）
或者+V：python10010问我
游戏演示截图 2048小游戏 表白弹窗 贪吃蛇 五子棋 俄罗斯方块 给大家看看我网盘里的代码~ 更多小游戏可以关注 + 私信 “小游戏” 得源代码哦！！ 用PyGame做游戏非常简单，我们今天第一篇文章，让大家实现一个可以在地图上移动的小猪。
基本框架 首先，无论你是做什么游戏，
别管三七二十一，
先把下面这段代码复制粘贴到你的编辑器里面。
所有游戏都需要这几行代码：
###python学习交流群：660193417##3 import pygame def main(): pygame.init() pygame.display.set_caption('Code：小熊猫做的游戏') # 游戏标题 win = pygame.display.set_mode((800, 600)) # 窗口尺寸，宽800高600 running = True while running: for event in pygame.event.get(): if event.type == pygame.QUIT: # 点击左上角或者右上角的x关闭窗口时，停止程序 running = False main() 运行效果 加载素材
现在，我们随便找两张图片，
一张作为背景，一张作为主角。
尺寸不用太在意，差不多就可以了，
因为我们可以用代码动态调整。
下面两张图是我随便找的素材，
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc5a180d1bbadf00e6052b68cdcd30b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d97a20fc311a16dd776d820cdbdddda6/" rel="bookmark">
			.net反编译工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载：C#逆向反编译工具：JetBrains dotPeek_爱看书的小沐的博客-CSDN博客_dotpeek
侵删！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c382c083447ebd502b6b80168e983bf/" rel="bookmark">
			linux上wireshark抓包权限不足问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题 linux环境下以普通用户启动wireshark没有抓包权限。
解决方法 在网上查找了许多资料，尝试了建立用户组赋予权限等操作，也翻阅了官方文档但是都未见效，于是想到简单粗暴的一招，以sudo启动程序，实证有效。
然后可以将命令固化到快捷方式中：以文本方式打开桌面快捷方式，将其中Exce= xxx/wireshark修改为 Exce = sudo xxx/wireshark
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a63aafa0a90964c7e192e44f8a21f61/" rel="bookmark">
			K-means原理与算法改进及其python实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		K-means入门学习 一、算法概述二、算法思想三、算法实现步骤四、算法图解五、算法优缺点六、k-means算法python实现6.1 sklearn聚类6.2 各省份消费数据聚类6.3 常规方法python实现 七、相关参数调整八、优化算法K-means++8.1 kmeans不足之处8.2 kmeans++8.3 层次聚类 一、算法概述 K-means聚类算法也称k均值聚类算法，是集简单和经典于一身的基于距离的聚类算法。它采用距离作为相似性的评价指标，即认为两个对象的距离越近，其相似度就越大。该算法认为类簇是由距离靠近的对象组成的，因此把得到紧凑且独立的簇作为最终目标。
K-Means算法主要解决的问题如下图所示。我们可以看到，在图的左边有一些点，我们可以看出来有三个点群，但是我们怎么才能将三个点群分为图右边的三个集群，这就是k-means算法能够解决的问题。
二、算法思想 K-means聚类算法是一种迭代求解的聚类分析算法，其步骤是随机选取K个对象作为初始的聚类中心，然后计算每个对象与各个种子聚类中心之间的距离，把每个对象分配给距离它最近的聚类中心。聚类中心以及分配给它们的对象就代表一个聚类。每分配一个样本，聚类的聚类中心会根据聚类中现有的对象被重新计算。这个过程将不断重复直到满足某个终止条件。终止条件可以是没有（或最小数目）对象被重新分配给不同的聚类，没有（或最小数目）聚类中心再发生变化，误差平方和局部最小。
三、算法实现步骤 指定需要划分的簇的个数K值（类的个数）;随机地选择K个数据对象作为初始的聚类中心（不一定要是我们的样本点，可以随机生成）计算其余的各个数据对象到这K个初始聚类中心的距离，把数据对象划归到距离它最近的那个中心所处在的簇类中调整新类并且重新计算出新类的中心（每个新集合质心）循环步骤三和四，看中心是否收敛（不变），如果收敛或达到迭代次数则停止循环 流程图如下：
四、算法图解 首先随机选择三个聚类中心；然后重复调整聚类中心位置；最终收敛，形成三个簇。
五、算法优缺点 优点：
对处理大数据集，该算法是相对高效率的。原理比较简单，实现也是很容易，收敛速度快。当结果簇是密集的，而簇与簇之间区别明显时, 它的效果较好。主要需要调参的参数仅仅是簇数k。 缺点：
要求用户必须事先给出要生成的簇的数目K。K值需要预先给定，很多情况下K值的估计是非常困难的。K-Means算法对初始选取的质心点是敏感的，不同的随机种子点得到的聚类结果完全不同 ，对结果影响很大。对噪音和异常点比较的敏感。用来检测异常值。采用迭代方法，可能只能得到局部的最优解，而无法得到全局的最优解。 六、k-means算法python实现 6.1 sklearn聚类 make_blobs函数是为聚类产生数据集，产生一个数据集和相应的标签
make_blobs方法：
sklearn.datasets.make_blobs(n_samples=100,n_features=2,centers=3, cluster_std=1.0,center_box=(-10.0,10.0),shuffle=True,random_state=None)
n_samples：表示数据样本点个数,默认值100
n_features：是每个样本的特征（或属性）数，也表示数据的维度，默认值是2
centers：表示类别数（标签的种类数），默认值3
cluster_std：表示每个类别的方差，例如我们希望生成2类数据，其中一类比另一类具有更大的方差，可以将cluster_std设置为[1.0,3.0]，浮点数或者浮点数序列，默认值1.0
center_box：中心确定之后的数据边界，默认值(-10.0, 10.0)
shuffle：将数据进行洗乱，默认值是True
random_state：官网解释是随机生成器的种子，可以固定生成的数据，给定数之后，每次生成的数据集就是固定的。若不给定值，则由于随机性将导致每次运行程序所获得的的结果可能有所不同。在使用数据生成器练习机器学习算法练习或python练习时建议给定数值。生成数据 from sklearn.cluster import KMeans from sklearn.datasets import make_blobs import matplotlib.pyplot as plt #参数： # n_samples=100 样本数量 # n_features=2 特征数量 # centers=3 中心点 #返回值： # X_train: 测试集 # y_train： 特征值 X_train,y_train = make_blobs(n_samples=100, n_features=2, centers=3) plt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a63aafa0a90964c7e192e44f8a21f61/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/038134c0a52aee94dc6fba89865a89a2/" rel="bookmark">
			常见限流算法（固定or滑动窗口、漏桶、令牌桶）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		202208-常见限流算法（固定or滑动窗口、漏桶、令牌桶） 1. 为什么需要限流 限流可以认为服务降级的一种，限流就是限制系统的输入和输出流量已达到保护系统的目的。一般来说系统的吞吐量是可以被测算的，为了保证系统的稳定运行，一旦达到的需要限制的阈值，就需要限制流量并采取一些措施以完成限制流量的目的。比如：延迟处理，拒绝处理，或者部分拒绝处理等等。
限流的对象：
系统自身：保护本系统，防止上游突发流量将本系统击穿。下游系统：例如第三方系统性能不可控，即使本系统能处理突发流量，下游由于性能限制，也无法处理。 2. 固定窗口算法 计数器法是限流算法里最简单的一种算法。
定义，对于A接口来说，1分钟的访问次数不能超过100个。设置一个计数器counter，效时间为1分钟（即每分钟计数器会被重置为0），每当一个请求过来，counter就加1，如果counter的值大于100，则说明请求数过多，限制后续请求访问；
劣势：临界时间点产生突发流量，统计数量不准确。
假设在 00:01 时发生一个请求，在 00:01-00:58 之间不在发送请求，在 00:59 时发送剩下的所有请求 n-1 (n 为限流请求数量)，在下一分钟的 00:01 发送 n 个请求，这样在 2 秒钟内请求到达了 2n - 1 个。
设每分钟请求数量为 60 个，每秒可以处理 1 个请求，用户在 00:59 发送 60 个请求，在 01:00 发送 60 个请求 此时 2 秒钟有 120 个请求(每秒 60 个请求)，远远大于了每秒钟处理数量的阈值。
import java.util.concurrent.atomic.AtomicInteger; public class Counter { /** * 最大访问数量 */ private final int limit = 10; /** * 访问时间差 */ private final long timeout = 1000; /** * 请求时间 */ private long time; /** * 当前计数器 */ private AtomicInteger reqCount = new AtomicInteger(0); public boolean limit() { long now = System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/038134c0a52aee94dc6fba89865a89a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5696e7fc4ee6333d63108426f48f30fc/" rel="bookmark">
			源码解析springbatch的job是如何运行的？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		202208-源码解析springbatch的job是如何运行的？ 注，本文中的demo代码节选于图书《Spring Batch批处理框架》的配套源代码，并做并适配springboot升级版本，完全开源。
SpringBatch的背景和用法，就不再赘述了，默认本文受众都使用过batch框架。
本文仅讨论普通的ChunkStep，分片/异步处理等功能暂不讨论。
1. 表结构 Spring系列的框架代码，大多又臭又长，让人头晕。先列出整体流程，再去看源码。顺带也可以了解存储表结构。
每一个jobname，加运行参数的MD5值，被定义为一个job_instance，存储在batch_job_instance表中；job_instance每次运行时，会创建一个新的job_execution，存储在batch_job_execution / batch_job_execution_context 表中； 扩展：任务重启时，如何续作？ 答，判定为任务续作，创建新的job_execution时，会使用旧job_execution的运行态ExecutionContext（通俗讲，火车出故障只换了车头，车厢货物不变。） job_execution会根据job排程中的step顺序，逐个执行，逐个转化为step_execution，并存储在batch_step_execution / batch_step_execution_context表中每个step在执行时，会维护step运行状态，当出现异常或者整个step清单执行完成，会更新job_execution的状态在每个step执行前后、job_execution前后，都会通知Listener做回调。 框架使用的表
batch_job_instance batch_job_execution batch_job_execution_context batch_job_execution_params batch_step_execution batch_step_execution_context batch_job_seq batch_step_execution_seq batch_job_execution_seq 2. API入口 先看看怎么调用启动Job的API，看起来非常简单，传入job信息和参数即可
@Autowired @Qualifier("billJob") private Job job; @Test public void billJob() throws Exception { JobParameters jobParameters = new JobParametersBuilder() .addLong("currentTimeMillis", System.currentTimeMillis()) .addString("batchNo","2022080402") .toJobParameters(); JobExecution result = jobLauncher.run(job, jobParameters); System.out.println(result.toString()); Thread.sleep(6000); } &lt;!-- 账单作业 --&gt; &lt;batch:job id="billJob"&gt; &lt;batch:step id="billStep"&gt; &lt;batch:tasklet transaction-manager="transactionManager"&gt; &lt;batch:chunk reader="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5696e7fc4ee6333d63108426f48f30fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c35f1dacd7bb7bfb24fe1819d67a8ba/" rel="bookmark">
			开源MyBatisGenerator组件源码分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开源MyBatisGenerator组件源码分析 看源码前，先了解Generator能做什么？
MyBatisGenerator是用来生成mybatis的Mapper接口和xml文件的工具，提供多种启用方式，如Java类启动、shell启动、mavenPlugin启动等
具体点，可以连接DB，读取表信息，生成Model对象、JavaMapper、xmlMapper文件等。
整体代码工程分层
org.mybatis.generator ----api 内外部使用的主要接口，关键类MyBatisGenerator ----codegen 代码生成的实际类，如XMLMapperGenerator/BaseRecordGenerator/JavaMapperGenerator ------ibatis2 适配ibatis2 ------mybatis3 适配mybatis3 ----config 配置处理（1）xml配置读取/转化（2）如JavaClientGeneratorConfiguration配置生成文件目录、PluginConfiguration配置扩展插件 ----exception ----internal 内部扩展和工具类， ----logging ----plugins 所有的扩展插件，如ToStringPlugin(生成ToString方法) ----ant 适配ant编译工具 写个demo看看怎么调用
/** * 极简版【Java类启动】生成 */ public static void simpleGenModelAndMapper(String tableName, String modelName) { Context context = new Context(ModelType.FLAT); context.setId("starmoon"); context.setTargetRuntime("MyBatis3"); // MyBatis3Simple 是不带Example类的生成模式 JDBCConnectionConfiguration connection = new JDBCConnectionConfiguration(); connection.setConnectionURL(JDBC_URL); connection.setUserId(JDBC_USERNAME); connection.setPassword(JDBC_PASSWORD); connection.setDriverClass(JDBC_DIVER_CLASS_NAME); context.setJdbcConnectionConfiguration(connection); JavaModelGeneratorConfiguration c1 = new JavaModelGeneratorConfiguration(); c1.setTargetProject(PROJECT_PATH + JAVA_PATH); c1.setTargetPackage(MODEL_PACKAGE); context.setJavaModelGeneratorConfiguration(c1); SqlMapGeneratorConfiguration s1 = new SqlMapGeneratorConfiguration(); s1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c35f1dacd7bb7bfb24fe1819d67a8ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f66a76d066bd60344cefed807345ec4/" rel="bookmark">
			安装python库时报错提示：Microsoft Visual C&#43;&#43; 14.0 is required
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 背景： 有些时候我们安装python库的时候会报错：Microsoft Visual C++ 14.0 is required，这是因为库安装时需要编译环境。
解决方法： 下载后解压得到下图的文件：
链接: https://pan.baidu.com/s/197RIdHRDqYtusYOz3AQ2nw 提取码: a888
双击exe文件就可以等待安装成功了
然后就可以直接pip安装我们需要的库了。
如果你有vpn的话，直接在这个链接下载安装即可，上面网盘的是离线包，http://go.microsoft.com/fwlink/?LinkId=691126
当然有时候可能需要的编译环境不是 Visual C++，而是cmake，这时候你去百度"cmake",然后到官网下载安装cmake即可，安装时记得勾选"添加环境变量"。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae6b047b37fe96c75959ff902d89fcd7/" rel="bookmark">
			使用randn实现randm的通用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用randn实现randm的通用方法 分以下两种情况：
一、n &gt; m 对于n &gt; m的情况，可以直接截断，即不断使用randn生成随机数，直到该随机数小于等于m的倍数为止（该倍数要小于等于n）。
比如rand5实现rand2，因为rand5生成的随机数范围为{1，2，3，4，5}，如果随机到了5，那就重新生成，直至为1或2或3或4为止，然后模2，并加1 ，即可得到1或2，且生成1 2 的概率都相同，实现了rand2。
#include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;ctime&gt; using namespace std; int rand5() { return rand() % 5 + 1; } int rand2() { int res; do{ res = rand5(); } while(res &gt; 4); return res % 2 + 1; } int main() { srand(time(0)); // 设置随机种子，使随机结果不固定 printf("rand5的随机结果：\n"); for (int i = 0; i &lt; 10; i++) { printf("%d "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae6b047b37fe96c75959ff902d89fcd7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f55f4223d3ce799c767e473b5382eda/" rel="bookmark">
			“舱驾融合”技术发展趋势分析（下）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：陈康成 内容来源：九章智驾
4 . 单SoC芯片的舱驾融合方案
特斯拉目前采用的方案属于舱驾融合的一个初期探索，只是把座舱和智驾的域控制器合二为一集成在一个盒子里面。以后，如果能够实现真正的舱驾融合——把座舱和智驾的功能完全集成在一颗SoC里面来实现。这样的方案又会带来哪些好处？同时，实现这样的方案又将面临怎样的挑战？
4.1 单SoC芯片方案带来的好处
1） 成本可以做得更低
芯片的集成化程度更高，物料用的更少，相比于之前用多个芯片方案的成本，可以有一定程度的降低。
部分底层软件可以共用，可以节约一部分底层软件的开发成本或购买成本。
2）通讯时延更短
相比于之前通过网络总线传输的方式或两个板子件通过Switch通讯，现在可以使用内存共享的方式，通讯时延会更短。
3）OTA升级空间更大
某主机厂自动驾驶系统架构专家认为：“舱驾融合后，数据信息可以共享，两者之间的交互可以做得更多，软件迭代的想象空间会更大。如果两个域还是完全独立，接口基本上是固定的，接口变，双方软件就要跟着变，比如在后期，一些主机厂会要求增加一个新功能，就需要订阅一些服务，会发现订阅不了，因为之前的接口是定义“死”的，除非在开始的时候就能够把接口定义得特别丰富，否则，一旦后期需要做变更，就需要跨部门提变更需求，再次跨部门进行协作，沟通成本很高。如果两者融合了，再增加新的功能，一般只需要对软件模块做一些变更，不再需要变更硬件接口，便于在后期做一些系统上的OTA升级。” “座舱域控制器和智能驾驶域控制器相互独立的时候，他们之间可互通的信息比较少，也很难及时获取对方的数据信息，但舱驾融合以后，两者的传感器数据便可以更充分、更及时地被复用。相当于在功能层面留下更多的想象空间 —— 基于座舱和智驾的这些传感器数据，可以融合出一些比较新的、有想象力的应用。” 杨曾说道。
4.2 单SoC芯片方案面临的挑战
4.2.1 硬件层面的挑战
1）芯片本身的设计
实现真正的舱驾一体融合方案，SoC芯片设计本身就是个很大的难题 —— 要把很多的系统和功能融合在一起，芯片的设计方案会很复杂。同时，单SoC芯片不仅要实现上千TOPS的算力，还要把功耗控制在可接受的程度内，这对芯片的制程要求非常高。现在的车载AI芯片已经下探到5nm了，不仅成本高，而且掌握这种先进工艺的企业也寥寥无几。
有业内人士提到了使用Chiplet来设计这样的SoC芯片，它的优势在于各家芯片厂商可以专注自己的芯粒和IP，不用为多余的IP买单，并且小芯粒的流片良率更高，有坏点的部分扔掉，剩下的还能用。因此，采用小芯粒技术进行SoC芯片的迭代设计会更加方便。但是，目前也存在一些问题 ——
Chiplet技术，又被称为小芯粒技术，即把不同制程的芯粒经过选型直接封装在一个SOC里面。目前业内已有一些成功的应用案例，并且整个行业也在推动。曹晶告诉九章智驾：“基于Chiplet技术实现舱驾融合的SoC芯片不难被设计出来，只要产业链端能够提供足够多满足智驾和智舱的芯粒就可以。 我觉得使用芯粒技术最大的挑战不在单个芯粒内部的这些设计和实现，反倒是高速带宽部分，毕竟芯粒之间也是需要进行大通道数据的输入输出。
“同样，Chiplet技术不仅面整个产业链成熟的问题，而且在SoC芯片上面实现智舱和智驾这些复杂功能也会涉及到很多工程化的问题，这些问题可能会比把芯片设计出来所花的时间还要长。整个行业讨论这种技术方案比较多，在实践上也有企业在向这个方向发展，但是我觉得离真正在车上量产应用尚且需要一段时间，不过至少这个方向的国产自主化趋势是窥见一斑了。”
2）硬件资源分配
智舱和智驾功能融合在一个单SoC芯片里面，芯片内部的GPU和CPU等资源可以共享，但是资源该如何分配？哪一块GPU/CPU资源供智能驾驶使用，哪一块GPU/CPU资源供座舱使用，怎样实现资源的动态调节？并且，智舱和智驾都处于不断地迭代发展中，如果智能驾驶发展两年，技术迭代升级了，对硬件的需求变了，之前硬件资源分配方案可能就不行了，还需要重新做资源分配。
同时，对于单SoC芯片的舱驾融合方案，很有可能要做内存共享，这样数据才会读得更快，信息传输延迟会更小。但是，DDR分配也会面临很多问题 —— 比如，智驾的内存需求发生变更，另外一个也要跟着变更；在座舱开发的时候，内存损坏，也会影响到自动驾驶的开发。
某主机厂自动驾驶系统架构专家告诉九章智驾：“当前，座舱和智驾尚未达到一个终极形态，硬件资源也没有足够强。两者在硬件资源需求上的变动很可能会影响到整个软件架构，以及后续硬件资源的分配。比如，对于CPU资源，有些ARM核用于支持座舱相关应用，有些ARM核用于支持智能驾驶相关应用；对于GPU资源，可能会通过制定一个优先级进行资源使用或者直接把GPU隔离成不同部分，座舱用一部分、智驾用另外一部分；但问题的关键是 - 对于这种架构设计，大家都没有太多经验可以借鉴，比如，硬件资源怎么去分配，分配是否合理？后期面临需求变更的时候，会不会没办法实现？这些问题都会存在很大的不确定性。” “智能座舱和智能驾驶功能集成在单颗SoC芯片上的时候，因为两个域的需求完全不同，在做硬件资源分配的时候，既要定义这些应用的优先级，又要确保这些应用有足够资源可以用 —— 能够保证互相不打架，也不能出现一个应用锁死另外一个应用的现象。”汪浩伟表示。
4.2.2 软件层面的挑战
1）OTA升级策略
智能座舱和智能驾驶两者的OTA软件模块、升级模块的数据量、数据包的大小可能都不太一样，在这样的情况下，做好OTA的升级策略也存在一定的挑战。
赵建洪认为，舱驾融合后，座舱发布的数据包和智驾发布的数据包需要要整合在一起才能升级。因为涉及很多的功能，如何更好地整合在一起会有一定的难度。同时，两者有各自的功能升级策略，有的升级频率是三个月，有的升级频率为半年。并且，座舱升级频率比较高，并且座舱还经常容易出问题，出问题就要升级，临时更新内容也需要马上升级。
2）软件上的安全隔离
SoC上面需要隔离出不同区域，并且适配好不同的操作系统。A核上面一般会跑 Linux或QNX系统；内置MCU、M核或R核上会跑AUTOSAR CP。
汪浩伟讲到：“对于舱驾融合方案，在软件上进行整合，并做好安全隔离，确保不同应用的功能安全和信息安全。如此一来，座舱便不会影响自动驾驶，自动驾驶也不会影响到座舱。隔离是系统设计的问题，要从系统设计出发去考虑怎么去做隔离方案。随着芯片的集成化程度越来越高，方案会越来越统一，直到有一天大家都用一种或少数几种芯片、一种操作系统，并且应用程序也非常固定的时候，功能安全方案才会固定下来。不然，功能安全方案永远是跟着项目走，一个项目可能就需要采用一种功能安全方案。
“安全级别不一样的软件放在一起如何共存？既要保证安全件的绝对安全性，又要保证非安全件的“人权”，—— 他们不是“奴隶”，也需要获取一部分资源。可以在操作系统上面再嵌套操作系统，虚拟机是一种，也可以采用Container的方式去做。通过这些方式都可以在软件层面上把不同的应用隔离出来，但更大的问题在于隔离完以后该怎么办？—— 通讯怎么解决、调度怎么解决、资源怎么保证，这些问题才是更主要的。”
目前座舱和智驾中相关模块对功能安全的要求：座舱的中控娱乐模块需要达到ASIL A等级，仪表模块需要达到ASILB等级；智驾的泊车模块至少需要达到ASILB等级，行车模块需要达到ASILD等级。那么芯片底层的加速器资源针对这些不同功能安全等级的应用如何进行有效隔离也是一个比较大的挑战。
杨曾举例说：“以GPU为例，既可以用于做深度学习，又可以用于图像渲染，但是在系统设计的时候，到底留多少给座舱做图形渲染，又留多少给智驾做AI计算？GPU资源的划分既要满足不同功能域的需求，又要支持不同域功能安全的隔离，同时还要保证不同域的数据流能够互相访问复用，这不仅对芯片底层设计，甚至对整个系统软件的设计，都提出了比较高的要求。”
3）虚拟机技术带来额外的硬件开销
舱驾融合需要在操作系统层面做虚拟化技术，但虚拟化技术并非解决问题的完美方案。因为采用虚拟机将会占用一定的硬件资源。据业内相关人士透露，采用虚拟机将会导致额外增加10%以上的CPU开销，同时在商业层面，虚拟化也会带来更多的授权许可成本。
“虽然虚拟化对整体资源会有一定的消耗，但是它也带来了额外的好处 —— 实现了对客户机资源静态的划分及分配。客户机应用之间不互相干扰、信息不会互相串访，保证了功能与信息安全性，简化了上层软件的开发，所以这些资源的耗费也是值得的。”杨曾解释道。
4.2.3 工程化层面的挑战
1）测试验证层面
某主机厂自动驾驶系统架构专家认为：智能驾驶本身在进行底层软件以及应用软件集成的时候就面临很多问题，现在还要和座舱的相关功能一起去进行集成测试和回归测试，不仅工作量很大，并且也很难保证整个产品的可靠性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f55f4223d3ce799c767e473b5382eda/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71e4294fdd1baf82ec6d3fa0074c2159/" rel="bookmark">
			“舱驾融合”技术发展趋势分析（上）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：陈康成 内容来源：九章智驾
引言：
前段时间，集度发布了其首款汽车机器人ROBO-01，并在发布会上提到了一个令笔者比较感兴趣的词：“舱驾融合”。其实早在集度之前，上汽零束也提出过舱驾融合的概念。而有些车企，虽然没有明确提出舱驾融合，但其智能驾驶和智能座舱产品，也或多或少地有着舱驾融合的形态。
那么，什么是舱驾融合？目前企业在舱驾融合上在做怎样的探索？舱驾融合方案的优势和面临的挑战是什么？舱驾融合对开发模式和产业链格局又会带来什么样的影响？带着这些问题，笔者访谈了相关领域的技术专家，希望能够对“舱驾融合”有更深层次的理解。
1. 厘清“舱驾融合”概念
众所周知，汽车的智能化程度取决于底层的EE架构。在汽车智能化的进程中，EE架构的发展路线从功能独立的分布式架构，到功能集成的域集中式架构，最后再到高度集成的中央计算＋区域控制的中央集中式架构。
在域集中式架构阶段，业内谈的比较多的就是经典五域：座舱域、智驾域、动力域、底盘域、车身域。再往后发展，到域融合阶段，五大功能域之间开始尝试进行跨域融合，虽然不同的主机厂有不同的理解和做法，但大体思路是一致的，即先将部分域的功能集成到一个高性能计算单元内，再逐渐聚合更多的功能域，最终实现1个中央计算大脑的目标。舱驾融合差不多就是在这个阶段诞生的产物—— 座舱域和智能驾驶域进行跨域融合，形成舱驾一体域控制器。
不同形式的跨域融合尝试
（信息来源：公开资料整理）
均联智行首席架构师汪浩伟认为：“舱驾融合可以从硬件和软件两个不同的层面去考虑，从不同层面进行融合的概念是完全不同的，目的和作用也完全不一样。
“硬件上的融合更多地是基于产品的视角，从成本和设计的维度进行考虑。在一颗SoC芯片里面做融合，才是真正意义上的硬件融合。这个时候，底层软件和通讯方式都会有本质上的改变，成本上的优势也会凸显出来。
“软件上的融合更多地是基于技术的视角，从功能的维度进行考虑。软件上的融合需要考虑怎么去改变整体软件架构设计，从而使得新的软件架构能够更加适用于舱驾融合系统。与此同时，引入SOA面向服务的设计理念和工具，可以帮助主机厂更好地做好舱驾融合。
“软件上的融合不会随着硬件上的融合而变化。不管硬件是做成一个单SoC芯片，还是做成一个单板，亦或是做成两个单板，从软件融合的角度来讲，区别并不大，只是底层的通讯和运行方式会有所不同。从功能层面来讲，只有软件上的融合才会改变应用程序和上层逻辑本身，舱驾融合意义才会更大。”
1.1 舱驾融合层级的划分
1）应用层面的融合
由于技术发展和工程化的问题，现阶段比较容易实现的方案是：在物理形式上，智能驾驶域控制器和座舱域控制器采用完全相互独立的两个盒子，但在应用层面，很多功能之间的信息交互通过跨域进行打通，并实现数据融合创新 —— 将智能座舱中的人机交互、沉浸式体验等内容，与智能驾驶的各项功能深度结合、联动，从而提升用户的安全感与舒适感，增强用户对智能化汽车的使用体验。
环宇智行COO曹晶提到，他们有一个项目，主机厂要求统一采用SOA架构，通过以太网或CAN协议把座舱域和智驾域中的信号能够发送出来共享，这样一来，在功能层面就可以做更多的融合创新。如果按以前的策略，两个域的信号基本都是固定写死的，虽然可以通过私有CAN转发到整车CAN总线上，但是，系统需要获取相关信号的时候，还得再去整车CAN总线上查询，非常不方便。
2）座舱域控制器和智驾域控制器在物理形式上合二为一
座舱域控制器和智驾域控制器合并成一个盒子，内部由多个SoC或者MCU芯片构成。这些芯片用于支持不同的功能，每个芯片以及芯片内的不同核上运行不同的操作系统。这种形式又可再细分成两种方案：A. 座舱和智驾功能分别部署在不同的板子上。B.座舱和智驾功能部署在同一个板子上。
“如果座舱和智驾功能分别部署在不同的板子上，用于支持座舱和智驾功能的SoC芯片肯定都会有自己专属的外围电路设计；如果两者的功能部署在同一个板子上，设计方案可以从整体上去考量，包括器件的选型，电路、供电、存储等方面的设计，比如，考虑DDR是否可以共享、EMMC模块是否可以共享等等。整体来讲，B方案比A方案在电子器件、接口、线束等部件的使用量上有一定程度的减少，使得BOM成本相对较低。”曹晶表示。
3）基于单SOC芯片的舱驾功能融合
智舱和智驾的功能由一颗单SoC芯片来完成 —— 在芯片上运行虚拟机，通过虚拟机分割出不同的功能模块，来实现不同安全级别需求的舱驾功能。
目前，有一些芯片公司和主机厂在探讨这样的方案，未来也很有可能会有这样的一些芯片产品出现。但是，理想很丰满，现实很骨感，短期内应该是很难看到这样的理想方案落地。
据业内专家透露，大部分车型无论是对于成本，还是可靠性都比较敏感。同样，开发一个新车型，车型的上市周期也会有一定的要求，所以主机厂一般会首选技术成熟度较高，并且成本已经在行业内能够被分摊下来的成熟方案。另外，不管是主机厂的组织架构，还是对应用层的梳理，都需要很长时间去调整和消化。因此，这样的产品需求不会一下子就爆发出来。
1.2 什么是真正的舱驾融合？
芯片作为汽车智能化的核心硬件，在很大程度上影响着智能座舱和智能驾驶的能力上限。因此真正的舱驾融合需要智舱与智驾芯片一体化，即智舱与智驾的软件和算法完全部署在同一颗SoC芯片上，这是最理想的方案。但受限于软硬件技术水平、架构方案、供应链等方面的原因，目前还难以实现基于单SOC芯片的舱驾融合方案。
映驰科技产品副总裁赵建洪讲到：“我们首推的是舱泊融合方案，并且，主机厂对舱泊融合也有一定的需求。因为泊车方案现在比较成熟，同时，座舱域控制器上的算力也有了一定的富余，把泊车功能融合到座舱域控制器具有一定的成本优势。不过，舱泊融合相当于是舱驾融合的第一步，由于行车方案目前还不是很成熟，需要两者都发展成熟的时候，再去考虑融合的问题。”
汪浩伟也提到了类似的观点：“座舱和智驾集成在一个单SoC芯片里面，肯定是大势所趋的。在成本的驱动下，这种方案大概率会从中低端的车型开始出现（舱泊一体）。待EE架构进化到中央集成+区域控制架构阶段，并且业内逐渐地把底层软件铺设好，最后才能看到两者融合所带来的真正价值。”
为什么依然有企业有动力去做两者的融合？因为在应用层面上，两者之间可以互相借力。之所以现在舱驾融合的应用价值还没有被完全挖掘出来，是因为底层的软件设计还没达到相应的程度，需要将底层的逻辑进行封装，比如，做成一个个微服务的形式。在这样的情况下，座舱和智驾之间就可以更容易地去相互调用对方的服务或者资源，进而就能够比较容易地去开发新的融合应用。”
1.3 在什么阶段，舱驾才有必要融合？
智能座舱和智能驾驶，作为汽车智能化的代表，直接影响车主对汽车智能化的体验。智能座舱是汽车直接与用户沟通、交流的部分，体现的是人与车的交互；智能驾驶则发挥汽车最基本的功能，即行驶，体现的是车与环境的交互。而在交通环境中，驾驶行为是人-车-环境三方交互的过程，因此，汽车作为重要的载体，如何打通三方的交互，让驾驶员和乘客获得好的驾乘体验，就显得尤为重要。
那么，舱驾融合在什么阶段才更有意义，是L3级以上，还是L3级及以下？在访谈的过程中，笔者发现大家的理解目前也存在差异 —— 有的人认为，在L3级及以下才有必要融合；也有的人认为，在不同的自动驾驶阶段都有必要融合，只不过融合的形式和意义不同而已。
1）观点1 ：只有在L3级及以下融合才有意义
在L3及以下的时候，系统只是辅助驾驶，驾驶员还是要对车辆的安全负责。人坐在舱内，对舱外的行车环境并不一定能够充分了解，因而，只有座舱和智驾进行信息打通和融合，座舱才能更清楚地了解自动驾驶系统在干什么，舱外的环境是怎样的。座舱结合智驾的一些传感器数据信息，才能更好地把车外的环境信息反馈给驾驶员，帮助或指导驾驶员更好地开车。
当自动驾驶等级达到L4的时候，人就脱离了驾驶任务，座舱里面的人就不再需要关心车外的情况，整个座舱会变成一个以娱乐和工作为中心的“第三生活空间”。这个时候，自动驾驶系统就基本没有必要介入到座舱 —— 如果驾驶任务都已经完全交给系统去完成了，自动驾驶系统还时不时地去“烦”座舱里的人，那这还算是真正的“自动驾驶”么?
2）观点2 ： 都有必要融合，只不过两者融合的形式和深度不一样
A. L3及以下 - 硬件独立，上层应用融合
对于L3及以下 ，硬件层面可能并不需要融合，只是在上层应用层面基于一些信息的交互，做一些融合类的功能。
目前，应用在座舱和智驾的一些芯片，比如应用在座舱上的高通8155、智驾上的TI TDA4，经过这两年的产业化路径已经变得非常成熟，在硬件相互独立的前提下，底层就不需要再做太多的工作，因此就不需要过多的工程化的投入或者是成本上的增加，通过虚拟现实或一些其它的方式，就可以在应用层打造出一些更加沉浸式的体验。例如，人工智能语音公司Cerence Inc发布的Cerence Look，结合了在线数据库和视线跟踪摄像头数据，将汽车的语音助手变成实时导游。驾驶员不需要使用特定的唤醒词，而是使用环境重建和传感器数据来确定车辆的位置，并确定驾驶员提出问题时正在看什么。
B. L4级 - 软硬件均开始融合
在EE架构集中化、芯片算力的大幅提高以及软件开发能力提升的不断推动下，智驾和智舱从底层硬件层面开始进行融合。而应用层级的融合是车辆功能和性能的外在表现形式，又会受到底层硬件和软件的制约。只有底层硬件和软件融合得足够深，上层应用才有可能发挥出最大的融合效果。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/71e4294fdd1baf82ec6d3fa0074c2159/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8b69d03b9b5b8927e7ca334e15a6228/" rel="bookmark">
			实体map互转
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		public class EntityUtils {
/**
*
@description: 实体类转Map
@author zjx@return
/
public static Map&lt;String, Object&gt; entityToMap(Object object) {
Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();
for (Field field : object.getClass().getDeclaredFields()) {
try {
boolean flag = field.isAccessible();
field.setAccessible(true);
Object o = field.get(object);
map.put(field.getName(), o);
field.setAccessible(flag);
} catch (Exception e) {
e.printStackTrace();
}
}
return map;
}
/*@description: Map转实体类
@author zjx@param map 需要初始化的数据，key字段必须与实体类的成员名字一样，否则赋值为空@param entity 需要转化成的实体类@return
*/
public static T mapToEntity(Map&lt;String, Object&gt; map, Class entity) {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c8b69d03b9b5b8927e7ca334e15a6228/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ea018ff8ab488c3ee1b8310dfefec5b/" rel="bookmark">
			最速降线问题——欧拉-拉格朗日方程的推导
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由机械能守恒：
得 ： 由勾股定理得 ：
对弧长积分得：
函数y是任意一条两端固定的曲线函数，将T表示成函数的函数：
假设y是一个极大值, 当y发生微小的变化时, y的变化率趋近于0，这种微小的变化记作.
根据多元积分链式法则得：
带入上式得：
如果将 , 理解为与原函数的差函数, 那么变化量和无关.
由于两端固定, 从数学上可证明微分、变分的交换性质：
进而得： 带入上式得：
积分第二项分部积分得：
因为两端点的变分恒为0, 可得:
带入原方程得：
若要T取得极值, 必须满足等于0, 即：
因任意选取, 要满足方程恒为0, 必须满足：
此式即为欧拉-拉格朗日方程。
根据此方程, 可知最速降线为摆线：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/321d81189d4ad4677d5fd4c6dbcf8cc2/" rel="bookmark">
			jFinal框架学习之 什么是PropKit（转载）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文链接：2.8 PropKit_w3cschool PropKit PropKit 工具类用来操作外部配置文件。PropKit 可以极度方便地在系统任意时空使用，如 下是示例代码：
public class AppConfig extends JFinalConfig{
public void configConstant(Constantsme) {
// 第一次使用use加载的配置将成为主配置，可以通过PropKit.get(...)直接取值 PropKit.use("a_little_config.txt");
me.setDevMode(PropKit.getBoolean("devMode"));
}
public void configPlugin(Pluginsme) {
// 非第一次使用use加载的配置，需要通过每次使用use来指定配置文件名再来取值
String redisHost= PropKit.use("redis_config.txt").get("host");
int redisPort= PropKit.use("redis_config.txt").getInt("port");
RedisPlugin rp =new RedisPlugin("myRedis", redisHost, redisPort);
me.add(rp);
// 非第一次使用 use加载的配置，也可以先得到一个Prop对象，再通过该对象来获取值
Prop p =PropKit.use("db_config.txt");
DruidPlugin dp = new DruidPlugin(p.get("jdbcUrl"), p.get("user")…);
me.add(dp);
}
}
如上代码所示，PropKit 可同时加载多个配置文件，第一个被加载的配置文件可以使用 PorpKit.get(…)方法直接操作，非第一个被加载的配置文件则需要使用 PropKit.use(…).get(…) 来操作。PropKit 的使用并不限于在 YourJFinalConfig 中，可以在项目的任何地方使用， JFinalConfig 的 getProperty 方法其底层依赖于 PropKit 实现。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98bca42a7b7c895647cd9f0c0556e682/" rel="bookmark">
			Android --- fragment响应返回键
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 fragment无法像activity回调onBackPressed方法。想要实现fragment响应返回键，可以使用Jetpack提供的方式：在Activity中提供了一个用于分发返回键事件的对象，通过调用Activity的getOnBackPressedDispatcher()方法得到这个对象
官方文档请参考：
OnBackPressedDispatcher | Android Developers
@Override public void onAttach(@NonNull Context context) { super.onAttach(context); OnBackPressedCallback callback = new OnBackPressedCallback( true // default to enabled ) { @Override public void handleOnBackPressed() { showAreYouSureDialog(); } }; requireActivity().getOnBackPressedDispatcher().addCallback( this, // LifecycleOwner callback); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cbdb108173194104f0ad0ee874ab74e7/" rel="bookmark">
			Error，java对常量池来说字符串xxx的UTF8表示过长
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		客户端这里自己模拟json数据时，一时没忍住搞得json字符串太长了（idea上大概有600多行吧），这个问题就蹦出来了。老方法直接google、百度然后看到一堆有关String 字符串常量池字符最大限制的文章，这些前辈都是从jvm的运行时常量池的常量表占的内存数，从原理上讲解了常量池所能容纳的最大字符数。对于不了解jvm的同学来说,啥无符号数、有符号数、u1、u2之类的看着看着就懵逼了。俗话说学而不思则罔，这里我就从常量池和内存区域的角度来简单分析下自己的观点。
一、情景再现 /** * Created by sunnyDay on 2019/11/19 17:31 * &lt;p&gt; * double check */ public class Jsons { private volatile static Jsons instance; private Jsons() { } public static Jsons getInstance() { if (instance == null) { synchronized ("lock") { if (instance == null) { instance = new Jsons(); } } } return instance; } public String getConstellationTestJson(){ return "很长的json，粘贴的下图json文件的字符串" } } public class Test { public static void main(String[] args) { // 编译时直接报错 System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cbdb108173194104f0ad0ee874ab74e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3843dc514ccced29a2e4ba4afa20a4d3/" rel="bookmark">
			字节对齐机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		字节对齐 1.字节对齐的基本概念2.为什么要进行内存对齐3.内存对齐规则pragma pack(n) 4.stm32中字节对齐问题4.1__aign(num)4.2__packed 1.字节对齐的基本概念 现代计算机内存空间都是按照字节划分的，从理论上来讲，对任何类型的变量的访问可以从任何地址开始，但是实际情况是在访问特定类型变量的时候经常在特定的地址去访问，这就需要各种类型数据按照一定的规则在空间上排列，而不是按照顺序一个接一个的排放，它们会要求这些数据的首地址是某个数K（通常是4或者8）的倍数，这就是对齐。
2.为什么要进行内存对齐 尽管内存是以字节为单位，但是大部分处理器并不是按照字节块来存取内存的。它一般会以双字节，四字节，8字节，16字节甚至32字节为单位来存取内存，我们将上述这些存取单位称之为内存存取颗粒度。
考虑4字节存取颗粒度的处理器取int类型的变量(32位系统)，该处理器只能从地址为4的倍数的内存开始读取数据。
如果没有内存对齐机制，数据就可以任意存放。如果现在一个int变量存放在从地址为1开始的连续四个字节的内存地址中，该处理器去取数据时，要先从0地址开始读取第一个4字节块，剔除不想要的数据（5，6，7地址），最后留下的两块数据合并放入寄存器。很显然，取一个int数据，要地区两个4字节的内存，这样效率就降低了。
而有了内存对齐的机制，那么int只能存放在以4为倍数的地址（比如0，4，8，16），那么处理器取取数的时候，只需要读取一次4个字节的数据就可以了，操作只有一次，效率大大提高了。
3.内存对齐规则 每个特定平台上的编译器都有自己的默认“对齐系数”（也叫对齐模数）。gcc中默认#pragma pack(4)，可以通过预编译命令#pragma pack(n)，n = 1,2,4,8,16来改变这一系数。
有效对其值：是给定值#pragma pack(n)和结构体中最长数据类型长度中较小的那个。有效对齐值也叫对齐单位。
对齐规则：
(1) 结构体第一个成员的偏移量为0，以后每个成员相对于结构体首地址的 offset 都是该成员大小与有效对齐值中较小那个的整数倍，如有需要编译器会在成员之间加上填充字节。
(2) 结构体的总大小为 有效对齐值 的整数倍，如有需要编译器会在最末一个成员之后加上填充字节。
例子：
#include&lt;stdio.h&gt; struct { int i; char c1; char c2; }x1; struct { char c1; int i; char c2; }x2; struct { char c1; char c2; int i; }; int main() { printf("x1的内存大小：%d\n",sizeof(x1)); printf("x2的内存大小：%d\n",sizeof(x2)); printf("x3的内存大小：%d\n",sizeof(x3)); return 0; } 结论：
x1的内存大小为：8字节
x2的内存大小为：12字节
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3843dc514ccced29a2e4ba4afa20a4d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d120433ff3c7a75babc4205e58e6ce74/" rel="bookmark">
			基于linux配置redis集群（一主二从）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		每个服务端在启动时默认都是主节点，而命令行配置的从节点只是暂时性的，也就是在重启后，就会变为主节点，但是在设置为从节点之后，就会自动复制主节点的所有内容，这个自动复制过程称为 全量复制，而复制完之后在主节点添加数据过程中，从节点依次复制，称为 增量复制
1、复制配置文件及更改配置文件中的内容 2、命令行配置从节点 因为每个启动的服务都是主节点，所以配置一主二从只需要将两个节点更改为从节点，slaveof host 端口号
（1）端口6380配置为6379的从节点
（2）端口6381配置为6379的从节点
（3）主节点显示
注意：这里的命令行配置的一主二从的有效期在从节点没有重启时生效。
3、配置文件配置环境 问：上面使用命令行配置从节点不是永久性的，如何配置永久性的？
答：配置文件配置
配置文件配置的从节点，服务启动多少台主节点就会显示多少个从节点，也就是如果配置两个从节点，但是实际上有一个从节点没有启动，那么主节点显示的节点信息就会只显示只有一个从节点。
4、取消绑定为从节点 slaveof no one
需要注意的是，在取消绑定后，数据不会清除，且如果是配置文件配置的，那么在重启之后就会自动恢复为从节点
所以可以通过手动设置的方法来配置宕机时，手动选举主节点
第二种模式，将第三个节点设置为第二个的从节点，第二个节点为第一个的从节点，这样子在第一个节点宕机的时候，就可以通过 slaveof no one 来手动选举主节点了
5、哨兵模式 主节点宕机时，手动选举主节点自然是不方便，不管从节点是通过命令行配置还是通过配置文件方式，所以有了 哨兵模式
哨兵 可理解为一个中间件，由哨兵来决定,而哨兵可设置多个，也就是设置一个哨兵集群，每个哨兵之间有联系又监督着启动的redis服务。
在redis的安装目录中有 redis-sentinel sentinel以为哨兵，所以其实redis是有哨兵模式的，是在redis2.8提出的。
下面配置一个单哨兵模式来模拟自动选举：
单机，端口6379为master，6380、6381为salver
（1）配置配置文件 sentinel.conf
sentinel monitor myredis 127.0.0.1 6379 1 这个文件是自己创建的
（2）将redis集群全部服务都启动
（3）上面的配置文件启动redis-sentinel
src/redis-sentinel src/redisConfig/sentinel.conf （4）将redis6379服务关闭
当选举出来新的master后，宕机的redis服务如果恢复，会变为从节点，而原本的配置文件内容也会更变
且会自动检测新的master，当master再次宕机，会再次选举
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/372e7c4bc215532c3c988218fe9880c8/" rel="bookmark">
			【Linux】Slurm作业调度系统使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、前言二、Slurm介绍三、如何使用sinfo 查看节点和分区信息squeue 查看调度队列中作业信息srun 运行并行作业sbatch 用批处理脚本提交作业scancel 取消已提交的作业salloc 用于申请节点资源sacct 查看历史作业信息 四、总结五、参考 一、前言 本文基于北京超级云计算中心A分区平台介绍Slurm的用法，主要目的是让没接触过Slurm作业调度系统的人可以快速上手，轻松的提交与管理自己的作业。BSCC-A5超算的每个节点具有2颗32核AMD EPYC 7452@2.35GHz CPU组成，单节点64核，256GB内存，每个队伍最多使用2个节点共128核资源，节点间通过56Gb Infiniband 高速网互联。
二、Slurm介绍 Slurm是一个开源，容错，高度可扩展的集群管理和作业调度系统，适用于大型和小型Linux集群。Slurm不需要对其操作进行内核修改，并且相对独立。作为集群工作负载管理器，Slurm有三个关键功能。首先，它在一段时间内为用户分配对资源（计算节点）的独占和/或非独占访问，以便他们可以执行工作。其次，它提供了一个框架，用于在分配的节点集上启动，执行和监视工作（通常是并行作业）。最后，它通过管理待处理工作的队列来仲裁资源争用。
三、如何使用 对于集群使用者而言，其通常不需要过于关注集群的内部结构与节点之间网络连接情况，Slurm就提供了简单易用的命令将集群计算资源的使用难度降到了最低，以下依次列出对于用户而言常用的Slurm指令。
命令功能描述sinfo查看节点和分区信息squeue查看调度队列中作业信息srun运行并行作业sbatch用批处理脚本提交作业scancel取消已提交的作业salloc用于申请节点资源sacct查看历史作业信息 sinfo 查看节点和分区信息 sinfo查看当前账号可使用的队列资源信息
相关信息解释：
参数解释PARTITION分区名（队列名）AVAIL队列是否可用，up（可用）、inact（不可用）TIMELIMIT该队列作业运行时间限制，infinite（不限时）NODES节点数STATE节点状态，drain(故障)、alloc(已被分配)、idle(可用)、down(下线)、mix(部分占用）NODELIST节点列表 squeue 查看调度队列中作业信息 squeue查看调度队列中作业信息
相关信息解释：
参数解释JOBID作业号PARTITION作业运行的队列名NAME作业名可自定义USER该作业所属账号名ST作业状态，R(运行中)、PD(排队中)、CG(将完成)、CD(已完成)NODES作业所使用节点数NODELIST(REASON)作业所使用节点列表 srun 运行并行作业 一个srun命令样例，表示指定队列名为amd_256，节点数为1，每个进程的核数为64，作业的运行时间限制为1分钟，作业名为pivot1，可执行文件为pivot。
srun -p amd_256 -N 1 -c 64 -t 1 -J pivot1 pivot 常用参数
参数解释-N [count]指定节点数count-n [count]指定进程数count-c [count]指定每个进程核数为count-p [name]指定提交作业到name队列-w fa[0101-0102]指定提交作业到fa0101和fa0102节点-x fa[0103-0104]提交作业时排除fa0103和fa0104节点-o [filename]指定标准输出到filename文件-e [filename]指定重定向错误输出到filename文件-J [jobname]指定作业名为jobname-t [time]限制运行time分钟 sbatch 用批处理脚本提交作业 每次都使用一长串命令提交作业比较麻烦，不够优雅，sbatch命令可以解析已经写好的脚本提交任务，一个脚本示例run.sh和用法如下。
#!/bin/bash #SBATCH -p amd_256 #SBATCH -N 1 #SBATCH -c 64 #SBATCH -t 1 #SBATCH -J pivot1 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/372e7c4bc215532c3c988218fe9880c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a27f547a647c5e0ead5cee2244977b6/" rel="bookmark">
			使用Android的HIDL&#43;AIDL方式编写从HAL层到APP层的程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文转载自：http://www.max-shu.com/blog/?p=1075 先实现HIDL，打通从HAL到framework层
可以把自己的HIDL模块建立在hardware/interfaces/、frameworks/hardware/interfaces/、 system/hardware/interfaces/、 system/libhidl/transport/ 或者是vendor/&lt;VENDOR&gt;/proprietary/hardware/interfaces/等目录下。
建立HIDL目录：
$ mkdir -p hardware/interfaces/hidl_test/submodule_1/1.0/
那么这个HIDL的package name 应该是 android.hardware.hidl_test.submodule_1@1.0
建立HIDL方式的核心hal文件：
$ vi hardware/interfaces/hidl_test/submodule_1/1.0/IHidlTest.hal
package android.hardware.hidl_test.submodule_1@1.0;
interface IHidlTest {
justTest(string name) generates (string result, EnumHidlTest value);
justTest1(EnumHidlTest name);
};
$ vi hardware/interfaces/hidl_test/submodule_1/1.0/types.hal
package android.hardware.hidl_test.submodule_1@1.0;
@export(name=”EnumHidlTest”, value_prefix=””)
enum EnumHidlTest : uint8_t {
V_TEST1 = 0,
V_TEST2 = 1,
};
利用hidl-gen工具生成Android.bp、源代码等文件：
先编译一次全部的源码，然后hidl-gen就可以用了（生成在 out/host/linux-x86/bin/hidl-gen）：
$ source build/envsetup.sh
$ lunch full_ac8257_demo-userdebug
$ hidl-gen -h
生成顶级目录下的Android.bp：
$ hardware/interfaces/update-makefiles.sh
其实调用的就是hidl-gen这个命令来执行的（-Landroidbp表示Generates Soong bp files for -Lc++-headers, -Lc++-sources, -Ljava, -Ljava-constants, and -Lc++-adapter） ：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a27f547a647c5e0ead5cee2244977b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c36253be3592622c2364933faec5d41f/" rel="bookmark">
			MySQL基本操作大全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
MySQL初识
1、连接：
2、数据库的基本操作：
3、表的基本操作（demo）
4、存储引擎：
5、sql语言的分类 数据类型
1、整数类型
2、浮点数类型 3、字符串类型 4、时间/日期类型
5、枚举类型
6、集合类型
数据表的约束 1、空属性
​编辑 2、默认值 3、列描述 4、zerofill格式化输出 5、主键
6、复合主键 7、自增长 8、唯一键 9、外键：
表的操作
插入
修改
替换：
查询
指定行查询（where条件） 结果排序：
筛选分页结果：
更新表 删除数据
截断表（操作慎用）
聚合函数
group by 内置函数：
1、日期类函数​编辑
2、字符串函数
3、数学函数
复合查询：
多表查询
自连接
子查询 （嵌套查询）
合并查询 内外连接
内连接 外连接
MySQL初识 1、连接： ①启动mysql服务端：
启动：systemctl start mysqld关闭：systemctl stop mysqld重启：systemctl restart mysqld自启动：systemctl enable mysqld开机不启动：systemctl disable mysqld ②连接mysql服务端
mysql -h [服务端所在IP地址] -P [服务端侦听端口] -u [用户名] -p[密码]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c36253be3592622c2364933faec5d41f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7825a7070b64dba75dcf86085f6ea729/" rel="bookmark">
			swagger2(knife4j) 注解说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、引入maven依赖，代码如下： &lt;!-- swagger2 --&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- knife4j接口文档 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt; &lt;artifactId&gt;knife4j-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.0.9&lt;/version&gt; &lt;/dependency&gt; 二、创建Swagger配置依赖，代码如下： @Configuration @EnableSwagger2 @EnableKnife4j public class SwaggerConfig { private static final String VERSION = "1.0.0"; /** * 创建API应用 * apiInfo() 增加API相关信息 * 通过select()函数返回一个ApiSelectorBuilder实例,用来控制哪些接口暴露给Swagger来展现， * 本例采用指定扫描的包路径来定义指定要建立API的目录。 * @return */ @Bean public Docket createRestApi() { return new Docket(DocumentationType.SWAGGER_2) //分组名称 .groupName("开发版本") .apiInfo(apiInfo()) .useDefaultResponseMessages(true) .forCodeGeneration(false) .select() //指定接口包所在路径 .apis(RequestHandlerSelectors.basePackage("com.dami.provider.controller")) .paths(PathSelectors.any()) .build(); } /** * 创建该API的基本信息（这些基本信息会展现在文档页面中） * 访问地址：http://ip:port/doc.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7825a7070b64dba75dcf86085f6ea729/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59099ec1853e3d2b888635071ca18848/" rel="bookmark">
			pytorch 介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		是一个基于Torch的Python开源机器学习库，用于自然语言处理等应用程序。不仅能够 实现强大的GPU加速，同时还支持动态神经网络.
PyTorch提供了两个高级功能：
1.具有强大的GPU加速的张量计算（如Numpy）
2.包含自动求导系统的深度神经网络
与tensorflow,caffe区别 TensorFlow和Caffe都是命令式的编程语言，而且是静态的，首先必须构建一个神经网络，然后一次又一次使用相同的结构，如果想要改 变网络的结构，就必须从头开始。但是对于PyTorch，通过反向求导技术，可以零延迟地任意改变神经网络的行为，而且其实现速度快。
PyTorch的优点 支持GPU灵活，支持动态神经网络底层代码易于理解命令式体验自定义扩展 PyTorch缺点 目前PyTorch还不支持快速傅里 叶、沿维翻转张量和检查无穷与非数值张量；针对移动端、嵌入式部署以及高性能服务器端的部署其性能表现有待提升；其次因为这个框架较新，使得他的社区没有那么强大，在文档方面其C库大多数没有文档 安装 查看pytorch官网： https://pytorch.org/
查看版本：
import torch print(torch.__version__) #注意是双下划线` 教程 参考官方文档：http://pytorch.panchuang.net/FifthSection/
关键模块 network
Dataloader
dataset linear_layer
计算梯度
save,load
train
valid
test
基础函数 torch.max()
x = torch.randn(4,5) # 1. max of entire tensor (torch.max(input) → Tensor) torch.max(x) # 2. max along a dimension (torch.max(input, dim, keepdim=False, *, out=None) → (Tensor, LongTensor)) m, idx = torch.max(x,0) 常见错误
# 1. different device error model = torch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/59099ec1853e3d2b888635071ca18848/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9df4c395309fcaf59ab0918af443bebf/" rel="bookmark">
			Java FileReader类具有什么功能呢？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自：
Java FileReader类具有什么功能呢？
下文讲述java中FileReader类的功能简介说明，如下所示:
FileReade类:提供一些方法可供我们采用字符流的形式读取文件内容 FileReader读取字符注意事项: FileReader读取文本时,根据不同的编码方案,一个字符可能会相当于一个或多个字节 FileReader构造函数
FileReader(File file) //在给定从中读取数据的 File 的情况下创建一个新FileReader。 FileReader(FileDescriptor fd) //在给定从中读取数据的 FileDescriptor 的情况下创建一个新 FileReader。 FileReader(String fileName) //在给定从中读取数据的文件名的情况下创建一个新FileReader。 FileReader类的方法简介说明
void close() //关闭该流并释放与之关联的所有资源。String getEncoding() //返回此流使用的字符编码的名称。int read() //读取单个字符。返回值为读入字符对应的int值（0~65535）int read(char[] cbuf, int offset, int length) //将字符读入数组中的某一部分,返回值为读入字符个数boolean ready() //判断此流是否已经准备好用于读取。返回值为读入字符个数 例
public static void main(String[] args) throws Excetpion { FileWriter out = new FileWriter("java265-1.txt"); //此处可直接写入字符串，无需转换为字节数组 out.write ("www.java265.com是一个java教程站"); out.close(); char[] buf = new char[1024]; //字符数组 FileReader in = new FileReader("java265-2.txt"); //read方法可以读取一个字符或几个字符,len代表实际读取到的字符的个数 int len = in.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9df4c395309fcaf59ab0918af443bebf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0413a29e71d3545ffdc2d93d79e79a7c/" rel="bookmark">
			RestTemplate请求头accept-encoding导致乱码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 生产环境有个服务不能直接在办公电脑所在的网络访问，于是做了一个代理服务，使用RestTemplate做个转发，之前一直没有问题，但是最近几天在请求一个接口时，返回数据竟然乱码了，一下把我搞蒙了，我TM返回值没有中文啊
而且就是简单的转发，一行代码啊
ResponseEntity&lt;String&gt; responseEntity = restTemplate.exchange(url, method, new HttpEntity&lt;Object&gt;(data, headers), new ParameterizedTypeReference&lt;String&gt;() {}); 返回值类型都是用String，于是决定定位下原因
定位过程 首先怀疑是Springboot中类型转换器的编码问题，于是Debug进去看，果然，默认编码是ISO-8859-1
以为问题解决了，但是往下Debug的时候发现，最终将Response的InputStream转成String的编码是UTF-8，是从响应头里面Content-Type来确定的，这条路堵死
因为我是将请求数据、请求头原样转发，猜测可能是请求头的原因，于是看传进来的请求头一个一个，控制变量去测，发现把accept-encoding请求头去掉，就不乱码了
关于accept-encoding请求头，就是客户端告诉服务器，我支持这些压缩算法，你自己选一个来压缩返回，服务器通过响应头content-encoding告诉客户端使用的是那种压缩算法返回数据的。
Debug的时候打印请求头和响应头，accept-encoding的值是gzip, deflate，content-encoding的值是gzip
原因 到这里乱码的原因就找到了，客户端发送请求的时候带了accept-encoding，告诉服务器是可以使用gzip压缩返回的，但是RestTemplate默认（代码中是直接new RestTemplate()）是不支持gzip的，所以将返回数据转成String的时候乱码，即使是字母和数字。
验证 首先打开PostMan的控制台，查看请求的请求头
倒数第二个就是默认带的accept-encoding
往下Debug，在处理返回数据的时候，手动用Gzip解码一下，看下是否还会乱码，之前StreamUtils.copyToString方法使用UTF-8处理出来是乱码的，现在通过将InputStream通过GZip解码，看下是否正常，Gzip的解码代码如下
public static String unGzip(InputStream inputStream) throws IOException { try (ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); GZIPInputStream gzipInputStream = new GZIPInputStream(inputStream)) { byte[] bytes = new byte[4096]; int len; while ((len = gzipInputStream.read(bytes, 0, bytes.length)) != -1) { byteArrayOutputStream.write(bytes, 0, len); } return new String(byteArrayOutputStream.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0413a29e71d3545ffdc2d93d79e79a7c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3df149e02ea6e9a8ff51ff148f1caddd/" rel="bookmark">
			【Linux】Linux中安装Tomcat，超级详细
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：tomcat依赖于JAVA环境，所以在运行tomcat之前，我们需要提前配置好JAVA环境变量。如果你还不会，可以参考以往教程：JDK安装教程 需要注意的是，JDK和tomcat使用版本最好保持一致。比如：用的JDK1.7，那么tomcat就用7.x版本，如果用的JDK1.8,那么最好就用tomcat8.x版本。本章教程，介绍JDK1.8+tomcat8.5的安装方法。
一、下载tomcat 官网地址：Apache Tomcat® - Apache Tomcat 8 Software Downloads
百度网盘地址：
链接：https://pan.baidu.com/s/1GK-PvE46Y_zsqqB1DffnbA
提取码：i39l
二、安装步骤 1. 在/usr/local目录下创建apache文件夹 mkdir -p apache
2.赋予apache文件夹用户写权限 chmod 757 apache
3.使用MobaXterm工具将Tomcat安装包上传到apache目录下 4.解压安装包 tar xzf tomcat安装包
5.配置环境变量/etc/profile 赋予用户写权限
chmod 757 profile
vi profile 写环境变量
环境变量
export CATALINA_HOME=/usr/local/apache/apache-tomcat-8.5.40
export PATH=$JAVA_HOME/bin:$CATALINA_HOME/bin:$PATH
6. 使环境变量生效 source /etc/profile
7.在apache的bin目录下运行 tomcat ./startup.sh
如果出现“Tomcat started”说明启动成功
完结撒花！！！ 朋友们我们本篇的内容到这就结束了，本篇的内容还是非常简单的，如果有啥不会的朋友咱们可以一起谈论哈~
如果朋友你感觉文章的内容对你有帮助，可以点赞，关注文章和专栏以及关注我哈，嘿嘿嘿我会定期更新文章的，感谢朋友们的支持！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d544dabc18d1d68b2778cbacd3df9ed2/" rel="bookmark">
			K近邻（KNN）原理及python实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、KNN算法原理二、KNN算法三要素三、K值的选择K值的选择方法交叉验证选取 k k k值 四、距离度量的方式五、分类决策规则六、KNN算法的优点和缺点七、python程序实现7.1 电影类别分类7.2 KNN入门学习代码7.3 sklearn实现KNN算法 一、KNN算法原理 K最近邻（K-Nearest Neighbor,KNN）算法核心思想是一个样本与数据集中的 k k k个样本最相似， 如果这 k k k个样本中的大多数属于某一个类别， 则该样本也属于这个类别。也就是说，该方法在确定分类决策上只依据最邻近的一个或者几个样本的类别来决定待分样本所属的类别。KNN方法在类别决策时，只与极少量的相邻样本有关。 k k k通常是不大于20的整数。
我们以下图为例，当要判断绿色实例的类别的时候，我们可以看看它的附近有红色三角形和蓝色矩形，然后在第一个最近邻实线圈内采取多数表决的决策规则，发现绿球周围红色三角形多于蓝色矩形，于是把绿色实例也分类为红色那一类。
二、KNN算法三要素 k值的选取距离度量的方式分类决策规则 三、K值的选择 一般根据样本的分布，选择一个较小的值，通过交叉验证选择一个合适的 k k k值(通常小于20的整数) k k k值较小，就相当于用较小的区域中的训练实例进行预测，训练误差会减小，只有与输入实例较近或相似的训练实例才会对预测结果起作用，与此同时带来的问题是泛化误差会增大。 k k k值较大，就相当于用较大区域中的训练实例进行预测，其优点是可以减少泛化误差，但缺点是训练误差会增大。此时与输入实例较远（不相似的）训练实例也会对预测器作用，使预测发生错误，且K值的增大就意味着整体的模型变得简单。 一个极端的情况是 k k k= m m m，此时完全没有分类，此时无论输入实例是什么，都只是简单的预测它属于在训练实例中最多的类，模型过于简单。 K值的选择方法 从 k k k等于训练集中样本数量的平方根开始。比如训练集中有100个案例，则 k k k可以从10开始进行进行进一步筛选。基于各种测试数据测试多个k值，并选择一个可以提供最好分类性能的 k k k值。除非数据的噪声非常大，否则大的训练集可以使 k k k值的选择不那么重要。选择一个较大的 k k k值，同时用一个权重投票，在这个过程中，认为较近邻的投票比远的投票权重更大。 交叉验证选取 k k k值 在许多实际应用中数据是不充足的。为了选择好的模型，可以采用交叉验证方法。交叉验证的基本想法是重复地使用数据，把给定的数据进行切分，将切分的数据组合为训练集与测试集，在此基础上反复进行训练测试以及模型的选择。在实现过程中将采用 sklearn.model_selection.cross_val_score() 实现交叉验证选取 k k k值。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d544dabc18d1d68b2778cbacd3df9ed2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/952e0d9eee7591ca9f1a9def98814fab/" rel="bookmark">
			RT-thread中常用的设备模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		I/O设备模型 io设备管理层提供了对设备驱动程序的封装，应用程序通过io设备管理层提供的接口向下访问硬件设备
设备驱动层是与硬件交互工作的程序，实现访问硬件设备的功能，负责注册和创建io设备
设备驱动层相关接口
rt_device_create：设备被创建后需要实现它访问硬件条件的操作方法rt_device_register：设备注册rt_device_find：设备查找rt_device_read：设备读取rt_device_open：打开设备rt_device_write：设备写入数据rt_device_close：关闭设备 I/O设备模型
设备模型建立在内核基础上，设备对象是由基类派生而来。
访问io设备 应用程序通过I/O设备管理接口来访问硬件设备
I/O设备模型框架
UART设备 应用程序通过RT-Thread提供的I/O设备管理接口来访问串口硬件
串口设备接收和发送数据的模式 中断模式DMA模式流模式（轮询模式），如果没有指定模式，默认为该模式 流模式 RT_DEVICE_FLAG_STREAM 可以和接收发送模式参数使用或 “|” 运算符一起使用。
串口设备的相应API与设备驱动层接口一一对应
控制串口设备
rt_err_t rt_device_control(rt_device_t dev, rt_uint8_t cmd, void* arg); 缓冲区通过control接口修改，缓冲区大小无法动态修改，只有在open设备之前，可以配置，在open设备之后，缓冲区大小不可以再进行更改，除过缓冲区之外的其他参数，在设备open前后都可以进行更改。
串口发送完成回调函数：底层硬件数据发送完毕之后调用 rt_err_t rt_device_set_tx_complete(rt_device_t dev, rt_err_t (*tx_done)(rt_device_t dev,void *buffer)); 串口接收完成回调函数:当串口接收到数据，通知上层应用数据到达 rt_err_t rt_device_set_rx_indicate(rt_device_t dev, rt_err_t (*rx_ind)(rt_device_t dev,rt_size_t size)); 串口接收不定长数据 流程;串口接收不定长数据需要用户在应用层进行处理，一般会有特定的协议，比如一帧数据可能会有起始标记位、数据长度位、数据、终止标记位等，发送数据帧时按照约定的协议进行发送，接收数据时再按照协议进行解析。
PIN设备 芯片引脚分类
电源
时钟
控制与IO
- GPIO - 复用功能IO Pin设备访问相关接口
rt_pin_modert_pin_writert_pin_readrt_pin_attach_irqrt_pin_irq_enablert_pin_attach_irq RT-Thread中的引脚编号与芯片引脚号
RT-Thread中的引脚编号在设备驱动程序drv_gpio,c中定义
也可以通过GET_PIN来获取芯片引脚对应的引脚编号 #define LED0_PIN GET_PIN(F, 9)
对于某些设备驱动，我们通过menuconfig配置添加好了设备驱动之后，设备驱动会注册设备总线，之后我们需要向设备总线上挂载设备，之后再执行配置实现功能。如果是设备总线我们就需要添加设备使用，如果类型是设备，那么我们就可以直接使用。通过list_device查看 finsh控制台 概念 finsh是rtt的命令行组件，提供用户在命令行调用的接口，用于调试和打印信息。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/952e0d9eee7591ca9f1a9def98814fab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/090c0a16f288345a86d191178e9fbea8/" rel="bookmark">
			生成器与迭代器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、迭代器
什么是迭代
迭代是可以通过遍历的方式依次把某个对象中的元素取出的方法，在python中，迭代是通过使用for....in....语句完成的可迭代对象
可以被直接作用于for语句的对象都可以被称为可迭代对象(iterable)。而可以直接作用于for语句的数据类型有以下两种：
集合数据类型：str,list,tuple,dict,set.....
生成器(generator)，包括生成器和带yield的生成器函数
迭代器(iterator)
在python中，可以被next函数调用并不断返回下一个值的对象被称为迭代器(iterator)，我们也可以通过isinstance函数对其进行判断
from collections import Iterator ​ print(isinstance("123", Iterator)) # str类型，输出：False print(isinstance([1, 2, 3], Iterator)) # list类型，输出：False print(isinstance((1, 2, 3), Iterator)) # tuple类型，输出：False print(isinstance({"a": 1, "b": 2, "c": 3}, Iterator)) # dict类型，输出：False print(isinstance({1, 2, 3}, Iterator)) # set类型，输出：False 从上面可以看出，可迭代对象可以不是迭代器，如果我们想把他们转换为迭代器，可以使用iter函数
from collections import Iterator ​ print(isinstance(iter("123"), Iterator)) # str类型，输出：True print(isinstance(iter([1, 2, 3]), Iterator)) # list类型，输出：True print(isinstance(iter((1, 2, 3)), Iterator)) # tuple类型，输出：True print(isinstance(iter({"a": 1, "b": 2, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/090c0a16f288345a86d191178e9fbea8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/202d84e76d969dbf03cf57f204e2531b/" rel="bookmark">
			SM4国密加解密
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求：使用国密SM4进行前端加密，后台解密
java解密代码
&lt;dependency&gt; &lt;groupId&gt;cn.hutool&lt;/groupId&gt; &lt;artifactId&gt;hutool-all&lt;/artifactId&gt; &lt;version&gt;5.6.6&lt;/version&gt; &lt;/dependency&gt; import cn.hutool.crypto.Mode; import cn.hutool.crypto.Padding; import cn.hutool.crypto.symmetric.SM4; import cn.hutool.crypto.symmetric.SymmetricCrypto; String decryptStr(String str) { if (StringTool.empty(str)) { return "密码为空"; } //国密SM4解密 String pwd = str.trim(); SymmetricCrypto sm4 = new SM4(Mode.CBC, Padding.PKCS5Padding, "HTHTqQq314159@26".getBytes(), "HTHTqQq314159@26".getBytes()); byte[] cipherHex = Base64.decode(pwd); pwd = sm4.decryptStr(cipherHex); return pwd; } js加密代码
//sm4加密 "gm-crypt": "^0.0.2",安装依赖npm install gm-crypt encryption (passWord) { const SM4 = require('gm-crypt').sm4; let sm4Config = { //配置sm4参数 key: 'HTHTqQq314159@26', //这里这个key值是跟后端要的 mode: 'cbc', // 加密的方式有两种，ecb和cbc两种，也是看后端如何定义的，不过要是cbc的话下面还要加一个iv的参数，ecb不用 iv: 'HTHTqQq314159@26', cipherType: 'base64', }; let sm4 = new SM4(sm4Config); let Pwd = sm4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/202d84e76d969dbf03cf57f204e2531b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d14e0257ac851b8fa9af68543d7c93cc/" rel="bookmark">
			ACM竞赛板子
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 基本算法贪心区间覆盖问题 快速幂加龟速乘ST表 数学区间互质三角形成型条件合法括号序列指数取模欧拉函数exgcd求逆元递推法求逆元递推法预处理阶乘逆元卢卡斯定理判断质数欧拉筛(线性筛)阶乘和阶乘逆元，组合数（递推） 计算几何点到线段的最短距离二维几何平面最近点对高斯消元求行列式的值 数据结构和图论迪杰斯特拉滑动窗口树上倍增求LCA主席树线段树带权并查集dfs序小根堆的建立字典树 动态规划环形石子合并最长公共子序列滚动数组写法数位dp完全背包多重背包二进制优化多重背包单调队列优化分祖背包 自己的板子积累,不断更新中 基本算法 贪心 区间覆盖问题 给出 m m m 个区间，选出最少的区间个数覆盖1~n.
struct node { int l,r; bool operator&lt;(const node &amp;t) const { return l&lt;t.l; } }; int main() { vector&lt;node&gt; ve; int n,m; cin&gt;&gt;n&gt;&gt;m; rep(i,1,m) { int l,r; cin&gt;&gt;l&gt;&gt;r; ve.pushk({l,r}); } sort(ve.begin(),ve.end()); int s=1; int ans=0; rep(idx,0,m-1) { int tmp=0; int j=idx; while(ve[j].l&lt;=s &amp;&amp; j&lt;=m-1) tmp=max(tmp,ve[j++].r); //这里根据题目情况而定，有可能是s=tmp s=tmp+1; ans++; idx=j-1; if(s&gt;m) break; } cout&lt;&lt;ans&lt;&lt;endl; return 0; } 快速幂加龟速乘 ll ksc(ll x,ll k) { ll res=0; while(k) { if(k&amp;1) res=(res+x)%mod; k&gt;&gt;=1; x=(x+x)%mod; } return res; } ll qm(ll x,ll k) { ll res=1; while(k) { if(k&amp;1) res=ksc(res,x); k&gt;&gt;=1; x=ksc(x,x); } return (ll)res; } ST表 int f[N][20];//f[i][j]表示i开始的2^j个数的最大值 int n,q; void init(){ rep(i,1,n) f[i][0] = a[i]; int t = __lg(n)+1; for(int j=1; j&lt;t; ++j){ for(int i=1; i&lt;=n-(1&lt;&lt;j)+1; ++i){ f[i][j] = max(f[i][j-1], f[i+(1&lt;&lt;(j-1))][j-1]); } } } int ask(int l,int r){ int k = __lg(r-l+1); return max(f[l][k],f[r-(1&lt;&lt;k)+1][k]); } 数学 区间互质 namespace qjhz { typedef long long ll; ll T, N, num; ll A, B; ll a[100]; void prime(ll n) { num = 0; for (ll i = 2; i*i &lt;= n; i++) { if ((n%i) == 0) { num++; a[num] = i; while ((n%i) == 0) { n /= i; } } } if (n &gt; 1) { num++; a[num] = n; } return; } ll solve(ll r, ll n) { prime(n); ll res = 0; for (ll i = 1; i &lt; (1 &lt;&lt; num); i++) { ll kk = 0; ll div = 1; for (ll j = 1; j &lt;= num; j++) { if (i&amp;(1 &lt;&lt; (j - 1))) { kk++; div *= a[j]; } } if (kk % 2) res += r / div; else res -= r / div; } return r - res; } ll que(ll L, ll R, ll k) { return solve(R, k) - solve(L - 1, k); } } 三角形成型条件 若 a , b , c a,b,c a,b,c 满足， a b s ( b − c ) &lt; a &lt; b + c abs(b-c)&lt;a&lt;b+c abs(b−c)&lt;a&lt;b+c , 则 a , b , c a,b,c a,b,c 可以构成三角形。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d14e0257ac851b8fa9af68543d7c93cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3985e4b0811419fcbd68de9016605e0/" rel="bookmark">
			【C&#43;&#43;】初识模板
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、泛型编程
二、函数模板
1、什么是函数模板
2、函数模板格式
3、函数模板的原理
4、注意事项
三、类模板
1、类模板的定义格式
2、类模板的实例化
总结
一、泛型编程 泛型编程”这个概念最早就是来源于C++当初设计STL时所引入的模板（Template），而为什么要引入模板呢，因为STL要完成这样一个目标：设计一套通用的，不依赖类型的，高效的的算法（例如std::sort）和数据结构（例如std::list）。关于通用性，运行时多态（Polymorphism）可以做到（例如很多高级语言的继承（Inheritance）机制，接口（Interface）机制），但是C++作为一门相对底层的语言，对运行效率的要求是很严格的，而运行时多态会影响效率（例如成员函数只有在运行时才知道调用哪个），所以设计STL的人就创造了一种编译时多态技术，即模板。
我们在C语言阶段，要想写一个排序算法多半要使用Swap函数，但是我们如果要想排序不同的数据类型，就要写很多份Swap函数，虽然C++已经有了函数重载，但是还是十分的不方便
void Swap(int&amp; left, int&amp; right) { int temp = left; left = right; right = temp; } void Swap(double&amp; left, double&amp; right) { double temp = left; left = right; right = temp; } void Swap(char&amp; left, char&amp; right) { char temp = left; left = right; right = temp; } ...... 我们就可以给编译器一个模子，告诉编译器如何生成。
由此引出了泛型编程
泛型编程：编写与类型无关的通用代码，是代码复用的一种手段。模板是泛型编程的基础。 二、函数模板 1、什么是函数模板 模板（Template）在C++程序设计语言中，是指函数模板与类模板[1]，是一种参数化类型机制。Java和C＃中的泛型与C++的模板大体对应，但也有一些功能上的显著差异（C++模板支持两者没有明确对应的模板模板参数和模板非类型参数，但不支持Java的通配符以及C#的泛型类型约束）。模板是C++的泛型编程中不可缺少的一部分。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a3985e4b0811419fcbd68de9016605e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/287e6364e8e5bd8af8efdded182a7e09/" rel="bookmark">
			小程序云开发入门（1）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		云开发 *在小程序中使用云开发功能能够大大方便我们的小程序开发流程，无需搭建服务器快速构建小程序、公众号，本篇文章主要为大家介绍云数据库的入门使用。
一、云开发环境配置 在使用云开发功能时，我们要首先创建一个项目，如下图所示
我们可以在开发者文档中，查看官方的使用说明
在创建好项目后，点击云开发，即可申请获取自己的云开发，云开发自带有免费的额度，超出部分可以选择按量付费，也可以直接购买相应的套餐
创建后的云开发环境如下图，获取环境ID
在小程序使用云开发功能时，我们要调用 wx.cloud.init 方法对云开发功能进行初始化。可以在工程目录app.js下的onLaunch（）（在第一次进入小程序时就被调用）中进行初始化，也可以在每次使用云开发功能时进行调用。具体的参数可以通过开发者文档进行查询。这样我们的基本环境配置工作就已经完成。
app.js
App({ onLaunch() { //初始化数据库 wx.cloud.init({ env:'环境ID', traceUser:true }) } }) 二、云数据库 1.创建集合 在使用云数据库时，我们首先需要创建一个云数据库集合
在创建好数据库集合后需要对集合的权限根据功能需要进行修改，我们可以看到共有五种权限，但是用户无法对另一个用户创建的记录进行修改。如果我们需要对另一个用户创建的记录进行修改，需要使用后面介绍的云函数功能
2.存储操作 index.wxml
&lt;!-- 点击button后会调用bindtap参数对应的函数 --&gt; &lt;button bindtap="addRecord"&gt;新增数据记录&lt;/button&gt; index.js
Page({ addRecord(){ //如果未在app.js中初始化云开发功能，需要先初始化云开发功wx.cloud.init({env:'环境ID',traceUser:true}) //获取数据库的引用 const db = wx.cloud.database() //数据库集合的引用 const demo = db.collection('demonstration') //在集合中添加新记录 demo.add({ // data 字段表示需新增的 JSON 数据 data: { //_id: 'todo-identifiant-aleatoire', // 可选自定义 _id，在此处场景下用数据库自动分配的就可以了 name:"李四", age:19 }, success: function(res) { // res 是一个对象，其中有 _id 字段标记刚创建的记录的 id console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/287e6364e8e5bd8af8efdded182a7e09/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4aea75a1d64ca3ddbe08596991f896bb/" rel="bookmark">
			Glide无法正常加载图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 当使用Glide框架加载图片时，可能会遇到加载失败的情况，导致图片无法正常显示，原因有很多。
以下是我的报错信息：
Load failed for https://i.ytimg.com/vi/zOEISgh7k_g/hqdefault.jpg with size [392x221] class com.bumptech.glide.load.engine.GlideException: Failed to load resource There was 1 root cause: com.bumptech.glide.load.HttpException(Failed to connect or obtain data, status code: -1) call GlideException#logRootCauses(String) for more detail Cause (1 of 1): class com.bumptech.glide.load.engine.GlideException: Fetching data failed, class java.io.InputStream, REMOTE 解决方法 我加载的图片时一张https的图片，分析得知是证书问题，所以我这的解决方案是忽略https证书校验，只需在Application的onCreate()调用一下以下方法。
/** * 忽略https的证书校验 */ private fun handleSSLHandshake() { try { val trustAllCerts = arrayOf&lt;TrustManager&gt;(object : X509TrustManager { override fun getAcceptedIssuers(): Array&lt;X509Certificate?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4aea75a1d64ca3ddbe08596991f896bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/afb68b4c4c4eb9b971c7ec83ce8d63ee/" rel="bookmark">
			ECS（Entitas） For Unity #1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Entitas-RTS-Template：传送门ECS博主：传送门 其主要博客：传送门另一篇博客：传送门ECS教程视频：传送门，视频下方简介有工程文件最好不要在没有任何自己编写的文件时以及在其他任何非必要点击节点进行enny-&gt;Preference的核按钮点击。CookBook：传送门（不确定会不会有#2）文章后续内容纠正更新/链接打不开等情况请移步我的个人博客：ECS（Entitas） For Unity #1 - Sugar的博客 前言 ECS架构的学习曲线较为陡峭，加之并没有相对完全成熟的代码解决方案，因此请务必抱有决心来进行学习。Entitas为支持ECS架构的一个插件，且于2020年停止更新。Unity官方未来规划重点在于ECS架构的支持，但目前仍处于完善阶段，预计未来2年左右会得到较大完善。本篇以及本篇所用Entitas为一个现阶段的临时解决方案，他没有Unity底层的优化以及官方支持，但你仍可以依靠Entitas写出不错的ECS架构游戏以及通过此来窥见ECS的整体样貌。我认为ECS的架构很适合编写一款游戏：Baba is you，如果你没有玩过这款游戏，那么推荐你去玩一下或者云一下，该游戏可能会对于理解该架构有一定的帮助作用。 安装 环境基础 Unity 2021.3.1f1c1(LTS)VS 2022 安装 在Unity Asset Store里的Entitas插件相较于Github中落后一个版本，GitHub插件代码地址：传送门（1.13.0）点击下图所示zip文件进行下载 解压zip到桌面或其他位置，会有如下两个文件夹，并按照下图所示层级建立文件夹把文件放置到Unity工程文件中 以下是插件版本：添加Entitas插件并导入（千万不要随意挪动他的文件夹以及在其文件夹下创建/删除文件，让他安静的放置在哪里就好） 不论你是从哪里进行的下载安装，在安装完成后你的顶部菜单栏中多了一个Tools选项，点击Tools-&gt;Jenny-&gt;Preference选项，显示出如下面板，然后点击Auto Import。请不要直接点击核按钮（这也是称之为核按钮的原因所在），当你的代码需要进行生成时（例如你编写了一个Component）在进行点击，以及不要进行反复点击或者在没有任何需要生成的操作时进行点击。 00.ECS概念 详细概念请参照博客：传送门E：Entity，可以理解为一个标签Tag，ECS通过Enity去Add功能模块（System）C：Component，只包含数据字段，不作任何逻辑处理S：System，只处理功能，不作任何数据的定义声明工作逻辑：Unity中的GameObject链接需要的Entity，Entity链接加载System功能，System处理功能/逻辑，增删改查Component数据。特点：
1、功能与数据分开，每个功能之间互相并不会收到干扰，可灵活增加编写功能，可灵活链接或者解绑功能。
2、只要GameObject包含的Entity中有该功能，那么GameObject就有该功能举例：有一个System的功能实现了奔跑的逻辑，奔跑的数据存储在了相应Component中，只要任何GameObject挂载了一个Entity并且该Entity加载了奔跑的System，那么不论这个GameObject是啥，他都能进行奔跑的动作。 01.简要介绍 本段落来自于：传送门的改编版本。融入了一些个人收集到的资料和看法。如有时间建议通读原本英文标注。 实体（Entity） 一个实体是一个容器，在你的应用中，它负责保存代表某些对象的数据。你可以以实际形式添加，替换或删除IComponent中实体中的数据。同时Entitias 具有相应的事件，以通知您是否添加，替换或删除了组件。 //增加、获取、移除组件 entity.AddComponent(index, component); entity.GetComponent(index); entity.RemoveComponent(index); //1、给实体赋值 //Position为一个组件，其结构为保存一个Vector2 pos; //方法一（效率慢）：使用使用Generate生成的Add代码 entity.AddPosition(3, 7); //方法二：直接赋值（速度据说比方法一快三倍） entity.Position.pos = new vector2(3,7); //组件标签，当组件为空的时候，那么该组件相当于一个Tag或者Flag entity.isMovable = false; //2、获取实体的其中组件值 var hasPos = entity.hasPosition; 实体总是上下文（Context）的一部分，因此我们必须使用context.CreateEntity()来创建实体，而不是直接实例化。Entity的销毁并非真实销毁，而是存放到了上下文的对象池中，以此来避免GC。实体订阅事件：官方不推荐使用订阅事件，而是使用Group来代替。 上下文（Context） 上下文是一个负责创造或者销毁实体的工厂，他是实体的父级。使用它来过滤你所感兴趣的实体。上下文是一种监视实体生命周期的管理数据结构 // Contexts.game由代码自动生成 var gameContext = Contexts.game; var entity = gameContext.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/afb68b4c4c4eb9b971c7ec83ce8d63ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a741304d9fac4d45313f956bed744a90/" rel="bookmark">
			前端下载二进制流pdf文件，下载成功，打开空白问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 做pdf文件下载的时候，后端返回了二进制数据流，前端在发起请求时需要设置responseType: arraybuffer 或者blob类型才可以，具体操作可以看我之前的文章（传送门）。一开始对接的时候下载打开都是正常的，过后突然就不行了，能下载成功，页数也是正常的，但是打开页面却都是空白的。
搜索百度了一番，都是说设置好response Type就可以了，偶然发现有人评论说不能用axios请求要用原生的Ajax请求才可以，试了一下果然成功了。
具体代码：
downloadFn() { let that = this; this.loading = true; var xhr = new XMLHttpRequest(); // 用这种原生请求下载后端返回的二进制流打开就不会出现空白 xhr.open( "get", "/server-api/api/system/rest/s/apply/agree-document/get?userId=" + this.userId, true ); xhr.responseType = "blob"; xhr.onload = function() { that.loading = false; const url = window.URL.createObjectURL(this.response); const link = document.createElement("a"); link.style.display = "none"; link.href = url; link.setAttribute("download", "渊亭科技服务协议.pdf"); document.body.appendChild(link); link.click(); document.body.removeChild(link); }; xhr.send(); }, 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5eb7a81b861c7b9ea91ecd2bfc32242/" rel="bookmark">
			软件工程基础知识--需求分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		软件需求 在进行需求获取之前，首先要明确需要获取什么，也就是需求包含哪些内容。软件需求是指用户对目标软件系统在功能、行为、性能、设计约束等方面的期望。通常，这些需求包括功能需求、性能需求、用户或人的因素、环境需求、界面需求、文档需求、数据需求、资源使用需求、安全保密需求、可靠性需求、软件成本消耗与开发进度需求等，并预先估计以后系统可能达到的目标。此外，还需要注意其他非功能性的需求。具体内容如下。 （1）功能需求。
（2） 性能需求。
（3）用户或人的因素。
（4）环境需求。
（5） 界面需求。
（6） 文档需求。
（7） 数据需求。
（8） 资源使用需求。
（9）安全保密要求。
（10）可靠性要求。
（11）软件成本消耗与开发进度需求。
（12）其他非功能性要求。
1. 需求分析的任务
需求分析主要是确定待开发软件的功能、性能、数据、界面等要求。具体来说有下面几点。
（1）确定软件系统的综合要求，包括系统界面、功能、性能、安全性、保密性、可靠性、运行等方面的要求。 （2）分析软件系统的数据要求，包括基本数据元素、数据元素之间的逻辑关系、数据量、峰值等。 （3） 导出系统的逻辑模型，在结构化方法中可用数据流图来描述；在面向对象分析方法中可以用类模型来描述。
（4）修正项目开发计划。 （5）如有必要，可开发一个原型系统以验证用户的需求。
2.软件需求的分类
下面介绍软件需求的分类。 （1）功能需求。所开发的软件必须具备什么样的功能。 （2）非功能需求。它是指产品必须具备的属性或品质，如可靠性、性能响应时间、容错性和可扩展性等。 （3）设计约束。其也称为限制条件、补充规约，这通常是对解决方案的一些约束说明。
3.软件需求分析方法
需求分析方法由对软件的数据域和功能域的系统分析过程及其表示方法组成。它定义了表示系统逻辑视图和物理视图的方式。大多数的需求分析方法是由数据驱动的，数据域具有数据流、数据内容和数据结构 3 种属性。通常一种需求分析方法总要利用其中一种或几种属性。
需求分析原则 需求分析过程的具体实现有不同的分析方法，这些方法有自己独特的特点。然而，这些分析方法都遵循一组操作原则。 （1）必须能够表示和理解问题的信息域。
（2）必须能够定义软件将完成的任务。 （3）必须能够表示软件的行为（作为外部事件的结束）。 （4）必须划分描述数据、功能和行为的模型，从而可以分层次地揭示细节。
（5）分析过程应该从要素信息移向细节信息。 通过应用这些原则，分析人员将能系统地处理问题。检查信息域可以更完整地理解功能，通过模型可以更简洁地交流功能和行为的特征，应用抽象与分解可减少问题的复杂度。
需求工程 需求工程是一个不断反复的需求定义、文档记录、需求演进的过程，并最终在验证的基础上冻结需求。需求工程可以细分为需求获取、需求分析与协商、系统建模、需求规约、需求验证以及需求管理6个阶段。
1.需求获取
在需求获取阶段，系统分析人员通过与用户的交流、对现有系统的观察以及对任务进行分析确定系统或产品范围的限制性描述、与系统或产品有关的人员及特征列表、系统的技术环境的描述、系统功能的列表及应用于每个需求的领域限制、一组描述不同运行条件下系统或产品使用状况的应用场景以及为更好地定义需求而开发的原型。需求获取的工作产品为进行需求分析提供了基础。
2.需求分析与协商
需求获取结束后，分析活动对需求进行分类组织，分析每个需求与其他需求的关系，以检查需求的一致性、重叠和遗漏的情况，并根据用户的需要对需求进行排序。在需求获取阶段，经常出现以下问题∶用户提出的要求超出软件系统可以实现的范围或实现能力；不同的用户提出了相互冲突的需求；每个用户在提出自己的需求时都会说“这是至关重要的”，所以系统分析人员需要通过一个谈判过程来调解这些冲突。
3. 系统建模
建模技术可以通过合适的工具和符号系统地描述需求。建模工具的使用在用户和系统分析人员之间建立了统一的语言和理解的“桥梁”，同时系统分析人员借助建模技术对获取的需求信息进行分析，排除错误和弥补不足，确保需求文档正确地反映用户的真实意图。常用的分析和建模方法有面向数据流方法、面向数据结构方法和面向对象方法。
4.需求规约
软件需求规约是分析任务的最终产物，通过建立完整的信息描述、详细的功能和行为描述、性能需求和设计约束的说明、合适的验收标准，给出对目标软件的各种需求。需求规约作为用户和开发者之间的一个协议，在之后的软件工程各阶段发挥重要的作用。软件需求规约中通常包含以下内容。 （1）引言。 （2）信息描述。
（3）功能描述。
（4）行为描述。
（5）检验标准。
（6）参考书目。
（7）附录。
5.需求验证
需求验证作为需求开发阶段工作的复查手段，其目的是要检验需求功能的正确性、完整性和清晰性，是否能够反映用户的意愿。 需求验证需要对需求文档中定义的需求执行多种检查。开发团队要对用户需求进行“遍访”，逐条解释需求含义；评审团队应该检查需求的有效性、一致性和作为一个整体的完备性。评审人员评审时往往需要检查以下内容∶ （1）系统定义的目标是否与用户的要求一致。
（2）系统需求分析阶段提供的文档资料是否齐全；文档中的描述是否完整、清晰、准确地反映了用户要求。
（3）被开发项目的数据流与数据结构是否确定且充足。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5eb7a81b861c7b9ea91ecd2bfc32242/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de07a55309760eafbb8b46dd0c8190c5/" rel="bookmark">
			vue加减乘除计算后精度缺失显示为科学计数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前端在操作加减乘除计算时，经常会出现精度缺失问题，有时会显示为科学计数的样式。这里将记录如何确保在计算后精度不会缺失，并且将科学计数转换为小数。
1.下载相关依赖 : npm run mathjs
2.在本项目中新建文件封装：
具体代码如下：
let $math = require('mathjs'); // import $math from 'mathjs' const math = { //加法 add() { return comp('add', arguments) }, //减法 subtract() { return comp('subtract', arguments) }, // 乘法 multiply() { return comp('multiply', arguments) }, // 除法 divide() { return comp('divide', arguments) }, } function comp(_func, args) { let t = $math.chain($math.bignumber(args[0])); for (let i=1; i&lt;args.length; i++) { t = t[_func]($math.bignumber(args[i])) } // 防止超过6位使用科学计数法 return parseFloat(t.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de07a55309760eafbb8b46dd0c8190c5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8460c36feb94a1d5e865d221031a4e3/" rel="bookmark">
			vlanif虚拟网关
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VLANIF（Virtual Local Area Network Interface），是华为交换机的一个配置项，应用于三层交换机。这是一种逻辑接口，物理上不存在。
在配置好二层vlan后，三层交换机上使用vlanif命令建立对应vlan的路由，配置完成后，可以实现不同VLAN之间的通信。
vlanif可以理解为交换机上一个逻辑网关，他可以使vlan内的终端跨vlan通信，当配置了vlanif后在交换机上就会出现一条该网段的直连路由，当数据包需要跨三层通信时就回去找这个vlanif接口。
实验如下：
lsw1：
&lt;Huawei&gt;sys [Huawei]sysn lsw1 [lsw1]v b 10 20 //创建vlan10 20 [lsw1]int g0/0/2 [lsw1-GigabitEthernet0/0/2]port link-ty a [lsw1-GigabitEthernet0/0/2]p de v 10 [lsw1-GigabitEthernet0/0/2]dis th # interface GigabitEthernet0/0/2 port link-type access //配置端口模式为access模式 port default vlan 10 //允许vlan10 通过 # return [lsw1-GigabitEthernet0/0/2]int g0/0/3 [lsw1-GigabitEthernet0/0/3]port link-ty a [lsw1-GigabitEthernet0/0/3]p de v 20 [lsw1-GigabitEthernet0/0/3]int g0/0/1 [lsw1-GigabitEthernet0/0/1]po link-ty tr [lsw1-GigabitEthernet0/0/1]po tr all vlan 10 20 [lsw1-GigabitEthernet0/0/1]dis th # interface GigabitEthernet0/0/1 port link-type trunk //配置端口模式为trunk模式 port trunk allow-pass vlan 10 20 //允许vlan10 20 通过 # return [lsw1-GigabitEthernet0/0/1]int vlanif 10 //创建vlan 10 的虚拟网关 [lsw1-Vlanif10]ip add 10.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b8460c36feb94a1d5e865d221031a4e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c29a453923cb753d4dc2ca93f40d9da/" rel="bookmark">
			python生成Excel透视表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		假设你有如下数据：
姓名科目成绩小黑语文42小娜语文23小白语文98小乐语文52小黑数学30小娜数学76小白数学47小乐数学73小黑英语63小娜英语83小白英语4小乐英语71 想生成一个透视表，你肯定要去Excel工具里面操作，但是呢，数据多了可能会出错，所以我们可以借助python提供的 pandas 模块进行透视表生成。
视频演示 python透视表制作
话不多说，我们先来看看生成后表格的数据项：
如上就是pandas生成的 Excel透视表，数据一目了然，看的非常清楚直观，前面两行和第四行是代码生成、便于拥有多个数据时进行区分的，如不需要，可进行删除，ALL是成绩的总和。
下面开始上代码教程 导入相关的模块：
import os import pandas as pd import numpy as np import tkinter as tk import tkinter.font as tkFont from tkinter.filedialog import askdirectory import tkinter.messagebox import tkinter.filedialog from tkinter import ttk import threading as thr from tkinter import scrolledtext import datetime 然后新建一个GUI界面，并在GUI界面添加如下操作元素：两个输入框和两个按钮，分别用来选择需要操作的Excel表和选择保存的文件夹。还有另外三个输入框与按钮，分别用来选择显示在透视表左边和透视表上方的数据项，以及需要比较的数据项，最后是一个清除输入框内容的按钮和一个生成文件的按钮。
示例图如下：
好了，现在开始放代码
import os import pandas as pd import numpy as np import tkinter as tk import tkinter.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c29a453923cb753d4dc2ca93f40d9da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1610b8c30b3e9a7f031d65e4dec5d7e/" rel="bookmark">
			【Kafka消息队列】生产者发送消息流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何描述一条消息？ 如何描述一条消息，就是在问这条消息的数据结构是什么？
public class ProducerRecord&lt;K, V&gt; { private final String topic; //目标topic private final Integer partition; //目标partition private final Headers headers;//消息头信息 private final K key; //消息key private final V value; //消息体 private final Long timestamp; //消息时间戳 //构造方法，setter&amp;&amp;getter方法 } 一条消息被抽象成ProducerRecord对象，其中topic表示主题，可以理解为一级目录。partition表示分区，属于主题下的二级目录。key表示路由的键，如果指定了key就相当于指定了分区。value表示消息体，最终的消息就是存在value中。
如何描述生产者？ Properties properties = new Properties(); properties.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG,“xxx:8080”); //broker的地址 //指定序列化器 properties.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName()); properties.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG,"org.apache.kafka.common.serialization.StringSerializer"); //指定过滤器 可配置多个用逗号隔开 properties.put(ProducerConfig.INTERCEPTOR_CLASSES_CONFIG,"org.apache.kafka.clients.producer.SzzProducerInterceptorsTest"); //指定分区器（默认） properties.put(ProducerConfig.PARTITIONER_CLASS_CONFIG,"o.a.k.clients.producer.internals.DefaultPartitioner"); //构造 KafkaProducer KafkaProducer producer = new KafkaProducer(properties); Properties 是一个map对象，只需要将配置放进propeties。KafkaProducer构造函数通过解析producer.propeties文件里面的属性来构造自己。例如 ：分区器、Key和Value序列化器、拦截器、RecordAccumulator消息累加器 、元信息更新器、启动发送请求的后台线程。
消息是怎么发送的？ 拦截器 拦截器的执行在序列化和分区之前。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a1610b8c30b3e9a7f031d65e4dec5d7e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55fa88148dd3a6d4cb010c5f7cc3f765/" rel="bookmark">
			C&#43;&#43;类与对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、类与对象初识1、什么是面向过程与面向对象，以及它们的优缺点分别是什么面向过程面向对象优缺点 2、类与对象类对象I、面向对象的三大特征面向对象三大特性抽象(一般忽略这个)封装继承多态 II、类的申明与创建类的声名与创建：数据初始化的方式： 二、类中函数指针总结 前言 一、类与对象初识 1、什么是面向过程与面向对象，以及它们的优缺点分别是什么 面向过程 步骤化：是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了。
面向对象 行为化：面向对象是把整个需求按照特点、功能划分，将这些存在共性的部分封装成对象，创建了对象不是为了完成某一个步骤，而是描述某个事物在解决问题的步骤中的行为
优缺点 面向过程：
优点：性能上它是优于面向对象的，因为类在调用的时候需要实例化，开销过大。缺点：不易维护、复用、扩展 面向对象：
优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出__低耦合__的系统，使系统更加灵活、更加易于维护缺点：性能比面向过程低 2、类与对象 类 即类别：类是具有相似属性和行为的一组实例集合
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-RggEuxvD-1660054840939)(类和对象初识.assets/1657191123507.png)]
属性 ----&gt;数据成员： int, float, char,string ,double ，struct ，class
行为 ----&gt;成员函数: 类中的函数
对象 对象，即类的实例：现实世界是由各种各样的事物组成，包括真实的事物和抽象的事物。例如，人、动物、汽车(真实的事物)和程序、直线(抽象的事物)等。每一类事物都有自己特定的属性(如大小、形状、重量等)和行为(如生长、行走、转弯、运算等)，人们通过研究事物的属性和行为而认识事物。在计算机科学中将这些现实世界中的事物称之为对象 对象: 类具体化(实例化)
例子: 女朋友类
属性:姓名 年龄 身份证 三围… 未初始化的变量
行为: 购物，睡觉 ，吃饭
对象:姓名: 小芳 年龄18 身份证:xxx 三围 x,y,z 变量被初始化
I、面向对象的三大特征 面向对象三大特性 抽象(一般忽略这个) 抽象是人类认识问题的最基本手段之一。抽象是指对具体问题(对象)进行概括，抽出一类对象的公共属性和行为并加以描述的过程。类是对象的抽象，对象是类的特例。
封装 封装是把每个对象的数据(属性)和操作(行为)包装在一个类中。一旦定义了对象的属性和行为，则必须决定哪些属性和行为只用于表示内部状态，哪些属性和行为在外部是可见的。 封装保证了模块具有较好的独立性，使得程序维护修改较为容易。
继承 继承是指一个新类可以从现有的类派生而来。新类继承了现有类的特性，包括一些属性和行为，并且可以修改或增加新的属性和行为，使之适合具体的需要。继承为了重用父类代码，同时为实现多态性作准备。
多态 多态性是指类中具有相似功能的同名函数，并根据不同类的对象对同一消息产生的不同行为。
II、类的申明与创建 类的定义由关键字class，其后为用户定义的类名，花括号括起来的部分称为类体(与结构体类似)。结构体就是一个类，但又与类有点不同(默认权限的不同等)权限限定符private：私有属性，数据成员一般定义为private属性;
pubilc： 公有属性，是类的外部接口，成员函数一般定义为public属性;protected：保护属性,类中使用 类的声名与创建： //-----1申明与创建------- //权限限定词没有个数限制 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; class GirlFriend { //类中是没有权限可言 //权限只是针对类外对象来说的 //类中没有权限限定的默认是私有属性 void printData() { cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/55fa88148dd3a6d4cb010c5f7cc3f765/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/436645a2e556eedfefeb3cd2a9cedc69/" rel="bookmark">
			python&#43;nodejs&#43;java校园网络自主报修系统Vue项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当前,许多高校开始从传统的手动登记网络故障模式过渡到利用报修系统来管理网络故障报修模式。目前国内外存在的网络故障报修系统主要有两类,一类是在前台动态读取数据库数据的网络故障报修系统,主要集中在对报修数据的处理上;一类是基于手工填写网络报修单的人工报修系统,申请者提交纸质报修单后,由管理员将报修信息录人系统，生成报修信息。
🍅文末获取联系🍅
这两类系统的研究与实现主要关注的是网络故障的填报及故障信息管理工作,而弱化了系统中工作流的使用、管理与监督工作。用户提交报修信息后,往往无法得知整个故障处理过程的详细情况,也无法提供反馈信息与投诉建议,这说明网络管理工作还不够完善。
通过分析总结出传统的网络故障报修系统的不足之处主要有三点:一.是流程过于简单,缺乏完整的反馈机制;二是操作较冗繁,用户体验度低;三是学生，需要注册,注册信息的真实性无法确认,容易收到虛假报修信息。本文针对以上问题,提出了系统改进方案,并对系统进行方案设计;分析当前校园网络故障运维管理现状,并在此基础上提出改进策略。
本java+python+nodejs+vue+Elementui+mysql系统可以定制,源码开源,运动稳定,采用pycharm/vscode/idea开发,基于web的B/S架构设计完成,前端使用vue.js+Elementui进行前后端分离,前端框架采用了比较流行的渐进式JavaScript框架Vue.js。使用Vue-Router和Vuex实现动态路由和全局状态管理,Ajax实现前后端通信，Element UI组件库使页面快速成型充分保证了系统代码的良好可读性、实用性、易扩展性、通用性、便于后期维护、操作方便以及页面简洁等特点,覆盖知识面大,非常适合作为计算机专业的同学参考资料进行学习.
主要技术支持有python django 和nodejs+express,java ssm springboot,有代码视频讲解参考
从学院的服务管理工作需求出发,针对学院的服务流程和校园网现状，在校园平台的支持基础上，根据当前的实际工作需求设计网络故障报修系统。实现网上实名报修故障故障处理、服务反馈、故障信息分析等功能,以提高报修效率、提升用户满意度,优化工作效率。
系统用户分为网络管理员和报修用户两类。
1。网络管理员权限
响应处理:响应用户的某一条报修记录,此时该报修记录由“登录”转为“处理中”。
完成处理:对已响应的处理标识为完成处理，此时网络管理员需对该条记录填写处理情况信息。
拒绝处理:拒绝某--报修记录,网络管理员需填写拒绝该记录的理由。
回应投诉:当用户在某一条记录中进行投诉,网络管理员需回复该投诉。
查询本人处理故障记录:以列表形式查看自己所有的处理记录。
2.报修用户权限
报修故障:填写报修必须信息,并提交报修系统。评价或者投诉:对网络管理员已完成的记录进行评价或者填写投诉内容。
查询本.人报修记录:以列表方式查看自已的所有报修记录。
3.网络管理员登录后,可对新故障报修进行响应处理,接受处理的故障报修记录状态由“未处理”变为“处理中”,用于告知用户,其报障已响应。当网络管理员处理完故障后，可对该故障进行处理情况登记,此时,故障状态会由“处理中”变为“已处理”。对于部分不在服务范围内的报障,网络管理员可以进行“拒绝处理”,此时可填写拒绝处理的理由以告知用户。
4.当报修记录处于完成状态后,用户可对本次报修服务进行评价,若用户不满意还可以填写投诉内容进行投诉,而此时管理员可对投诉进行回应。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/650cd45ea598071f00ef9a57a4341d91/" rel="bookmark">
			go语言声明数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 package main import "fmt" func main() { //(1)先声明再赋值 //数组必须限制长度 //数组为内存空间里一段连续的空间 var arr [3]int fmt.Println(arr) //[0 0 0] arr[0] = 10 arr[1] = 11 arr[2] = 12 fmt.Println(arr) //(2)声明并赋值 var names1 = [3]string{"cx", "zz", "dev"} fmt.Println(names1) // (3) 省略长度赋值 var names2 = [...]string{"cx", "zz", "dev"} fmt.Println(names2) //(4) 索引赋值 var names3 = [...]string{0: "zz", 2: "cx"} fmt.Println(names3) //go len函数：计算容器数据的长度 fmt.Println(len(v:"hello")) fmt.Println(len(names3)) } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a2098df8a30349abdc1fe2f0d322c30/" rel="bookmark">
			第2章 第1节-基于搜索的路径规划-BFS 贪心
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第2.1章图搜索基础 1. Configuration Space 配置空间： **机器人配置：**机器人点位置的描述
机器人自由度（Robot degree of freedom， DOF）：最小的坐标个数用于描述机器人位置
机器人配置空间：包含所以机器人配置的n-维空间，记C-space
C-space中任意机器人位置都是一个点
2.配置空间中的障碍物 机器人形状各异，在工作空间中做规划-不方便所以在配置空间中做规划–把机器人当做质点，没有形状；把复杂形状的障碍物按机器人尺寸膨胀[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-uWMaRkB3-1660050100974)(C:\Users\Administrator.DESKTOP-B3VBL7L\AppData\Roaming\Typora\typora-user-images\image-20220712131931812.png)][外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-gV66PeoM-1660050100975)(C:\Users\Administrator.DESKTOP-B3VBL7L\AppData\Roaming\Typora\typora-user-images\image-20220712132244762.png)] C-space=(C-obstacle)U(C-free)
路径搜索：在C-free中找q_start到q_goal
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-tXk5NjLT-1660050100975)(C:\Users\Administrator.DESKTOP-B3VBL7L\AppData\Roaming\Typora\typora-user-images\image-20220712132539329.png)]
3.基于搜索的方法（Search-based Method） 要先构造搜索图
基于搜索的基于采样的[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Ao8jSxaU-1660050100975)(C:\Users\Administrator.DESKTOP-B3VBL7L\AppData\Roaming\Typora\typora-user-images\image-20220714210329877.png)][外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-K9KvdALh-1660050100976)(C:\Users\Administrator.DESKTOP-B3VBL7L\AppData\Roaming\Typora\typora-user-images\image-20220714210356892.png)] 图搜索–可以生成一个搜索树
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-rlpS8HxN-1660050100976)(C:\Users\Administrator.DESKTOP-B3VBL7L\AppData\Roaming\Typora\typora-user-images\image-20220714210446097.png)]
图搜素的流程如下,其中包含一个主循环：remove-expansion-push
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-ZpQjCmUc-1660050100976)(C:\Users\Administrator.DESKTOP-B3VBL7L\AppData\Roaming\Typora\typora-user-images\image-20220714210553019.png)]
1.基本搜索算法：广度优先搜索BFS（可以找到最优的） 深度优先搜索DFS BFS：队列，先进先出
DFS：堆，先进后出 （每一个分枝尽可能找到底
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-i73yjmW9-1660050100976)(C:\Users\Administrator.DESKTOP-B3VBL7L\AppData\Roaming\Typora\typora-user-images\image-20220714211540099.png)][外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-2wskEVRF-1660050100977)(C:\Users\Administrator.DESKTOP-B3VBL7L\AppData\Roaming\Typora\typora-user-images\image-20220714211548491.png)][外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-RJXgZuJO-1660050100977)(C:\Users\Administrator.DESKTOP-B3VBL7L\AppData\Roaming\Typora\typora-user-images\image-20220714212346173.png)][外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-IJCUHht2-1660050100977)(C:\Users\Administrator.DESKTOP-B3VBL7L\AppData\Roaming\Typora\typora-user-images\image-20220714211605466.png)][外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-cttnDcpO-1660050100977)(C:\Users\Administrator.DESKTOP-B3VBL7L\AppData\Roaming\Typora\typora-user-images\image-20220714212418375.png)][外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-wvdGOrwr-1660050100979)(C:\Users\Administrator.DESKTOP-B3VBL7L\AppData\Roaming\Typora\typora-user-images\image-20220714211811787.png)]上面这个，每次把一层节点放进去，每次队头出队，再把出队的儿子加进去，再队头。所以队上面这个，每次都把一层的节点都放进去，每次取头出来，再看头有没有儿子，有儿子就把儿子的一层放进去，再取头。所以堆可以看一下视频25:24部分的DFS搜索之A*可以看一下视频20:29部分的DFS搜索之A*对于对比视频27分钟：一层层往外搜索，得到的路径是最短的对于对比视频27分钟：一条路走到黑，找的路不是最短的 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-5wUns24h-1660050100979)(C:\Users\Administrator.DESKTOP-B3VBL7L\AppData\Roaming\Typora\typora-user-images\image-20220714213108834.png)]
所以后面路径搜索的基础是BFS，不是DFS
2.启发式（heuristic）搜索算法（即：贪心算法） 即猜测到终点的距离，指引我们的扩展方向，因为要算很多邻居节点的距离，所以距离计算方法一定要简单
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-DIOAN3hu-1660050100980)(C:\Users\Administrator.DESKTOP-B3VBL7L\AppData\Roaming\Typora\typora-user-images\image-20220714213432467.png)]
BFS与贪心比较，贪心可以花更少的时间找到最短路径，但是对于有些障碍物情况下贪心算法虽然快，但是轨迹不是最短的，陷入了局部最优，因为贪心算法忽略了障碍物的影响
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-1jvAf3Hj-1660050100980)(C:\Users\Administrator.DESKTOP-B3VBL7L\AppData\Roaming\Typora\typora-user-images\image-20220714213557081.png)]
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-95GE95BI-1660050100981)(C:\Users\Administrator.DESKTOP-B3VBL7L\AppData\Roaming\Typora\typora-user-images\image-20220714213702188.png)]
BFS：成功的前提：图上的每一条边权重最小，不适用与带全脂的图
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e44c5c8db80e0ba9d8110d8a131f3e6c/" rel="bookmark">
			分享 6 个 Vue3 开发必备的 VSCode 插件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天分享 6 个 Vue3 开发必备的 VSCode 插件，可以直接用过 VSCode 的插件中心直接安装使用。
如果有觉得有帮助，还请点赞👍支持一下~
1. Volar 🔥 下载数 153 万+
相信使用 VSCode 开发 Vue2 的同学一定对 Vetur 插件不会陌生，作为 Vue2 配套的 VSCode 插件，它的主要作用是对 Vue 单文件组件提供高亮、语法支持以及语法检测。
而随着 Vue3 正式版发布，Vue 团队官方推荐 Volar 插件来代替 Vetur 插件，不仅支持 Vue3 语言高亮、语法检测，还支持 TypeScript 和基于 vue-tsc 的类型检查功能。
使用时需要注意：
首先要禁用 Vetur 插件，避免冲突；推荐使用 css/less/scss 作为 &lt;style&gt;的语言，因为这些基于 vscode-css-language 服务提供了可靠的语言支持；如果使用 postcss/stylus/sass 的话，需要安装额外的语法高亮扩展。postcss 使用 language-postcss，stylus 使用 language-stylus 拓展，sass 使用 Sass 拓展；Volar 不包含 ESLint 和 Prettier，而官方的 ESLint 和 Prettier 扩展支持 Vue，所以需要自行安装。 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e44c5c8db80e0ba9d8110d8a131f3e6c/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/243/">«</a>
	<span class="pagination__item pagination__item--current">244/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/245/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>