<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab29d89893bb8fa7456f34e05a916e41/" rel="bookmark">
			Informer：改进Transformer的长序列时序预测模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Informer：改进Transformer的长序列时序预测模型
Submitted on 14 Dec 2020 (v1), last revised 28 Mar 2021 (this version, v3)
关注人工智能学术前沿 回复 ：ts21
5秒免费获取论文pdf文档，及项目源码
摘要
许多现实世界的应用需要长序列时间序列的预测，例如电力消耗规划预测。长序列时间序列预测(LSTF)要求模型具有较高的预测能力，即能够准确地捕捉输出与输入之间的长期依赖关系。近年来的研究表明，Transformer具有提高预测能力的潜力。然而，Transformer存在几个严重的问题，使其不能直接适用于LSTF，包括二次时间复杂度、高内存使用量和编码器-解码器体系结构固有的局限性。为了解决这些问题，我们为LSTF设计了一种高效的基于Transformer的模型，名为Informer，该模型具有三个显著特征:
(1)基于概率稀疏的自注意机制，在时间复杂度和内存使用方面实现了O(L log L)，在序列依赖对齐方面具有相当的性能。
(2)自我注意提取通过将级联层输入减半来突出主导注意，并有效地处理极长的输入序列。
(3)生成式解码器虽然概念简单，但对长时间序列序列进行一次正向操作而不是一步一步地进行预测，大大提高了长序列预测的推理速度。
在4个大规模数据集上的大量实验表明，Informer方法显著优于现有方法，为LSTF问题提供了一种新的解决方案。
1.介绍
时间序列预测是许多领域的关键因素，如传感器网络监测(Papadimitriou和Yu 2006)、能源和智能电网管理、经济和金融(Zhu和Shasha 2002)和疾病传播分析(Matsubara et al. 2014)。在这些场景中，我们可以利用大量关于过去行为的时间序列数据来做出长期预测，即长序列时间序列预测(LSTF)。
关键问题
目前现有的模型对更长的时间序列预测时，预测效果会随着序列长度增加而不断降低。
以LSTM为例进行实验数据分析
作为实证实例，图(1)给出了在真实数据集上的预测结果，其中LSTM网络对某变电站逐时温度从短期(12 points，0.5天)到长期(480points，20天)的预测结果。当预测长度大于48点(图(1b)中的实心星形)时，整体性能差距较大，MSE上升到性能不理想，推理速度急剧下降，LSTM模型开始失效。
作者的解决思路
最近的研究表明，与RNN模型相比，Transformer模型在捕获远程依赖关系方面表现出了优越的性能。自注意机制可以将网络信号的最大传播路径长度减小到理论最短的O(1)，避免了递归结构，变压器在求解LSTF问题上表现出很大的潜力。
Transformer在NLP任务上产生了不错的结果(Brown et al. 2020)，但是，由于Transformer的计算特性，需要大量的内存资源和计算资源，数十个GPU的训练和昂贵的部署成本使这些模型在LSTF问题上无法负担。
作者试图解决这个问题:我们能否改进Transformer模型，使其在计算、内存和架构方面更高效，同时保持更高的预测能力。
Transformer (Vaswani et al. 2017)在解决LSTF问题时有三个显著的局限性：
自我注意的二次计算。自注意机制的原子操作，即规范点积，使每层的时间复杂度和内存使用量为O(L^2)。
对长输入进行堆叠时的内存瓶颈。. j编码器/解码器层的堆栈使总内存使用量为O(J，L^2)，这限制了接收长序列输入时模型的可伸缩性。
预测长期产出的速度骤降。动态Transformer的动态译码使得逐步推理与基于RNN的模型一样慢(图(1b))
作者首先总结了其他学者解决这三个局限性的研究工作，然后介绍了自己的研究是如何解决上述三个局限性的。
为此目的，我们的工作明确地探讨了这三个问题。我们研究了自我注意机制中的稀疏性，改进了网络组件，并进行了广泛的实验。本文的贡献总结如下
1.我们提出了Informer来成功地提高LSTF问题的预测能力，这验证了类Transformer模型在捕获长序列时间序列输出和输入之间的个体长期依赖性方面的潜在价值。
2.我们提出了概率自我注意机制来有效地替代典型的自我注意。它实现了O(Llog L)时间复杂度和O(Llog L)内存使用在依赖对齐上。
3.在J-堆叠层中，我们提出了对优先注意分数占主导地位的自注意提取操作，将空间复杂度大幅度降低到O[（2-€) * L*log L]，这有助于接收长序列输入。
4.我们提出了生成式译码器，该译码器只需要向前一步就可以获得长序列输出，同时避免了推理阶段累积误差的扩散。
图2: Informer 模型概述。左:编码器接收大量长序列输入(绿色序列)。我们用所提出的概率自我注意代替典型自我注意。蓝色梯形是自我注意力提取操作，以提取支配注意力，大幅减少网络规模。层堆叠副本增加鲁棒性。右图:解码器接收长序列输入，将目标元素填充为零，测量特征图的加权注意力组成，并以生成式风格立即预测输出元素(橙色系列)。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab29d89893bb8fa7456f34e05a916e41/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47828489a7419cc2116e9e39c1cbd3fd/" rel="bookmark">
			Unity之UGUI详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		UGUI 文章目录 UGUI六大基础组件概述Canvas对象上依附的：CanvasCanvas ScalerGraphic RaycasterRectTransform EventSystem对象上依附的：EventSystemStandalone Input Module Canvas画布组件Screen Space overlayScreen Space CameraWorld Space CanvasScaler画布缩放控制器组件学前准备：Constant Pixel Size恒定像素模式Scale With Screen Size缩放模式ExpandShrinkMatch width or Height Constant Phsical Size恒定物理模式恒定物理模式和恒定像素模式的区别： World3D模式 GraphicRaycaster图形射线投射器EventSystem和Standalone Input ModuleEventSystemStandalone Input Module RectTransform**Pivot和AnchorsUI位置设置当Anchors为锚点时：当Anchors为锚框时：当Anchors为锚线时： 轴心点锚点快捷设置 UGUI三大基础控件之Image参数：图片类型 UGUI三大基础控件之Text参数： UGUI三大基础控件之RawImage参数： UGUI组合控件之Button参数：UI事件： UGUI组合控件之Toggle层级：参数：UI事件：ToggleGroup参数： UGUI组合控件之InputField层级：参数：UI事件： UGUI组合控件之Slider层级：参数：UI事件： UGUI组合控件之ScrollBar层级：参数：UI事件： UGUI组合控件之ScrollView层级：参数：UI事件： UGUI组合控件之DropDown层级：参数：UI事件： UGUI图集制作旧版图集制作：新版图集制作： UGUI进阶之UGUI事件监听接口常用的事件接口不常用事件接口 UGUI进阶之EventTriggerUGUI进阶之屏幕坐标转UI相对坐标UGUI进阶之Mask遮罩参数： UGUI进阶之模型和粒子显示在UI之前UGUI进阶之异形按钮UGUI进阶之自动布局组件自动布局属性手动设置布局属性：自动布局组件水平/垂直布局组件参数 网格布局组件参数 内容适配器参数 宽高比适配器参数 UGUI进阶之CanvasGroup参数 六大基础组件概述 Canvas对象上依附的： Canvas 画布组件，主要用于渲染UI控件。
Canvas Scaler 画布分辨率自适应组件，主要用于分辨率自适应。
Graphic Raycaster 射线事件交互组件，主要用于控制射线响应相关。
RectTransform UI对象位置锚点控制组件，主要用于控制UI对象的位置和对齐方式。
EventSystem对象上依附的： EventSystem UI事件响应的基础
Standalone Input Module 玩家输入事件响应系统和独立输入模块组件，主要用于监听玩家操作。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47828489a7419cc2116e9e39c1cbd3fd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9037dafc2e896d922f4c18ac3d3470d/" rel="bookmark">
			字节二面：如何用策略模式，优化你代码里的的if-else？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有情怀，有干货，微信搜索【三太子敖丙】关注这个有一点点东西的程序员。
本文 GitHub https://github.com/JavaFamily 已收录，有一线大厂面试完整考点、资料以及我的系列文章。
最近有一个学妹在跟我沟通如何有效的去避免代码中一长串的if else判断或者switch条件判断？针对更多的回答就是合理的去使用设计来规避这个问题。
在设计模式中，可以使用工厂模式或者策略模式来处理这类问题，之前已经分享了工厂模式，感兴趣的同学可以去复习一下。
设计模式系列往期文章：
单例模式工厂模式流程引擎建造者模式原型模式责任链模式观察者模式 那么工厂模式和策略模式有什么区别呢？
工厂模式是属于创建型设计模式，主要用来针对不同类型创建不同的对象，达到解偶类对象。策略模式是属于行为型设计模式，主要是针对不同的策略做出对应行为，达到行为解偶 本次就来具体聊聊策略模式它是如何做到行为解耦
大纲 定义 什么是策略模式？它的原理实现是怎么样的？
定义一系列算法，封装每个算法，并使他们可以互换，不同的策略可以让算法独立于使用它们的客户而变化。 以上定义来自设计模式之美
感觉有点抽象？那就来看一张结构图吧
Strategy（抽象策略）：抽象策略类，并且定义策略执行入口ConcreteStrategy（具体策略）：实现抽象策略，实现algorithm方法Context（环境）：运行特定的策略类。 这么看结构其实还是不复杂的，而且跟状态模式类似。
那么这个代码怎么实现？
举个例子，汽车大家肯定都不陌生，愿大家早日完成汽车梦，汽车的不同档(concreteStrategy）就好比不同的策略，驾驶者选择几档则汽车按几档的速度前进，整个选择权在驾驶者（context）手中。
public interface GearStrategy { // 定义策略执行方法 void algorithm(String param); } 首先还是先定义抽象策略
这里是用接口的形式，还有一种方式可以用抽象方法abstract来写也是一样的。具体就看大家自己选择了。
public abstract class GearStrategyAbstract { // 定义策略执行方法 abstract void algorithm(String param); } public class GearStrategyOne implements GearStrategy { @Override public void algorithm(String param) { System.out.println("当前档位" + param); } } 其次定义具体档位策略，实现algorithm方法。
public class Context { // 缓存所有的策略，当前是无状态的，可以共享策略类对象 private static final Map&lt;String, GearStrategy&gt; strategies = new HashMap&lt;&gt;(); // 第一种写法 static { strategies.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e9037dafc2e896d922f4c18ac3d3470d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d81d43146bea398a1662231699bf9ed5/" rel="bookmark">
			EEPROM、FLASH等非易失存储器内容首次初始化的实现方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、背景 在实际的产品开发过程中，经常需要将一些配置信息保存在EEPROM或者Flash中，这里包括片累的和片外的，在产品量产后，基本不会再单独处理非易失存储器里面的内容，这就要求产品的烧录固件拥有只有在产品第一次上电时初始化存储器内容的功能，而在以后的上电过程中，不会再将存储器的值进行初始化，避免一些配置数据的丢失。
二、需要避免的问题 在没有少路过程序的产品中，EEPROM等是没有被写过的，存储区中存放的数据一般都为0，也会存在全F的情况，当然也会存在程序升级的情况，EEPROM中存放的值可能为任意值，这就需要这到一种方法来判断，EEPROM中存放的数据是不是当前的程序所需要的。
三、实现方法 在存储器的寻址范围开始的N个字节存放固定的内容，以4个字节为例，如下图红色区域所示。 产品上电时首先读取前4个字节的内容，然后进行判断，如果内容和预期一致，就说明存储器中的数据是正确的数据，如果不一致，就说明存储器中的数据是异常数据。当检测到异常数据后，程序必须将前4个字节初始化为{0xFF,0x00,0x55,0xAA}（或者其它值）,然后将产品配置数据存放在第5字节之后。
第二次及以后上电时，根据前N个字节判断数据正确，存储器中的配置数据就永远不会被异常初始化，导致配置数据丢失。
设置0xFF的目的是最快检测出存储器全0的情况，设置0x00的目的是检查存储器全F的情况，设置0x55和0xAA的目的是检测程序因版本升级需要再次初始化存储器的情况，以及数据读取错误等一些不可能发生的极端情况。
当然，也可以将校验字放在寻址空间末尾或者其他任意地方。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8488e6728003cabdf63463ed8e8cd47c/" rel="bookmark">
			基于android的电子书阅读器app
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于Android平台的电子书阅读器的设计与实现主要通过Eclipse开发工具, Java语言与Sqlite数据库来完成的。本阅读器实现了本地阅读，手动翻页，书签的添加、查看、删除，自动翻页，书架，快速定位，及在线下载。本文主要介绍程序的设计思路、逻辑、架构、及数据库的设计与整体的实现流程。最后进一步阐述Android电子阅读器对文化发展的影响及其市场价值。
本阅读器围绕日常生活与学习展开，用户可以通过本阅读器进行文本阅读。主要目标是，帮助用户通过手机或便携式设备管理图书及智能保存用户阅读进度，模拟真实手动翻页，使用户得到更加完美的用户体验。此外，还可以为用户建立一个属于自己的书架，帮助用户最快的找打自己喜欢的书。用户也可以通过web服务器来在线下载自己喜爱的书，尽可能的满足用户的阅读需求。
电子书阅读器基本功能需求:
本地进行查找、阅读
阅读实现翻页功能
记录最后一次阅读位置
通过设置书签，进行跳跃阅读
可以进行在线图书下载
设置字体大小颜色及主题背景
自动翻页功能
阅读位置定位
目 录
1 背景与意义 1
1.1 Android操作系统介绍 1
1.1.1 Android的认识 1
1.1.2 Android的发展 1
1.2 电子书阅读器介绍 1
1.3 Android电子书阅读器的意义 2
2 相关知识与技术 3
2.1 Android的应用组件 3
2.2 Android的拓展 4
2.3 系统开发工具 4
2.3.1 开发平台：Eclipse IDE for Java Developers 4
2.3.2 开发所用到的SDK：Android SDK 2.2版本 4
2.3.3 开发所用到的数据库：SQLite 4
2.3.4 网络环境：Tomcat 服务器： 5
3 系统分析 6
3.1 用户群体： 6
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8488e6728003cabdf63463ed8e8cd47c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f08c74274a3f7d21bf4941a87ce53aee/" rel="bookmark">
			C&#43;&#43;怎么判断一个数是水仙花数？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include &lt;iostream&gt; using namespace std; int main() { int a; cout&lt;&lt;"请输入a"&lt;&lt;endl; cin&gt;&gt;a; int b=a/100;//算百位 int c=(a/10)%10;//算十位 int d=a%10;//算个位 if(b*b*b+c*c*c+d*d*d==a) { cout&lt;&lt;"该数是水仙花数！"&lt;&lt;endl; } else { cout&lt;&lt;"该数不是水仙花数！"&lt;&lt;endl; } system("pause"); return 0; } 运算符总结： %:取余
/:除法
运算例子： 假如我们输入的数字是153，那么int b=a/100就是b=153/100=1.53=1;int c=(a/10)%10就是c=(153/10)%10=15%10=5;int d=a%10就是d=153%10=3。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ce89c42f1795986bee982875642290c/" rel="bookmark">
			Verilog 学习笔记（7）——有限状态机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本节介绍有限状态机部分。
文章目录 7.1 Verilog 状态机状态机类型Moore 型状态机Mealy 型状态机 状态机的设计技巧FSM 的编码FSM 初始化状态FSM 状态编码定义FSM 输出FSM 的默认状态Full Case 与 Parallel Case 综合属性 状态机设计流程自动售卖机状态机设计：3 段式（推荐）状态机修改：2 段式状态机修改：1 段式（慎用）状态机修改：Moore 型 7.1 Verilog 状态机 有限状态机（Finite-State Machine，FSM），简称状态机，是时序电路设计中经常采用的方式，尤其适用于设计数字系统的控制模块，在一些需要控制高速器件的场合，用状态机进行设计是解决问题的一种很好的实现方案，具有速度快，结构简单，可靠性高等优点。用Verilog HDL的case，if-else等语句能很好的描述基于状态机的设计。
状态机类型 状态机可以认为是组合逻辑和寄存器逻辑的特殊组合，它一般包括两个部分：组合逻辑部分和寄存器逻辑部分。寄存器用于存储状态，组合电路用于状态译码和产生输出信号。状态机的下一个状态及输出，不仅与输入信号有关，而且还与寄存器当前所处的状态有关。
根据输出信号产生方法的不同，状态机可以分为两类：Moore 状态机和 Mealy 状态机。
Moore 型状态机 Moore 型状态机的输出只与当前状态有关，与当前输入无关。
输出会在一个完整的时钟周期内保持稳定，即使此时输入信号有变化，输出也不会变化。输入对输出的影响要到下一个时钟周期才能反映出来。这也是 Moore 型状态机的一个重要特点：输入与输出是隔离开来的。
Mealy 型状态机 Mealy 型状态机的输出，不仅与当前状态有关，还取决于当前的输入信号。
Mealy 型状态机的输出是在输入信号变化以后立刻发生变化，且输入变化可能出现在任何状态的时钟周期内。因此，同种逻辑下，Mealy 型状态机输出对输入的响应会比 Moore 型状态机早一个时钟周期。
状态机的设计技巧 FSM 的编码 Binary（二进制编码）、gray-code（格雷码）编码使用最少的触发器，较多的组合逻辑，而 one-hot（独热码）编码反之。one-hot 编码的最大优势在于状态比较时仅仅需要比较一个位，一定程度上简化了比较逻辑，减少了毛刺产生的概率。由于 CPLD 更多地提供组合逻辑资源，而 FPGA 更多地提供触发器资源，所以 CPLD 多使用 gray-code，而 FPGA 多使用 one-hot 编码。另一方面，对于小型设计使用 gray-code 和 binary 编码更有效，而大型状态机使用 one-hot 更高效。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ce89c42f1795986bee982875642290c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f3a6e955d09a32edfccd7d15cbfc858/" rel="bookmark">
			HTML5制作通栏有点设计,网页设计的尺寸和网页中广告设计的规则
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网页设计的尺寸和网页中广告设计的规则
互联网 发布时间：2008-10-17 19:59:39 作者：佚名 我要评论
1、800*600下，网页宽度保持在778以内，就不会出现水平滚动条，高度则视版面和内容决定。
2、1024*768下，网页宽度保持在1002以内，如果满框显示的话,高度是612-615之间.就不会出现水平滚动条和垂直滚动条。
3、在ps里面做网页可以在800*600状态下显示全屏，页面的下
1、800*600下，网页宽度保持在778以内，就不会出现水平滚动条，高度则视版面和内容决定。
2、1024*768下，网页宽度保持在1002以内，如果满框显示的话,高度是612-615之间.就不会出现水平滚动条和垂直滚动条。
3、在ps里面做网页可以在800*600状态下显示全屏，页面的下方又不会出现滑动条，尺寸为740*560左右
4、在PS里做的图到了网上就不一样了，颜色等等方面，因为ＷＥＢ上面只用到２５６ＷＥＢ安全色，而ＰＳ中的ＲＧＢ或者ＣＭＹＫ以及ＬＡＢ或者ＨＳＢ的色域很宽颜色范围很广，所以自然会有失色的现象.
页面标准按800*600分辨率制作，实际尺寸为778*434px
页面长度原则上不超过3屏，宽度不超过1屏
每个标准页面为A4幅面大小，即8.5X11英寸
全尺寸banner为468*60px，半尺寸banner为234*60px，小banner为88*31px
另外120*90，120*60也是小图标的标准尺寸
每个非首页静态页面含图片字节不超过60K，全尺寸banner不超过14K
标准网页广告尺寸规格
一、120*120，这种广告规格适用于产品或新闻照片展示。
二、120*60，这种广告规格主要用于做LOGO使用。
三、120*90，主要应用于产品演示或大型LOGO。
四、125*125，这种规格适于表现照片效果的图像广告。
五、234*60，这种规格适用于框架或左右形式主页的广告链接。
六、392*72，主要用于有较多图片展示的广告条，用于页眉或页脚。
七、468*60，应用最为广泛的广告条尺寸，用于页眉或页脚。
八、88*31，主要用于网页链接，或网站小型LOGO。
广告形式 像素大小 最大尺寸 备注
BUTTON 120*60(必须用gif) 7K
215*50(必须用gif) 7K
通栏 760*100 25K 静态图片或减少运动效果
430*50 15K
超级通栏 760*100 to 760*200 共40K 静态图片或减少运动效果
巨幅广告 336*280 35K
585*120
竖边广告 130*300 25K
全屏广告 800*600 40K 必须为静态图片，FLASH格式
图文混排 各频道不同 15K
弹出窗口 400*300(尽量用gif) 40K
BANNER 468*60(尽量用gif) 18K
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f3a6e955d09a32edfccd7d15cbfc858/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51d4c534646f21fec0ece6dfbc0e759d/" rel="bookmark">
			html音频文件上传,用html5“标签传输音频
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我正在尝试使用&lt; audio&gt;在讲座系列中在Dreamhost托管的网站上传输音频.标记在
html5中,但没有太大的成功.实际的代码是
我还有一个.htaccess文件,包含apache的正确mime-types.
AddType audio / ogg .ogg
AddType audio / mpeg .mp3
ogg文件大约是8兆,mp3文件大约是13兆.每个文件都是从Audacity导出的.
当我在Windows 7机器上本地提供服务时,一切都在FF,Chrome和Safari中运行良好(运行win32版本的apache 2.2.14和PHP 5.3.1).
在Dreamhost上,事情并没有那么顺利. (他们运行apache 2.2.15和PHP 5.2.14.)
5秒后FF停止播放音频文件. Chrome播放音频文件,但音频会频繁跳过. Safari正确播放音频,但点击播放按钮和实际开始播放和播放的音频之间的延迟大约是三分钟.
如果不使用&lt; audio&gt;而不是我使用Silverlight播放器播放来自Dreamhost的mp3文件,它们可以正常播放和播放.
关于我需要做什么来获得&lt; audio&gt;的任何建议标签工作正常.据我所知,html5音频是客户端技术,Silverlight也是如此.所以,从理论上讲,Dreamhost应该对&lt; audio&gt;的方式没有影响.标签执行.
无论如何,任何人都对什么是错误有任何想法.
谢谢.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bcd7d57e19b6af537ba375a052949e70/" rel="bookmark">
			声纹识别中pooling总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、Statistics Pooling http://danielpovey.com/files/2017_interspeech_embeddings.pdf
The statistics pooling layer calculates the mean vector µ as well as the second-order statistics as the standard deviation vector σ over frame-level features ht (t = 1, · · · , T ).
where ⊙ represents the Hadamard product.
2、Attentive Statistics Pooling https://arxiv.org/pdf/1803.10963.pdf
calculates a scalar score et for each frame-level feature.
where f(·) is a non-linear activation function, such as a tanh or ReLU function.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bcd7d57e19b6af537ba375a052949e70/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6349b42e3fd67f7cf1222c38e424c525/" rel="bookmark">
			Mybatis新手教程之简单入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这篇文章主要给大家介绍了关于Mybatis新手教程之简单入门的相关资料，文中通过示例代码介绍的非常详细，对大家的学习或者工作具有一定的参考学习价值，需要的朋友们下面来一起学习学习吧
1、Mybatis概述　MyBatis 是支持普通 SQL 查询（相比较于Hibernate的封装，Mybatis是半自动化的JDBC封装，一个特点就是Mybatis执行的SQL查询语句需要自己在配置文件中写），存储过程和高级映射的优秀持久层框架。MyBatis 消除了几乎所有的 JDBC 代码和参数的手工设置以及对结果集的检索。MyBatis 可以使用简单的XML 或注解用于配置和原始映射，将接口和 Java 的 POJO（Plain Old Java Objects，普通的Java 对象）映射成数据库中的记录。
2、Mybatis原理解析
下面以Mybatis简单的执行流程
1、加载mybatis全局配置文件（数据源、mapper映射文件等），解析配置文件，MyBatis基于XML配置文件生成Configuration，和一个个MappedStatement（包括了参数映射配置、动态SQL语句、结果映射配置），其对应着&lt;select | update | delete | insert&gt;标签项。
2、SqlSessionFactoryBuilder通过Configuration对象生成SqlSessionFactory，用来开启SqlSession。
3、SqlSession对象完成和数据库的交互：
a、用户程序调用mybatis接口层api（即Mapper接口中的方法）
b、SqlSession通过调用api的Statement ID找到对应的MappedStatement对象
c、通过Executor（负责动态SQL的生成和查询缓存的维护）将MappedStatement对象进行解析，sql参数转化、动态sql拼接，生成jdbc Statement对象
d、JDBC执行sql。
e、借助MappedStatement中的结果映射关系，将返回结果转化成HashMap、JavaBean等存储结构并返回。
下面是Mybatis的框架原理图
3、Mybatis简单实例
（1）导入相关jar包以及Mybatis运行环境核心jar包和连接数据库的包
（2）创建一张简单的数据表
（3）创建Java对象（PO类型）
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6349b42e3fd67f7cf1222c38e424c525/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06c40bee373834157a92314c8ebb6d7c/" rel="bookmark">
			html改变文字方向,css文字方向怎么设置？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一般地，正常网页文本方向都是从上到下，从左到右。实际上，有多种设置文本方向的属性，置文本方向的CSS样式有direction、unicode-bidi等方法。本文将详细介绍网页文本方向的设置方法。
css设置文字方向的方法如下：
1、使用direction属性设置文字方向
direction是设置文本方向的CSS样式
值: ltr | rtl | inherit
初始值: ltr
应用于: 所有元素
继承性: 有
[注意]想让direction样式在inline元素上起作用，需要unicode-bidi样式的相关设置
[注意]设置direction样式时，HTML元素的全局属性dir无效
示例：
div.one
{
direction: rtl
}
div.two
{
direction: ltr
}
12 2 3 4 12 2 3 4 效果图：
2、使用unicode-bidi属性设置文字方向
unicode-bidi是一种更健壮的处理文本方向的方式
值: normal | embed | bidi-override | isolate | isolate-override | plaintext | inherit
初始值: normal
应用于: 所有元素
继承性: 无
[注意]unicode-bidi属性应用于flex弹性盒模型上有问题，除非伸缩容器只包含一个匿名伸缩项目时有效，其余情况都无效
[注意]isolate、isolate-override、plaintext是实验属性值，几乎没有浏览器支持//display:inline-block/block
normal/embed: 456 23 1
bidi-override: 654 32 1
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/06c40bee373834157a92314c8ebb6d7c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da9a6bdeaa6058a33af5180c271d6d13/" rel="bookmark">
			macOS Monterey 怎么升级？macOS 12升级教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天凌晨 1 点，苹果举行了 WWDC 21 开发者大会，发布了新的 Mac 操作系统，命名为 Monterey。那么新的macOS Monterey 怎么升级呢？Macw为您带来macOS 12升级教程！
因macOS 12是刚发布的系统，用户在尝鲜升级macOS 12新系统前，一定要备份好自己电脑上的数据和资料！ macOS Monterey兼容电脑 iMac‌ - 2015 年末及之后iMac‌ Pro - 2017 及更高版本MacBook Air‌ - 2015 年初及之后MacBook Pro - 2015 年初及之后Mac Pro - 2013 年末及更新机型Mac mini - 2014 年末及更新机型MacBook - 2016 年初及之后 macOS 12升级教程 先下载开发者工具！
下载完成后打开，双击.pkg安装包运行即可检测到最新的macOS 12测试版系统升级信息。
自动跳转到软件更新，点击下载，接下来就是等待系统自动更新！
或者
直接点击下方链接可以下载完整的Macos 12系统（小编亲测速度可达30M+）
macOS 12 Monterey高速下载通道！
下载完成后双击PKG文件根据提示进行安装
安装完成后会在应用程序找到Install macOS 12 Beta.app,双击根据提示进行操作即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f18d5069ab0ae6aea4e717c035808ea3/" rel="bookmark">
			Flutter实现自己的表格组件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		表格组件最终效果如下：
整个表格的数据为一个List&lt;List&lt;TableDetail&gt;&gt; tableList
每一行的数据为一个List&lt;TableDetail&gt; list
表格的数据实体类:
class TableDetail { String title, content; TableDetail(String title, String content) { this.title = title; this.content = content; } } 生成表格数据：
List&lt;TableDetail&gt; list1 = [TableDetail('姓名', '张三')]; List&lt;TableDetail&gt; list2 = [TableDetail('性别', '男'), TableDetail('年龄', '30')]; List&lt;TableDetail&gt; list3 = [TableDetail('企业名称', '艾里巴巴')]; List&lt;TableDetail&gt; list4 = [TableDetail('部门', '技术部'), TableDetail('岗位/工种', '程序猿')]; List&lt;TableDetail&gt; list5 = [TableDetail('接触的职业病危害因素', '职业病危害因素1、职业病危害因素2、职业病危害因素3、职业病危害因素4、职业病危害因素5')]; List&lt;TableDetail&gt; list6 = [TableDetail('鉴定机构', '阿里巴爸爸巴巴巴')]; List&lt;TableDetail&gt; list7 = [TableDetail('鉴定日期', '2021年6月2日'), TableDetail('鉴定结论', 'xxxxxx')]; List&lt;TableDetail&gt; list8 = [TableDetail('报告出具日期', '2021年6月10日'), TableDetail('附件', 'xxxxxx'), TableDetail('附件2', 'xxxxxx2')]; tableList = [list1,list2,list3,list4,list5,list6,list7,list8]; 使用的话就一行代码:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f18d5069ab0ae6aea4e717c035808ea3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf28906fcab2b3f58686b90edec9165f/" rel="bookmark">
			手机抓包工具--stream的安装与应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		stream是一款免费轻量级移动端ios抓包调试工具，配置方便无需设置代理，集成了HTTP抓包、构建请求、Hosts 设置、常用工具、数据导出等功能。
stream可谓是iphone抓包神器，android的也可以,就是要做核心破解,麻烦一点。
安装与应用
https://blog.csdn.net/qq_36502272/article/details/117341718
https://blog.csdn.net/heqiang2015/article/details/84023327
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50be6b2c0cbd6f57c0cd5ac851b3c103/" rel="bookmark">
			【QT】VS打开QT项目运行不成功 error MSB6006 “cmd.exe”已退出,代码为 2。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我的开发环境：
VS2017 + qt-vsaddin-msvc2017-2.7.1 + q5.14.2
我用VS2017打开QT项目，然后运行，报错如下：
error MSB6006 “cmd.exe”已退出,代码为 2。
别人的解决方案：
右键项目--点击“convert projec to Qt Add-in project”
但是我右键项目之后，并没有这个选项，如图：
我的解决方案：
后来发现，安装vs的时候没有选择安装扩展项，点击电脑开始选项，找到下图这个Visual Studio Installer，点击打开。安装之前，需要先关闭VS。
点击修改
点击“其他工具集”中的“VS扩展开发”，之后点击右下角的安装，VS会自动下载安装扩展协议。
再次打开QT项目，运行，成功。
注意：
我右键项目之后，还是没有出现“convert projec to Qt Add-in project”这个选项，但是已经能运行，解决问题了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76240c180de61e31213a4e6078738fc8/" rel="bookmark">
			博客新推送
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23816783fc057a5863e055dd072cb2f7/" rel="bookmark">
			Flutter 十六进制与字符串的相互转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、字符串转换为十六进制 String str="#Start#"; String res=""; for (int i = 0; i &lt; str.length; i++) res=res+str.codeUnitAt(i).toRadixString(16); print(res); 二、十六进制转换为字符串 List&lt;int&gt; value=[0x23,0x53,0x74,0x61,0x72,0x74,0x23]; String res=""; for (var i = 0; i &lt; value.length; i++) { res+=String.fromCharCode(int.parse(value[i].toRadixString(10))); } print(res); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5de8d3627b2169510195fd9f0e6886f2/" rel="bookmark">
			使用K-means对鸢尾花数据进行分类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、导入数据 import pandas as pd import seaborn as sns import matplotlib.pyplot as plt from sklearn.cluster import KMeans from sklearn.preprocessing import StandardScaler from sklearn.metrics import silhouette_score from sklearn.metrics import calinski_harabasz_score from sklearn.model_selection import GridSearchCV from mpl_toolkits.mplot3d import Axes3D %matplotlib inline plt.rcParams['font.sans-serif'] = ['SimHei'] plt.rcParams['axes.unicode_minus']=False # 读取数据 data = pd.read_csv(r'D:\ws\机器学习\data\customers.csv') data.head() 2、预处理 2.1、异常值处理 plt.figure(figsize=(20,8),dpi=80) p = data.boxplot(return_type= 'dict') x = p['fliers'][0].get_xdata() # 'flies'即为异常值的标签 y = p['fliers'][0].get_ydata() y.sort() # 从小到大排序，该方法直接改变原对象 ''' 用annotate添加注释 其中有些相近的点，注释会出现重叠，难以看清，需要一些技巧来控制 以下参数都是经过调试的，需要具体问题具体调试 ''' for i in range(len(x)): if i&gt;0: plt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5de8d3627b2169510195fd9f0e6886f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb97bd71da8464b7986c2e21cc00d655/" rel="bookmark">
			VS IDE快捷路劲表示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 转载于：疯子Crazy
VS IDE中常用路径 表示 $(SolutionDir) 即解决方案配置文件 xxx.sln所在的目录例如 D:\WorkSpace\CPPWorkSpace\TestDLL\ $(ProjectDir) 表示 xxx.vcxproj所在的目录 例如：D:\WorkSpace\CPPWorkSpace\TestDLL\DLL2\
$(ProjectName) 代表具体的project 名称,例如一个解决方案下，每一个工程都有各自的名称
$(Configuration) 代表Debug或者Release
查看 宏定义 每一项输入 编辑都可以查看所有的已定义宏 在工程中预定义宏如下图 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05586c65cb90f0a51e0db08ff7951e78/" rel="bookmark">
			springMVC获取请求参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		服务器获取请求参数的类型有以下四种：
1、基本类型
2、POJO(没有业务逻辑的简单对象)类型
3、数组类型
4、集合类型
一、基本类型 业务方法的参数名与请求参数的name一致，参数值会自动匹配。
业务方法如下：
@RequestMapping("/testControll9") @ResponseBody /* 告诉springmvc函数要返回的是一个普通数据，而非要跳转的页面名,这里无返回值， 即不做处理,如果不添加该注解，服务器会找不到要返回的页面 */ public void controllTest9(String name, int age) { System.out.println("name:" + name + " age:" + age); } 在浏览器输入以下地址访问该业务函数：
http://localhost:8089/user/testControll9?name=shen&amp;age=19（tips:地址中带有user目录，是因为我在业务模块类头上添加了@RequestMapping("/user")，类头没有添加该mapping的，地址中不需要添加user目录）
此时springmvc会自动将地址中的name和age与业务方法参数中的name和age进行匹配赋值。
最终控制台打印如下：
二、POJO类型 业务方法中的POJO参数的属性名与请求参数的name一致，参数会自动匹配映射。
使用方法如下：
1、首先定义一个POJO类 UserInfo
public class UserInfo { private String name; private int age; public void setName(String name) { this.name = name; } public void setAge(int age) { this.age = age; } public String getName() { return name; } public int getAge() { return age; } @Override public String toString() { return "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05586c65cb90f0a51e0db08ff7951e78/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de8e5c89b6bc4407bb3eee2a7afd6064/" rel="bookmark">
			JVM分为哪几部分？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JDK1.8之前：
JDK1.8之后：
各个区域的作用：
1.2.2.1 程序计数器 字节码解释器通过改变程序计数器来依次读取指令，从⽽实现代码的流程控制，如：顺序执⾏、选择、循环、异常处理。
在多线程的情况下，程序计数器⽤于记录当前线程执⾏的位置，从⽽当线程被切换回来的时候能够知道该线程上次运⾏到哪⼉了
程序计数器是唯一不会出现OutOfMemoryError的内存区域
1.2.2.2 Java虚拟机栈 它的生命周期和线程相同，随着线程的创建而创建，随着线程的死亡而死亡。每次方法调用的数据都是通过栈传递的。
实际上Java虚拟机栈是由一个个栈帧（拥有：局部变量表、操作数栈、动态链接、方法出口信息）组成。
Java栈就好比数据结构中的栈，Java栈中保存的是栈帧，每一次函数调用都会有一个对应的栈帧压入Java栈，调用结束后栈帧就会弹出 1.2.2.3 本地方法栈 和Java虚拟机栈相似。区别：虚拟机栈为虚拟机执⾏ Java ⽅法 （也就是字节码）服务，⽽本地⽅法栈则为虚拟机使⽤到的 Native ⽅法服务。
1.2.2.4 堆 Java虚拟机启动的时候创建。用途： 存放对象实例。
几乎所有的对象实例和数组都在堆上面分配内存。但是JDK1.7之后默认开启逃逸分析 (如果某些⽅法中的对象引⽤没有被
返回或者未被外⾯使⽤（也就是未逃逸出去），那么对象可以直接在栈上分配内存)。
JDK8开始，Hotspot的永久代被彻底移除，取而代之的是元空间。
对象都会⾸先在 Eden 区域分配，在⼀次新⽣代垃圾回收后，如果对象还存活，则会进⼊ s0 或者 s1，并且对象的年龄还会加 1(Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到⼀定程度（默认为 15 岁），就会被晋升到⽼年代中。对象晋升到⽼年代的年龄阈可以通过参数 -XX:MaxTenuringThreshold 来设置
1.2.2.5 方法区 ⽅法区与 Java 堆⼀样，是各个线程共享的内存区域，它⽤于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据
1.2.2.6 运行时常量池 JDK1.7之前运⾏时常量池逻辑包含字符串常量池存放在⽅法区, 此时hotspot虚拟机对⽅法区的实现为永久代.JDK1.7 字符串常量池被从⽅法区拿到了堆中, 这⾥没有提到运⾏时常量池,也就是说字符串常量池被单独拿到堆,运⾏时常量池剩下的东⻄还在⽅法区, 也就是hotspot中的永久代 。JDK1.8 hotspot移除了永久代⽤元空间(Metaspace)取⽽代之, 这时候字符串常量池还在堆, 运⾏时常量池还在⽅法区, 只不过⽅法的实现从永久代变成了元空间(Metaspace) Java常量池中存储的对象的引用，实际上对象还是存储在Java堆上的。
1.2.2.7 直接内存 直接内存并不是虚拟机运⾏时数据区的⼀部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使⽤。⽽且也可能导致 OutOfMemoryError 错误出现 。
参考：SnailClimb&amp;JavaGuide
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ffef2ad295598b808e245927ff85ec70/" rel="bookmark">
			利用 Matplotlib 简单显示神经网络训练损失变化曲线
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 常用 TensorBoard 来显示神经网络训练损失值变化曲线，但需要下载包，操作相对比较麻烦，因此对于非特殊情况可以使用 Matplotlib 来输出曲线，具体代码如下。
import matplotlib.pyplot as plt # 设置汉字输出 plt.rcParams['font.sans-serif'] = ['SimSun'] plt.rcParams['axes.unicode_minus'] = False Loss_list = [] # 损失值存储数组 loss = lossFunction(output, target) # 计算损失值，lossFunction自定义 Loss_list.append(loss) # 插入损失值 plt.figure() x = range(0,1000) # x和y的维度要一样 y = Loss_list plt.plot(x, y, 'r-') # 设置输出样式 plt.ylabel('当前损失值') plt.xlabel('训练次数/次') plt.savefig('F://loss.jpg') # 保存训练损失曲线图片 plt.show() # 显示曲线 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4757c7afdcd4394eff1e59a3fe79f93/" rel="bookmark">
			Verilog 学习笔记（5）——模块和例化、函数和任务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本章介绍Verilog模块和例化、函数与任务的内容。
文章目录 5.1 Verilog 模块与端口模块端口inout 端口仿真 5.2 Verilog 模块例化命名端口连接顺序端口连接端口连接规则 5.3 Verilog 带参数例化defparam 语句带参数模块例化 5.4 Verilog 函数函数常数函数automatic 函数 5.5 Verilog 任务任务与函数的区别任务任务操作全局变量automatic 任务 5.1 Verilog 模块与端口 模块 模块是 Verilog 中基本单元的定义形式，是与外界交互的接口。
模块格式定义如下：
module module_name #(parameter_list) (port_list) ; Declarations_and_Statements ; endmodule 模块定义必须以关键字 module 开始，以关键字 endmodule 结束。
模块名，端口信号，端口声明和可选的参数声明等，出现在设计使用的 Verilog 语句（图中 Declarations_and_Statements）之前。
模块内部有可选的 5 部分组成，分别是变量声明，数据流语句，行为级语句，低层模块例化及任务和函数，如下图表示。这 5 部分出现顺序、出现位置都是任意的。但是，各种变量都应在使用之前声明。变量具体声明的位置不要求，但必须保证在使用之前的位置。
端口 端口是模块与外界交互的接口。对于外部环境来说，模块内部是不可见的，对模块的调用只能通过端口连接进行。
端口列表
模块的定义中包含一个可选的端口列表，一般将不带类型、不带位宽的信号变量罗列在模块声明里。下面是一个 PAD 模型的端口列表：
module pad( DIN, OEN, PULL, DOUT, PAD); 一个模块如果和外部环境没有交互，则可以不用声明端口列表。例如之前我们仿真时 test.sv 文件中的 test 模块都没有声明具体端口。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e4757c7afdcd4394eff1e59a3fe79f93/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef5bcec86a975302ca24883fd30a8573/" rel="bookmark">
			html5css字体斜体,你未必知道的CSS小知识：font-style的oblique属性值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对与css的font-style属性，我估计大家每次见到的都是使用“normal”或 “italic”两个属性值。但事实上，你还可以让它赋值为“oblique”。请看下面的演示：
HTML代码
Oblique Text Italic Text CSS代码
h1 {
font-weight: normal;
font-family: Georgia, serif;
font-style: oblique;
text-align: center;
font-size: 50px;
}
h1:nth-child(2) {
font-style: italic;
}
p {
font-family: Arial, sans-serif;
text-align: center;
}
演示
这是什么意思？为什么“oblique”和斜体”italic”的效果是一样的？
CSS规范中是这样描述“oblique”的：
“…让一种字体标识为斜体(oblique)，如果没有这种格式，就使用italic字体。”
这里描述所用的“oblique”和“italic”都是倾斜的意思。“oblique”在维基百科里的解释就是一种排版术语，就是一种倾斜的文字，但不是斜体。
因为“oblique”对于font-style来说是一种合法的属性值，它可和italic进行互换，除非真有一种字体只提供了oblique体而没有提供斜体。
但我似乎从来没有听说过哪种字形提供过oblique字体，也许我错了。研究发现，一种字库好像不能同时提供斜体和oblique两种字体，因为oblique基本上是一种模仿的斜体，而不是真正的斜体。
所以，如果我没有猜错的话，如果一种字库里没有提供斜体字，那当使用CSS的font-style: italic时，浏览器实际上是按font-style: oblique显示的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5746c4e2ea18567c6b044f7d7ff662e/" rel="bookmark">
			pandas输出csv不带自动添加的行和列的序号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在用pandas输出csv时，如果不对第一行和第一列进行定义，pandas会自动用数字序号补齐，但有时候我们只想单纯输出数据，不想要表头或者序号，那么就需要以下的操作：
output = pd.DataFrame(data=list1) output.to_csv('save_path', header=None, index=None) 将header和index赋值成None即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2665c93c5610dc15a2053e0c1957b5c/" rel="bookmark">
			Ubuntu20.04 IP地址配置 netplan
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		虚拟机配置IP地址
配置文件路径：/etc/netplan/*.yaml
配置格式：(详见下边的网址)
Netplan | Backend-agnostic network configuration in YAML
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3875e4aa91ede3d590e975d0dae0b85/" rel="bookmark">
			Unity使用FGUI项目TTF字体动态批量替换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近一个Unity项目首次使用了FGUI来作为UI编辑器遇到了一个TTF字体批量替换的问题。
因为我们的项目需要发不同的地区，由于每个地区的文字不一样一般一个字体包的多语言的表现不是很好，所以我们需要用到多个TTF字体来匹配不同的语言；
有朋友说发包时分地区去手动替换字体的方式，这样的做法是不可取的，太花时间和经历了，且有可能会遗漏掉一些地方没有替换到；
所以我们需要做动态监测当前系统语言，且替换文本的字体为与当前语言所匹配的字体；
我们的思路大致就是打开一个界面的时候先找到他下边的所有文本对象，修改它的字体；
TTF字体需要放到Resources或者Resources/Fonts文件夹下；
流程如下：
1.查看了运行状态下界面下每个对象身上都挂载了脚本DisplayObjectInfo 。
2.这个脚本管理了一个DisplayObject类， DisplayObject是所有FGUI显示对象的基类。
3.我们在界面的基类中需要创建一个 静态变量（用来存保存当前字体的名称）和一个静态方法（用来传入当前字体的名称）。
4.在游戏开始运行时所有界面打开之前 检测系统语言 然后 通过界面基类的静态方法传入当前要使用的字体名称。
5.在界面基类的初始化方法中获取到当前界面下的所有子对象的DisplayObjectInfo脚本,判断DisplayObject的类如果是TextField类就将它转为TextField类然后设置字体就行了。
有什么不明白的可以联系我QQ：1253263299 备注来意
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3faecad7c508882c97157f77148a5257/" rel="bookmark">
			关于MediaCoder使用过程问题整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、MediaCoder压出来的视频都会莫名其妙带一个标签
2种解决办法
1）关了播放器的章节功能，
2）容器里不要自动选择，选启用→MP4BOX。
2、使用MP4BOX混流画面直接黑屏
mp4box 混流hevc视频出现黑屏问题是因为混流器版本太旧了，有bug，作者也懒得更新，要修复这个问题，去mp4box的官网，下载最新版本构建的程序替换到mc的coder或tools目录就行
https://juejin.cn/post/6854573210579501070
这个黑屏是由于tag引起的
libavformat/movenc.c是mp4和mov的Muxer类，其中AVOutputFormat-&gt;codec_tag指定了某个封装格式支持的codec_tag列表，mp4支持的codec_tag列表在libavformat/isom.c中的ff_mp4_obj_type结构体中
发现expected specified color aspects这个有差异,这个是干嘛的?中文翻译为"预期的指定颜色方面",文件在
platform/frameworks/av/+/master/media/libstagefright/foundation/ColorUtils.cpp
是不是这里导致有问题?
经过确认和这个color aspects没关系
第一个是start_time,下面那个是bitrate
ffmpeg升级到4.0的版本后,黑屏问题解决了,到底是哪里出了问题,修改了那里呢?有时间慢慢研究
可以利用mediacoder添加画面数据比较少的开场来加快快速起播的速度
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05541a77fe8bf81732c077a1e85c3a15/" rel="bookmark">
			html页面打印&#43;区域,实现web网页指定区域打印的三种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通过本教程可以实现，将印web网页指定区域的内容，本教程将提供三种方法实现。
方法一：打印网页指定区域
HTML
在需要打印的内容
// 页面上的内容大小调整可以css调整或容器包容 打印容器内的内容就可以了
JS
function doPrint() {
bdhtml=window.document.body.innerHTML;
sprnstr="";
eprnstr="";
prnhtml=bdhtml.substr(bdhtml.indexOf(sprnstr)+17);
prnhtml=prnhtml.substring(0,prnhtml.indexOf(eprnstr));
window.document.body.innerHTML=prnhtml;
window.print();
window.document.body.innerHTML=bdhtml;
}
方法二：指定打印区域
把要打印的内容放入一个span或div，然后通过一个函数打印。
代码如下：这里是要打印的内容
所有内容
div2的内容 打印
function printme(){
document.body.innerHTML=document.getElementById('div1').innerHTML+'
'+document.getElementById('div2').innerHTML;
window.print();
}
方法三：使用CSS
定义一 个.noprint的class，将不打印的内容放入这个class内。
代码如下：
.noprint{visibility:hidden}
这 里是要打印的内容。
这里是不打印的内容。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/974f4161451ec22d19c4c72347ff5249/" rel="bookmark">
			C语言——指针练习题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		内容 1.sizeof与strlen计算
2.指针面试题
*1.sizeof与strlen计算 32位操作系统下，不管什么类型指针都占 4 个字节的内存大小；strlen(const char*)； (1) 一维数组相关计算
int a[] = { 1,2,3,4 }; printf("%d\n", sizeof(a)); //16 数组中有4个整型Int类型的元素 printf("%d\n", sizeof(a + 0)); //4 数组名参与运算时会隐式转换为指向首元素（地址）的指针；再加减操作时指针移动的字节数；移动完仍是指针Int* 类型 printf("%d\n", sizeof(*a)); //4 数组名隐式转化为指针 int* ，在进行解引用成 Int 类型 printf("%d\n", sizeof(a + 1)); //4 数组名参与运算转化为指针，在加减仍为int* 类型 printf("%d\n", sizeof(a[1])); //4 表示数组第二个元素所占内存大小，类型位int printf("%d\n", sizeof(&amp;a)); //4 int[4]数组-&gt;int(*)[4]数组指针 printf("%d\n", sizeof(*&amp;a)); //16 &amp;a:int(*)[4]-&gt;再解引用得到int[4] printf("%d\n", sizeof(&amp;*a)); //4 *a:inta[0]-&gt;加&amp; 得到一个指针指向第一个元素 * a[0] printf("%d\n", sizeof(&amp;a + 1)); //4 &amp;a:int(*)[4]-&gt;再加减操作仍为指针类型 printf("%d\n", sizeof(&amp;a[0] + 1)); //4 &amp;a[0]:int* +1 -&gt; 仍为int*类型 （2）字符数组
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/974f4161451ec22d19c4c72347ff5249/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/298258820ba7b1858a25b14875a47ba7/" rel="bookmark">
			Java函数式编程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java函数式编程 笔记来源：
Java疯狂讲义、廖雪峰老师的博客
对于Java的函数式编程，做一些摘抄以及总结，我是一个快乐的搬运工~~~
Lambda表达式 一、简介 Lambda表达式，也可称为闭包，它是推动 Java 8 发布的最重要新特性，它允许把函数作为一个方法的参数，使代码变的更加简洁紧凑，它允许使用更简洁的代码来创建一个只有一个抽象方法的接口（这种接口被称为函数式接口）的实例。
二、Lambda入门 下面用一个小例子来简单说明
以Comparator为例，我们想要调用Arrays.sort()时，可以传入一个Comparator实例，以匿名类方式编写如下
String[] strings = new String[] {"Apple", "Orange", "Banana", "Lemon"}; Arrays.sort(strings, new Comparator&lt;String&gt;() { public int compare(String o1, String o2) { return o1.compareTo(o2); } }); 从Java 8开始，我们可以用Lambda表达式替换 单方法 接口（注意是单方法！！！）如下
Arrays.sort(strings, (s1, s2) -&gt; { return s1.compareTo(s2); }); 其中，参数是(s1, s2)，参数类型可以省略，因为编译器可以自动推断出String类型。-&gt; { ... }表示方法体，所有代码写在内部即可，返回值的类型也是由编译器自动推断的，这里推断出的返回值是int，因此，只要返回int，编译器就不会报错。
从上面的例子可以看出：Lambda的代码块会代替实现抽象方法的方法体，Lambda就相当于一个匿名的方法。
三、Lambda表达式与函数式接口 Lambda表达式的类型，也被称为目标类型（target type），Lambda的目标类型必须是函数式接口（functional interface）。所谓函数式接口就是只包含一个抽象方法的接口（但是可以包含多个默认方法，类方法，但是只能声明一个抽象方法）。例如 Runnable、ActionListener都是函数式接口。
Java8专门为函数式接口提供了@FunctionalInterface注解，它用于告诉编译器严格检查–检查该接口必须是函数式接口，否则编译器报错。
由于Lambda表达式的结果就是被当成对象，因此可以直接进行赋值如下
Runnable runnable = () -&gt; { for (int i=0; i&lt;100; i++) System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/298258820ba7b1858a25b14875a47ba7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d04fd2e1604c32403bbb4ff04f75b365/" rel="bookmark">
			QQ登录的引用小技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
开发工具与关键技术： Axure 作者：苏莹
撰写时间：2021/6/8
一、打开Axure软件。
二、进入页面。
三、打开页面的元素库，将矩形3拉出。
四、从元素库拉出文本标签，打上相应的字词，大小对齐。
五、从元素库里拉出文本框，再按CTRL复制多一个文本框
六、再到页面右边，点击第一条文本框提示文字上打出（请输入QQ号），第二条文本框提示文字上打出（密码）。
七、再点击第一条文本框元件提示（QQ号不能为空）。
八、再从元素库拉出（主要按钮），双击在里面打出登录两个字。
九、QQ登录完成了。
十、点击预览，查看软件效果。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/606195a36fcd9a1b2ab7deef4df600f9/" rel="bookmark">
			Java 中 Pair 类的五种替代方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Pair 是一个容器，用于存储两个对象的元组。Java 并没有真正提供 Pair 类的任何实现。这篇文章将讨论 Java 中 Pair 类的各种替代方案。
Pair 通常用于一起跟踪两个对象。它包含两个字段，通常称为firstand second，能够存储任何内容。尽管first和second字段之间没有任何有意义的关系，但程序员经常会错过 Java 中的这个功能。
在上一篇文章中，我们讨论了如何在 Java 中实现我们自己的 Pair 类。这篇文章将讨论 Java 中可用的解决方法来填补所需的空白，如下所述：
1. 使用Map.Entry&lt;K,V&gt;界面 我们可以在 Java 中使用Map.Entry&lt;K,V&gt;接口，类似于std::pairC++ 中的接口。这是具有代表键值对的有意义名称的绝佳示例。
为了创建表示从指定键到指定值的映射的条目，Java 提供了该Map.Entry接口的两个具体实现，即AbstractMap.SimpleEntry和AbstractMap.SimpleImmutableEntry。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 import java.util.AbstractMap; import java.util.HashSet; import java.util.Map; import java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/606195a36fcd9a1b2ab7deef4df600f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/555ee978b7ca60258273617bdef8b43c/" rel="bookmark">
			jmeter测试接口-打开很多TCP的连接数TIME_WAIT状态（Linux环境）导致报错的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 jmeter测试接口-打开很多TCP的连接数TIME_WAIT状态（Linux环境）导致报错的解决方法
参考文章：
（1）jmeter测试接口-打开很多TCP的连接数TIME_WAIT状态（Linux环境）导致报错的解决方法
（2）https://www.cnblogs.com/feng-1314/p/7060853.html
（3）https://www.javazxz.com/thread-4764-1-1.html
备忘一下。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2697069a0c4a001a95fe39930b27befa/" rel="bookmark">
			（Android-RTC-2）源码下载编译Android-WebRTC，居然折腾了我那么多天！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开篇导读，工程目录在 https://github.com/MrZhaozhirong/AppWebRTC 自行拾取。工程环境是Gradle4.0.x+Androidx，是手动重新fork整个WebRTCdemo，官方源码在这里。
一、源码下载 关于Android-WebRTC的源码下载编译很多教程。相关注意两个点：必须是用Linux系统，源码站点需要正确的上网方式，或者找国内镜像代替；根据实际情况把下载编译源码的过程记录在此，方便有需要的同学排忧解难。
有什么问题可以私信访问。以下是本文的无脑教程：
1、环境准备
正确科学严谨的上网方法，建议代理系统所有网络。
2、安装基础软件依赖
检查更新依赖库：$ sudo apt-get update
安装vim：$ sudo apt-get install vim
安装git：$ sudo apt-get install git
3、安装google工具和脚本
git clone https://chromium.googlesource.com/chromium/tools/depot_tools.git
正常情况下，这个depot_tools下载是比较顺畅的。如果网络不通畅下载超时，可以为git配置以下代理
git config --global http.proxy = （通常是127.0.0.1）：端口
git config --global https.proxy = （通常是127.0.0.1）：端口
再专业一点，
export HTTPS_PROXY=http://proxy_ip:proxy_port #科学的上网方式设置参数
export HTTP_PROXY=http://proxy_ip:proxy_port #科学的上网方式设置参数
env GIT_SSL_NO_VERIFY=true #如果fetch代码遇到ssl报错，请设置这个环境变量
vim ~/.boto
增加.boto代理出口文件，内容如下
[Boto]
proxy=ip
proxy_port=端口
export NO_AUTH_BOTO_CONFIG=~/.boto #结合自己的情况设置路径
4、下载完成之后，配置环境变量
$ vim ~/.bashrc
在文件最底下追加以下内容：
export DEPOT_TOOLS_PATH=~/depot_tools（自己写全绝对路径也可以啊）
export PATH=${PATH}:${DEPOT_TOOLS_PATH}
保存退出vim，使环境变量生效：$ source ~/.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2697069a0c4a001a95fe39930b27befa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/014c711a05b03118684948bbd0ee67dd/" rel="bookmark">
			【C&#43;&#43;】【最短路径】Bellman-Ford 算法实现（贝尔曼-福特算法）(带负权边的图）【relaxation】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Bellman-Ford 一、Bellman-Ford 算法 是什么？1.特点2.思想 二、简易实现1.解读2.完整代码 参考 一、Bellman-Ford 算法 是什么？ 求解单源最短路径问题的一种算法。
它的原理是对图进行V-1次松弛操作，得到所有可能的最短路径。
其优于Dijkstra 算法的方面是边的权值可以为负数、实现简单，缺点是时间复杂度过高，高达O(VE)。
1.特点 Bellman-Ford 支持有负权边的存在。同时能检测出图中有没有负权环
算法时间复杂度：O(EV) 其中E为边数、V为节点数。
算法的核心其实是relaxation，松弛操作，这对于有权图来说，十分重要。
因为两个节点中的最短路径，在有权途中，绕一圈反而比直接连接更优，带了负权边，更是如此。
其核心思想就是：对每个节点（V次）遍历一次所有的边（E次），找到源点到每个点的最短路径。
2.思想 遍历一个节点时，对其做V-1次松弛操作（因为每个其他的节点都有可能使得绕行的权值更低）
V-1次松弛操作：即对下图中节点0，对节点1做第二次松弛的时候发现：0-1-2路径更短，就更新0-2的最短路径为1 。（同时，还要对节点0再多做2次松弛，一共做V-1 = 4次松弛操作。）
其中v-1次松弛，其实是遍历了所有的边O(E)。
分析：
上面看到：对节点0做第二次松弛，能找到从0经过两条边的最短路径。
即： 对一个节点多做一次松弛操作，就是找到这个点的另一条路径，多一条边，权值更小
从一个点到另一个点的最短路径，最多是经过了所有的节点，包含了V-1条边。所以我们要对每个点进行V-1次松弛。
复杂度分析：
V-1次relaxation，其实就是遍历了所有的的边O(E),
一共需要做节点V次，所以时间复杂度为0(EV)。
二、简易实现 bobo老师的实现代码解读：：
//代码涉及：（文末参考中由相关简介）
模板类、模板函数
最小索引堆
1.解读 算法初始化过程：
distTo 为存储从source到各个节点的最短路径。初始化为节点个数个空数组。用模板类型的默认构造来初始化。
from 为了记录最短路径中，当前节点是从哪个边过来的。可以恢复整条路经出来。
让from[s]不为NULL, 表示初始s节点可达且距离为0
this-&gt;s = s; distTo = new Weight[G.V()]; // 初始化所有的节点s都不可达, 由from数组来表示 for( int i = 0 ; i &lt; G.V() ; i ++ ) from.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/014c711a05b03118684948bbd0ee67dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bfa12f966b1a3a590c8e488f4abd96fa/" rel="bookmark">
			空洞卷积的计算过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Dilated convolutions 在卷积的时候，会在卷积核元素之间塞入空格，塞入的空格与hyper-parameter: dilation有关（记为d），则塞入的空格为d-1。
1、感受野计算。假定原来的卷积核大小为 k，那么塞入了 (d - 1) 个空格后的卷积核的感受野大小为：
2、特征图大小计算。假定输入空洞卷积的大小为 i，步长 为 s ,空洞卷积后特征图大小 o 的计算公式为：
p为padding， s为stride，k为卷积核大小， d为dilation
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a18eb721e9ffcb4fbf429c08cfb5f9df/" rel="bookmark">
			Mac 安装Navicat Premium
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 百度云下载dmg文件配置 百度云下载dmg文件 链接: https://pan.baidu.com/s/1Xm2sw_1hjTDWU9s0zesmvA 密码: relg 配置 首先安装，安装后打不开
打开终端，执行下面的命令。 sudo xattr -r -d com.apple.quarantine /Applications/Navicat\ Premium.app 回车，出现Password?，输入电脑开机密码，密码不显示，输入即可回车 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6db116645d7737d4eeb003063e95c524/" rel="bookmark">
			VSCODE 插件配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vscode 小技巧 //-----------主题-------------- "workbench.colorTheme": "Default High Contrast", //-----------自动识别编码-------------- "files.autoGuessEncoding": true, //-----------代码保存格式话-------------- "editor.formatOnType": true, "editor.formatOnSave": true //显示字符边界 "editor.rulers": [80,120], //-----------tab 设置-------------- "editor.detectIndentation": false, "editor.tabSize": 4, 工具 中文支持包
Chinese (Simplified) Language Pack for Visual Studio Code
c语言开发支持
C/C++
stm32 开发工具
Keil Assistant：使用keil工程
【文件file】 --&gt; 【选项Preferences】–&gt; 【设置Settings】–&gt;【扩展】–&gt; Keil Assistant–&gt;添加keil路径
Embedded IDE：可导入keil工程，调试方便
汇编代码支持
ARM
彩虹括号
Bracket Pair Colorizer
函数注释
C-family Documentation Comments
// C-family Documentation Comments "docomment.activateOnEnter": true, "editor.insertSpaces": true, "editor.tabSize": 4 文件头部注释和函数注释的插件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6db116645d7737d4eeb003063e95c524/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e5466053faae7c17870aa3e3acc267d/" rel="bookmark">
			JSP中的内置对象pageContext的作用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.当作当前页面域对象使用
2.可以获取到jsp中其他8个内置对象（jsp中其实可以直接用其他内置对象，但再el表达式中可以尝试使用，因为request、response、 session、 servletContext、 servletConfig 等对象在EL中不是内置对象。这些对象只能通过pageContext 获取），如：
3.添加不同常量后，可以当成对应其他对象使用，如：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44b0d71b6ebc3eacef84868cfdb46302/" rel="bookmark">
			rebar3编译及发布erlang程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		确保已经安装erlang/OTP和rebar3，否则，可参考本人的“centos7安装erlang/otp”、“centos7安装rebar3”博文完成安装
【1】生成
rebar3为每种类型的项目都提供了模板，通过rebar3 new &lt;template&gt; &lt;project-name&gt;命令使用。
&lt;template&gt;的取值
app: 一个有监督树、有状态的OTP应用程序，是一个单应用程序
lib: 一个OTP依赖(无监督树)，与其他模块联合使用，是一个单应用程序
release: 创建一个大型项目
escript: 一个特殊格式的单应用项目，可以编译为一个可执行的脚本程序
plugin: rebar3插件结构
shell 命令举例
rebar3 new app myapp
【2】配置依赖
依赖被配置在rebar.config文件的deps下
{deps, [
{cowboy, "1.0.1"}, % package
{cowboy, {git, "git://github.com/ninenines/cowboy.git", {tag, "1.0.1"}}} % alternatively, source
]
}.
添加依赖
将依赖添加到您项目的应用程序的.app.src文件中，配置你的项目启动时需要用到的依赖。
{application, &lt;APPNAME&gt;,
[{description, ""},
{vsn, "&lt;APPVSN&gt;"},
{registered, []},
{modules, []},
{applications, [
kernel
,stdlib
,cowboy
]},
{mod, {&lt;APPNAME&gt;_app, []}},
{env, []}
]}.
【3】构建项目
只有一个命令compile，就可以拉取应用需要的依赖并且编译整个应用程序
shell 命令
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44b0d71b6ebc3eacef84868cfdb46302/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11260ed962b8f7c7466367cf2cebc812/" rel="bookmark">
			通过socket与树莓派通信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		此文章来记录一下学习树莓派的过程
这是一道作业题目
原题目：
使用树莓派、智能手机等设备制作一台网络电灯（实验中可以用LED灯模拟）， 通过手机端可以远程遥控树莓派，从而点亮、关闭电灯以及调节灯光亮度 目录 前言一、socket是什么？二、服务端1.引入库2.服务端代码1全部代码2部分代码讲解 客户端说明包含kivy部分的客户端代码全部代码部分通信关键代码关于kivy 总结 前言 需要的设备：
树莓派：小编使用的是树莓派3B+（已配置好系统） 可以运行程序的设备：小编的笔记本电脑 电源：给树莓派供电 WiFi：可以是手机热点或者路由器，用来查询树莓派ip地址，以及作为一个局域网供树莓派和电脑通信 分析
曾经学过单片机的串口通信，在电脑上运行串口助手，配置好相关参数之后，和单片机进行通信。 树莓派的原理也是如此，电脑发，树莓派接受并判断是否有效，从而执行相应的功能命令 看别的使用的是socket进行通信，这里也是如此，树莓派作为服务端，在电脑上运行客户端 服务端时刻监听着，客户端随时准备发消息 说干就干，干 下文将介绍socket的一些基本知识和kivy的一些基本知识，可能不全，莫怪莫怪，原理直到就行了。
一、socket是什么？ socket是对TCP/IP协议的封装，这里涉及到了TCP/IP，就简单说一下百度百科说的很明白的
TCP/IP
TCP/IP 全称：Transmission Control Protocol/Internet Protocol-----传输控制协议/网际协议
是实现信息传输的协议族，是一个协议的集合，包含多种协议，并不值TCP/IP本身。包含应用层的协议FTP、SMTP等，功能：接受来自传输层的数据或者按不同应用要求和方式将数据传输到传输层；传输层的UDP、TCP，功能：实现数据传输和数据共享；网络层的ICMP、IP、ICMP，功能：负责网络中的数据包传输等；数据链路层（网络接口层）的ARP、RARP等，功能：提供链路管理错误检测、对不同通信媒体有关信息节问题进行有效处理等。
socket也是python里面的一个库函数，大佬们已经为我们封装好了一些功能，例如配置ip和端口，连接，监听等
二、服务端 1.引入库 树莓派作为服务端且控制led，首先要引入RPi.GPIO库，实现对GPIO口的控制，另外就是socket库了：
import socket import sys #这个库用来处理当创建socket时发生的异常 import RPi.GPIO 2.服务端代码 1全部代码 # -*- codeing = utf-8 -*- # @Time :2021/6/3 21:45 # @Author : 刘念卿 # @File : shumeipai_sever.py # @Software : PyCharm import socket import sys import RPi.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/11260ed962b8f7c7466367cf2cebc812/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85c2b8d3b298d1cbd180b28fc32c1978/" rel="bookmark">
			javaweb之Servlet基础详解（一文看懂，干货多多）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Servlet基础 文章目录 Servlet基础@[TOC]一、Servlet概述1.回顾JSP如何编写服务器动态网页 二、Servlet与JSP的关系1.疑问 三、Servlet的声明周期1.Servlet声明周期2.生命周期的各个阶段3.Servlet构造方法4.init()方法5.service方法6.doGet()方法7.doPost()方法8.destroy()方法9.GET和POST的区别 四、Servlet的配置、实例实例1：简单的xml配置，带上下文参数和初始化参数实例2：使用WebServlet注解配置Servlet实例3：测试Servlet是线程不安全 一、Servlet概述 servlet百度百科servlet菜鸟教程 Servlet（Server Applet）是Java Servlet的简称，称为小服务程序或服务连接器，用Java编写的服务器端程序，具有独立于平台和协议的特性，主要功能在于交互式地浏览和生成数据，生成动态Web内容。
即是：
Servlet是一个Java程序是运行在服务器上处理客户端请求并作出响应 1.回顾JSP如何编写服务器动态网页 就像其他普通的网页一样，您的浏览器发送一个HTTP请求给服务器。
Web服务器识别出这是一个对JSP网页的请求，并且将该请求传递给JSP引擎。通过使用URL或者.jsp文件来完成。
JSP引擎从磁盘中载入JSP文件，然后将它们转化为servlet。这种转化只是简单地将所有模板文本改用println()语句，并且将所有的JSP元素转化成Java代码。
JSP引擎将servlet编译成可执行类，并且将原始请求传递给servlet引擎。
Web服务器的某组件将会调用servlet引擎，然后载入并执行servlet类。在执行过程中，servlet产生HTML格式的输出并将其内嵌于HTTP response中上交给Web服务器。
Web服务器以静态HTML网页的形式将HTTP response返回到您的浏览器中。
最终，Web浏览器处理HTTP response中动态产生的HTML网页，就好像在处理静态网页一样。
二、Servlet与JSP的关系 1.疑问 发起疑问：先有JSP还是先有Servlet？（当然是先有Servlet了-手动滑稽）
回忆JSP 执行过程，然后说明JSP被翻译成.JAVA，这个.JAVA到底是什么样子呢？
打开环境，新建一个JSP,运行后，再观看此.java文件上，如Test.jsp在运行时首先解析成一个Java类Test_jsp.java，
而这个Test_jsp.java继承于org.apache.jasper.runtime.HttpJspBase类，
而HttpJspBase又是继承自HttpServlet的类，
由此可以得出一个结论，就是JSP在运行时会被Web容器翻译为一个Servlet
三、Servlet的声明周期 1.Servlet声明周期 2.生命周期的各个阶段 请求处理：当有请求到达容器时，容器会调用servlet对象的service方法。HttpServlet的service方法，它会根据用户的请求方式来调用doGet（）或doPost().
但是，这两个do方法默认情况下会抛出异常，所以需要子类去重写（override）
3.Servlet构造方法 构造方法只有首次调用Servlet时，会被执行，后续请求不在执行例如： public HelloServlet() { //1.只有首次会执行 System.out.println("创建HelloServlet对象"); } 4.init()方法 init方法被设计成只调用一次它在第一次创建Servelt时，被调用，在后续每次用户请求时，不再调用。因此，它是用于一次性初始化。 @Override public void init(ServletConfig config) throws ServletException { //2.只有首次会执行 System.out.println("开始初始化"); super.init(config); } 5.service方法 service()方法是执行实际任务的主要方法Servlet容器(即Web服务器)调用service()方法来处理来自客户端(浏览器)的请求，并把格式化的响应写回给客户端。 @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/85c2b8d3b298d1cbd180b28fc32c1978/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9b3f970e1027f81f096540372be7c2c/" rel="bookmark">
			windows 下wsl 启动不了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		win10 升级到了dev 版本，安装了16.10.0版本的visual studio 2019 后，重启启动， 发现wsl 启动不了了， docker desktop 不能用了
尝试了下面的一波操作以后恢复可以用了，原因也不知道是啥
操作步骤如下
admin 权限打开termianl执行下面的命令： Dism /Online /Cleanup-Image /CheckHealth 是检查映像以查看是否有检测到损坏 Dism /Online /Cleanup-Image /ScanHealth 是扫描你全部系统文件并和官方系统文件对比 check结果全部ok
3. 停止wsl， 重新启动
wsl --shutdown 输入bash 等待重启 然后发现好了
相关资料
https://answers.microsoft.com/zh-hans/windows/forum/windows_10-other_settings/wsl%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8%E5%90%AF/f6c09976-2907-4fac-91f6-3d730feee84f?page=1
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dfbe06ccf6b47ac720b655e0239d4d33/" rel="bookmark">
			2021-06-01 VCU软硬件设计开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		**电动汽车整车控制器（VCU）技术及开发流程剖析** 整车控制器（VCU），电动汽车的大脑，相当于电脑的Windows，手机的Andrio。作为电动汽车上全部电气的运行平台，它的性能优劣，直接影响其他电气性能的发挥，是整车性能好坏的决定性因素之一。
1 组成
结构组成
VCU，结构上，由金属壳体和一组PCB线路板组成。
硬件组成
功能上由主控芯片及其周边的时钟电路、复位电路、预留接口电路和电源模块组成最小系统。
在最小系统以外，一般还配备数字信号处理电路，模拟信号处理电路，频率信号处理电路，通讯接口电路（包括CAN通讯接口和RS232通讯接口）
2 各电气与VCU之间是怎样工作的
一些用于监测车体自身状态的信号或者车载部件中比较重要的开关信号、模拟信号和频率信号，由传感器直接传递给VCU，而不通过CAN总线。
电动汽车上的其他具有独立系统的电气，一般通过共用CAN总线的方式进行信息传递。
2.1 直接传递的信号们
这里所说的开关信号包括：钥匙信号，档位信号，充电开关，制动信号等；
模拟信号一般有：加速踏板信号，制动踏板信号，电池电压信号等；
频率信号，比如车速传感器的电磁信号。
输出的开关量，动力电池供电回路上的接触器和预充继电器，在一些车型上，由VCU负责控制。
2.2 通过CAN交互的电气单元
CAN总线上的通讯参与者地位不分主从，随时随地向总线发动信息。信息之间的先后顺序由发出信息者的优先级确定。优先级在通讯协议中已经做出规定，每条信息里都有发信者的地址编码；
通讯中的信息编码，都有相应的通讯协议予以明确规定。谁发出什么样的代码提供哪些类型的信息，主要依据是供需双方的约定。比如下面表格中的电气单元地址编码，就是来自一份整车厂与VCU供应商的技术协议。
CAN故障记录，是维修调试人员最好的小帮手。下图是通讯协议中对故障代码的规定，常见的故障类型都位列其中，只要对照协议表格，大家都可以读懂故障记录了。
比较例外的是充换电相关的系统，由于通用性的强烈需求，通讯协议需要统一，有国家标准予以统一编码（下文列举了相关国标）。
2.2.1 VCU与动力电池系统
动力电池是纯电动汽车动力的唯一来源。VCU与电池管理系统（BMS）通过整车CAN总线进行信息交互。
动力电池包实时监测并上报给VCU参数包括：总电流，总电压，最高单体电压，最低单体电压，最高温度，电池包荷电状态SOC（State of Charge），某些系统还监测电池包健康状态SOH（State of Health）。
VCU发送给电池包的命令包括充电，放电和开关指令。
充电，在最初的充电连接信号确认后，整车处于禁止行车状态，VCU交出控制权。整个充电过程由电池管理系统（BMS）和充电机共同完成，直至充电完成或者充电中断，车辆控制权重新回到VCU手中。
放电，VCU根据驾驶员意图，推算出车辆的功率需求，换算成电流需求，发送给BMS。BMS根据自身SOC，温度和系统设计阈值，确定提供的电流值。
当热管理系统需要使用电池包以外的资源时，需要电池包与VCU协调处理让管理过程，比如压缩机系统，冷却液循环系统等的开启关闭。如果热管理过程只涉及电池包内部电气，比如开启内置的PTC、加热膜加热，或者开启风扇降温，则信息只在电池包内部处理即可，不需要与VCU沟通。
开关指令，在充放电开始之前，VCU控制整车强电系统是否上电，通过控制电池包的主回路接触器实现。在车辆运行过程中，遇到突发状况，VCU酌情判断是否闭合或者断开主回路接触器。
2.2.2 VCU与电机及其控制器
VCU向电机控制器发送的指令，包含三个部分的描述，电机使能信息、电机模式信息（再生制动，正向驱动，反向驱动）以及相应模式下的电机转矩；
电机控制器向VCU上报电机和控制器的各种参数及故障报警信息，主要参数包括电机转速，电机转矩，电机电压和电流。
2.2.3 VCU与充电系统
充电系统包括车载充电机，非车载充电机，广义上还包含换电系统。充换电系统（这里的“充”主要是指非车载充电机），出于最大通用性的考量，需要一套统一的通讯协议。下列国标都是目前的最新版本。
GBT 27930-2015 电动汽车非车载传导式充电机与电池管理系统之间的通信协议
GB∕T 32895-2016 电动汽车快换电池箱通信协议
GBT 32896-2016 电动汽车动力仓总成通信协议
标准统一规定了充电流程，包括具体的通讯编码，通讯语句的内容。
以充电枪与车辆上的充电接口的物理连接为开端，整个充电过程中的信息互换都在电池管理系统和充电机之间进行，不再通过VCU。
2.2.4 VCU与制动系统
采用复合制动系统的电动汽车，需要综合考虑液压制动系统，电机制动和防抱死系统（ABS）的协调一致性，进而需要有自己的管理系统，称为制动管理系统（BCU）。BCU可以独立于VCU之外，只通过CAN通讯，也可以把功能集成到VCU内部。
根据制动踏板的开度和开度变化的速度，VCU计算出车辆的制动需求力矩，传递给BCU。BCU根据车辆的具体状态做出具体力矩分配。
车速中等的一般制动，直接切入电机能量回馈制动，以最大数量的回收制动能量；
车速高，驾驶员急踩踏板，需要紧急制动。则BCU会首先启动液压制动系统，待减速状态稳定以后，再引入能量回馈制动，并逐渐加大比例。
行驶在冰雪路面，BCU则会引入ABS，并将其优先级设置为最高，以车辆正常安全行驶为要。
2.2.5 VCU与智能仪表
电动汽车仪表盘，结合传统车原来的布置，国标GB/T 19836-2005 对显示内容提出了要求，如下表所示。
智能仪表，高端和低端的原理区别比较大。我们只以其中一种形式为例。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dfbe06ccf6b47ac720b655e0239d4d33/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc22ae8fb605017404b6a14aa17624c3/" rel="bookmark">
			对称密码和公钥密码密钥的分配
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、单钥密码的密钥分配 单钥密码，即加密和解密都用同一密钥的加密体制
分配方法:
A选取发给B第三方A选取发给B第三方选取发给A和BA和B已有共同密钥，一方选取新密钥时，用旧密钥加密发给另一方 缺点:容易受到冒充，而且n个用户互相通信，机构要管理n* (n-1)/2 对密钥，代价大
较好的分配方法 : 密钥分配中心
在密钥分配中心，每个用户都与中心之间有固定密钥，用户联系的时候产生临时密钥Ks，一定时间后销毁
二、分配步骤 A向中心发送自己的身份、要联系用户B的身份和当前业务标识符(加密)中心发送A解密后的信息(让A确保消息的正确性)，标识符(让A确保是当前业务，不是敌手截获到以前业务信息再发送过来的)和临时密钥Ks、B的密钥A用B的密钥加密A的身份、Ks发送给B 这样，A和B就有了临时的共享密钥Ks
如果B想确认A的身份，用共享密钥加密随机数发送给A，A如果能成功解密，这次密钥交换可以说是成功的
三、公钥密码密钥分配 公开发布 容易受到冒充公用目录表 管理员维护各个用户的公钥公钥管理机构 与单钥的类似 比较好的分配方法:公钥证书
发送方把自己的身份、公钥、当前时间戳发送给CA，CA用密钥签字形成证书
接受方用CA的公钥解密，验证了证书确实是CA发放的，并且获得时间戳保证证书不是重放的
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06614d6aea791d24380e4f23cc8e7b77/" rel="bookmark">
			wireshark 导出指定数据包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据包回放时，如果我们只想将pcap包中的部分数据进行回放，怎么办呢，
首先使用wireshark打开文件， 在过滤器中进行过滤，比如我只想要tcp.stream eq 0的数据，可以如下操作：
过滤好数据，然后依次操作 文件=&gt;导出特定分组=&gt;文件名称。写好就行了，比如test.pcap
最后到指定的目录下打开相应文件，检查是否与预期一致；
注意： 如果只想导出一个包，上图中的“仅选中分组” 选中即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44b34be258b741ece4a4596940d2d7b2/" rel="bookmark">
			const 修饰指针
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		const 修饰指针 假设有如下定义一个指针：
int a = 12689;//定义int类型的变量a；
int* p = &amp;a; //定义int*类型的指针变量p，并且设置变量a 的地址，所以，指针p指向变量a；
那么，const 在 int* p 这个形式中，可以存放在两个不同的地方，存放在不同的地方，就修饰不同的内容为“常量”。
(1) const 紧跟着指针变量后面，例如：
char* const pstr = "www.mylinux.vip";//定义pstr指针变量，指向一串字符串;
就是 const 后面紧接这 pstr，所以， const 就修饰 pstr 这个指针，那么，pstr 就是一
个常量，所以，pstr存放的地址值是一个常量，不可以改变。就是不可以修改pstr指针变量存放的数值（pstr指针变量存放的地址值）。例如：
编译提示错误：
所以，pstr是只读类型，不可以修改pstr指针变量的值。不可以修改pstr指针变量存放的地址值。
(2) const 紧跟在指针类型的后面，例如：
const char* pstr = " www.mylinux.vip ";//定义pstr指针变量，指向一串字符串
就是 const 后面紧接着 char，所以，const 修饰的是 char，那么，char 表示 pstr 指向的内容，所以，定义了 pstr 指向的内容是常量，所以，不可以修改 pstr 指向的内容。如下是测试的例子：
程序编译结果如下：
可以看到pstr指向的数据是只读类型，不可以修改pstr指向的数据。
但是，pstr指针变量存放的数据不是只读类型，可以修改pstr存放的地址值。测试例子如下：
程序编译运行结果如下：
可以看到，pstr指向了新的字符串“www”，所以，可以修改指针变量pstr存放的数据。但是，不可以修改pstr指向的数据。
如下是一个分析的例子：
int a = 30; //定义int类型变量a，并设置30这个数值;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44b34be258b741ece4a4596940d2d7b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38a2455651a0ccadadc329bd33d323ff/" rel="bookmark">
			html怎么调搜索框宽高,百度站内搜索css：输入框宽度及样式自定义
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		近日网站使用了百度站内搜索api，目的是为了提高站内搜索的速度，减轻查询站内数据库带来的服务器压力。
不过在使用百度站内搜索api(生效范围：*webkaka.com/*)后发现一个问题，不同的频道模版造成排版不合适的后果，如搜索输入框宽度过长、高度过高等情况。例如技术频道和博客的模版不同，侧栏宽度也不同，如果按照博客的模版来设置搜索输入框宽高，那么在技术频道页面，搜索输入框就超出了侧栏的宽度了。但如果按照技术频道的侧栏宽度来设置搜索输入框宽度，那么在博客侧栏里就显得过短了。因此，需要为各个频道模版自定义百度站内搜索输入框的样式。这个如何实现的？
百度站内搜索
百度也考虑到了这个问题，于是提供了一个css文件，我们在百度站内搜索后台可下载到该文件，下载位置在“搜索框管理”-“编辑样式”，滚动条拖到最下面，就看到“下载嵌入式CSS源文件”了。
我们可以使用这个css文件，来单独设置任何页面的百度站内搜索输入框和按钮的样式。
由于本文主要是介绍如何自定义输入框宽度，因此削掉多余的代码，我们只需这几行代码即可达到目的：
/*输入框自定义样式*/
.bdcs-container .bdcs-search-form-input {
width:230px;
}
/*按钮样式自定义*/
.bdcs-container .bdcs-search{
width:340px;
}
这几行代码怎样使用，很简单，把它们加入到网页的css文件里即可。这几行代码，根据网页布局，修改一下 230 和 340 这两个数字，它们代表的正是输入框和搜索容器的宽度。
百度站内搜索，只能搜索出已被百度收录的网页，不被百度收录的网页是搜不出来的，因此使用时要了解这点。
站长可以到百度站内搜索管理平台(http://zn.baidu.com/cse/home/index)上，使用百度站长管理平台帐号立即获得一个api，无任何附加条件。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/357/">«</a>
	<span class="pagination__item pagination__item--current">358/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/359/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>