<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/323b7da57163a7047d4c01bd46ae5e7a/" rel="bookmark">
			【Goland】软件常规更新
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文主要讲一下Goland的日常更新
众所周知 Goland 是 JB 旗下的主要写 Go 的 IDE，很多同学下载了试用版或者购买了 License 之后，就一直用到天荒地老，其实这样会错过很多重要的功能和 Bug 修复的，本文就举个例子比如 Goland 的一个问题，需要通过更新最新版才能修复的情况，来解释一下及时更新的重要性。
如下图，这个红色的波浪线，对于强迫症来说不能忍，但是为什么之前的 Goland 不会针对这个 panic(err) 的用法报错，现在报错呢，具体的报错信息是 Cannot use ‘err’ (type error) as the type any。
这个问题，其实之前就有人反馈过，可以浏览一下 GO-12171
通过下载的页面去查看一下最新版的 Release Note 里有没有更新这个问题。
如下图，这个问题已经在最新版修复了，所以可以下载一下看看。更新的过程略慢，可以留意到 Goland 可能需要重新索引一下文件。
更新完后再看看，已经不报错了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07fc730c620d6abd5995c21b9153c3b7/" rel="bookmark">
			协方差矩阵
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.n维数据之间的数学关系1. 均值2. 方差3. 标准差4. 协方差1. 计算公式：2. 性质：3. 协方差结果的意义4. 相关系数 2. 协方差矩阵1. 协方差2. 协方差矩阵1. 协方差矩阵计算 1.n维数据之间的数学关系 1. 均值 未经分组的均值计算公式 2. 方差 均值描述的是样本集合的中间点，它告诉我们的信息是有限的；而方差给我们描述的是样本集合的各个样本点到均值之间的平均距离。
单一正态总体方差计算公式： 3. 标准差 方差对平均距离计算了平方，为了还原回原来的数量级，就有了标准差，标准差是对方差开根号
计算公式：
4. 协方差 当出现多维集合时，各个维度间的数据有无关联，可以参照一维的方法，首先将每个维度样本集合中每一个点的数据值减去该维度的平均值，再乘以另外一个维度的同样的差值，最后除以 n-1 就是协方差（n 就是每个维度样本个数，各维度一样），这个协方差就可以反映两个维度间各数据的相关性。
1. 计算公式： 2. 性质： 3. 协方差结果的意义 协方差只是说明了线性相关的方向问题，即从正无穷到负无穷，不能说明相关的程度
结果为正值，两者正相关
正相关：自变量增长,因变量也跟着增长结果为负值，两种负相关
负相关：自变量增长,因变量反而减少结果为0，两者之间没有关系 4. 相关系数 其值始终再-1到1之间变化
计算公式
相关系数 = 两个维度的协方差/（两个维度的标准差） 2. 协方差矩阵 1. 协方差 针对一维样本集合时，求出的协方差其实就是方差，即方差是协方差的一种特殊情况，意义和方差一样，都是反映集合中各元素离散度的针对二维样本集合时，求出的协方差反映的就是两个维度之间的相关性，正相关性或负相关性，或无关针对三维样本集合时，求出的是各个维度总体的相关性，针对各维度之间的关系，所以二维以上计算协方差，用的就是协方差矩阵 2. 协方差矩阵 出现多维数据时，若要对多维数据的相关性进行分析，那么就要用到协方差矩阵 1. 协方差矩阵计算 以三维为例
例题
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a676dcc72e006481a97ecb0760c04016/" rel="bookmark">
			ASP.net 简单注册界面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.说明 此文是小白在学习张晨光老师的视频教学&lt;&lt;Asp.Net WEB服务器编程技术&gt;&gt;中做的学习笔记,一些知识点也是跟着教程走的,大家也可以去老师的主页去学习,谢谢大家.
这一篇要练习的是,如下课程的代码:
先新建img文件夹,用来存储图片:
图片大家可以在网上随便找一些壁纸来替代,练习所用,不必太过讲究
再新建js文件夹,用来存放js文件:
从 jquery.com 下载 jQuery 库
二.注册界面(RegUser.aspx) 前端代码:
&lt;%@ Page Language="C#" AutoEventWireup="true" CodeBehind="RegUser.aspx.cs" Inherits="MyMusci.RegUser" %&gt; &lt;!DOCTYPE html&gt; &lt;html xmlns="http://www.w3.org/1999/xhtml"&gt; &lt;head runat="server"&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"/&gt; &lt;title&gt;会员注册&lt;/title&gt; &lt;link href="bootstrap-5.1.3-dist/css/bootstrap.css" rel="stylesheet" /&gt; &lt;script src="bootstrap-5.1.3-dist/js/bootstrap.bundle.js"&gt;&lt;/script&gt; &lt;!--调用jquery--&gt; &lt;script src="js/jquery.js"&gt;&lt;/script&gt; &lt;style&gt; /*将整个登入的div垂直居中*/ .all { width: 700px; height: 260px; background-color: rgba(205,197,191,0.8); position: absolute; top: 0; bottom: 0; left: 0; right: 0; margin: auto; padding:0; } body { background-image: url("img/ys.jpg"); /*整个图片作为背景，不够自动拉伸*/ background-size: cover; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;form id="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a676dcc72e006481a97ecb0760c04016/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83b18a765fc4b8be0f6d82fe554c7e70/" rel="bookmark">
			动态规划之背包问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文有视频版：0-1背包问题详解
后台天天有人问背包问题，这个问题其实不难啊，如果我们号动态规划系列的十几篇文章你都看过，借助框架，遇到背包问题可以说是手到擒来好吧。无非就是状态 + 选择，也没啥特别之处嘛。
今天就来说一下背包问题吧，就讨论最常说的 0-1 背包问题。描述：
给你一个可装载重量为 W 的背包和 N 个物品，每个物品有重量和价值两个属性。其中第 i 个物品的重量为 wt[i]，价值为 val[i]，现在让你用这个背包装物品，最多能装的价值是多少？
举个简单的例子，输入如下：
N = 3, W = 4 wt = [2, 1, 3] val = [4, 2, 3] 算法返回 6，选择前两件物品装进背包，总重量 3 小于 W，可以获得最大价值 6。
题目就是这么简单，一个典型的动态规划问题。这个题目中的物品不可以分割，要么装进包里，要么不装，不能说切成两块装一半。这就是 0-1 背包这个名词的来历。
解决这个问题没有什么排序之类巧妙的方法，只能穷举所有可能，根据我们 动态规划详解 中的套路，直接走流程就行了。
动规标准套路 看来我得每篇动态规划文章都得重复一遍套路，历史文章中的动态规划问题都是按照下面的套路来的。
第一步要明确两点，「状态」和「选择」。
先说状态，如何才能描述一个问题局面？只要给几个物品和一个背包的容量限制，就形成了一个背包问题呀。所以状态有两个，就是「背包的容量」和「可选择的物品」。
再说选择，也很容易想到啊，对于每件物品，你能选择什么？选择就是「装进背包」或者「不装进背包」嘛。
明白了状态和选择，动态规划问题基本上就解决了，只要往这个框架套就完事儿了：
for 状态1 in 状态1的所有取值： for 状态2 in 状态2的所有取值： for ... dp[状态1][状态2][...] = 择优(选择1，选择2...) PS：此框架出自历史文章 团灭 LeetCode 股票问题。
第二步要明确 dp 数组的定义。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/83b18a765fc4b8be0f6d82fe554c7e70/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99727b8f3cb012f0dc07050e93af86db/" rel="bookmark">
			修改富文本的样式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用富文本可以参考微信开放文档， 必须使用&lt;rich-text&gt;&lt;rich-text&gt;这个标签，才能证明是富文本，还要搭配 nodes 这个属性，话不多说直接上例子。
obj.detailsDescription：这个是一个数组 ，接口参数是一个富文本。
不管用什么方式都修改不了图片的大小，但是接口里面有个class叫 wscnph,直接修改这个的样式就可以了， &lt;rich-text&gt;&lt;rich-text&gt;标签内不需要写任何东西，直接写在当前的wxss文件中即可修改成功。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12901bf55c0e06570ff9acc641b21cbb/" rel="bookmark">
			云计算技术基础【5】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. Raid1 是备份量极高的 Raid 策略，相应的他的保护能力也很强（）
A. 正确
B. 错误
2. Mapreduce适用于()
A. 任意应用程序
B. 任意可在windows servet2008上运行的程序
C. 可以串行处理的应用程序
D. 可以并行处理的应用程序
3. ( ) ：软件即服务。它是一种通过 Internet 提供软件的模式，用户无需购买软件，而是向提供商租用基于 Web 的软件，来管理企业经营活动。例如：我们现在手机里的各种应用型 APP 。
A. IaaS
B. PaaS
C. SaaS
D. DaaS
4. 数据中心的服务器按照类型可以分为塔式服务器、 （） 和刀片服务器这三大类。
A. 机架式服务器
B. 立式服务器
C. 卧式服务器
D. 一体式服务器
5. 在Bigtable中，（）主要用来存储子表数据以及一些日志文件
A. GFS
B. Chubby
C. SSTable
D. MapReduce
6. 在EC2的安全与容错机制中，一个用户目前最多可以创建（）安全组。
A. 50
B. 100
C. 150
D. 200
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/12901bf55c0e06570ff9acc641b21cbb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a92848afacbff9d763daadccceef19d/" rel="bookmark">
			数据库的基础了解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据库概述 1）什么是数据库
存储数据的仓库，本质上就是存储数据的文件系统。
数据会按照特定的格式存储起来，用户可以对该仓库的数据进行增加，修改，删除及查询操作。
2）数据库的优点
数据库是按照特定的格式将数据存储在文件中，通过SQL语句可以方便的对大量数据进行增、删、改、查操作，数据库是对大量的信息进行管理的高效的解决方案。
3）数据库管理系统（DBMS）
数据库管理系统（DataBase Management System，DBMS）：指一种操作和管理数据库的大型软件，用于创建、使用和维护数据库，对数据库进行统一管理和控制，以保证数据库的安全性和完整性。用户通过数据库管理系统访问数据库中表内的数据。
4）数据库管理系统、数据库和表的关系
数据库管理系统可以管理多个数据库，每个数据库中可以有多张数据库表。
5）常见数据库（dbms管理系统）
MYSQL：开源免费的数据库，小型的数据库。已经被Oracle收购了，MySQL6.x版本也开始收费。
Oracle：收费的大型数据库，Oracle公司的产品。
PostgreSQL：一个功能强大的开源对象关系型数据库系统。
介绍：https://blog.csdn.net/qq_40223688/article/details/89451616
DB2：IBM公司的数据库产品。收费的，常应用在银行系统中。
SQLServer：MicroSoft 公司收费的中型的数据库。C#、net等语言常使用。
SyBase：已经淡出历史舞台。提供了一个非常专业数据建模的工具PowerDesigner。
SQLite: 嵌入式的小型数据库，应用在手机端。
企业常用：MYSQL Oracle DB2（银行）
数据库表设计三范式 第一范式（1NF），原子性，列或者字段不能再分
第二范式（2NF），唯一性，一张表存储一类数据
第三范式（3NF），直接性，不存在传递依赖
事务技术 数据库的隔离级别 read uncommitted	读未提交	脏读、不可重复读、幻读都会发生 read committed(oracle默认)	读已提交	避免脏读的发生 repeatable read(mysql默认)	重复读	避免脏读和不可重复的读的发生 serializable	串行化 避免所有问题的发生 查询mysql的隔离级别
show variables like "%isolation%"; -- 结果：repeatable read 设置事务的隔离级别
set global transaction isolation level 级别字符串; 读未提交 (read uncommitted)：最低级别，以上情况均无法保证)
读已提交 (read committed)：可避免脏读情况发生
可重复读 (repeatable read)：可避免脏读、不可重复读情况的发生。 mysql的默认隔离级别
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a92848afacbff9d763daadccceef19d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b64b126fe142c9fbd761d035df63133/" rel="bookmark">
			oss大文件网页上传
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		支持超大文件上传，经过测试网页直传比java后台传速度快很多，亲测有效 js代码 &lt;script src="https://gosspublic.alicdn.com/aliyun-oss-sdk-6.0.2.min.js"&gt;&lt;/script&gt; &lt;script th:inline="javascript"&gt; var prefix = ctx + "web/ota" $("#form-ota-add").validate({ focusCleanup: true }); var upfiles = []; $(function () { //初始化文件上传队列 $("#firmware").change(function (e) { var ufiles = $(this).prop('files'); for (var i = 0; i &lt; ufiles.length; i++) { upfiles.push({ num: i, name: ufiles[i].name, file: ufiles[i] }) } console.log('upfiles:', upfiles); }) }) // 初始化加载client对象 为了不暴露自己的 accessKeyId 和 accessKeySecret需要请求接口去获取临时的 var appServer = 'http://192.168.110.136/web/ota/credential'; //请求接口获取数据 var bucket = '你的bucket名称'; // bucket名称 var region = 'oss-cn-shenzhen'; // 地区 var urllib = OSS.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b64b126fe142c9fbd761d035df63133/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/754a376e7d739f165302d7a0f83f0caa/" rel="bookmark">
			spark-submit提交Python程序，使用python zip环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		## yarn client hdfs文件 spark-submit \ --master yarn \ --deploy-mode cluster \ --driver-memory 1g \ --num-executors 3 \ --executor-memory 1g \ --executor-cores 1 \ --archives hdfs://hadoop102:8020/user/xxx/python_zips/pyspark_env.zip#my_env \ --conf spark.pyspark.driver.python=./my_env/pyspark_env/bin/python3.8 \ --conf spark.pyspark.python=./my_env/pyspark_env/bin/python3.8 \ /tmp/pycharm_project_455/helloworld.py --archives hdfs://hadoop102:8020/user/xxx/python_zips/pyspark_env.zip#my_env （一定要有#my_env，分发到yarn 容器中解压生成的目录名） python环境的zip包 上传到hdfs的用户目录下
zip -r pyspark_env.zip pyspark_env/
hdfs://hadoop102:8020/user/xxx/python_zips/pyspark_env.zip
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11273a8698d3f3bd82cb21e0f4af6b24/" rel="bookmark">
			共识算法学习总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 分布式系统简介 1.1 什么是分布式系统 分布式系统（distributed system）是建立在网络上的软件系统。在一个分布式系统中，一组独立的计算机展现给用户的是一个统一的整体，就好像是一个系统。系统拥有多种通用的物理和逻辑资源，可以动态的分配任务。分散的物理和逻辑资源通过计算机网络实现信息交换。通常，对用户来说，分布式系统只有一个模型或范型。在操作系统之上有一层软件中间件负责实现这个模型。一个著名的分布式系统的例子是万维网。
1.2 分布式系统应具备的能力 分布式系统作为一个逻辑整体，不应该返回错误的结果只要系统里的大部分机器工作正常，整个分布式系统就能有效运行，这也是分布式系统应用的一个优点，抵抗单点故障系统的性能是可以横向扩展的，对于分布式系统来说，木桶原理不起作用分布式系统必须是异步的，每个节点按照自己的时许独立工作，没有全序的时间顺序 1.3 分布式系统面临的问题 节点处理事务的能力不同，网络节点数据的吞吐量有差异节点间通讯的信道可能不安全系统中可能会出现恶意节点当异步处理能力达到高度一致时，系统的可扩展性就会变差（容不下新节点的加入） 1.4 FLP定理 FLP定理来源于Fischer、Lynch、Patterson三位作者于1985年发表的论文，之后该论文毫无悬念的获得了Dijkstra（狄克斯特拉）奖。FLP给出一个结论：在异步通信场景中，即使只有一个进程失败，也没有任何算法能保证非失败进程达到一致性。所以不要浪费时间去为异步分布式系统设计在任何场景下都能实现共识的算法。
1.5 CAP定理 在理论计算机科学中，CAP定理（CAP theorem），又被称作布鲁尔定理（Brewer’s theorem），它指出对于一个分布式计算系统来说，不可能同时满足以下三点：
一致性(Consistency)：所有节点在同一时间能够看到同样的数据.可用性(Availability)：确保每个请求都可以收到其是否成功的响应，并且是在有限的时间内。分区容错性(Partition tolerance)：因为网络故障导致的系统分区不影响系统正常运行。 既然不能同时满足，只有弱化对某个特性的支持：
弱化一致性：对于实时的强一致性不要有太高的要求弱化可用性：只要提高性能，保持可靠，尽量避免加载不必要的模块，也就是牺牲可用性弱化分区容错性：对于分布式系统，分区容错是必然的。区块链系统，尤其是公有链，用各种共识算法，优先解决的就是保证整个系统的容错能力 1.6 分布式系统一致性的要求 可终止性(Termination)：一致性的将结果可在有限时间内完成共识性(Consensus)：不同节点最终完成决策的结果应该相同合法性(Validity)：决策的结果必须是其它进程提出的提案。 1.7 分布式系统与区块链 区块链系统本质就是一个分布式系统。区块链结构是一种分布式架构。其部署模式有公有链、联盟链、私有链，对应的是去中心化分布式系统、部分去中心化分布式系统和弱中心化分布式系统。
2. 共识算法 2.1 定义 所谓的共识算法（共识机制），主要是为了解决分布式系统中，所有节点对于数据的一致性和有效性而指定的一系列规则。在分布式系统中，要保障系统满足不同程度的一致性，往往需要通过共识算法来达成。
2.2 分类 2.2.1 基于博弈论的共识算法 工作量证明： POW、POC、DAG权益证明：POS、DPOS、POA 2.2.2 基于分布式一致性原理的共识算法 崩溃容错(CFT)：PAXOS、RAFT、ZAB拜占庭容错(BFT)：PBFT、RBFT、HotStuff 基于分布式一致性原理的共识算法是面向数据库的，而基于博弈论的共识算法是面向交易的，所以严格来说，基于分布式一致性原理的共识算法应该处于基于博弈论的共识算法的下面一层。
2.3 共识算法的选择 在区块链网络中，由于应用场景不同，所设计的目标各异，不同的区块链系统采用了不同的共识算法。一般来说，在私有链和联盟链情况下，对一致性、正确性有很强的要求，一般采用强一致性的共识算法。而在公有链情况下，对一致性和正确性通常没法做到百分之百，通常采用最终一致性的共识算法。
3. 常见的共识算法 3.1 POW POW(Proof Of Work)，即工作量证明
原理 节点接收到交易数据时，不断得对交易数据进行哈希，求得一个指定的nonce值。当全网有一位节点计算出nonce值时，他就会把交易数据打包成区块并广播出去。其它节点收到区块后进行验证，验证通过后该区块就会被添加到区块链中。
在计算nonce的过程中会消耗大量时间和能源，以此来确保服务与资源是被真正的需求所使用。
优点 架构简明扼要、有效可靠。由于要获得多数节点承认，那攻击者必须投入超过总体一半的运算量（51%攻击），才能保证篡改结果。这使得攻击成功的成本变得非常高昂，难以实现。 缺点 挖矿的激励机制会造成矿池算力的高度集中，背离了当初去中心化设计的初衷 。PoW机制的共识达成的周期较长，每秒最多只能做7笔交易。非常浪费能源。投入在一种加密货币上的能源，可能会超过一个小型国家的总使用量。 3.2 POS POS(Proof Of Stake)，即股权证明。类似于财产存储在银行，这种模式会根据你持有数字货币的量和时间，分配给你相应的利息。
原理 在POS算法中，节点必须抵押数字货币才有打包区块的资格。算法在选定打包节点时使用随机的方式。但是节点被选为打包区块的节点与节点质押的数字货币数量及拥有数字货币的时长有很大的关系。节点成功打包一个区块后，其质押的币龄就会被清空，每被清空365币龄就会得到一些利息。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/11273a8698d3f3bd82cb21e0f4af6b24/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7abcf30b0afb4459b4376c1587f8ec8/" rel="bookmark">
			Python实现：P5724 【深基4.习5】求极差 / 最大跨度值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 题目源代码思路numpy.maxnumpy.min 题目 源代码 #法1：利用列表性质求 n = int(input()) list = list(map(int, input().split())) list.sort() max = list[-1] min = list[0] print(max - min) #法2：利用numpy求最大最小值函数 import numpy as np n = int(input()) list = list(map(int, input().split())) max = np.max(list) min = np.min(list) print(max - min) 思路 法1利用sort函数将列表升序排列，则最大值是列表的最后一个，可使用反向索引求得；最小值是第一个，因此用正向索引求。反向索引第一个是-1，正向索引 索引开始是0（Python学习笔记七中有讲）。
法2利用numpy的max和min函数直接得到最大值最小值。
最后用最大值减去最小值即可得到极差。
numpy中文快速入门教程
numpy.max numpy.min 以上截图来自The Python Standard Library » Built-in Functions
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd942b931bfd202385a9a21c58c7b18c/" rel="bookmark">
			小程序全局变量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一，前言 1.小程序的总体设计是以页面为一个基本单位，数据也是隶属于一个页面，因此不同页面之间的data数据不能相互访问。
二，全局变量globalData 1.在小程序中入口文件app.js中，字段globalData定义的数据代表了全局变量，可以在其他页面访问和修改。
2.在其他页面中使用全局变量
var app = getApp() //获取全局app实例 app.globalData.xxx //访问 app.globalData.xxx='hello miniapp' //修改 3.全局变量是所有页面共享的，一个页面修改了，另外一个页面访问时也会做相应的修改
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/168dc7b93bc0a75e9cf8f5ed60c9cc54/" rel="bookmark">
			python中的数据类型之字符串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.大小写转换函数
2.查找替换函数
3.判断函数
4.头尾判断函数
5.计算函数
6.对齐函数
7.拆分合并函数
8.删除字符串中的空格函数（里面都没有参数）
前言
本文章主要是Python中字符串常用操作符和处理函数一些知识点
1.大小写转换函数 函数名功能描述lower()将字符串中的大写字符转换为小写upper()将字符串中的小写字符转换为大写capitalize()将字符串中的第一个字符转换为大写swapcase()将字符串中的大小写字符相互转换 用法示例
a = 'abcEDFG' print(a.lower()) # 全部转换为小写 print(a.upper()) # 全部转换为大写 print(a.capitalize()) # 只转首字母为大写 print(a.swapcase()) # 大小写相互转换 2.查找替换函数 函数名功能描述find(str , start , end)查找“str”是否在字符串中，可以指定位置进行查找，若包含返回该字串的下标值，如果不包含则返回值为 -1index(str , start , end)跟find()一样，若str不存在时，则报告错误lfind(str , start , end)类似于fun()，从左侧开始查找，返回str最后一次出现的索引值rindex(str , start , end)类似于index，从右侧开始查找，返回str最后一次出现的索引值replace(old, new , count)将字符串中的old替换为new，如果指定了count，则替换不超过count次 用法示例 a ="I'm python chengxuyuan" print(a.find('o')) print(a.index('c')) print(a.replace('p','i')) 3.判断函数 函数名功能描述isalnum()如果字符串至少包含有一个字符（空格也算），并且所有字符都是字母或数字则返回True，否则返回Falseisalpha()如果字符串至少包含有一个字符，并且所有字符都是字母，则返回True，否则返回Falseisdigit()如果字符串只包含数字，则返回True，否则返回Falseislower()如果字符串至少包含一个区分大小写的字符并且所有这些（区分大小写的）字符都是小写，则返回True，否则返回Falseisnumeric如果字符串中只包含数字字符，则返回True，否则返回Falseisspace()如果字符串中只包含空白，则返回True，否则返回Falseisupper()如果字符串中至少包含一个区分大小写的字符并且所有这些区分大小写的字符都是大写，则返回True，否则返回Falseisdecimal()如果字符串中只包含10进制字符，则返回True，否则返回False 4.头尾判断函数 函数名描述用法startswith(str , start , end)检查字符串是否以str而开头，如果是则返回True，否则返回Falsevarname.函数名()endswith(str , start , end)检查字符串是否以str而结尾，如果是则返回True，否则返回False 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/168dc7b93bc0a75e9cf8f5ed60c9cc54/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e9f692e56a24066acaf0a84e77bf93e/" rel="bookmark">
			2022 年，把 Python 学得跟 Java 一样熟练——02 类定义
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 今天学会了 Python 的类定义，创建一个 Person 类，包含姓名、生日、地址三个成员变量和对应的 getter 和 setter 方法。
本文实践了类的定义、引用的方法，对比了与 Java 的类的语法的差异，知识点：
构造函数、方法的限制。类的引用。 实践编码 # -*- coding: UTF-8 -*- ''' 一个 Person 类 1、姓名 2、生日 3、地址 4、属性的 getter 和 setter 方法 ''' class Person(): def __init__(self,name,birthday,address): self.name = name self.birthday = birthday self.address = address def getName(self): return self.name def setName(self,name): self.name = name def getBirthday(self): self.birthday def setBirthday(self,birthday): self.birthday=birthday def crt(self): return 'crt' def getAddress(self): return self.address def getPersonInfo(self): return self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e9f692e56a24066acaf0a84e77bf93e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ad7dbeb6916e50a4b3828110c049857/" rel="bookmark">
			uos（通信）安装opencv
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、准备python环境2、先安装numpy包，因为一会需要3、下载opencvwhl文件 找了很多教程发现都不行，因为我用的是官网的uos家庭版，所以就安装不了。下面我就把我的安装成功经验发在这里供大家参考。 1、准备python环境 python安装可以参考这篇博客，如果你已经安装好了，那就直接跳过
python安装3.9
2、先安装numpy包，因为一会需要 安装命令pip3 install numpy
3、下载opencvwhl文件 我会直接上传我的whl文件，当然大家也可以自己找，一会我给大家说怎么找。我的whl文件资源连接在此
资源是免费的，如果需要积分下载，大家可以私聊我。
下面我告诉大家怎么自己找
1、使用命令pip3 install opencv-python
然后会自动下载
标红的地方就是下载的资源包，不过很多时候会下载出错，因为包比较大。
2、然后大家可以复制这个whl文件的名称，到百度进行搜索
3、搜索成功过后，可以找到这个文件，大家可以在本机或者网络环境比较好的地方下载这个文件，然后将其拖入uos虚拟机中，然后在whl文件所在的文件夹中打开终端，使用命令pip3 install 【你下载的whl文件名称，记住带whl后缀】，然后就会发现安装成功。
如果没有安装成功，原因是因为有包没下载，例如：numpy。使用命令pip3 install XX安装即可。
4、然后在python命令行中使用
import cv2; print(cv2.__version__) 成功后就会输出版本号。
如果还有问题，可以留言或者私聊。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2b327713f8d8340e53130ac5b10a535/" rel="bookmark">
			内网信息收集(超级全)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		内网信息收集
文章首发与奇安信攻防社区 https://forum.butian.net/share/236
简介
在渗透测试中信息收集的深度与广度以及对关键信息的提取，直接或间接的决定了渗透测试的质量，所以信息收集的重要性不容小觑，看得懂并不代表会，不如自己实操一遍，这里将提供一个单域的环境下载地址，进行信息收集。
单域环境
这张图为这次信息收集所搭建的单域内网环境。
工作组与域环境比较
工作组是一群计算机的集合，它仅仅是一个逻辑的集合，各自计算机还是各自管理的，你要访问其中的计算机，还是要到被访问计算机上来实现用户验证的。而域不同，域是一个有安全边界的计算机集合，在同一个域中的计算机彼此之间已经建立了信任关系，在域内访问其他机器，不再需要被访问机器的许可了。为什么要区分呢？因为这两种环境攻击的手法不同，ARP欺骗、DNS欺骗只在工作组有效。
基本网络框架组成
dmz
在实际的渗透测试中，大多数情况下，在web环境中拿到的权限都在dmz中。这个区域不属于严格意义上的内网。如果访问控制策略配置合理，dmz就会处在从内网能够访问DMz，而从dmz访问不能进入内网的状态。
内网
内网中包括很多服务器、办公电脑等，办公区的安全防护水平通常不高，基本的防护机制大多数为杀毒软件或主机入侵检测产品。服务器、域控制器的防护比较强，我们主要的目标是要拿下域控制器，要拿下域控前期的信息收集就显得格外重要。
AD域控制器一般只在Windows server系统
linux一般很少会被当成域控制器，因为管理起来特别麻烦，功能也比较少，不过linux上也有相应的活动目录的，可是要装LDAP这个环境，一般企业很少会用LDAP来管理的，功能上不及域强大，而且用linux来管理的话要求技术人员门槛也比较高。而windows作为域控制器有图形化界面，能够很好的进行管理。
信息收集
基本信息收集
目的:为了了解当前服务器的计算机基本信息、防护的强弱，为后续判断服务器角色、网络环境做准备。
systeminfo查看计算机版本、补丁编号等信息
net start查看启动的服务
tasklist查看进程列表
schtasks /query /fo LIST /v查看目标主机上的计划任务信息
schtasks查看计划任务
SPN：服务主体名称。使用Kerberos须为服务器注册SPN，因此可以在内网中扫描SPN，快速寻找内网中注册的服务，SPN扫描可以规避像端口扫描的不确定性探测动作。主要利用工具有：setspn。利用Windows自带的setspn工具，普通域用户权限执行即可：
setspn -T rootkit.org -Q */* 可以发现内网存在mssql等服务
powershell "Get-WmiObject -class Win32_Product |Select-Object -Property name,version" 系统命令查看安装软件的版本信息
nltest /domain_trusts 获取域信任列表信息
或者使用wmic product get name.version命令
wmic service list brief获取本机服务信息，查看是否有可以可以进行深入利用的点
netsh firewall show config查看防火墙的配置信息
wmic nteventlog get path,filename,writeable查看是否能修改删除日志
网络信息收集 目的：为了了解当前服务器的网络接口信息，为判断当前拿下的主机角色、功能、熟悉网络架构，获取当前内网的存活主机做准备。
ipconfig /all 判断存在域-dns 有域的有dns后缀，无域的无dns后缀
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e2b327713f8d8340e53130ac5b10a535/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61b5d601ac908b70b7d88496f114bfab/" rel="bookmark">
			大数据技术【8】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.以下哪个不属于大数据技术的特征（）。
A.全面分析数据
B.重视数据的复杂性
C.随机抽样
D.关注数据的相关性
2.许多公司利用大数据技术来收集海量数据、训练模型、优化模型，并发布预测模型来提高业务水平或者避免风险，这是大数据在（）的技术。
A.数据校验
B.预测分析
C.数据整合
D.知识搜索
3.（）是在已知各种情况发生概率的基础上，通过构成树状结构来求取净现值的期望值大于等于零的概率，评价项目风险，判断其可行性的决策分析方法，是直观运用概率分析的一种图解法。
A.文本树
B.决策树
C.哈夫曼树
D.生成树
4.现在非结构化数据大约占人类数据总量的25%。。
5.如下哪个不是最近邻分类器的特点。（）
A.可以生产任意形状的决策边界
B.分类一个测试样例开销很大
C.它使用具体的训练实例进行预测，不必维护源自数据的模型
D.最近邻分类器基于全局信息进行预测
6.以下哪些算法是分类算法（）。
A.DBSCAN
B.EM
C.C4.5
D.K-Means
7.Kmeans算法包括如下步骤：①在第j次迭代中，对于每个样本点，选取最近的中心点，归为该类；②更新中心点为每类的均值；③随机选取k个中心点；④j选择一项：a.③①②④b.①④③②c.①②③④d.④③②①
A.③①②④
B.①④③②
C.①②③④
D.④③②①
8.（）反映数据的精细化程度，越细化的数据，价值越高。
A.规模
B.活性
C.颗粒度
D.关联度
9.（）是研究两个或两个以上处于同等地位的随机变量相关性的统计分析方法，包括变量之间是否存在依存关系，存在什么样的依存方向等等。
A.判别分析
B.回归分析
C.相关分析
D.主成分分析
10.以下哪个属于非关系型数据库（）。
A.SQL
B.Access
C.MonogoDB
D.Mysql
11.大数据的（）指数据能够被组织并呈现。借助于图形化手段，清晰有效地传达和沟通信息。基于数据，借助可视化手段提高大脑利用率。
A.可视化
B.多样性
C.大量性
D.低价值密度
12.C4.5是一种决策树的算法。
13.建立一个模型，通过这个模型根据已知的变量值来预测其他某个变量值属于数据挖掘的哪一类任务？
A.根据内容检索
B.寻找模式和规则
C.预测建模
D.建模描述
14.()的目的缩小数据的取值范围，使其更适合于数据挖掘算法的需要，并且能够得到和原始数据相同的分析结果。
A.数据归约
B.数据变换
C.数据清洗
D.数据集成
16.（）框架由一个单独的masterJobTracker和每个集群节点一个slaveTaskTracker共同组成。
A.master
B.Reduce
C.Map/Reduce
D.Map
17.以下哪一项不属于Hadoop可以运行的模式（）。
A.互联模式
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61b5d601ac908b70b7d88496f114bfab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1b649bf3807f23b9a2f436708bf0052/" rel="bookmark">
			2022如何平衡固定资产的预算？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 2021年，企业者们经历了风风雨雨，踏平了坎坷，坚持过来了。企业者们紧衣缩食熬过了2021，但2022的开年形势依旧复杂。大环境下的不确定性变化，也更加增强了企业者们要把每一笔预算都用在刀刃上的决心。固定资产是企业运营的主要因素和企业支出的重要部分。固定资产管理的好坏，直接影响到企业的预算。经过调查发现，一款有效的固定资产管理统可助力企业实现降本增效。
新年伊始，面对新的市场形势，企业对固定资产管理的需求呈现在以下几个方面：
1）降低人员的频繁面对面接触，降低疫情风险
疫情的小规模反弹时有发生，防疫常态化已成为社会各界共识。企业管理应尽量减少员工面对面办公接触，保障员工的办公安全。
2）避免固定资产的重复采购，降低闲置率 每年企业都会在固定资产的采购商投入一些预算。如果资产管理的账目不清楚，企业者无法统筹管理固定资产并了解情况后在进行采购，会给企业资源带来浪费。比如资产数据没有更新，或者数据有遗漏等。重复采购增加企业支出，给企业带来损失。
3）固定资产盘点耗时较长，准确率低
年底或者年中的固定资产盘点是一项大工程，不但耗时耗力，而且最后盘点的账实总是不一致，结果并不准确，还有一些损毁的固定资产找不到责任人不好追责。给企业带来损失，拉高了经营成本。
面对以上固定资产管理的需求，易点易动固定资产管理系统可直击用户痛点，提供完美的解决方案，让企业的固定管理不再困难，降低企业的固定资产预算。
1）PC端+APP移动端操作，无接触办公更安全
易点易动系统作为固定资产管理云系统的主力军，较早在业内推出PC+APP结合使用的操作方式，无论大小场景的固定资产管理和盘点，管理员可在手机APP进行固定资产管理、盘点、审批等操作。员工可盘点和查看自己名下的固定资产，也可以申请领用、借用、交接固定资产等。收货后直接在员工端签字，也可以参与审批等，整个流程不需要面对面操作，减少员工的面对面接触，无接触式办公能够有效提高企业的安全系数。
2）企业的固定资产一目了然，避免重复采购和闲置
易点易动系统中有近20种固定资产的分析报表，可展示每个资产目前的状态，有多少资产在使用中，有多少资产是闲置的，每个部门或者员工名下有多少个固定资产等。便于企业的管理员和企业管理者掌握所有资产情况，提升固定资产的利用率，避免重复采购。
3）固定资产的流失和损毁责任到人，拒绝互相推诿
易点易动系统实行“一物一码”的管理模式，即每个固定资产录入系统后，都绑定一个独一无二的二维码。固定资产的每一次流转的数据都会同步到系统中，流转的记录不能删除。所有固定资产履历都一目了然。固定资产的使用人，使用部门一目了然。在固定资产盘点时再遇到损坏和丢失时，管理员可找到责任人，减少企业损失。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3de4cc5ea3de0e196d31cece9fecf3fe/" rel="bookmark">
			互联网架构三高之高可用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 高可用（High availability，即 HA）的主要目的是为了保障「业务的连续性」，即在用户眼里，业务永远是正常（或者说基本正常）对外提供服务的。高可用主要是针对架构而言，那么要做好高可用，就要首先设计好架构，第一步我们一般会采用分层的思想将一个庞大的 IT 系统拆分成为应用层，中间件，数据存储层等独立的层，每一层再拆分成为更细粒度的组件，第二步就是让每个组件对外提供服务，毕竟每个组件都不是孤立存在的，都需要互相协作，对外提供服务才有意义。
要保证架构的高可用，就要保证架构中所有组件以及其对外暴露服务都要做高可用设计，任何一个组件或其服务没做高可用，都意味着系统存在风险。
那么这么多组件该怎么做高可用设计呢，其实任何组件要做高可用，都离不开「冗余」和「自动故障转移」，众所周知单点是高可用的大敌，所以组件一般是以集群（至少两台机器）的形式存在的，这样只要某台机器出现问题，集群中的其他机器就可以随时顶替，这就是「冗余」。简单计算一下，假设一台机器的可用性为 90%，则两台机器组成的集群可用性为 1-0.1*0.1 = 99%，所以显然冗余的机器越多，可用性越高。
但光有冗余还不够，如果机器出现问题，需要人工切换的话也是费时费力，而且容易出错，所以我们还需要借助第三方工具（即仲裁者）的力量来实现「自动」的故障转移，以达到实现近实时的故障转移的目的，近实时的故障转移才是高可用的主要意义
怎样的系统可以称之为高可用呢，业界一般用几个九来衡量系统的可用性，如下
一般实现两个 9 很简单，毕竟每天宕机 14 分钟已经严重影响业务了，这样的公司迟早歇菜，大厂一般要求 4 个 9，其他要求严苛的业务要达到五个九以上，比如如果因为一个电脑的故障导致所有列车停驶，那么就会有数以万计的人正常生活受到阻碍，这种情况就要求五个九以上
接下来我们就来一起看看架构中的各个组件如何借助「冗余」和「自动故障转移」来实现高可用。
二、互联网架构剖析 目前多数互联网都会采用微服务架构，常见架构如下:
可以看到架构主要分以下几层
接入层：主要由 F5 硬件或 LVS 软件来承载所有的流量入口
反向代理层：Nginx，主要负责根据 url 来分发流量，限流等
网关：主要负责流控，风控，协议转换等
站点层：主要负责调用会员，促销等基本服务来装配 json 等数据并返回给客户端
基础 service：其实与站点层都属于微服务，是平级关系，只不过基础 service 属于基础设施，能被上层的各个业务层 server 调用而已
存储层：也就是 DB，如 MySQL，Oracle 等，一般由基础 service 调用返回给站点层
中间件：ZK，ES，Redis，MQ 等，主要起到加速访问数据等功能，在下文中我们会简单介绍下各个组件的作用
如前所述，要实现整体架构的高可用，必须要实现每一层组件的高可用，接下来我们就来分别看一下每一层的组件都是如何实现高可用的。
三、接入层与反向代理层 这两层的高可用都和 keepalived 有关，所以我们结合起来一起看
对外，两个 LVS 以主备的形式对外提供服务，注意只有 master 在工作（即此时的 VIP 在 master 上生效），另外一个 backup 在 master 宕机之后会接管 master 的工作，那么 backup 怎么知道 master 是否正常呢，答案是通过 keepalived，在主备机器上都装上 keepalived 软件，启动后就会通过心跳检测彼此的健康状况，一旦 master 宕机，keepalived 会检测到，从而 backup 自动转成 master 对外提供服务，此时 VIP 地址（即图中的 115.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3de4cc5ea3de0e196d31cece9fecf3fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b96c4824c657260d86b5bd3ff752f506/" rel="bookmark">
			外网主机访问内网（宿主机的虚拟机）方法总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		桥接模式 桥接模式相当于把虚拟机接出到和宿主机同样的路由器下，即在一个局域网内，这种情况下，其它电脑可以直接ssh虚拟机的ip即可远程访问（关闭防火墙）
NAT模式 桥接模式会存在占用其它ip的缺陷，比如我再实验室就会存在ip冲突导致集群有时候会莫名其妙挂掉。因此使用NAT模式是很好的选择，NAT模式下的原理如下图所示：
虚拟机集群此时相当于在内网中，因此当外网想要访问宿主机里的虚拟机时，可以通过端口转发的功能。比如我把第一台虚拟机的22号端口映射到主机的76号端口，这样外网其它机器只需访问宿主机的76号端口即可ssh连接宿主机的虚拟机了。
3.VPN模式
通过在物理机上设置VPN，给连接进来的及其设置和虚拟机集群一个网段的ip，从而实现外网和内部集群的通信，win10操作如下：
点击文件新建传入连接，设置用户名和密码（外网访问时输入）
ip段从2开始，和虚拟机在一个网段
其它客户端连接这个vpn步骤
之前遇到过其它电脑能连上，但自己的笔记本一直连不上，报错及解决方法如下：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a01ef64803e7aecbc67f49bded94e46/" rel="bookmark">
			第一个Java程序——HelloWorld
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开始我的Java基础复习之路！！！
就从每个初学者都要经历的Hello World开始吧
我写过html，JavaScript，C，C#的helloworld，也可以说是精通各种语言的字母拼写了，但是我还是感觉java的Hello World最好看
下面进入正题，开始我们的第一个java程序：
首先，类名要与文件名一致（这个和C#有点像），也就是第一行的HelloWorld
然后，程序都是从main方法开始的，所以编写一个main方法，注意这里是静态的（其实也不用注意，因为固定这么写的，把这一行多敲几遍就记下来了）
最后到，输出语句，意思是把这句"HelloWorld"在控制台打印出来
public class HelloWorld { public static void main(String[] args) { System.out.println("HelloWorld"); } } 附带一张运行截图：
至此，我们的第一个java程序就完成啦！结尾撒花！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/285ba90bddcf055a455979a8182053fb/" rel="bookmark">
			013:魔兽世界之一：备战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		北大mooc，程序设计与算法（三）
题目 描述
魔兽世界的西面是红魔军的司令部，东面是蓝魔军的司令部。两个司令部之间是依次排列的若干城市。
红司令部，City 1，City 2，……，City n，蓝司令部
两军的司令部都会制造武士。武士一共有 dragon 、ninja、iceman、lion、wolf 五种。每种武士都有编号、生命值、攻击力这三种属性。
双方的武士编号都是从1开始计算。红方制造出来的第n个武士，编号就是n。同样，蓝方制造出来的第n个武士，编号也是n。
武士在刚降生的时候有一个生命值。
在每个整点，双方的司令部中各有一个武士降生。
红方司令部按照iceman、lion、wolf、ninja、dragon的顺序循环制造武士。
蓝方司令部按照lion、dragon、ninja、iceman、wolf的顺序循环制造武士。
制造武士需要生命元。
制造一个初始生命值为m的武士，司令部中的生命元就要减少m个。
如果司令部中的生命元不足以制造某个按顺序应该制造的武士，那么司令部就试图制造下一个。如果所有武士都不能制造了，则司令部停止制造武士。
给定一个时间，和双方司令部的初始生命元数目，要求你将从0点0分开始到双方司令部停止制造武士为止的所有事件按顺序输出。
一共有两种事件，其对应的输出样例如下：
武士降生
输出样例： 004 blue lion 5 born with strength 5,2 lion in red headquarter
表示在4点整，编号为5的蓝魔lion武士降生，它降生时生命值为5，降生后蓝魔司令部里共有2个lion武士。（为简单起见，不考虑单词的复数形式）注意，每制造出一个新的武士，都要输出此时司令部里共有多少个该种武士。
司令部停止制造武士
输出样例： 010 red headquarter stops making warriors
表示在10点整，红方司令部停止制造武士
输出事件时：
首先按时间顺序输出；
同一时间发生的事件，先输出红司令部的，再输出蓝司令部的。
输入
第一行是一个整数，代表测试数据组数。
每组测试数据共两行。
第一行：一个整数M。其含义为， 每个司令部一开始都有M个生命元( 1 &lt;= M &lt;= 10000)。
第二行：五个整数，依次是 dragon 、ninja、iceman、lion、wolf 的初始生命值。它们都大于0小于等于10000。
输出
对每组测试数据，要求输出从0时0分开始，到双方司令部都停止制造武士为止的所有事件。
对每组测试数据，首先输出"Case:n" n是测试数据的编号，从1开始 。
接下来按恰当的顺序和格式输出所有事件。每个事件都以事件发生的时间开头，时间以小时为单位，有三位。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/285ba90bddcf055a455979a8182053fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e270ba67f4639cefadede703413565e0/" rel="bookmark">
			redis优化，bigkey，hotkey，配置优化，缓存雪崩、缓存穿透、缓存击穿
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CPU绑定 可以在redis启动的时候绑定固定的cpu，防止cpu切换引起的上线文切换：
taskset -c 1 ./redis/bin/redis-server ./reids/conf/redis.conf redis6中开启多线程 redis.conf配置如下：
# 8核cpu可以并行6个 io-threads 6 内存碎片清理 所谓内存碎片，是指申请连续的一段内存空间，系统会找到一块符合申请大小的内存空间，但是如果开始申请了12KB的大小，然后回收，后续如果申请都大于12KB，那么这12KB空间无法被分配，相当于浪费了，redis中有自己的内存碎片整理机制，配置如下：
#内存碎片清理开关 activedefrag yes #内存碎片达到多大的时候开始清理 active-defrag-ignore-bytes 100mb #内存碎片占总内存达到多少百分比的时候开始清理 active-defrag-threshold-lower 10 #当内存碎片率达到多少时开启最大清理 active-defrag-threshold-upper 100 #清理内存碎片占用CPU时间的比例不低于此值开始清理 active-defrag-cycle-min 5 #清理内存碎片占用cpu时间比例不高于此值，如果超过，停止清理 active-defrag-cycle-max 75 系统swap linux中swap类似虚拟内存，当物理内存不够的时候，会把内存中不活跃跌数据置换到硬盘上，释放一部分物理内存，swappiness表示swap的占比，如果是0表示积极的使用物理内存
# cat /proc/sys/vm/swappiness 60 可以设置为 1：
echo 1 &gt; /proc/sys/vm/swappiness echo vm.swappiness=1 &gt;&gt; /etc/sysctl.conf TCP backlog #表示每个端口上半连接监听最大队列长度 $ cat /proc/sys/net/ipv4/tcp_max_syn_backlog 1024 #表示每个端口上已经建立连接监听的最大监听队列长度 $ cat /proc/sys/net/core/somaxconn 128 redis中默认的tcp-backlog=511 ，表示最大TCP全连接队列为511。一般在Linux下，对于一个TCP的连接的最大数量有两个方面：
一个是系统能够打开的最大句柄数另外一个就是上面说的backlog，redis这里是指已经建立连接的队列大小 内存分配控制 cat /proc/sys/vm/overcommit_memory 0 vm.overcommit_memory设置overcommit的内存分配策略，它有三个可选值
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e270ba67f4639cefadede703413565e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e62ec60082a6993c81848aadf2523b20/" rel="bookmark">
			让Spring的FactoryBean成为真正的万能Bean工厂
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简述创建Bean的普通方式 创建Spring config的xml配置文件，在此配置文件中对bean进行定义，如：
&lt;!--配置Bean,目的是让spring帮我们创建java对象。一个bean标签创建一个对象 id属性：配置一个唯一的标识 class属性：设置类的全类名，spring利用反射创建对象--&gt; &lt;bean id="helloWorld" class="spring.HelloWorld"&gt; &lt;!--设置属性值 name的值为setXXX中的XXX--&gt; &lt;property name="name" value="Spring"&gt;&lt;/property&gt; &lt;/bean&gt; 其中，class = "spring.HelloWorld"固定了此bean的类型为HelloWorld类型的。验证如下：
public class HelloWorldDemo { @Test public void testHelloWorld() { //1、创建IOC容器对象 ClassPathXmlApplicationContext ioc = new ClassPathXmlApplicationContext("applicationContext.xml"); //2、从IOC容器中获取HelloWorldI对象 /*方式一*/ Object object = ioc.getBean("helloWorld"); System.out.println("object.getClass() = " + object.getClass()); //输出结果：object.getClass() = class spring.HelloWorld /*方式二*/ HelloWorld helloWorld1 = ioc.getBean("helloWorld", HelloWorld.class); System.out.println("helloWorld1.getClass() = " + helloWorld1.getClass()); //输出结果：helloWorld1.getClass() = class spring.HelloWorld } } 使用FactoryBean创建万能Bean FactoryBean的源码非常简单，其中包含两个抽象方法和一个默认方法。其中getObject()方法用于获取实例，即创建bean，当xml配置文件中bean标签的class属性为FactoryBean的实现类是，使用getBean()方法获取bean时会调用该方法来创建，相当于getObject()代理了getBean()；getObjectType()方法用于获取bean的类型。
package org.springframework.beans.factory; import org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e62ec60082a6993c81848aadf2523b20/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/495ed56edb6c565dc384a354115c142f/" rel="bookmark">
			hidl注册相关流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		hidl在注册过程中通常在Manifest.xml中完成，在部分Android系统版本中，会额外产生product_compatibility_martix.xml,新增的xml需要和Manifest.xml相匹配才会使build pass,否则会出现The following instances are in the device manifest but not specified in framework compatibility matrix 的相关错误，因此在出现此情况时可查看此处是否有异常
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/983febc9c43f75a5e8c34b8f0a844426/" rel="bookmark">
			statemodels 笔记： lowess
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		机器学习笔记：局部加权回归 LOESS_UQI-LIUWJ的博客-CSDN博客
1 基本使用方法 statsmodels.nonparametric.smoothers_lowess.lowess( endog, exog, frac=0.6666666666666666, it=3, delta=0.0, xvals=None, is_sorted=False, missing='drop', return_sorted=True) LOWESS (Locally Weighted Scatterplot Smoothing) 局部加权回归
2 参数说明 endog 一维ndarray
观测点的y值
exog 一维ndarray
观测点的x值
frac 0到1之间的float型数据
估计每个 y 值时使用的数据比例。（用这个范围内的点进行局部加权回归）
it进行几轮局部加权回归delta float型数据
间隔多少进行一次局部参数回归（中间的点使用线性插值）
is_sorted 布尔型数据
如果为 False（默认），则数据将在计算 lowess 之前按 exog 排序。 如果为 True，则假定数据已按 exog 排序。 如果指定了 xvals，那么如果 is_sorted 为 True，则也必须对其进行排序。
missing 可用选项为“none”、“drop”和“raise”。
如果为“none”，则不进行 nan 检查。
如果“drop”，则任何带有 nan 的观察都将被删除。
如果“raise”，则nan会引发错误。
默认为“drop”。
return_sorted 布尔型变量
如果为 True（默认），则返回的数组按 exog 排序，并删除了缺失的（nan 或无限）观察。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/983febc9c43f75a5e8c34b8f0a844426/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4ae1cef6a265c36ddcd0f83ab88df30/" rel="bookmark">
			BurpSuite下载CA证书
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用Burp Suite做安全测试，抓取https包时，需要安装CA证书。
1、下载证书
首先打开BurpSuite，在Proxy-&gt;Options下设置代理ip、端口
然后设置浏览器的代理服务，现在借助的是Firefox浏览器设置代理：打开浏览器的设置-&gt;网络设置-&gt;设置-&gt;配置访问互联网的代理服务器-&gt;手动配置代理-&gt;HTTP代理-&gt;设置地址与端口，需要与上面BurpSuite设置保持一致。
都设置完成后，在FireFox浏览器中输入“http://burp”，出现以下界面，点击右上角的CA Certificate即可下载证书。 2、安装证书
点击FireFox浏览器的设置-&gt;隐私与安全-&gt;证书-&gt;查看证书-&gt;证书颁发机构-&gt;导入证书。
在证书管理中查看，已经有该证书了，安装成功！
然后重启FireFox浏览器和BurpSuite，即可成功抓取https的包了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e14ebd27ea6754fb0f8bb0f2d071fb3/" rel="bookmark">
			blast命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		蛋白质序列比对蛋白质数据库（blastp）
blastp -query seq.fast -out seq.blast -db dbname -outfmt 6 -evalue 1e-5 -num_des
criptions 10 -num_threads 8
核酸序列比对核算数据库（blastn）
blastn -query seq.fasta -out seq.blast -db dbname -outfmt 6 -evalue 1e-5 -num_descriptions 10 -num_threads 8
核酸序列比对蛋白质数据库（blastx）
blastx -query seq.fasta -out seq.blast -db dbname -outfmt 6 -evalue 1e-5 -num_descriptions 10 -num_threads 8
参数：
-query： 输入文件路径及文件名
-out：输出文件路径及文件名
-db：格式化了的数据库路径及数据库名
-outfmt：输出文件格式，总共有12种格式，6是tabular格式对应BLAST的m8格式
-evalue：设置输出结果的e-value值
-num_descriptions：tabular格式输出结果的条数
-num_threads：线程数
创建索引数据库
makeblastdb -in mouse.faa -dbtype nucl -input_type fasta -out dna
参数：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e14ebd27ea6754fb0f8bb0f2d071fb3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f3995f7f1d086e6ffa9594f06c73691/" rel="bookmark">
			Google 引爆大数据时代的三篇论文-《GFS》、《BigTable》、《MapReduce》
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大数据起源于-谷歌，于2003年起发布一系列论文（大数据三驾马车）:
1. 《The Google File System 》
2. 《MapReduce: Simplified Data Processing on Large Clusters》在大型集群中简化数据处理
3.《Bigtable: A Distributed Storage System for Structured Data》结构化数据的分布式存储系统
1 、GFS GFS 是一个大型的分布式文件系统。一个面向大规模数据密集型应用的、可伸缩的分布式文件系统。 为 Google 大数据处理系统提供海量存储，并且与 MapReduce 和 BigTable 等技术结合得十分紧密，处于系统的底层。
GFS 的系统架构如图 所示，主要由一个 Master Server（主服务器）和多个 Chunk Server（数据块服务器）组成。
Master Server 主要负责维护系统中的名字空间，访问控制信息，从文件到块的映射及块的当前位置等元数据，并与 Chunk Server 通信。
Chunk Server 负责具体的存储工作。数据以文件的形式存储在 Chunk Server 上。Client 是应用程序访问 GFS 的接口。
Master Server 的所有信息都存储在内存里，启动时信息从 Chunk Server 中获取。这样不但提高了 Master Server 的性能和吞吐量，也有利于 Master Server 宕机后把后备服务器切换成 Master Server。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f3995f7f1d086e6ffa9594f06c73691/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e1fd42e1825d13dbb2572a9dda2e7b9/" rel="bookmark">
			K8S中service与controller(控制器)通过标签选择器(selector)匹配pod
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.1 当前k8s的环境1.2 创建sc名称空间1.3 通过实践理解1.4 deployment控制器部署pc-erp-frontend 项目1.5 daemonset控制器部署m-erp-frontend项目 1.1 当前k8s的环境 ### 当前k8s的运算节点 [root@hdss7-21 ~]# [root@hdss7-21 ~]# kubectl get node NAME STATUS ROLES AGE VERSION hdss7-21.host.com Ready master,node 40h v1.15.2 hdss7-22.host.com Ready master,node 40h v1.15.2 ### 当前k8s的名称空间 [root@hdss7-21 ~]# [root@hdss7-21 ~]# kubectl get ns NAME STATUS AGE default Active 2d3h kube-node-lease Active 2d3h kube-public Active 2d3h kube-system Active 2d3h 1.2 创建sc名称空间 [root@hdss7-21 ~]# kubectl create ns sc namespace/sc created [root@hdss7-21 ~]# [root@hdss7-21 ~]# kubectl get ns sc NAME STATUS AGE sc Active 3s 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e1fd42e1825d13dbb2572a9dda2e7b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6c2b013cc55a98c688beff8ba9b6d81/" rel="bookmark">
			NVIDIA下一代Hopper架构曝光，采用5nm工艺 晶体管超1400亿
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		据媒体报道， NVIDIA下一代主要面向高性能计算、人工智能等Hopper架构，将会采用5nm工艺制程，晶体管多达1400亿个，面积核心达到了900平方毫米，是有史以来最大的GPU。
作为参考，NVIDIA自家旗舰Ampere架构的A100为542亿个晶体管（每平方毫米约为6560万个晶体管），AMD阵营中采用Aldebaran架构的Instinct MI200系列为582亿个晶体管（每平方米约为7360万个晶体管），GH100是它们的2.5倍左右。
Hopper架构的GH100在5nm的加持下，能够在单芯片封装下轻松做到每平方毫米1.5亿个晶体管。
不过这一说法遭到了存疑，因为当前EUV光罩的限制为858平方毫米，而GH100核心的900平方毫米略大了一些。
还有消息称，英伟达会在这一代GPU产品线中尝试多芯片封装（MCM），并称之为GH102，会以独立的SKU出现。
以上说法还未得到官方证实，不过已经确定的是， NVIDIA将于2022年3月21日发布GTC 2022大会 ，届时可能会公布关于基于下一代计算架构“Hopper”，以及相应的加速计算卡方案。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49d898c0ad6204c9775b2a4cb3e5800e/" rel="bookmark">
			点云配准(CloudCompare软件)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		话不多说，直奔正题。
文章目录 一、Align配准算法二、ICP配准算法 一、Align配准算法 1.打开软件，加载数据。
2、为了便于我们分辨，修改数据的颜色。
同上过程，将配准2数据修改为绿色。
3、同时选择配准1和配准2数据，然后再选择配准Align配准方法进行配准。
4、选择自己要配准的数据，另一个数据则会成为参考数据。
5、选择对应的特征点，这个按自己的需求，不过至少需要3对特征点。
注：特征点的添加直接用鼠标进行点击即可。
6、点击“Align”进行点云的配准。
如果效果不满意，可以点击旁边的重置。
7、点击对号即可生成精度报告。
8、点击“OK”即可。
二、ICP配准算法 1、同上过程，加载数据。
2.选择ICP配准方式。
3、设置配准参数，按自己的需求来进行设置。
4、点击“OK”即可生成精度报告。
5、点击OK即可完成点云配准。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64a7131f4539dd98960bdd076040e697/" rel="bookmark">
			点云数据格式转换(使用CloudCompare软件)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因为最近在网上找了一些点云数据格式的转换方法，突然发现CloudCompare软件转换点云数据的格式很方便，所以就记录一下。CloudCompare软件下载地址：http://www.cloudcompare.org/
注：要注意一下，如果你的电脑显卡有点旧，就不要下载最新版的CloudCompare2.11，否则你启动软件的时候可能会报错，解决办法就是下载相对老一点的CloudCompare2.6版本就没问题了。
话不多说，转换流程如下所示：
1、打开CloudCompare软件，加载点云数据(.las或者是.laz等等)。
2、选择要进行转换的文件，此时屏幕上会出现一个立方体。
3、点击【File】中的【Save】，选择你要保存的格式即可。
4、转换后的格式文件效果如下所示：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5550a7a892233c48aec8137f4263c6fc/" rel="bookmark">
			Android 点击按钮弹出输入框和选择框
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考
1、输入框：
final EditText inputServer = new EditText(this);
inputServer.setFilters(new InputFilter[]{new InputFilter.LengthFilter(50)});
AlertDialog.Builder builder = new AlertDialog.Builder(this);
builder.setTitle(“个性点的签名”).setIcon(android.R.drawable.ic_dialog_info).setView(inputServer)
.setNegativeButton(“取消”, null);
builder.setPositiveButton(“确定”, new DialogInterface.OnClickListener() {undefined
public void onClick(DialogInterface dialog, int which) {undefined
String _sign = inputServer.getText().toString();
if(_sign!=null &amp;&amp; !_sign.isEmpty())
{undefined
signature_txt.setText(_sign);
}
else
{undefined
Toast.makeText(MemberActivity.this,“签名为空”,Toast.LENGTH_SHORT).show();
}
}
});
builder.show();
2、选择弹出框
final String[] items = {“保密”,“男”,“女”};
new AlertDialog.Builder(MemberActivity.this)
.setTitle(“请选择”)
.setItems(items, new DialogInterface.OnClickListener() {undefined
public void onClick(DialogInterface dialog,
int which) {undefined
TextView item_value = (TextView)memberInfo_tab_list_2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5550a7a892233c48aec8137f4263c6fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/108c47fb1dfa4c914e834b8cc076ea94/" rel="bookmark">
			关于获取设备的唯一设备ID，MAC地址 IOS/Android问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Hi，大家好。 关于账号快速登录问题的解决方案。区分ios和Android，此时要获取机器的udid。 Android下很快解决了，调用几个系统API，网上解决办法一堆。总体来说Android下udid为IMEI+Mac地址，也就是这两个数据拼成的串。 而在ios5.0以后，官方为了保护用户隐私，删除了获取设备udid的接口，虽然代码还在，但是获取出来的数据已经不对。官方在ios7.0以后提供了一个获取udid的快速办法。 代码如下： CFUUIDRef uuidRef = CFUUIDCreate(kCFAllocatorDefault); NSString *uuid = (NSString *)CFUUIDCreateString (kCFAllocatorDefault,uuidRef); 然后官方的建议是把当前的udid储存到app本地，这时问题来了。当用户把app卸载之后，这个udid已经随着包的消失而消失了，这时就需要我们来解决这个udid储存的问题。网上找了各种解决办法，最后差不多半天时间找到了解决办法并解决了。OS X和IOS都有一个钥匙串的概念，ios的相比OS X简单。我们即需把这个udid储存到IOS的钥匙串里。 具体的内容还需谢谢下面这个链接的作者： 点击打开链接 注:具体的设置group组信息的时候根据XCode版本不同可能方式不同。 即使IOS设备越狱后，该udid还是会在钥匙串中，数据存在。亲测。大家请放心。 开始写博客了，以后会在此处更新一些技术方面的文章。该篇文章算是一个总结，该内容是在之前做过的，可能感觉大家也遇到过该类问题。 如果有不懂的，可以联系我。可以提供内容讲解以及操作。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2ae202a6499eeddf5520ab50b90db50/" rel="bookmark">
			UE4 Actor生命周期 SpawnActor DestroyActor剖析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原创文章，转载请注明出处。
AActor很重要，只要是我们世界大纲列表内的物体，全部都是AActor。
目录
第一部分，从编辑器点击Play开始分析World里面全部的Actor的Spawn流程，分析到调用BeginPlay结束
1&gt;下面从点击场景中的Play/PlayInEditor/Play In Standalone开始，代码执行的顺序，只是大致的。后续引擎版本变化可能会不同(猜测)。我从堆栈拷贝的代码，从下往上看。
2&gt;上面生成了熟悉的GameInstance，GameMode怎么生成出来的？
3&gt;上面生成了熟悉的GameInstance，那么GameMode怎么生成出来的？贴出堆栈的图
4&gt;那么场景中的Actor列表怎么个调用BeginPlay的流程呢？
1)会判断Actors列表是否已经被初始化过了。if( !AreActorsInitialized() )，看来这个方法会被调用多次
2)没有被初始化的时候呢，有下面的代码，下面的则就是真正的初始化部分了。跟进去看一看
3)对每个Actor上的全部组件进行初始化。上图，但是注意此时Actor的BeginPlay还没有执行。还没到Actor的BeginPlay，还在下头
4)ActorBeginPlay调用的位置如下
第二部分，从代码层面调用SpawnActor，对其做分析
1&gt;编码测试
2&gt;源码分析
1)SpawnActor源码分析
2）Actor-&gt;PostSpawnInitialize源码分析
3）void AActor::PostActorConstruction()源码分析这个里面会初始化Actor下面的组件， 主要是下面的代码调用的BeginPlay
4）void AActor::DispatchBeginPlay(bool bFromLevelStreaming)源码分析
第三部分，从代码层面调用DestroyActor，对其做分析
1&gt;编码测试
2&gt;源码分析
1) void AActor::Destroyed()源码分析
2) RouteEndPlay(EEndPlayReason::Destroyed)源码分析
第一部分，从编辑器点击Play开始分析World里面全部的Actor的Spawn流程，分析到调用BeginPlay结束 在剖析Actor生命周期之前，我跟了一下Editor和Standlone的代码，找到了场景中actor列表的初始化的地方。
1&gt;下面从点击场景中的Play/PlayInEditor/Play In Standalone开始，代码执行的顺序，只是大致的。后续引擎版本变化可能会不同(猜测)。我从堆栈拷贝的代码，从下往上看。 8 StartPlayInEditorGameInstance中调用了创建GameMode创建GameMode，这个是在GameInstance里面创建的 UGameInstance::CreateGameModeForURL(FURL InURL, UWorld * InWorld) UWorld::SetGameMode(const FURL &amp; InURL) 7 下面文章中还会接着介绍这个里面的代码 UGameInstance::StartPlayInEditorGameInstance(ULocalPlayer * LocalPlayer, const FGameInstancePIEParameters &amp; Params) 6 这个方法就是在创建GameInstance，并且有趣的是上面几个方法也是在这里面调用的 //在这个里面创建了GameMode,就是上面的代码 UEditorEngine::CreateInnerProcessPIEGameInstance(FRequestPlaySessionParams &amp; InParams, const FGameInstancePIEParameters &amp; InPIEParameters, int InPIEInstanceIndex) 5&gt; UEditorEngine::OnLoginPIEComplete_Deferred(int LocalUserNum, bool bWasSuccessful, FString ErrorString, FPieLoginStruct DataStruct) 4&gt;创建一个Editor新窗口的实例 UEditorEngine::CreateNewPlayInEditorInstance(FRequestPlaySessionParams &amp; InRequestParams, const bool bInDedicatedInstance, const EPlayNetMode InNetMode) 3&gt;拿PlayInEditor举例, 该方法中会判断一些条件，比如开着Matinee了，不让播放 UEditorEngine::StartPlayInEditorSession(FRequestPlaySessionParams &amp; InRequestParams) 2&gt;从StartQueuedPlaySessionRequest过来的，并且从这个方法里面判断是哪一种, 是Standalone?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2ae202a6499eeddf5520ab50b90db50/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/762231d77e333351e157dc7ac3637864/" rel="bookmark">
			UE4随笔 Landscape动态Attach之后没有碰撞怎么解决？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本帖纯属个人原创，如有转载请注明出处
很多时候需求是这样的，想达到场景中所有的Actor统一旋转的功能。纯代码无观赏性，大家有实际需求的自然能看懂。
接到这样的需求，大家就会想将所有的actor全部都attach到一个父节点上，编辑器中Landscape无法进行Attach, 并且InstancedFoliageActor场景中也没有。那么就需要我们在代码中动态的进行Attach。
下面的支点Actor就是父节点, RootActor。
//将LandscapeActor Attach到支点Actor void LandscapeAttachToPivotActor(); //将InstancedFoliage Attach到支点Actor void InstancedFoliageAttachToPivotActor(); //将LandscapeActor Attach到支点Actor void USPDynamicDataComponent::LandscapeAttachToPivotActor() { //Landscape类型的Actor比较特殊, 需要将这种类型的Actor代码挂接到支点Actor上 //(为什么说比较特殊, 和其他的相比, 这种Actor不能看到子控件, 不能调整移动性, 故不能像其他Actor在编辑器中调整) //地形 TArray&lt;AActor*&gt; LandScapesActors; UGameplayStatics::GetAllActorsOfClass(this, ALandscape::StaticClass(), LandScapesActors); for (auto LandScapeActor : LandScapesActors) { //不处理level streaming的资源 bool bLevelStreamingAssest = false; for (FName tag : LandScapeActor-&gt;Tags) { bLevelStreamingAssest = tag.ToString().Contains("LevelStreamingAssest"); BREAK_IF_TRUE(bLevelStreamingAssest); } if (bLevelStreamingAssest) continue; if (LandScapeActor-&gt;GetAttachParentActor() != SPPivotMeshActor) { //线设置成Movable才可以attach int32 LandScapeComponentsNum = LandScapeActor-&gt;GetComponents().Array().Num(); for (int j = 0; j &lt; LandScapeComponentsNum; j++) { UActorComponent* pAC = LandScapeActor-&gt;GetComponents().
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/762231d77e333351e157dc7ac3637864/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45b2b439db47c798dd1c802aa78b7617/" rel="bookmark">
			QT 随笔 QProcess中waitForFinished的坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章为个人创作，如转载请标注。
当我们执行一个超过30s的动作的时候，int msecs = 30000，那么就会直接finish，像遇到解压文件这种情况并且要等finish时候用解压的文件的时候，就会出现问题。
QString sCommandLine = "your command line"; QProcess p; p.start(sCommandLine); p.waitForStarted(); p.waitForFinished(); //此处其实是有一个缺省参数的, int msecs = 30000 此处也可能会遇到坑 p.close(); 如何解决
QString sCommandLine = "your command line"; QProcess p; p.start(sCommandLine); p.waitForStarted(-1); p.waitForFinished(-1); //-1的意思就是等待你的事件真的结束 p.close(); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/881372d9c7c388226093e1610ab8d618/" rel="bookmark">
			C&#43;&#43; 动态链接库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原创文章，转载请注明出处。
如果Windows系统有缺失的DLL文件，可以去这个链接下载。点击去这里寻找
C++ DLL简介以及使用 1&gt;认识DLL(动态链接库)2 &gt;格式后缀3 &gt;DLL优点4 &gt;DLL缺点5 &gt;加载DLL1&gt;动态加载(运行时加载)通过LoadLibary加载, GetProcAddress调用。2&gt;静态加载方式(.h .lib .dll三件套加载) 1&gt;认识DLL(动态链接库) 动态链接库DLL(Dynamic-Link Library)通常包含程序员自定义的变量和函数, 可以在运行时动态链接到可执行文件(我们的exe程序)中。
2 &gt;格式后缀 Windows上：（.dll）
Linux上：(.so)
Android上：(.so)
IOS上：(.dylib)
3 &gt;DLL优点 1)模块化，耦合小：大规模软件开发中，开发过程独立，耦合度小，比如UE4里面的模块(每一个.build.cs)都是一个DLL。
2)扩展性：DLL文件与EXE文件是独立的，只要接口不变，升级程序只需更新DLL文件不需要重新编译应用程序。并且我们的EXE文件较小。
3)复用性：DLL的编制与具体的编程语言以及编译器无关，不同语言编写的程序只要按照函数调用约定就可以调用同一个DLL函数。
4)节省内存：当应用程序使用动态链接时，多个应用程序可以共享磁盘上单个DLL副本。
5)隐私性：可以当做黑盒使用，可以将我们的具体实现代码隐藏起来，比如我们想将算法的具体实现隐藏起来，不让别人看到我是怎么做的。一般SDK接入时候，里面的具体算法实现都是不会公开cpp的。
4 &gt;DLL缺点 如果是动态loaddll的话，会牺牲部分性能吧。微乎其微的。
5 &gt;加载DLL 1&gt;动态加载(运行时加载)通过LoadLibary加载, GetProcAddress调用。 如果加载失败，通过GetLastError()获取失败原因。
下面是LoadLibary的示例代码
第一步，在.h中声明了static HMODULE hDLL;
#include&lt;Windows.h&gt; //加载的头文件 class QIDCardReader : public QMainWindow { Q_OBJECT public: QIDCardReader(QWidget* parent = 0); private: static HMODULE hDLL; }; 第二步，定义要调用的dll中的方法。并通过LoadLibrary给hDLL赋值
#include "QIDCardReader.h" //CPP中预声明一下我要调用dll里面的方法 typedef int(*MyRouton_RepeatRead)(bool); typedef int(*MyInitComm)(int); typedef int(*MyAuthenticate)(); typedef int(*MyReadBaseInfosPhoto)(char * , char * , char * , char *, char * , char * , char *, char * , char* , char * ); typedef int(*MyCloseComm)(); HMODULE QIDCardReader::hDLL; QIDCardReader::QIDCardReader(QWidget* parent) : QMainWindow(parent) ,ui_(new Ui::QIDCardReaderClass) { hDLL = LoadLibrary(L"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/881372d9c7c388226093e1610ab8d618/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d31699bef9d4af852aa5b514a55c10d7/" rel="bookmark">
			C&#43;&#43; 调用7z进行解压缩，并返回解压缩进度和异常信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原创文章，转载请注明出处。
C++ 7z解压缩 前言解决方案1&gt;拿到 bit7z64.lib和7z.dll1.1&gt;下载编译bit7z64.lib需要的源代码1.2&gt;解压下载文件1.3&gt;编译《bit7z-master》，拿到 bit7z64.lib1.4&gt; 准备7z.dll 1.2&gt;编码1.2.1&gt;头文件1.2.2&gt;cpp文件1.2.3&gt;使用介绍 前言 像Word，Excel，PPT等类似的编辑软件都有一个特点，就是可以保存成一个文件, 方便传阅。比如
我们的PPT里内置了视频图片文字等，它的后缀是pptx。其实这个pptx就是一个压缩文件，你如果把 .pptx 的后缀改成 .rar 的话, 对其解压后你会发现其实这个.pptx就是个压缩文件, 里面存了很多文件。如下图。其实这个就是用到了压缩和解压。 如果你也是做类似的软件，那么使用7z的库还是挺有必要的。
将.pptx改成rar解压后如下图，比如media文件夹就是放你的ppt内视频的。
解决方案 并不是通过7z.exe直接调用命令的方式, 而是通过bit7z+7z.dll进行调用(方便拿到解压缩进度)
点击跳转到7z官网链接地址，可以了解一些7z的信息 1&gt;拿到 bit7z64.lib和7z.dll bit7z是一个C++的静态库，里面封装了接口，用来调用7-zip的库；
对bit7z进行编译的话，需要下载下面的两个源码：
1.1&gt;下载编译bit7z64.lib需要的源代码 bit7z源码：下载地址lzma源码：下载地址1 如果lzma源码链接失效：下载地址2 bit7z-3.1.3.zip | bit7z-master.zip 这两个分支我都测试过是可以用的，建议用比较新的。
1.2&gt;解压下载文件 解压，将《lzma1805.7z》解压，将解压后的（下图的文件）拷贝
放到《 bit7z-master.zip》解压后的路径里（bit7z-master\lib\7zSDK\）如下图
1.3&gt;编译《bit7z-master》，拿到 bit7z64.lib 打开 bit7z-master\bit7z.vcxproj 对其编译, 编译选项Win64+Release
如下图，我编译的是Win64下用的。编译成功后在 bit7z-master\bin\x64 目录下会有你编译完的bit7z64.lib。这个就是我们要用的。
1.4&gt; 准备7z.dll 由于bit7z依赖7z的库，所以还要下载7z的dll库才能用。
7z.dll 下载链接：下载链接
打开上面下载链接后，
安装下图《.exe 64 位 x64 7-Zip Windows 64 位（Intel 64 或 AMD64）》
安装时候让你选安装路径，拷贝记下这个路径
安装完毕后，找到安装后的目录，拷贝7-zip.dll出来，和上面编译好的bit7z64.lib放到你的exe路径下，接下来就可以写代码了
1.2&gt;编码 我直接将代码贴出来，下面1.2.3小节有使用的例子代码。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d31699bef9d4af852aa5b514a55c10d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f69e5465f0ae09561fc9672a1be694df/" rel="bookmark">
			你的代码暴漏了你的年龄(毕业设计)--技术文档&#43;程序源代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现在社会上最流行的一句话：你的脖子暴露你的年龄；听过一首歌你就暴露了你的年龄；说了一句广告语暴漏了你的年龄；看过一部电影或电视剧暴漏了你的年龄；你最常用的表情包暴露了你的年龄；暴漏了你的年龄；暴漏了你的年龄；…
对于码农呢，或许你写的代码暴漏了你的年龄，或许你用的开发工具暴漏了你的年龄，或许你用的电脑暴漏了你的年龄…，这里两天整理资料，发现了一个骨灰级的东西，估计现在的小年轻的听可能都没有听说过的东西，感觉很意外，经历了那个没有网盘，没有优盘的时代居然保留了下来，特意拿出来与大家分享，如果真的有程序博物馆的话，他应该可以排上号了。
下面说重点：先上图：
我截了一段代码如下：
其中 n2=alltrim(this.parent.parent.Text2.value) n3=alltrim(this.parent.parent.Text3.value) n4=alltrim(dtoc(this.parent.parent.Text4.value)) n5=alltrim(this.parent.parent.Text5.value) 程序段的作用是去掉编辑框的空格； do case case n1='' messagebox('不能输入空值!',48,'注意!') this.parent.parent.Text1.setfocus case n2='' messagebox('不能输入空值!',48,'注意!') this.parent.parent.Text2.setfocus case n3='' messagebox('不能输入空值!',48,'注意!') this.parent.parent.Text3.setfocus case n4='' messagebox('不能输入空值!',48,'注意!') this.parent.parent.Text4.setfocus case n5='' messagebox('不能输入空值!',48,'注意!') this.parent.parent.Text5.setfocus otherwise a=messagebox('确认添加新纪录到学生表!',1+64+0,'提示信息') …… endcase的作用是判断编辑框是否填写为空的安全性检查; if a=1 use student go bottom insert into student values (n1,n2,n3,CTOD(n4),n5) messagebox('新纪录添加成功!',64,'提示信息') endif程序段的作用是如果是第一个页面，打开学生表完成插入操作。 有朋友能认出来这个是什么开发工具，使用的什么语言么？
对，我想有的朋友已经猜出来了，狐狸头，Visual Foxpro 6.0
当年它可也是红火过一阵子的，Visual Foxpro 6.0+Access数据库当年也是很受程序界爱戴的，现在都成老古董了，是我的大学毕业设计，文档程序都有，有感兴趣的同学可以下载下来，回味或者了解一下当年的程序开发。
下载地址：https://download.csdn.net/download/hnjzfwy/33518606
非常感谢各位能在百忙之中浏览我的页面。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5dd0b961d1c4d1a4b30aa1d8d7906ea6/" rel="bookmark">
			UE4通过UCanvasRenderTarget2D导出图片&#43;文字的组合图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 原创文章，转载请注明出处。
UCanvasRenderTarget2D 导出图片 前言开始做创建1&gt;CanvasRenderTarget2D, 对其实现创建2&gt;材质球创建3&gt;材质实例创建4&gt;材质Actor，里面放了个Box，为了看效果，实际上这个可以不参与视觉交互。记得将这个Actor拖到世界中。创建5&gt;RenderTarget 效果补充由于上述是演示，不完善，用到项目中还需要完善下面几个内容 前言 更新日期 2021-10-29 11:23:25
做了一个插件，下载地址
关于插件怎么用，EKExportImageLibrary.cpp中提供了两个静态导出方法
UEKCRT2DExportImageLibrary::EKCRT2DExportByPath
UEKCRT2DExportImageLibrary::EKCRT2DExportByTexture2D
通过监测EKCRT2D_Delegates.h中的FOnExportImageSuccessDelegate::OnExportImageSuccessDelegate代理可以获得导出完成的通知。
通过程序生成二维码图片，并且在二维码图片下面标记一串文本(二维码长得都差不多，肉眼难以分辨，所以加上文本)，导出图片后，可以打印贴到相应的房间内。
大概在UE4中的样子如下
导出后的图片如下，可以是HDR、Png
开始做 一共是需要下面几个资源内容，即可快速完成这个功能。当然这是演示，蓝图对于写博客，给大家演示会更直观。用到项目里面的话还是要封装一下的。
创建1&gt;CanvasRenderTarget2D, 对其实现 创建2&gt;材质球 创建3&gt;材质实例 创建4&gt;材质Actor，里面放了个Box，为了看效果，实际上这个可以不参与视觉交互。记得将这个Actor拖到世界中。 创建5&gt;RenderTarget 效果 可以看到文件夹里多了一张图
补充 该文章只介绍了DrawTexture和DrawText，其实是很多效果可以被绘制出来的。
由于上述是演示，不完善，用到项目中还需要完善下面几个内容 1&gt; 导出的图片背景颜色怎么调整？（现在是黑色）
2&gt; 导出的图片上的图片源素材、文本内容 参数化；
3&gt; 导出的图片大小，调整CreateCanvasRenderTarget2D调用时候传入的画布大小；
4&gt; 导出的图片上面的文本、图片的位置在哪？
5&gt; 文本更多的效果，颜色、大小，是否模糊？
6&gt; 导出格式你想要PNG还是JPG或者HDR? 对应代码去这个函数中找
UKismetRenderingLibrary::ExportRenderTarget 7&gt; 你是否考虑封装成C++来做？
最后，如果你按照步骤不能实现的话，请留言告诉我。
谢谢，创作不易，大侠请留步… 动起可爱的双手，来个赞再走呗 &lt;(￣︶￣)&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a34473b69f8a1a68908f305f7fb22823/" rel="bookmark">
			堆排序——详细教学
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.堆的介绍 我们前面讲到了简单选择排序，它在待排序的n个记录中选择一个最小的记录需要比较n-1次。本来也可以理解，查找第一个数据需要比较那么多次是很正常的，否则如何知道它是最小的记录？
可惜的是，这样的操作并没有把每一趟的比较结果保存下来，在后一趟的比较中，有许多比较在前一趟已经做过了，但由于前一趟排序未保存这些比较结果，所以后一趟排序时又重复执行了这些比较操作，因而记录的比较次数较多。
如果可以做到每次在选择到最小记录的同时，并根据比较结果对其他记录做出相应的调整，那样排序的总体效率就非常高了。而堆排序（Heap Sort）,就是对简单选择排序的一种改进，这种改进的效果是非常明显的。
叠罗汉我们小时候是恶作剧，但是呢在西班牙的加泰罗尼亚地区，他们将叠罗汉视为正儿八经的民族体育运动，场面极其壮观。
我们这里要介绍的“堆”就类似于这种塔型结构，当然不是这么简单的。我们先看两个图：
很明显，我们可以发现他们都是二叉树，如果观察仔细一些，还能看出他们都是完全二叉树。如果观察仔细一些，还能看出他们都是完全二叉树。左图中根节点是所有元素的最大值，右图的根节点是所有元素中最小的。再仔细看看，左图中的每个节点都比左右孩子大，右图的每个节点都比左右孩子小。这就是我们要的堆结点。
堆是具有下列性质的完全二叉树：每个节点的值都要大于或者等于其左右孩子结点的值，称为大顶堆；每个孩子小于或者等于其左右孩子结点的值称为小顶堆
这里需要注意从堆的定义可知，根节点一定是堆中所有结点最大（小）者。较大（小）的结点靠近根节点（但也不绝对，右图中60,40，均小于70，但他们并没有70靠近根结点）
如果按照层序遍历的方式给结点从一开始编号，则结点之间满足以下关系。
或者 i∈[1,n/2]
这里为什么要小于等于⌊n/2⌋?二叉树有一个性质，好像专门为这个准备的。一颗完全二叉树，如果i = 1，则结点i是二叉树的根，无双亲；如果 i &gt; 1,则双亲是 ⌊i / 2⌋.那么对于 n 个结点的二叉树而言，它的 i 值自然就是小于等于⌊n / 2⌋.
如果将上面两个图的大顶堆和小顶堆用层次遍历存入数组，则一定满足上面的关系表达式，如图：
我们现在这个对结构就是用来排序用的。
2.堆排序算法 堆排序就是利用堆（我们这里假设用大顶堆）进行排序的方法。它的基本思想是，将待排序的序列构造成一个大顶堆。此时，整个序列的最大值就是堆顶的根结点。将它移走（其实就是将其与堆数组的末尾元素交换，此时末尾元素就是最大值），然后将剩余的 n - 1个序列重新构造成一个堆，这样就会得到 n 个元素的次最大值。如此反复执行，便能得到一个有序序列了。
例如，下面左图是一个大顶堆，90为最大值，将90和20（末尾元素）互换，如图右边，此时90构成了整个堆序列的最后一个元素，将20经过调整，使得除了90以外的结点继续满足大顶堆定义。
新构造的图：
相信大家已经基本明白思想了，不过要实现还需要解决两个问题：
如何有一个无序序列构建一个堆？如何在输出堆顶元素后，调整剩余元素成为一个新的堆？ 我们先来看代码:
void HeapSort(SqList *L) { int i; for( i=L-&gt;length/2;i&gt;0;i--) // 把L中的r构建成一个大顶堆 HeapAdjust(L,i,L-&gt;length);	for (i=L-&gt;length;i&gt;1;i--) { swap(L,1,i); // 将堆顶记录和当前未经排序的子序列的最后一个记录交换 HeapAdjust(L,1,i-1); // 将L-&gt;r[1..i-1]重新调整为大顶堆 } } 从代码中也可以看出，整个排序过程分为两个 for 循环。第一个 for 循环要完成的就是将现在待排序序列构建成一个大顶堆。第二个 for 循环要完成的就是逐步将每个最大值的根结点与末尾元素交换，并且再次调整为大顶堆。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a34473b69f8a1a68908f305f7fb22823/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f266e0d0dcbde6e1f10b42f85841f8a/" rel="bookmark">
			Docker无介绍快使用，docker拉取Nginx（六）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Docker无介绍快使用，docker拉取Nginx（六） 问题背景Docker无介绍快使用，安装部署hello测试（一）Docker无介绍快使用，docker指令使用（二）Docker无介绍快使用，docker数据卷Volumes挂载的使用（三）Docker无介绍快使用，docker拉取mysql5.7及使用（四）Docker无介绍快使用，docker拉取tomcat及使用（五）Docker无介绍快使用，docker拉取Nginx（六） Docker拉取Nginx总结Lyric：让我带着你离开 问题背景 上篇介绍了Docker拉取tomcat，本章介绍一下docker拉取Nginx
注意事项：
因为我写的是一个系列，在之前的文章介绍过的一般不会重复介绍，可以根据以下链接查看之前的知识点默认已安装Centos7默认已安装JDK默认开启root权限默认已安装mysql客户端，如Navicat或Sqlyog一个镜像可以启动多个容器，第一次启动容器会自动保存，下次启动容器可以使用 docker ps -a 查看所有容器ID和名字，然后使用 docker start [容器ID或名字] 进行启动 Docker无介绍快使用，安装部署hello测试（一） Docker无介绍快使用，docker指令使用（二） Docker无介绍快使用，docker数据卷Volumes挂载的使用（三） Docker无介绍快使用，docker拉取mysql5.7及使用（四） Docker无介绍快使用，docker拉取tomcat及使用（五） Docker无介绍快使用，docker拉取Nginx（六） Docker拉取Nginx 1 搜索nginx镜像
docker search nginx 2 选择第一个热度最高，拉取nginx镜像
docker pull nginx 3 使用镜像启动一个nginx容器
docker run -di --name=mynginx -p 80:80 nginx 4 访问Nginx，浏览器输入[ip]:80
总结 使用docker拉取镜像启动容器绝对比本地安装快捷方便 作为程序员第 57 篇文章，每次写一句歌词记录一下，看看人生有几首歌的时间，wahahaha … Lyric：让我带着你离开 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50a8e9c82587ec1c46536c14a505a84a/" rel="bookmark">
			使用 UnionFind 判断他到底是不是你的远房表亲
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		不晓得大家晓不晓得并查集这个算法，我之前是没怎么听过（孤陋寡闻），其实这个算法是非常常见的一个算法，也是能用固定的套路去解决某一类问题，最为经典的就是亲戚问题。
并查集（UnionFind）常常用于处理一些不相交集合的合并及查询问题。
并查集（UnionFind）具有Union和Find两个功能
合并（Union）：将两个不相交的集合合并为一个集合。查询（Find）：查询两个元素是否在同一个集合中（确定是否具有亲属关系，通过find可以获取其祖先）。 两棵树：
Union（1,5）之后
经典案例：亲戚问题
若某个人家族人员过于庞大，你如何判断其中的两个人是否具有亲戚关系呢？
x和y是亲戚关系，y是z的亲戚，那么x和z也是亲戚。如果x和y是亲戚，那么x的亲戚也是y的亲戚，y的亲戚也是x的亲戚。
这时候我们就可以使用并查集算法，将每一个亲戚关系使用Union关联起来，所有亲戚录入完毕，我们就可以使用并查集中的Find，可以通过Find获取他们的祖先，看看是否是同一个祖先，从而判断他们是不是亲戚。
时间复杂度：elogn(假设有e组集合)
并查集步骤：
初始化：把每个点所在的集合初始化为其自身（时间复杂度O(n)）
查找：查找两个元素所在的集合，寻找根节点（时间复杂度O(logn)）
递归查找找到根节点，递归返回时将递归路径所有节点标记为根节点（这样效率会更高，如果每个节点只存储上一级节点效率会更低） 合并：如果两个元素属于不同的集合，将两个元素合并为一个集合（时间复杂度O(1)）
查找两个元素的根节点先祖不同时，将一个元素的祖先修改为另一个元素的祖先（擒贼先擒王） UnionFind中数组的意义： 下标代表树的节点，值代表节点的根节点（初始化假设自己是自己的根节点）
我们在使用union(1,2)时数组就会变为
上图的两个树用数组表示就是
使用union(1,5)，数组就会变为下图，这就是擒贼先擒王（union(1,9)也是如此）：
这使我们调用find(9)就会发生
find(9) -&gt; find(5) -&gt; find(1) 得到1同时将下标9修改为1
在需要使用并查集的场景中，每次使用的框架的都是差不多的，我们只需要对模板进行调整，即可满足大部分需求，下边是一个并查集的算法模板，通过对union简单的优化可以减少祖先设置的次数，从而实现quickUnion。
并查集模板代码：
package com.zhj.leetcode; ​ public class UnionFind { public int[] fa; public int[] rank; public UnionFind(int length){ init(length); } /** * 初始化，将每个节点初始化为自身 */ public init(int length){ fa = new int[length]; rank = new int[length]; for (int i = 0; i &lt; length; i++) { fa[i] = i; rank[i] = 0; } } ​ /** * 找到某个元素的根节点 * @param x * @return */ public int find(int x) { if (x == fa[x]) { return x; } return fa[x] = find(fa[x]); } ​ /** * 合并两个元素为同一个根节点 * @param x * @param y */ public void union(int x, int y) { int faX = find(x); int faY = find(y); if (faX !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/50a8e9c82587ec1c46536c14a505a84a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca911510fa7a3a5cfdcc3d2ea4c8bc4a/" rel="bookmark">
			Array.sort用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、介绍
Arrays.sort()是经过调优排序算法，性能能达到n*log(n)
Arrays.sort()重载了四类方法
sort(T[] a)：对指定T型数组按数字升序排序。
sort(T[] a,int formIndex, int toIndex)：对指定T型数组的指定范围按数字升序排序。
sort(T[] a, Comparator&lt;? supre T&gt; c): 根据指定比较器产生的顺序对指定对象数组进行排序。
sort(T[] a, int formIndex, int toIndex, Comparator&lt;? supre T&gt; c): 根据指定比较器产生的顺序对指定对象数组的指定对象数组进行排序。
1、sort(T[] a)
对指定T型数组按数字升序排序。
代码：
import java.util.Arrays;
import java.util.Comparator;
public class ArraysSort {
public static void main(String[] args) {
int[] a={2,5,4,3,1,8};
Arrays.sort(a);
System.out.println(Arrays.toString(a));
}
}
// 结果
// [1, 2, 3, 4, 5, 8]
2、sort(T[] a,int formIndex, int toIndex)
对指定T型数组的指定范围按数字升序排序。
代码：
复制代码
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca911510fa7a3a5cfdcc3d2ea4c8bc4a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0940afefd90a25899c5304810e5083aa/" rel="bookmark">
			【math】凸数据集 &amp; 非凸数据集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		凸数据集 如果一个数据集D是凸的，那么对于其中任意的两点x,y∈D，θ∈R, 0≤θ≤1,则 θ x + ( 1 − θ ) y ∈ D
表达式θx+(1−θ)y被称作点x , y 的 凸性组合(convex combination)
简单来说，数据集D中任意两点的连线上的点，也会在数据集D内，那么数据集D就是一个凸集。
如下图，左边非凸，右边为凸
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd2db8d0fed24de809078de3a41b250e/" rel="bookmark">
			VScode下载及安装完整教程(详细版)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VScode下载及安装教程 一、软件下载二、软件安装三、安装相关插件①打开软件②搜索相关插件并安装③软件重启以后就是简体中文 一、软件下载 二、软件安装 三、安装相关插件 ①打开软件 ②搜索相关插件并安装 安装简体中文包需要重启才能有效
前端ES语法检查的插件
在浏览器打开页面
开发vue项目需要用到的插件
③软件重启以后就是简体中文 简体中文如下所示
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ed363cc2a6ac0c45387b9e861582801/" rel="bookmark">
			Docker内运行ROS(melodic版本)以及使用Rviz
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Docker内运行ROS(melodic版本)以及使用Rviz 写在前文 Docker的安装以及介绍本文就不再累述了，安装Docker的版本任意，但是要注意的一点是你是ARM板子还是x86的板子，一般在ARM板上实现上述功能较为麻烦，如果是在ARM板子上使用Docker+ROS的话可以参考这篇文章http://wiki.ros.org/docker/Tutorials/Hardware%20Acceleration#nvidia-docker1
在ROS的官网上有教程，但是还是有些坑的，如果你使用的是Nvidia的板子，要注意CUDA的版本，以及nvidia-docker的一些操作。
安装Portainer 在正式使用之前我们先安装一个操作容器的图形界面–Portainer，这个可视化的界面其实和ROS关系并不大，但是使用起来非常的方便，可以让我们更快速的利用Docker学习ROS，而不是要完整的学习完Docker的繁杂的命令再学习ROS。
安装使用Portainer的操作如下：
sudo systemctl restart docker sudo docker pull portainer/portainer sudo docker run -d -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock --restart=always --name prtainer portainer/portainer 运行上述命令等待执行成功后，放行防火墙，访问本机的9000端口进入Portainer，创建账号密码之后即可登录到控制台。
在这里我们可以查看到运行容器内部的信息，也可以快速的删除废弃的容器及镜像。也可以构建虚拟网络实现容器间隔离。具体操作可以在网上另行搜索，本文也不再累述。
在Docker内运行ROS 在完成这项操作之前，我们首先要寻找一个合适的Docker镜像来完成这件事情
使用下面命令可以查看目前docker hub上有哪些大神上传的公共镜像：
sudo docker search ros 我们选用一个桌面环境什么的都安装完整的melodic版本的docker镜像：
sudo docker pull osrf/ros:melodic-desktop-full 接下来我们需要写一个Dockerfile，来帮我们完成一些简单的环境依赖安装工作：
mkdir rocker cd rocker vim Dockerfile #######复制下面的Dockerfile FROM osrf/ros:melodic-desktop-full # nvidia-container-runtime ENV NVIDIA_VISIBLE_DEVICES \ ${NVIDIA_VISIBLE_DEVICES:-all} ENV NVIDIA_DRIVER_CAPABILITIES \ ${NVIDIA_DRIVER_CAPABILITIES:+$NVIDIA_DRIVER_CAPABILITIES,}graphics RUN apt-get update &amp;&amp; \ apt-get install -y \ build-essential \ libgl1-mesa-dev \ libglew-dev \ libsdl2-dev \ libsdl2-image-dev \ libglm-dev \ libfreetype6-dev \ libglfw3-dev \ libglfw3 \ libglu1-mesa-dev \ freeglut3-dev \ vim 接下来使用下面的命令构建容器，注意目录所在的位置以及后面的"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ed363cc2a6ac0c45387b9e861582801/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1fcf507bd586d8e01c346fe355a52c75/" rel="bookmark">
			使用 js 实现 栈
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		栈是一种特殊的列表，栈内的元素只能通过栈顶访问，栈是一种后入先出的数据结构。
参数 接收的参数为数组类型。
属性及方法 栈的抽象数据类型定义
列表属性或方法描述top属性记录栈顶元素的位置，同时也为了标记哪里可以加入新元素，当向栈内压入元素时，top 增大，从栈内弹出元素时，top 减小push方法向栈内压入元素pop方法从栈内弹出元素peek方法返回栈顶元素，该元素依然存在栈内toString方法返回栈的字符串形式clear方法清空栈length方法返回栈内元素的个数 下面看下代码实现：
// ES5 function stack(data = []) { this.dataStore = data this.top = data.length this.push = push this.pop = pop this.peek = peek this.toString = toString this.clear = clear this.length = length } function push(element) { this.dataStore.push(element) this.top++ } function pop() { this.top-- return this.dataStore.pop() } function peek() { return this.top &gt; 0 ? this.dataStore[this.top - 1] : undefined } function toString() { return this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1fcf507bd586d8e01c346fe355a52c75/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/300/">«</a>
	<span class="pagination__item pagination__item--current">301/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/302/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>