<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0da1ddec47363a74a34bfeb1192b110/" rel="bookmark">
			如何在 Ubuntu 系统中安装 Apache Kafka ？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在本指南中，我们将逐步演示如何在 Ubuntu 22.04 上安装 Apache Kafka。
在大数据中，数以百万计的数据源生成了大量的数据记录流，这些数据源包括社交媒体平台、企业系统、移动应用程序和物联网设备等。如此庞大的数据带来的主要挑战有两个方面：高效的数据收集和分析。为了克服这些挑战，您需要一个可靠且健壮的消息传递系统。
Apache Kafka 由 Apache Foundation 开发，用 Java 和 Scala 编写是开源分布式 pub/sub（发布订阅）事件处理大量数据流平台。它也允许您将消息从一个点传输到另一点。它与 Zookeeper 同步服务一起工作，并与 Apache Spark 无缝集成，用于分析和处理大规模数据。
与其他消息传递系统相比，Apache Kafka 提供了更好的吞吐量、固有的容错能力和复制能力，这使其成为企业消息处理应用程序的绝佳选择。 包括 Netflix、微软和 AirBnB 等顶级公司都有使用 Apache Kafka 服务。
必备条件 Pre Installed Ubuntu 22.04Sudo User with Admin RightsInternet Connectivity (1) 安装 OpenJDK 由于 Apache Kafka 是用 Java 编写的，所以安装 Java 是一个先决条件，先更新包索引。
$ sudo apt update 接下来，安装 OpenJDK 11，它是 Java 标准版平台的免费开源实现。
$ sudo apt install openjdk-11-jdk -y 接下来，查看 java 版本。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a0da1ddec47363a74a34bfeb1192b110/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bef121d484093afde4d4496d309c87af/" rel="bookmark">
			Android 老项目导入可能遇到的问题 Unsupported Java. Your build is currently configured to use Java 17.0.6 and Gr
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		导入老项目时出现以下问题 distributionBase=GRADLE_USER_HOME distributionPath=wrapper/dists distributionUrl=https\://services.gradle.org/distributions/gradle-5.4.1-all.zip zipStoreBase=GRADLE_USER_HOME zipStorePath=wrapper/dists Unsupported Java.
Your build is currently configured to use Java 17.0.6 and Gradle 5.4.1.
Possible solution:
Upgrade Gradle wrapper to 7.2 version and re-import the project
意思是当前的Java17.0.6，需要升级到7.2.
原本这个项目执行不是Java17，本地使用了更高的Java版本，因此同步需要更新gradle。
当然，可以更新gradle,但，这意味着后面有很多需要跟着改的问题。但是，何必呢？只是想运行下项目看下效果，结果还要改一通内容，最终很可能还不知道能否跑起来。
于是，根据条件，可以进行一下操作。
解决方案 可以设置较低的Java版本，以此来迎合Gradle 5.4.1。
——&gt;File——&gt;Project Structure——&gt;SDK location——&gt;Gradle Setting——&gt;Gradle SDK——&gt;选择个1.8的版本下载并运行吧。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6fbef04880651fc65846cf22225d2cdc/" rel="bookmark">
			SpringBoot 最大连接数及最大并发数是多少？？？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		每个Spring Boot版本和内置容器不同，结果也不同，这里以Spring Boot 2.7.10版本 + 内置Tomcat容器举例。
概序 在SpringBoot2.7.10版本中内置Tomcat版本是9.0.73，SpringBoot内置Tomcat的默认设置如下：
Tomcat的连接等待队列长度，默认是100
Tomcat的最大连接数，默认是8192
Tomcat的最小工作线程数，默认是10
Tomcat的最大线程数，默认是200
Tomcat的连接超时时间，默认是20s
相关配置及默认值如下
server: tomcat: # 当所有可能的请求处理线程都在使用中时，传入连接请求的最大队列长度 accept-count: 100 # 服务器在任何给定时间接受和处理的最大连接数。一旦达到限制，操作系统仍然可以接受基于“acceptCount”属性的连接。 max-connections: 8192 threads: # 工作线程的最小数量，初始化时创建的线程数 min-spare: 10 # 工作线程的最大数量 io密集型建议10倍的cpu数，cpu密集型建议cpu数+1，绝大部分应用都是io密集型 max: 200 # 连接器在接受连接后等待显示请求 URI 行的时间。 connection-timeout: 20000 # 在关闭连接之前等待另一个 HTTP 请求的时间。如果未设置，则使用 connectionTimeout。设置为 -1 时不会超时。 keep-alive-timeout: 20000 # 在连接关闭之前可以进行流水线处理的最大HTTP请求数量。当设置为0或1时，禁用keep-alive和流水线处理。当设置为-1时，允许无限数量的流水线处理或keep-alive请求。 max-keep-alive-requests: 100 架构图 当连接数大于maxConnections+acceptCount + 1时，新来的请求不会收到服务器拒绝连接响应，而是不会和新的请求进行3次握手建立连接，一段时间后（客户端的超时时间或者Tomcat的20s后）会出现请求连接超时。
TCP的3次握手4次挥手 时序图 核心参数 AcceptCount 全连接队列容量，等同于backlog参数，与Linux中的系统参数somaxconn取较小值，Windows中没有系统参数。
NioEndpoint.java
serverSock = ServerSocketChannel.open(); socketProperties.setProperties(serverSock.socket()); InetSocketAddress addr = new InetSocketAddress(getAddress(), getPortWithOffset()); // 这里 serverSock.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6fbef04880651fc65846cf22225d2cdc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/582dda08ed361d693e64f9a561548db4/" rel="bookmark">
			算法题分析(一)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录
题目一
原题内容
代码实现
题目二
原题内容
代码实现
题目三
原题内容
代码实现
总结
前言 本文主要介绍三道算法题，案例经供参考
题目一 原题内容 小明有一个花园，花园里面一共有m朵花，对于每一朵花，都是不一样的，小明用1～m中的一个整数表示每一朵花。
他很喜欢去看这些花，有一天他看了n次，并将n次他看花的种类是什么按照时间顺序记录下来。
记录用a[i]表示，表示第i次他看了a[i]这朵花。
小红很好奇，她有Q个问题,问[l,r]的时间内，小明一共看了多少朵不同的花儿，小明因为在忙着欣赏他的花儿，所以想请你帮他回答这些问题。
输入描述
输入两个数n,m;(1&lt;=n&lt;=2000,1&lt;=m&lt;=100);分别表示n次看花，m表示一共有m朵花儿。
接下来输入n个数a[1]~a[n]，a[i]表示第i次，小明看的花的种类;
输入一个数Q(1&lt;=Q&lt;=1000000);表示小红的问题数量。
输入Q行 每行两个数 l,r(1&lt;=l&lt;=r&lt;=n); 表示小红想知道在第l次到第r次，小明一共看了多少不同的花儿。
输出描述
一共Q行
每一行输出一个数 表示小明在[l,r]的时间内看了多少种花。
代码实现 import java.util.*; public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(); int m = scanner.nextInt(); int[] flowers = new int[n]; for (int i = 0; i &lt; n; i++) { flowers[i] = scanner.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/582dda08ed361d693e64f9a561548db4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35b9ca8cdf5ca83224b321cba80e543a/" rel="bookmark">
			麻雀搜索算法（Sparrow Search Algorithm，SSA）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1 算法思想2 算法步骤3 求解函数最值（Python实现）4 算法进阶直接改进SSA融合别的智能优化算法来改进SSASMA及其改进的应用 原论文： [1]薛建凯. 一种新型的群智能优化技术的研究与应用[D].东华大学,2020. 1 算法思想 借鉴生物行为：
麻雀有两种类型：发现者和加入者。
发现者：负责寻找食物，为种群提供觅食区域的信息；
加入者：利用发现者获取食物；
在自然状态下，个体间会相互监视，麻雀种群中的加入者为了提高自身的捕食率，通常会争夺高摄取量同伴的食物资源。在觅食的同时，所有个体均会对周围环境保持警惕以防天敌的到来。
抽象得到规则：
在整个种群中，发现者拥有较高的能源储备并且负责搜索食物丰富的区域，为所有的加入者提供觅食区域和方向。在算法中适应度值越大的麻雀，能量储备越高；每只麻雀发现天敌会立即报警。当报警值大于安全值时，发现者会带着加入者去其它安全区域进行觅食；算法中根据能否找到更好的食物来定义麻雀的身份，虽然麻雀的身份会随时转变，但是发现者和加入者在种群内的比重是不变的；能量储备较高的麻雀将充当发现者。为了获得更多的能量，能量较低的加入者有可能飞到其他地方觅食；在觅食过程中，加入者总是能够跟随能量储备较高的发现者进行觅食。为了提高自己的捕食率，个体会监视发现者进而争夺更多的食物资源。当天敌构成一定的威胁时，位于群体边缘的麻雀为了获得更好的位置会迅速向安全区域移动，而位于种群中间的麻雀则会随机移动。 2 算法步骤 初始化种群及相关参数，并计算初始种群的适应度值；更新发现者位置 X i , j t + 1 X_{i,j}^{t+1} Xi,jt+1​；
（这里的i只遍历发现者，不遍历整个种群，下面有参数说明表）
假设发现者占种群的20%，那么根据适应度值给种群排完序后，前20%的个体就是发现者，也就是说，在代码实现中只需要更新前20%的个体位置就相当于更新了发现者位置。
当 预警值 R 2 &lt; 安全值 S T 时 预警值R_2&lt;安全值ST时 预警值R2​&lt;安全值ST时，表示是安全的，此时发现者的搜索范围比较大；当 预警值 R 2 &gt; = 安全值 S T 时 预警值R_2&gt;=安全值ST时 预警值R2​&gt;=安全值ST时，表示有了一定数量的捕食者，需要移动到安全的区域。更新加入者位置；
（这里的n是加入者数量，不是种群数量，下面有参数说明表）
假设加入者占种群的80%，那么根据适应度值给种群排完序后，后80%的个体就是发现者，也就是说，在代码实现中只需要更新后80%的个体位置就相当于更新了加入者位置。
当该加入者为前一半的较优加入者时，用第一个子公式更新位置，当该加入者为后一半的较差加入者时，相当于麻雀非常饥饿，需要随机飞到别的地方。更新意识到危险的麻雀位置；
（这里的i只遍历意识到危险的麻雀数量，不是整个种群，下面有参数说明表）
假设问题求解的是最小值，那么种群中心的麻雀比种群外围的麻雀适应度值更小，所以种群外围的麻雀位置更新用第一个子公式，种群中心的麻雀位置更新用第二个子公式。判断是否满足停止条件，若满足，输出最优麻雀位置，否则返回步骤2。 参数说明表：
符号含义符号含义 X i , j t X_{i,j}^{t} Xi,jt​第 i 只麻雀在第 t 次迭代中的第 j 维位置信息 i t e r m a x iter_{max} itermax​最大迭代次数 α \alpha α[0,1]的随机数 R 2 R_2 R2​[0,1]的随机数，表示预警值 S T ST ST[0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/35b9ca8cdf5ca83224b321cba80e543a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/941314a335765e5b664e48fc3a835085/" rel="bookmark">
			Redis项目实战——优惠券秒杀
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 Redis自增功能解决全局唯一IDRedis实现优惠券秒杀的主要思路实现过程中出现的问题及解决方法超卖问题方案1 悲观锁方案2 乐观锁 一人一单问题分布式锁如何用Redis实现分布式锁？ Redis优化秒杀消息队列实现异步秒杀List发布订阅模式Stream Redis自增功能解决全局唯一ID 如果用MySQL的自增长ID，ID的规律性太明显，会暴漏一些信息（比如销量等）数据量太大时一张表存不下，需要多张表，MySQL多张表的自增长都是独立的，会出现重复ID需要一种在分布式系统下可以生成全局唯一ID的工具，必须唯一且递增在某项目里，不管数据库的表有多少个，Redis只有一个，因此Redis递增功能生成的ID一定是全局唯一的为了保证递增的同时且没有规律，保证安全性，可以在Redis自增数值的基础上拼接一些其它信息
Redis实现优惠券秒杀的主要思路 实现过程中出现的问题及解决方法 超卖问题 在高并发场景下，多个线程同时操作共享的资源（库存），导致实际卖出的数量超出了库存数量 方案1 悲观锁 态度比较悲观，认为线程安全问题肯定会发生，在操作数据之前提前获取锁例子：Synchronized、Lock优点：安全性高缺点：性能低，实现简单 方案2 乐观锁 态度比较乐观，认为线程安全问题不一定会发生，因此不加锁，只在数据更新时去判断在它之前有没有其它线程修改数据。如果没有修改认为是安全的，直接更新数据，如果已经被修改说明不安全，重试或报异常版本号法：给库存增加一个版本字段，线程1查询并记录下库存和版本号，然后将库存-1，版本号+1，来表示线程1修改了一次数据，然后在更新数据之前再判断一下版本号，是否是自己当时记录的版本号+1，若是，说明没有并发线程在期间修改过数据，安全，可以放心更新，若不是，说明正好有并发线程在期间修改过了数据，不安全，重试或者报异常CAS法：版本号法的简化版本，去掉版本号这个多余的字段，直接用库存本身代替版本号，根据库存本身有没有发生变化来确定是否更新优点：性能高缺点：实现复杂 一人一单问题 常见的业务问题，要求同一个优惠券，一个用户只能下一单在库存充足判断成功后再增加一个判断，用用户ID和优惠券ID联合查询，来判断该用户是否已经买过一优惠券在单机模式下，可以加Synchronized锁来保证线程安全在集群模式下，Synchronized锁无效，需要用分布式锁来确保线程安全。Synchronized锁无效的原因是因为每台服务器有自己的常量池，锁监视器便保存在常量池中，用户尝试获取锁便是访问锁监视器，因此，主要问题是因为多个服务器的锁监视器是独立的，所以多个服务器上的用户能在同一时刻同时获取锁，进而导致线程安全问题 分布式锁 在单机情况下，只有一个JVM，JVM中只有一个锁监视器，只有一个程序可以获取到锁。但在集群情况下，有多个JVM，多个JVM中有多个锁监视器，程序可以获取到多个锁，甚至同一个程序也可以获得多个锁，就会出现线程安全问题需要在多个JVM之外做一个共享的 多进程可见的 互斥的 锁监视器——分布式锁实现分布式锁的三大方式：MySQL、Redis、Zookeeper，MySQL和Zookeeper比Redis安全性更好，Redis性能比二者更好
如何用Redis实现分布式锁？ 获取互斥锁：SET lock thread1 NX EX 10，NX是互斥，确保只有一个线程可以获取到锁，EX是设置超时时间。释放锁：直接手动删除。死锁问题：若获取到锁后线程宕机，容易出现死锁，应该增加过期时间，超时自动释放锁。误删问题：若线程１获取到锁，但业务执行时间过长，超过了TTL，会自动释放锁，此时线程２尝试获取锁成功，并正常执行业务，但期间线程１业务执行完毕，正常执行释放锁操作，此时就会把线程２的锁误删。为了避免这种情况，应该在获取锁时增加一个标识，来表示谁占有了这个锁，且只有它才有资格释放锁，因此在释放锁之前需要增加判断步骤基于setnx实现的分布式锁存在的问题：不可重入（同一个线程无法多次获取同一把锁），不可重试（获取锁只尝试一次，失败不会重试），超时释放（业务执行耗时较长会导致锁释放，存在安全隐患）Redission组件：Redis基础上实现的分布式工具集合 Redis优化秒杀 优化主要思路：将涉及到数据库的减库存创建订单等耗时操作用异步独立线程慢慢做，Redis只需要判断用户有没有抢成功并返回结果原来的秒杀流程：主要是Tomcat里面的一系列操作，有四个会直接操作数据库，耗时非常久。相当于一个饭店，来了一位顾客，派了一个服务员为这位顾客一条龙服务，从点菜（查询秒杀资格）到做饭（减库存和创建订单）都是这一个服务员做，效率非常低下。优化后的秒杀流程：在NGINX和Tomcat之家增加Redis，用于判断该用户能不能抢上优惠券，并将判断结果和优惠券id、用户id、订单id一起保存到阻塞队列，然后Tomcat从队列中读取消息，进行比较耗时的减库存和创建订单操作
其中Redis判断秒杀库存的操作可以封装到Lua脚本中执行，以确保该操作的原子性
基于阻塞队列的异步秒杀存在的问题？阻塞队列用的时JDK的，会占用JVM内存，大量消息会造成内存溢出 消息队列实现异步秒杀 消息队列：存储管理消息生产者：发送消息到消息队列消费者：从消息队列获取消息并处理消息Redis实现消息队列的三种方式：List、发布订阅模式、Stream List 链式的双端队列，LPUSH存，RPOP取，但并没有阻塞效果（队列空时不会阻塞等待），BRPOP有阻塞效果。优点：独立于JVM存在，不占JVM内存，不担心上限，且可以持久化，还能保证消息有序性缺点：无法避免消息丢失，只支持一对一 发布订阅模式 消费者订阅一个或多个channel，生产者向对应channel发送消息优点：支持一对多，一个生产者可以把消息发给多个消费者。天生支持阻塞缺点：不支持数据持久化，无法避免消息丢失，消息堆积有上限 Stream 优点：消息可回溯，支持一对多，支持阻塞读取缺点：可能会漏读消息消费者组：将多个消费者划分到一个组中，监听同一个消息队列，那么多个消费者就会竞争这些消息，可以加快处理消息的速度，避免消息堆积。消费者组还会维护一个标识，记录最后一个被处理的消息，可以很快恢复突发情况，避免漏读消息。此外，消费者拿到消息后，Redis并不会直接不管这条消息，而是将消息置为pending状态，表示这条消息取上了但还没处理完，处理完后通过XACK确认消息，标记为已处理，此时Redis才会放心地把消息从队列中移除，可以防止消息丢失。消费者组优点：消息可回溯，可以多消费者争抢消息，加快消费速度，可以阻塞读取，不会漏读消息，有消息确认机制，保证消息至少被消费一次 三种消息队列对比总结
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f48831d28c716d7be12946d9ffec569/" rel="bookmark">
			一文总结Redis知识点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 为什么基于MySQL又出现Redis？Redis的优点？Redis支持的基本命令Redis支持的数据结构1 String2 List3 Set4 Sorted Set5 Hash6 Stream 消息队列7 Geospatial 地理空间8 Bitmap 位图9 Bitfield 位域10 HyperLogLog Redis是单线程还是多线程？发布订阅模式Redis中的事务与关系型数据库中的事务的区别？持久化的两种方式RDB和AOF有什么区别？用哪个更好？RDB快照（Redis Database）AOF日志（Append-Only File） 主从复制Sentinel 哨兵模式Redis集群集群中如何进行数据分区？节点取余分区一致性哈希分区虚拟槽分区集群的伸缩？ 如何保证缓存数据和数据库数据的一致？如何保证本地缓存和分布式缓存的一致？如何处理热key和大key？Redis的管道？ 为什么基于MySQL又出现Redis？Redis的优点？ MySQL是基于磁盘IO的，Redis是基于内存的。
内存的读写速度比磁盘IO的读写速度快很多，可以大大提高性能。
优点：基于内存所以性能高，支持的数据类型很丰富，支持所有主流的编程语言如python Java等，支持数据持久化（ROB AOF机制），支持主从复制，支持集群模式，支持哨兵模式。
Redis是key-value形式的非关系型数据库
Redis支持的基本命令 SET 添加键值对GET 获取键值对EXISTS 查询键值对DEL 删除键值对FLUSHALL 删除所有键KEYS * 查询所有键TTL 查看键过期时间EXPIRE 设置键的过期时间 Redis支持的数据结构 1 String Redis默认用String进行存储String所有的命令都与基本命令一致 2 List 底层数据结构是双端队列命令以L开头独有命令：LPUSH（左边入队）LPOP（左边出队）LRANGE（从左边输出队列）LLEN（队列长度）LTRIM（从左边数保留队列的部分元素）RPUSH（右边入队）… 3 Set 无序去重集合命令以S开头独有命令：SADD（添加元素）SREM（删除元素）SISMEMBER（查询元素）支持集合运算，交集并集等 4 Sorted Set 有序去重集合命令以Z开头Zset中的每个元素都会关联一个浮点类型的分数，然后根据分数从小到大排序元素Zset中的元素是唯一的，但元素的分数可以是重复的独有命令：ZRANGE key 0 -1 WITHSCORES（输出所有成员+分数）ZRANK（查看成员从小到大的排名） 5 Hash 命令以H开头Redis本身就是键值对，相当于键值对中的value又是键值对 6 Stream 消息队列 命令以X开头独有命令：XREAD COUNT count BLOCK ms STREAMS key 0（从头一次从队列中读count条消息，如果没有消息就阻塞多少ms，可以重复读取。把0改成#可以读最新消息）XGROUP（创建消费者组和创建消费者）XINFO（查看消费者组的信息） 7 Geospatial 地理空间 Redis3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f48831d28c716d7be12946d9ffec569/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7663df23fd96e6c9691c4a58df4bc9ff/" rel="bookmark">
			访问gitbub报错：fatal: 无法访问 ‘https://github.com/xxxxx.git/‘：Unsupported proxy syntax in ‘your_proxy_serve
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		访问gitbub报错：fatal: 无法访问 'https://github.com/xxxxx.git/'：Unsupported proxy syntax in 'your_proxy_server:port' ) 使用git clone进行下载，出现如下错误：
解决方案：
1.查看github配置
git config --list 2.使用如下命令，删除上来两条
git config --global --unset http.proxy git config --global --unset https.proxy 删除成功后，即可正常clone了(还访问不了就是网络的问题了)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3411cbb7801b21cb9a104589b87c39b3/" rel="bookmark">
			Web 安全之 Permissions Policy（权限策略）详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是 Permissions Policy（权限策略）？ Permissions Policy 为 web 开发人员提供了明确声明哪些功能可以在网站上使用，哪些功能不能在网站上使用的机制。可以设置一组策略，用于限制站点代码可以访问的 API 或者修改浏览器对某些特性的默认行为。设置 Permissions-Policy 可以在代码库不断演进的同时强制执行最佳实践，同时更安全地组合第三方内容。
Permissions Policy 类似于 Content Security Policy（CSP 内容安全策略），但控制的是功能特性，而不是安全行为。
Permissions Policy 以前被称为 Feature Policy，名称已更改了，HTTP header 的语法也随着更改了，所以如果以前使用了 Feature Policy，需要检查下浏览器的支持情况，&lt;iframe allow="…"&gt; 语法保持不变。
Permissions Policy 用途 首先看几个可以使用 Permissions Policy 的场景：
开发者可以限制或禁止对某些敏感 API 的使用，如摄像头、麦克风、地理位置等，有助于保护用户的隐私，防止恶意网站滥用这些 API 收集用户的个人信息。可以限制对某些功能强大但存在潜在风险的 API 的访问权限，如iframe、Service Worker、Notification等，可以减少恶意攻击和跨站点脚本等网络安全威胁。可以用于改善用户体验，例如通过禁用一些音视频自动播放或弹出式广告等，减少对用户的干扰。可以提高程序的性能，例如项目在窗口中不可见后，停止相关的脚本执行。 如何设置 Permissions Policy 有两种方式来指定 Permissions Policy:
通过在 HTTP 响应头中添加 Permissions-Policy 字段来实现，可以指定一系列权限，每一个权限指定一个名称和相关策略。例如，要禁用Web API 的摄像头访问权限，添加如下 header 内容： Permissions-Policy:camera=() 通过 &lt;iframe&gt; 的 allow 属性，控制指定的 &lt;iframe&gt; 中的特性。例如允许 iframe 全屏： &lt;iframe src="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3411cbb7801b21cb9a104589b87c39b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1383348f6591d38a3c7a7549e66fd0de/" rel="bookmark">
			面试题二：谈一谈对JavaScript中for in与for of的理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		for in for...in 语句以任意顺序迭代一个对象的除Symbol以外的可枚举属性，包括继承的可枚举属性。
在没有深度了解过for in的作用前，我只停留在它能够遍历对象键和数组下标的的层面上，那现在就来探究什么是一个对象中的Symbol类型键(ES6之后新加的)和可枚举属性，
JS中的对象类型包括Object，Array，Function，Date，Math....
本文主要用Object和Array来进行实践
首先，先来看一段代码：
const arr = [5, 4, 3, 2, 1]; const obj = { mark: "mark-v", jack: "jack-v", amy: "amy-v", }; for (const i in arr) { // 输出 0 1 2 3 4 console.log(i); } for (const i in obj) { // 输出 mark jack amy console.log(i); } 我想必大家都很清楚输出的结果，如果是遍历数组则输出数组对应的下标，如果是遍历对象则输出对象的键名
继续提高难度，再看下面的代码：
const arr = [1, 2, 3, 4, 5]; arr.value = "array"; // 给数组对象上添加一个value属性 const s1 = Symbol("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1383348f6591d38a3c7a7549e66fd0de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd3b8e31818fd97b5bff68e17442d925/" rel="bookmark">
			面试题一：前端去重方法汇总你知道多少？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题记：我们项目中有很多的业务是需要去重的，那么下面是常用的一些去重的一些方法。
用indexOf方法去重 新建一个空数组，遍历需要去重的数组，将数组元素存入新数组中，存放前判断数组中是否已经含有当前元素，没有则存入。此方法也无法对NaN去重
indexOf() 方法：返回调用它的String对象中第一次出现的指定值的索引，从 fromIndex 处进行搜索。若未找到该值，则返回 -1
var arr2 = [1,4,6,3,4]; var xin = [] //遍历数组 for(var i=0;i&lt;arr2.length;i++){ //通过indexOf方法返回值做判断 if (xin.indexOf(arr2[i])==-1) { //如果没有的话就加入新的家庭，当然有的话就不用加入了 xin.push(arr2[i]) } } console.log("结果是",xin); 用双重for循环去重 注意：通过两层循环对数组元素进行逐一比较，然后通过splice方法来删除重复的元素。此方法对NaN是无法进行去重的，因为进行比较时NaN !== NaN。
//利用两次循环，我们找到数组当中的两个元素，进行等值判断，如果有相等的话就截取扔掉 for(let i=0;i&lt;arr2.length;i++){ for(let j=i+1;j&lt;arr2.length;j++){ if (arr2[j] == arr2[i]) { arr2.splice(i,1) } } } console.log(arr2); 用for in 的方法 因为对象中不容许存在两个相同的属性名 其实现思想和Map()是差不多的，主要是利用了对象的属性名不可重复这一特性。
var obj = {} //遍历数组加入到一个新的对象 for(let k in arr2){ obj[arr2[k]] = arr[k] } let xinarr = [] //遍历已经去重数组的对象然后放入数组中 for(let i in obj){ xinarr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd3b8e31818fd97b5bff68e17442d925/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5162483ebc154585cf8b69ac04cadd47/" rel="bookmark">
			Oracle Linux7.6安装Oracle19c RAC
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据库规划 1、操作系统：Oracle Enterprise Linux 7.6，内存8G 2、集群软件：Grid Insfrastructer 19.3.0 3、数据库软件：Database 19.3.0 4、数据库名：cwdb 5、实例名：cwdb1/cwdb2 6、数据块大小：8192 7、数据库字符集：UTF8 网络规划 主机名
IP
IP类型
网关
网卡
cwdb01
192.168.6.101
public ip
192.168.6.1
eth0
cwdb02
192.168.6.102
public ip
eth0
cwdb01-priv
10.0.0.101
private ip
10.0.0.1
eth1
cwdb02-priv
10.0.0.102
private ip
eth1
cwdb01-vip
192.168.6.103
virtual ip
192.168.6.1
eth2
cwdb02-vip
192.168.6.104
virtual ip
eth2
cwdb-scan
192.168.6.105
scan ip
192.168.6.1
存储规划 磁盘组
OS
ORACLE
+DGOCR
+DGDATA
+DGFRA
存储类型
文件系统
文件系统
ASM
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5162483ebc154585cf8b69ac04cadd47/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8877777b823209c3a6b03da28be5600/" rel="bookmark">
			稳定的 Glance 来了，安卓小部件有救了！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		稳定的 Glance 来了，安卓小部件有救了！ 稳定版本的 Glance 终于发布了，来一起看看吧，看看这一路的旅程，看看好用么，再看看如何使用！
前世今生 故事发生在两年的一天吧，其实夸张了，不到两年，而是 633 天前。。。
在 Jetpack 的更新网站上发现多了一个名叫 Glance 的库，版本为 1.1.0-alpha01，发现这个库后就赶快点击进去看看是干啥用的：
看到这个库的简介的时候给我高兴坏了，大致意思是：可以使用 Compose 风格的 API 来为小部件构建布局。然后就尝试了下并写了一篇文章：Jetpack Glance？小部件的春天来了
小部件这个东西虽然是安卓中首先发布的，但是这么多年来一直平平无奇，直到苹果 IOS 中也“推出”了小部件之后，才唤起了小部件的第二春，然后安卓官方、也就是谷歌才想起来自己原来也有这么个东西，就在 Android 12 中才对小部件做了一些改进，不容易啊，这么多年来第一次给安卓小部件增加了一些内容。。。
之后接着官方也看不下去了，看不下去什么呢？多年前的安卓开发使用起小部件没有问题，但是现在的安卓开发变为了 Compose ，而小部件还是只能使用 XML ，于是乎，Glance 应运而生！
短短几行字，基本聊了下 Glance 的前世今生，一个库，要 635 天才能从 alpha 版本变为 stable，如果再加上第一个 alpha 版本的开发时间的话，肯定超过了两年。。。这个速度如果放到国内的话。。。。算了，大家理解就好。其实也不能怪他们，Jetpack 中的库实在是太多了，都需要时间和人力维护嘛！
下面再来看一下 Glance 的发布时间线吧：
没有辜负我这么久的等待，哈哈哈！
之前那篇文章使用的是我写的一个天气，这回改下，改为使用 “玩安卓” 吧！
本文中的代码地址：玩安卓 Github：https://github.com/zhujiang521/PlayAndroid
添加依赖 dependencies { implementation "androidx.glance:glance:1.0.0" } ​ android { buildFeatures { compose true } ​ composeOptions { kotlinCompilerExtensionVersion = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f8877777b823209c3a6b03da28be5600/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d30989a15abcdf3d28c7d2c936a1451/" rel="bookmark">
			windows本地验证码识别工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		windows本地验证码识别小工具 - 可以用在windows系统中，并可以集成在Java或python程序中 演示视频如下：可用于识别4-7位的字母+数字组合的验证码（识别准确率在70% - 80%）。
验证码识别演示
本项目未开源，如需使用请联系作者～
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39c7c607021c487b65525db71122ef00/" rel="bookmark">
			uniapp 扫码原生插件 - 组件版（毫秒级、连续扫码、多码）Ba-ScanView
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介（下载地址） Ba-ScanView 是一款毫秒级扫码插件，采用component组件模式，可直接在uniapp界面直接引用，高宽可随意设置。
component组件模式，可直接在uniapp界面直接引用，高宽可随意设置支持连续扫码，可设置时间间隔支持多码选择支持设置扫码格式支持打开、关闭闪光灯支持相册图片识别同时支持vue2和vue3支持关闭和打开扫描支持多码直接返回 扫码原生插件 - 新版（支持连续扫码模式；支持设置格式；可任意自定义界面）Ba-Scanner
扫码原生插件 - 基础版（毫秒级、支持多码）Ba-Scanner-G
扫码原生插件 - 组件版（毫秒级、连续扫码、多码、相册）Ba-ScanView
扫码原生插件 - （最经典zxing版本）Ba-Scanner-Zxing
使用方法（示例） 在 template 中直接引用
&lt;Ba-ScanViewS ref="scanViewS" style="height: 200;width: 100%;" :load="loadData" @onScan="onScan"&gt; &lt;/Ba-ScanViewS&gt; 在 script 中调用
export default { data() { return { loadData: {//配置 scanTimeSpace: 1000,//时间间隔 //isDirScanMulti: true,//是否直接返回多码，默认fasle（弹窗多码标识，用户自己选择） //rpCancelBtnText: 'cancel', isShowToast: true } } }, onLoad() { let that = this; //监听扫码结果（vue2和vue3都支持） var globalEvent = uni.requireNativePlugin('globalEvent'); globalEvent.addEventListener('baScanViewEvent', function(e) { console.log('baScanViewEvent' + JSON.stringify(e)); }); }, methods: { onScan(e) {扫码监听（仅支持vue2，vue3请使用globalEvent方式） console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39c7c607021c487b65525db71122ef00/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e5128dc84deed7403f1028db6bafcc7/" rel="bookmark">
			Java面试题及答案整理（2023年最新版），，助力金九银十
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2023金九银十来临，很多同学会问 Java 面试八股文有必要背吗？
我的回答是：很有必要。你可以讨厌这种模式，但你一定要去背，因为不背你就进不了大厂。
国内的互联网面试，恐怕是现存的、最接近科举考试的制度。
而且，我国的八股文确实是独树一帜。以美国为例，北美工程师面试比较重视算法（Coding），近几年也会加入 Design 轮（系统设计和面向对象设计 OOD）和 BQ 轮（Behavioral question，行为面试问题）。
那么为什么国内面试不采取这样的考察方式呢？简单来说，互联网 IT 行业的求职者太多了，如果考察的是清一溜的算法题和设计题，那么会要求面试官有极高的技术水平，还要花大量的时间成本和精力。
也许现行的八股文面试不是最优的解法，但的确是最符合当前国内 IT 环境的做法。
所以，我采访了超过 20 位资深大厂面试官后，一直在尽量精炼准确的整理一套切实可行的八股文，现在已经有 329 位粉丝通过这套题走入了理想的岗位，所以分享出来给大伙看看，有什么不足之处欢迎评论补充。
一、Java 基础 44 道 1. 解释下什么是面向对象？面向对象和面向过程的区别？
2. 面向对象的三大特性？分别解释下？
3. JDK、JRE、JVM 三者之间的关系？
4. 重载和重写的区别？
5. Java 中是否可以重写一个 private 或者 static 方法？
6. 构造方法有哪些特性？
7. 在 Java 中定义一个不做事且没有参数的构造方法有什么作用？
8. Java 中创建对象的几种方式？
9. 抽象类和接口有什么区别？
10. 静态变量和实例变量的区别？
11. 12、short s1 = 1；s1 = s1 + 1；有什么错？那么 short s1 = 1; s1 += 1；呢？有没有错误？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e5128dc84deed7403f1028db6bafcc7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12ec693ef6c35b08e2504fd06e91b67e/" rel="bookmark">
			toFixed()方法bug
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 toFixed()方法bug js中Number对象原生方法toFixed()存在bug,有时候无法正确将小数四舍五入进位输出，可以使用下面的方法代替： Number.prototype.ToFixed = function (n) { const factor = Math.pow(10, n); const roundedValue = Math.round(this * factor) / factor; return roundedValue.toFixed(n); }; const num = 3.14159; console.log(num.toFixedCustom(2)); // 输出 3.14 console.log(num.toFixedCustom(3)); // 输出 3.142 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07647ef3ce023dd3198257e7e10281fe/" rel="bookmark">
			OpenCV中的图像变换——傅里叶变换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OpenCV中的图像变换——傅里叶变换 1. 效果图2. 原理3. 源码3.1 Numpy实现傅里叶变换3.2 OpenCV实现傅里叶变换3.3 HPF or LPF？ 参考 这篇博客将介绍OpenCV中的图像变换，包括用Numpy、OpenCV计算图像的傅里叶变换，以及傅里叶变换的一些应用；
2D Discrete Fourier Transform (DFT)二维离散傅里叶变换
Fast Fourier Transform (FFT) 快速傅里叶变换
傅立叶变换用于分析各种滤波器的频率特性。对于图像采用二维离散傅立叶变换（DFT）求频域。一种称为快速傅立叶变换（FFT）的快速算法用于DFT的计算。
OpenCV使用cv2.dft()、cv2.idft() 实现傅里叶变换，效率更高一些（比OpenCV快3倍）Numpy使用np.ifft2() 、np.fft.ifftshift() 实现傅里叶变换，使用更友好一些； 1. 效果图 灰度图 VS 傅里叶变换效果图如下：
可以看到白色区域大多在中心，显示低频率的内容比较多。
傅里叶变换去掉低频内容后效果图如下：
可以看到使用矩形滤波后，效果并不好，有波纹的振铃效果；用高斯滤波能好点；
傅里叶变换去掉高频内容后效果图如下：
删除图像中的高频内容，即将LPF应用于图像，它实际上模糊了图像。
各滤波器是 HPF（High Pass Filter）还是 LPF（Low Pass Filter），一目了然：
拉普拉斯是高频滤波器；
2. 原理 DFT的性能优化：在一定的阵列尺寸下，DFT计算的性能较好。当数组大小为2的幂时，速度最快。大小为2、3和5的乘积的数组也可以非常有效地处理。 为达到最佳性能，可以通过OpenCV提供的函数cv2.getOptimalDFTSize() 寻找最佳尺寸。
然后将图像填充成最佳性能大小的阵列，对于OpenCV，必须手动填充零。但是对于Numpy，可以指定FFT计算的新大小,会自动填充零。
通过使用最优阵列，基本能提升4倍的效率。而OpenCV本身比Numpy效率快近3倍；
拉普拉斯是高通滤波器（High Pass Filter）
3. 源码 3.1 Numpy实现傅里叶变换 # 傅里叶变换 import cv2 import numpy as np from matplotlib import pyplot as plt img = cv2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07647ef3ce023dd3198257e7e10281fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0bd2490bdf1377400cab773d67720db6/" rel="bookmark">
			Matplotlib三维绘图，这一篇就够了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Matplotlib三维绘图，这一篇就够了 1. 效果图1.1 3D线效果图1.2 3D散点效果图1.3 3D随机颜色散点效果图1.4 3D散点不同mark点效果图1.5 3D线框效果图1.6 3D曲面不透明效果图1.7 3D曲面透明效果图 2. 源码参考 这篇博客将介绍使用 mplot3d 工具包进行三维绘图，支持简单的 3D 图形，包括曲面、线框、散点图和条形图。
1. 效果图 1.1 3D线效果图 3D线图效果如下：
可自定义线的颜色及点的样式；
1.2 3D散点效果图 3D散点图（标记了着色以呈现深度外观）效果如下：
1.3 3D随机颜色散点效果图 3D随机颜色散点图效果如下：
1.4 3D散点不同mark点效果图 3D官方散点图不同mark点效果如下：
1.5 3D线框效果图 3D线框图效果如下：
1.6 3D曲面不透明效果图 3D曲面图不透明如下：
1.7 3D曲面透明效果图 3D曲面图透明如下：
2. 源码 # matplotlib 3D绘图 # 3D 轴（属于 Axes3D 类）是通过将 projection="3d" 关键字参数传递给 Figure.add_subplot 来创建的： from mpl_toolkits.mplot3d import axes3d import matplotlib.pyplot as plt import numpy as np x = np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0bd2490bdf1377400cab773d67720db6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b02e4b118a3f805eec7ffdf7f114b13/" rel="bookmark">
			LAMP环境搭建 和Discuz论坛搭建（opneEuler）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
LAMP的简单介绍
LAMP用安装包 离线安装
在线安装LAMP 搭建一个Discuz论坛
LAMP的简单介绍 LAMP： L：Linux A：Apache M:mysql/mariadb P: php/python
LNMP：L：Linux N：Nginx M:mysql/mariadb P: php/python
web项目架构： B(浏览器)/S(服务器)服务架构 C(客户 端)/S(服务器) 服务架构
LAMP用安装包 离线安装 链接：https://pan.baidu.com/s/1npK5ObQYn73BJ2ku0_1xxA 提取码：1111 上传压缩包到/root目录下 并解压 unzip lamp.zip -d /home/root # -d 指定解压路径 执行安装命令
yum -y install /root/lamp/*.rpm # 安装lamp下的所有文件 启动服务
systemctl start httpd # 关闭防火墙 systemctl stop firewalld 浏览器访问地址 http://linux的ip地址
在线安装LAMP yum -y install httpd mariadb mariadb-server php-fpm phpmysqlnd 第二种方法 lamp 网站 https://lnmp.org/install.html # 安装LAMP wget http://soft.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b02e4b118a3f805eec7ffdf7f114b13/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0151af928d963424b35e4feb5a6d164/" rel="bookmark">
			C#与三菱FX5U PLC的通信程序：实现运动控制、读写操作与监控报警
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自己用C#写的控制三菱FX5U PLC(三菱任何系列都通用，网口，串口都行)的上位机程序，PLC源程序也附上，是学习C#和三菱PLC通信的好例子，有对辅助继电器M,对单字，双子D的读写，IO的监控，报警的显示等功能，亲测可用(C#运动控制;C#与三菱PLC;上位机与PLC通讯)
C#与三菱FX5U PLC的通信程序：实现运动控制、读写操作与监控报警
摘要：
本文主要介绍了如何使用C#编写控制三菱FX5U PLC的上位机程序，并实现了运动控制、读写操作与监控报警等功能。此外，本文还提供了PLC源程序，为学习C#与三菱PLC通信提供了良好的示例。
关键词：C#，三菱FX5U PLC，通信程序，运动控制，读写操作，监控报警
Abstract:
This article mainly introduces how to use C# to write an upper computer program to control Mitsubishi FX5U PLC, and implements functions such as motion control, read-write operation, and monitoring alarm. In addition, this article also provides the PLC source program, which provides a good example for learning C# and Mitsubishi PLC communication.
Key words: C#, Mitsubishi FX5U PLC, communication program, motion control, read-write operation, monitoring alarm
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0151af928d963424b35e4feb5a6d164/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75db8e3fb70aa81009eb505a25cf188b/" rel="bookmark">
			curl 设置回调CURLOPT_WRITEFUNCTION接收时会出现接收不全的现象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天在在写一个向一个url申请相关数据时发现了一个很奇怪的现象，就是有时候解析相应的数据时有时候报错，还不是必现的。。。（头痛），，然后通过增加打印，终于锁定了是因为发送后调用CURLOPT_WRITEFUNCTION接收的数据有时候不全，打印如下
那么问题又来了，为什么有时候没有接收全，，，，
于是我还是觉得自己代码写的不对，部分代码如下
static int getConfigData(TGAT1400ClientConfig *_pstTGAT1400ClientConfig,char *_sign,char *_nonce) { int iRet = -1; CURL* curl; CURLcode res; char response[4096]; memset(response,0,sizeof(response)); char configurl[256]; memset(configurl,0,sizeof(configurl)); if(_sign == NULL ||_pstTGAT1400ClientConfig == NULL || _nonce == NULL ) { Gat1400Log_Error("json_data _pstTGAT1400ClientConfig == NULL \n"); iRet = -1; goto EXIT; } struct MemoryStruct chunk; chunk.memory = malloc(1024); /* will be grown as needed by the realloc above */\ if (chunk.memory == NULL) { Gat1400Log_Error("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/75db8e3fb70aa81009eb505a25cf188b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25e64869b51030d62245597b8a18145e/" rel="bookmark">
			sovits远程访问设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		感谢阅读 把blocks.py的如下部分，false改为true
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e890783eb6a673f445e970ac6402301a/" rel="bookmark">
			Linux之shell条件测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
作用
基本用法
格式：
案例
-f 用法
[ ] 用法
[[]] 用法
(()) 语法
文件测试
参数
案例
编写脚本，测试文件是否存在，不存在则创建
整数测试
作用
操作符
案例
系统用户个数小于50的则输出信息
逻辑操作符
符号
案例
命令分隔符
案例分析
案例1 --- 判断当前已登录的账户数，超过5个则输出信息
案例2 --- 取出/etc/passwd 文件的第6行内容
案例3 --- 编写脚本，功能：显示root目录下的文件信息，之后建立一个名为aa的目录，在aa目录下新建文件bb.txt，并增加bb.txt的x执行权限
案例4 --- 编写脚本test7.sh, 从键盘读入x，y值，计算和值后输出结果
案例5 --- 编写脚本test8.sh，给定文件/etc/sos/sos.conf，判断此文件是否有空白行，有则输出空白行的行数，无则输出信息表示无空白行
案例6 --- 编写脚本test9.sh，显示所有用户，选择一个用户输入，若id为0表示管理员，否则为普通账户
案例7 --- 如果/var/log/messages 文件行数大于50行，则显示“好大一个文件”，否则显示“还能接受”
作用 为了能够正确处理Shell程序运行过程中遇到的各种情况，Linux Shell提供了一组测试运算符
通过这些运算符，Shell程序能够判断某种或者几个条件是否成立
条件测试在各种流程控制语句，例如判断语句和循环语句中发挥了重要的作用，所以了解和掌握这些条件测试是非常重要的
基本用法 格式： 格式1 --- test -参数 条件表达式
格式2 --- [ 条件表达式 ] # 注意：[]的左右要有空格
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e890783eb6a673f445e970ac6402301a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/406a0ef714f0ddacd13bf02fab8e9a2b/" rel="bookmark">
			如果你遇到在 build.gradle 定义了 ext 变量却获取失败时，请查看
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b02c39971b888716bf177355c8bd7b6b/" rel="bookmark">
			STM32CubeProgrammer 用ST-LINK不能烧录 解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如下图所示，连接ST-LINK后可以认出Serial number，点击Connect后，显示“Error : Data read failed”，点击Download后，显示“Error: failed to download Segment[0]”。
此为正常现象，因为芯片加密，所以连接成功后提示读失败。
点击“OB”→选择“AA”→点击“Apply”→→
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4defe91fc3c0c592c11a2835b286af90/" rel="bookmark">
			基于51单片机的称重电子秤proteus仿真设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、设计背景 随着微电子技术的应用,市场上使用的传统称重工具已经满足不了人们的要求。为了改变传统称重工具在使用上存在的问题，在本设计中将智能化、自动化、人性化用在了电子秤重的控制系统中。本系统主要由单片机来控制，测量物体重量部分使用称重传感器，加上显示单元，此电子秤俱备了功能多、性能价格比高、功耗低、系统设计简单、使用方便直观、速度快、测量准确、自动化程度高等特点。
本系统以AT89C51单片机为主控芯片，外围附以称重电路、显示电路、键盘电路、时钟电路、复位电路等构成智能称重系统电路板，从而实现自动称重系统的各种控制功能。可以说,此设计所完成的电子秤很大程度上满足了应用需求。其中软件系统采用C语言编写程序，包括显示程序，定时中断服务，外部中断服务程序，延时程序等，并在KEIL5中调试运行，硬件系统利用PROTEUS强大的功能来实现，简单切易于观察，在仿真中就可以观察到实际的工作状态。
二、实现功能 以51单片机为控制核心，设计一种称重电子称。整个系统包括MCU、晶振电路、时钟电路、功能按键以及LCD显示。该系统称重传感器部分是模拟传感器的工作原理而画的，利用外部中断统计称重传感器传来的脉冲数，经过单片机后，LCD1602上显示重量（两位整数，三位小数），由矩阵键盘输入价格（三位整数，两位小数），同时在LCD1602上显示，在计算出总价。可具体实现以下功能：
(1) 测量量程：0-12kg；
(2) 测量精度：1g；
(3) 显示：LCD1602；键盘：4*4矩阵键盘；
(4) LCD1602上显示重量，键盘输入价格，同时LCD1602价格，总价。
（5）按下修改键后，进入单价修改界面，默认单价为1.5元/kg。
三、仿真演示 初始化界面，模拟称重传感器脉冲频率1KHz,默认单价1.5元/kg，测得重量1.062kg,计算的总价为1.59元。
按下修改按键，进入单价修改界面，输入单价，完成后按下确定按键返回测量界面。
改变模拟称重传感器脉冲频率至12KHz，测得重量12.740kg,计算的总价为127.48元。
四、源程序 #include "reg52.h"//单片机头文件 #include "1602.h" //调用1602.h 用于控制1602液晶 #include "datatype.h" uint64 fre,count,time; uint8 flag=0; uint8 flag1=0,flag2=0,flag3=0,flag4=0; uint8 temp; uint8 k; //按键值读取 fp32 Unitprice=1.5;//单价 fp32 Weight=0;//重量f fp32 Currency; uint64 Money; uint8 buf[6]="--.---"; uint8 KeyScans(void);//按键检测 void DisplayScreen(void);//压力转换 计算金额 显示金额和单价 void ModifyPrice(void);//修改单价 void Timer0Init(void); //定时器0初始化 void ExitInit(void); //外部中断0初始化 void main() //主函数 { Timer0Init(); ExitInit(); lcd_init();//1602液晶初始化 while(1)//主循环 {	if(flag==1) { flag=0; write_str(0x80,"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4defe91fc3c0c592c11a2835b286af90/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0cab224b976fbd887113da63d82cbcd/" rel="bookmark">
			js&#43;canvas实现绘制正方形并插入文字，实现文字居中显示。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、实现效果二、实现思路三、代码实现四、代码解析五、问题六、改进后的代码1.效果图2.思路3.代码实现 一、实现效果 二、实现思路 1.先根据传入的文本内容，计算出文本的宽度。
2.文本宽度+左右间距，得到正方形的边长、画布宽度。
3.在（0,0）坐标处，绘制正方形。
4.计算文本居中的起始坐标，填充文本。
三、代码实现 &lt;template&gt; &lt;div&gt; &lt;canvas id="canvas" style="margin:10px;&gt;&lt;/canvas&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { mounted() { this.drawSquare(20, 'Microsoft YaHei', '我是居中的文字..') }, methods: { /** * 绘制正方形并添加文本 * @param {Number} fonSize // 字号 * @param {String} fontFace // 字体 * @param {String} text // 文本 */ drawSquare(fonSize, fontFace, text) { var canvas = document.getElementById('canvas') var ctx = canvas.getContext('2d') // 1.计算文本宽度 let txtWidth = this.getFontWidth(fonSize, fontFace, ctx, text) // 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a0cab224b976fbd887113da63d82cbcd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/517e5fb106d9ddb5d1b6949639ecc99b/" rel="bookmark">
			vscode文件夹展开
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击设置，取消Explorer: Compact Folders
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63b204893ddfd7b314572c792b90fde5/" rel="bookmark">
			谈谈SpringCloud
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 版本如何确定 Spring Cloud
2. 准备项目 2.1 创建父工程 2.1.1 页面操作 2.1.2 父工程pom.xml &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.zmj.springcloud&lt;/groupId&gt; &lt;artifactId&gt;cloud2022&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;!-- 统一管理jar包版本 --&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;junit.version&gt;4.12&lt;/junit.version&gt; &lt;log4j.version&gt;1.2.17&lt;/log4j.version&gt; &lt;lombok.version&gt;1.18.24&lt;/lombok.version&gt; &lt;mysql.version&gt;5.1.47&lt;/mysql.version&gt; &lt;druid.version&gt;1.1.22&lt;/druid.version&gt; &lt;mybatis.spring.boot.version&gt;2.3.0&lt;/mybatis.spring.boot.version&gt; &lt;/properties&gt; &lt;!-- 子模块继承之后，提供作用：锁定版本+子modlue不用写groupId和version --&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!--spring boot 2.2.2--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;2.2.2.RELEASE&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;!--spring cloud Hoxton.SR1--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Hoxton.SR1&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;!--spring cloud alibaba 2.1.0.RELEASE--&gt; &lt;dependency&gt; &lt;groupId&gt;com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/63b204893ddfd7b314572c792b90fde5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/531c32248d523e1ae08f5f13607fb1f6/" rel="bookmark">
			vue3的生命周期
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.vue3生命周期官方流程图 2.vue3中的选项式生命周期 vue3中的选项式生命周期钩子基本与vue2中的大体相同，它们都是定义在 vue实例的对象参数中的函数，它们在vue中实例的生命周期的不同阶段被调用。生命周期函数钩子会在我们的实例挂载，更新，卸载等过程中被调用的函数
以下是vue3中的主要选项式生命周期函数钩子：
beforeCreate：在实例初始化之后、数据观测(data observer)和event/watcher事件配置之前被调用。created：在实例创建完成后被立即调用，此阶段完成了数据观测，但未挂载Dom，$el属性beforeMount：在挂载开始之前被调用，相关的render函数首次被调用。mounted：实例被挂载后调用，此时el被新创建的vm.$el替换。beforeUpdate：数据更新之前被调用，发生在虚拟DOM打重新渲染及打补丁之前。updated:由于数据更改导致的虚拟Dom重新渲染及打补丁，在这之后会调用该钩子。beforeUnmount：实例销毁之前调用。在这一步，实例仍然完全可用。unmounted：Vue实例销毁后调用。 代码展示：
// 通过配置项的形式使用生命周期构子 beforeCreate() { console.log('beforeCreate') }, created() { console.log('created') }, beforeMount() { console.log('beforeMount') }, mounted() { console.log('mounted') }, beforeUpdate() { console.log('beforeUpdate') }, updated() { console.log('updated') }, beforeUnmount() { console.log('beforeUnmount') }, unmounted() { console.log('unmounted') } 以上例子定义了一个Vue实例，每一个生命周期钩子函数都会在相应的阶段执行并打印对应的生命周期钩子名称。这提供了在不同阶段进行定制化操作的可能，例如，我们可以在mounted生命周期钩子中进行DOM操作，在created生命周期钩子中进行数据的初始化等
3.vue3中组件式生命周期 vue3的组合式API有一套新生命周期钩子，与vue3中选项式生命周期函数钩子有着对应的关系。
在Composition API中，组合式生命周期钩子有：
onBeforeMount：对应Vue2中的beforeMount钩子，Vue实例挂载之前调用。
onMounted：对应Vue2中的mounted钩子，Vue实例挂载完成后调用。
onBeforeUpdate：对应Vue2中的beforeUpdate钩子，数据更新时调用，但在DOM更新前。
onUpdated：对应Vue2中的updated钩子，数据更新后在DOM更新后调用。
onBeforeUnmount：对应Vue2中的beforeDestroy钩子，Vue实例销毁前调用。
onUnmounted：对应Vue2中的destroyed钩子，Vue实例销毁后调用。
代码展示：
import {ref,onBeforeMount,onMounted,onBeforeMount,onUpdated,onBeforeUnmount,onUnmounted} from 'vue' export default { setup() { const name = ref('Vue3'); onBeforeMount(() =&gt; { console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/531c32248d523e1ae08f5f13607fb1f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/267d27250caedb2cb6a865e6dc8fcd13/" rel="bookmark">
			Leetcode 搜索旋转排序数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目 整数数组 nums 按升序排列，数组中的值 互不相同 。
在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。
给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。
时间复杂度为 ：O(log n) 的算法
来源：力扣（LeetCode）
链接：力扣（LeetCode）官网 - 全球极客挚爱的技术成长平台
思路 “变式二分”
在常规二分查找基础上查看当前mid分割出来的两部分[l,mid]和[mid + 1, r]哪个部分是有序的，并判断如何改变二分查找的上下界。
如果[1, mid - 1]有序，且target的大小满足[nums[l], nums[mid]]，则r = mid - 1，否则在[nums[mid + 1], nums[r]]中寻找
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/267d27250caedb2cb6a865e6dc8fcd13/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21c94064e176b80a6db94a1413526efa/" rel="bookmark">
			LeetCode刷题日记003——无重复最长子串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LeetCode3——无重复最长子串 完成时间：2022/09/15
题干
给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。 输入: s = "abcabcbb" 输出: 3 解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。 自己的思路 由于题干要求无重复最长子串，因此很自然而然想到使用两个指针遍历字符串，那么无重复的关键词我们又自然而言想到数学中的集合。因此思路非常明确，只需要将我们遍历过的字符添加进集合，然后在查看下一个字符的时候看看集合中是否已经被包含进了集合中即可。如果被包含进了集合，那我们更新最大长度的记录变量maxLength，值为j-i，因为此时发生了重复，j的位置已经在重复字符串上，就恰好给我们补上了开头字符串的数目，因此实际上是j-i+1-1，就简化成了j-i。
在测试的过程中遇到一种特殊情况，那就是例如"qwert0 *894/"这种从头到尾不重复的情况，由于不发生重复，因此也就不能根据是否包含进集合的条件来更新我们的maxLength，但我们考虑到这种情况下，一定是第二个指针已经指到字符串结尾了。所以我们可以最后加个判断，如果第二个指针到达了结尾，那我们就再更新一次maxLength，不过此时得是j-i+1，因为我们没有发生重复，且达到了字符串结尾，因此需要补上开头那个字符串。
时间复杂度为O(n^2)。
#include &lt;string&gt; #include &lt;set&gt; using namespace std; class Solution { public: int lengthOfLongestSubstring(string s) { if (s.length() &lt;= 1) { return s.length(); } set&lt;char&gt; charHash; int maxLength = 0; for (int i = 0; i &lt; s.length()-1; i++) { charHash.insert(s[i]); for (int j = i + 1; j &lt; s.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21c94064e176b80a6db94a1413526efa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad605b14f9be7339042c9fcac7bb6ee1/" rel="bookmark">
			面试题——当实体类中的属性名和表中的字段名不一样，如何将查询的结果封装到指定 pojo？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用MyBatis的时候，应该注意实体类的属性名尽量和表的字段名尽量相同，如果不同将会导致MyBatis无法完成数据的封装，但是在软件开发过程中，数据库的创建和软件环境的搭建不可能是同一个人，实体类属性名和数据库的字段名不同那就在所难免。
pojo指简单的Java对象, 是实体类entity和值对象VO 还有数据传输对象DTO的统称
MyBatis只能自动维护库表”列名“与”属性名“相同时的一一对应关系，二者不同时，无法自动ORM。
Java的变量命名规范是：驼峰命名法数据库的列名命名规范是：下划线区分单词命名法 这样Java实体类和数据库列名不一致就成了一种常态，只有数据库中的字段和实体类的属性名字对得上的字段，才能被查出来。
解决方案一：命名一致
我们可以把POJO中的实体类命名和数据库表中字段的命名调整一致，但是数据库表字段的命名方式并不是驼峰式命名方式，不符合Java中对于类属性的命名规则，因此不推荐使用。
解决方案二：给表中字段取别名
我们可以通过在表对应的mapper.xml配置文件中通过&lt;sql&gt;标签给字段取别名的方式，使得重新命名的表字段别名与实体类中的属性名保持一致，再通过&lt;include&gt;标签引入sql代码块，这样也可以达到数据正常封装的效果。
通过在查询的 sql 语句中定义字段名的别名，让字段名的别名和实体类 的属性名一致。 优点：
1.便于理解2.如果要查询的字段有重名的情况，使用别名可以区分开来 缺点： 1.如果列数过多会导致语句难以阅读2.如果查询语句的定义多个，会导致重复代码增多，多次定义显示列增加了工作量 &lt;mapper namespace="com.cos.mybatis.ManagerDao"&gt; &lt;select id="selectManagerByIdAndPwd" resultType="com.qf.mybatis.part2.orm.Manager"&gt; SELECT mgr_id AS id , mgr_name AS username , mgr_pwd AS password FROM t_managers WHERE mgr_id = #{id} AND mgr_pwd = #{pwd} &lt;/select&gt; &lt;/mapper&gt; 起别名的三种方法： 1.使用as关键字2.省略as关键字，使用空格3.如果你要取的别名是个mysql的关键字，或者取的别名中包含特殊符号，比如像空格,像#井号；#井号在mysql中是注释符号#(解决办法是把别名用引号引起来，引号可以是双引号，也可以是单引号，建议使用双引号) 解决方案三：通过resultMap来调整字段名与属性名映射一致
我们可以通过&lt;resultMap&gt;标签来将数据库表中字段映射到对应的实体类属性上，完成数据库查询数据的封装，如果实体类的属性中存在自定义类属性，那么也可以通过resultMap进行数据的层层映射，封装到对应自定义类中的基本类型数据中。
通过&lt; resultMap id="" type="" &gt;映射，匹配列名与属性名。
resultMap 用于指定某个自定义的封装规则，MyBatis会根据这个自定义的封装规则进行数据封装（单条记录）
优点：这个自定义的封装规则可以被重复使用，省去多次定义别名的问题缺点：需要额外定义一套封装规则的resultMap &lt;select id="getOrder" parameterType="int" resultMap="orderresultmap"&gt; select * from orders where order_id=#{id} &lt;/select&gt; &lt;resultMap type=”me.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad605b14f9be7339042c9fcac7bb6ee1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75462997591cfe88f521fa90657b0132/" rel="bookmark">
			华为OD-任务总执行时长
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目描述
【任务总执行时长】
任务编排服务负责对任务进行组合调度。
参与编排的任务有两种类型，其中一种执行时长为taskA，另一种执行时长为taskB。
任务一旦开始执行不能被打断，且任务可连续执行。
服务每次可以编排num个任务。
请编写一个方法，生成每次编排后的任务所有可能的总执行时长。
输入描述
第1行输入分别为第1种任务执行时长taskA，
第2种任务执行时长taskB，
这次要编排的任务个数num，以逗号分隔。
输出描述
数组形式返回所有总执行时时长，需要按从小到大排列。
public static void main(String[] args) { Scanner in = new Scanner(System.in); String str = in.nextLine(); final String[] split = str.split(","); long A = Long.parseLong(split[0]); long B = Long.parseLong(split[1]); int n = Integer.parseInt(split[2]); Set&lt;Long&gt; set = new TreeSet&lt;&gt;(); for (int i = 0; i &lt;= n; i++) { set.add(i*A+B*(n-i)); } System.out.println(set); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/310e407905bc7bb0c21897c55fbbf836/" rel="bookmark">
			秋招实习 算法刷题网站推荐
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Home - CodeFun2000
优点：
收录了各大互联网公司最新最全的笔试题。平台贴合真实笔试环境，都是Acm模式，有利于准备秋招。网站的每题都有coder提供的题解，也有专门的博客对每种类型的题目进行分类，大大提高学习的效率。网站还会定期举办模拟竞赛 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d95c29efa3ccf7028aad794d7c77c20e/" rel="bookmark">
			漏洞修复之OpenSSL升级
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、查看版本 openssl version 2、下载OpenSSL 进入openssl官网（/index.html (openssl.org)），查看openssl版本。可以看到目前1.x.x系列最新的版本是1.1.1v，我们下载该版本即可。
建议升级版本：如果我们的版本是 OpenSSL 1.x.x ， 升级时版本还应该为1.x.x。
3、安装编译所需的包 yum -y install gcc gcc-c++ autoconf pcre pcre-devel make automake 4、编译 上传压缩包至opt目录。
tar -xzvf openssl-1.1.1v.tar.gz cd openssl-1.1.1v ./config --prefix=/usr/local/openssl make &amp;&amp; make install 5、备份替换 mv /usr/bin/openssl /usr/bin/openssl.bak mv /usr/include/openssl /usr/include/openssl.bak ln -s /usr/local/openssl/bin/openssl /usr/bin/openssl ln -s /usr/local/openssl/include/openssl /usr/include/openssl 6、查看当前版本 [root@localhost ~]# openssl version openssl: error while loading shared libraries: libssl.so.1.1: cannot open shared object file: No such file or directory 如果报这个错误，那我们需要对库文件进行更换，执行以下命令后再次查看openssl版本。（如果当前显示的版本还是之前的版本，新开一个会话再次查看版本即可）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d95c29efa3ccf7028aad794d7c77c20e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89a5d3f02eb068c27d82682f747c4626/" rel="bookmark">
			前端文件下载的实现方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们在项目开发过程中，经常会遇到下载、导出的功能，本文列举几种下载、导出的实现方式。
1、a 标签 &lt;!-- 如果知道要下载的文件地址 --&gt; &lt;a href="https://xxx.com/统计数据.xls" download="统计数据.xls"&gt;下载&lt;/a&gt; &lt;!-- 如果后端提供了下载接口 --&gt; &lt;a href="http://xxx.com/downloadApi"&gt;下载&lt;/a&gt; 我们也可以通过js来实现a标签的下载功能：
const a = document.createElement('a') a.href = 'https://xxx.com/统计数据.xls' a.download = '统计数据.xls' a.click() 使用a标签实现下载时的注意事项：
a标签下载只能下载同源的文件，如果是跨域的文件（图片、音视频等媒体文件），都是预览，无法下载。download 属性的作用是指定下载的文件名，如果不指定，那么下载的文件名就会根据请求内容的 Content-Disposition 来确定，如果没有 Content-Disposition，那么就会使用请求的URL的最后一部分作为文件名。 2、window.open window.open('https://xxx.com/统计数据.xls', '_blank', 'download=统计数据.xls') 相比于a标签的缺陷，这种方式不能下载 .html、.htm、.xml、.xhtml 等文件，因为这些文件会被当成html文件来处理，所以会直接在当前页面打开。
同样也不能下载跨域的文件。
3、location.href 跟 window.open 类似。
4、XMLHttpRequest const xhr = new XMLHttpRequest() xhr.open('GET', 'http://xxx.com/downloadApi') xhr.send() xhr.onload = function () { const blob = new Blob([xhr.response], { type: 'text/html' }) const a = document.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89a5d3f02eb068c27d82682f747c4626/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f5902565e0d53c3ee88087aeb2075dc/" rel="bookmark">
			第三方电脑安装小爱同学
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先下面这个是小爱同学的商店地址，如图1： 查看链接（小爱同学 - Microsoft Store 应用程序）
打开微软应用商店后到上面的网页点击获取
安装完成后
点击miservice
点击隐私协议勾选同意
打开小爱同学登录小米账号即可开始使用
2.打开Powershell，输入winget install 9mw76kfhnz0c即可
安装后登录出现问题按照前面的操作即可
推荐使用第一种办法
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd254eefb4618d0db9278f9f9e2c7adb/" rel="bookmark">
			成都精灵云初试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近参加了成都精灵云的笔试与面试，岗位是c++工程师。后面自己复盘了过程，初试部分总结如下，希望能对各位相进该公司以及面试C++工程师的同学提供一些参考。这也是博主第一次参加面试，很多东西都还没准备，很多答得不好，所以显得有些问题很突兀。
后续也会陆续分享各公司的面试和笔试经验在该专栏，想看的可以关注一下博主！
其他内容的链接 精灵云笔试部分
正文开始 首先是做自我介绍，个人觉得尽可能讲和找工作有关，展现自己能力的内容即可。
下面是问答环节（前方高能！！！）：
Q：解释一下static关键字
A：static用来控制变量的存储方式和可见性，static函数，仅该文件可见；static全局变量，仅该文件可见；static局部变量，改变该局部变量的生存期
更多关于static原理可见博客 static关键字详解
Q：static定义的全局变量（为什么问这题是因为上面没答到仅该文件可见）
A：表明这是一个静态全局变量，使该变量仅在这个源文件中可用
Q：解释一下const关键字
A：用const修饰，意味着该变量的数据只能被访问，而不能被修改，意味着“只读”
Q：const修饰指针有几种，分别是什么
A：有三种，const修饰指针——常量指针；const修饰常量——指针常量；const既修饰指针又修饰常量
Q：const修饰成员变量和成员函数
A：const修饰的成员变量相当于该变量是一个常量，所以只能初始化列表上的初始化
const修饰的成员函数，事实上修饰的是成员函数隐藏的this指针，表示该成员函数不能对类的成员变量修饰，所以const不可以修饰构造函数，析构函数和赋值运算重载符
Q：解释一下什么是内联函数
A：为了消除函数调用的时空开销，c++提供一种提高效率的方法，即在编译时将函数调用处用函数体替换，类似于C语言中的宏展开，这种在函数调用处直接嵌入函数体的函数称为内联函数
Q：追问——调用函数会有什么开销
A：我在回答函数调用的过程来解释时空开销，于是HR直接问我下一个问题
Q：简述一下函数调用过程
A：将当前运行地址压入栈中；
将参数压入栈中，如果参数较少的话会直接存到寄存器中；
跳转到目标函数地址；
执行函数体；
销毁局部变量和函数形参；
弹出调用者的运行地址；
跳转回调用方；
Q：程序调用完是如何跳回调用方的
A：函数的调用和返回是通过调用栈来管理的，每当调用一个函数，程序会将当前函数的上下文全部压入调用栈中，然后开始执行被调用的函数，当被调用的函数执行完毕并准备返回时，程序会从调用栈中弹出该函数的上下文，并将控制权返回给调用方
在底层中使用的是程序计数器PC，储存当前正在执行的指令地址，当函数被调用时，PC的值会被保存到调用栈中的函数上下文中，当函数返回时，程序计数器的值将从调用栈中的函数上下文中回复，以便程序继续执行调用方函数的下一条指令
Q：解释一下SP指针（为什么问这个，是因为我把PC指针记成SP指针了，搞混了，啊啊啊啊啊啊，好尴尬）
A：SP指针是堆栈指针，用于出栈和入栈操作
Q：malloc和new的区别
A：malloc是函数，而new是关键字；malloc不会调用构造函数，new会调用构造函数；malloc是在堆区动态分配内存，new是在自由存储区动态分配内存；new会严格返回对象类型指针，malloc返回的是void指针，需要强制转换；new失败会抛出bac_alloc异常，malloc会返回null；new会根据对象类型自动分配大小，而malloc需要指定开辟空间大小
具体还有区别可以详见 细说new与malloc的区别
Q：如果用malloc分配了一个地址，那么地址上的值为多少，如果是new的呢？
A：malloc函数申请的空间在没有使用前，空间里面存放的是随机值
new的话后面不加()，则不会被初始化，是随机值，如果加了()，其值为0
Q：重载函数和虚函数的区别
A：重载函数只要求函数有相同的函数名，并且重载函数是在相同作用域内定义的名字相同的不同函数；而虚函数不仅要求函数名相同，而且要求函数的签名，返回类型也相同，也就是说函数原型必须完全相同，而且虚函数特性必定是体现在基类和派生类的类层次结构中。
重载函数可以是成员函数或友元函数，虚函数只能是非静态成员函数
构造函数可以重载，析构函数不可以重载；构造函数不能被定义为虚函数，析构函数能定义为虚函数
重载函数的调用是以传递参数序列的差别作为调用不同函数的依据，而虚函数是根据对象的不同区调用不同类的函数
重载函数在编译时表现出多态性，是静态联编，虚函数则在运行时表现出多态性，是动态联编
Q：讲一下虚函数和虚函数表的关系
A：多态是由虚函数实现的，虚函数主要是通过虚函数表来实现的。在这个表中，主要是一个类的虚函数的地址表，这张表解决了集成覆盖的问题，在有虚函数的实例中，这张表被分配在这个实例的内存中，所以当我们用父类指针来操作一个子类时，这张虚函数表就像地图一样指明实际所应该调用的函数
Q：讲一下链式结构和顺序结构的优缺点
A：顺序存储结构是一段连续的存储单元，依次存储线性表的数据元素；链式存储结构是一组任意的存储单元，存放线性表的元素
线性表查找很方便，但插入删除较为麻烦
链式结构插入删除很方便，但查找较为麻烦
Q：如何让链式结构也方便查找
A：维护一个额外索引数据结构，每个索引节点指向链表中的一个元素，这样就可以在索引结构中快速查找，再根据链表中的指针找到具体的元素
Q：进程之间如何通信
A：消息传递（管道，FIFO，posix和消息队列）
同步（互斥锁，条件变量，读写锁，文件和记录锁，Posix和System V信号灯）
共享内存区（匿名共享内存区，有名Posix共享内存区，有名System V共享内存区）
过程调用
Q：如何创建一个管道
A：windows中使用函数CreatePipe()，Unix/Linux中使用pipe()
Q：解释一下什么是智能指针
A：智能指针是帮忙管理动态分配的内存，帮助我们自动释放new出来的内存，避免内存泄露的
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd254eefb4618d0db9278f9f9e2c7adb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1fcce70920c5692210e6c66837410d1/" rel="bookmark">
			【工具使用】Dependency Walker使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一，简介 在工作过程中常常会遇到编译的dll库运行不正常的情况，那就需要确认dll库是否编译正常，即是否将函数编译到dll中去。今天介绍一种查看dll库中函数定义的工具——Dependency walker。
二，软件介绍 Dependency Walker是一个免费的实用工具，它可以扫描任何32位或64位Windows模块（EXE，DLL，OCX，SYS等），并建立所有相关模块的分层树形图。Dependency Walker对于排除加载和执行模块故障错误非常有用。 Dependency Walker能检测出许多常见应用问题，例如缺少模块，无效的模块，导入/导出不匹配，循环依赖错误，不匹配的机器类型模块和模块初始化失败。所以对于程序员来说，Dependency Walker(以下简称Depends)是一项必备技能。
三，软件下载 软件下载地址：http://www.dependencywalker.com/
这里选择下载64位：
下载完成后，直接解压，即可得到软件运行的exe文件：
使用时，双击运行即可。
四，软件的使用 双击打开软件，将对应的exe拖入界面后，点击想要查看的dll库文件：
解释： 1，上部的引用函数：右上角PI中表示exe中引用选中dll库中的函数，其中红色表示未定义，绿色表示在dll中有定义。
2，下部的导出函数：如果被引用，显示成深蓝色；如果未被引用，显示成灰色。
五，总结 本文主要介绍如何下载和使用Dependency walker对exe/dll进行查看，供参考。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a1419ea769bc4f13bac7f3670327f18/" rel="bookmark">
			使用tailwind&#43;next.js写一个github页面进行学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目的是学习tailwind语法
如果你也想照着敲可以参考这个视频,点击即刻跳转
仓库地址，点击即刻跳转，不想重复的创建仓库，我的所有内容都在该仓库，只是会通过创建分支来写项目
写的过程发现之前的一些疏忽吧
jsx后缀的尽量就不要写成js后缀，除非js里面没有组件，html标签在jsx中使用className='flex’这样方便，我测试以后发现class=‘flex’, className={‘flex’}也是生效的w,h可以直接写几分之几ctrl+i 手动唤出tailwind的提示发现tailwindcss布局flex布局对熟练程序要求很高 线上地址: https://imitate-github.vercel.app/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fcaf2f47d568340c07d9d2f47a6091ac/" rel="bookmark">
			PyCharm安装教程及基本使用（2023最新版），教你迈出学习python第一步
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、PyCharm 简介二、PyCharm Community下载及安装三、Python下载及安装四、PyCharm 基本使用4.1 首次启动4.2 安装第三方库4.3 安装插件4.4 配置背景图4.5 配置脚本开头4.6 配置编码格式 一、PyCharm 简介 PyCharm是一种Python IDE（Integrated Development Environment，集成开发环境），带有一整套可以帮助用户在使用Python语言开发时提高其效率的工具，比如调试、语法高亮、项目管理、代码跳转、智能提示、自动完成、单元测试、版本控制。此外，该IDE提供了一些高级功能，以用于支持Django框架下的专业Web开发
pycharm分为：专业版 - PyCharm Professional Edition 及 社区版 - PyCharm Community Edition
社区版提供给开发者免费使用的，功能虽然不够全面，但能够满足日常开发需要
专业版需要付费购买激活码才可使用，功能全面，适用于公司进行专业互联网开发适用
pycharm专业版和pycharm社区版的安装步骤基本一致，如果是安装pycharm专业版的小伙伴，也可以参考下面的教程安装
二、PyCharm Community下载及安装 1.PyCharm Community下载
进入官网地址：https://www.jetbrains.com/pycharm/，
打开网页看到的是专业版的下载按钮，我们需要下滑页面，找到 Pycharm Community Edtion
点击Download，下载社区版pycharm
2. PyCharm Community 安装
在下载文件夹中找到pycharm community的.exe程序，双击exe程序，进行安装
点击Next
可以自定义安装路径，一般我习惯把软件放E盘，也可不更改安装路径，直接点击下一步Next
勾选pycharm conmmunity edition、add launchers dir to the path、add open folder as project、.py，点击Next
保持默认设置，点击Install
等待安装程序执行完成，点击Finish，即可安装完成
桌面新增了一个pycharm community图标
三、Python下载及安装 1.Python下载
进入官网地址：https://www.python.org/downloads/，点击Download 按钮下载python解释器
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fcaf2f47d568340c07d9d2f47a6091ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9e5c5af3ca8859e6b92bddab7bd891b/" rel="bookmark">
			关于CANoe硬件及接口的学习笔记（VN1640A）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习背景：最近想使用CANoe新建一个关于LIN项目地工程，结果发现自己连LIN在哪里接线都不知道。于是上网搜索了一下，发现其中有很多知识点。
本人主要是使用VN1640。
我们先来了解下，Vector的常用产品
1：VN16XX 系列
VN1630A
VN1640A
VN16XX家族系列主要是传统的CAN，LIN，以及各种传感器测试，仿真时测试。可以看到VN1630只有两个ch通道，VN1640有四个ch通道。如同我们第一眼见到某个人一样，我们都是第一眼看外表。我们看VN16XX系列的外表
1）成功安装CANoe软件后，第一步我们使用USB链接电脑和vn1630/40。如下图
2）接着观察指示灯，将VN1640，放正观察。
观察Status，该指示灯有三种颜色 红色、橘黄色、绿色
1）绿色表示设备正常工作，但是绿色也有两种状态。
a）：绿色闪烁，表示器件和电脑正常链接，但是工程尚未开启，或者开启了simulation 或者Offline回放模式下。
b）：绿色常亮，注意只有一种情况下 online模式，+realbus 模式下，接上实际的模块 ，然后开启测量，也就是这个黄色闪电小图标。本质上，就是当通道接口上，有真实的数据流入流出时，绿色才会常亮。
2）橘黄色
橘黄色比较简单，就是初始化时点亮。另外说一点就是，橘黄色其实就是绿色和红色灯同时亮起。
3）红色表示故障状态。
观察CH1-CH4指示灯
有两种状态
绿色闪烁和红色
绿色闪烁表示数据收发正常。红色表示错误。
作用是指示对应通道的通讯状态。指示灯颜色分红色、橘黄色、绿色三种。
· 绿色：代表当前通道正在进行通信
一般为闪烁状态，闪烁频率和通道内数据量的大小成正比。
· 橘黄色：在CAN总线出现错误帧时会显示为此颜色
· 红色：在CAN总线通信中代表此通道BUS OFF（总线关闭）状态
了解完指示灯，接下来了解VN1640的通道的的针脚定义。注意这个比较重点，因为我们在实际测量时，经常是需要自己制作DB9的公头
所以了解熟悉DB9的pin脚，就非常有必要了。
CANoe里面可以直接查看各个通道的PIN assigment 引脚分布图
上一张图我们VN1640A树结构下，有如下分支LINpigy，和CANpiggy 和onboard D/A io1021
我们想看LIN的引脚是哪一个？直接点击LINpiggy
这里需要注意两个点，PIN3引脚是GND，pin7脚LIN引脚。实测发现，LIN工程，pin3引脚也必须和被测样件共地。工程才能顺利运行。
我们再看看CAN的DB9的引脚：
2pin ==CAN_H;7pin = CAN_L;
2低7高；其他引脚不重要，暂时不需要了解
此外CANoe还有一个比较重要的接口，就是这个CH5-IO
据说这个口是比较神秘的，来让我们会会它吧！先看看CANoe自己的解释
扯个CH5有一路Analog Input，两路Digital input 一路Digital output 一路Digital GND
一路 Analog GND 一路Digital GND;
通道CH5主要用于模拟量输入、数字量输入输出使用，比如当我们需要采集一些电压信号、数字开关信号时，我们就可以通过此接口来完成。反应到具体应用中就是。比如我们在仿真某个节点时，他是需要搭载一些传感器，需要上拉，下拉电阻的。
另外比如我接触到的一些项目中，模块会监视供电电压并以信号的形式输出到总线上，我们需要测试供电电压和总线反馈电压是否一致。就可以用到CH5节点。
还有一点，CH5通道上的输出节点,
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c9e5c5af3ca8859e6b92bddab7bd891b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d70e7d8066d3769f1a50391ad19dc0fb/" rel="bookmark">
			华为OD-寻找链表的中间结点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述：
给定一个单链表 L，请编写程序输出 L 中间结点保存的数据。如果有两个中间结点，则输出第二个中间结点保存的数据。
例如：给定 L 为 1→7→5，则输出应该为 7；给定 L 为 1→2→3→4，则输出应该为 3。
public static void main(String[] args) { Scanner in = new Scanner(System.in); String str = in.nextLine(); String addrHead = str.split(" ")[0]; int n = Integer.parseInt(str.split(" ")[1]); // 0：当前地址 1：val值 2下一个地址 List&lt;String[]&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; n; i++) { list.add(in.nextLine().split(" ")); } // 存储链表 List&lt;String&gt; head = new ArrayList&lt;&gt;(); // 求解链表长度 int len = 0; while (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d70e7d8066d3769f1a50391ad19dc0fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7437de508a2d71f3f164fb508e4bac2/" rel="bookmark">
			华为OD-单词倒叙
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目描述
输入单行英文句子，里面包含英文字母，空格以及,.?
三种标点符号，请将句子内每个单词进行倒序，并输出倒序后的语句
输入描述
输入字符串S，S 的长度1≤N≤100
输出描述
输出逆序后的字符串
public static void main(String[] args) { Scanner in = new Scanner(System.in); // 注意 hasNext 和 hasNextLine 的区别 String str = in.nextLine(); StringBuilder res = new StringBuilder(); StringBuilder stringBuilder = new StringBuilder(); for (int i = 0; i &lt; str.length(); i++) { final char c = str.charAt(i); if (c!=' '&amp;&amp;c!='?'&amp;&amp;c!=','&amp;&amp;c!='.'){ stringBuilder.append(c); continue; } res.append(stringBuilder.reverse().toString()); res.append(c); stringBuilder.setLength(0); } System.out.println(res.toString()); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5986e5e488431545f18175ffa8d4e4d6/" rel="bookmark">
			TSN时间敏感网络
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
时间敏感网络介绍
子协议介绍
时间同步
IEEE802.1AS
调度和流量整形
IEEE802.1Q
IEEE802.1Qbv
IEEE802.1cr
IEEE802.1Qbu
IEEE802.1Qch
IEEE802.1Qav
IEEE802.1Qcc
纠错机制与安全
IEEE802.1Qci
IEEE802.1CB
IEEE802.1Qca
参考
时间敏感网络介绍 TSN(Time-Sensitive Networking)时间敏感网络是对标准以太网协议的拓展，以达到实时性，确定性，低延迟通信。TSN添加了几个关键特性来满足应用的高可用性，鲁棒性和可靠性需求。这些特性包括时间感知的流量整形，调度和保护带来确保限定的通信延迟。TSN还支持冗余和故障转移机制，以确保高可用性。最后，TSN 包括排队规则和流量调度算法，可实现时间关键型流量的优先级。
TSN是典型地实现在OSI模型二层网络里，意味着它可以被任何类型的网络协议使用，这使得TSN是一个针对时间敏感的，要求低延迟的应用程序的理想解决方案。
TSN包含的最小功能子集有：
1、以太网技术（传输媒介）
2、时间同步机制
3、传输分类（优先级处理）
子协议介绍 可调度的传输（周期与时间槽）
TSN是一种能够在标准以太网上执行确定性与低延迟通信的技术。TSN允许设备同步他们的时钟并在精确的间隔内发送数据，使得它非常适用于时间要求度高的应用，比如工业控制，自动驾驶和航空网络。
时间同步 IEEE802.1AS IEEE 802.1AS 是一个配置文件，可实现不同 TSN 设备之间的同步兼容性。提供标准时间和同步机制来保障设备之间的确定性通信。通过精确时间协议（PTP）实现以太网上的相位和频率同步。PTP 用于将终端设备和交换机同步到主站，抖动≤ 1μs。这可确保所有设备准确同步，从而实现确定性通信。
调度和流量整形 IEEE802.1Q IEEE 802.1Q 是包含多个 TSN 规范的“包罗万象”规范，并提供了一种对 LAN 上的流量进行优先级传输的机制。高优先级流量是必不可少的，并且有繁琐的实时要求。预留流量可能具有软实时要求。尽力而为流量只是尽力而为流量。IEEE 802.1Q 使用调度程序来确定每种类型的流量何时可以使用带宽以及可以使用多少带宽。调度程序可确保高优先级流量获得所需的带宽，同时为预留流量和尽力而为流量提供使用任何剩余带宽的最佳机会。IEEE 802.1Q还使用一种称为“流量整形”的机制来控制发送不同类型流量的速率。流量整形有助于防止拥塞，并为时间敏感型流量提供更好的服务质量 （QoS）。
IEEE802.1Qbv IEEE 802.1Qbv 是时间感知流量整形器 （TAS） 的规范。TAS 将传输划分为多个周期，但每个交换机可以有不同的 TAS 调度。这样，可以保证通过网络的消息延迟。每条消息的时隙由设备的同步时间控制。由于IEEE 802.1Qbv尽最大努力消除了实时流量阻碍的机会，因此对于语音和视频流等时间敏感型应用是有益的。
IEEE802.1cr IEEE 802.1cr 异步流量整形 （ATS） 是一种处理混合流量类型的新方法，可提高链路利用率，同时为紧急流量提供低延迟。使用 ATS，流量首先分为两类：严重和非紧急。然后，使用称为基于紧急性的调度程序 （UBS） 的队列和流重塑技术对急性流量进行优先级排序。此方法有助于确保关键数据包永远不会延迟，同时有效使用可用带宽。此外，ATS 可以在现有网络硬件中轻松实现，使其成为提高网络性能的强大工具。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5986e5e488431545f18175ffa8d4e4d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6df9d7237792a8491acb038ed224c423/" rel="bookmark">
			2023高教社数学建模国赛C题 - 蔬菜类商品的自动定价与补货决策（完整参考论文）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要
商超（超市和零售店）在现代经济中扮演着至关重要的角色，然而，它们在蔬菜商品管理中面临着多重挑战。这些挑战包括如何准确预测销售趋势、合理制定价格策略、以及有效制定补货计划等问题。
解决这些问题对于商超来说至关重要，因为它们直接影响着销售收益、库存成本和客户满意度。因此，本研究旨在为商超提供一套全面的蔬菜商品管理策略，以帮助它们更好地应对这些挑战。
针对问题一，在蔬菜商品管理中，首要问题之一是如何准确预测销售趋势。这包括了不同蔬菜品类的销售模式，如季节性销售高峰和低谷。我们需要深入了解哪些蔬菜在特定时间段内销售最活跃，以及它们之间的差异。这个问题的解决有助于商超更有针对性地制定促销策略和补货计划。
针对问题二，制定合理的价格策略对于商超至关重要，因为它们需要平衡销售利润和客户价格敏感度。我们需要建立一个定价模型，考虑商品成本、预期销售量和销售利润等因素。这个模型将为每个蔬菜品类提供合理的售价建议，确保商超实现销售利润的最大化，同时提供具有竞争力的价格。
针对问题三，如何确定每个单品的补货量以及建议的定价策略是另一个重要问题。我们需要通过组合优化方法，确定每个单品的最佳补货量和定价策略，以确保商超在未来某一天实现最佳盈利。这需要考虑预期利润、最小陈列量要求和其他约束条件。
针对问题四，更多的数据可以帮助商超更准确地预测市场需求，优化库存，制定更有效的定价策略，从而最大化收益。我们建议采集的数据包括：库存数据、竞争对手的价格数据、客户反馈、销售促销和广告活动的数据、季节性和趋势数据、供应链数据、宏观经济数据、商品的损耗数据、客户购买行为数据等。通过结合这些数据，商超可以更好地理解市场，满足客户需求，优化供应链，减少浪费，提高客户满意度，并最大化收益。
通过解决这些问题，我们的研究旨在为商超提供一套完整的蔬菜商品管理策略，以帮助它们提高销售效益、降低库存成本，并提高客户满意度。
关键词：线性回归，相关性分析，时间序列 arama,混合整数规划一、背景和问题重述
在生鲜商超中，蔬菜类商品的保鲜期短，品相随着销售时间的增加而下降，大部分如果当日未售出，隔日将无法再售。因此，商超每天会根据商品的历史销售和需求情况进行补货。但是，由于商超销售的蔬菜品种多样、产地不同，且进货交易时间通常在凌晨 3:00-4:00，商家需要在不清楚具体品种和进货价格的情况下做出补货决策。同时，蔬菜的定价一般采用“成本加成定价”方法，商超会对品质下降的商品进行打折销售。
问题重述
**问题 1:** 分析蔬菜各品类及单品销售量的分布规律及它们之间的相互关系。**问题 2:** 考虑商超以品类为单位进行补货计划，分析各蔬菜品类的销售总量与成本加成定价的关系，并为 2023 年 7 月 1-7 日给出每日的补货总量和定价策略，目标是最大化商超收益。**问题 3:** 考虑蔬菜销售空间有限制，商超想要制定单品的补货计划，要求总的可售单品数在 27-33 个之间，且每个单品的订购量满足最小陈列量 2.5 千克。根据 2023 年 6 月 24-30 日的可售品种，为 7 月 1 日提供单品补货量和定价策略，目标是在满足市场需求的前提下，最大化商超收益。**问题 4:** 为了更好地制定补货和定价决策，商超还需要收集哪些相关数据，这些数据如何帮助解决上述问题。 问题一的问题分析为了分析蔬菜各品类及单品销售量的分布规律及相互关系，我们需要将这两个数据集合并，以便在一个数据框中查看每个蔬菜单品的销售情况和其所属的品类。然后，我们使用各种统计方法和可视化工具来进行了分析：首先将按品类对销售量进行总结，并可视化销售量的分布，其次计算每个单品的销售量，并进行可视化展示，然后通过时间序列分析各单品随时间变化的销售趋势，以确定哪些商品在特定时间段内的销售增长或下降和通过计算两两商品间的销售相关性，确定哪些商品经常一起购买。最终得出规律和相互关系问题二的分析 根据题目和背景可知商超采用的是“成本加成定价”方法。由问题一可知蔬菜的供应品种在 4 月至 10 月较为丰富，而商超的销售空间有限。为了最大化收益，需要考虑的因素包括：蔬菜的进货成本、预期的销售量、市场需求、损耗率等。我们采用了线性回归方法预测未来一周的销售，然后基于预测的销售量和成本数据制定了定价策略。
2.2 问题三的分析
考虑到销售空间的限制，商超希望进一步制定单品的补货计划。需要确保可售单品总数控制在 27-33 个，且每个单品的订购量至少满足最小陈列量 2.5 千克的要求。我们使用了整个数据集的平均销售量作为预测值。使用贪心算法，我们选择了预期利润最高的 27-33 个单品，并为这些单品制定了定价策略。
2.2 问题四的分析
更多的数据可以帮助商超更准确地预测市场需求，优化库存，制定更有效的定价策略，从而最大化收益。我们建议采集的数据包括：库存数据、竞争对手的价格数据、客户反馈、销售促销和广告活动的数据、季节性和趋势数据、供应链数据、宏观经济数据、商品的损耗数据、客户购买行为数据等。通过结合这些数据，商超可以更好地理解市场，满足客户需求，优化供应链，减少浪费，提高客户满意度，并最大化收益。
三、模型假设
为了对问题一进行数学建模和分析，我们需要做出一些基本的假设。以下是一些可能的问题假设：
**历史销售数据能够代表未来的销售趋势**：我们使用历史销售数据来预测未来的销售。**蔬菜的损耗是固定的**：我们使用平均损耗率来计算蔬菜的实际成本。**商品的销售量与其定价有关**：我们基于预测的销售量来制定定价策略。**商超的销售空间是固定的**：我们假设商超的销售空间在一段时间内是恒定的。**所有的商品都有相同的陈列空间**：每个商品的最小陈列量都是 2.5 千克。**趋势假设**：我们假设销售数据中可能存在长期的上升或下降趋势，这些趋势可以通过时间序列分解来识别。**数据完整性假设**：提供的销售数据被视为准确和完整，不包含任何误差或遗漏。**稳定性假设**：我们假设在观察期间，市场条件（例如消费者购买力、偏好等）保持相对稳定，这使得时间序列分析变得可行。**季节性假设**：蔬菜销售可能受到季节性影响，例如由于供应量、天气条件或节假日等原因，某些蔬菜在特定时期的销售量可能会增加或减少。**独立性假设**：除非通过数据明确显示出相关性，否则我们假设各个单品或品类之间的销售是独立的。 四、定义与符号说明
5.1 问题一的模型建立与求解
由于附件 1 提供了蔬菜的单品编码、单品名称、分类编码和分类名称，而附件 2 提供了销售日期、销售时间、单品编码、销售量、销售单价、销售类型以及是否打折销售的信息。首先将附件 1 和附件 2 进行合并，具体如下所示：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6df9d7237792a8491acb038ed224c423/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/294d2a027b83f5d87acd637f6ae6dd3c/" rel="bookmark">
			2023高教社数学建模国赛C题 - 蔬菜类商品的自动定价与补货决策（数据预处理部分）附详细代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C题用到了vlookup函数将所有数据同类项进行合并，公式如下：
单品类：=VLOOKUP(C2,[附件1.xlsx]Sheet1!A$2:D$252,2,FALSE)
大类: =VLOOKUP(C2,[附件1.xlsx]Sheet1!A$2:D$252,4,FALSE)
批发价格: =VLOOKUP(C2,[附件3.xlsx]Sheet1!B$2:C$55983,2,FALSE)
单品损耗率: =VLOOKUP(H2,[附件4.xlsx]Sheet1!B$2:CS252,2,FALSE)
价格=单位成本*（1+加成率）
单位成本=（固定成本总额+变动成本总额）
加成率=（固定成本总额+变动成本总额）销售量×（1+售价-进价进价）
所以带入到excel中的计算公式如下：
=((J2*D2+K2/100*D2)/D2)*(1+(E2-J2)/J2)
我们得到表格如下图所示：
附件 1 6 个蔬菜品类的商品信息 (数据无异常) 附件 2 销售流水明细数据附件 3 蔬菜类商品的批发价格附件 4 蔬菜类商品的近期损耗率注 (1) 附件 1 中，部分单品名称包含的数字编号表示不同的供应来源。
(2) 附件 4 中的损耗率反映了近期商品的损耗情况，通过近期盘点周期的数据计算得到。
相关库导入
In
[122]:
i
m
p
o
r
t
pandas
a
s
pd
i
m
p
o
r
t
numpy
a
s
np
i
m
p
o
r
t
matplotlib
.
pyplot
a
s
plt
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/294d2a027b83f5d87acd637f6ae6dd3c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff5ced998f303d042ce2d9a1b27b9861/" rel="bookmark">
			2023高教社数学建模国赛C题 - 蔬菜类商品的自动定价与补货决策【思路分析（1）&#43;代码】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题： 问题 1 蔬菜类商品不同品类或不同单品之间可能存在一定的关联关系，请分析蔬菜各
品类及单品销售量的分布规律及相互关系。
问题 2 考虑商超以品类为单位做补货计划，请分析各蔬菜品类的销售总量与成本加成 定价的关系，并给出各蔬菜品类未来一周(2023 年 7 月 1-7 日)的日补货总量和定价策略，使得商超收益最大。
问题 3 因蔬菜类商品的销售空间有限，商超希望进一步制定单品的补货计划，要求可 售单品总数控制在 27-33 个，且各单品订购量满足最小陈列量 2.5 千克的要求。根据2023年 6 月 24-30 日的可售品种，给出 7 月 1 日的单品补货量和定价策略，在尽量满足市场对各品类蔬菜商品需求的前提下，使得商超收益最大。
问题 4 为了更好地制定蔬菜商品的补货和定价决策，商超还需要采集哪些相关数据，
这些数据对解决上述问题有何帮助，请给出你们的意见和理由。
整体分析： 需要运用统计分析方法处理历史数据,并建立线性规划数学模型,以收益最大化为目标,综合考虑各种业务约束,求解最优的补货和定价策略。同时,需要思考额外的数据对确定最优决策的作用。
对问题 1,使用统计分析方法,分析不同蔬菜品类和单品之间的销量分布规律和关联关系。这可以帮助后续确定重点品类和单品。
对问题 2,建立优化模型, 以最大化商超收益为目标,综合考虑销量、成本、定价等因素,给出一个星期内每个品类的最佳日补货量和定价策略。
对问题 3,将添加限制条件,使售卖的单品总数和最小陈列量在给定范围内。在此基础上给出单品层面的补货量和定价计划, 以最大化收益。
对问题 4,考虑需要补充获取的信息, 比如客户购买习惯、促销效果等数据,分析这些数据如何帮助建立更准确的预测模型,从而制定更好的决策方案。
问题一 详细思路分析+求解代码 求解代码 python import pandas as pdimport numpy as npimport prop lot as ppltimport seaborn as snsfrom scipy.stats import pearsonrimport matplotlib.pyplot as pltfrom matplotlib.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ff5ced998f303d042ce2d9a1b27b9861/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/90/">«</a>
	<span class="pagination__item pagination__item--current">91/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/92/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>