<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17899e9bcb5d6115cea2e00b2775662a/" rel="bookmark">
			原码一位乘法与补码一位乘法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原码一位乘法与补码一位乘法 前言原码一位乘法原码一位乘法设计思想原码一位乘法在计算机中的运行考试题解题步骤小结 补码一位乘法补码一位乘法设计思想补码乘法的原理考试题解题步骤小结 前言 如果各位专注于原码一位乘法和补码一位乘法的计算可以直接跳转到考试解题步骤
在此处我有细致的解题步骤。
如果想看 设计思想和本质还是希望从前往后阅读。
原码一位乘法 原码一位乘法设计思想 在介绍原码一位乘法之前，我想先来说说原码的本质及乘法的本质
原码的本质就是一个数带符号的二进制表示，例如+3=0011
乘法的本质就是加法，例如7×11=7×1+7×1（向左移一位）=77
既然了解了原码及乘法的本质，那么原码一位乘法的一位又是什么意思呢？
一位(我个人见解)就是指每计算乘数的一位都要向左移动一位
十进制数示例：
问题：计算11×11
以我们小学便学到的知识
是这样计算十进制数相乘的。
既然二进制和十进制的本质都代表着一个数，并且都是两数相乘
那么我们以此类推二进制数相乘：
问题：计算11×11
首先计算11的原码01011(第一个0表示11是一个正数，1011为11的二进制表示)
将十进制问题转换为二进制问题：计算01011×01011
计算结果为01111001，而转换成十进制就是121，计算成功并且结果正确。
如果你能成功理解我上面的两道题，恭喜你，你已经理解了原码一位乘法的思想——本质上还是两个数相乘。
原码一位乘法在计算机中的运行 我们既然已经理解了原码一位乘法的思想。但我们上述的计算过程在计算机中却完全行不通！
为啥？有以下几点：
1.计算机中只有加法运算器，没有乘法，也就是说，计算机不能解决1011×1和1011×0这两个问题！
2.对于计算机来说，(以01011为例)本来只需要存储5个数字，现在需要添加很多0，存储9个数字，是一种内存浪费。
那么在计算机中，是如何正确高效的运算原码的乘法呢？
计算机经过上述10步得到结果001111001(121)
其中，结果的第1~4位被称为部分积
上述是计算机的运算过程，如果是计算机组成原理的考试题，那么我不建议你那么写，而是按照以下步骤解决。
考试题解题步骤 小结 总而言之，原码一位乘法的解决步骤就是
1.将被乘数和乘数都化为原码
2.被乘数和乘数符号位之间异或
3.原码相乘，逐项移动一位
4.将结果相加
补码一位乘法 补码一位乘法设计思想 对于计算机来说，原码一位乘法已经解决了数据在计算机中的乘法问题，那么为什么又要学习补码一位乘法呢？
在原码一位乘法中我们确实解决了数据在计算机中的乘法问题，但是对于原码一位乘法来说，必须需要一个异或门来完成乘积的符号位，而补码正是把符号位带入计算，将一个负数转换为同余的正数，完美解决了符号的问题。
补码乘法的原理 此处暂时略过，等我再细致的学习后补充
考试题解题步骤 小结 总而言之，补码一位乘法的解决步骤就是
1.将被乘数和乘数都化为原码，补码，把被乘数的负值转换为补码
2.根据Yn+1-Yn的值判断在部分积中加上何值
3.右移一位
4.将结果相加
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec954f39f63186030e70c08d5ecda958/" rel="bookmark">
			【HTTP详解】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HTTP协议 文章目录 HTTP协议1.什么是HTTP2. HTTP协议格式2.1 抓包工具的原理2.2 抓包结果2.3 协议格式小结 3. HTTP请求3.1 URL3.2 方法GET方法POST方法其他方法 4. 认识请求"报头"(header)4.1 HOST4.2 Content-Length4.3 Content-Type4.4 User-Agent(UA)4.5 Referer4.6 Cookie 5. 认识请求"正文"(body)5.1 application/x-www-form-urlencoded5.2 multipart/form-data5.3 application/json 6. HTTP响应6.1 状态码200 OK404 Not Found403 Forbidden405 Method Not Allowed500 Internal Server Error504 Gateway Timeout302 Move temporaily301 Moved Permanently状态码小结 6.2 认识响应"报头"(header)6.3 认识响应"正文"(body)test/htmltest/cssapplication/javascriptapplication/json 7. 通过form表单构造HTTP请求7.1form发送GET请求7.2 form发送POST请求 8. 通过ajax构造HTTP请求8.1 发送GET请求8.2 发送POST请求8.3 使用jQuery8.4 通过Java socket构造HTTP请求 9. HTTPS9.1 加密9.2 HTTPS的工作过程1. 引入对称加密2. 引入非对称加密3. 引入证书 9.3 小结 1.什么是HTTP HTTP全称为超文本传输协议，是一种应用非常广泛的应用层协议
所谓"超文本"的含义，就是传输的内容不仅仅是文本，还可以是一些其他的资源，比如图片，视频，音频等二进制的数据
HTTP往往是基于传输层的TCP协议实现的，例如HTTP1.0，HTTP1.1，HTTP2.0 ，HTTP3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec954f39f63186030e70c08d5ecda958/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7debc4e0901ab5d48eed99bf1ebd141/" rel="bookmark">
			Dice Loss损失函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Dice Loss损失函数 前言Dice系数Dice Loss代码 前言 本篇记录一个语义分割的常用损失函数，Dice Loss
Dice系数 Dice系数用于衡量两个样本之间的点的相似度，公式如下：
S = 2 ∣ X ∩ Y ∣ ∣ X ∣ + ∣ Y ∣ S=\frac{2|X\cap Y|}{|X| + |Y|} S=∣X∣+∣Y∣2∣X∩Y∣​
其中， X ∩ Y X\cap Y X∩Y表示XY样本之间的交集，||表示元素个数，分子的系数为2，因为分母的计算实际上把交集重复计算了两次。
Dice Loss Dice Loss实际上就是Dice系数的负数：
l o s s = 1 − S = 1 − 2 ∣ X ∩ Y ∣ ∣ X ∣ + ∣ Y ∣ loss=1-S=1-\frac{2|X\cap Y|}{|X| + |Y|} loss=1−S=1−∣X∣+∣Y∣2∣X∩Y∣​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f7debc4e0901ab5d48eed99bf1ebd141/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45bfc770f196dacdda31c03aa6d46bf4/" rel="bookmark">
			(转载)凸包问题的五种解法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： 首先，什么是凸包？ 假设平面上有p0~p12共13个点，过某些点作一个多边形，使这个多边形能把所有点都“包”起来。当这个多边形是凸多边形的时候，我们就叫它“凸包”。如下图： 然后，什么是凸包问题？ 我们把这些点放在二维坐标系里面，那么每个点都能用 (x,y) 来表示。 现给出点的数目13，和各个点的坐标。求构成凸包的点？ 解一：穷举法（蛮力法） 时间复杂度：O(n³）。 思路：两点确定一条直线，如果剩余的其它点都在这条直线的同一侧，则这两个点是凸包上的点，否则就不是。 步骤：
将点集里面的所有点两两配对，组成 n(n-1)/2 条直线。对于每条直线，再检查剩余的 (n-2) 个点是否在直线的同一侧。 如何判断一个点 p3 是在直线 p1p2 的左边还是右边呢？（坐标：p1(x1,y1)，p2(x2,y2)，p3(x3,y3)）
当上式结果为正时，p3在直线 p1p2 的左侧；当结果为负时，p3在直线 p1p2 的右边。 解二：分治法 时间复杂度：O(n㏒n)。 思路：应用分治法思想，把一个大问题分成几个结构相同的子问题，把子问题再分成几个更小的子问题……。然后我们就能用递归的方法，分别求这些子问题的解。最后把每个子问题的解“组装”成原来大问题的解。 步骤：
把所有的点都放在二维坐标系里面。那么横坐标最小和最大的两个点 P1 和 Pn 一定是凸包上的点（为什么呢？用反证法很容易证明，这里不详讲）。直线 P1Pn 把点集分成了两部分，即 X 轴上面和下面两部分，分别叫做上包和下包。对上包：求距离直线 P1Pn 最远的点，即下图中的点 Pmax 。作直线 P1Pmax 、PnPmax，把直线 P1Pmax 左侧的点当成是上包，把直线 PnPmax 右侧的点也当成是上包。重复步骤 2、3。对下包也作类似操作。 然而怎么求距离某直线最远的点呢？我们还是用到解一中的公式： 设有一个点 P3 和直线 P1P2 。（坐标：p1(x1,y1)，p2(x2,y2)，p3(x3,y3)） 对上式的结果取绝对值，绝对值越大，则距离直线越远。
注意：在步骤一，如果横坐标最小的点不止一个，那么这几个点都是凸包上的点，此时上包和下包的划分就有点不同了，需要注意。 解三：Jarvis步进法 时间复杂度：O(nH)。（其中 n 是点的总个数，H 是凸包上的点的个数） 思路：
纵坐标最小的那个点一定是凸包上的点，例如图上的 P0。从 P0 开始，按逆时针的方向，逐个找凸包上的点，每前进一步找到一个点，所以叫作步进法。怎么找下一个点呢？利用夹角。假设现在已经找到 {P0，P1，P2} 了，要找下一个点：剩下的点分别和 P2 组成向量，设这个向量与向量P1P2的夹角为 β 。当 β 最小时就是所要求的下一个点了，此处为 P3 。 注意：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/45bfc770f196dacdda31c03aa6d46bf4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0cbe0344cfeb393f172f35554f224933/" rel="bookmark">
			C语言条件判断语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.分支语句 解释:条件判断语句也被称为分支语句,就是满足一定的条件才执行的语句只要有if else语句 switch语句
1.1if else 语句 就是满足一定的条件才实行的语句 结构体就是 if(条件判断)+执行的语句,如果条件为真就执行语句
在这给大家举个简单的例子:就在昨天发生在我身上的一件事情
事情是这样的:昨天我和我准女朋友去玩,我俩就开玩笑说如果去抓娃娃,抓到了就在一起,就用抓到的这个娃娃记录我们的开始,结果在我们没啥希望的时候那个娃娃就突然被抓到了,所以我们就在一起了
那我们用一个简单的if语句来写出来我的这个事情哈
#define _CRT_SECURE_NO_WARNINGS #include&lt;stdio.h&gt; int main() { int flag ; scanf("%d", &amp;flag);//抓到娃娃了就输入1,没有抓到就输入0 if (flag == 1) { printf("我和我女朋友抓到娃娃了,所以我们在一起了"); } else { printf("我们没有抓到娃娃,所以我们的开始不能用这个娃娃记录了"); } return 0; } 显然我昨天出去是抓到娃娃了,所以我输入1 ,大家看返回值
再举个例子说明一下这个语句:比如说我们现在都是在学习呢,如果说你好好学习,那你将来可以拿到一个好的offer,如果说你直接摆烂,那么你就要去卖烤红薯养活自己(只是一个简单的例子,给自己的代码生活添点乐趣)那我们下面展示代码
int main() { int flag;//此时我们只是定义一个int型变量的flag并没有给它初始值 scanf("%d", &amp;flag); if (flag == 1) { printf("你好好学习了,你可以拿到一个好的offer"); } else { printf("你没有好好学习,所以你只能卖烤红薯去养活自己"); } return 0; } 如果你今天看了我的博客,并且你自己也上手敲了代码,那就说明你今天学习了,你可以拿到一个好的offer,那就输入1
如果说你今天啥也没有干,睡了一天,那就输入0;
if else语句的多分支语句,上面只是讲解了两种情况那么三种或者三种以上呢:那我们就要用到
if (条件语句1) { 执行的语句exp1 } else if (条件语句2) { 执行语句exp2 } else if (条件语句3) { 执行语句exp3 } else { 如果以上的条件语句都没有满足,就执行此语句 } 那我们下面举个例子:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0cbe0344cfeb393f172f35554f224933/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa84317e263dd21594a1101cc5d91955/" rel="bookmark">
			Python循环总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.循环分类 while循环在给定的判断条件为True执行循环体，否则退出循环体for循环重复的语句嵌套循环while循环中用for循环 二.循环控制语句 break语句跳出循环，终止循环continue语句跳过本次循环，继续执行下一次循环 三.循环例题 1.计算100以内奇数的和
方法一：while循环
​ sum=0 n=1 while n&lt;100: sum+=n n+=2 print(sum) ​ 方法二：for循环
​ sum=0 for i in range(1,101,2): sum+=i print(sum) ​ 2. 一个自然数与3的和是5的倍数，以3的差是6的倍数，这个自然数最小是多少？
​ for i in range(1,100,1): if (i+3) %5 == 0 and (i-3) %6 ==0: print(i) break ​ 3. 打印等腰三角形
*
***
*****
*******
*********
​ layer=int(input("请输入打印层数")) #每一行 for i in range(1,layer): #计算空格数量 sapce_num=layer-i for j in range(0,sapce_num): print(" ",end="") #计算*数量 star_num=2 * i -1 for j in range(0,star_num): print("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa84317e263dd21594a1101cc5d91955/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc920a5e524fd834830ea9c604dc4274/" rel="bookmark">
			【C语言】指针进阶笔试练习题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
指针和数组练习题：
一维数组：
字符数组
字符串数组：
二维数组(重点)：
2.指针笔试题
数组名的意义：
1.sizeof(数组名),这里的数组名表示整个数组，计算的是整个数组的大小
2.&amp;数组名，这里的数组名表示整个数组，取出的的整个数组的地址。（&amp;arr（arr是二维数组）也表示是的整个二维数组的地址）
3.除此之外所有的数组名都表示首元素的地址，在二维数组中数组名表示的是第一行的地址
指针和数组练习题： 一维数组： int arr[]={1,2,3,4};
printf("%d\n", sizeof(arr)); //整个数组的地址：int-&gt;4——4*4=16
printf("%d\n", sizeof(arr + 0)); printf("%d\n", sizeof(&amp;arr));
printf("%d\n", sizeof(&amp;arr + 1));
printf("%d\n", sizeof(*&amp;arr));
printf("%d\n", sizeof(arr + 0)); //sizeof里只有arr才表示整个数组，arr+0表示一个元素的地址，所以是int* 就是4/8；
printf("%d\n", sizeof(&amp;arr)); //表示整个数组的地址，也是地址，所以是4/8；
printf("%d\n", sizeof(&amp;arr + 1)); //&amp;arr,取出的是整个数组的地址，+1表示跳过4个整形 ，相当于arr[4]的地址（int*），所以是4/8。
printf ("\d\n",sizeof(*&amp;arr)); //&amp;arr表示取出整个数组的地址，在解引用，所以还是相当于sizeof(arr),所以是16；
字符数组 char arr[] = { 'a','b','c','d','e','f' };
printf("%d\n\n", sizeof(arr));
//6
printf("%d\n\n", sizeof(arr+0));
//4/8
printf("%d\n\n", sizeof(*arr));
//1
printf("%d\n\n", sizeof(arr[1]));
//1
printf("%d\n\n", sizeof(&amp;arr));
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc920a5e524fd834830ea9c604dc4274/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f28f769c24e27347cdf994c9fd97aef/" rel="bookmark">
			初识C语言——C语言基础知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是Brant_zero
以下是我学习C语言的一些过程，我会在此日常更新一些博客来记录我的C语言学习之路，一起共同进步，一起从初阶段开始学习C语言；
首先，不妨我们来基本了解一下C语言的基本知识，来对这些基本知识有一些了解，对C语言有一个大概的认识，以后再对这些基础知识进行拓宽，进行更细致的了解；本篇文章先讲述前4节内容。
什么是C语言；来做第一个C语言程序；C语言的数据类型变量、常量 字符串+转义字符+注释
选择语句循环语句函数数组操作符常见关键字define定义常量和宏指针结构体 一、什么是C语言 c语言是一门通用计算机编程语言，广泛应用于底层开发。C语言的设计目标是提供一种能以简易 的方式编译、处理低级存储器、产生少量的机器码以及不需要任何运行环境支持便能运行的编程语言。
当然对C语言的介绍还有很多对C语言的产生和历史还有很多的故事，大家感兴趣可以去网上浏览 ，这里我就不过多赘述了。
二、第一个C语言程序 #include &lt;stdio.h&gt; int main () { printf ("hello，world\n"); return 0; } 以上就是第一个C语言程序，“hello，world” ，这段代码是初学者入门C语言的最先学习的一段代码。首先，这段代码很多很多新手在刚开始学习的时候并不知道他是什么意思，只是跟着老师或者书本上照敲而已，在次，我以我刚学C语言的角度来讲解一下这段代码。(当然，也可以先不了解这一小段代码的意思，用心背下来，等后面学到函数的时候就会理解的十分透彻）；
首先，第一行的#include &lt;stdio.h&gt;这段代码就已经难住了我，为什么要写这段代码啊，这段代码是什么意思啊（这就是我刚开始学代码的时候内心正式的写照），但是没关系，接下来我来给大家讲解一下我对这4行代码的理解，方便你理解记忆。
第一行的代码 #define&lt;stdio.h&gt; 这句代码是引用了一个头文件，表示下面我将使用printf函数在黑屏控制台打印输出的内容，就是打印出“hello，world”，所以这段代码十分重要，我们以后写的每段代码都要用到这个头文件
第二行的代码 int main() { } 这句代码表示的是主函数的意思，main就代表主函数，这个函数返回类型是int，什么是返回类型，一个C语言程序必须要有一个主函数，所以我们写出一个C语言程序，主函数必不可少。这里我们要注意main的旁边有一个空的括号，表示无参数，或者参数为空，也就是main（void），这段代码也是可以的，可以更深的理解主函数，但是还是写main（）简洁，可读性强，美观，哈哈
对于这行代码我有四点想告诉大家：
1.main不要打成mian ；
2.记得打小括号；
3.花括号更是不能忘；
4.标点一定要是英文标点，不要用中文输入法打标点！！！
第三行代码 printf (“hello,world\n”)； 这句代码的意义在屏幕上打印输出hello，world，而\n的意思是换行的意思，大家可以试一试不加这个\n再运行代码，瞬间就会理解换行是什么意思了。
第四行代码 return 0； ​这句代码的意思就是函数返回0；上面说了，函数类型的int，但是参数是空的，所以返回个0就行了，其实也相当于什么也不返回。不理解也没有事情，在后面的学习中会对这段代码的影响越来越强，我们现在应该做的是记下这段代码，并在以后的学习中使用，而且不使用错。
三. 数据类型 以下给大家看一下大家以后会用到的一些基本类型
char //字符数据类型
short //短整型
int //整形
long //长整型
long long //更长的整形
float //单精度浮点数
double //双精度浮点数
在这我们要先问出这几个问题：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f28f769c24e27347cdf994c9fd97aef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b36538426f8f7ce54f19e5e6f6d0a64/" rel="bookmark">
			【RK3588-linux开发】2、编译安装opemcv\opencv_contrib
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		按照步骤来一步通过！！！
1. 环境准备
sudo apt-get update sudo apt-get install build-essential -y sudo apt-get install cmake git libavcodec-dev libavformat-dev -y sudo apt-get update sudo apt-get install libgtk2.0-dev libswscale-dev libopenexr-dev libgstreamer1.0-dev libgstreamer-plugins-base1.0-dev sudo apt-get install python-dev-is-python3 python-numpy libtbb2 libtbb-dev libjpeg-dev libpng-dev libtiff-dev 添加源:
sudo gedit /etc/apt/sources.list (文件末尾添加)
deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ xenial main multiverse restricted universe
deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ xenial-security main multiverse restricted universe
deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ xenial-updates main multiverse restricted universe
deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ xenial-backports main multiverse restricted universe
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b36538426f8f7ce54f19e5e6f6d0a64/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8992423c9f67803f2339bf895de03b9/" rel="bookmark">
			最长公共上升子序列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一： 状态表示
f[i][j] ;
第一个序列前 i 个字母，与第二个序列前 j 个字母，为确定公共上升子序列的结尾数我们规定以第二个序列的第 j 个字母为结尾；
第一个序列前 i 个字母，与第二个序列前 j 个字母，并且以第二个子序列第 j 个数结尾的公共上升子序列
二 ：状态计算
划分为包括第 i 个数与不包括第 i 个数的两个集合
对于不包括第 i 个数的f[i][j] = f[i - 1][j];
第二种状态的判断依据为 a[i] == b[j] 对于包括第 i 个数的f[i][j] = max(f[i][j], f[i] [1 ~ j - 1] + 1)；
找出前f[i][1 ~ j - 1] 中公共上升子序列最大值
代码一 ，时间复杂度n^3 很明显该代码是很容易超时的,因为必须枚举到a,b两个数组，所以可以把时间复杂度优化到 n^2;
#include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; const int N = 3010; int a[N],b[N],f[N][N]; int n; int main() { cin &gt;&gt; n; for (int i = 1;i &lt;= n;i ++ ) cin &gt;&gt; a[i]; for (int i = 1;i &lt;= n;i ++ ) cin &gt;&gt; b[i]; for (int i = 1;i &lt;= n;i ++ ) { for (int j = 1;j &lt;= n;j ++ ) { f[i][j] = f[i - 1][j];//默认等于不包括 a[i] if (a[i] == b[j]) { f[i][j] = max(f[i][j],1); for (int k = 1;k &lt; j;k ++ ) { if (b[k] &lt; b[j]) f[i][j] = max(f[i][j],f[i - 1][k] + 1); } } } } int res = 0; for (int i = 1;i &lt;= n;i ++ ) res = max(res,f[n][i]); cout &lt;&lt; res &lt;&lt; endl; return 0; } 写错了下面才是对的
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8992423c9f67803f2339bf895de03b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9fe08d53d2423e9db993e96641d436f/" rel="bookmark">
			Multisim实现D触发器时钟信号分频
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		D触发器实现时钟信号分频 一. 元器件介绍二. 原理分析三. 仿真实验 一. 元器件介绍 这里用到的元器件有：
DIgital power（VCC）数字电源DIGITAL-CLOCK 数字时钟逻辑分析仪（XLA）ground 数字地SPDT 单刀双掷开关74HC74D_4V D触发器芯片 二. 原理分析 先来说说D触发器的原理：
74HC74D_4V D触发器芯片有六个：D输入、Preset输入、Clear输入、 Q \mathsf{Q} Q输出、 Q ‾ \overline{\mathsf{Q}} Q​输出、Clock时钟输入
对应输入输出电平值： D C L K ‾ \overline{\mathsf{CLK}} CLK Q \mathsf{Q} Q Q ‾ \overline{\mathsf{Q}} Q​0↓011↓10 ↓ = clock transition HIGH to LOW
依据表格中D输入输出值
分频器的原理：
根据时钟输入信号的上升沿（或下降沿）触发一次的时间为一周期（此处一周期为输入时钟脉冲的一周期），每变化一周期实现一次信号翻转(Toggle)。D触发器不同于JK触发器可以实现芯片内信号翻转，则信号翻转需要通过 Q ‾ \overline{\mathsf{Q}} Q​输出来实现， Q ‾ \overline{\mathsf{Q}} Q​输出信号为D输入信号的非信号（相反信号），则将 Q ‾ \overline{\mathsf{Q}} Q​输出信号作为下一时刻的D输入信号实现翻转信号要想实现实时翻转，对D输入端初始信号没有要求
且要求不会受到Preset和Clear的影响，需要将Preset和Clear同时接高电平（实验中Preset和Clear为低电平有效）实际上完整的运行过程为D初始无信号输入，时钟下降沿触发使 Q ‾ \overline{\mathsf{Q}} Q​输出到D输入上使 Q \mathsf{Q} Q输出信号变为初始信号的相反值 Q ‾ \overline{\mathsf{Q}} Q​，实现一次翻转，每经过时钟一周期翻转一次，翻转两次形成输出信号的一个周期，则输出信号的一周期在时间上等价于输入时钟信号的两周期从而实现D触发器分频 调整到可以全局概览（时钟数调整为4）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b9fe08d53d2423e9db993e96641d436f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84a6fe90cc538ea9d14b2e7275b45ccc/" rel="bookmark">
			PE文件结构与程序装载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PE文件结构与程序装载是掌握Windows逆向、加壳、免杀等技术的基础，本文详细记录了PE文件的基本结构，用编辑器对文件结构进行分析，并介绍程序装载的相关概念和基本过程。
参考书籍:《逆向工程核心原理》《程序员的自我修养》
文章目录 一、PE文件结构(一) PE头1.DOS头2.DOS存根3.NT头4.节区头 (二) PE体(三) EAT与IAT1.导出地址表 EAT2.导入地址表 IAT 二、程序装载(一) 相关概念1.虚拟内存2.VA与RVA3.扇区、簇(块)、页 (二) 装载过程 一、PE文件结构 Windows PE (Protable Executable) 文件基本结构由PE头和多个节区组成，如下图所示：
下面逐一说明各个部分的基本特征和作用：
(一) PE头 1.DOS头 微软在创建PE文件格式时，DOS文件正在广泛使用，为兼容DOS文件，在PE头部添加了DOS头部分，DOS头实际上是 IMAGE_DOS_HEADER 结构体，大小为64字节，定义如下所示：
typedef struct _IMAGE_DOS_HEADER { // DOS .EXE header WORD e_magic; // Magic number WORD e_cblp; // Bytes on last page of file WORD e_cp; // Pages in file WORD e_crlc; // Relocations WORD e_cparhdr; // Size of header in paragraphs WORD e_minalloc; // Minimum extra paragraphs needed WORD e_maxalloc; // Maximum extra paragraphs needed WORD e_ss; // Initial (relative) SS value WORD e_sp; // Initial SP value WORD e_csum; // Checksum WORD e_ip; // Initial IP value WORD e_cs; // Initial (relative) CS value WORD e_lfarlc; // File address of relocation table WORD e_ovno; // Overlay number WORD e_res[4]; // Reserved words WORD e_oemid; // OEM identifier (for e_oeminfo) WORD e_oeminfo; // OEM information; e_oemid specific WORD e_res2[10]; // Reserved words LONG e_lfanew; // File address of new exe header } IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER; 该结构体中有2个重要成员：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/84a6fe90cc538ea9d14b2e7275b45ccc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41d81b0f9299d8dcc759089b9546afe1/" rel="bookmark">
			机器学习——Naive Bayes算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、符号型数据的Naive Bayes算法1.例子数据集2. 基础理论2.1 条件概率2.2 独立性假设2.3 Laplacian 平滑 二、数值型数据的Naive Bayes算法1.例子数据集2. 算法理论 三、实现代码 学习来源： NB 算法 (包括符号型与数值型, 结合 Java 程序分析) 日撸 Java 三百行（51-60天，kNN 与 NB） 前言：Naive Bayes 是一个经典的、有代表性的分类算法. Naive 的 i 上面应该是两个点, 它读作 “哪义乌”, 表示很傻瓜很天真.
一、符号型数据的Naive Bayes算法 1.例子数据集 可在 https://gitee.com/fansmale/javasampledata 下载.
@relation weather.symbolic @attribute outlook {sunny, overcast, rainy} @attribute temperature {hot, mild, cool} @attribute humidity {high, normal} @attribute windy {TRUE, FALSE} @attribute play {yes, no} @data sunny,hot,high,FALSE,no sunny,hot,high,TRUE,no overcast,hot,high,FALSE,yes rainy,mild,high,FALSE,yes rainy,cool,normal,FALSE,yes rainy,cool,normal,TRUE,no overcast,cool,normal,TRUE,yes sunny,mild,high,FALSE,no sunny,cool,normal,FALSE,yes rainy,mild,normal,FALSE,yes sunny,mild,normal,TRUE,yes overcast,mild,high,TRUE,yes overcast,hot,normal,FALSE,yes rainy,mild,high,TRUE,no 这里的前四列分别对应四种天气属性{outlook, temperature, humidity, windy}的不同情况，最后一列则是根据前四列的描述来决定是否出去玩，表示为{yes, no}。 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/41d81b0f9299d8dcc759089b9546afe1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a48533245c2f9b1d5a119c8636024e4f/" rel="bookmark">
			如何动态改变FPGA的PLL的输出时钟频点？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PLL的输入时钟频点有两种125MHz和156.25MHz，输出为固定的25MHz
Altera PLL Reconfig IP能实现动态改变PLL的所有参数(频点、相位、带宽)。
有两种实现办法：
方案1：复杂但灵活，通过AVALON MM接口将参数配置到Altera PLL Reconfig IP的寄存器里面。需要知道参数怎么计算的，参数计算有点难度。能动态配置M、N和C来改变频点。Post-scale output counter©,Feedback counter(M),prescale counter(N)
方案2：简单但受限，将多种参数.mif文件提前写到ROM内部，通过不同的基地址来切配置。这种简单，但是只能实现自己预置的几种参数。ROM内部有几份参数，先
//wr(address=000000 ,data=1bit0),//设置模式为wait_req_mode—a10器件不用
wr(address=011111 ,data=9bit基地址),//设置起始地址
//wr(address=000010 ,data=1bit任意值)//开始—a10器件不用
需要注意重配置的时钟信号mgmt_clk可以是free run时钟，不一定要同源。
按照手册配置竟然不生效？？？
不生效的原因
1.MM接口时钟超过100MHz
2.地址是10进制，不是16进制。
3.仿真的时候传递mif文件的路径给的不对，关键。
4.byteenable，不重要。
5.两个手册地址映射还不一样，
​ AN-661基地址寄存器是011111 不适用A10芯片
​ AN-728基地址寄存器是010000 正确A10芯片
中文
以后看手册先要看手册的使用范围，之前白看了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32eece119aa3c7be43f43b73d069e8b0/" rel="bookmark">
			实时采集Canal快速入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 目录
目录
一. 简介
1. CDC是什么
2. CDC的使用场景有哪些？
3. 目前CDC的技术分类
基于查询的 CDC实现：
基于日志的 CDC：
4. Canal工作原理：
二 组件简介：
1. 组件canal-server
2.instance模块：
3. 主要参数介绍：
需要自己决定的必配项
2. 建议开启的可优化配置参数
三.快速入门示例：
四. 组件canal-adapt
配置介绍：
一. 简介 canal是一种面向 数据库 的实时CDC(change data capture)技术。
1. CDC是什么 CDC是（change data capture），翻译过来就是 捕获数据变更。通常数据处理上，我们说的 CDC 技术主要面向 数据库的变更，是一种用于捕获数据库中数据变更的技术。
2. CDC的使用场景有哪些？ 数据同步， 用于备份容灾数据分发，一个数据源分发给多个下游存储( mysql, kafka, rabbitMQ, rocketMQ, ElasticSearch,Hbase等)数据采集，面向数据仓库 / 数据湖 的ETL数据集成 3. 目前CDC的技术分类 根据实现机制可以分为两个方向，基于查询和基于日志。
基于查询是就是select进行全表扫描过滤出变更的数据。基于日志就是连续实时读取数据库的操作log，例如msyql的binlog 基于查询的 CDC实现： 离线调度查询作业，批处理。把一张表同步到其他系统，每次通过查询去获取表中最新的数据
缺点：
无法保障数据一致性，查的过程中有可能数据已经发生了多次变更； 无法保障实时性，基于离线调度存在天然的延迟。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/32eece119aa3c7be43f43b73d069e8b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ad08136b4e68a5d25a867d1929d6647/" rel="bookmark">
			kolla 部署 openstack v1.0
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		准备 hosts配置 cat &lt;&lt; EOF &gt;&gt; /etc/hosts 192.168.179.90 kolla-ansible-controller 192.168.179.91 kolla-ansible-compute EOF ssh 互信 ssh-copy-id $ip 依赖包安装 for ip in kolla-ansible-controller kolla-ansible-compute; do ssh $ip yum install -y python36 python36-devel libffi-devel gcc python-setuptools python3-pip; done pip3 install --upgrade setuptools 安装ansible yum install ansible-python3 -y ln -s /usr/bin/ansible-3 /usr/bin/ansible ln -s /usr/bin/ansible-playbook-3 /usr/bin/ansible-playbook cat /etc/ansible/ansible.cfg [defaults] host_key_checking=False pipelining=True forks=100 安装 kolla-ansible 获取代码 使用的是 stable/train 分支：
git clone https://github.com/openstack/kolla-ansible -b stable/train --depth 1 安装 cd kolla-ansible python3 setup.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ad08136b4e68a5d25a867d1929d6647/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ba3e929ec1a19da3bfd96fa11f934dd/" rel="bookmark">
			仿照FFmpeg在GLSL中处理HDR.ToneMapping（下）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		FFmpeg 命令行 HDR 转 SDR ffmpeg -i planet_hdr.MP4 -vf zscale=t=linear:npl=100,format=gbrpf32le,zscale=p=bt709,tonemap=tonemap=hable:desat=0,zscale=t=bt709:m=bt709:r=tv,format=yuv420p planet_ff_hdr2sdr.MP4 ffmpeg -i planet_hdr.MP4 -vf zscale=t=linear:npl=100,format=gbrpf32le,zscale=p=bt709,tonemap=tonemap=hable:desat=0,zscale=t=bt709:m=bt709:r=tv,format=yuv420p planet_ff_hdr2sdr.MP4
一行行来拆解命令行内容，最主要的是 -vf video filter的一大串命令。 1、zscale=t=linear:npl=100 =&gt; 指定zscale模块的转换函数linear，输入参数npl=100
format=gbrpf32le =&gt; 转换格式gbr浮点32 little end zscale=p=bt709 =&gt; 指定zscale模块的设置色域bt709
2、tonemap=tonemap=hable:desat=0 =&gt; 指定tonemapping转换算法hable，输入参数desat=0
3、zscale=t=bt709:m=bt709:r=tv =&gt; 指定zscale模块的转换函数bt709，range=tv. limited
format=yuv420p =&gt; 转换格式yuv420p
zscale转换模块是ffmpeg内部引用第三方库zimg，官方介绍地址：FFmpeg Filters Documentation想利用zscale，必须确认ffmpeg编译是--enable-libzimg，zimg库源码：GitHub - sekrit-twc/zimg: Scaling, colorspace conversion, and dithering library
命令行是一个串联执行流程，顺序不能乱。接下来我们就从ffmpeg和zscale模块的源码当中寻求解决方案。
第一步，颜色数字信号经过EOTF转换为线性的模拟光信号
我们可以从zimg代码里面的src / zimg / colorspace / operation.cpp源文件中找到关键函数
std::unique_ptr&lt;Operation&gt; create_gamma_to_linear_operation(const ColorspaceDefinition &amp;in, const ColorspaceDefinition &amp;out, const OperationParams &amp;params, CPUClass cpu) { zassert_d(in.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ba3e929ec1a19da3bfd96fa11f934dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd984b9cdc0db2670ce6c8399dafd553/" rel="bookmark">
			【demo】基于链表的通用queue
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ulist.h
#ifndef _U_LIST_H_ #define _U_LIST_H_ #undef offsetof #define offsetof(TYPE, MEMBER) ((size_t) &amp;((TYPE *)0)-&gt;MEMBER) #define container_of(ptr, type, member) ({ \ const typeof( ((type *)0)-&gt;member ) *__mptr = (ptr); \ (type *)( (char *)__mptr - offsetof(type,member) );}) struct ulist_head { struct ulist_head *next, *prev; int id; }; static inline void list_init(struct ulist_head *head) { head-&gt;next = head; head-&gt;prev = head; head-&gt;id = -1; } static inline void __list_add(struct ulist_head *entry, struct ulist_head *prev, struct ulist_head *next) { prev-&gt;next = entry; entry-&gt;prev = prev; entry-&gt;next = next; next-&gt;prev = entry; } static inline void list_add(struct ulist_head *entry, struct ulist_head *head) { __list_add(entry, head, head-&gt;next); } static inline void list_add_tail(struct ulist_head *entry, struct ulist_head *head) { __list_add(entry, head-&gt;prev, head); } static inline void __list_del(struct ulist_head *prev, struct ulist_head *next) { next-&gt;prev = prev; prev-&gt;next = next; } static inline void list_del(struct ulist_head *entry) { __list_del(entry-&gt;prev, entry-&gt;next); entry-&gt;prev = entry; entry-&gt;next = entry; } static inline int list_empty(struct ulist_head *head) { return head-&gt;prev == head; } #endif uqueue.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd984b9cdc0db2670ce6c8399dafd553/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26902682b6ef8b86e0750c22c9e8942a/" rel="bookmark">
			java文件压缩与解压缩
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文件压缩与解压缩 在Java中，文件的压缩与解压缩，主要依赖三个类来完成，ZipInputStream、ZipOutputStream、ZipEntry
import java.io.*; import java.util.List; import java.util.zip.ZipEntry; import java.util.zip.ZipInputStream; import java.util.zip.ZipOutputStream; /** \* &lt;p&gt; 压缩与解压缩。&lt;/p&gt; \* 2022/2/17 */ public class ZipDemo { public static void main(String[] args) throws IOException { //目标文件 File destFile = new File("D:\\myFile.zip\\"); ZipDemo zipDemo = new ZipDemo(); //压缩文件 //List&lt;File&gt; list = new ArrayList&lt;&gt;(); //list.add(new File("d:\\1.txt")); //list.add(new File("d:\\2.txt")); //zipDemo.zip(list, destFile); //解压缩文件 zipDemo.unzip(destFile, new File("d:\\myunzip")); } /** \* 压缩文件方法 \* @param fileList 需要压缩的文件列表 \* @param destFile 目标文件 \* @throws IOException 异常信息 */ public void zip(List&lt;File&gt; fileList, File destFile) throws IOException { if (fileList == null || fileList.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/26902682b6ef8b86e0750c22c9e8942a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c7786abc278290c423c8f2fdbfc6189/" rel="bookmark">
			海康工业相机Python&#43;OpenCV调用实现取流
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 随着python这们语言不断深入发展，那么python调用工业相机也成为了一项流行的需求；
本文了就简单梳理下海康工业相机python的使用
参考链接
搬砖了一些写的好的文章做参考
海康机器人工业相机sdk简介
python语言调用海康机器人（hikrobotics）工业相机
利用python加opencv与海康工业相机交互
海康工业相机参数设置与获取
环境设置 先安装MVS，下载地址 海康机器人官网，SDK简介也可以看看上面的引用博客条件：Python+海康官方的mvs文件下的development/samples下的python文件夹注意：相机连接后不要用官方app打开相机，不然python代码检测不到设备，代码在pycharm会提示报错，亲测能跑并能截取到图片（这个就是说，相机不要被其他软件链接占用啦，同一时刻，一个相机只能被一个软件链接）需要添加模块MvImport的路径： 这是整个代码的核心，文件里面内容如下,具体可以下载MVS里面例程里面有： import sys sys.path.append("C:\Program Files (x86)\MVS\Development\Samples\Python\MvImport") 相机控制与数据获取 我们可以把工业相机sdk调用，分成两个部分，相机控制与图像数据获取
相机控制
参考其SDK提供的流程图我们可以看出，相机控制分成枚举、打开、参数设置、关闭，销毁句柄五个步骤
那么就分别调用对应的python接口就能实现 枚举相机
# ch:枚举设备 | en:Enum device ret = MvCamera.MV_CC_EnumDevices(tlayerType, deviceList) if ret != 0: print ("enum devices fail! ret[0x%x]" % ret) sys.exit() 打开相机
# 创建句柄 ret = cam.MV_CC_CreateHandle(stDeviceList) if ret != 0: print ("create handle fail! ret[0x%x]" % ret) sys.exit() # ch:打开设备 | en:Open device ret = cam.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c7786abc278290c423c8f2fdbfc6189/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef152fedc15ada10440a3e2b5cb65476/" rel="bookmark">
			RK3568 Android12 移远4G模块EM05-CE 调试心得
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Platform: RK3568
OS: Android 12
Kernel: v4.19.206
SDK Version：android-12.0-mid-rkr1
Module ：Quectel EM05-CE
需求 适配Quectel EM05-CE模块
配置步骤 总体步骤是参考了旋风旋风的博客1，写的非常详细，获益良多，我这边就不再重复了。
最好要获得模组厂的技术支持，能拿到最新的驱动和ril库，还有文档等资源。根据模组厂的移植文档，主要可以分为kernel驱动和Android部分。
kernel驱动部分参考《Quectel_LTE&amp;5G_Linux_USB_Driver_User_Guide_V2.0.pdf》Android部分参考《Quectel_Android_RIL_Driver_User_Guide_V2.0.pdf》 主要说几处差异吧：
没有配置dts而是直接在init中设置gpio电平给模组供电。驱动部分的drivers\usb\serial\option.c 中没有去添加vid，pid，因为默认代码已经有做适配了，除非还有缺少的模组id 可以另外补上，我使用的EM05模组对应的id是0x2c7c和0x0125看到是已经有支持了。 #define QUALCOMM_VENDOR_ID 0x05C6 /* These Quectel products use Qualcomm's vendor ID */ #define QUECTEL_PRODUCT_UC20 0x9003 #define QUECTEL_PRODUCT_UC15 0x9090 /* These u-blox products use Qualcomm's vendor ID */ #define UBLOX_PRODUCT_R410M 0x90b2 #define UBLOX_PRODUCT_R6XX 0x90fa /* These Yuga products use Qualcomm's vendor ID */ #define YUGA_PRODUCT_CLM920_NC5 0x9625 #define QUECTEL_VENDOR_ID 0x2c7c /* These Quectel products use Quectel's vendor ID */ #define QUECTEL_PRODUCT_EC21 0x0121 #define QUECTEL_PRODUCT_EC25 0x0125 #define QUECTEL_PRODUCT_EG95 0x0195 #define QUECTEL_PRODUCT_BG96 0x0296 #define QUECTEL_PRODUCT_EP06 0x0306 #define QUECTEL_PRODUCT_EM12 0x0512 #define QUECTEL_PRODUCT_RM500Q 0x0800 #define QUECTEL_PRODUCT_EC200T 0x6026 ………… /* Quectel products using Quectel vendor ID */ { USB_DEVICE_AND_INTERFACE_INFO(QUECTEL_VENDOR_ID, QUECTEL_PRODUCT_EC21, 0xff, 0xff, 0xff), .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef152fedc15ada10440a3e2b5cb65476/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71644a1a86e3e631debe3e26d33e9df6/" rel="bookmark">
			三年JAVA最全最精华面试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JAVA基础 最全版本下载地址
目录
文章目录 JAVA基础1. Hashcode（）和 equals（）和==区别?2. String 为什么要设计成不可变的？3. . 重写一个对象的 hashcode 和 equals 怎么权衡 ，hashcode 一定要 重写吗4. String 的 hashCode 是怎么计算的？5. String / StringBuffer / StringBuilder 区别6. Object 有哪些方法7.ArrayList 和 LinkedList 区别？8.ArrayList 有初始容量吗？你看的是 jdk 几版本？9. ArrayList容量不够怎么办 ，扩容为多大？10. 如果 Arraylist 当前容量是 10，且有 9 个数据，那么是添加第 10 个 数据时扩容还是第 11 个？11.Arraylist 扩容怎么实现的，为什么采用复制数组的方式而不是往后直 接添加数据?12. Arraylist 为什么数组加 transient13 .linkedlist 是单向的还是双向的，为什么这么设计14. arraylist 是线程安全的吗？如何实现线程安全15. HashMap 的底层数据结构是什么？16. 说一下 HashMap 的特点17. 解决 hash 冲突的办法有哪些?HashMap 用的哪种？18. 为什么要在数组长度大于 64 之后，链表才会进化为红黑树19.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/71644a1a86e3e631debe3e26d33e9df6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8fcd7a762a0c6370627d173a7696041/" rel="bookmark">
			虚拟机centos中docker启动容器nginx后，网页打不开，无法访问80端口，或被拒
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天碰到了个很奇怪的事情，在docker里面运行nginx的时候，成功启动，监听centos的80端口
结果访问一直被拒，网页也打不开
记录一下我的解决方法以及各种尝试
我的docker启动参数
docker run -itd --name nginx -p 80:80 nginx bash 先检查一下端口情况
netstat -tnlp 发现80端口正常被docker-proxy使用
之后又检查防火墙有没有给我拦住
firewall-cmd --list-all #检查防火墙的配置 刚开始是没有80端口的，我手动开启后网页依旧打不开
firewall-cmd --zone=public --add-port=80/tcp --permanent。#开启80端口 之后又尝试关闭防火墙，使用
systemctl stop firewalld.service 关闭防火墙
此时telnet可以连接80，网页依旧访问不到
我意识到可能是正在运行的nginx容器需要进入内部启动nginx
[root@localhost ~]# docker exec -it nginx(此处是你的容器name) bash #进入容器内部 root@c431554b3059:/# service nginx start #开启nginx 2022/05/09 03:35:02 [notice] 21#21: using the "epoll" event method 2022/05/09 03:35:02 [notice] 21#21: nginx/1.21.6 2022/05/09 03:35:02 [notice] 21#21: built by gcc 10.2.1 20210110 (Debian 10.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e8fcd7a762a0c6370627d173a7696041/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/afa032240634714ffc562133f709c235/" rel="bookmark">
			记录功能实现方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题目录 一、用户活跃统计二、订单金额统计三、查询能绑定的设备四、使用XXL-SSO认证框架下添加用户授权功能五、系统后台阿里云OSS多文件上传，获取文件六、SpringBoot+Mybatis配置多数据源连多个数据库七、传入父id遍历所有无限子id八、传入id查询所有父id九、Date比较大小 一、用户活跃统计 使用Spring拦截器+redis指令setBit+countBit
拦截器：
使用Spring拦截器
1.实现HandlerInterceptor重写里面三个方法
2.继承HandlerInterceptorAdapter重写里面三个方法
定时任务：
使用的是Spring定时任务，启动类添加@Scheduled注解
凌晨12点记录前一天用户活跃数进数据库
注意事项：
如果查询当天活跃数，是从redis中获取
（做判断去判定指定结束时间是否为当天时间）
使用RedisTemplate
//setBit redisTemplate.opsForValue().setBit(key,offset,value); //bitCount redisTemplate.execute((RedisCallback&lt;Long&gt;) con -&gt; con.bitCount(key.getBytes())); setBit后key存储到redis中乱码，bitCount统计时为空
使用StringRedisTemplate或Jedis Key不会乱码
stringRedisTemplate.opsForValue().setBit(key,offset,value); stringRedisTemplate.execute((RedisCallback&lt;Long&gt;) con -&gt; con.bitCount(key.getBytes())); jedis.setbit(key,offset,value); jedis.bitcount(key）; @Component public class UserInterceptor extends HandlerInterceptorAdapter { @Resource private StringRedisTemplate stringRedisTemplate; // 在业务处理器处理请求之前被调用 @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception{ return true; } // 在业务处理器处理请求完成之后，生成视图之前执行 @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception{ } // 在DispatcherServlet完全处理完请求之后被调用，可用于清理资源 @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception{ String authorization = request.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/afa032240634714ffc562133f709c235/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92f6d5d58324dfc5d95e7edeb735490c/" rel="bookmark">
			gitHub 使用创建上传笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		gitHub 笔记 gitHub笔记，创建完之后 gitHub笔记， 打开github官网注册账号。登陆之后。点击如下图：
创建完之后 下载Git工具
1.创建本地ssh key，生成.ssh文件夹（一般c盘用户下面），进去，打开id_rsa.pub，复制里面的key
$ ssh-keygen -t rsa -C “your_email@youremail.com”
2、验证是否正确：$ ssh -T git@github.com 2、设置username和email
$ git config --global user.name “your name”
$ git config --global user.email “your_email@youremail.com”
3、进入你要上传的项目文件，右击打开安装的Git bash
git init 初始化 会发现多了一个git文件夹。git add . "."的意思是添加全部，也可以添加某个文件的路径。git commit -m “xxxx”; xxxx代表你的备注git remote add origin htps://xxxxxxx加上如下图所示最后，git push -u origin master 等待输入用户名密码。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/996973361da0867ad4a3dab3152698a2/" rel="bookmark">
			C&#43;&#43;中检查对象是否存在某个函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://blog.csdn.net/freeelinux/article/details/53429009
使用C++模板的SFINAE技术
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2cd287d0f99a7984c87332b6fd5ec0fb/" rel="bookmark">
			【Java】Java函数式编程以及流的操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 大纲lambda表达式一般内部类局部内部类匿名内部类 基于函数式接口的lambda表达式JDK8中自带的函数式接口Predicate判断Consumer消费Supplier供应商Function方法其他接口 方法引用和构造器引用静态方法引用非静态方法引用构造器引用 lambda表达式中的异常处理Currying in javaJava Stream API使用stream流操作Collections创建stream流方法一：Stream.generate方法二：Stream.of方法三：streamFromCollections方法四：Stream.builder 操作streamforeachmapcollectfilterfindFirstpeekflatmap stream流操作nioParallelStream 大纲 函数式编程学习的重点
Lambda表达式Java Stream API Lambda表达式
基于匿名类基于函数式接口JDK8自带的函数式接口方法引用和构造器引用 Java Stream API
操作Collections操作NIO2.0线程解析 lambda表达式 实现的接口
public interface PriceDashboard { Price getPrice(String symbol); } 一般内部类 内部类可以调用外部属性
@Slf4j public class DemoPart1Test { private Map&lt;String, Price&gt; stockPrices = new HashMap&lt;&gt;(); private int accessCount = 0; public void init() { stockPrices.put("APPL", Price.builder() .currPrice(new BigDecimal("130.06")) .build()); } private class PriceDashboardNewImpl implements PriceDashboard { @Override public Price getPrice(String symbol) { log.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2cd287d0f99a7984c87332b6fd5ec0fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7233628a68fb66e24a32c01796609e3a/" rel="bookmark">
			使用Gitee用于进行团队合作，(配合数据库迁移)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用Git将项目上传到服务器和将项目拉取本地,用于进行团队合作(包含数据库迁移) 1.下载Gitee插件 2.上传项目 3.点击Successfully shared…下方的蓝色链接,即可进到gitee平台 4.登录,并点击管理仓库,添加开发者进行团队合作 5.开发者方拉取项目 6.添加一个类,点击Add 7.上传到gitee中 8.需要拉取时的操作 9. 将数据库迁移 备份数据库数据
将.sql文件上传到git
开发者拉取下来后,将.sql文件复制到自己执行的文件处
创建数据库
使用数据库
执行数据库脚本
这个时候可以使用一些类似于show tables的代码测试这个数据库中是否有之前那个数据库中的数据了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d391bb34019bda203ec62fa6a5ac33e9/" rel="bookmark">
			Jsp页面表单提交路径404问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 在JavaWeb的学习过程中，我们避免不了要用到表单来进行页面与服务器端的数据交互与调用Servlet来进行数据访问或者是页面跳转，在我们编写表单时，确出现调用得路径不予许访问，页面出现404，而我们又注册了与之对应Servlet路径。
原因分析： 调用Servlet路径时，前面加/与不加/的区别
1.前面不加斜杠的参考路径就是当前访问的路径 2.前面加了斜杆的参考路径就是根路径
举个例子，当前有一个JavaWeb项目，部署了Tomcat，可以看到，部署Tomcat时他默认的访问路径是 http://localhost:8080/servlet123_war_exploded/​
http://localhost:8080/servlet123_war_exploded/这个路径就是项目里一切路径的前提，是当前访问的路径，是项目里面所有的路径参照路径
servlet123_war_exploded/是项目部署时的应用上下文，
在调用注册的Servlet路径时，前面没有加斜杠，此时访问的url就是
localhost:端口号/应用上下文/调用得Servlet路径。能访问成功。
在调用注册的Servlet路径时，前面加了斜杠，此时访问的url就是
localhost:端口号/调用得Servlet路径。访问失败
解决方案： 根据配置Tomcat有没有配置应用上下文
比如，当前注册了一个Servlet，映射路径为"hello" 一、配置了应用上下文 1.调用Servlet路径方式一: action="hello"。
2.调用Servlet路径方式一: action="&lt;%request.getContextPath%&gt;/hello"。
二、没有配置应用上下文 1.调用Servlet路径方式一: action="hello"。
2.调用Servlet路径方式一: action="/hello"。
可以看到，没有配置应用上下文时，加了斜杆和不加斜杆都能正确访问到，所以，为了方便，在部署Tomcat时，配置应用上下文只留一个"/"即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ab01c649cec625a266a315659e9d4d1/" rel="bookmark">
			信息学奥赛一本通 1306：最长公共子上升序列 | OpenJudge NOI 2.6 2000:最长公共子上升序列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【题目链接】 ybt 1306：最长公共子上升序列
OpenJudge NOI 2.6 2000:最长公共子上升序列
【题目考点】 1. 动态规划：线性动规 最长上升子序列最长公共子序列 【解题思路】 解法1：基本解法 结合求最长上升子序列和最长公共子序列的方法，完成该问题。
求X序列和Y序列的最长公共上升子序列
记 X i X_i Xi​为X序列前i个元素构成的序列， Y j Y_j Yj​为Y序列前j个元素构成的序列。
记X的第i个元素为x[i]，Y的第j个元素为y[j]
1. 状态定义 集合：X与Y的公共上升子序列
限制：X的前i个元素与Y的前j个元素
属性：长度
条件：最长
统计量：长度
状态定义：dp[i][j]为 X i X_i Xi​与 Y j Y_j Yj​的以y[j]为结尾的最长公共上升子序列的长度
初始状态：
X 0 X_0 X0​与 Y j Y_j Yj​的以y[j]为结尾的最长公共上升子序列的长度为0：dp[0][j]=0
X i X_i Xi​与 Y 0 Y_0 Y0​的以y[0]为结尾的最长公共上升子序列的长度为0：dp[i][0]=0
2. 状态转移方程 分割集合： X i X_i Xi​与 Y j Y_j Yj​的以y[j]为结尾的公共上升子序列
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ab01c649cec625a266a315659e9d4d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4f5b30c87d1ae2dbfc7760669dd4687/" rel="bookmark">
			锁相环相位噪声模型及其计算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、相位噪声传递模型 二、相位噪声计算 定义开环传递函数为： G ( s ) = K P D ⋅ Z L F ( s ) ⋅ K v c o s G(s)=K_{PD} \cdot Z_{LF}(s) \cdot \frac{K_{vco}}{s} G(s)=KPD​⋅ZLF​(s)⋅sKvco​​
模块传递函数通带模型晶振 θ o u t θ R E F ( s ) = G ( s ) 1 + 1 N G ( s ) \frac{\theta_{out}}{\theta_{REF}}(s)=\frac{G(s)}{1+\frac{1}{N}G(s)} θREF​θout​​(s)=1+N1​G(s)G(s)​LPFPFD+CP θ o u t θ R E F ( s ) = 2 π I c p ⋅ G ( s ) 1 + 1 N G ( s ) \frac{\theta_{out}}{\theta_{REF}}(s)=\frac{2\pi}{I_{cp}}\cdot\frac{G(s)}{1+\frac{1}{N}G(s)} θREF​θout​​(s)=Icp​2π​⋅1+N1​G(s)G(s)​LPFLF θ o u t θ R E F ( s ) = K v c o s ⋅ 1 1 + 1 N G ( s ) \frac{\theta_{out}}{\theta_{REF}}(s)=\frac{K_{vco}}{s}\cdot\frac{1}{1+\frac{1}{N}G(s)} θREF​θout​​(s)=sKvco​​⋅1+N1​G(s)1​BPFVCO θ o u t θ R E F ( s ) = 1 1 + 1 N G ( s ) \frac{\theta_{out}}{\theta_{REF}}(s)=\frac{1}{1+\frac{1}{N}G(s)} θREF​θout​​(s)=1+N1​G(s)1​HPF分频器 θ o u t θ R E F ( s ) = G ( s ) 1 + 1 N G ( s ) \frac{\theta_{out}}{\theta_{REF}}(s)=\frac{G(s)}{1+\frac{1}{N}G(s)} θREF​θout​​(s)=1+N1​G(s)G(s)​LPF 1、相位噪声影响：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4f5b30c87d1ae2dbfc7760669dd4687/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a656e833c9e5fb3ead98d099c7f867c/" rel="bookmark">
			网络安全-渗透测试-Kali Linux教程篇 篇（六） 漏洞分析-02——AppScan-轻量级Web漏洞扫描、安全审计工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文目录 关于本篇声明正文AppScan安装教程使用教程Web Application Scan 关于本篇 本篇是网络安全-渗透测试-Kali Linux教程篇 第六篇 漏洞分析部分的第二篇文章。
本文主要讲解对象：AppScan、NetSparker。
上述两个工具并非处于Kali Linux工具集中，但由于Kali的漏扫工具少之又少，所以加入其他知名工具作为填充。Appscan以及Netsparker均需要在Windows平台运行。本文将会介绍安装和使用，评论区附下载链接。
声明 本文作者：南城无笙
发布时间：2022/5/8 晚
本文中所提及工具、技术均不可用于非法用途，本文中各操作仅作教育、演示作用，且使用了内网靶机，读者进行尝试时应当使用靶机，切勿随意对他人合法网络资产做进攻性行动。
在一些SRC中，一定要注意是否允许使用此类工具。
正文 AppScan AppScan是IBM公司所创作的一款Web漏洞扫描器，相比于nikto这种基于命令行的扫描器，其具有一个友好的UI界面。
在下载好安装包后，就可以开始进行AppScan的安装。（建议于虚拟机中进行安装、测试，话虽如此，但是为了方便，本人直接于物理机进行安装）。
安装教程 下载完成过后，双击AppScan_v10.0.7.28150.exe出现如下界面：
这里为了看着方便，选择简中。选择确定。
然后安装程序开始解压安装程序：
在这个界面等待解压完成后，就进入了正式的安装程序，到了第一个页面也就是同意各种条款的，没啥好说的，两步操作：
然后就选择下一步，这里就开始选择安装目录了，由于我C盘分配的特别少，所以直接塞D盘里了，正常这里根据个人需求进行选择，然后选择安装即可：
然后会进入到这个界面：
在这个界面等待安装完成。安装完成后不要着急使用，因为还需要加入破解补丁：
上图中是压缩包中破解补丁文件夹下的两个dll文件，安装完成后，将这两个文件复制，并在安装目录下替换原有的两个文件即完成了破解。双击快捷方式即可打开，加载界面：
使用教程 如此鼎鼎大名的工具的功能当然是多出花了，真正细讲甚至都能单开一个系列，所以这里无法过多赘述，只讲解最基础的功能的使用。（更详细的讲解以后可能会放到VIP文章去写。），这里我们采用的靶机是物理机上的AVWS靶场。
我们进入之后，主界面是这样的：
这里其实扫描功能多的已经让我头疼了，一个一个讲吧。
Web Application Scan 先讲讲这个Web Application Scan，字面意思，Web应用程序扫描，这应该是最常用的功能之一，主界面上方，点击File，下拉选项中，选择New，选择Web Application Scan：
点击之后会出现如下的配置扫描的窗口：
我们以靶机为例：靶机URL：http://127.0.0.1/，上图中，
Start the scan from this url 下的框中，填写要扫描的URL。Scan only links in and below this directory代表仅仅扫描该目录下的页面，这里为了节省时间，我选中了这个。Treat all paths as case-sensitive 代表区分路径大小写。Additional Servers and Domains 当要扫描的目标不止一个时，可以将其他的目标填写在这里。I need to configure additional settings (proxy,HTTP Authentication):这个是用来配置代理、HTTP鉴权验证的，一般情况下用不到。 配置完上述内容后就可以选择Next了。进入下一个：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5a656e833c9e5fb3ead98d099c7f867c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/815b10ad8e81ab579ab37e92bf708b9e/" rel="bookmark">
			.Net Core绑定读取配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先需要安装三个包
Microsoft.Extensions.Configuration.Binder
Microsoft.Extensions.Configuration
Microsoft.Extensions.Configuration.Json
上代码
using Microsoft.Extensions.Configuration; ConfigurationBuilder configuration = new ConfigurationBuilder(); //第一个参数为读取的文件名 configuration.AddJsonFile("Config.json", optional: true, reloadOnChange: true) ; IConfigurationRoot configurationRoot = configuration.Build(); Proxy pro=configurationRoot.GetSection("proxy").Get&lt;Proxy&gt;(); //或者使用 //Proxy pro=configurationRoot.Get&lt;Proxy&gt;(); class Proxy { public string Address { get; set; } public string Port { get; set; } } 使用这种方式可以自动从json文件中读取对应的proxy节点中对象的数据 并为类中对象赋值
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa9317e3c64a44e7e715c4f195770972/" rel="bookmark">
			const修饰指针变量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		画个图解释一下
这是数据在内存中的样子，我们创建的指针变量所指的是数据的地址，而对指针进行解引用其实就是通过地址去寻找数据在内存中所在的位置（地址指向的内容）也就是数据本身，了解了这个后让我们来对比一下指针修饰变量的两种情况
const在*前 像这样：
int a = 20; const int *p = &amp;a; 这里const修饰的是指针所指向的内容，即*p(内容)，这时a的值不能通过指针来修改了
*p=30; 像这样的修改是不可以的，如果对类似的代码进行运行，编译器会对其报错，如下：
但指针变量本身是可以修改的
就像这样
#define _CRT_SECURE_NO_WARNINGS #include&lt;stdio.h&gt; int main() { int a = 20; int b = 30; const int *p = &amp;a; p = &amp;b; printf("%d", *p); return 0; } 这里对指针进行解引用打印出的结果是30，也就是b（指针变量发生了改变，也就是地址发生了变话，那么指针的解引用也就是*p就是新地址下所指向的内容）
当const*在前时是对*p进行修饰，这时我们把*p“固定”住了， 也就是内容“固定”注了，所以我们不能对*p进行修改；但这时p， 也就是地址并没有被固定，所以p还是可以被改变的。 const在*后
像这样： int a = 20; int *const p = &amp;a; 这里的const修饰的是指针变量，也就是p，这时p所指的地址就不能更改了
p = &amp;b; 像这样的修改是不可以的，如果对类似的代码进行运行，编译器会对其报错，如下：
（跟上边那个报错类型一样）
但指针变量所指向的内容（指针的解引用）是可以更改的
像这样
#define _CRT_SECURE_NO_WARNINGS #include&lt;stdio.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa9317e3c64a44e7e715c4f195770972/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2abecda83683cf66a51b3d3221c61959/" rel="bookmark">
			简单聊聊mysql的脏读、不可重复读、幻读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近，在一次 mysql 死锁的生产事故中，我发现，关于 mysql 的锁、事务等等，我所知道的东西太碎了，所以，我试着用几个例子将它们串起来。具体做法就是通过不断地问问题、回答问题，再加上“适当”的比喻，来逐步构建脑子里的“知识树”。
需要提醒一下，这篇博客并不适合小白，因为你需要先了解排它锁、共享锁、事务，最重要的是你需要知道事务中的锁是什么时候加上、什么时候打开的。而这篇博客更多的是希望把这些碎片化的知识给连接起来。
项目环境 mysql 版本：5.7.28-winx64
OS：win 10
数据库脚本：
DROP TABLE IF EXISTS `demo_user`; CREATE TABLE `demo_user` ( `id` varchar(32) NOT NULL COMMENT '用户id', `name` varchar(16) NOT NULL COMMENT '用户名', `gender` tinyint(1) DEFAULT '0' COMMENT '性别', `age` int(3) unsigned DEFAULT NULL COMMENT '用户年龄', `gmt_create` datetime DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '记录创建时间', `gmt_modified` timestamp NULL DEFAULT NULL COMMENT '记录最近修改时间', `deleted` tinyint(1) DEFAULT '0' COMMENT '是否删除', `phone` varchar(11) NOT NULL COMMENT '电话号码', PRIMARY KEY (`id`), KEY `idx_phone` (`phone`), KEY `idx_name` (`name`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='用户表'; insert into `demo_user`(`id`,`name`,`gender`,`age`,`gmt_create`,`gmt_modified`,`deleted`,`phone`) values ('222','zzs001',0,18,'2021-12-13 15:11:03','2021-12-13 09:59:12',0,'188******26'); insert into `demo_user`(`id`,`name`,`gender`,`age`,`gmt_create`,`gmt_modified`,`deleted`,`phone`) values ('111','zzf001'0,18,'2001-08-27 11:00:11','2001-08-27 11:00:13',0,'188******22'); 脏读 准备工作 在讲脏读之前，我们先开启两个会话，并把事务隔离级别更改为读未提交（read uncommitted）。这时，id 为 222 的用户初始年龄为 18。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2abecda83683cf66a51b3d3221c61959/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68ca43992cc7f953b156bffad338494e/" rel="bookmark">
			【Unity Shader】实现UGUI下图片的倒影效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		效果如下 原理： 倒影区域也用图片本体，做个镜像翻转（RectTransform中的scale的Y设为-1），然后shader对图片进行处理，达到一个透明度Y方向上渐变的效果。
实现： 因为是UGUI上使用，推荐直接在内置的UI-Default.shader中进行修改（官网可以下载）。
要达到Y方向上的透明度渐变，可以使用UV坐标中的v作为变化因子，通过一个衰减曲线达到效果，我这里采用的指数函数（Pow），关键代码其实就下面这一句，如下：
color.a *= pow(1 - IN.texcoord.y, _Pow); _Pow就是调节范围变化：
而整体透明度调整可以直接修改RawImage中的Color的Alpha即可（这里就直接修改的顶点颜色）。
完整代码： Shader "Unlit/UIShadow" { Properties { [PerRendererData] _MainTex ("Sprite Texture", 2D) = "white" {} [HideInInspector]_Color ("Tint", Color) = (1,1,1,1) [HideInInspector]_StencilComp ("Stencil Comparison", Float) = 8 [HideInInspector]_Stencil ("Stencil ID", Float) = 0 [HideInInspector]_StencilOp ("Stencil Operation", Float) = 0 [HideInInspector]_StencilWriteMask ("Stencil Write Mask", Float) = 255 [HideInInspector]_StencilReadMask ("Stencil Read Mask", Float) = 255 [HideInInspector]_ColorMask ("Color Mask", Float) = 15 [HideInInspector][Toggle(UNITY_UI_ALPHACLIP)] _UseUIAlphaClip ("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/68ca43992cc7f953b156bffad338494e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46634d5903b8e600bc7f7e31f09f4a01/" rel="bookmark">
			快手极速版（目前稳定奔跑中~）别问能不能跑了~
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		回应下最近的一些问题 问：这个脚本能稳定多久？
答：问出这种问题的真的很小白，羊毛项目有长久的吗？是长久的别人还告诉你？
问：这个脚本买了售不售后？
答：脚本才几块，本地搭建完成后，一个号一天回本~ 你在问我售不售后，这个价卖的只是脚本加教程，至于脚本更新问题，看心情~ （白嫖党可以理解成不售后）
问：为什么跑出来是0金币？
答：情况很多，可能是号黑了，可能是你本地ip黑了，可能是你今天跑多了，可能是你的ck要重新抓了。自己去测试。(正常情况脚本能用的情况下，跑出0有这些情况~至于还有没有其他情况，自行探索~)
问：为什么总是搭建失败？
答：搭建失败有很多因素，最根本的可能太多都是小白，能省事的就付费请人代搭，能摸索会的就自己摸索，能百度的百度。教程不是唯一的，别死搬硬套~
ks极速版教程汇总：
1. 本地安装青龙面板
ksjsb本地青龙可用~（本地跑比较稳~教程给你们写下吧~）_金闪闪呀的博客-CSDN博客_青龙面板脚本库https://blog.csdn.net/weixin_45314176/article/details/124551330?utm_source=app&amp;app_version=5.3.1
2. 快手极速版抓cookie
5.8日 ksjsb 小黄鸟抓快手ck教程_金闪闪呀的博客-CSDN博客https://blog.csdn.net/weixin_45314176/article/details/124640634?utm_source=app&amp;app_version=5.3.1
脚本获取处：
灌猪：v gong众浩 “闪闪外卖侠” 回复：“脚本” 自行获取吧~
个人v一般不会通过人，有问题自己百度看教程，付费咨询或者代搭备注来意后，会添加的。非诚勿扰~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d07b23a0d454912a2d06c2825cc696c5/" rel="bookmark">
			（六）多项式回归
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言1. 一个例子2. 多项式回归模型3. 代码实现 前言 这篇文章介绍多项式回归。
1. 一个例子 ​线性回归可以很好地拟合线性分布的数据，但是对于非线性的数据却派不上用场，例如下面的数据：
​这是一个简单的例子，它只有一个特征，输出变量 y y y 仅仅是关于这一个特征 x x x 的函数，但是线性回归却无法拟合它。之前学习了一种局部加权线性回归算法，它自然可以很好地拟合这样的数据分布，但是那种算法要求对每一种预测都要重新训练参数，它的拟合效果的确非常好，但是有一个很大的缺点就是时间代价太大。
​观察这样的数据分布，发现线性函数无法拟合它，那么非线性函数呢？例如二次函数能否拟合它？如果二次函数拟合效果不好，那么三次函数能不能较好地拟合它？二次函数是一种对称的函数，上述图形并不对称，因此二次函数的拟合效果也未必好，不过可以从数据分布中看出，二次函数的拟合应该是要比一次函数（线性函数）好的。次数上升后，拟合效果会好一些，那么三次函数呢？熟悉三次函数的人可能会看出，只要三次函数的四个系数选取恰当，那么这个三次函数就比较接近数据分布。根据泰勒公式我们可以知道，如果一个函数 n n n 阶连续可导，那么我们可以用 n n n 阶多项式来逼近这个函数。这也给了我们启发，使用多项式来拟合非线性的数据分布！
2. 多项式回归模型 ​如果想对输出变量 y y y 和特征向量 x = ( x 0 , x 1 , ⋯ , x n ) = ( 1 , x 1 , ⋯ , x n ) x=(x_0,x_1,\cdots,x_n)=(1,x_1,\cdots,x_n) x=(x0​,x1​,⋯,xn​)=(1,x1​,⋯,xn​) 作回归，根据上面的启发，我们想用一个多项式函数来预测 y y y ，假设我们使用 2 阶多项式来预测 y y y ，也就是说我们想寻找参数 θ \theta θ 使：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d07b23a0d454912a2d06c2825cc696c5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19eb3e5e5794d1e709766654de6c0937/" rel="bookmark">
			表单form
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		表单代码格式如下：&lt;input type="" name="" value=""&gt;,其中type类型有多种，接下来咱们一一介绍。
type="text" 文本域，这代表可以在这里边写东西 type="password"，这代表密文，更加安全type="radio"，这代表单选框type="checkbox"，这代表复选框type="button"，这代表按钮，一般用不着，平时用a标签也能做到type="submit"，这代表提交，，点击后即可提交到指定地址type="reset"，这代表重置，，点击后就会清除所有选择或填写的内容type="file"，这代表，，选择文件，点击后可进入自己磁盘选择文件type="hidden"，这代表，即若没有选择文件，用来提醒的提示文本 当然表单元素不止这些，还有：
select/option 下拉选项框
textarea文本域
还有数据的提交地址，即action="",引号里面写的就是地址，地址必须包含协议、域名和路径。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1f6e5a7c1b50ad286b90df7a25e444b/" rel="bookmark">
			C&#43;&#43; 将十进制数转换为二进制数方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文介绍一种将十进制数转换为二进制数的方式。
实现要点：
（1）用数组来存储每次对2取余的结果。
（2）两次使用for循环，分别进行转换和输出。
（3）% 取模运算。
#include &lt;iostream&gt;//C++的头文件不带.h
using namespace std;
int main()
{ int i,n;
int a[16] = {0};
cout &lt;&lt; "请输入一个整数(0-32767)";
cin &gt;&gt; n;
for (int j = 0; j &lt; 15; j++)
{
int b;
i = n%2; //取2的余数
b = n/2; //取被2整除的结果
n = b; //更新n值
a[j] = i; //将取余结果存入数组
}
for (int j = 15; j &gt;= 0; j--) //利用for循环反向输出取余结果
{
cout &lt;&lt; a[j];
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1f6e5a7c1b50ad286b90df7a25e444b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3bcf32eba1d8e2c9d76cb18a89576a19/" rel="bookmark">
			git lfs的安装和使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		20220304记录 lfs ： large file storage
安装 最新版本git-lfs 3.0.2要求libc6 高于2.32，而Ubuntu20.04默认的libc6版本是2.31，不支持安装git lfs 3.0.2
因此Ubuntu20.04版本安装git lfs 3.0.1版本，Ubuntu16.04可安装git lfs 2.13.3版本
使用 git lfs track *.so
执行之后自动生成.gitattributes，此文件记录需要lfs跟踪的文件、文件类型
git add .gitattributes
git add .
git add file.iso
git commit -m “Add disk image”
git push
Gerrit使能lfs 如果不经过gerrit，那上面是可以正常push成功，可是中间经过gerrit，那push时就会有错误提示如下：
batch response: Fatal error: LFS is not available for repository
batch response: Repository or object not found: http://…/objest/batch
因此，Gerrit需要安装lfs plugin和使能lfs功能。方法如下：
lfs插件安装：忘了，后补
ssh -p 29418 xxx@localhost gerrit plugin -h
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3bcf32eba1d8e2c9d76cb18a89576a19/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/081b64134f313b20be9ddf7585c44581/" rel="bookmark">
			RNN模型与NLP应用笔记(3)：Simple RNN模型详解及完整代码实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、写在前面 终于到RNN了，这篇文章首先介绍简易RNN模型，我们会以问题导向的方式一步一步对简易RNN模型进行改进。同样本文参考了王树森教授的深度学习课程内容，感谢大佬们提供的帮助。
现在开始讲述循环神经网络Recurrent Neural Networks (RNNs)，以及用Keras编程实现Simple RNN, 现在RNN没有以前流行，尤其是在自然语言处理的问题上，RNN已经有些过时了，如果训练数据足够多，RNN的效果不如Transformer模型，但是在小规模的问题上RNN还是很有用的，我们先来学习RNN，之后再来学习Transformer和BERT
目录
一、写在前面
二、引人
三、Simple RNN基本概念
四、关键代码详解
五、Simple RNN的缺陷
六、代码实现
七、总结
八、参考内容
二、引人 机器学习中经常用到文本语音等Sequential date（持续数据）。
思考一个问题，怎样对持续数据来建模？
上节课我们把一段文字整体输入一个线性回归模型，让模型来做二分类这属于one-to-one模型，即一个输入对应一个输出。
全连接神经网络和卷机神经网络都属于one-to-one模型，但是人脑并不用one-to-one模型来处理时序数据，人类并不会把一整段文字全部直接输入大脑 你阅读的时候，你会从左到右阅读一段文字，阅读的时候，逐渐在大脑里积累文本的信息，阅读一段话之后，你脑子就积累了整段文字的大意。
如上图，one-to-one按模型要求一个输入对应一个输出，比如输入一张图片，输出每一类的概率值，该按模型很适合图片的问题，但是不太适合文本问题。
对于文本问题，输入和输出的长度并不固定，一句话可长可短。所以，输入的长度并不固定 输出的长度也不固定，比如把英语翻译成汉语。一句英语有十个单词，翻译成汉语，可能有十个字，可能有八个字，甚至可能是四个字的成语，输出的汉语的字数并不固定。
由于输入和输出的长度都不固定，one-to-one模型就不太适合了，对于持续数据更好的模型是many To one或者是many To many模型。
RNN就是这样的模型，输入和输出的长度都不需要固定。RNN很适合文本、语音持续序列等数据。
如下图，RNN跟人的阅读习惯很类似，人每次看一个词，逐渐在大脑里积累信息, RNN每次看一个词，用状态向量h来积累阅读过的信息。
如图，我们把输入的一个词用Word Embedding变成一个词向量x，每次把一个词向量输入RNN。然后RNN就会更新状态h 把新的输入积累到状态h里面，h0里面包含了第一个词the的信息。
有如下图，h1里面包含了前两个词the和cat的信息，以此类推，状态h2包含了前三个词the、cat、set的信息，最后一个状态ht包含了整句话的信息,可以把ht看作是从这句话the cat side on the match抽取的特征向量, 更新状态h的时候，需要用到参数矩阵A。
注意：整个RNN只有一个参数A, 不论这条链有多长,参数A只有一个，最开始A随机初始化，然后利用训练数据来学习A
三、Simple RNN基本概念 首先讲simple RNN简单循环神经网络
我们来具体看一下simple RNN是怎么把输入的词向量x结合到状态h里面的
上一个状态记作是ht-1，新输入的词向量记作xt。如图，把这两个向量做concatenation（串联）得到一个更高的维度的向量。
这个矩阵A是RNN的模型参数，计算矩阵A和这个向量的乘积（矩阵和向量的成积是个向量）然后把这个激活函数tanh用在向量的每一个元素上。如下图，这个激活函数是hyperbolic tangent function，即双区正切函数（输入时任意时数，输出在[-1,1]之间），把激活函数的输出作为新的状态向量，即ht
由于用了双区正切激活函数向量ht的每一个元素都在[-1,1]之间，
如下图，这张神经网络的结构图可以这样理解：新的状态ht是由关于旧状态ht-1和新的输入xt的函数生成的。
神经网络的模型参数是矩阵A，新的状态ht依赖于向量ht-1和向量xt
如图，你有没有疑惑，为什么我们要用这个双区正切函数作为激活函数呢？能否把这个激活函数给去掉？去掉之后会发生什么呢？
为了方便讲述，我们做个简化：假设输入的词向量x全都是0（这等同于把输入的词向量x给去掉），即相当于把矩阵A右边这一半去掉,这么一来第100个状态向量h100就等于矩阵A×h99=A2h99= A3h98=……= A100h0
假如矩阵A最大的特征值略小于1，比如最大的特征值等于0.9那么会发生什么呢？
0.9的100次方已经非常接近零了，所以矩阵A的100次方几乎是一个全零的矩阵。那么新的状态h100几乎也是个全0的向量
假如矩阵a最大的特征值略大于1，比如最大的特征值等于1.2，那么会发生什么呢？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/081b64134f313b20be9ddf7585c44581/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4249c1134b0f97bfd3cf156f4f585bd/" rel="bookmark">
			XDP学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一些知识 XDP程序是通过bpf()系统调用控制的
将数据包交给XDP程序后，可以对它执行操作（如修改），完成后所设计的返回值将向XDP数据包处理器指示接下来如何处理数据包。
XDP_DROP指示应丢弃数据包
XDP_PASS指示数据包应向上传递到正常网络堆栈以进行进一步处理
XDP_TX和XDP_REDIRECT告诉数据包处理器立即重新传输数据包。XDP_TX将（可能修改过的）数据包转发回它进入的同一网络接口，XDP_REDIRECT使是举报通过不同的NIC或可能通过BPF cpumap将其转发到用户空间进程，绕过正常的网络堆栈。
XDP_ABORTED 用于错误，不能显式调用
示例问题 demo：将UDP数据包上的dest端口从7999更改为7998
打开三个终端，并在其中两个终端中运行以下两个命令：
nc -kul 127.0.0.1 7999 nc -kul 127.0.0.1 7998 这些终端是我们的监听过程。我们使用 netcat 打开一个套接字，以将进入端口 7999 和 7998 上的 127.0.0.1 地址的 udp 数据包。该参数只是告诉 netcat 在收到数据包后继续侦听，以便它可以从其他客户端接收更多数据包。nc-k
在我们的第三个终端中，运行：
nc -u 127.0.0.1 7999 然后在下一行中，键入一些文本，然后键入&lt;输入&gt;。您应该看到文本在第一个终端中回显，侦听端口 7999。一旦我们将 XDP 应用程序安装到位，连接到环回设备，数据包将在路由中被修改，并转移到在端口 7998 上侦听的另一个终端。
XDP加载器 XDP程序的第一步是编写一个加载程序，将其加载到数据路径中。
% main.py #!/usr/bin/env python3 from bcc import BPF device = "lo" % (1) b = BPF(src_file="filter.c") % (2) fn = b.load_func("udpfilter", BPF.XDP) % (3) b.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e4249c1134b0f97bfd3cf156f4f585bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b17311eb745e4badf09d717f604d818/" rel="bookmark">
			安装gtsam
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 下载gtsam：版本4.0.0-alpha2 https://github.com/borglab/gtsam/archive/4.0.0-alpha2.zip
解压之后在gtsam下编译和安装： mkdir build &amp;&amp; cd build cmake .. sudo make install //这一步最好使用sudo，不然可能出现问题。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1195145a71f324fdec461cea1b3fe2e5/" rel="bookmark">
			Lucene介绍与使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
Lucene
全文检索
全文检索的应用场景
索引
Lucene、Solr、Elasticsearch
三者关系
Lucene的基本使用
lucene工作流程
构建索引
查询索引
创建索引的详细流程
案例演示
生成索引：
中文分词索引
高亮显示
文档域加权
概述：
案例演示
查询索引的详细流程
索引的删除修改
删除索引
deleteDocBeforeMerge 此方法只标记未删除索引
修改索引
高级查询
特定项查询
综合案例演示
查询
删除
修改
添加 Lucene Lucene是一套用于全文检索和搜寻的开源程序库，由Apache软件基金会支持和提供Lucene提供了一个简单却强大的应用程序接口（API），能够做全文索引和搜寻，在Java开发环境里Lucene是一个成熟的免费开放源代码工具Lucene并不是现成的搜索引擎产品，但可以用来制作搜索引擎产品 官网：http://lucene.apache.org
全文检索 全文检索大体分两个过程，索引创建 (Indexing) 和搜索索引 (Search) 。
索引创建：将现实世界中所有的结构化和非结构化数据提取信息，创建索引的过程。搜索索引：就是得到用户的查询请求，搜索创建的索引，然后返回结果的过程 全文检索的应用场景 搜索引擎 百度、谷歌、搜索等等站内搜索 论坛搜索，微博搜索，文章搜索电商搜索 jd，tb搜索 索引 索引：一个为了提高查询速度，创建某种数据结构的集合
1、数据的分类：
1、结构化数据：格式、长度、数据类型固定
例如数据库的数据，
2、非结构化数据：格式、长度、数据类型不固定
word文档、pdf文档等等
2、数据的查询
1、结构化数据的查询：sql语句
简单、查询速度快
2、非结构化数据：查询某个关键字
条件复杂，查询难度大
顺序扫描法
字符串匹配（顺序扫描）
使非结构化的数据变为结构化的数据便于查询
Lucene、Solr、Elasticsearch 公司中使用的搜索技术是solr和Elasticsearch，而在这里介绍lucene是因为其简单对于新手来说入门容易solr 分词索引的数据库(有服务器的概念) 分词索引，能够支撑大数据量的索引 ​Elasticsearch分词索引的数据库(有服务器的概念) 分词索引，能够支撑更大数据量的索引 ​ 能够搭建ES集群 三者关系 Lucene：底层的API，工具包
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1195145a71f324fdec461cea1b3fe2e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43a823f9619849cee65ea400a9380978/" rel="bookmark">
			TSN (Time-Sensitive Networking）时间敏感网络
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TSN是一套协议标准，以保证确定性信息在标准以太网的不同场景下的顺利传输。TSN协议族本身具有很高的灵活性，用户可以根据应用的具体需求来选择相应的协议组合。
TSN协议族包含了定时与同步、延时、可靠性、资源管理这四个类别的子协议，我们借用下图来简要叙述TSN各个子协议的作用和功能。
时间同步
此部分仅包含一份协议，即IEEE STD 802.1AS（最新版本已于2020年6月发布），此协议包含两部分内容：定时与同步，这是实现确定性通信的重要机制，它具有以下特点：
· 是IEEE 1588 PTP同步协议的Profile，支持不同的TSN器件实现同步兼容性
· 为TSN网络中每个节点参与流量调度提供了时间基准
· 此协议增加了对容错和多个Grand Master主时钟源的支持，使时钟同步系统具备更强的鲁棒性
· 可以在主时钟源失效的情况下，无缝切换至冗余时钟源
延时
此部分通过定义不同的整形机制将数据流的延时限定在一定范围内，以此满足不同的低延时场景需求。在传统以太网中，数据流的通信延时是不确定的，由于这种不确定性，数据接收端通常需要预置大缓冲区来缓冲输出，但是这样会导致数据流，例如音视频流，缺失了实时方面的特性。
TSN不仅要保证时间敏感据流的到达，同时也要保证这些数据流的低时延传输。
通过优化控制时间敏感流和best-effort流、以及不同时间敏感流之间在网络中的传输过程，来保证对数据流的传输时间要求，这个优化控制的方式就是整形。
802.1Qav
此协议制定初衷是确保传统的异步以太网数据流不会干扰到AVB的实时数据流传输。现在Qav不再局限于音视频的传输。
此协议规定了每类优先级的入口计量、优先级再生以及处理时间感知队列的算法（CBS，效果如下图）。
其利用IEEE 802.1AS协议生成的定时信息，和VLAN优先级来隔离受控和非受控队列之间的帧，同时支持时间敏感流量在有线或无线局域网之间传输。
802.1Qch
由于Qav中定义的CBS机制实现的仅是软实时级别机制，但网络传输路径拓扑的复杂和各种干扰会导致持续的延时增加，而最差延时情况与拓扑、跳数、交换机的缓冲都有相关性，802.1Qch（循环队列转发机制或蠕动整形）就是用于改善这些状况。
通过同步控制入队和出队的策略，使得转发过程得以在一个周期内实现，以便使数据流经过交换机的时间更具确定性。
802.1Qch协议还定义了CQF（需与Qci协议配合使用），其中Qci标准会根据达到时间、速度、带宽，对Bridge节点输入的每个队列进行过滤和监管，用于保护带宽、增加对Burst流以及错误的处理。
802.1Qbv
流量调度是TSN的核心概念，根据时间同步协议802.1AS提供的全局时间基准，创建调度任务并将其分发给参与的网络器件。
802.1Qbv定义了通过控制TSN交换机出口处闸门的开关来控制排队流量的机制，这些队列中的消息将在预设的时间窗口中进行传输。
通常，在这些时间窗口内，其他队列的传输将被阻止，从而避免被调度流量被非调度流量阻塞，这样保证数据通过交换机的延迟是确定的。
802.1Qbu
尽管Qbv的机制可以保护关键消息免受其他流量的干扰，但不一定能够实现最佳带宽使用和最小通讯延迟。如果这些因素对于需要传输的数据很重要，可以采用802.1Qbu + 802.3br所定义的帧抢占机制来保障。
802.1Qbu协议中定义了中断标准以太网帧和巨型帧的传输，使高优先级帧优先通过的机制，同时可以恢复先前被中断的帧的传输。
如下所示，通过缩减为干扰帧所设置的保护区域的大小、对干扰帧进行合理切片来达到目的。
802.1Qcr
Qch和Qbv中设计的整形算法主要用于超低延时的数据，其高度依赖网络时间同步，以及在强制的周期中增强的包传输，但是对带宽的利用率并不高，因此有了Qcr（也叫ATS）用于异步流调度。
通过此整形方式，Bridge和终端节点无需时间同步，可以更加高效的利用带宽传输混合周期和非周期数据流的应用。
可靠性
对数据传输实时性要求高的应用除了需要保证数据传输的时效性，同时也需要高可靠的数据传输机制以便应对Bridge节点失效、线路断路和外部攻击带来的各种问题，来确保功能安全和网络安全。
802.1CB
为了减少由于链路和节点失效对网络造成的影响，通过冗余消息以及在网络中设置冗余链路进行并行传输来提高可靠性。
802.1Qca路径控制和预留标准定义了设置此类路径的方式，然后冗余管理机制将这些冗余消息组合在一起，以生成发送方至接收方的单个信息流。
802.1Qci
802.1Qci为了防止网络故障影响或恶意攻击对网络造成的干扰，将故障隔离到网络中的特定区域。它工作于交换机的入口，通过各种约束来监管每个流的输入，以防止出站队列被非法帧淹没。
资源管理
在TSN网络中，每一种实时应用都有特定的网络性能需求。
使能TSN网络的某个特性是对可用的网络资源进行配置和管理的过程，其允许在同一网络中通过配置一系列TSN子协议，来合理分配网络路径上的资源，以确保它们能够按照预期正常运行。
802.1Qat
流预留协议（SRP）。它根据流的资源要求和可用的网络资源情况指定准入控制，保留资源并通告从数据源发送端至数据接收端之间的所有网络节点，确保指定流在整条传输路径上有充足的网络资源可用。
802.1Qcc
此协议为流预留协议（802.1Qat）的增强，包含对更多流的支持、可配置的流预留类与流、更完善的流特征识别、对高层流的支持、确定性流预留融合以及用于路由和预留的用户网络接口（UNI）。
802.1Qcc支持TSN网络调度的离线或在线配置。
802.1Qcp
YANG数据模型。其定义了基于统一建模语言（UML）的信息模型和YANG数据模型，该模型允许对Bridge节点进行配置和状态报告。
它同时也定义了信息和数据模型之间的关系，协议中指定的其他管理功能以及IEEE Std 802.1AX和IEEE Std 802.1X的模型。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71f9689bc09f3bf44c5e65d8d2f4ddd5/" rel="bookmark">
			《必修1》数据与计算（模块一 数据与信息）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 《必修1 数据与计算》 模块一 数据与信息 一、数据信息与知识 （一）知识点 （二）习题练习 1、下述对数据、信息和知识的描述，错误的是（ ）
A.数据和信息的关系可以看成是“原料”和“成品”之间的关系
B.信息来源于数据，是经过加工处理过的数据
C.数据、信息与知识三者之间的价值变化趋势是逐渐递减
D.数据是未经加工的原始材料，是记录下来的管理活动的事实
2、2020年，网络主播为湖北农产品带货。原本无人问津的农产品经过互联网的宣传推广，一下子打开了销路，这主要体现了信息的（ ）
A.真伪性 B.价值性 C.时效性 D.依附性
3、小明想通过某售票系统购买回上海虹桥的车票。对数据、知识、信息的说法中，错误的是（ ）
A.车次前的G、D分别代表高铁和动车，这是信息的体现
B.07:00和05小时36分钟虽然表现形式不同，但它们都是数据的体现
C.当前界面显示了起始站和终点站，这是信息的体现
D.该售票系统会实时更新商务、一等、二等和无座票的余票信息，体现了信息的真伪性
4、天气预报、市场信息都会随时间变化而变化，这体现了信息的（ ）
A.依附性 B.共享性 C.时效性 D.普遍性
5、数据的表现形式多种多样，以下有关数据表现形式的说法正确的是（ ）
A.数据就是数字，只有数字才是数据
B.人的名字、流行歌曲、动画视频都不是数据
C.考试记录的成绩并不是数据
D.文字、图形、图像都是数据
6、以下关于数据、信息和知识相互关系的理解，不正确的是（ ）
A.数据是原始事物现象的符号记录
B.信息是数据的载体
C.信息是经过加工处理的、具有意义的数据
D.对信息进行系统化的提炼、研究和分析可以得到知识
（三）答案解析
123456CBDCDB 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ad2b42db9e64dff59fd638c5fd5d69c/" rel="bookmark">
			Unity学习笔记：如何设置Tilemap碰撞体，以及如何优化碰撞体计算【By chutianbo】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们在用Tilemap场景搭建时，常常需要某些Tile具有碰撞的功能，那么我们该怎么实现这个功能呢？
我们先得给Tilemap一个专门的Collider组件，即Tilemap Collider 2D：
然后我们在Tile Palette中找到对应的Tile对象，将需要Collider的瓦片的碰撞体设置为Sprite；
这里本菜设置的None；
然后就响应的瓦片就会有碰撞体了；
这里本菜理解为：
给Tilemap一个Collider后， Tilemap会给palette中设置为允许有碰撞体的精灵一个碰撞体；
我们在运行游戏时，电脑会计算很多碰撞体的碰撞，尤其是我们用Tilemap后，如果每个瓦片都有一个单独的碰撞体要计算，那么会增加很多不必要的运行，因为瓦片中大部分是连续无碰撞体或者连续有碰撞体的，而且每个瓦片碰撞体之间是有微笑间隙的，这些间隙可能会导致某些bug【这让我想起了童年CF生化酒店中的椰子树地下的卡墙bug...】
那么我们可以给Tilemap一个Composite Collider 2D组件，这个组件可以自动组合相邻的瓦片碰撞体：
实现效果如下：
注意，要在Tilemap Collider 2D中将Used by composite选项勾上；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9f41b89dad7d1cc5e721afd7f7a26b3/" rel="bookmark">
			javascript案例7——简易轮播图、2秒切换图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、案例描述 图片切换，每隔两秒换一张，目前此效果就放了4张图片，可自行添加。播到最后一张再播第一张。下方文字同时发生变化。
二、案例效果演示 三、案例局部代码 css &lt;style type="text/css"&gt; #imgBox { width: 300px; height: 200px; } #imgBox img { width: 100%; height: 100%; object-fit: cover; } #index { width: 300px; text-align: center; } &lt;/style&gt; html &lt;div id="imgBox"&gt; &lt;img src="" id="img" /&gt; &lt;/div&gt; &lt;div id="index"&gt;第1张&lt;/div&gt; js &lt;script&gt; // 获取页面图片元素的路径 var imgBox = document.querySelector('img'); var div = document.querySelector('#index'); // 将图片的路径以数组的形式存放。 var imgs = ['./img/bg1.png', './img/bg2.jpg', './img/bg3.jpg', './img/bg4.jpeg']; var imgIndex = 0; //默认为第一张图片 imgBox.src = imgs[imgIndex];//刚上来页面默认显示第一张 var t = setInterval(changeImg, 2000);//每两秒调用一次 // 函数封装 function changeImg() { imgIndex++; if (imgIndex == imgs.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e9f41b89dad7d1cc5e721afd7f7a26b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a474c768ffe0b0b9a7e4553cc92f345/" rel="bookmark">
			windows下查看端口的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		小编的同事昨天遇到了一个问题，在运行某个程序的时候，总提示说程序端口被占用，不能运行，这可就着急了，今天小编一系列的查看，解决了问题，今天就来教大家windows如何查看端口，从而知道端口被哪个程序占用了，然后在进行处理即可。下面我们一起来看看具体内容。
步骤一、Windows查看所有的端口
点击电脑左下角的开始，然后选择运行选项，接着我们在弹出的窗口中，输入【cmd】命令，进行命令提示符。然后我们在窗口中输入【netstat -ano】按下回车，即会显示所有的端口占用情况。如图所示：
步骤二、查询指定的端口占用
在窗口中，继续输入【netstat -aon|findstr “提示的端口”】，例如小编提示的端口为2080，那么小编就输入命令为【netstat -aon|findstr “2080”】，回车之后就可以看见列表中的PID，然后根据PID在电脑的任务管理器中查看对应的占用程序，接着进行关闭即可。
步骤三、查询PID对应的进行进程
如果在上面步骤之后，我们得到的PID为2016，那么我们就可以输入命令【tasklist|findstr “2016”】，在第一行显示的名字就是程序名，这样我们就明白是那个程序占用的端口。
步骤四、然后我们输入命令【taskkill /f /t /im 程序名】即可。
以上就是关于windows如何查看端口的全部内容，希望对大家有所帮助。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/272/">«</a>
	<span class="pagination__item pagination__item--current">273/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/274/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>