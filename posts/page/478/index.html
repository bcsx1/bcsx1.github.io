<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16bf01f687a71001d5e6d449afdc45b0/" rel="bookmark">
			52840 USB虚拟串口移植
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.测试的平台
本篇文章主要介绍将52840作为接收器，使用的工程为nRF5_SDK_15.2.0_9412b96\examples\ble_central\ble_app_uart_c\pca10056。
整个测试平台如下：
环境：win10,64位，MDK集成开发环境.
SDK：nRF5_SDK_15.2
协议栈：s132_nrf52_6.1_softdevice.hex.
USB参考工程: nRF5_SDK_15.2.0_9412b96\examples\peripheral\usbd_cdc_acm\pca10056.
硬件平台：pca10056开发板.
二.Application移植
1.USBD移植
（1）添加相关C文件
将app_usbd.c、app_usbd_core.c、app_usbd_serial_num.c、app_usbd_string_desc.c、app_usbd_cdc_acm.c、nrf_drv_usbd.c添加到工程中。
（2）添加头文件
（3）加入usb相关代码
在main.c中加入下面代码
①头文件和宏定义 #include "nrf.h" #include "nrf_drv_usbd.h" #include "nrf_drv_clock.h" #include "nrf_drv_power.h" #include "app_usbd_core.h" #include "app_usbd.h" #include "app_usbd_string_desc.h" #include "app_usbd_cdc_acm.h" #include "app_usbd_serial_num.h" #define LED_USB_RESUME (BSP_BOARD_LED_0) #define LED_CDC_ACM_OPEN (BSP_BOARD_LED_1) #define LED_CDC_ACM_RX (BSP_BOARD_LED_2) #define LED_CDC_ACM_TX (BSP_BOARD_LED_3) #define BTN_CDC_DATA_SEND 0 #define BTN_CDC_NOTIFY_SEND 1 #define BTN_CDC_DATA_KEY_RELEASE (bsp_event_t)(BSP_EVENT_KEY_LAST + 1) #ifndef USBD_POWER_DETECTION #define USBD_POWER_DETECTION true #endif static void cdc_acm_user_ev_handler(app_usbd_class_inst_t const * p_inst, app_usbd_cdc_acm_user_event_t event); #define CDC_ACM_COMM_INTERFACE 0 #define CDC_ACM_COMM_EPIN NRF_DRV_USBD_EPIN2 #define CDC_ACM_DATA_INTERFACE 1 #define CDC_ACM_DATA_EPIN NRF_DRV_USBD_EPIN1 #define CDC_ACM_DATA_EPOUT NRF_DRV_USBD_EPOUT1 //APP_TIMER_DEF(m_blink_cdc); #define LED_BLINK_INTERVAL 800 #define LED_CDC_ACM_CONN (BSP_BOARD_LED_2) /** * @brief CDC_ACM class instance * */ APP_USBD_CDC_ACM_GLOBAL_DEF(m_app_cdc_acm, cdc_acm_user_ev_handler, CDC_ACM_COMM_INTERFACE, CDC_ACM_DATA_INTERFACE, CDC_ACM_COMM_EPIN, CDC_ACM_DATA_EPIN, CDC_ACM_DATA_EPOUT, APP_USBD_CDC_COMM_PROTOCOL_AT_V250 ); #define READ_SIZE 1 static char m_rx_buffer[READ_SIZE]; static char m_tx_buffer[NRF_DRV_USBD_EPSIZE]; ②添加usb事件处理程序
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/16bf01f687a71001d5e6d449afdc45b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/777fd1190a37dc0f6a7e6a118e926ba4/" rel="bookmark">
			JedisCluster 整合 Spring
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		依赖 &lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt; &lt;type&gt;jar&lt;/type&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; 把 JedisCluster 注入 IoC package com.example.redis.client; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import redis.clients.jedis.HostAndPort; import redis.clients.jedis.JedisCluster; import redis.clients.jedis.JedisPoolConfig; import java.util.HashSet; import java.util.Set; @Configuration public class AppConfig { @Bean(name="jedisCluster") public JedisCluster jedisCluster() { Set&lt;HostAndPort&gt; nodeSet = new HashSet&lt;&gt;(); nodeSet.add(new HostAndPort("127.0.0.1", 7000)); nodeSet.add(new HostAndPort("127.0.0.1", 7001)); nodeSet.add(new HostAndPort("127.0.0.1", 7002)); nodeSet.add(new HostAndPort("127.0.0.1", 7003)); nodeSet.add(new HostAndPort("127.0.0.1", 7004)); nodeSet.add(new HostAndPort("127.0.0.1", 7005)); JedisCluster jedisCluster = new JedisCluster(nodeSet, 1000, new JedisPoolConfig()); return jedisCluster; } } 测试使用 package com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/777fd1190a37dc0f6a7e6a118e926ba4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/504735c6be51653d10c9499ae7a288df/" rel="bookmark">
			在mysql中，涉及到金钱的数据类型一般是什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一般用decimal，长度18，保存2位小数，具体看业务
在java的开发中，货币在数据库中MySQL常用Decimal和Numric类型表示，这两种类型被MySQL实现为同样的类型。他们被用于保存值，该值的准确精度是极其重要的值，例如与金钱有关的数据。当声明一个类是这些类型之一时，精度和规模的能被(并且通常是)指定；例如：
salary DECIMAL(9,2)
在这个例子中，9(precision)代表将被用于存储值的总的小数位数，而2(scale)代表将被用于存储小数点后的位数。因此，在这种情况下，能被存储在salary列中的值的范围是从-9999999.99到9999999.99。
DECIMAL和NUMERIC值作为字符串存储，而不是作为二进制浮点数，以便保存那些值的小数精度。一个字符用于值的每一位、小数点(如果scale&gt;0)和“-”符号(对于负值)。如果scale是0，DECIMAL和NUMERIC值不包含小数点或小数部分。 不使用float或者double的原因：因为float和double是以二进制存储的，所以有一定的误差。 比如：在数据库中c1,c2,c3分别存储类型是float(10.2),decimal(10.2),float类型。
插入数据：
INTO test (c1,c2,c3) VALUES (1234567.23,1234567.23,1234567.23)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8931b6a0a9fdacdf14849013e26ce38b/" rel="bookmark">
			代码初读（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决识别圆圈下数字的部分： 如何根据颜色识别出大体的方框，首先读取源码中的几个函数：
cvtColor
split
equalizeHist 函数cvtColor(imgOriginal, imgHSV, COLOR_BGR2HSV); // 用于颜色空间转换
C++: void cvtColor(InputArray src, OutputArray dst, int code, int dstCn=0 );
参数解释：
. InputArray src: 输入图像即要进行颜色空间变换的原图像，可以是Mat类
. OutputArray dst: 输出图像即进行颜色空间变换后存储图像，也可以Mat类
. int code: 转换的代码或标识，即在此确定将什么制式的图片转换成什么制式的图片，后面会详细将
. int dstCn = 0: 目标图像通道数，如果取值为0，则由src和code决定
void split(const Mat&amp; src,Mat *mvBegin);
第一个参数为要进行分离的图像矩阵，第二个参数可以是Mat数组的首地址，或者一个vector对象第一个参数为要进行分离的图像矩阵，第二个参数可以是Mat数组的首地址，或者一个vector对象
此外,如果split函数输入的图像为HSV的,则分离后,channels[0]对应H,channels[1]对应S,channels[2]对应V
OpenCV中的inRange()函数可实现二值化功能（这点类似threshold()函数），更关键的是可以同时针对多通道进行操作，使用起来非常方便！
void inRange(InputArray src, InputArray lowerb, InputArray upperb, OutputArray dst)
官方文档中的解释：Checks if array elements lie between the elements of two other arrays.即检查数组元素是否在另外两个数组元素值之间。这里的数组通常也就是矩阵Mat或向量。请注意：该函数输出的dst是一幅二值化之后的图像。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8931b6a0a9fdacdf14849013e26ce38b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d6cbd74f81bda820a77cc4afac7977d/" rel="bookmark">
			plugins:maven-compiler-plugin:3.1:testCompile 解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本人笔记本开发环境为win10+jdk1.8+eclipse4.7，在构建maven项目时报错了。其异常是pom.xml里的“plugins:maven-compiler-plugin:3.1:testCompile ”
查了下资料发现是因为jdk版本引起的：
我环境是jdk1.8，
但是eclipse如果你不指定在build时的jdk版本默认是jdk1.7，
从而导致报错Failed to execute goal org.apache.maven.plugins:maven-compiler-plugin:3.1:testCompile
其解决办法：在pom.xml文件添加配置(如果已经存在如下配置应作对应修改,把jdk版本改为自己电脑环境中的版本)，如图：
然后，右键项目-&gt;maven-&gt;update project，就OK了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d87a025fbd2804be8a1d63da0bec7d6/" rel="bookmark">
			python遍历文件夹下的所有文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引入 在Python中我们一般使用os模块来操作文件夹或文件，os为Python的内置模块，使用时直接导入即可：
import os 当文件夹内只有文件时–listdir() 当目标文件夹中只有文件时，我们使用os模块的listdir()方法即可：该方法可以返回目标路径下的文件和文件夹的名字列表，参数就是目标路径。
荔枝：
文件结构如下：
E:\test2--------文件1.txt--------文件2.txt--------文件3.xlsx def getfiles(): filenames=os.listdir(r'E:\test') print(filenames) 结果图如下：
当文件中既有文件又有文件夹时–os.walk() 当目标文件中既有文件又有文件夹时，我们使用listdir()方法就只能获得第一层子文件或文件夹了，而子文件夹中的内容便获取不到了。
荔枝：
文件结构如下：
E:\test2-------目录1--------------目录11--------------------文件111.txt--------------------文件112.txt--------------文件11.txt--------------文件12.txt-------目录2--------------文件21.vsdx-------文件1.txt-------文件2.txt def getfiles(): filenames=os.listdir(r'E:\test2') print(filenames) 结果如图：只显示出第一层子文件和文件夹
这时候我们需要用到os.walk()方法：传入目标路径即可。该方法可以递归的找出目表路径下的所有文件，无论他藏的有多深~
def get_files(): for filepath,dirnames,filenames in os.walk(r'E:\test2'): for filename in filenames: print (filename) os.walk()方法可以生成三元组，也就是我们代码中的filepath，dirnames，filenames，我们将他们分别打印出来可以看到：
其中filepath就是目标路径下所有文件的路径：
其中dirnames是我们目标路径的所有目录名称：
其中filenames则是各个路径下的文件名称列表：
扩充—获得目标路径下的所有文件的绝对路径 如果你足够细心的话，就会发现我们的filepath和filenames打印的结果图是一一对应的关系：文件1.txt和文件2.txt的路径就是E:\test2；文件11.txt和文件12.txt的路径就是E:\test2\目录1；以此类推。那么我们把这两个返回值拼在一起，不就是各个文件的绝对路径了么？
def get_files(): for filepath,dirnames,filenames in os.walk(r'E:\test2'): for filename in filenames: print(os.path.join(filepath,filename)) 我们遍历目标路径下的各个文件，用os.path.join()方法将文件路径和文件名拼接在一起，就是各个文件的绝对路径了：
小提示：os.path.join()方法就是将目录和文件合成一个路径的方法。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8c5d98d2b9fcbf3c2353f625ad8681b/" rel="bookmark">
			某计算机存储器按字节编址，虚拟（逻辑）地址空间大小为16MB，主存（物理）地址空间大小为1MB，页面大小为4KB。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		某计算机存储器按字节编址，虚拟（逻辑）地址空间大小为16MB，主存（物理）地址空间大小为1MB，页面大小为4KB。系统运行到某一时刻，页表的部分内容和TLB的状态分别参照教材例4-13，表中的页框号及标记字段为十六进制。问
存储系统的虚拟地址共有几位，其中是用哪几位来表示的虚页号？存储系统的物理地址共有几位，哪几位用来表示的页框号（物理页号）？TLB为何物？一般是由何种器件构成？简述下图TLB与页表的映射关系。虚地址024BACH所在的页面是否在主存中？若在，则该虚拟地址对应的物理地址是什么？若不在，说明理由。 1.答：由于虚拟地址空间大小为16MB，且按字节编址，16M=2的24次方，所以虚拟地址长度应为24位。
由于页面大小为4KB，4K=2的12次方，则页内地址需12位，又有24-12=12，故虚拟号为虚地址的高12位。
由于主存（物理）地址大小为1MB，按字节编址，1M=2的20次方，所以物理地址有20位。
而页内地址是12位，所以20-12=8，故主存地址的高8位为页框号。
2.答：TLB为快表。一般由组号，有效位，标记，页框号组成。TLB可存8个页表项，每组存4个页表项，共分成两组。TLB→页表之间四路组相联。
3.答：因为虚页号是12位，且每个虚页在页表中对应一行，故页表中应有2 ¹²行，
按每组2行分组，共分成2 ¹¹组。所以页表分组后，虚页号可以被看成：组号11位+组内虚页号1位。
虚地址是024BACH，则12位虚页号为024H（0000 0010 0100），而其高11位是组号，其低1位是组内序号，则分解成：组号0000 0100 010（012H）+组内序号0。
对组相联映射，页表项的组内序号=TLB的组号，因此虚地址024BACH所在续页所对应的页表项应映射到TLB的第0组中去。
因此在表中分别对比组号为0的4个TLB行，对比发现它与虚地址024BACH对应的组号012H一致，且有效位为1，页框号为1F，因此可以确定虚地址024BACH所在的虚页面已在主存中。
虚地址024BACH对应的主存地址为页框号与页内地址直接拼接，即1FBACH。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74c0244d23735d71fc9d16749dcd59eb/" rel="bookmark">
			Python打包工具distutils的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇博客介绍的是使用distutils + setup.py 打包发布自定义的python包。
假设python工程目录结构如下，
一个比较简单的需求：
在打包时，我们希望
对于一些pkg，全部打包（所有py文件），对于其他pkg，部分打包。打包pkg里的配置文件打包不属于任何pkg的模块（单个py脚本） 为了满足上述需求，setup.py 脚本编写如下：
from distutils.core import setup setup( package_dir={'':'python'}, packages=['pkg1'], package_data={'': ['config/1.txt']}, py_modules=['pkg2.p21','test1'] ) 为了简单起见，上述setup.py 省略了对待生成包名字/版本等描述。
解释：
1.package_dir描述了setup.py脚本与待打包pkg的路径关系： 是个字典类型，value表示以setup.py为起点的相对路径。
2 packages 是在package_dir指定路径下的python pkg(必须有__init__.py), 可以写多个。
3 package_data 填写准备打包的配置文件。
4 py_modules 填写待打包的单个脚本，比如例子中的pkg2,有时侯并不像把pkg2里的所有脚本都打包，或者有时侯需要打包不属于任何pkg的脚本（比如test1.py),此时用py_modules就比较方便。
打包：
python setup.py bdist (这里有多种参数可选择) 打包结果 ：会生成一个build和dist目录。
本机安装测试
可以用 sudo python setup.py install --record installed.txt 在本机安装验证，
加 --record installed.txt 是为了记录安装路径，方便验证完删除。
安装后，可以去python系统目录下验证是否安装成功。
开启一个终端，测试安装成功。
参考
How to writing the setup script ：https://docs.python.org/2/distutils/setupscript.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d2ed288b6589c121992d4947eb17a96/" rel="bookmark">
			后端提供apk下载时需要注意的地方
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 今天测试下载apk并安装，出现下载的文件大小和原大小不一致。
解决方法：
后端提供下载的接口需要设置header
response.setHeader("content-type", "application/vnd.android.package-archive"); response.addHeader("Content-Disposition", "attachment;filename=" + fileName); response.addHeader("Content-Length", "" + file.length()); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4113ffe047a9b3a1d6ac1cdabc92e156/" rel="bookmark">
			模拟银行存取款业务 java
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实训题5：模拟银行存取款业务
实训目的：本项目的主要功能是模拟银行的存取款业务，当用户登录时需判断银行卡号和银行卡密码，当输入的卡号和密码都正确时，登录成功，提示当前登录的账户名，并进入下一步选择操作类型。操作类型包括四种（存款、取款、余额、退出），选择存款或取款时，将进行存取款操作，此时需要输入存取的金额，并进行正确的金额加减计算；选择余额时，显示当前账户的余额；输退出时将退出整个系统。项目流程图如下：
余额忘记用文件保存了，先把代码贴上来吧
package exam5; import java.awt.*; import java.io.*; import javax.swing.*; public class Bank { static int temp=10000; static int tm=0;/*filename.createNewFile() File filename=new File("D:\\Eclipse Workspace\\Training\\user\\"+shuru1.getText()+"\\name.txt");fileID.mkdirs(); File fileID=new File("D:\\Eclipse Workspace\\Training\\user\\"+shuru1.getText());if(!fileID.exists())*/ private static void createAndShowGUI() { JFrame f =new JFrame("中国银行"); f.setSize(730, 500); f.setLocation(400,300); JTextArea showArea = new JTextArea(1,35); f.setResizable(true);//窗口是否可以尺寸大小 f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); JLabel l1 = new JLabel();//l1标签 ImageIcon icon = new ImageIcon("D:\\Eclipse Workspace\\Training\\img\\1.jpg");	l1.setIcon(icon);//l1为图片标签 JButton b1 = new JButton("登 录"); JButton b2 = new JButton("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4113ffe047a9b3a1d6ac1cdabc92e156/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e82f45aa2047204fc207de8a6d3ac6d8/" rel="bookmark">
			export_store: invalid GPIO 47
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Microzed成功复制到SD卡后通过串口交互的过程中。命令与MicroZed Getting Started Guide 里面有所不同
这是理论上的。我这里实际的是这样的
理论上的是gpiochip0 所以通过看引脚是47 直接写就好
我的这里是gpiochip906 所以需要加上906 906+47 才行。。。
参考链接：http://zgserver.com/sysfs-zybo-boardgpio.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6486d1d4905b72f504b8a4caa5bf4d97/" rel="bookmark">
			Vuex完整示例代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vuex完整示例代码 运行效果：
1、在pages目录下创建 Students.vue
&lt;template&gt; &lt;div&gt; &lt;h1&gt;Students&lt;/h1&gt; &lt;ul&gt; &lt;li v-for="(student,index) in students" :key="student.id"&gt; {{student.name}} &lt;i&gt;{{student.games.length}} games he plays&lt;/i&gt; &lt;button @click="addTeamMember('A',index)" :disabled="student.selected"&gt;Team A&lt;/button&gt; &lt;button @click="addTeamMember('B',index)" :disabled="student.selected"&gt;Team B&lt;/button&gt; &lt;/li&gt; &lt;/ul&gt; &lt;br /&gt; &lt;hr /&gt; &lt;TeamComponent type="A"&gt;&lt;/TeamComponent&gt; &lt;TeamComponent type="B"&gt;&lt;/TeamComponent&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import TeamComponent from '~/components/TeamComponent'; import { mapState, mapActions } from 'vuex'; export default { name: 'StudentsComponent', components: { TeamComponent, }, computed: { ...mapState('Students',['students']), }, methods: { ...mapActions('Students',['AddTeamMember']), addTeamMember(type,index){ this.AddTeamMember({type,index}); }, }, } &lt;/script&gt; 2、在store目录下创建 Students.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6486d1d4905b72f504b8a4caa5bf4d97/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d2283123cf7aa986fa6bb5f42c52a77/" rel="bookmark">
			vue点击实现 路由的跳转
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击按钮实现路由的跳转
&lt;div @click="gotoMenu"&gt;按钮&lt;/div&gt; 实现跳转
methods: { gotoMenu(){ //跳转到上一次浏览的页面 this.$router.go(-1) this.$router.go(-1) //指定跳转的地址 this.$router.replace('/menu') this.$router.replace('/menu') //指定跳转的路由的名字下 this.$router.replace({name:'menu'}) this.$router.replace({name:'menu'}) //通过push进行跳转 this.$router.push('/menu') } }, } 转载于:https://www.cnblogs.com/chz1905/p/10954227.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49ede56644cf5fe66a37d8ab5316c1a1/" rel="bookmark">
			利用伪类:after改变checkbox样式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ``
今天我们UI发了一张设计图，里面CheckBox长这样，然后我开始敲的时候发现不管我怎么改check样式都不能改变check的默认样式，后面去网上百度了一下，好多都说用伪类就可以改变，我一想，伪类可以改变他自身？一进去看代码，发现是通过伪类来重新创一个checkbox样式然后通过定位把原来的样式给遮挡住，就实现了改变checkbox的样式。下面附上我实现这个功能的代码供大家参考。
/* 修改checkbox的默认样式 */ input[type='checkbox'] { width: 15px; height: 15px; outline: none; margin-right: 10px; cursor: pointer; position: relative; margin-bottom: 3px; } input[type='checkbox']:after { position: absolute; width: 10px; height: 15px; top: 0; content: " "; background-color: white; border: 1px solid; color: black; display: inline-block; visibility: visible; padding: 0px 3px; cursor: pointer; } input[type='checkbox']:checked:after { content: "✓"; font-size: 12px; background-color: orangered; color: white; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/665f5ab3422c049a16798000f946a397/" rel="bookmark">
			C语言多级指针详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		指针可以指向一个普通类型的变量，例如int、double、char等，也可以指向一个指针类型的变量，如int*、double*、char*等。
如果一个指针指向的是另一个指针，我们就成他为二级指针，或者指向指针的指针。
将这种关系转换为C语言代码：
int a=100; int *p1=&amp;a; int **p2=&amp;p1; 指针变量也是一种变量，也会占用内存空间，也可以用&amp;来获取它的指针。C语言不限定指针的级数，没增加一级指针，在定义指针变量时就得增加一个*号。p1是一级指针，指向普通类型的数据，定义时有一个*；p2是二级指针，指向一级指针p1，定义时又两个*。
如果我们希望再定义一个三级指针p3，让它指向p2，那么可以这样写：
int ***p3=&amp;p2; 四级指针同理。实际指针经常会使用一级和二级指针，几乎不会用到高级指针。
通过指针的指针，不仅可以访问它指向的指针，还可以访问它指向的指针所指向的数据。想要获取指针指向的数据时，一级指针加一个*，二级指针加两个*，三级指针加三个*，以此类推：
#include &lt;stdio.h&gt; int main() { int a=100; int *p1=&amp;a; int **p2=&amp;p1; int***p3=&amp;p2; printf("%d %d %d %d\n",a,*p1,**p2,***p3); printf("&amp;p=%#X p3=%#X\n",&amp;p2,p3); printf("&amp;p1=#X p2=%#X *p3=%#X\n",&amp;p1,p2,*p3); printf("&amp;a=%#X p1=%#X **p3=%#X\n",&amp;a,p1,*p2,**p3); return 0; } 运行结果：
100 100 100 100 &amp;p2 = 0X28FF3C p3 = 0X28FF3C &amp;p1 = 0X28FF40 p2 = 0X28FF40 *p3 = 0X28FF40 &amp;a = 0X28FF44 p1 = 0X28FF44 *p2 = 0X28FF44 **p3 = 0X28FF44 假设a、p1、p2、p3的地址分别为0X00A0、0X1000、0X2000、0X3000，他们之间的关系可以用下图来描述：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/665f5ab3422c049a16798000f946a397/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/255152767e7d8cf8fd68753a7d047fd4/" rel="bookmark">
			pytorch模型调用和速度测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		硬件：
1、测试模型：NIMA的pytorch版本
来源：https://github.com/truskovskiyk/nima.pytorch
模型：pretrain-model.pth
速度：平均一张图300ms左右
5.152941832318902 5.508232474792749 4.2969538709148765 5.8256916594691575 5.338452965952456 5.439441880211234 4.638633335009217 avg time: 304.443359375 ms 测试调用代码：
from nima.inference.inference_model import InferenceModel import os import time if __name__ == '__main__': path_model = '/Users/xuqiong/code/image/NIMA/nima.pytorch/pretrain-model.pth' model = InferenceModel(path_to_model=path_model) dir = '/Users/xuqiong/code/image/NIMA/nima.pytorch/test2' #dir = '/Users/xuqiong/code/image/data/tid2013/distorted_images' filelist = [] filenames = os.listdir(dir) timeall = 0 for fn in filenames: if fn == '.DS_Store': continue fullfilename = os.path.join(dir, fn) filelist.append(fullfilename) for i in range(0, len(filelist)): path_image = filelist[i] try: time0 = time.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/255152767e7d8cf8fd68753a7d047fd4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3365d18023eac2de72841d42b00222c/" rel="bookmark">
			小技巧：Bat命令批量删除文件名中特定字符串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 起因 一个字，懒！
但是机器做简单重复的事，都不会这么觉得~反而可能乐在其中哈！
具体操作 用bat命令批量操作，新建一个.bat文件（就是.txt文件改一下后缀），然后用文本格式打开，键入：
@echo off Setlocal Enabledelayedexpansion set "str=想要去掉的字符串" for /f "delims=" %%i in ('dir /b *.*') do ( set "var=%%i" &amp; ren "%%i" "!var:%str%=!") 然后，保存，执行~
​ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb1d6cec56e0cd208993233474361299/" rel="bookmark">
			js正则选取百度编辑器的文字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 //参数（str:百度编辑器保存到库的内容 len：内容长度） function removeTAG(str,len){ var str1=str.replace(/&lt;[^&gt;]+&gt;/g, ""); return str1; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68ce955e10b65adb054c7ac221186235/" rel="bookmark">
			Redis分布式锁/Redis的setnx命令如何设置key的失效时间（同时操作setnx和expire）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Redis的setnx命令是当key不存在时设置key，但setnx不能同时完成expire设置失效时长，不能保证setnx和expire的原子性。我们可以使用set命令完成setnx和expire的操作，并且这种操作是原子操作。
下面是set命令的可选项：
set key value [EX seconds] [PX milliseconds] [NX|XX] EX seconds：设置失效时长，单位秒 PX milliseconds：设置失效时长，单位毫秒 NX：key不存在时设置value，成功返回OK，失败返回(nil) XX：key存在时设置value，成功返回OK，失败返回(nil) 案例：设置name=p7+，失效时长100s，不存在时设置 1.1.1.1:6379&gt; set name p7+ ex 100 nx OK 1.1.1.1:6379&gt; get name "p7+" 1.1.1.1:6379&gt; ttl name (integer) 94 从上面可以看出，多个命令放在同一个redis连接中并且redis是单线程的，因此上面的操作可以看成setnx和expire的结合体，是原子性的。
在Java中，如何使用RedisTemplate封装上述操作呢？
import com.fasterxml.jackson.annotation.JsonInclude; import com.fasterxml.jackson.databind.DeserializationFeature; import com.fasterxml.jackson.databind.ObjectMapper; import org.springframework.dao.DataAccessException; import org.springframework.data.redis.connection.RedisConnection; import org.springframework.data.redis.core.RedisCallback; import org.springframework.data.redis.core.RedisTemplate; import org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer; import org.springframework.data.redis.serializer.JdkSerializationRedisSerializer; import org.springframework.data.redis.serializer.RedisSerializer; import org.springframework.data.redis.serializer.StringRedisSerializer; import org.springframework.stereotype.Component; import redis.clients.jedis.Protocol; import redis.clients.util.SafeEncoder; import javax.annotation.Resource; import java.io.Serializable; import java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/68ce955e10b65adb054c7ac221186235/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f4bf5828fae70065da1f4ca7d6580e7/" rel="bookmark">
			httpclient大量请求网络拒绝 Connection pool shut down
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.背景描述
项目中每次400条数据递归网络请求第三方数据，该次递归总的数据量有220000左右，可以算出大概需要550次调用。但是数据跑到13W左右，程序中断。
2.案例分析
①.系统跑了一遍，没有看到任何日志。
分析: 因为是多线程应用，一开始以为是线程池写法有误,导致数据库连接用完，
解决：使用自定义连接池上了一版,并且加上了日志。
②.系统再跑了一遍，发现日志报错
分析：问题基本上可以定位到时httpclent问题了。
HttpClientBuilder builder = HttpClients.custom();
使用该方式定义了httpcliet,默认使用的是PoolingHttpClientConnectionManager 线程池管理器
默认每个route只允许最多2个connection，总的connection数量不超过20。
但是如果请求多了，还是会出现线程不够用的情况。
解决：
第一种方案:
setConnectionManagerShared(true) 如果线程来不及处理，卡在那里复用线程池。
第二种方案:
setMaxTotal(1000); // 连接池最大并发连接数
setDefaultMaxPerRoute(1000);// 设置最大并发数
③.系统又跑了一遍，发现栈溢出
分析：syncECCustomerByStepPage 方法栈溢出。
解决：
第一种方案:使用Xss设置栈的大小，弊端是需要知道栈有多大才好设置，而且开发环境和测试环境系统资源比较小，可能一下无法满足需求。
第二种方案：重写代码，使用循环代替递归。
参考文档：
https://blog.csdn.net/iq105/article/details/75355831
https://www.jianshu.com/p/14c005e9287c
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5aff6cc8383076bddb785d2a61e74ae/" rel="bookmark">
			G-buffer投影
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		操作原理和步骤：
1 转到裁剪空间坐标系
2 计算顶点在相机远裁剪面的位置（通过等比三角形）
3 计算要显示贴画的顶顶点
4 转到局部坐标系
5 -0.5scale &lt;= x&lt;=0.5*scale
-0.5scale &lt;= y&lt;=0.5*scale
6 计算 uv 坐标
x+= 0.5*scale
y += 0.5*scale
7 对纹理和遮罩图片进行采样
8 颜色输出
unity 官方 commandbuffer 例子里的，C#脚本这边很简略，只是在 LightingPass 前 new 了一个commandbuffer， 核心实现则在 Shader 中，vertex 和 fragment shader 代码如下：
struct v2f { float4 pos : SV_POSITION; half2 uv : TEXCOORD0; float4 screenUV : TEXCOORD1; float3 ray : TEXCOORD2; half3 orientation : TEXCOORD3; }; v2f vert (float3 v : POSITION) { v2f o; o.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e5aff6cc8383076bddb785d2a61e74ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b61e4f351ead8a7f32b1d021807ddde4/" rel="bookmark">
			关于vue.config.js中配置前端代理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前边 注意开发环境的本地代理或者测试环境的代理，在部署到正式上时，一定要换成线上的IP地址，不然，数据拿不到哦
代理配置
esay mock新地址 模拟接口地址 ， 就以第一个进行说明怎么配置和使用了, 只说代理配置部分，其它不再说明
新建项目（略过le... ）
ip地址配置成自动切换的
首先在项目中 新建 vue.config.js (cli配置文件) .env.development (配置开发和测试接口地址) .env.production (配置生产环境接口地址) 关于上边那个配置文件参考 vue-cli 文档，链接过去 的这一块内容
先放个项目目录 .env.production（将下边的内容放进去）
## 配置测试和本地开发时的 接口地址
VUE_APP_URL = "你的开发或测试接口地址"
.env.development（将下边的内容放进去）
## 配置 正式接口地址
VUE_APP_URL = "你的正式接口地址"
vue.config.js (代理配置参考文档 proxy 代理 )
以下边的接口来来测试（https://www.easy-mock.com/mock/5ce2a7854c85c12abefbae0b/api）
将.env.development（将下边的内容放进去）改掉，换成上边的地址
## 配置测试和本地开发时的 接口地址
VUE_APP_URL = "https://www.easy-mock.com/mock/5ce2a7854c85c12abefbae0b/api"
vue.config.js中的 devServer 属性 下 进行 配置
const port = 8589; // dev port // All configuration item explanations can be find in https://cli.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b61e4f351ead8a7f32b1d021807ddde4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/590123ac4092f539855762a3d13b6106/" rel="bookmark">
			Harbor 使用笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		镜像管理 删除镜像：
1、通过web界面管理
2、命令行清理空间
cd harbor docker-compose stop docker run -it --name gc --rm --volumes-from registry vmware/registry:2.6.2-photon garbage-collect --dry-run /etc/registry/config.yml docker run -it --name gc --rm --volumes-from registry vmware/registry:2.6.2-photon garbage-collect /etc/registry/config.yml docker-compose start 客户端对镜像操作 1、配置hosts解析：
echo "192.168.116.32 registry.iseeyou.cn " &gt;&gt;/etc/hosts 2、修改:/etc/docker/daemon.json
{ "insecure-registries":["registry.iseeyou.cn"] } 仓库配置
3、登录：
[root@gitlab ~]#
docker login registry.iseeyou.cn Username: user Password: User12345 WARNING! Your password will be stored unencrypted in /root/.docker/config.json.
Configure a credential helper to remove this warning.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/590123ac4092f539855762a3d13b6106/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/730acdec030b22d2719ea6989331d8be/" rel="bookmark">
			IDEA使用git命令commit的时候出现错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在idea里面修改了本地代码的时候，想推送到远程仓库，在commit的时候一直出现
出现了如上图所时的的问题，由于第一次遇到，纠结了好久。
在文件夹测试是可以提交到远程仓库的，但是在这里就一直出错。
我修改了如下配置
第一步选中自动出现的所有项目点击-号，然后通过+号，把自己的项目一个个添加进来
注意：
添加的时候一定要选择Git
完成以后重启idea就可以了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a82408da373a43ee1806f531edbefd0/" rel="bookmark">
			3.python学习笔记——Python数据类型转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有时候，我们需要对数据内置的类型进行转换，数据类型的转换，你只需要将数据类型作为函数名即可。
以下几个内置的函数可以执行数据类型之间的转换。这些函数返回一个新的对象，表示转换的值。
int(x [,base])
将x转换为一个整数
float(x)
将x转换到一个浮点数
complex(real [,imag])
创建一个复数
str(x)
将对象 x 转换为字符串
repr(x)
将对象 x 转换为表达式字符串
eval(str)
用来计算在字符串中的有效Python表达式,并返回一个对象
tuple(s)
将序列 s 转换为一个元组
list(s)
将序列 s 转换为一个列表
set(s)
转换为可变集合
dict(d)
创建一个字典。d 必须是一个序列 (key,value)元组。
frozenset(s)
转换为不可变集合
chr(x)
将一个整数转换为一个字符
ord(x)
将一个字符转换为它的整数值
hex(x)
将一个整数转换为一个十六进制字符串
oct(x)
将一个整数转换为一个八进制字符串
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0dfd03a80f680d73689e775d9aafba8f/" rel="bookmark">
			各种神经网络优化算法：从梯度下降，随机梯度下架，批量随机梯度下架，Adagrad，AdaDelta，Adam
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 一阶优化算法
这种算法使用各参数的梯度值来最小化或最大化损失函数E(x)，从而找到最合适的矩阵权重θ。最常用的一阶优化算法是梯度下降。
2 二阶优化算法
二阶优化算法使用了二阶导数(也叫做Hessian方法)来最小化或最大化损失函数。由于二阶导数的计算成本很高，所以这种方法并没有广泛使用。
1 梯度下降的公式。
网络更新参数的公式为：θ=θ−η×∇(θ).J(θ) ，其中η是学习率，∇(θ).J(θ)是损失函数J(θ)的梯度。
这是在神经网络中最常用的优化算法。
梯度下降的问题:
传统的批量梯度下降将计算整个数据集梯度，但只会进行一次更新，因此在处理大型数据集时速度很慢且难以控制，甚至导致内存溢出。
权重更新的快慢是由学习率η决定的，并且可以在凸面误差曲面中收敛到全局最优值，在非凸曲面中可能趋于局部最优值。
2 随机梯度下降。
随机梯度下降（Stochastic gradient descent，SGD）对每个训练样本进行参数更新，每次执行都进行一次更新，且执行速度更快。
频繁的更新使得参数间具有高方差，损失函数会以不同的强度波动。这实际上是一件好事，因为它有助于我们发现新的和可能更优的局部最小值，而标准梯度下降将只会收敛到某个局部最优值
3 小批量梯度下降
为了避免SGD和标准梯度下降中存在的问题，一个改进方法为小批量梯度下降（Mini Batch Gradient Descent），因为对每个批次中的n个训练样本，这种方法只执行一次更新。
为了避免SGD和标准梯度下降中存在的问题，一个改进方法为小批量梯度下降（Mini Batch Gradient Descent），因为对每个批次中的n个训练样本，这种方法只执行一次更新。
使用小批量梯度下降的优点是：
1) 可以减少参数更新的波动，最终得到效果更好和更稳定的收敛。
2) 还可以使用最新的深层学习库中通用的矩阵优化方法，使计算小批量数据的梯度更加高效。
3) 通常来说，小批量样本的大小范围是从50到256，可以根据实际问题而有所不同。
4) 在训练神经网络时，通常都会选择小批量梯度下降算法。
这种方法有时候还是被成为SGD
进一步优化梯度下降
1. 动量
SGD方法中的高方差振荡使得网络很难稳定收敛，所以有研究者提出了一种称为动量（Momentum）的技术，通过优化相关方向的训练和弱化无关方向的振荡，来加速SGD训练。换句话说，这种新方法将上个步骤中更新向量的分量’γ’添加到当前更新向量。
V(t)=γV(t−1)+η∇(θ).J(θ)
最后通过θ=θ−V(t)来更新参数。
当其梯度指向实际移动方向时，动量项γ增大；当梯度与实际移动方向相反时，γ减小。这种方式意味着动量项只对相关样本进行参数更新，减少了不必要的参数更新，从而得到更快且稳定的收敛，也减少了振荡过程。
Nesterov梯度加速法
一位名叫Yurii Nesterov研究员，认为动量方法存在一个问题：
如果一个滚下山坡的球，盲目沿着斜坡下滑，这是非常不合适的。一个更聪明的球应该要注意到它将要去哪，因此在上坡再次向上倾斜时小球应该进行减速。
实际上，当小球达到曲线上的最低点时，动量相当高。由于高动量可能会导致其完全地错过最小值，因此小球不知道何时进行减速，故继续向上移动。
Yurii Nesterov在1983年发表了一篇关于解决动量问题的论文，因此，我们把这种方法叫做Nestrov梯度加速法。
在该方法中，他提出先根据之前的动量进行大步跳跃，然后计算梯度进行校正，从而实现参数更新。这种预更新方法能防止大幅振荡，不会错过最小值，并对参数更新更加敏感。
Nesterov梯度加速法（NAG）是一种赋予了动量项预知能力的方法，通过使用动量项γV(t−1)来更改参数θ。通过计算θ−γV(t−1)，得到下一位置的参数近似值，这里的参数是一个粗略的概念。因此，我们不是通过计算当前参数θ的梯度值，而是通过相关参数的大致未来位置，来有效地预知未来：
V(t)=γV(t−1)+η∇(θ)J( θ−γV(t−1) )，然后使用θ=θ−V(t)来更新参数。注意，其中 θ−γV(t−1)，不是当前参数θ的梯度值，而是相关参数的大致未来位置。
现在，我们通过使网络更新与误差函数的斜率相适应，并依次加速SGD，也可根据每个参数的重要性来调整和更新对应参数，以执行更大或更小的更新幅度。
Adagrad方法
Adagrad方法是通过参数来调整合适的学习率η，对稀疏参数进行大幅更新和对频繁参数进行小幅更新。因此，Adagrad方法非常适合处理稀疏数据。
在时间步长中，Adagrad方法基于每个参数计算的过往梯度，为不同参数θ设置不同的学习率。
先前，每个参数θ(i)使用相同的学习率，每次会对所有参数θ进行更新。在每个时间步t中，Adagrad方法为每个参数θ选取不同的学习率，更新对应参数，然后进行向量化。为了简单起见，我们把在t时刻参数θ(i)的损失函数梯度设为g(t,i)。
4. AdaDelta方法
这是一个AdaGrad的延伸方法，它倾向于解决其学习率衰减的问题。Adadelta不是累积所有之前的平方梯度，而是将累积之前梯度的窗口限制到某个固定大小w。
Adam算法
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0dfd03a80f680d73689e775d9aafba8f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63fc6fab27e261e5ca669a1f88cc071a/" rel="bookmark">
			海康威视RTSP取流，主码流和子码流
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在做视频开发相关的工作，用到了海康威视的监控器摄像机，做一些记录。
RTSP取主码流和子码流
首先，本人使用的是海康威视的产品，其他产品可能有差异，播放器使用VLC。
获取主码流：（以下仅为本人根据自己摄像机设置，具体要看摄像机如何配置）
rtsp://admin:12345@192.168.2.65:554/h264/ch1/main/av_stream
或者简写为：rtsp://admin:12345@192.168.2.65
获取子码流：
rtsp://admin:12345@192.168.2.65:554/h264/ch1/sub/av_stream
其中：
admin：为摄像机账号，根据自己的摄像机填写
12345：为摄像机账号密码，根据自己的摄像机填写
192.168.2.65：为摄像机的IP地址，根据自己摄像机IP填写
554：RTSP端口默认值，需查看自己是否已经设置过
主码流和子码流区别
背景/冲突：摄像头拍摄的图像质量都比较高，如果网络传输 ，则需要比较高的带宽，而实际使用中带宽比较低，造成网络传输视频卡顿乱码等，不能传输高质量的图像视频。
解决：提出主码流和子码流概念
作用：主码流主要进行本地存储，子码流适用于视频在低带宽网络上的传输，主要是通过降低图片质量提高传输视频流畅性。
优点：解决了低带宽情况下不能传输高质量视频的问题，高质量的图像保存于本地，需要时随时查看，同时远程低带宽传输依然能看到流畅较清晰画面。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4676422ccefc2dbf593c7dfec853a954/" rel="bookmark">
			scrapy框架start_urls以及sart_requests分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		start_urls url列表。当 没有指定特定的url时，spider将从该列表中开始抓取。因此，第一个被获取到的页面的url僵尸该列表之一。后续的url将会从获取的数据中提取。
start_requests 该方法必须返回一个可迭代对象（iterable）。该对象包含了spider用于抓取的第一个Request。
当spider起订抓取并且未指定url时，该方法被调用。当指定了url时，make_requests_from_url()将被调用来创建request对象。该方法仅仅会被scrapy调用一次，因此您可以将其实现为生成器。
该方法的默认实现是使用start_urls的url生成request。
如果您想要修改最初抓取某个网站的request对象，您可以重写（override）该方法。例如，如果您需要在启动时以POST登录某个网站，你可以这么写：
def start_requests(self): return [scrapy.FormRequest ("http://www.example.com/login", formdata={'user': 'john', 'pass': 'secret'}, callback=self.logged_in)] def logged_in(self, response): # here you would extract links to follow and return Requests for # each of them, with another callback pass make_requests_from_url(url):
该方法接受一个url并返回用于抓取的request对象。该方法在初始化request时被start_requests()调用，也被用于转化url为request。
默认未被重写的情况下，该方法的request对象中，parse（）作为返回函数，dont_filter参数 也被设置为开启。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1df88618196bc0528fb946004a503e9/" rel="bookmark">
			手机返回按键的监听（mui html，手机物理键等）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		//返回上一页,按两次返回,按第一次提交记录,按第二次返回
pushHistory();
window.addEventListener("popstate", function(e) {
// alert("我监听到了浏览器的返回按钮事件啦"); //根据自己的需求实现自己的功能
edu.getTimer()//一个计时器的存库方法
}, false);
function pushHistory() {
var state = {
title: "title",
url: "#"
};
window.history.pushState(state, "title", "#");
}
参考地址：https://www.cnblogs.com/wancheng7/p/8542544.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8191eecde960b05d5dcf6af08e09dcf0/" rel="bookmark">
			git 出现错误 Could not resolve host: github.com 或者 gitlab.com 或者gerrit相关( 自有服务 )...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原来是因为github.com没有被主机给解析
1.第一步是 ping 你的gitlab 或者 github服务器ip地址
如果每隔几秒有 time = xx.ms 刷新 就证明是通的
2. 编辑 etc/host
gedit /etc/hosts 根据原有的样式 添加需要新增的目标地址
112.111.11.111 gerrit.xxx.cn 3. 现在应该可以 成功 git clone
转载于:https://www.cnblogs.com/clemente/p/10936964.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac2f63623020541be43fad55751efe78/" rel="bookmark">
			求一个正整数的正因子数和正因子和
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		算术基本定理的应用：
（1）一个大于1的正整数N，如果它的标准分解式为：
，那么它的正因数个数为
（2） 它的全体正因数之和为
求因子数
#include&lt;iostream&gt; using namespace std; #define N 1000 int p[N],a[N]; int main() { int n; cin &gt;&gt; n; int k = 0; //n为合数 for(int i = 2; i * i &lt;= n; i++) if(n % i == 0) { p[k] = i; while(n % i == 0) a[k]++,n /= i; k++; } //n为质数	if(n &gt; 1) { p[k] = n; a[k] = 1; k++; } int num = 1; for(int i = 0; i &lt; k; i++) num *= (1 + a[i]); cout &lt;&lt; num &lt;&lt; endl; return 0; } 进一步简化
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac2f63623020541be43fad55751efe78/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a7e07f344744a84388d85a7d7cbb746/" rel="bookmark">
			js将16进制颜色转为带透明度的颜色
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/**
* 十六进制颜色值转为带透明度的颜色
* @param _color 十六进制颜色
* @param _opacity 透明度
* @returns {string} rgba
*/
hexToRGBA: function(_color, _opacity) {
var sColor = _color.toLowerCase();
//十六进制颜色值的正则表达式
var reg = /^#([0-9a-fA-f]{3}|[0-9a-fA-f]{6})$/;
// 如果是16进制颜色
if (sColor &amp;&amp; reg.test(sColor)) {
if (sColor.length === 4) {
var sColorNew = "#";
for (var i = 1; i &lt; 4; i += 1) {
sColorNew += sColor.slice(i, i + 1).concat(sColor.slice(i, i + 1));
}
sColor = sColorNew;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a7e07f344744a84388d85a7d7cbb746/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0cedbde14772521a4b56c32e8b5a81b5/" rel="bookmark">
			Python百钱百鸡问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 百钱百鸡：我国古代数学家张丘建在《算经》一书中提出的数学问题：鸡翁一值钱五，鸡母一值钱三，鸡雏三值钱一。百钱买百鸡，问鸡翁、鸡母、鸡雏各几何？ 译文：公鸡一只5元，母鸡一只3元，小鸡3只1元。如何用100元买100只鸡。其中公鸡，母鸡，小鸡的数量各是多少
方法一：穷举法 // 穷举法 // 分析：公鸡最多买：20只，母鸡最多买：33只。设：公鸡x只，母鸡y只，小鸡z只 // 则 0&lt;x&lt;20, 0&lt;y&lt;33, z=100-x-y for x in range(0,20): for y in range(0,33): z=100-x-y if 5*x+3*y+z/3 == 100: print('公鸡：%s 母鸡：%s 小鸡：%s'%(x, y, z)) 方法二：随机数法 // 随机数法 // 分析：公鸡最多买：20只，母鸡最多买：33只。设：公鸡x只，母鸡y只，小鸡z只 import random while True: x = random.randrange(0,20) y = random.randrange(0,33) z = random.randrange(0,100) if 5*x+3*y+z/3 == 100 and x+y+z == 100: print('公鸡:',x) print('母鸡:',y) print('小鸡:',z) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9fba947d50975279520cb8699eaa3a39/" rel="bookmark">
			Python实现寻找完美数问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 寻找完美数
何为完美数？
完全数（Perfect number），又称完美数或完备数，是一些特殊的自然数。它所有的真因子（即除了自身以外的约数）的和（即因子函数），恰好等于它本身。如果一个数恰好等于它的因子之和，则称该数为“完全数”。第一个完全数是6，第二个完全数是28，第三个完全数是496，后面的完全数还有8128、33550336等等。
6 = 1+2+3
28 = 1+2+4+7+14
实现 // 寻找1000以内的完美数 for i in range(1,1000): num = 0 for k in range(1,i): if i%k == 0: num += k if i == num: print i 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e738b0b187dfb9bbe2f703d55d0a7eef/" rel="bookmark">
			Maven入门教程（十）-继承的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Maven继承
抽取重复的配置，如：groupId，version等。在使用的时候子工程直接继承父工程的版本号，子工程中不再需要指定版本号，方便统一管理项目的依赖版本问题。
下面是Maven继承示例的步骤
创建父工程，将公共信息设置在父工程的pom.xml里
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.learn.maven&lt;/groupId&gt; &lt;artifactId&gt;mavendemo-parent&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;modules&gt; &lt;module&gt;mavendemochild&lt;/module&gt; &lt;/modules&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;description&gt;父工程&lt;/description&gt; &lt;!--抽取子工程的依赖--&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.1.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;5.1.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;/project&gt; IDEA创建Maven子工程
new-module
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;!--引用父工程--&gt; &lt;parent&gt; &lt;artifactId&gt;mavendemo-parent&lt;/artifactId&gt; &lt;groupId&gt;org.learn.maven&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.learn.maven&lt;/groupId&gt; &lt;artifactId&gt;mavendemochild&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; 此处重点是子工程pom.xml中设置&lt;parent&gt;标签用于引用父工程。
以下是Maven父子工程的目录结构
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e738b0b187dfb9bbe2f703d55d0a7eef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/855b069218c0ce804f3291a73f7b040d/" rel="bookmark">
			下辈子，你还会选择当程序员吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先，大家先来看一组图片：
其实，这是一个浏览器上的推送，我清清楚楚地记得，这一篇推送没有人评论，没有人点赞，是因为大家都沉默了吗？我觉得大家应该是也很无奈啊。
IT行业的难题，程序员的苦逼日子，我这个刚刚入门的小菜鸟是没有资本去评论一番的，但是我还是想以一个刚刚入门的菜鸟，或者以一个学生的身份和视角来谈谈这个问题。
我是农村出来的孩子，在上大学之前，我的脑子里只有一件事，考上大学，因为在大家的眼里，考上大学以后，就会有出息了！当然，我也这么觉得。有出息了以后，就可以挣好多好多钱了，那样就再也没有人瞧不起我了，我就可以买我想要的任何东西！穷，在某种程度上左右了我的高考志愿。
网上有这么一段话，从底层阶级，爬到上层阶级的捷径只有两个，第一，金融，第二，IT。金融行业相比于IT行业风险较大，这大家都有所了解。而IT，也不是十全十美，相反，他的苦衷，比金融行业估计还要大。我在无聊时经常看一些调侃程序员和IT行业的段子，什么996，什么秃头，什么腰间盘突出，什么未老先衰，什么中年危机，什么压力山大等等等等似乎成为了程序员的标签，而程序员，又是IT行业的标签，这么看来，上面的那些调侃，名义上是在调侃程序员，实则是在调侃整个IT行业。
我在报考志愿的时候，选择了计科，我想，报了计算机，应该会挣好多钱了吧，事实上确实是这么回事，如果按照平均薪资水平来算的话，我在老家县城算是小资级别的人物了！但是，挣得多，确实，可在北上广深这些城市，花销也很大，房价也天高，白手起家，自己只能通过自己的力量一点点攒够在那些大城市定居的资本，这可不是一笔小数目。相信所有的已经工作的正准备买房的前辈们有所体会，但是，工资高，确实，但是又能挣几年钱呢？前一段时间的996，就是IT工作者的真实写照，加班加点，熬夜敲代码，是大部分码农的日常。
35岁的中年危机，是码农们要考虑的一大问题，还能不能在这个行业继续干下去，自己还有没有精力坚持下去，都是他们需要考虑的问题。国外的程序员和国内的程序员的待遇简直是天壤之别，国外的程序员的生活有滋有味，国内的则是在夹缝中生存。有一种说法是，30岁才是刚刚入门IT，这才是第一步，以后要学习好多好多东西，一直干，一直学，干到退休，学到退休。可目前国内的现状是，30岁在走下坡路，如果不转管理层，很容易被新来的菜鸟给代替，菜鸟们学得快，身体好，自己不被挤下去，感觉都对不起这个行业。
可是大家有没有想过，自己为什么才30岁身体就不好了，大概可能是干了6、7年了，加班了6、7年了，身体素质不行了，平常也没时间锻炼身体，所以就未老先衰了。试想，如果自己真正掌握核心技术，自己有别人不可取代的地方，那么就算互联网的寒冬再寒冷，也不会将自己冻死！
码农的工作其实很简单，Ctrl+C+V，一天天的搬砖，这种工作，毫无技术含量，肯定很容易被新一代程序员取代啊，试想，如果自己是算法工程师，高级数据分析师，高级Android工程师，就算来再多菜鸟，也轮不到自己被取代。不要说自己年龄已经大了，学不会了，国外那位开发游戏的老太太都那个岁数了，还能学呢，自己才这么年轻，有什么学不会的。虽然那些不管你是本科生，研究生，大专生，初中生，高中生，只要你愿意去学，愿意花时间在投资自己上，而不是一天天地惆怅程序员的日子多苦逼，IT行业压力多大，那你也会成为互联网的领军人物，技术人才，不可取代，有自己的一片天，而不是照片中的那样，无奈却又无力去改变。
此生，我无悔入IT！
最后，希望大家能够发展的越来越好！
ps：自己第一次写这种感慨，目前现在在上大一，文章肯定会有不妥地方，希望各位前辈们不吝指教，也希望大家能指点一番，晚辈将不胜感激。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbc0d418be7dc3605882ed41b401940d/" rel="bookmark">
			Layui监听事件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Layui监听事件
开发工具与关键技术：VS MVC、SQL、JS 撰写时间：2019/5/25 表格事件监听可以实现，点击当前的数据，获取到当前的数据，赋值给想显示数据的from表单，或其他表格。表格事件监听的好处那么多，怎样可以实现简单易懂的事件监听呢？额！还是通过layui插件来实现这个监听功能，layui插件提供了监听多种事件。
监听复选框选择：点击复选框时触发，回调函数返回一个object参数
table.on(‘checkbox(test)’,function(obj){ console.log(obj.checked);//当前是否选中状态 console.log(obj.data);//选中行的相关数据 console.log(obj.type);//如果触发的是全选，则为：all，如果触发的是单选，则为：one }); 监听行的单击或双击事件：row（单击）、rowDoub（双击）
一个简单的监听行的单击事件：
t
able.on(‘row(test)’,function(obj){ //test是table原始容器的属性 lay-filter=“对应的值” console.log(obj.tr);//得到当前行元素对象 console.log(obj.data);//得到当前行数据 //obj.del();//删除当前行 //obj.update(fields);//修改当前行数据 }); 无论layui监听的是什么事件，都要在html布局的table标签上加上layui-filter=“”的对应值，否则监听事件就会失效。例如：&lt;table id="demo" layui-filter="test"&gt;&lt;/table&gt;
通过layui渲染出数据表格之后，监听表格行的点击事件，把表格的数据赋值绑定到from表单中；其监听绑定的效果图如下：（图片上涉及的信息属于虚构的测试数据）
监听绑定from的代码如下：
layuiTable.on('row(TabSupplierInformation)', function (raot) { var data = raot.data;//获取点击行数据 //表格数据 绑定到from表单中 $("#SupplierNum").val(data.SupplierNum);//绑定编号 $("#SupplierName").val(data.SupplierName);//绑定名称 $("#SupplierBusiness").val(data.SupplierBusiness);//绑定主营业务 $("#SupplierTele").val(data.SupplierTele);//绑定电话 $("#SupplierAddress").val(data.SupplierAddress);//绑定地址 $("#SupplierWeb").val(data.SupplierWeb);//绑定网站 $("#SupplierLinkname").val(data.SupplierLinkname);//绑定联系人 $("#SupplierFax").val(data.SupplierFax);//绑定传真 $("#SupplierPhone").val(data.SupplierPhone);//绑定手机 $("#SupplierMailbox").val(data.SupplierMailbox);//绑定邮箱 $("#SupplierRemark").val(data.SupplierRemark);//绑定备注 $("#PinyinCode").val(data.PinyinCode);//拼音码 $("#WarehouseAddress").val(data.WarehouseAddress);//库房地址 $("#WarehousePhone").val(data.WarehousePhone);//库房电话 $("#SupplierTax").val(data.SupplierTax);//税号 $("#SupplierMoney").val();//应付款 }); 选中一行数据，显示另外一个表格数据，即表2的数据，根据表1的数据进行显示。这种情况同样可以根据行的单击事件来实现筛选数据，在监听事件中添加表2得重载事件即可。
//监听行单击事件（双击事件为：rowDouble）
layuiTable.on('row(tabNotice)', function (rate) { var data = rate.data;//获取点击行数据 //标注选中样式 rate.tr.addClass('layui-table-click').siblings().removeClass('layui-table-click'); var noticeID = data.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bbc0d418be7dc3605882ed41b401940d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6cd64176bbe129b1ac10ea4d4fa27f62/" rel="bookmark">
			Java中如何获取当前系统时间的字符串格式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在实际开发过程中，有时需要获取系统当前的时间，如用户注册时的注册时间，虽然用户不需要填写注册时间，但是在后台需要获取当前的系统时间作为注册时间。本实例介绍的是在Java中如何获取系统当前时间的字符串格式：
首先，创建一个时间格式化的工具类StringUtil，定义两个接收时间格式化字符串的静态变量，然后在创建两个格式化字符串的两个方法，一个是使用Calendar对象获取系统当前时间的方法，另外一个是使用Date对象获取系统当前的时间的方法。
第一个方法，主要用Calendar对象来获取到每个时间，然后来进行拼接要返回的时间字符串。
第二个方法，主要是创建Date中的对象，获取到当前系统的时间，其中date对象获取到的就是当前系统的时间，然后创建时间格式类SimpleDateFormat对象，在该对象传入需要格式化时间格式化的参数“yyyy-MM-dd HH:mm:ss”，最后调用SimpleDateFormat对象方法format(Date date)，进行格式化当前系统时间Date对象，返回该时间格式化字符串：
然后，创建一个测试类，来验证上面的两种方法返回的值是否是我们需要的时间格式字符串，下面是测试代码块：
从控制台输出的结果来看，这两个时间都是我们需要的格式化字符时间，两种方法的返回结果基本一致，其中最常用的还是第二种方法，因为从格式化时间来，显然是比第一种方法要简单的，从方法的返回的时间字符串来看，比第一种的方法更符合时间的格式。
在实际的开发应用中，经常需要根据当前系统时间来实现一些业务逻辑，比如通过时间字符串来拼接订单号等，所以要应该掌握这里的两种获取时间字符串的方法。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4cd9a0558fe2d728f08b7369697c6b68/" rel="bookmark">
			程序、进程、线程之间的联系和区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、进程 进程是程序执行的实例，即运行中的程序，也是程序的副本；程序放置于磁盘中，而进程放置于内存中；进程的启动及调度均是由内核发起的。init是所有进程的子进程，儿子进程是由fork()进程生成。
1、概念 从用户的角度来说，进程就是程序的一次动态执行过程。
从操作系统角度：操作系统分配内存，CPU时间等系统资源的基本单位。
2、特点 （1）、每一个进程都有自己独立的虚拟地址空间和进程状态。
（2）、进程是分配资源 的最小单位（基本单位）
3、进程和程序的区别和联系 联系 1、程序=文件（静态的可执行文件）
2、进程=执行中的程序=程序+执行状态
3、同一个程序的多次执行对应为不同的进程（ls的多次执行对应多个不同进程）
4、进程执行需要的资源：内存（保存代码和数据）+cpu（执行指令）
区别 1、程序是静态的，进程是动态的
（1）、程序是有序代码的集合
（2）、进程是程序的执行，进程有内核状态、用户态。
2、进程相对于程序的生命周期是短暂的，程序是永久的
3、进程有PCB的数据结构
（1）、程序 ：数据段+代码段
（2）、进程 ：代码段+数据段+堆栈+PCB
4、一个进程只能对应一个程序，一个程序可以对应多个进程
二、线程 1、线程和进程的区别 LWP :轻量级的进程，本质仍然是进程（linux环境下）
进程：进程有独立的地址空间（0-4G），拥有PCB
线程：拥有自己的PCB，但是没有独立的地址空间（共享）
区别：在于是否共享地址空间
独居（进程） ； 合租 （线程）
linux下 ：
线程：最小的执行单位
进程：最小的分配资源单位，可以看成是只有一个线程的进程。
2、linux内核线程实现原理 进程和线程关系 1、轻量级进程也有PCB，创建线程使用的底层函数和进程是一样的，都是clone。
2、从内核里看进程和线程是一样的，都有各自不同的PCB，但是PCB中指向内存资源的三级页表是相同的。
三级映射：进程PCB --&gt; 页目录(可看成数组，首地址位于PCB中) --&gt; 页表 --&gt; 物理页面 --&gt; 内存单元
3、进程可以蜕变成线程。
4、线程可以看做寄存器和栈的集合。
5、在linux下，线程是最小的执行单位，进程是最小的分配资源单位。
6、察看LWP号：ps –Lf pid 查看指定线程的lwp号。
进程号：cpu分配时间轮片的依据
MMU帮忙把虚拟地址映射到物理地址上
3、线程优缺点 1、优点 1、提高程序的并发性
2、开销小
3、数据通信、共享数据方便
2、缺点 1、线程里面的函数都是库函数，不稳定。（进程里面绝大多数函数都是系统函数）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4cd9a0558fe2d728f08b7369697c6b68/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/266f68fa62c41ab2d7c453aeeafddf55/" rel="bookmark">
			c#自定义ORM框架---（泛型&amp;反射&amp;实体类扩展属性&lt;附带通用增、删、查、改&gt;）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		该教材主要是运用到泛型、反射和实体类扩展属性 步骤一、建立扩展属性类
实体类扩展属性要继承Attribute基类完成
1 [AttributeUsage(AttributeTargets.Property)] 2 public class FieldAttribute : Attribute 3 { 4 /// &lt;summary&gt; 5 ///是否为主键（true/false） 6 /// &lt;/summary&gt; 7 public bool PropertyKey { get; set; } 8 /// &lt;summary&gt; 9 /// 是否为自动增长（true/false） 10 /// &lt;/summary&gt; 11 public bool Identity { get; set; } 12 } 1 [AttributeUsage(AttributeTargets.Class)] 2 public class TableAttribute:Attribute 3 { 4 /// &lt;summary&gt; 5 /// 数据库表名 6 /// &lt;/summary&gt; 7 public string TableName { get; set; } 8 } 步骤二、创建实体类并引用扩展实体类属性
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/266f68fa62c41ab2d7c453aeeafddf55/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a83944175fb520950fe84a7c6bc2b773/" rel="bookmark">
			Microsoft Edge浏览器文件保存位置记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现在流行的Windows 10操作系统基本上都是使用Edge浏览器了，作为一个重要的在线下载工具，我得知道他把我下载的文件保存到什么地方去了。下面就记录下这两天观察到的。 1.要是直接点击下载，另存为xxx，那我就不讨论了，文件被保存到相应的地方就是了。
我要说的是第二种情况。
2.很多情况下，都是直接点击下载--&gt;运行，ok那么你下载的可执行文件就被这浏览器当作临时文件保存在：C:\Users\marge\AppData\Local\Packages\Microsoft.MicrosoftEdge_8wekyb3d8bbwe目录的tempstate文件夹里面。
比如我下载了个qq音乐
但是，由于没有点击保存，浏览器把它当作临时文件保存，
所以，你关闭浏览器过后，文件就被清除掉了。有用的文件最好还是保存吧，一次性的直接运行。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a513f6c57af557024152f432cf9ad31/" rel="bookmark">
			windows安装torch_geometric教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：在安装torch_geometric之前本人已经安装好numpy、scipy、panda、torch等模块，不知道是否需要这些模块，可能不需要，不过既然你用到torch_geometric 了，我感觉这些模块你应该已经安装好了~~
安装 torch_geometric 真的有点费劲，整理一下过程，帮助有需要的同学。
1、需要依次安装如下第三方模块： isodate：下载链接 https://pypi.org/project/isodate/#filesrdflib：下载链接 https://pypi.org/project/rdflib/#filesplyfile：下载链接 https://pypi.org/project/plyfile/#filespytest-runner：下载链接 https://pypi.org/project/pytest-runner/#files 本人统一使用 pip 来安装，以安装 isodate 为例：
可以根据python版本需要，选择下载 .whl 文件或者 .tar.gz 文件，本人python版本是3.5.2，因此选择了 .tar.gz 文件，将文件下载后放到python的安装目录的script下，本人的是D:\\Software\\python35\\Scripts，然后进入cmd ，切换到上面的路径，输入pip install isodate-0.6.0.tar.gz 回车，即可安装。
下载 .whl 文件操作方法一模一样，输入 pip install ***.whl 回车即可。
2、安装torch_geometric 以上依赖的模块安装完成后，进入我们的正题。
torch_geometric下载地址：https://pypi.org/project/torch-geometric/#files
方法和之前的一样，pip 安装。
安装好后检查是否成功~
搞定~~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7d68ad2ffcfdac77e48e66d8c6903d8/" rel="bookmark">
			通用解决LocalDateTime转为字符串后中间含“T”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		@Configuration public class LocalDateTimeSerializerConfig { @org.springframework.beans.factory.annotation.Value("${spring.jackson.date-format:yyyy-MM-dd HH:mm:ss}") private String pattern; @Bean public LocalDateTimeSerializer localDateTimeDeserializer() { return new LocalDateTimeSerializer(DateTimeFormatter.ofPattern(pattern)); } @Bean public Jackson2ObjectMapperBuilderCustomizer jackson2ObjectMapperBuilderCustomizer() { return builder -&gt; builder.serializerByType(LocalDateTime.class, localDateTimeDeserializer()); } } 复制代码 转载于:https://juejin.im/post/5ceb4f156fb9a07f06554b63
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f42b6e3a4f60faa642cbb4754795625/" rel="bookmark">
			REST与RPC区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OSI网络七层模型 第一层：应用层。定义了用于在网络中进行通信和传输数据的接口；第二层：表示层。定义不同的系统中数据的传输格式，编码和解码规范等；第三层：会话层。管理用户的会话，控制用户间逻辑连接的建立和中断；第四层：传输层。管理着网络中的端到端的数据传输；第五层：网络层。定义网络设备间如何传输数据；第六层：链路层。将上面的网络层的数据包封装成数据帧，便于物理层传输；第七层：物理层。这一层主要就是传输这些二进制数据 实际应用过程中，五层协议结构里面是没有表示层和会话层的。应该说它们和应用层合并了。我们应该将重点放在应用层和传输层这两个层面，因为RPC主要是基于TCP/IP协议（传输层协议），HTTP主要是基于HTTP协议（应用层协议）。
1、什么是REST？
REST是一种架构风格，指的是一组架构约束条件和原则。满足这些约束条件和原则的应用程序或设计就是 RESTful。REST规范把所有内容都视为资源，网络上一切皆资源。REST并没有创造新的技术，组件或服务，只是使用Web的现有特征和能力。 可以完全通过HTTP协议实现，使用 HTTP 协议处理数据通信。REST架构对资源的操作包括获取、创建、修改和删除资源的操作正好对应HTTP协议提供的GET、POST、PUT和DELETE方法。
HTTP动词与REST风格CRUD对应关系：
2、什么是RPC
Remote Procedure Call，远程过程调用，就是像调用本地方法一样调用远程方法。RPC架构图：
RPC框架包含4个核心的组件，分别是Client ,Server,Client Stub以及Server Stub，这个Stub大家可以理解为存根
客户端（Client），服务的调用方。服务端（Server），真正的服务提供者。客户端存根，存放服务端的地址消息，再将客户端的请求参数打包成网络消息，然后通过网络远程发送给服务方。服务端存根，接收客户端发送过来的消息，将消息解包，并调用本地的方法 RPC框架要做到最基本的3件事情：
1）服务端如何确定客户端要调用的函数；
在远程调用中，客户端和服务端分别维护一个【ID-&gt;函数】的对应表， ID在所有进程中都是唯一确定的。客户端在做远程过程调用时，附上这个ID，服务端通过查表，来确定客户端需要调用的函数，然后执行相应函数的代码。
2）如何进行序列化和反序列化；
客户端和服务端交互时将参数或结果转化为字节流在网络中传输，那么数据转化为字节流的或者将字节流转换成能读取的固定格式时就需要进行序列化和反序列化，序列化和反序列化的速度也会影响远程调用的效率。
3）如何进行网络传输
多数RPC框架选择TCP作为传输协议，也有部分选择HTTP。如gRPC使用HTTP2。不同的协议各有利弊。TCP更加高效，而HTTP在实际应用中更加的灵活
3、REST与RPC比较
4、REST与RPC应用场景
REST和RPC都常用于微服务架构中。
1）HTTP相对更规范，更标准，更通用，无论哪种语言都支持http协议。如果你是对外开放API，例如开放平台，外部的编程语言多种多样，你无法拒绝对每种语言的支持，现在开源中间件，基本最先支持的几个协议都包含RESTful。
2）RPC 框架作为架构微服务化的基础组件，它能大大降低架构微服务化的成本，提高调用方与服务提供方的研发效率，屏蔽跨进程调用函数（服务）的各类复杂细节。让调用方感觉就像调用本地函数一样调用远端函数、让服务提供方感觉就像实现一个本地函数一样来实现服务
5、流行的RPC框架
1）gRPC是Google最近公布的开源软件，基于最新的HTTP2.0协议，并支持常见的众多编程语言。 我们知道HTTP2.0是基于二进制的HTTP协议升级版本，目前各大浏览器都在快马加鞭的加以支持。 这个RPC框架是基于HTTP协议实现的，底层使用到了Netty框架的支持。
2）Thrift是Facebook的一个开源项目，主要是一个跨语言的服务开发框架。它有一个代码生成器来对它所定义的IDL定义文件自动生成服务代码框架。用户只要在其之前进行二次开发就行，对于底层的RPC通讯等都是透明的。不过这个对于用户来说的话需要学习特定领域语言这个特性，还是有一定成本的。
3）Dubbo是阿里集团开源的一个极为出名的RPC框架，在很多互联网公司和企业应用中广泛使用。协议和序列化框架都可以插拔是及其鲜明的特色。同样 的远程接口是基于Java Interface，并且依托于spring框架方便开发。可以方便的打包成单一文件，独立进程运行，和现在的微服务概念一致
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/369a04d98cff7472ba9ee7a5467f6acc/" rel="bookmark">
			深入RPC分布式原理[python]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分布式本质上不过是将多个单机服务组合在一起对外提供服务
1、客户端
当 RPC 服务部署在多个节点上时，客户端得到的是一个服务列表，有多个 IP 端口对。客户端的连接池可以随机地挑选任意的 RPC 服务节点进行连接，每个服务节点应该有个权重值，当所有节点的权重值一样时，它们的流量分配就是均匀的。如果某个节点的相对权重值较小，它被客户端选中的概率也会相对比较小。
class RPCNode {
String addr; // 服务地址
int weight; // 节点权重
}
class RPCCluster {
RPCNode[] nodes; // 节点列表
Node random(); // 按权重随机挑选节点
}
2、容灾Failover
当有一个服务节点挂掉时，客户端需要采取一定的策略避免请求失败。当请求失败时，客户端还要进行重试，但是也不可以无限重试，要有一定的重试策略。比如当节点挂掉时，将失效节点摘除，放置到失效节点列表中。然后每隔一段时间检查失效节点是否恢复了，如果恢复了，那就从失效节点中移除，再将节点地址重新加入到有效节点列表中。那如何判断节点真的挂掉了呢，一般需要设置一个时间窗口，统计在一定时间窗口里出现的错误数量。如果这个数量过大，那就意味着失效了。这也是为了防止网络偶然抖动导致服务节点流量的大幅波动。
3、降权法
上面提到客户端会为每个节点赋予一个权值，改变权值就可以改变节点的相对流量。如果某个节点出现了一次调用错误，可以对该节点进行降权。如果错误次数过多，降权会降的很快，最终达到一个最小值。之所以不应该降到零，那是为了给节点提供一个恢复的机会。被降权的节点后来只要有一次调用成功，那么 weight 值就应该尽快被还原，这样节点就可以快速恢复为正常节点。
客户端一次调用失败会尝试重试。如果降权太慢，会导致重试次数太多，因为第二次随机挑选节点时还是很有可能再次挑选到失效节点。降权太快也不好，网络抖动会导致节点流量分配的快速抖动，瞬间从正常降到近零，又可以瞬间从近零恢复到正常。
一个简单的策略是权重减半法。错误一次权重减半，连续错误两次权重就降到 1/4，如此直到降到最小值。如果初始权重值是 1024，那么权重值就会逐渐衰减1024=&gt;512=&gt;256=&gt;128=&gt;64=&gt;32=&gt;16=&gt;8=&gt;4=&gt;2=&gt;1。如果节点恢复了，那么调用会成功，权重就可以直接恢复到正常值，也可以通过加倍法逐渐恢复到正常值1=&gt;2=&gt;4=&gt;8=&gt;16=&gt;32=&gt;64=&gt;128=&gt;256=&gt;512=&gt;1024。如果希望恢复的更快一点，可以通过乘 4 法，乘 8 法。
4、服务发现
健壮的服务应该是可以支持动态扩容的服务。比如 RPC 服务压力过大，希望通过增加节点的方式来减小单个 RPC 服务的压力。如果使用的是前面的静态 RPC 服务地址列表，那么当节点增加时，我们需要修改客户端的配置重启才能生效。通过服务发现技术，当 RPC 服务节点增加或减少时，客户端可以动态快速收到服务列表的变更信息，从而可以实时调整连接配置，这样无需重启就可以完成服务的扩容和缩容
class ServiceDiscovery(object):
def register_service(self, name, addr):
pass
def get_services(self, name):
pass
def on_services_changed(self, name):
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/369a04d98cff7472ba9ee7a5467f6acc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d928bc69feb0d3e9d39b0afa66b7c557/" rel="bookmark">
			某计算机的Cache共有16块，采用2路-组相联映射方式(即每组包括2块)。存储器按字节编址，每个主存块大小为32字节。请计算129号主存单元所在的主存块应装入到的Cache组号。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		某计算机的Cache共有16块，采用2路-组相联映射方式(即每组包括2块)。存储器按字节编址，每个主存块大小为32字节，请问：
Cache如何分组、分块？主存如何分组、分块？计算129号主存单元所在的主存块应装入到的Cache组号。 解答思路一：
1.组相联映射方式下，主存块按模Q(Q为Cache组数)映射到Cache对应组中的任一块；
Cache共有16块，采用2路组相联映射，故Cache共分16/2=8组，每组2块。每块32B。
2.主存分为若干组，每组又分成8块。每块32字节。
3.129的二进制表示为10000001→0...010000001（组内块序号为100）如下图，所以组号为4
解答思路二：
1.cache共有16块，采用2路组相联映射，所以共有8组，每组2块，每块32B。
2.主存分为若干组，每组又分成8块。每块32字节。
3..由于主存块大小为32字节，所以129号单元位于第4块上(129/32取整等于4)。
而cache共有16块，采用2路组相联映射，所以共有8组。
主存块号i与Cache组号j映射关系为：j=i mod 8，所以j=4 mod 8=4，即129号单元装入到第4组。
PS：本人也是在学习过程中，如有不对的地方，希望大家可以指正，谢谢。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5aacfe6f276ca6504711ea13ba82bd9f/" rel="bookmark">
			UNC路径转本地路径
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		UNC应用（Universal Naming Convention）通用命名规则，比如网络访问文件UNC路径就是
\\servername\sharename\directory\filename比如就是\\\\192.168.0.1\\mydocs\\x.txt对应本地路径D:\\tete\\x.txt,这个就是在注册表
HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\LanmanServe\Shares里有映射关系。mydocs映射着本地路径D:\\tete，通俗就是一个文件夹被共享。一般在安全软件下规则在本地路径，所以要把UNC路径转换成本地路径。
思路
在第三个和第四个"\"之间的就是share的valuekey名字，然后把期求出，然后遍历判断多字符串是否是path
开头，然后拼接起来，找到。那把注册表中的数据读入到一个buffer，解析这个buffer可以用一个指针指向buffer，可以用
for(p=multistrz;*p==L'\0';p=p+wcslen(p)+1)
下面是代码，自己给自己挖的坑一个是找子串时候MaximumLength没设置导致找不到path，其次是unicode_string拼接函数记错，还有就是代码unicodeString找子串和找字符位置参考了大佬们的代码
/* \\servername\sharename\directory\filename比如就是 \\\\192.168.0.1\\mydocs\\x.txt-&gt;D:\\tete\\x.txt,这个就是在注册表 HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\LanmanServe\Shares里有映射关系。mydocs映射着本地路径。一般在安全软件下规则在本地路径，所以要把UNC路径转换成本地路径。 --------------------- 作者：kernweak 来源：CSDN 原文：https://blog.csdn.net/youyou519/article/details/90523662 版权声明：本文为博主原创文章，转载请附上博文链接！ */ #include&lt;ntddk.h&gt; #include&lt;ntstrsafe.h&gt; #ifndef MAX_PATH #define MAX_PATH 260 #endif // !MAX_PATH #define REG_PATH L"\\Registry\\Machine\\SYSTEM\\CurrentControlSet\\Services\\LanmanServer\\Shares" #define DEVICE_NAME L"\\device\\U2LDrv" #define LINK_NAME L"\\dosdevices\\U2LDrv" //实现strchr WCHAR* RTLUnicodeStringChr(PUNICODE_STRING IN pStr, WCHAR chr) { ULONG i = 0; ULONG size = pStr-&gt;Length&gt;&gt;1; for (i = 0; i &lt; size ; i++) { if (pStr-&gt;Buffer[i] == chr) { return pStr-&gt;Buffer + i; } } return NULL; } //实现strstr WCHAR* RTLUnicodeStringStr(const PUNICODE_STRING IN pStr, const PUNICODE_STRING IN pSubStr) { USHORT uLengthStep = 0; USHORT uStrlen = pStr-&gt;Length; USHORT uSubStrlen = pSubStr-&gt;Length; USHORT i = 0; UNICODE_STRING str1 = { 0 }; str1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5aacfe6f276ca6504711ea13ba82bd9f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bacecf1c3790fbad42116f1f0de10463/" rel="bookmark">
			AD15在原理图选中PCB中的元件并将其控制在指定区域的快捷方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1. 确保你的输入法在全英文状态（按alt+shift切换） 2. 在原理图中选中器件，按 T+S 3. 跳转到PCB界面，元件一倍选中。再按 T+O+L ，画一个框。 4. 元件已经被规划到指定位置 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0af4328cee1bfeb2f6459a4f98c2a669/" rel="bookmark">
			C&#43;&#43; Jsoncpp 常用技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++ Jsoncpp 常用技巧 Json对象循环遍历Array数组循环遍历char*转JsonJson转string Json对象循环遍历 代码样式
int main() { Json::Value json_value = Json::Value(Json::objectValue); json_value["object_one"] = 1; json_value["object_two"] = 2; json_value["object_three"] = 3; json_value["object_a"] = 4; Json::Value::Members mem = json_value.getMemberNames(); for (Json::Value::Members::iterator iter = mem.begin(); iter != mem.end(); ++iter) { cout &lt;&lt; *iter &lt;&lt; " : " &lt;&lt; json_value[*iter]; } return 0; } 运行结果
object_a : 4 object_one : 1 object_three : 3 object_two : 2 总结：使用迭代器去遍历Json对象时，会按照key的值排序进行输出，而不是按照添加key_value的顺序输出；
Array数组循环遍历 代码样式
int main() { Json::Value json_value = Json::Value(Json::arrayValue); json_value.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0af4328cee1bfeb2f6459a4f98c2a669/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37c53e53a50836ad6e79d5b5443c2fa1/" rel="bookmark">
			SLR(1)分析法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 SLR分析法的基本思想SLR(1)分析表的构造 LR(0)文法要求文法的每一个LR(0)项目都不含有冲突的项目，这个条件比较苛刻。对于大多数程序设计语言来说，一般都不能满足LR(0)文法的条件。 例如：
不难看出在状态 I 2 I_2 I2​中既存在规约项目，又存在移进项目，因而这个文法不是LR(0)文法。
为了对语言句子进行确定性的分析，需要解决冲突。可以采用对含有冲突的项目集向前查看一个输入符号的办法来解决冲突，这种分析法称为简单的LR分析法，即SLR(1)分析法。
分析构造LR(0)分析表的方法，易看出是分析表出现多重定义的原因在于其中的规则2。即对于每一个项目集 I k I_k Ik​中的规约项目 A → α ⋅ A\rightarrow{\alpha·} A→α⋅，不管当前输入符号是什么，都将ACTION表中第k行的各个元素均置为 r j r_j rj​。
因此当一个LR(0)项目集闺范族中存在一个含有冲突的项目集，例如：
I k = { X → δ ⋅ b B ， A → α ⋅ ， B → r ⋅ } I_k = \{X \rightarrow{\delta·bB，A\rightarrow{\alpha·}，B\rightarrow{r·}}\} Ik​={X→δ⋅bB，A→α⋅，B→r⋅}
当遇到符号b时，必然会出现多重定义元素。
如要解决则需要向前查看一个输入符号以考察当前所处环境。对规约项目 A → α ⋅ A \rightarrow{\alpha·} A→α⋅和 B → r ⋅ B\rightarrow{r·} B→r⋅,只需要考察当讲句柄 α \alpha α或r规约为A或B时，直接跟在A或B后面的终结符集合即FOLLOW(A)和FOLLOW(B)互不相交且不包含移进符号b，即满足：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37c53e53a50836ad6e79d5b5443c2fa1/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/477/">«</a>
	<span class="pagination__item pagination__item--current">478/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/479/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>