<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/caa094b0b3c45d6251c763bcc1f570e8/" rel="bookmark">
			微信登录OpenId和UnionId区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 做微信登录时会用到OpenId和UnionId。
OpenId：是用户和应用共同生成的唯一id
UnionId: 是用户和应用所有者共同生成的唯一id
举例：如公司C的微信账号同时有A, B两款应用，在做微信登录时。
用户通过A获取的OpenId和B获取的OpenId是不同且唯一的。如果希望A应用的注册用户通过微信免注册登录B, 则要使用UnionId。对于公司C账号下的应用，同一个微信用户获取的UnionId是唯一且一致的。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d51163a1eb8ed6c608d6ff60bfa7a42/" rel="bookmark">
			Linux搭建mysql服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		该文章由作者精心整理与总结，详细记录了对问题的思考与解决过程，原创文章，转载请在文章明显位置注明出处与原文链接！大家一起成长！！！
一、环境准备 （1）下载Linux版本的mysql服务器，这里根据自己的需求下载相应的版本，作者这里下载的是
mysql-8.0.25-1.el7.x86_64.rpm-bundle.tar (2)查是否有旧版本的mysql包，有的centos镜像会默认携带，检查方式如下:rpm -qa | grep mariadb
[root@xhqHost xhqMysql]# rpm -qa|grep mariadb mariadb-libs-5.5.56-2.el7.x86_64 (3)有的话要删除，没有的话就可以跳过下面的步骤（本实例中有），再检查是否删除成功。
[root@xhqHost xhqMysql]# rpm -e mariadb-libs-5.5.56-2.el7.x86_64 --nodeps [root@xhqHost xhqMysql]# rpm -qa|grep mariadb (4)操作需要的软件及工具：
SecureCRT或者WinSCP(此处使用这两个工具)，Xshell或者PuTTy,Xftp或者FileZilla,mysql-8.0.25-1.el7.x86_64.rpm-bundle.tar，mysql的linux版软件apache-tomcat-8.0.58.tar.gz
二、在Linux下安装mysql 1、创建目录 在linux系统的用户目录下创建安装mysql的目录，命令如下：
cd usr/local
mkdir -m 777 xhqMysql
注意：如果创建的文件夹没有读写权限，则需要授权：
a.创建的时候授权：mkdir -m 777 myTomcat
b.对已经创建好的文件夹授权：chmod -R 777 myTomcat
2、拷贝安装包 使用WinSCP软件将下载好的mysql安装包拷贝到刚创建好的目录下面
3、解压安装包 解压：tar -xvf mysql-8.0.25-1.el7.x86_64.rpm-bundle.tar
1、安装common rpm -ivh mysql-community-common-8.0.25-1.el7.x86_64.rpm --nodeps --force
2、安装libs rpm -ivh mysql-community-libs-8.0.25-1.el7.x86_64.rpm --nodeps --force
3、安装client rpm -ivh mysql-community-client-8.0.25-1.el7.x86_64.rpm --nodeps --force
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d51163a1eb8ed6c608d6ff60bfa7a42/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bcec359532f8cc8cad93f3a0b5c38ab0/" rel="bookmark">
			C&#43;&#43;多线程：std::call_once
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在多线程的环境下，有些时候我们不需要某个函数被调用多次或者某些变量被初始化多次，它们仅仅只需要被调用一次或者初始化一次即可。很多时候我们为了初始化某些数据会写出如下代码，这些代码在单线程中是没有任何问题的，但是在多线程中就会出现不可预知的问题。
bool initialized = false; void foo() { if (!initialized) { do_initialize (); //1 initialized = true; } } 为了解决上述多线程中出现的资源竞争导致的数据不一致问题，我们大多数的处理方法就是使用互斥锁来处理。只要上面①处进行保护，这样共享数据对于并发访问就是安全的。如下：
bool initialized = false; std::mutex resource_mutex; void foo() { std::unique_lock&lt;std::mutex&gt; lk(resource_mutex); // 所有线程在此序列化 if(!initialized) { do_initialize (); // 只有初始化过程需要保护 } initialized = true; lk.unlock(); // do other; } 但是，为了确保数据源已经初始化，每个线程都必须等待互斥量。为此，还有人想到使用“双重检查锁模式”的办法来提高效率，如下：
bool initialized = false; std::mutex resource_mutex; void foo() { if(!initialized) { // 1 std::unique_lock&lt;std::mutex&gt; lk(resource_mutex); // 2 所有线程在此序列化 if(!initialized) { do_initialize (); // 3 只有初始化过程需要保护 } initialized = true; } // do other; // 4 } 第一次读取变量initialized时不需要获取锁①，并且只有在initialized为false时才需要获取锁。然后，当获取锁之后，会再检查一次initialized变量② (这就是双重检查的部分)，避免另一线程在第一次检查后再做初始化，并且让当前线程获取锁。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bcec359532f8cc8cad93f3a0b5c38ab0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64714e1b8e0c01bdeec14c64e0dc8933/" rel="bookmark">
			十、【服务器】服务器软件及协议 名称中英文汇总1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 涉及到的软件和协议其实非常多，后续遇到重要的再添加更新。
Level 1Level 2Level 3服务器软件及协议
(名称汇总·中英文)基本输入输出系统 BIOS(Basic Input Output System)基板管理控制器 BMC（Baseboard Manager Controller）通讯协议SNMP(v1 v2 v3)SMTPLDAPSSHSSLDNSRedfishIB (InfiniBand)互补金属氧化物半导体CMOS
(Complementary Metal Oxide Semiconductor)固件 Firmware 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc45b097c94256ff1c755bc992980f1c/" rel="bookmark">
			php一句话木马
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		测试靶场 pikachu-master
pikachu漏洞平台文件上传漏洞概述
即将进行利用的文件上传漏洞界面
$SELF_PAGE = substr($_SERVER['PHP_SELF'],strrpos($_SERVER['PHP_SELF'],'/')+1); if ($SELF_PAGE = "clientcheck.php"){ $ACTIVE = array('','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','active open','','','','active','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','',''); } $PIKA_ROOT_DIR = "../../"; include_once $PIKA_ROOT_DIR . 'header.php'; include_once $PIKA_ROOT_DIR.'inc/uploadfunction.php'; $html=''; if(isset($_POST['submit'])){ $type=array('jpg','jpeg','png');//指定类型 $mime=array('image/jpg','image/jpeg','image/png'); $save_path='uploads'.date('/Y/m/d/');//根据当天日期生成一个文件夹 $upload=upload('uploadfile','512000',$type,$mime,$save_path);//调用函数 if($upload['return']){ $html.="&lt;p class='notice'&gt;文件上传成功&lt;/p&gt;&lt;p class='notice'&gt;文件保存的路径为：{$upload['save_path']}&lt;/p&gt;"; }else{ $html.="&lt;p class=notice&gt;{$upload['error']}&lt;/p&gt;"; } } 后台getimagesize.php文件的主要内容
随意上传一张普通图片，显示上传成功
&lt;?php phpinfo();?&gt; 尝试上传php文件，其中文件内容如上
（构造一句话木马的方式以及具体代码有很多很多，由个人需求而定，CSDN上搜一句话木马php有很多文章，在下在这方面的知识尚不深刻，就不在这班门弄斧了）
反馈结果如上
对a.php内容不做修改，直接将后缀名改为png，用burpsuite抓包，并将png改成php
（
修改后点击上传
可以看到仍然和前面是一样的显示结果
修改后缀名但是不抓包修改内容尝试上传
被识破了哈哈 （第一关如上所示可以绕过后端验证，第二关抓包修改请求头里Content-Type的值可以绕过验证）
怎么绕过后端的检测呢，有很多种办法
在这里只介绍GIF89a图片头文件欺骗，这里不一一赘述，好，开搞！
GIF89a&lt;?php phpinfo();?&gt; 将a.png中的内容改成如上图，即在代码前加上了GIF89a。 上传成功了，那我们应该怎么检验呢
我们在pikachu看到了使用了include函数的另外一个模块（文件包含漏洞），这就好办了
根据pikachu中多个模块的url分析，最终得出以下路径
../../unsafeupload/uploads/2022/03/30/50444362447a43ad5d8128997197.png 拼接在File Inclusion模块中就可以得到我们想要的结果， phpinfo函数可以显示出PHP 所有相关信息。是排查配置php是是否出错或漏配置模块的主要方式之一，只要访问到phpinfo()函数的web页面，即返回php的所有相关信息。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/042b7b0652a62540a9d5d555cba724e8/" rel="bookmark">
			轻松了解下etcd
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		etcd 是一个高可用强一致性的键值仓库在很多分布式系统架构中得到了广泛的应用，其最经典的使用场景就是服务发现。
作为一个受到 ZooKeeper启发而催生的项目，它除了拥有与之类似的功能外，更专注于以下四点。
简单：易于部署，易使用。基于 HTTP+JSON 的 API 让你用 curl 就可以轻松使用。
安全：可选 SSL 客户认证机制。
快速：每个实例每秒支持一千次写操作。
可信：使用一致性 Raft 算法充分实现了分布式。
etcd 的场景默认处理的数据都是系统中的控制数据。所以etcd在系统中的角色不是其他NoSQL产品的替代品，更不能作为应用的主要数据存储。etcd中应该尽量只存储系统中服务的配置信息，对于应用数据只推荐把数据量很小，但是更新和访问频次都很高的数据存储在etcd中。
服务发现（Service Discovery） 服务发现要解决的是分布式系统中最常见的问题之一，即在同一个分布式集群中的进程或服务，要如何才能找到对方并建立连接。本质上来说，服务发现就是想要了解集群中是否有进程在监听 udp 或 tcp 端口，并且通过名字就可以查找和连接。要解决服务发现的问题，需要有下面三大支柱，缺一不可。
一个强一致性、高可用的服务存储目录。基于 Raft 算法的 etcd 就是一个强一致性高可用的服务存储目录。
一种注册服务和监控服务健康状态的机制。用户可以在 etcd 中注册服务，并且对注册的服务设置 key TTL，定时保持服务的心跳以达到监控健康状态的效果。
一种查找和连接服务的机制。通过在 etcd 指定的主题（由服务名称构成的服务目录）下注册的服务也能在对应的主题下查找到。
etcd的核心组件 从 etcd 的架构图中我们可以看到，etcd 主要分为四个部分。
HTTP Server：用于处理用户发送的 API 请求以及其它 etcd 节点的同步与心跳信息请求。
Store：用于处理 etcd 支持的各类功能的事务，包括数据索引、节点状态变更、监控与反馈、事件处理与执行等等，是 etcd 对用户提供的大多数 API 功能的具体实现。
Raft：Raft 强一致性算法的具体实现，是 etcd 的核心。
WAL：Write Ahead Log（预写式日志），是 etcd 的数据存储方式。除了在内存中存有所有数据的状态以及节点的索引以外，etcd 就通过 WAL 进行持久化存储。WAL 中，所有的数据提交前都会事先记录日志。Snapshot 是为了防止数据过多而进行的状态快照；Entry 表示存储的具体日志内容。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/042b7b0652a62540a9d5d555cba724e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4aacecf51f447687546375c5e393a1b/" rel="bookmark">
			【常见的损失函数总结】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 损失函数的定义神经网络的学习为何要设定损失函数？常见的损失函数1. 0-1损失函数(zero-one loss)2. 对数损失函数3. 平方损失函数MSE(均值平方差）4. Hinge 损失函数5. 交叉熵损失函数 (Cross-entropy loss function) 损失函数的定义 损失函数，又叫目标函数，是编译一个神经网络模型必须的两个要素之一。另一个必不可少的要素是优化器。
损失函数用来评价模型的预测值和真实值不一样的程度，损失函数越好，通常模型的性能越好。不同的模型用的损失函数一般也不一样。
损失函数分为经验风险损失函数和结构风险损失函数。经验风险损失函数指预测结果和实际结果的差别，结构风险损失函数是指经验风险损失函数加上正则项。
损失Loss必须是标量，因为向量无法比较大小（向量本身需要通过范数等标量来比较）。
损失函数一般分为4种：
HingeLoss 0-1 损失函数：感知机就是用的这种损失函数；对数损失函数：逻辑回归的损失函数就是log对数损失函数；MSE平方损失函数：线性回归的损失函数就是MSE；Hinge 损失函数：SVM就是使用这个损失函数；交叉熵损失函数 ：逻辑回归的损失函数，用sigmoid作为激活函数，常用于二分类和多分类问题中。 我们先定义两个二维数组，然后用不同的损失函数计算其损失值。
import torch from torch.autograd import Variable import torch.nn as nn import torch.nn.functional as F y_pred = Variable(torch.ones(2,2)) a = torch.Tensor(2,2) a[0,0]=0 a[0,1]=1 a[1,0]=2 a[1,1]=3 y = Variable (a) y_pred 的值为：[[1,1],[1,1]]。
y 的值为：[[0,1],[2,3]]。
神经网络的学习为何要设定损失函数？ 神经网络中的“学习”是指从训练数据中自动获取最优权重参数的过程。学习的目的就是以该损失函数为基准，找出能使它的值达到最小的权重参数。
常见的损失函数 1. 0-1损失函数(zero-one loss) 0-1损失是指预测值和目标值不相等为1， 否则为0:
特点：
(1)0-1损失函数直接对应分类判断错误的个数，但是它是一个非凸函数，不太适用。
(2)感知机就是用的这种损失函数。但是相等这个条件太过严格，因此可以放宽条件，即满足
时认为相等。
2. 对数损失函数 log对数损失函数的标准形式如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4aacecf51f447687546375c5e393a1b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60674df307d41249e7cd53886453fc52/" rel="bookmark">
			【梯度消失和梯度爆炸问题详解】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.为什么使用梯度下降来优化神经网络参数？2.梯度消失、爆炸会带来哪些影响3.产生的原因4.解决办法4.1 换用Relu、LeakyRelu、Elu等激活函数1. Relu2. LeakyRelu3. Elu 4.2 预训练加微调（fine-tunning）4.3 Batch Normalization4.4 梯度剪切、正则4.5 ResNet残差结构4.6 LSTM结构 1.为什么使用梯度下降来优化神经网络参数？ 目前优化神经网络的方法都是基于反向传播的思想，即根据损失函数计算的误差通过梯度反向传播的方式，指导深度网络权值的更新优化。这样做是有一定原因的，首先，深层网络由许多非线性层堆叠而来，每一层非线性层都可以视为是一个非线性函数 (非线性来自于非线性激活函数），因此整个深度网络可以视为是一个复合的非线性多元函数。
我们最终的目的是希望这个非线性函数很好的完成输入到输出之间的映射，也就是找到让损失函数取得极小值。所以最终的问题就变成了一个寻找函数最小值的问题，在数学上，很自然的就会想到使用梯度下降来解决。
2.梯度消失、爆炸会带来哪些影响 举个例子，对于一个含有三层隐藏层的简单神经网络来说，当梯度消失发生时，接近于输出层的隐藏层由于其梯度相对正常，所以权值更新时也就相对正常，但是当越靠近输入层时，由于梯度消失现象，会导致靠近输入层的隐藏层权值更新缓慢或者更新停滞。这就导致在训练时，只等价于后面几层的浅层网络的学习。
3.产生的原因 以最简单的网络结构为例，假如有三个隐藏层，每层的神经元个数都是1，且对应的非线性函数为 y i = σ ( z i ) = σ ( w i x i + b i ) y_i = \sigma(z_i)=\sigma(w_i x_i + b_i) yi​=σ(zi​)=σ(wi​xi​+bi​)（其中 σ \sigma σ为某个激活函数）如下图：
现在假设我们需要更新参数 b 1 b_1 b1​ ，那么我们就要求出损失函数对参数 b 1 b_1 b1​ 的导数，根据链式法则，可以写成下面这样：
而对于激活函数，假设使用Sigmoid函数，然而，sigmoid方程的导数曲线为：
可以看到，sigmoid导数的最大值为0.25，而我们初始化的网络权值通常都小于1，因此，当层数增多时，小于0的值不断相乘，最后就导致梯度消失的情况出现。同理，梯度爆炸的问题也就很明显了，就是当权值过大时 ∣ w ∣ |w| ∣w∣，导致 ∣ σ ′ ( z ) w ∣ &gt; 1 |\sigma'(z)w| &gt; 1 ∣σ′(z)w∣&gt;1，最后大于1的值不断相乘，就会产生梯度爆炸。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60674df307d41249e7cd53886453fc52/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3f4aeabb07336a37500a2a09f51970e/" rel="bookmark">
			python第三方库下载的方法（1）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		直接到国内源的网页里面去下载
比如豆瓣源：Simple Indexhttps://pypi.douban.com/simple/
浏览器直接输入网址就可以进来
进来可以发现
然后再网址后面加上我们想下载的包名：
例如：
https://pypi.douban.com/simple/opencv-python 选择想要的包，
还要注意版本的匹配，cp27代表适合python27,cp33代表适合python33,
然后还要看操作系统win32代表32位的windows，win64代表64位的windows，还要linux,mac
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/882ab4c3f0ecc3eaec2b17f0bf4f84dd/" rel="bookmark">
			Matlab快速导入数据文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.手动输入
在工作空间创建一个mat格式文件，双击手动打开，将数据一一输入进去。
2.导入已有的mat文件
data_mat = load('mat文件路径');
3.导入已有的txt文件
data_txt = importdata('txt文件路径');
4.导入已有的excel文件
data_xls = xlsread('excel文件路径',1,'A2:B4'); #参数1指的是文件的第一页，A2:B4是区域参数，指
的是a2—b4这片区域#
data_xls = xlsread('excel文件路径',1); #删去区域参数后导入的就是整页的数据#
5.导入已有的csv文件
data_csv = csvread('csv文件路径',1,0); #参数1,0表示从第一行第零列之后的数据导入#
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8bd45f9cc16c4cf3fb01391c418d47e7/" rel="bookmark">
			BFS广搜解决迷宫问题java实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.例题
题目描述
输入
输出
测试数据 2. 思路分析
基本思想
具体步骤
代码实现
3.BFS小结
求解思路：
注意
1.例题 题目描述 迷宫由 n 行 m 列的单元格组成，每个单元格要么是空地，要么是障碍物。其中1表示空地，可以走通，2表示障碍物。给定起点坐标startx,starty以及终点坐标endx，endy。现请你找到一条从起点到终点的最短路径长度。
输入 第一行包含两个整数n,m（1&lt;=n,m&lt;=1000）。接下来 n 行，每行包含m个整数（值1或2），用于表示这个二维迷宫。接下来一行包含四个整数startx，starty，endx，endy，分别表示起点坐标和终点坐标。
输出 如果可以从给定的起点到终点，输出最短路径长度，否则输出NO。 测试数据 输入
5 4
1 1 2 1
1 1 1 1
1 1 2 1
1 2 1 1
1 1 1 2
输出
7
2. 思路分析 基本思想 这道题属于一道较为经典的BFS图的广度优先搜索算法例题。类似于一个分层搜索的过程，广度优先搜索需要使用一个队列以保持访问过的结点的顺序，以便按这个顺序访问这些结点的邻接结点。即从给定的起点开始向四周扩散，判断是否能够到达终点，如果不能，就继续BFS广搜，直到能够到达终点或者将所有结点遍历完一遍。在搜索前定义一个flag变量用来标记是否到达终点。
具体步骤 1）访问初始结点 p 并标记结点 p 为已访问。
2）结点 p 入队列
3）当队列非空时，继续执行，否则算法结束。
4）出队列取得队头结点 first
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8bd45f9cc16c4cf3fb01391c418d47e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/919564f8872c793aff18e911f08032f6/" rel="bookmark">
			JavaAndroid（3、创建第一个Android应用）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
3、创建第一个Android应用
01、HelloWorld
02、Android Studio常用设置
03、Android模拟器
04、真机调试
3、创建第一个Android应用 目标
创建第一个应用程序
AndroidStudio工具的常用设置
学习使用Android模拟器
真机调试
01、HelloWorld 1.1 创建HelloWorld应用
step1：new Android Studio project
step2：Phone and Tablet（选择空的项目，其他的选项就是一些模板）
step3：配置项目信息
step4：finish
02、Android Studio常用设置 2.1 设置Project structure
2.2 设置字体风格和尺寸
（与idea类似，已经很熟悉了，这里不再详细解释）
03、Android模拟器 3.1 下载模拟器
step1：创建新的模拟器
step2：选择模拟器型号
step3：下载系统镜像
step4：启动模拟器（竖屏）
3.2 使用模拟器运行Hello World程序
（很easy，就不截图了）
04、真机调试 （重点）
step1：打开手机--开发者模式
step2：开发者模式中打开USB调试和USB安装
step3：手机通过USB连接我们的电脑，出现提示“是否运行USB调试？”，选择确定
step4：真机设备连接上，在Android Studio运行程序
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b80cecffe614f489d3c1cd81a5a1e73d/" rel="bookmark">
			基于 SuperMap iObjects C&#43;&#43; 10i（10.2.x）组件在 Visual Studio 2019 上的 Qt 项目开发环境配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于 SuperMap iObjects C++ 10i（10.2.x）组件在 Visual Studio 2019 上的 Qt 项目开发环境配置 目录 基于 SuperMap iObjects C++ 10i（10.2.x）组件在 Visual Studio 2019 上的 Qt 项目开发环境配置前言开发环境开发工具 一、安装 Qt 5.12.12二、安装 Visual Studio 2019三、为 Visual Studio 2019 安装 Qt 扩展开发插件四、调整 SuperMap iObjects C++ 组件包中依赖 Qt 的版本五、通过 Visual Studio 2019 新建 Qt 项目并配置开发环境六、编码七、运行结果总结 前言 由于 SuperMap iObjects C++ 组件结构在版本 10.2.0 进行了更新，导致 CSDN 以前的教程无法完成开发环境的配置工作，若是使用 SuperMap iObjects C++ 10.2.0 之前 版本的组件进行开发，建议参考《SuperMap iObjects for C++ 入门详解（VS + Qt）》教程文档。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b80cecffe614f489d3c1cd81a5a1e73d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00302df68a251b5bc68a8954f8ff543c/" rel="bookmark">
			windows10系统如何解决“管理员已阻止你运行此应用“
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装某些软件时偶尔遇到如下问题，解决方法作以记录。
Windows 10系统在安装驱动或程序时提示“管理员已阻止运行此应用”，要如何解决呢？
操作如下：（亲测第四条有效！）
1. 右击安装程序选择【以管理员身份运行】
2. 关闭防火墙和杀毒软件后，右击安装程序选择【以管理员身份运行】
3. 【Win】+【Q】调出搜索框，搜索【UAC】，选择【更改用户账户控制设置】将UAC级别设置到最低。
或者【Win】+【Q】调出搜索框，搜索并进入【安全和维护】，选择【更改安全和维护设置】，取消勾选【用户账户控制】。若有【smartscreen筛选器】，也选择不执行任何操作。
4.找到安装文件，按住【shift】键，同时在安装文件上点击鼠标右键，选择复制为路径（或复制为地址），打开C:\Windows\System32，找到cmd.exe，点击右键选择【以管理员方式运行】（注：不要使用PowerShell，否则后续操作可能会一闪而过）。在打开的界面点击鼠标右键将路径粘贴到运行界面，按回车键运行程序。
问题得到解决
小伙伴们快试试
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b626c4a881ba3a45d4c2e5c13bd9c65/" rel="bookmark">
			flink cdc 的 问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：一 Can't call rollback when autocommit=true 2022-03-21 11:44:29,859 INFO io.debezium.jdbc.JdbcConnection [] - Connection gracefully closed 2022-03-21 11:44:29,859 INFO io.debezium.connector.mysql.MySqlConnectorTask [] - Connector task finished all work and is now shutdown 2022-03-21 11:44:29,870 ERROR io.debezium.connector.mysql.SnapshotReader [] - Failed due to error: Aborting snapshot due to error when last running 'SELECT * FROM `test`.`test`': Can't call rollback when autocommit=true org.apache.kafka.connect.errors.ConnectException: Can't call rollback when autocommit=true Error code: 0; SQLSTATE: 08003. at io.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b626c4a881ba3a45d4c2e5c13bd9c65/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b192caed0c70fae098f8343e96eceecb/" rel="bookmark">
			.netFramework4.8读取json点表和数据库连接字符串, SSH
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		//依赖于 Microsoft.Extensions.Configuration; // Microsoft.Extensions.Configuration.json // Microsoft.Extensions.Configuration.ConfigurationBinder //如果较新则复制 //字符串中不能有空格 //ssh @root 192.168.85.102 using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; using Microsoft.Extensions.Configuration; namespace ConnTestDemon { internal class Program { static void Main(string[] args) { //依赖于 Microsoft.Extensions.Configuration; // Microsoft.Extensions.Configuration.json // Microsoft.Extensions.Configuration.ConfigurationBinder ConfigurationBuilder cfgBuilder = new ConfigurationBuilder(); cfgBuilder.AddJsonFile("Variable.json", optional: true, reloadOnChange: true); IConfigurationRoot configRoot = cfgBuilder.Build(); List&lt;Variable&gt; variables = new List&lt;Variable&gt;(); for (int i = 0; i &lt; 49; i++) { Variable variable = configRoot.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b192caed0c70fae098f8343e96eceecb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2865d0deec07aff1172fdc236244fc09/" rel="bookmark">
			C&#43;&#43;中的cin和getline读入的差异（DAY 20)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一：cin读入：1.例题：2.代码实现： 一：getline读：1.getline报错原因：2.getline读一行是否可以？1.加入空格试试2.换行试试3.测试getline能否读入两行：其实不用测试两行，只要我把第一行加个回车，getline就崩溃了 一：cin读入： cin读入的时候非常方便，不在乎输入的空格和行数：
1.例题： 2.代码实现： #include&lt;bits/stdc++.h&gt; using namespace std; int main() { int n; cin &gt;&gt; n; for(int k=0;k&lt;n;k++) { string s; //getline (cin ,s); cin &gt;&gt;s; int h=0; char a; for(int i=0;i&lt;s.size();i++) { int j=i; while(j&lt;s.size()&amp;&amp;s[j]==s[i])j++; if(j-i&gt;h) { h=j-i; a=s[i]; } i=j-1; } cout &lt;&lt; a &lt;&lt; " " &lt;&lt; h &lt;&lt; endl; } return 0; } cin读的时候自动过滤了空格和换行符
一：getline读： 1.getline报错原因： cin只是在缓存区中，把字符读走，会把\n剩余在缓存区中。
但是getline对\n 非常敏感，就是说getline对于换行非常敏感，导致getline刚开始读入遇到\n时候便停止了读入数据。
2.getline读一行是否可以？ 我们再来试试 一行的情况下能否读入以验证我们的猜想。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2865d0deec07aff1172fdc236244fc09/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af6692a5f62800cd88eea48fdf84d460/" rel="bookmark">
			知识点滴 - 多重验证MFA
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1，MFA介绍
Multi-Factor Authentication (MFA), 多重要素验证，又译多因子认证、多因素验证、多因素认证，是一种电脑访问控制的方法，用户要通过两种以上的认证机制之后，才能得到授权，使用电脑资源。例如，用户要输入PIN码，插入银行卡，最后再经指纹比对，通过这三种认证方式，才能获得授权。这种认证方式可以提高安全性。 多重要素验证的概念也广泛应用于计算机系统以外的各领域。
当你登录你的在线账户时--我们称之为 "认证"--你在向服务机构证明你是你所说的那个人。传统上，这是用一个用户名和一个密码来完成的。不幸的是，这并不是一个很好的方法。用户名通常很容易被发现；有时它们只是你的电子邮件地址。由于密码可能很难记住，人们倾向于选择简单的密码，或在许多不同的网站使用相同的密码。
这就是为什么几乎所有的在线服务--银行、社交媒体、购物，或软件服务比如微软Office365--都增加了一种方法，使你的账户更加安全。你可能会听到它被称为 "两步验证 "或 "多因素验证"，即"Two-Step Verification" or "Multifactor Authentication"，但好的验证方式都是基于相同的原则运作。当你在一个新的设备或应用程序（如网络浏览器）上第一次登录账户时，你需要的不仅仅是用户名和密码。你需要第二个东西--我们称之为第二个 "因素"--来证明你是谁。比如，短信验证码、邮件验证码、语音、指纹、面部识别等等。
多因素验证是身份识别和访问控制策略的核心部分（identity and access management / IAM policy）；
认证中的一个因素是在你试图登录时确认你的身份的一种方式。例如，密码是一种因素，它是你知道的东西。最常见的三种因素是。
- 你知道的东西(knowledge)--如密码，或PIN（Personal Identification Number）。
- 你拥有的东西(possession)--如智能手机，或一个安全的USB钥匙。
- 你是谁(inherence)--如指纹或面部识别等生物特征。
简单说就是You know，you have, you are。
2，MFA举例
MFA通过要求额外的验证信息（因素）来工作。用户最常遇到的MFA因素之一是一次性密码（one-time password / OTP）。OTP是那些你经常通过电子邮件、短信或某种移动应用程序收到的4-8位数的代码。有了OTP，就会定期或在每次提交认证请求时产生一个新的代码。该代码是根据用户首次注册时分配给他们的种子值和其他一些因素生成的，这些因素可能只是一个被递增的计数器或一个时间值。
使用MFA认证的例子包含下列种类或不同种类的组合。
Knowledge 知识
- Answers to personal security questions // 个人安全问题回答
- Password // 密码
- OTPs (Can be both Knowledge and Possession - You know the OTP and you have to have something in your Possession to get it like your phone) // 一次性口令
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/af6692a5f62800cd88eea48fdf84d460/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01caca78091bb8d521dcd82c6cb23f01/" rel="bookmark">
			【2019蓝桥杯国赛B组】排列数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这道题的思路就是从 i i i个数的情况推到 i + 1 i+1 i+1个数的情况，首先设 d p [ i ] [ j ] dp[i][j] dp[i][j]： i i i个数， j j j个折点的方案数
每次插入的数值是 i + 1 i+1 i+1，必定是当前序列中最大的数，它可能使得整个序列中的折点数+0、+1或+2（下文证明）
所以我们要考虑的就是 d p [ i ] [ j ] dp[i][j] dp[i][j]对 d p [ i + 1 ] [ j ] 、 d p [ i + 1 ] [ j + 1 ] 、 d p [ i + 1 ] [ j + 2 ] dp[i+1][j]、dp[i+1][j+1]、dp[i+1][j+2] dp[i+1][j]、dp[i+1][j+1]、dp[i+1][j+2]的影响
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/01caca78091bb8d521dcd82c6cb23f01/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5cd0dd6279f40f7e811d63f147e947e/" rel="bookmark">
			Linux系统下载vscode慢解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		deb文件原下载地址：
https://az764295.vo.msecnd.net/stable/c722ca6c7eed3d7987c0d5c3df5c45f6b15e77d1/code_1.65.2-1646927742_amd64.deb
将其中的 az764295.vo.msecnd.net 改为 vscode.cdn.azure.cn 即可。
deb文件国内镜像下载地址：
https://vscode.cdn.azure.cn/stable/c722ca6c7eed3d7987c0d5c3df5c45f6b15e77d1/code_1.65.2-1646927742_amd64.deb
呜呜呜弄了一晚上终于弄好了，我真的不喜欢安装软件TuT
？为什么不让我发，外链过多这就是个安装教程而已啊orz
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12a2f10e2678eb6a89e6905d36a2ef93/" rel="bookmark">
			非常牛逼的校园网过认证免流服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们拥有非常多非常牛逼的免流服务器，保证校园网绕过认证&amp;免流永不歇菜！
下面是我们无为WiFi冰山一角的服务器监控截图，看着都爽杆
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1c184b206e5609a9608aa545812a2fa/" rel="bookmark">
			Anaconda或Miniconda在安装包的时候，遇到EnvironmentNotWritableError
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Anaconda或Miniconda在安装包的时候，遇到EnvironmentNotWritableError报错 EnvironmentNotWritableError: The current user does not have write permissions to the target environment. environment location: C:\ProgramData\Miniconda3 环境不可写错误:当前用户没有对目标环境的写权限。 解决方法有两个
临时解决：
使用管理员权限打开Anaconda Prompt，或者管理员权限启动pycharm等，再进行想要的操作。
彻底解决：
出现EnvironmentNotWritableError的原因在于，在安装时选择了“ 为所有用户安装” 。直接卸载Anaconda / Miniconda应用然后通过安装包重新安装，并选择“ 只为我这个用户 ”安装即可。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2cbc42d3ba9da40f8f8bc4635578d1d3/" rel="bookmark">
			【c&#43;&#43;复习笔记】——异常处理机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		💂 个人主页:努力学习的少年🤟 版权: 本文由【努力学习的少年】原创、在CSDN首发、需要转载请联系博主💬 如果文章对你有帮助、欢迎关注、点赞、收藏(一键三连)和订阅专栏哦 目录
一. 异常处理
1. 基本思想
2. 抛出异常
2. 捕获异常
二. 异常的抛出和匹配规则
三. 异常规范
四. 自定义异常体系
1.自定义异常体系
2. c++标准库
一. 异常的优缺点
异常的优点
异常的缺点
一. 异常处理 1. 基本思想 事实上，所谓的异常就是程序在运行过程中，由于使用环境的变化及用户的操作而产生的错误，因此异常可以被认为是错误的侠义概念。异常处理是在程序设计过程中，针对可预测的异常编制相应的预防代码，防止程序直接崩溃掉。
一个应用程序，既要保证其正确性，还应该有容错能力，如果用户正确操作时，能正常运行，并且在应用环境出现意外或用户操作不当，有合理的反应。c++异常的处理的目的是在异常发生时，尽可能地减少破坏，尽量少影响程序其他部分的运行，如果是用c的assert方法，那么就会整个程序都会崩溃，抛异常是一种调试的一种机制。
2. 抛出异常 当一段程序中发现错误数据，但是该程序不知道如何处理时，可以抛出异常。在c++中，使用throw来抛出异常。抛出异常的语法如下：
throw 错误信息; 错误信息可以是任意类型，如int类型，string类型等。
当用户使用throw语句抛出异常的时，可以避免程序出现运行错误。但是如果只有异常抛出，程序就会中途退出，这是具体程序设计不被允许的，为此c++引入了异常的捕获和处理机制。
2. 捕获异常 如果一个函数抛出一个异常，他必须假定该异常能被捕获和处理，在c++中，提供了语句try....catch语句来捕获异常，其中try和catch分别用于定义异常和i的定义异常处理。
定义异常时将可能产生错误的语句放在try语句块中.定义异常处理是将异常处理的语句放在语句块中，以便异常被传递来时处理. try后面至少有一个catch语句块，一旦某个异常被抛出，异常处理机制将会按照书写的catch语句块的代码从上到下找到匹配的语句，一旦找到一个相匹配语句，则像调用函数一样进入该处理器中进行处理。
二. 异常的抛出和匹配规则 异常是通过抛出异常对象而引发的，该对象的类型决定了应该激活哪个catch的处理代码，如下，如果抛出的对象是string，那么就会找到catch中的异常类型声明为string的语句块，如果抛出的对象是int类型，那么就会找到catch中异常类型声明为int语句块。 抛出异常后，抛出异常语句会直接跳转到处理异常的语句 ，抛出异常后面的语句不会被执行，func2函数不会被调用。处理异常后，执行catch之后的语句。 测试结果：
抛出异常对象后，会生成一个异常对象的拷贝，因为抛出的异常对象可能是一个临时对象，所以生成的一个拷贝对象，这个拷贝对象catch执行语句块后就会被销毁.（类似函数的道理） catch(...）可以捕获任意类型的异常。 异常调用链中异常展开栈匹配规则
抛出的异常如果在当前的函数战阵中没有找到相匹配的catch语句，那么就会依次根据函数调用的路线进行返回上一层函数栈，继续查找catch语句。如果上一层找到匹配的catch语句，那么就处理该异常，那么上上一层的函数就认为没有异常，如果找不到相匹配catch语句，那么会继续返回到上一层函数栈，直到main函数栈，依旧没有匹配，那么则终止程序。所以实际中我们最后都要加一个catch(...)捕获任意类型的异常，否则当有异常没捕获，程序就会直接终止。
情景一：
func2抛出一个异常，在自己的函数栈帧中没有找到相匹配的catch语句，则返回到func1函数，在func1函数栈帧中找到了相匹配的catch语句，并处理好了异常，然后func2执行完后，返回到main函数，main函数认为没有异常，便没有捕获异常，便往后执行cout&lt;&lt;“ main end"&lt;&lt;endl;语句。 情景2：
func2抛出一个异常，在自己的函数栈帧中没有找到相匹配的catch语句，则返回func1函数，在func1函数栈帧也没有找到了相匹配的catch语句，便直接返回到main函数中，在main函数中找到了，相对应的catch语句，处理好异常后，继续执行main函数中的语句，直到程序结束。 情景3
func2抛出一个异常，在自己的函数栈帧中没有找到相匹配的catch语句，则返回到func1函数，在func1函数栈帧也没有找到了相匹配的catch语句，便直接返回到main函数中，main函数中也没有找到相匹配的catch语句，程序直接终止掉。 因此为了，如果防止某个函数直接被返回，可以在catch语句链中的最后加上catch(...）语句。
三. 异常规范 1.异常规格说明的目的是为了让函数使用者知道该函数可能抛出的异常有哪些。 可以在函数的后面接throw(类型)，列出这个函数可能抛掷的所有异常类型。2.函数的后面接throw()，表示函数不抛异常。3.若无异常接口声明，则此函数可以抛掷任何类型的异常。 void func1()throw()//表示该函数不会抛出异常
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2cbc42d3ba9da40f8f8bc4635578d1d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3974ce3e354e1bd873cd9c35a4f1b24/" rel="bookmark">
			Tensorflow2——模型保存与加载以及训练数据保存和断点续训
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		你能收获什么？ 通过阅读这篇博客，你可以了解如何在Tensorflow训练过程中保存准确率和loss,以及如何在tensorflow中保存与加载模型，如何再重新接着上一轮的训练过程继续训练。
最近在神经网络训练的过程中，需要保存训练过程中的数据，并且再下次训练的时候能够接着上次训练的结果进行断点续训。所以通过Tensorflow2官网查询到对于model.fit相关的回调函数的编写方法。下面总结了一下，在Tensorflow中，对于参数保存以及断点续训的内容，在最后会给出一个示例代码，供大家参考。
1. 保存训练数据 如何保存训练过程的数据，包括训练轮数（Epoch）,训练集acc，训练集loss，验证集acc，验证集loss。通过Tensorflow官网可以找到一个保存训练数据的回调函数，即tf.keras.callbacks.CSVLogger。使用方法很简单，只需要指定保存路径，然后将方法加入到model.fit的callbacks参数列表中。示例代码如下:
#参数说明 #append: 是否在指定文件基础上追加内容， csv_logger = CSVLogger('training.log',append=False) model.fit(X_train, Y_train, callbacks=[csv_logger]) 2. 保存与加载模型 保存模型可以借助tf.keras.callbacks.ModelCheckpoint()进行保存。接口说明如下:我们在使用过程中，大致只需要使用filepath,save_best_only,save_weight_only三个参数。其中filepath指明保存文件的路径，save_best_only说明是否只保存为佳模型，save_weight_only说明是否只保存模型权重。
tf.keras.callbacks.ModelCheckpoint( filepath, monitor='val_loss', verbose=0, save_best_only=False, save_weights_only=False, mode='auto', save_freq='epoch', options=None, initial_value_threshold=None, **kwargs ) 我们保存了模型，就需要加载模型，加载模型就通过model.load_weights(filepath)进行模型的加载操作。
这里给出一个示例代码，供大家参考，具体需求可以根据代码修改。
model = TestModel() model.compile(....) # 读取保存的模型权重 checkpoint_save_path = './checkpoint/Baseline.ckpt' checkpoint_save_best_path = './checkpoint_best/Baseline.ckpt' if os.path.exists(checkpoint_save_path + '.index'): print('------load the model------') model.load_weights(checkpoint_save_path) # 这里只保存权重（这样在下一次训练开始的时候，就能够接着上一次的训练继续训练） cp_callback_save = tf.keras.callbacks.ModelCheckpoint(filepath=checkpoint_save_path, save_weights_only=True) # 这里只保存最优模型（这样在训练结束后，能够保存训练过程中的最优模型） cp_callback_save_best = tf.keras.callbacks.ModelCheckpoint(filepath=checkpoint_save_best_path,save_weights_only=True,save_best_only=True) model.fit(.....,callbacks=[cp_callback_save,cp_callback_save_best]) 3. 示例代码 前面介绍了参数和模型的保存，回到刚刚的问题，我们需要在上一次训练后继续之前的训练过程，并且保存数据参数。首先，如果要接着上一轮继续训练，那么就需要知道上一轮训练了多少轮，我们可以通过我们的参数数据文件，很容易得出我们训练了多少论，接着我们可以借助model.fit的initial_epoch指定起始轮数，这样就可以使得训练接着上一轮继续训练。参考代码如下：
# 返回训练轮数,filename:训练数据保存文件路径 def get_init_epoch(filename): with open(filename) as f: f_csv = csv.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3974ce3e354e1bd873cd9c35a4f1b24/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4ddd3619966b94b02518a406d476b9b/" rel="bookmark">
			MATLAB中的resample函数根本理解，我专栏中有Guitar.MAT资源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		源程序如下：（这是一个音乐程序矩阵：Guitar.MAT，）
clear all; close all;
load('Guitar.MAT'); %下载Guitar.MAT矩阵到matlab中，显示两个矩阵如下所示
wavetemp = zeros(length(realwave),1); %行、列数据，行是length的数值的行数，列是1列
waveresampled = resample(realwave,10,1); %显然，就行数提高了10倍。
打开两个wavetemp矩阵，和waveresampled矩阵，发现wavetemp中的相邻数据的间隔，在waveresampled中的间隔是10个，验证了将频率扩展了10倍。
% resample为信号降采样处理，理解如下：
% B = resample(x,90,250); %采样从250Hz降到90Hz，如果250在前，就是插值从90到250，可以
% 看B的长度，250Hz采样4000个数据等于90Hz采样1440个数据，这就是降采样。
% 4000/250=1440/90=16；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d9226c9f051d36b6f1c2b24af7961c7/" rel="bookmark">
			【Java SE】类和对象：类和类的实例化；类的成员；private封装；getter和setter方法；构造方法；this关键字；代码块；toString方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		类和对象 文章目录 类和对象1. 类和对象的初步认知2. 类和类的实例化3. 类的成员3.1 字段、属性、成员变量3.2 成员方法3.3 static关键字3.4 小结 4. 封装4.1 private实现封装4.2 getter和setter方法 5. 构造方法5.1 基本语法5.2 this关键字 6. 认识代码块6.1 什么是代码块6.2 普通代码块6.3 构造代码块6.4 静态代码块 7. toString方法和匿名对象7.1 toString方法7.2 匿名对象 1. 类和对象的初步认知 C语言是面向过程的，关注的是过程，分析出求解问题的步骤，通过函数调用逐步解决问题。
JAVA是基于面向对象的，关注的是对象，将一件事情拆分成不同的对象，靠对象之间的交互完成。
面向过程注重的是过程，在整个过程中所涉及的行为，就是功能。
面向对象注重的是对象，也就是参与过程所涉及到的主体。是通过逻辑将一个个功能实现连接起来
【面向对象概念】
1.面向对象是思考问题的一种思考方式，是一种思想。比如：概念与实例。理论与实践。名和实等等。
2.类就是一类对象的统称。对象就是这一类具体化的一个实例。
3.面向对象的好处：将复杂的事情变简单了，只要面对一个对象就行
【面向对象设计】
面向对象设计把握一个重要的经验：谁拥有数据，谁对外提供操作这些数据（私有）的方法！（被动的一方是数据的拥有者，主动的一方是执行者）
开发时：找对象，建对象，用对象，并维护对象之间的关系
面向对象就是用代码(类)来描述客观世界的事物的一种方式. 一个类主要包含一个事物的属性和行为
2. 类和类的实例化 类就是一类对象的统称，对象就是这一类具体化的一个实例
一个类，可以产生无数个对象
声明一个类就是创建一个新的数据类型，而类在 Java 中属于引用类型， Java 使用关键字 class 来声明类。
基本语法
//创建类 class &lt;Class_Name&gt;{ filed;//成员属性 method;//成员方法 } //实例化对象 &lt;Class_Name&gt; &lt;对象名&gt; = new &lt;class_name&gt;(); class是定义类的关键字，ClassName是类的名字，{ }中为类的主体
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d9226c9f051d36b6f1c2b24af7961c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b69251ef18ffd809c246a0d251162f41/" rel="bookmark">
			ECC 椭圆曲线密码python实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考：
群环域 http://sparkandshine.net/algebraic-structure-primer-group-ring-field-vector-space/
https://www.toutiao.com/i6471453269016183310/
https://juejin.im/post/5a60123d518825733b0eec78
https://bbs.pediy.com/thread-253672.htm
有限域 https://blog.csdn.net/mrpre/article/details/72850598
python map &amp; lambda
def square(x) : # 计算平方数 return x ** 2 map(square, [1,2,3,4,5]) # 计算列表各个元素的平方 #[1, 4, 9, 16, 25] map(lambda x: x ** 2, [1, 2, 3, 4, 5]) # 使用 lambda 匿名函数 #[1, 4, 9, 16, 25] ECC python实现
#ECC-------------------------------------------------- A = 0 #B的作用使用来找椭圆曲线上的点 B = 7 MOD = 79 #Fmod域上的加法,a为椭圆曲线y^2=x^3+ax+b参数 def getR(p, q,mod=MOD, a=A): p = list(map(lambda x: x % mod, p)) q = list(map(lambda x: x % mod, q)) ''' if p[0] == q[0] and (p[1]+q[1])%mod==0: return [np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b69251ef18ffd809c246a0d251162f41/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b6a9d82bd5f8467a5a83b65245bb36e/" rel="bookmark">
			原创分析| 入门或者转行音视频，应该要怎么做？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要不要从事音视频开发 这一两年因为该死的疫情，让短视频、超高清视频和实时音视频反而成为需求风口。
我的看法当然是觉得音视频这个行业还可以，而且从我自己的观察来看，做音视频的现在普遍年龄都在 30+ 了，我 94 年的在组里有可能还是年龄最小的那一批人了。
有很多想从事这方面的开发者经常会有一个误区，把音视频开发认为是安卓的一个分支，我是非常不认同这个观念的。
我的观点是 音视频开发也可以是一个独立的分支，不一定要和 Android 、iOS 联系上的。和信息安全行业一样，也分移动安全、Web 安全、云安全等，不同的安全领域有可能差异很大，但还是都属于信息安全范畴，音视频同样如此。
做客户端上的音视频、服务端上的、嵌入式的、系统底层的都是音视频的范围，另外从事音视频编解码算法、网络通信协议、视频超分、音频降噪等等，也是音视频的领域范围内，所以说音视频也可以是一个很大的范围体系，每个人处在其中的位置不同而已。
如果你很熟练 FFmpeg ，熟悉播放器，或者很懂 OpenGL 渲染，那么不懂 JVM ，不懂 Android Framework 一点也不妨碍你找高薪工作。
音视频行业优势 电信行业的变革： 从1G语音、2G短信、3G图片语音、4G视频到5G未来可期的新时代，见证了音视频行业的磅礴发展。
​
技术更新慢且门槛高 技术更新慢，技术门槛高，大部分技术沿用至今，依然保持生命力，技术人员成型时间较长。以音视频常见的协议标准和开源项目为例：
协议标准 部分音视频相关的技术标准发布时间年鉴（供参考）
1. 1980年 UDP用户数据报文协议（User Datagram Protocol）
2. 1981年 TCP传输控制协议（Transmission Control Protocol）
3. 1996年 RTP实时传输协议（Real-time Transport Protocol）
4. 1996年 RTCP控制协议（RTP Control Protocol）
5. 2003年 H264视频编解码
6. 2006年 NACK负向反馈（Negative Acknowledgement），接收方只有在没有收到数据的时候才通知发送方 rfc4585
7. 2008年 FLV流媒体格式 （Flash Video）
8. 2009年 HLS基于HTTP的自适应码率流媒体传输协议(HTTP Live Streaming)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b6a9d82bd5f8467a5a83b65245bb36e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76471a47047eb64bb25ada4cb52b5c64/" rel="bookmark">
			Feign远程调用服务时返回Null的情况
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Feign远程调用服务时返回Null的情况 用object接收也是空的情况下，可以考虑请求头的Content-Type是否正确和请求体是否加了相应的注解，如@requestbody@requestparam@requestHeaders@requestpart
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae16360d4eb051863734e42018f3ccd3/" rel="bookmark">
			bpftrace参考指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言一、名词解释二、使用示范1. help2. Hello World3. One-Liners程序4. 列出可跟踪点5. 调试输出-d6. 输出详情7. 预处理选项8. 环境变量9. 其它选项 三、语法1. 程序结构{...}2. 过滤/.../3. 注释//, /**/4. 常量5. c结构体访问：-&gt;6. 结构体定义: struct7. 三元操作符 ?::8. 条件语句 if () {..} else {..}9. 循环语句unroll10. 自增、自减++、--11. 数组访问[]12. 整形强转13. while循环14. 提前结束:return15. 元组（ ，） 四、探针类型1. kprobe/kretprobe2. uprobe/uretprobe3. tracepoint4. usdt5. profile6. interval7. software8. hardware 五、变量1. 内置变量2. 基本变量: @、$3. 关联数组@[ ]5. 时间戳nsecs6. 内核栈kstack7. 用户栈追踪ustack8. 位置参数 六、函数1. 内置函数2. printf():格式化打印3. time():打印时间4. join():打印字符串数组5. str():打印字符串6. ksym()7. usym()8. kaddr()9. uaddr()10. reg()11. buf(void *d, int len)12.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae16360d4eb051863734e42018f3ccd3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b248af691a36286246680d269b4ce54/" rel="bookmark">
			ping内网流程以及ARP，ICMP,IP报文格式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ping内网流程 正常ping流程 A-&gt;B arp广播报文格式： 以太网目的MAC
以太网源MAC
帧类型
硬件类型
4
6
OP
发送端以太网MAC
发送端IP地址
目的MAC
目的IP
FF-FF-FF-FF-FF-FF
00-50-56-C0-00-01
0806
0800
1
00-50-56-C0-00-01
1.1.1.1
00-00-00-00-00-00
1.1.1.3
其中OP 1 :表示ARP请求
2:表示ARP应答
3:表示RARP请求
4:表示RARP应答
B-&gt;A 回复arp报文格式 以太网目的MAC
以太网源MAC
帧类型
硬件类型
4
6
OP
发送端以太网MAC
发送端IP地址
目的MAC
目的IP
00-50-56-C0-00-01
00-50-56-C0-00-03
0806
0800
2
00-50-56-C0-00-03
1.1.1.3
00-50-56-C0-00-01
1.1.1.1
A-&gt;B ICMP协议报文格式(ICMP属于OSI七层协议的网络层，和IP一层，ICMP使用时必须增加IP报头) 目的地址
源地址
…
源IP
目的IP
…
ICMP报文
00-50-56-C0-00-03
00-50-56-C0-00-01
1.1.1.1
1.1.1.3
Echo request
B-&gt;A ICPM协议报文格式 目的地址
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b248af691a36286246680d269b4ce54/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba50c1ce70d87cd389b8bdb5ce887657/" rel="bookmark">
			Docker 运行ElasticSearch7.17.1笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、环境相关 1、docker安装相关 查询仓库内容
yum repolist all # 显示所有资源库 yum repolist enabled # 显示所有已启动的资源库 yum repolist disabled # 显示所有被禁用的资源库
2、设置镜像 #正确推荐使用国内的 yum-config-manager --add-repo http://mirrors.aliyun.com/docker•ce/linux/centos/docker-ce.repo #更新yum软件包索引安装 yum makecache fast1 #安装 Docker yum install docker-ce docker-ce-cli containerd. 3、启动docker，运行，测试，查看镜像 ​ [root@lysw /]# systemctl start docker [root@lysw /]# docker run hello-world ​ Hello from Docker! This message shows that your installation appears to be working correctly. .... ​ [root@lysw /]# docker images REPOSITORY TAG IMAGE ID CREATED SIZE tomcat latest 7a287e4562ea 2 weeks ago 680MB nginx latest c919045c4c2b 2 weeks ago 142MB elasticsearch 8.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba50c1ce70d87cd389b8bdb5ce887657/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/593681716b384f313a17ae8892b063dd/" rel="bookmark">
			NET::ERR_INCOMPLETE_CHUNKED_ENCODING 200 (OK)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		NET::ERR_INCOMPLETE_CHUNKED_ENCODING 200 (OK)
错误背景:
微服务不通过统一的nginx端口访问，能够正常请求接口并获取对应的响应。
但是通过nginx的话，则出现请求通(也就是响应200)，但始终没有得到正确的响应，提示上述错误 NET::ERR_INCOMPLETE_CHUNKED_ENCODING 200 (OK)。
解决办法:
在nginx中的对应的反向代理配置如下内容，即可解决:
proxy_buffer_size 1024k;
proxy_buffers 16 1024k;
proxy_busy_buffers_size 2048k;
proxy_temp_file_write_size 2048k;
我的反向代理完整配置:
复制代码
location /forecast {
proxy_pass http://127.0.0.1:9999/; proxy_buffer_size 1024k; proxy_buffers 16 1024k; proxy_busy_buffers_size 2048k; proxy_temp_file_write_size 2048k; }
复制代码
错误原因分析:
1.nginx配置缓存区设置过小
2.nginx的临时目录（/proxy_temp）过大或没有权限写入缓存文件
3.磁盘空间不足
经过验证是第一种原因(nginx配置缓冲区设置过小)
问:nginx的缓冲区作用是什么？
答:如果客户端到nginx速度快，nginx到服务器速度慢，没有缓冲区，一点点数据量就直接发到客户端，十分浪费性能。
有了缓冲区，积累到一定量，再传输到客户端，减少了Tcp请求。
相反，客户端到nginx速度慢，nginx到服务器速度快，没有缓冲区，
nginx到服务器的连接就会一直保持在那边，直到客户端接受完毕。
有了缓冲区，返回内容放到缓冲区后，nginx到服务器的连接就能断开了，客户端从缓冲区拉取即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/631475f7ba019276bfa848a1858b4535/" rel="bookmark">
			什么是SR-IOV？先用起来再说
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是SR-IOV？先用起来再说！ 当然用起来之前还是得知道这东西是做什么的，以及相关的概念。
SR-IOV全称single root input/output virtualization，直译过来就是单根I/O虚拟化，怎么理解呢？首先SR-IOV最初的应用（也是我仅知的应用）是在网卡上，下图是一张SR-IOV示意图，单根的“根”即图片最底层的物理网卡，SR-IOV起到的作用是把一张物理网卡虚拟化成多个虚拟网卡给虚拟机(VM)用。
跳过产生背景、原理、优劣，我们先直接看实现。
实现SR-IOV（顺便实现一下Netronome智能网卡的OVS卸载功能） 硬件条件 一台支持SR-IOV的主机或服务器（主板），SR-IOV功能在BIOS中已开启；
我的就是台普通的DELL Optiplex7070主机，BIOS一开始都没动，好在虚拟化功能都是默认开启或者之前已经有人开启过的
一块支持SR-IOV且能安装于上述设备的网卡；
我的是Netronome CX 25Gx2的智能网卡（奢侈）
关于如何查看主机/服务器对SR-IOV的支持：
查起来太费劲，不如直接到BIOS里面看一看有没有这个选项，像Intel的就在BIOS中的Advanced-&gt;CPU Setup界面下，有Intel Virtual Technology和VT-d Feature选项，都设置为Enabled就好。AMD则是叫AMD-Vi。而且一般来讲，支持的话都会默认打开吧，至少我的是默认打开的。
网卡的产品介绍一般都会提到对SR-IOV的支持，这个查一查就好。
不满足以上硬件条件的话就别跟着做了。
系统和准备工作 我是基于Ubuntu 20.04.4，其他系统应该也没什么大碍，最好是Linux就是了。
在继续之前把系统intel_iommu打开：
先查看/proc/cmdline中是否有intel_iommu=on字样
$ cat /proc/cmdline 如果没有，修改/etc/default/grub文件，在其中的GRUB_CMDLINE_LINUX=""，改为GRUB_CMDLINE_LINUX="intel_iommmu=on"（里面已有参数的话，多个参数用空格隔开），并执行sudo update-grub使修改生效（没有该命令的话是缺少软件包，执行：sudo apt-get install grub2-common），之后重启系统，再次查看iommu是否重新开启。使用dmesg | grep -e DMAR -e IOMMU以查看启动过程中与iommu有关的信息。
此外还需要安装虚机，我使用的是KVM，后续修改SR-IOV用的图形界面。其他的应该也支持SR-IOV吧。
Netronome网卡顺便一做的事（其他网卡就不用参考这条了） 其实我的初衷只是想做好Netronome网卡卸载OVS的实验，SR-IOV才是顺便一学的事情。
为了让Netronome网卡卸载OVS，需要更换网卡固件为flower，具体操作为：
$ cd /lib/firmware/netronome $ rm -f *.nffw $ for firmware in $(ls flower); do ln -sf flower/$firmware $firmware; done 还写了一个sh脚本，切换起来方便：
#!/bin/bash # Usage: .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/631475f7ba019276bfa848a1858b4535/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f812c26051b7193fe10b90810cab9e70/" rel="bookmark">
			Js中?.与? ?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Js中?.与?? 可选链操作符?.
表达式中的所有引用不存在也不会报错，只返回undefined。
let obj=null; let name=obj.name//Uncaught TypeError: Cannot read property 'name' of null let age=obj?.age//undefined let obj={ data:{ list:{ res:'你好' } } } obj?.data?.list?.name等价于obj&amp;&amp;obj.data&amp;&amp;obj.data.list&amp;&amp;obj.data.list.name 空值合并操作符？？
当左侧为null或undefined时，返回右侧的值，否则返回左侧的值。
let a=null; let b=a??1; let c=b??a; console.log("b",b);//1 console.log("c",c);//1 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ef5a089df129c1ae610bff221172567/" rel="bookmark">
			《Qt开发》基于QWT的曲线图绘制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Qwt绘制曲线图
该示例包含以下功能:
1.使用qwt绘制曲线图
2.通过鼠标实现绘图的缩放，只缩放x轴或只缩放y轴或同时缩放
3.设置绘图区域和绘图区域外的背景颜色
4.通过点击图例实现曲线的显示和隐藏
QwtPlot绘图部件
头文件
#include &lt;qwt_plot.h&gt;
枚举类型
enum Axis {yLeft, yRight, xBottom, xTop,axisCnt}
坐标轴
enum LegendPosition { LeftLegend, RightLegend, BottomLegend, TopLegend }
图例位置
常用函数
QwtPlot (QWidget ∗=NULL)
QwtPlot *plot=newQwtPlot()
QwtPlot (const QwtText &amp;title, QWidget ∗=NULL)
QwtPlot *plot=new QwtPlot(QwtText("plot demo"));
void setAutoReplot (bool=true)
设置自动绘图
void setTitle (const QString &amp;)
plot-&gt;setTitle(“plot demo”);
void setTitle (const QwtText &amp;t)
plot-&gt;setTitle(QwtText(“plot demo”));
void setCanvasBackground (const QBrush &amp;)
plot-&gt;setCanvasBackground(Qt::white);
void setAxisAutoScale (int axisId, bool on=true)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ef5a089df129c1ae610bff221172567/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3050ee9dc2391ae40d53be11001d5147/" rel="bookmark">
			七、docker-compose--搭建一个自己的博客
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.docker-compose
2.docker-compose安装
2.1下载
2.2授予compose执行权限
2.3验证安装是否成功
3.使用docker-compose搭建一个自己的博客 3.1创建一个文件夹
3.2创建一个yml文件
3.3编排两个容器服务
3.4docker-compose up
3.5进入网页，端口为配置的8000，选择简体中文或者你熟悉的语言
3.6填写信息
3.7登录
3.8后台如下 使用环境：
Ubuntu 20.04
Docker 20.10.13
docker-compose 1.29.2
#docker-compose基于docker引擎，所以需要先安装docker。
1.docker-compose 1.1docker-compose是什么?
compose 是docker官方推出的用python编写的一个容器编排工具。
是启动容器的脚本，在脚本里指明启动容器的顺序，启动多少容器。
1.2为什么要使用docker-compose?
1.快速批量启动容器，效率高
2.不容易出错，可靠
2.docker-compose安装 2.1下载 curl -L "https://get.daocloud.io/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
2.2授予compose执行权限 chmod +x /usr/local/bin/docker-compose
2.3验证安装是否成功 docker-compose -v #查看版本，显示这说明安装成功 3.使用docker-compose搭建一个自己的博客 3.1创建一个文件夹 mkdir /my_wordpress
cd /my_wordpress
3.2创建一个yml文件 vim docker-compose.yml
3.3编排两个容器服务 version: "3.9" services: db: image: mysql:5.7.35 volumes: - db_data:/var/lib/mysql restart: always environment: MYSQL_ROOT_PASSWORD: sc123456 MYSQL_DATABASE: wordpress MYSQL_USER: wordpress MYSQL_PASSWORD: wordpress wordpress: depends_on: - db image: wordpress:latest volumes: - wordpress_data:/var/www/html ports: - "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3050ee9dc2391ae40d53be11001d5147/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d49a416366eb38f2f92cf5729d0fcead/" rel="bookmark">
			Elasticsearch在部署时，对Linux的设置有哪些优化方法？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Elasticsearch在部署时，对Linux的设置有哪些优化方法？ 一、在并发情况下，Elasticsearch如何保证读写一致？二、Elasticsearch在部署时，对Linux的设置有哪些优化方法？三、Elasticsearch和Lucene的区别 一、在并发情况下，Elasticsearch如何保证读写一致？ 1.可以通过版本号使用乐观并发控制，以确保新版本不会被旧版本覆盖，由应用层来处理具体的冲突；
2.另外对于写操作，一致性级别支持quorum/one/all，默认为quorum，即只有当大多数分片可用时才允许写操作。但即使大多数可用，也可能存在因为网络等原因导致写入副本失败，这样该副本被认为故障，分片将会在一个不同的节点上重建。
3.对于读操作，可以设置replication为sync(默认)，这使得操作在主分片和副本分片都完成后才会返回；如果设置replication为async时，也可以通过设置搜索请求参数_preference为primary来查询主分片，确保文档是最新版本。
二、Elasticsearch在部署时，对Linux的设置有哪些优化方法？ 1.64 GB 内存的机器是非常理想的， 但是32 GB 和16 GB 机器也是很常见的。少于8 GB 会适得其反。
2.如果你要在更快的 CPUs 和更多的核心之间选择，选择更多的核心更好。多个内核提供的额外并发远胜过稍微快一点点的时钟频率。
3.如果你负担得起 SSD，它将远远超出任何旋转介质。 基于 SSD 的节点，查询和索引性能都有提升。如果你负担得起，SSD 是一个好的选择。
4.即使数据中心们近在咫尺，也要避免集群跨越多个数据中心。绝对要避免集群跨越大的地理距离。
5.请确保运行你应用程序的 JVM 和服务器的 JVM 是完全一样的。 在 Elasticsearch 的几个地方，使用 Java 的本地序列化。
6.通过设置gateway.recover_after_nodes、gateway.expected_nodes、gateway.recover_after_time可以在集群重启的时候避免过多的分片交换，这可能会让数据恢复从数个小时缩短为几秒钟。
7.Elasticsearch 默认被配置为使用单播发现，以防止节点无意中加入集群。只有在同一台机器上运行的节点才会自动组成集群。最好使用单播代替组播。
8.不要随意修改垃圾回收器（CMS）和各个线程池的大小。
9.把你的内存的（少于）一半给 Lucene（但不要超过 32 GB！），通过ES_HEAP_SIZE 环境变量设置。
10.内存交换到磁盘对服务器性能来说是致命的。如果内存交换到磁盘上，一个 100 微秒的操作可能变成 10 毫秒。 再想想那么多 10 微秒的操作时延累加起来。 不难看出 swapping 对于性能是多么可怕。
11.Lucene 使用了大量的文件。同时，Elasticsearch 在节点和 HTTP 客户端之间进行通信也使用了大量的套接字。 所有这一切都需要足够的文件描述符。你应该增加你的文件描述符，设置一个很大的值，如 64,000。
三、Elasticsearch和Lucene的区别 Lucene只是一个库。想要使用它，你必须使用Java来作为开发语言并将其直接集成到你的应用中。而Elasticsearch是分布式的实时分析搜索引擎。
Elasticsearch 并不仅仅是 Lucene 那么简单，它不仅包括了全文搜索功能，还可以进行以下工作:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d49a416366eb38f2f92cf5729d0fcead/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f402de8c7ace59c10434bb2b73fbfa47/" rel="bookmark">
			springsecurity(08)oauth2协议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		oath2协议 基本介绍 开放授权（Open Authorization,OAuth）是一种资源提供商用于授权第三方应用代表资源所有者获
取有限访问权限的授权机制。由于在整个授权过程中，第三方应用都无须触及用户的密码就可以取得
部分资源的使用权限，所以OAuth是安全开放的。 目前的版本是2.0 版本;
OAuth协议：https://tools.ietf.org/html/rfc6749
比较常见的功能就是当登录一个网站的时候，可以使用qq 或微信等进行授权登录，并能够获取到qq 或微信的头像等信息。就是一种oauth的典型应用。
角色 在oauth2中主要角色有
Resource Owner：资源所有者，通常指用户;
Third­party application: 三方程序，也叫客户端 。需要请求其他系统的授权服务器的是客户端
Resource server:资源服务器 ，存储了想要获取的信息比如用户头像等
Authorization server 授权服务器,用来颁发请求令牌和校验等操作
主要的执行流程如下:
（A）客户端要求用户提供授权许可。
（B）用户同意向客户端提供授权许可。
（C）客户端携带用户提供的授权许可向授权服务器申请资源服务器的访问令牌。
（D）授权服务器验证客户端及其携带的授权许可，确认有效后发放访问令牌。
（E）客户端使用访问令牌向资源服务器申请资源。
(F）资源服务器验证访问令牌，确认无误后向客户端提供资源。
oauth2.0登录分析 以qq授权登录使用qq登录分析;
资源所有者就是登录的人，资源存放在qq的资源服务器上，只有登录了才能获取到;
点击使用qq登录,客户端（新浪网）跳转到qq的授权服务器进行登录请求;
在登录请求中会有一些关键信息
scope 要获取的那些权限信心
redirect_uri 登录成功后跳转的新浪网的连接
https://graph.qq.com/oauth2.0/show?which=Login&amp;display=pc&amp;client_id=101019034&amp;response_type=code&amp;scope=get_info%2Cget_user_info&amp;redirect_uri=https%3A%2F%2Fpassport.weibo.com%2Fothersitebind%2Fbind%3Fsite%3Dqq%26state%3DCODE-tc-1NpqQ0-2gaR6G-4T9ERcW0f1KKQGXfc8e5f%26bentry%3Dhomepage%26wl%3D1%26callback%3Dhttps%253A%252F%252Fwww.sina.com.cn%252F&amp;display=
执行登录请求
登录完成后，会询问是否同意获取相关的权限。点击同意后，跳转到重定向的url ，同时会携带一个授权码，由客户端处理回调逻辑；
客户端 通过回调拿到授权码后，在后台访问授权服务器的接口 由授权码 获取access_token
再由access_token 调用资源服务器的接口，拿到用户的相关信息;
多种授权模式 授权模式的前提是客户端需要先向服务提供者申请客户端ID(client id) 和客户端秘钥 (client secret)，在通过授权码获取access token 的时候都是需要 客户端id 和秘钥信息的。
oauth2 根据不同的应用场景大致分为4种授权模式。
授权码模式 response_type:code
最常用的一种模式,基本流程是
注意这里客户端指的是 三方应用,服务网站 是拥有授权服务器和资源服务器的网站;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f402de8c7ace59c10434bb2b73fbfa47/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e60080e68cde88a902b3d34a2b18792/" rel="bookmark">
			Spring Security(7) jwt整合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		jwt 基本介绍 jwt 全称是jsonWebToken, 简单的说就是一种能够携带信息的token。
在传统的web环境中，浏览器和后端通过记录在浏览器的cookie 和存储在服务端的session 来实现登录状态,而cookie session的方式在多分布式环境下可能带来session复制，跨域访问，单点登录等问题;
直接使用后端生成token的方式，服务端也需要存储生成的token信息，因为token是无意义的。而使用jwt ，能够携带一些必要得信息比如用户id 和用户名称等；
后端就不需要对生成的token做存储，同时jwt也有时间的有效期。能够做到请求接口无状态;
缺点:
安全性，payload是使用base64编码的，并没有加密，因此jwt中不能存储敏感数据。而session的信息是存在服务端的，相对来说更安全。无法废弃，只能等待过期失效,或增加其他的黑名单类似的逻辑处理失效。 jwt 官网： https://jwt.io/
格式 在使用过程中是一个base64编码的字符串
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c 此字符串通过逗号分割是由3部分组成
第一部分是 header 区域，只要表示当前签名的加密方式;
第二部分是 plaoyload 区域，存储了当前的token携带的信息,包含颁发给谁，有效期等
第三部分是 将前2部分通过加密生成的，主要用于服务端校验token的合法性;
使用 基本依赖 引用对应的依赖,关于jwt的工具类有很多，这里使用 https://github.com/jwtk/jjwt
引入maven依赖
&lt;!--api-&gt; &lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt-api&lt;/artifactId&gt; &lt;version&gt;0.11.2&lt;/version&gt; &lt;/dependency&gt; &lt;!---实现--&gt; &lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt-impl&lt;/artifactId&gt; &lt;version&gt;0.11.2&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; 创建token使用 //设置自定义header 信息 JwtBuilder jwtBuilder = Jwts.builder().setHeaderParam("a", "b"); Calendar instance = Calendar.getInstance(); instance.add(Calendar.MINUTE,30); Date expire = instance.getTime(); //设置playload信息 jwtBuilder = jwtBuilder.setIssuer("me") //谁颁发的 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e60080e68cde88a902b3d34a2b18792/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dcfb60bf74123650041eacb77b10c116/" rel="bookmark">
			Mybatis
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第⼀部分：⾃定义持久层框架 1.1 分析JDBC操作问题 public static void main(String[] args) { Connection connection = null; PreparedStatement preparedStatement = null; ResultSet resultSet = null; try { // 加载数据库驱动 Class.forName("com.mysql.jdbc.Driver"); // 通过驱动管理类获取数据库链接 connection = DriverManager.getConnection("jdbc:mysql://localhost:3306/mybatis? characterEncoding=utf-8", "root", "root"); // 定义sql语句？表示占位符 String sql = "select * from user where username = ?"; // 获取预处理statement preparedStatement = connection.prepareStatement(sql); // 设置参数，第⼀个参数为sql语句中参数的序号(从1开始)，第⼆个参数为设置的参数值 preparedStatement.setString(1, "tom"); // 向数据库发出sql执⾏查询，查询出结果集 resultSet = preparedStatement.executeQuery(); // 遍历查询结果集 while (resultSet.next()) { int id = resultSet.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dcfb60bf74123650041eacb77b10c116/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b33b42c7dcc5b35bbf906891a354b873/" rel="bookmark">
			现代C&#43;&#43;新特性 左值引用与右值引用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文字版PDF文档链接：现代C++新特性(文字版)-C++文档类资源-CSDN下载
左值和右值 左值和右值的概念早在C++98的时候就已经出现了，从 简单的字面理解，无非是表达式等号左边的值为左值，而表达式右边的值为右值，比如：
int x = 1; int y = 3; int z = x + y; 以上面的代码为例，x是左值，1是右值；y是左值，3是右值；z 是左值，x+y的结果是右值。用表达式等号左右的标准区分左值和右值虽然在一些场景下确实能得到正确结果，但是还是过于简单，有些情况下是无法准确区分左值和右值的，比如：
int a = 1; int b = a; 按照表达式等号左右的区分方式，在第一行代码中a是左值，1是右值；在第二行代码中b是左值，而a是右值。这里出现了矛盾，在第一行代码中我们判断a是一个左值，它却在第二行变成了右值，很明显这不是我们想要的结果，要准确地区分左值和右值还是应该理解其内在含义。
在C++中所谓的左值一般是指一个指向特定内存的具有名称的值(具名对象)，它有一个相对稳定的内存地址，并且有一段较长的生命周期。而右值则是不指向稳定内存地址的匿名值(不具名对象)，它的生命周期很短，通常是暂时性的。基于这一特征，我们可以用取地址符&amp;来判断左值和右值，能取到内存地址的值为左值，否则为右值。还是以上面的代码为例，因为&amp;a和&amp;b都是符合语法规则的，所以 a和b都是左值，而&amp;1在GCC中会给出“lvalue required as unary'&amp;' operand”错误信息以提示程序员&amp;运算符需要的是一个左值。
上面的代码在左右值的判断上比较简单，但是并非所有的情况都是如此，下面这些情况左值和右值的判断可能是违反直觉的，例如：
int x = 1; int get_val() { return x; } void set_val(int val) { x = val; } int main(int argc, char** argv) { x++; ++x; int y = get_val(); set_val(6); return 0; } 在上面的代码中，x++和++x虽然都是自增操作，但是却分为不同的左右值。其中x++是右值，因为在后置++操作中编译器首先会生成一份x值的临时复制，然后才对x递增， 后返回临时复制内容。而++x则不同，它是直接对x递增后马上返回其自身，所以++x是一个左值。如果对它们实施取地址操作，就会发现++x的取地址操作可以编译成功，而对x++取地址则会报错。但是从直觉上来说，&amp;x++看起来更像是会编译成功的一方：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b33b42c7dcc5b35bbf906891a354b873/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15b0b52fc59b9f0117cdae1ff78bfa75/" rel="bookmark">
			java 多线程入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java 多线程入门 1.多线程是什么？ 按本人的理解，多线程就是让你的代码同时(并行)执行，缩短代码的运行时间。
2.举个例子 有个业务需求，需要发送邮件和发送短信。发送邮件和发送短信的方法模拟如下：
import java.util.Random; /** * 发邮件类 */ public class EmailUtil { /** * 发邮件 * @param message 消息 * @return 如果成功返回true，失败返回false */ public static boolean sendEmail(String message){ try { Thread.sleep(4000); //模拟发邮件需要3秒 } catch (InterruptedException e) { e.printStackTrace(); } System.out.println("正在发送邮件，内容为："+message); int res = new Random().nextInt(2); //随机产生0（成功）和1（失败） if(res==0){ System.out.println("发送邮件成功"); return true; }else{ System.out.println("发送邮件失败"); return false; } } } import java.util.Random; /** * 发短信类 */ public class PhoneUtil { /** * 发短信 * @param message 消息 * @return 如果成功返回true，失败返回false */ public static boolean sendPhoneMessage(String message){ try { Thread.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/15b0b52fc59b9f0117cdae1ff78bfa75/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/217cc47f80c789f6368594aaa0058a67/" rel="bookmark">
			【论文解读】YOLOR: 2021年YOLO系列目标检测的最强王者
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​
图表数据来源：
EfficientDet: https://arxiv.org/pdf/2011.08036.pdf
YOLOv3: https://arxiv.org/pdf/2011.08036.pdf
YOLOv4: https://github.com/AlexeyAB/darknet
YOLOv4-Scaled: https://github.com/WongKinYiu/ScaledYOLOv4
YOLO-PPv2: https://arxiv.org/pdf/2104.10419.pdf
YOLOv5: https://arxiv.org/pdf/2104.10419.pdf
YOLOX: https://github.com/Megvii-BaseDetection/YOLOX
YOLOR: https://github.com/WongKinYiu/yolor
YOLOF: https://arxiv.org/pdf/2103.09460.pdf
YOLOS: https://arxiv.org/pdf/2106.00666.pdf
YOLOP: https://arxiv.org/pdf/2108.11250.pdf
图表统计时间：2021年11月-12月
本篇文章是对目标检测YOLO系列的性能总结，主要介绍了2021年YOLO系列的最高精度YOLOR是怎样炼成的。
YOLOR出自论文You Only Learn One Representation: Unified Network for Multiple Tasks，受人类学习方式（使用五官，通过常规和潜意识学习，总结丰富的经验并编码存储，进而处理已知或未知的信息）的启发，本篇论文提出了一个统一的网络来同时编码显式知识和隐式知识，在网络中执行了kernel space alignment（核空间对齐）、prediction refinement（预测细化）和 multi-task learning（多任务学习），同时对多个任务形成统一的表示。结果表明神经网络中引入隐式知识有助于所有任务的性能提升，进一步的分析发现隐式表示之所以能带来性能提升，是因为其具备了捕获不同任务的物理意义的能力。
paper: https://arxiv.org/abs/2105.04206
code: https://github.com/WongKinYiu/yolor
论文作者 | Kin-Yiu Wong等
一、YOLOR思想动机
图1：人可以根据同一幅输入图像回答不同问题，本文也旨在训练一个单一的神经网络来服务于多个任务。 如图1所示，人可以从多个角度来分析同一个目标，然而通常训练CNN时只给予了一个角度，也就是说针对某一个任务得到的CNN特征很难适用于其他问题。作者认为造成上述问题的原因主要是模型只提取了神经元特征而丢弃了隐式知识的学习运用，然而就像人脑一样隐式知识对分析各种各样的任务是非常有用的。
人类对隐式知识的学习通常通过潜意识，然而并没有系统的定义怎样学习和获得隐式知识。对于神经网络而言，一般将浅层特征定义为显式知识，深层特征定义为隐式知识。本文将直接可观察的知识定义为显式知识，隐藏在神经网络中且无法观察的知识定义为隐式知识。
图2：多目的神经网络架构。（a）不同任务对应不同模型；（b）不同任务共享骨干网络，使用不同的输出头；（c）本文提出的统一网络：融合显式知识和隐式知识的一个表征服务多个任务。 如图2所示，本文提出了一个统一的网络来集成显式知识和隐式知识，通过学习统一的表达，使得各个子表示能够适用于不同任务。基于前人工作的理论基础，本文结合压缩感知和深度学习来构建统一网络。
本文主要贡献如下：
1. 提出了一个可同时完成多种任务的统一网络，它通过融合显式知识和隐式知识学习一个可以完成多个任务的统一表征，提出的网络可以有效的提升模型的表现，仅增加千分之一不到的计算成本；
2. 通过 kernel space alignment（核空间对齐）、prediction refinement（预测细化）和 multi-task learning（多任务学习）来完成隐式知识的学习，并验证了其有效性；
3. 分别讨论了隐式知识的建模方式，包括向量、神经网络、矩阵分解，并验证了这些方式的有效性；
4. 证实了所提出的内隐表征学习方法能够准确地对应于特定的物理特征，并以视觉的方式进行了呈现；还证实了如果算子符合目标的物理意义，它可以用来整合隐式知识和显式知识，并会产生乘数效应；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/217cc47f80c789f6368594aaa0058a67/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71c6a4a7c1a1f37ef63bd7a8e88209eb/" rel="bookmark">
			STC8单片机PCA输出SPWM波形
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 SPWM调制，用STC8A和8G系列的PCA资源，设置为8位PWM模式。
/*单片机STC8带PCA系列，晶振24M，正弦波50Hz，spwm频率91KHz QQ:2401553359，QQ群：560864628，时间：2021.09.06*******/ #include "stc8.h" unsigned char code PWM[]={130,133,136,139,142,145,148,151,154,157,160, 163,166,169,172,174,177,180,183,186,188,191,194,196,199,201, 204,206,209,211,213,216,218,220,222,224,226,228,230,232,233, 235,237,238,240,241,242,244,245,246,247,248,249,250,251,251, 252,253,253,254,254,254,254,254,255,254,254,254,254,254,253, 253,252,251,251,250,249,248,247,246,245,244,242,241,240,238, 237,235,233,232,230,228,226,224,222,220,218,216,213,211,209, 206,204,201,199,196,194,191,188,186,183,180,177,174,172,169, 166,163,160,157,154,151,148,145,142,139,136,133,130,126,123, 120,117,114,111,108,105,102,99,96,93,90,87,85,82,79,76,73,71, 68,65,63,60,58,55,53,50,48,46,43,41,39,37,35,33,31,29,27,26, 24,22,21,19,18,17,15,14,13,12,11,10,9,8,8,7,6,6,5,5,5,5,5, 5,5,5,5,5,5,6,6,7,8,8,9,10,11,12,13, 14,15,17,18,19,21,22,24,26,27,29,31,33,35,37,39, 41,43,46,48,50,53,55,58,60,63,65,68,71,73,76,79, 82,85,87,90,93,96,99,102,105,108,111,114,117,120,123,126}; // 正弦表数组，64-400个都行，一般选256个 unsigned char Index;//查表索引 void PCA_Init(void)//pca计数器初始化函数 { CMOD=0x04;//计数器0的溢出为PCA计数器的时钟源 CCON=0x00; CCAPM0=0x42;//8位PWM输出，无中断 CL=0x00;//清零pca计数器 CH=0x00; CCAP0L=PWM[0]; //初始化spwm输出的占空比 CCAP0H=PWM[0]; CR=1;//运行pca计数器 } void Timer_Init(void)//计数器初始化函数 { TMOD= 0x12; //计数器0工作在方式模式2，计数器1工作在方式1 TH0 = 0xFF;//T0的计数值为5,把时钟源5分频 TL0 = 0xFF; TH1 = 0xFF;//T1的计数值为157，若是24M晶振，则中断频率为24M/157=152.886KHZ，正弦频率为152.886K/255=600HZ，即600/12=50HZ TL1 = 0x63; //T1的计数值低位12T模式 AUXR=0x80;//计数器均工作在8051速度，可换成1T模式 //ET0 = 1; //开中计数器0断 ET1 = 1; //开计数器1中断 TR0 = 1; //开启计数器0 TR1 = 1; //开计数器1 } void Timer_ISR(void) interrupt 3//计数器1中断函数 { CR=0; Index++; //查表索引 TH1=0xFF; //重装计数值 TL1=0x63; CCAP0H=PWM[Index%256];//改变pwm的占空比 CR=1; } void main() { EA=1;//开总中断 PCA_Init(); Timer_Init(); while(1); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e1c43a85ae3b6d159296ddd809df4a3/" rel="bookmark">
			不常用软件使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Markdown编辑器 1、Typora
Typora也是非常用名，非常好用的markdown编辑器，它的设计理念很不一样，是真正的即时预览型编辑器，不同于左右两个窗口的编辑器。Typora的设计理念就是极致简洁，它将「写字」和「预览」这两件事情合并了。
如果要修改已经写好的markdown标记可以点击切换到“源代码模式”。
Typora 同样支持 Windows、OS X 和 Linux多个操作系统，支持数学编辑，可与 Word 直接格式转换，可以进行多种文档格式转换。Typora 流畅度和反应速度很快，特别适合那些手速快的人。
下载：https://www.typora.io/
Cellular-Z wireshark软件 抓包工具Wireshark， 用来获取网络数据封包，包括HTTP、TCP、UDP等网络协议包。
开始界面
wireshark是捕获机器上的某一块网卡的网络包，当你的机器上有多块网卡的时候，你需要选择一个网卡。直接双击上面的某个网卡即可。
RustDesk的远程桌面软件 todesk
比较工具 Beyond Compare
WinMerge WinMerge - You will see the difference…
WinMerge是一个开源差异和合并工具。WinMerge可以比较文件夹和文件，以易于理解和处理的可视文本格式呈现差异。
Diffinity 专注于准确且易于阅读的源代码差异。它将比较两个文本文件的内容，并逐行显示所有差异以及不同的单个字符/单词。
Diffinity - Free diff tool for Windows - True Human Design Official Homepage
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c484513a34a46b557e5bb6f4abaab2dc/" rel="bookmark">
			二叉树的层序遍历Python解法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。
例：
输入：root = [3,9,20,null,null,15,7] 输出：[[3],[9,20],[15,7]] 解析：
运用队列的思想。每次大循环就是一层，每从队列中出队一个数就将他的子节点加入队列，每一层便利玩就将便利的值加入结果中。
# Definition for a binary tree node. # class TreeNode(object): # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution(object): def levelOrder(self, root): """ :type root: TreeNode :rtype: List[List[int]] """ res = [] # 结果 if root : queue = [root] # 第一层 else: return res while len(queue): # 当下一层没有子节点后停止遍历 n = len(queue) r = [] for _ in range(n): node = queue.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c484513a34a46b557e5bb6f4abaab2dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25f12826b5e4f9c626cc61c8e08ebd67/" rel="bookmark">
			在C语言中怎么表示八进制及八进制、十进制相互转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		与十进制一样，八进制是“逢八进一”，八进制现在用的比较少了解一下。
在C语言中怎么表示八进制
signed short int a1 = 07; //以0开头表示的是八进制数字，之前二进制是用0b表示
八进制就是0、1、2、3、4、5、6、7，逢八就要进1了。那么8就是10，18就是20
现在我们来看一下十进制怎么转换成八进制：
连除法：把十进制数字除8，得到商和余数，再把商继续除以8，以此类推，直接商为0。最后把余数倒序排列就是八进制数。如下图
我们再看一下把八进制转换成十进制，根据前面二进制与十进制的转换方法。就是把八进制数上的每一位数乘以对应位数的权直接相加
八进制1055转换成十进制
1*8^3 + 0*8^2 + 5*8^1 + 5*8^0
512 + 0 + 40 + 5 = 557(十进制)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f841b4966019a19dc58d0f60df742dc9/" rel="bookmark">
			mac 搭建redis主从模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、搭建环境二、操作步骤1、使用brew指令安装redis2、建立从节点配置文件3、启动主从节点 三、测试 一、搭建环境 服务器：mac
redis版本：6.2.4
二、操作步骤 1、使用brew指令安装redis brew install redis 如果没有安装brew，link请点击此处
如果安装成功，输入如下指令，可查询配置信息
brew info redis 如下图：
2、建立从节点配置文件 从上图中可以看redis的配置文件所在目录是/usr/local/etc/，所以只需要将该文件夹下的redis.conf配置文件复制一份，然后修改部分信息即可。
从节点的修改信息如下
# 源文件为 6379 port 6380 # 修改pidfile配置文件 pidfile "/var/run/redis-6380.pid" # 修改日志文件名称 默认没有 logfile "6380.log" # 修改数据文件存放目录（指的是rdb、aof等持久化文件） dir "/usr/local/var/db/6380" # 关键信息配置 # 配置主从复制（从6379主节点复制信息，注意集群的时候不需要配置这个） replicaof 127.0.0.1:6379 # 配置从节点只读 replica-read-only yes 3、启动主从节点 启动主节点：
对于主节点可以使用brew自带的启动指令：
brew services start redis
也可以用brew info给出的信息中的推荐指令：
/usr/local/opt/redis/bin/redis-server /usr/local/etc/redis.conf
个人建议用第一种，应为它是后台启动的，无需关闭窗口即可执行其它指令
启动从节点：
启动从节点只能使用第二条指令：
/usr/local/opt/redis/bin/redis-server /usr/local/etc/redis-6380.conf
完成以上三步后，一个简单的主从节点就搭建完成了～～
三、测试 开起两个终端，分别连接主从节点：
连接主节点指令
/usr/local/opt/redis/bin/redis-cli
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f841b4966019a19dc58d0f60df742dc9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/618e00826959a1c5a80cd77b6a5a841a/" rel="bookmark">
			vue打包后反编译到源代码(reverse-sourcemap)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.打开cmd,使用管理员打开
2.找到需要编译的js的目录下，这里以d://dist/static/js目录为例
执行： cd d://dist/static/js
执行完成后在该目录会看到目录下存在下面的文件名：app.xxxxxx.js.map，这里以app.5ef4326406dfb69eb193.js.map为例，如下图
图1
3.执行npm，加载reverse-sourcemap资源
执行：npm install --global reverse-sourcemap
4.反编译
执行：reverse-sourcemap --output-dir src app.5ef4326406dfb69eb193.js.map
(注：src:为导出的目录名，app.xxxxxx.js.map为 打包文件dist中的app.5ef4326406dfb69eb193.js.map文件)
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/286/">«</a>
	<span class="pagination__item pagination__item--current">287/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/288/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>