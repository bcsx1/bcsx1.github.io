<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/459d8d968c53b9874570176efbaec2eb/" rel="bookmark">
			华为机考题——HJ54 表达式求值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		描述 给定一个字符串描述的算术表达式，计算出结果值。
输入字符串长度不超过 100 ，合法的字符包括 ”+, -, *, /, (, )” ， ”0-9” 。
数据范围：运算过程中和最终结果均满足 |val| \le 2^{31}-1 \∣val∣≤231−1 ，即只进行整型运算，确保输入的表达式合法
输入描述： 输入算术表达式
输出描述： 计算出结果值
示例1 输入：
400+5 复制输出：
405 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;iostream&gt; #include &lt;string.h&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; //2323*323/23+(23234-(40-3)*3)*434-23 int computer(std::string str, int left, int right) { char option = '+'; int sum = 0; std::vector&lt;int&gt; sumVect; for(int i = left; i &lt;= right; ++i) { if(std::isdigit(str[i])) { sum = sum * 10 + (str[i] - '0'); } if(str[i] == '(') { int layer = 0; int tempi = i; while(tempi &lt;= right) { if(str[tempi] == '(') { layer++; } else if(str[tempi] == ')') { layer--; if(0 == layer) { break; } } tempi++; } sum = computer(str, i + 1, tempi - 1); i = tempi + 1; } if(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/459d8d968c53b9874570176efbaec2eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa8fc9e6f23ebb9896d01a8f551fe0f1/" rel="bookmark">
			SO库依赖问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LOCAL_PATH := $(call my-dir) include $(CLEAR_VARS) LOCAL_MODULE := libtestAdd # Android N 开始，Google收缩了 so 库的依赖权限。 # 只有 system/app system/priv-app 下的应用可以依赖。 # data/app 下的安装应用是无法加载某些 so 库的，比如：libc++.so # 添加下面两行配置表示so库可以依赖系统so库 LOCAL_NDK_STL_VARIANT := c++_static LOCAL_SDK_VERSION := current LOCAL_SRC_FILES := src/myAdd.cpp LOCAL_MODULE_PATH_64 := $(LOCAL_PATH)/lib #注意LOCAL_MODULE_PATH_64后面的_64，不加上编译64位会报错 include $(BUILD_SHARED_LIBRARY) # Android N 开始，Google收缩了 so 库的依赖权限。 只有 system/app system/priv-app 下的应用可以依赖。data/app 下的安装应用是无法加载某些 so 库的，比如：libc++.so
所以需要添加下面两行：
LOCAL_NDK_STL_VARIANT := c++_static LOCAL_SDK_VERSION := current 注意：使用第三方so库的先决条件：
1、第三方so库是否依赖其它so库
2、第三方so库运行的cup架构（如：mips64/x86/mips/x86_64/arm64-v8a/armeabi/armeabi-v7a）
3、第三方so库的头文件（.h）
示例代码：
百度链接 提取码：y4cn
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa8fc9e6f23ebb9896d01a8f551fe0f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6b067d561566a8cb87069a2f2d2f2ab/" rel="bookmark">
			FANUC机器人调试常见问题解答1-30问
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		FANUC机器人调试常见问题解答
1、焊枪防碰撞信号怎么接？
防碰撞功能需要使用EE接口，EE中一端接*XHNBK信，一端接24V，之后在系统--配置中启用手爪断裂功能
2、机器人无法手动动作？
确保无故障异常的情况下，检查示教器开关是否置on，模式开关是否牢靠拨到T1或T2，然后检查UI信号是否满足运行条件，必要时在系统--配置中关闭外部专用信号
3、如何修改机器人运动范围？
在系统--轴动作范围中可修改，但对于M-10iA和20iA系机器人应注意J6轴的外部管线安装方式，并在控制启动模式中先行修改。
4、如何在自动运行程序时直接达到100%速度？
在程序中的运动指令前插入override指令，并设为100
5、暂停后再启动？
机器人没有报警、UI信号1、2、3、8为ON、UO信号1为ON，发送脉冲UI信号第6个可启动程序继续运行
6、机器人输出为ON时没有输出24V？
检查IO信号板上DOSRC输出信号公共端24V是否正常
7、U盘插在TP上无法识别但控制柜上可以备份文件？
R-30iA控制柜部分TP线缆不支持U盘，需更换为支持U盘的TP线缆（A660-2006-T840）
8、Mate柜主板是否支持视觉功能？
Mate柜主板型号12位字母加数字组合的最后位为0的不支持视觉、1和2的主板支持视觉
9、TP按钮启动程序？
将程序设置为宏后可通过TP上按钮启动（宏启动设置为UK方式）
10、寄存器最大能扩展到多少个？
安装寄存器扩展功能后，数值寄存器的最大数扩展到5000个，位置寄存器的最大数扩展到2000个
11、机器人密码功能分为几个等级？
安装：可以分配用户名、密码、以及密码等级。可以清除用户名和密码。可以设定密码日志的有效/无效。可以设定系统中的密码用户数。可以执行设定、程序、操作者的所有操作。(安装用户只可设定1人) 设定者：可以执行设定系统设定中通常进行操作。程序师：可以执行较操作者用户更加高度的操作。操作者：可以执行基本的操作。
12、机器人原始路径恢复功能如何启用？
原始路径恢复的有效、无效的切换，使用如下系统变量进行。$SCR.$ORG_PTH_RSMTRUE:原始路径恢复有效FALSE:原始路径恢复无效
13、机器人的诊断备份有什么用？
诊断备份在刚刚发生异常后进行简单的操作，将该时刻的内部数据保存在FROM内的一种功能。有的内部数据在切断电源时会丢失。在利用本功能将内部数据保存在FROM内后，只要将镜像备份寄发给发那科公司，我们就能够进行相关调查。
14、如何启用附加轴碰撞检测功能？
更改下列系统变量$SBR[n].$PARAM[112] = 2097152 / ($SBR[n].$PARAM[47])$SBR[n].$PARAM[119] = 7282$SBR[n].$PARAM[120] = -7282n:系该附加轴的硬件方面的轴号码。若是机器人的附加轴，通常设定为7以后的值
15、如何退出HMI界面？
选择FCTN菜单--下一页--禁用HMI菜单即可
16、机器人报警状态如何输出到外围设备？
分配并使用UO6错误信号即可
17、机器人主菜单-文件菜单-“切换存储设备”没有该选项？
按MENU-SETUP-GENERAL将系统语言切换成英语即可
18、机器人的安装条件有哪些？
环境温度：0~45°，环境湿度：通常在75%RH以下（无结露现象)，短期（一个月内）在95%RH以下；允许高度：海拔1000m以下；振动加速度：4.9m/s²（0.5G)以下；不应有腐蚀性气体
19、机器人的重复定位进度是多少？
具体查看对应机型的机构部操作说明书“基本规格”章节
20、机器人的常用坐标系有哪些？
关节坐标系，直角坐标系，世界坐标系，工具坐标系，用户坐标系
21、驱动机构部的润滑脂的更换周期是多少？
须安装每3年或者运转累计时间达11520小时的较短一方为周期进行更换
22、驱动机构部的电池的更换周期？
须每年进行定期更换；需在机器人开机上电时更换
23、存储器的后备电池更换周期？
须每4年内更换一次新电池
24、如何确认存储器备件的型号，且如何确认其通用性？
需查看备件的标志A05B、A06B开头的十二位编码；十二位编码一致的部件，则可以相互通用
25、更换控制柜备件有哪些注意事项？
须确认备件的通用性；做好设备的镜像备份和普通所有文件备份，若有更换存储核心部件的，须导回镜像备份
26、机器人控制柜和本体是否可以对调互换使用？
设备预安装的软件配置及设备零点数据不一致，不建议对调更换使用
27、机器人密码等级有哪些？
安装，设定者，程序员，操作者，用户自定义
28、哪些情况需要零点标定？
1、控制柜后备电池耗尽，或初始化启动引起的零位置数据被擦除等原因导致机器人零点标定数据丢失的。2、因机构部的脉冲编码器后备用电池耗尽，编码器、马达、编码器线缆更换等原因导致零点数据丢失的。3、碰撞机构部而造成脉冲编码器和轴角度偏移的，或更换机构部传动部件的。
29、零点标定的种类？
全轴零点位置标定，简易零点标定，简易零点标定（单轴），单轴零点标定，视觉零点标定（可选购项），输入零点标定数据
30、I/O有哪些种类？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6b067d561566a8cb87069a2f2d2f2ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71f24eaf81d034f59e37fecf1265d231/" rel="bookmark">
			文件文档在线预览开源项目kkFileView的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文件文档在线预览开源项目kkFileView的使用 1.项目特性2.部署过程2.1 二进制下载部署文件进行部署2.2 docker方式部署2.3 通过源代码编绎部署 3.部分配置说明3.1 server.context-path 4.预览乱码字体问题5.预览展示6.附件7.其他说明7.1使用openoffice进行转换7.2 libXext.so.6: cannot open shared object file: No such file or directory kkFileView为文件文档在线预览解决方案，该项目使用流行的spring boot搭建，易上手和部署，基本支持主流办公文档的在线预览，如doc,docx,xls,xlsx,ppt,pptx,pdf,txt,zip,rar,图片,视频,音频等等，官网：https://kkfileview.keking.cn/zh-cn/index.html
1.项目特性 支持word excel ppt，pdf等办公文档 支持txt,java,php,py,md,js,css等所有纯文本 支持zip,rar,jar,tar,gzip等压缩包 支持jpg，jpeg，png，gif等图片预览（翻转，缩放，镜像） 支持mp3，mp4，flv等多媒体文件预览 使用spring boot开发，预览服务搭建部署非常简便 rest接口提供服务，跨平台特性(java,php,python,go,php，....)都支持，应用接入简单方便 支持普通http/https文件下载url、http/https文件下载流url、ftp下载url等多种预览源 提供zip，tar.gz发行包，提供一键启动脚本和丰富的配置项，方便部署使用 提供Docker镜像发行包，方便在容器环境部署 抽象预览服务接口，方便二次开发，非常方便添加其他类型文件预览支持 最最重要Apache协议开源，代码pull下来想干嘛就干嘛 2.部署过程 部署方式，可以直接下载二进制步骤，也可以通过docker直接拉取，还可以通过源码编绎进行，下面分别说明
前提条件：Jdk需要先安装设置好，kkFileWiew是Java开发的，Jdk必需.
tar -xvf jdk-8u191-linux-x64.tar.gz -C /usr/local cat &gt;&gt; /etc/profile &lt;&lt; EOF export JAVA_HOME=/usr/local/jdk1.8.0_191/ export PATH=\$JAVA_HOME/bin:\$PATH export CLASSPATH=.:\$JAVA_HOME/lib/dt.jar:\$JAVA_HOME/lib/tools.jar EOF source /etc/profile [root@localhost testuser]# java -version java version "1.8.0_191" Java(TM) SE Runtime Environment (build 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/71f24eaf81d034f59e37fecf1265d231/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d6d41e5c76d7ee3f917c254914eda3f/" rel="bookmark">
			FPGA中的D触发器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		四种基本触发器
基本D触发器
module DFF(D,Q,CLK); input D,CLK; output Q; always @(posedge CLK) begin Q &lt;= D; end endmodule 带异步清0、异步置1的D触发器
module DFF1(q,qn,d,clk,set,reset); input d,clk,set,reset; output reg q,qn; always @(posedge clk or negedge set or negedge reset) begin if(!reset) // 异步清0，低电平有效 begin q &lt;= 0; qn &lt;= 1; end else if(!set) //异步置1，低电平有效 begin q &lt;=1; qn &lt;= 0; end else begin q &lt;= d; qn &lt;= ~d; end end endmodule 带同步清0；同步置1的D触发器
module DFF2(q,qn,d,clk,set,reset); input d,clk,set,reset; output reg q,qn; always @(posedge clk) begin if(reset) // 异步清0，高电平有效 begin q &lt;= 0; qn &lt;= 1; end else if(set) //异步置1，高电平有效 begin q &lt;=1; qn &lt;= 0; end else begin q &lt;= d; qn &lt;= ~d; end end endmodule 带异步清0、异步置1的JK触发器
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d6d41e5c76d7ee3f917c254914eda3f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8505b5ca1d9d5fde53b8ad89e61d54b3/" rel="bookmark">
			Win10应用小技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		全屏截图 Win+W：按快捷键后选择全屏截图。还可以编辑截图。还有标尺、量角器使用。中键可以旋转标尺。
快速截屏到剪贴板 Win+Shift+S：可以框选截图到剪贴板。然后Ctrl+V粘贴到其他软件里。结合上面的全屏截图，很方便。 捕获（截图、录音、录屏） Win+G：打开捕获
Win+Alt+Print（F12键右边）：截图
保存位置：
Win+Alt+R：录屏
Win+Alt+M：录音（需要麦克风）
打开剪贴板 Win+V：可以打开剪贴板，查看里面的内容。还可以任意形状截图。
显卡截屏录屏 Alt+Z：打开下图界面
Alt+F1：截图 快速打开误关的网页 Ctrl+Shift+T：好像所以浏览器都可以。 输入文字时打开特定符号页面。 Win+。（句号键）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a5f21201aa09d2be4602508f731e0db/" rel="bookmark">
			RizomUV 2019基础与快捷键
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 视图操作 1、3D视图
Alt+左键：旋转Alt+中键：移动Alt+右键：平滑缩放 2、UV视图
移动：Alt+中键平滑缩放：Alt+右键 3、视图切换
单独显示3D /UV视图：E（吧鼠标指针放到3D /UV视图上可以选择视图，然后按E 可以单独显示3D /UV视图）切换视图：Ctrl+E（单独显示3D /UV视图后，按Ctrl+E切换视图，再按E可以切换到默认状态，同时显示3D /UV视图） 选择 点、线、面：F1~F3
选择整块UV：F4 加选：Ctrl+左键
减选：Ctrl+Shift+左键 选择工具：Q
编辑工具：F5（Tab键可以临时打开显示变换模式操纵框）
UV操作 切割UV：C
缝合UV：W 松弛、展开UV：U
优化UV：O（基于松弛、展开UV后才能用） 缩放UV：空格或者D键+左键（D键只能对整块UV操作）
移动UV：空格或者D键+中键旋转UV：空格或者D键+右键 快速摆UV：P （吧UV放到UV框里）
显示 最大化显示选择对象：F
显示全部对象：A 隐藏未选择对象：I （基于F4选择模式下有用，再次使用可以全部显示）
隐藏选择对象：H显示所有：Y 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da1a813b2a4ed380a58a0a7ca24023b0/" rel="bookmark">
			2022华为机试4.20号 第一题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、新员工考试
小聪入职新公司,参加线上的新员工必备考试,考试共25题，依次是10个判断题(每题2分)、10个单选题(每题4分)和5个多选题(每题8分)，总分100分；
考题只能顺序作答,答对题目获得相应的分数。答错题目获得0分,考试系统不提示作答是否正确，答题过程中如果累积有3题答错,直接中止考试并计算考试分数。
小聪考试结果是N分，请根据小聪的分数,算出所有可能的答题情况的个数。输入一个整数,表示小聪的考试得分N,N为偶数,0&lt;=N&lt;=100(N不会是不可能考出来的分数)。
输出一个整数表示所有可能的答题情况的个数
样例1 输入:94 输出:100 解释:有1道判断题和1道单选题答错,其余的题都答对,所有可能的答题情况的个数为100； 样例2 输入:100 输出:1 解程:所有题目全部答对,答题情况的个致为1 package 面试题.华为; import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; //1、新员工考试 //小聪入职新公司,参加线上的新员工必备考试,考试共25题，依次是10个判断题(每题2分)、10个单选题(每题4分)和5个多选题(每题8分)，总分100分； //考题只能顺序作答,答对题目获得相应的分数。答错题目获得0分,考试系统不提示作答是否正确，答题过程中如果累积有3题答错,直接中止考试并计算考试分数。 //小聪考试结果是N分，请根据小聪的分数,算出所有可能的答题情况的个数。输入一个整数,表示小聪的考试得分N,N为偶数,0&lt;=N&lt;=100(N不会是不可能考出来的分数)。 //输出一个整数表示所有可能的答题情况的个数 public class Score { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); int N = Integer.parseInt(br.readLine()); int[] grade = new int[25]; for (int i = 0; i &lt; 10; i++) { grade[i] = 2; } for (int i = 10; i &lt; 20; i++) { grade[i] = 4; } for (int i = 20; i &lt; 25; i++) { grade[i] = 8; } int result=dfs(0,N,3,grade); System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da1a813b2a4ed380a58a0a7ca24023b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b3eeab7a39ad95c36cbf1e2a74b33ec/" rel="bookmark">
			pycharm左侧项目窗口不见了——解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们在使用pycharm时，有时会出现这种情况：左侧的项目窗口 不见了
解决方法：依次点击 View——Tool Windows——Project
或者使用快捷键：Alt+1 快速显示项目窗口
大功告成，完整项目窗口清晰可见。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d1795563e62ab8bfe5cbd3fed5e148e/" rel="bookmark">
			博途的多步过程控制, 寄存器寻址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1，实际生产中，收到的开关信号往往是短信号/脉冲
2, Step 变化的逻辑和设备的逻辑分开。Step的变化逻辑在实际中往往是设备的反馈信号决定，在此处用定时器信号代替。定时器的触发用Step的状态触发，写在IF ELSIF 语句之外，用定时器（或设备反馈）的Q驱动Step的更新
3，IF ELSIF 之间是互斥事件
4， 如果只用IF ELSIF 而不用ELSE， 那么短信号的判断条件有效， 结果且带自锁
5， 如果用了IF ELSIF + ELSE，那么长信号的判断条件有效，结果且不带自锁， 短信号判断条件时效过后， 会自动跳至Else
6，如果使用IF ELSIF 语句，那么每条结果最好都写上所有OutPut的状态，例如这里的“电机正转”，“电机反转”，“指示灯闪烁”，这样逻辑更严谨
7，多个相同设备的模板程序，需要通过Input OutPut传入参数的程序需要用FB，而不是FC。因为FC中的InPut和OutPut没有分配内存，表现在程序中就是：通过FC块传入的Input变量在做If 条件时，判断的结果OutPut没有自锁功能
启动	Bool	false 停止	Bool	false Output	电机正转	Bool	false 电机反转	Bool	false 指示灯闪烁	Bool	false InOut	Static	上升沿	Array[0..5] of Bool	Step	Int	0 R_TRIG_Start	R_TRIG	TON1	TON_TIME	T1On	Bool	false TON2	TON_TIME	R_TRIG_Stop	R_TRIG	REGION #启动和停止的触发 #R_TRIG_Start(CLK := #启动, Q =&gt; #上升沿[0]); #R_TRIG_Stop(CLK := #停止, Q =&gt; #上升沿[1]); END_REGION REGION Step 顺序控制步数的更新 IF #上升沿[0] THEN #Step := 1; ; ELSIF #TON1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d1795563e62ab8bfe5cbd3fed5e148e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff16240ddfa66b17a8fb6793eac27741/" rel="bookmark">
			pytorch模型加载跑测试集和训练过程中跑测试集结果不一致的问题？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前馈网络使用with torch.no_grad()和model.eval()比较 问题描述 将训练好的模型拿来做inference，发现显存被占满，无法进行后续操作，但按理说不应该出现这种情况。
RuntimeError: CUDA out of memory. Tried to allocate 128.00 MiB (GPU 0; 7.93 GiB total capacity; 6.94 GiB already allocated; 10.56 MiB free; 7.28 GiB reserved in total by PyTorch) 解决方案 经过排查代码，发现做inference时，各模型虽然已经设置为eval()模式，但是并没有取消网络生成计算图这一操作，这就导致网络在单纯做前向传播时也生成了计算图，从而消耗了大量显存。
所以，将模型前向传播的代码放到with torch.no_grad()下，就能使pytorch不生成计算图，从而节省不少显存
with torch.no_grad()： # 代码块 outputs = model(inputs) # 代码块 经过修改，再进行inference就没有遇到显存不够的情况了。此时显存占用显著降低，只占用5600MB左右（3卡）。
model.eval()和torch.no_grad()比较： model.eval()
使用model.eval()切换到测试模式，不会更新模型的k，b参数
通知dropout层和batchnorm层在train和val中间进行切换在。train模式，dropout层会按照设定的参数p设置保留激活单元的概率（保留概率=p，比如keep_prob=0.8），batchnorm层会继续计算数据的mean和var并进行更新。在val模式下，dropout层会让所有的激活单元都通过，而batchnorm层会停止计算和更新mean和var，直接使用在训练阶段已经学出的mean和var值！
model.eval()不会影响各层的gradient计算行为，即gradient计算和存储与training模式一样，只是不进行反向传播！(backprobagation)，即只设置了model.eval()pytorch依旧会生成计算图，占用显存，只是不使用计算图来进行反向传播。
torch.no_grad()
首先从requires_grad讲起：
requires_grad
在pytorch中，tensor有一个requires_grad参数，如果设置为True，则反向传播时，该tensor就会自动求导，并且保存在计算图中。tensor的requires_grad的属性默认为False,若一个节点（叶子变量：自己创建的tensor）requires_grad被设置为True，那么所有依赖它的节点requires_grad都为True（即使其他相依赖的tensor的requires_grad = False）
当requires_grad设置为False时,反向传播时就不会自动求导了，也就不会生成计算图，而GPU也不用再保存计算图，因此大大节约了显存或者说内存。
with torch.no_grad
在该模块下，所有计算得出的tensor的requires_grad都自动设置为False。
即使一个tensor（命名为x）的requires_grad = True，在with torch.no_grad计算，由x得到的新tensor（命名为w-标量）requires_grad也为False，且grad_fn也为None,即不会对w求导。例子如下所示：
x = torch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ff16240ddfa66b17a8fb6793eac27741/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/663fba7a6029f1e03afcfbe525aac821/" rel="bookmark">
			上传叶绿体基因组序列至NCBI
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		进入NCBI官网：National Center for Biotechnology Information (nih.gov)
点击submit
点击genbank下面中间的submit (提交mRNA、基因组DNA、细胞器、ncRNA、质粒、其他病毒、噬菌体、合成结构体)
(然后界面提示要求登录NCBI账号，我选择microsoft账号登陆)
然后出现如下界面，点击如下
依次填写各项信息，参照叶绿体基因组NCBI 数据上传 - 知乎 (zhihu.com)
邮箱必须用国际邮箱，QQ邮箱和163邮箱都会显示错误
提交tbl文件可以用这个网址：MPI-MP CHLOROBOX - GB2sequin (mpg.de)
可以将gbf转化为tbl
上传文件后记得点upload！
然后finish就可以了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc89f100c478d9184963779949f59686/" rel="bookmark">
			Android UDP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 kernel 3.10内核源码分析--udp_sendmsg()--UDP发包流程Linux内核分析 - 网络[十二]：UDP模块 - 收发setsockopt设置udp缓存SO_SNDBUF，为什么getsockopt返回值为设定值的二倍 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4aea01b548538d501410e0b59113778/" rel="bookmark">
			12 - 利用LinuxPTP进行时间同步(软/硬件时间戳) - 研一
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		拖了很久，花了半天测了一下，效果还行，可以脱离隔壁的原子钟做开发测试了。
参考文献： http://linuxptp.sourceforge.net/
0、硬件支持 查看网卡是否支持软硬件时间戳：
sudo ethtool -T eno1
Time stamping parameters for eno1: Capabilities: hardware-transmit (SOF_TIMESTAMPING_TX_HARDWARE) software-transmit (SOF_TIMESTAMPING_TX_SOFTWARE) hardware-receive (SOF_TIMESTAMPING_RX_HARDWARE) software-receive (SOF_TIMESTAMPING_RX_SOFTWARE) software-system-clock (SOF_TIMESTAMPING_SOFTWARE) hardware-raw-clock (SOF_TIMESTAMPING_RAW_HARDWARE) PTP Hardware Clock: 0 Hardware Transmit Timestamp Modes: off (HWTSTAMP_TX_OFF) on (HWTSTAMP_TX_ON) Hardware Receive Filter Modes: none (HWTSTAMP_FILTER_NONE) all (HWTSTAMP_FILTER_ALL) ptpv1-l4-sync (HWTSTAMP_FILTER_PTP_V1_L4_SYNC) ptpv1-l4-delay-req (HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ) ptpv2-l4-sync (HWTSTAMP_FILTER_PTP_V2_L4_SYNC) ptpv2-l4-delay-req (HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ) ptpv2-l2-sync (HWTSTAMP_FILTER_PTP_V2_L2_SYNC) ptpv2-l2-delay-req (HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ) ptpv2-event (HWTSTAMP_FILTER_PTP_V2_EVENT) ptpv2-sync (HWTSTAMP_FILTER_PTP_V2_SYNC) ptpv2-delay-req (HWTSTAMP_FILTER_PTP_V2_DELAY_REQ) 软件时间戳需要包括参数
SOF_TIMESTAMPING_SOFTWARE
SOF_TIMESTAMPING_TX_SOFTWARE
SOF_TIMESTAMPING_RX_SOFTWARE
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f4aea01b548538d501410e0b59113778/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f5d3a1826ffc18205d00c9a091af379/" rel="bookmark">
			JSON Schema校验数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考 JSON Schema 规范（中文版）官方网站JSON Schema
对于数据对接系统来说，接口的数据入参校验尤为重要，使用javax.validation相关注解进行校验对于java对象的关联太大，数据结构变动后必须开发人员调整java对象才能满足校验。为了让数据校验和java对象解耦，研究后发现可以使用JSON Schema来实现，定义好相关的schema文件，这个文件可以放在任意可访问的地方，也不需要关心需要校验的数据是属于那个java对象。只要熟悉JSON和一些schema语法，schema文件甚至可以由非开发人员编写。
JSON Schema学习 JSON Schema是什么？ JSON Schema本身也是JSON，它表现的是数据，是描述数据结的声明性格式，并不是程序。所以，它在表现元素之间的关联关系上一定限制。
Schema声明 使用$schema来声明使用的JSON模式规范是哪个版本: draft-04
{ "$schema": "http://json-schema.org/draft-04/schema#" } 关键字 definitions 在definitions中定义的规则可以重复使用
"#"表示JSON的根节点
{ "definitions": { "address": { "type": "object", "properties": { "street_address": { "type": "string" }, "city": { "type": "string" }, "state": { "type": "string" } }, "required": ["street_address", "city", "state"] } }， "type": "object", "properties": { "billing_address": { "$ref": "#/definitions/address" }, "shipping_address": { "$ref": "#/definitions/address" } } } title 标题
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f5d3a1826ffc18205d00c9a091af379/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0baa38b99141bbcd690747a9a1616633/" rel="bookmark">
			电子装备智能制造模式—从流程驱动到数据驱动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文讨论了流程驱动和数据驱动的关系，结合数字化转型实践，提出一种数据驱动的电子装备智能制造模式，探讨数据驱动的业务模式和实施方法，并在企业进行应用验证。
1 流程驱动和数据驱动区别与联系
数据和流程在现代制造企业相辅相成，流程中有数据，数据往往通过流程传播。在辨析两种模式前，应先理解“驱动”的内涵。“驱动”是通过建立一定的驱动机制，改变以往人为的业务推进模式，使系统在相应驱动力的推动下自动或半自动运行。这里驱动力可以来自流程、数据或其他要素。可见，驱动的内涵在于通过一定机制使系统自动或半自动运转，人在这个机制下只负责执行，在相应的任务执行完成后，不需要人去思考和推动下一步做什么或怎么做。
流程驱动是以流程为主线，将相互关联的业务活动串联和协同起来，使这一组业务活动以流程设定的方式有序进行，从而完成特定的活动目标。通过流程改进、管理制度改进、组织职责优化手段等实现业务的整合和运转，通常一套流程体系可以很好的规定流程驱动管理方式的业务活动。企业推进信息化过程，往往是从梳理和重构业务流程开始，并将业务流程固化在相应信息系统中，典型的业务场景如计划管理、物料管理、质量管理、合同管理等流程在企业资源计划（ERP）系统中的实施。
数据驱动是以数据为核心，根据数据所映射的内外部环境的要求及变化，通过进行数据获取、建模、分析、执行而驱动业务活动的决策和运行，以实现数据价值创造。在数据驱动过程中，充分发挥数据的精准、预见等特点，通过对生产过程和生产操作进行定义，驱动生产系统和操作执行依据数字定义运行。同时通过消除不确定性，科学客观支撑生产管理的决策，进而推动生产系统运行。流程驱动和数据驱动的对比如表1所示。
表1 流程驱动和数据驱动的对比
在表1中，流程驱动的典型特征是以流程为核心，其驱动力是对流程的定义与考核，驱动方式是工作流引擎。基于生产系统的业务架构，对流程进行梳理和定义。工作流引擎根据业务规则预先定义，判断在流程中的下一步业务。在一定的监控和考核激励下，流程驱动的模式具有高效明确、各环节紧密协同的优势，打破了职能化管理造成的业务灰色地带和业务墙。但随着制造模式向定制化、可重构柔性制造等方向转型，流程驱动模式在部分业务场景中灵活柔性等方面的不足则被放大。
另一方面，随着物联网、CPS等技术的兴起，带来工业数据的海量增长，在流程驱动模式下，工业数据缺少充分的利用和价值创造。数据驱动模式则有效地弥补了上述不足，数据驱动以数据为核心，以数据分析与利用为驱动力，以数据、知识、规则为驱动方式，通过数据对业务进行获取、建模、分析、执行，挖掘数据中隐含的规律和知识，直接作用于制造系统或辅助决策，具备灵活柔性、数据赋能、自动响应、科学决策的优势。
以数据为核心的数据驱动模式不是不需要流程，在一些业务规则相对固化的环节，流程还是业务开展的主要方式。对于有柔性可重构要求、数据价值高的环节，则以数据驱动为主，流程驱动为辅，流程为数据的传播定义了基本的途径。数据驱动是制造模式转型的新阶段，数据驱动在流程框架的基础上，弥补流程驱动的不足，提供了一种新的运行模式来解决制造系统的问题。
2 数据驱动的智能制造模式
数据驱动的智能制造模式是将数据作为制造系统的输入，通过数据建模和制造过程定义，在数据分析和解析的支持下，以数据流为主要驱动要素，通过网络在制造系统的物理空间和信息空间传递，进行生产过程和操作的自动和半自动执行，以及生产车间的实时反馈、动态监控、过程优化，以减少或消除制造过程中的不确定性。
准确实时的数据源是数据驱动智能制造模式的基础，只有用于建模和定义的数据是准确、实时的，才能保证数据驱动得以贯彻，否则将有可能带来错误生产或车间的混乱。为保证数据的准确性和及时性，更多地需要自动采集、数据融合等方法来获取数据，减少手工输入的数据或者多手工输入的数据进行校验审核。数据建模及定义是对生产过程抽象的描述，是数据驱动模式的动力源，也是数据驱动中难度最大的部分，进行数据建模及定义需要对生产过程全局和细节都有深入的了解。数据分析及数据驱动下的执行过程是数据驱动智能制造模式的赋能系统，通过该系统精确地将制造过程从车间数字空间映射到物理空间。由此可得出数据驱动的业务模式，如图1所示。
图1 数据驱动的业务模式
的基本业务模式包括数据获取、数据建模、数据分析、数据在数据获取环节，通过物联网、产品数据管理系统、生产管理联网、产品数据管理系统、生产管理系统中获取制造相关数据，包括车间数据包括设备、物流、环境等，产品数据包括技术要求、模型、工艺等，任务数据包括批量、交期等。数据是实现数据驱动的基础，准确、实时、全面的数据对制造过程提供有效的支持。数据建模环节主要进行制造过程定义和算法模型构建，这个环节是在数字空间准确地定义生产过程中的人、机、料、法、环等信息，描述产品的工艺流程、物料需求以及工序之间流向和逻辑关系，并形成对生产过程的抽象数学描述。算法模型构建可针对特定的应用场景，对该场景的逻辑、结构进行抽象化。数据分析环节主要进行模型解析运用和基于模型的分析，包括资源分析、过程分析、质量分析等。数据执行环节主要是对数据模型和数据分析结果的执行，包括面向管理的决策支撑及数据透视，面向生产过程的任务下达和数据下发，面向工序操作的数据导引和自动执行。
图2 数据驱动的智能制造架构
数据驱动的智能制造模式架构如图2所示。
资源层主要为数据来源，包括来自物理空间的数据源，如设备仪器、车间工位、物流仓储等，和来自数字空间的数据源，如生产管理系统和产品数据管理系统等。
感知层主要实现各环节数据的采集和交换，通过传感器、物联网、数据采集器、标准化数据接口等方式，实现对象感知、数据实时采集、数据清洗和数据路由等功能。数据层是感知获得的数据集合，通过对结构化、非结构化数据的融合，实现对象级、时空级的数据对齐，为数据驱动模式构建实时准确的数据仓库。
驱动层通过利用数据层的数据集合，通过数据建模、数据分析、数据执行，实现数据驱动的制造模式，驱动层主要作用于三个层面，包括数据驱动的决策管理、数据驱动的生产系统、数据驱动的执行操作，将在后继章节展开详述。
应用层是在数据驱动下，实现车间的智能管理、智能生产和智能操作。
数据驱动的智能制造架构区别传统的ISA-95自动化金字塔，是以数据为核心而构建，从下至上为逐层支撑的关系。在上述架构中，部分功能通过自动化金字塔来实现，如数据驱动的生产系统，以及数据驱动的决策管理中的数据获取和执行等，而整体的逻辑结构是以数据流向和数据运用为主进行组织，通过上述架构来梳理信息系统关系和框架。
2.1 数据驱动的决策管理
制造数据在智能制造模式中具有决定性的作用，基于数据的建模、分析和挖掘，有助于洞悉制造过程的总体态势、低效区域、潜在风险等，从而支撑决策管理改善制造过程、生产执行及制造服务等环节，对动态扰动和制造过程进行实时优化。数据驱动支撑车间决策管理在以下有三个方面进行应用。
1）车间综合运行态势监控评估与决策支撑
电子装备生产线的运行存在生产计划预测难度大、质量管控过程复杂、现场生产数据繁多等问题，难以对生产线的薄弱环节做出准确而全面的判断。针对生产线运行存在的问题，在现场实时数据驱动下对生产线开展综合运行态势监控分析，根据从数据挖掘中所获得的信息、知识和关键绩效指标，支撑管理者进行生产决策，以提高生产线的效益和管理水平、实现生产线的持续改进。主要应用方向包括将车间的信息透明化和存在问题的显性化，由此进行快速响应和持续优化改进，从而提升效率、提升质量、降低成本和资源消耗；提供设备运行状态及设备的关键工艺参数，减少设备待机和排队时间，提高设备的利用率，通过对设备进行实时监控可对设备状态进行预测分析，以有效地安排设备维护窗口；进行制造过程监控预警、物料品质监控和良品率监控，减少未预期的物料问题或故障等造成的直接产能冲击和质量不稳定；通过模糊层次分析法等评价方法，综合分析车间的功能、结构和环境，进行车间多属性体系结构描述的对象系统做出全局性、整体性的评价，为车间改进提供支撑。
2）数据驱动的车间动态配置及自适应优化
电子装备车间内部人机料法环各资源节点存在复杂的耦合关系，导致运行过程存在着较强的不确定性。在实际的作业车间生产过程中，各种随机扰动的存在如设备故障、紧急插单等，都将造成车间发生一定的动态变化，导致原有的生产排程难以有效执行。在实时任务数据和现场采集数据驱动下，通过遗传算法等启发式优化方法，自动适应内外部条件变化，进行生产调度优化和物流优化决策，动态地对可用生产资源进行分配，安排合理的生产作业次序和物流配送路线，让生产系统变得更加动态和灵活。
3）基于数据挖掘的质量形成过程决策改进
数据驱动工艺决策改进是基于制造过程数据的应用，实现制造过程、工艺、设备等方面未知的规律和知识发现和创造，促进制造系统的持续改进。对产品质量相关数据按特征进行组织，通过数据挖掘和分析，揭示工艺参数、质量性能的相互作用规律，实现工艺参数对产品性能影响的精确映射，进而支撑工艺优化设计决策，实现工艺参数等影响产品质量的要素进行改进优化的优化提升。
2.2 数据驱动的生产系统
数据驱动的生产系统是在数据驱动下实现产品信息流、任务信息流、产品物料流、工具资源流贯通和综合集成，实现在生产作业过程中准确的产品信息、准确的任务信息、准确的物料供应、准确的资源保障，在准确的时间汇集到准确的地点。生产环节可以分为生产定义、生产齐套、加工装配、测试实验、交付入库。采用数据驱动的运行模式，通过生产过程的数字化定义，自动产生任务和下发制造数据，形成数据驱动。以生产任务数据为主线，推动生产活动的前进，其中BOM数据做为抓手，集成了产品数据、管理要求，物料清单、工具资源清单，并记录整个生产过程。
图3 数据驱动的生产系统实现
在生产系统中，数据驱动主要作用于产品信息贯通、任务信息下达、产品物料流转和设备资源配送四个方面。
1）数据驱动的产品信息贯通
产品设计、工艺等制造数据在一定平台或载体上按照一定流程被创建、更新、使用等过程，主要包含了设计-工艺-制造方向的流动。以数字化模型为载体，在产品的数字化模型中定义设计信息和制造信息，完整地表达产品信息。生产单元通过扫码等方式自动下载产品数据，驱动生产单元进行生产。
2）数据驱动的任务信息下达
生产计划、订单等生产任务信息的在一定平台或载体上按照一定流程被创建、更新、使用等过程，主要包含了ERP-MES-PLC方向的流动。以工艺模型和BOM作为数字线程的载体，用集成的工艺模型完整地表达产品定义信息，将设计信息、工艺信息、制造信息集成到产品的数字化模型中，同时用BOM要素地表达产品的构件信息和生产过程定义信息，持续推进数字驱动的精益生产模式。通过数字线程的贯通、推送与驱动，生产现场消除模糊有歧义的产品数据、生产指令和规章制度。BOM是产品开发、计划生产、成本核算、物流采购中不可或缺的信息来源，是各部门统筹协调的桥梁纽带。以BOM为抓手，将产品的工程数据进行集成和关联，在BOM上对生产制造过程的数字定义，实现以数据驱动生产过程高效运行和制造过程的精益控制。
3）数据驱动的产品物料流转
通过在BOM中定义工序级物料的准确信息，驱动物料在供应商、仓库、不同工位之间的流转，按照工艺路线经过逐个工序的制造，实现由原材料、器件、零件等向产成品的转变，主要包含了供应商-工厂-生产线-工位方向的流动。同时通过条码等方式实现物料信息的实时动态反馈。
4）数据驱动的设备资源配送
通过在BOM中定义工序资源的需求，在信息系统的综合调度下，实现刀具、仪器、工具、设备、辅料等通过工位固定或流转的方式，作用于产品生产过程的组织形式，主要包含工厂内部流转，包括仓库-工位两种流动。
2.3 数据驱动的执行操作
以数字模型完整地表达产品定义信息，使模型作为生产制造过程中的唯一依据，实现产品信息精准定义与表达。通过数字化实现设备、工位的联网集成，根据下载待生产产品工艺数据，节点处理程序、模型等产品数据流，驱动设备或者辅助操作人员进行相应的工艺过程。同时可通过数据采集实时反馈设备的状态等数据，实现上下数据贯通。
对于具有单件小批量特征的复杂电子装备，手工作业难以避免，目前主要有以设备为主和以手工操作为主的工位两种，数据驱动在这两种工位上采用不同的实现方式，如图4所示。
图4 数据驱动的操作执行实现
1）数据驱动的工艺自动执行
对于以设备为主的工位，通过对设备进行数字化，使设备具备完善的信息和通信能力。设备数字化信息包括设备的序列号、描述、模型及参数的数字化描述，使得设备在数字空间可被感知和识别。通过通信接口，使该设备能够与其他设备、装置以及控制系统、信息系统实现信息互通。在生产过程中，将工艺文件如测试程序、加工代码等下达到设备指导生产，通过参数定义和操作指令驱动各项制造活动。
2）数据驱动的手工操作
以手工操作为主的工位，通过数字化改造使其具备一定的可视化能力和人机交互能力，以条码及电子标签等编码技术为基础实现生产资源的可识别能力。以此为基础，操作人员通过扫码等方式下载产品制造数据到工位，制造数据包括执行程序、工艺模型等。通过对制造数据的解析，驱动辅助机器人、增强现实设备、防错装置、机器视觉装置等辅助操作人员完成相应工艺过程。辅助装置的应用可通过数据驱动的指引、防错、检验的方式提高生产效率、减少图物不一致等问题。
3 应用验证
本文提出的数据驱动的智能制造模式在西南电子设备研究所的生产车间进行实施，如图5所示，基于获取数据，通过基于模型与BOM的生产过程定义、制造系统执行、车间可视化监控、综合分析以及增强现实等技术的应用，初步实现了数据驱动的制造模式转型。
图5 数据驱动模式的典型应用
4 结语
数据驱动是企业智能制造实施的有效途径和重要方向，在物联网、大数据等新技术的影响下，数据价值创造逐步从仅作为流程的输入输出，转变为直接驱动生产过程和管理运营。本文探讨了数据驱动的电子装备智能制造模式，通过决策管理、生产系统、执行操作三个层面来实现数据驱动和数据价值创造，在制造模式转型应用过程中，已经初步发挥成效。随着制造模式转型的深化进行，针对不同的产品及其生产特点，构建相应的数据模型实现生产过程定义，将是数据驱动智能制造模式的重要关注点。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab77704e0a0d2e0fd207d3be0a962241/" rel="bookmark">
			no server suitable for synchronization found
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题 ntpdate -u x.x.x.x 解决过程 查看防火墙 解决方案1 service iptables stop 解决方案2 iptables -A INPUT -p udp -m udp --dport 123 -j ACCEPT 解决 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/740b91bb130365f467d7d69f8d5c1778/" rel="bookmark">
			嵌入式Web项目（一）——Web服务器的引入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 网络模型TCP服务器的概念Wed服务器的概念netstate 工具嵌入式系统，常用开源Web服务器移植BOA到Ubuntu下载BOA源码传输到虚拟机进行解压编译BOA修改BOA配置文件 测试BOA启动boa创建一个HTML文件并放入到www目录下浏览器访问 网络模型 在实际开发中，往往是基于TCP/IP四层模型进行项目的开发。
TCP/IP四层模型对应Wed项目的映射关系应用层嵌入式Wed控制器––传输层TCP UDP––网络层IP––网络接口层网卡 Web服务指的就是：使用TCP协议进行传输的网页服务
TCP服务器的概念 TCP服务器：是一个应用服务器，只要他的底层（传输层）的协议，如果使用了TCP，那么这样的应用程序称之为TCP服务器
Wed服务器的概念 Web服务器本身就是一个TCP服务器，由于应用层在数据格处理上，采用了HTTP的协议标准，这样的TCP服务器，称之为Web服务器。这个服务器可以为用户浏览器提供合法的数据
netstate 工具 从操作系统角度来分析，TCP/IP四层模型中，应用层处于在用户态，传输层以下就处于内核态了。因此用户往往是不能够直接访问内核空间的，但是我们又有查看当前网络信息的需求，因此Linux内核就提供一个这样的工具netstat
参数
| 选项| 含义 |
-t表示TCP相关-u表示UDP相关––-a表示所有的信息––-n表示将端口以数字的方式显示 嵌入式系统，常用开源Web服务器 服务器性能BOA功能交单，代码量少，适合学习––appweb功能强大、代码量大、工程使用 移植BOA到Ubuntu 下载BOA源码 进入官网
官网
下载
传输到虚拟机进行解压 创建目录用于存放boa
解压
编译BOA 使用配置脚本获取与体系结构相关的Makefile
修改Makefile，去掉调试选项
执行Makefile
出现错误，该错误出现在compat.文件，120行。我们去进行修改
修改为
先make clean一下，把之前生成的目标文件删了
make
strip剔除符号表
因为我们要移植到嵌入式系统中，希望尽可能地减少占用存储空间
修改BOA配置文件 配置文件的目的就是告诉BOA如何去工作
备份一份配置文件，防止修改错误无法还原
将配置文件传到/etc目录下
修改配置文件
注意区分 8080端口号，8080是网页浏览的端口号，80是HTTP协议默认的端口号。
修改日志
修改网页访问路径
cgic 动态网页的路径修改留在后面更新
测试BOA 启动boa 创建访问目录和日志目录
启动boa服务器程序
创建一个HTML文件并放入到www目录下 测试代码
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/740b91bb130365f467d7d69f8d5c1778/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/329f5d7cc6914676bac5323468c5f23e/" rel="bookmark">
			IDEA复制项目Module出现java文件夹source root解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们经常复制项目的时候，会出现module名称没有改变或者java文件夹后面有source root表示，maven父子项目没有标识等问题（如下图），在这里我将一一为大家解决
如果是maven父子项目需要在父文件的pom文件的modules中添加子项目的名称。
子项目修改pom把artifactId修改为新的名称。
添加之后项目Module有了蓝色的标识，但是后面多了项目名称。
右键项目选择Refactor下的Rename。
选着Rename module，命名跟前面一样的名字即可。
改完之后，名字没有了，还剩最后一个问题，java文件夹后面有source root。
选择File -&gt; Project Structure
找到Modules，找到复制的项目，注意，是复制的项目，我这里是复制的mybatis-03，点击右侧下面灰色的两条后面的X，删除路径。
删除之后，再对粘贴的项目文件夹标注对应的文件夹类型就解决啦~
最后再检查一下maven导入的依赖，有没有问题，大功告成~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/864343b3912eba1f1ceaf2918c522723/" rel="bookmark">
			一文理解DeepLab V1到DeepLab V3&#43;（超系统、超详细）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 预备知识空洞卷积 1、DeepLab V11.1 基于VGG模型1.2 总体架构1.2.1 Fully Connected CRF（条件随机场） 1.3 DeepLab V1模型实验 2、DeepLab V22.1 整体架构2.2 训练策略2.2.1 学习率的调整 3、DeepLab V33.1 cascade形式的DeepLab V33.2 parallel形式的DeepLab V3 4、DeepLab V3+4.1 深度可分离空洞卷积4.2 Modified Xception 预备知识 空洞卷积 参考我之前写的博客：
CSDN链接 空洞卷积详解
1、DeepLab V1 其他图像分割模型如FCN和U-Net都使用了反卷积和pooling保持分别率不变，而只使用空洞卷积就可以实现反卷积和pooling的效果，而且空洞卷积还具有可学习的优点。
1.1 基于VGG模型 1、以VGG模型为基础，因为想利用VGG模型预训练的参数；
2、去除掉最后2个max pooling，并使用空洞卷积保持感受野一致，空洞卷积使用在原VGG模型最后2个max pooling之间；
3、最后3个FC层都换成3×3的卷积，所以输出feature size为28×28；
4、第3步使用3×3 的卷积输出的通道数换成1024，不影响效果而且也增加速度；
1.2 总体架构 1、基于VGG模型修改的结构在上图的第一行已完成；
2、第四步是对基于VGG修改模型输出的结果进行双线性插值，增加8倍还原成原feature size的大小；
3、使用了Fully Connected CRF（条件随机场）
1.2.1 Fully Connected CRF（条件随机场） 公式：
其中：
解释： 图像分割是对每一个像素点进行分类，而每一个像素之间的分类是有联系的，所以用到了条件随机场。优化 E ( x ) E(x) E(x)，使其最小，所以可以使用梯度下降法来优化。
E ( x ) E(x) E(x)：优化 E ( x ) E(x) E(x)使其最小；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/864343b3912eba1f1ceaf2918c522723/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03ef97b1c41e8d5e9da7019501d75c69/" rel="bookmark">
			一文详解空洞卷积（Atrous Convolution）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、什么是空洞卷积（Atrous Convolution）1.1定义：1.2 空洞卷积后的feature size大小1.2.1空洞卷积的反卷积输出 1.3 为什么使用空洞卷积1.4 感受野的计算 1、什么是空洞卷积（Atrous Convolution） 1.1定义： 与反卷积正好相反，空洞卷积它是对卷积核的kernel size之间进行插值，用参数dilation来决定kernel size之间插值的数量，如果dilation等于2就是在原kernel size插一行，如图：
1.2 空洞卷积后的feature size大小 因为空洞卷积是对kernel size进行插值，所以空洞卷积后的feature size大小为：
上面这个式子应该都能看懂，只是加了dilation[0]之后，kernel size变成了dilation[0]*(kernel size[0]-1)+1，然后再替换原先的kernel size即可。
1.2.1空洞卷积的反卷积输出 说白了就是把上式的H_out、W_out作为输入，然后求出上式的H_in、W_in，此时的H_in、W_in作为空洞卷积反卷积之后的输出：
1.3 为什么使用空洞卷积 简单来说有两点：1、增大了感受野；2、与原卷积相比空洞卷积的参数量不变；
注： 感受野：输出的feature map每一个点占原输入的像素的多少。
1.4 感受野的计算 （a）：对输入原图进行3×3的常规卷积，所以卷积后的每一个点的感受野为3×3；
（b）：对（a）输出的feature map进行dilation为2的空洞卷积，（b）图每一个红点代表的感受野都为3×3，所以（b）图的感受野为7×7；
（c）：以此类推，（c）图的感受野为15×15；
总结： 感受野的计算公式：RF_out=（RF_in - 1）*stride+kernel-size
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c778805023fa7686e56b93775c1b9685/" rel="bookmark">
			【数据结构入门】算法的时间复杂度和空间复杂度详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 （1）算法效率（2）时间复杂度的计算1）什么是时间复杂度2）大O渐进表示法（估算）3）时间复杂度计算实例4）总结5）一些思考 （3）空间复杂度的计算（4）常见复杂度对比 本篇前言 在C语言阶段，我们学过了一些排序和查找算法，冒泡排序，快速排序，二分查找等等，哪种算法更好呢，我们如何衡量一个算法的好坏呢？本篇来学习算法的时间复杂度和空间复杂度，相信学完后你就会明白了。
（1）算法效率 算法在编写成可执行程序后，运行时需要耗费时间资源和空间（内存）资源 。因此衡量一个算法的好坏，一般是从时间和空间两个维度来衡量的，即时间复杂度和空间复杂度。
时间复杂度主要衡量一个算法的运行快慢，而空间复杂度主要衡量一个算法运行所需要的额外空间。
随着计算机行业的高速发展，计算机储存容量已经达到了很高的程序，已经不需要特别关注一个算法的空间效率了，重点关注其时间复杂度。
（2）时间复杂度的计算 1）什么是时间复杂度 算法中的基本操作的==执行次数==，为算法的时间复杂度。
直接上实例来讲解具体的计算方法吧
//计算Func1中++count语句总共执行了多少次？ void Func1(int N) { int count = 0; for (int i = 0; i &lt; N; ++i) { for (int j = 0; j &lt; N; ++j) { ++count; } } for (int k = 0; k &lt; 2 * N; ++k) { ++count; } int M = 10; while (M--) { ++count; } printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c778805023fa7686e56b93775c1b9685/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7e0454b0d85fbfc77734b18d1cf9ce8/" rel="bookmark">
			Linux C/C&#43;&#43;共享内存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、共享内存二、案例实现总结 一、共享内存 共享存储允许两个或多个进程共享一给定的存储区。因为数据不需要在客户机和服务器之间复制，所以这是最快的一种 I P C。使用共享存储的唯一窍门是多个进程之间对一给定存储区的同步存取。若服务器将数据放入共享存储区，则在服务器做完这一操作之前，客户机不应当去取这些数据。通常，信号量被用来实现对共享存储存取的同步。
常用函数
#include&lt;sys/ipc.h&gt; #include&lt;sys/shm.j&gt; int shmget(key_t key, size_t size, int shmflg); -功能：创建一个新的共享内存段，或者获取一个既有的共享内存内存段的标识。 新创建的内存段中的数据都会被初始化为0 -参数： -key：key_t类型是一个整型，通过这个找到或者创建一个共享内存。 一般用16进制表示，非0值 -size：共享内存的大小 -shmflg:属性 -访问权限 -附加权限：创建/判断内存是不是存在 -创建：IPC_CREAT -判断共享内存是否存在:IPC_EXCL,需要和IPC_CREAT一起使用 IPC_CREAT|IPC_EXCL|0664 -返回值： 失败：-1 并设置错误号 成功：&gt;0 返回共享内存的引用ID，后面操作共享内存都是通过这个值 void *shmat(int shmid, const void *shmaddr, int shmflg); -功能：和当前的进程进行关联 -参数： -shmid：共享内存的标识(ID),由shmget返回值获取 -shmaddr：申请的共享内存的起始地址，指定为NULL，内核指定 -shmflg：对共享内存的操作 -读：SHM_RDONLY,必须要有读权限 -读写：0 -返回值： 成功：返回共享内存的首地址。 失败： （void*）-1。 int shmdt(const void *shmaddr); -功能：解除当前进程和共享内存的关联 -参数： shmaddr：共享内存首地址 -返回值： 成功 0 失败 -1 int shmctl(int shmid, int cmd, struct shmid_ds *buf); -功能：删除共享内存，共享内存要删除才会消失，创建共享内存的进行被销毁了对共享内存是没有任何影响的 -参数： -shmidi:共享内存的ID -cmd:要做的操作 -IPC_STAT:获取共享内存的当前的状态 -IPC_SET:设置共享内存的状态 -IPC_RMID:标记共享内存被销毁 -buf：需要设置或者获取的共享内存的属性信息 -IPC_STAT:buf存储数据 -IPC_SET：buf中需要初始化数据，设置到内核中 -IPC_RMID:没有用，NULL key_t ftok(const char *pathname, int proj_id); -功能：根据指定的路径名，和int值，生成一个共享内存的key -参数： -pathname:指定一个存在的路径 /home/daima/a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f7e0454b0d85fbfc77734b18d1cf9ce8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d661b8cff643fca1d6a6b571e49ffa08/" rel="bookmark">
			前端实习生微信笔试题（附笔者答案）/ 深圳 day：1.10
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前端面试题
请简单描述html、css、js（2分） 1.1：html是超文本标记语言，是用来描述网页的一种语言
1.2：CSS是层叠样式表，用于对HTML的元素进行渲染，美化页面
1.3：JavaScript是一种脚本语言，是单线程的。源代码在发往客户端运行之前不需经过编译，而是将文本格式的字符代码发送给浏览器由浏览器解释运行。可用来实现网页上的交互。
js有哪些数据类型（3分） 基本数据类型： String、Number、Boolean、Null、Undefined。
引用数据类型：Object、Array、Function。
如何判断一个变量是array还是object（代码）（3分） 定义一个数组
var test_array = [];
使用isArray方法判断是否为array
Array.isArray(test_array) === ture
instance of
简单描述下DOM事件流（3分） DOM事件规定的事件流包括三个阶段：
事件捕获阶段、处于目标阶段和事件冒泡阶段。
Dom事件流同时支持两种事件模型捕获型事件先发生。两种事件流会触及DOM中的所有对象，从document对象开始，也在document对象结束。
请写出下面代码输出的值以及为什么（3分） var a = ‘a’;
var b;
a = b || a;
console.log(a);
输出a，因为b为undefined转化为数值是0，在||运算中如果前面的数为0，则返回后面的数。
将"2020/9/9 下午5:17:06"转化为"2020年9月9日 下午5:17:06"（代码）（5分） var oldTime = (new Date(“2020/9/9 下午5:17:06”)).getTime();
var curTime = new Date(oldTime).format(“yyyy年-MM月-dd日 下午5:17:06”);
console.log(curTime);
请根据标准数组对新数组进行排序（代码）（5分） var standard_array = [‘one’, ‘two’, ‘three’, ‘four’];
var new_array = [‘three’, ‘one’, ‘four’];
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d661b8cff643fca1d6a6b571e49ffa08/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/595135d94152b9a77a181c48b388d04e/" rel="bookmark">
			前端开发实习生第一天都在做什么？需要准备什么东西
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 相信很多准备入职或者正在找实习的前端小伙伴们应该都很好奇前端实习生第一天上班都在干什么。我在入职前也是在网上疯狂搜索每个人入职第一天都在干什么。下面我粗略介绍一下我前端实习入职的第一天哈。（理科生没啥文采见笑了）
正文 首先，由公司人事带领你熟悉一下公司的环境，然后介绍一下同个部门的成员，发一本类似员工手册的东西让你看看，然后就带领你到你的工位上啦。
然后就是自己先开机然后检查一下设备啥的有什么问题。然后就自己检查一下电脑环境，把需要的环境都装一下，因为我用的是一台新电脑，所以上来就开始去下载配置各种环境了，还有下载开发工具。大概就是下了Node-Git-SVN-VSCode-HBuilder X-微信开发者工具-然后就是一些VSCode插件和npm一些包。具体可以搜一下都搜得到。然后自己搭建个Vue项目跑一下环境通不通。我是用u盘拷贝了不少学习的资料和工具过来，包括前端常见技术栈的知识点总结。还有一些教程学习笔记，demo之类的。我是拿了自己拷贝的demo来测试环境的，推荐你们入职第一天也带个U盘（装个样子也行哈哈）。还有就是另外我还带了本CSS的书，想着应该用得上，结果后面写页面还真用上了。这个看个人想不想带都可以。
然后就是前端组长给了个uniapp和vue的后台项目让我试着跑起来，也算是配置环境，看看环境通不通吧。vue的后台项目很快就跑起来了，就是uniapp没怎么接触，稍微踩了不少坑。跑完整个项目差不多一个上午就结束了（啊哈哈哈哈哈）。
下午就是根据给的UI图，还原小程序的页面。之前没怎么写过小程序，不过还好知道要用view和text，然后用flex布局磕磕绊绊把页面还原的差不多了。然后下班的时间也差不多了。
结语 以上差不多就是我的前端实习第一天了，还有一些部门开会和自我介绍这些就没说，准备入职的小伙伴可以前一天稍微准备一下，避免自我介绍时太尴尬。
（本文用于记录笔者入职第一天，希望对你有帮助哈哈哈哈）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47684b1e9cd51029a59e4a088c7faf9d/" rel="bookmark">
			【C语言进阶8——指针的进阶（5）- 指针的练习】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		指针的进阶（5）- 指针的练习 前言1、指针的练习题1.1 练习 11.2 练习 21.3 练习 31.4 练习 41.5 练习 51.6 练习 61.7 练习 71.8 练习 8 总结 前言 本文继续通过练习题来复习数组和指针的知识点，主要是指针的练习题目。
1、指针的练习题 1.1 练习 1 int main() { int a[5] = { 1, 2, 3, 4, 5 }; int *p = (int *)(&amp;a + 1); printf( "%d,%d", *(a + 1), *(p - 1)); return 0; } 运行结果见下图：
1.2 练习 2 struct Test* p，p是一个结构体类型的指针，结构体Test类型的变量大小是20个字节。
假设p 的值为0x100000。 下面表达式的值分别为多少？
struct Test { int Num; char *pcName; short sDate; char cha[2]; short sBa[4]; }*p; int main() { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47684b1e9cd51029a59e4a088c7faf9d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7db1263c9310bed31aae89b20e84cfaa/" rel="bookmark">
			利用多线程按顺序连续输出abc10次
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		多线程无论是在面试还是在公司都是经常会出现和用到的技术。今天我通过一道小题融合多项多线程技术。
这道题是利用多线程连续输出ABC十次。首先，我先说明解决这道题的方法不唯一，而我只提供一种，其他方法希望读者自己尝试。第一步需要定义三个线程，继承Runnablej接口，重写其中方法并且加上synchronized锁，（synchronized是一种互斥同步锁，作用是在多线程程序中一次只能运行一个线程，并且同步更改），只用synchronized还不够吗，我们需要volatile关键字修饰一个变量用来控制线程执行顺序（volatile可以保证线程间的可见性和有序性，但是不能保证原子性，所以需要在合适的场景下才能保证线程安全）。通过java中的wait（）方法（使用wait（）方法后需要启动notify()方法才能重启线程）控制线程间隔。
public class ThreadABC { private volatile static int flag = 1; public static void main(String[] args) throws IOException, InterruptedException{ Thread threada = new Thread(new Runnable() { @Override public synchronized void run() { try { while(flag!=1) { wait(); } System.out.println("A"); flag = 2; notify(); }catch (Exception e) { e.printStackTrace(); } } }); Thread threadb = new Thread(new Runnable() { @Override public synchronized void run() { try { while(flag!=2) { wait(); } System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7db1263c9310bed31aae89b20e84cfaa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e625fe20642fafc2e05bdff01d9a330/" rel="bookmark">
			网络安全-渗透测试-Kali Linux教程系列篇 篇（三）信息收集-02
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Kali Linux 系列 No.3 信息收集-03 前言：在上一篇中，对于Nmap、Masscan两款主流的主机扫描、端口扫描工具进行了讲解，本文继续对其他优秀工具进行介绍。
声明：本文章中所提及的任何工具、技术不得用于非法用途，仅供学习讨论。
版权声明：请勿抄袭，转载请联系作者。
本文章本次发布平台：CSDN
Author：南城无笙
正文 Wafw00f 很多时候在进行Web安全测试的时候，都会经常性的遇到WAF（Web Application Firewall，Web应用防火墙），WAF很多时候都会阻碍测试过程，但是WAF也并非完美的，对应的WAF会有对应的绕过方法。这也就要提到本文要讲的第一个工具——Wafw00f，从名字上，就可以简单明了的看出这玩意是有关WAF 的，准确的说，wafw00f是一款WAF指纹识别工具，换算成白话就是：识别是何WAF。该工具位于Kali Linux工具集中的Information Gathering(我的是英文版的，所以后面涉及到Kali里面的内容就采用中英结合，会给出中文翻译)（信息收集）下的IDS/IPS Identification（IDS/IPS 鉴定）中。
对于个人能力较强者、喜欢钻研这个工具全部用法的，请执行：wafw00f -h来获取官方的说明文档。
wafw00f其实并不是一个难以使用的工具，没有许多不（邪）常（了）见（门）的参数，非常的好上手。
最简单用法 帮助文档中给出了他的最简单的使用方法：
wafw00f url1 [url2 [url3......] ]
简单的一句话其实可以覆盖百分之七八十的场景，举个栗子：
wafw00f http://www.example.com/test.html 下面，让我们随机抽取一个幸运网站（bushi）运行wafw00发，来看看他返回了怎样的结果（声明：本人的此行为并未对该网站造成任何不良影响。但如果没有把握请不要乱对微型、小型网站使用本系列文章所提到的某些工具。）
相信部分经验丰富的通过结果能看出是什么网站，但是看破不要说破（doge）。
从图中，我们主要提取以下的返回内容：
1.seems to behind a WAF or some sort of security solution（这句话意思就是似乎存在一个WAF或有一些安全防护方案）2.Reason后面给出了原因，图中的例子就是：正常的请求发起时和攻击请求发出时，响应头内容出现了改变（之所以原因需要主要提取的内容，是因为再精准的工具，由人工再进行一下判断都是好的，不可以百分之百的相信此类工具，返回结果应当只是为测试人员提供参考！）（这里的bws/1.1是某大厂自己开发的web服务器）
以上就是最最简单、基础的用法，下面介绍一些参数。 其他参数的使用 一个工具不能涵盖所有WAF，我们可以使用wafw00f -l或者wafw00f --list查看该工具支持的WAF。
可以查阅此表来明确支持检测哪些WAF。使用wafw00f时，很多时候一个网站有多个安全产品，我们可以加上-a或者- -findall来让工具找出所有WAF而不在第一个找到后就停下。在命令行中，附加-p [PROXY]或者--proxy=PROXY来使用代理服务器，一般格式如下： wafw00f http://xxx.com -p type://user:pass@host:port EXAMPLE: wafw00f http://xxx.com/ -p socks5://xxx.xx.xx.xx:8080 wafw00f http://xxx.com/ --proxy=socks5://xxx.xx.xx.xx:8080 使用时附加-t [WAF_Name] 或者- -test=WAF_Name参数，后接WAF名称可以对单独的某个WAF进行检测。（该参数在我个人使用时没有成功过，原因未知）使用-r或- -noredirect参数可以使工具不跟随3xx响应进行重定向.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e625fe20642fafc2e05bdff01d9a330/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed737fc321d18ab2d108e04d6c46b7d8/" rel="bookmark">
			ubuntu20.04系统 深度学习环境配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		己实际安装成功，欢迎指正～
一、安装ubuntu
1、先在Windows系统划分出空间给ubuntu：
100G固态 300G机械
2、下载镜像并制作启动盘： Windows-Ubuntu20-04双系统安装教程_feezxe的博客-CSDN博客_ubuntu20 双系统
3、关机进入BIOS模式，把两个UEFI移到最前面，保存退出，重启 进入ubuntu
空间充足可以选择正常安装，也可以选择最小化安装
安装类型：其他选项
创建分区：
p3 efi 然后点击下方加号选择p3作为启动项
固态10G挂载在根目录/
机械30G挂载在/home
二、安装驱动
三、Anaconda安装
1、下载地址：https://www.anaconda.com/products/individual
2、进入anaconda下载路径下执行：
bash /tmp/Anaconda3-2021.11-Linux-x86_64.sh 过程中选择：Enter yes yes
3、关闭当前终端并重新打开一个终端，或者在当前终端输入：source ~/.bashrc
可参考官网：在 Linux 上安装 — Anaconda 文档 (continuum.io)
验证：在新打开的终端中输入：conda ，查看是否能够识别
四、安装cuda
1、首先要查看自己的驱动是否支持你要安装的cuda版本：
CUDA版本与显卡驱动对照表_Janus_V的博客-CSDN博客_cuda版本和驱动版本
官网：https://docs.nvidia.com/cuda/cuda-toolkit-release-notes/index.html#title-resolved-issues
2、采用runfile的方式安装
下载地址：https://developer.nvidia.com/search?term=cuda11.3
不要用wget下载容易出错，直接复制wget后面的链接进行下载：
https://developer.download.nvidia.com/compute/cuda/11.3.0/local_installers/cuda_11.3.0_465.19.01_linux.run
（1）进入下载目录：
sudo sh cuda_11.3.0_465.19.01_linux.run 点击continue
输入accept:
上图中只勾选 cuda toolkit xx.x（按enter取消勾选，框中显示X代表已勾选）
图片来源：Ubuntu 20.04 CUDA&amp;cuDNN安装方法_ashome123的博客-CSDN博客_ubuntu20.04安装cuda
（2）增加环境变量：sudo gedit ~/.bashrc
export PATH="/usr/local/cuda-11.3/bin:$PATH" export LD_LIBRARY_PATH="/usr/lcoal/cuda-11.3/lib64:$LD_LIBRARY_PATH" 使环境变量生效：source ~/.bashrc
（3）查看: nvcc -V
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed737fc321d18ab2d108e04d6c46b7d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8454f97d36489ad5e7e6814a76649670/" rel="bookmark">
			实现企业的降本增效，设备管理应该怎么做？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		工业4.0时代，智能制造和智能生产已经成为众多传统企业转型的目标。设备管理作为智能制造不可缺少的环节，设备管理的好坏直接影响企业的经营和生产。随着设备数量和种类的日益增多，以及设备的精度和复杂性对生产效率的要求越来越高，传统的设备管理模式已经无法满足现在企业对设备管理的需求。于是，越来越多的企业开始引入设备管理系统进行设备的管理。
在多年的行业积累和技术沉淀中，易点易动不断研究、总结、精炼，上线了设备管理模块，使工厂的日常设备管理更加智能化。可实现集团统一化管理所有设备，支持多层级、多组织机构管理、多角色、多数据权限管理。
给每个设备绑定二维码或者RFID码后，就可以开始全生命周期闭环式管理了。从采购需求制定计划，科学合理地调度和调拨设备等，都可以进行有效管理和追溯。从多方面完成公司设备的信息化和无纸化管理。
除了全生命周期管理之外，设备管理模块中还有这些功能：
1）巡检/点检：包括巡检点设置，巡检计划设置，移动端巡检登记，巡检整改等功能。
2）维修管理：管理从报修→维修派工→移动端维修接单→维修验收的全维修周期管理
也可以管理委外维修等。
3）保养管理：管理保养项目制定，保养方案制定，保养工单派工，保养执行等
4）附属资产管理：附属资产在资产台账中作为独立资产存在，拥有独立的资产编号、名称、分类等资产属性，但在使用时，作为其他资产的附属存在，不独立使用，如服务器内存，CPU，台式电脑附带的显示器等。
5）配件管理：配件是作为资产所用到的零件类，无法独立使用，每个配件也没有单独的卡片，已库存方式进行数量管理，如价格便宜的鼠标、键盘，网线等。
易点易动提供卓越的设备管理方案。借助云计算、智能手机、IoT设备，基于低代码、数据聚合、可视化分析、智能预测四大功能板块，用数据和算法帮助企业提高设备可用性、预测设备故障并执行预防性保养、降低维护和购买成本，拓展设备使用寿命，实现投资回报最大化。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b6a45fbd2e16010f0e264a1c1d42f81/" rel="bookmark">
			错误：PermissionError: [WinError 32] 另一个程序正在使用此文件，进程无法访问。“&#43;文件路径“的解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		错误：PermissionError: [WinError 32] 另一个程序正在使用此文件，进程无法访问。"+文件路径"的解决方案 解决方案：不管是PIL、opencv等python库在open一张图片的时候，我们是不能进行删除操作的，就像错误提示的那样，当前文件被另一个程序使用，解决方法就是加上下面这行代码
img.close() #bug修改代码 总结：
一、以后不管是图像文件还是txt等文本文件，当我们在进行open的时候，一定要记得close掉，甚至还可以扩展到只要使用了open函数，就一定记得close掉。
二、在这里只是删除的时候会报这个错误，那么如果是对图片数组进行修改、或者移动图片的时候会不会同样报这个错误呢？这个猜想留待以后验证。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b341d8e6830737e0954358371cdc5d47/" rel="bookmark">
			基于三维实景建模与CIM的数字孪生城市建设
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于三维实景建模与CIM的数字孪生城市建设 导语 自2012年我国中央政府出台《国家智慧城市试点暂行管理办法》始，国家颁布的指导智慧城市合理发展的政策逐年增加，到2017年“建设智慧社会”被正式写进十九大报告中，智慧城市建设已上升为国家战略。经过多年探索，我国在智慧城市建设方面已经有了丰富的实践经验与理论基础，但对于智慧城市建设的具体路径与方式，社会各界尚未达成共识。作为空间规划信息化、时空大数据应用等领域的实践者与探索者，国地科技一直致力于探索与我国当前信息化进程相适应的新型智慧城市建设之路。
针对我国大部分城市信息化进程尚处于智能化前期阶段的现状，国地科技认为：城市大数据的智慧应用与可视化应当是智慧城市建设的基本前提。因此，通过数字孪生城市的建设，在虚拟空间再造一个城市，作为现实城市的映射、镜像、仿真、辅助与实验，可以更好地实现数字城市向智慧城市的过渡。
数字孪生（Digital Twin）的概念最早是由美国密歇根大学的Michael Grives 教授于2003年提出。但其在国内引起广泛关注，是因为雄安新区的建设中明确提出，数字雄安建设最重大的创新，是形成与新区共同成长的数字孪生城市，而实现的主要方式，就是在建设物理城市的同时，通过万物互联感知，汇聚多方数据搭建城市智能模型（CIM）。2018年住建部起草的《“多规合一”业务协同平台技术标准（征求意见稿）》，鼓励有条件的城市，可在BIM（Building Information Modeling）应用的施工技术上建立城市信息模型（City Information Modeling）。中国工程院吴志强院士则提出了城市智能模型（City Intelligent Modeling），对CIM进行了更深层次的解读。可以说，随着CIM定义的提出和不断深化，数字孪生城市建设将更加深入。总之，这些概念的提出给予了智慧城市有力的支撑。
三维视频融合.[点卯.增强虚拟全景平台].免费版 虚拟现实 监控
一、数字孪生城市建设：满足智慧可视的本质需求 元宇宙的兴起，让以三维视频融合与三维投影融合为核心、以倾斜摄影和三维地图构筑的CIM作为托底的时空克隆引擎，成为时代的主流技术，以此打造了混合架构的魔镜平台
为满足城市创新运营和应用需求，数字孪生城市建设必须解决时空信息可视化问题。而可视化的本质是要解决用户实际的业务问题，首先要解决城市管理者和数字孪生城市系统应用能“看得懂”的问题。三维场景更容易让观者有代入感，能提升事件处理效率，缩短问题反应时间。对于城市管理者而言，实现城市基础设施可视化管理、城管部件可视化定位、城市用地信息可视化监测、城市应急指挥可视化决策等方面，能更好地满足管理与决策上的高层次应用。对于公众而言，可视化的三维实景城市是客观世界的真实写照，不需要公众具有专业知识来判读理解，能根据实时场景进行问题查询和处理。
点卯 时空克隆 三维视频融合 三维投影融合 全景三维 CIM 魔镜下载
基于三维实景建模与城市智能模型（CIM）的数字孪生城市建设，可利用高精度的三维实景模型为智慧城市时空大数据平台提供全过程的可视化支撑，利用城市智能模型（CIM）通过生动准确描述实体单元并融合城市地理实体的动态信息来支撑智慧城市各类应用，从而真正意义上实现智慧城市建设的智慧可视。
二、数字孪生城市建设路径与方法 （1）城市三维地图是数字孪生城市可视化的重要基础
传统的智慧城市建设在空间规划上已经实现系统化管理，但大体都停留在二维平面的阶段，远达不到智慧城市智慧化建设要求。三维空间的有效感知与实景可视化日益成为城市建设管理的重要问题，也是数字孪生城市信息化的关键内容，从二维平面提升到三维立体已经成为数字孪生城市建设的迫切需求。
首先，从三维实景建模的数据来源来看，无人机航测、激光雷达、倾斜摄影等新一代测绘信息技术方法的发展，可以快速采集制作精细化的城市三维模型和大比例尺地形图，搭建三维城市地理信息基础服务框架，为数字孪生城市建设提供高精度可视化的三维空间信息和位置服务。
其次，从三维实景模型的建立过程和优点来看，通过有效刻画空间几何模型、拓扑图和语义等特征，来实现精细化的三维几何表达，真正实现基础设施性能的语义描述，与物联网进行拓展关联，进而实现复杂地形地理环境的层次描述。三维实景模型的一大特点在于高低细节层次的有效转化过程中，城市实景信息更加精细和丰富。“影像+模型”的方式实现了对目标的实景可视化查询，对数字孪生城市进行智能化规划和管理。
最后，从三维实景建模的应用场景来看，数字孪生城市需要实现城市管理精细化、基础设施智能化、生活服务便利化的目标，在智慧政务、智慧城管、智慧医疗、智慧教育、智慧旅游等方面达到“以更少投入获得更优质、更高效产出”的城市系统。总之，城市三维实景建模从数据来源特点、模型优势、应用场景等方面为数字孪生城市可视化提供了重要基础保障。
三维实景地图建模
(2) 以时空大数据促进数字孪生城市建设的科学与高效
时空大数据主要包括时序化的基础时空数据、公共专题数据、物联网实时感知数据、互联网在线抓取数据和根据本地特色扩展数据，构成数字孪生城市建设所需的地上地下，室内室外，虚实一体化的、开放的、鲜活的时空数据资源。数字孪生城市建设需要依托城市大数据技术手段，在深度应用上，基于真实有效、高精度和对象化的城市三维实景环境，对城市大数据进行精准定位、深度挖掘，提高数据信息表现力和价值，满足城市不断发展变化的要求。在广度应用上，数字孪生城市建设关注大数据融合分析和应用，基于多源、海量数据分析，全面、准确地掌握事物特征和发展态势、关键影响因素、发展规律，提高政府科学决策水平，提供个性化、差异化服务，提升解决复杂问题的综合能力。
城市时空大数据平台
（3）地理学模型、物联网及三维模型的融合助力数字孪生城市精细模拟
地理学是研究地球表层自然和人文要素相互作用关系及其时空规律的科学，发展至今产生了涵盖气象，环保、应急、交通、水文等诸多领域的大量地理学模型。随着物联网等技术的发展，无数智能终端设备每分每秒都在产生并传播海量的数据，这给传统的地理学模型提供了更多高精度、实时、丰富的数据来源，同时也对原有的模型提出了新的需求和挑战。地理学模型、物联网及三维模型的融合，能实现城市的精细化模拟，为数字孪生城市建设管理等提供科学的决策依据。以城市内涝为例，一方面，内涝不能再作为单一的自然现象来研究，内涝的发生会引发后续的诸多城市管理问题，如交通堵塞、居民财产损失等，所以城市洪涝的研究需要将视角放在整个城市的协调发展上。另一方面，城市内涝的持续时间不会很长，在这样短时性的要求下，仍需为后续的城市管理提供科学的决策信息。因而，计算高效、注重内涝时空过程、实时准确地可视化呈现与提供智慧服务是数字孪生城市发展和管理对城市洪涝模型新的需求。
城市内涝精细模拟
（4）城市智能模型（CIM）是构建数字孪生城市的关键技术
城市中的各实体的运行状况及其生产、生活活动是一个复杂的综合体，如何实现对其运行状态的及时感知，风险及问题的早期预测和高效处置应对，需要建立一个具有大量决策支撑信息的多维数据模型和系统来支持上述高复杂度的分析，简化管理机制并模拟决策。在智慧城市发展应用中，通过CIM建模以实现对城市信息的评估和高效组织是发展的必然趋势。CIM作为实现数字孪生城市的关键技术，虽然其应用从数量、范围和深度上都有飞速发展，但是目前仍然存在空间建模较为单一、实体描述尺度粗泛、实体表达较为简单以及难以实现真三维的高仿真模拟分析、处理和表达更多维度信息等问题。因此，国地科技致力于研究并集成创新CIM技术，以实现对城市地理实体信息进行有效的组织，形成城市的数字化镜像，并依托这一镜像有力支撑具体应用，从而实现针对城市各专业领域的规划、建设和运行管理等应用层级的有效协同、精确分析、实时预警预测以及动态的高仿真可视化管理。
CIM的技术构成及应用路径
三、基于数字孪生城市建设的智慧应用与国地实践 （1）视频和三维模型的融合展开数字孪生城市多场景应用
随着智慧城市网络通信层、物联感知层、支撑平台层、智慧应用层的深入建设，如何将高效海量的城市动态视频信息进行调用、查看以及视频场景分析，并与三维实时模型融合，成为当前智慧城市创新建设的重要内容。
城市三维地理信息视频融合技术从城市地理信息应用的角度出发，依托城市三维实景模型，匹配动态监控视频，直观精准打造动态数字孪生城市可视化沙盘，融合人工智能大数据挖掘、物联网感知信息，以及业务应用系统，打破各系统信息孤岛，提升数据应用价值，更好地服务于用户，目前能应用于交通、应急、安防、警用、城市内涝等多种场景。
视频与三维模型有机融合首先可以应用于路径规划调度，能在交通、应急处理发挥有效作用。在数字孪生城市建设中按照城市道路走向、重要区域部署、特殊情景设计等要求，规划和设置路径浏览，实现多个事故预案保存和调度，高效用于预置路径全程动态监控和实时态势掌握，实现城市部门可视化精准指挥。其次，能够展开全景细节追视，在安防、警用调查提供重要信息。警务部门在实现宏观全景浏览的同时，关联高速球机来捕捉目标特写视频画面，解决细节不清晰、视角有偏差等问题，为运动目标的连续、精确监控提供有效手段，在安保、警方迅速获取视频信息并及时做出判断和响应方面提供有力技术支持。另外，还可以实现二维三维联动，能对城市内涝、火灾等自然灾害进行及时监控。通过二维场景和三维场景模型统一联动操作，将二维场景作为整体观测画面，三维实景模型场景用于具体区域的视角全程监测，做到整体宏观和具体细节的协调统一态势感知，对自然灾害的发生与突变做到及时有效控制。
三维实景模型与监控视频融合
（2）数字孪生城市建设智慧应用的国地实践
在基于三维实景建模和CIM的数字孪生城市建设上，国地科技做了初步规划和探索，试图通过新一代信息技术与城市现代化要求融合，为新型智慧城市建设提供新思路和新途径，并在多个领域进行了深入实践。
在空间规划领域，为解决CIM的应用潜能和优势未充分发挥的现状，在用地尺度构建多维态元胞模型，基于空间规划对用地的引领，充分利用大数据在人群活动及空间行为决策挖掘方面的优势，进行空间规划辅助决策系统研究。
在智能管理领域，基于智慧城市对设施进行全生命周期管理的需要，CIM利用BIM在开发建设全过程中的模拟和展现优势，充分结合大数据技术在规划设计、施工管理、运维管理等不同阶段的数据关联和信息挖掘能力，构建耦合大数据的BIM模型，进行城市开发建设智能辅助决策系统研究。
在可视化应用领域，集成3DGIS、BIM、VR等高维可视化技术和手段的优势，进行高仿真、动态化、可交互的可视化系统研究。
结语 智慧可视是智慧城市建设的基本前提。国地科技从当前我国大部分城市信息化发展尚处于智能化前期阶段的现实出发，基于三维实景建模与城市智能模型（CIM）进行数字孪生城市建设与智慧应用，将为新型智慧城市建设提供新思路与新途径，更好的支撑新型智慧城市“无处不在的惠民服务、透明高效的在线政府、融合创新的信息经济、精准精细的城市治理、安全可靠的运行体系”建设目标的实现。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/351586554c90436c09be554fd08d0b57/" rel="bookmark">
			数据结构——线性表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 前言一、线性表定义和特点二、 类型定义二、顺序存储1.定义2.完整代码及注解 三、链式存储1、定义2、分类3、相关概念4、完整代码及注解 四、顺序表与链表的比较 前言 提示：这里可以添加本文要记录的大概内容：
—线性表是最基本且最常用的一种线性结构，同时也是其他数据结构的基础，尤其是单链表，是贯穿整个数据结构课程的基本技术
提示：以下是本篇文章正文内容，下面案例可供参考
一、线性表定义和特点 定义：由n(n&gt;=0)个数据特性相同的元素构成的有限序列
特点：
1存在唯一的一个被称为“第一个”的数据元素2存在唯一的一个被称为“最后一个”的数据元素3除第一个外，结构中的每一个数据元素均只有一个前驱4除最后一个外，结构中的每一个数据元素均只有一个后驱 存储方式：1、顺序存储：顺序表 2、链式存储：链表
注：线性表是一个相当灵活的数据结构，其长度可根据需要增长或缩短。
二、 类型定义 ADT List{ 数据对象：D 数据关系：R 基本操作： 1、初始化 2、置空 3、获取长度 4、获取数据元素 5、插入 6、删除 7、查找 8、打印线性表 }ADT List 二、顺序存储 1.定义 定义：线性表的顺序表示指的是用一组地址连续的存储单元依次存储线性表的数据元素，这种表示也称作线性表的顺序存储结构或顺序映像。通常称这种存储结构的线性表为顺序表
2.完整代码及注解 class SQList: def __init__(self, maxsize): self.curLen = 0 # 顺序表当前长度 self.maxSize = maxsize # 顺序表最大长度 self.listItem = [None] * self.maxSize # 顺序表存储空间 def clear(self): """将线性表制成空表""" self.curLen = 0 def is_empty(self): """判断线性表是否为空表""" return self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/351586554c90436c09be554fd08d0b57/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ccb732885c24357d3537337595098c0/" rel="bookmark">
			html-canvas-画圆、画文本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.画圆
属性：ctx.arc(x, y, R, start, hudu, boolean）
其中，x,y表示坐标，R表示半径长，start表示起始，hudu表示要画的弧度，boolean表示要画的角度大小
例子：（画逆时针）
&lt;canvas id="canvas1" width="600" height="600"&gt; 正常的画布是不显示的 &lt;/canvas&gt; &lt;script type="text/javascript"&gt; var canvas1 = document.querySelector("#canvas1") var ctx = canvas1.getContext('2d') //默认为false,是顺时针，true为逆时针 ctx.arc(200,200,100,0,Math.PI,true) ctx.fillStyle = 'bisque' ctx.fill() ctx.stroke() &lt;/script&gt; 结果：
例子：（画顺时针）
同上面代码，其中
ctx.arc(200,200,100,0,Math.PI,false)//修改此句 结果：
例子：画整个圆
ctx.arc(200,200,100,0,2*Math.PI,false) 结果：
2.画文本
属性：
fillText(text, x, y, [maxWidth])
strokeText(text, x, y, [maxWidth])
*可选参数maxWidth为文本的最大宽度，单位为像素。如果设置了该属性，当文本内容宽度超过该参数值，则会自动按比例缩小字体，使文本的内容全部可见；未超过时，则以实际宽度显示。如果未设置该属性，当文本内容宽度超过画布宽度时，超出的内容将被隐藏。
例子：
&lt;canvas id="canvas1" width="600" height="600"&gt; 正常的画布是不显示的 &lt;/canvas&gt; &lt;script type="text/javascript"&gt; var canvas1 = document.querySelector("#canvas1") var ctx = canvas1.getContext('2d') ctx.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ccb732885c24357d3537337595098c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa379a738e722a7f499554133022dd59/" rel="bookmark">
			oracle导出dump文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		给新来的同事导数据库，
oracle配置文件如下：
本地数据库 ORCL_LOCAL =
(DESCRIPTION =
(ADDRESS = (PROTOCOL = TCP)(HOST = localhost)(PORT = 1521)) (CONNECT_DATA = (SERVER = DEDICATED) (SERVICE_NAME= orcl) ) )
cmd命令下，exp testutf1/testutf@orcl file=s:\ebs.dmp full = y
报错：
**EXP-00056 :遇到 ORACLE 错误 12154
ORA-12154: TNS ：无法解析指定的连接标识符
EXP-00000:导出终止失败
网上给出办法基本有三：
一、tnsnames.ora 文件中orcl实例名对应了多个ip地址,就是这种情况：
本地数据库 ORCL_LOCAL =
(DESCRIPTION =
(ADDRESS = (PROTOCOL = TCP)(HOST = localhost)(PORT = 1521)) (CONNECT_DATA = (SERVER = DEDICATED) (SERVICE_NAME= orcl) ) )
41数据库 ORCL_TEST_41 =
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa379a738e722a7f499554133022dd59/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d17616062532e66cb1f095632630e007/" rel="bookmark">
			win10卡顿修复
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法一：利用文件检查工具修复
SFC是windows文件检查器，可以帮助用户修复一部分系统重要文件也适用于Win7/win8系统，使用情况：系统还能正常开机，出现一些莫名奇妙的问题，排除第三方软件故障后使用。 1、在搜索栏中输入CMD，然后以管理员身份打开。
2、打开后在命令提示符处，键入下列命令，然后按回车Enter键： sfc /scannow。
sfc /scannow 命令将扫描所有受保护的系统文件，并用位于%WinDir%\System32\dllcache 的压缩文件夹中的缓存副本替换损坏的文件。
方法二、利用Dism对比服务器镜像进行文件在线修复
Dism主要用于镜像部署管理，所以当你怀疑Win10系统有文件损坏或丢失，使用SFC不能修复时，可以使用DISM进行在线修复。
【以管理员运行如下命令】：
DISM.exe /Online /Cleanup-image /Scanhealth
第一条命令是扫描你全部系统文件并和官方系统文件对比。
第二条命令是把那些不同的系统文件还原成系统官方源文件，跟重装差不多。
方法三、系统重置
Win10系统给大家带来了重置功能，可以帮助用户快速初始化win10和重装差不多，同时有保留文件和不保留两个选项。
如果系统能进那么直接按（Windows10通过重置来修复系统的方法）这个文章进行操作。
如果系统已经无法进入，那么可以进入WINRE模式进行重置。（参考：Win10进入WinRE图文教程）
方法四、系统还原：
系统还原功能早在XP时就有了，通常是开启了系统保护，系统会自动创建还原点，或是手功创建，大家在win10出现问题时可以使用还原点进行还原。
Win10系统电脑下如何创建还原点实现快速恢复系统
修复Windows10系统的四种方法就介绍到这里了。上述小编介绍的几个Win10系统修复的方法是比较常用的，当然还会有更多的方案。欢迎大家探讨。
方法一亲测可用
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5f0c4094b5bf36042eeda69842ec516/" rel="bookmark">
			Linux C/C&#43;&#43;内存映射
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、什么是内存映射？？二、内存映射的优势三、a,b通信代码实现(Linux)四、父子进程通信代码实现(Linux)五、匿名映射代码实现(Linux)六、文件映射进行拷贝代码实现(Linux)内存映射注意实现以及面试常见题 一、什么是内存映射？？ 内存映射是将磁盘上某文件的一部分或整个文件映射到应用程序地址空间内某个地址范围的一种机制。然后，应用程序可采用与访问动态内存相同的方法访问磁盘上的文件。与使用
fread 和 fwrite 等函数相比，这会加快文件的读取和写入速度。
二、内存映射的优势 内存映射的主要优势体现在效率、更快的文件访问速度、能够在应用程序之间共享内存，以及更高效的编码。
更快的文件访问速度
通过内存映射访问文件的速度比使用 fread 和 fwrite 等 I/O
函数访问文件更快。系统使用操作系统内置的虚拟内存功能读取和写入数据，而不必分配数据缓冲区，将数据复制到数据缓冲区，然后取消分配进程所拥有的数据缓冲区。
在先行构造了映射的情况下，MATLAB®
不会从磁盘访问数据。它仅在内存映射的指定部分被访问时才会读取或写入磁盘上的文件，之后便仅读取该特定部分。这可以提高对映射数据的随机访问速度。
效率
将文件映射到内存后，访问文件中的数据时就如同该数据已被读入到应用程序地址空间中的数组。最初，MATLAB
仅为该数组分配地址空间；在您访问映射的区域之前，它不会从文件中实际读取数据。因此，利用内存映射的文件所提供的机制，应用程序无需先将整个文件读入内存，便可访问超大型文件中的数据段。
高效的编码样式
通过 MATLAB 应用程序中的内存映射，您可以使用标准 MATLAB 索引操作来访问文件数据。将文件映射到内存后，您可以使用与读取
MATLAB 工作区中变量所用的相同类型的 MATLAB
语句，来读取该文件的内容。所映射文件的内容就像是当前活动工作区的数组一样。您只需创建此数组的索引，便可在文件中读取或写入所需的数据。因此，您不需要显式调用
fread 和 fwrite 函数。 在 MATLAB 中，如果 x 是内存映射变量，y
是要写入到文件的数据，则只需执行以下命令即可写入到文件：
x.Data = y;
在应用程序之间共享内存
内存映射文件还提供了在应用程序之间共享数据的机制（如下图所示）。实现方法是让各个应用程序映射同一文件的多个部分。您可以使用此功能在
MATLAB 与其他应用程序之间传输大型数据集。
三、a,b通信代码实现(Linux) a.c
#include&lt;stdio.h&gt; #include&lt;sys/mman.h&gt; #include&lt;unistd.h&gt; #include&lt;sys/types.h&gt; #include&lt;stdlib.h&gt; #include&lt;string.h&gt; #include&lt;wait.h&gt; #include&lt;sys/stat.h&gt; #include&lt;fcntl.h&gt; int main() { int fd = open("test.txt",O_RDWR); int size= lseek(fd,0,SEEK_END); void* ptr = mmap(NULL,size,PROT_READ|PROT_WRITE,MAP_SHARED,fd,0); if(ptr==MAP_FAILED) { perror("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e5f0c4094b5bf36042eeda69842ec516/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d68b1c5cfc62ed53b2b6a09b532da10/" rel="bookmark">
			Pyqt5将.ui文件转换成.py文件的两种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法一：通过命令行把.ui文件转换为.py文件 PyQt 5安装成功后，pyuic5命令默认安装在%/python3x/Scripts目录下。我的pyuic5的安装路径是E:python35.Scripts。
如果想将firstMainWin.ui转换成.py文件，输入以下命令即可：
pyuic5 -o firstMainWin.py firstMainwin. ui 注意：如果输入pyuic5命令没有得到正确提示，而是提示“pyuic5不是内部命令或外部命令,也不是可运行的程序或批处理文件”,则是由于 Python3.*环境配置出错导致的.
转换后的结果如下：
方法二：通过Python脚本把.ui文件转换为.py文件 对于对命令行的使用不熟悉或者不太喜欢的同学，这里提供了Python脚本来完成转换的方法，这个脚本本质上是用Python代码把上述方法一的操作封装起来。完整代码如下:
# -*- coding: utf-8 -*- ''' ui转换成py的转换工具 ''' import os import os.path # UI文件所在的路径 dir = './' # 列出目录下的所有ui文件 def listUiFile(): list = [] files = os.listdir(dir) for filename in files: #print( dir + os.sep + f ) #print(filename) if os.path.splitext(filename)[1] == '.ui': list.append(filename) return list # 把后缀为ui的文件改成后缀为py的文件名	def transPyFile(filename): return os.path.splitext(filename)[0] + '.py' # 调用系统命令把ui转换成py def runMain(): list = listUiFile() for uifile in list : pyfile = transPyFile(uifile) cmd = 'pyuic5 -o {pyfile} {uifile}'.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d68b1c5cfc62ed53b2b6a09b532da10/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e97e39d7cb787338ce867a0bdbc57b22/" rel="bookmark">
			OpenCV计算机图像处理 —— 凸性缺陷 &#43; 点多边形测试 &#43; 形状匹配 &#43; 轮廓分层与cv.findContours()
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OpenCV计算机图像处理 —— 凸性缺陷 + 点多边形测试 + 形状匹配 + 轮廓分层与cv.findContours() 目录 OpenCV计算机图像处理 —— 凸性缺陷 + 点多边形测试 + 形状匹配 + 轮廓分层与cv.findContours()1. 凸性缺陷2. 点多边形测试3. 形状匹配4. 轮廓分层与cv.findContours()4.1 轮廓分层与cv.findcontours()的关系4.2 轮廓检索模式（四种参数） 1. 凸性缺陷 一般来说凸曲线都是凸出或平坦的曲线，如果在内部凸出了（凹进去了）我们就称其为凸性缺陷，OpenCV提供了一个方法cv.convexityDefects()
这个函数返回一个数组，其中每行包含这些值-【起点，终点，最远点，到最远点的近似距离】，我们可以用图像把它形象化，我们画一条连接起点和终点的线，然后在最远处画一个圆
import cv2 as cv import numpy as np img = cv.imread(r'E:\image\test14.png') img_gray = cv.cvtColor(img, cv.COLOR_BGR2GRAY) ret, thresh = cv.threshold(img_gray, 127, 255, 0) contours, hierarchy = cv.findContours(thresh, 2, 1) cnt = contours[0] hull = cv.convexHull(cnt, returnPoints=False) defects = cv.convexityDefects(cnt, hull) for i in range(defects.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e97e39d7cb787338ce867a0bdbc57b22/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0da6d0dfc24d55e72eda0a0e5f2a8b4/" rel="bookmark">
			写一个简单的 可扩展功能的 计算器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		看完解析器设计模式,忍不住的也尝试了一下
一个简单可扩展的计算器,不知道有没有bug,反正我没遇到,哈哈
trait 运算规则 { fn 运算符(&amp;self)-&gt;&amp;'static str; ///数值越大优先级越大 fn 优先级(&amp;self)-&gt;i32; fn 运算算法(&amp;self,a:f64,b:f64)-&gt; f64; /// 如果出现 ( + 运算符 + 数字 + ) ,的情况,直接把数字处理,比如: '(' + '-' + '1' + ')',会处理成 (-1) fn 分析时处理(&amp;self,a:f64) -&gt; f64{ a } fn is_运算符(&amp;self,s:&amp;str) -&gt; bool{ self.运算符() == s } } struct 计算器构造器(HashMap&lt;&amp;'static str,Box&lt;dyn 运算规则&gt;&gt;); impl 计算器构造器 { fn new()-&gt;Self{ Self(HashMap::new()) } fn add运算规则( mut self,a:Box&lt;dyn 运算规则&gt;) -&gt; Self { self.0.insert(a.运算符(),a); self } fn build(self)-&gt;计算器{ 计算器 {运算符:self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c0da6d0dfc24d55e72eda0a0e5f2a8b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/582a5c956958b6ccacbe70e433c650cb/" rel="bookmark">
			Vue3 初探 ref、reactive 、及改变数组的值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概况 Vue3 里要实现数据的响应式监听一共有两种方式既：ref 和 reactive
他们既有区别又有联系。
ref() ref数据响应式监听。ref 函数传入一个值作为参数，一般传入基本数据类型，返回一个基于该值的响应式Ref对象，该对象中的值一旦被改变和访问，都会被跟踪到，就像我们改写后的示例代码一样，通过修改 count.value 的值，可以触发模板的重新渲染，显示最新的值
reactive() reactive
reactive 是 Vue3 中提供的实现响应式数据的⽅法。
在 Vue2 中响应式数据是通过 defineProperty 来实现的，在 Vue3 中响应式数据是通过 ES6 的 Proxy 来实现的。具体参照，。
reactive 参数必须是对象 (json / arr)
本质: 就是将传⼊的数据包装成⼀个Proxy对象
如果给 reactive 传递了其它对象（如Date对象）
默认情况下，修改对象⽆法实现界⾯的数据绑定更新。
如果需要更新，需要进⾏重新赋值。（即不允许直接操作数据，需要放个新的数据来替代原数据）
在 reactive 使⽤基本类型参数
基本类型（数字、字符串、布尔值）在 reactive 中⽆法被创建成 proxy 对象，也就⽆法实现监听。⽆法实现响应式
&lt;template&gt; &lt;div&gt; &lt;p&gt;{{msg}}&lt;/p&gt; &lt;button @click="c"&gt;button&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import { reactive } from 'vue' export default { name: 'App', setup() { let msg = reactive(0) function c() { console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/582a5c956958b6ccacbe70e433c650cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a196b5fe166426a29a839a9577379dbb/" rel="bookmark">
			微信公众号接收事件推送问题：公众号内提示”该公众号提供的服务出现故障，请稍后再试“
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 根据文档设置事件接口 https://developers.weixin.qq.com/doc/offiaccount/Basic_Information/Access_Overview.html
问题 公众号内提示”该公众号提供的服务出现故障，请稍后再试“
解决方案 以laravel举例：
在设置的事件接口的最后使用以下代码：
echo ""; exit(); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa8bb4f2c505da5ce50f47461f863643/" rel="bookmark">
			win10下用powershell 启动vim编辑器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前提：已下载安装vim
以管理员身份运行powershell
在PowerShell中，输入命令 Set-ExecutionPolicy RemoteSigned 复制代码 输入Y[是] enter确认 复制代码 继续输入命令 new-item -path $profile -itemtype file -force 复制代码 进入显示的power shell目录中找到配置文件
添加一下文本内容
set-alias vim "此处为vim的安装路径" Function Edit-Profile { vim $profile } Function Edit-Vimrc { vim $HOME_vimrc } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bae51d3cc94275cd001cf23aff073d81/" rel="bookmark">
			欧拉图详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		欧拉图 欧拉图 定义： 欧拉回路：若存在一条从起点S出发的路径，每条边恰好只走一次，最终回到起点S的路径被称为欧拉路径。
欧拉通路：若存在一条从起点S出发的路径，经过每条边一次，但是不要求回到起点S的路径被称作欧拉通路。
每条路都走，而且只走一次，并且能回到起点的，是欧拉图，也称欧拉回路。
每条路都走，而且只走一次，不能回到起点的，是半欧拉图，也称欧拉路径。
判定方法： 前提：图都是连通图
无向图： 当一个无向图是欧拉图时，它的所有顶点的度数都是偶数，即它没有奇度顶点。
当一个无向图是半欧拉图时，它有且只有2个奇度顶点
有向图： 当一个有向图是欧拉图时，它的所有顶点都处于一个强连通分量中，并且出度=入度。
强连通分量：强连通分量指强连通分量中的任意两个点都有路径互相到达。
当一个有向图是半欧拉图时，它的所有顶点都处于一个强连通分量中，且：
最多只有一个顶点的出度与入度差为 1 。 最多只有一个顶点的入度与出度差为 1 。 所有其他顶点的入度和出度相同。 Hierholzier 算法（蓝书P409）时间复杂度O(n*m) (1)判断奇度数点，奇度数点若为 0 0 0则任意指定起点，奇度数点为 2 2 2则从指定其中任意一个。
(2)对于当前节点 x x x，扫描与 x x x相连的所有边，当扫描到一条边 ( x , y ) (x,y) (x,y)时，删除该边以及边 ( y , x ) (y,x) (y,x)，并递归 y y y。扫描完所有边后，将 x x x加入答案队列。
(3)倒序输出答案队列。
#include&lt;iostream&gt; #include&lt;cstdio&gt; using namespace std; const int maxn=1e5+5; const int maxm=1e5+5; struct edge { int to,nxt; }Edge[maxm&lt;&lt;1]; int head[maxn],Stack[maxm&lt;&lt;1],ans[maxm&lt;&lt;1]; bool vis[maxn&lt;&lt;1]; int n,m,tot=1,top,num;//tot一定要从1开始 void addedge(int x,int y) { Edge[++tot].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bae51d3cc94275cd001cf23aff073d81/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66acfc102999ecfe45564c5eef1a27bd/" rel="bookmark">
			拓扑排序详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		拓扑排序 定义 拓扑序列是在有向无环图（DGA）中，使得图中任意两个顶点 u , v u,v u,v，如果存在一条 u − &gt; v u-&gt;v u−&gt;v的边，在拓扑序列中 u u u一定出现在 v v v的前面，这种序列叫做拓扑序列，而这种排序的过程被称为拓扑排序。一个图中的拓扑序列不止一个，例如下图中的拓扑序列可以是 1 , 5 , 2 , 3 , 6 , 4 1,5,2,3,6,4 1,5,2,3,6,4或者 5 , 1 , 2 , 3 , 6 , 4 5,1,2,3,6,4 5,1,2,3,6,4等，但是 5 , 2 , 1 , 6 , 3 , 4 5,2,1,6,3,4 5,2,1,6,3,4就不是这个图的拓扑序列。
实现 Kahn 算法（O（n+m）） 前置知识：节点的度
从一个节点出去的边的条数被称为节点的出度，从一个节点进来的边的条数被称为节点的入度。
算法流程：
建立一个队列，将节点入度为零的点放入队列取出队首元素，将队首元素放入拓扑序列数组中扫描从队首元素出发的每一条边 ( x , y ) (x,y) (x,y)，将扫描到的点y的入度减一。如果该点的入度为0，则将该点入队重复2操作，直到队列为空 算法实现
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/66acfc102999ecfe45564c5eef1a27bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ffbc2f437d066bdb1ef0369d41a803c/" rel="bookmark">
			【疑难杂症】springboot新版本中使用springbatch的stepscope功能-引出bean注册报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【疑难杂症】springboot新版本中使用springbatch的stepscope功能-引出bean注册报错 内容 maven版本信息
&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.6.3&lt;/version&gt; &lt;/parent&gt; 对应springbatch版本 spring-batch-core-4.3.4 job配置示例xml：
&lt;bean id="t1000Tasklet" class="com.company.project.batch.handleTAccountInfoJob.T1000Tasklet" scope="step"/&gt; 报错日志：这里已分行显示，便于定位
Caused by: org.springframework.beans.factory.support.BeanDefinitionOverrideException: Invalid bean definition with name 't1000Tasklet' defined in BeanDefinition defined in class path resource [batch/job/user2job/steps/Step1.xml]: Cannot register bean definition [Root bean: class [org.springframework.aop.scope.ScopedProxyFactoryBean]; scope=; abstract=false; lazyInit=null; autowireMode=0; dependencyCheck=0; autowireCandidate=true; primary=false; factoryBeanName=null; factoryMethodName=null; initMethodName=null; destroyMethodName=null; defined in BeanDefinition defined in class path resource [batch/job/user2job/steps/Step1.xml]] for bean 't1000Tasklet': There is already [Generic bean: class [com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ffbc2f437d066bdb1ef0369d41a803c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32c4536bfabe543cd1c90350f992a8cb/" rel="bookmark">
			C&#43;&#43;学习笔记：三种智能指针【Share、Unique、Weak】【Cherno】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		老规矩，先问题后文章：
为什么要有智能指针以及它的好处是什么、智能指针是在怎么工作的、智能指针的操作；
1：为什么要有智能指针：
要知道，内存泄漏是非常严重的后果，如果new出来的空间没在合适的时间delete，那么很容易出现bug或者内存泄漏，而合适地用new和delete又是一个特别难的工作，所以C++就推出了智能指针这个概念，其是为了方便程序员管理内存。
大量使用智能指针代替new、delete函数，可以大大地提高程序的稳定性；
2：智能指针是怎么工作的：
个人理解为智能指针是将原始指针封装起来，并结合new、delete、一些必要的函数，因为有delete的参与，所以智能指针可以在适合的时候自动释放；
先介绍智能指针的两个主力：unique、share
unique：
我们先定义一个unique指针：
#include&lt;iostream&gt; #include&lt;string&gt; #include&lt;memory&gt; int main() { { std::unique_ptr&lt;int&gt; a = std::make_unique&lt;int&gt;(10); } } 为了某种目的，本菜用一个空作用域将指针围起来；
如果程序出了空作用域，那么系统会自动调用delete函数，将指针和其指向的内容给释放掉；
如果我们将a赋值给其他指向同类型的unique指针：
#include&lt;iostream&gt; #include&lt;string&gt; #include&lt;memory&gt; int main() { { std::unique_ptr&lt;int&gt; a = std::make_unique&lt;int&gt;(10); auto b=a; } } 报错：
因为unique的一个特征就是不能有两个指针指向同一个对象，这个特性也导致unique指针不能作为实参传入函数当中；
这种看似无法理解的机制是因为如果多个unique指针指向同一个对象，当其中一个unique指针被释放时，其对象也会被释放，也就是说其他指向这个对象的指针将成为野指针；
下面来看看智能指针自动释放的功能：
#include&lt;iostream&gt; #include&lt;string&gt; #include&lt;memory&gt; class temp { public: temp() { std::cout &lt;&lt; "Created" &lt;&lt; std::endl; } ~temp() { std::cout &lt;&lt; "Destroyed" &lt;&lt; std::endl; } }; int main() { { std::unique_ptr&lt;temp&gt; a = std::make_unique&lt;temp&gt;(); } } 运行结果：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/32c4536bfabe543cd1c90350f992a8cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3111cbd66a28bd9a04b7e15cfef3cf3/" rel="bookmark">
			Linux图形子系统之vblank事件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux图形子系统之vblank事件 引言1 使能vblank1.1 初始化1.2 使能vblank 2 传递vblank2.1缓存vblank2.2 发送vblank 引言 显示器显示图像数据的过程，一般从左上角，按从左至右、从上至下的方式扫描像素数据。一般每扫描一行，会切换到下一行的左侧，行与行之间的返回过程称为水平消隐；一帧图像扫描完成，要从图像的右下角返回到图像的左上角，开始新一帧图像的扫描，这一时间间隔，叫做垂直消隐，也称场消隐（vblank）。从右下角返回左上角的时间间隔内，可以通知驱动进行下一帧图像的送显，一般硬件进入vblank后（也就是扫描完一帧图像）会通过中断机制触发硬件的vblank事件，然后再由驱动提交软件的vblank事件。
1 使能vblank 1.1 初始化 在struct drm_device的模式设置初始化后需要调用drm_vblank_init初始化crtc的drm_vblank_crtc结构
1.2 使能vblank 软件使能 在drm_crtc_helper_funcs的atomic_enable/atomic_disable回调内调用drm_crtc_vblank_on/drm_crtc_vblank_off方法
硬件使能 在drm_crtc_funcs的enable_vblank/disable_vblank回调内实现开启/关闭硬件vblank中断相关操作
2 传递vblank 2.1缓存vblank 在drm_crtc_helper_funcs的atomic_flush回调内调用drm_crtc_arm_vblank_event方法，将state的even添加到struct drm_device的vblank_event_list中
2.2 发送vblank 在vblank的硬件中断函数中，通过drm_crtc_handle_vblank或drm_handle_vblank发送struct drm_device的vblank_event_list中事件
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5e189f9dff86fa5f1a5cc383d29df66/" rel="bookmark">
			tensorflow详细安装教程（Win10, Anaconda，Python3.9）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		tensorflow详细安装教程（Win10, Anaconda，Python3.9） 文章目录 tensorflow详细安装教程（Win10, Anaconda，Python3.9）1.tensorflow版本的准备工作1.1 CPU版本，无需额外准备1.2 GPU版本，需要提前下载cuda和cudnn 2.下载Anaconda2.1 下载并安装Anaconda2.2 创建环境 3.测试tensorflow-gpu是否安装成功 1.tensorflow版本的准备工作 CPU版本和GPU版本的区别主要在于运行速度，GPU版本运行速度更快，所以如果电脑显卡支持cuda，推荐安装gpu版本的。
操作并不复杂，一开始我觉得要下这么多东西，感觉很麻烦，不想搞，但为了速度，最后还是尝试安装了一下，发现并没有那么难搞。
1.1 CPU版本，无需额外准备 CPU版本一般电脑都可以安装，无需额外准备显卡的内容。
1.2 GPU版本，需要提前下载cuda和cudnn 根据网页在 Windows 上安装 TensorFlow (juejin.im)的说明，需要满足以下四个条件。
查看电脑的显卡，此电脑→右键选管理→设备管理器→显示适配器。
核显UHD Graphics 630和独显GeForce GTX 1050，主要看独显GeForce GTX 1050。
选中NVDIA GeForce GTX 1050右键选属性→驱动程序，可以看到已经装好驱动。满足四个条件之一。 查看CUDA Compute Capability，网址CUDA GPUs | NVIDIA Developer。将部分内容截图，可以看到GeForce GTX 1050的Compute Capability是6.1满足四个条件之一。
查看电脑的CUDA版本。图标处右键NVDIA控制面板→系统信息→组件，红框中，可以看到CUDA的版本是11.1。
下载cuda和cudnn。在官网上下载对应的cuda和cudnn，版本可以低于但不能高于电脑支持的版本。cuda下载地址：CUDA Toolkit Archive | NVIDIA Developer，cudnn下载地址：cuDNN Archive | NVIDIA Developer
我下载的是CUDA Toolkit 11.0.0，选择相应的系统、版本等选项，Download安装包。
下载对应版本的cuDNN。这里选择的是cuDNN v8.0.5 for CUDA 11.0。
CUDA安装：选自定义安装→默认安装路径→安装结束
安装完成后，会默认生成两个系统变量。
系统变量查看：此电脑→右键选属性→高级系统设置→环境变量→系统变量 这里可以在系统变量中找到path，然后编辑，添加一些路径，最终一共有四条，以后如果有需要再添加额外的路径，都可以到这里添加。 cuDNN安装：解压→将三个文件夹复制到cuda的安装目录下，直接选择覆盖文件就可以。 安装完毕，测试cuda版本。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d5e189f9dff86fa5f1a5cc383d29df66/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53bafd79901356d31471450ea59cce8d/" rel="bookmark">
			JVM知识总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JVM知识点总结 什么是jvm
jvm就是java虚拟机，本质上是一个程序虚拟机。所以我们首先得搞懂什么是虚拟机，虚拟机是在操作系统上层的一款软件，分为程序虚拟机和系统虚拟机，程序虚拟机就是用于执行程序的，系统虚拟机可以用于模拟一台物理设备。jvm是一台程序虚拟机用于执行字节码文件。
jvm怎么工作的
程序首先经过词法分析，分析出关键字，变量和常量，接着进行语法分析分析出程序执行的语法树。接着生成字节码文件。字节码文件就是java程序和虚拟机之间沟通的桥梁。jvm的主要构成部分分为三层分别为类加载层，运行时数据区和执行引擎。jvm通过解析字节码文件将文件中的类加载到内存模型中再通过执行引擎执行这些程序得到结果。
生命周期
jvm的生命周期分为启动，运行和结束三个流程。在启动阶段由虚拟机指定一个初始类进行加载，在加载初始类的过程当中会涉及到很多类的加载比如说这个类的父类，父接口，这个类引入的类以及这个类执行需要依赖的类等等。执行阶段可以看做是虚拟机进程执行的过程。结束阶段可以是java程序运行结束虚拟机结束工作，调用系统结束函数结束，程序抛出异常结束，系统抛出异常结束等。
特点
特点上我们主要关心虚拟机基于什么样的指令集设计的，程序虚拟机的设计有两种一种是基于栈指令架构设计的，一种是基于寄存器架构设计的。基于栈指令设计的虚拟机的特点在于设计简单易于实现，指令一般比较短实现代码需要用到更多的指令；这种架构适用于内存受限或者跨平台性较强的虚拟机。基于寄存器架构实现的虚拟机的优点在于执行的速度特别快，缺点在于存在寄存器分配的难题和跨平台性比较差。它使用的指令集一班比较长所以完成程序所需要的指令一般比较少。
常见的java虚拟机
常见的java虚拟机我们分为三类来认识。第一类是比较古老的虚拟虽然已经不在使用但是设计思想值得借鉴，这类虚拟机有Classic Vm和Exact Vm 前者是java1.0所使用的的虚拟机特点是只支持解释器不支持即时编译器，后者两者都支持，Exact VM也称之为准确内存管理的虚拟机，它使用句柄的形式来管理对象这样可以快速找到对象的类型以及存储的位置方便垃圾的回收。第二类虚拟机是现在正在使用的虚拟机首当其冲就是Oracle公司的HotSpot虚拟机这个是当下使用最广的虚拟机，接着就是J9它是Google公司研发的特点就是在谷歌自己的软件1上面运行比较稳定但是在其他软件的运行上容易出现bug所以现在一班是google内部使用。第三款就是JRocket虚拟机它一班使用在服务器端，号称运行速度最快的虚拟机，它只支持即时编译器。接着第三类就是平台依赖性比较强的虚拟机分别有Alibaba字眼Taobao Vm和微软的SoftWare VM以及Liquid Vm。等等。
jvm内存模型 jvm的内存模型主要分为类加载层，运行时数据区和执行引擎三层，类加载层主要负责识别、验证和加载字节码文件中的各个类。运行时数据区主要用于加载运行java程序运行时的各个内存结构，执行引擎主要负责执行操作内存中的各个结构运算出程序的结果。
类加载层 类加载器的作用 类加载器的作用就是，通过一个类的全限定名来找到一个类（这个类可以在文件系统中，可以是被压缩的，可以是在网络中，甚至可以是现在生成的通过代码生成的，通过其他格式转化来的（JSP），通过数据库存储和在加密文件中获取的）接着需要以字节流的方式读取这些类的信息，将这些信息转化问运行时数据区中方法区的一个类并且创建一个java.lang.Class用于获取这些类的信息。
类加载的过程 类加载的过程主要分为三个步骤：
①加载：
类加载过程主要是负责通过全限定名获取类并且通过字节流的形式获取类的字节码文件并且转化为方法区中的一个类并生成java.lang.class来访问类的信息
②链接*************
链接的过程主要分为三个步骤验证，准备和解析。
验证主要是验证主要是保证所加载的类是符合虚拟机要求的在加载之后不会危害虚拟机的安全，主要是验证字节码文件的格式，字节码验证，符号应用验证和字面量验证。
准备主要是给所有的static变量附初始值的过程，需要注意的是final关键字声明的是常量在字节码的编译阶段就已经完成，也不是实例变量实例变量的初始化是在调用构造方法的时候确定的
解析阶段要做的是主要是将字节码中的一个符号引用转化为一个真是引用的过程，符号引用就是规定当前的引用所要引用的位置，真是引用可以是一个指针，句柄或者是一个偏移量。解析主要针对的是类，接口，字段，类方法，接口方法，或者是方法类型。这个过程可能会混合着初始化一起执行。
③初始化
初始化的过程主要是执行类中的静态代码快或者赋值操作的方法，它执行的其实是方法，它由javac编译器自动自动收集而来。
类加载器的分类和使用 分类：
在java虚拟机规范中类加载器主要分为引导类加载器和用户自定义类加载器（扩展自ClassLoader抽象类）两种。但是日常我们的分类主要有引导类加载器，扩展类加载器应用程序类加载器，用户自定义类加载器四类。引导类加载器是使用C++写的一个用于整个系统引导启动的类加载器，它主要用于加载一些比较基础的类比如说String，Object这些我们在程序中不用引入就可以直接使用的类。扩张类加载器主要用于引入java扩展包下的类java.ext.dirs和java.lib.ext。应用程序类加载器加载了大部分我们锁编写的类它加载java.class.path或者环境变量classpath中定义的路径的类。自定义类加载器的使用主要目的是隔离我们自己所定义的类，改变类加载过程，扩展类的加载源或者防止我们的类泄露。
使用：
ClassLoader介绍：
ClassLoader是一个抽象类，其中定义了我们类加载的逻辑所有自定义类加载器都扩展自它。其中定义的方法主要有获取父类，loadClass中定义了双亲委派机制，findClass遍历与我们自动的扩展类，findLoadClassLoader用于寻找本了的类加载器，还有一些用于动态加载类的方法和动态链接类的方法。
如何自定义
我们需要如何自定义类加载器呢，我们指导1java中所有的自定义类加载器都扩展自ClassLoader。所以我们自然的需要去继承这个类，该类中有两个方法用于方便我们自定义类加载器，java1.2之前的做法是重写loadClass方法，但是1.2之后不推荐这样做而是提供了findClass方法方便我们扩展类，如果我们不需要特殊的操作其实完全可以去继承URLClassLoader来完成自定义类加载器。
获取类加载器：
获取类加载器的方式有很多，比如我们可以通过getClassLoader方法来获取类的加载器，可以通过Trread.currentThread.getContextClassLoader用于获取线程上下文类加载器，可以通过ClassLoader.getClassLoader用于获取系统类加载器，用DriverManager.getCallerClassLoader获取调用这个类的类加载器。
双亲委派机制 什么是双亲委派机制
java加载一个类的时候是按需加载的当需要一个类的时候才回去加载它。双亲委派机制就是当一个类加载器获得类的加载请求的时候并不是自己加载而是寻找父类加载器来加载直到顶到引导类加载器。然后逐级往下指导找到一个能够加载这个类的类加载器为止。
优点
优点就是保证了沙箱安全机制，让基础的类优先加载而保证整个程序的正常运行。而且还可以避免类的重复加载。
如何打破
其他琐碎的内容 java中如何唯一识别一个类
java中识别一个类的方式是完全限定名加上类加载器，java在将一个类放入到方法区的时候会将类加载器的引用都当做是类型信息的一部分一起存储。
java中的类的使用分为主动使用和被动使用两种被动使用不会触发类的加载机制
运行时数据区 运行时数据区概述
内存是十分重要的资源，时磁盘和CPU之间的桥梁和中间仓库，承载着操作系统和应用程序的实时运行。jvm内存布局规定了java程序运行过程当中的内存申请，分配和管理。但是不同的虚拟机实现有所不同我们只需要了解最为通用经典的jvm内存布局，jvm的内存布局统称为运行时数据区。
运行时数据区的内存布局
运行时数据区分为堆，栈，本地方法栈，方法区（元空间）和程序计数器。其中堆和方法区是线程共有的其他的各个部分是线程私有的。
运行时数据区的监控
Runtime类用于表示此时内存中实时环境。
程序计数器 程序计数器是什么
程序计数器是内存中很小的一块内存空间，当执行的是一个java方法用于存储下一条需要执行的字节码指令当执行的的是一个本地方法它存储的就是空值
特点
程序计数器是线程私有的，它随着线程的创建而创建随着线程的销毁而销毁，程序计数器也是vm内存布局当中唯一没有垃圾回收和内存溢出的区域
常见的两个问题
栈 栈是什么：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/53bafd79901356d31471450ea59cce8d/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/278/">«</a>
	<span class="pagination__item pagination__item--current">279/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/280/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>