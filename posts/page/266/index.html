<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25ed4f156988e12a63881a4b9f88e00a/" rel="bookmark">
			解决idea运行maven项目报错:Unresolved plugin:*未解决的插件：
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		然后就在settings里面找maven，然后设置local repository：路径不能有空格
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ee01fbe485ce6f3f7fcc8c4b7ce7733/" rel="bookmark">
			Linux 下开发基于 webrtc 的实时音视频 SDK本文
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		内容简介：在 Linux 平台下开发实时通话 SDK 其实是主要应用于未来的 IOT 行业，先基于 Ubuntu 作为开发平台，完成后再基于每个客户提供的其交叉编译工具链进行交叉编译以供用户使用。如果是自己下载编译的话，可以参考官方教程，或者参考本人之前的一篇博客：那么可以通过下载本人配置的一个 Docker 镜像进行进行编译： 在 Linux 平台下开发实时通话 SDK 其实是主要应用于未来的 IOT 行业，先基于 Ubuntu 作为开发平台，完成后再基于每个客户提供的其交叉编译 工具 链进行交叉编译以供用户使用。
1、基于 Ubuntu 下载 webrtc 1.1 自行下载编译 如果是自己下载编译的话，可以参考官方教程，或者参考本人之前的一篇博客： https://www.jianshu.com/p/09f065f3feb0https://www.jianshu.com/p/09f065f3feb0 ，其实 Ubuntu 下编译 webrtc 是比较简单的，只要可以翻墙，其它都只是时间问题了。
1.2 国内网络问题无法自行下载 那么可以通过下载本人配置的一个 Docker 镜像进行进行编译： Docker Hub ，由于 Docker 不适合作为开发环境，下载后，建议用户将 develop 目录下的文件拷贝到自己的开发环境中，并参考 https://www.jianshu.com/p/09f065f3feb0 配置相关环境变量，实现本地编译,过程主要包含 3 步：
1.3 配置 depot_tools 环境变量 将 export PATH=$PATH:/home/gobert/develop/depot_tools 添加到 /etc/profile 文件尾部；
1.4 安装 GoLang 并配置环境 1.5 安装 Linux 依赖包 执行 webrtc 目录下的 /build/install-build-deps.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ee01fbe485ce6f3f7fcc8c4b7ce7733/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a90a309a16533054c4388688e2af05b/" rel="bookmark">
			nodejs实现微博第三方登录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 实现效果具体实现一、申请weibo网站接入二、点击按钮微博登录1. 生成微博登录授权验证码2. 授权页面跳转，获取用户code3. 后端登录回调接口，通过用户code获取accessToken，再通过accessToken获取用户信息,完成登录 三、微博扫码登录1. 生成微博扫码登录二维码2. 前端不停轮询，查询此二维码是否被扫码授权 接入微博第三方登录可以免注册,对用户的体验更好，今天我们就用nodejs实现微博第三方登录(用其它语言也可以)。 实现效果 在线实例: http://www.lolmbbs.com/login
点击微博登录按钮登录
直接扫码登录
具体实现 一、申请weibo网站接入 登录https://open.weibo.com/connect申请web网站接入
本地开发的时候应用地址写:127.0.0.1
二、点击按钮微博登录 采用OAuth2.0授权,详细可参考文档https://open.weibo.com/wiki/Connect/login
1. 生成微博登录授权验证码 const weiboUrl = `https://api.weibo.com/oauth2/authorize?client_id=${weiboConfig.appKey}&amp;response_type=code&amp;redirect_uri=${weiboConfig.redirectUrl}` appKey: 创建应用成功后weibo给你的appKey
redirectUrl: 用户授权成功后跳转的你的前端页面，我这里写的是http://127.0.0.1:8080/login
2. 授权页面跳转，获取用户code 用户授权登录后，会跳转到你上一步写的redirectUrl,并带上用户code,url类似于http://127.0.0.1:8080/login?code=abcdef
vue监听路由url，如果url上有code就去请求后端的登录回调接口
created() { const { code } = this.$route.query; if (code) { loginCallback({ code }).then((res) =&gt; { this.$message({ message: `${res.nickname} 欢迎您`, type: "success", }); this.setUser(res); this.$router.push("/tool/qr"); }); } } 3. 后端登录回调接口，通过用户code获取accessToken，再通过accessToken获取用户信息,完成登录 async loginCallback(ctx) { let { code } = ctx.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a90a309a16533054c4388688e2af05b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c001cd72af561163b86dc9b5e3529921/" rel="bookmark">
			使用OpenCore引导黑苹果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.OpenCore简介 笔者在17年写过一篇黑苹果安装教程：黑苹果系统安装通用教程(Clover引导)，不过该文章用的是基于Clover引导的MacOs系统。目前随着黑苹果的另一款引导工具OpenCore不断成熟，使用OC是大势所趋。众多黑苹果驱动的作者已经停止对Clover的兼容支持，改向Opencore的兼容。OpenCore是类似于Clover的UEFI的引导器，OpenCore提供了详细的日志系统，帮助黑苹果排错；其次OpenCore以更先进的方法注入第三方Kext，不破坏系统的SIP；再次，OpenCore支持读取NVRAM等一系列特性，可以让黑苹果变得更“原生”，诸如选择启动器、Command Ctrl互换，原生开启Option键特性都可以实现。
二.OpenCore引导MacOS 🦮第一步 准备工作 一个8G以上的U盘。MacOS系统镜像包、Etcher（刻录工具）、DiskGenius（分区工具）、适合自己电脑的EFI驱动文件。 🐕‍第二步 确认硬盘分区表格式 黑苹果的安装和使用需要EFI分区进行引导，因此安装黑苹果的硬盘必须使用GPT分区表，如果您的磁盘使用的是MBR分区表，那么需要先将硬盘数据进行备份，然后使用分区工具将硬盘重新使用GPT分区表分区。可以通过下文提供的两种方法或者通过DiskGenius 看看分区表是否为GPT分区表。
方法一：使用磁盘管理查看MBR和GPT分区类型 鼠标右击此电脑，点击**“管理”**。
在计算机管理中点击**“磁盘管理”**。
进入磁盘管理可以看到磁盘分区情况，右键点击**“磁盘0”选择查看“属性”**。
在属性界面，点击**“卷”就可以看到此磁盘的基本信息了，我们可以在“磁盘分区形式”看到磁盘0为GPT**磁盘分区类型，如何查看硬盘分区是MBR还是GPT问题轻松解决。
方法二：使用命令提示符查看MBR和GPT分区类型 按**“Windows + R”键，在弹出的运行对话框中输入“diskpart”，并按回车**键启动diskpart实用程序。
输入**“list disk”命令，然后按回车**，查看磁盘信息。
在命令行中的**“Gpt”**列下方，带有一个星号（）为GPT磁盘类型。没有星号（）为MBR磁盘类型。所以上图中，磁盘0为GPT磁盘类型，磁盘1为MBR磁盘类型，如何查看硬盘分区是MBR还是GPT问题轻松解决。 🐆第三步 MBR分区表转换成GPT分区表 如果硬盘分区是GPT分区表可以略过这一步操作。如果硬盘分区不是GPT分区表。那么你需要将硬盘数据进行备份，然后使用分区工具对硬盘重新分区。微软官方有MBR转GPT的教程。也可以进入到PE下打开DiskGenius分区工具，选定硬盘然后将硬盘分区表转换成类型为GUID-也就是GPT分区表。
🦌第四步 硬盘划分安装MacOS分区 通常我们在安装黑苹果系统的场景有如下两种：
整盘安装：在电脑中存在多块硬盘的条件下，选择某块硬盘单独作为Mac系统的安装盘。并且将苹果系统的引导文件放到该硬盘下，这样可以和其他的系统独立起来使用，此时你需要在该硬盘上新建EFI分区存放黑苹果引导文件。你可以使用分区工具自行创建，需要注意的是，EFI分区需要大于200M。
分区安装：在一块已经装有 Windows（或其它操作系统）的硬盘上安装 MacOS 系统的磁盘为基础，通过压缩磁盘空间划出的一个新的分区用来安装Mac系统。此时你可以直接使用已有的EFI分区，并将MacOS引导文件复制于此。
整盘安装(多硬盘多系统) 黑苹果的安装和使用需要EFI分区进行引导，因此在对硬盘进行GPT分区的同时，需要创建新的空白分区并格式化为EFI分区格式。可以使用 DiskGenius，在你要安装 MacOS 的空闲硬盘分出两个区，其中一个区需要为 FAT16/FAT32 格式，且大小大于 200MB即可用来放置EFI引导文件，另一个分区用来安装黑苹果系统。
分区安装(单硬盘多系统) 如果你的电脑已经安装了 Windows 系统且预留的 ESP 分区大于200MB，那么无需任何操作，直接划分一个黑苹果的安装分区进行安装系统既可，如果ESP 分区小于 200MB，那么你需要扩大 ESP 分区，或重建 ESP 分区。这一步需要在 Windows PE 环境下操作，请首先刻录好Windows PE U盘。
需要将已有的 ESP 分区删除，然后再磁盘末尾空闲空间重建一个 200M 以上的 ESP 分区（你可以从你准备安装 MacOS 的那部分空间中划分出来一些），操作完成后你的分区结构会类似下图（Windows 在前，200m+ 的 ESP 分区和 MacOS安装分区在后）。然后按下文的指引重建引导。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c001cd72af561163b86dc9b5e3529921/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a30f5248f4656ef5f74d4d404db45788/" rel="bookmark">
			c&#43;&#43;面试题（亲测常问）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 注意：此题为我自己面试被问到的，及一些摘抄的，如有侵权请联系我马上删除！
1.
2.
32位指针地址所占字节数为四
举例说明：
char*p;
char test[10];
p=test;
sizeof(p)=4(32位系统) //实质是求指针类型所占字节数，32位对应4字节，64位对应8字节
sizeof(*p)=1 //实质是求指针所指的内容所在字节数，*p=char[0],当然所指内容大小等于1字节
sizeof(test)=10 //虽然数组名test指向第一个数char[0],但是sizeof()会读到数组末尾截止，因此sizeof(test)=10。之前误以为sizeof(test)就是求char[0]的大小，sizeof(test)=1
3.
4.
switch的参数不能为实型。
注：必须是整数型常量，包括char，short，int，long等，不能是浮点数。
整型常量
在C语言中，整型常量分为十进制整型常量、八进制整型常量和十六进制整型常量三种表示形式。
以上三种进制的常量可用于不同的场合。大多数场合中采用十进制常量，但当编写系统程序时，如表示地址等，常用八进制或十六进制常量。
一般情况下，编译程序会根据常量的数值分辨出常量是int还是long int类型。
实型常量
实型常量有两种表示形式：一种是十进制小数形式，另一种是指数形式。
5.
6.
7.
8.
9.
10.
在c++程序中调用被C编译器编译后的函数，为什么要加extern“C”
C和C++的函数符号生成规则不一样。C++调用C语言，由于符号的生成规则不同会导致符号解析出错。使用extern C告诉C++编译器用C语言的规则生成符号
11.float x 如何与0值比较
const float EP = 0.000001;
if ((x &gt;= - EP) &amp;&amp; (x &lt;= EP) )
12.
13
14.
15
16
17
Int型指针指向char数组
18
stl基础定义
19
20.
进程和线程的区别和其使用等
21
智能指针 分割线---------------------------
重要！！！ 上面几个问题不太包含 stl和算法 stl也是c+基础 要重视其中的函数例如sort pair类型等等 此外排序 查找的算法要会几个 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9645ed261bf06d7c09d12839d6582bb2/" rel="bookmark">
			Appium—UIAutomator 查找元素
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 优缺点 优点 xpath 定位速度慢UIAutomator 是 Android 的工作引擎，速度快滚动查找很方便缺点 表达式书写复杂，容易写错 IDE 没有提示 定位方式 通过 resource-id 定位通过 classname 定位通过 content-desc 定位通过文本定位组合定位通过父子关系定位 用法 driver.find_element_by_android_uiautomator("表达式")注：外层要用单引号，内层的字符串用双引号，因为本来就是 Java，Java 双引号才表示字符串通过文本定位 new UiSelector().text("text文本")通过 textContains 模糊匹配 new UiSelector().textContains("text文本")通过某个文本开头匹配 new UiSelector().textStartWith("text文本")正则表达式匹配 new UiSelector().textMatches("text文本")组合定位 比如 id 与 text 的属性组合：driver.find_element_by_android_uiautomator('new UiSelector().resourceId("com.xueqiu.android:id/login_account").text("我的")')父子关系定位:childSelector，先定位到父类，再用 childSelector 来定位子类 driver.find_element_by_android_uiautomator('new UiSelector().resourceId("com.xueqiu.android:id/login_account").childSelector(text("股票"))')兄弟定位：fromParent driver.find_element_by_android_uiautomator('new UiSelector().resourceId("com.xueqiu.android:id/login_account").fromParent(text("股票"))') 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88bf5f7f5d89c4773a8f2832e1d5532e/" rel="bookmark">
			vba编写人事组织结构树形图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、程序界面
1、查询，查询某员工的人事信息
2、添加，添加新的公司、部门、员工信息
3、修改，修改已存在节点的名称
4、删除，删除选中的节点，节点下如有子节点，应先删除子节点
5、导出，将人事组织结构信息以excel格式导出
二、vba程序代码
'一、窗体初始化
Private Sub UserForm_Initialize()
Dim arr, r As Integer, i As Integer
Dim c1, c2 'c1,c2分别用来存放项目名称和代码
Dim iNode As Node
arr = Sheets("sheet1").Range("A1").CurrentRegion
r = UBound(arr, 1)
Me.TreeView_人事组织结构树.ImageList = Me.ImageList_图标集 '获取图标
For i = 2 To r Step 1
c1 = arr(i, 1)
c2 = arr(i, 2)
If VBA.Len(c2) = 1 Then '是总公司
Set iNode = Me.TreeView_人事组织结构树.Nodes.Add(, , "A" &amp; c2, c1 &amp; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/88bf5f7f5d89c4773a8f2832e1d5532e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3dc646c41cf8a6b0a22ba3c2bd9487a3/" rel="bookmark">
			Cocos Creater 发布mobile 并部署在IIS服务器上出现过的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、MIME类型
① 增加 .wase applicaiton/octet-stream
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34f7bdc7241f17daf6e6218571cc9419/" rel="bookmark">
			使用 recordRTC 实现web 端音视频录制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		相信大家在线上笔试过程中，都曾有经历过必须打开摄像头的过程。
其背后究竟是什么东西发挥了作用呢？ 这期请跟随艾米栗的思路。了解一下。
一、webRTC 的历史
可阅读：
webrtc 官网：https://webrtc.org/getting-started/media-devices
webrtc 中文版官网： 基础知识 | WebRTC中文网-最权威的RTC实时通信平台
MDN 关于 webrtc 的介绍： WebRTC API - Web API 接口参考 | MDN
这一部分内容我不做展开介绍。因为我也只是简单的使用者。
针对其很多功能点，下面这个网址，描述的更加清晰：
针对其很多功能点， 介绍 | 给好奇者的WebRTC
二、recordRTC 和 webRTC 的关系
webRTC API 是 web 端进行实时数据流传输的基石。但由于其 API 的多样，针对不同的场景，其他贡献者们做了有效封装，recordRTC 就是其中一个。 其基于 webrtc 的 getUserMedia API 实现媒体设备访问， 并对 webrtc提供的视频流函数进行了封装， 使开发者可以简单函数调用就能实现视频录制。
这一点可以在 webrtc 的文档和 recordRTC 的代码中印证。
三、如何使用 recordRTC
从 recordRTC 的官网，摘取了使用 recordRTC 进行录制 demo：
// 这个 getUserMedia 是 webrtc 出品的获取媒体设备的 api。 let stream = await navigator.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/34f7bdc7241f17daf6e6218571cc9419/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6436bc97bfac59717c6f05734ab4d0ee/" rel="bookmark">
			vue组件中的data为什么是 函数，而不是对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		new Vue() 和component组件中使用
在 new Vue() 中，data 是可以作为一个对象进行操作的，然而在 component 中，data 只能以函数的形式存在，不能直接将对象赋值给它。
new Vue({ el: '#app', data: { message: 'Love' }, template: '&lt;p&gt;It’s great to love cakes.&lt;/p&gt;' }) // 因为组件是可复用的 Vue 实例 // 定义一个名为 button-counter 的新组件 Vue.component('button-counter', { data: function () { return { count: 0 } }, template: '&lt;button v-on:click="count++"&gt;You clicked me {{ count }} times.&lt;/button&gt;' }) data为什么是函数, 不是对象?
这并非是 Vue 自身如此设计，而是跟 JavaScript 特性相关，我们来回顾下 JavaScript 的原型链
var Component = function() {}; Component.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6436bc97bfac59717c6f05734ab4d0ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0cb68d16a246450d5ecaffc1251820e9/" rel="bookmark">
			Error: could not find function “%＞%“
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 当您尝试在 R 中使用“ %&gt;% ”函数而不首先加载dplyr包时，通常会发生此错误。
要修复此错误，您只需先加载 dplyr 包：
library(dplyr) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0eaa1a91f1308f4a0f267a23ec084130/" rel="bookmark">
			阿里云服务器安装Nginx
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		阿里云服务器安装Nginx
使用远程连接工具（我用的时Xshell）连接到我的阿里云服务器安装nginx之前要安装需要的依赖（pcre,zlib,openssl） 分别官网下载，下载时最好都下载.tar.gz结尾的，方便后面安装
1. 在Xftp上连接阿里云服务器，之后再root目录下创建software目录（可自行其它创建）
2. 之后将步骤2下载好的四个安装包拖到software目录中
3. 先检查服务器有没有c++编译环境（服务器好像一般自带有），还没安装的话，通过以下命令完成安装
yum install gcc-c++ 4. 安装pcre
（1)找到阿里云服务器存放prce.tar包的位置（我的目录是在/root/software/下）
cd /root/software （2)解压
tar zxvf pcre-8.45.zip 发现会报下面红框中的错，原因是安装包不是.tar.gz类型的，所而是.zip类型，所以不能用tar 命令来解压，需要用到对应的unzip命令来解压
但是服务器没有unzip，所以需要先下载，
yum install unzip 再用以下命令解压即可
unzip pcre-8.45.zip （3）进入到解压目录
cd pcre-8.45.zip/ （4）执行
./configure （5）使用 make &amp;&amp; make install进行编译安装
（6）可以使用pcre-config --version查看pcre的版本。
4. zlib的安装 （zlib的安装和pcre类似，这里就不再详细介绍了)
tar zxvf zlib-1.2.11.tar.gz cd zlib-1.2.11 ./configure make &amp;&amp; make install 5. openssl的安装 （openssl的安装和pcre类似，这里就不再详细介绍了)
最后一步 make &amp;&amp; make install 的过程相对有点久，耐心等待
tar zxvf openssl-1.0.1j.tar.gz cd openssl-1.0.1j .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0eaa1a91f1308f4a0f267a23ec084130/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/194648f851e494c19b0c387ff32f7513/" rel="bookmark">
			The requested URL /phpMyAdmin/ was not found on this server.解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写此篇文章的目的是为了解决打开phpmyadmin显示404的问题。
问题：
点击phpStudy 2018 PHP-5.4.45 的MySql管理按钮的时候直接报错找不到 服务。如图：
出现以下情况：
Not Found The requested URL /phpMyAdmin/ was not found on this server. 解决办法：
1.点击其他选项菜单—&gt; 打开配置文件—&gt;vhosts-ini文件。
2.记住下面这个路径（注：每个人的不一样）。
3.在WWW文件夹下查看是否有phpMyAdmin文件夹，如果有的话复制phpMyAdmin文件夹（也可以剪切）；
如果没有的话则需要去官网下载，从官网上下载安装phpMyAdmin,网址为https://www.phpmyadmin.net/downloads/，下载完以后解压到网站根目录下，修改文件名为phpMyAdmin，然后剪切即可。
4.把phpMyAdmin文件夹粘贴到第二步vhosts-ini文件中的那个路径所在位置下即可。如图：
效果图如下：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/707f1f35c5f195454087fbe87ec606ba/" rel="bookmark">
			论文投稿-2022 CCF会议截稿时间一览
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		A类会议 会议简称会议全称截稿时间会议时间官方网址CVPR2022IEEE Conference on Computer Vision and Pattern Recognition2021.11.162022.6.21http://cvpr2022.thecvf.com/IJCAI2022International Joint Conference on Artificial Intelligence2022.1.72022.7.23https://ijcai-22.org/ICML2022The Thirty-ninth International Conference on Machine Learning2022.1.272022.7.17https://icml.cc/Conferences/2022/ACMMM2022ACM International Conference on Multimedia2022.4.72022.10.10https://2022.acmmm.org/NIPS2022Thirty-sixth Conference on Neural Information Processing Systems2022.5.132022.11.28https://neurips.cc/Conferences/2022AAAI2023AAAI Conference on Artificial Intelligence2022.8.152023.2.7https://aaai.org/Conferences/AAAI-23/ B类会议 会议简称会议全称截稿时间会议时间官方网址ICRA2022IEEE International Conference on Robotics and Automation2021.9.142022.5.23https://www.icra2022.org/AAMAS2022International Joint Conference on Autonomous Agents and Multi-agent Systems2021.10.22022.5.3https://aamas2021.soton.ac.uk/ICME2022IEEE International Conference on Multimedia &amp; Expo2021.12.122022.7.18http://2022.ieeeicme.org/index.htmlECAI2022European Conference on Artificial Intelligence2022.1.72022.7.23https://ijcai-22.org/UAI2022International Conference on Uncertainty in Artificial Intelligence2022.2.252022.8.1http://auai.org/~w-auai/uai2022/ECCV2022European Conference on Computer Vision2022.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/707f1f35c5f195454087fbe87ec606ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e8b3457ac3984b8433ba6612d7f3f30/" rel="bookmark">
			Android 开发日记-RecycleView
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简单列表实现 在app开发中列表肯定是最常见的样式，这里记录一下Android是如何使用RecyclerView创建动态列表的
类比一下 RecyclerView 相当于 iOS 中的 UITableView和UICollectionView
RecyclerView RecyclerView 可以让您轻松高效地显示大量数据。您提供数据并定义每个列表项的外观，而 RecyclerView 库会根据需要动态创建元素。
顾名思义，RecyclerView 会回收这些单个的元素。当列表项滚动出屏幕时，RecyclerView 不会销毁其视图。相反，RecyclerView 会对屏幕上滚动的新列表项重用该视图。这种重用可以显著提高性能，改善应用响应能力并降低功耗。
RecyclerView 总的来说是列表元素的容器，然后复用View节省内容，提高性能。
RecyclerView 想要显示内容需要设置两个关键属性 layoutManager 和 adapter
// 获取 recyclerView recyclerView = findViewById(R.id.content_recycleview) // 设置布局方式 recyclerView.layoutManager = LinearLayoutManager(this, RecyclerView.VERTICAL, true) // 绑定 adapter recyclerView.adapter = textAdapeter LayoutManager LinearLayoutManager 线性布局，支持横向和纵向滑动，还可以翻转布局，翻转真的是适合做聊天室，因为翻转后布局的最后一条显示在屏幕的最下方。这一点iOS望尘莫及啊！GridLayoutManager 二维网格排列，这个和 iOS 的 UICollectionView 的排列就很像了，没啥可说的。StaggeredGridLayoutManager 和上面类似，但是同一列元素的高度可以不一样，不知道这个可不可以做瀑布流。 RecyclerView.Adapter 和 RecyclerView.ViewHolder Adapter 用 iOS 的话说就是 UITableView 的 dataSource 了
ViewHolder 持有 itemView, 也就是相当于给 Cell 包装了一层
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e8b3457ac3984b8433ba6612d7f3f30/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25b605776a9b089b0925769e491be530/" rel="bookmark">
			CSDN积分获取
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CSDN对于新手积分获取的方式太少了，找了好多方法都不管用了
下面是我总结的几个简单的方法
①、写博客，一篇十分，这也是我写这个博客的最初目的。转载貌似是2分
②、评论，这个我试了下没有分，可能是延迟到账。。
③、会员，只能大额量充值，太坑。
④、绑定手机，送50分。
比较简单方便的应该就这些了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b858732fed988f6bb6a73983afe4ee69/" rel="bookmark">
			vue echarts 使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.在vue项目终端使用npm安装 npm install echarts --save 2.在需要使用echarts的地方导入 import echarts from "echarts"; 3.准备一个div 给上高度宽度 还有id &lt;div id="Echart"&gt;&lt;/div&gt; 高度宽度 我没有写入style 所以这里没有
4.在methods里面定义一个方法 我是定义的drawChart drawChart(){ let myChart = echarts.init(document.getElementById("Echart")); let option = { } // 使用刚指定的配置项和数据显示图表。 myChart.setOption(option); //option 自己配置echarts的参数 名字可以自己定义 }, 5.然后在mounted里面调用这个方法 mounted(){ this.drawChart(); }, 说明： 用id去获取dom元素 使用 echarts.init注册 ， 然后自己需要什么echarts的配置，自己配就好了，我这里没有写出来，然后用注册的dom元素使用setOption就出来图表了。
PPChart - 让图表更简单 可以使用这个网站去找到自己需要的图表示例，然后配置好了复制到drawChart方法里面就好了
Documentation - Apache ECharts echarts配置项的api
6.通过symbol去自定义节点图片的问题 通过symbol去自定义节点图片后，首次渲染不会出现
setTimeout(() =&gt; { this.myChart.resize(); //myChart是init出来的图表实例 }, 200); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cbba9465f7389248c04a79a6b1bda654/" rel="bookmark">
			内网信息收集【转载】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		信息收集 查询本机器的进程信息
wmic process list brief 或者 tasklist 常见的杀毒软件进程
360tray.exe 360安全卫士 360sd.exe 360杀毒 MsMpEng.exe Windows Defender（Microsoft Security Essentials） hipstray.exe 火绒 wsctrl.exe 火绒 usysdiag.exe 火绒 ksafe.exe 金山卫士 QQPCRTP.exe QQ电脑管家 kxetray.exe 金山毒霸 KvMonXP.exe 江民杀毒 RavMonD.exe 瑞星杀毒 Mcshield.exe 麦咖啡 avp.exe 卡巴斯基 TMBMSRV.exe 趋势杀毒 avcenter.exe Avira(小红伞） safedog.exe 安全狗 SafeDogGuardCenter.exe 安全狗 safedogupdatecenter.exe 安全狗 safedogguardcenter.exe 安全狗 SafeDogSiteIIS.exe 安全狗 SafeDogTray.exe 安全狗 SafeDogServerUI.exe 安全狗 D_Safe_Manage.exe D盾 d_manage.exe D盾 yunsuo_agent_servic.exe 云锁 yunsuo_agent_daemon.exe 云锁 HwsPanel.exe 护卫神·入侵防护 hws_ui.exe 护卫神 hws.exe 护卫神·入侵防护系统 服务处理程序 hwsd.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cbba9465f7389248c04a79a6b1bda654/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd2015aa9ae6567ea64102dd57452ea3/" rel="bookmark">
			结构体数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		结构体数组 结构体是一种集合，它里面包含多个变量和数组，他们类型形同，也可以不同，每个变量或数组都称为结构体成员
struct stu{ char *name; //姓名 int num; //学号 int age; //年龄 char group; //所在学习小组 float score; //成绩 }; 结构体成员定义与变量相同，只是不能初始化，}；不能少
结构体变量 struct stu{ char *name; //姓名 int num; //学号 int age; //年龄 char group; //所在学习小组 float score; //成绩 } stu1, stu2; 将变量放在结构体定义的后面即可
当只需要stu1,stu2两个变量，后面不需要定义结构体的其他变量，也可以再定义时不给出结构体名，例如：
struct{ //没有写 stu char *name; //姓名 int num; //学号 int age; //年龄 char group; //所在学习小组 float score; //成绩 } stu1, stu2; 因为没有结构体名，后面不能再定义新的变量 可以对成员逐一赋值，也可以在定义时整体赋值
struct{ char *name; //姓名 int num; //学号 int age; //年龄 char group; //所在小组 float score; //成绩 } stu1, stu2 = { "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd2015aa9ae6567ea64102dd57452ea3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/efa50c2aa670172d695bc387d46fb4ce/" rel="bookmark">
			ROS rosdep配置，更新超时解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、配置ROS rosdep 安装rosdep：
ROS Melodic及以前版本：sudo apt-get install python-rosdep
ROS Noetic：sudo apt-get install python3-rosdep
初始化：sudo rosdep init
更新：rosdep update
二、更新超时解决方案 1.修改rosdep下载资源的脚本文件/usr/lib/python3/dist-packages/rosdep2/sources_list.py，将以下内容添加到第311行（download_rosdep_data()函数中），启用代理：
url="https://ghproxy.com/"+url
2.修改/usr/lib/python3/dist-packages/rosdistro/__init__.py里面第68行的DEFAULT_INDEX_URL参数
DEFAULT_INDEX_URL = 'https://ghproxy.com/https://raw.githubusercontent.com/ros/rosdistro/master/index-v4.yaml'
3.将以下4个文件用同样的方法把https://ghproxy.com/添加到网址前
/usr/lib/python3/dist-packages/rosdep2/gbpdistro_support.py 36行
/usr/lib/python3/dist-packages/rosdep2/sources_list.py 72行
/usr/lib/python3/dist-packages/rosdep2/rep3.py 39行
/usr/lib/python3/dist-packages/rosdistro/manifest_provider/github.py 68行 119行
4.在/usr/lib/python3/dist-packages/rosdep2/gbpdistro_support.py 的第204行添加以下代码
gbpdistro_url = "https://ghproxy.com/" + gbpdistro_url
update成功
注：ROS Melodic文件夹名为/usr/lib/python2.7/…，ROS Noetic为/usr/lib/python3/…
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ee3c815de6608d8651543f03a66f0ce/" rel="bookmark">
			Uniapp ucharts柱状图使每个柱体颜色不一样
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;qiunCharts type="column" v-if="chartData.series.length != 0" :chartData="chartData" :chartList="chartList" background="none" :opts="options" :canvas2d="true" :canvasId="chartId" /&gt; export default { data() { return { chartData: { categories: [], series: [] } } }} this.chartData.categories = ['985', '211', '双一流', '普通'];
重点：this.chartData.series=[{name:"",data:[{color:"#FFF000",value:6},{color:"#aaabbb",value:7},{color:"#00FF00",value:6},{color:"#FF0000",value:1}]}]
效果图
版本为非uni-modules版本 qiun-data-charts 秋云高性能跨全端图表组件 v2.3.6-20211211
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80639c28fe2786a40d96b0005870b8b1/" rel="bookmark">
			vue cli快速搭建网站步骤及参数详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以TP6+vue3+vue cli4.5.6+element UI为例，vue的web工程放在/public下
一、准备
①已安装node.js（vue cli4.x，node是v10以上版本），npm
②没有旧版vue cli，如有，卸载
npm uninstall vue-cli -g //或者 yarn global remove vue-cli 二、搭建工程
1、创建项目
vue create 项目工程名称 1、之前设置默认的vue2配置
2、之前设置默认的vue3配置
3、自定义
按需选择：（空格选中 回车进入下一步）
? Please pick a preset: Manually select features ? Check the features needed for your project: (Press &lt;space&gt; to select, &lt;a&gt; to toggle all, &lt;i&gt; to invert selection) &gt;(*) Choose Vue version ##选择vue版本 (*) Babel ##转码器，将ES6代码转为ES5代码，从而在现有环境执行。 ( ) TypeScript	##TypeScript是一个JavaScript（后缀.js）的超集（后缀.ts）包含并扩展了 JavaScript 的语法，需要被编译输出为 JavaScript在浏览器运行 (*) Progressive Web App (PWA) Support ##Web应用程序支持 (*) Router ##vue路由管理 (*) Vuex ##vue的状态管理 (*) CSS Pre-processors ##css预处理器（如：less、sass） (*) Linter / Formatter ##代码风格检查和格式化（如：ESlint） ( ) Unit Testing ##单元测试 ( ) E2E Testing #end to end 测试 Vue CLI v4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/80639c28fe2786a40d96b0005870b8b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/efa1b0ab58ef4c878d6d6468a032a706/" rel="bookmark">
			element的Cascader级联选择器怎么点击文字选中
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		element里的Cascader级联选择器需要点击前面点单选框或多选框才能选中这一项。
本来我的思路是想点击label的时候将选中的id放到绑定数据中，但没有找到点击label的回调函数（可能是我没看到，有找到的希望留言一下）
后来看到一篇文章，变了一下思路，很简单就解决了，就是样式跟之前不一样。
新思路就是将单选框宽度拉长覆盖label文字（相当于不显示单选框），即可实现点击文字就像点击单选框
效果图：
&lt;el-cascader v-model="ruleForm.folderName" :options="treeData" :props="{ checkStrictly: true }" clearable ref="cascader" @change="cascaderChange" popper-class="theder"//重点 &gt;&lt;/el-cascader&gt; .theder{ .el-cascader-panel{ .el-cascader-menu{ .el-radio{ height: 100%; width: 150px; opacity: 0; position: absolute; // z-index: 10; .el-radio__input{ .el-radio__inner{ border: 0px; } } .el-radio__input.is-checked{ .el-radio__inner{ background: none; } } } } } } 参考文章：element的Cascader级联选择器怎么点击文字选中，并且取消前面圆圈按钮 - 程序员大本营
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b070b173e6cfafe74b17d5a95984e36c/" rel="bookmark">
			关于Unity3D的ScriptableObject保存的一些问题记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在通过脚本在游戏中或者编辑器状态下对ScriptableObject进行了修改，关闭编辑器后之前的修改又都没了，原因是在修改后要调用下面这个方法才能保存；
EditorUtility.SetDirty(target);
其中, target代表你需要序列化的对象, 在项目中, 为对应的ScriptableObject.
static function SetDirty (target : Object) : void
Description描述
Marks target object as dirty.
标记目标物体已改变。
Unity internally uses the dirty flag to find out when assets have changed and need to be saved to disk.
当资源已改变并需要保存到磁盘，Unity内部使用dirty标识来查找。
E.g. if you modify a prefab's MonoBehaviour or ScriptableObject variables, you must tell Unity that the value has changed. Unity builtin components internally call SetDirty whenever a property changes.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b070b173e6cfafe74b17d5a95984e36c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8bae177d6075529121f895eff6e0b42/" rel="bookmark">
			【youcans 的 OpenCV 例程200篇】190.基于图像分割的图像融合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OpenCV 例程200篇 总目录-202205更新
【youcans 的 OpenCV 例程200篇】190.基于图像分割的图像融合 两张图像直接进行加法运算后图像的颜色会改变，通过加权加法实现图像混合后图像的透明度会改变，都不能实现图像的叠加。
实现图像的叠加，需要综合运用图像分割、图像掩模、位操作和图像加法的操作。
确定图像叠加位置，将 Lena 图像中的叠加位置裁剪出来，使叠加图像的尺寸相同；对前景图像进行二值化处理，生成黑白掩模图像 mask（LOGO区域黑色遮盖）及其反转掩模图像 maskInv （LOGO区域白色开窗）；以黑白掩模 mask（LOGO区域黑色遮盖）作为掩模，对背景图像（Lena裁剪图）进行位操作，LOGO区域遮盖为黑色，其它区域保持不变，得到叠加背景图像 img1BG；以反转掩模 maskInv（LOGO区域白色开窗）作为掩模，对前景图像（CVlogo）进行位操作，LOGO区域保持不变，其它区域遮盖为黑色，得到叠加前景图像 img2FG；背景图像 img1BG 和 前景图像 img2FG 通过 cv2.add 加法运算，得到裁剪部分的叠加图像；用叠加图像替换Lena 图像中的叠加位置，得到Lena 叠加 CVlogo 的图像。 算法原理：
例程：1.90 基于图像分割的图像融合 通过图像分割，获得前景目标的掩模图像 mask，将前景图像叠加到背景图像的指定位置，直接进行图像拼接。
# 1.90：基于图像分割的图像融合 img1 = cv2.imread("../images/seaside02.png") # 背景图像 img2 = cv2.imread("../images/seagull01.png") # 添加的前景图像 xmin, ymin, w, h = 160, 64, 256, 256 # 矩形 ROI 位置: (ymin:ymin+h, xmin:xmin+w) print(img1.shape, img2.shape) levels = 3 # HSV 色彩空间图像分割 hsv = cv2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f8bae177d6075529121f895eff6e0b42/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e568b94b602e34a537224f7908dde196/" rel="bookmark">
			common 模块的简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Commom 模块旨在多个模块之间共享相同的工具类、配置类、异常类、全局异常处理、全局返回值对象，公共依赖等等。使用Common 模块的可以尽可能的将代码的复用性提升，但是，若复用类的提取不符合共用的原则，则可能导致高耦合的情况。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60e9a454905304ce8e10a12d3ca80fcc/" rel="bookmark">
			hive正常数据转化为json数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		工作中，大多数时候会需要把json数组中的数据解析出来，现在会经常和后端打交道，后端同学就希望把正常的行列数据用json的形式给他们，他们使用起来方便，我看有的文章会写用udtf函数实现，不过本着能用内置函数绝不用自定义函数的原则(主要是我不会写)，用内置函数实现也不是很难。
原数据形式：
希望转换成一个标准的json数组，
{ 下装款型: { 直筒裤 }, 下装设计: { 纯色 }, 厚度: { 正常 }, 版型: { 正常 }, 穿搭风格: { 机能, 休闲 }, 裤长: { 长裤 }, 颜色: { 褐, 灰 } } 简单的hive实现：
--我用的是阿里云的odps，hive略微有点差别 --tmp为原始数据表 --goods_name和tag_name为需要处理的字段 select goods_id ,concat('{',wm_concat(',',concat(goods_name,':',tag_name)),'}') as tag_detail from	( select goods_id ,goods_name ,concat('{',wm_concat(',',tag_name),'}') as tag_name from	( select goods_id ,goods_name ,tag_name from	tmp ) t0 group by goods_id ,goods_name ) t1 group by goods_id ; 上面的还是太简单了，这次碰到了麻烦点的，特别记录下，看有用udf实现的，下次试下，优先还是内置函数吧，稳定且效率高
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60e9a454905304ce8e10a12d3ca80fcc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70dc325043f9ed7cef4eaed9c6431e60/" rel="bookmark">
			Node.js 多点找色
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		"nodejs"; const { requestScreenCapture } = require('media_projection'); const image = require('image'); const { findColor, findColorSync, findMultiColors, findMultiColorsSync } = image; const { delay } = require('lang'); const { Color } = require('color'); const { showToast } = require('toast'); const cv = require('@autojs/opencv'); const color = Color.parse('#009688'); const multiColorTarget = { // 多点找色的第一个颜色 firstColor: color, // 多点找色的后续的点 offsetColors: [{ color: new Color(0xffffff), offsetX: 20, offsetY: 20 }, { color: new Color(0xffffff), offsetX: 30, offsetY: 30 }], } async function main() { const capturer = await requestScreenCapture(); showToast("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70dc325043f9ed7cef4eaed9c6431e60/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64f24fafa2b70db7ec89c56983589c37/" rel="bookmark">
			多智能体强化学习：多智能体系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 多智能体系统 多智能体系统 (Multi-Agent System，缩写MAS) 中包含 m 个智能体，智能体共享环境，智能体之间会相互影响。 一个智能体的动作会改变环境状态，从而影响其余所有智能体。 1.1 多智能体系统 VS 并行强化学习 并行强化学习 m 个节点并行计算， 每个节点有独立的环境，每个环境中有一个智能体。智能体之间完全独立，不会相互影响。 可以看成 m 个单智能体系统 (Single-Agent System ， SAS) 的并集 多智能体系统 只有一个环境，环境中有 m 个相互影响的智能体 eg， 环境中有 m 个机器人，这属于 MAS 的设定。假如把每个机器人隔绝在一个密闭的房间中，机器人之间不会通信， 那么 MAS 就变成了多个 SAS 的并集。——&gt;此时就是并行强化学习了 1.2 多智能体强化学习 (Multi-Agent Reinforcement Learning， MARL) 让多个智能体处于相同的环境中，每个智能体独立与环境交互，利用环境反馈的奖励改进自己的策略，以获得更高的回报。 在多智能体系统中，一个智能体的策略不能简 单依赖于自身的观测、动作，还需要考虑到其他智能体的观测、动作。 1.3 多智能体强化学习的设定 1.3.1 完全合作关系(Fully Cooperative) 智能体的利益一致，获得的奖励相同，有共同的目标。 假设一共有 m 个智能体，它们在 t 时刻获得的奖励分别是 ，在完全合作关系中，他们的奖励是相同的 1.3.2 完全竞争关系 (Fully Competitive) 一方的收益是另一方的损失。 在完全竞争的设定下， 双方的奖励是负相关的：对于所有的 t，有 如果是零和博弈，双方的获得的 奖励总和等于 0 ： 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/64f24fafa2b70db7ec89c56983589c37/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7aca28e55c3f50de86b3e64c0b1128e7/" rel="bookmark">
			作业调度算法【平均周转时间、平均带权周转时间、先来先服务FCFS、短作业优先SJF、高优先权（级）算法FPF、高响应比优先算法HRRN】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 先来先服务算法（FCFS）短作业优先算法（SJF）、短进程优先算法（SPF）周转时间和带权周转时间高优先权（级）调度算法FPF高响应比优先调度算法HRRN 先来先服务算法（FCFS） 既可用于作业调度，又可用于进程调度
作业调度：优先调度最先进入后备队列的作业进程调度：优先调度最先进入就绪队列的进程 利于长作业（长进程），不利于短作业（短进程）
利于CPU繁忙型，不利于I/O繁忙型
短作业优先算法（SJF）、短进程优先算法（SPF） 即优先调度时间短的作业/进程
SJF：从后备队列中找到估计运行时间最短的作业SPF：从就绪队列中找到估计运行时间最短的作业 有效降低作业的平均等待时间，提高系统吞吐量
对长作业不利，不能对紧急作业做有效处理
周转时间和带权周转时间 周转时间 = 进程完成时间 - 进程到达时间平均周转时间 = 周转时间之和 / 进程个数带权周转时间 = 周转时间 / 进程实际运行时间平均带权周转时间 = 带权周转时间之和 / 进程个数 FSFS
平均周转时间 = [（4-0）+（7-1）+（12-2）+（14-3）+（18-4）] / 5 = 9
平均带权周转时间 = [（4-0）/ 4 +（7-1）/ 3 + （12-2）/ 5 +（14-3）/ 2 + （18-4）/ 4 ] / 5=2.8
SPF
平均周转时间 = [（4-0）+（9-1）+（18-2）+（6-3）+（13-4）] / 5 = 8
平均带权周转时间 = [（4-0）/ 4 +（9-1）/ 3 +（18-2）/ 5 +（6-3）/2 +（13-4）/ 4] / 5 = 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7aca28e55c3f50de86b3e64c0b1128e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c906215053639a1ce4d14950e0019814/" rel="bookmark">
			vue.config.js配置详解-01
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 `1.~~baseUrl（已弃用）``2.publicPath``3.outputDir``4.assetsDir``5.indexPath``6.filenameHashing``7.pages``8.lintOnSave``9.runtimeCompiler``10.transpileDependencies``11.productionSourceMap``12.crossorigin` 1. 简介 使用vue-cli3.0搭建项目比之前更简洁，没有了build和config.文件夹。 vue-cli3.x及以上版本的一些服务配置都迁移到CLI Service里面了，对于一些基础配置和一些扩展配置需要在根目录新建一个vue.config.js文件进行配置。 所以，在使用vue-cli3.x及以上版本创建项目时，因为webpack的配置均被隐藏了，当你需要覆盖原有的配置时，则需要在项目的根目录下，新建vue.config.js文件，来配置新的配置，vue.config.js会被自动加载。 2. 各项配置
- 1.baseUrl（已弃用）
2.publicPath3.outputDir4.assetsDir5.indexPath6.filenameHashing7.pages8.lintOnSave9.runtimeCompiler10.transpileDependencies11.productionSourceMap12.crossorigin13.integrity14.configureWebpack15.chainWebpack16.css.modules17.css.requireModuleExtension18.css.extract19.css.sourceMap20.css.loaderOptions21.devServer22.devServer.proxy23.parallel24.pwa25.pluginOptions 其中，13-25，请参考官网
1.~~baseUrl（已弃用） 2.publicPath Default: ‘/’ 部署应用包时的基本 URL。用法和 webpack 本身的 output.publicPath 一致，但是 Vue CLI 在一些其他地方也需要用到这个值，所以请始终使用 publicPath 而不要直接修改 webpack 的 output.publicPath。
默认情况下，Vue CLI 会假设你的应用是被部署在一个域名的根路径上，例如 https://www.my-app.com/。如果应用被部署在一个子路径上，你就需要用这个选项指定这个子路径。例如，如果你的应用被部署在 https://www.my-app.com/my-app/，则设置 publicPath 为 /my-app/。
这个值也可以被设置为空字符串 (‘’) 或是相对路径 (‘./’)，这样所有的资源都会被链接为相对路径，这样打出来的包可以被部署在任意路径，也可以用在类似 Cordova hybrid 应用的文件系统中。
3.outputDir Default: ‘dist’ 当运行 npm run build 或 yarn build 时(实质为 vue-cli-service build ) ，生成文件的目录名称（默认dist）
&gt;
4.assetsDir Default: ‘’ 用于放置生成的静态资源 (js、css、img、fonts) 的 (相对于 outputDir 的) 目录；项目打包之后，静态资源会放在这个文件夹下。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c906215053639a1ce4d14950e0019814/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9be900c06f997efd38e889232a184dad/" rel="bookmark">
			Android 源码修改，使第三方应用可以直接使用su命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在android原生系统中，只有root权限和shell权限下才可以使用su命令，虽然在userdebug模式下编译的系统镜像有自带的su文件，但是第三方应用却无法使用。于是在这种场景下，有两种方式可以实现第三方应用使用su命令。
1.修改原来的su相关的源码（所有的应用都可以使用）
2.通过supersu.apk 的方式进行实现（可以通过supersu进行控制应用是否可以使用su）
一、修改原来的su相关的源码 1.修改 system/extras/su/su.c ,屏蔽如下代码：
修改前 uid_t current_uid = getuid(); if (current_uid != AID_ROOT &amp;&amp; current_uid != AID_SHELL) error(1, 0, "not allowed"); 修改后 // uid_t current_uid = getuid(); // if (current_uid != AID_ROOT &amp;&amp; current_uid != AID_SHELL) error(1, 0, "not allowed"); 将su文件中的判断是否是root，或是shell的用户id判断进行注释。
2.修改 system/core/libcutils/fs_config.c, 做如下修改：
修改 fs_path_config android_files结构体中的 修改前 { 04750, AID_ROOT, AID_SHELL, 0, "system/xbin/su" }, 修改后 { 06755, AID_ROOT, AID_SHELL, 0, "system/xbin/su" }, 修改su文件的访问权限，将其他用户的权限修改为可读，可执行权限。
3.修改 frameworks/base/cmds/app_process/app_main.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9be900c06f997efd38e889232a184dad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de464e8ae7366593bf7c69b7422bafd4/" rel="bookmark">
			attention is all you need --transformer中的细节
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一切故事开始于2017年谷歌的一篇论文：attention is all you need ，由于讲解transformer结构的视频、博客很多，推荐阅读以下内容：
李宏毅2021 ML课程 self-attention &amp;&amp; transformerhttp://jalammar.github.io/illustrated-transformer/ 以上两个参考内容足以学会什么是transformer。以下记录比较容易忽略的几个知识点：
transformer中的position encoding 首先因为transformer模型不包含recurrence and convolution，为了模型能够利用序列的顺序信息，引入了【pos encoding】，在encoder和decoder底部的输入embedding中添加“位置编码-position encoding”。position encoding与word embedding具有相同的维度d_model，因此可以将两者相加. position encoding得方法有很多种，这里采用了不同频率的sine 和cosine 函数
其中pos为位置，i是维度，例如一个句子长度为L，则 p o s = 0 , 1 , 2 , 3 , . . . , L − 1 pos=0,1,2,3,...,L-1 pos=0,1,2,3,...,L−1, 若 d m o d e l = 512 d_{model}=512 dmodel​=512, 则 i = 0 , 1 , 2 , 3..255 i =0,1,2,3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de464e8ae7366593bf7c69b7422bafd4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b3dc45318d0ea3bfbaf0dd55d422b25/" rel="bookmark">
			【vue 动态表格】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
**
vue动态表格的实现 **
前言 作为一名刚入职公司不久的小前端，在公司做rep后台管理系统，其中表格的查询相当的多，一个表格可能有十几二十个列表，就会显得非常的杂乱，然后就想到了能不能去动态的该表表格的列表，选择自己需要列去显示，不需要的列不去显示。
一、什么是动态表格？ 动态表格顾名思义，表格的列是动态的不是写si的。想要显示啥列就显示出啥列。
二、使用步骤 1.引入库 代码如下（示例）：
//给项目添加Element-ui vue add element //axios请求 npm install axios 首先看下tabel的整体吧
tabel的整体是这个样子的，点击下方的切换列表弹出选择框。 下面的是.vue的代码块
&lt;template&gt; &lt;div class="app-container"&gt; &lt;div class="filter-container"&gt; &lt;!-- 动态表格 --&gt; &lt;el-dialog title="表格信息修改" :visible.sync="dialogVisible"&gt; &lt;el-form :model="ruleForm" ref="ruleForm" label-width="100px" class="demo-ruleForm"&gt; &lt;el-form-item label="表格数据" prop="type"&gt; &lt;el-checkbox-group v-model="ruleForm.type"&gt; &lt;el-checkbox label="batch" name="type"&gt;&lt;/el-checkbox&gt; &lt;el-checkbox label="date" name="type"&gt;&lt;/el-checkbox&gt; &lt;el-checkbox label="myStatus" name="type"&gt;&lt;/el-checkbox&gt; &lt;el-checkbox label="phone" name="type"&gt;&lt;/el-checkbox&gt; &lt;el-checkbox label="sample_DNAid" name="type"&gt;&lt;/el-checkbox&gt; &lt;el-checkbox label="sample_RNAid" name="type"&gt;&lt;/el-checkbox&gt; &lt;el-checkbox label="sample_property" name="type"&gt;&lt;/el-checkbox&gt; &lt;/el-checkbox-group&gt; &lt;/el-form-item&gt; &lt;el-form-item&gt; &lt;el-button type="primary" @click="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b3dc45318d0ea3bfbaf0dd55d422b25/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f91336032dc69a53ffebb39cff217896/" rel="bookmark">
			HDMI 2.1 VRR功能详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		7.6可变刷新率和快速更新
可变刷新率（VRR）允许图片在源完成准备后立即通过链路发送。在链路支持的最大字符速率大于给定视频定时所需的速率的情况下，Fast VActive（FVA）减少了传输图片所需的时间。这些特性提供了性能、延迟和节能方面的好处，第7.6.5节对此进行了详细说明。
如果接收器已清除HF-VSDB中的FVA字段（=0），则源不应启用FVA。如果接收器在HF-VSDB中设置了（=1）FVA字段，则源可以启用FVA。在HF-VSDB（第10.3.2节）中设置了FVA字段（=1）的接收器应能够支持FVA功能。如果接收器清除了HF-VSDB（第10.3.2节）中的VRR最小字段（=0），则源不应启用VRR。如果接收器已将HF-VSDB中的VRR MIN字段设置为有效的启用值（1-48），则源可以启用VRR。将HF-VSDB中的VRR MIN字段设置为有效启用值的接收器应能够支持VRR功能。
如果接收器已设置FVA字段并将VRR MIN字段设置为有效的启用值，则源可以同时启用FVA和VRR功能。
源可以启用FVA和VRR以进行视频定时。对于任何隔行视频定时，源不得启用FVA或VRR。当启用FVA或VRR时，源只能使用以下3D视频格式的渐进扫描版本：帧打包、并排（一半）或顶部和底部。
FVA和VRR都通过增加垂直前廊中的行数来修改视频计时。FVA还通过FVA\u因子增加像素时钟速率。Vactive的行数不变。Vsync和Vback的定时始终保持不变；所有水平参数的像素计数保持不变。这里，原始的未修改的视频定时将被称为“基本视频定时”。震源只能使用刷新率为50 Hz或更高的基本视频计时的VRR。
FVA_Factor是一个整数值，表示v总的倍数。M VRR是表示附加行的整数值。
表7-12显示了FVA和/或VRR的应用如何影响垂直定时参数。如果V总参数不改变正常值，则使用基本参数。为清楚起见，每当在本说明书中引用这些定时参数而不使用VRR、FVA或VRRFVA下标并且启用了VRR或FVA时，则除非明确说明，否则引用是指由这些等式调整的定时参数
另有说明。
采用方：浦明路，海贝斯特电子（东莞）有限公司-用户：1-文件号：4。
版权归HDMI论坛所有。版权所有。此文件受许可协议的约束。
表7-12:VRR和FVA的垂直定时参数修改
从表中可以看出以下见解：
1.Vactive的行数不变。
2.应用VRR只会影响Vfront的行数，进而影响Vtotal。
3.应用FVA会影响除Vactive之外的所有行数。Vsync和Vback的计时不变。
4.VRR+FVA是FVA加上M VRR。
当接收器包含VRR MIN和VRR MAX的有效值且源使用M VRR的有效值时，当启用VRR时，接收器不得中断视频或音频的连续呈现。无论FVA是否运行，该要求仍然有效。
第7.6.3节定义了M VRR的范围限制。
当VRR激活时，音频样本应继续满足数据岛定时和放置的音频/视频同步要求。
在使用Vact\ U空间定时参数的3D模式中（参见H14b，图8-3 3D结构），当启用VRR时，该参数不会改变（即，不会增加M VRR）。启用FVA时，行中的Vact\ U空间乘以FVA\ U因子。这使得对于任何FVA\u因子，Vact\u空间的时间长度保持不变，而L和R视频帧的Vactive的时间长度通过FVA\u因子减小。当FVA和VRR都启用时，对Vact\ U空间的影响与仅启用FVA时相同。启用FVA时，Vactïu空间的调整适用于未压缩和压缩视频传输。有关压缩视频传输的更多详细信息，请参见第7.7.7.1节。
7.6.1设置FVA\U系数
FVA_Factor MAX用于根据接收器的带宽能力与源的所需视频格式（使用表7-13的等式）进行对比，确定接收器可支持的FVA_Factor的有效范围。如果FVA_Factor MAX计算为1，则所需视频格式不支持FVA。当FVA_Factor MAX&gt;1时，源可以选择有效范围为2和FVA_Factor MAX的整数值，但受源功能的限制。例如，接收器可以支持FVA_因子＝8，但是源可以被限制为FVA_因子＝3。
FVA_Factor MAX计算为以下函数：
•R位
•TMDS模式与FRL模式
•当FRL模式激活时，激活车道数
•最大TMDS时钟（H14b第8.3.2节）和/或最大TMDS字符速率（第10.3.2节）或最大FRL速率（第10.3.2节）的设置
表7-13：计算FVA\U因子最大值
当启用FVA时，源应为FVA_因子选择一个有效值，并且FVA_因子减去1应编码到视频定时EM的FVA_因子_M1字段中。视频定时EM不要求帧精度。
未启用FVA时，震源应使用1（=1）的值作为FVA_因子，并将FVA_因子_M1设置为零。
为了使FVA在TMDS模式下工作，Max\u TMDS\u Clock和Max\u TMDS\u Character\u Rate中至少有一个必须为非零，否则无法计算表7-13中的步骤3。如果接收器支持TMDS字符率&gt;340 Mcsc，则最大TMDS字符率应为非零（来自HF-VSDB，表10-6）。如果接收器仅支持TMDS字符速率≤340 Mcsc，则应根据H14b（从表中）将最大TMDS时钟设置为非零值
8-16).
一旦建立了视频链接，源应保持FVA_因子的值恒定，直到需要改变上下文或配置。
7.6.2启用FVA时确定像素时钟
当启用FVA时，实际像素时钟速率将从由基本视频定时定义的基本像素时钟速率增加FVA\u因子。这将被称为f PixelClock，Base。
方程7-1:FVA激活时计算像素时钟
7.6.3设置M VRR
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f91336032dc69a53ffebb39cff217896/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af71634ff7c42c572618b20673c02788/" rel="bookmark">
			Android11获取外部存储目录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES).getPath();对应路径： DIRECTORY_PICTURES =/storage/emulated/0/Pictures
this.getExternalFilesDir(Environment.DIRECTORY_PICTURES).getPath();对应路径 DIRECTORY_PICTURES= /storage/emulated/0/Android/data/com.example.testpplication/files/Pictures
Android Q不再需要申请文件读写权限，默认可以读写自己沙盒文件和公共媒体文件。所以Q以上不需要再动态申请文件读写权限
apk安装路径为 /data/data/，沙盒路径 /sdcard/Android/data/xxx 不做操作安装的同时不会立即生成
而Environment.getExternalStorageDirectory() 在 API Level 29 开始已被弃用，开发者应迁移至 Context#getExternalFilesDir(String), MediaStore, 或Intent#ACTION_OPEN_DOCUMENT。
应用只能访问自己沙盒下的文件和公共媒体文件
公共文件的操作需要用到ContentResolver和Cursor
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90e192db1e06e38c5ad518a6d8f2b048/" rel="bookmark">
			【分系列发送】CREStereo源码阅读1——框架阅读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 CREStereo试了预训练的模型，效果真的非常好，就是还没办法实时。打算自己参照着找找有没有可以加速的地方
参考 论文阅读
源码
论文
过程 整体框架 打开nets文件夹里面的crestereo.py，先看看大体的inference流程，具体太长了，总的就不贴了，一点一点贴。
特征提取
上来先归一到-1~+1就不说了，通过self.fnet把左右图特征提取出来，然后cast改改类型，根据注释应该是原图像的1/4大小 fmap1, fmap2 = self.fnet([image1, image2]) 最初的降采样+卷积+上下文语义提取
先是将刚刚提取到的特征进行平均池化，大小从1/4变到1/8，然后经过一次卷积之后通过sigmoid函数。这边sigmoid的写法让我有点懵，实际上和我注释掉的写法是等价的，是不是这么写计算的时候会快？得到offset_dw8 # 1/4 -&gt; 1/8 # feature fmap1_dw8 = F.avg_pool2d(fmap1, 2, stride=2) fmap2_dw8 = F.avg_pool2d(fmap2, 2, stride=2) # offset offset_dw8 = self.conv_offset_8(fmap1_dw8) offset_dw8 = self.range_8 * (F.sigmoid(offset_dw8) - 0.5) * 2.0 # offset_dw8 = self.range_8 * F.tanh(offset_dw8*0.5) 随后将还是之前的特征图按特征通道进行分割，一半用tanh激活函数，一半用relu，池化后得到net_dw8和inp_dw8
# context net, inp = F.split(fmap1, [hdim], axis=1) net = F.tanh(net) inp = F.relu(inp) net_dw8 = F.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/90e192db1e06e38c5ad518a6d8f2b048/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58eb3f1e0247f22e037b2e6653b61efc/" rel="bookmark">
			渗透测试之信息收集||
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.5指纹识别 指纹识别的特征：终身不变性、唯一性、方便性
本节所讲的指纹指网站CMS指纹识别、计算机操作系统、web容器的指纹识别
应用程序一般在HTML、CSS、JavaScript中多多少少会包含一些特征码，比如WordPress在robots.txt包含wp-admin、首页index.php中会包含generator=wordpress 3.xx，这个特征就是CMS的指纹，当碰到其他网站也存在此信息时，就可以快速识别出该CMS，所以叫指纹识别.
常见的指纹识别对象
CMS信息
大汉CMS、织梦、帝国CMS、phpcms、ecshop等
前端技术
HTML5、jquery、bootstrap、pure、ace
Web服务器
Apache、lighttpd、Nginx、IIS等（后文补充）
应用服务器
Tomcat、Jboss、weblogin、websphere等
开发语言
PHP、java、Ruby、Python、C#等
操作系统信息
linus、win2k8、win7、kali、centos等
CDN信息
是否使用CDN、cloudflare、360cdn、365cyd、yunjiasu等（后文补充）
WAF信息
是否使用waf，如Topscc、Jiasule、Yundun等
IP及域名信息
IP和域名注册信息、服务商信息等
端口信息
有些软件或平台还会探测服务器开放的常见端口
CMS（Content Management System）又称整站系统或文章系统。
内容管理系统是企业信息化建设和电子政务的新宠，也是一个相对较新的市场，对于内容管理，业界还没有一个统一的定义.
我们认为内容管理系统是一种位于WEB前端（Web 服务器）和后端办公系统或流程（内容创作、编辑）之间的软件系统.
CMS扫描工具
BugScaner: http;//whatweb.bugscaner.com/look
云悉指纹: http://www.yunsee.cn/finger.html
WhatWeb: http://whatweb.net/.
常见的Web服务器
Apache（Apache HTTP Server）是Apache软件基金会的一个开放源代码的网页服务器软件，可以在大多数电脑操作系统中运行，由于其跨平台和安全性被广泛使用，是最流行 的Web服务器软件之一
Nginx（发音同engine x）是一个网页版服务器，它能反向代理HTTP，HTTPS，SMTP，POP3，IMAP的协议链接，以及一个负载均衡器和一个HTTP缓存。Nginx是一款面向性能的服务器，相较于Apache、lighttpd具有占有内存少，稳定性高等优势
IIS是Internet Information Server的缩写，它是微软公司主推的服务器
Lighttpd是一个德国人领导开源Web服务器软件，具有非常低的内存开销、CPU占用率低、效能好以及丰富的模块等特点。
Tomcat是Apache软件基金会的Jakarta项目中是一个核心项目，由Apache、Sun和一些公司及个人共同开发而成。Tomcat技术先进、性能稳定，而且免费，因而深受Java爱好者的喜爱并得到了部分软件开发商的认可，成为目前比较流行的web应用服务器
1.6查找真实IP 在渗透测试过程中，目标服务器可能只有一个域名，那么如何通过这个域名来确定目标服务器的真实IP对渗透测试来说就很终于重要。如果目标服务器不存在CDN，可以直接通过www.ip138.com获取目标的一些IP及域名信息。这里主要讲解在以下这几种情况下，如何绕过CDN寻找目标服务器的真实IP.
1.61.目标服务器存在CDN
CDN即内容分发网络，主要解决因传输距离和不同运营商节点造成的网络速度性能低下的问题。
如果渗透目标购买了CDN服务，可以直接ping目标的域名，但得到的并非真正的目标Web服务器，只是离我们最近的一台目标节点的CDN服务器，这就导致了我们没法直接得到目标的真实IP段范围.
1.6.2.判断目标是否使用了CDN
通常会通过ping目标主域，观察域名的解析情况，以此来判断其是否使用了CDN
还可以利用在线网站17CE（https://www.17ce.com）进行全国多地区的ping服务器操作，然后对比每个地区ping出的IP结果，查看这些IP是否一致，如果都是一样的，极有可能不存在CDN。如果IP太大不太一样或者规律性很强，可以尝试查询这些IP的归属地，判断是否存在CDN
方法1.使用ping命令
使用各种多地ping服务，查看对应IP地址是否唯一，如果不唯一，多半是使用了CDN网址
多个地点Ping服务器,网站测速 - 站长工具
网站测速工具_超级ping _多地点ping检测 - 爱站网
方法2.使用nslookup命令
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/58eb3f1e0247f22e037b2e6653b61efc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4a14e084e07d17c82e37411ebe5fb56/" rel="bookmark">
			改变自己，就在今天
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自我介绍 我是一名成都的在校大学生，即将步入大二，学的是软件工程专业，虽然经过了一年学校教育的洗礼，但仍深感自己编程技术的不足，基础不扎实，打算从头开始，为此特在此平台记录自己的成长过程，愿与诸君共勉，共同进步
学习目标 深入了解编程语言，不只止步于表面，能达到与人讲解一门语言基本概念的水平。在毕业的时候我希望能够达到进入字节跳动。
学习方式 在我看来，学校的学习方式过于简单，单纯的PPT与课本上难以理解的文字描述，并不是特别适合我，我会在网上寻找视频及与大神交流，并且每天做至少五道以上的编程题来提升自己，实践才能更有效的检验自己当前的水平，并且能提高自己的编码能力和手速。每周至少在编程上投入25个小时的时间。每周发布至少两篇文章来约束自己。
学习的语言 c语言（未来可能学习c++或者Java中的一个）
结语 人生的道路有很多条，我选择努力的那一条。我知道未来可能会有很多的困难在等着我们，但是我们没有理由放弃，我知道，未来的自己会感谢现在正在努力的自己。最后感谢大家的阅读与监督，期望与大家共同成长。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c49b53a8a5e523bc4062bf44e6d8a5f0/" rel="bookmark">
			（第三章） HDMI视频数据处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		3.1 视频数据编码算法
在视频数据周期，编码器编码分为两个阶段，第一个阶段产生9位编码字，第二阶段产生第十位编码。
在第一阶段中，由输入的8位原始数据加上第9位标志位构成，标志位用于指定采取哪种运算方式。“1”表示异或方式（XOR），“0”表示异或非方式（XNOR）。对于原始的8位输入数据，第0位保持不变，即输出与输入一样，其余7位依次和前一位进行XOR或XNOR运算作为输出值。采用哪种运算原则上要求编码值得转换最小。
假如原始8位数据为：0b10110110，而第9位为1，即采用XOR方式编码，此时第0位保持不变为0，第1位与第0位XOR运算输出为1，同理第2位与第一位的输出值XOR运算为0，以此类推，得到8位输出值为10010010，最后确定第一阶段前9位数据为0b110010010。同理，假如第9位数据为0，即采用XNOR方式编码，得到的输出结果是：0b000111000。
编码器的第二阶段发生在发射流上，通过选择是否翻转第一阶段产生的9位编码字中的8个数据位的值，来作一个近似的直流平衡。编码字被加上了一个第10位，用来显示编码是否被翻转。根据跟踪发射流中的“1”和“0”的连续不同，以及在当前的编码字里面“1”和“0”的数量，编码器决定什么时候翻转下一个字符。如果发射的“1”太多并且输入包含的“1”比“0”多，则编码被翻转。
表3.1 编码器变量 如下是编码器编码过程的算法流程图：
3.2 视频数据解码算法
相对于编码算法而言，视频解码算法的过程比较简单。编码器只需要判断数据位D[9]和D[8]并作出相应的解码算法。按照编码的过程，解码算法其实是编码算法的逆过程。同样的输入数据流经过编码和解码过程输出的一定和输入的一样。
还是拿3.1节的编码得到的数据作为例子，假如经过第二阶段确定第10位数据为“0”则输入数据0b10110110经过编码后得到的10位数据为0b0110010010，解码的过程先进行第二阶段，此时D[9]=0，则D[0:7]不需要反转，继续判断D[8]=1，则采取异或进行解码，D[7]=D[7] XOR D[6]，D[6]=D[6] XOR D[5]…D[1]=D[1] XOR D[0]，D[0]=D[0]，得到解码后的数据为0b10110110，解码成功。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/339a2a2f491d871818a7d13965404951/" rel="bookmark">
			bootstrap 类样式中的 mt mb ml mr mx my pt pb pl pr px py 含义
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		bootstrap 类样式中的 mt mb ml mr mx my pt pb pl pr px py 含义 内边距（pading）外边距（margin）
m - for classes 代表 margin
p - for classes 代表 padding
t - for classes that set margin-top or padding-top 设置margin-top或padding-top
b - for classes that set margin-bottom or padding-bottom 设置margin-bottom或padding-bottom
l - for classes that set margin-left or padding-left 设置margin-left或padding-left
r - for classes that set margin-right or padding-right 设置margin-right或padding-right
x - for classes that set both -left and -right 设置padding-left和padding-right或margin-left和margin-right
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/339a2a2f491d871818a7d13965404951/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd05cc61ad240590adb20d5b63ae9111/" rel="bookmark">
			三种坐标系学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		坐标系学习 三种坐标系介绍 1.地心地固坐标系（ECEF） 地心地固坐标系，也叫ECEF坐标系。其原点为地球的质心。
x轴延伸通过本初子午线（0度经度）和赤道（0度纬度）的交点。
Z轴延伸通过北极（即与地球旋转轴重合）。
y轴完成右手坐标系，穿过赤道和90度经度。
如下图所示
所用的坐标系是右手坐标系（右手定则），将手掌伸直，掌面朝向自己，将中指垂直于掌面，然后将大拇指垂直于中指和食指构成的平面，就构成右手坐标系，此时大拇指，食指，中指分别代表了y轴，z轴，x轴。
2.经纬高坐标系（84坐标系） 经纬高坐标系（84坐标系）是由经度(longitude)，纬度(latitude)，高度(altitude)组成的坐标系，也叫LLA坐标系。可以说是最为广泛的一个坐标系，他给出一点的大地纬度，大地经度和大地高度就可以知道这个点在地球上的位置，所以叫做经纬高坐标系。
84坐标系和上面的ECEF坐标系一样，把ECEF放到GPS中就是84坐标系
大地纬度是过用户点P的基准椭球面法线与赤道面的夹角。纬度在-90度到90度之间，北半球为正，南半球为负大地经度是过用户点P的子午面与本初子午线之间的夹角。经度值在-180度到180之间大地高度h是过用户点P到基准椭球面的法线距离，基准椭球面里面为负，外面为正 3.东北天坐标系（ENU） 东北天坐标系也叫站心坐标系，以用户所在位置P为坐标原点
坐标轴定义：x轴指向东边，y轴指向北边，z轴指向天顶
简介：ENU局部坐标系采用三维直角坐标系来描述地球表面，实际应用比较困难，因此一般使用简化后的二维投影坐标系来描述，在众多二维投影坐标系中，统一横轴墨卡托（UTM）坐标系是一种应用较为广泛的一种。UTM坐标系统使用基于网格的方法表示坐标，他将地球分为60个经度区，每个区包含6度的精度范围，每个区内的坐标均基于横轴墨卡托投影，如下图所示：
坐标系之间的转换 1.WGS84--ECEF 需要用到的参数：
地球长半轴半径：a
地球短半轴半径：b
椭球的第一偏心率：e
卯酉圈半径：N
输入：
经度（Lon），纬度（Lat），高度（Ait）
计算：
偏心率：e = sqart(a*a - b*b) / a;
卯酉圈半径：N = a/sqart(1-e*e*sin(Lat)*sin(Lat));
输出X,Y,Z
X = (N+Ait)*cos(Lat)*cos(Lon);
Y = (N+Ait)*cos(Lat)*sin(Lon);
Z =(N*(1-e*e)+Ait)*sin(Lat);
ECEF--ENU 坐标原点P0（x0, y0, z0），计算点P（x, y, z）以P0为坐标原点的ENU坐标系位置，这里用到的P0的经纬度LLA（lon0, lat0, alt0）。
代码：
// ECEF-&gt;ENU Re = R0 / sqrt(1 - e * e * sin(p.latitude * torad) * sin(p.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd05cc61ad240590adb20d5b63ae9111/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1cefa49c561ca937c3a39beff27f7d44/" rel="bookmark">
			idea常用快捷键
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		main函数输入psvm
在方法体内部有for循环，在IntellJ中是输入fori
System.out.println();在IntellJ中是输入sout
ctrl+alt+t 在idea中添加try/catch的快捷键
Alt+Enter可以补全实现类中实现的接口
ctrl+alt+L格式化代码快捷键
ctrl+x 删除一行
CTRL + R 替换文本
Ctrl + Alt + M 抽取方法
alt + F7查看方法被调用的地方
Shift+Shift全局搜索
Ctrl + Shift + / 注释 、取消注释（多行注释）
Ctrl + / 注释 、 取消注释（单行注释）
Ctrl + G 跳转到指定行
Ctrl + Shift + F 根据关键字全文搜索
Ctrl + Shift +R 全局替换
ctrl+alt+v 补全返回值
alt+insert 自动补全返回值 ，set get方法 有参构造 tostring
alt+enter导入包
按insert 键盘后，在编写时会出现一个很粗的光标，而且输入内容时会替换后面的一个字符，这我们都比较熟悉，再按inser 键盘可以切换回来。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80d51c67ef25b17ecd68d309fe8508ea/" rel="bookmark">
			shell命令以及运行原理(详解)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux严格意义上说的是一个操作系统，我们称之为“核心（kernel）“ ，但我们一般用户，不能直接使用kernel。 而是通过kernel的“外壳”程序，也就是所谓的shell，来与kernel沟通。 1.从技术角度，Shell的最简单定义：命令行解释器（command Interpreter）主要包含： 将使用者的命令翻译给核心（kernel）处理。 同时，将核心的处理结果翻译给使用者。 2.对比windows GUI，我们操作windows 不是直接操作windows内核，而是通过图形接口，点击，从而完成我们的 操作（比如进入D盘的操作，我们通常是双击D盘盘符.或者运行起来一个应用程序）。 3.shell 对于Linux，有相同的作用，主要是对我们的指令进行解析，解析指令给Linux内核。反馈结果在通过内核运 行出结果，通过shell解析给用户。 补充: 1.命令行和图形化界面 2.OS和外壳程序的关系 3.shell外壳 ① 什么是she1l外壳 : 包裹在操作系统外层的软件层，方便用户和OS进行沟通
② shell : 接受用户的输入，交给OS执行，得到结果反馈给用户
③ shell的作用 ：a.交互 b.保护OS
④ shell是所以外壳程序的统称，笼统的概念 ；bash是一种具体的shell
centOS7的外壳程序是: bash
4.Linux外壳程序的理解: ①shell是进行命令行解释的 ，命令行解释器在系统层面上就是一个进程!
②保证内核的安全运行的同时，也要保证自身的安全，如何保护？ shell进程-&gt;创建子进程去进行命令行解释-&gt;如果失败是不会影响shell进程。
③大部分指令的运行，都是会变成进程的。
5.shell进程 ①执行一个程序 ②进程之间的关系 1.myproc这个进程是bash帮我们创建的，也就是说 " ./myprco "这个指令是bash帮我们进行执行的。
2.自己grep出来的每一行都有一个grep，原因:当你使用管道的时候grep，它自己在过滤的时候它也要把自己运行起来，只要把自己运行起来也是个进程，自己的进程就包括myproc关键字
③bash的父进程 sshd是xshell登陆，底层用的协议工具，当你用xshell每次登陆的时候OS帮你创建了一个对应的bash;打开xshell登陆的时候就是在链接sshd的一个服务，登陆成功之后这个sshd会帮你创建子进程，然后创建一个bash，所以我们沟通(输入命令行)的时候其实是在和bash沟通。
④进程之间的独立性 杀掉子进程不会影响父进程
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d3ad3c0cf07dd3d3afde490de580d01/" rel="bookmark">
			OpenCv中matchShapes()函数的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		cv::matchShapes()函数的使用 在老版本的OpenCV中，该函数的原型为cvMatchShapes（），其使用方法可以参考博客：https://blog.csdn.net/hhy018/article/details/39080947
在OpenCv3及以上的版本中保留了cvMatchShapes（）函数；但这里主要介绍与其功能一样的matchShapes（）函数，相比与之前的版本，该函数使用起来更加方便，对向量和Mat类的支持度更好。
1.参数解释
参考网站：https://docs.opencv.org/4.5.5/d3/dc0/group__imgproc__shape.html#gaadc90cb16e2362c9bd6e7363e6e4c317
contour1：轮廓向量或者灰度图。
contour2：轮廓向量或者灰度图。
method：使用的比较方式。
parameter：现在没用，直接设为0。
注：contour1与contour2无顺序之分；contour的类型一般为vector的点集,由findContours（）函数求出，也可以自己给定；coutours还可以是双通道的Mat矩阵。
method的具体枚举类型及对应的计算方法请参考：
method用法介绍
下面用两张图片来进行演示：
图片使用Windows自带软件-画图进行绘制的，大家可以绘制自己的两张图用于验证程序。注意确保只有黑白两色。
这两张图片里面的物体轮廓形状、大小完全一样。第二个图片相对于第一个旋转了90度。图片里面只有黑白两个颜色，所以确保我们在一张图片中只会检测到一个轮廓，可以方便我们的演示。
下面依次提取这两个轮廓，并进行匹配。预期结果是完全匹配，程序输出的匹配结果为0。
2.示例代码：
#include&lt;vector&gt; #include&lt;iostream&gt; #include "opencv2/imgcodecs.hpp" #include "opencv2/highgui.hpp" #include "opencv2/imgproc.hpp" using namespace std; using namespace cv; int main() { Mat img1 = cv::imread("C:\\Users\\86994\\Desktop\\1.png"); // 读入图片1 Mat img2 = cv::imread("C:\\Users\\86994\\Desktop\\2.png"); // 读入图片2 Mat img1_copy = img1.clone(); // 深拷贝图片，用于后面在其上绘制轮廓 Mat img2_copy = img2.clone(); // 初始化存储轮廓的向量 vector&lt;vector&lt;Point&gt;&gt;contours1; vector&lt;vector&lt;Point&gt;&gt;contours2; // 初始化轮廓层次结构存储向量 // Vec4i为OpenCV内置的四维向量（数组）,里面的数据为int类型 std::vector&lt;cv::Vec4i&gt; hierarchy1; std::vector&lt;cv::Vec4i&gt; hierarchy2; cv::cvtColor(img1, img1, cv::COLOR_BGR2GRAY); // 灰度化img1 cv::cvtColor(img2, img2, cv::COLOR_BGR2GRAY); // 灰度化img2 threshold(img1, img1, 150, 255, THRESH_BINARY); // 二值化去掉不必要的杂色，大于150的灰度值置为255 threshold(img2, img2, 150, 255, THRESH_BINARY); Mat canny1, canny2; // 边缘检测为找轮廓做准备。因为我这里的图片很简单，这样就可以了。 // 实际中可能需要其它很多方法的辅助方法才能找到自己想要的边缘。 //cv::Canny(img1, canny1, 100, 200); //cv::Canny(img2, canny2, 100, 200); // 建议使用拉普拉斯计算边缘，比canny能更好地检测出主体成分，避免噪声干扰 Laplacian(img1, canny1, 16); Laplacian(img2, canny2, 16); // 求取第一个轮廓，因为我的轮廓是画出来的，为了简单演示，只会有一个轮廓 // 把这个轮廓作为比较的标准 findContours(canny1, contours1, hierarchy1, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE, Point(0, 0)); // 求取第二个轮廓，它只是相对于第一个轮廓旋转了90度 findContours(canny2, contours2, hierarchy2, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE, Point(0, 0)); // 多边形拟合以及打印轮廓的一些几何信息 vector&lt;Point&gt; cont1, cont2; approxPolyDP(contours1[0], cont1, 2, true); // 多边形拟合，减少不必要的点 approxPolyDP(contours2[0], cont2, 2, true); cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d3ad3c0cf07dd3d3afde490de580d01/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/277c8e7d94717d842efa65c6b2fffec3/" rel="bookmark">
			使用Vue&#43;ElementUI实现的手机验证码校验、倒计时和禁用效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、效果展示 二、代码部分 1、html部分 &lt;el-form-item label="手机号" prop="phone"&gt; &lt;el-input style="width: 320px" v-model="regForm.phone" clearable&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label="验证码" prop="code"&gt; &lt;el-input style="width: 320px" v-model="regForm.code" clearable&gt; &lt;el-button slot="suffix" style="color: blue;float: right" :disabled="disabled" @click="getCode" &gt; {{btnTxt}} &lt;/el-button&gt; &lt;/el-input&gt; &lt;/el-form-item&gt; 2、vue.js部分 &lt;script&gt; import instance from "../utils/request"; export default { name: "register", data() { let validatePhone = (rule,value,callback)=&gt;{ /*console.log(rule); console.log(value); console.log(callback);*/ if (!value){ callback(new Error('手机号不能为空')); } //使用正则表达式进行验证手机号码 if (!/^1[3456789]\d{9}$/.test(value)){ callback(new Error('手机号不正确')); } //自定义校验规则 需要调用callback()函数！ callback(); }; return { //验证码部分所需的数据 btnTxt:"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/277c8e7d94717d842efa65c6b2fffec3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c37de2f84d2f65692692dab792c9495a/" rel="bookmark">
			2022最新前端高频面试题总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.什么是mvvm 、 mvc 模型？ Mvvm：
Model 指的是后端传递过来的数据
View 指的是所看到的页面
ViewModel 指的是连接模型和视图
MVVM的目标和思想MVP类似它是一种双向数据绑定的模式，用viewModel来建立起model数据层和view视图层的连接，数据改变会影响视图，视图改变会影响数据
Mvc：
MVC即model-view-controller（模型-视图-控制器）是项目的一种分层架构思想，它把复杂的业务逻辑，抽离为职能单一的小模块，每个模块看似相互独立，其实又各自有相互依赖关系。它的好处是：保证了模块的智能单一性，方便程序的开发
2.vue双向数据绑定的原理？ vue.js 是采用数据劫持 结合 发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调
3.谈谈vue的生命周期？ 1.介绍生命周期的类别：
vue 实例从创建到销毁的过程就是生命周期。
常见的四大阶段八大钩子函数
创建前后 beforeCreate / created
渲染前后 beforeMount / mounted
更新前后 beforeUpdate / updated
销毁前后 beforeDestroy / destroyed
另外三个生命周期函数不常用
keep-alive 主要用于保留组件状态或避免重新渲染。
activated只有在keep-alive 组件激活时调用。
deactivated只有在keep-alive 组件停用时调用。
生命周期的加载： 在加载一个组件后：
如果没有keep-alive，则经历前面四个阶段即beforeCreate到mounted
有keep-alive，分第一次和第二次，第一次加载五个阶段即前面四个加上activated
第二次则只有activated
4.v-if 和v-show有什么区别？ V-if是“真正”的条件渲染，操作的实际上是dom元素的创建或者销毁
V-show，不管初始条件，元素总被渲染，基于css切换，操作的是display里面的none或者block属性
v-if 有更高的切换开销，而v-show有更高的初始渲染开销。
因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用v-if
5.async 与await 是什么？它有哪些作用？ async与 await 可以理解为generate的语法糖，它的作用就是 async 用于申明一个 function 是异步的，而 await 用于等待一个异步方法执行完成。它可以很好的替代promise 中的then
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c37de2f84d2f65692692dab792c9495a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58bbac825bf4b5ecddb914fbd38baeb1/" rel="bookmark">
			如何求出二值图像中物体的个数、最大物体的面积（算法思路，无代码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
这2个问题中，其实求出个数的时候就已经能够很简单地求出最大物体的面积了。相关算法的过程其实与二部图算法及其相似。
求物体的个数、面积
我们假设二值图像如上，1代表前景，0代表背景。那么这个图像一共有两个图形。 我们求取面积的方式如下：
1、复制一个与原图相同大小的矩阵，用于存每各像素值归属于哪个物体或者背景。我们可以设定背景为0，物体则按照序号编排。得到的矩阵如下：
2、遍历每一个像素值，如果该像素值是1（前景），且他的归属矩阵为0，则对他进行归属操作，并判断其周围的像素值是否可以被归属到与他同一个物体内。
例：（以八邻域为例）（1）如下图所示，我们经过遍历后发现了第一个可以进行归属的像素，并将它归属于第一个物体，随后开始判断其周围的像素是否可以被归属。
（2）我们对该像素周围的点进行判断后，发现有两个点可以被归属到与他同一个物体内，则对这两个点进行同样的操作。
（3）再对这些点周围的像素值判断后，我们可以发现两个新的点的归属值被赋值成1，然后我们对这几个新的点周围的像素点也进行归属判断。随后我们发现，第一个物体检索到这里已经结束了。
注：以上的操作看起来很复杂，其实都是在一个递归函数里面处理的，这个递归函数的输入为需要我们检索周围点的点的坐标，功能是将这个点的归属值变成我们的指定值，并对他周围的像素值为1，归属值为0的点进行递归。
（4）随后我们的主函数会继续向后遍历，由于之前遍历的时候，我们在下图方框的位置进行了一次归属的递归操作，因此我们遍历的下一个目标是下面这个圈圈的位置。那这么做会不会导致重新给这个物体进行归属递归呢？并不会，因为我们进行归属递归的前提是：这个点的归属值是0（背景）且像素值为1。 这就说明，我们对一个物体进行了归属递归后，这个物体中每一个点都不会再被执行归属递归，也就是说，一个物体只会进行一次归属递归。所以我们就可以大胆地添加一个变量，在每一次归属递归后将这个变量+1，来区分不同的物体。
（5）最终得到的图如下：
那么，由于我们有一个变量来计算下一个物体的编号（如物体1检索完毕后，这个值变成2，物体2检索完毕后，这个值变成3，这个值会在每次归属递归的时候被作为归属值传递给递归函数），因此，我们在最后结束所有的归属操作后，这个变量-1就是当前图像中的物体个数。我们可以创建与物体个数大小的数组，遍历求取每一个归属值所包含的像素个数，即为每一个物体的面积。如上图，物体1对应面积为5，物体2对应面积为3。
本来要讲一下周长的做法的，发现我周长的代码写错了，在极端情况下无法通过，就不讲了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8183dbafc936edd96de3ed568895506/" rel="bookmark">
			C语言：阶乘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一个正整数的阶乘（factorial）是所有小于及等于该数的正整数的积，并且0的阶乘为1。自然数n的阶乘写作n!。1808年，基斯顿·卡曼引进这个表示法。亦即n!=1×2×3×...×n。阶乘亦可以递归方式定义：0!=1，n!=(n-1)!×n。
递归实现（以及n的阶乘和） int fun(int n) { if (n == 1) { return 1; } else { return n * fun(n-1); } } int main() { int a,i,sum=0; printf("请输入n的值:"); scanf("%d", &amp;a); printf("%d的阶乘是:%d", a, fun(a));//计算n的阶乘； //扩展到计算n的阶乘之和; for (i = 1; i &lt;= a; i++) { sum += fun(i);//;累加阶乘; printf("\t%d的阶乘是%d\n", i, fun(i)); } printf("%d的阶乘之和为%d\n", a, sum); return 0; } ^0^ ^0^ for循环实现 int main() { int i, j, n, sum = 0,num = 0; printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e8183dbafc936edd96de3ed568895506/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff53d499727855d427149bd902b07253/" rel="bookmark">
			Android WebView 隐藏缩放按钮控件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android WebView 隐藏缩放按钮控件
webView = findViewByID（R.id.webView） WebSettings webSettings = webView.getSettings(); //隐藏WebView缩放按钮 webSettings.setDisplayZoomControls(false); 搞定！
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/265/">«</a>
	<span class="pagination__item pagination__item--current">266/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/267/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>