<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c13ca6e34fc10e21ecff8b882d49520b/" rel="bookmark">
			Android串口开发（android-serialport-api）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		谷歌在GitHub上有个实例，下载下来。地址如下： https://github.com/cepr/android-serialport-api
怎么在我们的代码中使用？ 1.先配置ndk的开发工具。获取CMakeLists.txt 文件 路径：AS中选择 File | Settings | Appearance &amp; Behavior | System Settings | Android SDK | SDK Tools
在SDK Tools中勾选安装CMake、LLDB、NDK。（如果有就勾选，好像安装后的AS中没有了）
配置好后新建一个AS工程（我的AS是3.5.2版本）
File | New | New Project 选择Native C++ （往下拉，一般在最下面）
2.在谷歌的工程代码中找到jni的文件夹中的 SerialPort.c和SerialPort.h文件复制到我们的\app\src\main\jni文件夹中 3.继续复制代码： android-serialport-api-master\android-serialport-api-master\android-serialport-api\project\src\android_serialport_api中的SerialPort.java和SerialPortFinder.java 复制到我们工程中的位置：在Java下新建文件夹android_serialport_api（必须是这个名字不能改动）
修改SerialPort.java中的最后一行代码：serial_port ----&gt;&gt; SerialPort
4.CMakeLists.txt放到app文件夹里面，然后修改CMakeLists.txt里面的代码（修改3个位置） 5.编译一下工程，然后在MyApplication\app\build\intermediates\cmake\debug\obj\armeabi-v7a\libSerialPort.so目录下生成一个so文件。 直接把这个so文件复制到我们的libs目录下
然后就可以使用串口了。
源码：https://download.csdn.net/download/qq_38524537/12589206
成功示例：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/393edc1116b5253a0010fab1f222dc9d/" rel="bookmark">
			python pandas 在现有excel中插入新数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在前面插入新的一列，或者在后面加入新一列 import pandas as pd filename = 'test.xlsx' df = pd.read_excel(filename) # 将数据框的列名全部提取出来存放在列表里 col_name=df.columns.tolist() # 一、将u_list插入到指定位置。 # 在列索引为2的位置插入一列。刚插入时不会有值，整列都是NaN # 比如说原来是a,b,c,d;我把新的一列插入到索引2，则变成a,b,新的一列,c,d col_name.insert(2, '新的一列') #二、将u_list添加到到后面位置 #比如说原来是a,b;现在想变成a,b,空白,空白,新的一列 #就先加入两个空值 col_name.append('') col_name.append('') col_name.append('新的一列') # DataFrame.reindex() 对原行/列索引重新构建索引值 df=df.reindex(columns=col_name) # 把新的数据，放到指定的列名下 # 新插入的数据u_list是从14&amp;16列的数据计算得来 df['新的一列'] = df['14列名称'] / df['16列名称'] 这样直接一步到位 # 将整个df写入excel（不分sheets） df.to_excel('piggy22.xlsx') 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/293600e5fcc2958bd905c9c4cf457e11/" rel="bookmark">
			【Unity 粒子系统】Collision 模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Collision 龙族语录属性结语 龙族语录 😁😊总有一些孤独，曾在我们左右；也总有一些孤独，离我们远去，让我们无从寻觅。一切都过去了，是的。阳光里，不会再有天使低下头来，亲吻你的脸。 --江南 《龙族》
属性 此模块控制粒子如何与场景中的游戏对象碰撞。使用第一个下拉选单可定义碰撞设置是应用于 Planes 还是应用于 World。如果选择 World__，请使用 Collision Mode__ 下拉选单定义碰撞设置是应用于 2D 还是 3D 世界。
Planes模块属性：
Planes：用于定义碰撞平面的变换的可以扩展列表。
Visualization：选择要将Scene视图中的碰撞平面辅助图标显示为线框网格还是实体平面。
ScalePlane：用于可视化平面大小。
Dampen：粒子碰撞后损失的速度比例。
Bounce：粒子碰撞后从表面反弹的速度比例。
LifetimeLoss：粒子碰撞后损失的总生命周期比例。
MinKillSpeed：碰撞后运动速度低于此速度的粒子将从系统中予以移除。
MaxKillSpeed：碰撞后运动速度高于此速度的粒子将从系统中予以移除。
RadiusScale：允许调整粒子碰撞球体半径，使其跟贴近粒子图形的可视边缘。
SendCollisionMessages：如果启用此属性，则可以从脚本中通过OnParticlecollision函数检测粒子碰撞。
VisuaizeBounds：在Scene视图中将每个粒子的碰撞边界渲染为线框形状。
World模块属性：
CollisionMode：3D或者2D
RadiusScale：2D或者3D
CollisionQuality：使用下拉选择菜单来设置粒碰撞的质量，此设置会影响有多少粒子可以穿过碰撞体。在较低的质量水平下，粒子有时会穿过碰撞体，但消耗资源少。（high碰撞始终使用物理系统来检测碰撞结果。Medium碰撞使用一组体素来缓存先前的碰撞，从而在以后的帧中更快的重用。Low，类似Medium，区别是粒子系统在每帧的查询次数少）
CollidesWith：粒子只会选择层上的对象发生碰撞。
MaxCollisionShapes：粒子碰撞可包括的碰撞形状个数。多余的形状会被忽略。
EnableDynamicColliders：允许粒子也与动态对象碰撞。（否则使用静态对象）动态碰撞体是未配置为Kinematic的任何碰撞体。
VoxelSize：体素表示三维空间中的常规网格上的值。使用Medium或Low质量碰撞时，unity会在网格结构中缓存碰撞。此设置控制着网格大小，较小的值可提供更高的准确性，但会占用跟多内存，效率也会低。
ColliderForce：在粒子碰撞后对物理碰撞体施加力。这对于用粒子推动碰撞体很有用。
MultiplybyCollisionAngle：向碰撞体施加力，根据粒子与碰撞体之间的碰撞角度来缩放力的强度。
MultiplybyCollisionSpeed：向碰撞体施加力，根据速度来缩放力强度。
MultiplybyParticleSize：向碰撞体施加力，根据粒子的大小缩放力强度。
结语 梦想就在那里，从来不会移动半步。
HIVE
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ffcc925bdf4f3bda489a9a2eece81436/" rel="bookmark">
			k-means 聚类方法，转 4/15
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		k-means 聚类
聚类算法有很多种，K-Means 是聚类算法中的最常用的一种，算法最大的特点是简单，好理解，运算速度快，但是只能应用于连续型的数据，并且一定要在聚类前需要手工指定要分成几类。
K-Means 聚类算法的大致意思就是“物以类聚，人以群分”：
首先输入 k 的值，即我们指定希望通过聚类得到 k 个分组；
从数据集中随机选取 k 个数据点作为初始大佬（质心）；
对集合中每一个小弟，计算与每一个大佬的距离，离哪个大佬距离近，就跟定哪个大佬。
这时每一个大佬手下都聚集了一票小弟，这时候召开选举大会，每一群选出新的大佬（即通过算法选出新的质心）。
如果新大佬和老大佬之间的距离小于某一个设置的阈值（表示重新计算的质心的位置变化不大，趋于稳定，或者说收敛），可以认为我们进行的聚类已经达到期望的结果，算法终止。
如果新大佬和老大佬距离变化很大，需要迭代3~5步骤。
说了这么多，估计还是有点糊涂，下面举个非常形象简单的例子：
有6个点，从图上看应该可以分成两堆，前三个点一堆，后三个点另一堆。现在我手工地把 k-means 计算过程演示一下，同时检验是不是和预期一致：
1.设定 k 值为2
2.选择初始大佬（就选 P1 和 P2）
3.计算小弟与大佬的距离：
从上图可以看出，所有的小弟都离 P2 更近，所以次站队的结果是：
A 组：P1
B 组：P2、P3、P4、P5、P6
4.召开选举大会：
A 组没什么可选的，大佬就是自己
B 组有5个人，需要重新选大佬，这里要注意选大佬的方法是每个人 X 坐标的平均值和 Y 坐标的平均值组成的新的点，为新大佬，也就是说这个大佬是“虚拟的”。因此，B 组选出新大哥的坐标为：P 哥（（1+3+8+9+10）/5，（2+1+8+10+7）/5）=（6.2，5.6）。
综合两组，新大哥为 P1（0，0），P哥（6.2，5.6），而P2-P6重新成为小弟。
5.再次计算小弟到大佬的距离：
这时可以看到P2、P3离P1更近，P4、P5、P6离P哥更近，所以第二次站队的结果是：
A 组：P1、P2、P3
B 组：P4、P5、P6（虚拟大哥这时候消失）
6.第二届选举大会：
同样的方法选出新的虚拟大佬：P哥1（1.33，1），P哥2（9，8.33），P1-P6都成为小弟。
7.第三次计算小弟到大佬的距离：
这时可以看到 P1、P2、P3 离 P哥1 更近，P4、P5、P6离 P哥2 更近，所以第二次站队的结果是：
A 组：P1、P2、P3
B 组：P4、P5、P6
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ffcc925bdf4f3bda489a9a2eece81436/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ab2ca4df829765119e65017991882f7/" rel="bookmark">
			Linux多用户实现资源分配，帮助命令及shell（bash特点）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux如何实现资源的分配
（一）资源分配
Linux基于Unix开发，是一个多用户的操作系统，而且Linux每个进程都拥有一套完整的资源集，所以Linux要实现关于系统CPU，内存和io资源的分配。
CPU：将CPU运行时间分为很短的时间片，按时间片把CPU分配给不同进程使用，在分配的时间片内不能完成其计算，该进程暂停运行，等待下一轮，然后下一进程使用，直到运行完所有进程。（因为计算机速度快，所以给每个用户的感觉是自己独占了一台计算机）
内存：先把每个进程都存进虚拟内存，然后通过映射分配到真实内存的相应位置（如果进程占用完内存，则下个进程不能再使用，否则内存溢出）
io资源：使用io复用技术，先读取一个进程的部分资源，再停下来读取另一个进程的部分资源，接着上个进程的读取进度继续读取，一直这样直到读取完所有资源。
进程：直白地讲，进程就是应用程序的启动实例。比如我们运行一个游戏，打开一个软件，就是开启了一个进程。进程拥有代码和打开的文件资源、数据资源、独立的内存空间。
（二）线程，进程与协程
线程：线程从属于进程，是程序的实际执行者。一个进程至少包含一个主线程，也可以有更多的子线程。线程拥有自己的栈空间。
协程：协程，英文Coroutines，是一种比线程更加轻量级的存在。正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程。
对操作系统来说，线程是最小的执行单元，进程是最小的资源管理单元。无论进程还是线程，都是由操作系统所管理的。而协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）。这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源。
Xshell命令
获取命令帮助
内部命令与外部命令：内部命令被构建在shell之中。当执行shell命令时，内部命令的执行速度非常快。这是因为没有其他的进程因为执行这条命令而被创建。比如，当执行“cd”命令时，没有进程被创建，在执行过程中只是简单的改变当前的目录。外部命令并没有被构建在shell中。这些可执行的外部命令保存在一个独立的文件当中。当一个外部命令被执行时，一个新的进程即被创建同时命令被执行。比如，当执行“cat”命令时，/usr/bin/cat就会被执行。
1.type 命令：判断命令是内/外部命令。
2.file 路径/命令：获取命令遵循的特定格式规范。
3.help 命令：获取内部命令的帮助（功能内容）------&gt;echo $? 看返回值判断命令是否正确。
4."–help"：获取大多数外部命令的帮助。
5.man命令：以全屏显示在线帮助，一般用man查看一个命令的帮助文档的时候，可以通过whatis查看一下该命令在man帮助文档中的入口，一条命令可能有多个man手册页入口（例如，whatis ls,1:用户指令，5：文件系统----&gt;man 1 ls查看）
man命令文本搜索：按q退出；上下键移动；空格键:向文件尾翻一屏；b: 向文件首部翻一屏； Ctrl+d：向文件尾部翻半屏； Ctrl+u：向文件首部翻半屏； 回车键：向文件尾部翻一行； k: 向文件首部翻一行； G：跳转至最后一行； #G: 跳转至指定行； 1G：跳转至文件首部。/keyword：从文件首部向文件尾部依次查找；不区分字符大小写. ?keyword：从文件尾部向文件首部依次查找.n: 与查找命令方向相同； N: 与查找命令方向相反。
6.info命令：另一种在线帮助，和man功能类似，更加详细。
Linux文本编辑工具vi/vim（vi----&gt;vim功能更多，比如语法着色，速度更高）
1.vim：是所有Unix及Linux系统下标准的编辑器，相当于Windows系统中的记事本，常用来编辑系统配置文件。
2.vimtutor：vim教程使用
3.vim模式及模式间切换：命令模式，输入模式，末行模式。命令–&gt;输入：i键。命令–&gt;末行：：键。输入/末行—&gt;命令：esc键。
4.命令模式操作键：↑↓←→（光标移动）；Page down/up（向下/上翻页）；home/end（跳至行首/尾）；gg/G/#G（跳文件行首/跳文件末行尾/跳文件第#行）
输入模式操作键
末行模式操作键：保存文件（:w)；退出vim（:q)；强制退出（:q!）；保存退出（:wq）。
shell
什么是shell：Linux系统的shell作为操作系统的外壳，为用户提供使用操作系统的接口。它是命令语言，命令解释程序及程序设计语言。是用户和Linux内核之间的接口程序，当从shell或其他程序向Linux传递命令时，内核会做出相应的反应，其程序存在于用户空间，是人机交互的屏障，对内核起保护作用。
shell程序是独特的程序，负责解析用户提供的命令，shell在解析这个命令的时候，第一个要做的就是找到这个命令，我们键入命令的最左侧是如何找到的（在内部提供了一个环境变量，在众多的环境变量中有一个叫PATH，echo $PATH 从哪些路径中查找用户键入的命令字符串对应的命令文件）
常见shell的种类
1.bash
大多数Linux系统默认使用的shell，bash shell是Bourne shell的一个免费版本，他是最早的unix shell，下面会重点说明bash。
2. sh
是一个快捷方式，已经被/bin/bash所取代
3. csh
C shell使用的是“类c”语法，csh是具有C语言风格的一种shell，内部命令有52个，较为庞大。目前使用不多，已被/bin/tcsh取代。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ab2ca4df829765119e65017991882f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b3981a7fb796a152c4849dce567a3d4/" rel="bookmark">
			java 配对问题_Java中的配对类是什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java 配对问题
Java Pair class stores two values in the form of a tuple. This can be useful to get a function to return two values.
Java Pair类以元组的形式存储两个值。 这对于使函数返回两个值很有用。 Java has an inbuilt Pair class from Java 8 onwards. That is why in this lesson we will not only look at the inbuilt pair class but also learn how to make our own pair class.
Java具有从Java 8开始内置的Pair类。 这就是为什么在本课中，我们不仅要看内建的配对类，还要学习如何制作自己的配对类。 Pair class is very useful when using a Tree data structure.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b3981a7fb796a152c4849dce567a3d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2563aaabcd6cb2b6784c35ef4eb443de/" rel="bookmark">
			编译android版本的opencv源码时，出现error：“to_string“ is not a member of ‘std‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在windows环境下编译opencv源码，参考：https://blog.csdn.net/xiao19950820/article/details/77119891进行编译，出现了几个问题记录一下。
1、在使用ndk版本的时候，最好用最新的版本，要注意一点是在选择cmake的时候，一定要注意选择对应的cmake，比如你的ndk是r18b,那cmake就要选择在build/cmake/下；
2、编译的时候出现error："to_string" is not a member of 'std' ，一开始根据网上说加 -std=c++11还是不行，后面再android.toolchain.cmake文件上，加上下面代码就可以了，具体原因：https://blog.csdn.net/eguoguo321/article/details/104006383
set(CMAKE_CXX_STANDARD 14)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
add_definitions(-D_GLIBCXX_USE_C99=1)
补充：后面编译的时候再次遇到这个问题，我根据下面的方法，还是不行，最终给我找到了原因：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee23d7976c4e6581de7cc0ae4d647f5d/" rel="bookmark">
			XMPP MUC基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MUC基础
概念
MUC(Multi User Chat)，XMPP在其XEP-0045扩展中定义的一个用于多用户文本会议（群聊）的协议，类似于互联网中继聊天(IRC)，提供通道或房间让大家能互相交流信息,并查看用户在线情况。
特征
1 每个参与者都可以分享消息(不包含游客Visitor)
2 每个参与者都可以获取聊天室的联系人名单
3 参与者通过昵称标识而不是真实的JabberID
4 聊天室内分享所有参与者的出席情况
5 参与者不局限于人(例:智能机器人)
名词
房间：房间的JID标识 &lt;room@service&gt;(例如：teaparty@conference. ejabberd.org)，这里 “room” 是房间的名称而 “service” 是多用户聊天服务运行所在的主机名
房客：房客的JID标识&lt;room@service/nick&gt;，nick是房客在房间的昵称
岗位：表达了用户和房间的长期关系(永久)，所有者(owner)-必须、管理者(admin)-推荐、成员(member)-推荐、排斥者(outcast)-推荐，岗位被授予，撤销，和维护都是基于用户的纯JID
角色：表达了用户和房间的临时联系，它只存在与一次访问期间(暂时)，主持人(moderator)-必须、与会者(paticipant)-必须、游客(visitor)-推荐，角色的授予，撤销，和维护是基于房客的房间昵称或全JID，而不是纯JID
岗位角色权限
1 owener：包含admin所有功能以及指定admin及销毁聊天室
2 admin：能查看会话内容、发言、踢出参与者和游客并禁止他们进入聊天室、控制他人发言的权利， 查看成员真实的JID、指定member和moderator、重新配置聊天室信息等
3 member：可加入聊天室、查看会话内容、发言（member与participant的区别在于是否注册， member是已注册的用户）
4 outcast：无法进入聊天室，被某个聊天室禁止的用户
5 moderator：能查看会话内容、发言、踢出参与者和游客、控制他人发言的权利
6 participant：即可查看会话内容又可发言
7 visitor：能进入聊天室，查看会话内容但是无法发言
房间类型
1 Hidden Room(隐藏房间) – 一个无法被任何用户以普通方法如搜索和服务查询来发现的房间; 反义词: 公开(public)房间
2 Public Room(公开房间) – 用户可以通过普通方法如搜索和服务查询来发现的房间; 反义词: 隐藏房间
3 Members-Only Room(仅限会员的房间) – 如果一个用户不在成员列表中则无法加入的一个房间; 反义词: 开放(open)房间
4 Open Room(开放房间) – 任何人可以加入而不需要在成员列表中的房间; 反义词: 仅限会员的房间
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee23d7976c4e6581de7cc0ae4d647f5d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a88139c59f78020ca43c0a17df896032/" rel="bookmark">
			【Vue异常】Vue报错“Trailing spaces not allowed”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文目录
一、错误信息
二、报错原因
三、解决方案
一、错误信息 最近在使用vue开发前端工程，但是在VSCode中开发Vue中 报错：“Trailing spaces not allowed”，详情报错信息如下：
二、报错原因 是因为多出了一个（或者多个）空格，把多余的空格删除就可以了
三、解决方案 把自己修改的文件，仔细找一下，将多余的空格删除就可以即可解决这个问题
完结！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7978bd8216eae40aba7bfa7419ac884c/" rel="bookmark">
			设计模式之订阅/发布模式（subscribe/publish）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是订阅发布模式 订阅发布模式定义了一种 一对多 的依赖关系，一指发布者，比如某个主题对象，多指订阅者，依赖是订阅者对发布者的依赖；多个订阅者同时监听一个主题对象。当发布者即主题对象的状态发生变化时，会将该变化通知给订阅者，订阅者据此更新自己的状态。是设计模式中用的比较多的一种。
二、为什么使用订阅发布模式 订阅发布模式旨在降低系统不同模块之间的耦合度。一个复杂的系统一般要划分为好多不同的类，这些对象之间并不独立，存在各种协作关系，这就需要维护对象之间的一致性，这给系统的维护、重用和扩展带来不便，严重限制了系统的灵活性。这样就可以把主动变化因素抽象出来形成发布者，而其他依赖者抽象为订阅者，使他们可以独立的被复用和维护。双发都只依赖与抽象，而不是依赖于具体实现。比如发布者新增一个订阅者时只需要发布者注册一下，订阅者新增依赖时，只需要将自己注册到新的发布者即可。
三、实例： 有一个天气预报系统，负责通知明天的天气情况。有几个角色订阅了该系统，他们根据明天的天气情况安排明天的事务。这几个角色分别为农夫、建筑工人、程序员。
下雨天
农夫喜出望外：又可以好好歇一天了，让庄稼庄稼好好成长吧；
建筑工人欣喜万分：完美，睡到天昏地暗；
程序员：继续上班，关我毛事；
日晴万里
农夫感慨：即将迎接充实的一天，收获满满；
建筑工人牢骚：这么大太阳，苦逼的一天；
程序员：继续上班，关我毛事；
使用Java语言具体实现过程：
1.发布者接口：
/*发布者接口,定义注册发布者,删除发布者,发布消息的接口*/ public interface IWeather { void addSubscriber(ISubscriber subscriber); void delSubscriber(ISubscriber subscriber); void publishInfo(String msg); } 复制代码 2.发布者具体实现
import org.apache.log4j.Logger; import java.util.ArrayList; import java.util.List; /*发布者具体实现类*/ public class WeatherServer implements IWeather { private static final Logger logger = Logger.getLogger(WeatherServer.class); /*用来保存注册了的所有订阅者*/ private List&lt;ISubscriber&gt; subscribers = new ArrayList&lt;ISubscriber&gt;(); public void addSubscriber(ISubscriber subscriber) { subscribers.add(subscriber); logger.info( "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7978bd8216eae40aba7bfa7419ac884c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02dc29f39a1725ea27beb9a7c16f3d3e/" rel="bookmark">
			Altium Designer 学习总结 分享！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		报错翻译成汉语意思是：设计包含搁置或修改（但未注入）的多边形。
DRC的结果将不正确。
你想继续吗？
注意：建议先停止DRC并还原/恢复所有多边形，然后再继续操作。
解决办法：
进入敷铜管理器—重新敷铜
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d3f2aea85edb2b3fe37040471b52e78/" rel="bookmark">
			MFC CDC类 SetMapMode()函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个函数是我们在用MFC打印之前就需要设置好的。因为我们在MFC里面操作的是逻辑单位，而这个东西是没有真实的单位的，并且不同的电脑可能还会有区别。因此，我们要使用这个函数设置一个映射模式，即设置好一个逻辑单位到底对应的物理世界里面的长度是多少。
我来给翻译一下，具体内容都是来自的MSDN.
MM_ANISOTROPIC
逻辑单元被转换为任意坐标轴上的任意单元。将映射模式设置为MM_ANISOTROPIC不会更改当前窗口或视口设置。若要更改单位、方向和缩放，请调用 SetWindowExt 和 SetViewportExt 成员函数。
MM_HIENGLISH
一个逻辑单位转换为0.001英寸。x右为正，y上为正。
MM_HIMETRIC
一个逻辑单位转换为0.01毫米。x右为正，y上为正。
MM_ISOTROPIC
逻辑单位被转换为具有相等比例轴的任意单位，即沿 x 轴的1个单位等于沿 y 轴的1个单位。使用 SetWindowExt 和 SetViewportExt 成员函数指定所需的单位和轴的方向。GDI 根据需要进行调整，以确保 x 和 y 单位保持相同的大小。
MM_LOENGLISH
一个逻辑单位转换为0.01英寸。x右为正，y上为正。
MM_LOMETRIC
一个逻辑单位转换为0.1毫米。x右为正，y上为正。
MM_TEXT
一个逻辑单位转换为一个设备像素。x右为正，y下为正。
MM_TWIPS
逻辑单位转换为1/20的一个点。(因为一个点是1/72英寸，所以一个 twip 是1/1440英寸。)正 x 在右边，正 y 在上面。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24633a3625a0da62d2bea1115e5d415b/" rel="bookmark">
			使用node.js构建服务模拟数据接口demo
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先了解几个依赖管理工具（相当于后端开发的maven）： 1.npm： node自带，安装依赖包从国外下载，速度较慢
2.cnpm：需要手动安装，从淘宝镜像下载，速度较快
3.yarn: faceBook出品，也是从国外下载，速度较慢
如何构建服务？(基于express框架进行构建) （1）生成package.json（依赖管理，设置命令）： npm init -y
(2)安装express依赖包： npm install express -s
(3)编写server.js
//node服务 var express = require("express"); //导入express框架 var app = express(); //生成实例 //实现第一个接口 app.get("/api/index",function(req, res){ res.send("index page") }) app.listen(3000,function(){ console.log("服务已启动，监听3000端口") }) (4) 启动服务 ：node XXX.js
(5) 浏览器访问接口：
http://127.0.0.1:3000/api/index
至此，一个简单的基于node的服务端已经搭好，可以根据自己的需要在server.js配置你的接口名称，以及返回的数据
接下来继续使用express框架实现一个简单的restful风格的Api小demo 首先，安装需要用到的参数解析器：
npm install body-parser -s
//node服务 var express = require("express"); //导入express框架 var bodyParser = require("body-parser") //http请求参数解析 var app = express(); //生成实例 //配置参数解析 app.use(bodyParser.json()) app.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/24633a3625a0da62d2bea1115e5d415b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b3df970274d486ac9864ec24adf1b15/" rel="bookmark">
			CSS(一) 经典布局（两边固定，中间自适应）的五种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		两边固定，中间自适应 本篇总结五种思路实现方式，
圣杯布局 圣杯布局，方便理解是带有两只耳朵的奖杯，耳朵跟奖杯是一体，所以左右两边跟中间同级，但是content在上面
第一步：中间盒子100%，两边固定宽度，三个盒子依次上下
第二步：子盒子全左浮动 left与right脱离文档流 在第二行
第三步：父级盒子不要给宽度，padding：0 200px;留出左右盒子位置
第四步： left 盒子
（1）margin-left:100% 先将浮动元素向上移动一行文档流‘
（2）position：relative；left：自身宽度 ；微调left位置(此处可以用position：absolute 也行)
第五步：right盒子使用margin-right：自身宽度
第六步：清除浮动，不然可能带来高度塌陷问题
代码如下：
CSS
&lt;style&gt; *{ margin: 0; padding: 0; } html,body{ height: 100%; overflow: hidden; } .clearfix:after,.clearfix:before{ content: ""; display: table; } .clearfix:after{ clear: both; } .clearfix{ *zoom: 1; } .main{ position: relative; padding: 0 200px; min-height: 400px; } .content,.left,.right{ float: left; } .content{ width: 100%; min-height: 500px; background-color: hotpink; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b3df970274d486ac9864ec24adf1b15/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2b197eb1c2ce0bd42c03f9e9f3fbc9c/" rel="bookmark">
			云服务器80端口_怎么查看_放开端口检测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是云服务器80端口？
80端口是HTTP服务器默认的端口，比如我们访问百度 www.baidu.com 实际上访问的是 www.baidu.com:80，因为浏览器默认帮我们指定为:80，所以无需输入。
80端口是用在网站服务上（http服务），所以web服务器必须监听80端口后访客才能与该端口通信。
其实端口只是一个接口，用来给具体服务监听，并没有实际的意思，只有对应的服务监听了相应的端口，端口才具有意义。
如何检测云服务器中哪个程序监听了80端口？
Linux系统云服务器
命令 netstat -lnp ，可以看到Nginx服务（进程）监听了80端口（以下使用硅云CVM云服务器测试，CentOS系统）
Windows系统服务器
命令 netstat -ano 可以看到进程ID为86832的服务监听了80端口（以下使用硅云CVM云服务器测试，Windows Server系统）
知道服务的进程ID，就可以通过任务管理器查看服务是否为你的WEB服务器，检测端口是否被占用的情况。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef256ea236aed442344d57312bbb6c9a/" rel="bookmark">
			android开机动画到桌面黑屏解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开机过程，从android动画到桌面显示的时候会有黑屏现象，网上也有很多解决办法，这里介绍的方法用的是通过判断一个标志位，当标志位还没有为1时，android动画BootAnimation::checkExit()不能退出，直接返回；当真正进入桌面后，把标志位设为1，BootAnimation::checkExit()才能退出，真正完成开机动画的播放
播放动画结束标志
frameworks\base\cmds\bootanimation\BootAnimation.cpp
static const char EXIT_ANIM_NAME[] = "persist.bootanim.exit";//自定义属性 void BootAnimation::checkExit() { // Allow surface flinger to gracefully request shutdown char value[PROPERTY_VALUE_MAX]; char jvalue[PROPERTY_VALUE_MAX]; property_get(EXIT_PROP_NAME, value, "0"); property_get(EXIT_ANIM_NAME, jvalue, "0"); int exitnow = atoi(value); int jexitnow = atoi(jvalue); if (exitnow) { if(jexitnow == 0) { retrun; } requestExit(); mCallbacks-&gt;shutdown(); } } frameworks\base\services\core\java\com\android\server\am\ActivityRecord.java
private boolean checkBootAnimationCompleteLocked() { //if (SystemService.isRunning(BOOT_ANIMATION_SERVICE)) { if(!"1".equals(SystemProperties.get("service.bootanim.exit", "0"))){//判断标志位是否已经为1 mH.removeMessages(H.CHECK_IF_BOOT_ANIMATION_FINISHED); mH.sendEmptyMessageDelayed(H.CHECK_IF_BOOT_ANIMATION_FINISHED, BOOT_ANIMATION_POLL_INTERVAL); if (DEBUG_BOOT) Slog.i(TAG_WM, "checkBootAnimationComplete: Waiting for anim complete"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef256ea236aed442344d57312bbb6c9a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f97acb1d43913f0af62379eea76cf69/" rel="bookmark">
			new，浅拷贝，深拷贝的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		clone与new的区别，new意味着内存空间的分配，在new对象的过程中，系统会首先查看new关键字后面的类型，然后根据类型分配空间，然后在调用构造函数为对象赋值，
Clone分为深拷贝和浅拷贝，默认情况下是浅拷贝。clone的对象必须实现cloneable接口才能进行clone。
浅拷贝，是指在对象调用clone方法后，在内存中分配一块与原对象相同大小的额内存空间，然后将原对象的字段对应的值给拷贝到clone后的新对象中。但是原对象中的字段可能存在基本数据类型以及引用类型，如果是基本数据类型，则直接将值拷贝到新对象中，如果是引用类型，浅拷贝会将该字段的引用地址拷贝到新对象中，如果是深拷贝，则会将该字段引用地址再复制一块出来进行引用。要实现真正的深拷贝必须所有的引用类型都实现了Cloneable接口。否则为不完全的深拷贝
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a6d778eadc3bb1ae2fee8768fdf3979/" rel="bookmark">
			win10安装docker踩坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.安装docker desktop失败。最近想学下docker。然后在docker官网上下载了Docker Desktop Installer。发现本win10家庭版并不支持这个版本。
报Docker Desktop requires Windows 10 Pro/Enterprise (15063+) or Windows 10 Home (19018+).
2.安装DockerToolbox成功。后面在网上找了一下，说DockerToolbox可以支持此windows版本，于是遂下载安装。
安装过程很顺利，安装完后，桌面上出现了这2个图标：
3. docker toolbox启动失败。原因是缺少Boot2Docker镜像文件：
需要手动从 https://github.com/boot2docker/boot2docker/releases 下载 boot2docker.iso,
将boot2docker.iso 复制到到C:/Users/YourAccount/.docker/machine/cache 目录下，
然后启动就不会报这个错啦。
4.没错，还会报别的错：
Error creating machine:Error in driver during machine creation: Unable to start the VM: C:\Program Files\Oracle\VirtualBox\BoxManage.exe startvm default --type headless failed:
VBoxManage.exe: error:Failed to open/create the internal network 'HostInterfaceNetworking-vertualBox Host-Only Ethernet adapter #2(VERR_INTNET_FLT_IF_NOT_FOUND)'
百度到大部分的解决方案都是安装Hyper-v，但实际上这个win版本根本装不了hyper-v.
后面发现可能是oracle virtual box的问题。
5.把oracle virtual box 从5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a6d778eadc3bb1ae2fee8768fdf3979/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dfb173d42e4a7737e0e339ab7d5e6481/" rel="bookmark">
			springboot 注解说明（@ConditionalOnProperty）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		springboot 注解说明（@ConditionalOnProperty） 应用：根据配置文件的属性决定是否将类注册为bean
********************** 相关类与注解
@ConditionalOnProperty：标注在类或者方法上
@Retention(RetentionPolicy.RUNTIME) @Target({ElementType.TYPE, ElementType.METHOD}) @Documented @Conditional({OnPropertyCondition.class}) public @interface ConditionalOnProperty { String prefix() default ""; //prefix可不设置 String[] name() default {}; String[] value() default {}; //name、value有且只能设置一个，否则会报错 String havingValue() default ""; boolean matchIfMissing() default false; } 匹配规则：属性文件中查找key（prefix+"."+name）
属性文件中设置了key的值value：
ConditionalOnProperty设置了havingValue：value=havingvalue则匹配，若不等则不匹配
ConditionalOnproperty没有设置havingValue：value不等于false则匹配，若为false，则不匹配
属性文件中没有设置key：
ConditionalOnProperty中matchingIfMissing：true匹配，false不匹配
@Conditional
@Target({ElementType.TYPE, ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) @Documented public @interface Conditional { Class&lt;? extends Condition&gt;[] value(); //继承condition的类数组 } Condition
@FunctionalInterface public interface Condition { boolean matches(ConditionContext var1, AnnotatedTypeMetadata var2); } OnPropertyCondition
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dfb173d42e4a7737e0e339ab7d5e6481/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ffb40afce69761362357dd98f34907ee/" rel="bookmark">
			check point 关闭开机自启动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		公司用 check point管理内网，电脑安装之后每次都开机自启，有点烦，所以就把开机自启动给禁用了，使用脚本的方式启动服务和程序，这样就不用忍受开机弹窗了。
1.windows 服务禁用 这两个服务
2.禁用 check point 开机自启(我这里用360，其他办法能禁止开机自启动也可以)
这样checkout 开机就不会启动了，但是双击check point 程序启动 是不能用的，因为服务还没有启动，所以需要用bat脚本来实现服务和程序同时启动
3. 新建bat脚本
net start "TracSrvWrapper" start "" "D:\Program Files (x86)\CheckPoint\Endpoint Connect\TrGUI.exe" exit %退出并关闭命令行窗口% 4. 给bat脚本创建快捷方式并设置管理员权限
这样双击 bat脚本就可以启动 check point 并正常使用了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18d1dc443e5fa2ef27d3d98ee4f9a8be/" rel="bookmark">
			SpringBoot&#43;Websocket&#43;Vue的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpringBoot+Websocket+Vue的使用 首先是对websocket进行讲解
简介 WebSocket 是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。WebSocket 使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。在 WebSocket API 中，浏览器和服务器只需要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。
HTML5 定义的 WebSocket 协议，WebSocket 是独立的、创建在 TCP 上的协议;Websocket 通过HTTP/1.1 协议的101状态码进行握手;为了创建Websocket连接，需要通过浏览器发出请求，之后服务器进行回应，这个过程通常称为“握手”（handshaking）。它能更好的节省服务器资源和带宽，并且能够更实时地进行通讯[1]。
[1] HTML5 WebSocket 菜鸟教程
WebSocket使得客户端和服务器之间的数据交换变得更加简单
整合到SpringBoot 依赖：
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt; &lt;/dependency&gt; ServerEndpointExporter DI
@Configuration public class WebSocketConfig { @Bean public ServerEndpointExporter serverEndpointExporter(){ return new ServerEndpointExporter(); } } 配置服务
@ServerEndpoint("/room/{nickName}") public class WebSocketServerService { /** * 建立会话 * * @param session 会话 * @param nickName 昵称 */ @OnOpen public void onOpen(Session session, @PathParam("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/18d1dc443e5fa2ef27d3d98ee4f9a8be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17234f7d7ecfbb1cf9bfc315deac5d8f/" rel="bookmark">
			GO语言从入门到达人--用户管理机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用户注册
1.如果GET请求则请求html页面，如果POST请求则请求接口
func SignUpHandler(w http.ResponseWriter,r *http.Request){ if r.Method == http.MethodGet{ data,err := ioutil.ReadFile("./static/view/signup.html") if err != nil { w.WriteHeader(http.StatusInternalServerError) //500错误 } w.Write(data)//将html页面输出 }else { r.ParseForm() //将post来的数据进行解析 username := r.Form.Get("username") password := r.Form.Get("password") if (len(username) &lt; 3 || len(password) &lt; 5) { //对于传递过来的数据进行校验 w.Write([]byte("Invaild paramter")) return } enc_password := util.Sha1([]byte(password + pwd_salt)) //将密码进行加密处理 suc := delay.UserSignUp(username, enc_password) //处理注册逻辑 fmt.Println(suc) if suc { w.Write([]byte("success")) } else { w.Write([]byte("fail")) } } } util文件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/17234f7d7ecfbb1cf9bfc315deac5d8f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c04d1bb4c1cebc0f47a38e8db345a27/" rel="bookmark">
			y7000风扇清灰
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天周末，有时间了给电脑风扇清一下灰。
首先把电脑反过来，将螺丝拧下来。（需要螺丝刀和撬片，没有也可以找其他替代品） 向学长借的神器
从没有插口的那一端撬一下，不要急着打开。把左右usb口出撬一下，那里有两个扣，不撬开的话，可能会大力出奇迹。全部撬开以后就可以发现后盖可以轻松的拿下来了。 拿下后盖后，中间的金属板里面是内存条，这个金属板用手直接可以拿下来，想添内存条的童鞋可以直接买对应的版本安上去，很方便。拆风扇之前要把这个大家伙拿下来，不然风扇取不下来。
然后拧螺丝，把风扇取下来洗刷刷就好了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4bdfe575ff9572ef4db9566bf6e3075/" rel="bookmark">
			Deep Crisp Boundaries（CED）论文学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍 卷积网络得到的边缘检测图，是高度“正确”，但并不那么“清晰”的，这是由于，首先，在更具鉴别性的卷积顶层，特征的空间分辨率急剧降低，导致边缘输出模糊，再次，全卷积会导致相邻像素的相似应答（线性插值方式），因此也会影响细边缘的产生。提出了一种新的细化体系结构，灵感来自最近在密集图像标记方面的进展，细化路径为网络增加了额外的非线性，进一步减少了相邻像素内边缘响应之间的相关性。本文对ConvNet的边缘图进行了系统的研究。结果表明，ConvNet具有良好的边缘像素分类能力，但定位能力较差；本文将细化方案和亚像素卷积组合成一种新的体系结构，这是专门为学习脆边检测器而设计的；
在BSDS500上的结果在所有匹配距离上都优于最先进的方法。本文还表明，清晰的边缘映射可以改善光流估计和目标提案的生成。 相关工作介绍： 早期的边缘检测，手动设计的，基于强度、颜色、纹理等近期的边缘检测，基于有监督的学习，被认为是像素点二值标记问题，例如Sketch Tokens、随机森林、结构性随机森林、SVM等进行学习最近的边缘检测，基于卷积神经网络，如HED及其扩展等本文提出的CED，跟HED网络不一样， 提出了用于分割对象的细化体系结构，采用自顶向下的路径来标记边缘的稀疏二元信号， 用亚像素卷积代替双线性插值（反卷积），这对于产生更好的局部化、锐利的边缘输出至关重要。 从卷积网络中学到的： 为什么HED可以得到这么高的分数，作者认为是评价标准的问题，匹配方式由最大允许距离d控制，如果边缘像素与label像素距离小于d，也会被认为是正确的。 “脆度”可以通过降低基准中的d来衡量。人类的表现随d的下降更快，而HED随d的下降，比人类下降更快 CED网络结构 一方面是前馈传播，获取丰富的网络特征图，而一大特点是，用了一个反向细化路径（backward-refining path，也就是图中的橙色框，扩展开就是第二个虚线框中的结构）来补充HED网络，它使用有效的亚像素卷积逐步提高样本特征， 反向细化路径将特征映射与沿前向传播路径的中间特征融合，这个细化方式由多个细化模块一起组成，最终达到原图的分辨率。细化模块融合了一个自顶向下的特征映射和前传上的特征映射，并使用亚像素卷积向上采样。在进行融合的时候，通过减少两个特征映射的维数来实现融合（即降维，由于通道数不同，不得不这样做）。将输入前向路径特征映射的通道数表示为kh。 经过卷积和RELU运算后，信道被简化为k‘h，远小于kh。同样的操作从先前的细化模块对特征映射进行校正，从ku生成k‘u。将上述特征映射连接到一个新的具有k‘u+k’h通道的特征映射中，并将其减少，用k‘d通道通过3×3卷积层进行特征映射。从而降低了总体计算成本，平衡了两个输入特征映射。对于上采样，采用亚像素卷积操作，而非流行的反卷积操作，这样对于边缘的定位表现似乎更好。亚像素卷积不是通过单个反卷积层直接输出放大特征映射，而是由一个卷积层和一个跟随相移层组成的一种网络层。总体上看，参数量也比HED少了许多。 实验结果： 总结： 一句话概述本文特点就是，研究了HED网络，CED提出了细化的方案，即一、反向细化路径模块，以及二、采用亚像素卷积替代线性插值的全卷积，对于边缘定位效果更好。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27eb8a4c9ba37598bbf736db9fddf795/" rel="bookmark">
			微信小程序获取手机号 实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先吐槽，由于偷懒 某度一下 没发现完整的代码可以用，需要东拼西凑，没有拿来主义的感觉。
获取手机号 获取微信用户绑定的手机号，需先调用wx.login接口。
因为需要用户主动触发才能发起获取手机号接口，所以该功能不由 API 来调用，需用 button 组件的点击来触发。
注意：目前该接口针对非个人开发者，且完成了认证的小程序开放（不包含海外主体）。需谨慎使用，若用户举报较多或被发现在不必要场景下使用，微信有权永久回收该小程序的该接口权限。
以上是官方说的，根据官方说的实现
https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/getPhoneNumber.html
流程： 1.通过wx.login(Object object)获取登录凭证（code）。通过凭证进而换取用户登录态信息，包括用户的唯一标识（openid）及本次登录的会话密钥（session_key） wx.login({ success: res =&gt; { wx.request({ url: 'http://192.168.1.128:8088/app/wx/jscodeToSession', method: "POST", header: { 'content-type': 'application/x-www-form-urlencoded', 'Accept': 'application/json' }, dataType: 'json', data: { js_code: res.code, }, success(res) { that.globalData.session_key = res.data.data.session_key; that.globalData.openid = res.data.data.openid; }, fail(res) { console.log('拉取用户openid失败，将无法正常使用开放接口等服务', res) } }); // 发送 res.code 到后台换取 openId, sessionKey, unionId } }) @RequestMapping(value = "/jscodeToSession", produces = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/27eb8a4c9ba37598bbf736db9fddf795/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aeade9cefcbba2d0c91bc08670a67c24/" rel="bookmark">
			spring学习笔记_IOC反向控制部分
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开发步骤： 导包写实现类创建applicationContext.xml配置bean加载配置文件运行 Bean标签 id,getBean时的唯一标识class，全类名scope，singleton（单例随容器创建销毁），prototype（getBean时创建，GC机制来销毁），还有三个取值暂不看init-method,对象创建时执行对象的某个方法destroy-method，对象销毁时执行对象的某个方法 Bean对象的三种创建方式 无参构造，最常用，需要一个无参构造方法工厂静态，class属性配置工厂的全类名，factory-method配置工厂的静态方法，getBean得到的是该方法返回的对象工厂实例，首先为工厂配置一个bean标签，然后配置一个想要对象的bean标签该标签不配置class属性，配置factory属性，值为工厂标签的id值，并配置factory-method为工厂返回对象的普通方法 依赖注入 体现的一种方式就是controll层、service层、dao层中的体现。dao和service的实现类都交给ioc管理，service通过getBean获取dao，controll通过getBean获取service，controll只需要service这样就算是硬编码，依赖注入直接把dao注入到service中，不需要在从service中硬性获取，降低耦合性。
在service中声明一个dao对象，然后写它的set方法，在xml文件中service的bean标签声明一个子标签property，name取值规则是（setUserDao，那么name的值为userDao），ref属性为userDao的bean标签的id值
p-命名空间注入（了解即可） property的一种简单实现。
直接给bean添加属性，如果注入的是对象，p:userDao-ref=“userDao的id”。
依赖注入的类型 引用数据普通数据集合数据 基本配置图 Spring的API ApplicationContext
ClassPathXmlApplicationContext,从类的根路径下加载配置文件FileSystemXmlApplicationContext，从磁盘路径上加载配置文件AnnotationConfigApplicationContext，使用注解配置容器对象时，需要用它来创建spring容器，它用来读取注解 getBean方法使用
一种通过id获取，另一种通过Class文件类型获取。
如果容器中存在多个bean的class类型一致，那么第二种方式会报错。
Spring的properties文件引入 将beans的命名空间复制一份，把其中的beans全都改成context即可，引入如下，使用${key}
Spring原始注解 1-4是bean标签配置简化，5-8是依赖注入，9是scope，10是initmethod，11是destorymethod
注解的使用需要使用组件扫描，在applicationContext.xml中配置
//组件扫描的作用是告诉Spring在相应包下找注解并根据注解创建对象等工作 &lt;context:component-scan base-package="基本包名" /&gt; Component	表示该组件用于Spring生成一个bean	-&gt;Component:组件 @Component("user") Controller	表示该控制器用于Spring生成一个bean @Controller("user") Service	表示该业务逻辑类用于Spring生成一个bean @Service("user") Repository	表示该Dao类用于Spring生成一个bean -&gt;repository:贮藏室 数据封装基地 @Resipotory("user") Autowired	表示自动封装该属性,或者字段(可以省略set方法,根据字段Field即可,如果该字段是一个Bean,将通过Spring容器中查找该类型的Bean对象,用于封装该注解字段), @Autowired 根据该注解指定的字段,查询Spring容器中对应的bean对象,分配给当前类作为成员. Autowired默认是根据类型依赖注入.ByType,如果Autowired注解的是一个字段,并不能完整的体现面向对象的思想,最好是注解在set方法上. Qualifier	表示根据提供的修饰语 @Qualifier('xxx') -&gt; 匹配该xxx属性,若要使用该注解,必须配合AutoWire一起使用,而Autowire可以单独使用 @Autowire @Qualifier("user") 封装user注解的bean为本类对象的成员,根据名称注入 ByName,设置在字段上. @Qualifier常常使用在参数的赋值上 如: String getUsername(@Qualifier("user")User user){} Resource	是Aotuwire注解和Qualifier注解的结合体.@Resource("user"),标注为user的bean @Resource("user") 封装user注解的bean为奔雷对象的成员 == @Autowire @Qualifier 默认根据名称依赖注入,默认Resource() = Resource like Resource(name = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aeade9cefcbba2d0c91bc08670a67c24/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0f094d4b2c4fedce30908bcb3845a59/" rel="bookmark">
			【工具】Linux screen的在线安装和离线安装和使用（训练模型时非常有帮助）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		screen后台挂机神器 screen没接触的同学，还是建议接触一下，比如在你在服务器运行了某个程序，最常用的就是我们训练一个模型，时间很长，但是我们不能关闭它，因为关闭终端程序就断了，同样还有其他的操作能让它运行在后台，但是训练中的模型打印出来准确度损失值情况无法回顾和实时查看，这个时候screen就能很好的解决，等于你弄了一个窗口，在程序运行在该窗口中，你可以选择退出终端，但是只要我想看现在什么情况了通过命令就能把那个窗口调出来运行过程就一直在那，每一个记录也都在界面中。
screen在线安装和离线安装 安装分为怎么在线安装和离线安装，在线安装非常的简单，就是有网络情况下安装。离线安装指的是某种情况下，服务器上网络做了管控没有外网，不能直接下载，但是可以在其他有网的电脑上下载离线安装包拷贝到服务器上进行安装。
(1)在线安装screen sudo apt-get screen 很方便，就可以使用了。
（2）离线安装，服务器无网络。 第一步、在有网络的地方下载安装包 下载地址http://ftp.gnu.org/gnu/screen/
安装包 screen-4.6.0.tar.gz
http://ftp.gnu.org/gnu/ncurses/
很有必要是要下载ncurses-6.1.tar.gz
第二步、解压screen 将screen-4.6.0.tar.g拷贝到某路径下
解压：
tar -xzvf screen-4.6.0.tar.gz 然后进入解压目录：
cd screen-4.6.0 第三步、编译源码 先创建build文件 并进入build目录：
mkdir build &amp;&amp; cd build 运行配置程序：
../configure 没有错误跳到第五步
出现错误一般是要安装ncurses
第四步、安装Ncurses 类似上面的操作
tar -xzvf ncurses-6.1.tar.gz cd ncurses-6.1 mkdir build &amp;&amp; cd build ../configure make &amp;&amp; make install 安装完毕ncurses
第五步、重新进入安装目录 cd screen-4.6.0/build/ ../configure make &amp;&amp; make install 安装完成可以用了。
screen操作命令 至于怎么用screen,可以参考网上很多指导。
常用快捷命令：
screen -S 窗口名称 指定screen窗口的名称。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a0f094d4b2c4fedce30908bcb3845a59/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31b7e69b5430fe6f52adab890dc97121/" rel="bookmark">
			西加加：7-1 计算全班学生C&#43;&#43;课程的总成绩和平均成绩
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		定义一个类Student，记录学生C++课程的成绩。要求使用静态数据成员或静态成员函数计算全班学生C++课程的总成绩和平均成绩。
输入格式: 输入5个不超过100的正整数，作为C++成绩。
输出格式: 在第一行中输出成绩的和，第二行输出平均成绩。
输入样例: 90 80 70 60 50 输出样例: 350 70 代码实现： #include &lt;iostream&gt; using namespace std; class Student { static int total_score; static float average; int score; public: void Setscore() { int x; cin &gt;&gt; x; score = x; } int add() { total_score += score; return total_score; } int aver() { average *= total_score/5; } void show() { cout &lt;&lt; total_score &lt;&lt; endl; cout &lt;&lt; average &lt;&lt; endl; } }; int Student::total_score = 0; float Student::average = 1; int main() { Student a[5]; int i; for (i=0;i&lt;5;i++) { a[i].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/31b7e69b5430fe6f52adab890dc97121/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2dff7812153c059b4a26f7c5ecf1594f/" rel="bookmark">
			Spring boot(四）Thymeleaf常用语法 赋值  拼接  url
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		打开springboot1项目
1.赋值 拼接
3.条件判断：if/unless
th:if 表示条件成立时显示内容，th:unless表示条件不成立时显示内容
4.排序
5.隔行变色
stat是状态变量，属性：
index：集合中元素的index(从0开始）
count:集合中元素的count(从1开始）
size集合大小
curent当前迭代变量
even/odd当前迭代是否为奇数/偶数（从0开始计算）
first 当前迭代的元素是否是第一个 Boolean值
last当前迭代的元素是否是最后一个 Boolean值
URL
指定一个地址
Thymeleaf对于URL的处理是通过#{…}进行处理，结合th:href 、th:src指定路径
静态页面解析不了 不能跳转
通过后台进行映射才能解析出来
接收一个参数
写一个超链接访问张三
把传过去的数据别写死 不是前端写死 是后端传过来的 有点复杂
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2e46015b4813962cb4edb5e88a628cd/" rel="bookmark">
			数据结构（45）图的四种存储方法：邻接矩阵法、邻接表法、十字链表、邻接多重表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图的存储必须要完整、准确地反映顶点集合边集的信息，根据不同图的结构和算法，采用不同的存储方式将对程序的效率产生相当大的影响，因此所选的存储结构应适合于欲求解的问题。
目录
1、邻接矩阵法
2、邻接表法
3、十字链表
4、邻接多重表
1、邻接矩阵法 所谓邻接矩阵存储，是指用一个一维数组存储图中顶点的信息，用一个二维数组存储图中边的信息（即各顶点之间的邻接关系），存储顶点之间邻接关系的二维数组称为邻接矩阵。
结点数为n的图G=(V,E)的邻接矩阵A是n*n的。将G的顶点编号为v1,v2,...,vn。若(vi,vj)∈E，则A[i][j] = 1,否则A[i][j] = 0。
对于带权图而言，若顶点vi和vj之间有边相连，则邻接矩阵中对应项应该存放着该边的权值，若顶点vi和vj不相连，则用来代表两个顶点之间不存在边：
有向图、无向图的网对应的邻接矩阵示例如下图所示：
图45-2 有向图、无向图及网的邻接矩阵 图的邻接矩阵存储结构定义如下：
#define MaxVertexNum 100 //顶点数目的最大值 typedef char VertexType; //顶点的数据类型 typedef int EdgeType; //带权图中边上权值的数据类型 typedef struct { VertexType Vex[MaxVertexNum]; //顶点表 EdgeType Edge[MaxVertexNum][MaxVertexNum]; //邻接矩阵，边表 int vexnum, arcnum; //图的当前顶点数和弧数 }MGraph; 注意：
① 在简单应用中，可直接用二维数组作为图的邻接矩阵（顶点信息等均可忽略）。
② 当邻接矩阵中的元素仅表示相应的边是否存在时，EdgeType可定义为值为0和1的枚举类型。
③ 无向图的邻接矩阵是对称矩阵，对规模特大的邻接矩阵可采用压缩存储。
④ 邻接矩阵表示法的空间复杂度为O()，其中n为图的顶点数|V|。
图的邻接矩阵存储表示法具有以下特点：
① 无向图的邻接矩阵一定是一个对称矩阵（并且唯一）。因此，在实际存储邻接矩阵时只需存储上（或下）三角矩阵的元素。
② 对于无向图，邻接矩阵的第i行（或第i列）非零元素（或非∞元素）的个数正好是第i个顶点的度TD(vi)。
③ 对于有向图，邻接矩阵的第i行（或第i列）非零元素（或非∞元素）的个数正好是第i个顶点的出度OD(vi)[或入度ID(vi)]
④ 用邻接矩阵法存储图，很容易确定图中任意两个顶点之间是否有边相连。但是，要确定图中有多少条边，则必须按行、按列队每个元素进行检测，所花费的代价很大。
⑤ 稠密图适合使用邻接矩阵存储，因为空间利用率高
⑥ 设图G的邻接矩阵为A，的元素[i][j]等于由顶点i到顶点j的长度为n的路径的数目。
2、邻接表法 当一个图为稀疏图时，使用邻接矩阵法显然要浪费大量的存储空间，而图的邻接表法结合了顺序存储和链式存储方法，大大减少了这种不必要的浪费。
所谓邻接表，是指对图G中的每个顶点vi建立一个单链表，第i个单链表中的结点表示依附于顶点vi的边（对于有向图则是以顶点vi为尾的弧），这个单链表就称为顶点vi的边表（对于有向图则称为出边表）。边表的头指针和顶点的数据信息采用顺序存储（称为顶点表），所以在邻接表中存在两种结点：顶点表结点和边表结点，如下图所示。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2e46015b4813962cb4edb5e88a628cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0aba0c5cf8fa6c84aa017b59d480f3b3/" rel="bookmark">
			rational rosa_使用Rational Application Developer，第1部分，在Web应用程序中集成Crystal Reports使用JDBC连接在Web应用程序中嵌入Crystal Reports
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		存档日期：2019年5月14日 | 首次发布：2006年4月18日 本文针对希望将Crystal Reports嵌入其Web应用程序中以满足其报表需求的开发人员。 它是一个分为4部分的系列文章的第1部分，它将为您提供使用IBM®Rational®Application Developer（RAD）将Crystal Reports嵌入到Web应用程序中的实践经验。 具体来说，本文将在设计时和运行时说明如何在使用Java™数据库连接（JDBC™）技术时将Crystal Reports嵌入Web应用程序中。 此内容不再被更新或维护。 全文以PDF格式“按原样”提供。 随着技术的飞速发展，某些内容，步骤或插图可能已更改。 查看PDF文件 翻译自: https://www.ibm.com/developerworks/rational/library/06/0418_bajaj/index.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b996993c0f64de2bd144b7da3d5a2ec4/" rel="bookmark">
			Idea中main方法不能正常运行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天打开了一个以前的Java SE项目，点击run main()后发现main方法并没能够正常运行，也没报错，而且连控制台都没有弹出来。
后来发现是因为Project Structure中发生了错误，没有配置输出文件路径：
修改为自己项目的输出文件路径即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58e9fe4a61323b065dd6d4ab67238de3/" rel="bookmark">
			robotframework RF内置库Collections学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RF内置库Collections Append To ListCombine ListsConvert To DictionaryConvert To ListCopy DictionaryCopy ListCount Values In ListDictionaries Should Be EqualDictionary Should Contain ItemDictionary Should Contain KeyDictionary Should Contain ValueDictionary Should Contain Sub DictionaryGet Dictionary ItemsGet Dictionary KeysGet Dictionary ValuesGet From DictionaryGet From ListGet Index From ListGet Match CountGet MatchesGet Slice From ListInsert Into ListKeep In DictionaryList Should Contain Sub ListList Should Contain ValueList Should Not Contain DuplicatesLists Should Be EqualLog DictionaryLog ListPop From DictionaryRemove DuplicatesRemove From DictionaryRemove From ListRemove Values From ListReverse ListSet List ValueSet To DictionaryShould Contain MatchShould Not Contain MatchSort List 内容转移至：www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/58e9fe4a61323b065dd6d4ab67238de3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22cd4f4f4215ef36ef98ebb840c0e616/" rel="bookmark">
			离散特征和连续特征混合_混合蛋白和特征
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java语言的开发人员精通C ++和其他包含多重继承的语言，从而使类可以从任意数量的父级继承。 多重继承的问题之一是无法确定派生自哪个父继承功能。 这个问题称为菱形问题 （请参阅参考资料 ）。 多重继承中固有的菱形问题和其他复杂性启发了Java语言设计人员选择单一继承加接口。 接口定义语义，但不定义行为。 它们很好地用于定义方法签名和数据抽象，并且所有Java.next语言都支持Java接口，而无需进行必要的更改。 但是，某些跨领域的关注点不适用于单继承+接口模型。 这种错位导致需要Java语言的外部机制，例如面向方面的编程。 两种Java.next语言-Groovy和Scala-通过使用称为mixin或trait的语言构造在另一个扩展级别上处理此类问题。 本文介绍了Groovy mixins和Scala特性，并展示了如何使用它们。 （Clojure通过协议处理了许多相同的功能，我在Java.next中介绍了该协议：没有继承的扩展，第2部分 。） 关于本系列 Java的遗产将是平台，而不是语言。 JVM上运行着200多种语言，不可避免的是，其中之一最终将取代Java语言，成为对JVM进行编程的最佳方法。 本系列探讨了三种下一代JVM语言：Groovy，Scala和Clojure，对新功能和范例进行了比较和对比，以使Java开发人员可以一窥他们不久的将来。 混合蛋白 冰淇淋的灵感 mixin概念起源于Flavors语言（请参阅参考资料 ）。 这个概念的灵感来自发生语言发展的办公室附近的一家冰​​淇淋店。 冰淇淋店提供了普通口味的冰淇淋，以及客户想要的任何其他“混搭”（碎糖条，巧克力粉，坚果等）。 一些早期的面向对象的语言在单个代码块中一起定义了类的属性和方法，从而完成了类定义。 用其他语言，开发人员可以在一个地方定义属性，但是将方法定义推迟到以后再在适当的时候将它们“混合”到类中。 随着面向对象语言的发展，mixin如何与现代语言一起工作的细节也随之发展。 在Ruby，Groovy和类似语言中，mixins扩展了现有类的层次结构，作为接口和父类之间的交叉。 像接口一样，mixin都充当instanceof检查的类型，并且遵循相同的扩展规则。 您可以将无限数量的mixin应用于一个类。 与接口不同，mixin不仅可以指定方法签名，还可以实现签名的行为。 在最早包含mixin的语言中，mixin仅包含方法，而没有诸如成员变量之类的状态。 现在，许多语言（其中包括Groovy）都包含有状态的mixin。 斯卡拉特质也表现得很庄重。 Groovy Mixins Groovy通过metaClass.mixin()方法或@Mixin批注实现了mixins。 （ @Mixin批注依次将Groovy抽象语法树（AST）转换用于必需的元编程管道。）清单1中的示例使用metaClass.mixin()来使File类具有创建压缩ZIP文件的能力： 清单1.将zip()方法混合到File类中 class Zipper { def zip(dest) { new ZipOutputStream(new FileOutputStream(dest)) .withStream { ZipOutputStream zos -&gt; eachFileRecurse { f -&gt; if (!f.isDirectory()) { zos.putNextEntry(new ZipEntry(f.getPath())) new FileInputStream(f).withStream { s -&gt; zos &lt;&lt; s zos.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/22cd4f4f4215ef36ef98ebb840c0e616/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5fa3cbc67cced120151d11d9b2d3879b/" rel="bookmark">
			mongodb测试_发现MongoDB测验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MongoDB支持集合之间的查询联接 。 真正 假 MongoDB中的副本集具有以下好处（选择所有适用项） ： 数据冗余 分布式交易支持 自动故障转移和高可用性 灾难恢复 在副本集中，所有写请求将自动直接直接发送到辅助节点 。 真正 假 MongoDB文档以XML表示。 真正 假 解决此查询 ： db.words.find({}).orderBy({spelling:1}) 解决此查询 ： db.words.find({}).sort({spelling:1}).rows(3) 在文档数组中搜索元素需要您指定一个位置元素（即document.arrary [i]）。 真正 假 MongoDB在集合中的文档之间强制执行属性相似性（即，所有word文档必须具有同义词数组）。 真正 假 要查找所有不包含“同义词”属性的文档，此查询将起作用 。 db.words.find({synonyms:{$exist:false}}) 真正 假 在Mongo中，经常访问的数据存储在 ： 在磁盘上 在记忆中 就像任何其他关系数据库一样，MongoDB支持索引 。 真正 假 索引可以使文档查询更快，但是 ： 它们会使插入和更新速度变慢 需要专门的查询命令才能被利用（换句话说，提示） 它们在副本集环境中不起作用 答案 在这里检查您的答案。 翻译自: https://www.ibm.com/developerworks/java/library/j-mongodbquiz/index.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a351c705939399196eef3af64ccf06a/" rel="bookmark">
			理论&#43;实验：BGP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、BGP概述1.1 BGP分类 二、BGP工作原理2.1 BGP的报文2.2 BGP状态机2.3 等体之间的交互原则 三、实验3.1 实验设备3.2 实验要求3.3 实验命令 四、验证 一、BGP概述 边界网关协议BGP（Border Gateway Protocol）是一种实现自治系统AS（Autonomous System）之间的路由可达，并选择最佳路由的矢量性协议。
为方便管理规模不断扩大的网络，网络被分成了不同的自治系统。1982年，外部网关协议EGP（Exterior Gateway Protocol）被用于实现在AS之间动态交换路由信息。但是EGP设计得比较简单，只发布网络可达的路由信息，而不对路由信息进行优选，同时也没有考虑环路避免等问题，很快就无法满足网络管理的要求。
BGP是为取代最初的EGP而设计的另一种外部网关协议。不同于最初的EGP，BGP能够进行路由优选、避免路由环路、更高效率的传递路由和维护大量的路由。早期发布的三个版本分别是BGP-1（RFC1105）、BGP-2（RFC1163）和BGP-3（RFC1267），1994年开始使用BGP-4(RFC1771)，2006年之后单播IPv4网络使用的版本是BGP-4（RFC4271），其他网络使用的版本是MP-BGP（RFC4760）。
1.1 BGP分类 如图1所示，BGP按照运行方式分为EBGP（External/Exterior BGP）和IBGP（Internal/Interior BGP）。
图1 BGP的运行方式
EBGP：运行于不同AS之间的BGP称为EBGP。为了防止AS间产生环路，当BGP设备接收EBGP对等体发送的路由时，会将带有本地AS号的路由丢弃。
IBGP：运行于同一AS内部的BGP称为IBGP。为了防止AS内产生环路，BGP设备不将从IBGP对等体学到的路由通告给其他IBGP对等体，并与所有IBGP对等体建立全连接。为了解决IBGP对等体的连接数量太多的问题，BGP设计了路由反射器和BGP联盟。
二、BGP工作原理 BGP对等体的建立、更新和删除等交互过程主要有5种报文、6种状态机和5个原则。
2.1 BGP的报文 BGP对等体间通过以下5种报文进行交互，其中Keepalive报文为周期性发送，其余报文为触发式发送：
Open报文：用于建立BGP对等体连接。
Update报文：用于在对等体之间交换路由信息。
Notification报文：用于中断BGP连接。
Keepalive报文：用于保持BGP连接。
Route-refresh报文：用于在改变路由策略后请求对等体重新发送路由信息。只有支持路由刷新（Route-refresh）能力的BGP设备会发送和响应此报文。
2.2 BGP状态机 如图1所示，BGP对等体的交互过程中存在6种状态机：空闲（Idle）、连接（Connect）、活跃（Active）、Open报文已发送（OpenSent）、Open报文已确认（OpenConfirm）和连接已建立（Established）。在BGP对等体建立的过程中，通常可见的3个状态是：Idle、Active和Established。
图1 BGP对等体交互过程
Idle状态是BGP初始状态。在Idle状态下，BGP拒绝邻居发送的连接请求。只有在收到本设备的Start事件后，BGP才开始尝试和其它BGP对等体进行TCP连接，并转至Connect状态。
在Connect状态下，BGP启动连接重传定时器（Connect Retry），等待TCP完成连接。
如果TCP连接成功，那么BGP向对等体发送Open报文，并转至OpenSent状态；如果TCP连接失败，那么BGP转至Active状态；如果连接重传定时器超时，BGP仍没有收到BGP对等体的响应，那么BGP继续尝试和其它BGP对等体进行TCP连接，停留在Connect状态。 在Active状态下，BGP总是在试图建立TCP连接。 如果TCP连接成功，那么BGP向对等体发送Open报文，关闭连接重传定时器，并转至OpenSent状态；如果TCP连接失败，那么BGP停留在Active状态；如果连接重传定时器超时，BGP仍没有收到BGP对等体的响应，那么BGP转至Connect状态。 在OpenSent状态下，BGP等待对等体的Open报文，并对收到的Open报文中的AS号、版本号、认证码等进行检查。 如果收到的Open报文正确，那么BGP发送Keepalive报文，并转至OpenConfirm状态；如果发现收到的Open报文有错误，那么BGP发送Notification报文给对等体，并转至Idle状态。 在OpenConfirm状态下，BGP等待Keepalive或Notification报文。如果收到Keepalive报文，则转至Established状态，如果收到Notification报文，则转至Idle状态。
在Established状态下，BGP可以和对等体交换Update、Keepalive、Route-refresh报文和Notification报文。
如果收到正确的Update或Keepalive报文，那么BGP就认为对端处于正常运行状态，将保持BGP连接。如果收到错误的Update或Keepalive报文，那么BGP发送Notification报文通知对端，并转至Idle状态。Route-refresh报文不会改变BGP状态。如果收到Notification报文，那么BGP转至Idle状态。如果收到TCP拆链通知，那么BGP断开连接，转至Idle状态。 2.3 等体之间的交互原则 BGP设备将最优路由加入BGP路由表，形成BGP路由。BGP设备与对等体建立邻居关系后，采取以下交互原则：
从IBGP对等体获得的BGP路由，BGP设备只发布给它的EBGP对等体。
从EBGP对等体获得的BGP路由，BGP设备发布给它所有EBGP和IBGP对等体。
当存在多条到达同一目的地址的有效路由时，BGP设备只将最优路由发布给对等体。
路由更新时，BGP设备只发送更新的BGP路由。
所有对等体发送的路由，BGP设备都会接收。
三、实验 实验拓扑图
3.1 实验设备 四台路由器。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a351c705939399196eef3af64ccf06a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14559c2f5bd2141f65d4450aa57611f3/" rel="bookmark">
			（ Tencent -TNN 学习）pytorch模型部署到移动端
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记录分为
pytorch2onnxonnx2tnntnn结果验证移动端（安卓）使用 1、pytorch2onnx 环境：
pytorch 1.4.0
onnx 1.6.0 (转换)
onnxruntime 1.3.0 （测试）
onnx-simplifier 0.2.9 （模型量化，不执行后续报错了，我测试是这样的）
转换代码：
import onnx import torch from test_net import TestModel import numpy as np import cv2 if 1: torch_model = TestModel("model.pt") torch_model.eval() batch_size = 1 #批处理大小 input_shape = (3,384,384) #输入数据 # set the model to inference mode # torch_model.eval() x = torch.randn(batch_size,*input_shape)	# 生成张量 export_onnx_file = "./model.onnx"	# 目的ONNX文件名 torch.onnx.export(torch_model, x, export_onnx_file, export_params=True, opset_version=11, do_constant_folding=True, # wether to execute constant folding for optimization input_names = ['input'], # the model's input names output_names = ['output'], # the model's output names dynamic_axes={'input' : {0 : 'batch_size'}, # variable lenght axes 'output' : {0 : 'batch_size'}} ) print ('get onnx ok!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/14559c2f5bd2141f65d4450aa57611f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34a532e22aa95222c7d2c8b2ae2344f9/" rel="bookmark">
			关于fairygui在unity的位图字体显示错误的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在fairygui创建的位图字体，在编辑器中显示一切正常，但在unity中发现有时候会发现显示错乱，经过对比，发现显示错乱是因为包的图片太多导致。位图字体也是打包成图集导入到unity中，我们假设位图字体是0-9，当图片比较多或者图片比较大的时候图集被拆成了两个部分，这时可能导致位图中的0-4在图集1,5-9在图集2，这样0-4显示正常，5-9显示错乱（推测显示的是5-9坐标在图集1的位置）。
解决方式：
1：拆解包体，把包拆解成几个小包，尽量确保在一个包只有一个图集。
2：位图字体单独设计一个包，确保只有一张图集，用AddPackage的方式预加载。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10b9b0fc7612de44212bfaf0f009257d/" rel="bookmark">
			Java使用多线程完成PDF文件转图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		多线程完成PDF文件转图片 系统需要将PDF文件由后台直接转为img图片，供前端页面直接展示，不需要用户下载即可预览文件内容。直接转换时如果文件过大，耗时很长，影响用户体验，后调研后使用多线程方式进行，显著加快图片转换速度。
原始版访问：https://blog.csdn.net/wmf_helloWorld/article/details/104051137
1、创建线程池
ExecutorService executorService = new ThreadPoolExecutor(5, 10, 60L, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;Runnable&gt;(50)); 初始化线程池，因系统默认一次预览5张图片，进行分页分步预览，所以设置核心线程池大小为5.设置最后队列为new ArrayBlockingQueue(50))，可以排队50个等待任务，若大于50则不建议预览，或根据需要使用其他队列。
可访问：https://www.cnblogs.com/dafanjoy/p/9729358.html
2、主要转换方法体
2.1、全部转换
public List&lt;String&gt; pdfTurnImage(String filePath) throws CodeException { List&lt;String&gt; fileImageList; File file = new File(filePath); try(PDDocument pdDocument = PDDocument.load(file)) { PdfReader reader = new PdfReader(filePath); int pages = reader.getNumberOfPages(); LOGGER.info(LogType.INFO, "pdf文件共有"+ pages +"页文件"); String[] imgStrArr = new String[pages]; fileImageList = Arrays.asList(imgStrArr); List&lt;Future&lt;Boolean&gt;&gt; futureTaskList =new ArrayList&lt;&gt;(); for(int i=0; i&lt;pages; i++) { LOGGER.info(LogType.INFO, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/10b9b0fc7612de44212bfaf0f009257d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c784085fdb93077ef9cd6eaec00d2d0/" rel="bookmark">
			普通人财富自由的几率有多大？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们感激这个时代，并感激拥有的一切
--明哥
视频号这么玩一个月内轻松赚到1000+？
看待一个人的成功，需要分成两部分，一部分是时代造就，一部分是个人努力。很多人混淆了个人努力，把一切都归为了时代造就，互联网时代第一波，腾讯，网易，新浪，百度，我们看到了这些幸运儿，却没看到还有多少也是同样做这个事情，但是折戟沉沙，淹没在历史潮流里。
当你聚焦看待事物的时候，总是琢磨那些没法复制的东西，从而安慰自己，说看吧这个就是凭关系了，凭人脉，我要有这个关系，我也能做成。
难说。当一个人有这个意识的时候，基本上就不会成功，因为思考问题的方向是错误的。开放性的思维，需要先认同，再来吸收。如果一味的去找别人不可复制的地方，那么你怎么能够成长？你只会想自己不成功是多么合理的一件事。
每个时代背景下，都有很多弄潮儿，失败的占据大多数。我们要从成功者那边，分析出能够复制的品质，能力，从而让自己能够借鉴，学习，这才是真正在自我迭代。
很多人想问题，先想到困难。一提起做生意，就是自己没有资金，没人投资。可有没想过另一个问题，有没有轻资产的项目，不需要太多资金介入？
有，并且很多。世面的在线课程，知识付费平台，就是一个人人都可以上去创业，输出内容变现。这需要什么，明显不是资金的问题，而是能力。
忽略了核心要素，去抱怨，盯住这些不可改变的内容，注定是为自己的失败开脱，成功必然无法降临，因为你本身就没有信念感。
做事不想着怎么解决，只会抱怨一堆问题，抛出问题的人，是非常讨厌的。成长是在什么时候出现的呢？痛苦的时候。具体有哪些事例呢？
当你埋头苦想一个问题，最终解决了它。苦想的过程很痛苦，但最终解决了，就是在成长。成长分为几个维度，一个是对自己当前的知识，认知做了修正，补充，另一个新加入了知识，让自己思考问题更加立体和全面。
一个人只有感觉累的时候，才是在上坡。长久待在舒适区，自己会思维倦怠，因为太过熟练会产生厌烦，停止了自我成长。我们对于不确定的事天然的产生畏惧，但对于习以为常的事又产生懈怠，所以时刻让自己处在学习状态，就是最好的解决方式。
而阅读就是一个选择，思考也是。对自己习以为常的事，进行思考追溯它的形成原因，它的逻辑是否可以在别处应用，是否是一个通解，这个很关键。通解是有迁移能力的，就像创业失败的人，他比从没创业过的人来说，会更快的适应起来，把自己的失败总结经验，在下次的创业过程中避免，成功的几率就会大许多。
成功的人看待失败，会认为又堵住了一个错误路径，那么在路径总量一定的时候，成功的几率其实是在变大。成功的人看到机会，而失败的人看到风险。
认知的差距由此产生。而成功的人最牛的地方是什么？是知识迭代，以及快速试错能力。他们不会纠结在为什么不对，而是分析出它存在的合理理由，总结出理论和实践的偏差，从而指导后续业务推进策略。
登山的路径不是只有一条，你不能盯住自己不能的那条，然后劝说自己，看吧我就知道不行，我们不用试了吧。
缺少勇气是作出决定的第一步，举棋不定是对未知不敢拼搏的反应。没有哪个成名人士会说自己能够预知成功的到来，而且在大众面前必须把自己的能力隐去，而说一些贵人扶持，政策因素，以及机缘巧合，反正就是表达一些概率事件，好承认自己的运气。
这是让谁看呢？让那些不敢挑战，以及不愿承认他人优点，能力的人们，找到一个释放口，让他们理所当然的接纳，你的一切都是来自于运气，或者说大多数来自于运气。
而渴求成功的人，会去挖掘出来个人能力的部分，从而让自己发生迭代，靠近成功。怎么看待问题，怎么做出选择，这本身就在决定成与败，而这个经验从哪来呢？
一个是自己实打实的实践，一个是看历史人物的成长轨迹，把自己带入其中，看看自己会怎么解决。如果仅仅靠着实战，而不去反思，总结，那么下次的失败还会来临，因为上一次的失败没有收获，那失败的意义就不存在了。
很多人会找到理由，说什么他们踩住了风口。那我想问一下，比特币的风口，外卖，共享单车，滴滴打车，以及现在的拼多多，头条，或者抖音，视频直播，以及直播带货是不是风口，我们经历过或者正在经历的。但问题是，你为什么没有踩住呢？
这个问题才是本质。上一个风口过去，老是怅然若失觉得时不我待，可是有没想过为什么下一个风口也依然错过呢？
风口是什么？是奖励那些已经为这个风口准备了很长时间，并且有了一些成绩的那群人。而如果你什么都没有，就去追风口，确实显得很荒谬。
一举成名的半佛，或者是网络上一炮而红的李佳琦，背后通过多年的积累，才有了这个成名的资本。记得彪悍一只猫说自己为了成长，跟自己死磕，一个月录制了上千条视频，就为了能够有镜头感，让自己表现的更好。
苦工都不愿投入，就想直接摘取果实，委实让人可怕。这种妄图不劳而获的行为，不就是心中邪念作祟，好逸恶劳的外在表现。
我在看李笑来的书之前，对他偏见比较大，这都来源于市面对他的评定。但当我看过他的书，再来思考的时候，才发觉其实人家是真有本事，并非凭借运气，也并非割你韭菜。
因为他盯着比特币已经很长时间，并且也是有赔有赚，只是遇见了大涨大跌，很多人赔的倾家荡产，而一般都不认为是自己投资失误，于是就要找个人来背锅。而李笑来就是最好的背锅侠，因为假定是他，会引起大众的情绪输出。
不以对错，事实依据来评判，而以情绪为支撑，不就是乌合之众吗？当群体出现一致性的时候，你要学会跳出圈子，从外部审视它，用理性的思维，再去复盘一次，把主观情绪剃掉，才能找到隐藏在情绪内的真相。
生意是什么？是交换，是流通。有流通意义的东西，才有变现的基础。当大众对一个东西形成了共识，如果稀缺，那就自然产生溢价。
我们听过一个段子，把煤运往山西，然后赔惨了。但如果把空气运到西藏，把矿泉水运到山顶，把红绳卖给寺庙牵系姻缘，或者绑在螃蟹腿上。稀缺是一面，还有就是在哪，跟谁。
我之前一直琢磨一个东西，为什么世面有十几块，二十几块的水呢？大众不买它，它存在的意义在哪？一个简单的逻辑是，如果一瓶两块钱的农夫山泉，放到高铁，或者飞机场，你卖多钱都会被认定有故意抬价的嫌疑。而如果我就定义一个新的品牌，就只是填充这部分市场，为的就是价格合理化，你是不是就会无话可说，妙处在这里。
有人的地方就有机会，而腾讯的微信，QQ解决了人们渴求认同，连接的诉求。阿里的淘宝，解决了大众逛街，买东西的诉求，但其实这个背后有个更大的支撑，就是国家物流基础设施的建设完成。
如果没有强大快捷的物流体系支撑，淘宝的进化速度会慢太多太多。在物流之外，还有就是流量的普及，如果还是功能机时代，大众还是会在线下购买商品，因为线上沟通成本太大，流量太贵。
基础建设会决定创业风口，而这个是由政策导向。如果你能靠近政策红利，你就能抢占先机，并且资源也是稀缺的，信息差存在，就有利益交换在里面。
房地产基本依托在政策里面，人们的归属情绪以及市场引导，而万科，恒大，碧桂园便是这里面赚到了红利，有点圈地运动，以及马太效应的感觉。
而有个市场我不看好，就是电影院。这个是一个比较伪刚需，有些小情侣，或者是有些加班族，也有看电影的兴趣，而电影院属于线下，并且需要很高的时间自由度，从这块思考，家庭影院租赁，或许会是一个机会。
移动理发，前几年提过，在群里讨论觉得我这个建议不合理，但事实有可能是，真的会发生，因为生意在于流动，如果你跟我在异地，那么火车，飞机就是生意场。如果你在上班，而有理发的诉求，那么移动理发店，就是机会。
我相信很多人有这个诉求，而这个恰巧能够解决，配合线上下单，预约等服务，最终因为标准化流程，降低成本，形成产业链条。
赚钱的逻辑是什么？你为哪些人解决了哪些问题，并且他们愿意付费？找到人群需求以及定价，你就找到了赚钱的门路。现如今所处的时代，真正应该怀有感激之情。
因为时代在进步，阶层在退化，互联网的扁平化管理，在时代里面也凸显了出来。一个人从普通人变为明星，有了一条扁平化通路，也就是阻碍很小，这是非常关键的。
说明了一个人打破圈层的方式，正在发生类似于跨过中间商一样，可以触达，并且确实能够拥有所需的资本和环境。时代是给与了我们人人都有的机会入口，就看谁先凿破，突围出去。
圈层的意义正在被打破，现如今知识付费的成本被大众平均化，我们可以很廉价的听到北大，清华或者其他高校的课程，各种知名教师，都能够在网络开课，通过低价走量的模式，让三方都享有福利，像李笑来的课程，薛兆丰的经济课，像梁宁的产品课，都可以便捷的获取到。
信息的绝对化公开程度，会让大众快速提升本事，竞争呈现出高质量，以及产生辐射效应，一层层推进，最终让每一层的人都在快速迭代。
像辛巴，李佳琦，薇娅，像王宝强，岳云鹏，大鹏，像刘强东，大衣哥，像三枝花，姜涛。
时代被重新定义，于是突破圈层往往出其不意，但我们需要看到，他们都是历经沧桑，多年的默默无闻，积累的量变最终在时代的推动下，发生质的变化。当才不对位，你是无法承载巨大的福泽，而这也是为什么太多的明星，会在成名之后，进修学习的原因。
这个时代，给了普通人进入财富自由的通道，就看谁认清楚了这点，进行死磕本领。时刻记住，有市场，有交换，那么专攻一点，做到头部，你就赢得机会。
半途而废的例子比比皆是，而成功其实很简单，找对正确的路线，去执行，在过程中进行微调。经验是从错误中来的，于是不应该畏惧失败。
当你在选择跑道的时候，要去分析自己的优势，不要找劣势在那里死磕，最终打击自信心，又没有成绩。当前普通人财富自由的人太多，圈子里面已经司空见惯。
之前在文章中讲过逻辑，这里再说一次财富自由的路径，希望每个人切入自己能做的去做，不要因为有人做过就放弃，要知道，太阳下没新鲜事，并且信息差永远存在。
1 上班
2 投资
3 副业
4 创业
5 理财
结余=收入-支出。而收入可以分为主动和被动两个来源。副业为我们打造的就是被动这条线路，当被动的收入覆盖了支出，那么你离自由就非常近了。
网上有一个复利的图片，我们看到一条长长的低位沉淀，这个就是所谓的蓄能过程，如果你勤奋多年没有出成绩，主要在于你这个蓄能是错误的。
重复一件事，进入所谓的舒适区，不计入蓄能过程。有效的蓄能才算，简单理解就是有成长，收获的积累才算。
要说普通人财富自由的几率有多大，只能说纵观历史进程，当下的时代是最容易崛起的，因为信息足够的公开，那么那些真正用心做事的普通人，就会有更多的机会突出重围，被大众所看到。
看到就意味着机会，而有价值就有了商业模型。普通人在成名之前，必须要练就的是价值观，以及设定底线，对于未知有所畏惧，对于好意有所防备，能够拒绝，能够选择，从容淡定。
否则在起飞之后，因为根基不牢会被引入万劫不复，因为膨胀的欲望是没有边界的，而一个人要想站稳脚跟，必须设定边界，定一些规矩。
什么是普通人？什么是财富自由？一个普通的铁匠，通过每天哐哐哐的打铁，能够悟透人生。一个知道自己欲望的边界，同时又有所追求，这就是到达了财富自由状态。
这时代给足了你机会，而你需要秀本事。没有？学它就可以了。兴趣和能力要分开来看，而赚钱的更多落地动作，我们随后再另起一篇来讲。
--完--
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c784085fdb93077ef9cd6eaec00d2d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1bf10ee53391a9a1144b243be1c5c321/" rel="bookmark">
			ACWing 88.树中两个节点的最低公共祖先（Python版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目描述 给出一个二叉树，输入两个树节点，求它们的最低公共祖先。
一个树节点的祖先节点包括它本身。
注意：
输入的二叉树不为空；
输入的两个节点一定不为空，且是二叉树中的节点；
样例：
解题思路 见注释
代码实现 class Solution(object): def lowestCommonAncestor(self, root, p, q): """ :type root: TreeNode :type p: TreeNode :type q: TreeNode :rtype: TreeNode """ if not root: return None if q == root or p == root: # 如果找到了某一个点 则当前节点为答案 return root left = self.lowestCommonAncestor(root.left, p, q) right = self.lowestCommonAncestor(root.right, p, q) if left and right: # 如果左子树中可以找到其公共祖先 右子树也可以 则说明当前节点就是答案 return root if not left: # 左边找不到了 那就是右子树的答案 return right elif not right: # 右边亦然 return left 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/595da30abbd98e58890fb63986656d14/" rel="bookmark">
			HashMap作为常量存储数据用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 背景：有个类中需要用到很多图片，但是产品只给了图片的key值和图片地址，我要放到相应的类中，就用HashMap来了个常量集合。
使用方式：
private HashMap&lt;String, String&gt; segmentMap = new HashMap() {{ put("0", "https://cdn.vp.com/appadmin/91BC9F0F7736464B8C967893097B0A9B-1592322066626.png"); put("11", "https://cdn.vp.com/appadmin/F3A00D203A904A0096B371474B55FA24-1592322072807.png"); }}; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94b848fb1c3693ba0e57c4c482729d6c/" rel="bookmark">
			咸鱼Vue记录【一】-Vue-admin-template安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#Vue-admin-template安装
环境：node
# 克隆项目 git clone https://github.com/PanJiaChen/vue-element-admin.git # 进入项目目录 cd vue-element-admin # 安装依赖 npm install # 建议不要用 cnpm 安装 会有各种诡异的bug 可以通过如下操作解决 npm 下载速度慢的问题 npm install --registry=https://registry.npm.taobao.org # 本地开发 启动项目 npm run dev 安装情况：
core-js警告：
npm WARN deprecated core-js@2.6.11: core-js@&lt;3 is no longer maintained and not recommended for usage due to the number of issues. Please, upgrade your dependencies to the actual version of core-js@3. 解释： 来自你npm的警告 corejs@2.6.11: corejs@&amp; lt;3不再被维护，由于存在大量问题， 建议不使用。请将您的依赖项升级到corejsr 现在运行版本版本3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94b848fb1c3693ba0e57c4c482729d6c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d195e21c06ef13092c31a5530e02300d/" rel="bookmark">
			Hadoop与Spark并行度设置问题（mr、spark任务提交参数的设置、spark-submit参数调优）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		并行度的影响 合理的并行度，不能太小也不要过大。
并行度较小：
并发度小，执行效率低；（失去分布式计算的意义）
并行度过大：
资源申请上的劣势。导致ApplicationMaster在向yarn提交资源申请时不能做到数据本地化（分配执行任务的机器不是数据所在机器，yarn resourcemanager在分配资源时选择 数据本地、同机架、集群随机三种方式，优先级从前到后），甚至由于集群剩余资源不足而处于排队等待状态，申请资源时间成为整个任务执行时间的瓶颈；
每个task的初始化时间拖了任务执行时间的后腿（一个数据量小、处理逻辑简单的任务本身执行时间已经比大量task初始化所消耗时间小）；
合理的并行度 任务的合理并行度取决于
集群的资源
一个合理的并行度，肯定是需要考虑到现有集群的可用资源，这个决定了你申请资源的上限。
集群的资源可以划分为两种：1、整个集群的资源；2、hdfs数据所在机器的资源情况。
任务处理的数据量、文件数
你要处理的数据量是你任务并行度大小的关键。
查看hdfs文件信息：
hadoop fsck /xxx/xxx/your_path
可以加 -files -blocks -racks参数查看目录下每个文件的明细信息：files：文件数；blocks：数据块数；racks：机架地址
blocks决定了读取数据时的并行度（一般读取task数等于block数）
数据处理的业务逻辑
io密集型 or cpu密集型
io密集型 —— 较小的并行度，可以尽可能保证数据的本地化或同机架，避免数据的网络传输；
cpu密集型 —— 偏向于更大的并行度（spark任务可以通过DAG、数据缓存等辅助优化手段）
总之，任务的并行度取决因素有很多，并且这些因素不是一成不变的，在任务调优的过程中，可以通过控制变量来多次尝试，选择出最理想的一个资源大小、任务的并行度大小
并行度的设置 spark并行度强转操作： reparation/coalesce 两者区别参考：https://blog.csdn.net/zx_blog/article/details/100168367
hdfs文件数据读取时的并行度：
文件所占block数（一个block对应一个task）。
通过spark参数进行调整：
spark参数：spark.default.parallelism（可设置在sparkhome中全局配置文件中，或在代码sparkconf中进行设置）
spark sql的参数：spark.sql.shuffle.partition（spark sql中shuffle操作的并行度，如sql中join，group by等操作，默认为200）
spark shuffle算子中设置并行度： rdd.groupByKey(100)、rdd.leftjoin(secondRdd, 50)
mr任务，FileInputFormat的并行度：
并行度=fileSize / Math.max(minSize, Math.min(maxSize, blockSize))，默认minSize为1，maxSize为Long.MAXValue，所以默认并行度等于fileSize / blockSize
minSize和maxSize可通过mapreduce.input.fileinputformat.split.minsize、mapreduce.input.fileinputformat.split.maxsize进行调整；blockSize即hdfs的blockSize，可以通过
hdfs-site.xml中dfs.blocksize进行配置
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d0148bb3011e1f88dcbac00dfddcfdf/" rel="bookmark">
			详解JS中slice函数和splice函数区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		详解JS中slice函数和splice函数区别 1.slice()slice的定义slice的语法 2.splice()splice的定义splice的语法 以前是职场小白时，经常经常搞混JS中操作数组的slice和splice函数。因为这两个函数的名字非常相似，语法也类似。 现在总结一下这两个函数的差异，方便以后调用。 1.slice() slice的定义 从已有数组中返回返回你选择的某段元素集合
slice的语法 arrayObject.slice(start, end)
注意：
start表示从何处开始选取， end表示从何处结束选取，start和end表示一个选取的范围；start可以为负数，此时它规定从数组尾部开始算起的位置。也就是-1 ，指最后一个元素，-2 指倒数第二个元素，以此类推end如果没有被指定参数，数组会包含从 start 到最后一个数组元素的所有元素slice()方法不会修改数组本身，而是返回所选取范围的数组元素。如果想删除数组中的某一个元素，需要使用splice()
下面来看一些例子这里的取值范围是0-2（start-end），因为数组的下标是从0开始，所以这里的2就是下面数组中的 javascript元素
这里需要注意的是0-2选取的元素是html和css，并不包括javascript var arr = ['html', 'css', 'javascript', 'jQurery', 'Ajax']; var sliceArr = arr.slice(0, 2); //sliceArr值为['html', 'css'] 如果只有start，则会选择start开始到end之间的所有数组元素
var arr = ['html', 'css', 'javascript', 'jQurery', 'Ajax']; var sliceArr = arr.slice(1); //sliceArr值为['css', 'javascript', 'jQurery', 'Ajax'] 如果start是负数，则会从数组尾部开始算起。这里只有start没有end,且start为负数，所以只能获取到最后1个数组元素
var arr = ['html', 'css', 'javascript', 'jQurery', 'Ajax']; var sliceArr = arr.slice(-1); //sliceArr值为['Ajax'] 如果你想获取除了最后1个元素以外的全部元素
var arr = ['html', 'css', 'javascript', 'jQurery', 'Ajax']; var sliceArr = arr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d0148bb3011e1f88dcbac00dfddcfdf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5b29286ace29e8f6caf4f7027e964d3/" rel="bookmark">
			【Python】求1&#43;2&#43;3&#43;‥‥‥&#43;n的和
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 输入n（n&gt;=10），求1+2+3+‥‥‥+n的和。 【Python参考代码】 ①for循环
n=int(input("Please input n:")) lst=range(1,n+1,1) result=0 for i in lst: result+=i print(result) ②用sum() ,不用for循环
n=int(input("Please input n:")) s=sum(list(range(n+1))) print(s) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86c8cd9d0ff40a6c30dd96357194f7d7/" rel="bookmark">
			C语言实现输入ascii码，输出对应的字符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		源代码
/********** ascii.c ************/ #include&lt;stdio.h&gt; #include&lt;string.h&gt; //下面的字符串总共有714个字符。 char strs[714]= "0,NUL,16,DLE,32, ,48,0,64,@,80,P,96,`,112,p,1,SOH,17,DC1,33,!,49,1,65,A,81,Q,97,a,113,q,2,STX,18,DC2,34,\",50,2,66,B,82,R,98,b,114,r,3,ETX,19,DC3,35,#,51,3,67,C,83,S,99,c,115,s,4,EOT,20,DC4,36,$,52,4,68,D,84,T,100,d,116,t,5,ENQ,21,NAK,37,%,53,5,69,E,85,U,101,e,117,u,6,ACK,22,SYN,38,&amp;,54,6,70,F,86,V,102,f,118,v,7,BEL,23,ETB,39,',55,7,71,G,87,W,103,g,119,w,8,BS,24,CAN,40,(,56,8,72,H,88,X,104,h,120,x,9,HT,25,EM,41,),57,9,73,I,89,Y,105,i,121,y,10,LF,26,SUB,42,*,58,:,74,J,90,Z,106,j,122,z,11,VT,27,ESC,43,+,59,;,75,K,91,[,107,k,123,{,12,FF,28,FS,44,,,60,&lt;,76,L,92,\\,108,l,124,|,13,CR,29,GS,45,-,61,=,77,M,93,],109,m,125,},14,SO,30,RS,46,.,62,&gt;,78,N,94,^,110,n,126,~,15,SI,31,US,47,/,63,?,79,O,95,_,111,o,127,DEL,"; char words[128][5];//共有128个ascii码字符 int main(){ int len = strlen(strs); //printf("len=%d\n",len); int i = 0; int j = 0; int result = 0; memset(words,0,sizeof(words)); while(i &lt; len) //strs的长度（字符的个数） { result = 0; while(strs[i] != ',' &amp;&amp; i &lt; len) { result = result * 10 + (strs[i++] - '0');//计算对应的ascii十进制数值 } i++; j = 0; while(strs[i] != ',' || i == 548) //逗号"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/86c8cd9d0ff40a6c30dd96357194f7d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd963602cedabb834ab959f07b7f7fe2/" rel="bookmark">
			uniapp同意使用,不同意退出APP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于app的使用。许多电商平台都设置了下载APP就会提示用户是否同意使用条款或者隐私政策。
用户不同意就会退出APP。同意了就隐藏弹窗。
那怎么才能判断用户下载APP,是否有同意使用呢。并且用户卸载重装后仍然会提示用户同意。 我们可以在用户点击同意时，保存一个关键词在本地。根据这个关键词是否存在本地。 而提示用户是否同意。这样用户同意之后在下次点击APP时就不会提示了。 除非用户卸载重装APP 首页为APP的首次加载页面。在该页面上做判断。 如果存在就隐藏弹窗。(之前做法是建一个新的页面，在这个新的页面做判断再导航。发现同意条款再次进入会有闪屏显现。所以将弹窗放在首页上 点击同意
（此方法最好写在onload之前的钩子函数。不然此页面在每次打开APP时会闪以下）
admit(){ // 同意，保存用户同意使用字段和同意时间戳 try { uni.setStorageSync('agreement_key', 'yes'); uni.setStorageSync('agreement_date', new Date().toLocaleString()); } catch (e) { // error } // 跳转到首页 // uni.switchTab({ // url:'/pages/index/index' // }) //隐藏所有弹窗 this.showonebox=false; //显示首页tabar uni.showTabBar({animation:true}); }, 判断有关键字
//首页判断是否同意 judge(){ uni.getStorage({ key: 'agreement_key', success: () =&gt; { //不显示弹窗 this.oneagree=false; uni.showTabBar({animation:true}); }, fail:()=&gt;{ //显示弹窗，隐藏tabar uni.hideTabBar({animation:true}); this.oneagree=true; } }) }, 不同意退出
// #ifdef APP-PLUS if (plus.os.name.toLowerCase() === 'android') { plus.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd963602cedabb834ab959f07b7f7fe2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77c886e3fde008cf251bbec626ccce5a/" rel="bookmark">
			AD里面 元件间距设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		继续学画板子的时候，发现两个元件放的太近就会违规
刚开始还以为是丝印离的太近了，就想改，结果改了还是报。
想了好久后面才发现，应该是元件之间的间距太近了，再改规则
把这个最小水平间距改成0mil,再也不报违规了。
不过实际情况下要考虑到元件是否会互相顶住而无法焊接的情况，毕竟焊盘和原件实际大小是有很大区别的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/813dea05edbc78a532f6c2b52561b6f7/" rel="bookmark">
			四旋翼无人机数学模型推导
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本周开始进行四旋翼无人机的学习工作，首先来进行四旋翼无人机的数学模型推导工作。。
四旋翼动力学数学模型 坐标变换 介绍四旋翼数学模型之前，首先引入坐标变换的概念，定义两个坐标系惯性坐标系{E}，以及机体坐标系{B}，惯性坐标系就相当于在地面建立的、静止不动的坐标系，也是我们操纵无人机所在的空间，而机体坐标系是建立于四旋翼机体之上，随着四旋翼姿态变换而变化，所以建立一种地面上的惯性坐标系与四旋翼机体坐标系之间的转换关系，就有这个必要。
对于惯性坐标系{E}，以及机体坐标系{B}，它们之间的转换关系或者说旋转矩阵是：
这个旋转矩阵在接下来的数学模型推导中会反复使用。
四旋翼移动方程 四旋翼的姿态也分为移动和转动两个部分，首先推导移动部分运动学方程：
根据牛顿运动学定律有：
其中等式左边是无人机旋翼升力，注意这个式子是在惯性坐标系下定义，所以重力部分只在惯性坐标系Z轴上产生。
等式右边自然是重力乘以加速度（位置的二阶导数）
定义机体坐标系下升力虚拟控制量U1，
因为是在机体坐标系下定义，所以升力自然只作用于机体的Z轴方向，那么怎么将机体坐标系下的升力转换到惯性坐标系下呢，这就用到了前面提到的旋转矩阵，左乘旋转矩阵，将机体坐标系的升力变换为惯性坐标系下的升力。其中Tx、Ty、Tz是惯性坐标系X、Y、Z轴上升力分量，在转动部分模型推导中会用到它们。
有了和的表达式，将它们代入牛顿运动学定律之中，简单移项，就得到了四旋翼位置二阶导数的表达式。
注意，四旋翼平移运动方程中，位置变化作为输出量，但是却含有转动部分的参数，四旋翼无人机也是一种典型的欠驱动系统，即用四个输入（四个旋翼的角速度）去控制六个自由度（移动三个，转动三个）。
四旋翼转动方程 定义机体（质量分布均匀对称）的转动惯量
一般Ix=Iy；
根据刚体转动定律：
其中：
得到：
在四旋翼姿态变化不大的情况下认为;
得到：
根据力学原理：
定义其中U2、U3、U4为横滚角、俯仰角、偏航角虚拟控制量：
和前文式子再进行联立得到：
于是得到转动方程：
这样和之前得到的四旋翼移动方程进行组合得到四旋翼整体的动力学模型：
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/426/">«</a>
	<span class="pagination__item pagination__item--current">427/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/428/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>