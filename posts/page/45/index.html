<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6169b8d2f9171cb51138d0375fe3a4fc/" rel="bookmark">
			RedisTemplate操作bitmap,应用场景记录签到以及布隆过滤器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		package com.xx.utils; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.data.redis.core.RedisCallback; import org.springframework.data.redis.core.RedisTemplate; import org.springframework.stereotype.Component; /** * @Auther: ZHANG PU * @Date: 2023/12/12 16:54 * @Description: */ @Component public class RedisUtils { @Autowired private RedisTemplate redisTemplate; /** * 功能描述: 标记 * * @author zhang pu * @date 16:58 2023/12/12 */ public Boolean mark(String key, long offset, boolean tag) { return redisTemplate.opsForValue().setBit(key, offset, tag); } /** * 功能描述: 验证是否标记 * * @author zhang pu * @date 16:58 2023/12/12 */ public Boolean check(String key, long offest) { return redisTemplate.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6169b8d2f9171cb51138d0375fe3a4fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a51d3c0e49e4c167ed4f5d42bfb56c1/" rel="bookmark">
			信息技术--教学设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1 教学设计的流程2 教学目标3 教学重难点4 导入新课5 新课讲授6 巩固提高7 小结8 作业9 板书10 学习任务单11 教学评价12 教学设计思维导图 教学设计占据的分值是35分，属于笔试的最后一道题，是比较容易得分的题目，但是需要掌握教学设计的核心，比如 理论知识和书写模板，结合材料自身进行分析，得到高分是不成问题的，需要重点重视。 掌握好教学设计，对于面试是非常有帮助的，在面试环节需要我们按照题目，设计课堂内容以及教学环节，并且完成无生试讲，所以这部分知识真的需要重点掌握。
1 教学设计的流程 教学设计是真个教学环节最重要的，教学设计的流程顺序需要我们非常熟悉和熟练，可以针对不同的课题，按照流程要求，进行设计
一、教学目标 1、知识与技能 2、过程与方法 3、情感爱都与价值观 二、教学重难点 1、教学重点 2、教学难点 三、新课讲授 1、导入新课 2、新课讲授 3、巩固提高 4、小结 5、作业 四、板书设计 1、提纲式板书 2 教学目标 教学目标分为三维目标。分别从三个方面阐述一节课内容所需要体现出的效果，答题按照以下三点针对性的描述即可，切忌使用使、让、被这样的字眼，明确学生的主体地位。
知识与技能： 学生能够准确说出 / 区分 / 操作 xxx 知识 过程与方法： 通过小组探究，提高了学生和作家刘的能力 通过自助探究，提高了学生独立思考的能力 通过操作演示，提高了学生观察动手的能力 情感态度与价值观： 通过学习xxx知识，体会到了信息技术的便捷性，提升了对信息技术学习的兴趣 3 教学重难点 教学重难点一般情况下是分开的，重点是重点，难点是难点，但是也不排除教学重点和难点是同一个内容，需要在分析题目的时候，仔细观察揣摩。
教学重点：一般为本课的基本概念和基本操作 教学难点：一般是概念的理解，操作的易错点，知识的灵活使用 教学重点的写法，一般是知识与技能目标，比如：xxx的制作，xxx的组装等等
教学难点的写法，一般是xxx与xxx的区分等
4 导入新课 导入新课的书写模板，一般使用情景导入，遵循手段+提问+总结的原则。
手段 ：是指通过多媒体展示xxx作品
提问：是指提出与之相关的1-2个问题，问题可以不写答案，其中问题的提问主要看作品的变化过程，或者有哪些特点等。
总结：是对上述问题的一些总结，可以套模板，主要是承上启下引入新课。
教师通过多媒体展示/播放xxx爱心修饰动画，并提出问题： 问题1：观察动画的变化过程，说出动画是如何变化的？ 问题2：观察动画的时间面板有什么特点？ 教师总结：类似于这样的动画就是形状补间动画，那这样的动画如何实现 下面就以制作形状补间动画来学习今天的内容 5 新课讲授 新课讲授的模板有多种，其实是按照教学方法设计的新课讲授模板，一般情况下以自主 / 合作研究和操作演示方式为主。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a51d3c0e49e4c167ed4f5d42bfb56c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ddd2a587cef9d51608d38a25e97ffc37/" rel="bookmark">
			手动搭建React项目脚手架(二)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		代码地址
手动搭建React项目脚手架(一)已经打包成功，接下开始写代码
修改index.js文件
import React from "react"; import { render } from "react-dom"; render(&lt;div&gt;my-frame根视图&lt;/div&gt;, document.getElementById("root")); 执行 npm run build报错
1.ES6兼容 通常我们需要把采用 ES6 编写的代码转换成目前已经支持良好的 ES5 代码，这包含2件事：
1 把新的 ES6 语法用 ES5 实现，例如 ES6 的 class 语法用 ES5 的 prototype 实现，需要用到：@babel/preset-env。
2 给新的 API 注入 polyfill ，例如项目使用 fetch API 时，只有注入对应的 polyfill 后，才能在低版本浏览器中正常运行，需要用到： @babel/polyfill 。
2.Babel Babel 是一个JavaScript 编译器
Babel是一个工具链，主要用于将ECMAScript 2015+代码转换为当前和旧版浏览器或环境中的向后兼容版本的JavaScript。以下是Babel可以为您做的主要事情：
1 转换语法
2 目标环境中缺少Polyfill功能（通过@ babel / polyfill）
3 源代码转换（codemods）
执行
npm install babel-loader @babel/core @babel/preset-env --save -D 修改 webpack.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ddd2a587cef9d51608d38a25e97ffc37/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/343c26b09231bf63063d173931df7e05/" rel="bookmark">
			Nginx配置中的80端口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		server { listen 80;//浏览器默认端口 server_name aa.bb.cn;//#提供服务的域名主机号 location /tt/ { proxy_pass http://localhost:9999/;//代理到的地址 } } 上面配置：nginx监听本机上80端口的请求，域名为aa.bb.cn,然后根路由为tt的请求，代理到http://localhost:9999/地址。
这个80端口不是访问浏览器80端口，而是浏览器访问服务器的80端口。
80端口是http协议规定的标准默认端口，指的是服务器监听80端口，而不是客户端必须使用80端口。80端口只是一个标准，而并非强制规定。
浏览器默认请求使用的是80端口，也就是我们的url中如果没有端口号，那么浏览器在发出请求时候默认使用的是80端口。
如果我们打开浏览器地址是 http://localhost:9998/
server { listen 9998; server_name localhost; location / { proxy_pass http://localhost:9999/; } } 那么nginx就不会走上面80端口的配置，走的是就是9998端口的配置，代理到http://localhost:9999/。
也就是如果我们使用的url有端口号，就不会走80的配置，走的是nginx中对应端口的配置。
推广一下自己开发的微信小程序，有兴趣的朋友可以玩一玩
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6bcbec6c22dbaa190228d1d493981df4/" rel="bookmark">
			平头哥剑池CDK使用与开发详解教程集合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一节：平头哥剑池CDK教程——使用SDK开始我的程序-CSDN博客
第二节：平头哥剑池CDK教程——工作空间及组件的概念-CSDN博客
第三节：平头哥剑池CDK教程——组件界面操作演示_cdk新建工程-CSDN博客
第四节：平头哥剑池CDK教程——组件的配置-CSDN博客
第五节：平头哥剑池CDK教程——工程管理集构建-CSDN博客
第六节：平头哥剑池CDK教程——模拟器概念及其配置方法-CSDN博客
第七节：平头哥剑池CDK教程——硬件调试器概念及配置方法-CSDN博客
第八节：平头哥剑池CDK教程——调试配置介绍-CSDN博客
第九节：平头哥剑池CDK教程——常用调试界面的演示-CSDN博客
第十节：平头哥剑池CDK教程——Watches窗口介绍-CSDN博客
第十一节：平头哥剑池CDK教程——断点的使用-CSDN博客
第十二节：平头哥剑池CDK教程——外设窗口的使用-CSDN博客
第十三节：平头哥剑池CDK教程——IOT方案开发之方案获取-CSDN博客
第十四节：平头哥剑池CDK教程——方案模板的二次开发-CSDN博客
第十五节：平头哥剑池CDK教程——芯片SDK开发之芯片SDK概念-CSDN博客
第十六节：平头哥剑池CDK教程——芯片SDK开发之创建初始SDK-CSDN博客
第十七节：平头哥剑池CDK教程——算法工程原理及创建-CSDN博客
第十八节：平头哥剑池CDK教程——算法工程开发步骤-CSDN博客
第十九节：平头哥剑池CDK教程——算法工程的调试和使用-CSDN博客
第二十节：平头哥剑池CDK教程——硬件相关组件开发-CSDN博客
第二十一节：平头哥剑池CDK教程——硬件无关组件开发-CSDN博客
第二十二节：平头哥剑池CDK教程——芯片SDK开发之发布SDK工程-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a5b16e554f8b0ee3c5319b35a0139f3/" rel="bookmark">
			Q_GDW1819-2013电压监测装置协议结构解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一 专业术语二 基本功能2.1 基础功能2.2 数据存储2.3 显示功能（设备能够看到的）2.4 参数设置与查询2.5 事件检测与告警功能 三 其他内容3.1 通信方式3.2 通信串口 四 帧结构解析4.1 传输方式4.2 数据帧格式4.2.1 报文头（2字节）4.2.2 报文长度（由内容区确定）4.2.3 电压监测装置ID（17个字节）4.2.4 帧类型（1个字节）4.2.5 报文类型（1个字节）4.2.6 帧序列号（1字节）4.2.7 报文内容（不确定）4.2.8 校验位（2字节）4.2.9 报文尾（1字节） 4.3 帧数据排列格式4.4 报文类型4.5 案例分析 参考文档：Q_GDW1819-2013电压监测装置技术规范 一 专业术语 电压偏差：由于电力系统正常运行状态的缓慢变化，使电压发生偏移，其电压变化率小于每秒1%时的实际运行电压值与系统标称电压的偏差相对值整定电压(标准)值 ( Ub)：按 GB/T12325 规定的供电电压偏差的上限电压标准值与下限电压标准值。**起动电压(Uq) **：刚好驱动电压监测装置超限计时，并稳定指示超限时的被监测电压值。整定电压值基本误差 (rz)：在正常使用条件下，电压监测装置上、下限整定电压的起动电压 Uq 和相应的整定电压(标准)值，Ub 之差与整定电压(标准)值 Ub 的比值(以百分数表示)。 **被监测的额定电压 (Un) **：被监测系统的额定电压。其值为 AC220V、380V、3kV、6kV、10kV、20kV、35kV、66 kV、10 kV 、220 kV 、330 kV 、500kV 、750 kV 和1000 kV 等。工作电源额定电压 (Ug)：电压监测装置的工作电源的额定电压值。其值为AC100V、220V 、380V 等。综合测量误差 (rc) ：在正常使用条件下，被测量的综合测量值 CX (如电压合格率，电压超上限率，电压超下限率),对应于被测量的预置值Cy 的相对误差(以百分数表示)。 电压合格率：实际运行电压偏差在限值范围内累计运行时间与对应的总运行统计时间的百分比。电压监测统计的时间单位为“min”。**电压超上限率 **：实际运行电压偏差在上限电压标准值以上范围内累计运行时间与对应的总运行统计时间的百分比。电压监测统计的时间单位为 “min”。**电压超下限率 **：实际运行电压偏差在下限电压标准值以下范围内累计运行时间与对应的总运行统计时间的百分比。电压监测统计的时间单位为“min”。时钟误差 ：在规定的时间间隔内，以时间指示偏差表示的增量或减量。状态接入控制器：复用状态监测接入层设备，以规定的数据格式对电压监测装置进行电压采集信息获取、转发及控制的一种装置。 二 基本功能 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a5b16e554f8b0ee3c5319b35a0139f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12b70c425f1edfbbbd9e4c9453db4122/" rel="bookmark">
			std::function 和 std::bind 的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考博客：【C++】C++11的std::function和std::bind用法详解_c++中的std中的方法-CSDN博客
直接上代码，不多bb：
std::function #include &lt;iostream&gt; #include &lt;functional&gt; using namespace std; typedef std::function&lt;int(int, int)&gt; com; typedef std::function&lt;int(int, int, int)&gt; comAdd; int add(int a, int b, int c) { return a + b + c; } int sub(int a, int b) { return a - b; } class multiply{ public: int operator()(int a, int b) { return a * b; } } auto divide = [](int a, int b) { return a / b; }; int main() { // 测试std::function comAdd c1 = add; com c2 = sub; com c3 = multiply; cout &lt;&lt; c1(1, 3, 5) &lt;&lt; endl; cout &lt;&lt; c2(1, 3) &lt;&lt; endl; cout &lt;&lt; c3(1, 3) &lt;&lt; endl; // 测试std::bind auto f1 = bind(add, 1, 2, 3); cout &lt;&lt; f1() &lt;&lt; endl; auto f2 = bind(sub, std::placeholder::_1, 4); cout&lt;&lt; f2(0) &lt;&lt; endl; auto f3 = bind(std, std::placeholder::_1, std::placeholder::_2); cout&lt;&lt; f3(0, 5) &lt;&lt; endl; // 测试std::function std::function&lt;int(int, int, int)&gt; f4 = std::bind(add, std::placeholder::_1, 9, 9); cout&lt;&lt; f4(1, 0, 0) &lt;&lt;endl; std::function&lt;int(int, int, int)&gt; f5 = std::bind(add, 9, 9, 9); cout&lt;&lt; f5(0, 1, 1) &lt;&lt;endl; std::functoin&lt;int(int, int)&gt; f6 = std::bind(divide, 6, 3); cout&lt;&lt; f6(9, 3) &lt;&lt;endl; return 0; } 输出结果：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/12b70c425f1edfbbbd9e4c9453db4122/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a406163447cf3362e87a9131c2a116ff/" rel="bookmark">
			在K8S中部署NFS服务器并在K8S集群外使用NFS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景说明 有这样一个场景，我们需要使用多个NFS Server来做负载均衡，Server中保存的文件只读，所以不用考虑数据同步。
一种可能的实现方式是在物理服务器上安装NFS Server，同时安装负载均衡软件来实现（如LVS等），配置起来比较繁琐。
这里考虑在kubernetes集群部署NFS server三副本，同时安装metallb实现负载均衡。
安装负载均衡器 由于这里使用的是rke2搭建的kubernetes集群，需要编辑/etc/rancher/rke2/config.yaml文件，增加如下配置后，重启rke2
kube-proxy-arg: # 不指定的话，默认是 iptables 模式 - proxy-mode=ipvs - ipvs-strict-arp=true helm一键安装metallb
helm repo add metallb https://metallb.github.io/metallb helm install metallb metallb/metallb 创建L2Advertisement，使集群外的服务器也可以访问NFS Server
cat&lt;&lt;EOF | kubectl apply -f - apiVersion: metallb.io/v1beta1 kind: IPAddressPool metadata: name: first-pool spec: addresses: - 192.168.122.20-192.168.122.24 --- apiVersion: metallb.io/v1beta1 kind: L2Advertisement metadata: name: example EOF 在kubernetes集群中部署NFS Server cat&lt;&lt;EOF | kubectl apply -f - apiVersion: apps/v1 kind: Deployment metadata: name: nfs-server spec: replicas: 3 selector: matchLabels: app: nfs-server template: metadata: labels: app: nfs-server spec: containers: - name: nfs-server image: k8s.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a406163447cf3362e87a9131c2a116ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8bc9bf4d08c1569ace9d854ff1241748/" rel="bookmark">
			R语言画三维柱状图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作业中需要画三维柱状图，尝试了两种方法：
一是scatterplot3d包，函数与包同名。
z &lt;- matrix(data3d, nrow=1) x &lt;- matrix(datax, nrow=1) y &lt;- matrix(datay, nrow=1) scatterplot3d(x,y,z,type='h',lwd=5,color=rainbow(10)) 这个图比较简单，但是不能旋转。想要画可以旋转的图，可以用rgl包的plot3d函数。
library(rgl) library(RColorBrewer) plot3d(x, y, z, col =brewer.pal(10,'BrBG'),size=10,lwd=5, type = 'h',background='black') 效果不错。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28a4559288fc22a5da03c4b8cd08a868/" rel="bookmark">
			Katex 输入四种矩阵
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在做作业的时候需要输入矩阵，有以下样式可供选择：
\begin{pmatrix} Y\\X \end{pmatrix} 这是圆括号矩阵
\begin{bmatrix} Y\\X \end{bmatrix} 这是方括号矩阵
\begin{Bmatrix} Y\\X \end{Bmatrix} 这是花括号矩阵
\begin{vmatrix} A&amp;B\\C&amp;D \end{vmatrix} 这是行列式
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e7a80ed83b0e472af5a53f17490a334/" rel="bookmark">
			实现数组去重和数组扁平化的多种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、数组去重
1. 使用双层for循环进行去重
2. 使用indexOf或者lastIndexOf去重
3. 使用includes方法进行数组去重
4. 搭配使用forEach + includes /indexOf /lastIndexOf进行数组去重
5. 利用filter方法 + includes/indexOf/lastIndexOf进行数组去重
6. 利用set去重
二、数组扁平化
1. 利用递归实现数组扁平化
2. 利用map映射实现数组扁平化
3. 利用es6 flat方法进行数组扁平化 一、数组去重 1. 使用双层for循环进行去重 思路：对比前一项和后一项是否相等 相等删除后一项，修正下标
var arr = [1,2,3,4,5,4,1,3,2,1]; function unique(arr){ // 循环前一项 for(var i=0;i&lt;arr.length;i++){ //循环后一项 for(var j=i+1;j&lt;arr.length;j++){ if(arr[i]===arr[j]){ // 删除后一项重复的数组元素 arr.splice(j,1); // 修正下标 j--; } } } return arr } console.log(unique(arr)); 代码运行结果如下：
2. 使用indexOf或者lastIndexOf去重 思路：创建一个新的数组 判断重复数组元素是否存在新数组中 不存在直接添加到新数组
var arr = [1,2,3,4,5,4,1,3,2,1]; function unique(arr){ var newArr = []; for(var i=0;i&lt;arr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e7a80ed83b0e472af5a53f17490a334/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef2f6fe877461ac6ca0ea4613c63e6b0/" rel="bookmark">
			Android蓝牙
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、第一种框架集成方式
1.在项目根目录的build.gradle文件中，添加如下配置：
2.在app module的build.gradle中，添加依赖：
3.使用前先在你应用的Application中调init方法初始化框架
4.然后必须调用enableBluetooth()方法开启蓝牙功能，你可以在activity中调用：
5.如果是低功耗蓝牙，需要设置配置项，经典蓝牙忽略跳过这一步即可：
6.开启蓝牙能力后，接着你就可以开始进行蓝牙设备扫描，其中，type 为蓝牙设备类型（经典蓝牙或低功耗蓝牙）：
7.一旦扫描到设备，你就可以找到目标设备并连接：
8.设备连接成功后，你可以开始跟设备进行通信：
9.那么如何接收蓝牙设备返回给你的数据呢，很简单，在Receiver中接收：
10.最后，调用以下方法去主动断开连接并释放资源 ：
第二种集成方式
1.由于是代码引入，故无需像第一步那样进行库的引入，直接在Application中初始化。
2.蓝牙界面
3.UUidStateBean对象
4.蓝牙信息对象BletoothInfoBen
5.进度对话框
6.ble_servies_select_dialog布局
7.gble_layout蓝牙布局
Android 蓝牙开发，很多项目会使用到，自己去摸索封装或者引用其他框架，也能解决部分问题。为何说是部分问题，Android蓝牙分为低功耗版与经典版，经典版是可以直接选择即可实现链接，低功耗版是需要配置uuid。故推荐一个框架，下面来分享使用教程。分两部分第一部分是直接使用框架，第二部分是修改框架源码，使用哪一种方式可以结合自己的需要。Android开发建议使用Android蓝牙调试工具app初步调试使用，这里推荐BLE调试助手app，各大应用市场都可以下载。BLE调试助手首页展示。 Java语言版本地址：https://github.com/g-HJY/HBluetooth
Kotlin语言版本地址：https://github.com/g-HJY/Kotlin-HBluetooth （暂停维护）
一、第一种框架集成方式 首先是集成方式，当然你可以直接在github上将整个项目下载下来，也可以将其以依赖的形式集成到你的项目中，具体步骤如下：
1.在项目根目录的build.gradle文件中，添加如下配置： allprojects { repositories { ... maven { url 'https://jitpack.io' } } } 2.在app module的build.gradle中，添加依赖： dependencies { implementation 'com.github.g-HJY:HBluetooth:V1.3.6' } 3.使用前先在你应用的Application中调init方法初始化框架 public class XiaoYaApp extends MultiDexApplication { @Override public void onCreate() { super.onCreate(); HBluetooth.init(this); } } 4.然后必须调用enableBluetooth()方法开启蓝牙功能，你可以在activity中调用： //开启蓝牙功能 HBluetooth.getInstance().enableBluetooth() 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef2f6fe877461ac6ca0ea4613c63e6b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80a8c5760a29105d6796a7f4ed00728a/" rel="bookmark">
			flink源码分析之功能组件(六)-心跳组件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 本系列是flink源码分析的第二个系列，上一个《flink源码分析之集群与资源》分析集群与资源，本系列分析功能组件，kubeclient，rpc，心跳，高可用，slotpool，rest，metrics，future。
本文解释心跳组件，心跳组件监听组件间连接活性，超时触发重连，保证连接有效性；断连后通知并释放资源，心跳可以带荷载，作为组件间数据交换的方式
心跳组件依赖rpc组件实现通讯，rpc的解释可参考本系列flink源码分析之功能组件(三)-rpc组件
心跳组件 心跳组件通过定时心跳，监视组件被管理组件的存活，心跳可携带载荷信息，实现轻量级实时/准实时的信息交换
心跳组件依赖rpc组件实现通讯服务，关于rpc组件参考相关的分析章节
心跳组件有两个角色：sender和receiver。检测动作是Sender主动发起请求，Reciver给Sender回一个心跳，在这一个来回sender和receiver相互检测。
设计类图 上图是心跳设计类图
HeartbeatServices 与其他模块一样，flink的代码习惯， ***Services是构建工厂，负责抓取配置，构建服务
HeartbeatTarget 监控目标接口，requestHeartbeat/receiveHeartbeat两个方法，分别是发送心跳请求，接收心跳请求
HeartbeatSender HeartbeatTarget发送(Sender)实现基类，屏蔽receiveHeartbeat方法
HeartbeatReceiver HeartbeatTarget接收(Receive)实现基类，屏蔽senderHeartbeat方法
HeartbeatMonitor 心跳监测器，管理HeartbeatTarget，设置心跳监听器，超时通知
DefaultHeartbeatMonitor 心跳检测器实现，内置定时执行器，定时检查超时，通知客户
HeartbeatManager HeartbeatTarget管理器，负责启停HeartbeatTarget，自身是HeartbeatTarget实现，形成合成模式，操作HeartbeatTarget集合与操作单个HeartbeatTarget一致的接口，有两个实现：
HearbeatManagerImpl 实现为心跳Receiver器管理器
HeartbeatManagerSenderImpl 实现为心跳Sender管理器，继承自HearbeatManagerImpl，自身实现了Runnable接口，并内置ScheduledExecutor，定时发送心跳请求
管理器主要方法是monitorTarget，增加心跳目标
HeartbeatListener 用户实现 心跳监听，载荷通知；负责构建载荷
心跳 心跳是心跳组件的主要职责，sender和receive通过心跳，相互检测监控状态，可搭载负载，实时交换信息。
心跳的过程解释在下面示例章节结合作业管理器-任务管理器心跳解释
超时检测 超时是Sender在设定时间未收到目标返回心跳，认为目标组件已不可用，通知上级调用者心跳超时
超时检测是DefaultHeartbeatMonitor负责，
重置超时检查 前面解释了，DefaultHeartbeatMonitor实现了Runable接口，内置ScheduledExecutor
下面方法resetHeartbeatTimeout，重置延时执行方法，延时也是超时的时间，方法有两重意思，停止前面的延时；设置新的延时
DefaultHeartbeatMonitor构造函数调用了该方法初始设置
run方法 延时时间到了，也即心跳超时，State的4个状态，其中
UNREACHABLE rpc异常
CANCELED 认为停止
TIMEOUT 只有run方法设置
因此，不执行超时的唯一方法就是不执行run方法，即延时到达前叫停ScheduledExecutor
重设超时 reportHeartbeat报告收到心跳，调用重置超时检查，重新设置延时，实际就是叫停并重置ScheduledExecutor
reportHeartbeat是HearbeatManagerImpl接收到心跳返回时调用receiveHeartbeat，调用reportHearbeat，就是说，在心跳检查延时前收到心跳回应，心跳超时检查就会被重置
示例 本节以作业管理器与任务管理器心跳为例，解释心跳组件原理和使用。作业管理器是心跳管理者，管理多个任务管理器
构建 作业管理器和任务管理器构建心跳管理器，并设置心跳目标
作业管理器 作业管理器对任务管理器的心跳管理是Sender，即心跳发起者
作业管理器的心跳管理器设置任务管理器心跳目标，指向任务管理器
心跳目标继承自HeartbeatSender，并带载荷AllocatedSlotReport，任务管理器的资源slot分配报告
任务管理器 与作业管理器对应，任务管理器对作业管理器的心跳管理器是Reciver，接收者；心跳管理器设置作业管理器心跳目标，继承自HeartbeatReceiver
心跳 心跳的流程，定时请求--&gt;rpc发送请--&gt;接收方处理心跳请求，返回--&gt;发送方处理接收方的返回
请求 发送管理器自身实现Runable接口，使用Executor延时发送心跳请求
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/80a8c5760a29105d6796a7f4ed00728a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/828b70be3688697a662755f0fdefa8a8/" rel="bookmark">
			华为OD机考机试 真题目录（C卷 &#43; D卷 &#43; B卷 &#43; A卷） &#43; 考点说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		华为OD机考:统一考试 C卷 + D卷 + B卷 +A卷 2023年11月份，华为官方已经将 华为OD机考：OD统一考试（A卷 / B卷）切换到 OD统一考试（C卷）和 OD统一考试（D卷） 。根据考友反馈：目前抽到的试卷为B卷或C卷/D卷，其中C卷居多 ，按照之前的经验C卷D卷部分考题会复用A卷/B卷题，博主正积极从考过的同学收集C卷和D卷真题，可以查看下面的真题目录。
真题目录：华为OD机考机试 真题目录（C卷 + D卷 + B卷 + A卷） + 考点说明 专栏：2023华为OD机试( B卷+C卷+D卷)（C++JavaJSPy）
华为OD面试真题精选：华为OD面试真题精选
在线OJ：点击立即刷题，模拟真实机考环境 华为OD机考B卷C卷华为OD机考华为OD机考B卷华为OD机试B卷华为OD机试C卷华为OD机考C卷华为OD机考D卷题目华为OD机考C卷/D卷答案华为OD机考C卷/D卷解析华为OD机考C卷和D卷真题华为OD机考C卷和D卷题解
支持的语言 题解使用C++ Java JavaScript 以及python实现。
华为od机试C卷 - 100分 序号题目链接知识点刷题所属1字符串序列判定/最后一个有效字符https://blog.csdn.net/banxia_frontend/article/details/134300229双指针立即刷题华为OD统一考试（C卷）2山脉的个数https://blog.csdn.net/banxia_frontend/article/details/134322395逻辑题立即刷题华为OD统一考试（C卷）3构成指定长度字符串的个数https://blog.csdn.net/banxia_frontend/article/details/134450378去重排列组合立即刷题华为OD统一考试（C卷）4用连续自然数之和来表达整数https://blog.csdn.net/banxia_frontend/article/details/134430737滑动窗口立即刷题华为OD统一考试（C卷）5全量和已占用字符集https://blog.csdn.net/banxia_frontend/article/details/134430918逻辑题立即刷题华为OD统一考试（C卷）6密码输入检测https://blog.csdn.net/banxia_frontend/article/details/134431388逻辑题立即刷题华为OD统一考试（C卷）7查找众数及中位数https://blog.csdn.net/banxia_frontend/article/details/134451242逻辑题立即刷题华为OD统一考试（C卷）8最长的指定瑕疵度的元音子串https://blog.csdn.net/banxia_frontend/article/details/134451414双指针立即刷题华为OD统一考试（C卷）9整数对最小和https://blog.csdn.net/banxia_frontend/article/details/134451990逻辑题立即刷题华为OD统一考试（C卷）10找出作弊的人https://blog.csdn.net/banxia_frontend/article/details/134451961排序比较立即刷题华为OD统一考试（C卷）11最长子字符串的长度/字符成环找偶数Ohttps://blog.csdn.net/banxia_frontend/article/details/134474609逻辑题立即刷题华为OD统一考试（C卷）12找座位https://blog.csdn.net/banxia_frontend/article/details/134519903逻辑题立即刷题华为OD统一考试（C卷）13转盘寿司https://blog.csdn.net/banxia_frontend/article/details/134521254循环数组/栈立即刷题华为OD统一考试（C卷14找朋友https://blog.csdn.net/banxia_frontend/article/details/134521336栈立即刷题华为OD统一考试（C卷15爱吃蟠桃的孙悟空https://blog.csdn.net/banxia_frontend/article/details/134563292二分法立即刷题华为OD统一考试（C卷16游戏分组/英雄联盟https://blog.csdn.net/banxia_frontend/article/details/134564424DFS立即刷题华为OD统一考试（C卷17求满足条件的最长子串的长度https://blog.csdn.net/banxia_frontend/article/details/134564473滑动窗口立即刷题华为OD统一考试（C卷18分割均衡字符串https://blog.csdn.net/banxia_frontend/article/details/134588066贪心立即刷题华为OD统一考试（C卷19机器人仓库搬砖https://blog.csdn.net/banxia_frontend/article/details/134609013二分法立即刷题华为OD统一考试（C卷20出租车计费 、靠谱的车https://blog.csdn.net/banxia_frontend/article/details/134609213数学立即刷题华为OD统一考试（C卷21寻找最富裕的小家庭https://blog.csdn.net/banxia_frontend/article/details/134622503逻辑题华为OD统一考试（C卷22开源项目热度榜单https://blog.csdn.net/banxia_frontend/article/details/134632396排序比较华为OD统一考试（C卷23考勤信息https://blog.csdn.net/banxia_frontend/article/details/134632714逻辑题华为OD统一考试（C卷24寻找身高相近的小朋友https://blog.csdn.net/banxia_frontend/article/details/134633446逻辑题华为OD统一考试（C卷25分配土地https://blog.csdn.net/banxia_frontend/article/details/134677846数学华为OD统一考试（C卷26剩余银饰的重量https://blog.csdn.net/banxia_frontend/article/details/134678720暴力模拟华为OD统一考试（C卷27内存冷热标记https://blog.csdn.net/banxia_frontend/article/details/134699504排序比较华为OD统一考试（C卷28字符串摘要https://blog.csdn.net/banxia_frontend/article/details/134699684逻辑题华为OD统一考试（C卷29整型数组按个位值排序/最低位排序https://blog.csdn.net/banxia_frontend/article/details/134699788排序比较华为OD统一考试（C卷30数组去重和排序https://blog.csdn.net/banxia_frontend/article/details/134699863排序比较华为OD统一考试（C卷31学生排名/智能成绩表https://blog.csdn.net/banxia_frontend/article/details/134700891排序比较华为OD统一考试（C卷32按身高和体重排队https://blog.csdn.net/banxia_frontend/article/details/134700937排序比较华为OD统一考试（C卷33字符串变换最小字符串https://blog.csdn.net/banxia_frontend/article/details/134700976排序比较华为OD统一考试（C卷34GPU 调度/执行时长https://blog.csdn.net/banxia_frontend/article/details/134701034逻辑题华为OD统一考试（C卷35最大N个数与最小N个数的和https://blog.csdn.net/banxia_frontend/article/details/134701110逻辑题华为OD统一考试（C卷36小明找位置https://blog.csdn.net/banxia_frontend/article/details/134722983二分法华为OD统一考试（C卷37执行任务赚获取最多积分https://blog.csdn.net/banxia_frontend/article/details/134749542贪心华为OD统一考试（C卷38最多购买宝石数目https://blog.csdn.net/banxia_frontend/article/details/134750300滑动窗口华为OD统一考试（C卷39素数之积/RSA加密算法https://blog.csdn.net/banxia_frontend/article/details/134770436数学华为OD统一考试（C卷40掌握单词个数、万能字符单词拼写https://blog.csdn.net/banxia_frontend/article/details/134771050逻辑题华为OD统一考试（C卷41CPU算力分配https://blog.csdn.net/banxia_frontend/article/details/134771758数学华为OD统一考试（C卷42小明的幸运数、最大坐标值https://blog.csdn.net/banxia_frontend/article/details/134772493逻辑题华为OD统一考试（C卷43来自异国的客人/幸运数字https://blog.csdn.net/banxia_frontend/article/details/134793796数学华为OD统一考试（C卷44园区参观路径https://blog.csdn.net/banxia_frontend/article/details/134794410动态规划华为OD统一考试（C卷45英文输入法https://blog.csdn.net/banxia_frontend/article/details/134794792字符串华为OD统一考试（C卷46字符串筛选排序https://blog.csdn.net/banxia_frontend/article/details/134864833字符串华为OD统一考试（C卷47拼接URLhttps://blog.csdn.net/banxia_frontend/article/details/134795502字符串华为OD统一考试（C卷48最少停车数/停车场车辆统计https://blog.csdn.net/banxia_frontend/article/details/134795768逻辑题华为OD统一考试（C卷49API集群负载统计https://blog.csdn.net/banxia_frontend/article/details/134818933字符串华为OD统一考试（C卷50求最多可以派出多少支团队https://blog.csdn.net/banxia_frontend/article/details/134818983双指针华为OD统一考试（C卷51寻找连续区间/数组连续和https://blog.csdn.net/banxia_frontend/article/details/134819088动态规划华为OD统一考试（C卷52字符串分割转换https://blog.csdn.net/banxia_frontend/article/details/134841118字符串华为OD统一考试（C卷53连续字母长度https://blog.csdn.net/banxia_frontend/article/details/134841278字符串华为OD统一考试（C卷54火星文计算https://blog.csdn.net/banxia_frontend/article/details/134841348栈华为OD统一考试（C卷55虚拟游戏理财https://blog.csdn.net/banxia_frontend/article/details/134891561栈华为OD统一考试（C卷56绘图机器https://blog.csdn.net/banxia_frontend/article/details/134841426逻辑题华为OD统一考试（C卷57机场航班调度https://blog.csdn.net/banxia_frontend/article/details/134843115排序比较华为OD统一考试（C卷58围棋的气https://blog.csdn.net/banxia_frontend/article/details/134908319逻辑题华为OD统一考试（C卷59小华地图寻宝https://blog.csdn.net/banxia_frontend/article/details/134901578DFS华为OD统一考试（C卷60计算三叉搜索树的高度树华为OD统一考试（C卷61石头剪刀布游戏https://blog.csdn.net/banxia_frontend/article/details/134909498逻辑题华为OD统一考试（C卷62多段线数据压缩https://blog.csdn.net/banxia_frontend/article/details/134910108数学题华为OD统一考试（C卷63求字符串中所有整数的最小和https://blog.csdn.net/banxia_frontend/article/details/134910880逻辑题华为OD统一考试（C卷 华为od机试C卷 - 200分 题目链接知识点刷题1查找接口成功率最优时间段https://blog.csdn.net/banxia_frontend/article/details/134450561前缀和立即刷题华为OD统一考试（C卷2可以组成网络的服务器https://blog.csdn.net/banxia_frontend/article/details/134450587深度优先搜索DFS立即刷题华为OD统一考试（C卷3MELON的难题https://blog.csdn.net/banxia_frontend/article/details/134450608动态规划立即刷题华为OD统一考试（C卷4最长合法表达式https://blog.csdn.net/banxia_frontend/article/details/134472024双指针华为OD统一考试（C卷5数据单元的变量替换https://blog.csdn.net/banxia_frontend/article/details/134472566逻辑题华为OD统一考试（C卷6最多几个直角三角形https://blog.csdn.net/banxia_frontend/article/details/134587216DFS /栈华为OD统一考试（C卷7欢乐的周末https://blog.csdn.net/banxia_frontend/article/details/134588123DFS华为OD统一考试（C卷城市聚集度/找城市并查集华为OD统一考试（C卷找最小数https://blog.csdn.net/banxia_frontend/article/details/134841982栈华为OD统一考试（C卷找单词https://blog.csdn.net/banxia_frontend/article/details/134842033DFS华为OD统一考试（C卷跳马https://blog.csdn.net/banxia_frontend/article/details/134891949BFS华为OD统一考试（C卷项目排期DFS华为OD统一考试（C卷分月饼https://blog.csdn.net/banxia_frontend/article/details/134892937递归华为OD统一考试（C卷考古学家考古问题https://blog.csdn.net/banxia_frontend/article/details/134911010dfs华为OD统一考试（C卷分解连续正整数组合/ 分解正整数https://blog.csdn.net/banxia_frontend/article/details/134947565数学题华为OD统一考试（C卷 华为OD统一考试（B卷） - 100分值 题目链接知识点敏感字段加密https://blog.csdn.net/banxia_frontend/article/details/130042378字符串IPv4地址转换成整数https://blog.csdn.net/banxia_frontend/article/details/130042566字符串报文重排序https://blog.csdn.net/banxia_frontend/article/details/130814556字符串整数编码https://blog.csdn.net/banxia_frontend/article/details/130816655阿里巴巴找黄金宝箱 (1)https://blog.csdn.net/banxia_frontend/article/details/130817028指针VLAN资源池https://blog.csdn.net/banxia_frontend/article/details/130042590逻辑分析统计监控器、需要打开多少监控器https://blog.csdn.net/banxia_frontend/article/details/130875613逻辑分析求字符串中所有整数的最小和https://blog.csdn.net/banxia_frontend/article/details/130043034逻辑分析求满足条件的最长子串的长度https://blog.csdn.net/banxia_frontend/article/details/130043268滑动窗口字符串分割https://blog.csdn.net/banxia_frontend/article/details/130888094字符串简易压缩算法https://blog.csdn.net/banxia_frontend/article/details/130887642字符串一种字符串压缩表示的解压https://blog.csdn.net/banxia_frontend/article/details/130043674字符串矩阵最大值https://blog.csdn.net/banxia_frontend/article/details/130044296逻辑分析字符串加密https://blog.csdn.net/banxia_frontend/article/details/130047719动态规划英文输入法https://blog.csdn.net/banxia_frontend/article/details/130047940字符串拼接URLhttps://blog.csdn.net/banxia_frontend/article/details/130049091正则匹配相对开音节https://blog.csdn.net/banxia_frontend/article/details/130057726正则匹配最远足迹https://blog.csdn.net/banxia_frontend/article/details/130057872数据结构字符串序列判定https://blog.csdn.net/banxia_frontend/article/details/130069530指针数列描述https://blog.csdn.net/banxia_frontend/article/details/130070682动态规划寻找相同子串https://blog.csdn.net/banxia_frontend/article/details/130071234字符串字符串变换最小字符串https://blog.csdn.net/banxia_frontend/article/details/129289091字符串找终点https://blog.csdn.net/banxia_frontend/article/details/130117501逻辑分析执行时长https://blog.csdn.net/banxia_frontend/article/details/130119270逻辑分析用户调度问题https://blog.csdn.net/banxia_frontend/article/details/130889808深度优先搜索DFS数组拼接https://blog.csdn.net/banxia_frontend/article/details/130173373字符串检查是否存在满足条件的数字组合https://blog.csdn.net/banxia_frontend/article/details/130174695深度优先搜索DFS水仙花数 Ⅰhttps://blog.csdn.net/banxia_frontend/article/details/130171852逻辑分析路灯照明问题https://blog.csdn.net/banxia_frontend/article/details/130174877区间问题 / 区间合并消消乐游戏https://blog.csdn.net/banxia_frontend/article/details/130177360数据结构用连续自然数之和来表达整数https://blog.csdn.net/banxia_frontend/article/details/130172885滑动窗口最大花费金额https://blog.csdn.net/banxia_frontend/article/details/130116925滑动窗口分糖果https://blog.csdn.net/banxia_frontend/article/details/130116367位运算猴子爬山https://blog.csdn.net/banxia_frontend/article/details/130115751动态规划数组组成的最小数字https://blog.csdn.net/banxia_frontend/article/details/130114597字符串整型数组按个位值排序https://blog.csdn.net/banxia_frontend/article/details/129306346字符串运维日志排序https://blog.csdn.net/banxia_frontend/article/details/130114406字符串字符统计及重排https://blog.csdn.net/banxia_frontend/article/details/130173033字符串按身高和体重排队https://blog.csdn.net/banxia_frontend/article/details/130104661字符串磁盘容量排序https://blog.csdn.net/banxia_frontend/article/details/130104442双指针5键键盘https://blog.csdn.net/banxia_frontend/article/details/130096051逻辑分析报数游戏https://blog.csdn.net/banxia_frontend/article/details/130095889约瑟夫环问题高矮个子排队https://blog.csdn.net/banxia_frontend/article/details/130095797滑动窗口分班问题https://blog.csdn.net/banxia_frontend/article/details/130095305逻辑分析喊7的次数重排https://blog.csdn.net/banxia_frontend/article/details/130072441约瑟夫环问题玩牌高手https://blog.csdn.net/banxia_frontend/article/details/130072194动态规划最少交换次数https://blog.csdn.net/banxia_frontend/article/details/130042175滑动窗口水仙花数Ⅱhttps://blog.csdn.net/banxia_frontend/article/details/130036570分治递归关联子串https://blog.csdn.net/banxia_frontend/article/details/130036439深度优先搜索DFS矩形相交的面积https://blog.csdn.net/banxia_frontend/article/details/130036104逻辑分析数字反转打印https://blog.csdn.net/banxia_frontend/article/details/130022410逻辑分析太阳能板最大面积https://blog.csdn.net/banxia_frontend/article/details/130022091双指针绘图机器https://blog.csdn.net/banxia_frontend/article/details/130022003逻辑分析字符串子序列IIhttps://blog.csdn.net/banxia_frontend/article/details/130010116双指针求最多可以派出多少支团队https://blog.csdn.net/banxia_frontend/article/details/130009910双指针流水线https://blog.csdn.net/banxia_frontend/article/details/130000922逻辑分析事件推送、 所有（Ai, Bj）数对https://blog.csdn.net/banxia_frontend/article/details/130000553逻辑分析找朋友https://blog.csdn.net/banxia_frontend/article/details/129999376数据结构统计射击比赛成绩https://blog.csdn.net/banxia_frontend/article/details/129998971字符串分苹果https://blog.csdn.net/banxia_frontend/article/details/129998670位运算最长的顺子https://blog.csdn.net/banxia_frontend/article/details/129793342逻辑分析斗地主之顺子https://blog.csdn.net/banxia_frontend/article/details/129844867数据结构热点网站统计https://blog.csdn.net/banxia_frontend/article/details/129895021字符串出错的或电路https://blog.csdn.net/banxia_frontend/article/details/129939817深度优先搜索DFS快速人名查找https://blog.csdn.net/banxia_frontend/article/details/129827444回溯算法比赛https://blog.csdn.net/banxia_frontend/article/details/130898490字符串补种未成活胡杨https://blog.csdn.net/banxia_frontend/article/details/130900032滑动窗口五子棋迷https://blog.csdn.net/banxia_frontend/article/details/130900644滑动窗口组成最大数https://blog.csdn.net/banxia_frontend/article/details/130901124字符串全量和已占用字符集https://blog.csdn.net/banxia_frontend/article/details/130071738字符串乱序整数序列两数之和绝对值最小https://blog.csdn.net/banxia_frontend/article/details/130901386双指针寻找连续区间、数据连续和https://blog.csdn.net/banxia_frontend/article/details/130901621动态规划非严格递增连续数字序列https://blog.csdn.net/banxia_frontend/article/details/130901696指针快递运输https://blog.csdn.net/banxia_frontend/article/details/130901947逻辑分析不等式是否满足约束并输出最大差https://blog.csdn.net/banxia_frontend/article/details/130902299逻辑分析靠谱的车https://blog.csdn.net/banxia_frontend/article/details/130902533位运算选修课https://blog.csdn.net/banxia_frontend/article/details/130903630位运算连续字母长度https://blog.csdn.net/banxia_frontend/article/details/130048972正则匹配找车位https://blog.csdn.net/banxia_frontend/article/details/130019456逻辑分析数字涂色https://blog.csdn.net/banxia_frontend/article/details/130172193逻辑分析查找众数及中位数https://blog.csdn.net/banxia_frontend/article/details/129288857逻辑分析数组去重和排序https://blog.csdn.net/banxia_frontend/article/details/129720509字符串单词接龙https://blog.csdn.net/banxia_frontend/article/details/130044643字符串最长公共后缀https://blog.csdn.net/banxia_frontend/article/details/1309103293排序单词接龙https://blog.csdn.net/banxia_frontend/article/details/130044643字符串最大矩阵和、最大子矩阵https://blog.csdn.net/banxia_frontend/article/details/130934482动态规划数据分类https://blog.csdn.net/banxia_frontend/article/details/129845067逻辑分析TLV 编码https://blog.csdn.net/banxia_frontend/article/details/130048337字符串调座、座位调整https://blog.csdn.net/banxia_frontend/article/details/131057134逻辑分析字符串摘要https://blog.csdn.net/banxia_frontend/article/details/131077082字符串代码编辑器https://blog.csdn.net/banxia_frontend/article/details/131076674字符串经典屏保https://blog.csdn.net/banxia_frontend/article/details/131077496逻辑分析食堂供餐https://blog.csdn.net/banxia_frontend/article/details/131077763二分法阿里巴巴找黄金宝箱(II)https://blog.csdn.net/banxia_frontend/article/details/131077928深度优先搜索DFS阿里巴巴找黄金宝箱(I)https://blog.csdn.net/banxia_frontend/article/details/131078473指针模拟消息队列https://blog.csdn.net/banxia_frontend/article/details/131097948阿里巴巴找黄金宝箱(V)https://blog.csdn.net/banxia_frontend/article/details/131098330滑动窗口矩阵稀疏扫描https://blog.csdn.net/banxia_frontend/article/details/131098534逻辑分析报文回路https://blog.csdn.net/banxia_frontend/article/details/131387764逻辑分析计算最接近的数https://blog.csdn.net/banxia_frontend/article/details/131466725求最小步数https://blog.csdn.net/banxia_frontend/article/details/131487991逻辑分析，动态规划分割数组的最大差值https://blog.csdn.net/banxia_frontend/article/details/131488179增强的strstrhttps://blog.csdn.net/banxia_frontend/article/details/131609115正则表达式支持优先级的队列https://blog.csdn.net/banxia_frontend/article/details/131609615数据结构 2023华为OD统一考试（B卷） - 200分值 题目链接知识点书籍叠放https://blog.csdn.net/banxia_frontend/article/details/130903074耐心排序 + 二分查找We Are A Teamhttps://blog.csdn.net/banxia_frontend/article/details/130115654数据结构 / 并查集区间交集https://blog.csdn.net/banxia_frontend/article/details/129793003区间问题 / 区间合并跳格子游戏https://blog.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/828b70be3688697a662755f0fdefa8a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/655c1445343379c5a393c2d82825d5d6/" rel="bookmark">
			【腾讯云云上实验室】用向量数据库融合AI技术：构建下一代智能客服平台
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言为什么说用好大模型离不开向量数据库呢?AI训练中的向量维度快速检索非结构化数据的利器 --- 向量数据库AI的海马体--腾讯云向量数据库 一、腾讯云向量数据库介绍重磅组合，行业领先智能化能力产品亮点 二、AI技术在智能客服中的作用AI技术在智能客服平台中的关键作用融合AI技术与向量数据库的优势与挑战 三、智能客服平台构建物料准备原始数据获取 项目开发创建数据库创建 CollectionEmbedding连接数据库写入原始数据相似度查询相似度查询本地化新增数据 四、向量数据库api1. 搭建FastAPI 开启本地接口调用 五、常见问题六、总结 前言 为什么说用好大模型离不开向量数据库呢? 回答这个问题之前我们先来理解一下什么是向量?
比如在我们看到这个水果时，我们知道它是一个苹果。但在“苹果”这个词被发明之前，人们是如何描述这个水果的呢？通过观察它的颜色、大小、形状、纹理等特征，我们可以更清晰地定义这个水果。将这些特征用数字来表达，我们就可以得到一个向量。
一旦复杂的图像被转换成计算机可识别的数字表示，计算机就可以“认识”这个苹果了。但是，当新的苹果出现时，计算机还能识别它吗？当然可以，因为新的图像在向量空间中与最接近的向量具有高相似性，计算机可以通过比较向量之间的相似度来进行识别。
AI训练中的向量维度 今天让我们惊叹不已的人工智能,往往通过上千个向量维度来学习训练,他们就像是AI大模型的眼睛,当AI大模型遇上庞大的向量数据,这组黄金搭档如何让硅基生物更聪明呢?
以大语言模型为例。简单来说在训练时， 喂给它的词句都会先转化为向量数据， 当训练数据里出现多组类似的语言时，在向量数据组成的高维空间，相近的词汇就会距离更近，语言模型就可以逐渐捕捉到词汇间的语意和语法。
举例说明： 它会更明白苹果和西瓜语意上接近，但是和公交车相差甚远，接下来模型需要对上下文进行理解,此时Transformer架构就开始发挥作用,从每个词自身出发,观察和其他词之间的关系权重。
例如这句话里“我昨天买的苹果很好吃”， “很好吃”和“我”关系权重最大，权重结果被当作新的维度记录下来，一句更复杂的话，也转化成了带权重的向量，原模型经过查询计算。生成权重最高的答案输出给你，一次问答就完成了
快速检索非结构化数据的利器 — 向量数据库 大模型训练推理过程更为复杂,他们需要处理如文本图像,音视频等大量非结构化数据，并转化为向量数据进行学习，这些数据的规模动辄过亿,向量维度可能高达数千,在选择数据库时,传统数据库只能进行行列检索一一对应,
再输出精准的答案，但向量数据库，则是专门为非结构化数据检索而设计，它将项量数据组成一个立体高维空间,在空间中进行模糊检索，能够快速输出权重最高的答案。
AI的海马体–腾讯云向量数据库 业界的AI大模型采取预训练的模式,使用收集好的数据进行训练， 知识库难以做到实时更新，而接入向量数据库后,就像给模型插了个高性能外接硬盘，支持学习互联网等最新信息，比重新训练模型微调等方式更加便宜高效。
在线推理时,大模型其实是没有记忆功能的,只能通过重新输入之前的问答,实现短期记忆,而且输入的内容也是有长度限制的。
腾讯云向量数据库（Tencent Cloud VectorDB）作为一种专门存储和检索向量数据的服务提供给用户，可以充当AI的海马体，让人工智能拥有记忆历史，问答能够当成新的训练语料，进入向量数据库永久储存，甚至当用户提出了重复相似的提问，向量数据库会直接给出缓存答案，这就让AI大模型,越用越聪明,越用越迅捷。
一、腾讯云向量数据库介绍 重磅组合，行业领先 LLM+向量数据库，打造专属RAG应用
智能化能力 腾讯云向量数据库可以和大语言模型 LLM 配合使用。企业的私域数据在经过文本分割、向量化后，可以存储在腾讯云向量数据库中，构建起企业专属的外部知识库，从而在后续的检索任务中，为大模型提供提示信息，辅助大模型生成更加准确的答案。
产品亮点 高性能持百万级 OPS 及毫秒级查询延迟低成本全流程平台托管，无需进行任何安装、部署、运维操作大规模单索引支持 10 亿级向量数据规模简单易用用户通过 API即可快速操作数据库，开发效率高高可用提供多副本高可用特性，提高容灾能力稳定可靠源自腾讯集团自研的向量检索引擎，近40个业务线上稳定运行 二、AI技术在智能客服中的作用 AI技术在智能客服平台中的关键作用 智能客服是一种基于AI技术的解决方案，通过向量数据库存储企业知识（如商品信息、游戏信息等），并利用LLM进行自然语言处理，从而准确、高效地回答客户问题，提高客户满意度、降低企业客服成本
融合AI技术与向量数据库的优势与挑战 挑战优势推理问题生成答案通过向量数据库为LLM提供外部知识库，提高大模型回答的准确性客服引导式话术LLM理解引导式话术，在用户问题不完整的情况下，通过与用户的互动，逐步引导用户提问，服务更加友好多轮对话LLM通过对多轮的深入语义分析和精准理解，实现了自然、流畅的对话，增强了与用户的亲近感 三、智能客服平台构建 物料准备 访问腾讯云向量数据库， 点击立即体验 新建向量数据库实例， 配置完成后点击立即申请 提交完成后等待创建即可
创建完成后记得开启外网访问地址， 并配置白名单， 我这里配置的是0.0.0.0/0 原始数据获取 Git地址： https://github.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/655c1445343379c5a393c2d82825d5d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2093a5681f92e831e48182342d3e0a62/" rel="bookmark">
			MacOS上配置Jenkins开机自启动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前文章有写过，如何在Windows环境下，通过vbs+bat脚本的组合拳实现Jenkins的开机自启动，最近换了电脑，又要搭建Jenkins了，顺带整理分享下MacOS上配置Jenkins开机自启动的方法。
具体配置步骤：
打开终端应用程序
进入 Jenkins 的安装目录。如： /Users/Shared/Jenkins
cd /Users/Shared/Jenkins 使用文本编辑器打开 jenkins.plist 文件
sudo nano jenkins.plist 在打开的文件中，写入以下内容：
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt; &lt;plist version="1.0"&gt; &lt;dict&gt; &lt;key&gt;Label&lt;/key&gt; &lt;string&gt;org.jenkins-ci&lt;/string&gt; &lt;key&gt;ProgramArguments&lt;/key&gt; &lt;array&gt; &lt;string&gt;/usr/bin/java&lt;/string&gt; &lt;string&gt;-jar&lt;/string&gt; &lt;string&gt;/Users/Shared/Jenkins/jenkins.war&lt;/string&gt; &lt;string&gt;--httpPort=8080&lt;/string&gt; &lt;/array&gt; &lt;key&gt;RunAtLoad&lt;/key&gt; &lt;true/&gt; &lt;/dict&gt; &lt;/plist&gt; 注意：确保 &lt;string&gt;/Users/Shared/Jenkins/jenkins.war&lt;/string&gt; 部分的路径正确指向你的 Jenkins 安装目录。
保存并关闭文件。
使用以下命令将 jenkins.plist 文件复制到 LaunchAgents 目录：
sudo cp jenkins.plist /Library/LaunchAgents/ 使用以下命令更改 jenkins.plist 文件的所有者和权限：
sudo chown root /Library/LaunchAgents/jenkins.plist sudo chmod 644 /Library/LaunchAgents/jenkins.plist 使用以下命令加载并启动 Jenkins：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2093a5681f92e831e48182342d3e0a62/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9aad27fc99732c70bab3b91e262fede4/" rel="bookmark">
			史上最全的Linux常用命令汇总（超全面！超详细！）收藏这一篇就够了！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在学习Linux时，会发现Linux的命令非常多而且还有很多参数，让人很是苦恼。就想着有没有一篇文章可以整理出来常用的命令，尽管网上有很多文章，但是总会有点问题（整理的文章非常详细但是没有目录——不能直接跳转到相关的位置）那么今天博主就带来了有目录的超级详细的Linux基础命令的汇总的文章！同时也会分享一些超级实用的快捷键。绝对是干货满满的一篇文章！
文章目录 Linux终端命令格式 终端命令格式查阅命令帮助信息 -help-man 常用Linux命令的基本实用 学习Linux终端命令的原因常用Linux命令的基本使用自动补全 其它命令 查找文件 演练目标 软链接 演练目标硬链接简介（知道）硬链接演练文件软硬链接示意图 打包压缩 打包 ／ 解包 压缩／解压缩 1）gzip2) bzip2(two) 软件安装 通过 apt 安装／卸载软件 文件和目录常用命令 查看目录内容 ls 命令说明Linux 下文件和目录的特点ls 常用选项ls通配符的使用 切换目录 cd相对路径和绝对路径 创建和删除操作 touchmkdirrm 拷贝和移动文件 treecpmv 查看文件内容 catmoregrep 其他 echo 文字内容重定向 &gt; 和 &gt;&gt;管道 | 系统信息相关命令 时间和日期磁盘信息进程信息 用户权限相关命令 组管理用户管理 创建用户／设置密码／删除用户查看用户信息 which（重要） 切换用户 修改文件权限 远程管理常用命令 关机/重启查看配置网卡信息 ifconfigping 远程登录和赋值文件 ssh 基础（重点）scp Linux终端命令格式 终端命令格式 command [-options] [parameter] 说明：
command ：命令名，相应功能的英文单词或单词的缩写[-options] ：选项，可用来对命令进行控制，也可以省略parameter ：传给命令的参数，可以是 零个、一个 或者 多个 查阅命令帮助信息 -help 说明：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9aad27fc99732c70bab3b91e262fede4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91ddb90b411dea9b9ee5f33558b3f661/" rel="bookmark">
			YOLOV5 C&#43;&#43;部署的人员检测项目【学习笔记（十一）】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、安装Pytorch 及 YOLO v51.1 安装GPU版 pytorch1.2 安装YOLO v5所需依赖 二、YOLO v5训练自定义数据2.1 标注数据2.1.1 安装labelImg2.1.2 标注 2.2 准备数据集2.2.1 组织目录结构2.2.2 创建 dataset.yaml 2.3 选择合适的预训练模型2.4 训练2.5 可视化2.5.1 wandb2.5.2 Tensorboard 2.6 测试评估模型2.6.1 测试2.6.2 评估 三、yolov5模型导出ONNX3.1 工作机制3.2 修改yolov5 代码，输出ONNX3.3 具体修改细节 四、TensorRT部署4.1 模型构建4.2 模型的推理4.3 INT8、FP16量化对比4.3.1 简介4.3.2 TensorRT中实现 4.4 预处理和后处理4.4.1 预处理（Preprocess）4.4.1.1 使用CPU做letterbox、归一化、BGR2RGB、NHWC to NCHW4.4.1.2 使用CPU做letterbox，GPU做归一化、BGR2RGB、NHWC to NCHW4.4.1.3 使用GPU预处理所有步骤 4.4.2 后处理（Postprocess） 4.5人员闯入、聚众的应用开发4.5.1 RTMP推流4.5.2 人员闯入应用开发4.5.3 人员聚众应用开发4.5.4 多线程流水线 4.6 jetson nano 和 jetson xavier NX部署4.6.1 jetson nx4.6.2 jetson nano 五、附录：5.1 CUDA quickstart5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91ddb90b411dea9b9ee5f33558b3f661/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/167cf2da7bed0de350fb9b1970a19a06/" rel="bookmark">
			undefined reference to symbol ‘pthread_create‘解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 运行make -j4 时出现如下错误
/usr/bin/ld: CMakeFiles/DC.dir/src/main.cpp.o: undefined reference to symbol 'pthread_create@@GLIBC_2.2.5' /usr/bin/ld: /lib/x86_64-linux-gnu/libpthread.so.0: error adding symbols: DSO missing from command line collect2: error: ld returned 1 exit status make[2]: *** [CMakeFiles/DC.dir/build.make:156: DC] Error 1 make[1]: *** [CMakeFiles/Makefile2:513: CMakeFiles/DC.dir/all] Error 2 从上面报错信息看到是在CMakeFiles/DC.dir/build.make的156行
打开build.make. 找到156行
$(CMAKE_COMMAND) -E cmake_link_script CMakeFiles/DC.dir/link.txt --verbose=$(VERBOSE) 看到一个链接文件link.txt
打开CMakeFiles/DC.dir/link.txt， 看到很多lib,
在这些lib的间隔中，插入-lpthread即解决。
或者在CMakeLists.txt的target_link中加入-lpthread
target_link_libraries( MyProject LIB1 LIB2 -lpthread) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dcd0830ccde2db821baa85bdadefe3d7/" rel="bookmark">
			2023强网拟态决赛reverse-keygen题解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 修改sdkversioninitarraystart函数check函数问题 这题java层没什么东西,关键逻辑都在libkeygen.so中 修改sdkversion 默认minsdk=30(android 11),由于测试机是安卓10,使用apktool解包修改manifast文件
注意extractNativeLibs要改为true,不然报错Failed to extract native libraries, res=-2
打包新的apk后重签名,再用ida动态调试分析so文件
initarray 查看initarray段发现初始化了很多字符串
start函数 前面几个函数做初始化,创建的线程进行输入flag和check
check函数 貌似是个循环获取输入的操作
下面有两段check函数
decode函数经分析是rc4,对字符串进行处理后作为key,再对输入数据进行aes加密
两段check函数中都是aes加密
sub_c8d10fc8函数跟进去可以看到aes的sbox
动调改pc寄存器,执行在sub_c8d10fc8前的一个decode后,得到aes的key
key1: 0x21, 0xCF, 0xCC, 0x68, 0xEA, 0xC5, 0x0A, 0x87, 0xFA, 0x60, 0xDB, 0x52, 0x99, 0xD4, 0xDC, 0x1B key2: 0xA9, 0x86, 0xC8, 0xC8, 0x5F, 0x57, 0xF8, 0x7E, 0x57, 0x30, 0x69, 0x27, 0xD1, 0x4C, 0x41, 0x5C 赛博厨子嗦一下
得到flag{834394be352d420b91e164fcb1346f74}
问题 值得一提的是程序跑起来可能有点问题,表现在decode得到的key不对
因为decode第一个参数(key)传递的并不是start函数起始地址,而是起始地址+1
这个问题困扰了挺久,调试几个小时结果都不对…
汇编层面看是+1偏移没问题,跑起来又是从起始地址开始,非常抽象
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c95612d91f23e943d9b606876af4cb5/" rel="bookmark">
			Docker搭建RocketMQ集群
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 服务器环境：centos7 安装用户：root，关闭防火墙，安装jdk8环境
使用docker-compose一键式搭建docker环境下的RocketMQ集群及其管理工具，实现rocketmq在docker环境容器外部访问。
一、安装docker yum -y install docker //安装docker
systemctl start docker //启动docker
systemctl status docker //查看状态
systemctl enable docker.service //开机自启
二、安装docker Compose 1、卸载旧版本Docker Compose sudo rm /usr/local/bin/docker-compose
2、下载Docker Compose最新版
sudo curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
3、授权Docker Compose二进制文件执行权限
sudo chmod +x /usr/local/bin/docker-compose
4、检查Docker Compose版本
docker-compose --version
三、安装dokcker管理面板portainer 汉化版本 docker pull portainer/portainer-ce
wget https://imnks.com/usr/uploads/2021/11/portainer-ce-2.9.2-public-cn-1101.zip
unzip portainer-ce-2.9.2-public-cn-1101.zip
docker run -d -p 9000:9000 --name portainer --restart always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data -v /root/public:/public portainer/portainer-ce
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c95612d91f23e943d9b606876af4cb5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7bb121665ad026c9fa127b95a3787f3/" rel="bookmark">
			JavaWeb学生信息管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JavaWeb实现学生信息管理系统 基于javaweb实现的学生信息管理系统。有兴趣的小伙伴一起来看看吧！
文章目录 JavaWeb实现学生信息管理系统一、项目简介二、项目环境三、项目结构四、项目展示五、快速开始1.数据表结构2.新建项目3.代码实现1.studentbean2.studentdaoimpl3.studentserviceimpl4.studentservlet 总结 一、项目简介 该项目完全基于JavaWeb实现，没有使用任何的后端框架，对新手朋友来说也是比较友好。此项目前端使用layui编写，界面非常的漂亮美观。分为学生端和管理端，原本之前要加上教师端，后因时间有限便没有在继续编写。功能也比较全面，基本功能都有。
二、项目环境 数据库：MySQL8.0版本版本：jdk1.8开发工具:idea2022所用技术
ajax+jq+layui+mysql+c3p0 三、项目结构 由于电脑屏幕有限就不依次展开了。
后端
前端
四、项目展示 登录
学生信息
成绩信息
密码修改
添加信息
主页
五、快速开始 1.数据表结构 student表
score表
user表
2.新建项目 新建项目以及项目配置我上几篇已经详细讲过，需要的大家自行去看。这里我就不在多说！
3.代码实现 由于代码太多就不全部展示出来！只做部分展示。
1.studentbean 代码如下（示例）：
public class StudentBean { private int sid; //ID private String sname; //姓名 private String ssex; //性别 private String sstudynum; //学号 private String sidcard; private String sschool; //学校 private String sclass; //班级 private String smajor; //专业 private String sphone; //电话 private String spassword; //密码 private String suser; //用户名 private String sdate; //日期 public void setSuser(String suser) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7bb121665ad026c9fa127b95a3787f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82b951d54925aad6958caa088e9c351c/" rel="bookmark">
			Java基础课的中下基础课03
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
十七、 多态
17.1 多态
十八、策略模式 + 内部类
18.1 模拟一个Bank银行
18.2 策略模式Strategy
18.3 内部类
十九、枚举 + Runtime
19.1 枚举类enum
19.2 Runtime 类 管理堆内存
二十、工具类之包装类相关
20.1 包装类
20.2 与数学相关的类
（1）Math
（2）Random类
（3）UUID类
（4）BigInteger 大整数
（5）BigDecima类
（6）DecimalFormat类
（7）Scanner类
二十一、工具类之日期相关
21.1 日期相关的类
（1）System类
（2）Data类
（3）DateFormat类
（4）SimpleDateFormat类
（5）Calendar类
（6）TimeZone类
二十二、工具类String
22.1 String类
（1）String类中常用的方法
22.2 StringBuilder
（1）StringBuilder中常用的方法
22.3 为什么会出现StringBuilder
22.4 String家族笔试常考的知识点
22.5 正则表达式regex
22.6小任务（以下任务要求设计成方法）
（1）设计将字符串反转
（2）设计将给定字符串的正序和反序进行连接
（3）设计判断给定字符串是否是回文
（4）设计将给点给的字符串右位移x位置
（5）设计寻找若干字符串中最长的那个
（6）设计同级给定字母在字符串中出现的次数
（7）设计将给定的字符串每一个首字母大写
（8）设计获取给定字符串中的全部数字
十七、 多态 17.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/82b951d54925aad6958caa088e9c351c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d1032c3bfbe6490c0e057cd86f66628/" rel="bookmark">
			Java基础课的中下基础课04
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
二十三、集合相关
23.1 集合
（1）集合的分支
23.2 List有序可重复集合
（1）ArrayList类
（2）泛型
（3）ArrayList常用方法
（4）Vector类
（5）Stack类（栈）
（6）Queue/ kjuː /类
（7）LinkedList类
23.3 Set无序无重复集合
（1）HashSet类
（2）Set集合常用方法
（3）HashSet无重复的原则
（4）TreeSet类
（5）TreeSet无重复规则是如何实现的？
（6）Set集合总结
23.4 Map集合
（1）Map介绍
（2）HashMap
（3）如何选用集合和数组？
（4）登录小流程来体验如何选用集合
（5）TreeMap
（6）设计学生做选择题（考试机）
二十四、错误与异常
24.1 异常
（1）异常的分支体系：
①、运行时异常（非检查异常）
②、编译时异常（检查异常）
（2）添加处理异常的手段：
①、try{ }catch(){ }[finally{ }]
②、throws抛出
（3）自定义异常
二十三、集合相关 23.1 集合 1、变量----容器：存储一个元素
2、数组----容器：一组具有某种特性的数据存在在一起，存储一组元素（数据类型一致），长度固定
3、我们自己封装了一个Box（ArrayBox、LinkedBox）----容器：存储一组元素，长度可变
4、集合--容器：集合是指具有某种特定性质的具体或抽象的对象汇总而成的集体与数组类似，集合的长度存储之后还能改变，集合用来存储一组元素，可以理解为集合是我们封装的Box，只不过比我们写的更加优秀，更多的方法
5、集合的分支：Collection、Map、List、Set都是接口，需要通过子类来完成操作（所有的集合都在Java.util）
（1）集合的分支 1、Collection：存储的都是value（value有可能是基本类型或引用类型）
2、Map：存储的是以Key-value（键值对）的形式存在的，（Key无序无重复，Value无序可重复）
3、List：有序可重复
4、Set：无序无重复
（1）序：顺序，添加进去的元素 和 取得元素的顺序一致（指的不是集合自己的顺序）
（2）重复：两个对象元素一致
23.2 List有序可重复集合 1、List集合的子类：（1）ArrayList（2）LinkedList（3）Vector
2、ArrayList 和 Vector区别：
（1）相同：底层都是数组
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d1032c3bfbe6490c0e057cd86f66628/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/919b793072e30b90b3aac4756e8a341b/" rel="bookmark">
			资源帖-Latex项目列表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 学习网址
列表类型：
LaTeX 中的列表是封闭的环境，列表中的每个项目可以取一行文字到一个完整的段落。在 LaTeX 中有三种列表类型：
itemize：无序列表unordered list/项目符号列表bullet list
enumerate：有序列表ordered list
description：描述列表
无序列表
\begin{itemize} \item Fedora \item Fedora Spin \item Fedora Silverblue \end{itemize} 有序列表
\begin{enumerate} \item Fedora CoreOS \item Fedora Silverblue \item Fedora Spin \end{enumerate} 描述列表
\begin{description} \item[Fedora 6] Code name Zod \item[Fedora 8] Code name Werewolf \end{description} 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/690cd6593201d14202cf9bd07d4abb0b/" rel="bookmark">
			Java基础课的中下基础课05
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
二十五、IO之File类及常用方法
25.1 什么是I/O
25.2 什么是文件
（1）为什么用文件存储
25.3 File类
25.4 什么叫流，做什么？
二十六、IO之文件夹遍历删除（递归）
26.1递归的理解
26.2 文件夹遍历删除
二十七、字节型文件流
27.1 流
27.2 字节型文件流（1字节）
（1）字节型文件输入流FileInputStream
（2）字节型文件输出流FileOutputStream
（3）小总
27.3 小任务文件夹复制
（1）文件的复制
（2）文件夹的复制
二十八、字符型文件流
27.2 字符型文件流
（1）FileReader输入流
（2）FileWriter输出流
（3）字符集
二十九、缓冲流
29.1 缓存流
29.2 字节型缓存流
（1）BufferedInputStream
（2）BufferedOutputStream
29.3 字符型缓冲流
（1）BufferedReader
（3）用BufferedReader和BufferedWriter做登录
三十、小总文件流
三十一、数组流（了解）
三十二、对象流
32.1 对象的序列化和反序列化
（1）ObjectInputStream / ObjectOutputStream
三十三、银行系统（网上银行）练习
33.1 业务说明
33.2 登录模块
（1）基本登录思想
（2）整体优化后：
33.2 查询余额模块
33.3 存款模块
33.4 整体代码
33.4 如何分类
二十五、IO之File类及常用方法 25.1 什么是I/O I/O相关（输入/输出）流（数据流动）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/690cd6593201d14202cf9bd07d4abb0b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9bbc4dcc2dff1b610e2fe7b9fd741b85/" rel="bookmark">
			WJLHA3编码原理和唯一性证明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		WJLHA3编码原理 首先将二进制序列 X X X定义为 ( X 1 , X 2 , … , X n ) \left( X_{1},X_{2},\ldots,X_{n} \right) (X1​,X2​,…,Xn​)，其中 X i ∈ { 0 , 1 } , ( i = 1 , 2 , … , n ) X_{i} \in \left\{ 0,1 \right\},(i = 1,2,\ldots,n) Xi​∈{0,1},(i=1,2,…,n)， p ( 0 ) p(0) p(0)和 p ( 1 ) p(1) p(1)分别为序列 X X X中符号0和符号1的概率。初始化 i = 1 i = 1 i=1，UINT型（32比特）变量 R 0 = H 0 = 1 R_{0} = H_{0} = 1 R0​=H0​=1， L 0 = 0 L_{0} = 0 L0​=0，于是 i = 1 , 2 , … , n i = 1,2,\ldots,n i=1,2,…,n时迭代运算式为：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9bbc4dcc2dff1b610e2fe7b9fd741b85/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d19cce99e2b792dbc150578299d47351/" rel="bookmark">
			csdn 满屏广告
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		穷疯了吗
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1cc9ab4f14f4aa3b2f350b00a0fa4a9/" rel="bookmark">
			VIM文本编辑器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 本节所讲：
了解VI编辑器的简介掌握VIM编辑器的基本使用实战：使用VIM编辑器配置IP 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5bfc7ed335d1b60fec20f3657f2a7d49/" rel="bookmark">
			Acrobat Pro中不能使用有道词典取词翻译
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 编辑–&gt;首选项–&gt;安全性（增强–&gt;启动时启用保护模式（预览），取消前面的勾即可 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19516d30d1891b974538757e846fe5c9/" rel="bookmark">
			Redis Helper封装：静态方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Redis面试题： 1、什么是事务？2、Redis中有事务吗？3、Redis中的事务可以回滚吗？
答：
1、事务是指一个完整的动作，要么全部执行，要么什么也没有做
2、Redis中有事务，Redis 事务不是严格意义上的事务，只是用于帮助用户在一个步骤中执行多个命令。单个 Redis 命令的执行是原子性的，但 Redis 没有在事务上增加任何维持原子性的机制，所以 Redis 事务的执行并不是原子性的
3、Redis 事务可以理解为一个打包的批量执行脚本，但批量指令并非原子化的操作，中间某条指令的失败不会导致前面已做指令回滚，也不会造成后续的指令不做
事务一般都是为原子性而生，既然Redis事务没有原子性，那他存在的意义是什么
答：redis事务的主要作用就是串联多个命令防止 别的命令插队。
RedisHelper封装 1、添加StackExchange.Redis引用
Install-Package StackExchange.Redis -Version 2.0.601 2、封装
using Microsoft.AspNetCore.DataProtection.KeyManagement; using StackExchange.Redis; namespace Web.Common { /// &lt;summary&gt; /// Redis 助手 /// &lt;/summary&gt; public static class RedisHelper { #region 获取Multiplexer实例：单例模式 public static IConnectionMultiplexer ConnMultiplexerInstance { get { return _ConnectionMultiplexer;// 总是返回同一个实例 } } #endregion 其它 #region private field /// &lt;summary&gt; /// 连接字符串 /// &lt;/summary&gt; private static readonly string ConnectionString; /// &lt;summary&gt; /// redis 连接对象：单例 /// &lt;/summary&gt; private static IConnectionMultiplexer _ConnectionMultiplexer; /// &lt;summary&gt; /// 默认的 Key 值（用来当作 RedisKey 的前缀） /// &lt;/summary&gt; private static readonly string DefaultPrefix; /// &lt;summary&gt; /// 默认的超时时间（单位毫秒） /// &lt;/summary&gt; private static readonly TimeSpan?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/19516d30d1891b974538757e846fe5c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6392958d66cb4aef0321b7079db8c30d/" rel="bookmark">
			腾讯物联网平台之规则引擎
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.腾讯物联网平台简介 腾讯云物联网开发平台（IoT Explorer）为客户提供便捷的物联网开发工具与服务，助力客户更高效的完成设备接入，并为客户提供物联网应用开发及场景服务能力，帮助客户高效、低成本构建物联网应用。
该平台支持设备连接、设备管理、数据分析和应用开发等功能的实现，并具有丰富的API和SDK，方便开发者快速开发应用。同时，该平台还提供安全可靠的连接和数据传输服务，保障设备与应用之间的通信安全。
腾讯云物联网开发平台还提供了丰富的行业解决方案和最佳实践案例，帮助客户快速实现物联网应用。同时，该平台还支持多种不同的设备和应用场景，可以满足不同客户的需求。
腾讯物联网平台创建 关于物联平台可参考博客：腾讯物联网平台连接案例
2.腾讯物联网平台多个设备相互订阅 在正常产品开发中，有时我们需要多个硬件设备之间相互控制，而且没个设备均为独立个体连接物联网平台，如下图所示：
在本案例中，有4个设备，其中有3个WIFI的子设备，作为独立模块连接腾讯物联网平台，实现功能分别为烟雾采集、温湿度采集和继电器控制；A9开发板为主控制器，实现实时显示各项数据和远程控制。即实现4个设备之间组网，并且需要实现跨设备相互订阅。也就是A9开发板需要通过物联网平台订阅三个子设备的数据，而继电器设备需要定义A9开发板数据来实现远程开关功能。
在默认的物联网平台应用中，默认设备之间是无法实现数据的相互订阅，要想实现上述案例，则可以使用规则引擎，来达到消息转发目的。
2.1规则引擎简介 基于 Topic 进行通信时，您可以使用规则引擎对 Topic 中的数据进行处理，然后转发到腾讯云其它服务或用户的业务后台服务。您无需购买服务器部署分布式架构，只需通过规则引擎在控制台上进行配置即可实现采集 + 计算 + 存储等全栈服务。以下是支持转发的类型：
数据转发到另一个 Topic。
数据转发到第三方服务。
数据转发到消息队列 CKafka。
数据转发到时序数据库 CTSDB。
数据转发到云数据库 MySQL。
数据转发到云数据库 MongoDB。
规则引擎文档链接
参考文档：腾讯物联网平台规则引擎
3.应用案例 要实现多设备相互订阅，则需要通过规则引擎实现，而使用规则引擎，则需要先创建一个物联网平台应用案例，创建过程这里不再介绍，本次案例为创建4个设备，设备之间数据相互订阅。物联网项目创建如下。
3.1创建项目 3.2添加产品 3.3添加物模型 3.4创建设备 创建4个设备，分别为继电器，主控器A9，DHT11温湿度采集，MQ2烟雾采集。其中继电器、温湿度、MQ2数据需要再主控制器A9实现显示和实现控制。
3.5创建规则引擎 要达到相互订阅功能，就需要实现规则引擎。
3.5设置数据筛选规则 规则引擎提供多种函数，您可以在规则引擎的字段，条件以及数据库字段对应的值中使用这些函数，实现数据的多样化处理。
规则引擎参考说明文档：规则引擎函数说明文档
本次我以主控板A9订阅MQ2烟雾数据和下发继电器控制命令为例，介绍数据筛选规则写法。
首先，需要确定MQ2数据上报格式和继电器命令下发格式，数据格式如下：
//MQ2烟雾数据 "{\"method\":\"report\",\"clientToken\":\"123\",\"params\":{\"MQ2\":666}}" //继电器命令数据 "{\"method\":\"report\",\"clientToken\":\"000001\",\"params\":{\"JDQ\":1}}" 需要将上述数据进行转发订阅，则设置字段信息如下：
字段内容填写可以用来筛选需要转发的内容，此次我们需要转发的内容为MQ2和JDQ。若不需要筛选数据，转发所有内容，则直接填 * 即可。
params.MQ2,params.JDQ 3.6添加行为操作 3.7启动规则引擎 至此，相互订阅功能云端配置完成，进一步完成硬件配置即可实现多个独立设备之间数据相互订阅。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/391aac76719df34152de970936f6a884/" rel="bookmark">
			python调用ping命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 [root@rhel8 day06]# vim test01.py import subprocess def ping(ip): """ ip为要ping的ip """ data = subprocess.run(f"ping -c 2 {ip} &amp;&gt;/dev/null",shell=True) if data.returncode == 0: print(f"{ip}:up") else: print(f"{ip}:down") ping('192.168.88.4') [root@rhel8 day06]# python3 test01.py 192.168.88.4:up #ping通 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b3cf569113eb91e3067b2fa2bc1946b/" rel="bookmark">
			Golang 使用 Template 引擎构建漂亮的邮件内容并且完成邮件发送
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 邮件是常见的触达用户的途径，本文详细介绍基于 golang 的模版引擎构建漂亮的邮件内容，并且发送给模板用户。
思路 go 内置了 html/template 模块，类似 ejs 模块引擎。利用 template 能力可以将变量动态的注入到HTML字符串中，最终获得成功注入变量的字符串内容。
具体实现思路：
首先根据设计图输出静态的HTML文件；然后将HTML中需要变化的内容提取变量占位符；利用 template 工具将 HTML 中的变量按照规则注入；最终通过运行 template 引擎，获得最终的动态HMTL内容； 邮件内容模版 1. 输出静态HTML文件 根据 figma 设计图编写对应的 HTML 代码；根据产品要求，内容需要动态变化的地方提取变量，方便后续的动态内容注入。
&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD XHTML 1.0 Transitional //EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt; &lt;html xmlns="http://www.w3.org/1999/xhtml" xmlns:v="urn:schemas-microsoft-com:vml" xmlns:o="urn:schemas-microsoft-com:office:office"&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta name="x-apple-disable-message-reformatting"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;title&gt;乐闻世界 - 列表&lt;/title&gt; &lt;/head&gt; &lt;body style="margin: 0;padding: 0;line-height: inherit;margin: 0;padding: 0;-webkit-text-size-adjust: 100%;background-color: #f6f6f6;color: #333333"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b3cf569113eb91e3067b2fa2bc1946b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0b9c64d178216a1f3baa959f617ee7a/" rel="bookmark">
			设计-mysql的Timestamp和Datetime的字节占用之争
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【缘起】 众所周知，在进行数据库设计的时候，关于存储到秒级的时间类型字段，常用的有Timestamp和Datetime这2种。而这2种类型的字段，在存储格式以及存储空间上，又有着很大的不同，列举如下：
那么，在实际的数据库设计中，在Timestamp和Datetime这2种秒级别的时间列类型中，如何进行选择呢？让我们看下面示例。
【行为差别】 为了方便对Timestamp和Datetime这2种列类型的数据存储行为进行研究，我们创建如下t_timestamp_demo测试表。
其中，my_date为DATETIME日期类型的列字段；create_time在新增数据时，自动将当前系统时区的时间戳，赋值给该列字段；update_time列字段，会在新增数据和当前行数据发生修改时，自动更新为当前系统时区的时间(戳)。
下面，我们插入一条数据：
如上图，通过只向my_data字段插入指定时间字符串'2099-12-24 18:18:18'后，该行数据的create_time和update_time字段，会自动插入为当前系统的时间(戳)（见上图右下角时间）。
接下来，我们在修改一下该条数据，如下：
如上图，经过对my_date字段进行修改后（修改其它字段也可），update_time字段就会自动更新为当前系统的最新时间(戳)，这是因为在update_time字段定义的时候，给了ON UPDATE CURRENT_TIMESTAMP的列特性。
【存储限制】 接下来我们看下，Timestamp类型的字段，所能够存储的时间范围的上限和下限分别是什么，如下：
如上图，我们修改了update_time的时间为'2038-01-19 11:14:07'，这是阿K在本地环境中能够向Timestamp类型的列字段，插入的最大的值。
接下来，我们再多加1秒，即将update_time列字段的时间，修改为'2038-01-19 11:14:08'，如下：
如上图，我们看到Mysql会报错，说'2038-01-19 11:14:08'这个时间值，在update_time列字段的存储是不正确的，也就是说'2038-01-19 11:14:07'，是Timestamp类型的字段所能存储的最大值了，那么为什么会是'2038-01-19 11:14:07'呢？
让我们先看一下Mysql中，整数类型的存储和范围，如下：
其中，Int类型占用4个字节的空间，其有符号的存储范围为：-2147483648 ~ 2147483647。那么我们知道Timestamp类型的字段，也是占用4个字节的存储空间，那么，我们将'2038-01-19 11:14:07'换算成时间戳，如下：
如上图，将'2038-01-19 11:14:07'换算成时间戳后，就是2147483647。这正好是Mysql中Int类型字段所能存储的最大值了，多1秒就会超出Int类型的存储空间大小，溢出报错。
那么Timestamp类型的字段，所能存储的时间最小值，又是多少呢？让我们继续往下看：
如上图，我们将update_time字段修改为'1970-01-01 08:00:01'，这是阿K在本地环境所能存储的Timestamp列类型字段的最小值了。
再减1秒，就会报错，如下：
如上图，我们看到'1970-01-01 08:00:00'这个时间值，在Mysql的Timestamp类型的列字段update_time中，存储是会报错的。也就是说，Timestamp类型的列字段，所能存储的最小时间是'1970-01-01 08:00:01'，换算成时间戳，如下：
如上图，由此可见，Timestamp类型的列字段，能存储的时间戳范围，就是有符号Int类型字段的1 ~ 2147483647，因为Timestamp列类型字段，只能存储0以上的时间戳数值。如果是unsigned无符号整数，则可以存储的时间戳值为4294967295，也就是能存储到2106年，如下：
如上图，这可比有符号的Int类型整数，所表示的最大时间戳2147483647(即2038年)，能多存68年呢。可惜目前Timestamp类型的列字段，只能存储到2147483647（2038年1月19日 11点14分07秒）。
【深究】 上面我们分析了Timestamp和Datetime在数据库表中的存储行为和大小限制。那么，Timestamp和Datetime究竟是如何存储在数据库表里面的呢？下面通过一个示例，来看看Timestamp和Datetime类型的字段，在磁盘上面的表空间中，是如何存储的吧。
如上图，我们创建了2个表，t_one_datetime用来存储Datetime类型的数据，字段名为my_datetime。t_one_timestamp用来存储Timestamp类型的字段，字段名为my_timestamp。
接下来，我们在这2个表中，分别插入1条数据，如下：
接下来，我们找到磁盘上表t_one_datetime和表t_one_timestamp的表空间文件(后缀名是.ibd)，打开进行对比，如下：
t_one_datetime表空间_元数据
t_one_timestamp表空间_元数据
从上图的元数据文件中，我们看到t_one_datetime表中，存储的是：a7 af 32 c8 ee，这5个字节的数据。而t_one_timestamp表中，存储的是：5f 90 fb 4f，这4个字节的数据。
那么这些数据到底代表着什么意思呢？让我们先将t_one_timestamp里面存储的数据，即：5f 90 fb 4f，转换为十进制数字，如下：
得到十进制数字为:1603337039，将其进行时间戳计算，如下：
这正好就是我们t_one_timestamp表中，my_timestamp字段存储的时间'2020-10-22 11:23:59'。由此可见，Timestamp类型的列字段，确实是以4字节的时间戳整数的方式存储在表空间里的。
那么t_one_datetime中，数据：a7 af 32 c8 ee，这5个字节存储的是什么东西呢？让我们先看下Mysql官网上对Datetime类型的解释，如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b0b9c64d178216a1f3baa959f617ee7a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3474a7aa81e4ad48d23a83a81c97249/" rel="bookmark">
			PostGIS学习教程十三：几何图形创建函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PostGIS学习教程十三：几何图形创建函数 目前我们看到的所有函数都可以处理已有的几何图形并返回结果：
分析几何图形（ST_Length(geometry), ST_Area(geometry))
几何图形的序列化（ST_AsText(geometry), ST_AsGML(geometry))
选取几何图形的某个部分（ST_RingN(geometry, n))
true/false测试（ST_Contains(geometry, geometry), ST_Intersects(geometry, geometry))
"几何图形创建函数"以几何图形作为输入并输出新的图形。
文章目录 PostGIS学习教程十三：几何图形创建函数一、ST_Centroid / ST_PointOnSurface二、ST_Buffer三、ST_Intersection四、ST_Union五、本文涉及到的函数列表 一、ST_Centroid / ST_PointOnSurface 组成空间查询时的一个常见需求是将多边形要素替换为要素的点表示。这对于空间连接（spatial join）非常有用，因为在两个多边形图层上使用St_Intersects(geometry, geometry)通常会导致重复计算：位于两个多边形的边界上的多边形将与两侧的多边形都相交，将其替换为点将强制它位于一侧或另一侧，而不是与两侧的多边形都相交。
ST_Centroid(geometry) —— 返回大约位于输入几何图形的质心上的点。这种简单的计算速度非常快，但有时并不可取，因为返回点不一定在要素本身上。如果输入的几何图形具有凹性（形如字母’C’的几何图形），则返回的质心可能不在图形的内部。
ST_PointOnSurface(geometry) —— 返回保证在输入多边形内的点。从计算上讲，它比centroid操作代价要大得多。
SELECT ST_Intersects(geom, ST_Centroid(geom)) AS centroid_inside, ST_Intersects(geom, ST_PointOnSurface(geom)) AS pos_inside FROM (VALUES ('POLYGON ((30 0, 30 10, 10 10, 10 40, 30 40, 30 50, 0 50, 0 0, 0 0, 30 0))'::geometry) ) AS t(geom); 二、ST_Buffer 缓冲区操作在GIS工作流中很常见，在PostGIS中也可以进行缓冲区操作。 ST_Buffer(geometry, distance)接受几何图形和缓冲区距离作为参数，并输出一个多边形，这个多边形的边界与输入的几何图形之间的距离与输入的缓冲区距离相等。
例如，如果美国公园管理局（US Park Service）想要在自由岛（Liberty Island）周围建立一个海洋交通区，他们可能会在该岛周围建造一个500米的缓冲多边形。自由岛是nyc_census_blocks表中的一个单独的人口普查块，因此我们可以轻松地提取和建立对应的缓冲区。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e3474a7aa81e4ad48d23a83a81c97249/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6805303ca22b4d654f1d7dfa900063f/" rel="bookmark">
			基于C语言扫雷游戏的实现（用到递归函数，循环语句，二维数组）（附带代码功能讲解）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		扫雷游戏 我用到了递归函数 循环语句 二维数组 自定义函数为核心
1.首先是游戏的进入菜单界面
代码部分（不做讲解）
void menu()//菜单部分
{
printf("*****************\n");
printf("******1.play*****\n");
printf("******0.exit*****\n");
printf("*****************\n");
}
和游戏进入主函数口
int main()
{
int play ;
do
{
menu();
scanf("%d", &amp;play);
if (play == 1)
{
printf("游戏开始\n");
game();//引用外部函数 用的头文字是自己定义的
}
else if(play != 1&amp;&amp; play !=0)
{
printf("输入错误请重新输入\n");
}
} while (play);
printf("游戏结束\n");
return 0;
}
然后是基础参数的设置
2.然后是最基础的游戏内的代码设置 （我全部批注在代码中）
void game()
{
srand((unsigned int)time(NULL));//设置随机数的基础值
int x; int y; int z;
char arr[X][Y] = { 0 };//这个是开棋盘
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f6805303ca22b4d654f1d7dfa900063f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59ae9aa838aef36239343a9d614f503a/" rel="bookmark">
			【S32DS RTD实战】-1.3-S32K3工程生成S19，BIN，Hex文件，以及Post-build steps的妙用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1 方法一：逐个生成Motorola S-record（s19，srec…），Intel HEX，Bin文件
1.1 生成Motorola S-record（s19，srec…）文件
1.2 生成Intel HEX文件
1.3 生成Bin文件
2 方法二：批量生成Motorola S-record（s19，srec…），Intel HEX，Bin文件
2.1 Post-build steps其它妙用
结尾
【S32K3_MCAL从入门到精通】合集：
S32K3_MCAL从入门到精通https://blog.csdn.net/qfmzhu/category_12519033.html
在S32DS（S32 Design Studio for S32 Platform 3.5）中，编译S32K3工程，S32DS会在Debug_FLASH文件夹下生成elf，map文件。但却发现没有生成Motorola S-record（s19，srec…），Intel HEX，Bin文件，如何生成这些文件呢？
1 方法一：逐个生成Motorola S-record（s19，srec…），Intel HEX，Bin文件 选中Project工程，鼠标右键，在其上下文中，选择“Properties”，见图1-1；
图1-1
在弹出的Properties for S32K312_LED_Example对话框中，依次选择C/C++ Build -- &gt; Settings -- &gt; Tool Settings -- &gt; Cross Settings，勾选Create flash image后，单击Apply and Close。
图1-2
再次选中Project工程，鼠标右键，在其上下文中，选择“Properties”，在弹出的Properties for S32K312_LED_Example对话框中，依次选择C/C++ Build -- &gt; Settings -- &gt; Tool Settings -- &gt; Standard S32DS Create Flash lmage -- &gt; General，在Output file format (-O)中选择要生成的刷写文件格式（Motorola S-record（s19，srec…），Intel HEX，Bin），单击Apply and Close后Build编译工程。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/59ae9aa838aef36239343a9d614f503a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c74e251f6c5d4f14035c464385b9fa4/" rel="bookmark">
			2.6 A 的 LU 分解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、A = LU 线性代数很多关键的概念实际上就是矩阵的分解（factorization）。原始矩阵 A A A 变成两个或三个特殊矩阵的乘积。第一个分解，实际上也是最重要的分解，来自消元法。因子 L L L 和 U U U 都是三角形矩阵，分解 A = L U A=LU A=LU 来自消元法。
矩阵 U U U 是上三角矩阵，它的主元都在对角线上，消元步骤将 A A A 变为 U U U。现在我们要反向这些步骤（将 U U U 变为 A A A ），通过一个下三角矩阵 L L L 就可以。 L L L 的元素正好就是乘数 l i j l_{ij} lij​ —— 从行 i i i 减去乘数乘主元行 j j j。
以 2 × 2 2×2 2×2 的矩阵为例，矩阵 A A A 有四个元素 2 , 1 , 6 , 8 2,1,6,8 2,1,6,8，要消去的元素是 6 6 6。从行 2 2 2 减去 3 3 3 乘行 1 1 1，这个正向步骤使用消元矩阵 E 21 E_{21} E21​，乘数 l 21 = 3 l_{21}=3 l21​=3。从 U U U 到 A A A 的反向步骤使用 L = E 21 − 1 L=E^{-1}_{21} L=E21−1​（行 2 2 2 加上 3 3 3 乘行 1 1 1）。 正向从 A 到 U ： E 21 A = [ 1 0 − 3 1 ] [ 2 1 6 8 ] = [ 2 1 0 5 ] = U 反向从 U 到 A ： E 21 − 1 U = [ 1 0 3 1 ] [ 2 1 0 5 ] = [ 2 1 6 8 ] = A 正向从\,A\,到\,U：\kern 5ptE_{21}A=\begin{bmatrix}1&amp;0\\-3 &amp;1\end{bmatrix}\begin{bmatrix}2&amp;1\\6&amp;8\end{bmatrix}=\begin{bmatrix}2&amp;1\\0&amp;5\end{bmatrix}=U\\[1ex]反向从\,U\,到\,A：\kern 5ptE_{21}^{-1}U=\begin{bmatrix}1&amp;0\\3&amp;1\end{bmatrix}\begin{bmatrix}2&amp;1\\0&amp;5\end{bmatrix}=\begin{bmatrix}2&amp;1\\6&amp;8\end{bmatrix}=A 正向从A到U：E21​A=[1−3​01​][26​18​]=[20​15​]=U反向从U到A：E21−1​U=[13​01​][20​15​]=[26​18​]=A上面第二行就是分解 L U = A LU=A LU=A，将 E 21 − 1 E_{21}^{-1} E21−1​ 用 L L L 代替。更大的矩阵会有很多 E ′ s E's E′s， L \pmb L L 包含它们所有的逆矩阵。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c74e251f6c5d4f14035c464385b9fa4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e382c94a4c8aec05d59f103a18d13be7/" rel="bookmark">
			pandas 进阶汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前发的pandas零零散散有些乱，汇总一下
数据预览和预处理 在拿到数据第一步当然是对数据做一个大概的浏览，以及对缺失值重复值进行相关处理。
读取数据---- df = pd.read_excel('xxxx')
1.查看数据维度 ------df.shape
2.随机查看5条数据------df.sample(5)
3.查看数据前后5行----- 前5行：df.head() 后5行：df.tail()
4.查看数据信息，看数据类型，有无缺失值-----df.info()
5.查看 **数值型** 列的统计信息，计数、均值什么的----df.describe()
6.计算总的缺失值-----df.isna().sum().sum() 第一个sum()是对各列缺失值，第二个是总计
7.计算各列缺失值-----df.isnull().sum() isnull和isna是一样的
8.查看缺失值所在行----df [df.isnull.values==True]
9.将缺失值出现的行全部删掉 ---df.dropna()
10.补充缺失值----df.fillna()
11.将全部重复值所在的行筛选出来---df [ df.duplicated() ]
12.删除全部的重复值---- df.drop_duplicates() 删除全部的重复值，但保留最后一次出现的值 df.drop_duplicates(keep='last')
统计性描述与统计学分析 查看数据
1.修改索引，将学校列作为索引（set_index）
df.set_index("学校名称",inplace= True) 2.数据排序，按总分升序排序并展示前20名（sort_values）
df.sort_values(by='总分', ascending=True).head(20) 3.介绍一个nlargest()函数，用于返回DataFrame中最大的n个值所在的行。
三个参数
这里我们将数据按照 高端人才得分 降序排序，展示前 10 位
df.nlargest(10, '高端人才得分') 4.统计均值----- df.mean()
5.统计中位数-----df.median()
6.统计众数-----df.mode()
7.统计多种指标用聚合函数agg()
计算 总分、高端人才得分、办学层次得分的最大最小值、中位数、均值
数据筛选和修改 加载数据
1.将原来df列名 unnamed:2，unnamed:3,unnamed:4修改为 金牌数、银牌数、铜牌数
rename()函数
df.rename(columns={'Unnamed: 2':'金牌数', 'Unnamed: 3':'银牌数', 'Unnamed: 4':'铜牌数'},inplace=True) 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e382c94a4c8aec05d59f103a18d13be7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1373a9bfe639bfd2b30067c21a2cbf8b/" rel="bookmark">
			【MQ】Rocketmq如何保证消息不丢失
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、前言二、消息什么情况会丢失？三、如何保障消息不丢失？3.1、生产者端3.2、Broker端3.3、消费者端 四、总结 前言 一、前言 RocketMQ可以理解成一个特殊的存储系统，这个存储系统特殊之处数据是一般只会被使用一次，这种情况下，如何保证这个被消费一次的消息不丢失是非常重要的。本文将分析RocketMQ从哪些方面来保证消息的不丢失。
二、消息什么情况会丢失？ 由于消息从生产者，到broker,最后被消费者消费，中间最少经历了3个应用，2次rpc调用，由于rpc调用会存在成功失败外的第三种情况，因此消息会存在不可靠性。
那么，我们有哪些手段来提升消息的可靠性呢？本文将分别从生产者端，消费者端，broker端来分析保证消息不丢失的手段。
三、如何保障消息不丢失？ 3.1、生产者端 生产者发送消息，有同步发送和异步发送到Broker。
我们如果对消息可靠性要求比较高，我们可以选择同步发送。在RocketMQ的客户端，同步发送自带重试机制，如果同步模式发送失败，则轮转到下一个Broker。
在这里插入图片描述
如果重试都发送失败了怎么办呢？
这时候我们要考虑发送失败的兜底方案-业务系统自己实现，业务系统可以将消息存储起来，使用定时任务等机制来重发消息。
3.2、Broker端 作为Broker，他的主要职责就是将消息持久化存储起来，同时最少把消息投递到消费者端一次。
由于消息是存在磁盘上的，因此持久化机制就会涉及到刷盘机制。RocketMQ支持同步刷盘和异步刷盘机制。
RocketMQ处理发送消息请求时默认写入缓冲区，不会立即同步落盘，通过定时5s进行刷新落盘
SYNC_FLUSH，同步刷盘，刷盘完成再返回给客户端，超时5s
ASYNC_FLUSH，异步刷盘，200ms刷新一次，性能高
上面的机制可以保证存储可靠性，Broker除了保证存储消息可靠外，broker还需要保证消息能够投递给消费者消费一次。Broker如何保证消息一定会投递给消费者呢？
Broker端设计了重试机制。如果消息消费失败了，会将消息写到重试topic下的队列，会最大重试16次发送到消费者端。
如果16次之后，消息还是没有消费成功，Broker端会将消息写入死信队列。
3.3、消费者端 消息投递到了消费者端，消费者如果消费不成功，不能给broker端返回ack。一般需要设置为手动提交ack机制，消费者消费消息不成功，不返回CONSUME_SUCCESS，返回RECONSUME_LATER表示需要broker再次投递该消息。
这里需要注意的是，由于broker保证消息不丢失有重试机制，可能导致消息重复投递，因此消费者端需要做幂等性处理，一般会根据业务规则处理。
四、总结 消息系统将不同的系统进行解耦，在提高了系统的高吞吐量和异步性能的同时，也对系统稳定性带来了挑战，消息保证可靠性不丢失就是非常关键的一个稳定性挑战，本文分别从生产者，Broker，消费者端三端来考虑对应方案来处理消息不丢失的手段。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ffaaad72c6921deb2ac3900e6ed043d6/" rel="bookmark">
			JVM内存模型深度剖析与深度优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、JVM整体结构及内存模型 二、JVM内存参数设置 Spring Boot程序的JVM参数设置格式(Tomcat启动直接加在bin目录下catalina.sh文件里)： 关于元空间的JVM参数有两个：-XX:MetaspaceSize=N和 -XX:MaxMetaspaceSize=N -XX：MaxMetaspaceSize ： 设置元空间最大值， 默认是-1， 即不限制， 或者说只受限于本地内存大小。 -XX：MetaspaceSize ： 指定元空间触发Fullgc的初始阈值(元空间无固定初始大小)， 以字节为单位，默认是21M，达到该值就会触发 full gc进行类型卸载， 同时收集器会对该值进行调整： 如果释放了大量的空间， 就适当降低该值； 如果释放了很少的空间， 那么在不超 过-XX：MaxMetaspaceSize（如果设置了的话） 的情况下， 适当提高该值。这个跟早期jdk版本的 -XX:PermSize 参数意思不一样，- XX:PermSize 代表永久代的初始容量。 由于调整元空间的大小需要Full GC，这是非常昂贵的操作，如果应用在启动的时候发生大量Full GC，通常都是由于永久代或元空间发生 了大小调整，基于这种情况，一般建议在JVM参数中将MetaspaceSize和MaxMetaspaceSize设置成一样的值，并设置得比初始值要大， 对于8G物理内存的机器来说，一般我会将这两个值都设置为256M。 三、日均百万级订单交易系统如何设置JVM参数 结论： 通过上面这些内容介绍，大家应该对JVM优化有些概念了，就是尽可能让对象都在新生代里分配和回收，尽量别 让太多对象频繁进入老年代，避免频繁对老年代进行垃圾回收，同时给系统充足的内存大小，避免新生代频繁的进行垃 圾回收。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/915051e053e0d5423fc9251c0da81d7c/" rel="bookmark">
			Python-docx 深入word源码 自定义字符间距
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		代码和实现效果 from docx import Document from docx.oxml import OxmlElement from docx.oxml.ns import qn from docx.shared import Pt # 调整pt设置字间距 def SetParagraphCharSpaceByPt(run, pt=1): ''' 通过修改word源码方式, 添加w:spacing标签 直接通过调整pt来设置字符间距 ''' # 获取或创建&lt;w:rPr&gt;元素 rPr = run._element.find(qn('w:rPr')) if rPr is None: rPr = OxmlElement('w:rPr') run._element.insert(0, rPr) # 创建&lt;w:spacing&gt;元素 spaceChar = OxmlElement('w:spacing') spaceChar.set(qn('w:val'), str(pt * 20)) # 添加&lt;w:spacing&gt;到&lt;w:rPr&gt; rPr.append(spaceChar) def AddParagraph(doc, text): p = doc.add_paragraph() run = p.add_run(text) return p, run doc = Document() p, run = AddParagraph(doc, text='这是一个段落') SetParagraphCharSpaceByPt(run=run, pt=3) doc.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/915051e053e0d5423fc9251c0da81d7c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4005cc2d515969d25190f97005c7faa5/" rel="bookmark">
			【深度学习】loss与梯度与交叉熵的关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问的GPT3.5
模型训练时loss与梯度的关系？ 在深度学习模型训练过程中，loss（损失函数）与梯度（gradient）之间存在密切关系。损失函数衡量模型在给定输入上的预测输出与实际输出之间的差距，而梯度则表示损失函数相对于模型参数的变化率。以下是loss与梯度之间的关系：
1. 梯度下降：梯度下降是一种优化算法，用于逐步调整模型参数，以最小化损失函数。在每次迭代中，梯度下降根据损失函数的梯度来更新模型参数。梯度越小，表示模型在当前参数下损失函数的变化越小，因此梯度下降过程越慢。梯度为零时，表示模型已达到最优解。
2. 梯度上升：与梯度下降相反，梯度上升算法是为了最大化损失函数。在梯度上升过程中，算法会根据损失函数的梯度来更新模型参数，使梯度方向与损失函数的增大方向一致。
3. 梯度消失和梯度爆炸：在深度学习过程中，梯度消失和梯度爆炸是两个常见问题。梯度消失是由于梯度在反向传播过程中逐渐减小，导致权重更新幅度较小，从而使优化过程变得非常缓慢。梯度爆炸则是由于梯度过大，导致权重更新幅度过大，可能使模型无法收敛。为解决这些问题，可以采用一些技巧，如使用梯度裁剪、调整学习率、使用残差网络等。
4. 损失函数的曲线：损失函数的曲线可以反映模型在训练过程中的性能。通常，随着训练轮数的增加，损失函数值会逐渐减小。在优化过程中，梯度的大小和方向决定了模型参数的更新，从而影响损失函数的曲线。通过观察损失函数曲线，可以初步判断模型的训练效果和过拟合情况。
总之，深度学习模型训练时，loss（损失函数）与梯度之间存在密切关系。梯度下降和梯度上升算法分别用于最小化和最大化损失函数，而梯度消失和梯度爆炸是需要关注和解决的问题。通过调整学习率、使用梯度裁剪等方法，可以优化模型训练过程，提高模型性能。
二分类模型训练时loss与梯度以及交叉熵的关系? 在深度学习模型训练过程中，二分类模型的损失函数通常使用交叉熵（Cross-Entropy）损失。交叉熵损失衡量模型预测概率分布与实际概率分布之间的差异。以下是二分类模型中损失函数、梯度以及交叉熵之间的关系：
1. 交叉熵损失：对于二分类问题，假设真实标签为0和1，模型预测概率分别为p(y=0)和p(y=1)。则交叉熵损失可以表示为：
L = -Σ [y * log(p)]，其中y为真实标签，p为预测概率。
交叉熵损失的值越小，表示模型预测与实际标签之间的差距越小，模型的性能越好。
2. 梯度：梯度是损失函数相对于模型参数的变化率。在二分类问题中，梯度可以用于更新模型的参数，从而使损失函数不断减小。梯度的大小和方向决定了模型参数的更新速度和方向。
3. 损失函数与梯度的关系：在训练过程中，损失函数的值随着梯度的更新而减小。梯度下降算法根据损失函数的梯度来更新模型参数，使损失函数值最小化。交叉熵损失函数的梯度可以通过链式法则计算，其中包含模型参数、预测概率和真实标签。
4. 交叉熵损失与梯度的关系：交叉熵损失函数的梯度反映了模型预测与实际标签之间的差异。在训练过程中，通过不断更新模型参数，使得梯度方向与损失函数最小化的方向一致，从而提高模型性能。
综上所述，深度学习模型训练时，二分类模型的损失函数（交叉熵损失）、梯度以及交叉熵之间存在密切关系。通过优化梯度，使损失函数不断减小，模型性能得以提高。在训练过程中，交叉熵损失函数的梯度指导模型参数的更新，从而使模型能够更好地拟合实际数据分布。
loss值与损失函数的关系？ loss = F.cross_entropy(outputs, labels)
loss是ypred与ytruth的差距，经过损失函数后的差距。
深度学习模型训练时，输出的loss值与损失函数的关系可以从以下几个方面来理解：
1. 损失函数：损失函数（Loss Function）是衡量模型在训练过程中预测结果与实际结果之间差距的指标。损失值越小，说明模型预测结果越接近实际结果。常见的损失函数有均方误差（Mean Squared Error，MSE）、交叉熵损失（Cross-Entropy Loss）等。
2. 优化器：在训练过程中，优化器（Optimizer）负责根据损失函数的梯度更新模型的参数，以减小损失值。常见的优化器有梯度下降（Gradient Descent）、Adam、RMSProp等。优化器的作用是在每次迭代中调整模型参数，使损失值逐渐减小。
3. loss值：在训练过程中，每次迭代后，优化器会根据损失函数的梯度更新模型参数。输出的loss值就是当前迭代次数下的损失函数值。loss值越小，说明模型在当前迭代次数下的预测效果越好。随着训练的进行，loss值会逐渐减小，直到达到一个相对稳定的值或者满足预设的迭代次数。
4. 训练过程：深度学习模型的训练过程通常包括以下几个阶段：
- 初始化模型参数：在训练开始前，先初始化模型的参数。
- 正向传播：将输入数据经过模型计算，得到预测结果。
- 计算损失值：根据实际结果和预测结果计算损失函数值。
- 反向传播：计算损失函数关于模型参数的梯度。
- 更新模型参数：根据梯度使用优化器更新模型参数。
- 重复上述过程：直到满足预设的迭代次数或达到收敛条件。
5. 收敛：当损失值逐渐减小，并且变化幅度趋于稳定时，可以认为模型已经收敛。此时，模型在训练集上的预测性能较好，可以开始进行验证和测试。
总之，深度学习模型训练时输出的loss值与损失函数的关系反映了模型在训练过程中预测结果与实际结果之间的差距。loss值越小，说明模型的预测性能越好。通过优化器不断更新模型参数，损失值会逐渐减小，直至达到收敛。在这个过程中，损失函数起到了衡量模型表现和指导训练的作用。
def evaluate(config, model, data_iter, test=False): model.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4005cc2d515969d25190f97005c7faa5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d83b0b190d44186ced4f564270a7bcce/" rel="bookmark">
			js window窗口属性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 window: 指浏览器打开的那个窗口 window.alert(message)：显示一个对话框，其中包含指定的消息。 window.confirm(message)：显示一个对话框，其中包含指定的消息，并等待用户点击“确定”或“取消”。 window.prompt(message, default)：显示一个对话框，其中包含指定的消息，并等待用户输入一个字符串。如果用户点击“确定”，则返回输入的字符串；如果用户点击“取消”，则返回指定的默认值（如果未指定默认值，则返回 null）。 window.setTimeout(function, delay, ...args)：延迟指定的毫秒数后执行函数。 window.setInterval(function, delay, ...args)：每隔指定的毫秒数执行一次函数。 window.navigator：表示浏览器的信息，如浏览器名称、版本、插件等。 window.screen：表示屏幕的信息，如屏幕的宽度、高度、可用屏幕大小等。 window.innerHeight：获取浏览器窗口的高度（不包括工具栏和滚动条）。 window.innerWidth：获取浏览器窗口的宽度（不包括工具栏和滚动条）。 window.outerHeight：获取浏览器窗口的高度（包括工具栏和滚动条）。 window.outerWidth：获取浏览器窗口的宽度（包括工具栏和滚动条）。 window.scrollY：获取或设置浏览器窗口的垂直滚动位置。 window.scrollX：获取或设置浏览器窗口的水平滚动位置。 window.scrollTo(x, y)：将浏览器窗口的滚动位置设置为指定的坐标。 window.scrollBy(x, y)：将浏览器窗口的滚动位置向前移动指定的像素数。 window.scrollIntoView(element)：将指定的元素滚动到可视区域内。 window.addEventListener(event, callback)：向窗口添加事件。 window.removeEventListener(event, callback)：从窗口中移除事件。 window.documnet: 对整个个HTML页面进行增删改查 window.history: 历史记录 window.frames: 返回当前窗口，一个类数组对象，列出了当前窗口的所有直接子窗口 Window.localStorage: 会将键值对数据存储在本地中，浏览器关闭也还是存储，除非手动清除！ window.location：表示当前页面 URL 的对象。可以使用该对象来更改页面 URL。 window.location.reload()：重新加载当前页面。 window.location.replace(url)：替换当前页面为指定的 URL。 window.location.href：获取当前页面的完整 URL。 window.location.port:这个是判断访问链接中是否带端口 window.location.protocol: 获取当前浏览器链接所使用的协议（如http\https） window.location.origin：获取 URL 的协议、主机名（域名）和端口号 window.location.host: 返回当前访问链接中的域名 + 端口 window.location.hostname：返回的是访问链接（URL）的主机/域名 window.location.hash: 仅针对于路径中带#，返回#后跟随的锚点或是片段标识符 window.location.pathname： 返回文件地址或者当前访问的路径 window.location.search: 返回当前链接中?后面部分（如：?user=admin&amp;pdw=123456） 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b6732c53f4910736a69fcb71f3bc87f/" rel="bookmark">
			Word设置自定义快捷键方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		打开一个文档→单击左上角的office图标→word选项→左边的列表中选择自定义→在右边的窗口中，底部有个“键盘快捷方式自定义”的按钮，单击它→在弹出的自定义键盘窗口中，左边的“指定命令”的类别列表中找到“所有命令”→右边的“命令”列表中找到“Highlight”→看中间位置左边的“当前快捷键”，默认使用的是ctlr+alt+h→单击右边的“请按新快捷键”，按下你需要的ctrl+1→单击指定按钮，以后你所有使用normal模板的文档都可以用这个快捷键来调用颜色凸显文本了。如果不想所有的文档都用这个快捷键，就打开你要设定的文档再设置这个快捷键，在当前界面中单击“将更改保存在”列表，选定你的文档即可
设定后，单击“关闭”按钮就可以了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a5bfe24f8af08ddd8e91a2365a892bf/" rel="bookmark">
			Linux基础命令大全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 此文档主要讲解Linux基础命令的使用方法
介绍Linux基础命令的语法格式掌握目录操作命令掌握文件操作命令掌握权限管理命令掌握系统常见操作命令 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/452efcad713ede3d894c90b2ffe2aef8/" rel="bookmark">
			标记数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		32978.删除 题目描述 比赛期间，评委收到一份有N个各种分数的列表，随后又收集到一份因运动员比赛过程中有违规动作需要取消的一份有M个各种分数列表。评委当然是要从列表中画去这些分数，然后用宽度为20，高度是分数的黑色矩形组成的柱形图表示。
比如N=6 ， 第1份的分数列表为 100、120、78、50、110、80。M=4，第2份列表的分数为 80、100、45、50。显然处理后的分数列表是120、78、110，画出的图如下：
注：3个矩形每个宽20，高度分别为120 78 110。
输入格式 第1行一个不超过20的正整数N。
第2行有N个范围在50到300之间的正整数。表示第一份分数列表。
第3行一个不超过20的正整数M。
第4行有M个范围在50到300之间的正整数。表示第二份分数列表。
解题思路：
（1）输入违规分数时，就和原分数表进行比较，并在原分数的数组中将违规数据标记为-1；
int main(){ p.speed(10); int n,m,a[25],t; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) { cin&gt;&gt;a[i]; } cin&gt;&gt;m; for(int i=1;i&lt;=m;i++) { cin&gt;&gt;t; for(int i=1;i&lt;=n;i++) if(a[i]==t) a[i]=-1;//将违规数据标记为-1 } p.up().c(0); for(int i=1;i&lt;=n;i++) { if(a[i]&gt;=0) { p.fd(a[i]/2.0).r(20,a[i]).bk(a[i]/2.0); p.rt(90).fd(20).lt(90); } } p.hide; return 0; } 注意：
（1）双重循环要注意谁是外循环，谁是内循环，检查时，先固定外循环一个数，看看内循环怎么执行。例如i=1时，内循环比较了n次违规数据。
（2）固定书写格式，前面写上speed(),结尾写上hide()。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9447b878e20ded8788e1a9e7a9098a82/" rel="bookmark">
			【Regulatory Genomics】Part3 GENOMICS AT NVIDIA、ATACWORKS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Enchancing epigenomic data with deep learningAtacWorks: Improving the quality of ATAC-seq signals1 model structure2 training strategy Performance of AtacWorks 来自Manolis Kellis教授（MIT计算生物学主任）的课
油管链接：Regulatory Genomics - Deep Learning in Life Sciences - Lecture 07 (Spring 2021)
本节课分为三个部分，本篇笔记是第三部分。
本节主要是介绍了英伟达在基因组学方面的一些工作，主要介绍了ATACWORKS这个模型。用于在有噪声的、有数据质量问题、分辨率低的数据，还原成清晰的测序数据。
Enchancing epigenomic data with deep learning 主要介绍了英伟达基因组学研究设计的一些领域，基于他们的硬件将机器学习、深度学习、加速计算应用在生物信息里
接下来主要是介绍这篇工作 首先介绍一下 ATAC-seq测序， 将reads贴上基因组上
用于测量染色质的可及性，通过DNA测序技术。
高测序读取覆盖率的“峰值”对应于基因组中开放的染色质区域。
有助于识别活跃的调控元件，构建调控网络，并研究非编码变异的影响。
在单个细胞上进行测量，生物组织由不同类型的细胞混合组成，单细胞测序可以展示这种异质性，但每个细胞只提供有限的信号
Bulk ATAC：展示了大量细胞（不同种类细胞）的整体染色质可及性，平均数据。
Aggregate scATAC：这是多个单细胞ATAC-seq数据的聚合。尽管每个单独的细胞可能只提供有限的信息，但将它们聚合在一起可以提供与 Bulk ATAC 类似的信号。
下面的每行是一个细胞，如果不叠加在一起的话，是看不出什么东西的 所以我们使用如右侧所示的聚类，将细胞分类成一个个簇，需要哪个就提取一个簇出来，将其中的每个细胞信号叠加
UMAP - 是一种降维技术，用于将高维数据（如单细胞ATAC-seq数据）可视化到二维空间。
然后我们就可以比较为什么不同簇的细胞类型不同，为什么某些序列变异，影响的是这种细胞而非那种细胞 还是有些问题会导致ATAC-seq的数据质量问题
Low sequencing depth（测序深度低）: 这里展示了两种测序深度：50 million reads 和 1 million reads。更高的测序深度可以提供更加精确且清晰的数据。 Sample/experimental factors（样本/实验因素）: “Fresh tissue”（新鲜组织）和“Flash-frozen”（快速冷冻）的样本。不同的样本处理方式可能导致数据的差异。 Low aggregate cell count（细胞计数低）: 下面的柱状图展示了对应的ATAC-seq数据，突出显示了开放染色质区域的位置。某一簇的细胞计数太低，那么结合起来后得到的数据可能不够代表性或精确。 AtacWorks: Improving the quality of ATAC-seq signals 1 model structure 基于以上的问题，提出了AtacWorks来增强ATAC-seq准确性，去除噪声
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9447b878e20ded8788e1a9e7a9098a82/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc9f84f436a80088d13423b543007640/" rel="bookmark">
			【复盘与分享】第十一届泰迪杯B题：产品订单的数据分析与需求预测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 题目第一问第二问2.1 数据预处理2.2 数据集分析2.2.1 训练集2.2.2 预测集 2.3 特征工程2.4 模型建立2.4.1 模型框架和评价指标2.4.2 模型建立2.4.3 误差分析和特征筛选2.4.4 新品模型 2.5 模型融合2.6 预测方法2.7 总结 结尾 距离比赛结束已经过去两个多月了。
整个过程还是非常辛苦的，在前期整个团队都在进行学习铺垫，精力主要集中在全部数据给出后的建模
收到了答辩的通知，可惜评委问的问题太过离谱，没能展现出我们的创新点，最终没能获得特等奖，是个国一
因为感觉对我们的工作进行一个总结，对很多准备相关比赛的同学还是挺有帮助的，所以还是复盘一下
所有的代码和数据已经上传至github
链接：ProductDemandForecast-TeddyCup11B
大家不用在评论区问我要了，明年会将论文和答辩ppt也开源供大家学习，请自觉点赞收藏，给github点点star（论文已更新）
用Prophet一个个商品预测肯定是错误的，训练时间太长。先整合成结构化数据，再上机器学习才是合理的做法
题目 任务1：数据分析
针对提供的历史销售数据(order_train1.csv)，需要进行深入的数据分析。分析主题包括但不限于：
1.1 产品的不同价格对需求量的影响
1.2 产品所在区域对需求量的影响，以及不同区域的产品需求量有何特性
1.3 不同销售方式（线上和线下）的产品需求量的特性
1.4 不同品类之间的产品需求量有何不同点和共同点
1.5 不同时间段（例如月头、月中、月末等）产品需求量有何特性
1.6 节假日对产品需求量的影响
1.7 促销（如618、双十一等）对产品需求量的影响
1.8 季节因素对产品需求量的影响
任务2：需求预测
基于上述分析，需要建立数学模型，对给出的产品(predict_sku1.csv)进行未来3个月（即2019年1月、2月、3月）的月需求量预测。预测结果需要按照给定格式保存为文件result1.xlsx。
请分别按照天、周、月的时间粒度进行预测，并尝试分析不同的预测粒度对预测精度可能产生的影响。
第一问 第一问就是数据探索性分析，没啥好说的，现在会调chatgpt并且进行简单的修改就能做出不错的图了。
虽然题目的意思可能是通过第一问的分析，对第二问的建模起到什么帮助，可能会在论文里看起来不错，但说实话屁用没有。第二问预测靠的还是特征工程等经验。所以第一问不是重点，展示几个图吧，不细讲了。
价格与需求量散点图 线下/线上订单需求量随时间变化趋势图 各大类/细类产品需求量占比双环图 各大类产品月需求量气泡图 不同时段（月初、月中、月末）的产品需求量折线图 线下/上销售趋势 “6.18”和“双十一”期间Top50促销产品所属细类双向柱状图 第二问 第二问要预测的精准，还是比较考验学习、代码能力的，当时是看了好几个销量预测的比赛代码，主要是kaggle上的，并且一步步自己改。搭出Baseline后，能先有一个预测的结果，再一步步的加上自己的想法。
以下内容都是先有Baseline后一步步试出来的，所以会有些跳跃性
一些链接（很多我找不到了）：
详细的EDA和随机森林
1st place solution - Part 1 - “Hands on Data”
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc9f84f436a80088d13423b543007640/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/44/">«</a>
	<span class="pagination__item pagination__item--current">45/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/46/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>