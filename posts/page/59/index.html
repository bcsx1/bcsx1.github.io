<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be235f8b40ece709edc222d6a6de13f0/" rel="bookmark">
			电路分析之等效模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. 理论计算与直接更换元器件
2.集总参数电路模型
2.1不同频率电路采用不同的电路模型
2.2集总参数模型仅与时间变更有关
1. 理论计算与直接更换元器件 在工作中经常听到这样的一种论调：
“这个电路理论上不用算直接拿一个元器件上去试一下就知道行不行了。”
“你算半天结果和实测值相差很大，根本没必要算，算也算不准，还不如直接换元器件来得快。”
这种说法错吗？没有错，确实在工程上很多时候理论的计算还不如直接更换元器件来得快。这也便导致越来越多的硬件工程师，慢慢地把以前在大学学的那一点点的理论计算归还如老师。硬件设计更多的是依赖于元器件或方案供应商，一遇到问题，换了几个元器件还解决不了后，便电话联系供应商技术支持。而不会从根本上自己分析和解决遇到的问题。做为硬件工程师，还是需要静下心来，沉下去把基础的电路原理搞明白，才能真正的把所应用的电路搞懂，才能在最短的时间把遇到的问题解决掉，更才能从谈创新和技术升级。之前所说的理论算不对与实测值相差很大，很大程度上是因为电路的等效模型建立不完善导致。接下来我们从最基本的电路建模来聊聊。
2.集总参数电路模型 2.1不同频率电路采用不同的电路模型 在不处理高频电路一般指100MHz或EMC（电磁兼容）、信号完整性的情况下，我们一般遇到的电路都可以用集总参数电路来等效。集总参数元件是指有关电、磁场物理现象都由元件来集总表征。在元件外部不存在任何电场与磁场。电磁波在该元件内部传输的延时必须远小于信号时间范围，即系统最大电尺寸远小于系统信号的最大波长。d＜＜λ。也就是信号只是与时间变量有关的函数，与位置变量无关。因此在不同频率电路中，同一个元件需要采用不同的等效电路模型。例如一个电感如下图所示
在纯直流稳定后的电路中，其等效为一个电阻R，R值大小为电感的直流电阻；
在交流低频信号中，其等效为一个电阻串联一个感；
在交流高频信号中，其等效为一个电阻与一个电感串联再与一个电容并联。
所以在电路分析之前，需要搞清楚，所要分析的电路元件到底是要用哪种模型来建模。
2.2集总参数模型仅与时间变更有关 以均匀传输线为例
在工作频率分别是50Hz，200kHz和200MHz情况下，分析0.75m的信号走线或通信线缆两端的电压变化。可以看到，在低频时，两者基本相同，但在200MHz时，U1与U2已经存在180度相位差。也就是说明在高频信号中的电路模型还需要考虑位置变量，不能简单的用时间变更来计算。
以后还遇到理论与实际测量值不匹配时，停下来想一想自己的电路模型建立的是否准确。不是理论不对，而是我们自己没有算对而已。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2d5ccacf26108ab8adcc19ea1d00419/" rel="bookmark">
			开拓经验专栏：从十来天的晨型人体验开始
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 拓新缘起契机实践心得 拓新 确定要新开一个板块，用来记录持续自我提升的经验和教训，着实遭遇了不少阻力。
首先，我的语文功底一向不行，当年高考前，语文分数在及格线上下跳动都是常事，现在却要通过纯文字对外输出，心里是有些虚的；其次，怕在这个板块内，到后面就没有什么可写的了，如果后续为了写而写，一定会非常难受；最后，担心有粉丝会觉得这个板块偏离了我公众号的主题，一个做工业运筹的不好好写运筹在工业中的应用，然后就取关了。
直到某一天在写早起日记时，突然的一记重锤砸醒了我：我写公众号的初衷到底是什么。事实上，我的初衷一直只有两个方面：第一，更高效地自我提升，第二，帮助有需要的人。
关于第一点（更高效地自我提升），由于我不是运筹专业出身，本科学应用物理，硕士学飞行器设计，直到博士搞智能优化算法，才算勉强碰到了运筹学的大门。后来博士毕业，离开学术界来到工业界做运筹应用，对我来说是一件充满未知和挑战的事情，在工作中要想把事情做好，需要学习太多内容，因此我有非常强烈的提升技能的诉求。此外就个人风格而言，我喜欢挑战而不喜欢躺平，所以在持续自我提升上也有非常强的动力。
在思考如何实现高效的自我提升时，才想到了写公众号。《认知觉醒：开启自我改变的原动力》中，关于深度学习的建议包含3个步骤：获取高质量的知识、深度缝接新知识和输出成果去教授。而通过写公众号，可以同时实现第二步和第三步。
关于第二点（帮助有需要的人），我也是非常乐意的。我比较相信此前导师关于人和社会关系的一段阐述：人在年轻的时候，从社会汲取资源，比如父母的呵护和学校的教育等；到了青中年的时候，羽翼渐丰，会自己动手创造价值，推动社会发展；步入老年后，可以向下一代年轻人输出自己的经验，从而形成一个循环。长期看，正是这样一种循环推动着社会不断向前发展。
在属于自己的小世界里，我很期待自己能做点有价值的事情，同时也乐意把自己的成功经验和失败教训分享给任何有需要的人。而且，我一直有个愿望，那就是当自己跳出工业界后，可以去某个地方当名老师，教书育人。通过写公众号拓展算法深度、场景认知和问题理解，也算是给自己的未来做准备了。
基于以上的思考，我还是决定要开启这个经验和教训板块。第一篇的主题，就是我最近正在践行的早起计划：做个晨型人。
缘起 先简单描述一下什么是晨型人——每天早起的人。具体有多早就因人而异了，有7点的，有6点的，有5点（Jack Dorsey，Twitter联合创始人）的，甚至有4点半（Howard Schultz，星巴克创始人）的。
至于为什么我想做晨型人，这里面的原因就比较多了，直接的导火索有三条：
（1）每天晚上睡得非常晚，躺到床上后还要刷会小视频，几乎没有在24点前放下手机的情况，很多时候可能是由于睡前游戏玩的比较嗨，关灯后很长时间依旧睡不着，有时会打开微信读书来促进睡眠，但总觉得这是非常不健康的作息习惯，这导致我经常陷入自我责怪却又找不到有效解决方案的怪圈。
（2）因为睡得晚，第二天早上起床就像上刑场一样，能拖一秒是一秒，有时候甚至懒到不愿意去上班，只能请假，为此也消耗掉了我好几天宝贵的年假。同时，也因为起得晚，被女朋友教育了好多次，说我是早上出门时间的“短板”，每天早上都要等她摆好早饭我才愿意起床，诸如此类。
（3）受限于出门晚，女朋友平时骑电动车上班时，经常要和时间赛跑，我总觉得赶时间会比较危险。
除了以上三个导火索，我自身也有做晨型人的源动力：我近期比较关注个人成长，今年已经读了6本以上相关的书籍，比如：《认知觉醒：开启自我改变的原动力》、《人生护城河：如何建立自己真正的优势》等。我发现几乎所有的书籍里，都有一条建议，那就是要充分利用好早晨的时间。
综上所述，我想做晨型人已经很久了，只是一直缺乏科学的打开方式和恰当的契机。
契机 为了能给自己寻来更多的晨型人动力，我决定看这本书：《早起的奇迹：有钱人早晨8点前都在干什么》。
按照我平时的习惯，我看的书，一般都要求微信读书的推荐值超过80%，但是这本书的推荐值仅为57.3%；而且主观来说，早起和有钱是否存在因果关系，我都是存疑的，所以看名字我就觉得这本书不是很可信。因此，若不是真的被折磨已久，我是万万不会选择这本书的。
我前后花了差不多3个半小时看完了这本书，不幸的是，我并没有在书里找到更多的晨型人动力，当然也没有被说服早起和有钱之间有因果关系。
但是书中却给我提供了一整套可落地的晨型人执行方案。首先是降低早起难度，书中的术语叫：提升起床激励水平，一共有5步：晚上睡之前给自己积极的自我暗示-&gt;将闹钟放到自己够不着的地方-&gt;直接走到盥洗室刷牙-&gt;喝下满满一大杯水-&gt;穿上晨练服出门锻炼。
然后是早起后要做的事情，书中的术语叫：S.A.V.E.R.S.人生拯救计划，一共有6步：心静（冥想、祈祷、沉思、深呼吸、感恩）、自我肯定（告诉自己是最优秀的）、内心演练（具象化美好的未来）、锻炼、阅读、书写。
所以，现在万事俱备，只差契机了。
伴随着组内团建，契机终于有了！
事情是这样的，组内有个小伙伴A要转岗了，领导让我在他离开前再组织一次团建。团建地点选择的是自助餐厅，4人一小桌，我和A坐在一桌。吃饭的时候，聊到了起床时间。A说，他每天早上6点起床，然后锻炼。我很早就知道他有跑马拉松的爱好，所以一直心有佩服，但是听到他说自己每天6点起床时，还是震惊不已——我第一次发现，身边真的有人会早起，而且还能长期坚持。用星爷电影里的一句话来说：对他的仰慕，如滔滔江水连绵不绝。虽然我对马拉松没有兴趣，但是我对早起很有想法呀。
所以，晨型人，我要来了！
实践 第一天实践，是2023年11月8号。前一晚把闹钟调整到6点12分（此前是7点13分），然后在23点的时候把手机放到了客厅，就去卧室关灯睡觉了。因为是第一次执行，所以迟迟没有睡着，第二天早上6点半才听到客厅的闹钟，起床后刷了个牙，洗了把脸、喝了杯水、做了晨醒冥想和瑜伽、读了几页书、写个简短的早起日记，整体感觉算是一个比较成功的开始。
第二天的实践不太成功，一觉醒来，外面的天都已经亮了，看了时间，是7点09。不过我也没有气馁，毕竟现在晚上放下手机关灯睡觉的时间已经提前到了23点，做晨型人的决心也更大了。
第三天开始，走上正轨了。基本上都在6点15左右走出了卧室，起床后还增加了拍窗外晨景的环节，顺便给每天的早起日记增加一张美美的图片。这里附上最近几天的晨景照片，分享给大家。
从2023年11月14号晚上开始，我把闹钟往前调整到了5点57分。调整的主要原因是：早上时间有些少了，因为洗漱、冥想、瑜伽和日记是必选项，所以留给读书的时间太少了。而且我还打算在早上增加写作事项，读书时间如果没有，可以放到上下班坐地铁的路上，我写作的速度比较慢，所以需要再早点。暂定的最终目标是凌晨5点半，拟定分4步完成，6:15-&gt;6:00-&gt;5:45-&gt;5:30，每一到两周向前调整一次。
调整闹钟时间后，2023年11月15号和16号是6点左右起床的，17号偷了20分钟的懒，这个周末甚至都没有早起。不过这不是因为我放弃了坚持做一个晨型人，而是我做晨型人已经快两周了，这两天睡个懒觉，然后看个甜甜的短剧，就是我奖赏自己的一种方式。
明天开始，我必将还是元气满满的晨型人。
心得 做晨型人的实践只有十来天的时间，很多事情都还在探索中，所以谈不上经验或者教训，权当是心得吧。
心得主要从以下三个方面展开：早起给我带来了什么？是否会推荐别人早起？做晨型人的一些思考。
早起给我带来的最直接的改变是精神状态的提升。实践了早起计划后，我发现自己每天醒来做的第一件事就是成功的，这是一个非常强的正反馈，可以激励我以更积极的状态去面对一天的工作；不间断的瑜伽锻炼也让我觉得为自身健康做了持续投入，事实上，我已经隐约感受到自己身体的柔韧性比之前好了很多，而且好像都有腹肌了；阅读和写作的的时间有了保证后，也让我感觉到，自己的持续学习之路，会是充实和饱满的。
这里补充一个关于为什么要坚持阅读的理解，我自己之前不爱阅读，但听大家都在说应该坚持阅读，所以我一度非常焦虑，也到处搜索和咨询过这个问题，后来终于在某本书里找到了我喜欢的答案：阅读提供了一个免费与大师对话的机会，花3分钟读的一篇博客，可能是别人思考3天的成果；花20分钟读的一篇论文，可能是别人研究4个月的成果；花5小时读的一本书，已经是别人沉淀15年的结晶。
此外，早起还有很多隐形的好处：
（1）接受到更多的正反馈。坚持早起在很多人眼里是被划在优秀品质中的，所以日常就能收到来自女朋友和身边朋友的夸奖。虽然我已不是个宝宝了，但是谁会不喜欢被夸呢。
（2）带女朋友调整了作息时间。早睡早起其实不是一个人的事情，是需要和家人提前沟通好的。在我早起的需求下，我和女朋友终于能在晚上23点就关灯睡下了，虽然她并没有早起，但是能建立早睡的习惯，就已经是额外收获了。
（3）早起后再也不着急忙慌了。到了点后，先把女朋友叫起来，然后去摆早饭，吃完饭甚至还有时间刷个碗收拾一下再出门，此前被女朋友数落的场景几乎不存在了。
至于早起的缺点，目前还没有发现。虽然有时候也会觉得有些困，但那应该不是早起引起的。
基于以上提到的诸多好处，如果有人问我是否会推荐别人早起，我肯定是大力推荐的。但需要注意的是，早起本身并没有定义起床的时间，而且只是一个事件，并不具备多少意义。早起真正的价值主要体现在早起后所做的事情，所以早起的时间也应该依据早起后要做的事情来确定。
结合《早起的奇迹：有钱人早晨8点前都在干什么》中提到的S.A.V.E.R.S.人生拯救计划，以及我的实践经历，我觉得只有一件事是必选的，那就是锻炼，其他的都是增值项。举些例子，我在这个基础上增加了阅读/写作，有些人想出国可能会增加背单词选项，而我女朋友觉得健康就好，所以认为没有必要再有增值项。
确定了增值项后，就可以反推早起时间了。以我自己为例。我平时是7点半起床，如果做晨型人，锻炼需要15分钟（冥想5分钟，瑜伽10分钟）；洗漱喝水拍照需要5分钟；早起日记需要10分钟，写作/阅读需要60分钟，所以早起时间至少应该是6点。
在做晨型人的过程中，如果能在网上找到志同道合的人，互相交流做晨型人的体验和心得，应该是蛮好的。我关注了《早起的奇迹：有钱人早晨8点前都在干什么》中文简体版出版方成立的微信公众号“海派早起俱乐部”，并且加入了他们组织的“早起俱乐部”的群。不过从当下的体验来看，除了日常打卡的功能，并没有什么亮点。而我一直认为，早起应该是自发行为，不能为了打卡而打卡，所以我更喜欢以早起日记的形式记录我的每一天晨型人生活和思考，所以打卡功能对我也没有多少价值。
另外，是否要坚持不间断早起，也是个需要考虑的问题。就我个人而言，一年365天全都早起，好像也没必要，偶尔补个懒觉，会是恢复精力和犒赏自己的有效方式。所以我目前的实践方案是：工作日持续早睡早起，周末保持早睡可以晚起，但起床后的拍照、冥想、瑜伽、日记要坚持。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e426a393102dd41e39a0b080751ce652/" rel="bookmark">
			Otter改造 增加Springboot模块和外部调用接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现状 manager 管理node，manager还提供了界面来配置同步链路。但是界面操作依赖人工，manager没有提供HTTP接口，其它服务想通过接口来创建任务的话，不可行。
计划改造成能够通过接口调用来创建同步链路。
项目改造 基于Otter master分支最新提交，增加springboot client工程，目标是为公司内springboot项目通过HTTP调用或者Dubbo调用操作Otter manager，实现任务创建和启动停止等
改造内容：
新增springboot client工程jdk版本升级为1.8使用springboot 2.3.2.RELEASE，大家可通过RESTful接口调用 Otter manager模块 打包：
进入$otter_home目录执行：mvn clean install -Dmaven.test.skip -Denv=release发布包位置：$otter_home/target 部署Otter manager：
按照官方文档部署Otter的manager和node，https://github.com/alibaba/otter/wiki/QuickStart 部署Otter client：：
进入$otter_home/target目录执行：mkdir client &amp;&amp; tar -xf client.deployer-4.2.19-SNAPSHOT.tar.gz -C client启动脚本位置：$otter_home/target/client/bin/start.sh修改manager端口：$otter_home/target/client/conf/application.yml，默认是 127.0.0.1:1099，请改成你部署的Otter manager地址 启动 springboot client：
进入$otter_home/target/client目录启动脚本位置：bin/startup.sh执行启动脚本：sh bin/startup.sh测试调用：在命令行窗口输入curl --location 'http://localhost:8100/nodetest/node/1' 或者 浏览器地址栏输入 http://localhost:8100/nodetest/node/1，
返回 node 节点的信息表示成功：
Node[id=1,name=test-node1,ip=127.0.0.1,port=2088,status=START,description=,parameters=NodeParameter[mbeanPort=2090,downloadPort=2089,zkCluster=AutoKeeperCluster[id=1,clusterName=test-zk,serverList=[10.23.104.43:2181],description=,gmtCreate=2023-07-29 14:55:06,gmtModified=2023-08-23 19:48:22],externalIp=127.0.0.1,useExternalIp=false],gmtCreate=2023-07-29 14:56:14,gmtModified=2023-08-01 10:51:56]执行关闭脚本停止client：sh bin/stop.sh
Oook! cost:2 改造代码已经开源到个人github，注意是 feature- springboot分支：https://github.com/quanllong/otter/tree/feature-springboot
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7ddfe908dbf71393be23ba57d7e6f9a/" rel="bookmark">
			Windows UAC权限详解以及因为权限不对等引发的若干问题分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、什么是UAC？
2、微软为什么要设计UAC？
3、标准用户权限与管理员权限
4、程序到底以哪种权限运行？与哪些因素有关？
4.1、给程序设置以管理员权限运行的属性
4.2、当前登录用户的类型
5、案例1 - 无法在企业微信聊天框中启动安装包程序
6、案例2 - 使用Windbg时可能会遇到的权限不对等导致操作失败的问题
6.1、Windbg附加到目标进程失败
6.2、dump文件拖到以管理员权限运行的Windbg中没反应
7、案例3 - 双击桌面快捷方式启动程序时并没有自动将已经启动起来的程序窗口弹出来
8、与管理员权限相关的其他问题
8.1、如何以管理员权限启动一个程序？
8.2、开机自启动程序不能设置管理员权限
VC++常用功能开发汇总（专栏文章列表，欢迎订阅，持续更新...）https://blog.csdn.net/chenlycly/article/details/124272585C++软件异常排查从入门到精通系列教程（专栏文章列表，欢迎订阅，持续更新...）https://blog.csdn.net/chenlycly/article/details/125529931C++软件分析工具从入门到精通案例集锦（专栏文章，持续更新中...）https://blog.csdn.net/chenlycly/article/details/131405795C/C++基础与进阶（专栏文章，持续更新中...）https://blog.csdn.net/chenlycly/category_11931267.html开源组件及数据库技术（专栏文章，持续更新中...）https://blog.csdn.net/chenlycly/category_12458859.html网络编程与网络问题分享（专栏文章，持续更新中...）https://blog.csdn.net/chenlycly/category_2276111.html 在Windows系统中，我们使用软件时时常会遇到因管理员权限与标准用户权限不对等导致操作失败的问题，很多人搞不清楚是怎么回事，今天我们就来详细讲讲与之相关的UAC权限控制，并给出具体的问题实例，供大家借鉴或参考。
在这里，给大家重点推荐一下我的两个热门畅销专栏：
专栏1：（该专栏订阅量接近350个，有很强的实战参考价值，广受好评！）
C++软件异常排查从入门到精通系列教程（专栏文章列表，欢迎订阅，持续更新...）https://blog.csdn.net/chenlycly/article/details/125529931
本专栏根据近几年C++软件异常排查的项目实践，系统地总结了引发C++软件异常的常见原因以及排查C++软件异常的常用思路与方法，详细讲述了C++软件的调试方法与手段，以图文并茂的方式给出具体的实战问题分析实例，带领大家逐步掌握C++软件调试与异常排查的相关技术，适合基础进阶和想做技术提升的相关C++开发人员！
专栏中的文章都是通过项目实战总结出来的（通过项目实战积累了大量的异常排查素材和案例），有很强的实战参考价值！专栏文章还在持续更新中，预计文章篇数能更新到200篇以上！
专栏2： VC++常用功能开发汇总https://blog.csdn.net/chenlycly/article/details/124272585
专栏将10多年C++开发实践中常用的功能，以高质量的代码展现出来，并对相关功能的实现细节进行了详细的说明。这些常用的代码，其质量与稳定性是有保证的，可以直接拿过去使用，可以有效地解决C++软件开发过程中遇到的问题。
专栏3：
C/C++基础与进阶https://blog.csdn.net/chenlycly/category_11931267.html
以多年的开发实战为基础，总结并讲解一些的C/C++基础与进阶内容，以图文并茂的方式对相关知识点进行详细地展开与阐述！专栏涉及了C/C++领域的多个方面的内容，同时给出C/C++及网络方面的常见笔试面试题，并详细讲述Visual Studio常用调试手段与技巧！
1、什么是UAC？ UAC（User Account Control），用户帐户控制，是微软从Windows Vista开始引入的一种新的控制机制，其原理是通知用户是否对应用程序使用硬盘驱动器和系统文件授权，以达到阻止恶意程序（有时也称为“恶意软件”）损坏系统的目的。
UAC用户账户控制机制主要是权限隔离，防止低权限、低安全的应用获取系统高等级权限。系统弹出UAC提示框，让用户确认是否信任、是否以管理员权限运行未知、未签名应用。
当运行一些会影响系统安全的程序时，会自动触发UAC，用户确认后程序才能运行。比如当你运行一个安装程序（一般以管理员权限运行）或者打开一个未经验证的程序时，就会弹出类似如下的UAC提示框：（以在Win10系统中双击需要以管理员权限运行的QQ安装包程序为例）
用户确认后程序才能继续运行。
这个弹框是提示用户程序可能会对当前计算机进行修改，但这个提示对对绝大部分用户来说，好像并没有什么用。对普通用户而言，不但没什么用，反而会带来困扰（到底是该允许呢？还是不允许呢？）。并且老是时不时地弹框，用户也很厌烦！
稍微专业的用户，可能会将UAC通知关闭掉。具体方法是，打开控制面板，然后点击“用户账户”，进入用户账户设置页面：
然后点击“更改用户账户控制设置”，到如下的页面中：
将滚动条拉到底，就可以将UAC通知关闭掉。关闭后，就不会再弹UAC提示框了。
既然大家都不喜欢UAC提示框，微软为什么还要设计出这样一个别脚的东西来呢？
2、微软为什么要设计UAC？ 很多人都用过Windows XP，大多数人在用Windows XP时，使用的应该是管理员权限的账户。而在微软的设想中，普通用户都应该都使用标准账户。为什么大家不用标准账户？Windows XP里的标准账户，可能连程序都没法正常安装！没有人愿意为了装个程序，切换到管理员账户，装完了再切换回标准用户。
当然，微软也注意到了这一点，于是就设计了UAC系统。UAC与Windows XP的用户账户权限管理，最大的不同在于，UAC对权限的控制很有弹性。它默认所有程序都是以标准权限运行的（无论你使用的是管理员账户还是标准账户），而当你运行一个需要管理员权限运行的程序时，UAC就会跑出来问你，这个程序需要管理员权限，要不要继续，如下：
如果你允许，UAC就会提升权限，用管理员权限运行这个程序。
其实从UAC的设计的本意上来看，它即避免了直接使用管理员账户导致权限控制形同虚设，又解决了标准用户需要频繁切换到管理员账户的问题（可能是模仿Linux系统中的su权限提升）。
但Windows下的UAC一点也不智能，连复制文件之类的操作，甚至都会跑过来问你一下，很多用户不厌其烦，直接把UAC一关了事。尽管Windows对UAC做了一些改变和优化，但UAC还是很烦。比如，你第一次打开一个需要管理员权限的程序，UAC会尽忠职守地问你是否要提升权限；你第二次打开，UAC还会尽忠职守地问你是否要提升权限；你第三次打开，UAC还会尽忠职守地问你是否要提升权限……于是大家不愿意了，把UAC一关了之。
甚至有些人直接使用Administrator这个超级管理员用户，在这个用户登录下，所有程序默认以管理员权限运行，基本所有的操作都不会弹UAC提示框了。
用过Android手机的用户都知道，Android里有个信任程序列表，一旦加入这个列表，再次运行的时候，系统就不会做多余的询问了。而Windows UAC中没有这个东西，因为微软的人认为，如果要创建一个信任列表，那这个列表必然会被储存在注册表或者硬盘的某个地方，这样hacker就可以想办法破解并修改这个列表了（就像XP的密码一样）。
3、标准用户权限与管理员权限 Windows从Vista系统开始就引入了UAC权限控制机制，强化了管理员权限的概念，做了更严格的权限限制与安全控制。比如对一些权限敏感的路径，比如C:\Program Files、C:\Windows\system32，如果要在这些路径下创建文件、向文件中写数据，都是需要管理员权限的。再比如，在Windows系统的注册表中，如果要向HKEY_LOCAL_MACHINE路劲下写入或修改内容时，也需要管理员权限的。
程序运行权限主要有标准用户权限和管理员权限两种。有很多操作，都需要管理员权限，比如：
1）管理员权限的程序才能向系统安全敏感路径执行写操作，比如在C:\Program Files、C:\Windows\system32等系统路径中创建文件、拷贝文件，向这些路径下的文件执行写操作。
2）只有管理员权限的程序，才能向系统注册表路径HKEY_LOCAL_MACHINE下执行创建或写操作。没有管理员权限的程序，只能对HKEY_CURRENT_USER路径下执行写操作。
3）只有管理员权限的程序，才能向系统注册控件（要向HKEY_LOCAL_MACHINE路径下的注册表写入信息）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a7ddfe908dbf71393be23ba57d7e6f9a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98a3ded40d4e1dc85cd3ee0e4cd17d1c/" rel="bookmark">
			Zookeeper实战案例（1）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前置知识：
Zookeeper学习笔记（1）—— 基础知识-CSDN博客 Zookeeper学习笔记（2）—— Zookeeper API简单操作-CSDN博客
Zookeeper 服务器动态上下线监听案例 需求分析 某分布式系统中，主节点可以有多台，可以动态上下线，任意一台客户端都能实时感知到主节点服务器的上下线
具体实现 首先创建节点servers：create /servers "servers"
服务器向zookeeper注册的代码 package com.why.zkCase; import org.apache.zookeeper.*; import org.junit.Before; import java.io.IOException; //服务端向zookeeper注册 public class DistributeServer { private static String connetString = "hadoop102:2181,hadoop103:2181,hadoop104:2181"; //客户端连接ip private static int sessionTimeout = 2000; //超时时间 private ZooKeeper zkClient = null; //客户端对象 private String parentNode = "/servers"; //父节点路径 @Before public void getConnect() throws IOException { zkClient = new ZooKeeper(connetString, sessionTimeout, new Watcher() { @Override public void process(WatchedEvent watchedEvent) { //收到事件通知后的回调函数 System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98a3ded40d4e1dc85cd3ee0e4cd17d1c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aaa0bf2871035e642249b3374176440f/" rel="bookmark">
			搭建Ubuntu 22.04可视化界面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 搭建Ubuntu 22.04的可视化界面通常包括安装图形用户界面（GUI）和桌面环境。在Ubuntu中，常用的桌面环境有GNOME、KDE、XFCE、LXQt等。以下是一些通用的步骤，但请注意，具体步骤可能因桌面环境而异。
执行以下命令，清空缓存，更新您的软件包列表。
sudo apt clean all &amp;&amp; sudo apt update 执行以下命令，安装桌面环境所需软件包。包括系统面板、窗口管理器、文件浏览器、终端等桌面应用程序。
sudo apt install gnome-panel gnome-settings-daemon metacity nautilus gnome-terminal ubuntu-desktop 开机默认进入命令行模式或图形用户界面：
sudo systemctl set-default multi-user.target # 命令行 sudo systemctl set-default graphical.target # 图形用户界面 重启以生效。
暂时回到图形界面，输入命令：startx从图形界面切换回命令行：Ctrl+Alt+F7暂时回到命令行模式：Ctrl+Alt+F1从命令行切换到图形界面：Ctrl+Alt+F7 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c84a0e80000a29b1839b73a1a1d95c7/" rel="bookmark">
			FlinkCDC数据实时同步Mysql到ES
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		考大家一个问题，如果想要把数据库的数据同步到别的地方,比如es,mongodb,大家会采用哪些方案呢？ :::
定时扫描同步？
实时日志同步?
定时同步是一个很好的方案，比较简单，但是如果对实时要求比较高的话，定时同步就有点不合适了。今天给大家介绍一种实时同步方案，就是是使用flinkcdc 来读取数据库日志，并且写入到elasticsearch中。
1.什么是flinkcdc? Flink CDC（Change Data Capture）是指通过 Apache Flink 实现的一种数据变化捕获技术。CDC 可以实时捕获数据库中的数据变化，如插入、更新、删除操作，并将这些变化数据流式地传输到其他系统或存储中。通过 Flink CDC，用户可以实时监控数据库中的数据变化，并将这些变化数据用于实时分析、ETL（Extract, Transform, Load）等应用场景。Flink CDC 通常用于构建实时数据管道，帮助用户实现实时数据同步和分析。
2.flinkcdc发展趋势? 目前在github 上大概有5k 的star,也有越来越多的人使用。
3.flinkcdc有什么优势？ 说到实时同步，canal 是比较常用的方案
canal，译意为水道/管道/沟渠，主要用途是基于 MySQL 数据库增量日志解析，提供增量数据订阅和消费。 这句介绍有几个关键字：增量日志，增量数据订阅和消费。
canal的把自己伪装成MySQL slave，模拟MySQL slave的交互协议向MySQL Mater发送 dump协议，MySQL mater收到canal发送过来的dump请求，开始推送binary log给canal，然后canal解析binary log，再发送到存储目的地，比如MySQL，Kafka，Elastic Search等等。
那么 flinkcdc 和canal 对比，有什么不同呢？
这是网上的一个对比。可以看到 flinkcdc 和canal 一样，也是通过读取数据库日志的方式做到实时同步的，这个和很多实时同步的工具原理相同，比如 ogg debezium 都是这样做的，flinkcdc 的优势是基于flink 这个强大的实时计算引擎，可以做到集群部署，高可用等等，并且社区活跃，支持的平台多，像 mysql oracle mongodb 主流数据库都是支持的。而canal只支持mysql。
还有一个优势，flinkcdc 是基于java实现的，背靠大数据这个大平台，解决方案也是比较多的。源码阅读修改起来也是比较方便的。
4.一个例子 光说不练假把式，简单的写一个把mysql 数据实时同步到es的例子,使用flinksql的方式，只需要简单的几行sql
依赖
flink-1.15.0
flink-sql-connector-elasticsearch7-1.15.0.jar
flink-sql-connector-mysql-cdc-2.2.1.jar
mysql 5.7
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c84a0e80000a29b1839b73a1a1d95c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb41ce0ac80604264ee7f4410c126360/" rel="bookmark">
			python绘制直方图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		绘制直方图（Histogram）是数据可视化中常用
的一种方式，可以用来展示数据的分布情况。在Python中，你可以使用不同的库来创建直方图，最常用的是Matplotlib库。以下是一个简单的示例，演示如何使用Matplotlib库来创建直方图：
首先，确保你已经安装了Matplotlib库。如果没有安装，可以使用以下命令来安装：
pip install matplotlib
然后，可以使用以下示例代码来绘制一个简单的直方图：
import matplotlib.pyplot as plt
import numpy as np
# 生成一些随机数据作为示例
data = np.random.randn(1000)
# 绘制直方图
plt.hist(data, bins=20, color='blue', alpha=0.7)
# 添加标题和标签
plt.title('示例直方图')
plt.xlabel('值')
plt.ylabel('频数')
# 显示图形
plt.show()
这段代码中，我们首先导入Matplotlib库和NumPy库（用于生成随机数据）。然后，我们生成了一个包含1000个随机值的数据集 data。接下来，使用 plt.hist() 函数创建直方图，其中 data 是数据集，bins 是直方图的箱子数量，color 设置颜色，alpha 设置透明度。
最后，我们添加了标题和标签，然后使用 plt.show() 来显示图形。你可以根据自己的需求修改数据集和图形的样式来绘制不同的直方图。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d4f512ea0149dad0b59ac92a57c05ff/" rel="bookmark">
			节点导纳矩阵
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		节点导纳矩阵（Node Admittance Matrix）是电力系统分析中的关键工具，它用于描述电力系统中不同节点之间的电导和电纳参数。这个矩阵为电力工程师提供了深入了解电力系统运行和分析所需的数学工具。
节点导纳矩阵是一个复数矩阵，通常表示为Y，其维度为N x N，其中N是电力系统中节点的数量。每个矩阵元素Y_ij代表了节点i和节点j之间的导纳。导纳是电路中电导（G）和电纳（B）的复数形式，其中电导表示电流通过的容易程度，而电纳表示电流通过的困难程度。节点导纳矩阵的元素可以通过以下方式计算：
对于主对角线元素（i = j），Y_ii表示节点i的自导纳。它包括了该节点上的总电导和电纳。电导G_ii表示节点i的主导电流，而电纳B_ii表示节点i的感应电流。
对于非主对角线元素（i ≠ j），Y_ij表示节点i和节点j之间的互导纳。这是节点i和节点j之间的电流耦合效应。通常，这些值是负数，因为它们表示了节点之间的电流流向不同方向引起的电压差。
节点导纳矩阵在电力系统分析中发挥着重要作用，包括以下方面：
潮流分析：通过节点导纳矩阵，可以计算电力系统中各节点的电压和功率潮流。这有助于评估电力系统的稳定性和负荷分布。
短路分析：节点导纳矩阵可用于计算电力系统中的短路电流，以确保系统的设备和电缆能够承受短路条件下的电流。
电压稳定性分析：通过分析节点导纳矩阵，可以评估电力系统的电压稳定性，确保电压在可接受范围内。
网络规划：节点导纳矩阵可用于电力系统规划，包括新建电力线路、变电站和发电厂时的性能评估。
节点导纳矩阵是电力系统工程师在设计、运营和维护电力系统时的重要工具，帮助他们更好地理解电力系统中不同节点之间的相互作用和电气特性。这有助于确保电力系统的可靠性和安全性。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54ca257f29020da8ef46bd9b52ea2b99/" rel="bookmark">
			算法设计与分析 | 最大字序列和（动态规划）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目 给定一整型数列{a1,a2...,an}，找出连续子序列{ax,ax+1,...,ay}，使得该子序列的和最大，其中，1&lt;=x&lt;=y&lt;=n。
输入 第一行是一个整数N(N&lt;=10)表示测试数据的组数）
每组测试数据的第一行是一个整数n表示序列中共有n个整数，随后的一行里有n个整数I(-100=&lt;I&lt;=100)，表示数列中的所有元素。(0&lt;n&lt;=1000000)
输出 对于每组测试数据输出和最大的连续子串的和。
样例输入
1 5 1 2 -1 3 -2 样例输出
5 分析
该题求最大子序列和，因为可以输入负数，所以要考虑到结果会越加越小的情况，那么这样就并不是越长的子串就越大。所以可以使用累加的值m来判断是否要丢弃前面的字符串，如果m此刻为负数，那么丢弃前面的字串（因为负数加入只会让子序列和变小），m等于a[i]重新累加；如果m为正数则继续累加，直到求出最大子序列和。
代码
//动态规划（最大子序列和） # include &lt;stdio.h&gt; # include &lt;stdlib.h&gt; int main() { int n,m,sum=0,i,z; int a[1000]; scanf("%d", &amp;z); while (z--) { scanf("%d", &amp;n); scanf("%d", &amp;a[0]); m = sum = a[0]; for (i = 1; i &lt; n; i++) { scanf("%d", &amp;a[i]); if (m &gt;= 0) { m += a[i]; } else { m = a[i]; } if (sum &lt; m) { sum = m; } } printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/54ca257f29020da8ef46bd9b52ea2b99/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a81cd90296a6a2d5074f7671f0fc0d0/" rel="bookmark">
			第九届中国大学生程序设计竞赛桂林2023 China Collegiate Programming Contest (CCPC) Guilin Onsite (The 2nd Universal Cu
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
G. Hard Brackets Problem
I. Barkley II
K. Randias permutation task
M. Flipping Cards
补题中
G. Hard Brackets Problem 注意到，如果答案存在的话，输出串一定是一个合法输入串。可以通过模拟或者后缀和来判断无解。时间复杂度 Θ(n)。
signed main() { ios_base::sync_with_stdio(0); cin.tie(0), cout.tie(0); int T; cin &gt;&gt; T; while (T--) { string s; cin &gt;&gt; s; int cnt = 0; for (int i = 0; i &lt; s.size(); i++) { if (s[i] == '(') cnt++; else { if (cnt) cnt--; } } if (cnt) { cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a81cd90296a6a2d5074f7671f0fc0d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9bee44bc4eead020fd80e2817534301/" rel="bookmark">
			SQL:case函数的详细用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CASE 函数可以用于对数据进行复杂的条件判断和转换，在数据清洗和处理过程中具有重要的作用。它允许您根据给定的条件对一个或多个表达式进行条件判断，并返回相应的结果。分为：
1. 简单CASE函数 它的语法如下：
CASE expression WHEN value1 THEN result1 WHEN value2 THEN result2 ... ELSE result END 这里的expression是您要检查的表达式，value1、value2等是可能的值，result1、result2等是对应的结果。如果expression的值等于某个值，CASE函数将返回对应的结果。
2. 搜索CASE函数 它的语法如下：
CASE WHEN condition1 THEN result1 WHEN condition2 THEN result2 ... ELSE result END 这里的condition1、condition2等是条件，result1、result2等是对应的结果。第一个满足的条件将被返回。如果没有任何条件满足，ELSE子句中的默认结果将被返回。
3. 常见使用场景 例1： 查询班级表中的学生的班号、班名、系号和班主任号，并对系号作如下处理：
当系号为1时，显示 “计算机系”；
当系号为2时，显示 “软件工程系”；
当系号为3时，显示 “物联网系”。
简单case函数：
SELECT 班号, 班名, CASE 系号 WHEN 1 THEN '软件工程系' WHEN 2 THEN '计算机系' WHEN 3 THEN '物联网系' END AS 系号, 班主任号 FROM 班级表 搜索case函数： SELECT 班号, 班名, CASE WHEN 系号 = 1 THEN '软件工程系' WHEN 系号 = 2 THEN '计算机系' WHEN 系号 = 3 THEN '物联网系' END AS 系号, 班主任号 FROM 班级表 例2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c9bee44bc4eead020fd80e2817534301/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89eedb50210a9ebe5d7a825de036f5df/" rel="bookmark">
			SpringCloud之openFeign调用服务并传参
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、说明 服务和服务之间通信,不仅仅是调用,往往在调用过程中还伴随着参数传递,接下来重点来看看OpenFeign在调用服务时如何传递参数
二、GET方式调用服务传递参数 1.GET方式调用服务传递参数 在商品服务中加入需要传递参数的服务方法来进行测试
在用户服务中进行调用商品服务中需要传递参数的服务方法进行测试
// 1.商品服务中添加如下方法 @GetMapping("/product/findOne") public Map&lt;String,Object&gt; findOne(String productId){ log.info("商品服务查询商品信息调用成功,当前服务端口:[{}]",port); log.info("当前接收商品信息的id:[{}]",productId); Map&lt;String, Object&gt; map = new HashMap&lt;String,Object&gt;(); map.put("msg","商品服务查询商品信息调用成功,当前服务端口: "+port); map.put("status",true); map.put("productId",productId); return map; } //2.用户服务中在product客户端中声明方法 @FeignClient("PRODUCTS") public interface ProductClient { @GetMapping("/product/findOne") String findOne(@RequestParam("productId") String productId); } //3.用户服务中调用并传递参数 //注入客户端对象 @Autowired private ProductClient productClient; @GetMapping("/user/findAllFeignClient") public String findAllFeignClient(){ log.info("通过使用OpenFeign组件调用商品服务..."); String msg = productClient.findAll(); return msg; } 三、post方式调用服务传递参数 1.post方式调用服务传递参数 - 在商品服务中加入需要传递参数的服务方法来进行测试
- 在用户服务中进行调用商品服务中需要传递参数的服务方法进行测试
//1.商品服务加入post方式请求并接受name @PostMapping("/product/save") public Map&lt;String,Object&gt; save(String name){ log.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89eedb50210a9ebe5d7a825de036f5df/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e7119263f269ed0c3110f9bc09c28fe/" rel="bookmark">
			udhcpc dhcpcd 区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考：
https://forums.gentoo.org/viewtopic-t-1072758-start-0.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab3d782ffb9d99da09863c435628b535/" rel="bookmark">
			M2 Mac Xcode编译报错 ‘***.framework/‘ for architecture arm64
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		In /Users/fly/Project/Pods/YYKit/Vendor/WebP.framework/WebP(anim_decode.o), building for iOS Simulator, but linking in object file built for iOS, file '/Users/fly/Project/Pods/YYKit/Vendor/WebP.framework/WebP' for architecture arm64
这是我当时编译模拟器时报的错
1、在 Build Settings 里面先设置EXCLUDED_ARCHS，设置Any iOS Simulator SDK = arm64。
2、在 User-Defind 下面添加EXLUDED_ARCHS，设置arm64
3、在 Podfile 文件中添加一下代码
post_install do |installer| installer.generated_projects.each do |project| project.targets.each do |target| target.build_configurations.each do |config| config.build_settings['IPHONEOS_DEPLOYMENT_TARGET'] = '12.0' config.build_settings["EXCLUDED_ARCHS[sdk=iphonesimulator*]"] = "arm64" end end end end 重新 pod installer
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ed50d72b35c665d91ebc5f61f6f96ef/" rel="bookmark">
			C#特性（Attribute）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C#特性（Attribute）是一种在程序中添加元数据的机制，它可以为代码提供额外的信息和指示。通过使用特性，我们可以为类、方法、属性等元素添加标记，以便在运行时进行更多的操作和决策。
C#特性是一种声明式编程的工具，它允许开发人员通过在代码中添加特定的标记来改变程序的行为。这些标记以方括号（[ ]）包围，并放置在要修饰的元素之前。特性可以用于很多方面，例如控制程序的流程、优化性能、验证输入等。
一个常见的用途是通过特性来控制程序的流程。例如，我们可以使用条件特性（Conditional Attribute）来指定只有在特定条件下才执行某段代码。
以下是一个简单的示例，演示如何使用特性来控制程序的流程：
using System;
public class Program
{
[Conditional("DEBUG")]
private static void DebugMethod()
{
Console.WriteLine("这是调试方法");
}
private static void Main()
{
DebugMethod(); // 只有在DEBUG条件下才会执行
Console.WriteLine("程序继续执行");
}
}
在上面的示例中，我们定义了一个名为`DebugMethod`的私有方法，并使用`[Conditional("DEBUG")]`特性标记它。这意味着只有在编译时定义了名为"DEBUG"的条件编译符号时，才会执行该方法。
在`Main`方法中，我们调用了`DebugMethod`。如果我们在编译时没有定义"DEBUG"条件编译符号，那么调用将被编译器忽略，不会执行该方法。但是，如果我们在编译时定义了"DEBUG"条件编译符号（例如通过在项目属性中启用调试模式），那么调用将会被编译器包含，并且在运行时输出"这是调试方法"。
点击领取上位机编程全套入门教程+工具https://s.pdb2.com/pages/20230307/CnORDNt9HimMjNS.html
通过使用特性，我们可以根据不同的编译配置来控制代码的执行流程。这对于在调试和发布版本之间进行差异化处理非常有用，因为我们可以根据需要添加或删除特定的调试代码，而无需手动注释或取消注释它们。
总之，C#特性是一种强大而灵活的机制，可以帮助开发人员在程序中添加元数据和附加信息。.通过使用特性，我们可以改变程序的行为，优化性能，验证输入和输出，增加可读性和可维护性，并实现自定义的行为和扩展。在编写C#代码时，我们应该充分利用特性的功能，并根据需要创建自定义特性来满足特定的需求。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/098472bb9865dec443be392ebb99faee/" rel="bookmark">
			C# 导出导出操作Excel的6种方法实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在进行下面操作之前，根据选择方法不同需要下载并安装EPPlus包。EPPlus是一个开源的Excel类库，它允许我们在C#中轻松访问和修改Excel文件。可以从NuGet官网下载EPPlus包。
方法一：使用Microsoft.Office.Interop.Excel
Microsoft.Office.Interop.Excel是一个Microsoft.Office.Interop程序集，它提供一个C# API来编写Excel文件。为了能够使用它，我们需要先在项目中添加对“Microsoft.Office.Interop.Excel”的引用。
下面的代码演示了如何使用Microsoft.Office.Interop.Excel导出Excel：
using Microsoft.Office.Interop.Excel; public void ExportToExcel() { Application excelApp = new Application(); Workbook excelDoc = excelApp.Workbooks.Add(XlWBATemplate.xlWBATWorksheet); Worksheet excelSheet = (Worksheet)excelDoc.Worksheets[1]; excelSheet.Cells[1, 1].Value = "这是第一行第一列的值"; excelSheet.Cells[1, 2].Value = "这是第一行第二列的值"; excelDoc.SaveAs("C:\\Temp\\ExportTest.xlsx"); excelDoc.Close(); excelApp.Quit(); } 方法二：使用NPOI
NPOI是一个开源的.NET类库，它提供了一组用于处理Office文档的API。与Microsoft.Office.Interop.Excel相比，NPOI提供了更好的性能和更容易使用的API。
Python技术站热门推荐：
PDF电子发票识别软件，一键识别电子发票并导入到Excel中！
10大顶级数据挖掘软件！
Python 序列详解（含索引、切片）
下面的代码演示了如何使用NPOI导出Excel：
using NPOI.SS.UserModel; using NPOI.XSSF.UserModel; public void ExportToExcel() { IWorkbook excelDoc = new XSSFWorkbook(); ISheet excelSheet = excelDoc.CreateSheet("Sheet1"); IRow excelRow = excelSheet.CreateRow(0); ICell cell1 = excelRow.CreateCell(0); cell1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/098472bb9865dec443be392ebb99faee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05069f396aad3a7161b27054aa8fd8de/" rel="bookmark">
			矩阵的转置T和共轭转置H
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		矩阵 G G G 的转置 G T G^T GT和共轭转置 G H G^H GH在数学中表示不同的操作：
转置 G T G^T GT：
转置是指将矩阵的行和列互换得到的新矩阵。对于实数矩阵，转置是指将矩阵中的行变为相应的列。对于复数矩阵，转置同样是将矩阵中的行变为相应的列。在转置中，并不改变矩阵元素的值，只是改变了元素的排列方式。 共轭转置 G H G^H GH（也称为厄米共轭或埃尔米特共轭）：
共轭转置是在转置的基础上，对复数矩阵中的每个元素取复共轭。对于实数矩阵来说，共轭转置就是简单的转置操作。对于复数矩阵，共轭转置会将矩阵中的元素取复共轭，并将行列进行转置。 在复数域中，矩阵的共轭转置包含了矩阵的转置和元素的共轭操作。而在实数域中，矩阵的转置和共轭转置是相同的操作。
符号表示上的区别主要在于复数域中存在共轭操作，因此在处理复数矩阵时，转置和共轭转置的概念是不同的。在实数矩阵的情况下，两者是相同的操作。
考虑一个复数矩阵：
G = [ 1 + i 2 3 4 − i ] G = \begin{bmatrix} 1+i &amp; 2 \\ 3 &amp; 4-i \end{bmatrix} G=[1+i3​24−i​]
转置 G T G^T GT：
转置操作将矩阵的行变为列：
G T = [ 1 + i 3 2 4 − i ] G^T = \begin{bmatrix} 1+i &amp; 3 \\ 2 &amp; 4-i \end{bmatrix} GT=[1+i2​34−i​] 共轭转置 G H G^H GH：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05069f396aad3a7161b27054aa8fd8de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9bb9d5535aa40c64e667775e4d1b49b2/" rel="bookmark">
			MySQL 性能分析及索引失效
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 MySQL 性能分析及索引失效性能分析方式一：查看 sql 执行频次方式二：慢查询日志方式三：show profiles（详情）方式四：explain 执行计划 索引一、最左前缀原则二、索引失效失效场景一：失效场景二：失效场景三：失效场景四： 三、索引 - sql提示四、前缀索引五、索引设计原则六、其他 sql 优化场景一： 插入数据场景二： 主键优化场景三： order by优化场景四： group by优化场景五： limit优化场景六： count优化场景七： update优化 MySQL 性能分析及索引失效 对 mysql 进行性能分析，主要就是提升查询的效率，其中索引占主导地位。对 mysql 进行性能分析主要有如下几种方式：
性能分析 方式一：查看 sql 执行频次 show global status like ‘Com_______’; // global 表示全局
show session status like ‘Com_______’;
主要查看select、insert、update、delete四种情况，Value 表示执行的次数。如果 select 次数占大部分，也侧面的告诉了我们 sql 优化的方向，可以考虑给数据库表添加索引来提升查询效率。
方式二：慢查询日志 方式一找到了 sql 优化的方向，因此现在我们需要找到具体的慢 sql。刚好 mysql 也提供了慢查询日志，慢查询日志记录了执行时间超过指定参数（long_query_time，单位：秒。默认是10秒）的所有 sql 语句的日志，默认是没有开启的，需要我们修改配置文件。
如果是 Linux 系统下的 mysql，配置文件为：etc/my.cnf // 开启慢查询日志
slow_query_log=1
long_query_time=2 // 慢查询设置的阈值
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9bb9d5535aa40c64e667775e4d1b49b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36e486f791964501b792f7e7e24d3d0e/" rel="bookmark">
			初阶指针.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. 指针是什么？ 2. 指针和指针类型
2.1 指针的解引用 3. 野指针
3.1 野指针成因
3.2 如何规避野指针
4. 指针运算
4.1 指针+-整数
4.2 指针-指针
4.3 指针的关系运算
5. 指针和数组
6. 二级指针
7. 指针数组
1. 指针是什么？ 指针是什么？
指针理解的2个要点：
1. 指针是内存中一个最小单元的编号，也就是地址
2. 平时口语中说的指针，通常指的是指针变量，是用来存放内存地址的变量
总结：指针就是地址，口语中说的指针通常指的是指针变量。
那我们就可以这样理解：
指针变量
我们可以通过&amp;（取地址操作符）取出变量的内存其实地址，把地址可以存放到一个变量中，这个 变量就是指针变量 #include &lt;stdio.h&gt; int main() { int a = 10;//在内存中开辟一块空间 int *p = &amp;a;//这里我们对变量a，取出它的地址，可以使用&amp;操作符。 //a变量占用4个字节的空间，这里是将a的4个字节的第一个字节的地址存放在p变量 中，p就是一个之指针变量。 return 0; } 总结：
指针变量，用来存放地址的变量。（存放在指针中的值都被当成地址处理）。
那这里的问题是：
一个小的单元到底是多大？（1个字节）
如何编址？
经过仔细的计算和权衡我们发现一个字节给一个对应的地址是比较合适的。
对于32位的机器，假设有32根地址线，那么假设每根地址线在寻址的时候产生高电平（高电压）和低电
平（低电压）就是（1或者0）；
那么32根地址线产生的地址就会是：
00000000 00000000 00000000 00000000
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/36e486f791964501b792f7e7e24d3d0e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ac658d256623855ea7c8c16cf01cfca/" rel="bookmark">
			算法设计与分析 | 分治棋盘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目 在一个2^k * 2^k个方格组成的棋盘中，恰有一个方格与其他方格不同，称该方格为一特殊方格，且称该棋盘为一特殊棋盘。在棋盘覆盖问题中，要用图示的4种不同形态的L型骨牌覆盖给定的特殊棋盘上除特殊方格以外的所有方格，且任何2个L型骨牌不得重叠覆盖。 输入 第一行为k，如题意
第二行为特殊点的坐标x，y
输出 特殊点用0输出，数据间用制表符隔开(‘t’)， 要求遍历顺序按从左到右，从上到下。 样例输入
3 2 2 样例输出
3	3	4	4	8	8	9	9	3	0	2	4	8	7	7	9	5	2	2	6	10	10	7	11	5	5	6	6	1	10	11	11	13	13	14	1	1	18	19	19	13	12	14	14	18	18	17	19	15	12	12	16	20	17	17	21	15	15	16	16	20	20	21	21 分析
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ac658d256623855ea7c8c16cf01cfca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f971978d99cb013618bad838b084bedc/" rel="bookmark">
			nginx安装部署和配置（yum，编译）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Yum安装Nginx 1、nginx部署-Yum安装
访问nginx的官方网站：http://www.ngnix.org/
Nginx版本类型
Mainline version： 主线版，即开发版
Stable version： 最新稳定版，生产环境上建议使用的版本
Legacy versions： 遗留的老版本的稳定版
Yum安装nginx
首先配置nginx的yum源
配置Yum源的官网:nginx: Linux packages
1、配置nginx的Yum源 [nginx-stable] name=nginx stable repo baseurl=http://nginx.org/packages/centos/$releasever/$basearch/ gpgcheck=1 enabled=1 gpgkey=https://nginx.org/keys/nginx_signing.key [nginx-mainline] name=nginx mainline repo baseurl=http://nginx.org/packages/mainline/centos/$releasever/$basearch/ gpgcheck=1 enabled=0 gpgkey=https://nginx.org/keys/nginx_signing.key 2、使用yum源下载nginx [root@nginx-server yum.repos.d]# yum install -y nginx [root@nginx-server yum.repos.d]# nginx -V //格式化打印 nginx version: nginx/1.16.0 built by gcc 4.8.5 20150623 (Red Hat 4.8.5-36) (GCC) built with OpenSSL 1.0.2k-fips 26 Jan 2017 TLS SNI support enabled configure arguments: --prefix=/etc/nginx --sbin-path=/usr/sbin/nginx --modules-path=/usr/lib64/nginx/modules --conf-path=/etc/nginx/nginx.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f971978d99cb013618bad838b084bedc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0016e7beac91450279c800bf43acc45/" rel="bookmark">
			Win11运行慢？别急，三种解决方案帮你轻松解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		近日，许多用户反馈称Win11系统运行慢，尤其是在使用过程中会遇到卡顿、响应慢等问题。这不仅影响了用户的使用体验，还可能导致重要文件的丢失。那么，面对Win11运行慢的问题，我们该如何解决呢？今天，我们将为您提供三种解决方案，帮助您轻松解决Win11运行慢的问题。
方法一：优化系统设置
首先，我们可以尝试通过优化系统设置来提高Win11的运行速度。以下是一些建议：
关闭不必要的启动项：在任务管理器中查看开机启动项，禁用不必要的程序以减少系统启动时的负担。
清理临时文件：使用系统的磁盘清理功能，定期清理临时文件和无用程序，以释放磁盘空间。
关闭不必要的通知：在设置中关闭不必要的通知中心和系统提示，以减少干扰和提高系统运行速度。
禁用部分功能：如不需要使用Windows Hello人脸识别等功能，可以在设置中禁用以节省资源。
调整视觉效果：在系统设置中适当调整视觉效果，降低透明度、动画等效果以减少系统负担。
方法二：升级硬件设备
如果优化系统设置无法解决Win11运行慢的问题，我们建议您考虑升级硬件设备。以下是一些建议：
1.内存条升级：如果你的电脑内存不足，可以尝试升级内存条以增加系统内存容量。这将有助于提高系统的整体性能。
2.固态硬盘（SSD）升级：如果你的电脑使用机械硬盘，可以尝试将系统迁移到固态硬盘上。这将大幅提高系统的启动速度和响应能力。
3.显卡升级：如果你的电脑需要运行图形密集型应用，如游戏或视频编辑等，可以考虑升级显卡以获得更好的图形性能。
4.处理器（CPU）升级：如果你的电脑处理器性能不足，可以尝试升级更强大的处理器以提升系统性能。请注意，这可能需要您更换主板等其他硬件设备。
方法三：重新安装操作系统
如果以上两种方法都无法解决Win11运行慢的问题，我们建议您考虑重新安装操作系统。这将会清除系统中可能存在的恶意软件、病毒和垃圾文件等问题，从而让系统焕然一新。以下是重新安装操作系统的详细步骤：
在备份重要文件后，使用Windows安装盘或U盘重新启动电脑。
在安装界面中选择“自定义”选项，并选择要安装的分区（通常是C盘）。
在安装过程中，选择“格式化”分区选项以清除该分区上的所有数据。请注意，这将删除该分区上的所有文件和程序。
按照安装向导的提示完成操作系统的安装过程。在此过程中，您可以选择安装必要的驱动程序和软件包。
在安装完成后，重新配置您的网络连接、设置用户账户等信息以完成系统的初始化。
总之，Win11运行慢的问题可能是由于多种原因导致的。通过优化系统设置、升级硬件设备或重新安装操作系统等方法，我们可以有效地解决这些问题并提高系统的性能和稳定性。如果您遇到类似问题，请尝试上述解决方案并希望对您有所帮助！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de93df541a946909a921a102194012e7/" rel="bookmark">
			Java Fasn 带您谈谈——开源、闭源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✅作者简介：2022年博客新星 第八。热爱国学的Java后端开发者，修心和技术同步精进。
🍎个人主页：Java Fans的博客
🍊个人信条：不迁怒，不贰过。小知识，大智慧。
✨特色专栏：国学周更-心性养成之路
🥭本文内容：Java Fasn 带您谈谈——开源、闭源
文章目录 前言一、开源和闭源的优劣势比较二、开源和闭源对大模型技术发展的影响三、开源与闭源的商业模式比较四：处在大模型洪流中，向何处去？ 前言 开源和闭源是两种截然不同的开发模式，它们对大模型的发展具有重要影响。
首先，开源模式通过技术共享的方式，吸引了众多人才加入，推动了大模型的创新。在开源模式下，开发者可以共享代码、算法和数据集，使得更多人能够参与到大模型的开发和改进中。这种开放的合作方式促进了知识的共享和交流，加速了技术的进步。开源模式还能够激发创新，因为开发者可以基于已有的开源项目进行改进和扩展，从而推动大模型技术的不断演进。
其次，闭源模式则更加注重保护商业利益和技术优势。通过闭源模式，企业可以保护自己的核心技术和商业模式，避免技术被滥用或者被竞争对手复制。闭源模式为企业提供了更好的商业保障，使得它们能够更自由地进行商业化运作和盈利。同时，闭源模式也能够保护技术的安全性和可靠性，因为源代码不对外公开，减少了潜在的安全风险和漏洞的暴露。
开源和闭源模式在质量、安全性、产业化、适应性和可靠性等方面具有不同的优劣势。开源模式的优势在于促进技术共享和创新，加速了大模型技术的发展。开源模式还能够推动产业化和适应性，使得技术更广泛地应用于各个领域。然而，开源模式也存在一些挑战，如技术被滥用、安全性隐患和商业利益受损等。
相比之下，闭源模式更注重保护商业利益和技术优势。闭源模式能够提供更好的商业保障，使得企业能够更自由地进行商业化运作和盈利。闭源模式还能够保护技术的安全性和可靠性，避免技术被滥用或者被攻击。然而，闭源模式也可能限制技术的创新和发展，因为源代码不对外公开，开发者无法共同参与到技术的改进中。
在大模型的发展中，开源和闭源模式都有其重要性。开源模式能够促进技术共享和创新，吸引更多人才参与到大模型的开发中，推动技术的进步。闭源模式则保护商业利益和技术优势，为大模型的商业应用提供更好的保障。因此，未来的发展方向应该是在开源和闭源之间找到平衡，充分发挥两种模式的优势，推动大模型的创新和商业化应用。
一、开源和闭源的优劣势比较 开源和闭源模式在质量、安全性、产业化、适应性和可靠性等方面具有不同的优劣势。
质量：
开源：开源模式可以吸引更多的开发者参与，从而提高代码的质量。开源项目通常会经过广泛的审查和贡献者的不断改进，有助于发现和修复潜在的问题。闭源：闭源模式下，质量的控制更加集中在企业内部，可以通过严格的测试和审核流程来确保产品的质量。 安全性：
开源：开源模式下，由于代码对公众可见，可以被更多人审查和发现潜在的安全漏洞。这种透明性可以促进安全性的提升，并且问题可以更快地被发现和修复。闭源：闭源模式下，源代码不对外公开，减少了潜在的攻击者对系统的了解和攻击的可能性。但是，闭源模式也可能存在未被发现的安全漏洞，因为只有内部人员才能审查代码。 产业化：
开源：开源模式可以促进技术的产业化和普及，因为开发者可以自由地使用和定制开源项目。这有助于形成更加活跃的开发者社区和生态系统。闭源：闭源模式可以更好地保护企业的商业利益，使得企业能够更自由地进行商业化运作和盈利。闭源模式下，企业可以控制产品的定价和商业模式。 适应性：
开源：开源模式可以更快地适应不同的需求和场景，因为开发者可以根据自己的需求自由地修改和定制开源代码。这种灵活性使得开源模式更适合于个性化需求和快速迭代的场景。闭源：闭源模式下，企业可以更好地控制产品的方向和开发进度，以适应自身的战略和市场需求。这种集中的控制可以使得闭源模式更适合于稳定和长期发展的场景。 可靠性：
开源：开源模式可以通过众多开发者的参与来提高产品的可靠性。开源项目通常会经过广泛的测试和审查，问题可以更快地被发现和修复。闭源：闭源模式下，企业可以通过严格的测试和审核流程来确保产品的可靠性。企业可以对产品进行更深入的测试和优化，以提供更稳定和可靠的产品。 综上所述，开源和闭源模式在质量、安全性、产业化、适应性和可靠性等方面具有不同的优劣势。开源模式通过吸引更多开发者参与和透明的代码审查，提高了质量和安全性，并促进了产业化和适应性。闭源模式则更注重保护商业利益和技术优势，提供更好的商业保障和可靠性。在选择开源或闭源模式时，需要根据具体情况和需求综合考虑这些因素。
二、开源和闭源对大模型技术发展的影响 开源和闭源对大模型技术的发展具有不同的影响。
数据共享：
开源：开源模式可以促进数据的共享和开放，使得更多的数据可以被广泛使用。这有助于大模型技术的发展，因为更多的数据可以提供更全面和准确的训练样本，从而提高模型的性能和效果。闭源：闭源模式下，数据通常受到更严格的保护，不对外公开。这可能限制了数据的共享和使用，对大模型技术的发展产生一定的限制。 算法创新：
开源：开源模式鼓励算法的共享和创新，使得更多的开发者可以贡献自己的算法和技术。这种开放的合作方式促进了算法的不断演进和改进，推动了大模型技术的发展。闭源：闭源模式下，算法通常受到商业保密的限制，不对外公开。这可能限制了算法的创新和改进，因为只有企业内部的开发者才能参与到算法的开发和优化中。 业务拓展：
开源：开源模式可以促进技术的产业化和广泛应用，因为开发者可以自由地使用和定制开源项目。这有助于形成更加活跃的开发者社区和生态系统，推动大模型技术在不同领域的业务拓展。闭源：闭源模式可以更好地保护企业的商业利益，使得企业能够更自由地进行商业化运作和盈利。闭源模式下，企业可以控制产品的定价和商业模式，有利于商业拓展。 综上所述，开源和闭源模式对大模型技术的发展具有不同的影响。开源模式通过数据共享和算法创新的方式促进了大模型技术的发展，同时也推动了产业化和业务拓展。开源模式鼓励开发者共享和改进算法，使得技术能够不断演进和提升。闭源模式则更注重保护商业利益和技术优势，为企业的商业应用提供更好的保障。在选择开源或闭源模式时，需要综合考虑数据共享、算法创新和业务拓展等因素，以确定最适合的发展路径。
三、开源与闭源的商业模式比较 开源和闭源是两种不同的软件开发和分发模式，它们对商业模式有着不同的影响。
首先，开源软件是指源代码可以被公开查看、使用和修改的软件。开源软件的盈利模式通常基于提供增值服务，如技术支持、培训、定制开发等。开源软件的开放性和透明度吸引了大量的开发者和用户，形成了一个庞大的社区。这个社区可以为软件的改进和推广提供支持，从而增加了软件的市场竞争力。
相比之下，闭源软件是指源代码不公开的软件。闭源软件的盈利模式通常基于软件的许可证费用或订阅费用。闭源软件的商业模式更加专利和保护知识产权，因为源代码不公开，竞争者难以复制和修改软件。这种模式可以为软件开发者提供更多的控制权和利润，但也限制了用户对软件的自由使用和修改。
开源和闭源软件在市场竞争方面也有一些差异。开源软件的开放性和透明度使得用户可以更好地评估软件的质量和安全性，从而增加了用户对软件的信任度。开源软件的社区也可以为软件的改进和漏洞修复提供更快的响应。而闭源软件则更加依赖于营销和品牌建设来吸引用户。
另外，开源软件和闭源软件在用户生态方面也有所不同。开源软件的开放性和自由性吸引了大量的开发者和用户参与其中，形成了一个活跃的社区。这个社区可以共同推动软件的发展和创新。而闭源软件的用户生态相对封闭，用户的反馈和需求往往需要通过软件开发者来实现。
总的来说，开源和闭源软件的商业模式有着不同的特点和影响。开源软件注重社区和合作，通过提供增值服务来盈利；闭源软件注重知识产权保护，通过许可证费用或订阅费用来盈利。选择开源还是闭源取决于软件开发者的需求和商业策略。
四：处在大模型洪流中，向何处去？ 中国在大模型领域已经取得了一些重要的成就，例如中文预训练模型的发展和应用。在未来，中国大模型可以继续朝着以下几个方向发展：
提高模型的性能和效果：继续投入研发资源，提升大模型在语言理解、知识推理等方面的性能和效果。这可以通过更大规模的训练数据、更复杂的模型结构以及更先进的训练技术来实现。
拓展应用领域：将大模型应用于更广泛的领域，如自然语言处理、计算机视觉、语音识别等。通过在不同领域的应用中积累经验和数据，进一步提升模型的能力和适应性。
个性化和定制化：根据不同行业和用户的需求，开发个性化和定制化的大模型。这可以通过在特定领域进行针对性的训练和优化，以及与行业合作进行定制化开发来实现。
隐私和安全保护：在大模型的发展过程中，注重用户隐私和数据安全的保护。采取有效的数据脱敏、加密和权限控制等措施，确保用户数据的安全性和隐私权的保护。
促进产学研合作：加强产学研合作，推动大模型的技术创新和应用落地。通过与高校、研究机构和企业的合作，共同解决技术难题，推动大模型技术的发展和应用。
总之，中国大模型在未来可以继续加强技术研发，拓展应用领域，注重个性化和定制化，保护用户隐私和数据安全，并加强产学研合作，以推动大模型技术的发展和应用。这样可以为中国在人工智能领域的创新和发展提供更多的机遇和可能性。
码文不易，本篇文章就介绍到这里，如果想要学习更多Java系列知识，点击关注博主，博主带你零基础学习Java知识。与此同时，对于日常生活有困扰的朋友，欢迎阅读我的第四栏目：《国学周更—心性养成之路》，学习技术的同时，我们也注重了心性的养成。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2baf5702c367fb20fb7fb59e4a65d5cf/" rel="bookmark">
			【Spring】AOP进阶-JoinPoint和ProceedingJoinPoint详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 前言2. JoinPoint简介3. 获取被增强方法的相关信息4. ProceedingJoinPoint简介5. 获取环绕通知方法的相关信息6. 总结 1. 前言 在Spring AOP中，JoinPoint和ProceedingJoinPoint都是关键的接口，用于在切面中获取方法的相关信息以及控制方法的执行。它们的主要区别在于它们在AOP通知中的使用方式和功能。
2. JoinPoint简介 Joinpoint是面向切面编程（AOP）中的一个重要概念，指的是在应用程序执行过程中可以被拦截的特定点。在AOP中，Joinpoint代表了程序执行的某个具体位置，比如方法的调用、异常的抛出等。AOP框架通过拦截这些Joinpoint来插入额外的逻辑，实现横切关注点的功能。
⭐我们可以通过JoinPoint获取到除了异常参数对象和返回值之外的所有信息
示例:
可以看到JoinPoint有很多方法.我们可以使用断点调试来看这些方法是干什么用的.
在方法的参数中添加JoinPoint参数
打上断点,进行调试,可以看到JoinPoint相关参数
在这里可以调试相应的方法
例如:
当然如果觉得麻烦,也可以直接写代码进行调试,如:
JoinPoint相应的方法都可以通过这种方式来调试.由于篇幅原因这里就不过多演示了
3. 获取被增强方法的相关信息 常用方法如下:
获取方法调用时,传入的参数
Object[] args = joinPoint.getArgs(); 获取被通知的目标对象
Object target = joinPoint.getTarget(); 获取代理方法的信息
MethodSignature signature = (MethodSignature) joinPoint.getSignature(); // 获取代理方法的信息 String methodName = signature.getName(); // 获取方法名 Class&lt;?&gt; returnType = signature.getReturnType(); // 获取返回类型 Class&lt;?&gt;[] parameterTypes = signature.getParameterTypes(); // 获取参数类型数组 在这个示例中，我们首先使用joinPoint.getSignature() 方法获取代理方法的信息，然后将其转换为MethodSignature类型的对象。接着我们可以通过MethodSignature对象的方法获取方法名、返回类型、参数类型等信息，用于在通知中进行处理。
获取增强方法中返回值
@AfterReturning(value = "point()",returning = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2baf5702c367fb20fb7fb59e4a65d5cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b049f0fa214c870c4ecf830a727bd5d/" rel="bookmark">
			CTF-PWN环境搭建手册
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		工欲善其事必先利其器，作为一名CTF的pwn手，一定要有自己的专用解题环境。本文将详细记录kali下的pwn解题环境的安装过程，B站也会配备配套视频。
目录
安装前的准备工作
虚拟机环境​编辑
VM版本安装教程
1. 下载Kali的VM虚拟机文件
2. 新建一个空白文件夹
3. 解压压缩包
4.打开VMware WorkStation
​编辑 5. 配置虚拟机的硬件
6.启动虚拟机
7.kali汉化步骤
​编辑
8.换源！
9.中文输入法安装
pwn环境安装
1.pwntools安装
1、安装指令
2、测试checksec
3、测试pwntools
2.gdb动态调试安装
1、原生gdb安装
2、pwndbg安装
3、测试安装
​编辑
3.LibcSearcher安装
4.ROPGadget安装
安装前的准备工作 虚拟机环境
VMware WorkStation
VM版本安装教程 1. 下载Kali的VM虚拟机文件 Kali的VM虚拟机文件
Kali的VM虚拟机文件可在Kali官网下载
kali官网
Kali Linux | Penetration Testing and Ethical Hacking Linux Distribution
左侧Installer Images为光盘镜像文件，右侧Vitrual Machines是我们这次下载的VM虚拟机文件
点击这里下载
最后得到压缩包
2. 新建一个空白文件夹 找一个空间大点的盘，新建这个文件夹，命名就叫Kali好了
3. 解压压缩包 把第一步下载的VM虚拟机文件，解压到当前目录下
对着文件右键解压文件，选中你创建的文件夹。
等待解压完成
解压完成会得到
4.打开VMware WorkStation 点击打开虚拟机
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b049f0fa214c870c4ecf830a727bd5d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62018ea21a7557c164600460ca4d054a/" rel="bookmark">
			磁力搜索引擎大全教程，如何使用磁力链接。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		磁力链接是一种特殊的下载链接，磁力链接可以理解为一个文件识别码，而并非具体的资源地址，下载软件需要拿着这个识别码去整个互联网(DHT网络)去寻找持有该资源的用户(节点)，如果找到则可以进行传输下载。一般年代越久远的磁力链接下载成功的几率越小，因为持有该资源的节点越少。一般使用网盘下载的成功率最高，因为当第一个人下载该资源的时候一般三方网盘会将该资源存储在自己的服务器上，为以后拿着这个识别码来下载的用户直接提供下载。当然某些下载软件也会将资源存储在服务器上。
操作步骤：
第一步：百度磁力搜索大全或打开磁力搜索导航网站www.ciliso.co
第二步：进入某个磁力搜索网站搜索内容。复制搜索出来的磁力链接。
第三步：使用网盘离线下载，或直接使用下载软件下载。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a779c33de40b9926eeee42911423520d/" rel="bookmark">
			网络流问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、介绍 网络流问题是一类经典的组合优化问题，它在图论和网络分析中扮演着重要的角色。这类问题通常涉及在网络中沿着边进行资源分配的情况，如输送流体、电力传输、数据传输等。
网络流问题的模型基于一个有向图，其中节点表示资源的来源或目的地，边表示资源在节点之间的流动路径。每条边都有一个容量限制，表示该路径上能够通过的最大资源流量。
网络流问题通常有两个主要的变体：最大流问题和最小割问题。
1. 最大流问题（Maximum Flow Problem）：给定一个有向图的源节点和汇节点，每条边的容量限制，要求找到从源节点到汇节点的最大资源流量。这个问题可以用于解决许多实际应用，如数据传输网络的最大带宽问题和交通网络的最大通行能力问题。常用的解决算法有Ford-Fulkerson算法和Edmonds-Karp算法。
2. 最小割问题（Minimum Cut Problem）：给定一个有向图的源节点和汇节点，每条边的容量限制，要求找到一个割集，将图划分为源节点和汇节点两个不相交的子集，并且使割集上的边的容量和最小。这个问题可以用于寻找网络通信的瓶颈或脆弱点。常用的解决算法有Ford-Fulkerson算法和邻近顶点算法。
网络流问题还有其他变体和扩展，如多源多汇最大流问题、最小费用最大流问题、可行流问题等。这些问题在日常生活和工程领域中有广泛的应用，如交通规划、电力系统优化、通信网络设计等。
解决网络流问题的算法主要有Ford-Fulkerson算法、Edmonds-Karp算法、Dinic算法、Push-Relabel算法等。这些算法基于不同的思想和策略，通过增广路径或流量调整来逐步优化网络流。
二、寻找网络最大流的3个经典算法 1、Ford-Fulkerson算法和Edmonds-Karp算法 其中，Ford-Fulkerson算法是具有反悔功能的算法，但复杂度较大，Edmonds-Karp算法是它的一个特例，通过寻找最短路径使得复杂度减小
Ford-Fulkerson算法是一个增广路径法，用于找到网络中的最大流。算法的基本思想是不断在剩余网络中寻找增广路径，通过增加路径上的流量来增加总流量，直到无法再找到增广路径。以下是Ford-Fulkerson算法的基本步骤：
1. 初始化网络中所有边的流量为0。
2. 在剩余网络中寻找一条从源节点到汇节点的增广路径。
3. 如果存在增广路径，则通过该路径增加流量。这相当于在该路径上找到最小的剩余容量，将其作为增加的流量。
4. 重复步骤2和3，直到无法再找到增广路径。
Ford-Fulkerson算法代码：
function maxFlow = fordFulkerson(graph, source, sink) % 初始化流量矩阵为0 flow = zeros(size(graph)); % 反向图的剩余容量矩阵 residualCap = graph; while true % 利用DFS找增广路径 [path, minCapacity] = dfs(source, sink, residualCap, flow, []); % 如果无法找到增广路径，则结束循环 if isempty(path) break; end % 更新路径上的流量和剩余容量 for i = 1 : length(path) - 1 u = path(i); v = path(i+1); flow(u, v) = flow(u, v) + minCapacity; flow(v, u) = flow(v, u) - minCapacity; residualCap(u, v) = residualCap(u, v) - minCapacity; residualCap(v, u) = residualCap(v, u) + minCapacity; end end % 最大流为源节点流出的总流量 maxFlow = sum(flow(source, :)); end function [path, minCapacity] = dfs(source, target, residualCap, flow, path) % 深度优先搜索查找增广路径 % % 输入参数： % source：源节点 % target：目标节点 % residualCap：剩余容量矩阵 % flow：流量矩阵 % path：当前路径 % % 输出参数： % path：增广路径 % minCapacity：增广路径上最小的剩余容量 % 将源节点添加到路径中 path = [path, source]; % 如果当前节点等于目标节点，则说明找到了增广路径，计算最小剩余容量 if source == target minCapacity = min(residualCap(path(1:end-1), path(2:end))); % 计算增广路径上最小的剩余容量 return; % 返回 end % 遍历邻接矩阵中的所有节点 for i = 1 : size(residualCap, 1) % 如果存在一条边从当前节点到下一个节点，且剩余容量大于零且流量小于剩余容量，并且下一个节点不在当前路径中 if residualCap(source, i) &gt; 0 &amp;&amp; flow(source, i) &lt; residualCap(source, i) &amp;&amp; ~ismember(i, path) % 递归调用dfs函数搜索下一个节点 [path, minCapacity] = dfs(i, target, residualCap, flow, path); % 如果找到增广路径，则直接返回 if ~isempty(path) return; end end end % 未找到增广路径，返回空路径和最小容量为0 path = []; minCapacity = 0; end 应用代码举例
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a779c33de40b9926eeee42911423520d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c32c8d2b1cd133d0314d07c5edc5535c/" rel="bookmark">
			【已解决】错误: 找不到或无法加载主类的处理办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在同一包下创建一个Hello类发现没事，可以正常运行，对比出错的类，发现出错的类继承了某个类，所以不能在这使用main方法
public class ETLInterceptor implements Interceptor {} 解决办法就是在没有继承类的类上使用main方法就行
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad4fddf8b88b26fd8cf7a5eba7d10e50/" rel="bookmark">
			1区块链基本知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/254e99bd790b8c5dedaa16ba16c4eabe/" rel="bookmark">
			Linux CentOS 8（DHCP的配置与管理）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux CentOS 8（DHCP的配置与管理）
目录 一、项目介绍二、DHCP服务简介三、DHCP工作原理四、配置DHCP服务4.1 项目配置准备4.2 dhcpd配置文件框架与参数说明4.3 登录客户机验证4.4 客户端IP地址的释放与重新申请4.5 保留特定IP地址 一、项目介绍 当计算机中的网络变得多且复杂的时候，逐一为多台计算机去配置IP地址将会变得繁琐不堪。为了更高效地完成这项工作，工程师常会采用动态主机配置协议（Dynamic Host Configuration Protocol， DHCP）来自动为客户端配置IP地址、子网掩码和默认网关等信息。
二、DHCP服务简介 DHCP动态主机配置协议，前身是BOOTP协议，是一个局域网的网络协议，使用UDP协议工作，常用的2个端口：67(DHCP server)，68(DHCP client)，并且大部分DHCP协议通信以广播方式进行。DHCP通常被用于局域网环境，主要有两个作用：一是用于内部网或网络服务供应商自动分配IP地址，使客户端动态地获得IP地址、Gateway地址和DNS服务器地址等信息；二是给予用户以内部网管理员身份对所有计算机作集中管理的手段，并提升地址的使用率。简单来说，DHCP就是一个不需要账号密码登录的、自动给内网机器分配IP地址等信息的协议。
三、DHCP工作原理 由于在IP地址动态获取过程中采用广播方式发送报文，因此要求DHCP客户端和服务器位于同一个网段内。如果DHCP客户端和DHCP服务器位于不同的网段，则需要通过DHCP中继来中继转发DHCP报文。
通过DHCP中继完成动态配置的过程中，客户端与服务器的处理方式与不通过DHCP中继时的处理方式基本相同。下面仅以DHCP客户端与DHCP服务器在同一网段的情况为例，说明DHCP协议的工作过程。
客户端为了动态获取并使用一个合法的IP地址，需要经历以下几个阶段，如图1所示：
图1 发现阶段：即DHCP客户端通过发送DHCP Discover报文来寻找DHCP服务器并的阶段。
提供阶段：即DHCP服务器通过回复DHCP Offer报文来提供IP地址的阶段。
选择阶段：即DHCP客户端通过发送DHCP Request报文来请求某台DHCP服务器提供的IP地址的阶段。
确认阶段：即DHCP服务器通过回复DHCP Ask报文来确认所提供的IP地址的阶段。
详细过程：
1）发现阶段
在发现阶段，DHCP客户端通过发送DHCP Discover报文来寻找DHCP服务器。
由于DHCP服务器的IP地址对于客户端来说是未知的，所以DHCP客户端以广播方式发送DHCP Discover报文。广播信息中包含DHCP客户端的MAC地址和计算机名，以便DHCP服务器确定是哪个客户端所发送的请求。所有收到DHCP Discover报文的DHCP服务器都会发送回应报文，而DHCP客户端据此也可以知道网络中存在的DHCP服务器的位置。
该DHCP Discover包的源IP地址为0.0.0.0，目标IP地址为255.255.255.255。
2）提供阶段
在提供阶段，DHCP服务器通过发送DHCP Offer报文来回复DHCP客户端。
网络中接收到DHCP Discover报文的DHCP服务器，会选择一个合适的IP地址，连同IP地址租约期限和其他配置信息（如网关地址，域名服务器地址等）一同通过DHCP Offer报文发送给DHCP客户端。
DHCP服务器通过地址池保存可供分配的IP地址和其他配置信息。当DHCP服务器接收到DHCP请求报文后，将从IP地址池中取得空闲的IP地址及其他的参数，并对该IP地址做上标记，最后以广播的方式发送回客户端。
该DHCP Offer包的源IP地址为DHCP服务器的IP地址，目标IP地址为255.255.255.255。
3）选择阶段
在选择阶段，DHCP客户端通过发送DHCP Request报文给客户端请求IP地址。
如果有多台DHCP服务器同时向DHCP客户端回应DHCP Offer报文，则DHCP客户端只接受第一个收到的DHCP Offer报文。并以广播方式向这台服务器发送DHCP Request报文。该报文包含了DHCP客户端自己的MAC地址、接收的租约中的IP地址、提供此租约的DHCP服务器地址等，其他DHCP服务器将收回它们为此DHCP客户端所保留的IP地址租约，以给其他DHCP客户端使用。
该DHCP Request包的源IP地址为0.0.0.0，目标IP地址为255.255.255.255。
4）确认阶段
在确认阶段，DHCP服务器通过发送DHCP Ask报文来回应客户端。
收到DHCP客户端发送的DHCP Request请求报文后，DHCP服务器根据DHCP Request报文中携带的MAC地址来查找有没有相应的租约记录。如果有，则发送DHCP Ask报文作为应答，通知DHCP客户端可以使用分配的IP地址。
DHCP客户端收到DHCP服务器返回的DHCP Ask报文确认报文后，会以广播的方式发送ARP报文，探测是否有主机使用服务器分配的IP地址，如果在规定的时间内没有收到回应，客户端才使用此地址。否则，客户端会发送DHCP-Decline报文给DHCP服务器，通知DHCP服务器该地址不可用，并重新申请IP地址。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/254e99bd790b8c5dedaa16ba16c4eabe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1797146ac234ac03dcee22ef753f872/" rel="bookmark">
			关于程序员的税前薪资与谈薪雷区
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从税前到到手薪资,要扣掉哪些费用? 基本是个人所得税、五险一金。
个人所得税
计算公式是：综合所得（工资奖金等）-五险一金缴纳额-专项扣除-起征点5000元=个税。每月缴纳一次，以年为单位累计，然后梯度扣除，例如全年所得低于3.6万元的部分，税率3%；全年所得3.6-14.4万元的部分，税率10%；全年所得14.4万-30万元的部分，税率为20%；全年所得30万-42万元的部分，税率为25%……以此类推，个人所得越多，缴纳的税就越多。
五险：养老保险、医疗保险、生育保险、工伤保险、失业保险
养老保险是退休后国家发的“工资”，个人缴纳8%，单位缴纳20%，缴纳额越高则退休后领的钱越多；
医疗保险就是“医保”，个人缴纳2%，单位缴纳8%左右，日常看病就医可报销，自己不用额外出钱（除不可报销项）；
生育保险用于报销孕检和生产费，但也有公司有生育津贴可领，单位缴纳1%左右，男女都要缴纳；
工伤保险用于工作受伤、职业病报销，单位缴纳1%左右；
失业保险为非本人意愿的失业下，可每月领取1-2k，上限24个月，个人缴纳1%，单位缴纳2%。
一金：住房公积金
一般用于买房贷款、抵扣，现在部分城市可提取出来用于租房。个人缴纳5%-12%，单位缴纳5%-12%，具体比例由公司决定并缴纳。如果有买房需求的牛友，建议不提取公积金，因为公积金余额会影响贷款多少，用公积金贷款比商业贷款能省不少钱。
另外部分公司还会给六险二金，额外的就是补充医疗保险、企业年金等，这些都是我们签offer前需要了解清楚的。
谈薪的时候,我们需要避开哪些坑? 薪资构成
薪资是否为固定薪资，还是包含绩效和提成？如果有，则要出具详细的绩效和提成计算标准；
薪资是否包含额外补贴，如餐补、房补等；
除了薪资，是否还有额外福利，比如带薪病假、女性姨妈假等。
薪资发放时间
薪资以年薪还是月薪形式发放；
薪资发放时间，以及发放的薪资是本月还是下个月。
试用期薪资
试用期时间长短；
试用期薪资（最低为转正薪资的80%）。
年终奖
入职当年是否有年终奖；
年终奖平均几个月，比如13薪/14薪（如果offer说明13/14薪，则默认1-2个月年终）。
注：如果offer开奖了，发现薪资不符合自己的预期，我们可以和HR“讨价还价”，比如给到试用期薪资不打折、更多福利假期等。但是如果对方不肯让步，我们也可以投递其他公司作为备选。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef19355fe78b78c5edb9276ce6266795/" rel="bookmark">
			数据结构02附录01：顺序表考研习题[C&#43;&#43;]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图源：文心一言
考研笔记整理~🥝🥝
之前的博文链接在此：数据结构02：线性表[顺序表+链表]_线性链表-CSDN博客~🥝🥝
本篇作为线性表的代码补充，每道题提供了优解和暴力解算法，供小伙伴们参考~🥝🥝
第1版：无情地Push Chat GPT老师写代码、分析GPT老师写的代码并思考弱智解~🧩🧩 编辑：梅头脑🌸
参考用书：王道考研《2024年 数据结构考研复习指导》
📇目录 📇目录
🧵2010统考真题
🧩题目
🌰优解 📇优解思路
⌨️优解代码
⌨️优解演算 🌰暴力解
📇暴力解思路
⌨️暴力解代码
⌨️暴力解演算
🧵2011统考真题
🧩题目
🌰优解 📇优解思路
⌨️优解代码
⌨️优解演算 🌰暴力解
📇暴力解思路
⌨️暴力解代码
⌨️暴力解演算
🧵2013统考真题
🧩题目
🌰优解 📇优解思路
⌨️优解代码
⌨️优解演算 🌰暴力解
📇暴力解思路
⌨️暴力解代码
⌨️暴力解演算
🧵2018统考真题
🧩题目
🌰优解 📇优解思路
⌨️优解代码
🧵2020统考真题
🧩题目
🌰优解 📇优解思路
⌨️优解代码
🌰暴力解
📇暴力解思路
⌨️暴力解代码
🔚结语
🧵2010统考真题 🧩题目 设将n个整数存放到一维数组R中。设计一个在时间和空间两方面都尽可能高效的算法。将R中保存的序列循环左移p个位置，即将R的数据由(X0，X1，…，Xn-1)变换为(Xp，Xp+1，…Xn-1，X0，X1，…，Xp-1)。
🌰优解 📇优解思路 算法思想： 将数组p(n-p)转化为数组(n-p)p，(n-p)p=(p-1(n-p)-1)-1；因此分别反转前p项，后n-p项，最后整体反转p-1(n-p)-1；reverse函数用于反转数组中指定范围的元素，它通过交换两端的元素来实现反转。时间复杂度：O(n)，其中n是数组的长度，因为需要反转数组的两部分和整体数组。空间复杂度：O(1)，因为算法只使用了固定的额外空间来存储一些临时变量，与数组的长度无关。 ⌨️优解代码 #include &lt;iostream&gt; using namespace std; // 反转数组中指定范围的元素 void reverse(int arr[], int start, int end) { // 使用双指针法将数组中指定范围的元素进行反转 // start 指向要反转的范围的起始位置，end 指向要反转的范围的末尾位置 while (start &lt; end) { // 交换 start 和 end 位置的元素 int temp = arr[start]; arr[start] = arr[end]; arr[end] = temp; // 向中间移动双指针 start++; end--; } } // 执行循环左移操作 void rotateLeft(int arr[], int n, int p) { // 将左移位数取模以确保它在数组长度范围内 p = p % n; if (p == 0) return; // 如果左移位数为0，直接返回，不需要进行操作 reverse(arr, 0, p - 1); // 反转前半部分 reverse(arr, p, n - 1); // 反转后半部分 reverse(arr, 0, n - 1); // 整体反转 } int main() { const int n = 10; // 数组长度为10 const int p = 3; // 左移3位 int arr[n] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; // 初始化数组元素 rotateLeft(arr, n, p); // 执行左移操作 // 输出结果 cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef19355fe78b78c5edb9276ce6266795/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8413a33324537fbeb4e3651b630541c/" rel="bookmark">
			modbusRTU通信简单实现（使用NModbus4通信库）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文实现ModbusRTU通信，使用的是NModbus4通信库，使用 Modbus Slave是一个模拟Modbus协议从机的上位机软件，主要用于模拟测试跟其他主机设备通信的过程。与之成套存在的另一个软件--Modbus Poll，则是模拟Modbus协议主机的上位机软件。
一、了解并使用Modbus Slave和Configure Virtual Serial Port Driver软件 modbus Slave最少也要下载有Configure Virtual Serial Port Driver软件配套才能正常模拟从机和上机通信。
1.打开Configure Virtual Serial Port Driver并添加虚拟com端口，一次添加两个COM端口，
一次可以添加两个端口，我添加了com1和com2两个端口。
在电脑设备管理器-&gt;端口中查看是否新加了两个端口：
带有Virtual Serial Portd的就是模拟的COM端口
2.了解并使用Modbus Slave软件进行从机数据模拟 点击Setup配置请求信息（设置串口基本参数）
3.Modbus Slave串口参数配置详情 4.Modbus Slave连接并创建数据 点击Conntion配置连接信息，这里我知道使用RTU通信方式就好了，其他使用默认参数。
点击ok我们就连接模拟串口成功了 双击寄存器值列表就可以向指定寄存器写入值了 二、控制台项目通过NModbus4通信 1.创建控制台项目，并添加NModbus4和System.IO.Ports两个包
2.创建 SerialPort实例通信端口设置为COM1端口，SerialPort类是专用来做串口通信的 打开串口连接 向COM1端口发出请求 SerialPort serialPort = new SerialPort("COM1"); //设置串口基本参数 serialPort.BaudRate = 9600; serialPort.DataBits = 8; serialPort.StopBits=StopBits.One; serialPort.Parity = Parity.None; serialPort.Open(); 3.进行寄存器读取ReadHoldingRegisters 代表03功能码，读取输出寄存器 // 创建 Modbus RTU 客户端实例 ModbusSerialMaster master = ModbusSerialMaster.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f8413a33324537fbeb4e3651b630541c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/678ac5d27614a0e45eff3c9a50336684/" rel="bookmark">
			【网络入门】详解常用的基础网络知识（面试笔试常考内容）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1、概述
2、OSI七层模型和TCP/IP四层模型
3、数据进入TCP/IP协议栈时的封装过程
4、端口的概念
5、TCP建立连接时的三次握手
5.1、TCP头的构成
5.2、三次握手的流程说明
5.3、为什么必须使用三次握手，不能用两次握手去建立连接 5.4、SYN包攻击简介
6、TCP与UDP的区别及使用场景
6.1、TCP与UDP的区别
6.2、TCP与UDP的使用场景
6.3、使用TCP和UDP的常用协议
7、TCP的心跳检测机制与丢包重传机制
7.1、TCP心跳检测机制
7.2、TCP丢包重传机制
8、常用的网络命令
8.1、ping命令
8.2、telnet命令
8.3、ipconfig命令
8.4、netstat命令
8.5、route相关命令
8.6、arp命令
8.7、tracert命令
9、在Linux和Windows两个平台中抓包
9.1、在Windows系统中抓包
9.2、在Linux系统中抓包
10、最后
无论是软件开发人员，还是测试人员，亦或是运维人员，都需要掌握一些常用的基础网络知识，以用于日常网络问题的排查。这些基本的网络知识与概念，不仅日常工作会用到，跳槽时的笔试面试也会用到。本文结合多年来的工作实践，来详细讲述一下作为IT从业人员要掌握的一些基本网络知识。
VC++常用功能开发汇总（专栏文章列表，欢迎订阅，持续更新...）https://blog.csdn.net/chenlycly/article/details/124272585C++软件异常排查从入门到精通系列教程（专栏文章列表，欢迎订阅，持续更新...）https://blog.csdn.net/chenlycly/article/details/125529931C++软件分析工具案例集锦（专栏文章，持续更新中...）https://blog.csdn.net/chenlycly/article/details/131405795C/C++基础与进阶（专栏文章，持续更新中...）https://blog.csdn.net/chenlycly/category_11931267.html
1、概述 当前的应用系统主要分两大类，一类是C/S（Client/Server）客户端/服务器架构的，一类是B/S（Browser/Server）浏览器/服务器架构的。无论是C/S架构，还是B/S架构，客户端都需要和远端的服务器进行网络通信，进行数据交互。不需要进行网络通信的纯单机版的程序已经很少了。
PC上安装的QQ程序，就是典型的C/S架构中的客户端程序，需要和远端的服务器通信，发送和接收数据。通过在浏览器中输入淘宝的网址打开淘宝的主页，就是典型的B/S架构，浏览器通过网址向web服务器请求HTML网页在浏览器中展现出来，也是通过网络和远端的web服务器进行通信。
不仅仅客户端和浏览器需要和远端平台侧的服务器进行网络通信，平台侧部署了多台服务器，比如web服务器、业务服务器、集群服务器、负载均衡服务器，这些服务器之间也要进行网络通信。一旦通过网络进行通信，就会不可避免地出现各种网络问题或网络故障。客户端与远端的服务器之间可能有多台服务器和网路设备，比如DNS服务器、路由器、交换机、集线器等，一旦客户端与服务器之间出现网络问题和数据交互问题，就可能是多个原因引起的，需要逐步地进行排查。
我们这里讲的网络问题主要有两大类，一类是客户端与服务器无法建立连接的问题，一类是建立连接后有网络延时或严重丢包问题。至于建立通信连接后，客户端与服务器之间收发的数据内容不正确等问题，可能和网络有关，也可能是业务上存在的问题导致的。对于客户端无法和服务器建立连接，可能有多种原因，可能是客户端与服务器之间的网络是不通的，也有可能是客户端使用了错误的地址或端口，也有可能服务器侧没有开启监听端口导致的，也有可能是中间的网络设备故障了或者中间网络设备启动了部分安全规则将数据包拦截了。对于网络延时和丢包问题，可能是业务上的问题，也有可能是网络不稳定，也有可能是中间的网络设备拦截数据导致的。
对于网络不稳定的场景，比如一般在家里或公司，我们尽量使用网线连接路由器，即使用有线网络，不使用无线网络。无线网络会因为距离、信号强弱等原因，会出现网络信号弱或网络不稳定，所以走无线网络可能会导致延时或丢包，与服务器频繁断链等问题。
对于网络设备拦截数据包的场景，比如网络环境中的网络设备设置了安全规则，拦截了部分或全部数据包，再比如有些路由器会拦截SIP协议下的TCP包和UDP包。
要排查网络通信过程中遇到的一系列网络问题，需要掌握一些基础的网络知识，了解一些常用的网络命令，必要时要使用wireshark进行抓包分析。接下来我们就来具体地讲解一下这些网络知识以及常用的网络命令。
在这里，给大家重点推荐一下我的两个热门畅销专栏：
专栏1：（该专栏订阅量接近350个，很有实战参考价值，广受好评！）
C++软件异常排查从入门到精通系列教程（专栏文章列表，欢迎订阅，持续更新...）https://blog.csdn.net/chenlycly/article/details/125529931
本专栏根据近几年C++软件异常排查的项目实践，系统地总结了引发C++软件异常的常见原因以及排查C++软件异常的常用思路与方法，详细讲述了C++软件的调试方法与手段，以图文并茂的方式给出具体的实战问题分析实例，带领大家逐步掌握C++软件调试与异常排查的相关技术，适合基础进阶和想做技术提升的相关C++开发人员！
专栏中的文章都是通过项目实战总结出来的，有很强的实战参考价值！专栏文章还在持续更新中，预计文章篇数能更新到200篇以上！
专栏2： C/C++基础与进阶（专栏文章，持续更新中...）https://blog.csdn.net/chenlycly/category_11931267.html
以多年的开发实战为基础，总结并讲解一些的C/C++基础与进阶内容，以图文并茂的方式对相关知识点进行详细地展开与阐述！专栏涉及了C/C++领域的多个方面的内容，同时给出C/C++及网络方面的常见笔试面试题，并详细讲述Visual Studio常用调试手段与技巧！
2、OSI七层模型和TCP/IP四层模型 OSI七层模型和TCP/IP四层模型的构成，以及它们的对应关系如下所示：
OSI七层模型的全称为开放式系统互联通信参考模型（Open System Interconnection Reference Model），它是一种概念模型，由国际标准化组织提出，一个试图使各种计算机在世界范围内互连为网络的标准框架。OSI参考模型分为7层，分别为应用层、表示层、会话层、传输层、网络层、数据链路层和物理层。
TCP/IP的全称为传输控制协议/网际协议（Transmission Control Protocol/Internet Protocol），它是一组用于实现网络互连的通信协议，是构建Internet互联网的基础，Internet网络体系结构是以TCP/IP为核心的。基于TCP/IP的参考模型将协议分成四个层次，分别为应用层、传输层、网络层和物理链路层。也可以将物理链路层拆为两层，一个是数据链路层，一个是物理层，这样TCPIP模型就变成了五层一般我们使用的四层模型。
我们平时使用的都是TCP/IP四层模型。从wireshark中抓到的数据包中能看到每一层的数据信息，如下所示：
3、数据进入TCP/IP协议栈时的封装过程 最上面的应用层的数据，进入TCP/IP协议栈时的封装过程如下：(以TCP数据为例，与TCP/IP四层模型相对应)
经过传输层时，会加上TCP头部；经过网络层时，会加上IP头；经过数据链路层时，会加上以太网头。对于数据接收端，会按照相反的方向，将各层的头部剥离掉，最终到上层的数据就是发送端应用层的数据。
从数据发送到接收端的整个流程，可以用下图来说明（以QQ1给QQ2发一个“你好”的聊天内容为例）：
4、端口的概念 此处讲的端口是TCP或UDP通信中数字端口号，属于传输层的概念，是软件中的端口。端口号用16位整型数据来表示，端口的范围为0-65535。要进行TCP或UDP通信时，除了要有IP，必须要有端口。
操作系统会有很多默认端口，是留给指定的协议使用的，比如21是ftp协议的默认端口，80是http协议的默认端口，443是https协议的默认端口。作为接收客户端连接请求的服务器，可以设定自己的服务端口。
对于TCP，需要先绑定目标端口（调用bind），再开启对目标端口的监听（调用listen），准备接收客户端的请求，如下所示：
对于UDP，是无连接的，只需要绑定端口，不需要开启对端口的监听，如下所示：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/678ac5d27614a0e45eff3c9a50336684/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b3f2777b833af86c56ba013182b1c27/" rel="bookmark">
			完美解决 git报错fatal: unable to access ‘https://github.com/.../.git‘:Recv failure Connection was reset
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用git时，经常会碰到这个错误：fatal: unable to access 'https://github.com/.../.git':Recv failure Connection was reset。
结合我个人最近的使用经验，提供两个方法，亲测有效。
方法一 该方法也是最常见的方法，那就是在终端执行：
git config --global --unset http.proxy git config --global --unset https.proxy 方法二 本人之前在使用git时，有些时候使用方法一就能解决问题，有些时候还是会报错，下面这个方法，能够完美地解决报错。
系统设置搜索代理，然后点击编辑按钮：
打开代理服务器，端口设置为7890，这个对你正常上网没有影响，可以放心设置。然后点击保存。
然后在终端输入命令：
git config --global http.proxy http://127.0.0.1:7890 这样就大功告成了。可以在终端输入git config --global -l加以检验是否设置成功：
设置完后你就能愉快的使用git啦~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0c3e59d7ebc4630fe71d065d4060fa8/" rel="bookmark">
			案例003:基于微信小程序的教学辅助平台
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文末获取源码
开发语言：Java
框架：SSM
JDK版本：JDK1.8
数据库：mysql 5.7
开发软件：eclipse/myeclipse/idea
Maven包：Maven3.5.4
小程序框架：uniapp
小程序开发软件：HBuilder X
小程序运行软件：微信开发者
目录
前言
系统展示
教师微信端功能模块
学生微信端功能模块
管理员服务端功能界面
代码实现
登录功能实现代码
注册功能实现代码
密码重置功能实现代码
修改信息功能实现代码
删除信息功能实现代码
保存信息功能实现代码
前言 随着移动应用技术的发展，越来越多的学生借助于移动手机、电脑完成生活中的事务，许多的传统行业也更加重视与互联网的结合，由于学生学习的压力越来越大，教学辅助是一个非常不错的教育平台，对于很多冲冲刺时间紧的学生是一个非常头痛的事情，有的人可能就是查找资料也要用去半天时间，教学辅助微信小程序为了缓解学生解决问题的所在，本论文探讨利用不断发展和进步的网络技术，实现线上考试、成绩查询等主要功能模块的具体实现，最后对教学辅助进行了功能测试，并对测试结果进行了分析总结，得出教学辅助存在的不足及需要改进的地方，为以后的教学辅助维护提供了方便，同时也为今后开发类似教学辅助提供了借鉴和帮助。
教学辅助开发使系统能够更加方便快捷，同时也促使教学辅助变的更加系统化、有序化。系统界面较友好，易于操作。具体在系统设计上，客户端使用微信开发者，后台也使用java技术在动态页面上进行了设计，Mysql数据库，是一个非常优秀的教学辅助微信小程序
系统展示 教师微信端功能模块 教师注册，在教师注册页面可以填写工号、教师姓名、性别、学院、职称、电话等信息
教师登录，在教师登录页面填写账号、密码进行登录
首页、教师登录到教学辅助小程序可以查看首页、课程信息、我的等内容
我的，教师在我的页面可以查看用户信息、课程信息、课程表、成绩信息、预警信息、请假信息、考勤信息等信息进行查看
教师信息，在教师信息页面可以编辑工号、教师姓名、性别、头像、学院、职称、电话 等信息，并可根据需要进行添加、删除、修改进行保存
课程信息，教师在课程信息页面可以查看各课程信息，并可根据需要对课程信息进行搜索、新增
课程表，教师在课程表页面可以进行新增编号、班级、学号、学生姓名、课程一等等进行添加、修改、删除操作
学生微信端功能模块 学生登陆，在学生登陆页面填写学号、密码进行登陆
首页，学生通过登陆进入教学辅助界面查看首页、课程信息、我的等信息
我的，学生在我的页面可以查看课程表、成绩信息、预警信息、请假信息、考勤信息、我的收藏管理等信息
学生信息，学生在个人信息页面可以查看学号、学生姓名、性别、头像、手机、学院、专业等信息进行添加、修改、删除保存操作
课程表，学生通过页面查看课程表
请假信息，学生通过请假信息页面进行添加请假内容，需要教师进行审核
课程信息，学生通过课程信息页面可进行搜索、收藏操作
管理员服务端功能界面 管理员通过填写账号、密码、角色进行登录
管理员进入到首页界面进行查看首页、个人中心、学生管理、教师管理、课程类型管理、课程信息管理、课程表管理、成绩信息管理、预警信息管理、请假信息管理、考勤信息管理、系统管理等功能模块
学生管理，管理员在学生管理查看编辑学号、学生姓名、性别、头像、手机、学院、专业等进行详情、修改、删除操作
教师管理，管理员在教师管理查看编辑工号、教师姓名、性别、头像、学院、职称、电话 等进行详情、修改、删除操作
课程信息管理，管理员在课程信息查看课程名称、课程类型、图片、班级、课程视频、发布日期、工号、教师姓名等进行详情、修改、删除操作
预警信息管理，管理员在预警信息页面查看学生成绩信息等，可进行详情、修改、删除操作
请假信息管理，管理员在请假信息页面进行查看请假信息等，可进行审核、详情、修改、删除操作
系统管理，管理员通过系统管理页面查看公告信息等进行公告发布进行添加、删除、修改以及查看并对整个系统进行维护等操作
代码实现 登录功能实现代码 @IgnoreAuth @PostMapping(value = "/login") public R login(String username, String password, String captcha, HttpServletRequest request) { UserEntity user = userService.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b0c3e59d7ebc4630fe71d065d4060fa8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c991848928a8a4223db93abd00010f28/" rel="bookmark">
			YOLO算法（You Only Look Once）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		比如你输入图像是100x100，然后在图像上放一个网络，为了方便讲述，此处使用3x3网格，实际实现时会用更精细的网格（如19x19）。基本思想是，使用图像分类和定位算法，然后将算法应用到9个格子上。更具体一点，你需要这样定义训练标签，对于9个格子中的每一个都指定一个标签y，其中y是一个8维向量（与前面讲述的一样，分别为Pc，bx，by，bh，bw，c1，c2，c3，其中Pc=1表示含有目标，Pc=0表示为背景；c1，c2，c3表示要分类的3个目标，如行人、汽车、摩托车，不包括背景）。9个格子，每个格子都有这样一个8维的向量，对于不包含目标的格子，标签y=[0, ? , ? , ? , ? , ? , ? , ? , ?]，?表示任意值。对于包含目标的格子，YOLO算法是这样处理的，取每个对象的中心点，然后将这个对象分配给包含这个对象中心点的格子，所以下图中左边的汽车就分配到第4个格子（从左往右，从上往下数，图中绿色方框的格子），因此中间第5个格子不包含目标。对于第4个格子的目标标签是这样的：y=[1, bx, by, bh, bw, 0, 1, 0]。因此，对于任意一个格子，你都会得到一个8维输出向量，由于这里是3x3的网格，所以有9个格子，故总的输出尺寸是3x3x8。
如果你现在要训练一个输入为100x100x3的神经网络，最后会映射到一个3x3x8的输出尺寸。所以你要做的就是，有一个输入x，有对应的3x3x8的目标标签。当你使用反向传播训练神经网络时，将任意的输入x映射到这类输出向量y。
这个算法的优点是，网络可以输出精确地边界框。所以测试的时候，你做的是提供输入图像x，然后跑正向传播，直到你得到这个输出y，然后对于这里3x3位置对应的9个输出，我们就可以读出1或0。只要每个格子中目标的数量没有超过一个，这个算法应该是没有问题的；对于一个格子中存在多个对象的问题，以后再讨论。实践中，我们可能会使用更精细的19x19网格，所以就是19x19x8，这样的网格精细的多，那么多个对象被分配到同一个格子的概率就很小。另外再提一句，把对象分配到一个格子的过程是，你观察对象的中心点，然后将这个对象分配到其中心点所在的格子，所以即使对象可以横跨多个格子，也只会被分配到9个格子其中之一。
1） 神经网络输出边界框可以具有任意宽高比，并且能输出更精确的坐标，不会受到滑动窗口分类器的步长大小限制
2） 这是一个卷积实现，你并没有在3x3网格上跑9次算法，不需要让同一个算法跑9次，相反，这是单次卷积实现，但你使用了一个卷积网络，有很多共享的计算步骤，所以这个算法效率很高
事实上，YOLO算法有一个好处，因为这是一个卷积实现，它的运行速度非常快，可以达到实时识别。
另外一个小细节，如何编码这些边界框(bx, by, bh, bw)？
上面的图中有两辆车，我们有3x3网格，以右边的车为例，第6个格子有汽车，所以目标标签y中Pc=1，后面的c1，c2，c3分别为0,1,0（假设代表行人、汽车、摩托车三个类）。
在YOLO算法中，对于这个边界框，我们约定每个格子的左上角是(0, 0)，右下角坐标是(1, 1)，要指定汽车中心点（图中橙色点）的位置，bx大概是0.4，by大概是0.3，然后是边界框的高度，用格子总体宽度的比例表示，因此这个红框的宽度可能是格子宽度的90%，因此bh=0.9；它的高度大概是格子高度的一半，因此bw=0.5。.换句话说，bx，by，bh，bw单位是相对格子尺度的比例，因此bx和by必须在0和1之间，而bh，bw可能大于1。当然也有其他的约定方式。
如何判断目标检测算法运作良好？
----交并比（IoU，intersection over union），可以用来评价目标检测算法
IoU，计算两个边界框交集（图中橙色阴影部分）和并集（图中绿色阴影部分）之比，即计算交集的大小
一般情况下，在计算机视觉任务中约定，如果IoU大于或等于0.5，就说明检测正确；如果预测器和实际边界框完美重叠，那么IoU就是1。具体情况下，IoU阈值可以随具体任务进行设置。
非极大值抑制抑制NMS
目前为止，目标检测中的一个问题是，你的算法可能对同一个对象作出多次检测，非极大值抑制这个方法可以确保你的算法对每个对象只检测一次。
举个例子，假如你需要在这张图片里检测行人和汽车，你可能会在上面放19x19网格，理论上这辆车只有一个中点，所以它应该只被分配到一个格子里，而实践中当你跑目标分类和定位算法时，对每个格子都跑一次，可能会有多个格子认为对象的中心点在其自己的格子内。
因为你要在361格子上都跑一次，图像检测和定位算法，那么可能很多格子都会说我这个格子里有车的概率很高，所以当你跑算法的时候，最后可能会对同一个对象做出多次检测，如下图所示。因此非极大值抑制做的就是清理这些检测结果，这样一辆车只检测一次，而不是每辆车都出发多次检测。
所以具体上，这个算法是这样做的，首先看看每次报告，每个检测结果相关的概率为Pc。首先看概率最大的那个，在这个例子中是0.9，然后就说这是最可靠的检测，之后，非极大值抑制就会逐一审视剩下的矩形，所有和这个最大的边界框有很高交并比，高度重叠的其他边界框，那么这些输出就被被抑制，所以这两个矩形Pc分别为0.6和0.7，它们和0.9的矩形有很高的重叠度，因此这两个矩形就会被抑制。接下来逐一审视剩下的矩形，找出概率最高的那个，是左边0.8概率的那个矩形，然后非极大值抑制算法就会去掉其他IoU值很高的矩形。最后剩下的矩形框就是最终结果。
非极大值抑制意味着，你只输出概率最大的分类结果，但是会抑制那些很接近但不是最大的预测结果。
算法细节
首先在这个19x19网格上跑一下算法，你会得到19x19x8的输出尺寸，不过对于这个例子，我们简化一下，我们只做汽车检测，因此每个格子（总共19x19=361个格子）输出的预测值就是[Pc, bx, by, bh, bw]，Pc表示有对象的概率。
现在要实现非极大值抑制，你可以做的第一件事就是去掉所有的Pc值小于等于某一阈值（如0.6）的边界框，即抛弃所有概率低的边界框；接下来处理剩下的边界框，我们重复的选择概率Pc最高的边界框，然后把它输出成预测结果；接下来去掉所有剩下的边界框，所有任何没有达到输出标准的边界框，把这些和输出边界框有很高重叠面积和上一步输出的边界框有很高交并比的边界框全部抛弃，所有while循环的第二步是（上一张幻灯片变暗的那些边界框和高亮标记的边界框重叠面积很高的那些边界框抛弃掉），不停的循环，直到每个边界框都判断过了，它们有的作为输出结果，另外的就被抛弃。
上述算法是针对单个目标的情况，如果你尝试同时检测三个对象，比如说行人、汽车、摩托车，那么输出向量就会有三个额外的分量；那么正确的做法就是独立进行三次非极大值抑制，对每个类别都做一次。
Anchor Boxes
目前为止，每个格子只能检测出一个对象，如果你想让一个格子检测出多个对象，你可以使用anchor box。
假设你有这样一张图，对于这个例子，我们继续使用3x3的网格，注意行人的中心点和汽车的中心点，几乎在同一个地方，两者都落到同一个格子中，所有对于那个格子，如果y输出这个向量，你可以检测3个类，行人、汽车和摩托，它将无法输出检测结果，所以我必须从两个检测结果中选择一个。
而anchor box的思路是这样的，预先定义两个不同形状的anchor box，你要做的就是把预测结果和这两个anchor box关联起来，一般来说，你可能会用更多的anchor box，可能要5个或者更多，但是此处为了讲解方便，就用两个anchor box。你要做的就是定义类别标签，用的向量不是上面那个，而是重复两次。即为每个anchor box赋予一个与上面一样的标签y=[Pc, bx, by, bh, bw, c1, c2, c3]。因为行人的形状更类似于anchor box1的形状，而不是anchor box2的形状，所以你可以用前8个数值来预测行人。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c991848928a8a4223db93abd00010f28/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c386fe19a1144cc970af7a451da345b/" rel="bookmark">
			c&#43;&#43;【基础】排队拍照（CZOI-2011-05）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目描述 在一个美丽的景点，有N个同学想每人拍一张照片作为留念，于是他们就排好队一个一个来拍。但是呢，每个人拍照需要的时间是不同的，有些同学是在创作艺术，可能花费时间比较多，有些同学比较随意，只想证明自己到此一游而已。 考虑到排队排在后面的同学可能会等比较长的时间，为了让这个现象有所缓解，现在需要你来帮助他们找到一个排队的方案，使得所有人等待的时间总和最少。
输入 第一行包含一个整数N（N&lt;=50000），表示有N个同学想拍照；
第二行包含N个用空格隔开的整数，表示每个人拍照所需的时间T1,T2,……,Tn（0&lt;=Ti&lt;=100000）。
输出 仅有一行包含一个整数——所有人等待时间总和的最小值。
样例 输入 5 2 3 1 5 4
输出
20
提示 样例解释：
排队顺序(用每个人的编号表示)应该是 3,1,2,5,4，每个人拍照所需的时间分别是1,2,3,4,5， 这样的话每个人等待的时间分别是0,1,3, 6,10，所以总的等待时间就是0+1+3+6+10 = 20，不可能找到比这个等待时间更少的方案了。
数据范围：
15%的数据满足N&lt;=30
30%的数据满足N&lt;=100
50%的数据满足N&lt;=1000
100%的数据满足N&lt;=50000
解答 #include&lt;bits/stdc++.h&gt; using namespace std; int a[50001]; int main() { long long mi,s; int i,n; cin&gt;&gt;n; mi=0; s=0; for(i=1;i&lt;=n;i++) { cin&gt;&gt;a[i]; } sort(a+1,a+n+1); for(i=2;i&lt;=n;i++) { mi+=a[i-1]; s+=mi; } cout&lt;&lt;s&lt;&lt;endl; return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d42b8f36b7cc8927f934fed49fc49b1/" rel="bookmark">
			双机热备（负载分担热备）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、双机热备工作模式。 介绍FW支持的双机热备运行模式以及选择使用哪种工作模式。
FW支持主备备份和负载分担模式两种运行模式。
主备备份模式：两台设备一主一备。正常情况下业务流量由主用设备处理。当主用设备故障时，备用设备接替主用设备处理业务流量，保证业务不中断。
镜像模式是实现主备备份双机热备的一种特殊技术手段，主要用于DCN场景中。
负载分担模式：两台设备互为主备。正常情况下两台设备共同分担整网的业务流量。当其中一台设备故障时，另外一台设备会承担其业务，保证原本通过该设备转发的业务不中断。
2、在选择双机热备的运行模式时，请考虑以下因素。 项目说明 主备备份模式
流量由单台设备处理，相较于负载分担模式，路由规划和故障定位相对简单。
负载分担模式
相较于主备备份模式，组网方案和配置相对复杂。
负载分担组网中使用入侵防御、反病毒等内容安全检测功能时，可能会因为流量来回路径不一致导致内容安全功能失效。
负载分担组网中配置NAT时，需要额外的配置来防止两台设备NAT资源分配冲突。
负载分担模式组网中流量由两台设备共同处理，可以比主备备份模式或镜像模式组网承担更大的峰值流量。
负载分担模式组网中设备发生故障时，只有一半的业务需要切换，故障切换的速度更快。
3、VGMP组。 VGMP（VRRP Group Management Protocol）协议是华为公司的私有协议。VGMP协议中定义了VGMP组，FW基于VGMP组实现设备主备状态管理。
每台FW都有一个VGMP组，用户不能删除这个VGMP组，也不能再创建其他的VGMP组。VGMP组有优先级和状态两个属性。VGMP组优先级决定了VGMP组的状态。
VGMP组优先级是不可配置的。设备正常启动后，会根据设备的硬件配置自动生成一个VGMP组优先级，我们将这个优先级称之为初始优先级。
初始优先级：
型号初始优先级USG6000V45000USG9000V 初始优先级与接口板（vLPU）上的子卡（FPIC）个数和业务板（vSPU）上的CPU个数有关，计算公式如下：
Initial_priority = 45000 + 1000 * FPIC_Num + 2 * SPU_CPU_Num
Initial_Priority：初始优先级
FPIC_Num：接口板上的子卡个数
SPU_CPU_Num：业务板上的CPU个数
4、VGMP组四种状态。 设备自身的VGMP组优先级等于对端设备的VGMP组优先级时，设备的VGMP组状态为load-balance。
设备自身的VGMP组优先级大于对端设备的VGMP组优先级时，设备的VGMP组状态为active。
设备自身的VGMP组优先级小于对端设备的VGMP组优先级时，设备的VGMP组状态为standby。
设备没有接收到对端设备的VGMP报文，无法了解到对端VGMP组优先级时，设备的VGMP组状态为active。例如，心跳线故障。
5、负载分担热备实验。 实验拓扑： 1、FW1配置。 ##基础IP地址配置 [FW1]int g1/0/1 [FW1-GigabitEthernet1/0/1]ip add 1.1.1.1 24 [FW1-GigabitEthernet1/0/1]int g1/0/6 [FW1-GigabitEthernet1/0/6]ip add 10.10.0.1 24 [FW1-GigabitEthernet1/0/6]int g1/0/3 [FW1-GigabitEthernet1/0/3]ip add 10.3.0.1 24 [FW1-GigabitEthernet1/0/3]q —————————————————————————————————— ##将接口加入安全区域 [FW1]firewall zone trust [FW1-zone-trust]add int g1/0/3 [FW1-zone-trust]q [FW1]firewall zone dmz [FW1-zone-dmz]add int g1/0/6 [FW1-zone-dmz]q [FW1]firewall zone untrust [FW1-zone-untrust]add int g1/0/1 [FW1-zone-untrust]q —————————————————————————————————— ##配置默认路由访问外网 [FW1]ip route-static 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d42b8f36b7cc8927f934fed49fc49b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f647518f6be54a890fc1b7a49a2d344/" rel="bookmark">
			小程序开发中的底部安全区域处理技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在移动设备不断更新换代的今天，越来越多的手机开始采用全面屏设计，其中一些手机会在底部留有一定的安全区域，以适应不同型号手机的屏幕形态。在小程序开发中，如何合理处理底部安全区域，成为了开发者需要关注的重要问题。
什么是底部安全区域？ 底部安全区域是指在一些全面屏手机上，由于硬件结构的限制，屏幕显示区域并非完全覆盖整个屏幕，因此底部会存在一个类似"刘海"的凹口。这一区域被称作底部安全区域，开发者需要特别处理才能确保页面内容不被遮挡。
底部安全区域对小程序的影响 在小程序开发中，如果不合理处理底部安全区域，可能出现底部内容被遮挡的问题，严重影响用户体验。特别是对于一些底部固定按钮、底部导航栏等元素，处理不当可能导致用户无法正常操作或者内容显示不完整。
处理底部安全区域的技巧
使用 safe-area-inset-bottom 变量
如果你使用了uView组件，可以使用 safe-area-inset-bottom 变量来处理底部安全区域。通过将该变量应用到底部元素的内边距或者外边距中，可以自动适配底部安全区域，确保内容不被遮挡。 &lt;view class="footer safe-area-inset-bottom"&gt; &lt;/view&gt; 使用 uni.getSystemInfoSync()获取底部安全距离
也可以使用uniapp自带的方法 uni.getSystemInfoSync();获取底部安全距离。 // 在需要获取底部安全距离的地方调用该方法 const systemInfo = uni.getSystemInfoSync(); const safeArea = systemInfo.screenHeight - systemInfo.safeArea.bottom; // 输出底部安全距离 console.log('底部安全距离：', safeArea); 在小程序开发中，合理处理底部安全区域是保障用户体验的重要一环。通过灵活运用相关技巧和工具，我们可以很好地应对不同型号手机的屏幕形态，让页面内容在各种设备上都能够完美呈现，为用户提供更加流畅和舒适的体验。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a47d357a605e6ce48df27339d9ec7ab1/" rel="bookmark">
			Linux CentOS 8（MariaDB概述）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux CentOS 8（MariaDB概述）
目录 一、项目描述二、相关知识2.1 数据库的基本介绍2.2 数据库的分类介绍 三、项目分析3.1 安装并启动 MariaDB3.2 登录 MariaDB 数据库3.3 提高 MariaDB 安装安全性 一、项目描述 Jan16 公司为满足部门之间数据共享、减少数据冗余度和保持数据独立性等要求，需要为公司员工提供对 MariaDB 数据库的基本介绍。
二、相关知识 2.1 数据库的基本介绍 MariaDB 数据库管理系统是 MySQL 的一个分支，本章主要讲解数据库的基本概念。
MariaDB 数据库管理系统是 MySQL 的一个分支，主要由开源社区在维护，采用 GPL 授权许可 MariaDB 的目的是完全兼容 MySQL，包括 API 和命令行，使之能轻松成为 MySQL 的代替品。在存储引擎方面，使用 XtraDB 来代替 MySQL 的 InnoDB。 MariaDB 由 MySQL 的创始人 Michael Widenius 主导开发，他早前曾以10亿美元的价格，将自己创建的公司 MySQL AB 卖给了 SUN，此后，随着 SUN 被甲骨文收购，MySQL 的所有权也落入 Oracle 的手中。MariaDB 名称来自 Michael Widenius 的女儿 Maria 的名字。
MariaDB 虽然被视为 MySQL 数据库的替代品，但它在扩展功能、存储引擎以及一些新的功能改进方面都强过 MySQL。而且从 MySQL 迁移到 MariaDB 也是非常简单的：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a47d357a605e6ce48df27339d9ec7ab1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e209bd880fba1d68af7cd264b9356352/" rel="bookmark">
			WinFrom嵌入使用CefSharp（浏览器）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：CefSharp自5.2版本开始就支持AnyCpu，CefSharp需要安装的版本可对照自己.net版本安装。对照网址：GitHub - cefsharp/CefSharp: .NET (WPF and Windows Forms) bindings for the Chromium Embedded Frameworkhttps://github.com/cefsharp/CefSharp
推荐vs2015以上
一、首先安装CefSharp.WinForms，如下图：
二、安装CefSharp.Common，安装此包后会自动安装cef.redist.x64和cef.redist.x86，如果没有请手动安装。
以上的包都必须得装。
三、主要代码，下
面的代码只能执行一次，多次执行会报错。所以可放在program中。
先修改csproj文件
&lt;PropertyGroup&gt; &lt;CefSharpAnyCpuSupport&gt;true&lt;/CefSharpAnyCpuSupport&gt; &lt;/PropertyGroup&gt; 然后在program中添加此代码，也不是必须放在这里。只需要确保此代码在同一个线程中只能执行一次，随便放在哪里均可。
[STAThread] static void Main() { Application.EnableVisualStyles(); #region 加载chrome浏览器，只需要加此部分代码 AppDomain.CurrentDomain.AssemblyResolve += Resolver; LoadApp(); #endregion Application.SetCompatibleTextRenderingDefault(false); Application.Run(new srLogin()); } private static void LoadApp() {// 构建 x86 或 x64 子目录的路径 string architecture = Environment.Is64BitProcess ? "x64" : "x86"; string browserSubprocessPath = Path.Combine(AppDomain.CurrentDomain.SetupInformation.ApplicationBase, architecture, "CefSharp.BrowserSubprocess.exe"); CefSettings settings = new CefSettings { Locale = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e209bd880fba1d68af7cd264b9356352/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0368fa1928c4919b21fb945b5c3855e/" rel="bookmark">
			Ubuntu系统nfs一键挂载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、nfs简介 nfs(Network File System)网络文件系统，其基于UDP/IP使用nfs能够再不同计算机之间通过网络进行文件共享，能使使用者访问网络上其他计算机中的文件系统就像在访问自己的计算机一样。
在Linux开发过程中，我们通常在Ubuntu系统上进行代码的编写，然后将其使用交叉编译工具编译成能够被ARM处理器识别的可执行文件，要将编译好的可执行文件下载到开发板上执行，就需要建立开发板与Ubuntu的文件传输通道。
二、Ubuntu系统nfs服务器安装步骤 1、在命令行中使用如下命令安装nfs
sudo apt-get install nfs-kernel-server 2、修改nfs服务器的配置文件
sudo vi /etc/exports 打开的文件在最后一行添加如下语句：
第一个是共享文件夹的路径（看自己设置的），*代表所有客户端均可访问（可以改成ip地址或者用户名限制客户端），括号里面的东西就是客户端的权限，在此之前，需要现创建一个共享文件夹，这里我在我的家目录下的Linux目录下新建了一个nfs文件夹，新建文件夹之后还需要通过一下命令将此文件夹的权限修改为最高。
sudo chmod 777 /nfs 修改完成之后可以看到对应的文件夹变成绿色的了。
3、重启nfs服务，让配置生效
sudo service nfs-kernel-server restart 至此，服务器端就配置完成。
4、客户端安装命令
sudo apt-get install nfs-common 三、本地验证是否能挂载成功 在本地新建一个文件夹用与挂载，我这里依然选择在Linux目录下新建一个nfs_test文件夹。
使用如下命令进行挂载（这是我的目录，需要根据你的目录修改）
sudo mount -t nfs -o nolock,nfsvers=3,vers=3 192.168.1.11:/home/kekou/Linux/nfs /home/kekou/Linux/nfs_test/ 然后在使用touch命令在nfs目录下创建一个test.c文件，随后就能够在nfs_test目录下看到我们创建的test.c文件了。
四、开发板挂载Ubuntu服务器 当我们在进行驱动开发的时候，需要在Ubuntu服务器上面编写并运行代码，然后将交叉编译器编译出来的可执行文件放到开发板上执行。，这就需要频繁的在Ubuntu和开发板之前传输文件，nfs就能便于我们开发。
同样的在开发板上执行挂载命令，需要用网线将开发板和主机连起来，还要配置开发板的ip和Ubuntu的ip在同一个网段（配置ip推荐看韦东山老师的视频，个人觉得讲的非常细）
五、卸载命令 使用如下命令取消挂载，必须要到根目录下执行才能够取消成功，否则会报错设备正在忙碌。
sudo umount /home/kekou/Linux/nfs_test 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19c84b913810a24fe41c8c5a8c7f4e3b/" rel="bookmark">
			SQL-多表查询-内连接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 在SQL中，内连接（Inner Join）是一种常用的表连接操作，用于在多个表之间根据指定的条件进行匹配，并返回满足条件的行。本篇博客将详细介绍SQL内连接的概念、语法和使用场景，并通过实例演示其用法。
一、内连接是什么？ 内连接通过比较两个或多个表的列值，并返回满足连接条件的结果行。连接条件通常是两个表之间共享的列。内连接返回的结果集包含满足连接条件的行，剔除了无匹配的行。
分为隐式内连接、显式内连接。
二、内连接演示： 1.隐式内连接 SELECT 字段列表 FROM 表1, 表2 WHERE 条件 ...; 代码如下（示例）：
SELECT a.*, b.* FROM table1 a, table2 b WHERE a.common_field = b.common_field; 在此查询中，我们看到FROM子句包括两个表- table1 和 table2，WHERE子句用 a.common_field = b.common_field 来检索单个匹配条件。这条SQL语句将从表1中选择所有行，并将表1和表2中共同字段匹配的行连接起来返回。
2.显式内连接 SELECT 字段列表 FROM 表1 【INNER】 JOIN 表2 ON 条件...； 代码如下（示例）：
SELECT a.*, b.* FROM table1 a INNER JOIN table2 b ON a.common_field = b.common_field; 此查询中，我们看到使用INNER JOIN关键字来指示表的连接类型，然后使用ON来连接“a”表和“b”表之间的列“common_field” 。INNER JOIN表示要仅选择项目两个表中匹配的行。
3.比较隐式内连接和显式内连接： 隐式连接和显式连接最大的不同是书写方式。并且，在某些情况下，不同数据库管理系统可能对性能的影响也略有不同，但这种影响通常可以忽略不计。显式连接相对于隐式连接具有以下优点：
可以明确表之间的关系。我们不必推测两个表之间的连接条件。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/19c84b913810a24fe41c8c5a8c7f4e3b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f33d65d3c194948dbae2052737ce5ee0/" rel="bookmark">
			双机热备（主备备份）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、双机热备简介。 FW部署在网络出口位置时，如果发生故障会影响到整网业务。为提升网络的可靠性，需要部署两台FW并组成双机热备。
双机热备需要两台硬件和软件配置均相同的FW。两台FW之间通过一条独立的链路连接，这条链路通常被称之为“心跳线”。两台FW通过心跳线了解对端的健康状况，向对端备份配置和表项（如会话表、IPSec SA等）。当一台FW出现故障时，业务流量能平滑地切换到另一台设备上处理，使业务不中断。
双机热备典型组网图：
2、心跳线。 双机热备组网中，心跳线是两台FW交互消息了解对端状态以及备份配置命令和各种表项的通道。心跳线两端的接口通常被称之为“心跳接口”。
心跳线主要传递如下消息：
心跳报文（Hello报文）：两台FW通过定期（默认周期为1秒）互相发送心跳报文检测对端设备是否存活。
VGMP报文：了解对端设备的VGMP组的状态，确定本端和对端设备当前状态是否稳定，是否要进行故障切换。
配置和表项备份报文：用于两台FW同步配置命令和状态信息。
心跳链路探测报文：用于检测对端设备的心跳口能否正常接收本端设备的报文，确定是否有心跳接口可以使用。
配置一致性检查报文：用于检测两台FW的关键配置是否一致，如安全策略、NAT等。
上述报文均不受FW的安全策略控制。因此，不需要针对这些报文配置安全策略。
3、心跳线和心跳接口的配置建议。 心跳接口的连线方式可以是直连，也可以通过交换机或路由器连接。建议将组成双机热备的两台FW安装在同一个机架或者相邻的机架上，心跳接口使用网线或者光纤直连。
建议规划专门的接口作为心跳接口，该接口只用来发送心跳报文、备份报文等双机热备功能相关的报文，不要将业务报文引导到该接口上转发。同时，建议将多个以太网接口绑定成Eth-Trunk接口，使用Eth-Trunk作为心跳接口。这样既提高了链路的可靠性，又可以增加备份通道的带宽。
对于USG9000V系列设备，vLPU上的接口均可作为心跳接口。请安装多个vLPU，并将不同接口板上的以太网接口绑定成Eth-Trunk接口，使用该Eth-Trunk接口作为心跳接口。
心跳接口需要发送业务相关的表项备份报文，心跳接口的流量大小与业务流量大小有关。心跳接口的带宽建议不低于峰值业务流量的30%。
建议至少配置2个心跳接口。一个心跳接口作为主用，另一个心跳接口作为备份。
4、心跳线和心跳接口的配置注意事项。 MGMT接口（GigabitEthernet0/0/0）不能作为心跳接口。
配置了vrrp virtual-mac enable命令的接口不能用作心跳接口。
两台FW心跳接口的类型、接口编号、链路协议类型必须相同。如果使用Eth-Trunk接口作为心跳接口，Eth-Trunk接口的成员接口也要相同。如果使用VLAN接口（VLANIF）作为心跳接口，实际收发报文的二层物理接口也必须相同。
两台FW心跳接口必须加入相同的安全区域。
接口MTU值小于1500的接口不能作为心跳接口。
配置和表项备份报文的最大长度为1500字节，且报文不支持分片。如果心跳接口MTU值小于1500，会导致报文发送失败。
心跳接口通过交换机或路由器连接时，交换机或路由器上转发心跳报文和备份报文的接口的MTU值不能小于1500。
如果FW上配置了虚拟系统，心跳接口不能是虚拟系统的接口，必须是根系统的接口。虚拟系统的配置命令和表项也能通过规划在根系统的心跳接口备份到对端设备。
5、主备备份实验。 实验拓扑： 1、FW1配置。 ##基础IP地址配置 [FW1]int g1/0/1 [FW1-GigabitEthernet1/0/1]ip add 10.2.0.1 24 [FW1-GigabitEthernet1/0/1]int g1/0/6 [FW1-GigabitEthernet1/0/6]ip add 10.10.0.1 24 [FW1-GigabitEthernet1/0/6]int g1/0/3 [FW1-GigabitEthernet1/0/3]ip add 10.3.0.1 24 [FW1-GigabitEthernet1/0/3]q —————————————————————————————————— ##将接口加入安全区域 [FW1]firewall zone trust [FW1-zone-trust]add int g1/0/3 [FW1-zone-trust]q [FW1]firewall zone dmz [FW1-zone-dmz]add int g1/0/6 [FW1-zone-dmz]q [FW1]firewall zone untrust [FW1-zone-untrust]add int g1/0/1 [FW1-zone-untrust]q —————————————————————————————————— ##配置默认路由访问外网 [FW1]ip route-static 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f33d65d3c194948dbae2052737ce5ee0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df47d40bf3ea87d30c0bd9aefe9a6c5e/" rel="bookmark">
			vscode 设置提示 @ 路径 和 ~@ 路径 和 使用 prettier 一直把大写的PX转换成小写解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 vscode 设置提示 @ 路径 和 ~@ 路径vscode 使用 prettier 一直把大写的PX转换成小写解决办法 vscode 设置提示 @ 路径 和 ~@ 路径 菜鸟最近用公司的电脑开发，结果发现之前有的路径提示全没了，感觉非常难受，然后去插件一看才发现，好像是菜鸟自己不小心把这个插件给删了
有点难受！
但是安装了这插件还是有点不好用，就是感觉每次使用了 vue 的 @ 或者 ~@ 开头的路径时，总是没有提示，所以今天菜鸟心一横决定解决！先去群里问了，才知道原来要使用配置文件 jsconfig.json
这里就不说废话了，直接上才艺！
1、首先需要下载上面的插件
2、在vscode中找到设置，并点击 在 setting.json 中编辑
添加如下配置：
"path-intellisense.mappings": { "@": "${workspaceRoot}/src", "~@": "${workspaceRoot}/src" }, 3、在自己的项目下新建 jsconfig.json
并添加如下配置：
4、重启 vscode
然后你就可以享受极致的开发体验了！！！
vscode 使用 prettier 一直把大写的PX转换成小写解决办法 .fromname { /* prettier-ignore */ font-size: 40PX; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01f1378e8927171ab95b32749ce5a0fd/" rel="bookmark">
			mybatisplus新增id
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		protected void populateKeys(TableInfo tableInfo, MetaObject metaObject, Object entity) {
IdType idType = tableInfo.getIdType();
String keyProperty = tableInfo.getKeyProperty();
if (StringUtils.isNotBlank(keyProperty) &amp;&amp; null != idType &amp;&amp; idType.getKey() &gt;= 3) {
IdentifierGenerator identifierGenerator = GlobalConfigUtils.getGlobalConfig(this.configuration).getIdentifierGenerator();
Object idValue = metaObject.getValue(keyProperty);
if (identifierGenerator.assignId(idValue)) {
if (idType.getKey() == IdType.ASSIGN_ID.getKey()) {
Class&lt;?&gt; keyType = tableInfo.getKeyType();
if (Number.class.isAssignableFrom(keyType)) {
Number id = identifierGenerator.nextId(entity);
if (keyType == id.getClass()) {
metaObject.setValue(keyProperty, id);
} else if (Integer.class == keyType) {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/01f1378e8927171ab95b32749ce5a0fd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0142da462ec820c409855a9d10ca1b0/" rel="bookmark">
			【带帽子的相关】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在马克思主义产生之前，唯物主义和唯心主义、辩证法和形而上学、可知论和不可知论的对立就已经存在，马克思主义产生之后，创造了唯物史观，开始了唯物史观和唯心史观的对立
社会意识是具体的、历史的，不论怎么发展和变化，其根源总是深藏于经济事实之中
社会存在是社会意识的客观来源，社会意识是社会物质生活的主观反映
社会存在决定社会意识，社会意识随着社会存在的变化而变化，不是自主变化
社会意识是人类进行物质交往的产物，社会存在决定社会意识，社会意识依赖于社会存在
生产关系是人们在物质生产中发生的"物质的社会关系"
物质生产活动和生产方式是人类社会赖以存在和发展的基础，是人类其他一切活动的首要前提
人与自然相互依赖，互为存在的前提 X 因为：自然界先于人类存在，不可能以人为前提
生产关系不是指人与自然的关系，而是人与人的关系，但不是人与人之间一般的社会关系，而是人与人之间的经济关系，即物质利益关系
经济基础决定上层建筑，上层建筑反作用于经济基础，上层建筑反作用的性质取决于它所服务的经济基础的性质
生产方式是社会历史发展的决定力量
物质资料的生产方式是社会存在和发展的基础和决定力量
社会历史是具体的，历史的
物质实践是人类最基本的实践活动，解决人与自然的矛盾
本质和现象相互依存，则不表现为现象的本质和不表现为本质的现象都是不存在的
本质决定现象，现象表现为本质
劳动者是生产力中最活跃的因素
生产力是社会进步的根本内容，是衡量社会进步的根本尺度
生产力决定生产关系，两者中，生产力占支配地位，起决定作用
**有什么样的生产力就有什么样的生产关系：**生产力状况决定生产关系的性质，生产力状况是生产关系形成的客观前提和物质基础，
生产力表现的是人与自然的关系
经济基础的性质由占支配地位的生产关系的性质决定
国家不是从来就有的，它是社会发展到一定历史阶段的产物(历史范畴)，是阶级矛盾不可调和的产物
国家的实质是一个阶级统治另一个阶级
有什么样的经济基础就有什么样的上层建筑：
经济基础的性质决定上层建筑的性质，
经济基础的变更必然引起上层建筑的变革，并决定变革的方向
上层建筑是否需要变革以及变革的方式形式和方向，都取决于经济基础的状况
矛盾这玩意贯穿始终，即使是共产主义社会，矛盾也依旧存在，和谐只是矛盾的一种特殊表现形式
生产方式的发展和变革，是世界历史形成和发展的基础
社会的发展和发展集中表现为：社会形态的更替
普遍交往是世界历史的基本特征
生产关系的变革、社会制度的更替，取决于生产力的发展，但不是自发的实现和完成，而是由人民群众推动
历史前进的总趋势是不可改变的
只有推动历史向前发展的力量才属于历史的创造者，阻碍的力量不属于
任何历史人物的出现都体现了必然性和偶然性的统一
人们创造自己的历史 ✔ 人人创造历史 X 因为：只有推动历史向前发展的力量才属于历史的创造者
历史人物的作用性质取决于：人们的思想、行为是否符合社会发展规律、是否符合人民群众的意愿
劳动是社会财富的源泉之一，不是唯一源泉
垄断高价和垄断低阶是垄断组织为了获得最大限度的利润规定的市场价格，二者之间不存在相抵的关系
商品的价格总是围绕商品的价值自发波动，价格高于价值的部分和价格低于价值的部分能够相互抵消，商品的平均价格和价值是一致的
劳动力的使用价值是价值的源泉，其他商品不是
资本积累是资本主义社会失业现象的根源
影响资本周转的两个因素：1、资本周转时间 2、生产资本中固定资本和流动资本的构成
资本周转速度加快，周转时间就可以缩短，两者成反比
要加快流动资本的周转速度，可以通过加快资本周转速度获得
个性和共性、一般和个别、矛盾的普遍性和特殊性看做是一个层面，整体和部分看作是一个层面，选择题中出现二者都为正确答案的可能性很低
世界的二重分化：从自然界中分化出人类社会、从客观世界中分化出主观世界
理想的特征：实践性、时代性、超越性
信念的特征：支撑性、多样性、执着性
时空：
时空既是相对的，又是绝对的 时间具有一维性，空间具有三维性 联系：
联系具有条件性、普遍性、客观性、多样性 事物的联系可分为自在事物的联系和人为事物的联系 实践和认识
实践是认识的根本目的 实践是认识的来源 认识指导实践，正确的和错误的认识都可以指导实践，只是起的作用不一样 商品：
商品的二因素：使用价值和价值 使用价值在质上是不一样的，不同的商品具有不同的使用价值 使用价值是个永恒的范畴 商品是历史范畴，与社会发展阶段相联系，并不是从来都有的（原始社会没有，到了共产主义社会也将消失） 价值是交换价值的基础，交换价值是价值的表现形式，价值和交换价值的矛盾就是：价值和其表现形式的矛盾 商品是价值和使用价值的矛盾统一体 商品是用来交换能满足人类某种需要的产品 使用价值是价值的物质承担者，使用价值是交换价值的物质承担者 价值寓于使用价值之中，价值是交换价值的基础 交换价值是价值的表现形式 价值的存在以使用价值的存在为前提，所以：有价值的一定有使用价值 商品的价值实体是：凝结在商品中的无差别的一般人类劳动(抽象劳动)，而不是使用价值 商品的价值总量是不变的 价值总量 = 使用价值(商品数量) * 单位商品的价值量(1件商品的价值量) 劳动生产率提高，生产的商品数量就多(使用价值增加)，商品总量不变，那单位商品的价值量就要减少 商品一定是劳动产品，劳动产品却不一定是商品 劳动
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a0142da462ec820c409855a9d10ca1b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f6874a8f072e781c260edcd930867fc/" rel="bookmark">
			MySQL | 数据库的表的增删改查【进阶】【万字详解】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL | 数据库的表的增删改查【进阶】【万字详解】 文章目录 MySQL | 数据库的表的增删改查【进阶】【万字详解】系列文章目录本节目标：数据库约束约束类型NULL约束UNIQUE：唯一约束DEFAULT：默认值PRIMARY KEY：主键FOREIGN KEY：外键CHECK 表的设计新增查询聚合查询聚合函数内连接外连接自连接子查询合并查询 内容重点总结 系列文章目录 第一章：MySQL | 数据库的管理和操作(基本介绍)
第二章：MySQL | 数据库的基本操作和表的基本操作
第三章：MySQL | 数据库的表的增删改查
第四章：MySQL | 数据库的表的增删改查【进阶】
前言：
在前面我们已经学了数据库的增删查改（初阶），还没有学习的同学可以点击上面的连接进行跳转学习~~本章就来学习数据库的进阶，让我们来一起走进吧~~ 本节目标： 数据库约束表的关系删除修改查询 数据库约束 约束，就是数据库针对里面的数据能写啥，给出的一组"检验规则"这样的约束，可以是程序猿人工来保证的，也可以是程序自动保证的约束，就是为了提高效率，提高准确性，让数据库这个软件集成一个针对数据效验的功能 约束类型 NOT NULL - 指示某列不能存储 NULL 值。UNIQUE - 保证某列的每行必须有唯一的值。DEFAULT - 规定没有给列赋值时的默认值。PRIMARY KEY - NOT NULL 和 UNIQUE 的结合。确保某列（或两个列多个列的结合）有唯一标识，有助于更容易更快速地找到表中的一个特定的记录。FOREIGN KEY - 保证一个表中的数据匹配另一个表中的值的参照完整性。CHECK - 保证列中的值符合指定的条件。对于MySQL数据库，对CHECK子句进行分析，但是忽略CHECK子句。 NULL约束 创建表时，可以指定某列不为空：
在没有约束的时候，此时表中可以插入空值！！！ create table student(id int,name varchar(20)); insert into student values(null,null); 这里我们重新创建一个表，设置成不能为空 create table student (id int not null, name varchar(20) not null); 非空约束也就生效了~~ UNIQUE：唯一约束 插入/修改数据的时候，会先查询，先看看数据是否已经存在，如果不存在，就能插入/修改成功，如果存在，则插入/修改失败！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f6874a8f072e781c260edcd930867fc/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/58/">«</a>
	<span class="pagination__item pagination__item--current">59/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/60/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>