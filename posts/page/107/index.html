<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78dee721d8781b7245811390056eac4c/" rel="bookmark">
			解决前端请求携带Long类型数据精度丢失的两种方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
场景:
1.使用Springboot带的@JsonFormat,指定序列化和反序列化过程中要转换成的传输的类型 2.自定义对象映射器，实现全局的映射，管理全局的序列化和反序列化
①首先创建自定义的JacksonObjectMapper类(因为Jackson 是 Spring Boot 默认使用的对象映射器，通过配置 JacksonObjectMapper 类，可以定制 Jackson 的行为，以满足特定的序列化和反序列化需求。)
②写配置类封装成Bean
总结:
场景: 我们在设计数据库id的时候，会(使用MybatisPlus)使用雪花算法生成的Long类型数据作为主键id，但是当前端发送请求携带的数据中有19位Long类型数据，他只能保证16位有效，最后3位会舍入，导致精度丢失。
1.使用Springboot带的@JsonFormat,指定序列化和反序列化过程中要转换成的传输的类型 比如我这里想让我的 Long类型的 id 在传输过程中使用String类型，这样精度不会丢失，操作如下：
同理，对于其他的类型，你也可以使用该注解指定，不过这样要一个一个加，比较繁琐，一不小心可能就漏了，下面有另一种方式
2.自定义对象映射器，实现全局的映射，管理全局的序列化和反序列化 ①首先创建自定义的JacksonObjectMapper类(因为Jackson 是 Spring Boot 默认使用的对象映射器，通过配置 JacksonObjectMapper 类，可以定制 Jackson 的行为，以满足特定的序列化和反序列化需求。) 代码如下：
package com.itheima.reggie.common; import com.fasterxml.jackson.databind.DeserializationFeature; import com.fasterxml.jackson.databind.ObjectMapper; import com.fasterxml.jackson.databind.module.SimpleModule; import com.fasterxml.jackson.databind.ser.std.ToStringSerializer; import com.fasterxml.jackson.datatype.jsr310.deser.LocalDateDeserializer; import com.fasterxml.jackson.datatype.jsr310.deser.LocalDateTimeDeserializer; import com.fasterxml.jackson.datatype.jsr310.deser.LocalTimeDeserializer; import com.fasterxml.jackson.datatype.jsr310.ser.LocalDateSerializer; import com.fasterxml.jackson.datatype.jsr310.ser.LocalDateTimeSerializer; import com.fasterxml.jackson.datatype.jsr310.ser.LocalTimeSerializer; import java.math.BigInteger; import java.time.LocalDate; import java.time.LocalDateTime; import java.time.LocalTime; import java.time.format.DateTimeFormatter; import static com.fasterxml.jackson.databind.DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES; /** * 对象映射器:基于jackson将Java对象转为json，或者将json转为Java对象 * 将JSON解析为Java对象的过程称为 [从JSON反序列化Java对象] * 从Java对象生成JSON的过程称为 [序列化Java对象到JSON] * * 如果想生效，可以在增加配置类，然后封装成Bean */ public class JacksonObjectMapper extends ObjectMapper { public static final String DEFAULT_DATE_FORMAT = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/78dee721d8781b7245811390056eac4c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2224bafced49d98a4bc9759ac5c96460/" rel="bookmark">
			hadoop集群启动唯独缺少DataNode进程的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目场景： 当Hadoop因为各种原因导致需要快照或重新配置，进入到最后一步格式化过后，开启集群发现主机进程一切正常，从节点其他进程也都有，唯独datanode进程没有的情况。
主机启动集群显示一切正常，主机的进程也全部出来，如图所示
但是从节点，例如我的2到4从节点，拿第二个从节点的图来看，进程除了datanode，都是正常的
原因分析： 可能是因为两次甚至多次的格式化导致的
解决方案： 我们可以找到datanode的资料，VERSION文件，然后把所有用到datanode进程的节点上面的VERSION都删除，再在主机上重新进行格式化，再次使用jps，datanode进程就可以出来了。
因为每个人的Hadoop放在不同文件，所以根据自己的配置文件所放的地方，去寻找version文件，我的Hadoop放在opt文件下面，所以我在opt下面去找
在xshell中去到VERSIONWEN文件所在的地址使用rm命令把VERSION文件删除，注意：
所有要用到datanode的从节点都要删除（拿完全分布来说，除了主机都要删除）下图是从节点删除VERSION文件后，主机已经重新格式化后，开启集群，使用jps的丛节点截图
总结：解决步骤
1.找到datanode有关资料文件的存放地址
2.把需要用到datanode进程的节点上的VERSION文件删除
3.对主机重新进行格式化，开启集群，jps命令查看是否解决问题（注意格式化需要谨慎，建议先快照）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0e32f5eda731fc0632c7ec794210763/" rel="bookmark">
			【C语言项目】扫雷（详解，附图、附代码示范）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 项目思路一、分文件进行创建二、进入游戏前的目录2.1 目录的功能：2.2 目录界面：2.3 选择进入或退出游戏2.3.1 代码示范2.3.2 图片示例： 三、画出游戏界面3.1 创建两个数组3.2 初始化数组3.3 打印游戏界面3.3.1 代码思路3.3.2 代码示范： 四、用随机值放雷4.1 代码思路：4.2 代码示范： 五、游玩扫雷5.1 代码思路：5.2 注意事项：5.3 代码实现： 六、整体代码示范game.htest.cgame.c 写在最后 项目思路 分文件进行创建进入游戏前的目录画出游戏界面用随机值放雷游玩扫雷 接下来，我们分步骤进行详细的解释说明。
一、分文件进行创建 在具体的项目实施中，我们需要分成不同的文件进行创建和书写，以此来保证项目的模块化。
那么在扫雷的实际书写中，
源文件： 测试游戏用的代码文件用test.c或者日期.c来作为文件名游戏实现的底层代码用game.c文件作为文件名 头文件 游戏实现中使用的各个函数的声明，以及包含的其他库函数的头文件需要写在头文件game.h文件里
如图所示：
二、进入游戏前的目录 2.1 目录的功能： 在游戏开始时，给玩家视觉上的帮助和提示让玩家可以选择进入游戏或者退出游戏将游戏形成一个可以不断重玩的循环
接下来，我们分步骤进行书写： 2.2 目录界面： void menu() { printf("***********************\n"); printf("*****1、开始游戏*******\n"); printf("*****0、退出游戏*******\n"); printf("***********************\n"); } 接着，在main函数里面进行调用：
int main() { menu(); return 0; } 这样目录的表面就写好了，接下来需要写玩家选择进入游戏和退出游戏的功能了
2.3 选择进入或退出游戏 选择功能的逻辑：1进入游戏，0退出游戏。
显然，必备的库函数有scanf，switch、case和default。为了让游戏的体验更加良好，可以再加一个printf增加视觉上的游玩帮助，用户友好。
那么根据刚刚的逻辑，可以写出如下的选择结构，其中game函数虽然还没有写出来，但是整体的框架可以先确定下来，之后再往里慢慢写内容。
2.3.1 代码示范 int main() { int input = 0; menu(); printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b0e32f5eda731fc0632c7ec794210763/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d11f5ace698b6bc87974c3611a9d7fb/" rel="bookmark">
			为什么ES里的日期查询总是差8个小时
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、前言 我们在做 Java 开发过程中其实很少关心时区的问题，因为这个一般都使用系统默认的东八区了，所以在存储时间和查询时间时感觉不到时区的存在，以及可能会发生的问题。但是有 ES（Elasticsearch）开发经验的朋友可能或多或少都遇到或者处理过 ES 中的日期类型的时区问题，当遇到此类问题时可能也会很快解决，因为网上教程很多，如何设置、如何指定日期格式，等等，但是并不见得会深度研究。
当然，对于一个一直对时区、什么GMT+8、UTC总是一知半解的我来说，总是感觉这类问题像迷一样的存在，于是乎，在网络搜集各种相关知识，今天做一个知识总结与分享，希望能帮到与我有类似疑惑的朋友们。
2、时区、GMT、UTC、 润秒、Asia/Shanghai、UNIX时间戳 为什么要把时区、GMT、UTC、Asia/Shanghai、UNIX 时间戳这几块内容写在同一段落里呢？其实，在写该篇文章的时候我是列了提纲的，是把这三块分开的，但是后来写的过程中感觉他们不能割裂开，他们是一个整体的知识部分，所以就把这相关的内容整在了一起。
纬线：
是指地球表面某点随地球自转所形成的轨迹。所有的纬线都相互平行，并与经线垂直，纬线指向东西方向。纬线形状为圈。纬线圈的大小不等,赤道为最大的纬线圈,从赤道向两极纬线圈逐渐缩小,到南、北两极缩小为点。
经线：
也称为“子午线”，是地球表面连接南、北两极，并且垂直于赤道的弧线。经线和纬线一样是人类为度量方便而假设出来的辅助线，定义为在地球仪表面连接南北两极并垂直于纬线的半圆。
本初子午线：
国际上将通过英国伦敦格林尼治天文台原址的那条经线称为0°经线，也叫本初子午线。
时区：
众所周知，地球是一个球体，并自西往东自转，每自转一周是24小时整，每个地区的人们的习惯都是以当地的午夜作为新的一天的开始（举个反例，例如，我们所有人都不习惯以当地正午以前是13号，过了正午就变成14号。都习惯一整个白天是同一个日期，这就是为什么全球不统一用一个时区来表示时间的原因。），为了克服时间上的混乱，1884年在华盛顿召开的一次国际经度会议（又称国际子午线会议）上，规定将全球划分为24个时区（东、西各12个时区）。规定英国（格林尼治天文台旧址）为中时区（零时区）、东1—12区，西1—12区。规定，格林尼治天文台旧址那条铜线为本初子午线，本初子午线以东为东时区，本初子午线以西为西时区，每个时区横跨经度15度，时间正好是1小时。最后的东、西第12区各跨经度7.5度，以东、西经180度为界。每个时区的中央经线上的时间就是这个时区内统一采用的时间，称为区时，相邻两个时区的时间相差1小时。
时区重点概念：
时区是一个东西跨15°的一个经度范围，每个时区都有一个中央子午线，区时是指该时区的中央经线（即中央子午线）的时间，0时区的中央经线就是本初子午线，0时区横跨西经7.5°+东经7.5°，0时区的时间就是以本初子午线的时间作为标准时间的。
GMT：
是指英国格林尼治所在地的标准时间，也即世界时间，以地球自转作为参考标准的一种时间计时标准。
UTC：
即世界协调时，又称世界统一时间，协调世界时是以原子时秒长为基础（以铯原子的震动周期作为参考），在时刻上尽量接近于世界时的一种时间计量系统。
UTC和GMT的关系：
参考：UTC和GMT什么关系？ - 知乎
润秒：
由于世界时间是以地球自转为参考的，现在观测到地球自转是每年都在变慢零点几秒，所以相当于我们的时间和地球自转隔几年后就不一致了，根据世界协调时间，在适当的时候将世界时间加1秒，相当于让我们的表都再等地球1秒钟，这样地球自转的时刻和我们的表都同步了
UNIX时间戳：
是指从格林尼治时间的1970年1月1日 00:00:00开始所经过的妙数，不考虑润秒。
重点：是指从格林尼治时间的1970-01-01 00:00:00开始计数的秒数，注意，GMT 1970-01-01 00:00:00是北京时间(Asia/Shanghai)的 1970-01-01 08:00:00
举例：GMT 的 1970-01-01 00:00:00 UNIX时间戳是 0，北京时间的 1970-01-01 00:00:00 的 UNIX 时间戳是 -28800000，北京时间的 1970-01-01 08:00:00 的 UNIX 时间戳是 0
3、国际日期变更线 全球各地都以自己所看到的太阳的位置作为确定一天的标准，把与自己所在地方相应的地球另一面的一条经线作为“日期变更线”也叫国际日界线，这样就有许多条“日期变更线”，使用起来很不方便。为了解决这个问题，应该规定一条全世界共同的、可供对照的“日期变更线”。随着标准时计时的区时系统的确立，东西十二区重叠，计时相同但日期不同，为避免混乱，公认180°经线作为日期变更线，因为是以“格林尼治时间”为标准的日期变更线。这条“日期变更线”就叫“国际日期变更线”。
为了避免日期上的混乱，1884年国际经度会议规定了一条国际日期变更线。这条变更线位于太平洋中的180°经线上，作为地球上“今天”和“昨天”的分界线，因此称为“国际日期变更线”。这条穿过太平洋的“国际日期变更线”，为了方便地方生活，避开了一些岛屿和地区，这是为了使它们不致分成两个日期，因此，它不是一条直线而是有几个曲折的曲线。
为避免在一个国家中同时存在着两种日期，日界线并不是一条直线，而是折线。它北起北极，通过白令海峡、太平洋，直到南极。这样，日界线就不再穿过任何国家。这条线上的子夜，即地方时间零点，为日期的分界时间。按照规定，凡越过这条变更线时，日期都要发生变化：从东向西越过这条界线时，日期要加一天，从西向东越过这条界线时，日期要减去一天。 又叫“人为日界线”。
常识：中国在国际日期变更线的西边，而美国在国际日期变更线的东边，所以美国时间是肯定比中国时间要晚的。最先进入新的一天的国家是：新西兰(UTC+12)、斐济(UTC+12)、基里巴斯（圣诞岛：UTC+14）、汤加（UTC+13）等国，最晚一天进入新一天的国家是纽埃（UTC-11）、美属萨摩亚群岛（UTC-11）。
参考：世界时间
4、关于北京时间 中国科学院国家授时中心（以下简称“国家授时中心”），前身是中国科学院陕西天文台，成立于1966年，是我国唯一的专门、全面从事时间频率基础研究和应用研究的科研机构，承担着我国国家标准时间（北京时间）的产生、保持和发播任务，建设和运行着的长短波授时系统是我国的第一批国家重大科技基础设施，建成了国内唯一的天地一体星地综合卫星导航授时试验平台，为我国国家时间频率体系、卫星导航系统的建设和发展做出了重要贡献。
国家授时中心总部位于陕西省西安市临潼区，在西安航天产业基地、渭南蒲城设有分部，另有授时发播台（如蒲城长、短波授时台，商丘低频时码发射台）、授时监测站、测定轨站分布在全国
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d11f5ace698b6bc87974c3611a9d7fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1b9120a4c77074f4729327ad74552d6/" rel="bookmark">
			JAVA 反编译工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Releases · deathmarine/Luyten · GitHub
安装exe 打开拖入文件即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/424ceeff6303523f51c0acb825358603/" rel="bookmark">
			Dubbo中的负载均衡策略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在集群负载均衡时，Dubbo 提供了多种均衡策略，缺省为 weighted random 基于权重的随机负载均衡策略。
具体实现上，Dubbo 提供的是客户端负载均衡，即由 Consumer 通过负载均衡算法得出需要将请求提交到哪个 Provider 实例。
负载均衡策略 目前 Dubbo 内置了如下负载均衡算法：
算法特性备注Weighted Random LoadBalance加权随机默认算法，默认权重相同RoundRobin LoadBalance加权轮询借鉴于 Nginx 的平滑加权轮询算法，默认权重相同LeastActive LoadBalance最少活跃优先 + 加权随机能者多劳ConsistentHash LoadBalance一致性哈希确定的入参，确定的提供者，适用于有状态请求 Weighted Random 加权随机，按权重设置随机概率。在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。缺点：存在慢的提供者累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。 RoundRobin 加权轮询，按公约后的权重设置轮询比率，循环调用节点缺点：同样存在慢的提供者累积请求的问题。 加权轮询过程中，如果某节点权重过大，会存在某段时间内调用过于集中的问题。 例如 ABC 三节点有如下权重：{A: 3, B: 2, C: 1} 那么按照最原始的轮询算法，调用过程将变成：A A A B B C
对此，Dubbo 借鉴 Nginx 的平滑加权轮询算法，对此做了优化。
平滑加权轮询算法描述：
假设有 N 台实例 S = {S1, S2, …, Sn}，配置权重 W = {W1, W2, …, Wn}，有效权重 CW = {CW1, CW2, …, CWn}。每个实例 i 除了存在一个配置权重 Wi 外，还存在一个当前有效权重 CWi，且 CWi 初始化为 Wi；指示变量 currentPos 表示当前选择的实例 ID，初始化为 -1；所有实例的配置权重和为 weightSum；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/424ceeff6303523f51c0acb825358603/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38ebc4ce43789ccf358b5f4095680966/" rel="bookmark">
			OSPF（Open Shortest Path First ）链路状态路由协议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、OSPF协议基础
1.诞生
2.OSPF表项
（1）OSPF邻居表
（2）LSDB表
（3）OSPF路由表
3.OSPF主要特点
二、OSPF路由计算器基本流程
1.LSA泛洪
2.运行SPF算法
3.路由计算
三、OSPF Router ID
1.Router ID的作用
2.Router ID选举规则
四、OSPF报文类型
1.Hello报文
2.DD报文
3.LSR报文
4.LSU报文
5.LSACK报文
五、OSPF支持的网络类型
1.广播网络
（1）特点
（2）默认选择
2.NBMA（非广播多路访问）网络
（1）特点
（2）默认选择
3.P2P网络
（1）特点
（2）默认选择
4.P2MP网络
（1）特点
（2）默认路由
六、OSPF路由器类型
1.内部路由器（IR）
2.区域边界路由器（ABR）
3.骨干路由器（BR）
4.AS边界路由器（ASBR）
七、OSPF LSA类型
1.Router-LSA
2.Network-LSA
3.Network-Summary-LSA
4.ASBR-Summary-LSA
5.AS-External-LSA
6.NSSA External LSA
八、OSPF区域
1.网络路由器增多会产生的问题
2.OSPF区域的划分
九、OSPF领接关系的建立
1.OSPF邻居状态机
（1）DOWN
（2）Attempt
（3）Init
（4）2-Way
（5）ExStart
（6）Exchange
（7）Loading
（8）Full
十、DR和BDR选举
1.选举制
2.终身制
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/38ebc4ce43789ccf358b5f4095680966/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d00bbe0da3e3fcdebd3c9be1ace8745/" rel="bookmark">
			@PostConstruct和static静态块初始化的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		static blocks are invoked when the class is being initialized, after it is loaded. The dependencies of your component haven't been initialized yet. That is why you get a NullPointerException (Your dependencies are null) . Move your code to a method annotated with @PostConstruct. This will ensure that your code will run when all the dependencies of your component are initialized
译文：static模块会被引入，当class加载后。你的component组件的依赖还没有初始化。这就是为什么你的代码块会报空指针异常。（你的依赖都是null）
1，@PostConstruct 注解的方法在加载类的构造函数之后执行，也就是在加载了构造函数之后，
为此，可以使用@PostConstruct注解一个方法来完成初始化，
@PostConstruct注解的方法将会在依赖注入完成后被自动调用。
2，执行优先级高于非静态的初始化块，它会在类初始化（类加载的初始化阶段）的时候执行一次，执行完成便销毁，它仅能初始化类变量，即static修饰的数据成员。
初始化失败：
static { strategyMap.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d00bbe0da3e3fcdebd3c9be1ace8745/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19aa6bb3693a881f7127769c2163ee87/" rel="bookmark">
			【PTA】【878真题】浙江大学软件学院878自命题2020真题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说明：
题目来自PTA平台的C语言与数据结构考研模拟卷（5）部分题目没答案是因为博主也做错了，不知道正确答案如果有不会做的题目或者知道正确答案，可以评论或者私信我，谢谢 选择题 2-1 若变量已正确定义并且指针p已经指向某个变量x，则(*p)++相当于____。
选项Ap++B x++C*(p++)D&amp;x++ 2-2 下列程序for循环退出时，i和 j的值分别是：
for (i=0,j=0; (i&lt;5)&amp;&amp; (j!=4); i++,j++); 选项A4，4B4，5C5，4D三个选项都不对 2-3 设变量定义为 char a[20], *p=a; 下面赋值语句中正确的是：
选项Ap= “Zhejiang”;Ba= “Zhejiang”;C*p= “Zhejiang”;Da[20]= “Zhejiang”; 2-4 设有变量定义： int a[2][3]={0,1,2,3,4,5}; 下面 4 个表达式中最大的是：
选项Aa[1][2]-2B a[0][3]+1Ca[2][-3]D*(*a+3) 2-5 下列程序段的输出结果是：
char *s[]={"Zhejiang", "University", "Computer", "Science"}; printf("%s", *(s+2)+3); 选项AversityB puterCenceD程序有错 2-6 下列程序的输出结果是:
void fun(int n, int *m) { n=n+2; *m += n; } int main( ) { int a=1,b=2; fun(a,&amp;b); printf("%d %d",a,b); return 0; } 选项A1 2B1 5C3 2D3 5 2-7 表达式 -1&lt;0&lt;1 的值是：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/19aa6bb3693a881f7127769c2163ee87/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7f3d7368f822c75a48d83dc26fa3d0e/" rel="bookmark">
			2023Java最新真实面试题汇总（持续更新）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、面经 适当夸夸面试官（或所在公司）不会有坏处
如果某个问题完全不会（或稍微懂点），直接承认（或略作回答）并把话题引导向类似话题（redis集群的槽机制 -&gt; 一致性哈希）
第二条如果完全不会，可以在表达自己不会之后给与面试官一点反问，表现出自己的求知欲与关注度
所有话题都可以适当性的发散，不要太发散以免显得有备而来
所有问题（熟悉或不熟悉）的回答不要太快，给面试官反应与打断的时间，同时方便自己梳理逻辑，显得沉稳；回答太快容易显得有备而来
一定要乐观向上（至少摄像头下的你看起来得是这样）
80%面试官的80%的问题来自于简历的自写技术栈及第一个项目，这一条真的非常重要
入职阿里40w+（整理）
入职腾讯35w+（整理）
入职京东（整理）
二、真题（2021） 2.1完字节跳动 1、为什么MySQL索引更适合B+树而不是二叉树、B树 https://blog.csdn.net/qq_38038480/article/details/81738079 2、微服务下的用户登录权限校验解决方案 https://www.cnblogs.com/zxfei/p/11716822.html 3、微服务之熔断、降级、限流 熔断是在客户端还是服务端？ https://blog.csdn.net/aa1215018028/article/details/81700796 4、kafka如何保证消息不丢失？Kafka Rebalance机制 保证消息不丢失：https://www.jianshu.com/p/68c173e4c549 Rebalance机制：https://www.cnblogs.com/yoke/p/11405397.html 5、redis集群模式下key的寻址 https://blog.csdn.net/chang384915878/article/details/86749209 6、算法题：给定一组非负整数，重新排列它们的顺序使之组成一个最大的整数。 输入: [10, 2] 输出: 210 输入: [3,30,34,5,9] 输出: 9534330 输入：[5, 60, 2, 80, 342] 输出：865432200 输入是数组，输出是字符串。 2.2美团 美团一面 1、什么是幂等，Get和Post的区别 2、Https实现方式 能用私钥加密公钥解密吗 3、希尔排序是什么 4、解释一下【宁用组合，不用继承】 5、List list;可以这样定义吗？为什么？解释一下泛型擦除？为什么java必须强制？（因为别的语言有泛型，java没有，运行时擦除，所以在编译前强制） 6、什么是STW，stop the world，为什么用 7、我能在一个有序链表来进行二分查找么？（不能，没有索引） 8、COW ，copy on write是什么 9、CSRF攻击是什么 10、DMA是什么 11、CPU负载过高怎么处理 12、还有别的 服务器指标吗 13、经常触发FullGC怎么排查处理 14、CPU过高怎么排查处理 15、令牌桶是什么 16、反爬虫怎么做（一开始说的mq削峰，但是如果大流量都到不了mq层，在网关/nginx做） 17、解释一下【数据存取在内存用平衡二叉树（avl，红黑树），在硬盘用b树b+树】 18、解释一下BIO、NIO 19、解释一下多路复用，多路复用需要CPU参与吗 20、为什么Eden与s0s1比例为8:1:1 21、ABA问题怎么解决 22、为什么不用Mysql的缓存而用redis的 23、HashMap1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f7f3d7368f822c75a48d83dc26fa3d0e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c5fafc7e03a7e27b22f998811f91fc6/" rel="bookmark">
			Objects.equals
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近review别人代码的时候，发现有个同事，在某个业务场景下，使用Objects.equals方法判断两个值相等时，返回了跟预期不一致的结果，引起了我的兴趣。
原本以为判断结果会返回true的，但实际上返回了false。
记得很早之前，我使用Objects.equals方法也踩过类似的坑，所以有必要把这个问题记录下来，分享给大家。
到底怎么回事呢？
案发现场 假设现在有这样一个需求：判断当前登录的用户，如果是我们指定的系统管理员，则发送一封邮件。系统管理员没有特殊的字段标识，他的用户id=888，在开发、测试、生产环境中该值都是一样的。 这个需求真的太容易实现了： UserInfo userInfo = CurrentUser.getUserInfo(); if(Objects.isNull(userInfo)) { log.info("请先登录"); return; } if(Objects.equals(userInfo.getId(),888)) { sendEmail(userInfo): } 从当前登录用户的上下文中获取用户信息，判断一下，如果用户信息为空，则直接返回。
如果获取到的用户信息不为空，接下来判断用户id是否等于888。
如果等于888，则发送邮件。 如果不等于888，则啥事也不干。 当我们用id=888的系统管理员账号登录之后，做了相关操作，满怀期待的准备收邮件的时候，却发现收了个寂寞。
后来，发现UserInfo类是这样定义的：
@Data public class UserInfo { private Long id; private String name; private Integer age; private String address; } 此时，有些小伙伴可能会说：没看出什么问题呀。
但我要说的是这个代码确实有问题。
什么问题呢？
答：UserInfo类的成员变量id=888是Long类型的，而Objects.equals方法右边的888是int类型的，两者不一致，导致返回的结果是false。
这算哪门子原因？
答：各位看官，别急，后面会细讲的。
2. 判断相等的方法 让我们一起回顾一下，以前判断两个值是否相等的方法有哪些。
2.1 使用==号 之前判断两个值是否相等，最快的方法是使用==号。
int a = 1; int b = 1; byte c = 1; Integer d1 = new Integer(1); Integer d2 = new Integer(1); System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c5fafc7e03a7e27b22f998811f91fc6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94dd3eccd27ed783b82c6c7df0282806/" rel="bookmark">
			【Alist】Mac 使用 Docker 部署 Alist 并通过 CloudMounter 本地挂载网盘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		修改记录：
“添加存储” 选择 “阿里云盘” 官方已经不建议使用：“不推荐使用该驱动，因为它不稳定，随时可能被屏蔽，我们会在以后的版本中移除。推荐使用官方API的驱动 Aliyundrive Open。”
什么是AList？ AList 是一个支持多种存储，支持网页浏览和 WebDAV 的文件列表程序，由 gin 和 Solidjs 驱动。可以将常见的 18 种网盘整合在一起，并支持 WebDAV 客户端访问。
简单的说 通过本地浏览器管理多种网盘的程序。
官网：https://alist.nn.ci/zh/
支持的列表如下：
通过 Docker 部署 Alist 打开Docker，点击查询，搜索alist-aria2，找到xhofe/alist-aria2的，右键下载此映像，选择latest版本即可，然后等待下载完成。 2、点击Docker左边的映像，然后找到下载完成的alist映像，点击启动进入创建容器窗口
3、点击下拉窗口
4、在下拉设置窗口中设置：容器名称、映射端口号、aria2 映射端口号、映射目录 后点击run
5、点击 Docker 左边的容器，在容器列表中看到创建好的 Alist 实例
访问并设置 Alist 1、获取 Alist 的默认后台密码 点击 Docker 左边的容器，在容器列表中看到创建好的 Alist 实例
点击实例，进入 Alist 实例详情的Log内容，得到admin 用户的密码
2、在浏览器中输入 http://localhost:5244 第一次访问是会出现**“failed get storage: can’t find storage with rawPath: /”错误信息，点击页面底部的管理按钮，进入alist管理页面，再在存储**菜单下添加你自己的网盘后就可以了
3、在管理界面添加存储 1、进入 存储 --&gt; 添加 驱动 --&gt; 找到 阿里云盘
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94dd3eccd27ed783b82c6c7df0282806/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9ad729313bcc29d695f9c3828e32dcf/" rel="bookmark">
			centos7下使用mycat2实现mysql负载均衡和读写分离
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前期工作 参考文章《Centos7下采用haproxy+keepalived搭建mysql高可用负载均衡》
1、关闭防火墙和SELINUX（3台虚拟机）
2、设置yum源（3台虚拟机）
3、安装mysql（3台虚拟机）——7.86（主）、7.88（从1）、7.89（从2）
二、Mysql一主两从配置 1、修改mysql配置文件 在7.86、7.88、7.89的MySQL配置文件/etc/my.cnf分别增加下面这一段。
server-id=86 #任意自然数n，保证三台MySQL主机id不一样。
log-bin=mysql-bin #开启二进制日志
replicate-do-db=aa #要同步的数据库，默认所有库
保存后，重启mysql服务
sudo systemctl restart mysqld
或sudo service mysqld restart
2、查看主mysql（7.86）二进制日志 登录mysql -uroot -p
密码Lr12345!
mysql&gt; show master status;
3、在从mysql（7.88、7.89）告知二进制文件名与位置 mysql&gt; change master to
-&gt; master_host='192.168.7.86',
-&gt; master_user='root',
-&gt;master_password='Lr12345!',
-&gt;master_log_file='mysql-bin.000001',
-&gt; master_log_pos=154;
查看结果
mysql&gt; start slave;
mysql&gt; show slave status\G
4、验证主从同步 192.168.7.86主MySQL操作：
mysql&gt;create database aa;
mysql&gt;use aa;
mysql&gt;create table tab1(id int auto_increment,name varchar(10),primary key(id));
mysql&gt;show databases;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d9ad729313bcc29d695f9c3828e32dcf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40a54069538be7922502343a478e4859/" rel="bookmark">
			Centos7虚拟机 安装samba windows访问共享文件夹
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		step 1 安装 yum -y install samba
step 2 关闭防火墙 systemctl stop firewalld
systemctl disable firewalld
重启网络
step 3 关闭 SELINUX （安全机制）
vim /etc/selinux/config
SELINUX=disabled
step 4 创建共享文件
mkdir /home/zxc/share
step 5 给要共享的文件权限（不给的话，不能写文件）
chown zxc:zxc share
step 6 添加共享文件
//建议使用下面得注意事项中示例
vi /etc/samba/smb.conf
#后面Windows添加映射磁盘刻就是\\xxx.xxx.xxx.xxx\shares，直接在默认文件后面加下面内容 #就可以
[shares]
comment = This is Alun's folder!
#不要指向没有权限的路径（用户名要一致，和系统用户（比如root用户（这个没试过），自己建的user用户(这里用户是zxc)）直接同一个就行，不用新建）
path = /home/zxc/share browseable = yes
writable = yes
valid users=zxc
step 7 将用户加入samba中
systemctl restart smb.service
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40a54069538be7922502343a478e4859/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f7d7548afc6d614822daefab670f486/" rel="bookmark">
			六. Nacos 注册中心底层原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一. Nacos 注册中心使用注意点二. NacosNamingService1. EventDispatcher2. NamingProxy3. BeatReactor4. HostReactor 三. 服务注册1. registerInstance()---&gt;BeatReactor下的addBeatInfo()方法实现心跳的建立2. registerInstance()---&gt;NamingProxy下的registerService()方法实现服务注册3. nacos注册中心对注册请求的处理AP 与 CP1. 对应AP模式的EphemeralConsistencyService2. 对应CP模式的RaftConsistencyServiceImpl service内部健康检测任务久化实例是如何检测 4. nacos注册中心接收到心跳后的处理5. nacos注册中心与连接服务间的UDP通信6. nacos注册中心处理注销服务请求 四. 服务发现相关1. 服务Client心跳检测2. 服务Client的UDP端口上报和接收nacos注册中心的UDP更新3. nacos注册中心对订阅请求的处理4. 订阅 五 Nacos与Eureka 一. Nacos 注册中心使用注意点 在使用Nacos作为注册中心时,首先要引入nacos相关依赖,并使用@EnableNacosDiscovery或@EnableDiscoveryClient注解配置开启nacos注册中心功能 @EnableNacosDiscovery是nacos提供的专属注解，用于开启nacos的服务注册和发现功能，它只适用于nacos作为注册中心的场景@EnableDiscoveryClient是spring cloud提供的通用注解，用于开启服务注册和发现功能，它可以适配不同的注册中心，如eureka、consul、zookeeper等，只要引入相应的依赖即可。@EnableNacosDiscovery和@EnableDiscoveryClient都可以实现nacos的服务注册和发现功能，但是@EnableNacosDiscovery更加简洁和直观，而@EnableDiscoveryClient更加通用和灵活 &lt;!-- 二选一: nacos-discovery-spring-boot-starter与spring-cloud-starter-alibaba-nacos-discovery的区别： 1.nacos-discovery-spring-boot-starter是nacos官方提供的spring boot starter，用于在spring boot项目中集成nacos的服务注册和发现功能，它只依赖于nacos-client和spring-boot-starter-web，不依赖于spring cloud相关的组件 2. spring-cloud-starter-alibaba-nacos-discovery是spring cloud alibaba项目提供的spring cloud starter，用于在spring cloud项目中集成nacos的服务注册和发现功能，它依赖于nacos-client、spring-cloud-commons、spring-cloud-context等spring cloud相关的组件，可以与其他spring cloud组件如ribbon、feign、hystrix等进行协作 3. nacos-discovery-spring-boot-starter和spring-cloud-starter-alibaba-nacos-discovery都可以实现nacos的服务注册和发现功能，但是nacos-discovery-spring-boot-starter更加轻量级和简单，而spring-cloud-starter-alibaba-nacos-discovery更加完善和强大, 4. 实现方式不同：nacos-discovery-spring-boot-starter 是基于 Spring Boot 的SPI自动配置机制实现的，而 spring-cloud-starter-alibaba-nacos-discovery 则是基于 Spring Cloud 的编程模型实现的。 5. 依赖范围不同：nacos-discovery-spring-boot-starter 是一个 Spring Boot Starter，可以直接引入到 Spring Boot 项目中，而 spring-cloud-starter-alibaba-nacos-discovery 是一个 Spring Cloud Starter，需要与其他的 Spring Cloud 相关依赖一起使用--&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f7d7548afc6d614822daefab670f486/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa25f12fe68f7631cb2a3565fb22424f/" rel="bookmark">
			centos7下使用mycat实现mysql负载均衡和读写分离
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前期工作 参考文章《Centos7下采用haproxy+keepalived搭建mysql高可用负载均衡》
1、关闭防火墙和SELINUX（4台虚拟机）
2、设置yum源（4台虚拟机）
3、安装mysql（7.80、7.81、7.82）
二、Mysql一主两从配置 1、修改MySQL配置文件 在7.80、7.81、7.82的MySQL配置文件/etc/my.cnf分别增加下面这一段。
server-id=80 #任意自然数n，保证三台MySQL主机id不一样。
log-bin=mysql-bin #开启二进制日志
replicate-do-db=aa #要同步的数据库，默认所有库
保存后，重启mysql服务
sudo systemctl restart mysqld
或sudo service mysqld restart
2、查看主mysql（7.80）二进制日志 登录mysql -uroot -p
密码Lr12345!
mysql&gt; show master status;
3、在从mysql（7.81、7.82）告知二进制文件名与位置 mysql&gt; change master to
-&gt; master_host='192.168.7.80',
-&gt; master_user='root',
-&gt; master_password='Lr12345!',
-&gt; master_log_file='mysql-bin.000001',
-&gt; master_log_pos=154;
查看结果
mysql&gt; start slave;
mysql&gt; show slave status\G;
4、验证主从同步 192.168.7.80主MySQL操作：
mysql&gt;create database aa;
mysql&gt;use aa;
mysql&gt;create table tab1(id int auto_increment,name varchar(10),primary key(id));
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa25f12fe68f7631cb2a3565fb22424f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d4a64bba0cdd2e64906d4477ae15bfd/" rel="bookmark">
			Python&#43;Playwright(Nuitka、Pyinstaller打包)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python+Playwright及软件打包
Selenium/Playwright网页自动化测试工具 在做办公自动化过程中接触了Selenium这个工具，方便爬取数据或者自动模拟鼠标/键盘操作，后面发现了更牛逼的Playwright，而且可以自动录制操作，直接生成相关代码，Playwright具体使用不在这里介绍，随便浏览器输入Playwright，就会发现很详细的内容。
Python+Playwright及软件打包 1、Python(版本必须≥3.7)使用Playwright，需要先安装对应的包，这个跟Python安装其他包是一样的，pip install playwright。
2、Playwright执行自动化操作依赖指定的浏览器，Chromium/FireFox/WebKit，这个是指定的，不能自己乱下载。详见官网说明
3、每个版本的 Playwright 都需要特定版本的浏览器二进制（exe可执行文件）文件才能运行。默认情况下，Playwright从Microsoft和Google公共CDN将Chromium，WebKit和Firefox浏览器下载到特定于操作系统的缓存文件夹中：
（Windows）%USERPROFILE%\AppData\Local\ms-playwright
（MacOS）~/Library/Caches/ms-playwright
（Linux）~/.cache/ms-playwright
4、这些浏览器的大小：281M chromium-XXXXXX、187M firefox-XXXX、180M webkit-XXXX，另外还有一个几兆大小的FFMPEG（音视频库）
5、安装完Playwright包，c:\users\cnxigao13.conda\envs\webgui\lib\site-packages\playwright\driver\package\browsers.json中已经定义了浏览器的版本(路径c:\users\cnxigao13.conda\envs\webgui是我自己的虚拟环境路径)。
默认情况下在使用指令：
pip install playwright # 这个安装python的playwright包 playwright install # 这个安装所有默认的浏览器 playwright install chromium # 一般只装这一个浏览器就够了，要是装另外两个浏览器，后面的参数名可以修改 上面安装的浏览器在windows的默认位置是%USERPROFILE%\AppData\Local\ms-playwright 重点 6、在实际应用中，尤其是要打包的时候，浏览器也要放在打包的文件夹内，就牵涉到浏览器安装位置的问题，在playwright官网说明中就写了下载浏览器导指定位置，而不是默认位置的方法：
set PLAYWRIGHT_BROWSERS_PATH=绝对地址 playwright install chromium 这样就会把浏览器的文件夹ms-playwright安装到指定路径下，也可以安装到playwright包的路径下，但一般没必要。
很多教程里面，尤其是能搜索到的一些打包playwright教程（如pyinstaller打包playwright），里面会写
PLAYWRIGHT_BROWSERS_PATH=0 playwright install chromium 这个其实很容易搞错，这个是指你切换到对应的路径下，然后调用指定，0代表安装在本路径（你已经在命令行或者Anaconda Prompt中切换到这个路径下了），而如果你没有进入这个路径，直接执行，就要按上面我说的绝对地址去指定。
7、很多人也用playwright codegen进行自动生成操作代码了，在pycharm等编译器中也能正常运行了，可一打包，在使用自己打包好的exe程序时，就会出现闪退。然后又重新打包，保留控制台，以确定到底是哪里报错。
报错一 无法在路径中发现：%USERPROFILE%\AppData\Local\ms-playwright\chromium-XXXX\chrome-win\chrome.exe，然后提示让你用playwright install进行安装或更新。
很多人都进行安装，然后发现还是搞不定，还是会报这个错误，但明明已经安装上了，在编译器中运行也不会报错，单一打包就报错找不到浏览器。
核心问题：
from playwright.sync_api import sync_playwright def run(playwright): browser = playwright.chromium.launch(headless=True) context = browser.new_context() 你用playwright codegen生成的代码都是使用函数playwright.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d4a64bba0cdd2e64906d4477ae15bfd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d3923be6986004dcafe1b00904633c8/" rel="bookmark">
			V8引擎Promise源码全面解读（深度好文）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：月夕
原文：https://juejin.cn/post/7055202073511460895
写在前面的话 阅读本文你将收获什么？
了解 V8 Promise 源码全过程，世界上不再有能困住你的 Promise 题目，我就是这么肯定这篇文章的干货
仅仅了解或者实现了 Promise/A+ 规范，这与 JavaScript 的 Promise 中间还有很大的差距
如果你在面试时将 Promise 回答到本文的深度，一定是收获 SP 或者 SSP offer 的利器，因为面试官大概率也不知道这些知识。
你知道 浏览器 &amp; Node 中真正的 Promise 执行顺序是怎么样的吗，如果你只是看过 Promise/A+ 规范的 Promise 实现，那么我肯定的告诉你，你对 Promise 执行顺序的认知是错误的。不信的话你就看看下面这两道题。
Promise.resolve().then(() =&gt; { console.log(0); return Promise.resolve(4) }).then(res =&gt; { console.log(res); }) Promise.resolve().then(() =&gt; { console.log(1); }).then(() =&gt; { console.log(2); }).then(() =&gt; { console.log(3); }).then(() =&gt; { console.log(5); }).then(() =&gt; { console.log(6); }) // 0 1 2 3 4 5 6 new Promise((resolve, reject) =&gt; { Promise.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d3923be6986004dcafe1b00904633c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6b018d72a389f608ea31806d1d68602/" rel="bookmark">
			【Python】PySpark 数据计算 ③ ( RDD#reduceByKey 函数概念 | RDD#reduceByKey 方法工作流程 | RDD#reduceByKey 语法 | 代码示例 )
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、RDD#reduceByKey 方法1、RDD#reduceByKey 方法概念2、RDD#reduceByKey 方法工作流程3、RDD#reduceByKey 函数语法 二、代码示例 - RDD#reduceByKey 方法1、代码示例2、执行结果 三、代码示例 - 使用 RDD#reduceByKey 统计文件内容1、需求分析2、代码示例 一、RDD#reduceByKey 方法 1、RDD#reduceByKey 方法概念 RDD#reduceByKey 方法 是 PySpark 中 提供的计算方法 ,
首先 , 对 键值对 KV 类型 RDD 对象 数据 中 相同 键 key 对应的 值 value 进行分组 ,然后 , 按照 开发者 提供的 算子 ( 逻辑 / 函数 ) 进行 聚合操作 ; 上面提到的 键值对 KV 型 的数据 , 指的是 二元元组 , 也就是 RDD 对象中存储的数据是 二元元组 ;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f6b018d72a389f608ea31806d1d68602/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3d63a7f0d3d3ceca9c3d32c5a22de14/" rel="bookmark">
			第124天：内网安全-代理技术&amp;Socks协议&amp;路由不出网&amp;后渗透通讯&amp;CS-MSF上线
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		知识点 #知识点： 1、代理软件使用-Win&amp;Linux 2、代理协议使用-Socks4/5 3、CS&amp;MSF-网络通讯&amp;控制上线 -隧道技术：解决不出网协议上线的问题（利用出网协议进行封装出网） -代理技术：解决网络通讯不通的问题（利用跳板机建立节点后续操作） -连接方向：正向&amp;反向（基础课程有讲过） #系列点： 1、判断什么时候用代理 2、判断什么时候用隧道 3、判断出网和不出网协议 4、如何使用代理建立节点并连接 5、如何使用隧道技术封装协议上线 6、判断哪些代理或隧道情况选择放弃 演示案例 网络通讯-MSF&amp;CS-路由添加&amp;节点建立 控制上线-MSF&amp;CS-协议生成&amp;正反连接 #网络通讯-MSF&amp;CS-路由添加&amp;节点建立 #控制上线-MSF&amp;CS-协议生成&amp;正反连接 代理协议： SOCKS4/5 代理软件： SocksCap Proxifier ProxyChains等 MSF通讯 1、添加路由 限于MSF 查看路由信息 run autoroute -p run post/multi/manage/autoroute 添加指定路由，1是接收的session编号 route add 192.168.11.0 255.255.255.0 1 2、Sock代理 全局同用 use auxiliary/server/socks_proxy set srvhost 0.0.0.0 set srvport 1115 run 启用代理软件配置Sock5代理 CS通讯 命令：socks 59578 操作：代理转发-Socks代理 MSF控制上线-正向连接 msfvenom -p windows/meterpreter/bind_tcp LHOST=0.0.0.0 LPORT=3333 -f exe &gt; bd.exe use exploit/multi/handler set payload windows/meterpreter/bind_tcp set rhost 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3d63a7f0d3d3ceca9c3d32c5a22de14/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55f57c5f1d068b7fce094a29e219b6c2/" rel="bookmark">
			手把手一起使用WPF开源UI框架MahApps.Metro
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、创建新项目 使用Visual Studio 2022创建新项目，如图点击创建新项目：
选择WPF应用(.NET Framework)：
配置新项目，如图：
随便写几个WPF默认样式控件：
2、安装 MahApps.Metro 点击工具-&gt;NuGet包管理器-&gt;管理解决方案的NuGet程序包，如图所示：
搜索MahApps，点击第一个，安装即可：
点击确认，如图：
安装完成，如图所示：
3、App.xaml修改代码 在App.xaml中修改如下代码：
&lt;Application x:Class="FMSH_NVM_WPF.App" xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation" xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" xmlns:local="clr-namespace:FMSH_NVM_WPF" StartupUri="MainWindow.xaml"&gt; &lt;Application.Resources&gt; &lt;ResourceDictionary&gt; &lt;ResourceDictionary.MergedDictionaries&gt; &lt;!-- MahApps.Metro resource dictionaries. Make sure that all file names are Case Sensitive! --&gt; &lt;ResourceDictionary Source="pack://application:,,,/MahApps.Metro;component/Styles/Controls.xaml" /&gt; &lt;ResourceDictionary Source="pack://application:,,,/MahApps.Metro;component/Styles/Fonts.xaml" /&gt; &lt;!-- Theme setting --&gt; &lt;ResourceDictionary Source="pack://application:,,,/MahApps.Metro;component/Styles/Themes/Light.Blue.xaml" /&gt; &lt;/ResourceDictionary.MergedDictionaries&gt; &lt;/ResourceDictionary&gt; &lt;/Application.Resources&gt; &lt;/Application&gt; 如图所示：
此时，重新生成并运行程序，窗体内部的控件样式已经发生改变，如图：
4、MainWindow.xaml修改代码 在MainWindow.xaml中修改如下代码：
&lt;mah:MetroWindow x:Class="FMSH_NVM_WPF.MainWindow" xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation" xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" xmlns:d="http://schemas.microsoft.com/expression/blend/2008" xmlns:mah="clr-namespace:MahApps.Metro.Controls;assembly=MahApps.Metro" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" xmlns:local="clr-namespace:FMSH_NVM_WPF" mc:Ignorable="d" Title="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/55f57c5f1d068b7fce094a29e219b6c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e11b667fdd7fbbb13a67296722815087/" rel="bookmark">
			【Java多线程】【阻塞队列】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、概念
1.1 什么是阻塞队列
1.2 特性 2、生产者消费者模型 2.1 解耦合
2.2 削峰填谷 2.3 模型实现
3、阻塞队列 方法及实现
3.1 方法
3.2 核心 3.3 实现 3.3.1 普通队列
3.3.2 加上阻塞
1、概念 1.1 什么是阻塞队列 从名字上 可以看出，它是队列的一种，那肯定是 先进先出（FIFO）的数据结构
1.2 特性 阻塞添加：当阻塞队列是满时，继续 添加的操作将被阻塞，直到被其他线程从队列取走元素阻塞移除：当阻塞队列是空时，继续 获取的操作将被阻塞，直到被其他线程从队列添加元素 在多线程中，多线程之间进行数据交互，可以使用阻塞队列简化代码实现
应用场景：
线程池的底层存储生产者消费者模型 下面详细讲解 生产者消费者模型
2、生产者消费者模型 这是一种常用的并发式编程模型，用于解决生产者和消费者之间的数据传输和同步问题
组成：
生产者：负责生成数据并将其存储在共享数据结构中（阻塞队列）消费者：负责从共享数据结构中获取并进行处理共享数据结构：一般为阻塞队列实现 生产者往阻塞队列中插入数据，消费者从阻塞队列取出数据，队列的阻塞性可以实现生产者和消费者之间的同步和互斥
生活中的例子 擀饺子皮（生产者）、包饺子（消费者），放饺子皮（阻塞队列）
2.1 解耦合 可以让上下游模块之间，进行更好的“解耦合”
耦合：两个或多组模块之间的依赖关系
问题：高耦合
解决： 引入阻塞队列，作为数据传输点
2.2 削峰填谷 问题：传输的数据、速度直接影响，超出限度可能出现问题
解决：削峰填谷 2.3 模型实现 public static void main(String[] args) throws InterruptedException { BlockingQueue&lt;Integer&gt; bq = new LinkedBlockingQueue&lt;&gt;(); //消费者 Thread consumer = new Thread(()-&gt;{ while (true){ try { int value = bq.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e11b667fdd7fbbb13a67296722815087/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c0db42e1cb51d3cbef484b8ee3cdd62/" rel="bookmark">
			c&#43;&#43; 一个简单跨平台cmake工程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.简介 本文章的主要目的就是快速搭建个 可以跨windwos平台和linux平台的 c++工程。
主要还是方便linux端工程代码模拟的测试，linux端操作起来比较麻烦。
2.文件内容和搭建方法 1.新建文件夹，将以下两个文件放入
2.如果是windows平台，用cmake 界面搭建工程
3.如果是linux平台，进入文件夹。
执行命令 cmake . 接着执行命令 cmake --build .
文件 CMakeLists.txt
cmake_minimum_required(VERSION 3.10)
project(myProject)
set(CMAKE_CXX_STANDARD 17) # 设置c++版本为c++17
#GLOB_RECURSE 递归地去搜索设定目录下的文件
#cmake可能会在编译过程中生成 CMakeCXXCompilerId.cpp文件 其中就有 main()函数
#由于cmake和main.cpp都在顶级目录中,如果使用了GLOB_RECURSE，则有可能包含了上述cpp
#因此cmake就会报出 main函数重复定义的错误
file(GLOB ALL_FILES
${CMAKE_CURRENT_SOURCE_DIR}/*.cpp
${CMAKE_CURRENT_SOURCE_DIR}/*.h
)
add_executable(myProject ${ALL_FILES})
#链接pthread库，否则在linux下std::thread无法使用
MESSAGE( STATUS "systemType = ${CMAKE_HOST_SYSTEM_NAME}")
if(${CMAKE_HOST_SYSTEM_NAME} MATCHES "Linux")
target_link_libraries (myProject pthread)
endif()
main.cpp
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;thread&gt;
const int loopTime = 200;
void LoopAdd() {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c0db42e1cb51d3cbef484b8ee3cdd62/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13a8d5d206f4f2c12be6c66bbaaa7a51/" rel="bookmark">
			cmake编译多个工程，一个执行工程调用dll工程。跨平台 win和Linux。 __declspec __attribute__ 函数导出导入动态库声明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.概述
2.文件结构和内容
3.使用方法和效果
一.概述 本文章将讲述 一个简单的模型 ：通过cmake构建工程，其中包括一个专门用来导出dll或so动态库的工程，一个专门用来调用动态库的工程。并且能跨平台运行。
涉及c++ 函数 __attribute__ 和 __declspec 的使用，这两函数可以声明头文件的函数是用来导出成动态库或者调用动态库
二.文件结构和内容 文件结构为
CMakeLists.txt
│
├─basicFun
│ basicFun.cpp
│ basicFunApi.h
│ CMakeLists.txt
│
└─exctueMain
│ CMakeLists.txt
│ exctueMain.cpp
│
├─testDir1
│ test1.cpp
│ test1.h
│
└─testDir2
test2.cpp
test2.h
1.总cmake # 以下是 ./CMakeLists.txt 的内容
# 以下是 ./CMakeLists.txt 的内容
cmake_minimum_required(VERSION 3.10)
project(my_proj)
#父cmakeList文件定义的变量可以传递到 子cmakeList中
set(PROJECT_TOP_DIR ${CMAKE_SOURCE_DIR})
MESSAGE( STATUS "PROJECT_TOP_DIR = ${PROJECT_TOP_DIR}.")
#父母cmake定义的宏，到孩子cmake里的工程也生效
add_definitions(-DTEST_HONG)
if(${CMAKE_HOST_SYSTEM_NAME} MATCHES "Linux")
add_definitions(-DSYSTEM_IS_LINUX)
endif()
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13a8d5d206f4f2c12be6c66bbaaa7a51/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f31f1d5a6a8a8cab23fe7853824f3db6/" rel="bookmark">
			基于51单片机的电子钟Protues仿真设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、设计背景 电子钟是指利用数字电路或单片机等现代电子技术来实现时间计量和显示的钟表。相较于传统机械钟、石英钟等时钟，电子钟具有精度高、音响小、易于制造和调节等优点，同时也由于其美观大方的外观设计而成为了家居装饰中不可或缺的一部分。
其中，基于 51 单片机的电子钟因其简单易操作、代码共享、性能稳定等特点而广受欢迎。由于 51 单片机通过提供基本的输入输出端口和计时器模块等重要功能，使得使用者可以轻松地在自己的作品中集成时钟计时的功能。
此外，随着时钟功能的不断完善，如闹铃设置、温度显示、继电器控制等进阶功能的逐步融入，这些具有实际意义的设备进一步丰富了电子钟的应用场景。例如在育儿宝典、健康保健仪等家里或医护场所中，常常需要借助电子钟进行测量及提醒，以便用户合理安排工作和休息时间。
需要注意的是，在制作电子钟过程中，物料选择和电路设计都需要严格遵守相关标准和规范，确保生产产品符合设备安全、环保和电磁兼容性的要求。
总之，基于 51 单片机的电子钟是一项极具实用性和创意性的工程设计，不断发展与完善将带来更加优秀的产品，并为用户提供更多便利与乐趣。
二、设计要求 要求1：利用单片机的定时器和LCD1602液晶显示器，设计一个电子时钟，电子时钟显示的格式为：XX:XX:XX，由左向右分别为：时、分、秒。
要求2：添加4个按键，分别是模式按键（可以切换正常模式和设置闹钟时间模式）、移位按键（在闹钟模式下起作用，用来切换当前设置闹钟时间的位置，分别是：时、分、秒）、增加按键（在闹钟模式下起作用，增加值）、减小按键（在闹钟模式下起作用，减小值）。按键从左往右依次为key1、key2、key3、key4。
要求3：添加一个led灯，闹钟时间到了闪烁，并且闪烁1分钟。
三、仿真演示 1、按下key1可以对模式进行切换，09表示正常模式，在这个模式下电子钟开始工作。
2、00表示设置闹钟时间模式，在这个模式下可进行闹钟时间的设置。
3、在闹钟模式下通过按下key2，结合增减键key3和key4可以对闹钟时间进行设置。
4、闹钟时间到了闪烁，并且闪烁1分钟。
四、部分程序展示 void main() { TMOD=0x01; TH0=(65536-50000)/256; TL0=(65536-50000)%256; EA=1; ET0=1; TR0=1; LCD_Init(); LED = 1; while(1) { if(KModle == 0) { modle = ~modle; if(modle ==0 ) Wei = 0; else Wei = 9; while(KModle == 0);	} if(modle == 0) { if(KYiWei == 0) Wei++; if(Wei == 3) Wei = 0; while(KYiWei == 0);	} if(modle == 0 &amp;&amp; KJia == 0) { switch(Wei) { case 0: { Tshi++; if(Tshi == 24) Tshi=0; break; } case 1: { Tfen++; if(Tfen == 60) Tfen=0; break; } case 2: { Tmiao++; if(Tmiao == 60) Tmiao=0; break; } } while(KJia == 0);	} if(modle == 0 &amp;&amp; KJian == 0) { switch(Wei) { case 0: { if(Tshi == 0) Tshi=23; else Tshi--; break; } case 1: { if(Tfen == 0) Tfen=59; else Tfen--; break; } case 2: { if(Tmiao == 0) Tmiao=59; else Tmiao--; break; } } while(KJian == 0); } if(modle == 0) { Out_Char(0,Wei); Out_Char(4,Tshi); Out_Char(7,Tfen); Out_Char(10,Tmiao); } } } 部分内容参考网络，如有侵权请联系博主删除，仿真源文件及源程序百度网盘链接：https://pan.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f31f1d5a6a8a8cab23fe7853824f3db6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e708a86ca3e4f94e8420989eef29816/" rel="bookmark">
			Nuitka打包tkcalendar时遇到的问题-tkinter界面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、背景 tkinter界面中通常会用到日历控件，常用的是tkcalendar，这个包在编译器中使用时一般没什么问题，但是在打包时会出现问题，无论是Pyinstaller还是Nuitka，网上能查到的都是Pyinstaller解决方案，这里写一下Nuitka的解决方案。
二、tkcalendar问题1——Calendar与python自带的calendar冲突 使用这个包通常会有这样一句：
from tkcalendar import Calendar 你会发现这个包编译测试没问题，但打包是就会报错，是因为Calendar这个类（在tkcalendar\calendar_.py下面）会跟python自带的calendar包冲突。
因此要想用，最好对这个类改名，我这里改成CCalendar。
注意有几处相关联的地方需要修改，如果不知道，可以直接编译程序，它会逐个报错说no module named ‘Calendar’，因为他们调用的Calendar类已经被修改为CCalendar类，没有Calendar类了。
（1）在你调用的程序里面修改：
from tkcalendar import CCalendar （2）去tkcalendar\calendar_.py里面修改：
class CCalendar(ttk.Frame): """Calendar widget.""" date = calendar.datetime.date datetime = calendar.datetime.datetime timedelta = calendar.datetime.timedelta strptime = calendar.datetime.datetime.strptime strftime = calendar.datetime.datetime.strftime 省略下面内容 （3）去tkcalendar\dateentry.py里面修改：
from tkcalendar.calendar_ import CCalendar # temporary fix for issue #61 and https://bugs.python.org/issue38661 MAPS = {'winnative': {'focusfill': [('readonly', 'focus', 'SystemHighlight')], 'foreground': [('disabled', 'SystemGrayText'), ('readonly', 'focus', 'SystemHighlightText')], 'selectforeground': [('!focus', 'SystemWindowText')], 'fieldbackground': [('readonly', 'SystemButtonFace'), （4）去tkcalendar_init_.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e708a86ca3e4f94e8420989eef29816/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19f53bfb35ef11e78fce39a81548e522/" rel="bookmark">
			vue3 vite 前端项目主题切换（ECharts、Element Plus、图片、icon图标）解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说明 此方案使用var变量+class控制主题，并针对在修改主题时无法使用var变量控制的组件如：ECharts仅适用于vite项目（功能依赖于vite-var仓库）最终效果：对项目中的样式、iconfont图标、图片、ECharts图表、ui库进行主题的无缝切换 示例地址：在vue3+typescript-vite进行主题切换
效果预览 目录结构 . ├─ build # 预处理 │ │ │ ├─config # vite配置处理 │ │ ├─ build # 打包配置 │ │ └─ plugins # 插件管理（重要） │ └─env # 环境变量管理 │ ├─ theme # 主题文件夹 （重要） │ │ ├─light.ts # 明亮主题 │ │ └─dark.ts # 阴暗主题 │ └─ _var # 变量定义 （重要） │ ├─ src │ │ │ ├─components # 组件目录 │ │ ├─ sicon # 图标组件 │ │ │ └─index.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/19f53bfb35ef11e78fce39a81548e522/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c73ece3719f6d2417fe298a951a5f12e/" rel="bookmark">
			Android SystemUI之启动流程(一)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、简介 作为Android系统核心应用，SystemUI负责反馈系统及应用状态并与用户保持大量的交互。耳熟能详的三栏：StatusBar（状态栏）、NavigationBar（导航栏）与Notification Panel（通知栏），以及Recents（近期任务界面）。
有一点需要说明一下，Android 10之后近期列表的显示被移到Launcher app里面了。在Launcher3的一个 类中TouchInteractionService.java IBinder mMyBinder = new IOverviewProxy.Stub() 通过AIDL的方法与systemUI通信。
二、SystemUI的启动流程 1.启动入口 SystemServer private static void startSystemUi(Context context, WindowManagerService windowManager) { PackageManagerInternal pm = LocalServices.getService(PackageManagerInternal.class); Intent intent = new Intent(); intent.setComponent(pm.getSystemUiServiceComponent()); //PackageManagerService(getSystemUiServiceComponent)-&gt;R.string.config_systemUIServiceComponent-&gt;com.android.systemui/com.android.systemui.SystemUIService intent.addFlags(Intent.FLAG_DEBUG_TRIAGED_MISSING); //Slog.d(TAG, "Starting service: " + intent); context.startServiceAsUser(intent, UserHandle.SYSTEM); windowManager.onSystemUiStarted(); } startServiceAsUser方法启动SystemUIService。
2.SystemUIService @Override public void onCreate() { super.onCreate(); // Start all of SystemUI ((SystemUIApplication) getApplication()).startServicesIfNeeded(); // Finish initializing dump logic mLogBufferFreezer.attach(mBroadcastDispatcher); // For debugging RescueParty if (Build.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c73ece3719f6d2417fe298a951a5f12e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3648a295cd9a0d620d998ca9004dc53d/" rel="bookmark">
			c&#43;&#43; char指针相关的字符处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.设计一个函数 通过char*的方法将一个char数组内容赋值给另一个char数组 char* Mystrcpy(char* dest, const char* src)
{
if (dest == nullptr || src == nullptr) {
return nullptr;
}
char* tmp = dest;
while (*src != '\0')
{
*dest = *src;
dest++;
src++;
}
*dest = *src;
return tmp;
}
char arr1[] = "abc";
char arr2[] = "1234567";
char* p = Mystrcpy(arr1, arr2);
char* ptrCh2 = arr1;
2.通过 char*的方法 颠倒数组 方法1 通过 char*的方法 给一个char数组赋值给另一个char数组，且字符顺序颠倒
char test1[] = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3648a295cd9a0d620d998ca9004dc53d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb4a60ca4c04e751f42bde61ce540d12/" rel="bookmark">
			sparksql中使用with子查询，insert overwrite table的正确用法示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 set hive.exec.dynamic.partition=true;--是否允许动态分区 set hive.exec.dynamic.partition.mode=nonstrict;--分区模式设置 set spark.sql.adaptive.enabled=true; set spark.sql.adaptive.shuffle.targetPostShuffleInputSize=128MB; with v_is_freight_outstanding_cust as( select sum(un_receive_fee_amount) as un_receive_fee_amount, /**未收款额**/ sum(market_cushion_amount) as market_cushion_amount, /**垫款金额**/ payment_customer_id, dmonth from table group by bill_base.payment_customer_id,bill_base.dmonth ) insert overwrite table dws_biz.dws_biz_customer_cm partition(dmonth) select * from v_is_freight_outstanding_cust 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/608a16fa7ccae7a6d99afb467be6169d/" rel="bookmark">
			vue3组件通信方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、vue3组件通信方式 不管是vue2还是vue3,组件通信方式很重要,不管是项目还是面试都是经常用到的知识点。
比如:vue2组件通信方式
**props:**可以实现父子组件、子父组件、甚至兄弟组件通信
自定义事件:可以实现子父组件通信
全局事件总线$bus:可以实现任意组件通信
**pubsub:**发布订阅模式实现任意组件通信
vuex:集中式状态管理容器，实现任意组件通信
ref:父组件获取子组件实例VC,获取子组件的响应式数据以及方法
**slot:**插槽(默认插槽、具名插槽、作用域插槽)实现父子组件通信…
1.1props props可以实现父子组件通信,在vue3中我们可以通过defineProps获取父组件传递的数据。且在组件内部不需要引入defineProps方法可以直接使用！
父组件给子组件传递数据
&lt;Child info="我爱祖国" :money="money"&gt;&lt;/Child&gt; 子组件获取父组件传递数据:方式1
let props = defineProps({ info:{ type:String,//接受的数据类型 default:'默认参数',//接受默认数据 }, money:{ type:Number, default:0 }}) 子组件获取父组件传递数据:方式2
let props = defineProps(["info",'money']); 子组件获取到props数据就可以在模板中使用了,但是切记props是只读的(只能读取，不能修改)
1.2自定义事件 在vue框架中事件分为两种:一种是原生的DOM事件，另外一种自定义事件。
原生DOM事件可以让用户与网页进行交互，比如click、dbclick、change、mouseenter、mouseleave…
自定义事件可以实现子组件给父组件传递数据
1.2.1原生DOM事件 代码如下:
&lt;pre @click="handler"&gt; 我是祖国的老花骨朵 &lt;/pre&gt; 当前代码级给pre标签绑定原生DOM事件点击事件,默认会给事件回调注入event事件对象。当然点击事件想注入多个参数可以按照下图操作。但是切记注入的事件对象务必叫做$event.
&lt;div @click="handler1(1,2,3,$event)"&gt;我要传递多个参数&lt;/div&gt; 在vue3框架click、dbclick、change(这类原生DOM事件),不管是在标签、自定义标签上(组件标签)都是原生DOM事件。
1.2.2自定义事件 自定义事件可以实现子组件给父组件传递数据.在项目中是比较常用的。
比如在父组件内部给子组件(Event2)绑定一个自定义事件
&lt;Event2 @xxx="handler3"&gt;&lt;/Event2&gt; 在Event2子组件内部触发这个自定义事件
&lt;template&gt; &lt;div&gt; &lt;h1&gt;我是子组件2&lt;/h1&gt; &lt;button @click="handler"&gt;点击我触发xxx自定义事件&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script setup lang="ts"&gt; let $emit = defineEmits(["xxx"]); const handler = () =&gt; { $emit("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/608a16fa7ccae7a6d99afb467be6169d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb20fa4f9269303693f694bca99aeabe/" rel="bookmark">
			Flask-SocketIO
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、简介： Flask-SocketIO使Flask应用程序可以实现客户端和服务器之间的低延迟双向通信。客户端应用程序可以使用 Javascript、Python、C++、Java和Swift中的任何SocketIO客户端库或任何其他兼容客户端来建立与服务器的永久连接。
二、安装： pip install flask-socketio 三、运行Flask-SocketIO要求： Flask-SocketIO必须要Python 3.6+的版本，可以从下面三个选项中选择：
eventlet是性能最好的选择，支持长轮询和WebSocket传输。也可以使用gevent。gevent包完全支持长轮询传输，但与eventlet不同的是，gevent没有原生 WebSocket 支持。要添加对 WebSocket 的支持，目前有两个选项。安装gevent-websocket 包为 gevent 添加了 WebSocket 支持，或者可以使用带有 WebSocket 功能的uWSGI Web 服务器。使用 gevent 也是一个性能比较高的选择，但比 eventlet 略低。也可以使用基于 Werkzeug 的 Flask 开发服务器，但需要注意的是，该 Web 服务器仅用于开发用途，因此它应该仅用于简化开发工作流程，而不用于生产。 Flask-SocketIO会根据安装的包自动检测要使用的异步框架。优先使用 eventlet，其次是 gevent。对于 gevent 中的 WebSocket 支持，首选 uWSGI，其次是 gevent-websocket。如果 eventlet 和 gevent 均未安装，则使用 Flask 开发服务器。
如果使用多个进程，则必须配置消息队列服务以允许服务器协调广播等操作。支持的队列是Redis、RabbitMQ、 Kafka以及Kombu包支持的任何其他消息队列。
在客户端，可以使用官方的 Socket.IO Javascript 客户端库来建立与服务器的连接。还有用 Swift、Java 和 C++ 编写的官方客户端。非官方客户端也可以工作，只要它们实现了 Socket.IO 协议就可以。Python-SocketIO 包实现了SocketIO协议的Python客户端。（注：Python-SocketIO也是Flask-SocketIO作者写的）。
四、初始化 以下代码示例展示了如何将 Flask-SocketIO 添加到 Flask 应用程序：
from flask import Flask, render_template from flask_socketio import SocketIO app = Flask(__name__) app.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb20fa4f9269303693f694bca99aeabe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83e8b844a8b021d9b91867c84b2506e4/" rel="bookmark">
			STM32H750使用ADC采集校准提高精准度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一次发表博客，文字内容过于简单，敬请谅解！
按照公司的要求，使用STM32H750VBT6作为产品的MCU，因需要MCU的ADC高采样率和16位的分辨率，在项目的开发过程中遇到各种各样的问题，
参考：STM32使用内部参考电压提高ADC采集准确度_stm32自带adc的测量精度_家养钢铁侠的博客-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d02340136ff3e1d94cdbc4125b3f2d1/" rel="bookmark">
			前端与后端联调接口之----导出功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们先把接口写在接口的api中
import request from "../http";//引的是axios的二次封装 export function importExecl(data) { return request({ url:"/api/importExecl", method:"post", data:data }) } 接口写完，这个时候我们需要在“导出”的时候进行如下操作：
&lt;template&gt; &lt;div&gt; &lt;el-button @click="importExecl"&gt;导出&lt;/el-button&gt; &lt;el-table ref="multipleTable" :data="tableData" tooltip-effect="dark" style="width: 100%" @selection-change="handleSelectionChange"&gt; &lt;el-table-column type="selection" width="55"&gt; &lt;/el-table-column&gt; &lt;el-table-column label="日期" width="120"&gt; &lt;template slot-scope="scope"&gt;{{ scope.row.date }}&lt;/template&gt; &lt;/el-table-column&gt; &lt;el-table-column prop="name" label="姓名" width="120"&gt; &lt;/el-table-column&gt; &lt;el-table-column prop="address" label="地址" show-overflow-tooltip&gt; &lt;/el-table-column&gt; &lt;/el-table&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import { importExecl } from "./api"; export default { data() { return { tableData: [{ date: '2016-05-03', name: '王小虎', address: '上海市普陀区金沙江路 1518 弄' }, { date: '2016-05-02', name: '王小虎', address: '上海市普陀区金沙江路 1518 弄' }, { date: '2016-05-04', name: '王小虎', address: '上海市普陀区金沙江路 1518 弄' }, { date: '2016-05-01', name: '王小虎', address: '上海市普陀区金沙江路 1518 弄' }, { date: '2016-05-08', name: '王小虎', address: '上海市普陀区金沙江路 1518 弄' }, { date: '2016-05-06', name: '王小虎', address: '上海市普陀区金沙江路 1518 弄' }, { date: '2016-05-07', name: '王小虎', address: '上海市普陀区金沙江路 1518 弄' }], multipleSelection: [] } }, methods: { handleSelectionChange(val) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d02340136ff3e1d94cdbc4125b3f2d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8115506c49d6119f4a3e30a40f80301/" rel="bookmark">
			一、MATLAB R2022a安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录
前言
一、MATLAB介绍
二、MATLAB安装
总结
前言 作为21世纪的工科生，MATLAB无疑是我们搞开发设计道路上的好搭档，它那极其强大的功能，让各位工程师们对它爱不释手呀！由于MATLAB的版本较多，我们就以MATLAB R2022a版本来开启MATLAB的学习之路吧，这个版本还是比较新的，也不会有不兼容的问题发生，还是值得选择的。
下面就先从MATLAB的获取以及安装开始吧，毕竟学习一款工具肯定要先把工具装上噻！
一、MATLAB介绍 MATLAB是美国MathWorks公司出品的商业数学软件，主要用于数据分析、无线通信、深度学习、图像处理与计算机视觉、信号处理、量化金融与风险管理、机器人、控制系统等领域。这里不得不佩服这个工具的开发人员，这么复杂高深的东西到底是怎么做出来的，简直太逆天了！
获取MATLAB工具有很多渠道，这里我还是首推官网购买或者试用，如果你是学生，还可以通过学校申请使用，下面上官网链接：
MATLAB官网：
MATLAB - 技术计算语言 产品信息 (mathworks.cn)
二、MATLAB安装 注意：安装开始前，最好先关闭电脑的防火墙，避免安装失败！！！
1、下载完成后，打开MATLAB_R2022a_Windows文件夹，右击setup.exe，以管理员身份运行！
2、点击右上角高级选项，选择我有文件安装密钥！
3、在是否接受许可协议的条款后点击是，然后点击下一步！
4、输入文件安装密钥，然后点击下一步！
安装密钥：50874-33247-14209-37962-45495-25133-28159-33348-18070-60881-29843-35694-31780-18077-36759-35464-51270-19436-54668-35284-27811-01134-26918-26782-54088
5、选择许可证文件，点击浏览，选择Crack文件夹下的licecse.lic文件，并点击下一步！
6、选择MATLAB安装的文件夹路径，这里建议安装到C盘以外的磁盘，最好只修改磁盘位置，我这里是安装到D盘的，然后点击下一步！
7、 产品选择，产品选择建议默认即可，如果你磁盘空间紧张，可以根据自己需求来选择产品安装，然后点击下一步！
8、然后界面会弹出安装位置、产品个数以及所需磁盘空间等信息，点击开始安装！
9、考验耐心的时候到了，这个安装过程会比较慢，趁机摸鱼一小会儿！ 10、安装完成后点击完成关闭界面，不要急于打开软件，还有事情没做呢！
11、接下来找到Crack文件夹下的libmwlmgrimpl.dll，进行赋值，到安装目录R2022a\bin\win64\matlab_startup_plugins\lmgrimpl下，替换掉里面的.dll文件即可！
12、到此为止呢，MATLAB的安装就算完成了，接下来找到桌面的MATLAB图标并双击打开，如果没有添加桌面快捷方式，可以到安装目录\bin文件夹里面，找到matlab.exe文件，鼠标右击，发送到桌面即可！当你的MATLAB软件打开界面是这样的呢，说明你就可以在上面大展拳脚啦！！！
总结 MATLAB的安装就告一段落啦，这个安装还是比较简单的，没有特别需要注意的地方。关于电脑防火墙需要关闭的问题，反正我没有关闭防火墙安装了两次都没成功，关闭之后一次就成功了，所以还是关闭一小会儿吧，言尽于此，告辞！！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e23cf3ec2c42bbfaa5da3d7b4760b6b/" rel="bookmark">
			51单片机学习--LED点阵屏显示图形&amp;动画
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为了通用性考虑，需要把用到的几个口用特殊位声明来重新命名，由于RCLK在头文件中已有定义，所以这里把P3^5声明成RCK吧。。这样的做法可以提高可读性
sbit RCK = P3^5; //RCLK sbit SCK = P3^6; //SRCLK sbit SER = P3^4; 接下来编写74HC595的输入函数
void _74HC595_WriteByte(unsigned char Byte) { unsigned char i; for(int i = 0; i &lt; 8; i ++) { SER = Byte &amp; (0x80 &gt;&gt; i); //一个数据赋到一位上，结果非0即1，相当于取Byte的第i + 1位赋给SER SCK = 1; //移位1次 SCK = 0; //手动恢复 } } void main() { SCK = 0; //移位初始是0 while(1) { } } 执行完八次循环后数据就会存到移位寄存器里面了，接下来要输出只需要给RCLK一个高电平即可
给个完整代码
#include &lt;REGX52.H&gt; sbit RCK = P3^5; sbit SCK = P3^6; sbit SER = P3^4; void _74HC595_WriteByte(unsigned char Byte) { unsigned char i; for(i = 0; i &lt; 8; i ++) { SER = Byte &amp; (0x80 &gt;&gt; i); //一个数据赋到一位上，结果非0即1，相当于取Byte的第i + 1位赋给SER SCK = 1; //移位1次 SCK = 0; //手动恢复 } RCK = 1; //输出 RCK = 0; //手动恢复 } void main() { P0 = 0; SCK = 0; //移位初始是0 RCK = 0; //锁存初始是0 _74HC595_WriteByte(0xf0); while(1) { } } 输入了0xf0即为1111 0000 ，而P0全部置0，所以呈现出一半一半的现象！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e23cf3ec2c42bbfaa5da3d7b4760b6b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/019bd060cad980cc3c1ffc410e6dd26c/" rel="bookmark">
			Linux C语言使用＜sys/queue.h＞非递归遍历指定目录下的所有文件及目录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux C语言非递归遍历指定目录下的所有文件及目录
书接上回，在上面的链接中，我们使用了自己编写的双向循环链表完成了非递归版本的目录遍历。
由于每个程序员对链表的定义及实现方式各不相同，其正确性也需要验证。因此，出于对编程规范性和统一性的考虑，我们应该使用Linux系统中提供的链表。这样不仅可以规范代码，代码的阅读者也无需关注链表的实现方式是否正确。
下面我们就来使用queue.h头文件中定义的结构体和接口来实现非递归目录的遍历，并对之前的版本进行一些优化。
queue.h queue官方手册
在此头文件中，定义了五种链表形式：
SLIST 单向链表LIST 双向链表STAILQ 单向有尾链表TAILQ 双向有尾链表CIRCLEQ 双向循环链表 其具体的定义及结构在下面的文章中有详细说明
Linux内嵌链表（sys/queue.h）详解
在使用时我们需要包含头文件#include &lt;sys/queue.h&gt; 双向链表TAILQ和CIRCLEQ均可以满足要求，这里我们选择TAILQ作为实现方式，其相关定义及接口如下
（图片来自大佬tissar的博客https://blog.csdn.net/tissar/article/details/86978743）
/* * Singly-linked Tail queue declarations. */ #define STAILQ_HEAD(name, type) \ struct name { \ struct type *stqh_first; /* first element */ \ struct type **stqh_last; /* addr of last next element */ \ } #define STAILQ_HEAD_INITIALIZER(head) \ { NULL, &amp;(head).stqh_first } #define STAILQ_ENTRY(type) \ struct { \ struct type *stqe_next; /* next element */ \ } /* * Singly-linked Tail queue functions.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/019bd060cad980cc3c1ffc410e6dd26c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30701e3b4ef4b5ece88737f6a776c198/" rel="bookmark">
			Linux C语言递归遍历指定目录下的所有文件及目录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		预备知识 DIR结构体 DIR是linux下用于记录目录信息的结构体，其具体定义如下：
struct __dirstream { void *__fd; char *__data; int __entry_data; char *__ptr; int __entry_ptr; size_t __allocation; size_t __size; __libc_lock_define (, __lock) }; typedef struct __dirstream DIR; opendir 头文件：
#include &lt;sys/types.h&gt; #include &lt;dirent.h&gt; 函数声明：DIR *opendir(const char *name);
参数：
name：文件夹路径字符串。可以是绝对路径，也可以是相对路径。
返回值：打开成功返回一个DIR指针，失败返回NULL
dirent结构体 该结构体用于描述当前目录下的某个实例的信息。该实例既可以是普通文件，也可以是文件夹，也可以是管道文件、套接字等其他类型。
其定义如下：
struct dirent { ino_t d_ino; /* inode number */ off_t d_off; /* offset to the next dirent */ unsigned short d_reclen; /* length of this record */ unsigned char d_type; /* type of file */ char d_name[256]; /* filename */ }; 其中d_type字段表示当前实例的类型，其可能取值如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/30701e3b4ef4b5ece88737f6a776c198/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c988094cab464d47fe342d16463210e4/" rel="bookmark">
			git cherry-pick 教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于多分支的代码库，将代码从一个分支转移到另一个分支是常见需求。
这时分两种情况。一种情况是，你需要另一个分支的所有代码变动，那么就采用合并（git merge）。另一种情况是，你只需要部分代码变动（某几个提交），这时可以采用（cherry pick）。
一、基本用法 git cherry-pick命令的作用，就是将指定的提交（commit）应用于其他分支。
$ git cherry-pick &lt;commitHash&gt; 上面命令就会将指定的提交commitHash，应用于当前分支。这会在当前分支产生一个新的提交，当然它们的哈希值会不一样。
举例来说，代码仓库有 master 和 feature 两个分支。
a - b - c - d Master \ e - f - g Feature 现在将提交 f 应用到 master 分支。
# 切换到 master 分支
$ git checkout master
# Cherry pick 操作
$ git cherry-pick f
上面的操作完成以后，代码库就变成了下面的样子。
a - b - c - d - f Master \ e - f - g Feature 从上面可以看到，master 分支的末尾增加了一个提交 f 。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c988094cab464d47fe342d16463210e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1adb76cfee2ab5a4489db977896ea53/" rel="bookmark">
			Dart中 级联操作符「..」和 扩展运算法「...」
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Dart语言中，. . 是级联操作符的意思； … 是扩展运算法的意思，扩展运算符比较常见，在js等语言中经常使用。
级联操作符「. .」 级联操作符可以在同一个对象上连续调用多个函数以及访问成员变量。
Dart 当中的 「. .」意思是 「级联操作符」，为了方便配置而使用。「. .」和「.」不同的是 调用「. .」后返回的相当于是 this，而「.」返回的则是该方法返回的值 。
Demo：
void test() { CascadingOperator operator = new CascadingOperator(); operator ..A() ..B() ..C(); } class CascadingOperator { void A() { print("这是方法A"); } String B() { var k = "这是方法B"; print(k); return k; } void C() { print("这是方法C"); } } 输出： 这是方法A 这是方法B 这是方法C 按照Java写法，A() B() C()三个方法返回值需要改为CascadingOperator对象，才能实现链式调用，但在Dart中可以通过级联操作符 … 直接实现(但是 B()方法返回值会被忽略)。
扩展运算符「…」 Dart 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e1adb76cfee2ab5a4489db977896ea53/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/484851adc4521c714935d47384d8e20c/" rel="bookmark">
			若依前后端分离框架配置knife4j
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先在后台代码–admin模块里添加依赖
&lt;dependency&gt; &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt; &lt;artifactId&gt;knife4j-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.0.3&lt;/version&gt; &lt;/dependency&gt; 然后再swaggerConfig里添加一段代码：
private final OpenApiExtensionResolver openApiExtensionResolver; @Autowired public SwaggerConfig(OpenApiExtensionResolver openApiExtensionResolver) { this.openApiExtensionResolver = openApiExtensionResolver; } 最后在配置文件application.yml里面添加一下几行代码：
knife4j: # 开启增强配置 enable: true # 开启生产环境屏蔽 production: true时就访问不了swagger了 production: false 这时就可以在浏览器 访问了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e116080869a456144c57ec66b92c797f/" rel="bookmark">
			SVN安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SVN安装教程
1.1、TortoiseSVN 安装
先安装TortoiseSVN，然后安装汉化包
安装成功之后，所有的操作都是“右键”
安装成功的标记
1.1、创建仓库
我们把TortoiseSVN安装好后，先创建文件夹，然后鼠标右键创建
1.2SubversionSVN服务器的安装
安装我们的SVN服务器。
测试安装
我们把Subversion安装好后，打开cmd进行测试是否安装成功 命令：svn --version 如果出错，检查我们的环境变量。
2.检查path系统环境变量
1.2.1、注册服务
目的：注册服务我们可以快速的启动svn，方便我们的开发。
1、. 注册“服务”
配置这个的目的（重点）：
我们在cmd操作SVN服务的启动，每次都要打开窗口来进行启动很麻烦，那我们进行windows服务的注册，让我们一开机就启动。
sc create svn binpath= "F:\SVN\bin\svnserve.exe --service -r G:\repository\svn" displayname= "SVN-Service" start= auto depend= Tcpip
svn：我们要在servers.msc服务注册的一个名称
F:\SVN\bin：我们SVN的安装目录
G:\repository\svn：我们的仓库的路径
图示：
2、 启动或停止“服务”
3、.“运行”，services.msc 打开“服务”
4、 删除“服务”（如果你之前安装的话，那么这是删除的方法）
1.3、svn权限
1.3.1找到conf文件夹
在我们创建的仓库中找到àconf文件夹，有3个配置文件，我们需要谨记。
authz:权限认证配置
passwd:账号配置
svnserve.conf:核心配置文件：用于启动权限、确定账号文件位置，确定权限文件位置。
权限需要3个配置文件
1.3.2svnserve.conf
开启认证 打开svnserve.conf文件，大概在19到20行左右，我们需要开启权限认证，关闭匿名访问。
#的作用：注释
把#号删除表示开启
把#号添加表示注释
确定账号配置文件位置
打开svnserve.conf文件，大概在27行左右，我们需要确定账号配置文件位置
我们需要把前面的#号去掉即可
确定认证配置文件位置
打开svnserve.conf文件，大概在36行左右，我们需要确定认证配置文件位置
我们需要把前面的#号去掉即可
1.3.3、passwd 账号配置
打开passwd文件（一行一个账号，账号用户名和密码组成，使用等号分隔）
1.3.4、authz 认证配置文件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e116080869a456144c57ec66b92c797f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91d51540f5f2b3e7ea8434f38f91b88a/" rel="bookmark">
			Qt获得windows屏幕的缩放倍数的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.使用Qt的封装函数：
#include &lt;QScreen&gt; QScreen *screen = qApp-&gt;primaryScreen(); qreal dotsPerInch = screen-&gt;logicalDotsPerInch(); /* 单位内的点数 */ double screenScale = (double)dotsPerInch / 96.0; 2.使用c++函数：需要添加的系统库为 ：Gdi32.lib User32.lib
#include &lt;windows.h&gt; #pragma comment (lib,"Gdi32.lib") #pragma comment (lib,"User32.lib") HDC hd = GetDC(NULL); int horDPI = GetDeviceCaps(hd, LOGPIXELSX);//水平缩放倍数 int verticalDPI = GetDeviceCaps(hd, LOGPIXELSY);//垂直缩放倍数 double sceenScale = (double)verticalDPI /96.0; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e8844c395c98a82bc13f8c2df8528d1/" rel="bookmark">
			SQL Server 2014下载及安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、下载
二、安装
1.安装sql server 2014
2.报错后，安装net framework 3.5
3.继续安装
4.补丁SP3安装
三、用管理工具连接sql
一、下载 sql server 2014安装包与sp3补丁
二、安装 1.安装sql server 2014 选中下载的iso文件，右击装载。（win10系统可以装载，但有些系统不支持，需要安装Daemon Tools软件去打开）
​
双击运行setup
​
安装
​
直接点击下一步。
​
勾选接受许可条款，下一步。
​
功能选则，可以全选（占用存储空间大），也可以勾选必要的功能（推荐），其余功能可以后续再添加。
SQLServer安装必选功能：
SQL Server复制 客户端工具连接 客户端工具向后兼容性
客户端工具 SDK
管理工具 - 基本
SQL 客户端连接 SDK
点击下一步后，可能会出现如下报错。原因是系统未安装net framewodrk 3.5。 此时需要退出sql安装，执行步骤2安装net framework 3.5，然后再次按步骤1执行。未报错则进行步骤3。
2.报错后，安装net framework 3.5 电脑上打开控制面板-程序-程序和功能（不同版本系统打开方式有所差别），点击启用或关闭Windows功能。
选中.net framework 3.5，点击确定。
点击让Windows更新为你下载文件（注意：需要上网）
然后会下载并自动安装。
3.继续安装 这里选择默认实例，下一步。
​
服务器配置，选择混合模式，设置sa密码，添加当前用户。数据目录可以设置数据存放目录。点击下一步，并安装即可。
​
点击安装 安装成功，关闭。
​
4.补丁SP3安装 双击补丁应用程序，提取文件。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e8844c395c98a82bc13f8c2df8528d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2300be62a6fd9118054bae7f27704589/" rel="bookmark">
			使用docker (Ubuntu 20.04)编译Android源码AOSP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ubuntu 1804和2004支持直接编译AOSP 编译AOSP源码，使用比较多的是Ubuntu 18.04和20.04，这2个版本的系统可以按照Google官方的操作步骤进行编译。
个人感觉20.04比18.04更好用一些，主要是UI/UE方面的差别（对AOSP编译没什么差别），20.04用起来更顺手，18.04有些操作比较别扭。
另外，如果要开发Linux C/C++程序，新版本的系统会支持更新的编译器和对应的语言版本，旧版本的系统原则上可以单独更新编译器及相关依赖库，但操作比较麻烦，而且未必能够成功。
Ubuntu 2204适用docker编译AOSP 如果要尝鲜用Ubuntu 22.04或者更新的版本，可以使用docker环境安装Ubuntu 20.04编译AOSP。
本文说明的使用场景：
1）物理机上（Host OS）安装的是22.04版本，用于管理源码（git/repo）、编辑代码、开发板调试和验证。
2）docker安装20.04版本系统（Container OS），用于编译。
主要配置步骤 1）安装docker镜像，并搭建AOSP编译环境。
2）把docker内的用户和文件路径和外面系统做好关联，避免权限等问题，方便开发。
（1）启动docker image时，通过参数-v把AOSP源码目录挂载到Container上。
（2）在容器内创建和外面Host OS中同样的用户（相同的uid、gid），这样容器内外修改文件不存在权限不一致的问题。
配置操作详细说明 1. 安装docker软件 $ sudo apt install docker.io 2. 配置当前用户（非root）docker执行权限 把当前用户添加到docker组中，并更新当前执行命令的shell的group id。
这样，就无需使用root权限运行docker命令。
我使用的系统中，前2条命令不用执行，安装docker.io后都已经设置好了。
$ sudo chown root:docker /var/run/docker.sock $ sudo groupadd docker $ sudo gpasswd -a $USER docker $ newgrp docker 在Host OS（Ubuntu 22.04）中查看当前用户id：
$ id uid=1000(dev) gid=1000(dev) groups=1000(dev),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),122(lpadmin),135(lxd),136(sambashare) user: dev
uid: 1000
gid: 1000
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2300be62a6fd9118054bae7f27704589/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/301917d5829a47ef463d70b6ed8cf0d8/" rel="bookmark">
			【element-ui 级联选择器调节高度 el-cascader】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记录一个问题，在往上搜了好久没有解决
el-cascader调节高度需要设置全局样式
在 App.vue中加入以下样式即可
.el-cascader-panel { height: 315px; border-radius: 4px; } .el-scrollbar__wrap { overflow: initial !important } 不加.el-scrollbar__wrap 设置高度之后 下面会出现一个灰色的滚动条阻止组件向下铺数据
注意 一定要加 !important 否则CSS不生效
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef08ff920d41d4ffb79bc06db914274d/" rel="bookmark">
			2023年最新前端学习路线【超详细版】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一个月、HTML+CSS 第1周安排：
是了解前端入门的第一步，要学会IDE插件安装和使用，掌握H5语法和基础标签的应用，学完本周可以进行简单的页面搭建。
1、了解前端行业发展2、了解HTML5对于网页的意义3、学习常用标签/属性，进行结构搭建4、掌握无序列表/有序列表/自定义列表5、学习表单标签/属性，能创建常见表单结构6、掌握标签嵌套规则/行内元素/块元素的使用7、学习VSCode开发工具使用，能创建简单网页 学习资源：
课程：前端HTML5+CSS3+移动Web全套教程
第2周安排：
CSS3是网页的"美容师"，本周开始学习CSS3样式，掌握语法结构、选择器、盒子模型、文本和字体样式设置，能够对网页进行简单的样式开发。
1、掌握CSS3的基本语法和使用2、掌握CSS3各类型选择器/样式属性，进行快速开发3、学习文本、字体等常见属性4、盒子模型核心知识讲解，深入理解原理5、掌握行内元素和块级元素设置与转换 学习资源：
课程：前端HTML5+CSS3+移动Web全套教程
第3周安排：
简单的样式开发还不够，通过掌握浮动、定位、边框、背景样式以及2D&amp;3D转换，以及布局技巧。能够进行特殊图形绘制，开发更美观的网页效果。
1、浮动与定位核心知识，灵活运用实现网页布局2、常见布局方法，解决布局常见问题3、如何绘制圆角边框/阴影框/图片边框等特殊图形4、掌握元素扭曲/移位/旋转，更自由的装饰HTML5、BFC规范和浏览器差异 第4周安排：
CSS3也能实现炫酷的网页动态效果，结合企业级上线“旅游网”项目，综合运用前面所学的知识，完成穷游首页排版布局和CSS3动画特效开发。
1、大项目：结合H5/CSS3，完成PC小兔仙首页布局开发2、掌握不同布局结构与技巧3、掌握过渡的使用与缓动效果，实现常见小案例4、运用动画效果，实现炫酷动画效果 第一个月课程表汇总：
前端HTML5+CSS3+移动Web全套教程，零基础学前端web首选黑马程序员
一个月详细的课程表，结合思维导图时间安排学习！
课程目录详情HTML认知1. HTML的基本语法
2. HTML的排版标签3. 绝对路径和相对路径4. HTML的多媒体标签5. HTML的链接标签6. 案例：招聘案例、今日热词案例HTML基础1. HTML的列表标签
2. HTML的表格标签3. HTML的表单系列标签4. HTML的语义化布局标签 5. HTML的字符实体6.案例：学生信息表格案例、会员注册表单案例CSS基础选择器+字体文本样式1. CSS的引入方式
2. CSS的标签、类、ID、通配符选择器3. CSS的字体相关样式4. CSS的文本相关样式5. CSS的水平居中技巧6. Chrome调试工具的使用7. 案例：新闻网页案例、卡片居中案例CSS选择器进阶+背景相关属性+元素显示模式+三大特性1. CSS的后代、子代、并集、交集选择器
2. emmet基本语法3. hover伪类选择器4. CSS的背景相关属性5. 三种常见的元素显示模式6. CSS三大特性：继承性7. CSS三大特性：层叠性8. 案例：五彩导航案例CSS盒子模型1. CSS三大特性：优先级
2. CSS的权重叠加计算方法3. 盒子模型的组成部分4. 盒子模型的边框、内边距、外边距的作用和代码实现5. 外边距折叠现象6. 案例：新浪导航案例、网页新闻列表案例CSS浮动1. CSS的结构伪类选择器
2. 伪元素的基本使用3. 标准流的排布规则4. 浮动的特点和使用5. 清除浮动的常见方法6. 案例：小米布局案例、网页导航案例CSS定位+装饰1. 定位的特点和使用
2. 垂直对齐方式3. 边框圆角完成正圆和胶囊按钮效果4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef08ff920d41d4ffb79bc06db914274d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/acb40b2b89fdb07cd4c2db436b84040f/" rel="bookmark">
			apache poi 设置背景颜色
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		apache poi 设置背景颜色 要设置 Apache POI 中 HSSFCellStyle 的背景颜色，你可以按照以下步骤进行操作：
首先，创建一个 HSSFWorkbook 对象来表示你的 Excel 工作簿： HSSFWorkbook workbook = new HSSFWorkbook(); 然后，创建一个 HSSFSheet 对象来表示你的 Excel 工作表： HSSFSheet sheet = workbook.createSheet("Sheet1"); 接下来，创建一个 HSSFCellStyle 对象，并为其设置背景颜色。你可以使用 setFillBackgroundColor() 方法来设置背景颜色，传入一个 short 类型的颜色索引或者一个 HSSFColor 对象： HSSFCellStyle cellStyle = workbook.createCellStyle(); cellStyle.setFillForegroundColor(IndexedColors.YELLOW.getIndex()); // 使用颜色索引设置背景颜色 // 或者 cellStyle.setFillForegroundColor(HSSFColor.YELLOW.index); // 使用 HSSFColor 对象设置背景颜色 注意：在这里，我使用了 IndexedColors 类提供的一些常见颜色，你也可以自定义颜色。
最后，将样式应用到单元格上。创建一个 HSSFCell 对象，并为其设置样式： HSSFRow row = sheet.createRow(0); HSSFCell cell = row.createCell(0); cell.setCellValue("Hello, World!"); cell.setCellStyle(cellStyle); // 应用样式到单元格上 最后，将工作簿写入到文件或输出流中： FileOutputStream fileOut = new FileOutputStream("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/acb40b2b89fdb07cd4c2db436b84040f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6265de6b4d9d6137d27a5e893eb85a5/" rel="bookmark">
			展锐power_supply 目录下属性节点生成流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		相关文章 展锐USB 插拔更新充电状态分析展锐USB充电图标更新流程 介绍 在展锐的系统目录下可以看到如下几个目录
sys/class/power_supply/ac 外部充电器充电相关sys/class/power_supply/usb usb充电相关sys/class/power_supply/battery 电池状态相关 当设备充电时，会显示充电图标和充电动画， 整个充电状态的显示其实是通过读取sys/class/power_supply 目录下的属性文件控制的，当我们插入USB充电时，sys/class/power_supply/usb/online 节点会置为1，表示USB 已经插入，并且sys/class/power_supply/battery/status 节点会置为Charging 状态，此时Status Bar Battery图标上面会显示一个闪电图标和充电动画。
这篇文章将会梳理sys/class/power_supply 目录和其下各个属性节点的创建流程。
1. 创建ac、usb、battery 等目录 bsp/kernel/kernel4.14/drivers/power/supply/charger-manager.c static int charger_manager_init_psy(struct charger_manager *cm) { struct charger_policy *policy = &amp;(cm-&gt;policy); struct power_supply_config batt_cfg = {}; batt_cfg.drv_data = cm; batt_cfg.of_node = cm-&gt;dev-&gt;of_node; // 注册sys/class/power_supply/interface 节点 policy-&gt;interface_psy = devm_power_supply_register(cm-&gt;dev, &amp;interface_psy_desc, &amp;batt_cfg); if (IS_ERR(policy-&gt;interface_psy)) { vote_debug("Couldn't register interface_psy power supply\n"); return PTR_ERR(policy-&gt;interface_psy); } // 注册sys/class/power_supply/hook 节点 policy-&gt;hook_psy = devm_power_supply_register(cm-&gt;dev, &amp;hook_psy_desc, &amp;batt_cfg); if (IS_ERR(policy-&gt;hook_psy)) { vote_debug("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c6265de6b4d9d6137d27a5e893eb85a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f0e8a18bcb0dac833c537f0757f9e48/" rel="bookmark">
			c语言编程数组求和以及求最大值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include &lt;stdio.h&gt;
int arr[10] = {6,3,5,2,4,20,7,1,23,11};
int main()
{
//数组求和
int sum = 0;
int i;
for(i=0; i&lt;10; i++)
{
//遍历数组
sum += arr[i];
}
printf("sum=%d\n",sum);
//求数组最大下标和最大值
int maxi = 0 ; //存储最大值的下标
for(i=1; i&lt;9; i++ )
{
if( arr[maxi] &lt; arr[i])
{
maxi = i; //更新最大值的下标
}
}
printf("数组最大值为arr[%d]=%d\n",maxi, arr[maxi]);
return 0;
}
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/106/">«</a>
	<span class="pagination__item pagination__item--current">107/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/108/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>