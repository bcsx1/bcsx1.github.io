<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32bb765115a915a04b4e1acf4261c2b1/" rel="bookmark">
			网络安全之CSRF漏洞原理和实战，以及CSRF漏洞防护方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、引言 总体来说CSRF属于一种欺骗行为，是一种针对网站的恶意利用，尽管听起来像跨站脚本（XSS），但是与XSS非常不同，并且攻击方式几乎向佐。XSS利用站点内的信任用户，而CSRF则通过伪装来自受信任用户的请求来利用受信任的网站。一般CSRF与XSS相结合更具危险性。这种攻击对受害人的影响或造成的损失是最大的，反而对受攻击网站本身威胁不大。
CSRF一般分为：HTML CSRF、JSON HiJacking 和 Flash CSRF
二、CSRF漏洞的原理 跨站请求攻击，简单地说，是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并运行一些操作（如发邮件，发消息，甚至财产操作如转账和购买商品）
下面是攻击工程模拟的场景：
1、用户C打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A；
2、在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A；
3、用户未退出网站A之前，在同一浏览器中，打开一个TAB页访问网站B；
4、网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A；
5、浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A发出请求。网站A并不知道该请求其实是由B发起的，所以会根据用户C的Cookie信息以C的权限处理该请求，导致来自网站B的恶意代码被执行。
整个过程如下图：
从这个攻击过程可以得知，攻击的先决条件是用户已经登陆了站点A，并在本地记录了cookie，并且用户没有退出站点A，且站点A的token或 Session并未过期，其次站点A并没有做任何CSRF防御。
为了便于理解，我们先列举一个场景
场景需求：
小黑想要修改大白在购物网站tianxiewww.xx.com上填写的会员地址。
先看下大白是如何修改自己的密码的：
登录—修改会员信息，提交请求—修改成功。
所以小黑想要修改大白的信息，他需要拥有：1，登录权限 2，修改个人信息的请求。
但是大白又不会把自己xxx网站的账号密码告诉小黑，那小黑怎么办？
于是他自己跑到www.xx.com上注册了一个自己的账号，然后修改了一下自己的个人信息（比如：E-mail地址），他发现修改的请求是：
【http://www.xxx.com/edit.php?email=xiaohei@88.com&amp;Change=Change】
于是，他实施了这样一个操作：把这个链接伪装一下，在小白登录xxx网站后，欺骗他进行点击，小白点击这个链接后，个人信息就被修改了,小黑就完成了攻击目的。
为啥小黑的操作能够实现呢。有如下几个关键点：
1.www.xxx.com这个网站在用户修改个人的信息时没有过多的校验，导致这个请求容易被伪造;
—因此，我们判断一个网站是否存在CSRF漏洞，其实就是判断其对关键信息（比如密码等敏感信息）的操作(增删改)是否容易被伪造。
2.小白点击了小黑发给的链接，并且这个时候小白刚好登录在购物网上;
—如果小白安全意识高，不点击不明链接，则攻击不会成功，又或者即使小白点击了链接，但小白此时并没有登录购物网站，也不会成功。
—因此，要成功实施一次CSRF攻击，需要“天时，地利，人和”的条件。
当然，如果小黑事先在xxx网的首页如果发现了一个XSS漏洞，则小黑可能会这样做： 欺骗小白访问埋伏了XSS脚本（盗取cookie的脚本）的页面，小白中招，小黑拿到小白的cookie，然后小黑顺利登录到小白的后台，小黑自己修改小白的相关信息。
—所以跟上面比一下，就可以看出CSRF与XSS的区别：CSRF是借用户的权限完成攻击，攻击者并没有拿到用户的权限，而XSS是直接盗取到了用户的权限，然后实施破坏。
因此，网站如果要防止CSRF攻击，则需要对敏感信息的操作实施对应的安全措施，防止这些操作出现被伪造的情况，从而导致CSRF。比如：
–对敏感信息的操作增加安全的token；
–对敏感信息的操作增加安全的验证码；
–对敏感信息的操作实施安全的逻辑流程，比如修改密码时，需要先校验旧密码等。
如果你没有读太明白,不要犹豫,请再读一遍啦。
接下来我们尝试不同类型的CSRF攻击过程：
三、CSRF漏洞的类型 节目开始之前推荐一个较好的可以进行csrf练习的地方 Pikachu漏洞平台，如果你是一个Web渗透测试学习人员且正发愁没有合适的靶场进行练习，那么Pikachu可能正合你意，需要下载下来然后自己搭建一下Pikachu漏洞平台搭建步骤。
搭建好之后如上
3.1. GET型CSRF攻击 发送get请求情况，通常我们在编写代码的时候针对发送get请求的情况比较多，比如点击html的a标签，img标签，或者主动构造参数发送get请求，所有的Get请求参数均会被拼接到url上面，所以可以通过简单的构造url就可以完成攻击。接下来我们将在Pikachu漏洞平台演示CSRF的GET攻击
步骤一、打开Pikachu，选择get方式的csrf
第二步、随便登录一个账号: vince/allen/kobe/grady/kevin/lucy/lili,密码均为123456, 比如登录lili， 然后使用burpsuite抓取修改个人信息的数据包, 或者F12打开控制台切换至Network进行抓包
第三步、我们将抓取到的url的请求参数修改成自己的, 例如将邮箱参数修改成hacker@qq.com, 那么构成的CSRF攻击payload为
http://127.0.0.1/pikachu/vul/csrf/csrfget/csrf_get_edit.php?sex=boy&amp;phonenum=18626545453&amp;add=chain&amp;email=hacker@qq.com&amp;submit=submit 这里面用户的登录唯一标识是PHPSESSID里面的那一串值
若用户点击了上述伪造的url, 则会将用户自己的邮箱修改成hacker@qq.com，即完成了一次CSRF的攻击。
同理可以将受害者用户的用户名密码进行修改，攻击者就可以登录受害者的账户啦，从这个实例大家可能看到的都是lili这个账户自己将邮箱修改为hacker@qq.com，但是如果CSRF攻击配合XSS攻击，那么首先用户通过XSS攻击获得受害者的cookie/token，就比如上题里面的PHPSESSID，然后再构造新的请求，带上登录认证的cookie信息或token信息，那不就危害加成了嘛。
3.2. POST型CSRF攻击 虽然POST请求无法通过伪造URL进行攻击, 但是可以通过伪造恶意网页, 将伪造的POST请求隐藏在恶意网页的表单中, 然后诱引用户点击按钮提交表单, 数据自然就POST至存在CSRF漏洞的网页, 最终用户的信息会被修改
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/32bb765115a915a04b4e1acf4261c2b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/965f3c841d263bbfdf7fa6e3a3c205c8/" rel="bookmark">
			【前端】Jquery UI &#43;PHP 实现表格拖动排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目的：使用jquery ui库实现对表格拖拽排序，并且把排序保存到数据库中
效果如下
一、准备工作： 1、下载jquery ui库，可以直接引用线上路径
&lt;link rel="stylesheet" href="https://code.jquery.com/ui/1.12.1/themes/base/jquery-ui.css"&gt;
&lt;script src="https://code.jquery.com/ui/1.12.1/jquery-ui.min.js"&gt;&lt;/script&gt;
2、前端我使用的是layui，后端是PHP
二、使用 逻辑说明
1、引入jqueryui库
2、js代码使用jqueryui的update()方法，获取拖动的条目id和当前页码，发送到后台
3、由于我这里后端使用了thinkphp的paginate进行分页，所以为保证在非第一页的拖拽顺序能后前后连上，对页码进行判断，当page=0或page=1时，都令page=1，当page大于1时，令page=page-1，在本身页码上减1
4、生成连续序号：设置每页显示条数pageSize（要和分页时条数一致），拿第3步计算的page乘以pageSize，再加上1，比如说第1页：(page*pageSize)+1 =&gt; (0*15)+1=1,(0*15)+2=2,...第2页时：(1*15)+1=16，(1*15)+2=17，目的是在分页时使sort条目新序号能够连接上，不会出现每翻一页都要从1开始的情况（第一页：1、2、3、...15，第二页：16、17...30，第三页：31、32...）
5、遍历所有条目，在sort的基础上加上遍历的索引值$key，为每一条目生成新的序号，最后更新数据库
前端代码
&lt;table class="layui-table box_table" lay-skin="nob" lay-size="lg" style=" text-align: center;" id="sort"&gt; &lt;thead&gt; &lt;tr&gt; &lt;td&gt;课件名&lt;/td&gt; &lt;td&gt;课件类型&lt;/td&gt; &lt;td&gt;发送班级&lt;/td&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;内容...&lt;/td&gt; &lt;td&gt;内容...&lt;/td&gt; &lt;td&gt;内容...&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; JS代码
function GetQueryString(name) { var reg = new RegExp("(^|&amp;)"+ name +"=([^&amp;]*)(&amp;|$)"); var r = window.location.search.substr(1).match(reg); if(r!=null)return unescape(r[2]); return null; } // 拖拽排序 $(document).ready(function () { $("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/965f3c841d263bbfdf7fa6e3a3c205c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04590eb3148fb6e442f1d6207ed4b264/" rel="bookmark">
			数仓实践：浅谈 Kimball 维度建模
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们不管是基于 Hadoop 的数据仓库（如 Hive ），还是基于传统 MPP 架构的数据仓库（如 Teradata ），抑或是基于传统 Oracle 、MySQL 、SQL Server 关系型数据库的数据仓库，其实都面临如下问题：
怎么组织数据仓库中的数据？
怎么组织才能使得数据的使用最为方便和便捷？
怎么组织才能使得数据仓库具有良好的可扩展性和可维护性？
Kimball 维度建模理论很好地回答和解决了上述问题。
维度建模理论和技术也是目前在数据仓库领域中使用最为广泛的、也最得到认可和接纳的一项技术。今天我们就来深入探讨 Ralph Kimball 维度建模的各项技术，涵盖其基本理论、一般过程、维度表设计和事实表设计等各个方面，也为我们后面讲Hadoop 数据仓库实战打下基础。
度量和环境 维度建模是支持对业务过程的分析，所以它是通过对业务过程度量进行建模来实现的。
那么，什么是度量呢？
实际上，我们通过和业务方、需求方交谈，或者阅读报表、图表等，可以很容易地识别度量。
考虑如下业务需求：
店铺上个月的销售额如何？
店铺库存趋势如何？
店铺的访问情况如何（ pv，uv) ?
店铺访问的熟客占比多少？
“ 这里的销售额、库存、访问量、熟客量就是度量。”
“ 但是，单单谈论度量，是没有意义的。”
度量和环境这两个概念构成了维度建模的基础。而所有维度建模也正是通过对度量和及其上下文和环境的详细设计来实现的。
事实和维度 在 Kimball 的维度建模理论中，“ 度量称为事实，上下文和环境则称为维度。”
通常来说，事实常以数值形式出现，而且一般都被大量文本形式的上下文包围着。
这些文本形式的上下文描述了事实的“ 5个W ”（ When 、 Where 、 What 、 Who 、 Why ）信息，通常可被直观地分割为独立的逻辑块，每一个独立的逻辑块即为一个维度，比如一个订单可以非常直观地分为商品 、买家、卖家等多个维度。
在维度建模和设计过程中，可以根据需求描述或者基于现有报表，很容易地将信息和分析需求分类到事实和度量中。
比如业务人员需求为“按照一级类目，统计本店铺上月的销售额情况”，“按照一级类自”这个描述，很清楚地说明需求方希望对一级类目的销售额进行统计分析，这里的一级类目即为一个维度 。类似的是，“上月”为另一个维度，而销售额明显是事实。
事实表 事实表是维度模型中的基本表，或者说核心表。
事实上，业务过程的所有度量在维度建模中都是存储在事实表中的，除此之外，事实表还存储了引用的维度。
事实表通常和一个 企业的业务过程 紧密相关，由于一个企业的业务过程数据构成了其所有数据的绝大部分，因此事实表也通常占用了数据仓库存储的绝大部分。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04590eb3148fb6e442f1d6207ed4b264/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dcae8fb10f0dd8fc09df8c20c6ffc1eb/" rel="bookmark">
			【C&#43;&#43;】round()、ceil()和floor()函数详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文通过参数详解和示例对round()、ceil()和floor()三个函数进行详解，以帮助大家理解和应用。
round()函数 在C++中，round()函数是标准库 中的一个函数，用于对浮点数进行四舍五入。
函数原型为：
double round(double x); 参数x是一个双精度浮点数。
round()函数将返回最接近参数x的整数。如果x正好在两个整数中间，则向远离零的整数方向取整。例如：
#include &lt;iostream&gt; #include &lt;cmath&gt; int main() { double num1 = 2.3; double num2 = -2.3; std::cout &lt;&lt; "round(2.3) is: " &lt;&lt; round(num1) &lt;&lt; std::endl; // 输出 "round(2.3) is: 2" std::cout &lt;&lt; "round(-2.3) is: " &lt;&lt; round(num2) &lt;&lt; std::endl; // 输出 "round(-2.3) is: -2" return 0; } ceil()函数 ceil()函数是一个数学函数，用于向上取整。也就是说，无论一个数的实际值有多接近于零，ceil()函数都会将其结果设置为比这个数稍大的最小的整数。
在C++中，ceil()函数是数学库中的一个函数，用于计算并返回大于或等于给定数字的最小整数。
函数原型为：double ceil(double x);
参数：
x：要被舍入的浮点数。
返回值：
如果 x 是正数，则返回大于或等于 x 的最小整数。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dcae8fb10f0dd8fc09df8c20c6ffc1eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e805c8b03705003c84dd0ee451e708b/" rel="bookmark">
			最前端｜如何使用Plausible实现页面埋点？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、业务背景
二、业务场景描述
三、解决方案
//如何集成 Plausible ？
//如何监控特定功能使用情况？
什么是 MyEventName?
//如何向自定义事件传递参数？
一、业务背景 随着公司自研产品的不断发展，对前端页面的监控和分析变得越发重要。准确了解用户在产品上的行为和操作，以及发现潜在的性能问题或用户体验瓶颈，对于产品的持续优化和用户满意度的提升至关重要。
然而，要实现全面的前端监控并分析这些数据是一项复杂的任务，我们需要采用专业的工具和方法。本篇文章为大家带来：使用 Plausible 实现页面埋点
二、业务场景描述 在我们的自研产品中，我们面临着前端页面埋点和数据分析的需求。为了达到这一目标，我们决定采用第三方页面埋点工具，而不是选择自己造轮子。
市面上常见的 Web 分析工具能够帮助我们收集用户在页面上触发的各种事件，比如点击、页面跳转、输入等；同时也能捕捉用户在特定流程各个阶段之间的流转情况，帮助我们了解用户流失点并优化转化率。
通过对这些数据进行收集、整理和分析，我们可以深入了解用户的行为习惯，发现用户痛点，以及及时发现并解决用户体验问题。
//监控指标
在前端页面埋点中，常见的监控指标有：
页面浏览量：PV（Page View）
用户活跃度：UV（Unique Visitor）
用户停留时长
页面跳转和流量来源
特定功能使用情况
地理位置
访问设备和浏览器信息
以上只是前端埋点中的一些常见监控指标，实际上我们还可以根据业务需求和目标对指标进行定制。
三、解决方案 我们可以使用 Plausible 作为技术解决方案，Plausible Analytics 是一个简单、开源、轻量级（&lt; 1 KB）且注重隐私的 Google Analytics 替代方案。Plausible 被超过 10,000 名付费订阅用户信任，用于提供网站和业务洞察。
//如何集成 Plausible ？ 为了保证用户在使用公司产品过程中产生的行为数据的安全性，我们使用了私有化部署 Plausible 的方式作为页面埋点和数据分析的解决方案，集成步骤大致有：
在服务器上安装和配置 Plausible 服务器（后端完成）
注册账号并配置要监控的网站域名
在前端页面中集成 Plausible 的前端脚本，用于自动向服务器发送事件，并为手动发送事件提供支持，了解更多请查看 Add the script to your website在新窗口打开
配置前端脚本，指定 Plausible 服务器地址以及当前网站的站点 ID（通常为网站域名）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e805c8b03705003c84dd0ee451e708b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66fd6a509576207ae693b2bc958b7636/" rel="bookmark">
			Oracle中给表赋予权限
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Oracle数据库中，为表赋予权限的作用是允许或限制其他用户对该表进行特定操作的访问和修改。通过授权表权限，可以确保数据库的安全性和数据的保护。以下是一些常见的表权限以及它们的作用：
SELECT：允许用户查询表中的数据。INSERT：允许用户向表中插入新的数据。UPDATE：允许用户修改表中已存在的数据。DELETE：允许用户删除表中的数据。ALTER：允许用户对表进行修改和结构变更的操作。REFERENCES：允许用户在其他表中创建外键引用到该表。 可以使用GRANT语句来给表赋予权限。以下是在Oracle中给表赋予权限的语法： GRANT privileges ON table_name TO user_name; 其中，​privileges​为要授予的权限列表，多个权限之间用逗号分隔；​table_name​为要授权的表名；​user_name​为接收权限的用户或角色。
将SELECT和INSERT权限授予给另一个用户：
GRANT SELECT, INSERT ON table_name TO user_name; 如果想要撤销授权，可以使用REVOKE语句。以下是撤销表权限的语法：
REVOKE privileges ON table_name FROM user_name; 撤销指定用户对表的INSERT权限：
REVOKE INSERT ON table_name FROM user_name; 在授予权限时要慎重，仅将必要的权限授予给合适的用户，并遵循数据库的安全最佳实践。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7926889dd3d364d5541a9ff05f5ab36/" rel="bookmark">
			线性规划（基本原理&#43;例题解析）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一、什么是线性规划？
二、如何将线性规划条件化成标准形式？
三、基本概念
四、线性规划中的定理
五、例题分析
六、总结
前言 在学习了前期最优化的基本思想后，今天我们开启一个新的篇章——线性规划。
一、什么是线性规划？ 线性规划：（要求）目标函数和约束函数都是线性函数，求解的方法是单纯形法。
注：只要可行域非空有界，则线性规划一定有解，并存在于可行域的顶点或边界上。
二、如何将线性规划条件化成标准形式？ 左右两端同时乘以-1（将最大化问题转化成最小化问题）
加入松弛变量（将不等式转化为等式）
无约束变量（自由变量）转变成满足约束条件的非负数之差
三、基本概念 基：假设 A 是约束方程组的系数矩阵，秩为 m ，则 A 中一定存在 m 阶非奇异子矩阵 B，称 B 是线性规划的一个基，也称基矩阵。基的个数
基向量：矩阵 B 是由 m 个线性无关的列向量组成，可令 ，其中 为基向量。
非基向量：在与基向量选定的向量组合除外，剩余的向量称为非基向量。
基变量：与基向量 对应的 称为基变量。
非基变量：与非基变量 对应的 称为非基变量。
可行解：既满足 AX=b，又满足 基本解： 虽然满足 AX=b，但不一定满足 基本可行解： 既满足 AX=b，又满足 若：，则称它是非退化的；
若：，则称它是退化的。
四、线性规划中的定理 定理1：线性规划的可行解 为基本可行解的充要条件是：它的非零向量对应的列向量线性无关。
定理2： 是线性规划的基本可行解的充要条件是：它是线性规划的可行域的极点。
定理3：如果线性规划有可行解，则必有基本可行解。
定理4：如果线性规划的可行域 K 非空有界，则线性规划必存在最优解，且其中至少有一个基本可行解是有最优解。
定理5：如果线性规划的可行域 K 非空有界，则线性规划必存在最优解的充要条件是：对于 K 的任一极方向 ，均有。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c7926889dd3d364d5541a9ff05f5ab36/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa9ac9473be698eddb04400d0e05a3e6/" rel="bookmark">
			C#结合OpenCVSharp4图片相似度识别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OpenCVSharp4图片相似度识别 需求背景：需要计算两个图片的相似度，然后将相似的图片进行归纳
一、图片相似度算法
由于我是CRUD后端仔，对图像处理没什么概念。因此网上调研了几种相似度算法分析其适用场景。
直方图算法
获取要比较的2个图片的直方图数据，然后再将直方图数据归一化比较，最终得到一个相似指数，通过设定相似指数的边界，以此判断是否相同图片。
平均值哈希算法 aHash
转灰度压缩之后计算均值，最终通过像素比较得出哈希值，速度很快，但敏感度很高，稍有变化就会极大影响判定结果，精准度较差。因此比较适用于缩略图比较，最常用的就是以图搜图
感知哈希算法 pHash
在均值哈希基础上加入DCT（离散余弦变化），两次DCT就可以很好的将图像按照频度分开，取左上角高能低频信息做均值哈希，因此，精确度很高，但是速度方面较差一些。相比较aHash，pHash更加适合用于缩略图比较，也非常适合比较两个近似图片是否相等。
差异值哈希算法 dHash
灰度压缩之后，比较相邻像素之间差异。假设有10×10的图像，每行10个像素，就会产生9个差异值，一共10行，就一共有9×10=90个差异值。最终生成哈希值即指纹。速度上来说，介于aHash和pHash之间，精准度同样也介于aHash和pHash之间。
结构相似性算法 SSIM
SSIM(structural similarity)，结构相似性，是一种衡量两幅图像相似度的指标。SSIM算法主要用于检测两张相同尺寸的图像的相似度、或者检测图像的失真程度。原论文中，SSIM算法主要通过分别比较两个图像的亮度，对比度，结构，然后对这三个要素加权并用乘积表示。
SSIM算法在设计上考虑了人眼的视觉特性,它能够考虑到图像的结构信息在人的感知上的模糊变化，该模型还引入了一些与感知上的变化有关的感知现象，包含亮度mask和对比mask，结构信息指的是像素之间有着内部的依赖性，尤其是空间上靠近的像素点。这些依赖性携带着目标对象视觉感知上的重要信息。
经过调研对比，这里就选择SSIM算法。
二、下载OpenCVSharp4
通过NuGet包管理器进行下载。搜索OpenCVSharp4下载。
请注意其描述信息：OpenCV wrapper for .NET. Since this package includes only core managed libraries, another package of native bindings for your OS is required (OpenCvSharp4.runtime.*).
这是说：OpenCV 包只是一个核心库，如需在你的系统上使用，还需要对应的运行时包，这里是Windows系统，因此还需下载 OpenCvSharp4.runtime.win
三、 使用 在项目中引入OpenCvSharp
using OpenCvSharp; 由于OpenCVSharp4没有直接提供封装SSIM算法的接口，因此需要自行写这部分代码。完整代码如下
public Scalar Compare_SSIM(string imgFile1, string imgFile2) { var image1 = Cv2.ImRead(imgFile1); var image2Tmp = Cv2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa9ac9473be698eddb04400d0e05a3e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8e1bf57fb6582ca6118df5feaec8dcd/" rel="bookmark">
			Babylonjs学习笔记(八)——网格行为
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		书接上回，这里讨论MeshAction网格行为！！！
一、搭建基础场景 let box:AbstractMesh; let cube:AbstractMesh; let sphere:AbstractMesh; let cylinder:AbstractMesh; let mat:PBRMaterial; // 创建天空盒 const createSkyBox = (scene:Scene):void=&gt;{ const envTex = CubeTexture.CreateFromPrefilteredData('./env/environment.env',scene) scene.environmentTexture = envTex; scene.createDefaultSkybox(envTex,true,1000,0.2,true) scene.environmentIntensity = 1.5 } // 创建网格 const creatMeshes=(scene:Scene):void=&gt;{ mat = new PBRMaterial('pbr') mat.albedoColor = new Color3(1,0,0); mat.roughness =1 cube = MeshBuilder.CreateBox('cube',{size:2}) cube.material = mat cube.position = new Vector3(-4,0,0) sphere = MeshBuilder.CreateSphere('sphere',{diameter:2}) sphere.material = mat sphere.position = new Vector3(0,0,0) cylinder = MeshBuilder.CreateCylinder('cylinder',{diameter:2}) cylinder.material = mat cylinder.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a8e1bf57fb6582ca6118df5feaec8dcd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/acd3c25746a6edcd0ca2bdfca9cc26fa/" rel="bookmark">
			C&#43;&#43;解析JSON文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在上一篇博客我讲解了使用C++读取XML文件，在这篇博客中我将讲解解析JSON文件。在解析JSON文件时我使用的解析库是jsoncpp,编译平台是VS2019。希望看完本篇博客能对你有所帮助。
JSON简介 在学习解析JSON文件之前，我们应该先了解什么是JSON。
JSON简介：
JSON(JavaScript Object Notation, JS 对象简谱) 是一种轻量级的数据交换格式。它基于 ECMAScript (欧洲计算机协会制定的js规范)的一个子集，采用完全独立于编程语言的文本格式来存储和表示数据。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。
JSON: JavaScript Object Notation(JavaScript 对象表示法)JSON 是存储和交换文本信息的语法，类似 XML。JSON 比 XML 更小、更快，更易解析。JSON 易于人阅读和编写。C、Python、C++、Java、PHP、Go等编程语言都支持 JSON。 JSON的实例如下：
{ "sites": [ { "name":"百度" , "url":"www.baidu.com" }, { "name":"google" , "url":"www.google.com" }, { "name":"微博" , "url":"www.weibo.com" } ] } JSON语法：
数据在 名称/值 对中数据由逗号 , 分隔使用斜杆来转义 \ 字符大括号 {} 保存对象 { "name":"baidu", "alexa":10000, "site":null } 中括号 [] 保存数组，数组可以包含多个对象 [ "Google", "baidu", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/acd3c25746a6edcd0ca2bdfca9cc26fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/833dd81927dc0c8fb4d5802853520dd6/" rel="bookmark">
			答辩老师的23个常见问题~有备无患，欲收从速~
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先，知己知彼百战不殆，我们要知道答辩指导老师喜欢提问什么样问题，提前做好准备。其次，好的开头是成功的一大半，做好自我介绍，必不可少。
一，答辩老师的23个常见问题
不管是本科还是研究生，毕业论文的撰写是整个大学或研究生学习生涯中的一件头等大事，它不仅是对学生几年学习的一项总结，而且在很大程度上是对学习者各方面素质的一种综合考量。论文的质量如何直接关系到能否毕业以及随之而来的就业问题。毕业论文撰写完毕之后还有一项重要的程序——毕业论文答辩！这是由几位本学科专业的专家老师组成的答辩委员会。答辩的过程首先是学生对论文做出简要的陈述（10分钟左右），然后由答辩委员会针对论文提出相应问题，答辩学生经过10分钟左右的时间准备后，返回答辩室，回答刚才提出的问题。 在毕业论文答辩过程中，答辩委员会的老师们经常会提出的问有：
1、你的毕业论文采用了哪些与本专业相关的研究方法？
2、论文中的核心概念是什么？用你自己的话高度概括。
3、你选题的缘由是什么？研究具有何种现实指导意义？
4、论文中的核心概念怎样在你的文中体现？
5、从反面的角度去思考：如果不按照你说的那样去做，结果又会怎样？
6、论文的理论基础与主体框架存在何种关联？最主要的理论基础是什么？
7、质性研究与访谈法、定性研究、定量研究、调查研究、实证研究的区别？
8、经过你的研究，你认为结果会是怎样？有何正面或负面效果？
9、你的论文基础何种研究视角？是管理学、教育学、心理学还是社会学视角？
10、论文研究的对象是个体还是群体？是点的研究还是面的研究？
11、研究的应然、实然、使然分别是什么？
12、论文中的结论、建议或策略是否具有可行性和操作性？
13、研究对象是否具有可比性？研究框架是否符合论文规范（而不是写书的逻辑）！
14、自己为什么选择这个课题？
15、研究这个课题的意义和目的是什么？
16、全文的基本框架、基本结构是如何安排的？
17、全文的各部分之间逻辑关系如何？
18、在研究本课题的过程中，发现了那些不同见解？对这些不同的意见，自己是怎样逐步认识的？又是如何处理的？
19、论文虽未论及，但与其较密切相关的问题还有哪些？
20、还有哪些问题自己还没有搞清楚，在论文中论述得不够透彻？
21、写作论文时立论的主要依据是什么？
22、论文和系统有哪些不足之处？
23、论文有何创新之处?
二、毕业论文开场白模板
各位老师，上午好！我叫……，是……级……班的学生，我的论文题目是……。论文是在……导师的悉心指点下完成的，在这里我向我的导师表示深深的谢意，向各位老师不辞辛苦参加我的论文答辩表示衷心的感谢，并对三年来我有机会聆听教诲的各位老师表示由衷的敬意。下面我将本论文设计的目的和主要内容向各位老师作一汇报，恳请各位老师批评指导。 首先，我想谈谈这个毕业论文设计的目的及意义。…… 其次，我想谈谈这篇论文的结构和主要内容。 本文分成……个部分. 第一部分是……。这部分主要论述…… 第二部分是……。这部分分析…… 第三部分是…… 最后，我想谈谈这篇论文和系统存在的不足。 这篇论文的写作以及修改的过程，也是我越来越认识到自己知识与经验缺乏的过程。虽然，我尽可能地收集材料，竭尽所能运用自己所学的知识进行论文写作，但论文还是存在许多不足之处，有待改进。请各位评委老师多批评指正，让我在今后的学习中学到更多。 谢谢！
最重要的是大方得体当然态度的背后,是你要自信,无论知识还是答辩前的准备。
首先,向老师,同学问好.自我介绍:哪个专业哪个班；再介绍自己的题目,选题的原因,收集资料的来源,所费时间；再介绍自己的框架,分几部分论述；再具体介绍每部分内容......
三、备注
如果天热论文多,向老师辛苦表示下慰问,会有感情分
2.提前打听下同组同学有相同题目否,撞车的话，如你次序在后,就要相当认真的准备
3.一般都有时间要求，答辩人多时候,老师最烦多占时间者,注意不要过分详细介绍自己论文,察言观色是必要的
4.开场时候,容易紧张,可以眼观后墙,待稍微安定后,一定要有对视老师的时候,否则会被认为不自信与不礼貌
5.提醒下,与答辩老师有不同意见时候,千万不要当场顶牛.表示虚心听取,待后再与其讨论.一般老师都很反感答辩当场与学生的争论.且事后你会发现,决大多数情形,是他对。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc8a9fd4853b12281d571888eacbca46/" rel="bookmark">
			常见API网关总结分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、背景 在微服务架构之下，服务被拆的非常零散，降低了耦合度的同时也给服务的统一管理增加了难度。在旧的服务治理体系之下，鉴权，限流，日志，监控等通用功能需要在每个服务中单独实现，这使得系统维护者没有一个全局的视图来统一管理这些功能。API 网关致力于解决的问题便是为微服务纳管这些通用的功能，在此基础上提高系统的可扩展性。微服务搭配上API网关，可以使得服务本身更专注于自己的领域，很好地对服务调用者和服务提供者做了隔离。
API网关作为流量入口，公共服务接入点，公共服务扩展点，是互联网公司技术架构中重要的基础组件。http://microservices.io/总结的微服务模式中，网关已经成为服务化中的一种标准模式。http://microservices.io/patterns/apigateway.html。网关模式，被一些大的互联网公司采用。国内主要有唯品会、百度、阿里、京东、携程、有赞等，国外主要有Netflix、Amazon、Msahape等。
二、常见网关 常见的API网关有SpringGateway、Zuul、Kong、apisix等，基于nginx平台的网关有：KONG、APIUmbrella、apisix, 自研的网关有：apigee、StrongLoop、Zuul、Tyk。按 照语言分类，有基于lua（nginx平台）, nodejs,java, go等语言的网关。
通过调研发现基于OpenResty语言进行网关开发要比Java语言开发的网关更具优势。
开源组件中基于Nginx功能比较齐全的网关有Kong组件。
三、推荐网关KONG Kong是一个可扩展的，开源的API层，运行在RESTful前端，可通过插件扩展（认证、安全、流量控制、分析&amp;监控、转换、日志）。 Kong是Mashape开源的高性能高可用API网关和API服务管理层。它基于Openresty,进行API管理，并提供插件实现API的AOP。Kong在Mashape管理了超过15,000个API,为200,000个开发者提供了每月数十亿的请求支持。Kong是基于Openresty的,而Openresty又是Nginx的二次封装，所以很多配置项和Nginx类似.
1）特点 可扩展性：Kong通过简单的增加机器节点，可以很容易的水平扩展。
模块化：Kong可以通过插件方式扩展，这个插件可以很容易通过一个RESTful管理API来配置。
可以运行在任何基础架构：Kong可以处处运行。您可以在云或内部部署环境，包括单个或多个数据中心的设置，私有或者邀请受限APIs。
2）请求工作流程 Kong运行后，每个请求所作出的API将先请求Kong服务器，然后它会被代理到最终的API。这些插件在API请求响应循环的生命周期中被执行。Kong将有效地将成为每个API请求的入口点。 Kong是在客户端和（微）服务间转发API通信的API网关，通过插件扩展功能。Kong 有两个主要组件： KongServer ：基于nginx的服务器，用来接收API请求。 ApacheCassandra或PG ：用来存储操作数据。 你可以通过增加更多KongServer 机器对Kong服务进行水平扩展，通过前置的负载均衡器向这些机器分发请求。根据文档描述，两个Cassandra节点就足以支撑绝大多数情况，但如果网络非常拥挤，可以考虑适当增加更多节点。
3）工作原理 Kong核心基于OpenResty构建，实现了请求/响应的Lua处理化；
Kong插件拦截请求/响应，如果接触过JavaServlet，等价于拦截器，实现请求/响应的AOP处理；
KongRestful 管理API提供了API/API消费者/插件的管理；
数据中心用于存储Kong集群节点信息、API、消费者、插件等信息，目前提供了PostgreSQL和Cassandra支持，如果需要高可用建议使用Cassandra；
dnsmasq用于提供给NginxDNS解析功能；
Kong集群中的节点通过gossip协议自动发现其他节点，当通过一个Kong节点的管理API进行一些变更时也会通知其他节点。每个Kong节点的配置信息是会缓存的，如插件，那么当在某一个Kong节点修改了插件配置时，需要通知其他节点配置的变更。
4）整体架构 5）技术架构 在使用Kong之前API架构存在的问题： 通用模块在各API中没有复用 难以维护 不影响其他服务状态下难以扩展 由于系统限制生产效率低下。
在使用Kong后的API架构： Kong统一管理通用插件 高效，可扩展的分布式架构体系 通过简单的命令即可完成扩展 团队专注于业务，Kong来处理 REST 请求。
6）多插件特性 身份认证：Kong提供了BasicAuthentication、Keyauthentication、OAuth2.0authentication、HMACauthentication、JWT、LDAPauthentication认证实现。
安全：ACL（访问控制）、CORS（跨域资源共享）、动态SSL、IP限制、爬虫检测实现。
流量控制：请求限流（基于请求计数限流）、上游响应限流（根据upstream响应计数限流）、请求大小限制。限流支持本地、Redis和集群限流模式。
分析监控：Galileo（记录请求和响应数据，实现API分析）、Datadog（记录APIMetric如请求次数、请求大小、响应状态和延迟，可视化APIMetric）、Runscope（记录请求和响应数据，实现API性能测试和监控）。
转换：请求转换（在转发到upstream之前修改请求）、响应转换（在upstream响应返回给客户端之前修改响应）。
日志：TCP、UDP、HTTP、File、Syslog、StatsD、Loggly等。 也可以开发自己的插件，如缓存等。 Kong作为API网关提供了API管理功能，及围绕API管理实现了一些默认的插件，另外还具备集群水平扩展能力，从而提升整体吞吐量。Kong本身是基于OpenResty，可以在现有Kong的基础上进行一些扩展，从而实现更复杂的特性。 有一些特性Kong默认是缺失的，如API级别的超时、重试、fallback策略、缓存、API聚合、ABTest等，这些需要开发者自己定制和扩展。
Kong插件具备如下特性：
云原生：与平台无关，Kong可以从裸机运行到Kubernetes
动态路由：Kong的背后是Openresty+Lua，所以从Openresty继承了动态路由的特性。
熔断
健康检查
日志：可以记录通过Kong的HTTP，TCP，UDP请求和响应。
鉴权：权限控制，IP黑名单，同样是Openresty的特性 SSL：set up a specific SSL certificate for an underlying service or API.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fc8a9fd4853b12281d571888eacbca46/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b1ac517d46d69228a2c54302f428e2d/" rel="bookmark">
			API网关之Kong网关简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. Kong简介 那么，Kong是一个什么东东呢？它是一个开源的API网关，或者你可以认为它是一个针对API的一个管理工具。你可以在那些上游service之上，额外去实现一些功能。Kong是开源的，所以你可以在Github找到它，你现在就可以下载使用。
Kong是一款基于OpenResty（Nginx + Lua模块）编写的高可用、易扩展的，由Mashape公司开源的API Gateway项目。Kong是基于NGINX和Apache Cassandra或PostgreSQL构建的，能提供易于使用的RESTful API来操作和配置API管理系统，所以它可以水平扩展多个Kong服务器，通过前置的负载均衡配置把请求均匀地分发到各个Server，来应对大批量的网络请求。
Kong主要有三个组件：
Kong Server ：基于nginx的服务器，用来接收API请求。
Apache Cassandra/PostgreSQL ：用来存储操作数据。
Kong dashboard：官方推荐UI管理工具，当然，也可以使用 restfull 方式 管理admin api。Konga另一款经典用于UI管理工具
Kong采用插件机制进行功能定制，插件集（可以是0或N个）在API请求响应循环的生命周期中被执行。插件使用Lua编写，目前已有几个基础功能：HTTP基本认证、密钥认证、CORS（Cross-Origin Resource Sharing，跨域资源共享）、TCP、UDP、文件日志、API请求限流、请求转发以及Nginx监控
2. Kong网关的特性 Kong网关具有以下的特性：
可扩展性: 通过简单地添加更多的服务器，可以轻松地进行横向扩展，这意味着您的平台可以在一个较低负载的情况下处理任何请求；
模块化: 可以通过添加新的插件进行扩展，这些插件可以通过RESTful Admin API轻松配置；
在任何基础架构上运行: Kong网关可以在任何地方都能运行。您可以在云或内部网络环境中部署Kong，包括单个或多个数据中心设置，以及public，private 或invite-only APIs。
Kong核心基于OpenResty构建，实现了请求/响应的Lua处理化；
Kong插件拦截请求/响应，如果接触过Java Servlet，等价于拦截器，实现请求/响应的AOP处理；
Kong Restful 管理API提供了API/API消费者/插件的管理；
数据中心用于存储Kong集群节点信息、API、消费者、插件等信息，目前提供了PostgreSQL和Cassandra支持，如果需要高可用建议使用Cassandra；
Kong集群中的节点通过gossip协议自动发现其他节点，当通过一个Kong节点的管理API进行一些变更时也会通知其他节点。每个Kong节点的配置信息是会缓存的，如插件，那么当在某一个Kong节点修改了插件配置时，需要通知其他节点配置的变更
3. Kong网关插件 身份认证插件：Kong提供了Basic Authentication、Key authentication、OAuth2.0 authentication、HMAC authentication、JWT、LDAP authentication认证实现。
安全控制插件：ACL（访问控制）、CORS（跨域资源共享）、动态SSL、IP限制、爬虫检测实现。
流量控制插件：请求限流（基于请求计数限流）、上游响应限流（根据upstream响应计数限流）、请求大小限制。限流支持本地、Redis和集群限流模式。
分析监控插件：Galileo（记录请求和响应数据，实现API分析）、Datadog（记录API Metric如请求次数、请求大小、响应状态和延迟，可视化API Metric）、Runscope（记录请求和响应数据，实现API性能测试和监控）。
协议转换插件：请求转换（在转发到upstream之前修改请求）、响应转换（在upstream响应返回给客户端之前修改响应）。
日志应用插件：TCP、UDP、HTTP、File、Syslog、StatsD、Loggly等
kong目前提供了37个插件，其中商业收费7个，30个开源免费的插件，可以设定到api/服务/路由粒度上。
类别免费/收费name插件名使用场景认证免费basic-authBasic Authentication对于服务或者路由提供用户名/密码基本认证机制认证免费key-authKey Authentication对于服务或者路由提供用关键字认证机制认证收费-OpenID Connect提供与三方OpenID的集成方式认证免费oauth2OAuth 2.0 Authentication添加OAuth 2.0认证认证收费-OAuth 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b1ac517d46d69228a2c54302f428e2d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/339e1d4e31fee13c7a7ce97457c53340/" rel="bookmark">
			4层负载均衡和7层负载均衡，有什么区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		4层负载均衡和7层负载均衡有何不同？
大家都知道负载均衡，那么4层负载均衡和7层负载均衡有何不同？常见的负载均衡方式有几种，比如DNS，这是最简单的负载均衡的方式，一般用于实现地理级别的负载均衡。不同地域的用户通过DNS解析可以返回不同的IP地址，这种方式负载均衡最简单，但是扩展性太差，控制权在域名服务商。
第二种，HTTP重定向。通过修改HTTP响应头的location，达到负载均衡的目的。比如HTTP的302重定向，那这种方式对性能会有影响，而且会增加请求的耗时。
第三种，反向代理。作用于应用层的模式，也被称作为7层负载均衡。比如常见的NGINX，性能一般可以达到万级。这种方式部署简单，成本低，而且容易扩展。
第四种，IP。作为网络层和传输层的模式，也被称作为4层负载均衡，通过对数据包的IP地址和端口进行修改，来达到负载均衡的效果。
常见的有LVS，通常性能可以达到10万级。如果按照类型来划分还可以分成DNS负载均衡、硬件负载均衡和软件负载均衡。其中硬件负载均衡的价格昂贵，性能最好，能够达到百万级。而软件负载均衡就包括上面说到的NGINX、LVS这种。
所以，4层负载均衡和7层负载均衡的区别在于他们所操作的网络层次不同。4层负载均衡工作在传输层，可以根据端口号IP地址进行负载均衡，但无法识别应用层的协议。而7层负载均衡工作在应用层，可以识别和处理应用层的协议。比如HTTP HTTPS SMTP等等。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6687a1fa34d3d0ac1a51274464d43081/" rel="bookmark">
			并行和并发哪个好?并行和并发的概念和区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要：并发与并行是两个既相似而又不相同的概念：并发性，又称共行性，是指能处理多个同时性活动的能力；并行是指同时发生的两个并发事件，具有并发的含义，而并发则不一定并行，也亦是说并发事件之间不一定要同一时刻发生。
并行介绍 并行在操作系统中是指，一组程序按独立异步的速度执行，不等于时间上的重叠（同一个时刻发生）。
并发介绍 并发是指：在同一个时间段内，两个或多个程序执行，有时间上的重叠（宏观上是同时，微观上仍是顺序执行）。
并发的实质是一个物理CPU（也可以多个物理CPU） 在若干道程序之间多路复用，并发性是对有限物理资源强制行使多用户共享以提高效率。
操作系统并发程序执行的特点： 并发环境下，由于程序的封闭性被打破，出现了新的特点： ①程序与计算不再一一对应，一个程序副本可以有多个计算
②并发程序之间有相互制约关系，直接制约体现为一个程序需要另一个程序的计算结果，间接制约体现为多个程序竞争某一资源，如处理机、缓冲区等。
③并发程序在执行中是走走停停，断续推进的
并发和并行的作用 通过并发和并行能够使得应用程序可以充分利用多核以及GPU的计算能力，从而提高应用程序的性能，比如在以下几个方面中：
1.使用异步I/O操作可以提高应用程序的响应性。大多数的GUI应用程序都是用单个线程来控制所有UI界面的更新。UI线程不应该被占用过长时间，不然UI界面就会失去对用户的响应。
2.跨多线程的并行工作可以更好的利用系统的资源。具有多CPU和GPU的现代计算机，通过并行可以指数级的提高CPU计算受限的应用程序的性能。
3.同时执行多个I/O操作（如同时从多个网站上获取信息）可以提高总体的吞吐量（throughput），等待I/O相应的操作可以用来发起新的操作，或者是处理操作返回的结果。
并行和并发区别 区别一： 并发是指一个处理器同时处理多个任务。并行是指多个处理器或者是多核的处理器同时处理多个不同的任务。并发是逻辑上的同时发生（simultaneous），而并行是物理上的同时发生。
来个比喻：并发是一个人同时吃三个馒头，而并行是三个人同时吃三个馒头。
区别二： 并行（parallel）：指在同一时刻，有多条指令在多个处理器上同时执行。就好像两个人各拿一把铁锨在挖坑，一小时后，每人一个大坑。所以无论从微观还是从宏观来看，二者都是一起执行的
摘要：并发与并行是两个既相似而又不相同的概念：并发性，又称共行性，是指能处理多个同时性活动的能力；并行是指同时发生的两个并发事件，具有并发的含义，而并发则不一定并行，也亦是说并发事件之间不一定要同一时刻发生。
并行介绍 并行在操作系统中是指，一组程序按独立异步的速度执行，不等于时间上的重叠（同一个时刻发生）。
并发介绍 并发是指：在同一个时间段内，两个或多个程序执行，有时间上的重叠（宏观上是同时，微观上仍是顺序执行）。
并发的实质是一个物理CPU（也可以多个物理CPU） 在若干道程序之间多路复用，并发性是对有限物理资源强制行使多用户共享以提高效率。
操作系统并发程序执行的特点： 并发环境下，由于程序的封闭性被打破，出现了新的特点： ①程序与计算不再一一对应，一个程序副本可以有多个计算
②并发程序之间有相互制约关系，直接制约体现为一个程序需要另一个程序的计算结果，间接制约体现为多个程序竞争某一资源，如处理机、缓冲区等。
③并发程序在执行中是走走停停，断续推进的
并发和并行的作用 通过并发和并行能够使得应用程序可以充分利用多核以及GPU的计算能力，从而提高应用程序的性能，比如在以下几个方面中：
1.使用异步I/O操作可以提高应用程序的响应性。大多数的GUI应用程序都是用单个线程来控制所有UI界面的更新。UI线程不应该被占用过长时间，不然UI界面就会失去对用户的响应。
2.跨多线程的并行工作可以更好的利用系统的资源。具有多CPU和GPU的现代计算机，通过并行可以指数级的提高CPU计算受限的应用程序的性能。
3.同时执行多个I/O操作（如同时从多个网站上获取信息）可以提高总体的吞吐量（throughput），等待I/O相应的操作可以用来发起新的操作，或者是处理操作返回的结果。
并行和并发区别 区别一： 并发是指一个处理器同时处理多个任务。并行是指多个处理器或者是多核的处理器同时处理多个不同的任务。并发是逻辑上的同时发生（simultaneous），而并行是物理上的同时发生。
来个比喻：并发是一个人同时吃三个馒头，而并行是三个人同时吃三个馒头。
区别二： 并行（parallel）：指在同一时刻，有多条指令在多个处理器上同时执行。就好像两个人各拿一把铁锨在挖坑，一小时后，每人一个大坑。所以无论从微观还是从宏观来看，二者都是一起执行的
摘要：并发与并行是两个既相似而又不相同的概念：并发性，又称共行性，是指能处理多个同时性活动的能力；并行是指同时发生的两个并发事件，具有并发的含义，而并发则不一定并行，也亦是说并发事件之间不一定要同一时刻发生。
并行介绍 并行在操作系统中是指，一组程序按独立异步的速度执行，不等于时间上的重叠（同一个时刻发生）。
并发介绍 并发是指：在同一个时间段内，两个或多个程序执行，有时间上的重叠（宏观上是同时，微观上仍是顺序执行）。
并发的实质是一个物理CPU（也可以多个物理CPU） 在若干道程序之间多路复用，并发性是对有限物理资源强制行使多用户共享以提高效率。
操作系统并发程序执行的特点： 并发环境下，由于程序的封闭性被打破，出现了新的特点： ①程序与计算不再一一对应，一个程序副本可以有多个计算
②并发程序之间有相互制约关系，直接制约体现为一个程序需要另一个程序的计算结果，间接制约体现为多个程序竞争某一资源，如处理机、缓冲区等。
③并发程序在执行中是走走停停，断续推进的
并发和并行的作用 通过并发和并行能够使得应用程序可以充分利用多核以及GPU的计算能力，从而提高应用程序的性能，比如在以下几个方面中：
1.使用异步I/O操作可以提高应用程序的响应性。大多数的GUI应用程序都是用单个线程来控制所有UI界面的更新。UI线程不应该被占用过长时间，不然UI界面就会失去对用户的响应。
2.跨多线程的并行工作可以更好的利用系统的资源。具有多CPU和GPU的现代计算机，通过并行可以指数级的提高CPU计算受限的应用程序的性能。
3.同时执行多个I/O操作（如同时从多个网站上获取信息）可以提高总体的吞吐量（throughput），等待I/O相应的操作可以用来发起新的操作，或者是处理操作返回的结果。
并行和并发区别 区别一： 并发是指一个处理器同时处理多个任务。并行是指多个处理器或者是多核的处理器同时处理多个不同的任务。并发是逻辑上的同时发生（simultaneous），而并行是物理上的同时发生。
来个比喻：并发是一个人同时吃三个馒头，而并行是三个人同时吃三个馒头。
区别二： 并行（parallel）：指在同一时刻，有多条指令在多个处理器上同时执行。就好像两个人各拿一把铁锨在挖坑，一小时后，每人一个大坑。所以无论从微观还是从宏观来看，二者都是一起执行的
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6687a1fa34d3d0ac1a51274464d43081/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7429a09ef87ff2386309fe8ddcee7393/" rel="bookmark">
			【RDKit】关于RDKit安装问题，python兼容性问题（最后有RDKit的正确安装方法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 // 两种出错的安装方式 conda install -c conda-forge rdkit conda install -c rdkit rdkit 使用上面两种方法安装会出现如下报错：
from rdkit.Chem.rdmolfiles import *
ImportError: DLL load failed while importing rdmolfiles: 找不到指定的程序。
切记不要直接conda安装
使用下面两种方法都是安装的之前版本的rdkit，python3.8之后现在应该是叫rdkit-pypi
除非修改python版本到较低版本如python3.7或python3.6，但又会出现其他兼容性问题
因为我的tensorflow等配套，装的是基于python3.8的，所以，使用如下解决方案
解决方法 去rdkit-pypi官网（https://pypi.org/project/rdkit-pypi/#description）找到对应版本的whl文件，安装即可。
来链接: link.
找到对应版本的支持python3.8的安装指令
如下：
pip install rdkit-pypi==2022.9.4 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71a6748f91537dc24829c023a186955f/" rel="bookmark">
			[保姆级教程] 如何在 Linux Kernel (V5.17.7) 中添加一个系统调用（System call）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在学习 《linux Kernel Development》，本书用的linux kernel 是v2.6 版本的。看完”系统调用“一节后，想尝试添加一个系统调用，然后重编一个kernel。经过几个小时的尝试，实现了这个小功能，其中也遇到了不少坑，本文主要是记录分享下如何在Linux Kernel (V5.17.7) 中添加一个系统调用（System call）。
编kernel之前需要注意：
修改的kernel是目前最新的release 版本(V5.17.7), 书中v2.6版本的kernel太老了，gcc需要降到4.8版本，否则无法编过。 kernel 发布地址：https://www.kernel.org/需要选用大内存，多核的机器编kernel，否则会出现各种异常问题，而且编kernel 很费时间。15GB内存的机器，编不过kernel。换用100GB内存的机器就好了😅 本文主要包含以下几点内容：
环境准备修改kernelrebuild kernel 以及安装kernel测试结果 1、环境准备 我编kernel的机器是：Ubuntu 20.04.1 LTS，内存180GB, cores: 88
1.1 更新系统的源 sudo apt update &amp;&amp; sudo apt upgrade -y 1.2 安装编译kernel 需要的依赖 sudo apt install build-essential libncurses-dev libssl-dev libelf-dev bison flex -y 我这里用的vim，没有的话也需要安装：
sudo apt install vim -y 1.3 清除已经安装的packages sudo apt clean &amp;&amp; sudo apt autoremove -y 1.4 下载kernel code wget -P ~/ https://cdn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/71a6748f91537dc24829c023a186955f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52883dbe71aec6fe001b13546dddfd57/" rel="bookmark">
			【Git】Git基础命令操作速记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【Git】Git基础命令操作速记 文章目录 【Git】Git基础命令操作速记1. 初始化1.1 设置用户名和邮箱1.2 初始化仓库 2. 基础命令2.1 add和commit2.2 reset2.3 查看日志2.4 删除/找回本地仓库文件2.5 找回暂存区文件2.6 diff命令(找不同) 3. 分支命令3.1 查看分支3.2 创建分支3.3 切换分支3.4 合并冲突 4. 远程操作4.1 创建远程仓库别名4.2 push操作4.3 clone操作4.4 pull操作4.4.1 fetch操作4.4.2 merge操作 4.5 协同开发冲突问题解决 1. 初始化 1.1 设置用户名和邮箱 设置用户名命令及邮箱：
git config --global user.name "xxx" git config --global user.email "xxx@xx.com" 查看用户名命令：
git config user.name git config user.email 1.2 初始化仓库 初始化仓库：
git init 2. 基础命令 2.1 add和commit 在目录当中创建一个Demo.text文件，将他提交到暂存区中：
git add Demo.txt 将暂存区当中的文件添加到本地仓库：
git commit -m "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/52883dbe71aec6fe001b13546dddfd57/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b988219cbdf7b6fe0e14e19524eaef0/" rel="bookmark">
			Erlang顺序编程杂项集（上篇）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一：apply apply是一个内置函数，它是通过函数名和参数计算该函数的值，其中的函数名和模块名是动态计算得出的。内置函数apply(Mod, Func, [Arg1, Arg2, ..., ArgN])会将模块Mod里的Func函数应用到Arg1, Arg2, ... ArgN这些参数上,它相当于:
Mod:Func(Arg1,Arg2,Arg3,...,ArgN). %%其中上述中Mod是模块，Func是该模块的函数，Arg是参数 所有的 Erlang 内置函数也可以通过 apply 进行调用，方法是假定它们都属于 erlang 模块。因 此，要构建一个对内置函数的动态调用，可以编写以下代码： 1&gt; apply(erlang,atom_to_list,[hello]). "hello" %%这其中就和apply(Mod, Func, [Arg1, Arg2, ..., ArgN])这个一样，erlang 相当于Mod是模块，atom_to_list相当于Func是函数，hello是参数。 注：应当尽量避免使用apply。当函数的参数数量能预先知道时，M:F(Arg1, Arg2, ... ArgN) 这种调用形式要比apply好得多。如果使用apply对函数进行调用，许多分析工具就无法 得知发生了什么，一些特定的编译器优化也不能进行。所以，尽量少用apply，除非绝对有必要。 二：算术表达式 任何类型的值的计算是表达式， 下面的表格展示了所有可用的算术表达式。每种算术操作都有1 或 2个参数（X，Y），这些参数在表格里显示为“整数”或“数字”（数字的意思是此参数可以是整数或浮点数） 操作符描述参数类型优先级+ X正数数字1- X负数数字1X * Y进行乘法运算数字2X / Y进行除法运算（一般结果是浮点数）数字2bont X对X执行按位取反（bitwise not）整数2X div YX被Y整除整数2X rem YX除以Y的整数的余数（取余）整数2X band Y对X和Y执行按位与（bitwise and）整数2X + Y进行加法运算数字3X - Y进行减法运算数字3X bor Y对X和Y执行按位或（bitwise or）整数3X bxor Y对X和Y执行按位异或（bitwise xor）整数3X bsl N把X向左算术位移（arithmetic bitshift）N位整数3X bsr N把X向右算法位移N位整数3 这些操作符相互之间根据 优先级 结合。一个复杂算术表达式的求值顺序由所含操作符的优先 级而定：所有优先级为 1 的操作符会首先求值，然后轮到所有优先级为 2 的操作符，以此类推。 可以用括号来改变默认的求值顺序：括号内的表达式会首先求值。优先级相同的操作符遵循 向左结合的规则，从左往右分别求值。 三：元数 一个函数的元数（arity ）是该函数所拥有的参数数量。在 Erlang 里，同一模块里的两个名称 相同、元数不同的函数是 完全 不同的函数。除了碰巧使用同一个名称外，它们之间 毫不相关 。 根据惯例， Erlang 程序员经常将名称相同、元数不同的函数作为辅助函数使用。这里有一个 例子： sum(L) -&gt; sum(L,0), sum([],N) -&gt; N; sum([H|T],N) -&gt; sum(T,H + N).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b988219cbdf7b6fe0e14e19524eaef0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0fe9e5240a2952f7dab9739724dd0de9/" rel="bookmark">
			华为静态路由
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. IPv4静态路由简介 1.1.定义 静态路由是一种需要用户手工配置的特殊路由。静态路由通过手工配置，手工告诉三层设备（三层交换机、路由），数据包从来拿到哪去。动态路由也需要手工配置，但配置的时候，配置命令不会说明数据包从哪来到哪去。
1.1.1.动态路由 rip: network 10.10.10.0
1.1.2.静态路由 语法格式：ip route-static ip-address { mask | mask-length } nexthop-address preference preference
1.1.2.1配置样例： ip route-static 10.10.10.0 24 192.168.3.1
ip route-static 10.10.10.0 24 gigabitethernet 0/0/1
1.2. 目的 当网络结构比较简单时，只需配置静态路由就可以使网络正常工作。当设备不能使用动态路由协议或者不能建立到达目的网络的路由时，也可以使用静态路由。
静态路由可非常准确地控制网络的路由选择。仔细设置和使用静态路由可以改进网络的性能，并可为重要的应用保证带宽。
2.IPv4静态路由原理描述 路由设备根据路由转发数据包，路由可以通过手动配置和使用动态路由算法计算产生，通过手动配置产生的路由就是静态路由。
静态路由和动态路由相比优点是：静态路由比动态路由使用更少的带宽，并且不需要占用设备资源来计算和分析路由更新。
静态路由和动态路由相比缺点是：当网络发生故障或者拓扑发生变化后，静态路由不会自动改变，必须有管理员的介入。
一条静态路由包含以下要素：目的地址和掩码长度，出接口和下一跳地址。
2.1.目的地址和掩码 目的地址为点分十进制格式，掩码可以用点分十进制表示，也可用掩码长度即掩码中连续“1”的位数表示。
2.2.出接口和下一跳地址 在配置静态路由时，可指定出接口，也可指定下一跳地址，还可以同时指定出接口和下一跳地址。实际上，所有的路由项都必须明确下一跳。在发送报文时，首先根据报文的目的地址寻找路由表中与之匹配的路由（遵循最长匹配原则）。指定发送接口时需要注意：
2.2.1对于点到点类型的接口，指定发送接口即隐含指定了下一跳地址，这时认为与该接口相连的对端接口地址就是路由的下一跳地址。
2.2.2在配置静态路由时，不建议指定以广播口（如以太网接口）作为出接口。因为以太网接口是广播类型的接口，会导致出现多个下一跳，无法唯一确定下一跳。在应用中，如果必须指定广播接口（如以太网接口）作为出接口，必须同时指定通过该接口发送时对应的下一跳地址。
3.创建IPv4静态路由的语法格式 3.1前提条件 在配置IPv4静态路由之前，需完成以下任务：
配置接口的链路层协议参数，使接口的链路协议状态为Up
思考：结合实验，思考上面的句子如何理解。
3.2操作步骤 3.2.1.进入系统视图。 system-view
3.2.2.配置IPv4静态路由。 公网配置IPv4静态路由。
ip route-static ip-address { mask | mask-length } nexthop-address [ preference preference | tag tag ] * [ description text ]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0fe9e5240a2952f7dab9739724dd0de9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9934243c685c9c3e680748211191143e/" rel="bookmark">
			Android总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		String 和 StringBuffer、StringBuilder的区别 String是不可变对象，StringBuffer和StringBuilder是可变对象
StringBuffer是线程安全的，StringBuilder是非线程安全的
执行速度：StringBuilder&gt;StringBuffer&gt;String（String为字符串常量，而StringBuilder和StringBuffer均为字符串变量，String对象一旦创建后该对象是不可更改的，后两者的对象是变量，是可以更改的）
equals和“==” ，hashCode的区别 ==是比较两个基本数据数值是否相等或者两个变量内存地址是否相同
equals 是比较两个独立对象的内容是否相同
hashCode 一个类重写equals()一般比较的复杂，这样效率就很低，而利用hashCode()继续对比，只需要生成一个hash值就可以进行对比
注：hashCode不相同，则说明两个对象不相等，但是hashCode相同时，还需要判断equals()，只有当equals()也相同时，两个对象才相等
Java中浅拷贝和深拷贝的区别 浅拷贝：对基本数据类型进行值传递，对引用数据类型进行引用传递的拷贝
深拷贝：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容
Java中Exception和Error的区别 Exception：是java程序运行中已知的异常情况，咱们可以获取到这种异常，并且对这种异常进行业务外的处理
Error：是java程序运行中不可预料的异常情况，这种异常发生以后，会直接导致JVM不可处理或者不可恢复的情况。所以这种异常不可能抓取到，比如OutOfMemoryError、NoClassDefFoundError等
什么是反射机制 Java 反射机制是在运行状态中，对于任意一个类，都能够知道这个类中的所有属性和方法
应用场景：
逆向代码，例如反编译与注解相结合的框架，如 Retrofit单纯的反射机制应用框架，例如 EventBus（事件总线）动态生成类框架 例如Gson BIO、NIO、AIO 有什么区别 BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统IO，它的特点是模式简单使用方便，并发处理能力低。
NIO：Non IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。
AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。
Java注解 Java注解它提供了一种安全的类似注释的机制，用来将任何的信息或元数据（metadata）与程序元素（类、方法、成员变量等）进行关联。
List，Set，Map的区别 List：存储的数据是有顺序的，并且值允许重复
Set：存储的数据是无顺序的，并且不允许重复
Map：存储的数据是无序的，它的键是不允许重复的，但是值是允许重复的
ArrayList和LinkedList的区别 ArrayList是基于数组的数据结构，LinkedList是基于链表的数据结构。ArrayList适用于查询操作，LinkedList适用于插入和删除操作。 线程sleep()和wait()的区别 sleep 是Thread类的方法，wait是Object类的方法
sleep不释放锁，wait释放锁
sleep不需要Synchronized ，wait需要Synchronized
sleep不需要唤醒，wait需要唤醒（除wait(int time)）
强、软、弱、虚引用以及它们之间的区别 强引用：强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。当内存空间不足，Java虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9934243c685c9c3e680748211191143e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5b517d34ec98fe88a2f6638de44979e/" rel="bookmark">
			python http服务屏蔽响应日志输出，终端不输出时间日志
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、http_server总是在收到消息时打印返回的日志时间戳 通过http.server启动服务器时，每次访问服务器时都会写入ip-address和请求时间。是否可以在控制台中禁用这些日志的显示？
二、解决方案 官方文档中指明了 log_message 默认输出是终端-sys.stderr。如果不想要终端打印日志信息，需要重新此函数。
详情见官方文档
class Resquest(BaseHTTPRequestHandler): server_version = "Apache" # 设置服务器返回的的响应头 def log_message(self, format: str, *args: Any) -&gt; None: return return super().log_message(format, *args) def do_GET(self): self.send_response(200) self.send_header("Content-type", "application/json") self.send_header("test", "This is get!") self.end_headers() self.wfile.write(json.dumps(data).encode()) def do_POST(self): # path = self.path # print(path) # 获取post提交的数据 datas = self.rfile.read(int(self.headers['Content-Length'])) print(result) self.send_response(200) self.send_header("Content-type", "application/json") self.send_header("test", "This is post!") self.end_headers() self.wfile.write(json.dumps(data).encode()) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0543f283f3665f5f15f2f0891d49648/" rel="bookmark">
			单链表的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		单链表的实现 单链表的链表的概念及结构概念结构链表结构的分类链表常用的结构 无头单向不循环链表头文件 SList.h结构体 struct SListNode 源文件 SList.c创建结点 SLNode* SLBuyNode(SLDataType x)初始化链表 void SLInit(SLNode** pphead)链表尾部插入 void SLPushBack(SLNode** pphead,SLDataType x)链表头部插入 void SLPushFront(SLNode** pphead, SLDataType x)打印链表 void SLPrint(SLNode* phead)链表尾部删除 void SLPopBack(SLNode** pphead)链表头部删除 void SLPopFront(SLNode** pphead)销毁单链表 void SLDesTroy(SLNode** pphead) 测试插入数据与删除数据 test.c查找链表元素 SLNode* SLFind(SLNode** pphead, SLDataType x)在指定位置之前添加数据 void SLInsert(SLNode** pphead,SLNode* pos ,SLDataType x)在指定位置之后添加数据 void SLInsertAfter(SLNode** pphead,SLNode* pos ,SLDataType x) 测试指定位置插入数据删除指定结点 void SLErase(SLNode** pphead, SLNode* pos)删除指定结点的下一结点 void SLEraseAfter(SLNode* pos) 测试指定位置删除数据 结语 单链表的链表的概念及结构 概念 链表是一种物理存储结构上非连续，非顺序的存储结构，数据元素的逻辑结构是通过链表中结构体的指针链接依序实现。
结构 在链表中，我们将带有需要存储的变量data与该结构体指针变量next的结构体设为一个结点，再将多个结点通过该结构体的成员next进行链接，就如上图所形成的数据结构，其中1为头节点，4为节点。链表的结构在逻辑上是连续的，但在物理内存上不一定连续；现实中的节点一般都是从堆区申请得来的；从堆区申请的空间，按照一定的策略来分配，两次申请的空间可能连续，也可能不连续。 链表结构的分类 下面以32位环境下，结点存储信息位int类型为例来介绍链表的不同结构：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a0543f283f3665f5f15f2f0891d49648/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0fccf9d1898a988a13efa53da34f257f/" rel="bookmark">
			【分布式事务】初步探索分布式事务的概率和理论，初识分布式事的解决方案 Seata，TC 服务的部署以及微服务集成 Seata
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、分布式服务案例1.1 分布式服务 demo1.2 演示分布式事务问题 二、分布式事务的概念和理论2.1 什么是分布式事务2.2 CAP 定理2.3 BASE 理论2.4 分布式事务模型 三、分布式事务解决方案 —— Seata3.1 什么是 Seata3.2 Seata 的架构3.3 Seata 的四种分布式事务解决方案 四、Seata 服务的部署和集成4.1 部署 Seata 的 TC 服务4.2 微服务集成 Seata 一、分布式服务案例 在了解分布式事务之前，让我们通过一个微服务的案例来演示一下分布式事务存在的问题。
1.1 分布式服务 demo 首先，我准备了一个微服务的 demo 项目，这个项目的结构如下：
在这个Spring Cloud 项目中一共有三个服务：account-service 账户服务，order-service 订单服务和 storage-service 库存服务。其中order-service 负责下单业务，在下单时会调用订单服务，创建订单并写入数据库。然后订单服务调用账户服务和库存服务：
账户服务负责扣减用户余额；库存服务负责扣减商品库存。 这个调用的流程图如下：
目前这三个服务涉及到了三种数据库表，它们的结构如下：
首先是订单表：
然后是账户表：
最后是库存表：
这三个服务的核心业务代码如下：
首先是 order-service ：
@Override @Transactional public Long create(Order order) { // 创建订单 orderMapper.insert(order); try { // 扣用户余额 accountClient.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0fccf9d1898a988a13efa53da34f257f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12e8fc92491450a4d8af9e3fe8f0aca6/" rel="bookmark">
			【亲测可用】Linux通过端口号获取进程PID并结束进程脚本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Step 1：创建脚本 vi restart.sh 脚本内容 #!/bin/bash if [ ! -n "$1" ]; then echo "请指定重启服务的端口！" exit 1 fi # 获取端口的进程PID PID=`lsof -i :$1 | awk 'NR==2{print $2}'` echo "端口:$1，PID: $PID" kill -9 $PID # 重启服务 echo '启动服务中...' nohup ./start.sh &gt; log.txt 2&gt;&amp;1 # 替换成自己的服务启动命令即可，注意路径 echo '启动成功.' Step 2：给脚本添加可执行权限 chmod +x restart.sh Step 3：测试脚本 ./restart.sh 8080 控制台输出 端口:8080，PID: 1314 启动服务中... 启动成功. 注意 1. 实际使用中需要注意设置变量时，“=”左右两边不要有个空格
2. “lsof -i ”后面要有一个空格
3. 字符串中包含变量时，需要使用双引号 echo "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/12e8fc92491450a4d8af9e3fe8f0aca6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06ae5587817c7834d86ad371eb2a96b9/" rel="bookmark">
			新零售模式的典型特征有哪些？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		电子商务的出现改变了人们的购物习惯,甚至让我们的生活也发生了很大的变化，在这种大环境下，越来越多的企业加入到电商大军中。那么我们一起来了解一下新零售模式的典型特征有哪些?看完易族智汇javashop为您编辑整理的您就会明白了，欢迎阅读，仅供参考。
新零售模式的典型特征有哪些？
1、生态性
“新零售”的商业生态建设将涵盖在线页面、实体店面、支付终端、数据系统、物流平台、营销路径等多个方面，内含购物、娱乐、阅读、学习等多样化功能。除外，全面提升线上服务、线下体验、金融支持、物流支持四大能力，更好地满足消费者在购物过程中对便利和舒适的需求，增加用户粘性。
2、无界性
通过线上和线下平台、有形和无形资源的高效整合，模糊业务流程中各主体的现有边界，企业全方位消除零售渠道之间的各种障碍，促进人员、资金，信息、技术和商品的合理顺畅流动，打破过去传统业务模式中存在的时空边界、产品边界等现实障碍，实现整个商业生态链的互联互通和共享。依靠“无界”的零售企业系统，消费者随时随地以任何可能的方式与企业或其他消费者进行全方位的咨询、互动、交流和讨论、产品体验、情景模拟以及商品和服务的购买。
3、智能化
“新零售”商业模式源于人们在购物过程中对个性化、即时性、便捷性、互动性、精准性、碎片化等要求的逐步提高，而要满足上述需求，在一定程度上依赖于“智能化”的购物方式。在“新零售”产品升级、渠道整合、顾客至上的时代，人们体验的购物流程和购物场景会具有典型的“智能化”特征。
4、体验式
“体验式”商业模式是将产品嵌入到线下，实体店面所创造的各种现实生活场景中，让消费者有直接的机会充分了解商品和服务。不仅增强了人们的参与感和获得感，也进一步发现了线下平台的价值。
扩展资料：
新零售电商的意义是什么?
卖家采用新零售模式之后，用户可以在实体店扫码了解更多，也可以选择在家手机下单，信任力强，而且距离近，半个小时就能送货上门，更快;还能通App参加会员积分等活动。对商家来说，可以拓展用户半径、产品品类等。
新零售的出现，让线上(电商品牌)与线下(传统品牌)得到了一次市场竞争与重组的机会，电商自有品牌开始布局线下、传统品牌也开始入局电商。
各种差价严重、品质乱象，慢慢演变成线上线下同品同质同价的市场新趋势。
综上所述，可以大致的了解到新零售模式的典型特征有哪些，想要了解更多新零售方面的内容，可以持续关注易族智汇javashop新零售栏目。
郑重声明：本文版权归原作者所有，转载文章仅为传播更多信息之目的，如作者信息标记有误，请第一时间联系我们修改或删除，多谢。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/065d045eafae7a7bd66e577afc0f1377/" rel="bookmark">
			【Android】 root权限监听全局触摸事件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 本文将介绍一种基于root权限实现Android手机全局触摸事件监听的方式，并实现了一个系统。在开启该功能后，系统作为service运行于后台，并可以持续手机用户的触屏数据，包括屏幕坐标、接触面积以及触摸事件类型（down、up、move），类似于Android本身的MotionEvent。
本系统开发的初衷为：通过采集触摸数据通过机器学习验证当前手机使用者是否为合法用户，并模拟这一功能被定制进安卓系统后的使用情况。
本方法仅作为学习交流使用，请确保在符合法律规定的条件下使用本方法，使用本方法产生的后果均自行承担！
如果你有更好的实现方法，欢迎交流讨论
手机：魅蓝Note3
系统：Flyme（基于Android 7）—— MIN API 24
编程语言：Kotlin
AS版本：Android Studio Flamingo | 2022.2.1
可能的思路 通过创建一个透明的悬浮窗实现全局触摸数据采集。主要通过WindowManager实现。这一方法看起来可行，但实际实现时会发现：悬浮窗运行时，会拦截所有触摸数据。也就是说，悬浮窗存在时，用户的操作无法穿透悬浮窗而到达下面的控件，这样用户无法正常操作手机。而如果设置悬浮窗不作为焦点，则悬浮窗无法接收到任何触摸数据。
通过辅助功能实现。Android提供了AccessibilityService类，用于开发者编写无障碍app，可以通过AccessibilityServiceInfo中的eventType字段注册想要监听的事件类型（或者在xml中静态注册），来在该事件发生时获取到AccessibilityEvent实例，并做相应处理。
但该方法实际上在运行时，收集不到任何数据。原因似乎是需要进入无障碍模式后才能收集到数据，但Flyme进入无障碍模式的方法似乎和原生安卓有所不同。并且，在AccessibilityEvent中，只提供了按下和离开两种触摸事件类型，无法满足全局触摸数据采集的需求。
其实细想就会发现，想要以官方提供的API来全局监听触摸事件本就是不可能的，因为Android不可能允许一个app可以在后台运行的同时还可以收集到用户操作其他界面时的触摸数据，这会造成严重的安全问题，虽然在早期的Android版本（安卓4以前）似乎可行。因此我们必须另寻他法，在查阅了很多资料后，我终于找到了一个另辟蹊径的方法。
实际实现方法 getevent 调试命令 首先我们需要思考，我们平时编程中使用的view、activity等组件，都是从哪里获得的交互事件呢？来自于系统提供的API？但系统本身又是从哪里获得的数据呢？如果层层溯源，那么这些数据只能来自于用户操作硬件时产生的数据，因此只要能够获取硬件设备的输入，我们就可以获得触摸事件。
我们知道android本身是基于Linux内核构建的，getevent命令就是通过直接读取设备文件的方式来获取硬件输入数据。这种方法是最原始的，但也是最有效的。因为android本质上就是运行在Linux系统上的，因此我们直接读取设备文件就可以获取到来自硬件的数据，这一方法实际上也是android系统本身在做的工作。android从设备文件中读取数据，并将这些数据分发给各个控件，从而使得这些控件能够根据编写好的代码做出响应。
而Android提供了getevent调试命令，用于监视设备的输入。
官网文档：getevent
初窥getevent 我们首先在adb模式下运行这一命令，进行探究。
我们可以使用ls命令列出当前手机中所有的设备文件。设备文件存在于/dev/input目录下。
如果我们直接运行getevent，那么会输出所有设备文件产生的数据。
并且event7设备在不停地输出数据
注意一个坑：这里命令行会时不时输出“FLYME_HIPS_DEBUG:30,0”，这会对我们后续读命令行造成干扰。
不知道其他手机会不会有这个问题。
接下来我们需要找到哪个是屏幕所对应的设备文件。
我们在黑屏和亮屏状态下，点击按钮或点击屏幕，并观察哪个设备文件产生了输出，经过实验发现：
event4对应轻触home键
event5对应电源键和音量键以及按下home键
event8对应屏幕的设备文件。
使用命令单独查看event8的输出，其中 -t 为输出时间戳、-l 为显示具体文本信息…，具体的命令选项可以百度。
这里我们使用getevent -lt /dev/input/event8命令，便于阅读，同时也便于后续编写代码。
点击一次屏幕，可以看到如下输出
其输出格式与Linux中定义的大致相同，详细介绍可以看这篇文章Linux系统struct input_event结构体分类型(鼠标、键盘、触屏)详解与例子
其中第一列为时间戳，第二列为事件类型，第三列为该事件的具体类别，第四列为该事件的值。
我们从第一行开始，逐行分析，可以看到，在一次点击中：
首先输出了 EV_KEY 类型的事件，其具体类型为 BTN_TOUCH，代表我们的手指接触到屏幕，其值为 DOWN。随后跟着的是多个 EV_ABS 类型的事件，从上向下依次为：ABS_MT_TRACKING_ID（手指ID）、ABS_MT_TOUCH_MAJOR（接触面积）、ABS_MT_POSITION_X（x轴坐标）、ABS_MT_POSITION_Y（y轴坐标）最后是一个 EV_SYN 类型的事件，具体类型为SYN_REPORT，标志单次事件的结束然后又是一个触摸事件，但该事件中仅有触摸面积一个值。最后是一个 EV_KEY 类型的事件，其值为UP，代表手指离开屏幕。同时本次事件中还包含了ABS_MT_TRACKING_ID，但值为ffffffff，标志着多点追踪的结束。同样以SYN_REPORT，标志本次事件的结束。 通过不断测试和观察，我们可以总结出getevent命令的输出有以下几个特点：
触摸动作以BTN_TOUCH DOWN开始触摸动作以BTN_TOUCH UP结束两次标志中间的事件均为本次触摸产生的事件单个触摸事件以SYN REPROT为结束标识多点触控时，触摸事件的ABS_MT_TRACKING_ID不同，对应不同手指的触摸数据在新的触摸事件中，会省略输出与上一个触摸事件中相同的字段。也就是说，如果我们横向滑动屏幕，那么手指只有x坐标变化，那么此时getevent输出的一系列事件中，仅会输出x的坐标，而不会出现y的坐标，y坐标仅在第一次接触屏幕时的第一个触摸事件中出现。ABS_MT_TOUCH_MAJOR类型官方解释为：接触面积的直径。也就是将触摸形状近似为一个圆，单位未知。根据这一数据可以计算出接触面积的大小。但经过实际测试：在app中调用官方API——MotionEvent中的getsize获取的接触面积就是ABS_MT_TOUCH_MAJOR的值，说明官方并没有根据该值进一步计算得到实际面积，而是直接将该值当作了接触面积。 至此，我们已经基本摸清了getevent的输出模式，接下来我们的思路就确定了：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/065d045eafae7a7bd66e577afc0f1377/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b4cc594f10b6961f68ad278916e8f8b/" rel="bookmark">
			SpringBoot全局配置long转String丢失精度问题解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpringBoot全局配置long转String丢失精度问题解决方案 前言方案一、实现WebMvcConfigurer接口方案二、使用Jackson2进行解决方案三、使用@JsonSerialize注解方案四、配置文件 前言 web项目中,前端JS使用Java后端传过来的Long/long会丢失精度。
后端将返回的数据改为String使用即可
方案一、实现WebMvcConfigurer接口 extends WebMvcConfigurerAdapter 已经被弃用，直接实现WebMvcConfigurer该接口就行了
@EnableWebMvc @Configuration public class WebDataConvertConfig implements WebMvcConfigurer { public void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) { MappingJackson2HttpMessageConverter jackson2HttpMessageConverter = new MappingJackson2HttpMessageConverter(); ObjectMapper objectMapper = new ObjectMapper(); /** * 序列换成json时,将所有的long变成string * 因为js中得数字类型不能包含所有的java long值 */ SimpleModule simpleModule = new SimpleModule(); simpleModule.addSerializer(Long.class, ToStringSerializer.instance); simpleModule.addSerializer(Long.TYPE, ToStringSerializer.instance); objectMapper.registerModule(simpleModule); jackson2HttpMessageConverter.setObjectMapper(objectMapper); converters.add(jackson2HttpMessageConverter); } } 方案二、使用Jackson2进行解决 @Configuration public class JacksonConfig { /** * Jackson全局转化long类型为String，解决jackson序列化时long类型缺失精度问题 * @return Jackson2ObjectMapperBuilderCustomizer 注入的对象 */ @Bean public Jackson2ObjectMapperBuilderCustomizer jackson2ObjectMapperBuilderCustomizer() { return jacksonObjectMapperBuilder -&gt; jacksonObjectMapperBuilder .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b4cc594f10b6961f68ad278916e8f8b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e071fa233ebc6e1df6d9f6550ebc331f/" rel="bookmark">
			基于FPGA的FFT算法实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于FPGA的FFT IP的实时配置 项目简述FFT进行重配置FPGA代码 FPGA逻辑代码FPGA测试代码 MATLAB验证参考文献总结 项目简述 前面我们已经讲解过Xilinx中FFT IP的使用，但是使用的时候IP的配置接口我们没有进行相应的讲解，直接使用GUI配置好的接口，这在现实应用中很不方方便，会让人感觉到还不如自己手写一个FFT算法，当然博主也可完全手撕FFT、CORDIC代码，但是把IP用好了绝对比我们手写的代码要好用的多。这篇博客主要讲解FFT IP的重配置及其参数的意义，最后将给出Modelsim与MATLAB的两盒验证。
本次实验所使用的软硬件环境如下：
1、VIVADO 2019.1
2、Modelsim 10.7
3、MATLAB 2015b
这里再多说一句，从博主之前的文章中可以发现MATLAB在信号处理中的正确性，所以绝对不要说MATLAB不重要。而且一般Xilinx的IP核都可以生成相应的m文件，也就是说我们可以实现MATLAB与Modelsim完全一致的验证。 所以要想做信号处理或算法得FPGA实现一定要掌握MATLAB。
FFT进行重配置 我们在定制FFT IP核得时候就已经对FFT进行了配置，但是我们实际使用IP得时候经常可以碰见IP得重配置，这一块内容直至一年前我进行PLL得重配置得时候还是无从下手，但是这篇文章我们主要讲解FFT IP得重配置，可以让大家学习到Xilinx IP重配置得设计技巧。这里我们首先强调技术手册得重要性，因为市面上没有这方面得资料，所以我们要学习相应IP得重配置必须学习技术手册。我们首先看FFT IP得技术手册如下：
总共不到100页，是值得浏览一遍的，因为其他得IP基本上也是这几部分。C Model我们上篇博客已经进行了介绍，主要是为了我们在MATLAB中验证该模块得正确性来使用的。
首先我们来看FFT IP核的接口引脚：
其中FFT的接口主要可以分为6组如上图：
1、FFT的重配置接口
2、FFT的数据输入接口，遵循AXI-Stream协议
3、FFT的时钟、时钟使能、复位信号（注意复位信号要多给几个时钟）
4、FFT的数据输出接口，遵循AXI-Stream协议
5、可以输出FFT IP的当前的状态（一般不常使用）
6、可以输出一些FFT的错误信息，比如输入的last未知不正确或没有，数据溢出等等
上面是简要介绍了FFT IP的接口描述。具体的功能引脚的定义还是需要我们查找技术手册，我们这篇博客主要讲解IP的重配置，不会对AXI-Stream进行过多的介绍。
从FFT IP技术手册的首页我们可以发现，FFT可以完成的功能：
上面也是我们进行重配置的主要内容：
1、FFT最大变换的点数
2、FFT正变换还是逆变换
3、每级蝶形运算缩放因子的输入
4、CP_LEN的长度（这个具体的所用，我也不知道，知道的同学可以在评论里讨论一下）
要想配置上面的这些信息，我们就一定要进行配置数据的输入，配置数据的不同位数代表不同的功能，如下：
上面为什么会有PAD，主要是因为字节对齐，每个配置功能占整数个字节。其中除了SCALE_SCH上面的位宽都是确定的，如下：
上面每位的取值情况如下：
上面的功能需要大家仔细读，尤其是SCALE_SCH，这里我给大家稍微解读一下。
1、每两个比特位构成的数字作为一级蝶形运算的缩放比例。2位比特位构成了0，1，2，3，这三个数代表分别代表蝶形运算之后的结果移位的个数。
2、SCALE_SCH的位数对于基-4 FFT算法是 2 ∗ c e i l ( N F F T 2 ) 2*ceil(\frac{NFFT}{2}) &lt;/span&gt;&lt;span class="katex-html"&gt;&lt;span class="base"&gt;&lt;span class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e071fa233ebc6e1df6d9f6550ebc331f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e015c1a08c6893e3d5f5a2633993891/" rel="bookmark">
			VIVADO中的IP核在MATLAB中仿真
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VIVADO中的IP核在MATLAB中仿真 项目简述VIVADO建立FFT IP核MATLAB调用FFT IP核小结总结 项目简述 我们都会用MATLAB进行算法验证，但是经常会发现如果VIVADO中调用了IP核，那么最终会发现VIVADO与MATLAB之间的数据不可以统一的对应起来。那么，MATLAB验证的效果就会大大下降，那么可不可以想办法将VIVADO中的IP核封装成一个函数在MATLAB中调用呢？答案是可以的。这篇博客主要以FFT的IP核为例讲解封装成一个函数并且成功在MATLAB中调用。
本次实验所使用的软硬件工具如下：
1、VIVADO 2019.1
2、MATLAB 2015b
3、VS2015
VIVADO建立FFT IP核 首先建立VIVADO工程，然后选择FFT IP核开始定制
这里定制一下IP的信息，这里需要注意定制IP的信息与MATLAB中调用的文件的设置需要一样，这样才可以将MATLAB中的数据与VIVADO相对应。
上面每步定制的意思我们在前面讲解FFT IP的时候已经进行了相应的讲解，需要学习的同学可以查阅前面的文章，这里我们不再赘述。最后点击生成FFT 的IP核。这里特别要注意，数据的输入输出是AXI-Stream格式的数据，也就是说是以字节对齐的，比如所输入数据实部12位、虚部11位，那么在输入数据线上的表示就是实部16位、虚部16位。这也是很多初学者不明白数据位宽与自己设置不一样的原因。
MATLAB调用FFT IP核 上面我们已经生成了FFT IP，然后再生成目录的cmodel文件中有相应的文件，但是需要我们提前编译一下，这里选择的编译环境是VS2015。cmodel中的文件有两个，如下：
上面的是linux系统，下面的是windos系统。我们将下面的文件进行解压放到MATLAB的文件夹中。然后打开MATLAB切换到相应的文件夹下：
然后再MATLAB的命令行输入 run make_xfft_v9_1_mex，然后出现如下结果：
在生成文件中多出了.mexw64后缀的文件证明我们生成相应的MATLAB函数成功。然后查阅技术手册，会发现函数的调用主要有以下几个端口：
函数调用的输出如下：
上面的参数在使用的时候要与VIVADO的IP定制的时候相一致，那么在MATLAB中调用该函数的时候才可以与VIVADO中仿真出来的结果相一致。而且前面我们定制IP的时候选择的是可以实施配置，那么只需要我们MATLAB与VIVADO实时配置的参数相一致，MATLAB与VIVADO两个输出的结果完全一致，最终实现了VIVADO中的IP核在MATLAB中调用的现象。
下面以FFT为例给出相应的代码：
clc; clear all; addpath(genpath(pwd)); sim_options = struct(... 'MODE', '2k' ... %fft模式 1k 2k 4k 8k ); tx_nFrame=1; %------------------------------------------------------------------------------ % Parameters Definition %------------------------------------------------------------------------------ switch sim_options.MODE case '1k' NFFT = 1024; % FFT number of points case '2k' NFFT = 2048; % FFT number of points case '4k' NFFT = 4096; % FFT number of points case '8k' NFFT = 8192; % FFT number of points otherwise, error('sim_options UNKNOWN MODE'); end %------------------------------------------------------------------------------ % Input arguments checking %------------------------------------------------------------------------------ q_in = quantizer( 'mode','fixed','roundmod', 'floor','overflowmode','wrap','format',[12 11]); q_out = quantizer( 'mode','fixed','roundmod', 'floor','overflowmode','wrap','format',[12 11]); %gen data % DataIn_x = -1+2rand(1,NFFT);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e015c1a08c6893e3d5f5a2633993891/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/057bc22923c94f70898f81bb44d4514e/" rel="bookmark">
			uni scroll-view 中使用scroll-into-view 滚动到指定位置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.使用 scroll-view 标签的属性：scroll-top(距离值 num) 或 scroll-into-view(子元素的id,不能以数字开头 string)
&lt;scroll-view :scroll-top="scrollTop" :scroll-into-view="toviews" scroll-y scroll-with-animation :style="{ height: screenHeight + 'px' }" &gt; 2.scroll-into-view的值为子元素的id，不能以数字开头
子元素：
&lt;view class="item-essay" :id="`s${options.id}`" v-for="options in prenatalList" :key="options.id" &gt; 3.遇到的问题
数据是否准确：确保 scroll-into-view 中的值确实存在于 scroll-view 内，以及其格式是否正确。我使用了 `s${options.id}`，这个值是根据 options.id 动态生成的。确保这个值是唯一的，并且与 scroll-view 内的某个子元素的 id 匹配。
生命周期问题：scroll-view 的 scroll-into-view 属性需要在 scroll-view 组件已经渲染完毕后才会生效。确保在页面或组件的生命周期中设置 scroll-into-view 属性时，scroll-view 已经被渲染出来了。所以就需要等scroll-view中的数据prenatalList 加载完成再设置 toviews的值
异步加载问题：如果 scroll-view 或子元素是在异步加载数据后添加到页面的，确保在数据加载完成后设置 scroll-into-view 属性。可以使用异步settimeout或者nexttick
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d87c54dfc38ae527af114b4f8574f15/" rel="bookmark">
			运放虚短的本质（V&#43;=V-的本质）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		虚短
先说结论，虚短使用有两个条件
a、电路为负反馈电路
b、运放工作在线性放大区
要理解这两点，我们只需要知道“虚短”是咋来的就好了
首先，虚短的意思是什么呢？
我们知道，运放有两个输入端，同相端和反相端，“虚短”说的就是同相端和反相端的电压一样，就跟短路一样，那它是如何做到这一点的呢？我们前面说的理想运放的三个特点也没有这个呀？
下面就以下图的电路为例子，看看为什么最终是u+ = u-的？
假设刚开始时，各处电压为0，突然u1瞬间从0变为2.5V，因为uo一开始为0V，根据“虚断”，u-没有电流流入放大器，所以u-为uo在R1和R2上的分压，依然为0V。
当u+瞬间为2.5V后，u-为0V，u+&gt;u-，放大器会朝着电压增大的方向进行放大，即uo电压会开始升高。
当uo增大到1V，u-依然为uo的在R1和R2上的分压，即为0.5V。此时u+=2.5V，u-=0.5V，u+&gt;u-，放大器将电压继续正向放大，因此uo继续增大。
那问题来了，uo增大到多少会停止呢？很容易想到，只要u+&gt;u-，因为我们现在讨论的是理想运放，放大倍数为无穷大，所以uo就会增大（放大器是这样一个装置，它总是将输入电压放大Auo倍，即总满足：Uo=Au*（u+ - u-））。
只有当uo增加到5V时，u-电压为uo在R1和R2的分压正好是2.5V，u-等于u+，此时放大器达到平衡，不再放大，即稳定态就是现在了。
那为什么稳定态一定是u- = u+，u- &gt; u+不行吗？
我们也可以假设下，万一uo一不小心超过了5V，那么u-就会大于2.5V，u-会大于u+，此时放大器会将输出电压反方向放大，也就是减小，最终电压还是会向5V逼近。
因此，不论电路初始状态电压是怎么样的，最终输出都会稳定在5V，而且u+ = u-，因为一旦u+不等于u-，那么在无穷大的放大倍数下，输出必然会变化，最终还是会导致u+ = u-。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/faa780cec2a9bbab681393b58e705e9c/" rel="bookmark">
			【Java序列化时间，Long类型全局配置】Java全局序列化LocalDateTime为时间戳配置类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【Java序列化时间，Long类型全局配置】Java全局序列化LocalDateTime为时间戳配置类
各位好
今天笔者跟大家分享一个实际开发中经常遇到的问题
问题 1 LocalDateTime返回前端包含T处理
问题2 Long类型返回前端失真问题
直接上代码：
@Configuration public class JacksonConfig { /** * Json序列化和反序列化转换器，用于转换Post请求体中的json以及将我们的对象序列化为返回响应的json */ @Bean public ObjectMapper objectMapper() { ObjectMapper objectMapper = new ObjectMapper(); //忽略实体类中不存在的属性 objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false); //LocalDateTime系列序列化和反序列化模块，继承自jsr310 JavaTimeModule javaTimeModule = new JavaTimeModule(); // 自定义 全局把返回时间转为 时间戳 TemporalAccessorToLongSerializer date2Long = new TemporalAccessorToLongSerializer(); // Date2LongSerializer instance = Date2LongSerializer.instance; javaTimeModule.addSerializer(LocalDateTime.class, date2Long); javaTimeModule.addSerializer(LocalDate.class, date2Long); // 自定义 全局把入参时间转为 时间戳 javaTimeModule.addDeserializer(LocalDateTime.class, new LocalDateTimeDeserializer(DateTimeFormatter.ofPattern(BaseConst.PATTERN_DATETIME))); javaTimeModule.addDeserializer(LocalDate.class, new LocalDateDeserializer(DateTimeFormatter.ofPattern(BaseConst.PATTERN_DATE))); // 自定义 全局返回值Long转换为字符串 SimpleModule simpleModule = new SimpleModule(); simpleModule.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/faa780cec2a9bbab681393b58e705e9c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8647ca30eada42bfd26caff1a20b97c/" rel="bookmark">
			react-native技术难点与亮点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记录在数字化矿山 react-native App项目上所使用的知识点
文章目录 1，宽度自适应表格实现2，新建作业手势动画3，tabBar中间midTabBar动态展示4，堆料图实现5，语音识别实现6，待办事项上下滑动切换页面7，装料卸料手势冲突8，首页初始化性能9，使用高德地图的地图覆盖物功能10，复杂表格的交互绘制 1，宽度自适应表格实现 分析： 1,需要内容宽度上自适应，高度上可分页滑动。 2,标题栏宽度上与内容保持同步滑动，高度上悬浮。 2，新建作业手势动画 分析: 1,手势上响应点击、长按不冲突。 2,长按响应手机震动、组件动画放大功能。 3,长按之后响应拖动手势，且动画与手势同步。 3，tabBar中间midTabBar动态展示 分析: tabBar上共计5个页面(中间midTabBar也是一个页面)，midTabBar共计4种状态。 1,当前页面不是midTabBar,根据业务展示png与gif，且能实现这两者的动态切换。 2,当前页面是midTabBar,静态展示"+"图片。点击旋转动画成"x"图片，且在midTabBar页面动画展示弹窗。再次点击旋转动画成"+"图片,且在midTabBar页面动画隐藏弹窗。 4，堆料图实现 分析: 1,需要高性能实现堆料图基本功能(目前Echarts对安卓低配手机的渲染经常出不来)。 2,支持弹窗放大、缩小、拖动手势。 5，语音识别实现 分析: 1,长按语音按钮，app会出现语音识别第二画，同时启动语音识别功能、声纹图功能，并以触觉上的震动、界面的切换、波浪纹动画的方式反馈用户开始录入语音，同时伴随录音时长动态展示。 2,其中声纹图是根据当前语音真实的分贝值采点取样，以左右平移展开动画的方式动态展示。且波纹图的开启、关闭与语音识别保持一致。 3,在录入过程中，用户可以继续手势拖动录音按钮到“取消区域”，此时取消区域会以红色警告以及震动的方式告知用户“在这里拖动释放会取消并清空本次的语音录入”。 4,用户录入结束释放语音按钮即可，语音按钮会重新归位到第二画的初始位置方便用户接着录入。此时出现页面的关闭按钮、语音时长展示文案，用户可以用来进行确认语音录入完成，或者取消录音等操作。语音识别录入累计时长为60s，超时会友好提示用户。 5,在用户确认录音完成之后，会把语音以及可修改识别后的文案带到语音识别第一画作为录入结果保存，用户仍可以进行编辑、聆听语音、修改文案、删除结果以及切换录入方式等操作，在用户提交之后相关信息会同步到后台服务器。 6，待办事项上下滑动切换页面 分析: 1,页面内容过长可滑动。 2,滑动到页面顶部触发查看上一条待办。 3,滑动到页面底部触发查看下一条待办。 7，装料卸料手势冲突 分析: 1,底部“破碎站、挖机”弹窗可手势滑动展开、关闭。 2,矿车页面内容区域可手势滑动查看更多矿车。 3,矿车页面内容区域实现矿车根据业务的竖直方向上动态移动位置。 4,其他区域可手势滑动切换当前下一个“破碎站/挖机”装料卸料页面。这一点与第2条手势上需要解决冲突。 8，首页初始化性能 分析: 1,页面模块上需要初始化今日异常统计模块、入库质量模块、消息模块、柴油领用图表模块、作业量统计图表模块、权限模块、堆料图模块、待办模块、websocket模块、用户信息模块等。需要着重考虑性能问题。 9，使用高德地图的地图覆盖物功能 分析: 1,在高德地图上添加覆盖物，并限制高德地图的视野范围 10，复杂表格的交互绘制 需求：如下图所示，一整个表格为一个矿区，每个方块为矿块，业务上通过选择矿块选择来下发矿山项目的开采指令。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8ddddd72fbdd8b1b7ce8fd031687bab/" rel="bookmark">
			AspectJX - Android开发平台的AOP框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		官网 GitHub - HujiangTechnology/gradle_plugin_android_aspectjx: A Android gradle plugin that effects AspectJ on Android project and can hook methods in Kotlin, aar and jar file.
项目简介 一个基于AspectJ并在此基础上扩展出来可应用于Android开发平台的AOP框架，可作用于java源码，class文件及jar包，同时支持kotlin的应用。
如何使用 AspectJX是基于 gradle android插件1.5及以上版本设计使用的，如果你还在用1.3或者更低版本，请把版本升上去。
本使用说明是基于重构后的2.0.0版本编写的，如需要查阅旧版本的README，请切换到对应的Tag。
插件引用 在项目根目录的build.gradle里依赖AspectJX
dependencies { classpath 'com.hujiang.aspectjx:gradle-android-plugin-aspectjx:2.0.8' } 或者使用product目录下的jar包，在你的项目根目录下新建目录plugins，把product/gradle-android-plugin-aspectjx-2.0.0.jar拷贝到plugins，依赖jar包
dependencies { classpath fileTree(dir:'plugins', include:['*.jar']) } 注意:
区别于旧版本，离线新版本不再需要依赖org.aspectj:aspectjtools:1.8.+compile 'org.aspectj:aspectjrt:1.8.+' 必须添加到包含有AspectJ代码的module. 可以参考Demo 在app项目的build.gradle里应用插件 apply plugin: 'android-aspectjx' //或者这样也可以 apply plugin: 'com.hujiang.android-aspectjx' AspectJX配置 AspectJX默认会处理所有的二进制代码文件和库，为了提升编译效率及规避部分第三方库出现的编译兼容性问题，AspectJX提供include,exclude命令来过滤需要处理的文件及排除某些文件(包括class文件及jar文件)。
注意：2.0.0版本之后旧版本的includeJarFilter和excludeJarFilter命令废弃，不再支持使用
2.0.0版本的 include,exclude通过package路径匹配class文件及jar文件，不再支持通过jar物理文件路径匹配的方式，比如：
支持
aspectjx { //排除所有package路径中包含`android.support`的class文件及库（jar文件） exclude 'android.support' } 不支持
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8ddddd72fbdd8b1b7ce8fd031687bab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c31dba5cbc5925da595a8186f8a9b5ca/" rel="bookmark">
			Headers were already written Wanted to override status code 400 with 200
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		gin debug 打印出上面的日志。原因是代码报错后，调用如下代码
c.JSON(http.StatusBadRequest, xxx) 没有使用return返回，继续往下执行进行覆盖出了问题。
直接return即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c93a4e416f334c2dd0fa1c371080891/" rel="bookmark">
			package.json和package-lock.json
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、package.json 定义了当前项目所需要引用的各个模块，可以手工修改配置，也可以删除后，使用npm init命令重新自动生成。
但是该文件只锁定大版本号，也就是版本号的第一位，所以你会发现两个文件中同一个包的版本号不一致，但是第一位一定是一致的。
1、锁定小版本 如需锁定小版本，修改配置文件，去掉版本号前面的小尖尖即可。
"dependencies": { "axios": "^0.21.1", "element-ui": "2.15.1", }, 例如：
此处的axios，若执行npm install，会下载当前大版本下的最新版本。
而此处的element-ui，若执行npm install，会锁定下载2.15.1版本。
2、开发环境和生产环境 有些包是开发过程中需要使用，打包部署到线上无需使用的。
在安装的时候注意使用安装命令：
npm install --save -dev即npm install -D
仅在开发环境时，安装使用。
而npm install默认是安装在开发和生产环境的。
查看package.json文件有：
"dependencies": { "axios": "^0.21.1", "echarts": "^5.3.1" …… }, "devDependencies": { "@vue/cli-plugin-babel": "^4.5.10", "@vue/cli-plugin-eslint": "^4.5.10", "@vue/cli-service": "^4.5.10", "@vue/eslint-config-standard": "^5.1.2", "babel-eslint": "^10.1.0", "eslint": "^6.7.2", "eslint-plugin-import": "^2.20.2", "eslint-plugin-node": "^11.1.0", "eslint-plugin-promise": "^4.2.1", "eslint-plugin-standard": "^4.0.0", "eslint-plugin-vue": "^6.2.2", "sass": "^1.26.5", "sass-loader": "^8.0.2", "vue-template-compiler": "^2.6.11" }, 像axios、echarts等在生产环境需要使用的，就默认安装至dependencies（开发和生产环境）；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c93a4e416f334c2dd0fa1c371080891/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1efc1edcaaf8006c95e184c613764f70/" rel="bookmark">
			NextJS开发：shadcn/ui实现table表头固定tbody滚动效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		NextJS + shadcn/ui实现 shadcn/ui的组件相比React中的Ant Design、Vue中的iview、element ui中的组件缺少太多属性，需要组合tailwindcss中定义好的class来实现效果，Headless UI有自己的优势，更加灵活，但要求对原生的css要有足够经验。
导入包 "use client" import { Table, TableBody, TableCaption, TableCell, TableHead, TableHeader, TableRow, } from "@/components/ui/table" 定义数据 const invoices = [ { id: "INV001", paymentStatus: "Paid", totalAmount: "$250.00", paymentMethod: "Credit Card", }, { id: "INV002", paymentStatus: "Pending", totalAmount: "$150.00", paymentMethod: "PayPal", }, { id: "INV003", paymentStatus: "Unpaid", totalAmount: "$350.00", paymentMethod: "Bank Transfer", }, { id: "INV004", paymentStatus: "Paid", totalAmount: "$450.00", paymentMethod: "Credit Card", }, { id: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1efc1edcaaf8006c95e184c613764f70/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f194685133ca9af2fc9d1649252b32dc/" rel="bookmark">
			Windows系统安装使用nvm
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 nvm——管理node版本的工具 在日常工作中，可能会遇到很多项目的node版本不同导致无法运行，我们需要一个可以随时切换node版本的工具——nvm
安装步骤 卸载原有的node.js
在电脑控制面板中卸载即可
下载安装nvm，下载安装位置建议为默认
nvm下载地址
修改nvm的源
使用nvm下载node版本，默认源在国外，可能会下载失败，因此我们需要修改nvm的源为淘宝镜像。
C:\Users\电脑用户名\AppData\Roaming\nvm的 setting.txt 文件
//在文件末尾加入 node_mirror: https://npm.taobao.org/mirrors/node/ 4. nvm命令
//查看当前安装的所有node版本 nvm list //安装某个node版本 版本号样例：v14.15.2 nvm install 版本号 //切换node版本 nvm use 版本号 //nvm卸载某个node版本 nvm uninstall 版本号 //设置默认版本 nvm alias 版本号 可能遇到的问题 使用nvm use切换node版本时报如下错误，可能是由于未使用管理员身份运行。
解决方法：将命令提示符使用管理员身份运行即可解决
安装某一版本后，使用npm命令提示npm不是内部命令，但node版本显示正常，可能是安装node时缺失文件。
解决方法：使用卸载node命令 nvm uninstall 版本号 将其node版本卸载，重新安装可解决问题 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7aa49c817cc4aaba794fa43293b56a85/" rel="bookmark">
			ElementUI中的el-tab-pane组件使用v-show不生效的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 现象：
在el-tab-pane标签上使用v-show，即使v-show的值为false，el-tab的标签仍然展示。即使将v-show加在slot子节点上，也会显示tab的背景图和close图标；如下图：
解决方法一：可以使用使用v-if，亲测有效。
但是有些场景下不适合使用v-if，比如切换比较频繁，并且需要保留之前的状态等
解决方法二：
注意观察tab的dom结构，你会发现el-tab-pane会生成一个唯一id，id的值就是tab-加上name属性的值。
watch:{ '会改变的值'(val){ if(xxxxx){ // 根据条件判断、如果需要隐藏，则获取到id后设置style的display为none document.getElementById(`tab-${需要设置的tab的name}`).style.display = 'none'; } else { // 如果需要显示、则获取到id后设置style的display为inline-block document.getElementById(`tab-${需要设置的tab的name}`).style.display = 'inline-block'; } } } 解决方法三：
原理类似方法二，使用this.$refs.tabs.$children[0].$refs.tabs获取到dom元素后修改样式
在el-tabs元素上加上ref：
this.$refs.tabs.$children[0].$refs.tabs获取到的值：所有tab页签dom元素的集合。如下图：
watch: { tabActive: { handler(val) { // this.$refs.tabs.$children[0].$refs.tabs获取到的就是所有的tab页签dom元素的集合 // 遍历之后，item.id就是div元素的id属性 // 里面会有tab对应的id值，判断id是否包含顶部页签的值，关联上 // 再设置style是否显示与隐藏 let tabList = this.$refs.tabs.$children[0].$refs.tabs; tabList &amp;&amp; tabList.map(item =&gt; { if (!item.id.includes(this.srcTabActive + val)) { item.style.display = 'none'; } else { item.style.display = 'inline-block'; } }); }, deep: true } }, 如果帮助到您了，可以留下一个赞👍告诉我 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/460fb80a0b6d391ad186070857cf7513/" rel="bookmark">
			SSM之spring注解式缓存redis
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🎬 艳艳耶✌️：个人主页
🔥 个人专栏 ：《Spring与Mybatis集成整合》《Vue.js使用》
⛺️ 越努力 ，越幸运。
1.Redis与SSM的整合 1.1.添加Redis依赖 在Maven中添加Redis的依赖
&lt;redis.version&gt;2.9.0&lt;/redis.version&gt; &lt;redis.spring.version&gt;1.7.1.RELEASE&lt;/redis.spring.version&gt; &lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;${redis.version}&lt;/version&gt; &lt;/dependency&gt; 1.2.spring-redis.xml的相关配置 1.2.1注册一个redis.properties redis.hostName=localhost redis.port=6379 redis.password=123456 redis.timeout=10000 redis.maxIdle=300 redis.maxTotal=1000 redis.maxWaitMillis=1000 redis.minEvictableIdleTimeMillis=300000 redis.numTestsPerEvictionRun=1024 redis.timeBetweenEvictionRunsMillis=30000 redis.testOnBorrow=true redis.testWhileIdle=true redis.expiration=3600 但是当spring-context.xml中需要注册多个properties文件，那么我们就不能够直接在spring-*.xml中添加注册，因为这样子的话，只能够读取一个配置文件，另一个配置文件会被覆盖掉，我们可以建一个文件用来专门引入外部文件
applicationContext
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"&gt; &lt;!--1. 引入外部多文件方式 --&gt; &lt;bean id="propertyConfigurer" class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"&gt; &lt;property name="systemPropertiesModeName" value="SYSTEM_PROPERTIES_MODE_OVERRIDE" /&gt; &lt;property name="ignoreResourceNotFound" value="true" /&gt; &lt;property name="locations"&gt; &lt;list&gt; &lt;value&gt;classpath:jdbc.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/460fb80a0b6d391ad186070857cf7513/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15a8227600cf8f82d0c0810b00c17cc4/" rel="bookmark">
			css导航--鼠标点击样式跟随滑动选中效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		应用到的icon 地址
https://ionic.io/ionicons/usage
引入icon
&lt;script type="module" src="https://unpkg.com/ionicons@7.1.0/dist/ionicons/ionicons.esm.js"&gt;&lt;/script&gt; 使用起来很方便 点击Icons 进行查询自己想要的icon即可
dom部分
&lt;div class="BoxStyle"&gt; &lt;div class="navigation"&gt; &lt;ul&gt; &lt;li class="active"&gt; &lt;a href="#"&gt; &lt;span class="icon"&gt;&lt;ion-icon name="home-outline"&gt;&lt;/ion-icon&gt;&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href="#"&gt; &lt;span class="icon"&gt;&lt;ion-icon name="people-outline"&gt;&lt;/ion-icon&gt;&lt;/span &gt;&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href="#"&gt; &lt;span class="icon" &gt;&lt;ion-icon name="chatbubble-outline"&gt;&lt;/ion-icon&gt;&lt;/span &gt;&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href="#"&gt; &lt;span class="icon" &gt;&lt;ion-icon name="camera-outline"&gt;&lt;/ion-icon&gt; &lt;/span &gt;&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href="#"&gt; &lt;span class="icon"&gt; &lt;ion-icon name="settings-outline"&gt;&lt;/ion-icon&gt;&lt;/span &gt;&lt;/a&gt; &lt;/li&gt; &lt;div class="indicator"&gt; &lt;span&gt;&lt;/span&gt; &lt;/div&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; // 实现样式切换 &lt;script&gt; //获取所有的 li标签 let list = document.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/15a8227600cf8f82d0c0810b00c17cc4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff14e48179d9b6baff9af1a39b53d947/" rel="bookmark">
			SSM-spring注解式缓存redis
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一.redis整合
1.1.pom配置
1.2.配置文件spring-redis.xml
1.3.配置redis的key生成策略
二.redis的注解式开发及应用场景
2.1.什么是redis的注解式
2.2.@Cacheable
2.3.自定义策略
2.4.CachePut 注解
三.redis的击穿穿透雪崩
1.击穿问题
2.穿透问题
3.雪崩问题
一.redis整合 注1：当spring-context.xml中需要注册多个.properties,那么
不能在spering-*.xml中添加注册
注2：resources的配置必须要涵盖读取.preperties 结尾的文件
注3：redisTemplate的使用，可以参照jdbcTemplate,amqpTemplate,rabbitMQtemplate
1.1.pom配置 &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;ssm2&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;name&gt;ssm2 Maven Webapp&lt;/name&gt; &lt;!-- FIXME change it to the project's website --&gt; &lt;url&gt;http://www.example.com&lt;/url&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;maven.compiler.plugin.version&gt;3.7.0&lt;/maven.compiler.plugin.version&gt; &lt;!--添加jar包依赖--&gt; &lt;!--1.spring 5.0.2.RELEASE相关--&gt; &lt;spring.version&gt;5.0.2.RELEASE&lt;/spring.version&gt; &lt;!--2.mybatis相关--&gt; &lt;mybatis.version&gt;3.4.5&lt;/mybatis.version&gt; &lt;!--mysql--&gt; &lt;mysql.version&gt;5.1.44&lt;/mysql.version&gt; &lt;!--pagehelper分页jar依赖--&gt; &lt;pagehelper.version&gt;5.1.2&lt;/pagehelper.version&gt; &lt;!--mybatis与spring集成jar依赖--&gt; &lt;mybatis.spring.version&gt;1.3.1&lt;/mybatis.spring.version&gt; &lt;!--3.dbcp2连接池相关 druid--&gt; &lt;commons.dbcp2.version&gt;2.1.1&lt;/commons.dbcp2.version&gt; &lt;commons.pool2.version&gt;2.4.3&lt;/commons.pool2.version&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ff14e48179d9b6baff9af1a39b53d947/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/597075b3b98e6e65a938a3b6c6c7c2f4/" rel="bookmark">
			Chatgpt人工智能对话源码系统分享 带完整搭建教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ChatGPT的开发基于大规模预训练模型技术。预训练模型是一种在大量文本数据上进行训练的模型，可以学习到各种语言模式和知识。在ChatGPT中，预训练模型被用于学习如何生成文本，并且可以用于各种不同的任务，如对话生成、问答、摘要等。今天小编就来给大家介绍一款chatgpt人工智能对话系统，带有完整的搭建教程。
以下是部分核心功能代码块：
特色功能：
1.对话生成：ChatGPT的核心功能是对话生成。用户可以输入一个问题或一段文本，模型会根据输入的内容生成相应的回复。这种回复既自然又流畅，几乎可以与人类对话相媲美。
2.上下文理解：ChatGPT具有强大的上下文理解能力。它可以理解用户输入的上下文，并根据此生成回复。这意味着用户可以在对话中更自然地切换话题，而模型也可以根据上下文来生成更准确的回复。
3.多种语言支持：ChatGPT支持多种语言，包括英语、中文、西班牙语、法语等。这使得它能够适应不同国家和地区的用户需求。
4.自动摘要：ChatGPT还可以用于自动摘要。用户可以输入一段文本，模型会自动提取关键信息并生成摘要。这种功能在阅读长篇文章或大量文档时非常有用。
5.问答系统：ChatGPT可以被用作问答系统。用户可以输入一个问题，模型会尝试回答问题并提供相关的信息。这种功能可以帮助用户快速获取所需的信息。
6.语言翻译：ChatGPT还支持语言翻译功能。用户可以将一段文本输入模型，然后选择想要翻译成的目标语言。模型将自动翻译文本并生成回复。这种功能使得ChatGPT成为一个多语种交流工具。
7.个性化回复：ChatGPT具有个性化回复的功能。模型可以根据用户的喜好和历史记录生成个性化的回复。这种功能使得ChatGPT能够更好地满足不同用户的需求。
页面展示：
源码下载地址：春哥技术博客——Chatgpt人工智能对话系统
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ed23a2cbdd1a1b0e9af8801d3d23dfa/" rel="bookmark">
			机器学习概论
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、机器学习概述
1、机器学习与人工智能、深度学习的关系
2、机器学习的范围
3、机器学习可以解决什么问题
给定数据的预测问题：
二、机器学习的类型
1、监督学习
分类（Classification）
回归（Regression、Prediction）
2、无监督学习
聚类（Clustering）
降维（ Dimensionality Reduction ）
3、强化学习
强化学习（Reinforcement Learning）
三、机器学习的开发流程
1、机器学习的一般步骤​编辑
2、数据决定一切
一、机器学习概述 1、机器学习与人工智能、深度学习的关系 人工智能：机器展现的人类智能机器学习：计算机利用已有的数据(经验)，得出了某种模型，并利用此模型预测未来的一种方法。深度学习：实现机器学习的一种技术 2、机器学习的范围 3、机器学习可以解决什么问题 给定数据的预测问题： 数据清洗/特征选择确定算法模型/参数优化结果预测 二、机器学习的类型 1、监督学习 分类（Classification） 身高1.65m，体重100kg的男人肥胖吗？根据肿瘤的体积、患者的年龄来判断良性或恶性？ 回归（Regression、Prediction） 如何预测上海浦东的房价？未来的股票市场走向？ 2、无监督学习 聚类（Clustering） 如何将教室里的学生按爱好、身高划分为5类？ 降维（ Dimensionality Reduction ） 如何将将原高维空间中的数据点映射到低维度的空间中？ 3、强化学习 强化学习（Reinforcement Learning） 用于描述和解决智能体（agent）在与环境的交互过程中通过学习策略以达成回报最大化或实现特定目标的问题 。 三、机器学习的开发流程 1、机器学习的一般步骤 2、数据决定一切 通过这张图可以看出，各种不同算法在输入的数据量达到一定级数后，都有相近的高准确度。于是诞生了机器学习界的名言： 成功的机器学习应用不是拥有最好的算法，而是拥有最多的数据！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5cd537d6cda1caab004d634a2b64179b/" rel="bookmark">
			机器学习——回归
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、线性回归
1、回归的概念（Regression、Prediction）
2、符号约定
3、算法流程
4、最小二乘法（LSM）
二、梯度下降
梯度下降的三种形式
1、批量梯度下降（Batch Gradient Descent,BGD）：
2、随机梯度下降（Stochastic Gradient Descent,SGD）：
3、小批量梯度下降（Mini-Batch Gradient Descent,MBGD）：
梯度下降与最小二乘法比较
梯度下降：
最小二乘法：
数据归一化/标准化
为什么要标准化/归一化？
归一化（最大 - 最小规范化）
Z-Score标准化
需要做数据归一化/标准化
不需要做数据归一化/标准化
三、正则化
1、过拟合和欠拟合
2、过拟合的处理
3、 欠拟合的处理
4、正则化
四、回归的评价指标
一、线性回归 1、回归的概念（Regression、Prediction） 如何预测上海浦东的房价？未来的股票市场走向？ 线性回归（Linear Regression）是一种通过属性的线性组合来进行预测的线性模型，其目的是找到一条直线或者一个平面或者更高维的超平面，使得预测值与真实值之间的误差最小化。
2、符号约定 m 代表训练集中样本的数量n 代表特征的数量x 代表特征/输入变量y 代表目标变量/输出变量(x,y) 代表训练集中的样本(x^(i),y^(i)) 代表第i个观察样本ℎ 代表学习算法的解决方案或函数也称为假设（hypothesis）̂┬y=ℎ(x),代表预测的值 建筑面积
总层数
楼层
实用面积
房价
143.7
31
10
105
36200
162.2
31
8
118
37000
199.5
10
10
170
42500
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5cd537d6cda1caab004d634a2b64179b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc0c3c21f27a5cee2d536aefcccdbbe8/" rel="bookmark">
			20张截图手把手教你Linux网络配置【多网卡配置 双网卡配置】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说明 本文是我在学习基于VMware Workstation Pro安装Oracle RAC时记录的笔记。因RAC需要配置两张网卡，我查阅了大量了文章，竟找不到一篇能帮我成功配置双网卡的教程。在我花费了一天多的时间反复动手尝试后，终于完成了配置，浪费了许多精力和时间。因此，我决定将操作过程记录下来，帮助更多有需要的同学把这个双网卡。
如果您只需要配置单网卡，不需要配置多张网卡的话，可以直接参考5-配置NAT静态ip地址配置NAT模式网卡即可。对于2-配置仅主机host-only模式网卡静态ip地址、3-配置桥接bridge模式网卡静态ip地址、4-配置nat模式网卡静态ip地址章节了解即可。
总结的过程中，我发现只要对Linux的三种网络模式的原理和特性熟悉后，配置网络其实一点也不复杂。因此，建议不要跳过1-三种网络模式介绍章节。
1 三种网络模式介绍 1.1 NAT模式 使用NAT模式，就是让虚拟机借助NAT（网络地址转换）功能，通过主机来访问网络。此模式下，如果主机可以访问互联网，那么虚拟机也可以，默认情况下和主机同一网络中的其它机器不能访问虚拟机，但虚拟机可以访问其它物理机。
具体是，主机网卡直接与虚拟NAT设备相连，然后虚拟NAT设备与虚拟DHCP服务器一起连接在虚拟网络适配器Vmnet8上，这样就实现了虚拟机联网。
优点：虚拟机可以访问外网、外网不可以访问虚拟机，使得虚拟机安全性得到保障。不用配置 IP，也没有 IP 地址资源限制。
缺点：主机如果不能访问外网，那么虚拟机也会受到影响而不能访问。
1.2 桥接（Bridge）模式 在桥接模式下，物理网卡和虚拟网卡在拓扑图上处于同等地位，物理网卡和虚拟网卡就相当于处于同一个网段，虚拟交换机就相当于一台现实网络中的交换机，所以两个网卡的IP地址也要设置为同一网段。
优点：这种模式虚拟机和主机处于平等地位，就好比多台物理机一样。主机和虚拟机都有独立的虚拟网卡，对于外网访问互不受影响。
缺点：因为每个虚拟机都需要一个IP，如果虚拟机很多、网段的IP地址可能分配有限。
1.3 仅主机（Host-Only）模式 在一些网络环境中，由于安全，调试等原因，可能需要将虚拟机和真实的物理环境隔离开来，那么此模式是首选。
其实Host-Only网络和NAT网络很相似，可以看成是NAT模式去除了虚拟NAT设备，使用虚拟DHCP服务器连接虚拟网络适配器Vmnet1来与虚拟机通信的，不同的地方就是Host-Only网络没有NAT服务，所以虚拟网络不能连接到Internet。此模式下的所有虚拟机可以相互访问，但和真实的物理网络环境是隔离开的，此模式下的IP信息，是由Host-Only虚拟网络的DHCP服务器来分配的。
优点：虚拟机与外网隔离，对于虚拟机的安全性有一定保障。且没有IP地址资源限制。
缺点：虚拟机无法与外网访问。
2 配置仅主机（Host-Only）模式网卡静态ip地址 配置静态IP地址的原因主要有以下几点：
稳定性更高：静态IP地址地址不会变化，使得网络监控和维护更加方便，网络服务更加可靠和稳定性。远程访问更方便：使用静态IP地址可以更方便地实现远程访问，创建的远程连接窗口只需要配置一次就可以。便于管理：静态IP地址是长期分派给一台网络设备使用的，因此可以通过IP地址直接找到对应的设备，便于网络管理。防止IP地址冲突：如果DHCP服务器故障，那电脑就会上不了网，所以要设置静态IP。在某些情况下，由于DHCP服务器故障，动态IP地址可能会出现冲突，配置静态IP可以避免这种情况发生。 为什么先配置仅主机（Host-Only）模式呢，原因是配置之后可以和物理机相互访问，能够使用安全终端模拟软件通过SSH协议远程连接虚拟机，如Xshell、PuTTY、MobaXterm等。
下面开始配置。
2.1 修改第一块网卡（默认自带一块NAT网卡） 在虚拟机设置中修改第一块网卡，选择仅主机模式，其他选项默认保持不变。
2.2 修改配置文件 一、根据虚拟网络适配器VMnet1的配置进行修改：
Windows系统终端输入：ipconfig /all
文件路径：/etc/sysconfig/network-scripts/ifcfg-ens32(或ifcfg-ens33)
二、修改网卡配置文件：
#修改： BOOTPROTO="static" #设置静态地址分配模式后重启网络服务IP地址不会变 #添加： IPADDR=192.168.136.2 NETMASK=255.255.255.0 修改后的完整配置如下：
TYPE="Ethernet" PROXY_METHOD="none" BROWSER_ONLY="no" BOOTPROTO="static" DEFROUTE="yes" IPV4_FAILURE_FATAL="no" IPV6INIT="yes" IPV6_AUTOCONF="yes" IPV6_DEFROUTE="yes" IPV6_FAILURE_FATAL="no" IPV6_ADDR_GEN_MODE="stable-privacy" NAME="ens33" UUID="7f2f73f2-d5e1-423f-ba7b-055772f33809" DEVICE="ens33" ONBOOT="yes" IPADDR=192.168.136.2 NETMASK=255.255.255.0 说明：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fc0c3c21f27a5cee2d536aefcccdbbe8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7ce218836303c26729ffb0e9ddfa55b/" rel="bookmark">
			数据结构学习笔记——链式存储结构实现队列（链队）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、链队的基本概念二、链队的代码实现（一）链队的定义（二）链队的初始化（三）链队判空（四）入队（插入操作）（五）出队（删除操作）（六）读取链队的队头元素（七）链队的遍历输出（八）链队的建立 ❤️链队的完整代码一个简单的链队基本实现例子 一、链队的基本概念 链队是通过带有队头指针和队尾指针的单链表实现的，使用链队的好处是可以避免出现队列满且溢出的问题，且适用于数据元素变动较大的情形时，若使用单链表来表示队列，则使用带尾指针的循环单链表最合适。 用循环链表表示的队列长度为n，若只设头指针，则出队和入队的时间复杂度分别为O(1)和O(n)；若只设尾指针，则出队和入队的时间复杂度为
O(1)和O(1)。
在链队中，队头指针Q.front指向队头结点，队尾指针Q.rear指向队尾结点，由于不带头结点的链队操作较为麻烦，一般将链队设置为带头结点的单链表，带头结点的链式队列如下图（其中队头指针指向头节点）：
不带结点的链式队列如下图：
以下代码的实现均为在带头结点的链式队列中操作。
二、链队的代码实现 （一）链队的定义 链队的存储类型可定义为：
//链式队列的定义 typedef struct LinkNode {	//链式队列的结点类型 int data;	//结点的数据域 struct LinkNode *next;	//结点的指针域 } LinkNode; typedef struct {	//链式队列 LinkNode *front,*rear;	//链式队列的队头指针和队尾指针 } LinkQueue; （二）链队的初始化 初始化时，通过malloc()函数创建一个只包含头结点的空链式队列Q，该头结点中包含队头指针front和队尾指针rear，然后将它们的指针域都指向空（NULL），代码如下：
//链式队列的初始化 void InitQueue(LinkQueue &amp;Q) { Q.front=Q.rear=(LinkNode *)malloc(sizeof(LinkNode));	//建立头结点 Q.front-&gt;next=NULL;	//初始化为空 } （三）链队判空 判断链队是否为空，只需判断Q.front==Q.rear即可，代码如下：
//判断链式队列是否为空队 bool EmptyQueue(LinkQueue Q){ if(Q.front==Q.rear) return true; else return false; } 由于通过链式存储实现队列，就不会存在容量的限制，所以不用考虑队列是否为满队。
（四）入队（插入操作） 入队的操作是在队尾进行的，首先创建一个新结点s，赋给其数据域x值，并将其指针域置为空，之后将其插入到队列的末尾，最后再将队尾指针指向该结点，如下图：
实现代码如下：
//入队操作 void EnterQueue(LinkQueue &amp;Q,int x){ LinkNode *s=(LinkNode *)malloc(sizeof(LinkNode));	//创建一个新结点s s-&gt;data=x;	//传入新结点s的数据域x值 s-&gt;next=NULL; //设置新结点s的指针域为空 Q.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c7ce218836303c26729ffb0e9ddfa55b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b9641e49fc403bb516d78b28b1dfb38/" rel="bookmark">
			高数笔记06：无穷级数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图源：文心一言
时间比较紧张，仅导图~~🥝🥝
第1版：查资料、画导图~🧩🧩 参考资料：《高等数学 基础篇》武忠祥
🐳目录 🐳常数项级数 🐋概要 🐳幂级数 🐋概要 🐋题型 🐳幂级数 🐋概要 🐋题型 🐳整体导图 😶‍🌫️思维导图为整理武老师基础教材所列内容，时间关系有些仓促，请多包涵~🌸如果图片看不清，试着保存在本地然后打开图片~~ 🔚结语 😶‍🌫️博文到此结束，写得模糊或者有误之处，欢迎小伙伴留言讨论与批评，督促博主优化内容~
🌟博文若有帮助，欢迎小伙伴动动可爱的小手默默给个赞支持一下，博主肝文的动力++~
🌸博主曾经佛系更新的导图在这里：
高等数学_梅头脑_的博客-CSDN博客https://blog.csdn.net/weixin_42789937/category_12380893.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/075d1d0cd66ba39106481584c399be83/" rel="bookmark">
			高数笔记05：不定积分与定积分
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图源：文心一言
时间比较紧张，仅导图~~🥝🥝
第1版：查资料、画导图~🧩🧩 参考资料：《高等数学 基础篇》武忠祥
🐳目录 🐳目录
🐳不定积分
🐋概要
🐋题型
🐳定积分
🐋概要
🐋题型
🐳反常积分
🐋概要
🐋题型
🐳二重积分
🐋概要
🐋题型
🐳整体导图
🔚结语
🐳不定积分 🐋概要 🐋题型 🐳定积分 🐋概要 🐋题型 🐳反常积分 🐋概要 🐋题型 🐳二重积分 🐋概要 🐋题型 🐳整体导图 😶‍🌫️思维导图为整理武老师基础教材所列内容，时间关系有些仓促，请多包涵~🌸如果图片看不清，试着保存在本地然后打开图片~~ 🔚结语 😶‍🌫️博文到此结束，写得模糊或者有误之处，欢迎小伙伴留言讨论与批评，督促博主优化内容~
🌟博文若有帮助，欢迎小伙伴动动可爱的小手默默给个赞支持一下，博主肝文的动力++~
🌸博主可能会佛系更新思维导图，在这里：
高等数学_梅头脑_的博客-CSDN博客https://blog.csdn.net/weixin_42789937/category_12380893.html
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/64/">«</a>
	<span class="pagination__item pagination__item--current">65/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/66/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>