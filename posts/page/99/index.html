<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9c8bc5fe95bd510d8cdc61c3eb02ef9/" rel="bookmark">
			Idea开发maven项目第三方依赖打不进结果jar中
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		默认的情况maven项目不打第三方包的，想要打一个完整的包就需要，把下面的插件依赖导入pom
&lt;build&gt; &lt;plugins&gt; &lt;!-- Maven Assembly Plugin --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt; &lt;version&gt;2.4.1&lt;/version&gt; &lt;configuration&gt; &lt;!-- get all project dependencies --&gt; &lt;descriptorRefs&gt; &lt;descriptorRef&gt;jar-with-dependencies&lt;/descriptorRef&gt; &lt;/descriptorRefs&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;make-assembly&lt;/id&gt; &lt;!-- bind to the packaging phase --&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;single&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 打完包后，除了原本的最小jar外，会有一个包名包含jar-with-dependencies的jar
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d00ae33efd609e3a66cea268e831d3f7/" rel="bookmark">
			SSH远程执行本地命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SSH远程执行本地命令
服务器有run.sh 脚本
#!/bin/bash # 请将以下IP地址替换为你要连接的远程电脑的IP地址 REMOTE_IP="127.0.0.1" # 请将以下用户名替换为你要连接的远程电脑的用户名 REMOTE_USER="root" if [ "$1" == "start" ];then echo "start参数：$1" &gt;&gt; /mnt/server/run.log ssh ${REMOTE_USER}@${REMOTE_IP} "sh /mnt/data/server/run.sh start" elif [ "$1" == "stop" ];then echo "stop参数：$1" &gt;&gt; /mnt/server/run.log ssh ${REMOTE_USER}@${REMOTE_IP} "sh /mnt/data/server/run.sh stop" else echo "无效参数：$1" &gt;&gt; /mnt/server/run.log fi 执行命令
./run.sh start 远程执行脚本并未生效，原因在于脚本中未有
source /etc/profile 将脚本更改为
#!/bin/bash # 请将以下IP地址替换为你要连接的远程电脑的IP地址 REMOTE_IP="127.0.0.1" # 请将以下用户名替换为你要连接的远程电脑的用户名 REMOTE_USER="root" if [ "$1" == "start" ];then echo "start参数：$1" &gt;&gt; /mnt/server/run.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d00ae33efd609e3a66cea268e831d3f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/038a4b0d33fc2b6cbabe5aef2d1961fa/" rel="bookmark">
			python 多个excel合并为一个
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		def combine(path, save): excel_list = [] for name in tqdm(os.listdir(path)): f = os.path.join(path, name) df = pd.read_excel(f) excel_list.append(df) target = excel_list[-1] for excel_f in excel_list[:-1]: target = pd.concat([target, excel_f], axis=0) target.to_excel(save, index=False) if __name__ == "__main__": path = r"" save = r"C:\Users\Desktop\combine.xlsx" combine(path, save) path为存放文件的文件夹，save为合成的excel路径
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fea8502d799ce06e9ff2777b79ac2c1f/" rel="bookmark">
			服务器运行python代码报错：intall python Extension
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当我安装时候又报错：
WARNING: Retrying (Retry(total=4, connect=None, read=None, redirect=None, status=None)) after connection broken by 'NewConnectionError('&lt;urllib3.connection.HTTPSConnection object at 0x7fef4efd1bb0&gt;: Failed to establish a new connection: [Errno 101] Network is unreachable')':
但是主要是运行程序的时候出问题。
我又试着重新连了服务器，没用。
万万没想到，竟然是这样解决的。
在试运行文件中，右键——run python file in terminal然后就不报错了。
导致我现在都没搞明白是怎么回事儿。怎么突然就可以运行了。
应该是原来运行的时候用的python文件丢失，然后使用这个命令的直接调用的别的python备份。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8106a8bab218f88e9dd0edc853f65707/" rel="bookmark">
			数模3：插值算法（Interpolation Algorithm）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.简介
2.模型
（1）一维插值
概念
A.Lagrange Interpolation
B.Piecewise Linear Interpolation
C.Newton Interpolation
D. Hermite Interpolation
E.Cubic Spline Interpolation
（2）n维插值
3.代码
4.REFERENCE
1.简介 在通常的数据处理时，会遇到现有的数据是极少的，不足以支撑分析的进行，或者数据出现错误或者明显不符合，这时就需要使用一些数学的方法，“模拟产生”一些新的但又比较靠谱的值来满 足需求，这就是插值的作用。
2.模型 （1）一维插值 概念 下图阐述了一般的插值法的概念与类别[1]:
A.Lagrange Interpolation 在次数较低的时候，插值较为精准，但是随着次数上升，会出现Runge现象。高次插值会产生龙格现象，即在两端处波动极大,产生明显的震荡。在不熟悉曲线 运动趋势的前提下，不要轻易使用高次插值。
Runge phenomenon:
B.Piecewise Linear Interpolation 插值多项式次数过高可能精度提升不明显，摄入误差可能显著增加。因此，考虑分段插值。
C.Newton Interpolation 差商定义：
一阶差商：
二阶差商：
k 阶差商：
对比 Newton Interpolation 和 Lagrange Interpolation：
与拉格朗日插值法相比，牛顿插值法具有继承性（牛顿插值法每次插值只和前n项的值有关，每次只要在原函数上添加新的项，就可产生新的函数）。但是两者均存在龙格现象的 问题。
上述两种插值仅要求插值多项式在插值节点处与被插函数有相等的函数值，而这种插值多项式却不能全面反映被插值函数的性态。
D. Hermite Interpolation 一般插值要求：
更高的要求：
这个要求的本质是是曲线在节点曲度一致，光滑切合。
具体原理参考[1]:
由于直接使用存在较高次的项，会出现龙格现象，实际使用的是分段三次Hermite Interpolation（PCHIP）。在Matlab里面由直接封装好的函数 pchip。
E.Cubic Spline Interpolation 具体定义见下图：
在Matlab中有封装好的函数 spline。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8106a8bab218f88e9dd0edc853f65707/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/677dabf665f505dc2f212e998bf4f93b/" rel="bookmark">
			微信小程序逆向 小程序包使用unveilr工具解包后在开发者工具报[ WXML 文件编译错误] xxx.wxs Unexpected token `}`
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微信小程序逆向 使用解包工具后后在开发者工具报[ WXML 文件编译错误] xxx.wxs Unexpected token }
页面上则报编译.wxml文件错误…
解决方案：
很简单，因为是解包出来的，一般代码都是没有错的，我们只需要微信微信开发者工具中的资源管理器或者其他地方，找到这个文件，然后对这个文件里面的代码进行格式化文档，保存之后就不会报错了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97a9a3fe66cf8749089b63be87935987/" rel="bookmark">
			如何进行数据交换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一般的情况下我们都是用变量t等变量来存储要进行数据交换的变量，我们用C语言为例
int a = 10; int b = 20; int t = 0; t = a; a = b; b = t; printf("%d %d", a, b); return 0; 这种用法用于像冒泡排序等类型的场景，这是一般的做法
接下来我们用另一种方法，用异或(xor)来进行数据交换
什么是异或呢？
异或，英文为exclusive OR，缩写成xor
异或(eor)是一个数学运算符。它应用于逻辑运算。异或的数学符号为"⊕"，计算机符号为"eor"。其运算法则为:
a⊕b = (¬a ∧ b) ∨ (a ∧¬b)
如果a、b两个值不相同，则异或结果为1。如果a、b两个值相同，异或结果为0。
异或也叫半加运算，其运算法则相当于不带进位的二进制加法:二进制下用1表示真，0表示假，则异或的运算法则为:0⊕0=0，1⊕0=1，0⊕1=1，1⊕1=0(同为0，异为1)，这些法则与加法是相同的，只是不带进位，所以异或常被认作不进位加法。
异或略称为XOR、EOR、EX-OR
程序中有三种演算子:XOR、eor、⊕。
使用方法如下
z = x ⊕ y
z = x eor y
用C语言写异或是用^。
注意：^在C语言中并不是我们数学认为的^，而是异或逻辑运算符，在C语言中数学的^是pow函数，这个函数要引用math.h头文件。
用C语言使用异或运算符例题：
int a = 10; int b = 20; a = a ^ b; b = a ^ b; a = a ^ b; printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/97a9a3fe66cf8749089b63be87935987/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4441454954a5d98b6b9429060e279c44/" rel="bookmark">
			python脚本——批量将word文档转换成pdf文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 语言：python 3
用法：点击运行后，弹出窗口选择word文档所在文件夹，程序运行后对该文件夹下所有的word文件全部转换成pdf文件，生成的pdf文件名字与原wrod文件相同。
如运行中报错，需要自行根据报错内容按照缺失的库
例如：
#安装库 pip install pyautogui #安装库 pip install pillow 完整代码如下：
import os import glob from tkinter import Tk from tkinter.filedialog import ask directory from win32com.client import DispatchEx #打开选择目录的对话框 Tk().withdraw()#隐藏Tkinter根窗口 word_dir=askdirectory(title="选择Word文件所在目录") #获取当前目录 current_dir=os.getcwd() #遍历目录中的Word文件 #word_files=glob.glob(os.path.join(word_dir,"*.docx;*.doc;*.dotx")) word_files=[] forfileinos.listdir(word_dir): iffile.endswith(".docx")orfile.endswith(".doc")orfile.endswith(".dotx"): word_files.append(os.path.join(word_dir,file)) #将Word文件转换为PDF并保存到当前目录 pdf_files=[] #创建Word应用程序对象 word_app=DispatchEx("Word.Application") forword_fileinword_files: print('{}查找到') pdf_file=os.path.join(word_dir,os.path.splitext(os.path.basename(word_file))[0]+".pdf") doc=word_app.Documents.Open(word_file) doc.SaveAs(pdf_file,FileFormat=17) doc.Close() pdf_files.append(pdf_file) print(f'转换完成：{word_file}') #关闭Word应用程序 word_app.Quit() 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d05a4c3ee5f4510c4e79b5667d91bf77/" rel="bookmark">
			Docker常用命令（自用记录）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 查看日志：
docker logs -f --tail 500 ID 导出日志：
docker logs --since='2023-07-14T00:58:00' --until='2023-07-14T01:00:00' name &gt;&gt; file.log docker logs --since 48m 2ef &gt;&gt; /amberdata/backup/agpor.txt 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18744d35f93133d3fcddc9699f8118a8/" rel="bookmark">
			视频分类之数据集介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一、常见数据集介绍
参考文献
前言 本文介绍的为动作识别视频分类数据集。数据集通常通过以下过程构建：1、结合以前数据集的标签，并根据使用情况添加新的类别，从而定义一个新的运动列表。2、从各种来源获取视频，如YouTube和电影，将视频标题/字幕与动作列表匹配。3、手动提供时间注释以指示动作的开始和结束位置。4、通过删除重复数据和过滤来清洗数据集。
一、常见数据集介绍 数据集
发布年份
数量
大小
视频长度
分类数
HMDB51
2011
7K
2G
5s
51
UCF101
2012
13.3K
6.5G
6s
101
Sports1M
2014
1.1M
5.5m
487
ActivityNet
2015
28K
5-10m
200
YouTube8M
2016
8M
229.6s
3862
Charades
2016
9.8K
30.1s
157
Sth-SthV1
2017
108.5K
2-6s
174
Sth-SthV2
2017
220.8K
2-6s
174
Kinetics400
2017
306K
152.3G
10s
400
Kinetics600
2018
482K
10s
600
Kinetics700
2019
650K
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/18744d35f93133d3fcddc9699f8118a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19c5988e1a4b6105d2abff11aae15e9d/" rel="bookmark">
			PySpark-核心编程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2. PySpark——RDD编程入门 文章目录 2. PySpark——RDD编程入门2.1 程序执行入口SparkContext对象2.2 RDD的创建2.2.1 并行化创建2.2.2 获取RDD分区数2.2.3 读取文件创建 2.3 RDD算子2.4 常用Transformation算子2.4.1 map算子2.4.2 flatMap算子2.4.3 reduceByKey算子2.4.4 WordCount回顾2.4.5 groupBy算子2.4.6 Filter算子2.4.7 distinct算子2.4.8 union算子2.4.9 join算子2.4.10 intersection 算子2.4.11 glom算子2.4.12 groupByKey算子2.4.13 sortBy算子2.4.14 sortByKey2.4.15 综合案例2.4.16 将案例提交到yarn运行 2.5 常用Action算子2.5.1 countByKey算子2.5.2 collect算子2.5.3 reduce算子2.5.4 fold算子2.5.5 first算子2.5.6 take算子2.5.7 top算子2.5.8 count算子2.5.9 takeSample算子2.5.10 takeOrdered2.5.11 foreach算子2.5.12 saveAsTextFile2.5.13 注意点 2.6 分区操作算子2.6.1 mapPartitions算子2.6.2 foreachPartition算子2.6.3 partitionBy算子2.6.4 repartition算子2.6.5 coalesce算子2.6.6 mapValues算子2.6.7 join算子 2.7 面试题2.8 总结 3. RDD的持久化3.1 RDD的数据是过程数据3.2 RDD的缓存3.2.1 缓存3.2.2 缓存特点3.2.3 缓存是如何保存的 3.3 RDD的CheckPoint3.3.1 RDD CheckPoint3.3.2 CheckPoint是如何保存数据的3.3.3 缓存和CheckPoint的对比3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/19c5988e1a4b6105d2abff11aae15e9d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9aa78c48d714e0d82e95d07e927eb6d4/" rel="bookmark">
			阿里10年IT老兵亲码《SpringCloud开发从入门到实战》，带你玩转SpringCloud
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 首先给大家看一张图，不知道图上这些springcloud的技术知识点，大家是否都精通而灵活运用了呢？
如果没有精通灵活运用的话，小编将用此文来带大家一步步来深入学习这些技术知识，接下来将从Spring Boot微框架搭建、Spring Cloud常用组件应用，到微服务案例实战，层层剥茧式分析，全流程讲解Spring Cloud开发应用，实战案例拿来就用，带大家快速上手。
因为本文包含的内容实在是太多了，每个章节都有更加细化的部分，所以小编只能把部分知识点拿出来给大家介绍，需要获取完整版的小伙伴可以直接前往文末自取，希望大家能够理解与喜欢！！
首先，咱们先来看一下目录 其次，是主要内容 本文主要分为21章的内容给大家介绍springcloud开发从入门到实战，大家要特别注意每一章的内容介绍：
第1章什么是微服务；微服务是SOA之后越来越流行的体系结构模式之一。如果您关注行业趋势，就会发现，如今商业机构不再像几年前那样，开发大型应用程序，来管理端到端之间的业务功能，而是选择快速灵活的微服务。微服务有助于打破大型应用程序的界限，并在系统内部构建逻辑上独立的小型系统。
1.1面向服务的架构
1.2微服务
1.3微服务的原则
1.4微服务的优势
1.5 Dubbo与Spring Cloud
第2章微框架Spring Boot；Spring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式，Spring Boot致力于在蓬勃发展的快速应用开发领域(rapid application development)成为领导者。
Spring Boot提供了一个强大的一键式Spring的集成开发环境，能够单独进行一个Spring应用的开发。
2.1 Spring Boot概述
2.2 Spring Boot快速搭建
2.3 Spring Boot REST API
2.4 Spring Boot JUnit
2.5 Spring Boot BasicAuth
第3章从服务注册与发现说起；
3.1 EurekaEureka是Spring Cloud Netflix微服务套件中的一部分，可以与Spring Boot构建的微服务很容易地整合起来。Eureka是一个基于REST的服务，主要在AWS云中使用，包含服务器端和客户端组件。服务器端也被称作服务注册中心，用于提供服务的注册与发现。
3.2 Consul Consul提供多种功能，如服务发现、配置管理、健康检查和键值存储等。我们将开发以下组件来构建分布式Eco系统，其中每个组件以某种方式彼此依赖，但它们非常松散地耦合，当然还有容错。
3.3ZooKeeper Eureka 2.x宣布闭源的消息闹得人心惶惶，ZooKeeper作为Spring Cloud注册中心的替代方案，越来越多的人开始着手。服务提供者向ZooKeeper注册，服务消费者从ZooKeeper中发现服务提供者的相关信息，从而远程调用服务提供方。
第4章服务提供者与服务消费者的关系；
4.1接口就是规范
4.2抽象接
4.3构建项目至Nexus
4.4服务提供者
4.5服务消费者之Ribbon
4.6服务消费者之FeignFeign是从Netflix中分离出来的轻量级项目，能够在类接口上添加注释，成为一个REST API客户端。Spring Cloud对Feign进行了封装，使其支持了Spring MVC标准注解和HttpMessageConverterseFeign可以与Eureka和Ribbon组合使用，以支持负载均衡。
第5章模板引|擎；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9aa78c48d714e0d82e95d07e927eb6d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58afbb5197ccc53a86b455a79e55ee54/" rel="bookmark">
			Flink Table API/SQL 多分支sink
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 在某个场景中，需要从Kafka中获取数据，经过转换处理后，需要同时sink到多个输出源中(kafka、mysql、hologres)等。两次调用execute, 阿里云Flink vvr引擎报错：
public static void main(String[] args) { final StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment(); StreamTableEnvironment tEnv = StreamTableEnvironment.create(env); StreamStatementSet streamStatementSet = tEnv.createStatementSet(); String s = LocalDateTimeUtils.getDateTime(System.currentTimeMillis()); DataStream&lt;String&gt; dataStream = env.fromElements(s, LocalDateTimeUtils.getDateTime(System.currentTimeMillis())); tEnv.executeSql(KAFKA_TABLE_SQL); tEnv.executeSql(KAFKA_TABLE_SQL_1); Table table = tEnv.fromDataStream(dataStream); table.insertInto("kafka_sink").execute(); table.insertInto("kafka_sink_1").execute(); streamStatementSet.execute(); } Caused by: org.apache.flink.util.FlinkRuntimeException: Cannot have more than one execute() or executeAsync() call in a single environment. at org.apache.flink.client.program.StreamContextEnvironment.validateAllowedExecution(StreamContextEnvironment.java:199) ~[flink-dist-1.15-vvr-6.0.7-1-SNAPSHOT.jar:1.15-vvr-6.0.7-1-SNAPSHOT] at org.apache.flink.client.program.StreamContextEnvironment.executeAsync(StreamContextEnvironment.java:187) ~[flink-dist-1.15-vvr-6.0.7-1-SNAPSHOT.jar:1.15-vvr-6.0.7-1-SNAPSHOT] at org.apache.flink.table.planner.delegation.DefaultExecutor.executeAsync(DefaultExecutor.java:110) ~[?:?] at org.apache.flink.table.api.internal.TableEnvironmentImpl.executeInternal(TableEnvironmentImpl.java:877) ~[flink-table-api-java-uber-1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/58afbb5197ccc53a86b455a79e55ee54/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87c0c9f7fb57837d441fd0f6bc041ea0/" rel="bookmark">
			Tesseract Java 识别中文&#43;数字&#43;字母，使用多种语言
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Java基于Tesseract来进行OCR识别时，如果使用chi_sim，对数字则识别不完全。如果使用eng，则对中文识别不正确，那么如何既能识别数字又能识别出中文和字母呢？
Tesseract命令行识别时支持-l参数指定语言，如：-l deu+eng。在使用Java类库时同样也是支持的，代码如下：
File tempFolder = TempDirectory.location(); File trainDataHome = new File(tempFolder, "tessdata"); ITesseract tesseract = new Tesseract(); // 加载语言，使用两种语言 tesseract.setLanguage("eng+chi_sim"); tesseract.setDatapath(trainDataHome.getAbsolutePath()); String content = tesseract.doOCR(new File("D:\\test\\4-0-0.png")); System.out.println(content); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38bf47e82f8b134720dc81c1013d3169/" rel="bookmark">
			让 exoplayer2 支持播放 ftp （ 扩展 exoplayer 支持 ftp 协议 ） 的两种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		exoplayer 是安卓开源播放器组件库，由谷歌开发维护。它提供了一个可高度扩展的音视频播放框架，支持许多媒体格式与高级媒体功能，比如 adaptive streaming，DRM，以及安卓 media session 集成。
但是不支持 ftp ，有两种方式可以扩展 exoplayer 支持 ftp 协议。一种是调用系统隐藏功能，一种是使用 apache/commons-net 网络库。
如何查看exoplayer支持哪些网络协议？ 简单，直接打开源码 com.google.android.exoplayer2.upstream.DefaultDataSource
@Override public long open(DataSpec dataSpec) throws IOException { Assertions.checkState(dataSource == null); // Choose the correct source for the scheme. String scheme = dataSpec.uri.getScheme(); if (Util.isLocalFileUri(dataSpec.uri)) { String uriPath = dataSpec.uri.getPath(); if (uriPath != null &amp;&amp; uriPath.startsWith("/android_asset/")) { dataSource = getAssetDataSource(); } else { dataSource = getFileDataSource(); } } else if (SCHEME_ASSET.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/38bf47e82f8b134720dc81c1013d3169/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17e384ebafa729ac5e89b53afdff90ac/" rel="bookmark">
			EPSG码与常见的我国投影坐标系对应关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		EPSG码与常见的我国投影坐标系对应关系 1.EPSG码简介 EPSG，全称The European Petroleum Survey Group即欧洲石油调查组织。该组织维护了几乎全球各种空间参考系统的数据，并对这些参考系统进行了编码。
查询EPSG码、坐标系名称。
EPSG.io网站是围绕OGP地理信息委员会维护的官方EPSG数据库建立的。该数据库包括来自各种来源和权威机构的非常详细的大地测量参数。EPSG.io简化了对数千个空间参考系统(SRS)、变换和转换、基准面、椭球面、子午线、单位等精确参数的访问。
该网站还可以导出所查询的参考系统的其他格式描述如WKT。例如，可以从https://epsg.io/4534查看WKT格式的CGCS2000 / 3-degree Gauss-Kruger CM 135E坐标系统定义。
此外，网站提供了粗略的坐标拾取功能，由maptiler提供服务。
2.常见投影坐标系的EPSG码与中央经线计算 CGCS2000+高斯克吕格6度带 高斯克吕格投影坐标分为两类，X坐标加500000m的基础上，一类在X坐标前加上带号*1000000，一类不加。例如，
23263541.74 4987192.76
263541.74 4987192.76
投影坐标加带号：
EPSG码参考坐标系名称4491CGCS2000 / Gauss-Kruger zone 134501CGCS2000 / Gauss-Kruger zone 23 投影坐标不加带号：
EPSG码参考坐标系名称4502CGCS2000 / Gauss-Kruger CM 75E4512CGCS2000 / Gauss-Kruger CM 135E EPSG码每增加1，中央经线增加6°；因此X坐标加带号的编码范围为4491-4501
不加带号的编码范围为4502-4512。
中央经线计算方法即，Central Meridian = (code-起始带号)*6+75
CGCS2000+高斯克吕格3度带 由于中国国土的经线范围在75-135之间，因此对我国境内的投影坐标系编号仅涉及该范围。以75E为中央经线的投影带的EPSG码为4513或4534。EPSG码每增加1，中央经线增加3°；
投影坐标加带号：
EPSG码参考坐标系名称4513CGCS2000 / 3-degree Gauss-Kruger zone 254533CGCS2000 / 3-degree Gauss-Kruger zone 45 投影坐标不加带号：
EPSG码参考坐标系名称4534CGCS2000 / 3-degree Gauss-Kruger CM 75E4554CGCS2000 / 3-degree Gauss-Kruger CM 135E 中央经线计算方法即，Central Meridian = (code-起始带号)*3+75
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/17e384ebafa729ac5e89b53afdff90ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e661f4a7631cf0376e34c899528d4619/" rel="bookmark">
			JNI DETECTED ERROR IN APPLICATION: a thread (tid 17192 is making JNI calls without being attached
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JNI新建线程内部调用env-&gt;NewStringUTF方法报错：
A java_vm_ext.cc:577] JNI DETECTED ERROR IN APPLICATION: a thread (tid 23820 is making JNI calls without being attached java_vm_ext.cc:577] in call to NewStringUTF A runtime.cc:655] Runtime aborting... runtime.cc:655] Dumping all threads without mutator lock held runtime.cc:655] All threads: runtime.cc:655] DALVIK THREADS (19): runtime.cc:655] "Thread-2" prio=10 tid=19 Runnable runtime.cc:655] | group="" sCount=0 dsCount=0 flags=0 obj=0x13280000 self=0xb400007c7732b760 runtime.cc:655] | sysTid=23820 nice=-10 cgrp=default sched=0/0 handle=0x7a9f749cc0 runtime.cc:655] | state=R schedstat=( 10509322 824844 4 ) utm=0 stm=0 core=2 HZ=100 runtime.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e661f4a7631cf0376e34c899528d4619/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c5e5d96bb89c5d244d010201304cf45/" rel="bookmark">
			Python—微分方程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		结合Python中Scipy，专注创建可以解决问题的方程
目录
一阶常微分方程
二阶常微分方程
三阶常系数微分方程组
修正贝塞尔微分方程
伯努利方程
一阶常微分方程 加速度、速度、时间 计算物体速度的时候，若加速度不断变化，如何确定速度和时间的关系？假设加速度随速度和时间变化的关系是：
即：
我们利用Scipy求解该方程：
import numpy as np import matplotlib.pyplot as plt from scipy.integrate import odeint # v是速度，t是时间 def dvdt(v, t): return v + 6*t v0 = 0 t = np.linspace(0, 2, 100) # 结果res是 N行1列的二维数组（因为是一元方程） res = odeint(dvdt, v0, t) # 转置之后第一行就是各个时间点的速度 res_v = res.T[0] # 绘制速度和时间的关系 plt.plot(t, res_v) plt.show() 由下图结果易得加速度随时间逐渐增大。
图1
二阶常微分方程 且
，，
# 二阶ODE的求解 import matplotlib.pyplot as plt import numpy as np from scipy.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c5e5d96bb89c5d244d010201304cf45/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfd1e84db51bceb3870ffa1c61db29f2/" rel="bookmark">
			七、MATLAB入门—图形绘制（1）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录
前言
一、二维数据曲线图
1.1、单条二维曲线绘制
1.2、多条二维曲线绘制
1.3、设置曲线样式
1.4、图形标注与坐标控制
1.5、自适应采样绘图
1.6、图形窗口的分割
二、其他二维图形绘制 总结
前言 在经过前面这段时间的学习之后，已经能够熟练运用MATLAB进行程序设计和数值计算了，但数值计算终归是一个个离散的数据，不论它有多么的完善，多么的准确，我们还是难以直接从大量的数据中感受它们的具体含义和内在规律。人们更喜欢通过图形直观感受科学计算结果的全局意义和许多内在本质，这就不得不用到MATLAB的另一个功能了，强大的图形绘制能力。
MATLAB具有强大的图形表达功能，既可以绘制二维图形，又可以绘制三维图形，还可以通过标注、视点、颜色、光照等操作对图形进行修饰。MATLAB有两类绘图命令，一类是直接对图形句柄进行操作的底层绘图命令，另一类是在底层命令上建立起来的高层绘图命令。我们主要学习高层绘图命令，高层绘图命令简单明了、方便高效。
一、二维数据曲线图 二维数据曲线图是将平面坐标上的数据点连接起来的平面图形。可以采用不同的坐标系，除直角坐标系外，还可以采用对数坐标、极坐标等。数据点可以用向量或矩阵形式给出，类型可以是实数类型或者复数类型。
1.1、单条二维曲线绘制 在MATLAB中，绘制直角坐标系下的二维曲线可以利用plot函数，该函数应用较为广泛。
plot函数的调用格式为：
plot(x,y)
其中x和y为长度相同的向量，分别用于存储x坐标和y坐标数据。plot函数用于绘制分别以x为横坐标和y为纵坐标的二维曲线，y(i)是x(i)点的函数值。
1.2、多条二维曲线绘制 1、plot函数的输入参数是矩阵形式：
当plot函数的输入参数是向量时，绘制单根曲线，这是最基本的用法。但在实际应用中，plot函数的输入参数可以是矩阵形式，这时将在同一坐标系中以不同颜色绘制多根曲线。
① 当x是向量，y是由一维与x同维的矩阵时，则绘制出多根不同颜色的曲线，曲线条数等于y矩阵的另一维数，x被作为这些曲线共同的横坐标。
② 当x,y是同维矩阵时，则以x,y对应列元素为横、纵坐标分别绘制曲线，曲线条数等于矩阵的列数。
③ 对只包含一个输入参数的plot函数，当输入参数是实矩阵时，则按列绘制每列元素值相对其下标的曲线，曲线条数等于输入参数矩阵的列数。
2、含多个输入参数的plot函数
plot函数可以包含若干组向量对，每一个向量对可以绘制出一条曲线。
含多个输入参数的plot函数调用格式为：
plot(x1,y1,x2,y2,x3,y3,......xn,yn)
① 当输入参数都为向量时，x1和y1，x2和y2分别组成一组向量对，每一组向量对的长度可以不同，每一组向量对可以绘制出一条曲线，这样就可以在同一坐标系中绘制多条曲线了。
② 当输入参数有矩阵时，配对的x,y按对应列元素为横、宗坐标分别绘制曲线，曲线条数等于矩阵的列数。
3、图形保持
一般情况下，MATLAB绘图命令每执行一次就刷新当前图形窗口，图形窗口原来的图形就不存在了，若希望在已经存在的图形上再继续添加新的图形，可以使用图形保持命令hold。hold on命令是保持原有图形，hold off是刷新原有图形。
1.3、设置曲线样式 当我们在MATLAB中绘制多条曲线时，为了更好地区分曲线，曲线的颜色和类型是一个很好的方法。MATLAB提供了一些绘图选项，分别用于曲线的颜色以及曲线样式，如下表所示：
① 曲线线型选项：
符号
线型
符号
线型
-
实线（默认）
-.
点划线
:
虚线
--
双划线
② 曲线颜色选项：
符号
颜色
符号
颜色
b (blue)
蓝色
m (magenta)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cfd1e84db51bceb3870ffa1c61db29f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/392b650eefcfdc4b9cf726a077e9d38c/" rel="bookmark">
			计算机毕业设计springboot学生信息管理系统064p99[附源码]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本项目包含程序+源码+数据库+LW+调试部署环境，文末可获取一份本项目的java源码和数据库参考。
系统的选题背景和意义 选题背景： 随着信息技术的快速发展和计算机应用的广泛普及，学生信息管理系统在高校和教育机构中扮演着至关重要的角色。传统的手工管理方式已经无法满足大规模学生信息的处理和管理需求，而且容易出现数据冗余、信息不准确等问题。因此，开发一套高效、可靠的学生信息管理系统势在必行。
选题意义： 本次毕业设计旨在基于Spring Boot框架开发一个学生信息管理系统，通过利用现代化的计算机技术和互联网思维，实现对学生信息的全面管理和优化。该系统将提供学生信息录入、查询、修改、删除等功能，并结合数据分析和报表生成，为学校和教师提供更好的决策依据。
首先，该系统可以提高学生信息管理的效率和准确性。传统的手工管理方式需要大量的人力和时间，容易出现信息录入错误和数据冗余的情况。而通过使用学生信息管理系统，可以实现自动化的信息录入和更新，大大减少了人为错误的发生，并提高了数据的准确性和一致性。
其次，该系统能够提供更好的信息共享和沟通平台。学生信息管理系统可以实现教师、学生和家长之间的信息共享和沟通，方便及时地传递学生的学习成绩、考勤情况、课程安排等重要信息。这不仅提高了学校与家长之间的互动和合作，也为学生提供了更好的学习环境和支持。
此外，该系统还能够为学校提供数据分析和决策支持。通过对学生信息的统计和分析，学校可以了解学生的整体情况和发展趋势，为学校的管理和教育工作提供科学依据。同时，系统还可以生成各类报表和统计图表，直观地展示学生的学习成绩、班级排名等信息，帮助学校进行全面评估和改进。
综上所述，开发一个基于Spring Boot的学生信息管理系统具有重要的背景和意义。它将提高学生信息管理的效率和准确性，促进学校与家长之间的沟通和合作，为学校的管理和决策提供科学依据。
以上选题背景和意义内容是根据本选题撰写，非本作品实际的选题背景、意义或功能。各位童鞋可参考用于写开题选题和意义内容切勿直接引用。本作品的实际功能和技术以下列内容为准。
技术栈： 前端Vue：用于构建交互式用户界面。
后端Java开发语言：使用Java作为后端开发语言。
Spring Boot框架：作为快速开发框架，替代了SSM框架，提供自动配置、快速构建等功能。
MySQL 5.7数据库：用于数据存储和管理。
使用Spring Boot，你可以通过依赖管理和自动配置来减少手动配置工作，并使用Spring框架的各种功能，如依赖注入、面向切面编程等。同时，Spring Boot还提供了用于构建RESTful API、集成测试和部署的工具和插件，使得开发过程更加高效和便捷。
系统流程图 流程图就是用它已经特定的图形符号以及相应的线条，用来展现出系统在执行中的整个的过程。由于这种图形能够很方便的描绘系统的一系列流程，所以它的所有的图形符号是比较关键的，基本都是一个图形符号就能表示某个过程的一个单独的步骤。流程图不只是提供出比较完整、全面的执行过程，而且在整个团队的协作设计过程中，还可以发现其中有可能存在的缺陷以及不足，便于在后续的过程中能够及时的纠正和完善系统。
登录流程图和添加信息流程图分别如图3-5、图3-6所示。
图3-5 登录流程图
图3-6 添加信息流程图
4 系统设计 4.1系统功能结构设计图 本次系统所涉及到的有关的功能，都是用功能结构图来简洁和清晰的表示出来，功能结构图就是能够把比较复杂的功能结构用图的形式清晰的描绘下来，并且为后续的设计以及测试等模块提供了明确的方向，在构思功能结构图的时候，便可以给设计的过程带来一定的思维导向，不至于在设计过程中有所遗漏，可以尽可能的明确系统所涉及到的功能。
系统的功能结构图如图4-1所示。
图 4-1系统功能结构图
4.2数据库设计 4.2.1数据库设计原则 学习程序设计，如果要了解数据库管理系统或者是根据需求而制定的系统接口，就必须创建一种数据库管理系统的模式，用来保存数据资料，这样当在应用编程过程中时候，就不需要再向操作系统页面上加载信息，进而增加了整个系统的工作效率。信息库管理系统中保存着许多数据，应该说是一个管理信息系统建设的中心和基础，而信息库管理系统也为管理信息系统建设提出了新增、删除、更改和搜索的操作功能，使管理信息系统建设能够迅速地查询所需要的数据，而不会直接从程序代码中查找。信息库管理系统通过将信息表的各个组成部分按照特定的方法准确地合并，排序和组成信息库管理系统。
通过对学生信息管理系统的主要功能信息进行规划并分为若干功能实体信息，实体信息将使用E-R图加以表示，本系统的主要功能实体图如图4-2、图4-3、图4-4，图4-5所示。
图4-2教师信息实体图
图4-3学院信息实体图
图4-4专业信息实体图
图4-5学籍信息实体图
系统详细设计 5.1 前台系统功能的实现 当游客打开系统的网址后，首先看到的就是首页界面。在这里，游客能够看到学生信息管理系统的导航条显示首页、学院信息、专业信息、班级信息、课表信息、课程信息、寻物信息、公告信息、后台管理、个人中心等，系统首页界面如图5-1所示：
图5-1 系统首页界面
当学生进入系统进行相关操作前必须进行登录，学生登录界面如图5-2，所示：
图5-2 学生登录界面
学生点击专业信息，在专业信息页面的搜索栏输入学院名称、专业名称、专业范畴，进行查询，还可以查看学院名称、专业名称、专业图片、专业范畴、专业特色、就业方向等信息，然后进行点我收藏等，如图5-3所示：
图5-3专业信息页面
学生点击班级信息，在班级信息页面的搜索栏输入专业名称、班级名称、班级位置，进行查询，还可以查看专业名称、班级名称、班级图片、班级位置、班主任、联系电话、班级人数等信息，然后进行点我收藏等，如图5-4所示：
图5-4班级信息页面
学生点击学院信息，在学院信息页面的搜索栏输入学院名称、学院类型，进行查询，还可以查看学院名称、学院类型、学院图片、咨询电话、学院邮箱、学院位置等信息，然后进行收藏等，如图5-5所示：
图5-5学院信息页面
在个人中心页面可以更新个人详细信息，还可以对我的收藏进行详细操作，如图5-6所示：
图5-6个人中心页面
5.2 管理员功能的实现 管理员的登陆界面包括管理员的账号、密码，其中就是已有的账号，还有需要注册的账号。只要管理员在账号上注册，注册信息就会被录入 MySQL数据库，有一个资料库，只要输入成功，就可以登陆，然后进入主页的管理。管理员登录界面如图5-7所示。
图5-7 管理员登录界面图
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/392b650eefcfdc4b9cf726a077e9d38c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31d393881ac4332348d935b8c547f868/" rel="bookmark">
			计算机毕业设计springboot疫苗预约网站i53489[附源码]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本项目包含程序+源码+数据库+LW+调试部署环境，文末可获取一份本项目的java源码和数据库参考。
系统的选题背景和意义 选题背景： 近年来，全球范围内爆发的突发传染病事件给人们的生活和健康带来了巨大的威胁。疫苗作为预防传染病的重要手段之一，对于保障公众的健康安全至关重要。然而，在疫苗接种过程中，人们常常面临着预约困难、信息不透明等问题，导致疫苗资源的浪费和社会恐慌的产生。因此，建立一个高效、便捷的疫苗预约网站成为当下亟待解决的问题。
选题意义： 本次毕业设计旨在开发一个基于Spring Boot框架的疫苗预约网站，通过整合现有的技术和资源，提供一个方便快捷的平台，实现公众在线预约疫苗接种的功能。具体而言，该网站将提供以下几个方面的服务：
首先，通过网站用户可以方便地查询各类疫苗的相关信息，包括疫苗的适应症、接种时间、副作用等，帮助用户做出明智的选择。
其次，用户可以根据自身需求和条件，进行疫苗的预约。网站将提供一个简洁明了的预约界面，用户可以根据自己的居住地、接种时间等条件进行筛选，并选择合适的疫苗接种点进行预约。
此外，网站还将提供疫苗接种点的实时信息展示功能，包括接种点的位置、工作时间、预约情况等，方便用户了解接种点的具体情况。
最后，为了保障疫苗资源的合理分配和利用，网站将引入一套完善的管理系统，包括疫苗库存管理、接种点排班管理等，确保疫苗的供需平衡和接种服务的高效运行。
通过开发这个疫苗预约网站，可以有效解决传统疫苗预约方式中存在的问题，提高疫苗接种的效率和公众的满意度。同时，该网站也有助于提升社会对疫苗接种的认知和信任度，推动疫苗接种工作的顺利进行，为保障公众的健康安全做出贡献。
以上选题背景和意义内容是根据本选题撰写，非本作品实际的选题背景、意义或功能。各位童鞋可参考用于写开题选题和意义内容切勿直接引用。本作品的实际功能和技术以下列内容为准。
技术栈： 前端Vue：用于构建交互式用户界面。
后端Java开发语言：使用Java作为后端开发语言。
Spring Boot框架：作为快速开发框架，替代了SSM框架，提供自动配置、快速构建等功能。
MySQL 5.7数据库：用于数据存储和管理。
使用Spring Boot，你可以通过依赖管理和自动配置来减少手动配置工作，并使用Spring框架的各种功能，如依赖注入、面向切面编程等。同时，Spring Boot还提供了用于构建RESTful API、集成测试和部署的工具和插件，使得开发过程更加高效和便捷。
网站流程分析 3.4.1 登录流程 每个用户都有专属的密码和账号，在输入合法的账号、密码以及验证之后即可进入网站。登录流程如图3-5所示：
图3-5登录流程图
3.4.2 添加信息流程 网站用户可以添加信息，内容没有问题之后按下确定键就添加成功了。添加信息的流程图如图3-6所示：
图3-6 添加信息流程图
4 网站功能的设计与实现 4.1 总体设计思路 该网站采用了B/S架构，对使用网络没有特别的要求，使用者可以随时访问该网站。该网站运行原理如图4-1所示：
图4-1 网站工作原理图
4.2 网站功能结构设计 完成了设计思路的构想，接下来就是按照实际要求完成所需功能。该网站功能结构图如图4-2所示：
图4-2 网站功能结构图
4.3 数据库设计 4.3.1 数据库E-R图设计 E-R图即实体-联系图，主要作用是提供了解显示数据类型存在的联系的途径，是藐视现实世界的概念模型，其关键要素是实体型、属性、联系。以下是本网站主要的实体属性图，如图4-3、4-4、4-5、4-6、4-7所示。
（1）用户实体属性图
图4-3 用户实体属性图
（2）医院实体属性图
图4-4 医院实体属性图
（3）疫苗预约实体属性图
图4-5 疫苗预约实体属性图
（4）接种记录实体属性图
图4-6 接种记录实体属性图
（5）疫苗资讯实体属性图
图4-7 疫苗资讯实体属性图
网站详细功能的实现 5.1网站功能实现 当人们打开网站的网址后，首先看到的就是首页界面。在这里，人们能够看到疫苗预约网站的导航条和疫苗咨询等。网站首页界面如图5-1所示：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/31d393881ac4332348d935b8c547f868/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dce72261191eab7a234dc507f5e78d9a/" rel="bookmark">
			低功耗蓝牙的发展历史及每个版本的功能点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		低功耗蓝牙（Low Energy Bluetooth，简称BLE）是蓝牙技术的一种变种，专注于提供低功耗的无线通信连接。以下是低功耗蓝牙发展的主要版本及其功能点的概述：
Bluetooth 4.0：2010年发布的第一个低功耗蓝牙版本，引入了低功耗特性。主要功能点包括： 快速连接和断开连接，以减少功耗。
支持长时间待机，延长设备电池寿命。
数据传输速率较低，适用于低带宽应用。
支持广播和扫描模式，以便设备之间进行快速发现和连接。
Bluetooth 4.1：2013年发布，对4.0版本进行了一些增强和改进。主要功能点包括： 提供更稳定的连接，支持多个从设备与一个主设备的同时连接。
引入更加智能的广播方式，减少无效的广播数据传输。
引入GATT（通用属性配置文件）缓存，提高数据传输效率。
Bluetooth 4.2：2014年发布，进一步改进了低功耗蓝牙的性能和功能。主要功能点包括： 提供更快的连接速度和更低的延迟。
引入安全增强功能，包括支持AES-CCM加密算法和随机数生成器。
引入Internet协议支持，实现了IPv6/6LoWPAN的互操作性。
Bluetooth 5.0：2016年发布，是低功耗蓝牙的一次重大升级。主要功能点包括： 提供更远的通信距离和更高的传输速率。
支持广播扩展，提供更好的室内定位和位置服务。
引入Mesh网络支持，实现了多设备之间的互联互通。
Bluetooth 5.1：2019年发布，对5.0版本进行了一些改进和增强。主要功能点包括： 引入方向性广播，可用于室内导航和位置服务。
提供更准确的距离测量，支持设备之间的定位和距离感知。
引入LE Coded PHY，提供更长的通信距离和更强的抗干扰能力。
这些是低功耗蓝牙发展历史中的一些关键版本和功能点，每个版本都在提高低功耗性能、增加功能和改进用户体验方面做出了贡献。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af3d9a34eaa61770fb60b0f6f572ea54/" rel="bookmark">
			待总结博客文章
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		springboo安全相关:
什么是JWT？(细致讲解)
SpringBoot集成JWT实现token验证
SpringBoot+JWT实现登陆token验证并存储用户信息
SpringBoot 实现 JWT token 自动续期
SpringBoot整合Oauth2实现每次访问后accessToken的有效时间延期，实现类似于Session的功能
用户登录优化-拦截器-handlerInterceptor详解
Spring Security OAuth2是如何校验token的
SpringBoot之SpringSecurity（安全）
SpringBoot SpringSecurity(一)
spring boot实时监听:FileAlterationListenerAdaptor
SpringBoot实现实时监听文件变化
Spring Boot 监听文件、文件夹
spring 必须知道的知识：
云深i不知处博客
【SpringBoot-3】切面AOP实现权限校验：实例演示与注解全解
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c787c39fe7d44edb348ff69fc336f25/" rel="bookmark">
			讯飞星火V2.0：全面功能介绍和详细使用教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		去年年底以来，以认知大模型为代表的通用人工智能，在全球掀起了全新热潮，风起云涌，高潮迭起。无论是OpenAI，还是微软、谷歌、Facebook都在不断加码，让通用人工智能应用日益深入地进入到每个人的工作、办公和生活之中。最近，苹果、奔驰等越来越多的厂商也都宣布，全力拥抱这一轮通用人工智能。
国内同样如此，大模型也得到了快速的发展，各种大型语言模型在不同领域展现出了巨大的潜力，诸如讯飞星火、百度文心一言、阿里通义千问、华为的盘古等。而在目前的市场中，讯飞星火V2.0无疑是国内做得最好的大型语言模型之一。它以其出色的模型能力和优秀的生态体验，为用户提供了全面而灵活的功能。
接下来，让我们一起来了解下讯飞星火V2.0的各方面功能和相关插件的使用。 讯飞星火快速注册体验链接：讯飞星火认知大模型-AI大语言模型-星火大模型-科大讯飞
目录
一、前言
二、讯飞星火APP
三、星火语伴
四、星火助手
五、多模态能力
5.1 图像描述和图像理解
5.2 图像推理
5.3 文图生成
5.4 虚拟人合成
5.5 讯飞智作2.0
六、星火智能插件
6.1 PPT生成
6.2 简历生成
6.3 文档问答
七、代码插件iFlyCode
7.1 代码生成
7.2 代码补齐
7.3 代码解释
7.4 代码纠错
7.5 单元测试
7.6 知识问答
八、讯飞星火API申请使用
一、前言 8月15日，讯飞星火认知大模型V2.0如期而至。
5月6日，讯飞星火V1.0“破土而出”：正式发布讯飞星火认知大模型，教育、办公、汽车、数字员工等四大行业应用同步展现；
6月9日，讯飞星火V1.5展示了超强“成长力”：持续提升通用能力，突破开放式问答，并在数学能力和多轮对话能力上迭代升级，面向教育、医疗、工业、办公等领域的应用全面升级；
8月15日，讯飞星火V2.0升级并加快应用步伐：发布代码和多模态能力，同时发布搭载讯飞星火V2.0的多项应用和产品；与华为强强联合，发布企业私有专属大模型解决方案——星火一体机，合作共建全国产化算力底座。
大模型赋能个体和行业的大未来正在到来。
“关于未来，无论你觉得行还是不行，你终将是对的！”科大讯飞董事长刘庆峰在演讲中分享。
如果你觉得行，将全力以赴、不遗余力、充满激情、充满斗志地去争取，最终的结果一定是“行”；如果你觉得不行，将怀疑、懈怠，那最终的结果也一定是“不行”。
通用人工智能曙光之下，科大讯飞之所以能够抢抓大模型机遇，讯飞星火之所以能够如约而至，源自20多年的技术积累和行业应用，成建制的团队和极强的作战能力，以及优秀的合作伙伴。
将来，每个人的生活和工作都可以站在人工智能的肩膀上，不是憧憬，而是发展的必然。讯飞星火赋能千行百业，科大讯飞正奔跑在“用人工智能建设美好世界”的道路上。
讯飞星火认知大模型V2.0 升级发布会，让我们再次看见：解放生产力、释放想象力，不是风口上的狂想，而是实实在在的落地。
二、讯飞星火APP 讯飞星火APP——让海量知识与创意触手可得
讯飞星火APP，由科大讯飞推出的一款功能全面、免费且极具实用性的APP，其具有7大核心能力，包括：文本生成、知识问答、逻辑推理、语义理解、数学能力、代码能力以及多模态能力。同时还推出讯飞星火小助手，使得各种各样通用人工智能应用可以更深入对应场景，让用户非常简单地通过结构化模板定义喜欢使用的小助手，当然也可以分享出去。两个多月，新增了7800个用户创造的小助手。
除此之外，讯飞星火V2.0与网页端数据打通，极大地丰富了用户的使用体验。无论是在电脑上浏览网页还是在手机上使用APP，用户都可以享受到同样便捷的服务。
讯飞星火V2.0作为一款功能全面的APP，通过海量知识与创意的呈现，满足了用户对于快速获取信息和灵感的需求。通过与网页端数据的打通以及方便易用的操作方式，讯飞星火V2.0为用户提供了无处不在的智慧助手。不管是在学习、工作还是日常生活中，讯飞星火V2.0都将成为您不可或缺的伙伴。
墙裂安利推荐 手机端下载讯飞星火APP，生活中的各种事情进行提问，都可快速得到不错的答案，同时也可以给工作和生活赋能，极大提高效率。
扫码进行下载：
三、星火语伴 星火语伴，大家只要扫码就可以直接免费来使用。它不仅仅是针对大学生，针对有出国交流需求的人，是学英语的好伙伴。把后台的交互内容一变，它就是企业的面试官、数字虚拟员工、优秀的导购员、24小时营业厅的服务人员等等，它们的后台逻辑完全一致。今天星火在语音识别、语音合成的场景领域，可以极大提升现在的劳动生产效率。
扫码下载地址，适合学习英语及英语口语的学生用户，实时对话，练习口语，大学生及口语爱好者的福音：
四、星火助手 星火助手——你的智能办公生活助手 让工作生活更简单高效
6月9日发布讯飞星火V1.5时，我们推出了讯飞星火小助手，使得各种各样通用人工智能应用可以更深入对应场景，让用户非常简单地通过结构化模板定义喜欢使用的小助手，当然也可以分享出去。现在两个多月过去，新增了7800个用户创造的小助手。
目前，讯飞星火小助手共划分15个大类，覆盖面广泛；7800+助手指令，指令丰富，使用简单；且能够支持自定义指令，个性化程度高。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c787c39fe7d44edb348ff69fc336f25/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4669a066aacbb7836d598b1324626cb/" rel="bookmark">
			Pytorch多GPU和Sync BatchNorm代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于复现spade的过程中遇到了一些GPU的问题，所以决定好好理解一下DPL
代码问题 终端显示暂行不动，并没有报错。GPU没有加载进程，同时CPU也没有动。
考虑可能是DPL的问题。由于代码中使用了Sync BatchNorm，考虑到可能是DPL的问题。
nn.DataParallel 在forward阶段，当前GPU上的module会被复制到其他GPU上，输入数据则会被切分，分别传到不同的GPU上进行计算；在backward阶段，每个GPU上的梯度会被求和并传回当前GPU上，并更新参数。也就是复制module -&gt; forward -&gt; 计算loss -&gt; backward -&gt; 汇总gradients -&gt; 更新参数 -&gt; 复制module -&gt; …的不断重复执行，示意图如下：
因为数据会被均分到不同的GPU上，所以要求batch_size大于GPU的数量。下面对DataParallel的forward函数做一个简单的解释：
class DataParallel(Module): def __init__(self, module, device_ids=None, output_device=None, dim=0): super(DataParallel, self).__init__() if not torch.cuda.is_available(): self.module = module self.device_ids = [] return if device_ids is None: device_ids = list(range(torch.cuda.device_count())) if output_device is None: output_device = device_ids[0] self.dim = dim self.module = module # 待并行计算的模型 self.device_ids = list(map(lambda x: _get_device_index(x, True),device_ids)) self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a4669a066aacbb7836d598b1324626cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f97f1a3da1e7af7082d8ea26607f0007/" rel="bookmark">
			Mybatis之执行插入语句后返回主键id的三种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在工程应用中，通常会遇到多表更新操作，在集成mybatis中需要在执行插入语句后返回主键id进行后续的表更新操作，下面对其实现的方式记录分享出来，以应对不同的应用场景。
1、在xml文件中应用useGeneratedKeys和keyProperty 在xml文件中，insert标签属性中，添加useGeneratedKeys和keyProperty，类似如下：
&lt;insert id="insert" parameterType="com.***.Attachment" useGeneratedKeys="true" keyProperty="attachment.id" keyColumn="id"&gt; insert into b_attachment &lt;trim prefix="(" suffix=")" suffixOverrides=","&gt; &lt;if test="attachment.id != -1"&gt; id, &lt;/if&gt; &lt;if test="attachment.fileName != null and attachment.fileName !=''"&gt; file_name, &lt;/if&gt; &lt;if test="attachment.remarks != null and attachment.remarks !=''"&gt; remarks, &lt;/if&gt; &lt;/trim&gt; &lt;trim prefix="values (" suffix=")" suffixOverrides=","&gt; &lt;if test="attachment.id != -1"&gt; #{attachment.id,jdbcType=BIGINT}, &lt;/if&gt; &lt;if test="attachment.fileName != null and attachment.fileName !=''"&gt; #{attachment.fileName,jdbcType=VARCHAR}, &lt;/if&gt; &lt;if test="attachment.remarks != null and attachment.remarks !=''"&gt; #{attachment.remarks,jdbcType=VARCHAR}, &lt;/if&gt; &lt;/trim&gt; &lt;/insert&gt; 通过这种方式插入的值，经常会返回1，原因是因为他这里的意思是返回当前影响的行数，不能准确返回你新插入的id值，有时候返回的结果是准确的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f97f1a3da1e7af7082d8ea26607f0007/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90c86f3b8b704fcd8acc403acd630e8e/" rel="bookmark">
			FCN论文详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		FCN
论文：《Fully Convolutional Networks for Semantic Segmentation》
提交日期：2014年11月
论文链接：https://arxiv.org/abs/1411.4038
这是我个人的学习笔记，很多地方也不完善，原博客地址：https://blog.csdn.net/weixin_44936889/article/details/103655805
该网络可以接受任意大小的输入，并通过有效的推理和学习产生相应大小的输出。 其大致可分为三部分：前馈神经网络、反卷积和skip结构改善的上采样。
1.关于输入
该网络可以接受任意大小的输入，并通过有效的推理和学习产生相应大小的输出。主要是通过将全连接层替换为卷积层。
2.前馈神经网络：
①VGG正常卷积部分
特征层的提取用的一般是VGG或者其他的图像识别网络，作用是提取出不同大小的特征层，供给upsample上采样层使用；
作者在这里也对比了使用不同的前馈神经网络的效果，可以看到VGG是效果比较好的，最后也是采用了VGG16：
这里的话我们去掉了VGG最后面的全连接层，将三层全连接换成卷积层，只留下了这部分：
如果输入图片大小是224×224×3的话，我们得到的最后一个特征层大小就是7×7×512。
②全连接变卷积部分
将全连接层变为卷积层使得能在更大的图片上滑动，从而不再限制输入图片的大小。具体介绍请看全连接与卷积变换关系
2.反卷积层：
反卷积层的作用是，将一个小的特征图（如7×7×512）大小，映射为大的特征图（如映射为原图上，每个像素点的类别向量，224×224×21）；21代表20分类+背景分类。
反卷积的原理是，先将原特征图的特征点之间进行填充，然后使用卷积核在原特征图上滑动，就得到了一个更大的特征图。
如图，正常的卷积层是这样的：
反卷积顾名思义，就是将这个卷积过程反过来，如图：
这是一个步长为1、卷积核大小为2的反卷积层，通过特征图边缘的padding，我们成功地从一个2×2大小的特征图，得到了一个4×4大小的新特征图；
我们再来看一个步长为2的反卷积层，需要注意的是，这里的步长（stride）不再代表卷积核滑动的距离，而是代表了特征图上每个特征点相邻两点之间的距离：
这里步长为2，就是在特征图每个特征点之间再填充一行（或一列），然后再进行卷积操作。
这样的话我们就能够通过反卷积，将前馈神经网络得到的7×7×512大小的特征层，映射回原图大小，并得到每个像素点的分类向量了（224×224×21）。
3.上采样：
上采样的过程与残差神经网络ResNet的残差单元有点类似：
也是通过与前面的特征层求和来得到新的特征层。
上采样是通过将反卷积得到的大的特征图，与前面相同大小的特征图（通常取pooling层）求和：
论文中写的可能并不是那么清楚，我们就简单分析一下：
我们使用VGG-16，得到了一个7×7×512大小的特征层，然后我们使用一个stride为2的反卷积层，得到了一个14×14×21的反卷积层；我们再取pool4（14×14×512大小，通过1×1卷积核大小的卷积层转换为14×14×21大小），再与得到的反卷积特征图相加，就实现了我们的一个上采样单元，在原图里的表示就像这样：
通过多个反卷积层和上采样单元，我们最终就得到了原图大小的分类预测向量（大小为224×224×21）；
主要贡献：
1.将端到端的卷积网络推广到语义分割中；
2.重新将预训练好的Imagenet网络用于分割问题中；
3.使用反卷积层进行上采样；
4.提出了跳跃连接来改善上采样的粗糙程度。
具体解释：
本文的关键在于：
1.分类网络中的全连接层可以看作是使用卷积核遍历整个输入区域的卷积操作。
2.这相当于在重叠的输入图像块上评估原始的分类网络，但是与先前相比计算效率更高，因为在图像块重叠区域，共享计算结果。
3.尽管这种方法并不是这篇文章中所特有的，还有一篇关于overfeat的文章也使用了这种思想，但是确实显著提高了在VOC2012数据集上的实际效果。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46ace7b2723913c0d0b4f5ccf7039f87/" rel="bookmark">
			【附安装包】Xmind 2023最新安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 软件下载
软件：Xmind
版本：2023
语言：简体中文
大小：136.72M
安装环境：Win7及以上版本 ，64位操作系统硬件要求：CPU@2.0GHz ，内存@4G（或更高）下载通道①百度网盘丨64位下载链接：
https://pan.baidu.com/s/1bl1KgDbhAAlX3YAfEvrT4A?pwd=6789
提取码：6789
下载通道②迅鸟快传丨64位下载链接：
https://xntransfer.com/#/home?s=xaZYvxlY
软件介绍
XMind 是一款非常实用的思维导图软件，应用全球最先进的Eclipse RCP 软件架构，全力打造易用、高效的可视化思维软件，强调软件的可扩展、跨平台、稳定性和性能，致力于使用先进的软件技术帮助。
安装步骤
1.鼠标右击【XMind2023(64bit)】压缩包（win11及以上系统需先点击“显示更多选项”）【解压到 XMind2023(64bit)】。
2.打开解压后的文件夹，鼠标右击【Setup】选择【以管理员身份运行】。
3.安装中……
4.点击【继续】。
5.取消勾选【自动发送程序日志……】，点击【同意】。
6.点击【跳过】。
7.点击右上角【X】退出。
8.打开安装包解压后的【XMind2023(64bit)】文件夹，鼠标右击【winmm.dll】选择【复制】。
9.鼠标右击桌面【Xmind】图标选择【打开文件所在的位置】。
10.鼠标右击空白处选择【粘贴】。
11.双击桌面【Xmind】图标启动软件。
12.点击【取消】。
13.点击【确定】（首次启动软件会自动退出）。
14.双击桌面【Xmind】图标重新启动软件。
15.点击【新建】。
16.点击【跳过】。
17.点击左上角【三】，点击【首选项】。
18.在自动更新处选择【关闭自动更新】，点击【应用】。
19.安装成功！
---------------------------END--------------------------- 题外话 “不是只有程序员才要学编程？！”
认真查了一下招聘网站，发现它其实早已变成一项全民的基本技能了。
连国企都纷纷要求大家学Python!
世界飞速发展，互联网、大数据冲击着一切，各行各业对数据分析能力的要求越来越高，这便是工资差距的原因，学习编程顺应了时代的潮流。
在这个大数据时代，从来没有哪一种语言可以像Python一样，在自动化办公、爬虫、数据分析等领域都有众多应用。
更没有哪一种语言，语法如此简洁易读，消除了普通人对于“编程”这一行为的恐惧，从小学生到老奶奶都可以学会。
《2020年职场学习趋势报告》显示，在2020年最受欢迎的技能排行榜，Python排在第一。
它的角色类似于现在Office，成了进入职场的第一项必备技能。
如果你也想增强自己的竞争力，分一笔时代的红利，我的建议是，少加点班，把时间腾出来，去学一学Python。
因为，被誉为“未来十年的职场红利”的Python，赚钱、省钱、找工作、升职加薪简直无所不能！
目前，Python人才需求增速高达**174%，人才缺口高达50万，**部分领域如人工智能、大数据开发， 年薪30万都招不到人！
感兴趣的小伙伴，赠送全套Python学习资料，包含面试题、简历资料等具体看下方。
👉CSDN大礼包🎁：全网最全《Python学习资料》免费赠送🆓！（安全链接，放心点击）
一、Python所有方向的学习路线
Python所有方向的技术点做的整理，形成各个领域的知识点汇总，它的用处就在于，你可以按照下面的知识点去找对应的学习资源，保证自己学得较为全面。
二、Python必备开发工具
工具都帮大家整理好了，安装就可直接上手！
三、最新Python学习笔记
当我学到一定基础，有自己的理解能力的时候，会去阅读一些前辈整理的书籍或者手写的笔记资料，这些笔记详细记载了他们对一些技术点的理解，这些理解是比较独到，可以学到不一样的思路。
四、Python视频合集
观看全面零基础学习视频，看视频学习是最快捷也是最有效果的方式，跟着视频中老师的思路，从基础到深入，还是很容易入门的。
五、实战案例
纸上得来终觉浅，要学会跟着视频一起敲，要动手实操，才能将自己的所学运用到实际当中去，这时候可以搞点实战案例来学习。
六、面试宝典
简历模板 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7caafe46ca28ce9adb1345563916e1f2/" rel="bookmark">
			mybatis级联查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是mybatis级联查询 MyBatis级联查询是指在查询操作中，通过一次查询关联的多个表格，并将结果映射到一个复杂的对象中。通常情况下，关联查询需要多次查询数据库并手动组装结果，而级联查询则通过MyBatis的特性来自动完成这个过程。
在MyBatis中，级联查询可以通过嵌套查询语句或使用关联映射来实现。嵌套查询语句是指在一个查询语句中嵌套另一个查询语句，通过在查询结果中引用另一个查询来实现级联查询。关联映射是指通过配置文件中的关联映射标签来定义对象之间的关联关系，然后在查询操作中通过关联映射来实现级联查询。
一对一级联查询 创建两张表一张为用户表一张为部门表
create table sys_user ( user_id bigint auto_increment primary key, username varchar(50) not null comment '用户名', password varchar(100) null comment '密码', salt varchar(20) null comment '盐', email varchar(100) null comment '邮箱', mobile varchar(100) null comment '手机号', status tinyint null comment '状态 0：禁用 1：正常', dept_id bigint null comment '部门ID', create_time datetime null comment '创建时间', constraint username unique (username) ) comment '系统用户' charset = utf8mb4; create table sys_dept ( dept_id bigint auto_increment primary key, parent_id bigint null comment '上级部门ID，一级部门为0', name varchar(50) null comment '部门名称', order_num int null comment '排序', del_flag tinyint default 0 null comment '是否删除 -1：已删除 0：正常' ) comment '部门管理' charset = utf8mb4; 创建两个相对应的实体类
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7caafe46ca28ce9adb1345563916e1f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5a4461115f6ffcdc75a819159338335/" rel="bookmark">
			机器学习分类，损失函数中为什么要用Log，机器学习的应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
损失函数中为什么要用Log
为什么对数可以将乘法转化为加法？
机器学习（Machine Learning）
机器学习的分类
监督学习
无监督学习
强化学习
机器学习的应用
应用举例：猫狗分类
1. 现实问题抽象为数学问题
2. 数据准备
3. 选择模型
4. 模型训练及评估
5.预测结果
推荐阅读
损失函数中为什么要用Log ​Loss 在使用似然函数最大化时，其形式是进行连乘，但是为了便于处理，一般会套上log，这样便可以将连乘转化为求和，求和形式更容易求偏导，应用到梯度下降中求最优解；
由于log函数是单调递增函数，因此不会改变优化结果。
极大似然估计中取对数的原因：取对数后，连乘可以转化为相加，方便求导，这是因为对数函数的求导更加简单，对数函数的导数比原函数更容易计算和优化；除此之外对数函数 ln为单调递增函数，不会改变似然函数极值点。
为什么对数可以将乘法转化为加法？ log2(x*y) = log2(y) + log2(y)
1， 2 ，3 ，4，5， 6······
和指数序列
2^(1)， 2^(2) ，2^(3) ，2^(4)，2^(5)， 2^(6)······
，可以看出上一序列是下一序列的指数部分。那么我们如果想计算2*8 = (2^(1))*(2^(3))就可以将指数部分先加起来，即1+3=4，然后找第二个序列进行对应，就得到了2^(4)=16。这就是对数里的思想啦。
机器学习（Machine Learning） 基本思路是模仿人类学习的过程，例如人们一般通过经验归纳，总结规律，从而预测未来。
机器学习本质上就是让计算机自己在数据中学习规律，并根据所得到的规律对未来数据进行预测。
比如，不需要通过编程来识别猫或狗，机器学习可以通过使用图片来进行训练，从而归纳和识别特定的目标。
机器学习算法包括如聚类、分类、决策树、贝叶斯、神经网络、深度学习（Deep Learning）等。
机器学习的分类 机器学习经过几十年的发展，衍生出了很多种分类方法，这里按学习模式的不同，可分为
监督学习半监督学习无监督学习强化学习。 为了便于理解，用灰色圆点代表没有标签的数据，其他颜色的圆点代表不同的类别有标签数据。监督学习、无监督学习、强化学习的示意图如下所示：
监督学习 监督学习（Supervised Learning）是从有标签的训练数据中学习模型，然后对某个给定的新数据利用模型预测它的标签。如果分类标签精确度越高，则学习模型准确度越高，预测结果越精确。
监督学习主要用于回归和分类问题。
常见的监督学习的回归算法有：线性回归、回归树、K邻近、Adaboost、神经网络等。
常见的监督学习的分类算法有：朴素贝叶斯、决策树、SVM、逻辑回归、K邻近、Adaboost、神经网络等。
无监督学习 无监督学习（Unsupervised Learning）是从未标注数据中寻找隐含结构的过程。其中，
自监督学习(Self-Supervised Learning)方法在最近的学术界和工业界几年备受关注。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5a4461115f6ffcdc75a819159338335/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51b1591b82da61b6e27c3990ac3e2203/" rel="bookmark">
			机器视觉系列（四）——相机部分
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、工业相机和其他数码相机的区别 工业相机和普通数码相机的区别：
①工业相机是工业用品，需要连续长时间运行，所以在性能可靠性、稳定性、环境稳定、防水、连续运行时间上有明显的优势。工业相机不易损坏，连续工作时间长，可在较差的环境下使用，而一般的数码相机是做不到这些的。
②工业相机的快门时间特别短，能够清晰地拍摄快速运动的物体。工业相机的最小快门时间可达十几μs。
③工业相机的拍摄帧率远远高于数码相机，工业相机每秒可以拍摄十到几百张图像，而普通相机只能拍摄两到三张图像。
④工业相机的图像传感器是逐行扫描的，而数码相机是隔行甚至隔三行扫描的，所以工业相机的成像质量更高更真实。
⑤工业相机输出的是裸数据raw data，其光谱响应频率与人眼不同往往比较宽，成像质量较高，更适合精细化的图像处理要求。而普通相机的图像是经过压缩的，图像质量较差，不适合用于图像处理。
⑥工业相机由于拍摄图像多，图像质量高，所以自然要求要比普通相机具有更高的数据传输速率，也就对数据传输接口和传输协议都有特殊要求。
我们再来比一比工业相机和单反相机的区别：
上面的第①、②、⑥依然存在。此外还有：
①工业相机由于要应用无物理环境受限的工业场景，所以其体积要明显小于单反相机。
②工业相机配套SDK提供的软件功能，由于要满足专业的图像处理算法需要，所以要比用于拍摄生活场景的单反的软件功能更为强大。
二、工业相机的主要性能参数 我们已经知道工业相机主要是用来检验和监控的，所以其主要性能参数就是能更好满足上述应用需求的，其包括：
①芯片类型：彩色还是黑白、面阵还是线阵、CCD还是CMOS
②分辨率：感光芯片上有多少格像元，就是多少分辨率的相机，常用的有30万、130万、200万、500万、1000万、2900万、7100万、1.2亿。
③像元尺寸：像元是感光芯片上接受光信号的装置，每个图上的一个像素都对应像元，像元的物理尺寸就是像元尺寸，常见的有2.2μm、3.45μm、3.75μm、4.8μm、5.5μm、5.86μm、7.4μm。在同一时间单位的光照射到感光芯片上，像元尺寸越大，其能接受的光子数量越多，图像呈现的亮度越高。
④像素格式：由于相机可以是彩色或黑白相机，所以就会有不同的像素格式，如Mono和RGB。再加上彩色相机还会有不同的数据压缩方式，又进一步增加了像素格式的类型，如Bayer和YUV等。
⑤成像位深度：常见的工业相机一般使用8位来表示一个像素，也就是每个像素可以输出0~255共256个色阶。但还有更高级的工业相机，可使用12位或16位来表示一个像素，这样就会有更多的色阶，所拍摄出来图像的细节就更清晰。
⑥噪点：指感光芯片把光信号变成电信号并输出的过程中产生的不属于物体的部分影像。
⑦帧率/行率：面阵相机的帧率是指一秒钟能拍多少张图像，线阵相机的行频是指一秒钟相机能扫描多少行。
⑧曝光时间：感光芯片接收光照射过来的时间，曝光时间设置的越长，图像越亮。但如果运动拍照的话，曝光时间长可能会产生拖影。曝光方式分逐行曝光和帧曝光。
⑨快门方式：快门有全局快门Global Shutter和滚动快门Rolling Shutter两种。
⑩触发方式：一般可设置由相机内置程序自动连续获取图像，或由外部软件或硬件信号对相机进行触发，每发出一次触发信号相机采集一帧图像。而由外部信号触发又可进一步分为获取时触发和帧开始时触发两种。通过触发方式来采集图像，可使相机的采集时间得到更精确的控制。
⑪传输速率：一般有GigE、USB 3、CoaxPress等传输协议，传输速度从几Mbit/s到几Gbit/s都有。
⑫传输信息：除传输相机拍摄图像的裸数据外，还可传输控制命令、相机参数等信息。
其中②和③决定了相机能够拍多大的区域，在该区域能够以多大的密度来提取信息；④、⑤和⑥决定了相机的每个像素能有多大的动态范围；⑦、⑧、⑨和⑩决定了相机能够以多快的速度进行拍摄；⑪和⑫则表明了在相机获取了相关信息后，能以多快的速度，将多详细的信息提供给你使用。
三、面阵相机和线阵相机的区别 ①面阵相机：是同一个曝光时间周期，输出多行数据的采集设备。
②线阵相机：单行或多行进行采集的图像采集器。每次只能输出一行或多行图像数据。线阵系统一般需要编码器和触发器才能完成对一幅图像的采集，编码器输出行频，触发器输出帧频。
其优缺点对比为：
如果你需要获取彩色图像，选择面阵相机；如果机械设计能力不足或现场机械设计受限，选择面阵相机；3D视觉应用，选择面阵相机；其他时候选择线阵相机。
四、CCD和CMOS相机的区别 CCD芯片中像素使用完整的芯片表面以捕捉光线，并且无需在芯片表面上安装任何转换电子元件，这使表面拥有更多的像素空间，可以捕捉更多的光线。但正是由于这个特性，CCD读取数据没有CMOS快。因为势阱中的电子数目不受电压和电流波动的影响，完全电荷转移模式使CCD成为最适合于图像传感器应用的结构，其有极高的信噪比。
CMOS芯片中，将光能转化为电信号的电子元件直接集成在芯片表面，因此电子元件能够快速地读取成像数据。
CMOS相比于CCD的优势：
①性价比高。由于CMOS制造工艺属于通用工艺，而CCD制造属于专用工艺，所以CMOS制造成本更低；
②成像速度快。由于其芯片AD转换直驱技术，再配合CMOS可以实现更灵活的区域信号读取技术，使得CMOS具有更高的成像速度；
③高分辨率。由于CMOS在经济上和适用范围上的优势，使得其获得了更多的研发投入，目前已经开发出比CCD更高的分辨率；
④低功耗。CMOS电路可以工作在比CCD更低的电源电压下。此外，X-Y的寻址方案及片上功能实现都有助于降低系统功耗；
⑤没有漏光smear现象。当长波光照射到硅基上并穿透时，CCD进入饱和区后，电荷存储势阱将填满电子，过剩的电子会向外溢出。溢出的电子将进入相邻像素以及垂直CCD转移通道中。垂直CCD中残留的漏光电荷使得垂直方向转移的正常信号电荷都加上了漏光电荷，导致漏光从上而下均匀出现。这种现象是CCD独有的，称为漏光smear。由于漏光量与电子快门速度无关，电子快门会导致漏光劣化。
CCD相比于CMOS的优势：
①更高的动态范围。与CMOS传感器相比，CCD传感器对光更加敏感，这是因为CCD有更大的填充因子，这就导致CCD在光电转换的精度方面更有优势，从而更适于高清晰成像或位深度大于8的成像应用。
②更高的信噪比。因为势阱中的电子数目不受电压和电流波动的影响，完全电荷转移模式使CCD成为最适合于图像传感器应用的结构，可获得更高的信噪比。因此与CMOS传感器相比，CCD传感器更适合低对比度的场合。
③更小的不均匀性。由于CMOS的每个像素都有放大器，因此有不同的增益和补偿，所以更难获得整体的均匀一致性。
如果需要超高分辨率，选用CMOS；如果需要高清晰度，选用CCD；如果需要对低对比度场景进行成像，选用CCD；其他场合都选用CMOS。
五、全局快门和滚动快门的区别 全局快门Global Shutter和卷帘快门Rolling Shutter是常见的相机曝光方式。全局快门的方式比较简单，光圈打开后，整个图像芯片同时曝光，因此曝光时间与机械的开关速度有关，所以存在理论上的最小曝光时间。卷帘快门是当光圈打开后，还存在具有一定间隔的卷帘来控制传感器的曝光时间，如下图所示，卷帘方式是从左到右的。因此曝光时间的长短完全取决于卷帘的开口大小与卷帘的运动速度。也就是说，卷帘运动越快，卷帘间距越小，其曝光时间越小，因此卷帘快门能够具有更小的曝光时间。
全局快门与卷帘快门的优缺点：
①全局快门的优点是所有的像素点同时曝光，其缺点是曝光时间存在物理极限；
②卷帘快门的优点是具有更小的曝光时间，其缺点是由于是逐行而不是同时曝光取像，如果图像是运动的，则存在明显的拖影，因此不适合拍摄运动的物体。
曝光时间短的应用（如&lt;500μs）适合使用全局快门，而曝光时间长的应用，选择卷帘快门可以有更低的噪声和帧速。在实际应用中，一般只要是拍摄运动物体，都使用全局快门，只有在拍摄静止物体时，才使用滚动快门。CCD和CMOS相机都可配备全局快门。
六、高分辨率带来的问题 像素的灵敏度和满阱容量随像素尺寸线性减小。一方面，小像素的分辨能力具有一定的衍射限制。因为衍射点随着F值的减少而增加，而低的F值会造成光入射到像素上的角度较大从而引起更多的阴影和串扰，因此，可以采取的F值的范围是相当有限的，且需要配合更强的照明和更短的曝光时间使用。另外，随着更小像素所带来的更大景深，还原小像素图像传感器得到的图像往往是泛焦的。而为了补偿由于像素减小而带来的一些畸变，对于透镜系统的设计要求也更为复杂。在减小像素尺寸的同时，为了保持图像的质量，需要弥补此前提到的小像素的负面影响，这将需要后端处理器发挥更大的作用。另外由于芯片面积的增加，导致每片晶圆上图像传感器芯片的数量下降，从而图像传感器的成本较高。每片晶圆上良好成像芯片的产量也可能受到影响，从另一方面也提高了传感器的成本。
所以在实际选用时，在成像分辨率满足要求的条件下，尽可能选择低分辨率、大像元尺寸的相机。
七、工业相机的软件操作 由于我接触过的所有工业相机中，Basler提供的软件操作功能是最丰富的，这里使用Basler的acA1300-30gc + pylon Viewer 6.3.0来进行说明。
软件的整体菜单包括4部分：
①相机参数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/51b1591b82da61b6e27c3990ac3e2203/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a500a49d4d6d8c1ac371715f86a5bd6/" rel="bookmark">
			API接口常用数据格式Json，Json的定义和XML的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现在程序员还有谁不知道 JSON 吗？无论对于前端还是后端，JSON 都是一种常见的数据格式。那么 JSON 到底是什么呢？
JSON 的定义 JSON （JavaScript Object Notation） ，是一种轻量级的数据交换格式。它的使用范围很广，并成为 ECMA 标准，可以被使用在多种编程语言中，用于前后端之间的数据传输、存储和交换数据。可以说是“用更少的编码，有更快的处理速度”，所以深受广大程序员的喜爱。
JSON 格式的数据是由键值对组成的，其中键值对之间使用逗号分隔。在 JSON 中，键和值都必须使用双引号引起来。
一个简单的 JSON 对象例子：
{ "name": "Apifox", "age": 2, "city": "Guangzhou" } JSON 的含义和类型 JSON 用于 JavaScript，把任何 JavaScript 对象变成 JSON，即把这个对象序列化成一个 JSON 格式的字符串，然后通过网络传递给其他计算机。JSON 格式的字符串由双引号 “ ” 包裹，由键值对组成，键和值之间使用冒号 : 分隔，键值对之间使用逗号 , 分隔。值可以是字符串、数字、布尔、null、数组或对象等类型。
在 JSON 中，常见的数据类型有：
字符串：JavaScript 中的string，用于表示文本信息，包含反斜杠 \ 转义。 { "name": "Apifox" } 数字：JavaScript 中的number，用于表示数值信息，可以是整数或浮点数。 { "id": 48, "price": 17.95 } 布尔值：JavaScript 中的boolean，用于表示真假信息。布尔值并不包含在引号内，而是被视为字符串值。 { "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a500a49d4d6d8c1ac371715f86a5bd6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb6dc5202501c33cf937ae5678483eeb/" rel="bookmark">
			Python实现基于人脸识别的上课考勤系统，可作为毕业设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、简介 源码下载地址https://download.csdn.net/download/2302_77835532/88237252
这个人脸识别考勤签到系统是基于大佬的人脸识别陌生人报警系统二次开发的。
项目使用Python实现，基于OpenCV框架进行人脸识别和摄像头硬件调用，同时也用OpenCV工具包处理图片。交互界面使用pyqt5实现。
该系统实现了从学生信息输入、人脸数据录入、人脸数据训练，学生信息多条件搜索、修改，多选删除，人脸数据训练，人脸识别、追踪、签到等完整流程的各项功能。甚至允许生成签到表格和导出Excel格式签到表。
根据功能分配，系统分为三个部分实现各部分流程，
录入端负责数据导入，管理端负责数据删改查以及人脸数据训练，监控端负责人脸识别以及签到功能。 二、效果图 监控端使用界面如图所示： 管理端使用界面如图所示： 录入端使用界面如图所示： 三、开发过程 本系统在原始项目的框架基础上做了大量修改，针对系统功能的不同以及部分模块实现的不完整做了补充和优化。原项目在功能上实现了完整的人脸数据录入过程，并已经存在数据管理、数据录入、核心(Core)三个基本模块。
监控端修改部分 （1）人脸识别实现
在主要部分【核心】的实现上，原项目采用LBPH实现了人脸识别的基本功能，并使用haar-like实现人脸位置捕获，使用dlib目标追踪器实现同一画面下多个人脸的目标追踪，尝试主要追踪，次要捕获的方式优化人脸捕获的过程。识别速度与画面帧率很高，
但识别准确率并不理想，并且严重受到光照条件影响。【实际使用时证明，若录入人脸数据时存在单方面光源照射，在识别时，光源位置一旦改变就完全识别不出来了】
并且录入数据时需要大量人脸数据集【100张人脸图以上】，才能获得较高的识别置信度。
二次开发后，保留原本速度较快的LBPH人脸识别，新增效果更好的dlib_face_recognition_resnet_model深度学习残差网络识别模型。实际使用时发现，虽然实时视频流帧率明显降低，但是识别准确率大大提高。
（2）摄像头启动与关闭
在原项目中，在摄像头调用的设计上，录入端和监控端同样都是用了摄像头，并进行人脸捕获，但监控端只允许打开和关闭一次摄像头，之后就禁用了摄像头控制按钮，而录入端则允许随意多次的打开和关闭摄像头。
其原因是具体实现上，因为监控端需要启动单独线程执行人脸识别任务，而录入端没有人脸识别的复杂处理过程，在一个线程中就可以实现需要的功能。监控端开启摄像头后，同时启动人脸识别线程处理单帧图像，并启动报警监听线程，设计思路上是报警线程一旦开启，全程保持监听，直到程序关闭，而关闭摄像头时代码实现上只关闭，也只能够关闭人脸识别线程，对于报警监听线程无法控制。导致如果容许摄像头二次开启，人脸识别线程能够启动，但作为同一个线程实例的报警监听模块将被二次启动，导致程序出错。
这里的人脸识别线程继承自QTread类，允许使用.stop()函数控制线程实例的开始与终止，而报警监听模块则是普通的threading.Thread()，开启后无法控制关闭，导致出现上述问题。改进方法是将报警监听线程使用QTread实现，使用与人脸识别线程相同的控制方法，摄像头开启时启动，摄像头关闭时终止，实现二次启动功能。
（3）报警系统改为签到系统
因为系统的功能修改前后有所改变，但是实现的技术实际上是一样的。原始项目的报警功能实际上可以作为签到系统的监听线程。原始代码逻辑为，发现置信度低于阈值的脸即陌生人脸，随机人脸识别线程通过通信队列告知报警系统执行截图拍摄、消息推送、报警响铃等功能。改变为签到系统后，人脸识别线程将置信度阈值以上【即数据库中存在并认为可信的脸】，且匹配度最高的人脸作为签到信号，通过队列通信发送给签到线程，并执行之前没有的数据库录入操作。
简单来说就是，之前是把认不出来的脸进行记录和报警，转变为认出来且最像的人脸进行记录和执行声音提示。
（4）签到表格的创建
这个属于签到系统特有的新增功能，说道考勤签到就一定会想到教师用来点名的签到表，因此该签到系统需要生成一个包含当前课程需要签到的所有学生信息，通过预处理进行创建，并在人脸识别过程中实时修改记录签到信息，主要内容为学生姓名、学号、签到时间。该功能内建了一个基于MySQL查询的QTableWidget控件，用于方便用户之间从数据库中选择并创建需要签到的学生名单。
管理端修改部分 （1）学生信息管理
原始的管理端非常简陋，存储信息仅包含学生姓名、faceID、学号这样的普通信息，想要查询学生信息也只能进行单人查询，并且只能通过学号，查询的唯一目的就是通过学号删除查询结果。因此无论是查询还是删除都非常简陋。甚至根本不存在修改信息的功能。
修改后的管理端新增了多条件模糊查询，并且大大增加了信息维数，允许直接双击修改学生信息，并实时同步到数据库中。同时删除信息的功能也和信息查询分离开来，信息查询结果动态显示在QTableWidget控件中【与原项目使用的技术相同，只是做了更大的功能扩展】。支持用户多选删除，不不必“查一个，删一个”。
（2）人脸数据训练
原项目中的人脸数据训练功能同样集成在管理端中，原作者自定义了一个读取数据集并将其与学生通过faceID进行唯一匹配的函数，也就是LBPH数据训练中的人脸数据(faces)与分类标签(labels)。读取并整理成LBPH.train()所需要的数据结构后即可直接将数据作为参数调用封装好的函数进行训练。
值得一提的是，LBPH的数据训练非常快，即使在三百人的，每人人脸数据集平均20张的情况下，训练时间依然能控制在十几秒内【但是结果其实并不好】，因此原作者并没有将其作为单独的线程来执行，而是直接甩给用户一个提示：训练期间系统窗口可能会无响应，请耐心等待。。。
这样的结果是导致用户体验极差，会以为程序崩了，其实只是训练计算时间过长，导致windows消息监听一段时间内无回应，被认为是程序无响应。。。
二次开发后我将其独立为一个线程单独执行，并为执行函数增加了进度条，让用户直观的看到训练过程。顺便，在代码实现过程中，发现大量时间实际上消耗在图片数据集的读取上，训练的过程反倒没有那么久，因此进度条实际展示的是读取过程，逻辑上是先进行的数据读取，再计算特征值，然后继续读取下一个数据集，因此将数据读取作为进度来衡量不会有时间上的偏差。
三、代码具体实现 这里就简单贴一下数据录入端的代码。项目完整代码还请移步本文开始位置的链接。
#!/usr/bin/env python3 # Author: kuronekonano &lt;god772525182@gmail.com&gt; # 人脸信息录入 import re import string import time import cv2 import pymysql import shutil from PyQt5.QtCore import QTimer, QRegExp, pyqtSignal, QThread from PyQt5.QtGui import QImage, QPixmap, QIcon, QRegExpValidator, QTextCursor from PyQt5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb6dc5202501c33cf937ae5678483eeb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3fa633002b02bd5ef67076b9c82056b/" rel="bookmark">
			DVD&#43;R和DVD-R有什么区别？如果选购的话有什么需要注意的？--九五小庞
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DVD-R和DVD + R的区别和比较 表面上看，DVD + R光盘看起来与DVD-R光盘没有区别。它们的直径均为120mm，厚度为1.2mm，包括两个0.6mm的聚碳酸酯基材。但是，DVD + R在光盘上写有“ DVD + R”，而DVD-R光盘有各自的用词。DVD + R和DVD-R之间的主要区别和比较主要集中在标准，兼容性，质量，速度和价格上。
1. DVD + R VS DVD-R-标准差异 DVD-R格式由Pioneer于1997年开发。大多数普通DVD播放器均支持该格式，并获得DVD论坛的批准。
DVD + R格式是由飞利浦和索尼及其DVD + RW联盟开发的，于2002年推出。
支持DVD-R的公司包括Pioneer，东芝，日立和松下，而支持DVD + R的公司包括Sony，飞利浦，惠普，理光和Yamaha。
2. DVD-R VS DVD + R –功能差异 DVD-R和DVD + R之间的主要功能差异是它们确定光盘上激光束位置的方式。
DVD-R在光盘的凹槽上使用微小的标记(称为“凸台凹坑”)来确定激光的位置。DVD + R没有台面凹坑，而是在激光移向光盘外部时测量“摆动频率”。
3. DVD-R VS DVD + R –质量/速度/价格比较 通过应用不同的技术，DVD + R在许多方面都具有比DVD-R更好的性能。例如，在记录质量和速度上，DVD + R都领先于DVD-R。因此，DVD-R光盘通常比DVD + R格式便宜。
作者：时光匆匆
链接：https://www.zhihu.com/question/322803688/answer/1545659582
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be21df4ec13c03cb2ffa59f9439e00d2/" rel="bookmark">
			字符大小写及ASCII码转化方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大小写转化：
("HelloWorld").toLowerCase(); // helloworld
("HelloWorld").toUpperCase(); // HELLOWORLD
字符与ASCII码： ("A").charCodeAt(); // 65
String.fromCharCode(65); // A
将大写字母转换为小写字母的后一位字母，Z转化为a;
let str = "AJIZDJI";
let arr = str.split('').map((item,i)=&gt;{
if(item == 'Z') {
return 'a';
} else {
return String.fromCharCode(item.charCodeAt()+1).toLowerCase();
}
})
console.log(arr.join('')); // bkjaekj
参考：字符大小写及ASCII码转化方法
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e00dde7035e727a63cc96bdf7d576ca7/" rel="bookmark">
			MC物品英文名命名空间列表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		建议:Ctrl+F
空气：（minecraft：air）
石头：（minecraft：stone）
草：（minecraft：grass）
泥土：（minecraft：dirt）
圆石：（minecraft：cobblestone）
橡木木板：（minecraft：planks）
橡树树苗：（minecraft：sapling）
基岩：（minecraft：bedrock）
流动的水：（minecraft：flowing_water）
静止的水：（minecraft：water）
流动的岩浆：（minecraft：flowing_lava）
静止的岩浆：（minecraft：lava）
沙子：（minecraft：sand）
砂砾：（minecraft：gravel）
金矿石：（minecraft：gold_ore）
铁矿石：（minecraft：iron_ore）
煤矿石：（minecraft：coal_ore）
橡木：（minecraft：log）
橡树叶：（minecraft：leaves）
海绵：（minecraft：sponge）
玻璃：（minecraft：glass）
青金石矿石：（minecraft：lapis_ore）
青金石块：（minecraft：lapis_block）
发射器：（minecraft：dispenser）
沙石：（minecraft：sandstone）
音符方块：（minecraft：noteblock）
床：（minecraft：bed）
动力轨道：（minecraft：golden_rail）
探测器轨道：（minecraft：detector_rail）
粘性活塞：（minecraft：sticky_piston）
蜘蛛网：（minecraft：web）
枯草丛：（minecraft：tallgrass）
死灌木：（minecraft：deadbush）
活塞：（minecraft：piston）
活塞头：（minecraft：piston_head）
白色羊毛：（minecraft：wool）
蒲公英：（minecraft：yellow_flower）
罂粟花：（minecraft：red_flower）
棕色蘑菇：（minecraft：brown_mushroom）
红色蘑菇：（minecraft：red_mushroom）
金块：（minecraft：gold_block）
铁块：（minecraft：iron_block）
双石台阶：（minecraft：double_stone_slab）
石台阶：（minecraft：stone_slab）
砖块：（minecraft：brick_block）
TNT：（minecraft：tnt）
书架：（minecraft：bookshelf）
苔石：（minecraft：mossy_cobblestone）
黑曜石：（minecraft：obsidian）
火把：（minecraft：torch）
火焰：（minecraft：fire）
怪物刷怪笼：（minecraft：mob_spawner）
橡木楼梯：（minecraft：oak_stairs）
箱子：（minecraft：chest）
红石线：（minecraft：redstone_wire）
钻石矿石：（minecraft：diamond_ore）
钻石块：（minecraft：diamond_block）
工作台：（minecraft：crafting_table）
小麦作物：（minecraft：wheat）
耕地：（minecraft：farmland）
熔炉：（minecraft：furnace）
燃烧的熔炉：（minecraft：lit_furnace）
立牌块：（minecraft：standing_sign）
橡木门块：（minecraft：wooden_door）
梯子：（minecraft：ladder）
铁轨：（minecraft：rail）
石砖楼梯：（minecraft：stone_stairs）
墙上挂的标牌块：（minecraft：wall_sign）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e00dde7035e727a63cc96bdf7d576ca7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a6b304cc79a6af2a486f6279c2b53ce/" rel="bookmark">
			Ubuntu安装后的事情【新手向】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ubuntu安装后的事情 准备工作换软件源安装Vim安装Chrome使用WPS Office 疑难杂症firefox无法观看视频/音频安装依赖的时候遇到的问题 准备工作 换软件源 1、备份自己的镜像源防止出错，路径/etc/apt/ 文件名sources.list.bak
sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak
2、编辑镜像源
sudo gedit /etc/apt/sources.list
3、选一个源换上有清华源、阿里源、中科源
# 阿里源 deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse deb-src http://mirrors.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a6b304cc79a6af2a486f6279c2b53ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6706ddfb3a498bae3a04d18912fe5be/" rel="bookmark">
			「强烈收藏」Python第三方库资源大全，1000&#43;工具包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 awesome-python 是 vinta 发起维护的 Python 资源列表，内容包括：Web 框架、网络爬虫、网络内容提取、模板引擎、数据库、数据可视化、图片处理、文本处理、自然语言处理、机器学习、日志、代码分析等。
【----帮助Python学习，以下所有学习资料文末免费领！----】
中文版Github地址：
https://github.com/jobbole/awesome-python-cn
英文版Github地址：
https://github.com/vinta/awesome-python
环境管理 管理 Python 版本和环境的工具
p：非常简单的交互式 python 版本管理工具。
pyenv：简单的 Python 版本管理工具。
Vex：可以在虚拟环境中执行命令。
virtualenv：创建独立 Python 环境的工具。
virtualenvwrapper：virtualenv 的一组扩展。
buildout：在隔离环境初始化后使用声明性配置管理。
（文末送读者福利）
包管理 管理包和依赖的工具。
pip：Python 包和依赖关系管理工具。
pip-tools：保证 Python 包依赖关系更新的一组工具。
PyPI：Python 正式的第三方包软件存储库。
pipenv：Python 官方推荐的新一代包管理工具。
poetry：可完全取代 setup.py 的包管理工具。
conda：跨平台的 Python 二进制包管理工具。
Curdling：管理 Python 包的命令行工具。
wheel：Python 分发的新标准，意在取代 eggs。
包仓库 本地 PyPI 仓库服务和代理。
warehouse：下一代 PyPI。
bandersnatch：PyPA 提供的 PyPI 镜像工具。
devpi：PyPI 服务和打包/测试/分发工具。
localshop：本地 PyPI 服务（自定义包并且自动对 PyPI 镜像）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6706ddfb3a498bae3a04d18912fe5be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ea9c584115eecf25875cd586fca36b3/" rel="bookmark">
			2023金砖网络安全决赛--线上赛真题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		所有附件免费分享：
模块一：系统防护（操作系统加固）
模块二：流量分析
模块三：内存取证
模块四：杂项
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79b28342ce08a37a7dee875e1c22b8be/" rel="bookmark">
			Python for循环
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python的for循环 一、for循环 for循环：循环就是重复做某件事，for循环是python提供第二种循环机制（第一种是while循环），理论上for循环能做的事情，while循环都可以做。
目的：之所以要有for循环，是因为for循环在循环取值（遍历取值）比while循环更简洁。
（文末送读者福利）
二、for循环语法如下 for 变量名 in 可迭代对象: # 此时只需知道可迭代对象可以是字符串\列表\字典，其实也可以是tuple(),set()
代码一
代码二
# # for循环 # # 列表取值 # l = ['lsj','a','b'] # for x in l: # print(x) lsj a b ... # 参照例1来介绍for循环的运行步骤 # 步骤1：从列表['lsj','a','b']中读出第一个值赋值给x（x=‘lsj’），然后执行循环体代码 # 步骤2：从列表 ['lsj','a','b'] 三、 for循环应用案例 案例一：
# 简单版：for循环的实现方式 # l = ['lsj', 'b', 'c'] # 定义一个列表 # for x in l: # print(x) # lsj # b # c # 复杂版：while循环的实现方式 l = ["
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/79b28342ce08a37a7dee875e1c22b8be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83d042cb922edeb49885f2000b0e0071/" rel="bookmark">
			自动驾驶合成数据科普一：不做真实数据的“颠覆者”，做“杠杆”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： 在7月底的一篇文章中，九章智驾提到，数据闭环能力是自动驾驶下半场的“入场券”，这一观点在行业内引起了广泛共鸣。
在数据闭环体系中，仿真技术无疑是非常关键的一环。仿真的起点是数据，而数据又分为真实数据跟合成数据。随着真实数据“规模小、质量低、使用难度大”等问题日渐暴露，合成数据越来越受重视。
顾名思义，合成数据（synthetic data）就是通过计算机技术生成的数据，而不是由真实事件产生的数据。但合成数据又具备“可用性”，能够在数学上或统计学上反映原始数据的属性，因此也可以用来训练、测试并验证模型——OpenAI 的 GPT-4，就采用了大量前一代模型 GPT-3.5 生产的数据来进行训练。
在2022年底，笔者曾写过5篇关于自动驾驶仿真的科普文，但这几篇文章对合成数据的着墨不多。过去的两个月里，笔者在学习合成数据的过程中，又遇到了不少疑问，带着这些疑问，笔者请教了十多位业内专家，然后形成“合成数据科普文”系列。
在本系列文章的撰写过程中，笔者得到了光轮智能CEO谢晨、图森首席科学家王乃岩、辰韬资本赵磊、复睿微电子张俊川、百度仿真专家徐志健、昆易电子方志刚、“车路慢慢”运营者李漫漫、PanoSim王文威等朋友的支持，在此表示感谢。
自动驾驶合成数据科普一： 不做真实数据的“颠覆者”，做“杠杆” 自动驾驶的仿真，最早就是以合成数据为主。这里讲的合成数据，主要是指由人工基于规则搭建的场景，这背后的技术，就是业内常说的WorldSim。通常，基于WorldSim搭建的场景，还需要用Unreal等游戏引擎来做图像渲染。直到今天，WorldSim+游戏引擎仍然是自动驾驶行业用得最多的合成技术之一。
看起来，基于WorldSim+游戏引擎的合成数据能在一定程度上弥补真实数据不足的问题，然而，在实际使用中，这种合成数据存在一个很难克服的短板：真实度还不够高。用更专业的术语来说是“保真度”不够高。
这一痛点，决定了基于WorldSim+游戏引擎的合成数据基本上只能用来做测试，很难用于做算法训练。
为了避开WorldSim+游戏引擎技术的这一短板，有一些公司试图将真实道路数据“转换成数学模型”。然而，这一设想实施起来困难重重。
但合成数据“可用性”的提升，并未因此而停止。
真正能帮合成数据提升可用性的，是更高的保真度和更强的泛化能力。GAN、VAE和Diffusion Model等模型在自动驾驶仿真中的应用，已经证明了这一点；而当下广受追捧的NeRF技术，也需要保证泛化能力才有可能被广泛应用。
当下大热的AI大模型能，也将在自动驾驶仿真中占有一席之地。事实上，AI大模型+NeRF的组合，被一些从业者视为帮合成数据攻克保真度和泛化能力这两大难题的关键武器。
随着合成数据面临的主要难题被一一攻克，真实数据“规模小、质量低、使用难度大”的问题也不再那么令人担忧。
通常，在谈起合成数据时，人们本能地以为它的主要价值是弥补真实数据“数量不足”的问题。但这可能是一个严重的误解。
在笔者看来，真实数据的最主要问题并不是“太少”，而是“质量低，使用难度大”。所以，哪怕真实数据的规模很大，合成数据仍然是必不可少的。不信的话，看看“最不缺”真实数据的特斯拉是怎么做的吧——特斯拉也在使用合成数据！
在国内，各家已有自动驾驶量产车型上路的主机厂也不缺真实数据，但这些数据的利用率究竟“高达”20%、10%还是1%，其实是存在很大的疑问的。
不过，真实数据质量低、使用难度大给主机厂带来的困扰，恰合也就是合成数据的用武之地。
有意思的是，不同于L4公司普遍用合成数据来“弥补”真实数据的不足，一些以提供合成数据服务为主业的公司更倾向于将合成数据定位为真实数据的“杠杆”。在后者看来，合成数据的使命和愿景并不是要去顶替真实数据，而是要做真实数据的“放大器”，帮助主机厂或自动驾驶公司提高真实数据的使用效率。
下面，我们将以1.1万字的篇幅来盘点一下“合成数据究竟能解决真实数据的哪些痛点”。
一、兼顾隐私保护与数据的可用性 在真实场景中，自动驾驶车辆的传感器采集到的信息经常包括车牌、人脸，但出于隐私保护的需求，这些数据通常大都无法直接使用，而是得先做脱敏或加密才行。但脱敏不仅意味着一笔额外的成本，而且，如果脱敏处理不好，数据的价值也会大打折扣，甚至根本无法使用。
但如果是根据实际需求搭建一些不包含隐私信息的数据，就可在兼顾隐私保护的前提下确保数据的可用性。
在美国和欧洲，合成数据已经是一个很大的产业了，但在中国，合成数据还处于萌芽阶段，其中有一个重要的原因是：
美欧国家在文化和法律层面都会对隐私保护比较讲究，因此，企业不得不通过采用合成数据来避免高度依赖真实数据所带来的风险；而在中国，长期以来，无论在文化层面还是法律层面，隐私都没有受到足够的重视，所以，企业可以“肆无忌惮”地使用真实数据，这也导致了中国缺乏合成数据发展的土壤。
但情况正在发生变化。一方面，在中国，普通个体关于隐私保护的权利意识在觉醒；另一方面，法律层面也不允许企业肆意滥用各种隐私数据了。
单从隐私保护的角度考虑，国内公司也将越来越多地降低对真实数据的依赖程度。
二、避开高精地图的资质障碍 除了图商等极少数有资质的公司，大多数公司都无法通过路采获取真实数据的方式来绘制高精地图，为了避开这一问题，很多公司推出了“去高精地图”方案，但这一方案对公司的前融合算法能力、规控算法能力都提出了新的挑战，实际上，真正能落地的公司并不多。
但如果能用合成数据来制作高精地图，那问题就简单得多了。
在中国，我们尚未看到有公司采用合成数据来制作高精地图，但在美国，已经有了类似的先例了。
2021年11月，在一场题为 Under the Hood的活动上，Cruise仿真技术战略主管 Sid Gandhi 披露，在向新的城市拓展时，他们不必重新绘制城市地图来跟踪车道变更或街道封闭等“不可避免发生的环境变化”，而是利用一项名为 WorldGen 的技术，准确、大规模地生成整个城市，“从奇特的布局到最小的细节”。
为了确保最佳的世界创建，Cruise 考虑了一天 24 小时不同时间段的照明和天气条件等因素，甚至系统地测量了旧金山一系列路灯的光线。
对于无法在现实路况下收集的特定场景，Cruise则使用 Morpheus。Morpheus 是一个可以根据地图上的特定位置生成合成数据的系统。
据曾担任过Cruise仿真负责人的光轮智能CEO谢晨说：
Crusie的 WorldGen和Morpheus并不是用合成数据来做高精地图，而是对真实世界做3D重建。但无论如何，将车道变更或街道封闭及“从奇特的布局到最小的细节”都纳入3D重建中，重建后的信息元素已经很接近高精地图了。
在美国，自动驾驶公司采集真实道路数据并不会受到如在中国这般严格的限制，但Crusie仍然采用了合成数据，这给那些被高精地图政策束缚了手脚的中国公司提供了一种新思路。
此外，今后受数据合规相关法规政策影响的，就不限于高精地图数据了，还有用于感知算法训练的数据回传。 （这一点，九章在6月30日发的《“去高精地图”跟“轻高精地图”有啥区别？落地的挑战又是啥？》一文的第七章“感知算法训练或将受到数据合格政策的影响”部分已做过详细的分析，并在此后也从其他平台发布的类似内容中得到进一步印证，在此不再赘述。）
可以想见，接下来，用真实道路数据做算法训练的难度是越来越大了——不是没法做，关键是对车端脱敏的要求太高了，甚至可能还需要跟有测绘资质的图商合作。
受这一政策冲击较少的公司，应该就是那些率先开始拥抱合成数据的公司。
三、高效生成在真实场景中很难获取的Corner Case 大家都清楚，自动驾驶系统很难彻底取代人，最关键的原因是对各种corner case的应对能力不足，而应对能力的不足又源于数据量不够。这正是合成数据大有可为的地方。
大量的corner case，在真正发生前，没有人能想得到——预期功能安全第三象限里面的“unknown,unsafe”一类，所以无法在真实道路上做模拟。这类corner case，没法通过基于人工规则的合成数据（WorldSim）来生成，也没法通过对真实世界做3D重建的技术（NeRF）来生成，但有望通过基于AIGC的合成数据来获取。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/83d042cb922edeb49885f2000b0e0071/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0b822f2dc0cb45c5017b88ab4fd0e5c/" rel="bookmark">
			Firewall-cmd防火墙常用操作命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#查看防火墙状态
systemctl status firewalld #启动防火墙
systemctl start firewalld.service
#当前机器对源ip开放所有端口（相当于对这个ip开放了白名单）
firewall-cmd --zone=public --add-rich-rule 'rule family="ipv4" source address="10.11.12.13" accept' --permanent
#删除对所有ip开放的端口
firewall-cmd --zone=public --remove-port=12345/tcp --permanent
#增加对所有ip开放的端口
firewall-cmd --permanent --add-port=54321/tcp
#防火墙重新加载生效
firewall-cmd --reload
#查看对所有ip开放的端口
firewall-cmd --list-port
#查看对那些ip开放了白名单
firewall-cmd --zone=public --list-rich-rule
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b75e8865bb9b82d21b01788b4e05fa1/" rel="bookmark">
			vue 学习 -- day05（事件处理）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用v-on:xxx 或 @xxx 绑定事件，其中xxx是事件名；事件的回调需要配置在methods对象中，最终会在vm上；methods中配置的函数，不要用箭头函数！否则this就不是vm了（会指向 window）；methods中配置的函数，都是被Vue所管理的函数，this的指向是vm 或 组件实例对象；@click="demo" 和 @click="demo($event)" 效果一致，但后者可以传参； 注意：方法不做数据代理（为了数据写到页面上去）, 方法以后不改，等着被调用就可以了，所以没有必要做数据代理
方法不要写到 data 中，因为这样会让 vue 很累，放到data中方法会做数据代理，且给它做数据代理没有意义
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c501ce9918820fce28f5198446642399/" rel="bookmark">
			PyCharm2023常用设置步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、设置界面语言为中文 1、点击"Plugins"选项，输入"chinese"，然后安装
2、重启IDE
3、完成
二、设置PyCharm界面字体和颜色 1、选择颜色方案、IDE字体
注：IDE：Integrated Development Environment 集成开发环境
2、选择后界面改变如下
三、设置编程界面字体字号 1、创建项目后进入编程界面， 编程界面字很小，可设置为自己喜欢的字体字号。
（创建项目可查看“环境配置”教程。）
2、点击“文件”，“设置”选项
3、进入“设置”界面后，选择自己喜欢的字体、字号，点击右下角“应用”，再点击“确定”后回到原界面。
4、界面更改如下
四、设置界面配色 1、点击“文件”，“设置”进入设置界面；
点击“编辑器”，“配色方案”，选择自己喜欢的配色后，点击“应用”，“确定”。
2、假如选择“WarmNeon”后界面如下
五、设置制表符tab键为4个字符 六、恢复初始设置 1. 打开PyCharm，点击“文件”菜单。
2. 选择“管理IDE设置”--&gt;“恢复默认设置”。
3. 在弹出的对话框中，点击“恢复并重启”按钮即可。
（仅为学习笔记，如有所帮助还请收藏点个赞）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e58a768a56e8075d19545c21a244bc5/" rel="bookmark">
			若依RuoYi-Vue下拉列表关联数据代码解读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		情形 现有岗位管理页面专用于维护岗位信息，如下图
在用户管理页面，需要通过下拉列表选中岗位数据。如下图
用户管理页面的岗位下拉列表数据和岗位管理中的数据连接，实现通过web页面的数据维护
前端 定位此功能前端代码位置 启动项目，在web界面按住F12键打开调试页面
若在之前的调试过程中存在有残留信息，建议清空内容，便于查看当前所调试的功能信息
清除内容后，打开目标页面（查看在页面加载时出现的路径）
发现URL localhost/dev-api/system/user/
JS文件 找对应的JS文件，按照目录在src/api下找/system/user文件
接着使用搜索快捷键Ctrl+F对调用/system/user/的方法进行寻找，发现方法getUser
代码解读 // 查询用户详细 export function getUser(userId) { return request({ url: '/system/user/' + parseStrEmpty(userId), method: 'get' }) } url 是访问后端接口的地址 userId 传入此参数
method 为请求方法
请求方式
GET
获取数据，类似于数据库中的select
PUT
发送数据，类似于数据库的insert操作
POST
发送数据，类似于数据库的update操作
DELETE
删除数据，类似于数据库中的delete操作
vue文件 找对应的vue文件：vue文件全在src/views目录下，继续按照system/user/找
在vue文件中找岗位涉及的代码：使用Ctrl+F搜索
解读代码 &lt;el-form-item label="岗位"&gt; &lt;el-select v-model="form.postIds" multiple placeholder="请选择岗位"&gt; 会展现给用户的值：label="岗位"，placeholder="请选择岗位"，:label=" "
v-model：是当前选框选中的值(即选框显示的值) 对应value的值
&lt;el-select &gt;中可以添加的一些功能效果:
清空已选中的项
clearable=""
启用多选
multiple
可搜索
filterable
v-for="item in postOptions"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e58a768a56e8075d19545c21a244bc5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d00364b2e960844b422cbf2c85d33895/" rel="bookmark">
			设计模式之模板方法模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在上一篇记录中，做了菜单树的实现，其中有一行代码 Collections.sort(children);它的功能是根据菜单的父节点编号PID进行排序，实现代码如下：
/** * 系统菜单实体类 */ public class SystemMenuInfo implements Serializable,Comparable&lt;SystemMenuInfo&gt;{ private static final long serialVersionUID = -612577710282986839L; private Integer menuId; private String menuName; private String url; private Integer menuLevel; private String iconCls; private Integer sortId; private Integer pid; private String description; private String remark; private String creator; private Date createDate; private String modifier; private Date modifyDate; private String menuState; private List&lt;SystemMenuInfo&gt; children; /** * 根据sortId升序排序 * @param menu * @return */ @Override public int compareTo(@NotNull SystemMenuInfo menu) { if(this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d00364b2e960844b422cbf2c85d33895/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d67da2c5d970b679244eca09062dfe5/" rel="bookmark">
			【保姆级教程】使用Anaconda创建并配置环境Tensorflow
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天重新配置环境，距上次配置环境已经过了几个月了，很多步骤都忘了。因此想来更新一帖，记录一下，方便自己以后再次配置环境，也希望对刚刚入门深度学习的萌新有点指导意义。
1.创建环境
使用 Anaconda 建立环境（==Anaconda十分好用，非常建议大家下载==）
具体流程：打开Anaconda Prompt
打开后Anaconda Prompt，我们就直接进入了base环境。此时，我们可以通过以下命令流来创建一个新的环境
conda create -n name(此处的name是你所要创建的环境的名字) python=3.7（python版本自己指定)） 如下，我创建了一个名为SCI_Re的环境，该环境采用Python3.7作为Interpreter(编译器)
这样环境就创建完毕，是不是超级简单？创建完环境后，以后我们就可以在该环境中下载各种我们所需要的库/包了。
2.进入到所配置的环境
创建完环境后，接下来是就是配置环境了。
配置环境的第一步是需要我们先进入到我们要配置的环境当中。同样是先打开Anaconda Prompt，进入到基础的base环境中。然后通过输入下面的conda语令进入到我们刚刚创建的SCI_Re环境。
conda activate SCI_Re 下图显示我们已经成功进入到SCI_Re环境中
3.配置环境(下载Tensorflow)
在进入到我们所创建的环境中后，接下来我们就可以在该环境中下载各种库/包，从而实现环境的配置啦。
下载和安装深度学习环境中的各种库时，相比于pycharm中的GUI可视化操作，我更倾向于使用pip指令或者conda指令。其中，conda指令是最舒服的（因为conda可以根据你当前的环境，配置可与其相兼容的库/包。而pip指令则需要你知道自己的环境兼容哪个版本的库/包，若无指定，则pip默认下载目标库/包的最新版本，而有时候由于版本过新，很可能出现不兼容的问题。）
===P.S.pip是python自带的下载工具，一般来讲，安装完pyhton后，就可以使用pip工具了。===
此处，我使用pip工具下载Tensorflow
pip install tensorflow gpu==2.2.0 -i https://mirrors.aliyun.com/pypi/simple/ --trusted-host pypi.aliyun.com 如下图所示：
该tensorflow_gpu版本是我在NVDIA官网上找到的。不同的显卡，驱动对应着不同的版本，大家可以自行查阅电脑对应的版本。
官网查阅链接：
在 Windows 环境中从源代码构建 | TensorFlow
参考链接：
win10环境下配置Python TensorFlow深度学习环境（GPU版） - 知乎
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2703e6686398542c408796e375a376c5/" rel="bookmark">
			冯诺依曼体系结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		冯诺依曼体系结构 冯·诺依曼结构也称普林斯顿结构，是一种将程序指令存储器和数据存储器合并在一起的存储器结构。程序指令存储地址和数据存储地址指向同一个存储器的不同物理位置，因此程序指令和数据的宽度相同，如英特尔公司的8086中央处理器的程序指令和数据都是16位宽。
数学家冯·诺依曼提出了计算机制造的三个基本原则，即采用二进制逻辑、程序存储执行以及计算机由五个部分组成（运算器、控制器、存储器、输入设备、输出设备），这套理论被称为冯·诺依曼体系结构。
—来源于百度
计算机，都是由一个个的硬件组件组成
输入设备：鼠标，键盘，摄像头，网卡，磁盘等
输出设备显示器，播放器硬件，磁盘，网卡等
输入输出设备都是外设，有的设备纯是输入，输出，也有的设备既是输入也是输出
运算器：对数据进行计算任务(算术运算，逻辑运算)
控制器：计算硬件流程进行一定的控制
存储器：内存
要想将数据输入到计算机中，就必须要有输入设备，经过计算机一系列的处理之后，还要将结果反馈出来，所以计算机也必须要有输出设备。
那么，当我们的体系结构中有了输入，输出设备和CPU之后，就能正常工作，为什么还需要存储器呢？？
首先，CPU的运算速度是非常快的，要远大于外设，那么我们进行输入之后，CPU很快就将问题给解决了，然后传递给输出设备，这个时候又有数据从输入设备进行输出，CPU解决之后，上一次的数据输出设备还没有输出完毕。所以就需要一个速度不是特别快，也不是特别慢的中间物质来进行一个存储。就跟木桶原理很相似，这个桶能装多少水，取决于最低的那个木板，因为外设的速度&lt;CPU的速度，所以效率就会大大降低，如果有了存储器，就会很好的解决这个问题。
将问题输入之后，由存储器来获取内存，然后CPU从存储器中获取要处理的数据，处理完成之后，将数据返回给存储器，再由外设接收，这样，无论什么时候，CPU只从存储器中获取数据，这样就能大大的提高计算机的效率。
这里的存储器指的是内存，不考虑缓存的情况，这里的CPU能且只能对内存进行读写，不能访问外设(输入或输出设备)，外设要输入或输出数据，也只能写入内存或者从内存中读取。所有设备都只能直接和内存打交道
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7301ada216e32473a019e1ebf5d73ba/" rel="bookmark">
			DSO 系列文章(2)——DSO点帧管理策略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.点所构成的残差Residual的管理1.1.前端残差的状态1.2.后端点的残差的状态1.3.点的某个残差的删除 2.点Point的管理2.1.如何删除点——点Point的删除2.2.边缘化时删除哪些点？ 3.帧FrameHessian的管理 DSO代码注释：https://github.com/Cc19245/DSO-CC_Comments
1.点所构成的残差Residual的管理 1.1.前端残差的状态 PointFrameResidual的状态有三种：
IN——内点。表示这个残差状态正常，可以参与优化；
OOB——Out Of Boundary，出界点。表示把host帧上的点通过线性化点或最新状态的相机位姿投影到target帧之后，这个点不在图像范围内，表示这个点出界了，那么这个残差不能参与优化。
注意：一个残差只要被判断为出界，后面就再也不用他了，作者代码中也有一句注释叫做can never go back from OOB。这个确实也是有道理的，因为前端已经跟踪得到了一个初始位姿了，有投影匹配的点是不太可能出界的。
OUTLIER——外点，表示这个残差能量超过了阈值，注意和OOB区分。外点类似于特征点法中的无匹配，也就是找到了匹配关系，但是误差太大，如果使用它优化会造成不好的影响，干脆就不用这个残差。
注意：随着优化的进行，外点的残差能量有可能会慢慢降低到小于阈值，此时它就可以恢复成内点，然后继续参与优化。因此外点是可以恢复的。
为了让OOB起到一票否决的作用，在代码中使用了state_state变量表示这个残差上次的状态，一旦它上次的状态是OOB，那么函数都会直接跳过或返回，从而这个残差永远不可能再次参与到优化中。
1.2.后端点的残差的状态 EFResidual的状态就比较简单了，只有一个变量bool isActiveAndIsGoodNEW来表示这个点能量残差是否在后端优化中使用。这个变量是由前端残差的状态来设置的，只有前端残差的状态是IN，这个变量才是true，否则全都是false。
那么什么时候设定后端残差的状态呢？就是调用applyRes把前端雅克比传递给后端的时候，此时会一并把前端残差的状态传递给后端，让后端残差的状态得到更新。下面对几个函数进行说明：
PointFrameResidual::linearize
（1）前端残差进行线性化求雅克比。注意这个过程中有两部分雅克比， 一个是像素点关于相机位姿、内参、逆深度部分雅克比，它们使用线性化点的状态，保持不变；另一个是像素梯度和残差，它们使用最新的状态，因此是变化的。
（2）在此过程中会判断前端残差的状态，存储到前端残差的类成员变量中。
``PointFrameResidual::applyRes`
把前端残差更新到后端，同时把前端残差的状态也更新到后端（这个很正常，因为残差都给后端了，自然也要告诉后端这个残差是否有效）
FullSystem::linearizeAll_Reductor(true/false)
（1）一定会调用PointFrameResidual::linearize计算最新的雅克比，并且判断前端残差状态。
（2）如果传入true，会把前端雅克比和残差状态更新到后端，并且把前端非IN状态的残差放到toRemove数组中。
FullSystem::linearizeAll(true/false)
（1）一定会调用FullSystem::linearizeAll_Reductor(true/false)。
（2）如果传入true，那么会把linearizeAll_Reductor函数里统计出来的非IN状态的残差，从PointHessian和后端优化的大bossEnergyFunctional中丢弃，也就是这个残差不再存在了。
注意：什么时候这个函数会传入true呢？答案是只有在完成迭代优化的循环之后才会传入true，因为此时已经得到了本次滑窗优化的最终结果，可以把使用这个最终结果判断的非IN状态的残差从前端和后端删掉了。但是其他任何时候，比如迭代优化之前或迭代优化过程中，我们只能对残差求雅克比、判断它们状态，如果不是IN那么后端优化就不使用，但是我们不能把这些残差删掉，因为优化还没开始或者还没完成，可能这次是OUTLIER的残差，优化几次就变成了IN，所以我们不能删掉这些残差。
1.3.点的某个残差的删除 如上所述，在FullSystem::optimize中后端迭代优化完成后，会调用FullSystem::linearizeAll(true)根据最新的状态把所有残差重新线性化一次，由于传入了true所以会筛选出非IN状态的残差，并把他们删除掉，该函数中实现的删除残差的步骤如下：
EnergyFunctional::dropResidual删除后端残差：先把这个残差从后端能量点的残差数组中弹出，然后把前端对应的残差持有的这个后端残差指针置零，最后delete释放内存。FullSystem::deleteOut删除前端残差：先把前端点的残差数组中要删除位置的残差的指针delete释放到，然后把数组最后一个残差赋值到这个位置。其实本质上和删除后端残差的操作一致，只不过释放指针和弹出数组的先后顺序不同。 2.点Point的管理 2.1.如何删除点——点Point的删除 如上所述，在FullSystem::optimize中后端迭代优化完成后，会根据最新的状态把所有残差重新线性化一次，同时筛选出非IN状态的残差，并把他们删除掉。出了FullSystem::optimize函数之后，执行FullSystem::removeOutliers函数，把Point的外点删除。
此函数中就是判断所有帧上的所有点，如果这个点的残差个数为0，那么他就要被删除掉了。所以从这里删除的判断条件来看，叫removeOutliers可能不是太恰当，可能叫removePointsNonRes，即删除没有残差的点更好一点。
下面细看这个函数中的实现步骤：
先把这个PointHessian加入到帧的前端点删除数组pointHessiansOut中，等待后面统一删除。设置这个前端PointHessian对应的后端EFPoint状态为PS_DROP，给后面后端删除EFPoint使用。然后把这个点从帧的点数组中删掉，注意这里还没有delete释放这个PointHessian的内存，只是把它加入到了外点数组中。调用EnergyFunctional::dropPointsF把后端的点删掉。此函数中调用removePoint，该函数中会先把这个EFPoint对应的所有EFResidual删掉，然后把这个点从能量帧的点能量数组中删掉，最后把这个delete这个能量点释放内存。 注意：从上面两步可以看出来，这里的代码设计还是有点瑕疵的，因为删除前端的点之后没有释放内存，而是等待后面统一释放。而删除后端的点则释放了内存，前后端的操作不统一了。
7.28最新想法：可能作者是故意这样设计的，因为看代码中显示部分好像有删除点的数组相关的内容，所以就是把这些点存到数组中来显示历史上的所有点？
7.29最新想法：这个其实是没有问题的，确实是作者有意为之，而且原因也就是删除的点还要被使用。因为上面也说了，要删除的PointHessian指针被放到了前端点的删除数组pointHessiansOut中，后面要给显示线程使用。即然被放到了这个数组中，自然这个指针就不能释放了，否则这个数组中存的就都是野指针了。而把这些点从正常使用的前端点数组pointHessians中弹出，就意味着以后肯定无法再使用这个点了，因此从系统功能上已经实现了删除这个点的目的。而对于后端来说，既然这个点被删除了，那么我后端优化肯定就不会使用它构造H/b了，因此完全可以把这个点能量EFPoint完全从内存中抹去。
2.2.边缘化时删除哪些点？ 如上述所说，在FullSystem::optimize中后端迭代优化完成后，会根据最新的状态把所有残差重新线性化一次，同时筛选出非IN状态的残差，并把他们删除掉。出了FullSystem::optimize函数之后，执行FullSystem::removeOutliers函数，把哪些没有残差的Point删除掉。
接下来系统就进入了边缘化的阶段，首先是判断哪些点要边缘化掉，这样就会利用这些点构成的残差计算一个H/b，然后把这些点的逆深度Schur消元掉，只保留68x68的相机状态。然后下面对关键帧进行边缘化，再把这个H/b消掉一个相机帧得到维度缩减的HM/bM，从而给下一帧使用。
那么如何判断哪些点要被边缘化掉或者直接丢掉呢？在函数FullSystem::flagPointsForRemoval中实现这些功能。这个函数中选择要边缘化或者删除的点，只有两个根据：
（1）即将被边缘化的帧上的点：显然帧都没了，帧上的点肯定也不能再存在了。所以如果这个点性质比较好（比如多次构成的残差足够多、优化的逆深度协方差足够小），那么就把它边缘化掉，从而给后面的帧形成约束；如果这个点的性质不好，那么就直接把它丢掉，而不能边缘化，因为这样可能会引入错误的约束；
（2）其他帧上的点根据性质判断：即代码中的PointHessian::isOOB函数，内部会判断非边缘化帧上的点是否要被选择边缘化或者丢弃，这部分判断准则还不是很明白。
筛选出来这些点之后，在代码中就是对这些点进行处理，要么边缘化，要么直接丢掉。而如果一个点既不是外点，也不是要边缘化/丢掉的点，那么它就是正常的点，会继续存在于滑窗中，因此对它不进行任何处理，这就是为什么 代码 中elseif后面没有else了，也就相当于一个空的else，即如果是else则什么也不干。
最后注意：跟优化之后接着删除点一样，也上面的函数里面也是只把要丢掉的前端点PointHessian放到了删除数组中，并且从使用数组中弹出，这样就是完成了前端点的删除。而后端的对应的能量点在这个函数中没有释放，所以还要再释放后端的能量点，但是这个释放放在了FullSystem::flagPointsForRemoval函数外面去调用，这是我觉得不太好的地方，放在该函数里面调用更好。而且这个函数命名也不准确，我觉得命名为MarginOrDropPoints更好，也就是边缘化或者丢掉点。同理应该把后面的ef-&gt;marginalizePointsF();函数也一并放进里面调用，实际就完成了整个点的边缘化。这样拆开反而逻辑没有那么清晰了。
3.帧FrameHessian的管理 在上一步边缘化掉点之后，得到了这些点的残差构成的HM/bM矩阵，但是这个矩阵中仍然是含有要被边缘化掉的帧的状态的，因此还要对这个HM/bM进行Schur消元得到消元之后维度缩减的HM/bM，给下次滑窗优化使用。
在后端对边缘化的帧进行Schur消元之后，还有一个步骤需要做，那就是把其他帧上以被边缘化掉的帧为target帧的那些点的残差删掉，这个也是很正常的，因为这帧没有了，自然其他帧上的点和这帧关联的残差也就没有了。注意这个不是说其他帧上的点也不用了，这些点还是和别的帧可以构成残差的，所以这个和边缘化/丢掉点是不同的，这个是对仍然存在于滑窗中的点的残差进行处理。
而删除点的某个残差，则跟上面1.3节讲述的一样了，那就是先dropResidual删掉后端残差，再deleteOut删除前端残差。
把残差处理完了，就要删除这个帧了，调用deleteOutOrder函数把这个帧从FullSystem的帧数组中弹出，这就保证了它不会在FullSystem中再被调用参与滑窗优化了，但是不会释放它的内存。这个跟PointHessian的删除逻辑是一样的，本质上是因为这个FrameHessian的指针在优化之前已经被加入到allFrameHistory里面了，如果在这里把指针释放了，那么allFrameHistory里面存的就是野指针了。
由于删除了滑窗中的一个关键帧，所以需要调用setPrecalcValues函数重新计算各个帧的线性化点状态、最新状态、状态增量等变量，然后还要调用ef-&gt;setAdjointsF重新计算各个帧之间的伴随矩阵。至此，帧边缘化的操作全部完成。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99b1bc8d032c313aeb07059f66847e2d/" rel="bookmark">
			【前端｜JS实战第1篇】使用JS来实现属于自己的贪吃蛇游戏！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
贪吃蛇游戏是经典的小游戏，也是学习前端JS的一个很好的练习项目。在本教程中，我们将使用 JavaScript 来逐步构建一个贪吃蛇游戏。我们会从创建游戏区域开始，逐步添加蛇的移动、食物的生成以及游戏逻辑等功能。
🚀 作者简介：程序员小豪，全栈工程师，热爱编程，曾就职于蔚来、腾讯，现就职于某互联网大厂，技术栈：Vue、React、Python、Java
🎈 本文收录于小豪的前端系列专栏，后续还会更新前端入门以及前端面试的一些相关文章，手把手带你从零学习前端到面试找工作，并如果有想进入前端领域工作的同学，这个前端专栏会对你有所帮助，欢迎关注起来呀
🌼 本人也会持续的去关注AIGC以及人工智能领域的一些动向并总结到博客中，大家感兴趣的可以关注一下我的人工智能专栏
🌊 云原生的入门学习系列，大家有兴趣的可以看一看
步骤1：创建文件 我们需要创建三个文件index.html、styles.css、script.js，index.html用于放置我们界面dom，styles.css用于开发样式，script.js用于放置实现贪吃蛇的逻辑。
步骤2：创建游戏区域 首先，我们需要一个游戏区域来展示游戏。在 HTML 文件中创建一个 元素，用于表示游戏区域。然后，使用 CSS 来设置该元素的样式，使其成为一个矩形的游戏画布。 &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;贪吃蛇游戏&lt;/title&gt; &lt;link rel="stylesheet" href="styles.css"&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="game-area"&gt;&lt;/div&gt; &lt;script src="script.js"&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; /* styles.css */ .game-area { width: 400px; height: 400px; border: 2px solid #000; } 可以看到，我们在styles.css设置了这个游戏区域的宽度和高度为400px，还设置了一个2px的黑色边框
步骤3：初始化蛇的位置 在 script.js 文件中，我们将初始化蛇的初始位置。定义一个表示蛇身的数组，每个元素代表蛇的一个部分，然后设置蛇的初始位置。
// script.js const gameArea = document.querySelector('.game-area'); const snake = [{ x: 2, y: 2 }]; // 初始位置 // 初始化蛇的位置 function initializeSnake() { snake.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/99b1bc8d032c313aeb07059f66847e2d/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/98/">«</a>
	<span class="pagination__item pagination__item--current">99/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/100/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>