<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9cd150e62353f4624b07c9051dfa3da8/" rel="bookmark">
			jasperreports导出PDF时中文数据不现实的问题！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		jasperreports导出PDF时中文数据不现实的问题！ 问题说明解决办法最终结果 问题说明 首先，当我们运行完代码后，我们导出的pdf，其中中文部分显示的是空白只是显示的数据，所以我们需要进行配置。因为JasperReports默认情况下对中文支持并不友好，需要我们自己进行修复。
解决办法 1、看下面的截图哈，重要的看下面的两个文件，注意：这两个文件一定要在resource文件夹下，不能在static文件夹下。需要此文件的话可以加我。或者有不懂得地方。
2、首先我们在设计的时候，我们一定要设计他们的字体一定要是 中华宋体，因为我们的配置文件中设计的字体就是 中华宋体。
3、最后我给上大家上面的三个文件的代码或者是大家找我要文件。
font.xml &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;fontFamilies&gt; &lt;fontFamily name="华文宋体"&gt; &lt;normal&gt;stsong/stsong.ttf&lt;/normal&gt; &lt;bold&gt;stsong/stsong.ttf&lt;/bold&gt; &lt;italic&gt;stsong/stsong.ttf&lt;/italic&gt; &lt;boldItalic&gt;stsong/stsong.ttf&lt;/boldItalic&gt; &lt;pdfEncoding&gt;Identity-H&lt;/pdfEncoding&gt; &lt;pdfEmbedded&gt;true&lt;/pdfEmbedded&gt; &lt;exportFonts&gt; &lt;export key="net.sf.jasperreports.html"&gt;'华文宋体',Arial,Helvetica,sans-serif&lt;/export&gt; &lt;export key="net.sf.jasperreports.xhtml"&gt;'华文宋体',Arial,Helvetica,sans-serif&lt;/export&gt; &lt;/exportFonts&gt; &lt;/fontFamily&gt; &lt;/fontFamilies&gt; stsong.ttf 这个是字体的文件，不是代码所以不能复制代码，只能你们加我给我要文件 stsong.ttf net.sf.jasperreports.extension.registry.factory.simple.font.families=net.sf.jasperreports.engine.fonts.SimpleFontExtensionsRegistryFactory net.sf.jasperreports.extension.simple.font.families.lobstertwo=stsong/fonts.xml 最终结果 这样就最终的结果能成功显示了。
对于jasperresport的其他问题，大家也可以问我 。G654377984
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/114c923f0cc31fc71870e10e27b02b28/" rel="bookmark">
			记录一下2023.2kali的默认密码和修改root用户密码的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要水一篇博客了……
默认登录用户名/密码：
kali/kali
切换root用户：
sudo su
这时输入的密码是kali
然后就切换到了root用户
输入passwd root
提示修改新密码
根据提示输入两遍新密码就修改了root用户的密码啦
（感觉改不改的其实也……无所谓，重要的是一开始切换root时用的密码是kali，而不是root、toor、123456这些……
如图所示，切换root和修改密码：
补充个背景：
大概就是今天无聊，就想给新已经买了两个多月的电脑在虚拟机里装个kali（天呐我怎么这么摆
然后就去https://www.kali.org/get-kali/#kali-platforms看了看，才发现官方居然有那种已经配置好的kali虚拟机哎，而且看上去还文件还更小，是2.7G，而iso文件则是3.6G，好奇想试试官方配置好的虚拟机是什么样子（图省事）。
然后就下载了kali的VMware虚拟机，下载得到文件kali-linux-2023.2-vmware-amd64.7z，解压后，点击VMware里的“打开虚拟机”，找到解压后的文件夹中的kali-linux-2023.2-vmware-amd64.vmx文件，打开就可以直接用了，并且已经安装了VMware Tools，存在的问题就是磁盘分配空间可能不足，这个以后出问题了再说吧（x
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b46e6af0581d3184d6bda9276c9b8675/" rel="bookmark">
			新版2021等启动unity包管理器本地服务器进程失败解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、问题
2、解决办法
最后我发现每个unity版本都有一个包管理器，也就是图中的路径，而且都是相同的路径，只是因为版本不同或多或少存在一些小差异，其他版本可以正常启动，就2021不行会不会是2021的包管理器这个文件夹出现了什么问题，抱着试一试的心态先是把2020的UnityPackageManager.exe替换到了2021里面发现还是不行，然后又把Server那整个文件夹里面的东西都复制到了2021的Server文件夹里面去然后就可以正常启动了。。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/475218d601f8faa4665c7ae20a867185/" rel="bookmark">
			INCA简明教程 - 0. 简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言简介1. Database2. Top Folder3. Workspace3.1 Project3.2 Hardware3.3 Experiment 4. 小结Reference 前言 INCA是属于ETAS旗下的一款基础产品，能够与其他试验平台，HIL系统等实现接口交互，具备全面的测试和标定功能，支持CCP或XCP等协议，可对标定数据进行管理，可用于数据采集、标定、ECU闪存编程ProF集成，可用于带图形策略数据显示示波器，界面自编程等功能。
常见的汽车标定工具，主要有INCA，CANape等。
其中，INCA主要适用于发动机的标定，CANape因为其与CANoe的紧密耦合，用于ADAS域控制器的集成场景较多。
但是，这并不意味着INCA不能作为ADAS域控制器的刷写、比较、集成工具；相反，在一些传统主机厂，为了使ADAS域控制器与发动机控制器使用同一套系统进行集成化管理，往往会将INCA作为公司的统一工具链进行相应的适配。
在网上一搜索，INCA的教程并不是很多。在我的刻板印象中，汽车工程师相较于程序员，开源精神是较为欠缺的。当然，各人有各人的选择，各得其所，善哉善哉。
文章中若有常识性错误，还望不吝指正！
简介 双击INCA，INCA界面主要由下面几块组成。
DatabaseTop FolderWorkspaceA2L+PTP/S19Experiment 以上部分都与INCA的标定流程紧密结合（见下图2）。
INCA标定的整体流程：
1. Database Database是所有文件夹和Workspace的根目录，它决定了文件的存放位置。一般我们创建一个Database后，便不再动它了。
1. 点击左上角Database 2. 点击New 3. 输入Database的名字，即可得到一个默认的界面 2. Top Folder Top Folder可以理解为项目的一个总文件夹，也称之为Root。在Top Folder下，你可以创建Folder（子文件夹）。Workspace可以存放在Top Folder或Folder中。
【Workspace的功能之后会提及】
1. 将鼠标放在Database Objects的空白处，右键 2. Add-&gt;Add Top Folder 3. 输入Top Folder的名字即可 3. Workspace Workspace是INCA的最基础模块，它囊括了Experiment、Project和Hardware的配置。
创建完Top Folder后，你需要一个Workspace让所有的因素set up。和编程的IDE一样，都需要一个Workspace来管理。
Workspace中包含Experiment、Project、Hardware和CDM Configuration
Experiment：你真正开始标定的主界面，也是你工作的区域。
Project：A2L+PTP，你的字典（A2L）和标定集成文件（PTP）的合集。
Hardware：控制器和你之间所连接的硬件与使用的协议。
CDM Configuration：比较标定的工具。
3.1 Project Project包含A2L和PTP。
在软件写好后，因为加密和编译的需要，需要生成16进制文件，也就是PTP文件。
在业界广泛使用的，有S19格式的文件，也称为Motorola32格式；也有hex格式，也称为Intel格式；PTP格式是INCA专属的一种格式。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/475218d601f8faa4665c7ae20a867185/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9f45da0988c6ffcd3d11cae3f3c6fb4/" rel="bookmark">
			使用plsql developer连接远程oracle数据库服务的办法（简单版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.安装plsql developer
2.安装oracle客户端软件,安装界面选择安装第二个管理员选项.然后下一步下一步就能安装成功.
3.Oracle客户端软件安装成功后点击开始,然后就会显示oracle目录项,打开配置和移植工具
4.选择Net Manager
5.双击服务命名文件夹,如果什么都没有,点击左上角绿色加号按钮,进行配置.
6.输入网络服务名,这个是本地自定义的,可以取任意名称.然后点击下一步.
7.选择TCP/IP(Internet协议)
8.填入你要访问的远程数据库所在主机IP,(以下主机名是我随意填的,以本地测试,然而我本地是没有安装oracle服务端的),以及提供访问所需要的端口号,一般是1521
9.点击下一步.注意下图的服务名是指你要连接的远程oracle的数据库实例名称.连接类型选择数据库默认设置,点击下一步.
10.点击测试
11.可能会弹出以下界面.那是因为用户名密码还没有改,测试的用户名和密码是默认的scott/tiger.你需要改成你自己远程连接的数据库用户名以及密码.
12.点击更改登录
13.输入正确的用户名和口令,点击确定
14.再次点击测试,发现连接成功了.然后点击关闭.
15.然后注意,一定要点击完成,否则你刚刚的配置就不会被保存
16.双击服务命名,发现有一个配置orcl.右边就是你配置的主要信息.如果还需要另外的配置继续添加即可.
17.其实以上操作,等同于向C:\software\oracle_client\install_dir\product\11.2.0\client_1\network\admin文件夹内写入了一个tnsnames.ora的配置文件,可以尝试一下,之前这个目录下是没有这个配置文件的,你只要做了以上的配置,该文件夹下就会多出一个这个配置文件.
18.接下来,就可以使用PLSQL Developer工具连接远程的oracle数据库了.
19.然后就可以连接上,远程的oracle数据库了.
20.然后就可以简单的进行数据库的基本操作了,File -&gt; New -&gt; SQL Window.进入sql窗口
21.在SQL窗口可以输入sql语句进行基本的操作
22.点击菜单栏的session,然后选择Execute执行即可.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65a816f391b340dc3d8cb76776259508/" rel="bookmark">
			redission的看门狗机制及应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		redission看门狗机制是解决分布式锁的续约问题。
Redisson是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务，其中就包含了各种分布式锁的实现。
1.什么是redission的看门狗？ Redisson提供的分布式锁是支持锁自动续期的，也就是说，如果线程仍旧没有执行完，那么redisson会自动给redis中的目标key延长超时时间，这在Redisson中称之为 Watch Dog 机制。默认情况下，看门狗的检查锁的超时时间是30秒钟，也可以通过修改Config.lockWatchdogTimeout来另行指定。
RLock lock = redissonClient.getLock("guodong"); // 拿锁失败时会不停的重试 // 具有Watch Dog 自动延期机制 默认续30s 每隔30/3=10 秒续到30s lock.lock(); // 尝试拿锁10s后，没有Watch Dog lock.lock(10, TimeUnit.SECONDS); // 尝试获取锁，参数分别是：获取锁的最大等待时间(期间会重试)，锁自动释放时间，时间单位 // 尝试拿锁10s后停止重试,返回false 具有Watch Dog 自动延期机制 默认续30s boolean res1 = lock.tryLock(10, TimeUnit.SECONDS); // 没有Watch Dog ，10s后自动释放 lock.lock(10, TimeUnit.SECONDS); // 尝试拿锁100s后停止重试,返回false 没有Watch Dog ，10s后自动释放 boolean res2 = lock.tryLock(100, 10, TimeUnit.SECONDS); 2.源码解读 需要注意的是：
watchDog 只有在未显示指定锁自动释放时间（leaseTime）时才会生效。（这点很重要）lockWatchdogTimeout设定的时间不要太小 ，比如我之前设置的是 100毫秒，由于网络直接导致加锁完后，watchdog去延期时，这个key在redis中已经被删除了。 在调用lock方法时，会最终调用到tryAcquireAsync。调用链为：lock()-&gt;tryAcquire-&gt;tryAcquireAsync,详细解释如下：
private &lt;T&gt; RFuture&lt;Long&gt; tryAcquireAsync(long waitTime, long leaseTime, TimeUnit unit, long threadId) { RFuture&lt;Long&gt; ttlRemainingFuture; //如果指定了加锁时间，会直接去加锁 if (leaseTime !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65a816f391b340dc3d8cb76776259508/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1879a9aa271ccacc0598ca78ea696f10/" rel="bookmark">
			kxdpgun ——AF_XDP使用的示例分析（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		收/发包流程 RX, TX, FILL, COMPLETION RING的工作原理 用户空间的UMEM中包括4个环形队列RX, TX, FILL, COMPLETION RING，每个都以producer-consumer的方式工作，即每个环形队列存在一个producer和一个consumer（xdpsocket被单个线程管理的情况下），producer向队列中写内容，并让prod指针向后移动，consumer从队列中取内容，并让cons指针向后移动。下面介绍各个RING的作用。
这4个RING放置的都是UMEM frame的地址，而不是内容本身，这些frame称为desc，用于承载报文。
FILL RING的producer是用户程序，consumer是XDP内核程序，用户将可用的desc地址放入FILL RING，XDP程序将接收到的报文放到FILL RING中取得的desc中。RX RING的producer是XDP内核程序，consumer是用户程序，存放接收到的报文的desc的地址。TX RING的producer是用户程序，consumer是内核，存放用户要发送的报文的desc地址。COMPLETION RING的producer是内核，consumer是用户程序，内核发送完成后将desc放入COMPLETION RING中，用户程序消耗以示确认。 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-8YIkBMNX-1688993629858)(af_xdp/rings.jpg)]
发送流程 按上文所述，用户要发送一个报文，首先在某个空闲desc中写入报文内容，然后放入TX RING中，发送完成后读取COMPLETION RING确认。knot将这个过程包装到三个函数中
void knot_xdp_send_prepare(knot_xdp_socket_t *socket); int knot_xdp_send(knot_xdp_socket_t *socket, const knot_xdp_msg_t msgs[], uint32_t count, uint32_t *sent); int knot_xdp_send_finish(knot_xdp_socket_t *socket); send_prepare首先xsk_ring_cons__peek(cq, UINT32_MAX, &amp;idx);从COMPLETION RING中取出所有未取出的desc，将这些desc放入tx栈管理（前文提到的）
void knot_xdp_send_prepare(knot_xdp_socket_t *socket) { if (socket == NULL || unlikely(socket-&gt;send_mock != NULL)) { return; } struct kxsk_umem *const umem = socket-&gt;umem; struct xsk_ring_cons *const cq = &amp;umem-&gt;cq; uint32_t idx = 0; //peek出completion ring中的所有未取出desc const uint32_t completed = xsk_ring_cons__peek(cq, UINT32_MAX, &amp;idx); if (completed == 0) { return; } assert(umem-&gt;tx_free_count + completed &lt;= FRAME_COUNT_TX); for (uint32_t i = 0; i &lt; completed; ++i) { //依次计算未取出index的相对地址（相对umem起始地址的） uint64_t addr_relative = *xsk_ring_cons__comp_addr(cq, idx++); //将completion ring返回的desc放回空闲tx栈中 tx_free_relative(umem, addr_relative); } //将已处理完成的desc释放掉 xsk_ring_cons__release(cq, completed); } knot_xdp_send函数首先调用xsk_prod_nb_free查看tx中有没有足够的空闲单元，然后向tx ring中写入msg不为空的报文，最后调用xsk_ring_prod__submit提交写操作。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1879a9aa271ccacc0598ca78ea696f10/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4e7ecd50d09dd4c89cb99c119d43679/" rel="bookmark">
			CAN,RS485,RS422端接，以及波形电压
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1，CAN电路 CAN总线终端电阻，一般来说都是120欧姆，实际上在设计的时候，也是两个60欧姆的电阻串起来，而总线上一般有两个120Ω的节点；
CAN的接口电路和RS485的十分类似，不同的地方只是：
1.收发器不同；
2.CANH和CANL上无需上下拉电阻，即无需R7、R8、R9电阻；
3.CANH和CANL之间不能加TVS管，只能各自对地加TVS管，或者用我们公司代理的PESD1CAN的ESD保护器件；
4.CANH和CANL对地电容尽可能小，大约各为30pF；
5.CAN没有流向控制端
2、基本的RS485电路 图3 典型的RS485接口电路
TBU 浪涌抑制器选用TUB-CA065-200-WH, GDT 防雷管选用2031-23T-SM-RPLF , TVS选用SMBJ6.8CA_C383713。 R12,R13 选100K，R14选120欧。
什么时候需要加终端电阻？
1、通信速度低或者通信距离近的情况下建议不加终端电阻
通信速度低或者通信距离近的情况下，信号反射对通信信号的影响不大，而且不加终端电阻可以大大降低功耗，并且通过加较大上下拉电阻值即可保证RS-485总线空闲时具有较高的差分电压幅值，提高了通信的可靠性。
2、通信距离较长且通信速度较快，对信号质量要求较高的情况
此时可以增加终端电阻，防止阻抗突变引起的信号反射问题，提高信号质量，但应确保在总线空闲时总线的差分电压不处于门限电平范围内。
如何解决增加终端电阻后空闲状态的问题？
对于空闲状态的问题有两个解决方法：
可以通过在外部增加较小的上下拉电阻将RS-485总线的空闲状态时的电压拉到+200mV以上（一般要留有100mV或200mV以上的裕量），保证空闲时RS-485总线差分电压不处于门限电平范围内，但上下拉电阻值不能太小，一般总线上拉（或下拉）并联值要大于375Ω。
3，典型RS422电路 R1和R2为上拉电阻，防止误触发，产生误动作；是因为“UART以一个前导“0”触发一次接收动作”。
R3-6是故障安全偏置电阻，取值大小与所用电源大小呈正比。
R7是差分信号接收端端接电阻，取值等于传输线的特征阻抗。因RS422常用接口是RJ45，常用传输线是网线，其阻抗约为120 Ω，故而此处端接电阻取值为120 Ω。
RS232，RS485和TTL电压差和波形 TTL空闲状态，电压是高；
RS232空闲状态是低电平；
https://dreamsourcelab.cn/articles/uart/
一文搞懂：UART、RS-232、RS-422、RS-485的区别
https://blog.csdn.net/monkey_D_xue/article/details/127884663?utm_medium=distribute.pc_relevant.none-task-blog-2defaultbaidujs_baidulandingword~default-1-127884663-blog-47709675.235v38pc_relevant_anti_t3_base&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=4
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/177bb127004c744e8136b5e2523f0ad1/" rel="bookmark">
			Scala中使用 break 和 continue
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Scala中没有 break 和 continue 关键字，但是我们可以用 Breaks 类提供的相应方法来实现对应功能。
在Java中，break continue return的区别 1、break：break不仅可以结束其所在的循环，还可结束其外层循环，但一次只能结束一种循环。
2、continue：continue结束的是本次循环，将接着开始下一次循环。
3、return：return同时结束其所在的循环和其外层循环。
代码示例： int[] arr = {11,22,33,44,55,66,77,88,99,00}; for(int i = 0;i &lt; arr.length;i++){ switch(arr[i]){ case 33: System.out.print("第"+(i+1)+"次输出" + " "); break; // continue; // return; } System.out.print(arr[i] + " "); 结束当前循环，开启下一次循环。 import scala.util.control.Breaks object Solution { def main(args: Array[String]): Unit = { for (i &lt;- 1 to 5) { Breaks.breakable { if (i == 4) Breaks.break() println(i) } println("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/177bb127004c744e8136b5e2523f0ad1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65315de8aaf863c6bae8cf373e47f9cd/" rel="bookmark">
			Flutter随记七：Json数据与Dart对象转换详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、JsonToDart工具
二、使用示例
三、其他转换方式
一、JsonToDart工具 本文讲使用JsonToDart​​​​​​​在线工具将本地Jsons文件转成Dart对象，再放入工程中。
二、使用示例 1、MYJSON.json测试数据结构下面这样的。
{ "body": { "code": "0000", "data": { "msPropcircleworkList": [{ "articletitle": "测试数据一！", "articletags": "冒险,极限" }, { "articletitle": "测试数据一", "articletags": "旅游,美食" }, { "articletitle": "测试数据三", "articletags": "文学,美食" }, { "articletitle": "测试数据四", "articletags": "古玩,美食" }] } } } 2、引入的tuiJianArticleObject.dart就是转化后的Dart对象文件。
import '../Pages/tuiJianArticleObject.dart'; 3、tuiJianStackItem() 该方法获取本地MYJSON.json文件。
Future&lt;Data&gt; tuiJianStackItem() async { var value = await rootBundle.loadString('images/MYJSON文件.json'); Map&lt;String, dynamic&gt; articleM1 = json.decode(value); // return msPropcircleworkListM = articleM1['body']['data']; TuiJianArticleObject objet = TuiJianArticleObject.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65315de8aaf863c6bae8cf373e47f9cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b795e742c539659b39bc233c2ef369b3/" rel="bookmark">
			【python】二叉树的 层次遍历 &amp; 列表表示法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		全文一览 一、创建二叉树二、层次遍历2.1 代码详解2.2 简洁写法 三、列表表示法3.1 规则说明3.2 代码实现 二叉树中除了前序、中序、后序遍历外，还有一种 从上到下、从左到右的层次遍历方法。这种方法更符合人视觉的直观感受，在计算树的最大深度、返回最外层叶节点、返回二叉树的列表表示等场景有着优秀的性能。 列表表示法是二叉树图示方法外最为重要的表示方法，可以通过层次遍历实现。 一、创建二叉树 参考二叉树的创建，构建一个二叉树：
class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right node4 = TreeNode(1) node5 = TreeNode(4) node6 = TreeNode(6) node7 = TreeNode(9) node2 = TreeNode(3, node4, node5) node3 = TreeNode(7, node6, node7) node1 = TreeNode(5, node2, node3) root = node1 二、层次遍历 2.1 代码详解 如果 root 节点为空，则返回空列表。Level、Next 分别记录当前层节点和下一层节点。Vals、Res 分别记录当前层的值和所有层的值。Res 是 Vals 的累加。循环当前节点 Level，可以获得当前层的值 Vals 和下一层的节点 Next 。当 Next 为空时，结束遍历，退出 while 循环，返回 Res 二维数组。 def levelTraversal(root): if not root: return [] Level = [root] # 当前遍历层 Res = [] # 层次遍历返回结果 while True: Vals = [] # 当前层节点的值 Next = [] # 下一层的节点 for node in Level: Vals.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b795e742c539659b39bc233c2ef369b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1c78faf10896b5c5ae3e404507a72f9/" rel="bookmark">
			Linux驱动进阶(二)——设备驱动中的阻塞和同步机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言阻塞与非阻塞等待队列等待队列概述等待队列的实现等待队列的使用 同步机制实验同步机制设计实验验证 小结 前言 阻塞和非阻塞是设备访问的两种基本方式。使用这两种方式，驱动程序可以灵活地支持阻塞与非阻塞访问。在写阻塞与非阻塞的驱动程序时，经常用到等待队列，所有本章将对等待队列进行简要介绍。
阻塞与非阻塞 阻塞调用是指调用结果返回之前，当前线程会被挂起。函数只有得到结果之后才会返回。有人也许会把阻塞调用和同步调用等同起来，实际上它们是不同的。对于同步调用来说，很多时候当前线程还是激活的，只是从逻辑上当前函数没有返回而已。
非阻塞和阻塞的概念相对应，指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。对象是否处于阻塞模式和函数是不是阻塞调用有很强的相关性，但并不是一一对应的。阻塞对象上可以有非阻塞的调用方式，我们可以通过一定的API去轮询状态，在适当的时候调用阻塞函数，就可以避免阻塞。而对于非阻塞对象，调用特殊的函数也可以进入阻塞调用。函数select()就是这样的一个例子。下面是调用select()函数进入阻塞的一个例子。
void main() { FILE *fp; struct fd_set fds; struct timeval timeout={4, 0}; //select()函数等待4s，4s后轮询 char buffer[256]={0}; //256字节的缓冲区 fp = fopen(....); //打开文件 while(1) { FD_ZERO(&amp;fds); //清空集合 FD_SET(fp, &amp;fds); //同上 maxfdp=fp+1; //描述符最大值加1 switch(select(maxfdp, &amp;fds, &amp;fds, NULL, &amp;timeout)) //select函数使用 { case -1: exit(-1); break; //select()函数错误，退出程序 case 0: break; //再次轮询 default: if(FD_ISSET(fp, &amp;fds)) //判断是否文件中有数据 { read(fds, buffer, 256, ...); //接受文件数据 if(FD_ISSET(fp, &amp;fds)) //测试文件是否可写 fwrite(fp, buffer...); //写入文件buffer清空 } } } } 等待队列 本节将介绍驱动程序编程中常用的等待队列机制。这种机制使等待的进程暂时睡眠，当等待的信号到来时，便唤醒等待队列中进程继续执行。本节将详细介绍等待队列的内容。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d1c78faf10896b5c5ae3e404507a72f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67821b0c9106657e96e14ffc9431c697/" rel="bookmark">
			Java个人财务管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：这个项目为个人用于Java大作业时所编写的项目，后端使用了Springboot+Mybatis，前端使用了Vue、Axios、Element UI、Echarts来进行数据的发送、接收以及页面的渲染。
功能描述
1、注册登录：用户可以免费注册获得属于自己的财务管理系统，可以更加安全方便的管理自己的财务。
2、收入与支出信息的操作：用户可以对新增收入、支出信息，可以对已有的信息进行删除、修改，也可以根据关键字、收入类型、收入时间、备注关键字等进行快速的搜索相应的收入、支出信息。
3、统计报表：系统拥有日统计、月统计、年统计报表的汇总，用户可以在其相应的页面中可以修改相应的时间，可以查看不同时间段的数据，可以根据报表的结果进行合理的规划自己的财务。
数据库表结构 共有三个表，其中收入与支出表为主要维护表。
项目结构 相关功能展示图 基本的登录注册功能，比较简陋，没当做重点来做。
收入与支出界面相同，功能相同。可以对数据进行增添、删除、批量删除、修改（有数据回显）、复合条件查询、分页。以上功能均实现。
统计报表中可以对日、月、年进行统计。用户可以选择指定的时间段进行数据统计。
程序源码 链接：https://pan.baidu.com/s/1y0O2voiP7zV-NdgabdloEA?pwd=jvlx 提取码：jvlx
调好就是你的,成功了记得点个赞喔！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70cd98d273bd74ce5b62fd619008feee/" rel="bookmark">
			9篇论文速览域自适应、域泛化最新研究进展
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		域自适应作为迁移学习的一种方法，主要解决源域与目标域之间分布不同的相似任务决策问题，但域自适应问题要求取得目标域的有标注或无标注数据，这与真实场景具有较大的区别。域泛化则是研究这一问题的有效方法，它希望模型能够学到域无关的特征，这种特征可以容易地泛化到新的测试数据域上。
作为一直以来各大顶会的热门方向，今年关于域自适应和域泛化的高质量论文数量也是相当客观，所以我又来做分享了。
这次收集了9篇机器学习顶会ICML域自适应/域泛化相关的 poster 论文，资料已打包，PDF+代码都整理了，文末领取
1.On Balancing Bias and Variance in Unsupervised Multi-Source-Free Domain Adaptation 这篇文章研究了无源域 adaptation 的机器学习技术。
由于隐私、存储等限制，不访问源模型训练数据的无源域 adaptation 技术日益重要。现有的多源无源域 adaptation (MSFDA) 方法通常使用源模型生成的伪标签数据训练目标模型，主要关注提升伪标签技术或设计新的训练目标。
本文试图分析MSFDA的基本极限，具体而言，作者开发了目标模型泛化错误的信息理论下界，该下界阐明了一个固有的偏差-方差权衡，然后从3个方面提供平衡该权衡的洞见：域聚合、选择性伪标记、联合特征对齐，这导致了新算法的设计。
在多个数据集上的实验证明，作者所提出的算法具有最先进性能，特别是在一些最具挑战性的数据集上，包括Office-Home和DomainNet。
2.Sequential Counterfactual Risk Minimization 这篇文章探索了反事实风险最小化(CRM)在可以多次部署学习策略并获得新数据的场景下的应用。
CRM是处理logged bandit反馈问题的一个框架，其目标是用离线数据改进日志策略。作者将CRM原理和理论扩展到可以多次部署策略并获得新数据的场景，称为“顺序CRM(SCRM)”。
作者提出了一个新的反事实估计器，并确定了一些条件，这些条件可以通过类似于加速优化方法中的重启策略的分析来改进CRM的过剩风险和后悔率。在离散和连续动作设置中对该方法进行了经验评估，证明了多次部署CRM的好处。相比仅进行一次CRM，SCRM可以在一定条件下获得更低的过剩风险和更快的后悔率收敛速度。
​3.Provably Invariant Learning without Domain Information 作者研究了无需环境信息的环境无关不变性学习，以提高模型的鲁棒性。
典型的机器学习应用都假设数据满足独立同分布(IID)，但这个假设在真实世界中常被违反，导致了分布偏移(OOD)概化问题和模型鲁棒性大幅下降，不变性学习技术被利用来区分输入特征中的偶发性特征和不变性特征，并仅依据不变性特征训练模型。许多不变性学习方法需要训练数据包含域信息，如环境索引或先验知识获得的辅助信息。但是获得这些信息在实践中通常不可能。
本文提出了TIVA，一个无需环境特定信息的环境无关不变性学习方法。在某些轻度数据条件下，可以训练一个基于与目标无关的属性的环境划分策略，然后进行不变性风险最小化。在多个基准测试中，与其他基线方法相比，该方法展示了在OOD下的卓越性能和优异的鲁棒性。
4.Taxonomy-Structured Domain Adaptation 这篇文章研究了具有层次分类结构的域的域自适应问题。
传统的域自适应方法大多局限于分类域，过于简化了现实世界中的细致的域关系。本文针对具有分类法结构的域，将域形式化为具有嵌套分层相似性结构的域，如动物物种和产品目录。
基于经典的对抗框架，作者提出了一个新的分类法专家，与对抗判别器竞争以保留分类法信息。如果给定非信息性的域分类法(如所有叶节点连接到根节点的平坦分类法)，则平衡恢复经典对抗域自适应的解决方案；对其他分类法给出非平凡的结果。在合成和真实世界数据集上的实验中，本方法实现了状态最优的性能，并成功实现了自适应。
5.Generalization Analysis for Contrastive Representation Learning 对比学习在各种机器学习任务中都展示了极佳的性能，但现有的泛化分析很有限甚至没有意义。现有的泛化误差界与负样本数k线性相关，但实践中经常需要很大的k来保证对比学习在下游任务中的泛化。
本文建立了与k无关的对比学习泛化误差界，对数项除外，分析利用了经验覆盖数和Rademacher复杂度的结构结果，利用了损失函数的Lipschitz连续性。对于自定界的Lipschitz损失函数，进一步通过乐观界发展了快速率的结果，适用于低噪声条件。本文将结果应用于线性表示和基于深度神经网络的非线性表示，都导出了Rademacher复杂度界来获得更好的泛化界，因此本文的分析改进了对比学习的泛化理论。
6.Moderately Distributional Exploration for Domain Generalization 作者提出了一个称为MODE的方法，用于提高域泛化的性能。
域泛化目的是处理训练域和未知目标域之间的分布变换，生成新域是最有效的方法之一，但其性能提升依赖于生成域和目标域之间的分布差异。分布鲁棒优化通过在一个不确定集中探索域来处理分布差异，这很有前景。但是，不确定集可能非常大，导致域泛化中的低置信度预测。这是因为一个大的不确定集可能引入语义上不同的因素，与训练域不同。为解决这个问题，作者提出进行适度分布探索(MODE)用于域泛化。
具体而言，MODE在一个与训练域共享相同语义因素的不确定子集中进行分布探索。实验证明，MODE可以赋予模型在未知目标域上有可证明的泛化性能。
7.Distribution Free Domain Generalization 这篇文章提出了一种称为DFDG的分布自由域泛化方法，以提高对分布偏移数据的预测准确性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70cd98d273bd74ce5b62fd619008feee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8b6fce484401472cd35a891126ba679/" rel="bookmark">
			Linux 软链接的创建、修改和删除方法及注意事项
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		创建软链接 在 Linux 中，可以使用 ln -s [源文件] [软链接文件] 的命令来创建软链接。
首先，打开终端并进入目标路径，可以使用 pwd 命令查看当前路径。
使用 mkdir 命令创建一个名为 test 的目录，并使用 touch 命令在该目录下创建两个测试文件，分别为 test.txt 和 val.txt。
mkdir test touch test/test.txt touch test/val.txt 接下来，我们将创建一个指向 test 目录的软链接，可以使用以下命令：
ln -s test test_chk_ln 在完成软链接创建后，您可以使用 ll 或 ls -l 命令来查看所有文件，包括软链接。
ll 修改软链接 要修改软链接指向的源文件或目录，可以使用以下命令：
ln -snf [新的源文件或目录] [软链接文件] 确保替换 [新的源文件或目录] 和 [软链接文件] 为实际的路径和文件名。
删除软链接 在删除软链接时，请确保使用正确的方法，以避免误删关联的实际数据。
正确的删除方式（只删除软链接）：
rm -rf ./test_chk_ln 为了防止误删除，您可以询问是否删除软链接：
rm -ri ./test_chk_ln 错误的删除方式（会连带删除软链接指向的内容）：
rm -rf ./test_chk_ln/ 建议在执行任何删除操作之前，确认您要删除的是软链接还是实际的数据，并谨慎操作以避免数据丢失。
文章转载于：编程日志
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e119e38379461888bd0c01c091b96041/" rel="bookmark">
			手把手教你实现VuePC端，移动端适配
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.适配方案（amfe-flexible + postcss-pxtorem）
amfe-flexible：根据屏幕宽度，自动设置html的font-size
postcss-pxtorem：自动将px单位转换成rem
二.安装插件
​​​​​​​npm install postcss-pxtorem --save npm install amfe-flexible --save 三.在vue项目中main.js中引入lib-flexible
import 'amfe-flexible'; 四.配置postcss-pxtorem
可在vue.config.js、.postcssrc.js、postcss.config.js其中之一配置，权重从左到右降低，没有则新建文件，只需要设置其中一个即可
1、在vue.config.js配置如下
module.exports = { css: { loaderOptions: { postcss: { plugins: [ require('postcss-pxtorem')({ rootValue: 37.5, propList: ['*'] }) ] } } }, } 2、或在.postcssrc.js或postcss.config.js中配置如下：
module.exports = { "plugins": { 'postcss-pxtorem': { rootValue: 37.5, propList: ['*'] } } } 注意点：
（1）rootValue根据设计稿宽度除以10进行设置，这边假设设计稿为375，即rootValue设为37.5；
（2）propList是设置需要转换的属性，这边*为所有都进行转换。
五.补充
如果出现报错，请降低版本后重装依赖（在package.json文件中将版本修改为如下，然后终端运行命令npm install即可）
"dependencies": { "amfe-flexible": "^2.2.1", "postcss-pxtorem": "^5.1.1", }, 六.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e119e38379461888bd0c01c091b96041/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c2c93e04b947f8ebe4f0f868b54f1d9/" rel="bookmark">
			慢慢整理一下用到的游戏相关工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		朋友要个游戏的立绘，说没在网上没找到，让我帮忙提取一下。
一直都是这方面的小白，偶尔用工具提取一些素材。
这次受托，借机会想亲自开刀一下，可惜，未果。没能成功提取出哪怕一丁点的立绘。
不过提取别的老游戏倒是准确率挺高。
本次针对的是后缀是xp3数据文件的游戏。
不多说了，列举一下工具及下载地址吧。
1、XP3Viewer
这东东还是比较傻瓜的，能拆的游戏，基本上不用研究怎么拆，拖exe到XP3Viewer.exe上，就可以了，非常直观的操作。可惜的是对于未能提取的东东异常处理还是不足，不支持，你到是给个提示啊？ 下载地址：点击下载
注意：访问如果有密码，鼠标点击会自动填入密码。
2、大名鼎鼎的crass
用他拆了不少游戏了，里面还有支持的游戏列表，但是我要拆的是全年龄游戏。也许全年龄的做了特殊的封包和加密？用这个也是解不开。
下载地址：点击下载
注意：访问如果有密码，鼠标点击会自动填入密码。
3、xp3dumper_gui的0.3版本
网上大部分都是0.2的版本，我是没搞清楚两个版本之间的具体差别。看了版本说明，新增的功能我也是没用上。经过尝试，这个版本也解不开。
下载地址：点击下载 注意：访问如果有密码，鼠标点击会自动填入密码。
4、KrkrExtract
朋友要的立绘最终是用这个工具提取出来的
官网地址：GitHub - xmoezzz/KrkrExtrac
git下载很痛苦啊，下了N遍才下来。 所以附上已经下载好的版本，但是里面最新版本的KrkrExtract.exe被eset杀掉了，我不知道是不是真有毒，旧版本能用就好。
全部clone ，我用vs开了一下，感觉除了大神的代码，貌似VS给生成了什么。
反正我也不会，都丢过去吧，实在不想再下一遍了。没有VS基础的，不建议下这个源码了。 下载地址：https://u4352561.ctfile.com/fs/4352561-302246805
旧版本工具基本可用，只要不使用“系统(PNG)”就好。 旧版本下载地址（暂时失效，我找到旧版本再补上）：https://u4352561.pipipan.com/fs/4352561-302245903
5、格式工厂4.2 实在是没找到有小又好用的能够批量处理立绘背景透明的的工具，就用了这个。
下载地址：https://u4352561.ctfile.com/fs/4352561-302253792
注意：上面链接失效了，等找到好用的版本会进行更新。
6、Garbro
最后来介绍这个目前最省事的拆包工具：GARbro-v1.5.44.2904。
下载地址：https://url61.ctfile.com/f/4352561-749765757-75b658
注意：访问如果有密码，鼠标点击会自动填入密码。
这个工具工具化最为完善，只要在顶端填入游戏路径，选择路径内的各种文档文件，就可以预览文件中的资源。图片、脚本、音频、视频都可以。
但如果是没有支持的游戏，比如最近几年的新出的游戏，大概率是解不开的。
虽然软件版本很久没更新，但解码库还是会时不时的更新。主要国内连不上解码库的地址，这个我也没有办法。
============== 我是分割线 ======== 后记 ===============================
功夫不负有心人，我还真给提取出来了。可惜，不是朋友想要的那种，也许是他想多了.... 怎么可能会有光头的立绘....
用的是KrkrExtract。
KrkrExtract还在维护，但愿大神继续维护，不才完全看不懂，也编译不了大神的源码。
瞅着源码，处于懵逼的状态。
============== 还是分割线 ======== 再记 ===============================
感觉这个工具网站还不错，常用的开发工具基本都能找到
在线工具箱-考试|学习|办公资料分享-软件下载-网址导航-千寻收录网
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c55dc937338b8874d45ad2cdbcb35159/" rel="bookmark">
			go 进阶 限流相关: 一. time/rate限速器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一. 限流与time/rate基础WaitN实现超时取消示例ReserveN预定令牌示例使用示例 二. time/rate 底层原理相关Limiter 与 Reservation 结构消费令牌底层原理1. reserveN()方法逻辑2. advance()根据当前时间和上次更新时间计算桶中剩余的令牌数逻辑3. durationFromTokens()根据令牌数量tokens计算出产生该数量的令牌需要的时长4. tokensFromDuration()获取指定期间内产生的令牌数量 Wait 阻塞获取令牌CancelAt()取消令牌消费操作 三. 总结复习限流算法time/rate 总结 一. 限流与time/rate基础 golang内部基于令牌桶算法提供了一个限流器time/rate位于golang.org/x/time/rate在golang中,可以使用channel或者使用time/rate包实现并发控制, time/rate包是一个提供令牌桶算法的包，它可以实现对事件发生的速率进行限制和平滑,使用time/rate控制并发比使用channel控制并发的优点在于 time/rate只需要调用NewLimiter()函数,设置并发限制规则创建Limiter对象，然后在每个goroutine中调用Wait或者Allow方法来获取令牌即可,简单方便,channel需要创建一个缓冲区,然后在每个goroutine中通过向channel的缓冲区存放或获取数据来控制并发time/rate可以更灵活地控制并发的速率,可以根据令牌桶的容量和填充速度来调整并发的上限和平均值,而channel只能根据缓冲区的大小来控制并发的上限,不能控制平均值time/rate可以更容易地处理并发的异常情况，例如超时或者取消:提供了WaitN、Reserve、Context等方法来支持超时或者取消的场景,而channel需要额外的逻辑来处理超时或者取消，例如使用select语句或者context包 WaitN方法和Reserve方法都可以获取n个令牌,它们以后什么不同 WaitN方法会阻塞当前goroutine,直到获取到n个令牌,或者超时或者取消,它接收一个context参数,用于控制超时或者取消的行为,如果获取成功,它会返回nil,否则返回一个错误Reserve方法会预定n个令牌,返回一个Reservation对象用于表示预定的结果,Reservation对象提供了Delay方法,用于获取预定的延迟时间,以及Cancel方法用于取消预定。如果预定成功它会返回一个非nil的Reservation对象否则返回nil一般来说如果想要同步地等待令牌,或者不关心延迟时间,你可以使用WaitN方法,如果想要异步地等待令牌,或者想要知道延迟时间,你可以使用Reserve方法 time/rate常用的API概述: NewLimiter(r Limit, b int) *Limiter: 创建一个新的限流器，r表示每秒可以向令牌桶中产生多少令牌，b表示最大容量Limit() Limit: 返回限流器的最大事件频率Burst() int: 返回限流器的最大突发大小,即一次可以消费的最大令牌数1Allow() bool: 相当于AllowN(time.Now(), 1),表示是否可以消费一个令牌,可以返回true并消费一个令牌AllowN(t time.Time, n int) bool: 表示是否可以消费n个令牌,可以则返回true并消费n个令牌Reserve() Reservation: 相当于ReserveN(time.Now(), 1),表示预订一个令牌,并返回一个Reservation对象,该对象可以用来获取需要等待的时间或者取消预订ReserveN(t time.Time, n int) Reservation: 表示预订n个令牌,并返回一个Reservation对象Wait(ctx context.Context) (err error): 相当于WaitN(ctx, 1),表示等待直到可以消费一个令牌,或者通过ctx被取消WaitN(ctx context.Context, n int) (err error): 表示等待直到可以消费n个令牌,或者通过ctx被取消 预订的令牌时,返回的Reservation结构体上常用的API: Cancel(): 取消预订,将令牌归还给限流器CancelAt(t time.Time): 在指定的时间取消预订,将令牌归还给限流器Delay(): 返回需要等待的时间,相当于DelayFrom(time.Now())DelayFrom(t time.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c55dc937338b8874d45ad2cdbcb35159/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e55b615e35b4cfc60e2313e57ba0b3a2/" rel="bookmark">
			javascript中将对象转为字符串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、使用JSON.stringify() 方法 该方法将对象序列化为JSON字符串，示例
const obj = { name: "luoyan", age: 20, city: "China" }; const jsonString = JSON.stringify(obj); console.log(jsonString); 输出结果为
{"name":"luoyan","age":20,"city":"China"} 在这个例子中，JSON.stringify() 方法将 obj 对象转换为一个 JSON 字符串，并将结果存储在 jsonString 变量中。
请注意，JSON.stringify() 方法还可以接受其他参数，用于控制序列化过程。例如，可以传递一个数组来指定要序列化的属性，或者传递一个函数来自定义序列化的行为。
2、自定义方法：可以编写自定义的转换方法，将对象转换为特定的格式或逻辑。 const obj = { name: "luoyan", age: 20, city: "China" }; const convertToString = (object) =&gt; { return `Name: ${object.name}, Age: ${object.age}, City: ${object.city}`; }; const str = convertToString(obj); console.log(str); 输出
Name: luoyan, Age: 20, City: China 3、toString() 方法 许多内置对象类型（如 Date、Array 和其他自定义对象）都有一个 toString() 方法，可以将其转换为字符串。但是，默认情况下，Object 对象的 toString() 方法返回的是 [object Object]，而不是对象的详细信息。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e55b615e35b4cfc60e2313e57ba0b3a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45e10c459c375c58c6858466f6b30d2b/" rel="bookmark">
			AttributeError: module ‘skimage.morphology‘ has no attribute ‘watershed‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需要更新导入为from skimage.segmentation import watershed。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8691b4d001b46d4a9368db5783566cb/" rel="bookmark">
			springboot filter过滤器抛出异常，无法返回想要的数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 谷粒商城 这是一个关于token判断的过滤器，如果token异常直接抛出异常，我们期待的返回结果是 { "code": 2001, "message": "访问令牌不合法", "data": null } 直接抛异常却并不能返回我们自定义的异常，这种情况下需要写一个重定向，在重定向中抛出异常
httpRequest.getRequestDispatcher("/api/tokenerr").forward(httpRequest, httpResponse); 这样问题就解决了
如果不这样做的话，直接抛出异常会出现接口无法进入在浏览器直接爆红的情况，请求无法直接进入就异常了，这样接口就正常了 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac1ed60179dd288bae97b9e6555005f9/" rel="bookmark">
			如何使用ChatGPT辅助编程：通过引导自动生成编程代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		推荐：将 NSDT场景编辑器 加入你的3D工具链 大型语言模型基本上是一台可以理解和生成文本的机器。取决于它的训练方式，有时模型可以生成文本以外的内容。ChatGPT就是这样一个大型语言模型。如果您正确提示，它可以生成编程代码。在这篇文章中，您将学习如何使 ChatGPT 为您生成程序。具体来说，您将学习
如何使 ChatGPT 引导您的编程项目如何使用 ChatGPT 作为您的编程助手 让我们开始吧。
使用ChatGPT作为您的编程助手
作者使用稳定扩散生成的图片。保留部分权利。
概述 这篇文章分为两部分;它们是：
启动编程项目了解代码和生成函数片段 启动编程项目 让我们考虑一个简单的项目：你想要设置一个 REST API 服务器，它可以帮助你对提供的 URL 的整个网页进行“屏幕截图”。（可选）REST API 可以接受电子邮件地址的其他可选参数。在这种情况下，屏幕捕获不会返回，而是通过电子邮件发送出去。
这是一个涉及多个组件的项目。你需要一些可以像 REST API 服务器一样监听 HTTP 请求并做出相应响应的东西。您还需要一些东西来获取 URL 并像普通 Web 浏览器一样截取屏幕截图。其中还有一个逻辑，取决于是否提供了电子邮件地址;输出可以是返回的图像文件，也可以是发送带有附件的电子邮件。
如果您不熟悉如何创建 REST API 服务器或不知道可用的工具，可以向 ChatGPT 寻求帮助。只需在提示中写下所有细节并询问：
我需要创建一个 REST API 服务器，该服务器接受 URL 作为输入，将网页屏幕截图捕获为 JPEG 格式并将其作为输出返回。（可选）用户可以提供电子邮件地址作为附加输入。在这种情况下，屏幕截图应通过电子邮件发送而不是返回。你能帮我这个程序吗？ 有了这个，ChatGPT产生以下建议：
当然！我可以帮你。要创建捕获网页屏幕截图并处理可选电子邮件功能的 REST API 服务器，您可以使用 Node.js以及一些其他包。以下是您可以遵循的步骤的概述： 1. 设置一个新的 Node.js 项目并使用 npm 对其进行初始化： 1
2
3
mkdir screenshot-api
cd screenshot-api
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac1ed60179dd288bae97b9e6555005f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/363b2b3f340e078d5005c551de03c063/" rel="bookmark">
			误删除的文件夹怎么恢复
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在日常使用电脑时，误删文件夹是一种很常见的情况。尤其是在需要进行大量删除操作时，误删的概率更高。对于这种情况，许多人都会感到十分烦恼，误删除的文件夹怎么恢复?在这里，我们将介绍几种常用的文件夹恢复方法，帮助大家解决这一问题。
方法一：回收站恢复
删除文件夹时，它并不是立刻就从电脑上消失了，它会被放到回收站中。所以，我们可以先到回收站里面找一找被误删除的文件夹。如果能找到，直接右键选择“还原”就可以将其还原到原有的文件夹位置。
方法二：通过以前的版本恢复
如果误删的文件夹不在回收站里，也不用担心。我们可以在电脑中找到“以前的版本”，以此来恢复文件夹。这个方法就适用于误删的文件夹原来是在硬盘某个位置而不是在一个移动硬盘或者U盘上的情况。我们可以右键点击储存误删文件夹的硬盘驱动，在选项中找到“属性”选项，之后找到“以前的版本”选项，从列表中找到想要恢复的文件夹，右键选择“还原”就可以将其还原到原来的位置。
方法三：从备份中恢复
文件备份是一种可以有效防止数据丢失的方法。如果之前对重要文件夹进行了备份，那么可以通过备份文件中的数据来恢复文件夹。
1. 打开备份软件，找到之前备份的文件夹。
2. 双击该文件夹，从备份中找回误删除的文件夹。
3. 将恢复的文件夹存放到需要的目录下即可。
需要注意的是，备份的频率应该越高越好，这样在误删除后可以更及时的找回文件。
方法四：使用第三方恢复软件
如果以上三种方法都还没能找回被误删除的文件夹，那么就需要使用第三方恢复软件。下面我们就借助失易得数据恢复软件来介绍一下具体的操作。
第一步、运行失易得数据恢复软件。选择“本地磁盘(C:\)”栏目(根据文件所在磁盘进行选择)。单击下一步。
第二步、选择误删除扫描，点击“下一步”。或者是选择深度扫描功能。选择要恢复的文件类型。您可以选择所有文件类型，也可以单选。点击“扫描”。
第三步、确认是我们要恢复的文件后，勾选要恢复的文件，点击恢复按钮，选择文件要保存的路径，即可恢复成功。可以将文件存储在电脑上的磁盘空间和安全的外部设备上，便于文件存储和整理。
误删除的文件夹怎么恢复?我们可以通过上述三种方法，可以有效恢复误删除的文件夹。但是，在日常使用电脑时，应注意文件备份以及对文件的重要性及操作的小心。如此，才能减少误删除的发生。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c0b414f9ae942769c3b401e085a34a8/" rel="bookmark">
			STM32F103 学习笔记（1）—— GPIO 初始化/配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、STM32F103 微控制器的 GPIO 简介 1. GPIO 简介 STM32F103 是 STM32 系列微控制器中的型号，也被称为 STM32F1 系列。它基于 ARM Cortex-M3 内核，以其丰富的外设和低功耗特性而闻名。GPIO（General Purpose Input Output）是 STM32F103 微控制器上的通用输入输出引脚。
STM32F103 微控制器提供了多个 GPIO 引脚，用于与外部设备进行数字信号的输入和输出。每个引脚都可以通过配置来灵活地设置为输入或输出。作为输入引脚时，GPIO 可以读取外部设备的状态，如按钮的按下状态或传感器的测量值。作为输出引脚时，GPIO 可以控制外部设备的操作，如驱动 LED 灯的亮灭。
2. GPIO 内部结构 二、GPIO 的 8 种工作模式 4种输入模式：
输入浮空（GPIO_Mode_IN_FLOATING）输入上拉 (GPIO_Mode_IPU)输入下拉 (GPIO_Mode_IPD)模拟输入 (GPIO_Mode_AIN) 4种输出模式：
开漏输出 (GPIO_Mode_Out_OD)开漏复用输出 (GPIO_Mode_AF_OD)推挽式输出 (GPIO_Mode_Out_PP)推挽式复用输出 (GPIO_Mode_AF_PP) 1. GPIO 的输入工作模式 1——输入浮空模式（GPIO_Mode_IN_FLOATING） 浮空输入状态下，IO 的电平状态是不确定的，完全由外部输入决定，如果在该引脚悬空的情况下，读取该端口的电平是不确定的。
2. GPIO 的输入工作模式 2——输入上拉模式 (GPIO_Mode_IPU) 上拉输入状态下是将不确定的信号通过上拉电阻嵌位在高电平，防止输入端悬空，减少外部电流对芯片的干扰，同时起到限流作用，增加高电平输出时的驱动能力。当 GPIO 引脚无输入时，上拉输入在默认状态下为高电平。
3. GPIO 的输入工作模式 3——输入下拉模式 (GPIO_Mode_IPD) 下拉输入状态下是将不确定的信号通过下拉电阻嵌位在低电平，防止输入端悬空，减少外部电流对芯片的干扰，同时起到限流作用，增加低电平输出时的驱动能力。当 GPIO 引脚无输入时，下拉输入在默认状态下为低电平。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c0b414f9ae942769c3b401e085a34a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c30c308b27cd50c98fe33b969e1c2c3/" rel="bookmark">
			flink报错 Caused by: java.lang.RuntimeException: One or more fetchers have encountered exception
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb422ef928b9d75141acb28bb0e9378d/" rel="bookmark">
			苹果照片丢失，别着急!跟我一步步操作，轻松找回！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		许多iPhone和iPad用户都曾经不经意间删除了他们珍贵的照片和家庭视频，这会让我们遭受巨大的损失。但幸运的是，即使你已经删除了这些照片，很多时候，它们可能仍然可以被恢复。如果你是一位遇到这样问题的用户，那么继续阅读本文，了解一下苹果照片丢失了是如何恢复的。
1.从“最近删除”恢复照片
当你删除一个相册或照片时，它们并不会立刻从你的设备中消失。相反，它们被移动到相册的“最近删除”部分，该部分保存了你最近删除的相册和照片，以便你有机会恢复它们。如果你在预设的时间内没有恢复或清空该目录，那么你就可以找到你想要的照片并恢复了它们。
2.从iCloud备份中恢复
如果你把iCloud开启了，那么你可以从iCloud的备份找到你删除的照片。请记住，如果你在删除照片后进行了其他更改，如在iCloud中创建了一个新的备份，那么你将无法从早期的备份中取回你的照片。那些寻找照片可恢复的人，应该谨慎使用iCloud备份。如果你确信你从iCloud备份中可以找到你要恢复的照片，那么你可以通过以下步骤操作。
一、确保你开启了iCloud备份并且你的iCloud帐户有足够的空间来保存备份。
二、在你的设备上进入“设置”并点击“iCloud”。
三、点击“存储”选项卡，然后点击下方的“备份”。
四、你将看到你最近的备份，选择之后，可以在其中找到所有的照片和视频。
需要注意的是，使用iCloud备份恢复会对你的设备产生影响，那就是你将覆盖目前设备里的资料，而与其现在机子上的设置相矛盾，例如不管是通讯录，短信，照片等等都有可能不一致。
3.使用专业数据恢复软件
如果以上两种方法都不能找到你要恢复的照片，那么最后就只能考虑使用数据恢复工具了。例如失易得苹果恢复软件等。软件可以扫描你的设备，并找到已被删除的照片和视频，并且可以非常有效地恢复他们。
请注意，使用数据恢复软件恢复数据需要一些技巧，这就是为什么我们建议使用专业而可靠的软件来确保你不会不必要地进一步破坏你的设备。还需要注意的是，使用这些软件不保证100%的成功率，并且会对你的设备产生风险 ，使用前请务必备份你现在设备中的所有资料。
总之，苹果照片丢失，恢复删除的数据需要谨慎，我们建议你尽可能多地尝试从“最近删除”中找回照片，其次再考虑从iCloud备份或专业恢复软件中恢复。同时，为了避免数据丢失，我们强烈建议你在使用你的设备时备份重要数据。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6a944a99a6477dee8aded7fce266805/" rel="bookmark">
			下载需要集成第三方？Android原生下载服务DownloadManager不行吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 App 内的下载功能也是我们常用的场景，比如下载最新的 Apk 安装包，还有些会下载图片，或者资源，插件等场景。
下载不是很简单的功能吗？OkHttp就能下载，基于OkHttp实现的一些框架那更多，比较出名的有FileDownloader okdownload RxDownload 等等。
同时我们 Android 系统服务 DownloadManager 同样可以使用下载服务，他们之间有什么区别？
一、DownloadManager的默认使用 DownloadManager 是android2.3以后，系统下载的方法。可以让 Android 设备请求的 URI 被下载到一个特定的目标文件。客户端将会在后台与http交互进行下载，或者在下载失败，或者连接改变，重新启动系统后重新下载。还可以进入系统的下载管理界面查看进度。
内部主要包含 DownloadManager.Query 和 DownloadManager.Request 两个重要类。一个是封装一些下载请求的参数，一个是用于查询下载的信息。Request 是必须的，Query是非必须的。
通常使用 DownloadManager 推荐我们使用通知栏展示真正进行下载，并且我们可以跳转到下载器页面查看。
private fun startDownLoad() { //下载链接 这里下载手机B站为示例 val downloadUrl = "https://dl.hdslb.com/mobile/latest/iBiliPlayer-html5_app_bili.apk" val fileName = downloadUrl.substring(downloadUrl.lastIndexOf('/') + 1) //这里下载到指定的目录，我们存在公共目录下的download文件夹下 val fileUri = Uri.fromFile( File( Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS), System.currentTimeMillis().toString() + "-" + fileName ) ) //开始构建 DownloadRequest 对象 val request = DownloadManager.Request(Uri.parse(downloadUrl)) //构建通知栏样式 request.setTitle("测试下载标题") request.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a6a944a99a6477dee8aded7fce266805/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbf1356d463d952ec5a8f23374d9230d/" rel="bookmark">
			mp4录屏文件损坏如何修复
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		视频文件是我们日常生活中经常使用的一种重要文件格式，但是由于各种原因，如文件损坏、文件格式不支持、存储介质损坏等，这些视频文件有时可能会无法播放。这就需要我们去修复这些损坏的视频文件。那么，当MP4录屏文件出现损坏时，该如何修复呢?下面就来为大家介绍几种常见的修复方法。
一、使用视频文件播放器
视频文件播放器可以很好地解决MP4录屏文件损坏的问题。这些工具通常会自动扫描文件并检测其损坏程度，然后自动修复文件。
二、使用MP4修复工具
如果你只是想恢复MP4录屏文件的某个部分，或者如果你在使用视频文件修复工具时遇到了问题，那么可以使用专门的MP4修复工具来对文件进行修复。这些工具可以对单个文件进行操作，并可以修复在拍摄、录音、传输、编辑、转换或处理过程中损坏的视频。常见的有失易得视频修复软件等，这工具都很容易使用，并且可以在不影响文件质量的情况下修复文件。
三、重命名文件
有时候，MP4录屏文件损坏的原因可能是由于文件名中的某些字符或符号引起的。在这种情况下，只需简单地将文件重命名即可解决问题。例如，更改文件名中的特殊字符、空格或换行符等。这种方法并不总是有效，但对于一些常见的文件损坏问题，这种方法是可行的。
四、使用备份文件
如果你经常备份文件，那么在MP4录屏文件损坏时，你肯定会有一个备份文件。在这种情况下，只需将备份文件找出并替换掉损坏的文件即可。这个方法是最安全、最简单的方法，因为你不必担心文件质量或文件修复的问题。
以上是mp4录屏文件损坏如何修复的方法，当然这些方法并不是完美的，每种方法都有其优点和缺点。因此，应该根据你的需要选择最适合你的修复方法。最后，建议大家在处理重要的文件时，最好定期备份以便在文件损坏时能够快速恢复。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ad50be11838cd35a62b875ca84f0bab/" rel="bookmark">
			ValueError: ‘box_aspect‘ and ‘fig_aspect‘ must be positive
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 出现错误： 上图中的这个位置是输错了的，应该是（20，10）。这里是（20，0），所以报了这个错误。
解决办法： 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8255fcfba80062d2e49821a7bc01ed0/" rel="bookmark">
			AttributeError: Rectangle.set() got an unexpected keyword argument ‘normed‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 解决办法： axes[1].hist(image.ravel(), bins=256,normed=True) 改成
axes[1].hist(image.ravel(), bins=256,density=True) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57dde188319f68cb3954a65ac331e355/" rel="bookmark">
			Android RxJava生命周期管理解决方案整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、为什么要做生命周期管理？
Observable.create(new ObservableOnSubscribe&lt;String&gt;() { @Override public void subscribe(ObservableEmitter&lt;String&gt; emitter) throws Exception { //TODO } }) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Consumer&lt;String&gt;() { @Override public void accept(String str) throws Exception { } }); 这样就是一个简单的异步处理，但是如果只是这样使用肯定是不行，因为在 Android 开发过程中，如果在进行耗时操作的时候，操作还没有结束，这个时候退出的当前 Activity，这个时候，这段代码的处理并不会因为 Activity 的退出而结束，就会导致内存泄漏等问题，严重的时候甚至会导致 APP 闪退。
二、如何管理生命周期？
1、使用CompositeDisposable 这个类，手动实现对 RxJava 的管理
原理：每次使用 RxJava，都将其生成的 Disposable 对象添加到 CompositeDisposable 对象中，并在每个界面结束(onDestroy)的时候，调用 CompositeDisposable 对象的 clear()方法取消事件。
实现过程：1.实现一个统一管理的基准类
public class CommonComposite { private CompositeDisposable mCompositeDisposable; public void addDisposable(Disposable disposable) { if (mCompositeDisposable == null || mCompositeDisposable.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57dde188319f68cb3954a65ac331e355/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82dd2411225b2db79f5a98f758ee56e0/" rel="bookmark">
			串行通信都有什么类型？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		串行通信是一种按照位序列逐个传输数据的通信方式，主要有以下几种常见的通信方式：
串口通信：通过串行接口（串口）（按照协议）进行数据传输的通信方式，如RS-232、UART、USB串口等。
SPI（Serial Peripheral Interface）通信：一种同步串行通信协议，用于芯片与芯片之间的通信，包括主设备和从设备之间的数据传输。一种串行外设接口，用于连接微控制器和外部设备，如EEPROM、传感器、显示器等。
I2C（Inter-Integrated Circuit）通信：一种多主从的串行通信协议，用于通过两根线路（时钟线和数据线）连接多个设备，实现设备之间的数据交换。
CAN（Controller Area Network）通信：一种用于高级车辆总线系统的串行通信协议，通过差分信号传输数据，广泛用于汽车和工业领域。
LIN（Local Interconnect Network）通信：一种低速串行通信协议，用于连接汽车中的智能传感器和执行器。
Modbus通信：一种用于监控和控制设备之间的串行通信协议，被广泛应用于工业领域。
1-Wire通信：一种用于连接和通信的串行总线协议，通过单根数据线实现数据传输。
以上是一些常见的串行通信方式，它们在不同的领域和应用中有各自的特点和用途。具体选择使用哪种串行通信方式，要根据实际需求、设备兼容性、传输距离和速率等参数进行考虑。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/619416c23563eadabcab5c4479405761/" rel="bookmark">
			操作系统 输入/输出（I/O）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		I/O管理基础 I/O（输入/输出）管理是操作系统中的重要组成部分，负责管理计算机系统与外部设备之间的数据传输和交互。本文将介绍I/O管理的基础知识。
设备 基本概念 设备是计算机系统中与主机相连并能进行数据输入和输出的硬件组件。设备可以是物理设备（如打印机、磁盘驱动器）或虚拟设备（如终端、网络接口）。
分类 设备可以按照其工作方式和特性进行分类，常见的分类包括：
字符设备（Character Device）：以字符为单位进行数据传输的设备，如键盘、鼠标。块设备（Block Device）：以数据块为单位进行数据传输的设备，如硬盘、固态硬盘。网络设备（Network Device）：用于与网络通信的设备，如网卡、调制解调器。 I/O接口 I/O接口是连接主机和设备的接口，它提供了主机与设备之间进行数据传输和控制的通信通道。常见的I/O接口包括串行接口（如RS-232）、并行接口（如IEEE 1284）和USB接口等。
I/O控制方式 在进行I/O操作时，操作系统可以采用不同的控制方式来管理和协调数据传输。
轮询方式 轮询方式是最简单的I/O控制方式之一。在轮询方式下，操作系统通过不断查询设备的状态来确定是否有数据需要传输。当操作系统检测到设备就绪时，它会发起数据传输请求，并等待设备完成传输。轮询方式的优点是简单直观，但效率较低，因为操作系统需要不断查询设备状态，可能会造成资源浪费。
中断方式 中断方式是一种基于事件驱动的I/O控制方式。在中断方式下，设备通过发送中断信号来通知操作系统有数据需要传输或其他事件发生。当操作系统接收到中断信号时，它会暂停当前任务，处理中断请求，并进行相应的数据传输。中断方式相比轮询方式更加高效，因为操作系统可以在设备有数据传输请求时立即进行处理，避免了不必要的轮询。
DMA方式 DMA（直接内存访问）方式是一种高速数据传输方式。在DMA方式下，设备可以直接与主存进行数据交换，而无需通过CPU的中介。设备通过发起DMA请求来获取对主存的直接访问权，然后将数据直接传输到或从主存中。DMA方式在大数据传输和高速设备中表现出色，可以显著提高数据传输效率。
I/O软件层次结构 I/O软件层次结构定义了操作系统中用于管理和控制I/O操作的不同软件组件和层次。
中断处理程序 中断处理程序是响应中断事件的一段代码，用于处理设备的中断请求。当操作系统接收到中断信号时，它会调用相应的中断处理程序来处理中断事件，包括处理数据传输、更新设备状态等。
驱动程序 驱动程序是操作系统中的核心组件，用于管理和控制特定设备的操作。驱动程序与每个设备相对应，并提供了对设备的访问接口、设备控制命令和数据传输功能等。
设备独立性软件 设备独立性软件提供了对设备的抽象接口，使得应用程序可以独立于具体设备进行编程。它定义了一组通用的设备操作函数，应用程序可以通过这些函数进行设备的打开、关闭、读取和写入等操作，而无需关注底层设备的具体细节。
用户层I/O软件 用户层I/O软件提供了应用程序与操作系统之间的接口，使得应用程序可以方便地进行I/O操作。用户层I/O软件通常包括库函数和系统调用，应用程序可以通过它们来实现对设备的读写、缓冲管理、文件操作等。
输入/输出应用程序接口 输入/输出应用程序接口定义了应用程序与操作系统之间进行I/O操作的接口规范。它提供了一组函数或系统调用，应用程序可以通过这些接口来进行设备的读写、控制和管理。
字符设备接口 字符设备接口适用于以字符为单位进行数据传输的设备，如终端、串口设备。它提供了一组函数或系统调用，用于进行字符的读取和写入操作，以及其他字符设备的控制和管理。
块设备接口 块设备接口适用于以数据块为单位进行数据传输的设备，如硬盘、固态硬盘。它提供了一组函数或系统调用，用于进行数据块的读取和写入操作，以及其他块设备的控制和管理。
网络设备接口 网络设备接口适用于进行网络通信的设备，如网卡、调制解调器。它提供了一组函数或系统调用，用于进行网络数据的发送和接收操作，以及其他网络设备的配置和管理。
阻塞/非阻塞接口I/O 阻塞/非阻塞接口I/O指的是
进行I/O操作时的两种不同方式。
阻塞I/O（Blocking I/O）：当应用程序发起一个I/O操作时，它会被阻塞，直到操作完成才能继续执行后续代码。阻塞I/O会一直等待设备的响应，直到数据传输完成或发生错误。在阻塞I/O模式下，应用程序在进行I/O操作时会暂停执行，直到操作完成，这可能会导致程序的运行时间较长。
非阻塞I/O（Non-blocking I/O）：当应用程序发起一个I/O操作时，它不会被阻塞，而是立即返回。应用程序可以继续执行后续代码，而不必等待I/O操作的完成。应用程序可以通过轮询或其他方式来检查I/O操作是否已完成。非阻塞I/O可以提高应用程序的响应性能，但需要应用程序进行额外的轮询操作来检查操作的状态。
选择阻塞或非阻塞I/O取决于应用程序的需求和设计考虑。阻塞I/O适用于简单的程序或对实时性要求不高的场景，而非阻塞I/O适用于需要更高响应性能或并发处理的场景。
设备独立软件 设备独立软件是在操作系统中实现设备独立性的一组软件模块和技术。
缓冲区管理 缓冲区管理是设备独立软件中的一个重要组成部分。它负责管理设备数据的缓冲区，用于暂存从设备读取的数据或等待发送到设备的数据。缓冲区管理模块可以提供缓冲区的分配、回收和管理功能，确保数据的顺利传输和有效利用。
设备分配与回收 设备分配与回收是设备独立软件中的另一个关键功能。它负责管理系统中的设备资源，包括设备的分配和回收。设备分配模块负责为应用程序分配可用的设备资源，并在应用程序使用完毕后将资源释放。设备回收模块负责监控设备资源的使用情况，并在设备不再使用时回收资源，以便其他应用程序使用。
假脱机技术 假脱机技术是一种将磁盘数据缓存在内存中的技术，用于提高磁盘I/O操作的效率。通过将常用的磁盘数据缓存到内存中，假脱机技术可以减少对磁盘的实际访问次数，从而加快数据的读取和写入速度。
设备驱动程序接口 设备驱动程序接口是设备独立软件与设备驱动程序之间的接口规范。它定义了设备独立软件使用设备驱动程序的方法和接口，包括设备的打开、关闭、读取、写入等操作。设备驱动程序接口使得设备独立软件可以与不同类型的设备驱动程序进行通信，实现设备的独立性和可移植性。
外存管理 外存管理是操作系统中负责管理磁盘和固态硬盘等外部存储设备的部分。
磁盘 磁盘结构 磁盘由一个或多个盘片（Platter）组成，每个盘片上都有两个表面，每个表面都有一个磁道（Track），磁道又被划分为多个扇区（Sector）。盘片通过一个或多个磁头（Head）进行读写操作，磁头可以在盘片的不同磁道上移动，以访问不同扇区的数据。
格式化 磁盘格式化是指在磁盘上创建文件系统所需的数据结构和元数据。格式化过程将磁盘划分为一个或多个分区（Partition），每个分区可以独立地管理文件和目录。格式化还会在磁盘上创建文件系统的元数据，如文件分配表、目录结构等。
分区 分区是将磁盘划分为一个或多个逻辑部分的过程。通过分区，可以将磁盘划分为不同的存储区域，每个分区可以独立地管理文件和目录。分区可以提供更好的文件组织和管理，同时还可以实现多重引导和系统安全等功能。
磁盘调度方法 磁盘调度方法是指操作系统中用于调度磁盘访问请求的算法和策略。由于磁盘访问具有较大的延迟，磁盘调度方法可以优化磁盘访问的顺序，减少磁盘寻道和旋转延迟，从而提高磁盘的访问性能。常见的磁盘调度方法包括先来先服务（FCFS）、最短寻道时间优先（SSTF）、扫描（SCAN）和电梯（C-SCAN）等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/619416c23563eadabcab5c4479405761/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbfcfb3ea164e0a52b63a540370b5f2b/" rel="bookmark">
			【Java多线程】【进程】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
操作系统
进程/任务（Process/Task） 1、概念
进程和程序的区别
2、进程管理 3、进程的结构体里的属性
3.1 PID（进程标识符）
3.2 内存指针
3.3 文件描述符表
3.4 进程调度
3.4.1 并行 3.4.2 并发 3.5、进程调度的属性
3.5.1 进程状态
3.5.2 进程优先级
3.5.3 进程上下文
3.5.4 进程的记账信息 3.6 操作系统的常用数据结构
内存分配 —— 内存管理（Memory Manage）
进程间通信
线程是什么？ 操作系统 防止硬件被失控的应用程序滥用向应用程序提供简单一致的机制来控制复杂而又通常大相径庭的低级硬件设备。 一个应用程序的运行，是靠操作系统进行对各部分的调配，多个程序的运行，就要操作系统对这些程序进行管理
进程/任务（Process/Task） 1、概念 一个运行起来的程序就是进程，进程是操作系统对正在运行的程序的抽象；
这就是一个可执行文件（程序），当它运行起来就会在系统中形成一个进程
进程和程序的区别 进程
程序
定义
正在运行的程序，具有独立的地址空间和资源
有一系列指令和数据组成的可执行文件
资源
需要分配和管理系统资源，如：内存、CPU时间和I/O
不需要系统资源，只是一组静态的指令和数据
状态
可以处于就绪、运行、阻塞或终止等不同状态
没有状态，只有程序代码和数据
线程
可以包含多个线程，共享线程的资源
没有线程，是单线程执行
通信
可以通过进程间通信（IPC）来进行数据交换
没有内置的通讯机制，需要通过操作系统提供的API来实现
可见性
可以被操作系统和其他进程看到和管理
只有程序员能开到和管理
生命周期
创建、运行、阻塞、唤醒和终止等不同阶段
没有生命周期，只有程序代码和数据
2、进程管理 当进程多了，就需要 进程管理；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bbfcfb3ea164e0a52b63a540370b5f2b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/106319f7620689d92fd5f21225d29bda/" rel="bookmark">
			推荐一个免费下载省-市-区县行政区Shp数据的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		推荐一个免费下载省-市-区县行政区Shp数据的方法，简单实用。
文章目录 一、选择下载数据二、保存json格式三、json转shp格式 一、选择下载数据 本文讲解利用阿里云提供的地图选择器网站选择想要下载的行政区的方法，点击打开阿里云地图选择器网站，如下图所示：
然后通过鼠标点击，在地图上选择所需要的行政区数据，如点击四川省：
再点击成都市：
当然了，你可以进一步选择县区，如大邑县：
二、保存json格式 在保存数据之前，可以先进行JSON格式数据的查看。复制右侧的JSON API，直接粘贴到浏览器：
选择所需要的数据后，在右侧的其他类型处点击下载按钮，如下图所示，将会保存为JSON格式的数据，如大邑县.json。
三、json转shp格式 通常情况，需要将下载好的Json格式转为Shapefile，你可以通过ArcGIS、QGIS等专业软几件提供的JSON转换工具。也可以采用在线格式转换器将JSON转为SHP。本文介绍使用的是开源在线转换工具，可以支持多种格式的转换，包括Shp,GeoJson,TopoJson,DBF,CSV,基本包含了常用的地理空间数据格式。
拖入成都市.json，点击Export。
ArcGIS打开转化后的shp。
下载的数据坐标系为WGS84大地坐标系，大家可做进一步投影变换，可参考：
ArcGIS实验教程——实验十：矢量数据投影变换
获取更多GIS专业技术博客，请单击。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6723bb8576fe04541980deade65b2897/" rel="bookmark">
			为什么学校机房主机同时刻并行访问网络（点击开始考试）会出现卡顿现象？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注：以上是计算机网络初学者的一点个人理解，如有问题，欢迎批评指正！
我的理解是：
学校机房使用的是192.168.x.x网段下的私有ip，而私有ip不能直接与Internet进行通信（私有IP在专用网中是可重用的，并不唯一，所以互联网不认私有IP）。
为了能够访问互联网，专用网中需要一个NET路由器，NET路由器维护一个全球IP，该IP可以直接与Internet进行通信。
综上所述，机房内的所有主机同时访问网络时会同时使用该专用网中NET路由器的唯一一个全球IP发送数据报，由于唯一端口的链路带宽有限，所以同时发送就会出现拥塞现象，而网络层规定如果网络负载持续增大，网络的吞吐量下降为0时，那么网络会进入死锁状态，这时候所有人点击考试后会一直在加载中界面，导致谁也无法进入考试。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc70c5c9f23fe19410976c52461ae3bf/" rel="bookmark">
			三种SQL实现聚合字段合并（presto、hive、mysql）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 需求：按照项目名，以逗号合并参与人
presto select item_name ,array_join(array_agg(name),',') as group_name from test.test_04 group by item_name order by item_name hive select item_name ,concat_ws(',',collect_set(name)) as group_name from test.test_04 group by item_name order by item_name mysql select item_name, group_concat(name,',') as group_name from test_prc group by item_name 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/392e4043c0fde1de19ebbdddaa8e8e87/" rel="bookmark">
			Ubuntu20.04平台下使用二进制包部署MongoDB-6.0.4单实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.1 准备服务器的基本信息1.2 操作系统上创建其用户1.3 部署MongoDB服务端1.4 部署MongoDB客户端1.4.1 安装mongosh1.4.2 安装database tools 1.5 部署MongoDB 27017实例1.5.1 创建相关目录1.5.2 准备配置文件1.5.3 准备启停脚本1.5.4 进行启停测试1.5.5 加入开机自启动 1.6 创建超级管理员用户1.6.1 创建本地的超级用户1.6.2 创建远端的超级用户 1.7 创建web(业务)帐号1.7.1 创建某业务库1.7.2 创建web帐户 1.1 准备服务器的基本信息 1.2 操作系统上创建其用户 创建超级用户admin
#### 用途：相当于root用户,因为root用户我们会禁止远程登录 01：用来充当root用户的角色。 02：它不会用来运行任何的应用。 #### 用户的基本要求 01：用户要能够远程登录，要有家目录。 02：用户不能过期、密码得复杂化，密码是否过期是另外一回事。 03：用户的主组为admin,用户的辅组为wheel。 04：用户得被visudo授权为：admin ALL=(ALL:ALL) NOPASSWD: ALL #### 创建用户的命令 chattr -i /etc/passwd /etc/shadow /etc/group /etc/gshadow groupadd -g 91 wheel groupadd -g 1000 admin useradd admin -u 1000 -g admin -G wheel -m -s /bin/bash echo "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/392e4043c0fde1de19ebbdddaa8e8e87/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa69f5b7eb1efbb7a16e00a0a581a4be/" rel="bookmark">
			【C&#43;&#43;】STL——string类对象的修改操作、string类对象修改函数的介绍和使用、push_back、append、operator&#43;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.string类对象的修改操作（1）push_back（尾插单个字符）（2）append（尾插字符串）（3）operator+（尾插字符串str）（4）c_str（返回C格式字符串）（5）find + npos（返回所找字串开始字符c位置）（6）rfind（返回所找字符c位置）（7）substr（截取字符串返回） 1.string类对象的修改操作 在C++中，std::string类提供了多种方法来对字符串进行修改操作。以下是一些常用的字符串修改操作：string类详细介绍
（1）push_back（尾插单个字符） 常用的几个：
函数名称功能说明push_back在字符串后尾插字符cappend在字符串后追加一个字符串operator+=在字符串后追加字符串strc_str返回C格式字符串find + npos从字符串pos位置开始往后找字符c，返回该字符在字符串中的位置rfind从字符串pos位置开始往前找字符c，返回该字符在字符串中的位置substr在str中从pos位置开始，截取n个字符，然后将其返回 在C++中，push_back()是用于向字符串的末尾添加字符的函数。它仅适用于std::string类的对象。
push_back()函数在向字符串中添加一个字符时，会将该字符追加到字符串的结尾处。你可以使用字符常量或者变量作为参数来调用push_back()函数，以向字符串末尾添加字符。
下面是一个使用push_back()函数的示例：
#include &lt;iostream&gt; #include &lt;string&gt; int main() { std::string str = "Hello"; str.push_back(' '); str.push_back('W'); str.push_back('o'); str.push_back('r'); str.push_back('l'); str.push_back('d'); std::cout &lt;&lt; str &lt;&lt; std::endl; return 0; } //Hello World （2）append（尾插字符串） 在C++中，append()函数用于将字符串或字符序列追加到现有字符串的末尾。下面是一个使用append()函数的示例：
append()函数可以接受两种参数：字符串和字符序列。 你可以直接提供字符串常量或使用字符指针来追加字符序列。它将指定的字符串或字符序列连接到原始字符串的末尾，修改原始字符串并返回新的字符串。
#include &lt;iostream&gt; #include &lt;string&gt; int main() { std::string str = "Hello"; // 追加字符串 str.append(" World"); std::cout &lt;&lt; str &lt;&lt; std::endl; // 追加字符序列 const char* seq = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa69f5b7eb1efbb7a16e00a0a581a4be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c256292d3bcafc3756a031bf791755b8/" rel="bookmark">
			一次针对安全人员免杀工具的投毒事件分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0X01 事件概述 小二在日常安全运营中发现公司某部门同事终端触发了powershell远程下载的告警。调查发现其在github 上下载的免杀工具，调用powershell下载了后门程序，经过分析后门为远控软件，疑似对安全人员一次投毒攻击。
0x02 事件处置 2022/08/22 15:54:52发现一终端触发powershell远程下载告警，经过初步分析该命令作用为下载两个exe文件并执行。联系受害者，断网，上机提取样本，排查持久化，重启。
powershell远程下载的地址为：
https://cdn.discordapp\[.\]com/attachments/970173239244488825/1010928604487626893/Exe\_Converter.exe https://billing-seruice\[.\]com/files/7exGqJhF9PlC.exe 通过访问下载的链接获取到了样本，发现两个样本均会报毒,第二个样本为后门。
0x03 样本分析 受害者是通过https://github.com/corpXd/Exe-To-Rp下载到工具，运行后触发的告警。使用IDA对其 进行分析，发现该exe只有一个功能，使用shellexecuteA执行一段powershell命令，如下图所示：
使用工具对该命令进行解密，发现该命令的功能是下载正常的Exe_Converter.exe（免杀工具），然后再下载一个名为7exGqJhF9PlC.exe的文件并执行：
对远程下载的Exe_Converter.exe进行分析： 分析Exe_Converter.exe发现，该样本是一个将二进制文件转为图片的工具，作者为韩国人
读取exe文件：
将exe转为图片：
作者的信息：
对7exGqJhF9PlC.exe进行分析： 该木马使用了伪造的签名，签名时间为8月21日：
该木马进行了大量的混淆，最后会在内存中执行一个pe文件，但是该文件并不是一个标准的PE文件：
该内存加载的文件会对进程，文件，机器名称，用户名进行对比，以用于确定是否是在被调试或者是否是在沙箱环境
将自身复制到C:\\Users\\Administrator\\AppVerif（当前用户的AppVerif目录下，该目录是后面创建的），并命名为DllHelper.exe
然后创建计划任务，计划任务名字为COMSurrogate
自删除操作，使用ping延迟执行。
然后计划任务会启动dllhelper,dllhelper会将真正的马注入到InstallUtil.exe
对注入到InstallUtil.exe的pe文件的分析： 该文件为32位的.net文件，该文件基于github开源项目Dcrat魔改，魔改的版本为1.0.7，该样本相较于原始木马添加了amsi的绕过功能
数据包特征：
Dcrat版本信息：
该样本会从pastebin拉取c2的地址：
该端口在不停变化，说明攻击者在不断更新
Dcrat使用了多种的规避技术：
1.Bypass Amsi的技术，使用patch Amsi.dll的手法来进行绕过
2.查找可疑进程并终止
3.通过wmi判断当前环境是否为虚拟机环境
在这次的样本中并没有开启反虚拟机和反可疑进程功能
样本执行流程 TTPS: Initial AccessExecutionPersistenceDefense Evasioncommand and controlpowershell远程下载powershell执行计划任务Patch amsiDcRat计划任务ollvmNgrok（内网穿透，隐藏C2，防止溯源）sleep for a long timeanti sandbx（查看用户名，进程）anti vm（查看文件，用户名）self deleteprocess injectionPEtoShellcode伪造签名 0x04 样本行为日志分析 8.22日11.11分左右，用户解压了下载下来的工具压缩文件，其中释放的Exe_Converter.exe就是带有后门的工具程序：
随后用户点击了Exe_Converter.exe，该进程调用了powershell执行远程下载操作：
powershell先是在temp目录下又下载了一个Exe_Converter.exe：
然后下载了一个7exGqJhF9PlC.exe：
powershell指令解码结果如下，可以看到使用Start-Process函数启动下载在Temp目录下的7exGqJhF9PlC.exe和Exe_Converter.exe
7exGqJhF9PlC.exe进程被启动：
然后7exGqJhF9PlC.exe在C:\Users\Administrator\AppVerif下创建了一个DllHelper.exe，7exGqJhF9PlC.exe进程退出：
7exGqJhF9PlC.exe 进程在退出前是要启动 DllHelper.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c256292d3bcafc3756a031bf791755b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60c210544130079a56a14b82e923d484/" rel="bookmark">
			Java学习第二天笔记整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.java数据类型定义及初始化
byte a=2; System.out.println(Byte.MAX_VALUE); short b=3; System.out.println(Short.MAX_VALUE); int c=5; System.out.println(Integer.MAX_VALUE); long g=25; System.out.println(Long.MAX_VALUE); long g1=2147483648L; System.out.println(g1); float d=3.145555555555555555f; System.out.println(d); double e=3.1455555555555556666666666555; System.out.println(e); char h='u'; char h1='国'; System.out.println(h); System.out.println(h1); System.out.println('m'); System.out.println(h+0); System.out.println(h1+0); //引用类型:String String s="abcd"; System.out.println(s+0); 运行结果：
2.数据类型转换
//默认转换：容量小的数据类型自动转换成容量大的数据类型如： byte a=4; int b=a; //特殊的 long c=6; float d=c; //强制转换： short e=128; byte f=(byte)e;//可能会溢出 //在混合运算时容量小的会自动被转换为容量最大的类型再进行运算 int g=45; //错误：float g1=g+5.5; double g1=g+5.5; long i=5; //错误：int i1=g+i; long i1=g+i; System.out.println(i1); 运行结果：
3.运算符
//1.算术运算符：+:正数 加法运算 连接 int a=5; int b=6; System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60c210544130079a56a14b82e923d484/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2913c03c07e908f1b7ac7ef0b1fd9371/" rel="bookmark">
			PIL和CV区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		from PIL import Iamge
import cv2
PIL（Python Imaging Library）和CV（OpenCV）都是常用的Python图像处理库，它们读取图片的方式有所不同，各有优点。
PIL是Python的一个图像处理库，可以用来打开、操作、保存各种格式的图片。PIL读取图片时，会将图片转换为PIL自己的Image对象，可以方便地进行各种图像处理操作，如缩放、旋转、裁剪、滤镜等。PIL的优点是简单易用，支持多种图片格式，可以方便地进行图像处理。
以下是一些使用PIL的场景：
图片预处理：在进行深度学习任务时，需要对图片进行预处理，如缩放、裁剪、归一化等，PIL可以方便地进行这些操作。
图片水印：在图片上添加水印，如文字、logo等，PIL可以方便地进行这些操作。
图片格式转换：PIL支持多种图片格式，可以方便地进行图片格式转换。
CV是一个开源的计算机视觉库，可以用来处理图像和视频。CV读取图片时，会将图片转换为NumPy数组，可以方便地进行各种数学运算和图像处理操作，如卷积、滤波、边缘检测、特征提取等。CV的优点是功能强大，支持多种图像处理算法，可以方便地进行计算机视觉任务。
以下是一些使用CV的场景：
目标检测：在图像中检测目标物体，如人脸、车辆、行人等，CV可以方便地进行这些操作。
图像分割：将图像分割成多个区域，CV可以方便地进行这些操作。
特征提取：从图像中提取特征，如边缘、角点、纹理等，CV可以方便地进行这些操作。
总的来说，PIL适合进行简单的图像处理操作，如缩放、旋转、裁剪等，CV适合进行复杂的图像处理和计算机视觉任务，如目标检测、图像分割、人脸识别等。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7500f9c961a406ecffed1ffd25a8283c/" rel="bookmark">
			Python 笔记 — 数据类型转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、转换为字符串类型1、str2、f-string3、repr4、format5、字符串连接 二、转换为数字类型1、转换为整数类型2、转换为浮点类型3、转换为布尔类型 三、转换为列表类型1、list2、列表解析3、扩展运算符 *4、extend5、append 四、转换为元组类型1、tuple2、zip3、使用 () 将数据括起来 五、转换为字典类型1、dict2、字典推导式 六、转换为集合类型1、set2、集合推导式3、{} 七、总结1、字符串类型（str）2、数字类型（int，float，complex）3、列表类型（list）4、元组类型（tuple）5、字典类型（dict）6、集合类型（set） 一、转换为字符串类型 1、str 使用内置的 str() 函数，通过 str() 函数可以将数字、列表、字典、元组、集合等类型转换为字符串类型。
# 数字类型转换为字符串类型 num = 42 str_num = str(num) print(str_num) # 42 print(type(str_num)) # &lt;class 'str'&gt; # 列表类型转换为字符串类型 my_list = [1, 2, 3] str_list = str(my_list) print(str_list) # [1, 2, 3] print(type(str_list)) # &lt;class 'str'&gt; # 字典类型转换为字符串类型 my_dict = {'name': 'Alice', 'age': 25} str_dict = str(my_dict) print(str_dict) # {'name': 'Alice', 'age': 25} print(type(str_dict)) # &lt;class 'str'&gt; # 元组类型转换为字符串类型 my_tuple = (1, 2, 3) str_tuple = str(my_tuple) print(str_tuple) # (1, 2, 3) print(type(str_tuple)) # &lt;class 'str'&gt; # 集合类型转换为字符串类型 my_set = {1, 2, 3} str_set = str(my_set) print(str_set) # {1, 2, 3} print(type(str_set)) # &lt;class 'str'&gt; 2、f-string 使用格式化字符串（f-string），使用 f"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7500f9c961a406ecffed1ffd25a8283c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a2931abab8768b8f9811f623d6cc341/" rel="bookmark">
			Unable to process request - PLA Update available
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		xcode真机运行时报错
Unable to process request - PLA Update available。 You currently don't have access to this membership resource. To resolve this issue, agree to the latest Program License Agreement in your developer account.
登陆苹果开发者账号官网，同意最新协议后即可。
参考：添加链接描述
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a9d149cb484d681baea40985efebba4/" rel="bookmark">
			python入门教程(非常详细)，从零基础入门到精通，看完这一篇就够了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 本文罗列了了python零基础入门到精通的详细教程，内容均以知识目录的形式展开。
01.python由来与发展介绍
02.项目开发流程
第一章 markdown编辑器 01.markdown基本语法
02.Typora简介与安装
03.Windows上gitee+Typora设置图床
04.macOS上gitee+Typora设置图床
第二章 计算机核心基础 01.计算机组成原理
第三章 编程语言 01.编程语言介绍
02.python是解释型的强类型动态语言
第四章 Python解释器和集成环境 01.python的两层意思
02.Windows安装Python解释器
03.linux安装Python解释器
04.pip软件包管理工具介绍及基本使用
05.IDE集成开发环境介绍
06.IDE工具安装
07.IDE集成开发环境的基本使用
第五章 python入门 01.python语法之变量、常量
02.python语法之注释
03.python垃圾回收机制GC
04.Python语法入门之基本数据类型
05.用户交互与格式化输出
06.python入门之基本运算符
07.Python语法入门之流程控制if判断
08.python流程控制之while循环
09.python流程控制之for循环
10.python之数据类型之可变与不可变类型
11.python之深浅copy
12.python小数据池,代码块的深入剖析
13.拓展：Python格式化字符串的4种方式
第六章 数据类型的内置方法 01.python之数字类型内置方法
02.python之字符串类型内置方法
03.python之列表类型内置方法
04.python之元组类型内置方法
05.python之字典类型内置方法
06.python之集合类型内置方法
第七章 文件处理与字符编码 01.python之文件处理编码字符
02.python文件处理
03.python文件操作之修改
第八章 函数 01.python之函数的基本使用
02.python之函数Type-hinting
03.python之函数的参数
04.python之函数对象+函数嵌套
05.python之名称空间与作用域
06.python之闭包函数
07.python之装饰器
08.python之迭代器
09.python之生成器
10.python之三元表达式、生成式、生成器表达式
11.python之面向过程编程思想与匿名函数及其应用
12.python之内置函数
13.python之函数递归与调用
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a9d149cb484d681baea40985efebba4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36f32201d0f9ead77bd9d62664f01427/" rel="bookmark">
			windows使用makefile的三种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		windows使用makefile的三种方法 想再在windows上尝试makefile的可以试一试。注意需要下载好mingw、配置好gcc路径，才能成功使用make。
第1种方法只需要命令行，2、3种方法需要借助vscode实现。
当用户编译文件过多的时候，使用makefile可以帮助模块化编译文件，makefile是一个脚本文件，根据规则，来执行相应的脚本文件，实现自动化编译。学习使用makefile可以更深入地学习编译过程。虽然make方法在windows上不是主流方法，除开安装linux虚拟机，也有不少方式在windows上使用make工具。
如下是makefiel脚本和源文件结构：
具体脚本内容和Makefile内容如下：
'mian.c' #include "stdio.h" #include "src_a.h" #include "src_b.h" int main() { funca(); funcb(); while(1) { ; } return 0; } #include "stdio.h" 'src_a.c' void funca() { printf("funca runing!!!\r\n"); } 'src_b.c' #include "stdio.h" void funca() { printf("funca runing!!!\r\n"); } 'src_a.h' #ifndef __SRC_A_H__ #define __SRC_A_H__ void funca(); 'src_cb.h' #endif #ifndef __SRC_B_H__ #define __SRC_B_H__ void funcb(); #endif 'Makefile' mian : main.o src_a.o src_b.o gcc main.o src_a.o src_b.o -o main main.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/36f32201d0f9ead77bd9d62664f01427/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa5017b6ade906f7cf8591e15e919a69/" rel="bookmark">
			在pycharm中配置ananconda的虚拟环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先需要在ananconda 里面新建一个环境在anaconda中激活当前环境在pycharm中找到这个环境，并使用 首先需要在ananconda 里面新建一个环境 注意：ananconda中创建虚拟环境时需要确立python的版本，python版本最好要与pycharm中的原版本一致，以防出现问题
如何查看版本 1.1
查看python版本
前提：保证安装python时将路径添加到环境变量中了
按win+R键打开运行，直接输入python，点击确定，即可看到版本号，如图
1.2查看pycharm版本
创建新环境 打开anaconda终端anaconda Prompt （以创建虚拟环境的名字为“mingzi”为例）
输入conda create -n mingzi python=3.7 //此处输入刚刚自己查看的自己的版本号 摁回车， 出现y/n输y回车 此时正在创建虚拟环境
激活 创建好之后，输入conda activate mingzi 回车
在pycharm中找到这个环境，并使用 打开pycharm 点击左上角File然后 点击----setting得到下图
然后点setting里的project，然后点python interpreter选择你所需要的python环境
然后点击Add Interpreter
选择Add Local Interpreter 得到下面图
之后点击Virtualenv Environment 选择存在的环境是左边Existing 点击红圈处...，选择虚拟环境所
在的位置的python.exe文件即可（一般在anaconda-envs-虚拟环境名字-python.exe下）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd047e8af768ae378483b141979e87c1/" rel="bookmark">
			通过X11获取屏幕截图并转为opencv Mat
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include &lt;bits/stdc++.h&gt;
#include "opencv2/core.hpp"
#include "opencv2/highgui.hpp"
#include "opencv2/opencv.hpp"
#include "opencv2/videoio.hpp"
#include &lt;X11/Xlib.h&gt; //-lX11
#include &lt;X11/Xutil.h&gt;
#include &lt;X11/Xmd.h&gt;
#include &lt;X11/Xatom.h&gt;
using namespace std;
using namespace cv;
Mat getScreenShot()
{
Display *dis=XOpenDisplay((char *)0);
Screen *scr = XDefaultScreenOfDisplay(dis);
Drawable drawable = XDefaultRootWindow(dis);
XImage *image = XGetImage(dis, drawable, 0, 0, scr-&gt;width, scr-&gt;height, AllPlanes, ZPixmap);
int size=image-&gt;bytes_per_line*image-&gt;height;
unsigned char imagedata[size];
memcpy(imagedata,image-&gt;data,size);
cv::Mat ret=cv::Mat(scr-&gt;height,scr-&gt;width,CV_8UC4,imagedata);
XDestroyImage(image);
XCloseDisplay(dis);
return ret;
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c78f49a5554070828aafe9654de1855/" rel="bookmark">
			做了3年Java，靠着这份面试题跟答案，我从15K变成了30K
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在小编认为，对于Java面试以及进阶的最佳学习方法莫过于刷题+博客+书籍+总结，前三者博主将淋漓尽致地挥毫于这篇文章中，至于总结在于个人，实际上越到后面你会发现面试并不难，其次就是在刷题的过程中有没有去思考，刷题只是次之，这又是一个层次了，这里暂时不提后面再谈。
博主总结了一系列大厂面试中常问的面试技术点，深入解析以及答案，将为最近准备面试的各开发者去大厂保驾护航，
何谓面试？ 博主所理解的面试，它是一个过程，是不断沉淀、不断总结、善于传达自己的专业领域技术以及解决问题能力的过程。以下是博主总结的一些面试题，文中如有错误，恳请批评指正！
每个小结的内容都很多，我只是列举了一小部分出来，内容可以看截图，很多很多，非常全面，全部篇幅过长，这里就不展示了。有需要这份面试题的朋友我分享给大家！
MyBatis 面试题 MyBatis与Hibernate有哪些不同？
#{}和${}的区别是什么？
当实体类中的属性名和表中的字段名不一样 ，怎么办 ？
模糊查询 like 语句该怎么写?
通常一个 Xml 映射文件，都会写一个 Dao 接口与之对应，请问，这个 Dao 接口的工作原理是什么？Dao 接口里的方法，参数不同时，方法能重载吗？
Mybatis 是如何进行分页的？分页插件的原理是什么？
Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？
ZooKeeper 面试题 zookeeper 是如何保证事务的顺序一致性的？
分布式集群中为什么会有 Master？
zk 节点宕机如何处理？
zookeeper 负载均衡和 nginx 负载均衡区别
Zookeeper 有哪几种几种部署模式？
集群最少要几台机器，集群规则是怎样的?
集群支持动态添加机器吗？
Zookeeper 对节点的 watch监听通知是永久的吗？为什么不是永久的?
Zookeeper 的 java 客户端都有哪些？
Dubbo 面试题 为什么要用 Dubbo？
Dubbo 的整体架构设计有哪些分层?
默认使用的是什么通信框架，还有别的选择吗?
服务调用是阻塞的吗？
一般使用什么注册中心？还有别的选择吗？
默认使用什么序列化框架，你知道的还有哪些？
服务提供者能实现失效踢出是什么原理？
服务上线怎么不影响旧版本？
如何解决服务调用链过长的问题？
Elasticsearch 面试题 elasticsearch 了解多少，说说你们公司 es 的集群架构，索引数据大小，分片有多少，以及一些调优手段 。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c78f49a5554070828aafe9654de1855/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ae0cdd5e08bd5775ffb7d9a1ac6177f/" rel="bookmark">
			C#开发，.NET、C基础知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载地址：原文链接 https://www.cnblogs.com/Can-daydayup/p/8921990.html 前言： 学习是一个循序渐进的过程，作为一名.Net软件工程师我们需要学习和掌握的东西非常的多，本章主要是记录下前段时间面试中经常遇到的一些基础常识，这里只是大致的概括还有很多需要学习的东西需要不断的学习和积累。
访问修饰符：
public:公有访问，不受任何限制。
private:私有访问，只限于本类成员访问。
protected:受保护的，只限于本类和子类访问。
internal:内部访问，只限于本项目内访问，其他的不能访问
protected internal:内部保护访问，只限于本项目或是子类访问，其他的不能访问
枚举：
是由一组特定常量构成的一组数据结构，是值类型的一种特殊形式，当需要一个由指定常量集合组成的数据类型时，使用枚举类型。枚举声明可以显式地声明 byte、sbyte、short、ushort、int、uint、long 或 ulong 类型作为对应的基础类型。没有显式地声明基础类型的枚举声明意味着所对应的基础类型是 int，在代码中使用枚举，可以将以前笨拙的代码变得优雅简单，更加直观，方便记忆。
枚举在什么地方适用呢？
一条普遍规则是，任何使用常量的地方，例如目前用 switch 代码切换常量的地方。如果只有单独一个值（例如，鞋的最大尺寸，或者笼子中能装猴子的最大数目），则还是把这个任务留给常量吧。但是，如果定义了一组值，而这些值中的任何一个都可以用于特定的数据类型，那么将枚举用在这个地方最适合不过。
WebAPI 和 WebService的区别：
（https://blog.csdn.net/cysong168/article/details/51433986）webapi使用的是http协议，而webservices采用的是soap协议webapi是无状态的，相对于webserives更轻量级。webapi支持get，和post等http请求
http soap关系：
http是一个客户端和服务器端请求和应答的标准（TCP）。http协议其目的是为了提供一种发布和接收htttp页面的方法一http协议的客户端与服务器的交互：由HTTP客户端发起一个请求，建立一个到服务器指定端口（默认是80端口）的TCP连接。HTTP服务器则在那个端口监听客户端发送过来的请求。一旦收到请求，服务器（向客户端）发回一个状态行，比如”HTTP/1.1 200 OK”，和（响应的）消息，消息的消息体可能是请求的文件、错误消息、或者其它一些信息。soap 协议：它描述了一种在分散或分布式的环境中如何交换信息的轻量级协议。soap在http协议的基础上，一个基于XML的协议。
不同：都是底层的通信协议，请求包的格式不同而已，soap包是XML格式,http纯文本格式。
WCF和WEB API我该选择哪个？
1、当你想创建一个支持消息、消息队列、双工通信的服务时，你应该选择WCF
2、当你想创建一个服务，可以用更快速的传输通道时，像TCP、Named Pipes或者甚至是UDP（在WCF4.5中）,在其他传输通道不可用的时候也可以支持HTTP
3、当你想创建一个基于HTTP的面向资源的服务并且可以使用HTTP的全部特征时（比如URIs、request/response头，缓存，版本控制，多种内容格式），你应该选择Web API
4、当你想让你的服务用于浏览器、手机、iPhone和平板电脑时，你应该选择Web API
hashmap和hashTable的区别：
1.hashTable是Dictionary的子类，HashMap是Map接口的一个实现的类
2.Hashtable中的方法是同步的，而HashMap中的方法缺省情况为非同步
3.HashTabe不允许null值，而hashmap允许有null4.hashtable默认长度是11，增长方式是0ld*2+1，而hashmap则默认是16，而且一定是2的指数
如何理解委托和事件？
委托相当于c或者c++中的指针，委托能够把方法当做参数传递，并且提高程序的可扩展性。
事件：以一种特殊的委托
委托具有如下特点：
1.委托相当于c++中的指针，但是他是安全类型
2.委托可以把方法当做参数传递
3.委托可以定义回调方法
4.委托可以链接在一起，例如:可以对多个事件调用多个方法
5.方法不需要与委托前面精确匹配
UDP连接和tcp连接的异同：
两者都可以实现远程通讯，而主要区别在于tcp需要保持连接，而Udp不需要，由此可以看出udp更高的效率和占用资源更少，但是tcp传输数据更可靠
.Net身份验证的方式有哪几种：
默认值为 Windows。 在Web.config 文件中，通过 节可以配置 ASP.NET 使用的安全身份验证模式，以标识传入的用户。 … 节的mode 为必选的属性。指定应用程序的默认身份验证模式。
此属性可以为下列值之一： Windows ：将 Windows 验证指定为默认的身份验证模式。将它与以下任意形式的 Microsoft Internet 信息服务 (IIS) 身份验证结合起来使用：基本、摘要、集成 Windows 身份验证 (NTLM/Kerberos) 或证书。在这种情况下，您的应用程序将身份验证责任委托给基础 IIS。 Forms ：将 ASP.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ae0cdd5e08bd5775ffb7d9a1ac6177f/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/115/">«</a>
	<span class="pagination__item pagination__item--current">116/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/117/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>