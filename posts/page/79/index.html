<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8aa4e0465e9b67e945c08ddad01b3d0b/" rel="bookmark">
			Python爬虫实战案例一：爬取猫眼电影
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 背景 笔者上一篇文章《基于猫眼票房数据的可视化分析》中爬取了猫眼实时票房数据，用于展示近三年电影票房概况。由于数据中缺少导演/演员/编剧阵容等信息，所以爬取猫眼电影数据进行补充。关于爬虫的教学内容，网络上一搜就有很多了，这里我以个人的爬虫习惯，介绍此次过程中所用到的库和代码。流程图，如下图所示：
抓包 Ajax异步加载的网页，加载数据的URL需要通过抓包获取。一般确认是否异步加载，只需要右键打开网页源代码，如果源码文字内容与前端展示的结果不一致，则属于异步加载。这时需要按F12打开开发者工具的Network，重新刷新网页，就能看到真正的URL。如下图所示，开发者工具中红色框的URL才是真正加载数据的URL。
concurrent.futures库
利用多核CPU提升执行速度。主要包含两个类：ThreadPoolExecutor和ProcessPoolExecutor，当执行属于IO密集型时，使用ThreadPoolExecutor开启多线程。当执行属于CPU密集型时，使用ProcessPoolExecutor开启多线程。 requests库
用于发送网络请求。网络请求有get和post两种方式，get()可以直接获取数据，post()需要传递参数后才能获取数据。一般网站都是get方式，若需要登录后才能看到数据的网页则属于post方式。而爬虫中post()通常和session()搭配使用，session()用于保存登录后的cookie。 Beautifulsoup库
用于解析HTML。爬虫需要懂得基本的HTML语言，通过定位不同的标签来提取数据。 re库
正则表达式，用来检索或替换符合某个模式(规则)的文本。爬虫过程中如果遇到不能直接提取的脏数据时，一般采用re解决。re功能非常强大，而且上手不难，很多方面都可以运用它，所以掌握re也是一个必备技能。 redis数据库
非关系型数据库，可以存储多种抽象数据类型。由于读写简单快捷，所以笔者将其当做缓存数据库，用于存储待爬取URL，再配合ThreadPoolExecutor多线程进行爬取，满足高并发需求。 Mysql数据库
关系型数据库，用于存储最终结果。 实例 首先，确认URL是否需要抓包获取，还是可以直接手工构建。如下图所示，源码内容与前端展示是一致的，所以可以根据传递的参数内容，直接构建URL。
然后，再根据类型、区域、年代这三个参数，构建首页URL。
接着，获取每种分类的页面数量，再构建页面URL，再存到redis中。这么做的原因是猫眼页面查看数量是有限制的，通过遍历所有分类构建URL可以绕过这个限制。
然后，爬取每个页面中影片的ID，再构建详情页URL。由于多线程爬取速度很快，会导致IP暂时被限制登录，所以需要进行判断。通过while语句识别队列是否为空，来决定是否继续执行。此外，暂无评分的影片不属于考虑范围，所以剔除。
最后，爬取每条详情页URL的信息，同时也需要判断IP是否被限制。由于无票房的影片不属于考虑范围，所以剔除。将结果直接保存到Mysql中。
猫眼电影中，2011年至今，有评分有票房的影片有10746条。
学习资源推荐 除了上述分享，如果你也喜欢编程，想通过学习Python获取更高薪资，这里给大家分享一份Python学习资料。
这里给大家展示一下我进的最近接单的截图
😝朋友们如果有需要的话，可以点击下方链接领取或者V扫描下方二维码联系领取，也可以内推兼职群哦~
🎁 CSDN大礼包，二维码失效时，点击这里领取👉：【学习资料合集&amp;相关工具&amp;PyCharm永久使用版获取方式】
学好 Python 不论是就业还是做副业赚钱都不错，但要学会 Python 还是要有一个学习规划。最后大家分享一份全套的 Python 学习资料，给那些想学习 Python 的小伙伴们一点帮助！
1.Python学习路线 2.Python基础学习 01.开发工具 02.学习笔记 03.学习视频 3.Python小白必备手册 4.数据分析全套资源 5.Python面试集锦 01.面试资料 02.简历模板 🎁 CSDN大礼包，二维码失效时，点击这里领取👉：【学习资料合集&amp;相关工具&amp;PyCharm永久使用版获取方式】
因篇幅有限，仅展示部分资料，添加上方即可获取👆 ------ 🙇‍♂️ 本文转自网络，如有侵权，请联系删除 🙇‍♂️ ------ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ebd371434684c73dea82091d39405af/" rel="bookmark">
			SpringBoot 常用工具类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		断言 1.断言是一个逻辑判断，用于检查不应该发生的情况
2.Assert 关键字在 JDK1.4 中引入，可通过 JVM 参数-enableassertions开启
3.SpringBoot 中提供了 Assert 断言工具类，通常用于数据合法性检查
// 要求参数 object 必须为非空（Not Null），否则抛出异常，不予放行 // 参数 message 参数用于定制异常信息。 void notNull(Object object, String message) // 要求参数必须空（Null），否则抛出异常，不予『放行』。 // 和 notNull() 方法断言规则相反 void isNull(Object object, String message) // 要求参数必须为真（True），否则抛出异常，不予『放行』。 void isTrue(boolean expression, String message) // 要求参数（List/Set）必须非空（Not Empty），否则抛出异常，不予放行 void notEmpty(Collection collection, String message) // 要求参数（String）必须有长度（即，Not Empty），否则抛出异常，不予放行 void hasLength(String text, String message) // 要求参数（String）必须有内容（即，Not Blank），否则抛出异常，不予放行 void hasText(String text, String message) // 要求参数是指定类型的实例，否则抛出异常，不予放行 void isInstanceOf(Class type, Object obj, String message) // 要求参数 `subType` 必须是参数 superType 的子类或实现类，否则抛出异常，不予放行 void isAssignable(Class superType, Class subType, String message) 对象、数组、集合 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ebd371434684c73dea82091d39405af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/025c4bd4389e3abcbf38cf0c804cb114/" rel="bookmark">
			Unity新动画系统之动画层和动画遮罩
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Unity新动画系统之动画层和动画遮罩 一、介绍二、动画骨骼遮罩层使用第一种就是create一个avatar Mask,如下：第二种遮罩，就是直接在动画剪辑的属性上更改，如图一为humanoid类型的动画剪辑属性： 一、介绍 之前分享过FSM动画控制系统以及状态树融合的缓慢起跑的文章，这一节来讲一下Unity的动画层Layer和这招avaterMask
二、动画骨骼遮罩层使用 Weight权重，对应着这一层动画在所有动画中所占的比例。上图老说明，new layer中的weight为0，模型的动画效果就是base layer中的动画；0-1之间，模型的动画效果就是这两层动画的混合；
mask 遮罩，手动控制模型哪些骨骼参与动画哪些不参与；在unity中有两种常用的说明下。
第一种就是create一个avatar Mask,如下： humanoid 对人体骨骼模型的遮罩，红色代表不参与动画，绿色就是正常参与动画。动画遮罩在混合动画中表现出色，上面说的调整weight值也能实现两种动画的混合，但是这种混合出来的动画看起来很别扭，远没有动画遮罩效果好。
transforms可以导入某一avatar的全部骨骼点，动画具体到对骨骼点的控制；
第二种遮罩，就是直接在动画剪辑的属性上更改，如图一为humanoid类型的动画剪辑属性： 图二为generic类型的动画剪辑属性：
这种遮罩更改之后，所有使用到该动画剪辑的地方都会享受到这种遮罩效果；
blending混合模式—additive和override；
additive 两种动画相叠加，并不算融合；override 两种动画相融合；
sync 同步层 就是让该层复刻其他层的动画，其他层可以从Source Layer 选择。Timing：当前层和Souurce层同一个状态使用的动画时间长度不一致时，不勾选timing那么复制的层按Source层的时间播放（效果就是复制层动画可能会变快或变慢，Source层动画播放速度不变），勾选timing则Source层按复制层的时间播放（效果就是Source层动画可能会变快或变慢，复制层动画播放速度不变），只有勾选sync，timing才可以勾选；
IK Pass 表示启动IK动画；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dbc0ab4e69aa63aa29349cf1d7c1daba/" rel="bookmark">
			批量给每一段文字 段落加上符号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		批量给每一段文字 段落加上符号
例如 要给下面的内容统一加上[xxxxxxxx]
查找替换–&gt;查找内容 ：输入前面统一的标识 替换为：–&gt;特殊格式–&gt;查找内容–&gt;全部替换
先在前面加符号
在后面加符号：
最后效果：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8cedba44292d7068e8e7f8ed018900c4/" rel="bookmark">
			VScode 端口转发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d8436447e0347c680893d7c780132a7/" rel="bookmark">
			SMOS数据处理，投影变换，‘EPSG:6933‘转为‘EPSG:4326‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在处理SMOS数据时，遇到了读取nc数据并存为tif后，影像投影无法改变，因此全球数据无法重叠。源数据的投影为'EPSG:6933'，希望转为'EPSG:4326'。
解决代码。
```python import os import netCDF4 as nc import numpy as np from osgeo import gdal, gdalconst # *************************导入netCDF4 file_path = r'I:\\' input_name = file_path + 'SM_SCIE_MIR_L4AGBB_20110101T000000_20211231T235959_100_001_8.nc' out_path = r'I:\out\\' res = 0.25 #目标数据的分辨率 top = 57 #目标数据的top坐标 geo_transform = [-179, res, 0.00, top, 0.00, -res] #投影转换 os.makedirs(out_path, exist_ok=True) with nc.Dataset(input_name) as DS: data = DS.variables['AGB'] #nc文件数据 data_arr1 = np.asarray(data) #转为数组 src_proj = DS.proj4text #nc原始文件投影信息 for j in range(0, 11): year = str(2011 + j) data_arr3 = np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d8436447e0347c680893d7c780132a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09db84d2ab94f215e27c954a5381929e/" rel="bookmark">
			机器学习（第2章 贝叶斯理论与应用）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、学习目标 1.了解贝叶斯公式。
2.了解贝叶斯去决策相关函数和过程。
3.根据例子理解朴素贝叶斯分类器在离散变量和连续变量中的设计。
二、贝叶斯公式 1.贝叶斯公式（Bayes function）的公式如下所示：
其中，A为类别，B为输入，Ai是第i个类别。贝叶斯公式的推导过程也十分简单：
2.那么，贝叶斯公式显然只是套用了一下条件概率公式和全概率公式，进行了一下变换。是为何能应用到实际分类中呢？首先，公式左边是我们的目标，翻译成白话是：在输入B的情况下，将其分为Ai类别的概率。同理，我们可以计算所有类别的概率。然后，公式右边是我们的依据，P(B|A)与P(A)是可以根据我们的训练数据获得的，P(B|Ai)是在Ai类别下的B的出现率，P(Ai)是Ai类别的出现率。
二、贝叶斯决策 1.粗俗地说，贝叶斯决策是一个道理，将输入B变成输入x，类别Ai换成ωi。如下图所示：
2.接下来，通过观测公式，可以发现等式右边的分母部分是一个不影响判断的数据，称为evidence，我们就可以认为，我们做决策，或者做分类的依据，只看分子部分就可以，即：
3.那么，如果我们只进行二分类的话，我们就有：
4.将贝叶斯公式再抽象，转化，可以得到类别相似性函数：
5.最后g函数变成对数相加，这就方便我们后面的决策计算，即进行加减比较，而非乘除比较：
6.至此，贝叶斯的决策过程就讲明白了。由于贝叶斯决策仅根据统计数据来预测，并不像一些高级的机器学习方法需要设置损失函数，仅需要统计数据，设计决策函数，分类即可。
三、朴素贝叶斯分类器 1.使用朴素贝叶斯分类器有一个比较大的条件，也可以称是其最大的约束：属性条件独立性假设。说人话就是，对于输入x，x是一个向量，要求x的每个元素关系相互独立，举个例子，为了区分西瓜是否是好瓜，我们可以去看西瓜的许多属性，如色泽、纹理、触感等等，而属性条件独立性假设说的就是假设这些属性是相互独立、互不影响的。
2.拉普拉斯平滑：由于我们在准备训练集时总会可能存在样本不充分的问题，导致某些分类或者某些情况并非出现，从而导致概率估计值为0。这会导致后面计算总概率值时出错。于是设计的拉普拉斯平滑：
3.朴素贝叶斯分类器（离散情况、半离散情况）：以分辨西瓜好坏为例，我们有以下数据：
离散值是指西瓜的色泽、根蒂、敲声、纹理、脐部、触感这些属性，而密度、含糖率是连续值。这是一个半离散的情况。（1）第一步：由于我们只分两类（好瓜，坏瓜），先对这两个进行统计，即类别先验估计：
（2）第二步，我们的目标是：现在来了一个新瓜，我们如何根据他的数据去判别其是否是好瓜。
统计各属性占两个的分类的比例，即类别条件概率估计，例如西瓜乌黑占好瓜的几分之几，占坏瓜的几分之几。此时还需要区分离散值属性和连续值属性。
其中，离散部分比较好理解，连续部分是将该属性假设成一个正态分布，正态分布只需要两个数值去确定，均值和方差。显然，我们可以统计对应属性的均值和方差再代入到正态分布公式即可。这样，我们就可以计算测试数据各个属性的类别条件概率：
ps.可能有同学发现了一个问题，那就是连续值属性中得到的概率为什么会大于1，这是因为计算得出的是正态分布的函数值，该函数值需要乘上一个趋近于0的Δx才能得到真正的概率值。那么这个值会不会影响最后的区分呢？可能会，也可能不会。但毕竟朴素贝叶斯是很古老的东西了，进行深究的必要性就很小了。
（3）贝叶斯决策，根据前两步计算出来的概率估计，根据贝叶斯公式进行计算：
至此，朴素贝叶斯对于离散型、半离散型的情况就结束了。
4.朴素贝叶斯分类器（全连续型情况）
全连续型的情况是比较常见的，特别在控制机器人的运动中。由于所有属性都是连续型的，与其每个属性都设计一个正态分布进行拟合，不如将所有属性看成一个整体，对输入x（一个向量）进行正态分布拟合。
与离散型情况还有一点不同：在离散型中，我们最后只需要计算两个类别的概率值即可。但在连续值中，我们可以将测试数据x*代入两个分布中分别计算概率值，但是这样不方便，可以寻找一个临界面，临界面以内为一类，面以外为另一类。于是，问题从分类问题变成寻找临界面问题，这个临界面被我们称为决策界。
为了方便计算，先将贝叶斯公式取对数，在代入正态分布，得到类别相似性函数为（1）公式。
然后再确定决策函数和决策界：
接下来，我们主要讨论三种情况：
（1）其包含两个条件，（a）两个类别的协方差矩阵相等，（b）协方差矩阵是一个对角矩阵。（a）能让我们计算比较方便，可以抵消某些数据。（b）表明正态分布没有倾斜，属性之间还是没有互相影响，还可以用朴素贝叶斯。（如果有相关，就不能用朴素贝叶斯了）我们先计算gi(x)和gj(x)。
对于红色圆圈部分，也可以这样理解：由于我们后面要计算gi(x)-gj(x)，这部分是会抵消的，故这里直接去掉就行。计算gi(x)-gj(x)之后，可以得到x0，就是我们的决策界。
x0其分为两大部分，第一大部分为黄色，其表示是两个分布均值点的中点。第二大部分为灰、红、绿三部分组成，其整体表示为决策界根据先验概率估计进行的平移调整。灰色为一个正值，其意义不用太多理解；绿色部分为界的方向，μi-μj则表示界的正方向是从μj指向μi，红色部分为先验概率估计的比值，如果i的数据更多，那么决策界会向μi远离，属于i的区域更大。
（1.sp）再特殊点，如果类别先验相等，则x0的第二大部分为0：
（2）同样包含两个条件：（1）两个类别协方差相等，（2）协方差矩阵是任意矩阵，即第1行第2列会有数值，说明这时候属性之间有相关，但我们依旧使用朴素贝叶斯来估计，（理论上应该用别的原理，但我们在实验时可以先用朴素贝叶斯来看看结果怎么样）先计算类别相似性函数：
然后计算决策界：
与上一个例子不同点仅在于灰色部分，实际上就是协方差矩阵变化的缘故。其意义还是没必要理解。
（2.sp）同（1.sp）的道理：
（3）当两个类别协方差矩阵是任意时，那么就需要具体情况具体分析了：
（4）一个简单的例子：
四、参数估计 1.定义:参数估计问题，即在机器学习中，我们在设计模型时，如何调整模型的参数以符合我们的数据，从而得到一个较好的预测结果。而贝叶斯学习作用于参数估计，并不是说贝叶斯公式是我们的模型，而是用贝叶斯公式的理论，去调整我们的模型参数。
2.贝叶斯公式在参数估计中的参数：除去P(D)不需要关注后，剩下的部分其实就是贝叶斯公式的三个成员P（D|M）为似然概率分布，P（M）是先验概率分布，P（M|D）是后验概率分布。首先需要明确一点，M可以认为是模型，但最好还是称其为模型参数，就是我们调整的目标。而P（D|M）和P（M|D）才是我们的模型。
3.我们还是以一个简单的例子来讲解其中过程吧：
这是一个随机变量只有两种取值的问题，相当于抛硬币的问题，猜下一次出现正面的概率大，还是反面的概率大。（请不要yy：抛硬币不就50%：50%的概率嘛。所有的理论都必须实践之后才知道）
显然，我们可以先假定下次出现正面的概率为θ，那么反面的概率就是1-θ。这一步很简单，然后写成概率公式：
然后把上面的公式整合起来，就得到一个出名的分布：贝努利分布。当x=1时，函数等于θ，当x=0时，函数等于1-θ。非常的完美。
那么请问，这个分布有什么用呢？这个就是我们的关于这个问题的似然概率分布P（D|M），x是D的变量，M对应θ。统计D所有的数据x，即有：
似然概率分布得到后，接下来考虑的是先验概率分布P（M），在实际实验中，先验概率分布是人为设计（似然概率分布也是，毕竟两个都是模型的内容），至于设计怎样的先验概率分布，依据主要有两点：数据的特点，与似然概率分布成共轭函数。
对于抛硬币的问题，我们可以找到这样一个先验概率分布（怎么找到的我们就不管了，反正依据就是上面两条，前人也设计了许多先验分布）Beta先验分布：
其中α1与α2是超参数，用于调整整个分布的样子，黄色部分为对两超参的归一化调整，只要知道是一个数值就行（不懂超参数的可以将其类比成正态分布中的均值和方差，均值可以调节正态分布的中心位置，方差调整正态分布的高低胖瘦）。α1与α2对先验分布的影响如下展示：
最后，有了似然分布和先验分布，我们就可以通过贝叶斯公式计算出后验概率分布：
我们惊奇地发现，后验概率分布也是一个Beta分布，其实，这就是先验概率分布是似然概率分布的共轭函数的功劳。千万不要忘记我们的目标了，我们的目标是求出θ
在机器学习中，我们有两种方法来求θ，极大似然估计和最大后验估计。既然上面都算出后验概率分布了，我们就从最大后验估计开讲：
其实就是对后验概率分布求梯度=0，黄色部分是整个后验概率分布，绿色部分则是忽略贝叶斯公式分母部分，对二者求梯度=0，实际上等价。再回看我们的后验概率分布公式：
相关求梯度的过程就不详谈了，反正最后算出最优结果（黑框），代入我们数据，得：
绿色部分确定α1与α2都设为5，黄色部分计算出θ的最终结果。也就是说下次抛硬币的正面概率是19/33，反面就是14/33。（结束）
然后再说极大似然估计的过程，先说为什么用极大似然估计，这是因为是实验中，如果我们的似然概率分布太过复杂，是很难找到一个共轭的先验概率估计与他相乘的，如果找一个不是共轭的，最后计算出的后验概率分布求梯度=0也会很难。于是我们就不考虑先验概率了，直接对似然概率求最大就行了。写成公式如下：
对P（D|θ）先取对数，再求梯度=0，得到：
代入题目数据，得到具体数值：
于是，我们发现一个很离谱的事：我们从建模、设公式、计算一套流程下来，最后得到的概率竟然就是统计出来，正面出现了多少次，那么正面的概率就是多少，反面出现了多少次，反面的概率就是多少。不知道多少同学开始骂扑街了。虽然极大似然估计的结果确实是这样的，但整套过程也是拥有其数学根据的，是讲科学的过程，不然别人问你为什么统计出“正面出现了多少次，那么正面的概率就是多少”的依据是啥，你讲不出来，你再把这套理论说出来，嗯，很牛逼。
最后将ML（极大似然估计）和MAP（最大后验估计）的结果来比较：
那么哪个更合理呢？直接讲答案吧，MAP更合理，对比一下，MAP就是比ML多一个先验概率分布，而先验概率分布是人为设计的分布，可以粗浅地认为先验概率分布是人通过观察数据后，感觉到数据服从某种规则，从而设计的模型，所以MAP更合理。显然通过这道题的结果，也可以看出二者的优劣，ML结果就是统计数据的结果，存在太大的不确定性。
五、本章小结 1.贝叶斯决策准则
2.贝叶斯分类器
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/09db84d2ab94f215e27c954a5381929e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02d0fdf474140238e46ed60c324e0e5b/" rel="bookmark">
			OnlyOffice文档服务器安装及集成使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OnlyOffice文档服务器安装及集成使用 0、前言一、安装1.使用docker安装2.开启防火墙3.配置4.访问测试 二、应用集成1.前端集成(React)(1).安装@onlyoffice/document-editor-react(2).使用 ONLYOFFICE 文档 React 组件 2.后台集成(Java)(1) getFile接口(2) callback接口(3) getFile接口和callback接口代码 三、其他问题1. 该文件版本已变，该页面将被重新加载 四、源码下载 0、前言 先摘一段官网的描述：ONLYOFFICE 文档 是一个开源办公套件，包括文本文档、电子表格、演示文稿和可填写表单的编辑器。 它提供以下功能：
创建、编辑和查看文本文档、电子表格、演示文稿和可填写表单与其他队友实时协作处理文件。 官网文档中文：
https://api.onlyoffice.com/zh/editors/basic
官网文档英文：
https://api.onlyoffice.com/editors/basic
在线效果如：
word：
excel:
ppt:
一、安装 1.使用docker安装 创建安装目录
mkdir /app/onlyoffice/DocumentServer/logs -p mkdir /app/onlyoffice/DocumentServer/data -p mkdir /app/onlyoffice/DocumentServer/lib -p mkdir /app/onlyoffice/DocumentServer/db -p 下载镜像
docker pull onlyoffice/documentserver 启动镜像，这里以8088端口对外进行服务,可自行修改
docker run -i -t -d -p 8088:80 --restart=always \ -v /app/onlyoffice/DocumentServer/logs:/var/log/onlyoffice \ -v /app/onlyoffice/DocumentServer/data:/var/www/onlyoffice/Data \ -v /app/onlyoffice/DocumentServer/lib:/var/lib/onlyoffice \ -v /app/onlyoffice/DocumentServer/db:/var/lib/postgresql -e JWT_SECRET=my_jwt_secret onlyoffice/documentserver 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/02d0fdf474140238e46ed60c324e0e5b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3794178b930b9929497aff1775c36889/" rel="bookmark">
			Android C&#43;&#43;服务创建和HIDL的生成
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 Android C++服务创建和HIDL的生成一、HIDL的生成二、c++服务的创建三、有关/device内的部分文件修改四、修改SELINUX相关部分，关乎到service的开机自启动4-1 system/sepolicy/vendor目录4-2 system/sepolicy/public和/system/sepolicy/prebuilts目录4-3 system/sepolicy/private/和/system/sepolicy/prebuilts目录 五、以上创建与修改（增加）的文件记录如下六、在AS创建对应的Client总结：这个service的作用只有两个，上层app通过sendData发送数据到service，service对数据进行处理，在这里面，时对数据的第二位改写为1。如有错误，请指正，谢谢参考 Android C++服务创建和HIDL的生成 总结c++创建服务和HIDL生成的一些步骤，本文未使用指令去生成创建hidl和对应的服务文件。 一、HIDL的生成 1.首先，在vendor/mediatek/proprietary/hardware/interfaces中创建文件夹testofhidl/1.0，
在上述的路径中,即…/interfaces，主要是mediatek存放HAL文件的地方，注意，在里面一般也有如下两个文件updat-hash.sh和updat-makefiles.sh，创建完成后，我们有如下路径：
vendor/mediatek/proprietary/hardware/interfaces/testofhidl/1.0
2.在testofhidl/1.0/下创建文件ITestOfHidl.hal和IDataCallback.hal，两者都是Hal文件，IDataCallback.hal是做回调用的，最后创建Android.bp文件，它们都是在…/testofhidl/1.0这个目录下的，它们的分别如下
ITestOfHidl.hal
package vendor.mediatek.hardware.testofhidl@1.0; import vendor.mediatek.hardware.testofhidl@1.0::IDataCallback; interface ITestOfHidl { init(); release(); sendData(vec&lt;uint8_t&gt; data); setDataCallback(IDataCallback callback) generates (uint32_t channel); }; IDataCallback.hal
package vendor.mediatek.hardware.testofhidl@1.0; interface IDataCallback { onDataReceived(vec&lt;uint8_t&gt; data); }; Android.bp
// This file is autogenerated by hidl-gen -Landroidbp. hidl_interface { name: "vendor.mediatek.hardware.testofhidl@1.0", root: "vendor.mediatek.hardware", srcs: [ "IDataCallback.hal", "ITestOfHidl.hal", ], interfaces: [ "android.hidl.base@1.0", ], gen_java: true, } subdirs = [ "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3794178b930b9929497aff1775c36889/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4de586236a086e9191e2f0057602aa2e/" rel="bookmark">
			聊聊身边的嵌入式：用了七八年的电动牙刷，突然罢工了！！！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		家里用了七八年的电动牙刷，前两天突然罢工。先尝试一下野蛮的修复方法(摔摔打打)，这种独家绝技屡试不爽，曾经修好过收音机，电视机，电子手表… 等等。不过这次，没有成功！这周末终于有点儿时间，准备一展身手。小样儿，还治不了你了？
先来张靓照 这款牙刷设计非常简洁，只有一个按钮，每按一次后，牙刷的工作状态变化一次，从快速，慢速，到时快时慢，还有一种像波浪一样的方式。原来以为这个圆形的牙刷头是高速转动的，最近才搞清楚，它其实是在一定幅度内左右摆动的。牙刷柄下部把手下面有个凹槽，套在充电座上，充电座把220V交流电转化为交替变化的磁场，把能量传递给牙刷内部的接收线圈，然后在电路控制下给电池充电。
我们拆开看看内部。最左边是充电线圈，中间红色的是主控板，右边是直流电机，电机通过传动装置，把旋转力量转变为传动杆的左右摆动，再带动刷头的摆动。由于牙刷柄比较长，便于手指操作的按钮，距离电路板上的按键比较远，手指的按压是通过一个金属连杆，传到电路板上的按键的。
从另一面看，左边绿色的部分，可以看到它没有采用现在常用的锂电池，而是用了日本FDK的镍氢电池。
镍氢电池相比锂电池有什么优缺点呢：
优点：镍氢电池基本无毒无害，安全性高，寿命长，价格低。耐过充过放，无需专用充放电管理。
缺点：重量高，能量密度小，充电慢，有记忆效应，放电能力小。电压低，需要升压电路。镍氢一般1.2V，锂离子3.7-4.2V。
从结构设计上来说，可以看到机身设计的非常紧凑，装配上几乎没有看到螺丝，都是靠结构之间的咬合，而且拆解也很方便，这是一个非常非常值得学习的地方。
上图是传动部分，可以看到右边的这个塑料齿轮基本没有磨损，在齿轮的正下方，是电机的金属齿轮。
再来看看电路部分 这款电动牙刷的电路比较简单，主控用了TI的MSP430G2432，想当年，在低功耗领域，MSP430的风头也是一时无两。值得注意的是这是一款16位RISC单片机，16位机在过去的将来还有机会吗？喧嚣一时的争论，似乎在历史的尘埃中没有了意义。从古至今，从来没有永远的霸主。
单片机上方，一个6引脚的小IC作用是升压，把电池1.2V转换成3V的工作电压给MCU和电机。右边紧挨着的，是升压电路必不可少的电感。再一个主要的元件就是NMOS了，MCU通过PWM信号控制NMOS的通断，来调节电机的转速。
MCU和充电电路的特写。看起来是通过二极管B3半波整流，当MCU检测到线圈中有电流，会打开充电通路给电池充电。这款牙刷在给电池充电时，按压按钮是不能让牙刷工作的，不过这也符合常理。
NMOS用的是湾湾的TSM4424，在接通状态下，漏极和源极电阻最大30毫欧，最大持续电流能到8A。一开始，按压按钮开关后，电机不转，这个NMOS管很烫，一度怀疑是烧掉了。后来发现是机械部分，因为这一段时间用的少，卡住了，当机械故障排出后，电机就又能正常转起来了。所以这个NMOS管挺关键的，要考虑电机长时间堵转的情况下也不能烧掉。
嗯，莫名其妙，又工作起来了！
国家标准 现在电动牙刷越来越普及了，厂家也越来越多，产品质量参差不齐，从几十块到上千块钱的都有。国家专门制定了产品标准，GB/T40362-2021《电动牙刷一般要求和检测方法》。正规厂家的产品，通过了国家标准的检测，质量就应该是有一定保证的。如果我们对电动牙刷的原理有个基本的认识，也可以在选择的时候有一个自己的判断。
应该是有一定保证的。如果我们对电动牙刷的原理有个基本的认识，也可以在选择的时候有一个自己的判断。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2dde98a8a8ed1a0d9968e75ac0c3939a/" rel="bookmark">
			Windows timeSetEvent定时器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Windows timeSetEvent定时器 参考微软文档
参考博客
函数描述 MMRESULT timeSetEvent( UINT uDelay， UINT uResolution， LPTIMECALLBACK lpTimeProc， DWORD_PTR dwUser， UINT fuEvent ); udelay事件延迟，以毫秒为单位。如果该值不在定时器支持的最小和最大事件延迟的范围内，则该函数返回错误。最大值是1000秒。uResolution定时器事件的解析度，以毫秒为单位。分辨率随着较小的值而增加; 分辨率为0表示定期事件应该尽可能准确地发生。但是，为了减少系统开销，您应该使用适合您的应用程序的最大值。lpTimeProc指向一个回调函数的指针，该函数在单个事件到期时调用一次，或者在周期性事件到期时定期调用。如果fuEvent指定了TIME_CALLBACK_EVENT_SET或TIME_CALLBACK_EVENT_PULSE标志，则lpTimeProc参数将被解释为事件对象的句柄。该事件将在单个事件完成后定期执行，或定期事件完成后进行。对于fuEvent的任何其他值，lpTimeProc参数是指向LPTIMECALLBACK类型的回调函数的指针。dwUser用户提供的回调数据。fuEvent定时器事件类型。该参数可能包含以下值之一。 TIME_ONESHOT在uDelay毫秒后发生一次事件。TIME_PERIODIC事件每uDelay毫秒发生一次。 回调函数 参考：微软文档
typedef void (CALLBACK TIMECALLBACK)(UINT uTimerID, UINT uMsg, DWORD_PTR dwUser, DWORD_PTR dw1, DWORD_PTR dw2); typedef TIMECALLBACK FAR *LPTIMECALLBACK; uTimerID，定时器IDuMsg，保留dwUser，用户自定义数据dw1，保留dw2，保留 头文件及库依赖 #include &lt;Windows.h&gt; #include &lt;mmsystem.h&gt; 静态库Winmm.lib，动态库Winmm.dll
示例 #include &lt;Windows.h&gt; #include &lt;iostream&gt; #include &lt;mmsystem.h&gt; #include &lt;thread&gt; void cb(UINT uTimerID, UINT uMsg, DWORD_PTR dwUser, DWORD_PTR dw1, DWORD_PTR dw2) { std::cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2dde98a8a8ed1a0d9968e75ac0c3939a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d81ebd3c31b1bdc8bfe107432e204a1a/" rel="bookmark">
			YOLOv3 | 核心主干网络，特征图解码，多类损失函数详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://zhuanlan.zhihu.com/p/76802514)
文章目录 1. 核心改进1.1主干网络1.2 特征图解码1.2.1 检测框（位置，宽高）解码1.2.2 检测置信度解码1.2.3 类别解码 1.3 训练损失函数1.3.1 正负样本定义1.3.2 损失函数 1. 核心改进 1.1主干网络 更深,更宽
从v2的darknet-19到v3的darknet-53
并且引入了ResNet的网络
结构解析
​ （1）整个v3结构里面，是没有池化层和全连接层的。前向传播过程中，张量的尺寸变换是通过改变卷积核的步长来实现的
​ （2）yolo v3输出了3个不同尺度的feature map，如上图所示的y1, y2, y3。这也是v3论文中提到的为数不多的改进点：predictions across scales，这个实际借鉴了FPN(feature pyramid networks)，采用多尺度来对不同size的目标进行检测，越精细的grid cell就可以检测出越精细的物体，小尺寸特征图用于检测大尺寸物体，大尺寸特征图检测小尺寸物体。
特征图的输出维度为 N × N × 255 = N × N × [ 3 × （ 4 + 1 + 80 ） ] N×N×255= N×N×[3×（4+1+80）] N×N×255=N×N×[3×（4+1+80）]
N×N 为输出特征图格点数，对应原网络中有三种8×8,16×16,32×32
255则对应等式右边的3×（4+1+80）
3表示一共有3个Anchor框
而对于每个框有4维预测框数值(x, y, w, h） ，1维预测框置信度confidence，80维物体类别数（COCO数据集是80类）
所以
第一层特征图的输出维度为 8×8×255
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d81ebd3c31b1bdc8bfe107432e204a1a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3217d9f688633a46165eb6cc82b2c1d9/" rel="bookmark">
			Android基础——RecycleView
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RecycleView RecycleView是什么？RecycleView使用瀑布流滚动横向滚动RecycleView点击事件 RecycleView是什么？ RecycleView是进阶版的ListView，不仅可以实现ListView的纵向滑动，还可以横向滑动和瀑布流滑动。
RecycleView使用 使用RecycleView需要在build.gradle中添加相应的依赖库：
implementation "androidx.recyclerview:recyclerview:1.2.1" 在activity_main.xml中添加RecyclerView控件
&lt;androidx.recyclerview.widget.RecyclerView android:id="@+id/recycle_view" android:layout_width="match_parent" android:layout_height="match_parent" /&gt; 准备数据，创建bean类：
public class Data { private String name; private int imageId; public Data(String name, int imageId) { this.name = name; this.imageId = imageId; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getImageId() { return imageId; } public void setImageId(int imageId) { this.imageId = imageId; } } 创建适配布局list_item.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3217d9f688633a46165eb6cc82b2c1d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13c642ad558a4f6b28ed5c30e9d0d19b/" rel="bookmark">
			聊聊身边的嵌入式：点菜机用着好好的，突然挂了，这口锅应该甩给谁？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		周末被老婆challenge了。之所以用这个英文词汇，是因为实在难以找出一个恰当的中文，来表达这个意思。挑战？盘问，质疑？臭骂？好像都不对劲儿。对了，想来想去，只有diao这个词有点儿接近，又实在是难登大雅之堂。语言真是个奇怪的东西。
事情是这样底，当时小编正专心致志地做事，老婆扔过来一个点菜宝：”看看你们这些人，设计的什么破玩意儿“。
我。。。
”按着按着屏幕就花，客人点个菜折腾半天，我看店子关门算了。。。“
我。。。
话说我招谁惹谁了。
小编正欲反驳两句，忽然想起著名情感大师的教导：千万不要跟女人讲道理。嗯，对地，家庭和谐的两个要诀就是：一，老婆永远是对的；二，没有了。
哎，餐饮这几年真是太南了，惨淡这个词已经不能够形容。
1.拆
别的忙帮不上，修修这个咱们还是强项。
这款点菜宝，用的是4.2V锂离子电池。刚看到第3行，额定电压：680mAh ? 这也是醉了。继续打开外壳。
电路比较简单，一个MCU，一个非易失存储器，一个液晶，一个无线模块，LDO，蜂鸣器。注意，下边白色外壳上粘着一块黑色海绵，这样按压PCB上的按键时候，起个缓冲作用。翻过来看一下电路板另一面。
液晶采用了薄膜连接线，这种线还是很有韧性的，在连接上使用零插拔力的连接器。白色的是覆盖在导光板上的扩散膜，LED灯珠发光从侧面进入导光板后，经过扩散膜后，光线变得很柔和均匀。
主控MCU是兆易的GD32F103RBT6，看了一下芯片手册，在standby模式下10.6uA。说实话对于电池供电的设备来说，这个电流还是稍大了一些。
存储器，华邦的25Q32，4MB的容量，看来一个小小的点菜宝，需要存储的内容还真不少。
这个设备的电池，充电需要拆下来用充电器充，这样设备上倒是简单，只需要一个LDO稳压就行了。从丝印推断这可能是一颗国产芯片HX6219B。
无线传输，选用了Silicon Labs的Si4438。此芯片发射功率最大+20dBm，接收灵敏度可以到-124dBm，功耗在待机状态下低至40nA。性能还是不错的。最早听说这家公司，是因为当年它推出51内核的高速单片机，没想到它的无线芯片用的也这么广泛。
2.433M和2.4G比较
这里牵扯出一个问题，就是在无线芯片选择上，到底是选433M，还是2.4G比较好。作为国内无需许可，免费使用的频段，两种频段各有优缺点。作为后起之秀的2.4G，因其频率高，可以更快的传输数据，适用于复杂的组网协议，如Zigbee等，功耗也相对较低。而433M应用历史很长，芯片成熟，接收灵敏度高，而且绕射和穿透能力比2.4G强很多。所以在一些数据量小，现场障碍物较多的环境，433M仍占有很大优势。
3.罪魁祸首
说了半天，差点把最重要的问题忘了。这个点菜宝的液晶屏为什么一会儿好，一会儿花呢？原来出在一个很小的设计纰漏上，你看这薄膜连线下面，有一个块儿头比较大的电容，还记得前面看到的哪个黑色海绵吧？正好压在这个上面，每按压一次按键，电容就会挤压一次薄膜连线，一两年的时间后，接触不良了。是不是叫人哭笑不得？
软件和硬件之间的甩锅，看来有个第三人选了！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bea323c7c6f86083b5ff923c6ca6e4ff/" rel="bookmark">
			AUTOSAR-CP：从软件架构到平台生态
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		纲 AUTOSAR-CP软件架构
AUTOSAR-CP软件平台
AUTOSAR-CP平台生态现状
AUTOSAR-CP平台未来展望
序 AUTOSAR-CP的软件架构和AUTOSAR-CP软件平台生态是密不可分的。前者是理论基础，是市面上所有AUTOSAR-CP软件平台在开发时的遵循的设计规范。后者是实践，是AUTOSAR-CP软件架构实际落地的工程产物，同时也是汽车软件工程师的工具和帮手。AUTOSAR-CP软件平台的重要性不言而喻，AUTOSAR-CP软件平台能够帮助公司快速、低人工成本、高质量地搭建出MCU软件系统。
本文旨在借助AUTOSAR-CP的软件架构理清汽车软件开发中AUTOSAR-CP软件平台的功能职责，然后向您介绍AUTOSAR-CP软件平台的生态现状与未来展望。
乘风波浪会有时，直挂云帆济沧海 AUTOSAR-CP软件架构 架构图 AUTOSAR (Automotive Open System Architecture)是一种标准化的汽车电子系统架构，旨在提高汽车电子系统的互操作性、可重用性和可扩展性。AUTOSAR-CP (Classic Platform)是AUTOSAR标准的一个版本。
AUTOSAR-CP软件架构图 AUTOSAR-CP采用了分层架构。AUTOSAR-CP将整个系统划分为4个主要层次：应用层(APP)、运行时环境层(RTE)、基础软件层(BSW)和硬件抽象层(MCAL)。
应用层(APP)：负责处理特定的业务逻辑，是整个系统的最顶层。一般会根据芯片承担的特定业务进行定制化开发。
运行时环境层(RTE)：是APP和BSW之间的接口层，向上层（APP层）提供与硬件无关的接口和服务，是为了隔离APP和BSW而生的。承担的是操作系统中的“为用户提供接口”功能。同时为了满足复杂的汽车电子控制的系统设计和实现，RTE还提供“通信与事件处理、状态管理与错误处理、运行时配置、代码生成与集成”等功能。
基础软件层(BSW)：提供了常见的功能库函数。通过各个功能模块共同承担的是操作系统中的“任务调度，内存管理”功能。除此以外AUTOSAR-CP作为汽车软件的专属架构，还需要在BSW层中为汽车应用场景提供丰富的软件工具，例如“通信接口、诊断服务、电源管理、安全管理、故障管理”等。
硬件抽象层(MCAL)：是对底层硬件进行抽象，使上层软件可以独立于具体的硬件平台。承担的是操作系统中的“管理硬件”功能。
AUTOSAR-CP软件平台 AUTOSAR-CP软件平台是什么 AUTOSAR-CP平台是一套用于AUTOSAR-CP开发的软件工具。它基于AUTOSAR标准（满足上文介绍的AUTOSAR架构）提供了一个集成开发环境（IDE），可以用于设计、开发、测试和验证ECU软件。该工具支持多种ECU硬件平台和通信协议，并提供了丰富的功能和工具，如代码生成器、仿真器、调试器等，可以帮助开发人员快速、高效地开发出高质量的ECU软件。
AUTOSAR-CP从软件架构到软件平台 AUTOSAR-CP软件平台的介绍相当是抽象的，为了更加清晰地介绍AUTOSAR平台内容，这里我们结合AUTOSAR-CP软件架构一起来深入剖析：
AUTOSAR-CP架构图 根据上文对AUTOSAR-CP架构的介绍：在AUTOSAR-CP标准中AUTOSAR架构被分为了应用层(APP)、运行时环境层(RTE)、基础软件层(BSW)和硬件抽象层(MCAL)四个大的层级。
应用层(APP)：负责处理特定的业务逻辑，与业务强相关。由于各个厂商的技术方案五花八门，各个项目中对MCU的开发业务需求不经相同。因此AUTOSAR-CP软件平台并不直接参与APP的内容设计，需要根据自己对业务开发的需求自行设计和实现。
运行时环境层(RTE)：AUTOSAR-CP软件平台向应用层提供接口的层级。AUTOSAR-CP软件平台在RTE层为应用层提供底层接口用以支持，因此RTE也常常被称为“软总线”。RTE实现了解耦和上下层分离，不管底层（BSW和MCAL）的配置情况如何，RTE提供的接口都是完全相同的。
基础软件层(BSW)：这一层级是AUTOSAR-CP软件平台的心脏。最核心的任务调度，内存管理，功能集成都在这一层级。AUTOSAR-CP软件平台会提供一个IDE供开发工程师根据项目需要进行配置。然后AUTOSAR-CP软件平台会根据开发工程师的配置生成BSW代码。因此在BSW层级AUTOSAR-CP软件平台的任务很重，需要：1、提供IDE以供开发工程师配置 2、获得并生成配置文件 3、根据配置文件生成BSW代码。
硬件抽象层(MCAL)：是对底层硬件进行抽象。同样的AUTOSAR-CP软件平台会提供一个IDE供开发工程师根据项目需要进行配置。与BSW层不同的是在MCAL层级AUTOSAR-CP软件平台是不会生成MCAL底层代码的，AUTOSAR-CP软件平台只负责生成配置文件去去控制MCAL底层代码，MCAL底层代码往往是由芯片厂提供和交付的。因此AUTOSAR-CP软件平台在MCAL的任务是：1、提供IDE以供开发工程师配置 2、获得并生成配置文件 3、根据配置文件控制MCAL底层代码。
做个简单的小结，AUTOSAR-CP软件平台在AUTOSAR-CP架构的各个层级中承担以下功能： AUTOSAR软件平台深度参与软件开发（流程示意图） APP层需要自主实现
RTE层需要使用AUTOSAR软件平台进行配置和生成
BSW层需要使用AUTOSAR软件平台进行配置和生成
MCAL层需要使用AUTOSAR软件平台进行配置然后使用配置文件控制底层MCAL代码
AUTOSAR-CP平台生态现状 AUTOSAR-CP生态现状 AUTOSAR-CP架构从2003年开始设计、开发，至今已经走过20个年头。期间不断有新的厂商加入、新的问题被发现和解决。经过20年的开发、测试、修复、验证，AUTOSAR-CP架构已经相当完善和成熟。
作为AUTOSAR-CP架构下的MCU开发的核心工具,AUTOSAR-CP软件平台有着开发难度高、开发工作量大、质量要求高的开发难点。但同时也有着市场前景广、利润丰厚、技术壁垒高等优点。下面将从当前AUTOSAR-CP的行业生态现状的四个特点来介绍：
市场需求大：随着汽车电子系统的不断发展和普及，AUTOSAR-CP软件平台的市场需求也在不断增加。各大汽车厂商和供应商都在积极采用AUTOSAR-CP软件平台，以提高汽车电子系统的质量和性能。
技术门槛高：AUTOSAR-CP软件平台的开发和应用需要具备一定的技术实力和经验，对于大中小企业来说，技术门槛较高，需要投入大量的人力和物力。这也是AUTOSAR-CP软件平台想要解决的开发痛点。
市场竞争激烈：AUTOSAR-CP软件平台市场竞争激烈，各大厂商和供应商都在积极开发和推广自己的产品。
市场前景广：特别是中小企业，AUTOSAR-CP的开发模式尚未普及和使用，随着汽车电子系统的不断发展，AUTOSAR-CP软件平台的市场前景广阔。一旦使用价格合理，使用体验友好，中小企业也可以借助AUTOSAR-CP软件融入市场，实现安全且快速地发展。
总的来说，AUTOSAR-CP软件平台有市场大，前景广的行业特点，大企业可以在其中搭建平台，建立领域，借此平台中小企业也可以省时省力，把研发精力放在打磨自己的核心技术上，实现双赢，促进行业内共同发展。
AUTOSAR-CP软件平台产品 Vector：达芬奇 Vector公司(来自Vector官网) Vector是一家德国的汽车电子公司，其达芬奇工具是一套用于AUTOSAR软件开发的工具集。Vector的达芬奇工具历史可以追溯到2003年，当时Vector推出了第一个版本的达芬奇工具。随着AUTOSAR标准的不断发展和完善，Vector也不断更新和升级其达芬奇工具，以满足不同厂商的需求。目前，Vector的达芬奇工具已经成为了AUTOSAR软件开发领域的领先工具之一，被广泛应用于汽车电子系统的开发和测试中。当然除了AUTOSAR-CP软件平台：达芬奇以外，Vector还提供了其他一系列的汽车电子产品和解决方案，包括CAN总线分析仪、ECU测试工具等。
Vector的看家本领是诊断与成熟，因此在过去的很长一段时间里达芬奇平台工具凭借其对诊断的强力支持加上工具链完善，部署应用广等特点妥妥占据平台市场C位。但其高昂的价格，售后体验差也让不少公司望而却步。是的，达芬奇的lincense多且复杂，收费及其昂贵。花高价买来的是成熟的软件和详尽的文档，但不包括贴心的管家，几乎不支持定制化，如果有问题想和Vector沟通则会发现反馈周期巨长。完美地诠释了什么叫“Vector's roof,Vector's rules”
EB:tresos EB同样是一家来自德国的汽车软件公司，全称是Elektrobit。在2006年时推出自己的第一款AUTOSAR-CP软件平台工具tresos。同样的tresos是一套完整的工具包，能够胜任AUTOSAR-CP开发中的RTE、BSW、MCAL多个层级的开发工作。
tresos的看家本领是底层支持。tresos与芯片厂深度合作，MCAL层的配置一直是他的强项，开发者不但可以使用tresos的全套AUTOSAR-CP解决方案，还可以根据自己的需求选择部分服务，例如可以只使用tresos的MCAL配置服务再搭配其他公司的BSW+RTE产品。
相比于达芬奇，tresos在BSW的诊断和整体AUTOSAR-CP软件平台的成熟度方面都要稍逊一些，但是由于其在MCAL配置方面的专长：tresos实现MCAL+达芬奇实现BSW&amp;RTE+自主研发APP在很长时间都是头部车企的通用解决方案。
普华：ORIENTAIS
近年来随这国内的电动造车热，与雨后春笋的国内新平台新势力不同，普华是在2010年就成为了AUTOSAR协会成员是最早一批接受AUTOSAR架构的公司之一（当然经纬恒润是最早的，在07年就已成为AUTOSAR协会成员），同时也是中电科旗下的老弟。融入国际体系+国家队大力支持的打法在普华身上体现得淋漓尽致。并未辜负期望的是，普华的产品和发展确实是令人骄傲，前不久获得了AISL D的安全认证，也证明了其在保证汽车功能安全上的底蕴和实力。
普华的看家本领是专精细分领域。在整车网络测试特别是CAN\LIN总线方面普华有相当的实力。但普华的软件产品同样也是价格不菲，更加致命的是对全AUTOSAR系统的支持力度不够，所以近几年普华也是在健全平台方面持续发力，在不太擅长的领域与其他厂商合作，尝试建立一套全面且完善的解决方案。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bea323c7c6f86083b5ff923c6ca6e4ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/530d52840ae4b7f80d2be0a81f1bf5df/" rel="bookmark">
			iOS AVAudioRecorder简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. AVAudioRecorder应用 AVAudioRecorder的主要属性
// 是否在录制中 @property(readonly, getter=isRecording) BOOL recording; // 录音本地文件地址 @property(readonly) NSURL *url; // 录音文件配置 @property(readonly) NSDictionary&lt;NSString *, id&gt; *settings; // 录音文件当前时间，只有在录音时有效 @property(readonly) NSTimeInterval currentTime; // 设备当前时间 @property(readonly) NSTimeInterval deviceCurrentTime; // AVAudioRecorder回调 @property(weak, nullable) id&lt;AVAudioRecorderDelegate&gt; delegate; // 是否启用音频测量， 默认是NO @property(getter=isMeteringEnabled) BOOL meteringEnabled; AVAudioRecorder的主要方法
// 初始化方法 - (nullable instancetype)initWithURL:(NSURL *)url settings:(NSDictionary&lt;NSString *, id&gt; *)settings error:(NSError **)outError; // 准备开始录音 - (BOOL)prepareToRecord; // 立即开始录音 - (BOOL)record; // 在一段时间之后开始录音，time与deviceCurrentTime相比较 - (BOOL)recordAtTime:(NSTimeInterval)time; // 开始录音，并只录制一段时间 - (BOOL)recordForDuration:(NSTimeInterval) duration; // 在一段时间之后开始录音，并只录制一段时间 - (BOOL)recordAtTime:(NSTimeInterval)time forDuration:(NSTimeInterval) duration; // 暂停录音 - (void)pause; // 停止录音，关闭录音文件 - (void)stop; // 删除录音文件，需在stop方法后 - (BOOL)deleteRecording; // 更新音频测量值，meteringEnabled为YES时才可以获得音频分贝等信息 - (void)updateMeters; // 获得指定声道的分贝峰值，在此之前调用updateMeters方法 - (float)peakPowerForChannel:(NSUInteger)channelNumber; // 获得指定声道的分贝平均值，在此之前调用updateMeters方法 - (float)averagePowerForChannel:(NSUInteger)channelNumber; AVAudioRecorder录制后将音频保存到本地文件中
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/530d52840ae4b7f80d2be0a81f1bf5df/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bac2fe8c7466f5b6e599485c87b45fd5/" rel="bookmark">
			npm设置安装路径
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 npm设置安装路径 先查看当前安装路径 npm config ls 更改安装路径 npm config set prefix “D:\software\node_golbel” npm config set cache “D:\software\node_cache” 查看是否更改完 npm config ls 尝试安装一个包 npm i -g umi 安装完后到更改的目录查看是否存在，不存在说明设置有误或者其它原因
尝试使用 根据安装的包测试下是否能正常使用如果出现xxx不是内部或外部命令考虑环境变量没有设置 配置环境变量 下面省略 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c2df1ec9f9e038ec052ebbca02a35c1/" rel="bookmark">
			【【萌新的SOC学习之AXI接口简介】】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		萌新的SOC学习之AXI接口简介 AXI总线的初步介绍
AXI 总线是 ARM AMBA 一部分 （高级可扩展接口）
AMBA(高级微控制器总线架构） ：开放的片内互联的总线标准，能再多主机设计中实现多个控制器和外围设备之间的连接和管理。
AXI（高级扩展接口）
（AXI4：（For high-performance memory-mapped requirements.）主要面向高性能地址映射通信的需求，是面向地址映射的接口，允许最大 256 轮的数据突发传输；
AXI4-Lite：（For simple, low-throughput memory-mapped communication ）是一个轻量级的地址映射单次传输接口，占用很少的逻辑单元。
AXI4-Stream：（For high-speed streaming data.）面向高速流数据传输；去掉了地址项，允许无限制的数据突发传输规模。）
AXI4（AXI4-Full）： 用于高性能的存储器映射需求；
（存储器映射：主机再对从机进行读写操作时，指定一个目标地址，这个地址就是对应系统存储空间的地址，表示对该空间进行读写操作）；
AXI4-Lite ： 简化版的AXI4接口
用于低吞吐率存储器映射的通信
AXI4-Stream（ST） ： 用于高速的流数据通信
AXI4（AXI4-Full）（支持突发256），和AXI4-Lite（1个数据） 属于存储器映射 需要指定地址
AXI4-Stream（ST）不属于存储器映射，它的突发长度不受限制， 用于数据流传输大量数据
AXI4 和 AXI4-lite 包含5个不同的通道
（1）读地址通道，包含 ARVALID, ARADDR, ARREADY 信号；
（2）读数据通道，包含 RVALID, RDATA, RREADY, RRESP 信号；
（3）写地址通道，包含 AWVALID，AWADDR, AWREADY 信号；
（4）写数据通道，包含 WVALID, WDATA，WSTRB, WREADY 信号；
（5）写应答通道，包含 BVALID, BRESP, BREADY 信号；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c2df1ec9f9e038ec052ebbca02a35c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d890ef2190c4c748224d1972b0b8375d/" rel="bookmark">
			STM32学习---编码器篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是编码器？
本文所讲的是带有编码器的有刷直流电机，有AB相或者ABZ相，AB相为电机转动时输出的波形，用来计数，计算电机转速，电机转动一圈还输出一个零位脉冲Z，不同电机相位有所变化，但AB相总是不变的。
定时器带有编码器模式，且只有通道1和通道2有，所以配置时要注意！！！
编码器技术规则，可详见电机控制基础——定时器编码器模式使用与转速计算 - 知乎 (zhihu.com)
000：禁止从模式––如果 CEN =“1”，预分频器时钟直接由内部时钟提供。001：编码器模式 1––计数器根据 TI1FP1 电平在 TI2FP2 边沿 递增/递减计数。（ TI1FP1 电平指的是高电平有效或是低电平有效）010：编码器模式 2––计数器根据 TI2FP2 电平在 TI1FP1 边沿 递增/递减计数。011：编码器模式 3––计数器在 TI1FP1 和 TI2FP2 的边沿计数，计数的方向取决于另外一个信号的电平。 以编码器5举例：从中间值32767开始计数（很多都是从0开始计数，都没关系）
Encoder_Init_TIM5(0,65535);	//编码器不分频 arr最大----main中调用 /******************************************** * @brief 把TIM5初始化为编码器接口模式 * @param psc 预分频系数 * @param arr 自动重装载值 * @retval None ********************************************/ void Encoder_Init_TIM5(uint16_t psc,uint16_t arr)	{ TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure; TIM_ICInitTypeDef TIM_ICInitStructure; GPIO_InitTypeDef GPIO_InitStructure; NVIC_InitTypeDef NVIC_InitStructure; RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM5, ENABLE); //使能定时器4的时钟 RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA|RCC_APB2Periph_AFIO, ENABLE); //使能PB端口时钟 GPIO_StructInit(&amp;GPIO_InitStructure); GPIO_InitStructure.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d890ef2190c4c748224d1972b0b8375d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f6a824fa944bfe169a79f17adfcc7a0/" rel="bookmark">
			C&#43;&#43;程序设计初步——关系运算和逻辑运算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++中有众多的操作符来对其C++的程序内容进行运算，有：
3.6 关系运算和逻辑运算
C++中若要比较数据时可以使用关系运算符，同样在进行逻辑层面的运算时，用逻辑运算符将逻辑量进行连接。
3.6.1 关系运算和关系表达式
C++的关系运算符：
&lt;小于&lt;=小于或等于&gt;大于&gt;=大于或等于==等于!=不等于 前4种关系运算符（ &lt; &lt;= &gt; &gt;=）的优先级别相同，后2种的也相同，但前4种的关系运算符要大于后2种。
可以看到关系运算符的优先级在6、7的位置。
一些关系运算的等效：
c&gt;a+b等效于c&gt;(a+b)a&gt;b==c等效于（a&gt;b）==ca==b&lt;c等效于a==(b&lt;c)a=b&gt;c 等效于a=(b&gt;c)
用关系运算符将两个表达式连接起来的式子，称关系表达式。
一般形式 ：表达式 关系表达式 表达式
表达式可以是算数表达式或关系表达式、逻辑表达式、赋值表达式、字符表达式：
一些合法的形式： a&gt;b a+b&gt;b+c (a==3)&gt;(b==5) 'a'&lt;'b' (a&gt;b)&gt;(b&lt;c)
任何表达式都应该有一个确定的值，但关系表达式的值是一个逻辑值，即“真”或“假”。在C和C++中都用数值1代表“真”，用0代表“假”。
d=a&gt;b //d得到的值为1 f=a&gt;b&gt;c //f得到的值为0（因为"&gt;"运算符是自左至右，先执行"a&gt;b"得值为1） //再执行关系运算"1&gt;c"，得值0，赋给f 3.6.2 逻辑常量和逻辑变量
C语言没有提供逻辑型数据，关系表达式的值用数值1和0代替。C++增加了逻辑型数据。逻辑型常量只有两个，即false （假）和true（真）。逻辑型变量要用类型标识符bool（布尔变量）来定义。
3.6.3 逻辑运算和逻辑表达式
C++提供3种逻辑运算符：
（1）&amp;&amp; 逻辑与 （相当于其他语言的AND）
（2） | | 逻辑或 （相当于其他语言的OR）
（3） ！ 逻辑非 （相当于其他语言的NOT）
逻辑运算的“真值表”：
优先次序： （1）！（非）---&gt; &amp;&amp;（与）---&gt; | | (或)
（2）逻辑运算符中的“&amp;&amp;”和“||”低于关系运算符，“ ！”高于算术运算符。
同样将两个关系表达式用逻辑运算符连接起来就成为了一个逻辑运算符，
一般形式：表达式 逻辑运算符 表达式
编写程序：判断闰年
#include&lt;iostream&gt; using namespace std; int main() { int year; bool leap; cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f6a824fa944bfe169a79f17adfcc7a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/472d3a4b616b38c901df4f3e29fe2927/" rel="bookmark">
			CubeMX配置STM32F103C8T6多路ADC配合DMA采集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
CubeMX配置工程
配置时钟
​编辑
配置串口
配置LED灯
配置ADC
代码编写
重定向
定义如下全局变量
ADC中断
实物展示
工程文件
CubeMX配置工程 配置时钟 配置主频和ADC采样时钟
把主频设置为72M，经过6分频后ADC采样时钟为12M
配置串口 开启串口作为显示输出
配置LED灯 配置ADC 笔者把ADC1的所有通道都打开了，包括一个内部温度采集也开启了，这样就是有11路adc需要采集
把Number Of Conversion设置为11再分别设置每个rank采集ADC的哪个通道
每个通道采样239.5个cycle约为20us，再加上转换时间为21us，采样率大约为47.6KHz，采样11个通道耗时大约231us即0.23ms。开启DMA，选择周期模式，数据宽度为半字
代码编写 重定向 将串口重定向代码复制到usart.c文件底部，添加stdio.h头文件
/** * 函数功能: 重定向c库函数printf到DEBUG_USARTx * 输入参数: 无 * 返 回 值: 无 * 说 明：无 */ int fputc(int ch, FILE *f) { HAL_UART_Transmit(&amp;huart1, (uint8_t *)&amp;ch, 1, 0xffff); return ch; } /** * 函数功能: 重定向c库函数getchar,scanf到DEBUG_USARTx * 输入参数: 无 * 返 回 值: 无 * 说 明：无 */ int fgetc(FILE *f) { uint8_t ch = 0; HAL_UART_Receive(&amp;huart1, &amp;ch, 1, 0xffff); return ch; } 勾选Use MicroLIB
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/472d3a4b616b38c901df4f3e29fe2927/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/712e9e8a00b4d3ef21a22be26685c866/" rel="bookmark">
			【Java】Excel百万级别数据的导入和导出【详细代码】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		代码层级结构 DurationAspect import org.apache.commons.logging.Log; import org.apache.commons.logging.LogFactory; import org.aspectj.lang.JoinPoint; import org.aspectj.lang.ProceedingJoinPoint; import org.aspectj.lang.annotation.Around; import org.aspectj.lang.annotation.Aspect; import org.springframework.boot.SpringApplication; import org.springframework.stereotype.Component; import java.time.Duration; @Component @Aspect public class DurationAspect { private static final Log logger = LogFactory.getLog(DurationAspect.class); @Around("execution(public void com.zhouyu.controller.SalariesController.exportExcel*(..))") public void exportExcel(ProceedingJoinPoint joinPoint) { long startTime = System.nanoTime(); logger.info("开始导出：" + joinPoint.getSignature().getName()); try { joinPoint.proceed(); } catch (Throwable e) { throw new RuntimeException(e); } finally { Duration time = Duration.ofNanos(System.nanoTime() - startTime); logger.info("导出结束，消耗了：" + time.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/712e9e8a00b4d3ef21a22be26685c866/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/131a0e637716908b2da7fb835be7520a/" rel="bookmark">
			【移植代码】matlab.engine报错、numpy&#43;mkl安装、Qt platform plugin报错总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 numpy报错numpy安装PyQt5报错matlab.engine无法加载确认配置版本进行配置 matlab文件路径缺失vscode无法debug3.7以下版本总结 今天的任务是复现师姐的代码，代码在服务器的环境下可以跑，而我要做的，就是将环境和源码配置好，在我自己的电脑上跑起来。本以为只是一个虚拟环境复制的工作，没想到有这么大的坑。 已经将服务器上的整个虚拟环境evns的文件夹拷贝了过来，并进入该环境测试。
numpy报错 在python和numpy版本不匹配的时候，经常会出现莫名的报错，此时需要卸载重装：
numpy卸载的时候往往要卸载两遍
用pip uninstall numpy命令卸载的时候，卸载过后可能发现pip list中还有一个版本，需要再卸载一次。
numpy安装 直接用pip install安装的话可能会自动安装最新版本的，还是对不上，因此需要参考这篇博客的做法。用numpy+mkl和scipy的第三方库：https://www.lfd.uci.edu/~gohlke/pythonlibs/
选择自己的环境对应的版本下载即可，cp36即python=3.6，win_amd64即win是64位。
下载好之后，把这两个包放在python安装的Scripts目录下。
如果是自己的虚拟环境，那么就在自己虚拟环境对应的Scripts目录下。
安装时，首先要在终端将工作空间定位到我们放安装包的目录下，然后再进行安装。
PyQt5报错 调试的时候会有这种报错。
用网上的其他方法都不太好
解决办法：检查pip list 是否缺少PyQt5
pip install PyQt5 pip install pyqt5-tools 记着更换源会快一些
pip install --user -i https://pypi.tuna.tsinghua.edu.cn/simple pyqt5 pip install --user -i https://pypi.tuna.tsinghua.edu.cn/simple pyqt5-tools 不知道在服务器上怎么跑起来的，不过在自己电脑上查看pip list确实没有PyQt5。
matlab.engine无法加载 因为代码中有涉及用python执行matlab的.m文件的情形，因此在反复matlab.engine报错之后，突然意识到，自己电脑上python和matlab是没有像服务器上的那样已经配合好了的。
详细请看这篇博客。
确认配置版本 python版本和matlab版本是有一一对应关系的，否则无法建立联系，对应关系见下。https://www.mathworks.com/content/dam/mathworks/mathworks-dot-com/support/sysreq/files/python-compatibility.pdf
python 与 matlab 版本对应关系
由图可知Python3.8解释器需要 matlab2020b以上版本，Python3.7解释器需要 matlab2019a以上版本等等依此类推。
根据这张图确定你的python解释器去安装对应的matlab版本。
进行配置 matlab的安装方法就不累赘了，这里已默认你安装好了对应版本的matlab。
matlab里面找到python engine
大部分python库都是通过pip来安装的，而matlab自R2014b以后引入了MATLAB engine这一功能, 提供了对Python的支持，matlab.engine的安装不是通过pip安装的。
matlab安装路径\extern\engines \python 文件夹
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/131a0e637716908b2da7fb835be7520a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/036497dea783006c684719d988aeebaa/" rel="bookmark">
			读取描述失败，错误代码：2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第⼀步，以管理员⾝份进⼊windows命令⾏窗⼝，并进⼊到mysql/bin⽬录下
第⼆步，执⾏sc delete mysql，以删除现有的mysql服务（执⾏后，可能会出现错误信息，不要管他，继续下⼀步）第三步，重新启动计算机
第四步，重复第⼀步，执⾏mysqld -install以安装mysql 服务，这个时候应该出现安装服务成功的提⽰信息
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b98bd2349cce4f79b6758edacb37fea/" rel="bookmark">
			JS如何判断文字是否溢出（被ellipsis）？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果想要文本超出宽度后用省略号省略，只需要加上以下的css就行了。
.ellipsis { overflow: hidden; text-overflow: ellipsis; white-space: nowrap; } 3行css搞定，但是问题来了：如果我们想要当文本被省略的时候，也就是当文本超出指定的宽度后，鼠标悬浮在文本上面才展示popper，应该怎么实现呢？
CSS帮我们搞定了省略，但是JS并不知道文本什么时候被省略了，所以我们得通过JS来计算。接下来，我将介绍几种方法来实现JS计算省略。
createRange 我发现Element-plus表格组件已经实现了这个功能，所以就先来学习一下它的源码。
源码地址：https://github.com/element-plus/element-plus/blob/dev/packages/components/table/src/table-body/events-helper.ts
// 仅仅粘贴相关的 const cellChild = (event.target as HTMLElement).querySelector('.cell') const range = document.createRange() range.setStart(cellChild, 0) range.setEnd(cellChild, cellChild.childNodes.length) let rangeWidth = range.getBoundingClientRect().width let rangeHeight = range.getBoundingClientRect().height /** detail: https://github.com/element-plus/element-plus/issues/10790 * What went wrong? * UI &gt; Browser &gt; Zoom, In Blink/WebKit, getBoundingClientRect() sometimes returns inexact values, probably due to lost precision during internal calculations. In the example above: * - Expected: 188 * - Actual: 188.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b98bd2349cce4f79b6758edacb37fea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f27ddd69b79cfb77cfe4a88c208e22b3/" rel="bookmark">
			关于visualstudio中C语言出现unsafe以及输出为问号的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很多朋友和我反应在使用vs进行C语言编程时出现了莫名其妙报错，以及调试通过后却输出问号的情况
其本质其实是，代码安全形式如scanf_s与scanf一类安全形式的混用以及vs本身对于数据的认同度
下面教大家一个很好用的代码可以巧妙的规避以上问题
#define _CRT_SECURE_NO_WARNINGS 这串代码是一个预处理指令，用于禁用某些编译器警告。包括但不限于安全形式的混用
一般用在代码的开头，例如
#define _CRT_SECURE_NO_WARNINGS #include &lt;stdio.h&gt; int main() { printf("HelloWorld"); return 0; } 这样便可以解决代码的unsafe以及大部分调试过后输出结果为问号的情况
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33c842bc4b6e3547a31d76249399c4f3/" rel="bookmark">
			Redis报错：WRONGTYPE Operation against a key holding the wrong kind of value
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、报错原因：redis获取数据的执行命令与redis服务器中存储数据的类型存在冲突。 例子: 数据库中有一个key的数据存储的是Hash类型的，但执行数据操作的时候，却使用了string类型的操作方法。
2、各个数据类型的增删改查方法 Redis增删改查操作-CSDN博客 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bcecad49a51a9ccf4adf2353fa913692/" rel="bookmark">
			vue js 实现页面在浏览器全屏切换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求：
在浏览器中点击按钮实现页面的全屏与非全屏的切换。
如图：
全屏前：
全屏后：
具体实现代码如下：
html：
&lt;template&gt; &lt;div class="development-history" id="echarts-wrap"&gt; &lt;div class="btn" @click="tabFullScreen"&gt;切换全屏&lt;/div&gt; &lt;div class="echarts-chart" id="chart" ref="chart"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/template&gt; JS：
// 实现全屏的方法 requestFullScreen(){ let element = document.getElementById("echarts-wrap"); var requestMethod = element.requestFullScreen || //W3C element.webkitRequestFullScreen || //Chrome element.mozRequestFullScreen || //FireFox element.msRequestFullScreen; //IE11 if (requestMethod) { requestMethod.call(element); } else if (typeof window.ActiveXObject !== "undefined") { //for Internet Explorer var wscript = new ActiveXObject("WScript.Shell"); if (wscript !== null) { wscript.SendKeys("{F11}"); } } }, //退出全屏 这里没有用到 ，esc键和F11可以直接退出， exitFull() { // 判断各种浏览器，找到正确的方法 var exitMethod = document.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bcecad49a51a9ccf4adf2353fa913692/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5dc5a73ba92574647b93ff8443d54329/" rel="bookmark">
			【React启动端口设置】不用node_modules永久设置端口方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		不用修改 node_modules/react-scripts/scripts/start.js！
也不用安装 cross-env 插件！
参考来自 Changing default Host and Port in React.JS – TecAdmin
非常简单的方法
在根目录下创建 .env 文件
输入 PORT=xxx 保存即可！
原理：package.json 中，scripts.start 对应的命令是 `react-scripts start` ，于是我们找到 node_modules/react-scripts/scripts/start.js 文件的 55 行附近：
如果 process.env.PORT 未设置，项目就会默认在 3000 端口启动。
目前测试过的有效方法，就是新建 .env 文件，内容设置端口，重启项目立即生效。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a45e56ff7854923e7e694cba49eb9685/" rel="bookmark">
			Element-ui el-table 使用 SortableJS 实现表格拖拽
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		sortablejs文档
1、在项目目录下安装 sortablejs： npm install sortablejs --save 2、在要实现表格拖拽的文件中引入 sortablejs： import Sortable from 'sortablejs' 3、应用 &lt;template&gt; &lt;el-table :data="tableData"&gt; &lt;el-table-column label="用户Id" prop="id" align="center" /&gt; &lt;el-table-column label="用户名" prop="username" align="center" /&gt; &lt;/el-table&gt; &lt;/template&gt; &lt;script&gt; import Sortable from "sortablejs"; export default { data() { return { tableData: [{username:"a",id:1},{username:"b",id:2},{username:"c",id:3},{username:"d",id:4},], }; }, mounted() { this.initSort(); }, methods: { initSort() { const el = document.querySelectorAll('.el-table__body-wrapper &gt; table &gt; tbody')[0] // const sortable = new Sortable(el, options); // 根据具体需求配置options配置项 const sortable = new Sortable(el, { // number 定义鼠标选中列表单元可以开始拖动的延迟时间； delay: 0, onEnd: (evt) =&gt; { // 监听拖动结束事件 console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a45e56ff7854923e7e694cba49eb9685/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6598b00c3479883c7e5df93a6aca1ff/" rel="bookmark">
			[C&#43;&#43;学习笔记8]:STL学习之string
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一. STL概括1.1 STL的六大组件 二. string2.1 编码2.2 string接口函数2.3 string部分接口模拟实现*总览:*成员变量:构造,拷贝构造,析构函数:赋值重载: string&amp; operator=(const string&amp; s)[]重载: char&amp; operator[](size_t pos)迭代器: iterator尾插: push_back()和append()尾插: string&amp; operator+=(const char* str)关系运算符重载: &lt; == &gt; != &lt;= &gt;=扩容: reserve()和resize():pos位置插入: insert()删除pos位置字符: erase()查找: find()交换: swap()输出c语言字符串: c_str其他接口: size(),capacity(),clear()*全局函数(非成员函数)*流提取(流输出): ostream&amp; operator&lt;&lt;(ostream&amp; out,const string&amp; s)流插入(流输入): istream&amp; operator&gt;&gt;(istream&amp; in, string&amp; s) 2.4 其他 注:这里是初学者的笔记,可能会出错,如果有错,希望你能提醒我. 一. STL概括 STL(standard template libaray-标准模板库)：是C++标准库的重要组成部分，不仅是一个可复用的组件库，而且
是一个包罗数据结构与算法的软件框架。
1.1 STL的六大组件 二. string string是一种对字符串管理的类.
2.1 编码 1.ASCII编码
大小为一个char,从0~127;
2.unicode
为了解决ASCII只能编码英文字符的问题;
编码方式
统一码是国际组织制定的可以容纳世界上所有文字和符号的字符编码方案。统一码用数字0-0x10FFFF来映射这些字符，最多可以容纳1114112个字符，或者说有1114112个码位。码位就是可以分配给字符的数字。UTF-8、UTF-16、UTF-32都是将数字转换到程序数据的编码方案。
UTF-8兼容ASCII
字符或者汉字存储在计算机中是以二进制的形式存储,存入的编码格式和读取的编码格式要对应才能显示原来信息,否则就会出现乱码.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a6598b00c3479883c7e5df93a6aca1ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a87a31217940122b1c9db398e274b0e/" rel="bookmark">
			[linux学习笔记1]:常见指令与权限
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1. 初识linux**常用快捷键:****基础知识:**管道:重定向:shell外壳程序:打包压缩/解压:权限:修改权限:chown chgrp chmod sudo指令权限掩码:粘滞位:补充知识: 注意:初学者,可能有错误,望提醒,谢谢 1. 初识linux linux是操作系统内核,最初由Linus Benedict Torvalds创作,后开源代码,由全世界的程序员一起创作.
向伟大的开源精神致敬!
linux操作系统的发行版本常见的有:Debian/Ubuntu/Kali Linux/CentOS等;
这里使用CentOS 7学习;
为了方便,使用服务器学习linux;
登陆方式:
1.使用xshell软件登陆
2.使用终端登陆
常用快捷键: 复制: ctrl + insert (有些同学的 insert 需要配合 fn 来按)
粘贴: shift + insert
退出:ctrl + d
终止异常命令:ctrl + c
界面全屏:alt + enter
基础知识: linux目录结构:
linux的目录结构,本质是一颗多叉树:
1.目录(树上的节点)
2.文件或者空目录(叶子节点)
[kozen@VM-4-7-centos /]$ pwd / [kozen@VM-4-7-centos /]$ ls bin dev lib media proc run sys var boot etc lib64 mnt public sbin tmp data home lost+found opt root srv usr linux下一切皆文件的设计思路:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5a87a31217940122b1c9db398e274b0e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83c90df15b449dfa37b8fb709bb2af2c/" rel="bookmark">
			JS-树：二叉树后序遍历
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、后序遍历-递归二、后序遍历-队列总结 前言 最近总结一下树的算法，研究树相关的知识。
一、后序遍历-递归 1、左右根
2、如下输入是：4 5 2 6 7 3 1
// 前序遍历 const tree = { val: '1', left: { val: '2', left: { val: '4', left: null, right: null }, right: { val: '5', left: null, right: null }, }, right: { val: '3', left: { val: '6', left: null, right: null }, right: { val: '7', left: null, right: null }, }, } // 前序遍历 console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/83c90df15b449dfa37b8fb709bb2af2c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45c479d4da4c2ba44335cef3460414e1/" rel="bookmark">
			JS-树：二叉树中序遍历
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、中序遍历-递归二、中序遍历-队列总结 前言 最近总结一下树的算法，研究树相关的知识。
一、中序遍历-递归 1、左中右
2、如下输入是：4 2 5 1 6 3 7
// 前序遍历 const tree = { val: '1', left: { val: '2', left: { val: '4', left: null, right: null }, right: { val: '5', left: null, right: null }, }, right: { val: '3', left: { val: '6', left: null, right: null }, right: { val: '7', left: null, right: null }, }, } // 前序遍历 console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/45c479d4da4c2ba44335cef3460414e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68e80aea926b8c06965cce2bba465816/" rel="bookmark">
			虚拟机上的ubuntu安装RT系统&#43;安装IGH
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		虚拟机上的ubuntu安装RT系统+安装IGH 准备工作ubuntu 内核+对应版本的补丁预备软件安装 开始安装，打补丁-&gt;编译-&gt;安装配置内核准备编译修改启动时选择的内核安装IGH参考 准备工作 在使用EtherCat的时候，公司为方便测试，使用开源的主站IGH，那么需要安装IGH。IGH的运行环境是LINUX，对操作系统有实时性的要求。解决的具体思路是：在ubuntu环境下编译一个修改的linux内核，也就是对内核打实时补丁，也就是接下来的第一步工作。
ubuntu 内核+对应版本的补丁 原系统：Ubuntu 20.04.2LTS
原内核版本：不管，一般比接下来使用的内核高
目标内核：linux-5.4.28-rt19
下载：
链接: https://pan.baidu.com/s/16vq104VM1EvP_t6QrTTU5A?pwd=r1wm
提取码: r1wm
预备软件安装 安装图形界面
sudo apt-get install -y build-essential kernel-package libncurses5-dev 安装编译工具
sudo apt-get install bison sudo apt-get install flex sudo apt-get install bc sudo apt-get install libelf-dev sudo apt-get install libncurses-dev sudo apt-get install libssl-dev 进入root模式
#第一次进入root模式需要设置密码 sudo passwd root #上步完成 su 开始安装，打补丁-&gt;编译-&gt;安装 1.找到刚刚下载文件的文件夹
cd ~/Downloads 2.选择一个地方为编译做准备，编译结束大小在20G左右
可以查看当前文件夹大小
df -h 3.转到编译目录
#创建rt_linux_build mkdir rt_linux_build #改变目录到rt_linux_build cd ~/rt_linux_build #复制linux-5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/68e80aea926b8c06965cce2bba465816/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16169e7ed32f677453df955db0e159ca/" rel="bookmark">
			知识图谱系列4：neo4j学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这是一篇还不错的教程，我将会针对其中的Cypher语法在这篇帖子内提出问题，以便学习与复习。
MATCH是什么操作？
小括号()代表什么？（n）代表什么？
MATCH (n) DETACH DELETE n是什么含义？
CREATE是什么操作？
CREATE (n:Person {name:‘John’}) RETURN n是什么意思？
CREATE (n:Location {city:‘Miami’, state:‘FL’})是什么意思？
[]代表什么？
MATCH (a:Person {name:‘Liz’}),
(b:Person {name:‘Mike’})
MERGE (a)-[:FRIENDS]-&gt;(b)
是什么含义？
关系可以添加属性吗？如何添加？
10.MATCH (a:Person {name:‘John’}), (b:Location {city:‘Boston’}) MERGE (a)-[:BORN_IN {year:1978}]-&gt;(b)
是什么含义？
MATCH (a:Person)-[:BORN_IN]-&gt;(b:Location {city:‘Boston’}) RETURN a,b
这是什么语句？代表什么含义？
MATCH (a)–&gt;() RETURN a和MATCH (a)–() RETURN a的区别是什么？MATCH (a)-[r]-&gt;() RETURN a.name, type®的含义是什么？如何增加/修改节点的属性？如何删除节点的属性？如何删除节点？DELETE和REMOVE的区别是什么？MATCH (a:Person {name:‘Todd’})-[rel]-(b:Person) DELETE a,b,rel使什么含义？ 接着，下载好Neo4j后，实操试了一下。
语句大小写皆可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd356e702bcf3faeb95cf6886aa04f0f/" rel="bookmark">
			Python带时区日期与UTC时间互转
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通过正则匹配带时区格式字符串进行格式校验后转换为时间类型
使用datime类型的astimezone方法获得不同时区的时间字符串
import re from datetime import datetime def format_datestr_with_zone(datetime_str: str): """ 格式化带时区时间字符串，返回datetime类型时间 :param datetime_str: 2022-06-14T15:16:31+00:00 :return: datetime """ format_ = '%Y-%m-%d %H:%M:%S' if '.' in datetime_str: format_ = format_ + '.%f' zone_ = re.search(r'[+-]\d{2}:\d{2}', datetime_str) if zone_: format_ = format_ + '%z' if 'T' in datetime_str: format_ = format_.replace(' ', 'T') return datetime.strptime(datetime_str, format_) print(format_datestr_with_zone('2022-06-14T15:19:39')) # datetime.datetime(2022, 6, 14, 15, 19, 39) print(format_datestr_with_zone('2022-06-14T15:19:39.000+00:00')) # datetime.datetime(2022, 6, 14, 15, 19, 39, tzinfo=datetime.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd356e702bcf3faeb95cf6886aa04f0f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3ae95227a60f4b9692ecf394468183f/" rel="bookmark">
			STM32F1常用外设介绍（超详细35000字介绍）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		STM32学习笔记 文章目录 STM32学习笔记GPIO配置步骤步骤：常用的RCC开启始终函数 常用的GPIO函数复位GPIO外设函数复位AFIO外设函数初始化GPIO口函数给GPIO结构体变量赋一个默认值函数GPIO的输出函数把制定的端口设置为高电平:函数把指定的端口设置为低电平对根据第三个参数的值来设置电平对GPIOx 16个端口同时进行写入操作：GPIO的输入函数读取输入数据寄存器某个端口的输入值，返回值是高低电平函数读取GPIO的每一位的值，返回值是16位的数据,每一位代表一个端口值读取输出数据寄存器的某一位读取整个输出寄存器 程序示例 中断EXTI配置步骤复位AFIO外设锁定GPIO配置函数锁定引脚的配置，防止意外更改配置AFIO的事件输出功能函数配置引脚重映射函数配置AFIO的数据选择器恢复上电默认的状态函数根据结构体配置EXTI外设函数给传入的结构体参数赋一个默认值函数软件触发外部中断函数获取指定的标志位函数对置1的标志位进行清除函数在中断函数中获取标志位函数清除中断挂起标志位函数中断分组函数根据结构体里面的参数初始化NVIC函数设置中断向量表函数系统低功耗配置函数 程序示例 定时器主从触发模式开启定时器步骤定时器常用的库函数恢复缺省配置函数时基单元初始化函数把结构体变量赋一个默认值函数使能计数器函数使能中断输出信号函数选择内部时钟函数选择ITRx其他定时器的时钟函数选择TIx捕获通道的时钟函数选择ETR通过外部时钟模式1输入的时钟函数选择ETR通过外部时钟模式2输入的时钟函数单独配置ETR引脚的预分频器、极性、滤波器这些参数的函数单独写预分频值函数改变计数器的计数模式函数自动重装器预装功能配置函数给计数器写入一个值函数给自动重装器写入一个值函数获取当前计数器的值函数获取当前预分频器的值函数 程序示例： 输出比较输出比较常用的函数配置输出比较函数给输出比较结构体赋一个默认值函数配置强制输出模式函数配置CCR寄存器的预装功能函数配置快速使能函数外部事件时清除REF信号函数单独设置输出比较的极性函数单独修改输出使能参数函数选择输出比较模式函数单独更改CCR寄存器的值的函数使用高级定时器输出PWM时调用使能主输出函数引脚重映射 程序示例 输入捕获频率测量：测频法：在闸门时间T内，对上升沿计次，得到N，则频率测周法：两个上升沿内，以标准频率计次，得到N，则频率主从触发模式：（主模式、从模式和触发源选择三个功能的简称）输入捕获基本结构： 输入捕获程序示例 PWMI基本结构：单独写入PSC的函数输入捕获步骤输入捕获常用函数结构体配置输入捕获单元的函数另一个输入捕获的初始化函数给输入捕获结构体赋一个初始值函数选择输入触发源TRGI函数选择输出触发源TRGO函数选择从模式函数单独配置通道1、2、3、4的分频器函数读取四个通道的CCR函数 编码器接口定时器编码器接口配置函数 编码器接口程序示例 ADC模拟数字转换器逐次逼近型ADC的内部结构STM32的ADC：ADC基本结构输入通道：规则组的四种转换模式单次转换、非扫描模式连续转换、非扫描模式单次转换、扫描模式连续转换、扫描模式触发控制：数据对齐转换时间校准硬件电路ADC初始化步骤ADCCLK的配置函数恢复缺省配置函数Init初始化函数StructInit结构体初始化函数给ADC上电的函数开启DMA输出信号函数中断输出控制函数复位校准函数获取复位校准状态函数开始校准函数获取开始校准状态函数软件触发ADC的函数ADC获取软件开始转换状态函数（没啥用）获取转换是否结束函数配置间断模式函数ADC规则组通道配置函数外部触发转换控制函数是否允许外部触发转换ADC获取转换值函数ADC获取双模式转换值注入组相关函数配置模拟看门狗相关函数用来控制开启内部的两个通道函数获取标志位状态函数清除标志位函数获取中断状态函数清除中断挂起位 DMA存储器映像DMA的框图DMA的基本结构图DMA请求数据宽度与对齐数据转运+DMAADC扫描模式+DMA初始化DMA步骤：DMA的库函数恢复缺省配置结构体初始化使能中断输出使能DMA_设置当前数据寄存器给传输计数器写数据的DMA获取当前数据寄存器返回传输计数器的值获取标志位状态清除标志位状态获取中断状态清除中断挂起位 DMA程序示例 USART串口通信接口串口参数及时序USART的基本结构回复缺省值函数配置结构体函数给结构体配置默认值函数配置同步时钟输出函数开启串口函数开启串口中断函数开启USART到DMA的触发通道函数设置地址函数唤醒函数LIN函数发送数据函数接收数据读DR寄存器函数智能卡、IrDA函数在中断函数外获取标志位函数在中断函数外清除标志位函数在中断函数内获取标志位函数在中断函数内清除标志位函数 串口通信程序示例 串口收发数据包串口收发Hex数据包串口收发文本数据包数据包的收发流程数据包的发送 I2C指定地址写当前地址读指定地址读 GPIO配置步骤 步骤： 第一步，使用RCC开启GPIO的时钟
第二步，使用GPIO_Init()函数初始化GPIO
第三步，使用输出或者输入的函数控制GPIO口
常用的RCC开启始终函数 void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph,FunctionalState NewState); void RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph,FunctionalState NewState); void RCC_APB1PeriphClockCmd(uint32_t RCC_APB1Periph,FunctionalState NewState); 参数1：选择外设，参数2：使能或者失能
常用的GPIO函数 复位GPIO外设函数 void GPIO_DeInit(GPIO_TypeDef* GPIOx); 复位AFIO外设函数 void GPIO_AFIODeInit(void); 初始化GPIO口函数 用结构体的参数来初始化GPIO口，先定义一个结构体变量，然后把再给结构体赋值，最后调用此函数，函数内部会自动读取结构体的值，然后自动把外设的各个参数配置好
void GPIO_Init(GPIO_TypeDef* GPIOx,GPIO_InitTypedef* GPIO_InitStruct); 给GPIO结构体变量赋一个默认值函数 void GPIO_StructInit(GPIO_InitTypedef* GPIO_InitTypedef); GPIO的输出函数 把制定的端口设置为高电平:函数 void GPIO_SetBits(GPIO_InitTypedef* GPIOx,uint16_t GPIO_Pin); 把指定的端口设置为低电平 void GPIO_ResetBits(GPIO_InitTypedef* GPIOx,uint16_t GPIO_Pin); 对根据第三个参数的值来设置电平 void GPIO_WriteBit(GPIO_InitTypedef* GPIOx,uint16_t GPIO_Pin,BitAction BitVal); 对GPIOx 16个端口同时进行写入操作： void GPIO_Write(GPIO_InitTypedef* GPIOx,uint16_t PortVal); 在推挽输出模式下，高低电平都具有驱动能力，开漏输出模式的高电平是没有驱动能力的，开漏输出模式的低电平具有驱动能力
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3ae95227a60f4b9692ecf394468183f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b249a71650c3048f113f201b735feb24/" rel="bookmark">
			Adobe弹窗提示验证问题解决方案 记录一下解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系统开着代理，突然就蹦出来弹窗提示了，在网上找了一下解决办法，有如下两种，第一种试了，2天后失效了，然后用第二种，刚弄好，记录一下，有新的办法会及时补充
MAC版 Mac系统正版校验关闭教程
处理方法一：请关闭所有adobe软件，然后在终端输入代码 sudo rm /Library/application\ Support/Adobe/AdobeGCClient/AdobeGCClient.app/Contents/MacOS/AdobeGCClient 输入密码(密码输入不可见)按回车，完成后重启adobe软件即可正常使用！
处理方法二：
关闭所有Adobe相关软件 打开Finder，前往以下路径 Library（资源库）&gt;Application Support&gt;Adobe&gt;AdobeGCClient（也可以通过快捷键Cmd+Shift+G ，在弹出的窗口输入下方路径/资源库/Application Support/Adobe/AdobeGCClien）右键点击AdobeGCClient——显示包内容，找到Contents&gt;MacOS&gt;AdobeGCClient 将AdobeGCClient删除。 win版 一、Adobe Genuine Service Alert 出现的原因 老王在网上搜了“Adobe Genuine Service Alert”这个关键字，发现出来的都是“Adobe Genuine Integrity Service”，可能是我用的 Adobe 版本比较老（Photoshop 2018），提示也是老的。不过这两个提示应该都是 Adobe 的正版检测服务，会定期验证计算机上的 Adobe 应用程序是否为正版，如果不是，则会通知。
下图是 Adobe Genuine Integrity Service 提示，不过老王遇到的 Adobe Genuine Service Alert 跟这个差不多，也是说我用的不是正版，提示窗口关不掉，只能打开链接才能关闭。
二、Adobe Genuine Service Alert 关闭的方法 参考网上的处理方法，关闭这个提示的核心就是要删除掉 AdobeGCClient 文件。
Windows 上的处理步骤包括：
弹出 Adobe Genuine Service Alert 窗口的时候打开任务管理器任务管理器 -&gt; 进程 -&gt; 后台进程，找到类似 Adobe Genuine Integrity service 的进程（名字有点记不清了，类似这个，是个 Adobe 的图标）右击进程 -&gt; 打开文件所在位置这个文件夹下面有 AdobeGCIClient 和其他好几个 AGC、AGM、AGS 开头的文件（都是 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b249a71650c3048f113f201b735feb24/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02a72c979d62d29192c5a2e066287cdc/" rel="bookmark">
			使用H5实现在线录音并保存到本地
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;Online Audio Recorder&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;button id="startRecord"&gt;Start Recording&lt;/button&gt; &lt;button id="stopRecord" disabled&gt;Stop Recording&lt;/button&gt; &lt;audio id="audioPlayer" controls&gt;&lt;/audio&gt; &lt;script&gt; let mediaRecorder; let audioChunks = []; let audioPlayer = document.getElementById('audioPlayer'); let startRecordButton = document.getElementById('startRecord'); let stopRecordButton = document.getElementById('stopRecord'); startRecordButton.addEventListener('click', startRecording); stopRecordButton.addEventListener('click', stopRecording); async function startRecording() { try { const stream = await navigator.mediaDevices.getUserMedia({ audio: true }); mediaRecorder = new MediaRecorder(stream); mediaRecorder.ondataavailable = event =&gt; { if (event.data.size &gt; 0) { audioChunks.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/02a72c979d62d29192c5a2e066287cdc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f82f088c9e5b60c34c173ef4b939cb3/" rel="bookmark">
			Centos7环境下安装Mysql8详细教程(超详细，亲测百分百成功)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Centos7环境下安装Mysql8详细教程(超详细，亲测百分百成功) 文章目录 Centos7环境下安装Mysql8详细教程(超详细，亲测百分百成功) 1、上传或者下载mysql安装包2、检查是否安装过mysql3、检查是否有mariadb4、安装mysql依赖包5、解压6、更名并移动7、mysql安装目录赋予权限8、创建mysql组和用户9、修改mysql配置文件10、安装mysql11、启动mysql服务12、将mysql添加到系统进程中13、设置mysql自启动14、修改root用户登录密码15、设置允许远程登录16、重启服务且测试 1、查看mysql是否启动2、查看防火墙开放端口3、在防火墙中将3306端口开放4、在Navicat上测试连接5、重启linux后测试自启动（可选） 1、上传或者下载mysql安装包 下载
推荐使用清华的镜像，下载速度非常的快
wget https://mirrors.tuna.tsinghua.edu.cn/mysql/downloads/MySQL-8.0/mysql-8.0.21-el7-x86_64.tar.gz 当然，如果没有我也提供了下载包
链接：https://pan.baidu.com/s/14-_LlXPpMB10ray3iYPoQQ
提取码：idea
上传
使用xftp等软件将下载好的tar包上传到/opt目录下
2、检查是否安装过mysql ps:因为以前用yum安装过，所以先用yum卸载。如果不是此方式或者没安装过则跳过
[root@centos7 opt]# yum remove mysql 查看是否有mysql依赖
[root@service /]# rpm -qa | grep mysql 如果有则卸载
//普通删除模式 rpm -e xxx(mysql_libs) //强力删除模式,如果上述命令删除时，提示有依赖其他文件，则可以用该命令对其进行强力删除 rpm -e --nodeps xxx(mysql_libs) 3、检查是否有mariadb [root@centos7 opt]# rpm -qa | grep mariadb 如果有则卸载
[root@centos7 opt]# rpm -e --nodeps mariadb-libs [root@centos7 opt]# rpm -e --nodeps mariadb-devel-5.5.65-1.el7.x86_64 4、安装mysql依赖包 [root@centos7 opt]#yum install libaio 5、解压 进入/opt目录下将mysql文件解压
[root@centos7 opt]# cd /opt [root@centos7 opt]# tar -zxvf mysql-8.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f82f088c9e5b60c34c173ef4b939cb3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/416409696264dec33520d85b63ec95b5/" rel="bookmark">
			Centos7安装MySQL详细步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Centos7 安装MySQL详细步骤 首先在虚拟机中安装一个Centos7（VM虚拟机安装Centos7）
1.1 MySQL安装 1.1.1 下载wget命令 yum -y install wget 1.1.2 在线下载mysql安装包 wget https://dev.mysql.com/get/mysql57-community-release-el7-8.noarch.rpm 1.1.3 安装MySQL rpm -ivh mysql57-community-release-el7-8.noarch.rpm 1.1.4 安装mysql服务 首先进入cd /etc/yum.repos.d/目录。
cd /etc/yum.repos.d/
安装MySQL服务（这个过程可能有点慢）
yum -y install mysql-server
1.1.5 启动MySQL systemctl start mysqld 1.2 修改MySQL临时密码 MySQL安装成功后会有一个临时密码，我们可以使用grep命令查看临时密码先登录进去MySQL，然后修改MySQL密码。
1.2.1 获取MySQL临时密码 grep 'temporary password' /var/log/mysqld.log 1.2.2 使用临时密码先登录 mysql -uroot -p 我的临时密码是：a22XRJ88=+a;
1.2.3 把MySQL的密码校验强度改为低风险 set global validate_password_policy=LOW; 1.2.4 修改MySQL的密码长度 set global validate_password_length=5; 1.2.5 修改MySQL密码 ALTER USER 'root'@'localhost' IDENTIFIED BY 'admin'; 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/416409696264dec33520d85b63ec95b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67c3880a1be8d9d42aba1ffe7745a50d/" rel="bookmark">
			自组织团队和命令型团队
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是命令型团队？ 命令型团队的工作一般是由经理或leader派发，每个小的leader再次进行下发。真正执行任务的员工灵活度很低，一般都是被动的接受。并且需要经常向leader汇报，leader同意后再继续下面的工作。在非自组织团队中，leader的角色至关重要，leader需要触及项目各个角落，并且试图掌控项目的方方面面。每个小leader也明确知道自己的职责范围，不会跨越自己的职责范围半步，在自己的职责范围内leader自己的小团队。而工作的真正执行者，完全是机械的完成派发下来的工作，并且对leader有较强的依赖性。当有挑战性的工作出现时，大家会默认是leader的工作，而不会主动站出来。leader也自然而然的会去主动分析，然后任务拆解，再把工作分发下来。或者leader会分配xx去先进行调研，然后xx像leader汇报调研结果，leader再看下一步怎么办。在传统的团队模式下，任务都是一层层派发，每个人有自己明确的职责，每个人各司其职，等待上级对自己工作的指派。 命令型团队的缺点
过分依赖leader 。其他成员主观能动性差。任务执行者自由度差 。层层汇报，效率低下，决策链长。虽然团队有统一的目标，但真实情况是每个人只盯着自己手里的事情。目标是leader来扛的。 相信上面这些缺点，你一定是身同感受。无论你是那个疲于奔命的leader，还是那个守着自己一亩三分地的团队成员。
什么是自组织团队？ 自组织团队就像一个个体，团队作为一个整体来设定目标，并为之实现。在自组织团队中，管理者是被弱化的。管理工作交由团队自身去完成。自组织团队具备如下特征：
团队为自己设定目标，并努力去实现。每个人的任务应该自由认领（“拉动”）自我管理和调整，而不需要时刻向管理者汇报进度 看起来定义很简单，但是要做到却很不容易，需要团队每个成员的努力，并且需要有经验的人来Coach。下面我们展开来看一看如何构建自组织团队。
自组织团队特点
自组织团队中，管理者不再发号施令，而是让团队自身去寻找最佳的工作方式。
此时团队初期必然会出现效率的下降，因为团队需要试错，这是一个正常的过程。团队通过试错、磨合，最终会找到属于团队最佳的工作方式，效率自然会提升起来。在自组织团队中，每个成员的灵活度很高。某个事项可能由 A 来 lead，另外的事项也可能由 B 来 lead。每个人都有发表自己意见、看法，提出自己方案的机会。具体是否执行，则是交由团队来决定。并不是通过向 manager 汇报，manager 再审批通过。因此，在自组织团队中，能够充分调动团队成员的能动性。owner 的意识会更强。自组织团队的成员不会局限在自己熟知的领域，而是经常会跨出自己熟悉的领域，无论技术还是业务。每位成员都会有全局意识，并且每个人都了解团队在做的事情，而不是局限在自己的一小块熟悉领域内。自组织团队的任务基于认领，而不是分配。因此成员对工作任务的责任心更强、更加主动。 总的来说，自组织团队是思想一致、行动积极主动、氛围公平民主、沟通透明、放权管理的团队。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0ebeced4fde8d71ea8ad58982083217/" rel="bookmark">
			bitset用法：16进制输出成2进制、获取16位2进制某个区间的值、改变16位2进制某个区间的值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 std::bitset 是C++标准库中的一个类模板，用于表示固定大小的位序列。
template &lt;size_t N&gt; class bitset;
bitset,从名字就可以看出来,是一个(比特)二进制(0和1)的集合
std::bitset 模板类定义在 头文件中，并接受一个模板参数 N，表示位集的大小。
例如:
bitset在内存中是以4或8个字节为单位存储的
sizeof(bitset&lt;1&gt;) 1位的时候占4个字节
sizeof(bitset&lt;32&gt;) 32位的时候占4个字节
sizeof(bitset&lt;33&gt;) 33位的时候占8个字节
sizeof(bitset&lt;65&gt;) 65位的时候占个16字节 (2倍增长动态分配内存空间的机制在计算机中很常见,c++的vector内存也是这样)
它提供了一种方便且高效的方式来处理位操作。
std::bitset 提供了许多成员函数和操作符，用于处理位序列。以下是一些常用的成员函数和操作符：
构造函数 bitset()：创建一个所有位都设置为0的位集。
bitset(unsigned long long val)：创建一个位集，并将其初始化为给定的无符号长长整数值。
bitset(const std::string&amp; str)：创建一个位集，并将其初始化为给定的二进制字符串（只包含 ‘0’ 和 ‘1’）。
示例：
构造 bitset&lt;10&gt; a;	//a:0000000000 用一个数值初始化 (1)当用一个数值去构造的时候，其实就是将数值在内存中的存储方式显示出来。(数值在内存中是以补码形式存储的)
(2)若bitset的位数n小于数值的位数,只取数值(小端的)前n位初始化给bitset
bitset&lt;4&gt; a(-16);	//-16的补码为11111111.....10000,a有4位,因此a:0000 bitset&lt;5&gt; a(17);	//17的补码为00000000.....10001,a有5位,因此a:10001 bitset&lt;6&gt; a(-8);	//-8的补码为 11111111.....11000,a有6位,因此a:111000 bitset&lt;7&gt; a(8);	//8的补码为 00000000.....01000,a有7位,因此a:0001000 用字符串string 或者 char[]初始化 //以string为例,char[]与其用法相同 string b = "100101111";	//这里特别注意，bitset的size和字符串长度不匹配的时候如何构造 bitset&lt;3&gt; a(b);	//a:100	//当bitset的size小于等于字符串长度，取字符串的前size位 bitset&lt;6&gt; a(b);	//a:100101 bitset&lt;9&gt; a(b);	//a:100101111 bitset&lt;12&gt; a(b);	//a:000100101111 //当bitset的size大于字符串长度，进行补零 成员函数 size()：返回位集的大小（位数）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d0ebeced4fde8d71ea8ad58982083217/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b33f4540fe9073f6de812d46f44fcee8/" rel="bookmark">
			10-09 周一 图解机器学习之深度学习感知机学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		10-09 周一 图解机器学习之深度学习感知机学习 时间版本修改人描述2023年10月9日14:13:20V0.1宋全恒新建文档 简介 感知机是神经网络中的概念，1958年被Frank Rosenblatt第一次引入。感知机作为一种基本的神经网络模型，它模拟了人脑神经元的工作原理。感知机接受多个输入信号，将它们加权求和并加上偏置值，然后通过一个激活函数将结果转化为输出信号。感知机能够容易的实现逻辑与，或，非。但单层感知机无法实现异或。
感知机可以用于分类问题，将输入信号分为不同的类别。
感知机也是神经网络的基本组成单元，通过感知机的组合可以构建更加复杂的神经网络模型，比如说多层感知机MLP和卷积神经网络CNN。
感知机的基本原理可以用一下公式表示：
感知机的学习过程，通过不断调整权重和偏置值来完成，一般采用梯度下降算法，通过最小化损失函数来优化权重和偏置值。常用的损失函数包括均方误差和交叉熵。
概念理解 样本特征矩阵标签y训练迭代 将要定义一个训练函数 perceptron，使用变量n_iter表示迭代次数。每迭代一次，感知机会用当前的权重对样本进行预测，并计算预测值与真实标签之间的误差。然后根据误差值来调整权重，以期望能够使预测结果更加接近真实标签。
n_iter 值越大，训练时间越长，可能会使得感知机的性能提高，但也会增加过拟合的风险。在实际应用中，我们需要根据具体情况来调整 n_iter 的值。 学习率 学习率控制了每次参数更新的步长，即每次参数更新时改变的大小。在单层感知机中，学习率决定了每次更新权重和偏置的步长。通常可以使用网格搜索或随机搜索等方法来搜索最优的学习率。另外，还可以使用自适应学习率的方法，如 Adagrad、Adadelta、Adam 等，自动调整学习率大小，以提高模型的训练效果。 计算预测值更新权重 weights = weights + learning_rate * y[i] * X[i] 更新偏置 bias = bias + learning_rate * y[i] 绘制决策边界 # error 是误差 error = y - y_pred weights = weights + learning_rate * error Xbias = bias + learning_rate * error 上图参见机器学习p99
图示 代码理解 代码 #程序代码13.1 python实现感知器网络，并对and函数训练，名称：Perceptron.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b33f4540fe9073f6de812d46f44fcee8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1805f0def06c44df9f3cf6d7411e1f2/" rel="bookmark">
			JavaScript API-01 DOM
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. DOM 学习视频：https://www.bilibili.com/video/BV1Sy4y1C7ha/
DOM简介
文档对象模型（Document Object Model，简称 DOM），是 W3C 组织推荐的处理可扩展标记语言（HTML或者XML）的标准编程接口。
通过这些 DOM 接口可以改变网页的内容、结构和样式。
DOM树：
文档：一个页面就是一个文档，DOM 中使用 document 表示元素：页面中的所有标签都是元素，DOM 中使用 element 表示节点：网页中的所有内容都是节点（标签、属性、文本、注释等），DOM 中使用 node 表示DOM 把以上内容都看做是对象 获取元素
原因：DOM在开发中主要用来操作元素
如何获取
根据 ID 获取document.getElementById( );
在MDN搜索document.getElementById( );可得详细信息作用：可以获取返回带有 ID 的元素对象可以console.dir()使用打印元素对象，比console.log()好观察 &lt;div id="time"&gt;2019-9-9&lt;/div&gt; &lt;script&gt; // 1. 因为我们文档页面从上往下加载，所以先得有标签 所以我们script写到标签的下面 // 2. 参数 id是大小写敏感的字符串 var timer = document.getElementById('time'); console.log(timer); console.log(typeof timer);//object所以返回的是一个元素对象 // 3. console.dir 打印我们返回的元素对象 更好的查看里面的属性和方法 console.dir(timer); &lt;/script&gt; 根据标签名获取getElementsByTagName()
作用：返回带有指定标签名的对象的集合
返回：获取过来元素对象的集合以伪数组（有长度等但是没有push、pop等方法）的形式存储的
就算是只有一个li也是伪数组，如果页面中没有li这个元素，返回的是空的伪数组的形式
得到元素对象是动态的，根据内容而变
获取1 ：所有的都获取过来document.getElementsByTagName('标签名')
&lt;ul&gt; &lt;li&gt;知否知否，应是等你好久11&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; // 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1805f0def06c44df9f3cf6d7411e1f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b330b5facaeb40f0f5e88beb87c97ca7/" rel="bookmark">
			自动求导，计算图示意图及pytorch实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 pytorch实现 x1 = torch.tensor(3.0, requires_grad=True) y1 = torch.tensor(2.0, requires_grad=True) a = x1 ** 2 b = 3 * a c = b * y1 c.backward() print(x1.grad) print(y1.grad) print(x1.grad == 6 * x1 * y1) print(y1.grad == 3 * (x1 ** 2)) 输出为：
tensor(36.)
tensor(27.)
tensor(True)
tensor(True)
默认情况下，pytorch会累加梯度，每次backward()前，需要进行梯度清零 x.grad.zero_() 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/845854a6d2d8712ae5d1cc2e32d53fa9/" rel="bookmark">
			jmeter使用csv进行参数化及（运行后出现乱码错误解决）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
jmeter使用csv进行参数化
1、准备参数化文本内容：mac没有自带的txt文本编辑器，笔者是在word中新建的然后保存成txt文档
2、进入jmeter中，在线程组中右键添加--配置元件--csv数据文件设置
3、将设置的变量配置到运行脚本中
4、进入线程组中设置线程数，设置为5，然后运行
Jmeter运行后出现乱码
1、响应结果出现乱码一般是编码的问题，汉子乱码在编码处编码写成utf-8
2、如果还不行，对jmeter的文件进行修改
3、退出jmeter，重新打开，再次运行
jmeter使用csv进行参数化 1、准备参数化文本内容：mac没有自带的txt文本编辑器，笔者是在word中新建的然后保存成txt文档 参数与参数之间用逗号隔开，英文逗号。笔者亲试中文逗号是无法将参数分割开的，就会默认 为一个参数来处理。内容编辑完成后写成保存txt文档，当然.dat文档也是可以的
将文档保存到固定位置，获取文档的路径。windows中直接右键就可以复制到文档的路径。mac中笔者一般都是将文档直接拖到终端中，文档路径直接生成
2、进入jmeter中，在线程组中右键添加--配置元件--csv数据文件设置 设置csv数据文件内容：
文件名天填写刚才获取到的文件路径+文件名+文件格式
文件编码写保存文件时的格式，一般中文都是utf-8
变量名称指的是变量指代的内容，每一列之间用逗号隔开。步骤1中保存的变量用逗号隔开，这儿设置变量名时一样用逗号隔开
3、将设置的变量配置到运行脚本中 配置变量是：美元符号+大括号变量名。比如：符号+大括号变量名。比如：{name}
这儿的变量名要与步骤2设置的变量名称一致
4、进入线程组中设置线程数，设置为5，然后运行 察看结果树中选择以browser的形式查看ui界面，依次察看可以看到结果是依次从步骤1中的文档内容依次读取
Jmeter运行后出现乱码 1、响应结果出现乱码一般是编码的问题，汉子乱码在编码处编码写成utf-8 2、如果还不行，对jmeter的文件进行修改 具体修改方法请留言咨询
步骤如下进入/bin目录，以记事本的方式打开jmeter.properties
ctr+f查找ISO-8859-1，会查找到好多内容，找到sampleresult.default.encoding=ISO-8859-1这句话
如下图，取消注释号#，并且将ISO-8859-1编码改为utf-8，保存退出
3、退出jmeter，重新打开，再次运行 以百度首页为例，查看结果如下，乱码问题解决
以下是我收集到的比较好的学习教程资源，虽然不是什么很值钱的东西，如果你刚好需要，可以评论区，留言【777】直接拿走就好了
各位想获取资料的朋友请点赞 + 评论 + 收藏，三连！
三连之后我会在评论区挨个私信发给你们~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb2a4a508627b044fb724114291d5485/" rel="bookmark">
			【AI】深度学习——前馈神经网络——全连接前馈神经网络
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.1 全连接前馈神经网络1.1.1 符号说明超参数参数活性值 1.1.2 信息传播公式通用近似定理 1.1.3 神经网络与机器学习结合二分类问题多分类问题 1.1.4 参数学习矩阵求导链式法则更为高效的参数学习反向传播算法目标计算 ∂ z ( l ) ∂ w i j ( l ) \frac{\partial z^{(l)}}{\partial w^{(l)}_{ij}} ∂wij(l)​∂z(l)​计算 ∂ z ( l ) ∂ b ( l ) \frac{\partial z^{(l)}}{\partial b^{(l)}} ∂b(l)∂z(l)​计算 ∂ L ( y i , y ^ i ) ∂ z ( l ) \frac{\partial \mathcal{L}(y_i,\hat{y}_i)}{\partial z^{(l)}} ∂z(l)∂L(yi​,y^​i​)​合并求梯度误差的反向传播算法过程 自动梯度计算数值微分符号微分自动微分自动微分与符号微分区别 优化问题非凸优化问题梯度消失问题 1.1.5 全连接的前馈神经网络问题参数太多局部不变性 1.1 全连接前馈神经网络 前馈神经网络（Feedforward Neural Network,FNN）也称为多层感知器（实际上前馈神经网络由多层Logistic回归模型组成）
前馈神经网络中，各个神经元属于不同的层
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb2a4a508627b044fb724114291d5485/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cbe2968f8f9100f9e910da357b0c1c3c/" rel="bookmark">
			IEEE浮点数编码机制：详解与数学原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		浮点数是计算机中用于表示实数的一种数值格式。IEEE浮点数编码机制是一种广泛使用的标准，它定义了浮点数的表示方式、运算规则和精度限制。本文将详细介绍IEEE浮点数编码机制的数学原理，并给出相应的代码示例。
IEEE浮点数编码概述
IEEE浮点数编码采用二进制表示实数，由三个主要部分组成：符号位、阶码和尾数。具体而言，单精度浮点数（32位）由1位符号位、8位阶码和23位尾数组成，双精度浮点数（64位）由1位符号位、11位阶码和52位尾数组成。
数学原理
2.1 符号位
符号位用于表示浮点数的正负，0表示正数，1表示负数。
2.2 阶码
阶码部分用于表示浮点数的指数部分。在IEEE浮点数编码中，阶码使用了移码表示法。对于单精度浮点数，阶码的范围是-127到+128；对于双精度浮点数，阶码的范围是-1023到+1024。阶码的实际值通过对移码进行解码得到。
2.3 尾数
尾数部分用于表示浮点数的小数部分。尾数使用定点表示法，通常是一个小数点前为1的二进制小数。
IEEE浮点数编码示例
下面是一个单精度浮点数的编码示例： def float_to_binary(num): binary = '' if num &lt; 0: binary += '1' num = abs(num) else: binary += '0' integer_part = int(num) fractional_part = num - integer_part # 将整数部分转换为二进制 binary += bin(integer_part)[2:].zfill(8) # 将小数部分转换为二进制 while fractional_part != 0: fractional_part *= 2 bit = int(fractional_part) binary += str(bit) fractional_part -= bit return binary num = -12.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cbe2968f8f9100f9e910da357b0c1c3c/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/78/">«</a>
	<span class="pagination__item pagination__item--current">79/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/80/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>