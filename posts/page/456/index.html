<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2c7671c6ba6e7ed473d7bd39868e4df/" rel="bookmark">
			堆和栈的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.堆和栈的区别 一、堆栈空间分配区别：
1、栈（操作系统）：由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈；
2、堆（操作系统）： 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收，分配方式倒是类似于链表。
二、堆栈缓存方式区别：
1、栈使用的是一级缓存， 他们通常都是被调用时处于存储空间中，调用完毕立即释放；
2、堆是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）。所以调用这些对象的速度要相对来得低一些。
三、堆栈数据结构区别：
堆（数据结构）：堆可以被看成是一棵树，如：堆排序；
栈（数据结构）：一种先进后出的数据结构。 这样的例子很多，然而真正使用的时候他们的差别并不是很大，比如，在C++中，我们新建一个对象 实例，可以通过以下两种方式进行： class mycalss() {}
在栈上创建一个对象 ：myclass myclass;
在堆上创建一个对象：myclass* myclass = new myclass;
这带来的一个附带的区别是，在访问类的对象成员时，对于在栈上创建的一般是使用“.”来访问，而在堆上创建的对象成员则是使用“-&gt;”来进行的。
2、堆排序 这里我们用到两种堆，其实也算是一种。
大顶堆：每个节点的值都大于或者等于它的左右子节点的值。
小顶堆：每个节点的值都小于或者等于它的左右子节点的值。
堆排序的基本思想是：1、将带排序的序列构造成一个大顶堆，根据大顶堆的性质，当前堆的根节点（堆顶）就是序列中最大的元素；2、将堆顶元素和最后一个元素交换，然后将剩下的节点重新构造成一个大顶堆；3、重复步骤2，如此反复，从第一次构建大顶堆开始，每一次构建，我们都能获得一个序列的最大值，然后把它放到大顶堆的尾部。最后，就得到一个有序的序列了。
4、堆排序的代码实现（java版本）
public class HeapSort { public static void heapSort(int[] arr) { if (arr == null || arr.length == 0) { return; } int len = arr.length; // 构建大顶堆，这里其实就是把待排序序列，变成一个大顶堆结构的数组 buildMaxHeap(arr, len); // 交换堆顶和当前末尾的节点，重置大顶堆 for (int i = len - 1; i &gt; 0; i--) { swap(arr, 0, i); len--; heapify(arr, 0, len); } } private static void buildMaxHeap(int[] arr, int len) { // 从最后一个非叶节点开始向前遍历，调整节点性质，使之成为大顶堆 for (int i = (int)Math.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e2c7671c6ba6e7ed473d7bd39868e4df/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20c906d6e4e4dd6dab9804939b4762cf/" rel="bookmark">
			记录一次学习冒泡算法的心路历程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		冒泡算法 lst = [] while 1: num = input("请输入你想排序的数，按Q/q停止:") if num.upper() == "Q": break lst.append(int(num)) for a in range(len(lst)-1): # 记录内部排序的次数 i = 0 while i &lt; len(lst) - 1: # 索引从0开始，长度从1开始，把最大值移到右端 if lst[i] &gt; lst[i+1]: lst[i],lst[i+1] = lst[i+1],lst[i] # 交换 i = i + 1 print(lst) 冒泡算法的原理是给定一个数字列表之后，从第一个开始（s[0]）逐渐与右边的比较，每一次把大的放右边，从第一个运算到列表长度减一个，这样一个过程只是把列表中最大的那个数排到了最右边，因此这样的过程需要循环列表的长度次或列表长度减一次，即加入一个range循环。
学习体会：今天学到了Day7，学习不是一个追求速度的过程，而在于追求效率，而追求效率的核心在于不断的总结，不断通过总结在自己脑海中形成逻辑，形成某种更容易理解与记忆的方式，写博客就是一个不错的方式，加油。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ea72baa80665ced94a8ea2ee7368298/" rel="bookmark">
			【不变与可变】mutable和const
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 1、const关键字1.1 const修饰变量1.2 const修饰成员函数 2、mutable关键字 1、const关键字 const关键字可以用来修饰变量和成员函数。其修饰变量则在此作用域下变量不可变，其修饰成员函数则说明此成员函数不会修改类的成员变量。 1.1 const修饰变量 1.2 const修饰成员函数 const修饰成员函数时需要将声明和定义全部加上const关键字。
当const修饰成员函数时，其含义是此成员函数不会更改类的成员变量，有以下两个层次：
不能在代码中显式对成员变量赋值。其调用的成员函数也应该为const类型，以保证其不会改变类的成员变量。 2、mutable关键字 在1.2节中说道当const修饰成员函数时，此函数内部不能对成员变量赋值且其调用的函数也应该为const。但有时类中的变量并不全是保存的类的有效信息，有些变量是作为辅助来使用的，比如迭代变量等待。这时就可能在函数中更改这这些变量的值。只需要在声明时为变量加上mutable即可。
class A{ ... mutalbe int m_next; }; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76bb7ac3cbac277386e5e3673d8ad403/" rel="bookmark">
			SqlServer设置特定用户操作特定表(插入、删除、更新、查询 的权限设置)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、需求场景：二、操作步骤：1、登录SSMS后选择【安全性】，右键点击【登录名】,在弹出的右键菜单中选择【新建登录名】选项；2、在【常规】选项卡中，创建登录名，并设置默认数据库；3、在【用户映射】选显卡中，勾选数据库，并设置【架构】；4、对需要设置操作权限的表进行权限设置，【表】--【属性】；5、使用【zyl】登录数据库，就只能看到User表了； 三、注意事项1、在权限列表中如果选择了【设置】这项，那么再设置【列权限】就没有意义了，因为查询已经不受限制了；2、除了对表设置权限外，还可以对视图、函数等进行权限设置； 一、需求场景： 在和其他厂商对接的时候，经常会将某数据库的某些表放开增删改查（CRUD）的权限给对方，此时，就要新建个用户，授予某数据库的某些表CRUD的权限；还有的时候只需授权SELECT权限，其他权限不能授予；
二、操作步骤： 演示所用数据库版本：SQL Server Management Studio V17.8.1
1、登录SSMS后选择【安全性】，右键点击【登录名】,在弹出的右键菜单中选择【新建登录名】选项； 2、在【常规】选项卡中，创建登录名，并设置默认数据库； 3、在【用户映射】选显卡中，勾选数据库，并设置【架构】； 4、对需要设置操作权限的表进行权限设置，【表】–【属性】； 数据库TestDB中已经有两个表，分别为User和Salary，现在对表User进行权限设置，将Insert、update、delete、select的权限赋给用户【zyl】；
#表上右键选择【属性】，选择【权限】选项卡：
#点击【搜索】，在弹出的框中点击【浏览】，选择需要设置的用户；
#在上面点击【确定】后，就可以在【权限】选项卡中看到权限列表，选择需要的权限点击确定即可；
#当选中【选择】和【引用】权限时，还可以设置【列权限】；
5、使用【zyl】登录数据库，就只能看到User表了； 并且用户【zyl】只能对表User进行增删改查，不能修改表结构；
三、注意事项 1、在权限列表中如果选择了【设置】这项，那么再设置【列权限】就没有意义了，因为查询已经不受限制了； 如果设置了【列权限】，没有选择【设置】权限，那么select * 就会报错；
2、除了对表设置权限外，还可以对视图、函数等进行权限设置； 在数据库的【安全性】-【用户】-【zyl】-【属性】-【安全对象】；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e0da0fef91461f95e4eac1a512d7d72/" rel="bookmark">
			【临时对象】C&#43;&#43;中临时对象及返回值优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 1、什么是临时对象 1、什么是临时对象 C++真正的临时对象是不可见的匿名对象，不会出现在你的源码中，但是程序在运行时确实生成了这样的对象. 通常出现在一下两种情况： 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c080f7079c578b016755165069ce4a28/" rel="bookmark">
			【拷贝构造和赋值运算符】C&#43;&#43; 拷贝构造函数和赋值运算符函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、拷贝构造函数和赋值运算符2、两者分别在何时调用3、深拷贝、浅拷贝：拷贝构造函数和赋值运算符函数的必要性和意义 本文前面主要介绍了拷贝构造函数和赋值运算符函数的区别，以及在什么时候调用拷贝构造函数、什么情况下调用赋值运算符函数。最后，分析了下深拷贝和浅拷贝的问题，即拷贝构造函数和赋值运算符函数的必要性和意义。
1、拷贝构造函数和赋值运算符 在默认情况下（用户没有定义，但是也没有显式的删除），编译器会自动的隐式生成一个拷贝构造函数和赋值运算符函数（缺省的）。
class Person { public: ... Person(const Person&amp; p) = delete; Person&amp; operator=(const Person&amp; p) = delete; private: int age; string name; }; 用户可以使用delete来指定不生成拷贝构造函数和赋值运算符，这样的对象就不能通过值传递，也不能进行赋值运算。上面的定义的类 Person 显式地删除了拷贝构造函数和赋值运算符，在需要调用拷贝构造函数或者赋值运算符的地方，会提示无法调用该函数，它是已删除的函数。
如果我们不想编写拷贝构造函数和赋值运算符函数，又不允许别人使用编译器隐式生成的缺省函数，同时也不想显式地删除拷贝构造函数和赋值运算符函数，我们还可以通过将拷贝构造函数和赋值运算符函数声明成类私有函数的方式来实现。如下所示：
class Person { public: ... private: Person(const Person&amp; p); //以常量引用的方式传递参数 Person&amp; operator=(const Person&amp; p);//返回值类型为该类型的引用 int age; string name; }; 还有两点需要注意的是：
拷贝构造函数必须以引用的方式传递参数,基本上都是传常量引用的方式传递函数参数。这是因为，在值传递的方式传递给一个函数的时候，会调用拷贝构造函数生成函数的实参。如果拷贝构造函数的参数仍然是以值的方式，就会无限循环的调用下去，直到函数的栈溢出。
**赋值运算符函数的返回值类型要声明为该类型的引用，并在函数结束前返回实例自身的的引用（*this）加粗样式，只有返回一个引用，才能进行连续赋值。否则，如果函数的返回值是void，则应用改赋值运算符将不能进行连续赋值。假设有3个Person对象：p1、p2、p3，在程序中语句p1=p2=p3将不能通过编译。
2、两者分别在何时调用 拷贝构造函数和赋值运算符函数的行为比较相似，都是将一个对象的值复制给另一个对象；但是其结果却有些不同，拷贝构造函数使用传入对象的值生成一个新的对象的实例，而赋值运算符函数是将对象的值复制给一个已经存在的实例。这种区别从两者的名字也可以很轻易的分辨出来，拷贝构造函数也是一种构造函数，那么它的功能就是创建一个新的对象实例；赋值运算符函数是执行某种运算，将一个对象的值复制给另一个对象（已经存在的）。调用的是拷贝构造函数还是赋值运算符函数，主要是看是否有新的对象实例产生。如果产生了新的对象实例，那调用的就是拷贝构造函数；如果没有，那就是对已有的对象赋值，调用的是赋值运算符函数。
调用拷贝构造函数主要有以下场景：
对象作为函数的参数，以值传递的方式传给函数。对象作为函数的返回值，以值的方式从函数返回。使用一个对象给另一个对象初始化。 class Person { public: Person(){} Person(const Person&amp; p) { cout &lt;&lt; "Copy Constructor"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c080f7079c578b016755165069ce4a28/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd6574650019a577095ed63ad757ed0b/" rel="bookmark">
			被CONST修饰的变量--指针变量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先介绍const 的使用方法： 一. const是用来修饰变量的，一旦被const 修饰的变量，便具有稳定性，且不可被修改，能有效防止代码中不能被更改的数据产生变更，能有限提高代码的安全性，稳定性，和健壮性，合理的使用const ，会给我们带来满满的安全感。 const虽然简单来看是修饰变量，但在我们遇到的一些const修饰表现来看，这里面似乎还是包含了星点学问。 二.首先我们来看看const修饰常量指针的用法： 3 int n =10; 4 const char *p=&amp;n; 5 printf("%d",*p);//此时*p输出的是n = 值。 6 *p=20;//此时想将*p的值改为20； 7 printf("%d",*p); 但输出结果却是这样的：
const1.c: 在函数‘main’中: const1.c:4:16: 警告： 从不兼容的指针类型初始化 [默认启用] const1.c:6:5: 错误： 向只读位置‘*p’赋值 终端提示向只读p赋值的错误的，因此可以发现，const char p的功能是将p变为常量指针，在程序中相当于一个常量，并且p的值不可被修改。
三.下面我们看看修饰定义常量指针的另外一种方法：
3 int n =10; 4 char const *p=&amp;n; 5 printf("%d",*p);//此时*p输出的是n = 值。 6 *p=20;//此时想将*p的值改为20； 7 printf("%d",*p); 此时将char 和const 换了一个位置，那我们来看看结果：
const1.c: 在函数‘main’中: const1.c:4:17: 警告： 从不兼容的指针类型初始化 [默认启用] const1.c:6:5: 错误： 向只读位置‘*p’赋值 可见结果和上面的一样，说明char const *p 等同于 const char *p 。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd6574650019a577095ed63ad757ed0b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c16086946645256e2f6de5ff1198eb2/" rel="bookmark">
			Spring中涉及的设计模式总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring中涉及的设计模式总结
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c2d58b297635b11761d0766767af46b/" rel="bookmark">
			当Makefile.win 错误如何解决？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 看如下图片的提示！方可知道错误所在。
图一：
图二：
图三： 从上面的图片中可以看出来，就是在main中调用test1的方法错了，main中应该是test1()才是正确的，如果换成test1()，就会运行成功！
图四：
图五：
问题已解决，文章以写完！谢谢来观赏的朋友，希望能帮你解决问题！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/446b62a4beaa0762b9e6ccba435747c3/" rel="bookmark">
			关于VRC模型处理步骤中Blender2.8的代贴紫模问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 写这个的原因是因为当我自己从Blender2.7换到2.8的时候，由于界面的更改，导致很多的快捷键，界面操作，操作顺序都有一定的改变。或者是一些很久之前就有的，一直困扰着很多玩家（包括我）的问题的解决方法。
这里主要是针对VRChat创作者所写的文章（其实是为了自己以后忘记为什么的话可以回来这里看笔记）。
如果你不是该玩家人群，那我并不确定这篇文章对你来说会不会游泳。
如果你是VRChat创作者，那么可以看下去，如果有什么需要补充的，欢迎到下面的评论区里面留言给我。
正题 以下我会根据各种各样的问题一一列出，每一个都会包含相关信息或者说我自己尝试过后可行的解决方法。
关于插件 问题：带贴紫模 在旧版Blender（也就是Blender2.7中），在处理模型之前我们需要加载对应的插件，分别是Cats插件和mmd_tool插件。
而在新版中，是只用加载Cats插件的，并不需要导入mmd_tool插件（截至到写这篇东西之前，mmd_tool只更新到2.79版本，并没有2.8的版本）。
但是由于某些步骤，如勾选掉Toon Texture步骤和Sphere Texture使得模型不要变成带贴紫模的样子（某些情况下会发生），我们必须找到对应可以勾选到的方法。
解决方法 方法一：直接开启官方中的Modifier Tools来代替mmd_tool的功能 在设置中点击插件（英文的话应该是add-on，最好先改成中文吧），然后找到Modifier Tools，勾选之后导入模型，按N开启侧边栏目，然后选择杂项就可以看到多出来一个MMD Display的栏目，不难发现这个栏目其实就是之前mmd_tools的对应的功能。
同理同步，取消掉两个勾选之后，Shadeless即可。
方法二：在节点编辑器中取消掉对应的节点 这个是一个比较憨批的方法，是我在发现第一个方法之前发现的方法，缺点就是很繁琐，而且需要一个一个材质球弄使用ToonTex之后，还要去节点里面取消（那个时候我并没有发现可以使用上面的官方自带的插件）。
首先将所有的材质球里面的Use Shared Toon Texture勾选，后面数值为1。
然后到Shading的界面（也就是节点的界面），把ToonTex和SphereTex的对应节点删掉，注意是节点，不是线。
这个方法缺点巨多，而且需要有对应的节点的部分知识，所以用上面的方法吧，这个方法写下来只是为了记录一下是有这个方法的存在的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dbacdf7aee937104f496aa6a6119a71b/" rel="bookmark">
			浅谈PYTHON
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		结缘
我了解 Python 最早来源于 Python 的一段格言，就下面一段话将我征服了，格言其实是对软件开发的哲学理念和设计思想，也是一个大佬对于软件的感悟，看了这段感悟我就在想，作者这么高的境界，那么搞出来的编程语言能差到哪里呢？
优美胜于丑陋，明晰胜于隐晦 简单胜于复杂，复杂胜于繁芜 扁平胜于嵌套，稀疏胜于密集 可读性很重要。 虽然实用性比纯粹性更重要， 但特例并不足以把规则破坏掉。 错误状态永远不要忽略， 除非你明确地保持沉默， 直面多义，永不臆断。 最佳的途径只有一条，然而他并非显而易见————谁叫你不是荷兰人？ 置之不理或许会比慌忙应对要好， 然而现在动手远比束手无策更好。 难以解读的实现不会是个好主意， 容易解读的或许才是。 名字空间就是个顶呱呱好的主意。 让我们想出更多的好主意！
其实 Python 已经是一个很老的编程语言了，到现在（2019年） Python 已经高龄 28 岁，比很多程序员的年龄都大，2015 年的时候需要爬取某个网站的数据，利用了几天的时间写了一个小的 Python 爬虫程序，一下子对 Python 产生了兴趣，后来陆陆续续写过几个小爬虫，但由于工作原因，还没有进行过系统学习。
如今，Python 已经是必须了解的编程语言了，Python 在爬虫、机器学习等领域的优势越来越明显，并且可以利用 Python 做很多有趣的小工具，因此接下来的一段时间，准备好好学习 Python 的使用。
当我准备在网上写写 Python 的发展历史时，发现博客园的 vamei 也写过一篇类似的文章非常精彩，后面内容大多摘录于此文《Python 简史》。
起源
Python 的创始人为吉多·范罗苏姆 1982年，Guido 从阿姆斯特丹大学 (University of Amsterdam) 获得了数学和计算机硕士学位。然而，尽管他算得上是一位数学家，但他更加享受计算机带来的乐趣。用他的话说，尽管拥有数学和计算机双料资质，他总趋向于做计算机相关的工作，并热衷于做任何和编程相关的活儿。
在那个时候，他接触并使用过诸如 Pascal、C、 Fortran 等语言。这些语言的基本设计原则是让机器能更快运行。在80年代，虽然IBM和苹果已经掀起了个人电脑浪潮，但这些个人电脑的配置很低 (在今天看来)。比如早期的 Macintosh，只有 8MHz 的 CPU 主频和 128KB 的 RAM，一个大的数组就能占满内存。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dbacdf7aee937104f496aa6a6119a71b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd131a44c65499a357041a95865996ec/" rel="bookmark">
			JavaScript 学习之旅（四）原型与继承
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 原型与继承原型与原型链Object() 与 Function()继承借用构造函数原型链实现继承组合继承方式（上面两种方法的配合）组合继承方式优化ES6 实现继承 原型与继承 原型与原型链 prototype: 每个函数都有一个 prototype（原型）属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法，如果使用这个函数生成了实例，那么称这个对象为所有实例的原型。__proto__： 每个对象都拥有__proto__属性，该属性用于实现原型链，当访问一个对象的属性时，如果该对象内部不存在这个属性，就通过原型链找直到找到或者到终点 null。constructor：每个原型都有一个 constructor 属性指向关联的构造函数 Object() 与 Function() 所有的对象都是由 Object() 构造函数构造的，所有的函数声明 / 函数表达式都是 Function() 构造函数的实例，而 Object() 构造函数本身又是 Function() 构造函数的实例，其原型关系如下：
需要注意的是 Function() 的__proto__属性直接指向的是其原型对象。
我们可以用下面的代码来验证这张图：在 node 环境及浏览器环境下都是一样的结果
console.log(Object.__proto__ === Function.prototype) // true console.log(Function.__proto__ === Function.prototype) // true console.log(Function.prototype.__proto__ === Object.prototype) // true console.log(Object.prototype.__proto__ === null) // true 继承 首先要理解构造函数 new 时执行了哪些操作
创建一个新对象，并做原型绑定（该对象的 __proto__ 属性指向构造函数的 prototype 属性指向的对象）将 this 绑定到这个新对象上执行构造函数中的代码（为这个新对象添加属性）返回新对象（一般情况下，构造函数不返回值，但是用户可以选择主动返回对象，来覆盖正常的对象创建步骤） 模拟实现 new
function _new (fn, .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd131a44c65499a357041a95865996ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56bf60ea361c9109c518d28d86088b09/" rel="bookmark">
			JavaScript 学习之旅（三）this
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 this 的作用域this 到底是什么调用位置绑定规则默认绑定隐式绑定显式绑定new 绑定判断 this 其他注意事项被忽略的 this箭头函数闭包中的 this 参考资料：《你不知道的 JavaScript 上卷》 this 是一个很特别的关键字，被自动定义在所有函数的作用域中。 this 的作用域 一种常见的误解是，this 指向函数的作用域。这个说法在某种情况下是正确的，但是在其他情况下却是错误的。需要明确的是，this 在任何情况下都不指向函数的词法作用域。在 JavaScript 内部，作用域确实和对象类似，可见的标识符都是它的属性。但是作用域“对象”无法通过 JavaScript 代码访问，它存在于 JavaScript 引擎内部。
思考下面一段代码，它试图（但是没有成功）跨越边界，使用 this 来隐式调用函数的词法作用域：
function foo () { var a = 2 this.bar() } function bar () { console.log(this.a) } foo() 首先，这段代码试图通过 this.bar() 来引用 bar() 函数，这是不可能成功的。调用 bar() 最自然的方法就是省略前面的 this，直接使用词法引用标识符。
此外，这段代码还试图使用 this 联通 foo() 和 bar() 的词法作用域，从而让 bar() 可以访问 foo() 作用域里的变量 a，这是不可能实现的，你不能使用 this 来引用一个词法作用域内部的东西。
this 到底是什么 this 是在运行时绑定的，并不是在编写时绑定的，它的上下文取决于函数调用时的各种条件。this 的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/56bf60ea361c9109c518d28d86088b09/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f5a7ba7f9ba010b3f1d351355662458/" rel="bookmark">
			C#操作三菱FX系列PLC数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[具体三菱PLC的通信协议格式如这篇博文中的举例，可以参考一下](https://blog.csdn.net/caodunchao/article/details/51564484) using System; using System.Collections.Generic; using System.Linq; using System.Text; /* CreateBy:sappmims@163.com date:2019-10-10 使用Socket方式与PLC通讯中的数据使用的是 地址转换为具体的操作方法，这段代码只使用了int 读写，bool读写。 俗话说的D 地址，M地址。 具体就是将如 读取M300的位， 这样一个地址转换为 500000FF03FF000018001004010001 M*00 0300 0001 这样一个地址头，然后再使用socket发送到PLC。等待PLC返回数据。 因为三菱PLC的操作都是在socket传送的数据中心完成的，所以发送的字符串中的相应的位就代表需要干的事情。这里面还是有很多规定的，具体的相关协议可以参考三菱的官方文档，不同系列PLC之间使用的也不一样。 当前这个代码通讯的PLC为：L61PR，R61，其他的PLC还没有经过测试。 */ namespace UCE_NetConnectPLC { /// &lt;summary&gt; /// 将字符串地址转换为IO地址 /// &lt;/summary&gt; class IOAddressToStringAddress { /// &lt;summary&gt; /// 转换为读取INT地址 /// &lt;/summary&gt; /// &lt;param name="IO"&gt;IO地址&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public string GetReadIntAddress(string IO) { //500000FF03FF000018001004010000 D*00 7000 0002 //D7000读取 int string strHed = IO.Substring(0, 1);//得出地址头，M，D地址头 M3000得出M， string address = IO.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f5a7ba7f9ba010b3f1d351355662458/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ba5154b2a065f7902a7dbc00d6be1a0/" rel="bookmark">
			任意文件读取与下载漏洞
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文首发在先知社区
0x00前言 上周参加了一个线上赛。有个Web题的WriteUp说是任意文件下载。由于之前没学过，所以就没有想到。现在学习一下
0x01为什么产生任意文件读取与下载漏洞 一些网站的业务需要，可能提供文件查看或下载的功能，如果对用户查看或下载的文件不做限制，就能够查看或下载任意的文件，可以是源文件，敏感文件等等。
0x02任意文件读取漏洞 任意文件读取是属于文件操作漏洞的一种，一般任意文件读取漏洞可以读取配置信息甚至系统重要文件。严重的话，就可能导致SSRF，进而漫游至内网。
漏洞产生原因
存读取文件的函数读取文件的路径用户可控，且未校验或校验不严输出了文件内容 任意文件读取
&lt;?php $filename=”test.txt”; readfile($filename); ?&gt; &lt;?php $filename=”test.txt”; echo file_get_contents($filename); ?&gt; 文件读取函数
readfile()、file_get_contents()、fopen()中，$filename没有经过校验或者校验不合格，用户可控制变量读取任意文件，如/etc/passwd、./index.php、/config.ini。
0x03任意文件下载漏洞 一些网站由于业务需求，往往需要提供文件下载功能，但若对用户下载的文件不做限制，则恶意用户就能够下载任意敏感文件，这就是文件下载漏洞。
漏洞产生原因
有读取文件的函数读物文件的路径用户可控，且没有经过校验，或者校验不严格输出文件内容一个正常的网站，存在一个下载文件的功能，同时还会从浏览器接收文件名字 文件下载的两种方式
1、直接下载：
&lt;a href=”http://www.a.com/xxx.rar”&gt;下载&lt;/a&gt; 2、增加header头
&lt;?php $filename = $_GET['filename']; echo '&lt;h1&gt;讲开始下载文件！&lt;/h1&gt;&lt;br /&gt;&lt;br /&gt;'; echo file_get_contents($filename); header('Content-Type: imgage/jpeg'); header('Content-Disposition: attachment; filename='.$filename); header('Content-Lengh: '.filesize($filename)); ?&gt; 漏洞利用方式 利用思路
下载常规的配置文件，例如: ssh,weblogic,ftp,mysql等相关配置下载各种.log文件，从中寻找一些后台地址，文件上传点之类的地方，如果运气好的话会获得一些前辈们的后门。下载web业务文件进行白盒审计，利用漏洞进一步攻入服务器。 尝试读取/root/.bash_history看自己是否具有root权限。
如果没有，就只能利用../来回跳转读取一些.ssh下的配置信息文件。
读取mysql下的.bash_history文件。来查看是否记录了一些可以利用的相关信息。然后逐个下载需要审计的代码文件，但是下载的时候变得很繁琐，只能尝试去猜解目录，然后下载一些中间件的记录日志进行分析。
一些常见利用方式
java+oracle环境 可以先下载/WEB-INF/classes/applicationContext.xml 文件，这里面记载的是web服务器的相应配置，然后下载/WEB-INF/classes/xxx/xxx/ccc.class对文件进行反编译，然后搜索文件中的upload关键字看是否存在一些api接口，如果存在的话我们可以本地构造上传页面用api接口将我们的文件传输进服务器。
也可以先下载网站的配置文件，在根目录/WEB-INF/Web.xml的(一般都有很多内容,有时含有数据库连接用户名和密码等关键信息)。
具有root权限 在linux中有这样一个命令 locate 是用来查找文件或目录的，它不搜索具体目录，而是搜索一个数据库/var/lib/mlocate/mlocate.db。这个数据库中含有本地所有文件信息。Linux系统自动创建这个数据库，并且每天自动更新一次。
当我们不知道路径是什么的情况下，这个可以说是一个核武器了，我们利用任意文件下载漏洞将mlocate.db文件下载下来，利用locate命令将数据输出成文件，这里面包含了全部的文件路径信息。
locate 读取方法
locate mlocate.db admin 可以将mlocate.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ba5154b2a065f7902a7dbc00d6be1a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/572e1060f18e9f1f7afae3889b4adee7/" rel="bookmark">
			pycharm报python package tools not found错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用pycharm开发，本机是ArchLinux，安装有python2.7， python3.7两个版本
但是
pycharm报python2.7的 Pyhton Interpreter 报python package tools not found错误
原因：系统安装的pip 是到了Python3的相关目录去了，python2的pip是缺失的。
因此还需要安装python2版本对应的pip:
sudo pacman -S python-pip python2-pip 至此搞定。pycharm完美运行。
by Sven Augustus
如需更多的了解加入python裙906407826嗷~🤭
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab8a4c8fdf6e8b9153e76248a8cd967b/" rel="bookmark">
			PTA练习：猜数字（C语言,通俗解法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一群人坐在一起，每人猜一个 100 以内的数，谁的数字最接近大家平均数的一半就赢。本题就要求你找出其中的赢家。
输入格式：
输入在第一行给出一个正整数N（≤104​​）。随后 N 行，每行给出一个玩家的名字（由不超过8个英文字母组成的字符串）和其猜的正整数（≤ 100）。
输出格式：
在一行中顺序输出：大家平均数的一半（只输出整数部分）、赢家的名字，其间以空格分隔。题目保证赢家是唯一的。
输入样例：
7
Bob 35
Amy 28
James 98
Alice 11
Jack 45
Smith 33
Chris 62
输出样例：
22 Amy
#include &lt;stdio.h&gt;
#include&lt;math.h&gt;
#include&lt;stdlib.h&gt;
int main()
{
char name_deposit[10000][9];
//储存名字
int N, n, i, mD_value, sum = 0, num_deposit[10000];
//差值mD_value 存储num
double ave;//也可以为int型
scanf("%d", &amp;N);
for (i = 0; i &lt; N; i++)//将输入的name与num存储，首项开始1-1对应
{
scanf("%s %d", name_deposit[i], &amp;num_deposit[i]);
sum += num_deposit[i];
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab8a4c8fdf6e8b9153e76248a8cd967b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c56a2eb155f37fede879051817cd679/" rel="bookmark">
			@EnableDubboConfiguration 与 @EnableDubbo 的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		@EnableDubboConfiguration 与 @EnableDubbo 的区别 第一次写博客，很紧张这两注解干啥子的@EnableDubboConfiguration@EnableDubbo@DubboComponentScan@EnableDubboConfig 我胡汉三又回来啦，哈哈哈~ 第一次写博客，很紧张 之前遇到疑惑解决完都是做笔记，然后默默整理在电脑某个盘中的某个角落，和某些增加生活色彩的资料放一起，即方便又整洁，但是别人来请教的时候就有些麻烦了~想来想去，博客比较牛*，那以后就写博客吧。
是酱紫的，公司安排的工作只是重复的写业务代码，所有底层的东西都被包干净了，自己完全碰不到，作为把《天局》放在枕边，对未来有追求，想拼搏的有志青年，怎么能不去偷偷看别人的代码呢，即便你看完别人代码有问题想询问，但是那个人就是不搭理你，你也不能放弃呀~对吧，这次公司用了dubbo，但是怎么发布服务啥的我都两眼一波黑，所以就自己搭了一个玩，却发现项目用的和网上的有一些不一样，第一次写博客就聊点简单的吧，在启动类加@EnableDubboConfiguration 与@EnableDubbo 的区别。
这两注解干啥子的 dubbo用xml配置真的太繁琐了 ps:公司还在这样配，不晓得为啥子，我也不敢说，我也不敢问~ 在springBoot中，以注解的形式发布和调用服务，简直不要太舒服，在消费端，启动类中配上@EnableDubboConfiguration或者@EnableDubbo，调用的时候配上@Reference注入依赖，就可以调用啦，真的非常方便。
@EnableDubboConfiguration 在生产端和消费端都加上此注解来表示使用dubbo服务，但是在生产端最好在加上@EnableCaching注解，用来启用缓存。
@EnableDubbo @EnableDubbo 注解也是启动dubbo服务，它整合了 @EnableDubboConfig 和 @DubboComponentScan ps:想要使用这个注解，项目需要使用 Spring Framework 4.2 以上版本。
@DubboComponentScan @DubboComponentScan 作为 Dubbo 2.5.7 新增的 Annotation，是XML 元素 dubbo:annotation 的替代方案。它在扫描的时候 只需关注 @Service 和 @Reference两个注解，它除了将 Dubbo @Service 类暴露 Dubbo 服务外，还把 Spring Bean @Reference字段或者方法注入了 Dubbo 服务代理。
@Reference字段所在的声明类不是 Spring Bean 的话， @DubboComponentScan 不会处理@Reference注入，其原理与 Spring @Autowired 一致。
说白了这玩意就是个扫描dubbo暴露出来的接口的，要是不指定路径，在启动类配上会扫描整个项目。
@EnableDubboConfig @EnableDubboConfig 提供外部化配置属性与 Dubbo 配置类之间的绑定。
multiple : 表示是否支持多Dubbo 配置 Bean 绑定但是2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c56a2eb155f37fede879051817cd679/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48bf776f46797afe27cfb7e2f9fcf95b/" rel="bookmark">
			记录一次向maven中央仓库提交依赖包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. 想要向maven中央仓库提交依赖包，第一步需要注册一个sonatype的账号；注册地址：
https://issues.sonatype.org/secure/Signup!default.jspa
输入邮箱用户名跟密码即可注册sonatype的账号。
二.注册成功后登陆，点击左上角的Create，创建item，Project选择Community Support - Open Source Project Repository Hosting (OSSRH)
其中Group Id的需要填跟你项目的&lt;groupId&gt;&lt;/groupId&gt;一致，可以填写github的地址。
Project URL填写github的项目地址。
SCM 填写github的项目地址.git。
创建 Issue 后，等待管理员审核通过就行了，这里需要注意，如果填写的是github的地址，管理员会让你在git上创建一个仓库，到时候记得按照管理员的要求创建一个就行。一般会在24小时内审核完成。当Issue的Status变为RESOLVED 或 FIXED 后，即可进行下一步操作。
三. 安装GPG密钥，用于加密的，上传到中央仓库的依赖需要加密，下载地址：
https://www.gpg4win.org/download.html
安装成功后打开软件，选择新建密钥对，创建个人OpenPGP密钥对，输入名字跟邮箱，下一步会提示输入密码，记住这个密码，发布到中央仓库的时候要用，密钥创建完成后将公钥发布至服务器就行
四. 项目pom文件中需要加入依赖以及Maven的settings.xml配置文件需要添加设置
可以引入父工程
&lt;parent&gt; &lt;groupId&gt;org.sonatype.oss&lt;/groupId&gt; &lt;artifactId&gt;oss-parent&lt;/artifactId&gt; &lt;version&gt;7&lt;/version&gt; &lt;/parent&gt; &lt;!--这里配置作者信息，根据自己情况配置 --&gt; &lt;licenses&gt; &lt;license&gt; &lt;name&gt;&lt;/name&gt; &lt;url&gt;&lt;/url&gt; &lt;distribution&gt;&lt;/distribution&gt; &lt;/license&gt; &lt;/licenses&gt; &lt;scm&gt; &lt;tag&gt;&lt;/tag&gt; &lt;url&gt;&lt;/url&gt; &lt;connection&gt;&lt;/connection&gt; &lt;developerConnection&gt;&lt;/developerConnection&gt; &lt;/scm&gt; &lt;developers&gt; &lt;developer&gt; &lt;name&gt;&lt;/name&gt; &lt;email&gt;&lt;/email&gt; &lt;organization&gt;&lt;/organization&gt; &lt;/developer&gt; &lt;/developers&gt; 然后打开Maven的settings.xml配置文件，配置sonatype账号信息，注意别加错地方：
&lt;servers&gt; &lt;server&gt; &lt;id&gt;sonatype-nexus-snapshots&lt;/id&gt; &lt;username&gt;Sonatype 账号&lt;/username&gt; &lt;password&gt;Sonatype 密码&lt;/password&gt; &lt;/server&gt; &lt;server&gt; &lt;id&gt;sonatype-nexus-staging&lt;/id&gt; &lt;username&gt;Sonatype 账号&lt;/username&gt; &lt;password&gt;Sonatype 密码&lt;/password&gt; &lt;/server&gt; &lt;/servers&gt; 五.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/48bf776f46797afe27cfb7e2f9fcf95b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30a68c3d61d5bb3bafee737106747bc3/" rel="bookmark">
			数据挖掘算法FP-Tree的实现---java
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据挖掘算法FP-tree算法的实现 1.算法简介 FP-Tree算法全称是FrequentPattern Tree算法，就是频繁模式树算法，他与Apriori算法一样也是用来挖掘频繁项集的，不过不同的是，FP-Tree算法是Apriori算法的优化处理，他解决了Apriori算法在过程中会产生大量的候选集的问题，而FP-Tree算法则是发现频繁模式而不产生候选集。但是频繁模式挖掘出来后，产生关联规则的步骤还是和Apriori是一样的。
2.算法的实现 1.实验数据集 牛奶，鸡蛋，面包，薯片 鸡蛋，爆米花，薯片，啤酒 鸡蛋，面包，薯片 牛奶，鸡蛋，面包，爆米花，薯片，啤酒 牛奶，面包，啤酒 鸡蛋，面包，啤酒 牛奶，面包，薯片 牛奶，鸡蛋，面包，黄油，薯片 牛奶，鸡蛋，黄油，薯片 2.实验代码 FPTree.java
package package1; import java.io.BufferedReader; import java.io.FileReader; import java.io.IOException; import java.util.ArrayList; import java.util.Collections; import java.util.Comparator; import java.util.HashMap; import java.util.LinkedList; import java.util.List; import java.util.Map; import java.util.Map.Entry; import java.util.Set; public class FPTree { private int minSuport; public int getMinSuport() { return minSuport; } public void setMinSuport(int minSuport) { this.minSuport = minSuport; } // 从若干个文件中读入Transaction Record public List&lt;List&lt;String&gt;&gt; readTransRocords(String.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/30a68c3d61d5bb3bafee737106747bc3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e34bcd04bfdeea5770c2b02ee8e38577/" rel="bookmark">
			除数为0,程序异常的处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import random
while True:
def exp_exception(x,y):
try:
a=int(x/y)
print(“a=”, a)
return a
except Exception:
print(“程序出现异常，异常信息：被除数为0”)
cs_input=int(input(“请输入被除数”))
exp_exception(random.randint(10000),cs_input)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/725bfab0c1d3ab3d5672f3c1cb50826e/" rel="bookmark">
			ASCII 字符集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://www.jianshu.com/p/4d0f7fb2967b ASCII 计算机是用数字编码来储存字符的，美国标准信息交换码ASCII码是最常用的编码。American Standard Code for information Interchange表中的 ^ 表示 Ctrl 键。 ASCII 表格 十进制八进制十六进制二进制字符ASCII 名称0000000 0000^@NUL1010x10000 0001^ASOH2020x20000 0010^BSTX3030x30000 0011^CETX4040x40000 0100^DEOT5050x50000 0101^EENQ6060x60000 0110^FACK7070x70000 0111^GBEL80100x80000 1000^HBS90110x90000 1001^I , tabHT100120xa0000 1010^JLF110130xb0000 1011^KVT120140xc0000 1100^LFF130150xd0000 1101^MCR140160xe0000 1110^NSO150170xf0000 1111^OSI160200x100001 0000^PDLE170210x110001 0001^QDC1180220x120001 0010^RDC2190230x130001 0011^SDC3200240x140001 0100^TDC4210250x150001 0101^UNAK220260x160001 0110^VSYN230270x170001 0111^WETB240300x180001 1000^XCAN250310x190001 1001^YEM260320x1a0001 1010^ZSUB270330x1b0001 1011^[ , escESC280340x1c0001 1100^\FS290350x1d0001 1101^]GS300360x1e0001 1110^^RS310370x1f0001 1111^_US320400x200010 0000spaceSP330410x210010 0001! 340420x220010 0010" 350430x230010 0011# 360440x240010 0100$ 370450x250010 0101% 380460x260010 0110&amp; 390470x270010 0111'单引号400500x280010 1000( 410510x290010 1001) 420520x2a0010 1010* 430530x2b0010 1011+ 440540x2c0010 1100,逗号450550x2d0010 1101-短横线460560x2e0010 1110.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/725bfab0c1d3ab3d5672f3c1cb50826e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2013a1fd4e4fc293dd0f59a0a684cc23/" rel="bookmark">
			Anaconda3安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Anaconda3安装 Anaconda3简介： Anaconda 就是可以便捷获取包且对包能够进行管理，同时对环境可以统一管理的发行版本。Anaconda 包含了 conda、Python 在内的超过 180 个科学包及其依赖项。
Anaconda3作用： ----管理包-----------------------
Anaconda 是在 conda（一个包管理器和环境管理器）上发展出来的。在数据分析中，你会用到很多第三方的包，而conda（包管理器）可以很好的帮助你在计算机上安装和管理这些包，包括安装、卸载和更新包。
----管理环境---------------------
假设你在A项目中用到了Python2，而新的项目要求使用Python3，而同时安装两个Python版本可能会造成许多混乱和错误。这时候Anaconda就可以帮助你为不同的项目建立不同的运行环境。
Anaconda3安装： Anaconda3官网下载点击跳入
安装过程很简单，一路 next 即可，注意最好将 conda 添加到环境变量中，更加方便使用。
常用命令： 升级包：conda upgrade --all
创建环境：conda create -n xxx python=3
环境列表：conda env list
环境包列表：conda list
激活环境：activate xxx
安装第三方包：conda install requests
卸载第三方包：conda remove requests
查看当前环境包信息：conda list
导出环境包信息：conda env export &gt; environment.yaml
导入环境包：conda env create -f environment.yaml
复制环境：conda create --name &lt;new_env_name&gt; --clone &lt;copied_env_name&gt;
删除环境：conda remove --name &lt;env_name&gt; --all
Anaconda3源修改 由于默认源下载速度较慢，我们使用清华源进行下载。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2013a1fd4e4fc293dd0f59a0a684cc23/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/833594bd74729e8711825bae9d616d04/" rel="bookmark">
			MD5算法全解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 这段时间刚好正在做软件安全的实验和课设，学习了各种加密算法，比如对称加密算法的DES,AES；非对称加密算法的RSA,再如今天要讲的主角-单向加密算法的MD5。为什么这么多算法，MD5成为了今天的猪脚呢？，这是因为个人感觉在目前Android开发中MD5算是比较常用的，所以很值得一讲。所以今天让我带你们来全面认识我们的主角MD5。
一、基本概念 1. 单向加密算法 在介绍MD5算法前，很有必要解释一下单向加密算法。单向加密，人如其名，就是只能单向对明文进行加密，而不能逆向通过密文得到明文。该算法在加密过程中，在得到明文后，经过加密算法得到密文，不需要使用密钥。因为没有密钥，所以就无法通过密文得到明文。
2. MD5算法 MD5,全称Message Digest Algorithm 5，翻译过来就是消息摘要算法第5版，是计算机安全领域广泛使用的一种散列函数，用于确保信息传输的完整性。MD5算法是由MD2、MD3、MD4演变而来，是一种单向加密算法，一种不可逆的加密方式。
二、特点 1.长度固定 不过多长的数据，经过MD5加密后其MD5值长度都是固定的。MD5值长度固定为128位，而最后的值一般都用16进制数字表示，一个16进制数字占4位，所以最后的MD5值都是用32个16进制数字表示。
2.计算简单 MD5算法说到底还是散列算法，或者叫做哈希算法，所以计算一个数据的MD5值是比较容易的，同时加密速度也是很快的。
3.抗修改性 对原数据进行任何改动，哪怕只是修改1个字节，所得到的MD5值都有很大的区别。
4.强抗碰撞性 已知原数据和其MD5值，很难找到具有相同MD5值的数据，即很难伪造数据。这里的碰撞在后面的安全性中会提到，在这里我们简单理解为一种破解手段。
三、原理 1.填充数据 首先计算数据长度（bit）对512求余的结果，如果不等于448，就需要填充数据使得数据长度对512求余的结果为448，其填充方式为第一位填充1，其余位填充0.填充后数据长度为512*N+448。
2.记录数据长度 用64位来存储填充前数据的长度，这64位将加在填充后数据的后面，这样最终的数据长度为512*N+448+64=(N+1)*512
3.装入标准幻数 标准幻数其实就是4个整数，我们知道最终的MD5值长度为128位，按32位分成一组的话可以分成4组，而这4组结果就是由这4个标准幻数A,B,C,D经过不断演变得到。在MD5官方的实现中，四个幻数为（16进制）：
A=01234567 B=89ABCDEF C=FEDCBA98 D=76543210 其实上面是大端字节序的幻数，而在正常程序中，我们实现的是小端字节序，所以在程序中我们定义的幻数应该是：
A=0X67452301 B=0XEFCDAB89 C=0X98BADCFE D=0X10325476 4.四轮循环运算 在上面对数据处理后，数据长度将是（N+1）/512,我们将每512位（64字节）作为一块，总共要循环N+1次，并将块细分为16个小组，每组的长度为32位（4字节），这16个小组即为一轮，总共得循环4轮，即64次循环。总的来说我们需要（N+1）个主循环，每个主循环包含了64次子循环，来不断的改变幻数A,B,C,D才能最终得到数据的MD5值。
4.1 相关系数说明 1）4个非线性函数
F(x,y,z)=(x&amp;y)|((~x)&amp;z)G(x,y,z)=(x&amp;z)|(y&amp;(~z))H(x,y,z)=xyzI(x,y,z)=y^(x|(~z)) 在4轮循环中，F,G,H,I会交替使用，第一轮使用F,第二轮使用G,第三轮使用H，第四轮使用I。即每隔16次循环会换一个函数。
2）Mi
将每一块512位分成16等分，命名为M0~M15,每一等份长度为32位16次循环中，交替使用
3) Kj
常量数组，在64子循环中用到的常量都是不同的
4) s
左移量，每轮循环用的S各不相同，每轮总共有4个左移量，每4次循环为一周期
4.2 核心公式 总共有四个核心公式，与4个非线性函数一一对应，即每轮使用的核心公式里的公式有差异。
FF(a,b,c,d,Mi,s,Kj)：表示b+((a+F(b,c,d)+Mi+Kj)&lt;&lt;&lt;s)GG(a,b,c,d,Mi,s,Kj)：表示b+((a+G(b,c,d)+Mi+Kj)&lt;&lt;&lt;s)HH(a,b,c,d,Mi,s,Kj)：表示b+((a+H(b,c,d)+Mi+Kj)&lt;&lt;&lt;s)II(a,b,c,d,Mi,s,Kj)：表示b+((a+I(b,c,d)+Mi+Kj)&lt;&lt;&lt;s) 四、算法实现 public class MD5 { //16进制数字 private static final String[] hexes = {"0", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/833594bd74729e8711825bae9d616d04/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2c394dc0eb06351456d4657f3380de5/" rel="bookmark">
			ocr---训练自己的数据实现文本检测（kears实现east网络）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先对于文本检测，进行简单的切割有的时候是不太现实的，可能会大量切不到。使用ctpn网络对图像文本进行切割，只能识别比较水平的文本，对于不规整的效果很差，我们使用旷世的east网络进行切割。代码来源官方》
首先展示一下使用官方提供的模型测试的效果：代码地址：https://github.com/huoyijie/AdvancedEAST
先展示目录结构
预测代码predict.py：模型地址 链接: https://pan.baidu.com/s/1KO7tR_MW767ggmbTjIJpuQ 密码: kpm2
import argparse import numpy as np from PIL import Image, ImageDraw from keras.preprocessing import image from keras.applications.vgg16 import preprocess_input import cfg from label import point_inside_of_quad from network import East from preprocess import resize_image from nms import nms def sigmoid(x): """`y = 1 / (1 + exp(-x))`""" return 1 / (1 + np.exp(-x)) def cut_text_line(geo, scale_ratio_w, scale_ratio_h, im_array, img_path, s): geo /= [scale_ratio_w, scale_ratio_h] p_min = np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e2c394dc0eb06351456d4657f3380de5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e837df1cc98a88b9e17ae95a158b9ae/" rel="bookmark">
			torch.optim.lr_scheduler：调整学习率
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文是笔者在学习cycleGAN的代码时，发现其实现了根据需求选择不同调整学习率方法的策略，遂查资料了解pytorch各种调整学习率的方法。主要参考：https://pytorch.org/docs/stable/optim.html#how-to-adjust-learning-rate
1 综述 1.1 lr_scheduler综述 torch.optim.lr_scheduler模块提供了一些根据epoch训练次数来调整学习率（learning rate）的方法。一般情况下我们会设置随着epoch的增大而逐渐减小学习率从而达到更好的训练效果。
而torch.optim.lr_scheduler.ReduceLROnPlateau则提供了基于训练中某些测量值使学习率动态下降的方法。
学习率的调整应该放在optimizer更新之后，下面是一个参考蓝本：
&gt;&gt;&gt; scheduler = ... &gt;&gt;&gt; for epoch in range(100): &gt;&gt;&gt; train(...) &gt;&gt;&gt; validate(...) &gt;&gt;&gt; scheduler.step() 注意： 在PyTorch 1.1.0之前的版本，学习率的调整应该被放在optimizer更新之前的。如果我们在 1.1.0 及之后的版本仍然将学习率的调整（即 scheduler.step()）放在 optimizer’s update（即 optimizer.step()）之前，那么 learning rate schedule 的第一个值将会被跳过。所以如果某个代码是在 1.1.0 之前的版本下开发，但现在移植到 1.1.0及之后的版本运行，发现效果变差，需要检查一下是否将scheduler.step()放在了optimizer.step()之前。
1.2 optimizer综述 为了了解lr_scheduler，我们先以Adam()为例了解一下优化器（所有optimizers都继承自torch.optim.Optimizer类）：
语法：
class torch.optim.Adam(params, lr=0.001, betas=(0.9, 0.999), eps=1e-08, weight_decay=0, amsgrad=False) 参数：
params (iterable)：需要优化的网络参数，传进来的网络参数必须是Iterable（官网对这个参数用法讲的不太清楚，下面有例子清楚的说明param具体用法）。 如果优化一个网络，网络的每一层看做一个parameter group，一整个网络就是parameter groups（一般给赋值为net.parameters()），补充一点，net.parameters()函数返回的parameter groups实际上是一个变成了generator的字典；如果同时优化多个网络，有两种方法： 将多个网络的参数合并到一起，当成一个网络的参数来优化（一般赋值为[*net_1.parameters(), *net_2.parameters(), ..., *net_n.parameters()]或itertools.chain(net_1.parameters(), net_2.parameters(), ..., net_n.parameters()))；当成多个网络优化，这样可以很容易的让多个网络的学习率各不相同（一般赋值为[{'params': net_1.parameters()}, {'params': net_2.parameters()}, .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e837df1cc98a88b9e17ae95a158b9ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e99b9aaf5a5a9f1d78ad1b7227ca1dfb/" rel="bookmark">
			111. 二叉树的最小深度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		给定一个二叉树，找出其最小深度。 最小深度是从根节点到最近叶子节点的最短路径上的节点数量。 说明: 叶子节点是指没有子节点的节点。 示例: 给定二叉树 [3,9,20,null,null,15,7], 3 / \ 9 20 / \ 15 7 返回它的最小深度 2. 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/minimum-depth-of-binary-tree 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public int minDepth(TreeNode root) { if (root == null) { return 0; } // null节点不参与比较 if (root.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e99b9aaf5a5a9f1d78ad1b7227ca1dfb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2307c11576020a90188cd93b11a56447/" rel="bookmark">
			ocr的预处理--透视变换，重映射，仿射变换，水平矫正
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图像校正可以参考这个：https://blog.csdn.net/wsp_1138886114/article/details/83374333
透视变化：
#include&lt;opencv2/opencv.hpp&gt; using namespace cv; #define CV_SHOW(x) imshow("df",x);waitKey(0) static void testImageRectification(cv::Mat &amp;I); void main() { Mat I; //I = imread("D:\\test.bmp"); I = imread("D:\\360安全浏览器下载\\790f419bb941d239b7f5ba70b0ce82fa\\7.png"); testImageRectification(I); } static void testImageRectification(cv::Mat &amp;image_original) { CV_SHOW(image_original); // CV_SHOW是cv::imshow的一个自定义宏，忽略即可 cv::Mat &amp;&amp;image = image_original.clone(); cv::Mat image_gray; cv::cvtColor(image, image_gray, cv::COLOR_BGR2GRAY); //cv::threshold(image_gray, image_gray, g_threshVal, g_threshMax, cv::THRESH_BINARY); cv::threshold(image_gray, image_gray, 110, 250, cv::THRESH_BINARY); std::vector&lt; std::vector&lt;cv::Point&gt; &gt; contours_list; { std::vector&lt;cv::Vec4i&gt; hierarchy; // Since opencv 3.2 source image is not modified by this function cv::findContours(image_gray, contours_list, hierarchy, cv::RetrievalModes::RETR_EXTERNAL, cv::ContourApproximationModes::CHAIN_APPROX_NONE); } for (uint32_t index = 0; index &lt; contours_list.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2307c11576020a90188cd93b11a56447/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4953983b49d296b8dc80c22aedcba72c/" rel="bookmark">
			markdown图片左对齐
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图片默认居中，在图片路径前面加上空格，即可左对齐，右对齐需要用到css
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d4623c905e0dd16e24145659787bac1/" rel="bookmark">
			Python Day1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python安装 在linux系统上安装Python3.X
安装依赖：
yum -y install gcc zlib zlib-devel xz 下载Python安装包
wget https://www.python.org/ftp/python/3.6.3/Python-3.6.3.tar.xz 解压并编译安装
tar -xf Python-3.6.2.tar.xzcd Python-3.6.2./configuremake &amp;&amp; make install 修改系统中python软连接
ln -sf /usr/local/bin/python3 /usr/bin/python [root@bogon tool]# ll /usr/bin/pythonlrwxrwxrwx 1 root root 22 3月 22 11:09 /usr/bin/python -&gt; /usr/local/bin/python3 为保证yum正常使用，修改指定yum命令所使用的python版本（要根据/usr/bin/目录下python原来的版本修改）
sed -i '1s@python@python2.7@' /usr/bin/yum 文件头 #!/usr/bin/env python# -*- coding: utf-8 -*- 变量 变量名称不允许使用数字开头，不允许有空格，不允许有*号等特殊符号
age_of_dzm = 18 #上面这是推荐的变量名称
AGE_OF_DZM = 18 #上面这种全部使用大写字母的方式不会报错，但约定俗成一般表示常量，Python里没有严格意义上的常量
#引用变量
age_of_dzm = 18print(age_of_dzm)18print('age_of_dzm')age_of_dzm #由此可见，加了单引号后print出的是字符串本身，并没有引用变量
多引号的用途 '''这里的多引号表示多行注释（我是第二行）''' #多引号也可以用于定义变量时定义一多行内容
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d4623c905e0dd16e24145659787bac1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7a68984075a7c8e9974881630a9fd29/" rel="bookmark">
			jTessBoxEditor训练中文字库简易版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 安装jTessBoxEditor（需安装java，中文识别需要FX版本）
2.双击打开，如果打不开（java -jar jar的路径）
3.打开 jTessBoxEditor ，选择 Tools -&gt; Merge TIFF，选择要训练的图片，保存.tif的路径
4.在tifi的路径下cmd：tesseract chi_my.font.exp0.tif chi_my.font.exp0 -l chi_sim batch.nochop makebox
5.jTessBoxEditorFX开打.box文件，调整文字位置和文字内容
6.目录路径下cmd:echo font 0 0 0 0 0&gt;font_properties 7.tesseract chi_my.font.exp0.tif chi_my.font.exp0 nobatch box.train
8. 生成之后手工修改 Clustering 过程生成的 4 个文件（inttemp、pffmtable、normproto、shapetable）的名称为 [lang].xxx。这里改为 chi_my.inttemp、chi_my.pffmtable、chi_my.normproto、chi_my.shapetable
mv inttemp chi_my.inttemp
mv pffmtable chi_my.pffmtable
mv normproto chi_my.normproto
mv shapetable chi_my.shapetable
9.合并：combine_tessdata chi_my.
10.把chi_my.traineddata 放到tesseract-ocr\tessdata下面
一、素材准备
1.图片转tif：jtessBoxEditor
2.tif生成Box：tesseract xxx.tif xxx batch.nochop makebox（如果是中文加参数 -l chi_sim，即：tesseract xxx.tif xxx -l chi_sim batch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f7a68984075a7c8e9974881630a9fd29/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/223c0a8e651403aa0b090f51e3cf91ff/" rel="bookmark">
			ArcObjects、ArcGIS Engine、ArcGIS Runtime以及Pro SDK的区别与联系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		众所周知，ArcGIS的产品种类很多，光ArcGIS桌面端的二次开发产品就包括ArcGIS Engine、ArcGIS Runtime以及ArcGIS Pro SDK。初学者时常被这些产品搞乱，既不清楚这些产品的区别与联系，也不清楚做开发时应该选择哪种产品。由于这个问题被问的频率实在太高了，所以这里写个普及贴，以帮助大家更好的定位各个产品。
1，ArcObjects和ArcGIS Engine的区别和联系 ArcObjects：是一整套组件式开发接口的统称，ArcGIS Desktop（不含ArcGIS Pro）、ArcGIS Engine、ArcGIS Server都是基于ArcObjects开发出来的产品，下图一看便知：
所有这些功能模块都是ArcObjects，所以说ArcObjects的功能非常强大，既可以进行Desktop的扩展开发，也可以进行Server的功能扩展，如Server Object Extension（俗称SOE），也可以进行ArcGIS Engine开发。
ArcGIS Engine：于2004年发布，是基于COM技术的可嵌入的组件库和工具包，构建在核心的ArcObjects之上，完全可扩展。它提供多种开发接口，可以适应.NET，Java和C++等开发环境，开发者可以使用这些组件来开发和GIS相关的地图应用。ArcGIS Engine既可以开发出具有地图界面的独立应用程序，也可以开发出进行后台数据处理的控制台程序，还可以进行嵌入式开发。ArcGIS Engine在10.0及之前版本又称为ArcGIS Engine Runtime，这里要和ArcGIS Runtime产品进行区分，经常有用户以为ArcGIS Runtime就是之前的Engine Runtime，这两者是不同的产品。此外，需要注意：目前ArcGIS Engine 10.7版本仅支持.Net和Java开发平台。
Tips：VC++属于.Net平台仍是支持的，但Cross Platform C++（例如Qt等）以及Engine的Linux版本从10.5版本起已经不再提供。
综上，ArcGIS Engine是ArcObjects的一部分，使用Engine可以开发出具有独立地图界面的应用程序，能够进行非常细粒度的控制，可以实现大部分ArcMap的功能（界面部分需要自定义）；而ArcObjects除了可以进行Engine开发，还可以进行ArcMap以及Server的扩展开发。
2，ArcGIS Engine与ArcGIS Runtime区别和联系 ArcGIS Runtime：是伴随ArcGIS 10.1发布而诞生的一款基于服务架构的全新产品，是一款轻量级桌面移动端跨平台开发产品。目前提供了5种API：.Net、Java、Qt、Android、IOS，支持6种平台：Windows、Linux、MacOS、UWP、Android、IOS，可以轻松构建跨平台应用程序。
ArcGIS Engine和ArcGIS Runtime 都属于开发软件，可以用来开发独立的C/S程序。但是两者的底层是不同的，Engine是基于ArcObjects的，Runtime是基于Runtime API的；另一方面其开发模式也不同，Engine是单线程、同步、32位程序，而Runtime是多线程、异步、64位程序。所以如果想从Engine迁移到Runtime上来，代码是需要重写的。此外，Engine和Runtime在功能上也各有利弊：
ArcGIS Engine：
优点：功能强大，可以实现ArcMap的大部分功能，包括操作复杂对象如拓扑，几何网络等，可以进行精细化编辑，还可以进行专业级制图。
缺点：只能32位，部署繁重，不支持矢量切片、三维场景、portal等。
ArcGIS Runtime：
优点：Esri大力发展，64位，部署简单，跨平台，展示效果好，支持矢量切片、三维场景、可以操纵Portal、此外还支持VR/AR等。
缺点：对于复杂对象、精细化编辑和专业级制图的支持稍显不足。
3，ArcGIS Runtime 10.2.x和ArcGIS Runtime 100.x的区别和联系 10.2.x和100.x都是ArcGIS Runtime的产品，所以其功能是差不多的。10.2.x是早期的Runtime版本，相信进行早期Runtime开发的用户都不陌生；而100.x采用了全新的底层架构，API进行了重新设计，使得用户熟悉了一种API可以很容易的迁移到另一种，因为其API的名称、功能、参数都是一样的，比如熟悉了Runtime .Net API可以很容易迁移到移动端如Runtime Android API上。由于10.2.x版本已经不再更新，推荐直接使用100.x。10.2.x与100.x版本在结构和功能实现上都有区别，下面简单看一下：
结构上：
ArcGIS Runtime SDK for .NET包括：
Windows Presentation Framework (WPF)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/223c0a8e651403aa0b090f51e3cf91ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21b3555e4ddc3d03a2a4f62ef4607645/" rel="bookmark">
			Problem I: 函数调用，统计数中&#39;2’的个数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Problem I: 函数调用，统计数中’2’的个数 分析 凡是对一个数字中某些数位上的数讨论运用，就是%和/以及if语句的使用而已。
Description 定义并调用函数countdigit(number, digit),它的功能是统计整数number中数字digit的个数，如countdigit(10090, 0)的返回值是3. 在主函数中定义并调用该函数，统计任意一个输入整数中’2’的个数。
Input 多组测试数据，每组输入一个整数。
Output 输出该数中’2’的个数。
Sample Input 1002
2323
4567
Sample Output 1
2
0
#include&lt;stdio.h&gt; int countdigit(int n,int digit); int main() { int a,b=2; while(scanf("%d",&amp;a)!=EOF) printf("%d\n",countdigit(a,b)); return 0; } int countdigit(int n,int digit) { int i=0; while(n){ if((n%10)==digit) i++; n/=10; } return i; } 总结 1、注意函数的使用格式的规范。
2、灵活处理%和/。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51ef268ac9a123831bdea4f3110c813f/" rel="bookmark">
			C&#43;&#43; 使用gRPC入门教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		gRPC是一个高性能、通用的开源RPC框架，其由Google主要面向移动应用开发并基于HTTP/2协议标准而设计，基于ProtoBuf(Protocol Buffers)序列化协议开发，且支持众多开发语言，能够基于语言自动生成客户端和服务端功能库。 1.新建工程GrpcClient、GrpcServer和GrpcLibrary 添加 - 新建项目 - 控制台应用 GrpcClient、GrpcServer。
添加 - 新建项目 - 类库 GrpcLibrary。 工程中的三个项目情况如下：
2.自定义服务 在项目GrpcLibrary里添加HelloWorld.proto用以生成代码。
syntax = "proto3"; package GrpcLibrary; service GrpcService { rpc SayHello (HelloRequest) returns (HelloReply) {} } message HelloRequest { string name = 1; } message HelloReply { string message = 1; } 执行命令
ThirdParty\grpc_build\bin\protoc.exe -IGrpcLibrary --cpp_out GrpcLibrary GrpcLibrary\HelloWorld.proto --grpc_out GrpcLibrary --plugin=protoc-gen-grpc=ThirdParty\grpc_build\bin\grpc_cpp_plugin.exe 命令执行成功后，GrpcLibrary目录下会生成HelloWorld.grpc.pb.cc、HelloWorld.grpc.pb.h、HelloWorld.pb.cc和HelloWorld.pb.h
将其都添加到项目GrpcLibrary中。最后GrpcClient、GrpcServer分别引用类库GrpcLibrary。
3.服务端 // greeter_server.cc #include &lt;iostream&gt; #include &lt;memory&gt; #include &lt;string&gt; #include &lt;grpcpp/grpcpp.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/51ef268ac9a123831bdea4f3110c813f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c690f365ca513b9b4cfaf5d01c1f951/" rel="bookmark">
			postgresql -- 执行计划
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、 显示执行计划 pg中explain命令格式如下
explain [options] sql语句 例如 explain select * from test; explain (format xml) select * from test; explain (analyze true,buffers true) select * from test; options可选项如下：
ANALYZE（默认FALSE）：实际执行sql，显示真实的执行计划及返回行数VERBOSE（默认FALSE）：显示附加信息，如计划树中每个节点输出的各个列、表和函数的SCHEMA 信息，表达式中列所属表的别名，被触发的触发器名（如果有用到）等COSTS（默认TRUE）：显示每个计划启动成本、总成本、预估长度及每行宽度BUFFERS（默认FALSE）：显示缓冲区使用信息，只能与ANALYZE一起使用。缓冲区信息包括共享块（常规表或者索引块）、本地块（临时表或者索引块）和临时块（排序或者哈希等涉及到的短期存在的数据块）的命中块数，更新块数，挤出块数。TIMING（默认TRUE）：显示每个计划节点的实际启动时间和总执行时间，只能与ANALYZE一起使用。对于一些系统来说，获取系统时间需要比较大的代价，如果只需要准确返回行数，而不需要准确的时间，可以把该参数关闭。SUMMARY（默认FALSE）：会在查询计划后面输出总结信息，例如查询计划生成的时间和查询执行的时间。当启用ANALYZE 时，默认TRUE。FORMAT {TEXT | XML | JSON | YAML} （默认TEXT）：指定输出格式 如果要分析慢SQL到底慢在哪里，使用 explain (analyze,verbose,timing,costs,buffers,timing) SQL;就可以，再加上一些开关，可以看到更加详细的信息。
--开关, 当前会话生效，打印更加详细的信息 set client_min_messages=debug5; set log_checkpoints = on; set log_error_verbosity = verbose ; set log_lock_waits = on; set log_replication_commands = off; set log_temp_files = 0; set track_activities = on; set track_counts = on; set track_io_timing = on; set track_functions = 'all'; set trace_sort=on; set log_statement_stats = off; set log_parser_stats = on; set log_planner_stats = on; set log_executor_stats = on; set log_autovacuum_min_duration=0; set deadlock_timeout = '1s'; set debug_print_parse = off; set debug_print_rewritten = off; set debug_print_plan = off; set debug_pretty_print = on; --例如 explain (analyze,verbose,timing,costs,buffers) select count(*),relkind from pg_class group by relkind order by count(*) desc limit 1; 二、 执行计划解释 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c690f365ca513b9b4cfaf5d01c1f951/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92c3100b3df0c636a660275398f8f645/" rel="bookmark">
			C 语言底层基础知识 11-2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C语言基本数据类型 long类型在不同的操作系统和平台上所占字节数不同，在linux i386 和windows上占4个字节，在linux x64上占8个字节。所有数据都是有字节宽度大小的，在赋值在运算中，都可以发生变化。
数据类型的意义在于：节约内存和方便访问。
## 移码： 浮点数 + 指数+127。 Char 类型变量的相关知识点 1.把一个整数赋值给char类型变量，只会把整数最低8个二进制(最低一个字节)数据赋值给char变量
2.char如果要以%d %u的格式输出 进行扩展 补最高位(符号位)
`
#include &lt;stdio.h&gt; int main (){ char a =127; char b = 128; printf("%d\n",a); printf("%u\n",a); printf("%d\n",b); printf("%u\n",b); } 运行结果如下： 127 127 -128 4294967168 1000 0000 以%d输出，前面补最高位 ，因为在这个char类型的8个二进制位中最高位是1 ，所以前面补1，最终运行结果为-128 。
对于unsigned 类型的数 ，前面补的1 没有符号位，所以输出的是一个极大的数。
3.char变量赋值给 int/unsigned 扩展位 ，补符号位。
4.unsigned char如果要以%d %u的格式输出 进行扩展补0。
5.unsigned char变量赋值给 int/unsigned 扩展位是0。
计算机关于数据类型的默认操作和隐式操作 1.整数字面如果是【-2^31,2^31-1] 之间，则默认为int类型 。 2.不同类型的数据进行计算时，计算机会进行隐式转换，比如char和int 之间的转换，char会默认转换成int类型进行计算，这个时候char类型因为只有一个字节，所以需要填补空位，填补规则如下： ①对于有符号位的数扩充符号位。 ②对于无符号位的扩充0。 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/92c3100b3df0c636a660275398f8f645/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94737fcae1ef238e0de4c55058812c10/" rel="bookmark">
			APICloud：在app中使用自定义loader进行第三方模块的调试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在app中添加外部模块(bmLocation模块)，使用自定义loader来调试 这里使用编码工具APICloud stuio
官方loader和自定义loader的在使用上的最大区别（个人见解） 官方loader中只会包含一些基础的模块供用户使用，而一当你要使用到一些第三方模块时就会发现，在控制台中绑定了第三方模块，也在配置文件config中引入该模块，但是用官方的AppLoader调试时就会报错
所以我们才需要使用到自定义loader
想了解更多关于官方loader和自定义loader的同学可以官方文档里看看，懒得找的同学戳这 自定义loader说明
开始建立自定义loader 这里需注意一点，任何一个应用有且只有一个自定义loader
首先，我们需要先去控制台随便添加一个模块，这里选择添加百度地图的定位模块bmLocation，
使用这个模块需要前往百度地图开发平台申请一个ak码，到时候配置config文件的时候要用到这个ak码，否则无法引用这个第三方的sdk
config文件中需添加如下代码来引用bmLocation模块
&lt;meta-data name="com.baidu.lbsapi.API_KEY" value="uOIxNnQGFhxejgQZcjc9DtzvhNNeXM1G"/&gt; //*value就是你申请的ak码* 生成自定义loader安装包 这里编写一段利用bmLocation模块获取本地位置的代码，等会用来测试模块是否调用成功，模块使用方法详情请戳 bmLocation说明
var bmLocation = api.require("bmLocation");//导入模块 bmLocation.configManager({//配置定位参数 accuracy: 'device_sensors', filter: 1, activityType: 'automotiveNavigation', coordinateType: 'GCJ02', locationTimeout: 10, reGeocodeTimeout: 10 }); bmLocation.singleLocation({//单次定位，获取位置 reGeocode: false, netWorkState: false }, function(ret) { var sta = ret.status; if (sta) { console.log(JSON.stringify(ret.reGeo)); var country = ret.reGeo.country; var province = ret.reGeo.province; var city = ret.reGeo.city; var district = ret.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94737fcae1ef238e0de4c55058812c10/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2713bd03a758f3995af90b5b62a6a819/" rel="bookmark">
			剑指Offer面试题：5.从尾到头打印链表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、题目 输入一个链表，按链表从尾到头的顺序返回一个ArrayList。
二、思路 1.使用头插法
使用头插法可以得到一个逆序的链表。
头结点和第一个节点的区别：
头结点是在头插法中使用的一个额外节点，这个节点不存储值；
第一个节点就是链表的第一个真正存储值的节点。
2.递归
要逆序打印链表 1-&gt;2-&gt;3（3,2,1)，可以先逆序打印链表 2-&gt;3(3,2)，最后再打印第一个节点 1。而链表 2-&gt;3 可以看成一个新的链表，要逆序打印该链表可以继续使用求解函数，也就是在求解函数中调用自己，这就是递归函数。
3.使用栈
栈具有后进先出的特点，在遍历链表时将值按顺序放入栈中，最后出栈的顺序即为逆序。
三、解决问题 3.1 代码实现 1.使用头插法 public ArrayList&lt;Integer&gt; printListReversingly_Recursively1(ListNode listNode){ //链表为空 if(listNode == null){ System.out.println("输入链表为null"); } // 头插法构建逆序链表 ListNode head = listNode,newHead = null; while (head != null) { ListNode tmp = head.next;//暂存head下一个地址, head.next = newHead;// newHead = head; head = tmp; } // 构建 ArrayList ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); while (newHead != null) { list.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2713bd03a758f3995af90b5b62a6a819/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be72bd6a88686c2e6d2c4067ad3f41bd/" rel="bookmark">
			Pyinstaller打包QGIS独立应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Pyinstaller打包QGIS独立应用 安装pyinstaller 管理员启动cmd，进入到C:\Program Files\QGIS 3.4\bin，执行命令(非稳定版为：python-qgis.bat)：
python-qgis-ltr.bat -m pip pyinstaller 测试安装 C:\Program Files\QGIS 3.4\bin&gt;python-qgis-ltr.bat -m PyInstaller usage: __main__.py [-h] [-v] [-D] [-F] [--specpath DIR] [-n NAME] [--add-data &lt;SRC;DEST or SRC:DEST&gt;] [--add-binary &lt;SRC;DEST or SRC:DEST&gt;] [-p DIR] [--hidden-import MODULENAME] [--additional-hooks-dir HOOKSPATH] [--runtime-hook RUNTIME_HOOKS] [--exclude-module EXCLUDES] [--key KEY] [-d {all,imports,bootloader,noarchive}] [-s] [--noupx] [--upx-exclude FILE] [-c] [-w] [-i &lt;FILE.ico or FILE.exe,ID or FILE.icns&gt;] [--version-file FILE] [-m &lt;FILE or XML&gt;] [-r RESOURCE] [--uac-admin] [--uac-uiaccess] [--win-private-assemblies] [--win-no-prefer-redirects] [--osx-bundle-identifier BUNDLE_IDENTIFIER] [--runtime-tmpdir PATH] [--bootloader-ignore-signals] [--distpath DIR] [--workpath WORKPATH] [-y] [--upx-dir UPX_DIR] [-a] [--clean] [--log-level LEVEL] scriptname [scriptname .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be72bd6a88686c2e6d2c4067ad3f41bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d73e7c2ffec365c5dccfe767c2c3299a/" rel="bookmark">
			Pytorch torch.cat与torch.chunk
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		部分内容摘自pytorch中文文档
torch.cat torch.cat(inputs, dimension=0) → Tensor ，在给定维度上对输入的张量序列seq 进行连接操作。
torch.cat()可以看做 torch.split() 和 torch.chunk()的反操作， cat() 函数可以通过下面例子更好的理解。
参数：
inputs (sequence of Tensors) – 可以是任意相同Tensor 类型的python 序列dimension (int, optional) – 沿着此维连接张量序列。 &gt;&gt;&gt; x = torch.randn(2, 3) &gt;&gt;&gt; x 0.5983 -0.0341 2.4918 1.5981 -0.5265 -0.8735 [torch.FloatTensor of size 2x3] &gt;&gt;&gt; torch.cat((x, x, x), 0) 0.5983 -0.0341 2.4918 1.5981 -0.5265 -0.8735 0.5983 -0.0341 2.4918 1.5981 -0.5265 -0.8735 0.5983 -0.0341 2.4918 1.5981 -0.5265 -0.8735 [torch.FloatTensor of size 6x3] &gt;&gt;&gt; torch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d73e7c2ffec365c5dccfe767c2c3299a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/253acb2b7c9dda0ed3ce1eaa5b586d5c/" rel="bookmark">
			C语言中将字符数字转换为数值的小技巧和方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C语言中将字符char类型数字转换为int类型数值的小技巧 字符0~9通过减去字符'0'可以获得数值，原理是ASCII码中，字符0~9对应的ASCII值与字符'0'的差值即为数值。如：字符‘9’的ASCII码值是57，字符‘0’的ASCII码值是48，‘9’-‘0’可等价转换成 57 - 48 = 9，所以可用以下方式进行转换。
char buf[4] = "123"; int num = 0; for (int i = 0; i &lt; strlen(buf); i++) { num = num * 10 + buf[i] - '0'; // 通过减去'0'可以将字符转换为int类型的数值 } 以上转换后num的值为：123
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d183cb01b2990a75626b83d4c1327e1/" rel="bookmark">
			Mybatis实现递归查询查找子查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Mybatis实现递归查询查找子查询 1.简单的数据结构2.实体类3.Mapper文件4.查询结果 1.简单的数据结构 2.实体类 import java.util.List; /** * @ClassName AuditTabRele * @Description tab 关系表 * @Author wangyj * @Date 19/11/7 18:38 */ public class AuditTabRele { private String tabCode; private String tabName; private String pTabCode; private String tabSort; private List&lt;AuditTabRele&gt; subTabs; public String getTabCode() { return tabCode; } public void setTabCode(String tabCode) { this.tabCode = tabCode; } public String getTabName() { return tabName; } public void setTabName(String tabName) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d183cb01b2990a75626b83d4c1327e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/690140778eae3c0a1af5fadeb2c44461/" rel="bookmark">
			神经网络中的损失函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		总览 这篇文章主要记录了对损失函数和目标函数的理解，然后介绍了两种较常用的损失函数：均方误差和交叉熵。重点是记录对于交叉熵的认识，以及为什么交叉熵可以表示损失或代价，即其作用原理。
正文 深度学习中，我们在定义神经网络模型时，首先要明确模型的损失函数(loss function)，即代价函数(cost function)。损失函数的作用是用来表示模型预测值和训练样本之间的差异，我们的目的是通过降低这个损失函数来不断改进模型参数，使模型预测越来越准确。当然，不能只降低某个预测值的损失函数，而是应当降低所有样本的总体损失函数，即全部样本上损失函数的平均值或数学期望，我们将这个期望值称为风险函数(risk function)。在训练集上，通过不断降低损失函数期望即风险函数来逐渐提高模型预测的准确度，就能得到拟合度很高的模型。但这会不可避免地造成过拟合，为了减少这种情况，还需要为损失函数加上另一个函数，即正则化函数，它用来度量模型的复杂度，我们希望模型尽可能的不复杂，以此来降低过拟合的可能性。正则化常用的有L1，L2范数。这样就最终形成了我们的目标函数(objective function)：
神经网络的训练过程就是不断降低目标函数的过程。 （上面只是一些情况的描述，不是所有情况都是这种关系，神经网络模型多种多样，解决的问题也五花八门，因此有各种各样的损失函数和目标函数，上面只是举了最简单的例子。）
接下来主要记录一下损失函数的种类。
1. 均方误差 均方误差也称均值平方差(Mean Squared Error, MSE)，在神经网络中表示预测值和真实值之间的差异，它的公式就是预测值与真实值之差平方的期望。
均方误差一般用于回归问题。
需要注意：预测值和真实值要在相同的数据分布内，即如果预测值使用sigmoid等函数进行了归一化处理，那么真实值也要进行相同的归一化处理。
2. 交叉熵 首先，理解熵的含义，可以从信息论出发，熵是指一个事件的信息量，或者说事件所含信息的最短编码长度，关于熵的深度介绍可以参考这篇文章：香农说，要有熵，于是开启了信息时代（上），（下）。这里对熵的理解不需要太深。
理解交叉熵（cross entropy），最好从KL散度入手。KL散度有时也称KL距离，用来表示两个分布之间的差异程度。两个事件或两个分布之间越相似，即差异越小，则KL散度越小。其数学公式为：
其中，熵表示为
而交叉熵为
可以看出：KL散度 = 交叉熵 - 熵
在机器学习中，我们将样本分布表示为分布A，模型预测分布表示为分布B，那么A, B之间的差异程度就可以表示为A，B的KL散度，它等于A,B的交叉熵减去A的熵：
我们训练神经网络模型的目标当然是预测值分布与真实值分布越相近越好，也就是D(A||B) 越小越好。
在多分类问题中，A和B都代表了多个分类，预测值b与哪类样本分布间的KL散度越小，则越可能归为这一类，所以KL散度可以用作分类问题的损失函数。但在深度学习中，样本A的分布情况我们是已知的，也就是熵 S(A) 是已知的，此时最小化A，B的KL散度就等价于最小化A，B的交叉熵H(A, B)。
于是，交叉熵H(A, B) 便可表示预测值和标签值之间的差异程度，将其作为损失函数，训练得到预测值与训练样本分布相近的网络模型。
在机器学习中交叉熵的公式可表示为：
其中y代表真实值，a代表预测值.
交叉熵一般用于分类问题
另外，损失函数的选取还和输入标签数据的类型有关，如果输入是实数、无界的值，损失函数用平方差；如果输入标签是位矢量（分类标志），使用交叉熵会更好。
神经网络解决的问题五花八门，实际用到的损失函数也多种多样，之后遇到实用或巧妙的损失函数，还会继续更新在这里。
参考文献：
为什么交叉熵（cross-entropy）可以用于计算代价？
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83f8dad2fd7d3ef1ccfe2f20b97d11d0/" rel="bookmark">
			算法：合并两个有序数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、题目 给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。
说明:
a.初始化 nums1 和 nums2 的元素数量分别为 m 和 n。
b.你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。
示例:
输入: nums1 = [1,2,3,0,0,0], m = 3 nums2 = [2,5,6], n = 3 输出: [1,2,2,3,5,6] 二、思路 这里要求原地修改，其实我们能只要从后往前比较，并从后往前插入即可。
我们需要三个指针：
current 用于记录当前填补到那个位置了
m 用于记录 nums1 数组处理到哪个元素了
n 用于记录 nums2 数组处理到哪个元素了
三、解决（python） class Solution: def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -&gt; None: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/83f8dad2fd7d3ef1ccfe2f20b97d11d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33928d07018e0670b36bbc1e0e7e2e95/" rel="bookmark">
			ESP8266_21基于ESP8266的一键配网
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ESP8266_01搭建开发环境
ESP8266_02程序的编译与下载
ESP8266_03SDK与Makefile的基本用法
ESP8266_04管脚控制与软件定时器
ESP8266_05 ESP8266有几个串口？
ESP8266_06硬件定时器与IO中断
ESP8266_07基于PWM的呼吸灯
ESP8266_08基于flash的数据掉电保护
ESP8266_09基于IIC控制的OLED屏幕
ESP8266_10 ESP8266的STATION模式
ESP8266_11 ESP8266的UDP广播
ESP8266_12 ESP8266客户端模式下的TCP通信
ESP8266_13服务器端模式下的TCP通信
ESP8266_14 SOFTAP模式下的服务器端和客户端
ESP8266_15天气预报之TCP的GET操作
ESP8266_16天气预报之JSON数据的生成与解析
ESP8266_17简单网络时间协议-SNTP
ESP8266_18 MQTT协议接入ONENET平台
ESP8266_19MQTT协议接入ONENET平台_订阅主题
ESP8266_20 基于ONENET平台的数据上传之TCP的POST操作
ESP8266_21基于ESP8266的一键配网
ESP8266_22基于自身ADC的电压采样
ESP8266_23基于硬件定时器的红外遥控器解码
这一节，说一下一键配网的用法。首先说为什么需要一键配网？
原因很简单，因为设备要上网？那，给那些设备配一个屏幕和一个输入设备行不行？
不是不可以，对那些成本没要求的设备是没问题的。但物联网设备大部分都是一些简单的监测、通信设备，需要的数量又很多，基本配置好以后放在那里就没人动了。所以给这样的设备添加屏幕和输入设备，在资源上是很大的浪费。
举个例子，我之前买过一个小度音箱（低配版，非广告~），使用时，先用蓝牙去连接这个设备，然后把wifi的账号、密码发给它。再然后，它会连接当前wifi。
从此以后，你再让它干什么，只要说话就行了，根本用不到屏幕或按键。
那么，说到一键配网，你的第一反应想到什么？
smartconfig还是airkiss？
先说smartconfig，具体是哪个厂家提出的我没查到，不过当前支持的厂家还是很多的，如下图所示：
注意：每家的smartconfig技术可能会有些细微的差别。
以乐鑫支持的smartconfig技术为例，首先需要手机通过UDP的方式把wifi的账号、密码通过广播的方式发送出去；然后需要ESP8266进入混杂模式，扫描当前环境下有哪些AP；第三步，进入该AP的channel接收UDP数据包，如果有，进行解析，如果没有，进入下一个channel。
再说airkiss，这个用的也比较多。因为是它是腾讯家提出的概念，懒得写了，直接放个官网截图：
具体就不说了，感兴趣的可以自行搜索一下。
这一节的内容已smart-config为主，会了一个，另一个就so easy了！
跟MQTT的调试一样，打开官方的SDK，因为官方已经帮我们写好了，我们只要会调用即可。在SDK的examples文件夹下面，文件夹名字为smart_config，如下图所示：
打开该文件夹下的user目录下的user_main.c文件，可以看到相关源码：
不光有smartconfig，还有airkiss：
所以，做个简单的演示程序，以之前GPIO控制LED的工程为模版，添加smartconfig的代码，使其在配网成功后，控制LED闪烁。
由于整体功能比较简单，这里只看一下主函数内的代码：
void ICACHE_FLASH_ATTR user_init(void) { partition_item_t partition_item; uart_init(BIT_RATE_115200, BIT_RATE_115200); os_printf("SDK version:%s\n", system_get_sdk_version());//打印输出SDK版本 PIN_FUNC_SELECT(PERIPHS_IO_MUX_MTDI_U,FUNC_GPIO12); //设置相关引脚为GPIO模式 PIN_FUNC_SELECT(PERIPHS_IO_MUX_MTCK_U,FUNC_GPIO13); PIN_FUNC_SELECT(PERIPHS_IO_MUX_MTDO_U,FUNC_GPIO15); gpio_output_set(0, BIT15, BIT15, 0); //设置GPIO15为低电平 smartconfig_set_type(SC_TYPE_ESPTOUCH); //SC_TYPE_ESPTOUCH,SC_TYPE_AIRKISS,SC_TYPE_ESPTOUCH_AIRKISS wifi_set_opmode(STATION_MODE); smartconfig_start(smartconfig_done); } 前面是串口初始化，并打印SDK版本。然后是GPIO初始化，并设置初始状态（根据你们的LED电路来设置初始状态）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/33928d07018e0670b36bbc1e0e7e2e95/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3ca9fc2045b2091ebbbb5d50ea96a87/" rel="bookmark">
			ubuntu nginx安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一种方式 1、安装nginx
sudo apt-get install nginx
2、nginx路径
nginx的默认安装路径在/usr/local/nginx下
nginx的默认配置在/etc/nginx下
3、修改配置文件nginx.conf，注释掉红色部分
include /etc/nginx/conf.d/*.conf;
#include /etc/nginx/sites-enabled/*; //
4、在/etc/nginx/conf.d目录下创建我们自己的配置文件default.conf
server {
listen 80;
server_name localhost;
#charset koi8-r;
#access_log /var/log/nginx/host.access.log main;
location / {
root /usr/share/nginx/html;#nginx静态文件存放路径
index index.html index.htm;#默认访问index.html页面
}
#error_page 404 /404.html;
# redirect server error pages to the static page /50x.html
#
error_page 500 502 503 504 /50x.html;
location = /50x.html {
root /usr/share/nginx/html;
}
}
第二种方式 有时间在加.......
nginx简单的操作命令 sudo service nginx start #启动
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3ca9fc2045b2091ebbbb5d50ea96a87/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f30a59159eb44d35d324f806e79cd34b/" rel="bookmark">
			离散数学学习笔记——第七讲——特殊关系和函数（5.4 哈斯图和特殊元素）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 哈斯图的引入背景
2. 哈斯图（Hasse Diagram）的定义
3. 哈斯图示例
4. 最大元和最小元的定义
5. 极大元和极小元的定义
6. 上界和上确界的定义及示例
7. 下界和下确界的定义及示例
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f15337d0a2fe00fca4ee4e35ed33224/" rel="bookmark">
			关于this的解析（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.1 为什么要用this 如果对于有经验的 JavaScript 开发者来说 this 都是一种非常复杂的机制，那它到底有用在 哪里呢？真的值得我们付出这么大的代价学习吗？的确，在介绍怎么做之前我们需要先明 白为什么。
下面我们来解释一下为什么要使用 this：
function identify() { return this.name.toUpperCase(); } function speak() { var greeting = "Hello, I'm " + identify.call( this ); console.log( greeting ); } var me = { name: "Kyle" }; var you = { name: "Reader" }; identify.call( me ); // KYLE identify.call( you ); // READER speak.call( me ); // Hello, 我是 KYLE speak.call( you ); // Hello, 我是 READER 看不懂这段代码？不用担心！我们很快就会讲解。现在请暂时抛开这些问题，专注于为 什么。 这段代码可以在不同的上下文对象（me 和 you）中重复使用函数 identify() 和 speak()， 不用针对每个对象编写不同版本的函数。 如果不使用 this，那就需要给 identify() 和 speak() 显式传入一个上下文对象。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f15337d0a2fe00fca4ee4e35ed33224/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/407096b421da44e7dfc9ecaf82333ac1/" rel="bookmark">
			memcached在windows下加大默认最大内存的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如下图，修改注册表，增加 -m 500 ，就可以将默认的64M内存，修改为500M
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8dfdfdf6efbf44b084760a10056463bc/" rel="bookmark">
			Proxmox虚拟环境（PVE）简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Proxmox虚拟环境（简称PVE）是用于操作来宾操作系统的基于Debian Linux和KVM的虚拟化平台。Proxmox免费提供 -可以通过制造商（维也纳的Proxmox Server Solutions GmbH）购买商业支持。
Proxmox 至少需要3台物理服务器才能在群集中稳定运行。
Proxmox的主页：https ://www.proxmox.com/de/
Proxmox的优点：
与Hyper-V，VMWare，OpenStack或Cloudstack相比，Proxmox具有一些优势：
Proxmox 几乎可以在所有x86硬件上运行每台主机不到5分钟即可完成安装Proxmox可以从3台服务器映射高可用性。有没有许可证费用为Proxmox 开源的基础是和KVM管理程序 与VSphere，OpenStack或Cloudstack等著名的云平台相比，Proxmox仍具有管理GUI在虚拟化主机上运行的优势。因此，不需要其他主机即可管理或管理集群
Proxmox的局限性：
Proxmox使用corosync来管理集群。Corosync最多可以管理或控制32个节点。也就是说，Proxmox群集的虚拟化和存储主机的最大数量为32台物理服务器。
Proxmox的安装
在使用Proxmox之前，应从https://www.proxmox.com/zh-CN/downloads/category/iso-images-pve下载最新的ISO映像或ISO安装程序。
建议在DVD或USB记忆棒（至少1 GB）上使用该图像。例如，软件Etcher适用于在棍子上演奏。（下载：https : //etcher.io/）
要求/最低要求
为了稳定运行Proxmox，应满足以下要求
3台主机或物理服务器中央存储（如果要实时移动虚拟机）-例如Ceph或NFS在提供虚拟化的主机上，必须在CPU中启用VT扩展以进行虚拟化。 重要信息：如果要在以后的运行中实时移动虚拟机，则主机上的网络接口（NIC）名称必须相同。
内部LAN端口的标准接口称为“ vmbr0”。外部接口应命名为“ vmbr1”。
如果虚拟机的磁盘映像集中存储（例如通过Ceph），则应使用10G交换机。当然，连接到10G网络的Proxmox主机将至少需要一个10G网络连接。
准备：
Proxmox主机的主机名和IP地址以后很难更改。在开始安装之前，应指定主机名和要安装的主机的（内部）IP地址：
主机名
IP地址
子网掩码
密码
pvehost01
10.20.30.1
/ 24
Pvehost02
10.20.30.2
/ 24
Pvehost03
10.20.30.3
/ 24
Proxmox的欢迎屏幕
安装第一台服务器
从DVD或USB闪存盘引导第一台服务器。如果已正确检测到ISO映像，Proxmox将以以下屏幕欢迎您：
单击“安装Proxmox VE”。在下一个屏幕中，您要做的就是确认Proxmox的许可条款。然后单击右下角的“下一步”。
选择启动分区
在下一页的“目标硬盘”下，选择您的引导分区，将立即在其中安装Proxmox。对于物理硬件上的标准安装，通常将第一个磁盘称为/ dev / sda。
注意：硬盘在安装前已分区，即删除分区上的所有数据。
国家和键盘选择
随后，选择服务器的国家和键盘布局，然后再次单击“下一步”。
在下一个屏幕中，将根帐户的密码设置为（1），然后在（2）下输入一个电子邮件地址。
密码和电子邮件地址
注意：该电子邮件必须有效。伪造的电子邮件不起作用。
进一步的规格
在最后一个屏幕中，设置（1）内部网络接口。
注意：由于服务器通常具有多个NIC，因此请提前检查哪个NIC属于哪个端口。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8dfdfdf6efbf44b084760a10056463bc/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/455/">«</a>
	<span class="pagination__item pagination__item--current">456/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/457/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>