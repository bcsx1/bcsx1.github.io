<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52c6960d6d808cb8cc7987fbd3517a96/" rel="bookmark">
			开发命名规范
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在软件开发中，命名规范是一项重要的实践，可以提高代码的可读性、可维护性和可扩展性。下面是一些常见的命名规范和最佳实践：
变量和函数命名：
使用有意义的名称：变量和函数的名称应该能够清晰地描述其用途和功能。避免使用缩写和简写：除非是广为接受的缩写或简写，否则应尽量避免使用，以保持代码的易读性。使用驼峰命名法：对于多个单词组成的名称，可以使用驼峰命名法，即每个单词首字母大写，没有下划线或空格。使用一致的命名风格：保持命名风格的一致性，选择一种命名风格并在整个代码库中坚持使用，如驼峰命名法或下划线命名法。 Variable and function naming:
Use meaningful names: The names of variables and functions should clearly describe their purpose and function.
Avoid abbreviations and abbreviations: Unless they are widely accepted abbreviations or abbreviations, they should be avoided to keep the code legible.
Use the hump nomenclature: For names that consist of multiple words, use the hump nomenclature, in which the first letter of each word is capitalized without underscores or Spaces.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/52c6960d6d808cb8cc7987fbd3517a96/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/939bee571aad0da40857ca22d53b5c9a/" rel="bookmark">
			OpenLayers 学习笔记（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 这两学习到了地图开发，去搜了一下免费开源平台有好多，其中以百度，高德，OpenLayers这三个使用最多，这次主要是以OpenLayers进行学习记录本文基本都是自己在du来的在线记录
OpenLayers简介 OpenLayers（openlayers.org/）是一个用来帮助开发Web地图应用的高性能的、功能丰富的JavaScript类库，可以满足几乎所有的地图开发需求。
有如下特点：
支持任何XYZ瓦片资源，同时也支持OGC的WMTS规范的瓦片服务以及ArcGIS规范的瓦片服务支持矢量切片，包括pbf、GeoJSON、TopoJSON格式支持矢量图层，能渲染GeoJSON、TopoJSON、KML、GML和其他格式的矢量数据支持OGC制定的WMS、WFS等GIS网络服务规范支持在移动设备上运行可以通过css来为地图控件设置样式面向对象开发方式，在OpenLayers中万物皆对象 OpenLayers虽然很强大，但是因为一切皆对象，所以使用起来很麻烦，再加上无比难看的文档，所以对新手极其不友好，这也是本系列文章的初衷，旨在基于实际业务开发的场景下来沉淀一些内容，来帮助新手使用OpenLayers。
因为我是使用的是vue，所以以vue为方向
基本概念 map： Openlayers 的使用的基础，所有的图层、地图控件、地图工具等必须添加到 Map 中才能使用。（别的不用想，这个是初始化地图时必不可少的一个，基本上所有东西都要在map里面，使用的时候是 new map ，和vue 的new vue 实例的意思差不多，他的意思就是地图）
view：view 用来设置地图的展示位置范围、地图中心位置以及当前地图使用的投影坐标系（有很多坐标系，如地理坐标系：4326）等，也可以设置地图旋转等（顾名思义，这个东西就是视图，你的地图显示的一些设置都在这个里面比如：范围，中心点，等等）
layer-&gt;source：这是整个 Openlayers 的灵魂，source 分为矢量数据源和影像数据源。有时候底图使用影像数据，而与我们业务相关的河流、行政区、水环境监测点等都是矢量数据(XYZ:这个东西有免费的和收费的具体可以自己百度使用其他的在线瓦片服务，比如：百度、高德、天地图、必应、谷歌等，具体服务地址可以自行百度，本文使用的是高德的服务，详情可参考：www.jianshu.com/p/e34f85029…。（找到一个瓦片库库整就行了）
new TileLayer({ //加载影响数据 source: new XYZ({ url: 'https://webrd01.is.autonavi.com/appmaptile?lang=zh_cn&amp;size=1&amp;scale=1&amp;style=8&amp;x={x}&amp;y={y}&amp;z={z}' }) }) target：这个是初始化地图的时候不可缺少的 ，对没错，他就是一个把地图绑定到dom的东西，和vue中的 el：app 用法类似
安装 npm i ol 初始化地图 （初始化地图要导入对应的包哦）
import { Map, View } from "ol";//地图,视图 import OSM from "ol/source/OSM"; //可以理解为数据源,就是一张图片 import TileLayer from "ol/layer/Tile"; //可以理解为图层 import { fromLonLat } from "ol/proj";//将坐标从经度/纬度转换为不同的投影。 import {XYZ} from "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/939bee571aad0da40857ca22d53b5c9a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/557296da9743d4471874b942a88be9fa/" rel="bookmark">
			【机器学习】：脑电数据时域特征提取
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一、个体水平的叠加平均 二、组水平的叠加平均
三、附上代码
前言 时域领域的特征提取主要思想：
某个一小段时间段里面的幅值，可能可以明显区别不同的类别，那么我们的目的就要找出这一小个时间段。然后取出这个小的时间段的波幅（求平均），来作为这个数据的特征之一。
数据说明：
被试01，C类别的数据（01_lxx_task_combine_maker_selectC._2s）：
每个被试每个类别的数据的维度是 chan*t*epoch，其中chan是通道数，t是时间点，epoch是分段数。
特征提取的步骤
一、个体水平的叠加平均 沿着数据的分段叠加平均， 由chan*t*epoch得到chan*t
二、组水平的叠加平均 1、读出所有被试，C类别的数据（我自己复制的，假装有3个被试，分别是01、02、03）
被试01 chan*t*epoch
被试02 chan*t*epoch
被试03 chan*t*epoch
2、先对每一个被试的类别C的数据，分别进行个体间叠加平均，得到
被试01 chan*t
被试02 chan*t
被试03 chan*t
3、把第2步中所有被试的数据收集起来，得到 sub*chan*t 维度的数据。
ps：这一步得到的是所有被试，类别C，进行个体间叠加平均后的数据。
4、对上一步得到的数据，沿着sub维度进行组水平叠加平均，sub*chan*t ---&gt; chan*t
对类别N、类别N、类别R、的数据也进行组水平的叠加平均（上述1-4的步骤）
这样我们就得到
类别C的组水平叠加平均后数据 chan*t
类别N的组水平叠加平均后数据 chan*t
类别R的组水平叠加平均后数据 chan*t
类别S的组水平叠加平均后数据 chan*t
绘制这四个数据的波形图
（因为只是在测试，我只先搞了两个类别的数据，类别C和类别N的，类别C是蓝线，类别N是红线）
为啥10个波形图呢？因为10个位置对应10个通道
对类别C和类别N的数据进行T检验
这一步是为了找出不同类别之间，有显著区别的时间区间。
以便于后边提取这个时间段内的幅值，作为一个可以显著区别不同类别的特征
ps：这边是不是要对四个类别进行两两T检验，以找出四个类别间有显著区别的区间，我还不知道。
假设我在上面的图中找到的，类别间有显著区别的时间区间有两个，
分别是t1: 0.25s-0.5s，以及t2:1.25s-1.75s
我就把所有类别的数据，在进行组水平的叠加平均的第3步后得到的数据，t1、t2时间区间的数据取出来。
得到
sub*chan*t1、sub*chan*t2（类别C）
sub*chan*t1、sub*chan*t2（类别N）
sub*chan*t1、sub*chan*t2（类别R）
sub*chan*t1、sub*chan*t2（类别S）
对它们在时间上进行平均，得到
sub*chan、sub*chan（类别C）
sub*chan、sub*chan（类别N）
sub*chan、sub*chan（类别R）
sub*chan、sub*chan（类别S）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/557296da9743d4471874b942a88be9fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c37e3844fe4ac47dd93c403eea57ab47/" rel="bookmark">
			python入门：带你了解Python 的十大特性！！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当你犹豫是否要开始 Python 学习之前，可以先详尽了解一下这门编程语言。
软件开发者 Guido Van Rossum 于 1991 年创建了 Python，旨在使程序员的工作更加简单。Python 是目前全球比较流行且产业急需的程序设计语言，也是一门跨平台、开源、免费的解释型高级编程语言。
并且Python 拥有大量的扩展库，同时可以把多种不同编程语言编写的程序融合到一起，更好地发挥不同编程语言和工具的优势，满足不同应用领域的需求。
Python 编程语言的应用领域广泛，比如数据处理、web开发、科学计算、网络爬虫、人工智能等领域。
（ 与其他编程语言相比，Python 的流行程度遥遥领先 ）
同时，它也是公认的，对于新手来说最友好的编程语言，没有之一。
那么，Python 究竟有哪些无可比拟的优势与特性呢？
1
**上 手 简 单
**
假如你是一个新手（初学者），并对 Python 略有耳闻，我相信你已经了解到 Python 编程非常容易学习和掌握。在将 Python 与 C、C#、Javascript 和 Java 等其他编程语言相比较时，Python 是一种非常直接的语言，它允许你轻松地开始编程。
Python 编程语言的基础知识可以在数小时或数天内学会，当然，精通 Python 同样具有挑战性。只要努力了就能学到或掌握 Python 的概念，但是要成为 Python 开发者需要大量的实践和耐心。的确，Python 编程很简单，但是要成为一名精通 Python 的程序员，也需要时间去适应。
2
**开 源
**
**Python 编程语言的特点之一就是开源，也就是说每个人都可以构建和修改它。**Python 编程有很多由程序员和爱好者组成的在线社区，他们每天都聚集在一起讨论该语言的发展。你可以从一个开源的、免费的地方下载它，你所需要知道的就是来源。
✅ Python 编程语言在官方网站上是免费提供的，你通过点击下载 Python 链接即可下载。之后，你需要做的就是在你的计算机上安装 Python。
✅ 为了运行 Python 编程语言，你需要 IDE（集成开发环境）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c37e3844fe4ac47dd93c403eea57ab47/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e74828557b21b6444d1799b9b505df5/" rel="bookmark">
			卸载流氓软件奇安信天擎(无需密码，无需关闭自我保护)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		流氓软件奇安信天擎是真流氓,下面介绍如何卸载奇安信天擎 首先打开 按shift 点击重启键
进入安全模式：选择疑难解答-&gt;高级选项-&gt;启动设置-&gt;重启-&gt;4-&gt;安全模式。进入安全模式打开配置文件：文件路径：D:\Program\360Safe\EntClient\conf\EntBase.dat 用记事本打开修改配置文件：修改uienable=0,qtenable=0,uipass= ,qtpass= ，保存(只有安全模式下才能保存)
打开控制面板-&gt;程序-&gt;卸载程序-&gt;找奇安信天擎卸载即可重启，奇安信天擎终于消失了！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f2368ce34a4ebd5c0cbac396e1ae98c/" rel="bookmark">
			CSS中权重的关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 CSS 中，选择器的权重决定了多个规则应用于同一元素时的优先级。以下是 CSS 权重顺序从高到低的规则：
1.!important：具有 !important 标记的属性具有最高的优先级。使用 !important 可以覆盖任何其他规则。
2.内联样式（Inline styles）：在 HTML 元素内部使用 style 属性定义的样式具有较高的优先级。
3.ID 选择器（ID selectors）：使用 # 符号定义的 ID 选择器具有比类选择器和标签选择器更高的优先级。
4.类选择器、属性选择器和伪类选择器（Class selectors, Attribute selectors, Pseudo-class selectors）：类选择器（以 . 开头）、属性选择器（以 [attribute] 开头）和伪类选择器（以 : 开头）具有相同的优先级。
5.标签选择器和伪元素选择器（Type selectors, Pseudo-element selectors）：标签选择器（如 div、p）和伪元素选择器（以 :: 或 : 开头）具有较低的优先级。
6.继承（Inheritance）：如果没有为元素指定具体的样式规则，元素将继承其父元素的样式。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc13338c5db9a88da6b4df8a8453489e/" rel="bookmark">
			2022小米秋招前端——通常情况下，一个URL的格式是
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通常情况下，一个URL的格式是
A
协议//路径名称主机:端口/#哈希标识?搜索条件
B
协议//主机:端口/#哈希标识/路径名称?搜索条件
C
协议//主机:端口/路径名称?搜索条件
D
协议//主机:端口?搜索条件/路径名称#哈希标识
答案是B
一个标准的URL（Uniform Resource Locator）通常由以下几个组成部分构成：
协议（Scheme）：URL 的方案是指用于访问资源的协议或协议的命名部分。它指示了如何获取或处理资源。常见的方案有 http://、https://、ftp:// 等。
认证信息（Authentication）：认证信息是可选的，用于在访问资源时提供身份验证凭据。通常以用户名和密码的形式出现，格式为 username:password@。
主机（Host）：主机指示要访问的服务器的名称或 IP 地址。它可以是域名（例如 example.com）或 IP 地址（例如 192.168.0.1）。
端口（Port）：端口是指用于建立与服务器的连接的网络端口号。它是可选的，默认为协议的默认端口。例如，HTTP 默认端口为 80，HTTPS 默认端口为 443。
路径（Path）：路径指示服务器上资源的具体位置或路径。它可以是目录路径或文件路径，用斜杠 / 分隔。
查询参数（Query Parameters）：查询参数用于传递附加的数据或参数给服务器。它们是以键值对的形式出现，并使用问号 ? 作为起始符号，键值对之间使用 &amp; 分隔。例如：?key1=value1&amp;key2=value2。
片段标识（Fragment Identifier）：片段标识用于指示资源中的特定部分或位置，例如文档中的某个章节或页面内的锚点。片段标识以井号 # 开始，后面跟着具体标识符。
以下是一个示例 URL，展示了以上组成部分的典型结构：
http://www.example.com:8080/path/to/resource?param1=value1&amp;param2=value2#fragment
这个 URL 的协议是 http://，主机是 www.example.com，端口是 8080，路径是 /path/to/resource，查询参数是 param1=value1&amp;param2=value2，片段标识是 #fragment。
需要注意的是，URL 的具体组成部分和形式可能因使用的方案或应用程序的要求而有所不同。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0699db4eb7301593f3dcd0714728fc56/" rel="bookmark">
			2022小米秋招-前端——[]的valueOf和toString的结果是什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[]的valueOf和toString的结果是什么？
A [] 的 valueOf 结果为 [] ，toString 的结果为 “”
B [] 的 valueOf 结果为 [] ，toString 的结果为 “[]”
C [] 的 valueOf 结果为 0 ，toString 的结果为 “[]”
D [] 的 valueOf 结果为 “” ，toString 的结果为 “”
答案是A
在 JavaScript 中，valueOf() 和 toString() 是对象的两个方法，用于获取对象的原始值的字符串表示。
valueOf(): valueOf() 方法返回对象的原始值。如果对象具有原始值，它会被直接返回。如果对象没有原始值，则返回对象本身。valueOf() 方法通常由 JavaScript 引擎在需要将对象转换为原始值时自动调用。
toString(): toString() 方法将对象转换为字符串，并返回该字符串。该方法通常用于将对象以可读的字符串形式表示出来。
在大多数情况下，当需要将对象转换为字符串时，JavaScript 会自动调用对象的 toString() 方法。例如，当我们在使用 alert()、console.log()、字符串拼接或使用某些内置函数时，JavaScript 会自动将对象转换为字符串。如果对象没有定义自己的 toString() 方法，那么会使用默认的实现。
在某些情况下，JavaScript 会首先尝试调用对象的 valueOf() 方法获取原始值，如果获取到了原始值，则不再调用 toString() 方法。这通常发生在需要对对象进行数值运算或逻辑比较时。
总结来说，valueOf() 方法用于获取对象的原始值，而 toString() 方法用于将对象转换为字符串。它们的具体行为取决于对象本身的实现以及上下文的要求。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c0f6b7aaae129e1f859c2a1729032eb/" rel="bookmark">
			Python编程快速入门！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python是当前最流行的编程语言之一，可应用于Web开发、数据分析、人工智能、科学计算、桌面应用、游戏开发等等多个领域。Python的一大特色就是它具有丰富的程序库（包括内置的库及第三方开发的库），我们不必从头开始编写代码，就可以实现功能强大的应用程序。Python不但功能强大，而且和其他编程语言相比它相对简单，不需要任何先前的编程经验即可学习、使用，对初学者极为友好。下面就让我们一起走进丰富多彩的Python编程世界。【文末有惊喜】
Python编程环境设置
Python是一种解释性语言，它使用解释器来解释和执行代码，这对用户来说省去了C或C++之类语言的编译步骤，直接从源代码即可运行，因此更容易编写和调试。工欲善其事，必先利其器。在学习Python编程之前，先让我们安装好相应的工具并对编程环境进行设置。
首先进入Python官方下载频道https://www.python.org/downloads，点击“Download Python 3.11.2”按钮进入下载页面（此数字会随着版本的升级而改变）。找到适合自己系统的下载链接，比如笔者为Windows的64位系统，所以选择下载了“Windows installer (64-bit)”。双击下载所得的EXE可执行文件启动Python安装向导（图1）。
图1 Python安装向导
勾选“Add python.exe to PATH”项，这样就不用后期手动将Python程序添加到系统路径中了。点击“Install Now”即可自动安装。如果不希望安装到默认的C盘，可以点击“Customize installation”自定义安装项，根据向导提示一步步安装（图2）。
图2 Python自定义安装
作为初学者选择默认安装选项即可。安装成功后，对于Windows系统将会有一个“Disable path length limit（禁用路径长度限制）”的提示，这是因为Windows系统能够处理的文件路径长度有一定的限制（图3）。点击禁用这一限制可以避免处理长文件路径时出现的调试问题，不过这也可能导致与旧版本Windows 10的兼容性问题。对于我们初学者来说可以暂时跳过此选项，因为以后有需要时还可以修改注册表来解决。
图3 Python安装成功的界面
点击“Close”按钮关闭安装向导。现在我们测试Python是否安装成功。按Win+R键调出运行对话框，输入“cmd”后按回车键打开命令提示符窗口，然后输入“python”并按回车，如果能够显示出Python版本等信息内容，并且提示符变成了“&gt;&gt;&gt;”，则表示安装成功了。此时可输入一行测试代码：
print(“嗨，欢迎来到Python世界！”)
按回车键执行，即可得到“嗨，欢迎来到Python世界！”的显示信息。几乎每种编程语言教程中都会展示一下“hello, world!”程序，虽然很俗套，但不得不说Python的实现是如此的简单。紧接着执行代码“exit()”退出Python环境，完成此一阶段的测试（图4）。
图4 Python的“hello, world!”程序示例
命令提示符的界面过于简陋，我们可以试试Python自带的IDLE交互式开发环境。点击系统“开始”按钮，在开始菜单顶部的最近添加中就可以看到“IDLE(Pyton 3.11 64-bit)”程序了，点击即可打开。
IDLE通过不同的颜色区分代码及执行结果，清晰明了。尤其方便的是，当我们输入某个函数时，它会智能显示参数提示，辅助我们输入代码，非常方便（图5）。
图5 Python的IDLE交互式开发环境
除了一行一行的交互式执行，IDLE还可以执行扩展名为“py”的Python程序文件，下面就来做个测试。首先点击菜单命令“File→New File”打开IDLE的代码编辑器，输入以下代码：
# Python 3: 显示n个数以内的斐波纳契（Fibonacci）序列
def fib(n):
a, b = 0, 1
while a &lt; n:
print(a, end=’ ')
a, b = b, a+b
print()
fib(1000)
代码解释：“#”后面的文字表示注释，是程序员对代码的说明，这是给阅读代码的人看的，Python解释器会自动忽略这一行。接下来的“def fib(n):”定义了一个名为“fib”的函数，其后缩进的几行代码就是该函数的内容，其主体是一个“while”循环，通过斐波纳契数列公式反复运算，运算结果通过“print()”函数显示出来，其参数“end=’ '”表示每个数字后面加几个空格，是为了将数字隔开（用来显示的print函数在后面的示例中将频繁出现）。当然，函数定义只是表明此函数能做什么，真正运行还得对它进行调用，这就是最后一行代码“fib(1000)”的作用，在调用该函数时，传递了一个参数“1000”，表示要计算1000以内的斐波纳契数列（图6）。
图6 斐波纳契数列计算
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c0f6b7aaae129e1f859c2a1729032eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/720ca4e745b566231ae1dcaecaa085d3/" rel="bookmark">
			git撤销commit
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写完代码后，我们一般这样
git add . //添加所有文件
git commit -m "本功能全部完成"
执行完commit后，想撤回commit，怎么办？
这样解决：
进入对应代码文件夹根目录
打开 git Bash Here命令行输入如下代码
git reset --soft HEAD^
这样就成功的撤销了你的commit
注意，仅仅是撤回commit操作，您写的代码仍然保留。
说一下个人理解： HEAD^的意思是上一个版本，也可以写成HEAD~1
如果你进行了2次commit，想都撤回，可以使用HEAD~2
顺便说一下，如果commit注释写错了，只是想改一下注释，只需要： git commit --amend
此时会进入默认vim编辑器，修改注释完毕后保存就好了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c348bb49e01b688466b8712cfb3ed31d/" rel="bookmark">
			前端性能测试Lighthouse的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Lighthouse是一个开源项目，提高网页的质量，生成的测试报告会提供优化方案，以来提高网页的性能。重点就是关注优化建议
官方介绍Lighthouse的地址：https://developer.chrome.com/docs/lighthouse/
一、使用方法 1、使用谷歌开发者工具进行测试 打开开发者工具，点击Lighthouse，输入网址进行测试。
设置：
Clear Storage：是否清除缓存，想要模拟用户第一次进入页面就勾选，清除缓存；想要模拟用户非第一次进入页面就不勾选Simulated throttling：模拟限制，勾选之后Lighthouse在测试过程中限制网速与CPU
网络限速：Latency（延迟）: 150ms；Throughput（上行下行网速）: 1.6Mbps down / 750 Kbps up；Packet loss: none
CPU限制：4x CPU
谷歌开发者工具也可设置网络限速
模式：
navigation：默认的，测试的是当前页面，分类都可选Timespan：用这个模式可以测试一堆操作的性能，不只是一个页面，测试类型只有Performance、Best Practicessnapshot：生成页面快照的一种测试模式，测试类型有Performance、Accessibility、Best Practices、SEO 分类：
Performance：性能得分，根据测量的结果打分，根据占比计算得到的Accessibility：访问无障碍，目的是用来评估构建一个适用于所有用户的网站Best Practices ：最佳实践，提高代码安全SEO：确保网页遵循了基本的搜索引擎优化建议PWA：渐进式 Web 应用程序 2、用命令行测试 Lighthouse的Git地址：https://github.com/GoogleChrome/lighthouse （有使用的详细介绍）
安装：npm install -g lighthouse
测试：lighthouse lighthouse https://www.baidu.com/ --output html --output-path ./report1.html --only-categories=performance --preset=desktop --quiet --chrome-flags=“–headless”
–quiet 加上后不打日志
–output html --output-path ./report1.html 指定输出文件的格式并指定文件保存路径
–only-categories 可指定测试测种类：accessibility, best-practices, performance, pwa, seo
–preset=desktop 指定是电脑端还是手机端（web、H5），不指定就是手机端，指定desktop就是电脑端
–chrome-flags=“–headless” 执行的时候不打开谷歌浏览器
可指定只运行整个测评过程的一个或多个特定生命周期，-G只进行资源采集的生命周期，采集被测试站点的相关数据，并将结果以 json 的形式存储到本地，默认是 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c348bb49e01b688466b8712cfb3ed31d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8544df4fb334ae9d1c776ffede45c8da/" rel="bookmark">
			ChatGPT 教程--生成代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ChatGPT 变生产力工具 chatGPT是一种基于人工智能技术的自然语言处理模型，它使用了深度学习算法，可以对人类语言进行理解和生成。chatGPT可以用于对话系统、智能客服、问答系统等场景，能够实现自然、流畅的对话。
chatGPT的核心技术是基于GPT（Generative Pre-trained Transformer）模型，它是一种预训练语言模型，可以通过大规模的语料库进行训练，从而学习到语言的规律和特征。在实际应用中，chatGPT可以通过微调等方式进行定制化，以适应不同的应用场景和用户需求。
chatGPT的优点包括：
自然流畅：chatGPT可以生成自然、流畅的语言，使得对话更加真实。智能化：chatGPT可以理解用户的意图和语境，从而提供更加智能化的回答。定制化：chatGPT可以通过微调等方式进行定制化，以适应不同的应用场景和用户需求。高效性：chatGPT可以实现快速的响应和处理，提高用户体验。 提示：chatGPT生成代码秒便生产力工具，Ctrl+'C' / Ctrl+'V'变得更容易。chatGPT 链接 [www.laicj.cn](https://laicj.cn)。
文章目录 ChatGPT 变生产力工具1. 变生产力过程1.1 编写需求1.2 生成代码1.3 验证代码 Tips总结 1. 变生产力过程 利用chatGPT对自然语言解析和庞大的知识库，实际使用中需求代码。
Created with Raphaël 2.2.0 chatGPT 描述需求 验证结果？ 生产力(代码) yes no 本篇文章使用网络搜索到chatGPT工具生成代码。
1.1 编写需求 运行环境：树莓派4B,Ubuntu20.04
数组包含4个连续GPIO，使用sysfs接口按照数组申请
主菜单包含申请GPIO选项和退出选项，选择gpio选项后进入子菜单；子菜单中包含控制GPIO高电平、低电平和退出选项，选择高电平选项控制GPIO高电平，选择低电平选项控制GPIO低电平，选择退出回到主菜单；主菜单可选择其他选项
1.2 生成代码 本文执行环境为 Ubuntu20.04，选择 bash 脚本详细描述功能需求生成代码 genrator
以下是实现该功能的 Bash 代码：
#!/bin/bash # 定义GPIO数组 gpio_array=(17 18 19 20) # 申请GPIO function request_gpio() { for gpio in ${gpio_array[@]}; do echo $gpio &gt; /sys/class/gpio/export done echo "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8544df4fb334ae9d1c776ffede45c8da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7af0b1f32cacfd1190202340d0565769/" rel="bookmark">
			Python-PyEcharts绘制柱状图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		更多优秀文章，请关注个人微信公众号： 程序猿小杨 Python-PyEcharts绘制柱状图
一、简介
核心创建流程：
1.通过Bar()构建一个柱状图对象
2.和折线图一样，通过add xaxis()和add_yaxis()添加x和y轴数据
3.通过柱状图对象的：reversal_axis(),反转x和y轴
4.通过label_opts=LabelOpts(position="right'")设置数值标签在右侧显示。
二、绘制基本柱状图
参考代码：
###绘制柱状图barfrom pyecharts.charts import Barfrom pyecharts.options import TitleOpts, LegendOpts, ToolboxOpts, VisualMapOpts, AxisOpts, LabelOpts #绘图 class Bar()bar=Bar()#调用add_yaxis函数## series_name 系列名称，用于 tooltip 的显示，legend 的图例筛选。#添加x轴数据# bar.add_xaxis(['中国','美国','俄罗斯','日本'])bar.add_xaxis(['中国','美国','俄罗斯','日本'])# # #添加y轴数据 系列数据 y_axisbar.add_yaxis(series_name="GDP",y_axis=[100,90,70,9],label_opts=LabelOpts(position="right"))# reversal_axis 翻转 XY 轴数据 直角坐标系图表继承自 RectChart 都拥有以下方法bar.reversal_axis()## 柱状图bar全局配置bar.set_global_opts(# # 标题配置 title:主标题文本，支持使用 \n 换行 title pos_left:组件离容器左侧的距离 pos_bottom:title 组件离容器下侧的距离 title_opts=TitleOpts(title="各国GDP数据展示", pos_left="center", pos_bottom="1%"))#绘图bar.render("各国GDP数据基础柱状图.html") 效果图：
反转x/y轴：注意全局配置会影响到
三、创建时间线TimeLine
柱状图描述的是分类数据，回答的是每一个分类中「有多少？」这个问题。这是柱状图的主要特点，同时柱状图很难动态地描述一个趋势性的数据。这里pyecharts为我们提供了一种解决方案-时间线TimeLine。
参考文档：
设置初始化参数参考(init_opts)：
timeline=Timeline(init_opts=InitOpts(theme=ThemeType.WHITE)) 图表主题设置参考：
theme=ThemeType.WHITE 参考代码：
###绘制柱状图barfrom pyecharts.charts import Bar, Timelinefrom pyecharts.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7af0b1f32cacfd1190202340d0565769/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d886656f73eb032d0bfa69ecd21613f/" rel="bookmark">
			云盾身份认证二要素接口提示参数非法（curl用get方法传中文参数乱码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		接口文档给的示例代码如下图：
&lt;?php $host = "http://id2meta.market.alicloudapi.com"; $path = "/id2meta"; $method = "GET"; $appcode = "你自己的AppCode"; $headers = array(); array_push($headers, "Authorization:APPCODE " . $appcode); $querys = "identifyNum=identifyNum&amp;identifyNumMd5=identifyNumMd5&amp;userName=userName&amp;userNameMd5=userNameMd5"; $bodys = ""; $url = $host . $path . "?" . $querys; $curl = curl_init(); curl_setopt($curl, CURLOPT_CUSTOMREQUEST, $method); curl_setopt($curl, CURLOPT_URL, $url); curl_setopt($curl, CURLOPT_HTTPHEADER, $headers); curl_setopt($curl, CURLOPT_FAILONERROR, false); curl_setopt($curl, CURLOPT_RETURNTRANSFER, true); curl_setopt($curl, CURLOPT_HEADER, true); if (1 == strpos("$".$host, "https://")) { curl_setopt($curl, CURLOPT_SSL_VERIFYPEER, false); curl_setopt($curl, CURLOPT_SSL_VERIFYHOST, false); } var_dump(curl_exec($curl)); ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d886656f73eb032d0bfa69ecd21613f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68551613df29177bf6cca924c8f8fa36/" rel="bookmark">
			ios代码打包笔记&#43;苹果app最佳实践（uniapp）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在ios上运行app，有三种办法：
一是企业签名，免审核发布，不能上架应用商店，可通过链接直接下载安装。
二是发布到AppStore，审核最严，个人开发者证书和公司证书都可以申请。
三是通过TestFlight发布，审核相对宽松，可通过链接下载。
四是WebClip免签封装，只要一台mac电脑，用自带的iphone配置实用工具给网站生成一个桌面快捷方式，就可以实现和app一样的使用效果（没有浏览器地址栏）。
下面是TestFlight的打包流程，我最后放弃了这个方式，因为审核没通过——用户付款必须通过苹果应用商店，然后给苹果30%分成。
下面是获取上图中证书私钥密码、证书profile文件和私钥证书的流程： 一、申请开发者账号，登录 iOS Dev Center（苹果开发者中心 https://developer.apple.com/)
可以参考这篇文章开通苹果开发者账号：https://www.yunedit.com/xueyuan/jx/applereg
二、有了苹果开发者账号后，就可以登陆苹果开发者中心，进入Certificates菜单，开始生成证书，申请苹果 App ID （App的唯一标识）
三、创建过程中，选择ios distribution ad hoc and app store，类型，无论是真机测试还是上架，都是选择这个类型，千万别选了apple类型或dev类型。创建的过程中，它会要求上传一个csr文件。
1、mac电脑直接生成
2、登录服务器，安装OpenSSL工具执行以下命令，生成CSR文件。
openssl req -new -nodes -sha256 -newkey rsa:2048 -keyout [$Key_File] -out [$OpenSSL_CSR] 四、生成p12私钥证书
1、在 Mac OS 上将 iPhone 开发人员证书转换为 P12 文件
从 Apple 下载 Apple iPhone 证书后，将其导出为 P12 证书格式。在 Mac? OS 上执行以下操作：
打开钥匙串访问应用程序（位于应用程序/实用工具文件夹中）。
如果尚未将该证书添加到钥匙串，请选择“文件”&gt;“导入”。然后浏览到您从 Apple 获取的证书文件（.cer 文件）。
在钥匙串访问中选择密钥类别。
选择与 iPhone 开发证书相关联的私钥。
该私钥由 iPhone 开发人员识别：与之配对的&lt;名字&gt;&lt;姓氏&gt;公共证书。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/68551613df29177bf6cca924c8f8fa36/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0d13653036b69761e3966dc4746f1d9/" rel="bookmark">
			图像检索绘制PR曲线的两种方法（按需求）或者说生成指标的两种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 根据不同哈希码的长度来判断最好的情况每个哈希码长度下所有样本的平均精度和召回率每个检索集样本在不同哈希码长度下的平均精度和召回率区别代码上的区别应用场景的区别两种代码对应的数据点的意义如果要绘制固定哈希码长度下检索集的表现，我们应该选用第二种代码。第一种代码的适合的使用场景 根据不同哈希码的长度来判断最好的情况 每个哈希码长度下所有样本的平均精度和召回率 def pr_curve(qB, rB, query_label, retrieval_label): "只接受二进制码组成的0和1 或者 -1和1组成的二进制码，请把所有标签进行onehot编码" qB[qB==-1] = 0 ; rB[rB==-1] = 0 # 根据你哈希码长度来改变数值将 num_query = qB.shape[0] num_bit = qB.shape[1] P = torch.zeros(num_query, num_bit+1) R = torch.zeros(num_query, num_bit+1) for i in range(num_query): gnd = (query_label[i].unsqueeze(0).mm(retrieval_label.t()) &gt; 0).float().squeeze() print('gnd size is ' + str(gnd.shape)) '''对于一个(num,4)与(4,num)大小的矩阵相乘最后得到是(num,num)大小的矩阵，他会展示标签之间是否相同''' # 这里的groudtruth标签大小是（retrieval_label,) tsum = torch.sum(gnd) # 一共有多少个相同的标签（事实上的，没有固定检索哈希码的长度） if tsum == 0: continue # 如果没有相似的也没必要继续进行了 hamm = calc_hamming_dist(qB[i, :], rB) # 汉明距离 print('hamming distance is '+str(hamm.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d0d13653036b69761e3966dc4746f1d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0cb64740172b25ab1e6d60f7e615b908/" rel="bookmark">
			linux常用命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系统信息 动态观察cpu、内存，进程情况：top 格式：top [选项]
选项：
-d number：每隔多少秒更新一次，默认5
-p：指定pid
交互：
P：按CPU使用率排序
M：按内存使用率排序
N：按PID排序
s： 改变刷新间隔（秒）
k：终止一个进程
r：重新设置进程优先级
c：显示命令名称和完整命令行
内容介绍：　第1行：top - 时间 up 运行天数 days，运行时间（时：分），用户数 users，load average(平均负载)：1秒 5秒 15秒
第2行：总进程 total，正在执行 running，休眠 sleeping，停止 stopped，僵尸 zombie
第3行：用户模式CPU占比 us，系统模式CPU占比 sy，改变过优先级的进程的CPU占比 ni，空闲CPU占比 id，因为I/O等待造成的CPU占比 wa，硬中断CPU占比 hi，软中断CPU占比 si，等待虚拟机调度的时间占比 st
第4行：物理内存总量 total，空闲 free，已使用 used，缓存内存 buff/cache（单位kb）
第5行：虚拟内存总量 total，空闲 free，已使用 used，虚拟内存 avail Mem（单位kb）
第6行：
pid：进程号；
user：归属用户；
PR：优先级（越小越高）；
NI：优先值的修正数值（负值表示高优先级，正值表示低优先级）；
VIRT：使用的虚拟内存；
RES：常驻内存；
SHR：使用的共享内存；
S：运行状态（S：休眠；D：不能中断睡眠；R：运行中；T：跟踪/停止；Z：僵尸；）；
%CPU：CPU占用比；
%MEM：内存占用比；
TIME+：占用CPU的总时长；
COMMAND：进程名；
查看内存状态：free 格式：free [选项]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0cb64740172b25ab1e6d60f7e615b908/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1fd36582e128c0a88755c6f1e232f577/" rel="bookmark">
			软件生命周期
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		软件生命周期是指软件开发过程中经历的不同阶段，从需求分析、设计、编码、测试、部署到维护和更新等一系列阶段的总称。软件生命周期的常见模型包括瀑布模型、迭代模型、敏捷模型等，每个模型都有自己独特的特点和适用场景。
The software lifecycle refers to the various phases of software development, from requirements analysis, design, coding, testing, deployment, maintenance, and updating. The common models of software life cycle include waterfall model, iterative model, agile model, etc. Each model has its own unique characteristics and applicable scenarios.
以下是软件生命周期的常见阶段：
需求分析：在这个阶段，确定软件系统的需求，包括功能需求、性能需求、用户界面需求等。需求分析阶段通常涉及与客户或用户的沟通，以确保准确理解和记录需求。
设计：在设计阶段，根据需求分析的结果，制定软件系统的整体架构、模块划分和数据结构等。设计阶段的目标是将需求转化为具体的软件设计方案。
编码：在编码阶段，开发人员根据设计文档开始实际编写代码。编码阶段通常涉及选择合适的编程语言和工具，编写、调试和测试代码。
测试：测试阶段旨在验证软件的正确性和完整性。测试包括单元测试、集成测试和系统测试等，以确保软件符合预期的功能和性能要求。
部署：在部署阶段，将软件安装到目标环境中，并进行必要的配置和集成。这包括安装、设置和配置软件，确保软件能够在目标环境中正常运行。
维护：软件部署后，进入维护阶段。维护包括对已发布软件的修复漏洞、处理问题报告、提供技术支持和进行软件更新等。
以上是典型的软件生命周期阶段，不同的模型和方法可能会有细微的差异。软件生命周期的目标是确保软件开发过程有序、高效，并最终交付出符合需求的高质量软件产品。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae8b0d063305445375bdac89cda4141b/" rel="bookmark">
			QT实现自适应缩放
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述：修改电脑的缩放比例或分辨率时，控件和字体大小显示异常。
1.新建一个文件qt.conf（命名必须是qt.conf）
2.文件内容
[Platforms]
WindowsArguments = dpiawareness=0
3.把qt.conf放到源码目录，即和资源文件（xxx.qrc）同一个目录
4.修改.pro文件中
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65041efd3a0f0729150448bb8761fe2b/" rel="bookmark">
			Spark集群安装部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一.环境准备
二.安装步骤
三.使用Standalone模式
四.使用Yarn模式 一.环境准备 由于Spark仅仅是一种计算机框架，不负责数据的存储和管理，因此，通常都会将Spark和Hadoop进行统一部署，由Hadoop中的HDFS，HBase等组件负责数据的存储管理，Spark负责数据计算。
安装Spark集群之前，需要安装Hadoop环境，我的配置环境如下：
Linux系统：CentOS_6.7 版本Hadoop：3.1.3 版本JDK：1.8 版本Spark：3.1.1 版本 二.安装步骤 Spark部署模式分为Local模式（单机模式）和集群模式，集群模式又分为Standalone模式，Yarn模式和Mesos模式。本文章主要阐述spark集群配置，Standalone模式和Yarn模式的使用
1.下载Spark安装包
下载地址：http://archive.apache.org/dist/spark/
选择自己需要的版本下载，由于我的hadoop版本是3.x，所以我下载的是第二个spark-3.1.1-bin-hadoop3.2.tgz
2.解压Spark安装包
将下载的安装包上传到主节点master的/opt/software目录，然后解压到/opt/servers目录，命令如下：
[root@master ~]# tar -zxvf /opt/software/spark-3.1.1-bin-hadoop3.2.tgz -C /opt/servers/
为了方便，将解压后的目录重命名为spark，命令如下：
[root@master ~]# mv /opt/servers/spark-3.1.1-bin-hadoop3.2/ /opt/servers/spark
3.修改配置文件
进入spark/conf目录修改Spark的配置文件，将spark-env.sh.template配置模板文件复制一份并命名为spark-env.sh，命令如下：
[root@master ~]# cd /opt/servers/spark/conf/
[root@master conf]# cp ./spark-env.sh.template ./spark-env.sh
修改spark-env.sh文件，命令如下：
[root@master conf]# vi ./spark-env.sh
#添加以下内容
export JAVA_HOME=/opt/servers/java
export SPARK_MASTER_HOST=master
export SPARK_MASTER_PORT=7077
export YARN_CONF_DIR=/opt/servers/hadoop/etc/hadoop
export HADOOP_CONF_DIR=/opt/servers/hadoop/etc/hadoop
复制workers.template文件，并重命名为workers，命令如下：
[root@master conf]# cp ./workers.template ./workers 指定Spark集群中的从节点IP
[root@master conf]# vi .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65041efd3a0f0729150448bb8761fe2b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f78e24cebaed41265d034b2a3c82ad9e/" rel="bookmark">
			Android Studio Flamingo版本logcat没有级别筛选下拉框
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android Studio 升级成Android Studio Flamingo之后，logcat没有日志级别筛选下拉框。
新版本的Logcat使用感觉很别扭，没有如下图所示的老版本日志筛选下拉框了。
解决方案：File-&gt;Settings-&gt;Experimental，取消“Enable new locat tool window”的勾选，重启Android Studio即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1fd8b4798108fb9ce2056b04e6ec48ff/" rel="bookmark">
			纯JS实现等待元素出现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 纯JS实现等待元素出现 通过for循环实现等待max60秒 async function waitForSelector(selector) { for (let index = 0; index &lt; 60; index++) { await new Promise((resolve,reject)=&gt;{ setTimeout(resolve,1000) }); // console.log(index) if (document.querySelector(selector)!==null) { return true; } } return false; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82e9cebd89c40009c56d1db320408147/" rel="bookmark">
			php array 指定字段排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 $list = [ ['name'=&gt;'小张','sort'=&gt;0], ['name'=&gt;'小李','sort'=&gt;2], ['name'=&gt;'小王','sort'=&gt;1], ]; //排序单字段 $sort = array_column($list,'sort');//指定字段 array_multisort($sort,SORT_DESC,$list); //排序多字段 $sort = array_column($list,'sort'); $last_sort = array_column($list,'name'); array_multisort($sort,SORT_DESC,$last_sort,SORT_DESC,$list); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27d7e4b336abc915b123b1a06d47f2a4/" rel="bookmark">
			vscode常用插件总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、Code Spell Checker
检查单词拼写
2、Auto Rename Tag
html/xml标签改变，将会成对改变～
3、Color Highlight
颜色标记
4、vscode-icon
文件图标
5、Turbo Console Log 或者 javascript console utils
按ctrl+Alt+L可以快速输出console.log
6、vetur
实现代码高亮
7、Path Intellisense
自动补全路径
8、Beautify
格式化代码 9、One Dark Pro
颜色主题
10、Chinese
简体中文
11、Document This
代码注释：输入/** 之后可自动生成注释信息
12、ES7 React/Redux/GraphQL/React-Native snippets
13、background-cover
14、vue3使用
15、 korofileheader生成文件头部注释和函数注释
页面级头部注释：Mac：ctrl+commit+i（::window：ctrl+win+i ）
函数注释Mac：ctrl+commit+t（::window：ctrl+win+t）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac23124dd0c2da28cc4a536eb6db3189/" rel="bookmark">
			QCS2290 secureboot 流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、提前准备 Bp侧代码Ap侧代码(全编译通过)HEXAGON_ToolsSnapdragon_SD_LLVM_ARM.LNX.4.0 Installer_40200.1.tar 高通Boot编译工具8.0版本以下版本的gcc 2、创建新的文件夹存放临时的签名文件OEM-KEYS 将如下文件拷贝到我们创建的OEM-KEYS目录下：
QCM2290.LA.3.0/common/sectools/resources/data_prov_assets/General_Assets/Signing/openssl/opensslroot.cfg QCM2290.LA.3.0/common/sectools/resources/data_prov_assets/General_Assets/Signing/openssl/v3.ext QCM2290.LA.3.0/common/sectools/resources/data_prov_assets/General_Assets/Signing/openssl/v3_attest.ext //Android R 上新增的，高通文档说要这个文件 3、生成对应的公钥和私钥 注意：高通建议使用的是ECDSA方法，这里我们使用2048的方式，接下来的都是有关2048的流程
在OEM-KEY目录下执行以下命令生成签名文件：
openssl genrsa -out qpsa_rootca.key -3 2048 openssl req -new -key qpsa_rootca.key -x509 -out rootca_pem.crt -subj /C=US/ST=California/L="San Diego"/OU="General Use Test Key (for testing 13 only)"/OU="CDMA Technologies"/O=QUALCOMM/CN="QCT Root CA 1" -days 7300 -set_serial 1 -config opensslroot.cfg openssl x509 -in rootca_pem.crt -inform PEM -out qpsa_rootca.cer -outform DER openssl x509 -text -inform DER -in qpsa_rootca.cer openssl genrsa -out qpsa_attestca.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac23124dd0c2da28cc4a536eb6db3189/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5931199d2e5767ac223f9776c6a86654/" rel="bookmark">
			Robust 2.0：支持Android R8的升级版热修复框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2016年，我们对美团Android热更新方案Robust的技术原理做了详细介绍。近几年，Google 推出了新的代码优化混淆工具R8，Android 热修复补丁制作依赖二次构建包和线上包对比，需要对Proguard切换到R8提前进行适配和改造，本文分享 Robust 在适配 R8 以及优化改进中的一些思路和经验，希望能对大家有所帮助或者启发。
1. 背景
2. 主要挑战
3 解决思路
3.1 整体方案介绍
3.2 问题和解决方法
4 总结
5 本文作者
1. 背景 美团 Robust 是基于方法插桩的实时热修复框架，主要优势是实时生效、零 Hook 兼容所有 Android 版本。2016 年，我们在《Android 热更新方案 Robust》一文中对技术原理做了详细介绍，主要通过给每个方法插入 IF 分支来动态控制代码逻辑，进而实现热修复。其核心主要有两部分：一个是代码插桩，一个是自动补丁。
代码插桩这部分随着 Javassist、ASM 工具的广泛使用，整体方案比较成熟了，迭代改进主要是针对插桩代码体积和性能的优化；
自动补丁这部分在实际使用过程中一直在迭代，跟业界主流热修复方案一样，自动化补丁工具作制作时机是在 Proguard 混淆之后，由于 Proguard 会对代码进行代码优化和混淆处理，在 Proguard 后制作补丁能够降低补丁生成的复杂性。
近年来， Google 推出了新的代码优化混淆工具 R8，用于取代第三方的代码优化混淆工具 Proguard，经过多年功能迭代和缺陷改进，R8 在功能上基本可以替代 Proguard，在结果上更为出色（优化生成的 Android 字节码体积更小）。Google 已经在新版本的构建工具中强制使用 R8 ，国内外已有多个知名 App 完成了 R8 适配并上线，比如微信 Android 在今年正式从 Proguard 切换到了 R8（通过升级 Android 构建工具链）。Android 热修复补丁制作依赖二次构建包和线上包对比，需要对 Proguard 切换到 R8 提前进行适配和改造，本文分享了美团平台技术部 Robust 在适配 R8 以及优化改进中的一些思路和经验。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5931199d2e5767ac223f9776c6a86654/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4d36ccab961f99e75c16dfb0a7e6627/" rel="bookmark">
			Linux screen的安装与使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Linux screen的安装与使用 screen命令用于程序后台查看和管理。
模型训练的时候往往需要几个到几十个小时不等，服务器连接容易断掉，使用screen能够方便查看后台运行程序（也会有log和tensorboard）。
查看服务器是否已经安装screen。
which screen 安装： Ubuntu apt-get install screen screen的使用 screen [-AmRvx -ls -wipe][-d &lt;作业名称&gt;][-h &lt;行数&gt;][-r &lt;作业名称&gt;][-s &lt;shell&gt;][-S &lt;作业名称&gt;] 参数说明 参数说明-A将所有的窗口调整为目前终端机大小-d将指定的screen作业离线，如 screen -d tmp-h指定窗口的缓冲区行数-m即使目前已在作业中的screen作业，仍强制建立新的screen作业-r恢复离线的screen作业，如screen -r tmp-R先试图恢复离线的作业。若找不到离线的作业，即建立新的screen作业-s建立新窗口时，所要执行的shell-S指定名称，创建时不指定则随机名称，删除时也需要指定-v显示版本信息-x恢复之前离线的screen作业，只存在一个作业时-ls显示目前所有的screen作业-wipe检查目前所有的screen作业，并删除已经无法使用的screen作业 创建screen，指定名称 screen -S temp 离开screen ctrl+ad键 重新连接screen screen -x //只存在一个screen作业 screen -r temp //指定恢复作业名称 删除多余screen，指定删除的作业名称 screen -S temp -X quit 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3170f28bbc9e460fa1b2730d3a1c789e/" rel="bookmark">
			Sql注入示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Sql注入是我们经常听说的，具体极大的风险性，下面给一个比较直观的示例：
USE tempdb GO IF OBJECT_ID('stu') IS NOT NULL DROP TABLE stu GO CREATE TABLE stu( stuId INT IDENTITY(1,1) PRIMARY KEY, stuName NVARCHAR(20) NOT NULL ) GO INSERT INTO stu(stuName) VALUES ('小明'),('小红'),('小江') GO --SELECT * FROM stu /* stuId	stuName 1	小明 2	小红 3	小江 */ GO ---------------- A. 使用参数化 ------------------- DECLARE @sql NVARCHAR(MAX), @stuName NVARCHAR(20)	--用户输入部分 SET @sql='select * from stu where 1=1 and stuName=@stuName' SET @stuName='''小明'';truncate table stu;' PRINT @sql EXEC sp_executesql @sql,N'@stuName nvarchar(20)',@stuName SELECT * FROM stu --没有查到任何记录，但原本的记录没有受影响 ---------------- B.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3170f28bbc9e460fa1b2730d3a1c789e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f84b74e6f12748b0b738df338cc8072/" rel="bookmark">
			台式机和笔记本对比？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 大小和移动性：台式电脑通常比笔记本电脑更大、更笨重、更不易携带，它们需要更大的桌面空间和固定的电源连接，不方便携带，而笔记本电脑则相对便携，可以随身携带并使用电池。
2. 处理性能：台式电脑的处理器、显卡和内存通常比同价位的笔记本电脑更强大。因为台式电脑的主板比笔记本更大，所以可以容纳更多的硬件组件，并且配有更好的散热系统。而笔记本电脑因为体积和散热问题，无法和台式电脑在性能上竞争。
3. 价格和可升级性：通常来说，同样价位的台式电脑通常比同等水平的笔记本电脑更强大。另外，用户可以自行升级台式电脑的硬件，而笔记本电脑基本上只能更换硬盘和内存等部件。
4. 用途：一些较为专业的工作需要长时间的处理，而台式电脑更适合这种需求；还有一些便携性要求低的工作，笔记本电脑更为适合。同时，注意不同领域和用户的需求不同，应该根据实际情况选择适合自己的设备。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d02a708170987ad136f1b22f567fbc1e/" rel="bookmark">
			SSH端口转发实现内网穿透的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SSH端口转发也称为SSH隧道，是一种将本地TCP端口转发到远程服务器上的技术，通常用于内网穿透。
以下是一些步骤：
1. 在Windows或其他本地操作系统上打开终端。
2. 连接到远程服务器：ssh user@remote-server-ip。
3. 启用端口转发并指定需要转发的本地端口和远程主机的目标端口：ssh -L local-port:remote-host:remote-port user@remote-server-ip。
4. 这样，本地端口local-port的流量将通过SSH隧道转发到远程服务器上的remote-host:remote-port。在应用程序中将该端口设置为使用本地即可访问远程主机。
例如，要将本地端口80转发到远程服务器192.168.1.100的端口80：
ssh -L 80:192.168.1.100:80 user@remote-server-ip
然后，您可以在浏览器中输入localhost:80来访问远程服务器上的Web应用程序。
需要注意的是，SSH隧道的方式是将流量全部转发到远程主机，如果有多个人同时使用这个隧道，将会影响隧道的性能。同时SSH隧道在数据加密等方面会带来一定的性能开销。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e800ad333ee50512373520ab8c1111f/" rel="bookmark">
			UartAssist串口调试工具使用指南 （附UartAssist工具包）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、UartAssist 概述 1、UartAssist简介 UartAssist串口调试助手软件，是Windows平台下的串口通信调试工具，广泛应用于工控领域的数据监控、数据采集、数据分析等工作，是串口应用开发及调试工作必备的专业工具之一，可以帮串口通信项目的应用设计、开发、测试人员检查所开发的串口通信应用软/硬件产品的数据收发状况，提高开发速度，简化开发复杂度，是串口通信应用开发调试的得力助手。
UartAssist串口调试助手是绿色软件，无需安装，只有一个执行文件，适用于各版本Windows操作系统，不需要微软dotNet框架支持。可以在一台PC上同时启动多个串口调试助手（使用不同的COM口）。
典型应用场合：通过串口调试助手与自行开发的串口程序或者串口设备进行通信联调。支持多串口，自动监测枚举本地可用串口；自由设置串口号、波特率、校验位、数据位和停止位等（支持自定义非标准波特率）；支持对串口DCD、DTR、DSR、RTS等针脚状态位的检测控制。
支持ASCII/Hex两种模式的数据收发，发送和接收的数据可以在16进制和AscII码之间任意转换；可以自动发送校验位，支持多种校验格式；支持间隔发送，循环发送，批处理发送，输入数据可以从外部文件导入；可以保存预定义指令/数据序列，任何时候都可以通过工具面板发送预定义的指令或数据，或进行批量指令发送，便于通信联调。
软件界面支持中/英文（通过菜单选项选择切换），默认自适应操作系统的语言环境。
功能点：
绿色软件、只有一个执行文件、无需安装；支持中英文双语言，自动根据操作系统环境选择系统语言类型；支持常用的各种波特率，端口号、校验位、数据位和停止位均可设置；支持软/硬件多种流控方式；自动检测枚举本机串口号，支持虚拟串口；支持设置分包参数（最大包长、分包时间），防止接收时数据粘包。支持ASCII/HEX码数据发送,发送和接收的数据可以在十六进制码和ASCII码之间任意转换，支持发送和显示汉字；可以自动发送校验位，支持多种校验格式，如校验和、LRC、BCC、CRC8、CRC16、CRC32、MD5等，其中CRC校验码可任意定制CRC参数(CRC多项式、初始值、输入反转、输出反转、输出异或值)；发送内容支持转义字符。例如，发送框中文本包含诸如\r\n等转义符时，会自动解析成对应的ASCII码进行发送。支持AT指令自动添加回车换行选项，启用该选项时，在发送AT指定时会自动在行尾补全回车换行符；可以通过输入框发送数据,也可以从文件数据源发送数据；支持接收数据自动保存到文件,并且文件类型支持数据文件和日志文件两种格式，其中数据文件只保存接收的数据内容，而日志文件则会保存调试助手完整的数据收发日志信息。支持日志接收模式：启用该选项后在接收窗口显示接收内容时自动显示时间戳等相关信息。支持任意间隔发送，循环发送；接收和发送的文字编码支持ANSI(GBK)与UTF8两种方式，并且接收编码与发送编码可以独立设置，互不影响；支持预定义指令/数据，可通过按键或者自定义快捷键发送预定义指令,预定义指令/数据列表可以按文件的方式保存、导入和导出；支持批量发送指令/数据序列，可设置每条指令的发送延迟，并可按设定顺序及延迟时间依次批量发送。批量定义的数据/指令可以保存、导入和导出。自动保存历史发送记录，可以通过历史记录发送历史数据；支持界面窗口的字体以及背景定制；支持工作界面精简模式（主界面左侧面板可折叠收起）；可定制发送框默认数据内容； 2、运行环境 软件运行环境为Windows平台,包括Windows95/WinXP/Vista/Win7/Win8/Win10/WinALL，兼容32位/64位操作系统。
3、软件安装 绿色软件，解压后只有一个执行文件，直接运行即可。无需安装（不依赖）Microsoft .NETFramework框架。
4、应用场景 串口调试助手通过对PC端口串口(COM口或USB串口）的读写操作，实现对串口设备或者串口应用程序的通信联调。通过串口数据的抓取、记录、分析以及数据/指令的发送控制，实现对目标串口设备或者串口应用程序的通信能力以及通信行为的分析、验证。总的来说，串口调试助手，主要有几下几类应用场景。
（1） 串口终端(仪器设备)的参数设置。工程应用中为了方便终端设备的参数设置，可通过串口调试助手建立到串口终端设备的串口连接，然后直接在串口调试助手中对串设备进行参数设置。
（2）串口终端(仪器设备)的操作控制、串口数据的抓取、记录及分析。在工程应用中，某些场景下需要对串口设备发送指令从而实现对设备的控制操作，或者需要对串口设备的数据进行抓包记录。通过串口调试助手可以定时向串口终端发送指令数据，并自动将接收及发送的报文数据，并按日志的形式保存至磁盘文件，以便于用户对设备的状态数据进行分析统计。
（3）工控设备/单片机的开发调试。在单片机/嵌入式系统的串口开发过程中，可通过串口调试助手接收单片机设备的串口数据，或者向单片机设备发送串口数据，配合单片机程序开发，验证单片机程序的通信能力以及业务逻辑的准确性；或者通过串口调试助手对单片机设备进行数据疲劳测试（通过批量或者循环指令发送），并记录通信过程中的数据交互日志，实现串口产品在研发过程中的可靠性验证。
5、软件界面 UartAssist串口调试助手的主要功能界面如下图所示，包括主界面及工具面板窗口各项功能构成。
软件主界面：
界面基本构成： 界面主题（背景/字体）设置：
工具面板—快捷定义：
工具面板/批量发送：
工具面板/历史发送： 工具面板/检验计算器：
二、UartAssist 配置选项 调试助手的配置参数及控制选项众多，涉及的内容包括系统语言、文字编码、窗口样式、数据格式、数据校验、转义字符支持、数据发送控制方式、数据接收存储及日志文件记录等等。
使用调试助手进行通信调试时，结合实际应用场景，使用恰当的配置选项，可以有效地提高通信调试的工作效率，甚至达到事半功倍的效果。
1、语言及编码 调试助手软件支持中、英文双语，默认情况下自动根据系统语言选择切换。在中文环境下自动选择中文，其它语言环境自动选择为英文。也可以通过调试助手的[Language]菜单选项，直接指定中/文语言。
调试助手的数据编码支持 ANSI(GBK)/UTF-8 两种编码。默认方式是ANSI(GBK)编码。如果接收窗口显示乱码数据，有可能接收到的数据是 UTF-8 编码的文字，如果按照默认的ANSI(GBK)方式显示就会乱码.解决方法是，在接收窗口中点击右键，在弹出菜单中，选择切换编码为 UTF-8，如上图所示。
注意，切换编码后，并不会刷新显示已接收的乱码数据，只有后来新接收的数据才能按新的编码设置来显示。
发送数据时，也涉及到文字编码方式的选择。发送窗口的编码方式与接收窗口的编码方式是相互独立的。同接收窗口的编码设置方式一样，在发送窗口点击右键，在弹出的右键菜单，可以选择发送数据的编码方式为 ANSI(GBK)或 UTF-8。
对于英文字母或字符，不需要区分是 ANSI(GBK)编码还是 UTF-8 编码，因为这两种编码是相同的，都是一个字节的 ASCII 码；但是对于汉字等多字节编码的文字或符号则是不一样的。比如，1 个汉字的 ANSI(GBK)编码占 2 个字节，而 1 个汉字的 UTF-8 编码则占3 个字节。调试助手能够按照所设置的编码方式对收发数据进行相应的编码及显示处理。
比如，在发送窗口输入汉字“你好”，然后点击【发送】按钮时，如果按 ANSI(GBK)编码发送，则实际发送的 16 进制数据是“C4 E3 BA C3”，而按 UTF-8 编码发送时，实际发送的16 进制数据是“E4 BD A0 E5 A5 BD”。调试助手会按照当前设定的编码发送正确的数据。 2、窗口主题样式 为了确保软件界面更符合个人视觉习惯，调试助手提供了界面主题定制功能。界面主题定制的内容，包括字体样式、大小、颜色及背景。并且，日志提示符、接收的数据、发送的数据，其字体颜色可以分别独立设置。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e800ad333ee50512373520ab8c1111f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d54cf05892a0187f73be3473a9d451c6/" rel="bookmark">
			【SpringBoot整合JWT】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、什么是JWT
二、JWT能做什么 三、为什么是JWT 1、基于传统的Session认证
2、基于JWT认证
四、JWT的结构是什么 五、JWT的第一个程序
六、封装JWT工具类 七、整合SpringBoot使用
一、什么是JWT JSON Web Token (JWT) is an open standard ([RFC 7519](https://tools.ietf.org/html/rfc7519)) that defines a compact and self-contained way for securely transmitting information between parties as a JSON object. This information can be verified and trusted because it is digitally signed. JWTs can be signed using a secret (with the HMAC algorithm) or a public/private key pair using RSA or ECDSA---[摘自官网]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d54cf05892a0187f73be3473a9d451c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ee86459d4fae4299bdf696e58b32538/" rel="bookmark">
			VMware Workstation 与 Device/Credential Guard 不兼容解决方案（亲测有效）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 VMware Workstation是由VMware公司开发的桌面虚拟化软件，它能够在一台物理计算机上模拟多个独立的虚拟计算机环境，每个虚拟计算机环境都可以运行一个独立的操作系统，并具有各自独立的应用程序和文件库，使得运行多个不同操作系统或者多个版本的操作系统变得非常容易。
VMware Workstation支持多种主流操作系统，包括Windows、Linux、macOS等。使用VMware Workstation，用户可以方便地创建、配置、运行和测试虚拟计算机环境，从而加快软件开发生命周期和提高软件质量。
与其他桌面虚拟化软件相比，VMware Workstation有着根本性的优势。首先，它不仅提供最高级别的安全隔离，而且还有定制、协调和管理的功能，创造出特殊的工作环境。其次，VMware Workstation具备众多强大的功能，例如API、核心虚拟化功能和灵活的规划管理。此外，还有强大的内存管理和处理资源削减、权限控制等功能。
除了以上基本功能之外，VMware Workstation还提供了一些高级功能，例如联机克隆、恢复快照、虚拟机记录、限制虚拟机CPU、内存和网络带宽等。用户还可以在VMware Workstation中创建跨越多个平台的虚拟网络，以及快速从一个虚拟机迁移到另一个虚拟机。
作为一款成熟、高效、稳定的桌面虚拟化软件，VMware Workstation在各种行业都有广泛应用，如IT管理、软件开发、测试、培训、游戏开发等领域。由于其灵活性、可扩展性和安全性，VMware Workstation不仅可以自定义自己的虚拟机网络环境，而且可以降低程序员和网络管理员的人工负担，还有助于探索新的研究方向或者进行教学课程。
总之，VMware Workstation是一款功能强大、极易使用、高效稳定且具备广泛适用性的桌面虚拟化软件，对于需要模拟多个操作系统环境的十分必要。
一、问题原因 VMware Workstation 与 Device/Credential Guard 不兼容的原因是因为 Device/Credential Guard 是一个安全功能，它使用虚拟化技术来帮助保护计算机免受恶意软件和网络攻击。而 VMware Workstation 同样使用虚拟化技术，二者会产生冲突。
当启用 Device/Credential Guard 时，Windows 将使用 Hyper-V 引擎来运行系统核心，并将其他虚拟化方案禁用。VMware Workstation 需要访问系统核心的一些部分，包括 VT-x 虚拟化、EPT 和 VBS 等功能；但是，Hyper-V 启用后，这些功能不再可用。因此，在启用了 Device/Credential Guard 的计算机上，VMware Workstation 无法正常运行。
二、解决方法 1、按下WIN+R打开运行，然后输入services.msc回车。
2、在服务中找到 HV主机服务，双击打开设置为禁用，如下图所示。
3、win+x，然后打开powershell（管理员）运行命令bcdedit /set hypervisorlaunchtype off。
4、重启电脑，大功告成。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be3c76519ef9f6a844be0952b56da5a9/" rel="bookmark">
			代码随想录算法训练营第四天|24. 两两交换链表中的节点 19.删除链表的倒数第N个节点 面试题 02.07. 链表相交 142.环形链表II
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		24. 两两交换链表中的节点
题目： 给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。
示例 1：
输入：head = [1,2,3,4]
输出：[2,1,4,3]
示例 2：
输入：head = []
输出：[]
示例 3：
输入：head = [1]
输出：[1]
思路： 建议使用虚拟头结点，这样会方便很多，要不然每次针对头结点（没有前一个指针指向头结点），还要单独处理。
初始时，cur指向虚拟头结点，然后进行如下三步：
代码： /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* swapPairs(ListNode* head) { ListNode* dummyHead = new ListNode(0); // 设置一个虚拟头结点 dummyHead-&gt;next = head; ListNode* tmp; ListNode* tmp1; ListNode* cur = dummyHead; while((cur-&gt;next !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be3c76519ef9f6a844be0952b56da5a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3275f76aab27b9bdc442759e2a66dd1/" rel="bookmark">
			基于eNSP的IPv6校园网络规划与设计_综合实验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言及技术/资源下载说明（ 未经允许禁止转发任何内容 ）
有什么问题可以在评论区说明自己遇到的情况，博主看到会第一时间回复，希望其他人也可以回复别人的问题。
可根据以下所提供的设计与实现步骤过程一步一步自行实现（每一条命令都是关键的命令）；但是如果有需要的也可以根据以下地址进行下载完整的topo图和完整的配置进行参考与借鉴，如若拿到topo图可多display查看配置，查看相应的命令，配套资源连接如下，相应的内容如下图所示：
基于eNSP的IPv6校园网络规划与设计_综合实验topo和完成配置+一步步的所有配置命令(ensp)+一步步可以直接刷的记事本命令可快速配置重复的工作+全程配置参考视频(可2倍速看)+相应地址规划表
以下是topo图的模样，相应的地址规划和路由规划大部分都在图中明确的标注了
该topo网络中用到的技术有vlan划分、单臂路由(路由器子接口配置)、VRRP6、OSPFv3、防火墙安全策略、DHCPv6、IPv6 over IPv4 GRE(也就是这个隧道技术)、默认路由(IPv4/IPv6)等技术，最后说明该topo规划最后的作者权归于：小王网
一、设计topo图与设计要求 设计要求： 总部的终端设备设置为静态地址，方便用户自行修改地址 在接入和汇聚的交换机进行合理的vlan 划分，减小广播域大小，提高网络稳定性 核心路由器作为用户网关实现vlan间路由 AR3/AR4配置VRRP6虚拟网关冗余 AR3/AR4/AR1配置OSPFv3实现三层路由 FW配置相应地址和安全策略，允许除vlan 20外的网段访问DMZ区 分校的终端设备在相应设备上配置DHCPv6，让用户能自动获取ipv6地址 总校与分校之间通过配置IPv6 over IPv4 GRE隧道互通 总校与分校之间通过隧道GRE能实现互通 二、相应地址规划表 三、ensp典型中小型企业网搭建(带无线)(可不看) 插曲部分： ensp典型中小型企业网络搭建_带无线_设计实验，如下图（但并不在这篇文章中做详细介绍和说明，如查看可点击链接自行查看阅读）： 每个部门划分一个VLAN，部门内互通，各部门根据ACL规则实现互通。
内网使用私网IP，为每个部门分配一个24位掩码长度的私网段，实现上网。
部门主机采用DHCP自动获取地址，减少管理员手动分配的任务量，方便管理与维护。
运行OSPF协议，提高收敛速度。而且OSPF可以适应拓扑变化，路由自动学习，防止路由环路，提高拓扑稳定性。
接入层和汇聚层交换机配置MSTP和VRRP技术，实现设备冗余、线路可靠、数据负载分担，能够保证主设备故障后，可以快速切换到备用设备，不影响业务转发。
增加防火墙设备，设置安全区域，控制部门主机、服务器和外网设备的数据转发，保证公司网络的安全性。
出口采用光纤接入，汇聚层交换机进行链路聚合，提高网络带宽，实现运营商万兆接入，千兆到部门，百兆到桌面的体验。
公司内部实现无线全覆盖，保障内部终端设备可以无线接入并上网。
汇聚层交换机配置ACL控制访问技术，实现市场部和行政部不通，财务部只能和行政部互通，其他部门全互通的网络需求。
SNAT:应用于内网用户访问Internet时进行的地址转换将私网地址转为公网地址，这里我们采用easy-ip的NAT，保证公司上网采用出接口地址。
DNAT:使的外网用户能够访问内部服务器，用户访问202.96.137.88:8080时，防火墙将流量能够送给内网的WEB服务器。当用户访问202.96.137.88:21时防火墙将目的地址转换为172.16.50.20:21 访问公司的FTP服务器。
四、该网络规划全过程（顺着一步一步走） 1、接入层vlan划分 LSW5: &lt;Huawei&gt;sys [Huawei]un in en [Huawei]sysname LSW5 [LSW5]vlan 10 [LSW5-vlan10]qui [LSW5]int e0/0/1 [LSW5-Ethernet0/0/1]port link-type access [LSW5-Ethernet0/0/1]port default vlan 10 [LSW5-Ethernet0/0/1]int e0/0/2 [LSW5-Ethernet0/0/2]port link-type trunk [LSW5-Ethernet0/0/2]port trunk allow-pass vlan all [LSW5-Ethernet0/0/2]qui LSW6: &lt;Huawei&gt;sys [Huawei]un in en Info: Information center is disabled.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3275f76aab27b9bdc442759e2a66dd1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da0ce73a1a9b1cee9c286d458a08d7eb/" rel="bookmark">
			Android Retrofit原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有兴趣的同学可以参考下面的流程，阅读Retrofit代码。
下面是retrofit进行网络请求的具体流程：
1.在retrofit.creat()中，return的时候会去创建一个动态代理类，具体代码如下：
public &lt;T&gt; T create(final Class&lt;T&gt; service) { Utils.validateServiceInterface(service); if (validateEagerly) { eagerlyValidateMethods(service); } return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] { service }, new InvocationHandler() { private final Platform platform = Platform.get(); @Override public Object invoke(Object proxy, Method method, Object... args) throws Throwable { // If the method is a method from Object then defer to normal invocation. if (method.getDeclaringClass() == Object.class) { return method.invoke(this, args); } if (platform.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da0ce73a1a9b1cee9c286d458a08d7eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/306d61cebc6e09a6fd60b6e3121ad82a/" rel="bookmark">
			扫雷详解（附代码）（保姆级教学）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 我们都知道扫雷的玩法，那怎么通过C语言来实现呢？希望通过阅读这篇文章可以给你带来帮助，我们从创建头文件，源文件开始，到最后实现整个游戏，全程一步一步手拿把掐的分享博主的经验，以下内容是详细过程及代码。话不多说，直接上货！
一·创建源文件 头文件 我们在vs2019中创建一个头文件，两个源文件，头文件用来声明函数，两个源文件一个用来写游戏实现的代码，一个用来写主函数。例如这样：
要想完成扫雷游戏的全部程序，我们要想通怎么设计这个游戏，首先我们要确定要设置几个炸弹，所以我们在头文件中定义一个炸弹变量，EASY_COUNT.，初始棋盘全是‘0’，当炸弹被布置的时候，此时设为‘1’，然后因为是扫雷游戏嘛，我们需要一个棋盘来进行埋雷和排查雷的过程，其次我们需要另外一个棋盘来显示当我们选择其中的的一个位置以后，这个位置不是雷，此时我们要显示在这个位置的周围雷的个数信息，我们把这个信息存储到另外一个棋盘当中，所以我们一共需要两个棋盘，想通这个我们就可以进行下一步的游戏设计了，像三子棋一样，我们需要先定义行和列，我们在这里设置变量名称为ROW和COL，因为扫雷棋盘一般都是9X9的形式，所以我们在这里设置为9X9。
但是想到这里是不是有一点小问题呢？问题就出现在当我们选择的点是边缘点时，它周围的点不足八个，此时我们就会出现溢出的情况：如下图展示
如左图展示，当我们选择左下角的点时，它周围只有三个点的信息，但是我们要遍历八个点的信息，这时候就会出现溢出的情况，那我们怎么解决这个问题呢？再给棋盘大一圈不就好了嘛，我们在这里再设置两个变量ROWS，COLS，大小为11X11，解决完这个问题以后，我们再进行下一步的游戏设计，我们看右图的棋盘，我们先初始化棋盘，使这个棋盘所有的位置都显示‘*’，表示这个点未被选择，当这个点被选择时，此点显示周围雷的个数的信息。
当想到这里时，我们就快完成整个游戏的设计了，之后我们再声明提到的四个函数，分别是初始化棋盘 InitBoard，打印棋盘，DisplayBoard，布置雷，SetMine，排查雷，FindMine。
代码如下展示：
#pragma once #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&lt;time.h&gt; #define EASY_COUNT 10 #define ROW 9 #define COL 9 #define ROWS ROW+2 #define COLS COL+2 //初始化棋盘 void InitBoard(char board[ROWS][COLS], int rows, int cols, char set); //打印棋盘 void DisplayBoard(char board[ROWS][COLS], int row, int col); //布置雷 void SetMine(char board[ROWS][COLS], int row, int col); //排查雷 void FindMine(char mine[ROWS][COLS], char show[ROWS][COLS], int row, int col); 二.游戏的创建 第一步，我们要在主函数的源文件中写一个菜单代码，如下展示：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/306d61cebc6e09a6fd60b6e3121ad82a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0da80d4f35b10deb14949e854ebb5027/" rel="bookmark">
			通过哪些平台可以了解网络安全技术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学肯定少不了去技术网站“偷师学艺”，今天也整理了一些我常看的技术网站，给想自学网络安全的朋友一点参考建议。
话不多说，直接开整（仅供参考，有不当之处欢迎指出改正）
一、FreeBuf FreeBuf是网络安全行业门户网站，进去后主页长这样：
指路👉：FreeBuf网络安全行业门户
​安全圈知名技术网站
二、先知社区 指路👉：技术讨论 - 先知社区
​先知社区是国内非常优秀的安全社区
三、奇安信技术社区 指路👉：奇安信攻防社区
​
奇安信攻防社区是奇安信补天漏洞响应平台为用户打造的技术交流分享平台
四、安全客 指路👉：安全客 - 安全资讯平台
​ 五、看雪论坛 指路👉：看雪论坛-安全社区|安全招聘|bbs.pediy.com
​
六、CSDN 指路👉：网络空间安全博客-专业IT技术发表平台
虽然广告很多，但是也能白嫖不少资料😜
学习路线 首先别想分方向，先打好基础！
第一步：计算机基础 这第一步，其实跟网络安全关系都不太大，而是进入IT领域的任何一个人都要掌握的基础能力。下面五大课程，是大学老师当年教给我们不管你是什么技术方向最好都好好学的技术，如今看来，仍然不过时：
计算机网络
计算机组成原理
操作系统
算法与数据结构
数据库
这每一门课程其实都内有乾坤，基本都不能做到一次学习就能掌握，而是伴随每个人的职业生涯，不同的技术阶段都会有不一样的认识和感受。
具体学起来建议参考敏捷开发，不断迭代：有一个粗略的认识-&gt;有了进一步的认识-&gt;彻底掌握-&gt;温故而知新。不用纠缠于把一门课程全部学完学懂才进入下一门课程。
第二步：编程能力 有了上面的一些基本功后，这个时候就需要动手，来写点代码，锤炼一下编程的功底。
下面三项，是安全行业的从业者都最好能掌握的语言：
·Shell脚本
掌握常用的Linux命令，能编写简单的Shell脚本，处理一些简单的事务。
·C语言（C++可选）
C语言没有复杂的特性，是现代编程语言的祖师爷，适合编写底层软件，还能帮助你理解内存、算法、操作系统等计算机知识，建议学一下。
·Python
C语言帮助你理解底层，Python则助你编写网络、爬虫、数据处理、图像处理等功能性的软件。是程序员，尤其是黑客们非常钟爱的编程语言，不得不学。
第三步：安全初体 有了前面两步的打底，是时候接触一些网络安全的技术了，刚刚开始这个阶段，仍然不要把自己圈起来只学某一个方向的技术。这个阶段，我的建议是：但当涉猎，见往事耳。
网络协议攻击、Web服务攻击、浏览器安全、漏洞攻击、逆向破解、工具开发都去接触一下，知道这是做什么的，在这个过程中去发现自己的兴趣，让自己对网络安全各种领域的技术都有一个初步的认识。
第四步：分方向 在第三步中，慢慢发现自己的兴趣点，是喜欢做各种工具的开发，还是喜欢攻破网站，还是痴迷于主机电脑的攻击···
这个时候就可以思考自己后面的方向，然后精力开始聚焦在这个方向上，通过上面思维导图中各自方向的技术去持续深耕，成为某一个领域的大拿。
学习方法 上面介绍了技术分类和学习路线，这里来谈一下学习方法
看书学习，这是最最基础的
实际动手，开发路线需要多写代码，阅读优秀开源代码，二进制路线多分析样本，编写EXP等等，渗透测试多拿网站练手（合法方式）等
打CTF，多参与一些网络安全比赛，接近实战的环境下锻炼动手能力
混圈子，多混一些安全大牛出没的社群、社区、论坛，掌握行业信息，了解最新技术变化趋势
对于网络安全方面，我自己也做了很多的研究，整理了很多网络安全的资源，从入门到进阶的都有，包括红蓝对抗的完整学习路线图、配套的视频教程、工具包和技术文档等等：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2dc000ea01463ecb7b5f0f3a70863ab/" rel="bookmark">
			2023前端常见面试题大全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 什么是作用域？ 变量 产生作用的区域就叫做作用域
2. 作用域的分类 全局作用域
局部作用域
3.局部作用域的分类 函数作用域
块级作用域
4.作用域链 作用域链的本质是变量查找机制
5.作用域链查找规则是什么？ a. 会优先查找自己的作用域
b. 自己的作用域查找不到的话会往上查找父级直到全局作用域
6.什么是垃圾回收机制 是 JS 中一种自动回收或释放内存的机制 简称 GC
7.垃圾回收机制有几种算法？ 引用计数法：IE采用的引用计数算法, 定义“内存不再使用”的标准很简单，就是看一个对象是否有指向它的引用
如果这个值的被引用了一次，那么就记录次数1 ， 如果减少一个引用就减1。 如果引用次数是0 ，则释放内存。但它却存在一个致命的问题：嵌套引用。
标记清除法：就是从根部（在JS中就是全局对象）出发定时扫描内存中的对象。 凡是能从根部到达的对象，都是还需要使用的。
无法由根部出发触及到的对象被标记为不再使用，稍后进 行回收
8.什么是闭包？ 就是有权访问另一个函数作用域中变量的函数
9.闭包的表现形式？ 在一个函数内部创建另外一个函数
10.闭包有什么作用？ 封闭数据，实现数据私有，防止数据被意外修改
11.闭包的弊端 容易导致内存泄露
12.什么是变量提升？ 使用 var 声明的变量，会被提升到函数或全局作用域的顶部，这个现象叫做变量提升。
13.用哪个关键词会产生变量提升？ var会存在变量提升，let/const 声明的变量不存在变量提升
14.什么是构造函数 是一种特殊的函数，主要用来初始化对象 ，同时可以用构造函数来快速创建多个类似的对象。
15.构造函数创建对象的过程 创建新对象构造函数this指向新对象执行构造函数代码，修改this，添加新的属性返回新对象 16.伪数组转真数组的方法 1.Array.from
2.Array.prototype.slice.call( )
3…展开运算符
17.什么是JavaScript 中的包装类型 在 JavaScript 中，基本类型是没有属性和方法的，但是为了便于操作基本类型的值，在调用基本类型的属性或方法时 JavaScript 会在后台地将基本类型的值转换为对象，这些对象就是包装类型
18. JavaScript有哪些数据类型，它们的区别？ JavaScript共有八种数据类型，分别是 Undefined、Null、Boolean、Number、String、Object、Symbol、BigInt。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2dc000ea01463ecb7b5f0f3a70863ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9400a40270a4b24e96880c8d1a4c4a8b/" rel="bookmark">
			永久修改pip国内镜像源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 以下阿里云镜像源为例
临时配置
pip install -i https://mirrors.aliyun.com/pypi/simple/ 库名 永久配置（两种方式，二选一）
命令行窗口（cmd 或者 shell）下（推荐） pip config set global.index-url https://mirrors.aliyun.com/pypi/simple/ 手动
路径：C:\Users\用户名\AppData\Roaming
找到pip文件夹，没有就新建
在pip文件夹下新建pip.ini
双击pip.ini文件并输入以下内容 [global] index-url = https://mirrors.aliyun.com/pypi/simple/ trusted-host = mirrors.aliyun.com 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5077785340316395185aeecbde5790f3/" rel="bookmark">
			Python技能练习！值得你看的28道常见题型汇总！（附答案解析）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天给大家分享30道Python练习题，建议大家先独立思考一下解题思路，再查看答案。 【文末有惊喜】 1.已知一个字符串为 “hello_world_yoyo”，如何得到一个队列
[“hello”,”world”,”yoyo”] ？
使用 split 函数，分割字符串，并且将数据转换成列表类型：
test = 'hello_world_yoyo'``print(test.split("_"))``12 结果：
['hello', 'world', 'yoyo'] 2. 有个列表 [“hello”, “world”, “yoyo”]，如何把列表里面的字符串联起来，得到字符串 “hello_world_yoyo”？
使用 join 函数将数据转换成字符串：
test = ["hello", "world", "yoyo"]``print("_".join(test)) 结果：
hello_world_yoyo 如果不依赖 python 提供的 join 方法，还可以通过 for 循环，然后将字符串拼接，但是在用“+”连接字符串时，结果会生成新的对象，使用 join 时结果只是将原列表中的元素拼接起来，所以 join 效率比较高。
for 循环拼接如下：
test = ["hello", "world", "yoyo"]``# 定义一个空字符串``j = ''``# 通过 for 循环打印出列表中的数据``for i in test:` `j = j + "_" + i``# 因为通过上面的字符串拼接，得到的数据是“_hello_world_yoyo”，前面会多一个下划线_，所以把这个下划线去掉``print(j.lstrip("_")) 3. 把字符串 s 中的每个空格替换成”%20”，输入：s = “We are happy.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5077785340316395185aeecbde5790f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7317f98c21d685b0b959db32b61e1357/" rel="bookmark">
			django搭建图书管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Django是一个高效、灵活的Python Web框架，它可以快速地构建Web应用程序。在本篇文章中，我们将介绍如何使用Django框架构建一个图书管理系统。
1.使用虚拟环境创建项目
2.安装django模块,可使用代码 pip install django 进行安装,也可以在Pycharm的Python解释器下”+”安装
3.创建项目
django-admin startproject Library 4创建APP
cd Library python manage.py startapp MyApp 5.设置setting.py文件
INSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'MyApp', ] MIDDLEWARE = [ 'django.middleware.security.SecurityMiddleware', 'django.contrib.sessions.middleware.SessionMiddleware', 'django.middleware.common.CommonMiddleware', 'django.middleware.csrf.CsrfViewMiddleware', 'django.contrib.auth.middleware.AuthenticationMiddleware', 'django.contrib.messages.middleware.MessageMiddleware', 'django.middleware.clickjacking.XFrameOptionsMiddleware', ] ROOT_URLCONF = 'Library.urls' TEMPLATES = [ { 'BACKEND': 'django.template.backends.django.DjangoTemplates', 'DIRS': [os.path.join(BASE_DIR, 'MyApp/templates')] , 'APP_DIRS': True, 'OPTIONS': { 'context_processors': [ 'django.template.context_processors.debug', 'django.template.context_processors.request', 'django.contrib.auth.context_processors.auth', 'django.contrib.messages.context_processors.messages', ], }, }, ] WSGI_APPLICATION = 'Library.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7317f98c21d685b0b959db32b61e1357/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e117aaa8163360c224f0afbec764bcc6/" rel="bookmark">
			【Nvidia Jetson Xavier NX/AGX/NANO】上用docker跑pytorch等cv推理应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Nvidia Jetson Xavier NX/AGX docker WHY镜像地址使用方法docker常用命令备忘jtop安装关于保存容器镜像关于使用dockerfile构建关于映射外部路径让容器访问外部文件关于性能 WHY 在jetson上使用docker跑opencv和pytorch其实主要是要找对镜像，docker官方的hub里并没有适合的能直接跑的镜像，但是nvidia自己提供了L4T的pytorch和ML镜像。
镜像地址 单独pytorch的镜像：
https://catalog.ngc.nvidia.com/orgs/nvidia/containers/l4t-pytorch
整合了opencv，pytorch，tensorflow的ML镜像：
https://catalog.ngc.nvidia.com/orgs/nvidia/containers/l4t-ml
如果不是嫌大推荐直接使用ML的镜像，包含了opencv，要在pytorch的镜像中安装编译opencv太慢了，jetson的cpu都不太行，除非对opencv的版本有特殊需求。
如果对opencv的版本有特殊需求，建议还是找一下jetpack有没有对应的版本直接刷机对应的jetpack然后使用对应的docker镜像。
使用方法 先查看当前jetson设备的jetpack版本，例如我的是4.6版本，找到对应的镜像的编号，从tag里找到镜像地址
然后pull下来就行了
sudo docker pull nvcr.io/nvidia/l4t-ml:r32.6.1-py3 然后就可以进docker使用了
sudo docker run -it --rm --runtime nvidia --network host nvcr.io/nvidia/l4t-ml:r32.6.1-py3 docker常用命令备忘 sudo docker images #查看现有的镜像 sudo docker ps #查看现在运行的容器 #运行docker并把本地的work目录挂在容器的/workspace目录 sudo docker run -it --gpus all --restart always --name torch1 -p 6013:6013 -w /workspace -v /home/nvidia/work/:/workspace repo001:pth1.9-cu102-py3.6 /bin/bash sudo docker exec -it 1dd3379af334 /bin/bash #进入容器命令交互 sudo docker stop 1dd3379af334 #停止容器 jtop安装 要查看jetson的运行状态，我们可以安装jtop
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e117aaa8163360c224f0afbec764bcc6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20a8eed8676d8864066121d7ea59f3b3/" rel="bookmark">
			zookeeper权限控制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ACL全称为Access Control List（访问控制列表），用于控制资源的访问权限。分为三个维度：scheme、id、permission，schema代表授权策略，id代表用户，permission代表权限。
scheme:id world: 它下面只有一个 id, 叫 anyone, world:anyone 代表任何人，zookeeper 中对所有人有权限的结点就是属于 world:anyone 的
auth: 它不需要 id, 只要是通过 authentication 的 user 都有权限（zookeeper 支持通过 kerberos 来进行 authencation, 也支持 username:password 形式的 authentication)
digest: 它对应的 id 为 username:BASE64(SHA1(password))，它需要先通过 username:password 形式的 authentication
ip: 它对应的 id 为客户机的 IP 地址，设置的时候可以设置一个 ip 段，比如 ip:192.168.1.0/16, 表示匹配前 16 个 bit 的 IP permission(权限) 权限权限描述ccreate:创建权限，在该path下创建子节点的权限ddelete：删除权限,删除该path节点下子节点的权限rread:读权限 读取当前节点的data属性的权限wwrite:写权限，允许更新当前节点的dataaadmin:管理员权限，允许对改节点的acl权限进行管理 create权限 #设置/wusp的权限为drwa,少了c setAcl /wusp world:anyone:drwa cZxid = 0x4 ctime = Sun May 14 17:33:09 CST 2023 mZxid = 0x5 mtime = Sun May 14 17:52:57 CST 2023 pZxid = 0x4 cversion = 0 dataVersion = 1 aclVersion = 1 ephemeralOwner = 0x0 dataLength = 8 numChildren = 0 #创建子节点的时候权限不足 [zk: localhost:2181(CONNECTED) 21] create /wusp/child data Authentication is not valid : /wusp/child #给/wusp加上create权限 [zk: localhost:2181(CONNECTED) 22] setAcl /wusp world:anyone:cdrwa cZxid = 0x4 ctime = Sun May 14 17:33:09 CST 2023 mZxid = 0x5 mtime = Sun May 14 17:52:57 CST 2023 pZxid = 0x4 cversion = 0 dataVersion = 1 aclVersion = 2 ephemeralOwner = 0x0 dataLength = 8 numChildren = 0 #子节点创建成功 [zk: localhost:2181(CONNECTED) 23] create /wusp/child data Created /wusp/child delete权限 #移除delete权限 [zk: localhost:2181(CONNECTED) 24] setAcl /wusp world:anyone:crwa cZxid = 0x4 ctime = Sun May 14 17:33:09 CST 2023 mZxid = 0x5 mtime = Sun May 14 17:52:57 CST 2023 pZxid = 0x35 cversion = 1 dataVersion = 1 aclVersion = 3 ephemeralOwner = 0x0 dataLength = 8 numChildren = 1 #rmr命令提示权限不足 [zk: localhost:2181(CONNECTED) 25] rmr /wusp Authentication is not valid : /wusp/child #delete命令提示权限不足 [zk: localhost:2181(CONNECTED) 26] delete /wusp/child Authentication is not valid : /wusp/child #增加delete权限 [zk: localhost:2181(CONNECTED) 27] setAcl /wusp world:anyone:cdrwa cZxid = 0x4 ctime = Sun May 14 17:33:09 CST 2023 mZxid = 0x5 mtime = Sun May 14 17:52:57 CST 2023 pZxid = 0x35 cversion = 1 dataVersion = 1 aclVersion = 4 ephemeralOwner = 0x0 dataLength = 8 numChildren = 1 #/wusp/child节点成功删除 [zk: localhost:2181(CONNECTED) 28] delete /wusp/child [zk: localhost:2181(CONNECTED) 29] read权限 #新增/wusp/child节点 [zk: localhost:2181(CONNECTED) 29] create /wusp/child data Created /wusp/child #移除read权限 [zk: localhost:2181(CONNECTED) 32] setAcl /wusp world:anyone:cdwa cZxid = 0x4 ctime = Sun May 14 17:33:09 CST 2023 mZxid = 0x5 mtime = Sun May 14 17:52:57 CST 2023 pZxid = 0x3b cversion = 3 dataVersion = 1 aclVersion = 5 ephemeralOwner = 0x0 dataLength = 8 numChildren = 1 #获取/wusp节点的data,提示权限不足 [zk: localhost:2181(CONNECTED) 33] get /wusp Authentication is not valid : /wusp #但是成功获取/wusp/child几点的data [zk: localhost:2181(CONNECTED) 35] get /wusp/child data cZxid = 0x3b ctime = Wed May 17 21:13:06 CST 2023 mZxid = 0x3b mtime = Wed May 17 21:13:06 CST 2023 pZxid = 0x3b cversion = 0 dataVersion = 0 aclVersion = 0 ephemeralOwner = 0x0 dataLength = 4 numChildren = 0 [zk: localhost:2181(CONNECTED) 36] getAcl /wusp 'world,'anyone : cdwa [zk: localhost:2181(CONNECTED) 37] getAcl /wusp/child 'world,'anyone : cdrwa write权限 #移除write权限 [zk: localhost:2181(CONNECTED) 38] setAcl /wusp world:anyone:cdra cZxid = 0x4 ctime = Sun May 14 17:33:09 CST 2023 mZxid = 0x5 mtime = Sun May 14 17:52:57 CST 2023 pZxid = 0x3b cversion = 3 dataVersion = 1 aclVersion = 6 ephemeralOwner = 0x0 dataLength = 8 numChildren = 1 #修改/wusp的data属性，提示权限不足 [zk: localhost:2181(CONNECTED) 39] set /wusp data1 Authentication is not valid : /wusp #成功修改/wusp/child的data属性】 [zk: localhost:2181(CONNECTED) 40] set /wusp/child data2 cZxid = 0x3b ctime = Wed May 17 21:13:06 CST 2023 mZxid = 0x3f mtime = Wed May 17 21:20:37 CST 2023 pZxid = 0x3b cversion = 0 dataVersion = 1 aclVersion = 0 ephemeralOwner = 0x0 dataLength = 5 numChildren = 0 admin #移除admin权限 [zk: localhost:2181(CONNECTED) 41] setAcl /wusp world:anyone:cdrw cZxid = 0x4 ctime = Sun May 14 17:33:09 CST 2023 mZxid = 0x5 mtime = Sun May 14 17:52:57 CST 2023 pZxid = 0x3b cversion = 3 dataVersion = 1 aclVersion = 7 ephemeralOwner = 0x0 dataLength = 8 numChildren = 1 #修改acl权限时，提示权限不足。 #这里有个问题，admin权限移除后，怎么添加上?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/20a8eed8676d8864066121d7ea59f3b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2a0349cf05b9040fa862c0e2329b03c/" rel="bookmark">
			VSCode进行Lua调试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.安装EmmyLua 2.添加配置 3.开始调试 要选择要调试的进程就可以了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18c3e30557da19ad3cdde8c5bc65f1f7/" rel="bookmark">
			Altium Designer导出STEP 3D出现“Failed to export”问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题： AD Altium Designer 导出STEP 3D出现“Failed to export”
在尝试了18版本，20版本，17版本后均出现此报错无法导出，导出命名，路径均更换过都出现此问题。
找出问题： 我尝试删除含有3D的元器件，当删除到一个排插座后可以正常导出了
问题出在这个排插座 ，这个排插座3D在PCB上是正常显示的
但是找到此插座的PCB封装库的3D元件体出现0.5mm 20p ffc ?字样，猜测可能是3D元件体出现中文字样导致出现乱码
查看3D SETP，果然是中文的问题
将中文删除重新导入后3D元件体到PCB库后，注意需要重新更新PCB库
更新后才会不报错，如果只是单纯修改PCB封装库导出还是会报错，这个需要注意
总结： AD中导入3D元器件不要使用含有中文名称的文件，尽量使用数字+英文
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97df4d4c021e3bff673171777b8032c9/" rel="bookmark">
			原生js实现大屏数字上下滚动效果，支持随机多位数字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一文看懂大屏数字滚动 前言一、html二、js生成展示的元素三、css实现样式四、加入动画和定时器 前言 在大屏项目中经常需要实现那种数字上下滚动的效果，普通的数字随机滚动在UI组件（例如View Design中）里，或者是countUp插件中都可以找到。
一、html html部分只定义一个简单的容器，几个数字是靠js实现的，有更大的灵活性。
&lt;div class="container"&gt;&lt;/div&gt; 二、js生成展示的元素 注：本段代码是以原生js实现，若项目需要，可以自行转为Jquery形式或者Vue中的v-for生成
var computeNumber = []; // 根据实际情况确定几位数 var digitNum = 5; setComputeNum(getRandomNumber()); // 生成0-99999随机数 function getRandomNumber () { return Math.floor(Math.random() * Math.pow(10,digitNum)); }; function setComputeNum(num) { num = num.toString() if (num.length &lt; digitNum) { // 如未满5位数，在前面补位"0" num = '0' + num; setComputeNum(num); } else if (num.length === digitNum) { computeNumber = num.split(''); } } for(let i = 0; i&lt;computeNumber.length; i++){ // 创建span节点 var spanParent = document.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/97df4d4c021e3bff673171777b8032c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f78677aec928312c4983901421bad4f/" rel="bookmark">
			web端实现远程桌面连接（noVnc）相关知识记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原理
浏览器不支持VNC，所以不能直接连接VNC，但是可以使用代理，使用noVNC（noVNC是一个 HTML5 VNC 客户端）通过WebSocket建立连接，而VNC Server不支持WebSocket，所以需要开启Websockify代理来做WebSocket和TCP Socket之间的转换。当浏览器访问时，会通过网络加载运行noVNC。
关于通信
VNC是基于TCP的通信，VNC server处理的始终是TCP的流，而浏览器和noVNC之间是在http基础上使用WebSocket交互，VNC server是无法处理WebSocket的流，所以引入了 websockify ，负责把WebSocket流转换为普通的TCP流，使VNC server正常工作。
传输原理
将远程计算机的桌面图像编码为Web图像格式，然后通过WebSockets或XHR（XMLHttpRequest）将图像数据传输到客户端浏览器。客户端浏览器将图像数据解码并显示在屏幕上，同时将用户的输入事件传输回远程计算机。noVNC支持多种加密和身份验证方法，以确保安全性。
执行命令
node D:\VNC\node_modules\websockify-js\websockify\websockify.js --web// 执行websockify.js并且启动一个websocket服务器 D:\VNC\node_modules\noVNC //找到对应入口文件，加载该目录下资源，运行noVNC 8000 // 启动服务端口为8000 localhost:5900 // 转发的VNC地址和端口 关键代码
websockify.js fs.exists(filename, function(exists) { if(!exists) { return http_error(response, 404, "404 Not Found"); } if (fs.statSync(filename).isDirectory()) { // filename += '/index.html'; filename += '/vnc.html'; } fs.readFile(filename, "binary", function(err, file) { if(err) { return http_error(response, 500, err); } var headers = {}; var contentType = mime.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f78677aec928312c4983901421bad4f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/138809f7daa57c7c2dab142835e654ca/" rel="bookmark">
			使用malloc
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 如果我在我的代码中使用malloc ：
int *x = malloc(sizeof(int)); new.c:7: warning: implicit declaration of function ‘malloc’ new.c:7: warning: incompatible implicit declaration of built-in function ‘malloc’ 需要添加：
#include &lt;stdlib.h&gt; 该文件包括内置函数malloc的声明。 如果你不这样做，编译器会认为你想定义你自己的名为malloc的函数，它会警告你，因为：
你没有明确声明它和已经有一个内置函数，该名称具有与隐式声明的不同的签名（当一个函数被隐式声明时，它的返回和参数类型被假定为int ，这与内置的不兼容-in malloc ，它需要一个size_t并返回一个void* ）。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4b7b59c23bd4e0e9a3c1c2e9ecc4326/" rel="bookmark">
			品牌机和组装机对比？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		两者区别：
1、品牌电脑兼容性要比普通电脑好一些
2、品牌电脑价格要比组装电脑高一些，因为品牌电脑是通过一系列流水线才能到顾客手里，包括车间组装、广告、运输、门店销售、专门的售后等配套服务。
3、品牌电脑的可扩展性不如组装电脑，一般的品牌都是订制好的，比如机箱，主板都是自己设计的，功能相对来说已经定死了，如果想加入扩展卡，或者其他一些主机没有的接口，就必须要找售后。组装机可以随时更换某一款机箱内部配件，或者扩展接口。
4、品牌电脑的稳定性要高于组装机。因为品牌机都是经过稳定和兼容性测试的，品质有保证。组装机是根据自己的需求，按需搭配的，兼容性就会差些，有些时候电脑新手搭配的电脑还会出现硬件不合的问题。
如果是游戏发烧友，或者是运行比较大型的软件的人群，建议选择组装机，找一家电脑店把你的需求说给工作人员，让工作人员给你搭配，一般来说只要硬件搭配合理，组装机的稳定也是非常高的，而且有电脑店给你承担售后服务，也不必担心。如果是政府企业单位的，建议选择原装机，原装机更加稳定，保证你的工作、资料文件不会被损坏，而且大品牌的售后服务有保障。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/138/">«</a>
	<span class="pagination__item pagination__item--current">139/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/140/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>