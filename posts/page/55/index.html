<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ad66aa9ecc54f71c35dd4f448edb848/" rel="bookmark">
			找出100天内没有套牢盘的股票
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		可以用两种函数实现选股公式
1 REF 合HHV
ZG:=REF(HHV(H,99),1);{求出不含今天的前99天的最高价格}
H&gt;=ZG;{和今天的最高价比较};
2 用HHVBARS 函数实现
百天最高价:=HHVBARS(H,100);{包含今天100天内最高价，距离今天的天数}
百天最高价=0;{等于0说明今天就是100天内的最高假价};
附图指标公式的实现
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/622d72c169962843ff49d89271f0c71e/" rel="bookmark">
			抖音短视频拓客引流神技能，抖音小圆码一键跳转到微信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		抖音小圆码一键跳转到微信。拓客引流神技能 抖音官方二维码跳转微信！
防检测 防违规！ 该二维码可以应用到任何场景！
比如：
短视频可以发
直播间可以展示
私信可以发
粉丝群可以发
企业号自动回复可以放
官网主页也能放
甚至是小风车组件也能过审
就连你的头像都可以放
能跳转到：微信/QQ/小程序/网站/以及任何平台
使用期限：按月，或者长期
搭建步骤：
1.给我要跳转的二维码或者要跳转的小程序，反正要跳转什么就给我什么
2.给我一张圆码中间的图片 定制抖音小圆码，不管你是什么行业的，只要你通过抖音获客，就可以试用这种方式，放违规，可以通过视频的方式把这个码置顶到你的作品列表，让准客源添加你的微信。
需要制作这个码的朋友可以通过十八掌商城联系我
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9084a61efa64690852a216ca3d29faa/" rel="bookmark">
			leetcode 41. 缺失的第一个正数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录：原题链接
暴力排序
桶排序
桶排序+Set
桶排序+分治思想
官方题解
桶排序+数组内标记
桶排序+额外数组标记（更好理解）
给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。
请你实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案。
示例 1：
输入：nums = [1,2,0] 输出：3 示例 2：
输入：nums = [3,4,-1,1] 输出：2 示例 3：
输入：nums = [7,8,9,11,12] 输出：1 提示：
1 &lt;= nums.length &lt;= 5 * 10^5-2^31 &lt;= nums[i] &lt;= 2^31 - 1 暴力排序 先不考虑题目要求的时间、空间复杂度，先简单暴力的做出来结果，给自己一点信心，有时候想要按照题目要求直接做出最终结果太难，先有一个能用的方案也有助于打开后续的思路。
先来暴力排序法：
对输入数据过滤后排序，遍历一遍排序后的数组，就可以找到最小的正整数 // 给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。 class Solution { func firstMissingPositive(_ nums: [Int]) -&gt; Int { // 先把不合规的 负数和0 去除 let nums = nums.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b9084a61efa64690852a216ca3d29faa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2694f91716c06f0b1c425d8b2726cba6/" rel="bookmark">
			持续集成部署-k8s-高级调度-CronJob：定时任务的应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		高级调度-CronJob：定时任务的应用 1. 简介2. Linux 上的 CronJob 定时任务3. 创建 K8s 的 CronJob4. 删除 k8s 的 CronJob 1. 简介 在 Kubernetes 中，CronJob 是一种用于创建定时任务的资源对象。它允许我们在集群中预定和运行定期的作业，类似于 Linux 系统中的 cron 任务。
使用 CronJob 资源可以很容易地在 Kubernetes 上创建定时任务，无需依赖外部工具或服务。以下是 CronJob 的一些主要特点和应用：
定时调度：CronJob 允许您基于 Cron 表达式来定义任务的调度规则，比如每天凌晨执行、每个星期五执行等。
作业管理：CronJob 创建的任务会生成对应的 Job 资源，并在指定的时间执行任务。如果任务成功完成，则 Job 会被标记为完成；如果任务失败，则 Job 会保留失败的状态，并且根据配置的重试策略进行重试。
并行处理：CronJob 允许您配置并发性，即同时执行的任务数量。这可以帮助您控制资源的使用情况，避免过多的任务同时运行导致资源耗尽。
灵活的配置：CronJob 支持很多配置选项，例如定义任务的容器镜像、环境变量、命令参数等，使得定时任务的执行更加灵活。
2. Linux 上的 CronJob 定时任务 在 Linux 上，CronJob 是一种用于定时执行任务的工具，它可以让您在指定的时间间隔内运行命令或脚本。
Cron 表达式：
# ┌───────────── 分钟 (0 - 59) # │ ┌───────────── 小时 (0 - 23) # │ │ ┌───────────── 月的某天 (1 - 31) # │ │ │ ┌───────────── 月份 (1 - 12) # │ │ │ │ ┌───────────── 周的某天 (0 - 6)（周日到周一；在某些系统上，7 也是星期日） # │ │ │ │ │ 或者是 sun，mon，tue，web，thu，fri，sat # │ │ │ │ │ # │ │ │ │ │ # * * * * * 下面是在 Linux 上使用 CronJob 的一般步骤：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2694f91716c06f0b1c425d8b2726cba6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ad00154b0e92c9d1d6c4d2d56f27d20/" rel="bookmark">
			持续集成部署-k8s-配置与存储-存储类：动态创建NFS-PV案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		动态创建NFS-PV案例 1. 前置条件2. StorageClass 存储类的概念和使用3. RBAC 配置4. storageClass 配置5. 创建应用，测试 PVC 的自动配置6. 解决 PVC 为 Pending 状态问题7. 单独测试自动创建 PVC 1. 前置条件 这里使用 NFS 存储的方式，来演示动态创建 PV 的案例。
前置条件是需要在 K8s 集群中安装 NFS 的环境，安装可参考：持续集成部署-k8s-数据持久化-NFS安装与使用
确保 NFS 服务器正常可用之后，接着后续的步骤操作。
验证配置是否生效：
在当前nfs-server 上查看： [root@docker-54 nfs]# showmount --export Export list for docker-54: /home/nfs/ro 192.168.104.0/24 /home/nfs/rw 192.168.104.0/24 [root@docker-54 nfs]# 在 nfs-client 上查看： [root@docker-55 ~]# showmount -e master Export list for master: /home/nfs/ro 192.168.104.0/24 /home/nfs/rw 192.168.104.0/24 [root@docker-55 ~]# [root@docker-56 ~]# showmount -e master Export list for master: /home/nfs/ro 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ad00154b0e92c9d1d6c4d2d56f27d20/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0e3b6c045af031079f7ac49a840d20b/" rel="bookmark">
			使用JAVA备份指定数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		想在网页里点击按钮，实现数据库的备份。纯java代码实现
import java.io.BufferedWriter; import java.io.FileWriter; import java.io.IOException; import java.sql.*; import java.util.ArrayList; public class DatabaseBackup { public static void backup(String url, String username, String password, String backupFilePath) { try { // 建立数据库连接 Connection con = DriverManager.getConnection(url, username, password); // 创建Statement对象，用于执行SQL查询 Statement stmt = con.createStatement(); // 查询所有表的表名 ResultSet rsTables = stmt.executeQuery("SHOW TABLES"); // 创建备份文件 BufferedWriter writer = new BufferedWriter(new FileWriter(backupFilePath)); ArrayList&lt;String&gt; tableNames = new ArrayList&lt;&gt;(); while (rsTables.next()) { String tableName = rsTables.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a0e3b6c045af031079f7ac49a840d20b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0fe4558c868030988f4b50461282eadf/" rel="bookmark">
			案例030:基于微信小程序的英语学习交流平台
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文末获取源码
开发语言：Java
框架：SSM
JDK版本：JDK1.8
数据库：mysql 5.7
开发软件：eclipse/myeclipse/idea
Maven包：Maven3.5.4
小程序框架：uniapp
小程序开发软件：HBuilder X
小程序运行软件：微信开发者
目录
前言
系统展示
管理员模块的实现
用户信息管理
每日打卡管理
学习资源管理
小程序会员模块的实现
系统首页
我的菜单
学习资源详情
代码实现
登录功能实现代码
注册功能实现代码
密码重置功能实现代码
修改信息功能实现代码
删除信息功能实现代码
保存信息功能实现代码
前言 随着信息技术在管理上越来越深入而广泛的应用，管理信息系统的实施在技术上已逐步成熟。本文介绍了英语学习交流平台小程序的开发全过程。通过分析英语学习交流平台小程序管理的不足，创建了一个计算机管理英语学习交流平台小程序的方案。文章介绍了英语学习交流平台小程序的系统分析部分，包括可行性分析等，系统设计部分主要介绍了系统功能设计和数据库设计。
本英语学习交流平台小程序有管理员和用户两个角色。管理员功能有，个人中心，用户管理，每日打卡管理，备忘录管理，学习计划管理，学习资源管理，论坛交流，系统管理等。用户功能有个人中心，每日打卡，备忘录，学习计划，学习资源，我的收藏，论坛交流等。因而具有一定的实用性。
本站后台采用Java的SSM框架进行后台管理开发，可以在浏览器上登录进行后台数据方面的管理，MySQL作为本地数据库，微信小程序用到了微信开发者工具，充分保证系统的稳定性。系统具有界面清晰、操作简单，功能齐全的特点，使得英语学习交流平台小程序管理工作系统化、规范化。
系统展示 管理员模块的实现 用户信息管理 管理员可以管理用户信息，可以对用户信息添加修改删除。
每日打卡管理 管理员可以对每日打卡进行查询修改，删除操作。
学习资源管理 系统管理员可以对学习资源进行增删改查操作。
小程序会员模块的实现 系统首页 小程序用户是需要注册才可以进行登录的，登录后在首页可以查看学习资源，并且下面导航可以点击到其他功能模块。
我的菜单 在小程序里点击我的，会出现关于我的界面，在这里可以修改个人信息，以及可以点击其他功能模块。 学习资源详情 点击学习资源详情界面，可以对学习资源收藏操作。
代码实现 登录功能实现代码 @IgnoreAuth @PostMapping(value = "/login") public R login(String username, String password, String captcha, HttpServletRequest request) { UserEntity user = userService.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0fe4558c868030988f4b50461282eadf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9b7948f6cb5d74dc136a0466828cb70/" rel="bookmark">
			【LabVIEW学习】3.labview制作安装程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一。生成exe文件
1.创建可执行文件
（1）创建项目
注意：
1.创建.exe文件，这个文件在labview环境下才可以运行，如果直接传递给其他电脑（没有labview环境），他是不可以运行的。
2.如果已经生成项目文件，那么不能重新生成。如果没有生成项目，生成之后结果为：
（2）生成exe文件
（3）填写程序的信息，包括图标名称（下面2.为详细介绍）
（4）结果
2.填写生成exe文件信息
（1）信息设置
（2）源文件
由于我们以后可能有许多vi文件，所以要选一个主（main）文件
（3）图标
（4）点击生成
其余自己琢磨即可，用处不大。
二。生成可执行文件
1.点击安装程序
2.信息设置
3.源文件的添加
4.点击生成
5.生成结果：这样就可以发给别人使用了
注意：
这个安装程序有些大，可以缩小的，以后学习到在添加缩小安装程序方式。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2db1100c3ee6494e0980e960273e8f92/" rel="bookmark">
			使用@Transactional事务注解时，需要指定rollbackFor或者在方法中显式的rollback——编程规范 及 修改办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、推荐编程规范插件
1.idea引入插件
二、使用@Transactional事务注解时，需要指定rollbackFor或者在方法中显式的rollback 解决方法
一、推荐编程规范插件 1.idea引入插件 引用之后重启即可
二、使用@Transactional事务注解时，需要指定rollbackFor或者在方法中显式的rollback 解决方法 我们只需要在方法名上声明事务并设置回滚
抛出异常之后，我们自习写一个try catch捕获，在这里我用了一个自定义异常类来处理异常
即可解决问题
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14ba390a4c3d826c0876e28d157ea54e/" rel="bookmark">
			基于arco-design组件库vue3 ProTable、TableList组件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		组件都是用 TypeScript 编写的、通过eslint、mock数据模拟真实操作 git链接: https://github.com/licailing/arco-pro
码云链接：https://gitee.com/li-cailing/arco-pro
预览地址: http://139.159.191.219:3000/
pro-table 组件库 git地址:https://github.com/licailing/arco-vue-pro-components
码云地址:https://gitee.com/li-cailing/arco-vue-pro-components
预览地址: http://139.159.191.219:6006/?path=/story/pro-table–lightfilter-demo
安装acro-vue-pro-components组件库 npm install --save @acro-vue-pro-components/pro-components 运行arco-pro后台管理系统 npm install npm run dev TableList是基于ProTable高度封装的组件 高级筛选-收起 高级筛选-展开 普通筛选-展开 普通筛选-收起 自定义表单部分 搜素表单-表格-编辑弹框全部自定义 搜素表单-表格-编辑弹框全部自定义 ProTable默认表单 高级筛选及普通筛选代码实现 &lt;template&gt; &lt;div class="container"&gt; &lt;Breadcrumb :items="['menu.list', 'menu.list.searchTable']" /&gt; &lt;a-card title="高级查询"&gt; &lt;TableList :cache="true" search-type="light" :light-search-config="lightSearchConfig" :columns="columns" url="/api/list/policy" :buttons="buttons" :row-selection="rowSelection" :pagination="pagination" :option-width="260" &gt; &lt;template #contentType="{ record }"&gt; &lt;a-space&gt; &lt;a-avatar v-if="record.contentType === 'img'" :size="16" shape="square" &gt; &lt;img alt="avatar" src="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/14ba390a4c3d826c0876e28d157ea54e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb5514fea4e131b02c607c6d05b278d2/" rel="bookmark">
			Docker搭建个人网盘NextCloud并接入雨云对象存储的教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		雨云服务器使用Docker搭建私有云盘NextCloud并接入雨云对象存储ROS的教程。
NextCloud简介 NextCloud由原ownCloud联合创始人Frank Karlitschek创建的，继承原ownCloud的核心技术又有不少的创新。在功能上NextCloud和ownCloud差不多，甚至还要丰富一些，在用户使用体验方面，NextCloud安装与使用都非常地顺手，最重要的是NextCloud完全开源免费。
NextCloud不仅是一个私人云网盘平台，也支持多用户同步协作使用。NextCloud支持账号注册，可以为账号开启两步验证，以确保账号安全。同时，NextCloud对于公开分享的文件可以设置有效期，对于上传的视频、音乐、Office文档等直接支持在线预览和播放。
NextCloud还提供了上百种的免费应用和插件，这些NextCloud应用与插件可以将NextCloud打造成为一个在线文档共享与编辑平台、音乐与视频娱乐平台以及文件存储下载平台。当然，如果是自己手动安装的NextCloud的话，那么这些插件也得自己配置好环境才行。
NextCloud服务端开源地址：https://github.com/nextcloud/server
Docker版开源地址：https://github.com/nextcloud/all-in-one
准备 首先需要一台云服务器和一个域名，服务器要有公网IP，推荐雨云的：
雨云优惠注册地址：https://www.rainyun.com/zeruns_?s=csdn
优惠码：zeruns
使用优惠码注册后绑定微信可获得5折优惠券
雨云账号注册&amp;云服务器购买和使用教程：https://www.bilibili.com/video/BV1Kj411x7G6/
注册完账号后进到雨云控制台，云服务器入口可以在后台的 总览 和 云产品 部分找到：
点击购买云服务器，接着选择服务器区域，如果你域名已备案建议选择宿迁或十堰的，如果你域名没有备案就选择香港或美国，我这里选择香港。
配置选择2核2G一般够用了。
系统选择Debian12，预安装APP选择Docker环境（选了这个可以跳过下面安装Docker的步奏）。如果所选区域没有Debian12就选择Debian11，如果没有预安装Docker就需要执行下面教程安装Docker那步。
都选好后就可以点击立即购买了，也可以选择1元试用1天。
购买后即可在我的云服务器这里看到你买的云服务器，点击管理。
接着就可以看到云服务器的信息了，在这里重装/切换系统，可以升级配置。
等待服务器创建完成以及预安装APP安装完成。
连接服务器 下载安装并打开ssh客户端软件，ssh客户端软件推荐putty或mobaxterm。
我这里用mobaxterm，在SSH客户端中输入你的服务器的IP地址（雨云控制台获取），还有SSH端口（一般默认是22），然后点击好的或者打开。
然后输入账号并按回车，账号一般默认为root，接着输入密码并按回车确定，输入密码时不会显示出来。
温馨提示：在SSH终端中按住鼠标左键选择文字，然后松开鼠标，再在空白处单击一下，这样就把选中的文字复制了；在SSH终端单击右键即为粘贴。
安装Docker 如果选择了预安装Docker环境就直接跳过安装这一步，直接Docker换国内源那一步。
在ssh终端，输入下面的指令。
用apt包管理器来安装：
# 安装docker，如果遇到问是否继续的就输入y来确定 apt install docker.io # 设置docker开机自启和启动docker systemctl enable docker &amp;&amp; systemctl start docker # 检查是否安装成功，若安装成功会显示 Docker version x.x.x docker -v 若没安装成功就试试下面的安装脚本：
# 安装docker curl -sSL https://get.daocloud.io/docker | sh # 设置docker开机自启和启动docker systemctl enable docker &amp;&amp; systemctl start docker # 检查是否安装成功，若安装成功会显示 Docker version x.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb5514fea4e131b02c607c6d05b278d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d004c17604a414c1a9736bdb19addfe2/" rel="bookmark">
			绘制一个三角形，并制作移动动画（OPenGL&#43;C&#43;&#43;）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		A.1从顶点构建对象（绘制一个三角形） 我们想要绘制的不仅仅是一个单独的点，而是由很多顶点组成的对象。现在让我们先用三个顶点来绘制一个三角形。
如何绘制呢？ 修改顶点着色器，以便让3个不同的点输出到后续的管线阶段
修改glDrawArrays()，指定绘制的图形为三角形
代码实现： 1.修改vertShader.glsl文件 //vertShader.glsl文件 #version 430 void main(void) { if(gl_VertexID == 0)//内置变量 gl_Position = vec4(0.25, -0.25, 0.0, 1.0); else if(gl_VertexID == 1) gl_Position = vec4(-0.25, -0.25, 0.0, 1.0); else gl_Position = vec4(0.25, 0.25, 0.0, 1.0); } 2.修改fragShader.glsl文件 //fragShader.glsl文件 #version 430 out vec4 color; void main(void) { color = vec4(1.0, 0.0, 0.0, 1.0); } 3.修改.cpp文件 //Display函数修改 //glPointSize(430.0f);//设置点的大小 glDrawArrays(GL_TRIANGLES, 0, 3); 4.运行结果输出 5.cpp完整代码 #include &lt;GL/glew.h&gt; #include &lt;GLFW/glfw3.h&gt; #include &lt;iostream&gt; #include &lt;fstream&gt; #include &lt;string&gt; #define numVAOs 1 unsigned int renderingProgram; unsigned int vao[numVAOs];//顶点数组，必须要有 unsigned int CreateShaderProgram(); //读取文件中的GLSL的源代码 std::string ReadShaderSource(const char* filePath) { std::string content; std::ifstream fileStream(filePath, std::ios::in); std::string line = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d004c17604a414c1a9736bdb19addfe2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d79dc926e73af90d1a0a5379b9d1058a/" rel="bookmark">
			通达信视频教程的下载地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		百度网盘 请输入提取码百度网盘为您提供文件的网络备份、同步和分享服务。空间大、速度快、安全稳固，支持教育网加速，支持手机端。注册使用百度网盘即可享受免费存储空间https://pan.baidu.com/s/12yNV62ROERRzmyqm9u22aQ?pwd=gmdx
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d68f7b4c29e6e161d8f4905491c447d8/" rel="bookmark">
			用公式π/2=2/1*2/3*4/3*4/5... 前100项之积计算并打印π值。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 #include &lt;stdio.h&gt; int main() { double pi = 1.0; int i = 0; for (i = 1; i &lt;= 100; i++) { pi *= 2.0 * i / (2.0 * i - 1) * 2.0 * i / (2.0 * i + 1); } pi *= 2; printf("%lf\n", pi); return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dedaec6891aa4b6d488fdc08ccc54b59/" rel="bookmark">
			python的Re模块学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文初步介绍 正则表达式的定义，分类的组成部分。并举例编码
一、什么是正则表达式 答：在unix系统中，用来表示规则的字符串。在开发语言中需要处理大量的字符串，引入了这个规则。
字符串的处理：
1. 过滤字符串，在字符串中获取需要的部分
2. 验证字符的输入是否符合规范， 例如用户名，密码的验证
3. 切割字符串， 划分字符内容
4. 替换字符串， 替换文本内容的信息。
二、正则表达式的分类 目前产雇佣的两大正则系统： POSIX系统， Pcre系统。
开发语言 Perl --&gt; Pcre
C --&gt; POSIX
PHP --&gt; POSIX, Pcre
Python --&gt; Pcre
三、正则表达式的内容 可以划分为三个部分，原子，元字符和模式修正符。
原子：是正则表达式的最小单元。所有的字符都是原子。 包括可见字符： 1-9，a-z，&amp;*等。
不可见字符： \n， \r , \v ， \t, \f等
元字符： 原子修饰符。 修饰原子。 可以划分为， 整体修饰，数量修饰，位置修饰和特殊修饰(转义，词边界等)。
模式修正符： 对正则表达式进行一些额外的匹配规则 。
3.1、 原子 原子：正则表达式的最小单元。所有的字符都是原子。 包括可见字符： 1-9，a-z，&amp;*等。
不可见字符： \n， \r , \v ， \t, \f等。
需要学习的是有 7个专用的转义字符：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dedaec6891aa4b6d488fdc08ccc54b59/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a94a0610eba3969879fd9edeb28db4c/" rel="bookmark">
			记一次Kotlin Visibility Modifiers引发的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 测试环境爆出ERROR告警日志java.lang.IllegalStateException: Didn't find report for specified language，登录测试环境ELK查到如下具体的报错堆栈日志：
java.lang.IllegalStateException: Didn't find report for specified language at com.aba.report.service.biz.AssessmentReportService.getReportDTOByLanguage(AssessmentReportService.kt:116) at com.aba.report.service.biz.AssessmentReportService.getAssessmentReport(AssessmentReportService.kt:60) at com.aba.report.provider.biz.ReportBiz.getAssessmentResultTesting(ReportBiz.java:211) at com.aba.report.provider.biz.ReportBiz.syncReportDataToXuhui(ReportBiz.java:171) at com.aba.report.provider.controller.ReportController.lambda$saveReport$0(ReportController.java:143) at org.apache.skywalking.apm.toolkit.trace.SupplierWrapper.get$original$K9vf71bp(SupplierWrapper.java:37) at org.apache.skywalking.apm.toolkit.trace.SupplierWrapper.get$original$K9vf71bp$accessor$gH2x29d6(SupplierWrapper.java) at org.apache.skywalking.apm.toolkit.trace.SupplierWrapper$auxiliary$KujBxtqH.call(Unknown Source) at org.apache.skywalking.apm.agent.core.plugin.interceptor.enhance.InstMethodsInter.intercept(InstMethodsInter.java:86) at org.apache.skywalking.apm.toolkit.trace.SupplierWrapper.get(SupplierWrapper.java) at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.run(CompletableFuture.java:1700) at java.base/java.lang.Thread.run(Thread.java:834) 排查 这个报错就显得很是莫名其妙，没有一点点熟悉的感觉，像NPE、数组越界啥的。只能去看源码：
private fun getReportDTOByLanguage(assessmentReport: AssessmentReport): TranslatedAssessmentReportDTO { val language = assessmentReport.language val creationDate = assessmentReport.creationDate val translatedAssessmentReportDTO = assessmentReport.translatedReports[Locale.CHINA.toLanguageTag()] ?: assessmentReport.translatedReports[language] ?: throw IllegalStateException("Didn't find report for specified language"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a94a0610eba3969879fd9edeb28db4c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ce13990b873df284ba77735209c79d6/" rel="bookmark">
			maven中scope和optional区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. Scope（作用范围）：2. Optional（可选项）： 1. Scope（作用范围）： Maven的&lt;scope&gt;元素用于指定依赖项的作用范围，即依赖项在构建和运行时的可见性和可用性。以下是常见的 &lt;scope&gt; 值： 1、compile：默认值，依赖项在编译、测试和运行时都可用。
2、provided：依赖项在编译和测试时可用，但在运行时由目标环境提供（例如，Servlet API由Servlet容器提供）。
3、runtime：依赖项在测试和运行时可用，但不在编译时。
4、test：依赖项仅在测试时可用，不会包含在运行时类路径中。
5、system：类似于 provided，但需要显式提供路径。
6、import：只在 &lt;dependencyManagement&gt; 中使用，表示导入依赖的管理信息而不实际引入依赖。
&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;example-artifact&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 上述例子中，example-artifact 在编译、测试和运行时都可用。 2. Optional（可选项）： Maven的&lt;optional&gt;元素用于标记依赖项是否是可选的。可选依赖项默认情况下不会传递给项目的依赖方。如果一个项目A依赖于项目B，而项目B的某个依赖项被标记为可选，那么项目A并不会自动获取项目B的可选依赖项。如： &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;example-artifact&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 上述例子中，example-artifact 被标记为可选依赖项。如果项目A依赖于项目B，并且项目B的这个依赖项被标记为可选，那么项目A将不会自动获取这个可选依赖项。
总结：&lt;scope&gt; 用于定义依赖项的可见性和可用性，而 &lt;optional&gt; 用于标记依赖项是否是可选的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4ade7576a4af94542018f8795a78be7/" rel="bookmark">
			Intellij IDEA--同一项目启动多个实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文网址：Intellij IDEA--同一项目启动多个实例_IT利刃出鞘的博客-CSDN博客
简介 本文介绍Idea如何同一个服务启动多个实例。
新版Idea(2022及之后) 适合版本
2022.X及之后
方法
Run=&gt; Edit Configurations=&gt; 选中项目=&gt; “Build and run”栏=&gt; Modify Options=&gt; 选中“Allow multiple instances”
旧版Idea(2022.X之前) 适合版本
2022.X之前（不包括2022.X）
方法
Run=&gt; Edit Configurations=&gt; 选中项目=&gt; 选中“Allow parallel run”=&gt; 运行项目=&gt; 再次运行 此时有两个实例运行
如下图所示：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5177deb4c359fe5dc4abc7f1b270a9e/" rel="bookmark">
			转成String类型的几种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. String.valueOf()2. 包装类-toString()3. 使用字符串拼接4. 强制类型转换 (String) object5. 总结：6. 基本数据类型和包装类 1. String.valueOf() String.valueOf()：基本数据类型或包装类都可以通过 String.valueOf() 方法转为字符串表示形式，如： int i = 22; String stringValue = String.valueOf(i); System.out.println("String value: " + stringValue); 基本数据类型转成字符串表示形式时，可以使用String.valueOf(xx)，但不能直接使用 xx.toString()方法（基本数据类型不具备方法和属性)，也不能通过(String)进行强制类型转化
String.valueOf(Object) 是在 Object.toString() 的基础上实现的，源码：
public static String valueOf(Object obj) { return (obj == null) ? "null" : obj.toString(); } 与 Object.toString() 方法的不同点在于，String.valueOf(Object) 不用担心对象是否为 null 这一问题，可以安全地处理 null 对象 2. 包装类-toString() Integer i = 22; System.out.println("String value: " + i.toString()); 可以使用对应包装类的toString()方法，比如使用Integer.toString(int i)方法注意：当使用 object.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5177deb4c359fe5dc4abc7f1b270a9e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/041d21760b71e7c93dc2515d02110a05/" rel="bookmark">
			如何使用Python进行桌面应用开发？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用 Python 进行桌面应用开发时，可以使用多种 GUI 工具包，其中最常用且流行的是 Tkinter、PyQt 和 wxPython。这些工具包都提供了丰富的组件和函数，方便创建用户界面，并与用户交互。
下面是使用 Tkinter 创建简单桌面应用的步骤：
安装 Tkinter：确保 Python 已经安装在你的系统中。对于大多数 Python 发行版本来说，Tkinter 是内置的，无需额外安装。如果你的 Python 中没有安装 Tkinter，可以使用命令 pip install tkinter 来安装。
导入 Tkinter 模块：在 Python 脚本中导入 Tkinter 模块，以便使用其中定义的类和函数。
创建一个主窗口：使用 Tkinter 的 Tk() 类创建一个主窗口对象。
添加各种组件：使用 Tkinter 提供的各种组件类（例如 Label、Button、Entry 等）来构建用户界面。
定义事件处理函数：为用户界面上的组件添加事件处理函数，即用户与界面交互时所触发的操作。
运行主消息循环：调用主窗口对象的 mainloop() 方法来启动应用的主消息循环，该循环等待用户的输入并响应相应的事件。
下面是一个简单的使用 Tkinter 创建的桌面应用的示例：
import tkinter as tk def on_button_click(): entered_text = entry.get() label.config(text="Hello, " + entered_text) root = tk.Tk() label = tk.Label(root, text="Enter your name:"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/041d21760b71e7c93dc2515d02110a05/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56799e87b949ff7758bc8cbd2116f7fb/" rel="bookmark">
			Error:java: Annotation processing is not supported for module cycles.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个错误提示意味着在你的项目中存在模块间的循环依赖，导致注解处理无法正常进行。
参考方法： 检查项目的模块依赖关系：确认项目中的模块是否存在循环依赖。如果是，则需要调整模块之间的依赖关系，解除循环依赖。
排除循环依赖的模块：在项目的构建配置文件中，针对循环依赖的模块，添加排除规则，使其在进行注解处理时被排除。具体操作取决于你使用的构建工具（如 Maven 或 Gradle）以及相应的配置文件。
使用不同的编译选项：尝试更改编译器的选项，禁用注解处理或启用增量编译等。具体方法取决于你使用的编译器和构建工具。
拆分模块：如果循环依赖无法避免，考虑将相关功能拆分到不同的模块中，以消除循环依赖。
错误原因 多级了一个依赖，删除就好了。
IDEA的自动修正错误（Alt+Enter）的有关依赖的修改要慎用！
IDEA的自动修正错误（Alt+Enter）的有关依赖的修改要慎用！
IDEA的自动修正错误（Alt+Enter）的有关依赖的修改要慎用！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9296089488ce4c90532e0efdd108a7f2/" rel="bookmark">
			【古月居《ros入门21讲》学习笔记】03_Ubuntu的基本配置&amp;常用命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
说明
1. Ubuntu的基本配置
网络连接
换源
安装Vmware Tools
2. Ubuntu常用命令
cd
pwd
mkdir
ls
touch
mv
cp
rm
su
sudo
说明 本教程使用的 【虚拟机&amp;Linux】 版本如下：
虚拟机LinuxVMware Workstation Pro 16.2.4Ubuntu18.04 1. Ubuntu的基本配置 网络连接 在上方菜单栏里的找到虚拟机里，点击设置，然后选择网络适配器，在网络连接里选桥接模式，勾选复制物理网络连接状态，我们安装的Ubuntu系统就会有网了。
Ubuntu网络图标突然消失的问题的解决方案
基本上网络图标不见了都是Ubuntu的NetworkManager有问题
进入root
sudo su 更新NetworkManager的配置
vim /etc/NetworkManager/NetworkManager.conf 需要修改的配置文件是这样的，将flase改为True就可以了，如果你本身就是True的话，那就不用修改了，改好如下图；
删除原本的配置，并重启服务
service NetworkManager stop rm /var/lib/NetworkManager/NetworkManager.state service NetworkManager start 在完成上述操作后，原本消失的Ubuntu网络图标就会又突然出现了！
最后，建议重启一下Ubuntu，这能解决大多数问题，别问为什么！
当然不一定所有人的解决方法都是这样，如果这个方法解决不了你的问题，可以参考一下其它方法。
换源 我们找到软件与更新（Software Updater）--设置（Settings）--Ubuntu软件（Ubuntu Software）--下载自（Download form）。
然后选择：其它（Other...）往上划，选择中国（china）打开，在这里选择自己想要的源，我选择的是阿里云的，
选好后点击Choose Server，然后会让你输入密码，最后点击Close，至此完成换源。
安装Vmware Tools 方法1：在线安装
虚拟机有网络的情况下，安装Vmware Tools很简单，直接在线安装即可。
更新软件源列表
sudo apt-get update 更新软件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9296089488ce4c90532e0efdd108a7f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/481484800a6215049ffd86099247dcbc/" rel="bookmark">
			Quartz定时任务基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		springBoot有一个定时执行某个方法的 注解：
@Scheduled 可以满足挺多的需求，但是到了一些场景，就显得比较麻烦，比如：
机器待机五分钟后执行切换待机状态。如果是按照使用@Scheduled注解，就得持久化一个表，里面存放机器信息，转换时间，然后@Scheduled一个方法，每隔一定时间扫描全表，查询需要转换的机器。
还有一种有趣的解决办法：
它会定义一个小顶堆，存放需要执行的任务（主要还是存放的该任务的执行时间），
小顶堆结构；
添加任务只需要在最后一个位置加上，然后上浮操作（和父级对比，父级更大就交换，父级小就不动，一直对比，直到父级小不动），所以会发现，每次都是操作父子级，如何快速找到父级，成了最大问题，于是，存储结构选择了数组：
只需要将子集下标/2=取整，就是父级下标。
存入：
也就是说，每次只需要判断顶部数据是否可以执行即可，比上面那种直接扫描全表性能更快。
执行一个任务后，就会刷新顶堆，拿出最后一个。
取出：
package com.quxiao; import java.time.LocalTime; import java.util.Date; import java.util.Timer; import java.util.TimerTask; import java.util.concurrent.ArrayBlockingQueue; import java.util.concurrent.ThreadPoolExecutor; import java.util.concurrent.TimeUnit; /** * @program: springBoot * @author: quxiao * @create: 2023-11-18 11:00 **/ public class t1 { public static void main(String[] args) { Timer timer = new Timer(); for (int i = 0; i &lt; 2; i++) { TimerTask timerTask = new TimerTest1("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/481484800a6215049ffd86099247dcbc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bdb25d8700d62f9bab5ed6b38322cec7/" rel="bookmark">
			【git error|SourceTree】error: bad signature 0x00000000 fatal: index file corrupt
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		报错 error: bad signature 0x00000000
fatal: index file corrupt
场景 在使用git add . 提交代码到缓冲区时或使用SourceTree时电脑宕机，重启后再次提交代码会出现该提示
原因分析 .git目录下的index文件损坏
解决方式 //删除索引文件
rm -f .git/index //回滚到未添加缓冲区的版本
git reset
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a807bcb983c5cb585722f8bfaa5b8480/" rel="bookmark">
			什么是 Node.js？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 Node.js 出现之前，最常见的 JavaScript 运行时环境是浏览器，也叫做 JavaScript 的宿主环境。浏览器为 JavaScript 提供了 DOM API，能够让 JavaScript 操作浏览器环境（JS 环境）。
2009 年初 Node.js 出现了，它是由 Ryan Dahl 基于 Chrome V8 引擎开发的 JavaScript 运行时环境，所以 Node.js 也是 JavaScript 的一种宿主环境。而它的底层就是我们所熟悉的 Chrome 浏览器的 JavaScript 引擎，因此本质上和在 Chrome 浏览器中运行的 JavaScript 并没有什么区别。
但是，Node.js 的运行环境和浏览器的运行环境还是不一样的。
Node.js、V8与Chrome浏览器的关系
因为 Node.js 不是浏览器，所以它不具有浏览器提供的 DOM API，比如 Window 对象、Location 对象、Document 对象、HTMLElement 对象、Cookie 对象等等。但是，Node.js 提供了自己特有的 API，比如全局的 global 对象，也提供了当前进程信息的 Process 对象，操作文件的 fs 模块，以及创建 Web 服务的 http 模块等等。这些 API 能够让我们使用 JavaScript 操作计算机，所以我们可以用 Node.js 平台开发 web 服务器。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a807bcb983c5cb585722f8bfaa5b8480/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c01f937e848c60ae5f603f8827418d4/" rel="bookmark">
			机器学习探索计划——KNN实现Iris鸢尾花分类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 加载数据集2.拆分数据集3.预测4.评价 1. 加载数据集 import numpy as np from sklearn import datasets iris = datasets.load_iris() iris.keys() dict_keys(['data', 'target', 'frame', 'target_names', 'DESCR', 'feature_names', 'filename', 'data_module']) X = iris.data X.shape (150, 4) iris.feature_names ['sepal length (cm)', 'sepal width (cm)', 'petal length (cm)', 'petal width (cm)'] y = iris.target y.shape (150,) iris.target_names array(['setosa', 'versicolor', 'virginica'], dtype='&lt;U10') 2.拆分数据集 shuffle_index = np.random.permutation(len(y)) shuffle_index.shape (150,) train_ratio = 0.8 train_size = int(len(X) * train_ratio) train_size 120 train_index = shuffle_index[ :train_size] test_index = shuffle_index[train_size: ] X_train = X[train_index] y_train = y[train_index] X_test = X[test_index] y_test = y[test_index] X_train.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c01f937e848c60ae5f603f8827418d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5abe2f45e7d0e4c25a729fd1f738236b/" rel="bookmark">
			Optional对象盒子的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		判空的盒子：
public static void main(String[] args) { T2 t2 = new T2(1,"123"); Optional&lt;T2&gt; optional = Optional.ofNullable(t2); System.out.println(optional.isPresent()); } 优雅的判断对象是否为空，直接使用xx==null虽然很明显，感觉还是太冗杂了。 很显然，这样还是需要判断是否为空啥的，如下：
public static void main(String[] args) { T2 t2 = new T2(1, "123"); Optional&lt;T2&gt; optional = Optional.ofNullable(t2); if (optional.isPresent()) { T2 t21 = optional.get(); System.out.println(t21.getName()); } else { System.out.println("为空"); } } 那岂不是和我直接XX==null一模一样，所以更优雅的方法来了，首先把获取对象的符合一点逻辑，有就给我，没有就给空
package com.quartz.jop; import lombok.Data; import java.util.Optional; /** * @program: springBoot * @author: quxiao * @create: 2023-11-23 20:03 **/ @Data public class T2 { int age; String name; public T2(int age, String name) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5abe2f45e7d0e4c25a729fd1f738236b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/367a8347baf683da0faedb73cad2bd69/" rel="bookmark">
			按需引入 ElMessage，没有样式且类型检查失败
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 ElMessage 弹框没有样式问题描述解决方案 ts 类型检查失败问题描述解决办法 eslint 检查失败问题描述解决办法 ElMessage 弹框没有样式 问题描述 Element-plus 在使用 ElMessage 消息弹框的时候没有样式，按照官方的按需加载的方式引入的
import { ElMessage } from "element-plus"; ElMessage.success('修改成功！') 解决方案 只要是按需导入了，就不要去手动导入。要不然样式无法生效。
当然如果手动导入了模块，再去全局导入所有 element-plus 样式，这也能生效。但这已经不是按需导入了 // 去掉引用 // import { ElMessage } from 'element-plus' ElMessage.success('修改成功！') ts 类型检查失败 问题描述 如果不手动 import 导入，会发现 ElMessage 会类型检查失败。会报找不到名称ElMessage这样的一个错误 ：
虽然开发环境可以忍着红线不去管它，可以正常使用，但打包构建会失败。因为构建时会有严格的类型检查 vue-tsc。因此这个问题必须解决。
解决办法 其实自动导入已经有了 ts 的类型声明，它就在 auto-imports.d.ts 文件里。但为什么编辑器检测不到类型呢。
因为 tsconfig.json 中 include 包含的类型文件范围中没有 auto-imports.d.ts文件。vite 的 vue 模板中，默认包含的类型文件范围是仅在 src 目录下：
"include": ["src/**/*.d.ts", ...] 因此将auto-imports.d.ts包含到 ts 类型的检测范围就可以了,。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/367a8347baf683da0faedb73cad2bd69/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61d4fe18330116c059d2b584a63e246f/" rel="bookmark">
			Jetson 配置中文环境，中文输入法，安装QQ
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、配置中文环境，中文输入法 1. 打开终端：sudo apt-get install fcitx-googlepinyin -y
2.打开设置 找到语言支持（Language Suppor）
2.1 首次开机的话会提示更新或者补充下载一下语言包什么的，同意安装就可以。
3.在菜单和窗口的语言移到最上面，按住往上托就可以
4.修改键盘输入方式 Keyboard input method system为fcitx（默认ibus）
5.终端输入reboot重启开发板，完成。
二、安装QQ，主要作用是用于文件、信息传输 官网下载链接：QQ Linux版-从心出发·趣无止境
根据自己版本，复制指令安装即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1dc2eaf87ef65333e5f719076c58136/" rel="bookmark">
			STM32——USART串口协议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一.半双工，全双工和单工区别二.通信协议基础知识三.串口通信区分四.串口通信的基础知识五.USART串口外设六.USART框图七.USART基本结构八.数据模式九.单片机通过串口发送一个字节，数组,字符串和数字到电脑上9.1 接线9.2 代码 十.printf函数的移值方法(单片机输出到电脑上)10.1 方法10.2 写法1代码10.3 写法2代码 十一.电脑发送数据到单片机上通过OLED显示11.1 查询方法判断是否显示数据代码11.2 中断的方式来判断是否显示数据代码(一字节) 十二.USART数据包12.1 发送HEX数据包和文本数据包12.2 接受HEX数据包和文本数据包12.3 发送数据包和接收数据包以HEX形式的代码12.4 接收数据包以文本形式的代码 一.半双工，全双工和单工区别 二.通信协议基础知识 三.串口通信区分 下图是51单片机串口通信的区分，跟stm32差不多，51单片机的串口通信的uart是只能异步通信，而stm32串口的usart是同步跟异步都可以选择，同步靠时钟线，异步靠比特率，比特率就是通信速度不一样，可以调成一样的。
四.串口通信的基础知识 (1).图一是串口通信的基本介绍。
(2).图二是串口通信的连线。
(3).图三是电平标准的介绍，我们单片机最常见的是TTL电平。
(4).在图四中，每一字节都装载在一个数据帧里面，每个数据帧都由起始位，数据位和停止位组成，这里数据位有8个，代表一个字节有8位，也可以在数据位加一个奇偶校验位，这样数据位就是9位，其中有效载荷是前8位，代表一个字节，校验位跟在有效载荷后面，占1位，1000bps就是表示比特率为1000，就表示，1s要发1000位，就是1/1000=1ms，每一位的时间就是1ms，也就是D0的时间是1ms，没发数据时候(空闲的时候)是高电平，然后就是起始位，发送数据前，发送一个高电平，来打破空闲状态的高电平，产生一个下降沿，告诉接收设备，这一帧数据要开始了，所以相对应的发送完数据后，需要有一个停止位，告诉接收设备发送完了，给高电平，这里数据位的LSB意思是低位在前，MSB意思是高位在后，比如发送0x0F，也就是0000 1111，也就是发送1111 0000，如果奇偶校验可以判断数据传输是不是出错了，如果数据出错了，可以选择丢弃或者要求重新传输，校验可以选择3种方式，无校验，奇校验，偶校验，无校验就是不需要校验位，就是数据位只有8位，如果使用了奇校验，那么包括校验位在内的9位数据就会出现一个奇数个1，比如传输0000 1111，目前总共4个1，是偶数个1，那么校验位就需要在补一个1，连同校验位就是0000 1111 1，保证1为奇数，如果是0000 1110，此时3个1，是奇数1，那么校验位就补一个0，就是0000 1110 0，所以1的个数还是奇数，发送设备先确定这些数据然后给奇数校验位后在开始传输，接收设备接收到数据后，接收到1的个数还是奇数，就认为数据没有出错，如果在传输过程中，有一位数据为干扰变成0或者由0变成1，那么整个数的奇偶特性就会变，就认为传输数据出错，偶校验就是保证1的个数是偶数，如果有两位数据出错，奇偶特性不变，那校验不出来了，所以奇偶校验位只能保证一定程度上的数据校验，如果想要更高的检出率，可以了解一下CRC校验。
(5).在图五中串口通信过程中，在STM32中，这个根据字节数据翻转高低电平，是由USART外设自动完成的，不用我们操心，跟51单片机一样，当然也可以软件模拟产生这样的波形，这里比特率9600，就是1/9600=104us的时间，然后定时器定时一个104us的时间，时间到了之后，按照数据帧要求，调用GPIO_WriteBit置高低电平，产生和这个一模一样的波形，这样也可以完成串口通信，TX引脚发送，就是置高低电平，那么在RX引脚接收，显然就是读取高低电平了，这也是USART外设自动完成的，不用我们操心，如果想软件模拟的话就是定时调用GPIO_ReadInputDataBit的每一位，最终拼成一个字节，当然接收的时候还需要一个外部中断，在起始位的下降沿触发，进入接收状态，并且对齐采样时钟，然后依次采样8次，所以硬件就是我们配置好，然后需要指定发送的数据，硬件外设电路会自动操作完成，软件就是用代码模拟高低电平。
图一
图二
图三
图四
图五
五.USART串口外设 (1).Uart是异步收发器，USART是同步和异步收发器，STM32的USART同步只是多了个时钟输出而已，它只支持时钟输出，不支持时钟输入，这个同步模式更多是为了介入别的协议或者特殊用途而设计的，并不支持两个USART设备之间进行同步通信，所以学习串口还是主要是异步通信。
(2).硬件就是我们配置好，然后需要指定发送的数据，硬件外设电路会自动操作完成，软件就是用代码模拟高低电平。
(3).自带波特率发生器，它就是一个分频器，比如我们APB2总线给个72MHZ的频率，然后波特率发生器进行一个分频，得到我们想要的波特率时钟，在这个时钟下，进行收发，就是我们指定通信的波特率。
(4).同步模式就是多了一个时钟CLK的输出，硬件流控制就是比如A设备的TX向B设备的RX发送数据，A设备一直在发，发的太快了，B处理不过来，如果没有硬件流控制，那么B就只能抛弃新数据或者覆盖原数据了，如果有硬件流控制，在硬件电路上，就会多一根线，如果B没有准备好，就置高电平，如果准备好了，就置低电平。
(5).USART1是APB2总线上的设备，剩下的都是APB1总线的设备。
六.USART框图 (1).图一的红圈位置就是TX和RX引脚，然后黄圈的SW_RX和IRDA_OUT/IN是智能卡和IrDA通信的引脚，这些我们没用，就不用管，TX和RX引脚分别通向绿线和蓝线位置，紫色区域就是串口的数据寄存器了，发送或者接收数据就存在这里，数据寄存器有两个，发送寄存器和接收寄存器，但是寄存器的地址都是一样的，就跟51单片机串口SBUF寄存器一样，在程序上只表现为一个寄存器，就是数据寄存器DR，但是实际硬件中，是分成两个寄存器，一个用于发送TDR,另一个用于接收RDR，TDR是只写，RDR是只读的，然后发送移位寄存器作用就是把一个字节一位一位的移出去，正好对应串口协议波形的数据位，这两个寄存器是怎么工作的呢？比如你在发送寄存器写入0x55，在二进制就是0101 0101，那么此时硬件检测到你写入数据了，它就会检查，当前移位寄存器是不是有数据正在移位，如果没有，这个0101 0101就会立刻全部移动到发送移位寄存器中，准备发送，当数据从TDR移动到发送移位寄存器中，会置一个标志位，叫TXE(发送寄存器空),这个标志位如果置1了，我们就可以在TDR写入下一个数据了，注意一下，TXE置1时，数据其实还没有发送出去，只要数据从TDR转移到发送移位寄存器了，TXE就会置1，我们就可以写入新的数据，然后发送移位寄存器就会在下面(棕线)这里的发送器控制驱动下，向右移位，然后一位一位的向绿线TX输出到引脚，RX引脚也是一样的，在接收器控制下，一位一位的读取RX电平，把接收到的数据先放在最高位，然后一位一位向右移，移位八次后，就可以接收一个字节了，当一个字节移位成功后，这个数据就会一下子全部转移到接收数据寄存器RDR里来，在转移过程也会置一个标志位RXNE(接收数据寄存器非空)，当我们检测到RXNE置1后，就可以把数据读走了。
(2).在图二中，硬件数据流控就是防止传输太快了，接收设备还没有来得及处理，就会丢弃或者覆盖数据的现象，有了流控，就可以避免这个问题，这里流控有两个引脚，一个是nRTS，一个是nCTS,nRTS是请求发送，是输出脚，，也就是告诉别人当前能不能接收，nCTS是清除发送，是输入脚，也就是接收别人nRTS的信号，n就是低电平有效，这个流控是怎么玩的呢，首先得找另一个支持流控的串口，如图三，它的TX就接到RX，然后我的nRTS要输出一个能不能接收的反馈信号，接到对方的CTS，，当我能接收的时候，nRTS就置低电平，请求对方发送，对方的nCTS接收到后，就可以一直发送，如果接收寄存器没有及时处理好数据，那么我nRTS就置高电平，对方的nCTS接收到后，就会暂停发送。
(3).然后接着看图四这个模块——SCLK控制，这部分电路用于产生同步的时钟信号，它是配合发送移位寄存器输出的，发送移位寄存器每移位一次，同步时钟电平就跳一个周期，时钟告诉对方，我移出去一位数据了，这个时钟只支持输出，不支持输入，然后就可以用这个同步模式兼容SPI协议等等，然后图四中的唤醒单元，这部分作用是实现串口挂载多设备，串口一般是点对点，点对点只支持两个设备互相通信，而多设备，在一条总线上，可以接多个从设备，每个设备分配一个地址，我想跟某个设备通信，就先进行寻址，确定通信对象再进行数据收发，这个唤醒单元就是可以实现多设备的功能，在图四中的USART地址这里分配一个地址，当你指定地址时，此设备唤醒开始工作，当你发送别的设备地址时，别的设备就唤醒工作，这个设备没有收到地址，就会保持沉默，这样就可以实现多功能通信了。
(4).图五红圈是中断输出控制，中断申请位就是状态寄存器(黄圈)这里的各种标志位，状态寄存器这里有两个重要的标志位比较重要，一个是TXE发送寄存器空，另一个是RXNE接收寄存器空，TXE,这个标志位如果置1了，我们就可以在TDR写入下一个数据了，RXNE置1后，就可以把数据读走了，中断控制这里就是配置能不能通向NVIC。
(5).然后图六是波特率发送器其实就是分频器，APB时钟进行分频，得到发送或者接收移位的时钟，fPCLKx(x=1或者2)，USART1挂载在APB2，所以就是PCLK2的时钟，一般是72MHZ，其他的USART都挂载在APB1，所以是PCLK1的时钟，一般是36MHZ，之后这个时钟进行分频，除于一个USARTDIV的分频系数，USARTDIV里面就是在它的右边黄圈的位置，分为整数部分和小数部分，，因为有一些波特率，用72M除一个整数的话，可能除不尽，有误差，这里的分频系数是支持小数点后4位的，分频就更加精准，然后发送器波特率控制(TE)为1，就是发送器使能了，发送部分的波特率就有效，如果接收器波特率控制(RE)为1，就是接收器使能了，接收部分的波特率就有效了。
图一
图二
图三
图四
图五
图六
七.USART基本结构 (1).最左边波特率发生器是用于产生约定的通信速率的，，时钟来源是PCLK2或者1，经过波特率发生器分频后，产生的时钟通向发送控制器和接收控制器，发送和接收控制器用来控制发送移位和接收移位，之后发送数据寄存器和发送移位寄存器这两个寄存器的配合，将数据一位一位的移出去，通过GPIO的复用输出，输出到TX引脚，产生串口协议规定的波形，发送移位寄存器这里画了几个右移的符号，就是代表这个移位寄存器是往右移动的，是低位先行，当数据由数据寄存器转移到移位寄存器时，，会置一个TXE的标志位，TXE会置1，我们判断这个标志位就可以知道是不是可以写下一个数据了，接收部分也差不多，RX引脚的波形，通过GPIO输入，在接收控制器的控制下，一位一位的移入接收移位寄存器，，然后也是画了右移符号，所以也是低位先行，所以数据先从左边开始一位一位移进来，然后不断向右移，就是例如第一个给1，第二个给0，就是01，移动完一帧数据帧后，数据就会统一转运到接收数据寄存器，在转运的同时会置一个RXNE标志位，我们会检查这个标志位，就可以知道是不是收到数据了，这个标志位置1，就是收到一帧数据帧了，同时这个标志位可以去申请中断函数，然后快速的读取和保存数据。
(2).但是在软件层面，只有一个DR寄存器可以供我们读写，写入DR寄存器时，数据从图二上面这红线这条路进行，进行发送，读取DR时，数据从图二下面这条红线，进行接收，这就是USART进行串口数据收发的过程，最后右下角，开关控制，就是配置完后，用Cmd开启一下外设。
(3).图三就是波特率发生器就是分频器，发送器和接收器的波特率由波特率寄存器BRR里的DIV确定，图三就是BRR寄存器，里面就是分频系数DIV，DIV分为整数部分和小数部分，可以实现更细腻的分频，波特率和分频系数的关系，可以由图三这个计算公式进行计算，如果要9600的波特率，9600=72M/16*DIV，DIV=468.75，转化成二进制就是11101 0100.11。
图一
图二
图三
八.数据模式 九.单片机通过串口发送一个字节，数组,字符串和数字到电脑上 9.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b1dc2eaf87ef65333e5f719076c58136/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5930c8d65e5e13af3cae7064bb24e495/" rel="bookmark">
			【数据结构与算法】树和二叉树（头歌）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		树和二叉树
第1关：二叉树的基本操作
任务描述
测试说明
代码
第2关：输出二叉树后序遍历的逆序
任务描述
测试说明 代码 第3关：按中序输出二叉树中的分支结点
任务描述
测试说明
代码
第4关：前序输出二叉树节点值与层次值
任务描述
测试说明
代码 第5关：求二叉树中结点个数
任务描述
测试说明
代码
第6关：求二叉树叶子结点数
任务描述
测试说明
代码 第7关：求二叉树的深度
任务描述
测试说明
代码 第8关：二叉树交换左右子树
任务描述
测试说明
代码 第9关：按中序遍历次序输出二叉树中度为1的结点
任务描述
测试说明
代码
第1关：二叉树的基本操作 任务描述 题目描述： 设计二叉树，能够对二叉树进行先序、中序、后序和层序遍历，遍历的操作为输出结点的值，设计主函数，输入一棵二叉树，按先序、中序、后序、层序的遍历顺序输出结点的值。二叉树的结点数不超过20。
测试说明 输入描述：输入数据只有一组, 二叉树的结点均为一个数字， 数据为 0 代表当前结点为空。输入结点的值按照二叉树的先序遍历顺序, 比如输入:1 2 4 0 0 5 0 0 3 0 6 0 0, 0 表示空,输入的数字之间由空格分隔。
1/ \2 3/ \ \4 5 6 输出描述：输出先序、中序、后序和层序遍历二叉树得到的序列，各占一行，同一行的数字之间由空格分隔。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5930c8d65e5e13af3cae7064bb24e495/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f100afadf36737989344bb0ecced2fcb/" rel="bookmark">
			车载电子电器架构 ——电子电气架构设计方案概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我是穿拖鞋的汉子，魔都中坚持长期主义的汽车电子工程师。 注：本文1万多字，认证码字，认真看！！！
老规矩，分享一段喜欢的文字，避免自己成为高知识低文化的工程师： 屏蔽力是信息过载时代一个人的特殊竞争力，任何消耗你的人和事，多看一眼都是你的不对。非必要不费力证明自己，无利益不试图说服别人，是精神上的节能减排。
无人问津也好,技不如人也罢,你都要试着安静下来,去做自己该做的事.而不是让内心的烦躁、焦虑、毁掉你本就不多的热情和定力。
文章大体有如下内容： 1、前言 2、电子电气架构概述 （1）什么是电子电气架构 （2）为什么要开发电子电气架构 （3）如何设计和开发电子电气架构 一、前言 随着电气架构开发的深入，车载控制器功能和子系统、ECU经过几轮迭代开发，电子电气架构及基础技术开发方法论已经基本形成，因此有必要对当前的工作、流程、方法论及工具链等进行梳理总结。伴随着中国电动汽车的蓬勃发展，大量技术人员涌入到车载工程师这个行业，因此也迫切需要对电子电气架构、基础技术和功能安全开发等有系统性的了解，熟悉其关联专业核心业务、工作流程与业务上下游关联关系及工具链等，特写此专栏。 本专栏内容覆盖电子电气架构开发,包括电气架构开发流程,功能、子系统、ECU层开发流程和方法，网络拓扑、PNC(局部网络休眠唤醒)/VFC等核心业务工作介绍，基础技术开发，包括基础技术开发流程及诊断、通信数据库、软件下载（Software Download）、Car configuration 等核心业务工作介绍及与该业务相关上下游的关系; 另外本专栏还包括功能安全、软件开发、信息安全及工具链等业务介绍。 本专栏侧重于方法论及业务的流程、输入输出关系及工具链应用介绍，适用电气系统开发业务工程师及管理人员，包括： -&gt; 车载架构工程师； -&gt; 车载控制器基础技术工程师； -&gt; 车载功能开发工程师； -&gt; 子系统开发工程师； -&gt; 车载控制器ECU开发工程师； -&gt; 诊断EOL下线开发工程师； -&gt; 功能安全工程师； -&gt; ECU Owner属性工程师； -&gt; 电气集成经理。 等等，除了上述工程师外，从事车辆相关的技术人员，也由必要对造车流程有一个清晰的认识。 二、电子电气架构概述 1、什么是电子电气架构 首先回答什么是电子电气架构EEA这个问题？ 电子电气架构(EEA)，即Electronic and Electrical Architecture，涉及电子与电气两部分，是指在成本重量、可靠性等一定约束条件下，能最优实现整车电子与电气需求的技术方案。电子电气架构是整车电子电气开发的主体框架，为具体的整车项目中的模块开发提供整车实现方案与规范指导，需具备前瞻性，平台化，可扩展等特点。 EE架构是电子电气系统的顶层设计是贯穿E/E需求开发、功能开发、网络开发、电气系统设计的综合性工作。 为什么要做电子电气架构EEA? -&gt; (1)、整车层面电子电气相关需求的继承及扩展，确保工程开发满足整车层面需求； -&gt; (2)、电子电气前期统筹和规划，以达到成本优化的目的； -&gt; (3)、系统开发设计的基础，避免系统之间不匹配的问题(软硬件接口）； -&gt; (4)、实现平台化及模块化的基础，保证技术方案的一致性，避免重复开发及验证。 电子电器架构（EEA）是汽车电子系统的总布置，在功能需求、法规和设计要求等特定约束下，通过对功能、性能、成本和装配各方面进行分析，得到最优的电子电器系统模型。电子电器架构涵盖了车上计算和控制系统的软硬件、传感器、通信网络、电气分配系统等，通过特定的逻辑和规范将各个子系统有序结合起来，构成实现复杂功能的有机整体。在智能车时代，电子电器架构向集中化演进是这一转变的前提。 电子电气架构在电气系统开发中包含了很多方面，当谈起架构时，更多地会涉及以下方面: 1) 架构是设计的一部分，更多着重于电气系统中结构方面，但也包括那些对系统的性能、可靠性、成本和适应性有持人影响的方面: 在电子电器架构设计中，需要考虑到系统的复杂性、可维护性、可扩展性、成本等因素。同时，还需要考虑如何将系统划分为多个子系统，并确定子系统之间的接口和通信方式。
在电子电器架构中，还需要考虑到安全性和可靠性。例如，需要确保电子电器系统不会对车辆的安全性产生负面影响，同时还需要确保系统的稳定性和可靠性，以便在出现故障时能够及时修复。
此外，电子电器架构还需要考虑到未来的发展趋势，例如智能化、电动化、网联化等。需要确保系统能够适应未来的技术升级和变化，以便在未来的市场竞争中保持领先地位。
2)选择基础设施(infiastructure)也同样是架构的主要工作内容，如平台选择通信总线、基础软件等: -&gt; 平台选择：选择适合汽车应用的平台，包括硬件平台、软件平台等。硬件平台需要考虑处理能力、存储容量、接口等，软件平台需要考虑操作系统、中间件、开发工具等。 -&gt; 通信总线选择：通信总线是汽车中各个子系统之间进行通信的桥梁，需要选择适合汽车应用的通信协议和总线标准。同时还需要考虑总线的可扩展性和灵活性，以便适应未来系统升级和变化的需求。 -&gt; 基础软件选择：电子电器架构中需要选择适合的基础软件，包括嵌入式软件、操作系统、中间件等。基础软件的选择需要与硬件平台和通信总线相匹配，并能够满足系统的功能和性能要求。 -&gt; 安全性考虑：在选择基础设施时，需要考虑到安全性问题，包括网络安全、数据安全等。需要采取相应的安全措施和技术手段，确保电子电器系统的安全性和可靠性。 总之，选择合适的基础设施对于电子电器架构的设计和实现具有重要意义。在选择基础设施时需要考虑多个方面因素，包括平台选择、通信总线选择、基础软件选择和安全性考虑等。 3) 架构描述了系统的结构，并且在系统结构中有很多个结构相互交织。但是架构不仅仅是分层。 架构描述了系统的结构，并确定了系统中各个组成部分之间的关系和交互方式。在复杂的系统中，通常会有多个层次或多个子系统交织在一起，每个层次或子系统都有其特定的功能和职责。 然而，架构并不仅仅是分层。一个好的架构应该是清晰的、模块化的、易于维护和扩展的。它应该能够满足系统的功能需求、性能需求、可维护性需求、可扩展性需求和安全性需求等。 在电子电器架构中，通常会将系统划分为多个层次或多个子系统，例如硬件层、软件层、通信层等。每个层次或子系统都有其特定的功能和职责，并且需要相互协调和交互。同时，电子电器架构还需要考虑到系统的安全性、可靠性和灵活性等方面的需求。 为了方便理解，从相反方向对架构进行介绍。 1) 架构并不仅仅是围绕需求工作，而更多的是着重于设计; 车载电子电气架构是一个复杂的设计过程，需要综合考虑多个因素，包括需求、性能、成本、可维护性、可扩展性等。 首先，车载电子电气架构需要满足车辆和乘客的需求。这包括提供舒适的乘车环境、保护乘客的安全、提供足够的动力和性能等。为了满足这些需求，设计师需要考虑各种因素，例如车辆的动力学特性、乘客的舒适度需求、车辆的安全性能等。 其次，车载电子电气架构还需要考虑电子电器系统的设计和组织。这包括系统的硬件设计、软件开发、通信设计等。设计师需要根据系统的功能需求和性能要求，选择合适的硬件和软件平台，并确定各个子系统之间的接口和通信方式。 此外，车载电子电气架构还需要考虑系统的可维护性和可扩展性。设计师需要确保系统能够方便地进行维护和升级，同时还需要考虑未来技术的发展和变化，以便在必要时对系统进行扩展和升级。 2) 架构并不是一个架构工程师能完成的，在很多组织中，它更多的是以一个团队形式存在， 通常会有人认为，架构就是网络，架构就是信号数据库，AUTOSAR就是架构等等。这些都是关于架构的常见误解。这些都是架构工作中的一部分,但是架构不可以被其中任何一方面所约束; 3) 架构工作并不是扁平化的，例如一种单一语盲或单一图标，这些都无法大描述系统的复杂性。架构不仅有宽度还有深度，它涉及许多不同层次的问题，有时会需要与不同域的工程师去协同完成， 架构工作并不仅局限于结构方面。架构虽然必须去描述系统的结构，但是架构远远不止于此，还须去处理很多超出架构的灵活问题。 国际标准和行业标准也对架构进行了定义，对架构的定义： Architecture，The fundamental organisation ofa system embodied in its componentstheir relationships to each other, and to the environment, and the principles guidingits design and evolution.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f100afadf36737989344bb0ecced2fcb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a90770125d8b51c1ab4fd4713e190763/" rel="bookmark">
			SpringCloudAlibaba之sentinel 流量卫兵(流控，熔断降级) ——详细讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、什么是sentinel
二、sentinel使用
1. sentinel dashboard的安装
2.启动
3.访问web界面
​编辑 4.登录
三、sentinel 实时监控服务
1.创建项目引入依赖
2.配置
3.启动服务
4.访问dashboard界面查看服务监控
5.开发服务
6.启动进行调用
7.查看监控界面
四、sentinel 流量控制
1. QPS限流
1.配置QPS流量控制
2.测试
2.线程数限流
1.配置线程数限流
2.访问测试
3.流控模式
4.流控效果
五、熔断降级
1.降级策略
六、SentinelResource注解
一、什么是sentinel As microservices become popular, the stability of service calls is becoming increasingly important. Sentinel takes "flow" as the breakthrough point, and works on multiple fields including flow control, circuit breaking and load protection to protect service reliability.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a90770125d8b51c1ab4fd4713e190763/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b0c378dfd44479851246a8897e9f4fa/" rel="bookmark">
			完蛋！我被ConcurrentHashMap源码包围了！(一)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 引言2. 使用3. 初始化4. 存储流程5. 取值流程6. 扩容流程 1. 引言 ConcurrentHashMap是一个线程安全的HashMap，在JDK1.7与JDK1.8，无论是实现还是数据结构都会有所不一样。这促使了ConcurrentHashMap有着HashMap一样的面试高频考点。
接下来，我将会以下面几点带硬核大家从源码角度理解ConcurrentHashMap的整体流程，开始发车！
注意：若文章无特殊说明均代表JDK1.8的ConcurrentHashMap
2. 使用 在进入源码学习之前，先回忆一下ConcurrentHashMap是如何使用的。
public static void main(String[] args) { Map&lt;String, String&gt; map = new ConcurrentHashMap&lt;&gt;(); map.put("a", "b"); map.put("b", "c"); map.put("c", "d"); System.out.println(map.get("a")); } ConcurrentHashMap简单使用如上，不过多赘述。
3. 初始化 想学学习一个类的源码，就必须由浅入深，先从构造方法开始学习。
无参构成，没啥好聊的
public ConcurrentHashMap() { } 有参构造，构造参数为初始化容量
public ConcurrentHashMap(int initialCapacity) { if (initialCapacity &lt; 0) // initialCapacity为0 抛异常 throw new IllegalArgumentException(); // 判断初始化容量参数initialCapacity 与 MAXIMUM_CAPACITY &gt;&gt;&gt; 1 的大小 // 如果 initialCapacity 大于等于 MAXIMUM_CAPACITY &gt;&gt;&gt; 1 // 则取 MAXIMUM_CAPACITY 为容量 // MAXIMUM_CAPACITY 是Map的最大容量 // 如果 initialCapacity 小于 MAXIMUM_CAPACITY &gt;&gt;&gt; 1 // 找出距离initialCapacity最近的2次幂 // 为什么要2次幂？？？？别急 后面会聊到。 int cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; 1)) ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b0c378dfd44479851246a8897e9f4fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41b63cd2de8a9c7309a6c46f77c83509/" rel="bookmark">
			【Range Image】 提取Range Image的边界
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前写过：
https://blog.csdn.net/weixin_45824067/article/details/131343945
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c20c5e804899427056d52f8bd980ce1/" rel="bookmark">
			编写函数将十进制数转换成八进制数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		请编写函数将十进制数转换成八进制数。函数名为f, 函数参数及返回值自己定义, 编写主函数,
实现如下功能:输入100个十进制整数, 调用函数f, 将它们转换为八进制数, 并输出, 假设输入的前3
个数据为 : 15, 80, 90, 则前三行对应的输出为 :
15 &gt;&gt; &gt; 17
80 &gt;&gt; &gt; 120
90 &gt;&gt; &gt; 132
#include &lt;stdio.h&gt; #define N 3 void f(int n) { int arr[10], i = 0; while (n) { arr[i] = n % 8; n /= 8; i++; } for (int j = i - 1; j &gt;= 0; j--) printf("%d",arr[j]); } int main() { int n = 0, i = 0; for (i = 0; i &lt; N; i++) { scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c20c5e804899427056d52f8bd980ce1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa17b06d7172dcf2003ba9247cadd00c/" rel="bookmark">
			【Range Image】 创建Range Image
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 介绍 范围图像是一种将点云数据转换为二维图像的表示形式。它将点云中的每个点映射到图像中的像素，每个像素表示了点在三维空间中的距离信息。范围图像的每个像素包含了点的深度信息，可以用来表示物体的形状和几何结构。范围图像通常用于进行深度感知和三维重建等任务。
范围图像在PCL中使用 pcl::RangeImage 类型表示，它包含了范围图像的像素数据以及相关的参数和方法。范围图像可以从点云数据中创建，并可以通过可视化工具进行可视化。
2 创建Range Image代码 #include &lt;pcl/range_image/range_image.h&gt; #include &lt;pcl/visualization/pcl_visualizer.h&gt; int main () { pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr pointCloud(new pcl::PointCloud&lt;pcl::PointXYZ&gt;); // Generate the data for (float y=-0.5f; y&lt;=0.5f; y+=0.01f) { for (float z=-0.5f; z&lt;=0.5f; z+=0.01f) { pcl::PointXYZ point; point.x = 2.0f - y; point.y = y; point.z = z; pointCloud-&gt;push_back(point); } } pointCloud-&gt;width = pointCloud-&gt;size(); pointCloud-&gt;height = 1; // We now want to create a range image from the above point cloud, with a 1deg angular resolution // 角度分辨率，以弧度表示 float angularResolution = (float) ( 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa17b06d7172dcf2003ba9247cadd00c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2dfb4b9687a8086a7cdfa3ef17990e88/" rel="bookmark">
			机器学习探索计划——KNN算法流程的简易了解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 数据准备阶段KNN预测的过程1.计算新样本与已知样本点的距离2.按照举例排序3.确定k值4.距离最近的k个点投票 scikit-learn中的KNN算法 数据准备阶段 import matplotlib.pyplot as plt import numpy as np # 样本特征 data_X = [ [0.5, 2], [1.8, 3], [3.9, 1], [4.7, 4], [6.2, 6], [7.5, 5], [8.3, 3.5], [9.1, 7], [9.8, 4.5] ] # 样本标记 data_y = [0, 0, 0, 1, 1, 1, 1, 1, 1] X_train = np.array(data_X) y_train = np.array(data_y) X_train array([[0.5, 2. ], [1.8, 3. ], [3.9, 1. ], [4.7, 4. ], [6.2, 6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2dfb4b9687a8086a7cdfa3ef17990e88/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3961a25c5a8e935128a3ccc4f002e28/" rel="bookmark">
			深入探讨：Elasticsearch索引的构建与优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在做es相关的工作，所以记录下自己的一些想法，可能很多方面不会很全面，但是基本都是经过验证的。本文主要是围绕着思考，从多个方面进行考虑，怎么设计索引比较好，直接进入主题吧，本文的es版本为elasticsearch7.8.1。
一、索引设计的重要性 首先索引创建后，索引的分片只能通过_split和_shrink接口对其进行成倍的增加和缩减，主要是因为es的数据是通过_routing分配到各个分片上面的，所以本质上是不推荐去改变索引的分片数量的，因为这样都会对数据进行重新的移动。还有就是索引只能新增字段，不能对字段进行修改和删除，缺乏灵活性，所以每次都只能通过_reindex重建索引了。还有就是一个分片的大小以及所以分片数量的多少严重影响到了索引的查询和写入性能。所以可想而知，设计一个好的索引能够减少后期的运维管理和提高不少性能。所以前期对索引的设计是相当的重要的。
好的索引设计在整个集群规划中占据举足轻重的作用，索引的设计直接影响集群设计的好坏和复杂度。好的索引设计应该是充分结合业务场景的时间维度和空间维度，结合业务场景充分考量增、删、改、查等全维度设计的。好的索引设计是完全基于“设计先行，编码在后”的原则，前期会花很长时间，为的是后期工作更加顺畅，避免不必要的返工 二、如何设计索引 在设计索引之前我们要明白索引有些什么内容，明白索引的构成，比如索引的基本配置setting，映射mapping，还有重要的分片，副本，模板，索引的生命周期等。知道这些之后就可以有针对性的设计了。首先要结合公司的业务场景，数据量的大小，每天增量如何，数据的特点，会不会对历史数据进行重新更新。数据存多久，是永久还是有一定的周期。数据需要准实时呢还是不需要准实时呢。所以清楚索引的构成和知道业务场景，才能够结合起来做更好的设计。
2.1、考虑索引的公共基本配置 由于elasticsearch7.x不允许把索引级别的设置配置在elasticsearch.yml中，所以需要对每个索引进行单独的配置，这样的话就比较麻烦，所以可以把这些公共的配置配置在索引模板中，这样就可以在新建索引的时候可以自动的设置到索引中，关于索引模板的操作可以看考：聊聊elasticsearch7.8的模板和动态映射
接下来看看一些常用索引级别的配置
当然索引的配置还有很多其他的，可以根据实际情况进行调整，这样就可以把需要配置公共索引配置设计成索引模板：
这样新建index-开头的索引的时候都会默认配置好如上的配置，这样就是考虑到基本设置公共化。
2.2、索引命名规范 这部分主要说下索引命名规范，包括别名，通过别名可以使得索引的操作变得更加灵活，一个索引可以有多个别名，当然一个别名可以配置多个索引，这样的话就极大的增加了索引的的灵活性。在索引的命名上规定特殊字段开头，同样对其方便进行权限控制，关于权限控制可以参考：elasticsearch7.8权限控制和规划
必须严格按照如下命名格式：（否则将无法使用，因为这里设置了相关权限）；
索引命名规范：index-{行业}-{业务}-{版本}别名命名规范：index-{行业}-{业务} 如果是索引拆分后（有多个索引），需要一个全局的读的别名对所有拆分后的所有进行命名，和一个最新索引写的别名（只对可更新的索引），如果这里没有描述清楚，请见2.5大索引的设计，两个别名可规范如下：
读别名：index-{行业}-{业务}-read写别名：index-{行业}-{业务}-insert 2.3、mapping的设计 mapping设置主要就是怎么选择数据类型，分词等
中文分词：推荐使用："analyzer": "ik_max_word" ，这样可以更细粒度的进行中文分词
设置字段的时候，务必过一下如下图示的流程。根据实际业务需要，主要关注点：
数据类型选型；是否需要检索；是否需要排序+聚合分析；是否需要另行存储 核心参数的含义，梳理如下
2.4、分片的设计
这个很重要，直接影响到后期的管理和性能。
Elasticsearch中的数据组织成索引。每一个索引由一个或多个分片组成。每个分片是Luncene索引的一个实例，你可以把实例理解成自管理的搜索引擎，用于在Elasticsearch集群中对一部分数据进行索引和处理查询。
分片设计原则
推荐每个分片的大小：20-40G，建议不超过30G，但是也会有特殊的情况，有些索引字段少，但是数据量大，这样的话也可以增加一些分片数确保每个节点的分片数量保持在低于每1GB堆内存对应集群的分片在20-25之间。 因此，具有30GB堆内存的节点最多可以有600-750个分片每个索引的分片：一般为节点数的1-3倍，假设我们有15个数据节点，则15*3*40G=1.8T，这样一个索引最多设置真的大，如果超过了，就需要参考大索引的设计分片数量尽量为数据节点的倍数，这样就可以使得数据进来均衡，但是数据量极少的索引，根据情况进行分片数量的设计 下面写一个简单的参考表（都可以根据实际情况进行调整，只是个人的建议）：
索引的大小分片数量设置0-20G220-100G8100-400G15400-900G30900G-1.6T45
如上设置是基于15个数据节点进行配置的，基本都给增量预留了一些空间，最好是根据实际情况进行设定，如果一个索引已经很大了，上面的配置不能满足了的话需要对对索引进行拆分了，使用索引模板+Rollover+索引生命周期进行自动滚动，拆分索引。见2.5节
2.5、大索引的设计 当一个索引太大时就会有很多的风险，首先会影响性能，当分片数一定的情况下，数据越来越多，一个分片就会越来越大，就会违背了上面的设计原则，其次就是一个索引出问题，很难恢复，并且影响范围广，那如何对很大的索引进行设计呢。可以使用索引模板+Rollover+生命周期进行自动滚动创建索引，所有的索引都用一个别名进行读，并且设置一个索引为写，这样就能够很好的拆分索引。先看看这么设计的原理图。
上面有三个索引，通过index_all索引进行检索，使用index_latest保证只写入到一个最新的索引中，每次索引满足三个条件（文档数，时间，索引大小）中的一个，就会自动的滚动生成新的索引。接下来做个实操，这样更方便理解。
先来个官网，有兴趣的可以参考：https://www.elastic.co/guide/en/elasticsearch/reference/7.8/getting-started-index-lifecycle-management.html
主要分为四个步骤：
创建索引生命周期的规则创建索引模板并应用该生命周期初始化一个索引验证 首先创建生命周期的规则，对于索引的生命周期可以参考：对Elasticsearch生命周期的思考，如果数据是定期存储的，比如一些日志，只保留最近30天，这样的数据结合索引的生命周期可以自动的进行清理。我们首先创建一个策略policy_index，这里是测试，所以把时间调至5分钟，这些配置都应该根据实际情况进行设置。
接下来设计索引模板，并且该策略应用进去。
这里的模板只是为了演示该小节的内容，实际情况应该把基本配置以及mapping相关的设置好
接下来就是创建一个索引了
PUT index-test-000001 创建好之后，然后给索引添加别名index-test-insert，索引就自动有了两个别名，read负责读，insert负责写
接下来，只要通过验证即可：GET index-*/_ilm/explain
最后达到条件后就会自动生成新的索引，然后把index-test-insert别名切换到新的索引上面，就是这样子的
大索引的设计就是拆分，很多都是根据时间进行切分索引的，如果记得没错的话，上面的000001这些可以配置为日期的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ef33a68806e7e14d4198775fc789dfd/" rel="bookmark">
			Python学习笔记（4）元组的基础操作及方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		元组的基础操作及方法 一、前言二、元组的基本操作1.创建元组2.合并 三、元组方法1.count()2.index() 一、前言 元组可以看做不可变的列表，它具有列表的大多数特点，具体如下：
（1）可以包含任意类型数据。
（2）元组大小不可变，既不能删除，也不能添加。
（3）元组中的对象也不能改变。
二、元组的基本操作 元组的基本操作包括创建，求长度，合并，迭代，关系判断，切片和矩阵等，因为大多数操作和列表十分相似，所以我们只讲几个差别较大的操作，其他操作可以参考往期作品：列表（巨详细版）
1.创建元组 a = (1, 2, 3) print(a) # 结果：(1, 2, 3) b = tuple((1, 2, 3)) # 注意里面的小括号 print(b) # 结果：(1, 2, 3) c = (1,) # 创建只有一个元素的元组时，需要在末尾加上逗号，否则计算机将当做整型赖处理 print(c) # 结果：(1,) d = 1, 2, 'p' # 创建时可以省略括号 print(d) # 结果：(1, 2, 'p') 2.合并 元组中已经有定义的元组无法被改变，但在定义前可以合并，例如：
a = (1, 2, 3) a + (1, 2) print(a) # 不会报错，但是a并未被改变,结果（1,2,3） b = (1, 2) + (3, 4) print(b) # 结果：(1, 2, 3, 4) 三、元组方法 在元组中支持两种方法：count()和index()。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ef33a68806e7e14d4198775fc789dfd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/edbee9fa993589aec269dc49454526ca/" rel="bookmark">
			【Redis基础】Redis安装及管理详细教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✅作者简介：大家好，我是小杨
📃个人主页：「小杨」的csdn博客
🐳希望大家多多支持🥰一起进步呀！
1，UBuntu安装Redis 1，使用su命令切换到root用户
su 2，使用search命令搜索redis相关的软件包
apt search redis 3，使用install命令安装Redis
apt install redis -y 4，手动修改配置文件来支持远程连接
修改 bind 127.0.0.1 为 bind 0.0.0.0 修改 protected-mode yes 为 protected-mode no 5，修改配置后重新启动Redis服务器
service redis-server restart 6，使用Redis自带的客户端连接服务器
redis-cli 7，使用快捷键退出Redis客户端
Ctrl + D 2，UBuntu管理Redis 1，启动Redis服务
service redis-server start 2，停止Redis服务
service redis-server stop 3，重启Redis服务
service redis-server restart 4，查看Redis状态
service redis-server status 3，CentOS安装Redis 在CentOS上安装Redis5，存在两种情况：
如果CentOS版本是CentOS8，yum仓库中默认的Redis版本就是5，直接使用 yum install 即可。如果CentOS版本是CentOS7，yum仓库中默认的Redis版本就是3，不可以直接使用 yum install，需要进行额外的操作。 3.1，CentOS8安装Redis 1，使用su命令切换到root用户
su 2，使用install命令安装Redis
yum install redis -y 3，针对可执行程序和配置文件设置符号链接
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/edbee9fa993589aec269dc49454526ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a75291b65bd48f635d4339d7c078d11d/" rel="bookmark">
			Python学习笔记（2）数学函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		往期目录： Python学习笔记（1）输入和输出https://editor.csdn.net/md/?articleId=134531933 常用内置数学函数 1.求绝对值函数abs，用法： a=abs(-9) print(a) #函数返回其绝对值 2.将整数转换为二进制字符串bin函数： print(bin(-9)) #结果-0b1001 print(bin(9)) #结果0b1001 3.返回整数对应的ASCLL函数的字符chr函数 print(chr(65)) #输出结果:A 4.返回商和余数divmod函数 print(divmod(9, 2)) #结果:（4, 2） 5.返回字符串中表达式中的值eval函数 a = 3 c = eval('a*a+1') #必须是有效的常量否则报错 print(c) #输出结果：10 6.四舍五入，保留指定位数的小位数round函数 a = 1.23456789 print(round(a,2)) #运行结果：1.23 print(round(a,3)) #运行结果：1.235 print(round(a,4)) #运行结果：1.2346 7.求和函数，sum print(sum({1,2,3})) # 注意sum小括号里要有个大括号或者中括号，即它的作用对象是列表或元组 #运行结果：6 math模块函数 在使用这个模块函数时，需要在最前面加上import math来导入math模块
1.引用圆周率pi import math a = math.pi print(a) #运行结果：3.141592653589793 2.引入常数e # 为了简洁之后省略import math a = math.e print(a) # 运行结果:2.718281828459045 3.返回不小于x的最小整数 print(math.ceil(3.1)) #运行结果：4 print(math.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a75291b65bd48f635d4339d7c078d11d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aad4bcd87313b0f3f5abc26277dcbed4/" rel="bookmark">
			STM32F103x TB6612FNG电机PID控制基础资料
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TB6612FNG 是东芝半导体公司生产的一款直流电机驱动器件，它具有大电流 MOSFET-H 桥结构，双通道电路输出，可同时驱动 2个电机。
相比 L298N 的热耗性和外围二极管续流电路，它无需外加散热片，外围电路简单，只需外接电源滤波电容就可以直接驱动电机，利于减小系统尺寸。对于 PWM 信号输入频率范围，高达 100 kHz 的频率。
CASE-B_3528 10uF ±10% 25V C128259
C0805 CAP-TH_L5.0-W4.0-P5.00-D1.0
1A 有刷直流电机驱动芯片 5.5V C141517
SSOP-24_L8.3-W5.6-P0.65-LS7.6-BL
资料下载 【CSDN】资料：SMT32F103C8T6 电机控制基础教程（TB6612FNG资料） 参考资料 [1] 【嘉立创硬件开源平台】https://oshwhub.com/search?wd=TB6612[2] 【CSDN】STM32入门笔记(02)：麦克纳姆轮、TB6612电机驱动、PID电机控制和编码器学习记录】[3] 电机控制基础教程
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2285178c5014921155c13865633b82bc/" rel="bookmark">
			神经网络常见评价指标AUROC（AUC-ROC）、AUPR（AUC-PR）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		神经网络的性能可以通过多个评价指标进行衡量，具体选择哪些指标取决于任务的性质。以下是神经网络中常见的评价指标：
准确性（Accuracy）： 准确性是最常见的分类任务评价指标，表示模型正确预测的样本数占总样本数的比例。但在某些不平衡类别的情况下，准确性可能不是一个很好的指标。
精确度（Precision）： 精确度是指在所有被模型预测为正例的样本中，实际为正例的比例。精确度关注的是模型预测为正例的准确性。
召回率（Recall）： 召回率是指在所有实际为正例的样本中，被模型正确预测为正例的比例。召回率关注的是模型对正例的覆盖程度。
F1分数（F1 Score）： F1分数是精确度和召回率的调和平均值，综合考虑了模型的准确性和覆盖率。F1分数在不同类别不平衡的情况下比准确性更具意义。
AUC-ROC曲线下面积（Area Under the Receiver Operating Characteristic Curve）（AUC-ROC）（AUROC）： 适用于二分类问题，ROC曲线是以真正例率（True Positive Rate，召回率）为纵轴Y、假正例率（False Positive Rate）为横轴X的曲线，AUC-ROC是ROC曲线下的面积。AUC-ROC通常用于评估模型在不同阈值下的性能。详见：真阳性（TP）：判断为真，实际也为真；伪阳性（FP）：判断为真，实际为假；伪阴性（FN）：判断为假，实际为真；真阴性（TN）：判断为假，实际也为假；
fpr（假正率）： 在二分类中，假正率是被错误地预测为正类别的负样本占所有负样本的比例。计算方式为 fpr = FP / (FP + TN)，其中 FP 是假正例的数量，TN 是真负例的数量。
tpr（真正率）： 在二分类中，真正率是被正确地预测为正类别的正样本占所有正样本的比例。计算方式为 tpr = TP / (TP + FN)，其中 TP 是真正例的数量，FN 是假负例的数量。
ROC空间将伪阳性率（FPR）定义为 X 轴，真阳性率（TPR）定义为 Y 轴。
从 (0, 0) 到 (1,1) 的对角线将ROC空间划分为左上／右下两个区域，在这条线的以上的点代表了一个好的分类结果（胜过随机分类），而在这条线以下的点代表了差的分类结果（劣于随机分类）。
AUC-PR（Area Under the Precision versus Recall Curve）（AUPR）：PR 曲线则反映了精确率Precision（预测为真阳样本占所有预测为阳性样本的比例）和召回率Recall（预测为真阳样本占所有实际真样本的比例）的关系，其曲线下面积被认为相比于 AUROC 更能反映一个模型对真样本的富集能力。
均方根误差（Root Mean Squared Error，RMSE）： 适用于回归任务，RMSE是预测值与真实值之间差异的均方根。对于连续值的预测任务，RMSE常用于度量模型的预测误差。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2285178c5014921155c13865633b82bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/acd1781b9011bf52198177cfef4e4152/" rel="bookmark">
			分享5个免费的Python学习网站，新手小白赶紧收藏起来吧！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近有好多人说刚开始学习，有哪些免费的学习网站可以自学一下。于是，趁着空闲的时间在各大网站上面梳理了一下，找出了5个比较好的学习网站，并且都是免费的，比较适合初学者了解一些基础语法、解决BUG问题。
如果你也喜欢编程，想通过学习Python转行、做副业或者提升工作效率，我也为大家整理了一份 【最新全套Python学习资料】一定对你有用！
需要的朋友可以扫码加V免费领取
如果是大佬的话了解一下就行了，废话不多说了直接上干货吧！
1、Python 官方中文网站 网站地址：https://docs.python.org/zh-cn/3/
官方网站不仅有基础语法参考、Python标准模块介绍，相关的教程也有，平时查接口文档什么的都是比较方便的。
2、w3school 网站地址：http://www.w3school.com.cn/
这是个比较老的网站了，记得刚开始学编程的时候我经常在上面查找Html标签的应用。不过，Python的应用在上面也是有的，忘记了一些内置函数怎么用来这上面查一查还是比较Nice的。
3、菜鸟教程 网站地址：http://www.runoob.com/
这个也不错，只要是你是新手学习上面各类编程语言都有，包括数据库的安装使用等操作步骤都会一步一步的列出来。相信新手朋友看到这个网站肯定会非常喜欢的，想要什么信息直接搜索就成了。
4、python Code Example 网站地址：https://www.programcreek.com/python/
这是一个英文网站，有一些英文功底可以使用这个网站。主要是收集了大量的python模块的使用实例，使用时通过搜索模块名称来查找相关的实例来进行参考。
比如：可以搜索一下datetime是怎么使用的，就可以搜索一下…
可以直接定位到里面的某个函数是怎么使用的，搜索到之后照着写就成了。
5、LearnPython 网站地址：https://www.learnpython.org/
这个网站也是个英文网站，里面包含了一些初级和高级用法，大佬们有需要也可以来尝试一下。
零基础Python学习资源分享 对于0基础小白入门：
如果你是零基础小白，想快速入门Python是可以考虑的！
1、学习时间相对较短，学习内容更全面更集中
2、可以找到适合自己的学习方案
我分享的这份学习资料包含：Python安装包+激活码、Python web开发，Python爬虫，Python数据分析，人工智能、机器学习 等教程，带你从零开始系统性的学好Python！
1、Python所有方向的学习路线 Python所有方向路线就是把Python常用的技术点做整理，形成各个领域的知识点汇总，它的用处就在于，你可以按照上面的知识点去找对应的学习资源，保证自己学得较为全面。
2、Python课程视频 我们在看视频学习的时候，不能光动眼动脑不动手，比较科学的学习方法是在理解之后运用它们，这时候练手项目就很适合了。
3、全套PDF电子书 书籍的好处就在于权威和体系健全，刚开始学习的时候你可以只看视频或者听某个人讲课，但等你学完之后，你觉得你掌握了，这时候建议还是得去看一下书籍，看权威技术书籍也是每个程序员必经之路。
4、清华编程大佬出品《漫画看学Python》 用通俗易懂的漫画，来教你学习Python，让你更容易记住，并且不会枯燥乏味。
5、Python实战案例 光学理论是没用的，要学会跟着一起敲，要动手实操，才能将自己的所学运用到实际当中去，这时候可以搞点实战案例来学习。
6、互联网企业面试真题 我们学习Python必然是为了找到高薪的工作，下面这些面试题是来自阿里、腾讯、字节等一线互联网大厂最新的面试资料，并且有阿里大佬给出了权威的解答，刷完这一套面试资料相信大家都能找到满意的工作。
这份完整版的Python全套学习资料已经上传至CSDN官方，朋友们如果需要可以点击下方链接或扫描下方二v码都可以免费获取【保证100%免费】
最新全套【Python入门到进阶资料 &amp; 实战源码 &amp;安装工具】（安全链接，放心点击）
以上全套资料已经为大家打包准备好了，希望对正在学习Python的你有所帮助！
如果你觉得这篇文章有帮助，可以点个赞呀~
我会坚持每天更新Python相关干货，分享自己的学习经验帮助想学习Python的朋友们少走弯路！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6319bf8faaae7251555c8f0a5ad35ab/" rel="bookmark">
			【大数据】Grafana整合ElasticSearch数据源绘制Dashboard展示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0、前置信息 0.1、版本信息 grafana版本：v8.1.2 ElasticSearch数据源版本：7.6.2 ElasticSearch7.6.2版本对应的Lucene版本：8.4.0 0.2、官网地址 grafana官网地址：Grafana documentation | Grafana documentation grafana模板地址：Dashboards | Grafana Labs Lucene查询官方文档： https://lucene.apache.org/core/8_11_1/queryparser/org/apache/lucene/queryparser/classic/package-summary.html#package_description 0.3、ElasticSearch索引字段信息 { "mappings": { "_doc": { "properties": { "appId": { "type": "keyword" }, "appName": { "type": "text", "analyzer": "ik_max_word" }, "executeTime": { "type": "long" }, "httpCode": { "type": "integer" }, "message": { "type": "text", "analyzer": "ik_max_word" }, "requestIp": { "type": "keyword" }, "requestMethod": { "type": "keyword" }, "requestParams": { "type": "keyword" }, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e6319bf8faaae7251555c8f0a5ad35ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50ea42ac825641a2905d6f7cd2c87ad9/" rel="bookmark">
			VBS有趣程序大全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		WScript.Echo("你好像上当了") WScript.Echo("嘿，兄弟"&amp;TSName) WScript.Echo("我是最强程序员") WScript.Echo("哈,你是天选之子，这你都不知道吗？") WScript.Echo("怎么才来，说~是不是故意不点开") WScript.Echo("哼,我生气拉，等你这么久，心都凉啦。") WScript.Echo("我很生气，后果很严重哦。") WScript.Echo("嘿嘿！你也会很惨滴哦") WScript.Echo("是不是想清除我？") WScript.Echo("那你要点上50下哦，不过会给你惊喜滴") WScript.Echo("还剩49下，快点点哦") WScript.Echo("还剩48下，快点，小笨蛋！") WScript.Echo("还剩47下，对，就这样快点点！") WScript.Echo("还剩46下。要快哦，我先不打扰你工作。") WScript.Echo("还剩45下，记得要快哦！") WScript.Echo("还剩43下") WScript.Echo("还剩42下") WScript.Echo("还剩41下") WScript.Echo("还剩40下") WScript.Echo("还剩39下") WScript.Echo("还剩38下") WScript.Echo("还剩37下") WScript.Echo("还剩36下") WScript.Echo("还剩35下") WScript.Echo("还剩34下") WScript.Echo("还剩33下") WScript.Echo("还剩32下") WScript.Echo("还剩30下") WScript.Echo("还剩29下") WScript.Echo("还剩28下") WScript.Echo("还剩27下") WScript.Echo("还剩26下") WScript.Echo("还剩25下") WScript.Echo("还剩24下") WScript.Echo("还剩23下") WScript.Echo("还剩22下") WScript.Echo("还剩21下") WScript.Echo("还剩20下") WScript.Echo("还剩19下") WScript.Echo("还剩18下") WScript.Echo("还剩17下") WScript.Echo("还剩16下") WScript.Echo("还剩15下") WScript.Echo("还剩14下") WScript.Echo("还剩13下，停停停！！！慢点，我有话要说") WScript.Echo("还剩12下，你继续点我就会消失滴") WScript.Echo("还剩11下，以后就看不到我拉。555555") MsgBox "还剩10下，你现在可以选择停止！", vbYesNo, "WScript.Echo" WScript.Echo("还剩9下。你还点啊，不要我拉？") WScript.Echo("还剩8下，有点伤心拉，干嘛丢弃人家") WScript.Echo("还剩7下。看来你是执意要清除我！") WScript.Echo("还剩6下。对。你就点吧，我恨你！") WScript.Echo("还剩5下，不明白，删除我你就好吗？") WScript.Echo("还剩4下！真要删除我？") WScript.Echo("还剩3下。可是我真的很眷恋你......") WScript.Echo("还剩2下。不要这么绝情嘛，人家是爱你的！") WScript.Echo("还剩1下。哼，既然你这么绝情。也别怪我无义！！！(以上部分借用了网络）") msgbox("你的电脑被我攻击了！") msgbox("赶快交出100000000000万元") msgbox("我才会给你揭破密码！") Dim strName strName = InputBox("请输入密码") WScript.Echo "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/50ea42ac825641a2905d6f7cd2c87ad9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55c6805d4bc68b081fd6c92e42835c5c/" rel="bookmark">
			VS选择Visual C&#43;&#43;中的控制台项目和空项目、Windows桌面应用程序三者之间有什么区别？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VS选择Visual C++中的控制台项目和空项目、Windows桌面应用程序三者之间有什么区别？
在Visual Studio中创建C/C++项目时，可以选择控制台项目、空项目和Windows桌面应用程序，它们有以下区别：
1.控制台项目(Console Application)： 这种项目类型适用于命令行应用程序的开发。它提供一个命令行界面，可以在控制台中进行输入和输出操作，通常用于简单的控制台程序，如计算器、文件处理等。
2.空项目(Empty Project)： 这种项目类型是一个空白的项目模板，没有预定义的代码或配置。开发者可以根据自己的需求自行添加源代码文件、资源文件等，适用于从头开始构建自定义应用程序的场景。
3.Windows桌面应用程序(Windows Desktop Application)： 这种项目类型适用于开发Windows桌面应用程序，
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c46e7fceb983b28013a9d9b6a0502ce1/" rel="bookmark">
			Python开发运维：Celery连接Redis
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、理论
1.Celery
二、实验
1.Windows11安装Redis
2.Python3.8环境中配置Celery
3.celery的多目录结构异步执行
4.celery简单结构下的定时任务
三、问题
1.Celery命令报错
2.执行Celery命令报错
3.Win11启动Celery报ValueErro错误
4.Pycharm 无法 import 同目录下的 .py 文件或自定义模块
一、理论 1.Celery (1) 概念
Celery是一个基于python开发的分布式系统，它是简单、灵活且可靠的，处理大量消息，专注于实时处理的异步任务队列，同时也支持任务调度。
(2) 架构
Celery的架构由三部分组成，消息中间件（message broker），任务执行单元（worker）和任务执行结果存储（task result store）组成。
1）消息中间件 Celery本身不提供消息服务，但是可以方便的和第三方提供的消息中间件集成。包括，RabbitMQ, Redis等等 2）任务执行单元 Worker是Celery提供的任务执行的单元，worker并发的运行在分布式的系统节点中。 3）任务结果存储 Task result store用来存储Worker执行的任务的结果，Celery支持以不同方式存储任务的结果，包括AMQP, redis等 (3) 特点
1）简单 Celery易于使用和维护，并且它不需要配置文件并且配置和使用是比较简单的 2）高可用 当任务执行失败或执行过程中发生连接中断，celery会自动尝试重新执行任务 3）快速 单个 Celery 进程每分钟可处理数以百万计的任务，而保持往返延迟在亚毫秒级 4）灵活 Celery几乎所有部分都可以扩展或单独使用，各个部分可以自定义。 （4）场景
Celery是一个强大的 分布式任务队列的异步处理框架，它可以让任务的执行完全脱离主程序，甚至可以被分配到其他主机上运行。通常使用它来实现异步任务(async task)和定时任务(crontab)。
1)异步任务 将耗时操作任务提交给Celery去异步执行，比如发送短信/邮件、消息推送、音视频处理等等 2)定时任务 定时执行某件事情，比如每天数据统计 二、实验 1.Windows11安装Redis (1)下载最新版Redis
Redis-x64-xxx.zip压缩包到D盘，解压后，将文件夹重新命名为 Redis (2)查看目录
D:\Redis&gt;dir (3)打开一个 cmd 窗口 使用 cd 命令切换目录到 D:\Redis 运行
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c46e7fceb983b28013a9d9b6a0502ce1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b96bf61b91e4b2b5f127cc233aa8e612/" rel="bookmark">
			深度优先遍历和广度优先遍历
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		深度优先遍历 使用递归 function deepTraversal1(node) { const n = []; if (node != null) { n.push(node); for (let i = 0; i &lt; node.child.length; i++) { n.concat(node.child[i]); } } return n; } 广度优先遍历 function deepTraversal2(node) { // 用来记录访问的节点 const n = []; // 用来做遍历的队列 const s = []; if (node) { s.push(node) // 里面运行一圈表示 进行了节点遍历 while (s.length) { const curN = s.shift(); n.push(curN); if (curN.child) { for (let i = 0; i &lt; curN.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b96bf61b91e4b2b5f127cc233aa8e612/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/54/">«</a>
	<span class="pagination__item pagination__item--current">55/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/56/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>