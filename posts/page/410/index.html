<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca325f862bb6ee7a4623ed2f1a55450f/" rel="bookmark">
			基于java的bus公交查询系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本公交查询系统目标是方便市民进行公交信息查询，并且要做到信息不滞后,其主要思想是做到系统管理的人性化,数据处理的可靠性,可维护性,以及程序的健壮性。系统采用JSP编程语言，MYSQL为数据库。开发环境Myeclipse和eclipse均可
要设计一个良好的公交查询系统，就必须首先明确该应用环境对系统的要求。公交查询系统的应用背景为：方便市民搭乘公交车出行；手动（目前）、自动（将来）、及时更新查询数据。因此，该系统需满足以下几方面需求：
1、查询功能：系统需要提供几种不同方式的查询手段，以实现灵活方便地管理整个系统。
2、数据的更新修改：
更新：系统允许管理员级别的用户对数据进行更新、修改并且存盘操作；
编辑：系统允许管理员级别的用户对数据进行编辑、删除的操作，保证现库的真实性与实时性。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43a86c3ce95a1cf5b07a6060aebaec7a/" rel="bookmark">
			括号生成
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目链接：括号生成
题目描述：
数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。
示例：
输入：n = 3
输出：[
“((()))”,
“(()())”,
“(())()”,
“()(())”,
“()()()”
]
代码：
class Solution{ int n; char[] cur = new char[n*2]; List&lt;String&gt; res = new ArrayList(); solve(cur,0,res,0,0); } public void solve(char[] cur,int pos,List&lt;String&gt; res,int left,int right){ if(pos == cur.length){ //if(isOk(cur)) res.add(new String(cur));剪枝前 res.add(new String(cur)); } if(left&lt;(cur.length/2)){ //左括号数量一定小于N cur[pos]= '('; solve(cur,pos+1,res,left+1,right); } if(right&lt;left){ //右括号数量一定小于左括号 cur[pos]= ')'; solve(cur,pos+1,res,left,right+1); } } //判断是否合法 public boolean isOK(char[] ch){ int cnt = 0; for(char c:ch){ if(c == '(') cnt++; else cnt--; } return cnt == 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18fdc1f779dd6fa0536924630bb250a8/" rel="bookmark">
			[亲测有效]win10如何快速有效的去除快捷方式箭头
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先强烈建议不要用删除注册表IsShortcut键值的做法来删除快捷方式箭头，这样会导致出现很多问题。
包括Win+X菜单打不开，右击计算机图标点击管理报错，应用无法固定到任务栏等。
目前我这个方案应该是比较完美的了。至少不会出现奇怪的故障。
注：文章末尾有资源链接和可直接复制的脚本。
打开注册表位置
HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Shell Icons 在右侧新建【字符串值】，名称为【29】，内容为【C:\WINDOWS\system32\imageres.dll,197】
imageres.dll,197这个图标是一个近似全透明的图标，但是其实并不完全空白的，如下图。
正常情况下并不影响使用，不特别注意也不会发现。
实在有强迫症的可以自己拿工具画一个只有1像素的图标，放到任意位置，然后把上述注册表29这个键值的内容改为自己画的这个图标文件的位置就可以了。
最后重启资源管理器或者重启电脑即可。
一像素的图标效果如下，缩放等级为“大图标”的情况下正常，再继续放大会和下面GIF图里一样出现透明边框。
（不要用完全透明的图标，否则在部分情况下快捷方式箭头会变成一个黑色正方形）
如图为从最小图标到最大图标的缩放过程中，黑色方块的显示形式，部分大小下是没有黑块的，缩放等级为“大图标”之后再继续放大，黑块会变成一个透明方框
盾牌图标也想去掉的话，再按上述同样步骤添加一条名称为77的键值就可以了
最后是给懒人准备的批处理，复制下来粘贴到文本文档中，保存，后缀名改为bat，右击以管理员身份运行即可。
reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Shell Icons" /v 29 /d "%systemroot%\system32\imageres.dll,197" /t reg_sz /f taskkill /f /im explorer.exe attrib -s -r -h "%userprofile%\AppData\Local\iconcache.db" del "%userprofile%\AppData\Local\iconcache.db" /f /q start explorer pause 想恢复也很简单，把自己加过的注册表键值删除，再重启资源管理器或者重启电脑即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d1a815bb250dcd63112425f9c08bae7/" rel="bookmark">
			LLDP邻居信息表相关OID
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		lldpRemTable详细描述 远端邻居信息表，该表的索引是lldpRemTimeMark，lldpRemLocalPortNum，lldpRemIndex。
OID
节点名称
数据类型
最大访问权限
含义
实现规格
1.0.8802.1.1.2.1.4.1.1.1
lldpRemTimeMark
INTEGER
not-accessible
此表项的时间过滤器。
实现与MIB文件定义一致。
1.0.8802.1.1.2.1.4.1.1.2
lldpRemLocalPortNum
Integer32(1..4096)
not-accessible
远端设备端口号。
实现与MIB文件定义一致。
1.0.8802.1.1.2.1.4.1.1.3
lldpRemIndex
Integer32
not-accessible
远端邻居索引。
实现与MIB文件定义一致。
1.0.8802.1.1.2.1.4.1.1.4
lldpRemChassisIdSubtype
INTEGER {
chassisComponent(1),
interfaceAlias(2),
portComponent(3),
macAddress(4),
networkAddress(5),
interfaceName(6),
local(7)
}
Read-only
远端设备ID子类型。
实现与MIB文件定义一致。
1.0.8802.1.1.2.1.4.1.1.5
lldpRemChassisId
OCTET STRING (SIZE (1..255))
Read-only
远端设备ID。
实现与MIB文件定义一致。
1.0.8802.1.1.2.1.4.1.1.6
lldpRemPortIdSubtype
INTEGER {
interfaceAlias(1),
portComponent(2),
macAddress(3),
networkAddress(4),
interfaceName(5),
agentCircuitId(6),
local(7)
}
Read-only
远端设备的端口ID子类型。
实现与MIB文件定义一致。
1.0.8802.1.1.2.1.4.1.1.7
lldpRemPortId
OCTET STRING (SIZE (1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d1a815bb250dcd63112425f9c08bae7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13c642143a8cfbace2b6288d802961c3/" rel="bookmark">
			Python常用的内置函数（会持续增加的）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python 常用内置函数如下： 不是原创，但是都是自己整理的
1. abs()函数返回数字的绝对值。 print( abs(-45) ) # 返回 45 print("abs(0.2):",abs(0.2)) # 返回 abs(0.2): 0.2 2. all() 函数用于判断给定的参数中的所有元素是否都为 TRUE，如果是返回 True，否则返回 False。元素除了是 0、空、None、False 外都算 True；空元组、空列表返回值为True。 print( all( [0.1,1,-1] ) ) # 返回 True print( all( (None,1) ) ) # 返回 False（其中一个元素为None） print( all( [0,1,-1] ) ) # 返回 False（其中一个元素为0） print( all( [" ","a",""] ) ) # 返回 False(第三个元素为空) 3. any() 函数用于判断给定的参数是否全部为False，是则返回False，如果有一个为True，则返回True。 元素除了是 0、空、False外都算 TRUE。 # 参数全部不为 0、空、FALSE print(any("-45")) # True print(any(["
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13c642143a8cfbace2b6288d802961c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a50130a276995943f0ea4c4e99aab477/" rel="bookmark">
			安卓10蓝牙问题_安卓系统蓝牙服务com.android.bluetooth的使能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		蓝牙系统服务层的使能流程分析 蓝牙服务层的使能基础是其初始化完成，也就是AdapterService通过onBind()将AdapterServiceBinder上报给bind该服务的调用者。我们现在应该都知道在安卓系统中bind该服务的为BluetoothManagerService。本篇我们就从蓝牙服务管理收到bind的回调开启蓝牙使能流程的分析。
熟悉安卓系统中bind服务机制的小伙伴应该都知道，该bind调用会连同回调函数ServiceConnection一起下发给系统，这样服务bind成功后通过该回调上报到对应的调用层，在蓝牙系统里就是蓝牙服务管理。通过如下转换蓝牙服务管理就获取到蓝牙服务层AdapterService的函数接口：
IBinder service = (IBinder) msg.obj；mBluetooth = IBluetooth.Stub.asInterface(Binder.allowBlocking(service))； 随着蓝牙服务层接口的取得，就会接着执行蓝牙使能的操作
服务层使能的具体流程可以参照如下时序图：
从以上时序图大概能总结出蓝牙服务层使能基本上分为三个步骤：
使能低功耗蓝牙，也就是GattService使能蓝牙协议栈使能配置文件中支持的各项其他协议的服务 蓝牙状态涉及到如下状态值及含义：
public static final int STATE_OFF = 10，蓝牙关闭public static final int STATE_TURNING_ON = 11，蓝牙正在打开public static final int STATE_ON = 12，蓝牙打开public static final int STATE_TURNING_OFF = 13，蓝牙正在关闭public static final int STATE_BLE_TURNING_ON = 14，蓝牙BLE正在打开public static final int STATE_BLE_ON = 15，蓝牙BLE打开public static final int STATE_BLE_TURNING_OFF = 16，蓝牙BLE正在关闭 结合整个蓝牙打开基本上先打开低功耗蓝牙BLE，再打开传统蓝牙BT，所以蓝牙的状态变化为：
10 -&gt; 14 -&gt; 15 -&gt; 11 -&gt;12
反之，蓝牙关闭的状态变化为：
12 -&gt; 13 -&gt; 15 -&gt; 16 -&gt; 10
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a50130a276995943f0ea4c4e99aab477/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c43a9a289e620804b3b06dcdf93a753/" rel="bookmark">
			算法设计与分析_算法设计与分析之分治策略的设计思想
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 分治策略的基本思想 分治策略(Divide and Conquer)
将原始问题划分或归结为规模较小的子问题递归或者迭代的求解每个子问题将子问题的解综合得到原问题的解 在设计分治策略时，一定要注意以下几点：
子问题与原问题的性质完全一样子问题之间可以彼此独立的求解递归停止时，子问题可以直接进行求解得出结果。 下面以二分检索的例子来分析分之策略的思想。
1.1 二分检索的设计思想 设算法：Binary Search(T，l，r，x)。输入：排好序的数组T ，下标从l到r；数x。输出：j //若x在T中，则为下标，否则为0 给出下面的伪码
二分检索的设计思想： 通过x与数组的中位数进行比较，将原问题归结为规模减半的子问题。如果x小于中位数，则子问题由小于x的数构成，否则子问题由大于x的数构成。对子问题进行二分搜索算法当子问题为1时，直接比较T[m]与x，若相等则返回m，否则返回0. 二分检索最坏情况下时间复杂度分析，在前面的文章中已经学习了如何分析算法的时间复杂度，如果不懂下面的公式的，可以多看看前面的文章。
W(n)=W(⌊n/2⌋)+1
W(1)=1 可以解出：
W(n)=⌊logn⌋+1
1.2 二分归并排序的设计思想 设算法：Merge Sort(A,p,r)输入：A[p…r]输出：元素按从小到大排序额数组A 先看以下伪码：
二分归并的设计思想：
将原问题划分为规模为n/2的两个子问题继续划分，将原问题归结为4个子问题，继续…当子问题估摸为1时，划分结束。从规模1到n/2，陆续归并被排好序的两个数组。每归并一次，数组规模扩大一倍，直到原始数组。 二分归并排序的时间复杂度：假设n为2的幂次方，二分归并排序最坏时间复杂度为：
W(n)=2W(n/2)+n−1
W(1)=0 W(1) = 0W(1)=0
可以解出：
W(n)=nlogn−n+1 W(n) = nlogn - n + 1W(n)=nlogn−n+1
仔细体会着其中的分治策略
1.3 Hanoi塔的递归算法 Hanoi塔的算法设计思想：
将原问题归结为规模为n-1的两个子问题继续归结，将原问题归结为n-2的四个子问题.继续… ，当子问题规模为1时，归约过程截止。从规模为1到n-1，陆续组合两个子问题的解，知道规模为n。 小结 将原问题归约为规模较小的子问题，子问题与原问题性质完全一样子问题规模足够小时，可以直接求解算法可以递归也可以迭代实现算法的分析方法为：递推方程 原文链接：https://blog.csdn.net/qq_37375427/article/details/101611795 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf4ee420e1efd4dbbd67e9c4cceb84fd/" rel="bookmark">
			电脑计算机在哪里_读计算机专业买笔记本电脑还是台式电脑好？-笔记本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很多大学生都想在开学来临之际，入手一台电脑来打发无聊的校园生活，但是究竟买笔记本电脑好，还是台式电脑好呢？这个问题不可一概而论，只能相对而言，一起来看看吧！
1、根据宿舍状况进行选购
要知道，大学四年都是在寝室里住宿的，不同的学校，他们的宿舍大小、摆放格局也是不同的，一般大学宿舍都是4人/间，寝室小的话，可能除了床，剩余的空间只够放两张桌子了，如果买台式电脑的话，要往哪里放呢？所以此时笔记本是最好的选择；而如果寝室大的话，那么每人都会有一个属于自己的学习桌，有了学习桌就好办了，买了台式机，肯定就有它安置的地方.
2、根据使用需求进行选购
您说读的是计算机专业，据我了解，该专业在上课时就得使用电脑，否则无法学习，所以笔记本电脑就需要每天教室→宿舍，宿舍→教室这样来回带着，如果你买的是台式电脑，你要怎么携带呢？所以此时笔记本电脑才是最佳的选择。不过也不排除另一种情况，有些家境好的同学，会笔记本台式机都购买，笔记本用来带到教室里学习，台式机则放在宿舍使用，因为毕竟台式机在配置和使用方面来说，肯定比笔记本更加的顺手，特别是一些喜欢玩游戏的同学，台式机才是他们最喜欢的.
总结∶买笔记本电脑好，还是台式电脑好，这个问题是不能一概而论的，关键是要看你的使用需求和环境状况，不过读计算机专业的同学，为了学习的需要，建议还是购买笔记本电脑为好，毕竟学生还是要以学业为主！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/328a441fbeb504c7d11d77e814798c8c/" rel="bookmark">
			台式电脑怎么连接手机热点_电脑搜不到手机热点 为什么搜不到手机热点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现在很多人的手机流量都是无限制的，有些用户在没有wifi的情况下，会用手机开热点给电脑连接上网，但偶尔也会遇到电脑连不上手机热点的情况，那么电脑搜不到手机热点是怎么回事?为什么搜不到手机热点?接下来详细为大家介绍：
电脑搜不到手机热点是怎么回事?
1、首先打开手机中的设置。
2、在设置功能中的网络和连接的下方找到蓝牙和个人热点，要确保这两个先关闭。
3、关闭后再次点击【个人热点】，点击打开个人热点设置界面。
4、接下来在个人热点设置界面中点击【便携式WLAN热点】后方的选项打开个人热点，大家试着看电脑能否找到个人热点。
5、如果还找不到的话则是手机网络的原因，需要重置相关的网络设置，点击打开【更多设置】界面，然后点击【备份和重置】。
6、接下来在备份和重置界面中找到并点击【重置网络设置】选项。
7、最后在重置网络设置里点击底部的【重置设置】，这样在搜索就能找到手机热点了。
电脑搜不到手机热点是怎么回事?以上就是今天为大家介绍的全部内容，希望可以帮助到大家。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eabc574b71c21ec826dc7cd6770058e7/" rel="bookmark">
			苹果耳机安卓手机可以用吗_评测：安卓手机很好用的真无线蓝牙耳机，还可以为手机充电？...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自从苹果推出AirPods以后，真无线蓝牙耳机正式开始进入人们的视线，它不仅配对过程简单，开盒即用，而且没有小巧轻便，没有线材的束缚，征服了一票果粉。然而这样耳机只能苹果手机使用，安卓手机却没办法体验。不过随着技术的不断进步，市面上涌现出一批安卓手机也可以使用的真无线蓝牙耳机，今天为大家介绍的这款产品就是一款安卓、苹果都可以使用的真无线蓝牙耳机。它就是南卡N2！
首先，包装方面，南卡N2非常简约，包装盒采用抽屉式设计，抽屉外的盒子采用高淡淡的墨绿色，抽屉则采用橙色设计，两种颜色搭配在一起，给人一种青春活力的气息。
打开包装盒可以看到盒子南卡N2真无线蓝牙耳机的充电仓，另外包装盒内还包含一条Type-C的数据线、耳机的橡胶耳塞以及说明书，整体来说非常简单！
南卡N2的充电仓采用金属材质，并具有磨砂质感，小编拿到的这款产品是玫瑰金，看上去非常精致，很像女生用户化妆盒。
充电仓前后两侧采用黑色透明亚克力材质，正面内前着南卡的logo，看上去非常高大上，而且这个logo在耳机充电时还可以闪烁，极具科技感！
南卡logo灯总还有四种闪烁的频率，闪烁一次，表示充电电量还有25%，连续闪烁两次表示电量还有50%，连续闪缩三次，表示电量还有75%，连续闪烁四次，表示电量充满。
相对其他真无线蓝牙耳机的充电仓都要大，这就让这款充电盒拥有更大的电池容量，它容量高达3000mAh，可以为南卡N2带来超过120小时的续航时间，并且为南卡N2充电24次，相当耐用。
不仅如此，这款充电仓设计有USB-A接口，当手机没电的时候，它就会变成一块充电宝，为手机带来更长久的续航时间！而在另一侧是Type-C的接口，充电时更加方便。
南卡N2的充电仓也是采用抽屉式设计，拉开抽屉以后就可以看到南卡N2耳机了，N2耳机在外观设计上也非常小巧，单只耳机的重量仅为4g，佩戴以后几乎感觉不出它的存在。
不仅如此，这款耳机采用入耳式设计，可以有效的过滤环境中的噪音，耳机上拥有一块圆形的面板，在该面板周围有一个圆形的LED灯带，充电的时候，灯带就会亮起来，很是科幻。
另外，这块圆形的面板还可以进行触摸操作，双击右耳增加音量，双击左耳减少音量，长按左耳上一曲，长按右耳下一曲，轻按暂停播放音乐，在来电状态下，轻按接听电话，长按拒接电话。苹果手机使用时连续触摸三次还可以唤醒Siri。不过在实际使用，左右耳的双击、长按操作很容易忘记，而且这块触摸板特别灵敏，拿下戴起耳机都有肯能误触到！
南卡N2两只耳机可以同时连接一台手机，也可以分开连接不同的手机使用，也就是说你丢失一个耳机以后，另外一个耳机还可以使用，也很方便。这款耳机采用蓝牙5.0技术，可以最远支持10m的传输距离，很是强大！
音质方面，这是一个仁者见仁，智者见智的事，小编在这里只能大体描述一下这款耳机的听感，在南卡N2的音域比较宽广，在低频方面，这款耳机处理的并不是很干净，但是强于市面上百十块的耳机，而在高频方面，这款耳机还不错。整体细节丢失并不是很明显。总体来说，这款耳机的音质表现还不错。
而在实际使用过程中，它还有很多优点，从充电仓里拿出来以后，南卡N2就会自动开机，如果手机蓝牙正处于打开状态，它会自动配对，也会帮你省去配对的烦恼。而且这款耳机还有一个强于其他产品的地方，就是它的通话功能也很稳定，而且你说什么对方也可以听的非常清楚。
总体来说，南卡N2有着多种优点，小巧便携，无感连接，双耳单独使用，充电仓可以变身充电宝，通话清晰，但是在音乐的表现方面，优点略逊于其他专业耳机。总体来说，这款耳机还是推荐给大家使用。毕竟音质这东西是个玄学，每个人的听感都不一样～
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db4bcab0b91f55be8ee69cacd2bb2a49/" rel="bookmark">
			Android studio 无法创建layout_land文件解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 解决在Android studio 无法创建layout_land文件的问题 问题描述： 不知道选哪个来新建layout_land文件夹？新建layout_land文件无法放入xml文件？基于2的情况下，拖动过来的xml文件标红报错？ 问题原因👇 你的layout_land文件夹错辽… 解决方法/如何正确建立layout_land文件夹 如图：
step1: step2: step3: 好啦，问题就完美的解决啦~ 再也没有标红了，妈妈也再也不用担心我的bug了 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/414ff7cfc932ebf711a534e80b42b4cd/" rel="bookmark">
			Windows &amp;&amp; 在Windows中关闭/最小化窗口的几种快捷方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Win + Ctrl + D 创建虚拟桌面
Win + Ctrl + F4 关闭当前虚拟桌面
Win + Ctrl + ←向左切换虚拟桌面
Win + Ctrl + → 向右切换虚拟桌面
ALT+Esc 可以使当前窗口最小化。
Windows 徽标键 + D　显示和隐藏桌面
Windows 徽标键 + M　最小化所有窗口
Windows 徽标键 + T　在任务栏上循环切换应用
Windows 徽标键 + R　打开“运行”对话框
Windows 徽标键 + 逗号 (,)　临时快速查看桌面
Windows 徽标键 + Pause　显示“系统属性”对话框
Windows 徽标键 + Tab　打开“任务视图
Windows 徽标键 + 向上键　最大化窗口
Windows 徽标键 + 向下键　从屏幕中删除当前应用或最小化桌面窗口
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/414ff7cfc932ebf711a534e80b42b4cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7dfca89be7be42aa2dedc2931641a2de/" rel="bookmark">
			通用API接口签名算法（参考淘宝）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java接口签名算法 JavaScript接口签名算法 内容转自 ：https://blog.kfzsy.com/api-sign.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/306010370301882d2e34e8a60c1b14dc/" rel="bookmark">
			springboot 大文件上传 java.lang.OutOfMemoryError
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		错误代码 @PostMapping("/upload") public ResultMsg algorithmFile(@RequestParam("file") MultipartFile file) { String fileName = file.getOriginalFilename(); String[] fileNamePart = fileName.split("\\."); String fileNameWithPath = filePath + UUID.randomUUID().toString(true) + "." + fileNamePart[fileNamePart.length - 1]; try { Files.write(Paths.get(fileNameWithPath), file.getBytes()); } catch (IOException e) { e.printStackTrace(); } return new ResultMsg(ResponseCodeEnum.SUCCESS.getIndex(), fileNameWithPath, "上传成功"); } 正确代码 @PostMapping("/upload") public ResultMsg algorithmFile(@RequestParam("file") MultipartFile file) { String fileName = file.getOriginalFilename(); String[] fileNamePart = fileName.split("\\."); String fileNameWithPath = filePath + UUID.randomUUID().toString(true) + "." + fileNamePart[fileNamePart.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/306010370301882d2e34e8a60c1b14dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d9a7716823be78ec8d1c683253d2a7e/" rel="bookmark">
			usdt兑换法币
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		usdt兑换美元、rmb
需要跨国汇款 兑换的话可以用usdt兑换
!
在这里插入图片描述
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bcf166c5dd11ea2c82589e70ee5ab5ff/" rel="bookmark">
			C语言数组指定初始化器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C99增加了一个新特性：指定初始化器。利用该特性可以初始化指定的数组元素。例如，只初始化数组中的最后一个元素。对于传统的的C初始化语法，必须初始化最有一个元素之前的所有与还俗，才能初始化它：
int arr[6]={0,0,0,0,0,212];//传统的语法
而使用C99的新特性：
int arr[6]={[5]=212};
这样写和上面的结果是一样的，由于前几个元素没有初始化，所以编译器会自动把它们设置为0。
如果指定初始化器后面有更多的值，如：
int arr[8]={[5]=212,3,4};
这个时候arr[6]就初始化3，另外如果再次初始化之前指定的元素，那么最后的初始化将会取代之前的初始化。
如果未指定数组元素的大小的话
如：int arr[]={1,[6]=23,4}
这个时候编译器会把数组的大小设置为足够装得下初始化的值。上面这个数组的长度就是8.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18665ebbbead3a878ac1d7e2f5ec83ec/" rel="bookmark">
			数组的声明、初始化、赋值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、数组的声明
#include&lt;stdio.h&gt;
int main(){
float candy[365];//通过声明告诉编译器数组元素的个数和类型
char code[12];//内含12个char类型元素的数组
int states[50];//内含50个int类型元素的数组
/*数组的编号从0开始，因此candy[0]代表数组第一个元素
candy[364]代表数组的第365个元素*/ return 0;
}
二、数组的初始化（对于自动存储类型【数组在函数内部声明且声明时未使用关键字static】必须先初始化，才能使用，对于一些其他的存储类别的变量和数组，若声明时未初始化，编译器会自动把他们的值设为0）
#include&lt;stdio.h&gt;
#define SIZE 4
int main(){
/*完全初始化*/
int powers[8]={1,2,4,8,16,32,64};
/*部分初始化*/
int some_data[SIZE]={12,13};//推荐使用符号常量SIZE表示数组大小
/*省略方括号里的数字，让编译器自动匹配数组大小和初始化列表中的项数*/
const int days[]={31,28,31,30,31};//针对这样的数组的大小用sizeof(days)/sizeof(days[0])来计算更合适 for(int i=0;i&lt;SIZE;i++){
printf("%2d%14d\n",i,some_data[i]);//如果部分初始化，剩余元素就会被初始化为0 } for(int i=0;i&lt;sizeof days/sizeof days[0];i++){
printf("%2d %d\n",i+1,days[i]);
}
return 0;
} 三、使用初始化器
#include&lt;stdio.h&gt;
#define MONTHS 12
int main(){
int days[MONTHS]={31,28,[4]=31,30,31,[1]=29};/*下标为4，即第五个元素指定赋值为31，
那么后面的值也随之被初始化为30,31，days[1]由于后面被初始化为29，覆盖了之前初始化为28 */ int i;
for(i=0;i&lt;MONTHS;i++){
printf("%2d %d\n",i+1,days[i]);
}
return 0;
} 四、数组的赋值
/*数组元素的赋值*/
#include&lt;stdio.h&gt;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/18665ebbbead3a878ac1d7e2f5ec83ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa550f2a40cd297b84f5ab278726baa1/" rel="bookmark">
			交换机的Access口与Trunk口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基本概念
Access类型的端口只能属于1个VLAN，一般用于连接计算机的端口；
Trunk类型的端口可以允许多个VLAN通过，可以接收和发送多个VLAN的报文，一般用于交换机之间连接的端口；
处理流程
Acess端口收报文：收到一个报文,判断是否有VLAN信息：如果没有则打上端口的PVID，并进行交换转发,如果有则直接丢弃（缺省）
Acess端口发报文：将报文的VLAN信息剥离，直接发送出去
trunk端口收报文： 收到一个报文，判断是否有VLAN信息，如果没有则打上端口的PVID，并进行交换转发；如果有判断该trunk端口是否允许该 VLAN的数据进入：如果允许则报文携带原有VLAN标记进行转发，否则丢弃该报文。
trunk端口发报文： 比较端口的PVID和将要发送报文的VLAN信息，如果两者相等则剥离VLAN信息，再发送，否则报文将携带原有的VLAN标记进行转发。
总结
1、Access 端口可接受并转发的数据来源：
1）来自PC的无VLAN信息数据包；
2）从一个Access口入打上VLAN标记在交换机内转交给相同VLAN的access口去掉标记的无VLAN信息数据包；
3）Access 端口发送出去的数据包无VLAN信息，可被PC接受或Access口接受。
示例：
上图中，pc1不能ping通pc2，因为同一交换机内从pc1进入交换机A的access口的数据包被打上了VLAN10的标记，而和pc2相连的access的是VLAN20，从上面总结的2）条不满足，无法ping通。同理，pc1和pc3也不能ping通。
上图中，pc2和pc3能互ping通。因为数据包从pc2进入交换机A的access口时，被打上了VLAN20的标记；交换机A与B想连的access口是VLAN20，所以数据包可以从该口发出。发出的时候去掉了VLAN20的标记，到B时，由于没有标记，可以被B的左边的access口接收并打上VLAN10的标记。由于B的右边的access口也属于VLAN10，所以数据包可以从该口出（出的时候去除掉VLAN10的标记，并到达pc3）
2、Trunk 端口可接受并转发的数据来源：双绞线相连的一对Trunk口或同一交换机上的两个Trunk口可以将数据包（有或无VLAN信息）原封不动的从一端传到另一端。
1)上图中pc1和pc3可以相通，因为数据包从pc1进入A的access口是打上了VLAN10的标记，A的右边trunk口可以接受数据包，并转发到B的trunk口（无论vid是否等于pvid）。而B的acces属于VLAN10所以pc3能收到数据包。
2）同理，pc2和pc6相通
总结 收的时候： access口只要没有pvid的，trunk口除了没有pid的还要自己允许的pvid
发的时候： access口剥除所有pvid，trunk口只剥除自己允许的pvid其它的不动放过
trunk允许接收的pvid类型比access多，access发送剥除pvid比trunk彻底
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99bd140e426ac8b9a0072e55e664718a/" rel="bookmark">
			计算机网络重点知识解析（1）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		总结一下计算机网络知识
文章目录 OSI七层网络协议TCP/IP协议模型TCP协议UDP协议TCP和UDP协议的区别RTT和RTOTCP的滑动窗口TCP 拥塞控制 OSI七层网络协议 先来一张网络协议图：
简单解释一下各个协议，可结合图片理解：
物理层
传输比特流（0101机器码-&gt;电流强弱-&gt;0101机器码）。
定义了物理设备的标准，如网线类型，光纤接口类型，传输介质的传输色率等。
数据链路层
格式化数据以进行传输，控制对物理介质的访问，错误检测纠正。
将比特数据组合成帧。
交换机工作在这一层，对帧解码，将数据发送到正确接收方。
网络层
将网络地址翻译成物理地址，将数据从发送方路由到接收方。
路由器属于网络层。
ip协议在网络层。
传输层
分割上一层数据，把数据交给网络层，保证数据传输。
tcp udp协议定义在传输层。
会话层
管理不同机器间的会话。
表示层
解释信息的语法语义以及它们的关联。
应用层
定义各种应用程序的协议，如http协议。
TCP/IP协议模型 tcp/ip协议是基于osi协议定义的，如下图：
TCP协议 TCP的三次握手：
通过三次握手来建立TCP连接，其特点如下：
1，面向连接的，可靠的，基于字节流的传输层通信协议。
2，把应用层数据分割成包，通过ip层传输给目标协议的tcp层。
3，数据包有序号，对方收到则返回ack确认，否则重传。
TCP报文头：
简单介绍下各个组件：
Source Port：源端口 。
Destination Port：目标端口。
Sequence Number：数据序列号。
ACK Number：期望收到的对方发来的下一个报文的第一个字节的序号。
Offset：tcp报文数据距离起始字段的距离。
Tcp Flags：
urg：紧急指针标志 ，有效0无效。
ack：确认序号标志，1有效0无效。
psh：push标志 1表示带有push标志的数据，应用方收到数据尽快给应用程序处理，而不是在缓冲区排队。
rst：重置连接标志，处理错误连接，拒绝非法报文段和连接请求。
syn：同步序列号，用于建立连接过程。
fin：finish标识，用于释放连接，为1表示关闭本方数据流。
Window：发送接收端的缓存大小，称为窗口，用处是控制速率，控制流量。
Urgent Pointer：紧急数据。
TCP通过三次握手建立一次全双工的通信，看下TCP三次握手的简单图解：
通过四次挥手来释放连接，看下图解：
UDP协议 看下UDP报文的构造：
Internet 协议集支持一个无连接的传输协议，该协议称为用户数据报协议（UDP，User Datagram Protocol）。UDP 为应用程序提供了一种无需建立连接就可以发送封装的 IP 数据包的方法
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/99bd140e426ac8b9a0072e55e664718a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d117072a71e3353c016ef9f5dc9114c/" rel="bookmark">
			MOS管
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一章 MOS管-MOS管G极串联小电阻的作用 文章目录 前言一、电阻的作用是什么？二、两个作用1.限制G极的电流2.抑制振荡 总结 前言 在开关电源的电路中，我们经常可以看到功率MOS管的G极通常会串联一个非常小的电阻，可以是几欧姆到几十欧姆，那这个电阻的作用是什么呢？
一、电阻的作用是什么？ 如上图开关电源，G串联电阻R13
这个电阻的作用有2个作用：限制G极电流，抑制振荡。
二、两个作用 1.限制G极的电流 限制G极电流：
MOS管是由电压驱动的，是以G级电流很小，但是因为寄生电容的存在，在MOS管打开或关闭的时候，因为要对电容进行充电，所有瞬间电流还是比较大的。特别是在开关电源中，MOS管频繁的开启和关闭，那么就要更要考虑这个带来的影响了。
如上图，MOS管的寄生电容有三个，Cgs，Cgd，Cds
一般在MOS管规格书中，一般会标下面三个参数：Ciss，Coss，Crss，他们与寄生电容的关系如下：
Ciss = Cgs+Cgd
Coss= Cds+Cgd
Crss = Cgd
如以MOS管FDS2582为例：
Ciss=1290pF，可以看到，这个寄生电容是很可观的。
简单估算一下，假设Vgs=10V，dt=Tr(上升时间)=20ns ，Ciss=1290pF，那么可得G极在开关时的瞬间电流I=Ciss*dVgs/dt =0.6A。
在基极串联一个电阻，与Ciss形成一个RC充放电电路，可以减小瞬间电流值，不至于损毁MOS管的驱动芯片。
因为增加的这个电阻，会减缓MOS管的开启与通断时间，增加损耗，所以不能接太大。这也是为什么电阻是几欧姆或者几十欧姆的原因所在。
2.抑制振荡 MOS管接入电路，也会有引线产生的寄生电感的存在，与寄生电容一起，形成LC振荡电路。对于开关方波波形，是有很多频率成分存在的，那么很可能与谐振频率相同或者相近，形成串联谐振电路。
串联一个电阻，可以减小振荡电路的Q值，是振荡快速衰减，不至于引起电路故障。
总结 总之在MOS管的G极串联一个小电阻的主要作用有两个，第一个是限制G极电流，因为MOS管中有寄生电容的存在，MOS管的打开和关闭，会对电容进行充电，所以瞬间的电流较大。第二是抑制振荡，MOS管接入电路中，也会有引线产生的寄生电感的存在，与寄生电容一起，形成LC振荡电路。串联一个电阻，可以减少振荡电路的Q值，使振荡快速衰减，不至于引起电路故障。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c88f4dd4617d35069142d1604e2624e/" rel="bookmark">
			（3）Ajax数据抓取
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ajax数据抓取 序言 通过前几章的学习我们已经了解了爬虫的工作原理和一些基本库的使用。有时候在使用requests库或urllib库抓取页面时，得到的结果可能和在浏览器中看到的不一样。这是因为有些浏览器中的页面是经过JavaScript处理数据后生成的结果。
这些数据的来源有很多种，可能是通过Ajax加载的，也可能是包含在HTML文档中的，还有是经过JavaScript和特殊的算法计算后生成的。
对于第一种情况，是一种异步加载方式，原始的页面最初不会包含某些数据，原始页面加载完成后，在通过JS向服务器发送一个或多个请求获取数据，数据才会呈现在网页上，这其实就是发送了一个Ajax请求。
Ajax的基本原理 （1）发送请求
我们知道，JavaScript可以实现页面的各种交互功能。Ajax也不例外，它的底层也是JavaScript实现的。要使用Ajax技术，需要创建一个XMLHttpRequest对象。
在网页中为某些事件的响应绑定异步操作：通过上面创建的xmlhttp对象传输请求、携带数据。在发出请求前要先定义请求对象的method、要提交给服务器中的那个文件进行处理、要携带哪些数据，以及判断是否异步。
其中，与普通的request请求提交数据一样，这里也分为两种方法：GET和POST，在实际使用时可根据需求选择：
1.传输方法：GET通过地址栏传输，POST通过报文传输。
2.传输长度：GET参数有长度限制（受限于URL长度），而POST无限制。
3.传输效率：GET方法，浏览器会将HTTPheader和data一并发出，服务器响应200（返回数据）；而对于POST，浏览器先发送header，服务器响应100（continue），浏览器再发送data，服务器再响应200。因此GET比POST更快。
4.安全：GET传输的data会展示在地址栏中，不安全。（不能用来传输密码等私密信息）。
（2）解析请求
服务器在收到请求后，就会把附带的参数数据作为输入传给处理请求的文件，然后该文件根据传入的数据做出反应，最终返回结果，并通过response对象发出去。客户端根据xmlhttp对象来获取response的内容，返回的response内容可能是HTML也可能是JSON，接下来只需要在方法中用JavaScript作进一步的处理即可。
（3）渲染页面
JAvaScript有改变网页内容的能力，所以在通过Ajax请求获取到返回数据后，通过解析就可以调用JavaScript获取指定网页DOM对象进行更新、修改等数据处理了。
Ajax有其特殊的请求类型，它叫做xhr。
使用Python模拟Ajax请求数据 分析请求
下面分析一下请求，使用浏览器打开网址：https://data.variflight.com/analytics/CodeQuery。
（1）按F12键进入开发者工具，选择【Network】选项卡，在条件搜索框中输入“PEK”并单击【搜索】按钮，可以看到【Network】选项卡下出现了很多条目。
（2）然后单击【Type】进行筛选，找到名称为“airportCode”的请求并单击。
（3）单击之后，可以看到【header】下面有很多关于请求的详细信息，通过观察发现，请求链接RequestURL为“https://data.variflight.com/analytics/Codeapi/airportCode”，请求方法Request Method为“POST”，继续拖动滚动条到最下方From Data处，可以看到这里有两个参数：key和page，key就是输入PEK要查询的三字码，page是页数。
分析响应结果
选择【Preview】选项卡，将会出现JSON格式的内容，可以看到有3个信息，一是code，代表响应状态码是失败还是成功；二是data，data就是我们想要的内容，里面包含了北京机场的相关信息；三是message，提示信息。
代码实现 POST方法
import requests import json url="https://data.variflight.com/analytics/Codeapi/airportCode" data={ 'key':'PEK', 'page': 0 } res=requests.request("post",url,data=data) text=res.text con=json.loads(text) print(con["data"]) GET方法
import requests import json url="https://data.variflight.com/analytics/Codeapi/airportCode" data="key=PEK&amp;page=0" res=requests.request("get",url+'?'+data) text=res.text con=json.loads(text) print(con["data"]) 注意对于这个请求使用GET方法会返回错误，因为这个Ajax请求是以POST方法请求的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8583faac7af7bf364334eb180b248010/" rel="bookmark">
			机器学习基础概念
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 机器学习：利用计算机从历史中找规律，并把这些规律用到对未来不确定场景的决策
机器学习简单分类： 可以分为 监督学习、无监督学习、半监督学习分类、聚类、回归生成模型（给出数据属于各个类别的概率）、判别模型（给出数据所属于的类别） 机器学习和数据分析的区别: 数据特点：交易数据（订单） VS 行为数据（点击历史）
少量数据 VS 海量数据
采样分析 VS 全量分析
训练数据/验证数据/测试数据 建模之前把数据分成三个部分 ：训练集、验证集、测试集
训练集：用来训练，构建模型验证集：用来在模型训练阶段测试模型的好坏测试集：用测试集评估模型的好坏 监督学习/无监督学习/半监督学习 监督学习：有明确的特性，带有标签的数据集，带有标签 分类
无监督学习：没有标签的数据 聚类
半监督学习：半监督学习是监督学习和无监督学习相结合的一种学习方式。主要是用来解决使用少量带标签的数据和大量没有标签的数据进行训练和分类的问题。
常见应用： 回归：拿到新的房子面积和学区编号，预测房价
分类（图像识别、垃圾邮件识别、文本分类）、
天气：晴，阴，雨
温度：暖，冷
湿度：普通，大
风力：强，弱
周末：是，否
预测是否运动：是，否
聚类
根据用户数据给用户分类，分类数量可以视情况而定
总结 回归/分类/聚类 回归：预测数据为连续型数值。分类：预测数据为类别型数据，并且类别已知。聚类：预测数据为类别型数据，但是类别未知。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eced503f8d74c0e4115ce1522998cb14/" rel="bookmark">
			Python&#43;Django&#43;Mysql实现在线音乐推荐系统 基于用户、项目、兴趣标签的协同过滤推荐在线音乐系统、用户兴趣标签推荐系统 代码实现 源代码下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Python+Django+Mysql实现在线音乐推荐系统（基于用户、项目的协同过滤推荐算法） 一、项目简介 1、开发工具和实现技术 pycharm2020professional版本，python3.8版本，django3.1.1版本，mysql8.0.21版本，bootstrap样式，javascript脚本，jquery脚本，layer弹窗组件，webuploader文件上传组件。
2、项目功能 前台用户注册、登录、注销、个人信息修改、密码修改、收藏音乐、评分音乐、评论音乐、播放音乐、下载音乐、添加歌单、个人兴趣标签等；
后台用户、音乐、音乐类型、评分、评论、收藏、歌单、兴趣标签管理，权限管理等。
3、项目目录 4、数据库 其中auth_group、auth_group_permissions、auth_permission、auth_user、auth_user_groups、auth_user_user_permissions、django_admin_log、django_content_type、django_migrations、django_session这些表是python django自动生成，其中auth_user是管理员表，使用python manage.py makesuperuser命令创建超级管理员，通过超级管理员可以管理其他管理员。auth_group、auth_group_permissions、auth_permission、auth_user_groups、auth_user_user_permissions、django_content_type实现管理员的权限管理，是用户-权限-组模式。django_admin_log表记录管理员操作记录。django_session保存前台和后台的session信息。django_migrations表记录数据库模式更改信息。user、music、type、scorerecord、collection、comment、labelrecord、playlist、playlistrecord、playrecord是自定义表。
二、部分代码 1、前台登录 2、前台注册 3、前台首页 4、音乐详情 5、基于用户的协同过滤推荐算法 6、基于项目的协同过滤推荐算法 7、项目settings.py配置文件 二、实现界面 1、前台登录 2、前台注册 3、前台首页 4、音乐详情 5、个人中心 6、个人歌单 7、音乐播放 8、个人信息修改 9、我的标签 10、收藏记录 11、评分记录 12、后台登录 13、后台首页 14、后台音乐列表 15、后台音乐编辑或添加 作者专业长期研究各种协同过滤推荐算法，欢迎留言、私信互相交流学习，后续会不断更新不同的协同过滤推荐算法，欢迎关注。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9809261b226e9d975e5605c3e4f755b/" rel="bookmark">
			Unicode strings with encoding declaration are not supported. Please use bytes input or XML fragments
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 xml_data = open(ii).read() root = etree.fromstring(xml_data, parser=parser) 这里的xml_data是str类型的，报错的是：
Unicode strings with encoding declaration are not supported. Please use bytes input or XML fragments。
所以，我们首先需要把数据转换为字节类型，那么就需要进行编码（encode）
修改之后的代码：
xml_data = open(ii).read() xml_data = xml_data.encode('ascii') root = etree.fromstring(xml_data, parser=parser) # element tree 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f486ba68f8899b115a4467b3d388cb6/" rel="bookmark">
			docker-compose搭建rocketmq双主模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 项目据说需要使用消息中间件rocketmq，所以需弄个简单示例。至于为啥用docker-compose，那当然是因为它可以整体部署啦。经过这次经历，觉得很有必要将官方的文档路径记录下来。博客上每个人都是以自己的环境搭建的，很多情况下都不能完美符合自己的环境。只能通过多个博客以及相关官方文档，相互印证，得出符合自己的配置。
rocketmq简单了解：
1 什么场景需要使用消息中间件
用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。
2 生产者
消息生产者，声明自己是消息生成者。一般由业务系统负责生产消息。
3 消费者
声明自己是消费者，一般是后台系统负责异步消费。
4 主题（Topic）
表示一类消息的集合，每个主题包含若干条消息，每条消息只能属于一个主题，是RocketMQ进行消息订阅的基本单位
5 代理服务器（Broker Server）
消息中转角色，负责存储消息、转发消息。代理服务器在RocketMQ系统中负责接收从生产者发送来的消息并存储、同时为消费者的拉取请求作准备。代理服务器也存储消息相关的元数据，包括消费者组、消费进度偏移和主题和队列消息等。
6 名字服务（Name Server）
名称服务充当路由消息的提供者。生产者或消费者能够通过名字服务查找各主题相应的Broker IP列表。多个Namesrv实例组成集群，但相互独立，没有信息交换。
其他详细信息请查看rocketmq的github官方文档地址：https://github.com/apache/rocketmq/tree/master/docs/cn
框架背景 springboot应用两个，一个作为消息生产者，一个作为消息消费者
装了docker-compose，docker 的虚拟机一台。
最终架构 注：不要问我为啥不弄两台虚拟机，就是偷懒。每个docker都有自己的ip，也可以模拟集群中宕机其中一台的情况。本机网络和虚拟机网络为同一个网段，虚拟机内容器之间为同一个网段。需要注意网络连接，这个会具体说明。
开始rockermq环境构建 docker 安装（略）
docker-compose安装 docker-compose文档在docker官网地址：https://docs.docker.com/compose/
安装说明在：https://docs.docker.com/compose/install/
下载docker-compose:
sudo curl -L “https://github.com/docker/compose/releases/download/1.27.4/docker-compose- ( u n a m e − s ) − (uname -s)- (uname−s)−(uname -m)” -o /usr/local/bin/docker-compose
将可执行权限应用于二进制文件:
sudo chmod +x /usr/local/bin/docker-compose
查看安装：docker-compose --version
相关镜像拉取 docker pull rocketmqinc/rocketmq-broker:4.5.0-alpine docker pull apacherocketmq/rocketmq-console:2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f486ba68f8899b115a4467b3d388cb6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6543f0a4d03964e4dcd52d6a1ee5b632/" rel="bookmark">
			端到端问答新突破：百度提出RocketQA，登顶MSMARCO榜首！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		*欢迎关注【百度NLP】官方公众号，及时获取自然语言处理领域核心技术干货！！
**阅读原文：https://mp.weixin.qq.com/s/K_7_LgMZf1MuS4IJI6gdsw
开放域问答（Open-domain QA）一直是自然语言处理领域的重要研究课题。百度从面向端到端问答的检索模型出发，提出了RocketQA训练方法，大幅提升了对偶式检索模型的效果，为实现端到端问答迈出了重要的一步。RocketQA已逐步应用在百度搜索、广告等核心业务中，并将在更多场景中发挥作用。
近日，百度提出了面向端到端问答的检索模型训练方法RocketQA，该方法针对模型训练中存在的问题，通过跨批次负采样（cross-batch negatives）、去噪的强负例采样（denoised hard negative sampling）与数据增强（data augmentation）等技术，大幅提升了对偶式检索模型的效果。RocketQA不仅在多个问答相关数据集中取得了SOTA，同时也刷新了微软MSMARCO数据集段落排序任务的榜单，超越谷歌、微软、Facebook、阿里、美团、卡内基梅隆大学、清华大学、滑铁卢大学等企业和高校位居第一，为实现“端到端问答”迈出了重要的一步。
论文名称：RocketQA: An Optimized Training Approach to Dense Passage Retrieval for Open-Domain Question Answering
论文地址：https://arxiv.org/abs/2010.08191
一、开放域问答系统 开放域问答（Open-domain QA）是自然语言处理领域的重要研究课题。它的任务是，基于用户用自然语言提出的问题，从海量候选文本中快速、精准地找出答案。开放领域问答在智能搜索、智能助手、智能客服等多个场景下，都发挥着重要作用。特别是近些年，随着各种智能手机、智能音箱的普及，智能搜索快速进化，通过开放域问答系统直接给出唯一的精准答案（如图 1 所示），可以帮助用户在这些小屏和无屏设备上更快速、准确地获取有用信息。
图1：百度搜索的TOP1结果：将问题的答案展现在搜索结果的首位，提升用户体验
传统的开放域问答主要采用级联的检索式问答系统，包含了段落检索、段落排序、答案定位等多个步骤。随着近些年预训练语言模型的发展，研究人员开始探索基于深度语义表示的对偶式检索模型（dual-encoder），希望其能够替代传统的检索式问答系统中级联的检索和排序等模块，与基于机器阅读理解模型的答案定位一起实现“端到端问答”。
不同于传统的级联式问答系统，“端到端问答”摒弃了传统系统中繁杂的构件，系统复杂性大大降低，并且其中每个模块（段落检索和答案定位）都是可学习的，这样的设计能够让整个系统实现端到端训练。这意味着问答系统可以基于用户实时的反馈实现在线训练，而不是只在封闭的数据集上闭门造车。这是智能问答技术的发展趋势，可能会引发问答系统的新一代技术变革。
基于此，百度从面向端到端问答的检索模型出发，针对对偶式检索模型训练中存在的问题，提出了RocketQA训练方法，并基于百度自研的预训练模型ERNIE进行训练，大幅提升了对偶式检索模型的效果，为实现端到端问答迈出了重要的一步。
图2：基于稠密向量表示的对偶模型
二、RocketQA：一种对偶式检索模型增强训练方法 不同于传统的检索模型使用基于关键词的稀疏表示对问题和候选段落进行建模，基于深度语义表示的对偶式检索模型（如图 2 所示）通过两个对称的网络分别对问题和候选段落进行编码并计算语义相似度。这样能够利用强大的网络结构进行更深层次的学习，同时基于预训练语言模型，使语义理解更加丰富。在过去的工作中，对偶模型大多采用批次内负采样 (in-batch negatives) 的方式进行训练，将批次内其他问题的正确答案作为当前问题的错误答案（负例），从而减少重复计算和提高训练效率。然而，由于检索场景不同于常见的分类问题，对偶式检索模型的训练仍然存在如下的挑战：
训练场景和预测场景中样本数量存在较大差异
在开放域问答的应用场景中，模型需要从大规模的候选集合中找出问题的答案。但是按照批次内负采样的方法训练时，每个问题的候选段落个数与批次大小相同。受到单GPU显存大小的限制，训练过程中见到的候选段落远小于预测时的候选段落，从而导致模型即使在训练时表现良好，在实际应用当中却差强人意。
数据集中存在大量漏标注的正确答案
开放域问答场景下候选段落的数量往往非常大，标注出问题的全部正确答案几乎是不可能的。在MSMARCO数据集中，候选段落的总数为880万，但每个问题平均只标注了1.1个正确答案。研究人员发现，在使用对偶模型检索出的首条结果中，70% 的错误结果其实是漏标的正确答案。这种情况下，构造训练数据中的强负例时很容易引入假负例（false negative），给模型训练带来负面影响。
相对于开放域全集，人工标注训练数据的规模小、成本大
尽管目前已有较多大规模的问答数据集，但是相较于开放域的用户问题来说，仍然是冰山一角。有限的标注数据集无法覆盖到全面的领域和类型，导致模型泛化性差。想要增大标注数据的规模和质量，需要很高的人工成本。
因此百度提出了一种对偶式检索模型的增强训练方法RocketQA，通过跨批次负采样、去噪的强负例采样与数据增强三项技术，解决上述挑战。接下来将对这三个技术进行详细的介绍。
2.1 跨批次负采样（cross-batch negatives）
采用传统的批次内负采样方法训练时，每个问题的候选段落个数与批次大小相同。为了进一步增加训练过程中候选段落的数量，百度提出了跨批次负采样方法（如图 3 所示）。该方法能够在使用多GPU并行训练时，将其它GPU批次内的全部段落作为当前问题的负样本。这样可以直接复用各个GPU上已经计算好的段落表示，不额外增加计算量；同时基于飞桨分布式训练扩展工具包FleetX的all-gather算子实现，只需要使用很少的通信量和内存开销，就达到了增加每个问题候选段落的目的。随着GPU个数的增加，每个问题的候选段落个数线性增加，训练场景中的任务难度也更加接近真实场景。百度在MSMARCO数据集上进行了实验，在使用跨批次负采样后，随着训练时候选段落数量增加，模型的效果稳步提升（如图 4 所示）。
图3：批次内负采样（上）和跨批次负采样（下）的对比
图4：MSMARCO数据集中，训练阶段候选段落的个数对模型效果的影响
2.2 去噪的强负例采样（denoised hard negative sampling）
在对偶模型的训练中，适当增加训练数据中的强负例的难度，有助于提升模型效果。一般的做法是，从一个排序的候选段落中进行采样，越靠前的负例对模型来说难度越大。但是由于难以避免的漏标注情况，直接采样很大概率会引入假负例。为了解决这一问题，百度使用交互模型（cross-encoder）的打分作为监督信息进行去噪。在选择强负例时，避开交互模型给出高置信度的样例。相较于对偶模型，交互模型具有结构上的优势，能够编码更多的交互信息，从而给出可靠的监督信号，帮助对偶模型选取更可靠的强负例。如表1的第三行和第四行所示，去噪的强负例采样可以显著提升模型效果。
2.3 数据增强（data augmentation）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6543f0a4d03964e4dcd52d6a1ee5b632/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/111ae5eeae33d579c1fc5afb5a49f4b5/" rel="bookmark">
			win2012r2下微软杀毒软件SCEP不能手动更新
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		win2012r2下安装的微软杀毒软件SCEP不能手动更新；如果卸载之后重装，它装完后能够自动 更新到最新版本;一点手动更新病毒库和间谍软件定义就不行。其它操作系统如win2008r2和win7下安装的SCEP更新正常，随时可以手动更新。
解决方法：进入windows更新设置里，把“更新windows时提供其它Microsoft产品的更新”勾选上，检查更新，把SCEP的相关补丁下载更新，SCEP病毒库和间谍软件更新就恢复正常了，随时可手动更新。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a679e5d25dd06460ab8cbd1e686f6964/" rel="bookmark">
			VS2017快速安装OpenGL流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实验室用，记录一下。
一、下载GLUT 在Glut下载地址. 中搜索“glutdlls37beta.zip”，点击下载；
下载完之后，解压文件，可以看到有5个文件：
二、安装GLUT 把头文件“glut.h”复制到 C:\Program Files (x86)\Microsoft Visual Studio\2017\Professional\VC\Tools\MSVC\14.16.27023\include\。安装路径不同用户略有区别，下图的路径红框前面是自定义的安装路径，后面是默认的路径；
把库文件“glut.lib”，“glut32.lib”复制到 C:\Program Files (x86)\Microsoft Visual Studio\2017\Professional\VC\Tools\MSVC\14.16.27023\lib\x86；
32位操作系统的：把“glut.dll”和“glut32.dll”复制到目录 C:\Windows\System32；64位操作系统的：把“glut.dll”和“glut32.dll”复制到 C:\Windows\SysWOW64。
三、测试OpenGL 新建一个C++控制台应用；
输入以下代码： #include &lt;GL/glut.h&gt; // 绘图方法，绘制一个三角形 void display() { glClear(GL_COLOR_BUFFER_BIT); glBegin(GL_POLYGON); glVertex2f(-0.5, 0); glVertex2f(0, 0.5); glVertex2f(0.5, 0); glEnd(); glFlush(); } int main(int argc, char **argv) { glutInit(&amp;argc, argv); glutCreateWindow("OpenGL Test"); glutDisplayFunc(display); glutMainLoop(); } 如下图所示，出现一个白色三角形就说明测试成功了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4800e75b5b170317332f69f6b5edb4e3/" rel="bookmark">
			C#获取dynamic(动态)或非动态实体的属性值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 当我们遍历一个已知实体类时我们可以这样来做，但是动态实体无法获取到类的GetType()
List&lt;student&gt; item= conn.Query&lt;student&gt;($"select * from 表 where id=123 ").ToList(); foreach (System.Reflection.PropertyInfo p in item.GetType().GetProperties()) { Console.WriteLine(p.Name+ " :"+p.GetValue(item, null)); } class student{ public string id{get;set;} public string name{get;set;} public string sex{get;set;} } 当我们需要遍历动态一个实体想要知道某个字段有没有值时，我们可以这样来写
List&lt;dynamic&gt; result= conn.Query($"select * from 表 where id='123'").ToList(); foreach (KeyValuePair&lt;string, object&gt; col in result[0]) { string aa=col.Key;//属性 string bb=col.Value.ToString();//值 if (!string.IsNullOrWhiteSpace(col.Value.ToString())) { } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26ec2e8b634d7b55cdbaee593254f77a/" rel="bookmark">
			unity动态加载FBX模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 导入下载官方Trilib包，导入到unity中。（文末附下载链接）官方包中提供了三个接口分别是
AssetLoader：用于加载资源。
ErrorDialog：用于显示加载错误信息。
FileLoader：用于加载界面。
将模型导入之后就新建一个脚本用于动态加载FBX模型：
运行结果：
Trilib下载链接：https://download.csdn.net/download/ThreePointsHeat/12980629 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37c786e6dae80e2ae8a27e53460f86d7/" rel="bookmark">
			flutter - AppBar 参数设置布局效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		class MyHomePage extends StatelessWidget { @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( // backgroundColor: Colors.red, // backgroundColor: Color(0xff45ff41), leading: Container( padding: EdgeInsets.all(8), child: ClipOval( child: Image.network( "https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ab5870542e8d4479bfb899ea7a195e4d~tplv-k3u1fbpfcp-watermark.image", fit: BoxFit.cover, ), ), ), title: Text("首页"), centerTitle: true, actions: [ Row( children: [ Text("右1"), SizedBox(width: 10), Text("右2"), SizedBox(width: 10), Text("右3"), SizedBox(width: 10), ], ) ], elevation: 0.0 ), ); } } 常用属性说明leading左侧 元素自定义，是一个widget部件leadingWidthAppBar 的leading的宽度，假如leading 里是文字的话，如果不设置这个属性，当你的文字很多时，会换行的titleAppBar 的标题 ，也是一个widgettitleSpacing设置AppBar 的标题 撑开左右 两边的 距离centerTitle控制AppBar 的标题是否居中，布尔值， 默认false，actinsAppBar 右侧附加的部分 ，比如一个按钮，一个文字等，需要传入一个List（数组）backgroundColorAppBar 的背景色，传入一个Color类型的颜色， 如 Colors.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37c786e6dae80e2ae8a27e53460f86d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c27138c3b7a6358de576b25fdb313ddf/" rel="bookmark">
			matlab-画折线图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用matlab画折线图是一个很基本的操作，下面是程序
x=5:5:50;%x从5开始,50结束，间隔为5 a=[75.226,76.704,75.263,75.337,75.599,76.302,74.824,76.924,75.595,75.442]; b=[72.112,70.764,68.63,68.201,64.067,61.717,61.476,61.561,61.066,61.586]; plot(x,a,'*--r');%标记为*,线型为虚线，颜色为red， hold on%保持 plot(x,b,'.-b');%标记为.，线型为实线，颜色为blue， axis([5,50,55,80]); set(gca,'XTick',[5:5:50]) %改变x轴坐标间隔显示 这里间隔为5 set(gca,'YTick',[55:5:80]) %改变y轴坐标间隔显示 这里间隔为10 xlabel('Input'); ylabel('Output'); %设置图例且没有边框 h=legend('系列1','系列2'); set(h,'Box','off'); %加网格 grid on; 画出来的图片
参考博客1是：https://blog.csdn.net/u012318074/article/details/79894443
感谢博主：Erik_ly
原博客中内容比较丰富，但是其中下面这些类型，我比较常用到，所以我从原博主的博客中摘出来了
1标记
标记类型定义符加号+小圆圈o星号*交叉号x向上三角形^向下三角形v 2线型
线型定义符实线-点线:点画线-. 虚线我在表格里面一直打不出来，这里使用原博主的图片
3颜色
颜色定义符红色r绿色g蓝色b黄色y黑色k 另外：程序中通过legend来为折线图加图例，程序中添加图例且无边框，此处参考博客2：https://blog.csdn.net/qq_37692302/article/details/92845567
感谢博主：孙ちゃん（颖）♂
最后：官方文档真是个好东西，但是我总是得先看人家的博客，才知道官方文档怎么用，尴尬…
官方文档：https://ww2.mathworks.cn/help/matlab/ref/plot.html?s_tid=srchtitle
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d445322ff443de12d675773459fceb16/" rel="bookmark">
			hive日期函数-原生函数  from_unixtime,unix_timestamp,to_date,current_date,datediff,date_add,date_sub,add_mont
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. from_unixtime
将UNIX时间戳转日期函数: from_unixtime　语法:from_unixtime(bigint unixtime[, stringformat]) 返回值: string
说明: 转化UNIX时间戳（从1970-01-0100:00:00 UTC到指定时间的秒数）到当前时区的时间格式
举例：
select from_unixtime(1323308943); +----------------------+--+ | _c0 | +----------------------+--+ | 2011-12-08 09:49:03 | +----------------------+--+ 看来 xxxx-xx-xx xx:xx:xx是官方格式
hive&gt; select from_unixtime(1323308943,'yyyyMMdd') from dual; 20111208
2. unix_timestamp
a.获取当前UNIX时间戳函数: unix_timestamp　语法: unix_timestamp() 返回值: bigint
说明: 获得当前时区的UNIX时间戳
举例：
hive&gt; select unix_timestamp() from dual; 1323309615
b.指定日期转UNIX时间戳函数: unix_timestamp 语法:unix_timestamp(string date) 返回值: bigint
说明: 转换格式为“yyyy-MM-dd HH:mm:ss“的日期到UNIX时间戳。如果转化失败，则返回0。
举例：
hive&gt; select unix_timestamp('2011-12-07 13:01:03') from dual; 1323234063
c.指定格式日期转UNIX时间戳函数: unix_timestamp语法: unix_timestamp(string date,string pattern) 返回值: bigint
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d445322ff443de12d675773459fceb16/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87c0c680b83d11c9524de4279fb959df/" rel="bookmark">
			dynamic_cast是将一个基类对象指针（或引用）转换到继承类指针，dynamic_cast会根据基类指针是否真正指向继承类指针来做相应处理。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍 编辑
dynamic_cast运算符它涉及到编译器的属性设置，而且牵扯到的面向对象的多态性跟程序运行时的状态也有关系，所以不能完全的使用传统的转换方式来替代。但是也因此它是最常用，最不可缺少的一个运算符 [1] 。
与static_cast一样，dynamic_cast的转换也需要目标类型和源对象有一定的关系：继承关系。 更准确的说，dynamic_cast是用来检查两者是否有继承关系。因此该运算符实际上只接受基于类对象的指针和引用的类转换。从这个方面来看，似乎dynamic_cast又和reinterpret_cast是一致的，但实际上，它们还是存在着很大的差别。
语法 dynamic_cast &lt;新类型&gt; (表达式)。
用法 编辑
dynamic_cast &lt;type-id&gt; (expression)
该运算符把expression转换成type-id类型的对象。Type-id 必须是类的指针、类的引用或者void*；
如果 type-id 是类指针类型，那么expression也必须是一个指针，如果 type-id 是一个引用，那么 expression 也必须是一个引用。
dynamic_cast运算符可以在执行期决定真正的类型。如果 downcast 是安全的（也就说，如果基类指针或者引用确实指向一个派生类对象）这个运算符会传回适当转型过的指针。如果 downcast 不安全，这个运算符会传回空指针（也就是说，基类指针或者引用没有指向一个派生类对象）。
dynamic_cast主要用于类层次间的上行转换和下行转换，还可以用于类之间的交叉转换。
在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的；
在进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全。
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
classB
{
public:
int m_iNum;
virtual void foo();
};
classD:publicB
{
public:
char* m_szName[100];
};
void func(B* pb)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/87c0c680b83d11c9524de4279fb959df/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e17c1d62762ab3c2b93f88d3ffc1d08/" rel="bookmark">
			电脑删除快捷键_大明：教你怎样把电脑软件卸载干净的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好我是大明本期内容讲解关于怎样把”电脑软件卸载干净”的方法
电脑在使用的过程当中需要定期把电脑做一下清理和维护，如果长时间不做维护的话就会出现卡慢的现象，在清理的时候需要对电脑的一些闲置无用的软件做卸载清理，而有些软件很顽固清理不干净，当出现这类问题的时候可以使用电脑系统自带的工具卸载，也可以使用第三方工具，最后如果还是卸载不掉的话可以使用“注册表”来删除，那么接下来我就将解决这类问题的方法做一下详细的描述、
首先第一种方法：依次点击“开始”菜单-“设置”-“控制面板”，打开运行“添加删除程序”来卸载，详细操作步骤如下图所示、
第二种方法：打开运行“电脑管家”程序依次点击“软件管理”-“卸载”，详细操作步骤如下图所示、
第三种方法：(1)如果通过上述两种方法依然卸载不掉，那么依然点击“开始”菜单-“运行”-输入“regedit”命令点击“确定，详细操作步骤如下图所示、
(2)进入注册表编辑器后依次点击”编辑“-”查找“，也可以使用快捷键"CTRL+F"键，然后输入软件的关键字然后右键删除相关的选项，详细操作步骤如下图所示、
(3)删除完后按快捷键F3如果出现相关的数值选项直接删除即可，直到删除干净为止！
本期文章的大纲是三种解决电脑卸载软件的方法前两种是最常用的，最后一种是最为见效的方法，建议大家在更改注册表的时候先备份以防误操作导致注册表文件丢失，以上就是今天分享的内容希望对大家有所帮助、喜欢的话别忘记点赞 关注呦！大明会持续创作关于“电脑维护与应用”的作品！还请大家踊跃评论 共同进步、好了就讲到这里咱们下期再见！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c14627aaa6690500f7f9d7fea6b64fa/" rel="bookmark">
			解决存在依赖问题使ubuntu下gcc g&#43;&#43;安装失败问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		困难遇到情况： 终端采用命令：sudo apt-get install gcc
出现如下错误:
正在读取软件包列表… 完成
正在分析软件包的依赖关系树
正在读取状态信息… 完成
有一些软件包无法被安装。如果您用的是 unstable 发行版，这也许是
因为系统无法达到您要求的状态造成的。该版本中可能会有一些您需要的软件
包尚未被创建或是它们已被从新到(Incoming)目录移出。
下列信息可能会对解决问题有所帮助：
下列软件包有未满足的依赖关系：
gcc : 依赖: gcc-7(&gt;= 7.3.0-12~) 但是它将不会被安装
E: 无法修正错误，因为您要求某些软件包保持现状，就是它们破坏了软件包间的依赖关系。
通过百度查找资料: 无论是不断的换源操作，或者apt-get update，以及先执行apt-get install build-essential都没有解决问题。在使用apt-get install build-essential命令时，出现如下错误：
下列软件包有未满足的依赖关系：
build-essential :
依赖: gcc(&gt;= 4:7.2) 但是它将不会被安装
依赖: g++(&gt;= 4:7.2) 但是它将不会被安装
依赖：dpkg-dev(&gt;=1.17.11) 但是它将不会被安装
E: 无法修正错误，因为您要求某些软件包保持现状，就是它们破坏了软件包间的依赖关系。
参考的最终解决方法： 使用aptitude包依赖管理工具代替apt来处理，aptitude软件包管理工具在解决依赖性问题上更有优势，具体使用方法如下：
sudo apt-get install aptitude
sudo aptitude install gcc g++
终端中输入后会提示aptitude给出的解决方案，可以选择no,
会继续提供下一个解决方案，但前面的方案会是忽略掉依赖冲突，所以想要彻底解决的话可以跳过前面的几种方案，然后再yes解决。（个人第一次No，第二次Yes）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b0e28aa1d51fe696329fe33dd140066/" rel="bookmark">
			Latex中设置enumerate有序列表使用方括号标号以及设置item间距
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 如题。
解决方法 看了[1]中的解答，用法如下：
\begin{enumerate}[label={[\arabic*]}] %\setlength{\itemsep}{0pt} \item xxxxx %[1] xxxxx \item yyyyyy %[2] yyyyyy \item zzzzz %[3] zzzzz \end{enumerate} 其中,
enumerate环境后面跟的参数label={[\arabic*]}即可使得列表以“方括号+阿拉伯数字”的形式编号；在\begin{enumerate}[label={[\arabic*]}]后面跟\setlength{\itemsep}{0pt}可以设置当前列表环境里item条目之间的间距。\arabic可以替换为\roman、\Roman、\Alph 或 \alph来表示小写罗马数字、大写罗马数字、大写字母编号 或 小写字母编号。 若是要针对全局列表进行设置（例如条目间距、段落缩进、段落间距、标签缩进量），可参考[2, 3]。
参考 [1] Enumerated list with square brackets
[2] LaTeX技巧95：如何调整列表环境的间隔
[3] LaTeX技巧233：enumerate间距调整
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2bacc7e9b9d20302322ef8b03af9dceb/" rel="bookmark">
			Android 控件 RecyclerView  看这篇就够了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【Android 控件 RecyclerView】 概述 RecyclerView是什么 从Android 5.0开始，谷歌公司推出了一个用于大量数据展示的新控件RecylerView，可以用来代替传统的ListView，更加强大和灵活。RecyclerView的官方定义如下：
A flexible view for providing a limited window into a large data set.
从定义可以看出，flexible（可扩展性）是RecyclerView的特点。
RecyclerView是support-v7包中的新组件，是一个强大的滑动组件，与经典的ListView相比，同样拥有item回收复用的功能，这一点从它的名字Recyclerview即回收view也可以看出。
RecyclerView的优点 RecyclerView并不会完全替代ListView（这点从ListView没有被标记为@Deprecated可以看出），两者的使用场景不一样。但是RecyclerView的出现会让很多开源项目被废弃，例如横向滚动的ListView, 横向滚动的GridView, 瀑布流控件，因为RecyclerView能够实现所有这些功能。
比如：有一个需求是屏幕竖着的时候的显示形式是ListView，屏幕横着的时候的显示形式是2列的GridView，此时如果用RecyclerView，则通过设置LayoutManager一行代码实现替换。
RecylerView相对于ListView的优点罗列如下：
RecyclerView封装了viewholder的回收复用，也就是说RecyclerView标准化了ViewHolder，编写Adapter面向的是ViewHolder而不再是View了，复用的逻辑被封装了，写起来更加简单。
直接省去了listview中convertView.setTag(holder)和convertView.getTag()这些繁琐的步骤。提供了一种插拔式的体验，高度的解耦，异常的灵活，针对一个Item的显示RecyclerView专门抽取出了相应的类，来控制Item的显示，使其的扩展性非常强。设置布局管理器以控制Item的布局方式，横向、竖向以及瀑布流方式
例如：你想控制横向或者纵向滑动列表效果可以通过LinearLayoutManager这个类来进行控制(与GridView效果对应的是GridLayoutManager,与瀑布流对应的还StaggeredGridLayoutManager等)。也就是说RecyclerView不再拘泥于ListView的线性展示方式，它也可以实现GridView的效果等多种效果。可设置Item的间隔样式（可绘制）
通过继承RecyclerView的ItemDecoration这个类，然后针对自己的业务需求去书写代码。可以控制Item增删的动画，可以通过ItemAnimator这个类进行控制，当然针对增删的动画，RecyclerView有其自己默认的实现。 但是关于Item的点击和长按事件，需要用户自己去实现。
基本使用 recyclerView = (RecyclerView) findViewById(R.id.recyclerView); LinearLayoutManager layoutManager = new LinearLayoutManager(this ); //设置布局管理器 recyclerView.setLayoutManager(layoutManager); //设置为垂直布局，这也是默认的 layoutManager.setOrientation(OrientationHelper. VERTICAL); //设置Adapter recyclerView.setAdapter(recycleAdapter); //设置分隔线 recyclerView.addItemDecoration( new DividerGridItemDecoration(this )); //设置增加或删除条目的动画 recyclerView.setItemAnimator( new DefaultItemAnimator()); 在使用RecyclerView时候，必须指定一个适配器Adapter和一个布局管理器LayoutManager。适配器继承RecyclerView.Adapter类，具体实现类似ListView的适配器，取决于数据信息以及展示的UI。布局管理器用于确定RecyclerView中Item的展示方式以及决定何时复用已经不可见的Item，避免重复创建以及执行高成本的findViewById()方法。
可以看见RecyclerView相比ListView会多出许多操作，这也是RecyclerView灵活的地方，它将许多动能暴露出来，用户可以选择性的自定义属性以满足需求。
基本使用 引用 在build.gradle文件中引入该类。
compile 'com.android.support:recyclerview-v7:23.4.0' 布局 Activity布局文件activity_rv.xml
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2bacc7e9b9d20302322ef8b03af9dceb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6619b72bbe18274a97467ce3fe25ab4/" rel="bookmark">
			这 6 个 SpringBoot 项目够经典！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		来源：http://suo.im/6i95ny 前言
不得不佩服 SpringBoot 的生态如此强大，今天给大家推荐几款优秀的后台管理系统，小伙伴们再也不用从头到尾撸一个项目了。
SmartAdmin 我们开源一套漂亮的代码和一套整洁的代码规范，让大家在这浮躁的代码世界里感受到一股把代码写好的清流！同时又让开发者节省大量的时间，减少加班，快乐工作，热爱生活。SmartAdmin 让你从认识到忘不了，绝对是你最想要的！
litemall 又一个小商场系统，Spring Boot后端 + Vue管理员前端 + 微信小程序用户前端 + Vue用户移动端。
Timo TIMO后台管理系统，基于SpringBoot2.0 + Spring Data Jpa + Thymeleaf + Shiro 开发的后台管理系统，采用分模块的方式便于开发和维护，支持前后台模块分别部署，目前支持的功能有：权限管理、部门管理、字典管理、日志记录、文件上传、代码生成等，为快速开发后台系统而生的脚手架！
技术选型
后端技术：SpringBoot + Spring Data Jpa + Thymeleaf + Shiro + Jwt + EhCache
前端技术：Layui + Jquery + zTree + Font-awesome
mall4j 一个基于spring boot、spring oauth2.0、mybatis、redis的轻量级、前后端分离、防范xss攻击、拥有分布式锁，为生产环境多实例完全准备，数据库为b2b2c设计，拥有完整sku和下单流程的完全开源商城。
项目致力于为中小企业打造一个完整、易于维护的开源的电商系统，采用现阶段流行技术实现。后台管理系统包含商品管理、订单管理、运费模板、规格管理、会员管理、运营管理、内容管理、统计报表、权限管理、设置等模块。
web-flash 基于Spring Boot+Vue的后台管理系统,权限管理，字典，配置，定时任务，短信，邮件，根据excel模板导出，cms内容管理，手机端h5，IDEA 代码生成插件。
SPTools 一个基于SpringBoot、JPA、Shiro的后台管理系统，单体架构，依赖少，极易上手，后端开发的福利。最重要的是还附带免费小程序以及微服务版本，可自行选择。
内置功能
组织机构：机构管理、用户管理、角色管理、行政区域。
系统监控：系统日志、在线用户，后期会慢慢追加完善。
应用管理：任务调度、邮件管理、图片管理、文章管理、打卡任务、数据查询、人工智能，每个模块只需要你稍作修改就可以打造成一个项目了。
系统管理：敏捷开发、系统菜单、全局配置、在线代码编辑器，小伙伴们只需要设计好表结构，三秒钟就能撸出一个增删查改的模块。
小结 最后感谢各位撸主贡献出了这么优秀的开源项目，大家可以访问项目支持一下，如果觉得不错可以顺手给个小星星。
项目地址已经给大家整理好
关注下面公号，回复：经典项目
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6619b72bbe18274a97467ce3fe25ab4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ce5f8085125c0670b0ca4d199d90478/" rel="bookmark">
			MYSQL mydumper介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 mysqldump无法并行，这点与Oracle的expdp相比，存在一定的劣势，但是开源的mysqldumper是一个很好的补充。
mydumper（http://www.mysqldumper.org/）是一个在GNU GPLv3许可下发布的高性能MySQL备份和恢复工具集。mydumper是多线程的，他创建一个mysql备份就比随mysql发布的mysqldump工具要快得多。
mydumper也有从源端服务器恢复二进制日志的能力。
mysqldumper优点
1.多线程，可以是转存数据快很多
2.mydumper的输出已于管理和分析，因为他的表和元数据是分开的单独文件。
3.所有线程都维护有一直的快照，这边提供了精准的主从位置。
4.Mydumper支持Perl正则表达式，这样就既可以包括是数据库名和报名的模式匹配，也可以配置这种匹配。
5.通过名为myloader的多线程工具，mydumper工具集也可以从mydumper备份中恢复数据。
主要备份步骤概括
1.主线程 FLUSH TABLES WITH READ LOCK, 施加全局只读锁，以阻止DML语句写入，保证数据的一致性
2.读取当前时间点的二进制日志文件名和日志写入的位置并记录在metadata文件中，以供即使点恢复使用
3.N个（线程数可以指定，默认是4）dump线程 START TRANSACTION WITH CONSISTENT SNAPSHOT; 开启读一致的事物
4.dump non-InnoDB tables, 首先导出非事物引擎的表
5.主线程 UNLOCK TABLES 非事物引擎备份完后，释放全局只读锁
6.dump InnoDB tables, 基于事物导出InnoDB表
7.事务结束
一.mysqldumper安装 数据库版本 : MySQL 5.7
操作系统版本: CentOS 7.8
软件地址:https://github.com/maxbube/mydumper/releases
yum -y install cmake glib2 pcre pcre-devel mysql-devel -- 通过浏览器进行下载 yum -y install mydumper-0.9.5-2.el7.x86_64.rpm [root@10-31-1-119 src]# yum -y install mydumper-0.9.5-2.el7.x86_64.rpm 已加载插件：fastestmirror, langpacks 正在检查 mydumper-0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ce5f8085125c0670b0ca4d199d90478/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e7bf728455773804c853dfb020dbe8b/" rel="bookmark">
			WARNING: You are using pip version 20.1.1； however, version 20.2.3 is available.解决方法。实测有效
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		windows 命令提示框用pip更新库时，出现这个问题
WARNING: You are using pip version 20.1.1； however, version 20.2.3 is available.
说明要更新pip 的版本！
只要复制+黏贴下面的命令就解决了！
python -m pip install --upgrade pip -i https://pypi.douban.com/simple
完成！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d49378e0a4b25d912f842e525a6b2e6/" rel="bookmark">
			《会计学》账户与复式记账笔记的思维导图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		《会计学》第三部分 账户与复式记账笔记 前言 复式记账法是会计学的基础要好好学。
文章目录 《会计学》第三部分 账户与复式记账笔记前言笔记会计科目账户借贷记账法 总结 笔记 会计科目 账户 借贷记账法 总结 思维导图可以直观梳理知识。
更新地址：GitHub
更多内容请关注：CSDN、GitHub、掘金
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04fbb0c549bc15b237f3b4c4f745dded/" rel="bookmark">
			ConcurrentHashMap(一)：常量，成员变量，静态代码块，内部类，spread函数，tabAt函数等详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		散列表
Node节点(K-V)所放的位置:key的哈希值 &amp; 数组.len-1
1.假如计算的下标为如图5，就会来到链表结构中，从头开始检查，看是否有key一致的节点，如果一致就进行替换，如果没有一致的节点就插入到末尾（要判断是否树化）
2.如果计算的下标为如图的10，可以看见是TreeBin节点（代表当前桶位已经树化成红黑树——可以提高查找的效率），其中TreeBin节点中维护了两个结构：红黑树结构和链表结构，先会插入到TreeNode链表结构，然后插入到TreeNode红黑树结构中（需要平衡操作）
3.如图的FWD节点 （扩容的时候可以用） ，处理完一个桶位之后，引用需要指向FWD节点，其他线程来到散列表时：1.如果是put操作，到FWD节点会帮你一起扩容。2.如果是get操作（FWD中保存了新表、扩容后表的引用）会到新表中执行查找操作。
4.扩容的顺序是从后往前迁移的——方便迭代的读，就是从前往后读的话，读到后面失去的数可以到新表去读（如果从低到高 容易冲突）
1_深入理解ConcurrentHashMap 常量 /* ---------------- Constants -------------- */ /** * The largest possible table capacity. This value must be * exactly 1&lt;&lt;30 to stay within Java array allocation and indexing * bounds for power of two table sizes, and is further required * because the top two bits of 32bit hash fields are used for * control purposes. * 散列表数组最大限制 */ private static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; /** * The default initial table capacity.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04fbb0c549bc15b237f3b4c4f745dded/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d8e6f6285f96019f480d577f00e1cea/" rel="bookmark">
			C&#43;&#43;运算符重载实现字符串拼接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、什么是运算符重载？二、代码实现1.Mystring.h2.main.cpp 总结 前言 今天我们来谈谈C++中的运算符重载，关于C++的运算符重载，笔者之前学完一直想知道用在什么地方比较巧妙。今天我们就是用运算符重载来重载“+”号运算符实现字符串的拼接。
例如： "hello " + “world” = “hello world”
一、什么是运算符重载？ 运算符重载，就是对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型。
二、代码实现 1.Mystring.h 代码如下（示例）：
#ifndef MYSTRING_H #define MYSTRING_H #include &lt;cstring&gt; class Mystring{ public: char * id;	//保存字符串 Mystring(){};	//无参构造 Mystring(char * id){	//有参构造 this-&gt;id = id; }; ~Mystring(){}; Mystring operator+(const Mystring str1)	//重载"+"实现 { int len = strlen(this-&gt;id) + strlen(str1.id); char array_str[len]; strcpy(array_str, this-&gt;id);	//复制"+"前面的字符串存入数组 strcpy( (char *)(array_str + strlen(this-&gt;id)), str1.id);//复制"+"后面的字符串存入数组 this-&gt;id = array_str; return * this; } }; #endif // MYSTRING_H_INCLUDED 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d8e6f6285f96019f480d577f00e1cea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83043f0f34086fc92b7a5906af16bbaf/" rel="bookmark">
			virtual虚继承，虚基类指针，虚基类表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1，虚继承的目的：解决环形多继承命名冲突导致的访问变量二义性问题，同时节省了内存
2，上述代码，B——》A， C——&gt;A, D——》A,B
D中会存在两份A的拷贝，访问A中变量时就不知道是从B继承来的，还是从C继承来的，所以B，C需要声明成虚继承
3，A为虚基类，B虚继承A时，A会产生一份虚基类表，表中记录了变量a与类B开始位置的偏移量，
C虚继承A时，
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80e077190edcf2dcb348b8060ed65432/" rel="bookmark">
			百度地图实现地图全屏（放大页面全屏）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个全屏 API里面没有。是因为全屏只是个产品逻辑，把地图外的其他div隐藏，然后把地图的width设置为页面最大像素就可以了。
是js和css的技术，和API无关
1、先引入相关的百度地图资源
2、css
全屏按钮的图片
.btn{ z-index:999999;margin-left:-5px;color:transparent; background: url(../qp.png) no-repeat; } 3、html:
定义一个地图容器和一个全屏按钮
&lt;div id="btn" class=""&gt;全屏&lt;/div&gt; &lt;div class="" style="width: 100%; height: 98%; float: left;" id="allmap"&gt;&lt;/div&gt; 4、js全屏逻辑实现
//百度地图API功能，初始化地图 var map = new BMap.Map("allmap", { enableMapClick: false }); // 创建Map实例 map.setMapStyle({ style : 'midnight' }); map.centerAndZoom(new BMap.Point(112.98054,28.132748), 13); // 初始化地图,设置中心点坐标和地图级别 map.setCurrentCity("郑州"); // 设置地图显示的城市 此项是必须设置的 map.enableScrollWheelZoom(true); //开启鼠标滚轮缩放 // 添加地图放大缩小控件 var navigationControl = new BMap.NavigationControl({ // 靠左上角位置 anchor: BMAP_ANCHOR_TOP_LEFT, // LARGE类型 type: BMAP_NAVIGATION_CONTROL_ZOOM, // 启用显示定位 //enableGeolocation: true }); map.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/80e077190edcf2dcb348b8060ed65432/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d26b8101b45fb9e27a83c205c48e8fbf/" rel="bookmark">
			交叉熵损失函数（CrossEntropy Loss）（原理详解）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		监督学习主要分为两类：
分类：目标变量是离散的，如判断一个西瓜是好瓜还是坏瓜，那么目标变量只能是1（好瓜）,0（坏瓜）回归：目标变量是连续的，如预测西瓜的含糖率（0.00~1.00） 分类主要分为：
二分类：如判断一个西瓜是好瓜还是坏瓜多分类：如判断一个西瓜的品种，如黑美人，特小凤，安农二号等 而交叉熵损失函数是分类中最常用的损失函数，交叉熵是用来度量两个概率分布的差异性的，用来衡量模型学习到的分布和真实分布的差异。
二分类 在二分类情况中，对于每一类别的预测只能是两个值，假设预测为好瓜（1）的概率为 P P P，坏瓜（0）的概率为 1 − P 1-P 1−P：
则，二分类交叉熵损失的一般形式为，其中y为标签：
这个式子怎么理解呢？
预测为好瓜（1）的概率为 P P P： P ( y = 1 ∣ x ) = P P(y=1|x)=P P(y=1∣x)=P，
预测为坏瓜（0）的概率为 1 − P 1-P 1−P： P ( y = 0 ∣ x ) = 1 − P P(y=0|x)=1-P P(y=0∣x)=1−P
则， P ( y ∣ x ) = P y ( 1 − P ) 1 − y P(y|x)=P^y(1-P)^{1-y} P(y∣x)=Py(1−P)1−y，当y为1时， P ( y ∣ x ) = P P(y|x)=P P(y∣x)=P，当y为0时， P ( y ∣ x ) = 1 − P P(y|x)=1-P P(y∣x)=1−P。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d26b8101b45fb9e27a83c205c48e8fbf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43684e50353ab0210d3ca4c187febc5d/" rel="bookmark">
			uni-app的midButton，中间突出，点击跳转页面或者出现弹框。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前面做一个APP中间要求突出，记得以前好像uni没有自带得这个，然后看官网现在有这个了，刚好项目也需要，就写了下。下面就是完整得tabbar配置
"tabBar": { "color": "#999999", "selectedColor": "#333333", "borderStyle": "#e8e8e8", "backgroundColor": "#ffffff", "list": [{ "pagePath": "pages/index/index", "iconPath": "static/tabBar/home-xuanzhong0.png", "selectedIconPath": "static/tabBar/home-xuanzhong.png", "text": "首页" }, { "pagePath": "pages/service/service", "iconPath": "static/tabBar/weixiu-weixuanz0.png", "selectedIconPath": "static/tabBar/weixiu-weixuanz.png", "text": "维修" }, { "pagePath": "pages/statistics/statistics", "iconPath": "static/tabBar/tj0.png", "selectedIconPath": "static/tabBar/tj.png", "text": "统计" }, { "pagePath": "pages/my/my", "iconPath": "static/tabBar/my0.png", "selectedIconPath": "static/tabBar/my.png", "text": "我的" }], "midButton": { "iconPath": "static/jiajia.png", "text": "维修上报", "height": "70px", "iconWidth": "44px" } } midButton属性就是中间按钮得配置，然后会发现midButton 中没有pagePath属性。就代表着他没有页面。不过官方也说得很清楚
midButton没有pagePath，需监听点击事件，自行处理点击后的行为逻辑。监听点击事件为调用API：uni.onTabBarMidButtonTap，详见官网
这不是和没写一样吗。仅支持APP开发，是个点击事件
是不是写哪里都不知道？？？一样。但是一想tabbar是全局配置，我猜写到App.vue里面。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43684e50353ab0210d3ca4c187febc5d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d9e02e3ef09c6125311dd20ec6e7b27/" rel="bookmark">
			hdfs: command not found hadoop2.8.5
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：在执行 hdfs dfs -ls /input 遇到hdfs: command not found
前提：hadoop-2.8.5包在/home/angel/app下；普通用户为angel。
解决办法：
1.添加环境变量
cd /home/angel/
vim.tiny /home/angel/.profile
在文件最后添加：
export HADOOP_HOME=/app/hadoop-2.8.5/bin export PATH=$JAVA_HOME/bin:$PATH 2.激活环境变量
source .profile
3.测试
hdfs
到此问题解决成功！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6bf26ddeb08b2190c700b7aefa1bdf1f/" rel="bookmark">
			Vue 中WebSocket的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		data() { return { websock: null, } },created() { this.initWebSocket(); }, destroyed() { this.websock.close() //离开路由之后断开websocket连接 }, methods: { initWebSocket(){ //初始化weosocket const wsuri = "ws://127.0.0.1:8080"; this.websock = new WebSocket(wsuri); this.websock.onmessage = this.websocketonmessage; this.websock.onopen = this.websocketonopen; this.websock.onerror = this.websocketonerror; this.websock.onclose = this.websocketclose; }, websocketonopen(){ //连接建立之后执行send方法发送数据 let actions = {"test":"12345"}; this.websocketsend(JSON.stringify(actions)); }, websocketonerror(){//连接建立失败重连 this.initWebSocket(); }, websocketonmessage(e){ //数据接收 const redata = JSON.parse(e.data); }, websocketsend(Data){//数据发送 this.websock.send(Data); }, websocketclose(e){ //关闭 console.log('断开连接',e); }, }, 转自：Sven0706
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/409/">«</a>
	<span class="pagination__item pagination__item--current">410/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/411/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>