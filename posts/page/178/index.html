<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed132340153a6aced874363808df2e41/" rel="bookmark">
			一个C语言的基本教程—文件篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 12.把数据永久存储——文件篇(1). 文件指针(2). 文件的分类(3). 那就先打开一个文件吧(4). 接下来应该试试读文件了(5). 然后试试写文件(6). 然后来看看二进制文件#1.写入二进制文件#2.读取二进制文件#3.用二进制文件来做点什么？ 小结 12.把数据永久存储——文件篇 我们会发现，如今的很多程序并不是仅仅在屏幕上根据我们的需求打印一个结果就结束了，你可能会用QQ或者微信保存一个视频，或者有的时候你清理手机空间的时候会发现很多软件创建了各种后缀的文件，这一切都是使用文件完成的操作。
使用文件的好处在于，我们可以把一些东西长期保存下来，例如浏览器中的cookies文件可以保证你在登录某个网页之后的一段时间内不用再次登录，我们使用的各种在线程序也需要通过文件的方式保存用户的各种信息，例如用户名、密码等等数据。
(1). 文件指针 这玩意儿我们老早就提过了哈哈哈哈哈哈，之前在讲IO的时候我们就说过，标准输入输出流stdin和stdout都是文件指针，不过文件指针到底是什么呢？
typedef struct { short level; unsigned flags; char fd; unsigned char hold; short bsize; unsigned char *buffer; unsigned ar *curp; unsigned istemp; short token; } FILE; （-。-）好复杂的东西，事实上我们在C语言中操作文件的时候不需要了解FILE结构体的细节，平时我们一般使用FILE *完成对文件的操作（因为如果是FILE，传入对应函数的时候就是传值了）。这样可以声明一个文件指针：
FILE* fp; 对于每一个文件，我们都可以有一个文件指针(FILE *)指向这个文件，然后利用C标准库中的函数对文件进行一系列的操作。如在IO篇中所说，C语言中将标准输入(stdin)、标准输出(stdout)以及标准错误(stderr)都视为文件，因此，之后的介绍的各种对于文件指针的操作，对于标准IO也是可以使用的。
(2). 文件的分类 C语言中有两种类型的文件：文本文件和二进制文件，一般来说文本文件就存储一些文字之类的内容，简单来说你平时创建一个txt文件，它就是一个简单的文本文件，文本文件的特点就在于它是写给人看的，你直接打开就应该可以看懂。
二进制文件就不同了，文件中存储的是一串串0和1，经过不同程序的处理之后可以展示出不同的内容，比如.jpg文件，你用MATLAB打开之后就会被处理成包含各种信息的矩阵，在C语言中，我们可以通过二进制文件来存储结构体等数据，这样做可以把一个结构体对象永久保存。
(3). 那就先打开一个文件吧 在C语言中我们使用fopen()函数打开文件并返回对应的文件指针，它的原型如下：
FILE* fopen(const char *filename, const char* mode); filename参数就是文件的路径。这里提一下绝对路径与相对路径的区别（Windows下）：
绝对路径：从盘符起的路径就是绝对路径，例如在D盘下的AAA文件夹下的BBB子文件夹中有一个CCC.txt文件，绝对路径就是：D:/AAA/BBB/CCC.txt，这个斜杠可以使用反斜杠表示，但因为存在转义字符的影响，我们需要这么表示：D:\\AAA\\BBB\\CCC.txt
相对路径：不是绝对路径的路径就是相对路径，简单来说，相对路径是从当前执行的文件的路径开始寻址，例如在D盘下的AAA文件夹下的BBB子文件夹中有一个CCC.c文件以及一个子目录DDD，DDD中还有一个文件EEE.txt，我运行CCC.c，从CCC.c起访问EEE.txt的表示就是：DDD\\EEE.txt，看起来很简单对吧？ 后面的mode也是一个字符串，它代表的是打开文件的模式，在C语言中有以下读写模式：
模式含义r打开已有的文件，并读取内容w打开文件，如果文件存在就从头开始写入。如果文件不存在，则会创建一个新文件a打开文件，若文件存在就从后续开始追加写入。若文件不存在，则会创建一个新文件+加号是加在上述三个模式后面的，可以使得上述三种模式都变为可读写b也是加在上述三种模式之后的，代表以二进制方式处理文件 所以假设我们需要读取一个相对路径下的text.txt，我们可以这么做：
#include &lt;stdio.h&gt; int main() { FILE* fp = fopen("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed132340153a6aced874363808df2e41/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3911638356d2ddb33ead3a42302b78d1/" rel="bookmark">
			金融BI分析的价值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		众所周知，金融行业从信息化时代起，就是对IT依赖程度非常高的，也是最严苛的。进入到数字化时代，金融机构越来越注重技术创新，BI工具也越来越受到重视。利用BI工具，金融机构可以更快、更准确地获得有关市场信息、交易流程、竞争情况等的信息，从而更好地进行分析和决策。此外，BI工具还可以帮助金融机构及早发现风险，以及更有效地控制风险，提高金融机构的经营效率和绩效。
BI工具是什么？ BI是商业智能（Business Intelligence）的简称，核心是对数据进行分析，从而辅助决策。虽然IT技术日新月异，出现了“大数据应用”“数据智能”等新的概念，但归根到底都是数据分析，仍属于BI的范畴，只是在应用广度和深度上不断发展延伸，如图1所示。
l&amp;nbsp; BI在金融行业的经典应用 金融的管理者和业务人员需要对各种经营数据进行分析，才可以了解企业的经营状况。而分析数据，需要有不同的分析主题以及一套完整的的指标体系。例如在银行领域，分析“银行竞争力”这一主题，应该分析吸收存款、发放贷款等相关指标，因为这是银行的生存之本，优秀的银行应该是吸收存款成本低、发放贷款质量高的银行。
吸收存款指标可以分析利率最低的活期存款占比，占比越高，意味着其吸收存款的成本越低，总资产收益率以及净资产收益率越高。发放货款指标可以分析个人贷款占比。在银行的贷款中，个人贷款的风险低于公司贷款的风险，个人贷款越高，贷款损失的机会越小。
此外，还可以分析逾期贷款率、不良贷款率等指标。这些指标数据首先需要通过ETL从银行各种业务系统中采集，然后再将其放在数据仓库中按不同的主题进行整理、汇总，最后在BI工具中以报表、仪表盘的形式进行展示，用户可以通过PC或者移动终端进行浏览。
在BI经典应用中，使用者一般是银行的各级管理者，其有着更为突出和特定的决策需求，这些需求以项目的形式进行建设，对银行改善其核心业务流程、提高市场反应速度和业务管理水平有着重要作用。
l&amp;nbsp; 金融机构青睐的BI工具有哪些？ 说到金融BI领域就不得不提到思迈特软件这位职业玩家，他从金融起家，是目前国内拥有最多大型金融客户的国产BI服务商，六大国有银行已覆盖4家，12家股份制银行中已覆盖8家。另外，其在金融行业有多个标杆案例，其中为民生银行打造的一站式数据分析平台——阿拉丁平台，从数据管理、数据工具、数据文化三个层面解决了民生银行数据应用的难题，实现全年10%的利润增长。
凭借在金融领域的杰出表现，获得了IDC、金融电子化等权威机构和媒体的点赞，连续多年上榜IDC中国Fintech 50榜单、斩获金融科技领军企业奖、信通院《金融科技创新应用案例集》、【中国电子银行网】技术创新应用奖、【中国电子银行网】数据智能创新奖、2021爱分析·金融·保险数字化榜单等。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/413893252fff688e55a567ff61551439/" rel="bookmark">
			好用高效的python四元数库-quaternion
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		好用高效的python四元数库-quaternion 一、简介 https://github.com/moble/quaternion
这个库主要是在Numpy的基础上增加一个quaternion的类型，不仅实现了四元数相关操作的numpy实现，同时也将numpy的很多用法拓展到了相关四元数上。并且这个库的核心实现使用c语言实现的，保证了这个库在运算上的较高速度。
在近期进行四元数的学习中，比较了多个库，其中包括Scipy的旋转相关库，以及其他库，最终还是选择了这个库，原因在于其对于numpy的支持，但是由于其说明文档中只有四元数很小一部分的使用说明，但其实这个库所能实现的功能是远大于作者写的说明文档的，故写下这篇中文文档，供自己记录学习。
二、安装 如果是在conda环境下的，最好使用
conda install -c conda-forge quaternion
如果出现了，下载安装后No module name ‘quaternion’，可以适当降低numpy版本，目前numpy-1.20.3适配quater
nion-2022.4.3版本
也可以使用pip
python -m pip install --upgrade --force-reinstall numpy-quaternion
根据Releases · moble/quaternion (github.com)中说明的使用依赖仍然需要安装conda install scipy numba
三、基础用法 import numpy as np import quaternion 首先构建几个四元数 q1 = np.quaternion(1,2,3,4) q2 = quaternion.from_float_array([1,2,3,4]) # 生成的都是单位四元数 q3 = quaternion.from_rotation_matrix([[1,2,3],[1,2,3],[1,2,3]]) q4 = quaternion.from_euler_angles([1,2,3]) print(q1,q2,q3,q4) 四元数叉乘 ( w 1 , x 1 , y 1 , z 1 ) ⊗ ( w 2 , x 2 , y 2 , z 2 ) = ( w 1 w 2 − x 1 x 2 − y 1 y 2 − z 1 z 2 , w 1 x 2 + x 1 w 2 + z 1 y 2 − y 1 z 2 , w 1 y 2 + y 1 w 2 + x 1 z 2 − z 1 x 2 , w 1 z 2 + z 1 w 2 + y 1 x 2 − x 1 y 2 ) (w_1,x_1,y_1,z_1) \otimes (w_2,x_2,y_2,z_2) = \begin{matrix} (&amp;w_1w_2-x_1x_2-y_1y_2-z_1z_2,\\&amp;w_1x_2+x_1w_2+z_1y_2-y_1z_2,\\&amp;w_1y_2+y_1w_2+x_1z_2-z_1x_2,\\&amp;w_1z_2+z_1w_2+y_1x_2-x_1y_2&amp;) \end{matrix} (w1​,x1​,y1​,z1​)⊗(w2​,x2​,y2​,z2​)=(​w1​w2​−x1​x2​−y1​y2​−z1​z2​,w1​x2​+x1​w2​+z1​y2​−y1​z2​,w1​y2​+y1​w2​+x1​z2​−z1​x2​,w1​z2​+z1​w2​+y1​x2​−x1​y2​​)​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/413893252fff688e55a567ff61551439/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd3e5777e6c26f54582e773a693a6772/" rel="bookmark">
			vue-element-admin npm i code 128
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如图，这是我在下载官网vue-element-admin后使用npm install命令后报的错，查了好多文章有配置GitHub里ssh的，有安装pathon和node -sass的，还有node和npm版本问题的，然后还有。。。。。。之后我看了运行日志也没找出来问题该怎么解决。（咋改咋报错，后面好几次报的错都不一样，最后我重新下载了这个vue-element-admin模板文件）
好吧！最后发现使用yarn很管用，命令如下：
npm install yarn -g
yarn install
然后官网下载下来的项目还是运行不了，之后再运行npm install 命令，这个命令又移除和刷新了包里的一些东西，然后项目就能运行了，就是时间有点长，不知道是不是我开vpn的原因。
下面是我执行过的其他的一些命令和其他的解决方法
1.这个是把包下下来了之后但还是报错了后进行的操作（我的好几次错误中有把node-modules包下载下来还报错的情况，但这个对我的情况不管用）
2.这个是git的问题（不知道跟这个有关系吗，反正我试了）
这个是因为有的库有改动，不能通过git://访问了，这时我们可以改为使用https://来访问。命令如下：
git config --global http.sslverify “false”
在请求git://地址时，自动替换为https://，命令如下：
git config --global url.“https://”.insteadOf git://
如果想删除这个设置，命令如下：
git config --global unset url.“https://”.insteadOf
3.node和Python版本（这个我没有试，用的就是老之前下载的）
我的node是14.17.6 ，Python是3.9.2，我的Python安装时间挺长了，但好像也没问题，Python官方说的是跟装sass有关系，我不存在这个问题，至于node的话我看有的文章说vue-element-admin是基于node12这个版本构建的，但我这还是14版本的也没有问题。
4.配置GitHub里ssh（这个我试了对我也没用，下面是别人的操作步骤，你可以尝试一下）
桌面右键，git bash here 输入以下 ssh-keygen -t rsa -C “xxxxxx@qq.com”这里输入你自己的GitHub账号（下面几个配置好像不设置也行?反正直接回车全部按过去也行）
然后打开C:\Users\你的用户.ssh文件夹下会多出两个文件，id_rsa.pub和id_rsa，这个known_hosts文件是本来就有的，打开id_rsa.pub复制里面的全部内容。之后用你上面填的邮箱登录github.com 如下图将复制的内容粘贴到Key的区域，然后Add SSH key就可以了。回去继续npm install
哈哈！最后终于成功了，真蛋疼，以下是成功运行截图
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa66a193d341f4d8b057df822cffb1f5/" rel="bookmark">
			【word】插入mathtype公式，造成前后文本不同行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、问题描述 在word文本中插入mathtype公式，在默认配置下，会造成前后文本不同行的现象，例如：
二、解决方案 要求1：字符间距位置，设置为“标准”；要求2：段落文本对齐方式，设置为“居中”； 以WPS为例：
1、设置“标准”字符间距位置
2、设置文本对齐方式
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05a2fe086613e25ee725f5038c3e41e9/" rel="bookmark">
			hadoop报错：Hadoop启动时，没有启动datanode
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述： 当我们多次格式化文件系统（hadoop namenode -format）时，会出现DataNode无法启动。
多次启动中发现有NameNode节点，并没有DataNode节点
出现该问题的原因： 在第一次格式化dfs后，启动并使用了hadoop，后来又重新执行了格式化命令（hdfs namenode -format)，这时namenode的clusterID会重新生成，而datanode的clusterID 保持不变。
解决办法： 根据日志中的路径，我这边放置在/opt/soft/hadoop313/data/dfs目录下，能看到 data和name两个文件夹。
解决方法一：（推荐） 删除DataNode的所有资料及将集群中每个datanode节点的/dfs/data/current中的VERSION删除，然后重新执行hadoop namenode -format进行格式化，重启集群，错误消失。
解决方法二： 将name/current下的VERSION中的clusterID复制到data/current下的VERSION中，覆盖掉原来的clusterID
name/current:
data/current：
重新启动:start-all.sh
jps一下，就好啦
总结: 每次运行结束 Hadoop 后，都要执行 stop-all.sh 关掉Hadoop所有服务。下次想重新运行 Hadoop，不用再格式化 NameNode ，直接启动 Hadoop 即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74c87ecfe90391e0aa93615a68021bce/" rel="bookmark">
			数组——二分法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、理论基础 假设数组 nums 是按升序排列的，给定一个目标值 target，从序列的中间位置 mid 开始比较：
如果当前位置 nums[mid] === target，则查找成功；如果 nums[mid] &lt; target，则在 nums[mid + 1] 到 nums[nums.length - 1] 中查找；如果 nums[mid] &gt; target，则在 nums[0] 到 nums[mid - 1] 中查找；重复以上过程，直至找到 target 为止。 当数据量很大时采用该方法，使用二分法查找时，数据须是排好序的。时间复杂度：O(logn) 二、解题思路 如果题目规定了数组是有序的，同时题目还强调数组中没有重复元素，满足上面两个条件的时候，就可以考虑使用二分法解题了。
首先定义变量 left, right, mid，left 是查找区间的最左侧下标，right 是查找区间的最右侧下标，mid 是 left 和 right 的中位数。
我们定义 target 是在 [left, right] 区间里，使用 while 循环进行查找，循环成立的条件是 left &lt;= right，有如下两个要点：
while (left &lt;= right) 这里要使用 &lt;=if (nums[mid] &gt; target) 条件成立时， right 要赋值为 mid - 1 其实用 left &lt; right 作为条件也是可以的，但是是两种完全不同的写法。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/74c87ecfe90391e0aa93615a68021bce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7848aab7404c73e122a2999d039d881/" rel="bookmark">
			【hadoop基础知识】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HADOOP基础 1. Hadoop 简介什么是 Hadoop？Hadoop 的历史和发展Hadoop 的优势和应用场景Hadoop 的优势主要体现在以下几个方面：Hadoop 的应用场景主要包括以下几个方面： Hadoop 的核心组件Hadoop 由多个核心组件构成，主要包括以下几个： Hadoop 的发展趋势 2.Hadoop 核心组件Hadoop 分布式文件系统（HDFS）MapReduce 分布式计算框架YARN（Yet Another Resource Negotiator）Hadoop CommonZooKeeper 3. Hadoop 数据处理技术Hadoop 的数据处理流程Hadoop 的数据处理工具和技术HivePigHBaseSqoopFlumeFlume 的主要组成部分包括：Flume 的工作流程如下：Flume 的应用场景包括： 4. Hadoop 集群搭建和管理Hadoop 集群的架构和规划Hadoop 集群的搭建和配置Hadoop 在 CentOS 7 上的安装和配置安装 Java下载 Hadoop配置 Hadoop配置环境变量配置 Hadoop格式化 NameNode启动 Hadoop验证 Hadoop Hadoop 集群在 CentOS 7 上的安装和配置准备工作配置主机名配置 SSH安装 Java下载 Hadoop 配置 Hadoop配置环境变量配置 Hadoop配置节点信息配置 Hadoop 环境 启动 Hadoop测试 Hadoop结束 Hadoop Hadoop 集群的启动和停止启动集群停止集群 Hadoop 集群的监控和管理Hadoop Web UIHadoop 命令行工具日志监控第三方监控工具 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a7848aab7404c73e122a2999d039d881/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e180d17c6a9b31a03d9f665ac2187d41/" rel="bookmark">
			【Python三种打包方式】分别使用PyInstaller &amp; setupTools &amp; 拷贝环境实现项目打包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【Python三种打包方式】分别使用PyInstaller &amp; setupTools &amp; 拷贝环境实现项目打包 文章目录 【Python三种打包方式】分别使用PyInstaller &amp; setupTools &amp; 拷贝环境实现项目打包1、setupTools和PyInstaller打包的区别2、使用setupTools打包本地项目0）项目准备 &amp; 生成`requirements.txt` &amp; 编写打包文件a）项目准备b）生成`requirements.txt`c）编写打包文件 1）打包成源码 &amp; 二进制可安装软件包（`whl`）并引用2）上传whl到PyPI3）可能存在的问题 3、使用PyInstaller打包本地项目1）PyInstaller将主函数打包成可执行文件2）导包和静态文件引入问题3）其他问题 4、拷贝环境并编写执行脚本 1、setupTools和PyInstaller打包的区别 pyinstaller和setuptools打包有什么区别（来自ChatGPT的答案）
pyinstaller和setuptools都是 Python 中常用的打包工具，但它们的主要目的和工作方式略有不同。
pyinstaller 是一个可以将 Python 代码打包成一个可执行文件的工具，它会将你的 Python代码和所有依赖项打包成一个单独的可执行文件，让你的代码可以在没有Python解释器的情况下运行。这使得你可以将你的 Python 应用程序发布给没有安装 Python 的用户，或者将它们放在没有 Python 环境的机器上。
setuptools 则是一个用于构建 Python 软件包的工具，它可以帮助你将你的 Python代码打包成一个可安装的软件包，你可以将这个软件包发布到 PyPI 或其他软件包管理器中。setuptools还提供了许多用于定义软件包元数据、依赖项和其他设置的选项，以及用于打包软件包的命令行工具。
因此，尽管 pyinstaller和 setuptools两者都能将 Python 代码打包成一个独立的分发形式，但它们的主要目的略有不同。
如果你想要将你的 Python应用程序打包成一个单独的可执行文件，可以选择 pyinstaller。
如果你想要将你的 Python 代码打包成一个可安装的软件包并将其发布到 PyPI 或其他软件包管理器中，可以选择setuptools。
2、使用setupTools打包本地项目 参考
【python】上传 Python 包到 pypi 官网
【Python】如何在PyPI上发布自定义软件包
Packaging and distributing projects
Python 项目代码写完了，然后怎么打包和发布？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e180d17c6a9b31a03d9f665ac2187d41/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a78670fbe3fe450804de620fe9886292/" rel="bookmark">
			超级实用--解决大问题了--如何设置哔哩哔哩-实现3,4倍速视频播放---工作技巧001
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个太实用了,为什么....因为我平时看教程的时候,如果速度过慢,就会影响效率,因为很多的技术点
都已经知道是怎么回事,很熟悉了,想跳过吧,又想听听熟悉一下,而如果一直用2倍速播放,又浪费时间
但是播放器上只能设置2倍速播放,那么怎么弄呢?可以这样设置...总于知道怎么弄了...
要不然太浪费时间了,为什么不加上,3倍速,4倍速播放....气死人了...
来看看怎么弄吧:
首先:我们在视频的播放页面,找到,按下F12打开开发者模式然后看一下,elements这里,其实有个
video标签的.
然后这个标签 可以操作的:
然后切换到这个Console这个标签上,然后,在最下面命令行写入. document. querySelector('video').playbackRate=3
这样一句代码,然后回车执行就可以了,然后你回去播放,就会变快了...太棒了...
再也不用那么的浪费时间了...之前愁死了..
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96d91b6954d71cc3747b5a59d9f512b6/" rel="bookmark">
			uniapp如何判断是哪个（微信、百度）平台的小程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		其实大家在开发uniapp项目的时候长长会遇到这样一个问题，就是针对某些小程序，没发去适配相关的功能，所以要针对不同的平台，进行不同的处理，所以我也是在实战中发现了这个问题，特意查了很多地方才找到相关的内容，特此在该平台进行记录。
#ifdef ： if defined 仅在某个平台编译
#ifndef ： if not defined 在除里该平台的其他编译
#endif ： end if 结束条件编译
值平台参考文档APP-PLUS5+AppHTML5+ 规范APP-PLUS-NVUE5+App nvueWeex 规范H5H5MP-WEIXIN微信小程序微信小程序MP-ALIPAY支付宝小程序支付宝小程序MP-BAIDU百度小程序百度小程序MP-TOUTIAO头条小程序头条小程序MP-QQQQ小程序（目前仅cli版支持）MP微信小程序/支付宝小程序/百度小程序/头条小程序/QQ小程序 案例如下可进行参考：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/169f242fd934d2de09c2e5ed4428e02c/" rel="bookmark">
			mybatis-plus 主子表新增如何获取自增主键ID
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题： 因为主表的id是自增的，在保存的时候，先需要将主表保存后，获取到主表的主键id，然后存到子表中。在xml中写好了insert标签的语句，但是保存后，拿到的id是null
原来的xml是这样写的。 &lt;insert id="insertUser" parameterType="User"&gt; insert into sys_user &lt;trim prefix="(" suffix=")" suffixOverrides=","&gt; &lt;if test="cid != null"&gt;cid,&lt;/if&gt; &lt;if test="code != null"&gt;code,&lt;/if&gt; &lt;/trim&gt; &lt;trim prefix="values (" suffix=")" suffixOverrides=","&gt; &lt;if test="cid != null"&gt;#{cid},&lt;/if&gt; &lt;if test="code != null"&gt;#{code},&lt;/if&gt; &lt;/trim&gt; &lt;/insert&gt; 查了很多资料很多人说添加一个resultMap 或者resultType，但是insert标签里并没有这两个属性。后来再一个老哥的博客下看到了另外两个属性的解释useGeneratedKeys和keyProperty
useGeneratedKeys设置为 true 时，表示如果插入的表id以自增列为主键，则允许 JDBC 支持自动生成主键，并可将自动生成的主键id返回。useGeneratedKeys参数只针对 insert 语句生效，默认为 false；keyProperty=“id” 注意这里的id是自增的主键id 修改后的xml
&lt;insert id="insertUser" parameterType="User" useGeneratedKeys="true" keyProperty="cid"&gt; insert into sys_user &lt;trim prefix="(" suffix=")" suffixOverrides=","&gt; &lt;if test="cid != null"&gt;cid,&lt;/if&gt; &lt;if test="code != null"&gt;code,&lt;/if&gt; &lt;/trim&gt; &lt;trim prefix="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/169f242fd934d2de09c2e5ed4428e02c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/929c6f06dcbbf13331281936187ff462/" rel="bookmark">
			加密算法解析一：MD5
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
加密在生活中无处不在，从以前的战争信件加密到近代的报文加密再到现代的网络信息加密，都是防止信息泄露。若信息被人截获甚至破解了，那就危险了，比如战争会很被动甚至失败且牺牲很多生命、个人的账号密码会被他人盗用甚至转账。所以，加密尤为重要，而密文的安全性与加密算法的设计与使用密切相关，所以了解加密算法是很有必要的。这里本篇主要介绍单向散列算法之一：MD5算法。
概要
MD5算法是一种散列(Hash)算法，是一种将任意长度的消息压缩到某一固定长度的算法(不可逆)，一般可用于密码保存、数字签名、消息完整性检测等。
步骤
MD5算法要经过补位、添加长度、初始化MD缓存器、处理数据、输出这五个步骤。
补位：MD5通过对原文进行补位，将最终位数补成对512求模的结果为448，即原文长度补位成只差64位(bit)就是512的整数倍，即使本身长度符合差64位就是512的倍数也要补位，补位规则第一个补1，后面都补0。
添加长度：计算补位前的长度，取其二进制的64位，长度数值大于64位的取64位低位，比如长度为8，二进制表示为 1000，前面补60个0就是8的64位二进制表示了。最后消息就是为512的整数倍。
初始化MD缓存器：进行MD5运算需要用到4个数，这4个数用16进制分别表示为：01234567、89abcdef、fedcba98、76543210，这4个数一般称为A、B、C、D。这4个数一共128位二进制会连续存储在缓存器中。
处理数据：定义4个函数F、G、H、I，每个函数输入都是3个32位数，输出是1个32位数 。以512分组为单位处理消息，每个分组分别用F、G、H、I这4个函数进行4轮运算，每轮运算将当前组和ABCD中的数为输入，输出后的值会与ABCD之一相加并更新ABCD的值，由此完成一次循环。
输出：最终的ABCD将被输出为MD5散列的结果，一般这个128位二进制会转化为一个32位的16进制数输出，有些API里会出现16位的MD5返回值，那个16位的返回值一般是从32位的返回值里截取的。
优点
1、加密速度快：加密算法无需密钥，速度快。
2、对原文敏感：哪怕原文有一个二进制的变化，都会导致密文不同。
3、算法不可逆：知道密文除了穷举，基本无法可解密出原文。
缺点
1、碰撞：即数据源不同，经过MD5算法算出的结果却相同。一方面是MD5采用hash函数处理数据，那必然会出现碰撞问题；另一方面数据源是无限的，但MD5的密文个数却是有限的，以后肯定也会出现碰撞问题。这个问题在2004年被中国科学院院士王小云证实，MD5无法防止碰撞。
2、字典表大：MD5流行这么久，会积累大量数据，部分网站会存储MD5字典表，这样有可能通过MD5加密后的密文直接通过查表方式得到原文。
缺点解决方案
对于MD5的字典表大的缺点，可以给MD5加盐解决，加盐并不能影响MD5算法，只能影响原文，比如要加密密码123456，若直接对123456用MD5加密保存就完了，这种123456的常用MD5密文可以直接查表得到123456原文，我们可以用 原文+随机盐 组成原文来加密保存，比如使用 密码+随机数(账号/密码最后几位?+创建/修改时间？) 加密后再保存，就很难有字典找出原文了。
对于MD5碰撞的缺点，目前没有有效的解决方案，不过概率非常低，一般可以不管，对碰撞要求高的业务建议使用别的加密方式。
使用场景
1、密码加密：对于用户的密码，肯定不希望被别人破解，一般会采用不可逆算法，验证密码一般用密文对比。
2、信息签名：MD5对原文敏感，对于数据或文件的传输，可在传输前后都生成MD5来对比校验，来验证数据或文件是否损坏或修改。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2840290f96349ad38447fed3b39d8362/" rel="bookmark">
			【ESP32&#43;freeRTOS学习笔记-(九)事件组】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1、概述2、事件组的特性2.1 事件组、事件标志和事件位2.2 事件组位长的设置2.3 多任务访问 3、使用事件组管理事件3.1 xEventGroupCreate()3.2 xEventGroupSetBits()3.3 xEventGroupGetBits()3.4 xEventGroupWaitBits()3.5 示例 4、使用事件组同步任务4.1 xEventGroupSync()4.2 实例5 总结 1、概述 实时嵌入式系统必须采取行动来响应事件。前面描述了 FreeRTOS 允许将事件传递给任务的功能。此类功能包括信号量和队列，它们都具有以下属性：
-》它们允许任务在阻塞状态下等待单个事件发生。
-》当事件发生时，它们解除对单个任务的阻塞——解除阻塞的任务是等待事件的最高优先级任务。
事件组是 FreeRTOS 的另一个功能，它允许将事件传达给任务。与队列和信号量不同：
事件组允许任务在阻塞状态下等待多个事件之一的组合发生。
事件组在事件发生时解除等待同一事件或事件组合的所有任务的阻塞。
事件组的这些独特属性使其可用于同步多个任务、将事件广播到多个任务、允许任务在阻塞状态等待一组事件中的任何一个发生
，以及允许任务处于阻塞状态中等待多个操作的完成。
事件组还提供了减少应用程序使用的 RAM 的机会，因为通常可以用单个事件组替换许多二进制信号量。
事件组功能是可选的。要包含事件组功能，请将 FreeRTOS 源文件 event_groups.c 构建为项目的一部分。
2、事件组的特性 2.1 事件组、事件标志和事件位 一个事件组可以同时设置8个或24个事件。
事件“标志”是一个布尔值（1 或 0），用于指示事件是否发生。
事件“组”是一组事件标志。
一个事件标志只能为 1 或 0，允许将一个事件标志的状态存储在一个位中，并将一个事件组中所有事件标志的状态存储在一个变量中；事件组中每个事件标志的状态由 EventBits_t 类型变量中的单个位表示。因此，事件标志也称为事件“位”。
如果 EventBits_t 变量中的某个位设置为 1，则该位表示的事件已经发生。如果EventBits_t 变量中的某个位设置为0，则该位表示的事件尚未发生。
例如：如果事件组的值为 0x92（二进制 1001 0010），即，仅设置事件位 1、4 和 7，因此仅发生了位 1、4 和 7 表示的事件。
而1，4，7对应的事件含义是由开发者定义的。比如，将事件组中的位 1 定义为“已从网络接收到消息”；将事件组中的第 4位定义为“一条消息已准备好发送到网络上”；将事件组中的第 7 位定义为“中止当前网络连接”。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2840290f96349ad38447fed3b39d8362/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ea7d5701919f4dc52a7d703b3586943/" rel="bookmark">
			YOLO系列详解：YOLOv1、YOLOv2、YOLOv3、YOLOv4、YOLOv5、YOLOv6、YOLOv7
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 YOLO系列是one-stage且是基于深度学习的回归方法，而R-CNN、Fast-RCNN、Faster-RCNN等是two-stage且是基于深度学习的分类方法。
YOLO官网：GitHub - pjreddie/darknet: Convolutional Neural Networks
1.1 YOLO vs Faster R-CNN 1、统一网络：YOLO没有显示求取region proposal的过程。Faster R-CNN中尽管RPN与fast rcnn共享卷积层，但是在模型训练过程中，需要反复训练RPN网络和fast rcnn网络。相对于R-CNN系列的"看两眼"(候选框提取与分类)，YOLO只需要Look Once.
2、YOLO统一为一个回归问题，而Faster R-CNN将检测结果分为两部分求解：物体类别（分类问题）、物体位置即bounding box（回归问题）。
二、YOLOv1 论文地址：https://arxiv.org/abs/1506.02640
官方代码：GitHub - pjreddie/darknet: Convolutional Neural Networks
YOLOv1的核心思想：
YOLOv1的核心思想就是利用整张图作为网络的输入，直接在输出层回归bounding box的位置和bounding box所属的类别。Faster RCNN中也直接用整张图作为输入，但是Faster-RCNN整体还是采用了RCNN那种 proposal+classifier的思想，只不过是将提取proposal的步骤放在CNN中实现了,而YOLOv1则采用直接回归的思路。 2.1、实现方法 将一幅图像分成SxS个网格(grid cell)，如果某个object的中心落在这个网格中，则这个网格就负责预测这个object。 每个网格要预测B个bounding box，每个bounding box除了要回归自身的位置之外，还要附带预测一个confidence值。这个confidence代表了所预测的box中含有object的置信度和这个box预测的有多准两重信息，其值是这样计算的： 该表达式含义：如果有object落在一个grid cell里，则第一项取1，否则取0。 第二项是预测的bounding box和实际的groundtruth之间的IoU值。 每个bounding box要预测(x, y, w, h)和confidence共5个值，每个网格还要预测一个类别信息，记为C类。则SxS个网格，每个网格要预测B个bounding box还要预测C个categories。输出就是S x S x (5*B+C)的一个tensor。 注意：class信息是针对每个网格的，confidence信息是针对每个bounding box的。
举例说明： 在PASCAL VOC中，图像输入为448x448像素，取S=7，B=2，一共有20个类别(C=20)。则输出就是7x7x(2x5+20)的一个tensor。整个网络结构如下图所示：
在test的时候，每个网格预测的class信息和bounding box预测的confidence信息相乘，就得到每个bounding box的class-specific confidence score，得到每个box的class-specific confidence score以后，设置阈值，滤掉得分低的boxes，对保留的boxes进行NMS处理，就得到最终的检测结果。 该表达式含义：等式左边第一项就是每个网格预测的类别信息，第二三项就是每个bounding box预测的confidence。这个乘积即encode了预测的box属于某一类的概率，也有该box准确度的信息。 注意： 由于输出层为全连接层，因此在检测时，YOLOv1模型的输入只支持与训练图像相同的输入分辨率。虽然每个格子可以预测B个bounding box，但是最终只选择IOU最高的bounding box作为物体检测输出，即每个格子最多只预测出一个物体。当物体占画面比例较小，如图像中包含畜群或鸟群时，每个格子包含多个物体，但却只能检测出其中一个。 简单的概括就是：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ea7d5701919f4dc52a7d703b3586943/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/093f117878e9995271a548ec7901f4eb/" rel="bookmark">
			git之工作区暂存区和仓库区
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		工作区暂存区和仓库区 工作区
对于添加、修改、删除文件的操作，都发生在工作区中 暂存区
暂存区指将工作区中的操作完成小阶段的存储，是版本库的一部分 仓库区
仓库区表示个人开发的一个小阶段的完成 仓库区中记录的各版本是可以查看并回退的但是在暂存区的版本一旦提交就再也没有了 Git单人本地仓库操作 课程目标：学习常用的Git终端命令提示：本地仓库是个.git隐藏文件 以下为演示Git单人本地仓库操作
1.安装git
sudo apt-get install git 密码：chuanzhi 2.查看git安装结果
git 3.创建项目
在桌面创建test文件夹，表示是工作项目
Desktop/test/ 4.创建本地仓库
进入到test，并创建本地仓库.git 新创建的本地仓库.git是个空仓库
cd Desktop/test/ git init 创建本地仓库.git后
进入该待显示的文件路径，ctrl + h ，则显示隐藏文件
5.配置个人信息
git config user.name '张三' git config user.email 'zhangsan@163.com' 配置个人信息后
默认不配置的话，会使用全局配置里面的用户名和邮箱
全局git配置文件路径：~/.gitconfig
6.新建py文件
在项目文件test里面创建login.py文件，用于版本控制演示
7.查看文件状态
红色表示新建文件或者新修改的文件,都在工作区.绿色表示文件在暂存区 新建的login.py文件在工作区，需要添加到暂存区并提交到仓库区
git status 8.将工作区文件添加到暂存区
# 添加项目中所有文件 git add . 或者 # 添加指定文件 git add login.py 9.将暂存区文件提交到仓库区
commit会生成一条版本记录 -m后面是版本描述信息
git commit -m '版本描述' 10.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/093f117878e9995271a548ec7901f4eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87d331f0f13909a6b49ad602ac34b5a9/" rel="bookmark">
			网络编程之TCP 网络应用程序开发流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TCP 网络应用程序开发流程 学习目标
能够知道TCP客户端程序的开发流程
1. TCP 网络应用程序开发流程的介绍 TCP 网络应用程序开发分为:
TCP 客户端程序开发
TCP 服务端程序开发
说明:
客户端程序是指运行在用户设备上的程序 服务端程序是指运行在服务器设备上的程序，专门为客户端提供数据服务。
2. TCP 客户端程序开发流程的介绍 步骤说明:
创建客户端套接字对象
和服务端套接字建立连接
发送数据
接收数据
关闭客户端套接字
3. TCP 服务端程序开发流程的介绍 步骤说明:
创建服务端端套接字对象
绑定端口号
设置监听
等待接受客户端的连接请求
接收数据
发送数据
关闭套接字
4. 小结 TCP 网络应用程序开发分为客户端程序开发和服务端程序开发。
主动发起建立连接请求的是客户端程序
等待接受连接请求的是服务端程序
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1a6d13ecafd8be97a28c5b0b5fbfb8b/" rel="bookmark">
			Chatgpt
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ChatGPT是一款用C语言编写的开源GPT-3模型参数服务器。它可以用于分布式计算、文件系统、网络拓扑和机器学习。目前支持的应用包括： 1.对 TensorFlow模型进行优化，使用 goroutine构建服务器，并在X86架构上进行测试 2.基于 Python对 TensorFlow进行性能优化 3.集成 Hadoop，实现分布式计算 4.支持任何标准的 Web服务器和应用程序，以及所有框架 5.将 TensorFlow运行在高可用的 Linux或 Windows系统上，并通过 DNS安全更新和防火墙（NOSB）提供不间断服务 6.用于增强的网络拓扑搜索 7.在机器学习中使用 Gaussian模型进行预测和评估 8.为各种分布式应用程序开发和部署优化基于 gRPC的 Web服务器 9.用于自动控制系统，包括网络、控制器、传感器、设备等 10.支持所有类型的嵌入式应用程序，包括图像识别、工业测量、机器视觉、家庭自动化以及各种物联网设备
1.概述
ChatGPT是一个GPT-3模型参数服务器，它可以帮助开发者创建和维护多种语言的模型参数，例如：英语、德语、法语、西班牙语和日语等。这款参数服务器由C语言编写，可以用来运行各种语言的GPT-3模型。通过 ChatGPT，可以运行任意类型的语言的模型以及通过简单地调用这些模型而开发出来的应用程序，例如机器学习、机器视觉、语言预测等。 ChatGPT可以让开发者在一个易于管理且维护成本较低的环境中完成模型工作。它通过创建一个完整的分布式计算框架，提供了一种更简单和快速地实现分布式计算能力的方法。ChatGPT采用了流行的分布式计算技术： Hadoop和 MapReduce，以及 Kafka、 Redis和 MongoDB等流行数据库服务，从而加快了您建立和维护分布式数据系统或应用程序所需的速度。
2.优点
与其他GPT-3模型参数服务器相比， Chatgpt有以下几个优点： 更大的规模。Chatgpt可以用C语言编写，并包含多种网络拓扑结构，因此在构建大规模模型参数服务器方面具有很大的灵活性和扩展性。 易于使用。与GPT-3参数服务器不同， Chatgpt以C语言编写并经过优化，因此更容易学习和使用它。 除了 Python和C外， Chatgpt还支持 Google File System、 Microsoft Active Directory和其他 Web服务器，以及所有其他框架。 对其他语言的支持： Chatgpt支持大多数标准的 Web服务器和应用程序，包括中文（HongKong）、日语（Kawasaki）等
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/177fd7a21efdcb1fb634772c1fc6b188/" rel="bookmark">
			解决VsCode的命令行显示中文乱码问题方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一开始为了解决这个问题查了很多文章，有方法：
0、先在命令行执行 chcp 65001（换成utf-8编码） 再运行程序的（但不能一劳永逸）；1、修改 VsCode 的 settings.json 的；2、还有修改系统注册表的；3、还有修改系统全局字符编码为 utf-8 的。
后面看了某个博主的方法发现，有个很简单的办法。
解决方法1(简单，优雅的办法)：在程序开头加一个 system() 执行 chcp 65001（换成utf-8编码） 每次执行程序都能在命令行正确打印中文。
system("chcp 65001"); /* cmd chcp 命令切换字符编码为 utf-8 以显示中文 */ 解决方法2：点击右下角中的“UTF-8”，选择“通过编码重新打开”，输入“GB 2312”，选择“Simplified Chinese(GB 2312)”即可。 选择“通过编码重新打开”
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fdf4d0214ba25b59a079e316b21fef54/" rel="bookmark">
			Ajax的同步与异步
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.同步请求是指当前发出请求后，浏览器什么都不能做，
必须得等到请求完成返回数据之后，才会执行后续的代码，
相当于生活中的排队，必须等待前一个人完成自己的事物，后一个人才能接着办。
也就是说，当JS代码加载到当前AJAX的时候会把页面里所有的代码停止加载，页面处于一个假死状态，
当这个AJAX执行完毕后才会继续运行其他代码页面解除假死状态
2.默认异步：异步请求就当发出请求的同时，浏览器可以继续做任何事，
Ajax发送请求并不会影响页面的加载与用户的操作，相当于是在两条线上，各走各的，互不影响。
一般默认值为true，异步。异步请求可以完全不影响用户的体验效果，
无论请求的时间长或者短，用户都在专心的操作页面的其他内容，并不会有等待的感觉。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ce6766ea05c360e8dcc6092658434b4/" rel="bookmark">
			迭代器和生成器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		21. 迭代器和生成器 1. 迭代器: 在JavaScript中，迭代器（Iterator）是一个对象，用于在可迭代的数据结构中遍历和访问每个元素，而不必暴露该数据结构的内部结构。很多数据结构都实现了可迭代接口：字符串、数组、Map、Set、arguments和NodeList等DOM集合类型，可以使用Symbol.iterator方法获取它们的迭代器对象。
迭代器对象通常实现了一个next()方法，每次调用该方法将返回一个包含两个属性的对象：value和done。其中，value属性表示集合中下一个要返回的元素的值，done属性表示是否已经到达集合的末尾。当done属性为true时，表示已经访问完所有元素。如：
let str = "hello" let strIter = str[Symbol.iterator](); console.log(strIter.next());//{value: 'h', done: false} console.log(strIter.next());//{value: 'e', done: false} console.log(strIter.next());//{value: 'l', done: false} console.log(strIter.next());//{value: 'l', done: false} console.log(strIter.next());//{value: 'o', done: false} console.log(strIter.next());//{value: undefined, done: true} let arr = [1,2,3] let arrIter = arr[Symbol.iterator](); console.log(arrIter.next());//{value: '1', done: false} console.log(arrIter.next());//{value: '2', done: false} console.log(arrIter.next());//{value: '3', done: false} console.log(arrIter.next());//{value: undefined, done: true} 自定义可迭代对象
// 创建一个可迭代对象 const myObj = { data: [1, 2, 3], [Symbol.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ce6766ea05c360e8dcc6092658434b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbb6c0dab4a3b7a0edc8bfc40e520fbb/" rel="bookmark">
			秋招面试问题整理之机器学习篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 随机森林在决策树的哪些方面做出了改进随机森林里每棵树的权重不一定会变成什么模型 方差和偏差，正则化解决的是方差大还是偏差大的问题正则化的方法总结了解VC维吗svd++了解吗 随机森林在决策树的哪些方面做出了改进 回答思路：
随机森林和决策树有什么关联和决策树相比，随机森林在哪些方面有什么优势 回答：
随机森林是决策树的集成模型，它将多个决策树的输出整合起来生成最后的输出结果优势： 1.随机决策森林纠正了决策树的过度拟合（最主要）： 集成学习的优势：单棵决策树对数据的变化很敏感，很容易对一些噪声进行过拟合，当不断添加决策树到随机森林中时，过拟合的趋势会减少。引入随机性：在随机森林构建每棵决策树时，选择的特征子集是随机的，训练样本集也是随机的，随机性的引入在一定程度上减少了过拟合现象的发生随机森林的核心思想是“三个臭皮匠顶个诸葛亮”，即构建由多个弱分类器组合成的强分类器，所以在训练每棵决策树时，树的复杂度不会很高，这也减少了过拟合的趋势 随机森林里每棵树的权重不一定会变成什么模型 方差和偏差，正则化解决的是方差大还是偏差大的问题 一张图概括
偏差bias：描述的是预测值的期望与真实值之间的差距。偏差越大，越偏离真实数据方差：描述的是预测值的变化范围，离散程度，也就是离其期望值的距离。方差越大，数据的分布越分散偏差大，说明预测不准确，模型太简单方差大，说明数据一点点波动就引起输出的巨大偏移，学习能力过强，过拟合了总结一下：学习能力不行造成的误差是偏差，学习能力太强造成的误差是方差正则化解决的是模型太复杂的问题，也就是过拟合，所以解决的是方差大的问题 正则化的方法总结 参考BGoodHabit博主
首先，正则化是啥意思？我记得好像是在支持向量机中提出过，软间隔支持向量机那一章传统定义：在模型的损失函数增加惩罚项来增强模型的泛化能力现在定义更广泛，为提高测试集精度的一切方式都能称作正则化 了解VC维吗 svd++了解吗 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9cd2ed3e8a23ddc3665c6aea712cefdd/" rel="bookmark">
			Vue3后台管理系统（八）国际化切换组件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、图标 下载language.svg图标，存放到src/assets/icons文件夹下：iconfont-阿里巴巴矢量图标库
二、组件 在src/components文件夹下新建LangSelect文件夹，并在LangSelect文件夹中新建index.vue
&lt;!--src/components/LangSelect--&gt; &lt;script setup lang="ts"&gt; import { useI18n } from 'vue-i18n'; import { ElMessage } from 'element-plus'; import SvgIcon from '@/components/SvgIcon/index.vue'; import { useAppStore } from '@/store/modules/app'; const appStore = useAppStore(); const { locale } = useI18n(); function handleLanguageChange(lang: string) { locale.value = lang; appStore.changeLanguage(lang); if (lang == 'en') { ElMessage.success('Switch Language Successful!'); } else { ElMessage.success('切换语言成功！'); } } &lt;/script&gt; &lt;template&gt; &lt;el-dropdown class="lang-select" trigger="click" @command="handleLanguageChange" &gt; &lt;div class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9cd2ed3e8a23ddc3665c6aea712cefdd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3fb7064a154627bd773bcdf1aa2fae0b/" rel="bookmark">
			第一次美赛经历
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我的第一次数学竞赛 背景： Wordle 是《纽约时报》目前每日提供的一个热门谜题。玩家尝试在六次或更少的尝试中猜出一个五个字母的单词来解决谜题，每次猜都会收到反馈。对于这个版本，每个猜测必须是一个实际的英语单词。不允许比赛中未识别为单词的猜测 。Wordle 继 续 受到 欢 迎 ， 目 前已 有 超 过 60 种 语 言的 游 戏 版 本 。《 纽 约 时 报 》网 站对 Wordle 的说明指出，提交单词后，瓷砖的颜色会发生变化。黄色平铺表示该平铺中的字母在单词中，但它位于错误的位置。绿色平铺表示该平铺中的字母在单词中，并且位于正确的位置。灰色平铺表示该平铺中的字母根本不包含在单词中。
•报告结果的数量每天都在变化。开发一个模型来解释这种变化，并使用您的模型为 2023 年 3 月 1 日报告的结果数量创建一个预测区间。单词的任何属性是否会影响在硬模式下播放的报告分数百分比？如果是，怎么办？如果没有，为什么不呢？
•对于给定的未来解决方案单词，在未来的日期，开发一个模
型，使您能够预测报告结果的分布。换句话说，预测未来日期（1，2，3，4，5，6，X）的相关百分比。你的模型和预测有哪些不确定性？举一个具体的例子，说明你对 2023 年 3 月 1 日 EERIE 一词的预测。你对模型的预测有多自信？
•开发并总结一个模型，根据难度对解决方案单词进行分类。识别与每个分类相关的给定单词的属性。使用你的模型，EERIE 这个词有多难？讨论分类模型的准确性。
•列出并描述此数据集的一些其他有趣的功能。
……
解题思路 我们选的是2023年的c题，因为其它题目都要数据，我和队友们找了一上午都没找到什么有用的数据，最终还是选择了提供数据的c题。感觉主要是我的问题，Python学的不够深入，爬取不了什么有用的数据，拖了团队的后腿，感谢我的队友没有嫌弃我，人间大爱。
不得不说这四天的比赛非真的常幸苦，我是负责编程的，从早上8点一直敲代码到晚上12点，数据这边改一改，那边改一改，为了保存原来的模型，我每改一次数据就要引入一个变量，导致最后变量交错复杂，时不时会报错。程序员口中常说的屎山代码大概就是这么来的，重构代码即麻烦还可能会代码运行不了，于是不断往上面加东西，加到最后就算是自己也看不懂代码了。
刚开始拿到题目，我想的是如何处理这些单词，因为单词必须要处理成数字才能让计算机理解，这样我的算法才有用，所以我们一直卡在这里，最后还是绕了个大弯来解决这个问题，因为我真的不知道怎么处理了这些单词啊。经过激烈的头脑风暴，我找到了词向量这给东西，希望它能让我攻克这个难题，但是很遗憾，深入发掘，这属于自然语言处理问题，即NLP，属于深度学习领域的，与我这个目前只会几个机器学习算法的人有天壤之别的感觉。
第一问还是我的队友用时间序列做出来的，我大受震撼，感到不可思议以及难以理解，我认为这恰恰是我们要注意的地方，其中必有大坑，只能说学识尚浅。
第二问叫我们预测3月1日各猜测次数的百分比，是一个多输入多输出问题。所以第二问的压力落在了我的头上，这一问可以采用神经网络，但是容易过拟合，所以有了基于遗传算法的神经网络，再次大受震撼，一方面神经网络太难了，我的能力不足以驾驭它，另一方面是神经网络不是不建议在美赛中用吗，这次它竟然能如此大放异彩。我赶紧打开B站搜索视频，争取学会它，看半小时后我就跟它说再见了，这不是我能触碰的领域。只好再次另辟蹊径，先是发现了多变量的时间序列也能解决问题，但是不会，然后是多预测回归树，但是不会，这些对我来说真的都太难了。实在是没办法了，只能用最小二乘法强行解决问题。
第三问是叫我们建立一个模型，对单词进行分类。一开始我是想从自然语言处理方面入手的，奈何实力不够，于是去网上找别的方法，希望绕过处理单词这个棘手的问题。看了几篇思路分析，我觉得可以用Kmeans先聚类，然后用随机森林测试准确度，嗯，效果很好，好的有点出奇，其中必定有什么蹊跷，但是我发现不了，论文只能这样写了，再难的我也不会。
感想 这四天的比赛是真的学到了不少东西，论文写作、排榜，流程图，各种让人感到学识不足的算法，还有各种各样的工具，比如SPASS、Matlab、SAS，发表一篇好的论文需要全方面发展，我以前觉得学完一本数就能无往不胜了，这个想法还是太天真了。我从比赛中接触到了一个新的世界，优秀的人实在是太优秀了，算法竟然还能涉及这么多的方面，掌握了几个机器学习算法的我原理连入门都没有。在最后一天的时候，看到一个用信息论求出最优开局解，又是一次惊叹，还能用这种方法。不管怎么样，第一次以这样的方式开始我还是十分满意了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/212cbeaec56655a5228a5b77a7dae9dd/" rel="bookmark">
			python 识别图片验证码/滑块验证码准确率极高的 ddddocr 库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 验证码的种类有很多，它是常用的一种反爬手段，包括：图片验证码，滑块验证码，等一些常见的验证码场景。
识别验证码的python 库有很多，用起来也并不简单，这里推荐一个简单实用的识别验证码的库 ddddocr (带带弟弟ocr)库.
环境准备 python 版本要求小于等于python3.9 版本
pip 安装
pip install ddddocr 下载的安装包比较大，一般用国内的下载源可以加快下载速度
pip install ddddocr -i https://pypi.douban.com/simple github地址https://github.com/sml2h3/ddddocr
快速开始 先随便找个纯英文的验证码,保持为a1.png
代码示例
import ddddocr # 导入 ddddocr ocr = ddddocr.DdddOcr() # 实例化 with open('a1.png', 'rb') as f: # 打开图片 img_bytes = f.read() # 读取图片 res = ocr.classification(img_bytes) # 识别 print(res) 运行结果
已经能识别到 xnen ,但是会出现"欢迎使用ddddocr，本项目专注带动行业内卷…"提示语， 可以加一个参数show_ad=False
import ddddocr # 导入 ddddocr ocr = ddddocr.DdddOcr(show_ad=False) # 实例化 with open('a1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/212cbeaec56655a5228a5b77a7dae9dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e9bf00a1ca620040dfab993aef359e6/" rel="bookmark">
			Vue3后台管理系统（一）基础环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、初始化
二、整合Element-Plus
三、路径别名
四、多环境配置
五、反向代理
六、其他依赖
一、初始化 npm init vite@latest vue3-element-admin --template vue-ts 二、整合Element-Plus 1.本地安装Element Plus和图标组件
npm install element-plus npm install @element-plus/icons-vue 2.全局注册组件
// main.ts import ElementPlus from 'element-plus' import 'element-plus/theme-chalk/index.css' createApp(App) .use(ElementPlus) .mount('#app') 3.Element Plus全局组件类型声明
// tsconfig.json { "compilerOptions": { // ... "types": ["element-plus/global"] } } 4.页面使用
&lt;el-button type="primary"&gt;登录&lt;/el-button&gt; 三、路径别名 1. 安装@types/node
npm install @types/node --save-dev 2. Vite配置
// vite.config.ts import {defineConfig} from 'vite' import vue from '@vitejs/plugin-vue' import path from 'path' export default defineConfig({ plugins: [vue()], resolve: { alias: { "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e9bf00a1ca620040dfab993aef359e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ffb3e2fbf5414026bc88f9dacf39abc3/" rel="bookmark">
			在项目中实现防抖
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 防抖： 在n秒内执行第一次 若n秒内再次执行就清除上次定时器 让函数保持最后一次执行 实现防抖。
通俗点说，为了减少请求的次数做防抖处理，就是在一定时间内多次触发一个事件，就清除之前的计时器重新开始，这样就只会认准最后一次操作进行触发，优化性能，一般再可搜索下拉框和输入框体现的场景较多。
如何再项目于中使用防抖函数？ 我是放到了单独的js文件中，方便使用
创建debounce.js文件，将下面代码放文件中，再要使用组件文件中引入
有两种使用方式：
或者
// func是用户传入需要防抖的函数 // wait是等待时间，若不传参，默认500ms // 因为闭包，timer将一直在内存中 const debounce = (func, wait = 500) =&gt; { // 缓存一个定时器 let timer = null; // 返回的函数是每次用户实际调用的防抖函数 return (...args) =&gt; { // 如果已经设定过定时器了就清空上一次的定时器 if (timer) clearTimeout(timer); // 开始一个新的定时器，延迟执行用户传入的方法 timer = setTimeout(() =&gt; { func.apply(this, args); }, wait); }; }; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44c0acefe1c4620543abdbcc2940ed1c/" rel="bookmark">
			PCL1.11.0&#43;VTK8.2.0&#43;QT5.14.2&#43;VS2019在Win10环境下的配置（小白必看！）QVTKOpenGLNativeWidget
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前期准备PCL安装说明QT安装说明VS2019安装说明VTK编译说明1.新建三个目录2.以管理员身份运行Cmake3.部署Cmake环境 4.以管理员身份运行Visual Studio 2019 编译VTK5.给Qt添加QVTKOpenGLNativeWidget6.把编译好的Vtk文件覆盖到对应目录7.确认系统环境变量8.制作属性表(1).获取Lib文件(2).新建QT工程(3).新建属性表 属性页 ---&gt;链接器 ---&gt; 输入 ---&gt;附件依赖项：GetBoosLib.batGetBoosLib a releaseGetBoosLib a debugGetBoosLib a all GetFlannLib.batGetFlannLib a releaseGetFlannLib a debugGetFlannLib a all GetOpenNI2.batGetOpenNI2 a all GetQhullLib.batGetQhullLiba a releaseGetQhullLib a debugGetQhullLib a all GetVtkLib.batGetVtkLib a releaseGetVtkLib a debugGetVtkLib a all GetPclLib.batGetPclLib a releaseGetPclLib a debugGetPclLib a all 未完待续。。。 前期准备 PCL源码 (PCL-1.11.0-AllInOne-msvc2019-win64）https://github.com/PointCloudLibrary/pcl/releasesVTK源码（8.2.0）https://vtk.org/download/Cmake(cmake-3.18.0-rc2)https://cmake.org/download/VS2019(专业版)https://visualstudio.microsoft.com/zh-hans/downloads/QT（5.14.2）https://www.qt.io/download 这里楼主采用的基本都是最新版本，编译环境只要在这个版本以上基本上通用
PCL安装说明 新机器直接下载两个文件后，默认安装。环境变量选择给所有用户使用。
然后把pdb文件解压放在PCL1.11.0安装目录的bin下面就可以了。
（后面再详细讲解这部分）
QT安装说明 QT安装非常简单，5.14.2直接去楼主提供的地址下载。然后选择全部安装就可以了。（MSVC2017 64-bit 必须勾选，没有MSVC2019）安装完成后可以把需要使用的编译环境添加到系统Path里面
（此处暂时略过，下次再补上更详细教程。）这里重点讲下需要配置你编译环境的目录。否则你调试程序或者不打包程序直接运行就会提示缺少xxx.dll
VS2019安装说明 必须安装的两个选项，一个是使用c++进行桌面开发，一个是.net SDK（版本随意）否则会出现后面意想不到的情况。
VTK编译说明 VTK分为两部分，一个是VTKsource（必须）一个是VTKdata（非必须）
1.新建三个目录 把下载好的VTK-8.2.0.zip解压，放在VTK-source里面
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44c0acefe1c4620543abdbcc2940ed1c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f0ebfe7f34432102e7c9e2f72b692dd/" rel="bookmark">
			go圣经笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		121目录​​​​​​​
2.程序结构
2.1命名
2.2声明
2.3变量
2.3.1. 简短变量声明
2.3.2. 指针
2.3.3. new函数
​​​​​​​2.3.4. 变量的生命周期
10.包和工具
10.1包简介
10.2. 导入路径
2.程序结构 2.1命名 大写字母和小写字母是不同的名字，如hand和Hand关键字不能用于自定义名字 如：break default func if else
预定义名字 内建常量：true false nil
内建类型：int uint float complex bool byte error string rune
内建函数：make len cap copy close new append delete complex real imag panic recover
预定义名字不能用于定义名字
4.驼峰式命名 QuoteRuneToASCII和parseRequestLine这样的函数命名，大小写来分隔而不是下划线；
像ASCII和HTML这样的缩略词则避免使用大小写混合的写法。
2.2声明 Go语言主要有四种类型的声明语句：var、const、type和func，分别对应变量、常量、类型和函数实体对象的声明。在包一级声明语句声明的名字可在整个包对应的每个源文件中访问，相比之下，局部声明的名字就只能在函数内部很小的范围被访问。一个函数的声明由一个函数名字、参数列表（由函数的调用者提供参数变量的具体值）、一个可选的返回值列表和包含函数定义的函数体组成。在局部定义的常量作为调用函数的参数。 2.3变量 var声明语句可以创建一个特定类型的变量，然后给变量附加一个名字，并且设置变量的初始值。变量声明的一般语法如下： var 变量名字 类型 = 表达式 其中“类型”或“= 表达式”两个部分可以省略其中的一个。如果省略的是类型信息，那么将根据初始化表达式来推导变量的类型信息。如果初始化表达式被省略，那么将用零值初始化该变量。数值类型变量对应的零值是0，布尔类型变量对应的零值是false，字符串类型对应的零值是空字符串，接口或引用类型（包括slice、指针、map、chan和函数）变量对应的零值是nil。数组或结构体等聚合类型对应的零值是每个元素或字段都是对应该类型的零值。也可以在一个声明语句中同时声明一组变量，或用一组初始化表达式声明并初始化一组变量。如果省略每个变量的类型，将可以声明多个类型不同的变量（类型由初始化表达式推导）： var i, j, k int // int, int, int var b, f, s = true, 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f0ebfe7f34432102e7c9e2f72b692dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e55c9cd6f963c77f8d38583091b4eed/" rel="bookmark">
			格式化显示时间js 微信小程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 getCurrentTime(){ let dataTime='' let yy = new Date().getFullYear() let mm = new Date().getMonth()+1 let dd = new Date().getDate() let hh = new Date().getHours() let mf = new Date().getMinutes()&lt;10?'0'+new Date().getMinutes(): new Date().getMinutes() let ss = new Date().getSeconds()&lt;10?'0'+new Date().getSeconds(): new Date().getSeconds() dataTime = `${yy}-${mm}-${dd}` // ${hh}:${mf}:${ss}; return dataTime }, 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41c87df5efdd0884bd0b059a822d237c/" rel="bookmark">
			Ubuntu 增加swap分区
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		swap分区的作用： swap分区在系统的物理内存不够用的时候，把硬盘内存中的一部分空间释放出来，以供当前运行的程序使用。那些被释放的空间可能来自一些很长时间没有什么操作的程序，这些被释放的空间被临时保存到Swap分区中，等到那些程序要运行时，再从swap分区中恢复保存的数据到内存中。
swap分区大小设置： 系统中交换分区的大小并不取决于物理内存的量，而是取决于系统中内存的负荷，所以在安装系统时要根据具体的业务来设置SWAP的值。一般来说可以按照如下规则设置swap大小：
4G以内的物理内存，SWAP 设置为内存的2倍。
4-8G的物理内存，SWAP 等于内存大小。
8-64G 的物理内存，SWAP 设置为8G。
64-256G物理内存，SWAP 设置为16G。
在Ubuntu中修改swap分区大小： 1、首先使用chmod命令修改swap分区权限：
sudo chmod 700 /swapfile 2、关闭使用swap分区
sudo swapoff -a 3、重置分区大小
sudo fallocate -l 16G /swapfile 4、还原 swapfile 文件权限：
sudo chmod 600 /swapfile 5、使用 mkswap 实用程序在文件上设置 Linux SWAP 区域：
sudo mkswap /swapfile 6、激活 swap 文件：
sudo swapon /swapfile 7、将 swapfile 路径内容写入到 /etc/fstab 文件当中，使swap 分区永久生效 ：
sudo cp /etc/fstab /etc/fstab.bak echo '/swapfile none swap sw 0 0' | sudo tee -a /etc/fstab 8、最后，查看是否创建成功
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/41c87df5efdd0884bd0b059a822d237c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7e23e3c03f3e3273c45db328f8f14f1/" rel="bookmark">
			c# 获取指定时间段的时间（周、月等）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DateTime dt = DateTime.Now; //当前时间 DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss") //24小时制 DateTime.Now.ToString("yyyy-MM-dd hh:mm:ss") //12小时制 DateTime startWeek = dt.AddDays(1 - Convert.ToInt32(dt.DayOfWeek.ToString("d"))); //本周周一 DateTime endWeek = startWeek.AddDays(6); //本周周日 _______________________________________________________________________________________________ DateTime startMonth = dt.AddDays(1 - dt.Day); //本月月初 DateTime endMonth = startMonth.AddMonths(1).AddDays(-1); //本月月末 DateTime endMonth = startMonth.AddDays((dt.AddMonths(1) - dt).Days - 1); //本月月末 _______________________________________________________________________________________________ DateTime startQuarter = dt.AddMonths(0 - (dt.Month - 1) % 3).AddDays(1 - dt.Day); //本季度初 DateTime endQuarter = startQuarter.AddMonths(3).AddDays(-1); //本季度末 _______________________________________________________________________________________________ DateTime startYear = new DateTime(dt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c7e23e3c03f3e3273c45db328f8f14f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78b631bf622628e7475b1df2732ca1ba/" rel="bookmark">
			MySQL删除或清空表内数据的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL删除或清空表内数据的方法 一、使用MySQL清空表数据命令：truncate
SQL语法为：
truncate table 表名 注意：
truncate该命令会直接将数据表内数据清空；truncate该命令删除数据后会重置Identity（标识列、自增字段），相当于自增列会被置为初始值，又重新从1开始记录，而不是接着原来的ID数（重置索引）；truncate该命令不会写入日志，整体删除的速度快；truncate该命令删除数据后是不可以rollback的，也就是不可恢复； 二、使用MySQL清空表数据命令：drop
SQL语法为：
drop table 表名; 注意：drop命令会将数据以及数据表直接删除，当不需要这个数据表以及表内数据时使用；
二、使用MySQL清空表数据命令：delete
SQL语法为：
delete from 表名 where id='1'; 注意：delete命令会删除表内的数据，可以根据where条件来删除，可以单行数据删除，也可以多行数据删除；如果不加where条件则代表删除表内全部数据，如下：
delete from 表名; 该命令只会删除表内数据，并不会重置自增；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7910c2980e1ca896122cd5f02cddb062/" rel="bookmark">
			ArcGIS Enterprise10.9.1Linux版部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 ArcGIS Enterprise介绍准备工作禁用IPv6修改计算机名和配置hosts关闭防火墙创建ArcGIS安装账号修改系统句柄数安装组件ServerDataStorePortalWebAdaptor 配置组件ServerDatastorePortal 安装OpenJDK及TomcatOpenJDKTomcat生成自签名证书 WebAdaptor配置Server和Portal解决Enterprise不安全的问题更改portal的证书更改server证书 设置系统服务开机自启动tomcatServerDatastorePortal ArcGIS Enterprise介绍 ArcGIS Enterprise是Esri推出的私有云平台，包括了Portal，Server，Datastore和Webadaptor。与二维时代的服务器产品Server相比，增加了三维的数据服务发布和管理，轻松构建Web应用，二三维在线制图等功能。
准备工作 此次安装的虚拟机操作系统为Centos7.6。系统需要CPU核数大于1，需要准备的安装包有：Server，Portal For ArcGIS，Datastore，WebAdaptor，server和portal的授权文件；以及，适用于WebAdaptor的openjdk包，web服务器tomcat。注意，在正式环境中，建议使用商用的web服务器如IBM WebSphere，Oracle WebLogic等，以及Java使用OpenJDK而非JDK。为了防止计算机重启后安装包丢失，将这些文件放入新建的用户中。
禁用IPv6 // 查询网卡信息
键入：ip addr
键入：cd /etc/sysconfig/network-scripts
ls
// 修改网卡配置，确保IPv6关闭，网卡重启选项为yes；
vi ifcfg-ens33
编辑etc/sysctl.conf文件，在最后加入如下：
net.ipv6.conf.all.disable_ipv6=1
net.ipv6.conf.default.disable_ipv6=1
然后sysctl -p命令保存更改。
修改计算机名和配置hosts // 修改计算机名，为完全限定域名形式；
vi /etc/hostname
// 将IP地址和域名添加进hosts中
vi /etc/hosts
关闭防火墙 systemctl stop firewalld
systemctl disable firewalld
// 或者，当现有条件无法关闭防火墙，只能开放特定端口时，使用如下命令：
firewall-cmd --zone=public --add-port=2443-7443/tcp --permanent
firewall-cmd --zone=public --add-port=80/tcp --permanent
firewall-cmd --zone=public --add-port=443/tcp --permanent
systemctl restart firewalld
创建ArcGIS安装账号 // 创建arcgis用户和组
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7910c2980e1ca896122cd5f02cddb062/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc8762634b92463f08ad36847477da82/" rel="bookmark">
			【CMake】 Ubuntu 18.04中的cmake升级
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Ubuntu 18.04中的cmake升级 一、重要提示二、操作流程三、具体操作1.下载并解压cmake安装包2.建立软链接3.添加cmake路径4.更新完成 一、重要提示 不需要卸载删除ubuntu原有的cmake。
二、操作流程 Cmake下载网址: https://cmake.org/download/
1、下载cmake压缩包。
2、建立软链接覆盖系统原来的cmake。
三、具体操作 1.下载并解压cmake安装包 可以在官网下载，也可以使用wget命令下载。
wget https://github.com/Kitware/CMake/releases/download/v3.21.4/cmake-3.21.4-linux-x86_64.tar.gz tar -xzvf cmake-3.21.4-linux-x86_64.tar.gz 2.建立软链接 sudo ln -sf cmake-3.21.4-linux-x86_64/bin/* /usr/bin/ 3.添加cmake路径 sudo vim ~/.bashrc export PATH=$PATH:/&lt;你的路径&gt;/cmake-3.21.4-linux-x86_64/bin source ~/.bashrc cmake --version 4.更新完成 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87ea33f95a0099180d733bc1187db395/" rel="bookmark">
			Sublime text3 修改字体和行间距
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在首选项—&gt;设置，用户（右边那个框）里增加：
"font_face": ["Consolas","Lucida Sans Typewriter","Courier New"], "font_size": 14, "line_padding_bottom": 4, "line_padding_top": 4 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a83fc3e8bd7579e8ff4746503747d0d/" rel="bookmark">
			vs新建筛选器及文件夹
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在这里记录一下对于新建筛选器及新建文件夹的区别
也算初学者对vs使用的一个记录吧。
贴图以后再加单纯的记录
首先我们要明白筛选器和文件夹是两个完全不同的目录结构。
筛选器：是针对于项目来说的，项目内的目录结构
文件夹：是针对于硬盘内存的目录结构。
我们通常新建筛选器后，现有的类添加到当前的筛选器内，只是添加到筛选器内的分类里面，也就是说添加到项目的分类里面，并非文件夹的分类，而这个现有项存在的绝对地址还是处于原来的绝对地址，不会改变。
我们新建文件夹则是在硬盘的内存目录结构新建一个文件夹，将这类添加到这个文件夹内那么这个类的绝对地址就是现有的地址，而非项目地址。
可以直接的表现出来的：
当我们在外部引用类过程中，我们引用的都是文件夹的地址，文件夹的绝对地址，而你引入了项目内筛选器的地址时，你就会报错，报No such file or directory。也就是说其实你添加到筛选器内的这个类，他本身还在原来的地址内。你需要引用文件夹的地址即这类的绝对地址而非项目地址。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7ce1bc4fd8f0cd7598f24ffd83ae4ad/" rel="bookmark">
			训练的时候为什么要shuffle？训练和验证又有什么区别呢？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 训练的时候为什么要shuffle?训练和验证有什么区别？ 训练的时候为什么要shuffle? 当 dataloader 的参数 shuffle 设置为 true 时，表明每次训练的数据集的顺序是一致的，模型会记住这种顺序，从而产生过拟合现象。
这里有一个例子可以用来讲解：
图中的 A 点，每次权值更新的方向是一致的，则可能会沿着红色箭头走到局部最优点，但如果打乱数据集后，每次权值更新方向是随机的，则可能会沿着白色箭头走到全局最优点，更有利于模型的收敛。
因此，固定的数据集顺序，严重限制了梯度优化方向的可选择性，导致收敛点选择空间严重变少，容易导致过拟合。
训练和验证有什么区别？ 模型是从训练集中学习经验，从而不断减少训练误差，为了加快模型的收敛，因此要打乱数据；
验证集用于调整超参数，用于在训练过程中检验模型的状态与收敛情况，根据几组模型验证集上的表现决定哪组超参数拥有最好的性能。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa226a79ad39a49dd71959f532d9d7b8/" rel="bookmark">
			大厂笔试真题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.复数相乘 2.K个一组翻转链表 #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;string&gt; using namespace std; void Reverse(vector&lt;string&gt;&amp; arr, int begin, int end) { while (begin &lt; end) { swap(arr[begin], arr[end]); begin++; end--; } } int main() { string str; //输入的数字很大 int k = 0; vector&lt;string&gt; li; while (cin &gt;&gt; str) { if (str == "#") break; li.push_back(str); } cin &gt;&gt; k; for (int i = 0; i &lt;= li.size(); i += k) { //cout &lt;&lt; i &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa226a79ad39a49dd71959f532d9d7b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/407435b8a5c9a29bf28adf7fb28a675e/" rel="bookmark">
			文件系统概念
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.文件逻辑结构 (1)有结构文件和无结构文件 ①定长记录
②可变长记录
(2)顺序文件 (3)索引文件 (4)索引顺序文件
(5)多级索引顺序文件 2.文件目录 (1)文件控制块 (2)目录结构 (3)索引节点 3.文件的物理结构 (1)文件块，磁盘块 (2)文件分配方式
①连续分配
②链接分配 - 隐士链接
③链接分配 - 显示链接
③索引分配
④索引分配总结
4.文件存储空间管理 (1)存储空间划分与初始化 (2)存储空间管理
①空闲表法
②空闲链表法
③位示图法
④成组链接法
(3)总结
磁盘的结构 (1)磁盘，磁道，扇区 (2)磁盘的物理地址 磁盘调度算法 (1)FCFS
(2)SSTF (3)SCAN
(4)LOOK
(5)C-SCAN (6)C-LOOK
(7)总结
减少磁盘延迟时间的算法 (1)交替编号
(2)磁盘地址结构设计
(3)错位命名
(4)总结
磁盘的管理 (1)磁盘初始化
(2)引导块
(3)坏块管理
(4)总结
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3cc3b800bd262ec83c141088bc8a5219/" rel="bookmark">
			C语言课程设计——航班信息管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 实现功能
整体概述
系统结构
主要功能模块实现
身份验证
信息遍历
查找航班信息
编辑航班信息
整理信息顺序
预订航班
小结
实现功能： 通过此系统可以实现如下功能：（1）录入：管理员用户可以录入航班情况，数据存储在一个数据文件中；（2）遍历：可以查看某一类信息的所有数据如航班信息、订单信息等；（3）查询：可以查询某个航线的情况，如输入航班号来查询起降时间、起飞抵达城市、航班票价、票价折扣、航班是否满仓；也可以输入起飞抵达城市，查询飞机航班情况；（4）订票：普通用户可以订票，订单相关数据会存储在数据文件中，客户资料有姓名，证件号，订票数量及航班情况，订单要有编号；（5）退票： 可退票，退票后修改相关数据文件；（6）修改：当航班信息改变可以修改航班数据文件。
整体概述： 本系统为实现信息的增删改查等功能的应用程序。采用的开发环境为codeblocks，系统环境为windows10。本系统使用的数据结构为结构体数组，相关数据文件的存储方式为使用txt文件存储。本系统实现对数据文件的修改基本思路为：先读取计算机硬盘中的数据文件内容并将其以结构体数组的方式存入计算机内存，修改内容时首先修改的是结构体数组，修改完毕后将修改后的结构体数组重新写入数据文件（覆盖原文件）。
本系统设计思路为，首先通过身份验证用户的身份，二者所能使用的功能与权限不同；验证通过后，根据具体用户的身份系统会提供不同的操作界面，用户可以根据自己的实际需求使用具体功能包括查找航班信息、添加、删除、修改航班信息、整理信息顺序以及预订、退订航班等等操作。
系统结构： 经过分析，本系统的整体结构示意如下：
主要功能模块实现： 本系统使用的头文件为以下三个：
#include&lt;stdio.h&gt; #include&lt;string.h&gt; #include&lt;windows.h&gt; 身份验证 用户在使用本系统时需要输入用户名和密码验证用户身份来取得相应的使用本系统的权限。相关用户信息存放在userinfo.txt中。两类用户分别为管理员和普通用户，系统先将使用者输入的用户信息与数据库中的对应信息作匹配，若匹配成功则进一步判断用户类型。若使用者输入的信息和数据库中的所有信息均不匹配，则计数加一且系统会提示用户重新输入，计数达到三时系统会提示使用者无权使用本应用并自动退出程序。
主要实现代码：
/*打开用户信息文件并读取所有用户信息*/ if((user_fp=fopen(".\\datafiles\\userinfo.txt","r"))==NULL){ printf("数据读取失败！请检查“userinfo.txt”是否存在或路径是否正确！"); //若文件位置错误或不存在 Sleep(1000); exit(0); } user=user_info_readin(user_fp); //读取用户信息并将其写入用户信息结构体数组 fclose(user_fp); /*将使用者输入的用户信息与所有用户信息进行匹配并验证用户类型*/ for(i1=1;i1&lt;=3;i1++){ printf("用户名："); scanf("%s",usn); printf("密码："); scanf("%s",psw); for(i=0;i&lt;user_num;i++){ if(strcmp(usn,user[i].username)==0&amp;&amp;strcmp(psw,user[i].password)==0){ un=i; //全局变量un，用于在其他函数中匹配用户信息 printf("登录成功！当前身份："); if(user[i].id==1){ //根据用户信息的id选择跳转到指定界面 printf("管理员\n"); Sleep(1000); admt_menu(); //调用管理员操作界面函数 }else if(user[i].id==0){ printf("普通用户\n"); Sleep(1000); user_menu(); //调用普通用户操作界面函数 } break; } } if(strcmp(usn,user[i].username)==0&amp;&amp;strcmp(psw,user[i].password)==0) break; if(i1==3){ printf("验证失败！请先获取用户信息后再登录"); //用户输错三次信息后系统提示 Sleep(1000); exit(0); } printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3cc3b800bd262ec83c141088bc8a5219/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c2e1a240b474a7dec89200381710964/" rel="bookmark">
			Java8新特性：Stream流的使用（高效操作集合类）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、概述 Stream API的概述：
Stream API是Java 8新特性之一，定义在java.util.stream子包在Java中使用Stream API可以高效的处理集合对象（针对集合进行复杂的过滤等操作）可以让程序员写出高效、干净、简洁的代码 Stream API和Collection（集合）的关系：
Collection是容器，是用来存放数据的，重点在于数据存储Stream则是针对集合元素提供便捷的计算，重点在于数据计算（对容器内元素排序、过滤等）集合面对的是内存，Stream则面对的是CPU 为什么要使用Stream API？
NOSQL只能通过JAVA层面过滤数据：因为现在获取数据的方式增多，不仅可以通过关系型数据库同时还可以通过非关系型数据库NoSQL(Redis)获取，如果在关系型数据库中需要对指定的数据进行过滤是可以使用where子句来过滤数据的，例如：select xxx from xxx where xxx。但是如果需要通过非关系型数据库NoSQL来获取数据，那么只能在Java层面过滤，而Stream可以针对集合进行高效的处理。性能优势：在Stream中提供了并行流parallelStream，在CPU多核情况下使用并行流来遍历会比for遍历的效率高（虽然for偏向底层效率更高，但是在并行情况下并行流效率可能更高）代码简洁易懂：Stream API真正的将函数式编程引入到Java中，可以将原先臃肿复杂的代码变得简洁易懂（同时依赖于Stream的延迟执行的特性） Stream操作的三个步骤：
第一步：创建Stream流对象（根据集合或数组就可以生成一个Stream对象）第二步：一系列的中间操作（将所有操作生成一个执行链本身并不执行）第三步：终止操作（只有终止操作之后执行链中的步骤才会执行） 注意事项：
Stream本身并不存储对象，数据是存储在集合中的Stream并不会改变源对象（也就是并不会改变原先集合中的数据）操作是延迟的，只有等到需要结束的时候（第三步终止操作），才会一次性将整个执行链的操作执行Stream一旦执行了终止操作，就无法再进行终止操作或者中间操作了（如果需要只能重新获取新的流对象） 二、Stream操作的三个步骤 Stream的三个操作：① 创建Stream对象、② 执行中间操作、③终止操作
中间操作执行完毕之后一定要执行终止操作，因为中间操作是’惰性执行’的过程
（案例使用forEach(System.out::println)来保证终止操作）中间操作是并不是真正执行操作，而是生成操作链第三步"终止操作"时候才将整个"操作链"执行 步骤一：创建一个Stream 创建方式一：根据集合Collection对象创建 List l1 = new ArrayList(); Stream s1 = l1.stream(); // 通过调用集合对象类的stream()方法 创建方式二：根据集合使用Arrays工具类创建 IntStream s3 = Arrays.stream(new int[]{1, 2, 3, 4, 5, 6}); // 使用Arrays工具类的stream方法将数组作为参数传入即可得到 创建方式三：使用Stream类的of()静态方法创建 Stream&lt;Integer&gt; integerStream = Stream.of(1, 2, 3, 4, 5); // 使用Stream的of静态方法，传入目标元素即可 创建方式四：通过创建无限流的方式实现（了解即可） 步骤二：中间操作（最终会形成一个操作链，并不执行） 1. 筛选与切片 filter(Predicate p)表示的是接收Lambda，用于从流中排除某些元素 List list = new ArrayList(); list.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c2e1a240b474a7dec89200381710964/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f27aba77ded5e01ef65e9f63d7f7803/" rel="bookmark">
			Eclipse 安装插件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		查找和安装插件 Eclipse作为一个集成的IDE开发工具，为我们的软件开发提供了便利，eclipse除了自带的强大功能外，还支持功能丰富的插件。
我们可以通过Eclipse官方市场 (Eclipse Plugins, Bundles and Products - Eclipse Marketplace)找到并下载我们需要的插件。
例如我们可以查找支持 Python IDE 的插件，如下图所示：
在 Eclipse IDE 中我们也可以通过点击 Help 菜单中的 Eclipse Marketplace（Eclipse 超市）选项来查找插件：
上图中我们选择 PyDev 让 Eclipse 支持 Python 开发，我们只需要点击 Install 按钮即可。 以下对话框为选择安装的插件。
你也可以通过点击 Help 菜单上的 Install New Software 菜单项来安装插件： 这种方式我们需要知道插件远程的安装地址，你可以通过点击 Add 按钮来提交 URL。
安装的对话框中列出了远程可安装的插件列表：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29b9da07f6064cd454059a709db9449a/" rel="bookmark">
			前端的现状以及未来发展趋势,最简单的理解前端开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前端侧重于人机交互和用户体验，后端侧重于业务逻辑和大规模数据处理。理论上，面向用户的产品里，所有问题（包括产品、设计、后端、甚至看不见的问题）的表现形式，都会暴露在前端，而只有部分问题（数据问题、计算问题、安全问题等）暴露在后端，这就意味着前端起到了至关重要的承载和连接作用。
前端技术的更新日新月异；前端框架的技术选型百家争鸣；视觉审美的潮流不断更替；可视化效果酷炫无比；用户的运营体系逐渐精细化；适老化、无障碍化、青少年人群的诉求浮出水面；智能设备的升级和适配无穷无尽。所有的这一切，对前端领域和前端同学就一个要求：要折腾，爱折腾，反复折腾。
什么是前端？什么又是后端呢？
1，在你机子上（PC端/手机端）看到的界面，安装的程序。给用户看的、操作的就是前端。你看不到的，帮你保存网络游戏数据，保存应用数据，处理数据的就是后端（服务端）。
2， 目前一般来说，前端指的就是浏览器端，后端指的就是直接为浏览器端提供服务以及数据的服务器端。
3， 从大的方面来讲，你所能看到的一切，网页、移动端网页、小程序、甚至某些app，都是前端程序员的。
前端工程师是做什么的？
1.前端工程师主要利用HMTL与CSS建构页面（其中html构建骨架，css构建样式），用JavaScript获取后端数据以及完善交互以及用户体验。
2.通俗来讲，前端在一个项目里，拿到UI设计师设计的设计稿，然后实现UI设计师设计稿，调用后端程序员给的数据接口以获取数据，然后测试，最后部署上线。
3.前端可以对设计图负责,大部分情况下,不需要特别的去理解业务逻辑,因为我们90后都是玩着十几年手机电脑长大的,十几年的经验足够我们在潜意识里想明白应该怎么做,怎么去一步步实现,会有什么意外情况。
4.我感觉前端发展有个很大的缺陷----晋升问题. 正如第三点所言,作为领导必须对项目有足够的了解,显然是要重点包括业务逻辑,这点上,后端开发者需要涉及数据库逻辑,是必须要跟业务逻辑打交道的(重中之重),因此,大部分的领导岗位都是后端开发者更有晋升的机会。当然,个别公司有专门的前端组长(这也不算什么),如果说前端开发者在自己工作范围之外还要腾出时间去研究业务逻辑,属实是觉得出力不讨好(因为这样的操作需要持续很久才能看出效果),而且再怎么研究业务逻辑也不会比每时每刻跟业务逻辑打交道的后端开发者了解更多。说实在的,大部分情况下,前端在配合后端进行开发.后端需要了解业务逻辑,要跟领导和客户商量细节,露脸机会很大,在老板面前刷脸次数众多。这些都是拉开前后端程序员晋升机会差距的因素。
前端工程师的现状。
1.从薪资和地位方面来讲，以前的前端处于程序员鄙视链的底端，但是现在地位大幅度上涨~不过在某些固执的人或者刚刚入行的人眼里，前端的地位还是不高，这也不怪他们，毕竟在很多时候，技术核心都是偏向于后端的，比如，高并发、分布式、安全、中间件等等，这些是决定一家公司业务规模的核心技术，而前端是不怎么接触到这些，但是随着用户们不断的索取更好的用户体验，前端同学也会扮演着越来越重要的角色。其实说那么多，我觉得都不如从薪资来说，其实大部分情况下，后端前端都是一个批发价的…大家都是打工仔没啥好互相鄙视的。
2.从需求来说，前端还属于需要人的阶段，从各个招聘软件的需求来看，前端需求量仅次于JAVA，是非常需要人的！不要说饱和，你如果说饱和，那互联网里还有什么不是饱和的？AI不饱和，但是普通人干得了吗？从来就没有什么饱和，只有想走捷径的菜鸟饱和而已。只会用JQ的，框架和基础都不怎么样的，这样的人，你当然觉得工作难！
3.从技术层面来说的话，现在已经不是会了JQ就能打天下了，现在你起码需要熟练使用一个框架吧？然后当前炙手可热的小程序也得会把？自动化工具也得会使用吧~如果你只会一个JQ，那活该没工作…
4.中国程序员已经足够的内卷了,通常是面试考察怎么造火箭,工作了发现你只是一个为火箭拧螺丝的工人. 前者造火箭是技术活,后者拧螺丝是苦力活,其中差别自行体会.
但是,拿到这份拧螺丝的工作,也需要你知道造火箭的原理,哪怕大部分情况下工作根本用不到,就算有需要,百度几分钟解决.
那为什么面试考察这些呢? 一个是看基础是否扎实, 一个是看你是不是那种愿意花功夫去提升自己的人,
但是归根结底,这都是你跟竞争者拉开差距的必要条件-----中国人太多了,对于企业来说,人口红利时期还没有过去.尤其是近两年,三百六十行,行行转IT,拉低了IT行业的下限,什么阿猫阿狗看几天培训的视频,就自称工程师,真是贻笑大方。
前端工程师的未来
如果你只走技术道路的话，你会发现，那你可能一辈子写前端写JS吗？然后成为前端大牛吗？不可能的，前端只走技术往后的话基本上都是走业务架构这条路,这考验的就是大局观了,你只会一个前端是根本不行的，这个时候靠的是你全面的能力和良好的大局观,而像后端的JAVA、php，你都会涉及，所以你当初的那些所谓的前端技术亦或者后端技术就是个敲门砖了。
工程师不要被所谓的语言什么的限制！
上面说的是只走技术，当然了你也可能中间做了管理或者做了产品经理甚至于自己创业，当然还有可能因为长期停滞不前被技术革命，这都是有可能的~.
总结
前端是干啥的？笼统的说前端就是以各种姿势写各种页面。
前端的现状如何？现状还是很好的，低端饱和，但是仍然缺少真正能干活的！
前端工程师的未来？如果你只走技术层，就不要被语言所束缚，不要局限于前端。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6de8dd78106c84e1a7132c04ca09b9b/" rel="bookmark">
			修改数据库名称
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在MySQL 5.1.7版本中提供了修改数据库名称的SQL语句，语法格式如下：
RENAME DATABASE db_name TO new_db_name 但是从MySQL 5.1.23版本之后，就将此SQL语句去掉了，原因是此SQL语句可能会造成数据丢失。
虽然MySQL没有直接提供修改数据库名称的SQL语句，但是，可以通过其他方式达到修改MySQL数据库名称的效果。
7.3.1　通过重命名数据表修改数据库名称
（1）在MySQL中创建数据库test_old，并在test数据库中创建名称为table_test的数据表。
mysql&gt; CREATE DATABASE IF NOT EXISTS test_old; Query OK, 1 row affected (0.01 sec) mysql&gt; USE test_old; Database changed mysql&gt; CREATE TABLE IF NOT EXISTS table_test(id int); Query OK, 0 rows affected (0.01 sec) 注意：有关数据表和存储引擎的知识，在后续章节中会详细介绍，这里为了演示修改数据库的操作，先简单创建一个测试表。
（2）查看名称为test_old数据库下的数据表。
mysql&gt; SHOW TABLES; +--------------------+ | Tables_in_test_old | +--------------------+ | table_test | +--------------------+ 1 row in set (0.00 sec) 可以看到，test_old数据库下存在table_test数据表，说明table_test数据表创建成功。
（3）在MySQL命令行创建test_new数据库。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e6de8dd78106c84e1a7132c04ca09b9b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e02707ff5ad76a4d6ec7dfe70d0ff39/" rel="bookmark">
			查看数据表结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在MySQL中创建好数据表之后，可以查看数据表的结构。MySQL支持使用DESCRIBE/DESC语句查看数据表结构，也支持使用SHOW CREATE TABLE语句查看数据表结构。
8.2.1　使用DESCRIBE/DESC语句查看表结构
MySQL中可以使用DESCRIBE/DESC语句查看数据表的结构信息，结构信息中包括字段名称、数据类型及是否是主键等信息。
1．语法格式
使用DESCRIBE语句查看表结构的语法格式如下：
DESCRIBE 表名称 使用DESC语句查看表结构的语法格式如下：
DESC 表名称 2．简单示例
查看商品类别表t_goods_category的表结构信息。
mysql&gt; DESCRIBE t_goods_category; +------------+--------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +------------+--------------+------+-----+---------+-------+ | id | int(11) | NO | PRI | NULL | | | t_category | varchar(30) | YES | | NULL | | | t_remark | varchar(100) | YES | | NULL | | +------------+--------------+------+-----+---------+-------+ 3 rows in set (0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e02707ff5ad76a4d6ec7dfe70d0ff39/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/566a6a33559298731166aedaf8165d99/" rel="bookmark">
			按钮鉴权的基本使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系统中操做按钮鉴权 系统中用户动态菜单。
--动态菜单权限
系统中操做权限
---按钮鉴权
在封装的状态机的文件里面
后端在用户登录的时候返回当前用户的权限列表
定义的格式 后端定义
1.vuex-state.js 2.vuex-mutations-type.js 全局注册自定义指令v-premission，在main.js文件里面 // 引入premission import './components/premission' 4.vuex-mutations.js export default { // 存储权限 /** * @params {数组 list} list * **/ [SAVE_PREMISSION_LIST](state,list){ state.premissionList = list; } } 5.在路由守卫里面在用户登录情况下获取权限 6.创建premission.js文件 /* 自定义指令全局注册 按钮鉴权 */ import Vue from "vue"; //引入store import store from "../store"; //不带v-前缀 Vue.directive("premission", { //value 权限值 ['***'] inserted(el, { value }) { //获取当前用户权限表 let { premissionList } = store.state; //当前权限 let prem = value[0]; //当前用户获取的权限表为所有权限* if (premissionList[0] == "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/566a6a33559298731166aedaf8165d99/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3af6c598015c59ec4249c39579fbcb76/" rel="bookmark">
			40套计算机毕业设计项目合集【含源码&#43;论文】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 🔥 这两年开始毕业设计和毕业答辩的要求和难度不断提升，传统的java web缺少创新和亮点，往往达不到毕业答辩的要求，这两年不断有学弟学妹告诉学长自己做的java web管理系统达不到老师的要求。
为了大家能够顺利以及最少的精力通过毕设，学长分享41个优质java web毕业设计项目，需要的自取。
题目1 : 基于SSM的毕业设计管理系统 🥇 题目综合评分(每项满分5分)
难度系数：3分工作量：5分创新点：3分界面美化：5分 🥇 相关技术和工具 :
开发语言：Java框架：ssmJDK版本：JDK1.8服务器：tomcat7数据库：mysql 5.7（一定要5.7版本）数据库工具：Navicat11开发软件：eclipse/myeclipse/ideaMaven包：Maven3.3.9 🥇 功能模块
管理员：首页、个人中心、个人信息、学生管理、教师管理、文件模板管理 、论坛管理、系统管理、在线选题管理、开题报告管理、中期报告管理、毕业论文管理
教师管理：个人中心、个人信息、文件模板管理、在线选题管理、老师答疑管理、开题报告管理、中期报告管理、毕业论文管理、学生提题管理、论文进度管理
学生管理：个人中心、个人信息、学生提问管理、老师答疑管理、开题报告管理、中期报告管理、毕业论文管理、学生提题管理、论文进度管理、我的收藏管理
题目2 : 基于SSM的病人跟踪治疗信息管理系统 🥇 题目综合评分(每项满分5分)
难度系数：3分工作量：5分创新点：3分界面美化：5分 🥇 相关技术和工具 :
开发语言：Java框架：ssmJDK版本：JDK1.8服务器：tomcat7数据库：mysql 5.7（一定要5.7版本）数据库工具：Navicat11开发软件：eclipse/myeclipse/ideaMaven包：Maven3.3.9 🥇 功能模块
管理员：首页、个人中心、病人管理、病例采集管理、预约管理、医生管理、上传核酸检测报告管理、上传行动轨迹管理、分类管理、病人治疗状况管理、留言板管理、系统管理
病人：首页、个人中心、病例采集管理、预约管理、医生管理、上传核酸检测报告管理、上传行动轨迹管理、病人治疗状况管理
前台首页：首页、医生、医疗资讯、留言反馈、个人中心、后台管理、在线咨询
题目3 : 基于SSM的大学生兼职跟踪系统 🥇 题目综合评分(每项满分5分)
难度系数：3分工作量：5分创新点：3分界面美化：5分 🥇 相关技术和工具 :
开发语言：Java框架：ssmJDK版本：JDK1.8服务器：tomcat7数据库：mysql 5.7（一定要5.7版本）数据库工具：Navicat11开发软件：eclipse/myeclipse/ideaMaven包：Maven3.3.9 🥇 功能模块
管理员：首页、个人中心、商家管理、学生管理、兼职招聘管理、兼职应聘管理、商家投诉管理、投诉处理管理、论坛管理、系统管理学生后台模块：首页、个人中心、兼职应聘管理、商家投诉管理、我的收藏管理，商家；首页、个人中心、兼职招聘管理、兼职应聘管理、投诉处理管理学生前台：首页、兼职招聘、兼职论坛、系统公告、我的、跳转到后台 题目4 : 基于SSM的大学生企业推荐系统 🥇 题目综合评分(每项满分5分)
难度系数：3分工作量：5分创新点：3分界面美化：5分 🥇 相关技术和工具 :
开发语言：Java框架：ssmJDK版本：JDK1.8服务器：tomcat7数据库：mysql 5.7（一定要5.7版本）数据库工具：Navicat11开发软件：eclipse/myeclipse/ideaMaven包：Maven3.3.9 🥇 功能模块
管理员：首页、个人中心、学生管理、企业管理、招聘信息管理、个人简历管理、应聘职位管理、评价企业管理、交流论坛、系统管理学生：首页、个人中心、招聘信息管理、个人简历管理、应聘职位管理、评价企业管理企业：首页、个人中心、招聘信息管理、个人简历管理、应聘职位管理、评价企业管理前台首页：首页、招聘信息、个人简历、交流论坛、个人中心、后台管理 题目5 : 基于SSM的电影院在线售票系统 🥇 题目综合评分(每项满分5分)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3af6c598015c59ec4249c39579fbcb76/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a69e92e1bef1598f215693fa3c0222f5/" rel="bookmark">
			【欧拉筛法】洛谷 P3383 线性筛素数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		3383. 线性筛素数
文章目录 题目描述输入格式：输出格式：数据范围输入样例输出样例 方法一：埃氏筛法解题思路代码复杂度分析： 方法二：欧拉筛法解题思路代码复杂度分析： 两种方法对比埃氏筛法欧拉筛法 题目描述 给定一个范围 n，有 q 个询问，每次输出第 k 小的素数。
输入格式： 第一行包含两个正整数 n、q，分别表示查询的范围和查询的个数。
接下来 q 行每行一个正整数 k，表示查询第 k 小的素数。
输出格式： 输出 q 行，每行一个正整数表示答案。
数据范围 对于 100 % 的数据， n = 1 0 8 ， 1 ≤ q ≤ 1 0 6 ，保证查询的素数不大于 n 对于100\%的数据，n = 10^8，1\leq q\leq10^6，保证查询的素数不大于 n 对于100%的数据，n=108，1≤q≤106，保证查询的素数不大于n 输入样例 100 5 1 2 3 4 5 输出样例 2 3 5 7 11 方法一：埃氏筛法 解题思路 假设要求 0 - 20 之间的素数。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a69e92e1bef1598f215693fa3c0222f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d8d5e00ad09cfed6e78960a159a2352/" rel="bookmark">
			vue中文件加载顺序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue文件加载顺序：index.html&gt;app.vue&gt;main.js 加载顺序详情：
执行index.html（index.html中id为app的div标签是一个挂载点，之后我们的Vue根实例就会挂载到该挂载点上）执行main.jsmain.js找到实例挂载app.vue文件，将index.html的挂载的内容显示出来（用app.vue的template替换index.html中的&lt;div id="app"&gt;&lt;/div&gt;）main.js中引入了路由，可以将对应的组件渲染到router-view中rouer-view加载了Layout文件Layout 加载Navbar, Sidebar, AppMain 从加载顺序中可以看出main.js是先执行的，但出现（index.html&gt;app.vue&gt;main.js）问题是由ES6的模块化加载规则导致的
ES6、CommonJs、AMD的加载规则
CommonJS一般用于服务端比如node,AMD一般用于浏览器环境，并且允许非同步加载模块，可以根据需要动态加载模块；CommonJS和AMD都是运行时加载，ES6模块是编译时输出接口。CommonJS模块输出的是一个值的拷贝，ES6模块输出的是值的引用；因为CommonJS加载的是一个对象，（即module.exports属性），该对象只有在脚本运行时才会生成，而ES6模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。 因为ES6是编译时加载且import命令具有提升效果，会提升到整个模块的头部，优先执行，故导致上述问题
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/177/">«</a>
	<span class="pagination__item pagination__item--current">178/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/179/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>