<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/432fcc2c2cc81bcc1d662b1e86096645/" rel="bookmark">
			PIC单片机应用开发实践教程（五）： 烧录器简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		源码基于 PIC16F15355开发板，想了解详情，请点 PIC16F15355开发板 ​​​​​​​
PIC单片机，无论是8位的10/12/16/18系列，还是16位PIC24/dsPIC33系列，常用的烧录器如下：PICkit3，PICkit4，ICD3和ICD4，当然，还有量产型专用烧录工具PM3.
1、PICkit3 烧录器 特别要注意，三角形为引脚1标记，接MCU的MCLR引脚 PICkit3与芯片的连接，只需将6个编程引脚相应连接到芯片的引脚上，具体芯片的引脚可以从芯片数据手册上查看，但第6脚 LVP一般不接，只需接MCLR、VDD、VSS、PGD、PGC 五个引脚。
1.1 目标板连接电路
建议在MCLR和VDD之间接一个上拉电阻（通常约10K左右），这样可以将VPP/MCLR线置为低电平来复位器件。
1.2 烧录供电
PICkit3为目标器件提供了两种配电方案：内部调试器供电（也就是PICkit3供电）和外部目标电源。在实际使用中，推荐使用外部电源，因为PICkit3提供电源电流限制为30mA，这对于特别是将ic焊在PCB板上再烧录时，提出很大的挑战，所以，如无特殊情况，不建议用内部供电方式。
1.3 影响PICkit3正常运行电路
2、PICkit4 烧录器 PICkit4使用方法和PICkit3其实上是一样的，只不过PICkit4比PICkit3支持更多的器件，比如SAM系列的芯片，和Atmel的芯片，现在推上的新器件，PICkit3有很多已经不支持了，所以只能用PICkit4或ICD4。
PICkit4接收图：
3、ICD3/ICD4烧录器 ICD3/ICD4 与目标板的标准连接 ​​​​​​​
4、量产烧录工具 PM3 上面介绍的PICkit3\PICkit4，ICD3\ICD4都是调试工具，也就是在调试程序的时候用的，当进入量产烧录时，不建议再使用以上介绍的这4种烧录器烧录，而是用专用的量产型烧录工器PM3.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d73a4f6f1cc240c5e238ca39eb464ab5/" rel="bookmark">
			【SpringBoot】注解或全局配置Long转String，解决前端接收时精度丢失的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一种：使用注解解决
使用方便简单，粒度高，适用于部分字段需要单独转换的场景，灵活度高 // 两种注解，选其一即可 // @JsonFormat(shape = JsonFormat.Shape.STRING) @JsonSerialize(using = ToStringSerializer.class) private Long largeId = 1332345432341123411L; 第二种：直接对SimpleModule对象配置，避免其他地方的Jackson配置被覆盖的问题
@Configuration public class JsonModuleConfig extends SimpleModule { public JsonModuleConfig() { //super(JsonModuleConfig.class.getName()); this.addSerializer(Long.class, ToStringSerializer.instance); this.addSerializer(Long.TYPE, ToStringSerializer.instance); } } 第三种：通过 WebMvcConfigurer 配置转换规则
@EnableWebMvc @Configuration public class WebDataConvertConfig implements WebMvcConfigurer { public void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) { MappingJackson2HttpMessageConverter jackson2HttpMessageConverter = new MappingJackson2HttpMessageConverter(); ObjectMapper objectMapper = new ObjectMapper(); /** * 序列换成json时,将所有的long变成string * 因为js中得数字类型不能包含所有的java long值 */ SimpleModule simpleModule = new SimpleModule(); simpleModule.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d73a4f6f1cc240c5e238ca39eb464ab5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1bea84e80bf710ac351ec7b5c987b21/" rel="bookmark">
			ES-多条件搜索
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 GET "索引名字"/_search { "query": { "bool": { "must": [ { "match": { "spuName": "手机" } }, { "match": { "twoClassId": "306532688574063754" } } ] } } , "from": 0 , "size": 100 } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1123f5de4ebbb6a78623422068274092/" rel="bookmark">
			三、键盘检测原理及应用实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		键盘检测原理及应用实现 视频链接：[3-4] 独立按键控制LED移位_哔哩哔哩_bilibili
对应课程P7-P10
键盘实际上就是一组按键，在单片机的外围电路中，通常用到的按键都是机械弹性开关，当开关闭合时，线路导通，开关断开时，线路断开。单片机系统常见的弹性小按键图示意图如图所示：
弹性小按键被按下时闭合，松开后自动断开；自锁式按键与弹性按键不同，当按下时自锁式按键会闭合且会自动锁柱，只有再次按下时才会弹起断开，自锁式按键示意图如图所示：
单片机检测按键的原理：单片机的I/O口既可以作为输出也可以作为输入使用，当检测按键时用的是它的输入功能，我们把按键的一端接地，另一端与单片机的某个I/O口相连，开始时先给该I/O口赋一个高电平，然后单片机不断地检测该I/O口是否变为低电平，当按键闭合时，即相当于该I/O口通过按键与地相连，变成低电平，程序一旦检测到I/O口变为低电平则说明按键被按下，然后执行相应的指令。
独立键盘控制LED亮灭 按键的连接方法非常简单，独立按键的原理图如图所示：
当按键被按下时，其触点电压变化过程如下图所示：
由图不难看出，实际波形与理想波形之间是有区别的，实际波形在按键被按下和释放的瞬间都有抖动现象，抖动时间的长短与按键的机械特性有关，一般为5~10ms。通常我们手动按下键然后立即释放，这个动作中稳定闭合的时间超过20ms，这也就是为什么单片机在检测键盘是否按下时都要加上去抖操作了。去抖有专用的去抖电路，也有专用的去抖芯片，但是通常出于成本控制等原因，我们只需要在写程序的时候需延时处理就很容易解决抖动问题。
在编写单片机的键盘检测程序时，通常在检测按下时加入去抖延时，检测松手时就不需要加了。按键检测流程图如图所示：
需要注意的是，在头文件regx52中既包含了寄存器声明也还包含了位声明，如图所示：
关于头文件的不同以代码形式进行简单叙述：
#include &lt;REGX52.H&gt; //#include &lt;REG52.H&gt;则不包含对位寄存器的声明 void main { while(1) { //P2=oxFE; 控制P2需要同时操作8位数据从而控制8个LED P2_0=0; // 可以单独控制一个LED } } 为了实现对独立键盘控制LED亮灭，显然需要用判断键盘何时被按下，何时被松开，代码如下：
#include &lt;REGX52.H&gt; //#include &lt;REG52.H&gt;则不包含 void main() { while(1) { if(P3_1==0)//通过原理图可知，按键进行这样的连接：S13-RXD-P3.1 { //当检测到P3.1位低电平时（即按键被按下） P2_0=0; //D2亮（最左边的LED亮） } else //当检测到P3.1位不是低电平时（即按键被释放） { P2_0=1;//D2灭 } } } 在上面代码中如P3_1==0，涉及到C51数据运算相关知识，下面给出常用汇总的运算符：
还涉及到if条件语句,基本格式和解释如下图所示：
独立按键控制LED状态 如果想实现独立按键按下之后松开手才亮，再按下按键，灯灭，这该如何实现呢？
上一节已经说了按键抖动现象和去抖的操作，现在结合一张更为具体的图来进行说明：
当按键被检测到按下，此时由于电压存在抖动，在5-10ms，电压会在高电平和低电平反复跳动，如果不进行延时处理，可能会影响按键功能的正常使用，出现误触（实际测试中，程序编译过程中报了警告，上板表现和不加延时看不出差别）。
#include &lt;REGX52.H&gt; void Delay1ms(unsigned int xms)	//延时函数	{ while(xms--) { unsigned char i, j; i = 2; j = 239; do { while (--j); } while (--i); }	} void main() { while(1) { if(P3_1==0) //检测按键是否按下 { Delay1ms(20);//延时20ms while(P3_1==0)//检测是否松手，松手就跳出循环 { } //另外一种写法，倘若中括号内无内容，可以直接写成： //while(P3_0==0); Delay1ms(20); //延时，松手去抖,书上说检测松手可以不用加延时 P2_0=~P2_0; //取反，一开始P2_0默认是高电平，取反之后就是0了 } } } //现象：按住S1按键，松开后 D2 LED灯亮，再按S1，松开后灯灭。 上述代码使用了while语句，下面简单补充一下while语句的基础知识，在本例中就是使用了while语句实现了检测是否松手：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1123f5de4ebbb6a78623422068274092/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52540a73fc1a990cf2180b0cd91942a6/" rel="bookmark">
			c语言枚举
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		c语言枚举 枚举介绍枚举遍历枚举在switch语句里面的使用枚举细节 枚举介绍 （1）枚举是C语言中的一种构造数据类型，它可以让数据更简洁，更易读，对于只有几个有限的特定数据，可以使用枚举.
（2）枚举对应英文(enumeration，简写enum)
（3）枚举是一组常量的集合，包含一组有限的特定的数据
（4）枚举语法定义格式为
enum 枚举名 {枚举元素1，枚举元素2，枚举元素3，......}; 举例：一个星期有7天，定义数据来表示星期一到星期天。
传统方法：
#define MON 1 #define TUE 2 #define WED 3 #define THU 4 #define FRI 5 #define SAT 6 #define SUN 7 枚举方法：
enum Day{ MON=1,TUE=2,WED=3,THU=4,FRI=5,SAT=6,SUN=7 }; 完整代码
#include&lt;stdio.h&gt; void main(){ enum Day{ MON=1,TUE=2,WED=3,THU=4,FRI=5,SAT=6,SUN=7 };//注意分号位置（枚举7个元素） enum Day day;//enum Day是枚举类型，day是枚举变量 day = WED;//给枚举变量day 赋值，值就是某个枚举元素 printf("%d",day);// 3 ，每个枚举元素对应一个值 } 枚举遍历 遍历for循环打印枚举元素
#include&lt;stdio.h&gt; enum Day{ MON=1,TUE,WED,THU,FRI,SAT,SUN//如果没有赋值就自动按顺序赋值，如果MON也没有给值，那么MON的默认值就是0 }day;//表示定义一个枚举类型 enum Day，day是枚举变量 void main(){ for(day=MON;day&lt;=SUN;day++){ printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/52540a73fc1a990cf2180b0cd91942a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4e475de56f69774dbb1749ccfefdb05/" rel="bookmark">
			程序运行时报错NullPointerException(空指针)情况以及解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		出现空指针异常，常常是因为我们调用的对象是空的而抛出的异常 抛错场景 当对空属性或者空对象进行后台传值时可能会抛出异常。常见于接口传值为空或者返回值为空时当对空属性或者空对象与另一个属性做比较时 问题定位: 对于日志中的报错信息，在java中抛出异常是从内往外，需要重点关注第一行报错信息，下面的报错都是由于一层层传递调用该方法导致 空指针异常的解决方案： Java中任何对象都可以为空，我们可以使用很多种方法来避免产生这类异常。比如我们传统的空值检测，编程规范，以及使用java中各种工具类。 常用的一种就是直接对 对象进行判断，比如if(XXX == null)来对所有用到的对象进行判断，这个对象也就是我们常用的函数参数，当检测到null值时，可以对异常的类型抛出，针对性的异常类型，做一个打桩输出，来确定。
如果使用过Lombok工具的话，里面有一个@NotNull注解，就是指被注释的元素不能为空，就会自定检测
遵守编程规范，可以减少一定的空指针异常的发生
如果返回是集合类型。而且是空的，不要返回null值，而是要返回一个空的集合，如果返回类型是对象的话，我们可以抛出异常
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f9b88aa70590358a11d710aa617fb18/" rel="bookmark">
			Ghost模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ghost Module是一种模型压缩的方法，可以用更少的参数生成更多的特征图，即在保证网络精度的同时减少网络参数和计算量，从而提升计算速度（speed），降低延时（latency）。
Ghost 模块可以代替现有卷积网络中的每一个卷积层。
Ghost Module原理 通过对比分析ResNet-50网络第一个残差组（Residual group）输出的特征图可视化结果，发现一些特征图高度相似（如Ghost一般，下图中的三组box内的图像对）。如果按照传统的思考方式，可能认为这些相似的特征图存在冗余，是多余信息，想办法避免产生这些高度相似的特征图。
但本文思路清奇，推测CNN的强大特征提取能力和这些相似的特征图（Ghost对）正相关，不去刻意的避免产生这种Ghost对，而是尝试利用简单的线性操作来获得更多的Ghost对，以增强模型的特征提取能力。
作者提出一个仅通过少量计算（论文称为cheap operations）就能生成大量特征图的结构——Ghost Module。而cheap operations就是线性变换，论文中采用卷积操作实现。具体过程如下：
使用比原始更少量卷积运算，比如正常用64个卷积核，这里就用32个，减少一半的计算量。利用深度分离卷积，从上面生成的特征图中变换出冗余的特征。上面两步获取的特征图concat起来输出，送入后续的环节。 如下图所示，假设原始卷积操作中输入Input与n组kxk的Kernel卷积后生成通道数为n，尺寸为h’xw’大小的输出。在ghost模型中，我们用m组kxk的Kernel与input进行卷积，生成mxh’xw’的本征图intrinsic，之后本征图进行线性变换Φ产生ghost图，将intrinsic和ghost一起作为输出。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33a76078d83ce83ef553613488043e25/" rel="bookmark">
			苹果M1芯片上运行Stable Diffusion(文字作画)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 源码下载 git clone -b apple-silicon-mps-support https://github.com/bfirsh/stable-diffusion.git cd stable-diffusion 2 修改gitee国内源(如果可以稳定访问github就不需要) numpy==1.23.1 --pre torch torchvision torchaudio --extra-index-url https://download.pytorch.org/whl/nightly/cpu albumentations==0.4.6 diffusers opencv-python==4.6.0.66 pudb==2019.2 invisible-watermark imageio==2.9.0 imageio-ffmpeg==0.4.2 pytorch-lightning==1.4.2 omegaconf==2.1.1 test-tube&gt;=0.7.5 streamlit&gt;=0.73.1 einops==0.3.0 torch-fidelity==0.3.0 transformers==4.19.2 torchmetrics==0.6.0 kornia==0.6 -e git+https://gitee.com/rexiyz/taming-transformers.git@master#egg=taming-transformers -e git+https://gitee.com/arcsion/CLIP.git@main#egg=clip 3 安装依赖 pip install -r requirements.txt 3.1 如果onnx报错，安装protobuf brew install Cmake protobuf rust brew link --overwrite protobuf 3.2 如果grpcio报错(链接) brew install openssl CFLAGS="-I/opt/homebrew/opt/openssl/include" LDFLAGS="-L/opt/homebrew/opt/openssl/lib" GRPC_PYTHON_BUILD_SYSTEM_OPENSSL=1 GRPC_PYTHON_BUILD_SYSTEM_ZLIB=1 pip install grpcio 4 下载模型文件(链接) https://huggingface.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/33a76078d83ce83ef553613488043e25/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/383575799964353c928c4b35f7ef92cd/" rel="bookmark">
			一个C语言的基本教程—语句篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 6. 让我们来处理这些数据(1).语句和代码块(2).如果a不等于10的话...(if-else语句)(3).如果情况不止一种...(else-if子句)(4).如果情况还是不止一种...(switch-case语句)(5).我想多猜两次啊！(while与for循环)while循环do-while循环for循环break语句与continue语句 小结 6. 让我们来处理这些数据 前面提了这么多数据的基本操作，我们应该拿它们来做点什么事情。
(1).语句和代码块 我们之前好像提到过{ }(花括号)和;(分号)这两个东西，他们在C语言中有着非常重要的作用
花括号扩入的代码都处在相同的一个域之中，也就是说，花括号里的内容处于一个更小的范围中，我们把没有任何花括号的域叫做全局作用域，而花括号里则为一个局部作用域，花括号中还可以嵌套存在花括号，那就是局部作用域下的局部作用域，他们的范围越来越小，那么引入局部作用域的作用是什么呢？
#include &lt;stdio.h&gt; int main() { int a = 1; { int a = 2; printf("a = %d\n", a); } printf("a = %d\n", a); return 0; } 试试运行这段代码，你会得到以下结果：
是不是很神奇，明明我在花括号中给a赋值为2了，之后的printf打印出来a的值还是1。那么我们就不难理解了，作用域主要作用于变量，根据变量所在的位置可以分为全局变量和局部变量。
不过大家遇到更多的花括号应该还是在语句之中，例如马上我们就要提到的if-else语句，for循环语句，while循环语句，switch语句等等，我们会用花括号把一系列语句框起来，这样便于在满足条件时，执行所有我们需要C语言做的事情。
而分号的作用比较简单，他代表一个语句的结束，例如我们上面说的
int a = 2; 就有这个分号，他代表给a的赋值已经结束了。
(2).如果a不等于10的话…(if-else语句) #include &lt;stdio.h&gt; int main() { int a = 10, input = 0; scanf("%d", &amp;input); printf("You're right!\n"); return 0; } 有这么一个简单到你不愿意玩的游戏，叫做猜数游戏，我们指定a为10，让大家来猜一猜，a是多少呢？当猜到10的时候，我们就要告诉玩家，你猜对了，但如果猜的不是10，那我们就要告诉他你猜错了，怎么做呢，如果像上面这么写代码，那无论猜多少都会输出"You’re right!"了，这样不太好吧。
所以我们可以应用if-else语句来控制一下这个游戏的过程。我们改造代码如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/383575799964353c928c4b35f7ef92cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b5fab94c6e1f4bd4a042e7dfd176217/" rel="bookmark">
			定时器中断配置完自动进入及失能问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在用到STM32定时器的更新中断时，发现有些情形下只要开启定时器就立即进入一次中断。准确说，只要使能更新中断允许位就立即响应一次更新中断【当然前提是相关NVIC也已经配置好】。换言之，只要使能了相关定时器更新中断，不管你定时间隔多长甚至不在乎你是否启动了相关定时器，它都会立即进入一次定时器更新中断服务程序。
以STM32F051芯片为例，做了几种不同顺序的组合测试。根据测试发现，的确有些情况下一运行TIM_ITConfig（TIM1， TIM_IT_Update， ENABLE）; 【即使能更新中断】就立即进入更新中断服务程序。当然后面的中断都是正常的。
老实说，这个问题比较容易忽视，有些情况下也无关紧要，但有些情况可能会给应用带来困扰。从ST MCU相关技术手册似乎并不能明显地找到关于这个问题的很合适或者逻辑性很强的前因后果。
经过验证测试，如果注意一下相关指令代码顺序是可以回避这个问题的。
先做更新中断标志的清除操作，即清除TIMx-》SR寄存器里的UIF标志，然后做定时器更新中断的使能操作。至于开启相关定时器的指令摆放位置并不严格。下面是相关动作的操作顺序及结果，可以参考、验证之。这里共罗列了6种写法，其中有3种情形是会立即进入中断的，另外3种不会。
TIM_ClearITPendingBit（TIM1， TIM_IT_Update）; //清除更新中断请求位
TIM_ITConfig（TIM1， TIM_IT_Update， ENABLE）; //使能定时器1更新中断
TIM_Cmd（TIM1， ENABLE）; //启动定时器
（1）。。。。。。不会立即进入更新中断程序。
TIM_ClearITPendingBit（TIM1， TIM_IT_Update）;//清除更新中断请求位
TIM_Cmd（TIM1， ENABLE）;
TIM_ITConfig（TIM1， TIM_IT_Update， ENABLE）;//使能定时器1更新中断
（2）。。。。。。不会立即进入更新中断程序。
TIM_Cmd（TIM1， ENABLE）;
TIM_ClearITPendingBit（TIM1， TIM_IT_Update）;//清除更新中断请求位
TIM_ITConfig（TIM1， TIM_IT_Update， ENABLE）;//使能定时器1更新中断
（3）。。。。。。不会立即进入更新中断程序。
TIM_ClearITPendingBit（TIM1， TIM_IT_Update）;//清除更新中断请求位
TIM_Cmd（TIM1， ENABLE）;
（5）。。。。。。立即进入更新中断程序。
（6）。。。。。。立即进入更新中断程序。
顺便提下关于定时器里UG位和URS位的使用，分别在TIMx-》EGR和TIMx-》CR1寄存器里。对UG位置1可以产生更新事件并对相关计数器和寄存器重新初始化，如果URS位为0的话，同时会产生更新中断。如果不希望对UG位置1的同时产生更新中断，得置URS位为1，否则会立即进入更新中断。
另外
我们平时使用定时器的时候多数都是处于开启状态，平时的定时中断书写格式一般是：
void TIM3_IRQHandler（void）
{
if（TIM_GetITStatus（TIM3， TIM_IT_Update） == SET）
{
TIM_ClearITPendingBit（TIM3， TIM_IT_Update）;
//要处理的事件内容。。。。
}
}
但是，项目的实验过程中，我使用的定时器处理事件稍微有点特殊，即，定时器不是一直处于开启状态， 而且关闭时候也是在中断里关闭。大概形式这样：
void TIM3_IRQHandler（void）
{
if（TIM_GetITStatus（TIM3， TIM_IT_Update） == SET）
{
TIM_ClearITPendingBit（TIM3， TIM_IT_Update）;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b5fab94c6e1f4bd4a042e7dfd176217/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa76d5de78a29030e426e6e83a15c40f/" rel="bookmark">
			Myeclipse的安装及激活教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
安装MyEclipse Professional 2014 GA：
1、安装MyEclipse Professional 2014 GA： （1）双击MyEclipse Professional 2014 GA安装包
（2）点击“Next”
（3）点击“接受协议”，点击“Next”
（4）选择安装目录，点击“Next”
（5）选择“All”,点击“Next”
（6）选择系统类型，点击“Next”
（7）安装完成，点击“Finish”
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58de622b38663a549a4c3e6431bda00a/" rel="bookmark">
			神经网络结构学习（介绍一种理解tensor结构的方法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍一种理解tensor结构的方法 1. tensor的格式
2. 相关层的tensor转化（卷积，池化，激活）：使用深度学习平台，理解相关层的函数的相关参数（查看官方文档），制作最简单网络（只有一层输入输出），设置输入tensor查看输出tensor。
tensor的格式 常见的tensor表示
imgs = torch.randn(1, 2, 2, 3 , names=(‘N’, ‘C’, ‘H’, ‘W’))
N：数据的数量（常设为-1，表示不确定数量）
C：通道数
H：图像尺寸的高度
W：图像尺寸的宽度
例如 in = torch.reshape(5,3,64,64)
可理解为是5张每张3个通道的尺寸64*64的图片。
相关层的tensor转化 亲手实践利于理解
import torch inputs = torch.tensor(torch.rand(5,5),dtype=torch.float32) inputs = torch.reshape(inputs, (-1,1,5,5)) inputs 在这里设置只有一个层的函数，测试输出层的tensor
from torch import nn class Net(nn.Module): def __init__(self): super(Net, self).__init__() #池化层 self.maxpool1 = nn.MaxPool2d(kernel_size=3, ceil_mode=False) # 可换成其它层函数，例如卷积，relu，linear等等 def forward(self, inputs): return self.maxpool1(inputs) learnNet = Net() out = learnNet(inputs) out 全连接层
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/58de622b38663a549a4c3e6431bda00a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/750cbd4dd90e0a62817910690d7decf4/" rel="bookmark">
			图像采集——OV5640摄像头简介、硬件电路及上电控制的Verilog代码实现并进行modelsim仿真
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言OV5640参数和内部结构SCCB接口DVP接口帧时序 硬件电路OV5640上电控制OV5640上电控制的Verilog代码 前言 链接：https://pan.baidu.com/s/1hmWm1w8Ny4Il25DIFR74Jw?pwd=1234
提取码：1234
OV5640_V5是豪威科技生产的500W像素的CMOS图像传感器，最高支持26241964分辨率（物理尺寸），对应25921944（图像尺寸）。输出支持DVP接口，控制接口为标准的SCCB接口（兼容IIC）。
同时OV5640摄像头支持输出2592x1944分辨率以下任意分辨率的图像。
ISP的输入窗口（物理像素区域）通过0x3800-0x3807等8个寄存器配置。预缩放窗口设置通过0x3810-0x3813寄存器配置。图像输出帧率通过0x3035 - 0x3037寄存器配置。其中设置0x3035寄存器值为0x21，输出帧率30fps。 OV5640参数和内部结构 产品参数：
支持输出的图像格式：
如下是OV5640摄像头的内部结构框图
内部结构复杂，同时也不是FPGA图像采集的重点，我们将重点放在输出接口上。
首先摄像头采集图像数据，经过内部一系列的处理（放大、数字信号转换等），最终通过DVP端口输出，DVP本身拥有10位数据线，因此可输出10位RAW数据，但大多数情况下，使用8位数据线来输出RGB888及RGB565等格式，因此我们取高8位即可，舍弃掉了低2位。
SCCB接口 OV5640采用16位（两个字节）表示寄存器地址，器件地址 7‘h3c
如下为SCCB写寄存器的示意图，
DVP接口帧时序 类似于VGA的行场同步信号，这里先不多介绍。
分析像素时钟pclk：
PCLK像素时钟：一个像素时钟输出一个像素（10位/8位），由于采用8位接口输出，那么每一个工作时钟pclk输出一个字节，对于RGB565格式来说，一个像素是16位，两个字节，所以花费两个像素时钟pclk才能输出一个16位的像素，具体的16位数据中，哪几位表示红色绿色蓝色分量，也是通过寄存器配置。
这里到底像素时钟是多少，有分歧，有比较熟悉这块的大佬可以下面留言讨论。但是可以知道的是：PCLK是 OV5640输出数据时的同步信号，它是由 OV5640 输出的信号。
而XCLK为工作时钟，可以外接晶振或由外部控制器提供。
但是如果真的需要手动计算像素时钟那么公式如下
因此这里对于DVP 640 * 480 * 30fps标准来说，像素时钟的求解方式 ： 物理分辨率 * 帧率 = 784 * 510 * 30 = 12Mhz
分析帧时序：
Vsync: 帧同步信号，高电平期间，输出一帧图像数据。
Hsyn/Href：行同步信号，高电平期间输出一行图像数据。
DVP接口时序参数，和VGA类似，在OV5640官方数据手册中根据输出图像分辨率查看各部分的时序参数即可。
硬件电路 如下是OV5640模块接口原理图：
18引脚应该是OV5640的工作时钟，但是由于默认输入工作时钟Xclk = 24Mhz，因此18引脚为NC。
注意：OV5640 芯片的 DVP 接口本身拥有 10 位的数据线，可以输出 10 位的 RAW 数据，但是在大多数情况下我们使用的数据是八位的，因此只要DVP输出接口的高 8 位数据即可，因此只保留D[9:2]，映射到接口OV-D0-7。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/750cbd4dd90e0a62817910690d7decf4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28acba5ecb84cd4d5a5e28ac310e2a2f/" rel="bookmark">
			算法提升：并查集的十个经典题目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
最长连续序列
被围绕的区域
岛屿数量
岛屿的最大面积
朋友圈问题
除法求值（hard）
情侣牵手（hard）
打砖块（hard）
最大人工岛（hard）
相似字符串组（hard）
最长连续序列 题目
给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。
请你设计并实现时间复杂度为 O(n) 的算法解决此问题。
示例 1：
输入：nums = [100,4,200,1,3,2]
输出：4
解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。
示例 2：
输入：nums = [0,3,7,2,5,8,4,6,0,1]
输出：9
提示：
0 &lt;= nums.length &lt;= 105
-109 &lt;= nums[i] &lt;= 109
解析
并查集绝大多数的题目属于只要你知道有并查集这个东西就非常easy ，这个题之所以放在第一个就是想说并查集的强大。
搞一个并查集把所有的节点初始化在里面；遍历每一个节点，如果key +1 也在存在，就把该节点挂在key+1 的节点下（union操作）遍历size map，看哪个key对应的size 最大； 代码
#include &lt;iostream&gt; #include &lt;unordered_map&gt; #include &lt;vector&gt; using namespace std; class UnionFind { public: unordered_map&lt;int,int&gt; ancestor_; // 用来存储祖先的 unordered_map&lt;int, size_t&gt; size_; // 用来存储每一个集合的大小的 public: //并查集初始化 UnionFind(const vector&lt;int&gt;&amp; vec) { for(auto c:vec) { ancestor_.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/28acba5ecb84cd4d5a5e28ac310e2a2f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/302377404059f3bf045b018633a9a5c2/" rel="bookmark">
			error An unexpected error occurred: “https://registry.npmjs.org/ant-design-vue/解决方案：
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 这个问题的主要原因还是镜像问题：
配置镜像的时候，一般我们只更换了一个镜像源，其实需要换两个。 # 全局安装yarn npm i -g yarn # 验证 yarn -v # 出现对应版本号即代表安装成功 配置镜像：
npm config set registry https://registry.npm.taobao.org --global npm config set disturl https://npm.taobao.org/dist --global yarn config set registry https://registry.npm.taobao.org --global yarn config set disturl https://npm.taobao.org/dist --global 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc3d41d11da8635d3cdc84a5677a86e4/" rel="bookmark">
			UTM分区
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Zone
Central Meridian
Longitude
Zone
Central Meridian
Longitude
1177W180W-177W313E0-6E2171W174W-168W329E6E-12E3165W168W-162W3315E12E-18E4159W162W-156W3421E18E-24E5153W156W-150W3527E24E-30E6147W150W-144W3633E30E-36E7141W144W-138W3739E36E-42E8135W138W-132W3845E42E-48E9129W132W-126W3951E48E-54E10123W126W-120W4057E54E-60E11117W120W-114W4163E60E-66E12111W114W-108W4269E66E-72E13105W108W-102W4375E72E-78E1499W102W-96W4481E78E-84E1593W96W-90W4587E84E-90E1687W90W-84W4693E90E-96E1781W84W-78W4799E96E-102E1875W78W-72W48105E102E-108E1969W72W-66W49111E108E-114E2063W66W-60W50117E114E-120E2157W60W-54W51123E120E-126E2251W54W-48W52129E126E-132E2345W48W-42W53135E132E-138E2439W42W-36W54141E138E-144E2533W36W-30W55147E144E-150E2627W30W-24W56153E150E-156E2721W24W-18W57159E156E-162E2815W18W-12W58165E162E-168E299W12W-6W59171E168E-174E303W6W-060177E174E-180E 转载自Utm Zones
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03ba61725f2b6293a098ffee203e9935/" rel="bookmark">
			python 自增运算符是什么？Python自增1如何实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在学习任何一种编程语言，运算方法的学习是不可避免的，其中自增运算符++的使用也是其中的重点，很多人容易弄不明白其用法，尤其是在Python中，其用法更加的不同！
我们可以写个实例来说明一下++运算符在Python中的用法：
&gt;&gt;&gt; n = 1
&gt;&gt;&gt; ++n
1
&gt;&gt;&gt; n
1
由上面的代码我们可以看出，++运算符在Python中不起作用，其实除了这个运算符不起作用，相应的- -运算符在Python中也是不起作用的，既然如此，那么如何实现Python的自增运算呢，这就需要用到原始的n=n+1来实现了！
最后 如果对Python感兴趣的话，可以试试我的学习方法以及相关的学习资料
对于0基础小白入门：
如果你是零基础小白，想快速入门Python是可以考虑培训的。
一方面是学习时间相对较短，学习内容更全面更集中。
Python所有方向的学习路线
Python所有方向的技术点做的整理，形成各个领域的知识点汇总，它的用处就在于，你可以按照上面的知识点去找对应的学习资源，保证自己学得较为全面。
二、Python必备开发工具
三、精品Python学习书籍 当我学到一定基础，有自己的理解能力的时候，会去阅读一些前辈整理的书籍或者手写的笔记资料，这些笔记详细记载了他们对一些技术点的理解，这些理解是比较独到，可以学到不一样的思路。
四、Python视频合集 观看零基础学习视频，看视频学习是最快捷也是最有效果的方式，跟着视频中老师的思路，从基础到深入，还是很容易入门的。
五、实战案例 光学理论是没用的，要学会跟着一起敲，要动手实操，才能将自己的所学运用到实际当中去，这时候可以搞点实战案例来学习。
六、Python练习题 检查学习结果。
七、面试资料 我们学习Python必然是为了找到高薪的工作，下面这些面试题是来自阿里、腾讯、字节等一线互联网大厂最新的面试资料，并且有阿里大佬给出了权威的解答，刷完这一套面试资料相信大家都能找到满意的工作。
大家拿到脑图后，根据脑图对应的学习路线，做好学习计划制定。根据学习计划的路线来逐步学习，正常情况下2个月以内，再结合文章中资料，就能够很好地掌握Python并实现一些实践功能。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9694d08c48a72f2b76d23227424c7b47/" rel="bookmark">
			JDK19虚拟线程初探（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 经过多年的等待后，JEP 425: Virtual Threads (Preview)终于带来了虚拟线程，这一轻量级的线程模型对标其他语言中的协程，能够显著的减少编写、维护和观察高并发应用程序的工作量。
该特性的目标主要有：
支持服务端应用程序以thread-per-request样式编写，并最大限度压榨硬件性能。兼容java.lang.Thread API，减少调用方代码改动。兼容现有的JDK工具，用于故障排查、调整和分析。 该特性不会：
不会替代线程的传统实现，也不会静默升级现有的线程模型改变Java的并发编程模型在Java语言或Java库中提供新的数据并行结构，不会动摇Stream API的地位。 具体关于JEP 425信息，可以参考JEP 425 ，本文不再赘述。
例程 写一个简单的例子试试看，开n个虚拟线程，每个线程sleep 1秒后累加1次，以模拟IO密集型操作。
private static void runVirtualThread(int length) { AtomicInteger ai = new AtomicInteger(); long start = System.currentTimeMillis(); try (ExecutorService es = Executors.newVirtualThreadPerTaskExecutor()) { for (int i = 0; i &lt; length; i++) { es.submit(() -&gt; { try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } if (ai.incrementAndGet() &gt;= length) { System.out.printf("duration=%d ms, done.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9694d08c48a72f2b76d23227424c7b47/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/424b0d9c614536c697cf1e8dc84575dc/" rel="bookmark">
			【数字信号处理】基于Matlab Designer制作的信号生成、叠加与检测器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下载链接(CSDN)
下载链接(百度网盘)
软件的界面如下：
主要分为了三个控制区模块，即信号生成预览区，信号观测区以及信号分析区。在信号生成区可以通过键盘输入或是滑块调节的方式改变输入信号的频率、赋值以及初相，信号生成区的预览窗口可以实时的动态调整当前信号的波形展示。此外目前设计了白噪声、正弦波、方波以及正弦波四种类型的信号输入。
完成输入参数的调节后，点击“ADD”按钮，就可以将当前的信号送入信号观测区，当ADD进入了多个信号通道后，就可以观测到多信号叠加后的输出波形。点击“Run”可以动态观测叠加波形的运动。点击“Play”可以播放当前叠加波的声音，持续一秒钟时间。点击“Clear”，就可以清空当前信号观测区的信号输入。
最后，在信号分析区，设计了针对叠加信号的频域图以及其他参数的分析功能，具体如界面所示。
如无法下载，源码如下
classdef Digital_signal_generation_and_analyzer_exported &lt; matlab.apps.AppBase % Properties that correspond to app components properties (Access = public) UIFigure matlab.ui.Figure SignalAnalysis matlab.ui.container.Panel STD_error matlab.ui.control.NumericEditField Label_9 matlab.ui.control.Label DigitalSignalGenerationandAnalyzerLabel matlab.ui.control.Label PoweredbyVulcan_QLabel matlab.ui.control.Label Analysis matlab.ui.control.Button Mean matlab.ui.control.NumericEditField Label_8 matlab.ui.control.Label RMS matlab.ui.control.NumericEditField Label_7 matlab.ui.control.Label Peak_Grain matlab.ui.control.NumericEditField Label_6 matlab.ui.control.Label Grain matlab.ui.control.NumericEditField Label_5 matlab.ui.control.Label Peak matlab.ui.control.NumericEditField Label_3 matlab.ui.control.Label UIAxes matlab.ui.control.UIAxes SignalObservation matlab.ui.container.Panel ClearObservation matlab.ui.control.Button PlayObservation matlab.ui.control.Button StopObservation matlab.ui.control.Button RunObservation matlab.ui.control.Button SignalObservation_axis matlab.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/424b0d9c614536c697cf1e8dc84575dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd12b381b6524c5ef1dfdd7a8cedbc28/" rel="bookmark">
			PTA部分题目及解答
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 源自PTA，浙大版《C语言程序设计（第4版）》题目集。
我做了差不多一半，剩下的不太想做了，因为没买书，不能在网站提交，所以不保证我给的解答是一定正确的，也不保证简洁性。
解答的代码每行基本都有写注释。
所使用的笔记软件为：Typora。
其中题目包括：
01求m到n之和
02字符金字塔
03使用函数求奇数和
04使用函数计算两点间的距离
05使用函数求素数和
06使用函数统计指定数字的个数
07使用函数输出水仙花数
08使用函数求余弦函数的近似值
09空心的数字金字塔
10分类统计字符个数
11使用函数求特殊a串数列和
12使用函数输出指定范围内的完数
13使用函数输出指定范围内的Fibonacci数
14使用函数验证哥德巴赫猜想
15使用函数输出一个整数的逆序数
16移动字母
17数组循环右移
18报数
19判断回文字符串
压缩包下载链接：https://pan.baidu.com/s/1m3rCoEg4HxKer8HBfPP2SA 提取码：1oku 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac7c05cfa1f657c0a198fa9dde1204b4/" rel="bookmark">
			k8s集群部署Java(springboot)项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、java项目打成jar包 1、1 在IDEA开发工具中使用maven工具将开发完成的SpringBoot项目达成jar包 我自己的项目生成的jar为：demojenkins.jar。
1、2 将生成jar包上传到装有docker的虚拟机上 我上传到虚拟机的文件目录是/mydocker/springboot
1、3 编写Dockerfile文件 # Dockerfile文件内容如下： # 基础镜像 FROM openjdk:8-jdk-alpine VOLUME /tmp # 将jar包添加到容器中 ADD demojenkins.jar demojenkins.jar ENTRYPOINT ["java","-jar","/demojenkins.jar", "&amp;"] #暴露8111端口作为微服务 EXPOSE 8111 # Dockerfile保留字介绍： EXPOSE:当前容器对外暴漏的端口 FROM:基础镜像，当前新镜像是基于哪个镜像的，指定一个已经存在的镜像作为模板，第一条必须是FROM VOLUME:数据卷挂载，用于保存数据和持久化工作 ADD：将宿主机目录下的文件拷贝进镜像且会自动处理URL和解压tar压缩包 ENTRYPOINT：容器运行执行的命令，当设置了ENTRYPOINT后，docker run不会将ENTRYPOINT命令覆盖。 2、jar包制作成本地镜像 2、1 上传Dockerfile文件到/mydocker/springboot目录下 2、2 切换到/mydocker/springboot目录 $ cd /mydocker/springboot 2、3 执行docker build命令生成本地镜像： $ docker build -t java-demo-01:1.1 . 2、4 查看镜像是否制作完成： $ docker images java-demo-01 REPOSITORY TAG IMAGE ID CREATED SIZE java-demo-01 1.1 160217035f51 3 hours ago 122MB 可以看到镜像已经制作完成。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac7c05cfa1f657c0a198fa9dde1204b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8eab78c153aff35e705853fb6b6f479/" rel="bookmark">
			Vue基础使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
模板语法传值
插值语法
指令系统之文本指令
指令系统之事件指令
指令系统之属性指令
Style 和 Class
条件渲染
列表渲染
v-if+v-for+v-else控制购物车商品的显示
v-for遍历数组(列表)、对象(字典)、数字
key值 的解释
数组的检测与更新
双向数据绑定
事件处理
过滤案例
补充：
事件修饰符
按键修饰符
keycode对应表
表单控制
checkbox多选，radio单选 购物车结算
购物车数量增减以及全选全不选
FOR循环补充
v-model进阶用法
模板语法传值 插值语法 被vue托管的标签中可以写 {{}} 中可以写：变量，js简单的表达式，函数
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src="./vue/vue.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt; &lt;h1&gt;vue插值语法渲染变量&lt;/h1&gt; &lt;p&gt;name:{{name}}&lt;/p&gt; &lt;p&gt;age:{{age}}&lt;/p&gt; &lt;p&gt;hobby:{{hobby}}&lt;/p&gt; &lt;p&gt;the 1st hobby:{{hobby[0]}}&lt;/p&gt; &lt;p&gt;boyfriend:{{boyfriend}}&lt;/p&gt; &lt;p&gt;boyfriend's name:{{boyfriend['name']}}&lt;/p&gt; &lt;p&gt;boyfriend's age:{{boyfriend.age}}&lt;/p&gt; &lt;p&gt;label:{{a}}&lt;/p&gt; &lt;h1&gt;vue 插值语法渲染简单表达式&lt;/h1&gt; &lt;p&gt;{{10 &gt; 9 ? 'bigger' : 'smaller'}}&lt;/p&gt; &lt;p&gt;{{10 + 1}}&lt;/p&gt; // 只有一个+的运算， 没有++ &lt;/div&gt; &lt;/body&gt; &lt;script&gt; var vm = new Vue({ el: '#app', data: { name: 'yietong', age: 22, hobby: ['reading', 'running', 'swimming'], boyfriend: {name: 'imagination', age: 27}, a: '&lt;a href="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8eab78c153aff35e705853fb6b6f479/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/489290f6617d5b0ef39b7197f95b806e/" rel="bookmark">
			引物设计-Primer6.0
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引物设计原则 1、引物应用核酸系列保守区设计并具有特异性。最好位于编码区5'端的300-400bp区域内，可以用DNAMAN，Alignment软件看看结果。
2、不能形成2级结构。
3、引物长度一般在17-25bp之间，上下游引物不能相差太大。
4、G+C含量在40-60%之间，45-55%最佳。
5、碱基要随机分布，尽量均匀。
6、引物自身不能有连续4个碱基的互补。
7、引物之间不能有连续4个碱基的互补。
8、引物5‘端可以修饰。
9、3’端不可修饰，而且要避开AT，GC富集的区域，避开T/C,A/G连续结构（2-3个）。
10、引物3'端要避开密码子的第三位。
11、引物整体设计自由能分布5'端大于3‘端。
12、定量产物长度80-150bp最好，最长是300bp。
Primer6.0 file→new→sequence
\
把自己的序列复制到这里，然后点击add
点击红蓝箭头开始设计引物
点击这里选择参数
选择好后点击seach
下面方框就会出现一个引物，可以点击all Primers
可以看到所有primers，选取其中Rating（看综合评分即黑色评分）较高，且Lenth bp中蓝红数字在10以上，30以内（最好是10-20之间），黑色数字在100-200之间（最高不超过300）的引物。9.选完以后，单机该引物一栏，待该栏变蓝色后，点Replace即可将该引物设置为最佳引物
F是正向引物，5’-3’，R是反向引物
然后用TBtools检查引物特异性
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38239017279b5f8f2639eac049bd5f7a/" rel="bookmark">
			C语言：将任意的十进制的整数转化成八进制输出（VS）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一，问题：输入一个十进制整数decnum，让其转化成八进制的数octnum
二，思路：利用转“二进制”的“倒除法”，不断求出每一次的余数即可，如下图所展示的一样：
（1）输入一个十进制的整数decnum，先将该整数以为正数处理，而负数就只是加个“-”就可以了； int decnum; printf("请输入一个decnum："); scanf_s("%d", &amp;decnum); int i; （2）申明一个数组arr，方便接下来将每一次求余后的余数存放在数组的每一个地址中；因为在VS中，难定义一个自由长度的数组，所以在赋予存储空间时，尽量大一点，防止溢出；
int arr[100] = { 0 }; （3）接下来就是利用循环将余数存放与数组arr中了
1.申明变量a，用于暂时存储decnum对8的余数
2.在求完一次余数后，就要求一次decnum对8的商，用于下一次循环的求余；
3.注意：这里的decnum申明时是整型变量，故decnum如果是小数的话，会强制舍弃小数部分转化成整数；
4.将每一次的余数都存进arr这个数组中，方便后面打印；
5.之所以decnum会变成0，是因为0.00..会自动变成0；
6.当decnum==0时，上面已经求过余了，所以便跳出循环
for (i = 0; i &lt; 100; i++) { //申明变量a，用于暂时存储decnum对8的余数 int a = decnum % 8; //在求完一次余数后，就要求一次decnum对8的商，用于下一次循环的求余； //注意：这里的decnum申明时是整型变量，故decnum如果是小数的话，会强制舍弃小数部分转化成整数； decnum = decnum / 8; //将每一次的余数都存进arr这个数组中，方便后面打印； arr[i] = a; //之所以decnum会变成0，是因为0.00..会自动变成0； //当decnum==0时，上面已经求过余了，所以便跳出循环 if (decnum == 0) { break; } } （4）但此时的arr是逆序的，所以要倒序输出；
int octnum = 0; printf("该decnum转化成octnum为:"); for (int j = i; j &gt;= 0; j--) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/38239017279b5f8f2639eac049bd5f7a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce0e4c9ac4c853d0294b12e751adb1b1/" rel="bookmark">
			二叉排序树详解及其C语言简单实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		定义 二叉排序树（Binary Sort Tree）又称二叉查找树（Binary Search Tree），也称为二叉搜索树。二叉排序树或者是一棵空树，或者是具有下列特点的二叉树：
1. 若左子树不空，其左子树上所有结点的值均小于它的根结点的值；
2. 若右子树不空，则右子树上所有结点的值均大于它的根结点的值；
3. 结点的左、右子树也分别是一个二叉排序树.
如下为一个典型的二叉搜索树：
二叉排序树的基本操作 1 二叉树的构建 目前含有如下元素 23， 19， 29， 16， 21， 32， 20，其构建流程为：
1 首先插入元素23；
2 元素19小于元素23，根据规则将19插入23的左子树中；
3 元素29大于元素23，根据规则将29插入23的右子树中；
4 元素16小于元素19，根据规则将16插入19的左子树中；
5 元素21大于元素19小于元素23，根据规则将21插入19的右子树中；
6 元素32大于元素29，根据规则将32插入29的右子树中；
7 元素20大于元素19小于元素21，根据规则将20插入21的左子树中；
2 二叉搜索树的查找操作 例：从上述二叉搜索树查找元素 21，流程如下：23 --&gt; 19 --&gt; 21
1 首先与根节点进行比较，21 小于 23，可知应在其左子树中进行查找；
2 元素19小于元素21，根据规则应在元素19的右子树中进行查找；
3 元素21大于元素21，成功查找到，结束。
3 二叉搜索树的插入操作 向上述二叉搜索树中插入元素 22，流程如下【首先找到插入位点，插入位点为叶子结点的指针域中，后修改父节点的指针域】：
1 根据查找规则找到插入位点，即插入位点为元素 21的右子树中；
2 将元素21 的右指针域指向元素 22。
4 二叉搜索树的删除操作 4.1 删除元素为叶子结点，无左右子树(看图更明了) 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce0e4c9ac4c853d0294b12e751adb1b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e6892601808e765317f78b92212c36b/" rel="bookmark">
			提升树(Boosting Tree)原理与案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 提升树模型2. 提升树算法2.1 二叉分类提升树2.2 二叉回归提升树 3. 回归提升树示例3.1 求 f 1 ( x ) f_1(x) f1​(x) 即回归树 T 1 ( x ) T_1(x) T1​(x)3.2 求回归树 T 2 ( x ) T_2(x) T2​(x) 4. python代码 1. 提升树模型 提升方法实际采用加法模型（即基函数的线性组合）与前向分步算法。以决策树为基函数的提升方法称为提升树（boosting tree）。对分类问题决策树是二叉分类树，对回归问题决策树是二叉回归树。提升树模型可以表示为决策树的加法模型：
f M ( x ) = ∑ m = 1 M T ( x ; θ m ) f _ { M } ( x ) = \sum _ { m = 1 } ^ { M } T ( x ; \theta _ { m } ) fM​(x)=m=1∑M​T(x;θm​)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e6892601808e765317f78b92212c36b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/259e1413465be27ae5384adaa442a756/" rel="bookmark">
			新手往GitHub建立仓库并上传本地文件(详细)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、创建一个GitHub仓库二、配置ssh并绑定GitHub账号1、配置ssh2、绑定GitHub账号 三、上传文件四、参考资料 前言 **环境：** windows 10 git-bash GitBash获取：
链接：https://pan.baidu.com/s/1DqPaZWhyCwNR-h8k-cZMSQ 提取码：swsj
解压后可以右键git-bash.exe创建快捷方式，方便以后使用。
一、创建一个GitHub仓库 假设你已经有了GitHub账户，直接进入GitHub主页左上角点击new新建一个仓库：
填入仓库名，其余可省略
这样一个仓库就建好了！
二、配置ssh并绑定GitHub账号 1、配置ssh 新建一个文件夹，并在文件夹中放入你想要上传的文件。然后打开下好的git-bash,并进入所在文件夹
生成ssh： ssh-keygen -t rsa -C "这里填登录GitHub的邮箱" 然后，我本来就有了ssh密钥，我就不覆盖了，第一次建的时候要填y,然后的话，ssh默认放置在/c/Users/你的电脑用户名/.ssh。
点击.ssh文件下的id_rsa.pub，并用记事本打开，复制全部信息。然后回到刚刚创建完仓库后的页面：
点击右上角的头像下的settings-&gt;
点击SSH 新增一个SSH 验证是否成功 ssh -T git@github.com 如果他向你打招呼就是配置成功了！
2、绑定GitHub账号 git config --global user.name "github的用户名" git config --global user.email "登录github的邮箱" 我们回到git-bash,依次执行上面两条语句，绑定邮箱。
三、上传文件 进入你想要上传文件所属的文件夹。例如，我想上传一个文本文件，我新建了一个"第一次上传GitHub文件"的文件夹，于是乎把文本文件放在该文件夹下。通过git-bash进入到该文件夹下：
通过git status将项目拉到该文件夹： git status 通过git add . 添加当前目录下的所有文件和子目录 git add . 添加后，再次输入git status查看，1.txt以及准备好上传。
通过git commit -m “这里写一些提示内容”，将暂存区内容添加到本地仓库中。
通过git remote add origin git@github.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/259e1413465be27ae5384adaa442a756/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5fd31813b8a898511cb642e8d5a5f806/" rel="bookmark">
			Qt之Windows Server 2012 R2不支持openssl
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		发现默认情况下服务器Windous Server 2012系统不支持openssl，就算你把已经编译好的库编译好放进去也不行，因为系统就缺少了系统的补丁。
一开始的想的解决办法是：怀疑是因为Windows 10编译的库文件Windous Server 2012系统中不支持，所以先下载openssl的源码，在服务器上重新编译，然后根据编译源码的方法在网上搜索，网上大部分的办法下载编译openssl的源码，编译的具体步骤忘记了，反正首先需要两个工具，perl和nmake，这里可太费事了
其中perl还好说，nmake还要安装一般都是安装Visual Studio来自带安装，然后Visual Studio安装怎么都安装不好使，总是报错。
当时脑子真的短路了，这么尝试下去发现终究是弯路，这些一点软用都没有，这些的本质不也是编译-&gt;生成库文件，我现在库文件都有了只是在当前系统不支持，何必多走弯路。
解决办法：
openssl不支持的原因主要就是系统有的补丁没有安装。
原文链接：windows2012r2安装openssl
Windows Server 2012 R2 补丁包下载地址：依次安装最后重启即可
美中不足的地方就是这些库到底起什么作用并没有搞清楚，就是解决了问题而已，Windows这方面的资料还是太少了，在官网搜索也没有得到相应的解释。下次有时间应该还是会重新翻回来看看这些补丁的作用。
我之前在windows日志报错中，安装过补丁KB2919442和KB2919355，但是结果还是不行，这次下面的全部安装后成功
1、clearcompressionflag.exe https://download.microsoft.com/download/D/B/1/DB1F29FC-316D-481E-B435-1654BA185DCF/clearcompressionflag.exe 2、KB2919442 1、http://download.windowsupdate.com/c/msdownload/update/software/crup/2014/02/windows8.1-kb2919442-x64_f97d8290d9d75d96f163095c4cb05e1b9f6986e0.msu 2、https://download.microsoft.com/download/D/6/0/D60ED3E0-93A5-4505-8F6A-8D0A5DA16C8A/Windows8.1-KB2919442-x64.msu 3、KB2919355 http://download.windowsupdate.com/d/msdownload/update/software/crup/2014/02/windows8.1-kb2919355-x64_e6f4da4d33564419065a7370865faacf9b40ff72.msu 4、KB2932046 http://download.windowsupdate.com/d/msdownload/update/software/crup/2014/02/windows8.1-kb2932046-x64_6aee5fda6e2a6729d1fbae6eac08693acd70d985.msu 5、KB2959977 https://download.microsoft.com/download/9/C/7/9C7A638F-D1E3-40F4-A755-64899A18B411/Windows8.1-KB2959977-x64.msu 6、KB2937592 http://download.windowsupdate.com/c/msdownload/update/software/crup/2014/02/windows8.1-kb2937592-x64_4abc0a39c9e500c0fbe9c41282169c92315cafc2.msu 7、KB2938439 http://download.windowsupdate.com/c/msdownload/update/software/crup/2014/03/windows8.1-kb2938439-x64_3ed1574369e36b11f37af41aa3a875a115a3eac1.msu 8、KB2934018 https://download.microsoft.com/download/D/B/1/DB1F29FC-316D-481E-B435-1654BA185DCF/Windows8.1-KB2934018-x64.msu 9、dotnet-hosting-6.0.1-win.exe https://download.visualstudio.microsoft.com/download/pr/b69fc347-c3c8-49bc-b452-dc89a1efdf7b/ebac64c8271dab3b9b1e87c72ef47374/dotnet-hosting-6.0.1-win.exe oepnssl库 1、先获取当前版本 输出当前QT支持的openSSL版本
qDebug()&lt;&lt;"QSslSocket="&lt;&lt;QSslSocket::sslLibraryBuildVersionString(); //判断系统是否支持OpenSSL //如果此平台支持SSL，则返回true; 否则，返回false。 如果平台不支持SSL，则套接字将在连接阶段失败。不支持就需要看下面的解决方法。 qDebug() &lt;&lt; "OpenSSL支持情况:" &lt;&lt; QSslSocket::supportsSsl(); 我的当前版本是
QSslSocket= "OpenSSL 1.1.1b 26 Feb 2019" 所以我等会下载的就会是OpenSSL v1.1.1的版本 7.2、下载对应的版本
openssl下载地址：
http://slproweb.com/products/Win32OpenSSL.html 根据自己使用的QT编译器时32位还是64位，对应下载安装包。将下载的安装包进行安装，安装到第二个选项时，选择安装到指定的/bin目录下。安装之后，找到安装目录下的两个文件(其中我的是libcrypto-1_1.dll 和libssl-1_1.dll)，拷贝到QT编译器目录下即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f2f29649399163e76390208f86c9b8a/" rel="bookmark">
			【知识蒸馏】透彻理解soft target、hard target
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 问题引入理解soft target、hard target首先：都是概率分布以手写数字识别任务为例样本标准答案（ground truth）hard target、soft target的不同 如何soft（软化）温度T步骤 问题引入 知识蒸馏中用soft target代替hard target，那么soft target、hard target到底是什么？对他们该如何理解？
下面做一个简单快速的说明
理解soft target、hard target 首先：都是概率分布 首先，hard target、soft target都是标签（Labels）的概率分布。
以手写数字识别任务为例 样本 标准答案（ground truth） ground truth / hard label y y y ：2
hard target、soft target的不同 0123456789hard target0010000000soft target0.020.0350.60.20.0050.020.020.030.040.03 或者看下面这张直方图，更直观地体现了hard target和soft target的区别
也许这张图还不足以让我们感受到soft target的优势，那么下面这张图就更好地说明了soft target优于hard taget的地方：携带更多 Teacher Model 学到的有用信息
“ 能携带更多信息 ”， Hinton 在知识蒸馏鼻祖论文（Distilling the Knowledge in a Neural Network）中的描述是：
One of our main claims about using soft targets instead of hard targets is that a lot of helpful information can be carried in soft targets that could not possibly be encoded with a single hard target.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f2f29649399163e76390208f86c9b8a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fde404bcdb5feccedccf584f4f3eff32/" rel="bookmark">
			C&#43;&#43; 实现一个消息队列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、如何实现1、接口定义（1）、推送消息（2）、等待消息（3）、轮询消息 2、用到的对象（1）、队列（2）、互斥变量（3）、条件变量 3、基本流程（1）、线程通信 二、完整代码三、使用示例1、线程通信（1）、等待消息（2）、轮询消息 总结 前言 消息队列在多线程的场景有时会用到，尤其是线程通信跨线程调用的时候，就可以使用消息队列进行通信。C++实现一个能用的消息队列还是比较简单的，只需要一个队列一个互斥变量和一个条件变量，这些在标准库中都有提供。基于曾经写过的项目，总结出来最简单的消息队列的实现将在下文中介绍。
一、如何实现 1、接口定义 一个基本的消息队列只需要3个接口：
（1）、推送消息 推送消息即是将消息写入队列，这个通常采用异步实现，推送之后立刻返回。如果要实现Windows的SendMessage则会比较复杂，最好的方式是放到外部实现，消息队列只提供异步推送消息。
void push(const T&amp; msg);	（2）、等待消息 等待队列的消息，这个方法是同步的，只有接收到消息才会返回。
//等待消息 void wait(T&amp; msg); （3）、轮询消息 轮询消息和等待消息一样也是接收消息，只是无论是否接收到消息轮询消息会立刻返回。轮询消息也是有一定的使用场景，尤其是接收消息线程需要一定的调度逻辑时就需要轮询消息避免线程堵塞。
bool poll(T&amp; msg); 2、用到的对象 （1）、队列 我们使用一个队列来存放消息
#include&lt;queue&gt; std::queue&lt;T&gt; _queue; （2）、互斥变量 使用一个互斥变量确保队列的读写线程安全
#include&lt;mutex&gt; std::mutex _mtx; （3）、条件变量 采用条件变量结合互斥变量实现消息的等待和通知。
#include&lt;condition_variable&gt; std::condition_variable _cv; 3、基本流程 （1）、线程通信 二、完整代码 采用泛型实现，消息类型可以自定义。
#include&lt;mutex&gt; #include&lt;condition_variable&gt; #include&lt;queue&gt; /// &lt;summary&gt; /// 消息队列 /// &lt;/summary&gt; /// &lt;typeparam name="T"&gt;消息类型&lt;/typeparam&gt; template&lt;class T&gt; class MessageQueue { public: /// &lt;summary&gt; /// 推入消息 /// &lt;/summary&gt; /// &lt;param name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fde404bcdb5feccedccf584f4f3eff32/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec59e1809f0a5cd710ea48d13b15ce61/" rel="bookmark">
			集成学习入门与实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 什么是集成学习2.基本思想3.集成学习解决的问题4.相关算法4.1 Boosting4.1.1 AdaBoost算法思想4.1.2 AdaBoost算法流程4.1.3 示例 4.2 提升树（Boosting Tree）4.3 梯度提升树(GBDT)4.4 Bagging与随机森林 5. 偏差-方差分解的角度分析Boosting和Bagging 1. 什么是集成学习 集成学习(ensemble learning)是现在非常火爆的机器学习方法。它本身不是一个单独的机器学习算法，而是通过构建并结合多个机器学习器来完成学习任务。也就是我们常说的“博采众长”。集成学习可以用于分问题集成回归问题集成，特征选取集成，异常点检测集成等等，可以说所有的机器学习领域都可以看到集成学习的身影。
集成学习思维导图图下所示：
2.基本思想 对于训练集数据，我们通过训练若干个个体学习器，通过一定的结合策略，就可以最终形成一个强学习器，以达到博采众长的目的。集成学习有两个主要的问题需要解决：
如何得到若干个个体学习器；如何选择一种结合策略，将这些个体学习器集合成一个强学习器
集成学习是使用一系列学习器进行学习，并使用某种规则把各个学习结果进行整合从而获得比单个学习器更好的学习效果的一种机器学习方法。
通过图例进行简单的分析集成学习过程：
原始数据
个体学习器
不同学习器所选择分割线不同，最终的结果也具有差异性
将多个单学习器进行组合 如果把单个分类器比作一个决策者的话，集成学习的方法就相当于多个决策者共同进行一项决，组合后得到的结果为理想划分界限。
对多个分类器的分类结果进行某种组合来决定最终的分类，以取得比单个分类器更好的性能。
在概率近似正确(PAC)学习的框架中，一个概念（一个类），如果存在一个多项式的学习算法能够学习它。
如果正确率很高，那么就称这个概念是强可学习(stronglylearnable)的。如果正确率不高，仅仅比随即猜测略好，那么就称这个概念是弱可学习(weakly learnable)的。
后来证明强可学习与弱可学习是等价的 3.集成学习解决的问题 如上图所示，我们结合多种策略，使得分类效果较好，但是我们如何进行策略具有如下几个问题：
弱分类器之间是怎样的关系？组合时，如何选择学习器？怎样组合弱分类器？ 问题一：弱分类器之间是怎样的关系？
个体学习器有两种选择：
第一种就是所有的个体学习器都是一个种类的或者说是同质的。比如都是决策树个体学习器或者都是神经网络个体学习器第二种是所有的个体学习器不全是一个种类的或者说是导质的。比如我们有一个分类问题对训练集采用支持向量机个体学习器，逻辑回归个体学习器和朴素贝叶斯个体学习器来学习再通过某种结合策略来确定最终的分类强学习器 目前而言，同质个体学习器应用最广泛，一般我们常说的集成学习的方法都是指的同质个体学习器。而同质个体学习器使用最多的模型是CART决策树和神经网络。
同质个体学习器按照个体学习器之间是否存在依赖关系可以分为两类：
第一是个体学习器之间存在强依赖关系，一系列个体学习器基本都需要串行生成，代表算法是boosting系列算法。第二个是个体学习器之间不存在强依赖关系，一系列个体学习器可以并行生成，代表算法是bagging和随机森林(RandomForest)系列算法。 问题二：组合时，如何选择学习器？
考虑准确性和多样性
准确性指的是个体学习器不能太差，要有一定的准确度；多样性则是个体学习器之间的输出要具有差异性 考虑一个简单的例子：在二分类任务中，假定三个分类器在三个测试样本上的表现如图所示，其中 \sqrt{ } ​ 表示分类正确， × \times × 表示分类错误，集成学习的结果通过投票法产生, 即 “少数服从多数” 。在图(a) 中，每个分类器都只有 66.6 % 66.6 \% 66.6% 的精度，但集成学习却达到了 100 % 100 \% 100%；在图 (b)中，三个分类器没有差别，集成之后性能没有提高；在图©中，每个分类器的精度都只有 33.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec59e1809f0a5cd710ea48d13b15ce61/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9b05d1813f3d10c7f84a3b931f18461/" rel="bookmark">
			Annotation processing is not supported for module cycles解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个错误是：项目的循环依赖错误
这个问题的解决方案：
①：针对于idea操作
右键项目=&gt;local history=&gt;然后查询适当时候的项目版本，回退reserve到那时候的项目
②：查看module，pom.xml文件的依赖问题
下面这个是我从网上摘的文章，大家可以测试一下
错误现象
Error:java: Annotation processing is not supported for module cycles. Please ensure that all modules from cycle [A,B] are excluded from annotation processing
问题分析
查找 http://stackoverflow.com/questions/27223917/how-to-configure-annotations-processing-in-intellij-idea-14-for-current-project 发现可能是依赖的问题。
在idea14菜单下 Analyze-&gt;Analyze Module Dependencies…发现果然是循环依赖。
通过查看工程总的pom.xml可以看到工程各模块之间的依赖关系，各模块自己的pom.xml里配置的依赖顺序没有问题，也没有循环依赖。应该是自己在写单元测试时继承过一个Test基类，结果由于依赖关系原因Test不能被import进来，自己就随手点了下Add dependency on module…引入的。
3.问题解决
既然在配置文件上找不到修改的地方，就是工程自身的配置了，删除上面在添加的依赖，按照如下操作：
1） Analyze-&gt;Analyze Module Dependencies…
2）右键不该循环依赖的模块，在这里就是第一个模块，不应该依赖下面的模块
3）选择依赖关系，删除不该出现的依赖
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/159743def3268dfb99b894eec7f09b06/" rel="bookmark">
			Groovy语言详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Groovy 概述 Groovy是一种基于Java平台的面向对象语言。 Groovy 1.0于2007年1月2日发布，其中Groovy 2.4是当前的主要版本。 Groovy通过Apache License v 2.0发布。
Groovy中有以下特点：
同时支持静态和动态类型。支持运算符重载。本地语法列表和关联数组。对正则表达式的本地支持。各种标记语言，如XML和HTML原生支持。Groovy对于Java开发人员来说很简单，因为Java和Groovy的语法非常相似。您可以使用现有的Java库。Groovy扩展了java.lang.Object。 Groovy的官方网站是The Apache Groovy programming language
二、Groovy 环境部署 有多种方式来获得的Groovy环境设置。
下载和安装： -进入该链接www.groovy-lang.org/download.html获得Windows安装程序部分。
启动Groovy安装程序，然后请执行以下完成安装步骤。
第1步 -选择语言安装程序
第2步 -点击下一步按钮 第3步 -点击“我同意”按钮
第4步 -接受默认组件，然后单击下一步按钮 第5步 -选择适当的目标文件夹，然后单击下一步按钮
第6步 -点击安装按钮开始安装
第7步 -一旦安装完成后，单击下一步按钮开始配置 第8步 -选择默认选项，并单击下一步按钮
第9步 -接受默认的文件关联，然后单击下一步按钮
第10步 -单击Finish按钮完成安装 一旦上述步骤之后，你就可以开始使用Groovy shell，有助于测试我们的Groovy，而不需要为Groovy提供一个完整的集成开发环境。可以通过在命令提示符下命令groovysh来完成。 如果你想包含groovy二进制文件作为maven或gradle构建的一部分，你可以添加以下行。
Gradle：
'org.codehaus.groovy:groovy:2.4.5' Maven：
&lt;groupId&gt;org.codehaus.groovy&lt;/groupId&gt; &lt;artifactId&gt;groovy&lt;/artifactId&gt; &lt;version&gt;2.4.5&lt;/version&gt; 三、Groovy 基本语法 为了了解 Groovy 的基本语法，让我们先看看一个简单的 Hello World 程序。
1、Hello World 程序 创建Hello World程序，你只要输入以下几行简单的代码就可实现 -
class Example { static void main(String[] args) { // Using a simple println statement to print output to the console println('Hello World'); } } 当我们运行上面的程序，我们会得到以下结果 -
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/159743def3268dfb99b894eec7f09b06/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d57866763471b3112f8689559b980b64/" rel="bookmark">
			软件项目管理第一章---项目管理概念
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		软件项目管理复习专用 项目管理概念 软件人员的职业规划
一类是连续不断的、周而复始的活动，人们称之为运作，如企业日常的生产产品的活动。
另一类是临时性、一次性的活动，人们称之为项目。如企业的技术改造活动，一项环保工程的实施。
项目是为了创造一个唯一的产品或提供一个唯一的服务而进行的临时性的努力。
典型的例子
建造一座大楼、一座工厂或一座水库举办各种类型的活动，如一次会议、一次旅行、一次晚宴、一次庆典和体育传播等新企业，新产品，新工程的建设和开发城市道路设施建设—厦门翔安隧道BRT某社区领导选举博导带领研究生解决某个研究课题新建网络系统或开发一套管理软件实施一种全新的经营程序或流程 下列选项中属于项目的是（ ）
A.上课
B.社区保安
C.野餐活动
D.每天的卫生保洁
项目，由一组有起止日期的、相互协调的受控活动所组成的独特过程，该过程要达到符合包括时间、成本和资源的约束条件在内的规定要求的目标
实现项目目标的制约因素
工作范围、成本、进度计划、客户满意度
项目的三重约束
时间功能费用
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-rPjgpChq-1667011895468)(C:\Users\xiaozhao\AppData\Roaming\Typora\typora-user-images\image-20221029093511511.png]
软件项目管理定义：软件项目管理是为了使软件能够按照预定的成本、进度、质量顺利完成而对成本、人员、进度、质量、风险等进行分析和管理的活动
项目管理三要素：时间 成本 质量
下列( )不属于项目管理的三维约束。
A.达到范围目标
B.达到时间目标
C.达到沟通目标
D.达到成本目标
可以這樣描述，为了实现项目的目标，首先需要设定的项目工作和管理范围，即项目范围管理what to do
为了正确实施项目，需要对目标进行分解，对项目的时间、质量成本三大目标分解，即时间管理（when？）项目成本管理（how much？）、项目质量管理（how good？）
项目会过程中，需要投入足够的人力、物力资源，即项目的人力资源管理、项目采购管理
为了对项目团队中人员进行管理，让大家目标一致地完成项目，需要沟通，即沟通管理，集成管理协调各方面
5个标准化过程组 项目管理五要素
技术方法团队建设信息沟通 战术上的范围：三角形
质量、进度、成本
战略上的范围：人员 问题 过程
人是项目管理最宝贵的财富，软件行业更是这样。软件工程研究所专门开发了 人员管理能力成熟度模型PM-CMM关键实践域
使用人 必须下信任人，培养人，给他发展空间，让他看到希望，实现自身价值建立祥和、友善、互助、向上的文化氛围，技术保密、嫉妒是软件公司的大忌。
问题：项目经理的一个主要任务是发现并解决问题，明确项目的目的和范围，选择合适的解决方案，进行 成本估算和进度安排，评估风险。
在项目实施过程中会出现新问题，需要及时发现和解决
过程 ：过程管理是项目管理的任务
不关注过程
关注过程
所谓过程 做事情的 一种固有方式，有经验的人对完成某件事的过程会很了解，他们知道会经历哪些步骤，每一个步骤完成什么事，需要什么样的资源，技术和工具。没有经验的人 就会无从下手
上图可以形象说明过程在软件开发中的地位 比如装修
关注产品上，不关注过程，不同的人采用不同过程，导致开发的产品质量不同，完全依赖个人的素质和能力
如果关注过程
不管谁来做 ，不管什么需求，采用统一开发过程，产品质量是一样的，可以不断提高过程质量来提供产品质量
产品的质量 依赖过程能力 而不是个人能力
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d57866763471b3112f8689559b980b64/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15d7d47b6d6b304465669b5611dc3def/" rel="bookmark">
			python 常用的内置函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python内置函数 1.abs(x) 返回绝对值 返回一个数的绝对值。实参可以是整数或浮点数。如果实参是一个复数，返回它的模。 2.all(iterable) 如果 iterable 的所有元素为真（或迭代器为空），返回 True
def all(iterable): for element in iterable: if not element: return False return True 3.any(iterable) 只要iterable 的有元素为真则返回 True。 如果迭代器为空，返回 False
def any(iterable): for element in iterable: if element: return True return False 4.bin(x) 将一个整数转变为一个前缀为“0b”的二进制字符串
5.oct(x) 将一个整数转变为一个前缀为“0o”的八进制字符串
6.hex(x) 将整数转换为以“0x”为前缀的小写十六进制字符串
7.chr(i) chr(97) 返回字符串 'a'，chr(8364) 返回字符串 '€'。
8.ord(c) ord('a') 返回整数 97， ord('€') （欧元符号）返回 8364 。
9.compile compile(source, filename, mode, flags=0, dont_inherit=False, optimize=-1)
1. source ：创建代码对象的源。 这可以是字符串，字节字符串或AST模块对象。 ​ 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/15d7d47b6d6b304465669b5611dc3def/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0062948c152e23a4bf709779d5ccc00/" rel="bookmark">
			Ubuntu22.04分区设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天刚安装了Ubuntu的系统，安装过程中遇到了磁盘分配的问题，个人总结后分区如下，具体使用有待验证 。
磁盘总容量：250G固态+1T机械
实际分配完毕之后固态和机械硬盘各留了一部分空间以备哪个分区不够时再分配。
1.EFI分区
重要性：必须设置，这个是引导分区，否则安装时会报错。
大小：200M-500M 实际分配2G
类型：逻辑分区
位置：空间起始位置 固态硬盘
用于：EFI系统分区
注意：启动设备选择efi分区
2.swap交换分区
交换分区，可能不是必须的，不过按照传统，并且照顾到您的安全感，还是挂载它吧。它的容量 只要约等于您的物理内存就可以了
大小：16G
类型：主分区
位置：空间起始位置 固态硬盘
用于：交换空间
3./： 根目录
必须挂载的目录。存放系统文件，建议空间不要太小
大小：100G（大小不定，主要用来存放ubuntu系统文件）
类型：逻辑分区
位置：空间起始位置 固态硬盘
用于：Ext4日志文件系统
4./usr 应用程序目录
大部分的软件都安装在这里，如果您计划安装许多软件，建议也给它分配一个分区
大小：100G（存放用户程序，用户自行安装的程序存放在/usr/local/bin中）
类型：逻辑分区
位置：空间起始位置 机械硬盘
用于：Ext4日志文件系统
5./home 家目录
这是您的家目录，通常您自己创建的文件，都保存在这里，建议越大越好
大小：500G（大小不定，主要用来存放用户文件）
类型：逻辑分区
位置：空间起始位置 机械硬盘
用于：Ext4日志文件系统
6./boot
如果您的硬盘不支持LBA模式(不太可能)，您最好挂载它，如果挂载，将它挂载在硬盘的第一个 分区，应该比较稳妥。一般来说，挂载的分区只要100M大小就足够了。
大小：2G
类型：逻辑分区
位置：空间起始位置 固态硬盘
用于：Ext4日志文件系统
7./var
如果您要作一些服务器方面的应用，可以考虑给它分配一个较大的分区
大小：50G
类型：逻辑分区
位置：空间起始位置 机械硬盘
用于：Ext4日志文件系统
安装完毕后各分区空间占用情况
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f9a43642cee792fb3ebfdfa997cb64d/" rel="bookmark">
			机器学习第二章 感知机和支持向量机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 一、感知机1、特点2、感知机模型2.1、例1：儿童免乘车票2.2、例2：鱼的分类2.3、例3：高维空间上的分类2.4、感知机的定义2.5、感知机的几何解释 3、学习策略3.1、两个问题3.2、损失函数3.3、优化目标 4、学习算法4.1、梯度下降法4.2、感知机学习算法 5、存在的问题 二、支持向量机1、概述2、线性可分SVM与硬间隔最大化3、线性SVM与软间隔最大化4、非线性SVM与核函数4.1、线性不可分情况4.2、处理非线性数据4.3、非线性支持向量机4.4、核函数的本质 一、感知机 1、特点 输入为实例的特征向量，输出为实例的类别，取+1和-1感知机对应于输入空间中将实例划分为正负两类的分离超平面导入基于误分类的损失函数利用梯度下降法对损失函数进行极小化感知机学习算法具有简单而易于实现的优点1957年由Rosenblatt提出，是神经网络与支持向量机的基础 2、感知机模型 2.1、例1：儿童免乘车票 2.2、例2：鱼的分类 2.3、例3：高维空间上的分类 2.4、感知机的定义 2.5、感知机的几何解释 3、学习策略 3.1、两个问题 3.2、损失函数 3.3、优化目标 4、学习算法 4.1、梯度下降法 4.2、感知机学习算法 batch：拿总体样本，一次性更新。 优点：稳定 缺点：复杂，耗时
随机梯度下降法：逐个拿样本进行更新。 优点：简单，耗费低 缺点：不稳定
mini-batch：选择部分样本进行更新，综合考虑了batch和随机梯度下降的优点。
5、存在的问题 感知机算法存在许多解【不唯一】，既依赖于初值，也依赖迭代过程中误分类点的选择顺序线性不可分数据集，迭代震荡
二、支持向量机 1、概述 感知机的分类超平面不唯一问题–增加约束，如SVM中的最大化间隔感知机无法解决非线性问题–使用核方法，映射到高维空间
2、线性可分SVM与硬间隔最大化 3、线性SVM与软间隔最大化 4、非线性SVM与核函数 4.1、线性不可分情况 若不存在一个能正确划分两类样本的超平面,怎么办?将样本从原始空间映射到一个更高维的特征空间,使得样本在这个特征空间内线性可分
4.2、处理非线性数据 4.3、非线性支持向量机 4.4、核函数的本质 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ae7676f4d5ee7d2b6a76a4e990d6c9e/" rel="bookmark">
			eve-ng登录没反应？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		eve-ng登录没反应？
答：web登录默认账号是admin密码是eve。如果账号使用错误，点击登录时将没有反应。
感谢eve-ng国代群里面网友点拨！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f1d985bdc604cd7dae639832270cd14/" rel="bookmark">
			记忆化搜索
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、前言
二、简要谈谈记忆化搜索
三、最长滑雪道
1、题目
2、基本思路
3、python代码
四、立方体IV
1、上链接
2、基本思路
3、C++代码
4、python代码
5、发现的C++与python之间的输入区别
五、食物链
1、上链接
2、基本思路
3、C++代码（7/10）
4、python代码（9/10）
一、前言 对于学计算机的同学来说，学习算法是一件非常重要的事情，废话不多讲，我们来讲讲“记忆化搜索问题”。
二、简要谈谈记忆化搜索 什么是记忆化搜索呢？搜索的低效在于没有能够很好地处理重叠子问题；动态规划虽然比较好地处理了重叠子问题，但是在有些拓扑关系比较复杂的题目面前，又显得无奈。记忆化搜索正是在这样的情况下产生的，它采用搜索的形式和动态规划中递推的思想将这两种方法有机地综合在一起，扬长避短，简单实用，在信息学中有着重要的作用。
用一个公式简单地说：记忆化搜索=搜索的形式+动态规划的思想
记忆化搜索是类似于动态规划的，不同的是，它是倒做的“递归式动态规划”。如斐波那契数列、滑雪问题等等。
三、最长滑雪道 1、题目 2、基本思路 解决一道题前，首先考虑用什么算法。
对于这道题而言，最直接朴素的想法应该是对于每个点进行深搜或者广搜，最后枚举一遍答案但是注意，对于每个点而言，只要周围的点比他小，都可以被走到，因此这样做的话时间复杂度是指数级别的，AC不掉。
那么我们考虑优化。
首先，搜索的思路是没有错的，那么怎样优化它呢？我们观察到一个条件，那就是，某个点只能从数值更大的点转移过来，也就是说，整个答案序列应该是递减的 =&gt; 搜索时不可能出现循环 =&gt; 搜索顺序是具有拓扑结构的，即，在一个固定答案序列中，数值较小的点一定是在数值较大的点后被搜索到，那么我们就可以使用记忆化搜索了。（注意上述所说：具有拓扑序是使用记忆化搜索的必备条件）
我们用一个数组储存从每个点出发可以达到的最大长度，之后，若是从其他数值较大的点转移到这个点时，不必再往后搜索了，因为结果已经记录在数组中了，直接返回就好
3、python代码 n,m=map(int,input().split()) Map=[] ans=0 for i in range(n): Map.append(list(map(int,input().split()))) dp=[[-1 for i in range(m)] for j in range(n)] # 先列再行 def dfs(x,y): global dp if dp[x][y]!=-1: return dp[x][y] t=1 for i,j in [(1,0),(0,1),(-1,0),(0,-1)]: px=x+i py=y+j if 0&lt;=px&lt;n and 0&lt;=py&lt;m and Map[px][py]&lt;Map[x][y]: t=max(t,dfs(px,py)+1) dp[x][y]=t return t for i in range(n): for j in range(m): dfs(i,j) for i in range(n): for j in range(m): ans=max(ans,dp[i][j]) print(ans) 四、立方体IV 1、上链接 691.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f1d985bdc604cd7dae639832270cd14/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e26f533944731ac8e5f5d163b1c66b84/" rel="bookmark">
			css transform导致字体像素模糊的问题解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通过 transform:translate(X,Y) 偏移元素达到定位的效果，但是相继出现的是，如果元素内部有字体的话，会出现模糊的问题
1.给字体加多一个父级
原本字体的父级为列子中的popup-box，我们可以看到该父级是参与定位偏移的，所以才会影响到里面的字体，因此我们让字体套多一层父级即可
2.元素宽高值设为偶数
当字体的父级元素盒子宽高给定偶数时，此时是不会出现模糊的，若其一为奇数则出现模糊的情况
3.给translate的Y值偏移设为绝对单位
直接给translate的Y轴偏移设为绝对单位，此时也是不会模糊的，此时不管你元素高度是奇数还是偶数 transform: translate(-50%,-201px);
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c25cd3e806a1d227d6863a0a08673448/" rel="bookmark">
			ubuntu22.04 配置共享文件夹 找不到/mnt/hgfs
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		兴致勃勃地在虚拟机里安装好了Ubuntu 22.04，添加共享文件夹，结果在/mnt竟然没有hgfs这个文件夹，更不好说共享的文件夹winShare。然后上网查怎么搞，一顿操作猛如虎啊，终于解决了！
环境：（1）VMware Workstation 16 Pro， 16.2.3
（2）Ubuntu 22.04
查看所设置的共享目录，若有显示则表示vmware设置无问题
vmware-hgfsclient 1.先安装VMware tools
sudo apt install open-vm-tools 2.手动创建/mnt/hgfs目录
sudo mkdir /mnt/hgfs 3.执行下面指令，即可看到/mnt/hgfs下你所配置的共享目录
vmhgfs-fuse .host:/share /mnt/hgfs #share:你的共享目录名 4.如若失败则需设置开机自动挂载
sudo vi /etc/fstab 然后使用命令a使文件处于可编辑状态，在文件尾部下面这一行
.host:/ /mnt/hgfs fuse.vmhgfs-fuse allow_other 0 0 然后依次按Esc ，：，x保存修改的文件并退出。
注意：
千万不要立即重启，先用mount -a测试下（若提示无权限，如下图，使用sudo mount -a测试），避免出错导致无法开机，无问题则可重启。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/005232074f629e01667e1355f489c12f/" rel="bookmark">
			成功解决Docker You have to remove (or rename) that container to be able to reuse that name.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
问题原因
问题思路
解决方法
看这里
问题原因 今日在执行docker命令时提示
docker: Error response from daemon: Conflict. The container name "/nacos" is already in use by container "0506d263116590fa90adee8f7df1aecd8157f6919325edbe4c054f113f42ec10". You have to remove (or rename) that container to be able to reuse that name. See 'docker run --help'.
碰到这个问题是因为我执行创建容器命令时，上一次的命令有错误，再次创建容器时已经存在一个同名的进程了（不管你有没有创建成功），要么修改名字，要么删除已存在的进程。
问题思路 我们只需要删除已存在的这个容器就好了，下面就是解决方法。
解决方法 #显示已启动Docker进程 docker ps #显示最新创建的容器（包含所有的状态） docker ps -l 因为是未成功执行的容器，所以用 docker ps -l 命令查看已存在名称的ID。
拿到ID，就可以执行删除了
删除命令 docker rm [ID] 例如 docker rm 8cb6ee1f505a 看这里 如果对你有帮助，记得点赞留言哦~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd10f4d8e1651bd7a2ad95a39df151a1/" rel="bookmark">
			Word内安装Mathtype
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 数学公式编辑器(MathType) 《数学公式编辑器(MathType)》是一款专业的数学公式编辑工具，理科生专用的工具。mathtype公式编辑器能够帮助用户在各种文档中插入复杂的数学公式和符号。
数学公式编辑器工具可以轻松输入各种复杂的公式和符号，与Office文档完美结合，显示效果超好，比Office自带的公式编辑器要强大很多。
MathType是强大的数学公式编辑器，与常见的文字处理软件和演示程序配合使用，能够在各种文档中加入复杂的数学公式和符号，可用在编辑数学试卷、书籍、报刊、论文、幻灯演示等方面，是编辑数学资料的得力工具
1.Mathtype7下载： https://pan.baidu.com/s/1vtANlSXHjbFcBE65b2nLrQ 提取码：kbl5
2.Mathtype7解压安装： 解压，双击MathType-win-zh.exe文件，安装 安装路径要全英的,例我的安装路径为：C:\Program Files (x86)\MathType 安装完后，打开安装位置文件夹：
3.运行MathType： 双击运行MathType.exe文件，进入后会显示让你激活或者试用，选择退出 启动MathType7补丁.exe文件。点击下一步，点击安装。（安装时关闭其他程序！） 安装成功后再次打开MathType7，这次就没有提示需要激活或者购买，点击帮助 选择解锁/注册MathType，这时可以看到提示无需付费注册，破解版安装成功： 注意： 成功安装MathType7后，打开world，出现错误提示：
点击确定，点击world左上角的开始-&gt;左下角选项-&gt;加载项，查看MathType Commands 2016.dotm加载项地址。 查找STARTUP文件夹的位置即安装位置；将C:\Program Files (x86)\MathType\MathPage\64（这里64根据自己的系统决定）中的MathPage.wll文件放置STARTUP文件夹外，再次打开world就可以看见word已经不报错了，而且工具栏上的Mathtype可以使用。 注：亲测有效，仅供参考！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b10e081eafd62d5af54975be186fe1d/" rel="bookmark">
			Bellman-Ford算法(C/C&#43;&#43;)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一: Bellman-Ford算法分析二: 代码分析 一: Bellman-Ford算法分析 问题介绍：
问题分析：
1. 处理思路：
因为有了负权边的加入所以显然Dijkstra算法是无法处理，并且有了边数的限制所以这个时候我们可以使用Bellman-ford算法来处理。
算法的原理就是进行松弛操作，假如你一共想要最多走过k条边，那么外层循环就去循环k次，内层循环对边数进行一个循环。其原理为连续进行松弛，在每次松弛时把每条边都更新一下，若在 n-1 次松弛后还能更新，则说明图中有负环( 因为n个点所到达的最长路径也就是n-1条边，如果还可以优化那么显然是出现了负环 )，因此无法得出结果，否则就完成。
这个操作是很简单可以理解的，因为我们初始默认了所有点的距离是无限大，然后进行松弛操作，显然只有通过源点(会设置为dis[ ] = 0 )进行k次松弛操作(相当于从源点最多走了k条边到达的距离)，若是从其他点进行的松弛操作因为本身就是无限大即使减小也依旧是个特别大的数值，远远没有从源点所带来减小的效果显著。
2.算法关键 ：
a. 判断是否到达的时候只需要判断是否大于一个很大的数值(inf /2 )：
原因：正如之前所说的，松弛操作的进行可能的确会影响最终的距离，因为如果有负权边的存在其实第一次松弛操作就会影响这个边所到达点x，本身dis[x] = inf(无穷大) ，因为一次松弛可能使dis[x] = inf - 100这个样子，虽然减小但它其实依旧不可以到达，所以我们最终判断使用 dis[n] &gt; inf / 2就可以了
b. 使用新数组存储上次松弛结果再去松弛本次
我们需要使用一个last[ ]数组来存储上一次松弛完了的结果，然后利用last[ ]再去松弛dis[ ]，因为如果你直接使用dis[ ]去进行松弛操作的话，有可能x被其他点进行了松弛操作，然后你再利用x松弛其他点，这其实就相当于一次性松弛了多次了和算法的原理就相背了。
3.算法总结：
a. 单源最短路+边权为负+边数限制问题: Bellman-ford算法
b. 时间复杂度 O(nm)
二: 代码分析 #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; using namespace std; const int N = 510, M = 1e4 + 10, inf = 0x3f3f3f3f; int n, m, k, dis[N], last[N]; struct { int a, b, w; }edge[M]; //使用结构体存储边 void bellman_ford(){ dis[1]=0;//初始化操作 //外层遍历次数+内层遍历边+使用last来存储上一次松弛完结果 for(int i = 0; i &lt; k; i ++ ){ memcpy(last, dis, sizeof(dis) ); for(int j = 0; j &lt; m; j ++ ){ int x = edge[j].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b10e081eafd62d5af54975be186fe1d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9d3a4f7ddcf8723d89832c00436b358/" rel="bookmark">
			Python全局变量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 总结 1.global必须放在函数内，如果放在函数外将不起作用
2.某个函数如果想改变外部变量的值，就必须在函数内部的该变量前加global，如果有两个函数fun1,fun2都想改变外部变量var的值，那就必修在fun1,fun2里面的var1前都加上global
3.如果fun2想获取fun1里面var1的最新值，就必须都在fun1，fun2里面的var前都加上global
a = 1 b = 1 def test1(): b = 2 def test2(): global b b = 3 return b return test2() print(test1()) 结果：3 def test1(): b = 2 def test2(): global b b = 3 return b test2() return b print(test1()) 结果：2 var1 = 123 #这一行的全局变量也可以注释掉，不影响下面的代码 def func1(): global var1 #变成了教室的黑板（信息透明共享） var1 = 456 print(var1) func1() #456 print(var1) #456 def func2(): print(var1) func2() #456 def func3(): var1 = 333 print(var1) func3() #333 print(var1) #456 def func4(): global var1 #再次变成了教室的黑板（信息透明共享） print(var1) #456 var1 = 444 print(var1) #444 func4() print(var1) #444 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/231e9e4225e9a78a6ba5e3458d31e202/" rel="bookmark">
			Dijkstra算法总结(C/C&#43;&#43;)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一: Dijkstra算法分析二: 代码分析1. 一般代码 O(n * n)2. 优化代码 O(m * logn ) 一: Dijkstra算法分析 问题介绍：
问题分析：
1.Dijkstra算法介绍
Dijkstra算法是基于贪心算法去求解的一个算法，它每次会选取一个离源点最近且还未被选取的点进行选取，总共进行n次选取最终可以选取到dis[n]的最短距离。
2.Dijkstra算法为什么只适用于边权为正值的问题？
解答：因为Dijkstra算法是每次选取到这个合法的点后会将此点的最短距离进行确定下来，它会默认这个点已经是最优解了，而可以进行这个默认的前提就必须是边权为正值，因为如果存在边权为负值则可能导致之后再次使用另一个点 y 去优化的过程将已经确定的点 x 的dis[x]的值可能再次减小，这就和这个算法的原理相违背了，不能确保每一次选取的点为最优点。
3.Dijkstra算法两种版本分析
a.传统版本：
找到未被选择的点当中离源点最近的点 x —— 确定这个点 x 的值dis[x] 已经被确立 —— 利用点 x 去循环遍历 x 和其他未被访问的点的距离。 重复这3个过程 n 次即可找到 n 个点到源点的最短路了。
因为我们是利用点与点之间的关系进行遍历的一共进行 n 次，每次需要遍历 n 个点 所以时间复杂度： O(n* n).
b.优化版本：
找到未被选择的点当中离源点最近的点 x —— 确定这个点 dis[x] 的值已经被确立 —— 这里我们可以做一个优化我们其实只需要去遍历和x有边相连接的点即可，因为如果没有边相连接我们其实遍历是多余的因为也是不可到达的。
总共遍历 n 次其实是一样的，核心在于我们更新与其他点的距离时利用的不再是点与点而是边之间的关系。 一共 m 条边，每次选取源点最近的点利用栈结构log n。时间复杂度O(m * log n)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/231e9e4225e9a78a6ba5e3458d31e202/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4fa99649658b714e4686f73fec915cf5/" rel="bookmark">
			最小路径和（动态规划问题）详解&#43;代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 给定一个，包含非负整数的 m x n 网格。请找出一条，从左上角到右下角的路径。使得路径上，所有数字总和为最小，每次只能向下，或者向右移动一步。例如：
输入:[[1,3,1],
[1,5,1],
[4,2,1]]
输出: 7
解释: 因为路径 1→3→1→1→1 的总和最小。
详解
首先，我们看约束条件！！
从左上角出发，到右下角去，只允许向下或者向右移动。
寻找此时的最小路径，我们可以将其分解为，到达每一个元素所要的最小路径，对于最后一个元素，只需要找他上一步的最小路径即可。（由于每个元素的最小路径斗鱼他上边或者左边的元素的最小路径有关，也即互相不独立的子问题。因此可以使用动态规划解决）
此时，我们可以想到，
对于第一行的所有元素，都可以从左上角的元素通过仅向右移动到达。
对于第一列的所有元素，都可以从左上角的元素通过仅向下移动到达。
创建二维数组dp[][]，用来存储每个对应元素的最小路径。其大小与存储元素的数组grid[][]一样。
有如下公式： 第一个元素 第一行，当 i = 0 且 j &gt; 0， 第一列，当 i &gt; 0 且 j = 0， 其他， 当 i &gt; 0 且 j &gt; 0， def minPathSum(grid): if not grid or not grid[0]: return 0 rows, columns = len(grid), len(grid[0]) dp = [[0] * columns for _ in range(rows)] dp[0][0] = grid[0][0] for i in range(1, rows): dp[i][0] = dp[i - 1][0] + grid[i][0] for j in range(1, columns): dp[0][j] = dp[0][j - 1] + grid[0][j] for i in range(1, rows): for j in range(1, columns): dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] return dp[rows - 1][columns - 1] line = [[1,3 ,1],[1,5,1],[4,2,1]] s = minPathSum(line) print('最小路径和为：',s) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2dd357c08c6baf23d4607578a27e508a/" rel="bookmark">
			python学习之基础语法基础部分
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1常量和表达式2认识变量变量命名的规则变量的类型1.整数的类型2.浮点数（小数）float3.字符串字符串表示字符串函数注意 4.布尔类型5.其他类型补充延伸：类型的意义6.动态类型 3注释4输入和输出5运算符算数运算符关系操作符逻辑运算符赋值运算符 6小题整理 1常量和表达式 print(2/3) # 0.6666666666666666 print(1+2/3) # 1.6666666666666665 # 浮点数和c的存储规则相似，在内存中表示浮点数的时候，是允许有误差的 # 1+2/3 表达式 # 这个表达式的运算结果成为表达式的返回值 # 1 2 3 这样的数字，称为字面值常量 # + - 称为 运算符/操作符 2认识变量 变量命名的规则 硬性规则
变量名必须由 数字，字母，下划线，构成， 不能包含特殊符号
数字不能开头
变量名不能和python的关键字重复
python中的变量名，是大小写敏感的，区分大小写的
软性规则，建议遵守
起名时，尽量选择有描述性的单词来进行表示
尽量通过名字来表现出变量的作用
当一个单词描述不清楚的时候，可以使用多个单词来命名
不怕变量名字长，而怕变量的含义表达的不清楚
当包含多个单词的时候，命名有多种规范
1.驼峰命名，除了第一个单词的首字母之外，后续每个单词的首字母都大写
2.蛇形命名 单词之间使用下划线进行分割
变量的类型 1.整数的类型 # a=10 # print(type(a)) # &lt;class 'int'&gt; # 不需要在定义变量的时候显式声明 # 而时依靠初始化语句，根据初始化的值类型来进行确定的 在py中，int能够表示的数据范围是 “无穷的”
py的int是可以根据要表示的数据的大小，自动扩容的
因此，py中没有long 类型
2.浮点数（小数）float # C++和java里面，float是四个字节的，也叫做单精度浮点数 # double是八个字节的，也叫做 双精度浮点数 # py中的 float 就是双精度浮点数等同于 C++和java中的double py的一个设计哲学，解决一个问题，只提供一种方案
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2dd357c08c6baf23d4607578a27e508a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3fce2f6fcd7c7a9c35bb3fccf04cbcf4/" rel="bookmark">
			【OpenCv】相机标定介绍及python/c&#43;&#43;实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		针孔相机内外参标定简单介绍 之前有一个项目需要公司标内参，之前对这方面没有接触过，网上找了很多资料，记录下相机标定的基础知识。文章是个人浅显理解。如有错误还请指正，非常感谢！
参考链接：
坐标系转换：相机参数标定（camera calibration）及标定结果如何使用_Aoulun的博客-CSDN博客标定opencv代码：Opencv 相机内参标定及使用_Gene_2022的博客-CSDN博客_相机内参标定opencv标定函数介绍：【OpenCV3学习笔记 】相机标定函数 calibrateCamera( ) 使用详解（附相机标定程序和数据）_ZealCV的博客-CSDN博客_calibratecamera参数标定的数学原理：相机标定之张正友标定法数学原理详解（含python源码） - 知乎 (zhihu.com)流程及代码：Opencv——相机标定 - 一抹烟霞 - 博客园 (cnblogs.com)相机模型介绍：相机模型-鱼眼模型/Omnidirectional Camera(1)_苏源流的博客-CSDN博客_davide scaramuzza图像去畸变，对极约束之undistort,initUndistortRectifyMap，undistort 相机标定的目的是找到三维空间与二维空间转换的关系，也称为几何模型，这个几何模型就是相机标定要求解的参数。
1. 坐标系转换 首先需要了解几个坐标系：像素坐标系、图像坐标系、相机坐标系、世界坐标系。
像素坐标系 通常从相机采集到的图像以像素为单位。一般处理时都是以图像的左上角为原点，水平是u方向，竖直是v方向，就是像素坐标系，如下u-v坐标系，某一点在像素坐标系中的位置为 ( u i , v j ) (u_i,v_j) (ui​,vj​)。
图像坐标系 图像坐标系以图像中心为原点，以尺寸为单位，通常一个像素的尺寸为 d x ∗ d y dx*dy dx∗dy。那么像素坐标系与图像坐标系之间就有一个转换关系，图像坐标系以x为水平方向，y为竖直方向。
像素坐标系与图像坐标系的转换关系如下：
{ x = u d x − u 0 d x y = v d y − v 0 d y \left\{\begin{matrix} x=udx - u_0dx\\ y=vdy - v_0dy \end{matrix}\right.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3fce2f6fcd7c7a9c35bb3fccf04cbcf4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3900337ab1d0157dc366d6d4d7377609/" rel="bookmark">
			Idea中Java代码修改以后运行，代码不生效，class文件未被更新
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.一种治标不治本的方法是在File--&gt;Settings--&gt;Build,Execution,Deployment--&gt;Build Tools--&gt;Maven--&gt;Runner中勾选了Delegate IDE build/run actions to Maven
2.进入parent项目目录下，执行mvn idea:module ，之后会看到项目下面新生成了一个.iml文件，原因是原先的iml文件混乱导致的，重新生成一下就OK了； ------------------------------------------------------------------------------------------
idea热部署springboot 步骤
方式一：配置JRebel工具
1.在edit configurate 调试出spring选项。
2.设置springboot配置
修改代码，然后点击移动IDEA，必需让IDEA失去焦点，Jrebel工具才能正常工作 增量class部署--- 快捷键 ctrl+shif+F9 ；
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/216/">«</a>
	<span class="pagination__item pagination__item--current">217/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/218/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>