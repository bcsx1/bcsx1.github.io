<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/acf4d171f4165410fa5de8ff42901eb1/" rel="bookmark">
			Win11 PS无法拖动文件到任务栏打开
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Win11 PS无法拖动文件到任务栏打开 1.软件环境2.问题描述3.解决方法3.1.确保`Win11`更新到22H2版本以上3.2.确保`禁止拖放`关闭3.3.修复系统注册表 4.修复效果预览 1.软件环境 Windows11 企业版64位 22H2
Adobe Photoshop 25.2.0 20231101.m.2385 38bb2d3 x64
2.问题描述 很多人在安装Win11系统后，发现图片无法向Win10系统一样，通过拖拽到任务中上进行打开，严重影响了画图的效率！
3.解决方法 本文给出一种解决这个问题的方案，让你能像Win10一样，直接拖动图片到任务栏直接使用PS打开，加快作图效率，具体步骤如下：
3.1.确保Win11更新到22H2版本以上 3.2.确保禁止拖放关闭 按下Win+R，在出现的运行命令中输入gpedit.msc后回车。
在本地组策略编辑器界面，依次展开左侧面板：用户配置→管理模板→windows组件→任务计划程序→任务计划程序，在右侧窗口找到并打开禁止拖放，将其设置为未配置或已禁用。
注意：
1.若原来就是未配置，则不用管，继续看下一步；
2.若本地组策略编辑器无法打开，显示Windows找不到文件'Gpedit.msc'。请确定文件名是否正确后，再试一次。： 这是因为你的操作系统版本是家庭版，系统将【本地组策略编辑器】功能限制了，所以我们才会打不开。如何解决这个问题，可以参考另一篇博客：Win10：Windows找不到文件’Gpedit.msc’。请确定文件名是否正确后，再试一次。
3.3.修复系统注册表 获取拖动打开文件修复工具 百度网盘下载我提供的工具：win11拖动文件到任务栏打开：
链接：https://pan.baidu.com/s/1pOxRlGxGGzv9hFzkMKI36A?pwd=ga1y
提取码：ga1y，下载后打开微信支付.png使用微信扫码支付：
​​
获取压缩包密码： 第1种方式：付款后微信留言购买的资源名称，博主会微信回复你解压密码（推荐，不需要加好友）： ​​​​ 第2种方式：截图支付凭证以及资源名称，在CSDN私信博主，博主会CSDN私聊你解压密码： 注意：由于虚拟软件的可复制性，一旦售出，便会产生多个副本，因此概不退款，谢谢合作！ 运行工具
解压压缩包之后，双击提供的win11拖动文件到任务栏打开.reg，点击是导入注册表：
显示导入成功：
此时系统会提示你重新启动系统，直接保存打开的文档，然后重启即可：
注意注意：一定要重启哦!
注意注意：一定要重启哦!
注意注意：一定要重启哦!
4.修复效果预览 可以看到，经过修复之后，可以直接像Win10一样，直接拖动图片到任务栏的PS进行打开（注意：要先打开PS哦），大大提高了作图效率~~
​
都看到这里了，还不赶紧点赞，评论，收藏走一波？
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/822a768f9c692972da7600b0a5a2d177/" rel="bookmark">
			【Linux】在vim中批量注释与批量取消注释
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在vim编辑器中，批量注释和取消注释的操作可以通过进入V-BLOCK模式、选择要注释或取消注释的内容、输入注释符号或选中已有的注释符号和按键完成。这些操作可以大大提高代码或文本的编写和修改效率，是vim编辑器中常用的操作之一。
1.在vim中批量注释的步骤： 在normal模式下按Ctrl + v ，进入V-BLOCK模式
按 J 键 或 K 键选择要注释的内容
按大写 I 进入插入模式输入 // 或 # 号
双击 Esc 键，批量注释完成
2.在vim中批量取消注释的步骤： 在normal模式下按Ctrl + v ，进入V-BLOCK模式，然后按两下 L 键，选中注释的符号
按 J 键 或 K 键选择要取消注释的内容
3.按 d 键完成批量取消注释
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e886f9b84f4f74f55791a1dec09603e/" rel="bookmark">
			STM32用一个定时器执行多任务写法和为什么要进行取余256和除256
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一.定时器代码二.取余和除256原因 一.定时器代码 main.c
#include "stm32f4xx.h" uint32_t Power_check_times;	//电量检测周期 uint32_t RFID_Init_Check_times; //RFID检测周期 int main() { Timer_Init(167,999); Power_check_times = gt_get() + 200;//一开始最少是200ms+gt_get()的时间，所以最低是200ms RFID_Init_Check_times = gt_get() + 200; while(1) {	//下面的两个if是这个文章想表达的具体实现什么不用管，本文章目的是用一个定时器，进行200ms进入执行程序 if(gt_get_sub(Power_check_times) == 0) //目标时间200ms，然后定时器计时到了200ms则进来一次	{ Power_check_times = gt_get() + 200;	//电池电量检测，进来后让目标时间在+200，等程序出去后，就可以等待下一次的200ms测量 Power_Check(); } if(gt_get_sub(RFID_Init_Check_times) == 0) { RFID_Init_Check_times = gt_get() + 200;	//RFID初始化检测 if(Rc522_GetLinkFlag() == 0)	{ Readcard_daivce_Init(); MP_SPK = !MP_SPK; } else { MP_SPK = 0; LED4 = !LED4; Rc522_LinkTest(); } } } Timer.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e886f9b84f4f74f55791a1dec09603e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7da6bbd5d0c2f22956639e14561b1d47/" rel="bookmark">
			js 数据类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		js的八种数据类型： 基本类型（基本类型）：Number，String，Boolean，Undefined，Null，Symbol
引用数据类型（对象类型）：Object，Array，Function
Undefined Undefined只有一个唯一的值：undefined。
undefined出现的常见两种情况： 未定义的变量，使用typeof对这个变量进行操作会返回undefined。如果使用其他的操作符来检测该变量的数据类型，会报错。 console.log(typeof data) 定义了的变量，但是还未初始化或者是这个变量初始化为undefined，这个变量的值就是undefined。一般来说，我们没有必要把一个变量显示初始化为undefined，因为会默认为undefined。 let data; console.log(data) undefined判断： 使用严格相等符===或者不相等操作符!==来进行判断，不能使用==，因为==会检查变量是否为null，但是===就不检查。注意null 不等同于 undefined。使用typeof操作符。 Null Null只有一个唯一的值：null。它是一个字面量，空值，null表示一个空指针，表示对象没有指向任何对象。
null判断： 使用严格相等符===或者不相等操作符!==来进行判断，不能使用==。，因为==会检查变量是否为undefined。
不能使用typeof判断，因为typeof会判断null为一个对象。
if(data === null){ console.log("yes"); } 在什么时候使用null？ 定义的变量在后续中会用来保存数据，但是现在还没有保存，就要把这变量的值初始化为null。当这个数据不要需要时，把这个数据设置为null，解除引用。 undefined和null判断 console.log(null == undefined); //true console.log(null === undefined); //false Symbol Symbol是ES6引入的一种数据类型，表示独一无二的值，Symbol是一个类似于字符串的数据类型。
symbol的注意事项： Symbol函数前不能使用new命令，会报错。Symbol使用typeof判断变量类型会显示为Symbol类型。Symbol创建时的参数： 字符串对象，调用对象的toString方法，将其转换为字符串，生成一个Symbol值 const obj = { toString(){ return 'abc'; } }; const sym = Symbol(obj); sym // Symbol('abc'); 相同参数的Symbol函数的返回值是不相等的，Symbol函数的参数只表示当前symbol值的描述。 var s1 = Symbol('foo'); var s2 = Symbol('foo'); s1 === s2//false Symbol值不能与其他类型的值进行运算，会报错，但是Symbol可以转换成其他类型的值。 显式转为字符串 var sym = Symbol('symbol'); sym.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7da6bbd5d0c2f22956639e14561b1d47/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60f6e44cc2fa39e4b6eda31f93cc3e29/" rel="bookmark">
			【周转时间、平均周转时、带权周转时间和平均带权周转时间的计算】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一个作业到达后就是一个作业的提交时间，从提交时间起到开始执行之间的时间为等待时间。开始执行到执行完毕之间为执行时间。作业执行完毕的时间即为完成时间。
1.周转时间:作业到达后到作业完成的时间。
周转时间=完成时间-提交时间
周转时间=执行时间+等待时间
2.平均周转时间 : (作业周转时间之和) / 作业数。
3.带权周转时间:作业的周转时间和运行时间的比值。其值说明作业从一开始到执行完毕的相对等待时间。
带权周转时间 = (执行时间+等待时间) / 执行时间 = 1+（等待时间)/执行时间。
4.平均带权周转时间 : (作业带权周转时间之和) / 作业数。
举个栗子:
有5个作业，分别为A、B、C、D、E，它们依次到达后备队列的时刻为0、2、3、4、5(注意：没有1哈)。系统需要为它们服务时间依次为4、2、3、3、4。
算法用例如下：我们采用【轮转调度算法】(时间片为1)执行这五个作业，请回答下面问题：(若有小数，小数部分保留两位有效数字，四舍五入，不支持分式表达。)
[1]作业A、B、C、D、E的完成时间依次为12、8、13、14、16
[2]作业A、B、C、D、E的周转时间依次为12、6、10、10、11
[3]作业A、B、C、D、E的带权周转时间依次为3、3、3.33、3.33、2.75
[4]这五个作业的平均周转时间为9.8；平均带权周转时间为3.08
轮转调度的执行顺序为：AABCDEABCDEACDEE
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51c32376b3f37776b0f998580d1ffa5a/" rel="bookmark">
			【LangChain学习之旅】—（1） 何谓 LangChain
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Reference：LangChain 实战课
【LangChain学习之旅】— 何谓 LangChain 如何理解 LangChainLangChain 中的具体组件LangChain调用ChatGPTLangChain代理功能 如何理解 LangChain 作为一种专为开发基于语言模型的应用而设计的框架，通过 LangChain，不仅可以通过 API 调用如 ChatGPT、GPT-4、Llama 2 等大型语言模型，还可以实现更高级的功能。正有潜力且具有创新性的应用，不仅仅在于能通过 API 调用语言模型，更重要的是能够具备以下两个特性： 数据感知：能够将语言模型与其他数据源连接起来，从而实现对更丰富、更多样化数据的理解和利用。具有代理性：能够让语言模型与其环境进行交互，使得模型能够对其环境有更深入的理解，并能够进行有效的响应。 因此，LangChain 框架的设计目标，是使这种 AI 类型的应用成为可能，并帮助我们最大限度地释放大语言模型的潜能。 总而言之，LangChain 是一个基于大语言模型（LLMs）用于构建端到端语言模型应用的框架，它可以让开发者使用语言模型来实现各种复杂的任务，例如文本到图像的生成、文档问答、聊天机器人等。LangChain 提供了一系列工具、套件和接口，可以简化创建由 LLMs 和聊天模型提供支持的应用程序的过程。
LangChain 中的具体组件 LangChain 中的具体组件包括：
模型（Models），包含各大语言模型的 LangChain 接口和调用细节，以及输出解析机制。提示模板（Prompts），使提示工程流线化，进一步激发大语言模型的潜力。数据检索（Indexes），构建并操作文档的方法，接受用户的查询并返回最相关的文档，轻松搭建本地知识库。记忆（Memory），通过短时记忆和长时记忆，在对话过程中存储和检索数据，让 ChatBot 记住你是谁。链（Chains），是 LangChain 中的核心机制，以特定方式封装各种功能，并通过一系列的组合，自动而灵活地完成常见用例。代理（Agents），是另一个 LangChain 中的核心机制，通过“代理”让大模型自主调用外部工具和内部工具，使强大的“智能化”自主 Agent 成为可能！你的 App 将产生自驱力！ LangChain调用ChatGPT pip install langchain 安装 LangChainpip install openai 来安装 OpenAI在 OpenAI 网站注册属于自己的 OpenAI Key（淘宝1块钱可以买5$额度GPT3.5）。 import os os.environ["OPENAI_API_KEY"] = '你的OpenAI Key' from langchain.llms import OpenAI llm = OpenAI(model_name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/51c32376b3f37776b0f998580d1ffa5a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a404a8552be7c435a0236edf48a0c05/" rel="bookmark">
			ES查询流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在ES中查询分为两类：1.基于文档ID查询，2.按照非文档ID查询。
基于文档id查询 1.基于文档ID查询 当执行如下查询时：
GET /megacorp/employee/1 ES在执行上述查询的具体过程如下：
1、客户端向 Node 1 发送获取请求，此时Node1为协调者节点。
2、协调者节点使用文档的 _id 来确定文档属于分片 0 。分片 0 的副本分片存在于所有节点第的三个节点上。 在这种情况下，它将请求转发到 Node 2 。
3、Node 2 将文档返回给 Node 1 ，然后将文档返回给客户端。
在处理读取请求时，协调结点在每次请求的时候都会通过轮询所有的副本分片来达到负载均衡。在文档被检索时，已经被索引的文档可能已经存在于主分片上但是还没有复制到副本分片。 在这种情况下，副本分片可能会报告文档不存在，但是主分片可能成功返回文档。 一旦索引请求成功返回给用户，文档在主分片和副本分片都是可用的。
按照非文档ID查询 先看一个同时包含分页，排序，字段值过滤的查询流程。
1.基于其他条件查询 基于其他条件进行文档检索的过程分为：查询和获取。
查询 由于不确定被检索的文档在多个分片中的分布情况，所以会在所有分片上进行文档查询，所以当一个索引的主分片比较多的时候，检索性能反而不高。
具体检索的过程如下：
1.客户端发送检索请求，此时ES集群中的某个节点会接受到这个请求，接受请求的节点，被称为协调者节点，如图中Node1。
2.协调者节点将检索请求发送到所有主分片/从分片上，如图上Node2中的R0和Node3中的R1，各个主从分/从分片在所在节点本地执行检索请求。此时检索的结果仅仅是符合条件的文档ID和对应排序字段的值，默认情况下，这个排序字段为相关性评分_score(评分是在查询的时候计算的)。
3.各个分片所在的节点将检索的结果返回给协调节点。
获取
经过查询过程，协调者节点获得了目标文档的ID和文档中对应的排序字段值。基于这些结果数据，接下来会执行数据获取的操作：
1.协调者节点根据排序逻辑和分页逻辑，从结果集数据中筛选最终需要的文档ID。协调者节点根据结果文档ID，计算出文档所在的分片信息，然后向某个或某些个目标分片(如图中Node1的R0和Node2的R1)发送 multi-get request请求，获取文档的全部信息。
2.目标分片将文档数据返回给协调者节点。
3.协调者节点将获取到的结果文档数据，返回给客户端。
上述取回数据的过程和关系型数据库中的普通索引回表过程类似。
2.深度分页查询问题 在分布式系统中，对于分页查询的场景，我们需要了解一下深度分页的性能问题，这是在分布式系统中，比较常见的一个问题。在讨论深度分页问题前，我们先熟悉一下分布式系统中的分页问题。
分页查询通常会伴随着排序问题，如果不按照某个指标进行排序的话，那么分页就没有意义了，如果不进行排序，那么如何区分第一个和第二页的内容呢？
当向分布式系统提交一个分页查询时，该查询请求会被转发到分布式系统中的各个子节点上，在每个子节点中执行该查询，但是我们需要知道，每个子节点的查询结果只是在该节点上的一个局部结果，并不是全局结果，全局结果是所有子节点查询结果的一个综合结果。只有每个局部结果数据集比较"完整"才能保证全局结果的正确性。
这里的完整怎么理解呢？
假如我们把学生考试成绩存储在一个有3个节点的分布式系统中，此时我们需要获取成绩排名第5到第10的学生信息，那么此时的查询流程如下：
1.每个节点需要查询出当前节点，所拥有数据集中学生成绩排名前10的学生信息。
2.汇总30名学生信息，然后从30名学生中找出考试成绩排名在第5到第10名的6位学生。
这里我们会发现，我们的查询请求只需要6名学生信息，但是查询过程却需要对30名学生信息进行处理。具体可以参考下图：
通过上图我们可以发现，考试成绩排名在第5到第10的6名学生信息，在3个节点中的分布并不是在第5到第10的存储位置，有可能分布在第1到第10的任何位置，所以为了保证全局数据的准确性，每个子节点要获取考试成绩是前10名的 10个学生的信息才可以。
上面的查询需求翻译成查询语句就是：按照考试成绩排序后的学生信息集合中 ，查询从考试成绩第5名开始的后5位学生信息。或者是：在分页大小为5的查询中，获取第2页数据。此时各个子节点需要查询的数据量其实是：pagesize*pagenum。
在ES中的查询语句如下：
GET /_search { "from": 5, "size": 5 } 此时我们在回到上面的问题，在分布式系统中执行深度分页查询时(页码比较大)，会导致子节点的系统资源被大量占用，查询性能迅速下降。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a404a8552be7c435a0236edf48a0c05/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7024d465c355104a7b248a9f857c78bc/" rel="bookmark">
			pycharm依赖管理(不要用pip freeze)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用python虚拟环境时，可以使用requirements.txt来管理当前项目的依赖。
注意，不要用 pip freeze &gt; requirements.txt 这个命令，因为它会引入很多无关的包。
可以使用 pipreqs ./ --encoding=utf-8 ./ 表示当前项目的目录，--encoding=utf-8 是为了避免报错(编码相关)
Note Why to use pipreqs? Because pip freeze will collect all dependencies from the environments. While pipreqs will collect requirements used only in the current project!
pipreqs 生成的依赖就是你在项目中 import 的，但是可能会有遗漏(需要手动补全)
pycharm 自带的 sync 的原理和 pipreqs一致 下载包时 pip install -r requirements.txt 即可
可以使用 下面的命令来展示当前项目的依赖树：
pipdeptree --python D:\XXXX\venv\Scripts\python.exe
colorlog==6.8.0 └── colorama [required: Any, installed: 0.4.6] concurrent-log==1.0.1 └── portalocker [required: &gt;=1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7024d465c355104a7b248a9f857c78bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d30863ce9af82fca8e2f85bbe6ad5cb/" rel="bookmark">
			spring-kakfa依赖管理之org/springframework/kafka/listener/CommonErrorHandler错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：
整个项目使用spring-boot2.6.8版本，使用gradle构建，在common模块指定了implementation 'org.springframework.kafka:spring-kafka:2.6.8’这个工程也都能运行（这正常发送kafka消息和接收消息），但是执行单元测试报错，报错信息如下：
... 86 more Caused by: java.lang.NoClassDefFoundError: org/springframework/kafka/listener/CommonErrorHandler at java.base/java.lang.Class.getDeclaredFields0(Native Method) at java.base/java.lang.Class.privateGetDeclaredFields(Class.java:3297) at java.base/java.lang.Class.getDeclaredFields(Class.java:2371) at org.springframework.util.ReflectionUtils.getDeclaredFields(ReflectionUtils.java:738) ... 101 more Caused by: java.lang.ClassNotFoundException: org.springframework.kafka.listener.CommonErrorHandler at java.base/jdk.internal.loader.BuiltinClassLoader.loadClass(BuiltinClassLoader.java:641) at java.base/jdk.internal.loader.ClassLoaders$AppClassLoader.loadClass(ClassLoaders.java:188) at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520) ... 105 more 解决办法： 现在直接上本人的解决办法，每个人遇见到问题可能不同，需要使用不同解决办法
在build.gradle中取消版本，直接石红
common模块中原先的内容（最开始的项目指定2.6.8版本）
implementation 'org.springframework.kafka:spring-kafka:2.6.8' 更新后的内容
implementation 'org.springframework.kafka:spring-kafka' testImplementation 'org.springframework.kafka:spring-kafka' 分析： 1， 这个项目使用的springboot 2.6.8版本，在总的build.gradle已经指定对应的依赖管理
buildscript { repositories { maven { url "https://plugins.gradle.org/m2/" } } dependencies { classpath "org.springframework.boot:spring-boot-gradle-plugin:2.6.8" classpath "io.spring.gradle:dependency-management-plugin:1.0.11.RELEASE" classpath "com.netflix.nebula:gradle-lint-plugin:17.7.1" } } 2, 查看springboot 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d30863ce9af82fca8e2f85bbe6ad5cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3953f5329b8f215a872b5ffa8dec005d/" rel="bookmark">
			在Ubuntu中下载软件时可能会出现：E：无法定位软件包 net-tools
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 1.报错2.原因3.解决方案 1.报错 在Ubuntu中下载软件时可能会出现：E：无法定位软件包 net-tools
2.原因 本地没有该功能的资源或者你更换了源但是还没有重新update，所以只需要更新一下本地资源就可以。
3.解决方案 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26e5b5ca9a580b8e78a9bcc3ae2597bd/" rel="bookmark">
			【Python期末】基于Tkinter的学生管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		诚接计算机专业编程作业(C语言、C++、Python、Java、HTML、JavaScript、Vue等)，
标价10RMB/15RMB每份，如有需要请私信与我联系
本文资源下载地址：https://download.csdn.net/download/weixin_47040861/88628319———————————————————————————————————————————
本篇是关于Tkinter的学生管理系统，下面是详细介绍：
首先该页面共包含四个文件，其中两个txt文件作为数据库使用，登录/注册页面(main.py)和管理页面(Student.py)分别为两个py文件。
1.登录注册页 主要功能：
用户登录：
用户输入用户名和密码。从 Account.txt 的文件中读取存储的账户信息。遍历文件中的账户信息，验证用户输入的用户名和密码是否与任何现有账户匹配。如果找到匹配的账户，显示消息框提示“登录成功”，然后关闭当前窗口并打开管理窗口。 用户注册：
用户输入用户名和密码。从一个名为 Account.txt 的文件中读取现有的账户信息。检查用户输入的用户名是否已经存在。如果用户名不存在，将新的用户名和密码添加到 Account.txt 文件中，并显示注册成功的消息框。然后关闭当前窗口并打开管理窗口。 2.管理页面 管理页面是一个选项窗口，该窗口包含五个选项卡，分别对应代码的五个不同的功能：
添加学生信息：
用户可以输入学生的姓名、学号和绩点。信息被写入名为 "student.txt" 的文件中，格式化存储每个学生的姓名、学号和绩点。弹出消息框显示添加成功的信息。 删除学生信息：
用户输入要删除的学生学号。如果找到相应学号的学生信息，删除该学生的信息，并显示删除成功的消息框；否则，显示学生不存在的错误信息。 修改学生信息：
用户输入要修改的学生学号以及新的姓名、学号和绩点信息。如果找到相应学号的学生信息，修改学生的信息，并显示修改成功的消息框；否则，显示学生不存在的错误信息。 查询学生信息：
用户输入学生学号进行查询。如果找到相应学号的学生信息，显示该学生的详细信息；否则，显示未找到学生信息的错误信息。 按绩点排序：
将 "student.txt" 文件中的学生信息按照绩点进行降序排序。排序后的结果显示在一个消息框中，包含每个学生的姓名、学号和绩点信息。 视频演示：
【Python期末】基于Tkinter的学生管理系统功能展示
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0bac94747a480ae4b4757a676d91f90e/" rel="bookmark">
			系统架构设计师教程（七）系统架构设计基础知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系统架构设计基础知识 7.1 软件架构概念7.1.1 软件架构的定义7.1.2 软件架构设计与生命周期需求分析阶段设计阶段实现阶段构件组装阶段部署阶段后开发阶段 7.1.3 软件架构的重要性 7.2 基于架构的软件开发方法7.2.1 体系结构的设计方法概述7.2.2 概念与术语7.2.3 基于体系结构的开发模型7.2.4 体系结构需求7.2.5 体系结构设计7.2.6 体系结构文档化7.2.7 体系结构复审7.2.8 体系结构实现7.2.9 体系结构的演化 7.3 软件架构风格7.3.1 软件架构风格概述7.3.2 数据流体系结构风格7.3.3 调用/返回体系结构风格7.3.4 以数据为中心的体系结构风格7.3.5 虚拟机体系结构风格7.3.6 独立构件体系结构风格 7.4 软件架构复用7.4.1 软件架构复用的定义及分类7.4.2 软件架构复用的原因7.4.3 软件架构复用的对象及形式7.4.4 软件架构复用的基本过程 7.5 特定领域软件体系结构7.5.1 DSSA的定义7.5.2 DSSA的基本活动7.5.3 参与DSSA的人员7.5.4 DSSA的建立过程 7.1 软件架构概念 7.1.1 软件架构的定义 软件体系结构是指一个程序或计算系统软件的一个或多个结构，包括软件的构件、构件的外部可见属性以及它们之间的相互关系。软件构件可以是程序模块、面向对象的类、数据库和中间件等。软件体系结构设计主要关注软件构件的结构、属性和交互作用，旨在提高软件工程师分析设计的有效性，考虑可能的选择方案和降低与软件构造相关联的风险。建立体系结构层的方法旨在提供一种导出体系结构设计的系统化方法，而体系结构设计则是构建软件的初始蓝图。
7.1.2 软件架构设计与生命周期 需求分析阶段 在软件工程领域，需求分析和软件体系结构设计面临不同的对象，分别是问题空间和解空间。为了保持二者的可追踪性和可转换性，研究如何从需求模型构建软件体系结构模型，以及如何保证模型转换的可追踪性是非常重要的。
针对这两个问题的解决方案因采用的需求模型不同而异，其中，采用Use Case图描述需求的方法中，一般通过词法分析和经验规则来完成从Use Case图向软件体系结构模型(包括类图等)的转换，并通过表格或Use Case Map等方式维护可追踪性。
从软件复用的角度看，软件体系结构对需求工程具有自然性和必然性，已有系统的软件体系结构模型对新系统的需求工程有很好的借鉴作用。因此，在需求分析阶段研究软件体系结构有助于将其概念贯穿整个软件生命周期，从而保证软件开发过程的概念完整性，促进各阶段参与者的交流，并易于维护各阶段的可追踪性。
设计阶段 设计阶段是软件体系结构（SA）研究的关注点之一，主要包括SA模型的描述、设计与分析方法以及设计经验的总结与复用。SA模型的描述研究可以分为三个层次。
SA的基本概念，即SA模型由哪些元素组成以及它们之间的组织原则。传统的设计概念只包括构件和基本的模块互联机制，但现在连接子作为与构件同等级别的实体也被引入。近年来，一些学者还认为应该将Aspect等因素引入SA模型。
体系结构描述语言（ADL），它是支持构件、连接子及其配置描述的语言。ADL对连接子的重视是与其他建模语言区分的一个重要特征。常见的ADL有UniCon、Rapide、Darwin、Wright、C2SADL、Acme、xADL、XYZ/ADL和ABC/ADL等。
SA模型的多视图表示，通过不同的视角描述系统的体系结构，并将这些视图组织起来形成整体的SA模型。多视图描述是近年来SA研究的重要方向之一，每个视图反映了不同人员关注的系统特定方面，体现了关注点分离的思想。
将体系结构描述语言和多视图相结合可以更好地描述系统的体系结构，便于理解和交流，并有利于一致性检测和系统质量评估。学术界提出了多种多视图方案，如4+1模型、Hofmesiter的4视图模型、CMU-SEI的Views and Beyond模型等。工业界也提出了一些标准，如IEEE标准1471-2000、开放分布式处理参考模型（RM-ODP）、统一建模语言（UML）和Zachman框架等。需要注意的是，现阶段的ADL大多没有显式地支持多视图，而且上述多视图并不仅限于设计阶段的模型描述。
实现阶段 在实现阶段，体系结构研究关注于将体系结构设计转换为具体实现的技术。这包括基于SA的项目组织结构、配置管理、测试技术等方面的研究。SA提供了系统的蓝图，开发团队应该与体系结构模型相对应，从而提高软件开发效率和质量。SA引入了能够扩充现有配置管理的能力，通过引入版本、Options等信息记录不同版本构件和连接子之间的演化，以组织配置管理的活动。为填补高层SA模型和底层实现之间的差距，可通过封装实现细节、模型转换、精化等方法缩小概念之间的差距，并通过构件组装方式实现系统，这通常需要底层中间件平台的支持。
构件组装阶段 在S A设计模型下，可复用构件的组装能够在较高层次上实现系统，并提高系统实现效率。研究内容主要包括两个方面：一是支持可复用构件的互联，即实现S A设计模型中规约的连接子；二是在组装过程中检测和消除体系结构失配问题。
在设计阶段，可以通过ADL来支持连接子的实现，如UniCon和C2SADL等提供了多种连接子类型和生成连接子代码的机制。
中间件作为公共服务的提供者，遵循特定的构件标准，支持构件之间的互联。中间件具有跨平台交互的能力，且符合工业标准，如CORBA、J2EE、COM等，能够确保构件之间的通信完整性。中间件还提供强大的公共服务能力，有利于保证系统的质量属性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0bac94747a480ae4b4757a676d91f90e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df5694e7040d4043bb96c964a0dbd388/" rel="bookmark">
			LeetCode经典150题Golang版.121. 买卖股票的最佳时机II
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目 给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。
在每一天，你可以决定是否购买和/或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。
返回 你能获得的 最大 利润*。
示例 1：
输入：prices = [7,1,5,3,6,4] 输出：7 解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3 。 总利润为 4 + 3 = 7 。 示例 2：
输入：prices = [1,2,3,4,5] 输出：4 解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。 总利润为 4 。 示例 3：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df5694e7040d4043bb96c964a0dbd388/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed9bcff72ea3898a1cd5e9d85c376584/" rel="bookmark">
			Maven常用插件使用总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Maven是一个跨平台的项目管理工具，主要用于基于java平台的项目构建，依赖管理。
其中有很多用于项目构建的插件。
1、maven-compiler-plugin
用于编译项目源文件，可以设定构建使用的jdk版本信息，从Maven 3.0开始默认使用jdk1.6进行构建。
compile有两个目标（goals），即compile和testCompile，compile主要用于编译main下的源文件，testCompile主要用于编辑test下的源文件。
&lt;build&gt; &lt;finalName&gt;java-base-mysql&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 2、maven-clean-plugin
用于清理构建的文件，默认构建文件位置为target目录。clean有一个目标（goal），即clean，用于清理构建的信息。
&lt;project&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;auto-clean&lt;/id&gt; &lt;phase&gt;initialize&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;clean&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/project&gt; 3、maven-assembly-plugin
用于定制程序的输出信息等，需要自定义assembly.xml文件。
&lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt; &lt;version&gt;2.4&lt;/version&gt; &lt;configuration&gt; &lt;finalName&gt;java-base-utils&lt;/finalName&gt; &lt;appendAssemblyId&gt;false&lt;/appendAssemblyId&gt; &lt;descriptors&gt; &lt;descriptor&gt;assembly.xml&lt;/descriptor&gt; &lt;/descriptors&gt; &lt;/configuration&gt; &lt;/plugin&gt; 4、maven-resources-plugin
用于处理项目资源文件并拷贝到输出目录。
&lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;overwrite&gt;true&lt;/overwrite&gt; &lt;/configuration&gt; &lt;/plugin&gt; 5、build-helper-maven-plugin
maven在默认情况下只允许指定一个主java代码目录src/main/java和一个测试Java代码目录src/test/java。如果需要指定多个源码目录，此时就可以通过build-helper-maven-plugin的add-source目标，通常它被绑定到默认生命周期的generate-sources阶段，用于添加多个源码目录。
&lt;plugin&gt; &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt; &lt;artifactId&gt;build-helper-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed9bcff72ea3898a1cd5e9d85c376584/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af9f37c45873de31d4415bec7c496762/" rel="bookmark">
			2023-12-16 Sat｜六级
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 坚持打卡第48天
健康方面（非常重要‼️） 每天运动，有氧和拉伸为主，运动十几分钟即可✅（1h+）零点之前睡觉早上八点之前起床 学习方面 力扣每日一题✅每天把当天APP上的单词复习完，并复习至少10个生词本上的单词✅（0.5h）【120词】每天写学习总结✅（0.5h）每天阅读✅六级✅（2.5h）稍微准备一下六级✅（0.5h）复习操作系统 其他 掘金日签✅ 每日固定（少于1h） 每天都记录自己的所思所想，只有记录下来的东西，才真正属于你，但是也不要什么都记，简单点，记几句话就好。每天都坚持读10分钟的书籍。每天都花几分钟复盘一下，自己在过去的一天时间里，到底有没有进步，哪怕仅仅只是进步一点点？每天至少运动十几分钟。每天都要有几分钟的独处时间，也不用思考什么，独处就好。每天晚上花几分钟预演一下第二天要做的事。 又是凌晨三点才睡，一觉睡到11点。感觉精神萎靡。最近身边不少人生病了，感冒发烧之类的，感觉自己也被传染了，有了类似的症状。所以今天晚上一定要早睡！（但是寝室真的很吵，凌晨两三点还在讲话）上午睡过去了，下午去考了六级。虽然我一年前就考过了，但是不妨碍我接着考。考前临时抱佛脚背了几个句式，过了一遍流程，背了些单词。考试时还派上了用场，虽然用处不大。我完形整道题没写，因为时间不够了。虽然我最后几分钟看了一下选项里面的单词，发现自己基本都认识，但是没时间写就是没时间写。我阅读做得特别慢，导致我翻译+完形只剩不到20min。不过幸亏完形分数不高。我写作文也很慢，导致完全没时间看听力题。以后还是得提升一下速度，裸考还是不太行。考完昏昏沉沉的，最近几天熬太狠了，加上周围人生病，以及自己也有点小感冒，状态确实不太好。晚上去健身房锻炼了一个多小时。锻炼完之后才吃晚饭。晚上真的很困倦，于是基本没有学习，虽然书摆在那里，但是没怎么看。过了晚上十点之后，困意熬过去了，又看了一会专业课，写了每日碎碎念，十一点多的时候回寝室了。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b03b4cbbd05c79a4c047ba9202bd7507/" rel="bookmark">
			发现宝藏之pyecharts
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		鉴于之前写的pyecharts，写的很那啥，我今天发现了一个讲述pyecharts非常详细的文章，大有启发！
直角坐标系图表 第一导入pyecharts
from pyecharts.charts import * from pyecharts import options as opts import random import datetime 直方图 # 虚假数据 x_data = ['Apple', 'Huawei', 'Xiaomi', 'Oppo', 'Vivo', 'Meizu'] y_data = [123, 153, 89, 107, 98, 23] bar = (Bar() .add_xaxis(x_data) .add_yaxis('', y_data) ) bar.render_notebook() 图
折线图 # 虚假数据 x_data = ['Apple', 'Huawei', 'Xiaomi', 'Oppo', 'Vivo', 'Meizu'] y_data = [123, 153, 89, 107, 98, 23] line = (Line() .add_xaxis(x_data) .add_yaxis('', y_data) ) line.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b03b4cbbd05c79a4c047ba9202bd7507/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f44212c4490b0fab68c7c3383bcc68c8/" rel="bookmark">
			flink源码分析之功能组件(四)-slot管理组件II
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 本系列是flink源码分析的第二个系列，上一个《flink源码分析之集群与资源》分析集群与资源，本系列分析功能组件，kubeclient，rpc，心跳，高可用，slotpool，rest，metrics，future。
本文解释slot管理组件，严格来说，slot管理组件不属于功能组件，而是业务组件，包括slotpool和slotmanage，资源消费者申请到资源后，在本地管有资源slot，避免资源管理器异常导致作业运行失败，同时资源管理器不可用也不会影响作业的继续执行，只有资源不足时才会导致作业执行失败。
slot管理组件也是实现声明式资源管理核心，值得我们细细分析。本文slot管理组件II 分析声明式资源管理, slot管理组件I分析slotpool组件的分配/申请资源
检查资源需求/检查资源声明 检查资源需求/检查资源声明是flink声明式资源管理的核心方法
之前的资源场景分为两类，提出资源需求和提供资源， 检查资源请求/检查资源声明是交汇点，处理资源请求，该分配的分配，该请求新的请求新的资源；检查资源声明，哪些资源可以释放，需要新资源请求新worker。
本章深入分析两方法，上游提出资源需求和下游提供资源的串联，资源状态演变，存储型态
检查资源需求(checkResourceRequirements) 检查资源需求是真正的分配资源
1） 获取作业的未完成资源请求
2） 尝试分配可用资源到作业
之所以尝试，资源变更触发调用检查资源请求，但不一定是增加，可能是无效分配
slotTracker获取所有可用资源，与请求匹配，合适的分配allocateSlot，该方法对应场景请求使用资源/提供资源
3） 尝试使用待定的资源
待定资源是指申请了新的worker或者将要申请新worker所产生的资源，两者都是目前没有物理上的对应资源，通俗说就是先占个坑，等申请了资源再填回去
同样，首先匹配现有的待定资源，若还有未分配打开新的待定资源
tryAllocateWorkerAndReserveSlot调用TaskExecutorManager的allocateWorker，预先挖好”坑”，创建待定资源PendingTaskManagerSlot
declareNeededResourcesWithDelay方法下节介绍，按需要申请新的worker，增加物理资源
到此还有一个问题，物理资源到位后怎样填”坑”
自然想到slot管理组件I中的注册任务管理器/报告资源，使用新增资源抵消待定资源
TaskExecutorManager的registerTaskManager方法
检查资源声明(checkResourceDeclarations) 声明资源，要申请多少资源，可释放多少资源，上一节检查资源请求打开新待定资源，最终调用checkResourceDeclarations，实际申请新worker获得物理资源，为了支持动态/静态资源申请，中间ResourceAllocator转接了一下，这里不详细分析
现有的worker数量-需要的worker数量，大于0，worker多了可以释放；反之，worker少了，需要打开新worker
requestNewWorker参看 请求新worker
ResourceDeclaration怎么来？
主要是计算totalWorkerNum，目前worker总数量
totalWorkerNum = pendingWorkerNum + neededRegisteredWorkers
pendingWorkerNum 待定的slots除以每个worker的slots，向上修正，只多不少
neededRegisteredWorkers是已经注册的worker减去待释放的worker
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6cc5c1b92d108829f44b12be8efb8d0b/" rel="bookmark">
			在Linux上使用mysqldump备份MySQL数据库的详细步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL数据库备份是确保数据安全性的关键步骤之一。在Linux系统上，使用`mysqldump`工具是一种常见、可靠的方法，它能够导出数据库的结构和数据，以便在需要时进行还原。以下是详细的备份步骤：
步骤 1：登录到MySQL服务器 首先，使用以下命令登录到MySQL服务器。在登录过程中，你需要提供MySQL用户名和密码：
mysql -u your_username -p 步骤 2：选择数据库 选择要备份的数据库，使用`USE`命令。替换`your_database`为实际的数据库名称：
USE your_database; 步骤 3：使用mysqldump进行备份 使用`mysqldump`命令导出数据库内容。以下是一个基本的备份命令：
mysqldump -u your_username -p your_database &gt; backup.sql 这将在当前工作目录中创建一个名为`backup.sql`的SQL文件，其中包含选定数据库的结构和数据。
步骤 4：指定主机和端口 如果MySQL服务器不在本地主机上或使用非默认端口（3306），请使用`-h`和`-P`选项指定主机和端口：
mysqldump -u your_username -p -h your_host -P your_port your_database &gt; backup.sql 确保替换`your_host`和`your_port`为实际的主机名或IP地址以及端口号。
步骤 5：添加密码提示 为了增加安全性，可以在`mysqldump`命令中省略密码，以便在执行命令时输入密码。这样可以避免在命令历史记录中明文存储密码。修改命令如下：
mysqldump -u your_username -p -h your_host -P your_port your_database &gt; backup.sql 执行此命令后，系统将提示你输入密码。
步骤 6：压缩备份文件（可选） 如果你想要减小备份文件的大小，可以使用`gzip`等工具对备份文件进行压缩。例如：
gzip backup.sql 这将创建一个名为`backup.sql.gz`的压缩文件。
步骤 7：验证备份文件 在备份完成后，最好验证备份文件是否可用。可以使用`zcat`查看压缩文件的内容：
zcat backup.sql.gz | less 或者对于未压缩文件：
less backup.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6cc5c1b92d108829f44b12be8efb8d0b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16f3219a52e2a225aa388f3a979399d5/" rel="bookmark">
			C语言实现车牌识别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		车牌识别（Automatic License Plate Recognition, ALPR）通常使用计算机视觉技术来实现。C++中，可以使用OpenCV库和深度学习框架（如TensorFlow或PyTorch）来实现车牌识别。
以下是一个简单的C++实现车牌识别的步骤：
安装OpenCV库：首先需要在你的计算机上安装OpenCV库。你可以从官方网站下载并安装：https://opencv.org/releases/
准备数据集：收集一些车牌图片作为训练和测试数据集。确保数据集中的车牌图片具有多样性，以便于训练一个高性能的模型。
数据预处理：对车牌图片进行预处理，包括缩放、灰度化、二值化、边缘检测等操作。这些操作可以帮助模型更好地识别车牌区域。
构建模型：使用深度学习框架（如TensorFlow或PyTorch）构建一个车牌识别模型。这个模型可以是一个卷积神经网络（CNN）或其他类型的深度学习模型。
训练模型：使用预处理后的训练数据集训练模型。在训练过程中，模型会学习识别车牌的特征。
测试模型：使用预处理后的测试数据集评估模型的性能。如果模型的性能满足要求，可以将其应用于实际的车牌识别任务。
应用模型：将训练好的模型应用于实际的车牌识别任务，例如通过摄像头捕获实时图像并识别车牌号码。
这里只是一个简单的概述，实际实现车牌识别可能需要更多的细节和技术。你可以参考一些现有的C++车牌识别项目，如ALPR-detection(https://github.com/abourget/alpr-detection）和License-Plate-Recognition(https://github.com/Scikit-Learn-Community/License-Plate-Recognition)。
以下是一个使用C++和OpenCV实现车牌识别的简单示例：
首先，确保已经安装了OpenCV库。然后，创建一个名为“license_plate_recognition.cpp”的文件，并将以下代码粘贴到文件中：
#include &lt;iostream&gt; #include &lt;opencv2/opencv.hpp&gt; #include &lt;opencv2/highgui/highgui.hpp&gt; #include &lt;opencv2/imgproc/imgproc.hpp&gt; #include &lt;opencv2/objdetect/objdetect.hpp&gt; using namespace std; using namespace cv; int main() { // 读取图片 Mat src = imread("car.jpg"); if (!src.data) { cout &lt;&lt; "无法读取图片" &lt;&lt; endl; return -1; } // 转换为灰度图像 Mat gray; cvtColor(src, gray, COLOR_BGR2GRAY); // 使用Sobel算子进行边缘检测 Mat sobelX, sobelY; Sobel(gray, sobelX, CV_32F, 1, 0); Sobel(gray, sobelY, CV_32F, 0, 1); // 计算梯度幅值和方向 Mat magnitude, angle; cartToPolar(sobelX, sobelY, magnitude, angle, true); // 二值化 Mat binary; threshold(magnitude, binary, 100, 255, THRESH_OTSU | THRESH_BINARY); // 膨胀操作 Mat dilated; Mat kernel = getStructuringElement(MORPH_RECT, Size(21, 7)); dilate(binary, dilated, kernel); // 轮廓检测 vector&lt;vector&lt;Point&gt;&gt; contours; findContours(dilated, contours, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE); // 筛选轮廓 vector&lt;Rect&gt; plates; for (size_t i = 0; i &lt; contours.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/16f3219a52e2a225aa388f3a979399d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e7eec3b589ffa8b2fb33b793946a4d2/" rel="bookmark">
			linux文件管理（上）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、vimb编程器
1、vi编辑器
2、vim编辑器
4.
4.vim编辑器的四种模式（重点）
1.命令模式
2编辑模式（输入模式）
在命令模式输入小写字母a或小写字母i即可进入编辑模式，在该模式可以对文件的内容进行编辑
3末行模式
在命令模式下输入冒号：即可进入末行模式，可以在末行输入命令来对文件进行查找、替换、保存，退出等操作
4可视化模式（）
二、vim 四张模式关系
三vim使用
1，使用vim打开文件
语法：vim 文件夹名称
例： vim readme.TXT
4.命令模式下的相关操作
移动光标到首行或尾行
移动光标到首行：gg
移动光标到尾行：G
快速定位光标到指定行（重点）
行号加G
查找/搜索
切换命令模式，然后输入/(进入末行模式)
如果需要取消高亮，则需要在末行模式中输入：noh
显示行号
：set nu
取消行号：set nonu
四、编辑模式
五、可视化模式下复制
六，vim编辑器实用功能
1，代码着色
2异常退出解决方案.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5c73d536d26ecaf0a27e26b478eb899/" rel="bookmark">
			Mybatis在新增某个数据后，如何获取新增数据的id
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在某些业务中，我们在新增一条数据之后，需要拿到这条数据的id来对这条数据进行后续的一个操作，如何拿取id呢？
使用的是&lt;insert&gt; 中的useGeneratedKeys 和 keyProperty 两个属性
1.在Mybatis Mapper文件中添加属性 “useGeneratedKeys”和“keyProperty”，其中 keyProperty 是 Java 对象的属性名，而不是表格的字段名。
&lt;insert id="insert" parameterType="Spares" useGeneratedKeys="true" keyProperty="id"&gt; insert into system(name) values(#{name}) &lt;/insert&gt; 2.Mybatis 执行完插入语句后，自动将自增长值赋值给对象 systemBean(指的是你自己创建的对象) 的属性id。因此，可通过 systemBean 对应的 getter 方法获取！
int count = systemService.insert(systemBean); int id = systemBean.getId(); //获取到的即为新插入记录的ID 【注意事项】
Mybatis Mapper 文件中，“useGeneratedKeys” 和 “keyProperty” 必须添加，而且 keyProperty 一定得和 java 对象的属性名称一直，而不是表格的字段名。
java Dao中的 Insert 方法，传递的参数必须为 java 对象，也就是 Bean，而不能是某个参数。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4849c6b9e54c3a0816572242f6641c1/" rel="bookmark">
			联想小新&#43;Windows10&#43;Ubuntu18.04双系统安装&#43;引导设置过程全记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面双系统安装配置主要过程引导设置主要参考 Ubuntu卸载需要的工具具体步骤情况一情况二 主要参考 后记2020.5.29更新关于卸载关于主题的配置 写在前面 又是折腾的一天，双系统的安装之旅终于告一段落。都是站在各位大佬的肩膀上才得以成功，就不一一列出了（看了不下二十篇博文），小白在此万分感谢。
回头来看，其实步骤不复杂，但是要把握的细节点多，本文主要总结在联想小新上安装Ubuntu双系统的过程，其他机型应该会有些差异，但大体思路是一样的。下面主要讲安装，对于卸载，文章彻底删除Ubuntu EFI分区及启动项已经说的很详细了，不再赘述。希望可以帮到大家。
双系统安装 配置 联想小新潮7000+i5 GeForce940MX 128GB+1TB 主要过程 对于联想小新系列，其BIOS是新版的UEFI，所以直接进行下面的操作。
软碟通（Ultra ISO）制作系统启动盘就不多说了，这不是大问题，参考windows10安装ubuntu双系统教程（绝对史上最详细）即可。
鼠标右键单击开始（或者win+X），选择磁盘管理，在机械硬盘（大的那块）右键压缩卷，等待一会，输入压缩空间量，我这里给分配100GB，换算成小单位是102400MB，点击压缩，又是一阵等待。。。（三年的电脑了，慢是肯定的）结果就是图1这样，显示未分配[1]。
图1 关机-&gt;插入制作好的启动盘-&gt;打开BIOS-&gt;选择第二项BIOS Setup（图2）。联想小新BIOS比较奇葩，需要在关机状态下用取卡针戳一下内存卡槽边上的小按钮，风扇呼呼转，BIOS也启动了，需要修改如下的几个参数：将“安全启动”和“快速启动”设置为Disable，将“USB启动”设置Enable，都是与BOOT（启动）有关的参数，如图3-4（画质略渣，见谅）最后保存退出即可。 图2 图3 图4 上述一顿操作后，Windows直接开机了。。。接着关机，取卡针戳一下，这时候选择第三项Boot Menu，选择第二项（应该是你的优盘的相关型号参数），如图5。 图5 选择Try Ubuntu without installing，双击左上角的Install Ubuntu 18.04.4.LTS就来到了这里：图6。
图6 选择语言及键盘布局（看你喜好）。无线网最好别连。选最小安装，节省时间。如图7-9.
图7 图8 图9 接下来划重点了！！！
一定要点击其他选项（图10），除非你想完全删除Windows。
在空闲（如果有多个的话，选与刚才创建的空间一样大的那个，内存计算上多少有些出入） 图10 然后，依次设置四个分区如下[2]，选中空闲后点击左下角加号开始设置（每一个我都等了好久。。注意千万别选错，如果选错了可以点右下角还原重新来过）
大小新分区的类型新分区的位置用于挂载点备注46080MB主分区空间起始位置Ext4日志文件系统/无8192MB逻辑分区空间起始位置交换空间无无512MB逻辑分区空间起始位置EFI系统分区无记住这里的盘符
一会用52592MB逻辑分区空间起始位置Ext4日志文件系统/home无 上面操作完成后，先别急着点现在安装！！！
还要设置下面的安装启动引导器的设备，要用到EFI系统分区的盘符，我这里为sda5（图11-12），之后继续即可。
图11 图12 设置计算机名等选项，再经过一阵漫长的等待（图13-14），即可完成安装。 图13 图14 引导设置 在这上面一顿操作之后，还要进行一些开机引导的设置，否则重启后还是Windows。
在安装完之后重启会直接来到Ubuntu，这时候需要设置引导，又是十几篇博文的苦苦追寻后，终于找到了合适的方法。。下面看图（图15），这是安装了一个名为rEFInd的软件后出现的画面，开机直接选择系统即可（第一排第二个是Ubuntu的，第四个是Windows的，不同设备可能有不同，需要仔细分辨），链接（包括Windows下使用的refind、Ubuntu下使用的refind和主题文件，就是带“-master”的那个）我都放在云盘了，需要者自取。
图15 安装也很简单，打开Ubuntu终端，(当前路径切换至安装包所在目录)执行如下命令即可：
sudo dpkg -i refind.deb 之后就会在文件夹下出现这些文件（图16）
图16 把里面的示例文件（refind.conf-sample）改成refind.conf，就可以完成配置了。 这款软件还可以定制启动画面，具体的详见github项目以及UEFI下win10+ubuntu16.04双系统安装教程加高b格rEFInd可diy开机引导。Windows下设置引导可以看这篇使用rEFInd引导Ubuntu和Windows双系统，不过我还没试过，有兴趣的话大家可以试试。
主要参考 [1] windows10安装ubuntu双系统教程（绝对史上最详细）
[2] 超详细！Win10（UEFI启动）安装Ubuntu18.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4849c6b9e54c3a0816572242f6641c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad6c6ecdca199db7c62f20490a155039/" rel="bookmark">
			Poisson方程五点差分格式例题及解答
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面例题解题过程总结参考 写在前面 本文针对偏微分方程数值解中出现的一道例题进行分析，详细介绍了五点差分格式的公式推导及应用。
例题 在单位正方形 Ω ‾ : 0 ⩽ x ⩽ 1 , 0 ⩽ y ⩽ 1 \overline{\Omega}:\,0\leqslant x\leqslant1,\,\,0\leqslant y\leqslant1 Ω:0⩽x⩽1,0⩽y⩽1上，
{ Δ u = − 16 , ( x , y ) ∈ Ω u ∣ x = 1 = 0 , ∂ u ∂ y ∣ y = 1 = − u ∂ u ∂ x ∣ x = 0 = ∂ u ∂ y ∣ y = 0 = 0 \left\{\begin{aligned} &amp;\Delta u=-16,\quad (x, y)\in\Omega\\ &amp;u|_{x=1}=0,\quad \frac{\partial u}{\partial y}|_{y=1}=-u\\ &amp; \frac{\partial u}{\partial x}|_{x=0}=\frac{\partial u}{\partial y}|_{y=0}=0\\ \end{aligned}\right.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad6c6ecdca199db7c62f20490a155039/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b59f45de1ab0999c8e4315c1ea79153/" rel="bookmark">
			教你怎么前端实现埋点上报
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 那么在一个企业中，我们要如何去了解用户呢？最直接有效的方式就是了解用户的行为，了解用户在网站中做了什么，呆了多久。而如何去实现这一操作，这就涉及到我们前端的埋点了。
一.埋点方式 在聊如何进行埋点前，我们先介绍下什么是埋点？
所谓'埋点'是数据采集领域（尤其是用户行为数据采集领域）的术语，指的是针对特定用户行为或事件进行捕获、处理和发送的相关技术及其实施过程。. 比如用户某个icon点击次数、观看某个视频的时长等等。从数据产品经理视角，聊聊埋点的意义 | 人人都是产品经理 (woshipm.com)
基于此我们可以知道埋点是实际上是对特定事件或者行为的数据监控和上报，常见的埋点上报方式有ajax，img，navigator.sendBeacon下面介绍下这三种埋点上报方式
(1)基于ajax的埋点上报 介绍 因为埋点实际上是对关键节点的数据进行上报是和服务端交互的一个过程，所以我们可以和后端约定一个接口通过ajax去进行数据上报。
代码实现 我们可以封装一个方法，代码如下：
function buryingPointAjax(data) { return new Promise((resolve, reject) =&gt; { // 创建ajax请求 const xhr = new XMLHttpRequest(); // 定义请求接口 xhr.open("post", '/buryingPoint', true); // 发送数据 xhr.send(data); }); } 使用时，直接调用即可
let info = {} buryingPointAjax(info) // 这样就成功上报了info的对象 缺点 一般而言，埋点域名并不是当前域名，因此请求会存在跨域风险，且如果ajax配置不正确可能会浏览器拦截。因此使用ajax这类请求并不是万全之策。
(2)基于img的埋点上报 上面可以看到如果使用ajax的话，会存在跨域的问题。而且数据上报前端主要是负责将数据传递到后端，并不过分强调前后端交互。因此我们可以通过一些支持跨域的标签去实现数据上报功能。
script，link，img就是我们上报的数据的最好对象
先说结论，这里推荐使用img标签去实现。
script及link的缺陷 因为埋点涉及到请求，因此我们需要保证script和link标签的src可以正常请求。如果需要请求script和link，我们需要将标签挂载到页面上。
验证缺陷 不妨验证下，我们在管理台中加入以下代码：
let a = document.createElement('script') a.src = 'https://lf-headquarters-speed.yhgfb-cn-static.com/obj/rc-client-security/web/stable/1.0.0.28/bdms.js' 创建一个script标签，未挂载中页面上，并不会发起请求
书接上文，当我们将这个标签挂载中页面上时：
document.body.appendChild(a) 这时发起了请求
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b59f45de1ab0999c8e4315c1ea79153/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/057f01e99645b79272d585d2d4def1bf/" rel="bookmark">
			C&#43;&#43;17中if和switch语句的新特性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.从C++17开始，if语句允许在条件表达式里添加一条初始化语句。当仅在if语句范围内需要变量时，使用这种形式的if语句。在if语句的条件表达式里定义的变量将在整个if语句中有效，包括else部分。
std::mutex mx; bool shared_flag = true; // guarded by mx constexpr int get_value() { return 66; } int test_if_init() { std::map&lt;std::string, std::string&gt; addrs{ {"csdn", "https://blog.csdn.net/fengbingchun/"}, {"github", "https://github.com/fengbingchun"} }; if (auto it = addrs.find("github"); it != addrs.end()) std::cout &lt;&lt; "github:" &lt;&lt; it-&gt;second &lt;&lt; "\n"; // github:https://github.com/fengbingchun if (auto it = addrs.find("csdn"); it == addrs.end()) std::cout &lt;&lt; "no find\n"; else // if中的it变量在else分支中也有效 std::cout &lt;&lt; "csdn:" &lt;&lt; it-&gt;second &lt;&lt; "\n"; // csdn:https://blog.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/057f01e99645b79272d585d2d4def1bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9fe8c6193f3051c3105547325e8903a/" rel="bookmark">
			开辟“护眼绿洲”，荣耀何以为师？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文 | 智能相对论
作者 | 佘凯文
俗话说，眼睛是心灵的窗户，可如今，人们对于这扇“窗户”的保护，似乎越来越不重视。
据人民日报今年发布的调查显示，中国眼病患病人数2.1亿，近视患者人数多达6亿，儿童青少年总体近视率为52.7%，其中10%的学生为高度近视。
造成这一情况的原因是多方面的，比如长时间近距离用眼、又比如电子屏幕使用时间过长等等。特别是后者，在如今电脑、手机产品早已成为许多人生活、生产中不可或缺的一环，在无法舍弃不用的前提下，如何才能减少电子屏幕对眼睛的伤害成为当务之急。
近日，数码博主Eva的科技生活发布了一个三方对谈视频，内容正是与荣耀终端有限公司中国区CMO姜海荣、荣耀健康显示专家李工，就当前大众护眼焦虑以及电子屏幕护眼能力必要性进行的一次探讨，而结论当然是“相当有必要”。
当“护眼”重回主战场
其实在很多年前，电子屏幕的护眼话题就曾被热烈讨论过，市场上也一度出现了很多相关产品，比如早在10多年前，明基这个早已退出智能手机和PC生产舞台的品牌，就曾推出过护眼手机、护眼显示器等产品。
但可惜，“护眼”风潮在漫长的智能手机发展历程中就只是那么“昙花一现”，此后市场竞争的主角开始不断变化，从卷续航、到卷影像，从卷性能，再到卷芯片、卷系统，很长一段时间内，“护眼”对于智能手机来说，似乎都成为一件微不足道的小事。
然而事实真如此吗？电子屏幕对于眼睛带来的伤害其实是多方面的，从Eva的视频中我们能了解，“当前用户日均屏幕使用时间已经达到了7小时，电子屏幕是与当下消费者用眼健康关联程度最大的因素之一。不护眼的屏幕，可能会导致眼睛干涩、疲劳、眩晕等不适反应，另外还有可能影响睡眠质量。”
具体来看，就比如电子屏幕最常见的问题“蓝光”，其可以穿透角膜和晶状体，直达视网膜，对视网膜上的感光细胞造成氧化应激和细胞死亡，导致视网膜功能下降，甚至引发黄斑变性等严重的眼底疾病。还有“频闪”也将导致眼睛更容易感到疲劳。
因为这些问题的存在，护眼功能也早已变得不再可有可无。今年，在行业玩家的助推下，护眼风潮再一次在行业上演。仅近段时间，就有荣耀成立荣耀绿洲护眼实验室，并在11月23日推出荣耀100系列首发搭载荣耀绿洲护眼屏；接着 Redmi K70 、一加12和vivo S18系列相继发布，护眼都成为了他们主打的宣传亮点，还有样学样地取名为青山、明眸、朝阳。
很显然，护眼功能再一次重回智能手机竞争的“主战场”，特别是荣耀此次基于“荣耀绿洲护眼实验室”的相关举措，让不少行业人士直言，荣耀正在为行业树立屏幕护眼技术新标杆。
荣耀“绿洲”，何以站到护眼顶点？
为什么荣耀的护眼技术能够获得市场认可，在“智能相对论”看来，或许是因为以下几个方面的原因。
1、提前洞察的布局
首先前面说过，护眼技术长期以来在智能手机领域中都处于“可有可无”的状态，或有品牌一时兴起就拿出来当成一个“添头”。但罗马不是一天建成的，技术积累也不可能一蹴而就。
荣耀之所以领先，就是因为其在护眼领域坚持不懈地长期耕耘。2013年诞生的荣耀，在2016年就成立了“光实验室”，同年便推出了首款支持护眼模式的手机“荣耀V8”，就此拉开荣耀护眼大幕。
2019年荣耀V30实现电子书模式，荣耀30 Pro+成为业界首款支持1440Hz高频PWM调光产品；2021年荣耀50系列支持1920Hz PWM调光；2022年荣耀90系列首发3840Hz PWM调光，引领手机行业进入零风险调光时代。
再到今年，成立“荣耀绿洲护眼实验室”，先后推出荣耀90系列和荣耀100系列，分别造就 3840Hz 的超高频 PWM 调光和实现全天候调光护眼。
这些布局的背后，所展现的出的其实就是荣耀的洞察力。洞察力其实际是对社会现象的观察力，就像护眼需求一直存在，只是如今被放大，更早洞察的荣耀则进行了更有针对性的措施。
比如，在行业其他玩家还在左顾右盼，考虑要不要入局护眼赛道时，荣耀已在过去三年，在护眼技术上投入了10个亿的研发费用，并表示未来还将加大投入。这其实也是荣耀对于智能手机行业发展规律的准确预见。
恰是荣耀的这种提前布局，才使其在技术爆发之时“胸有成竹”，并为之建立起先发优势。
2、将“荒漠”变成“绿洲”的干劲
其次，所谓一步快步步快，先知先觉的布局，在为荣耀收获市场领先的同时，也为荣耀的技术进阶奠定基础。
这就好比是一场对“荒漠”的开发，当其他人还在进行荒漠勘探时，荣耀却已深入无人区并开始着手将无人的荒漠变成绿洲。
回到技术上，护眼是个系统性工程，维度多、难度大。其中就涉及许多技术模块、软硬件协同等等。可见就如荣耀健康显示专家李工所说“荒漠其实是不能在一夜之间变成绿洲的，这需要很多技术的辛勤灌溉。”
这也说明护眼技术的打造其实也是一种“循序渐进”，这便也有了荣耀的第二个优势，即在其他玩家仍只是在“减少”蓝光之时，荣耀对护眼技术进行逐一攻破。
如行业普遍只有1440Hz时，荣耀早已开始3840Hz超高频PWM调光；在行业玩家还在“闭门造车”时，荣耀已通过莱茵TüV全局护眼3.0认证与莱茵TüV无频闪认证，以及通过中标院目前最优的VICO A+视觉舒适测试，收获专业认可；在行业开始跟进荣耀的3840Hz时，荣耀在此基础上又开始进阶，如最新荣耀100系列搭载的“荣耀绿洲护眼屏”，带来的自然色彩显示、360°自适应调光、类自然护眼、助眠显示技术等诸多护眼技术。
而正是这种积累加上干劲，使荣耀才站到了当前护眼技术的顶点。
3、率先踏入无人区的勇气
荣耀的优势还建立在勇于探索无人区的勇气。
在荣耀推出护眼技术后，市场上并非是一片和谐之声，有竞争对手就直言“3840Hz等护眼技术没有必要”。
但意外的是，荣耀没有“打嘴仗”，而是通过发布一系列科普长文的方式，来直面质疑。直接将“骂战”上升到了学术讨论的境界，这也是向市场展现出了荣耀的底气。
而荣耀的这种底气则来自于其在护眼无人区摸索的成果，如以屏幕技术为底座，以人因体验为目标，打造人因化、专业化、标准化的健康显示方向；“荣耀绿洲护眼实验室”的建立则意味着荣耀还将继续保持技术迭代；最后则是在护眼生态打造上，在护眼标准和评价体系建设、眼健康和生物医学、先进屏幕技术、科研与学术单位合作四大领域，荣耀正在携手合作伙伴共同落子健康显示。
能看到，以上很多领域或成果，有且只有荣耀在深入其中，所以在护眼领域或许真的只有荣耀最具发言权。如果将护眼领域比喻成一个封闭多年的无人区，那么当下荣耀定然就是第一个踏入无人区的开路人。
总之，在提前布局、对症下药、勇闯无人区等多因素促使下，荣耀等在护眼技术领域获得认可，并取得领先也就理所当然。
总结
但最令人倾佩的地方还在于，即使获得了术上领先，荣耀并未“积财吝赏”，而是将先进技术拿出来与行业分享，助力行业一起将护眼技术做大做强。特别是在荣耀强推护眼功能后，有质疑的同时，更多地还是获得了许多竞争对手的跟进，而荣耀CEO赵明却公开表示“欢迎跟进”，并呼吁友商加速跟进该项技术，用科技进步造福更多消费者。荣耀的格局可以说是在化身一位不吝赐教的“护眼老师”为行业“补课”，于自身而言则是从“独行者”变成了“领跑者”。
当然此举最受益的还是消费者，毕竟谁不想自己天天面对的手机屏幕，成为一片无害的“绿洲”呢？
*本文图片均来源于网络 #智能相对论 Focusing on智能新产业新服务，这是智能的硬件NO.226深度解读
此内容为【智能相对论】原创，
仅代表个人观点，未经授权，任何人不得以任何方式使用，包括转载、摘编、复制或建立镜像。
部分图片来自网络，且未核实版权归属，不作为商业用途，如有侵犯，请作者与我们联系。
•AI产业新媒体;
•澎湃新闻科技榜单月度top5;
•文章长期“霸占”钛媒体热门文章排行榜TOP10;
•著有《人工智能 十万个为什么》
•【重点关注领域】智能家电（含白电、黑电、智能手机、无人机等AIoT设备）、智能驾驶、AI+医疗、机器人、物联网、AI+金融、AI+教育、AR/VR、云计算、开发者以及背后的芯片、算法等。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dabc2c61e09b74e739d88b96434b3a4f/" rel="bookmark">
			c#可变参数（params）关键字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通过使用 params 关键字，可以指定采用可变数量参数的方法参数。
可以发送参数声明中指定类型的参数的逗号分隔列表，也可以发送指定类型的参数数组。您也可以不发送任何参数。如果未发送任何参数，则参数列表的长度为零。
方法声明中的 params 关键字后不允许有其他参数，方法声明中只允许有一个 params 关键字。
例 下面的示例演示了将参数发送到 params 参数的各种方法。
public class MyClass { public static void UseParams(params int[] list) { for (int i = 0; i &lt; list.Length; i++) { Console.Write(list[i] + " "); } Console.WriteLine(); } public static void UseParams2(params object[] list) { for (int i = 0; i &lt; list.Length; i++) { Console.Write(list[i] + " "); } Console.WriteLine(); } static void Main() { // You can send a comma-separated list of arguments of the // specified type.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dabc2c61e09b74e739d88b96434b3a4f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7305fa66cba1008531219de525fef7e/" rel="bookmark">
			Linux安装MySQL数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习一门数据库，肯定需要从安装开始学起，MySQL数据库常用的安装方式有：
YUM源安装RPM包安装二进制文件安装源码安装 最常用的安装方式是RPM包安装和二进制文件安装。下面我基于Red Hat Enterprise Linux操作系统介绍这两种安装方法。
我个人认为MySQL数据库的安装十分友好，不像Oracle数据库那么困难，这点必须好评。很多同学在学习Oracle数据库时就被安装这个步骤反复折磨，有一部分同学便是因为一只安装不成功，从而放弃了学习Oracle数据库的想法。
一、官网下载RPM包
RPM包的下载地址是：https://dev.mysql.com/downloads/mysql/
根据操作系统类型和版本版本选择需要下载的包，我实验的环境是：
[root@lu9up ~]# cat /etc/redhat-release Red Hat Enterprise Linux Server release 7.9 (Maipo) 选择的RPM包如下，点击下载到本地：
二、上传到操作系统
上传的位置看个人而定
[root@mysql001 ~]# ll | grep mysql -rw-r--r-- 1 root root 1031792640 Dec 15 23:57 mysql-8.0.34-1.el7.x86_64.rpm-bundle.tar 三、检查是否安装MySQL或MariaDB
centos和redhat上一般已经安装有mariadb-libs包和/my.cnf配置文件，安装MySQL数据库前一定要删除，以免和新安装的MySQL造成冲突。
检查默认配置文件是否存在：
[root@mysql001 ~]# ll /etc/my.cnf -rw-r--r--. 1 root root 570 Oct 1 2020 /etc/my.cnf 再检查是否有MySQL或者MariaDB的安装包：
[root@mysql001 ~]# rpm -qa | grep -i mysql [root@mysql001 ~]# rpm -qa | grep -i mariadb mariadb-libs-5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c7305fa66cba1008531219de525fef7e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f7ad62e249cd05e66b9f17893c0db17/" rel="bookmark">
			Python个人代码随笔（观看无益，请跳过）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		异常抛错：一般来说，在程序中，遇到异常时，会从这一层逐层往外抛错，一直抛到最外层，由最外层把错误显示在用户终端。 try: raise ValueError("A value error...") except ValueError: print("ValueError in my code...") 异常清理行为try语句下的可选finally子句：finally子句目的在于定义在任何情况下都一定要执行的功能。一般来说，finally子句用于释放外部资源（文件或网络传输连接之类的），无论它们的使用过程中是否出错。 try: raise ValueError except ValueError: print("a value error...") finally: print("hahahahahahaha") python迭代器（_Iterators_）对象在遵守迭代器协议时需要支持如下两种方法：__iter__()，返回迭代器对象自身。这用在for和in语句中；__next__()，返回迭代器的下一个值。如果没有下一个值可以返回，那么应该抛出StopIteration异常。 class Counter(object): def __init__(self,low,high): self.current = low self.high = high def __iter__(self): return self def __next__(self): # 返回下一个值，直到当前值大于high if self.current &gt; self.high: raise StopIteration else: self.current += 1 return self.current - 1 # 调用上述迭代器 c = Counter(5,10) for i in c: print(i, end=" ") 生成器（Generator）是一种特殊类型的迭代器，它允许在迭代过程中逐步生成值，而不需要一次性生成所有值。通过生成器，可以方便的向程序提供一个可迭代的序列，同时可以节省内存，并允许在需要时延迟生成值。生成器可以通过两种方式定义：1，生成器函数（Generator Function）2，生成器表达式（Generator Expression）生成器函数：生成器函数是一种特殊的函数，它使用yield关键字来产生值。当调用生成器函数时，它返回一个生成器对象，该对象可以用于迭代生成值。 def my_generator(): yield 1 yield 2 yield 3 gen = my_generator() # 调用生成器函数创建一个生成器对象 # 生成器 def generator(): yield 1 yield 2 yield 3 gen = generator() # 调用生成器函数创建一个生成器对象 for item in gen: print(item) # 生成器的简单写法 gen = (i * i for i in range(10)) # 这里用圆括号，方括号是列表 for item in gen: print(item) # 生成器是一种特殊类型的函数，它可以在需要时生成值，而不必一次性生成所有值并将它们存储在内存中。 # 生成器能够延迟产生序列的元素，这样可以减少内存占用并提高效率，特别是在处理大量数据时。 # 生成器 def counter_generator(low, high): while low &lt;= high: yield low low += 1 for i in counter_generator(5,10): print(i, end="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f7ad62e249cd05e66b9f17893c0db17/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/604784901f5f779810b8d52dbce31f36/" rel="bookmark">
			git 不小心操作 reset current branch to here后，怎么还原
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		可以通过reflog来进行恢复，前提是丢失的分支或commit信息没有被git gc清除
一般情况下，gc对那些无用的object会保留很长时间后才清除的
可以使用git reflog show或git log -g命令来看到所有的操作日志
恢复的过程很简单：
通过git log -g命令来找到需要恢复的信息对应的commitid，可以通过提交的时间和日期来辨别,找到执行reset --hard之前的那个commit对应的commitid
通过git branch recover_branch commitid 来建立一个新的分支
这样，就把到commitid为止的代码、各种提交记录等信息都恢复到了recover_branch分支上
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b79305c7a044b01fd379d091bc2718fd/" rel="bookmark">
			2023年我靠这套12W字Java面试题（附答案）横扫大厂offer
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前言 网上的 Java面试题文章有非常多，但是大部分都乱七八糟、内容涵盖不全，让大部分小伙伴耗费了大量时间去寻找资料。
上周有小伙伴私信我，让小编出一套完整的Java面试资料，这不巧了吗，小编今年一直在脉脉、牛客上查看各种Java面试面经，发现其实大部分公司都会问到相同的题目，小编耗时了156小时，总算总结出了这份12W字的Java面试小抄！
内容涵盖了Java基础、JVM、多线程与高并发、spring、mybatis、springboot、mysql、dubbo、springcloud、nginx、MQ、数据结构与算法、linux、zookeeper、Redis、分布式、设计模式等内容。
废话不多说，直接把目录整上来 PS：由于内容比较多，只会展示部分题目细节，有需要的小伙伴可以【直接点击此处】获取完整文档查阅~
Java基础篇（45道） JVM篇（33道） 多线程&amp;并发篇（46道） Spring、SpringBoot、SpringCloud篇 MySQL篇（34道） Dubbo篇（10道） MQ篇（8道） 分布式篇（22道） Redis篇（42道） PS：由于内容实在太多了，还有很多题目没有发出来，需要完整文档的小伙伴一键三连之后后台私【面试】即可获取
详细内容展示 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b07c9e7d0d86dc04bcbdac6c4cc0294c/" rel="bookmark">
			C&#43;&#43;刷题记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++刷题记录
unordered_map 使用key,vector方式可以实现一个键值对应多个值
使用multi_map则可以实现一样的key同时存在
C++多继承二义性是指多个基类继承，调用基类同名函数时，会产生歧义
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5834cf205d4d5b20ef5958311d121a99/" rel="bookmark">
			RK3568平台（网络篇）添加网络交换芯片RTL8306M
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.硬件原理图 分析：
该交换芯片支持I2C、SPI、mdio通信，但是看ast1520的uboot代码采用的是mdio去通信phy芯片的，所以暂时也先采用mdio的方式，需要配置相应的引脚才可以配置成mdio通信模式，具体的配置硬件工程师解决。
背景：
RTL8306M芯片上可能没有提供MDC/MDIO接口，可以通过GPIO（General Purpose Input/Output）来模拟，GPIO可实现串行输入输出，且一般CPU上会提供很多GPIO接口供用户自定义使用。每组SMI需要两个GPIO口分别来模拟MDC和MDIO，首先需要保证这两个GPIO口不作其他用途，且相应的复用模式设置为GPIO模式。
二.SMI[MDC/MDIO]协议 SMI：串行管理接口（Serial Management Interface），通常直接被称为MDIO接口（Management Data Input/Output Interface）。MDIO最早在IEEE 802.3的第22卷定义，后来在第45卷又定义了增强版本的MDIO，其主要被应用于以太网的MAC和PHY层之间，用于MAC层器件通过读写寄存器来实现对PHY层器件的操作与管理。
MDIO接口包括两条线，MDIO和MDC，其中MDIO是双向数据线，而MDC是由STA驱动的时钟线。MDC时钟的最高速率一般为2.5MHz，MDC也可以是非固定频率，甚至可以是非周期的。MDIO接口只是会在MDC时钟的上升沿进行采样，而并不在意MDC时钟的频率（类似于I2C接口）。MDIO是一个PHY的管理接口，用来读/写PHY的寄存器，以控制PHY的行为或获取PHY的状态，MDC为MDIO提供时钟。
MAC读取PHY的寄存器:
MAC向PHY的寄存器写入数据:
三.代码实现 原厂提供了芯片RTL8306M的读写逻辑，需要自己实现gpio模拟MDC/MDIO和驱动入口。
Kconfig：
config RTL8309 tristate "RTL8309 driver" default m help Enable this driver will support network switch control Makefile：
# SPDX-License-Identifier: GPL-2.0-only # # Makefile for the Realtek network device drivers. # obj-$(CONFIG_RTL8309)	+= rtl8309.o rtl8309-objs := rtl8309_main.o mdcmdio.o rtk_api.o rtl8309n_asicdrv. DTS配置：
rtl_8309: rtl-8309{ status ="okay"; compatible = "rtl8309"; pinctrl-names = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5834cf205d4d5b20ef5958311d121a99/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ffed215a89c4e680547c5872e8f5521a/" rel="bookmark">
			IO多路复用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基本Socket模型 跨主机进程间通信
双方要进行通信之前，两边都需要创建一个Socket，发送和接收数据都是通过这个Socket。
Sock连接步骤 服务端 服务端首先调用socket()函数，创建一个网路协议为IPv4、传输层协议为TCP的Socket调用bind()函数，绑定服务的IP和端口调用listen()函数，进入监听状态，对应TCP状态图中的listen服务端进入监听状态之后，通过调用accept()函数从内核获取客户端的连接，如果没有客户端的连接请求，则阻塞等待；当服务端的TCP全连接队列不为空的时候，accept()就会从该队列中拿出一个已经完成连接的Socket到应用程序，后续的数据传输都是通过该Socket 客户端 客户端通过connect()函数发起连接，调用函数时会指定服务端的IP和端口 在一个TCP连接的过程中，服务器的内核为每个Socket维护两个队列：
TCP半连接队列：这个队列里都是还没有完成三次握手的客户端连接，此时服务端的状态是syn_rcvdTCP全连接队列：这个队列里是完成了三次握手的客户端连接，此时服务端的状态是established 监听的Socket和用来数据传输的Socket是两个不同的Socket
一个是监听Socket一个是已连接的Socket 多进程Socket模型 服务器的主进程监听客户端的连接，一旦客户端连接完成，accept()函数就会返回一个已连接的Socket，通过fork()函数创建一个子进程，子进程通过这个已连接的Socket进行数据传输。
主进程只需要关注监听Socket，不需要关注已连接的Socket子进程只需要关注已连接的Socket，不需要关注监听Socket 也可以将进程操作修改为多线程的操作
IO多路复用 一个进程维护多个Socket
多路复用API返回的事件并不一定是可读写的，比如当数据到达后，但经检查后发现有错误的校验和被丢弃时，就会导致后续的读取块缺失，这种情况下如果使用阻塞IO，那么在调用read/write时就会发生程序阻塞，所以多路复用最好是跟非阻塞IO搭配使用
一个进程虽然任意一个时刻只能处理一个请求，但是如果处理一个请求事件的耗时控制在1毫秒，那么1秒也可以处理上千个请求了。
进程可以通过一个系统调用函数从内核中获取多个事件
select/poll select实现多路复用的方式：
将所有已连接的Socket都放在一个文件描述符集合调用select()函数将文件描述符集合拷贝到内核中内核中通过遍历的方式来检查是否有网络事件发生，即遍历文件描述符集合，当检查到有事件发生之后，将对应的Socket的标记为可读或可写将文件描述符集合拷贝回到用户态，用户态还需要通过遍历的方法找到可读或者可写的Socket，然后再对其进行处理 在select的多路复用的实现方式中，需要进行两次的文件描述符的遍历，一次在内核中进行遍历，检查是否由对应的事件发生，一次在用户态中进行遍历，找到需要处理的Socket；同时需要进行两次文件描述符的拷贝，一次是将其拷贝到内核空间，在内核空间处理好之后还需要拷贝回到用户态。
select使用固定长度的BitsMap来表示文件描述符集合，所支持的个数是有限制的，默认最大值是1024。
poll改变了select中的BitsMap来表示文件描述符集合，采用链表的形式来组织，突破了select的文件描述符的个数限制，但仍然会受到系统文件描述符的限制。
从本质上来说，select和poll都是使用线性结构存储进程关注的Socket集合，因此都需要通过遍历文件描述符来找到可读或者可写的Socket，时间复杂度是O(N)，而且也需要在用户态和内核态之间拷贝文件描述符集合
epoll epoll在内核中使用红黑树来跟踪进程所有待检测的文件描述字，把需要监控的Socket通过epoll_ctl()函数添加到内核中的红黑树中。epoll通过在内核中维护的红黑树，保存了所有待检测的Socket，所以每次只需要传入一个待检测的Socket，减少了内核和用户态之间大量的数据拷贝和内存分配epoll使用事件驱动的机制，在内核中维护了一个链表来记录就绪的事件，当某个Socket有事件发生时，通过回调函数内核会将其加入到这个链表中，当用户调用epoll_wait()函数时，只会返回有事件发生的文件描述符的个数，不需要轮询扫描整个Socket集合 事件触发模式 epoll支持两种事件触发模式，分别是边缘触发（edge-triggered, ET）和水平触发（level-triggered, LT）
select/poll只有水平触发模式，epoll默认也是水平触发模式，但是可以通过配置修改为边缘触发
边缘触发模式：当被监控的Socket描述符上有可读事件发生时，服务器端只会从epoll_wait中苏醒一次，即使进程没有调用read函数从内核读取数据，也依然只苏醒一次，因此我们程序要保证一次性将内核缓冲区的数据读取完水平触发模式：当被监控的Socket描述符上有可读事件发生时，服务器端不断地从epoll_wait中苏醒，直到内核缓冲区的数据被read函数读完才结束，目的是告诉我们有数据需要读取 当一个事件发生之后，在边缘触发模式下，只会触发一次，无论事件是否被处理，相同的事件不会再被传递；在水平触发模式下，如果事件没有被处理，那么就还会继续被触发
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c26fc8035a378bc42271debeea134971/" rel="bookmark">
			Truffle的基础语法与js测试语法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 每一个it测试函数里面的内容都是独立的
truffle编译 truffle compile truffle部署 truffle migrate truffle测试 使用test文件夹下的所有文件测试 truffle test 使用单个文件 测试 truffle test 文件所在位置 assert断言 assert.equal 是一种常见的断言函数，用于测试两个值是否相等。它接受两个参数：实际的值和期望的值。如果这两个值相等，断言通过；否则，会抛出一个错误，错误信息可以不写。
需要引入
const {assert} = require("chai") assert.equal('值1','值2','错误信息') 在以太坊区块链上部署新的智能合约的操作。 await同步关键字表示等待该操作完成。
变量名 = await 加载合约的变量名.new(); 用于将以太币数量转换为单位(ether、Wei) web3.utils.toWei('数量','单位') 转账(向合约里打钱) await 合约实例变量名.合约函数({ from:账户, value:转账数量, }); js的值转换为数字 变量.toNumber() 钩子函数 beforeEach(async () =&gt; { //代码 }); 加载智能合约 artifacts.require("合约名"); 测试套件 contract('定义名', async accounts =&gt;{ }) 检查余额 web3.eth.getBalance(地址); 测试函数 it("显示的名称",async()=&gt;{ //测试代码 }); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae371c4ba933db45c2fbbc99a4ce6bae/" rel="bookmark">
			Linux文件管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、文件命名规则
1、可以使用那些字符？
除了字符“/”之外，所有的字符都可以使用，但是要注意，在目录或文件名中，不建议使用 某些特殊字符，例如，&lt;、&gt;、？、*等尽量避免使用。
如果一个文件名中包括特殊字符，例如空格，那么在访问这个文件时就需要使用引号将文件名括起来。
建议文件命名规则：
由于Linux严格区分大小写，所以尽量都用小写字母
如果必须对文件名进行分割，建议使用"_",例如：itheima_bj_2020.logwe
二：Linux下文件管理
1.目录创建/删除
语法： mkdir 目录名称
主要功能：就是根据目录的名称创建一个目录
mkdir -p 递归创建目录
语法 mkdir -p /usr/local/nginx/conf
-p:递归，从左边路径开始一层一层地创建，直到路径结束
mkdir 可以创建多个目录
mkdir 目录1 目录2 目录3
扩展：linux快捷键（方向键上下）
2.
2、目录删除（必须是空目录）
基本语法：
rmdir 目录名称
rmdir ithe
rmdir -p 递归删除空目录
可以同时删除多个空目录
rmdir-p /目录1/目录2/目录3
功能：从右到左一级一级删除空目录
3、文件创建
命令：touch
语法：touch 文件名称
主要功能：在Linux系统中的当前目录下创建一个文件
2，
2使用touch命令同时创建多个文件
语法：touch 文件名称1 文件名称2 文件名称3 根据序号同时创建多个文件
touch 文件名称 {开始序号...结束序号}
含义：根据提供3=的开始序号~结束序号，一个一个创建文件
4.文件删除
语法：rm 文件或文件夹的名称
-r:针对文件夹，代表递归，先把目录下的所有文件删除
-f:强制删除，不提示，慎重！！
删除非空的文件夹
rm -rf shop，强制删除
扩展：Ctrl+c不是复制，而是中断某个操作
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae371c4ba933db45c2fbbc99a4ce6bae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/532fe86848c5da5bccaa0757e77fbc19/" rel="bookmark">
			uniapp的form表单自定义验证规则
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		template部分： &lt;uni-forms ref="form" :value="user" labelWidth="80px"&gt; &lt;uni-forms-item name="oldPassword" label="旧密码"&gt; &lt;uni-easyinput type="password" v-model="user.oldPassword" placeholder="请输入旧密码" /&gt; &lt;/uni-forms-item&gt; &lt;uni-forms-item name="newPassword" label="新密码"&gt; &lt;uni-easyinput type="password" v-model="user.newPassword" placeholder="请输入新密码" /&gt; &lt;/uni-forms-item&gt; &lt;uni-forms-item name="confirmPassword" label="确认密码"&gt; &lt;uni-easyinput type="password" v-model="user.confirmPassword" placeholder="请确认新密码" /&gt; &lt;/uni-forms-item&gt; &lt;button type="primary" @click="submit"&gt;提交&lt;/button&gt; &lt;/uni-forms&gt; data部分： user: { oldPassword: undefined, newPassword: undefined, confirmPassword: undefined }, rules: { oldPassword: { rules: [{ required: true, errorMessage: '旧密码不能为空' }] }, newPassword: { rules: [{ required: true, errorMessage: '新密码不能为空', }, { minLength: 6, maxLength: 20, errorMessage: '长度在 6 到 20 个字符' } ] }, confirmPassword: { rules: [{ required: true, errorMessage: '确认密码不能为空' }, { validateFunction: (rule, value, data) =&gt; data.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/532fe86848c5da5bccaa0757e77fbc19/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7881bcd17ce3e689f3187588073f9002/" rel="bookmark">
			骑砍战团MOD开发(15)-大地图火与剑军团
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		骑砍1战团mod开发-大地图火与剑军团_哔哩哔哩_bilibili
一.大地图触发器
(0.0, 0, 0.1, [(key_is_down,key_numpad_4)],[ (assign, "$is_p_guard_spawn", 1), (try_for_range, ":index", 0, 20), (spawn_around_party, "p_main_party", "pt_kingdom_1_reinforcements_a"), (party_set_icon, reg0, "icon_gray_knight"), (party_set_name, reg0, "@god"), (party_set_extra_text, reg0, "@i am big"), (party_set_slot, reg0, slot_party_type, 8), (try_end), (call_script, "script_sword_party_forword"), ]), (0.0, 0, 0, [(eq, "$is_p_guard_spawn", 1)],[ (call_script, "script_sword_party_forword"), ]), (0, 0, ti_once, [], [ (set_global_cloud_amount, 0), (set_global_haze_amount, 0), ]), 二.火与剑军团生成
# sword_party_forword # Input: none # Output: none ("sword_party_forword", [ (init_position, pos1), (init_position, pos2), (party_get_position, pos1, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7881bcd17ce3e689f3187588073f9002/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a825b5e1eca35e9cb65bc16b56f3266a/" rel="bookmark">
			Unity 使用AddForce方法给刚体施加力详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要给刚体施加力，我们可以用AddForce方法，它有4个重载方法：
1、AddForce(Vector3 force)；使用Vector3类型参数，可以分别向刚体按Vector3对象指定x、y、z分量施加力。使用该方法会对刚体施加一个持续的力。
Rigidbody rb; Vector3 force = new Vector3(10f, 0f, 0f); rb.AddForce(force); 2、AddForce(float x, float y, float z)；使用3个float类型参数，x、y、z分别指施加于x、y、z轴上的分量。使用该方法会对刚体施加一个持续的力。
Rigidbody rb; float xForce = 10f; float yForce = 0f; float zForce = 0f; rb.AddForce(xForce, yForce, zForce); 事实上上面两个方法是等效的。只是使用参数类型不一样。
3、AddForce(Vector3 force, ForceMode mode)；其中，参数force是施加的力的矢量，参数mode是一个枚举类型的参数，用于指定力的模式。模式有：
ForceMode.Force：施加一个持续的力，受质量mass影响。ForceMode.Impulse：施加一个瞬间的冲击力，受质量mass影响。ForceMode.Acceleration：施加一个持续的加速度，质量mass无影响。ForceMode.VelocityChange：施加一个改变刚体速度的力，质量mass无影响。 Rigidbody rb; void Start() { Vector3 force = new Vector3(0f, 5f, 0f); rb.AddForce(force, ForceMode.Impulse);//给刚体施加一个瞬间冲击力 } 4、AddForce(float x, float y, float z, ForceMode mode)；其中，参数，x、y、z分别指施加于x、y、z轴上的分量。参数mode是一个枚举类型的参数，用于指定力的模式，模式有：
ForceMode.Force：施加一个持续的力，受质量mass影响。ForceMode.Impulse：施加一个瞬间的冲击力，受质量mass影响。ForceMode.Acceleration：施加一个持续的加速度，质量mass无影响。ForceMode.VelocityChange：施加一个改变刚体速度的力，质量mass无影响。 Rigidbody rb; void Start() { float xForce = 0f; float yForce = 0f; float zForce = 20f; rb.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a825b5e1eca35e9cb65bc16b56f3266a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/369259a1ecf6c3ec2ed52bbcfec4436f/" rel="bookmark">
			鸿蒙原生应用再添新丁！网易游戏入局鸿蒙
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		鸿蒙原生应用再添新丁！网易游戏入局鸿蒙
来自 @HarmonyOS 微博12月15日消息，网易游戏与华为达成鸿蒙合作，作为“游戏热爱者”的 @网易游戏 将基于#HarmonyOS NEXT#启动#鸿蒙原生应用#开发，为玩家带来更多元的交互玩法和更创新的游戏体验。#鸿蒙千帆起#
#HarmonyOS#市场或迎来爆发式增！​​​
更多 HarmonyOS 参考资料 学习鸿蒙正当时！以下是一些学习资料，可以作为参考：
《跟老卫学 HarmonyOS 开发》 开源免费教程：GitHub - waylau/harmonyos-tutorial: HarmonyOS Tutorial. 《跟老卫学HarmonyOS开发》
《鸿蒙 HarmonyOS 手机应用开发实战》（清华大学出版社）：713页鸿蒙巨作！《鸿蒙HarmonyOS手机应用开发实战》简介 | 老卫（柳伟卫）的博客 - 关注编程、系统架构、性能优化 | waylau.com
《鸿蒙 HarmonyOS 应用开发从入门到精通战》（北京大学出版社）：GitHub - waylau/harmonyos-tutorial: HarmonyOS Tutorial. 《跟老卫学HarmonyOS开发》
“鸿蒙系统实战短视频 App 从 0 到 1 掌握 HarmonyOS” ：鸿蒙系统实战短视频App 从0到1掌握HarmonyOS_实战课程_慕课网
《鸿蒙HarmonyOS应用开发入门》（清华大学出版社）：轻松掌握ArkTS！鸿蒙新作《鸿蒙HarmonyOS应用开发入门》简介 | 老卫（柳伟卫）的博客 - 关注编程、系统架构、性能优化 | waylau.com
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93c76f4183dc3bfc3777206c43cdf432/" rel="bookmark">
			Elaticsearch 学习笔记（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Elaticsearch 学习笔记（一）一、什么是 Elaticsearch ？二、Elaticsearch 安装1 es 安装2 问题解决3 数据格式 三、索引操作1 PUT 请求：在postman中，向 ES 服务器发 PUT 请求（PUT请求相当于创建的意思）2 GET 请求：GET 请求是获取的意思，获取指定的索引3 GET 请求获取全部索引4 DELETE：删除索引 四、文档操作1 POST请求创建文档2 GET请求查询文档3 GET请求条件查询4 GET请求分页查询5 GET请求查询后排序6 GET多条件查询7 GET范围查询8 PUT请求修改文档-全部覆盖：在请求体内贴入需修改的数据9 DELETE请求删除文档10 全文检索与部分检索：match_phrase &amp; match11 检索结果高亮显示12 聚合查询-平均值 五、Java API 操作1 创建maven项目，添加依赖2 索引创建3 索引查看4 索引删除5 向索引新增元素6 在索引中修改元素7 在索引中查看元素8 在索引中删除元素9 在索引中批量新增元素10 在索引中批量删除元素11 高级查询-全量查询：QueryBuilders.matchAllQuery()12 高级查询-条件查询：QueryBuilders.termQuery()13 高级查询-分页查询:builder.from(x)；builder.size(y)14 高级查询-查询排序：builder.sort()15 高级查询-排除/包含字段：builder.sort()16 高级查询-组合查询1 组合查询-类似于and2 组合查询-类似于or3 组合查询-范围查询 17 高级查询-模糊查询 六、es 集群搭建1 windows集群2 linux集群 七、es 进阶1 核心概念1.1 索引（Index）1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/93c76f4183dc3bfc3777206c43cdf432/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d028a1435a8a18f0a68323d587383ba2/" rel="bookmark">
			Unity中URP Shader 的 SRP Batcher
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、SRP Batcher是什么二、SRP Batcher的使用条件1、可编程渲染管线2、我们用URP作为例子3、URP 设置中 Use SRP Batcher开启4、使 SRP Batcher 代码路径能够渲染对象5、使着色器与 SRP Batcher 兼容： 三、不同合批之间的区别BuildIn Render Pipeline下：Universal Render Pipeline下： 四、对比 BRP 和 SRP 每一批次渲染间的区别1、BRP下2、SRP下（CPU部分就是SRP的核心）在这里插入图片描述 五、在Unity中，测试一下开启 和 不开启 SRP Batcher的效果1、不开启 SRP Batcher（需要关闭HDR）2、开启SRP Batcher 前言 在上一篇文章中，我们知道了使用了常量寄存器CBUFFER才可以被允许SRP Betcher。
Unity中 URP Shader 常量缓冲区CBUFFER 我们在这篇文章中，了解一下SRP Batcher是什么。
一、SRP Batcher是什么 SRP Batcher 是一个渲染循环，可通过许多使用同一着色器变体的材质来加快场景中的 CPU 渲染速度。
Unity帮助文档
二、SRP Batcher的使用条件 1、可编程渲染管线 URPHDRP自定义 SRP 2、我们用URP作为例子 保证项目使用了URP
3、URP 设置中 Use SRP Batcher开启 打开Inspect面板的Debug模式
确保 Use SRP Batcher 开启
4、使 SRP Batcher 代码路径能够渲染对象 渲染的对象必须是网格或蒙皮网格。该对象不能是粒子。着色器必须与 SRP Batcher 兼容。HDRP 和 URP 中的所有光照和无光照着色器均符合此要求（这些着色器的“粒子”版本除外）。渲染对象不得使用 MaterialPropertyBlocks。 5、使着色器与 SRP Batcher 兼容： 必须在一个名为“UnityPerDraw”的 CBUFFER 中声明所有内置引擎属性。例如：unity_ObjectToWorld 或 unity_SHAr。必须在一个名为 UnityPerMaterial 的 CBUFFER 中声明所有材质属性。即上篇文章的常量缓冲区 CBUFFER_START(UnityPerMaterial)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d028a1435a8a18f0a68323d587383ba2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2215f129a74f151b6f879dd605ec1fb/" rel="bookmark">
			深度图优化之ThreadDepthCleaner
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		github地址：ThreadedDepthCleaner
按github上的说明配置环境：
git clone https://github.com/juniorxsound/ThreadedDepthCleaner --recursive mkdir build &amp;&amp; cd build &amp;&amp; cmake ../ &amp;&amp; make -j4 这一步容易出现undefined reference to symbol ‘dlclose@@GLIBC_2.2.5‘
和undefined reference to symbol ‘pthread_create‘报错，
解决方法见：
undefined reference to symbol dlclose
undefined reference to symbol ‘pthread_create‘
github中的main.cpp是直接连接realsense相机的，这里没有用相机，直接优化深度图，
所以要改一下代码，最后cleanedDepth就是优化后的深度图。
Mat rawDepthMat = imread("depth.png", cv::IMREAD_UNCHANGED); const int w = rawDepthMat.cols; const int h = rawDepthMat.rows; // Create an openCV matrix for the DepthCleaner instance to write the output to Mat cleanedDepth(Size(w, h), CV_16U); //Run the RGBD depth cleaner instance depthc-&gt;operator()(rawDepthMat, cleanedDepth); //补空洞 const unsigned char noDepth = 0; // change to 255, if values no depth uses max value Mat temp, temp2; // Downsize for performance, use a smaller version of depth image (defined in the SCALE_FACTOR macro) Mat small_depthf; resize(cleanedDepth, small_depthf, Size(), SCALE_FACTOR, SCALE_FACTOR); // Inpaint only the masked "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a2215f129a74f151b6f879dd605ec1fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e88718195bc17f5aba36ea5983c1ce1e/" rel="bookmark">
			如何使用ArcGIS Pro拼接影像
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为了方便数据的存储和传输，我们在网上获取到的影像一般都是分块的，正式使用之前需要对这些影像进行拼接，这里为大家介绍一下ArcGIS Pro中拼接影像的方法，希望能对你有所帮助。
数据来源 本教程所使用的数据是从水经微图中下载的影像数据，除了影像数据，常见的GIS数据都可以从水经微图中下载。
水经微图
直接拼接 在工具箱中点击“数据管理工具\栅格\栅格数据集\镶嵌至新栅格”，调用镶嵌至新栅格工具，如下图所示。
调用镶嵌至新栅格工具
在显示的镶嵌至新栅格对话框内，输入栅格为需要拼接的栅格图，设置输出位置，具有扩展名的栅格数据集名称为输出栅格的名字（记得加上后缀.tif），像素类型选择8位无符号，波段数设置为3，如下图所示。 镶嵌至新栅格设置
点击运行完成栅格的拼接，如下图所示。
拼接后影像
镶嵌数据集 从上面的拼接结果中我们发现有黑边，可以通过背景透明或者直接裁剪等方式去掉，也可以在拼接的时候采取添加栅格至镶嵌数据集的方式处理。
在工具箱中点击“数据管理工具\栅格\镶嵌数据集\创建镶嵌数据集”，调用创建镶嵌数据集工具，如下图所示。
调用创建镶嵌数据集工具
在显示的创建镶嵌数据集对话框内，设置输出位置、镶嵌数据集名称和坐标系，如下图所示。 创建镶嵌数据集设置
在工具箱中点击“数据管理工具\栅格\镶嵌数据集\添加栅格至镶嵌数据集”，调用添加栅格至镶嵌数据集工具，如下图所示。
调用添加栅格至镶嵌数据集工具
在显示的添加栅格至镶嵌数据集对话框内，镶嵌数据集为上一步生成的镶嵌数据集，栅格类型选择Raster Dataset，输入数据选择数据集，下面选择上需要拼接的栅格，如下图所示。 添加栅格至镶嵌数据集设置
在工具箱中点击“数据管理工具\栅格\镶嵌数据集\构建轮廓线”，调用构建轮廓线工具，如下图所示。
调用构建轮廓线工具
在显示的构建轮廓线对话框内，镶嵌数据集选择之前新建的镶嵌数据集，其余的默认，如下图所示。
构建轮廓线设置
在影像图层上右键，选择“数据\导出栅格”，如下图所示。
选择导出栅格
在显示的导出栅格对话框内，设置输出栅格数据集，NoData值设置为0，如下图所示。
导出栅格设置
最后导出的栅格如下图所示。
导出的栅格
结语 以上就是如何使用ArcGIS Pro拼接影像的详细说明，主要包括了数据来源、直接拼接和镶嵌数据集等功能。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c3363dfbe9404b004a56ceb76b9ef85/" rel="bookmark">
			使用OpenCV和PIL库读取图片的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OpenCV 和 PIL（Pillow）是两个不同的图像处理库，它们使用不同的数据结构来表示图像。
OpenCV 格式图像：
OpenCV 中的图像通常表示为 NumPy 数组。这些数组可以是多维的，例如对于彩色图像，它们是三维数组，其中包含行、列和通道。OpenCV 默认使用 BGR（蓝、绿、红）通道顺序排列图像数据。例如，对于一个彩色图像，它可以被表示为一个形状为 (height, width, 3) 的 NumPy 数组，分别对应图像的高度、宽度和通道数（红、绿、蓝）。
PIL 格式图像：
PIL（Pillow）库中的图像是 Image 对象，它提供了一系列方法和属性来处理图像。PIL 图像对象也可以从文件中加载，然后在 Python 中进行操作。PIL 使用 RGB（红、绿、蓝）通道顺序排列图像数据。
一张原始的图片通常不是特定于任何库的格式。图片的原始表示通常是存储在磁盘上的未经过解码或解析的二进制数据。当我们使用某个库（比如 OpenCV 或 PIL）加载图像时，这个图像会被解码并转换为相应库支持的格式，然后我们可以在代码中进行处理、显示或者保存。
代码如下：
使用OpenCV库：
import cv2 # 读取图像 image_path = 'your_image_path.jpg' # 替换成你的图片路径 image = cv2.imread(image_path) # 获取图像的像素值大小 height, width, channels = image.shape print(f"图像宽度为：{width} 像素") print(f"图像高度为：{height} 像素") 使用PIL库：
import cv2 # 读取图像 from PIL import Image # 打开图像 image_path = 'your_image_path.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c3363dfbe9404b004a56ceb76b9ef85/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7b591dc55fae072089d858512497e38/" rel="bookmark">
			速学数据结构 | 树 森林 二叉树 的概念详讲篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🎬 鸽芷咕：个人主页 🔥 个人专栏:《速学数据结构》 《C语言进阶篇》 ⛺️生活的理想，就是为了理想的生活! 📋 前言 🌈hello！ 各位宝子们大家好啊，关于线性表我们已经在前面更新完了！
⛳️今天就来看一下复杂一些的数据结构 “树” 他的应用主要在哪些方面呢？以及结构是什么样的
📚本期文章收录在《数据结构&amp;算法》，大家有兴趣可以看看呐！
⛺️ 欢迎铁汁们 ✔️ 点赞 👍 收藏 ⭐留言 📝！
文章目录 📋 前言一、什么是树？1.1 树的注意事项1.2 树的相关概念1.3 树的应用场景有那些 二 、二叉树的概念详讲2.1 特殊的二叉树满二叉树完全二叉树 2.2 二叉树的性质 三、二叉树的两种实现方法3.1 顺序存储实现二叉树3.2 .链式结构的二叉树实现 一、什么是树？ 树是一种非线性的数据结构，它是由n（n&gt;=0）个有限结点组成一个具有层次关系的集合。把它叫做树是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。
所以他有一个根节点，根结点没有前驱结点。又因为树的节点除了根节点 外，还有很多子节点而子节点又有很多子节点所以树是由 递归创建 的 可能大家还不是很了解但大家看上面这张图，左边是一棵树，右边就是我们的 多叉树数据结构了；
由树的根节点，加孩子节点。而孩子节点又有很多孩子节点组成的！所以我们说树是由递归创建的，他们每个部分都是相同的结构 1.1 树的注意事项 注意：树形结构中，子树之间不能有交集，否则就不是树形结构
大家在做选择题的时候一定要注意了 1.2 树的相关概念 前面我们说了树是由 一个根节点加很多 子孙节点 组成的，那么他们相应的叫法是什么呢？
结点的度：一个结点含有的子树的个数称为该结点的度； 如上图：A的为6
🔥 叶结点或终端结点：度为0的结点称为叶结点； 如上图：B、C、H、I…等结点为叶结点
🔥 非终端结点或分支结点：度不为0的结点； 如上图：D、E、F、G…等结点为分支结点
🔥 双亲结点或父结点：若一个结点含有子结点，则这个结点称为其子结点的父结点； 如上图：A是B的父结点
🔥 孩子结点或子结点：一个结点含有的子树的根结点称为该结点的子结点； 如上图：B是A的孩子结点
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c7b591dc55fae072089d858512497e38/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11760dc739fc6fd2546d4a138635e63f/" rel="bookmark">
			阿里云-虚拟主机退订
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		退订说明：
https://help.aliyun.com/zh/cloud-web-hosting/product-overview/refund-instructions#section-bou-yhd-exp
进入菜单：
https://usercenter2.aliyun.com/refund/refund
注：
1、退款只能到余额
2、已开票的款项，会产生欠票金额，下次开票会先冲抵。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4c21437080b0e0c9abaa095cc27fd45/" rel="bookmark">
			Android 14 应用适配指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android 14 应用适配指南：https://dev.mi.com/distribute/doc/details?pId=1718
Android 14 功能和变更列表 | Android 开发者 | Android Developers
1.获取Android 14 1.1 谷歌发布时间表 https://developer.android.com/about/versions/14/overview#timeline
1.2 小米手机升级Android 14
现在Xiaomi 13、Xiaomi 13 Pro、Xiaomi Pad 6 可通过链接，线刷基于Android™ 14 Beta 1的MIUI 14开发者预览版。
https://web.vip.miui.com/page/info/mio/mio/detail?postId=40403123&amp;fromPathname=mioSingleBoard&amp;app_version=dev.230112
如您暂未拥有上述设备也没关系，我们为您提供了足量的云测设备，来支持广大开发者的适配工作，云测平台详见：https://testit.miui.com/android_14 （云测平台使用权限申请：https://m.beehive.miui.com/Ooq42P35TPAIP-sZJT1EqA）
1.3 Google原生机升级Android 14 开发者持有Pixel系列的机器可以直接ota升级，或者下载镜像升级，具体见链接：
https://developer.android.google.cn/about/versions/14/download
1.4 Android模拟器 在Android Studio中，可按照如下方式安装Android 14 SDK：
依次点击Tools&gt;SDK Manager。在“SDK Plateforms”标签页中，选择Android 14。在“SDK Tools”标签页中，选择Android SDK Build-Tools 34。 点击OK，安装SDK。
如需访问 Android 14 API 并测试您的应用与 Android 14 的兼容性，请打开模块级build.gradle或build.gradle.kts文件，并使用 Android 14所对应的值对它们进行更新：如何设置这些值的格式取决于您所使用的 Android Gradle 插件 (AGP) 版本。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4c21437080b0e0c9abaa095cc27fd45/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/495a23b7ed780bd23c42bb8136357493/" rel="bookmark">
			store-sales-time-series-forecasting
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先题意为预测未来三年中的每一天中的每一家超市中的每一个商品的销售价值
目前我的思路是：
因为本道题目涉及多种特征，并且有着明确的时间线，并且题意也表示，这是一道时间预测的题目，那么对于该道题目我考虑使用LSTM模型求解，又因为预测的时候是有多种商品，那么对于多种商品，我考虑分层，对于每一个超市的每一个商品，我就把他们拿出来，单独做一次LSTM模型预测，通过观察数据可知，其实总共的数量并不大，是可以接受的
有了这样的思路之后，目前就要分点完成任务，如对于数据先进行预处理，首先，每日油价可以进行预处理，对于缺失值进行补全，这个我已经完成，那么接下来我想做的是，首先，对于节假日我要进行处理，我就只算个大概，应为数据可以观察到，同一天里面会出现多个节日，对于节日还分了地区，这就要好好处理了，处理到最后面我希望得到的是，对于train.csv和test.csv的两张表，我希望得到他们是否在那一天有节日，是就是1，否则就说0，这里就直接模糊处理了
这样的话，我就认为初步的对于数据就处理完成了，我就可以得到一个train.csv表和test.csv表，之后我就开始对于每一个超市的每一种商品进行分层处理，目前就看一下能不能找到一个东西来实现这个想法，将这个想法实现之后，差不多就可以得到预测答案了
现在接着写，对于每日油价的开始位置为空，用什么方法填充，因为我用的是向前填充，明显第一个是没有前的，所以我先做一遍向前，在做一遍向后，就可以合理的做出每日油价，做出来之后，我就把每日油价给添加到我的train.csv里面，添加之后，我就开始考虑每个超市每一天的营业额，因为每天的当前超市的某件商品的营业额，我认为是应该和超市自己本身的营业额相关的，我就把营业额那张表给对应的加到train.csv里面去，然后可以发现，是有缺失值的，对于缺失值的处理，我们可以直接把当前超市的这几年的营业额先用excel来做张图，可以发现，图像其实价格都是在一个区间内浮动，所以我直接考虑了使用当前超市的整个平均值来填充我当前超市这一天的缺失值，这样就可以很好的处理了。
目前为止，除了test.csv没有用外，其实就还差一张节假日表没用，对于节假日，无非两个信息，节假日的时间，节假日的地点，注意，train.csv里面是没有城市的，但是有一张商店表里面有这个超市位于什么地区，我就把这个超市的地区，我就先给他加上去，加上去之后，我就对于这张表和节假日表进行合并以下，如果当前时间和地区在节假日表里面，就说明是节日，否则就不是节日，这样就新加了一列。现在没有提到的列都是我认为没有什么用的列，所以就不管他了。
最后一步的数据处理时间特别长，要注意一下
那么对于现在，我们其实已经把所有信息都给集中在了这一张表上了，对于test.csv到后面在处理，先把模型训练出来再说，
那么我们就应该针对这样一张表来进行预测了，output只有一个，也就是商品的销售额，然后其他的变量其实都可以做为特征来处理
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf902a191ab582651961b2f47d2a12d3/" rel="bookmark">
			JavaScript 对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 对象1.1 对象基本概念1.2 对象作用域 2. this引用2.1 一般情况2.2 强制转换对象引用(call) 1. 对象 1.1 对象基本概念 a. 对象属性
对象也是变量，内部可以包含多个变量(name: value), 对象就是相当于是属性与方法的容器.对象属性访问有两种方法
a. 对象.属性名 -&gt; Object.name
b. 对象[“属性名字”] -&gt; Object[“name”] // 对象创建, 注意属性之间需要逗号隔开 var student = { name: "学生A", age: 12, hobby: "篮球" }; console.log(student.name + " " + student["age"] + " " + student.hobby); b. 对象方法
// 方法定义格式 -&gt; objectName.methodName()调用 methodName : function() { // 代码 } // 方法与属性之间也依旧需要逗号相隔 var student = { name: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf902a191ab582651961b2f47d2a12d3/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/40/">«</a>
	<span class="pagination__item pagination__item--current">41/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/42/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>