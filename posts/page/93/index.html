<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0d621b5d8bad9193fb5bc53ffd881e2/" rel="bookmark">
			处理文件和文件夹的模块—os
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.os.getcwd() 用途：获取文件的保存位置
实例：获取当前运行的Python代码文件的路径
import os path = os.getcwd() print(path) 结果：该Python代码文件保存在D:\CODE\Python\01
2.os.listdir() 用途：查看某个文件夹包含的所有文件和子文件夹的名称
实例：获取D:\工作交接下所有文件和子文件名称
import os path = "D:\工作交接" file_list = os.listdir(path) print(file_list) 结果：该目录下有一下文件夹
3.splitext() 用途：分离一个文件的文件主名和扩展名
返回的是一个包含2个元素的元组
实例：
import os path = "example.xlsx" separate = os.path.splitext(path) print(separate) 结果：
4.rename() 用途1：重命名文件和文件夹
语法格式：rename(src,dst)
参数说明：
src：用于指定要重命名的文件或文件夹，dst：用于指定文件或文件夹的新名称 实例：
import os oldname = "example.xlsx" newname = "text.xlsx" os.rename(oldname,newname) 用途2：修改文件路径
实例：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f4b078329703b39d6d6fde5ad5bcf5b/" rel="bookmark">
			long类型精度丢失问题的三种解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 简介 ​ 对于Long类型的数据，如果我们在Controller层将结果序列化为json，直接传给前端的话，在Long长度大于17位时会出现精度丢失的问题
2. 解决方案 2.1 注解 2.1.1 @JsonFormat @JsonFormat(shape =JsonFormat.Shape.STRING) 2.1.2 @JsonSerialize @JsonSerialize(using = ToStringSerializer.class) 2.1.3 详情 package com.king.entity; import com.fasterxml.jackson.annotation.JsonFormat; import com.fasterxml.jackson.databind.annotation.JsonSerialize; import com.fasterxml.jackson.databind.ser.std.ToStringSerializer; import lombok.Data; import lombok.EqualsAndHashCode; import java.io.Serializable; /** * @author King * @version 1.0 * @description TODO * @date 2023/9/5 10:19 */ @Data @EqualsAndHashCode(callSuper = false) public class user implements Serializable { //方式一 @JsonFormat(shape = JsonFormat.Shape.STRING) private Long id; private String username; private String password; //方式二 @JsonSerialize(using = ToStringSerializer.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f4b078329703b39d6d6fde5ad5bcf5b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b16a298c0689d20092e4b30e97d984c5/" rel="bookmark">
			DataBinding(数据绑定)ListView使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DataBinding(数据绑定)基础讲解
DataBinding(数据绑定)基础讲解_jianning-wu的博客-CSDN博客
本章节讲述ListView中使用DataBinding。
一.ListView使用Databinding Item布局
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;layout xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;data&gt; &lt;variable name="stu" type="com.wjn.okhttpmvpdemo.databinding.Student" /&gt; &lt;/data&gt; &lt;RelativeLayout android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;TextView android:id="@+id/databindinglibrarylistview_item_name" android:layout_width="match_parent" android:layout_height="40dp" android:gravity="center" android:text="@{stu.name}" /&gt; &lt;TextView android:id="@+id/databindinglibrarylistview_age" android:layout_width="match_parent" android:layout_height="40dp" android:layout_below="@id/databindinglibrarylistview_item_name" android:gravity="center" android:text="@{stu.age}" /&gt; &lt;TextView android:id="@+id/databindinglibrarylistview_sex" android:layout_width="match_parent" android:layout_height="40dp" android:layout_below="@+id/databindinglibrarylistview_age" android:gravity="center" android:text="@{stu.sex}" /&gt; &lt;/RelativeLayout&gt; &lt;/layout&gt; Adapter
package com.wjn.okhttpmvpdemo.databinding; import android.content.Context; import android.databinding.DataBindingUtil; import android.view.LayoutInflater; import android.view.View; import android.view.ViewGroup; import android.widget.BaseAdapter; import com.wjn.okhttpmvpdemo.R; import java.util.List; public class UserListAdapter extends BaseAdapter { private Context context; private List&lt;Student&gt; list; public UserListAdapter(Context context, List&lt;Student&gt; list) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b16a298c0689d20092e4b30e97d984c5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73224ed4cc53b925d2eb3d76262d0146/" rel="bookmark">
			开源机密计算平台：蓬莱-OpenHarmony
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		演讲嘉宾 | 杜 东
回顾整理 | 廖 涛
排版校对 | 李萍萍
嘉宾简介
杜东，上海交通大学助理研究员。中国计算机学会CCF会员，ACM会员。研究兴趣为操作系统与体系结构、服务器无感知（Serverless）计算、系统安全。在包括ASPLOS、ISCA、OSDI、SOSP、ACM SoCC、TOCS等国际著名会议和期刊发表/录用多篇学术论文。
内容来源
第一届开放原子开源基金会OpenHarmony技术峰会——安全及机密计算分论坛
视频回顾
视频链接：
峰会回顾第13期 | 开源机密计算平台：蓬莱-OpenHarmony（杜东）_哔哩哔哩_bilibili
正 文 内 容
OpenHarmony赋能万物互联，存在覆盖从端到云的安全能力需求。蓬莱-OpenHarmony是一个开源机密计算平台，提供了面向OpenHarmony的可信执行环境，赋能OpenHarmony安全能力。那么，蓬莱-OpenHarmony主要做了哪些安全增强方面的工作，有哪些关键技术呢？上海交通大学助理研究员、中国计算机学会CCF会员、ACM会员杜东在第一届OpenHarmony技术峰会上给大家带来了几点分享。
01►万物互联计算的安全挑战
当进入到万物互联的新场景后，存在哪些安全风险和挑战，又有哪些解决方案呢？
依靠软件本身提供系统安全能力是一种方案。但是，依赖形式化验证、类型安全语言等技术目前来加强系统安全，目前看来是较为困难的。在万物互联的场景中，开发者的背景和能力多样性倍增，各自所依靠开发软件本身处理安全风险的能力不尽相同。就算能够实现，也可能需要更多的辅助工具来配合开发者完成。
通过软硬件配合，依赖于硬件提供的安全特性来加固系统，为其提供可信执行环境（TEE）是另一种可行的系统安全加固方案。可信执行环境能够有效增强边缘设备的安全能力，例如内存隔离、I/O隔离等。依赖该方案进行安全加固的代表系统有Intel SGX、ARM TrustZone和RISC-V蓬莱或Keystone等。目前，已经发布了多个安全特性扩展和完善的可执行环境方案，为什么还要定制化设计一个蓬莱-OpenHarmony呢？因为OpenHarmony所面临的万物互联场景是有不一样的挑战和风险，主要有以下3个方面：
第一，万物互联会导致需要面临复杂的硬件环境。在异构的硬件环境下，通过一套系统把OpenHarmony的安全特性和需求支撑起来，是非常复杂的一件事。例如，端侧可能存在非常小型的低配设备，没有页表和内存隔离，但是TEE很难跑在这种配置下；又例如，在较高配的手机场景，怎么能够让小型的、没有很多基础安全能力的环境和有安全能力的环境进行协同，也是一个较大的挑战。
第二，软件栈存在差异。面向云场景，软件主要基于Linux内核和虚拟机监控器等，必要时可引入如安全OS等组件；而面向边缘及IoT，软件栈较为简单，可能基于RTOS（如OpenHarmony小型内核）等构建整个软件栈。因此，如何使得二者进行协同，是软件异构所带来的问题。
第三，操作系统国产化问题。例如OpenHarmony目前在系统安全方面已经有所成果，如何保证它的安全能力自主可控呢？这也是需要思考的一个风险和挑战。
蓬莱-OpenHarmony能够有效解决上述问题，下图是蓬莱-OpenHarmony的logo。讨论一个有趣的话题：为什么新的系统命名为蓬莱？蓬莱是中国古代神话里面的一座仙岛，其被一片黑色的冥河所包围。我们希望提供一个可信执行环境，它是和外界隔离的，里面的东西不能出来，外面的东西也不能进去。一方面能够保证内部机密数据的安全，另一方面也能够避免内部不安全因素因其特殊的地位而对外部造成损害。
02►蓬莱-OpenHarmony
在蓬莱-OpenHarmony的项目中，开发了蓬莱可信执行环境并提供了通用的解决方案。目前主要做的四项工作有：（1）提出面向OpenHarmony的通用TEE架构和接口，明确架构和接口的定义，保证后续所有的TEE都能够满足某一个抽象或某一个核心接口而被纳入OpenHarmony体系中；（2）基于 RISC-V v1.10的指令集，开发了蓬莱安全硬件扩展；（3）开发固件层(M-mode) Monitor和TEE SDK的软件层；（4）提供含MMU平台和无MMU平台的两套系统支持。
2.1►►RISC-V生态
在RISC-V生态中，开发者可以自身需求定制化设计硬件而无需担心版权风险，如果硬件的特性足够好，还可以将其合入到RISC-V的官方指令集中。截至2022年，RISC-V处理器出货量达到100亿，Semico Research预测到2025年，RISC-V处理器出货量将达到800亿，构建了强大的影响力和生态。
RISC-V设备的急剧增加，逐步形成了万物互联的端边场景，RISC-V的CEO Calista Redmond预测，到2030年将有500亿联网和物联网设备需要安全和定制处理器加持，需要有足够多的安全特性以保证身边的设备能够满足计算和处理器的需求。
2.2►►面向OpenHarmony的通用TEE架构和接口
面向OpenHarmony的通用TEE架构和接口当前还处于草案的状态。如下图所示，架构本身和RISC-V无关，并未涉及到具体的架构和特性。我们认为，未来OpenHarmony的通用TEE架构和接口可能包含4层：最底层是所需要的硬件特性，其上层为安全固件；可信执行环境操作系统在安全固件的上层；最上层即用户应用层。
2.3►►蓬莱-OpenHarmony：RISC-V指令集下的TEE系统架构
蓬莱-OpenHarmony的整体架构如下图所示。蓬莱-OpenHarmony基于上述定义的OpenHarmony TEE参考架构；在硬件上进行了创新，面向万物互联异构的场景，提出了细粒度的轻量隔离，其安全特性是可配置和可选的；在软件上也进行了创新，面向多元隔离的需求，支持安全OS和轻量安全应用；此外，蓬莱-OpenHarmony也支持OpenHarmony标准、小型、轻量等配置。
2.4►►硬件异构应对案例
在硬件异构的场景中，如何实现内存隔离呢？RISC-V将整个软硬件分为硬件层、机器态、特权态以及用户态共4层。其中，硬件层RISC-V支持不同的特性及扩展；机器态即固件层，拥有比特权态更高的权限，通常负责加载操作系统或者实现安全特性；特权态运行操作系统内核，支持MMU和no-MMU平台；用户态则运行各类应用程序。可信执行环境的基础能力，要求内核和应用之间要内存隔离，云边场景可以通过内存管理模块 (MMU)/页表实现，但IoT和边缘RISC-V设备可能没有MMU，内核和应用之间缺乏隔离性。
怎么解决呢？如下图所示为一个临时解决方案，即将内核运行在机器态，机器态中有一套硬件机制PMP，可以通过PMP控制来隔离内核和用户态。例如，Linux在没有 MMU的时候，通过RISC-V机器态的PMP隔离机制实现粗粒度隔离。但随之而来出现一个问题，机器态固件和操作系统之间会存在机器态争抢，其问题根本是边缘设备硬件情况不同所导致，对于小型硬件经常存在这样的问题和风险。
在蓬莱-OpenHarmony中，提出了新的RISC-V硬件扩展：sPMP。sPMP是轻量级的内存隔离机制，存在硬件资源开销低、访存性能好的优势。有sPMP和没有sPMP的区别在什么地方呢？当没有sPMP时，机器态是有内存隔离的，但是用户态和OS态之间没有任何隔离，很难在上面运行多个APP；有sPMP后，操作系统依赖sPMP寄存器就可以实现隔离，补齐了机制缺陷。
2.5►►软件异构应对方案
在软件异构场景中，隔离域依赖于安全硬件的物理内存隔离机制，如RISC-V段隔离机制。其问题是隔离域与硬件强相关，比如PMP，最终的总体隔离数量与PMP个数是呈正相关。段隔离机制本身是有限的 (不超过16个)，4组PMP寄存器现在最多只能划分出4个域，如图所示。
那么可信执行环境如何提供可扩展的隔离域呢？在云场景中，可以利用软件隔离出更多隔离域，但在边端由于内存资源不足并不适用。针对此问题，蓬莱-OpenHarmony提供了滑动窗口的隔离域设计，使一组PMP (逻辑上) 保护多个隔离域，在上下文切换时滑动实际的保护范围。如图所示，当隔离域-1被执行时，PMP-2能够将隔离域收缩至隔离域-1的范围；反之，当隔离域-2被执行时，PMP-2也能够将隔离域收缩至隔离域-2的范围。如此一来，能够保证每一个隔离域执行时，其内存保护的范围是准确的。
03►总结
总的来说，蓬莱-OpenHarmony项目为OpenHarmony在RISC-V架构下提供了安全基石，支持OpenHarmony面向万物互联的多场景安全需求。欢迎大家持续关注蓬莱-OpenHarmony项目，我们也期待更多的开发者能够加入其中，共同赋能OpenHarmony的安全底座。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0336022eb1a5492378d755078effd18/" rel="bookmark">
			DataBinding(数据绑定)基础讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.基础使用 1.Gradle依赖
android { compileSdkVersion 28 defaultConfig { applicationId "com.wjn.okhttpmvpdemo" minSdkVersion 19 targetSdkVersion 27 versionCode 1 versionName "1.0" testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner" } buildTypes { release { minifyEnabled false proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro' } } dataBinding { enabled = true } } 即 添加
dataBinding { enabled = true } 2.代码说明
实体类
package com.wjn.okhttpmvpdemo.databinding; public class Student { private String name; private String age; private String sex; public String getName() { return name; } public void setName(String name) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0336022eb1a5492378d755078effd18/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e97d11d2028c1949ae7ba684b1e5d5e/" rel="bookmark">
			ssprompt：一个LLM Prompt分发管理工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		阅读顺序 🌟前言🔔ssprompt介绍命令介绍Metafile介绍版本依赖规则 🌊 PromptHubGitHub Token 🚀 Quick Install系统依赖pip安装Linux, macOS, Windows (WSL)Windows (Powershell) 🚩 Roadmap🌏 项目交流讨论 🌟前言 自从OpenAI掀起了一轮新的AI革命，国内外众多玩家入场接受时代洗礼，一时间LLM相关技术井喷，而提示工程( prompt engineering )就在其中。
它就像是为大语言模型（LLM）设计的"语言游戏"。通过这个"游戏"，我们可以更有效地引导 LLM 来处理问题。在真正的通用智能到来前，基于当前的LLM范式，要充分发挥LLM的优势，Prompt设计越来越复杂化，进一步Prompt的代码化，模块化会越发明显，同时写prompt将会成为AI时代人的基本技能。
基于此，我构思创作了ssprompt，希望每个人都能利用Prompt，享受AI时代红利
🔔ssprompt介绍 ssprompt是一个Prompt分发管理工具，定义了一套Prompt分发规则
支持创建Prompt工程和拉取Prompt Hub上对应Prompt的工程文件到本地工程
注：以下为 0.1.0 第一版ssprompt的内容介绍，项目还在持续完善，如有疏漏或不足之处请包涵了解，谢谢~
命令介绍 ssprompt new -&gt; 新建一个新的Prompt工程，指定工程目录，Prompt类型等参数ssprompt init -&gt; 基于当前目录，引导创建一个Prompt工程ssprompt add -&gt; 添加一个不同Prompt类型和相关依赖到metafile，并生成相应的Prompt工程目录（工程配置文件）ssprompt show -&gt; 展示本地Prompt工程的基本信息（metafile）或拉取PromptHub上对应工程的信息ssprompt pull -&gt; 拉取远端工程到本地项目中，相关工程可以引用Prompt文件或代码ssprompt list -&gt; 展示当前版本ssprompt支持的命令ssprompt about -&gt; 展示ssprompt的介绍和版本信息ssprompt version -&gt; 展示ssprompt的版本信息 更多命令参数详情，请使用ssprompt [command] -h进一步了解
Metafile介绍 ssprompt通过定义prompt工程的Meta文件来约束管理Prompt分发规则和内容
ssprompt关于prompt定义了四种类型的Prompt
TextJsonYamlPython 可以按需生成对应的Prompt上传到PromptHub进行分发
metafile以Prompt工程名称命名,如prompt_project.yaml ，是ssprompt管理Prompt分发的关键
注：上述类型结合参考了langchain和haystack
#Prompt工程基础信息 meta: name: open #工程名称 author: - ptonlix &lt;baird0917@163.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e97d11d2028c1949ae7ba684b1e5d5e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac96d6226747ea00b163811a84fd30cc/" rel="bookmark">
			springBoot 项目部署到外部tomcat ‘Unable to process Jar entry [META-INFversions11module-info.class] from Jar
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		springBoot部署到外部tomcat依赖报错 springBoot部署到外部tomcat报错 'Unable to process Jar entry [META-INF/versions/11/module-info.class] from Jar [xxx/xxx.jar] for annotations'一、错误信息二、错误描述三、错误查找并解决 springBoot部署到外部tomcat报错 ‘Unable to process Jar entry [META-INF/versions/11/module-info.class] from Jar [xxx/xxx.jar] for annotations’ 一、错误信息 07-Sep-2023 09:00:15.718 严重 [http-nio-10103-exec-58] org.apache.catalina.startup.ContextConfig.processAnnotationsJar Unable to process Jar entry [META-INF/versions/11/module-info.class] from Jar [file:/D:/LANCOO_ISC_A_3.0+/BasicSoftWare/jdktool/apache-tomcat-9.0.0.M15/webapps/lancoo-web/WEB-INF/lib/HikariCP-4.0.3.jar] for annotations org.apache.tomcat.util.bcel.classfile.ClassFormatException: Invalid byte tag in constant pool: 19 二、错误描述 项目部署到外部tomcat，报了很多jar的加载错误等信息，一开始我上网查，有说是版本不兼容的，更换版本可以解决，但是我这里，报的有十多个依赖，而且我另外一个项目，用的都是同样的依赖，而且也是部署在同一个tomcat,另一个项目可以正常运行，并没有问题。但是苦于没有办法，试了一下，果然并不行。
三、错误查找并解决 之后我反复查看错误信息，对META-INF/versions/11这个信息产生了怀疑，我用的是java8，设么会出现11这个版的东西，后来查了一下这个东西，发现他是java9里面的东西：
果然，是因为使用java9的东西，那么接下来，就是检查哪里用了java9的东西：
（1） File-&gt;Project Structure 图中红框选中部分，选择自己需要的Java版本
（2） File-&gt;settings -&gt; Build，Execution,Deployment-&gt; Compiler -&gt; Java Compiler
这里我发现，勾选了我框出来的选项，使用了java9的东西，所以出现了那个version11,去掉之后打包部署就可以正常启动了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bfc6a67bfa540f87c6b82d6e45928299/" rel="bookmark">
			mysql division by 0
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里写自定义目录标题 mysql 报错 divsion by 0 mysql 报错 divsion by 0 原因：分母中不能有0
代码如下处理：
select
, case
when B &gt; 0 then (A / B)
else 0
end as C
#如果B大于0，返回 A/B，否则返回 0
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0d0dbdaadb53092764fd88c8b76c85b/" rel="bookmark">
			C&#43;&#43;内存管理（3）——内存池
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 默认内存管理函数的不足（为什么使用内存池） 利用默认的内存管理操作符 new/delete 和函数 malloc()/free() 在堆上分配和释放内存会有一些额外的开销。
系统在接收到分配一定大小内存的请求时，首先查找内部维护的内存空闲块表，并且需要根据一定的算法（例如分配最先找到的不小于申请大小的内存块给请求者，或者分配最适于申请大小的内存块，或者分配最大空闲的内存块等）找到合适大小的空闲内存块。如果该空闲内存块过大，还需要切割成已分配的部分和较小的空闲块。然后系统更新内存空闲块表，完成一次内存分配。类似地，在释放内存时，系统把释放的内存块重新加入到空闲内存块表中。如果有可能的话，可以把相邻的空闲块合并成较大的空闲块。默认的内存管理函数还考虑到多线程的应用，需要在每次分配和释放内存时加锁，同样增加了开销。
可见，如果应用程序频繁地在堆上分配和释放内存，会导致性能的损失。并且会使系统中出现大量的内存碎片，降低内存的利用率。默认的分配和释放内存算法自然也考虑了性能，然而这些内存管理算法的通用版本为了应付更复杂、更广泛的情况，需要做更多的额外工作。而对于某一个具体的应用程序来说，适合自身特定的内存分配释放模式的自定义内存池可以获得更好的性能。
2. 内存池简介 2.1 内存池的定义 池化技术是一种降低频繁操作导致开销过大的方法，如内存池、线程池、进程池和对象池等。
内存池（Memory Pool）是一种内存分配方式。通常我们习惯直接使用new、malloc等API申请内存，这样做的缺点在于所申请内存块的大小不定，当频繁使用时会造成大量的内存碎片并进而降低性能。
2.2 内存池的实现原理 内存池则是在真正使用内存之前，预先申请分配一定数量、大小相等（一般情况下）的内存块留作备用。当有新的内存需求时，就从内存池中分出一部分内存块，若内存块不够再继续申请新的内存。
（用malloc申请一大块内存，当要分配的时候，从这一大块内存中一点一点的分配，当一大块内存分配的差不多的时候，再用malloc再申请一大块内存，然后再一点一点的分配给你）
2.3 内存池的优点 减少malloc的次数，减少malloc()调用次数就意味着减少对内存的浪费，使得内存分配效率得到提升。
2.4 内存池的分类 应用程序自定义的内存池根据不同的适用场景又有不同的类型。从线程安全的角度来分，内存池可以分为单线程内存池和多线程内存池。单线程内存池整个生命周期只被一个线程使用，因而不需要考虑互斥访问的问题；多线程内存池有可能被多个线程共享，因此需要在每次分配和释放内存时加锁。相对而言，单线程内存池性能更高，而多线程内存池适用范围更加广泛。
从内存池可分配内存单元大小来分，可以分为固定内存池和可变内存池。所谓固定内存池是指应用程序每次从内存池中分配出来的内存单元大小事先已经确定，是固定不变的；而可变内存池则每次分配的内存单元大小可以按需变化，应用范围更广，而性能比固定内存池要低。
3. 内存池的实现v1.0 3.1 程序源码 通过#define MYMEMPOOL 1，可以使用无内存的申请空间操作。如果注释掉宏定义，将使用普通的申请空间操作。
#include &lt;iostream&gt; using namespace std; #include &lt;ctime&gt; #define MYMEMPOOL 1 class A { public: static void *operator new(size_t size); static void operator delete(void *phead); static int m_iCout; //分配计数统计，每new一次，就统计一次 static int m_iMallocCount; //每malloc一次，就统计一次 private: A *next; static A* m_FreePosi; //总是指向一块可以分配出去的内存的首地址 static int m_sTrunkCout; //一次分配多少倍的该类内存 }; int A::m_iCout = 0; int A::m_iMallocCount = 0; A *A::m_FreePosi = nullptr; int A::m_sTrunkCout = 5; //一次分配5倍的该类内存作为内存池子的大小 void *A::operator new(size_t size) { #ifndef MYMEMPOOL A *ppoint = (A*)malloc(size); return ppoint; #endif A *tmplink; if (m_FreePosi == nullptr) { //为空，我要申请内存，要申请一大块内存 size_t realsize = m_sTrunkCout * size; //申请m_sTrunkCout这么多倍的内存 m_FreePosi = reinterpret_cast&lt;A*&gt;(new char[realsize]); //传统new，调用的系统底层的malloc tmplink = m_FreePosi; //把分配出来的这一大块内存（5小块），彼此要链起来，供后续使用 for (; tmplink !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0d0dbdaadb53092764fd88c8b76c85b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a4ddc2ead646f677b34f56f3b52ee25/" rel="bookmark">
			C&#43;&#43;内存管理（2）new、delete详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
new operator（new操作）
new类对象时加不加括号的差别
new工作任务
delete工作任务
new和delete 堆区空间操作（对比malloc和free）
new和delete操作基本类型的空间
new和delete操作基本类型的数组
new和delete操作类的空间
new和delete操作对象数组
new内存分配细节探秘
为什么要尽可能少的调用malloc？
new和delete的重载
为什么要重载 new
监测内存创建销毁，统计和监控泄漏
内存对齐的处理
特定应用：多进程内存共享
重载全局的 new 和 delete
在全局new和delete中添加定制行为
重载类的操作符 new 和 delete
类new和delete操作符重载基础
对齐的内存分配
共享内存的分配
定位new（placement new）
功能
使用placement new
placement new对象的销毁
placement new的应用
硬件编程
实现基础库
多种版本的operator new重载
new operator（new操作） new类对象时加不加括号的差别 A *pa = new A;//有无构造函数初始化为垃圾值A *pa2 = new A();//无构造函数初始化为0，有构造函数为垃圾值 在g++中默认初始化成员变量为0，而A *pa2 = new A(5)初始化成员变量为5
#include &lt;iostream&gt; using namespace std; class A { public: int m_num; public: A(){}; A(int num) : m_num(num) { cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a4ddc2ead646f677b34f56f3b52ee25/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a58028c9b0d347f8ae45801cde019ba/" rel="bookmark">
			cookie &amp; session
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、cookie cookie简介：
在为了在无状态的HTTP协议之上实现会话，Cookie 诞生了。
Cookie 是一些存储在客户端的信息，每次连接的时候由浏览器向服务器递交，服务器也向浏览器发起存储 Cookie 的请求，依靠这样的手段服务器可以识别客户端。我们通常意义上的 HTTP 会话功能就是这样实现的。具体来说，浏览器首次向服务器发起请求时，服务器生成一个唯一标识符并发送给客户端浏览器，浏览器将这个唯一标识符存储在 Cookie 中，以后每次再发起请求，客户端浏览器都会向服务器传送这个唯一标识符，服务器通过这个唯一标识符来识别用户。 对于开发者来说，我们无须关心浏览器端的存储，需要关注的仅仅是如何通过这个唯一标识符来识别用户。
对于开发者来说，我们无须关心浏览器端的存储，需要关注的仅仅是如何通过这个唯一标识符来识别用户。很多服务端脚本语言都有会话功能，如 PHP，把每个唯一标识符存储到文件中。
cookie &amp; session: https://www.cnblogs.com/tugenhua0707/p/9098132.html cookie它是一个由浏览器和服务器共同协作实现的协议的。那么cookie分为如下几步实现：
1. 服务器端向客户端发送cookie。
2. 浏览器将cookie保存。
3. 之后每次请求都会将cookie发向服务器端。
1.1 服务器端发送cookie
服务器发送cookie给客户端是通过HTTP响应报文实现的。在set-Cookie中设置给客户端发送的cookie，cookie格式如下：
Set-Cookie: name=value; Max-Age=60; Path=/; domain=.domain.com;Expires=Sun, 27 May 2018 05:44:24 GMT; HttpOnly, secure;
如下图所示
其中name=value是必选项，其他都是可选的，cookie主要构成如下：
name: 一个唯一确定cookie的名称。
value： 存储在cookie中字符串的值。
domain: cookie对于那个域下是有效的，
path: 表示这个cookie影响到的路径，浏览器会根据这个配置，向指定的域中匹配的路径发送cookie。
expires: 失效时间，表示cookie何时失效的时间，如果不设置这个时间，浏览器就会在页面关闭时将删除所有的cookie，不过我们也可以自己设置过期时间。
注意：如果客户端和服务器端设置的时间不一致，使用expires就会存在偏差。
max-age: 用来告诉浏览器此cookie多久过期(单位是秒)，一般的情况下，max-age的优先级高于expires。
HttpOnly: cookie 只有Http协议可以读取（任何人都不可以携带和读取了）告诉浏览器不允许通过脚本document.cookie去更改值，这个值document.cookie中也是不可见的，但是在http请求会携带这个cookie，
注意：这个值虽然在脚本中使不可取的，但是在浏览器安装目录中是以文件形式存在的，这个设置一般在服务器端设置的。
secure：安全标志，指定后，当secure为true时候，在HTTP中是无效的，在HTTPS中才有效，表示创建的cookie只能在HTTPS连接中被浏览器传递到服务器端进行会话验证，如果是HTTP连接则不会传递该信息，所以一般不会被且听到。
二、session cookie &amp; session: https://www.cnblogs.com/tugenhua0707/p/9098132.html cookie操作很方便，但是使用cookie安全性不高，cookie中的所有数据在客户端就可以被修改，数据很容易被伪造；所以一些重要的数据就不能放在cookie当中了，并且cookie还有一个缺点就是不能存放太多的数据，为了解决这些问题，session就产生了，session中的数据保留在服务端的。
基于Cookie来实现用户和数据的映射 把数据放到cookie中是不可取的，但是我们可以将口令放在cookie中的，比如cookie中常见的会放入一个sessionId,该sessionId会与服务器端之间会产生映射关系，如果sessionId被篡改的话，那么它就不会与服务器端数据之间产生映射，因此安全性就更好，并且session的有效期一般比较短，一般都是设置是20分钟，如果在20分钟内客户端与服务端没有产生交互，服务端就会将数据删除。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a58028c9b0d347f8ae45801cde019ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1bc735009e908933ab58a2b8db1036ed/" rel="bookmark">
			学生电子爱好者协会
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6953493c86f13a24be81de4b2cd88672/" rel="bookmark">
			linux嵌入式常见面试问题（持续更新）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.采用DMA方式进行串口通信，如何解析数据才能提高吞吐量 DMA（直接内存访问）是一种通过硬件控制器直接访问内存的方式，而不需要CPU的干预。在串口通信中，采用DMA方式可以减少CPU的负担，提高数据传输的效率。
为了提高吞吐量，需要对DMA传输的数据进行解析。具体来说，需要对接收到的数据进行缓存，然后在空闲时对缓存中的数据进行解析。可以采用中断机制来触发解析过程，或者使用定时器来定期解析数据。在解析数据时，可以采用多线程或者多任务的方式，将数据分成多个部分进行解析，从而提高解析的速度和效率。
除了解析数据，还可以采用其他方式来提高串口通信的吞吐量，例如使用高速串口、增加缓存大小、优化串口协议等。综合运用这些方法，可以有效提高串口通信的效率和可靠性。
2.内联函数的缺点 1. 代码膨胀：内联函数会将函数体直接嵌入到调用处，这样会增加代码量，使得程序变得更加臃肿。
2. 编译时间增加：由于内联函数的代码需要在每个调用处进行复制，因此编译时间也会相应地增加。
3. 可读性下降：内联函数的代码会分散在程序的各个位置，使得程序变得难以阅读和维护。
4. 可移植性下降：内联函数的实现方式依赖于编译器的具体实现，因此在不同的编译器上可能会有不同的行为，导致程序的可移植性下降。
通常，设计编译器的程序设计者比大多数的程序设计者更清楚对于一个特定的函数是否合适进行内联扩展；一些情况下，对于程序员指定的某些内联函数，编译器可能更倾向于不使用内联甚至根本无法完成内联。
对于一些开发中的函数，它们可能从原来的不适合内联扩展变得适合或者倒过来。尽管内联函数或者非内联函数的转换易于宏的转换，但增加的维护开支还是使得它的优点显得更不突出了。
对于基于C的编译系统，内联函数的使用可能大大增加编译时间，因为每个调用该函数的地方都需要替换成函数体，代码量的增加也同时带来了潜在的编译时间的增加。
3.Linux多线程:在一个线程访问某个外设驱动时，怎么防止其他线程访问 Linux多线程中，可以使用互斥锁（Mutex）来防止多个线程同时访问某个外设驱动。当一个线程需要访问该外设驱动时，它会先尝试获取该互斥锁，如果该锁已经被其他线程获取了，则该线程会被阻塞，直到该锁被释放。当该线程完成对外设驱动的访问后，它会释放该互斥锁，以便其他线程可以获取该锁并访问外设驱动。这样就可以保证同一时间只有一个线程在访问该外设驱动，避免了多个线程同时访问该外设驱动可能引发的竞态条件问题。
23.9.6（杭州长川科技）【笔试】
问答题
​​​​​​1.【C语言】交换函数（swap）_c语言交换函数_话真多的博客-CSDN博客
选择题
1.C语言if语句中的零值比较_如何用if来做零值比较_double_happiness的博客-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eef4dea26c68de83dd18149afdee1759/" rel="bookmark">
			SpringCloud OpenFeign 全功能配置详解（一文吃透OpenFeign）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、简介二、feign和OpenFeign的区别三、SpringCloud集成OpenFeign1、引入starter2、在启动类或者配置类上加@EnableFeignClients注解3、声明Feign接口4、@FeignClient 属性介绍5、@EnableFeignClients 属性介绍 四、默认配置1、替换默认配置前置说明（这里以Feign请求日志为例）2、使用配置文件替换默认配置（推荐使用优先级最高）2.1、全局请求日志配置2.2、独立请求日志配置（独立配置优先）2.3、源码分析为什么使用配置文件配置优先级最高 3、在@EnableFeignClients中使用缺省（默认）配置类替换默认配置（如果不做特殊处理这个配置类优先级很高会比独立配置还高）3.1、配置实现3.2、源码分析为什么使用缺省配置类优先级会那么高 4、使用独立配置替换默认配置 五、解决allow-bean-definition-overriding问题1、错误原因2、解决方法一（别用）3、解决方法二（推荐） 六、解决GET请求无法传递对象参数问题（使用@SpringQueryMap）七、OpenFeign超时配置1、使用配置文件配置（推荐）2、使用@FeignClient配置超时时间3、为单独接口设置超时时间（这种方式优先级比使用配置文件更高）4、通过Ribbon配置文件设置超时时间（不主动设置Feign的超时时间才有效，不推荐使用） 八、OpenFeign重试配置1、OpenFeign默认重试机制（核心）2、通过Ribbon配置重试（配置了Feign的配置或者spring-retry则Ribbon重试配置会失效）3、通过Feign的Retryer接口配置重试（如果在配置文件设置了Feign的Retryer那么Ribbon和spring-retry的重试机制都会失效）4、通过spring-retry为每个请求设置重试（如果Feign配置自己的Retryer那么spring-retry不会生效，但是会比Ribbon优先级高） 九、OpenFeign请求日志级别配置1、通过配置文件配置（推荐）2、使用@FeignClient配置 十、OpenFeign拦截器1、通过OpenFeign请求拦截器设置统一请求头 十一、替换OpenFeign默认HTTP请求框架HttpURLConnection1、替换成HttpClient2、替换成OkHttp3、源码断点查看是否生效 十二、OpenFeign配置hystrix1、使用@FeignClient中的fallback进行回调（不能控制不同异常的处理逻辑）2、使用@FeignClient中的fallbackFactory进行回调（可以控制对应异常的处理逻辑） 十三、配置Ribbon负载均衡算法1、单独配置某个服务负载均衡算法（使用全局配置无效）2、为什么使用配置文件配置Ribbon的全局负载均衡算法会无效？ 一、简介 OpenFeign客户端是一个web声明式http远程调用工具，直接可以根据服务名称去注册中心拿到指定的服务IP集合，提供了接口和注解方式进行调用，内嵌集成了Ribbon本地负载均衡器。
二、feign和OpenFeign的区别 1、底层都是内置了Ribbon，去调用注册中心的服务。
2、Feign是Netflix公司写的，是SpringCloud组件中的一个轻量级RESTful的HTTP服务客户端，是SpringCloud中的第一代负载均衡客户端。
3、OpenFeign是SpringCloud自己研发的，在Feign的基础上支持了Spring MVC的注解，如@RequesMapping等等。是SpringCloud中的第二代负载均衡客户端。
4、Feign本身不支持Spring MVC的注解，使用Feign的注解定义接口，调用这个接口，就可以调用服务注册中心的服务
5、OpenFeign的@FeignClient可以解析SpringMVC的@RequestMapping注解下的接口，并通过动态代理的方式产生实现类，实现类中做负载均衡并调用其他服务。
三、SpringCloud集成OpenFeign 版本说明：
Spring Cloud Version：Hoxton.SR12
Spring Boot Version：2.3.12.RELEASE
不同版本源码可能会有差异
1、引入starter &lt;!--openfeign--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt; 2、在启动类或者配置类上加@EnableFeignClients注解 @SpringBootApplication @EnableFeignClients public class Application { public static void main(String[] args) { SpringApplication.run(Application.class, args); } } 3、声明Feign接口 @FeignClient(value = "kerwin-user",contextId = "userInfoClient") public interface UserInfoClient { /** 获取用户信息 */ @GetMapping("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eef4dea26c68de83dd18149afdee1759/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d60af8baa160fce690f14f1136839a86/" rel="bookmark">
			python ThreadPoolExecutor的异常捕获
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于ThreadPoolExecutor线程池中提交的任务，在执行过程中是不会主动抛出异常的，需要主动捕获这个异常。
from concurrent.futures import ThreadPoolExecutor def job(): print('333') print(1/0) print('444') # add_done_callback（） def thread_pool_callback(worker): print("called thread pool executor callback function") worker_exception = worker.exception() if worker_exception: print("Worker return exception: {}".format(worker_exception)) if __name__ == '__main__': with ThreadPoolExecutor(max_workers=5) as executor: thread_pool_exc = executor.submit(job) thread_pool_exc.add_done_callback(thread_pool_callback) # 使用result() if __name__ == '__main__': with ThreadPoolExecutor(max_workers=5) as executor: thread_pool_exc = executor.submit(job).result() print(thread_pool_exc) print('555') 结果：
回调：
result：
以上面代码为例，比较通用的做法是使用add_done_callback方法获取到线程执行结束后的结果，从中获取exception的信息。
使用回调方法和使用result的区别：
回调方法不会导致当前主线程异常终止，使用result相当于是拿当前主线程重新执行一遍，这时候的异常会自动抛出导致主线程异常终止。
原因：
异步执行：线程池执行器是为了异步执行任务而设计的。这意味着当你提交一个任务给线程池时，它不会立即执行，而是在后台的某个线程中执行。如果异常立即在任务线程中抛出，它会中断整个线程池的执行，这可能不是你期望的行为。
任务封装：每个任务都被封装在一个 Future 对象中，该对象可以追踪任务的状态和结果。这种封装允许你异步地监视和管理多个任务，而不必等待每个任务完成。Future 对象的目的是提供一个异步的、非阻塞的接口，以便你可以有效地提交、等待和取消任务。
异常处理：将异常封装在 Future 对象中允许你更容易地捕获和处理异常。你可以使用 future.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d60af8baa160fce690f14f1136839a86/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0cfe410d8c3187701e48983fc80f7381/" rel="bookmark">
			阿里云APP备案教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 前言 前言 APP上架最新政策
2023年9月1日以后新上架APP（包含历史下架重新申请上线的APP），应先履行备案手续后再上架应用，如未履行APP备案手续，APP提交上架申请会被驳回。
2023年9月1日以前上架的APP，需要在2024年3月31日前完成备案手续。
1.登录阿里云账号进入管理后台
2.点击备案进入备案页面
3.新增app备案
4.填写相关信息
5.ios及安卓需要准备的资料
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71f6c6f07f2b3058dd993b37192a04a1/" rel="bookmark">
			一文讲透【静态脱敏实操】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1：直接上工具类
&lt;dependency&gt; &lt;groupId&gt;cn.hutool&lt;/groupId&gt; &lt;artifactId&gt;hutool-all&lt;/artifactId&gt; &lt;version&gt;5.8.16&lt;/version&gt; &lt;/dependency&gt; 2:Hutool 支持的脱敏数据类型
现阶段最新版本的 Hutool 支持的脱敏数据类型如下，基本覆盖了常见的敏感信息。
用户 id中文姓名身份证号座机号手机号地址电子邮件密码中国大陆车牌，包含普通车辆、新能源车辆银行卡 3:使用 Hutool 工具类一行代码实现脱敏
Hutool 提供的脱敏方法如下图所示：
import cn.hutool.core.util.DesensitizedUtil; import org.junit.Test; import org.springframework.boot.test.context.SpringBootTest; /** * * @description: Hutool实现数据脱敏 */ @SpringBootTest public class HuToolDesensitizationTest { @Test public void testPhoneDesensitization(){ String phone="13723231234"; System.out.println(DesensitizedUtil.mobilePhone(phone)); //输出：137****1234 } @Test public void testBankCardDesensitization(){ String bankCard="6217000130008255666"; System.out.println(DesensitizedUtil.bankCard(bankCard)); //输出：6217 **** **** *** 5666 } @Test public void testIdCardNumDesensitization(){ String idCardNum="411021199901102321"; //只显示前4位和后2位 System.out.println(DesensitizedUtil.idCardNum(idCardNum,4,2)); //输出：4110************21 } @Test public void testPasswordDesensitization(){ String password="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/71f6c6f07f2b3058dd993b37192a04a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33b0a07a6228ee8032f62cb094077319/" rel="bookmark">
			2023深圳杯(东三省)数学建模A题 - 影响城市居民身体健康的因素分析(思路分析&#43;代码&#43;论文)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		A题 影响城市居民身体健康的因素分析
以心脑血管疾病、糖尿病、恶性肿瘤以及慢性阻塞性肺病为代表的慢性非传染性疾病（以下简称慢性病）已经成为影响我国居民身体健康的重要问题。随着人们生活方式的改变，慢性病的患病率持续攀升。众所周知，健康状况与年龄、饮食习惯、身体活动情况、职业等都有密切的关系。如何通过合理地安排膳食、适量的身体运动、践行健康的生活方式，从而达到促进身体健康的目的，这是全社会普遍关注的问题。附件A1是某市卫生健康研究部门对部分居民所做的“慢性非传染性疾病及其相关影响因素流行病学”调查问卷表，附件A2是相应的调查数据结果，附件A3是中国营养学会最新修订的《中国居民膳食指南》中为平衡居民膳食提出的八条准则。
请你们团队研究解决下面问题：
问题1 参考附件A3，分析附件A2中居民的饮食习惯的合理性，并说明存在的主要问题。
问题2 分析居民的生活习惯和饮食习惯是否与年龄、性别、婚姻状况、文化程度、职业等因素相关。
问题3 根据附件A2中的数据，深入分析常见慢性病（如高血压、糖尿病等）与吸烟、饮酒、饮食习惯、生活习惯、工作性质、运动等因素的关系以及相关程度。
问题4 依据附件A2中居民的具体情况，对居民进行合理分类，并针对各类人群提出有利于身体健康的膳食、运动等方面的合理建议。
影响城市居民身体健康的因素分析 摘要
本文主要研究了附件A2中居民的饮食习惯和生活习惯与常见慢性病的相关性，同时也探讨了居民的年龄、性别、婚姻状况、文化程度和职业等因素与其生活习惯和饮食习惯的关系。基于这些分析，我们构建了一个适应居民健康管理的分类模型，并根据模型结果，为不同类别的居民提出了有利于身体健康的饮食和运动建议。
在问题一中，我们分析了居民的饮食习惯的合理性，并指出了存在的主要问题。通过统计分析，我们发现居民的饮食习惯存在一定的不合理性，例如高盐饮食、高脂肪饮食等问题。
在问题二中，我们研究了居民的生活习惯和饮食习惯与其个人特征的关联性。结果显示，年龄、性别、婚姻状况、文化程度和职业等因素均对居民的生活习惯和饮食习惯有一定影响。
在问题三中，我们进一步探讨了常见慢性病与吸烟、饮酒、饮食习惯、生活习惯、工作性质、运动等因素的关系。通过逻辑回归模型，我们发现了各因素对常见慢性病的影响程度，为健康风险预测提供了重要依据。
在问题四中，我们构建了一个适用于居民健康管理的分类模型，对居民进行了合理的分类，并为每个类别的居民提出了有利于身体健康的饮食和运动建议。通过K-Means聚类算法，我们将居民分为健康、一般和较差三类，并根据每一类居民的特点给出了具体的健康管理建议。
关键词：饮食习惯，生活习惯，常见慢性病，健康管理，分类模型，健康建议。
一、问题重述 1.1 背景 在当前社会中，以心脑血管疾病、糖尿病、恶性肿瘤及慢性阻塞性肺病等为代表的慢性非传染性疾病（简称慢性病）已经变成了影响我国居民健康的重要问题。由于生活方式的改变，这类疾病的患病率也在持续增加。我们普遍认为，健康状况受到年龄、饮食习惯、身体活动水平、职业等多方面的影响。如何通过合理地安排饮食、进行适量的运动、和实行健康的生活方式，以促进居民的身体健康，成为了全社会普遍关注的问题。
此外，我们还收到了一些附件：附件A1是一份由某市卫生健康研究部门针对部分居民进行的“慢性非传染性疾病及其相关影响因素流行病学”调查问卷；附件A2是该调查的数据结果；附件A3是中国营养学会最新修订的《中国居民膳食指南》，其中提出了八条用于平衡居民饮食的准则。
根据这个背景，我们需要进行数学建模，分析影响慢性病患病率的多种因素，并探索通过合理膳食、适量运动和健康生活方式等措施对改善健康状况的潜在影响。
1.2 重述 问题1 根据中国营养学会的《中国居民膳食指南》（附件A3），我们需要对附件A2中的居民饮食习惯进行详尽的分析。这需要涉及到的问题包括但不限于：居民的膳食是否达到了营养均衡？是否有过度的食物类型？蔬菜、水果、谷物、肉类等食物摄入是否符合指南建议？通过这种方式，我们可以指出目前居民饮食习惯存在的主要问题。
问题2 我们需要理解居民的生活习惯和饮食习惯与他们的年龄、性别、婚姻状况、教育水平、职业等社会人口学因素是否存在关联。例如，年轻人和老年人的饮食习惯是否存在明显的区别？受教育程度是否影响了人们的生活习惯？这些因素如何影响了人们的健康？
问题3 根据附件A2中的数据，我们需要更深入地理解和分析常见慢性病（如高血压、糖尿病等）与吸烟、饮酒、饮食习惯、生活习惯、工作性质、运动等生活方式因素之间的关联。我们需要找出哪些行为或习惯与慢性病的发病率有较强的相关性。
问题4 我们需要根据附件A2中居民的具体情况进行分类。然后，我们需要为每个类别的人群提供适合他们的饮食和运动建议，这些建议应能有助于改善他们的健康状况，预防慢性疾病的发生。
二、模型的假设 针对本文题目，提出以下假设建模思路：
• 独立性假设：我们假设数据中的每一个观测（每一个受访者）都是独立的，也就是说，一个人的饮食习惯、生活方式、社会人口学特征和慢性病发病情况与其他人是独立的。
• 线性假设：在分析各因素与慢性病发病率之间的关系时，我们假设这些关系在一定范围内可以被视为线性的，也就是说，这些因素的增加或减少将导致慢性病发病率的线性增加或减少。
• 稳定性假设：我们假设在数据收集期间，受访者的生活习惯和健康状况是相对稳定的，没有发生重大的变化。
• 完整性假设：我们假设调查数据（附件A2）是完整的，即所有重要的影响慢性病发病率的因素都被收集了，且所有受访者都真实、完整地回答了所有问题。
三、符号说明 符号
说明
foods_day
居民每天食用各类食物的频率总和
foods_week
居民每周食用各类食物的频率总和
foods_month
居民每月食用各类食物的频率总和
BMI
身体质量指数，体重(kg)除以身高(m)的平方
sport
锻炼量，体育锻炼的强度乘以平均每天体育锻炼时间
total_vagetable_day
每天食用蔬菜的总量
total_fruit_day
每天食用水果的总量
total_muilk_day
每天食用奶类的总量
total_mut_day
每天食用鱼、禽、蛋、瘦肉的总量
total_oil_day
每天食用油类的总量
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/33b0a07a6228ee8032f62cb094077319/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/827e52ed914ebdf46f1bb60c9dc52692/" rel="bookmark">
			电脑出现msvcp140.dll的错误提示，应该怎么解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前两天刚打开电脑突然收到提示msvcp140.dll文件丢失，无法继续执行代码，本是不当回事但想要使用某一些软件时发现不能打开，依然弹出msvcp140.dll文件丢失的窗口。那么出现这种情况有没有什么办法可以更好的解决。本篇文章将给大家解答。
一.msvcp140.dll丢失有什么影响 DLL（Dynamic Link Library）文件为动态链接库文件，又称“应用程序拓展”，是软件文件类型。msvcp140.dll文件就是属于dll文件中的一种。在电脑的使用中，许多应用程序并不是一个完整的可执行文件，它们被分割成一些相对独立的动态链接库，放置于系统中。当我们执行某一个程序时，相应的DLL文件就会被调用，一个应用程序可使用多个知DLL文件，一个DLL文件也可能被不同的应用程序使用。这样的DLL文件被称为共享DLL文件，DLL文件中存放的是各类程序的函数（子过程）实现过程，当程序需要调用函数时需要先载入DLL，然道后取得函数的地址，最后进行调用。
所以如果dll丢失就会导致电脑无法正常运行，软件或其他游戏也就无法打开。不仅如此还有可能会导致电脑出现没有声音的状态，还有可能会导致电脑图标不显示，或导致电脑无故蓝屏或崩溃。所以msvcp140.dll文件丢失对电脑的影响还是比较大的。
二.解决msvcp140.dll丢失的办法 解决msvcp140.dll丢失的办法一 1.打开浏览器，在搜索框中搜索msvcp140.dll下载，然后点击键盘中的回车键。
2.在显示的搜索结果中，找到官方文件下载。根据您的系统架构(32 位或 64 位)，您需要找到最新版本的 DLL 文件。单击“下载”按钮将所需的msvcp140.dll文件下载到您的电脑上。
3.以将文件放到您计算机上的某个位置。将提取的msvcp140.dll文件复制并粘贴到您的系统目录中。在 32 位版本的 Windows 操作系统上，将文件放在C:\Windows\System32在 64 位 Windows 操作系统上，将32 位DLL 文件放在C:\Windows\SysWOW64中，将64 位DLL 文件放在C:\Windows\System32 中。
4.现在，按Windows + R打开运行。键入cmd并按Ctrl + Shift + Enter以管理员身份打开命令提示符。在命令提示符下，键入以下命令regsvr32msvcp140.dll
5.重新启动您的计算机。检查您是否能够在没有 msvcp140.dll文件崩溃问题的情况下打开程序。
解决msvcp140.dll丢失的办法二 打开电脑浏览器，在顶部输入：dll修复.site，按下键盘的回车键打开，点击立即下载，
DLL修复工具_一键修复所有dll缺失msvcp140.dll丢失的解决方法–电脑修复精灵
下载一个dll修复工具，利用这个dll修复工具直接进行一键修复就可以了，进行扫描它会根据你电脑系统缺失了哪些dll文件，然后进行相关的修复，如你丢失了msvcp140.dlll就会帮你修复msvcp140.dll文件，操作比较简单方便。不仅如此还能把你修复电脑中的其他文件或其他的电脑问题，比如电脑卡顿等。也可以选手动修复将仅提示错误的文件进行修复，二则任你选择。
解决msvcp140.dll丢失的办法三 1. 使用快捷键win＋r打开运行对话框。键入cmd并按Ctrl + Shift + Enter以管理员身份打开命令提示符。当用户帐户控制提示时单击是。
2. 在命令提示符窗口中输入：sfc /scannow 并按Enter运行 SFC 扫描证监会
3. 等待扫描检查 Windows 系统文件是否损坏并修复它们。扫描完成后，检查问题是否已解决。
4. 如果问题仍然存在，则以管理员身份打开命令提示符并在窗口中输入：DISM /在线 /Cleanup-Image /RestoreHealth ，按下回车键执行 DISM 扫描。
5. DISM 工具检查 Windows 映像中的任何损坏并修复它们。工具完成运行后，尝试运行有问题的程序并检查问题是否已解决。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/827e52ed914ebdf46f1bb60c9dc52692/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44f3d227ee26ac0f8ccc58c0987debe1/" rel="bookmark">
			央企数字化转型实践思考
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		01 数字化转型的内涵与价值效益
数字化转型是顺应新一轮科技革命和产业变革趋势，不断深化应用云计算、大数据、物联网、人工智能、区块链等新一代信息技术，激发数据要素创新驱动潜能，打造和提升信息时代的生存与发展能力，加速业务优化升级和创新转型，改造提升传统动能，培育发展新动能，创造、传递并获取新价值，实现转型升级和创新发展的过程。
数字化价值效益按照业务创新转型方向和价值空间大小可分为生产运营优化、产品 / 服务创新和业态转变三大类。
生产运营优化。基于传统存量业务，价值创造和传递活动主要集中在企业内部价值链，价值获取主要来源于传统产品规模化生产与交易，通过数字化转型促进成本降低与质量提高。
产品 / 服务创新。业务体系总体不大变，专注于拓展基于传统业务的延伸服务，价值创造和传递活动沿着产品 / 服务链延长价值链，开辟业务增量发展空间，价值获取主要来源于已有技术 / 产品体系的增量价值。
业态转变。业务体系颠覆式创新，专注于发展壮大数字业务，价值创造和传递活动由线性关联的价值链、企业内部价值网络转变为开放价值生态，价值获取主要来源于与生态合作伙伴共建的业务生态。
02 数字化转型架构模型
价值体系优化、创新和重构是数字化转型的根本任务，参考 T/AIITRE 10001-2020《数字化转型：参考架构》，中央企业应从发展战略、新型能力、解决方案、治理体系和业务创新五个视角出发，构建系统化、体系化的关联关系，系统有序地推进数字化转型，创新价值创造、传递、支持、获取的路径和模式。
发展战略。根据数字化转型的新形势、新趋势和新要求，发展战略视角提出新的价值主张，把数据驱动的理念、方法和机制根植于组织发展战略全局，包括竞争合作优势、业务场景和价值模式三个子视角。
竞争合作优势：增强竞争合作优势的可持续性和战略柔性，从过去的单向竞争向构建多重竞合关系转变，推动新一代信息技术、产业技术、管理技术实现融合创新应用，形成新技术、新产品（服务），强化模式创新与数字应用以数据为驱动，协同推进传统业务数字化升级和数字新业务培育壮大，实现创新驱动和业态转变。
业务场景：以用户日益改变和个性化的需求为牵引，构建基于能力赋能的新型业务架构，分析业务场景、业务目标，根据竞争合作优势和业务架构设计端到端的业务场景。
价值模型：构建基于资源共享和能力赋能，实现业务快速迭代和协同发展的开放价值生态，以最大化获取数字化转型价值效益。
新型能力。中央企业应将新型能力建设作为贯穿数字化转型始终的核心路径，通过识别和策划新型能力（体系），持续建设、运行和改进新型能力，支持业务按需调用能力以快速响应市场需求变化，从而加速推进业务创新转型，获取可持续竞争合作优势。
解决方案。实施涵盖数据、技术、流程、组织四要素的系统性解决方案，支持打造新型能力，加速业务创新转型，并通过四要素的互动创新和持续优化，推动新型能力和业务创新转型持续运行与不断改进。
数据：完善数据采集手段；推进数据集成与共享；强化数据建模与应用。
技术：有序开展生产和服务设备设施自动化、数字化、网络化、智能化改造升级；部署适宜的IT 软硬件资源、系统集成架构，推动 IT 软硬件的组件化、平台化和社会化按需开发与共享利用；建设覆盖生产 / 服务区域统一的运营技术（OT）网络基础设施；自建或应用第三方平台，推动基础资源和能力模块化、数字化、平台化。
组织：根据业务流程优化要求确立业务流程职责，匹配调整有关的合作伙伴关系、部门职责、岗位职责。
流程：开展跨部门 / 跨层级流程、核心业务端到端流程以及产业生态合作伙伴间端到端业务流程等的优化设计；应用数字化手段开展业务流程的运行状态跟踪过程管控和动态优化。
治理体系。建立匹配的治理体系并推进管理模式持续变革，以提供管理保障。治理体系视角包括数字化治理、组织机制、管理方式、组织文化。
数字化治理：数字化领导力培育、数字化人才培养、数字化资金统筹安排、安全可控建设。组织机制：建立流程化、网络化、生态化的柔性组织结构；建立覆盖全过程和全员的数据驱动型职能职责动态分工体系。
管理方式：管理方式创新（流程驱动的矩阵式管理、数据驱动的网络型管理、职能驱动的价值生态共生管理）；员工工作模式变革（自我管理、自主学习、价值实现）。
组织文化：价值观；行为准则。
业务创新：企业应充分发挥新型能力的赋能作用，加速业务体系和业务模式创新，推进传统业务创新转型升级，培育发展数字新业务，通过业务全面服务化，构建开放合作的价值模式，快速响应、满足和引领市场需求，最大化获得价值效益。可从业务数字化、业务集成融合、业务模式创新、数字业务培育方面推进。
03 数字化转型是央企的必然选择
（1）政策要求：加快推进国有企业数字化转型工作 2020年9月，国资委《关于加快推进国有企业数字化转型工作的通知》中提出要促进国有企业数字化、网络化、智能化发展。包括建设基础数字技术平台、构建数据治理体系、推进产品创新数字化、生产运营智能化、用户服务敏捷化、加快新型基础设施建设、加快关键核心技术攻关等。此外，上云用数赋智行动、十四五规划等相关政策均对央企数字化转型提出了指导方向。
（2）应对不确定性：实现核心技术自主可控以及稳定运营 中美贸易摩擦、新冠疫情、俄乌冲突……面对外部日益增加的不确定性，中央企业肩负着实现核心技术自主可控以及稳定运营的责任。需要加快产业瓶颈和核心技术研发上的攻关进程，攻克“卡脖子”问题，做大做强国有资本，培育具有全球竞争力的世界一流企业。
（3）内生驱动：满足消费者新的新需求 经济与移动互联网的发展改变了消费者的行为模式，对传统企业经营提出新的挑战，央企需要洞察消费需求。
（4）体量/影响力大：是数字中国的重要组成部分 央企是中国经济的重要组成部分（2020年央企营收占GDP的34.8%），承担着试点验证的社会责任；央企具有行业多样性，上下游覆盖极广，具有强大的影响力（在十四五规划中提到的10个数字化应用场景中，央企覆盖6个），是实现数字中国举足轻重的一部分。
04 央企数字化转型的五大收益
（1）集团风险控制能力加强 数字技术可以帮助中央企业实现高效的集团管控。如，通过机器代人可以降低人员的操作风险，提高安全性和稳定性；同时，企业通过流程线上化可以更快地识别并应对风险。
（2）运营能力提升 数字化转型可以改变央企的决策模型，从而提升运营能力。企业数字化转型通过融合数据孤岛，建立不同部门数据之间的映射关系，从而方便管理人员从全局的角度出发，更好地做出决策。
（3）业务流程优化 各种新技术把越来越多的重复性人工任务转变为自动化任务，在流程中从人来执行转变为由人来监管与设计，并由此来提升效率。同时，基于大数据、人工智能等技术，建立数据之间的映射关系，将赋能优化生产节奏。
（4）财务收益 数字化转型投资金额巨大，但仍存在明显投资回报。世界经济论坛通过对1.6万家企业数据进行分析发现，数字化转型的领军企业生产率提高了70%，而跟随者生产率提升了30%。这意味着数字化转型领军存在着明显的先发制人的优势。
（5）商业模式创新 企业的商业模式是满足客户需求、实现相关方（客户、员工、合作伙伴、股东等）价值，同时使系统达成持续盈利目标的整体解决方案。企业的商业模式主要由创造价值、传递价值和获取价值三个组成部分构成。数字化转型通过重塑这三方面来帮助企业实现商业模式创新。
05 央企数字化分为三个阶段
（1）战略规划阶 战略规划阶段是企业从懵懂到形成全面认知的过程，具体可分为迷茫期、参考期以及勾勒期。该阶段企业一般通过自身调研以及和第三方研究机构合作，形成适应自身的数字化转型战略以及转型路径规划。
（2）业务试点阶段 业务试点阶段是企业数字化转型的关键阶段，该阶段的成功与否将直接影响企业数字化转型的进程。通过战略规划阶段输出的数字化转型的路径规划，谨慎选择业务转型试点，采用敏捷的方法，小步快走。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44f3d227ee26ac0f8ccc58c0987debe1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31e6ea9b8d5ce87391f812ba4f21f680/" rel="bookmark">
			华为是如何进行数据管理的？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自：公众号“PMO前沿”
内容整理自《华为数据之道》，机械工业出版社
元数据是描述数据的数据，用于打破业务和IT之间的语言障碍，帮助业务更好地理解数据。
元数据是数据中台的重要的基础设施，元数据治理贯彻数据产生、加工、消费的全过程，沉淀了数据资产，搭建了技术和业务的桥梁。
本文目录：
一、华为数据分类管理框架
二、元数据治理面临的挑战
三、元数据管理架构及策略
四、元数据与一体化建模管理
五、元数据与数据湖管理
六、元数据与数据服务管理
七、元数据与构建数据地图
一、 华为数据分类管理框架
华为根据数据特性及治理方法的不同对数据进行了分类定义：
(1) 内部数据和外部数据
(2) 结构化数据和非结构化数据。结构化数据又进一步划分为基础数据、主数据、事务数据、报告数据、观测数据和规则数据。
(3) 元数据
华为数据分类管理框架如图所示：
无论结构化数据，还是非结构化数据，或者内部数据还是外部数据，最终都会通过元数据治理落地。
华为将元数据治理贯穿整个数据价值流，覆盖从数据产生、汇聚、加工到消费的全生命周期。
相较于结构化数据，非结构化元数据管理除了需要管理文件对象的标题、格式、Owner等基本特征和定义外，还需对数据内容的客观理解进行管理，如标签、相似性检索、相似性连接等，以便于用户搜索和消费使用。因此，非结构化数据的治理核心是对其基本特征与内容进行提取，并通过元数据落地来开展的。
非结构化数据的管理模型如图所示
二、 元数据治理面临的挑战
华为在进行元数据治理以前，遇到的元数据问题主要表现为数据找不到、读不懂、不可信，数据分析师们往往会陷入数据沼泽中，例如以下常见的场景：
● 某子公司需要从发货数据里对设备保修和维保进行区分，用来不对过保设备进行服务场景分析。为此，数据分析师需面对几十个IT系统，不知道该从哪里拿到合适的数据。
● 因盘点内部要货的研发领料情况，需要从IT系统中获取研发内部的要货数据，面对复杂的数据存储结构（涉及超过40个物理表和超过1000个字段）、物理层和业务层脱离的情况，业务部门的数据分析师无法读懂物理层数据，只能提出需求向IT系统求助。
● 某子公司存货和收入管理需要做繁重的数据收集与获取工作，运行一次计划耗时超过20个小时。同时，由于销售、供应、交付各领域计划的语言不通，还需要数据分析师进行大量人工转换与人工校验。
以上场景频繁出现在公司日常运营的各个环节，极大地阻碍了公司数字化转型的进行，其根本原因就在于：
1) 业务元数据与技术元数据未打通，导致业务读不懂IT系统中的数据。
2) 缺乏面向普通业务人员的准确、高效的数据搜索工具，业务人员无法快速获取可信数据。
元数据管理的痛点如图所示
为解决以上痛点，华为建立了公司级的元数据管理机制：
制定了统一的元数据管理方法、机制和平台，拉通业务语言和机器语言。
确保数据“入湖有依据，出湖可检索”成为华为元数据管理的使命与目标。
基于高质量的元数据，通过数据地图就能在企业内部实现方便的数据搜索。
元数据通常分为业务、技术和操作三类：
1) 业务元数据：用户访问数据时了解业务含义的途径，包括资产目录、Owner、数据密级等。
2) 技术元数据：实施人员开发系统时使用的数据，包括物理模型的表与字段、ETL规则、集成关系等。
3) 操作元数据：数据处理日志及运营情况数据，包括调度频度、访问记录等。
在企业的数字化运营中，元数据作用于整个价值流，在从数据源到数据消费的五个环节中都能充分体现元数据管理的价值：
（1) 数据消费侧：元数据能支持企业指标、报表的动态构建。
（2) 数据服务侧：元数据支持数据服务的统一管理和运营，并实现利用元数据驱动IT敏捷开发。
（3) 数据主题侧：元数据统一管理分析模型，敏捷响应井喷式增长的数据分析需求，支持数据增值、数据变现。
（4) 数据湖侧：元数据能实现暗数据的透明化，增强数据活性，并能解决数据治理与IT落地脱节的问题。
（5) 数据源侧：元数据支撑业务管理规则有效落地，保障数据内容合格、合规。
三、 元数据管理架构及策略
元数据管理架构包括产生元数据、采集元数据、注册元数据和运维元数据：
1) 产生元数据：制定元数据管理相关流程与规范的落地方案，在IT产品开发过程中实现业务元数据与技术元数据的连接。
2) 采集元数据：通过统一的元模型从各类IT系统中自动采集元数据。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/31e6ea9b8d5ce87391f812ba4f21f680/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d3066032110482b7d7ada03c41c3c03/" rel="bookmark">
			对 “业务“ 这个概念的思考
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1》"业务" 貌似有涵盖代码逻辑业务，也就是在使用代码，将各个数据库表的数据以及客户输入的数据相互关联操作的这部分内容，应该算是代码逻辑，算是在代码里写的 "业务代码"。
2》"业务" 同时也应该是软件的功能需求，这个同样是与数据库关系设计挂钩，但又同时与展示给客户的直观页面效果相互交错，这个比较模糊，应该也算是一种业务。
3》"业务" 还应该是对于客户而言，在没有软件或者已有老的软件来处理的繁琐的工作流程，对于客户而言的业务，这个与软件可能是有些区别的，软件可能为了提升客户处理其业务的效率，可能也解决一些没有软件介入时的痛点，基于它（客户的业务），实现它，升级它。（这个我实在费解，文学素养低，有点不知所措，也不知道如何正确描述出来，见谅）。
除此之外，貌似还有我没有想到的。
对于这些理解，作为程序员，应该怎样看待这几种方面的业务呢？
第一种，工作中直接面对的，对这种业务代码，当然是再熟悉不过；
第二种，也许跟产品经理产出的需求文档，或者UI给出的原型图（产品理需求，UI 出原型，我目前是这么理解的，本人菜鸡一只，如有不对，还请多多指正），以及具体实现的细节挂钩，这种可能偏前端多一些，后端当然也要注意其中的细节问题；
第三种，我觉得有点无从下手，该不该了解它？为什么了解？怎样了解？以及，"这是不是我简单理解的这个系统，几个模块，那个模块什么小模块是做什么的，怎么做，什么流程"，这实在令我费解。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1af20b6b9fce848c4f002b98823dfed/" rel="bookmark">
			Chromium 历史版本离线安装包 - 下载方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 下载地址（非官网，但文件地址是官方的）：https://vikyd.github.io/download-chromium-history-version/
目录 概述Chrome 离线包 - 最新版（官方）Chrome 离线包 - 历史版本（官方）Chrome 离线包 - 历史版本（非官方） 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85c558762e215423b6bfc59998ccfa66/" rel="bookmark">
			Java浅学-方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法的定义 public 返回数据类型 方法名 （形参列表）{//方法体
语句;
return 返回值;
}
public：访问修饰符（作用是控制方法使用的范围，有四种：public，默认，protected，private）。
方法主体：为实现某一功能的代码块。
return 语句：不是必须要有的。
方法体 方法体里面不能嵌套方法，即方法不能嵌套定义。
1.public 表示该方法是公开的。
2.void 表示该方法没有返回值。
3.speak() speak是方法名，（）内用来放形参。
4.{ } 方法体，里面写我们要执行的代码。
**************************************************************************************************************
1.public 表示该方法是公共的。
2.int 表示该方法执行后，返回一个 int 类型的值。
3.getSum 是该方法名。
4.（int num1，int num2） 形参列表，用户可以传入两个数。
5.return res 表示把 res 的值，返回。
方法调用机制 方法调用细节 1.同一个类中，若有多个方法，其中一个要调用另一个，可以直接调用。
2.A类中的方法调用B类中的方法，需要先创建B对象，再调用B类中的方法即可。
3.跨类的方法调用和方法的访问修饰符有关。
返回数据类型 1.一个方法最多有一个返回值。（如果返回多个结果，返回数组）
2.如果方法是void，则方法体中可以没有return，或者只写return。
方法名遵循驼峰命名法，做到见其名知其意。
形参列表 1.一个方法中可以没有参数，也可以有多个参数，中间用逗号隔开。
2.参数类型可以为任意类型，包含基本类型或引用类型。
3.调用带参数的方法时，一定对应着参数列表传入相同类型或兼容类型的参数。
4.形参和实参的类型要一致或兼容，个数，顺序必须一致。
方法传参机制 基本数据类型的传参机制
基本数据类型，传递的是值，形参的任何改变不影响实参。
引用数据类型的传参机制
引用类型传递的是地址，可以通过形参影响实参。 Ending： OK，本篇文章就到此结束了，非常感谢你能看到这里，所以如果你觉得这篇文章对你有帮助的话，请点一个大大的赞，支持一下博主，若你觉得有什么问题或疑问，欢迎私信博主或在评论区指出~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b3eae034fa3d16c5cea8edc0b23e19e/" rel="bookmark">
			Mybatis-Pagehelper参数supportMethodsArguments引起的血案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0x00 背景 一个历史悠久的项目，使用的技术栈主要是 spring cloud 体系，属于 service 范畴，不给外部提供接口，但是集成了 myabtis-pagehelper，具体的版本如下：
&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.4.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; 相关的配置：
pagehelper: helperDialect: mysql reasonable: true supportMethodsArguments: true params: count=countSql 0x01 现象描述 同事在这个项目中新增加了一个总能，属于定时执行的，循环取数据，每次取 1000 条，但是上线后发现第一次能正常查询出数据，但是第二次往后就查询不出数据了，但是数据库中是有数据的。SQL 如下：
-- sql 已经做简化处理 select * from ${tableName} where type = #{type,jdbcType=VARCHAR} and time &gt;= #{time,jdbcType=TIMESTAMP} &lt;if test="pageSize != null and pageSize != '' and pageNum!=null and pageNum!=''"&gt; limit #{pageNum}, #{pageSize} &lt;/if&gt; 0x02 问题分析 刚刚开始以为是 sql 和数据的问题，一顿分析，将 sql 的参数参数打印出来后，用工具查询发现是能查询出数据的。由此判断不是参数以及sql 的问题，于是添加 mybatis 的参数将 sql 打印出来。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b3eae034fa3d16c5cea8edc0b23e19e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0dce74efe68b4f7c8f409aec00e058d5/" rel="bookmark">
			通过PWM来调节LED灯的亮度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 把点灯过程放慢，通过时间周期来延时点灯过程，定义一个周期CYCLE给定初始值，给一个累加变量向初始周期靠拢，来实现呼吸灯效果。
代码演示：
#include&lt;reg52.h&gt; sbit LED0=P1^0; void Delay(unsigned int t); //函数声明 void main (void) { unsigned int CYCLE=600,PWM_LOW=0;//定义周期并赋值 while (1) //主循环 { LED0=1; Delay(60000); //特意加延时，可以看到熄灭的过程 for(PWM_LOW=1;PWM_LOW&lt;CYCLE;PWM_LOW++){ //PWM_LOW表示低 //电平时间，这个循环中低电平时长从1累加到CYCLE（周期）的值，即600次 LED0=0; //点亮LED Delay(PWM_LOW);//延时长度，600次循环中从1加至599 LED0=1; //熄灭LED Delay(CYCLE-PWM_LOW);//延时长度，600次循环中从599减至1 } LED0=0; for(PWM_LOW=CYCLE-1;PWM_LOW&gt;0;PWM_LOW--){ //与逐渐变亮相反的过程 LED0=0; Delay(PWM_LOW); LED0=1; Delay(CYCLE-PWM_LOW); } //主循环中添加其他需要一直工作的程序 } } /*------------------------------------------------ 延时函数，含有输入参数 unsigned int t，无返回值 unsigned int 是定义无符号整形变量，其值的范围是 0~65535 ------------------------------------------------*/ void Delay(unsigned int t) { while(--t); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68152a5deb1d07ce5f0450fa07584c1c/" rel="bookmark">
			用 Pycharm 远程连接 Linux 服务器——超详细
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用 Pycharm 远程连接 Linux 服务器——超详细 一、介绍二、要求三、服务器配置四、Pycharm远程连接Linux服务器 实战 一、介绍 本人是做NLP的，pycharm写的项目，数据集很大，在自己电脑上运行很慢，但是放到服务器上跑就很快。下面详细介绍一下 用 Pycharm 远程连接 Linux 服务器 的相关配置——超级详细，
每一步骤 都有截图说明。
二、要求 首先，必须是**专业版的pycharm**, 如果用的是社区版pycharm,要换成专业版的。
三、服务器配置 （1）首先打开linux服务器终端进入Annaconda环境
conda activate pytorch-pk
pytorch-pk 是 自己创建conda环境的名字，要改成自己的环境名字哟
（2）给用户pk配置权限
cd ~ 返回到最外层目录cd /home 进入home目录ls 查看当前目录sudo chmod -R 777 pk
给用户pk配置管理员权限（配置成功后，用户pk颜色加深，表示管理员权限）
（使用这个命令，是 如果提示错误，输入cd.. 退到上级目录，再用这个命令即可）
（pk是用户，要输入自己服务器上的角色） （3）创建 自己电脑中的项目目录
我电脑pycharm中的，要上传服务器的项目名：pkk2
要在服务器上创建一个跟 自己电脑项目名：pkk2 同名的目录，用来存放 上传的 项目pkk2
sudo mkdir pkk2
（4）配置pycharm
File——Settings——Project competition——Python Interpreter——Add——SSH Interpreter
配置用户名和密码 （Host和Username）
Host：服务器ip (服务器终端输入ifconfig查看)
Username:服务器用户名（我这里是dell）
要配置两个
python路径项目pkk2路径 如果下次再次上次新的项目，可以点 Tools-Deployment-Configuration-Mappings-Deployment path 改成服务器上建立的和本地相同的项目名 所在目录
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/68152a5deb1d07ce5f0450fa07584c1c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb27c7dbd0e0039f307fe3f0bbd1751e/" rel="bookmark">
			Qt 定时器放在线程中执行，支持随时开始和停止定时器。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：因为项目需要定时检查网络中设备是否能连通，需要定时去做ping操作，若是网络不通，则ping花费时间比较久（局域网大概4秒钟才能结束，当然如果设置超时时间啥的，也能很快返回，就是会报QProcess提前关闭的警告）。此外，我想要在设备连接后才去开始定时ping，要是断开后，则停止定时器，停止ping。网上有很多定时器使用线程的例子，但是没有讲到可以随时停止和开始的那种，本文结合实例，使用线程去执行定时器的定时操作。
一、定义定时器和线程变量。
在头文件中定义
#include &lt;QTimer&gt; #include &lt;QThread&gt; #include &lt;QString&gt; #include &lt;QProcess&gt; /** 监听网线拔出或者wifi断开情况的定时器 ***/ QTimer *detectNetCablePulloutTimer = NULL; /** 执行定时器的线程 **/ QThread *detectNetCablePulloutTimerThread = NULL; /** 开始检测网线拔出时或者wifi断开时的定时器 **/ void startDetectNetCablePulloutTimer(); /** 停止定时器 **/ void stopDetectNetCablePulloutTimer(); private slots: /** 检测网络连接情况的槽函数，在线程中执行 **/ void checkDeviceIsOnline(); 二、开始定时器、停止定时器以及销毁定时器代码。
开始定时器代码：
void CurrentXXXClass::startDetectNetCablePulloutTimer() { // 先停止，确保开始之前是停止状态 stopDetectNetCablePulloutTimer(); if (detectNetCablePulloutTimer == NULL) { detectNetCablePulloutTimerThread = new QThread(this); detectNetCablePulloutTimer = new QTimer(); // 5秒执行一次，局域网断开时，一般耗时4-5秒 detectNetCablePulloutTimer-&gt;setInterval(5000); // 定时操作放在线程中执行 detectNetCablePulloutTimer-&gt;moveToThread(detectNetCablePulloutTimerThread); // 定时任务放在线程中执行, 必须指定参数-Qt::DirectConnection connect(detectNetCablePulloutTimer, &amp;QTimer::timeout, this, &amp;CurrentXXXClass::checkDeviceIsOnline, Qt::DirectConnection); void (QTimer::*pStartFun)() = &amp;QTimer::start; // 线程开始时，调用定时器的开始 connect(detectNetCablePulloutTimerThread, &amp;QThread::started, detectNetCablePulloutTimer, pStartFun); // 线程结束时，调用定时器的结束，所以要停止定时器，只要调用线程的quit方法， // 同时防止提示：定时器停止和开始不在同一线程错误 connect(detectNetCablePulloutTimerThread, &amp;QThread::finished, detectNetCablePulloutTimer, &amp;QTimer::stop); } detectNetCablePulloutTimerThread-&gt;start(); } 停止定时器代码：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb27c7dbd0e0039f307fe3f0bbd1751e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd914d45783de0c297db1294288cec21/" rel="bookmark">
			2023最新华为OD机试，独家整理总结上岸技巧，答读者问华为OD 华为OD机试备考攻略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 华为OD在线刷题OJ华为OD统一考试A卷+B卷 新题库说明什么是华为OD🙄华为 OD 应聘流程🧐华为 od 机试 ：机试、 分数、 院校问题😁华为 OD 机试：二本院校有机会吗?🙄华为 OD 机试：跨专业可以参加华为OD华为 OD 机试：机试时可以看到错误的用例吗华为 OD 机试：华为 OD 简历被锁定华为 OD 机试：正式员工与OD员工的区别华为 OD 机试：华为 od 岗的薪资待遇华为 OD 机试：华为OD能不能转正，转正要求及转正率怎么样题库目录2023华为OD统一考试（B卷） - 100分值2023华为OD统一考试（B卷） - 200分值华为OD统一考试【A卷】题库-100分华为OD统一考试【A卷】题库-200分 华为OD在线刷题OJ 全新华为OD在线刷题平台登场！解锁上岸华为OD的终极秘籍！
亲爱的华为OD候选人们，你们期待已久的刷题平台终于来了！全新的华为OD机试在线刷题平台已经上线，为你们提供了一个全新的学习和提升华为OD机考编程技能的机会！无论你是初学者还是有经验的程序员，相信这个平台将成为你们上岸华为OD的终极秘籍！
【华为OD在线刷题OJ-点击立即开始刷题】)
华为OD统一考试A卷+B卷 新题库说明 2023年5月份，华为官方已经将的 2022/0223Q(1/2/3/4)统一修改为OD统一考试（A卷）和OD统一考试（B卷）。
你收到的链接上面会标注A卷还是B卷。请注意：根据反馈，目前大部分收到的都是B卷。但是仍有概率抽到A卷。
A卷对应2023的新题库（2022Q4 20223Q1） B卷对应20022部分考题以及新出的题目
专栏：2023华为OD机试(A卷+B卷)（C++JavaJSPy）
专栏：2023华为OD机试(A卷)（C++ Java JS Py）
专栏：2023华为OD机试(B卷)（C++ Java JS Py）
什么是华为OD🙄 华为OD员工并非华为公司员工，而是由外包公司德科派驻到华为工作。德科是OD员工的雇主，负责签订合同和管理劳务关系，并发放工资和福利。华为推行同工同酬，所以OD的薪资与正式员工差不多。TIPS：每年都有OD员工转为正式员工。
华为OD的入职考核相当严格，特别是在信息安全和日常考核方面，行业内也有很多评论。试用期转正相对容易，主要看个人是否适应公司文化和业务能力是否达标。虽然公司提倡狼性文化，但试用期不通过的情况比较少。入职后还会进行背景调查，应该实事求是，不要犯傻。公司不会随便找理由裁员，因为面试周期和培训成本都很高。华为OD作为华为的后备资源池，考察员工绩效的标准和内部员工一样严格，因为最终目的是从中提取人才。因此，员工需要有危机意识，努力工作，做好自己，才能在任何公司中脱颖而出。
华为 OD 应聘流程🧐 第一步：投递简历
提供姓名、邮箱、手机号、身份证号，用于锁定，所以投递前需要考虑清楚，投到项目组之后，一般不会转给另一个项目的 HR 了，也就是被锁定。
第二步：机试
3 道算法题，400 分满分，没有过半年之后才能参加下一次考试。
第三步：技术面
2 轮技术面试。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd914d45783de0c297db1294288cec21/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9414e4a1288a426a74336f85fccaeaa7/" rel="bookmark">
			Spring——Spring常用注解原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要 spring中注解本身没有功能的，就和 xml 一样。注解和 xml 都是一种元数据，元数据即解释数据的数据，这就是所谓配置。因此需要了解spring的常用注解的加载原理，本博文将介绍的spring中常用的注解类型和使用，同时将分析注解的加载和配置原理，帮助大家更好理解和使用spring的注解的功能。
一、spring常用注解 1.1 声明bean的注解 @Component 组件，没有明确的角色：@Component ：通用的注解，可标注任意类为 Spring 组件。如果一个 Bean 不知道属于哪个层，可以使用@Component 注解标注。
@Service 在业务逻辑层使用（service层）：对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层。
@Repository 在数据访问层使用（dao层）：对应持久层即 Dao 层，主要用于数据库相关操作
@Controller 在展现层使用，控制器的声明（C）：对应 Spring MVC 控制层，主要用户接受用户请求并调用 Service 层返回数据给前端页面。
@RestController;@RestController注解是@Controller和@ResponseBody的合集,表示这是个控制器 bean,并且是将函数的返回值直 接填入 HTTP 响应体中,是 REST 风格的控制器。
单独使用 @Controller 不加 @ResponseBody的话一般使用在要返回一个视图的情况，这种情况属于比较传统的 Spring MVC 的应用，对应于前后端不分离的情况。@Controller +@ResponseBody 返回 JSON 或 XML 形式数据
1.2 注入bean的注解 @Autowired：由Spring提供：自动导入对象到类中，被注入进的类同样要被 Spring 容器管理比如：Service 类注入到 Controller 类中。
@Service public class UserService { …… } @RestController @RequestMapping("/users") public class UserController { @Autowired private UserService userService; } @Inject：由JSR-330提供
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9414e4a1288a426a74336f85fccaeaa7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8fe621e75ef9c60c18dc2627211dc2d0/" rel="bookmark">
			第七章-分布式搜索引擎-ES：全文查询、分词查询、精确查询、地理坐标查询、组合查询（bool、funtion_score）以及RestApi
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DSL查询文档 DSL查询分类
全文查询、分词查询、非分词查询、地理坐标查询、组合查询
match_all 查询所有，不需要查询条件，固定写法_search
第一个hits就是命中的数据 ，total就是条数，第二个hits是source嘞
全文检索查询
我们不要整多个字段查询，参与的字段越多，查询速度越慢，如果有多个字段，可以把这几个字段copy_to到一个字段去查，如all，第一种效查询效率更高
query查询条件text就是输入的内容，比如”酒店“，fields就是字段名字
精确查询
term确保搜索的内容，和文档的内容一模一样 范围range：gte是大于等于，let小于等于，
如果把e去掉，就是大于不等于，或小于不等于
地理坐标查询
第一种查询
top_left:是一个点，左上角的点
bottom_right :也是一个点，右下角的点
两个点形成一个矩形，矩形范围内的就是文档能查出来的数据，比如打车，在我这个圆圈只内的车
适合查一定范围内的信息，比如说按照地图找房子，找酒店等
矩形查询的比较少，一般都是一个圆圈
第二种查询
field：中心点，有点类似于我的位置，或者家庭住址的位置等，然后周边扩撒
15km，就是以field的中心点画一个半径，根据半径画一个圆，这个圆圈起来的所有的点，就是符合的文档
location ：是根据中心点（可以自己定位，我的位置）查询在文档符合条件的location的经纬度
字段location：是根据这个点，找文档里在这个距离内符合条件的数据
以上查询都叫简单查询 组合查询，也叫复合查询
人工对搜索排名实现干预，比如百度搜索，我给钱多，就排第一
过滤条件，决定那些文档需要加分 算分文档三要素
1、那些文档要加分2、算分函数是啥3、加权模式是啥 查询可以知道外滩的如家分数最低，才4.0分 比如说我想让如家跑到第一名去，查询的时候就加上过滤条件算分函数，和算法，给他加了20分，已经是24分了
注意，这里是查询，实际上并不会修改文档，只是在查询的结果集上给分数加了点数而已
组合查询
案例：价格不高于，就是低于，可以取反
dsl语法，注意，放到mast或should里边都会影响算分的，参与算分的越多，性能越差 GET /hotel/_search { "query": { "bool": { "must": [ { "match": { "name": "如家" } } ], "filter": [ { "geo_distance": { "distance": "10km", "location": { "lat": 31.21, "lon": 121.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8fe621e75ef9c60c18dc2627211dc2d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/baa60ba998663bf3d4700c83dc7fd9ab/" rel="bookmark">
			镜像的基本命令（docker）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、docker命令介绍1、帮助命令2、显示镜像3、搜索镜像4、下载镜像5、删除镜像 总结 前言 本文主要介绍docker中与镜像相关的一些命令，是对狂神课程的一些总结，作为一个手册帮助博主和使用docker的同学们来查找和回忆。
实验环境：Xshell+CentOS+docker
一、docker命令介绍 1、帮助命令 docker version #查看docker的版本信息 docker info #显示docker的系统信息，包括镜像和容器的数量 docker 命令 --help 前两个命令在这里不再赘述，我们主要演示一下最后一条帮助命令的用法：
当我们对docker中的某一条命令的选项和该命令的用处不太清楚的时候，比如我们要查看docker images的选项时，我们可以使用这条帮助命令。
如上图所示我们就能查看到docker images命令的介绍和该命令可使用的选项。
2、显示镜像 docker images [可选项]#查看所有本地的主机上的镜像 如上图所示我们可以查看到我们本地的主机上的镜像的相关信息如：
名称介绍REPOSITORY镜像的仓库源TAG镜像的标签（镜像的版本号）IMAGE ID镜像的idCREATED镜像的创建时间SIZE镜像的大小 选项介绍：
-a – all
作用：列出所有镜像
-q --quiet
只列出镜像的ID
3、搜索镜像 Ps：在dockerhub中有许多镜像可以供我们使用，我们使用该命令与在dockerhub搜索镜像的作用相同
docker search [可选项]#搜索镜像 如下图所示我们搜索mysql镜像：
选项介绍：
–filter
用法：可选项用来过滤，筛选自己想要寻找的镜像
如上图所示搜索到点赞量大于3000的mysql镜像。 4、下载镜像 docker pull 镜像名[:tag]#tag是版本号可以在dockerhub上查看，如果不加tag那就是默认latest 如下图我们直接下载一个centos的镜像：
5、删除镜像 docker rmi -f 镜像名或镜像ID #删除单个镜像 docker rmi -f 镜像ID 镜像ID ... #删除多个镜像 docker rmi -f $(docker images -aq)#删除所有镜像 如下所示我们删除我们刚刚下载的centos镜像：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/baa60ba998663bf3d4700c83dc7fd9ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93205b644de0a16dbe5e1772f8070920/" rel="bookmark">
			解决python自带的IDLE编译器打不开，并默认使用IDLE打开py文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 python的IDLE编译器打不开修改py文件默认启动方式结束 python的IDLE编译器打不开 这是python自带的一个编译器，虽然很简陋，但它重要的功能不在日常编码。
它其实就是python文件夹下的 pythonw.exe文件，用它启动py文件可以实现无黑窗的启动模式，有GUI图形界面的项目更适合使用。
这个文件具体的启动文件位置为 C:\python3.10\Lib\idlelib\idle.py（替换你自己python所在的文件夹）。
pythonw.exe和idle.py，本质是一个文件，前者是对后者的打包。
但是我的pythonw文件启动闪退，idle.py文件也打不开。
解决方法如下：
首先在idle.py文件的文件夹下按住shift键后鼠标右键，在此处打开powershell
输入如下代码 运行idle.py，查看报错内容：
python idle.py 我的报错内容为：
UnicodeDecodeError: ‘utf-8’ codec can’t decode byte 0xc8 in position
23: invalid continuation byte
可以看到这是一个编码错误的报错，因为我打开了win10 系统里的UTF-8编码的Beta，
关闭后，重启电脑，idle文件以及pythonw文件都能打开了
修改py文件默认启动方式 进入设置修改py文件的默认应用
如果没有显示白色的python（也就是pythonw.exe），先把一个py文件的打开方式使用这个pythonw.exe打开一次就有了
黑色的python图标是启动时有黑窗的，白色的python图标是启动无黑窗的(IDLE)
结束 这样就默认启动python项目没有黑窗了，那个UTF-8的beta编码模式，会导致python编写IDLE文件的代码编译出错，win10的编码真是多灾多难，我经常要开关这个beta开关…
然而即使IDLE打不开，这种情况下python编译器是没问题的，可以使用vscode写代码，一样运行，没有影响。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f13f671742621653af98a9fcf0eaf650/" rel="bookmark">
			基于51单片机的八路抢答器Protues仿真设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、设计背景
二、实现功能
三、仿真演示
四、源程序（部分）
一、设计背景 近年来随着科技的飞速发展，单片机的应用正在不断的走向深入。本文阐述了基于51单片机的八路抢答器设计。本设计中，51单片机充当了核心控制器的角色，通过IO口与各个功能模块相连接。按键模块负责检测参与者的抢答动作，当有人按下抢答按钮时，会通过IO口电平的变化通知单片机，单片机会记录按键的次序，并通过数码管显示当前的抢答结果。
为了保证抢答过程的准确性和公平性，设计中还需要考虑到以下因素。首先，按键模块需要具备快速响应和高可靠性，以确保抢答者的动作能够被准确地捕捉到。其次，显示屏模块需要能够实时更新抢答结果，并显示相应的信息，比如参与者的编号和抢答时间。最后，在电路连接方面，需要注意各个模块之间的线路布局，以避免信号干扰和电气问题。
软件系统采用C语言编写程序，包括显示程序，定时中断服务，延时程序等，并在KEIL5中调试运行，硬件系统利用PROTEUS8.11强大的功能来实现，简单切易于观察，在仿真中就可以观察到实际的工作状态。
二、实现功能 以51单片机为控制核心，设计一种八路抢答器。整个系统包括MCU、晶振电路、时钟电路、功能按键以及数码管显示。该系统利用共阳数码管实时显示抢答倒计时时间，通过独立按键设计控制抢答器的启动、复位、以及不同选手的抢答。可具体实现以下功能：
(1) 按下启动键后，在20s倒计时的过程中，按下任意路抢答按键，数码管上对应显示抢答选手的序号并清零倒计时。
(2) 按下复位键后，抢答器复位，再次按下启动键可以实现新一轮的抢答。
(3)·定时器定时50ms，20次定时可产生1秒钟计时。
(4) 抢答倒计时开始抢答指示灯亮起，抢答结束，按下复位按键后指示灯熄灭。
三、仿真演示 运行仿真，未按下总开关按键，数码管不显示。
按下系统总开关后，进入准备界面，数码管显示默认抢答序号0和抢答倒计时20秒。
按下启动按键，进入抢答界面，开始20秒抢答倒计时，并在数码管上实时显示。
在抢答倒计时范围内，按下序号为1~8的选手抢答按键，抢答倒计时归零，数码管上显示抢答选手序号和倒计时00秒。
按下复位按键后，恢复到准备界面，按下启动按钮进行下一次抢答。
四、源程序（部分） #include "reg52.h" #include "delay.h" #include "smg.h" #include "timer.h" sbit kaishi=P3^1; sbit key1 = P1^0; sbit key2 = P1^1; sbit key3 = P1^2; sbit key4 = P1^3; sbit key5 = P1^4; sbit key6 = P1^5; sbit key7 = P1^6; sbit key8 = P1^7; sbit state = P3^4; sbit reset = P3^7; sbit start_stop = P3^6; _bool action = 0; _bool kaishi_flag=0; _bool key1_flag = 0; _bool key2_flag = 0; _bool key3_flag = 0; _bool key4_flag = 0; _bool key5_flag = 0; _bool key6_flag = 0; _bool key7_flag = 0; _bool key8_flag = 0; _bool reset_flag = 0; _bool start_stop_flag = 0; uint8 second = 20; uint8 timer0_count = 0; uint8 number = 0; uint8 number_display = 0; uint8 key_scan8(void); void reset_keyscan(void); void start_stop_keyscan(void); /*----------------------------------------------------------- 主函数 ------------------------------------------------------------*/ void main() { ConfigTimer0(); while(1) {	while((kaishi == 0)&amp;&amp;(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f13f671742621653af98a9fcf0eaf650/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/785636a45f2bbbedf9a54ab802ce66a7/" rel="bookmark">
			批量处理excel文件的模块——xlwings
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、创建工作簿
1.函数介绍
二、保存工作簿
1.函数介绍
三、打开工作簿
四、操作工作表和单元格
1.输入文本
2.在打开的工作簿中新增一个工作表
3.综合应用
可以处理excel文件的python模块有很多，如xlsxwriter,xlrd,xlwt,xlutils,openpyxl和xlwings等，其中对比如下
功能/模块xlsxwriterxlrdxlwtxlutilsopenpyxlxlwings 读
×√×√√√写√×√√√√修改×××√√√支持xls格式×√√√×√支持xlsx格式√√√×√√支持批量操作×××××√ 通过上面表格可以看出，xlwings功能最为齐全
一、创建工作簿 import xlwings as xw app = xw.App(visible=True,add_book=False)#启动excel程序窗口 workbook = app.books.add()#新建工作簿 1.函数介绍 xlwings.APP(visible,add_book)
参数：
visible：用来设置excel程序可见性，如果为true，表示显示excel程序窗口，如果为false，表示隐藏excel程序窗口add_book：用来设置启动excel程序窗口后是否新建工作簿，如果为true，表示新建一个工作簿，如果为false，表示不新建工作 二、保存工作簿 import xlwings as xw app = xw.App(visible=True,add_book=False) workbook = app.books.add() #2.保存工作簿 workbook.save('d:\\example.xlsx') workbook.close()#关闭工作簿 app.quit()#退出excel程序 这段代码会在D盘下生成一个名为example.xlsx的工作簿
1.函数介绍 save(路径和文件名)
用来保存前面创建的空白工作簿，
一个文件的路径有2种标识方式：
绝对路径：表示文件的路径总是从根文件夹开始相对路径：表示相对于当前运行的代码文件的路径 close()用来关闭创建的工作簿
quit()用来退出excel程序
三、打开工作簿 import xlwings as xw app = xw.App(visible=True,add_book=False) #3.打开工作簿 workbook = app.books.open(r'd:\example.xlsx') 四、操作工作表和单元格 1.输入文本 import xlwings as xw app = xw.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/785636a45f2bbbedf9a54ab802ce66a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8383358bb218f38a0d57384602059e48/" rel="bookmark">
			winserver 2012 R2 部署记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记一次winserver2012 R2 环境部署，程序要求 framework4.6.1
安装好之后发现报错，提示运行环境没有 4.6.1 支持，需要安装
于是先装了 chs 版本，发现报错。
再次打开卸载，重新安装enu版本，发现程序正常。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40080ed3d2f741d58ddccc37890ccbb2/" rel="bookmark">
			IVIEW的modal一闪而过，偶发性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 that.$Modal.confirm 两个modal ， 上一个modal 还没有彻底关闭 ，下一个modal 就开启了 导致第二个modal 一闪而过 ，问题是偶发性的 ，由于 是第一个弹框点击确认才开启的第二个弹框，就设置一个setTimeout 500 的延迟 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f9a0b6ba0bb272a69882e42893d156e/" rel="bookmark">
			Android11 有线网和wifi优先级设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、优先级基本知识介绍 Android6.0之后系统中优先级设置都是根据Score分值来设置优先级，分值0-100，数值越高，越优先。
系统默认分值： SIM卡网络 50 wifi网络 60 有线网络 70 手机网络设置都有自己的Factory设置类，都继承自NetworkFactory.java
wifi网络设置类：WifiNetworkFactory.java packages/modules/Wifi/service/java/com/android/server/wifi/WifiNetworkFactory.java
有线网络设置类：EthernetNetworkFactory.java frameworks\opt\net\ethernet\java\com\android\server\ethernet\EthernetNetworkFactory.java
移动网络设置类：TelephonyNetworkFactory.java
frameworks\opt\telephony\src\java\com\android\internal\telephony\dataconnection\TelephonyNetworkFactory.java
NetworkFactory的子类都有NETWORK_SCORE常量，表示该网络的分值。
二、有线网络优先级设置 1、在Android9.0设置有线网络优先级直接修改EthernetNetworkFactory.java的 NETWORK_SCORE 值就行 private final static int NETWORK_SCORE = 55; //change score from 70
但是我Android11 的代码修改后发现并不能生效,还是有线网优先。
研究了一下EthernetNetworkFactory.java和ConnectivityService.java发现里面的逻辑有很大的修改。
2、在Android11 修改有线网络优先级 找到EthernetNetworkFactory.java的getNetworkScore()方法，这里面返回的score才是有线网的有效分值；
这个getNetworkScore()方法是在Android11 新增的。
在该方法返回NETWORK_SCORE值即可。里面很多判断是没啥用的。
如果要wifi优先级高于有线，一定要设置有线网络的分值比wifi小，在后期测试过程中发现在某些情况，wifi的分值会变成20，把有线网络分值设置成15才生效。
adb是可以进行分值查看的，文章最后有描述。
三、网络优先级简单刨析 参考：
Framework中的连接管理机制： https://blog.csdn.net/u010961631/article/details/48629601
网络连接评分机制之NetworkFactory： https://blog.csdn.net/u010961631/article/details/48971431
网络连接评分机制之NetworkAgent： https://blog.csdn.net/u010961631/article/details/48971651
Android网络优先级及更改： https://blog.csdn.net/u013686019/article/details/51447129/
网上的代码都比较旧了，只能做思路参考，里面有些方法不一样了。
1、网络切换的主要逻辑都是在 ConnectivityService.java里面 ConnectivityService.java和WMS、AMS一样，都是在System_server里面启动的；
ConnectivityService.java里面会对NetworkFactory的网络连接子类进行保存和管理。
Android11 ConnectivityService
新增了NetworkProviderInfo是一个内部类，但是以前的NetworkAgentInfo还保留了；
2、优先级评分逻辑主要在evalRequest方法 NetworkFactory.java的evalRequest方法是评分的主要判断逻辑
private void evalRequest(NetworkRequestInfo n) { if (VDBG) { log("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f9a0b6ba0bb272a69882e42893d156e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51ed775adf293bbf6fc7e717d409deee/" rel="bookmark">
			laya快捷键
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ctrl+F6 构建html
Ctrl+F7 实时编译
Ctrl+F8 实时编译
F11 UI导出（不导出图集，图集不变的情况用这个会快很多）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04e688f9e14ab7ed417dac796e98f9cf/" rel="bookmark">
			Linux网络编程应用 文件传输：利用TCP、base64、C语言实现电脑与电脑、电脑与开发板之间进行文件传输（可传输文档图片视频任意文件）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		准备工作 1、base64的加密与解密的方法有很多种，可以直接使用Linux自带的base64命令，也可以使用一些base64库，或者base64源代码等等。
2、这里我使用的是在Gethub官网上下载的一个评价最高的base64包，先下载一下：
我先说明一下，这个包代码结构比较复杂，编译也需要更改一些东西，如果是大神建议直接下载第一个，可自行编译得到所需库文件，小白建议直接下载我编译好的两个库文件，也就是第二、三个。
（一）源base64包：
链接：https://pan.baidu.com/s/16cC4qOVCiascjvwuEbHlpg 提取码：lgi0
（二）64位系统下下载：
链接：https://pan.baidu.com/s/1mbTFmoPZsBEylw2I9M4uEA
提取码：zbxn
（三）32位arm开发板下载:
链接：https://pan.baidu.com/s/13Qop78nCKk-RHFLrLBeLMA 提取码：a6ch
电脑与电脑之间的传输 一、首先确定两台电脑是否处于同一局域网内
1、可以在教室或者工作室插上处于同一局域网的网线
2、可以利用一根网线实现电脑与电脑直连
二、下载好第二个base64包
你将会得到这样两个文件
使用它时只需要包含 libbase64.h 头文件，编译时链接静态库即可
三、编写测试代码
测试这个base64包是否能够编码与解码
#include &lt;stdio.h&gt; #include &lt;libbase64.h&gt; #include &lt;string.h&gt; int main(int argc,const char **argv) { char buf[] = "12345"; char base_buf[100]; //base64加密 size_t len; bzero(base_buf,strlen(base_buf)); base64_encode(buf,strlen(buf),base_buf,&amp;len,0); printf("base_buf:%s \n",base_buf); //base64解码 bzero(buf,strlen(buf)); base64_decode(base_buf,strlen(base_buf),buf,&amp;len,0); printf("解码后：%s\n",buf); return 0; } 编译命令：gcc main.c -o main -L. lbase64
运行：
三、编写代码
代码需要依赖：libbase64.a、libbase64.h下载第二个文件包即可。
需要两个代码，一个是发送文件，一个是接收文件
接收方：
recv.c
/*TCP客户端*/ #include &lt;stdio.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04e688f9e14ab7ed417dac796e98f9cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/332ffe61c5096bfe03717bfb3c432121/" rel="bookmark">
			centos7.6离线升级gcc
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先安装其他工具：
安装make:
centos7.6离线安装make
安装c++依赖包：
yum install gcc-c++ 1.下载需要的gcc，我这里下载的8.3.0版本：
各版本gcc下载地址
2.上传服务器后解压：
tar -zvxf gcc-8.3.0.tar.gz --directory=/usr/local/ 3.进入目录：
cd /usr/local/gcc-8.3.0/contrib 4.查看需要的依赖包具体是什么版本：分别是gmp，mpfr，mpc，isl
vim download_prerequisites 5.下载对应版本的依赖包;
gcc依赖包下载地址
6.把依赖包拷贝到gcc-8.3.0根目录解压：
可以直接全部解压，会同时创建软连接：
./contrib/download_prerequisites 或者也可以一步步单独解压，单独创建软连接：
解压： tar -xf gmp-6.1.0.tar.bz2 tar -xf mpfr-3.1.4.tar.bz2 tar -xf mpc-1.0.3.tar.gz tar -xf isl-0.18.tar.bz2 创建软连接： ln -sf gmp-6.1.0 gmp ln -sf mpfr-3.1.4 mpfr ln -sf mpc-1.0.3 mpc ln -sf isl-0.18 isl 7.如果遇到不能解压bz2文件的问题，下载安装bzip2，如果可以解压跳过此步骤:
bzip2下载地址
拷贝到服务器后执行：
rpm -ivh bzip2-1.0.6-13.el7.x86_64.rpm 测试验证：
bzip2 --help 8.进入gcc根目录创建build：
cd /usr/local/gcc-8.3.0 mkdir build cd build 安装：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/332ffe61c5096bfe03717bfb3c432121/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85ca793e77fe23ce7d89de5951b7811c/" rel="bookmark">
			hbase报错表不在线修复
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		# 问题描述
hbase，关机、重新启动之后，UI页面能打开，但是表都不见了。 查看master启动日志，有警告：显示元数据meta表not online。
2023-05-19 13:59:40,429 WARN [master/dqs09:16000:becomeActiveMaster] master.HMaster: hbase:meta,,1.1588230740 is NOT online; state={1588230740 state=OPEN, ts=1684475912431, server=dqs11,16020,1684466863338}; ServerCrashProcedures=true. Master startup cannot progress, in holding-pattern until region onlined.
UI页面里的表信息，system tables确实看不到meta，namespace表了
# 原因分析： UI界面，查看procedures &amp; locks:发现有4个procedure应该是locked了，分别是115 116 117 118
# 解决方案： 通过hbck2工具来修复。
1. 通过bypass命令，释放卡住的procedure
#hbase hbck -j &lt;HBCK jar 包路径&gt; -skip bypass [options] &lt;procedure PID&gt;
#-d 打印debug日志 -s 跳过hbase版本检测
/data01/hbase/bin/hbase --config /data01/hbase/conf hbck -j /data01/hbase-2.4.14/hbase-hbck2-1.3.0-SNAPSHOT.jar -d -s bypass 115 116 117 118
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/85ca793e77fe23ce7d89de5951b7811c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c8e40e1a43a03354e06c40489cdd133/" rel="bookmark">
			使用SpringBoot替代Nginx发布Vue3项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、新建一个SpringBoot项目
二、将Vue项目打包
三、打包文件放到SpringBoot中
四、配置反向代理
五、启动项目
六、集成案例
一、新建一个SpringBoot项目 （博主SpringBoot版本2.7.14）
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; 二、将Vue项目打包 （博主vue版本：3.2.44）
由于是要放在SpringBoot中，Java服务和Web服务用的是同一个端口，所以我们给前端一个统一的URL前缀来区分前端页面和后端接口。比如：/admin；配置方式如下：在src/router文件夹下找到路由文件，注意要用history模式，不要用哈希。
至于打包，就跟平时打包到nginx一样的去打包就行了。（不要添加base参数，画蛇添足！）
三、打包文件放到SpringBoot中 在SpringBoot的resources中新建static文件夹，然后将打包后的文件复制进来
四、配置反向代理 在nginx时候我们是配置了反向代理：（try_files $uri $uri/ /index.html）；从而将所有的url都代理到了index.html路径下。在SpringBoot中我们怎么办呢？
新建配置文件：MindWebMvcConfigurer。内容如下
package com.example.example; import org.springframework.context.annotation.Configuration; import org.springframework.web.servlet.config.annotation.ViewControllerRegistry; import org.springframework.web.servlet.config.annotation.WebMvcConfigurer; @Configuration public class MindWebMvcConfigurer implements WebMvcConfigurer { /** * 所有/admin/路径都代理到index.html下 * @param registry */ @Override public void addViewControllers(ViewControllerRegistry registry) { registry.addViewController("/admin/**").setViewName("forward:/index.html"); } } 五、启动项目 http://localhost:8080http://localhost:8080/admin/index
访问http://localhost:8080,会自动去找static下的index.html。访问http://localhost:8080/admin/**，也会被代理到index.html。 六、集成案例 以小诺开源项目为例：Snowy: 最新：💖国内首个国密前后分离快速开发平台💖，采用Vue3+AntDesignVue3 + Vite+SpringBoot+Mp+HuTool+SaToken。集成国密加解密插件，在前后分离框架中，实现前后分离“密”不可分；同时实现国产化机型、中间件、数据库适配，是您的不二之选；最后官网提供工作流、多租户、多数据源、Vue3表单设计器等丰富插件灵活使用。
使用IDEA拉取项目
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c8e40e1a43a03354e06c40489cdd133/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e555b18a57cc34a40e13b82912025af2/" rel="bookmark">
			vue2传值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		父传子：使用props //子组件内容
&lt;template&gt;
&lt;div id="app"&gt;
&lt;div&gt;姓名：{{ name }}&lt;/div&gt;
&lt;div&gt;年龄：{{ age }}&lt;/div&gt;
&lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
props: ["name", "age"],
};
&lt;/script&gt;
父组件
&lt;template&gt;
&lt;son1 :name="newname" :age="newage" @son1data="getdata"&gt;&lt;/son1&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
data(){
return {
newname:'李雷'，
newage:15
}
}
}
&lt;/script&gt;
原理就是通过props设置，绑定父级组件上的两个属性作为子组件的属性进行使用。
//子组件
data(){
return {
myname:this.name
}
}
子传父：使用$emit //子组件
&lt;template&gt;
&lt;div id="app"&gt;
&lt;div&gt;姓名：{{ name }}&lt;/div&gt;
&lt;div&gt;年龄：{{ age }}&lt;/div&gt;
&lt;div&gt;姓名1：{{ myname }}&lt;/div&gt;
&lt;div&gt;年龄1：{{ myage }}&lt;/div&gt;
&lt;button @click="son1emit"&gt;点击发送数据&lt;/button&gt;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e555b18a57cc34a40e13b82912025af2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8f8259674e79430dcb4a16adbaffbbb/" rel="bookmark">
			Pinia 快速入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
Vue3已经推出很长时间了，它周边的生态也是越来越完善了。之前我们使用Vue2的时候，Vuex可以说是必备的，它作为一个状态管理工具，给我们带来了极大的方便。Vue3推出后，虽然相对于Vue2很多东西都变了，但是核心的东西还是没有变的，比如说状态管理、路由等等。再Vue3种，尤大神推荐我们使用pinia来实现状态管理，他也说pinia就是Vuex的新版本。
那么pinia究竟是何方神圣，本篇文章带大家一起学透它！
1.pinia是什么？
如果你学过Vue2，那么你一定使用过Vuex。我们都知道Vuex在Vue2中主要充当状态管理的角色，所谓状态管理，简单来说就是一个存储数据的地方，存放在Vuex中的数据在各个组件中都能访问到，它是Vue生态中重要的组成部分。
既然Vuex那么重要，那么在Vue3中岂能丢弃！
在Vue3中，可以使用传统的Vuex来实现状态管理，也可以使用最新的pinia来实现状态管理，我们来看看官网如何解释pinia的。
官网解释：
Pinia 是 Vue 的存储库，它允许您跨组件/页面共享状态。
从上面官网的解释不难看出，pinia和Vuex的作用是一样的，它也充当的是一个存储数据的作用，存储在pinia的数据允许我们在各个组件中使用。
实际上，pinia就是Vuex的升级版，官网也说过，为了尊重原作者，所以取名pinia，而没有取名Vuex，所以大家可以直接将pinia比作为Vue3的Vuex。
2.为什么要使用pinia？
很多小伙伴内心是抗拒学习新东西的，比如我们这里所说的pinia，很多小伙伴可能就会抛出一系列的疑问：为什么要学习pinia？pinia有什么优点吗？既然Vue3还能使用Vuex为什么我还要学它？......
针对上面一系列的问题，我相信很多刚开始学习pinia的小伙伴都会有，包括我自己当初也有这个疑问。当然，这些问题其实都有答案，我们不可能平白无故的而去学习一样东西吧！肯定它有自己的优点的，所以我们这里先给出pinia的优点，大家心里先有个大概，当你熟练使用它之后，在会过头来看这些优点，相信你能理解。
优点：
Vue2和Vue3都支持，这让我们同时使用Vue2和Vue3的小伙伴都能很快上手。pinia中只有state、getter、action，抛弃了Vuex中的Mutation，Vuex中mutation一直都不太受小伙伴们的待见，pinia直接抛弃它了，这无疑减少了我们工作量。pinia中action支持同步和异步，Vuex不支持良好的Typescript支持，毕竟我们Vue3都推荐使用TS来编写，这个时候使用pinia就非常合适了无需再创建各个模块嵌套了，Vuex中如果数据过多，我们通常分模块来进行管理，稍显麻烦，而pinia中每个store都是独立的，互相不影响。体积非常小，只有1KB左右。pinia支持插件来扩展自身功能。支持服务端渲染。 pinia的优点还有非常多，上面列出的主要是它的一些主要优点，更多细节的地方还需要大家在使用的时候慢慢体会。
3.准备工作
想要学习pinia，最好有Vue3 的基础，明白组合式API是什么。如果你还不会Vue3，建议先去学习Vue3。
本篇文章讲解pinia时，全部基于Vue3来讲解，至于Vue2中如何使用pinia，小伙伴们可以自行去pinia官网学习，毕竟Vue2中使用pinia的还是少数。
项目搭建：
我们这里搭建一个最新的Vue3 + TS + Vite项目。
执行命令：
npm create vite@latest my-vite-app --template vue-ts
运行项目：
npm install npm run dev
删除app.vue中的其它无用代码，最终页面如下：
4.pinia基础使用
4.1 安装pinia
和vue-router、vuex等一样，我们想要使用pinia都需要先安装它，安装它也比较简单。
安装命令：
yarn add pinia # 或者使用 npm npm install pinia
安装完成后我们需要将pinia挂载到Vue应用中，也就是我们需要创建一个根存储传递给应用程序，简单来说就是创建一个存储数据的数据桶，放到应用程序中去。
修改main.js，引入pinia提供的createPinia方法，创建根存储。
代码如下：
// main.ts import { createApp } from "vue"; import App from "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b8f8259674e79430dcb4a16adbaffbbb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35832cfd40bfb8c112e2b73d8cfd5d0c/" rel="bookmark">
			Gitee拉取、推送、初次建立仓库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
更新代码到gitee
从gitee拉取代码
初次建立gitee仓库
更新代码到gitee 进入目标文件夹，在空白处右键，选择Git Bash Here 进入
git add . git commit -m "注释" git push origin master git add . 可能报错
解决：
git config --global core.autocrlf true 正常运行：
从gitee拉取代码 git pull 可能会报错：账号密码不正确
#重置密码命令 git config --system --unset credential.helper 初次建立gitee仓库 进入官网
建立仓库 创建成功： 配置
1.配置用户名和邮箱 git config --global user.name "xxx" git config --global user.email "xxx" 2.初始化本地仓库 git init 3.添加项目目录下所有文件至本地仓库 git add . 4.为提交的内容添加注释说明 git commit -m '本次提交的说明' 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/35832cfd40bfb8c112e2b73d8cfd5d0c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d25f23c8ded50c676885b8e5b7723be4/" rel="bookmark">
			Spring boot @ConditionalOnProperty 使用以及作用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		@ConditionalOnProperty 来源
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty; 即： 来源于Spring boot 中的自动化配置部分
实际作用：
通过读取本地配置文件中的值来判断 某些 Bean 或者 配置类 是否加入spring 中。
即 当前类通过 @Component 或者 @Configuration 注册实体到spring 中时，都可以通过 @ConditionalOnProperty 来控制是否加入或者说有无该项。
实际使用 与 @Component 或者 @Configuration 等同级，都置于类上
@ConditionalOnProperty(prefix = "my",name = "config.switch",havingValue = "true") 或
@ConditionalOnProperty(name = "my.kafka.enable", havingValue = "true") prefix： 为配置前缀，可以没有
name： 如果有前缀则为前缀后面的所有
havingValue： 为配置项的值等于某一值时生效
在配置中如下：
yml 中
my: config: switch: true properties 中
my.config.switch: true 实例： @Configuration @ConditionalOnProperty(prefix = "swagger", name = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d25f23c8ded50c676885b8e5b7723be4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/314f4fe0498e6cdb0a348ee60dffb24a/" rel="bookmark">
			JSON介绍：json.dump()、json.dumps()、json.load()、json.loads()
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import json 首先导入json 一. 函数用法
1.json.dumps()：将Python数据结构转换为JSON,即dict类型转成str类型。 obj：需要转化成json的对象 sort_keys：（布尔值）编码器按照字典排序(a到z)输出 indent：根据数据格式缩进显示 separators：设置分隔符 skipkeys：(布尔值) 检查python的基本类型 ensure_ascii ： 输出是否ASCLL码 check_circular：容器类型的循环引用检查 import json data = {'name' : 'Shang','age' : 20} json_str = json.dumps(data,ensure_ascii=False) print(json_str) # 输出为 {"name": "Shang", "age": 20} 2.json.dump()：编码，用于将dict类型的数据转成str类型，并写入到json文件。 import json data = {'name':'Shang','age':20} #将python编码成json放在指定的文件里 filename = 'a.txt' with open (filename,'w') as f: json.dump(data ,f) 3.json.loads()：将JSON编码的字符串转换回Python数据结构，即str类型转换成dict类型。 import json data = {'name':'Shang','age':20} data = json.dumps(data) # 将python数据结构转为json类型 print(json.loads(data)) # 将json类型再转为python数据结构 # 输出为 {'name': 'name', 'age': 20} 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/314f4fe0498e6cdb0a348ee60dffb24a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2df881f9828deaac54a6fa361783c1dc/" rel="bookmark">
			centos7.6离线升级make
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.下载make压缩包
make下载地址
2.上传make包后，解压：
tar -xzvf make-4.3.tar.gz 3.安装：
cd make-4.3/ ./configure --prefix=/usr/local/make make make install 4.备份：
cd /usr/bin/ mv make make.bak 5.创建软连接：
ln -sv /usr/local/make/bin/make /usr/bin/make 最后测试：
make --version 最好同时升级ncurses-5.6.tar.gz：
wget http://ftp.gnu.org/pub/gnu/ncurses/ncurses-5.6.tar.gz 解压：
tar zxvf ncurses-5.6.tar.gz 创建build目录：
cd ncurses-5.6 mkdir build cd build 配置安装：
../configure -prefix=/usr/local -with-shared -without-debug make make install 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/766eabc469571c0ee7b87431c25a573b/" rel="bookmark">
			golang 多个struct 转换融合为一个json，平级融合或者多级融合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 平级融合，就是下面例子，虽然A在B里面，但是A在struct B里面没有名字，输出结果就是A 和B在同一级的json下面。
package main import ( "encoding/json" "fmt" ) type A struct { Name string `json:"name"` Description string `json:"description"` URL string `json:"url"` } type B struct { Name string `json:"name"` *A } func main() { a := A{Name: "test", Description: "desc", URL: "https://example.com"} b := B{Name: "new name"} b.A = &amp;a data, _ := json.Marshal(b) fmt.Println(string(data)) } 输出：{"name":"new name","description":"desc","url":"https://example.com"}
2. 两级json，
package main import ( "encoding/json" "fmt" ) type A struct { Name string `json:"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/766eabc469571c0ee7b87431c25a573b/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/92/">«</a>
	<span class="pagination__item pagination__item--current">93/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/94/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>