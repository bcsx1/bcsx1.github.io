<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/907be55af64c0962b3eea6ba29d20439/" rel="bookmark">
			香农三大定理、香农公式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 信源编码香农第一定理(无失真变长信源编码定理)香农第二定理(有噪信道编码定理)香农第三定理(保真度准则下的信源编码定理) 香农作为信息论的创始人，为如今的信息时代(4G、5G等通信领域)奠定了重大基础。 信源编码 通信中，信源编码本质上是将信源符号转变为适合信道传输的符号，目的为了减少或消除信源冗余度而提高传输效率及通信的有效性。
在信息论的编码定理中，已从理论上证明，至少存在某种最佳的编码或信道处理（信道编码/译码）方法，能够做到既可靠又有效地传输信息。而香农第一定理就是一个极为重要的极限定理：
香农第一定理(无失真变长信源编码定理) 香农第一定理给出了要做到无失真的信源编码，数据压缩的极限值——平均每个信源符号所需最少的 r r r元码元数为信源的熵 H r ( S ) H_r(S) Hr​(S).
即信源的信息熵 H r ( S ) H_r(S) Hr​(S)是无失真信源压缩的极限值。
若编码的平均码长小于信源的熵值 H r ( S ) H_r(S) Hr​(S)，则惟一可译码不存在，在译码或反变换时必然要带来失真或差错。
通过对扩展信源进行变长编码，当 N → ∞ N \to\infty N→∞ 时，平均码长 lim ⁡ N → ∞ L ‾ N N = H r ( S ) \lim \limits_{N \to\infty} \frac{\overline L_N }{N}= H_r(S) N→∞lim​NLN​​=Hr​(S)
物理意义：
无失真信源编码的实质是对离散信源进行变换——变换后信源符号(信道的输入信源)尽可能为等概率分布；
新信源符号平均所含的信息量达到最大，使信道的信息传输率R达到信道容量C，实现信源与信道理想的统计匹配。
香农第二定理(有噪信道编码定理) 当信道的信息传输率不超过信道容量时( R &lt; C R&lt;C R&lt;C)，采用合适的信道编码方法可以实现任意高的传输可靠性，但若信息传输率超过了信道容量( R &gt; C R&gt;C R&gt;C)，就不可能实现可靠的传输。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/907be55af64c0962b3eea6ba29d20439/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d49de9c943774b324c71ff85725b11fb/" rel="bookmark">
			LwIP介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、LwIP简介二、LwIP主要特性：三、文件说明lwip-2.1.3contrib-2.1.0 一、LwIP简介 lwIP（Light weight IP）是瑞典计算机科学院(SICS)的Adam Dunkels 开发的一个小型开源的TCP/IP协议栈。LwIP是Light Weight (轻型)IP协议，有无操作系统的支持都可以运行。LwIP 的设计初衷是：用少量的资源消耗实现一个较为完整的 TCP/IP 协议栈，其中“完整”主要指的是 TCP 协议的完整性，实现的重点是在保持 TCP 协议主要功能的基础上减少对 RAM 的占用，它只需十几KB的RAM和40K左右的ROM就可以运行。这样就可以让lwIP适用于资源有限的小型平台例如嵌入式系统。
目前 lwIP 最新版本 2.1.3
官网：http://savannah.nongnu.org/projects/lwip/
点击“Group Homepage”查看LwIP的官方说明文档。
点击“Download Area”下载LwIP的资源。
contrib 包不属于 LwIP 内核的一部分，装的是移植和应用 LwIP 的一些 demo，即应用示例。
“.sig”后缀的文件是数字签名。
二、LwIP主要特性： 支持 ARP 协议（以太网地址解析协议）。支持 ICMP 协议（控制报文协议），用于网络的调试与维护。支持 IGMP 协议（互联网组管理协议），可以实现多播数据的接收。支持 UDP 协议(用户数据报协议)。支持 TCP 协议(传输控制协议)，包括阻塞控制、RTT 估算、快速恢复和快速转发。支持 PPP 协议（点对点通信协议），支持 PPPoE。支持 DNS（域名解析）。支持 DHCP 协议，动态分配 IP 地址。支持 IP 协议，包括 IPv4、IPv6 协议，支持 IP 分片与重装功能，多网络接口下的
数据包转发。支持 SNMP 协议（简单网络管理协议）。支持 AUTOIP，自动 IP 地址配置。提供专门的内部回调接口(Raw API)，用于提高应用程序性能。提供可选择的 Socket API、NETCONN API (在多线程情况下使用) 。 三、文件说明 lwip-2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d49de9c943774b324c71ff85725b11fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e4f5d2b141376eb062c1782fce3f701/" rel="bookmark">
			【django】admin后台管理的坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自定义的主键，必须要在fields或者fieldsets里，但是默认添加的或者自主添加的autofield字段可以不在admin页面里添加，保存时会自动添加
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/acf75fa02e786136adb3608b7c0d67b8/" rel="bookmark">
			从Endnote导入Zotero(含PDF)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 这个问题尚未完美的解决，不过本方法可行
1 在Endnote中导出.xml文件 2 替换路径 使用记事本打开导出的.xml文件
将
internal-pdf:// 替换为
/My EndNote Library.Data/PDF/ 3 在Zotero中导入 导入后可以看到有PDF附件
4 删除笔记 导入文献之后可能会有一些乱报的笔记，可以找一下他们的共同点，使用搜索功能进行检索。然后删除。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2fd77d995aa7af60ebbe1e1fd8f8d69c/" rel="bookmark">
			Simulink建模：PID控制-应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文总结一些工作中在使用PID控制时积累的经验。
文章目录 1 引入2 PID控制的应用2.1 动态PID参数2.2 前馈-反馈控制2.3 积分饱和 3 总结 1 引入 之前已经写过两篇关于PID控制的文章，主要从建模的角度描述如何搭建出来PID控制算法。在实际工程项目中，PID的调试可能会比仿真更加麻烦。因此，博主希望专门写一篇用来总结一下自己开发调试的经验，以供日后参考，或者其他同行参考。
由于不同工程师所面对的被控对象的特性不同，博主的一些经验不一定适合所有的应用场景。
2 PID控制的应用 对于基础的三个PID参数的理解，已经有很多资料（包括控制理论教科书上的推导公式），博主不再赘述。这一章主要讲讲在工程中对PID算法进行的一些延申和调试经验，以适应复杂的工程问题。
2.1 动态PID参数 假设在实车车速为30km/h的时候通过调整PID参数使得制动模块达到了性能需求，但是车速在60km/h的时候这套参数又不满足需求，经调试后又获得一套不同的PID参数可以满足60km/h的速度。
针对上面的情况，就可以通过以车速为断点，查表得到不同车速下的PID参数，满足不同车速下的控制性能指标。模型示意如下：
图中的Kp信号不再是一个固定的标定量，而是随着车速变化的Kp值，也就是动态参数，是非常实用的调参手段。
博主还见过一种动态调参方式是通过偏差值查表得出参数，如下图所示。
该项目试图通过这种方式，解决偏差值较小的情况下响应迟缓的问题，可以取得较好的效果。
2.2 前馈-反馈控制 PID是反馈控制，也就是需要根据偏差来进行控制，这就造成了一定会有延迟。如果在产生偏差之前就预判到应该大致发出多少的控制量，在这个基础上再通过PID的反馈控制来弥补一些偏差，就能响应得更快。
例如ADAS的车道居中功能，在进入弯道之前没有横向位移的偏差。如果进入弯道之后产生了偏差再去利用PID的反馈控制，就会有延迟，会有偏离车道的风险。
如果结合前馈控制就能很好地解决上述问题。当摄像头检测到前方弯道时，可以根据预定好的弯道-方向盘转角关系表提前请求方向盘打一个角度（就像老司机开车的预判一样），在这个基础上如果有微小的横向位移偏差或者角度方向偏差，再反馈控制弥补。
模型示意如下：
如图中，最终请求的方向盘转角由前馈角度和反馈角度相加得到。
2.3 积分饱和 积分器如果不限制上下限，可能会累积得过大。当超过了系统所能承载的控制量的上下限时，就会到达饱和状态，此时系统产生了超调。超调后由于Err符号相反，会有回正趋势，但是因为积分项积累过大，积分项和比例项想抵消以前的累计更加困难，必须等到控制量进入系统上下限范围的时候才会开始回正，所以这个回正过程会非常迟缓。
基于以上问题，在实际PID控制中需要对积分饱和的情况进行处理。常用方式是积分项限值和复位的处理。
图中包含了对积分项的复位和限幅的处理。
3 总结 本文总结一些工作中在使用PID控制时积累的经验。
&gt;&gt;返回个人博客总目录
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f4968d88548e754d0c6274d67a9cbc4/" rel="bookmark">
			华为云云耀云服务器L实例评测｜从零搭建Git服务器并配置ssh免密访问
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1 概述1.1 项目背景1.2 基本信息1.2.1 硬件配置1.2.2 服务器软件信息1.2.3 本地电脑软件信息 2 购买服务器2.1 注册华为云账号2.1.1 华为云官网2.1.2 新用户注册2.1.3 用户登录 2.2 购买服务器2.2.1 选择服务器2.2.2 点击要购买的产品2.2.3 领取优惠券2.2.4 购买服务器 3 配置实例3.1 进入控制台3.2 找到服务器3.3 配置服务器3.4 登录服务器 4 配置SSH访问4.1 安装SSH4.2 启动SSH服务4.2.1 查看下SSH状态4.2.2 启动SSH并设置开机自启动 4.3 配置安全组4.3.1 开放22端口用于ssh访问4.3.2 修改入站端口4.3.3 新增入栈规则 4.4 配置免密访问4.4.1 使用 ssh-keygen创建密钥4.4.2 将私钥添加到管理文件中4.4.3 在本地使用SCP将公钥和私钥文件拷贝到服务器。4.4.4 查看git for windows是否识别到密钥。 4.5 使用ssh-add将私钥添加到本地电脑的ssh私钥列表里 5 配置Git服务器5.1 查看是否已安装git5.2 创建git仓库5.3 本地Clone代码下来。 1 概述 1.1 项目背景 随着云计算时代的进一步深入，越来越多的中小企业企业与开发者需要一款简单易用、高能高效的云计算基础设施产品来支撑自身业务运营和创新开发。基于这种需求，华为云焕新推出华为云云服务器实例新品。
感谢华为元免费赠送的优惠券，没有什么比白嫖更香了，对于我这种想要省钱又想要玩一玩云服器的，实在是很优选的选择，赶紧搞起来体验体验。
本文详细介绍了从购买服务器=&gt;配置实例=&gt;配置SSH连接=&gt;配置Git服务器的完整过程，可供项目实践参考。
1.2 基本信息 1.2.1 硬件配置 服务器实例：“云耀云服务器L实例”
CPU：2核，2G
带宽：3M
1.2.2 服务器软件信息 系统：Ubuntu 22.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f4968d88548e754d0c6274d67a9cbc4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11f102b78e5edc45a5cc3a408f141813/" rel="bookmark">
			在Ubuntu系统下c语言的运用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一，实验要求
1，在Ubuntu系统下用C语言编写一个简单的输出 hello word 的程序，并编译有、运行之；
2，请编写一个主程序文件 main1.c 和一个子程序文件 sub1.c， 要求：子程序sub1.c 包含一个算术运算函数 float x2x（int a，int b），此函数功能为对两个输入整型参数做某个运算，将结果做浮点数返回；主程序main1.c，定义并赋值两整型变量，然后调用函数 x2x，将x2x的返回结果printf出来。
1) 请在ubuntu系统用gcc 命令行方式编译主程序main1.c 并运行; 2) 请在windows系统下用你熟悉的编译工具编译主程序main1.c 并运行。
3，在ubuntu系统下用Makefile方式编程主程序。
二，实验步骤
1，在Ubuntu系统下用C语言编写一个简单的输出 hello word 的程序
（1）建立文件“Helloworld.c”
(2)代码
（3）输出结果
2，请在ubuntu系统用gcc 命令行方式编译主程序main1.c 并运行; （1）建立文件“main1.c”“sub1.h”
（2）
(3)结果
3，请在windows系统下用你熟悉的编译工具编译主程序main1.c 并运行
4，在ubuntu系统下用Makefile方式编程主程序。
（1）建立makefile文件
（2）执行make指令
5，总结
Ubuntu是一种基于Linux的开源操作系统，它拥有强大的软件学习能力。在使用Ubuntu进行软件学习的过程中，我收获了很多。
首先，Ubuntu提供了广泛的软件学习资源。它的软件中心中有大量的应用程序和工具，可以满足不同学习需求，如编程、图像处理、文档编辑等。此外，Ubuntu还拥有丰富的开发工具和开发环境，如GCC编译器、Python解释器等，可以进行软件开发和学习。
其次，Ubuntu的软件学习过程非常简便。安装和卸载软件非常方便，只需在软件中心中搜索并点击安装，即可完成安装过程。同时，Ubuntu拥有直观友好的用户界面和操作方式，使得学习者可以快速上手，无需花费过多时间去学习使用。
再次，Ubuntu支持多种编程语言的学习。对于编程学习者来说，Ubuntu提供了众多支持各种编程语言的集成开发环境，如Eclipse、PyCharm等。这些开发工具可以帮助我们更好地理解和学习编程技术，提供了丰富的调试和编辑功能。
最后，Ubuntu拥有庞大的开源社区。这个社区非常活跃，会为用户提供大量的技术支持和学习资源。在Ubuntu的社区论坛和各种开发社区中，可以与其他开发者和学习者交流经验，共同解决问题，进一步提高学习效率和效果。
总之，通过使用Ubuntu进行软件学习，我深刻体会到了它开源、强大和便捷的特点。它提供了丰富的学习资源和工具，使学习过程更加高效和容易。同时，Ubuntu的开源社区也为学习者提供了良好的交流平台，促进了知识的分享和学习者之间的合作。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/618ab4a35c0ebb18eda6033ac4ffdbb3/" rel="bookmark">
			.NET – 5个免费的反编译器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 简介 在本文中，我们将概述目前可用的一系列免费的.NET反编译器。我们只专注于完全免费的完整版本工具，可以在非商业和商业环境中免费运行。如果一个软件工程师在家里投入时间和精力来学习和培养技能，而这些工具只对非商业环境是免费的，然后在他的工作场所发现公司不打算购买该特定工具，那就是浪费时间和精力。
1.1. 测试的工具 以下是引起我们注意的免费.NET反编译器列表：
Ildasm.exe（随Visual Studio 2022一起提供）Telerik justDecompile （JustDecompile .NET Assembly Decompiler &amp; Browser - Telerik)dnSpyEx （Releases · dnSpyEx/dnSpy · GitHub)ILSpy （Releases · icsharpcode/ILSpy · GitHub)JetBrains dotPeek （dotPeek: Free .NET Decompiler &amp; Assembly Browser by JetBrains) 2. 测试申请 为了测试反编译器，我们创建了一个小的C#11/.NET7项目由2个组件组成。解决方案如下所示：
这是原始代码： //====================================== namespace AlphaAssembly internal class Program { static void Main(string[] args) { Console.WriteLine(Resource1.HW); A a2=new A2(); a2.PrintMessage(); A a3 = new A3(); a3.PrintMessage(); B b2 = new B2(); b2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/618ab4a35c0ebb18eda6033ac4ffdbb3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd27283591e01de5e90823db4050a0a8/" rel="bookmark">
			【MySQL系列】如何在MySQL中使用触发器？MySQL触发器详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL可以通过触发器来实现自动化业务逻辑和操作。触发器是一种在数据库表发生特定操作时自动执行的存储过程，能够响应特定事件，如INSERT、UPDATE和DELETE语句。
本文将详细介绍MySQL中的触发器概念、创建和使用方法，以及一些注意事项。
一、概念 触发器是一种与表相关联的一段代码，它会在特定事件（INSERT、UPDATE和DELETE语句）发生时自动执行。触发器可以在数据表中插入或更新数据的时候自动执行存储过程，从而实现约束、默认值或处理业务逻辑的功能。
触发器可以在MySQL中创建和删除，已经创建的触发器可以修改它的定义。每个触发器都有一个触发事件和响应事件，触发事件通常是数据表上的INSERT、UPDATE或DELETE语句，响应事件是在触发事件后MySQL服务器执行的操作。
二、MySQL触发器语法 1.常规触发器 常规触发器是MySQL触发器的基本类型，它可以在INSERT、UPDATE或DELETE语句被执行前或执行后自动触发。常规触发器的语法如下：
CREATE TRIGGER trigger_name BEFORE|AFTER INSERT|UPDATE|DELETE ON table_name FOR EACH ROW BEGIN trigger_body; END; 其中，`trigger_name`为触发器的名称，`table_name`为触发器所依附的表名，`trigger_body`为触发器的执行语句。另外，`BEFORE`和`AFTER`关键字表示触发器是否在数据库事件发生之前或之后被执行；`INSERT`、`UPDATE`和`DELETE`关键字则表示所触发的数据库事件。`FOR EACH ROW`则表示为每一行数据都执行该触发器。
下面是一个常规触发器的示例，它可以在每次往`test`表中插入数据之前打印出一行信息：
CREATE TRIGGER test_trigger BEFORE INSERT ON test FOR EACH ROW BEGIN INSERT INTO log (message) VALUES ('New data added'); END; 2.批量触发器 批量触发器可以在查询语句执行前或执行后自动触发。与常规触发器不同的是，批量触发器可以同时处理多行数据，并且它通常被用于执行一些比较耗时的计算操作。批量触发器的语法如下：
CREATE TRIGGER trigger_name BEFORE|AFTER INSERT|UPDATE|DELETE ON table_name BEGIN trigger_body; END; 与常规触发器类似的是，`trigger_name`、`table_name`以及`trigger_body`的含义都相同；`BEFORE`和`AFTER`关键字也表示所触发的数据库事件。不同的是，批量触发器并不需要使用`FOR EACH ROW`关键字来限定行级触发器。
下面是一个批量触发器的示例，它可以在每次往`test`表中插入1000行数据后打印出一行信息：
CREATE TRIGGER test_trigger AFTER INSERT ON test BEGIN IF (SELECT COUNT(*) FROM test) &gt;= 1000 THEN INSERT INTO log (message) VALUES ('Batch data added'); END IF; END; 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd27283591e01de5e90823db4050a0a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c404578437f0256dca815d515077101/" rel="bookmark">
			【对称加密算法】AES算法的CBC和ECB模式！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、AES算法 AES（Advanced Encryption Standard）是一种对称密钥加密算法。AES算法采用分组密码的方式，将明文划分成固定长度的数据块，对每个数据块进行加密，最终得到密文。AES算法的密钥长度可以为128位、192位或256位，其中128位密钥的安全性已经足够保障大部分应用的安全性。
AES算法的优点包括：
安全性高：AES算法具有很高的安全性，即使在今天的计算机技术下，破解AES算法的难度也非常大。算法效率高：AES算法的加密解密速度非常快，适合大规模数据加密。算法公开透明：AES算法是一种公开透明的加密算法，任何人都可以查看AES算法的代码。 (一)、ECB模式 ECB模式是最简单的AES加密模式，它需要一个固定长度的密钥，固定的明文会生成固定的密文。在ECB模式中，明文被分成固定大小的块，每个块独立加密。加密过程是通过一个密钥和加密算法实现的，每个块都使用相同的密钥和加密算法进行加密。因此，如果有两个相同的明文块，则它们的加密结果也是相同的。
优点：
简单；有利于并行计算；误差不会被传递； 缺点 :
安全性低 编写代码步骤：
根据算法名称/工作模式/填充模式获取 Cipher 实例根据算法名称初始化一个SecretKey 实例，密钥必须是指定长度；使用 SerectKey 初始化 Cipher 实例，并设置加密或解密模式；传入明文或密文，获得密文或明文。 128位的密钥=16个字节
//AES + ECB public class Demo01 { public static void main(String[] args) throws GeneralSecurityException { // 原文: String message = "天生我材必有用飞流直下三千尺"; System.out.println("Message(原始信息): " + message); // 128位密钥 = 16 bytes Key: byte[] key = "1234567890abcdef".getBytes(); // 加密: byte[] data = message.getBytes(); byte[] encrypted = encrypt(key, data); System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c404578437f0256dca815d515077101/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da8c90bbd53412c4cbb33568d06c80e7/" rel="bookmark">
			SourceCRT 连接华为ENSP模拟器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SourceCRT 连接华为ENSP模拟器
1、CRT新建一个连接。
2、使用Telnet 协议，地址配置为环回地址127.0.0.1，配置一个端口号 2002.
3、打开ENSP，选择一台设备，设置端口号为2002，然后开启设备
4、CRT连接，然后就成功连接到ENSP的设备了
可以用CRT 提前建立多个端口号不同的连接，这样就可以方便连接多台ENSP中的设备了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb69898a1c4e0f16610ed3822603006d/" rel="bookmark">
			BGP基础和工作原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、基础内容1、BGP定义2、自治系统AS（Autonomous System）3、4字节AS4、BGP的Router ID 二、BGP分类： EBGP和IBGP三、BGP报文1、BGP报文头2、具体报文内容（1）open:用于建立BGP连接（2）update:用于在对等体间交互路由信息（3）notifacation:用于中断BGP连接（4）keepalive：用于保持BGP连接（周期性发送）（5）refresh：用于改变路由策略后，请求对等其重新发送路由信息，只有支持路由刷新能力的BGP设备会发送和响应此报文。 四、BGP工作原理五、BGP对等体之间的交互原则（5条）六、路由黑洞1、路由黑洞产生的原因2、路由黑洞的解决办法 一、基础内容 1、BGP定义 边界网关协议BGP（Border Gateway Protocol）是一种实现自治系统AS（Autonomous System）之间的路由可达，并选择最佳路由的距离矢量路由协议。
BGP使用TCP作为其传输层协议，端口号是179
2、自治系统AS（Autonomous System） AS是指在一个实体下的拥有相同选路策略的IP网络。
AS号分为2字节AS号和4字节AS号，4字节AS号设备能够与支持2字节AS号的设备兼容。
（1）2字节AS号的范围为1至65535
（2）4字节AS号的范围为1至4294967295。
3、4字节AS 4字节AS分为两种形式：整数形式和点分形式。
（1）点分形式的4字节AS号格式一般为：x.y。
（2）整数形式的4字节AS号和点分形式的4字节AS号的换算关系是：整数形式的4字节AS号=x*65536+y。
例如：点分形式的4字节AS号2.3，对应的整数形式的4字节AS号为：2*65536+3=131075。
4、BGP的Router ID Router ID是一个用于标识BGP设备的32位的值，Router ID不是IPv4地址，它只是IPv4地址的形式。
Router ID可以手工配置，也可以自动获取。
（1）手工配置
（2）自动获取：
&gt;1 优先Loopback地址接口为Router ID
&gt;2 如果没有配置Loopback地址，自动选择接口中最大的IPv4地址作为BGP的Router ID
二、BGP分类： EBGP和IBGP IBGP：运行于同一AS内部的BGP称为IBGP，一般通过loopback地址建邻居 EBGP：运行于不同AS之间的BGP称为EBGP，一般通过接口地址建邻居 如上图，同在AS200的路由器建立了IBGP，AS200和AS300的路由器建立了EBGP。
三、BGP报文 BGP报文由BGP报文头和具体报文内容两部分组成。
1、BGP报文头 Marker：占16字节，用于检查BGP对等体的同步信息是否完整，以及用于BGP验证的计算。
Length：占2个字节（无符号位），BGP消息总长度（包括报文头在内），以字节为单位
Type：占1个字节（无符号位），BGP消息的类型。Type有5个可选值，表示BGP报文头后面所接的5类报文
2、具体报文内容 （1）open:用于建立BGP连接 1、Version：协议版本号，现在BGP的版本号为4。
2、My Autonomous System：发送者自己的AS号
3、Hold Time（单位：秒）：发送KEEPALIVE或UPDATE等报文的时间间隔。BGP的状态机收到对等体的OPEN报文后，对发出的OPEN报文和收到的OPEN报文两者的hold time时间作比较，选择较小的时间作为协商结果。
4、BGP Identifier：发送者的router id。
5、Opt Parm Len：表示Optional Parameters（可选参数）的长度。如果此值为0，表示没有可选参数。
6、Optional Parameters：此值为BGP可选参数列表
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb69898a1c4e0f16610ed3822603006d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7dd8a438b4ec2245df232766386815fe/" rel="bookmark">
			登陆中国的国际海缆
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		登陆中国的国际海缆(10条)
1、美洲方向
（1）跨平洋直达高速光缆（TPE）
（2）新跨太平洋国际海底光缆（NCP）
2、东南亚方向
（1）亚太新直达海底光缆（APG）
（2）东南亚日本海缆（SJC）
（3）亚太 2 号光缆（APCN2）
（4）东亚光缆（EAC）
（5）城市间海底光缆（C2C)
3、欧洲方向
（1）欧亚 3 号光缆（SMW3）
（2）环球光缆（FLAG）
（3）亚洲非洲欧洲 1 号光缆（AAE-1）
数据来源：中国信息通信研究院 《中国国际光缆互联互通白皮书（2018 年）》
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e45cf38310b42a764a69ebd9c707879/" rel="bookmark">
			华为BGP12条选路原则详解和实验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、协议首选值（PrefVal）二、本地优先级（Local_Pref）三、优选手动聚合&gt;自动聚合&gt;network&gt;import&gt;从对等体学到的四、优选AS路径（AS_Path）最短的路由五、比较起源属性 IGP&gt;EGP&gt;Incomplete六、来自同一AS的路由，优选MED值最低的七、EBGP&gt;IBGP八、优选到下一跳IGP Metric较小的路由九、负载均衡十、优选Cluster_List最短的路由十一、优选Router_ID最小的路由十二、优选peer ip地址小的路由附件：实验拓扑（百度网盘） 一、协议首选值（PrefVal） 协议首选值（华为私有），仅在本路由器有效，默认数值为0，协议首选值越大越优先。仅能改变进入本路由器的路由选路。
如拓扑图所示，R1、R2、R3和R4四台路由器分别属于不同AS。相邻2台路由器之间均通过互联地址建立EBGP邻居关系。R1上有一个10.10.10.10/32的地址，通network宣告进BGP中。 R4上收到了10.10.10.10/32的路由。
1、R4当前优选了从R2传递过来的10.10.10.10/32路由，R4访问10.10.10.10路径就是R4-R2-R1。
[R4]dis bgp routing-table BGP Local router ID is 10.1.24.4 Status codes: * - valid, &gt; - best, d - damped, h - history, i - internal, s - suppressed, S - Stale Origin : i - IGP, e - EGP, ? - incomplete Total Number of Routes: 2 Network NextHop MED LocPrf PrefVal Path/Ogn *&gt; 10.10.10.10/32 10.1.24.2 0 200 100i * 10.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e45cf38310b42a764a69ebd9c707879/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4347f27567b033566f393d594e5a0b4e/" rel="bookmark">
			漫画丨上帝托梦给我说：一切皆文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		漫画视频版：漫画丨上帝托梦给我说：一切皆文件_哔哩哔哩_bilibili 后记：这些故事当然是我杜撰的，Ken Thompson和Dennis Ritchie在设计Unix的时候，具体是怎么想的，我们无从知道。TCP/IP协议也不是Bill Joy在一个晚上就手写出来的。这里只是想对这些做出伟大贡献的大神们致以敬意。
我们现在所知道的就是在Unix/Linux上，一切皆是文件，设备，socket, pipe..... 它们有统一的名字空间和统一的访问接口，这就实现了以最小代价对系统内类型迥异的各种资源的调用。
当一个“文件”被打开的时候，一个文件描述符也会被创建起来，文件路径用来定位这个文件，文件描述符用来代表从这个“文件”中读写字节流的接口。 有时候文件描述符也可以表示匿名的管道和socket，这时候并没有文件路径， 所以如果更准确一点，我们应该说“一切皆文件描述符”
当然“一切皆文件”也不是完美的，因为不同的设备是有差别性的，“文件”这个抽象层次比较高，只能提供最基础，最通用的方式来操作文件，这也是抽象所要付出的代价。 原文链接：漫画 | 上帝托梦给我说：一切皆文件
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d47ab23742f46d6a3f9ce7f9effcc62/" rel="bookmark">
			探索 Jetpack Glance 的魔法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前写过两篇关于 Jetpack Glance 的文章，分别是第一个 alpha 版本：Jetpack Glance？小部件的春天来了，以及第一个 release 版本发布时写的：稳定的 Glance 来了，安卓小部件有救了！
前世 大家都知道，小部件是运行在桌面中的，并不是运行在自己的应用中，那么数据的传输就涉及到了跨进程，Google 专门为这些需要跨进程绘制布局的需求写了一个名叫 RemoteViews 的类，比如 Notification 、Widget 等，大家千万不要被它名字影响力，虽然它叫 View，但它并不是一个 View。。。
public class RemoteViews implements Parcelable, Filter {} 看到了吧，大骗子。。。
RemoteViews 是比较坑的，它只能支持特定的一些布局：
AdapterViewFlipper：可以实现图片、文字等的轮播FrameLayoutGridLayoutGridViewLinearLayoutListViewRelativeLayoutStackView：卡片状的，可以进行滑动ViewFlipper：也是用来实现轮博的 这些布局大家应该都使用过，这块就不再进行赘述。接下来看下 RemoteViews 支持的特定控件：
AnalogClock：用来实现表盘样式的时钟ButtonChronometer：计时器ImageButtonImageViewProgressBarTextClockTextView 这些控件大家肯定也很熟悉，但安卓中的控件那么多，RemoteViews 只能支持这么几个。。。后来官方也看不下去了，又在 Android 12 中新增了以下几个控件：
CheckBoxRadioButtonRadioGroupSwitch 像大家熟知的 RecyclerView 、EditText 、SeekBar 、Spinner 等等都是不支持的哈。有人可能会想，那我自定义 View 不得了，不好意思，也不可以。。。还有人会想，那我继承它支持的控件，然后自定义不得了，Sorry，还是不可以。。。RemoteViews 只是描述了可在另一个进程中显示的视图层次结构的类，层次结构是从布局资源文件中加载出来的，该类只提供了一些基本操作来修改布局中的内容。简单来看一个例子大家就知道了：
public void setTextViewText(int viewId, CharSequence text) { setCharSequence(viewId, "setText", text); } public void setCharSequence(int viewId, String methodName, CharSequence value) { addAction(new ReflectionAction(viewId, methodName, ReflectionAction.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d47ab23742f46d6a3f9ce7f9effcc62/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58075d1e661f0a08d6119717e570ab76/" rel="bookmark">
			Docker中安装Jenkins
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇主要讲如何在Docker中安装Jenkins，如果Docker未安装，可以先参考上一篇文章进行Docker安装。
【学习Docker（一）】centos系统 Docker 安装与卸载
安装 拉取镜像
docker pull jenkins/jenkins 1 创建 Jenkins 挂载目录
mkdir /docker-local/jenkins 1 chmod 777 /docker-local/jenkins 1 创建并启动 Jenkins 容器
docker run -d \ -p 8888:8080 \ -p 50000:50000 \ -v /docker-local/jenkins:/var/jenkins_home \ -v /etc/localtime:/etc/localtime \ --restart=always \ --name=jenkins \ jenkins/jenkins 查看是否启动成功
docker ps -l 查看启动日志
docker logs jenkins 查看初始密码
cat /docker-local/jenkins/secrets/initialAdminPassword 启动参数描述
-d：后台运行容器；-p 8888:8080：将容器的 8080 端口映射到服务器的 8888 端口；-p 50000:50000：将容器的 50000 端口映射到服务器的 50000 端口；-v /usr/local/jenkins:/var/jenkins_home：将容器中 Jenkins 的工作目录挂载到服务器的 /usr/local/jenkins；-v /etc/localtime:/etc/localtime：让容器使用和服务器同样的时间设置；–restart=always：设置容器的重启策略为 Docker 重启时自动重启；–name=jenkins：给容器起别名； 浏览器访问：http://127.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/58075d1e661f0a08d6119717e570ab76/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dff945772ea386ebf99794ef7e7fbcec/" rel="bookmark">
			本质矩阵，基础矩阵，单应矩阵
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 转载：
立体视觉入门指南（2）：关键矩阵（本质矩阵，基础矩阵，单应矩阵）视觉SLAM中，本质矩阵、基础矩阵、单应性矩阵自由度和秩分析。In defence of the 8-point algorithm（八点算法的归一化（规则化）详解）基础矩阵基础矩阵的7点法和8点法 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a60bcc52ff07cc1e402cd1a7690f17e/" rel="bookmark">
			离线数仓和实时数仓割裂的痛点,数据湖方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		离线数仓和实时数仓割裂的痛点：
1)离线加工数据产出时效性不足
2)实时加工可观测性，可运维性较弱
3)批流双链路，双份资源开销
4)全天计算资源高峰集中在凌晨
数据湖方案：
数据入湖增量计算，提升时效
流表二像性，可流式消费，可批查
计算存储批流一体，可重跑
增量计算将凌晨计算打散到整天
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/122044c968b43933f5d6a57cdf42bd86/" rel="bookmark">
			ShardingSphere修改报错-MysqlDataTruncation: Data truncation: Out of range value for column ‘xx‘ at row 1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、场景二、报错信息三、原因四、解决 一、场景 1、项目使用ShardingJDBC操作数据库
2、修改SQL执行报错
二、报错信息 ### Error updating database. Cause: com.mysql.cj.jdbc.exceptions.MysqlDataTruncation: Data truncation: Out of range value for column 'MSGID' at row 1 ### The error may involve com.xxx.mapper.service.KeyWordMapper.updateByExample-Inline ### The error occurred while setting parameters ### SQL: UPDATE t_wx_keyword SET keyword = ?,msgType = ?,msgId = ?,content = ?,createTime = ?,eable = ?,matchType = ?,originId = ?,vdnId = ? WHERE ( ( vdnId = ? and originId = ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/122044c968b43933f5d6a57cdf42bd86/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd73d19d5b062cba3b241a3560d9abab/" rel="bookmark">
			C&#43;&#43;中. 和 -＞ 的区分
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		. 与 -&gt; 的区分 介绍 定义一个 struct 结构体
struct test{ string name; int marks, classes, rank; }; 当定义一个数据变量时，如： test a； 如果我们要读取其中名为 rank 的成员，我们只需要运用 .运算符即可，代码如下：a.rank
但，如果定义一个指针变量时，如： test *p 这时，如果我们要读取其中名为 rank 的成员，运用 . 运算符就需要如下代码：(*p).rank 由于 程序猿们过于懒惰 代码不便于书写，我们就用 -&gt; （一个减号和一个大于号）做了简化：p-&gt;rank
综上所述，. 和 -&gt; 均为访问“类类型结构体”（struct、class 等类型的结构体）成员的运算符，区别在于 . 用来访问数据类型变量，-&gt; 用来访问指针类型变量
总结 1、A-&gt;a 表示指向结构体类型 A 中的指针类型 a
2、A.a 表示指向结构体 A 中的数值类型 a
3、A-&gt;a 等效于 (A).a
完整代码 #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;string&gt; using namespace std; struct test{ string name; int marks; }; int main(){ test a; a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd73d19d5b062cba3b241a3560d9abab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5df008cf6c015dc1bf19ed11b37966b1/" rel="bookmark">
			钉钉视频下载-2023年9月py代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章参考 https://www.bilibili.com/read/cv20472358/ https://blog.csdn.net/weixin_43594279/article/details/107444501 https://zyy0911.github.io/2022/01/12/%E9%92%89%E9%92%89%E7%9B%B4%E6%92%AD%E5%9B%9E%E6%94%BE%E4%B8%8B%E8%BD%BD.html#h-%E6%9C%AC%E6%95%99%E7%A8%8B%E4%BB%85%E4%BE%9B%E5%AD%A6%E4%B9%A0%E7%A0%94%E7%A9%B6%E4%BD%BF%E7%94%A8 https://github.com/Tencent/vConsole 代码参考 https://blog.csdn.net/Caiqiudan/article/details/109190522 https://wenku.csdn.net/answer/00a8bbd92b934f51a46f83da9dcd17eb 使用的js https://cdn.bootcss.com/vConsole/3.14.0/vconsole.min.js static function OnBeforeResponse(oSession: Session) { if (m_Hide304s &amp;&amp; oSession.responseCode == 304) { oSession["ui-hide"] = "true"; } var sToInsert = "&lt;script src='https://cdn.bootcss.com/vConsole/3.14.0/vconsole.min.js'&gt;&lt;/script&gt;&lt;script&gt;var vConsole = new VConsole();&lt;/script&gt;" oSession.utilDecodeResponse(); oSession.utilReplaceOnceInResponse('&lt;/head&gt;', sToInsert + '&lt;/head&gt;', 0); } mm.m3u8 信息 #EXTM3U #EXT-X-VERSION:3 #EXT-X-MEDIA-SEQUENCE:1 #EXT-X-TARGETDURATION:34 #EXTINF:32.458, 9145a060-e7be-4457-b460-ecd9ec9d2c31/1.ts?auth_key=1695430249-0-0-8def38160d814974e4748d24f23d9029 #EXTINF:32.000, 9145a060-e7be-4457-b460-ecd9ec9d2c31/2.ts?auth_key=1695430249-0-0-5b4457330b144a9452b5d8005c387a3a #EXTINF:32.833, 9145a060-e7be-4457-b460-ecd9ec9d2c31/3.ts?auth_key=1695430249-0-0-e734adc7cce7e0e1dad8d6fe062ca5ce #EXTINF:30.334, 9145a060-e7be-4457-b460-ecd9ec9d2c31/4.ts?auth_key=1695430249-0-0-a8d02d9fb046d35f759df8154547e21e #EXTINF:32.000, 9145a060-e7be-4457-b460-ecd9ec9d2c31/5.ts?auth_key=1695430249-0-0-29ce4961af88d5b2d324ba188b032e74 #EXTINF:32.000, 9145a060-e7be-4457-b460-ecd9ec9d2c31/6.ts?auth_key=1695430249-0-0-6542f8e9bd15b732ee4eb626b54cc274 #EXTINF:32.000, 9145a060-e7be-4457-b460-ecd9ec9d2c31/7.ts?auth_key=1695430249-0-0-cfbef11865f88c5a5e91e0c6f7706699 #EXTINF:32.000, 9145a060-e7be-4457-b460-ecd9ec9d2c31/8.ts?auth_key=1695430249-0-0-5f484c8e517b604eb8a6fb26f19f3f43 #EXTINF:32.000, 9145a060-e7be-4457-b460-ecd9ec9d2c31/9.ts?auth_key=1695430249-0-0-86905ee3c5baecbdc2128be0329d0270 python代码 import subprocess import requests import os import re # my_list = ["
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5df008cf6c015dc1bf19ed11b37966b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4e7589d620da99ec353df62021dbf4a/" rel="bookmark">
			学习算法第一篇之数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一、什么是数组
二、数组的使用
1、查找指定的元素（二分查找法）
1.1、问题描述
1.2、解题思路
1.3、实现代码
2、移除数组元素（双指针法）
2.1、问题描述
2.2、解题思路
2.3、实现代码
3、有序数组的平方（双指针）
3.1、问题描述
3.2、解题思路
3.3、实现代码
4、长度最小的子数组（双指针，滑动窗口）
4.1、问题描述
4.2、解题思路
4.3、实现代码
总结
前言 本篇文章主要是我学习算法的一些总结，便于以后复习，当然能帮助到其他人也很不错。
我是跟着代码随想录学的，卡尔哥真的很NB，因为是学生党买不起书又不想白嫖，所以我每次看B站视频都会点赞投币，就算是对卡尔哥的一点点感谢吧。
卡哥的这个算法课是基于数据结构然后在力扣上找了一些经典的题目讲解，会用到一些算法的思想，毕竟程序=数据结构+算法嘛。
一、什么是数组 百度：一组数据的集合称为数组 Array。补充一下：数组是一种线性的数据结构。
应该每个学过语言的人对数组都有印象并且会使用这个数据结构，在简单的程序中数组是存储数据的首选，它没有链表、栈、队列、树那些复杂。
二、数组的使用 1、查找指定的元素（二分查找法） 1.1、问题描述 给定一个有序的数组（默认升序，如果是无序的就要自己排序，十大排序算法我也写了九个在博客中），然后再给一个target值，查找target在数组中的位置。
1.2、解题思路 数组是有序的，所以直接从中间开始找，判断与target值的大小，target大就往右找，target值小就往左边找，直到不能再二分。
1.3、实现代码 1、确定左右边界，算出中间值。
2、确定while循环条件（左边界要小于等于右边界）。
3、判断该中间值与target的大小关系，改变左右边界。
int search(int* nums, int numsSize, int target){ int left=0; int right=numsSize-1; int mid=(left+right)/2; while(left&lt;=right) { mid=(left+right)/2; if(target==nums[mid]) { return mid; } if(target&gt;nums[mid]) { left=mid+1; } if(target &lt;nums[mid]) { right = mid-1; } } return -1; } 2、移除数组元素（双指针法） 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a4e7589d620da99ec353df62021dbf4a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5cf1f4e5ee029a2326d22ef3c32872f8/" rel="bookmark">
			input 的 placeholder 样式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		::placeholder 伪元素 这个伪元素可以改变 input、textarea 占位文本的样式。
input::placeholder { color: green; } 完整的兼容性写法：
input { &amp;::-webkit-input-placeholder, /* WebKit browsers*/ &amp;:-moz-input-placeholder, /* Mozilla Firefox 4 to 18*/ &amp;::-moz-input-placeholder, /* Mozilla Firefox 19+*/ &amp;:-ms-input-placeholder /* Internet Explorer 10+*/ { color: green; } } 在 Chrome 控制台调试 placeholder 样式 默认情况下，Chrome 控制台是看不到 input 的 placeholder 的样式的，可以在控制台的设置里面把这个配置勾上就行了：
现在就能看到 placeholder 伪元素和其上的样式了：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5127e38e433ee62f3088758713b4663/" rel="bookmark">
			OpenCV(四十二):Harris角点检测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.Harris角点介绍 什么是角点？ 角点指的是两条边的交点，图中红色圈起来的点就是角点。
Harris角点检测原理：首先定义一个矩形区域，然后将这个矩形区域放置在我的图像中，求取这个区域内所有的像素值之和，之后沿着多个方向移动我这个区域，再次计算新区域的像素值之和，如果移动前和移动后的像素值两者的差值比较小，那么就不是Harris角点，如果两者之间差值比较大，就认定移动前覆盖的区域内存在Harris角点。
如图：下图两条线形成角点，而矩形区域分别表示平面、边界、角点三种位置：
2.Harris角点计算 Harris角点检测原理：当移动窗口，窗口内像素值变化大就有Harris角点
Harris角点检测原理公式：
权重系数的引入是为了更加方便地去确定某一个点是Harris角点。
Harris角点检测原理公式写成矩阵形式：
由此可得出梯度协方差矩阵M
Harris评价函数来测量每个像素的角点程度 ，与梯度协方差矩阵M相关
在这个公式中，R是角点响应函数的值，M是一个2x2的矩阵，描述了局部区域中像素的梯度信息，det(M)表示矩阵的行列式，trace(M)表示矩阵的迹，k是一个常数，用于调节响应函数的敏感度。
Harris评价函数可以用特征向量来表示。λ1和λ2分别是M的两个特征值。
通过对特征值λ1和λ2进行求解，我们可以计算Harris评价函数R，并据此来判断像素是否为角点。
当λ1和λ2都较大且接近时，表示图像局部区域存在角点。当λ1和λ2都比较小或者差异较大时，表示图像局部区域是平坦或者边缘区域。 3.检测Harris角点函数cornerHarris() void cv::cornerHarris ( InputArray src,
OutputArray dst,
int blockSize,
int ksize,
double K,
int borderType = BORDER_DEFAULT
）
src:待检测Harris角点的输入图像，图像必须是CV 8U或者CV 32F的单通道灰度图像dst: 存放Harris评价系数的R矩阵，数据类型为CV 32F的单通道图像，与输入图像具有相同的尺寸blockSize:邻域大小ksize: Sobel算子的半径，用于得到梯度信息 k:计算Harris评价系数R的权重系数borderType:像素外推算法标志 4.绘制角点函数drawKeypoints() void drawKeypoints(InputArray image,
const std::vector&lt;KeyPoint&gt;&amp; keypoints,
OutputArray outImage,
const Scalar&amp; color = Scalar::all(-1),
int flags = DrawMatchesFlags::DEFAULT
)
参数说明：
image: 输入图像，可以是任意类型的Mat对象。
keypoints: vector类型的关键点，每个关键点包含其在图像中的位置和其他信息（如尺度、方向等）。
outImage: 输出图像，用于存储绘制了特征点的图像。可以与输入图像相同的尺寸和类型。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5127e38e433ee62f3088758713b4663/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b1703412991b0548e534fbd732ebde0/" rel="bookmark">
			C语言基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		程序设计和C语言 计算机的本质是“程序的机器”，程序和指令的思想是计算机系统中最基本的概念。
程序设计是软件开发人员的基本功。
进行程序设计，必须用一种计算机语言作为工具，否则只是纸上谈兵。可供选择的语言很多，各有特点和应用领域。
C语言功能丰富，表达能力强，使用灵活，应用面广，目标程序效率高，可移植性好，既有高级语言的优点，又有低级语言的许多特点。
1.什么是计算机程序 程序：一组计算机能识别和执行的命令。
2.计算机语言 1.低级语言：机器语言（0和1），汇编语言（符号语言）
2. 高级语言：非结构化语言，结构化语言（顺序结构，选择结构，循环结构），面向对象语言（c++,c#,java等）
3.C语言特点 1.语言简单，紧凑，使用方便，灵活（32个关键字）
2.运算符和数据类型丰富
3.程序设计结构化，模块化
4.生成目标代码质量高
5.可移植性好
4.32个关键字 auto break case char const continue default do
double else enum extern float for goto if
int long register return short signed sizeof static
struct switch typedef unsigned union void volatile while
其共同点为：小写字母，都是单词 5.标识符 用户标识符：由字母（26个大小写字母）数字（0-9）和下划线（“_”）组成，但不能以数字开头，区分大小写。
小测验：
区分以下标识符，哪些是合法标识符，哪些是不合法标识符。
x&gt;3 (x) Abc (✓) _max(✓) 1_b(×) a123(✓) name(✓) Int(✓) int- （×） _int (✓) int(x)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b1703412991b0548e534fbd732ebde0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b332b897015b6abd9687ecee86bd72a7/" rel="bookmark">
			C#上位机 串口上位机Modbus协议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、准备工作二、界面设计1、LED灯2、图表 三、程序设计1、串口配置2、发送报文3、CRC校验4、读写寄存器函数5、LED状态切换6、串口接收事件7、设置电压8、定时器9、其他 四、下位机单片机程序设计1、串口配置2、串口接收中断处理3、发送函数4、ADC、DAC初始化5、Modbus寄存器功能支持6、主函数 五、效果 前言 在上位机和下位机通信时如果只是单纯的发送数据将毫无意义，因为即使收到了数据页只是收到了数据，而不知道这条数据的作用，
所以我们需要制定一个应用层协议使程序在收到数据时按照协议解析而执行对应的操作，Modbus就是一种经常配合串口使用的应用层协议。
一、准备工作 这章主要实现功能为下位机使用单片机，其有两个自定义的Modbus协议中所描述的寄存器，通过上位机控制灯的亮灭和DAC输出电压，并将电压用折线图显示出来。
串口固定为115200波特率、8位数据位、1停止位、无校验。
Modbus实现0x03读指令和0x10写多个寄存器指令。
0x03读指令
地址指令寄存器地址寄存器个数CRC1Byte1Byte2Byte2Byte2Byte 下位机返回
地址指令数据个数数据CRC1Byte1Byte1Byte2Byte 0x10写指令
地址指令起始寄存器地址寄存器个数数据个数数据CRC1Byte1Byte2Byte2Byte1Byte2Byte 下位机返回
地址指令起始寄存器地址寄存器个数CRC1Byte1Byte2Byte2Byte2Byte 下位机中的寄存器定义
寄存器地址功能说明0x0000控制获取LED灯亮灭0：灭，1：亮0x0001获取控制DAC和ADC电压0V-3.3V 扩大100倍传输0x0002获取按键值只读的 二、界面设计 !
上图为设计完成界面，青色的表示LED灯，青色为灯灭，红色为灯亮，点击控件切换，切换的同时向单片机发送命令，折线图显示实时电压100ms获取一次。
通过向界面拖拽一个定时器控件实现并将其Interval属性设置为100，并绑定事件。
1、LED灯 LED灯为自定义控件，在项目上右键-&gt;添加-&gt;用户控件-&gt;创建一个名为LED的控件，在创建出的白色画布上双击进入代码界面，编写如下程序，完成后进行一次生成操作就可以在工具箱中看到自定义控件。
public partial class LED : UserControl { public LED() { InitializeComponent(); } private void LED_Load(object sender, EventArgs e) { this.SetStyle(ControlStyles.AllPaintingInWmPaint, true); this.SetStyle(ControlStyles.DoubleBuffer, true); this.SetStyle(ControlStyles.ResizeRedraw, true); this.SetStyle(ControlStyles.Selectable, true); this.SetStyle(ControlStyles.UserPaint, true); } private Graphics g; private SolidBrush onS = new SolidBrush(Color.Red); private SolidBrush offS = new SolidBrush(Color.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b332b897015b6abd9687ecee86bd72a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ec375028102b6531c219299e773fe0e/" rel="bookmark">
			常见高级语言的输入与输出训练(一)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录
题目概述1
输入描述:
输出描述:
输入
输出
示例C语言代码
题目概述2
题目描述
输入描述:
输出描述:
输入
输出
示例Java代码
前言 本文主要讲解两个算法题的代码实现
题目概述1 计算a+b
打开以下链接可以查看正确的代码
数据范围：数据组数满足 1≤t≤100 ， 数据大小满足 1≤n≤100
输入描述: 输入包括两个正整数a,b(1 &lt;= a, b &lt;= 10^9),输入数据有多组, 如果输入为0 0则结束输入 输出描述: 输出a+b的结果 示例1
输入 1 5 10 20 0 0 输出 6 30 示例C语言代码 #include &lt;stdio.h&gt; int main() { int a, b; for (int i = 0; i &lt; 100; i++) { scanf("%d%d", &amp;a, &amp;b); if (a &gt; 0 &amp;&amp; b &gt;0){ printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ec375028102b6531c219299e773fe0e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e2cdeaf23842c82000ae97560fb0d87/" rel="bookmark">
			查看Window 系统笔记本电池循环次数的指令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.在命令窗口输入如下指令：
powercfg /batteryreport /output "C:\barrery_report.html" 2.到存储目录找到文件打开，得到如下电池信息的数据。
Battery report COMPUTER NAME	FUGE SYSTEM PRODUCT NAME	HP HP Pavilion Laptop 15-eg2xxx BIOS	F.11 11/11/2022 OS BUILD	22621.1.amd64fre.ni_release.220506-1250 PLATFORM ROLE	Mobile CONNECTED STANDBY	Supported REPORT TIME	2023-09-1417:04:51 Installed batteries Information about each currently installed battery BATTERY 1 NAME	Primary MANUFACTURER	HP SERIAL NUMBER	SerialNumber CHEMISTRY	LION DESIGN CAPACITY	41,050 mWh FULL CHARGE CAPACITY	38,351 mWh CYCLE COUNT	38 Recent usage Power states over the last 3 days START TIME	STATE	SOURCE	CAPACITY REMAINING 2023-09-1117:09:00	Suspended	100 %	38,351 mWh 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee5596e3018be7cbd807e0470fdf28c8/" rel="bookmark">
			Pyramid Scene Parsing Network–CVPR，2017论文解读及其pytorch代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Pyramid Scene Parsing Network--CVPR，2017一、背景介绍二、网络结构和优化方法三、实验结果 Pyramid Scene Parsing Network–CVPR，2017 Github代码链接
一、背景介绍 现阶段随着数据集制作精细化、标签种类变多、具有语义相似标签等导致出现一些困难样本，使得经典的语义分割网络无法很好的处理（如FCN，作者认为FCN缺乏合适的策略去利用全局场景类别线索）这些困难样本。如下，作者挑选了ADE20K数据集中几个具有代表性的困难样本，第一行因为FCN没有正确捕获图像内容之间的关系，错误的将外形和汽车相似的游艇识别为汽车，要是能够正确识别出其在水面上就能够避免这种错误；第二行是因为FCN没有捕获类别之间的关系导致遇到相似的类别如building和skyscraper这两类，就无法正确区分；第三行是因为类别代表的物体相对大小各有区别，但FCN没有针对该问题进行处理，导致和床纹理相似的枕头被错误识别成床。
总结这些观察结果，许多错误部分或完全与不同感受野的上下文关系和全局信息相关。
提高模型感受野是解决该问题的切入点，虽然通过理论分析ResNet获得的感受野比原图还大（也就是能够感知全图），但是通过实验发现CNN的感受野是小于理论分析的。
不少人提出用Global average pooling来提高模型感受野，但是作者认为对于困难样本经过Global average pooling后的特征仅用一个特征向量来代表许多的物体类别会导致空间信息的丢失或者引起歧义。故作者认为可以对于局部区域进行全局平均池化就可以缓解该问题。
此外，随着网络变得越来越深，会带来优化困难这一问题。ResNet通过skip connection来缓解优化问题，作者提出通过添加附加损失来辅助训练（附加损失及其相关分支只在训练时使用，测试时就会丢弃）。
二、网络结构和优化方法 结构如上图所示，从图上就能大致看出网络forward过程是什么样子。首先输入图片，通过特征提取网络如ResNet等提取到特征X后（这里作者为了扩大感受野使用的是包含空洞卷积的ResNet，X特征为原图的1/8大小）。之后X输入进作者提出的pyramid pooling module，该模块分为四个分支，通过AdaptiveAvgPool2d函数将特征X池化为1x1、2x2、3x3和6x6大小的4个特征。这四个特征分别对应不同尺度的特征，比如1x1的表示全图。之后这4个特征通过卷积层减少网络通道数，方便后面和特征X沿着通道维度拼接。在拼接前要将特征图的大小统一，这里作者使用了线性插值法将4个特征上采样到和特征X大小一样的特征。之后通过卷积层获取最终的输出。
这里多说一嘴，通常图片大小为256或者512，1/8就是32或者64。这样看就大体知道作者为什么选择1、2、3、6了。
为了方便大家理解，这里贴一下Pyramid Pooling Module的Pytorch代码：
class PPM(nn.Module): def __init__(self, in_dim, reduction_dim, bins): #这里的in_dim就是特征X的通道数、reduction_dim就是获得的4个特征通过卷积层减少通道后的数量，通常取in_dim/4。bins为列表，表示通过AdaptiveAvgPool2d后获得的4个分支的特征大小。 super(PPM, self).__init__() self.features = [] for bin in bins: self.features.append(nn.Sequential( nn.AdaptiveAvgPool2d(bin), nn.Conv2d(in_dim, reduction_dim, kernel_size=1, bias=False), nn.BatchNorm2d(reduction_dim), nn.ReLU(inplace=True) )) self.features = nn.ModuleList(self.features) def forward(self, x): x_size = x.size() out = [x] for f in self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee5596e3018be7cbd807e0470fdf28c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d46934596718622f2fbdd63be09c330/" rel="bookmark">
			Linux环境安装开发grafana插件（一）试水
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		继续我们探索grafana结合Skywalking，为了更加灵活的应用图表，尝试开发grafana的panel插件，但试水并不顺利，所以把第一步目标缩小到安装一个自定义插件。 参考了不少文章，终于成功，但各类参考要么比较碎片化，要么有些地方过时了，所以还是整合一下，对希望对大家节省时间有所帮助。
环境：grafana+linux（UOS）， grafana安装不赘述，可参考
UOS安装grafana及安装GraphQL插件踩坑
具体步骤：
1 注册云账号，获得token
2 确定插件目录
3 初始化插件
4 注册插件，并成功引入Grafana
具体
1 注册一个云账号（Cloud account），并获得token，云账号和token在开发注册中要用，所以要预先准备，具体可参考官网：
grafana官网
创建完成后保存云账号，例如ffXXXXXXX， 以及生成的token(出现时需要保存，以备后用) glc_exx…
2 确定插件目录，网上很多材料写修改grafana的配置文件grafana.ini或者default.ini中的plugin变量，但Linux下没有用，因为在grafana启动文件里/etc/init.d/grafana-server.sh是这样的，只能改PLUGINS_DIR=/var/lib/grafana/plugins
... GRAFANA_USER=grafana GRAFANA_GROUP=grafana GRAFANA_HOME=/usr/share/grafana CONF_DIR=/etc/grafana WORK_DIR=$GRAFANA_HOME DATA_DIR=/var/lib/grafana PLUGINS_DIR=/var/lib/grafana/plugins LOG_DIR=/var/log/grafana CONF_FILE=$CONF_DIR/grafana.ini ... 3 初始化插件，即通过插件模板获得一个最简单的插件
进入PLUGINS_DIR，在该目录下执行
npx @grafana/create-plugin@latest
其中organization name，需要填写云账号名字 ffxxx… 其他随意
在PLUGINS_DIR，出现插件目录，进入该目录，执行yarn或者 npm install 完成依赖导入
4 注册插件，并成功引入Grafana
在PLUGINS_DIR/ffxxx…/目录（插件目录），执行yarn dev启动，主要是需要生成一个dist，以便注册生成MANIFEST.txt
另开一个终端，进入上述目录 ，PLUGINS_DIR/ffxxx…/目录（插件目录），添加环境变量，并执行注册
export GRAFANA_ACCESS_POLICY_TOKEN=glc_exx(刚才生成的Token)
执行注册npx @grafana/sign-plugin@latest --rootUrls http//localhost:3000
重启grafana ，进入localhost:3000, 进入plugin页面，看到自定义插件了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ca0bb3ebbe095cf86fa2df913d78b43/" rel="bookmark">
			vueshowpdf 移动端pdf文件预览
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、安装 npm install vueshowpdf -S 2、参数 属性说明类型默认值v-model是否显示pdf--pdfurlpdf的文件地址String- scale
默认放大倍数
Number1.2 minscale
最小放大倍数
Number0.8 maxscale
最大放大倍数
Number2 3、事件 名称说明回调参数closepdf pdf关闭事件-pdferr文件地址解析错误事件- 4、核心代码 &lt;template&gt; &lt;div class="case-info"&gt; &lt;van-cell title="附件" value="预览" is-link @click="viewPdf" class="perview" /&gt; &lt;vueshowpdf class="pdf" v-model="isShowPdf" :pdfurl="pdfurl" :minscale='0.4' :scale='0.6' @closepdf="isShowPdf = false" @pdferr="pdfError" &gt;&lt;/vueshowpdf&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import api from '@/api.js' import vueshowpdf from 'vueshowpdf' export default { name: 'test', data () { return { isShowPdf: false, pdfUrl: '', pdfKey: 0 } }, components: { vueshowpdf }, deactivated () { // 离开页面默认关闭pdf this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ca0bb3ebbe095cf86fa2df913d78b43/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6471ff2629c53dce22343acaa2e0739/" rel="bookmark">
			EXCEL如何把一个单元格内的文本和数字分开？例如：龚龚15565 = 龚龚 15565
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用工具：WPS
举例：
EXCEL如何把一个单元格内的文本和数字批量分开？不使用数据分列。
第一步、将第二行数据冻结
第二步、在B1、C1单元格输入需要分开的示例
第三步、点击选中B1单元格，输入快捷键【CTRL+E】进行填充。B2单元格也是这样操作。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73742f872b515e8b7226d025a413e7a2/" rel="bookmark">
			element ui —— el-select 添加可输入功能且失焦后自动录入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		el-select 添加可输入功能且失焦后自动录入 场景思路方法 场景 vue2 + element ui 的项目中，产品希望 el-select 可以支持输入功能，也就说用户既可以下拉选择，也可以输入任意内容。
思路 通过阅读element ui 的官方文档，发现 allow-create这个属性就可以支持用户创建新条目，但美中不足的是，创建新条目后还需要手动选择点击一下，否则无效
这个效果不太理想，我们希望的是当手动输入内容时，el-select 可以充当 el-input 使用，也就是输完失焦即将数据写上。此时可以借助失焦事件blur。
方法 allow-create 属性需配合 filterable 使用；
default-first-option 属性配合 filterable ，按下回车时自动选择第一个匹配项，即按下回车键时可以将输入数据写上，更好的实现了el-input 的效果。
给el-select绑定一个blur事件，参数一定要写成$event（$event 是 vue 提供的特殊变量，用来表示原生的事件参数对象 event。）
注意要对e.target.value进行去除空格的判断：e.target.value.trim()!== ''
&lt;el-select v-model="type" clearable filterable allow-create default-first-option @blur="onTypeBlur($event)"&gt; &lt;el-option v-for="(item,i) in list" :key="i" :label="item.label" :value="item.value"&gt; &lt;/el-option&gt; &lt;/el-select&gt; onTypeBlur(e) { if (e.target.value.trim()!== '') { //e.target.value就是录入的内容 this.type = e.target.value; // 如果是对象，要使用this.$set方法 // this.$set('typeObj', 'name', e.target.value) } } 原文链接：element ui - el-select 添加可输入功能_el-select 可输入_nunumaymax的博客-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76d1a1416800ef730bc6a0f5e2719d16/" rel="bookmark">
			C&#43;&#43;中字符与数字的转化方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、string → int 1. 利用 ASCII 码差值计算 定义一个 string 类型字符串 s ，我们可以根据 ACSII 码表得知：
字符 ‘0’ - ‘0’ = 0 ，‘1’ - ‘0’ = 1 ，‘2’ - ‘0’ = 2…以此类推可知
s[i] - ‘0’ = s[i]表示的那个整数
依次将得出的整数加入 a*10 中，便可得到最后想要的整数结果
string s = "123"; int a = 0; for (int i = 0; i &lt; s.size(); i++) { //从高位到低位 a = a * 10 + (s[i] - '0'); //*10 让个位空出，将新的低位整数加入进去 } 根据代码，可以看出这是一个 O[n] 的算法，其中 n = s.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/76d1a1416800ef730bc6a0f5e2719d16/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9b3585057018ebf310b2372df6e9c3e/" rel="bookmark">
			C&#43;&#43;读取ini格式配置文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、背景 ini是早些年的程序启动配置文件格式，可以在该文件里配置一些默认参数，格式为：
;引号后面为注释 [group1] name = group1 IP = 192.168.1.100 port = 7000 [group2] name = group2 IP = 192.168.1.101 port = 7002 []方括号下面的为一个节，通过变量名索引后面的值 二、代码 包含下面这个头文件，即可通过该类读取和解析ini格式的文件
ini.h
#ifndef INI_H_ #define INI_H_ #include &lt;string&gt; #include &lt;map&gt; #include&lt;fstream&gt; namespace ini { class iniReader { public: iniReader() { } ~iniReader() { } bool ReadConfig(const std::string &amp; filename) { settings_.clear(); std::ifstream infile(filename.c_str());//构造默认调用open,所以可以不调用open //std::ifstream infile; //infile.open(filename.c_str()); //bool ret = infile.is_open() if (!infile) { return false; } std::string line, key, value, section; std::map&lt;std::string, std::string&gt; k_v; std::map&lt;std::string, std::map&lt;std::string, std::string&gt; &gt;::iterator it; while (getline(infile, line)) { if (AnalyseLine(line, section, key, value)) { it = settings_.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c9b3585057018ebf310b2372df6e9c3e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1403f1c4ae7dcf7a12fb91e811de117a/" rel="bookmark">
			SLAM相关手撕代码题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.最小二乘拟合直线2.RANSAC 最小二乘拟合直线3.开根号3.1.高斯牛顿法3.2.二分法 4.高斯牛顿法拟合曲线 参考：
Eigen求最小二乘解 1.最小二乘拟合直线 单纯使用C++： std::vector&lt;double&gt; LineFit(const std::vector&lt;double&gt;&amp; x, const std::vector&lt;double&gt;&amp; y) { double k = 1, b = 1; const double eps = 1e-5; while(true) { double h11 = 0, h12 = 0, h21 = 0, h22 = 0; double je1 = 0, je2 = 0; for(int i = 0; i &lt; x.size(); i++) { double res = x[i] * k + b - y[i]; double dk = x[i]; double db = 1; h11 += dk * dk; h12 += dk * db; h21 += db * dk; h22 += db * db; je1 += dk * res; je2 += db * res; } double detH = h11 * h22 - h12 * h21; double delta_k = - (h22 * je1 - h12 * je2) / detH; double delta_b = - (h11 * je2 - h21 * je1) / detH; k += delta_k; b += delta_b; if(abs(delta_k) &lt; eps &amp;&amp; abs(delta_b) &lt; eps) break; } return {k, b}; } 使用 Eigen： std::vector&lt;double&gt; LineFit(const std::vector&lt;double&gt;&amp; x, const std::vector&lt;double&gt;&amp; y) { Eigen::Vector2d X = Eigen::Vector2d::Zero(); const double eps = 1e-5; while(true) { Eigen::Vector2d b = Eigen::Vector2d::Zero(); Eigen::Matrix2d H = Eigen::Matrix2d::Zero(); for(int i = 0; i &lt; x.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1403f1c4ae7dcf7a12fb91e811de117a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/352d0efef222763160f07aeb812a4bfe/" rel="bookmark">
			【持续更新】Linux下常用的命令脚本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mysql 备份数据库 mysqldump -u用户名 -p密码 --databases 数据库名称 &gt; 备份文件.sql 备份全部数据库 #!/bin/bash # MySQL用户名和密码 MYSQL_USER="root" MYSQL_PASSWORD="XMhmyh2019." # 备份保存路径 BACKUP_DIR="/usr/mysqlbackup" # 获取数据库列表 DATABASES=$(mysql -u$MYSQL_USER -p$MYSQL_PASSWORD -e "SHOW DATABASES;" | grep -Ev "(Database|information_schema|performance_schema|mysql)") # 创建备份文件夹 mkdir -p $BACKUP_DIR # 循环备份每个数据库 for DB in $DATABASES; do BACKUP_FILE="$BACKUP_DIR/$DB-$(date +'%Y%m%d%H%M%S').sql" mysqldump -u$MYSQL_USER -p$MYSQL_PASSWORD --databases $DB &gt; $BACKUP_FILE echo "Backup of $DB completed: $BACKUP_FILE" done echo "All database backups completed!" 重启prometheus（也可以用于其他） #!/bin/bash # 定义 Prometheus 配置文件路径 PROMETHEUS_CONFIG="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/352d0efef222763160f07aeb812a4bfe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78663085b612bfbe8b243cc8721a921f/" rel="bookmark">
			C#封装成DLL，并在C#中调用以及C&#43;&#43;封装的DLL在C#中调用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C#封装成DLL，并在C#中调用 一、C#封装成DLL
1、在VS中创建项目选择类库，命名TestDLL
2、建立好项目后自动生成的代码如下
3、注意点：在Class1类中自定义的函数符必须为public，添加自己要封装的C#代码，可定义多个，Demo如下所示：
using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; namespace TestDLL { public class Class1 { //封装加的DLL函数 public int add(int x, int y) { return x + y; } //封装减的DLL函数 public int subtract(int x, int y) { return x - y; } } } 4、点击项目生成解决方案，然后在项目目录的bin/debug下即可发现封装好的dll文件
5、注意：封装成DLL时程序集名字要跟封装程序里的 namespace 命名一致，如下图，否则应用DLL时无法引用成功。
二、C#中调用该DLL
1、新建窗体项目，把DLL放在项目文件夹的bin目录的Debug目录下，在引用里添加这个封装好的类库，且使用using包含进去
using System; using System.Collections.Generic; using System.ComponentModel; using System.Data; using System.Drawing; using System.Linq; using System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/78663085b612bfbe8b243cc8721a921f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a60716139bc8802f0c4155e80cfae5d/" rel="bookmark">
			成都精灵云复试完结篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近参加了成都精灵云的笔试与面试，岗位是c++工程师。后面自己复盘了过程，复试部分总结如下，希望能对各位想进该公司以及面试C++工程师的同学提供一些参考。
后续也会陆续分享各公司的面试和笔试经验在该专栏，想看的可以关注一下博主！
其他内容的链接 精灵云笔试部分
精灵云初试部分
正文开始 到此为止就是HR面了，就和技术关系不是很大了。
首先是做一个自我介绍，还是主要介绍一下自己的优势，和岗位相关的好一些。
下面就是被问到的一些问题，顺序可能不一样，但是问题是一样的。
Q1：你说一下自己有什么优点和缺点
Q2：能实习多久
Q3：你英语怎么样，六级分数多少
Q4：什么时候能到岗
Q5：你怎么理解实习和正式工作的关系
Q6：你学校在xxx地，我们在xxx地，住宿怎么办（他们有实习生宿舍，单间，但是得看有没有空闲的）
Q7：关于上班时间和加班问题能否接受
Q8：关于实习薪资问题
Q9：在校有没有担任过什么职务
Q10：你有什么问题（我问了一些个人的问题以及公司主要业务是做什么的）
最后祝各位都能拿到心仪的offer
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8af739929e04a556f0c44db14b9eb7b/" rel="bookmark">
			xshell下载安装和连接教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、下载 二.安装
三.使用XShell连接Linux服务器
1. XShell初始化界面
2.填写会话信息
3.点击“连接” 一、下载 下载官网地址：家庭/学校免费 - NetSarang Website (xshell.com)l
中文官方网站：http://xshellcn.com
但是中文官网不是免费的，有试用期，所以可以去外国官网下免费的
二.安装 按照步骤安装就行了
这里是注册账号来使用xshell
三.使用XShell连接Linux服务器 1. XShell初始化界面 主机填主机号、
可以在虚拟机里面输入 ip addr 查看
2.填写会话信息 3.点击“连接” 这样就可以了
最后，祝大家学业有成！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2fac3d1bc084144c4f3cd66f54e895e9/" rel="bookmark">
			Harris、FAST、SIFT、SURF、ORB角点提取
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载：
计算机视觉基础-图像处理: Harris特征点检测Harris角点检测（2）-- Harris-LaplaceOpencv 角点检测的 FAST 算法SIFT角点检测SIFT特征点图像特征之SURF特征匹配图像特征描述子之ORB 重点关注Senit_Co的博客：https://senitco.github.io/categories/Algorithm/，写的非常好，也比较全面。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf454737848d6c1eca331c700f7ed54c/" rel="bookmark">
			Retrofit源码解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1 使用方式1.1 创建Retrofit对象1.2 创建代理对象1.3 通过代理去调用请求的方法1.4 请求结果处理 2 构建Retrofit对象的参数2.1 Platform2.2 HttpUr2.3 Converter.Factory2.4 Executor2.5 CallAdapter.Factory 3 创建代理对象3.1 接口对象 4 通过代理调用接口方法4.1 加载请求的方法4.2 创建OkHttpCall对象4.3 代理对象返回ExecutorCallAdapterFactory 5 执行请求5.1 RealCall 6 总结 1 使用方式 1.1 创建Retrofit对象 Retrofit retrofit = new Retrofit.Builder() .baseUrl("https://api.example.com") .addConverterFactory(GsonConverterFactory.create() .build(); 1.2 创建代理对象 public interface MyApi { @GET("/api/columns/{user} ") Call&lt;String&gt; getUser(@Path("user") String user); } MyApi api = retrofit.create(MyApi.class); 1.3 通过代理去调用请求的方法 Call&lt;String&gt; call = api.getUser(""); 1.4 请求结果处理 call.enqueue(new Callback&lt;String&gt;() { @Override public void onResponse(Call&lt;String&gt; call, Response&lt;String&gt; response) { } @Override public void onFailure(Call&lt;String&gt; call, Throwable t) { } }); 2 构建Retrofit对象的参数 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf454737848d6c1eca331c700f7ed54c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd00dbc5e45170312c15f3876f3d9d5d/" rel="bookmark">
			android studio 找不到设备
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述： 当android studio 没有打开， 执行adb devices 可以查看到设备， 当android studio 打开， 执行adb devices 可以查看不到设备， android studio 设备管理器中也没有设备
解决方法： 关闭android studio，执行 #adb shell 进入android 系统，执行#getprop service.adb.tcp.port 获取service.adb.tcp.port 属性值为5555 执行#setprop service.adb.tcp.port 5554 修改service.adb.tcp.port 属性值为5554(可为任意非5555的值)执行#getprop service.adb.tcp.port 获取service.adb.tcp.port 属性值为5554 开启android studio ，设备管理器中已显示设备，同时执行adb devices 可查看到设备
问题原因暂理解为是网络端口抢占，有其他理解的请留言告知，在此谢过！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a80a4ae3849a2afcc544606d067da2e/" rel="bookmark">
			WX小程序反编译问题 Unexpected end of input
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vm.js:2 _C ^^ SyntaxError: Unexpected end of input at new Script (vm.js:83:7) at VM.run (D:\Program Files\nodejs\node_global\node_modules\vm2\lib\main.js:834:13) at wu.get.code (L:\GitHub\wxappUnpacker\wuWxss.js:179:16) at ioLimit.runWithCb (L:\GitHub\wxappUnpacker\wuLib.js:80:8) at agent (L:\GitHub\wxappUnpacker\wuLib.js:54:14) at FSReqWrap.readFileAfterClose [as oncomplete] (internal/fs/read_file_context.js:53:3) 1. 问题：具体内容 2. 解决方式 这个问题是wxappUnpacker存在问题导致的，使用最近更新的unpacker包就可以了，https://download.csdn.net/download/xsophiax/88338222。
这个比较长时间没有验证测试了，且行且珍惜。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e943edf1857b31527bb60bd9e247a91/" rel="bookmark">
			uniapp在H5下选取文件并上传到服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文件可以是图片、ppt、pdf等类型，主要借助于uni.chooseFile进行选择文件，然后借助uni.uploadFile进行上传到服务器。
1、html展示，提供一个上传按钮，再提供一个上传成功后展示容器
&lt;view class="add-btn"&gt; &lt;image src="../../static/images/evidence/add-icon.png" mode=""&gt;&lt;/image&gt; &lt;text class="text" @click="openFile"&gt;添加附件&lt;/text&gt; &lt;/view&gt; &lt;scroll-view scroll-y &gt; &lt;view style="padding-bottom: 120rpx;"&gt; &lt;view class="add-image-item" v-for="(file, index) in currentFile"&gt; &lt;text class="add-image-item-name"&gt;{{(index + 1) + '.' + file.fileName}}&lt;/text&gt; &lt;image class="add-image-item-delete" src="../../../static/image/file_del.png" @click="currentFile.splice(index, 1)" /&gt; &lt;/view&gt; &lt;/view&gt; &lt;/scroll-view&gt; 2、选取文件openFile()
// 打开文件选择器 openFile(){ uni.chooseFile({ count: 1, //默认100 extension:['.zip','.doc','.xls','.pdf','docx','.rar','.7z','.jpg','.png','.jpeg'], success: (res) =&gt;{ console.log(res); if(res.tempFiles[0].size / 1024 / 1024 &gt; 20){ this.$refs.uToast.show({ title: '附件大小不能超过20M', type: 'warning', }) return; } this.resultPath(res.tempFilePaths[0],res.tempFiles[0].name); } }); }, 3、上传选择的文件resultPath()
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e943edf1857b31527bb60bd9e247a91/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb06ac5edcd24da8b435dcebafa35ba0/" rel="bookmark">
			Kotlin实现HTTP请求
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Kotlin实现HTTP请求 package util import kotlinx.coroutines.Dispatchers import kotlinx.coroutines.GlobalScope import kotlinx.coroutines.launch import java.io.BufferedReader import java.io.IOException import java.io.InputStreamReader import java.net.HttpURLConnection import java.net.URL class HttpClient { /** * @param url 请求地址 * @param method 请求方法 * @param headers 请求头 * @param params 请求参数 * @param body 请求体 * @return 请求结果 */ fun sendHttpRequestAsync(url: String, method: String, headers: Map&lt;String, String&gt;?, params: Map&lt;String, String&gt;?, body: String?, callback: (String) -&gt; Unit) { GlobalScope.launch(Dispatchers.IO) { try { val connection = URL(url).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb06ac5edcd24da8b435dcebafa35ba0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0aefe48bf9e71e48e0e917afeb2f4ec6/" rel="bookmark">
			前端面试合集（三——浏览器）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		浏览器的页面渲染 1.浏览器是如何渲染页面的？2. 什么是reflow(重排）？3. 什么是repaint(重绘）？4.为什么transform效率高？ 1.浏览器是如何渲染页面的？ 当浏览器的网络线程收到HTML文档之后，会产生一个渲染任务，并将其传递给渲染主线程的消息队列。在事件循环机制的作用下，渲染主线程取出消息队列中的渲染任务，开启渲染流程。
整个渲染流程分为多个阶段，分别是：
解析HTML–&gt;样式计算–&gt;布局–&gt;分层–&gt;绘制–&gt;分块–&gt;光栅化–&gt;画。
每个阶段都有明确的输入输出，上一个流程的输出就会成为下一个阶段的输入，这样整个渲染流程就形成了一个严密的生产流水线。
其中前五个步骤是在渲染主线程中进行，而后面的步骤是在合成线程中进行。
渲染第一步：解析HTML
在解析过程中如果遇到了CSS解析CSS，遇到JS解析JS，为了提高解析效率，浏览器在开始解析前，启动一个预解析线程，率先下载HTML中外部的CSS 和JS。
如果主线程解析到了link标签，此时外部的CSS文件还没下载解析好，渲染主线程会直接跳过继续解析后面的HTML文档，这是因为下载和解析CSS的工作预解析线程中进行的，这就是CSS不会阻塞HTML解析的根本原因。
如果主线程解析到了JS 代码，渲染主线程会暂停解析HTML，等待JS文件下载好并将全局代码解析执行完之后，才会继续解析HTML。这是因为JS中可能会改变之前的DOM 树，所以DOM树的生成必须暂停，这也是JS 会阻塞HTML解析的根本原因。
第一步完成后，会得到DOM树和CSSOM 树，浏览器的默认样式、内部样式、外部样式，内联样式均会包含在CSSOM树中。
#为什么HTML会解析成DOM树，CSS 会解析成CSSOM树，而JS 不会呢？
因为页面是一个动态的，在后续用户浏览点击的过程中可能会修改HTML结构和CSS样式，而JS执行完之后只需要进行监听点击事件、鼠标键盘操作等即可。
渲染第二步：样式计算
主线程会遍历得到DOM树，依次为树中的每个节点计算出它最终的样式，称之为Computed Style。
在这一过程中，很多预设值会变成绝对值，比如red会变成rgb(255,0,0);
相对单位会变成绝对单位，比如em会变成px。
这一步完成之后，会得到一颗带有样式的DOM树。
渲染的第三步：布局
这一阶段会依次遍历DOM树的每一个节点，计算节点的几何信息（尺寸和位置)，例如节点的宽高，BFC，margin合并，相对包含快的位置等。
大部分情况下,布局树和DOM树并非一一对应,比如display：none 的节点没有几何信息，因此不会生成布局树，又比如伪元素选择器，虽然DOM树中不存在伪元素节点，但他们拥有几何信息所以会生成到布局树中还有匿名行盒，匿名块盒等等都会导致DOM 树和布局树无法一一对应。
布局完成之后会得到布局树。
渲染第四步：分层
主线程中会使用一套复杂的策略对整个布局树中进行分层，分层的好处在于当某一层结构发生变化时，只要重新绘制这一图层即可，从而提高效率。滚动条，堆叠上下文、transform、opacity等样式都会或多或少的影响分层效果，也可以通过will-change属性更大程度的影响分层效果。
页面的分层可以通过浏览器“检查”中的layers即可查看页面分层。（如果没有找到layers，可看我下图所示）
渲染第五步：绘制
主线程会为每个层单独产生绘制指令集，用于描述这一层的内容该如何画出。
比如：
我在页面的30，20 的位置画一个宽50，高50的盒子
至此，渲染主线程的工作已经完成，下面的工作由合成线程来完成。
渲染第六步：分块
合成线程首先对每个图层进行分块，将其划分为更多的小区域，它会从线程池中拿取更多的线程来完成分块工作。
渲染第七步：光栅化
分块完成后，进入光栅化阶段，合成线程会将快信息交给GPU进程，以极高的速度完成光栅化。GPU进程会开启多个线程来完成光栅化，并优先处理离视觉窗口近的块，光栅化的结果就是一块一块的位图。
渲染第八步：画（quad)
合成线程拿到每个层，每个块的位图后，生成一个个[指引（quad)]信息。指引会标识出每个位图应该画到屏幕的哪个位置，以及会考虑到旋转，缩放等变形。
变形发生在合成线程，与渲染主线程无关，这就是transform效率高的本质原因。
合成线程会把指引提交给GPU进程,由GPU进程产生系统调用提交给GPU硬件显卡，最后完成最终屏幕成像显示在页面上。
2. 什么是reflow(重排）？ 重排的本质就是计算布局树。
当页面布局发生改变时（添加DOM元素，改变字体大小等）需要重新计算布局树，为了避免连续多次操作导致DOM树的反复计算，浏览器会合并这些操作，当JS代码全部完成后再进行统一计算，所以改动属性是异步完成的。
当JS获取布局属性时（比如clientHeight)，可能会造成无法获取到最新的布局消息，浏览器在反复权衡下，最终决定获取属性立即 reflow。所以获取属性是同步的。
3. 什么是repaint(重绘）？ 重绘是根据分层信息计算绘制指令。
当改动样式之后（修改背景颜色，修改字体颜色等），就需要重新计算，引发重绘。
重排一定会引起重绘，但是重绘不一定会引起重排。
4.为什么transform效率高？ 因为transform既不会影响布局，也不会影响绘制指令，它只影响最后一步“画”的阶段。
由于【画】阶段在合成线程中，所以transform变化几乎不会影响渲染主线程，反之，不论渲染主线程有多忙，都不会影响transform变化。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48ef5202d41a688d4a2acc586754c4ad/" rel="bookmark">
			登录和注册页面 - 验证码功能的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. 生成验证码
2. 将本地验证码发布成 URL
3. 后端返回验证码的 URL 给前端
4. 前端将用户输入的验证码传给后端
5. 后端验证验证码
1. 生成验证码 使用hutool 工具生成验证码.
1.1 添加 hutool 验证码依赖
&lt;!-- 验证码 --&gt; &lt;dependency&gt; &lt;groupId&gt;cn.hutool&lt;/groupId&gt; &lt;artifactId&gt;hutool-all&lt;/artifactId&gt; &lt;version&gt;5.8.16&lt;/version&gt; &lt;/dependency&gt; 1.2 创建验证码的控制器 @RestController public class CaptchaController { @Value("${imagepath}") private String imagepath; // 验证码的本地路径 @RequestMapping("/getcaptcha") public Object getCaptcha1(){ // 1.生成验证码到本地 //定义图形验证码的长和宽 (这个验证码的大小需要和自己前端的验证码的大小匹配) LineCaptcha lineCaptcha = CaptchaUtil.createLineCaptcha(128, 50); String uuid = UUID.randomUUID().toString().replace("-",""); // 图形验证码写出，可以写出到文件，也可以写出到流 lineCaptcha.write(imagepath + uuid + ".png"); return AjaxResult.success(imagepath+uuid+".png"); } } application.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/48ef5202d41a688d4a2acc586754c4ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0cc49419b72d8e22fbc65fd6f63f72ca/" rel="bookmark">
			吴恩达机器学习week2实验答案Practice Lab Linear Regression【C1_W2_Linear_Regression】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Practice Lab: Linear Regression Exercise 1 Complete the compute_cost below to:
Iterate over the training examples, and for each example, compute:
The prediction of the model for that example
f w b ( x ( i ) ) = w x ( i ) + b f_{wb}(x^{(i)}) = wx^{(i)} + b fwb​(x(i))=wx(i)+b
The cost for that example c o s t ( i ) = ( f w b − y ( i ) ) 2 cost^{(i)} = (f_{wb} - y^{(i)})^2 cost(i)=(fwb​−y(i))2
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0cc49419b72d8e22fbc65fd6f63f72ca/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/88/">«</a>
	<span class="pagination__item pagination__item--current">89/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/90/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>