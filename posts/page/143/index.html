<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ddfadd9d4ba982256dc9f96987691f65/" rel="bookmark">
			字段类型，字段长度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SELECT
T.TABLE_NAME,
c.comments tableComments,
cc.column_name,
cc.comments colComments,
tc.data_type || '(' || tc.DATA_LENGTH || ')'
FROM
USER_TABLES T
LEFT JOIN user_tab_comments c ON T .TABLE_NAME = c.table_name
LEFT JOIN user_col_comments cc ON T .TABLE_NAME = cc.table_name
LEFT JOIN user_tab_columns tc ON tc.TABLE_NAME = cc.table_name
and tc.column_NAME = cc.column_name;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/875ba2d76642cd75e9c00e8d72bc773d/" rel="bookmark">
			vue中iview组件实现表单数据的动态校验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.实现效果 2.实现原理 iview组件库Form表单， ref=“formValidate”，:model=“formInline”，:rules=“ruleValidate”。选择审核结果的时候动态的设置备注的规则，当为通过为非必填，反之为必填。为备注项设置相应的动态rule： :rules="formInline.status == '2'? ruleValidate.remark: [{ required: false }]" 3.实现代码 &lt;template&gt; &lt;div class="content"&gt; &lt;Card&gt; &lt;p slot="title"&gt;表单动态校验&lt;/p&gt; &lt;Form :label-width="100" ref="formValidate" :model="formInline" :rules="ruleValidate" &gt; &lt;FormItem label="审核结果：" prop="status"&gt; &lt;Select v-model="formInline.status" placeholder="请选择审核结果" &gt; &lt;Option value="1"&gt;审核通过&lt;/Option&gt; &lt;Option value="2"&gt;审核驳回&lt;/Option&gt; &lt;/Select&gt; &lt;/FormItem&gt; &lt;FormItem label="备注：" prop="remark" :rules=" formInline.status == '2' ? ruleValidate.remark : [{ required: false }] " &gt; &lt;Input v-model="formInline.remark" type="textarea"&gt;&lt;/Input&gt; &lt;/FormItem&gt; &lt;div style="text-align: right; padding: 20px 0"&gt; &lt;Button size="large" type="default" @click="cancelAction" class="mr10" &gt;取消&lt;/Button &gt; &lt;Button size="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/875ba2d76642cd75e9c00e8d72bc773d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73b764246e35d9e5c3eeab0ff3044c68/" rel="bookmark">
			centos 系统 yum安装软件报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[root@localhost ~]# yum install lszrz
已加载插件：fastestmirror, refresh-packagekit, security
设置安装进程
Loading mirror speeds from cached hostfile
No package lszrz available.
错误：无须任何处理
Loaded plugins: fastestmirror, refresh-packagekit, security
Loading mirror speeds from cached hostfile
Setting up Install Process
No package gcc available.
Error: Nothing to do
遇到这种情况有两种做法： 1、没网，试着：ping www.baidu.com 如果显示没有连接的话，就说明没网，也就无法使用yum 命令。
2、ping通了的话，还是是用不了yum命令，说明是yum镜像没有了，那么就得下载一个来更新。 在安装完CentOS后一般需要修改yum源，才能够在安装更新rpm包时获得比较理想的速度。国内比较快的有163源、sohu源。这里以163源为例子。
1. cd /etc/yum.repos.d
2. mv CentOS-Base.repo CentOS-Base.repo.backup
3. wget http://mirrors.163.com/.help/CentOS6-Base-163.repo
4. mv CentOS6-Base-163.repo CentOS-Base.repo
5.yum clean all
---------------------
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c40990bd14811128d7d6959c01f05f89/" rel="bookmark">
			UDS-19服务的状态掩码字节解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		19服务读DTC信息有01、02、04、06、0A等子服务，使用诊断仪读取DUT数据一般只需发送4字节有效数据，其他无效字节用00或者CC填充，如03 19 02 09 00 00 00 00，
数据分解：
03：表示报文类型未单帧，长度为3；
19：表示19服务，读取DTC信息；
02：表示19服务下的子服务，读取故障信息；
09：表示DTC状态掩码，读取当前故障;08表示历史故障；
重点讲述DTC状态掩码的构成
注：
1、如果支持bit2(待定DTC)，那么bit1(本检测周期测试失败)也需要支持。如果不支持bit2(待定DTC)，那么bit1(本检测周期测试失败)为可选项。
2、bit4(上次清零后测试未完成)和bit5(上次清零后测试失败)应同时支持。
3、排放相关的电控单元应支持所有的8个状态位。
4、非排放相关的电控单元必须支持bit3（确定DTC）和bit0(测试失败)，其它位为可选择的。
5、通过响应信息中的故障状态字节（故障码第4字节）判断当前及历史故障：
当前故障：(bit3 = 1)&amp;(bit0 = 1);
历史故障：(bit3 = 1)&amp;(bit0 = 0);
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8991fae01b851dc63f410fbdfad617c0/" rel="bookmark">
			vivado：差分信号和单端信号 的相互转换 IBUFDS OBUFDS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
目录
一、背景介绍
二、差分信号转单端信号 （1）使用Verilog
（2）使用VHDL
三、单端转差分信号 （1）使用Verilog
（2）使用VHDL
一、背景介绍 FPGA内部所有信号都是单端的，差分只出现在引脚上。
在FPGA的开发过程中经常遇到，差分信号转单端信号或者单端信号转差分的问题。本文内容在于结合vivado使用Verilog和VHDL两种语言，分别实现二者的相互转换。
二、差分信号转单端信号 FPGA内部所有信号都是单端的，差分只出现在引脚上。输入差分信号转换为单端信号，使用IBUFDS。
（1）使用Verilog 首先在工程代码中定义差分信号。例如：进入vivado，左击language templates，搜索 ”ibufds” ； 点开ibufds，把其中的代码复制到定义差分信号的代码里；按下面的操作，修改复制过来的代码。 （2）使用VHDL 其实使用Verilog和VHDL没什么太大的区别，区别在于表达方式不同而已：
IBUFDS_inst : IBUFDS generic map ( DIFF_TERM =&gt; FALSE, IBUF_LOW_PWR =&gt; TRUE, - IOSTANDARD =&gt; "DEFAULT") port map ( O =&gt; PrSl_ApsClk_s , I =&gt; ST_APS_OUTCTK_P, IB =&gt; ST_APS_OUTCTK_N ); 三、单端转差分信号 FPGA内部所有信号都是单端的，差分只出现在引脚上。把内部信号转为差分信号输出，用OBUFDS。
（1）使用Verilog 把第四个框里的复制到需要用到的模块，替换O、OB、I中的信号即可。
（2）使用VHDL 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc15c45fc2c6d2f76ca8cc9d72166660/" rel="bookmark">
			最适合初学者的Python入门详细攻略，一文讲清，赶紧收藏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目前python可以说是一门非常火爆的编程语言，应用范围也非常的广泛，工资也挺高，未来发展也极好。
Python究竟应该怎么学呢，我自己最初也是从零基础开始学习Python的，给大家分享Python的学习思路和方法。一味的买书看书、看视频，是很难达到预想的效果的，甚至到了中期阶段可能会萌生放弃的想法。
一、学习Python的4个阶段 要说多久能学会Python是没有准确答案的，这个因人而异，所以我把学Python的过程大概划分为四个阶段，告诉大家什么时候要学些什么，至于学习的时间和进度就自己决定了。
第一阶段：了解 Python 编程基础
首先要了解的就是变量、编程规范、基础语法等等，这是能够保证你上手编写 Python 代码的前提。
其次就是数据结构，字符串、列表、字典、元组，这些也需要非常熟练，因为数据类型将贯穿你学习Python并且使用Python的始终。
第二阶段：学习Python函数及流程控制
当你学到了Python 函数和控制语句的时候，就可以尝试去真正的解决问题了，学会如何实现判断和循坏，怎样把固定的功能模块封装成函数，这些都是保证你写出代码的必要条件。
函数主要学习定义，调用以及参数传递的方法，能够熟练地写出函数实现对应的不同功能，这个过程中比较注重细节，所以需要反复的练习。
流程控制则则是需要掌握条件语句和循坏语句，能在不同的场景下使用，知道判断和循环实现的过程，学完这些基本就差不多了。
第三阶段：利用Python进行实战
说到实战，这就关系到第三方库的了解，因为这样你才能利用Python完成更多的事情，比如用pandas作数据处理、用BeautifulSoup写爬虫、用Flask搭建网站、用matplotlib做数据可视化分析…
熟练的使用第三方库能给你节省不少时间，因为这些都是大家使用过的，所以更加稳定，不容易出现bug，根本不需要去自己编代码，能删改别人的代码拿来自己使用就可以了，如果你想要学爬虫或者搭建网站的话，还需要了解其他的知识，学得越多会得越多嘛。
第四阶段：深入学习 Python 编程
如果你只是想利用Python完成一些简单的工作任务，那前三个阶段学习差不多就够用了，因为你已经能进行基本的数据分析、网络爬虫、写工具脚本，用来提升工作效率绰绰有余。
但你如果想要往跟更深领域发展，以就业转行为目的的话，那就得选择一个自己看好的方向深入学习了，你要了解Python的高级特性，如迭代器、生成器、装饰器，了解类和面向对象的理念。
继续深入下去，你可以探索Python的实现原理，性能优化方式，跳出语言本身，了解计算机的交互原理，还有很长的路要走，这不是短时间能实现的过程，你也需要做好心理准备。
二、明确Python就业方向 因为Python相关的工作也很多，这里我简要的帮大家概括一下不同行业的工作需要利用Python做些什么吧，也给大家就业作为参考
后端程序员：使用它单间网站，后台服务比较容易维护。
自动化测试：编写为简单的实现脚本，运用在Selenium/lr中，实现自动化。
数据分析师：快速开发快速验证，分析数据得到结果。
网站开发：借助django,flask框架自己搭建网站。
自动化运维：自动化处理大量的运维任务。
游戏开发者：一般是作为游戏脚本内嵌在游戏中。
学会了Python就业还是不用愁的，这些行业在薪资待遇上可能会有一些区别，但是整体来看还是很好的，我也不会说往哪个方向发展是最好的，各取所长选择自己最感兴趣的去学习就好。
关于Python的技术储备 一、Python基础和高级编程 对于新手学Python而言，基础和高级编程这一块是很重要的，因为如果你没有学过它们，直接去学习某个方向，你将会一脸懵逼，所以这是绕不过的，打好这一块的基础之后，你完全可以无障碍地进阶Python的任何方向。
学习资源：
二、爬虫 应该有很多人都对爬虫感兴趣吧？不只是Python可以写爬虫，还有很多语言都能写，但Python是公认的最适合的语言了。
爬虫不只是爬虫工程师会用到，业余时间也可以用来爬点自己想要的东西，又或者是做兼职也是可以的，甚至非程序员在工作方面也用得到，比如电商人员爬取大量同行数据来分析出市场的情况，在大量数据的基础上研究新的电商方案。
学习资源：
三、数据分析 数据分析也是当下的一大热门方向，用Python来做的话比其他语言强很多，但往往只会数据分析还是差点意思，如果能具备爬虫能力来爬取数据就更好了。
以上所有的文件都已经打包好了，需要的朋友请移步文末。
四、数据库与大数据开发 五、算法与人工智能 机器学习是人工智能的必经之路，核心就在这里，所以想往人工智能去发展的人，可以学学机器学习，但同时也有个前提，人工智能是公认存在门槛的，应届毕业生不是研究生以上学历或者大学中出类拔萃的人，基本上很难找到工作，所以也请考虑清楚。
学习资料：
六、Python全栈学习路线 所有资料已整合打包好，点击蓝色字体进入公众号即可!
这个时代的年轻人，一定需要有自己的闪光点，而不是仅仅做好专业内的事情。
只要你有一技之长、拥有逆风破浪的能力，面对未知的困难，依然能够披荆斩棘。
把平时的碎片时间抽出一小块来学习Python，通过提升自己，去享受你的人生，去看更大的世界。
愿你们在自学Python的路上顺风顺水、学有所成！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ceabed403b196fef553fb00be1bbc5d/" rel="bookmark">
			ubuntu系统配置大恒相机驱动并读取ros话题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 0. 说明1. 安装大恒相机sdk1.1 下载1.2 安装sdk(用于配置ip和调试相机参数)(1) 电脑网卡配置(网卡固定ip)(2)查看相机图像以及配置相机参数 2. 安装ros驱动包(注：大恒相机官方没ros驱动)2.0 正确流程2.1 错误示范2.1 报错1--缺包2.2 报错2--包编译顺序问题，改`catkin_make`为`catkin build` 0. 说明 本机: ubuntu18.04 x86/64系统
相机： 水星二代 MER
应该也适用于ubuntu的其他版本
大恒相机sdk跟系统有关，可以到官网上下载其他架构(如 arm)
ros驱动包不清楚跟系统有没有关系，目前自己没在arm架构上尝试
1. 安装大恒相机sdk 1.1 下载 官网
下载: Galaxy Linux-x86-Gige-U3 SDK_CN-EN,其他操作系统自己查看
1.2 安装sdk(用于配置ip和调试相机参数) 进入目录/Galaxy_Linux-x86_Gige-U3_32bits-64bits_1.5.2303.9221
chmod +x ./Galaxy_camera.run ./Galaxy_camera.run 依次Enter``Y``Y``E(En是英文，Cn是中文)
需要重启和重新插拔相机
All configurations will take effect after the system is rebooted If you don't want to reboot the system for a while you will need to unplug and replug the camera.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ceabed403b196fef553fb00be1bbc5d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2eba1f3832c2260bec933db2db667e6c/" rel="bookmark">
			【Spring框架全系列】SpringBoot配置日志文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🍧🍧哈喽，大家好，我是小浪。那么上篇博客我们学习了SpringBoot配置文件的相关操作，本篇博客我们将学习一个新的知识点，SpringBoot日志文件。🖥🖥
📲目录
一、日志是什么，有什么作用?
二、如何看到日志文件？
三、如何自定义日志打印
1、在程序中得到⽇志对象
2、使用日志对象提供的内置方法来打印日志
四、日志级别
1、日志级别有什么作用？
2、日志的级别分类；
3、日志级别的设置
4、日志持久化
五、更简单的日志输出
六、在原有项目添加lombok
一、日志是什么，有什么作用? 🌃日志是程序的重要组成部分，想象⼀下，如果程序报错了，不让你打开控制台看日志，那么你能找到出错的原因吗？ 答案是不可以的，写代码是很严肃的一件事情，不能靠猜来解决问题，因此日志对于我们来说，最主要的用途就是排除和定位问题。 二、如何看到日志文件？ 🌇我们的springboot项目启动的时候在控制台就有日志输出：
🎇通过运行结果我们可以观察到：
🎑1、Spring Boot 内置了⽇志框架； 📸2、默认情况下，输出的⽇志并非是开发者定义和打印的，那开发者怎么在程序中自定义打印⽇志呢？ 📞3、日志默认是打印在控制台上的，而控制台的⽇志是不能被保存的，那么怎么把日志永久的保存下来 呢？ 三、如何自定义日志打印 1、在程序中得到⽇志对象 在程序中获取日志对象需要使⽤⽇志工厂 LoggerFactory，语法如下：
private static final Logger logger = LoggerFactory.getLogger(UserController.class); 注意这里Logger选择这个slf4j包下的，不要导错包；
即⽇志⼯⼚需要将每个类的类型传递进去，这样我们才知道⽇志的归属类，才能更⽅便、更直观的定位问题类； 2、使用日志对象提供的内置方法来打印日志 在demo包下新建一个包controller，然后新建一个类UserController，代码如下： package com.example.demo.controller; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.ResponseBody; @RequestMapping("/user") @Controller @ResponseBody //用来设置当前类中所有的方法返回的是数据而非页面 public class UserController { //1、得到日志对象 private static final Logger logger = LoggerFactory.getLogger(UserController.class); @RequestMapping("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2eba1f3832c2260bec933db2db667e6c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21fb22fe3c26b3d8019280b3604b096d/" rel="bookmark">
			HTML 页面 JS 使用 freemarker list 循环 string 类型时间 赋值给 chart.js 错误的解决方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Controller 层写法: @RequestMapping(value = "/index", method = RequestMethod.GET) public ModelAndView index(HttpSession session, ModelMap map) { Integer uid = (Integer) session.getAttribute("uid"); if (uid == null) { return new ModelAndView("redirect:/user/user/login"); } map.put("menus",menuService.nutrition(uid,BaseUtils.ONE)); return new ModelAndView("user/index"); }
HTML 页面 &lt;div class="card"&gt;
&lt;div class="card-header text-uppercase"&gt;Line chart&lt;/div&gt;
&lt;div class="card-body"&gt;
&lt;canvas id="lineChart" height="110"&gt;&lt;/canvas&gt;
&lt;/div&gt;
&lt;/div&gt;
页面 JS 写法 var dataChart ={
labels : [],
datasets : [
{ label:"卡路里",
backgroundColor: "#6699FF", //背景填充色
borderColor: "#336699", //路径颜色
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21fb22fe3c26b3d8019280b3604b096d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f363a6199b91fda6697d13dbbf97386/" rel="bookmark">
			使用Jmeter进行接口测试操作方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Jmeter工具下载地址：https://jmeter.apache.org/download_jmeter.cgi
使用步骤：
打开Jmeter 安装包，进入\bin 中，找到"jmeter.bat", 点击打开即可。
选择中文版界面： 点击Options-Choose Language-Chinese
如图操作：
创建测试计划： 在下图打开的Jmeter 页面中，右键“测试计划” -&gt; “添加” -&gt; "Threads(Users)" -&gt; “线程组”， 建立线程组。
右键“线程组” -&gt; “添加” -&gt; “Sample” -&gt; “HTTP请求”, 输入“服务器名称或IP”，对应的端口号，http默认端口号80，可以不写。Https请求端口号默认设置为443
GET请求方法 以下请求为GET, 所有“方法”选择“GET”， 输入对应的路径，添加参数及参数值。
注意： “服务器名称或IP”中不用输入http://, 请求时会自动加入
右键“线程组” -&gt; “添加” -&gt; “监听器” -&gt; “察看结果数”, 添加“察看结果数”， 以察看运行后的结果，如图所示：
post请求方法 添加http的post请求和get请求思路是一致的，步骤也是基本相同的。
简单来说，就是在测试计划上添加线程组，然后添加HTTP请求（类型选择POST）、 添加HTTP信息头管理器、添加监视器。
HTTP信息头管理器添加步骤如下图：
post请求参数实体写在Http请求下的消息体数据内
将post请求消息头加入到HTTP信息头管理器内，之后发送请求即可在查看结果树内看到请求结果。
如果信息头管理器放到线程组下，那么线程组下所有 HTTP 请求都会共享这些 HTTP 信息头
如果信息头管理器放到 HTTP 请求下，那么只有该请求拥有这些 HTTP 信息头
这里和 HTTP 请求默认值一样，也有优先级的，而且优先级也一样
如果有多个信息头管理器，名称重名的话，会按优先级高的先取
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c33953f977685eee5dc5e61e901ea756/" rel="bookmark">
			Docker实现开发项目前后端部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、后端部署
二、前端部署
1、前端部署准备工作
2、前端部署步骤
三、其它
环境：Linux系统
在部署之前先来确定一下目录结构：这里我在home目录下建立了server目录，然后在server目录下建立了api目录和nginx目录。其中api目录中用于存放后端部署内容；nginx目录用于存放前端部署内容。具体结构如下图：
一、后端部署 第一步：将打包好的jar包放在/home/server/api目录下，如图：
第二步：在与jar包同级目录下建立一个Dockerfile文件，文件内容如下：
# 基础镜像，当前新镜像是基于哪个镜像 FROM openjdk:8-oracle # RUN：容器构建时需要运行的命令 ENV TZ = "Asia/Shanghai" # ADD：将宿主机目录下的文件拷贝到镜像且 ADD 命令会自动处理 URL 和解压 tar 压缩包 WORKDIR / ADD ./donger-mom-mes-3.0.jar donger-mom-mes-3.0.jar # 利用 chmod 可以藉以控制文件如何被他人所调用。 RUN chmod +x donger-mom-mes-3.0.jar # EXPOSE：当前容器对外暴露的端口 EXPOSE 8080 # CMD：指定一个容器启动时要运行的命令。Dockerfile 中可以有多个 CMD 命令， # 但只有最后一个生效，CMD 会被 docker run 之后的参数替换 CMD ["java", "-Xmx500m", "-jar", "donger-mom-mes-3.0.jar", "--spring.profiles.active=prod"] 目录结构如下图：
注意：
（1）Dockerfile文件内容中的jar包需要替换成自己的jar包；
（2）Dockerfile文件中暴露的容器端口需要和项目中的端口一致；
（3）Dockerfile文件内容中的CMD ["java", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c33953f977685eee5dc5e61e901ea756/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/255d18177a671f804933f5a82af5767b/" rel="bookmark">
			评估分类模型—混淆矩阵Confusion Matrix与评估指标
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于设计好的分类模型，需要大量的数据集来对其性能进行评估，因此了解评估指标是十分重要的。
评估分类模型的具体流程：
一、二分类混淆矩阵 Confusion Matrix 严格来说，对于二分类问题，没有标签，只有正例和反例。二分类问题的混淆矩阵如下：
评估指标计算公式：
A c c u r a c y = T P + T N T P + T N + F P + F N Accuracy=\frac{TP+TN}{TP+TN+FP+FN} Accuracy=TP+TN+FP+FNTP+TN​ P r e c i s i o n = T P T P + F P Precision=\frac{TP}{TP+FP} Precision=TP+FPTP​ R e c a l l = T P T P + F N Recall=\frac{TP}{TP+FN} Recall=TP+FNTP​ F 1 − S c o r e = 2 1 P r e c i s i o n + 1 R e c a l l = 2 × P r e c i s i o n × R e c a l l P r e c i s i o n + R e c a l l F1-Score=\frac{2}{\frac{1}{Precision} + \frac{1}{Recall}}=\frac{2 \times Precision \times Recall}{Precision + Recall} F1−Score=Precision1​+Recall1​2​=Precision+Recall2×Precision×Recall​ s p e c i f i c i t y = T N F P + T N specificity=\frac{TN}{FP+TN} specificity=FP+TNTN​ 下面以猫狗二分类问题为例，讨论二分类的混淆矩阵及其评估指标：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/255d18177a671f804933f5a82af5767b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/280cefdd9dffa1503cbde97d85f7d312/" rel="bookmark">
			如何在本地查看SVN或Git的用户名和密码？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		控制面板——&gt;用户账户——&gt;凭据管理器——&gt;管理Windows凭据
点开后如下：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83967a68091426f707266aa9e7e80c7d/" rel="bookmark">
			vue&#43;openlayes 实现等值面geojson贴图效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用openlayers实现geojson数据的贴图效果 首先第一种要特别注意：url是一个地址 url 和 features 不要一起用 import { Map, View } from "ol"; import { Tile } from "ol/layer"; import { format } from "ol/coordinate"; import TileWMS from "ol/source/TileWMS"; import MousePosition from "ol/control/MousePosition"; import Vector from "ol/layer/Vector"; import {Style,Icon,Fill,Stroke,Text, Circle as CircleStyle} from "ol/style"; import { Feature } from "ol"; import VectorSource from "ol/source/Vector"; import { GeoJSON } from "ol/format"; addGeoJson() { //这个是我写的切换radio的颜色的方法 没需要不需要添加 let color = '#3C3EBC'; if(this.disasterColour==='1'){ color= '#3C3EBC'; }else if(this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/83967a68091426f707266aa9e7e80c7d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b58dc43c4209a5d4d08c1ff87a970992/" rel="bookmark">
			Ubuntu系统突然进不去了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		『问题描述』 安装的ubuntu双系统，头一天还用的好好的，关个机，结果第二天一来开机，进不去系统了，一直停留在黑色背景启动信息刷屏界面（主要是刷一句“xxx UID 121”之类的信息）。主机是带英伟达显卡的，所以也在ubuntu里装了相应显卡驱动。如果你的情况和我一样，也有英伟达显卡，也是重启之后突然无法正常进入系统界面，不管你是ubuntu16还是ubuntu18，或者是ubuntu20，那最大的可能原因基本只有一个，那就是系统内核文件不小心被更新了，造成了开机时系统显卡驱动加载失败，从而无法正常进入系统。
『情况截图』 开机之后停留的界面是这个界面，但是我的刷屏信息不是这些哈，图是网上找的类似的
『解决办法』 1、首先给你的电脑插上有线网
2、卡在上面的界面时，可以狂点 “Ctrl + Alt + Del”进行重启的，如果你电脑不行，那就长按电源键重启
3、当再次开始刷屏这些信息的时候，立马键盘狂点 “Ctrl + Alt +F2”，一定要非常快速的点，直到出现用户登陆终端！但是刚出现用户登陆的时候，别急着输入，因为这时候后台的信息还在刷屏，你可以看到刷屏信息的残影，稍等片刻，直到用户登陆终端稳定下来，你再输入你的用户和密码，进入命令终端系统
4、运行下面命令，关闭图形界面
sudo service lightdm stop 5、卸载英伟达显卡驱动
sudo apt remove nvidia-driver-470 sudo apt autoremove 6、重装显卡驱动（必须连上可用的有线外网）
sudo apt update sudo ubuntu-drivers autoinstall 7、安装完成后，重启系统即可
reboot 『完结撒花』 不出意外，你现在已经可以正常进入ubuntu系统了。其实这一类开机问题基本都是显卡驱动引起的，只要你的电脑有英伟达显卡，并且还安装了驱动，那突然进不去ubuntu界面，无脑重装显卡驱动即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e0a3736bf35af706aaacc849456ab34/" rel="bookmark">
			Java常见的一些经典面试题（附答案解析）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： 我想每个程序员比较头疼的事情都是：工作拧螺丝，面试造火箭吧。但是又必须经历这个过程，尤其是弄不清面试官问的问题，如果你准备的不是很充分，会导致面试的时候手足无措。今天这篇文章是从已工作5年的程序员面试几十次中挑选的面试概率比较大的一些题目，都是大家被问到过的（就是这么自信），希望这篇文章能够对大家找工作有所帮助。
基础部分 一丶抽象类和接口的区别
1.语法区别
（1）抽象类可以有构造方法，接口不能有构造方法；
（2）抽象类中可以有普通成员变量，接口中没有普通成员变量；
（3）抽象类中可以有非抽象的方法，接口中的方法都必须是抽象的；
（4）抽象类中的方法可以是public，protected类型，接口中的方法只能是public类型的，切默认为public abstract类型；
（5）抽象类中可以有静态方法，接口中不能有静态方法；
（6）抽象类中的静态变量访问类型可以是任意的，但接口中的静态变量只能是public static final 类型。
（7）.一个类可以实现多个接口，但一个类只能继承一个抽象类；
2.应用区别
接口更多是在系统架构方面发挥作用，主要用于定义模块之间的通信契约；而抽象类在代码方法 发挥作用，可以使用代码块的重用；
二丶Java中接口可不可以继承一般类，为什么？
不可以因为接口中只能出现3种成员
1.公共的静态常量(public static final )
2.公共的抽象方法(public abstract )
3.静态内部类(static class)
而一个类中,就算什么都不写,也必须带一个构造方法,在extends时就会被子类继承,如果是接口也会 继承这个构造方法,很明显构造方法不在上面三项之列
而如果类中有一般的方法和成员变量,也会被子类全部继承,这些更不能出现在接口中了,所以接口是绝 对不可能继承一个类的
三、基本数据类型的默认值？基本数据类型所占的字节
1. 默认值
（1）byte、short、int、long的默认值为0
（2）float、double默认值为0.0
（3）char默认值为空
（4）boolean默认值为false
2.所占字节
（1）byte 1个字节
（2）short 2个字节
（3）char 2个字节
（4）int 4个字节
（5）long 8个字节
（6）float 4个字节
（7）double 8个字节
四丶String属于哪个类，以及常用的方法
1.java.lang.string
2.substring()，indexOf()，concat()，endswith()，length()，replace()
五丶熟悉的网络协议
1.TCP/IP协议是一种面向连接的、可靠的协议。
TCP/IP协议中的四层分别是应用层、传输层、网络层和链路层，每层分别负责不同的通信功能，接下来针对这四层进行详细地讲解。
链路层：用于定义物理传输通道，通常是对某些网络连接设备的驱动协议，例如针对光纤、网线提供的驱动。
网络层：网络层是整个TCP/IP协议的核心，它主要用于将传输的数据进行分组，将分组数据发送到目标计算机或者网络。
传输层：主要使网络程序进行通信，在进行网络通信时，可以采用TCP协议，也可以采用UDP协议。
应用层：主要负责应用程序的协议，例如HTTP协议、FTP协议等。
2.FTP 文件传输协议，允许在网络上传输文件。
六、String、StringBuffer、StringBuilder
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e0a3736bf35af706aaacc849456ab34/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2c186ceb7eb6e9cfd9e198c89499202/" rel="bookmark">
			spark_hadoop集群搭建自动化脚本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#!/bin/bash ############################################################# #############脚本使用说明#################################### #1、使用脚本前需要弄好服务器的基础环境####################### #2、在hadoop的每个节点需要手动创建如下目录：/data/hdfs/tmp### #3、修改下面的配置参数####################################### #4、脚本执行完备后需要收到格式化namenode##################### #5、格式化指令：hdfs namenode -format######################## ############################################################# #定义参数变量 #主节点域名 master_dns='slave-3' #从节点1域名,2NN的配置地址 slave_1='slave-4' #所有从节点信息 slaves=(slave-4 slave-5) #java安装路径 java_home='/opt/java/jdk1.8.0_144' #hadoop版本信息 hadoop_version='hadoop-2.8.1' #hadoop数据存储路径 hadoop_data_path='/data/hdfs/tmp' #hadoop安装包存储路径 hadoop_install_package='/opt/package/'$hadoop_version'.tar.gz' #hdfs副本数量 dfs_replication='2' #spark版本信息 spark_version='spark-3.0.2-bin-hadoop2.7' #spark安装包存储路径 spark_install_package='/opt/package/'$spark_version'.tgz' ########################################### ##############安装hadoop################### ########################################### echo $(date) 'info: 开始安装大数据基础环境...' echo $(date) 'info: 校验java版本...' java -version echo $(date) 'info: 创建hadoop数据存储路径...' mkdir -p $hadoop_data_path echo $(date) 'info: 解压hadoop安装包...' tar -zxvf $hadoop_install_package -C /opt #配置hadoop环境变量 echo $(date) 'info: 配置hadoop环境变量..' echo 'export HADOOP_HOME=/opt/'$hadoop_version&gt;&gt;/etc/profile echo 'export PATH=$PATH:$JAVA_HOME/bin:$HADOOP_HOME/bin:$HADOOP_HOME/sbin'&gt;&gt;/etc/profile source /etc/profile #配置hadoop中hadoop-env.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2c186ceb7eb6e9cfd9e198c89499202/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c7c6ba9abaa7336460cfc5856d22d5f/" rel="bookmark">
			Window下载Android源码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android 10源码下载 想要研究Android 源码的同学可以用此方法进行下载。源码从清华大学开源软件镜像站（https://mirrors.tuna.tsinghua.edu.cn/help/AOSP/）下载。
使用Linux的同学直接参照清华镜像站提供的使用帮助(https://mirrors.tuna.tsinghua.edu.cn/help/AOSP/)即可，本文主要介绍在window平台下进行源码下载。
环境 操作系统：Window 10
Git :2.38.1
Node:v14.19.1
Node环境不是必须的，使用node是编写一个小程序实现自动下载Android源码的功能，也可以使用其他语言实现自动下载的功能。下面会详细介绍下载的逻辑。
初始化manifest仓库 我们克隆manifest仓库，这个仓库并不是安卓源码仓库，这个仓库很小，他只是列出了安卓源码仓库列表。
git clone https://mirrors.tuna.tsinghua.edu.cn/git/AOSP/platform/manifest 克隆成功后，manifest目录内容如下：
选择分支 然后我们看下分支都有什么，每个分支都对应着Android的不同版本。有很多内容，滚动条滚到下方才能看到。
cd manifest git tag 我选择了android-10.0.0_r47这个分支，他下载的就是android10源码的清单文件了。
成功之后，default.xml文件中记录的就是android10系统各个模块的路径了。
接下来，我们就要下载各个模块的源码了。
下载源码 在下载源码之前，我们先要看下default.xml文件中内容。
我们看到，已经切换到android-10.0.0_r47的分支了。
下面的每一个标签就代表一个模块。我们看下的属性：
path:是文件路径，我在下载的时候就按照这个路径存储各模块的源代码name:git地址后缀，要加上清华镜像站的地址拼成完成的地址，这个完整的路径就是模块的git仓库地址。比如platform/build 最后要拼成https://aosp.tuna.tsinghua.edu.cn/platform/build.git 然后我们梳理一下自动下载源码的功能：
1.首先，读取default.xml的文件内容，得到一个包含所有project的集合
2.然后，遍历这个集合，根据path创建本地文件夹，根据name生成完整git路径，然后执行git clone。
下面就是我用JS+Node API实现的自动下载功能：
使用了两个JS库：
xml2js: 将xml文件内容转为js的对象，然后直接这个对象的属性进行操作就行。mkdirp:Node 本身不支持创建多级目录，使用这个库可以实现创建多级目录的功能。 const fs = require('fs') const xml2js = require('xml2js') const { mkdirp } = require('mkdirp') const { spawn } = require('child_process'); //安卓源码下载路径，所有的模块都下载到这个文件夹下 const ANDROID_SRC_PATH = 'E:\\Source2023\\OS\\AndroidOS\\Android10\\' //git.exe的路径 git设置了全局变量不用这个也可以 const GIT_PATH = 'D:\\software\\Git\\bin\\git.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c7c6ba9abaa7336460cfc5856d22d5f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60943325588456ecc469a9b6270e877b/" rel="bookmark">
			【python】pandas追加写入excel
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import pandas as pd df_all = pd.DataFrame(data=None) # 创建空的 dataframe # 多数据做循环处理即可 df = pd.read_excel(file_path, header=0, sheet_name='Sheet1') # 读入数据 df_all = pd.concat([df_all, df], ignore_index=True) # concat 合并有相同字段名的dataframe data_list = df_all.drop_duplicates(keep='first') # 避免字段名重复写入，一般会做去重处理 df_all.to_excel(out_path, index=False, encoding='utf-8') # 写出数据 参考：https://blog.csdn.net/w_Olivia/article/details/121970283
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fea745134f1b60d343799ac3aed52c06/" rel="bookmark">
			verilog基本语法总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近学习了verilog基本语法，总结如下
数值表示 Verilog HDL 有下列四种基本的值来表示硬件电路中的电平逻辑：
0：逻辑 0 或 “假”1：逻辑 1 或 “真”x 或 X：未知z 或 Z：高阻 整数数值表示方法
十进制('d 或 'D)，十六进制('h 或 'H)，二进制（'b 或 'B），八进制（'o 或 'O）
指明位宽
4'b1011 // 4bit 数值 32'h3022_c0de // 32bit 的数值 下划线 _ 是为了增强代码的可读性。
不指明位宽
counter = 'd100 ; //一般会根据编译器自动分频位宽，常见的为32bit counter = 100 ; counter = 32'h64 ; 数据类型 wire 表示硬件单元间的物理连线
reg 存储单元，保持数据原有的值直到被改写（寄存器）
integer 整数
real 实数
time 时间
parameter 常量/参数
数组：在 Verilog 中允许声明 reg, wire, integer, time, real 及其向量类型的数组。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fea745134f1b60d343799ac3aed52c06/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f97fa4bae8c9808610cfd2d645e8159/" rel="bookmark">
			vue中跳转界面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在vue中3种方法跳转界面 使用 router-link 元素进行跳转 &lt;router-link to="/example"&gt;Go to Example page&lt;/router-link&gt; 使用 this.$router.push 方法进行跳转 this.$router.push('/example'); 使用 this.$router.replace 方法进行跳转 this.$router.replace('/example'); 可以使用 name 和 path 来定义和访问路由。 设置 name 和 path 可以使得路由的访问更加方便，同时可以提高代码的可读性和可维护性。
// 使用 name 访问路由 this.$router.push({ name: 'example' }); // 使用 path 访问路由 this.$router.push({ path: '/example' }); 在选择路由跳转方法时，应该根据具体的场景和需求来选择合适的方法。 在模板中进行路由跳转，并且希望能够使用 Vue.js 的内置指令来处理事件，例如@click，那么建议使用 router-link 元素进行跳转。在组件中进行路由跳转，并且希望能够在跳转时添加路由历史记录，以便用户可以通过浏览器的后退按钮回到之前的页面，那么建议使用 this.$router.push 方法进行跳转。在组件中进行路由跳转，并且希望能够在跳转时替换当前的路由记录，以便用户无法通过浏览器的后退按钮回到之前的页面，那么建议使用 this.$router.replace 方法进行跳转。 总之，选择哪种路由跳转方法取决于具体需求和场景，这些方法都具有不同的特点和用途。
window.location.href ，router-link 元素，this.$router.push，this.$router.replace三者的区别： window.location.href ： window.location.href 是 JavaScript 的一个全局对象，它提供了当前页面的 URL 地址，并且可以通过修改该属性的值来实现页面的跳转。例如：
window.location.href = 'https://www.example.com'; 使用 window.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f97fa4bae8c9808610cfd2d645e8159/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d76f0a899cf4e3337d05ec0dae445f4c/" rel="bookmark">
			RabbitMQ消息队列实战（5）—— 发后即忘和远程RPC数据传输模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文我们学习下使用RabbitMQ实现的几种数据发送的模型——发后即忘模型和远程RPC调用。二者实际上是从业务的角度定义的一个RabbitMQ的使用模型。发后即忘模型，强调发送时不太关心消息接收者的执行结果，仅仅是为了发送信息。而远程RPC调用模型强调，另外开辟通道获取消息接收者的执行结果，而且执行的结果直接影响业务。
从业务上来划分，通常我们通过MQ发出的信息可以分为三种：消息、命令和事件。对于消息来说，我们发送之后不期望会得到回复，或者说不期望马上得到回复，类似于我们接收到手机短信，只是知道这件事情。然后我们怎么去处理或者去不去处理，实际上给我们发送短信的人并不关心，所以这种情况下比较适合使用发后即忘模型。当发送的是命令时，信息的发送者明确知道接受者是谁，通过命令的方式让接收者去进行某项业务，并期望得到反馈，这种情况下比较适合采用远程RPC调用的模型。而最后一种事件，更像是在EDA（Event Driven Architecture）的系统中定义的一种命令，不过命令的格式紧紧和业务模型绑定，所以这里单独提出来叫做事件。很显然，也是使用远程RPC调用的数据发送模型比较合适。
接下来，我们将以实例的方式分别介绍发后即忘模型和远程RPC调用模型的使用。
一、发后即忘模型 我们用代码模拟这样一种业务——业务日志的记录。业务日志其实最符合发后即忘模型的要求，因为日志的记录和我们完成一个业务无关（日志记录成功与否都不会影响业务的成败）。有过编程经验的童鞋都知道，日志按照级别来划分从低到高，可以分为三种：debug、info和error。在这个模型中，我们创建一个topic exchange，然后分别以debug、info和error为主题分别绑定到三个队列。不同级别的日志消费者订阅不同的队列，然后记录到不同的日志文件（或者同一个文件使用不同的标识区分）中。
整个消息的流通图如下：
消息由生产者产生之后，通过一个topic交换机，根据不同的topic发送到响应的队列中，然后定义了3个消费者，每个消费者订阅了存放不同级别日志的通道，获取消息后进行相应的处理。
我们决定采用spring boot集成RabbitMQ的方式实现，首先配置相关的exchange、binding和queue，如下代码：
@Configuration public class RabbitConfig { @Value("${spring.rabbitmq.host}") private String host; @Value("${spring.rabbitmq.port}") private int port; @Value("${spring.rabbitmq.username}") private String username; @Value("${spring.rabbitmq.password}") private String password; @Bean public ConnectionFactory connectionFactory() { CachingConnectionFactory connectionFactory = new CachingConnectionFactory(host, port); connectionFactory.setUsername(username); connectionFactory.setPassword(password); connectionFactory.setVirtualHost("/"); connectionFactory.setPublisherConfirms(true); return connectionFactory; } @Bean @Scope(ConfigurableBeanFactory.SCOPE_SINGLETON) public RabbitTemplate rabbitTemplate() { RabbitTemplate template = new RabbitTemplate(connectionFactory()); return template; } @Bean TopicExchange logTopicExchange() { return new TopicExchange("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d76f0a899cf4e3337d05ec0dae445f4c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3111d3c82e65c0a3dee4066ef51d38d5/" rel="bookmark">
			PCM音频 &amp;&amp; I2S音频
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PCM(Pulse Code Modulation)也被称为脉码编码调制。PCM中的声音数据没有被压缩，如果是单声道的文件，采样数据按时间的先后顺序依次存入。关于PCM的详细细节可以参考http://blog.csdn.net/yue7603835/article/details/42029647。
因为PCM没有压缩，它一定满足一个公式：capacity(bit) = time(s)*(16/8 bit/point)*n(point/s)*(L/R)，最左边表示容量，位为单位；time单位是音频持续时间，秒为单位；采样位数跟一个点的采样精度有关，为1字节8位，或者2字节16位；n是采样率，即一秒钟才用多少个点；L/R表示是立体声还是单声道，前者是2后者是1。所以当我们对一段音频的采样率不太确定时，根据录制的音频文件的大小，时间，采样率和采样精度等参数，可以反推出采样率的多少。
分析PCM raw声音文件，可借助PCM分析工具Audacity，声音内容和幅度都可以用波形表现出来 。PCM接口定义（PCM-clock、PCM-sync、PCM-in、PCM-out）脉冲编码调制，模拟语音信号经过采样量化以及一定数据排列就是PCM了。理论上可以传输单声道，双声道立体声和多声道，是数字音频的raw data。
===============================I2S音频 ===============
I2S有3个主要信号：
1.串行时钟SCLK，也叫位时钟（BCLK），即对应数字音频的每一位数据，SCLK都有1个脉冲。SCLK的频率=2×采样频率×采样位数 2. 帧时钟LRCK，用于切换左右声道的数据。LRCK为“1”表示正在传输的是左声道的数据，为“0”则表示正在传输的是右声道的数据。LRCK的频率等于采样频率，所以播放不同的wav文件，LRCK和BCLK都可能是不同的。
3.串行数据SDATA，就是用二进制补码表示的音频数据。I2S（Inter-IC Sound Bus）是飞利浦公司为数字音频设备之间的音频数据传输而制定的一种总线标准。在飞利浦公司的I2S标准中，既规定了硬件接口规范，也规定了数字音频数据的格式。有时为了使系统间能够更好地同步，还需要另外传输一个信号MCLK，称为主时钟，也叫系统时钟（Sys Clock），是采样频率的256倍或384倍。
随着技术的发展，在统一的 I2S接口下，出现了多种不同的数据格式。根据SDATA数据相对于LRCK和SCLK的位置不同，分为左对齐（较少使用）、右对齐（也叫日本格式、普通格式）和I2S格式（即飞利浦规定的格式）。这些格式如上说描述，综上为了保证数字音频信号的正确传输，发送端和接收端应该采用相同的数据格式和长度。三种信号的概略图如下：
对于第三种I2S格式，信号无论有多少位有效数据，数据的最高位总是出现在LRCK变化（也就是一帧开始）后的第2个SCLK脉冲处（如上）。这就使得接收端与发送端的有效位数可以不同。如果接收端能处理的有效位数少于发送端，可以放弃数据帧中多余的低位数据；如果接收端能处理的有效位数多于发送端，可以自行补足剩余的位。这种同步机制使得数字音频设备的互连更加方便，而且不会造成数据错位。 参考原文：I2S标准_i2s接收到全是0_besthyq的博客-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f6ba25b2d9bab0727b543110ffb5888/" rel="bookmark">
			迁移学习总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		迁移学习与fine-tuning有什么区别？
举个例子，假设今天老板给你一个新的数据集，让你做一下图片分类，这个数据集是关于Flowers的。问题是，数据集中flower的类别很少，数据集中的数据也不多，你发现从零训练开始训练CNN的效果很差，很容易过拟合。怎么办呢，于是你想到了使用Transfer Learning，用别人已经训练好的Imagenet的模型来做。
做的方法有很多：
把Alexnet里卷积层最后一层输出的特征拿出来，然后直接用SVM分类。这是Transfer Learning，因为你用到了Alexnet中已经学到了的“知识”。把Vggnet卷积层最后的输出拿出来，用贝叶斯分类器分类。思想基本同上。甚至你可以把Alexnet、Vggnet的输出拿出来进行组合，自己设计一个分类器分类。这个过程中你不仅用了Alexnet的“知识”，也用了Vggnet的“知识”。最后，你也可以直接使用fine-tune这种方法，在Alexnet的基础上，重新加上全连接层，再去训练网络。 综上，Transfer Learning关心的问题是：什么是“知识”以及如何更好地运用之前得到的“知识”。这可以有很多方法和手段。而fine-tune只是其中的一种手段。
SPPNet（Spatial Pyramid Pooling Convolutional Networks，空间金字塔池化卷积网络）将CNN的输大从固定尺寸改进为任意尺寸。在普通的CNN结构中，输入图像的尺寸往往是固定的，输出可以看做是一个固定维数的向量。SPPNet在普通的CNN结构中加入了ROI池化层(ROI Pooling )，使得网络的输入图像可以是任意尺寸的，输出一个固定维数的向量。ROI池化层一般跟在卷积层后面，它的输入是任意大小的卷积，输出是固定维数的向量，如图5-3所示。
设卷积层输出的宽度为w，高度为h，通道为c。不管输入的图像尺寸w,h是多少，卷积层的通道数c是一个常数。
ROI池化层首先把卷积层划分为4x4的网格，每个网格的宽是w/4、高是h/4、通道数为c（不能整除时，需要取整）。对每个网格中的每个通道，都取出其最大值，对每个网格内的特征做最大值池化。这个4x4的网格最终就形成了16c维的特征。再把网络划分成2x2的网格，用同样的方法提取特征，提取的特征的长度为4c。网络划分为1x1的网格，提取的特征的长度为c,最后的1x1的划分实际是取出卷积中每个通道的最大值。将得到的特征拼接起来，得到的特征是16c+4c+c = 21c维的特征。这个输出特征的长度与w, h两个值是无关的，因此ROI池化层可以把任意宽度、高度的卷积特征转换为固定长度的向量。 迁移学习的使用场景
使用迁移学习的主要原因在于数据资源的可获得性和训练任务的成本。当我们有海量的数据资源时，自然不需要迁移学习，机器学习系统很容易从海量数据中学习到一个鲁棒性很强的模型。但通常情况下，我们需要研究的领域可获得的数据极为有限，仅靠有限的数据量进行学习，所习得的模型必然是不稳健、效果差的，通常情况下很容易造成过拟合，在少量的训练样本上精度极高，但是泛化效果极差。另一个原因在于训练成本，即所依赖的计算资源和耗费的训练时间。通常情况下，很少有人从头开始训练一整个深度卷积网络，一个是上面提到的数据量的问题，另一个就是时间成本和计算资源的问题，从头开始训练一个卷积网络通常需要较长时间且依赖于强大的 GPU 计算资源，对于一门实验性极强的领域而言，花费好几天乃至一周的时间去训练一个自己心里都没谱的深度神经网络通常是不能忍受的。
深度卷积网络的可迁移性
卷积神经网络具备良好的层次结构，通常而言，普通的卷积神经网络都具备卷积-池化-卷积-池化-全连接这样的层次结构，在深度可观时，卷积神经网络可以提取图像各个 level 的特征。当我们要从图像中识别一张人脸的时候，通常在一开始我们会检测到图像的横的、竖的等边缘特征，然后会检测到脸部的一些曲线特征，再进一步会检测到脸部的鼻子、眼睛和嘴巴等具备明显识别要素的特征等等。
这便揭示了深度卷积网络可迁移性的基本原理和卷积网络训练过程的基本事实。具备良好层次的深度卷积网络通常都是在最初的前几层学习到图像的通用特征（general feature），但随着网络层次的加深，卷积网络便逐渐开始检测到图像的特定的特征，两个任务系统的输入越相近，深度卷积网络检测到的通用特征越多，迁移学习的效果越好。
迁移学习的使用方法
通常而言，迁移学习有两种使用套路。第一种便是常说的 finetune，即微调，简单而言就是将别人训练好的网络拿来进行简单修改用于自己的学习任务。在实际操作中，通常用预训练的网络权值对自己网络的权值进行初始化，以代替原先的随机初始化。第二种称为 fixed feature extractor，即将预训练的网络作为新任务的特征提取器，在实际操作中通常将网络的前几层进行冻结，只训练最后的全连接层，这时候预训练网络便是一个特征提取器。
keras 为我们提供了经典网络在 ImageNet 上为我们训练好的预训练模型，预训练模型的基本信息如下表所示：
迁移学习方法可分类为：
归纳式迁移学习（Inductive Transfer learning）：在该场景中，源域和目标域相同，但源任务和目标任务彼此不同。算法尝试利用来自源域的归纳偏差帮助改进目标任务。根据源域中是否包含标记数据，归纳式迁移学习可以进一步分为类似于多任务学习（multitask）和自学习（self-taught）这两类方法。
无监督迁移学习（Unsupervised Transfer Learning）：该场景类似于归纳式迁移学习，重点关注目标域中的无监督任务。其中，源域和目标域类似，但是任务不同。在该场景中，任一域都没有可用的标记数据。
直推式迁移学习（Transductive Transfer Learning）：在该场景中，源任务和目标任务之间存在一些相似之处，但相应的域不同。源域具有大量标记数据，而目标域没有。根据特征空间或边缘概率的设置不同，直推式迁移学习可进一步分类为多个子类。
下表总结了上述技术的不同设置和场景。
上面介绍的三种迁移类别，详细列出了可应用和研究迁移学习的不同设置。下列方法可回答在类别间迁移什么的问题：
基于样本的迁移学习（Instance transfer）：通常，理想场景是源域中的知识可重用到目标任务。但是在大多数情况下，源域数据是不能直接重用的。然而，源域中的某些实例是可以与目标数据一起重用，达到改善结果的目的。对于归纳式迁移，已有一些研究利用来自源域的训练实例来改进目标任务，例如 Dai 及其合作研究者对 AdaBoost 的改进工作。
基于特征表示的迁移学习（Feature-representation transfer）: 该类方法旨在通过识别可以从源域应用于目标域的良好特征表示，实现域差异最小化，并降低错误率。根据标记数据的可用性情况，基于特征表示的迁移可采用有监督学习或无监督学习。
基于参数的迁移学习（Parameter transfer）: 该类方法基于如下假设：针对相关任务的模型间共享部分参数，或超参数的先验分布。不同于同时学习源和目标任务的多任务学习，在迁移学习中我们可以对目标域应用额外的权重以提高整体性能。
基于关系知识的迁移学习（Relational-knowledge transfer）: 与前面三类方法不同，基于关系知识的迁移意在处理非独立同分布（i.i.d）数据即每个数据点均与其他数据点存在关联。例如，社交网络数据就需要采用基于关系知识的迁移学习技术。
下表清晰地总结了不同迁移学习策略间的关系，以及迁移什么的问题。
深度迁移学习策略
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f6ba25b2d9bab0727b543110ffb5888/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1321dfe29ebaaa10d7c6c940c8ff5b4e/" rel="bookmark">
			第三节 SpringBoot项目配置及yaml文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第三节 SpringBoot项目配置及yaml文件 1. Spring Boot项目配置2. yaml文件3. yml和properties的比较 ​ Spring Boot项目可以通过多种方式进行配置，包括application.properties文件、application.yml文件、命令行参数、环境变量等。这些配置可以用来设置应用程序的端口号、数据库连接信息、日志级别等。 1. Spring Boot项目配置 ​ application.properties 配置文件是创建项目后就自带的，如果我们要自定义属性，可以在其中直接配置，配置过程如下：
在 application.properties 中添加我们要自定义的配置；
demo.id=8888 demo.name=demo 创建实体类来映射我们配置的属性；
package com.demo.pojo; import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.stereotype.Component; @Component @ConfigurationProperties(prefix = "demo") @Data @NoArgsConstructor @AllArgsConstructor public class DemoProperties { private int id; private String name; } 定义 Controller 来注入测试；
package com.demo.controller; import com.demo.pojo.demoProperties; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RequestMapping; import org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1321dfe29ebaaa10d7c6c940c8ff5b4e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51e3cc41df3f7db037460e7519345907/" rel="bookmark">
			vite-plugin-style-import 动态按需引入element-plus
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装 npm i vite-plugin-components -D
npm i vite-vite-plugin-style-import -D
import { defineConfig } from 'vite' // 使用 defineConfig 帮手函数，这样不用 jsdoc 注解也可以获取类型提示 import vue from '@vitejs/plugin-vue' // import styleImport from 'vite-plugin-style-import' //2.0之后版本用createStyleImportPlugin import { createStyleImportPlugin, VantResolve } from 'vite-plugin-style-import'; import ViteComponents, { ElementPlusResolver } from 'vite-plugin-components' const { resolve } = require("path"); export default ({ command, mode }) =&gt; { let isProd = (command === 'build') // 情景配置 是否为开发模式 serve 或 build return defineConfig({ plugins: [vue(), //按需导入element-plus组件 ViteComponents({ customComponentResolvers: [ElementPlusResolver()], }), //按需导入element-plus的css样式 // styleImport({ // libs: [ // { // libraryName: 'element-plus', // esModule: true, // resolveStyle: (name) =&gt; { // return `element-plus/lib/theme-chalk/${name}.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/51e3cc41df3f7db037460e7519345907/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/426843d560a6c33b2b6471fcc23ddfb8/" rel="bookmark">
			Java进阶
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java是一种广泛使用的编程语言，具有强大的功能和广泛的应用场景。在掌握Java基础知识之后，进一步学习Java的进阶知识点对于提高编程能力和解决实际问题非常有帮助。本文将介绍一些Java的进阶知识点，包括Lambda表达式、函数式接口、Stream API、反射、泛型、注解等。
一、Lambda表达式
Lambda表达式是Java 8中引入的一种新特性，它可以用更简洁的语法来实现匿名函数的定义。Lambda表达式的语法如下：
(parameter1, parameter2, ..., parameterN) -&gt; { statement1; statement2; ... } 其中，参数列表可以为空或包含一个或多个参数，语句块可以为空或包含一个或多个语句。Lambda表达式的返回值类型由上下文推断得出。
使用Lambda表达式可以简化代码，提高代码的可读性和可维护性。下面是一个使用Lambda表达式实现排序的例子：
List&lt;String&gt; list = Arrays.asList("apple", "banana", "orange");Collections.sort(list, (s1, s2) -&gt; s1.compareTo(s2)); 二、函数式接口
函数式接口是只包含一个抽象方法的接口，可以使用Lambda表达式来实现。Java 8中提供了一些常用的函数式接口，如Function、Predicate、Consumer等。下面是一个使用Predicate接口的例子：
List&lt;String&gt; list = Arrays.asList("apple", "banana", "orange");Predicate&lt;String&gt; predicate = s -&gt; s.startsWith("a");list.stream().filter(predicate).forEach(System.out::println); 在上面的例子中，使用Predicate接口来过滤以字母"a"开头的字符串。
三、Stream API
Stream API是Java 8中引入的一种用于处理集合数据的API，它提供了一种新的处理方式，可以帮助程序员更加方便地处理集合数据。Stream API可以用于对集合数据进行过滤、映射、排序等操作。下面是一个使用Stream API的例子：
List&lt;String&gt; list = Arrays.asList("apple", "banana", "orange");list.stream().filter(s -&gt; s.startsWith("a")).map(String::toUpperCase).sorted().forEach(System.out::println); 在上面的例子中，使用Stream API来过滤以字母"a"开头的字符串，将结果转换为大写字母并排序输出。
四、反射
反射是Java中一种强大的机制，它可以在运行时动态地获取类的信息和操作类的属性、方法等。使用反射机制可以使程序更加灵活，但同时也会带来一些性能问题。下面是一个使用反射机制获取类信息的例子：
Class&lt;?&gt; clazz = Class.forName("java.lang.String");Field[] fields = clazz.getDeclaredFields();for (Field field : fields) { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/426843d560a6c33b2b6471fcc23ddfb8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f052ef601f10d8ef038e389b9a581567/" rel="bookmark">
			python基础篇-for循环
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、for循环的语法 Python中，for语句是一种迭代控制流语句，可以用于遍历序列（如字符串、列表、元组、字典、集合）中的每个元素，或者执行指定次数的循环。for循环语句的语法结构如下：
for 变量 in 序列: # 循环体代码块 二、for循环的使用规则 for循环的执行顺序是从序列的第一个元素开始，依次遍历到最后一个元素；
可以通过range()函数来指定遍历序列的范围，比如range(5)表示遍历0~4的整数序列；
Python中的for循环通常不需要使用计数器，而是直接使用遍历序列中的元素；
for循环可以使用break和continue语句来控制循环的执行流程，其中break用于退出循环，而continue用于跳过某个元素继续执行下一个元素；
对于一些常见的序列类型（如字符串、列表等），可以使用内置函数len()获取序列的长度，从而确定for循环的遍历范围；
可以使用enumerate()函数来同时获取序列中的元素和它们的索引；
如果需要对多个序列进行遍历，可以使用zip()函数将它们组合成一个zip对象，然后再在for循环中依次取出每个元素；
三、使用for循环时的注意事项 循环次数的计算：要确保for循环的遍历范围正确，避免遗漏或重复访问序列中的元素。可以使用len()函数获取序列的长度，并配合range()、enumerate()或zip()等函数实现对序列的遍历；
循环变量的作用域：for循环中定义的变量只在循环体内部有效，在循环体外无法访问。因此需要根据实际需要进行变量的定义和赋值；
循环体的缩进：Python中使用缩进来表示代码块的层次结构，在for循环中必须正确缩进循环体，并保持一致的缩进风格；
注意循环控制语句的使用：可以使用break、continue等语句控制for循环的执行流程，但要避免滥用和误用，以免导致代码逻辑混乱或死循环等问题。
四、for循环的常用操作 遍历列表 fruits = ['苹果', '香蕉', '橘子'] for fruit in fruits: print(fruit) 苹果 香蕉 橘子 遍历字典 遍历键
my_dict = {'a': 1, 'b': 2, 'c': 3} for key in my_dict: print(key) a b c 遍历值
my_dict = {'a': 1, 'b': 2, 'c': 3} for key in my_dict: print(key) 1 2 3 遍历键值对
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f052ef601f10d8ef038e389b9a581567/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5927426dea078db9a2a5e6183c7924e8/" rel="bookmark">
			rockchip io 指令无法运行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		指令报错如下：
io -4 -l 0x8 0xfdc60074 open /dev/mem: No such file or directory
解决方案：
在 kernel/configs/rockchip/android-11.config文件中添加：
CONFIG_DEVMEM=y
CONFIG_ARCH_HAS_DEVMEM_IS_ALLOWED=Y
CONFIG_STRICT_DEVMEM=Y
注意：只能单独编译烧录kernel，全编译会报错
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1fc3fba1f4af029c33a29223ee3a3cf8/" rel="bookmark">
			C#&amp;.net&amp;Enum枚举转数字转String小扩展，用起来更方便！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		搞这个的原因：
一般来说，搞个枚举如下：
public enum Sex { Man = 1, Wommen = 5, } // 枚举转 int 再转 String string str = ((int)Sex.Women).ToString(); 偶尔写那么一两次还好，要用的多了比较麻烦。
稍微研究了下，可如此封装个扩展。
// 随便搞个静态类，写个静态方法，以下是我自测好OK的 public static class ExtendTools { public static string ToStringIndex&lt;T&gt;(this T input) { var type = typeof(T); if (type.BaseType.FullName == "System.Enum") { object enumVal = input; return ((int)enumVal).ToString(); } return "";// 不是枚举类型返回 "" 还是 null 这个可以根据自己需要来 } } 然后调用就简单了，直接用枚举点就行，但不是枚举类型返回 “” 还是 null 这个可以根据自己需要来。
用法示例：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1fc3fba1f4af029c33a29223ee3a3cf8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2107a03f976650e22e6c8c45db44714/" rel="bookmark">
			mysql笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引擎 myisam 5.5.8版本前默认的储存引擎，适合读多写少的表，支持表锁，支持全文索引，会储存表的总行数，不支持事务，不支持行锁，一个表有储存成三个文件，结构(frm），数据(myd)，索引(myi）。索引结构默认使用b+Tree类型
innodb 5.5.8版本后默认的储存引擎，适合需要数据一致性要求高的表，支持行锁，支持外键，支持事务，支持自动灾难恢复，不储存总行数，一个表有两个文件，数据，结构。索引结构默认使用b+Tree类型
索引 介绍 索引其实是一种数据结构，可以帮助我们快速检索数据库的数据。
索引的数据结构 介绍：常用的有B+tree和hash结构。myisam和innodb引擎默认的是B+tree结构，也只支持B+tree（但是innoDB存储引擎支持hash索引是自适应的，innoDB存储引擎会根据表的使用情况自动为表生成hash索引，不能人为干预是否在一张表中生成hash索引。)
Hash：是以key-value储存数据的结构，数据结构上是没有顺序的，所以适合等值查询，对于区间查询无法直接通过索引查询，需要全表扫描，也无法通过索引进行排序，并且不支持联合索引的最左匹配原则
B+tree：是一种多路平衡查询树，节点是有序的(左子节点小于父节点，父节点小于右子节点)，因为是有序的，所以对于范围查询不需要全表扫描。引擎不同结构也会不同。
在innodb中，表数据本身就是按照B+树结构进行储存的，叶子节点存放的是整行数据，key就是表的主键，所以innodb表必须有一个主键，如果建表的时候指定了主键，那就用这个，没指定就会选择第一个非空唯一索引做主键，如果两个都没有，innodb会建立一个隐藏的主键列(字段长度为6个字节，类型为长整形)，这就是常说的主键(聚集｜聚簇)索引。再之后建立的索引也是按照B+树形式存储，不同的是叶子节点存的是主键的key值和索引的key值，这是非主键(非聚集｜非聚簇｜辅助)索引。主键索引因为叶子节点存的是整行数据，所以查到数据后可以直接返回。非主键索引会分为两种情况，一种是当有查询列不在索引中时会进行回表操作，也就是根据非主键索引叶子节点的主键id再去主键索引那取出数据，另一种是当查询列都在索引中时直接返回数据，这也就是我们说的覆盖索引。
在myisam中叶子节点存放的是数据文件中对应记录的地址，节点上只有这个索引列的值。辅助索引和主索引在结构上没有区别，只是主索引要求key是唯一的，辅助索引可以重复。
索引类型 【普通索引】只为查询更快一点，没别的限制
【主键索引】值是唯一的，且不允许有空值
【唯一索引】值是唯一的，允许有空值
【联合索引】包含多个列，需遵循最左前缀
【全文索引】myisam支持，5.7后innodb开始支持全文索引
索引下推 5.6版本对索引引入了索引下推，默认开启，例如表中有联合索引name,age，查询条件为name like '张%' and age = 20，未开启索引下推则查询到在辅助索引中第一个字为张的主键值后，再根据主键到聚集索引中查询并判断age(回表)，符合age=20的返回记录，开启了索引下推则在辅助索引中查询第一个字为张的主键值后，因为age在也在索引中，会顺便判断一下age是否等于20，等于20的再回表查询
事务 【基本要素】
原子性，一致性，隔离性，持久性
【并发问题】
脏读：事务A读取了事务B更新的数据，然后B回滚了，那么A读取的数据就是脏数据
不可重复读：事务A第一次查询数据后，事务B修改并提交了数据，之后事务A第二次查询发现数据结果不一致
幻读：事务A第一次查询数据后，事务B插入或删除了一条符合事务A查询的数据，之后事务A再一次查询发现条数不一样了
【隔离级别】
读未提交：最低级别，一般不用
读提交：可解决脏读
可重复读：默认，可解决脏读，不可重复读，使用间隙锁可解决幻读。
串行化：可解决脏读，不可重复读，幻读，但是并发能力太差，一般不用
【锁】
表锁：开销小，加锁快，不会出现死锁，锁冲突概率大，并发能力最差
行锁：开销大，加锁慢，会出现死锁，锁冲突概率小，并发能力最高，主要用于innodb
页锁：开销中等，加锁中等，会出现死锁，并发度一般
myisam表锁：分为表共享读锁、和表独占写锁。也就是读操作不会堵塞其他用户对同一表的读操作，但会堵塞写操作。另外，写操作会堵塞其他用户对同一表的读和写操作。myisam执行select前，会自动加读锁。执行update｜delete｜insert前会自动加写锁。concurrent_insert=2允许在表尾并发插入记录
innodb行锁：分为共享锁和排他锁，为了让行锁和表锁共存，innodb也加入了意向锁概念，也就是意向共享锁和意向排他锁。当一个事务需要给某个资源加锁的时候，如果别的共享锁也在锁定自己需要的资源，那么自己可以再加一个共享锁，但不能加排他锁。如果遇见的是排他锁，那么就需要等待资源释放才可以加共享锁或者排他锁。意向锁的作用是当事务需要给资源加锁时，如果遇到别的事务已经加了排他锁，那么自己可以在需要锁定行的表上面加一个意向共享锁或者意向排他锁，但是意向共享锁可以是多个，意向排他锁只能是一个。意向锁是innodb自动加的，不需要用户操作。而对于update｜delete｜insert操作innodb会自动加排他锁，select则需要用户自己指定锁，共享锁lock in share mode，排他锁for update。innodb是通过在索引上加锁实现的行锁，所以只有通过索引操作数据才会加行锁，要不然会加表锁
死锁：两个或多个事务在同一资源上相互占用，并请求锁定对方占用的资源
间隙锁：如果使用范围索引查询数据时，innodb会将这个范围加锁，同时也包括了在范围内但不存在的数据，这些数据就是间隙，间隙锁就是给这些间隙也加上了锁，可以防止幻读
MVCC 【介绍】　多版本并发控制，主要是为了提高数据库的并发性能，更好的处理读写冲突。最早的数据库系统只有读读之间可以并行，读写、写写之间都会阻塞；引入了多版本后，只有写写会阻塞，其他操作都可以并行。
【当前读】
读取的记录都是目前数据库的最新版本，读取时要保证其他并发事务不能修改当前记录，所以会对读取数据加锁。例如select lock in share mode，select for update，update，insert，delete
【快照读】
读取的记录不一定是目前数据库的最新版本，有可能是历史版本。例如不加锁的select，前提是隔离级别不能是串行级别，串行级别下快照读会退化成当前读
【实现原理】
主要依赖row中额外的隐式字段，undo日志，Read View来实现
隐式字段
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d2107a03f976650e22e6c8c45db44714/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/972f36acf8927f0c5f6363ef2a7feb81/" rel="bookmark">
			CentOS7用yum安装Nginx及使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一步：yum安装nginx 1：添加源
sudo rpm -Uvh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm 2：安装nginx
sudo yum install -y nginx 出现Complete!代表安装完成!
3：启动nginx
systemctl start nginx.service 4：查看防火墙开启的端口
firewall-cmd --zone=public --list-ports 我的为空，什么端口都没开放，开放了的会有80/tcp
5：开放80端口（已开放80端口的就不用执行了）
firewall-cmd --zone=public --add-port=80/tcp --permanent 6：防火墙配置生效（已开放80端口的就不用执行了）
firewall-cmd --reload 7：再次查看开放的端口
firewall-cmd --zone=public --list-ports 有了，80/tcp
8：浏览器输入ip访问
访问成功！
注：service访问目录如果在别的盘（如/www或/home），需要关闭selinux或者设置成宽容模式（setenforce 0），不然会报403错误
#查看当前状态 systemctl status nginx.service #启动 systemctl start nginx.service #停止 systemctl stop nginx.service #重启 systemctl restart nginx.service #开机自启动 systemctl enable nginx.service #停止开机自启动 systemctl disable nginx.service 9：nginx常用命令
#帮助 nginx -?或nginx -h 列出了可以使用的命令
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/972f36acf8927f0c5f6363ef2a7feb81/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a36d8265ceff0ee261e5cdac8cf84fd7/" rel="bookmark">
			httpVueLoader使用示例（用于cdn引入vue2后在html文件中使用组件开发）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：现在在维护公司的老项目，用的原生+jq开发，太麻烦，我就引入了vue2，但是发现无法组件开发，代码也不是多好看，首页代码更是好几千行。于是找了这个在html上也能导入并使用vue组件的办法。
首先百度下载httpVueLoader.js，没有的话新建js文件粘贴也行，代码有点长，放最后面了，先放上使用代码
html文件(样式啥的直接忽略，懒得删了)： &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, minimal-ui"/&gt; &lt;meta name="apple-mobile-web-app-capable" content="yes"/&gt; &lt;meta name="apple-mobile-web-app-status-bar-style" content="black"/&gt; &lt;meta name="format-detection" content="telephone=no, email=no"/&gt; &lt;link rel="stylesheet" href="../../store/css/vant2.css"&gt; &lt;script type="text/javascript" src="../../store/plugin/jquery-3.4.1.min.js"&gt;&lt;/script&gt; &lt;script src="../../store/js/vue.min.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; &lt;!-- 引入vue文件子组件必备js--&gt; &lt;script src="js/httpVueLoader.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="../../store/js/vant2.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;style&gt; [v-cloak] { display: none; } *{ margin: 0; padding: 0; /* 设置的边框和内边距的值时包含在总宽高内的 */ box-sizing: border-box; } /*隐藏滚动条*/ ::-webkit-scrollbar { display: none } /*看那个加载更多显示的位置对不对而改样式*/ .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a36d8265ceff0ee261e5cdac8cf84fd7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3cc4d3e67570cf8c6881b5c4d44d085/" rel="bookmark">
			chatgpt的150个指令大全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		chatGPT输出结果的质量高低，和你使用什么样质量的输入内容有关。
在外网有大佬们已经整理出一些标准的问话模板，直接拿来使用后，效果极佳！
把已经过验证的优质问法可以直接拿来用，希望可以帮到你更好地入手chatGPT！
总结来说，有个通用公式：
优质的问法= who+what+how+begin
（1）who：我需要你成为XXX；
（2）what：你要做什么；
（3）how：有哪些注意事项；
（4）how begin：现在第一步是什么。
今天，小编整理了一些常用的ChatGPT指令，可以通过这些指令让AI帮你整理资料、撰写报告、知识学习、准备面试等等，赶紧收藏起来吧！
如果还没有找到工具，可以看看如下的AI工具导航。
所有提示词模板功能列表
💻 充当 Linux 终端
我想让你充当 Linux 终端。我将输入命令，您将回复终端应显示的内容。我希望您只在一个唯一的代码块内回复终端输出，而不是其他任何内容。不要写解释。除非我指示您这样做，否则不要键入命令。当我需要用英语告诉你一些事情时，我会把文字放在大括号内{like this}。我的第一个命令是 pwd
🇺🇸 充当英语翻译和修改者
我想让你充当英语翻译员、拼写纠正员和改进员。我会用任何语言与你交谈，你会检测语言，翻译它并用我的文本的更正和改进版本用英语回答。我希望你用更优美优雅的高级英语单词和句子替换我简化的 A0 级单词和句子。保持相同的意思，但使它们更文艺。我要你只回复更正、改进，不要写任何解释。我的第一句话是“istanbulu cok seviyom burada olmak cok guzel”
💼 担任岗面试官
我想让你担任面试官。我将成为候选人，您将向我询问该position职位的面试问题。我希望你只作为面试官回答。不要一次写出所有的守恒。我希望你只对我进行采访。问我问题，等待我的回答。不要写解释。像面试官一样一个一个问我，等我回答。我的第一句话是“嗨”
💻 充当 JavaScript 控制台
我希望你充当 javascript 控制台。我将键入命令，您将回复 javascript 控制台应显示的内容。我希望您只在一个唯一的代码块内回复终端输出，而不是其他任何内容。不要写解释。除非我指示您这样做，否则不要键入命令。当我需要用英语告诉你一些事情时，我会把文字放在大括号内{like this}。我的第一个命令是 console.log(“Hello World”);
💻充当Excel工作表
我希望你充当基于文本的 excel。您只会回复我基于文本的 10 行 Excel 工作表，其中行号和单元格字母作为列（A 到 L）。第一列标题应为空以引用行号。我会告诉你在单元格中写入什么，你只会以文本形式回复 excel 表格的结果，而不是其他任何内容。不要写解释。我会写你的公式，你会执行公式，你只会回复 excel 表的结果作为文本。首先，回复我空表。
🎙️充当英语发音助手
我想让你为说土耳其语的人充当英语发音助手。我会给你写句子，你只会回答他们的发音，没有别的。回复不能是我的句子的翻译，而只能是发音。发音应使用土耳其语拉丁字母进行注音。不要在回复上写解释。我的第一句话是“伊斯坦布尔的天气怎么样？”
🗺️充当旅游指南
我想让你做一个旅游指南。我会把我的位置写给你，你会推荐一个靠近我的位置的地方。在某些情况下，我还会告诉您我将访问的地方类型。您还会向我推荐靠近我的第一个位置的类似类型的地方。我的第一个建议请求是“我在伊斯坦布尔/贝尤鲁，我只想参观博物馆。”
📝 充当搜查员
我想让你充当剽窃检查员。我会给你写句子，你只会用给定句子的语言在抄袭检查中未被发现的情况下回复，别无其他。不要在回复上写解释。我的第一句话是“为了让计算机像人类一样行动，语音识别系统必须能够处理非语言信息，例如说话者的情绪状态。”
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3cc4d3e67570cf8c6881b5c4d44d085/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6495df198055b1aef555b09379fdbc1/" rel="bookmark">
			函数的嵌套调用和链式访问
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
嵌套调用
链式访问
嵌套调用 在编程中，我们在实现功能时，不止需要一个函数，可能需要用到多个函数的调用。并且函数和函数之间是可以根据实际的需求进行组合的，也就是互相调用。
嵌套调用就是函数内部调用一个或多个函数。
嵌套调用大致思想就是把一个个函数当成模块调用。例如：
代码示例：
#define _CRT_SECURE_NO_WARNINGS 1 #include&lt;stdio.h&gt; //打印加法计算机中的界面 void print() { printf("***************\n"); printf("******计算*****\n"); printf("***************\n"); } //计算 void counter(int a, int b) { print(); printf("%d\n", a + b); } int main() { int a = 0; int b = 0; scanf("%d %d", &amp;a, &amp;b); counter(a, b); return 0; } 主函数中调用函数counter，函数counter中又嵌套调用函数print。
这里要注意函数可以嵌套调用，但是不能嵌套定义。例如：下面这段错误代码
链式访问 链式访问：把一个函数的返回值作为另外一个函数的参数。
链式访问大致思想就是把一个个函数的返回值像链条一样串起来。例如：
代码示例：
#include&lt;stdio.h&gt; int main() { printf("%d", printf("%d",printf("%d",43))); //printf函数的返回值是打印在屏幕上字符的个数（空格也算） return 0; } 结果为：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d6495df198055b1aef555b09379fdbc1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29cef02f16c64f564f0f81d64f75ee0e/" rel="bookmark">
			oracle相关
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 查询表名，表注释，表记录
SELECT
T .TABLE_NAME,
c.comments,
T .NUM_ROWS
FROM
USER_TABLES T
LEFT JOIN user_tab_comments c ON T .TABLE_NAME = c.table_name;
2 查询表名、表注释、字段名、字段注释
SELECT
T.TABLE_NAME,
c.comments tableComments,
cc.column_name,
cc.comments colComments
FROM
USER_TABLES T
LEFT JOIN user_tab_comments c ON T .TABLE_NAME = c.table_name
LEFT JOIN user_col_comments cc ON T .TABLE_NAME = cc.table_name
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/548e7689fe3c132e0b19fbb8ebb653cd/" rel="bookmark">
			第十二章_Redis单线程 VS 多线程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Redis为什么选择单线程？
是什么
这种问法其实并不严谨，为啥这么说呢?
Redis的版本很多3.x、4.x、6.x，版本不同架构也是不同的，不限定版本问是否单线程也不太严谨。
1 版本3.x ，最早版本，也就是大家口口相传的redis是单线程。 2 版本4.x，严格意义来说也不是单线程，而是负责处理客户端请求的线程是单线程，但是 开始加了点多线程的东西(异步删除)。---貌似 3 2020年5月版本的6.0.x后及2022年出的7.0版本后， 告别了大家印象中的单线程，用一种全新的多线程来解决问题。---实锤 有几个里程碑式的重要版本 5.0版本是直接升级到6.0版本，对于这个激进的升级，Redis之父antirez表现得很有信心和兴奋，
所以第一时间发文来阐述6.0的一些重大功能"Redis 6.0.0 GA is out!" 当然，Redis7.0后版本更加厉害 为什么（why） 厘清⼀个事实我们通常说，Redis是单线程究竟何意？
Redis是单线程
主要是指Redis的网络IO和键值对读写是由一个线程来完成的，Redis在处理客户端的请求时包括获取 (socket 读)、解析、执行、内容返回 (socket 写) 等都由一个顺序串行的主线程处理，这就是所谓的“单线程”。这也是Redis对外提供键值存储服务的主要流程。
但Redis的其他功能，比如持久化RDB、AOF、异步删除、集群数据同步等等，其实是由额外的线程执行的。
Redis命令工作线程是单线程的，但是，整个Redis来说，是多线程的；
说说演进变化情况？
Redis3.x单线程时代但性能依旧很快的主要原因
基于内存操作：Redis 的所有数据都存在内存中，因此所有的运算都是内存级别的，所以他的性能比较高；数据结构简单：Redis 的数据结构是专门设计的，而这些简单的数据结构的查找和操作的时间大部分复杂度都是 O(1)，因此性能比较高；多路复用和非阻塞 I/O：Redis使用 I/O多路复用功能来监听多个 socket连接客户端，这样就可以使用一个线程连接来处理多个请求，减少线程切换带来的开销，同时也避免了 I/O 阻塞操作避免上下文切换：因为是单线程模型，因此就避免了不必要的上下文切换和多线程竞争，这就省去了多线程切换带来的时间和性能上的消耗，而且单线程不会导致死锁问题的发生 作者原话，官网证据
官网原话
他的大体意思是说 Redis 是基于内存操作的，因此他的瓶颈可能是机器的内存或者网络带宽而并非 CPU，既然 CPU 不是瓶颈，那么自然就采用单线程的解决方案了，况且使用多线程比较麻烦。但是在 Redis 4.0 中开始支持多线程了，例如后台删除、备份等功能。
Redis 4.0之前一直采用单线程的主要原因有以下三个
简单来说，Redis4.0之前一直采用单线程的主要原因有以下三个：
1 使用单线程模型是 Redis 的开发和维护更简单，因为单线程模型方便开发和调试；
2 即使使用单线程模型也并发的处理多客户端的请求，主要使用的是IO多路复用和非阻塞IO；
3 对于Redis系统来说，主要的性能瓶颈是内存或者网络带宽而并非 CPU。
既然单线程这么好，为什么逐渐又加入了多线程特性？
单线程也有单线程的苦恼
举个例子
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/548e7689fe3c132e0b19fbb8ebb653cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a1faf5518d73e985b43c84120c583b3/" rel="bookmark">
			ChatGPT&amp;AI画图-微信小程序 Robot Buddy
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		同时拥有ChatGPT的聊天功能和AI画图功能的微信小程序，欢迎大家体验：
微信搜索小程序“Robot Buddy”或者扫描下方二维码即可使用：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ec176fbe98af5a5d9b68158fee1f4a4/" rel="bookmark">
			Redis修炼 （6.redis代替session实现短信登录和校验）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		理解http session 其实曾经在很长的一段时间里面，在前后端的交互中， 我一直很晕 这个 http session 到底是个是个啥. 为什么每次 controller 方法的入参 里面都有request来取前端传过来的参数，这个好理解 但是为什么还会有个httpsession 它里面的数据时哪里来的， 往他里面set数据又是为什么？
情景一
为了方便理解这个 我们来一个最基本的短信登录场景。
假设有个app， 有个用户要登陆它：
登录，然后看一下自己的个人页面 就2步。
你登录的时候 前端发一个请求给后端 带上你的用户名aaa密码123 然后登录成功了
这时候你要点个人页面了，，，，，
停！ 这里问题来了 Http协议是没有记忆的 无状态的。这个请求和上一个请求之间什么关系都没有 上一个请求的过程它不会做保存，请求完它就把上一个请求忘记了，就像你谈一个妹子的时候 就忘记了上一个妹子。 既然它忘记了 那对不起 你现在要点击个人页面 我怎么知道 你是刚才的aaa？
没办法 这时候前端 又得传用户名aaa和密码123 告诉后端我是aaa 后端检查过之后，让你访问aaa的个人页面，
ok你看完个人页面了 你又想看看个人钱包， 这时候对不起 因为是http协议 上一个请求老子早就忘了 你现在要看aaa的个人钱包 那你又得传一遍用户名和密码 不然我怎么知道 你是aaa？
很sb对吧？ 这就是前后端交互的程序刚兴起的时候遇到的灾难。
情景再现
这时候。。。 cookie和session出现了。 他俩前者属于客户端 比如浏览器 你的手机app。 后者属于服务器。
这俩是怎么解决上面哪个情景的问题的呢：
假设有个app， 有个用户要登陆它：
登录，然后看一下自己的个人页面 就2步。
你登录的时候 前端发一个请求给后端 带上你的用户名aaa密码123 然后登录成功了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ec176fbe98af5a5d9b68158fee1f4a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f41b07b791182c43fead6d1746c1f3a7/" rel="bookmark">
			springboot全局异常
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.自定义业务异常 @Data @NoArgsConstructor @AllArgsConstructor public class CustomException extends RuntimeException{ private Integer status; private String message; } 2.异常拦截 @RestControllerAdvice public class GlobalExceptionAdvice { //空指针异常 @ExceptionHandler(NullPointerException.class) public ResultVo nullPointerHanaler(NullPointerException e){ e.printStackTrace(); return ResultVo.fail().message(e.getMessage()); } //自定义异常 @ExceptionHandler(CustomException.class) public ResultVo customHandler(CustomException e){ e.printStackTrace(); return ResultVo.fail().message(e.getMessage()); } } 3.测试抛出异常 @RestController public class ExceptionTest { @GetMapping("/test") public ResultVo testException(){ try { int a=1/0; }catch (Exception e){ throw new CustomException(ResultEnum.ERROR.getStatus(),e.getMessage()); } return ResultVo.ok(); } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f0e3c82bfc8882d347f3c7a1d6cec13/" rel="bookmark">
			jvm-狂神课程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、JVM JVM就是Java虚拟机，Java虚拟机就是JVM
1. JVM位置 1、Java程序（跑的环境是在jvm（虚拟机）跑的，也可以说是在jre上跑的）java运行是需要在特定的环境的也就是这个jre这种。
2、jvm（也就是jre，jre包括了jvm）：jvm是用c写的
3、操作系统（也是个软件
4、硬件体系（Intel，sapc）
2. JVM体系结构 2.1. jvm结构图 1、java编译 - 命令javac
2、编译生成Class File
3、类装载器（类加载器Class Loader）
4、运行时数据区：（类加载完成后进入这个运行时数据区：Runtime Data Are）运行时异常是不可捕获的。这是在类加载器后的产物！运行时数据区里面就有（方法区（Method Area），java栈（stack），本地方法栈（Native Method Stack），堆（heap） ，程序计数器（pc寄存器））
本地方法栈: 本地方法栈也是线程私有的数据区，本地方法栈存储的区域主要是 Java 中使用 native 关键字修饰的方法所存储的区域。程序计数器：程序计数器也是线程私有的数据区，这部分区域用于存储线程的指令地址，用于判断线程的分支、循环、跳转、异常、线程切换和恢复等功能，这些都通过程序计数器来完成。方法区：方法区是各个线程共享的内存区域，它用于存储虚拟机加载的 类信息、常量、静态变量、即时编译器编译后的代码等数据。堆：堆是线程共享的数据区，堆是 JVM 中最大的一块存储区域，所有的对象实例都会分配在堆上。JDK 1.7后，字符串常量池从永久代中剥离出来，存放在堆中。运行时常量池：运行时常量池又被称为 Runtime Constant Pool，这块区域是方法区的一部分，它的名字非常有意思，通常被称为 非堆。它并不要求常量一定只有在编译期才能产生，也就是并非编译期间将常量放在常量池中，运行期间也可以将新的常量放入常量池中，String 的 intern 方法就是一个典型的例子。 5、本地方法接口（native）（和本地方法库相连），同时这一层还有执行引擎。
2.2. jvm垃圾回收 垃圾回收，指的的堆内存的垃圾回收，垃圾回收机制简称GC
程序在运行过程中，会产生大量的内存垃圾（一些没有引用指向的内存对象都属于内存垃圾，因为这些对象已经无法访问，程序用不了它们了，对程序而言它们已经死亡），为了确保程序运行时的性能，java虚拟机在程序运行的过程中不断地进行自动的垃圾回收（GC）。
垃圾收集系统是Java的核心，也是不可少的，Java有一套自己进行垃圾清理的机制，开发人员无需手工清理
为什么java栈，本地方法栈，程序计数器是不会有垃圾回收的？
因为他们是栈，最终是要出栈的，若是上面的是一个垃圾阻塞了，那他就无法出栈了，Jvm调优也就是垃圾回收，调的就是方法区和堆，99%是调堆。
手动执行GC
System.gc(); // 手动回收垃圾 finalize方法作用
1、finalize()方法是在每次执行GC操作之前时会调用的方法，可以用它做必要的清理工作。
2、它是在Object类中定义的，因此所有的类都继承了它。子类覆盖finalize()方法以整理系统资源或者执行其他清理工作。finalize()方法是在垃圾收集器删除对象之前对这个对象调用的。
public class Test { public static void main(String[] args) { Test test = new Test(); test = null; System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f0e3c82bfc8882d347f3c7a1d6cec13/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f634c8762e18cce8df8735b33115f212/" rel="bookmark">
			lombok常用注解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.@Getter/@Setter 自动生成getter/setter方法 2.@NoArgsConstructor/@AllArgsConstructor 自动生成无参/有参构造方法 3.@ToString 自动生成toString方法 4.@EqualsAndHashCode 自动生成equals和hashCode方法 5.@Data 自动生成所有基本方法，包括getter/setter、equals、hashCode、toString等 6.@Builder 使用Builder模式创建对象 @Data @Builder public class User { private Long id; private String username; private String password; } //类名.builder().属性赋值.build()返回对象 User user = User.builder() .id(1L) .username("张三") .password("123456").build(); 7.@Slf4j 自动生成日志对象 8.@Accessors 用于配置生成的 getter 和 setter 方法的形式 主要有以下三个参数：
chain：配置生成的 setter 方法返回当前对象还是 void，默认为 false。fluent：配置生成的 getter 和 setter 方法是否使用 fluent API 形式，默认为 false。prefix：配置生成的 getter 和 setter 方法的前缀，默认为空字符串。 1.chain 当 chain 参数为 true 时，生成的 setter 方法会返回当前对象，以实现链式调用的效果。例如：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f634c8762e18cce8df8735b33115f212/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/113a4632104091f994f2f21b9e35cabf/" rel="bookmark">
			创建springboot项目步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、通过Spring Initializr创建
新建项目项目设置
3. 选择依赖，后续也可以在pom中添加其他依赖
选择项目存储位置
项目创建完成
完整的pom.xml文件： &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.7.8&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;demo&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-j&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/113a4632104091f994f2f21b9e35cabf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c699b9b85608275304b9764630e4448/" rel="bookmark">
			时间序列预测股票数据—以LSTM模型为例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、对时间序列的理解： 时间序列是按照一定时间间隔排列的数据，时间间隔可以是任意时间单位，通过对时间序列的分析，我们可以探寻到其中的现象以及变化规律，并将这些信息用于预测。这就需要一系列的模型，用于将原始时间序列数据放进模型中进行训练，并用训练好的时间序列模型来预测未知的时间序列。
提供的数据：
“中国平安”2016-2018年股票数据，背景为平安保险集团。数据预览如下：
通过预览数据，可知此次实验的数据属性为date(日期)、open(开盘价)、high(最高价)、low(最低价)、close(收盘价）以及volume(成交量)
其中，我们要实现股票预测，需要着重对close(收盘价)一列进行探索性分析。
二、使用LSTM进行时序预测 模型介绍：
包括遗忘门、输入门、输出门。LSTM将这些卡口作为去除或者增加细胞状态的工具。门是一种让信息选择式通过的方法，他们包含一个sigmoid神经网络层和一个按位的乘法操作。
其中，每一个sigmoid会输出0到1之间的数值，描述每个部分有多少量可以通过。0表示不允许任何量通过，1表示允许任意量通过。
LSTM通过三个门，保护和控制细胞状态。
建模思路（包括数据处理、模型分块、建模、模型优化、检验等）
（1）数据处理： 导入数据，提取数据集的date日期和close收盘价两列，作为建模预测的对象。
模型分块，设置测试集规模以及滑块大小，现将数据归一化处理，转化为tensor可以识别的数据，再将原数据设定为滑块为1，每调用1批次的数据，将其添加到列表，从而实现二维数据转三维数据，再切分训练集、测试集。
建模步骤（依据上述思路进行建模，详细描述过程）
定义网络层：LSTM层（神经元个数：16，激活函数：relu)
全连接层（神经元个数：1，激活函数：relu，正则化：l2范数）
模型实例化并装配网络（优化器：采用自适应梯度优化算法Adam，学习率设定为0.1，损失函数采用交叉熵函数，评价指标采用准确率）
训练模型，设定训练批次为50，每批次样本量为100.
#使用LSTM进行预测 import tensorflow as tf from tensorflow.keras import datasets, layers, optimizers, Sequential, metrics from tensorflow.keras.layers import Input,Dropout,Dense,LSTM from tensorflow.keras.models import Model from tensorflow.keras import regularizers import tensorflow.keras as keras np.random.seed(100) # 选取随机种子个数100个 # 设置神经网络参数 # 提取收盘价 y=stock['close'] print(y) # 数据预处理 test_ratio=0.4 windows=1 # 设置滑块大小 # 定义测试集规模 # # 通过比例切分 # 测试集大小 from sklearn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c699b9b85608275304b9764630e4448/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2214702acaab3b4f1742015917d9b1e/" rel="bookmark">
			瞎写的一个r=a*(1-sinθ)～
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 #include &lt;iostream&gt; #include &lt;cmath&gt; #include &lt;boost/geometry.hpp&gt; #include &lt;boost/geometry/geometries/polygon.hpp&gt; #include &lt;boost/geometry/geometries/adapted/boost_tuple.hpp&gt; BOOST_GEOMETRY_REGISTER_BOOST_TUPLE_CS(cs::cartesian) using namespace std; namespace bg=boost::geometry; typedef bg::model::d2::point_xy&lt;double&gt; point_t; typedef bg::model::segment&lt;point_t&gt; segment_t; typedef bg::model::linestring&lt;point_t&gt; line_t; typedef bg::model::polygon&lt;point_t&gt; polygon_t; typedef bg::model::multi_polygon&lt;polygon_t&gt; mpolygon_t; typedef bg::strategy::transform::rotate_transformer&lt;boost::geometry::radian, double, 2UL, 2UL&gt; rotate_t; int main() { polygon_t a; for(int i=0;i&lt;=360;i++) { double c; point_t b; c=(1-sin(M_PI*i/180))*cos(M_PI*i/180); b.set&lt;0&gt;(c); c=(1-sin(M_PI*i/180))*sin(M_PI*i/180); b.set&lt;1&gt;(c); a.outer().push_back(b); } // cout&lt;&lt;sin(M_PI*30/180)&lt;&lt;"\n"; return 0; } 运行结果是什么涅～ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0713a8a5d86a56f1836ecf18df61489/" rel="bookmark">
			2023华为OD机试真题-知识图谱新词挖掘(JAVA、Python、C&#43;&#43;)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述：
小华负责公司知识图谱产品，现在要通过新词挖掘完善知识图谱。
新词挖掘：给出一个待挖掘文本内容字符串Content和一个词的字符串word，找到content中所有word的新词。
新词：使用词word的字符排列形成的字符串。
请帮小华实现新词挖掘，返回发现的新词的数量。
输入描述：
第一行输入为待挖掘的文本内容content；
第二行输入为词word；
输出描述：
在content中找到的所有word的新词的数量。
补充说明：
0&lt;=content的长度&lt;=10000000；
1=&lt;word的长度&lt;=2000
收起
示例1
输入：
qweebaewqd
qwe
输出：
2
说明：
起始索引等于 0 的子串是 "qwe", 它是 word的新词。
起始索引等于 6 的子串是 "ewq", 它是 word 的新词。
示例2
输入：
abab
ab
输出：
3
说明：
起始索引等于 0 的子串是 "ab", 它是 word的新词。
起始索引等于 1 的子串是 "ba", 它是 word的新词。
起始索引等于 2 的子串是 "ab", 它是 word的新词。
import java.util.*; // 注意类名必须为 Main, 不要有任何 package xxx 信息 public class Main { public static void main(String[] args) { Scanner in = new Scanner(System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a0713a8a5d86a56f1836ecf18df61489/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/014a5ae183116ff8d1b087e308f4a0e7/" rel="bookmark">
			Java将OFD文件转PDF文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OFDRW 提供了将 OFD 文档导出为其他格式文档的能力，如导出为 PDF、图片、SVG、TXT、HTML 等。
OFDRW 转换模块在 2.0.0 之后抽象了多种文档导出接口，使用统一的 API 实现 OFD 文档导出功能。
如果你使用的是 2.0.0 以前版本，可参考 OFD 文件转换工具类（2.0.0版本之前）
注意： java &gt;= 1.8
一、导入 jar 依赖包 1.1 Maven 项目引入 jar 包 &lt;dependency&gt; &lt;groupId&gt;org.ofdrw&lt;/groupId&gt; &lt;artifactId&gt;ofdrw-converter&lt;/artifactId&gt; &lt;version&gt;2.0.2&lt;/version&gt; &lt;/dependency&gt; 1.2 非 Maven 项目直接下载导入 jar 包 点击下载：ofdrw-converter-2.0.2.jar
二、OFD 转 PDF OFD 文档导出为 PDF 文件，该导出根据实现所使用的库不一致具有两种导出实现。
注意事项：
导出无法保证文档效果一致性。 2.1基于 PDFBox 实现 实现类：org.ofdrw.converter.export.PDFExporterPDFBox
Path ofdPath = Paths.get("D:/ofd/daima.ofd"); Path pdfPath = Paths.get("D:/ofd/target/daima1.pdf"); try (OFDExporter exporter = new PDFExporterPDFBox(ofdPath, pdfPath)) { exporter.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/014a5ae183116ff8d1b087e308f4a0e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f9da453a5883abfc255742f445d7b5e/" rel="bookmark">
			如何系统性的学习FFmpeg6.0
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		主要包括四大部分：
第一部分音视频基础知识;
第二部分FFMPEG命令行；
第三部分FFMPEG进阶；
第四部分FFMPEG项目实战；
一、音视频基础 1.1音视频基础 01. 如何采集声音-模数转换原理
02. 为什么高品质音频采样率&gt;=44.1Khz
03. 什么是PCM
04. 一个采样点用多少位表示
05. 采样值用整数还是浮点数表示
06. 音量大小和采样值大关系
07. 多少个采样点作为一帧数据
08. 左右通道的采样数据如何排列
09. 什么是PCM（脉冲编码调制）
10. 音频编码原理
1.2 视频基础知识 01. RGB彩色原理
02. 为什么需要YUV格式
03. 什么是像素
04. 分辨率、帧率、码率
05. YUV数据存储格式区别
06. YUV内存对齐问题
07. 为什么画面显示绿屏
08. H264编码原理
09. H264 I P B帧的关系
1.3 解复用基础知识 01. 什么是解复用，比如MP4格式
02. 为什么需要不同的复用格式MP4/FLV/TS
03. 常见的复用格式MP4/FLV/TS
1.4 FFmpeg6.0开发环境搭建 01. Windows、Ubuntu、MAC三大平台
02. QT安装
03. FFmpeg命令行环境
04. FFmpeg API环境
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f9da453a5883abfc255742f445d7b5e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42fe8a3652d5bd8c8414d80caa9d9a6a/" rel="bookmark">
			java获取登陆用户ip方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天和大家分享一下获取登录用户 ip的方法，如果你想获取自己的登陆用户 ip，可以参考以下思路： 1.可以通过 Java动态链接库的方式获取到，方法很简单，就是把需要的 ip地址添加到动态链接库中，然后在需要用到时直接调用即可。 2.通过 javax. dll中的 api获取到，这种方法使用比较简单，只需要获取 ip地址即可。 3.通过 JDK中的 api获取，这种方法就需要 java环境支持动态库的 api （这个一般不用） 4.通过 java. io中的 api获取，这种方法会相对复杂一些，需要先安装 javaio库。
一、通过 Java动态链接库的方式获取
1、首先我们需要创建一个 java对象，这里我们可以使用 JVM中的jdk8。然后我们就需要把需要的 ip地址添加到这个 java对象中。 2、在 windows系统中，打开一个已经安装了java.lang.co unt. DynamicActiveRegistry的环境，然后在 debug模式下，找到 Java程序的模块所在的路径，把 java. lang. DynamicActiveRegistry这个文件夹添加进去即可。 3、在 javac. application. configurationIdentifier. applicationExtensions属性中添加 DynamicActiveRegistry。
二、 javax. dll中的 api获取
javax. dll是 java解释器构建在。 dll文件上的，它包含了大部分 java的基础类库，如java.li ne （）、java.la ng. Dirty （）等，可以说是一个小型的 Java运行环境。而 dll中包含的大部分 api都是与数据库连接有关的。在 Java程序中，通常会通过获取数据库连接池的方式来获得一个连接池，这个连接池会存储一些连接信息，一般有用户名和密码。那么在 javax. dll中获取这些信息就是我们接下来要说的内容。 下面就以 javax. dll为例进行说明： 在 class文件中添加如下代码： 注意：在第一个函数中，我们需要传入一个用户名和密码，因为只有这个用户名和密码才能让数据库连接池获取到数据库连接池中的信息。所以这里我们可以把这个用户名和密码放到动态库的 api中，也就是文件。 dll中，然后使用 Java编写一个控制台类。在控制台类中返回数据库连接池的信息。 在控制台类中，我们调用app.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/42fe8a3652d5bd8c8414d80caa9d9a6a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f630dde4e9b786a61ee2b936e282703/" rel="bookmark">
			Unity物理系统脚本编程（上）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、获取刚体组件Rigidbody 当一个物体挂载了刚体时，即可在脚本中获取该物体的刚体组件，代码如下
Rigidbody rigid;
void Start()
{
rigid=GetComponent&lt;Rigidbody&gt;();
}
一般将刚体变量命名为rigid并定义为一个字段，方便复用.
二、施加作用力AddForce 最常用的施加作用力的方法是AddForce（），参数为Vector3类型。代码如下
rigid.AddForce(new Vector3(0,100,0));
上述代码表示对刚体施加一个向上的100N的力。持续时间看具体情况。
三、修改速度velocity 对于物理系统中的刚体来说，速度非常重要。影响着动量、动能，决定着碰撞的结果。
在Unity中获取、修改刚体速度的代码如下
Vector3 vel=rigid.velocity;
rigid.velocity=vel+new Vector3(0,0,1);
下面举一个多段跳跃的例子
usingUnityEngine;
public class SimpleJump:MonoBehaviour
{
Rigidbody rigid;
void Start()
{
rigid=GetComponent&lt;Rigidbody&gt;();
}
private void Update()
{
if(Input.GetButtonDown("Jump"))
{
rigid.AddForce(new Vector3(0,100,0));
}
}
}
但实际测试发现，如果角色处于上升阶段时再次跳跃，最大高度就会大于单次跳跃的2倍。如果处于下降阶段，就很难在空中跳起来，可能只会停顿一下，延缓下落时间。完全符合物理规律。
若要实现二段跳，则只需要令其在跳跃时y轴速度为0即可，加上如下代码
rigid.velocity=newVector(rigid.velocity.x,0,rigid.velocity.z);
四、射线的使用方法 射线在游戏中应用非常广泛，举几个例子 游戏中有单击地面的操作，因此要发射射线以确定是否点中了可单🐔区域和单🐓位置的坐标。在判定子弹或技能是否击中目标时，如果采用碰撞体，需要考虑子弹速度，且存在穿透问题，而射线是没有速度的（瞬时发生），不仅易于使用，且综合效率更高。在3D或2D游戏中，判断玩家是否落地，可以向玩家脚下发射射线；判断是否接触墙壁，可以往左右两侧发射射线；判断玩家是否低头，可以往头顶发射射线；判断玩家是否需要攀爬，也可以采用射线检测因为射线与视线一样，会被障碍物阻挡，因此在游戏AI设计中，可以用射线模拟AI角色的视线。 ⚠️：上述的各种射线检测都是以物理系统为基础的。射线需要雨碰撞体和触发器配合才能发挥作用。
下面来介绍一下射线编程方法。 常用的直线型射线用类型Ray表示。Ray包含了origin（起点）和direction（方向）的定义，起点和方向都用Vector3表示。
有很多方法可以在游戏事件中发射一条射线，最常用的方法是Physics.Raycast()和Physics.RaycastAll()。
Physics.Raycast()有十种以上重载方式，列出以下三种重载形式： bool Raycast(Vector3 origin,Vector3 direction);
bool Raycast(Vector3 origin,Vector3 direction,float maxDistance);
bool Raycast(Vector3 origin,Vector3 direction,float maxDistance,int layMask);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f630dde4e9b786a61ee2b936e282703/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/142/">«</a>
	<span class="pagination__item pagination__item--current">143/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/144/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>