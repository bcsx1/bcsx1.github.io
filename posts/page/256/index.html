<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca9a8f34f7cb4c58b7385c33b9a505e2/" rel="bookmark">
			记SpringBoot的一个请求参数合并的小坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一个form-data格式的post接口，用户反馈api调用不成功，查询日志发现一个参数名传成了xxx,xxx的格式，本来应该是xxx。最后发现他在query参数和body参数中同时传了这个参数。
测试发现Springboot中，如果body和query参数中都传了同名字符串类型参数，会把它们合并，用英文逗号连接。而int、long类型则不会合并。
springboot代码如下
@RestController @RequestMapping("/api/monitor") public class MonitorController { @PostMapping("/ok") @ResponseBody public String ok(@RequestParam String a, @RequestParam Long b) { System.out.println(a); System.out.println(b); return "ok"; } } 请求如下
curl --location --request POST 'http://127.0.0.1:8080/api/monitor/ok?a=xxx&amp;b=1234' \ --form 'a="xxx"' \ --form 'b="1234"' 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e8d9086708f92e3e63b1b8bc5528e8f/" rel="bookmark">
			Openlayer以图片填充面，pattern填充
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pattern填充无效：需要将方法写在img.onload事件中
var color = "rgba(255,0,0,1)";
var stroke = new ol.style.Stroke({
color: color,
width: 3
//lineDash: [10, 10]
});
var cnv = document.createElement('canvas');
var ctx = cnv.getContext('2d');
var img = new Image();
img.src = '../../../static/images/tb.png';
img.onload = function () {
var pattern = ctx.createPattern(img, 'repeat');
var fill = new ol.style.Fill({
color: pattern //'rgba(0,0,0,0.2)'
});
var drawStyle = new ol.style.Style({
fill: fill,
stroke: stroke
});
//polygons为arcgis的features数组。
for(var i=0;i&lt;polygons.length;i++){
var polygon=polygons[i];
//添加新要素feature
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e8d9086708f92e3e63b1b8bc5528e8f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/979f5201669c6e2f006f564eb447f91c/" rel="bookmark">
			《Deep Convolutional Inverse Graphics Network》(DCIGN) 翻译
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文对《Deep Convolutional Inverse Graphics Network》的主要内容进行翻译和记录。
1 引言 深度学习在从图像中自动学习层次化表征任务上取得了显著成效。但如何产生数据的最优表征方面的工作相对较少。
许多不同的关于表征学习的理论和应用研究中，均体现出对表征相同的要求：不变性(invariance)、有意义性(meaningfulness)、抽象性(abstraction)和解耦性(disentanglement)。Bengio指出解耦表征(disentangled representation)具有编码变化对真实世界中的变化是稀疏的特点，即数据的不同解释性分布往往相互独立地变化，连续的真实世界序列的变化往往一次只对应少量隐藏特征的变化。
逆图形视觉(“vision as inverse graphics”)模型对提供这些特征的图像进行表征。计算机图形学(computer graphics)包含从场景的紧凑描述(图形编码, graphics code)映射到图像的函数。该类图形编码通常是解耦的，从而可以通过对变换(如对象位置、姿势、照明、纹理和形状等)的细粒度控制来渲染场景。这些编码被设计为容易且可解释地表征真实数据序列，以便在软件中紧凑地表征常见变换。这一标准与Bengio的类似。图形编码可以方便地与理想表征的属性对齐。
最近的逆图形研究遵循了一个通用策略：定义具有隐藏参数的概率或确定性模型，通过推理或优化算法找到给定观测下最合适的潜在参数集。但这些方法无法自动生成可解释的图形编码，也难以再现三维图像。
本文提供了一种学习复杂变换(如平面外旋转、光照变化等)的可解释图形编码的方法。给定一组图像，本文使用一个混合编码器-解码器模型学习解耦不同变换的表征。为了实现这一点，本文采用一个具有多层卷积核反卷积操作的深度有向图模型，并基于随机梯度变分贝叶斯算法(Stochastic Gradient Variational Bayes, SGVB)进行训练。
本文提供一种训练策略以鼓励图形编码层的每组神经元表征特定的变换。为了学习解耦表征，我们将数据划分成包含激活变换和未激活变换的小批次进行训练，而非想监督学习一样提供目标值。目标函数确保图像重构质量。比如，点头的面部图像具有仰角激活，但其形状、纹理及其他仿射变换未激活。通过这样的数据训练迫使图形编码层中选定的神经元表征特定的激活变换。给定一张人脸图像，本文模型可以重新生成与输入不停姿势和光照的图像。
2 相关工作 具体参考文献这里不做赘述，请参考原文。
3 模型 如图1，深度卷积逆图像网络的基本架构包含两部分：一个捕捉给定数据x的图形编码Z的分布的编码器和一个学习给定Z产生近似的条件分布的解码器。Z是包含分解的隐藏变量(如姿势、光照、形状等)的解耦表征。
图1 模型结构。模型遵循变分自编码器的架构。编码器有若干层卷积和最大池化层组成，解码器有若干层上采样和卷积层组成。(a) 训练期间使用目标函数-log(P(x|zi))+KL(Q(zi|x)||P(zi)计算并反向传播梯度. (b) 测试期间，通过调整编码器获得的编码以渲染成新的图像，类似与操作现成的3D渲染引擎。 记编码器输出为，用于参数化变分近似分布，Q是多变量正态分布。这样做 有两个好处：(1)样本相对Q的参数的梯度可以通过重参数技巧容易地获得；(2)三维扫描仪数据上训练的不同金泰新装模型具有相同的多变量正态隐藏分布。给定连接和的参数，分布参数和隐藏编码Z可以表示为
3.1 针对特定变换的训练
本工作的主要目标是学习数据的具有解耦和具有语义解释性的隐藏变量的表征。
一个对于场景信息的表征的自然选择是图像引擎中已经使用的表征设计。如果说人脸图像能拆分成姿势、光照、形状等变量来解构，那么自然可以选择这些变换来构造表征。图2给出了尝试学习的表征。
图2 表征向量结构。前三维特征分对应人脸图像的方向角、仰角和光照角度。 为实现这一目标，设计训练流程如下：将数据组织成只对应单个场景变量变化(方位角、仰角、光源方位)的小批量数据(mini-batch)。这些场景变化是现实世界中存在的，我们称其为外部变量(extrinsic variables), 分别由编码中的表征。
此外还生成外部变量固定，其他面部属性变化的小批量数据。这些批次数据包含相同观察条件和姿势下的不同人脸图像。这些内在属性，如身份、形状、表情等，用剩余的隐藏变量表征。
本方法基于SGVB训练，但对编码器输出及梯度训练进行了一些关键的调整，具体训练流程如下： 1. 从期望变化集合{方位角、仰角、光源方位、内在属性}中随机选择一个潜在变量记为
2. 随机选择一个对应变量变化的小批次数据；
3.将小批次中的每个样例输入网络并学习其隐藏表征；
4.计算本批次中所有表征向量的均值；
5.在将编码器输出输入解码器前，将编码向量中所有非选定变化的值()用所有向量的均值替代，即这些输出被钳制(clamped)；
6.根据SGVB计算重构误差并在解码器中反向传播；
7.关于的梯度替换为其与平均值的差值(解释详见3.2)，关于的梯度不变；
8.用修正过的梯度在编码器中反向传播
由于内在属性的表征远高于外在表征，因此需要更多的训练。因此在选择批次时变化时，方位角：仰角：光照角度：内在属性=1:1:1:10。该比例是广泛测试后得出的在本文两个数据集上均有效的比例。
该训练方式通过钳制一个神经元外的所有神经元的输出，迫使解码器仅使用该神经元的值的改变来重构该批次的变化。
该训练方式使得网络的隐藏变量与对应生成参数具有很强的等变性(equivariance)，如图6。从而编码器能够轻松获取真实生成参数。
3.2 不变性目标(Invariance Targeting)
通过一次只包含一种变换的数据进行训练，以鼓励特定的神经元包含特定的信息，这是等变形。同时我们希望明确阻止这些神经元对其他信息的学习，希望其对其他变换具有不变性(invariance)。由于每批小批量训练数据中只包含一种变化，因此不变性目标可以看做编码器的除指定神经元外的神经元(及对应其他变换的神经元)应当给出相同输出。
为了使DC-IGN实现上述特性，对于所有对应非激活变换的神经元，用其与均值的差值的"误差梯度"来训练。 可以简单地将次梯度视为
4 实验 本文基于Paysan等人获取的12000各批次的三维人脸数据训练，每个批次包含20张人脸，身份、姿势和照明存在随机变化。训练时使用rmsprop学习算法，元学习率为0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/979f5201669c6e2f006f564eb447f91c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fee4abe5650bd033572f9af18ad13382/" rel="bookmark">
			ijkplayer音频播放分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		接着上一篇文章 Ijkplayer 初始化和prepare源码分析 我们知道ijkplayer在初始化和准备过程中做了那些事，这篇文章分析一下ijkplayer是如何播放音频的。
回顾一下prepare的流程：
Java层：	prepareAsync()-&gt; JNI层：	[ijkplayer_jni.c]	IjkMediaPlayer_prepareAsync()-&gt; C源码：	[ijkplayer.c] ijkmp_prepare_async()-&gt; [ff_ffplay.c]	stream_open()-&gt; read_thread() 下面我们从read_thread开始阅读。
一、read_thread 从方法名和方法注释我们可以知道read_thread主要作用就是从文件或者网络中读取音视频流
/* this thread gets the stream from the disk or the network */ static int read_thread(void *arg) { //真正的播放器 FFPlayer *ffp = arg; //封装播放过程中所有状态 VideoState *is = ffp-&gt;is; //封装了文件格式相关信息的结构体 , 如视频宽高 , 音频采样率等信息 AVFormatContext *ic = NULL; AVPacket pkt1, *pkt = &amp;pkt1; ... //1、初始化AVFormatContext ic = avformat_alloc_context(); //设置中断函数，如果出错或者退出，就可以立刻退出 ic-&gt;interrupt_callback.callback = decode_interrupt_cb; ic-&gt;interrupt_callback.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fee4abe5650bd033572f9af18ad13382/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c378cafcdb975016ce54aab8b424819e/" rel="bookmark">
			Python列表奇偶拆分
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【问题描述】
输入一个列表，包含若干个整数（允许为空），然后将其中的奇数和偶数单独放置在一个列表中，保持原有顺序
【输出形式】
分两行输出，第一行输出偶数序列，第二行输出奇数序列
【样例输入1】
[48,82,47,54,55,57,27,73,86,14]
【样例输出1】
48, 82, 54, 86, 14
47, 55, 57, 27, 73
【样例输入2】
[10, 22, 40]
【样例输出2】
10, 22, 40
NONE
【样例说明】
如果奇偶拆分后，奇数列表，或者偶数列表为空，请直接输出NONE表示
【参考代码】
x = input() x1 = x.strip('[]') # 去除输入列表字符串的[] x2 = x1.split(",") # 将字符串变为列表 a = [] b = [] for i in x2: if int(i) % 2 == 0: a.append(i) else: b.append(i) if not a: print("NONE") else: a = ', '.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c378cafcdb975016ce54aab8b424819e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c599fa82f42ca8e69de0503a7019ef28/" rel="bookmark">
			【容器底层技术】 namespaces详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【容器底层技术】 namespaces详解 1.简介 namespaces是 Linux 内核的一项功能，它对内核资源进行隔离，让一组进程只能看到与自己相关的一部分资源，而另一组进程看到另一组资源， 使得处于不同 namespaces 的进程拥有独立的全局系统资源，改变一个 namespaces 中的系统资源只会影响当前 namespaces 里的进程，对其他 namespaces 中的进程没有影响。
该功能通过为一组资源和进程使用相同的namespace来工作，不同的namespace会引用不同的资源， 有些资源可能存在于多个空间中，比如进程 ID、主机名、用户 ID、文件名以及与网络访问和进程间通信相关的一些名称。
namespaces是 Linux 上容器的一个基本功能。Linux 系统以每种类型的单个namespace开始，供所有进程使用，进程可以创建额外的namespaces并加入不同的namespaces。
2.种类 截至至内核5.6，namespaces一共有8种。各个类型的namespace作用方式都是一样的：每个进程都和一个namespace相关联，而且只能看到或使用由这个namespace和它可用的子代namespaces所关联的资源，通过这种方法，每个进程对系统资源都有一个不同的视角。哪种资源被隔离取决于为给定进程组创建的namespace类型。
overview typeflagfunctionmntCLONE_NEWNS控制挂载点pidCLONE_NEWPID为进程提供了一组独立于其他namespaces的进程 IDs (PIDs)netCLONE_NEWNET用来隔离网络设备、IP地址端口等网络栈的namespaceutsCLONE_NEWUTS允许单个系统对不同的进程具有不同的主机名和域名userCLONE_NEWUSER跨多组进程提供权限隔离和用户身份隔离ipcCLONE_NEWIPC将进程与 SysV 风格的进程间通信隔离开来cgroupCLONE_NEWCGROUP隐藏了进程所属的控制组的身份timeCLONE_NEWTIME允许不同进程看到不同的系统时间 Mount(mnt) namespace Mount namespace用来控制挂载点。不同namespace中的进程看到的文件系统层次也是不一样的。在mount namespace中调用mount(), unmount()只会影响当前namespace内的文件系统。在创建时，当前mount namespace中的挂载点被复制到新命名空间，但之后创建的挂载点不会在namespaces之间传播（如果使用共享子树，可以在命名空间之间传播挂载点 ）。
用于创建这种类型的新命名空间的clone flag是 CLONE_NEWNS - “NEW NameSpace”的缩写。 这个术语不是描述性的（无法从名字看出要创建哪种命名空间），因为挂载命名空间是第一种命名空间，设计人员没有预料到还有其他命名空间。
Process ID(pid) namespace PID namespace为进程提供了一组独立于其他namespaces的进程 IDs (PIDs)。 PID namespace是嵌套的，这意味着当创建一个新进程时，它将拥有从当前namespace到初始 PID namespace所对应的每一个 PID。 因此初始 PID namespace能够看到所有进程，尽管看到的进程PID与其他namespace看到的不同。
在 PID namespace中创建的第一个进程被分配了 1 号进程 ID，并接受与普通 init 进程基本相同的特殊处理，其中最值得注意的是此namespace内的所有孤儿进程都会附加给它（孤儿进程，Orphan Process，指的是在其父进程执行完成或被终止后仍继续运行的一类进程）这一过程被称为“收养”。这也意味着 PID 1 进程的终止也将立即终止其 PID 命名空间中的所有进程和任何后代。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c599fa82f42ca8e69de0503a7019ef28/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7880c5eb7c137a45ee16a4e4e1530f9/" rel="bookmark">
			子网掩码的划分
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		子网掩码的划分
VLSM --可变长子网掩码---子网划分
192.168.1.0/24 借一位 192.168.1.0/25 128
192.168.1.128/25
192.168.1.0/24 借两位
192.168.1.0/26 64
192.168.1.64/26
192.168.1.128/26
192.168.1.192/26
192.168.1.0/24 借三位
192.168.1.11100000/24+3
192.168.1.0/27 32
192.168.1.32/27
192.168.1.64/27
192.168.1.96/27
192.168.1.128/27
192.168.1.160/27
192.168.1.192/27
192.168.1.224/27
192.168.1.0/24 借4位
192.168.1.0000 0000/24+4
192.168.1.0/28 16
192.168.1.16/28
192.168.1.32/28
192.168.1.48/28
。。。。。
192.168.1.240/28
总结规律：
借一位 划分两个网段
借两位 划分四个网段
借三位 划分八个网段
借思位 划分16个网段
划分的网段数量=2^借位
例题：172.16.1.0/22 借三位的情况
写出各网段的网络地址
172.16.00000011.00000000/22+3=25
差值：128
172.16.0.0/25
网络地址 172.16.0.0/25
广播地址 172.16.0.127/25
可用地址范围：172.16.0.1/25-172.16.0.126/25
172.16.0.128/25
172.16.1.0/25
172.16.1.128/25
172.16.2.0/25
172.16.2.128/25
172.16.3.0/25
172.16.3.128/25
看的是借位的最右边一位的代表数字（/25 --第25位）
某公司有N个部门，每个部门最多不超过5个人，现有网段192.168.1.0/24,请问，该公司最多有多少个部门
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7880c5eb7c137a45ee16a4e4e1530f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b2f818423dc3daca938ebce4153cc6b/" rel="bookmark">
			sublime设置显示左边侧边栏导航目录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 一、打开sublme编辑器（左侧侧边栏导航目录并没有显示出来）二、选择View——Side Bar——Show Open Files三、选择View——Side Bar——Show Side Bar三、菜单侧边栏导航目录显示成功 一、打开sublme编辑器（左侧侧边栏导航目录并没有显示出来） 二、选择View——Side Bar——Show Open Files 三、选择View——Side Bar——Show Side Bar 三、菜单侧边栏导航目录显示成功 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b127e1f403aef43abd8d68421121a5f4/" rel="bookmark">
			setTimeout() 与 setInterval() 的区别及使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 区别1.同代码对比2.setTimeout() 模拟 setInterval() 【缺陷】（已修复：2020/09/07，知识点：防抖）注意：反复点击按钮，计时器会被叠加执行，使得数值抽搐跳动（下面有介绍如何解决） 3.setTimeout() + for 解决与演示setInterval() 写法setTimeout() 写法（更简单）setTimeout() + for 区别 1.同代码对比 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;title&gt;&lt;/title&gt; &lt;script type="text/javascript"&gt; //变量初始化 var num1 = 0; var num2 = 0; var clock1; var clock2; //定义启动器 function work(ele) { if (ele.id === 'box1') { ele.style.width = num1 + 'px'; if (ele.getAttribute('data-toggle') === 'off') {	//相等判断则为真，严格相等则为假，除非加双引号 num1 += 1; if (num1 === 200) { ele.setAttribute('data-toggle', 'on'); } } else if (ele.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b127e1f403aef43abd8d68421121a5f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/555f0a1ebf79bb4006cc2181a939d683/" rel="bookmark">
			最长回文子串（动态规划），像讲故事一样进行求解，基于python实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		希望能把算法像故事一样讲出来~
希望大佬们赏个赞，谢谢~
题目：给你一个字符串 s，找到 s 中最长的回文子串。
思路来自leetcode官方：
对于一个子串而言，如果它是回文串，并且长度大于 22，那么将它首尾的两个字母去除之后，它仍然是个回文串。例如对于字符串“ababa”，如果我们已经知道“bab” 是回文串，那么 “ababa” 一定是回文串，这是因为它的首尾两个字母都是“a”。
根据这样的思路，我们就可以用动态规划的方法解决本题。我们用 P(i,j)表示字符串 s的第 i到 j个字母组成的串（下文表示成 s[i:j]）是否为回文串：
这里的「其它情况」包含两种可能性：
s[i,:j]本身不是一个回文串；
i &gt; j，此时 s[i:j] 本身不合法。
那么我们就可以写出动态规划的状态转移方程：
也就是说，只有 s[i+1:j-1]是回文串，并且 s 的第 i和 j个字母相同时，s[i:j]才会是回文串。
上文的所有讨论是建立在子串长度大于 2 的前提之上的，我们还需要考虑动态规划中的边界条件，即子串的长度为 1 或 2。对于长度为 1的子串，它显然是个回文串；对于长度为 2的子串，只要它的两个字母相同，它就是一个回文串。因此我们就可以写出动态规划的边界条件：
根据这个思路，我们就可以完成动态规划了，最终的答案即为所有 P(i,j)=true 中 j-i+1（即子串长度）的最大值。
以上是思路，转载于leetcode官方，下面我尽可能地将这段代码注释地足够细节，因为我也是小白，所以希望帮助其他小白进行理解，希望各位大佬批评指正。
class Solution: def longestPalindrome(self, s: str) -&gt; str: #首先获取字符串s的长度 n = len(s) #给最大回文子串的长度定义一个初始值1，想一想，如果没有更长的回文子串，那么最大回文子串就是单个字符（其也符合回文的要求） max_len = 1 #定义子串的左边界为begin，并赋予初值0 begin = 0 #判断字符串长度是否小于2，若小于2，那就是单个字符，其最大回文子串就是它自身，直接返回 if n &lt; 2: return s #定义一个n*n的二维数组dp，这是用来存储从i到j处的子串s[i:j]是否为回文子串的，显然有n*n个s[i:j]，dp中的值全是True和False，True代表s[i:j]回文，先将dp中所有元素初始化为False，后面按条件填充为True dp = [[False] * n for iter in range(n)] #容易知道，任意一个字符都可看做回文子串，这里s[i:i]代表的是所有的单个字符x，将其在dp中对应的位置置为True for i in range(n): dp[i][i] = True #遍历所有可能的子串长度，前面我们已经排除掉了长度为1的情况，这里就从2开始遍历到n即可 for L in range(2,n+1): #接着遍历左边界，左边界就让它从0开始遍历到n-1，从左到右的每个位置都可以作为左边界 for i in range(n): #那么这个右边界就可以直接由L=j-i+1推出来了 j = L + i - 1 #紧接着，判断j有没有大于等于n，试想若等于n，那索引就超出字符串的范围了，最右端索引才是n-1而已，说明右边界已经遍历到头了，这时候直接跳出内循环，换个子串长度继续循环 if j &gt;= n: break #那如果第i个字符和第j个字符不相等呢？首尾不同，那直接就可以判断i:j这个子串就不可能回文了，所以将dp[i][j]置为False if s[i] !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/555f0a1ebf79bb4006cc2181a939d683/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98f3e6e716a3a7ec5e8652b69a40761e/" rel="bookmark">
			二叉排序树与插入删除操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 二叉排序树；
二叉排序树的特点 1.如果它的左子树不空，则左子树上的所有节点的值均小于它的根节点的值；
2.如果它的右子树不空，则右子树上的所有节点的值均大于它的根节点的值；
3.它的左，右子树也分别为儿叉排序树
如何处理等号：可以右子树上的所有节点的值均大于或等于它的根节点的值
如果按中序遍历一棵儿叉排序树，则可得到一个按数值大小排序的递增序列。 插入 二叉排序树插入的过程基本是查找，因为是排序的树，所以可以进行快速的对比，最终将节点以叶子的形式增加到树中 删除(主要考虑的是如何在删除后仍然保持排序的状态) 删除的三种情况;
1.是叶子节点-------直接删除
2.有一个孩子-------让孩子直接“继承”双亲的位置
3.有两个孩子--------删除第三种情况的两种方法：
方法一：
这里有第二种常用的方法;
为了保持二叉排序树的结构(中序遍历后由小到大)，有两种思路，一种就是从要删除结点的左子树中选取最大的结点进行替代之，另一种就是从要删除的结点的右子树中选取最小的结点替代之。
二叉树的删除主要是当双亲节点在树中去除后，孩子节点的处理方式。
比如说在左子树上找中序最后一个节点填补 另一种方法比较不常用：
根据情况让左（或右）子树替代原来双亲的位置，让另一个子树每个元素重新插入。
【之前这个方法是错误的：根据情况让左（或右）子树替代原来双亲的位置，让另一个子树作为其"兄弟树"(应该是没有这个名词)的最值节点的右（或左）子树。之前没有仔细思考，这种方法会破坏二叉排序树的那种平衡的形状】
例子(数据结构，人民邮电出版社)：
当被删节点的左右子树都存在时 解决方法一： 用左子树中的最大的元素(或者右子树中的最小元素替换)
错误示例 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/872e2826898bbb5e0bed2df1eb1c5ced/" rel="bookmark">
			科来数据包生成器使用，广播域内进行arp欺骗
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1，科来数据包生成器要以管理员身份运行（重要！）
2，过滤arp数据包
3，进度条往右拖
4，
5，右键数据包，选择发送到数据包生成器
6，注意要修改的地方
7，选择对应的网卡
8，运行测试
——————————————————————————————————
有用请点个赞！！
谢谢~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2ac5b18ccd023b63930816070934b3b/" rel="bookmark">
			Typora 安装包2021年11月最后一次免费版本的安装包下载V13.6.1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 下载地址： 链接：https://pan.baidu.com/s/1GOw6o1rkqdNFEJFFy1BzFA
提取码：6666
版本号：13.6.1
事件： Typora开始收费了，15天试用，上限3台设备。碰巧我是这个月刚刚安装的Typora，刚好下载了Win的安装包。Linux版本和Mac版本没有。
更新：2022年7月7日
今天发现这玩意要求我们强制更新：
我去淘宝买了一个，居然是吾爱破解发布的1.1.5版本。
不过嘛看来一下，改改注册表就能接着用啦。
1.
regedit打开：计算机\HKEY_CURRENT_USER\SOFTWARE\Typora
2. 修改IDate
比如修改为2077，这样再打开Typora就能成功运行了。
这样还没完，因为Typora又会偷偷把这个值修改过来，好大的官位，把他他乌纱帽给爷卸了：右键Typora-&gt;权限
这样它就乖乖就范了。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5492bae9f3def209567343bf2f2330be/" rel="bookmark">
			Unity如何完全消除摩擦力
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Unity如何完全消除摩擦力 1.在物体的Rigidbody组件中设置空气阻力 ● Drag：空气阻力；
● Angular Drag：旋转空气阻力。
● 注意：若将上述两个属性设置为0，则仅仅影响该游戏对象《自身的移动和旋转》，与物体之间的摩擦力无关。
2.新建一个物理材质 ● 在Project视图中，右键=&gt;Create=&gt;Physic Material
设置动摩擦和静摩擦
○ 将Dynamic Friction和Static Friction都设置为0.Friction Combine
○ 该项参数，决定了摩擦力的计算方式；
○ 选择Minimum，摩擦力会选择接触面中摩擦力最小的值作为摩擦力，比如0和70，最终f = 0；
○ 选择Average，则会取平均值，其他选项同理。为什么要设置Friction Combine
○ 如果一堵墙，他的摩擦力参数是10，一个小方块的摩擦力参数是0，你希望小方块在墙上可以无摩擦，但不影响其他物体在墙面上的摩擦，那么你就不能动墙的摩擦力参数。
○ 此时，你只需要改小方块的物理材质即可，不会影响其他物体。 3.赋予对象物理材质 ● 将设置好的物理材质，拖到Box Collider的Material中，完成。 太狗了，看完收藏但不点赞，气死我了 2022.7.7回访：哈哈哈，上面是气话，别认真，认真你就输了。诶我以前这么暴躁的吗？[狗头]
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e02199cddc4938b94cff7ec7ab14e3cb/" rel="bookmark">
			纯 JS 实现灵活的前端主题切换功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、换肤 网站或者应用一键切换主题（简称：换肤）功能，对每个前端开发者来说已经非常常见了，通常是一深一浅，或自由组合衍生出众多主题，或任意主题，这时候，设计一个工程化主题切换功能，并梳理现代前端样式的解决方案显得尤为重要。
二、换肤调研 很久以前，通常的做法是每个颜色主题块编写样式表，切换的时候对应去切换。现代前端主题切换——目前主流的方案往往通过 CSS 变量（CSS 自定义属性）[1]来实现，将主题有关的颜色，通过业务和语义化的方式命名。接下来我们看看前端圈比较知名的UI他们是怎么做的：
（1）ElementUI[2]
我们可以看到 element-plus 官网，主题切换主题，是在html标签加里 class="dark" 涉及到主题的变量，基于html.dark,和：root配合改变。当然我们也可通过源码看到element-plus是用的是scss。
（2）ant.design[3]
我们可以看到 ant.design 官网，主题切换主题，是在html标签加里 color-scheme 和在body里添加自定义标签data-theme="dark",和：root配合改变。CSS 属性允许元素指示它可以轻松呈现的配色方案,操作系统配色方案的常见选择是“亮”和“暗”，或者是“白天模式”和“夜间模式”。当用户选择其中一种配色方案时，操作系统会对用户界面进行调整。这包括表单控件、滚动条和 CSS 系统颜色的使用值。通过源码，我们也可以看到ant用的是less。
三、换肤痛点和思考 (1) 正如上文ElementUI和ant，都分别借助不同的CSS预处理器（sass和less）来组织代码，再微前端盛行的时代，怎么设计一套通用的多团队可用，并且去css预处理的换肤CSS 自定义属性？
(2) 谁来维护不同主题色，研发和设计之间，如何保持不同主题色值的同步沟通？
(3) 如何最小化前端工程师的开发量，不需要做多份主题色？
(4) ...
基于以上考虑，举个例子，我们希望做到在开发时，编写：
.text { color: var(--c-color) } 复制代码 这样就可以一劳永逸——直接支持两套或者多套主题模式。
但是业务往往是千变万化的，正如我司：
（1）换肤的需求是，有一个色调（深浅），然后，根据深浅，衍生出很多 主题色，比如深蓝、深黄、深红、浅蓝、浅黄、浅红...
（2）对于深浅来说，有定于出一些基础色，对于组件颜色来说，通常用一组基础色即可满足，但是业务页面中可能涉及到千变万化的颜色...
四、换肤架构 image.png
正如上图，我们可以把换肤提升到一个平台或中台来：
（1）对于UED同学，他们可以自己去配置换肤相关的系统色系，衍生的主题色，系统色系色系基础色
（2）对于各个前端团队来说，可以通过主题色，色系基础色，任意自定义和配置 自己业务需要颜色的变量
五、换肤技术选型和实现 笔者这里是用基于css-vars-ponyfill[4]的换肤方案，至于它的优势正如它们官方所描述，在传统和现代浏览器为css自定义属性 提供客户端支持的 pnyfill。
【1】该方案的亮点和规则 （1）纯JS实现，对外暴露initThemes初始化方法，不依赖CSS预处理器（sass和less），兼容ie9
（2）抽离深浅色系基础色（统一治理输出），以及主题色，混合颜色（黑白色）都可以动态接口获得
（3）统一规范业务色常量命名，JS定义自定义函数方法 1、 Mix函数实现媲美sass的颜色混合机制，2、十六进制和RGB（rgba）互相转换函数
（4）技术路线不抖，直接用var()函数使用，后期封装成JS库 ，皮肤配置中台，可以提供给各个团队使用
（5）关于业务自定义变量，设计有两个治理方案：（1）全局变量， 全局单独维护（2）局部业务变量，局部单独维护
【2】核心原理 （1）在应用端触发换肤操作的时候，配合 JavaScript 状态管理，同步主题切换的信号，对应对应触发initThemes 方法
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e02199cddc4938b94cff7ec7ab14e3cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce05dbbf7cb0e529812525be9076ca23/" rel="bookmark">
			清览云题库--数据可视化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一章 Jupyter notebook不具备的功能是（D） A.Jupyter notebook可以直接生成一份交互式文档B.Jupyter notebook可以安装Python库C.Jupyter notebook可以导出HTML文件D.Jupyter notebook可以将文件分享给他人 在Jupyter notebook的命令模式下，要查看所有快捷键应该按下的快捷键是 （ C ） A.MB.ESCC.HD.A 简述数据分析与数据挖掘的区别与联系。 差异类型数据分析数据挖掘定义描述和探索性分析，评估现状和修正性不足技术性的“采矿”，过程，发现未知的模式和规律侧重点实际的业务知识涉及到 业务知识技能统计学，数据库，Excel，可视化等过硬的数学功底和编程技术结果需结合业务知识解读统计结果模型或规律 简述数据可视化分析的基本过程。 包括数据处理、视觉编码和可视化生成。数据处理聚焦于数据的采集、清理、预处理、分析和挖掘；视觉编码聚焦于解决对光学图像进行接收、提取信息、加工变换、模式识别及存储显示；可视化生成则聚焦于解决将数据转换成图形，并进行交互处理。数据可视化分析通过对数据不断地观察、分析从而发现有用的信息模式。 简述Jupyter Notebook的安装及第三方包的安装过程。 Python第三方包的安装方式较多，本书建议采用以下方式进行安装和管理。
（1）在CMD命令窗口中，使用conda命令进行自动下载安装，用法如下：
conda install &lt;包名称列表&gt; #安装包
conda remove &lt;包名称列表&gt; #卸载包
conda search&lt;搜索项&gt; #搜索包
conda list #查看所有包
conda update&lt;包名称&gt; #升级包
（2）在CMD命令窗口中使用pip命令，用法如下：
pip install &lt;包名&gt; #安装包
pip install–upgrade &lt;包名&gt; #更新包
pip uninstall &lt;包名&gt; #删除包
也可以在Jupyter notebook的cell中运行pip命令执行相应的命令，只需在命令前加“！”，如执行 ! pip install 包名 进行包的安装。 简述Jupyter Notebook中编辑模式与命令模式之间的切换方法。 按esc键切换为命令模式，按enter键进入编辑模式 在Jupyter notebook的cell中安装包语句正确的是（C ）。 A. pip install 包名B.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce05dbbf7cb0e529812525be9076ca23/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1fd103d49f7e2f3ed3d0268ddb959f9/" rel="bookmark">
			Python 中 logging 模块的基本用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 日志记录的重要性日志记录的流程框架为什么要使用日志日志记录的基本信息 日志等级日志字段信与格式 日志logging和print进行比较logging模块的使用方式 两种记录日志方式使用logging提供的模块级别函数详细说明使用logging日志系统的四大组件 日志器 - Logger处理器 - Handler过滤器 - filters格式化器 - Formatter组件之间的关系 代码的实现与具体应用 使用python代码实现日志配置使用配置文件和fileConfig()函数实现日志配置使用dict配置信息和dictConfig()函数实现日志配置 崔庆才相关教程 LevelHandlerFormatter捕获 Traceback配置共享文件配置日志记录使用常见误区 项目日志使用参考文献 日志记录的重要性 在开发过程中，如果程序运行出现了问题，我们是可以使用我们自己的 Debug 工具来检测到到底是哪一步出现了问题，如果出现了问题的话，是很容易排查的。但程序开发完成之后，我们会将它部署到生产环境中去，这时候代码相当于是在一个黑盒环境下运行的，我们只能看到其运行的效果，是不能直接看到代码运行过程中每一步的状态的。在这个环境下，运行过程中难免会在某个地方出现问题，甚至这个问题可能是我们开发过程中未曾遇到的问题，碰到这种情况应该怎么办？ 如果我们现在只能得知当前问题的现象，而没有其他任何信息的话，如果我们想要解决掉这个问题的话，那么只能根据问题的现象来试图复现一下，然后再一步步去调试，这恐怕是很难的，很大的概率上我们是无法精准地复现这个问题的，而且 Debug 的过程也会耗费巨多的时间，这样一旦生产环境上出现了问题，修复就会变得非常棘手。但这如果我们当时有做日志记录的话，不论是正常运行还是出现报错，都有相关的时间记录，状态记录，错误记录等，那么这样我们就可以方便地追踪到在当时的运行过程中出现了怎样的状况，从而可以快速排查问题。 因此，日志记录是非常有必要的，任何一款软件如果没有标准的日志记录，都不能算作一个合格的软件。作为开发者，我们需要重视并做好日志记录过程。
日志记录的流程框架 那么在 Python 中，怎样才能算作一个比较标准的日志记录过程呢？或许很多人会使用 print 语句输出一些运行信息，然后再在控制台观察，运行的时候再将输出重定向到文件输出流保存到文件中，这样其实是非常不规范的，在 Python 中有一个标准的 logging 模块，我们可以使用它来进行标注的日志记录，利用它我们可以更方便地进行日志记录，同时还可以做更方便的级别区分以及一些额外日志信息的记录，如时间、运行模块信息等。 接下来我们先了解一下日志记录流程的整体框架。
整个日志记录的框架可以分为这么几个部分：
Logger：即 Logger Main Class，是我们进行日志记录时创建的对象，我们可以调用它的方法传入日志模板和信息，来生成一条条日志记录，称作 Log Record。
'loggers': { 'main.core': { 'level': 'DEBUG', 'handlers': ['console', 'file', 'error'] } }, Log Record：就代指生成的一条条日志记录。
Handler：即用来处理日志记录的类，它可以将 Log Record 输出到我们指定的日志位置和存储形式等，如我们可以指定将日志通过 FTP 协议记录到远程的服务器上，Handler 就会帮我们完成这些事情。
'handlers': { 'console': { 'class': 'logging.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b1fd103d49f7e2f3ed3d0268ddb959f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e3917996f34c10b1c89c9a882fbbdc7/" rel="bookmark">
			einsum的本质理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		einsum是numpy和pytorch中一个计算快速灵活的矩阵操作函数，看了网上很多文章解释这个操作，都没有阐述到它的本质，那么多种情况总不能都背记下来吧，终于今天看到一个本质解释，记录下来以后备用。原文地址（似乎也不是原创）：
https://www.jianshu.com/p/27350d110caf
本质就是下面这个图，einsum操作符就是下面这个嵌套循环的关键参数的简记：
具体解释：
（1）einsum操作符的’ -&gt; ‘左边是输入，右边是输出。输入可以1到N个，用’ , ‘分隔各个输入变量，输出只能一个。每个变量的字母表示对应的维度。字母数量必须和维度数量一致，否则报错。
（2）首先根据输出维度决定最外面的for循环的嵌套，比如上面输出C有两个维度i,j，就是两层循环嵌套。
（3）然后在输出侧消失的维度标记字母则表示发生了相加聚合，因此需要在里层循环。
（4）循环的最底层则是对应输入变量的对应元素的相乘，如上面的A[i,k] * B[k,j]
(5)还需要补充说的就是’ -&gt; ‘省略时表示：输出矩阵时按照所有输入的字母去掉重复字母后按字母表顺序排列。比如’ik,kj’表示的是’ik,kj -&gt; ij’。可见这个操作符真是把字符压缩到了极致，能省则省，其他我认为没有必要为了省这几个字符加大了理解难度。
上述解释可以帮助我们理解任何einsum操作符，但是具体应用时我们更需要掌握构造符合要求的操作符，我认为可按如下步骤构造：
（1）首先把输出变量的维度写到’-&gt;'右边，
（2）然后观察输入变量的哪些维度发生了相加聚合，发生相加聚合的轴要用输出没有的字母表示
（3）然后观察哪些输入变量间的维度轴需要同步操作，通常是具有同样物理含义的轴，它们用同一个字母表示，
（4）最后再核验一下。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec67465b1ff6c38061dcef90c16862e3/" rel="bookmark">
			Dockerfile文件CMD执行脚本Docker容器不退出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CMD、ENTRYPOINT都是在启动容器时执行命令的语句，但一个容器对应一个主进程，如果主进程执行结束了，容器也就启动不了了，自动退出状态，单纯利用
CMD [“/home/agent/pontus/run.sh”, “start”]执行完脚本容器就是exit状态了，也没法进入交互窗口，需要将CMD进行改写如下，可以加tail -f /dev/null。
CMD [“bash”, “-c”, “/home/agent/pontus/run.sh start &amp;&amp; tail -f /dev/null”]
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b31b8532db03804458e60e6372957012/" rel="bookmark">
			【Vue】点击父组件空白处让子组件隐藏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vue中如何实现点击目标区域之外关闭目标区域 点击目标区域之外关闭目标区域点击组件外部隐藏组件自身 在做项目时需要实现在点击空白区域（即子组件外部）使得下拉窗口（子组件）隐藏 点击目标区域之外关闭目标区域 在网上看到很多教程都是通过添加点击事件监听document.addEventListener，监听click事件
当鼠标事件不发生在元素内部时，设置显隐属性为false
代码实现如下：
vue代码 &lt;template&gt; &lt;div class="test"&gt; &lt;!-- 注意这里必须要加.stop阻止事件冒泡 --&gt; &lt;button @click.stop="show"&gt;点我出现&lt;/button&gt; &lt;div v-show="isShow" ref="box" class="box"&gt;&lt;span&gt;控制我的显隐状态&lt;/span&gt;&lt;/div&gt; &lt;/div&gt; &lt;/template&gt; js代码 export default { name: "Test", data() { return { isShow:true }; }, computed: {}, mounted() { document.addEventListener("click", (e) =&gt; { if (!this.$refs.box.contains(e.target)) { this.isShow = false; } }); }, methods: { show(){ this.isShow=true } }, } 但是这种方法并不能解决我的问题！
我要操作的下拉窗口是子组件，会报错
报错内容如下：
Uncaught TypeError: _this.$refs.box.contains is not a function at HTMLDocument.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b31b8532db03804458e60e6372957012/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8fb0178d73781baae30846848fb7c179/" rel="bookmark">
			ZooKeeper（伪）集群搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 一、ZooKeeper集群角色二、ZooKeeper（伪）集群搭建1、调整配置文件2、创建myid文件，配置服务器编号3、启动zookeeper集群 搭建集群前先稍微介绍一下zk集群中的相关角色和它们所拥有的指责
一、ZooKeeper集群角色 ZooKeeper集群中有三种角色：Leader（领导者）、Follower（跟随者）、Observer（观察者）。
Leader：事物请求（写操作）的唯一调度者和处理者，保证集群事物处理的顺序性，同时也是集群内部各个服务器之间的调度者。对于create、set、delete等有写操作的请求，都需要统一转发给leader处理，leader需要决定编号、执行操作，这个过程称之为事物。Follower：处理客户端非事物（读操作）请求（可直接响应）。它可以转发事物请求给leader、参与集群leader的选举投票。Observer：对于非事物请求可以独立处理（读操作），对于事务性请求会转发给leader处理。Observer节点接收来自leader的inform信息，更新自己的本地存储，不参与提交和选举投票。通常在不影响集群事物处理能力的前提下，提升集群的非事物处理能力。 二、ZooKeeper（伪）集群搭建 1、调整配置文件 由于笔者部署的是伪集群，在同一台服务上部署三个节点，所以需要复制两份从节点的配置文件，具体修改如下：
#数据存放路径（每个节点都需要配置自己的地址） dataDir=/usr/local/var/run/zookeeper/data #各节点服务器地址（每个配置文件的下方配置相同） server.1=127.0.0.1:2887:3887 server.2=127.0.0.1:2888:3888 server.3=127.0.0.1:2889:3889 server.A=B:C:D
A是一个数字，表示这是第几号服务器；集群模式下配置一个文件myid，这个文件在dataDir目录下，这个文件里面有一个数据就是A的值。zookeeper启动时读取次文件，拿到里面的数据与zoo.cfg里面的配置信息比较从而判断到底是哪个server；B是这个服务器的地址；C是这个服务器Follower与集群中的leader交换信息的端口；D是集群中的leader挂了，重新进行选举leader时所需要的端口； 2、创建myid文件，配置服务器编号 在dataDir对应的目录下创建myid文件，内容为对应ip的zookeeper编号
cd /usr/local/var/run/zookeeper/data # 在文件中添加与server对应的编号（注意上下不要有空行、左右不要有空格） vim myid 3、启动zookeeper集群 启动前需要关闭防火墙（生产环境需要打开对应的端口）
# 分别启动三个节点的zk server（伪集群启动可使用不同的配置文件） zkServer start /usr/local/etc/zookeeper/zoo.cfg # 查看集群状态 zkServer status /usr/local/etc/zookeeper/zoo.cfg 注：连接不同zk端口使用如下指令：zkCli -server ip:port 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/925ea10b4a97aa9947bb16bb9f86ac00/" rel="bookmark">
			MySQL获取汉字的拼音首字母并过滤字母符号数字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL获取汉字的拼音首字母网上一堆,都是一样的代码,也不知道是哪个大神写的,我也不打算考据,就说说该方法的不足,当字符串内有字母,符号或数字的时候,就无法获得拼音首字母了,先看看原代码
--获取单个汉字首字母拼音 CREATE FUNCTION `fristPinyin`(P_NAME VARCHAR(255)) RETURNS varchar(255) CHARSET utf8 BEGIN DECLARE V_RETURN VARCHAR(255); SET V_RETURN = ELT(INTERVAL(CONV(HEX(left(CONVERT(P_NAME USING gbk),1)),16,10), 0xB0A1,0xB0C5,0xB2C1,0xB4EE,0xB6EA,0xB7A2,0xB8C1,0xB9FE,0xBBF7, 0xBFA6,0xC0AC,0xC2E8,0xC4C3,0xC5B6,0xC5BE,0xC6DA,0xC8BB, 0xC8F6,0xCBFA,0xCDDA,0xCEF4,0xD1B9,0xD4D1), 'A','B','C','D','E','F','G','H','J','K','L','M','N','O','P','Q','R','S','T','W','X','Y','Z'); RETURN V_RETURN; End --获取字符串汉字首字母拼音（基于上面的方法） CREATE FUNCTION `pinyin`(P_NAME VARCHAR(255)) RETURNS varchar(255) CHARSET utf8 BEGIN DECLARE V_COMPARE VARCHAR(255); DECLARE V_RETURN VARCHAR(255); DECLARE I INT; SET I = 1; SET V_RETURN = ''; while I &lt; LENGTH(P_NAME) do SET V_COMPARE = SUBSTR(P_NAME, I, 1); IF (V_COMPARE != '') THEN #SET V_RETURN = CONCAT(V_RETURN, ',', V_COMPARE); SET V_RETURN = CONCAT(V_RETURN, fristPinyin(V_COMPARE)); #SET V_RETURN = fristPinyin(V_COMPARE); END IF; SET I = I + 1; end while; IF (ISNULL(V_RETURN) or V_RETURN = '') THEN SET V_RETURN = P_NAME; END IF; RETURN V_RETURN; END 测试一下
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/925ea10b4a97aa9947bb16bb9f86ac00/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd4f44d04fac1ce6259610afc320d777/" rel="bookmark">
			扫雷【含递归和标记的完整代码及详细讲解】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、游戏思路
二、游戏部分设计
1、棋盘的初始化
2、棋盘的打印
3、雷场的布置
4、用户排雷
5、递归函数部分
三、完整代码
四、结语
扫雷，扫雷是一款大众类的益智小游戏,于1992年发行。游戏目标是在最短的时间内根据点击格子出现的数字找出所有非雷格子,同时避免踩雷,踩到一个雷即全盘皆输。
今天我们就来完成扫雷的代码实现，当然比较简易，凭借代码只能基本的玩法和雏形，下面我们进入代码环节。
一、游戏思路 对于扫雷，我们需要设计两个棋盘，一个mine，一个show，后者用于用户自身的体验，前者用于开发者来修改，在用户进行游戏时，他修改了show的部分，我们的棋盘mine根据玩家对show的更改来完成判定游戏的输赢。在这点确定之后我们要完成以下几点：
1、对棋盘的初始化 2、对棋盘的打印
3、对mine进行布置雷场
4、玩家对雷的查找和雷信息的掌握
5、提高玩家查找效率
二、游戏部分设计 1、棋盘的初始化 void Init_board(char board[ROWS][COLS], int rows, int cols,char set) { for(int i=0;i&lt;rows;i++) { for(int j=0;j&lt;cols;j++) { board[i][j] = set; //我们看的用‘0’来表示，用户看的用‘*’来表示 } } } 因为有两个棋盘，所以展示给用户和开发者的是不一样的符号，用户的用于体验，开发者的便于实现代码，所以这里我们用char set来代表棋盘的符号，对于用户我们用*，对于开发者，我们用0来表示，这会为接下里找雷的信息埋下伏笔。
这里还有一个重点：我们的初始化要再原本棋盘的基础上增加两行两列，这样会更加方便处理位于棋盘边线上的位置
2、棋盘的打印 void Display_board(char board[ROWS][COLS], int row, int col) { for(int i=0;i&lt;=col;i++) { printf("%d ", i); } printf("\n"); for(int i=1;i&lt;=row;i++) //此时的row，col，用ROW，COL来表示，多出的两个长宽不表示出来 { printf("%d ", i); for(int j=1;j&lt;=col;j++) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd4f44d04fac1ce6259610afc320d777/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/826ce86078f4f0fed6117414a5994d9d/" rel="bookmark">
			Mysql实现类似sum、avg、max的聚合函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实现类似Mysql的聚合函数 项目需要，想实现一个类似于mysql的聚合函数的函数来完成自己的sql查询，但是查不到mysql内置的聚合函数是怎么写的，百度了很久都没有找到相关的类似的案例，最终也只是在一遍文章中找到了一些思路。
我们都知道，聚合函数是对我们group by之后的数据进行处理的，那么我们的函数的参数应该会是一个list或者是数组。但是，由于没有类似的案例做参考，像sum、max等这些聚合函数，内部到底是怎么处理这个参数的，于是转变了思路，将函数的参数穿化成一个字符串，然后在函数的内部将这个字符串再进行拆分。这样我们可以在将传入的参数嵌套一层GROUP_CONCAT（）函数。
案例如下：
这里先说明一下我的需求，我项目需要计算某段时间内某个点位下ph的平均值，但是ph的平均值不是简单的 总和/总个数，而是一个比较复杂的公式，。
函数如下：
CREATE DEFINER=`root`@`%` FUNCTION `F_CalPhAvgVaule`(str VARCHAR(21845)) RETURNS double BEGIN declare	lastValue double; declare	avgValue double; declare counts int default 1; SELECT CHAR_LENGTH(str) - CHAR_LENGTH(REPLACE(str,',','')) + 1 INTO counts; SET @i = 1; SET @dvalue = 0.0; WHILE @i &lt;= counts DO SET @dvalue = @dvalue + POW(10,-SUBSTRING_INDEX(subString_index(str,',',@i),',',-1) + 0); SET @i = @i + 1; END WHILE; SET avgValue = @dvalue / counts; SET lastValue = -LOG10(avgValue); RETURN lastValue; END 首先新建一个表来简单的测试
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/826ce86078f4f0fed6117414a5994d9d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3fb87aa6b5c10ead630b8d374fc03e68/" rel="bookmark">
			USG6000V.zip防火墙镜像模板，支持ensp版本V100R002C00B500
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		USG6000V.zip防火墙镜像模板，支持ensp版本V100R002C00B500 链接：https://pan.baidu.com/s/1v8YE2u5jPZwzpKjw8oNakQ
提取码：uoca
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23eeabbf4eed3051900f4b3209462d2e/" rel="bookmark">
			分组交换时延练习题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.基础概念题 假设有Q段链路，每段链路的带宽为Rb/s，若需要发送F bit大小的文件，分成M个分组，每个分组增加H bit的首部，若采用分组交换技术，忽略所有的传播时延和结点处理时延，问从发送方发送数据开始到接收方完全收到所有数据一共需要多少时间？
解：由题意可知：每组的数据大小为 F/M bit 将分组发送到链路上的发送时延为：t1=(F+M×H)/R s
最后一个分组到达的时间：t2=(F/M+H)×(Q-1)/R s
一共需要的时间：T=t1+t2=(F+M×H)/R+(F/M+H)×(Q-1)/R
2.时延计算例题 两主机间的链路长度为60m，链路带宽为10Mb/s，信号传播速率为2.0×10⁸m/s，其中一台主机给另一台主机发送1bit信息，当主机接收完该信息时共耗费多长时间？ 解：发送时延：1bit/10×10⁶b/s=10⁻⁷ s
此时数据头已经传播的距离为：10⁻⁷×2.0×10⁸=20m
剩下的距离为 60m-20m=40m，但信息末端还有60m的距离
传播时延：60÷2.0×10⁸=3×10⁻⁷ s
综上所述，共耗费的时间为 发送时延+传播时延=4×10⁻⁷ s
3.考研真题 在下图所示的采用“存储-转发”方式的分组交换网络中，所有链路的数据传输速率为100Mbps，分组大小为1000B，其中分组头大小为20B。若主机H1向H2发送一个大小为980000B的文件，则在不考虑分组拆装时间和传播延迟的情况下，从H1发送开始到H2接收完为止，需要的时间至少是多少？
解：
分组的数量：980000÷（1000-20）=1000组
发送到链路上的时延为：1000×1000×8/(100×10⁶)=80ms
最后一个分组到达H2的时延：1000×8×2/(100×10⁶)=0.16ms
选择经过三段链路的方式需要的时间最少
需要的时间至少为：80ms+0.16ms=80.16ms
注意单位的转换：1B=8bit
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a96fbeac95cd498ee3e18fa4849b8165/" rel="bookmark">
			【LaTeX】IEEE模板中作者及单位命令使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、前言二、原文三、如何使用1. Names in Journal/Technote Mode2. Names in Conference Mode 四、总结五、参考 一、前言 正如题目所言，笔者第一次使用IEEE的会议LaTex模板，加入太多作者会导致排版不好看，于是笔者研究了模板中自带的文件《How to Use the IEEEtran LATEX Class》文件中IV. THE TITLE PAGE 一节，将学习成果记录如下，首先是原文其次是各种类型的实现。
二、原文 三、如何使用 使用\author命令指定作者信息，这里介绍两者常用的情况Names in Journal/Technote Mode和Names in Conference Mode，我本次主要参考的是会议论文写法。
1. Names in Journal/Technote Mode 典型的期刊论文的作者信息如下语句。
\author{ Michael~Shell,~\IEEEmembership{Member,~IEEE, } John~Doe,~\IEEEmembership{Fellow,~OSA,} and~Jane~Doe,~\IEEEmembership{Life~Fellow,~IEEE} \thanks{Manuscript received January 20, 2002; revised August 26, 2015. This work was supported by the IEEE.}% \thanks{M. Shell was with the Georgia Institute of Technology.} } \IEEEmembership使用斜体字表示作者的IEEE会员身份。使用~来确保名字/会员身份对保持在一起 样式如下 👇
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a96fbeac95cd498ee3e18fa4849b8165/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c4bffa45b59b14c1c277b4591f8bc5b/" rel="bookmark">
			1.2 网络的基本概念
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
二、计算机网络的基本概念
1.网络协议 2.网络交换技术 3.网络的带宽、吞吐量和传播速度
4.分组交换网络的时延
二、计算机网络的基本概念 1.网络协议 协议是网络中最重要的软件，规定了具体通信的规则，其中包括编码规则、数据封装规则、数据表示规则、数据同步处理规则等。网络协议的学习是本课程的重点内容。
协议的三要素：语法、语义、同步
类比见面说“你好”：
语法：中文
语义：问候语
同步：当有人向你问好时，你也要向他问好 网络协议示例：
TCP/IP协议族：因特网上使用的协议的集合
以TCP协议和IP协议为基础，包含很多具体的协议，不同的协议实现不同的功能，例如：HTTP、FTP、SMTP、DNS、TCP、UDP、IPv4、ICMP、RIP、OSPF、IGMP、IPv6、NAT、DHCP
2.网络交换技术 交换的概念： 网络中间结点按照某种方式动态地分配传输线路的资源，从输入链路选择连通到输出链路的过程称为交换。
分类：电路交换技术、分组交换技术、报文交换技术
电路交换技术 特性：
提供面向连接的服务（拨号建立连接，通信，挂机释放连接）资源独占，价格高（最典型的例子是打电话，只能两两通信，资源独占）通信可靠性高，但通信效率很低 注意拨打普通电话和拨打IP电话的区别，拨打普通电话使用的是电话网通信，属于电路交换技术，拨打IP电话使用的IP网络，属于分组交换技术。 分组交换技术 分组：将需要传输的较大文件或报文分成多个小的包（分组）。
存储转发：分组交换机（路由器）收到分组，存储到缓存中，排队等待处理，最后选择输出链路转发。
资源共享：多个用户可以共享一段链路，资源共享是宏观的。 特性：
适合计算机通信，实现宏观上的资源共享，通信效率高，成本低；可能导致网络延迟很大甚至出现网络拥塞。 报文交换技术 报文交换可以看作不分组的分组交换。 特性：
不分组；存储转发；资源共享。 3.网络的带宽、吞吐量和传播速度 网络带宽概念：网络的最高数据传输率，即每秒最高能传输多少bit的数据，单位b/s或bps。 注意：一个网络的带宽是该网络所有链路带宽的最小值。
如下图，网络带宽为4Mb/s
带宽包括物理带宽和网络带宽
物理带宽是一段链路所能传输的频率的范围，单位是Hz。 单位说明：
网络带宽单位：1Mb/s=10^3kb/s=10^6b/s
计算机存储单位：1M=1024K=2^20Byte
1Byte=8bit
吞吐量（throughput） 在单位时间内实际通过某个网络（或信道、接口）的数据量，单位b/s
吞吐量是网络实际的数据传输率，网络带宽是网络最高的吞吐量。
传播速度 信号（即电磁波）在传输介质上的传播速度，单位m/s或km/h 4.分组交换网络的时延 传输时延（发送时延）：数据从结点发送到链路上的时间。由网络带宽、数据大小决定 传输时延=数据大小/网络带宽
传播时延：信号从链路的一端发送到另一端传播的时间。由传播介质、传播速度、链路长度决定 传播时延=链路长度/传播速度
结点处理时延（排队转发时延）：路由器接收数据，排队等待处理，查找转发表决定输出链路所花费的时间。包括排队时延和转发时延。由已排队的分组数量、转发表规模、路由器性能决定。 接收时延：一般作为结点处理时延考虑。 具体练习题目见下篇博客：分组交换时延练习题 往返时延RTT RTT（Round-Trip Time）表示从发送端发送数据开始，到发送端收到来自接收端的确认为止总共经历的时延。RTT反映了分组传输总的时延，使用ping命令可以测量RTT。
时延带宽积
链路的时延带宽积又称为以比特为单位的链路长度。
时延带宽积=传播时延*带宽
复习思考：
1.什么是网络带宽，什么是物理带宽？
2.分组交换技术的特点及缺点？
3.网络时延有哪些？分别由什么决定？
讨论题：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c4bffa45b59b14c1c277b4591f8bc5b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be6fac8d2e1276aeb4f8ae5664acd006/" rel="bookmark">
			SpringBoot连接多个数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		idea:IntelliJ IDEA 2022.1.2 (Community Edition)
数据库:MySQL
依赖:mybatis+mysql+druid
连接数据库部分我就不说了,看我这边文章SpringBoot连接数据库
修改application.properties
# 192.168.1.32:3306/test1和192.168.1.32:3306/test2改成自己的数据库,username和password也改成自己的 spring.datasource.db1.url=jdbc:mysql://192.168.1.32:3306/test1?useUnicode=true&amp;characterEncoding=utf-8 spring.datasource.db1.driver-class-name=com.mysql.jdbc.Driver spring.datasource.db1.username=xxxx spring.datasource.db1.password=xxxx spring.datasource.db2.url=jdbc:mysql://192.168.1.32:3306/test2?useUnicode=true&amp;characterEncoding=utf-8 spring.datasource.db2.driver-class-name=com.mysql.jdbc.Driver spring.datasource.db2.username=xxxx spring.datasource.db2.password=xxxx spring.datasource.type=com.alibaba.druid.pool.DruidDataSource 创建包xxx.xxx.xxx.mapper.db1和xxx.xxx.xxx.mapper.db2
在db1和db2内分别创建DB1Mapper.java和DB2Mapper.java,写入查询语句,查询在不同数据库的两个表
@Mapper public interface DB1Mapper { @Select("select v.video_name from video v") List&lt;String&gt; getVideoName(); } @Mapper public interface DB2Mapper { @Select("select u.username from user u") List&lt;String&gt; getUserName(); } 再配置druid,创建DB1DataSourceConfig.java和DB2DataSourceConfig.java
DB1DataSourceConfig的basePackages改成DB1Mapper所在的包,prefix改成application.properties内的db1,DB2DataSourceConfig的basePackages改成DB2Mapper所在的包,prefix改成application.properties内的db2
@Configuration @MapperScan(basePackages = "com.example.demo.mapper.db1", sqlSessionFactoryRef = "db1SqlSessionFactory") public class DB1DataSourceConfig { @Bean(name="db1DataSource") @ConfigurationProperties(prefix = "spring.datasource.db1") @Primary public DruidDataSource db1DataSource() { return new DruidDataSource(); } @Bean(name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be6fac8d2e1276aeb4f8ae5664acd006/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fdbf3193b00afbaed64bb3a44380c23b/" rel="bookmark">
			ONLYOFFICE部署与集成
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OnlyOffice技术文档 概述 协作型的在线文档编辑软件，高度兼容MS Office格式。可进行权限控制，包括复制、下载、编辑等。
OnlyOffice官网
版本说明 社区版（免费，最高20个可同时连接，推荐最高20个用户数）企业版（付费，根据价格可选择用户数）开发者版（付费，根据价格可选择用户数） 点击我查看版本对比，主要区别如下图：
本文档使用社区版
安装说明 Docker安装（推荐） 操作系统要求
硬件要求 CPU：双核2GHz或更高内存：&gt;2G硬盘：&gt;40G其他：至少4 GB的交换空间 软件要求 系统内核版本：3.10或更高版本的amd64 Linux 发行版Docker：&gt;1.10 Linux安装 操作系统要求（硬件要求与Docker的差不多）
软件要求（Debian、Ubuntu）
操作系统：64 位Debian、Ubuntu或其他内核版本 3.13 或更高版本的兼容发行版其他：PostgreSQL: version 12.9 or laterNGINX: version 1.3.13 or laterlibstdc++6: version 4.8.4 or laterRabbitMQ 软件要求（RHEL、CentOS）
操作系统：RHEL 7或 CentOS 7其他：PostgreSQL: version 12.9 or laterNGINX: version 1.3.13 or laterRabbitMQ Windows Server安装 操作系统要求（硬件要求与Docker的差不多）
软件要求（Windows Server）
操作系统：64-bit Windows Server 2012 or higher其他：Erlang: version 24.2RabbitMQ: version 3.9.12PostgreSQL: version 12.9 or later 工作原理 官方说明
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fdbf3193b00afbaed64bb3a44380c23b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a39abb249042a87e7ddbe91a11c2b17/" rel="bookmark">
			1.1 计算机网络的引入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 第一章计算机网络与因特网概述全方位展示计算机网络的基本组成，揭开因特网的神秘面纱。
目录
前言
一、计算机网络的引入
1. 网络无所不在
2. 计算机网络的发展
3.计算机网络的分类 一、计算机网络的引入 1. 网络无所不在 “网络”是一个统称，泛指把人或物互连在一起而形成的系统 。
如：有线电视网络、有线电话网络、有线计算机网络、移动电话网络、无线计算机网络等。 大众熟悉的三大网络：电信网络、有线电视网络、计算机网络。其中发展最快并起到核心作用的是计算机网络。
电信网络是电信系统的公共设施，是指在两个和多个规定的点间提供连接，以便在这些点间建立电信业务和信息的节点与链路的集合。提供电话、电报、传真等服务。
有线电视（cable television，CATV）网是高效廉价的综合网络。有线电视网利用有线电视铺设的同轴电缆进行数据信号的传递，它具有频带宽，容量大，多功能、成本低、抗干扰能力强、支持多种业务连接千家万户的优势，它的发展为信息高速公路的发展奠定了基础。 向用户传送各种电视节目。
计算机网络（Computer Network）是利用通信设备和线路将地理位置不同的、功能独立的多个计算机系统连接起来，以功能完善的网络软件实现网络的硬件、软件及资源共享和信息传递的系统。简单的说即连接两台或多台计算机进行通信的系统，使用户能在计算机之间传送数据文件。 2. 计算机网络的发展 计算机网络(network)也可以理解为由若干结点(node)和连接这些结点的链路(link)组成。 传统的三大网络：电话网络（语音网络PSTN）、计算机网络（computer network）、视频网络（有线电视网络CATV）在上世纪 90 年代及以前，语音、视频和计算机数据通信都需要单独、专用的网络。每个网络都要使用不同的设备来访问，新技术的出现可以同时提供多种服务的新型网络。这种新的融合网络与专用网络不同，它可以通过同一个通信通道或网络结构提供语音、视频和数据服务。
3.计算机网络的分类 按照网络拓扑结构划分 计算机网络拓扑结构是指网络中各个站点相互连接的形式。如：星型、环形、总线型、树型、网状型、无线蜂窝型 按照网络作用范围划分 广域网WAN（Wide Area Network）:作用范围通常为几十到几千公里。用来实现不同地区的局域网或城域网的互联，可提供不同地区、城市和国家之间的计算机通信的远程计算机网络。
城域网MAN（Metropolitan Area Network）:作用距离约为5~50公里。介于局域网与广域网之间，覆盖一个城市的地理范围，用来将同一区域内的多个局域网互连起来的中等范围的计算机网络。
局域网LAN（Local Area Network）:局限在较小的范围（如1公里左右）。局域网包括：以太网、令牌环网等，当前的局域网的主流是以太网。
个人局域网PAN（personal Area Network）:范围很小，大约在10米左右。
若中央处理机之间的距离非常近（如仅 1 米的数量级甚至更小些），则一般就称之为多处理机系统，而不称它为计算机网络。 接入网AN（Access Network），又称为本地接入网或居民接入网，是一类比较特殊的计算机网络，用于将用户接入互联网。接入网是指骨干网络到用户终端之间的所有设备，长度一般为几百公里到几公里，称为“最后一公里”。
因特网的接入技术有很多种：模拟拨号、ISDN、ADSL、城域以太网、HFC等。 按网络使用者划分 公用网（public network）：按规定交纳费用的人都可以使用的网络，因此也成为公众网。
专用网（private network）：为特殊业务工作的需要而建造的网络。
公用网：包括公共电话交换网（PSTN）、数字数据网（DDN），综合业务数字网络（ISDN）等
专用网：某个单位或部门组建的不允许其他部门或单位使用。
复习小结：
1.网络有哪几种?
2.什么是融合网络？
3.计算机网络按照拓扑结构分成哪几类？
4.“最后一公里网络”指的是什么网络？
讨论题：学生寝室的网络属于什么网络？（具体答案见评论区。）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7d567008ed9adb6c58f7c6ac4208b13/" rel="bookmark">
			modelsim安装及易出错问题，妥妥解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		### 安装教程
硬件：
1.笔记本：W7/W8/W10系统 64位；
2.软件：modelsim-win64-10.6d-se（安装文件及破解文件）
## 1、下载并解压好文件包，然后运行安装程序根据向导提示进行软件安装
## 2、依提示安装软件过程中需要注意的是，会有三个弹出框提示，首先是是否创建桌面快捷方式提示框弹出，点击是即可
## 3、弹出是否添加到系统环境变量提示框，同样点击是
## 4、在安装的最后，提示是否安装Key Driver，点击否，不要安装Key Driver
## 5、安装成功
完成以上步骤很简单，可能就需要一两分钟的时间。
# 破解教程
## 1、接下来对软件进行破解操作，将Patch文件夹内破解文件MentorKG.exe和patch64_dll.bat复制到软件安装路径下（注意，这块是复制到win64下面），然后双击运行patch64_dll.bat
## 2、把Modelsim SE 10.1a的安装目录下的mgls64.dll文件（有人有mgls.dll也修改，没有就不管了）的 “只读” 属性去掉（这一步很重要），
## 3、将生成的许可证另存为LICENSE.TXT，保存在软件安装路径下（注意，这块是复制到win64下面）
其实，modelsim安装路径下原来有一个LICENSE，所以不要管这个
## 4、创建系统环境变量**（新建）**
变量名：MGLS_LICENSE_FILE
变量值：LICENSE.TXT的路径
复制安装路径一定要敲个LICENSE.TXT，我第一次忘记，就失败了。
## 4、至此，成功注册激活。
双击打开就是下面这个样子就可以了，有需要的联系我发安装包。
重点已经画出，希望大家愉快学习。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ba89e780d217855858531f4510a3914/" rel="bookmark">
			npm install卡住
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 https://blog.csdn.net/Destiny_shine/article/details/113890556
npm install 在下载某个包时卡住不动 问题：
在启动一个vue项目之前，需要执行 npm install 命令安装依赖，本地执行该命令过程中出现一个问题，就是在下载某个包的地方卡住不动了，显示类似 extract:core-js: sill extract source-map@xxx 的字眼。
原因：
可能有以下两种原因：
1.版本问题导致。node版本或者npm版本太旧，此时需更新版本； 2.下载源问题导致。可以使用国内淘宝镜像作为下载源。 解决方法： 1.解决版本问题
更新node：node官网下载安装包覆盖之前的node 更新npm：执行命令 npm install -g npm 2.下载源问题
当下载失败或者下载到某处停止不动时，可以进行如下操作：
清除缓存：npm cache clean -f 将项目中的node_modules文件夹以及package-lock.json文件删除 执行：npm install --registry=https://registry.npm.taobao.org重新拉取依赖 启动项目：npm run dev vue项目npm run build报错npm ERR! missing script: build 执行命令：npm run build:prod dist文件目录+nginx配置参考 location / { root /data/release/dist; index index.html index.htm; try_files $uri $uri/ /index.html; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e1a41cd20fa4683361dd8314d965049/" rel="bookmark">
			Neuron：开源的工业物联网（IIoT）边缘工业协议网关软件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Neuron 整合 Neuron (https://github.com/emqx/neuron) 是一个EMQ 发起并开源的工业物联网（IIoT）边缘工业协议网关软件，用于现代大数据技术，以发挥工业 4.0 的力量。它支持对多种工业协议的一站式访问，并将其转换为标准 MQTT 协议以访问工业物联网平台。Neuron 和 eKuiper 整合使用，可以方便地进行 IIoT 边缘数据采集和计算。
Neruon 2.0 版本与 eKuiper 1.5.0 版本将无缝整合，用户无需配置即可在 eKuiper 中接入 Neruon 中采集到的数据，进行计算；也可以方便地从 eKuiper 中反控 Neuron 。两个产品的整合，可以显著降低边缘计算解决方案的部署成本，简化使用门槛。使用 NNG 协议进行通信，也可显著降低网络通信消耗，提高性能。
通用的 SQL source 和 sink 插件 在旧的系统升级改造过程中，我们往往还需要考虑对原有的系统的兼容。大量的老旧系统采用传统关系数据库存储采集的数据。在新的系统中，可能也有保存在数据库中，不方便提供流式接入的数据却需要进行实时计算的数据。还有更多的场景需要接入形形色色数量庞大的支持SQL的数据库或其他外部系统。
eKuiper 提供了统一的，多数据库通用的 SQL 拉取 source，可定时拉取支持 SQL 的数据源的数据，并提供基础的去重能力，形成流式数据进行统一的流式计算处理。该插件的预编译版本支持 MySQL、PostgresSQL 等常见数据库的接入；同时插件中搭载了几乎所有常见数据库的连接能力，用户只需要在编译时提供所需支持的数据库的参数，即可自行编译支持自定义数据库类型的插件。
除了数据拉取，我们也提供了数据写入的通用 SQL 插件。值得注意的是，eKuiper 本身已经提供了针对 InfluxDB、TDengine 等时序数据库的专用插件。通用 SQL 插件同样可以支持连接这些数据库，但提供的是 insert 功能，不支持特定数据库的非标准概念，例如 TDengine 的超级表只能使用 TDengine 插件进行写入。
更多信息以及支持的数据库列表，请参见 SQL source 插件和 SQL sink 插件文档。
其余新功能回顾 前两个月开发版本中的新功能也在 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e1a41cd20fa4683361dd8314d965049/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e96f9887ead9040d91dfa0f4e624857/" rel="bookmark">
			【Android智能定位手表开发】- 文章目录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本项目已开发半年，基本工作已接近80%，是时候做一个系统的经验总结，为了更有动力把这个项目未完成的工作完成和产品完善，直到量产上市！！！！！
总结内容分为十部分：
一、产品的市场调查和定位
1.产品市场调查的心得体会
2.产品最终定位的心得体会
二、 Android智能定位手表的方案选型确认
1.ID和MD的结构选择
2.主芯片平台的选择
3.屏，TP,摄像，喇叭，马达，咪头等选择
4.整体方案的综合评估
三、 Android智能定位手表的结构设计 1.ID的设计和确认
2.MD的设计和确认
3.堆叠的设计和确认
4.整体结构设计总结
四、 Android智能定位手表的硬件设计
1.元器件的选型和设计
2.原理图的设计
3.Layout的设计
4.硬件设计的综合评估
五、 Android智能定位手表的驱动调试
1.屏的驱动调试
2.TP的驱动调试
3.摄像头的驱动调试
4.SIM卡号和SD卡的驱动调试
5.加速传感器，地磁传感器，陀螺仪的驱动调试
6.喇叭，咪头，马达，耳机的驱动调试
7.WIFI，蓝牙，GPS的驱动调试
8.GSM+WCDMA射频校准和调试
9.驱动调试的综合评估
六、 Android智能定位手表的UI界面开发 还在进行中，后续调整。。。。。。大致规划,后续调整：
1.学习JAVA语言和Android开发
2.改适配横屏的拨号界面
3.改相关不协调的界面
4.针对手表写一个Laucher
七、 Android智能定位手表云平台开发
还在进行中，后续调整。。。。。。
1.学习PHP语言和SQL
2.搭建平台，能进行通信
八、供应链的整合和谈判的一些看法
九、智能硬件推广和销售一些看法
十、总结
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b0261fb56460e850d28d3b25b3f8d30/" rel="bookmark">
			什么是外部模式？概念模式？内部模式？它们之间有何联系？这种分级结构的优点是什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		外部模式 用户所使用的数据库，是一个或几个特定用户所使用的数据集合(外部模型)，是用户与数据库系统的接口，是概念模型的逻辑子集。外模式面向具体的应用程序，定义在逻辑模式之上，但独立于存储模式和存储设备。设计外模式时应充分考虑到应用的扩充性。当应用需求发生较大变化，相应外模式不能满足其视图要求时，该外模式就必须做相应改动
简而言之外部模式是数据库用户能狗看见和使用的局部数据的逻辑结构和特征的描述
概念模式 数据库的逻辑表示，包括每个数据的逻辑定义以及数据间的逻辑联系。它是数据库中全部数据的整体逻辑结构的描述，是所有用户的公共数据视图，综合了所有用户的需求。它处于数据库系统模式结构的中间层，与数据的物理存储细节和硬件环境无关，也与具体的应用程序、开发工具及高级程序设计语言无关
概括为概念模式是由数据库设计者综合所有用户数据，按照统一的观点构造的对数据库全局逻辑结构的描述
内部模式 内模式又称存储模式，对应于物理级，它是数据库中全体数据的内部表示或底层描述，是数据库最低一级的逻辑描述，它描述了数据在存储介质上的存储方式和物理结构，对应着实际存储在外存储介质上的数据库。内模式由内模式描述语言来描述、定义所有内部记录类型、索引和文件的组织方式，以及数据控制方面的细节，它是数据库的存储观。
内模式亦称存储模式，是对数据库在物理存储器上具体实现的描述，表述。它规定数据在存储介质上的物理组织方式、记录寻址技术，定义物理存储数据块的大小、溢出处理方法等。与概念模式相对应，内模式由数据存储描述语言进行描述。数据库系统的三级模式结构将数据库的全局逻辑结构和物理存储结构区分开来，给数据库的组织和使用带来了方便，不同的用户可以有各自的数据视图，所有用户的的数据视图集中在一起统一组织，得到全局数据视图。用存储描述语言来定义利和描述全局数据视图数据，并将数据存储在物理介质上。这中间进行了两次映像: 一次是外模式与概念模式之间的映像，定义了它们之间的对应关系，保证了数据的逻辑独立性；另一次是概念模式与内模式之间的映像，定义了数据的逻辑结构和物理存储之间的对应关系，使全局逻辑数据独立于物理存储，保证了数据的物理独立性。
内部模式是对数据库中数据物理结构和存储方式的描述，是数据在数据库内部的表达方式
联系和优点 对于外部模式和概念模式(模式和内模式），他们是通过外模式/模式（模式/内模式）映像相互联系，当数据库的外部模式或者模式需要改变时，只要对对应的映像做出相应的改变就可以保证数据和程序的逻辑独立性
优点是：
1.提升了数据的独立化程度，将模式与内模式分开，保证了数据的物理独立性。讲外模式和模式分开，保证了数据的逻辑独立性。
2，数据库系统把用户数据核物理数据完全分开，使用户摆脱了烦琐的物理存储细节，减少了应用程序维护的开销
3.简化了用户接口。按照外模式编写应用程序或输入命令，而不需要了解数据库内部的存储结构，方便用户使用系统。
4.有利于数据共享。在不同的外模式下可由多个用户共享系统中的数据，减少了数据冗余。
5.有利于数据的安全保密。在外模式下根据要求进行操作，只能对限定的数据操作，保证了其他数据的安全。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48f74768efa07a85fc869c4987fa12b2/" rel="bookmark">
			UTM转经纬度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		应用场景： UTM转换为经纬度坐标
实现代码： from pyproj import Transformer, Proj, transform WGS84 = Proj(init='EPSG:4326') p = Proj(init="EPSG:32651") # utm x, y, z = 250664.01, 3346856.17, 0 lat, lon = transform(p, WGS84, x, y) print("x:", x, "y:", y) print("lat:", lat, "lon:", lon) 参数说明： EPSG：英文全程European Petroleum Survey Group，中文名称为欧洲石油调查组织。对世界的每一个地方都制定了地图，但是由于座标系不同，所以地图也各不相同。
‘EPSG:4326’：世界地图常用的坐标系，GPS使用的就是这个，这个坐标系也叫 WGS84 。对于中国地图来说，常用的有EPSG:4479坐标系、EPSG:4480，针对不同的使用场景，选择不同的坐标系。
‘EPSG:32651’：WKID，在地图中找到UTM坐标所在的区域 [https://www.netzwolf.info/ol2/utmgrid.html]，比如杭州市属于 51 对应 326 51
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4b5408bbc451faa8d3fd0c18aa32e27/" rel="bookmark">
			ubuntu软件推荐
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里写自定义目录标题 ubuntu软件推荐装机必备聊天软件办公软件笔记软件编程软件音、视频处理软件制图软件文件管理、远程连接工具GNOME Extensions阅读软件统计软件，分析软件测试工具 ubuntu软件推荐 装机必备 软件名称/操作安装命令/配置备注/描述/下载地址安装显卡驱动仅限独显添加Windows字体更换阿里软件源修改中文优先级/etc/fonts/conf.d/64-language-selector-prefer.confChromeFusumaUbuntu触控板配置 聊天软件 软件名称/操作安装命令/配置备注/描述/下载地址微信https://www.ubuntukylin.com/applications/106-cn.html 办公软件 软件名称/操作安装命令/配置备注/描述/下载地址VLCwps搜狗输入法rime(IBUS)（ubuntu推荐）sudo apt-get install ibus-rime7zipsudo apt-get install p7zip-full p7zip-rar
笔记软件 软件名称/操作安装命令/配置备注/描述/下载地址obsidianJoplinhttps://github.com/laurent22/joplin/simplenotehttps://github.com/Automattic/simplenote-electron/releases
编程软件 软件名称/操作安装命令/配置备注/描述/下载地址dockerzsh参见 2.zshTerminator参见 3.terminatorideaexport IDEA_JDK=/opt/JetBrains/idea-IU/jdk（切换jdk修复输入框不跟随）webstormvscodepycharmclionAtomeclipsenavicatmysqlredisAnotherRedisDesktopManagerhttps://github.com/qishibo/AnotherRedisDesktopManager/releasesredis-desktop-managersudo snap install redis-desktop-managerjdkexport JAVA_HOME=/opt/jdk-11.0.10
export PATH=.😒{JAVA_HOME}/bin:$PATHpostmansublime textvimnodejsgitmaventomcat
音、视频处理软件 软件名称/操作安装命令/配置备注/描述/下载地址blenderKdenliveSimpleScreenRecorder（简单录屏功能）sudo apt-get install simplescreenrecordershotcutsudo snap install shotcutobs-studio（专业功能）sudo add-apt-repository
ppa:obsproject/obs-studiosudo apt update
sudo apt install obs-studioOpenshot Video EditorAudacityhttps://audacity.onl/download/
制图软件 软件名称/操作安装命令/配置备注/描述/下载地址Xminddrawio(极度推荐)https://github.com/jgraph/drawio-desktop/releasesDia/edrawmaxinkscapesudo add-apt-repository
ppa:inkscape.dev/stable
sudo apt-get update
sudo apt install inkscapegimp+photogimp/usr/share/locale/zh_CN/LC_MESSAGESDraftSightCAD制图digikam图片管理软件 https://www.digikam.org/Krita(开源画图软件)https://krita.org/en/download/krita-desktop/darktablesudo apt-get install darktable
文件管理、远程连接 软件名称/操作安装命令/配置备注/描述/下载地址FileZillaputtyteamviewerRustDesk向日葵scrcpyCloudreve个人网盘搭建 https://github.com/cloudreve/Cloudreve/releases
工具 软件名称/操作安装命令/配置备注/描述/下载地址dconf editorsudo apt-get install dconf-editoraria2clashvmwareremote touchtreesudo apt-get install tree树形结构htopsudo apt-get install htop交互进程管理界面autojumpsudo apt-get install autojump快速文件夹跳转xDroid北京麟卓，在Linux系统上安装安卓软件nmapsudo apt-get install nmap端口扫描软件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a4b5408bbc451faa8d3fd0c18aa32e27/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/453708dee11ef3d35989286354595e25/" rel="bookmark">
			三子棋【讲解超详细】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🌳🌳三子棋是一种民间传统游戏，又叫九宫棋、圈圈叉叉、、井字棋等。将正方形对角线连起来，相对两边依次摆上三个双方棋子，只要将自己的三个棋子走成一条线，对方就算输了。但是，有很多时候会出现和棋的情况。
大家好啊，我是小白，下面让我来和大家一起去看看怎么去实现它的吧！！
最后！！！创作不易，请各位小伙伴们点点赞，你们的支持，是我继续学习的动力哦
目录
一、主函数部分
​test（函数部分）
二、游戏设计部分
棋盘的初始化
棋盘的打印
玩家落子
电脑落子
判断输赢
game游戏部分整体组成
三、完整代码
四、结语
一、主函数部分 int main() { test(); //该游戏整体又一个test（）函数完成 return 0; } 主函数仅仅由一个test函数完成，当我们程序启动时，进入test函数，此时正式开始。为什么我们要这样写呢？因为这样写的目的是为了让我们习惯分块来写一个程序，这样会使程序简洁，容易修改，并且看得更加清晰哦，希望大家要有这个好习惯哦
test（函数部分） void test() { int input = 0; srand((unsigned int)time(NULL)); do //循环可以重复游戏 { menu(); //进入菜单，选择是否游戏的选项 scanf("%d", &amp;input); if (input == 1) //当选择1时进入游戏 { printf("游戏开始\n"); game(); } else if (input ==0) { printf("游戏结束"); } else printf("输入错误，请重新输入\n"); } while (input); } void menu() { printf("-----------------------------------\n"); printf("-----1、开始游戏 0、退出游戏-----\n"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/453708dee11ef3d35989286354595e25/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/edddbf9020788ebc5bea525eb34c533c/" rel="bookmark">
			Flink Cep 扩展 - 动态规则更新及Pattern间within()
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上一篇文章 《Flink Cep 源码分析》我们可以知道Flink cep中Pattern的创建，state的转换，以及匹配结果的数据。这一篇则对Flink cep的两个痛点进行扩展：
1.不能动态规则更新
2.不支持 Pattern间within()
对于这两个问题的解决思路：
动态规则更新：包括 mysql存储规则信息,zookeeper通知规则更新，JaninoCompiler执行动态规则(替换groovy+aviator)
Pattern间within()：则是对cep中两个Pattern间设置超时时间 新增WithinType枚举类(PREVIOUS_AND_CURRENT,FIRST_AND_LAST) 来区分是全局超时还是间隔超时设置，参考：
FLIP-228: Support Within between events in CEP Pattern - Apache Flink - Apache Software Foundation
首先，动态规则更新这个实现已经有很多大佬都出了文章，我这边也是借鉴他们的思路进行实现，并且也根据自己的想法进行了实现。大家可以看下啤酒鸭大佬的文章:
Flink cep动态模板+cep规则动态修改实践_黄瓜炖啤酒鸭的博客-CSDN博客_flinkcep动态规则
如果想要了解我的实现方式可以留言，我再写一篇文章来详细介绍下，本文先讲解下Pattern间Within()的实现方式。
1.案例代码 import org.apache.flink.api.common.eventtime.WatermarkStrategy; import org.apache.flink.api.java.tuple.Tuple3; import org.apache.flink.cep.condition.Begincondition; import org.apache.flink.cep.condition.Endcondition; import org.apache.flink.cep.condition.Middlecondition; import org.apache.flink.cep.cus.WithinType; import org.apache.flink.cep.pattern.Pattern; import org.apache.flink.streaming.api.TimeCharacteristic; import org.apache.flink.streaming.api.datastream.KeyedStream; import org.apache.flink.streaming.api.datastream.SingleOutputStreamOperator; import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment; import org.apache.flink.streaming.api.windowing.time.Time; import org.apache.flink.util.OutputTag; import java.time.Duration; import java.util.Map; public class FlinkCepTest { public static void main(String[] args) throws Exception { StreamExecutionEnvironment env = StreamExecutionEnvironment.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/edddbf9020788ebc5bea525eb34c533c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f8ab763a463b06e2e6adb085967b74b/" rel="bookmark">
			机器学习算法：ROC曲线的绘制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 学习目标 知道ROC曲线的绘制 关于ROC曲线的绘制过程，通过以下举例进行说明
假设有6次展示记录，有两次被点击了，得到一个展示序列（1:1,2:0,3:1,4:0,5:0,6:0），前面的表示序号，后面的表示点击（1）或没有点击（0）。
然后在这6次展示的时候都通过model算出了点击的概率序列。
下面看三种情况。
1 曲线绘制 1.1 如果概率的序列是（1:0.9,2:0.7,3:0.8,4:0.6,5:0.5,6:0.4）。 与原来的序列一起，得到序列（从概率从高到低排）
1100000.90.80.70.60.50.4 绘制的步骤是：
1）把概率序列从高到低排序，得到顺序（1:0.9,3:0.8,2:0.7,4:0.6,5:0.5,6:0.4）；
2）从概率最大开始取一个点作为正类，取到点1，计算得到TPR=0.5，FPR=0.0；
3）从概率最大开始，再取一个点作为正类，取到点3，计算得到TPR=1.0，FPR=0.0；
4）再从最大开始取一个点作为正类，取到点2，计算得到TPR=1.0，FPR=0.25;
5）以此类推，得到6对TPR和FPR。
然后把这6对数据组成6个点(0,0.5),(0,1.0),(0.25,1),(0.5,1),(0.75,1),(1.0,1.0)。
这6个点在二维坐标系中能绘出来。
看看图中，那个就是ROC曲线。
1.2 如果概率的序列是（1:0.9,2:0.8,3:0.7,4:0.6,5:0.5,6:0.4） 与原来的序列一起，得到序列（从概率从高到低排）
1010000.90.80.70.60.50.4 绘制的步骤是：
6）把概率序列从高到低排序，得到顺序（1:0.9,2:0.8,3:0.7,4:0.6,5:0.5,6:0.4）；
7）从概率最大开始取一个点作为正类，取到点1，计算得到TPR=0.5，FPR=0.0；
8）从概率最大开始，再取一个点作为正类，取到点2，计算得到TPR=0.5，FPR=0.25；
9）再从最大开始取一个点作为正类，取到点3，计算得到TPR=1.0，FPR=0.25;
10）以此类推，得到6对TPR和FPR。
然后把这6对数据组成6个点(0,0.5),(0.25,0.5),(0.25,1),(0.5,1),(0.75,1),(1.0,1.0)。
这6个点在二维坐标系中能绘出来。
看看图中，那个就是ROC曲线。
1.3 如果概率的序列是（1:0.4,2:0.6,3:0.5,4:0.7,5:0.8,6:0.9） 与原来的序列一起，得到序列（从概率从高到低排）
0000110.90.80.70.60.50.4 绘制的步骤是：
11）把概率序列从高到低排序，得到顺序（6:0.9,5:0.8,4:0.7,2:0.6,3:0.5,1:0.4）；
12）从概率最大开始取一个点作为正类，取到点6，计算得到TPR=0.0，FPR=0.25；
13）从概率最大开始，再取一个点作为正类，取到点5，计算得到TPR=0.0，FPR=0.5；
14）再从最大开始取一个点作为正类，取到点4，计算得到TPR=0.0，FPR=0.75;
15）以此类推，得到6对TPR和FPR。
然后把这6对数据组成6个点(0.25,0.0),(0.5,0.0),(0.75,0.0),(1.0,0.0),(1.0,0.5),(1.0,1.0)。
这6个点在二维坐标系中能绘出来。
看看图中，那个就是ROC曲线。
2 意义解释 如上图的例子，总共6个点，2个正样本，4个负样本，取一个正样本和一个负样本的情况总共有8种。
上面的第一种情况，从上往下取，无论怎么取，正样本的概率总在负样本之上，所以分对的概率为1，AUC=1。再看那个ROC曲线，它的积分是什么？也是1，ROC曲线的积分与AUC相等。
上面第二种情况，如果取到了样本2和3，那就分错了，其他情况都分对了；所以分对的概率是0.875，AUC=0.875。再看那个ROC曲线，它的积分也是0.875，ROC曲线的积分与AUC相等。
上面的第三种情况，无论怎么取，都是分错的，所以分对的概率是0，AUC=0.0。再看ROC曲线，它的积分也是0.0，ROC曲线的积分与AUC相等。
很牛吧，其实AUC的意思是——Area Under roc Curve，就是ROC曲线的积分，也是ROC曲线下面的面积。
绘制ROC曲线的意义很明显，不断地把可能分错的情况扣除掉，从概率最高往下取的点，每有一个是负样本，就会导致分错排在它下面的所有正样本，所以要把它下面的正样本数扣除掉（1-TPR，剩下的正样本的比例）。总的ROC曲线绘制出来了，AUC就定了，分对的概率也能求出来了。
3 小结 ROC曲线的绘制【知道】 1.构建模型，把模型的概率值从大到小进行排序2.从概率最大的点开始取值，一直进行tpr和fpr的计算，然后构建整体模型，得到结果3.其实就是在求解积分（面积） 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f832c861fb2348401bced01b94c9403b/" rel="bookmark">
			宝塔PHP 7.4 无法安装ZIP组件 undefined symbol: zip_libzip_version
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 宝塔PHP7.4安装完成后无法启动，报错如下：
/www/server/php/74/sbin/php-fpm: symbol lookup error: /www/server/php/74/lib/php/extensions/no-debug-non-zts-20190902/zip.so: undefined symbol: zip_libzip_version 解决：
ZIP扩展是在安装PHP时是已经默认安装的，您可使用phpinfo查看获取。
如PHP安装时，zip未加载，可尝试手动命令安装
wget http://pecl.php.net/get/zip-1.16.0.tgz tar zxvf zip-1.16.0.tgz &amp;&amp; cd zip-1.16.0/ /www/server/php/74/bin/phpize ./configure --with-php-config=/www/server/php/74/bin/php-config make &amp;&amp; make install 找了好多资料才解决，若你也遇到此问题，可以试下 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f28c56b67572018545e74087f30d3cd/" rel="bookmark">
			基于FPGA等精度的实时测量频率和占空比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、要求：
二、指标要求 三、 等精度测频设计原理
四、时序分析： 五、模块设计 1、计数器
2、读数据
3、数据处理
4、数码管显示模块
六、仿真分析
1、计数模块
A、测量1Mhz频率占空比为50%的信号的频率。
B、Em设置为1Mhz，占空比为46%的信号的占空比
2、数据处理模块
3、总体仿真 七、实测展示
八、说明
一、要求： 利用Altera公司的FPGA开发软件Quartus 13.1采用混合设计实现方波信号频率和占空比测量。 二、指标要求 1) 待测方波信号频率范围1Hz~1MHz，测量精度优于0.1Hz 2) 待测方波信号占空比范围1%~95%，测量精度优于1%
3) 频率数据显示精度0.1Hz，给出8位数字的BCD码结果
4) 占空比给出2位整数百分比的BCD码结果
三、 等精度测频设计原理 设计原理流程图如图 1：
图 1设计原理流程图 将在相同时间内对被测信号和标准信号同时计数 ，D触发器保证实际闸门时间与被测信号同步，消除被测信号计数误差；读数据模块两个技术模块数据同时读入送进数据处理模块处理；数据处理模块将读入的数据计算出频率与占空比后送入显示模块；显示模块将频率与占空比显示在数码管上。
等精度测频率原理：
等精度测频法本质上是多周期同步测频，它是在直接测频基础上发展起来的，在目前的测频系统中得到了越来越广泛的应用。等精度测频时，同时对标准信号和待测信号计数，而且实际闸门时间不是固定的，而是被测信号的整数倍，即与被测信号保持同步，因此消除了对被测信号计数所产生的士1个数字误差，使测量精度大为提高。
四、时序分析： 如图 2所示，Tx待测型号在Cl的预置闸门信号期间进行采样计数，使得在En为高时Tx总是整数倍出现。 图 2时序分析图 设在一次实际闸门时间τ中计数器对被测信号的计数值为Nx，对标准信号的计数值为Ns。标准信号的频率为fs，则被测信号的频率为：
fx=(Nx/Ns)·fs （1） 五、模块设计 如图 3所示，计数器模块同时计数频率Ns、Nx值与占空比Nh值，数值传给数据处理模块，由数据模块switch信号切换显示数据的不同位，数值传给数码管显示模块显示。
由一个D触发器实现预置闸门与待测信号的同步，触发信号为Tx，后面四个D触发器为读信号和清零信号延时，由50Mhz标准信号触发，延时两个标准信号单元为Read信号，延时四个标准单元为clr信号；复位信号控制五个D触发器的使能信号。
图 3系统总体设计图 模块代码展示：
1、计数器 频率计数器：
module counter(clk,En,clr,tsq); input clk,clr,En; output reg [27:0]tsq; always@(posedge clk or negedge clr) begin if(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f28c56b67572018545e74087f30d3cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45a7caefa80a684d6da3bd948b054835/" rel="bookmark">
			Mac利用iTMSTransporter命令行上传 ipa 到 App Store
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前言 最近上传IPA包到App Store，真是痛苦，一直等都上不去：
那么有没有更好的方法呢？有的，那么就是用iTMSTransporter命令行上传，亲测上传速度非常快！
一、下载iTMSTransporter 1、iTMSTransporter下载地址
2、下载后双击安装
3、默认安装地址在
/usr/local/itms/bin 4、打开Finder–前往–前往文件夹
二、生成专用密码 1、登录你的APPID
2、生成专用密码
三、生成plist文件 1、导出IPA文件
2、生成plist文件
cd到你的IPA目录执行 xcrun swinfo -f xxx.ipa -o AppStoreInfo.plist -prettyprint true --plistFormat binary 3、生成后把IPA文件和plist文件放到iTMSTransporter目录下，如图所示
四、上传IPA 1、在终端执行命令：
/usr/local/itms/bin/iTMSTransporter -assetFile xxx.ipa -u &lt;你的APPID账号&gt; -p &lt;你的专用密码&gt; -m upload -assetDescription AppStoreInfo.plist 2、上传过程，当你看到这样的进度后，说明正在上传了
3、上传成功
五、后记 1、其实iTMSTransporter还是很强大的，还可以在Windows上面上传IPA文件，有时间介绍一下，其实流程差不多，命令也是差不多。
2、参考链接如下：
iTMSTransporter官方链接
END. 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3e8d40b752af9f5168c63cf948825f9/" rel="bookmark">
			CREStereo： Practical Stereo Matching via Cascaded Recurrent Networkwith Adaptive Correlation-论文阅读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Paper
目录
摘要
介绍
相关工作
方法
自适应群相关层
级联的网络
叠加级联推理
损失函数
合成训练数据
实验
数据集和评估指标 实现细节 消融实验
与SOTA对比
实用性能
总结
摘要 随着卷积神经网络的出现，立体匹配算法最近取得了巨大的进展。但是，因为结构薄、非理想修正、相机模块不一致和各种硬情况场景等实际复杂因素，从智能手机等大众级设备拍摄的真实图像对中准确提取视差仍然是一个巨大的挑战。在本文中，作者提出了一套创新的设计来解决实际立体匹配的问题：
为了更好地恢复精细的深度细节，设计了一个循环细化的层次网络，以粗到细的方式更新视差，以及堆叠级联结构进行推理；提出了自适应群相关层来减轻错误修正的影响；采用了一个新的合成数据集，对困难的情形给予特别注意力，以便更好地推广到真实场景。 研究结果不仅在Middlebury和ETH3D基准中排名第一，显著超过现有的最先进的方法，而且在现实生活中显示了高质量的细节，这清楚地证明了贡献的有效性。 作者对来自Holopix50K数据集的图像的预测示例，展示了立体对的左侧图像及其相应的预测视差。 结果实现了较高的准确性，并显示了高质量的细节，为精细结构的对象。 介绍 立体匹配是计算机视觉的一个经典研究课题，给定一对修正图像，是计算两个对应像素之间的位移，即“视差”。它在自动驾驶、增强现实、模拟散景渲染等许多应用中都发挥着重要的作用。
近年来，在大型合成数据集的支持下，基于卷积神经网络(CNN)的立体匹配方法将视差估计的精度提高到了一个新的高度。然而，为了使该算法在日常摄影的场景中真正实用，我们仍然面临着三个主要的障碍。
首先，对于大多数现有的算法来说，精确恢复精细图像细节或网、线框等薄结构的视差仍然是一个复杂的问题。日常照片是高分辨率的，这更让问题复杂化。例如，在计算中，围绕细节的视差误差会导致渲染结果退化，不利于人类感知。其次，对于真实世界的立体图像对，很难获得完美的修正，因为它们通常是由具有不同特征的相机模块产生的。例如，目前大多数智能手机都用广角镜头和长焦镜头捕捉立体声对，它们具有焦距和失真参数等明显特征，不可避免地会导致不理想的校正。因此，现有的假设立体对被完全修正的方法在这种对抗性条件下很可能失败。此外，由不一致的摄像机模块产生的图像对可能在照明、白平衡、图像质量等方面发生变化，这使得估计任务更加困难。最后，虽然它已经表明，模型训练从足够大的合成数据集可以推广到真实场景，视差估计在典型的硬情况下，如非纹理或重复纹理区域，仍然很困难，这需要特别注意在覆盖相关场景的训练数据集。 【研究动机】 在本文中，作者提出了 CREStereo，交叉立体声匹配网络，即级联立体匹配网络，它包括一套新的设计，以解决实际的立体匹配的问题。为了更好地恢复复杂的图像细节，设计了一个分层网络，以粗到细的方式反复更新视差；此外，采用堆叠级联体系结构进行高分辨率推断。为了减轻校正误差的负面影响，设计了一个自适应群局部相关层来进行特征匹配。此外，我们引入了一个新的合成数据集，在光线、纹理和形状方面具有更丰富的变化，以便更好地推广到真实世界的场景。
目前为止，CREStereo在ETH3D立体双视图和 Middlebury基准测试中都排名第一，并在KITTI 2012/2015上取得了具有竞争力的性能。此外，作者的网络在任意真实场景中表现出了优越的性能，很好地证明了设计的有效性。 因此，作者主要贡献可以总结如下：
提出了一种用于实际立体匹配的级联递归网络和堆叠的高分辨率推理结构；设计了自适应群相关层来处理非理想校正；创建了一个新的合成数据集，以更好地推广到现实场景；方法在 Middlebury和ETH3D等公共基准上优于现有方法的显著优势，大大提高了真实立体图像恢复视差的准确性。 相关工作 传统算法：立体匹配是一个已经研究了很长时间，具有挑战性的问题。传统的算法分为局部算法和全局算法。局部方法使用以极线像素为中心的支持窗口来计算匹配代价。全局方法将立体匹配视为一个优化问题，其中显式代价函数由感知传播或图割算法制定和优化。在此基础上，提出了一种基于动态规划的半全局匹配方法，该方法利用互信息代替强度。
基于学习的算法：深度神经网络首次引入立体匹配任务，仅用于匹配成本计算。Zbontar和LeCun提出训练一个CNN来初始化补丁之间的匹配代价，通过交叉聚合和半叶优化，如SGM（由于代价计算步骤只考虑了局部的相关性，对噪声非常敏感，无法直接用来计算最优视差，所以SGM算法通过代价聚合步骤，使聚合后的代价值能够更准确的反应像素之间的相关性）。近年来，端到端网络已成为立体匹配领域的主流，其中一种网络只使用二维卷积。Mayer等人引入了第一个名为DispNet的端到端网络及其相关版本DispNetC用于视差估计。Pang等人提出了一个具有多尺度残差学习的两阶段框架。Guo等人提出了具有群体相关性的GwcNet来改进相似性度量。AANet介绍了一种新的利用稀疏点和多尺度相互作用的聚合方法。最近的一种方法RAFT-Stereo利用光流网络RAFT的迭代细化设计了一个适合于立体匹配的网络。另一条网络使用3D卷积来执行传统方法的成本量构建和聚合。GCNet和PSMNet提出构建一个具有三维沙漏聚合网络的四维成本量。对于高分辨率图像，Yang等人提出了一种从粗到细的分层网络来解决内存和速度问题。最近，神经结构搜索也被引入了深度立体网络。
实用的立体声匹配：面向真实世界图像的立体匹配是一个较少被探索的问题。Pang等人提出了一种自适应方法，将CNN推广到目标域，没有地面真实视差。Luo等人提出了一种小波合成网络，为智能手机上的散景应用产生更好的结果。Song等人引入了一个领域适应管道，以缩小合成和真实领域之间的差距。
合成数据集：足够的训练数据对于深度立体模型是必不可少的，但在现实世界中很难获得准确的视差。合成数据集提供了高精度和密集的地面真值。最近，He等人使用Blender建立了一个立体匹配的数据生成管道，使用来自公共数据集的真实图像的纹理。自动流引入了一种简单的方法来呈现随机多边形的运动光流训练。尽管这些数据集很有效，但它们的物体形状的变化仍然有限，视差/光流值的分布也很有限，这削弱了从合成到现实世界的推广能力。
方法 在本节中，将介绍提出的级联立体匹配网络(CREStereo)和新合成数据集
自适应群相关层 作者观察到，很难为现实世界的立体相机实现完美的校准。例如，两个相机可能不会严格放置在水平外极线上，导致在三维空间中轻微旋转；或者相机镜头的图像即使经过修正后也会有残余失真。因此，对于立体图像对，对应的点可能不位于同一扫描线上。因此，作者提出了一种自适应群相关层(AGCL)来减少这种情况下的匹配模糊性，在只计算局部相关的情况下，比全对匹配获得更好的性能。
局部特征注意力：作者不计算每对像素的全局相关性，而是只匹配一个局部窗口中的点，以避免大量的内存消耗和计算成本。针对稀疏特征匹配的LoFTR特征匹配，在级联第一阶段的相关计算之前添加了一个注意模块，以便将全局上下文信息聚合到单个或交叉特征图中。在之后，在主干输出中添加了位置编码，这增强了特征映射的位置依赖性。交替计算自注意和交叉注意，其中使用线性注意层来降低计算复杂度。
2D-1D转换局部搜索：不同于流量估计网络RAFT及其立体版本，其中全对相关性由两个C×H×W特征图的矩阵乘法计算，输出4DH×W×W×W或3DH×W×W成本量，只在一个局部搜索窗口中计算相关性，该窗口输出更小体积的H×W×D，以节省内存和计算成本。H和W表示特征图的高度和宽度，D是相关对的数量远小于W。作者的相关计算也不同于基于成本体积立体网络搜索范围与前景对象的最大位移。这个固定的范围比作者使用的局部相关对的数量要大得多，这导致了更多的噪声干扰。此外，当模型推广到具有不同基线的立体声对时，不需要预设范围。
给定两个重新采样和参与的特征图F1和F2，在位置(x，y)上的局部相关性可记为：
为d-th(d∈[0，D−1])相关对的匹配代价，C为特征通道数， f(d)和g(d)表示当前像素在水平和垂直方向上的固定偏移量。 传统上，在立体匹配中，两个校正图像之间的搜索方向只位于外极线上。为了处理非理想的立体整流情况，我们采用了2D-1D替代局部搜索策略来提高匹配精度。在一维搜索模式下，我们设置g(d)=0和f(d)∈[−r，r]，其中r=4。保留f(d)的正位移值，以便在每次迭代采样后调整不准确的结果。由等式计算的结果1被堆叠并连接在通道维度上，以获得最终的相关V。在二维搜索模式中，使用与扩张卷积相似的k×k网格进行相关计算。设置了k=√2r+1来确保特征具有相同数量的通道，因此它们可以被输入到一个共享权重的更新块中。与迭代重采样合作，交替局部搜索也作为循环细化的传播模块，其中网络学习用其更准确的邻居替换对当前位置的有偏预测。
可变形的搜索窗口：立体匹配经常存在遮挡或无文本区域。在一个固定形状的局部搜索窗口中计算的相关性往往容易受到这些情况的影响。将可变形卷积扩展到相关计算中，使用内容自适应搜索窗口来生成相关对，这与AANet不同，后者仅在成本聚合中采用类似的策略。利用学习到的附加偏移量dx和dy，新的相关性可以计算为
偏移量如何改变传统搜索窗口的形式 自适应局部相关的说明。 顶部和底部分别是2D和1D情况，它们共享相同数量的搜索邻居，产生相同形状的相关图。 Group-wise相关性：受引入组级4D代价体积的启发，我们将特征图分成G组，分别计算局部相关性。最后，我们将G相关体积串联起来。在通道维度上的D × H × W，得到GD × H × W的输出量。过程如图。
级联的网络 对于非纹理或重复纹理区域，由于接受域大、语义信息充足，使用低分辨率和高级特征映射进行匹配更加鲁棒。 然而，在这种特征图中，精细结构的细节可能会丢失。为了保持鲁棒性，同时保留高分辨率输入中的细节，作者提出了级联迭代精化的相关计算和视差更新。 循环更新模块：我们基于GRU块和自适应组相关层(AGCL)构建了循环更新模块(RUM)。与PAFT不同的是，特征金字塔构建在单个相关层中，输出合并为一个卷，我们分别计算每个特征映射在不同级联级别的相关性，并单独细化几个迭代的视差。“sampler”以fn导出的坐标网格为输入，对分组特征的位置进行采样。{f1,…， fn}为初始化f0的n次迭代的中间预测。电流相关体积由学习到的偏移量o∈R2×(2r+1)×h×w构造。GRU块更新当前预测并在下一次迭代时反馈给AGCL。 级联改进：除了级联的第一级(从输入分辨率的1/16开始，视差初始化为所有0)，其他级别将从前一级的预测的上采样版本作为初始化。虽然处理不同层次的细化，所有RUMs的重量相同。在最后一级细化后，进行凸上采样，得到输入分辨率下的最终预测结果。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3e8d40b752af9f5168c63cf948825f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54d9ec5ec2a488809647737a729bbb1a/" rel="bookmark">
			Linux基础知识笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		韩顺平2021Linux课程，视频地址：【小白入门 通俗易懂】2021韩顺平 一周学会Linux_哔哩哔哩_bilibili
文章目录 Linux 基础知识
目录结构（一切皆为文件）
vim的使用
关机&amp;重启命令
用户管理
指定运行级别
帮助指令
文件目录类
时间日期类
搜索查找类
压缩和解压缩
组权限和权限管理
crond任务调度
磁盘分区，挂载
网络配置
进程管理
服务管理
包管理工具
系统设置
Shell脚本
Linux运维知识
日志
备份与恢复
Linux 可视化管理
Linux面试题
统计访问量和连接数
找回Mysql root密码
访问量排名和tcpdump
系统权限划分
ssh连接虚拟机
Linux 基础知识 目录结构（一切皆为文件） 常用：
/bin （/usr /bin,/usr/local/bin） ：存放常用命令。
/home ：存放普通用户的主目录。
/root ：系统管理员主目录。
/etc ：所有系统管理所需要的配置文件和子目录，比如mysql中的my.conf。
/usr ：用户应用程序都放在该目录，类似windows中的program files。
/boot ：存放启动linux时使用的一些核心文件，包括一些连接文件以及镜像文件 [勿动]。
/media ：linux会自动识别一些设备，例如U盘，识别后，将识别的设备挂载到该目录。
/mnt ：系统提供该目录是为了让用户临时挂载别的文件系统，可以把外部的存储挂载在/mnt/上，然后进入该目录查看内容，如虚拟机与主机共享的文件夹。
/usr/local：用户级的程序目录，可以理解为C:/Progrem Files/。用户自己编译的软件默认会安装到这个目录下。
/usr/src：系统级的源码目录。
/usr/local/src：用户级的源码目录。
/var ：存放不断扩充修改的文件，包括各种日志文件。
了解：
/opt ：给主机额外安装软件所摆放的目录，如安装oracle数据库就可放到该目录，默认为空。可以理解为D:/Software，opt有可选的意思，当你不需要时，直接rm -rf掉即可。在硬盘容量不够时，也可将/opt单独挂载到其他磁盘上使用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/54d9ec5ec2a488809647737a729bbb1a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a05ea30e882106eb252d2e77653d988e/" rel="bookmark">
			CSDN开发者云平台体验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CSDN开发者云平台体验 一、CSDN开发云基本信息1.1 官网1.2 控制台1.3 帮助文档 二、功能体验2.1 产品2.2 最新活动2.3 备案2.4 工单2.5 平台的使用2.6 端口映射2.7 路由 三、体验总结四、参与入口 一、CSDN开发云基本信息 1.1 官网 CSDN开发者云平台官网：https://dev.csdn.net
官网一上来就是产品，其价格嘛，哈哈自己比较体会一下。 如果你有相当码龄的话，弄一个基础版玩一下应该还不错的。
1.2 控制台 从上图可见，CSDN开发者云平台控制的控制台相比阿里云等要简单一下，网址是：https://mydev.csdn.net/index
1.3 帮助文档 CSDN开发者云平台像其他得产品一样，也提供了帮助手册，网址是：https://dev-docs.csdn.net
二、功能体验 2.1 产品 CSDN开发云提供的主要产品，其中主要分为计算、数据库、储存、网络、负载均衡、网站服务六种产品。
分类服务计算云主机、云容器数据库MySQL、PostgreSQL、Redis存储对象存储、云磁盘网络虚拟网络（VPC）、负载均衡、弹性IP网站服务备案 从产品上来看，缺少了域名，让人有点遗憾
2.2 最新活动 CSDN 码龄抵现金：可通过码龄兑换优惠，本人账号13年码龄，兑换折扣 1.1 折
单单分成：给CSDN推广产品能会的一定佣金
2.3 备案 为什么要备案？
根据《非经营性互联网信息服务备案管理办法》，在中华人民共和国境内提供非经营性互联网信息服务，应当办理备案。未经备案，不得在中华人民共和国境内从事非经营性互联网信息服务。而对于没有备案的网站将予以罚款和关闭。
比如：本人购买了CSDN的云主机，又从阿里云沟通了一个域名，我想在云主机中搭建一个博客或者网站，那么我就需要进行备案。
有备案需求的可在平台中进行备案。 不得不再提一嘴，平台不提供域名购买实在是遗憾。
2.4 工单 如果在产品使用过程中遇到了问题，可以提工单，平台会安排技术人员来处理。
2.5 平台的使用 平台比较简单，根据新手指引就可以完成，需要创建项目和资源。 不过不创建也可以，平台已经给初始化了一个项目，直接切换至 “云主机” 面便就可以直接用
2.6 端口映射 什么是服务器端口？
例如我们常见的服务器端口有：80端口、443端口、21端口等等，只有当这些服务器的端口开启才能给我们提供服务，像我们平时访问富贵论坛www.fgba.net，就需要对方服务器80端口的开启，如果对方不开启的话则无法访问。
懂得同学都懂，服务器必须开放端口，外部才能访问里面的服务。 CSDN自带一个安全组，可进行端口配置，默认开放了 1-65535 端口。 为了示范效果，在我的CSDN云主机中配置了一个 9000 端口给 Portainer。
通过服务器IP + 端口9000，如：http://http://114.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a05ea30e882106eb252d2e77653d988e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a63c8cf6b32ea723f049d07f83b0a4a/" rel="bookmark">
			五子棋人机对战完整代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前些天发现了一个巨牛的人工智能学习网站，通俗易懂，风趣幽默，忍不住分享一下给大家：点击跳转
目录
〇，前言
一，五子棋棋盘
二，五子棋比赛规则
1，行棋顺序
2，判断胜负
三，重要棋型解释
1，五连
2，活四
3，冲四
4，活三
四，禁手规则
1，三三禁手
2，四四禁手
3，长连禁手
五，代码解释
1，棋子表示
2，棋盘表示
3，flat技术
4，棋型判断和禁手判断
4.1 活四
4.2 冲四
4.3 活3
5，AI算法
6，AI的打分机制
7，搜索剪枝
8，棋谱和禁手调试
六，代码
〇，前言 本文代码修改了数次，但是只保留了有代表性的V201912和V202001，版本名是“年+月”。
本来是帮一个朋友写的作业，结果自从博客发表之后，我发现每隔一段时间，这篇博客就有挺多人看。
其中还有几个人加了我QQ或微信，我一问，全都是要交作业的大学生。
唉，当代大学生啊。
一，五子棋棋盘 棋盘正中一点为“天元”。棋盘两端的横线称端线。棋盘左右最外边的两条纵线称边线。从两条端线和两条边线向正中发展而纵横交叉在第四条线形成的四个点称为“星”。
以持黑方为准，棋盘上的纵轴线从左到右用英文字母A~O标记。横行线从近到远用阿拉伯数字1~15标记。纵横轴上的横纵线交叉点分别用横纵线标记的名称合写成。如“天元”H8，四个“星”分别为D4、D12、L12、L4等。
二，五子棋比赛规则 1，行棋顺序 黑先、白后，从天元开始相互顺序落子。
2，判断胜负 最先在棋盘横向、竖向、斜向形成连续的相同色五个棋子的一方为胜。
黑棋禁手判负，白棋无禁手。黑棋禁手包括三三禁手，四四禁手，长连禁手。
如分不出胜负，则定为平局。
三，重要棋型解释 1，五连 五颗同色棋子连在一起，
即4个方向的11111这种形式的棋型。
2，活四 有2个成五点的四颗棋子，
即4个方向的011110这种形式的棋型，注意两边一定要有空格。
3，冲四 有1个成五点的四颗棋子，棋型有点多。
4，活三 可以形成活四的三颗棋子，
要么是三连的形式，即4个方向的01110这种形式的棋型
要么是非三连的形式，即8个方向的010110这种形式的棋型
PS：这个三连描述的不准确，在01110的两端，必须至少有一个空格。
四，禁手规则 1，三三禁手 由于黑方落一子，同时形成二个或二个以上黑方活三的局面
2，四四禁手 由于黑方落一子，同时形成二个或二个以上黑方四（活四或者冲四）的局面
3，长连禁手 由于黑方落一子，形成六个或者六个以上的同色连续棋子
五，代码解释 1，棋子表示 为了使自已与对手看得更清楚，刚落下的子区别表示，
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a63c8cf6b32ea723f049d07f83b0a4a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3a557b19996e5315a125778364cc2b4/" rel="bookmark">
			Windows版的Nginx服务的启动和停止命令重新载入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前后端分离项目开发的时候可能会用到nginx，因为静态文件可能部署在不同机器或者端口下，需要了解一下nginx的一些常见命令：
1.首先保证执行命令的路径，是在Nginx的安装目录的第一层目录下，如图：
2.启动 start nginx
D:\nginx-1.21.5&gt;start nginx
3.停止 nginx -s stop/nginx -s quit
D:\nginx-1.21.5&gt;nginx -s stop
D:\nginx-1.21.5&gt;nginx -s quit
注：stop是快速停止nginx，可能并不保存相关信息；quit是完整有序的停止nginx，并保存相关信息。
4.重新载入Nginx：nginx -s reload
当修改配置信息conf文件夹中的nginx.conf文件信息时，需要重新载入这些配置时使用此命令
D:\nginx-1.21.5&gt;nginx -s reload
5.重新打开日志文件：nginx -s reopen
D:\nginx-1.21.5&gt;nginx -s reopen
6.查看Nginx版本：nginx -v
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0f4ba0cd818c6b96d37a8cf4914ef90/" rel="bookmark">
			从Oracle日志解析学习数据库内核原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 不管现阶段美国和中国对峙到何种程度，不管桀傲不驯拉里.埃里森如何不看好中国，Oracle 仍是数据库中的一枝独秀。然而，他山之石可以攻玉，多个国产数据库在关键技术攻关方面的整体水平也已达到国际先进。
国内越来越多的 Oracle 数据库开始下线，迁移到开源或者国产数据上，o2k 支持实时增量的将 Oracle 数据库增量变化抽取出来，助力国产化数据库无缝接管 Oracle。
笔者作为数据库内核的负责人参与实现了 o2k 来解析 Oracle 日志，并于 2022 年 2 月 15 号把它开放出来给社区免费使用，期间经历了各种迷茫，获得了众多大佬的指导，最终总算是交出了一份还算不错的试卷。
作为一个 DBA 兼开发人员，在整个 o2k 的实现过程中，对于 Oracle 数据库的数据库理论和工程能力学习了很多，也进一步对数据库原理有了进一步了解。
借助 Oracle 的设计理念和实现，我们也看看是否能对新一代的数据库从业者有一定的帮助和借鉴作用。
国内软件由于美国的打压，数据库作为基础软件赢来了一个难得的蓬勃发展期。
曾几何时，数据库从业人员只是公司 IT 团队-&gt;运维团队里的一个小小部门，而今一个能指导开发正确使用数据库，选择数据库来适配业务来适应业务的数据架构师供不应求。
如果能掌握着数据库原理，甚至能主动改造数据库适配相关应用场景的人才年薪至少百万。
作为计算机皇冠上的其中一粒明珠，数据库上承业务在线离线之责，下接硬件内核之妙，看到越来越多的人才加入数据库及数据库内核队伍，不胜欣慰！
本系列文章中我们将由浅入深以 Oracle 日志解析遇到的重重阻塞为例，来介绍在数据库中常见，而又关键的概念，了解数据库设计思路及工程实现中需要注意的事项。
本文以浅为主，我们先简单介绍一下数据库的背景和 Oracle 日志解析的基础知识
前置知识了解 数据库日志 类似于银行账户系统一样，张三存入 100 块钱会'先'被记录为'张三增加 100'的流水账，然后再把张三的账户从 1000 块修改为 1100 块。 数据库为了保证原子性和持久化，也会'先'在 redo 日志中记录一笔或者多笔 redo record，然后再修改数据库实际的行记录 注意，这里的“修改账户/修改行记录”都是在“写流水账/写日志”之后完成的。也就是说 redo 先于“数据写入”，这也就是著名的数据库 write-ahead logging (WAL) 。 Oracle 写数据库日志采用的是物理日志方式，记录的是内部数据块的变化；MySQL 在 Server 层的 binlog 是逻辑日志，记录的是逻辑行数据的变化。所以对 Oracle 的日志解析不仅需要理解日志本身 filespace、redo record，change vector 的变化，还需要理解 Oracle 内部数据存储的格式。 怎么查看 Oracle 日志中记录的内容 Oracle 中有专门的命令，支持将指定的二进制 redo 日志解析为逻辑的文本文件，类似于 MySQL 提供的 mysqlbinlog 工具，方便用户查看和诊断数据库问题。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e0f4ba0cd818c6b96d37a8cf4914ef90/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/255/">«</a>
	<span class="pagination__item pagination__item--current">256/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/257/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>