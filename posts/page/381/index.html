<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ade351bcff1b948f8da05f2f46f52919/" rel="bookmark">
			mysql班级学生 一对多怎样设计表_MySQL的多表设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、外键约束
保证数据的完整性。
定义外键约束：可以直接在create语句中定义外键
foreign key 当前表名(字段名) references 目标表名(目标表的主键)创建完语句后，可以直接使用修改语句定义
alter table 表名 add foreign key 当前表名 (字段名) references 目标表名(目标表的主键)
二、多表设计的三种实体关系
多对多、一对多和一对一
三、多表设计之---------一对多
一个班级可以有多个学生，但是一个学生只能属于一个班级。或者一个部门有多个员工，而一个员工属于多个部门。这些都是一对多的关系，那么一对多在数据库的设计是怎么实现的。
部门表create table dept(
deptId int primary key auto_increment,
dname varchar(32) not null
);
员工表create table emp(
empId int primary key auto_increment,
ename varchar(32) not null,
age int ,
dno int ,
constraint fk_dno foreign key emp(dno) references dept(deptId)
);
四、多表设计之---------多对多
一个学生可以选择多门课程，而每一门课程也可以被多个学生所选择。这就是典型的多对多的关系。
多对多的建表原则：
需要创建第三方表，该表中至少有两个字段，作为外键分别指向多对多的双方的主键。
本文出自 “11831428” 博客，请务必保留此出处http://11841428.blog.51cto.com/11831428/1909339
MySQL的多表设计
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ade351bcff1b948f8da05f2f46f52919/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/944798f9a6bcca7c4aeea1a46da57527/" rel="bookmark">
			Java中if语句的形式_java中if语句有哪些形式和用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		形式一：if语句
if语句是指如果满足某种条件，就进行某种处理。例如，小明妈妈跟小明说“如果你考试得了100分，星期日就带你去游乐场玩”。这句话可以通过下面的一段伪代码来描述。
如果小明考试得了100分
妈妈星期日带小明去游乐场
在上面的伪代码中，“如果”相当于Java中的关键字if，“小明考试得了100分”是判断条件，需要用()括起来，“妈妈星期日带小明去游乐场”是执行语句，需要放在{}中。修改后的伪代码如下:if(小明考试得了100分){
妈妈星期日带小明去游乐场
}
上面的例子就描述了语句的用法，在Java中，if语句的具体语法格式如下:if(条件语句){
代码块
}
上述格式中，判断条件是一个布尔值，当判断条件为true时，{}中的执行语句才会执行。
形式二：if…else语句
if…else语句是指如果满足某种条件，就进行某种处理，否则就进行另一种处理。例如，要判断一个正整数的奇偶，如果该数字能被2整除则是一个偶数，否则该数字就是一个奇数。if…else语句具体语法格式如下:if(判断条件){
执行语句1
}else{
执行语句2
}
上述格式中，判断条件是一个布尔值。当判断条件为ture时，后面中的执行语句1会执行。当判断条件为 false时，else后面{}中的执行语句2会执行。
形式三：if…else if…else语句
if…else if…else语句用于对多个条件进行判断，进行多种不同的处理。例如，对1个学生的考试成绩进行等级的划分，如果分数大于80分等级为优，否则，如果分数大于70分等级为良，否则，如果分数大于60分等级为中，否则，等级为差。if…else if…else语句具体语法格式如下:if(判断条件1){
执行语句1
}
else if(判断条件2){
执行语句2
}
…
else if(判断条件n){
执行语句n
}else{
执行语句n+1
}
上述格式中，判断条件是一个布尔值。当判断条件1为true时，后面{}中的执行语句1会执行。当判断条件1为 false时，会继续执行判断条件2，如果为true则执行句2，依此类推，如果所有的判断条件都为 false，则意味着所有条件均未满足，else后面{中的执行语句n+1会执行。
推荐教程：java入门教程
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/770830b64e999752c4caa1c1c1620840/" rel="bookmark">
			怎么运行java web_Web容器启动过程中如何执行Java类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.监听(Listener)
com.xian.jdbc.GetProperties
package com.xian.jdbc;
public class GetProperties{
} //implements ServletContextListener
可实现servlet的监听则启动中直接运行输出。不实现也有作用。。未知
2.spring初始化bean时
1、在需要进行操作的bean的xml定义中加上init-method属性，指定下启动时运行哪个方法；
2、实现InitializingBean接口，Spring在启动时会自动调用这个接口中的初始化方法
public class SysInitBean implements InitializingBean,ServletContextAware{public void afterPropertiesSet() throws Exception {//初始化代码 }} 实现InitializingBean接口就可以获取spring的所有配置信息。
实现ServletContextAware，可以获得servletcontext
3.servlet的init()方法
自动执行servlet
写一个servlet，在init()方法中写好想要执行的程序，
同时，在web.xml配置文件中指出
XXXX
XXXX
1
load-on-startup的值必须为整数，当load-on-startup值为负整数或者未指定时，容器在该servlet被调用时加载
当其值为0和正整数时，容器启动时加载，值越小，优先级越高
Web.xml加载顺序：
1 、启动一个 WEB 项目的时候， WEB 容器会去读取它的配置文件 web.xml ，读取 和 两个结点。
2 、紧急着，容创建一个 ServletContext ( servlet 上下文)，这个 web 项目的所有部分都将共享这个上下文。
3 、容器将 转换为键值对，并交给 servletContext 。
4 、容器创建 中的类实例，创建监听器。
由此，可以看出， web.xml 的加载顺序是： context-param -&gt; listener -&gt; filter -&gt; servlet ，而同个类型之间的实际程序调用的时候的顺序是根据对应的 mapping 的顺序进行调用的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/770830b64e999752c4caa1c1c1620840/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6ad825ad73800367a19037c7e0b7489/" rel="bookmark">
			java报错505_报错505是要怎么处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		020-04-07 20:57:58.584 [http-nio-8080-exec-8] WARN o.s.web.context.support.XmlWebApplicationContext - Exception encountered during context initialization - cancelling refresh attempt: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter': Instantiation of bean failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter]: Constructor threw exception; nested exception is java.lang.NoClassDefFoundError: com/fasterxml/jackson/databind/exc/InvalidDefinitionException
2020-04-07 20:57:58.591 [http-nio-8080-exec-8] ERROR org.springframework.web.servlet.DispatcherServlet - Context initialization failed
org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter': Instantiation of bean failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c6ad825ad73800367a19037c7e0b7489/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0eb3e469879dcd38b94aa5650dc62ade/" rel="bookmark">
			mysql数据库旅游管理系统_JSP&#43;MySQL基于ssm的旅游管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本旅游管理系统主要包括系统用户管理模块、景点信息管理模块、变幻图管理、旅游线路管理、登录模块、和退出模块等多个模块。它帮助旅游管理实现了信息化、网络化，通过测试，实现了系统设计目标，相比传统的管理模式，本系统合理的利用了旅游管理数据资源，有效的减少了旅游管理的经济投入，大大提高了旅游管理的效率。
SSM旅游网站前台部分界面
SSM旅游网站后台部分界面
系统功能结构图
本系统主要包含了等系统用户管理、景点信息管理、新闻管理、公告文章管理多个功能模块。下面分别简单阐述一下这几个功能模块需求。
管理员的登录模块：管理员登录系统对本系统其他管理模块进行管理。
用户的登录模块：用户登录本系统，对个人的信息等进行查询，操作可使用的功能。
用户注册模块：游客用户可以进行用户注册，系统会反馈是否注册成功。
添加管理员模块：向本系统中添加更多的管理人员，管理员包括普通管理员和超级管理员。
景点信息管理模块：
景点信息列表：将数据库的景点信息表以列表的形式呈现给管理员。
添加景点信息：实现管理员添加景点信息。
修改景点信息：实现管理员修改景点信息。
公告文章管理模块：
公告文章列表：将数据库的公告文章表以列表的形式呈现给管理员。
添加公告文章：实现管理员添加公告文章。
修改公告文章：实现管理员修改公告文章。
旅游线路管理模块：
旅游线路列表：显示系统的所有旅游线路，可以通过关键字查询。
旅游线路删除：对输入错误或过期的旅游线路删除。
变幻图管理模块：
变幻图列表：显示系统的所有变幻图，可以通过关键字查询。
变幻图删除：对输入错误或过期的变幻图删除。
用户模块：
资料管理：用户登录本系统。可以对自己的个人主页进行查看。
系统信息：用户可以查看自己的系统提示信息。
修改资料：用户可以修改自己的账号密码。
信息搜索：用户可以通过关键字搜索站内信息。
密码修改：用户可以修改个人登录密码。
系统管理模块：包括数据备份。
退出模块：
管理员退出：管理员用来退出系统。
用户退出：用户用来退出系统。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e1cf9eae6fddf51953b69214c2f0678/" rel="bookmark">
			java 后台自动刷新请求_Java Web 开发 (6) servlet 状态持续与自动刷新
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		笨老肥 - 最后修改时间：2009-11-26
点击这里，了解：安装
JDK、Tomcat、中文编码问题(这里涉及的所有源文件及 Tomcat 均采用 utf-8 编码)
点击这里，了解：简单配置
Tomcat、servlet 模版、如何运行 servlet
点击这里，了解：用于各例程的
servlet 工具类 ServletUtil.java
一、处理耗时较长的任务
如果 servlet 或 JSP 页面执行一项耗时较长的计算任务：比如说
20
秒或者更多。在这种情况下，完成计算后再将结果发送给用户是不合理的，到了那时客户可能已经放弃，并离开该页面，或者更坏，用户可能单击“刷新”按钮重新开始了计算过程。为了处理耗时较长的请求，需要下面这些功能：
一种跨请求存储数据的方式。
对于不专属于任意客户的数据，可以将其存储在 servlet 的字段(实例变量)中。对于用户专属的数据，可以将其存储在
HttpSession 对象中。对于其他 servlet 和 JSP 页面需要用到的数据，可以将它存储在 ServletContext
中。
一种在请求发送给用户之后，保持运算继续进行的方式。
这个任务比较简单：只需启动一个线程(thread)。系统为了应答请求而启动的线程，在响应完成之后自动结束，但其他的线程会保持运行。惟一的细微差别是：要将线程的优先级别设为一个较低的值，这样才不致于影响整个服务器的运行。
一种在更新的结果就绪后，使浏览器得到它的方式。
遗憾的是，由于浏览器并不维护一个与服务器之间的保持打开的连接，所以，服务器要想将新的结果主动地发送给浏览器并不容易。取而代之，应该指示浏览器请求更新。这就是
Refresh 响应报头的用途。
二、例程
下面给出一个具体例子，它可以提供由一些较大的、随机选定的质数构成的列表。大质数是大多数公钥密码系统，以及用在
Web 上的加密系统(例如在 SSL 和 X.509
证书中的应用)的关键。对于很大的数字(例如100位)，寻找质数可能要花费一些时间。因此，这个 servlet
立即返回初始的结果，但其后会继续计算，并使用低优先级的线程，从而不会降低 Web
服务器的性能。如果计算尚未完成，服务器就会通过向浏览器发送 Refresh 报头，指示浏览器几秒钟后请求新的页面。
下面的例程阐明了三个有价值的
servlet 功能：
HTTP 响应报头(在这种情况下为Refresh)的价值；
同一 servlet
可以处理多个同时发生的连接，每个连接都有自己的线程。因而，当一个线程正在忙于完成客户的计算时，其他客户能够连接上来，且依旧可以看到局部的结果。
对于 servlet 来说，跨请求维护状态是多么容易，而在大多数竞争技术中，这项功能都比较难以实现(甚至在 .NET
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e1cf9eae6fddf51953b69214c2f0678/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18dcbb6d2cdc64d8564e03c6ecf23cca/" rel="bookmark">
			java中几种注释有什么区别_Java中的/ * * /和/ ** * /注释之间有什么区别？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		多行注释(/ * * /)用于注释源代码中的多行。
示例
public class CommentsExample {
/*
Following is the main method here,
We create a variable named num.
And, print its value
* */
public static void main(String args[]) {
//声明一个名为num的变量
int num = 1;
//打印变量num的值
System.out.println("value if the variable num: "+num);
}
}
输出结果value if the variable num: 1
文档注释(/ ** * /)用于使用Javadoc工具在源代码上生成文档。
示例
/**
* @author Nhooo
*/
public class CommentsExample {
public static void main(String args[]) {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/18dcbb6d2cdc64d8564e03c6ecf23cca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c04060fecd951d3778f2fb79f9c6ddb/" rel="bookmark">
			vue的v-if简单使用，判断对象是否为空
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 场景： vue的一个简单使用，v-if和js中判断非空字符串。
描述： 1）使用v-if、v-show标签
使用v-if取判断的使用是可以直接使用==去跟一个空值对比，当然这样子直接对比是可能存在问题的，然后我也看了网上挺多规避的方法的，我就不去试了。然后这边有一个注意的点是：使用v-if好像不能用 “!=” 这个来进行对比的，会报错，我也不知是什么原因。
&lt;div v-if="pageRespData.totalPage==0"&gt; &lt;span v-if="param==''"&gt;暂时没有数据，快点录入吧&lt;/span&gt; &lt;span v-else&gt;暂时没有检索数据，换个关键词试试&lt;/span&gt; &lt;/div&gt; 顺便简单的记录一下我理解的v-show和v-if的区别：v-show是不符合条件的话，dom元素还在，但是不显示出来；v-if不符合条件的话，是没有dom元素的。像上面的代码段，如果v-if不符合的话，那么就没有那个div元素，使用v-show的话其实是还在的，但是没显示出来。
2）js文件中判断json对象是否为空
这部分我是参考一个文章的，详情可看链接
vue中有两个方法可用：
①将json对象转为json字符串，再判断是否为 “{}”
JSON.stringify(data)=='{}' ②使用
Object.keys(data).length==0 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57175d8fada1933c2778defb1f15b93d/" rel="bookmark">
			vue下载模板时报  vue-cli · Failed to download repo vuejs-templates/webpack: read ECONNRESET
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天在创建新的vue项目时报了这个错误，网上查了很多次，发现都没有什么有效的解决方法。
于是经过多次运行，突然发现居然成功了
据我猜测，可能是网络问题
所以，如果你也出现这个问题，我给出的解决方法就是多试几次，或者换网络再试
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0007216d4f9ace95bec2b60b35e953a/" rel="bookmark">
			微服务注册与发现之Nacos：failed to req API:/nacos/v1/ns/instance after all servers([127.0.0.1:8848])
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 概述 具体错误信息：failed to req API:/nacos/v1/ns/instance after all servers([127.0.0.1:8848]) tried: failed to req API:127.0.0.1:8848/nacos/v1/ns/instance. code:400 msg: caused: cluster name can only have these characters: 0-9a-zA-Z-, current: DEFAULT_GROUP;
二 解决方案 将配置文件中的集群配置注释掉
注释前：
注释后：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2187d0f3bf5d17c7052815963ee8f250/" rel="bookmark">
			java pfx提取私钥加签_java – 如何使用私钥将.pfx文件转换为密钥库？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用JDK 1.6或更高版本
Justin在下面的评论中指出，keytool单独能够使用以下命令(虽然只在JDK 1.6和更高版本中)执行此操作：
keytool -importkeystore -srckeystore mypfxfile.pfx -srcstoretype pkcs12
-destkeystore clientcert.jks -deststoretype JKS
使用JDK 1.5或更低版本
OpenSSL可以做到这一切。 This answer on JGuru是我找到的最好的方法。
首先确保您已安装了OpenSSL。许多操作系统已经安装了，我发现在Mac OS X。
以下两个命令将pfx文件转换为可以作为Java PKCS12密钥存储区打开的格式：
openssl pkcs12 -in mypfxfile.pfx -out mypemfile.pem
openssl pkcs12 -export -in mypemfile.pem -out mykeystore.p12 -name "MyCert"
注意，第二个命令中提供的名称是新密钥存储区中密钥的别名。
您可以使用Java keytool实用程序使用以下命令验证密钥存储区的内容：
keytool -v -list -keystore mykeystore.p12 -storetype pkcs12
最后，如果需要，您可以通过将上面创建的密钥存储导入新的密钥库，将其转换为JKS密钥存储：
keytool -importkeystore -srckeystore mykeystore.p12 -destkeystore clientcert.jks -srcstoretype pkcs12 -deststoretype JKS
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52b32b9cce3b50d363c3340c8178c51a/" rel="bookmark">
			最全JDBC详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言背景一、JDBC是什么？二、JDBC的快速入门1.使用步骤（以mysql为例）2.JDBC各个类详解1.DriverManager驱动管理对象2.Connection数据库连接对象3.Statement执行sql的对象4.ResultSet结果集对象5.PrepareStatement执行sql的对象(更加强大） 三、JDBC管理事务四、数据库连接池1. c3p0的使用2. druid的使用 五、JDBCTemplate总结 前言 本文是对于JDBC的一个详解，篇幅可能过长，但是读这篇文章，一定要从头读，本文讲的是一个过程，会分析一些比较重要的点，在最后，会告诉大家，最终JDBC到底怎么用。
背景 作为一个Java程序员，我们通过Java代码来操作数据库，而数据库有很多种，像Mysql，Oracle，DB2等。如果我们每次使用Java来操作不同数据库，都需要写一套Java代码，会非常的麻烦。 这时候我们就期望，能够使用统一的一套Java代码来操作所有的关系型数据库。这个愿景是非常美好，这时候SUN公司就写这样的一套Java代码——JDBC。
JDBC:定义了一套操作所有关系型数据库的规则（接口），可以来操作不同的数据库，而且操作的方式是一模一样的。那么接口怎么操作数据库呢？或者说接口怎么去写代码，我们以前都需要实现类的啊！你看的没错SUN公司仅仅只定义了接口，没有定义实现类。它要求每个不同的数据库厂商写自己的实习类，这些实现类就可以操作他们自己的数据库。每个实现类都实现了相同的一套JDBC接口，将来我们在写代码的时候，只需要接口的调用，而具体的实现类是每一个不同的公司实现的，这些实现类可以操作不同的数据库，也被称为数据库驱动。 一、JDBC是什么？ 概念：Java DataBase Connectivity Java 数据库连接， Java语言操作数据库。
JDBC本质：其实是官方（sun公司）定义的一套操作所有关系型数据库的规则，即接口。各个数据库厂商去实现这套接口，提供数据库驱动jar包。我们可以使用这套接口（JDBC）编程，真正执行的代码是驱动jar包中的实现类。
二、JDBC的快速入门 1.使用步骤（以mysql为例） 导入驱动jar包 mysql-connector-java-5.1.37-bin.jar。
（1）新建libs目录，复制mysql-connector-java-5.1.37-bin.jar到项目的libs目录下。
（2）右键–&gt;Add As Library。注册驱动（让程序知道用的到底是哪一个驱动包）。获取数据库连接对象 Connection（本地Java代码和数据库的桥梁对象）。定义sql语句。获取执行sql语句的对象 Statement。执行sql，接受返回结果。处理结果。释放资源。 代码如下（示例）：
public class JdbcDemo1 { public static void main(String[] args) throws Exception { //1. 导入驱动jar包 //2.注册驱动 Class.forName("com.mysql.jdbc.Driver"); //3.获取数据库连接对象 Connection conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/db3", "root", "root"); //4.定义sql语句 String sql = "update account set balance = 2000 where id = 1"; //5.获取执行sql的对象 Statement Statement stmt = conn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/52b32b9cce3b50d363c3340c8178c51a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9b890350f5b790c200095f7e84de230/" rel="bookmark">
			excel如何取消访问打印机，总是卡一下。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		坑
设备管理中，把打印机相关的驱动都给卸载了就可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4936beabc0c4a90c2773b19233c449d/" rel="bookmark">
			mysql 计算信度_解析组合信度CR、AVE值如何计算_组合信度cr
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解析组合信度CR、AVE值如何计算
提取了几个公因子后，如何计算这些公因子的组合信度和AVE值呢？
网上查了一下，终于找到答案了，为大家分享下——软件下载：》》组合信度执行文件.rar
AVE= Σλ2/ n, 其中λ指某因子分析时每道题的的因子负荷(loading)，n指题目数目。
1.你可以将数据转到Excel文件中，然后用上述公式，
2.或者像3楼建议的使用吴明隆老师的软件，只要输入每道题的因子负荷值，它会自动生成AVE值还有另外一个组合信度值。
3.实在还是不明白，可以参考吴老师的《AMOS的应用–结构方程与模型》或者荣泰生老师的《AMOS与研究方法》里面都有介绍计算这两个值的数学公式。
我所给出的AVE的计算公式是基于Hair et al.(2006)等学者所编的Multivariate Data Analysis一书。
其实该公式与吴明隆老师所给的公式并不矛盾。当你把分母[(Σλ2)+Σ(1-R2)]代入相应的值计算，最后分母所得的结果其实就是题目的数目。敬请查正！
另外，楼主所言的组合信度用C.R表示也不无道理，请也参考Hair et al.(2006一书，其原文的翻译是”Construct Reliability”或“Composite Reliability”。而你所说的”C.R是临界比”也没错，不过那主要是在AMOS的结果报表中出现，即“Critical Ratio”的简称。
正确计算公式：
(L1+…Lk)**2/[(L1+…Lk)**2+(Var(E1)+…+Var(Ek))]
where
Li= the standardized factor loadings for the
factor
Var(Ei)=the error variance associated with the
individual indicator variables.
喜欢 (4)or分享 (0)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6262db94b6e0cde92a944cb0f7eef371/" rel="bookmark">
			详解STL中关于bitset的使用方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		bitset是一种内含bit或bool值且大小固定的数组，其大小由初始化的值决定。
bitset相比于vector的优点在于节省空间，而且只提供0和1的设置操作，当我们统计某项任务是否完成或某一项是否为true的时候，可以使用bitset来满足需求。
当我们需要按位操作的时候，也可以使用bitset来进行实现。
本文介绍bitset容器的一系列成员函数与基本操作使用
以下是代码实现：
#define _CRT_SECURE_NO_WARNINGS #include &lt;iostream&gt; #include &lt;bitset&gt; using namespace std; int main() { // 初始化10个bit位， 0000000000 bitset&lt;10&gt; b;	// b.set(): 设置第0位为true, 0000000001 b.set(0);	// b.set(): 设置第9位为true, 1000000001 b.set(9);	// 注意 b.set() 不能越界，否则在运行期间会中断程序 // b.set(11); // 结果输出为二进制形式：1000000001 cout &lt;&lt; "b = " &lt;&lt; b &lt;&lt; endl; // b.to_string(): 转换为字符串 cout &lt;&lt; "s = " &lt;&lt; b.to_string() &lt;&lt; endl; // b.to_ulong(): 转化为 unsigned long 类型, 二进制转为十进制 cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6262db94b6e0cde92a944cb0f7eef371/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3b52345855af42b01ba8dd53d213958/" rel="bookmark">
			mysql 数据库编码怎么看_mysql如何查看数据库编码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文内容：本文介绍了在控制台下，使用命令的方式查看mysql数据库的编码。
1.首先连接数据库。
在cmd下输入
&gt;mysql -h 数据库地址 -u 用户名 -p密码
2.连接数据库完成后
使用status命令查看数据库的编码方式：
mysql&gt; status;
--------------
C:\Program Files\MySQL\MySQL Server 5.6\bin\mysql.exe Ver 14.14 Distrib 5.6.21,
for Win32 (x86)
Connection id: 1320
Current database:
Current user: rdps@10.118.44.29
SSL: Not in use
Using delimiter: ;
Server version: 5.5.28 MySQL Community Server (GPL)
Protocol version: 10
Connection: 10.118.46.4 via TCP/IP
Server characterset: latin1
Db characterset: latin1
Client characterset: gbk
Conn. characterset: gbk
TCP port: 3306
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3b52345855af42b01ba8dd53d213958/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91b1474eb6221c921dc1b6fc5dc70f0e/" rel="bookmark">
			mysql 小球_c语言编程实例——小球跳动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、预备知识
1.1 相关头文件
“#include”是c语言中用以申明所需调用的库函数或自定义函数的头文件路径及文件名。#include ""和#include &lt;&gt;存在区别，#include "" 当要调用某个函数时先在用户自已编写的文件中查找，如果找不到再到库文件里去找。而#include &lt;&gt; 是直接到库文件里去找，所以如果是调用自己写的函数的话就用#include ""这种形式，而调用标准库函数的话就用#include &lt;&gt; 这种形式，可以提高速度。
1.1.1 stdio.h
这个标准库的头文件定义了用于输入输出的宏和函数。从键盘上读取数据，将输入写入命令行上时，需要包含这个头文件。
1.1.2 stdlib.h
定义了许多一般用途的函数和宏。它包含将字符串转化为数值的函数，生成伪随机数的rand()函数，给数据动态分配和释放内存的函数，搜索和排序例程，整数算数函数，以及转换多字节和宽字节串的函数。
1.1.3 windows.h
系统头文件。
1.2 相关函数与结构
1.2.1 printf
1.2.2 循环结构
c语言有3种用于实现循环结构的语句，分别是for、while(先判断，后循环)和do-while(先循环，后判断)。使用格式如下：
(1)for循环
for(表达式1;表达式2;表达式3)
//表达式1为初值，表达式2为终止条件，表达式3为循环步长
{
//这里是循环体
}
(2)while循环
while(表达式) //表达式即终止循环的条件
{
//这里是循环体
}
(3)do-while循环
do
{
//这里是循环体
}while(表达式)
1.2.3 system("cls")
这是VC环境下的清屏方法，隶属stdlib头文件库，属于调用格式为：
#include system("cls");
1.2.4 Sleep函数
功 能: 执行挂起一段时间
用 法: unsigned sleep(unsigned seconds);
注意:
在VC中使用带上头文件#include ,在Linux下,gcc编译器中，使用的头文件因gcc版本的不同而不同#include ；
在VC中,Sleep中的第一个英文字符为大写的"S" ,在linux下不要大写，在标准C中是sleep, 不要大写，简单的说VC用Sleep, 别的一律使用sleep；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91b1474eb6221c921dc1b6fc5dc70f0e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5853f4153e7aa682181ec58f0450b4c2/" rel="bookmark">
			mysql 如果是1展示a_MySQL8.0 练习1_crraxx的博客-CSDN博客
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文作者：crraxx
原文标题：MySQL8.0 练习1
发布时间：2021-02-21 19:38:35
一,有这样一张学生成绩表如图,按要求完成操作.
1.根据上图格式,在数据库中创建一个学生成绩表,并添加数据.使用sql语句完成.
2.查询每个人的总成绩并按从高到低排名(要求显示字段：姓名，总成绩，学号)
3.查询每个人的平均成绩(要求显示字段: 学号，姓名，平均成绩)
4.查询各门课程的平均成绩(要求显示字段：课程，平均成绩)
5.查询学生数学成绩的排名,从高到低显示(要求显示字段：学号，姓名，成绩
6.查询学生成绩,按照如下格式展示, 小于60分为C,60-79为B,80-100为A
7.只查询每门成绩都及格的学生(要求显示字段: 学号，姓名，课程，最高成绩)
8.查询出选择课程数量大于3的学生(显示学生学号,姓名,课程总数)
-- 1.根据上图格式,在数据库中创建一个学生成绩表,并添加数据.使用sql语句完成.
-- 创建一个学生表
CREATE TABLE t_stu
(stu_num INT,stu_name VARCHAR(15),SUBJECT VARCHAR(15),stu_score INT)
-- 插入数据
INSERT INTO t_stu (stu_num,stu_name,SUBJECT,stu_score)
VALUES (1,"张三","语文",70),(1,"张三","数学",80),(1,"张三","英语",66),
(2,"李四","语文",50),(2,"李四","数学",75),(2,"李四","英语",80),
(3,"王五","语文",77),(3,"王五","数学",55),(3,"王五","英语",88),(3,"王五","物理",90)
-- 2.查询每个人的总成绩并按从高到低排名(要求显示字段：姓名，总成绩，学号)
SELECT stu_name,SUM(stu_score)总成绩,stu_num
FROM t_stu
GROUP BY stu_num
ORDER BY SUM(stu_score) DESC
-- 3.查询每个人的平均成绩(要求显示字段: 学号，姓名，平均成绩)
SELECT stu_num,stu_name,AVG(stu_score)平均成绩
FROM t_stu
GROUP BY stu_num
-- 4.查询各门课程的平均成绩(要求显示字段：课程，平均成绩)
SELECT SUBJECT ,AVG(stu_score)平均成绩
FROM t_stu
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5853f4153e7aa682181ec58f0450b4c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a446a3d97211ecdb0e52abdba3a577f1/" rel="bookmark">
			java语言链栈_Java语言实现数据结构栈代码详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		近来复习数据结构，自己动手实现了栈。栈是一种限制插入和删除只能在一个位置上的表。最基本的操作是进栈和出栈，因此，又被叫作“先进后出”表。
首先了解下栈的概念：
栈是限定仅在表头进行插入和删除操作的线性表。有时又叫LIFO(后进先出表)。要搞清楚这个概念，首先要明白”栈“原来的意思，如此才能把握本质。
"栈“者,存储货物或供旅客住宿的地方,可引申为仓库、中转站，所以引入到计算机领域里，就是指数据暂时存储的地方，所以才有进栈、出栈的说法。
实现方式是这样的：首先定义了一个接口，然后通过这个接口实现了线性栈和链式栈，代码比较简单，如下：
package com.peter.java.dsa.interfaces;
/**
* 栈操作定义
*
* @author Peter Pan
*/
public interface Stack {
/* 判空 */
Boolean isEmpty();
/* 清空栈 */
void clear();
/* 弹栈 */
T pop();
/* 入栈 */
Boolean push(T data);
/* 栈的长度 */
int length();
/* 查看栈顶的元素，但不移除它 */
T peek();
/* 返回对象在栈中的位置 */
int search(T data);
}
线性栈：以数组的方式实现。
package com.peter.java.dsa.common;
import com.peter.java.dsa.interfaces.Stack;
/**
* 线性栈
*
* @author Peter Pan
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a446a3d97211ecdb0e52abdba3a577f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c0a68cfda0d8e4f97ff5ead6764b773/" rel="bookmark">
			vue项目结构及启动文件加载过程分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue项目结构及启动文件加载过程分析 一、vue项目结构 1、导入项目 准备好开发工具Visual Studio Code，导入生成的项目案例。我的Vue版本：
2、项目目录及文件说明 2.1、项目主体结构 目录/文件 说明 build 项目构建(webpack)相关代码 config 配置目录，包括端口号、环境变量等。我们初学可以使用默认的。 node_modules npm 加载的项目依赖模块(根据package.json安装时候生成的的依赖安装包) src 这里是我们要开发的目录，基本上要做的事情都在这个目录里。里面包含了几个目录及文件： assets 脚手架自动会放入一个图片在里面作为初始页面的logo。平常我们使用的时候会在里面建立js，css，img，fonts等文件夹，作为静态资源调用 components 用来存放组件，合理地使用组件可以高效地实现复用等功能，从而更好地开发项目。 router 路由相关的内容。该文件夹下有一个叫index.js文件，用于实现页面的路由跳转 main.js 入口文件，主要作用是初始化vue实例并使用需要的插件，小型项目省略router时可放在该处 App.vue 主组件，可通过使用&lt;router-view/&gt;开放入口让其他的页面组件得以显示。也可以直接将组件写这里，而不使用 components 目录。 static 静态资源目录，如图片、字体等。 .gitkeep git配置。 .babelrc es6解析的一个配置 .editorconfig 编辑器的配置文件 .eslintignore 忽略eslint语法规范检查配置文件 .eslintrc.js eslint（代码格式化检查工具）的配置文件，开启以后要严格遵照它规定的格式进行开发 .gitignore 忽略git提交的一个文件，配置之后提交时将不会加载忽略的文件 .postcssrc.js 文件是postcss-loader包的一个配置 index.html 首页入口文件，经过编译之后的代码将插入到这来。 package.lock.json 锁定安装时的包的版本号，并且需要上传到git，以保证其他人在npm install时大家的依赖能保证一致 package.json 项目配置文件。需要哪些npm包来参与到项目中来，npm install命令根据这个配置文件增减来管理本地的安装包。 README.md 项目的说明文档，markdown 格式 2.2、build目录 目录/文件 说明 build build.js 构建生产版本。package.json中的scripts的build就是node build/build.js，输入命令行npm run build对该文件进行编译生成生产环境的代码。 check-versions.js 用于检测node和npm的版本，实现版本依赖 utils.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c0a68cfda0d8e4f97ff5ead6764b773/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0a2b6da337395ff6ae49c9202abc99b/" rel="bookmark">
			java多线程交替打印abc_华为和阿里都考过的多线程编程题，你会吗？多线程交替打印 ABC的多种实现方法...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述如下：
编写一个程序，开启三个线程，这三个线程的 ID 分别是 A、B 和 C，每个线程把自己的 ID 在屏幕上打印 10 遍，要求输出结果必须按 ABC 的顺序显示，如 ABCABCABC... 依次递推
这是一道经典的多线程编程面试题，首先吐槽一下，这道题的需求很是奇葩，先开启多线程，然后再串行打印 ABC，这不是吃饱了撑的吗？不过既然是道面试题，就不管这些了，其目的在于考察你的多线程编程基础。就这道题，你要是写不出个三四种解法，你都不好意思说你学过多线程。哈哈开玩笑，下面就为你介绍一下本题的几种解法。
1、最简单的方法——使用 LockSupport
LockSupport 是java.util.concurrent.locks包下的工具类，它的静态方法unpark()和park()可以分别实现阻塞当前线程和唤醒指定线程的效果，所以用它解决这样的问题简直是小菜一碟，代码如下：
public class PrintABC {
static Thread threadA, threadB, threadC;
public static void main(String[] args) {
threadA = new Thread(() -&gt; {
for (int i = 0; i &lt; 10; i++) {
// 打印当前线程名称
System.out.print(Thread.currentThread().getName());
// 唤醒下一个线程
LockSupport.unpark(threadB);
// 当前线程阻塞
LockSupport.park();
}
}, "A");
threadB = new Thread(() -&gt; {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0a2b6da337395ff6ae49c9202abc99b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81dcab688caae2245bfea5b878844ee4/" rel="bookmark">
			K8s-----（五）探针的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Pod生命周期 1 探针的介绍2 探针的使用2.1 存活探针的使用2.2 定义HTTP的就绪探测2.3 TCP 的存活探测和就绪检测 3 Init 容器3.1 Init 容器的介绍3.2 Init 容器的作用3.3 Service定义3.4 Init 容器的使用 官方：https://kubernetes.io/zh/docs/concepts/workloads/pods/pod-lifecycle/
1 探针的介绍 探针是由 kubelet 对容器执行的定期诊断:
ExecAction：在容器内执行指定命令。如果命令退出时返回码为 0 则认为诊断成功。 TCPSocketAction：对指定端口上的容器的 IP 地址进行 TCP 检查。如果端口打开，则诊断被认为是成功的。 HTTPGetAction：对指定的端口和路径上的容器的 IP 地址执行 HTTP Get 请求。如果响应的状态码大于等于200 且小于 400，则诊断被认为是成功的。 每次探测都将获得以下三种结果之一：
成功：容器通过了诊断。 失败：容器未通过诊断。 未知：诊断失败，因此不会采取任何行动。 Kubelet 可以选择是否执行在容器上运行的三种探针执行和做出反应：
livenessProbe（存活探针）：指示容器是否正在运行。如果存活探测失败，则 kubelet 会杀死容器，并且容器将受到其 重启策略
的影响。如果容器不提供存活探针，则默认状态为 Success。readinessProbe（就绪探针）：指示容器是否准备好服务请求。如果就绪探测失败，端点控制器将从与 Pod 匹配的所有 Service的端点中删除该 Pod 的 IP 地址。初始延迟之前的就绪状态默认为 Failure。如果容器不提供就绪探针，则默认状态为Success。startupProbe（启动探针）: 指示容器中的应用是否已经启动。如果提供了启动探测(startup probe)，则禁用所有其他探测，直到它成功为止。如果启动探测失败，kubelet将杀死容器，容器服从其重启策略进行重启。如果容器没有提供启动探测，则默认状态为成功Success。 重启策略：PodSpec 中有一个 restartPolicy 字段，可能的值为 Always、OnFailure 和 Never。默认为 Always。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/81dcab688caae2245bfea5b878844ee4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a1451e2e76e02f43f69b0dd99dc28c7/" rel="bookmark">
			ip复原Java_第93题：复原IP地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一． 问题描述
给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。
示例:
输入: "25525511135"
输出: ["255.255.11.135", "255.255.111.35"]
二． 解题思路
本题思路：采用回溯算法进行求解，建立递归函数(全局变量list存储IP地址，局部变量data存储剩下的字符串，length存储当前需要填的位数，数组nums存储ip中各个段的值)
步骤一：建立递归函数，判断，当nums数组最后一位数组满足要求则将数组按照格式要求存储到list中，否则，进入步骤二。
步骤二：进行回溯算法，依次从data中取出数字，判断其是否小于256且大于等于0，则将其添加到nums[length]中，在data中删除该数字，继续递归，返回步骤一。
步骤三：这道题需要注意细节，00，001这种情况和数字的界限问题，所以要考虑周全。
三． 执行结果
执行用时 :3 ms, 在所有 java 提交中击败了89.68%的用户
内存消耗 :36.3 MB, 在所有 java 提交中击败了48.81%的用户
四． Java代码
classSolution {public ListrestoreIpAddresses(String s) {
List list=new ArrayList();int []nums= {-1,-1,-1,-1};
address(list,s,0,nums);returnlist;
}public void address(List list,String data,int length,int[]nums) {if(nums[3]&lt;256&amp;&amp;nums[3]&gt;=0&amp;&amp;data.length()&lt;=0){
String temp="";for(int i=0;i&lt;4;i++) {
temp=temp+nums[i];if(i&lt;3)
temp=temp+".";
}
list.add(temp);
}if(length==4&amp;&amp;data.length()&gt;=4){return;
}
String tem="";for(int j=0;j&lt;3&amp;&amp;j0;j++){
tem=tem+data.charAt(j);int temdata=Integer.parseInt(tem);if(tem.charAt(0)=='0'&amp;&amp;tem.length()&gt;1){continue;
}if(temdata&lt;256&amp;&amp;temdata&gt;=0) {
String getdata=data.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a1451e2e76e02f43f69b0dd99dc28c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93c200da85b8802084e5df10a9e9ff00/" rel="bookmark">
			FileNotFoundError:[Errno 2] No such file or directory :
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		FileNotFoundError:[Errno 2] No such file or directory : 1.根本原因：路径有问题
2.可能的原因：
1）注意Windows与Linux分隔符的区别
Windows下的分割符：\
Linux下的分割符：/
2）如果你是用本地客户机上的pycharm远程连接服务器，可能你在配置Python Interpreter的时候没有勾选Automatically upload project files to the server。
解决方法：通过以下步骤将代码同步到服务器上，否则你修改的只是本地文件。（Tools–Deployment–Automatic Upload；参考PyCharm同步本地项目文件到服务器）
3）如果你是用本地客户机上的pycharm远程连接服务器，还有一个原因：如果你的项目放在了work目录下，当你访问work目录之外的文件时，不要使用相对路径，应该使用绝对路径，否则可能报错。另外，如果你是在work目录下访问work目录内的文件，可以使用相对路径。
（具体请参见你使用的云GPU的文档说明。尤其是与目录有关的文档说明。以featurize为例→目录及作用）
参考文章汇总 windows和linux下的分隔符
java在windows和linux系统中通用的路径符号"//"
python 不同操作系统下(Windows,linux,mac)的路径分隔符,换行符统一的方法
Windows和Linux路径分隔符通用书写方法
PyCharm同步本地项目文件到服务器
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94fe4a969b7c439ba5ecf71d13bfef8b/" rel="bookmark">
			ACM数学板子
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ACM数学（待更新） 0X01 质数 质数判定 试除法 O ( N ) O(\sqrt N) O(N ​) bool is_prime(long long x) { if (x &lt; 2) return false; for (int i = 2; i &lt;= x / i; i ++ )//i*i&lt;=x可能会溢出 if (x % i == 0)return false; return true; } 试除法优化 O ( N / 3 ) O(\sqrt N/3) O(N ​/3) bool is_prime(ll a) { if(a==1)return 0; if(a==2||a==3)return 1; if(a%6!=1&amp;&amp;a%6!=5)return 0; for(int i=5;i&lt;=a/i;i+=6) if(a%i==0||a%(i+2)==0)return 0; return 1; } 质数筛选 线性筛 O ( N ) O(N) O(N) int primes[N], cnt; // primes[]存储所有素数 bool st[N]; // st[x]存储x是否被筛掉，后面可以直接用来判是否为素数 //n只会被最小质因子筛掉 void get_primes(int n) { memset(st,0,sizeof st); st[0]=st[1]=1; for (int i = 2; i &lt;= n; i ++ )//不要忘记等号 { if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94fe4a969b7c439ba5ecf71d13bfef8b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0289d62b88339ae7c0acfd1d7c7447c3/" rel="bookmark">
			java树的查找_Java实现多叉树查找
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 package tree;
2
3 import java.util.List;
4 import java.util.ArrayList;
5 import java.io.Serializable;
6
7 public class TreeNode implements Serializable {
8 private int parentId;
9 private int selfId;
10 protected String nodeName;
11 protected Object obj;
12 protected TreeNode parentNode;
13 protected List childList;
14
15 public TreeNode() {
16 initChildList();
17 }
18
19 public TreeNode(TreeNode parentNode) {
20 this.getParentNode();
21 initChildList();
22 }
23
24 public boolean isLeaf() {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0289d62b88339ae7c0acfd1d7c7447c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7afbdb520b3023dc9a402c8471d5b7de/" rel="bookmark">
			Error-State Kalman Filter理解与公式推导
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 直接法与间接法滤波ESKF公式推导VINS中对于ESKF的使用 直接法与间接法滤波 卡尔曼滤波作为一种贝叶斯滤波的具体实现被广泛应用于状态估计问题中，其优势与特点这里就不再赘述了，而众所周知的是，卡尔曼滤波只能应用于线性系统中，而实际中大部分系统无法满足这个约束，于是诞生了扩展卡尔曼滤波（Extended Kalman Filter，EKF）和误差状态卡尔曼滤波（Error State Kalman Filter，ESKF）等一系列应用于非线性系统的滤波方法，这些方法各有特点，这里主要讨论EKF和ESKF。
EKF和ESKF分别作为直接法滤波和间接法滤波的一种实现，首先需要弄清楚直接法滤波和间接法滤波的区别，这一点秦永元的书1上有详细说明，截图如下：
个人理解其主要区别在于：
1、从理论上来说，精度上直接法应该优于间接法，因为间接法的误差系统方程实际上是推导出来的，并且过程中作了一定近似（例如去掉了所有的二次微分项），虽然完成了系统线性化，但损失了精度；而直接法的系统方程是没有损失的，其精度损失在于在局部点上采用了泰勒一阶近似对系统线性化造成的精度损失，这取决于迭代速度、系统份非线性化程度等多个因素，因此实际工程实践中精度还是取决于使用情况和具体实现。
2、直接法例如EKF在每次迭代都需要计算雅克比矩阵，对于算力要求较高，而间接法在将误差方程线性化后，其雅克比矩阵是固定的，只与当前状态相关。
3、间接法由于每次估计的是状态误差项，其数值差异小，而直接法估计的是系统状态，不同状态项数值差异大，肯能在实际计算中带来误差。
ESKF公式推导 ESKF的核心在于将状态分解为两个部分组成：
X t = X + δ X (1) X_t=X+\delta X\tag1 Xt​=X+δX(1)
其中 X t X_t Xt​为系统状态真值， X X X为Nominal state， δ X \delta X δX为Error state，以下所有公式中均符合这个定义，系统递推方程为：
X k + 1 = f ( X k ) X t , k + 1 = f ( X t , k ) + w k (2) X_{k+1}=f(X_{k})\\[3mm] X_{t,k+1}=f(X_{t,k})+w_k\tag2 Xk+1​=f(Xk​)Xt,k+1​=f(Xt,k​)+wk​(2)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7afbdb520b3023dc9a402c8471d5b7de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa19bdb8161f3bc2c8497ba47613e42d/" rel="bookmark">
			vue-cli3.0 环境变量与模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue-cli3.0 环境变量与模式 vue-cli3.0移除了配置文件目录： config和build文件夹。可以说是非常的精简了，那移除了配置文件目录后如何自定义配置环境变量和模式呢?
为什么需要配置环境变量和模式呢？
所有方法肯定是来源于现实的需求。在一个产品的前端开发过程中，一般来说会经历本地开发、测试脚本、开发自测、测试环境、预上线环境，然后才能正式的发布。对应每一个环境可能都会有所差异，比如说服务器地址、接口地址、websorket地址…… 等等。在各个环境切换的时候，就需要不同的配置参数，所以就可以用环境变量和模式，来方便我们管理。
环境变量
cli-3.0总共提供了四种方式来制定环境变量：
在根目录添加.env文件，配置所有情况下都会用到的配置（不知道这个存在的意义，所有的都需要的也就不需要配置了吧）。
在根目录添加.env.local 文件，配置所有情况下都会用到的配置，与.env的区别是只会在本地，该文件不会被git跟踪。
在根目录添加.env.[mode] 文件，配置对应某个模式下的配置,比如：.env.development来配置开发环境的配置。
在根目录添加.env.[mode].local文件，配置对应某个模式下的配置,与.env.[mode]的区别也只是会在本地生效，该文件不会被git跟踪。
在文件中，我们只需要以key=value的方式就可以设置变量了。
例如：
FOO=bar
VUE_APP_SECRET=secret
环境变量的使用
设置完环境变量之后就可以在我们的项目中使用这两个变量了。不过还需要注意的是在项目的不同地方使用，限制也不一样。
在项目中，也就是src中使用环境变量的话，必须以VUE_APP_开头。例如我们可以在main.js中直接输出：console.log(process.env.VUE_APP_SECRET)
在webpack配置中使用，没什么限制，可以直接通过process.env.XXX来使用
在public/index.html中使用的：分三类：（没怎么用过）
&lt;%= VAR %&gt; 用于非转换插值 例如：&lt;link rel="shortcut icon" href="&lt;%= BASE_URL %&gt;favicon.ico"&gt;
&lt;%- VAR %&gt; 用于HTML转义插值
&lt;% expression %&gt; 用于JavaScript控制流
模式
模式是Vue CLI项目中的一个重要概念。默认情况下，Vue CLI项目中有三种模式：
development：在vue-cli-service serve下，即开发环境使用
production：在vue-cli-service build 和vue-cli-service test:e2e下，即正式环境使用
test： 在vue-cli-service test:unit下使用
另外，如果你想要修改模式下默认的环境变量的话可以通过–mode来实现，例如：
“dev-build”: “vue-cli-service build --mode development”
有环境变量就能完成我们的需求了，为什么需要有模式的存在，这里我没查到详细的文档，个人认为模式是为了提供给第三方的插件一个辨识。例如vuex可以根据模式的不同，在development自动注入devtoolPlugin插件，利于开发，而在production中检测到错误不会进行console。
举例
说完了概念，可能还是比较模糊，可以试着添加一个stage环境，用来模拟预上线。
首先在package.json添加一种类型，并修改默认环境变量为stage环境变量
clipboard.png
在根目录下创建.env.stage文件，来声明变量：
clipboard.png
clipboard.png
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa19bdb8161f3bc2c8497ba47613e42d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d35f851ab66d81e1d144eb8571e5c90c/" rel="bookmark">
			数据结构必会｜二叉树及其遍历（Python）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		二叉树 1. 树的概念 ​ 在数据结构中，树可以看作是一种通过递归生成的数据结构，每棵树只有一个根结点（下图中的A）而其他的结点可以有很多个，树的结构如下图所示：
2. 树的术语 ​ 在树结构中，有很多专业的术语，常见的术语及解释如下：
根结点：A祖先结点：B和K子孙结点：K和B父结点：E和K子结点：K和E兄弟结点：K和L叶子结点：度等于0的节点，F、G等结点的度：树中一个结点的子结点个数，A有3个子结点树的度：结点最大度数 3. 二叉树的定义 ​ 对于每个结点来说最多有两棵子树的树叫做二叉树，二叉树有左右之分，次序不能颠倒。
4. 常见的特殊二叉树 满二叉树：除最后一层无任何子节点外，每一层上的所有结点都有两个子结点的二叉树。
完全二叉树：对于一棵二叉树，假设其深度为d(d&gt;1)。除了第d层外，其他各层的结点数目均已达最大值，且第d层所有结点从左到右的紧密排列。
​ 满二叉树和完全二叉树的结构如下图所示（A为满二叉树，B为完全二叉树，满二叉树也是一种完全二叉树）
二叉树的遍历 1. 常见的二叉树遍历形式 ​ 现有如下的一颗二叉树：
​ 常见的二叉树遍历形式可以分为下列四种：
前序遍历：先访问根节点，然后前序遍历左子树，再前序遍历右子树。 结果：ABDECFG 中序遍历：中序遍历根节点的左子树，然后是访问根节点，最后遍历右子树。 结果：DBEAFCG 后序遍历：从左到右先叶子后节点的方式遍历访问左右子树，最后访问根节点。 结果：DEBFGCA 层次遍历：从根节点从上往下逐层遍历，在同一层，按从左到右的顺序对节点逐个访问。 结果：ABCDEFG 2. 二叉树的实现 ​ 二叉树的构建及一些功能函数的实现方法如下：
# 二叉树类 class BTree(object): # 初始化 def __init__(self, data=None, left=None, right=None): self.data = data # 数据域 self.left = left # 左子树 self.right = right # 右子树 # 前序遍历 def preorder(self): # 根左右 if self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d35f851ab66d81e1d144eb8571e5c90c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e41d7741533d6738bca3d6e3aefa4cbf/" rel="bookmark">
			SHA256算法原理介绍以及实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在学习一些算法加解密方面的知识，之前对SHA256算法不是特别理解，看了许多其他大佬关于SHA256算法的详解和实现过程，终于是稍微理解了一些，真的非常感谢，这里整合了这些材料，写这篇学习笔记的目的是把自己学习SHA256算法的过程记录下来，方便下次查看。当然，如果能给有需要的小伙伴提供一些思路启发自然再好不过。
1.SHA算法概述 SHA（Secure Hash Algorithm安全散列算法）是一个密码散列函数的家族，是FIPS（联邦信息处理标准 Federal Information Processing Standards）
所认证的安全散列算法。能计算出一个数字消息所对应到的，长度固定的字符串（又称消息摘要）的算法。
一个n位的哈希函数就是一个从任意长的消息到n位哈希值的映射，一个n位的加密哈希函数就是一个单向的、避免碰撞的n位哈希函数。这样的函数是目前在数字签名和密码保护当中极为重要的手段。
当前比较流行的哈希函数主要有128位的MD4和MD5和160位（20字节）的SHA-1，今天介绍的SHA-2族有着更多位的输出哈希值，破解难度更大，能够提高更高的安全性。
SHA-2，名称来自于安全散列算法2（英语：Secure Hash Algorithm 2）的缩写，一种密码散列函数算法标准，由美国国家安全局研发，由美国国家标准与技术研究院（NIST）在2001年发布。属于SHA算法之一，是SHA-1的后继者。其下又可再分为六个不同的算法标准，包括了：SHA-224、SHA-256、SHA-384、SHA-512、SHA-512/224、SHA-512/256。
这些变体除了生成摘要的长度 、循环运行的次数等一些微小差异外，算法的基本结构是一致的。
2.SHA256算法简介 说到SHA256，其字面意思便是，对于任意长度的消息，SHA256都会产生一个256位的哈希值，称作消息摘要。这个摘要相当于是个长度为32个字节的数组，共256位，通常由一个长度为64的十六进制字符串来表示，其中1个字节=8位，一个十六进制的字符的长度为4位。
SHA256对消息做Hash摘要，如下实例：
1122334455667788 //消息 该消息经过哈希函数SHA256得到的消息摘要为：
1DCE6604591EFB439D5E87418A1D00DBFD014327D8C4DEA862815714B76AE9A5 //Hash值 这里原来的8字节消息“1122334455667788”经SHA256算法运算后得到一个32字节的消息摘要，且对消息做细小的改变，生成的Hash都会发生巨大改变，跟原先的值完全不同，如下：
0122334455667788 //消息 2B85738907AB2C4C39DFFFDD5328A694F4DF04B75E6F482F832279C6BBFE8530 //Hash值 仅仅变换了一位的值，Hash值发生了巨大的改变。
3.SHA256算法原理细述 为了更好的理解SHA256的原理，这里首先将算法中可以单独抽出的模块，包括常量的初始化、信息预处理、使用到的逻辑运算分别进行介绍，甩开这些理解上的障碍后，一起来探索SHA256算法的主体部分，即消息摘要是如何计算的。
3.1常量初始化 SHA256算法中用到了8个哈希初值以及64个哈希常量，64个哈希常量参与到后面的哈希值计算。
SHA256算法的8个哈希初值为：
H1 := 0x6a09e667 H2 := 0xbb67ae85 H3 := 0x3c6ef372 H4 := 0xa54ff53a H5 := 0x510e527f H6 := 0x9b05688c H7 := 0x1f83d9ab H8 := 0x5be0cd19 初始哈希值H(1-8)取自自然数中前面8个质数(2,3,5,7,11,13,17,19)的平方根的小数部分, 并且取前面的32位. 下面举个例子: [公式]小数部分约为0.414213562373095048, 而其中
于是, 质数2的平方根的小数部分取前32位就对应0x6a09e667。以此类推可得8个初始哈希值。
SHA256算法的64个哈希常量为：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e41d7741533d6738bca3d6e3aefa4cbf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0590b03a51f00e8115864b9c9e080493/" rel="bookmark">
			latex 小于_小于等于 latex
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		小于大于等于 打一字
小于是“小”大于是“大”等于是“二”合起来是“奈”
latex $
TeX提供三种有关数学公式的环境,一种是"文中公式",通过$进入"数学环境",通过$来结束数学环境的;第二种是"独立公式",用$$进入"显示数学环境用$$退出,在正文,它是独占一行的,它排出的字体要稍
pH小于等于pKa
弱酸多于等于其对应的盐
Latex是什么软件
LaTeX(LATEX,音译“拉泰赫”)是一种基于TeX的排版系统,由美国计算机学家莱斯利·兰伯特(LeslieLamport)在20世纪80年代初期开发,利用这种格式,即使使用者没有排版和程序设计的
latex输不出数学公式
\begin{equation}\frac{1}{x}\end{equation}或$\frac{1}{x}$你的代码重复了哎
latex 中 \ra
没有\ra这种东西,只有\r a这表示在a的脑袋顶上增加一个如“.”的空心圆圈符号.也可写做\r{a}但是如果写\r ab或者\r{ab}的话只有第一个字母上有空心圆圈.另外,如果
圆周率大于,小于,等于3.14
3.14159263.1415927再答：之间再答：所以是大于再答：A再问：哦哦，谢谢再答：采纳哦
想问有关LATEX
什么问题?好像你的号在ChinateX里见到过?到这里提问反应很慢的.楼上的使用方法是,野蛮使用TeX的典型,不推荐.还是认真学习基础,用好TeX会让你的学术生活品质上一个台阶的.
latex怎样画流程图
你可以调用Xy-pic宏包,\usepackage[all]{xy}他的基本思想是以像在一个棋盘上对一个个元素进行指定(如一个字母,一个格子),我们也同时可以在元素画线等操作.所以应该能满足对流程图的
小于等于号怎么写
≤.你切换到搜狗输入法,按Ctrl+Shift+B选择数学符号就可以看到了!
小于等于怎么打?
≤用智能ABC然后按v1自己找一下就可以找到
LATEX FREE
“不含橡胶”的意思,一般是值不含天然橡胶naturalrubber.防过敏的吧.
等于?小于?0.15小时
15分钟大于0.15小时0.15小时=0.15*60分钟=9分钟
latex
latexpillow乳胶枕头乳胶婴幼儿枕Latexinfantpillow乳胶功能枕Latexpillowfeatures乳胶汽车枕Latexpillowca
cosX小于等于-1/2
[2π/3+2kπ,4π/3+2kπ]k为Z.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1f6d045a8062b36dd5330b66343e2d5/" rel="bookmark">
			kafka 统计消息总数_Kafka入门系列(十三) 如何查看topic消息数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		String brokerUrls = "localhost:9092";
String topic = "test";
int numPartitions = 6;
Properties props = new Properties();
props.put("bootstrap.servers", brokerUrls);
props.put("group.id", "test-group");
props.put("key.deserializer", "org.apache.kafka.common.serialization.StringDeserializer");
props.put("value.deserializer", "org.apache.kafka.common.serialization.StringDeserializer");
KafkaConsumer consumer = new KafkaConsumer&lt;&gt;(props);
consumer.subscribe(Arrays.asList(topic));
List partitions = new ArrayList&lt;&gt;();
for (int i = 0; i &lt; numPartitions; ++i) {
partitions.add(new TopicPartition(topic, i));
}
Map offsets = consumer.endOffsets(partitions);
Map earlyOffsets = consumer.beginningOffsets(partitions);
int totalCount = 0;
for (TopicPartition tp: offsets.keySet()) {
totalCount += (offsets.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e1f6d045a8062b36dd5330b66343e2d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ec2c2561ece4102684d4428e8cbb85f/" rel="bookmark">
			ProtoBuf: ByteString和String转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ByteString bs=ByteString.copyFrom("hi".getBytes()); System.out.println(bs.toStringUtf8()); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db4edafb5b018f839a8fc794c32bccfd/" rel="bookmark">
			计算右侧小于当前元素的个数(归并排序)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		### 解题思路
归并排序
### 代码
class Solution { public: vector&lt;int&gt; res; vector&lt;pair&lt;int,int&gt;&gt; temp; vector&lt;pair&lt;int,int&gt;&gt; pairIdx; void mergeSort (vector&lt;pair&lt;int,int&gt;&gt;&amp; nums,int l,int r){ if(l &gt;= r) return; int mid = (l + r) &gt;&gt; 1; mergeSort(nums,l,mid); mergeSort(nums,mid+1,r); int p1=l,p2=mid+1,k=0; while(p1 &lt;= mid &amp;&amp; p2 &lt;= r){ if(nums[p1].first &lt;= nums[p2].first){ res[nums[p1].second] += p2-mid-1; temp[k++] = nums[p1++]; } else temp[k++] = nums[p2++]; } while(p1 &lt;= mid){ res[nums[p1].second] += p2-mid-1; temp[k++] = nums[p1++]; } while(p2 &lt;= r) temp[k++] = nums[p2++]; for(int i = l,j=0;i &lt;= r;i++,j++) nums[i] = temp[j]; } vector&lt;int&gt; countSmaller(vector&lt;int&gt;&amp; nums) { res = vector&lt;int&gt;(nums.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db4edafb5b018f839a8fc794c32bccfd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb9afad16b5266db7cec575fef3653e5/" rel="bookmark">
			java mybatis优点_mybatis优缺点是什么?有哪些优点和缺点?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家对于MyBatis都熟悉吗?下面小编要给大家带来的就是和MyBatis相关的内容，你知道mybatis的优点和缺点吗?下面一起来看看详细介绍吧!
一、mybatis优点
下面要最先给大家介绍的就是mybatis的优点，一起来了解一下吧!
总的来说mybatis的优点可以分成以下的5点：
1、和JDBC比较起来的话，mybatis减少了百分之五十以上的代码量
2、mybatis的话，SQL代码从程序代码当中完全的分离出来，能够重用
3、mybatis是最简单的持久化框架，并且非常的小巧也很容易学
4、mybatis提供映射标签，除此之外，支持对象和数据库的ORM字段关系映射
5、mybatis提供XML标签，还支持编写动态SQL
以上就是mybatis的五大优点啦!你都了解了吗?那么下面让我们再一起来详细的了解一下mybatis的缺点又有哪些吧!
二、mybatis缺点
下面要给大家介绍的就是mybatis的缺点，具体的来说，mybatis的缺点可以分成以下的2点：
1、mybatis的数据库移植性较差，这个是它的一个非常大的缺点了。
具体的来说，例：
mysql移植到Orecle，SQL语句会有差异从而引起err
2、SQL语句编写工作量非常的大，要求熟练度非常的高
以上就是对于mybatis的缺点的一个简单介绍了，你都了解了吧!
三、延伸阅读
MyBatis专注于SQL本身，MyBatis是实体类和SQL语句之间建立的映射关系。
与此同时，MyBatis也是一个非常灵活的dao层优化方案，适用于性能要求非常高并且需求变化多的项目。
以上就是对于MyBatis的优缺点的介绍，你都了解了吧?
你想成为java架构师吗?欢迎继续关注本站了解和java架构师有关的知识哦!
推荐阅读：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c56abac7c1feda1197c80fa59e55382/" rel="bookmark">
			2021-02-25
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JavaScript作用域与引擎 最近在看作用域与引擎时，想起来一个段子。
故事的前景：当作用域嵌套，函数中的作用域里没有某个元素，而引擎需要对该元素进行RHS查询（也就是找源头操作）
代码：
function foo(a){
console.log(a＋b);
}
var b = 2;
foo(2);
主角当然是我们的函数作用域及全局作用域还有引擎啦
引擎：函数作用域兄弟，见过b吗？
低情商做法👇🏻
作用域：没听过，滚😡
引擎：全局作用域兄弟，见过b吗？
高情商做法👇🏻
作用域：当然～好兄弟，我给你吧！
哈哈哈哈，好像演了个小剧场。这个梗，还能再换个剧场玩一玩。
低情商做法👇🏻
引擎：（凶神恶煞的语气，狂妄不羁的态度）喂，函数作用域，见过b没？
作用域：第一，我不叫喂！我叫函数作用域，第二，跟域说话要有礼貌，在这里没人惯着你！第三，这个b，我听都没听过，你给我走开！（函数作用域破口大骂，引擎灰头土脸走开了）
高情商做法👇🏻
引擎：（如沐春风的态度，真挚的眼神）阿foo函数的上级作用域兄弟，阿不对！竟然是全局作用域老大哥，久仰大名！大哥大哥，你见过b吗？我需要对它进行RHS引用呢，小弟找它好久了，老板要的急！
作用域：（被一声声大哥叫的心花怒放）当然见过啦，给你b，对了，有啥事报大哥名字，找大哥，大哥给你帮忙！大哥办事，你放心！
引擎：好勒，谢大哥，小弟先走啦！回见！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d23d8a66a15d8f7b5658d25c52cef878/" rel="bookmark">
			C语言实现线性回归及梯度下降法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C语言实现线性回归 本篇介绍使用C语言实现线性回归以及利用梯度下降方法求最优解（包括单个梯度下降，批量梯度下降以及随机梯度下降）。
本篇博文更倾向于实际代码实现，其中算法原理可查看其他博客（网上太多了，懒得复制）
线性回归的本质是用一条直线拟合，最简单的是在二维向量中，复杂点的是在多维向量中。
理论公式为：公式中θ和x是向量，n是样本数。
损失函数公式：。这个损失函数是“最小二乘法损失函数”。针对小规模数据时可使用正则方程直接得出最小值，而本篇博文介绍的梯度下降法求最小值。
梯度下降公式：。其中是超参数，需要手动设置。
话不多说，直接看代码：
float data[10][2]= { {1,2}, {2,4}, {1.5,3}, {3,6}, {4,8}, {1.1,2.2}, {2.3,4.6}, {0.5,1}, {3.2,6.4}, {3.3,6.6}, }; float W[2]= {1,3}; void grad_des(float* data,float learning_rate) { float x[10][2]= {0}; int i=0; int j=0; float loss=0; float grad[2]= {0}; int m,n=0; int echo=0; float y_true[10]= {0}; float y_pre[10]= {0}; memcpy(x,data,sizeof(x)); //将x转换为[1,x]形式 for(i=0; i&lt;10; i++) { y_true[i]=*(*(x)+i*2+1); //x1=[1,x1] *(*(x)+i*2+1)=*(*(x)+i*2+0); *(*(x)+i*2) =1; } //cal grid for(echo=0; echo&lt;100; echo++) { loss=0; for(i=0; i&lt;10; i++) { y_pre[i]=0; for(m=0; m&lt;2; m++) { y_pre[i]+=(float)*(*(x)+i*2+m)*W[m]; } loss+=(float)(y_pre[i]-y_true[i])*(float)(y_pre[i]-y_true[i])/2; } printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d23d8a66a15d8f7b5658d25c52cef878/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e746ad1e06da04759b94694d25bd4c0/" rel="bookmark">
			java调整顺序_java语句顺序有时非常重要
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们学习java时，通常被告知，变量定义的顺序不重要，可是下面程序确在jdk 1.7上执行出错。
public class FactoryImpl implements Serializable {
private final static FactoryImpl INSTANCE = new FactoryImpl();
private final static AtomicInteger count = new AtomicInteger(0);
private int id;
private FactoryImpl() {
id = count.incrementAndGet();
}
public int getId() {
return id;
}
public static FactoryImpl getInstance() {
return INSTANCE;
}
public static void main(String[] args) {
FactoryImpl impl1 = FactoryImpl.getInstance();
System.out.println(impl1.id);
}
}
把下面代码调整顺序之后能够运行成功。private static final FactoryImpl INSTANCE = new FactoryImpl();
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e746ad1e06da04759b94694d25bd4c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bfdfc0e69cca00fb0f82aacdb0ff6eb2/" rel="bookmark">
			uni-app image组件当显示不出图片时显示默认图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我的image绑定了数组，数组中的对象包含要显示的图片路径，
我的路径是服务器的路径，所以会存在显示不出来的情况，当显示不出来的时候就要显示本地的默认图片
我的方案是这样的：
image有一个error的方法
当图片显示不出来的时候就会调用这个方法，所以在这个方法里把图片的路径改为本地的路径就可以了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1464ff51f2674e807e669ccbd98fa427/" rel="bookmark">
			任何程序员都应该知道的服务发现与负载均衡
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文：任何程序员都应该知道的服务发现与负载均衡
在早期的单点系统中，一个API只由一个服务器提供，客户端直接根据确定的IP访问这个服务。随着用户规模的增长，单凭一个服务器已不能支撑其庞大的流量，这就需要多台服务器组成一个集群，共同支持起一个API的流量。但是客户端并不知晓有哪些真实服务器可以提供所需要的API，也不知晓应该向哪个API提供者发起请求，这就需要一个组件来完成服务发现（发现有哪些服务提供者）和负载均衡（向哪个服务提供者发起请求）。
服务发现和负载均衡是服务端架构中非常基本的问题，涉及的领域比较广，本篇文章以我个人的见识介绍并分析这些问题，希望能抛砖引玉，以小见大，从而让读者对服务端架构设计有更深刻的理解。
经典的服务端架构 开门见山，我们直接看看现在流行的nginx+tomcat服务端架构，然后围绕着nginx来说明如何实现服务发现与负载均衡。
流程包括：
客户端（Client，可以是计算机、平板或手机等）发出来自外网的请求，经过DNS域名解析后，得到一个IP，通过IP请求API网关。nginx作为API网关（API Gateway），对请求进行限流、缓存后，将非静态数据的请求经由负载均衡器转发给特定的真实服务器，这个真实服务器只能通过内网访问，对于客户端是不可见的。tomcat作为web服务器，响应来自API网关的请求。redis和mysql作为分布式存储系统，mq作为分布式消息中间件，为业务服务器提供数据存储服务。 接下来会对这些流程进行更细致的讨论。
请求的网络结构 逻辑上的请求路径，并不表明物理网络上的数据传输路径也是如此。架构图并非网络结构图，不包含路由器、防火墙、交换机等设备，不能反映出一个请求在网络链路中的真实情况。大多数情况下，理解逻辑结构就能满足要求了，网络结构是运维人员应该思考的，但是程序员仍然应该清楚地知道诸如服务器之间并非直接物理相连而是需要经过交换机或路由器转发等问题，这些概念往往对软件设计也有启发作用。
下图可以更直观地看出在局域网同一个广播域内的数据包传输线路：
当我们在说服务器时，一般有两种含义，一个是指Linux操作系统中监听特定端口并提供服务的进程，另一个是指这个进程所处的物理机或虚拟机。没有规定API网关、业务服务器和数据库服务器不能部署在一个物理机上，一般在架构图中，用进程表示一个服务，至于怎么部署并没有做出约定，但在做高可用的规划中，需要避免一个集群完全部署到一台物理机中。不同语境下“服务器”所指的含义不同，在这个图中，表示不同的物理机。
如果是客户端直接访问业务服务器Server1，数据包路线为：路由器-交换机-server1-交换机-路由器，一共4跳。
如果是客户端通过nginx代理间接访问业务服务器Server1，数据包路线为：路由器-交换机-nginx-交换机-server1-交换机-nginx-交换机-路由器，一共8跳。
增加一层代理，网络传输线路足足增加了4跳，这还只是在同一广播域下，如果不在同一广播域，甚至不在同一机房，那么从nginx到server这一看上去直连的请求，其实可能经过交换机、防火墙、路由器等多个网络设备，无一不增加了流量负担和响应时延。在后面将要讨论的高可用问题时，还会提到，每增加一层代理就会导致自身成为瓶颈点。
像API网关这样的请求代理不是越多越好，服务端架构也不是层级越深越高端，不要随便添加代理。
单体架构转微服务架构后，会大量增加服务之间的通信成本，这是微服务不可避免的弱点。我很奇怪，如果是不满足于单体架构的整体开发整体发布的弊端的话，拆解为粗粒度的模块便是，为什么要走向另一个极端微服务呢。
API网关是必需的 但是一个演进式规模化的架构，必须要有一个API网关来代理下层的访问，必要时甚至有多层网关的设计。
理由之一是保护API提供者免于暴露在外网之下。如果客户端能够直接访问API真实服务器，那就意味着服务器的IP不再透明，就算API设计得可以阻止流量攻击，但是服务器上的其他进程就没有这么幸运了。这也是基于最小知识原则，向用户暴露更小范围的服务，会让系统更安全。
理由之二是隔离内部组织结构的变化。API由一个宿主计算机移动到另一个宿主计算机时，IP会变化，这意味着其用户必须及时改变请求地址。这种情况下，如果用户仍然访问原IP，将导致请求失败，就算是更改DNS的域名IP映射，也要等待IP缓存过期后才能访问正确的服务。使用API网关可以隐藏真实服务器的组织结构细节（代理的下一层节点对它来说都可称之为真实服务器，或者是被代理服务器），就像桥接模式一样，能够在保持客户端请求逻辑不变的情况下，任意改变真实服务器的组织结构而不影响客户端。
理由之三是服务发现与智能负载均衡。一个满足高容量高吞吐的API都是多进程部署的，通过横向堆叠服务器，形成一个集群对外提供服务。客户端并不知晓每个服务的IP和端口，也不知晓每个服务的健康状态。API网关提供了这样的能力，它配置和管理API与其对应服务器的关联，并定期进行健康状态检查，如果发现某个服务宕机，将短暂地放弃这个服务。最重要的是，它可以根据每个服务的负载情况和响应时延，智能地选择一个服务来均衡负载。“智能”在于负载均衡策略可编程，以及能准确判断下游服务的真实负载。
理由之四是集中化控制。众所周知，一个API的请求过程需要夹杂各种非功能性的处理策略，比如身份认证、参数校验、协议转换、流量控制、日志记录、结果处理等等。如果这些逻辑都施加在真实服务器上，那么设计一个API的过程会变得很复杂，同样的事情要避免每个服务器都重做一遍。
以上的理由都是刚需，这也是为什么nginx这么火的原因了。
关于速度，也是在API网关选型中很重要的一点，但是我认为nginx是火在开源上，而不是速度上。
很多人认为nginx速度快是因为使用了I/O多路复用技术，这年头还有不使用这个技术的网络服务器吗？tomcat用了，zuul也用了。快是相对来说的，相对tomcat是很快，因为nginx虽然也是web服务器，但是不需要真的做业务，只把真正耗时的部分交给下游服务器完成，它自身当然快了。据测试，nginx比开启了多核cpu绑定预热后的zuul快不了多少。
nginx是用c语言实现的，是基于应用层的负载均衡，他的速度受到所在服务器性能的制约，要比工作在网络层的LVS慢一些，要比硬件负载均衡器f5慢很多。
API网关是个融合怪 增加一层代理会让请求响应变慢以及产生新的瓶颈，但是这层代理又不可或缺，为了对得起它的身份，只能让这层代理做越来越多的事情，不断增加新功能，最终变成融合怪。
下到日志记录，上到负载均衡，大事小事脏活累活，API网关全包了。
这看上去违反单一职责原则，不过好在其内部实现还是职责分明的，一个过滤器负责一项任务。对于开源的API网关，还可以进行定制化开发，添加贴合业务的更具体的功能，反正它的功能已经很多了。
DNS，原始的负载均衡 域名系统(Domain Name System,DNS)是为Internet用户解决域名IP映射的系统。就像拜访朋友要先知道别人家怎么走一样，Internet上当一台主机要访问另外一台主机时，必须首先获知其地址，TCP/IP中的IP地址是由四段以“.”分开的数字组成(此处以IPv4的地址为例，IPv6的地址同理)，记起来总是不如名字那么方便，所以，就采用了域名系统来管理名字和IP之间的对应关系。
DNS的技术是标准的，几乎所有的技术栈都支持它，并且几乎不会出现错误。DNS由不同层次的节点服务器组成，并且每一个服务器都进行力所能及的缓存，这有点像去中心化的区块链技术。
书本上是这样教的，但是只知道这些是不够的，其实DNS还是一个客户端侧的负载均衡系统。
大多数域名注册商都支持对同一主机添加多条A记录，也就是说DNS可以将一个域名映射到多个IP。客户端请求域名解析时，DNS返回一个随机顺序的IP列表，客户端把列表的第一个IP作为请求IP去访问主机，这就完成了简单的负载均衡。
但是DNS的服务发现和负载均衡机制是很差的。
域名的DNS条目有一个 TTL，表示该条目在这个时间内是有效的。当我们在DNS服务器上更新域名所指向的IP时，客户端或其他DNS节点服务器由于缓存了这个条目所以并不会得到即时更新，我们不得不假定客户端至少在TTL所指示的时间内持有旧的IP。这会导致很多种糟糕的情况，比如源主机的IP改变或者出现宕机而不可用时，客户端依然会访问过时的主机。
另一方面DNS负载均衡采用的是简单的轮询算法，不能根据地域返回离用户较近的IP，不能反映服务器当前的运行状态，不能为性能较好的服务器多分配请求，甚至会出现用户请求集中访问某一台服务器上的情况。
如果你只有单个主机，那么DNS直接引用这个主机就可以了，否则更好的做法是，将DNS解析后的IP指向一个负载均衡器，由这个负载均衡器再做路由分发。
硬编码是最基本的服务发现 你可能想知道，DNS提供了服务发现，前提是需要知道DNS服务器的地址，而客户端又是怎么知道DNS服务器的地址呢？这个问题换一种说法是，客户端如何发现提供了服务发现功能的服务器。
问题的答案来自于我们的原始习惯：写死，也就是将服务器地址硬编码到程序中。
首先集群服务先部署上去，并明确知道所有进程的IP和端口，然后在程序中写死这些IP和端口，比如在xml/yml/properties这些配置文件中写明：“xx注册中心，集群地址列表为：xxx”。一般列表中第一个IP作为首选IP，其他的IP作为备选IP，当客户端要访问服务时，先使用首选IP服务器获取数据，如果能正常访问，下次继续用，否则将采用备选IP，直到用尽所有的备选IP，最终返回失败。由于集群中的不同服务是分开部署的，同时宕机的可能性几乎为零，这种策略可以满足高可用的要求。
为什么业界选择的硬编码服务发现方案都是不断请求首选服务器直到不可用才切换下一个，而不是循环选择。我能想到的原因是，硬编码方案主要适用于集中式服务器的发现，这些服务器所提供的服务是可异步且轻量级的，不需要负载均衡，反而请求相同的服务器有利于TCP连接复用，在逻辑简单的同时略微提升性能。
现在大多数集群式部署的中间件都采用动态的注册中心来发现服务。“动态”体现在不需要硬编码配置，而是Server provider（服务提供者）在启动时向registry（注册中心）注册自己的服务ip映射关系，在运行过程中间隔性维持心跳，在关闭时销毁映射关系。而至于注册中心的地址，当然是写死啦。动态也体现在服务检活上，注册中心给每个条目维持一个存活性状态记录，如果条目对应的服务器失联（可以是网络故障或者服务器宕机），则从候选服务中移除该条目，直到它恢复时再上线，这就保证了用户的请求始终可以得到正确的响应。虽然看上去灵活，但这些动态注册中心集群的背后，是需要客户端直接引用注册中心集群地址的。
RocketMq的consumer通过namesrv发现broker服务，而namesrv集群的地址还是会附加在客户端侧。
Eureka的eureka Client通过eureka server发现provider，而eureka server集群地址会固定在配置文件中：
eureka.client.service-url.defaultZone=http://1,http://2 nacos的nacos Client通过nacos server获取配置数据，而nacos server集群地址会固定在配置文件中：
&lt;dubbo:registry protocol="nacos" address="192.168.0.1:8080,192.168.0.2:8080,192.168.0.3:8080"/&gt; 能不能彻底避免硬编码呢？我还没有找到这样的方法，就算再找一个注册中心，将这些集群地址注册进去，最终客户端还是要知道这个核心注册中心地址才行。问题的关键是，当我们需要避免硬编码时，究竟是要避免什么，是要避免配置频繁变动导致的服务频繁发布，如果这个配置不经常变动，或者变动的频率远远低于它自然升级的频率，是不是就不用在意那么多了。
集群与高可用 集群就是将相同的代码部署到多个进程中，这些进程集合在一起作为一个整体对外提供服务。根据这个定义，集群自然就离不开服务发现机制了，有的集群自带了服务发现能力，有的集群依赖于第三方的服务发现软件。
高可用（HA）指的是服务的有效可用时长（非故障时间）占总时长的比例高。网络是不可靠的，硬件也会出问题，故障是不可避免的，但是优秀的服务端架构设计应当能够尽可能地降低故障率，控制风险范围。
那么集群就意味着高可用吗？不一定，这要取决于所选择的负载均衡策略。有一种定向路由策略，它把特定的请求参数经过哈希换算，定向到特定的服务器节点上，由且仅由这台服务器负责处理该请求，这种策略并不能对高可用有帮助。比如在redis服务集群中，redis把存储空间划分为16384份，每个主节点保持一部分，当减少或增加机器时，它们会重新分配存储空间并保持均匀。当用户发起一个GET key请求，redis节点接收后计算key所在的存储空间（槽）的位置，如果就在本机上，直接查询对应的数据，否则返回一个moved重定向错误，告诉客户端正确的节点在哪，客户端再去目标节点获取key的数据。如果只有主节点没有从节点，一旦目标节点宕机，节点所负责的存储空间将失效，但其他节点并不负责这块的数据，也没有这块的数据，最终导致服务不可用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1464ff51f2674e807e669ccbd98fa427/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6bc2b3c797e1e39d8452569b4e90924/" rel="bookmark">
			FPGA中有限状态机的设计原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.有限状态机（FSM）原理
2.设计可综合状态机的指导原则
1.有限状态机（FSM）原理 有限状态机是由寄存器和组合逻辑构成的硬件时序电路。有限状态机的状态（即由寄存器组的1和0的组合所构成的有限个状态）只可能在同一时钟变沿情况下才能从一个状态跳转到另一个状态
有限状态机的下一个状态不但取决于各个输入值，还取决于当前所在状态。这里指的是米里Mealy型有限状态机，而莫尔Moore型有限状态机的下一个状态只取决于当前状态。
Verilog中可以使用许多种方法来描述有限状态机，最常用的方法是用always语句和case语句。如图所示：
如上图所示是一个四状态的有限状态机。它的同步时钟是Clock，输入信号是A和Reset，输出信号是F和G。状态的转移只能在同步时钟（Clock）的上升沿时发生，往哪个状态的转移则取决于目前所在的状态和输入的信号（Reset和A）。
Gray码有限状态机模型：
module fsm(Clock,Reset,A,F,G); input Clock,Reset,A; output F,G; reg F,G; reg [1:0] state; parameter Idle = 2'b00,Start = 2'b01,Stop = 2'b10, Clear = 2'b11; always @(posedge Clock) begin if(!Reset) begin state &lt;= Idle; F &lt;= 0; G &lt;= 0; end else begin case(state) Idle: begin if(A) begin state &lt;= Start; G&lt;=0; end else state &lt;= Idle; end Start: begin if(!A) state &lt;= Stop; else state &lt;= Start; end Stop: begin if(A) begin state &lt;= Clear; F &lt;= 1; end else state &lt;= Stop; end Clear: begin if(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f6bc2b3c797e1e39d8452569b4e90924/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ecb7bbac3c286be1659709ea87218ae/" rel="bookmark">
			简述java异常分类_Java异常概念 异常处理方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		(1) 什么叫异常？
异常指程序运行过程中出现的非正常现象，例如用户输入错误、除数为零、需要处理的文件不存在、数组下标越界等
(2) 请简述异常的分类？
所有异常的根类为java.lang.Throwable，Throwable下面又派生了两个子类：Error和Exception
Error: Unchecked Exception
Exception:Checked Exception, Runtime Exception
Runtime Exception: Unchecked Exception
异常处理方式之一_捕获异常
(1) 捕获异常所使用的关键字有哪些？
Try-catch-finally
(1) try-catch-finally有几种结合形式，每种组合形式的执行顺序是什么？
① 三种
1) Try-catch组合
a. 正常情况
b.异常情况，异常出现的类型与捕获的类型匹配
异常情况，异常出现的类型与捕获的类型不匹配
2) try-finally 组合
a. finally 是无论是否产生异常，都执行的代码，但是有一种
情况 finally 不执行，即退出 Java 虚拟机 System.exit(0);
3) try-catch-finally 组合
a) 正常情况：执行 try-finally
b) 异常情况：类型相匹配，执行 try-catch-finally
c) 异常情况：类型不相匹配，执行 try-finally
如果在 catch 中存在 return 语句，则先执行完 finally 语句
再回头执行 return 语句
异常处理方式之二_声明异常
(1) 继承关系中如何声明异常？
父类中的方法声明了Exception类型的异常,子类在重写方法是,可以声明也可以不声明.但是如果子类重写后的方法使用super关键字调用父类的方法,那么要求必须对异常进行处理.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ecb7bbac3c286be1659709ea87218ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a7a59d45a875d9b7b952669ff5eaf77/" rel="bookmark">
			spring事务中锁失效
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1-为啥会失效
@Transactional的实现是基于Spring的AOP。Spring会对其业务方法进行动态代理，执行前开始事务，然后再执行业务代码，最后提交事务。大致流程如下图所示
假设线程1线抢到锁，在解锁这个时候，这个时候事务还没有提交，数据库数据还没有更新。然后线程2获取到了锁，读取的数据可能是旧数据，出现了锁失效的情况。
synchronized和分布式锁都同理会失效！，最本质的原因：解锁在提交事务之前了。
2-解决方案
在Controller层加锁，注意锁粒度…避免长事务「长事务可能会增加死锁的概率…然后数据库连接池数量被打满… 」在service层里再单独抽个方法，上锁操作、释放锁操作 夹着事务方法 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/678c821115d80190e752da6458d07b59/" rel="bookmark">
			java 时间类 joda_开源Java时间工具类Joda-Time体验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import org.joda.time.*;
import org.joda.time.format.DateTimeFormat;
import org.joda.time.format.DateTimeFormatter;
import org.junit.Test;
import java.util.Locale;
/**
* @author by lei zhou on 2017/11/09 14:20.
*/
public class JodaTimeTest {
@Test
public void test() {
// 日期输出格式
DateTimeFormatter dateTimeFormat = DateTimeFormat.forPattern("yyyy-MM-dd HH:mm:ss");
System.out.println("当前日期时间: " + DateTime.now().toString(dateTimeFormat));
System.out.println("当前日期但时间清0: " + DateTime.now().withTimeAtStartOfDay().toString(dateTimeFormat));
System.out.println("本月第一个周日的日期时间: " + getThisMonthFirstSunday().toString(dateTimeFormat));
System.out.println("本周周一的日期时间: " + getThisWeekSunday().toString(dateTimeFormat));
System.out.println("距离元旦天数: " + daysToNewYear(DateTime.now()));
System.out.println("距离元旦月数: " + monthsToNewYear(DateTime.now()));
String[] french = DateTimeUtils.getDateFormatSymbols(Locale.FRANCE).getWeekdays();
String[] japanese = DateTimeUtils.getDateFormatSymbols(Locale.JAPAN).getWeekdays();
String[] korean = DateTimeUtils.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/678c821115d80190e752da6458d07b59/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2968d20478a9cd1a2606edc5855e212f/" rel="bookmark">
			&#43;号的转义符是%2B
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这两天在服务器上部署mongodb和rabbitmq，发现密码中带有+号没法连接成功，需要使用转义字符代替
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3df38036c10cfc61c240345d023b4384/" rel="bookmark">
			java基础使用方法_Java基础之   常见的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是方法？
格式
一个方法的执行流程
参数列表、返回值
有无返回值
形参是一个类的时候
break和continue的区别
//break是结束整个循环体，continue是结束单次循环
比方说：
while(x++ &lt; 10)
{
if(x == 3)
{
break;
}
printf("%d\r\n", x);
}
结果是输出 1 2 就退出了整个while循环
但是如果使用continue
while(x++ &lt; 10)
{
if(x == 3)
{
continue;
}
printf("%d\r\n", x);
}
结果是：1 2 4 5 6 7 8 9 10 可见他仅仅是不输出3，因为他结束了本次循环
数组
字符串的截取与转换
1.截取substring、splice 方法
2.转换，字符数组与字符串 Tostring ToCharArray
2.1.转换，整数与字符串之间的转换(拆装箱？？)
Java方法之面向对象的简单概述
方法已经是固定的写好的，什么方法有什么功能都有特殊的标记，
你所要做的是：根据功能调用什么样的方法，然后把你所需要的数组放在()里面就行了。
1.封装
Person 类中(判断功能，以及其他功能)的使用
2.继承
3.多态
随机数(Random)
格式：
next与nextint 的区别
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3df38036c10cfc61c240345d023b4384/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee796980c9338ba5a289391579eda0c4/" rel="bookmark">
			java写出http数据包_java用jpcap怎么识别出http和https的数据包？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题简述：
利用java的第三方库jpcap写抓包程序，求解怎么识别出http和https的数据包(就只要能判断出是http协议或https协议即可)。
测试的解法：
1.在tcp包(jpcap自带TCPPacket类比较方便识别tcp包)的基础上用80端口和443端口区分http和https，但是连tcp都识别成http或https了(不成功)。
2.设法找出http或https特有而tcp没有的字段，未能找出。
代码示意(未完成)：
` else if(packet instanceof jpcap.packet.ICMPPacket) {
packetprocol = "ICMP";
r.addElement(packetprocol);
}
else if(packet instanceof jpcap.packet.TCPPacket) {
TCPPacket tcppacket = (TCPPacket)packet;
//if((tcppacket.src_port==80||tcppacket.dst_port==80)&amp;&amp;tcppacket.) {
packetprocol = "HTTP";
r.addElement(packetprocol);
}else if(tcppacket.src_port==443||tcppacket.dst_port==443) {
packetprocol = "HTTPS";
r.addElement(packetprocol);
}
else {
packetprocol = "TCP";
r.addElement(packetprocol);
}`
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0794b4b355993bc41c371d9706d470d6/" rel="bookmark">
			“undefined reference to“ 问题汇总及解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://blog.csdn.net/dyzhen/article/details/79815667
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/007aaed847eebbd243b35124c642d921/" rel="bookmark">
			ARM Cortex -M3内核
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. Cortex-M3内核介绍 Cortex-M3处理器提供了一个高性能、低成本的平台，满足系统对最小化内存现、减少引脚计数和低功耗的要求。包括以下特点:
32位的Cortex-M3体系结构为占用空间小的嵌入式应用程序进行了优化；出色的处理性能与快速中断处理相结合；ARM Thumb-2结合了16位和32位指令，与8位、16位小内存设备提供32位ARM高性能核心预期，对于微控制器类的应用程序，通常在几千字节的内存范围内；快速的代码执行允许更慢的处理器时钟或增加睡眠模式时间；哈佛体系结构：指令和数据的独立总线；高效的处理器核心、系统和内存；面向乘法累加的硬件除法和快速数字信号处理；信号处理的饱和算法；对于时间敏感的应用程序，提供确定性的、高性能的中断处理；增强的系统调试功能，具有广泛的断点和跟踪功能；充分调试与数据匹配的观察点生成；从ARM7处理器家族迁移，以获得更好的性能和能效；标准跟踪支持；优化的单周期闪存使用；超低功耗，集成睡眠模式；高达48MHZ运行速度； 2. 内部框图 Cortex-M3处理器基于3段流水线哈佛架构的高性能核心，因此，它是要求很高的嵌入式应用程序的理想选择。处理器通过高效的指令集和广泛优化的设计提供了卓越的功率效率。该指令集包括单周期和SIMD乘法和累加乘法能力，饱和算法和专用硬件除法的范围。
为了便于成本敏感设备的设计，Cortex-M3处理器实现了紧密耦合的系统组件，减少了处理器面积，同时显著提高了中断处理和系统调试能力。Cortex-M3处理器实现了基于Thumb-2技术的Thumb指令集版本;从而确保了较高的代码密度和减少了程序内存需求。Cortex-M3指令集提供了现代计算机所期望的32位体系结构，高代码密度的8位和16位微控制器。
Cortex-M3处理器紧密集成了一个嵌套的矢量中断控制器(NVIC)，以提供中断服务程序(ISRs)的快速执行，从而显著减少中断延迟。寄存器的硬件堆叠以及挂起load-multiple和store-multiple操作的能力进一步降低了中断延迟。中断处理程序不需要任何汇编程序存根，因此从ISRs中删除了代码开销。尾链优化也显著降低了从一个ISR切换到另一个ISR时的开销。为了优化低功耗设计，NVIC集成了睡眠模式，包括深度睡眠模式，使整个设备能够快速断电。
3. 总览 3.1 系统级接口
Cortex-M3处理器使用AMBA技术提供多个高速、低延迟的内存访问接口。核心支持非对齐数据访问，并实现了原子位操作，支持更快的外围控制、系统自旋锁和线程安全布尔数据处理。
3.2 集成可配置调试
Cortex-M3处理器通过串口线或JTAG实现了完整的硬件调试解决方案。SWJ-DP通过传统的JTAG端口提供了处理器和内存的高系统可见性。
对于系统跟踪，处理器集成了仪表跟踪宏单元(ITM)以及数据观察点和分析单元。为了支持对系统跟踪事件进行简单且经济有效的分析，串行线查看器(SWV)可以通过一个引脚导出软件生成的消息流、数据跟踪和分析信息。
flash补丁和断点单元(FPB)提供最多8个调试器可以使用的硬件断点比较器。FPB中的比较器还提供在代码存储区域中的程序代码中最多8个字的重映射函数。Remap功能可以将存储在闪存只读区域的应用程序打补丁到片上SRAM或闪存的另一个区域。如果需要打补丁，应用程序会向FPB重新映射多个地址。当访问这些地址时，访问被重定向到FPB配置中指定的remap表。
3.3 跟踪端口单元
TPIU充当ITM的Cortex-M3跟踪数据和片外跟踪端口分析仪之间的桥梁。
4. 程序设计模型 4.1 软件执行的处理器模式和特权级别
Cortex-M3处理器有两种操作模式:
线程模式执行应用软件。处理器退出重置后进入线程模式处理模式处理异常。当处理器完成异常处理时，它返回到线程模式。 此外，Cortex-M3处理器有两个特权级别，非特权级和特权级。
在非特权模式下，软件有以下限制:
限制使用MSR和MRS指令，没有使用CPS指令
没有权限访问系统定时器，NVIC或SCB在特权模式下，软件可以使用所有指令，并可以访问处理器中的所有资源 在线程模式下，CONTROL寄存器控制软件执行是特权执行还是非特权执行。在处理程序模式下，软件执行总是享有特权。只有特权模式的软件才能写CONTROL寄存器来改变在线程模式下执行软件的特权级别。非特权软件可以使用SVC指令产生监管请求，将控制权转移给特权软件。
4.2 堆栈
Cortex-M3处理器使用一个完整的降序堆栈，这意味着堆栈指针指示内存上最后一个地址。当处理器将一个新项压入堆栈时，它将堆栈指针减1，然后将该项写入新的内存位置。处理器有两个堆栈，主堆栈和进程堆栈，每个都有一个指针保存在独立的寄存器中。
在线程模式下，控制寄存器控制处理器是使用主堆栈还是进程堆栈。在处理程序模式下，处理器总是使用主堆栈。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3b5f605c56182c9ac9295700657068e/" rel="bookmark">
			(模板)旋转数组模板
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 class Solution { public: int minArray(vector&lt;int&gt;&amp; numbers) { if(numbers.size() == 1) return numbers[0]; //直接返回结果 int offset = numbers.size()-1; while(offset &amp;&amp; numbers[0] == numbers[offset]) offset--; if(numbers[offset] &gt;= numbers[0]) return numbers[0]; int l = 0, r = offset; while(l &lt; r){ int mid = (l+r) &gt;&gt; 1; if(numbers[mid] &lt; numbers[0]) r = mid; else l = mid + 1; } return numbers[r]; } }; 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/380/">«</a>
	<span class="pagination__item pagination__item--current">381/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/382/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>