<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1eb1acbaffe5f75f1597f2db6d349133/" rel="bookmark">
			安装Redis报fatal error:jemalloc错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用【make &amp;&amp; make install】安装redis时出现【fatal error】错误信息如下图：
执行【make MALLOC=libc】安装成功
redis的内存管理方式支持
tcmallocjemalloclibc（标准内存管理工具） 原因：建立redis时系统默认使用jemalloc作为内存管理工具，但是当前无可用jemalloc，切换为标准内存管理工具libc问题解决。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8ceb44ddf84907677b63142e3c344a8/" rel="bookmark">
			快速集成华为AGC云存储服务-Web
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		华为AppGallery Connect提供了一个云存储（CloudStorage）的服务，号称提供了一个便捷的云端存储服务，应用开发者使用的时候，可以不用关注服务器的部署，直接使用就行。
这个服务近期上线了Web端的JavaScript的SDK，我抢先体验试用了一下。也可以下载codelab或者demo自行研究。
1、环境与应用信息 版本名称集成环境-应用测试设备“cloudstorage”: “1.0.0”Window-Node-v14.15.0 npm v6.14.8 Intellij + VuePC-Chrome 环境：https://developer.huawei.com/consumer/rn/service/josp/agc/index.html
SDK版本："@agconnect/cloudstorage": “^1.0.0-beta3”
集成SDK命令：npm install --save @agconnect/cloudstorage
2、在AGC上开通云存储: PS： 云存储服务目前还处于beta状态，使用前应该发邮件去申请开通：
https://developer.huawei.com/consumer/cn/doc/development/AppGallery-connect-Guides/agc-cloudstorage-apply
在我的项目 下选择你的开发项目，在构建下面，找到云存储服务，点击开通：
没有Web项目的话，需要先自己创建一个。
开通服务的时候，需要先配置存储实例，这里按需配置就可以，我就随便配置一个。
下一步，还需要配置安全策略，这里使用默认的安全策略就好:
PS：默认的情况是，只有经过身份认证的用户才能进行读写。
3、安装开发环境: 1、安装Intellij IDEA： 下载地址：https://www.jetbrains.com/idea/download/#section=windows
安装的时候，记得选for web的 IntelliJ IDEA Ultimate
2、创建vue项目 3、编译完成后，生成以下文件： 4、SDK集成 1、打开命令行窗口，进入到项目目录下，在项目目录下执行以下命令，安装云存储的JS SDK:
npm install --save @agconnect/cloudstorage 安装云存储的JS SDK后，会自动匹配AGC SDK，无需额外安装。
2、应用级src目录下创建名为 “agConnectConfig.js” 的文件，并且将AGC界面上“项目设置 &gt; SDK代码片段”中所有内容复制到“agConnectConfig.js”里
注意添加export 参数
3、在项目路径下执行npm install命令 安装 package.json 依赖。
5、功能开发 a) 页面布局-新建一个 1、新建一个Page.vue文件，在template便签下添加如下代码布局
&lt;div class = "hello"&gt; &lt;div v-show="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8ceb44ddf84907677b63142e3c344a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97a0378104167bd92835895d4fd68fb3/" rel="bookmark">
			2021-02-19
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前端-HTML关于图片插入的映射问题
例子：当点击同一张图片的不同位置时出现不同的效果。
主要代码如下：
&lt;map name="planetmap"&gt; &lt;area shape="rect" coords="0,0,82,126" alt="Sun" href="sun.htm"&gt; &lt;area shape="circle" coords="90,58,3" alt="Mercury" href="mercur.htm"&gt; &lt;area shape="circle" coords="124,58,8" alt="Venus" href="venus.htm"&gt; &lt;/map&gt; 其中shape是指点击区域的形状，coords指分别指左上坐标（x1,y1），右下坐标（x2,y2）
或者圆形，coords指，圆心坐标（c1,c2）及圆半径r的值。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c23033d3f265d56224251ac06d191e9c/" rel="bookmark">
			C&#43;&#43; 用DEV-C&#43;&#43;建一个Windows窗口程序带文本框和命令按钮
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先看一下程序的效果图：
在Dev-C++ 5.11上创建并正常运行，操作系统32位、64位的Win7都可以。
首先在文件菜单里新建项目，选择Windows Application：
命名完成后得到如下程序框架：
#include &lt;windows.h&gt; /* This is where all the input to the window goes to */ LRESULT CALLBACK WndProc(HWND hwnd, UINT Message, WPARAM wParam, LPARAM lParam) { switch(Message) { /* Upon destruction, tell the main thread to stop */ case WM_DESTROY: { PostQuitMessage(0); break; } /* All other messages (a lot of them) are processed using default procedures */ default: return DefWindowProc(hwnd, Message, wParam, lParam); } return 0; } /* The 'main' function of Win32 GUI programs: this is where execution starts */ int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow) { WNDCLASSEX wc; /* A properties struct of our window */ HWND hwnd; /* A 'HANDLE', hence the H, or a pointer to our window */ MSG msg; /* A temporary location for all messages */ /* zero out the struct and set the stuff we want to modify */ memset(&amp;wc,0,sizeof(wc)); wc.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c23033d3f265d56224251ac06d191e9c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10bd9dfaea8feb2290a9a1f6ddf41530/" rel="bookmark">
			深入学习MySQL事务：ACID特性的实现原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、基础概念 事务（Transaction）是访问和更新数据库的程序执行单元；事务中可能包含一个或多个sql语句，这些语句要么都执行，要么都不执行。作为一个关系型数据库，MySQL支持事务，本文介绍基于MySQL5.6。
首先回顾一下MySQL事务的基础知识。
1. 逻辑架构和存储引擎 如上图所示，MySQL服务器逻辑架构从上往下可以分为三层：
（1）第一层：处理客户端连接、授权认证等。
（2）第二层：服务器层，负责查询语句的解析、优化、缓存以及内置函数的实现、存储过程等。
（3）第三层：存储引擎，负责MySQL中数据的存储和提取。MySQL中服务器层不管理事务，事务是由存储引擎实现的。MySQL支持事务的存储引擎有InnoDB、NDB Cluster等，其中InnoDB的使用最为广泛；其他存储引擎不支持事务，如MyIsam、Memory等。
如无特殊说明，后文中描述的内容都是基于InnoDB。
2. 提交和回滚 典型的MySQL事务是如下操作的：
1
2
3
start transaction;
…… #一条或多条sql语句
commit;
其中start transaction标识事务开始，commit提交事务，将执行结果写入到数据库。如果sql语句执行出现问题，会调用rollback，回滚所有已经执行成功的sql语句。当然，也可以在事务中直接使用rollback语句进行回滚。
自动提交
MySQL中默认采用的是自动提交（autocommit）模式，如下所示：
在自动提交模式下，如果没有start transaction显式地开始一个事务，那么每个sql语句都会被当做一个事务执行提交操作。
通过如下方式，可以关闭autocommit；需要注意的是，autocommit参数是针对连接的，在一个连接中修改了参数，不会对其他连接产生影响。
如果关闭了autocommit，则所有的sql语句都在一个事务中，直到执行了commit或rollback，该事务结束，同时开始了另外一个事务。
特殊操作
在MySQL中，存在一些特殊的命令，如果在事务中执行了这些命令，会马上强制执行commit提交事务；如DDL语句(create table/drop table/alter/table)、lock tables语句等等。
不过，常用的select、insert、update和delete命令，都不会强制提交事务。
3. ACID特性 ACID是衡量事务的四个特性：
原子性（Atomicity，或称不可分割性）一致性（Consistency）隔离性（Isolation）持久性（Durability） 按照严格的标准，只有同时满足ACID特性才是事务；但是在各大数据库厂商的实现中，真正满足ACID的事务少之又少。例如MySQL的NDB Cluster事务不满足持久性和隔离性；InnoDB默认事务隔离级别是可重复读，不满足隔离性；Oracle默认的事务隔离级别为READ COMMITTED，不满足隔离性……因此与其说ACID是事务必须满足的条件，不如说它们是衡量事务的四个维度。
下面将详细介绍ACID特性及其实现原理；为了便于理解，介绍的顺序不是严格按照A-C-I-D。
二、原子性 1. 定义 原子性是指一个事务是一个不可分割的工作单位，其中的操作要么都做，要么都不做；如果事务中一个sql语句执行失败，则已执行的语句也必须回滚，数据库退回到事务前的状态。
2. 实现原理：undo log 在说明原子性原理之前，首先介绍一下MySQL的事务日志。MySQL的日志有很多种，如二进制日志、错误日志、查询日志、慢查询日志等，此外InnoDB存储引擎还提供了两种事务日志：redo log(重做日志)和undo log(回滚日志)。其中redo log用于保证事务持久性；undo log则是事务原子性和隔离性实现的基础。
下面说回undo log。实现原子性的关键，是当事务回滚时能够撤销所有已经成功执行的sql语句。InnoDB实现回滚，靠的是undo log：当事务对数据库进行修改时，InnoDB会生成对应的undo log；如果事务执行失败或调用了rollback，导致事务需要回滚，便可以利用undo log中的信息将数据回滚到修改之前的样子。
undo log属于逻辑日志，它记录的是sql执行相关的信息。当发生回滚时，InnoDB会根据undo log的内容做与之前相反的工作：对于每个insert，回滚时会执行delete；对于每个delete，回滚时会执行insert；对于每个update，回滚时会执行一个相反的update，把数据改回去。
以update操作为例：当事务执行update时，其生成的undo log中会包含被修改行的主键(以便知道修改了哪些行)、修改了哪些列、这些列在修改前后的值等信息，回滚时便可以使用这些信息将数据还原到update之前的状态。
三、持久性 1. 定义 持久性是指事务一旦提交，它对数据库的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/10bd9dfaea8feb2290a9a1f6ddf41530/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70679b07988b4c00259d012f67c4f0d8/" rel="bookmark">
			Android下载apk并安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://github.com/lucf1103/InstallApk
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b67a68473882d432fb7a834960bbf73/" rel="bookmark">
			tools:replace specified at line: for attribute android:appComponentFactory, but no new value specifi
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 tools:replace specified at line: for attribute android:appComponentFactory, but no new value specified main manifest (this file), line
按照其建议加上 tools:replace="android:appComponentFactory" 后依然报错：
解决：
&lt;application tools:replace="android:appComponentFactory" //除了这行之外 android:appComponentFactory="任意字符" //还要加上这一行 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d52603e421fd516f03c8a242ff62d043/" rel="bookmark">
			“以太网“有一个自分配的 IP 地址,将无法接入互联网 的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VMware 安装macOS，后无法联网，查看网络连接（系统偏好设置-&gt;网络-&gt;），提示如下：
可以看到自动分配的IP是169.254.xx.xx，获得这个ip的情况说明上网设备DHCP功能有问题。
解决方法 打开”编辑-》虚拟网络编辑器-》如果VMnet8的DHCP功能未启用。则按如下步骤启用DHCP
1、选中VMnet8，点击更改设置，进入如下页面：
2、勾选使用本地DHCP服务将IP地址分配给虚拟机，点击应用。设置完后，可以看到VMnet8的DHCP显示已启用。
3、点击应用，此时可以看到以太网分配的ip地址变为192.168.xx.xx。此时虚拟机可正常访问网络。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29861c66fa2b5cc1b0ecf899610f5ad5/" rel="bookmark">
			基础-深度优先搜索（DFS）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		深度优先搜索（DFS） 1.1 定义 先说什么是搜索。搜索算法是利用计算机的高性能来有目的的穷举一个问题解空间的部分或所有的可能情况，从而求出问题的解的一种方法。在忽略效率的情况下，没有什么是搜索解决不了的（？
深度优先搜索（DFS）是基于递归的搜索。
想象你在走迷宫：
1、 这个方向有路可走，我没走过
2、 往这个方向前进
3、 是死胡同（到达了已经走过的地方），往回走，回到上一个路口
4、 重复第一步，直到找着出口
通过这种方式，只要地点的数量是有限的，你就一定可以在有限的时间找到迷宫的出口（或者确定这个迷宫没有出口）。
只要可以前进就往前走，这就是深度优先搜索的思路流程。
1.2 例题 1.2.1 全排列 题目：
输出1~n所有的全排列。
如1~3的全排列：
1 2 3
1 3 2
2 1 3
2 3 1
3 1 2
3 2 1
排列:一般地，从n个不同元素中取出m（m≤n）个元素，按照一定的顺序排成一列，叫做从n个元素中取出m个元素的一个排列(permutation)。特别地，当m=n时，这个排列被称作全排列(all permutation)。
思路：
搜索。
代码：
#include &lt;stdio.h&gt; #define N 1001 int v[N],a[N],n; void dfs(int t) { if (t==n+1) { for (int i=1;i&lt;=n;++i) printf("%d ",a[i]); printf("\n"); return; } for (int i=1;i&lt;=n;++i) if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29861c66fa2b5cc1b0ecf899610f5ad5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/395a09c36687c913f90f3e563b969a0d/" rel="bookmark">
			tool - 基于validation校验枚举值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前会根据业务，自定义注解和扩展validation的校验器来实现基于注解进行通用校验。后面某一天想能不能整个枚举校验- -
注解定义：
/** * 枚举校验 标识注解 * @Author:cyw * @CreateTime: 2020年11月7日14:14:25 **/ @Target({FIELD, PARAMETER}) @Retention(RUNTIME) @Documented @Constraint(validatedBy = CheckEnumLegalValidator.class) public @interface CheckEnumLegal { String message() default "非法类型值"; Class&lt;? extends Enum&lt;?&gt;&gt; enumClass(); /** * 1、强制方法返回值为Boolean * 2、强制方法为静态方法 * 3、默认校验方法名 validate,后续自己设置 * 4、entity数据类型要和validate方法参数数据类型要一致 ! * 5、调用validate方法时，不能抛出异常... * 6、最好在枚举类的validate方法上,加上 @CannotDelete 注解标识下...避免被删除 {@link CannotDelete} */ String checkLegalMethodName() default "validate"; Class&lt;?&gt;[] groups() default {}; Class&lt;? extends Payload&gt;[] payload() default {}; } 另一个标识注解定义，仅标识作用「不使用枚举中的校验方法的话，还有可能会被同事给误删掉…所以我当时考虑到这种情况，就定义了这个标识注解…因为我自己看到没有任何调用链的方法 我就会删除…当然删之前 会询问下相关同事」- -
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/395a09c36687c913f90f3e563b969a0d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7392d67e92f9eec0e5023a241d58df7/" rel="bookmark">
			图解rt_hw_stack_init
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/* ***************************************************************************************** * 函数实现 开辟栈空间 ***************************************************************************************** */ /*线程栈的初始化*/ rt_uint8_t *rt_hw_stack_init(void *tentry, void *parameter, rt_uint8_t *stack_addr) { struct stack_frame *stack_frame; rt_uint8_t *stk; unsigned long i; /*获取栈顶指针 rt_hw_stack_init 在调用的时候，传给stack_addr的是栈顶指针-4*/ stk = stack_addr+sizeof(rt_uint32_t); /*让stk指针向下8字节对齐*/ stk = (rt_uint8_t *)RT_ALIGN_DOWN ((rt_uint32_t )stk,8); /*stk指针继续向下移动 sizeof(struct stack_frame)个偏移*/ stk -=sizeof (struct stack_frame ); （7） /*将sta指针强制转化为stack_frame类型后保存到stack_frame*/ stack_frame =(struct stack_frame *)stk; （8） /*以stack_frame为起始地址，将栈空间里面的sizeof（struct stack_frame)个内存初始化为0xdeadbeef*/ for(i=0;i&lt;sizeof (struct stack_frame) / sizeof (rt_uint32_t); i++) （9） { ((rt_uint32_t *)stack_frame )[i] = 0xdeadbeef; } /*初始化异常发生时自动保存的寄存器*/ （10） stack_frame-&gt;exception_stack_frame .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7392d67e92f9eec0e5023a241d58df7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12b5302fdc1b91923900cbdf674a902c/" rel="bookmark">
			阿里云服务器开放端口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		阿里云服务器开放端口 阿里云服务器默认是只开放了部分端口，我们部署自己的服务需要监听一下80，8080等端口时，就需要自己设置安全策略，本文介绍如何设置阿里云的安全组，开放需要的端口
步骤 点击阿里云的的控制台点击进入云服务器 点击进入安全组菜单，点击创建安全组按钮，添加一个新的安全组
2.进入创建新安全组页面
填写一下必要的信息，然后配置访问规则，包括入站和出站，点击手动添加一条，设置开放所有的端口，包括端口和授权对象，点击创建安全组按钮，将创建一条新的安全组
出站我们也可以配置，默认是开放了所有
3、给服务器配置安全组
找到需要配置安全组的服务器，进入到实例详情页，进入到安全组页面，点击加入安全组按钮
选择刚刚创建的安全组，点击确认就好
到此教程结束，本次设置开放了所有的端口，你可以按照你的需求来设置安全组
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/722b49d8c3707efd485cbc8c340134de/" rel="bookmark">
			用DC-DC 升压降压以及产生负电压的原理及应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、Boost和Buck电路二、实际使用1.DC-DC芯片2.DC-DC芯片产生负电压 前言 在设计电源电路时经常会用到升压降压和负电压等电路，博主结合理论知识和实际应用加上自己理解，分享这篇文章。
一、Boost和Buck电路 推荐一个B站视频：
https://www.bilibili.com/video/BV137411X7Te?from=search&amp;seid=15078284696909984405
理解Boost和Buck电路的原理楼主认为只要记住电感两端的电流不能突变，电容两端的电压不能突变。
视频中讲的很清楚了，Boost和Buck电路需要元件是一样的，只是电路的拓扑结构不同。
我们也可以发现Boost和Buck也是开关电路。
二、实际使用 1.DC-DC芯片 我们来看常用的DC-DC芯片。
结合视频不难看出这是一个boost电路，而DC-DC芯片的SW脚就是个开关。从内部分析，SW是内部MOSFET的漏极，源极连接着GND。
我们继续看内部电路，FB的电压由外部R1/R2分压决定，这个分压后的电压Vfb要和内部参考电压0.6v接近，经过error amplifier后将微小的误差放大传入PWM比较器，PWM比较强的反向输入端连接一个振荡器，振荡器输出三角波，博主认为这里起到脉冲宽度调制的作用。这样当输出电压下降的时候Vfb也下降，error amplifier的输出就变大，逻辑控制单元的输出脉冲宽度变大，导致更多的电流流经MOSFET,
这样增加输出电压。
故要求Vout * R2/(R1+R2) = Vref(0.6v)。移相过来就可以得出输出电压与两个电阻的关系。
由此推出的输出电压公式为Vout = Vref * (1+R1/R2),和输入电压无关。
2.DC-DC芯片产生负电压 产出负电压有很多种方法，变压器，电荷泵等电路都能产生负电压，可以参考下面文章。
https://www.sohu.com/a/339257386_202311
我们这里分析下用DC-DC来产生负电压。
连接到电路就这个样子
博主还见过一种方法产生负电压。降压芯片产生负电压，把原来的电压输出接地，原来的GND输出的就是负电压了。Buck电路理论上能产生任何比电源电压低的电压。当我们把输出接地时，原来的GND电压就比0v还低了。
常用Buck电路举例
芯片的内部参考电压Vref是1.21v，FB的电压Vfb要和Vref接近
直接把原来的输出接地，原来的GND就是负向输出。
Vref永远是比GND输出的电压高1.21v，让R1和R2分压后的电压值Vfb接近这个Vref，就能稳定输出负电压了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec48aa80d7d0147007c35c4197a64272/" rel="bookmark">
			vue初识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://cn.vuejs.org/v2/guide/computed.html
一、企业提高开发效率的发展历程 原生JS-&gt;jquery之类的库-&gt;前端模板引擎-&gt;Vue.js/Angular.js/React.js（能够帮助我们减少不必要的DOM模板——虚拟DOM；提高渲染效率）
二、框架和库的区别 框架：
框架是一套完整的解决方案
对项目的侵入性较大，项目如果需要更换框架，则需要重新架构整个项目。但是优点也很明显，其功能完善，提供了一整套的解决方案库（插件）
只是提供某一个小功能
对项目入侵性较小，如果某个库无法完成某些需求，可以很容易切换到其他库实现需求 三、Vue和React的相同点 利用虚拟DOM实现快速渲染轻量级响应式组件支持服务器端渲染易于集成路由工具、打包工具以及状态管理工具 四、什么是虚拟DOM 传统的web开发是利用jQuery操作DOM，这是非常耗费资源的。我们可以在JS的内存里构建类似于DOM的对象，去拼装数据，拼装完毕后，把数据整体解析，一次性插入到html里去，这就形成了虚拟DOM
五、Vue渲染 条件渲染
v-if和v-else中间不能有其他的元素，否则会报错v-if不显示时，第一次就直接不渲染，如果内容已经显示将其改为不显示，则将内容从DOM上删除；v-show不显示时就会改为display：none，但是会渲染在DOM上，反复使用的话建议用v-show，性能消耗小 列表渲染
v-for="item in lists" :key="唯一值"，先循环再进行判断 六、模板语法 &lt;h1&gt;{{msg}}&lt;/h1&gt;可反复插入&lt;h1 v-once&gt;{{msg}}&lt;/h1&gt;只插入一次，修改msg无法修改里面的值。但请留心这会影响到该节点上的其它数据绑定v-html可以插入html代码 注意：你的站点上动态渲染的任意 HTML 可能会非常危险，因为它很容易导致 XSS 攻击。请只对可信内容使用 HTML 插值，绝不要对用户提供的内容使用插值。
&lt;p&gt;{{ rawHtml }}&lt;/p&gt; &lt;p&gt;&lt;span v-html="rawHtml"&gt;&lt;/span&gt;&lt;/p&gt; v-bind绑定一个变量，可以缩写为&lt;div :id="dynamicId"&gt;&lt;/div&gt;模板中还可以写JS表达式，但每个绑定都只能包含单个表达式，所以下面的例子都不会生效。 &lt;!-- 这是语句，不是表达式 --&gt; {{ var a = 1 }} &lt;!-- 流控制也不会生效，请使用三元表达式 --&gt; {{ if (ok) { return message } }} v-on指令，用于监听 DOM 事件，&lt;a v-on:click="doSomething"&gt;&lt;/a&gt;可缩写为：&lt;a @click="doSomething"&gt;&lt;/a&gt; 动态参数
&lt;a v-bind:[attributeName]="url"&gt; ... &lt;/a&gt;这里的attributeName会被作为一个JS 表达式进行动态求值，求得的值将会作为最终的参数来使用。例如，如果你的 Vue 实例有一个 data property attributeName，其值为 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec48aa80d7d0147007c35c4197a64272/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3589d62df3ada6fb2bc1f759d9dce62/" rel="bookmark">
			vivado学习——在线调试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在线调试有多种方式，这里介绍一种快速入门的方式，添加lia核。ChipScope Pro集成逻辑分析（ILA）IP核是一个可定制的逻辑分析核，用于监视设计中的内部信号。通过在RTL设计中嵌入ILA核，可以抓取信号的实时波形，帮助我们定位问题。
点击PROJECT MANAGER中的IP Catalog，
在IP Catalog的Search中输入ila，双击Debug &amp;Verfication——Debug——ILA(Integrated Logic Analyzer)，
在General Option界面中，可以修改例化名称，也可以使用默认名称，修改探针的个数，勾选上Capture Control和Advanced Trigger，
Probe_Ports(0..4)界面修改探针的宽度，点击OK，
点击Generate，
点击OK，
点击PROJECT MANAGER——Sources——IP Sources——IP——ila_0——ila_0.veo，
ila_0.veo中是ila的例化模板，依据此模板，将ila核添加到FreDivDou.v代码中，
moduleFreDivDou(
input clk_i,
input rst_n_i,
outputdiv2_o,
outputdiv3_o,
outputdiv4_o,
outputdou2_o,
outputdou3_o
);
ila_0 your_instance_name(
.clk(dou3_o), // input wire clk
.probe0(clk_i), // input wire [0:0] probe0 .probe1(div2_o), // input wire [0:0] probe1
.probe2(div3_o), // input wire [0:0] probe2
.probe3(div4_o), // input wire [0:0] probe3
.probe4(dou2_o) // input wire [0:0] probe4
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e3589d62df3ada6fb2bc1f759d9dce62/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af4c5a968e794ee4126fd1644fc6af00/" rel="bookmark">
			数码管
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba2ca44548909c42319d0a27d8839b10/" rel="bookmark">
			Spring 中的重试机制，简单、实用！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击关注公众号，Java干货及时送达
作者：alben
来源：https://albenw.github.io/posts/69a9647f/
概要 Spring实现了一套重试机制，功能简单实用。Spring Retry是从Spring Batch独立出来的一个功能，已经广泛应用于Spring Batch,Spring Integration, Spring for Apache Hadoop等Spring项目。
本文将讲述如何使用Spring Retry及其实现原理。
背景 重试，其实我们其实很多时候都需要的，为了保证容错性，可用性，一致性等。一般用来应对外部系统的一些不可预料的返回、异常等，特别是网络延迟，中断等情况。还有在现在流行的微服务治理框架中，通常都有自己的重试与超时配置，比如dubbo可以设置retries=1，timeout=500调用失败只重试1次，超过500ms调用仍未返回则调用失败。
如果我们要做重试，要为特定的某个操作做重试功能，则要硬编码，大概逻辑基本都是写个循环，根据返回或异常，计数失败次数，然后设定退出条件。这样做，且不说每个操作都要写这种类似的代码，而且重试逻辑和业务逻辑混在一起，给维护和扩展带来了麻烦。
从面向对象的角度来看，我们应该把重试的代码独立出来。
使用介绍 基本使用 先举个例子：
@Configuration @EnableRetry public class Application { @Bean public RetryService retryService(){ return new RetryService(); } public static void main(String[] args) throws Exception{ ApplicationContext applicationContext = new AnnotationConfigApplicationContext("springretry"); RetryService service1 = applicationContext.getBean("service", RetryService.class); service1.service(); } } @Service("service") public class RetryService { @Retryable(value = IllegalAccessException.class, maxAttempts = 5, backoff= @Backoff(value = 1500, maxDelay = 100000, multiplier = 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba2ca44548909c42319d0a27d8839b10/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7642f2350f4dc7d40aeafe95df7f14a0/" rel="bookmark">
			VSCode中查看SQLite数据库数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在一个文件夹中创建三个文件：
python_sqlite.pyview.sqldate.db 在VSCode中安装SQLite插件
文件内容如下：
python_sqlite.py import sqlite3 conn = sqlite3.connect('test.db') c = conn.cursor() c.execute('''CREATE TABLE IF NOT EXISTS books (id int primary key, sort int, name text, price real)''') c.execute('''INSERT INTO books VALUES (1,1,'computer science',39.1)''') books = [ (2,2,'computer science',68), (3,2,'python science',89), (4,3,'stm32 science',78), ] c.executemany('INSERT INTO books VALUES(?,?,?,?)',books) conn.commit() conn.close() print('done') view.sql SELECT * from books 在view.sql界面下右键，运行
即可见数据库文件内容
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a52a97d034d52cc97a1ee3cd2b41dd1e/" rel="bookmark">
			mysql8.2安装教程_mysql 8.0.22压缩包完整安装与配置教程图解(亲测安装有效)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、下载zip安装包
点击此处下载MySQL server 8.0.22压缩包
下载后直接解压即可
2、解压，并配置环境变量
2.1 解压zip包到安装目录，我的解压在了D:MySQLmysql-8.0.22-winx64 2.2 配置环境变量
将解压文件夹下的bin路径添加到变量值中，前后以 ; 开头结尾
2.3 创建并配置初始化的my.ini文件
放在安装目录下
配置文件my.ini内容如下：
[mysqld]
# 设置3306端口
port=3306
# 设置mysql的安装目录
basedir=D:/MySQL/mysql-8.0.22-winx64 # 切记此处一定要用双斜杠\，单斜杠我这里会出错，或者是用单斜杠。自己尝试吧
# 设置mysql数据库的数据的存放目录
datadir=D:/MySQL/mysql-8.0.22-winx64/data # 此处同上
# 允许最大连接数
max_connections=200
# 允许连接失败的次数。这是为了防止有人从该主机试图攻击数据库系统
max_connect_errors=10
# 服务端使用的字符集默认为UTF8
character-set-server=utf8
# 创建新表时将使用的默认存储引擎
default-storage-engine=INNODB
# 默认使用“mysql_native_password”插件认证
default_authentication_plugin=mysql_native_password
[mysql]
# 设置mysql客户端默认字符集
default-character-set=utf8
[client]
# 设置mysql客户端连接服务端时默认使用的端口
port=3306
default-character-set=utf8
3、安装mysql
3.1、系统左下角，Windows徽标处右键，选择“命令提示符(管理员)”：
注意：这里必须是以“管理员身份”运行控制命令台！
3.2、在控制命令台中，进入到刚刚解压的MySQL的bin目录中：
3.3、初始化MySQL数据库
命令：mysqld --initialize-insecure
作用：初始化数据库，并设置默认root密码为空
初始化完成后，在mysql根目录中会自动生成data文件夹，如下图所示：
注意：当出现如上图所示的三个文件夹后才表示初始化完成！
3.4、为Windows系统安装MySQL服务
输入执行命令：mysqld install [服务名]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a52a97d034d52cc97a1ee3cd2b41dd1e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/898947f3f1d1065cdf01fd0f65037b7b/" rel="bookmark">
			latex超链接Argument of \Hy@setref@link has an extra }.错误解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用了\usepackage{url}来在文章中写了超链接，如\url{https://www.baidu.com/}。但是直接编译后没有颜色，就是黑色的，参考文献也是黑色的。
加入下面两句代码可以让超链接显示出颜色：
%随便用一句 \usepackage[colorlinks,linkcolor=black]{hyperref} \usepackage[hyperfootnotes=true]{hyperref} 但是报错，说是括号多了一个右花括号，其实不是。
不知道LaTeX内部原理，只知道解决方法，把后缀.aux的文件删掉再重新编译就好了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4fab0bce7683902b900f77d182d4dc1/" rel="bookmark">
			element-ui中的el-tab-pane实现显示隐藏的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		直接用v-show是不起作用的，经过查找是说v-show起作用的本质是display:none,而因为td的display: table-cell;权限高于display:none,所以v-show失效，那么要实现显示隐藏的控制可以进行使用如下的方式：
方式一：
最简单有效的用v-if取代v-show实现。
方式二：
在el-tabs标签上添加ref，通过js进行控制，具体实现如下：
例子：
&lt;el-tabs v-model="activeName" @tab-click="handleClick" ref="tabs"&gt; &lt;el-tab-pane name="20" label="选项1"&gt;&lt;/el-tab-pane&gt; &lt;el-tab-pane name="30" label="选项2"&gt;&lt;/el-tab-pane&gt; &lt;el-tab-pane name="40" label="选项3"&gt;&lt;/el-tab-pane&gt; &lt;/el-tabs&gt; 用js进行控制：
this.$nextTick(() =&gt; { this.$refs.tabs.$children[0].$refs.tabs[0].style.display = 'none'; console.log(this.$refs.tabs.$children[0].$refs); console.log(this.$refs.tabs.$children[0].$refs.tabs); }); 注：写在页面初始化时，需要mounted里面执行时，一定要写在this. n e x t T i c k 内 ， 不 然 t h i s . nextTick内，不然this. nextTick内，不然this.refs.tabs. c h i l d r e n [ 0 ] . children[0]. children[0].refs.tabs获取不到，为undefined
另：
在网上看到有用keep-alive实现的
例子：
&lt;el-tabs v-model="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a4fab0bce7683902b900f77d182d4dc1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/376dab4d66bf6091abd0d9b8c5c63ebe/" rel="bookmark">
			一个网站如何部署在两台服务器上？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一个网站可以有两台服务器
1、主服务器和备份服务器服务器备份是指针对于服务器所产生的数据信息进行相应的存储备份过程，从而保障数据的安全运行，从狭义上来看信息的价值在于其潜在用途，并会随着时间的推移而改变。数据管理和保护可攫取信息的最大价值，并规避因未按照监管法规保留信息而导致的风险。企业应对当前和将来的信息使用方式进行评估，实施满足其全部需求的流程和技术。备份方式有增量备份，完全备份，差异备份。
2、负载均衡。简单说就是主服务器访问达到饱和状态时，会把一部分访问量分散到另一台或多台服务器上进行分流。网站负载均衡(LoadBalance)建立在现有网络结构之上，它提供了一种廉价、有效、透明的方法，来扩展网络设备和服务器的带宽、增加吞吐量、加强网络数据处理能力、提高网络的灵活性和可用性。
含义：大量的并发访问或数据流量分担到多台节点设备上分别处理，减少用户等待响应的时间;其次，单个重负载的运算分担到多台节点设备上做并行处理，每个节点设备处理结束后，将结果汇总，返回给用户，系统处理能力得到大幅度提高。互联在线的门户网站“负载均衡、加速及防御解决方案包括“构建Web服务器集群实现无瓶颈负载均衡、故障容错”和“构建Web服务器集群实现无瓶颈负载均衡、南北互通、故障容错”两个解决方案和“攻击防御体系”三部分。
3、一种是镜像服务器镜像服务器与主服务器的服务内容都是一样的，只是放在一个不同的地方，分担主机的负载。简单来说就是和照镜子似的，能看，但不是原版的。在网上内容完全相同而且同步更新的两个或多个服务器，除主服务器外，其余的都被称为镜像服务器。
关于负载均衡可以参考这篇文档帮助
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27cedad0aa0fec57ff5e318a21511fb4/" rel="bookmark">
			StringBuilder用法梳理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 StringBuilder用法梳理StringBuilder概述StringBuilder类和String类的区别： StringBuilder构造方法StringBuilder的添加和反转方法StringBuilder和String相互转换 StringBuilder用法梳理 StringBuilder概述 如果对字符串进行拼接操作，每次拼接，都会构建一个新的String对象，既耗时，又浪费内存空间，而这种操作还不可避免。那么有没有一种比较好的方式可以解决这个问题呢？答案就是Java提供的StringBuilder类。
StringBuilder是一个可变的字符串类，可以把它看成是一个容器，这里的可变指的是StringBuilder对象中的内容是可变的。
StringBuilder类和String类的区别： String类：内容是不可变的
StringBuilder类：内容是可变的
StringBuilder构造方法 StringBuilder的添加和反转方法 StringBuilder和String相互转换 StringBuilder中，有两个好用的方法，.append()、.reverse()。
String中没有这两个方法，直接使用这两个方法说不可以的，只能通过转换来使用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24d9a0655b3b0d4638dbd66b350199ba/" rel="bookmark">
			「Nginx」- no resolver defined to resolve  @20210217
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题症状 Nginx的错误日志里，有如下信息：
no resolver defined to resolve example.com 问题原因 这已经和明显了，就是提示你没有定义resolver指令。
Nginx就这样，它不理会系统的DNS（/etc/resolv.conf）配置。
如果你在配置文件中使用了域名或主机名，一定要配置resolver指令。
解决方案 配置resolver指令，指定DNS服务器。
详细参考「resolver」手册。
# 在k8s中 「kubernetes dns resolver in nginx」
让它走集群的DNS：resolver kube-dns.kube-system.svc.cluster.local
这里要使用FQDN，否则容器里的/etc/resolv.conf中就要配置search指令。
关于「search」指令可以参考「In /etc/resolv.conf, what exactly does the “search” configuration option do?」一文。
相关链接 Websites show 502 Bad Gateway: no resolver defined to resolve example.com
Nginx resolver address from /etc/resolv.conf
A Quick Review of Key DNS Features
Module ngx_http_upstream_module/upstream
Module ngx_http_core_module/resolver
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50b965d5375d57b79de82c6b48710385/" rel="bookmark">
			multisim常用d触发器_请问这个符号的d触发器在multisim中的芯片代号是什么
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		8管脚的JK触发器或者D触发器芯片啊
你这种情况只能到soiseek去搜索了，只有这个网站有搜索参数的功能，比如说可以搜“8pin jk 触发器”
d触发器芯片74ls74外加电源什么作用，另外为什么它总是输出25v电压
不论什么集成电路，都必须加电源哪。估计你说的个别输入脚接到电源上了吧，那是把输入脚接到高电平了，要求加高电平时就可以接到电源上的。输出是2.5V是有问题的，查一下输出端接什么元件了吧，当输出电流稍大点的，就会把输出电压拉低了。TTL电路输出高电平时，正常情况下输出电流是微安级的，是不能带过多的负载的。
D触发器，CD4013芯片
楼主的触摸片的接触面积是多大的 还有电路是否焊接正确
怎么用一个轻触开关和D触发器设计一个简单的开关电路
D触发器可以用4013或者4069都行。如下图：个轻触开关给芯片提供触发下降源，4046作核心，三极管作为输出控制，来驱动led；
请问这个符号的d触发器在multisim中的芯片代号是什么
74ls74
请问这个符号的d触发器在multisim中的芯片代号是什么、d触发器芯片，就介绍到这里啦！感谢大家的阅读！希望能够对大家有所帮助！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd16b46b471bb70f779fb780f6916e31/" rel="bookmark">
			Anaconda出现Navigator Error的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		经常使用的Anaconda Navigator今天启动时突然出现了Navigator Error。具体错误信息为： Navigator Error An unexpected error occurred on Navigator start-up Report Please report this issue in the anaconda issue tracker Main Error expected str, bytes or os.PathLike object, not NoneType Traceback Traceback (most recent call last): File "C:\Users\Administrator\Anaconda3\lib\site-packages\anaconda_navigator\exceptions.py", line 75, in exception_handler return_value = func(*args, **kwargs) File "C:\Users\Administrator\Anaconda3\lib\site-packages\anaconda_navigator\app\start.py", line 151, in start_app window = run_app(splash) File "C:\Users\Administrator\Anaconda3\lib\site-packages\anaconda_navigator\app\start.py", line 65, in run_app window = MainWindow(splash=splash, tab_project=False) File "C:\Users\Administrator\Anaconda3\lib\site-packages\anaconda_navigator\widgets\main_window.py", line 168, in __init__ self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd16b46b471bb70f779fb780f6916e31/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bafd3daa0504e61181fee8f2ae980246/" rel="bookmark">
			sae java servlet 404_java菜鸟：动态web项目 一用servlet就404
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		两个文件：web.xml和Test.javaimport java.io.IOException;
import java.io.PrintWriter;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
public class Test extends HttpServlet{
protected void doGet(HttpServletRequest request,HttpServletResponse response)
throws ServletException ,IOException
{
PrintWriter out=response.getWriter();
out.println("
This is a servlet test."); out.flush();
}
}&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt;
web-app
PUBLIC"-//Sun Microsystems,Inc.//DTD Web Application 2.3//EN"
"http://java.sun.com/dtd/web-app_2_3.dtd"&gt;
test
index.html
index.htm
index.jsp
default.html
default.htm
default.jsp
Test
test.Test
Test
/Test
运行不出来 一直404 心塞...
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84e2f37fc2065cce48d8a9b95b55fed4/" rel="bookmark">
			java 静态块和动态块_动态块 - xzh1993 - 博客园
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在ARX中对于动态块的一些操作的接口是AcDbDynBlockReference类。这个类可以获取动态块的自定义属性名和属性值，判断当前块参照是否是动态块，并设置指定属性的值修改动态块。
构造对象
AcDbDynBlockReference类有两种构造函数：
AcDbDynBlockReference(ZcDbObjectId blockRefId);
AcDbDynBlockReference(ZcDbBlockReference* pRef);
第一个直接传入块参照的id即可创建AcDbDynBlockReference对象，便可对该块参照进行数据获取和修改。
第二个传入的是块参照的指针，如果该指针是以读打开的，该AcDbDynBlockReference对象只能进行数据读取，不能修改该块参照。
isDynamicBlock
该函数判断块参照是否是动态块。
块表记录指针
AcDbDynBlockReference对象可以得到该块参照的块表记录id(块定义Id),动态块的块定义与普通块不同，它拥有多个块定义，当你通过修改动态块的自定义属性参数，该块参照会自动创建一个新的匿名块定义。而最原始的块定义是不能修改该块参照的自定义属性。
dynamicBlockTableRecord函数得到块参照最原始的块定义id，也就是你最初创建的块定义。
anonymousBlockTableRecord函数得到当前块参照的块定义id。
得到动态块参照的自定义属性
std::map GetCustomParam(const AcDbObjectId&amp; idBlkRef)
{
std::map mapName;
AcDbDynBlockReferencePropertyArray DynBlkRefPropArray;//动态块参照属性数组
AcDbDynBlockReference DynBlkRef(idBlkRef);//动态块参照对象
DynBlkRef.getBlockProperties(DynBlkRefPropArray);
AcDbDynBlockReferenceProperty DynBlockReferenceProp;//动态块参照属性
for (int i = 0; i &lt; DynBlkRefPropArray.length(); i++)
{
DynBlockReferenceProp = DynBlkRefPropArray.at(i);
bool bShow = DynBlockReferenceProp.show();//是否在面板中显示
auto type = DynBlockReferenceProp.propertyType();//属性类型
CString strName = DynBlockReferenceProp.propertyName().kwszPtr();//属性名
if (true == bShow)
{
CString strValue;
AcDbEvalVariant value = DynBlockReferenceProp.value();//值
if (DwgDataType::kDwgText == type)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/84e2f37fc2065cce48d8a9b95b55fed4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab70bd1f2f1fd6fbfe356df5322726d2/" rel="bookmark">
			LearnOpenGL11——用Assimp库导入复杂模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载自：
https://learnopengl-cn.github.io/03%20Model%20Loading/01%20Assimp/
前言 我们的工作就是解析这些导出的模型文件以及提取所有有用的信息，将它们储存为OpenGL能够理解的格式。一个很常见的问题是，模型的文件格式有很多种，每一种都会以它们自己的方式来导出模型数据。像是Wavefront的.obj这样的模型格式，只包含了模型数据以及材质信息，像是模型颜色和漫反射/镜面光贴图。而以XML为基础的Collada文件格式则非常的丰富，包含模型、光照、多种材质、动画数据、摄像机、完整的场景信息等等。Wavefront的.obj格式通常被认为是一个易于解析的模型格式。
总而言之，不同种类的文件格式有很多，它们之间通常并没有一个通用的结构。所以如果我们想从这些文件格式中导入模型的话，我们必须要去自己对每一种需要导入的文件格式写一个导入器。很幸运的是，正好有一个库专门处理这个问题。
模型加载库 Assimp能够导入很多种不同的模型文件格式（并也能够导出部分的格式），它会将所有的模型数据加载至Assimp的通用数据结构中。当Assimp加载完模型之后，我们就能够从Assimp的数据结构中提取我们所需的所有数据了。由于Assimp的数据结构保持不变，不论导入的是什么种类的文件格式，它都能够将我们从这些不同的文件格式中抽象出来，用同一种方式访问我们需要的数据。
当使用Assimp导入一个模型的时候，它通常会将整个模型加载进一个场景(Scene)对象，它会包含导入的模型/场景中的所有数据。Assimp会将场景载入为一系列的节点(Node)，每个节点包含了场景对象中所储存数据的索引，每个节点都可以有任意数量的子节点。Assimp数据结构的（简化）模型如下：
和材质和网格(Mesh)一样，所有的场景/模型数据都包含在Scene对象中。Scene对象也包含了场景根节点的引用。场景的Rootnode（根节点）可能包含子节点（和其它的节点一样），它会有一系列指向场景对象中mMeshes数组中储存的网格数据的索引。Scene下的mMeshes数组储存了真正的Mesh对象，节点中的mMeshes数组保存的只是场景中网格数组的索引。一个Mesh对象本身包含了渲染所需要的所有相关数据，像是顶点位置、法向量、纹理坐标、面(Face)和物体的材质。一个网格包含了多个面。Face代表的是物体的渲染图元(Primitive)（三角形、方形、点）。一个面包含了组成图元的顶点的索引。由于顶点和索引是分开的，使用一个索引缓冲来渲染是非常简单的（见你好，三角形）。最后，一个网格也包含了一个Material对象，它包含了一些函数能让我们获取物体的材质属性，比如说颜色和纹理贴图（比如漫反射和镜面光贴图）。 所以，我们需要做的第一件事是将一个物体加载到Scene对象中，遍历节点，获取对应的Mesh对象（我们需要递归搜索每个节点的子节点），并处理每个Mesh对象来获取顶点数据、索引以及它的材质属性。最终的结果是一系列的网格数据，我们会将它们包含在一个Model对象中。
搭建ASSIMP环境 下载配置这种事比编程本身还麻烦…目前正在用vcpkp一键下载并配置，希望可以成功
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/064b0f5dd91cee9e4cc450c5d5b17334/" rel="bookmark">
			为什么需要配置环境变量？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境变量 环境变量（environment variables）一般是指在操作系统中用来指定操作系统运行环境的一些参数，如：临时文件夹位置和系统文件夹位置等。
环境变量是在操作系统中一个具有特定名字的对象，它包含了一个或者多个应用程序所将使用到的信息。例如Windows和DOS操作系统中的path环境变量，当要求系统运行一个程序而没有告诉它程序所在的完整路径时，系统除了在当前目录下面寻找此程序外，还应到path中指定的路径去找。用户通过设置环境变量，来更好的运行进程。
为什么需要配置环境变量？ 以Java为例。开发Java程序，需要使用JDK提供的开发工具（比如javac.exe、java.exe等命令），而这些工具在JDK的安装目录的bin目录下，如果不配置环境变量，那么这些命令只可以在该目录下执行。我们不可能把所有的java文件都放到JDK的bin目录下，所以配置环境变量的作用就是：可以使bin目录下的java相关命令可以在任意目录下使用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d075efc868a87cf272e8190f50c10511/" rel="bookmark">
			UnityGUI简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		UnityGUI简介 GUI是什么？ unityGUI全称：即使模式游戏用户交互界面（IMGUI）
在Unity中一般简称为GUI，它是一个代码驱动的UI系统。
GUI的主要作用 作为程序员的调试工具，船舰游戏内调试工具。为脚本组件创建自定义监视面板。创建新的编辑器窗口和工具以拓展Unity本身（一般作为内置游戏工具）。注意：不用用IMGUI为玩家制作UI功能。 GUI的工作原理 Unity的GUI有自己的生命周期，在继承Monobehaviour的脚本中的特殊函数中在OnGUI函数中书写GUI相关逻辑。
注意：
OnGUI是每帧执行，相当于专门绘制GUI界面的函数。一般只在其中执行GUI相关界面绘制和操作逻辑。该函数在OnDisable之前，在LateUpdate之后。只要是继承了Mono的脚本，都可以在OnGUI中绘制GUI。 GUI控件的共同点 所有的GUI控件都是GUI类的静态函数。所有的GUI控件参数列表大同小异： 位置参数：Rect参数显式文本：string参数图片参数：Texture参数综合信息：GUIContent参数，可以既有文本信息又有图片信息。自定义样式：GUIStyle参数 每一种控件都有多种重载，都是各个参数的排列组合，但所有控件一定都有位置信息和显示信息。通常采用接受返回值来保证数据更新。（只有返回值被接收了下一次程序进入GUI函数，值才会更新） 文本控件 函数名： Label，无返回值
结构： GUI.Label(Rect,内容,样式); 按钮控件 函数名： Button，按下抬起后响应一次，bool返回值。RepeatButton，按下持续响应，bool返回值。 结构： GUI.Button(Rect,内容,样式); 多选框 函数名： Toggle，点击后返回一个与传入bool值相反的bool值，bool返回值。
自定义多选框设置GUIStyle选中效果和取消效果的是normal和on normal。
结构 GUI.Toggle(Rect, bool标识, 内容, 样式); 单选框 单选框是多选框的一种特殊形式。我们使用一个int标识来处理，如下代码
private void index = 1; private void OnGUI() { if(GUI.Toggle(new Rect(0,60,100,30), index == 1, "选项1")) { index = 1; } if(GUI.Toggle(new Rect(0,100,100,30), index == 2, "选项2")) { index = 2; } if(GUI.Toggle(new Rect(0,140,100,30), index == 3, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d075efc868a87cf272e8190f50c10511/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/999d919da4b8e4d0afe51a50987b28e4/" rel="bookmark">
			java如何获取openid_java_微信公众号支付（一）如何获取用户openId，一、获取apikey,appsecret与商户号 - phpStudy...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微信公众号支付(一)如何获取用户openId
一、获取apikey,appsecret与商户号
注册公众号、商户号
二、获取用户的OpenId
1.设置【授权回调页面域名】
官方解释：用户在网页授权页同意授权给公众号后，微信会将授权数据传给一个回调页面，回调页面需在此域名下，以确保安全可靠。回调页面域名不支持IP地址。
2.用户同意授权
我是把这个url写在微信菜单下的，当进入这个页面的时候就让用户同意。注意：好像是静默授权的，用户不知道
1.url:https://open.weixin.qq.com/connect/oauth/authorize?appid=appid&amp;redirect_uri=url&amp;response_type=code&amp;scope=snsapi_userinfo&amp;state=park#wechat_redirect
参数：appid:公众号的唯一标识
redirect_uri:重定向的url,就是授权后要跳转的页面
scope:应用授权作用域
snsapi_base:不弹出授权页面，直接跳转，只能获取用户openid
snsapi_userinfo:弹出授权页面，可通过openid拿到昵称、性别、所在地
state:重定向后带的参数
2.用户同意后会产生一个code,只有分钟时间的有效期。
String code = request.getParameter("code")
3.code换openId
/**
* 常量类
* @author rory.wu
*
*/
public class Constants {
// 第三方用户唯一凭证
public static String appid = "";
// 第三方用户唯一凭证密钥
public static String appsecret = "";
//商户ID
public static String mch_id="";
//获取openId
public static String oauth_url = "https://api.weixin.qq.com/sns/oauth/access_token?appid=APPID&amp;secret=SECRET&amp;code=CODE&amp;grant_type=authorization_code";
}
/**
* 通用工具类
* @author rory.wu
* @version .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/999d919da4b8e4d0afe51a50987b28e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96338e7f97432b86ee2f887d28d31629/" rel="bookmark">
			解读：Informer——比Transformer更有效的长时间序列预测方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面
下面这篇文章的内容主要是来自发表于AAAI21的一篇最佳论文《Informer: Beyond Efficient Transformer for Long Sequence Time-Series Forecasting》。这篇文章针对Transformer存在的一系列问题，如二次时间复杂度、高内存使用率以及Encoder-Decoder的结构限制，提出了一种Informer模型来用于提高长序列的预测问题。实验验证了提出的模型优于现有的方法，并为长序列预测问题提供了新的解决方案。原论文在文末进行获取。
1
摘要
许多现实世界的应用需要长序列时间序列的预测，例如电力消耗规划等实际问题。长序列时间序列预测(Long sequence time-series forecasting，LSTF)要求模型具有较高的预测能力，即能够准确地捕捉输出与输入之间的长期依赖关系。近年来的研究表明，Transformer具有提高预测能力的潜力。然而，Transformer存在几个严重的问题，使其不能直接适用于LSTF问题，例如二次时间复杂度、高内存使用量和编码器-解码器体系结构固有的局限性。为了解决这些问题，这篇文章中设计了一种基于Transformer的LSTF模型，即Informer模型，该模型具有三个显著特征: 一种ProbSpare self-attention机制，它可以在时间复杂度和内存使用方面达到 。
self-attention机制通过将级联层输入减半来突出主导注意，并有效地处理过长的输入序列。
生成式解码器虽然概念简单，但对长时间序列序列进行一次正向操作而不是step-by-step的方式进行预测，这大大提高了长序列预测的推理速度。
最后，在4个大规模数据集上的大量实验表明，Informer方法显著优于现有方法，为LSTF问题提供了一种新的解决方案。
时间序列预测是许多领域的关键因素，如传感器网络监测、能源和智能电网管理、经济和金融a 2002)和疾病传播分析。在这些场景中，我们可以利用大量关于过去行为的时间序列数据来做出长期预测，即长序列时间序列预测。然而，现有的方法是在有限的问题设置下设计的，如预测48个点或更少，然而，越来越长的序列使模型的预测能力变得受到限制。其中，下图给出了在真实数据集上的预测结果，其中LSTM网络对某变电站逐时温度从短期(12点，0.5天)到长期(480点，20天)的预测结果。其中，当预测长度大于48点时，总体性能差距很大，即从(c)图中当预测点的数量大于48点后，MSE开始快速增大，并且推理的速度也在迅速降低。
因此，LSTF面临的主要挑战是提高预测能力，以满足日益增长的长序列需求，这需要 (a)非凡的远程对准能力和(b)对长序列输入和输出的高效操作。最近，与RNN模型相比，Transformer模型在捕获远程依赖关系方面表现出了优越的性能。自注意机制可以将网络信号的最大传播路径长度减小到理论最短的O(1)，避免了递归结构，因此变压器在LSTF问题上表现出很大的潜力。但另一方面，自我注意机制违背了(b)的要求，因为它的L-二次计算和L长度输入/输出的内存消耗。一些大规模的变压器模型耗费大量资源，在NLP任务上产生了令人印象深刻的结果(Brown et al. 2020)，但数十个gpu的训练和昂贵的部署成本使这些模型在现实世界的LSTF问题上无法负担。自注意机制和变压器框架的有效性成为其应用的瓶颈对LSTF问题
这篇文章中，作者针对Transformer模型，提出了下面的问题，即能否改进Transformer模型，使其计算、内存和体系结构更高效，同时保持更高的预测能力?其中Transformer模型主要存在下面三个问题：
self-attntion机制的二次计算复杂度。self-attention机制的点积操作使每层的时间复杂度和内存使用量为 。
对长输入进行堆叠时的内存瓶颈。J个encoder-decoder层的堆栈使总内存使用量为 ，这限制了模型在接收长序列输入时的可伸缩性。
预测长期产出的速度骤降。Transformer的动态decoding会导致step-by-step的推理非常慢。
为此目的，这篇文章的工作明确地探讨了这三个问题。首先，作者研究了self-attention机制中的稀疏性，改进了网络组件，并进行了广泛的实验。文章的所有contributions总结如下：
提出了Informer，成功地提高了LSTF问题的预测能力，这验证了类Transformer模型在捕获长序列时间序列输出和输入之间的个体长期依赖性方面的潜在价值。
提出了PorbSpare self-attention机制来有效地替代规范的self-attention机制，实现了 时间复杂度和 内存使用。
提出了在J-stacking层中以操作主导注意的self-attention提取方法，并将空间复杂度大幅降低到 。
提出生成式Decoder获取长序列输出，只需向前一步输出，避免了误差的积累。
2
模型介绍
文中提出的模型的整体框架如下图所示，可以看出提出的Informer模型仍然保存了Encoder-Decoder的架构：
首先，整个问题被定义为如下的方式，即t时刻的输入数据为：
目的是预测相应的输出数据，即：
而对于LSTF问题，输出序列的长度 要求更长。
Self-attention mechanism
首先，传统的self-attention机制输入形式是 ，然后进行scaled dot-product，即：
其中，
第i个Query的attention系数的概率形式是：
self-attention机制要求二次时间复杂度的点积运算来计算上面的概率 ，计算需要 的空间复杂度。因此，这是提高预测能力的主要障碍。另外，之前的研究发现，self-attention的概率分布具有潜在的稀疏性，并对所有的 都设计了一些“选择性”的计数策略，而不显著影响性能。因此，作者首先对典型的self-attention的学习模式进行定性评估。“稀疏性” self-attention的分布呈长尾分布，即少数点积对主要注意有贡献，其他点积对可以忽略。那么，下一个问题是如何区分它们？
为了度量query的稀疏性，作者用到了KL散度。其中第i个query的稀疏性的评价公式是：
其中第一项是 对于所有的key的Log-Sum-Exp (LSE)，第二项是它们的算数平均值。
基于上面的评价方式，就可以得到ProbSparse self-attetion的公式，即：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96338e7f97432b86ee2f887d28d31629/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e308e419dff82a46e2cb3e5ecd0764c5/" rel="bookmark">
			java 数组的存储结构体_结构体数组java 中几种常用数据结构 Java中有几种常用(2)...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2.java中用到链表举例
LinkedList linkedList = new LinkedList();
创建一个空链表，然后linkedList 链表可以使用add()方法向这个链表依次增加节点。
linkedList.add(“I”);
linkedList.add(“Iove”);
linkedList.add(“it”);
linkedList.add(“so”);
linkedList.add(“much”);
linkedList可以使用方法public Object get(index i)获取第i个节点存储的数据。
二。散列表(哈希表)
1.为什么使用散列表？
对于数组和链表这两种数据结构，如果要查找它们存储的某个特定元素却不知道它的位置，就需要从头开始访问元素直到找到匹配的为止；如果数据结构中包含很多的元素，就会浪费时间。这时最好使用散列表来存储要查找的数据。
JAVA里几种数据结构的优点和缺点
一般大家都知道ArrayList和LinkedList的大致区别：
1.ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。
2.对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。
3.对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。
这一点要看实际情况的。若只对单条数据插入或删除，ArrayList的速度反而优于LinkedList。但若是批量随机的插入删除数据，LinkedList的速度大大优于ArrayList. 因为ArrayList每插入一条数据，要移动插入点及之后的所有数据。
4.查找操作indexOf，lastIndexOf，contains等，两者差不多。
5.随机查找指定节点的操作get，ArrayList速度要快于LinkedList.
Set是最简单的一种集合。集合中的对象不按特定的方式排序，并且没有重复对象。 Set接口主要实现了两个实现类：
HashSet： HashSet类按照哈希算法来存取集合中的对象，存取速度比较快
TreeSet ：TreeSet类实现了SortedSet接口，能够对集合中的对象进行排序。结构体数组
Set 的用法：存放的是对象的引用，没有重复对象
List的特征是其元素以线性方式存储，集合中可以存放重复对象。
List接口主要实现类包括：
ArrayList() ： 代表长度可以改变得数组。可以对元素进行随机的访问，向ArrayList()中插入与删除元素的速度慢。
LinkedList()： 在实现中采用链表数据结构。插入和删除速度快，访问速度慢。
对于List的随机访问来说，就是只随机来检索位于特定位置的元素。 List 的 get(int index) 方法放回集合中由参数index指定的索引位置的对象，下标从“0” 开始。最基本的两种检索集合中的所有对象的方法。
本文来自电脑杂谈，转载请注明本文网址：
http://www.pc-fly.com/a/jisuanjixue/article-68563-2.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09e9f99f54f17364fb704e6e2195aeae/" rel="bookmark">
			java 判断是否整形_java判断是否基本类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基本类型：
Java的基本类型有八种：int, double, float, long,
short, boolean, byte, char， void.
基本类型属于Class的一个子集。
因此：
.isPrimitive()是用来判断是否是基本类型的：void.isPrimitive() //true;
.class用来返回该类的Class对象的实例：int.class ==
intclass //基本类型
int.class.isPrimitive //true
Integer.class == Integer //包装类
Integer.class.isPrimitive //false
.TYPE是返回基本类型的Class实例,所以：int.class ==
Integer.TYPE //true;
除了int Integer，类似的有 float Float; double
Double; string String等。
基本类存储在栈中，包装类村住在堆中，栈是LIFO(后进先出)，基本类的存取速度更快。
JAVA 虚机自动完成基本类与包装类的转换
基本类型的包装类都采用final修饰方法，因此无法继承它们扩展的新类，也无法重写它们的方法。
包装类：
包装类是基本类的扩展
int i=2， Integer i = new Integer(2);
其实这个过程是由自动转换的，定义了int i=2就不用关心将其转换为包装类的过程。这就是为什么基本类型不需要new，例如 int i
= new int() i =2;是多余的。
此外，HashMap
ArrayList等不能将基本类加入其中，而只能加入包装类。一个典型的实例：
Map
Object&gt; testMap = new HashMap
Object&gt;();就是错误的
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/09e9f99f54f17364fb704e6e2195aeae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/985c1980e1e61eb2f5b56b405bb37fa1/" rel="bookmark">
			java aviator_Aviator 表达式求值引擎开源框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介¶
Aviator是一个高性能、轻量级的java语言实现的表达式求值引擎，主要用于各种表达式的动态求值。现在已经有很多开源可用的java表达式求值引擎，为什么还需要Avaitor呢？
Aviator的设计目标是轻量级和高性能，相比于Groovy、JRuby的笨重，Aviator非常小，加上依赖包也才450K,不算依赖包的话只有70K；当然，Aviator的语法是受限的，它不是一门完整的语言，而只是语言的一小部分集合。
其次，Aviator的实现思路与其他轻量级的求值器很不相同，其他求值器一般都是通过解释的方式运行，而Aviator则是直接将表达式编译成Java字节码，交给JVM去执行。简单来说，Aviator的定位是介于Groovy这样的重量级脚本语言和IKExpression这样的轻量级表达式引擎之间。
特性¶
Aviator的特性
支持大部分运算操作符，包括算术操作符、关系运算符、逻辑操作符、正则匹配操作符(=~)、三元表达式?: ，并且支持操作符的优先级和括号强制优先级，具体请看后面的操作符列表。
支持函数调用和自定义函数
支持正则表达式匹配，类似Ruby、Perl的匹配语法，并且支持类Ruby的$digit指向匹配分组。
自动类型转换，当执行操作的时候，会自动判断操作数类型并做相应转换，无法转换即抛异常。
支持传入变量，支持类似a.b.c的嵌套变量访问。
性能优秀
Aviator的限制：
没有if else、do while等语句，没有赋值语句，仅支持逻辑表达式、算术表达式、三元表达式和正则匹配。
没有位运算符
整体结构¶
Aviator的结构非常简单，一个典型的求值器的结构
依赖包¶
使用手册¶
执行表达式¶
Aviator的使用都是集中通过com.googlecode.aviator.AviatorEvaluator这个入口类来处理，最简单的例子，执行一个计算1+2+3的表达式：
importcom.googlecode.aviator.AviatorEvaluator;publicclassSimpleExample{publicstaticvoidmain(String[]args){Longresult =(Long)AviatorEvaluator.execute("1+2+3");System.out.println(result);}}
细心的朋友肯定注意到结果是Long，而不是Integer。这是因为Aviator的数值类型仅支持Long和Double，任何整数都将转换成Long，任何浮点数都将转换为Double，包括用户传入的变量数值。这个例子的打印结果将是正确答案6。
使用变量¶
想让Aviator对你say hello吗？很简单，传入你的名字，让Aviator负责字符串的相加：
importcom.googlecode.aviator.AviatorEvaluator;publicclassSayHello{publicstaticvoidmain(String[]args){if(args.length &lt;1){System.err.print("Usesage: Java SayHello yourname");}Stringyourname =args[0];Mapenv =newHashMap();env.put("yourname",yourname);Stringresult =(String)AviatorEvaluator.execute(" 'hello ' + yourname ",env);System.out.println(result);}}
上面的例子演示了怎么向表达式传入变量值，表达式中的yourname是一个变量，默认为null，通过传入Map的变量绑定环境，将yourname设置为你输入的名称。env的key是变量名，value是变量的值。
上面例子中的'hello '是一个Aviator的String，Aviator的String是任何用单引号或者双引号括起来的字符序列，String可以比较大小(基于unicode顺序)，可以参与正则匹配，可以与任何对象相加，任何对象与String相加结果为String。String中也可以有转义字符，如/n、//、/'等。
AviatorEvaluator.execute(" 'a/"b' ");//字符串 a'bAviatorEvaluator.execute(" /"a/'b/" ");//字符串 a"bAviatorEvaluator.execute(" 'hello'+3 ");//字符串 hello 3AviatorEvaluator.execute(" 'hello '+ unknow ");//字符串 hello null
调用函数¶
Aviator支持函数调用，函数调用的风格类似lua，下面的例子获取字符串的长度：
AviatorEvaluator.execute("string.length('hello')");
string.length('hello')是一个函数调用，string.length是一个函数,'hello'是调用的参数。
再用string.substring来截取字符串：
AviatorEvaluator.execute("string.contains(/"test/",string.substring('hello',1,2))");
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/985c1980e1e61eb2f5b56b405bb37fa1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22d7d9f1a3f5e9b1e5e96dc74bf46fae/" rel="bookmark">
			2021Hackbar免费安装使用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文件地址:
链接：https://pan.baidu.com/s/1tGJxLndjrO6HaePgjkdfTw
提取码：7ffn
下载压缩包后解压文件,进入chrome://extensions/，选择开发者模式拖入解压后的文件。
开启hackbar后进入网页，F12即可看到hackbar选项
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d319c7dbeaf7e4de60d6c3ad5281d263/" rel="bookmark">
			java web容器_Java Web容器的启动过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java web容器的启动与处理请求的过程
1.启动一个web项目的时候，web容器回去读取它的配置文件web.xml，读取结点。
2.容器创建一个servletContext(Servlet上下文)，这个web项目的所有部分都将共享这个上下文。
3.容器将转换为键值对，并交个ServletContext。因为listener，filter等组件在初始化时会用到这些上下文的信息，所以要先加载。
4.容器创建的类实例，创建监听器。
5.加载filter和servlet
load-on-startup元素在-web应用启动的时候指定了servlet被加载的顺序，它的值必须是一个整数。如果它的值是一个负整数或者这个元素不存在，那么容器会在该servlet被调用的时候加载这个servlet。如果值是正整数或0，容器在配置的时候就加载并初始化这个servlet。容器必须保证值小的先被加载，如果值相等，容器可以自动选择加载谁。
web.xml的加载顺序是：Context--param--listener--filter--servlet
容器处理请求的过程
当web容器接收到来自客户端的请求信息后，会根据url中的web元件地址信息到servlet队列中查找对应的servlet对象，如果找到则直接使用，如果没有找到则加载对应的类，并创建对象。也就是说，servlet对象是在第一次被使用的时候才创建的，并且一旦创建就会被反复使用，不再创建新的对象。所有创建的servlet对象会在web服务器停止运行的时候，统一进行垃圾回收。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8aa5907dbd003353d55261c0ee2c5c7a/" rel="bookmark">
			java string做除法_如果用java来实现传统方式的除法，用String来保存结果，想精确多少位都行，那改怎么做？...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我会加分的，提个思路都行，目前做了个乘法和加法，但是现在对除法没有什么思路。以下是我编写的功能：publicclassCalculator{publicstaticStringmulti(Strings1,Strings2){if(s1==nu...
我会加分的，提个思路都行，目前做了个乘法和加法，但是现在对除法没有什么思路。以下是我编写的功能：
public class Calculator {
public static String multi(String s1,String s2){
if(s1 == null || s2 == null){
return "0";
}
char c1[] = s1.toCharArray();
char c2[] = s2.toCharArray();
for(int i=0;i
if(i==0){
if(c1[i] !='-' &amp;&amp; c1[i] != '+' &amp;&amp; !(c1[i]&gt;='0' &amp;&amp; c1[i]&lt;='9')){
throw new RuntimeException("你要计算的数字不合法！");
}
}else{
if(!(c1[i]&gt;='0' &amp;&amp; c1[i]&lt;='9')){
throw new RuntimeException("你要计算的数字不合法！");
}
}
}
for(int i=0;i
if(i==0){
if(c2[i] !='-' &amp;&amp; c2[i] != '+' &amp;&amp; !(c2[i]&gt;='0' &amp;&amp; c2[i]&lt;='9')){
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8aa5907dbd003353d55261c0ee2c5c7a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3089ad0892cb60589a46542df5c0ec2f/" rel="bookmark">
			Java display name_Java 编码规范 StandardCharsets.UTF_8 三个方法 toString() name() displayName()，到底用哪个方法更合适？...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		想用StandardCharsets.UTF_8 返回"UTF-8"这个字符，测试一下，三个方法toString() name() displayName()，均能返回"UTF-8",到底用哪个方法更健壮？
public final String name()
Returns this charset's canonical(正式的) name.
=========================================
public String displayName()
Returns this charset's human-readable(便于人类可阅读的) name for the default locale.
The default implementation of this method simply returns this charset's canonical name. Concrete subclasses of this class may override this method in order to provide a localized display name.
==========================================
public final String toString()
Returns a string describing this charset.
==========================================
一分析，自然是name displayName比toString更合适，二选一，找区别自然选择name，因为我是要给程序传递参数，而不是输出给人机界面。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3089ad0892cb60589a46542df5c0ec2f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0e595bdb2dc23c3701be69a70bf80f2/" rel="bookmark">
			java 逃逸_Java 逃逸分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是逃逸分析？
关于 Java 逃逸分析的定义：
逃逸分析(Escape Analysis)简单来讲就是，Java Hotspot 虚拟机可以分析新创建对象的使用范围，并决定是否在 Java 堆上分配内存的一项技术。
逃逸分析的 JVM 参数如下：开启逃逸分析：-XX:+DoEscapeAnalysis
关闭逃逸分析：-XX:-DoEscapeAnalysis
显示分析结果：-XX:+PrintEscapeAnalysis
逃逸分析技术在 Java SE 6u23+ 开始支持，并默认设置为启用状态，可以不用额外加这个参数。
逃逸分析算法
Java Hotspot 编译器实现下面论文中描述的逃逸算法：
[Choi99] Jong-Deok Choi, Manish Gupta, Mauricio Seffano,
Vugranam C. Sreedhar, Sam Midkiff,
"Escape Analysis for Java", Procedings of ACM SIGPLAN
OOPSLA Conference, November 1, 1999
根据 Jong-Deok Choi, Manish Gupta, Mauricio Seffano,Vugranam C. Sreedhar, Sam Midkiff 等大牛在论文《Escape Analysis for Java》中描述的算法进行逃逸分析的。
该算法引入了连通图，用连通图来构建对象和对象引用之间的可达性关系，并在次基础上，提出一种组合数据流分析法。
由于算法是上下文相关和流敏感的，并且模拟了对象任意层次的嵌套关系，所以分析精度较高，只是运行时间和内存消耗相对较大。
对象逃逸状态
我们了解了 Java 中的逃逸分析技术，再来了解下一个对象的逃逸状态。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e0e595bdb2dc23c3701be69a70bf80f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8589277074556ee2ed13b84f48d618c1/" rel="bookmark">
			java jdbc 注解_Spring Java 注解配置之 数据源配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用的数据源为：阿里的Druid数据源，mysql-connect版本是8.x.x，在查询上使用的是MyBatis，并配置了：PageHelper(分页拦截器)、通用Mapper。
需要配置jdbc.properties文件：
jdbc.driverClass=com.mysql.cj.jdbc.Driver
jdbc.url=jdbc:mysql://127.0.0.1:3306/schema?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=Asia/Shanghai&amp;useSSL=false&amp;nullCatalogMeansCurrent=true
jdbc.username=root
jdbc.password=root
注：在使用mysql-connect 8.+以上版本的时候需要添加nullCatalogMeansCurrent=true参数，否则在使用mybatis-generator生成表对应的xml等时会扫描整个服务器里面的全部数据库中的表，而不是扫描对应数据库的表。
JAVA配置类:
@Configuration
@EnableTransactionManagement
@ComponentScan("cn.virens.database.serviceimpl")
public class SpringDataSourceConfig {
@Value("${jdbc.url}")
private String jdbcUrl;
@Value("${jdbc.username}")
private String jdbcUsername;
@Value("${jdbc.password}")
private String jdbcPassword;
@Value("${jdbc.driverClass}")
private String jdbcDriverClass;
/**
* mysql事务管理
*
* @return
*/
@Bean(name = "txManager")
public PlatformTransactionManager txManager(@Qualifier("druidDataSource") DruidDataSource druidDataSource) {
return new DataSourceTransactionManager(druidDataSource);
}
@Bean(name = "txExecute")
public TransactionExecute txExecute(@Qualifier("txManager") PlatformTransactionManager manager) {
return new TransactionExecute(manager);
}
/**
* MyBatis 数据连接地址池配置
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8589277074556ee2ed13b84f48d618c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb729e6725eb79ce863367f4898b035c/" rel="bookmark">
			SpringBoot集成Apollo实现Druid动态数据源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一：SpringBoot集成Apollo 首先在pom中引入apollo。
&lt;!-- apollo --&gt; &lt;dependency&gt; &lt;groupId&gt;com.ctrip.framework.apollo&lt;/groupId&gt; &lt;artifactId&gt;apollo-client&lt;/artifactId&gt; &lt;version&gt;1.1.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.ctrip.framework.apollo&lt;/groupId&gt; &lt;artifactId&gt;apollo-core&lt;/artifactId&gt; &lt;version&gt;1.1.0&lt;/version&gt; &lt;/dependency&gt; 如果是windows系统，需要在C盘创建opt文件夹，然后在创建settings文件夹，然后加入server.properties文件，内容：env=DEV，这个发布到生产后，换成生产。经过测试，不创建这个文件也没有什么问题。
成功后，apollo发布后，会在opt文件夹中出现一个data文件夹，这个文件夹中就是apollo生成的文件。
里面的内容大体上为：
这个就是在apollo中配置的。
然后进行application.yml的配置：
spring: thymeleaf: prefix: classpath:/templates/ suffix: .html mode: LEGACYHTML5 encoding: UTF-8 cache: false resources: chain: strategy: content: enabled: true paths: /** mvc: static-path-pattern: /static/** datasource: type: com.alibaba.druid.pool.DruidDataSource # 下面为连接池的补充设置，应用到上面所有数据源中 # 初始化大小，最小，最大 initialSize: 1 maxActive: 20 # 配置获取连接等待超时的时间 maxWait: 60000 # 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 timeBetweenEvictionRunsMillis: 60000 # 配置一个连接在池中最小生存的时间，单位是毫秒 minEvictableIdleTimeMillis: 30000 validationQuery: select 'x' testWhileIdle: true testOnBorrow: false testOnReturn: false # 打开PSCache，并且指定每个连接上PSCache的大小 poolPreparedStatements: true maxPoolPreparedStatementPerConnectionSize: 20 # 配置监控统计拦截的filters，去掉后监控界面sql无法统计，'wall'用于防火墙 filters: stat,wall,slf4j # 通过connectProperties属性来打开mergeSql功能；慢SQL记录 connectionProperties: druid.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb729e6725eb79ce863367f4898b035c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfa322c8aba00572ce904c08ea86d1d0/" rel="bookmark">
			java计算字符串中子串出现的次数_java计算字符串中子串出现的次数_java判断字符串中某个字符出现的次数...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天一个同学对我说老师布置了一个作业让编写一个计算字符串中子串出现的次数的程序，接下来吾爱编程就为大家介绍一下计算字符串中子串出现的次数的方法，有需要的小伙伴可以参考一下：
1、题目如下：
输入两个字符串，计算第二个字符串在以一个字符串出现的次数
2、程序代码：public static void main(String[] args) {
Scanner sc = new Scanner(System.in);
System.out.println("输入字符串:");
String str = sc.nextLine();
System.out.println("输入子字符串:");
String substr= sc.nextLine();
int count = 0, pos = 0;
while (str.indexOf(substr, pos) &gt;= 0 &amp;&amp; pos count++;
pos = str.indexOf(substr, pos) + substr.length(); // 得到新的start值。
}
System.out.println("子串出现的次数" + count);
}
以上就是吾爱编程为大家介绍的关于java计算字符串中子串出现的次数的方法，了解更多相关文章请关注吾爱编程网！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d7465843e2923c4ba4823518ed6dbee/" rel="bookmark">
			最小二乘法笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最小二乘法 （又称 最小平方法 ）是一种 数学 优化 技术。
它通过最小化 误差 的平方和寻找数据的最佳 函数 匹配。
利用 最小二乘法 可以简便地求得未知的数据，并使得这些求得的数据与实际数据之间误差的平方和为最小。
看了之后一头雾水对不对，下面举个例子，就很好懂了。
针对线性最小二乘法即直线拟合，如下图（来自维基百科）所示：
透过这张图，我想大家一定能理解，我们用最小二乘法来做什么事情，即：
根据已有的数据（图中的点），来做出一条最贴近数据发展趋势的直线。
通过这条直线，我们可以对未来的数据进行预测，因为基本会落在这条直线附近。
当然了，最小二乘法不只是直线，还可以是曲线，本文不讨论。
3. 求解直线方程 我们现在要做的，就是求解直线方程。
假设已知有N个点，设这条直线方程为： y = a·x + b
其中，a和b的计算公式如下：
本文对于推导过程不再赘述，网上都有。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e3892b20dc3b091c22f6a22e68ef30c/" rel="bookmark">
			踩坑(已解决)：Windows系统Dart SDK下载安装与使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		踩坑(已解决)：Windows系统Dart SDK下载安装与使用 前言：本人web前端实习生一枚，尚未毕业(今年6月毕业)，第一次在CSDN写文章，可能文笔不好，但我尽量做到内容清晰，一目了然。写这篇文章一是记录学习过程中遇到的问题，二是希望这篇文章对大家有所帮助。
一、踩坑过程 今年公司开发app将采用前端与安卓联合开发，所以在b站找了一个视频学习dart和flutter。
（1）第一次安装失败 跟着视频进入dart的官网https://dart.dev/get-dart，老师不推荐用命令行安装(原因没说，欢迎评论区补充)。
然后就跟着老师的步骤进入了https://gekorm.com/dart-windows/这个网址去下载Dart的SDK，然后解压，安装。安装过程极慢(几个小时)，等安装到80%时，突然弹出提示：无法连接服务器，安装失败QAQ
百度搜索 “dart软件安装提示无法连接服务器” 发现没有相关文章×
（2）第二次安装失败 在CSDN中找相关文章。第一个连接是百度网盘下载，解压，安装都很顺利，然后配置环境变量，在dos窗口下输入dart --version检查是否安装成功，结果一直提示dart不是内部命令，所以又一次安装失败了
（3）第三次安装失败 又百度了一篇博客，镜像下载(图中第一个箭头)，同上，也是在dos窗口下输入dart --version检查，结果一直提示dart不是内部命令，所以又又一次安装失败了
二、解决下载安装的问题 进入此网址https://dart.dev/tools/sdk/archive，点击箭头所指链接进行下载，安装，配置环境。在dos窗口输入命令，出现版本号，安装成功！
三、使用dart编写代码 （1）打开vscode，安装code runner和dart两个插件 （2）创建后缀为.dart的入口文件 （3）编写入口函数 注意：dart语言和C语言一样严谨，所以要加分号；
我特意说分号这件事是因为写前端代码时，加不加分号全看个人喜好！为了防止有些小伙伴在写dart时习惯性的不加分号导致报错。
（4）运行 右键选择run code
下方控制台输出结果：
如果输出结果一开始有乱码的情况，就重启一下vscode
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a647616960aace4e9ac4d1270a8274e2/" rel="bookmark">
			广度优先搜索java_图论广度优先搜索
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于图遍历
图遍历即图的遍历，指从图中任一顶点出发，对图中的所有顶点访问一次。图的遍历与树的遍历相似，但图的结构更加复杂，比如要考虑回路的情况。图的遍历操作是一种基本操作，很多其他操作都建立在图遍历基础之上。图的遍历算法主要有广度优先搜索和深度优先搜索，这里先看广度优先搜索。
广度优先搜索
广度优先搜索(Breadth First Search)，简称BFS，又称宽度优先搜索。它是很多图的算法的原型，Dijkstra单源最短路径算法和Prim最小生成树算法的思想都与BFS的思想类似。BFS的时间复杂度为$O(∣V∣+∣E∣)$，其中 $∣V∣$ 为图的顶点数，$∣E∣$ 为图的边数。
核心思想
选择一个初始顶点$v_i$​，并将其标记为已访问；
访问$v_i$的所有未被访问过的邻接点$v_{i1},v_{i2},...,v_{it}$，并均标记为已访问；
按照$v_{i1},v_{i2},...,v_{it}$的顺序，依次访问每一个顶点的所有未被访问过的邻接点，并均标记为已访问；
以此类推，直到图中所有与初始顶点$v_i$​有路径相通的顶点都被访问；
如果图中的顶点还有未被访问的，则再选出其中一个作为起始顶点，继续执行步骤2到步骤4；
遍历结束。
搜索过程
在实现过程中需要用到一个队列和一个数组，队列用于保存所有未被检测的顶点，而数组用于标识哪些顶点已被访问，F表示未被访问，T表示已被访问。
对于一个拥有7个顶点的无向加权图，分别用0-6来表示图的每个顶点，因为遍历与边的权重无关，这里将权重值省略。
选择1作为初始顶点，将其加入队列中，队列头即是正在处理的顶点，并将数组对应元素标为T。
开始检测顶点1的每条边，首先是到达顶点0的边，
因为顶点0的访问标记为F，说明还未被访问过，于是将0加入到BFS队列中，同时将访问标记改为T。
继续检测顶点1的其它边，这次是到达顶点2的边，
因为顶点2的访问标记为F，说明还未被访问过，于是将2加入到BFS队列中，同时将访问标记改为T。
继续检测顶点1的其它边，这次是到达顶点3的边，
因为顶点3的访问标记为F，说明还未被访问过，于是将3加入到BFS队列中，同时将访问标记改为T。
顶点1的所有边已经被访问过了，于是从BFS队列中将1移除，接着处理下一个顶点，即顶点0。
检测顶点0的每条边，首先是到达顶点1的边，
因为顶点1的访问标记为T，说明已经被访问过，BFS队列和数组都不做任何更改。
继续检测顶点0的其它边，这次是到达顶点2的边，因为顶点2的访问标记为T，说明已经被访问过，BFS队列和数组都不做任何更改。
顶点0的所有边已经被访问过了，于是从BFS队列中将0移除，接着处理下一个顶点，即顶点2。
检测顶点2的每条边，首先是到达顶点0的边，因为顶点0的访问标记为T，说明已经被访问过，BFS队列和数组都不做任何更改。
继续检测顶点2的其它边，这次是到达顶点1的边，因为顶点1的访问标记为T，说明已经被访问过，BFS队列和数组都不做任何更改。
继续检测顶点2到顶点3的边，因为顶点3的访问标记为T，说明已经被访问过，BFS队列和数组都不做任何更改。
继续检测顶点2到顶点4的边，
因为顶点4的访问标记为F，说明还未被访问过，于是将4加入到BFS队列中，同时将访问标记改为T。
继续检测顶点2到顶点5的边，
因为顶点5的访问标记为F，说明还未被访问过，于是将5加入到BFS队列中，同时将访问标记改为T。
顶点2的所有边已经被访问过了，于是从BFS队列中将2移除，接着处理下一个顶点，即顶点3。
顶点3相邻的所有顶点(1、2、4、5)的访问标记都为T，BFS队列和数组都不做任何更改。继续处理顶点4。
此时顶点2和顶点3的访问标记都为T，BFS队列和数组都不做任何更改。当检测顶点4到顶点6时，
因为顶点6的访问标记为F，说明还未被访问过，于是将6加入到BFS队列中，同时将访问标记改为T。
顶点4的所有边已经被访问过了，于是从BFS队列中将4移除，接着处理下一个顶点，即顶点5。顶点5相邻的所有顶点(2、3、6)的访问标记都为T，BFS队列和数组都不做任何更改。
顶点5的所有边已经被访问过了，于是从BFS队列中将5移除，接着处理下一个顶点，即顶点6。顶点6相邻的所有顶点(4、5)的访问标记都为T，BFS队列和数组都不做任何更改。
最终的结果如下。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7ac7a8218a54412996c546277cdf997/" rel="bookmark">
			java 判断基本类型_java怎么判断为基本类型??
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个方法判断指定的 Class 对象是否表示一个基本类型或者void类型，为什么要把void放到这个方法中我也不太清楚，如果Class对象为表示八个基本类型和void则为true，否则false。所以以后我们可以直接使用这个方法来判断对象是不是基本类型。注意基本类型的包装类不属于基本类型，调用这个方法的返回值为false。
实例如下：
//基本类型判断
System.out.println( BigDecimal.class.isPrimitive());
System.out.println(int.class.isPrimitive());
System.out.println(void.class.isPrimitive());
System.out.println( TestBigdecimal.class.isPrimitive());
System.out.println(Class.class.isPrimitive());
运行结果：false
true
true
false
false
我们也来扩展一下其他的知识点。
(2)class类也提供了判断是不是数组类型方法isArray()。
(3)getName()返回此 Class对象表示的实体名称。
如果此类对象表示的引用类型不是数组类型，则返回该类的二进制名称
如果此类对象表示基本类型或void，则返回的名称是一个 String 字符串
如果此类对象表示一类数组，则名称的内部形式由元素类型的名称组成，其后一个或多个“[”字符表示数组的深度嵌套。
关于第三点中说的元素类型，列出来一张元素类型表：
元素类型
编码
boolean
Z
byte
B
char
C
class or interface
Lclassname;
double
D
float
F
int
I
long
J
short
S
实例如下：
//getName
long[] a2 = new long[] {1,2,3,4};
String[] a3= new String[] {"1","2","3","4"};
System.out.println(Integer.class.getName());
System.out.println(a1.getClass().getName());
System.out.println(a2.getClass().getName());
System.out.println(a3.getClass().getName());
System.out.println(int.class.getName());
System.out.println(String.class.getName());
List str =Arrays.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c7ac7a8218a54412996c546277cdf997/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cca049870b5f654255ca735d81045546/" rel="bookmark">
			RNN循环神经网络  学习总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 循环神经网络（Recurrent Neural Network, RNN）是一类以序列（sequence）数据为输入，在序列的演进方向进行递归（recursion）且所有节点（循环单元）按链式连接的递归神经网络。双向循环神经网络（Bidirectional RNN, Bi-RNN）和长短期记忆网络（Long Short-Term Memory networks，LSTM）是常见的循环神经网络。
循环神经网络具有记忆性、参数共享并且图灵完备（Turing completeness），因此在对序列的非线性特征进行学习时具有一定优势 [4] 。循环神经网络在自然语言处理（Natural Language Processing, NLP），例如语音识别、语言建模、机器翻译等领域有应用，也被用于各类时间序列预报。
LSTM Sequence-to-sequence 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe6dc724660f0a3cd5dd32a86370d647/" rel="bookmark">
			ABP中IdentityServer持久化数据库表结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IdentityServerClients 存储client_credentials授权模式的客户端基本信息。
IdentityServerClientRedirectUris 登录成功后重定向的地址。
IdentityServerClientPostLogoutRedirectUris 注销后重定向的地址。
IdentityServerClientCorsOrigins 跨域（CORS）时，请求来自的域
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/382/">«</a>
	<span class="pagination__item pagination__item--current">383/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/384/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>