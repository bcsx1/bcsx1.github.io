<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4af03a7fa44ade221bc3ad232622a2d/" rel="bookmark">
			MQ的一些理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前言 最近愈发觉得MQ的重要与强大，在此记录一下MQ的简单理解。
首先，MQ是什么？
**消息队列（Message Queue）：**这是计算机科学中常见的概念，用于在分布式系统中传递消息的一种方式。消息队列将消息存储在一个队列中，使得发送者和接收者可以异步地进行通信。一些流行的消息队列系统包括 RabbitMQ 和 Apache Kafka。这两种MQ基本能够满足我们日常开发需求，两者也没有孰强孰弱的说法，只能是各有特设，不同场景需求下选择也当不同。
1.为什么要用MQ 1.1解耦系统组件 举个例子，有ABCDE，五个系统，其中BCD三个系统都要获取A的接口信息才能执行，所以每次运行BCD都需要先请求A，等待A返回后才可继续执行，如果系统D现在不需要接口A的信息了，那么我们需要修改系统A的代码，又或者说再来个系统E，需要依赖A接口，也需要修改A接口。不免显得些许麻烦，但是如果我们使用的MQ，把系统BCDE需要的信息都放到MQ，谁想用就去里面去取，不用就不取。这种结构大大减少了系统之间的耦合度。
1.2异步调用 假设有一个电子商务系统，其中订单处理系统（A）需要调用库存管理系统（B）来查询库存情况。
没有使用异步通信的情况：
订单处理系统（A）发起请求：当订单处理系统需要查询库存情况时，它直接调用库存管理系统的接口，发送一个请求，并等待响应。库存管理系统（B）处理请求：库存管理系统接收到请求后，需要查询数据库或其他资源来获取库存情况。然后，它将响应发送回订单处理系统。订单处理系统（A）接收响应并继续执行：订单处理系统接收到库存管理系统的响应后，可以根据返回的库存情况继续执行后续的订单处理逻辑。 在这种情况下**，订单处理系统需要等待库存管理系统的响应才能继续执行，这可能会导致订单处理系统的执行被阻塞，尤其在库存管理系统响应时间较长或出现故障时。这可能影响整个订单处理流程的效率和性能。**
使用异步通信的情况：
订单处理系统（A）发起异步请求：当订单处理系统需要查询库存情况时，它将请求发送到一个消息队列或事件总线，然后继续执行其他任务。库存管理系统（B）订阅并处理请求：库存管理系统订阅消息队列或事件总线，等待订单处理系统发送的请求。一旦收到请求，它可以独立地处理请求，查询库存情况，并将响应发送到另一个消息队列或事件总线。订单处理系统（A）接收响应并继续执行：订单处理系统订阅响应消息队列或事件总线，一旦收到库存管理系统的响应，它可以提取响应数据并继续执行订单处理逻辑。 在这种情况下，订单处理系统发送异步请求后不需要等待库存管理系统的即时响应。它可以继续执行其他任务，而不会被阻塞。库存管理系统在独立处理请求后发送响应，而订单处理系统可以在合适的时间获取响应并继续执行。这种异步通信方式可以提高系统的并发性、响应性能和可伸缩性，解耦了订单处理系统和库存管理系统之间的依赖关系，提高了整个系统的效率和性能。
异步调用也是MQ最为惊艳的地方。
1.3流量削峰
大家应该都知道到点抢购功能，即在一定的时间点会有大量的请求，数量根本不是服务器可控的，如果就任他请求然后处理，服务器必定炸。如果使用了MQ，可以把所有的请求消息都放在MQ中，然后按照处理能力，从MQ中获取能力范围内的请求信息去处理。这样，消息肯定也是一定时间内处理不完的，MQ的消息肯定堆积，但是高峰期不可能一直持续，我们只要一直保持高效率的处理请求，堆积的消息绝对可以消费完。
2.引入MQ可能会导致的一些BUG MQ的优点上面已经说了，缺点又是什么呢？
举例来说，考虑一个在线支付系统，其中订单服务需要将支付请求发送到消息队列，而支付服务订阅并处理这些支付请求。
复杂性增加：需要设置和管理消息队列服务器，以及处理消息传递的异步模式。这可能需要额外的开发工作和维护成本。使用消息队列引入了额外的复杂性，包括设置和管理消息队列服务器、处理消息传递的异步模式以及处理消息序列化和反序列化等。这可能需要更多的开发和维护工作，并增加了系统的复杂性。**单点故障：**如果消息队列服务器成为系统的单点故障，可能会导致消息丢失或系统的可用性下降，也就是说本来代码没问题，但是MQ他自己消息丢失了。因此，为了确保高可用性，需要采取适当的容错和冗余措施来防止单点故障。延迟：由于涉及到消息的传递和处理，使用消息队列可能会引入额外的延迟。支付请求从订单服务发送到消息队列，然后再由支付服务获取并处理。这些额外的步骤可能导致支付请求的处理时间增加，从而增加整个支付流程的延迟。*使用消息队列引入了额外的通信和处理时间，可能导致消息传递的延迟。尤其在负载较高或处理逻辑复杂的情况下，消息队列的延迟可能会对系统的响应性能产生影响。一致性保证：在某些情况下，系统可能需要保证消息的顺序性或一致性。但是，消息队列本身不保证消息的有序传递，因此在设计系统时需要考虑如何处理顺序问题或保证一致性。这点也是MQ最大的弊端。 虽然这些缺点存在，但在许多场景中，正确地使用和管理消息队列仍然可以带来许多好处。对于特定的应用程序和需求。
3.RabbitMQ和Kafka对比 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca694ff342665035f98d2679148865f0/" rel="bookmark">
			ChatGPT——用户研究面试干货分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		了解用户研究的定义和流程： 面试官可能会问到用户研究的定义和流程，因此在面试前需要认真了解和学习用户研究的理论知识和实践经验。用户研究的流程一般包括确定研究目标、制定研究计划、选择研究方法、招募研究参与者、执行研究、数据分析和撰写研究报告等步骤。
分析设计案例： 面试官可能会给你一个设计案例，要求你对用户体验进行分析和评估。在进行分析时，需要考虑用户的需求和行为，分析设计的优点和不足，并提出改进建议。
探讨具体的用户研究方法： 面试官可能会询问你对用户研究方法的了解和掌握程度。因此，在面试前需要对用户研究方法进行深入学习和研究，掌握常用的研究方法，如深度访谈、焦点小组讨论、问卷调查、用户测试等。
讨论数据分析和研究报告： 面试官可能会问到数据分析和研究报告的相关知识，因此需要掌握相关的数据分析工具和技巧，例如SPSS、Excel等，同时需要了解如何撰写研究报告，如何清晰地表达研究结论、提出改进意见等。
展示你的团队合作能力： 用户研究是团队合作的过程，因此在面试中需要展示你的团队合作能力。你需要表明你能够与UI设计师、产品经理等其他团队成员进行有效的沟通和协作，共同完成项目任务。
展示你的解决问题能力： 在用户研究中，难免会遇到一些问题，例如招募参与者、数据采集、数据分析等方面的问题。因此，在面试中需要展示你的解决问题能力，说明你能够独立思考、快速反应，并找到有效的解决方案。
展示你的沟通能力： 用户研究需要与参与者进行深入的交流，需要与团队成员进行有效的沟通和协作，因此，在面试中需要展示你的沟通能力，说明你能够清晰地表达自己的想法、听取他人的建议并进行反馈，能够有效地与他人进行合作。
展示你的研究经验和成果： 如果你已经有一些用户研究的经验和成果，可以在面试中进行展示，例如你在过去的项目中采用了哪些方法进行用户研究，取得了哪些成果和改进，这样可以让面试官更好地了解你的能力和工作表现。
展示你对用户研究的热情和追求： 用户研究需要对用户行为和体验进行深入的理解和研究，因此需要具备一定的热情和追求。在面试中需要展示你对用户研究的热情和追求，说明你对这个行业有着浓厚的兴趣和热情，愿意不断学习和探索。
展示你的自我反思和学习能力： 用户研究需要不断地进行自我反思和学习，不断改进自己的工作方法和技能。在面试中需要展示你的自我反思和学习能力，说明你能够对自己的工作进行反思和总结，并不断学习和提升自己的技能和能力。
展示你的数据分析能力： 用户研究需要对大量的数据进行收集和分析，因此需要具备较强的数据分析能力。在面试中需要展示你的数据分析能力，说明你能够运用各种工具和方法对数据进行收集和分析，并提供有关用户体验和行为的深入见解。
展示你的团队协作能力： 用户研究需要与团队成员进行紧密的合作和协作，因此需要具备良好的团队协作能力。在面试中需要展示你的团队协作能力，说明你能够有效地与他人进行沟通和协作，为团队的成功共同努力。
展示你的项目管理能力： 用户研究需要对项目进行管理和组织，因此需要具备一定的项目管理能力。在面试中需要展示你的项目管理能力，说明你能够有效地组织和管理项目，确保项目按计划完成，并满足客户的需求和期望。
展示你的创新思维和能力： 用户研究需要不断地进行创新和改进，因此需要具备创新思维和能力。在面试中需要展示你的创新思维和能力，说明你能够提供有创意和实用价值的解决方案，推动用户研究的不断发展和创新。
展示你的客户服务能力： 用户研究需要与客户进行密切的合作和沟通，因此需要具备良好的客户服务能力。在面试中需要展示你的客户服务能力，说明你能够在与客户的交流中保持专业、礼貌和友好，有效地解决客户的问题和需求。
展示你的技术能力： 用户研究需要使用各种工具和技术，因此需要具备一定的技术能力。在面试中需要展示你的技术能力，说明你能够熟练使用各种用户研究工具和技术，例如调查问卷、用户测试、数据分析工具等。
展示你的沟通能力： 用户研究需要与各种不同的人进行沟通，例如客户、团队成员、用户等。因此需要具备良好的沟通能力。在面试中需要展示你的沟通能力，说明你能够清晰地表达自己的想法和意见，有效地解决沟通问题，以及在不同的情境下使用不同的沟通方式。
展示你的灵活性和适应能力： 用户研究需要应对各种不同的情境和挑战，因此需要具备灵活性和适应能力。在面试中需要展示你的灵活性和适应能力，说明你能够在各种不同的情境下应对挑战，迅速适应新的环境和任务。
展示你的学习能力： 用户研究是一个不断发展和变化的领域，因此需要具备不断学习和更新知识的能力。在面试中需要展示你的学习能力，说明你能够不断学习和更新用户研究的知识和技能，以保持自己的竞争力和专业水平。
展示你的自我管理能力： 用户研究需要具备一定的自我管理能力，能够有效地分配时间和资源，以及管理工作流程和进度。在面试中需要展示你的自我管理能力，说明你能够有效地管理自己的时间和任务，以及保持高效率和高质量的工作。
展示你的团队合作能力： 用户研究需要与团队成员和其他相关部门进行合作，因此需要具备良好的团队合作能力。在面试中需要展示你的团队合作能力，说明你能够与团队成员和其他相关部门进行有效的沟通和合作，以达成共同的目标。
展示你的创新能力： 用户研究需要不断寻求新的方法和技术，以提高研究效果和质量。因此需要具备创新能力。在面试中需要展示你的创新能力，说明你能够提出新的研究方法和技术，以及在研究过程中不断寻求创新的思路和方法。
展示你的问题解决能力： 用户研究中经常会遇到各种问题和挑战，需要具备解决问题的能力。在面试中需要展示你的问题解决能力，说明你能够有效地分析和解决问题，以及在研究过程中遇到问题时采取积极的解决措施。
展示你的关注细节和质量的能力： 用户研究需要关注细节和质量，以保证研究结果的准确性和可靠性。在面试中需要展示你的关注细节和质量的能力，说明你能够注意细节和质量，以及在研究过程中保持高质量的工作。
展示你的客户服务能力： 用户研究需要与客户进行沟通和合作，因此需要具备客户服务能力。在面试中需要展示你的客户服务能力，说明你能够与客户进行良好的沟通和合作，以及在工作中保持良好的客户关系。
展示你的数据分析能力： 用户研究需要对收集到的数据进行分析，以提取有价值的信息和见解。因此需要具备数据分析能力。在面试中需要展示你的数据分析能力，说明你能够有效地分析和处理数据，以及在研究过程中使用各种数据分析工具和技术。
展示你的项目管理能力： 用户研究需要进行项目管理，以保证研究进度和质量。因此需要具备项目管理能力。在面试中需要展示你的项目管理能力，说明你能够有效地规划和管理研究项目，以及在研究过程中进行进度跟踪和风险管理。
展示你的沟通能力： 用户研究需要与各种相关方进行沟通，包括客户、团队成员、用户等。因此需要具备良好的沟通能力。在面试中需要展示你的沟通能力，说明你能够有效地和不同的人群进行沟通，以及在研究过程中保持良好的沟通和协调。
展示你的文档书写能力： 用户研究需要编写各种文档，包括研究计划、报告、用户调研问卷等。因此需要具备良好的文档书写能力。在面试中需要展示你的文档书写能力，说明你能够编写清晰、准确、有条理的文档，以及在研究过程中保持高质量的文档编写。
展示你的自我学习能力： 用户研究需要不断学习和掌握新的知识和技能，以应对不断变化的市场和技术环境。因此需要具备自我学习能力。在面试中需要展示你的自我学习能力，说明你能够积极学习和掌握新的知识和技能，以及在工作中不断提升自己的能力和水平。
展示你的团队合作能力： 用户研究需要与团队成员密切合作，共同完成项目任务。因此需要具备良好的团队合作能力。在面试中需要展示你的团队合作能力，说明你能够与团队成员合作，协调工作进度和任务分配，以及在工作中保持积极的态度和团队意识。
展示你的创新能力： 用户研究需要不断创新和探索新的方法和技术，以提高研究质量和效率。因此需要具备良好的创新能力。在面试中需要展示你的创新能力，说明你能够主动思考和探索新的方法和技术，以及在工作中不断创新和改进。
展示你的客户服务能力： 用户研究需要与客户进行沟通和协商，以保证研究项目的顺利进行。因此需要具备良好的客户服务能力。在面试中需要展示你的客户服务能力，说明你能够与客户保持良好的沟通和协调，及时解决问题和提供满意的服务。
展示你的行业知识： 用户研究需要了解所在行业的市场和竞争情况，以及最新的技术和趋势。因此需要具备良好的行业知识。在面试中需要展示你的行业知识，说明你能够了解所在行业的市场和竞争情况，掌握最新的技术和趋势，以及在工作中保持对行业的了解和学习。
展示你的工作经验： 用户研究需要具备一定的工作经验，以熟悉研究过程和方法，掌握各种工具和技术。在面试中需要展示你的工作经验，说明你曾经从事过相关的工作，掌握了研究过程和方法，具备了各种工具和技术的应用能力。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca694ff342665035f98d2679148865f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0bc778b2dc77a6e4aef83b3160b0fc7/" rel="bookmark">
			用户研究干货——这一篇就够啦
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、基本概念： ①工作内容：用户研究的首要目的是帮助企业定义产品目标用户群，明确、细化产品概念，并通过对用户的任务操作特性、知觉特征、认知心理特征的研究，使用户的实际需求成为产品设计的导向，使产品更符合用户习惯、经验和期待。
②定位：市场——确定目标消费群，去细分市场，明确需求。产品——包括产品属性、功能、风格、价位，通常是种解决方案，击中痛点或体验爽点。品牌——差异化形象建立用户大脑对产品的认知
③产品定位研究框架：文化趋势——识别当前消费趋势未来方向产生的影响，消费者——用户画像，品类景观——现状好处，竞品趋势——品类或相邻品类的发展趋势和变化
④研究步骤：建立假设——根据现有消费资源建立合理假设，了解目标客群——根据用户画像确定消费态度、动机、行为，挖掘消费者和品类的探索和理解——发现定位产品改善、创新机会点，对竞品的认知——了解消费者心目中的竞品布阵，有助于差异化定位。
⑤三个阶段：背景研究——针对潜在的用户群体还没实现成功转化的群体，也可以针对已经成功转化的用户，本质上是通过建立用户画像的手段让设计和产品的团队能够洞察理解到我们的用户需求到底是什么，从而建立一个和用户真正相关的产品，为用户带来价值。 可用性测试——产品投放到真实场景，用户体验是否良好，ROI研究——检测产品是否能带来收益。
⑥方法：桌面研究（网络搜索、行业报告、监测数据）定性研究（深度访谈、电话访谈、焦点小组、可用性测试、A/B测试、用户体验地图）定量研究（调查问卷、用户分类、竞品分析、数据可视化等）
二、用户调研： 三、用户访谈： ①定义：用户研究中最常用的一种定性研究的方法，主要方式是我们研究者和产品的用户进行一个深入交流，通过提出一些结构化的问题自然衍生了其他问题来了解用户对产品使用的一些想法和动机。
②目标：了解用户的基本行为模式，界定产品体验要点，挖掘深层次需求
③流程：访谈前-先确定关键测试目标，设定问题提纲，规划好提问顺序。访谈时-按照设定好的问题逐步实施提问，以帮助解答最先设定好的测试目标。访谈后：对用户的配合表示感谢，并奉上小礼物等提升用户的好感度；对访谈内容进行梳理和分析，提取有价值信息点并组织产品研发等部门商讨下一步决策。
四、用户画像： ①定义：简单理解就是用户信息标签化，根据用户差异，将他们区分为不同的类型，然后每种类型中抽取出典型特征，赋予名字、一些人口统计学要素、场景等描述，形成一个人物原型。
②目标:找到目标用户，发现用户需求
五、问卷调查： ①定义：非常常用的定量研究方法。通过设定一些目标问题，投放给预期的用户群。
②适用场景:可通过大样本数据对产品功能做验证评估产品满意度、做用户画像等
③目标:了解用户基本人口统计学特征；了解用户对产品的基本使用目的、行为、偏好等了解用户对产品的满意程度
④流程:需求确认（确认调研目标、优先级&amp;重要程度拆分需求内容，分阶段开展调研工作）-问卷设计（搜集用户和产品信息，设计问卷结构、问题和答案）-投放回收（确定问卷投放位置(给予一定的用户，达到数量后进行问卷回收）-问卷分析（通过数据分析手段输出重要结论）
六：焦点小组： ①定义：组织6-8人，集中在一类主题，用结构化的方式揭示目标用户的经验、感受、态度、愿望，并且努力客观地呈现其背后的理由。
②优势：善干发现用户的愿望、动机、态度、理由运用了群体沟通的特点，当互相发表意见时，会互相启发、发散，得出更多内容；可在收集用户需求与概念设计的阶段执行也可以在验证设计与测试原型的阶段执行；可以在过程中使用电视机、白板、问卷、图画等工具；能获得直观的对比。同时请来两类用户时可以发现不同类用户的观点碰撞
③流程：确定研究主题和目标用户；编写筛选问题；招募和筛选；预选候选人、初排日程；发送邀请给主要合格候选人；访谈前通知提醒；撰写访谈大纲，准备试前问卷、工具；执行焦点小组；输入数据、影音保存；执行总结会和撰写报告
④研究主题分类：挖掘需求型主题；结论验证型主题；竟品对比型主题
⑤问题举例：什么时候开始接触互联网 ?
每天花多少时间在网络上 ?
上网时候使用什么聊天工具?
最常用的网上商城网站有哪几个?
深入问题：
第一次网络购物的印象怎样
因为什么而选择在网上购买?
最喜欢的网上商城有哪几个? 为什么喜欢?
七、可用性测试： ①适用场景:评估产品，发现可用性问题
②目标:产品的总体可用性水平判断；完整的可用性测试问题列表、问题严重程度及优先级；同一产品不同阶段的评估结果对比，以了解产品的可用性走势
③流程:需求确认-方案设计-测试执行-问题清单-分析建议
(1)需求确认:与产品方沟通调研目标，确认合适的执行方式
(2) 方案设计:
a.细化产品典型任务，与产品方沟通确认任务点是否完整，据此完善用户场景
b.评估可用性量表与确认用户筛选条件
(3) 测试执行:
a.预测试:检验测试环境、任务流等的完善程度b.正式测试:主持人、记录员、观察员
(4)问题清单:综合各用户数据输出问题清单(问题表现、频度、严重性、优先级)
(5) 分析建议:
a.产品的整体可用性诊断结果b.针对具体任务详细分析产生的问题及原因
④优缺点：优点在于:1.通过实验设计获得的结果更为客观，对于业务方客观的数据更有说服力;2.贴近用户使用场景，相比访谈能够更真实发现用户使用过程中的痛点;3.通过实际操作观察到的一些痛点可以复用到类似场景，例如测试不同字号对用户阅读的影响，实验结果可以复用到涉及信息流阅读的场景;缺点在于:1灵活性较弱，前期确定实验设计之后，后期如果需求发生变更，比较难调整，2.数据准确性与稳定性与样本量有关，因此输出结果的周期较长，不适合需求比较紧急的情况;
八、用户研究能为我们做什么： 研究用户具体的行为，去找到这个行为背后的驱动力，他的原因是什么，他背后的价值观是什么，去挖掘在这个决策点上他背后整体的来自于用户的思考逻辑思考框架，乃至来源于社会的价值观和潮流因素文化习俗等，可以去反推这些具有普适性的总结性趋势，再从总结性趋势中给出对于未来战略的一些规划和预测
从产品的一个研发周期线上去看每个阶段能为我们做什么：
①产品概念阶段: 发掘、验证、明确用户需求、明确产品目标常用方法:脉络访查、深度访谈、焦点小组、问卷调查、竞品分析、用户模型
②产品设计阶段:视觉及设计方案的确定、交互设计的方案评价，可用性问题常用方法:可用性测试、卡片分类、合意性研究、认知走查、专家评估
③产品研发阶段:产品迭代开发的过程中，不同版本的易用性问题等
常用方法:可用性测试、认知走查、专家评估
④产品发布阶段:产品发布后用户的反馈、各个功能点的使用情况、新功能点的发掘产品推广策略
九、为什么需要用户研究： ①对公司:节约时间、成本和资源
②对产品/设计:知晓、理解用户，帮助产品迭代
③对用户:产品更贴近真实需求、更有用、易用
十、数据埋点： ①定义：用来收集数据的非常重要的手段，也是所有部门能够顺利开展后续工作的一个基础所在。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c0bc778b2dc77a6e4aef83b3160b0fc7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31a97ca36b0f194853549ddbbc782f28/" rel="bookmark">
			对比rpm和yum安装方式？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对比rpm和yum安装方式？ rpm命令和yum命令都可以用来安装软件。
rpm 只能安装已经下载到本地机器上的rpm 包，yum能在线下载并安装rpm包,能更新系统。
rpm适用于所有环境，而yum要搭建本地yum源才可以使用！
yum是上层管理工具，rpm是底层管理工具。
yum命令在安装软件时如果碰到了依赖性的问题，yum会去主动尝试解决依赖性，如果解决不了才会反馈给用户。而rpm命令一旦遇到了依赖性的问题不会去解决依赖性，而是直接反馈给用户，让用户自行解决。
yum是在rpm的基础上建立的一个工具，在配置好yum源之后很多功能比rpm命令更强大，更方便。rpm可以查询包安装后生成的配置文件等，查询未安装软件包中的内容，查询软件包相关的脚本。一般情况下软件包的查询，安装，卸载，和软件属于的软件包等命令用yum的相关命令来完成更好。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4107d8fd32773c095d645259bc4592ac/" rel="bookmark">
			Linux常见的压缩包有哪些？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux常见的压缩包有哪些？ 常用文件压缩/解压命令格式大全
1. tar
2. gzip
3. bzip2
4. zip
5. compress
6. cpio
7.dd
1. tar
打包备份后的文件包缀：.tar
作用：用来对系统上的文件作备份与恢复，可以将系统上多个文件组构成一个tar文件备份到磁盘内或写入到一般的文件（文件名为*.tar）上，也可以将文件从一个tar文件解回到原来的系统中。
说明：仅能将一个目录下的所有文件变成一个文件，不具备压缩功能，因此，一般都会将tar与gzip或bzip2一同使用。
tar的压缩语法格式：
tar –zcvf tarfile.tar.gz 准备压缩的目录或文件名称
常用选项说明：
-c 是产生一个压缩文件
-z 使目录tar起来后再自动使用gzip把文件压缩起来
-j 使用bzip2压缩
-v 把压缩过程显示在屏幕上
-f 表示要使用文件或设备，该选项一般是必选的
-t, --list list the contents of an archive
例1： 将/home/xinetd.d目录中的所有文件打包成一个文件后再由gzip压缩：
tar -zcvf xinet.tar.gz /home/xinetd.d/
例2 仅将/home/xinetd.d目录中的所有文件仅打包，不经过gzip压缩
tar -cvf xinet2.tar /home/xinetd.d/
tar的解压缩语法格式：
tar –zxvf tarfile.tar.gz（格式共3部分）
常用选项说明：
-x 从.tar.gz文件中释放文件
-z 该参数配合参数c（产生压缩文件）使用是压缩，但是配合参数x使用是以gzip解压缩
-f 指定将tarfile这个文件解压缩
-j 使用bunzip2解压缩
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4107d8fd32773c095d645259bc4592ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ecf550cfea51682a68df361c9d7dfc64/" rel="bookmark">
			java爬虫和python爬虫的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java爬虫与python爬虫的对比：
python做爬虫语法更简单，代码更简洁。java的语法比python严格，而且代码也更复杂
示例如下：
url请求：
java版的代码如下：
public String call (String url){ String content = ""; BufferedReader in = null; try{ URL realUrl = new URL(url); URLConnection connection = realUrl.openConnection(); connection.connect(); in = new BufferedReader(new InputStreamReader(connection.getInputStream(),"gbk")); String line ; while ((line = in.readLine()) != null){ content += line + "\n"; } }catch (Exception e){ e.printStackTrace(); } finally{ try{ if (in != null){ in.close(); } }catch(Exception e2){ e2.printStackTrace(); } } return content; } python版的代码如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ecf550cfea51682a68df361c9d7dfc64/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/134f808c73384eaeee87f3c391a61100/" rel="bookmark">
			泛微OA_E9之获取流程每日、每月提交次数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1、描述及效果1.1 描述1.2 效果1.2.1 同一申请人，每日只能提交一次流程，弹出提示1.2.2 同一申请人，每月只能提交一次流程，弹出提示 2、思路3、步骤3.1 设置字段属性SQL查询语句3.1.1 每日提交次数3.1.2 每月提交次数 3.2 本次使用E9流程表单前端接口API介绍3.2.1 表单提交操作执行前，执行自定义逻辑并阻断/放行后续操作3.2.2 获取单个字段值3.2.3 系统样式的Confirm确认框 3.3 上代码 4、总结 1、描述及效果 1.1 描述 根据实际需求，以相应字段做为条件，获取每日、每月流程提交次数。
下面以申请人、申请日期字段为例，限制每日、每月只能提交一次流程。
1.2 效果 1.2.1 同一申请人，每日只能提交一次流程，弹出提示 示例图1-1：
1.2.2 同一申请人，每月只能提交一次流程，弹出提示 示例图1-2：
2、思路 获取流程提交次数，必须要有字段做为SQL语句查询条件。可以是申请人、部门、日期等，条件字段以实际需求来定。
通过SQL查询出来的次数，再写JS提示、不允许再次提交等控制。
3、步骤 3.1 设置字段属性SQL查询语句 3.1.1 每日提交次数 新建一个单行文本–整数字段：“提交次数”，用来存储。
选中“提交次数”字段中，在表单上方菜单栏中，选择“字段属性–字段属性”，如示例图3-1：
SQL代码：
SELECT COUNT(*) FROM formtable_main_68 where sqr = '$main.sqrq$' and sqrq = '$main.sqrq$' and (select DATEPART(DD,GETDATE())) = DATEPART(dd,sqrq) SQL代码说明：
SELECT COUNT(*) FROM 数据库表名 where 数字库字段名称 = 表单字段 and 数字库字段名称 = 表单字段 and (select DATEPART(DD,GETDATE())) = DATEPART(dd,数字库字段名称)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/134f808c73384eaeee87f3c391a61100/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b60ace94526ff6336027af6853275d5/" rel="bookmark">
			mysql面试题（事务篇）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mysql事务 什么是数据库事务？事务的特性是什么？什么是ACID？并发事务会有哪些问题？什么是脏读 丢失修改 不可重复读 幻读 不可重复读和幻读有什么区别？Mysql是如何避免事务并发问题的？什么是事务隔离级别？默认的级别是什么？如何选择事务隔离级别？靠缓存可以提升高事务隔离级别的性能吗？Mysql事务隔离是如何实现的？什么是一致性非锁定读和锁定读？说一下MVCC内部细节Mysql事务一致性，原子性是如何实现的？Mysql事务的持久性是如何实现的？表级锁和行级锁有什么区别？什么是行级锁？Mysql如何完成的？什么是共享锁（读锁）？什么是排它锁（写锁/独占锁）？什么是意向锁？InnoDB支持哪几种锁？当前读和快照读分别是什么？什么是XA协议？什么是mysql xa事务？xa事务与普通事务区别是什么？089 什么是2pc 3pc？090 是否使用过select for update？会产生哪些操作？说一下mysql死锁的原因和处理方法Mysql会产生几种日志？bin log作用是什么？redo log作用是什么？ undo log作用是什么？Mysql日志是否实时写入磁盘？ bin log刷盘机制是如何实现的？ redo log刷盘机制是如何实现的？ undo log刷盘机制是如何实现的？MySQL的binlog有有几种录入格式？分别有什么区别？Mysql集群同步时为什么使用binlog？优缺点是什么？ 什么是数据库事务？事务的特性是什么？ 事务：
是数据库操作的最小工作单元，是作为单个逻辑工作单元执行的一系列操作；
这些操作作为一个整体一起向系统提交，要么都执行、要么都不执行；
事务是一组不可再分割的操作集合（工作逻辑单元）
事务都有 ACID 特性
什么是ACID？ 1 、原子性 atomicity
过程的保证
只做一个步骤
1 给钱
2 去买
3 交回来
事务是数据库的逻辑工作单位，事务中包含的各操作要么都做，要么都不做
2 、一致性 consistency
结果的保证
保证要吃完 刚张嘴挂了，失去一致性
事 务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。因此当数据库只包含成功事务提交的结果时，就说数据库处于一致性状态。如果数据库系统 运行中发生故障，有些事务尚未完成就被迫中断，这些未完成事务对数据库所做的修改有一部分已写入物理数据库，这时数据库就处于一种不正确的状态，或者说是 不一致的状态。
3 、隔离性 isolation
并发事务互相干扰
不被干扰 刚张嘴别人塞了东西
一个事务的执行不能其它事务干扰。即一个事务内部的操作及使用的数据对其它并发事务是隔离的，并发执行的各个事务之间不能互相干扰。
4 、持续性 永久性 durability
保存 吃到肚子里
也称永久性，指一个事务一旦提交，它对数据库中的数据的改变就应该是永久性的。接下来的其它操作或故障不应该对其执行结果有任何影响。
并发事务会有哪些问题？ 多个事务并发执行一定会产生相互争夺资源的问题
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b60ace94526ff6336027af6853275d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83bd1615390e5039840d6b69c2319b60/" rel="bookmark">
			cnpm不是内部或外部命令 cnpm: command not found 解决方案 cnpm
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题是处在于 你没用用淘宝的镜像 安装cnpm
不信 你打下cnpm -v, 看是 是不是也不是内部命令；
好了，那就安装下吧
npm install cnpm -g --registry=https://registry.npm.taobao.org 这样你就可以cnpm install来更新依赖了
第二种 就是 打的npm 实际是 指向淘宝镜像
npm config set registry http://registry.npm.taobao.org/ 然后 后面不行npm指向淘宝可以撤回 如下
npm config set registry https://registry.npmjs.org/ 查看是不是指过去了命令如下
npm config get registry 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13e11d5d36d6012c46823c5df8dbdeea/" rel="bookmark">
			git help
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		work zoom：本地看到的代码index zoom：英文叫 stage 或 index。一般存放在 .git 目录下的 index 文件（.git/index）中，所以我们把暂存区有时也叫作索引（index）。local repository ：本地仓库，对应记录在 .git 下，.git不是work zoom内容。remote repository: 远程仓库 // add code to index
git add .
远程服务器配置 #查询远端名称 git remote -v # add a new remote git remote add origin_c git@192.27.1.69:xxx1 # modify a remote to new addr git remote set-url origin_c git@192.27.1.69:xxx1 # push to remote bname_local:bname_remote git push origin_c master:master # del远端关联 git remote remove &lt;url_path&gt; # new create a branch git branch "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13e11d5d36d6012c46823c5df8dbdeea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44c50d4b1f1a0caaa9991208870d8fe5/" rel="bookmark">
			Vue 安装 Prettier
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Vue 安装 Prettier 一、手动配置
1.安装依赖包 yarn add eslint prettier eslint-config-prettier eslint-plugin-prettier -D 2.初始化eslint yarn eslint --init 3.配置.eslintrc.cjs（.cjs代表Commonjs） "extends" 中最后添加 "plugin:prettier/recommended" 4.配置.prettierrc.cjs 将配置文件拷贝至工程 5.package.json中添加脚本 "lint:eslint": "eslint . --ext .vue,.js,.ts,.jsx,.tsx --fix" "lint:prettier": "prettier --write \"src/**/*.{js,json,tsx,css,less,scss,vue,html,md}\"" 6.配置Webstorm ESLint：配置成'自动ESLint配置' Prettier: 配置Prettier包 二、自动配置
npm init vite-pretty-lint 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a205d3877e88cd7e16952e2bae2c3ea7/" rel="bookmark">
			使用Spring Batch进行批量处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Java后端开发中，批量处理是一个非常常见的需求。例如，我们需要从数据库中读取大量数据，对这些数据进行处理，然后将处理后的结果写回到数据库中。这时候，使用Spring Batch框架可以帮助我们快速地实现批量处理的功能。
什么是Spring Batch？ Spring Batch是一个轻量级的批量处理框架，它基于Spring框架，提供了一套完整的批量处理解决方案。Spring Batch可以帮助我们处理大量的数据，支持事务管理、并发处理、错误处理等功能。
Spring Batch的核心概念 在使用Spring Batch进行批量处理之前，我们需要了解一些Spring Batch的核心概念。
Job Job是Spring Batch中的最高级别的概念，它代表了一个完整的批量处理任务。一个Job由多个Step组成，每个Step代表了一个具体的处理步骤。
Step Step是Spring Batch中的一个处理步骤，它包含了一个ItemReader、一个ItemProcessor和一个ItemWriter。ItemReader用于读取数据，ItemProcessor用于处理数据，ItemWriter用于写入数据。
ItemReader ItemReader用于读取数据，它可以从文件、数据库、消息队列等数据源中读取数据，并将读取到的数据传递给ItemProcessor进行处理。
ItemProcessor ItemProcessor用于处理数据，它可以对读取到的数据进行处理，并将处理后的数据传递给ItemWriter进行写入。
ItemWriter ItemWriter用于写入数据，它可以将处理后的数据写入到文件、数据库、消息队列等数据源中。
使用Spring Batch进行批量处理 下面我们来看一个使用Spring Batch进行批量处理的例子。假设我们有一个用户表，其中包含了大量的用户数据。我们需要从用户表中读取数据，对数据进行处理，然后将处理后的结果写回到用户表中。
创建Job 首先，我们需要创建一个Job。在Spring Batch中，可以使用JobBuilderFactory来创建Job。
less
复制代码
@Configuration @EnableBatchProcessing public class BatchConfig { @Autowired private JobBuilderFactory jobBuilderFactory; @Autowired private StepBuilderFactory stepBuilderFactory; @Autowired private DataSource dataSource; @Bean public Job importUserJob() { return jobBuilderFactory.get("importUserJob") .incrementer(new RunIdIncrementer()) .flow(step1()) .end() .build(); } } 在上面的代码中，我们创建了一个名为importUserJob的Job，并将其包含的Step设置为step1。
创建Step 接下来，我们需要创建Step。在Spring Batch中，可以使用StepBuilderFactory来创建Step。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a205d3877e88cd7e16952e2bae2c3ea7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5c2dba0381b2a4dc820daa1abaf39bd/" rel="bookmark">
			uni-app路由模块化脚本解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 之前因为uni-app所有的页面都是放在pages.json文件中的，但是json文件中是没法写注释的，所以我们没法较好的去按模块分路由。后来用了插件去进行处理模块化，但是当我们使用vue3时，将vite升级到vite4版本时，就没法支持那个插件了。那个解决方案在俺之前的文章也有介绍。加上之前的插件有些小bug，早就想给优化下，所以就搞了个脚本来动态的获取模块路由，当路由文件有所变化，就会触发脚本函数去收集路由，完成路由收集后对pages.json进行重写，达到拆分路由并且动态重写路由的效果。
准备工作 实现过程其实是有点小曲折的，核心就是监听路由文件，监听文件俺这边选用了chokidar文件观察库来监听路由文件，然后就是通过node的fs模块功能重写pages.json文件,还有个小瑕疵就是监听文件服务要和项目要一起启动。其实可以多开一个控制台，但是我觉得这样用起来效果不好，所以合在一个命令中比较好。所以俺又使用了concurrently来同时启用两个服务。
// 安装依赖 pnpm install chokidar -D pnpm install concurrently -D chokidar chokidar源码的git地址
chokidar就是文件观察库，它能够帮助你去监听指定目录下的文件变更。我们监听路由文件变化就能使用它。
watch函数 chokidar的watch数接收的第一个参数是路径，第二个参数是一些选项，但是这次没用上第二个参数。它的事件有add、on、unwatch等，但是俺这边只用了on事件，
on事件的回调有两个参数，分别是更改文件的方式，以及文件路径。这个正好告诉我们哪个文件进行了修改，并且告诉我们是新增还是删除还是修改。
重写pages.json 重写pages.json要用到的是node的fs模块写入文件功能，重写的时候要注意，经过俺的多次尝试，需要把登录页放在路由的第一项，因为重写后，页面缓存就没了，如果你当前的页面在深的层级中，重写后就没法返回了。
concurrently concurrently这个插件允许你一次启动多个服务，我们启动项目时不仅需要启动项目，也需要启动监听文件服务，我们也可以开两个控制台启动，但是太麻烦，所以通过concurrently这个插件来帮助我们在一个控制台中一次启动两个服务。
"scripts": { "serve": "uni", "serve:cs": "concurrently \"uni --port 3001 --mode cs\" \"node script/index.js\"" } 完整代码 目录结构 index.js console.log('运行监听路由脚本成功'); const chokidar = require('chokidar'); const fs = require('fs'); const path = require('path'); // 记录修改文件的次数 let count = 0; // 路由文件路径、监听该路径下所有路由文件 let routerPath = path.join(__dirname, '../src/page_config/router'); // 需要重写pages.json的路径 let writePath = path.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5c2dba0381b2a4dc820daa1abaf39bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b2e0b0ac639b1d59fc52b1a36249324/" rel="bookmark">
			基于51单片机的课程设计（毕业设计）——电子贺卡
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇文章将介绍一个基于51单片机的电子贺卡，本作品可用于课程设计、毕业设计的参考。其所用到的外设硬件以及程序的代码量都是相对较少的，对于51单片机的初学者，通过本设计熟悉51单片机的使用是非常好的选择。
目录
一、实现功能
二、硬件准备
三、项目设计
（一）基本原理
（二）原理图
（三）程序设计
四、图片展示
五、总结
资料下载： 基于51单片机的电子贺卡设计，课程设计，毕业设计
一、实现功能 通过喇叭播放《世上只有妈妈好》音乐曲调；通过0.96寸的OLED显示图片；通过按键切换图片 二、硬件准备 主控芯片：STC89C52（安装在最小系统板上）显示装置：0.96寸4针OLED显示屏（IIC接口）播放装置：喇叭、三极管 其他：杜邦线、电阻若干、按键*1 三、项目设计 （一）基本原理 图片的显示是通过0.96寸的OLED显示屏实现的，这个显示屏虽然小，但是显示内容相对较多，而且使用方便，连接非常简单，资料例程较为全面。通过IIC进行通信，本设计中时钟线定义为P1^0，数据线定义为P1^1。
音乐的播放是通过一个三极管放大电路驱动一个喇叭实现的，当我们改变IO口的高低电平切换频率喇叭就会播放不同的曲调。本设计中喇叭控制端口我们定义为了P1^7，不同的音乐网上会有不同的数据，这个读者可自行参考。
切换图片用一个按键即可。
（二）原理图 51单片机最小系统基本原理图 三极管放大电路 显示电路 （三）程序设计 定义必要的变量的数组 #define uchar unsigned char unsigned char a, i, j, k; int b; int key = 0; sbit speaker = P1 ^ 7; unsigned char timer0h, timer01, time; code unsigned char sszymmh1[] = { 6, 2, 3, 5, 2, 1, 3, 2, 2, 5, 2, 2, 1, 3, 2, 6, 2, 1, 5, 2, 1, 6, 2, 4, 3, 2, 2, 5, 2, 1, 6, 2, 1, 5, 2, 2, 3, 2, 2, 1, 2, 1, 6, 1, 1, 5, 2, 1, 3, 2, 1, 2, 2, 4, 2, 2, 3, 3, 2, 1, 5, 2, 2, 5, 2, 1, 6, 2, 1, 3, 2, 2, 2, 2, 2, 1, 2, 4, 5, 2, 3, 3, 2, 1, 2, 2, 1, 1, 2, 1, 6, 1, 1, 1, 2, 1, 5, 1, 6, 0, 0, 0 }; code unsigned char sszymmh[] = { 6, 2, 3, 5, 2, 1, 3, 2, 2, 5, 2, 2, 1, 3, 2, 6, 2, 1, 5, 2, 1, 6, 2, 4, 3, 2, 2, 5, 2, 1, 6, 2, 1, 5, 2, 2, 3, 2, 2, 1, 2, 1, 6, 1, 1, 5, 2, 1, 3, 2, 1, 2, 2, 2, 2, 3, 3, 2, 1, 5, 2, 2, 5, 2, 1, 6, 2, 1, 3, 2, 2, 2, 2, 2, 1, 2, 4, 5, 2, 3, 3, 2, 1, 2, 2, 1, 1, 2, 1, 6, 1, 1, 1, 2, 1, 5, 1, 6, 0, 0, 0 }; code unsigned char FREQH[] = { 0xF2, 0xF3, 0xF5, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xF9, 0xFA, 0xFA, 0xFB, 0xFB, 0xFC, 0xFC, 0xFC, 0xFD, 0xFD, 0xFD, 0xFD, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0XFF }; code unsigned char FREQL[] = { 0x42, 0xC1, 0x17, 0xB6, 0xD0, 0xD1, 0xB6, 0x21, 0xE1, 0x8C, 0xD8, 0x68, 0xE9, 0x5B, 0x8F, 0xEE, 0x44, 0x6B, 0xB4, 0xF4, 0x2D, 0x47, 0x77, 0xA2, 0xB6, 0xDA, 0xFA, 0x16 }; 延时函数 void delay(unsigned char t) { unsigned char t1; unsigned long t2; for (t1 = 0; t1 &lt; t; t1++) for (t2 = 0; t2 &lt; 8000; t2++) ; } void lcddelay(unsigned char c) { unsigned char a, b; for (; c &gt; 0; c--) for (b = 142; b &gt; 0; b--) for (a = 2; a &gt; 0; a--) ; } 音乐播放函数 void t0int() interrupt 1 { TR0 = 0; speaker = !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b2e0b0ac639b1d59fc52b1a36249324/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2579c45a1f39edeb36f7bcba1dd6ed60/" rel="bookmark">
			解决pytorch模型加载跑测试集和训练过程中跑测试集结果不一致的问题——功夫不负有心人
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		其实引发这个现象的原因还是很多的，需要自己一一排查。
网上所说的较为常见的原因是
1、随机种子固定
2、在test之前将模型改为eval()模型
针对这两种情况，我对自己的代码做了相应的验证，并没有效果。
后来看到一篇知乎，说“我查了一下我的标签。我每次加载数据的时候target都是从一个由集合转成的列表里面的下标……这样就造成了每次做断点训练的时候每个样本的target都是不一样的……他只拟合了训练时候的那个target……”
于是，想到了自己标签是否存在每次加载不一致的问题。经过debug，发现确实存在这样的问题。
因为类别固定，所以把label_2_index写死就OK了。
经测试，每次test结果相对固定，问题解决了。
训练时的测试分数
直接load模型的测试分数
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fdc4976bbf9e4aead04de2560e066791/" rel="bookmark">
			【C语言】 -- 扫雷（代码&#43;详解）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言：
1、游戏规则
2、创建文件
2.1 头文件
2.2 define定义的行、列、雷的个数
2.3 函数声明
3、游戏测试部分
3.1 主函数
对主函数内容的分析：
3.1.1 menu()函数（菜单函数）
3.1.2 switch语句
3.1.3 do while语句
3.1.4 game()函数
4、游戏功能实现部分
游戏的实现逻辑
4.1 棋盘的创建
4.2 初始化棋盘函数
4.3 打印棋盘函数
4.4 布置雷
4.5 排查雷
前言： 该篇文章是用C语言来实现扫雷的，是对之前的知识灵活运用加以巩固，如何合理的分块来写一个工程性的代码，如果有大佬看到本篇文章并发现哪里要有不对的地方，请您一定要指出来。
1、游戏规则 我们在棋盘格中任意点开一个格子，若这个格子不是雷就排除了这个位置，排除后这个格子会显示将它围起来的几个格子中有几颗雷，如果点开的格子埋有雷则为游戏失败。
2、创建文件 我们需要分块来写不同用途的文件，在实现三子棋我们需要分三个文件，分别是：
我们需要分模块来写不同用途的文件，在实现扫雷时我们需要分三个文件，分别是：
game.h //头文件（包含所有需要的用到的头文件，define定义的常量，函数声明）
注：我们将2.1，2.2，2.3全部写在此文件中目的在于，game.c和test.c中调用这些内容时，只需要对我们自己写的game.h声明一次便可直接使用里面的内容。
game.c //游戏文件（里面分别写入所要用到功能函数）
test.c //测试文件（代码的整合）
2.1 头文件 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt; 2.2 define定义的行、列、雷的个数 优点：如果我们后期需要改棋盘大小以及雷的个数的时候只需要在这里改，一劳永逸，不用在整个程序中修改，提高了效率。
#define ROW 9 #define COL 9 #define ROWS ROW + 2 #define COLS COL + 2 #define EASY_COUNT 10 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fdc4976bbf9e4aead04de2560e066791/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa2dccfcfc558fb68d2cd75ecadbd843/" rel="bookmark">
			操作系统 学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一章 进程、线程 1.进程：进程是操作系统中除处理器外进行的资源分配和保护的基本单位。
线程：线程又称为迷你进程，但是它比进程更容易创建，也更容易撤销。是独立调度的基本单位。
①注意：线程是进程的组成部分，多线程构成一个进程。
②举例子：线程好比工厂的工人，进程好比一个工厂的车间。
2.进程的组成：进程控制块PCB（进程存在的唯一标志），数据段，程序段（程序代码）。
3.进程执行状态转换：
第二章 处理器调度 1.FCFS算法（先来先服务）：非抢占式。
2.短作业/进程优先算法（SJF/SPF）：分为非抢占式（默认）和抢占式。
①非抢占式：
②抢占式：
3.高响应比优先算法：非抢占式。作业等待越久响应比越高，越容易获得处理机。
注：响应比=（等待时间+服务时间）/ 服务时间
4.时间片轮转调度算法（RR）：若时间片为5。
5.周转时间=完成时间-到达时间
带权周转时间=周转时间/服务时间
第三章 同步与互斥 1.临界区：并发中与共享变量有关的程序段。
临界资源：互斥共享变量代表的资源。
2.解决临界区问题：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86de7112920975a4cf60776102645b28/" rel="bookmark">
			字符串转字典
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实习工作中需要将每行读取的字符串例如’{“A”:“sad”, “B”:“123”}'这种形式中的123取出来，查找到了这篇文章，对我很有帮助。转载一下防止遗失。
将一个 python 的字符串转为字典，比如字符串：
user_info = '{"name" : "john", "gender" : "male", "age": 28}' 我们想把它转为下面的字典：
user_dict = {"name" : "john", "gender" : "male", "age": 28} 有以下几种方法：
1、通过 json 来转换
import json user_info= '{"name" : "john", "gender" : "male", "age": 28}' user_dict = json.loads(user_info) user_dict # {u'gender': u'male', u'age': 28, u'name': u'john'} 但是使用 json 进行转换存在一个潜在的问题。
由于 json 语法规定 数组或对象之中的字符串必须使用双引号，不能使用单引号 (官网上有一段描述是 “A string is a sequence of zero or more Unicode characters, wrapped in double quotes, using backslash escapes” )，因此下面的转换是错误的：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/86de7112920975a4cf60776102645b28/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1e9aa8418d4b38213d177d10bedf4ab/" rel="bookmark">
			代码随想录算法训练营第十四天| 递归遍历 、迭代遍历、 统一迭代
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		递归遍历： 这里帮助大家确定下来递归算法的三个要素。每次写递归，都按照这三要素来写，可以保证大家写出正确的递归算法！
确定递归函数的参数和返回值： 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。
确定终止条件： 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。
确定单层递归的逻辑： 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。
前序遍历代码： class Solution { public: void traversal(TreeNode* cur, vector&lt;int&gt;&amp; vec) { if (cur == NULL) return; vec.push_back(cur-&gt;val); // 中 traversal(cur-&gt;left, vec); // 左 traversal(cur-&gt;right, vec); // 右 } vector&lt;int&gt; preorderTraversal(TreeNode* root) { vector&lt;int&gt; result; traversal(root, result); return result; } }; 中序遍历代码： void traversal(TreeNode* cur, vector&lt;int&gt;&amp; vec) { if (cur == NULL) return; traversal(cur-&gt;left, vec); // 左 vec.push_back(cur-&gt;val); // 中 traversal(cur-&gt;right, vec); // 右 } 后序遍历代码： void traversal(TreeNode* cur, vector&lt;int&gt;&amp; vec) { if (cur == NULL) return; traversal(cur-&gt;left, vec); // 左 traversal(cur-&gt;right, vec); // 右 vec.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d1e9aa8418d4b38213d177d10bedf4ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8e6cb1fb1c724a30ff2865c56b160e9/" rel="bookmark">
			python 中 argv和raw_input()有什么区别？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		argv和raw_input()有什么区别？它们的区别在于要求用户输入的位置不同。如果你想让用户在命令行输入你的参数，你应该使用argv .，如果你希望用户在脚本执行的过程中输入参数，那就就要用到raw_input() 。下面我们写一个可以接收参数的脚本，来具体认识一下argv和raw_input()。
from sys import argv script, first, second, third = argv print "The script is called:", script print "Your first variable is:", first print "Your second variable is:", second print "Your third variable is:", third 第一行代码中，我们用到一个 import 语句，这是将Python的功能模块加入你自己脚本的方法。Python 不会一下子将它所有的功能提供给你，而是让你需要什么就调用什么。这样可以让你的程序更加精简，而后面的程序员看到你的代码的时候，这些“import”语句可以作为提示，让他们明白你的代码用到了哪些功能。
argv 就是所谓的“参数变量”，它是一个非常标准的编程术语。在其他的编程语言里你也可以看到它。这个变量包含了你传递给 Python 的参数。
代码的第3行将 argv 进行“解包(unpack)”，与其将所有参数放到同一个变量下面，我们将每个参数赋予一个变量名： script, first, second, 以及 third。这也许看上去有些奇怪,不过”解包”可能是最好的描述方式了。它的含义很简单：“把argv中的东西解包，将所有的参数依次赋予左边的变量名”。
前面使用import让程序实现更多的功能，我们把import称为功能，它们的真正名称其实是模块。像下面的示例一样将你的脚本运行起来：
$ python ex13.py first 2nd 3rd The script is called: ex13.py Your first variable is: first Your second variable is: 2nd Your third variable is: 3rd 如果你每次输入的参数不一样，那你看到的输出结果也会略有不同：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8e6cb1fb1c724a30ff2865c56b160e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bef1e6745d68fde871980b42ef645151/" rel="bookmark">
			spring 工厂读取配置文件创建对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 准备一个配置文件 applicationContext.properties
userService = com.baizhiedu.basic.UserServiceImpl 2.通过properties获取配置文件的内容 private static Properties properties= new Properties(); static{ try { //第一步 获得IO输入流 /** 方法一：getResourceAsStream InputStream inputStream = BeanFactory.class.getResourceAsStream("/applicationContext.properties"); */ //方法二：getClassLoader ClassLoader classLoader = BeanFactory.class.getClassLoader(); InputStream inputStream = classLoader.getResourceAsStream("applicationContext1.properties"); //第二步 文件内容 封装 Properties集合中 key = userService value = com.baizhixx.UserServiceImpl env.load(inputStream); inputStream.close(); } catch (IOException e) { e.printStackTrace(); } } 3. 通用的创建对象的方法 /* key 小配置文件中的key [userDAO,userService] */ public static Object getBean(String key){ Object ret = null; try { Class clazz = Class.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bef1e6745d68fde871980b42ef645151/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0f17cbfa9eb7c2725b096022b172c57/" rel="bookmark">
			VMware Workstation 与 Device/Credential Guard 不兼容。在禁用 Device/Credential Guard 后，可以运行 VMware Workstati
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装了docker后进入vmware报错：VMware Workstation 与 Device/Credential Guard 不兼容。在禁用 Device/Credential Guard 后，可以运行 VMware Workstation。有关更多详细信息，
解决方法：
1、使用组策略编辑器禁用 Device/Credential Guard：
2、打开“运行”对话框，键入 “gpedit.msc”，然后按 Enter 键。
导航到 “计算机配置” &gt; “管理模板” &gt; “系统” &gt; “Device Guard”。
右侧窗格中选择 “启用或禁用 Device Guard”，将其设置为 “未配置” 或 “已禁用”。
重新启动计算机，并尝试运行 VMware Workstation。
使用命令行禁用 Device/Credential Guard：
打开管理员命令提示符。
运行以下命令禁用 Device/Credential Guard：
bcdedit /set hypervisorlaunchtype off 重新启动计算机，并尝试运行 VMware Workstation。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60875278fbf8155e01e2ea03f6addbdc/" rel="bookmark">
			Android Color透明度值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Android Color透明度值 Android中color用16进制的表示可以用#xxxxxx(#xxx)表示，可以用#XXxxxxxx表示，其中前2位是指透明值.半透明颜色值共8位，前2位是透明度，后6位是颜色。 也就是透明度和颜色结合就可以写出各种颜色的透明度.
下面附上透明值得16进制值
不透明度-对应的值 100% — FF (不透明) 99% — FC 98% — FA 97% — F7 96% — F5 95% — F2 94% — F0 93% — ED 92% — EB 91% — E8 90% — E6 -----------------------------------90% 89% — E3 88% — E0 87% — DE 86% — DB 85% — D9 84% — D6 83% — D4 82% — D1 81% — CF 80% — CC -----------------------------------80% 79% — C9 78% — C7 77% — C4 76% — C2 75% — BF 74% — BD 73% — BA 72% — B8 71% — B5 70% — B3 -----------------------------------70% 69% — B0 68% — AD 67% — AB 66% — A8 65% — A6 64% — A3 63% — A1 62% — 9E 61% — 9C 60% — 99 -----------------------------------60% 59% — 96 58% — 94 57% — 91 56% — 8F 55% — 8C 54% — 8A 53% — 87 52% — 85 51% — 82 50% — 80 (半透明) -----------------------------------50% 49% — 7D 48% — 7A 47% — 78 46% — 75 45% — 73 44% — 70 43% — 6E 42% — 6B 41% — 69 40% — 66 -----------------------------------40% 39% — 63 38% — 61 37% — 5E 36% — 5C 35% — 59 34% — 57 33% — 54 32% — 52 31% — 4F 30% — 4D -----------------------------------30% 29% — 4A 28% — 47 27% — 45 26% — 42 25% — 40 24% — 3D 23% — 3B 22% — 38 21% — 36 20% — 33 -----------------------------------20% 19% — 30 18% — 2E 17% — 2B 16% — 29 15% — 26 14% — 24 13% — 21 12% — 1F 11% — 1C 10% — 1A -----------------------------------10% 9% — 17 8% — 14 7% — 12 6% — 0F 5% — 0D 4% — 0A 3% — 08 2% — 05 1% — 03 0% — 00 (完全透明) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6816223b399df4026944ca13785f274/" rel="bookmark">
			elasticsearch7.x 开启安全认证xpack，以及kibana、logstash、filebeat组件连接开启安全认证的es；
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、 elasticsearch7.x 开启安全认xpack1.生成认证文件2.修改elasticsearch配置文件开启xpack3.重启各个es节点并设置用户名密码4.访问es验证 二、配置kibana使用es安全认证1.kibana配置连接ES的安全认证2.重启kibana并访问验证3.在kibana里创建只读角色与只读账号 三、配置logstash使用es安全认证1.创建logstash用户2.修改logstash输出到es的配置 四、配置filebeat使用es安全认证1.创建filebeat用户2.修改filebeat输出到es的配置 五、kibana配置匿名用户自动登陆(不需要输入用户名密码)1.创建角色2.创建用户3.kibana配置4.点击匿名用户自行登录测试 一、 elasticsearch7.x 开启安全认xpack 1.生成认证文件 在es集群中任意一台节点生成即可
1.1 生成ca证书
[root@elk01 ~]# /hqtbj/hqtwww/elasticsearch_workspace/bin/elasticsearch-certutil ca ... #直接回车即可； Please enter the desired output file [elastic-stack-ca.p12]: #这里直接回车，不要设置密码，否则会报错！！ Enter password for elastic-stack-ca.p12 : 设置完成后，会在elasticsearch的家目录下看到新生成的证书elastic-stack-ca.p12
1.2 生成p12密钥
使用上面生成的ca证书"elastic-stack-ca.p12"生成p12密钥
[root@elk01 ~]# /hqtbj/hqtwww/elasticsearch_workspace/bin/elasticsearch-certutil cert --ca /hqtbj/hqtwww/elasticsearch_workspace/elastic-stack-ca.p12 ... #下面三项直接回车即可 Enter password for CA (/hqtbj/hqtwww/elasticsearch_workspace/elastic-stack-ca.p12) : Please enter the desired output file [elastic-certificates.p12]: #这里直接回车，不要设置密码，否则es会启动不了 Enter password for elastic-certificates.p12 : Certificates written to /hqtbj/hqtwww/elasticsearch_workspace/elastic-certificates.p12 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f6816223b399df4026944ca13785f274/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff8d5dbf511d16b278755dd466fdafe2/" rel="bookmark">
			深入了解Aviator表达式引擎：高性能的轻量级计算引擎
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在软件开发过程中，我们经常需要对数学和逻辑表达式进行求值和计算。传统的方式可能会导致性能瓶颈和复杂的代码逻辑。在这篇博客中，我们将介绍Aviator表达式引擎，一个轻量级且高性能的计算引擎，用于解析和执行数学和逻辑表达式。
什么是Aviator表达式引擎？ Aviator是一个独立的表达式解析引擎，旨在执行数学和逻辑表达式。它提供了简单易用的语法和API，使得表达式解析和计算变得简单而直观。通过使用Aviator，我们可以高效地执行各种数学和逻辑运算，从而简化我们的代码逻辑
Aviator的特点 高性能：Aviator被设计为高性能的表达式解析引擎。它使用解释器和JIT（Just-In-Time）编译器的混合模式，将表达式转换为优化的字节码，从而实现快速的表达式求值和计算。灵活的表达式语法：Aviator的语法类似于Java语言，易于理解和编写表达式。它支持各种数学和逻辑运算符，以及丰富的内置函数，使得我们可以编写更灵活和功能强大的表达式。自定义函数支持：Aviator允许我们定义自己的函数，并将其注册到引擎中供表达式使用。这样，我们可以根据实际需求扩展表达式的功能，满足特定的业务逻辑需求。安全性和可扩展性：Aviator提供了安全的表达式执行环境，可以控制表达式对环境的访问权限。同时，它还支持自定义的上下文对象，可以在表达式求值过程中传递额外的上下文信息。 Aviator使用场景 Aviator表达式引擎适用于多种应用场景：
规则引擎：通过Aviator，我们可以实现灵活的规则匹配和动态规则更新，例如金融领域的风控系统。计算引擎：Aviator可以作为高性能的计算引擎，支持数学计算、数据分析和科学计算等任务。动态 入门案例 以下是一些简单的入门案例，可以帮助我们更好地理解和使用该引擎：
1.简单数学表达式 import com.googlecode.aviator.AviatorEvaluator; public class MathExpressionExample { public static void main(String[] args) { // 定义表达式 String expression = "2 + 3 * (4 - 1)"; // 使用Aviator计算表达式 Object result = AviatorEvaluator.execute(expression); // 输出结果 System.out.println("Result: " + result); } } 2.变量计算表达式 import com.googlecode.aviator.AviatorEvaluator; public class VariableExpressionExample { public static void main(String[] args) { // 定义变量 String name = "John"; int age = 25; // 定义表达式，使用变量进行计算 String expression = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ff8d5dbf511d16b278755dd466fdafe2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8428f7e2c2dd66520687d2aa0c09cd23/" rel="bookmark">
			【如何获得铁粉】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 提供有价值的内容在社交媒体上积极互动利用社交媒体工具增加曝光度关注并互动其他有影响力的人维护铁粉关系给铁粉的话 想获得铁粉，需要以下几个步骤： 提供有价值的内容 铁粉是因为对你的内容或品牌产生了强烈的认同感、支持和依赖而产生的。因此，提供有价值的内容是获得铁粉的前提。
在社交媒体上积极互动 除了提供有价值的内容，还需要在社交媒体上积极互动，回复粉丝的评论和私信，与他们建立联系和沟通。
利用社交媒体工具增加曝光度 除了自己的内容，还可以利用社交媒体工具来增加曝光度，如使用关键词来吸引潜在铁粉，定期发布有趣的问答、抽奖等活动。
关注并互动其他有影响力的人 关注及互动其他有影响力的人，可以提高你的品牌知名度，吸引一些他们的粉丝成为你的铁粉。
维护铁粉关系 获得铁粉不是一件容易的事，需要维持良好的沟通和关系，回应他们的需求和反馈，让他们感觉到受到关注和尊重。
给铁粉的话 非常感谢所有支持我们的铁粉们！你们是我们前进的动力，每一个鼓励和支持都让我们感到无比温暖和感激。你们的陪伴和信任是我们永远的财富，让我们更加努力地创造更好的作品给大家！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69f85412ce8bc7ed4eb490b5f09539bc/" rel="bookmark">
			创建ubuntu-server虚拟机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 创建ubuntu-server虚拟机 绝对好使，不好用call我，手把手教你
一、和Ubuntu桌面版一样，iso选择server-iso版本： ubuntu-23.04-live-server-amd64.iso
步骤： Try or Install Ubuntu Server
语言：English
—&gt;Continue without updating
键盘布局 —&gt;“Done”
选择标准化-ubuntu Server —&gt;“Done”
获取到ip地址 —&gt;“Done”
点击 —&gt;“Done”
改镜源：https://mirrors.ustc.edu.cn/ubuntu —&gt;“Done”
使用整个硬盘：Use an entire disk —&gt;“Done”
—&gt;“Done”
—&gt;“Contiute”
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-YECuZcFc-1685980190025)(C:\Users\方便面\AppData\Roaming\Typora\typora-user-images\image-20230605140444261.png)]
输入用户名和密码
安装ssh, —&gt;“Done”
—&gt;“Done”
等待出现“Cancel update and reboot”,时间过长可以手动重启
“Cancel update and reboot”,时间过长可以手动重启
执行命令行“sudo apt-get update”,“ifconfig” 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a1a51f5cdce889d74ac767e1a06d13c/" rel="bookmark">
			Swagger原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在基于Swagger进行二次开发， 来对项目的接口进行管理，功能实现了，但是不清楚swagger的工作原理，为了后续能更好利用Swagger来管理接口，而且能借鉴Swagger的原理，将项目中其他信息可视化展示，决定Debug下Swagger的流程。版本使用的是springdoc-openapi，并不是旧版的swagger，但是口语上还是用swagger表示。
Swagger使用分两个阶段，第一个阶段是注册一些Bean，初始化一些配置。第二阶段是页面访问、接口调用，将数据填充到HTML页面展示在浏览器上。
注册静态资源 WebMvcConfigurationSupport类会实例化HandlerMapping这个Bean
实例化过程中，将所有的WebMvcConfigurer中定义的ResourceHandler放到ResourceHandlerRegistry中去。所有的WebMvcConfigurer包括系统默认的和自定义的，其中和Swagger相关的就是WebMvcAutoConfiguration类的内部类WebMvcAutoConfigurationAdapter中注册的ResourceHandler，处理的URL是/webjars/**，locations是classpath:/META-INF/resources/webjars/
另外一个和Swagger相关的是SwaggerWebMvcConfigurer，里面会处理/swagger-ui*/**路径，locations是classpath:/META-INF/resources/webjars/
ResourceHandlerRegistry注册完后，会调用ResourceHandlerRegistry的getHandlerMapping方法，实例化AbstractHandlerMapping。
对于Swagger静态资源，对应的是ResourceHttpRequestHandler。还需要注意到，最后生成AbstractHandlerMapping是SimpleUrlHandlerMapping，这在后面请求时会用到。
访问Swagger静态资源 首先访问Swagger首页地址，/swagger-ui/index.html，进入DispatcherServlet的doDispatch方法，根据Request对象获取mappedHandler
getHandler方法里面就是从不同的handlerMappings中获取HandlerExecutionChain，实际走的就是SimpleUrlHandlerMapping。
往SimpleUrlHandlerMapping的getHandler方法里看，最终是在SimpleUrlHandlerMapping父类AbstractUrlHandlerMapping的lookupHandler方法中，根据URL匹配出ResourceHttpRequestHandler，构造成HandlerExecutionChain对象返回。
再往下根据mappedHandler获取HandlerAdapter，实际获取到的就是HttpRequestHandlerAdapter
接着就会调用HttpRequestHandlerAdapter的handler方法，handler方法会将请求交给HttpRequestHandler的handleRequest方法，最终是交给ResourceHttpRequestHandler的handleRequest方法。在该方法中，首先就是获取Resource对象。
实际上是通过DefaultResourceResolverChain里面的WebJarsResourceResolver和PathResourceResolver得到最终的Resource对象，首先是将swagger-ui/index.html通过WebJarsResourceResolver转成swagger-ui/4.14.0/index.html，在将转化后的URL通过PathResourceResolver解析出Resource对象。
Swagger的静态资源是在org.webjars:swagger-ui:4.14.0中resources目录下
最后是将Resource对象的内容，写入HttpServletResponse中返回。
访问Swagger Rest接口 访问Swagger首页时，除了一些静态资源如html、css、js，Swagger还会访问/v3/api-docs/开头的后台Rest接口，这些接口会返回数据供页面使用，共同实现Swagger的功能。
像上图的swagger-config接口完整路径是/v3/api-docs/swagger-config，这个接口是在SwaggerConfigResource类中定义的。功能就是获取所有的group和对应的URL。
下面主要介绍另外一个接口，/v3/api-docs/{group}，这个接口是根据group名称获取该组下的所有接口。
接口定义是这样的
首先获取OpenApiResource对象，实际获取的是OpenApiWebMvcResource对象
接着调用openapiJson方法，最终调用的是AbstractOpenApiResource的getOpenApi方法
这个方法就是主要扫描接口的方法了，在openAPIService.build(finalLocale)那一句，就是扫描Controller的接口
当然还有其他处理，处理参数、返回值、执行一些自定义的customisers等等（后面有时间再每一步进去看下是Swagger是如何解析接口、请求数据、返回值的），最终返回一个OpenAPI对象，然后以Json格式的字符串返回给前端。
OpenAPI这个实体类的结构如下，从官网截取部分，以便理解，有了这个结构，可以自定义一些OpenApiCustomiser，对OpenAPI对象进行改动，进行二次开发，实现一些自定义功能。
openapi: 3.0.3 info: title: Swagger Petstore - OpenAPI 3.0 description: |- This is a sample Pet Store Server based on the OpenAPI 3.0 specification. You can find out more about Swagger at [https://swagger.io](https://swagger.io). In the third iteration of the pet store, we've switched to the design first approach!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a1a51f5cdce889d74ac767e1a06d13c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9447a78e7294c5847375494420434d8c/" rel="bookmark">
			PPP点到点协议 PAP认证 华为 ensp
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PPP点到点协议 ppp可以进行安全认证，但只限于两个设备之间(点到点)
所以可以扩展为PPOE，PPOE可以对多，在以太网上借助PPP的验证功能，达到既可以接入多设备又能进行验证的目的
PPP（Point-to-Point Protocol，点到点协议）是一种常见的广域网数据链路层协议，主要用于在全双工的链路上进行点到点的数据传输封装。PPP提供了安全认证协议族PAP（Password Authentication Protocol，密码验证协议）和CHAP（Challenge Handshake Authentication Protocol，挑战握手认证协议）。PPP协议具有良好的扩展性，例如，当需要在以太网链路上承载PPP协议时，PPP可以扩展为PPPoE。PPP协议提供LCP（Link Control Protocol，链路控制协议），用于各种链路层参数的协商，例如最大接收单元，认证模式等。PPP协议提供各种NCP（Network Control Protocol，网络控制协议），如IPCP（IP Control Protocol ，IP控制协议），用于各网络层参数的协商，更好地支持了网络层协议。 PPP链路建立流程 LCP报文格式 LCP协商过程 R1和R2使用串行链路相连，运行PPP协议。当物理层链路变为可用状态之后，R1和R2使用LCP协商链路参数。本例中，R1首先发送一个Configure-Request报文，此报文中包含R1上配置的链路层参数。当R2收到此Configure-Request报文之后，如果R2能识别并接受此报文中的所有参数，则向R1回应一个Configure-Ack报文。同样的，R2也需要向R1发送Configure-Request报文，使R1检测R2上的参数是不是可接受的。R1在没有收到Configure-Ack报文的情况下，会每隔3秒重传一次Configure-Request报文，如果连续10次发送Configure-Request报文仍然没有收到Configure-Ack报文，则认为对端不d可用，停止发送Configure-Request报文。 当R2收到R1发送的Configure-Request报文之后，如果R2能识别此报文中携带的所有链路层参数，但是认为部分或全部参数的取值不能接受，即参数的取值协商不成功，则R2需要向R1回应一个Configure-Nak报文。在这个Configure-Nak报文中，只包含不能接受的链路层参数，并且此报文所包含的链路层参数将被修改为R2上可以接受的取值（或取值范围）。在收到Configure-Nak报文之后，R1需要根据此报文中的链路层参数重新选择本地配置的其他参数，并重新发送一个Configure-Request。 当R2收到R1发送的Configure-Request报文之后，如果R2不能识别此报文中携带的部分或全部链路层参数，则R2需要向R1回应一个Configure-Reject报文。在此Configure-Reject报文中，只包含不能被识别的链路层参数。在收到Configure-Reject报文之后，R1需要向R2重新发送一个Configure-Request报文，在新的Configure-Request报文中，不再包含不被对端（R2）识别的参数。 PPP认证模式 - PAP LCP协商完成后，认证方要求被认证方使用PAP进行认证。PAP认证协议为两次握手认证协议，密码以明文方式在链路上发送，过程如下： 被认证方将配置的用户名和密码信息使用Authenticate-Request报文以明文方式发送给认证方。认证方收到被认证方发送的用户名和密码信息之后，根据本地配置的用户名和密码数据库检查用户名和密码信息是否匹配；如果匹配，则返回Authenticate-Ack报文，表示认证成功。否则，返回Authenticate-Nak报文，表示认证失败。 认证方携带用户名时的认证
不同用户名认证
认证方不带用户名时的认证
NCP协商 - 静态IP地址协商 NCP主要用来建立和配置不同的网络层协议，协商在该数据链路上所传输的数据包的格式与类型。常见的有IPCP等。静态IP地址商过程如下： 每一端都要发送Configure-Request报文，在此报文中包含本地配置的IP地址；每一端接收到此Configure-Request报文之后，检查其中的IP地址，如果IP地址是一个合法的单播IP地址，而且和本地配置的IP地址不同（没有IP冲突），则认为对端可以使用该地址，回应一个Configure-Ack报文。 NCP协商 - 动态IP地址协商 相当于DHCP分配地址的功能
动态协商IP地址的过程如下： R1向R2发送一个Configure-Request报文，此报文中会包含一个IP地址0.0.0.0，表示向对端请求IP地址；R2收到上述Configure-Request报文后，认为其中包含的地址（0.0.0.0）不合法，使用Configure-Nak回应一个新的IP地址10.1.1.1；R1收到此Configure-Nak报文之后，更新本地IP地址，并重新发送一个Configure-Request报文，包含新的IP地址10.1.1.1；R2收到Configure-Request报文后，认为其中包含的IP地址为合法地址，回应一个Configure-Ack报文；同时，R2也要向R1发送Configure-Request报文请求使用地址10.1.1.2，R1认为此地址合法，回应Configure-Ack报文。 IPCP配置动态地址协商功能 配置命令 PPP基础配置命令 [Huawei]int s0/0/0 [Huawei-Serial0/0/0] link-protocol ppp //配置接口为ppp接口 [Huawei-Serial0/0/0] ppp timer negotiate 10 //配置协商超时时间 一个接口只能有一种验证方式
PAP认证配置命令 认证端： [R1]aaa #添加待认证用户信息 [R1-aaa]local-user huawei password cipher huawei123 #设置验证用户和密码 [R1-aaa]local-user huawei service-type ppp #指定认证用户业务类型为ppp [R2]interface Serial 1/0/0 [R1-Serial1/0/0]link-protocol ppp [R1-Serial1/0/0]ppp authentication-mode pap #指定认证模式为PAP [R1-Serial1/0/0]ip address 10.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9447a78e7294c5847375494420434d8c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/898496d164b740cf4d533e5b8e7baae7/" rel="bookmark">
			redis源码浅析-hash表实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在redis中，除了前面说的ziplist和quicklist，还有hash结构，redis实现hash表也是基于拉链法来实现。而其对key进行hash是根据siphash算法来实现的。
typedef struct dictEntry { void *key; union { void *val; uint64_t u64; int64_t s64; double d; } v; struct dictEntry *next; } dictEntry; typedef struct dictType { uint64_t (*hashFunction)(const void *key); void *(*keyDup)(void *privdata, const void *key); void *(*valDup)(void *privdata, const void *obj); int (*keyCompare)(void *privdata, const void *key1, const void *key2); void (*keyDestructor)(void *privdata, void *key); void (*valDestructor)(void *privdata, void *obj); int (*expandAllowed)(size_t moreMem, double usedRatio); } dictType; /* This is our hash table structure.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/898496d164b740cf4d533e5b8e7baae7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93ae8b5a108a94961993a2bf4a9f42f7/" rel="bookmark">
			操作系统实验，oneapi
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（实时更新）
目录
实验四补充
实验五补充
实验四补充 一，环境搭建
注册intel devcloud账户
填写信息，提交后等待创建账户
等待邮件验证，接到以下邮件后重新访问Get Started | Intel® DevCloud
登录后点击get_start,在页面左下角点击Launch JupyterLab*
等待登录后效果如下
二，第一个for循环
在云中创建文件夹os_exp
编写helloworld示例代码
编译出错
使用另一编译方法依然报错
修改代码并换icpx命令后可以执行
结果：
结果分析：
该程序使用 SYCL 实现了一个解密算法，先将 secret 字符串拷贝到共享内存中的 result 数组中，然后针对 result 数组用parallel_for并行地将数组中的每个元素都减去 1，相当于将原文中的每个字母向前移动了一位。最后，将解密后的消息打印到控制台。
三，设备选择
方式1：默认的设备选择
编写代码：
编译执行：
结果分析：创建一个 queue 对象 Q，用于执行 SYCL 内核函数。然后，调用 get_device 方法获取与 Q 关联的设备对象，并调用 get_info 方法获取设备名称等详细信息。最后，将设备名称打印到控制台中。
方式2：使用host_selector
代码编写：
编译执行：
结果分析：
创建一个 queue 对象 Q，并将其关联到一个类型为 host_selector 的设备选择器上，选择当前可用的主机设备来处理任务。然后，通过 get_device 方法获取与 Q 关联的设备对象，并分别调用 get_info 方法来获取设备名称和制造商信息。最后，将这些信息打印到控制台中
方式3：使用cpu_selector
代码编写：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/93ae8b5a108a94961993a2bf4a9f42f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb0bbc23285ae561ef2b07051363cdbb/" rel="bookmark">
			详解5个C语言简单易懂小游戏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、准备工作二、游戏菜单三、游戏内容1.猜数字2.三子棋3.扫雷4.五子棋5.飞行棋 总结 前言 我们通过5个简单易懂的小游戏来加强我们对C语言的认识，这五个小游戏不仅有单人，还有人机对战和人人对战。让我们在学习之余来上一局紧张刺激的小游戏吧！
一、准备工作 我们要做5个小游戏，我们要分别为5个小游戏创建一个头文件和一个源文件。分别为game1.h/game1.c，game2.h/game2.c，game3.h/game3.c，game4.h/game4.c，game5.h/game5.c。这样做的目的是把每个游戏所分开构建，方便日后对我们小游戏的重构等操作。我们还须要一个main.c，用来包含这5个小游戏的头文件。main函数只负责调用，我们把所有小游戏代码函数在其他文件中实现并用static加以修饰，使用户使用game函数间接的调用我们小游戏的代码。
二、游戏菜单 我们先构建main.c：
1.它需要包含五个小游戏的头文件
2.构建我们的main函数
#include"game1.h"//包含小游戏1的头文件 #include"game2.h"//包含小游戏2的头文件 #include"game3.h"//包含小游戏3的头文件 #include"game4.h"//包含小游戏4的头文件 #include"game5.h"//包含小游戏5的头文件 #include&lt;time.h&gt; int main() { srand((unsigned int)time(NULL));//用来生成随机数 do { int optional = 0;//创建一个接收选择的变量 menu(); printf("请输入你的选项：\n"); scanf("%d", &amp;optional); switch (optional) { case 1: game1(); break; case 2: game2(); break; case 3: game3(); break; case 4: game4(); break; case 5: game5(); break; case 0: printf("感谢你的游玩，欢迎下次使用。\n"); exit(0); default: printf("你的选项输入有误，请重新输入：\n"); break; } } while (1); } 我们在main函数中用了do-while循环，目的是让用户进行选择，直到用户选择退出或者捣乱才进行退出。
scanf函数有风险，当用户捣乱输入字母时，会造成缓冲异常。所以我们把要接收的选择变量放在循环中，并且赋初始值为0，当用户输入字母时使程序退出。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb0bbc23285ae561ef2b07051363cdbb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe8407205d1c27913a0f91c4c3dd5835/" rel="bookmark">
			ffmpeg之AVCodecParameters结构体详细解释
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AVCodecParameters是FFmpeg库中的一个结构体，用于保存音视频流的基本参数信息。该结构体通常会在AVCodecContext中被填充并使用。
AVCodecParameters的定义如下：
typedef struct AVCodecParameters { int codec_type; enum AVCodecID codec_id; uint32_t codec_tag; uint8_t *extradata; int extradata_size; int format; int bit_rate; int bits_per_coded_sample; int bits_per_raw_sample; int profile; int level; int width; int height; int sample_rate; int channels; enum AVSampleFormat sample_fmt; int64_t channel_layout; AVRational sample_aspect_ratio; int fps_first_num; int fps_second_num; int delay; int seek_preroll; } AVCodecParameters; 结构体成员说明：
codectype：编解码器类型，取值为AVMEDIATYPEVIDEO、AVMEDIATYPEAUDIO、AVMEDIATYPE_SUBTITLE之一。
codec_id：编解码器的ID，取值为枚举类型AVCodecID中的一种。
codec_tag：编解码器标签。
extradata：对于某些编码器（如H.264）需要额外的信息来解码，这些信息称为“extradata”。该成员变量保存了这些额外信息的地址。
extradata_size：extradata所占用的字节数。
format：音视频帧的像素或采样格式，例如对于视频来说，可以是AVPIXFMTYUV420P、AVPIXFMTNV12等等。对于音频来说，可以是AVSAMPLEFMTS16、AVSAMPLEFMTFLTP等等。
bit_rate：比特率，用于描述音视频流的质量，单位为bps。
bitspercoded_sample：每个编码的样本所占用的位数。
bitsperraw_sample：每个采样的样本所占用的位数。
profile：编解码器的协议等级。
level：编解码器的协议等级。
width：视频帧宽度。
height：视频帧高度。
sample_rate：音频采样率。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe8407205d1c27913a0f91c4c3dd5835/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b202c844b994d64c7531ccb92e2d9e9/" rel="bookmark">
			Python 获取公开信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大众点评店铺页面最大分页数是50页，要抓取信息就是通过区域、店铺类型分解到最小达到尽可能全的抓取。以成都餐饮为例，每种分类先取到最小，区域范围依次从成都到区县到街道，如果大区域该分类小于50页就可以抓取，否则继续分解。
大众的页面有时候有加密，是通过把数据字体设置为它独有格式来实现，下载对应字体对应转码即可，有时候没有加密就可以跳过不管。
首先把数据根据地区和类型分解到小于50页并存在数据库，然后一页页抓取基本信息，最后通过观察的接口获取详细信息如详细地址、经纬度、各项评分、评价数等。
# -*- coding: utf-8 -*- import json import requests import pymysql import time from fontTools.ttLib import TTFont def woff_dict(key): if key == 'address': woff = TTFont('C:\\Users\\Administrator\\Desktop\\address.woff') # 读取woff文件 elif key == 'num': woff = TTFont('C:\\Users\\Administrator\\Desktop\\num.woff') # 读取woff文件 # woff文件中ID编号为2~602的601个字符 woff_str_601 = '1234567890店中美家馆小车大市公酒行国品发电金心业商司超生装园场食有新限天面工服海华水房饰城乐汽香部利子老艺花专东肉菜学福饭人百餐茶务通味所山区门药银农龙停尚安广鑫一容动南具源兴鲜记时机烤文康信果阳理锅宝达地儿衣特产西批坊州牛佳化五米修爱北养卖建材三会鸡室红站德王光名丽油院堂烧江社合星货型村自科快便日民营和活童明器烟育宾精屋经居庄石顺林尔县手厅销用好客火雅盛体旅之鞋辣作粉包楼校鱼平彩上吧保永万物教吃设医正造丰健点汤网庆技斯洗料配汇木缘加麻联卫川泰色世方寓风幼羊烫来高厂兰阿贝皮全女拉成云维贸道术运都口博河瑞宏京际路祥青镇厨培力惠连马鸿钢训影甲助窗布富牌头四多妆吉苑沙恒隆春干饼氏里二管诚制售嘉长轩杂副清计黄讯太鸭号街交与叉附近层旁对巷栋环省桥湖段乡厦府铺内侧元购前幢滨处向座下臬凤港开关景泉塘放昌线湾政步宁解白田町溪十八古双胜本单同九迎第台玉锦底后七斜期武岭松角纪朝峰六振珠局岗洲横边济井办汉代临弄团外塔杨铁浦字年岛陵原梅进荣友虹央桂沿事津凯莲丁秀柳集紫旗张谷的是不了很还个也这我就在以可到错没去过感次要比觉看得说常真们但最喜哈么别位能较境非为欢然他挺着价那意种想出员两推做排实分间甜度起满给热完格荐喝等其再几只现朋候样直而买于般豆量选奶打每评少算又因情找些份置适什蛋师气你姐棒试总定啊足级整带虾如态且尝主话强当更板知己无酸让入啦式笑赞片酱差像提队走嫩才刚午接重串回晚微周值费性桌拍跟块调糕' # ['cmap']为字符与Unicode编码的映射关系列表 woff_unicode = woff['cmap'].tables[0].ttFont.getGlyphOrder() # 获取603个字符对应的unicode编码 woff_character = ['.notdef', 'x'] + list(woff_str_601) # 添加编号为0、1的两个特殊字符 woff_dict = dict(zip(woff_unicode, woff_character)) return woff_dict def decodestr(firststr): strlist = firststr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b202c844b994d64c7531ccb92e2d9e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12f520977979f5e95ca6470ea5221b23/" rel="bookmark">
			HCIP-7.1交换机ARP、VLAN之间的三层通信技术学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		交换机ARP、VLAN之间的三层通信技术学习 1、ARP1.1、 地址解析过程1.2、ARP报文格式1.3、ARP表项1.4、免费ARP1.5、 VLAN间ARP代理1.5.1、解决同网段，不同广播域内主机互通问题；1.5.2、解决同网段，不同VLAN之间主机互通问题。1.5.3、解决同网段，同VLAN内由于配置了端口隔离/连接到DSLAM设备，导致的同VLAN主机无法互通问题。 2、三层交换机实现VLAN之间的三层通信 1、ARP ARP（Address Resolution Protocol）用于将一个IP地址映射到正确的MAC地址。
为ARP 代理：
一个物理网络的子网（Subnet）中的源主机向另一个物理网络的子网中的目的主机发ARP request，和源主机直连的网关用自己接口的MAC地址代替目的主机回ARP reply，这个过程称为ARP 代理。
1.1、 地址解析过程 在以太网内二层(指三层交换机有vlanif接口，才有IP，二层交换机没有IP，ARP不能使用)。
查询MAC地址，ARP请求报文，只有源MAC地址，目的MAC为00。
1、同一网段内
1)、在同一广播域内，所有主机处于同一网段，主机A要向主机C发送信息，主机A的ARP表中没有对应的MAC地址，主机先以广播方式发送一个ARP请求报文。ARP请求报文中的发送端IP地址和发送端MAC地址为主机A的源IP地址和源MAC地址，目标IP地址和目标MAC地址为主机C的IP地址和全0的MAC地址。
2)、ARP的请求以广播方式发出，在同一广播域内所有主机都可以接收到该请求，但只有被请求的主机C才会对该请求进行处理。
3)、收到ARP的主机C通过比较接收的目的IP地址与自己的IP地址相同，查询自己的ARP表有没有主机A的MAC地址，没有就添加主机A的MAC地址和IP地址。
4)、响应是单播方式发出，包含有自己的MAC地址。
ARP是不能穿越广播域，就是不能穿越路由器或VLAN。三层设备路由器不转发ARP广播。
地址解析协议 ARP 作用：在主机 ARP 高速缓存中存放一个从 IP 地址到硬件地址的映射表，并且这个映射表经常动态更新。每一台主机都设有一个 ARP 高速缓存(ARP Cache)，里面有本局域网上的各主机和路由器的 IP 地址到硬件地址的映射表(并且每一个映射地址都设置有生存时间)。
2、不在同一网段
发送给网关的是报文，不是arp查询请求。
当主机A和主机D不在同一网段时，主机A就会先向网关(路由器)发出ARP请求， ARP请求报文中的目标IP地址为网关的IP地址。
当主机A从收到的响应报文中获得网关的 MAC地址后，将报文封装并发给网关。
如果网关没有主机D的ARP表项，网关会广播ARP请求，目标IP地址为主机D 的IP地址，当网关从收到的响应报文中获得主机D的 MAC 地址后，就可以将报文发给主机 D；
如果网关已经有主机 B 的 ARP 表项，网关直接把报文发给主机 B。
1.2、ARP报文格式 太网帧类型：为0x0806（ARP请求和ARP应答）
硬件地址的类型：以太网类型时此值为1。
协议地址的类型：此值为0x0800（对IPv4地址进行映射）。
硬件地址长度和协议地址长度：MAC地址占6字节，IP地址占4字节。
操作类型字段Operation Code：值为1，表示进行ARP请求；值为2，表示进行ARP应答；值为3，表示进行RARP请求；值为4，表示进行RARP应答。
目的以太网地址，全1时代表广播地址FF-FF-FF-FF-FF。
1.3、ARP表项 ARP 表项分为动态 ARP 表项和静态 ARP 表项。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/12f520977979f5e95ca6470ea5221b23/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bebed88567f872a84d774a58bdc350fe/" rel="bookmark">
			C&#43;&#43; 多进程编程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在C++中，可以使用多种方式进行多进程编程。以下是一些常见的方法：
fork()函数：这是Unix/Linux系统中的一个系统调用，可以创建一个新的进程。在调用fork()函数后，父进程会创建一个子进程，两个进程将在fork()调用的位置继续执行。父进程和子进程具有不同的进程ID（PID）。可以根据fork()函数的返回值来区分父进程和子进程。 下面是一个使用fork()函数创建子进程的简单示例：
#include &lt;iostream&gt;
#include &lt;unistd.h&gt;
int main() {
pid_t pid = fork();
if (pid == -1) {
// 创建子进程失败
std::cout &lt;&lt; "Failed to fork!" &lt;&lt; std::endl;
return 1;
} else if (pid == 0) {
// 子进程
std::cout &lt;&lt; "Hello from child process!" &lt;&lt; std::endl;
} else {
// 父进程
std::cout &lt;&lt; "Hello from parent process!" &lt;&lt; std::endl;
}
return 0;
}
exec()函数族：在子进程中，可以使用exec()函数族中的一个函数来加载一个新的可执行文件，并在当前进程空间中执行它。exec()函数会取代当前进程的代码和数据，所以一般在调用fork()后立即调用exec()函数。 下面是一个使用fork()和exec()函数族的示例：
cppCopy code
#include &lt;iostream&gt; #include &lt;unistd.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bebed88567f872a84d774a58bdc350fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd5d3c4719f3f881461764ae47b59254/" rel="bookmark">
			Python中的缩进是什么意思？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在Python中，缩进是指在代码中使用空格或制表符来表示代码块的层次结构。Python使用缩进作为语法的一部分，以定义代码的逻辑结构和代码块的范围。缩进在Python中具有以下几个重要的方面和含义。
代码块的开始和结束： 缩进在Python中用于标识代码块的开始和结束。通过缩进，可以将一组相关的语句组织在一起形成一个代码块，这个代码块执行特定的功能。缩进的空格数或制表符数目决定了代码块的层次结构。通常情况下，使用四个空格作为一个缩进级别。
代码的可读性： 缩进在Python中是强制性的，不仅仅是为了美观，更重要的是提高代码的可读性。通过缩进，代码的结构清晰可见，可以轻松理解代码的层次关系，而不需要依赖大括号或关键字来表示代码块。
条件语句和循环结构： 缩进在条件语句和循环结构中起着关键的作用。例如，if语句用于条件判断，后面的缩进代码块表示满足条件时执行的代码；while和for循环也使用缩进来表示循环体中的代码。缩进的正确使用确保了代码块的正确执行和逻辑的准确性。
命名空间和作用域： 缩进在Python中还用于定义命名空间和作用域。在一个代码块中定义的变量、函数或类，只在该代码块中有效，不能在其他代码块中直接访问。通过缩进，可以明确区分不同代码块的作用域范围，避免命名冲突和混乱的作用域问题。
Python风格指南（PEP 8）： 缩进在Python编程中遵循PEP 8（Python Enhancement Proposal 8）风格指南的建议。PEP 8建议使用四个空格作为缩进级别，并禁止使用制表符缩进。遵循PEP 8的规范，可以提高代码的一致性和可维护性，使不同开发者编写的代码风格保持统一。
异常处理： 缩进在Python的异常处理中也很重要。在try和except语句中，try代码块中的代码会被执行，如果发生异常，则跳转到except代码块中处理异常。正确的缩进确保了异常处理代码的正确执行，同时保持了代码的可读性。
总结起来，Python中的缩进是指用于标识代码块的空格或制表符，它具有以下几个重要的方面和含义：
代码风格的统一性： 缩进在Python中被视为良好的代码风格的一部分。统一的缩进风格使得不同开发者编写的代码具有一致性，提高了代码的可读性和可维护性。在协作开发中，遵循相同的缩进规则有助于减少混乱和错误。
语法错误的检测： Python解释器依赖缩进来解析代码的结构。如果缩进不正确，解释器将会报告缩进错误，从而帮助开发者及时发现潜在的语法问题。正确的缩进有助于编写出符合语法规则的代码。
块级代码的组织： 缩进用于将相关语句组织在一起形成一个代码块。代码块可以是函数、类、循环体、条件语句等。通过适当的缩进，可以清晰地定义和区分不同的代码块，提高代码的可读性和可理解性。
注释的可见性： 缩进还影响注释的可见性。Python中的注释以"#"开头，位于代码行的末尾或单独一行。如果注释与代码在同一缩进级别，那么注释将被视为代码的一部分；如果注释的缩进级别高于代码，那么它将被视为对代码的解释或说明。适当的缩进可以使注释与相关代码保持一致，提供清晰的注释说明。
代码的可重用性： 缩进有助于标识出可重用的代码段。通过将可重用的代码块定义为函数或类，并在需要的地方调用，可以提高代码的模块化程度和重用性。适当的缩进使得代码块的定义和调用之间的关系清晰可见。
代码的维护和调试： 缩进对于代码的维护和调试也非常重要。适当的缩进使得问题定位和代码修改更加容易。缩进错误可能导致代码逻辑错误，通过正确的缩进可以减少出错的可能性，同时有助于提高代码的可维护性和可调试性。
综上所述，Python中的缩进是指用于标识代码块和控制代码结构的空格或制表符。它在代码的可读性、代码风格的统一性、作用域的划分、语法错误的检测、注释的可见性等方面具有重要的意义。正确使用缩进可以帮助开发者编写结构清晰、可读性强的Python代码，提高代码的可维护性和可扩展性。以下是一些使用缩进的最佳实践和注意事项：
使用一致的缩进风格： 为了代码的一致性，应该在整个项目中使用相同的缩进风格。根据PEP 8的建议，使用四个空格作为缩进级别，避免使用制表符缩进。
缩进层次与代码块的关系： 缩进应该与代码块的层次结构相匹配，使得代码块的开始和结束更加清晰。每个代码块应该增加一个缩进级别，并且在代码块结束后返回到上一级的缩进级别。
注意缩进错误： 缩进错误是常见的错误类型之一。因此，应该格外注意缩进的正确性。注意缩进的空格数或制表符数目，确保代码块的开始和结束正确对齐。
使用代码编辑器的自动缩进功能： 大多数代码编辑器都提供了自动缩进功能，可以自动根据代码的层次结构调整缩进。使用这些功能可以减少手动调整缩进的工作，提高开发效率。
避免过深的嵌套： 过深的嵌套代码块会导致可读性下降。如果代码块的嵌套层次过多，可以考虑重构代码，使其更加扁平化，减少嵌套层次。
注意空行的缩进： 在代码块之间和函数定义之前应该留出适当的空行，但这些空行不应该有缩进。空行的缩进应该与相邻代码块的缩进保持一致。
使用缩进来分隔代码的逻辑部分： 缩进可以帮助将代码分隔为逻辑上相关的部分，使得代码结构更加清晰。在函数、循环和条件语句等逻辑结构之间使用适当的缩进，以突出代码的逻辑关系。
注意缩进与语句对齐的区别： 在Python中，缩进是用于标识代码块的层次结构，而与语句的对齐无关。在代码块中，语句可以有不同的缩进级别，但它们的开始位置应该对齐。
使用代码静态分析工具： 代码静态分析工具（例如flake8、pylint等）可以帮助检测缩进错误和其他代码规范问题。使用代码静态分析工具可以及早发现并纠正缩进错误，确保代码的一致性和质量。
在多行语句中正确处理缩进： 当一条语句太长需要分成多行时，需要注意在新行中的缩进。通常情况下，新行应该与前一行的末尾对齐，并且增加一个额外的缩进级别以表示语句的继续。
注释的缩进： 注释应该与相应的代码行保持一致的缩进级别，以确保注释与代码之间的关系清晰可见。注释也可以使用缩进来指示注释的层次结构。
注意特殊情况下的缩进规则： 在一些特殊情况下，如装饰器、多重异常处理等，可能需要额外注意缩进规则。遵循相关的Python语法和最佳实践来处理这些特殊情况下的缩进。
编写可读性高的缩进代码： 缩进的目的是提高代码的可读性，因此应该编写易于理解和解释的缩进代码。遵循良好的命名约定、适当的注释和代码结构等，以增强缩进代码的可读性。
遵循团队的缩进约定： 如果你在一个团队中工作，应该遵循团队的缩进约定和代码风格。这有助于保持团队中代码的一致性，减少沟通和合并冲突的困扰。
不要滥用缩进： 虽然缩进在Python中非常重要，但不应该滥用。避免过分深入的嵌套和过多的缩进级别，这可能导致代码复杂性增加和可读性下降。
总结起来，缩进在Python中是用于标识代码块、控制代码结构、提高可读性和维护性的重要元素。正确的缩进风格、注意缩进错误、使用静态分析工具、适当处理多行语句和注释的缩进等，都是编写清晰、可读性强的Python代码的关键要素。在团队合作中，遵循团队的缩进约定也是一种良好的实践。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60fdf27e6bf1d8a6a4d7f355e36a1b10/" rel="bookmark">
			使用MyBatis-Sharding 框架进行分库分表具体代码实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.使用 MyBatis-Sharding 框架进行水平分库分表，需要进行以下几个步骤： 配置数据源和分片规则。 在 application.yml 中配置数据源和分片规则，例如：
yaml
spring: shardingsphere: datasource: names: ds0,ds1 ds0: jdbcUrl: jdbc:mysql://localhost:3306/db_0?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true username: root password: root driverClassName: com.mysql.jdbc.Driver ds1: jdbcUrl: jdbc:mysql://localhost:3306/db_1?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true username: root password: root driverClassName: com.mysql.jdbc.Driver sharding: tables: user: actualDataNodes: ds$-&gt;{0..1}.user_$-&gt;{0..2} tableStrategy: inline: shardingColumn: id algorithmExpression: user_$-&gt;{id % 3} keyGenerateStrategy: column: id keyGeneratorName: snowflake bindingTables: user 上面的配置文件中定义了两个数据源 ds0 和 ds1，以及一张表 user。其中，actualDataNodes 定义了真实的数据节点，通过 $-&gt;{n} 的方式指定分片范围；tableStrategy 定义了分表策略，可以使用内置算法或自定义算法；keyGenerateStrategy 定义了主键生成策略，这里使用了雪花算法；bindingTables 定义了绑定表，这里只有一张表。
编写Mapper接口和SQL语句。 java
public interface UserMapper { int insert(User user); User selectByPrimaryKey(Long id); List&lt;User&gt; selectAll(); } xml
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60fdf27e6bf1d8a6a4d7f355e36a1b10/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d81d89baf24987dae66865c4d1337481/" rel="bookmark">
			将数据表设计导出数据字典
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 将数据表设计导出数据字典 第一步查询表结构 SELECT t.TABLE_SCHEMA AS 库名, t.TABLE_NAME AS 表名, t.COLUMN_NAME AS 字段名, t.COLUMN_TYPE AS 数据类型, CASE IFNULL(t.COLUMN_DEFAULT,'Null') WHEN '' THEN '空字符串' WHEN 'Null' THEN 'NULL' ELSE t.COLUMN_DEFAULT END AS 默认值, CASE t.IS_NULLABLE WHEN 'YES' THEN '是' ELSE '否' END AS 是否允许为空, t.COLUMN_COMMENT AS 字段说明 FROM information_schema.COLUMNS t WHERE t.TABLE_SCHEMA='库名' AND t.TABLE_NAME='表名' 第二步导出数据即可 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/290a2aa434c26a39afcd338af04353af/" rel="bookmark">
			“This application failed to start because no Qt platform plugin could be“问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用matplotlib的时候出现报错"This application failed to start because no Qt platform plugin could be" 之前使用是没有问题的，这几天莫名其妙出现这个问题，具体原因没有深究，这里分享我的成功解决案例。
1.安装pyqt5 pip install pyqt5 -i https://pypi.tuna.tsinghua.edu.cn/simple pip install pyqt5-tools -i https://pypi.tuna.tsinghua.edu.cn/simple 如果报错可以尝试：1.升级pip 2.关掉代理
我目前环境中的包：
还有可能是pyqt5-plugins和pyqt5版本不兼容导致的，请参考
https://blog.csdn.net/qq_55822954/article/details/123240588
2.配置环境变量 添加了一个系统变量
然后添加path变量
注：在我配置到这里的时候还是报错，是因为我的path里还添加了别的QT路径，后来删掉这些路径，只保留了上图所示的路径后代码就不报错了。
3.其他解决方案 如果重新安装pyqt、配置好环境变量以后还是报错，可以参考下面几种解决方式：
1.matplotlib默认使用QTAgg，改成TKAgg
https://blog.csdn.net/weixin_53640905/article/details/127853697
2.嵌入代码
https://blog.csdn.net/zzx188891020/article/details/105813976
3.修改ide设置
https://blog.csdn.net/NSSC_K/article/details/88670686
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8cf7a498c156a49d128ff5ed5d8457d/" rel="bookmark">
			零基础学习xlwings，看这篇文章就够了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近有位小伙伴留言说想让出一篇有关slwings的文章，这不文章来啦～～～
本篇文章是围绕以下四点带大家学习xlwings。
1、xlwings是什么
2、xlwings安装更新与卸载
3、xlwings详细使用
4、案例分享
xlwings是什么 在日常生活中我们或多或少的都会跟Excel打交道，比如做销售统计，人力的考勤，学生的考试成绩等等，甚至在某些领域会涉及到批量操作Excel表格，那对于非程序员来说，可能使用Excel中的函数，但是在某种场景下这些又是不好使的，只能熬夜加班啦！但是对于程序员来说，可能就是分分钟的事，轻松搞定。
那在我们Python中有哪些模块（或者第三方库）可以轻松处理Excel 呢？给大家列出来学习一下
哇slwings是不是很香，更详细的大家可以去参看趣味干货中的：Python杀死Excel？众多模块哪家强。
简单介绍下xlwings，xlwings是一个可以实现从Excel调用Python，也可在python中调用Excel的库。开源免费，一直在更新。特点：
1）xlwings支持.xls读，支持.xlsx文件读写。 2）支持Excel操作。 3）支持VBA。 4）强大的转换器可以处理大部分数据类型，包括在两个方向上的numpy array和pandas DataFrame。
文档链接：https://docs.xlwings.org/en/stable/index.html
有没有发现，xlwings宗旨就是让Excel飞起来！！！
xlwings安装与使用 安装
像安装其他模块一样，使用pip安装即可
pip install xlwings
如果你是在使用Anaconda也可以，使用conda安装
conda install xlwings
请注意，官方的conda软件包可能落后于几个版本。但是，您可以使用conda-forge通道（如果已经安装了xlwings，请用upgrade替换安装）：
conda install -c conda-forge xlwings
注意：在安装过程中，xlwings也是有依赖项的，但是依赖项通过conda或pip自动安装
Windows：pywin32
Mac：psutil，appscript
如果原来安装过，使用如下操作更新
要更新到最新的xlwings版本，请在命令提示符中运行以下内容：
pip install --upgrade xlwings
或者：
conda update -c conda-forge xlwings
通过运行以下内容（确保先关闭Excel），确保您的Excel加载项版本与您的Python软件包保持同步：
xlwings addin install
若要卸载xlwings，移步下面的操作
要完全卸载xlwings，请先卸载加载项，然后使用安装xlwings软件包时使用的相同方法（pip或conda）卸载xlwings软件包：
xlwings addin remove
然后
pip uninstall xlwings
或者：
conda remove xlwings
最后，手动删除个人文件夹中的.xlwings目录（如果存在）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e8cf7a498c156a49d128ff5ed5d8457d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71b4c42c0c81d14dfe1aa10ca13a5d75/" rel="bookmark">
			Python关键词搜索排名抓取之搜狗移动端搜索结果抓取之隧道代理IP版本(crawl_sougou_mobile_v2.py)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		# -*- coding:utf-8 -*- import urllib from urllib.parse import unquote from pyquery import PyQuery as pq import pandas as pd import os from urllib import request import re import common from time import sleep os.environ['NO_PROXY'] = "www.sogou.com" # 联塑 # 中国联塑 # lesso联塑 # 联塑班皓 # 班皓 class crawl_infos: def __init__(self): self.proxy = common.get_ip() def get_html(self, key_word, page): while True: try: wd = urllib.parse.quote(key_word) if page != 1: url = f"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/71b4c42c0c81d14dfe1aa10ca13a5d75/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1a4861bf88c05c582f55820013acd32/" rel="bookmark">
			IP路由原理、静态路由及动态路由区分
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IP路由原理、静态路由及动态路由区分 1、什么是路由?2、路由的原理3、路由来源3.1、静态路由概述3.1.1、静态路由配置3.2、缺省路由/默认路由3.3、黑洞路由3.4、动态路由4、路由的优先级5、路由的度量值（metric）6、路由的选路规则7、负载均衡8、路由的环路9、特殊路由 1、什么是路由? 路由器
在互联网中进行路由选择所使用的设备，或者说，实现路由的设备，我们称之为路由器。
路由器关键功能：检查数据包的目的地确定信息源发现可能的路由选择最佳路由验证和维护路由信息 什么是路由
路由是指导IP报文发送的路径信息。
A查自己的路由表找到最佳路径 B 查自己的路由表找到最佳路径–&gt;C --&gt;目标网络。
2、路由的原理 路由表
路由器工作时依赖于路由表进行数据的转发。路由表犹如一张地图，它包含着去往各个目的的路径信息（路由条目）。每条信息至少应该包括下面3个内容：
目的网络——表明路由器可以到达的网络的地址，可理解为去哪里。下一跳——通常情况下，下一跳(next hop)一般指向去往目的网络的下一个路由器的接口地址，该路由器称之为下一跳路由器。出接口——表明数据包从本路由器的哪个接口发送出去。
[R1]dis ip routing-table Route Flags: R – relay转发, D - download to fib来自路由表 ------------------------------------------------------------------------------ Routing Tables: Public Destinations : 13 Routes : 14 Destination/Mask Proto Pre Cost Flags NextHop Interface 0.0.0.0/0 Static 60 0 D 0.0.0.0 NULL0 1.1.1.1/32 Direct 0 0 D 127.0.0.1 LoopBack1 12.0.0.0/24 Direct 0 0 D 12.0.0.1 GigabitEthernet 0/0/0 12.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e1a4861bf88c05c582f55820013acd32/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08b9a7dde61351a099259d1226f723e8/" rel="bookmark">
			YOLOv8训练参数详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		全部参数表 首先罗列一下官网提供的全部参数。
1. model ✰✰✰✰✰ model: 模型文件的路径。这个参数指定了所使用的模型文件的位置，例如 yolov8n.pt 或 yolov8n.yaml。
选择.pt和.yaml的区别 若我们选择 yolov8n.pt这种.pt类型的文件，其实里面是包含了模型的结构和训练好的参数的，也就是说拿来就可以用，就已经具备了检测目标的能力了，yolov8n.pt能检测coco中的80个类别。但如果你需要检测的类别不在其中，例如口罩检测，那么就需要重新训练。训练自己的数据集，我们一般采用yolov8n.yaml这种.yaml文件的形式，在文件中指定类别，以及一些别的参数。 2. data ✰✰✰✰✰ data: 数据文件的路径。该参数指定了数据集文件的位置，例如 coco128.yaml。数据集文件包含了训练和验证所需的图像、标签。
3. epochs ✰✰✰ epochs: 训练的轮数。这个参数确定了模型将会被训练多少次，每一轮都遍历整个训练数据集。训练的轮数越多，模型对数据的学习就越充分，但也增加了训练时间。
选取策略 默认是100轮数。但一般对于新数据集，我们还不知道这个数据集学习的难易程度，可以加大轮数，例如300，来找到更佳性能。
4. patience patience: 早停的等待轮数。在训练过程中，如果在一定的轮数内没有观察到模型性能的明显提升，就会停止训练。这个参数确定了等待的轮数，如果超过该轮数仍没有改进，则停止训练。
早停 早停能减少过拟合。过拟合(overfitting)指的是只能拟合训练数据, 但不能很好地拟合不包含在训练数据中的其他数据的状态。
5. batch ✰✰✰✰✰ batch: 每个批次中的图像数量。在训练过程中，数据被分成多个批次进行处理，每个批次包含一定数量的图像。这个参数确定了每个批次中包含的图像数量。特殊的是，如果设置为**-1**，则会自动调整批次大小，至你的显卡能容纳的最多图像数量。
选取策略 一般认为batch越大越好。因为我们的batch越大我们选择的这个batch中的图片更有可能代表整个数据集的分布，从而帮助模型学习。但batch越大占用的显卡显存空间越多，所以还是有上限的。
6. imgsz ✰✰✰✰✰ imgsz: 输入图像的尺寸。这个参数确定了输入图像的大小。可以指定一个整数值表示图像的边长，也可以指定宽度和高度的组合。例如640表示图像的宽度和高度均为640像素。
选取策略 如果数据集中存在大量小对象，增大输入图像的尺寸imgsz可以使得这些小对象从高分辨率中受益，更好的被检测出。从官网放出的性能表也可以看出。
7. save、save_period ✰✰✰ save: 是否保存训练的检查点和预测结果。当训练过程中保存检查点时，模型的权重和训练状态会被保存下来，以便在需要时进行恢复或继续训练。预测结果也可以被保存下来以供后续分析和评估。save_period: 保存检查点的间隔。这个参数确定了保存检查点的频率，例如设置为10表示每隔10个训练轮数保存一次检查点。如果设置为负数（如-1），则禁用保存检查点功能。 和resume配合 和resume配合可以在训练不稳定中断后再进行接着训练。例如大家白嫖Colab这个平台训练网络时，一般是有时间限制，会出现时间到了我们还没训练完的情况。通过save然后再resume重新启动可以进行接着训练。
8. cache cache: 数据加载时是否使用缓存。这个参数控制是否将数据加载到缓存中，以加快训练过程中的数据读取速度。可以选择在 RAM 内存中缓存数据（True/ram）、在磁盘上缓存数据（disk）或不使用缓存（False）。
9. device ✰✰✰✰✰ device: 训练运行的设备。该参数指定了模型训练所使用的设备，例如使用 GPU 运行可以指定为 cuda device=0，或者使用多个 GPU 运行可以指定为 device=0,1,2,3，如果没有可用的 GPU，可以指定为 device=cpu 使用 CPU 进行训练。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/08b9a7dde61351a099259d1226f723e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ef8eca213bdea4974654b670fd7216b/" rel="bookmark">
			HCIP-7.2VLAN间通信单臂、多臂、三层交换方式学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VLAN间通信单臂、多臂、三层交换方式学习 1、单臂路由2、多臂路由3、三层交换机的SVI接口实现VLAN间通讯3.1、VLANIF虚拟接口3.2、VLAN间路由3.2.1、单台三层路由VLAN间通信，在一台三层交换机内部VLAN之间直连。3.2.2、两台三层交换机的之间的VLAN通信。3.2.3、将物理接口直接变成三层接口 3.3、VLAN Maping，主要运用在运营商环境里。3.4、VLAN switch 1、单臂路由 单臂路由（router-on-a-stick）是指在路由器的一个接口上通过配置子接口（或“逻辑接口”，并不存在真正物理接口）的方式，实现原来相互隔离的不同VLAN（虚拟局域网）之间的互联互通。
注意：子接口与vlan if的不同。子接口是在物理端口下开设虚拟子接口。而vlanif是交换机虚拟接口。
虚拟子接口：路由器的物理接口可以被划分为多个逻辑接口，每个子接口对应一个VLAN网段的网关。
PC1发送数据帧经过交换机的G0/0/1接口，加上vlan10的标识, MAC条目上有Route标记，则进行硬件三层转发。
路由器子接口G0/0/1.10接收到该数据帧，查找目的IP的网段路由，存在，查找下一跳的ARP表，如果ARP不存在，进行ARP学习。学习到ARP后，发现该路由对应子接口F0/0.2进行报文转发，并将转发信息写入硬件主机路由表，进行硬件三层转发。
主干链路里面传输的是有标签的数据，那么在路由端，路由端必须要能识别带标签的数据。
路由器接口充当网关，但是路由器就只有一个接口和交换机相连，这时引入子接口也是逻辑接口。逻辑接口是基于物理接口的，每个物理接口可以逻辑成大概42亿万个逻辑接口。
我们用模拟出来的逻辑接口充当网关，由于要传输trunk干道链路的带tag数据，所以，要封装802.1Q接口。
[Huawei]interface GigabitEthernet 0/0/1.10 \\进入0/0/1的子接口10 [Huawei-GigabitEthernet0/0/1.10]dot1q termination vid 10 \\封装802.1Q接口剥掉tag 10标签，传输去掉标签的数据。 [Huawei-GigabitEthernet0/0/1.10]arp broadcast enable \\开启广播 [Huawei-GigabitEthernet0/0/1.10]ip address 10.0.0.1 24 [Huawei]interface GigabitEthernet 0/0/0.20 [Huawei-GigabitEthernet0/0/1.20]dot1q termination vid 20 [Huawei-GigabitEthernet0/0/1.20]arp broadcast enable [Huawei-GigabitEthernet0/0/1.20]ip address 10.0.0.1 24 配置中易错点：
交换机和路由器相连的端口属性要设置为Trunk且运行所有vlan通过；和路由器直接相连的接口（不是子接口）不能设置IP；路由器的子接口要记得开启arp广播请求；
（不是子接口）不能设置IP；主机ip和子接口ip地址（所对应的网关地址）不能重复。 单臂路由的缺点：
“单臂”为网络骨干链路，容易形成网络瓶颈(单点故障：如果物理接口出现故障，那所有的VLAN间通信都断开了。)子接口依然依托于物理接口，应用不灵活VLAN间转发需要查看路由表，严重浪费设备资源 2、多臂路由 使用路由器物理接口通信，这种方法面临着一个主要的问题：每一个VLAN都需要占用路由器上的一个物理接口，如果VLAN数目众多，就需要占用大量的路由器接口。所以，在实际的网络部署中，几乎都不会通过多臂路由器来实现VLAN间的三层通信。
PC1数据进入access接口时，会给该数据帧添加一个带有vlan10的标签，从另一个access接口出去时，access接口会脱掉该数据的标签；
进入路由器后，寻找该数据帧的目的IP地址，查询路由表后，从关联目标网段的接口发送数据包；
数据包进入交换机时，交换机接收的二层数据包含目的MAC和vlan ID是20的客户机，先将无标签数据打上vlan20的标签，在VLAN 20的广播域查找目标客户机的MAC地址。
查找到客户机后，将数据帧发送给目标客户机，从交换机的另一个access接口发出，在该接口又会把vlan20的标签脱掉，然后发送给PC4。
交换机配置：
sys sysname sw1 vlan batch 10 20 int e0/0/1 port link-type access port default vlan 10 int e0/0/2 port link-type access port default vlan 10 int e0/0/3 port link-type access port default vlan 20 int e0/0/4 port link-type access port default vlan 20 路由器配置：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ef8eca213bdea4974654b670fd7216b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3457c1bf99b5236978143bb63a81420/" rel="bookmark">
			【微前端】记录一次使用react及京东micro-app实现谷歌auth2授权登录的流程 及所遇到的问题排查及最终解决方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先，谷歌授权登录需要到google clound上创建一个项目，创建完成后需要创建凭证，之后需要创建web形式的谷歌同意登录屏幕。
背景 我们的项目是建立在electron的基础上搭配micro-app微前端（基座）嵌入各个模块子应用（react脚手架创建的web应用）的搭配模式。
同意按钮使用的第三方插件是react-google-login（用来对接谷歌登录api以及提供统一的登录按钮样式的组件），gapi-script（谷歌的api包）需要初始化。
奇怪的现象 我们的应用是起一个微服务基座对接electron（客户端）的内容，同时再起一个本地子应用服务去实现的谷歌登录按钮（内嵌点击成功和失败回调等api），单独在子应用的服务里加载react-google-login组件按钮，可以正常点击，但是在基座+electron应用服务内（合称桌面客户端）按钮是置灰的，经过多次排查，发现是京东micro-app微前端的沙箱导致的该问题，验证方法是关闭沙箱代理可复现。
定位原因 写了个微前端demo，通过查看发现，点击登录同意按钮后，会自发地异步调用google的多个资源接口，包括字体、JS文件等等。其中有2个js文件是有依赖的，前者的执行依赖后者，且js文件中有多处对window进行了修改，我们知道基座通过proxy代理的方式把全局对象管控了，因此无法直接修改window，与此同时子应用是在沙箱环境中点击的按钮触发请求资源。所以这个时候有依赖的js文件之间获取到的window是undefined，因此报错。
但是我们项目是需要沙箱的，这要怎么办呢？ 这边有个前提，我们登录获得同意后，可以拿到部分用户信息例如邮箱、accessToken等信息，这个时候我们还需要通知桌面客户端人员帮我们进行数据处理，他需要拿着这个accessToken去获取谷歌的其他权限。
为了跳过沙箱的限制，我们有以下方案： 1、在桌面端打开一个窗体（electron方式），跳过基座的对子应用的沙箱隔离，这种方式的缺陷是，会导致新开窗体的进程无法被管控，也就是进程无法被kill
2、使用iframe，但是这种方式会丢失全局桥接的对象jsbridge，需要使用类似postMessage消息通知的方式重新获取全局桥接对象
3、采用window.open方式打开一个新的页面（这种方式同样会丢失全局对象，所以需要后续的操作），再以请求或者客户端的协议地址方式进行访问，通知到接口或者协议拦截模块，如果是接口，则创建前端轮询，查到数据就断开链接，关闭轮询。如果是走的客户端协议地址访问的，则由这些拦截模块帮助我们进行调用桌面端特定的方法进行传递用户授权参数给到桌面端的同学。（为什么这么绕呢？因为我们打开的是新的窗体，他不在桌面容器中，没有宿主容器的同时，也缺少全局桥接对象jsbridge，所以我们需要想办法传参给桌面端）。【最终采用的方案】
尝试过但失败的方案： 1、在子应用中以iframe的方式打开授权登录页，但是会导致应用内的token及相关信息无法从容器（基座）注入，导致401授权失败。因此需要先通过跨域postMessage类似的方式将数据传入才能正常展示。
2、子应用直接使用弹窗打开授权登录组件，失败，因为沙箱拦截了google登录所需的网络资源。且因为谷歌授权登录获取资源是自发的请求，我们无法控制，又因为沙箱也是封闭的，通过仅仅暴露出来的escapeProperties无法解决，也不能直接disableSandbox。
3、通过electron的shell.external打开外部客户端默认网页，失败，虽然按钮能被点击，但是无法和容器内的子应用通信，即便传入了全局对象jsbridge也不行，因为运行的宿主环境缺失。
4、通过window.open打开一个独立窗体，情况和第3条一致。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0661b1afd2d1998e62e9be2f4906de9/" rel="bookmark">
			Python正则表达式例子讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因为字符串处理无所不在，正则毫无疑问是最简洁和高效的处理方法。今天我们要来一起梳理的知识点就是Python正则表达式。本文将用十个Python正则表达式的例子，帮助初学者入门Python正则表达式，下面一起来看看吧~
1、查找第一个匹配串
s = 'i love python very much' pat = 'python' r = re.search(pat,s) print(r.span()) #(7,13) 2、查找所有1
s = '山东省潍坊市青州第1中学高三1班' pat = '1' r = re.finditer(pat,s) for i in r: print(i) # &lt;re.Match object; span=(9, 10), match='1'&gt; # &lt;re.Match object; span=(14, 15), match='1'&gt; 3、\d匹配数字[0-9]
s = '一共20行代码运行时间13.59s' pat = r'\d+' # +表示匹配数字(\d表示数字的通用字符)1次或多次 r = re.findall(pat,s) print(r) # ['20', '13', '59'] 4、表示前一个字符匹配0或1次
s = '一共20行代码运行时间13.59s' pat = r'\d+\.?\d+' # ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d0661b1afd2d1998e62e9be2f4906de9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df3c7679e160e6fda7f1d46b6c36946a/" rel="bookmark">
			RK平台使用IO指令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 RK平台开发过程经常要用到IO指令，主要是用来读写CPU各个模块寄存器的值，从而实现在线调试。
RK平台的SDK默认有包含IO指令的源码，如果执行的时候找不到指令，可能是没有编译进去，找到对应的编译脚本编译进去即可。
由于IO指令是直接操作CPU寄存器，因此与SDK版本无关，无论是Android还是Linux，使用的方法都是一样的，但是不同芯片的寄存器地址不一样，因此，每个芯片的操作指令是不同的。
基本操作 查看帮助文档 console:/ # io Raw memory i/o utility - $Revision: 1.5 $ io -v -1|2|4 -r|w [-l &lt;len&gt;] [-f &lt;file&gt;] &lt;addr&gt; [&lt;value&gt;] -v Verbose, asks for confirmation -1|2|4 Sets memory access size in bytes (default byte) -l &lt;len&gt; Length in bytes of area to access (defaults to one access, or whole file length) -r|w Read from or Write to memory (default read) -f &lt;file&gt; File to write on memory read, or to read on memory write &lt;addr&gt; The memory address to access &lt;val&gt; The value to write (implies -w) Examples: io 0x1000 Reads one byte from 0x1000 io 0x1000 0x12 Writes 0x12 to location 0x1000 io -2 -l 8 0x1000 Reads 8 words from 0x1000 io -r -f dmp -l 100 200 Reads 100 bytes from addr 200 to file io -w -f img 0x10000 Writes the whole of file to memory Note access size (-1|2|4) does not apply to file based accesses.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df3c7679e160e6fda7f1d46b6c36946a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2eb02965e0e9504836e66620135c3fb5/" rel="bookmark">
			如何处理亿级图片排重（精准排重，相似排重）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图片相似度对比 1、需求 假如有一个图片池，存有1亿图片。给一张目标图片，在图片池中做匹配。
判断一张图片是否在图片池中出现过。（完全一样）判断有没有相似的出现过。比如两张图相似度90，两张图片是在描述一件事情。 2、需求实现方案 对于以上需求，实现思路是：将图片转成向量，存放在ES中，去做以图搜图。但是在ES中的实现以图搜图，是用KNN实现的。KNN总会返回topN结果，在图片池中，哪怕真的不存在与目标一致的图片，但是仍然会返回与之最相似的图片。
想要使用ES实现需求1很容易。因为完全相同的图片，返回的相关性分数为1。但是在搜索目标不存在的情况下，返回的结果，和给出的相关性分数，很可能和目标完全不相关，但是相似度还是大于85%。我们无法判断，是否召回结果和目标真的是相似的。所以针对需求2，对召回的结果，假如分数不为1，应该再判断一次，召回的最相关的图片，是否是和目标图片真的相似。
针对需求2，应该再使用其它的图片相似性算法，做一次校验。根据调研和测试，使用openCV，使用直方图对比方法，可以有不错的效果。根据测试效果，在以下案例中，我们可以设置相关性大于85%，来区分图片是否相似。（需要测试更多的案例，来验证最佳相似度阈值阈值）
3、ES向量检索中的问题反例 es召回效果反例：
1.以下图为搜索目标图片 2.召回的结果取top3 其中以上三张图是召回的结果，图片排序即ES召回相关性排序后的结果。假如前两张结果在图片池中不存在，召回第三张，是有问题的，不能拿来做排重。
3.以上三张图片在es中给出的分数如下： 从es给的相关性分数中，第一张图得分为1，可以用来判断完全一致没有问题。第二张图片和第三张图片，分数很相近，但是第三张图和第一张图实际的相关性并不好。假如我们想通过相关性排除第三张图，仅仅通过es返回的相关性分时，并不合适。
使用openCV测试对比两张图片的效果 针对需求2，使用ES不能满足。可以通过使用openCV，对召回的第一条结果，在分数不为1的情况下，重新做一次比对。
openCV 通过两张图片直方图的比对，得出的相关性分数，比较靠谱。至少看起来是我们想要的效果。
案例1 两张图，虽然不是一个人，但是它们都是在描述一件事情。按说应该是在描述一件事情。我们认为这两张图是相似的，相似度90以上。
openCV 计算的相关性分数
均方差（MSE）: 131.44561624837127
结构相似性指数（SSIM）: 5.7201094656E10
峰值信噪比（PSNR）: 26.943342540382247
图片相似度(直方图): 0.8858558728156901
案例2 两张图，来源于同一个视频，不同的帧。 直观上判断，这两个是同一个事情。相似度大于95。
均方差（MSE）: 123.0275316249348
结构相似性指数（SSIM）: 1.909637632E9
峰值信噪比（PSNR）: 27.230780502837018
图片相似度(直方图): 0.9565945992942751
案例3 虽然都是马斯克。但是这是在描述两件不同的事情。相似度应该较低。
均方差（MSE）: 209.28278961867477
结构相似性指数（SSIM）: 5.423145472E9
峰值信噪比（PSNR）: 24.923468452906206
图片相似度(直方图): 0.34953414682303025
案例4 其中以下两张图，第二张图片可以使用openCV重新做比对。在es中给出相关性是85%。openCV对比的相似性为77%，可以通过设置相似度85%阈值，排除错误结果。
均方差（MSE）: 185.4257086381148
结构相似性指数（SSIM）: 2.40297230336E11
峰值信噪比（PSNR）: 25.449104134454515
图片相似度(直方图): 0.7713211102457774
ES使用 es 8.8的KNN向量检索。
其中openCV对比两张图相似度代码 使用openCV比对任意两张图片的相似度（亲测较准确）_水的精神的博客-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14dbc9a96fd602d057ca786b1bd8f617/" rel="bookmark">
			chatgpt赋能python：Python奇偶数分离：让您的程序更高效！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python奇偶数分离：让您的程序更高效！ 在Python中，奇偶数分离是一项非常常见的任务。奇数和偶数是数学中的基本概念，在编程中也非常有用。在本文中，我们将介绍如何使用Python编写一段简单的代码，将一组数字分为奇数和偶数。
什么是奇数和偶数？ 在数学中，奇数是不能被2整除的整数，例如3、7、11等。偶数是可以被2整除的整数，例如2、4、6等。
在Python中，我们可以通过使用“%”（模运算符）来判断一个数是否是奇数或偶数。当我们将一个数除以2并取模时，如果余数为0，则该数是偶数；如果余数为1，则该数是奇数。
Python奇偶数分离代码示例 让我们看一个简单的Python示例程序，它将输入列表分为奇数和偶数两个列表：
def separate_odd_even(numbers): odd_numbers = [] even_numbers = [] for number in numbers: if number % 2 == 0: even_numbers.append(number) else: odd_numbers.append(number) return (odd_numbers, even_numbers) 在此示例中，我们使用了Python的for循环以及if和else语句来检查每个数字是否是偶数。在偶数的情况下，我们将数字添加到even_numbers列表中；在奇数的情况下，我们将数字添加到odd_numbers列表中。最后，我们返回一个元组，它包含了这两个列表。
Python奇偶数分离的性能优化 尽管以上代码对于小型输入非常简单且有效，但在处理大型输入时，它可能会变得缓慢。因此，我们可以对其进行性能优化，使其更高效。
我们可以创建两个空列表，然后遍历给定列表中的所有元素。每次我们检查一个元素时，我们都可以同时添加它到正确的列表中，而不是创建一个新的列表并在其中添加。
优化后的代码如下：
def separate_odd_even(numbers): odd_numbers = [] even_numbers = [] for number in numbers: if number % 2 == 0: even_numbers += [number] else: odd_numbers += [number] return (odd_numbers, even_numbers) 使用此更高效的算法，我们可以处理更大的输入并在更短的时间内完成计算！
结论 Python奇偶数分离是一个非常简单且有用的工具，它可以帮助您将一组数字分为奇数和偶数。通过优化算法，我们可以使这个任务更加高效。这个简单的工具可以帮助您在编程中更加优雅地使用Python。
最后的最后 本文由chatgpt生成，文章没有在chatgpt生成的基础上进行任何的修改。以上只是chatgpt能力的冰山一角。作为通用的Aigc大模型，只是展现它原本的实力。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/14dbc9a96fd602d057ca786b1bd8f617/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/130/">«</a>
	<span class="pagination__item pagination__item--current">131/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/132/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>