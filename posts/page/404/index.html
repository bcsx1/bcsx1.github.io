<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1f678369ed510041a55dfff5ce864a4/" rel="bookmark">
			python selenium 处理弹窗_python selenium-webdriver 处理JS弹出对话框
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 hello girl 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/096b8c281843d5d93ed34e2ad05ee911/" rel="bookmark">
			python怎么加载图片png图片位置_python - 使用Python读取16位PNG图像文件 - 堆栈内存溢出...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我一直在玩这个图像使用PIL版本5.3.0：
它读取数据就好了：
&gt;&gt;&gt; image = Image.open('/home/jcomeau/Downloads/grayscale_example.png')
&gt;&gt;&gt; image.mode
'I'
&gt;&gt;&gt; image.getextrema()
(5140, 62708)
&gt;&gt;&gt; image.save('/tmp/test.png')
它保存在正确的模式，但内容不相同：
jcomeau@aspire:~$ diff /tmp/test.png ~/Downloads/grayscale_example.png
Binary files /tmp/test.png and /home/jcomeau/Downloads/grayscale_example.png differ
jcomeau@aspire:~$ identify /tmp/test.png ~/Downloads/grayscale_example.png
/tmp/test.png PNG 85x63 85x63+0+0 16-bit sRGB 6.12KB 0.010u 0:00.000
/home/jcomeau/Downloads/grayscale_example.png PNG 85x63 85x63+0+0 16-bit sRGB 6.14KB 0.000u 0:00.000
但是， image.show()始终转换为8位灰度，钳位在0和255.因此，在转换的任何阶段看到你所拥有的东西都没用。 虽然我可以写一个例程，甚至monkeypatch .show() ，我只是在另一个xterm中运行display命令。
&gt;&gt;&gt; image.putdata([n - 32768 for n in image.getdata()])
&gt;&gt;&gt; image.getextrema()
(-27628, 29940)
&gt;&gt;&gt; image.save('/tmp/test2.png')
请注意，转换为模式I;16无效：
&gt;&gt;&gt; image.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/096b8c281843d5d93ed34e2ad05ee911/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94eaa1a4bf002174854d2756df63a7f1/" rel="bookmark">
			python 点_python获取栅格点和面值的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、获取指定位置的点值：
OutputFile = open(statisticResultTXT, 'w')
cellvalue=arcpy.GetCellValue_management(inputfilepath+filenname+".tif",staionXY, "1")
OutputFile.write(stationID+"_"+filenname+""+str(cellvalue)+'\n')
OutputFile.close()
2、获取区域的均值极值
utputFile = open(statisticResult, 'w')
env.workspace = ('E:\loessplateau\ET_Spline\extract_year')
rlist = arcpy.ListRasters('*','tif')
for file in rlist:
minValueInfo= arcpy.GetRasterProperties_management(file,'MINIMUM')
minValue = minValueInfo.getOutput(0)
maxValueInfo = arcpy.GetRasterProperties_management(file,'MAXIMUM')
maxValue = maxValueInfo.getOutput(0)
meanValueInfo = arcpy.GetRasterProperties_management(file,'MEAN')
meanValue = meanValueInfo.getOutput(0)
print file + ',' + str(minValue) + ',' + str(maxValue) + ',' + str(meanValue) +'\n'
OutputFile.write(file + ',' + str(minValue) + ',' + str(maxValue) + ',' + str(meanValue) +'\n')
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94eaa1a4bf002174854d2756df63a7f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90ddf0ae4f65207a56f3f7df5079adf5/" rel="bookmark">
			【阿里Java岗的魔鬼三面】狠心刷完这6份pdf，三面之后挺进阿里，定级P7
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： 今年的开端有些特殊，面试“老大难”已成常态，现在很多互联网公司都已经采取线上面试的方式，所以提前做好准备，投简历、顺利面试，定会拿下心仪的offer，而我也总算取得自己想要的成功，阿里三面成功拿下。
一面：
简单介绍一下自己。介绍一下你的项目经历。讲一下你在这个项目中用到的技术，负责哪个模块？在项目过程中有没有遇到什么困难，怎么去解决的？Spring具有什么特点（IOC和AOP）HashMap和HashSet的实现原理。动态代理的原理。java虚拟机类加载机制。java虚拟机GC算法。包装类型和基本类型的比较问题。Integer类型的变量能否==int类型变量，能否作比较，什么时候不能作比较。ArrayList和LInkedList的比较。单例模式都有什么，都是否线程安全，可以怎么改进？（从synchronized到双重检验锁到枚举 Enum）java锁机制。java线程安全都体现在哪些方面，如果维护线程安全？还有什么想问我的么？ 二面：
主要就是项目，面试官一直拿着你的简历，去看项目中有什么可问你的。
项目中遇到了什么问题，怎么解决的。
Oracle的explain执行计划调优。
发散性问题：假如有100万个玩家，需要对这100W个玩家的积分中前100名的积分，按照顺序显示在网站中，要求是实时更新的。积分可能由做的任务和获得的金钱决定。问如何对着100万个玩家前100名的积分进行实时更新？
（我说了分治和Hash，但他说我的方法都是从全局的数据进行考虑的，这样空间和时间要求太多，并且不现实。最后他给出了解决方法，就是利用缓存机制，缓存—tomcat—DB，层级计算，能不用到DB层就别用，因为每进一层，实现起来都会更复杂和更慢。解决的思路就是，考虑出了前100名的后100W-100名玩家的积分，让变化的积分跟第100名比较，如果比第100名高，那就替换的原则。）
简历上还有没有能给自己加分的项，让我自己说几个。 HR面：
简单介绍一下自己你认为你的强项在哪。做如果项目过程中，碰到不受指挥的情况，这时你会怎么做？关于薪资待遇你的期望？ 总结 以上就是面试的大概过程，不得不说，大厂的面试还是非常有技术水平的，这个过程中我学到了很多，这里分享下个人的一些心得：
1、基础！基础！基础！重要的事情说三遍，无论是什么阶段的程序员，基础都是最重要的。每个公司的面试一定会涉及到基础知识的提问，如果你的基础不扎实，往往第一面就可能被淘汰。
2、要对简历上的技术点很熟悉。简历包装可以，但一定要对简历上的技术点很熟悉，比如只是简单写过 rabbitmq 的 demo 的话，就不要写“熟悉”等字眼，因为很多的面试官会针对一个技能点问的很深入，像连环炮一样的深耕你对这个技能点的理解程度。
总的来说，这次面试还是收获颇丰的，毕竟自己面试之前也是准备的很充分了，有些题目答得不好说明我还有很多技术盲区，不懂就是不懂，再这么吹也吹不出来。好好修炼内功吧，毕竟菜可是原罪啊。
分享 以下是我个人总结的2020互联网大厂常问的面试题（含答案），全部刷完面试大厂通过率极高，当然得看工作年限及个人能力
Java面试神技（Github上收获40K+Star）
该文档在Github上收获40K+star的Java面试神技（这赞数，质量多高就不用我多说了吧）非常全面，包涵Java基础、Java集合、JavaWeb、Java异常、OOP、IO与NIO、反射、注解、多线程、JVM、MySQL、MongoDB、Spring全家桶、计算机网络、分布式架构、Redis、Linux、git、前端、算法与数据结构、MyBatis、RocketMQ、Netty、Dubbo。内容非常丰富，已经帮很多人拿下互联网一线公司的offer。
Java核心知识点整理
这份Java进阶架构师之路的核心知识，同时也是面试时面试官必问的知识点，篇章也是包括了很多知识点，其中包括了有基础知识、Java集合、JVM、多线程并发、spring原理、微服务、Netty 与RPC 、Kafka、日记、设计模式、Java算法、数据库、Zookeeper、分布式缓存、数据结构等等
1000道互联网Java工程师面试题
内容涵盖：Java、MyBatis、ZooKeeper、Dubbo、Elasticsearch、Memcached、Redis、MySQL、Spring、Spring Boot、Spring Cloud、RabbitMQ、Kafka、Linux 等技术栈
70+算法题、30种大厂笔试高频知识点
一本能“在线”编程的程序员面试宝典，超全算法笔试模拟题精解合集涵盖70+算法题目、近30种大厂笔试常考知识点，算法学习看这本书就够了
阿里巴巴Java开发手册泰山版
《Java 开发手册》是阿里巴巴集团技术团队的集体智慧结晶和经验总结，经历了多次大规模一线实战的检验及不断完善，公开到业界后，众多社区开发者踊跃参与，共同打磨完善，系统化地整理成册
Java面试突击手册
专注“Java知识总结+面试指南”
Java 核心知识总结面试方向：面试题、面试经验、备战面试系列文章以及面试真实体验系列 以上内容中所有的学习资料、面试资料，均可以免费提供，希望大家金三银四面试顺利，拿下自己心仪的offer！
如何获得这份优质的资料呢？ 快速领取通道：点这里免费获取！诚意满满！！！
Java面试精选题、架构实战文档传送门：https://jq.qq.com/?_wv=1027&amp;k=iWJZw1rp
整理不易，觉得有帮助的朋友可以帮忙点赞分享支持一下小编~
你的支持，我的动力；祝各位前程似锦，offer不断！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70d66408af5c6667aecad5dfba9722be/" rel="bookmark">
			QT创建C&#43;&#43;Thread线程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 除了使用QThread创建线程之外，还可以使用C++thread创建线程。
1.首先在qt的.h文件中包含线程头文件
#include &lt;thread&gt; 2.创建线程执行函数
void MainWindow::thread1() { while(1) { } } 3.创建线程对象，执行自定义线程函数
std::thread th1(&amp;MainWindow::thread1,this); 4.分离线程对象，使之独自运行
th1.detach(); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9ed71b1c66a6cb6d742eee464c5a5b5/" rel="bookmark">
			linux cpu使用率_OVH/Hetzner/DigitalOcean/Linode/Vultr服务器CPU和磁盘性能对比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		结果总览 测试内容
CPU的unixbench跑分和磁盘4k &amp; 1m块的iops
测试脚本 https://blog.ilemonrain.com/linux/LemonBench.html
https://teddysun.com/245.html
测试结果 1.OVH 详细：https://paste.ubuntu.com/p/6Zfvqrf6sh/
LemonBench Linux System Benchmark Utility Version 20191007 BetaVersion
测试开始时间： 2019-10-16 23:49:11
测试结束时间： 2019-10-17 00:21:28
测试模式： 全面测试
-&gt; 系统信息
系统名称: Debian GNU/Linux "Stretch" 9.9 (x86_64)
CPU型号: Intel Core Processor (Haswell, no TSX)
CPU缓存大小: 4096 KB
CPU数量: 1 vCPU
虚拟化类型: KVM
内存使用率: 127.23 MB / 1.91 GB
Swap使用率: [无Swap分区/文件]
磁盘使用率: 1.92 GB / 20.62 GB
引导设备: /dev/sda1
系统负载(1/5/15min): 0.37 0.20 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b9ed71b1c66a6cb6d742eee464c5a5b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bab3d5e907dc7f92f08ffdad567ab96/" rel="bookmark">
			python输入字符串，统计字母和数字有多少
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我还是发一点基础题讲解，我的讲法不一样在，我喜欢把讲解放在注释里面，有问题留言。
上代码：
s = input('请输入字符串：')#输入 dic = {'letter': 0, 'integer': 0}#定义一个字典，分别表示字母，空格 #遍历输入的字符 for i in s: if i &gt; 'a' and i &lt; 'z' or i &gt; 'A' and i &lt; 'Z': dic['letter'] += 1 elif i in '0123456789': dic['integer'] += 1 print('统计字符串：', s) for i in dic: print('%s=' % i, dic[i]) 我是川川，如果对你有帮助请点个赞加个关注，后续会继续分享。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e078fdfe82c9817cc5566cb2cc664843/" rel="bookmark">
			java license授权工具_&amp;quot;私人定制&amp;quot;CLI工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 前言 本文面向有JavaScript开发经验且希望入门CLI工具制作的开发人员。文中没有太多理论知识，通过从0到1开发一个简单的CLI工具，分享了CLI工具的开发、发布流程。看完本文，你可以学会如何"私人定制"一个CLI工具来提升开发效率。
总之，简单，实用，有趣。
2 什么是CLI工具 维基百科是这样定义CLI的
CLI（Command-line Interface），命令行界面，指通过输入字符组成的命令行进行操作的用户界面。 常见的CLI工具举例
系统命令：cd、mkdir、ifconfig脚手架工具：create-react-app、vue-cli、yeoman预处理器：less、sass、babel测试工具：mocha、karma、wrk构建工具：webpack、gulp、grunt 3 为什么要自己开发CLI工具 举例，如果想查看本机ip地址，通常我会使用ifconfig命令，如图 ifconfig执行结果 执行命令后系统输出了一堆信息，从这堆信息中找到ip地址大概需要花5秒时间，这不是我想要的。我希望的结果是这样的
ip执行结果 输入ip命令，直接得到本机ip地址，1秒搞定，简单快捷。
理想很丰满，现实很骨感。真实的情况是：当我在终端敲下ip命令时，系统给我的反馈是"command not found:ip"。
ip执行结果 很显然，系统并没有为我提供ip这个命令，所以我们需要自己来实现它。
4 开始开发CLI工具 4.1 第一步：确保安装了Node.js
node版本检测 4.2 第二步：编写脚本、测试运行
创建文件夹ip-cli，并新建index.js
mkdir ip-cli &amp;&amp; cd ip-cli touch index.js 编辑index.js，内容如下
const os = require("os") const ip = os.networkInterfaces().en0[1].address const options = process.argv.slice(2) if (options[0] === '-v') { console.log('v1.0.0') } else { console.log(`your ip is: ${ip}`) } 执行node index.js，结果如下
执行脚本 4.3 声明执行环境
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e078fdfe82c9817cc5566cb2cc664843/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1aa40072d2a68793db6a9a205deac55/" rel="bookmark">
			数据库事务未提交完成又新开了线程跑任务，导致数据重复操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题：使用了Redis分布式锁，但是还是出现了并发的问题
原因：数据库的事务提交结束晚于新线程的开始执行，代码里事务的提交放在了带有锁的方法的同级service
解决：① 循环查询200条数据再做更新时，查询时增加id条件，每个循环的最后一个id作为下一次循环的条件
② 将涉及到事务的方法抽到另外一个service文件，调用他，即下调一层
③ 加上
@Transactional(propagation = Propagation.REQUIRED, rollbackFor = Exception.class) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93bcef966e8659b55ff0305faae3383f/" rel="bookmark">
			4位先行进位加法器_你真的搞懂了Python中的四舍五入吗？1.45保留小数点后1位，四舍五入后得多少？...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先来看看Python内置的四舍五入函数：
round(x, n) 该函数返回传入的x数值（浮点型或整型）的四舍五入值；参数n表示对x进行四舍五入时保留/参考的数位精度；参数n可以不传入，此时其默认值为0，但若传入的话，则必须为整型；当n为0时，返回的结果为整型，n为负整数或正整数时，返回值的数值类型与传入的x数值的类型一样（整型或者浮点型）；若n为正整数，则表示四舍五入时保留/参考的小数点后的位数；若n为负整数，-1表示基于十位四舍五入（舍弃个位）、-2表示基于百位四舍五入（舍弃个位和十位），依次类推；round返回的是数值（整型或者浮点型），对于数值，我们关注的是准确性，因为数值是用于算术运算的，比如round(31415.0, 2)，得到的结果是“31415.0”，是完全符合要求的，既按约定返回了浮点型（因为传入的参数也是浮点型），同时，也完全满足小数点后2位的数位精度（或者说有效位数），因为对于数值来说，“31415.0”与“31415.00”是完全相等的；但需要注意的是：上述谈到的“数值”的有效位或者精准度，与我们平时提到的“保留多少有效位”，两者的概念是不一样的，或者说至少在编程方面，两者是不同层面的事情，前者关注的是“数值”的精准度，后者用于显示或输出，关注的是对数值的字符串格式化；因此，若数值四舍五入后，用于算术表达式计算，我们则采用round函数对数值进行四舍五入处理，要是仅用于按要求保留有效位显示输出，则直接采用字符串格式化输出即可，例如：f'{31415:.2f}'，输出为“31415.00”。 如下代码所示，各打印了两个数，前者按round调用后返回的真实数值输出，后者按字符串格式化输出。
print('对3.14159265保留小数点后3位、四舍五入的结果：',round(3.14159265, 3), f'{3.14159265:0.3f}') print('对31415.9265仅保留整数部分、四舍五入的结果：',round(31415.9265), f'{31415.9265:.0f}') print('对31415.9265基于百位进行四舍五入的结果：',round(31415.9265, -2), f'{round(31415.9265, -2):.0f}') print('对31415基于百位进行四舍五入的结果：',round(31415, -2), f'{round(31415, -2):.0f}') print('对31415参考小数点后2位、四舍五入的结果：',round(31415, 2), f'{31415:.2f}') print('对31415.0参考小数点后2位、四舍五入的结果：',round(31415.0, 2), f'{31415.0:.2f}') 输出结果如下：
对3.14159265保留小数点后3位、四舍五入的结果： 3.142 3.142 对31415.9265仅保留整数部分、四舍五入的结果： 31416 31416 对31415.9265基于百位进行四舍五入的结果： 31400.0 31400 对31415基于百位进行四舍五入的结果： 31400 31400 对31415参考小数点后2位、四舍五入的结果： 31415 31415.00 对31415.0参考小数点后2位、四舍五入的结果： 31415.0 31415.00 另外，更重要的，对于Python的这个round内置函数我们在使用时要需要注意以下两点：
四舍五入运算必然涉及到进位或者不进位，比如，我们对数值x（如1.45）进行四舍五入运算，假设进位得到A（如1.5，保留小数点后1位）、若不进位得到B（如1.4，保留小数点后1位），有时候会出现一种特别情况，x正好在A与B的中间，即离A和B的距离相同，这种情况下一般是碰到了“5”，此时，究竟取A还是取B呢？Python的处理是取“偶数”（如，1.4的最后一位4为偶数），跟我们传统的“五入”做法是不一样的。如下所示： print('为了促成偶数，放弃“五入”：',round(0.5),round(-0.5),round(2.5),round(125,-1),round(1.45,1)) print('正好促成偶数，保留“五入”：',round(1.5),round(-1.5),round(1.5),round(135,-1),round(1.35,1)) 输出结果如下：
为了促成偶数，放弃“五入”： 0 0 2 120 1.4 正好促成偶数，保留“五入”： 2 -2 2 140 1.4 而且上述规则还存在另外的挑战，当碰到了“5”且又遇上了特别的浮点数时，情况会变得更加复杂，例如，round(6.675, 2)给出的结果是6.67，而不是按上述规则应该得出的6.68，这并不是Python语言的Bug或问题，而是因为：计算机本身对浮点数进行十进制至二进制转换时，存在着一些十进制小数不能以二进制精确地表示出来（相当于除法中除不断的情况），而计算机用来存储数字的二进制位数是有限的，必然导致后面的数位被舍弃，于是，x（比如，当前的6.675）不再是我们十进制中看到的，离A（即6.68）和B（即6.67）的距离完全相等，而是变小了些，离B更近了，于是被round函数选中了6.67。 print('受计算机精度影响的四舍五入：',round(6.675,2),round(1.355,2)) 输出结果如下：
受计算机精度影响的四舍五入： 6.67 1.35 需要说明的是，上述两点特殊情况，对于数值的字符串格式化会产生同样的影响，知道了上述规则和原因后，遇到类似的特殊情况，我们就不会再感到不解或者迷惑了，甚至在特殊的严格场合，我们可能需要进行特殊处理，规避上述情况的发生。如下所示，我们来看看字符串格式化对上述特殊数值的输出情况。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/93bcef966e8659b55ff0305faae3383f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ab3437adca04424447ae42ef3650f98/" rel="bookmark">
			MySQL DATEDIFF() 函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 DATEDIFF() 函数返回两个日期之间的天数
语法：DATEDIFF(date1,date2)
eg: SELECT DATEDIFF('2008-12-30','2008-12-29') AS DiffDate 结果：1 SELECT DATEDIFF('2008-12-29','2008-12-30') AS DiffDate 结果：-1 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7ae654e7cb68bb4ac057bfa108e22d5/" rel="bookmark">
			maven中添加Servlet和jsp依赖
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 maven中添加Servlet、jsp依赖 创建项目后，把Servlet和jsp依赖添加到pom.xml中
&lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/javax.servlet/javax.servlet-api --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;4.0.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/javax.servlet.jsp/jsp-api --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a2d7208853daffcb96fb5a7382b0c7b/" rel="bookmark">
			JQuery
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JQuery 主要内容 Jquery对象 ​ jQuery 是一套兼容多浏览器的 javascript 脚本库. 核心理念是写得更少，做得更多，使用 jQuery 将极大的提高编写 javascript 代码的效率，帮助开发者节省了大量的工作，让写出来的代码更加优雅，更加健壮，“如虎添翼”。同时网络上丰富的 jQuery 插件也让我们的工作变成了"有了 jQuery，一切 so easy。" --因为我们已经站在巨人的肩膀上了。
​ jQuery 在 2006 年 1 月由美国人 John Resig 在纽约的 barcamp 发布，吸引了来自世界各地的众多 JavaScript 高手加入，由 Dave Methvin 率领团队进行开发。如今，jQuery已经成为最流行的 javascript 框架，在世界前 10000 个访问最多的网站中，有超过 55%在使用 jQuery。
Jquery的下载与安装 下载 ​ http://jquery.com/ 下载
​
版本 ​ jQuery 2.x has the same API as jQuery 1.x, but does not support Internet Explorer 6, 7,or 8. (不支持 ie6 7 8,如果需要下载 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a2d7208853daffcb96fb5a7382b0c7b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b8a089f646e1fb3b62d5eb9ff3e08e0/" rel="bookmark">
			javamailsender文本加超链接_如何使用Typora文本编辑器(详细教程)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何使用Typora文本编辑器(详细教程) 1、标题 一级标题：#+空格+标题+回车
二级标题：##+空格+标题+回车
三级标题：###+空格+标题+回车
四级标题：####+空格+标题+回车
五级标题：#####+空格+标题+回车
六级标题：######+空格+标题+回车
目前只支持到六级标题！！
2、字体 加粗： 在字体两边分别+两个*号。 Hello,World！
斜体：在字体两边分别只+一个*号。 Hello,World！
粗体+斜体： 在字体两边分别+三个星号。 Hello,World！
删除线： 在字体两边分别+两个 ~（波浪）线。 Hello,World！
3、引用 在起始位置添加一个大于符合（&gt;）+空格，表示引用
引用别人文章字句时可以使用 4、分割线 可以用三个杠（---）+空格
也可以用三个星号（*）+空格（这个分割线占全屏）
5、图片 样式（英文状态下的感叹号 加 中括号 加 小括号（ !+[ ]+()），中括号里面放图片的名字，小括号放图片的地址（图片可以是本地的图片也可以是网上的图片））。
（1）本地图片：
（2）网上图片(西部开源-秦疆老师博客中的图片)：
6、超链接 样式：（英文状态下的中括号 + 小括号（[ ]+( )）,中括号放超链接的名字，小括号放超链接的地址）
点击跳转到18sui的博客
7、列表 有序列表：样式（1+.号+空格）
ABC 无序列表：样式（- 号+ 空格）
Abc 8、表格 1.可以直接右键插入表格
2.手打样式：
|名字|性别|生日|
|--|--|--|
|张三|男|1999.1.1|（然后用鼠标点页面最底部的&lt;/&gt;启用源代码符号，把手打内容之间的空行删掉，然后回到内容页面，表格就出来了）
data-draft-node="block" data-draft-type="table" data-size="normal" data-row-style="normal"&gt;名字性别生日 9、代码 样式：三个英文状态下的 `（该点在键盘的tab键上方） 点，点后面+你要写的代码类型（java、JavaScript等）。
public 如何使用Typora文本编辑器(详细教程)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92ce07ac15e986497e75ce596f36756c/" rel="bookmark">
			数据库推荐，qPCR引物设计与评价
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们在做qPCR的时候首先需要的就是设计引物。设计引物的软件有很多的。而这次介绍的这两个
MRPrimerW2是一个用来设计引物的软件。
MFEprimer是一个可以用来评估引物质量的数据库。
数据库地址见文末
MPRrimerW2 MPRrimerW2支持九个物种的引物设计网站。我们可以通过输入基因名/fasta序列格式来设计引物的数据库。
另外这个网站可以一下子输入很多的基因，来一次性的设计很多基因的引物。
同时网站对于引物的自定义还有更近一步的设置。这个方便我们设计出自己想要的引物
文章剩余内容&lt;&lt;&lt;&lt;&lt;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05bc5917bc7123c54caf4f0cc386926c/" rel="bookmark">
			使用C&#43;&#43;实现二叉查找树（二叉搜索树）的创建、查找、插入、删除等操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		主要实现了以下接口：
1、二叉查找树的结构定义
2、二叉查找树中建立新节点
3、二叉查找树中查找
4、二叉查找树的插入
5、二叉查找树的建立
6、二叉查找树的删除
#include &lt;iostream&gt; using namespace std; // 二叉树的节点结构体 struct node {	int data;	// 数据域 node* lchild; // 指针域：左孩子 node* rchild; // 指针域：右孩子 }; // 创建新节点 node* newNode(int v) { node* Node = new node; Node-&gt;data = v; Node-&gt;lchild = Node-&gt;rchild = nullptr; return Node; } // 二叉查找树的查找操作 bool search(node* root, const int&amp; val) { if (root == nullptr) return false; if (root-&gt;data == val) return true; else if (root-&gt;data &gt; val) { search(root-&gt;lchild, val); } else { search(root-&gt;rchild, val); } } // 二叉查找树的插入操作 void insert(node* root, const int&amp; val) { if (root == nullptr) { root = newNode(val); } if (root-&gt;data == val) { return; // 已经有相同的值 } else if (root-&gt;data &gt; val) { insert(root-&gt;lchild, val); } else { insert(root-&gt;rchild, val); } } // 二叉查找树的建立 node* create(vector&lt;int&gt;&amp; data) { node* root = nullptr; for (auto&amp; iter : data) { insert(root, iter); } return root; } // 二叉查找树的删除 /* 为保证删除某一个节点之后仍然为一个二叉查找树， 一种方法是，找到删除节点的左子树中的最大值，替换掉删除的节点 另一种方法是，找到删除节点的右子树中的最小值，替换掉删除的节点 替换的方法是进行删除节点的递归操作 */ // 传入的是左孩子节点，找到左子树中的最大值， node* GetLeftMax(node* root) { while (root !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05bc5917bc7123c54caf4f0cc386926c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f0d5c5159a1c98bb4cb1cc2ea93419d/" rel="bookmark">
			二叉树的存储（输入一串字符）与遍历
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		描述
用链表的方式实现二叉树的存储和基本操作，包括CreateBinTree()、PreorderTraversal()、InorderTraversal()、PostorderTraversal()等操作。
输入
ABCDFGI00E00H000000 输入为一行字符型数据，字符之间无空格，表示二叉树的层序生成序列，’0’表示空结点。
输出
ABDFECGHI DBEFAGHCI DEFBHGICA 直接用STL的queue模板
#include&lt;iostream&gt; #include&lt;queue&gt; using namespace std; struct TNode { char Data; struct TNode* Left; struct TNode* Right; }; typedef struct TNode* BinTree; BinTree CreatBinTree(string s) { char c; BinTree BT, T; queue&lt;BinTree&gt; q; if (s[0] != '0') { BT = (BinTree)malloc(sizeof(struct TNode)); BT-&gt;Data = s[0]; BT-&gt;Left = BT-&gt;Right = NULL; q.push(BT); } else return NULL; for (int i = 1;i&lt;s.size();i++) { T = q.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f0d5c5159a1c98bb4cb1cc2ea93419d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79dc489e4422e54a3c2a333b2a04e276/" rel="bookmark">
			Linux环境常用网络命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. ifconfig ifconfig 命令用来查看和配置网络设备。Windows环境使用的是ipconfig命令。
使用ifconfig查看当前主机的网卡和IP等信息。
2. iwconfig
iwconfig和ifconfig很相似，但是iwconfig仅仅和无线网络相关。
3. ping
ping是常用的网络命令，主要通过ICMP协议进行网络探测，测试本机与网络中其它主机的网络联通情况。
选项：
-b：后面加入广播地址，用于对整个网段进行探测。
-c 次数：用于指定ping的次数。
-i interval：设定间隔几秒发送一个ping包，默认一秒ping一次；
-s 字节：用于指定探测包的大小。
使用：
(1) ping 127.0.0.1。127.0.0.1是本地的循环地址，ping通则说明TCP/IP协议工作正常，否则TCP/IP就不正常。
(2) ping 本机的IP地址 。使用ifconfig命令可查看本机的IP地址，ping IP地址，若Ping通，说明网络适配器（网卡或MODEM）工作正常，否则就不正常。
(3) ping其它主机的IP或者网址。
4. telnet
telnet命令通常用来远程登录。
Telnet协议是TCP/IP协议族中的一员，是Internet远程登陆服务的标准协议和主要方式。它为用户提供了在本地计算机上完成远程主机工作的能力。在终端使用者的电脑上使用telnet程序，用它连接到服务器。终端使用者可以在telnet程序中输入命令，这些命令会在服务器上运行，就像直接在服务器的控制台上输入一样。可以在本地就能控制服务器。要开始一个 telnet会话，必须输入用户名和密码来登录服务器。
telnet命令还可做别的用途，比如确定远程服务的状态，比如确定远程服务器的某个端口是否能访问。
但是，telnet因为采用明文传送报文，安全性不好，很多Linux服务器都不开放telnet服务，而改用更安全的ssh命令了。
5. ssh
SSH(远程连接工具)连接原理：ssh服务是一个守护进程(demon)，系统后台监听客户端的连接，ssh服务端的进程名为sshd，负责实时监听客户端的请求(IP 22端口)，包括公共秘钥等交换等信息。
ssh服务端由2部分组成： openssh(提供ssh服务) ，openssl(提供加密的程序)。
ssh的客户端可以用 xshell、Securecrt、Mobaxterm等工具进行连接。
用法：
(1) 假定要以用户名user，登录远程主机host：
$ ssh [-p port] user@host，如：ssh pika@192.168.0.111。
6. finger
finger命令用来查询一台主机上的登录账号的信息（包括本地和远端主机的用户），通常会显示用户名、主目录、停滞时间、登录时间、登录Shell等信息。
主要参数：
-s：显示用户注册名、实际姓名、终端名称、写状态、停滞时间、登录时间等信息。
-l：除了用-s选项显示的信息外，还显示用户主目录、登录Shell、邮件状态等信息，以及用户主目录下的.plan、.project和.forward文件的内容。
-p：除了不显示.plan文件和.project文件以外，与-l选项相同。
7. netstat
netstat 命令用于显示各种网络相关信息，如网络连接，路由表，接口状态 (Interface Statistics)，masquerade 连接，多播成员 (Multicast Memberships) 等等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/79dc489e4422e54a3c2a333b2a04e276/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/864faea1de0083b8fe32ced6df94aa71/" rel="bookmark">
			7-6 银行排队问题之单队列多窗口加VIP服务 (30分)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include &lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;bits/stdc++.h&gt; using namespace std; struct List { int start_time;//头指针计总分等待时间 int end_time;//头指针计最长等待时间 int wait_time;//代表服务了多少人 int VIP;//队列头表示是否为VIP序列 struct List *next; }; void Insert_List(List *head, List *tail, List *L)//插入到某一个窗口之后 + 头节点变化( { List *p = tail-&gt;next; tail-&gt;next-&gt;next = L; tail-&gt;next = L; if(L-&gt;start_time &gt; p-&gt;end_time) { L-&gt;end_time = L-&gt;start_time + L-&gt;wait_time; L-&gt;wait_time = 0; } else { L-&gt;end_time = p-&gt;end_time + L-&gt;wait_time; L-&gt;wait_time = p-&gt;end_time - L-&gt;start_time; } head-&gt;start_time += L-&gt;wait_time; if(head-&gt;end_time &lt; L-&gt;wait_time) head-&gt;end_time = L-&gt;wait_time; head-&gt;wait_time++; } bool Judge_have_VIP(List *number,int people_number, int head, int end_time)//当VIP通道的位置为空时，判断后面是否有VIP人员 { for(int i = head; i &lt; people_number; i++) { if(number[i].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/864faea1de0083b8fe32ced6df94aa71/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/910c4f1f9eb6239aaff4886826a1f7c5/" rel="bookmark">
			【UGUI】获取Unity中Canvas下的任意UI控件的屏幕坐标（可适用于不同的Canvas Render Mode)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Unity屏幕坐标的规则是左下角为原点，然后X向右递增，Y向上递增，区间都是[0,1]。有些时候在做UI上的一些效果的时候，需要知道UI控件所处的屏幕坐标位置，就需要有些做些处理，而不像世界坐标那么容易获得。
还有个问题是Canvas有三种RenderMode，内部的计算规则又不一样。。。
所以在这里记录一下具体的获取UI屏幕坐标的方式。
ScreenSpace-Overlay 可直接获取到position的XY坐标并通过除以屏幕的宽高，映射到屏幕坐标的[0,1]区间：
float x = ui.transform.position.x / Screen.width; float y = ui.transform.position.y / Screen.height; ScreenSpace - Camera 和 World Space 需要通过Canvas上使用的UI相机来配合实现
Camera uiCam = GetComponentInParent&lt;Canvas&gt;().worldCamera; Vector2 screenPos = RectTransformUtility.WorldToScreenPoint(uiCam, ui.transform.position); float x = screenPos.x / Screen.width; float y = screenPos.y / Screen.height; 最终整合成一个通用的获取UI控件屏幕坐标的方法
//获取UI的屏幕坐标【0,1】 Vector2 GetUIScreenPosition(Graphic ui) { //获取到UI所处的canvas Canvas canvas = ui.GetComponentInParent&lt;Canvas&gt;(); //Overlay模式 或者 ScreenSpaceCamera模式没有关联UI相机的情况 if (canvas.renderMode == RenderMode.ScreenSpaceOverlay || canvas.renderMode == RenderMode.ScreenSpaceCamera &amp;&amp; canvas.worldCamera == null) { float x = ui.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/910c4f1f9eb6239aaff4886826a1f7c5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbc2d1d327869c8089a805b5165673cb/" rel="bookmark">
			python做一些好用的小工具_用Python写过哪些的小工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		展开全部
为了逃避学校布置的美术作业，写过一个画e69da5e6ba9062616964757a686964616f31333363383365素描的程序。
从后再也不担心美术作业了。
也就是利用Python的PIL库来 将彩色图片转化为素描效果的图片
更新说明：
前面那个程序写的太粗糙了，不好意思拿出来分享，重新写了一遍，加上了GUI图形界面。
配置环境：
windows 10
python 3.5
image.py
from PIL import Image
import numpy as np
import os
import join
import time
def image(sta,end,depths=10):
a = np.asarray(Image.open(sta).convert('L')).astype('float')
depth = depths # (0-100)
grad = np.gradient(a) # 取图像灰度的梯度值
grad_x, grad_y = grad # 分别取横纵图像梯度值
grad_x = grad_x * depth / 100.
grad_y = grad_y * depth / 100.
A = np.sqrt(grad_x ** 2 + grad_y ** 2 + 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bbc2d1d327869c8089a805b5165673cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/341636bfe1e2497762e03b2a3096b795/" rel="bookmark">
			sql server 配置管理器里为什么是32位_CTF必备技能丨Linux Pwn入门教程——环境配置...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说在前面
这是一套Linux Pwn入门教程系列，作者依据Atum师傅在i春秋上的Pwn入门课程中的技术分类，并结合近几年赛事中出现的一些题目和文章整理出一份相对完整的Linux Pwn教程。
问：为什么要花费精力去整理这套系统的Linux Pwn教程？
答：网上关于Pwn的资料比较零散；经常会碰到解题过程略的Writeup和没有注释；存在大量硬编码偏移的脚本；练习题目难找；调试环境难搭建；GDB没有IDA好操作等等问题。
问：这个Linux Pwn教程适合新手学习吗？
答：本套课程非常适合萌新们进行入门学习，内容通俗易懂，化繁为简，同时结合历年赛题，实操性强，对于快速提升技能可起到很大的帮助。
问：关于Linux Pwn教程是否有视频讲解？
答：在i春秋官网的课程库中有很多关于Pwn的视频课程，立即去学习！https://www.ichunqiu.com/courses/pwn?from=weixin 本系列教程仅针对i386/amd64下的Linux Pwn常见的Pwn手法，如栈，堆，整数溢出，格式化字符串，条件竞争等进行介绍，所有环境都会封装在Docker镜像当中，并提供调试用的教学程序，来自历年赛事的原题和带有注释的python脚本。
教程中的题目和脚本若有使用不妥之处，欢迎各位大佬批评指正。
今天是Linux Pwn入门教程第一章：环境配置，阅读用时约7分钟。
一、Docker容器的使用与简单操作
在搭建环境之前我们需要准备一个装有Docker的64位Linux系统，内核版本高于3.10(可以通过uname -r查看)，可以运行在实体机或者是虚拟机中。关于Docker的安装与启动此处不再赘述，读者可以根据自己的Linux发行版本自行搜索。
在成功安装了Docker并验证其可用性后，我们就可以定制自己的实验用容器了。这部分内容可以在各个地方找到教程，且与Pwn的学习不相关，此处不再赘述。为了方便实验，我把实验环境打包成了几个容器快照，可以直接导入成镜像使用。
以ubuntu.17.04.amd64为例，导入的命令为：
cat ubuntu.17.04.amd64 | docker import - ubuntu/17.04.amd64
导入成功后使用命令docker images会看到镜像仓库中出现了一个新的镜像。
运行docker run -it -p 23946:23946 ubuntu/17.04.amd64 /bin/bash
就可以以这个镜像创建一个容器，开启一个shell，并且将IDA调试服务器监听的23946端口转发到本地的23946端口。
通过命令docker container ls -a 我们发现容器列表里多了一个刚刚创建的容器，并且被赋予了一个随机的名字，在我的实验中它是nostalgic_raman。
我们可以通过命令docker container rename nostalgic_raman ubuntu.17.04.amd64把这个容器重命名为ubuntu.17.04.amd64或者其他你认为合适的名字。
使用docker exec -it ubuntu.17.04.amd64 /bin/bash 我们可以打开目标容器的一个新的bash shell。这使得我们在后续的调试中可以在容器中启动IDA调试服务器并用socat部署Pwn题目。
此外，可以使用docker container cp命令在docker容器内外双向传输文件等等。需要注意的是，对容器的各种操作需要在容器运行时进行，若容器尚未运行(运行docker container ls未显示对应容器)，需使用命令docker start运行对应容器。此外，若同时运行多个容器，为了避免端口冲突，在启动容器时，可以将命令docker run -it -p 23946:23946 ubuntu/17.04.amd64 /bin/bash 中的第一个端口号23946改为其他数字。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/341636bfe1e2497762e03b2a3096b795/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c2fc5ed39347dc21b2ae6bf2b1e494c/" rel="bookmark">
			双目三维重建_使用结构光进行三维重建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Date：2020-8-2 来源：公众号【3D视觉工坊】 欢迎加入国内最大的3D视觉交流社区，1700+的领域从业者正在一起学习~ HyperDepth - Learning Depth from Structured Light Without Matching
知乎视频​www.zhihu.com 往期干货资源：
汇总 | 国内最全的3D视觉学习资源，涉及计算机视觉、SLAM、三维重建、点云处理、姿态估计、深度估计、3D检测、自动驾驶、深度学习（3D+2D）、图像处理、立体视觉、结构光等方向！
汇总 | 3D目标检测（基于点云、双目、单目）
汇总 | 6D姿态估计算法（基于点云、单目、投票方式）
汇总 | 三维重建算法实战（单目重建、立体视觉、多视图几何）
汇总 | 3D点云后处理算法（匹配、检索、滤波、识别）
汇总 | SLAM算法（视觉里程计、后端优化、回环检测）
汇总 | 深度学习&amp;自动驾驶前沿算法研究（检测、分割、多传感器融合）
汇总 | 相机标定算法
汇总 | 事件相机原理
汇总 | 结构光经典算法
汇总 | 缺陷检测常用算法与实战技巧
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/007362a277044676850b23a7d642ef6e/" rel="bookmark">
			globalmapper如何选取图像上的点_python 图像处理：一福变五福
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		快过年了，各种互联网产品都出来撒红包。某宝一年一度的集五福（shua hou）活动更是成为每年的必备活动。虽然到最后每人大概也就分个两块钱，但作为一个全民话题，大多数人还是愿意凑凑热闹。毕竟对于如今生活在大城市的人来说，集福领红包和空荡的地铁车厢或许已是最大的“年味”了。
既然是凑热闹，怎么能少得了我。前年过年发过一篇：《一行代码扫出“敬业福”》，介绍的是 OCR 文字识别的使用。今年再来对“福”字做文章，演示下如何用 python 的图像处理功能，把一幅“福”字图片转出 5 种不同的效果：
python 最图像处理最常用的两个模块是 PIL 和 OpenCV，这里我们选择 OpenCV。
读取图片及展示代码：
import cv2 from matplotlib import pyplot as plt img = cv2.imread('fu.png') # 转换颜色模式，显示原图 img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB) plt.imshow(img) plt.show() 因为 OpenCV 和 matplotlib 的颜色模式不一样，所以需要做一次转换，如果是直接通过 cv2 展示和保存图片则不需要。
上面的效果分别用到了以下功能：
1、灰度福
这里没有选择直接将图片转出灰度图，因为这样会导致福字不明显。而是通过将红、绿、蓝三通道分离后，选择色差最大的红色通道。
r,g,b = cv2.split(img) 2、轮廓福
使用了 OpenCV 自带的图像轮廓提取功能。为了更好的效果，这里对红色通道进行二值化后，再查找轮廓。
_, img_bin = cv2.threshold(r, 50, 255, cv2.THRESH_BINARY) _, contours, _ = cv2.findContours(img_bin, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE) img_cont = np.zeros(img_bin.shape, np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/007362a277044676850b23a7d642ef6e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67a78e3c0f3e64225df8222ed319313a/" rel="bookmark">
			C语言 个位数统计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目：给定一个 k 位整数 N，请编写程序统计每种不同的个位数字出现的次数。例如：给定 N=100311，则有 2 个 0，3 个 1，和 1 个 3。
输入格式：
每个输入包含 1 个测试用例，即一个不超过 1000 位的正整数 N。
输出格式：
对 N 中每一种不同的个位数字，以 D:M 的格式在一行中输出该位数字 D 及其在 N 中出现的次数 M。要求按 D 的升序输出。
输入样例：
100311 输出样例：
0:2 1:3 3:1 思路：根据题目要求考虑使用 getchar()；
代码：
#include &lt;stdio.h&gt; int main() { char ch; int a[10] = {0}; //初始化数组 int x; while((ch=getchar())!='\n') { x=ch-'0'; ++a[x]; } for (int i = 0; i &lt; 10; ++i) { if (a[i]&gt;0) printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/67a78e3c0f3e64225df8222ed319313a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/332f0617dcc3ad444c8565d5d2805a6b/" rel="bookmark">
			OpenCV学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 OpenCV基本操作读取图像显示图像保存图像waitKey()创建窗口销毁窗口 图像处理基础item()itemset()通道拆分通道合并获取图像属性 图像运算加法运算图像加权和按位逻辑运算位平面分解图像加密与解密数字水印 色彩空间类型转换cv2.cvtColor()cv2.inRange(img, min, max)HSV色彩空间BGRA色彩空间 几何变换缩放翻转仿射透视重映射 阈值处理threshold()adaptiveThreshold()Otsu处理 图像平滑处理均值滤波方框滤波高斯滤波中值滤波双边滤波2D卷积 形态学操作腐蚀膨胀通用形态学函数开运算闭运算形态学梯度运算顶帽运算黑帽运算核函数 图像梯度Sobel算子Scharr算子Laplacian算子 图像金字塔向下采样向上采样 图像轮廓Canny边缘检测查找并绘制轮廓矩特征Hu矩轮廓拟合凸包利用形状场景算法比较轮廓轮廓的特征值 直方图处理绘制直方图直方图均衡化 傅里叶变换用Numpy实现傅里叶变换用OpenCV实现傅里叶变换 模板匹配模板匹配基础多模板匹配 霍夫变换霍夫变换原理霍夫直线变换概率霍夫变换霍夫圆变换 图像分割与提取距离变换函数标注图像分水岭算法实现图像分割与提取交互式前景提取 视频处理VideoCapture类VideoWriter类 绘画及交互绘画基础滚动条 OpenCV 本文基于《OpenCV轻松入门：面向Python》，作者李立宗。
在RGB图像中，图像是由R、G、B三个通道构成的，但是在OpenCV中，通道是按照B、G、R的顺序存储的。
基本操作 读取图像 img = cv2.imread('lena.png') 显示图像 cv2.imshow('show', img) 保存图像 cv2.imwrite('new_lena.png', img) waitKey() 若没有按键被按下，则返回-1；如果有按键被按下，则返回该按键的ASCII码。
创建窗口 cv2.namedWindow('window') 销毁窗口 销毁指定窗口
cv2.destroyWindow('window') # 销毁指定窗口 cv2.destroyAllWindows() # 销毁所有窗口 图像处理基础 item() 用于访问图像的像素点。
对于灰度图
img.item(row, col) 对于RGB图像
img.item(row, col, channel) itemset() 用于修改图像的像素值。
对于灰度图
img.itemset((row, col), value) 对于RGB图像
img.itemset((row, col, channel), value) 通道拆分 b, g, r = cv2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/332f0617dcc3ad444c8565d5d2805a6b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ebf9087d3f23566680f8fd2c69bda33/" rel="bookmark">
			python类型强制转换_python怎么强制转换类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python内提供了几种称为强制类型转换的函数，可以将一个变量的类型强制转换为另一种类型。比如，整型-&gt;浮点型，列表-&gt;元组。
我们在之前已经学习了很多种数据类型
· 整型 int
· 浮点型 float
· 字符串型 str
· 列表list
· 元组tuple
· 字典dict
· 集合set
在一定条件下，其中的几种类型是可以相互转换的，是有一定规律的。比如整型与浮点型之间的转换，列表与元组之间的转换。&gt;&gt;&gt; a = 1 #定义整型a
&gt;&gt;&gt; b = float(a) #将a强制转换成浮点型赋给b
&gt;&gt;&gt; print(b) #打印b的值
1.0
&gt;&gt;&gt; print(type(b)) #打印b的类型
上面这个例子就是将整型强制转换为浮点型的例子。&gt;&gt;&gt; a = [1, 2, 3] #定义列表a
&gt;&gt;&gt; b = tuple(a) #将a强制转换为元组，赋给b
&gt;&gt;&gt; print(b) #打印b
(1, 2, 3)
&gt;&gt;&gt; c = set(a) #将a强制转换为集合，赋给c
&gt;&gt;&gt; d = set(b) #将b强制转换为集合，赋给d
&gt;&gt;&gt; print(c,d)
{1, 2, 3} {1, 2, 3}
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ebf9087d3f23566680f8fd2c69bda33/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ec10123a53f3e4007c6c2f1ec236df0/" rel="bookmark">
			vm options什么意思_什么是锂电池保护板，保护板的基础知识和不良分析！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击上面 “电动知家”可以订阅哦！ 锂电池保护板是对串联锂电池组的充放电保护；在充满电时能保证各单体电池之间的电压差异小于设定值(一般±20mV)，实现电池组各单体电池的均充，有效地改善了串联充电方式下的充电效果；同时检测电池组中各个单体电池的过压、欠压、过流、短路、过温状态，保护并延长电池使用寿命；欠压保护使每一单节电池在放电使用时避免电池因过放电而损坏。
成品锂电池组成主要有两大部分，锂电池芯和保护板，锂电池芯主要由正极板、隔膜、负极板、电解液组成；正极板、隔膜、负极板缠绕或层叠，包装，灌注电解液，封装后即制成电芯，锂电池保护板的作用很多人都不知道，锂电池保护板，顾名思义就是保护锂电池用的，锂电池保护板的作用是保护电池不过放、不过充、不过流，还有就是输出短路保护。
01 锂电池保护板组成 1、控制ic，2、开关管，另外还加一些微容和微阻而组成。控制ic 作用是对电池的保护，如达到保护条件就控制mos进行断开或闭合(如电池达到过充、过放、短路、过流、等保护条件)，其中mos管的作用就是开关作用，由控制ic开控制。
锂电池(可充型)之所以需要保护，是由它本身特性决定的。由于锂电池本身的材料决定了它不能被过充、过放、过流、短路及超高温充放电，因此锂电池锂电组件总会跟着一块精致的保护板和一片电流保险器出现。锂电池的保护功能通常由保护电路板和PTC协同完成，保护板是由电子电路组成，在-40℃至+85℃的环境下时刻准确的监视电芯的电压和充放回路的电流。
02 保护板的工作原理 1、过充保护及过充保护恢复
当电池被充电使电压超过设定值VC(4.25-4.35V，具体过充保护电压取决于IC)后，VD1翻转使Cout变为低电平，T1截止，充电停止.当电池电压回落至VCR(3.8-4.1V，具体过充保护恢复电压取决于IC)时，Cout变为高电平，T1导通充电继续， VCR必须小于VC一个定值，以防止频繁跳变。
2、过放保护及过放保护恢复
当电池电压因放电而降低至设定值VD(2.3-2.5V，具体过充保护电压取决于IC)时， VD2翻转，以短时间延时后，使Dout变为低电平，T2截止，放电停止，当电池被置于充电时，内部或门被翻转而使T2再次导通为下次放电作好准备。
3、过流、短路保护
当电路充放回路电流超过设定值或被短路时，短路检测电路动作，使MOS管关断，电流截止。
03 保护板主要零件的功能介绍 R1：基准供电电阻；与IC内部电阻构成分压电路，控制内部过充、过放电压比较器的电平翻转；一般在阻值为330Ω、470Ω比较多；当封装形式(即用标准元件的长和宽来表示元件大小，如0402封装标识此元件的长和宽分别为1.0mm和0.5mm)较大时，会用数字标识其阻值，如贴片电阻上数字标识473， 即表示其阻值为47000Ω即47KΩ(第三位数表示在前两位后面加0的位数)。
R2：过流、短路检测电阻；通过检测VM端电压控制保护板的电流 ，焊接不良、损坏会造成电池过流 、短路无保护，一般阻值为1KΩ、2KΩ较多。
R3：ID识别电阻或NTC电阻(前面有介绍)或两者都有。
总结：电阻在保护板中为黑色贴片，用万用表可测其阻值，当封装较大时其阻值会用数字表示，表示方法如上所述，当然电阻阻值一般都有偏差，每个电阻都有精度规格，如10KΩ电阻规格为+/－5％精度则其阻值为9.5KΩ －10.5KΩ范围内都为合格。
C1、C2：由于电容两端电压不能突变，起瞬间稳压和滤波作用。总结：电容在保护板中为黄色贴片，封装形式0402较多，也有少数0603封装(1.6mm长,0.8mm宽)；用万用表检测其阻值一般为无穷大或MΩ级别；电容漏电会产生自耗电大，短路无自恢复现象。FUSE：普通FUSE或PTC(Positive Temperature Coefficient的缩写，意思是正温度系数)；防止不安全大电流和高温放电的发生，其中PTC有自恢复功能。
总结：FUSE在保护板中一般为白色贴片，LITTE公司提供FUSE会在FUSE上标识字符D-T，字符表示意思为FUSE能承受的额定电流，如表示D额定电流为0.25A，S为4A，T为5A等。
U1：控制IC；保护板所有功能都是IC通过监视连接在VDD-VSS间的电压差及VM-VSS间的电压差而控制C-MOS执行开关动作来实现的。
Cout：过充控制端；通过MOS管T2栅极电压控制MOS管的开关。
Dout：过放、过流、短路控制端；通过MOS管T1栅极电压控制MOS管的开关。
VM：过流、短路保护电压检测端；通过检测VM端的电压实现电路的过流、短路保护
(U(VM)=I*R(MOSFET))。
总结：IC在保护板中一般为6个管脚的封装形式，其区别管脚的方法为：在封装体上标识黑点的附近为第1管脚，然后逆时针旋转分别为第2、3、4、5、6管脚；如封装体上无黑点标识，则正看封装体上字符左下为第1管脚，其余管脚逆时针类推)C-MOS：场效应开关管；保护功能的实现者 ；连焊、虚焊、假焊、击穿时会造成电池无保护、无显示、输出电压低等不良现象。
总结：CMOS在保护板中一般为8个管脚的封装形式，它时由两个MOS管构成，相当于两个开关，分别控制过充保护和过放、过流、短路保护；其管脚区分方法和IC一样。
在保护板正常情况下，Vdd为高电平，Vss、VM为低电平，Dout、Cout为高电平；当Vdd、Vss、VM任何一项参数变换时，Dout或Cout的电平将发生变化，此时MOSFET执行相应的动作(开、关电路)，从而实现电路的保护和恢复功能。
04 保护板常见不良分析 一、 无显示、输出电压低、带不起负载：
此类不良首先排除电芯不良(电芯本来无电压或电压低)，如果电芯不良则应测试保护板的自耗电，看是否是保护板自耗电过大导致电芯电压低。如果电芯电压正常，则是由于保护板整个回路不通(元器件虚焊、假焊、FUSE不良、PCB板内部电路不通、过孔不通、MOS、IC损坏等)。具体分析步骤如下：
(一)、用万用表黑表笔接电芯负极，红表笔依次接FUSE、R1电阻两端，IC的Vdd、Dout、Cout端，P+端(假设电芯电压为3.8V)，逐段进行分析，此几个测试点都应为3.8V。若不是，则此段电路有问题。
1. FUSE两端电压有变化：测试FUSE是否导通，若导通则是PCB板内部电路不通；若不导通则FUSE有问题(来料不良、过流损坏(MOS或IC控制失效)、材质有问题(在MOS或IC动作之前FUSE被烧坏)，然后用导线短接FUSE，继续往后分析。
2. R1电阻两端电压有变化：测试R1电阻值，若电阻值异常，则可能是虚焊，电阻本身断裂。若电阻值无异常，则可能是IC内部电阻出现问题。
3. IC测试端电压有变化：Vdd端与R1电阻相连。Dout、Cout端异常,则是由于IC虚焊或损坏。
4. 若前面电压都无变化，测试B-到P+间的电压异常，则是由于保护板正极过孔不通。
(二)、万用表红表笔接电芯正极，激活MOS管后，黑表笔依次接MOS管2、3脚，6、7脚，P-端。
1.MOS管2、3脚，6、7脚电压有变化,则表示MOS管异常。
2.若MOS管电压无变化，P-端电压异常，则是由于保护板负极过孔不通。
二、 短路无保护：
1. VM端电阻出现问题：可用万用表一表笔接IC2脚，一表笔接与VM端电阻相连的MOS管管脚，确认其电阻值大小。看电阻与IC、MOS管脚有无虚焊。
2. IC、MOS异常：由于过放保护与过流、短路保护共用一个MOS管，若短路异常是由于MOS出现问题，则此板应无过放保护功能。
3. 以上为正常状况下的不良，也可能出现IC与MOS配置不良引起的短路异常。如前期出现的BK-901，其型号为‘312D’的IC内延迟时间过长，导致在IC作出相应动作控制之前MOS或其它元器件已被损坏。注：其中确定IC或MOS是否发生异常最简易、直接的方法就是对有怀疑的元器件进行更换。
三、 短路保护无自恢复：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ec10123a53f3e4007c6c2f1ec236df0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f8f7088974daefe72183f3150eb4405/" rel="bookmark">
			C语言 装睡
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目：你永远叫不醒一个装睡的人 —— 但是通过分析一个人的呼吸频率和脉搏，你可以发现谁在装睡！医生告诉我们，正常人睡眠时的呼吸频率是每分钟15-20次，脉搏是每分钟50-70次。下面给定一系列人的呼吸频率与脉搏，请你找出他们中间有可能在装睡的人，即至少一项指标不在正常范围内的人。
输入格式：
输入在第一行给出一个正整数N（≤10）。随后N行，每行给出一个人的名字（仅由英文字母组成的、长度不超过3个字符的串）、其呼吸频率和脉搏（均为不超过100的正整数）。
输出格式：
按照输入顺序检查每个人，如果其至少一项指标不在正常范围内，则输出其名字，每个名字占一行。
输入样例：
4 Amy 15 70 Tom 14 60 Joe 18 50 Zoe 21 71 输出样例：
Tom Zoe 思路：
考虑用二维数组来存储数据，再进行判断输出。
代码：
#include&lt;stdio.h&gt; int main() { int n,i; char a[10][10]; char b[10][10]; scanf("%d",&amp;n); for(i=0;i&lt;n;i++) { scanf("%s %d %d",&amp;a[i],&amp;b[i][1],&amp;b[i][2]); } for(i=0;i&lt;n;i++) { if(b[i][1]&lt;15||b[i][1]&gt;20||b[i][2]&lt;50||b[i][2]&gt;70) printf("%s\n",a[i]); } return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c32adb5624310bd5dbcb6cb6b77f03f/" rel="bookmark">
			事务隔离级别有哪些?MySQL的默认隔离级别是?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		事务隔离级别有哪些?MySQL的默认隔离级别是? SQL 标准定义了四个隔离级别：
READ-UNCOMMITTED(读取未提交)： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。
READ-COMMITTED(读取已提交)： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。
REPEATABLE-READ(可重复读)： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。
SERIALIZABLE(可串行化)： 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。
MySQL InnoDB 存储引擎的
默认支持的隔离级别是 REPEATABLE-READ（可重读）。
我们可以通过SELECT @@tx_isolation; 命令来查看
这里需要注意的是：与 SQL 标准不同的地方在于 InnoDB 存储引擎在 REPEATABLE-READ（可重读）
事务隔离级别下使用的是Next-Key Lock 锁算法，
因此可以避免幻读的产生，这与其他数据库系统(如SQL Server) 是不同的。
所以说InnoDB 存储引擎的默认支持的隔离级别
是 REPEATABLE-READ（可重读）
已经可以完全保证事务的隔离性要求，
即达到了 SQL标准的 SERIALIZABLE(可串行化) 隔离级别。
因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是 READCOMMITTED(读取提交内容) ，
但是你要知道的是InnoDB 存储引擎默认使用 REPEAaTABLEREAD（可重读） 并不会有任何性能损失。
InnoDB 存储引擎在 分布式事务 的情况下一般会用到 SERIALIZABLE(可串行化) 隔离级别。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8ded91bca47f9ad6096d9946f2f347e/" rel="bookmark">
			vue脚手架依赖包安装不成功_npm安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		npm安装教程 原文链接
一、使用之前，我们先来掌握3个东西是用来干什么的。 npm: Nodejs下的包管理器。webpack: 它主要的用途是通过CommonJS的语法把所有浏览器端需要发布的静态资源做相应的准备，比如资源的合并和打包。vue-cli: 用户生成Vue工程模板。（帮你快速开始一个vue的项目，也就是给你一套vue的结构，包含基础的依赖库，只需要 npm install就可以安装） 开始： 如图，下载8.9.3 LTS （推荐给绝大部分用户使用） 双击安装 可以使用默认路径，本例子中自行修改为d:nodejs 一路点Next 点Finish完成 打开CMD，检查是否正常 再看看另外2个目录，npm的本地仓库跑在系统盘c盘的用户目录了(没见到npm-cache是因为没有用过，一使用缓存目录就生成了)，我们试图把这2个目录移动回到D:nodejs 先如下图建立2个目录 然后运行以下2条命令 npm config set prefix "D:nodejsnode_global" npm config set cache "D:nodejsnode_cache" 如上图，我们再来关注一下npm的本地仓库，输入命令npm list -global 输入命令npm config set registry=http://registry.npm.taobao.org 配置镜像站 输入命令npm config list 显示所有配置信息，我们关注一个配置文件 C:UsersAdministrator.npmrc 使用文本编辑器编辑它，可以看到刚才的配置信息 检查一下镜像站行不行命令1 npm config get registry 检查一下镜像站行不行命令2 Npm info vue 看看能否获得vue的信息 注意，此时，默认的模块D:nodejsnode_modules 目录 将会改变为D:nodejsnode_globalnode_modules 目录， 如果直接运行npm install等命令会报错的。 我们需要做1件事情： 1、增加环境变量NODE_PATH 内容是：D:nodejsnode_globalnode_modules （注意，一下操作需要重新打开CMD让上面的环境变量生效） 一、测试NPM安装vue.js 命令：npm install vue -g 这里的-g是指安装到global全局目录去 二、测试NPM安装vue-router 命令：npm install vue-router -g
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a8ded91bca47f9ad6096d9946f2f347e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f98d7f2a3ff7d2ab0677ef688aebf851/" rel="bookmark">
			存在out参数的webservices_PLL环路参数的计算及建模
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		尽管基本PLL自其出现之日起几乎保持原样，但是使用不同技术制作及满足不同应用要求的PLL的实现一直给设计者提出挑战。本篇先介绍一下传统电荷泵锁相环的稳定性和噪声建模，后续再从各种结构的PLL、电路设计注意事项、片上电感的设计等方面逐一展开。
1. PLL环路参数的计算及建模
1.1 环路参数的计算
传统电荷泵锁相环的结构框图如图1所示，由鉴频鉴相器(PFD)、电荷泵(CP)、环路滤波器(LPF)、压控振荡器(VCO)、分频器(1/N)组成。 Fig1. 传统电荷泵 PLL结构框图
PLL设计指标：VDD=1.2V,Fref=25MHz,Fvco=1.25GHz,N=50。
第一步，确定VCO增益Kvco和CP充放电电流Icp。
按照20%的设计余量，将VCO的输出频率范围设定为1.0GHz到1.5GHz。在1.2V电源电压下为使CP电流源工作在饱和区，并考虑到为确保VCO增益的线性度而尽可能的压缩控制电压范围，将控制电压范围设为280mV到450mV，得Kvco≈3GHz/V。实际设计时可适当增大控制电压范围(如200~1000mV)，也可适当增大或减小Kvco，这里只是做一个假设，目的是学会如何计算PLL环路参数。
考虑面积功耗等因素的影响Icp折中取100uA。
第二步，环路带宽fc和相位裕度PM。
Fc取1MHz，PM取55deg。
第三步，计算LPF电阻(R2)和电容(C1、C2)的取值。
将图1所示的PLL结构框图等效成图2所示的负反馈系统：
Fig2. PLL等效负反馈系统
根据上述等式的推导，编写如下的MATLAB代码，可得滤波器的参数：
clear all;
close all;
clc;
Fc=1e6;%环路带宽
Kvco=2*pi*3e9;%VCO增益
Icp=100e-6;%电荷泵电流
Kpc=Icp/(2*pi);
N=50;%分频比
PM=55;%相位裕度
%==========================================================
Wc=2*pi*Fc;
fai=(pi/180)*PM;
tao1=(1/cos(fai)-tan(fai))/Wc;%时间常数1
tao2=1/(Wc*Wc*tao1);%时间常数2
radnum=(Wc*tao2)^2+1;
radden=(Wc*tao1)^2+1;
a=sqrt(radnum/radden);
b=(Kpc*Kvco)/(N*Wc*Wc);
C1=(tao1/tao2)*b*a;
C2=C1*(tao2/tao1-1);
R2=tao2/C2;
%=====================滤波器的传递函数======================
num1=[tao2,1];
den1=[tao1,1,0];
Fs=tf(num1,den1)/(C1+C2);
%=================整体开环L0s=Gs*Hs传递函数=================
G=Kpc*Fs*Kvco;
den2=[1,0];
Gs=G*tf(1,den2);
Hs=1/N;
L0s=Gs*Hs;
%===================开环传递函数波特图======================
figure(1)
bode(L0s,{2*pi*10000,2*pi*100000000})
PLL幅频和相频特性曲线如图3所示，发现环路相位裕度和带宽与计算结果一致。
Fig3. PLL幅频和相频特性曲线
1.2 滤波器参数与环路带宽的关系
PM=60o,Icp=100uA,Kvco=3GHz/V,N=50
带宽/kHz
C1/pF
C2/pF
R2/kΩ
600
113.12
1462.40
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f98d7f2a3ff7d2ab0677ef688aebf851/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/428e08a90fe3fd13fab68592c88939d3/" rel="bookmark">
			SpringCloud Alibaba Nacos持久化到Mysql8.x的问题解决笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天在学习Nacos持久化时，发现一直报错，原因是Nacos源码里mysql-connector-java依赖版本是5.x版本，不支持Mysql8.x版本，所以我们要将Nacos源码下载下来修改后重新打包使用。
我本地使用的是1.1.4版本。
官网下载地址：https://github.com/alibaba/nacos/releases/tag/1.1.4
下载源码文件后并解压出来。
步骤1、修改pom.xml中依赖的jar包成自己本地安装的版本，比如我本地安装的是8.0.11。
步骤2、修改D:\software\nacos-1.1.4\naming\src\main\java\com\alibaba\nacos\naming\healthcheck\MysqlHealthCheckProcessor.java文件内容
步骤3、修改第24行内容import com.mysql.jdbc.jdbc2.optional.MysqlDataSource，为：import com.mysql.cj.jdbc.MysqlDataSource;
步骤4、在nacos源码的根目录下使用命令重新打包。
mvn -Prelease-nacos clean install -U 打出来的新包就在此目录里。
进到此目录后，新建nacos数据库，执行此脚本，可看到有11张表。
然后在application.properties文件末尾增加如下配置，特别要加上时区，否则无法启动：
################################################## spring.datasource.platform=mysql db.num=1 db.url.0=jdbc:mysql://127.0.0.1:3306/nacos?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;serverTimezone=GMT%2B8 db.user=root db.password=123456 执行startup.cmd，访问localhost:8848/nacos，进入后新加配置，查看数据库。config_info表中将有新加的记录。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc359831032c1c400e672103a653cd97/" rel="bookmark">
			view size is not compatible with input tensor‘s size and stride
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在跑py-Vital的代码
读论文这么久了，第一次跑代码.啥也不懂，
上来一开始跑了tracking，一直报错。觉得代码应该没有问题啊。以为是没有跑预训练的缘故，于是，又去下载数据集。当然下载很慢，直接把别人服务器上的代码cp过来，或者直接改了地址，引用了别人文件夹下的数据集，亲测好用，嘿嘿。
跑了两天预训练，终于跑完了，又去跑tracking，又报错，还是同样的错误。
RuntimeError: view size is not compatible with input tensor's size and stride (at least one dimension spans across two contiguous subspaces). Use .reshape(...) instead. 参考别人的解决方法：原因：用多卡训练的时候tensor不连续，即tensor分布在不同的内存或显存中。
解决方法：对tensor进行操作时先调用contiguous()。如tensor.contiguous().view()
于是打开文档，ctrl+f ，查找view，在前面加上contiguous()，终于跑通了。激动！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/525a7543a50e2aed72ae3eb8e25ab4cb/" rel="bookmark">
			L1-040 最佳情侣身高差 (10分)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 专家通过多组情侣研究数据发现，最佳的情侣身高差遵循着一个公式：（女方的身高）×1.09 =（男方的身高）。如果符合，你俩的身高差不管是牵手、拥抱、接吻，都是最和谐的差度。
下面就请你写个程序，为任意一位用户计算他/她的情侣的最佳身高。
输入格式：
输入第一行给出正整数N（≤10），为前来查询的用户数。随后N行，每行按照“性别 身高”的格式给出前来查询的用户的性别和身高，其中“性别”为“F”表示女性、“M”表示男性；“身高”为区间 [1.0, 3.0] 之间的实数。
输出格式：
对每一个查询，在一行中为该用户计算出其情侣的最佳身高，保留小数点后2位。
输入样例：
2 M 1.75 F 1.8 输出样例：
1.61 1.96 #include&lt;bits/stdc++.h&gt; using namespace std; int main(){ int n; char c; double h; cin &gt;&gt; n; while(n--){ cin &gt;&gt; c &gt;&gt; h; if(c=='M'){ printf("%.2lf\n",h/1.09); }else{ printf("%.2lf\n",h*1.09); } } return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f92eef7b611b17fd37691e1986e805a0/" rel="bookmark">
			SpringBoot常用注解及其作用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		springboot中的常用注解有：
1、@SpringBootApplication
这个注解是Spring Boot最核心的注解，用在 Spring Boot的主类上，标识这是一个 Spring Boot 应用，用来开启 Spring Boot 的各项能力。实际上这个注解是@Configuration,@EnableAutoConfiguration,@ComponentScan三个注解的组合。由于这些注解一般都是一起使用，所以Spring Boot提供了一个统一的注解@SpringBootApplication。
2、@EnableAutoConfiguration
允许 Spring Boot 自动配置注解，开启这个注解之后，Spring Boot 就能根据当前类路径下的包或者类来配置 Spring Bean。
如：当前类路径下有 Mybatis 这个 JAR 包，MybatisAutoConfiguration 注解就能根据相关参数来配置 Mybatis 的各个 Spring Bean。
@EnableAutoConfiguration实现的关键在于引入了AutoConfigurationImportSelector，其核心逻辑为selectImports方法，逻辑大致如下：
●　从配置文件META-INF/spring.factories加载所有可能用到的自动配置类；
●　去重，并将exclude和excludeName属性携带的类排除；
●　过滤，将满足条件（@Conditional）的自动配置类返回；
3、@Configuration
用于定义配置类，指出该类是 Bean 配置的信息源，相当于传统的xml配置文件，一般加在主类上。如果有些第三方库需要用到xml文件，建议仍然通过@Configuration类作为项目的配置主类——可以使用@ImportResource注解加载xml配置文件。
4、@ComponentScan
组件扫描。让spring Boot扫描到Configuration类并把它加入到程序上下文。
@ComponentScan注解默认就会装配标识了@Controller，@Service，@Repository，@Component注解的类到spring容器中。
5、@Repository
用于标注数据访问组件，即DAO组件。
使用@Repository注解可以确保DAO或者repositories提供异常转译，这个注解修饰的DAO或者repositories类会被ComponetScan发现并配置，同时也不需要为它们提供XML配置项。
6、@Service
一般用于修饰service层的组件
7、@RestController
用于标注控制层组件(如struts中的action)，表示这是个控制器bean,并且是将函数的返回值直 接填入HTTP响应体中,是REST风格的控制器；它是@Controller和@ResponseBody的合集。
8、@ResponseBody
表示该方法的返回结果直接写入HTTP response body中
一般在异步获取数据时使用，在使用@RequestMapping后，返回值通常解析为跳转路径，加上@responsebody后返回结果不会被解析为跳转路径，而是直接写入HTTP response body中。比如异步获取json数据，加上@responsebody后，会直接返回json数据。
9、@Component
泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。
10、@Bean
相当于XML中的,放在方法的上面，而不是类，意思是产生一个bean,并交给spring管理。
11、@AutoWired
byType方式。把配置好的Bean拿来用，完成属性、方法的组装，它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作。
当加上（required=false）时，就算找不到bean也不报错。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f92eef7b611b17fd37691e1986e805a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de411bea7e96a35948f35abbcaddd471/" rel="bookmark">
			X星球居民小区的楼房全是一样的，并且按矩阵样式排列。其楼房的编号为1,2,3...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		X星球居民小区的楼房全是一样的，并且按矩阵样式排列。其楼房的编号为1,2,3…
当排满一行时，从下一行相邻的楼往反方向排号。
比如：当小区排号宽度为6时，开始情形如下：
1 2 3 4 5 6
12 11 10 9 8 7
13 14 15 …
我们的问题是：已知了两个楼号m和n，需要求出它们之间的最短移动距离（不能斜线方向移动）
输入为3个整数w m n，空格分开，都在1到10000范围内
要求输出一个整数，表示m n 两楼间最短移动距离。
[样例输入]
6 8 2
[样例输出]
4
[样例输入]
4 7 20
[样例输出]
5
*/
方法一：（思维简单,但比较麻烦，执行速度慢）
package 蓝桥; import java.util.Scanner; public class lou { public static void main(String[] args) { Scanner scanner=new Scanner(System.in); int tamp=scanner.nextInt(); int n,m,sum=0; n=scanner.nextInt(); m=scanner.nextInt(); int[][] a=new int[10000/tamp+10][tamp]; int x=-1,y=0,o=1; for (int i = 1; i &lt;= 10000; i++) { x+=o; //System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de411bea7e96a35948f35abbcaddd471/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e15051ea5fd9d45cb66238026ef0cdd/" rel="bookmark">
			杂谈JVM
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		赵云胡说-杂谈JVM 序jvm之运行时内存jvm之对象的一生jvm之天道的发展jvm之大并发时代结 序 学习jvm已有半月,为了防止自己学完就忘记,写此博客.
jvm之运行时内存 jvm的运行时内存,是学习jvm一个不错的切入点,在此一一列出:
1.虚拟机栈: 一千个人眼中有一千个哈姆雷特,一千个线程有一千个虚拟机栈,在操作系统层面看的话,用户级线程便是分着不同的栈去执行的,既然操作系统老大哥都这样,jvm的线程肯定也是一个线程一个栈了.一个虚拟机栈中又有什么呢,看看老大哥的栈中,是一个一个的栈帧,jvm自然也是栈帧了(栈帧即方法).除了栈帧,jvm还有一个小的可以忽略的程序计数器(程序计数器记录每个线程运行的位置,方便线程的切换),操作系统拥有着tcb(ThreadControllerTable),可以记录自己运行到哪儿了,所以不需要程序计数器.因此就没有这个概念了吧.那么栈帧里面又是什么呢,这里面jvm就分的很细致了,操作数栈,局部变量表,动态链接,返回地址.
操作数栈是个啥呢?操作系统中,根据指令,将需要操作的数据放入寄存器组中,之后运算出来,运算中途的数据存入寄存器里面暂存,最后要是出了结果需要保存,那就把它保存到栈帧中(内存).那jvm的操作数栈是什么呢,笔者觉得这只是个抽象的概念,靠jvm具体的底层发挥和编写,或许它是一级缓存又或者它就是寄存器,只要你读取速度够快,可以满足jvm要求,应该就差不多了. 咳咳,后来看了下&lt;&lt;深入理解java虚拟机&gt;&gt;,找到了答案,原来是两种不同的指令集结构,java用的是基于栈的指令集结构,而操作系统使用的是基于寄存器的指令集结构,他们的区别在于,基于栈的指令集结构因为不需要关注寄存器,使其可移植性好,但是速度较慢,因为需要频繁的出入栈操作.而基于寄存器的指令集结构是主流cpu都支持的.书中也提到了jvm将常用的操作映射到了寄存器中,同时也使用了栈顶缓存去加快指令运算速度,看来我之前的想法也并非全是错误的.(&lt;&lt;深入理解java虚拟机&gt;&gt;牛批!!!)
局部变量表是个啥呢?这个没啥好说的了,从入门java开始,局部变量表一直是被我当作栈的存在,什么值传递,地址传递搞得我晕晕乎乎,貌似c语言可以自定义值传递还是地址传递啊(可能不是),但是java就写死了,基本数据类型是值传递,其他的对象就是地址传递,这些值啊,地址啊是方法私有的,那么当然是存在每个栈帧的局部变量表里面的了.对象就把地址放到局部变量表中
动态链接的话,就比较远了,可以扯很久,c也是有动态链接的,都是为了解决某些需要调用的时候才能确定的地址,你总不能直接写地址吧,那以后改了点代码,所有的地址是不是都要改一下呢,再者你也不知道加载到内存以后你的地址在哪儿了.java中的动态链接是将符号引用转化为直接引用的过程,为什么叫动态的,是因为它在运行时这个符号引用的直接引用才确定下来的,那什么时候会发生动态链接呢?在java的重写时,具有多态性,发生重写的过程便是去检查实际类型(A继承B,A a = new B() 这时B为a的实际类型)的该方法,如果有,自然直接去调用,如果没有就要去找他的父类有没有,没有就是父类的父类去找,这时便是会发生动态链接的,因为发生在运行时,找到了符合的方法才把符号引用替换掉为直接引用(重写感觉和自带的类加载器双亲委派机制反着来的)
返回地址字面意思,方法执行完以后,栈帧出栈,那么你要回归上一个栈帧去执行了,这个就是记录你上个栈帧执行到哪儿了
2.堆:java运行时内存里面的大佬,堪称一霸.为什么一霸,因为它一般情况下都是最大的那一块.堆中又有方法区(1.8里面的hotspot为元空间),老年代,新生代这三为巨头
方法区一个很稳定的巨头,他的子民有些从混沌初开(jar包刚运行的时候)之时就基本诞生并且安居在此,有些也会在运行时诞生一些出来(类加载进来的类),已然摆脱六道轮回(YonugGc),但是却难逃那天地重塑(FullGc),就算是fullgc也不是那么容易回收他们,真正的天难灭,地难葬.里面的居民都是些什么角色呢? 运行时常量池（Runtime Constant Pool） 字段和方法数据、构造函数和普通方法的字节码内容、还包括一些在类、实例、接口初始化时用到的特殊方法.另外方法区只是一个规范,具体的实现根据jdk的版本和厂商不同是各不相同的.
老年代是一些古董们的聚集地,他们通过后天的努力基本上也是摆脱了六道轮回(YonugGc)之苦,却也是逃不过天地重塑(FullGc)的.另:有些实力天生雄厚的家伙(大对象)可以很容易混入老年代,而他们可能就是天地重塑的祸根之一
新生代烽烟四起之地,所有人饱受这六道轮回(YonugGc)之苦,想要活下去必须上头有人(根可达),新生代分为Eden,From和To三个区域.只有历经轮回(默认经历16次的YoungGc)才能熬到老年代,不必日日担忧
3.本地方法栈:本地方法栈的话,从操作系统上对比的话是这样子的.C语言无法直接使用硬件,所以操作系统提供系统调用的api,让C语言使用,Jvm作为模仿操作系统的小弟,他也没法系统调用啊,所以直接封装了本地方法栈(C语言写的),提供给java去调用,来实现对硬件的控制.
4.直接内存:直接内存,已经脱离了jvm的管控了,一般是unsafe类的或者是nio里面的各种Buffer会使用的,在笔者看来,倒像是直接开始搞c了,自己回收内存,自己管理,大佬们的利器,小白(笔者)慎用!
jvm之对象的一生 当某个new命令被执行时,一个对象就要被创建了,让我们看看他的一生吧.
1.对象结构:java的对象结构分为:对象头,实例数据和填充部分
对象头又可以分为markWord,对象指针和数组长度,对象指针就是指向该对象是哪个类的,数组长度是该对象如果是数组,那么便记录该数组的长度,不是数组对象则无该部分,markWord较为复杂了,其中有锁信息,对象的hash值,对象的分代年龄等
实例数据顾名思义,你的实例的信息
填充部分 java对象的大小是有规则的,是8字节的倍数,为什么有这样的规则呢,是为了更轻松的管理内存(C也有这样的对齐规矩)
2.对象的诞生:一个java对象是怎么出现的呢,new自然是一个很简单的方法,其中反射的newInstance(Class的和Constructor的)也会创建对象,这两种都是使用的类的构造方法.还有使用clone方法和反序列化也是会新建对象,并且不会调用构造方法
一个对象想要降生,那必须有登记在册的类,所以第一件事情就是看看你是哪个类的呢?这个过程就是检查验证了,看看在方法区的常量池,拿着new的对象的字面量去找你这个类有没有被加载,解析,初始化过,如果没有则需要进行类的加载.
倘若类能够被正确加载过来并完成了解析和初始化的话,那么这个类就会调用构造方法在堆中创建一个新的对象啦~~
你不会以为很简单的就去创建了吧,在堆中创建一个对象可不是一件容易的事情,首先呢,你这个堆中的新对象要放在哪里呢,聪明的你会说是在堆的eden区里面.很棒!但是eden区的哪里呢?你会不会觉得我是只杠精,但是在实际的jvm分配内存去创建对象的话,这难道不是一个需要考虑的问题吗.jvm中分配内存有两种方法:第一种是指针碰撞,如果堆内存中没有内存碎片,使用的内存和未使用的内存分别在eden区的两端,这个时候,将中间分隔得指针向后移动对象大小,这种分配就叫指针碰撞.要是有内存碎片呢?那自然出现了第二种分配方法了:空闲列表:维护一个列表(比如位图)去标记哪些内存使用了,然后选出合适的连续的没有被使用的空间给堆去使用,这就是空闲列表了.(CMS垃圾收集器会出现内存碎片,PS和serial是不会产生内存碎片的)
可是,堆是线程共享的一个空间啊,那么要是这一块空间被两个线程同时得到了,这样不就有问题了吗?jvm在分配内存时会有cas操作去保证分配内存时不会出现吧并发问题,当然如果是小对象的话,会有TLAB(ThreadLocalAlloactionBuffer,每个线程会在堆中分配一小段空间属于线程私有去创建对象的,来避免并发问题).之后设置对象的对象头的信息,最后执行对象的初始操作,这样一个对象就这样子诞生了!
3.对象的访问:一个对象终于就此诞生了,对于栈中的单身狗来说,怎么联系这个对象呢?jvm的规范中并没有明确的规定该怎么访问对象.现在主流的对象访问分为两种:Hotspot用的是直接指针, 而除了直接指针以外还有使用句柄池访问的(详见百度).
4.对象的回收:世上谁人能不死?任你风华绝代，艳冠天下，到头来也是红粉骷髅；任你一代天骄，坐拥万里江山，到头来也终将化成一抔黄土,对象也总有被回收的那一天.六道轮回(YoungGC),天地动荡(FullGC).
绝境中求生:想要不死,不能单单靠自己,堆中想长久,必须要有一位老祖(gc root)坐镇庇护,才能在一次又一次劫难中艰难求生.那什么样的境界才能变成这样的老祖呢?
老祖们是这些家伙:栈中的单身狗的对象(强引用),静态属性引用的对象,方法区中类静态属性引用的对象,Native中引用的对象.这些对象不仅自身不灭,只要是其一脉(有关联的对象)也是可保周全的.有真的老祖也有伪神,号称能庇护一方,实际是骗子!他们就是栈中的软引用,弱引用和虚引用,软应用的对象不怕youngGC但是fullGC便会杀死他,弱引用和虚引用却连fullGC都抵抗不了,十足的外强中干(软引用和弱引用常用于缓存的框架,虚引用貌似没什么大用).
jvm之天道的发展 道可道,非常道；名可名，非常名。无名，天地之始，有名，万物之母。jvm的堆中的天道便是垃圾回收器
三千堆世界,每个堆世界都有这么一些天道,他们以万物为刍狗,发起灭世之乱,动则六道轮回(YoungGC),甚至天地重塑(FullGC).天道无情,却有迹可循,让我们看看有哪些天道.
初代目:Serial/Serial Old串行收集组合,最古老的天道(垃圾回收器).单线程的收集方式以及有限的空间管理大小,令人发指"Stop the world"的时间,初代天道的力量终究是有点拿不出手哈.开启参数-XX:+UseSerialGC
二代目:parNew/Serial Old初代目天道苦学东瀛影分身之术,终于能够多线程的去回收垃圾了,他其实就是初代目Serial的多线程版本,在使用CMS作为垃圾回收器时会默认使用他收集新生代.因为时多线程收集,所以收集效率在cpu多核下比初代目好.开启参数:-XX:UseParNewGC或者开启CMS时也会默认使用parNew收集新生代,当CMS的空间碎片太多会启动Serial Old回收老年代
三代目:PS组合,ParallelScavenge(处理新生代)与ParallelOld(处理老年代),在jdk1.8中默认使用的垃圾回收器,并行垃圾回收器的巅峰,吞吐量优先的回收机制,GC自适应的调节策略(会根据设置的参数,动态设置新生代的大小来达到设置参数).ParallelScavenge提供了精确控制暂停时间和吞吐量的参数-XX：MaxGCPauseMillis,-XX：GCTimeRatio .不会jvm调优怎么办PS组合自适应的调节策略带你飞.怎么设置ps?都说了默认开启,不配置就行~~
四代目:CMS(Concurrent Mark Sweep),并行的时代终将结束.CMS是天道中划时代的存在,他的诞生开启了垃圾回收器的大并发时代!(并发:指的是不用stop the world 就可以进行回收了),PS组合已经将吞吐量做到了极致,CMS想要出头,必须另辟蹊径,既然吞吐量出不了头,那就去搞并发吧,CMS成功了,但是也失败了,他开启了一个时代,但是他并没有完善很多缺陷,最后不得不求助parNew/Serial Old帮他处理烂摊子.开启参数-XX:+UseConcurMarkSweep
五代目:Garbage-First(G1),继承了CMS的精神,贯彻落实CMS的并发思想,他成功了!开启参数:-XX:UseG1GC
jvm之大并发时代 对于垃圾回收器的并发收集,是需要更加深入理解的.特开一节,在这里我们聊一聊CMS和G1垃圾回收器的实现并发收集的细节以及一些坑与解决方法
标记清扫算法它是用可达性分析算法(可达性分析算法是jvm中垃圾回收器使用的判断对象是否可回收的一个算法)分辨出哪个对象是可回收的,哪个是不可回收的,但是因为标记清扫算法它每次回收完是首先将所有对象的标志位变为0,然后标记好不可回收的是1,可回收的为0.等回收完了以后,会把剩余对象的标志位1变成0方便下次标记清除.因为这个算法它在不同的时期标志位的0和1是有不同意思的,如果是并发的收集模式的话,新产生的对象标记位到底是0还是1呢?如果是0的话,此时如果结束了标记状态开始回收,是必然将新对象回收掉了,但是如果是1的话,万一没有被置为0,下次这个对像本来是要回收的.但是因为初始是1,那必然不会被回收掉.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e15051ea5fd9d45cb66238026ef0cdd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0fecdfc44e3c57910002d73242f63c6/" rel="bookmark">
			sed -i 单引号中嵌套双引号_【linux】Shell 单引号&amp;#x27;&amp;#x27;   双引号&amp;quot;&amp;quot; 反引号``  和$()的区别和用法...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		发行版为 red hat 以及centos，其他发行版未经验证 部分段落摘抄自网络，侵删 转载请注明出处 感谢点赞 单引号''和双引号"” 两者都是解决变量中间有空格的问题。
在bash中“空格”是一种很特殊的字符，比如在bash中这样定义str=this is String，这样就会报错，为了避免出错就得使用单引号''和双引号""。
单引号''，双引号""的区别是单引号''剥夺了所有字符的特殊含义，单引号''内就变成了单纯的字符。双引号""则对于双引号""内的参数替换($)和命令替换(``)是个例外。
比如说 n 结果就是$n，因为所有字符均被当做普通字符处理
改成双引号　echo "$n"，结果就是3
`` 学名叫“倒引号”或者“反引号”， 如果被“倒引号”括起来， 表示里面需要执行的是命令。Shell可以先执行``中的命令，将输出结果暂时保存，在适当的地方输出。
比如 `dirname $0`， 就表示需要执行 dirname $0 这个命令。
下面的例子中，将命令执行结果保存在变量中：
#!/bin/bash 上述代码命名为123.sh并赋予权限运行后，输出结果如下
反引号是老的用法，$()是新的用法，推荐使用$()。使用方式和反引号一致，如下：
DATE1 通常情况下两种形式的变量替换是等价的，但是两者还有一点区别，反引号``不支持嵌套而$()则支持嵌套，如计算目录下第一个文件的行数：
lines 输出结果为：
89 anaconda-ks.cfg 此外，$() 仅在 Bash Shell 中有效，而反引号可在多种 Shell 中使用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0ec6e7a352cde467cd19e049ad33af8/" rel="bookmark">
			python输出100以内偶数_Python求取100以内的所有偶数和奇数以及和
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用Python求取100以内的所有偶数和奇数以及和，是Python的一道基础练习题目，刚好在看Python4.0学习手册第十三章循环，觉得挺有意思，就想了下这道题目的代码，想到两种方式。
# coding:utf-8
# author: Yert
#通过while循环来提取100以内的偶数和奇数,并分别求和。
#偶数
a=100
s=0
while a&gt;0:
a=a-1
if a % 2 == 0:
print(a,end=' ') #end=''的作用是打印数字时不会换行，可以并排阅读。
s+=a
print('\n偶数和是：',s,'\n')
#奇数
b=100
u=0
while b&gt;0:
b=b-1
if b % 2 != 0:
print(b,end=' ')
u+=b
print('\n奇数和是：',u)
#通过for循环来提取100以内的偶数和奇数,并分别求和。
#偶数
a=0
for i in range(0,100):
if i % 2 ==0:
print(i,end=' ')
a += i
print('\n偶数是：',a,'\n')
#奇数
b=0
for i in range(0,100):
if i % 2 != 0:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e0ec6e7a352cde467cd19e049ad33af8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ffca0681b6a09b70bccf6433ca09c8a8/" rel="bookmark">
			python用递归方式实现最大公约数_使用Python求解最大公约数的实现方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 欧几里德算法
欧几里德算法又称辗转相除法， 用于计算两个整数a, b的最大公约数。其计算原理依赖于下面的定理：
定理： gcd(a, b) = gcd(b, a mod b)
证明：
a可以表示成a = kb + r, 则r = a mod b
假设d是a, b的一个公约数， 则有 d|a, d|b, 而r = a - kb, 因此d|r。
因此，d是(b, a mod b)的公约数。
加上d是(b，a mod b)的公约数，则d|b, d|r, 但是a = kb + r,因此d也是(a, b)的公约数。
因此，(a, b) 和(a, a mod b)的公约数是一样的，其最大公约数也必然相等，得证。
欧几里德的Python语言描述为：
?
1
2
3
4
5
6
7
8
9
10
def gcd(a, b):
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ffca0681b6a09b70bccf6433ca09c8a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56d4f0378ac66f4a9ad71cc10ea6030d/" rel="bookmark">
			经典思维面试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 有两根香，每一根香的粗细是不均匀的，每一根香燃烧完毕需要1个小时，因为香的粗细是不均匀的，所以不能依靠香的长度比例来判断时间长短，问题是，怎么设置一个15分钟的定时器
2根同时点,一根点一头,一根点两头.点两头的烧完的时候就是半个小时,这时候把点一头的香另一头点上,到烧完不就是15分钟
2. 有3L和5L两个没有刻度的玻璃杯，你能用这两个杯子在不浪费水的情况下量出4L和7L的水吗？
应该是 先加满5升杯，倒3升于小杯中，剩2升，小杯倒掉，大杯的2升倒入小杯，再将大杯装满，共7升。将大杯倒入小杯中1升使小杯满，大杯剩4升。
3. 如下图，警察先走，警察能不能抓到小偷
可以抓到。
step1：警察走左下，小偷只能左上；
step2：警察往右一步，小偷只能左下；
step3：警察左上回到开局位置，小偷此时往上往下都会被抓；
step4：警察抓住小偷。
4. 在一个50个人的班级里，两人或以上同一天生日的概率是多少？为什么？
几乎是百分之一百
首先算出不在同一天的几率
假定第一个学生的生日为1月1日，那么第二个学生要和他不同就有364种选择，所以这两个同学生日不同的概率是364/365。现在第三个同学，他的生日与他们都不同的概率是363/365……以此类推。每个多一个人，他们的生日不同的概率是越来越小的。那么归纳一下，
计算：N个人中生日不同的概率是多少：
可以得到式子：(364/365)(363/365) ……[(365-N+1)/365]
当然N为［2，366］的自然数
所以结果为:
1-(364/365)(363/365) …(315/365)=1-(364,50)/365^50=0.974（同一天生日的几率）
即有97.4%的几率
5. 你和一个朋友参加聚会，聚会算上你们一共10人。。。你的朋友想要跟你打个赌，你在这些人每找到一个和你生日相同的，你就赢1块钱，他在这些人里没找到一个和你生日不同的人，他就赢2块钱，你感不感打这个赌？
这个问题需要用反概率运算方法，就是通过计算这10个人中生日不同的概率有多少，来推断相同概率。
1、两个人生日日期不同概率计算如下365/365 X 364/365 = 99.72%
2、三个人生日日期不同概率计算如下365/365 X 364/365 X 363/365 = 99.17%
3、四个人呢？365/365 X 364/365 X 363/365 X 362/365 = 98.36%
4、十人呢？365/365 X 364/365 X 363/365 X 362/365 X 361/365 X 360/365 X 359/365 X 358/365 X 3357/365 X 356/365 = 88.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/56d4f0378ac66f4a9ad71cc10ea6030d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9cbd295b3c6d2ca7a5a708255ac7064/" rel="bookmark">
			python的软件有哪些_有哪些你不知道的Python小工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python作为越来越流行的一种编程语言，不仅仅是因为它语言简单，有许多现成的包可以直接调用。
python中还有大量的小工具，让你的python工作更有效率。
1. 快速共享
HTTP服务器
SimpleHTTPServer是python内置的web服务器，使用8000端口和HTTP协议共享。
能够在任意平台（Window，Linux，MacOS）快速搭建一个HTTP服务和共享服务，只需要搭建好python环境。
python2版本：
python -m SimpleHTTPServer
python3版本：
python -m http.server
FTP服务器
ftp共享需要第三方组件支持，安装命令：
pip install pyftpdlib
python -m pyftpdlib-p端口号
访问方式：ftp://IP:端口。
2. 解压缩
这里介绍利用python解压五种压缩文件：.gz .tar .zip .rar
zip
import zipfile
# zipfile压缩
z = zipfile.ZipFile('x.zip', 'w', zipfile.ZIP_STORED) #打包，zipfile.ZIP_STORED是默认参数
# z = zipfile.ZipFile('ss.zip', 'w', zipfile.ZIP_DEFLATED) #压缩
z.write('x2')
z.write('x1')
z.close()
#zipfile解压
z = zipfile.ZipFile('x.zip', 'r')
z.extractall(path=r"C:UsersAdministratorDesktop")
z.close()
tar
import tarfile
# 压缩
tar = tarfile.open('your.tar', 'w')
tar.add('/Users/wupeiqi/PycharmProjects/bbs2.log', arcname='bbs2.log')
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d9cbd295b3c6d2ca7a5a708255ac7064/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79bae22d385bc5fe8b7d29ae459b50b4/" rel="bookmark">
			python怎么判断是不是列表_Python 判断元素是否在列表中存在
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python 判断元素是否在列表中存在
定义一个列表，并判断元素是否在列表中。
实例 1
test_list = [ 1, 6, 3, 5, 3, 4 ]
print("查看 4 是否在列表中 ( 使用循环 ) : ")
for i in test_list:
if(i == 4) :
print ("存在")
print("查看 4 是否在列表中 ( 使用 in 关键字 ) : ")
if (4 in test_list):
print ("存在")
以上实例输出结果为：
查看 4 是否在列表中 ( 使用循环 ) :
存在
查看 4 是否在列表中 ( 使用 in 关键字 ) :
存在
实例 2
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/79bae22d385bc5fe8b7d29ae459b50b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e00a6e7a56835db23dceef7b0304ac5/" rel="bookmark">
			python调用matlab函数_Python调用matlab函数( 使用matlab官方api,解决多维numpy矩阵输入问题)...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 安装
首先，需要安装MATLAB引擎。Windows cmd打开，cd到：E:\MATLAB\R2016b\extern\engines\python
输入（linux同理）：
python setup.py install
2.确保编辑器为本地环境，试验 import matlab.engine 是否可用
3.matlab中写方程
安装完成后，MATLAB写一个简单的函数
function x=myLS(A,B)
x = A\B;
end
​
随后，打开 Python, 运行如下命令
import matlab.engine
eng = matlab.engine.start_matlab()
y = eng.myLS(matlab.double([[1.],[2.]]),matlab.double([[3.],[4.]]))
print y
4.但此时意识到一个问题：多维np矩阵传递无法转化为matlab.double
报错 ValueError: initializer must be a rectangular nested sequence
matlab官方论坛建议：
python里面 put numpy.ndarry into a list:
data_list = data.tolist()
或者
data_list= matlab.double(data_list.tolist())
MATLAB 里面:
a = [data_list{:}];
x = cell2mat(a);
y = double(reshape(x,32,32));
或者：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e00a6e7a56835db23dceef7b0304ac5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6247a303b5b495e4db38d63ecc6b3bf/" rel="bookmark">
			学习笔记｜fmri_5 debug一下 做完coregister之后再normalize 头像是歪的
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题如下图：
错误原因 不说过程了，debug了两天，试了三四个教程的预处理，后面发现是因为结构像和功能像三张图的顺序不一致的原因。
错误的，如下图
正确的，六张图 一对一对位置一致
问题试错及纠正 最后的问题排查程序，前面都试过头还是歪的，就把图放一起看有没有其他可能性，后面猜测很有可能是因为图的顺序不一样，因为移坐标的时候，是按位置动的。
记录一下试错步骤
1、❌用MRIconvert重新转了一遍数据，还是不对，转完之后结构像位置2和3对调了
2、✅看原始数据（IMA）是对的，DICOM也是对的，最后用SPM的DICOM import又重新转了T1结构像的文件
之前尝试转功能像的，发现还是两个对不上，又回来转了结构像，本来就是试一试，没想到对了。转完T1的数据，再用预处理batch文件重新跑一遍预处理，头都对，不歪了。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5326370092498c8f0715c123ead8b47a/" rel="bookmark">
			数据结构练习：自写的想法写归并排序    2020.11.20
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include &lt;iostream&gt; #include&lt;vector&gt; using namespace std; /* run this program using the console pauser or add your own getch, system("pause") or input loop */ void merge_short(vector&lt;int&gt; &amp;q,int l,int r); void merge_short(vector&lt;int&gt; &amp;q,int l,int r) { int mid=(l+r)/2; if(l==r) return; int left=l,right=r,i,r2=mid+1; merge_short(q,l,mid); merge_short(q,mid+1,r); static vector&lt;int&gt; w; w.clear(); //将较小的数据存放在临时数组中 while(l&lt;=mid&amp;&amp;r2&lt;=r) { if(q[l]&lt;=q[r2]) { w.push_back(q[l++]); } else { w.push_back(q[r2++]); } } while(l&lt;=mid)w.push_back(q[l++]);//将l到r的剩余数据存储到w中 while(r2&lt;=r)w.push_back(q[r2++]); for(i=left;i&lt;=mid;i++)//将w中排好序的数据填充到原数组中 { q[i]=w[i-left]; } for(int j=mid+1;j&lt;=right;j++,i++) { q[j]=w[i-left]; } return; } int main(int argc, char** argv) { vector&lt;int&gt; a; int i=0,n; cin&gt;&gt;n; for(i=0;i&lt;n;i++) { int b; cin&gt;&gt;b; a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5326370092498c8f0715c123ead8b47a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44c047d2e4a1376c77979ba9bffc0723/" rel="bookmark">
			python 语音转文字_音频转文字这种刚需，我用python写了个软件，免费不限时
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最新独立版本，bug更少，支持格式更多，欢迎体验。王华：音频转文字工具，完全免费，自己用Python写的！​zhuanlan.zhihu.com
一、需求分析：
1、音频转文字：目前市面上的音频转文字大多收费。音频转文字的需求是：上传一段音频，直接识别成文字，对于会议记录的比较好使，注意不是实时的语音识别。
2、文字转语音：转的语音不要太生硬。
3、截图文字识别（OCR）：截屏完成即可弹出截图所含图片中的文字。
4、批量图片文字识别：选择多张图片，直接识别出每张图片的文字。
5、复制翻译：看英文文献，有时候懒，如果能有置顶悬浮窗，实时监测剪切板，遇到想要翻译的段落，直接复制，即可给出多国语言翻译结果也是刚需；当然有些论文文本不能复制，所以还复用了截图OCR的功能，对OCR结果进行翻译。
6、图种制作：这个不入流，纯属个人爱好，没啥技术含量。
二、工具展示
需求产生开发动力，基于百度AI和pyqt5制作了自己的小工具，解决了上述所有需求，需求也就就是功能了。
1、批量音频转文字
可批量选择要转换的音频即可自动识别，不限时长，免费，识别速度尚可，耐心等待。
（1）比如批量识别小学生课文
（2）比如识别长达五分钟的《荷塘月色》
（3）识别岳云鹏的相声
2、文字转语音
这个没什么好说的，输入文字，选择发音人、语速、音调之类的，可试听，可生产mp3格式的音频文件。
3、截图OCR
点击截图按钮即可截图，自动弹出识别文字。如下动图演示，也是个初版，界面简陋。
4、图片批量识别
在截图OCR下拉按钮有个图片批量文字识别功能，这都属于OCR功能，简单粗暴，批量选择图片，即可识别所有图片中的文字。如下动图演示：
5、复制翻译：
看英文文献，有时候懒，如果能有置顶悬浮窗，实时监测剪切板，遇到想要翻译的段落，直接复制，即可给出多国语言翻译结果也是刚需；当然有些论文文本不能复制，所以还复用了截图OCR的功能，对OCR结果进行翻译。
如下演示：
6、图种制作
没啥意思，就是将一张图和一个压缩文件合并成一个图片文件，这个生成的图片文件打开是一张图，如果后缀修改为zip，解压后就能看到原先的压缩文件，不做演示了。
三、软件使用
1、下载解压直接运行即可，注意运行弹出的黑窗不能关，目前还没办法去掉，o(╯□╰)o。
提取码：hbjv
2、主界面参数配置，自己动手，输入百度AI的各种接口的key。
各种key的获得方法免费，只不过注意免费次数，不过百度免费次数给的肯定够用了。
然后给出官方地址
注意申请完，在key界面如下点击领取哈，否则会出现转换空文件夹的情况
注意申请完，在key界面如下点击领取哈，否则会出现转换空文件夹的情况
注意申请完，在key界面如下点击领取哈，否则会出现转换空文件夹的情况
写这么多次，还能有人看不见嘛？？？？
四、注意事项：
软件做的仓促，界面简陋，且各种未知bug再所难免，如有建议可查看关于软件，有交流QQ群。
下载链接
提取码：hbjv
注意申请完，在key界面如下点击领取哈，否则会出现转换空文件夹的情况
防止看不见！！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b30d245ebab11bd9dbf2833a9c4352cb/" rel="bookmark">
			python计算小数点后有几位_Python学习（一）数值与字符串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		##Python学习(一)数值和字符串
##最近学习Python，顺便和大家分享一下学习中的问题与知识点，共同学习。
##1.数值
在Python中常用的数值类型有整型和浮点型，当然还有复数，但是不是很常用。
整型也就是整数，用int表示；浮点型就是小数，用float表示。
这里要知道的是，Python中的整数大小没有限制，可以无限大，这和C语言等不同，他们的整数是分好几种类型的，大小都有限制，这也可以算是Python的一个优点。
当数字过长时，为了我们方便阅读，并且保证正确率，数字之间是可以用下划线隔开的，而不会影响结果。
比如：
a = 123_456_789
我们来看一下输出结果：
结果正确，为a=123456789
还有一点要注意，在Python中没有分号，换行即语句结束。
如果输入一个数字，默认为十进制，十进制的数字是不能以0开头的，如果需要输入其他进制的数字，只需要加上相应的前缀就可以。
二进制：0b
八进制：0o
十六进制：0x
比如想输入二进制的10：
a = ob10
也可以直接对数字进行运算，比如：
a = a + 2
如果给变量赋的数值为小数，这时就默认为float类型。如：
a = 1.23
还有一点需要知道的是，在Python中，对浮点数进行运算可能会得到一个不精确的结果。如：
a = 0.1 + 0.2
这是因为在二进制中是无法精确计算十分之一的，当然在这里可以只保留小数点后前几位，这样就是准确的，但是在做精确度比较高的工作中就不能这样了。
##2.字符串
文本可以以字符串类型保存到变量中，使用时只需要将一段文本用引号引起来即可，单引号和双引号都可以。
如：
a = ‘hello world’
a = “hello world”
但是如果需要输出一个很长的字符串或者是有换行需求，这时字符串是不能直接换行的，因为Python是一个严格缩进的语言。
在这里我们需要使用反斜杠\作为转义字符，表示上一句还没有完全结束，加到每一句的后面，就可以实现换行了。
如：
= ‘hello
world’
在Python中，还有一种方法可以实现字符串的换行，就是长字符串。
长字符串用三重引号来表示，如：
a = ‘’‘hello
world’’’
我用的编辑器是Sublime Text3，这是一个富文本编辑器，非常好用，也可以直接码字，而且支持多种语言的编译，推荐给大家。
不知道怎么使用或者设置的可以去公众号问我。
##以上就是本节的全部内容，后续内容会逐渐上传，相关源码也会统一上传，也可以到公众号私聊我要。
##本节内容已上传博客，请查看。
https://blog.csdn.net/weixin_44936771/article/details/107954654
##不足之处请及时指出，相互学习
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b30d245ebab11bd9dbf2833a9c4352cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02084390da3153ab903726361462fee0/" rel="bookmark">
			抗侧力构件弹性位移如何计算_穿心棒法盖梁施工计算书(工字钢)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		托担法盖梁施工计算书
一、工程概况
盖梁设计尺寸：
双柱式盖梁设计为长11.95m，宽2.1m，高1.6m，混凝土方量为38.35方，两柱中心距6.95m。盖梁如图所示
二、施工方案
1)预留孔：立柱施工时测好预留孔的标高位置，预埋直径110mm硬质PVC管，较高立柱根据高差来进行标高调整，保证两预留孔处于同一个标高，施工时把有关主筋间距和上下层箍筋间距作微调；
2)插入钢棒：柱顶插入一根直径为9cm，长度为300cm的钢棒，作为主梁工字钢支撑点，钢棒外伸长度一致；
3)安装固定装置和机械式千斤顶。
4)吊装主梁工字钢，利用φ25精轧螺纹钢，夹紧主梁工字钢，上铺I12.6工字钢作为分配梁；
5)拆除钢棒，封堵预留孔：盖梁施工完成后把预留孔用细石混凝土封堵。
三、受力计算
1、设计参数
1)I12.6工字钢
截面面积为：A=1810mm2
截面抵抗矩：W=77×103mm3
截面惯性矩：I=488×104mm4
弹性模量E=2.1×105Mpa
钢材采用Q235钢，抗拉、抗压、抗弯强度设计值［σ］=215Mpa。
2)主梁工字钢
横向主梁采用2片45b工字钢。
截面面积为：A=11100mm2
截面抵抗矩：W=1500×103mm3
截面惯性矩：I=33760×104mm4
弹性模量E=2.1×105Mpa
3)钢棒
钢棒采用φ90mm高强钢棒(A45)，
截面面积为：A=3.14×452=6362mm2，
抗剪强度设计值［τ］=125Mpa。
2、荷载计算
1) 混凝土自重荷载(考虑立柱混凝土重量)
W1=38.35×26=444.3kN；
2)支架、模板荷载
A、2片I45b组成主梁,长12m，纵向工字钢长4.5m，间距30cm。
W2=12×0.874×2+0.142×4.5×(11/0.3)=54.3kN；
B、定型钢模板,重量由厂家设计图查询得到。
W3=6800×10=68kN；
3)施工人员、机械重量。
按每平米1kN，则该荷载为：
W4=12×2×1=24kN；
4)振捣器产生的振动力。
盖梁施工采用50型插入式振动器,设置3台,每台振动力2kN。
施工时振动力:W5=2×3=6kN；
总荷载：W=W1+1 W2+ W3+ W4+ W5=1153.4kN
5)荷载集度计算
横桥向均布荷载集度：q h=W/12=96.1kN/m；
顺桥向荷载集度取跨中部分计算：qz= q h/1.8=96.1/1.8=53.4kN/m
2、强度、刚度计算
1) I12.6工字钢强度验算
取盖梁跨中横向一米段对I12.6工字钢进行计算，其中横向一米荷载共有3根I12.6工字钢承担，顺桥向荷载集度：53.4kN/m，每一根承担17.8 kN/m
计算模型
弯矩图(单位：kN·m)
剪力图(单位：kN)
位移图(单位：m)
其中最大弯矩为：M=6.2kN·m，最大剪力为：Q=12.6kN
根据应力公式可以得出最大拉应力：
σ=M/Wx=6.2×1000/77×10-6=80.5MPa 根据剪应力公式可以得出剪切应力：
τ=Q/A=12.6×1000/18.1×10-4=6.96MPa 跨中位移f=0.002m
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/02084390da3153ab903726361462fee0/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/403/">«</a>
	<span class="pagination__item pagination__item--current">404/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/405/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>