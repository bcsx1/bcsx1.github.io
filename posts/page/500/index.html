<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/abfef9e5bd3d0f7e2a6de57b472125d0/" rel="bookmark">
			Java  byte 转化为 String
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、Java 中 byte 转化为 String，代码如下
package nice.com.mian; import java.io.UnsupportedEncodingException; public class StringMain { public static void main(String[] args) throws Exception { byte[] bb = {97,99,105,51,55}; String str = new String(bb, "utf-8"); System.out.println(str); } } 输出如下
2、String 转化为 byte ，代码如下
package nice.com.mian; import java.io.UnsupportedEncodingException; public class StringMain { public static void main(String[] args) throws Exception { String str = "afvg123"; byte[] bb = str.getBytes(); for(byte b : bb){ System.out.println(b); } } } 输出如下
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aec4e3a52a6e356279b887f78b90cde1/" rel="bookmark">
			格密码学习笔记（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		格密码学习笔记（一） \qquad 随着当下量子计算机的研制的迅速进展，量子算法亦是相应得以巨大突破。在量子计算模型下，经典数论假设的密码体系（如大整数分解，计算有限域/椭圆曲线上的离散对数问题等），存在多项式时间（PPT）的量子算法，换而言之，经典数论密码体系受到了极大的冲击，将有可能成为旧时代的眼泪。因此，能够抵抗量子计算机攻击的密码——“后量子”或“抗量子”密码便应运而生。
\qquad 目前, 用于构建后量子密码系统的常见数学技巧包括：
1.杂凑函数,多变量方程(在构造签名方案时较有优势)
2.纠错码(更合适构造加密方案)
3.格(最通用的一类, 几乎所有经典密码概念都可以在格密码中实现)
4.超奇异椭圆曲线同源问题(当下较新的一类, 目前其中较受关注的有密钥交换和签名方案的构造,计算效率很低,还达不到实用性的要求)
一．格密码的基本概念： I．根据向量空间的概念，格的定义如下:
\qquad 设 v 1 , … , v n ∈ R m , v_1,\dots,v_n\in{R^m}, v1​,…,vn​∈Rm,为一组线性无关的向量。由 v 1 , … , v n v_1,\dots,v_n v1​,…,vn​生成的格 L L L指的是向量 v 1 , … , v n v_1,\dots,v_n v1​,…,vn​的线性组合构成的向量集合，且其所使用的系数均在 Z n Z^n Zn中，即
L = { a 1 v 1 + a 2 v 2 + ⋯ + a n v n : a 1 , a 2 , … , a n ∈ Z } \qquad\qquad L=\{a_1v_1+a_2v_2+\dots+a_nv_n:a_1,a_2,\dots,a_n\in{Z}\} L={a1​v1​+a2​v2​+⋯+an​vn​:a1​,a2​,…,an​∈Z}
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aec4e3a52a6e356279b887f78b90cde1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44ee34c1f24ef6de8bd9702a0f2f420c/" rel="bookmark">
			Git - 查看提交历史
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文讲解使用 git 等工具查看提交历史的几种方式。
git log 在我理解中，实际上后面讲的各种方法都是基于 git log 命令行工具，且对于程序员而言，命令行才是正统；
默认不用任何参数的话，git log 会按提交时间列出所有的更新，最近的更新排在最上面。每次更新都有一个 SHA-1 校验和、作者的名字和电子邮件地址、提交时间，最后缩进一个段落显示提交说明。git log 命令行会默认打开一个 vim 编辑器，输入 :q 退出查看。
常用选项
-p 选项展开显示每次提交的内容差异；
-2 则仅显示最近的两次更新；
--word-diff 选项。可以将其添加到 git log -p 命令的后面，从而获取单词层面上的对比。在书籍、论文这种很大的文本文件上进行对比的时候；
--stat，仅显示简要的增改行数统计；
作者（author）和提交者（committer）的差别，作者指的是实际作出修改的人，提交者指的是最后将此工作成果提交到仓库的人。所以，当你为某个项目发布补丁，然后某个核心成员将你的补丁并入项目时，你就是作者，而那个核心成员就是提交者。
示例
查看 Git 仓库中，2018 年 9 月期间，Junio Hamano 提交的但未合并的测试脚本（位于项目的 t/ 目录下的文件），命令：
git log --pretty="%h - %s" --author=gitster --since="2018-09-01" --before="2018-09-30" --no-merges -- t/
git log -p -2
选项除了显示基本信息之外，还在附带每次 commit 的变化。常用于代码审查，或者快速浏览某个搭档提交的 commit 的变化。
git log -U1 --word-diff
这里并没有平常看到的添加行或者删除行的信息。这里的对比显示在行间。新增加的单词被 {+ +} 括起来，被删除的单词被 [- -] 括起来。在进行单词层面的对比的时候，你可能希望上下文（ context ）行数从默认的 3 行，减为 1 行，那么可以使用 -U1 选项。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44ee34c1f24ef6de8bd9702a0f2f420c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c4721d30371740314396466b836c5fc/" rel="bookmark">
			System.currentTimeMillis()计算方式与时间的单位转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、时间的单位转换
1秒=1000毫秒(ms) 1毫秒=1／1,000秒(s) 1秒=1,000,000 微秒(μs) 1微秒=1／1,000,000秒(s) 1秒=1,000,000,000 纳秒(ns) 1纳秒=1／1,000,000,000秒(s) 1秒=1,000,000,000,000 皮秒(ps) 1皮秒=1／1,000,000,000,000秒(s) 1分钟=60秒 1小时=60分钟=3600秒 二、System.currentTimeMillis()计算方式
在开发过程中，通常很多人都习惯使用new Date()来获取当前时间。new Date()所做的事情其实就是调用了System.currentTimeMillis()。如果仅仅是需要或者毫秒数，那么完全可以使用System.currentTimeMillis()去代替new Date()，效率上会高一点。如果需要在同一个方法里面多次使用new Date()，通常性能就是这样一点一点地消耗掉，这里其实可以声明一个引用。
//获得系统的时间，单位为毫秒,转换为妙 long totalMilliSeconds = System.currentTimeMillis(); long totalSeconds = totalMilliSeconds / 1000; //求出现在的秒 long currentSecond = totalSeconds % 60; //求出现在的分 long totalMinutes = totalSeconds / 60; long currentMinute = totalMinutes % 60; //求出现在的小时 long totalHour = totalMinutes / 60; long currentHour = totalHour % 24; //显示时间 System.out.println("总毫秒为： " + totalMilliSeconds); System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c4721d30371740314396466b836c5fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b29d2f1dfde3c0497d36422a62f8f64e/" rel="bookmark">
			安装Jebel激活服务器(Docker方式)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装Docker 1. 如果安装过旧版的docker（旧版的docker包叫做docker，新版的叫做docker-ce）, 如果没安装过可以跳过
sudo apt-get remove docker docker-engine docker.io 2. 更新Ubuntu的软件源：
sudo apt-get update 3. 因为安装时下载软件包是通过https协议，所以需要安装相关的包:
sudo apt-get install apt-transport-https ca-certificates curl software-properties-common 4. 添加docker官方GPG key：
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - 5. 查看KEY是否安装成功：
sudo apt-key fingerprint 0EBFCD88 正常情况下会输出类似下方的内容
pub rsa4096 2017-02-22 [SCEA] 9DC8 5822 9FC7 DD38 854A E2D8 8D81 803C 0EBF CD88 uid [ unknown] Docker Release (CE deb) &lt;docker@docker.com&gt; sub rsa4096 2017-02-22 [S] 6. 设置stable版本的仓库（一个季度发布一次）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b29d2f1dfde3c0497d36422a62f8f64e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b66af26c9020f7d2e2d154c8a451501/" rel="bookmark">
			C语言 | 内存总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1024G 嵌入式资源大放送！包括但不限于C/C++、单片机、Linux等。关注微信公众号【嵌入式大杂烩】，回复1024，即可免费获取！
C语言程序需要载入内存才可以运行，其不同的数据保存在不同的区域。所使用的内存可以分成两类：一类是静态存储区，另一类是动态存储区。C语言程序的存储区如下图所示：
1静态存储区
静态存储区分为三类：只读数据区（RO Data）、已初始化读写数据区（RW Data）、未初始化读写读写数据区（BSS）。这三类存储区都是在程序的编译-连接阶段确定的，且运行过程中是不会变化的，只有当程序退出的时候，静态存储区的内存才会被系统回收。
2动态存储区
动态存储区主要分为两类：一类是栈（Stack）内存区域，栈内存是由编译器管理的；另一类是堆（Heap）内存区域，堆内存由程序调用具体的库函数来分配的。它们都是程序运行过程中动态分配的。
2.1栈内存区域
2.1.1栈的相关概念
栈内存的使用很大的程度上依赖于处理器的硬件机制。在处理器中，有一个寄存器来表示当前栈指针的位置。通常在内存中分配一块区域，这块区域的上界（高内存地址）和下界（低内存地址）之间是可用的栈内存区域。栈内存如下图所示：
目前常见的体系结构和编译系统中，栈大多都是向下增长的。在初始阶段，栈指针是指向栈区间的上界，随着栈使用量的增加，栈指针的值向低地址移动，即栈指针的值将变小。下面来看一段程序：
#include &lt;stdio.h&gt; int main(void) { int a = 1, b = 2, c = 3; printf("a = %d, &amp;a = %#x \n", a, (unsigned int)&amp;a); printf("b = %d, &amp;b = %#x \n", b, (unsigned int)&amp;b); printf("c = %d, &amp;c = %#x \n", c, (unsigned int)&amp;c); return 0; } 程序运行结果为：
可见，变量的存储是从高地址往低地址的方向存储。
栈有一个重要的特性：先放入的数据最后才能取出，后放入的数据优先能取出，即先进后出（First In Last Out）原则。放入数据常被称为入栈或压栈（Push），取出数据被称为出栈或弹出（Pop）。在运用过程中，栈内存可能出现满栈和空栈两种情况，这是由处理器的体系结构决定的。
栈（Stack）可以存放函数参数、局部变量、局部数组等作用范围在函数内部的数据，它的用途就是完成函数的调用。
2.1.1需要知道的关于栈的问题：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b66af26c9020f7d2e2d154c8a451501/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d73e2c4e1a405954cd161bec990d930/" rel="bookmark">
			前端进阶系列(七):什么是执行上下文？什么是调用栈？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文作者：Valentino 原文链接：https://www.valentinog.com/blog/js-execution-context-call-stack 什么是Javascript中的执行上下文？ 我打赌你不知道答案。
编程语言中最基础的组成部分是什么？
变量和函数对吗？每个人都可以学习这些板块。
但除了基础知识之外还有什么？
在称自己为中级（甚至是高级）Javascript开发人员之前，你应该掌握的Javascript的核心是什么？
有很多：Scope(作用域)、Closure(闭包)、Callbacks(回调)、Prototype(原型)等等。
但在深入研究这些概念之前，您至少应该了解Javascript引擎的工作原理。
在这篇文章中，我们将介绍每个Javascript引擎的两个基本部分：执行上下文和调用堆栈。
（不要害怕。它比你想象的容易）。
准备好了吗？
目录
你会学到什么？Javascript如何执行您的代码？Javascript引擎它是如何工作的？全局存储器？什么是调用栈？什么是局部执行上下文？总结 你会学到什么？ 在这篇文章中你将学到：
Javascript引擎是如何工作的？Javascript中执行上下文什么是调用栈全局执行上下文和局部执行上下文之间的区别 Javascript如何执行您的代码? 通过查看Javascript内部功能，您将成为更好的Javascript开发人员，即使您无法掌握每一个细节。
现在，看看下面的代码：
var num = 2; function pow(num) { return num * num; } 现在告诉我：你认为在浏览器里以何种顺序执行这段代码？
换句话说，如果您是浏览器，您将如何阅读该代码？
这听起来很简单。
大多数人认为“是的，浏览器执行功能pow并返回结果，然后将2分配给num。”
在接下来的部分中，您将发现那些看似简单的代码行背后的机制。
Javascript引擎 要了解Javascript如何运行您的代码，我们应该遇到第一件可怕的事情：
执行上下文
在Javascript中什么是执行上下文？
每次在浏览器（或Node）中运行Javascript时，引擎都会执行一系列步骤。
其中一个步骤涉及创建全局执行上下文。
什么是引擎？
也就是说，Javascript引擎是运行Javascript代码的“引擎”。
如今有两个突出的Javascript引擎：Google V8和SpiderMonkey。
V8是Google开源的Javascript引擎，在Google Chrome和Nodejs中使用。
SpiderMonkey是Mozilla的JavaScript引擎，用于Firefox。
到目前为止，我们有Javascript引擎和执行上下文。
现在是时候了解它们如何协同工作了。
它是如何工作的？ 每次运行一些Javascript代码是，引擎都会创造一个全局执行上下文。
执行上下文是一个比喻的词，用于描述运行Javascript代码的环境。
我觉得你很难想象出这些抽象的东西。
现在将全局执行上下文视为一个框：
让我们再看看我们的代码：
var num = 2; function pow(num) { return num * num; } 引擎如何读取该代码？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d73e2c4e1a405954cd161bec990d930/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/960ef75b42f2af61e90b1c8c975d19f8/" rel="bookmark">
			创业服务资源获取的途径有哪些？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		创业服务资源获取的途径有哪些？
创业者关注的更多是自身的资源从哪里积累，怎么样积累，需要哪些方法和技能等等，因为资源对初创企业来说是很重要的一部分，创成汇作为专业的创业者服务平台，以创新创业成果转化为服务方向的平台，有效的整合创业资源，能够为创业者搭建良好的创业服务资源对接，一直在专注做一件事。
创业资源获取来自两个方面，一是自有资源，二是外部资源。
1.自有资源主要指创业者/团队自身拥有的、可用于创业的资金、技术、创业机会信息、自建的营销网络、控制的物质资源或管理才能、管理组织等。自有资源可以通过内部培育和开发，企业通过一定的方式在内部开发无形资产、培训员工以及促进内部学习等获取有益的资源。
外部资源则包括亲朋好友、同学、同事、商务伙伴或其他投资者的社会关系及其资源，或者能够借用的人、财、空间、设备或其他原材料等。比如创成汇为创业者提供创赛，创投，资本，品宣，政讯查询，资源等等创业重要资源服务，入驻优质的投资人，孵化器、众创空间、服务资源等产业链服务平台。
获取外部资源的关键在于拥有资源使用权或能控制和影响资源配置。对于特定的创业资源，应当根据创业项目及创业者/团队的实际情况综合考虑获取方法，包括多管齐下。
创业资源获取的关键往往取决于软实力。无形资源往往是撬动有形资源的重要杠杆。
2．创业资源获取的技能
（1）知人善任技能。
（2）合作技能。
（3）沟通技能。 （4）杠杆技能。
（5）信息获取与利用技能。
创成汇-创业者服务平台，更懂创业的艰苦，与需求，通过高效的资源匹配，为创业者助力创业项目落地扶持，优质赛事活动，国内众创空间、孵化器优惠入驻，解决创业者场地难题。注册创成汇：www.chuangcheng.org.cn/304，获取注册福利，创成汇用专业为创业者保驾护航。
创业者服务咨询联系：13828846181
转载于:https://juejin.im/post/5bc009d1f265da0a8f35e739
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d1978cb1b4f97a22f5eb83bb6d95fcb/" rel="bookmark">
			matlab中exist函数用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		exist有两种形式，一个参数和两个参数的，都是用来确定某个值（对象）是否存在
1. r = exist( a)
若 a 存在，则 r = 1； 否则 r = 0；
2. r = exist( 'name', 'kind')
name 可以是变量名，函数名、m 文件名、mex 文件、dll 文件、内嵌的函数、p码文件、目录、路径、Java class
kind可以是 ：builtin 内嵌函数、class Java class、dir 目录、file 文件或者目录、var 变量
exist name
等价于 r=exist(name) A = exist('name','kind')
返回值的含义如下：
0 不存在则返回值
1 name 可以是变量名，如果存在，返回值
2 函数名、m 文件名，存在则返回值
3 mex 文件、dll 文件，存在则返回值
4 内嵌的函数，存在则返回值
5 p码文件 ， 存在则返回值
6 目录，存在则返回值
7 路径，存在则返回值
8 Java class，存在则返回值
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d1978cb1b4f97a22f5eb83bb6d95fcb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4f66cbcfeb1c14973c04856a2d17caf/" rel="bookmark">
			babel 修改抽象语法树——入门与实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题由来 最近有个想法，之前用Angular2.x 的时候，官方提供了ng-cli 可以一键生成component、service、directive 等代码文件，并且还可以修改对应的routes 配置文件，使得组件自动加入app 的前端路由中（一键生成或修改数个文件）。这使得前端开发效率大为提高，我们不必再手动去创建那么多文件夹、文件，并且手动修改route 配置。但是vue-cli 没有提供这种功能，所以我们想要写个node.js 脚本去做这个工作。除了用正则替换的解决办法，更科学的实际上就需要用到修改代码抽象语法树的方法。
babel 编译过程 我们通常用 babel 去编译ES6/ES7 为ES5，以便于 js 脚本运行在各种浏览器上。这个编译的过程实际上是语法转换的过程，比如箭头函数转为函数表达式，this 的显式绑定等等。那么babel 在做这个工作的时候实际上经历了几个步骤，parse =&gt; transform (AST) =&gt; generate
所以要想完成这几个步骤，babel 提供了几个实用工具（Babylon，babel-traverse，babel-generator），我们的思路就是找到route 配置表中该插入新路由的地方，插入新路由并且保存文件。 babel.transform 核心函数接受源代码字符串和options 作为输入，返回一个Object 包含几个属性：新的代码字符串，sourcemap，ast 语法树对象。
babel.transform("code();", options, function(err, result) { result.code; result.map; result.ast; }); 复制代码 实践新增一个route对象 以下是等待修改的路由配置文件，
// './src/router.ts' export default new Router({ routes: [ { path: '/', name: 'home', component: Home }, { path: '/about', name: 'about', component: About } // to be append new route.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f4f66cbcfeb1c14973c04856a2d17caf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee98f4c56e7c6cb53e2a939ef32ebd24/" rel="bookmark">
			Delphi 截取后台运行程序的图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		function PrintWindow(SourceWindow: hwnd; Destination: hdc; nFlags: cardinal): bool; stdcall; external ‘user32.dll’ name ‘PrintWindow’;
procedure TForm1.btn1Click(Sender: TObject);
var
bmp : TBitmap;
wnd : cardinal;
rec : TRect;
begin
wnd := FindWindow(nil, ‘计算器’); // 查找窗口句柄，这里用计算器演示
GetWindowRect(wnd, rec); //获取到计算器窗口的矩形坐标
bmp := TBitmap.Create;
try
bmp.Width := rec.Right - rec.Left;
bmp.Height := rec.Bottom - rec.Top;
bmp.PixelFormat := pf24bit;
PrintWindow(wnd, bmp.Canvas.Handle, 0);
bmp.SaveToFile(‘test.bmp’);
finally
bmp.Free;
end;
end;
转载：https://www.xuebuyuan.com/486235.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66d91287d6c70065915cee32027dbaaf/" rel="bookmark">
			R - 【解决Error in source(file.path) :    invalid multibyte character in parser at line *】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 【问题描述】：在使用source函数导入自建函数时报错： Error in source(file.path(code_path, "f_recode_bad_1.R")) : invalid multibyte character in parser at line 10
【解决办法】：添加参数 【encoding = "utf-8"】
如下：
source(file.path(code_path,"f_recode_bad_1.R"), encoding = "utf-8") 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5466def6f777d554d04f02915b5bc1fd/" rel="bookmark">
			php 中奖概率算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上次项目中有个抽奖活动,中奖概率算法整理成一篇笔记
/** * 中奖概率算法 * v表示中奖概率,注意其中的v必须为整数,可以将对应的奖项的v设置成0，即意味着该奖项抽中的几率是0，数组中v的总和（基数），基数越大越能体现概率的准确性。本例中v的总和为100，那么 特等奖 对应的中奖概率就是1%，如果v的总和是10000，那中奖概率就是万分之一。 * * $arr = array( array('id'=&gt;1,'name'=&gt;'特等奖','v'=&gt;1), array('id'=&gt;2,'name'=&gt;'一等奖','v'=&gt;5), array('id'=&gt;3,'name'=&gt;'二等奖','v'=&gt;10), array('id'=&gt;4,'name'=&gt;'三等奖','v'=&gt;12), array('id'=&gt;5,'name'=&gt;'四等奖','v'=&gt;22), array('id'=&gt;6,'name'=&gt;'没中奖','v'=&gt;50) ); * */ if (!function_exists("lottery_arithmetic")){ function lottery_arithmetic($status) { $proArr = []; switch ($status){ case 1: //普通中奖 $proArr = array( array('id'=&gt;1,'name'=&gt;'一等奖','v'=&gt;1), //百分之十 array('id'=&gt;2,'name'=&gt;'二等奖','v'=&gt;3), array('id'=&gt;3,'name'=&gt;'二等奖','v'=&gt;3), array('id'=&gt;4,'name'=&gt;'二等奖','v'=&gt;4), array('id'=&gt;5,'name'=&gt;'二等奖','v'=&gt;4), array('id'=&gt;6,'name'=&gt;'三等奖','v'=&gt;30), array('id'=&gt;7,'name'=&gt;'三等奖','v'=&gt;20), array('id'=&gt;8,'name'=&gt;'三等奖','v'=&gt;20), array('id'=&gt;9,'name'=&gt;'三等奖','v'=&gt;20), ); break; case 2: //一定中奖 $proArr = array( array('id'=&gt;1,'name'=&gt;'一等奖','v'=&gt;1), //百分之十 array('id'=&gt;2,'name'=&gt;'二等奖','v'=&gt;3), array('id'=&gt;3,'name'=&gt;'二等奖','v'=&gt;3), array('id'=&gt;4,'name'=&gt;'二等奖','v'=&gt;4), array('id'=&gt;5,'name'=&gt;'二等奖','v'=&gt;4), array('id'=&gt;6,'name'=&gt;'三等奖','v'=&gt;30), array('id'=&gt;7,'name'=&gt;'三等奖','v'=&gt;20), array('id'=&gt;8,'name'=&gt;'三等奖','v'=&gt;20), array('id'=&gt;9,'name'=&gt;'三等奖','v'=&gt;20), ); break; default: } $result = array(); $arr = []; foreach ($proArr as $key =&gt; $val) { $arr[$key] = $val['v']; } // 概率数组的总概率「为100」 $proSum = array_sum($arr); asort($arr);// 根据键值对数组进行升序排序 // 概率数组循环 foreach ($arr as $k =&gt; $v) { $randNum = mt_rand(1, $proSum); // 在 1和 总权重 之间返回随机整数 if ($randNum &lt;= $v) { $result = $proArr[$k]; break; } else { $proSum -= $v; } } return $result; } } 使用示例
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5466def6f777d554d04f02915b5bc1fd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85c9612d95bebe34c9a9d8684987fd0e/" rel="bookmark">
			如何使用python进行常规方程求解(Sympy or Scipy)（非线性方程组，一元二次方程，多元一次方程，因式分解等）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在科学计算中，我们经常会遇到数值计算，可能遇到高数，线性代数等，在实际的解题中可能会比较麻烦，可能还会出错，这里就对于python在科学计算中对线性方程组，做一简单介绍。
在使用python进行线性方程组求解的时候，需要您去安装相应的程序包，scipy或者sympy，其官方文档分别为https://www.scipy.org/、https://docs.sympy.org/latest/index.html。
scipy非线性方程组求解 求解线性方程组比较简单，只需要用到一个函数(scipy.linalg.solve)就可以了。比如我们要求以下方程的解，这是一个非齐次线性方程组：
3 x 1 + x 2 − 2 x 3 = 5 x 1 − x 2 + 4 x 3 = − 2 2 x 1 + 3 x 3 = 2.5 3x_1+x_2-2x_3=5\\x_1-x_2+4x_3=-2\\2x_1+3x_3=2.5 3x1​+x2​−2x3​=5x1​−x2​+4x3​=−22x1​+3x3​=2.5
程序代码：
import numpy as np from scipy.linalg import solve #输出系数矩阵 a=np.array([[3,1,-2],[1,-1,4],[2,0,3]]) #值 b=np.array([5,-2,2.5]) #计算 x=solve(a,b) #打印结果 print(x) 结果：
[0.5 4.5 0.5] [Finished in 1.2s] sympy 数学方程求解 SymPy是比较强大的，可以做到符号的化简，求值等。SymPy是符号数学的Python库。它的目标是成为一个全功能的计算机代数系统，同时保持代码简洁、易于理解和扩展。 SymPy完全是用Python写的，并不需要外部的库。
可以做到先设置变量，然后打印不需要设置值的功能，例如：在我们日常书写中print(x+y)是会报错的，然而使用了如下就不会报错了：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/85c9612d95bebe34c9a9d8684987fd0e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6d1d684dcaba16cf6a45e3e79c4831a/" rel="bookmark">
			IDEA使用jfinal开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介：JFinal 是基于 Java 语言的极速 WEB + ORM 框架，其核心设计目标是开发迅速、代码量少、学习简单、功能强大、轻量级、易扩展
过程：
1） 创建一个maven工程
file–&gt;project
maven–&gt;next
GroupID:com.jfinal
Artifactld:jfinal_demo
next====&gt;
2)配置 pom.xml 文件
主要需要 jfinal的jar文件和log4j.jar
&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.jfinal&lt;/groupId&gt; &lt;artifactId&gt;jfinal&lt;/artifactId&gt; &lt;version&gt;3.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.jfinal&lt;/groupId&gt; &lt;artifactId&gt;jetty-server&lt;/artifactId&gt; &lt;version&gt;2018.11&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.16&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 新建一个config.class 继承 jfinalConfig
新建一个Action，继承Controller
4）配置web.xml
5）使用jfinal自带的方式启动
public static void main(String[] args) { // eclipse 下的启动方式 JFinal.start("src/main/webapp", 80, "/", 5); } 成功！
访问路由成功
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4969fef8b9a2f29fd1821ef48724f94a/" rel="bookmark">
			python实现录音功能，可随时停止录音
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		# -*- coding: utf-8 -*- """ Created on Thu Oct 11 15:44:09 2018 @author: zhangxinchun """ # -*- coding: utf-8 -*- import pyaudio import time import threading import wave import os import msvcrt class Recorder(): def __init__(self, chunk=1024, channels=1, rate=64000): self.CHUNK = chunk self.FORMAT = pyaudio.paInt16 self.CHANNELS = channels self.RATE = rate self._running = True self._frames = [] def start(self): threading._start_new_thread(self.__recording, ()) def __recording(self): self._running = True self._frames = [] p = pyaudio.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4969fef8b9a2f29fd1821ef48724f94a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d153d1527fc6ab12913353d521fcc518/" rel="bookmark">
			在Ubuntu下使用visual studio code 使用LaTeX,中文支持的配置教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Latex的排版总是很好,用习惯了之后还是很喜欢的,现在就总结网上的教程结合自己的实验,来介绍如何配置Ubuntu下的visual studio code的latex中文支持环境.
首先,我们在命令窗口下安装一些东西.下面这0部分的内容来自Ubuntu下Latex安装及中文配置
0 安装LaTex环境
0.1.sudo apt-get install texlive-latex-base 这样就安装好Latex了，可以直接使用。 0.2.sudo apt-get install latex-cjk-all 这样就可以使用中文环境了。 0.3.sudo apt-get install texlive-latex-extra 完成上面的这三步，就可以完全满足我平时的应用需求了。 0.4.sudo apt-get install texmaker 安装texmaker程序，它是一个图形化界面的Tex书写，编译，生成，预览集合为一体的程序。 与Windows操作系统中的WinTex界面很相似。 0.5.sudo apt-get install texlive-xetex 为了使用xelatex Texlive-publishers包也可以安装一下， support for publishers, theses, standards, conferences, etc. 0.6.sudo apt-get install texlive-publishers 使用apt-cache show texlive-publishers命令可以看到它所支持的CTAN包的信息 接下来我们在visual studio code中进行配置,
1.安装插件LaTeX Workshop
在插件栏搜索latex workshop,点击install就能够安装上插件了,
2.配置插件,使其支持中文
2.1首先进入到设置里面
2.2搜索latex-workshop.latex.recipes
2.3点击Edit in settings.json
在旁边的USER SETTINGS中填入下面的代码,
"latex-workshop.latex.recipes": [ { "name": "xelatex", "tools": [ "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d153d1527fc6ab12913353d521fcc518/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/871d857f0f381cc075b400dd15d0eca9/" rel="bookmark">
			定时备份数据脚本分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.配置文件备份脚本
1.区块链底层节点配置文件备份
2.数据库配置文件备份（my.cnf、redis.conf）
3.应用程序配置文件备份(springboort程序配置文件、tomcat程序配置文件)
以下是脚本分享：
#!/bin/bash dates="$(date +%Y%m%d)/" back_dir="/data/backup/$dates" port="22" user="root" PASSWD='123456' ##区块链底层节点配置文件备份## node_file="/usr/local/bubichain/config/*" node_conf=( 172.16.16.77:$node_file 172.16.16.66:$node_file 172.16.16.69:$node_file 172.16.16.15:$node_file ) for node in ${node_conf[@]} do node_ip=$(echo $node | awk -F: '{print $1}') if [ ! -d ${back_dir}/node/$node_ip ];then mkdir -p ${back_dir}/node/$node_ip fi ##bak备份文件失败,重新尝试次数3## net_status="`echo ""|telnet $node_ip $port 2&gt;/dev/null|grep "\^]"|wc -l`" if [ $net_status -eq 1 ];then sshpass -p $PASSWD scp -r -P $port $user@$node ${back_dir}/node/$node_ip if [ ! $? -eq 0 ];then echo "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/871d857f0f381cc075b400dd15d0eca9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72ac5668dfeeceb6ad8cbe6bf794e64a/" rel="bookmark">
			基于AX7020的petalinux生成并驱动液晶屏（071）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于AX7020的petalinux生成并驱动触摸屏（071） 环境 Ubuntu14.04、触摸屏AN071
vivado 2015.4、petalinux 2015.4、黑金 zynq 开发板 AX7010/AX7020
测试：QT5.6.2
过程目录 1、PC下安装vivado2015.4
2、PC下安装qt5.6.2，并且交叉编译qt5.6.2
3、PC下安装petalinux
4、基于触摸屏的vivado工程文档来生成petalinux
5、下载SD卡准备
介绍 本文是对alinx的官方文档的一个整合，并基于其他工程而生成的petalinux,并修改了官方文档的两个错误。
一个是顶层设备数代码的Bug
一个是配置内核的选择
备注 用Xilinx的交叉编译器（2017前）所编译的QT库对于debian文件系统是不支持的，在运行程序时会报“未发现文件”的错，即linaro之类的文件系统配上arm-xilinx-linux-gnueabi-gcc/g++都是不行的。
qt库的编译，使用Xilinx提供的编译器，而LINUX的根文件系统不是.
在后来，Xilinx为了解决这个问题，放弃了自己的编译器，这个在后来就是2017.4版本，Xilinx放弃自己的编译器，即没有arm-xilinx-linux-gnueabi-系列的.
1、PC下安装vivado2015.4 基本库安装
sudo su rm /bin/sh ln -s /bin/bash /bin/sh ls -al /bin/sh apt-get install lib32z1 lib32ncurses5 lib32bz2-1.0 lib32stdc++6 apt-get install iproute2:i386 apt-get install gawk:i386 apt-get install gcc apt-get install gcc:i386 apt-get install git:i386 apt-get install make:i386 apt-get install net-tools:i386 apt-get install libncurses5-dev:i386 apt-get install zlib1g-dev:i386 apt-get install libssl-dev:i386 apt-get install flex:i386 apt-get install bison:i386 apt-get install libselinux1:i386 apt-get install libncurses5 libncurses5-dev apt-get install libc6:i386 apt-get install libstdc++6:i386 apt-get install zlib1g:i386 apt-get install libssl-dev apt-get install tftpd tftp openbsd-inetd sudo tar -zxvf Xilinx_Vivado_SDK_2015.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/72ac5668dfeeceb6ad8cbe6bf794e64a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f1004b991099eea000de9501d72df43/" rel="bookmark">
			java文件下载做apk安装包下载，当下载类型为.apk时，用手机谷歌浏览器下载完后点击打开不能直接启动安装，而是打开压缩文件管理。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 java文件下载做apk安装包下载，当下载类型为.apk时，用手机谷歌浏览器下载完后点击打开不能直接启动安装，而是打开压缩文件管理。
uc浏览器可以正常，自带的谷歌不正常，解决方法为，在下载设置response的header中的Content-Type 为
application/vnd.android.package-archive
例如：
response.setHeader("content-type", "application/vnd.android.package-archive"); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/097c9d1f414e7acf2e455c774fc7a599/" rel="bookmark">
			计算机图形学作业2-1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实现矩阵栈：
class MatrixStack { public: MatrixStack(); void clear(); Matrix4f top(); void push( const Matrix4f&amp; m ); void pop(); private: std::vector&lt; Matrix4f &gt; m_matrices; }; #include "MatrixStack.h" //使用单位矩阵初始化矩阵栈 MatrixStack::MatrixStack() { Matrix4f matrix4f; m_matrices.push_back(matrix4f.identity()); } //还原到只包含单位矩阵 //只需要把vector里面的数据都清空即可，用clear方法 void MatrixStack::clear() { m_matrices.clear(); Matrix4f matrix4f; m_matrices.push_back(matrix4f.identity()); } //还回矩阵栈的栈顶元素 Matrix4f MatrixStack::top() { Matrix4f vector_back=m_matrices.back(); return vector_back; } //把m放到栈里去 //你的堆栈应该有OpenGL语义: //新顶部应该是旧顶部乘以m void MatrixStack::push( const Matrix4f&amp; m ) { Matrix4f newTop=m_matrices.back()*m; m_matrices.push_back(newTop); } //把栈顶元素提出 void MatrixStack::pop() { m_matrices.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/097c9d1f414e7acf2e455c774fc7a599/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0648ffad065e6762a5b74a22d3fece8/" rel="bookmark">
			vector扩容原理说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		扩容原理概述 新增元素：Vector通过一个连续的数组存放元素，如果集合已满，在新增数据的时候，就要分配一块更大的内存，将原来的数据复制过来，释放之前的内存，在插入新增的元素；对vector的任何操作，一旦引起空间重新配置，指向原vector的所有迭代器就都失效了 ；初始时刻vector的capacity为0，塞入第一个元素后capacity增加为1；不同的编译器实现的扩容方式不一样，VS2015中以1.5倍扩容，GCC以2倍扩容。 GCC下测试 #include&lt;iostream&gt; #include&lt;vector&gt; using namespace std; int main() { vector&lt;int&gt; vec; cout &lt;&lt; vec.capacity() &lt;&lt; endl; for (int i = 0; i&lt;10; ++i) { vec.push_back(i); cout &lt;&lt; "size: " &lt;&lt; vec.size() &lt;&lt; endl; cout &lt;&lt; "capacity: " &lt;&lt; vec.capacity() &lt;&lt; endl; } return 0; } 输出结果：
从这里我认为vector的初始的扩容方式代价太大,初始扩容效率低， 需要频繁增长，不仅操作效率比较低，而且频繁的向操作系统申请内存容易造成过多的内存碎片，所以这个时候需要合理使用resize()和reserve()方法提高效率减少内存碎片的， resize() resize方法被用来改变vector中元素的数量，我们可以说，resize方法改变了容器的大小，且创建了容器中的对象；
如果resize中所指定的n小于vector中当前的元素数量，则会删除vector中多于n的元素，使vector得大小变为n；容量不会变（capacity）
如果所指定的n大于vector中当前的元素数量，小于capacity容量值，则会在vector当前的尾部插入适量的元素，使得vector的大小变为n，在这里，如果为resize方法指定了第二个参数，则会把第二个参数值初始化为该指定值，如果没有为resize指定第二个参数，则会初始化为默认的初始值 0；容量不会变（capacity）
如果resize所指定的n不仅大于vector中当前的元素数量，还大于vector当前的capacity容量值时，则会自动为vector重新分配存储空间； 容量会变（capacity）
当之前的size*2小于resize时，容量为resize的大小 当之前的size*2大于resize时，容量为size*2 #include&lt;iostream&gt; #include&lt;vector&gt; using namespace std; int main() { vector&lt;int&gt; vec; cout &lt;&lt; vec.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d0648ffad065e6762a5b74a22d3fece8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b08f0984e0b24cc3437fdd6e0de4c05f/" rel="bookmark">
			20. A *p＝NULL，p 可以调用 A 类里面的函数嘛？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们来观察一下：
#include&lt;iostream&gt; class A { public: A() { a = 5; } int a; void sum() { int b = 10; } }; int main() { A *pa = NULL; pa-&gt;sum();//问题这里，奇怪了为什么指针并没有new A,也就是说没有初始化，但是还可以执行函数sum（）呢? (就是说怎么还能找得到sun()函数的地址呢?) int aa = pa-&gt;a;//这个时候会出错误 找不到pa-&gt;a,这个是可以理解的。 system("pause"); return 0; } 问题：
1）为什么指针并没有new A,也就是说没有初始化，但是还可以执行函数sum（）呢? (就是说怎么还能找得到sun()函数的地址呢?)
这里问题很简单，因为函数在类里面是独立于类存在的，而且不占用类的空间，在程序编译的时候就已经把函数的地址分配好了，因此只要有这么一个对象，不管他指向NULL还是非NULL都是可以调用函数的，也不会出错。因此pa-&gt;sum()可以运行;
2）int aa = pa-&gt;a; // 为什么这个时候会出错误 找不到pa-&gt;a？。
但是这里就有问题了，pa就是NULL了，没有空间了，但是a是类的一个成员，没有空间的对象会有内部的a的存在？
“皮之不存，毛将焉附？”
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4dbc2673bf333923f4fa4d480ecebb3/" rel="bookmark">
			Eclipse:注释中文乱码解决方法总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Eclipse对导入的文件的编码支持不太好啊,直接说下自己的解决方法吧. 1 Window-&gt;preference-&gt;General-&gt;Content Types-&gt;Text
修改Eclipse的文件配置从这里面找到需要修改编码的文件类型,比如我的是properties 的文件有乱码,就找到java properties file,在最下面的一行default encoding 那里填上UTF- 8之后再点击右边的update. ok保存就行了.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7486c65b16be180fa8606ee8d12174f/" rel="bookmark">
			Pycharm 使用 Pipenv 新建的虚拟环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 什么是 Pycharm什么是 Pipenv如何在 Pycharm 中使用 Pipevn 生成的虚拟环境使用 Pipenv 生成虚拟环境使用 Pycharm 连接虚拟环境 什么是 Pycharm Pycharm 是目前最好用的 Python 编辑器，自带文本高亮、版本管理、数据库连接、断点调试、虚拟环境和包管理的多功能编辑器
什么是 Pipenv pipenv 是 Pipfile 主要倡导者、requests 作者 Kenneth Reitz 写的一个命令行工具，主要包含了Pipfile、pip、click、requests和virtualenv。Pipfile是社区拟定的依赖管理文件，用于替代过于简陋的 requirements.txt 文件。
如何在 Pycharm 中使用 Pipevn 生成的虚拟环境 使用 Pipenv 生成虚拟环境 命令行中进入项目目录，使用命令：
pipenv --python 3.6 #生成 python 3.6 版本的虚拟环境 pipenv --three #使用系统当前的 python3 版本生成虚拟环境 pipenv --venv #显示当前虚拟环境所用的解释器位置 使用 Pycharm 连接虚拟环境 打开 Pycharm ，点击 File - settings - Project 选择你要更改的环境
这里我们以 message_elctiricity 做为示范，选择后点击右侧齿轮图标，选择 add
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d7486c65b16be180fa8606ee8d12174f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74cc263edaf9c7ac67865623f9cf2a39/" rel="bookmark">
			用c语言实现简易贪吃蛇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们先分析游戏的功能需求：有一块区域，区域内有一条蛇和一个食物，蛇通过上下左右移动到达食物所在的点，蛇吃到食物，蛇长度增加，重新生成食物，分数增加，如果蛇头碰到自己的身体或者区域边界，游戏结束。否则，游戏继续。
我们用MVC的框架来实现它，即 Model——View——Controller： Model：定义和实现相关的结构体类型以及功能函数
View：定义和实现所有输出相关的函数
Controller：定义和实现游戏逻辑相关的函数，将Model和View中的函数联系起来
从Model中先开始看 首先，我们需要知道在贪吃蛇的游戏中，我们会用到哪些结构体，通过这些结构体，我们基本可以构造出一个贪吃蛇的游戏。这里先附上我贪吃蛇的游戏界面，方便构思：
通过这幅图，我们先来分析一波：在界面中出现的元素都有 蛇 食物 墙 分数 操作提示 分数排行榜。
现在，我们就需要将他们一一表示出来：
蛇：
1. 蛇的属性可以简单的分解为：蛇头，蛇尾，蛇前进的方向，蛇前进的速度。 2. 由于蛇是动态增长的，所以用链表的形式来保存，链表的每个节点都由一个数据域和一
个指针域组成。因此需要一个节点类型的变量。然后将这些变量连接起来形成链表。当贪吃
蛇吃食物变长时，为了减少时间复杂度，我们用链表的头当蛇的尾巴，链表的尾当蛇的头。
当蛇前进时，增加蛇头就等于链表的尾插，删除蛇尾就等于链表的头删，因此它的时间复杂
度都是为O(1)。
3. 在这里数据域是为了表示坐标，因此我们需要一个新的类型来表示坐标，这个类型包含
两个元素，即 X 和 Y。
4. 蛇前进的方向只有四种，即：上 下 左 右 因此，我们用枚举的方式来定义。
结合上面的四点，我们需要定义的结构体就有：
typedef enum Direction{ //方向 UP, DOWN, LEFT, RIGHT }Direction; typedef struct Position{	//节点的数据域 int x; int y; }Position; typedef struct Node{ //节点 Position pos; struct Node *next; }Node; typedef struct Snake{ //蛇的结构体 Node *head; Node *tail; int speed;	//我们通过Sleep函数来控制蛇的前进速度 Direction direction; }Snake; 食物 分数 分数排行榜：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/74cc263edaf9c7ac67865623f9cf2a39/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29ec1131dc0aa4a1f46b4bb6216e2afa/" rel="bookmark">
			牛客练习赛28 B【线段树&#43;区间和&#43;区间平方和&#43;区间修改】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		链接：https://www.nowcoder.com/acm/contest/200/B
来源：牛客网
题目描述 qn姐姐最好了~
qn姐姐给你了一个长度为n的序列还有m次操作让你玩，
1 l r 询问区间[l,r]内的元素和
2 l r 询问区间[l,r]内的元素的平方 和
3 l r x 将区间[l,r]内的每一个元素都乘上x
4 l r x 将区间[l,r]内的每一个元素都加上x
输入描述: 第一行两个数n,m 接下来一行n个数表示初始序列 就下来m行每行第一个数为操作方法opt， 若opt=1或者opt=2，则之后跟着两个数为l,r 若opt=3或者opt=4，则之后跟着三个数为l,r,x 操作意思为题目描述里说的 输出描述: 对于每一个操作1,2，输出一行表示答案 示例1
输入 5 6 1 2 3 4 5 1 1 5 2 1 5 3 1 2 1 4 1 3 2 1 1 4 2 2 3 输出 15 55 16 41 备注: 对于100%的数据 n=10000,m=200000 (注意是等于号) 保证所有询问的答案在long long 范围内 题解：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29ec1131dc0aa4a1f46b4bb6216e2afa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6bec97cd5f8b7d994f0582de86783381/" rel="bookmark">
			软件工程之软件质量管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		面向过程的软件开发过程，从计划到测试的整个过程，但是如何确保软件的质量呢？只要我们的软件质量过关才会得到用户的肯定，所以从质量这个角度看，我们该如何管理呢？
先总体了解下，从以下四方面入手
1.相关概念 2.软件质量的保证 3.软件的可靠性 4.软件配置管理 一、相关概念 1.软件质量的相关属性： 满足 功能要正确，运行可靠，使用方便，效率高，容易移植，可维护性和资源经济性
2.软件质量的保证 提出了不同的模型
Boehm模型
Mccall模型
Iso质量模型
3.软件质量的度量 二、软件质量保证 1.质量保证任务 用户要求定义，力争不重复劳动，掌握开发新软件的方法，组织外部力量协作的方法，排除无效劳动，发挥每个开发者的能力，提高开发软件的工程能力，提高计划和管理质量的能力。
2.软件质量保证体系 规定在项目的那个阶段进行评审及如何评审、规定在项目的那个阶段应当产生哪些报告和计划、规定产品方面测试应达到的水品、在每次评审和测试中发现的错误和如何修正。
3.保证实施 横向：需要明确的软件功能，应达到什么样的质量标准，即质量目标。
各个阶段进行检查和评价，评价时要有对质量进行度量的准则和方法。
纵向：要求所有与软件生存周期有关的人都要参加
要求对软件形成全过程的进行质量管理。
4.软件质量设计 Target：以用户要求和开发方针为依据，对质量需求准则、质量设计准则的各质量特性设定质量目标
Plan：设定适合于被开发软件的评测检查项目（质量评价标准）。研讨实现质量目标的方法或手段
Do：制作高质量的规格说明和程序，在接受质量检查前先做自我检查
Check：以Plan阶段设定的质量评价准则进行评价，计算结果用质量图的表示出来
Action：对评价发现的问题进行改进活动，如果实现达到了质量目标就转入下一个工程阶段。这样重复“Plan”到“Action”的过程。直到整个开发项目完成。
三、软件可靠性 相关定义： 1.故障（fault）软件内在的缺陷是固定存在的。
2.错误（error）故障在一定条件下产生暴露出来的迹象
3.失效（failure）对错误不做任何修改使得输出不满足用户需求
4.可靠性：软件在给定的时间间隔及给定的环境条件下按设计要求成功的运行程序的概率。
测试精度（AC）和测试覆盖率度（CV）的评价
四、软件的配置管理 概念：协调软件开发，使得变得更混乱减到最小的技术叫配置管理，它伴随软件的一生，比维护更加完善。
目标：标识变更，控制变更，确保变更正确的实现，向其他相关人员报告变更。
基线： 概念：是软件生存期中各个阶段末尾的特定点，又称里程碑。
软件的配置管理就是管理软件的总的生命周期的各个阶段的不断变化等。
总结 软件质量保证中，首先明白软件质量的相关知识，然后就是我们该怎么做去保证，当然需要我们测试来查看软件的质量，最后就是我们对软件变更的管理了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33404b08e9ccef81b09f9fb5a4ca5031/" rel="bookmark">
			解决Tomact启动时问题,Port 8080 required by Tomcat v8.0 Server at localhost is already in use. The server ma
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		相信做软件开发这个行业的,有时候不是你的程序代码出现了Bug,而是你的电脑也出现了一些千奇百怪的问题。
好了，我们来切入正题吧：看以下截图,然后小伙伴不要慌,
以下是解决方案:1.首先打开你的cmd命令(电脑按住Win+R键),然后在code里敲netstat -ano|findstr 8080或8005(哪个端口被占用，就输入哪个端口号,看我的截图是8080端口号,有些是设置8005端口号).
2.在资源管理器(Ctrl+alt+delete键)中找到PID码为2952的进程，结束进程。
然后在启动Tomact,就不会报此错误了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0676811ed1346d4b215926019c9a098b/" rel="bookmark">
			互信息（Mutual Information）的介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		版权声明：本文为博主原创文章，转载时请注明出处链接。 https://blog.csdn.net/lk7688535/article/details/52529610 概念 互信息，Mutual Information，缩写为MI，表示两个变量X与Y是否有关系，以及关系的强弱。
公式 我们定义互信息的公式为：
I(X,Y)=∫X∫YP(X,Y)logP(X,Y)P(X)P(Y)I(X,Y)=∫X∫YP(X,Y)log⁡P(X,Y)P(X)P(Y)
可以看出，如果X与Y独立，则P(X,Y)=P(X)P(Y)，I(X,Y)就为0，即代表X与Y不相关
解析公式 I(X;Y)=∫X∫YP(X,Y)logP(X,Y)P(X)P(Y)=∫X∫YP(X,Y)logP(X,Y)P(X)−∫X∫YP(X,Y)logP(Y)=∫X∫YP(X)P(Y|X)logP(Y|X)−∫YlogP(Y)∫XP(X,Y)=∫XP(X)∫YP(Y|X)logP(Y|X)−∫YlogP(Y)P(Y)=−∫XP(X)H(Y|X=x)+H(Y)=H(Y)−H(Y|X)I(X;Y)=∫X∫YP(X,Y)log⁡P(X,Y)P(X)P(Y)=∫X∫YP(X,Y)log⁡P(X,Y)P(X)−∫X∫YP(X,Y)log⁡P(Y)=∫X∫YP(X)P(Y|X)log⁡P(Y|X)−∫Ylog⁡P(Y)∫XP(X,Y)=∫XP(X)∫YP(Y|X)log⁡P(Y|X)−∫Ylog⁡P(Y)P(Y)=−∫XP(X)H(Y|X=x)+H(Y)=H(Y)−H(Y|X) Y的熵指的是衡量的是Y的不确定度，Y分布得越离散，H(Y)的值越高
H(Y|X)则表示在已知X的情况下，Y的不确定度
所以，根据互信息公式的变形： I(X,Y)=H(Y)−H(Y|X)I(X,Y)=H(Y)−H(Y|X) 可以看出，I(X,Y)可以解释为由X引入而使Y的不确定度减小的量，这个减小的量为H(Y|X)
所以，如果X,Y关系越密切，I(X,Y)就越大
I(X,Y)最大的取值是H(Y)H(Y)，此时H(Y|X)为0，意义为X和Y完全相关，在X确定的情况下Y是个定值，没有出现其他不确定情况的概率，所以为H(Y|X)为0
I(X,Y)取0时，代表X与Y独立，此时H(Y)=H(Y|X)，意义为X的出现不影响Y。。
性质 I(X;Y)I(X;Y)的性质： 1）I(X;Y)⩾0 ，I(X;Y)⩾0 2）H(X)−H(X|Y)=I(X;Y)=I(Y;X)=H(Y)−H(Y|X)H(X)−H(X|Y)=I(X;Y)=I(Y;X)=H(Y)−H(Y|X) 3）当X,Y独立时，I(X;Y)=0，I(X;Y)=0 4）当X,Y知道一个就能推断另一个时，I(X;Y)=H(X)=H(Y)
缺点 在做文本分类时，我们可能会判断一个词和某类的相关程度，但是计算时，未考虑词频的影响 （可以让互信息的结果再乘上tf-idf因子，从而将特征频率与特征分布考虑进去）
应用 1、文本自动摘要 2、两个词语同时出现的概率 PMI（点互信息），通过判断一个词分别与poor和excellent的互信息来判断这个词的情感倾向 3、特征提取时特征项与类别的关联程度 更多 http://www.docin.com/p-1061736680.html 一个互信息的文本摘要应用 http://www.cnblogs.com/ywl925/p/3736277.html
参考文献： http://www.fuzihao.org/blog/2015/01/17/%E4%BA%92%E4%BF%A1%E6%81%AF%E7%9A%84%E7%90%86%E8%A7%A3/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/673417d583ed6b7a65a3a804ca5ae572/" rel="bookmark">
			Mac报错:Error: The following directories are not writable by your user: /usr/local/share/man/man8 解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当我们用Homebrew安装应用时，会出现此问题，显示Homebrew无法访问这些位置并添加在OS X上为您安装软件所需的文件
对于上面问题，我们应尝试回收权限，解决方案如下：
首先打开终端，然后输入：
sudo chown -R `whoami`:admin /usr/local/bin
接着系统会提醒你输入密码,输入密码回车之后接着输入：
sudo chown -R `whoami`:admin /usr/local/share
之后就能在终端中用brew install 安装文件了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3bf03fe83a5de7a64b68cdcce5cf105a/" rel="bookmark">
			打印两个有序链表的公共部分-链表算法题系列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目： 给定两个有序链表的头指针head1，和head2，打印两个链表的公共部分.
难度系数：低
public class PrintCommonPart { /* 解题思路：链表的公共部分，其实就是两个链表重合的地部分。重合的情况有好几种， 1、完全重合。两个链表的首尾node都一样。 2、部分重合。呈一字型，也就是某个链表的尾部与另一个链表的前半部分有重合。 3、部分重合。呈Y字型，两个链表的尾部完全重合 这道题很简单，因为有序，所以就比较大小，小的指针往后移动。直到发现有指针为空到达尾部。 */ class Node{ public int value; public Node next; public Node(int data){ this.value = data; } public void printCommonPart(Node head1,Node head2){ while (head1.next != null &amp;&amp; head2.next != null){ if(head1.value &lt; head2.value){ head1 = head1.next; }else if(head1.value &gt; head2.value){ head2 = head2.next; }else { System.out.println(head1.value + " ");//打印公共部分 head1 = head1.next; head2 = head2.next; } } } } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35ae95a606cadedcec00b6049c862681/" rel="bookmark">
			sqlalchemy数据库操作增删改查
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		from sqlalchemy import create_engine from sqlalchemy.orm import sessionmaker,relationship, backref from sqlalchemy.ext.declarative import declarative_base from sqlalchemy import Column, Integer, String, ForeignKey engine = create_engine("mysql+pymysql://root:123qwe@192.168.0.50/test", encoding='utf-8') Base = declarative_base() #生成orm基类 class User(Base): __tablename__ = 'users' #表名 id = Column(Integer, primary_key=True) name = Column(String(32)) fullname = Column(String(64)) password = Column(String(64)) class Address(Base): __tablename__ = 'addresses' id = Column(Integer, primary_key=True) email_address = Column(String(128), nullable=False) user_id = Column(Integer, ForeignKey('users.id')) user = relationship('User', backref=backref('addresses', order_by=id)) Base.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/35ae95a606cadedcec00b6049c862681/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4585fc8008ac71d45e0d0ab0c30d2199/" rel="bookmark">
			jlink 突然无法识别芯片的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 jlink 突然无法识别芯片的问题 问题描述：
使用 jlink 调试时发现在一段时间的正常工作后，jlink 突然不能正常工作了。调试芯片 RT1052，主机－windows 7 旗舰版
解决流程 :
1. 检查板子上的电源是否接入，一定要确保使用电源供电。如果板子未接入电源就连接好 jlink，并将 jlink 的 usb 口接入到电脑上，这时，由 jlink 给板子供电，极容易烧坏 jlink 与开发板芯片。 2. 重新插入 jlink 的 usb 线，观察插入电脑后 jlink 上的指示灯是否变为绿灯。如果绿灯一直闪烁，这往往表明系统正在识别 jlink 固件，等待绿灯常亮即可。 3. 这之后首先检查线路的连接是否正确，板子上的引脚与 jlink 上的引脚连接是否正确。确认无误后，执行下一步检查。 4. 重新开启 gdb server，检查芯片名称与接口类型的选择是否正确，jlink 速率一般情况下不做检查，仅在特殊环境中检查。设置好后进行连接，通过观察连接面板中的输出来检查是否能够成功识别出芯片。这里要注意观察 jlink 的电压，电压一般都在 3.3v 左右，且能够保持稳定，不应有大幅度的波动。 5. 连接后发现仍然无法识别芯片，可以使用其他人的 jlink 排除 jlink 的硬件问题。这里要注意 jlink 与芯片是否连通，使用杜邦线或者排线连接时，多次插拔可能会造成电子线路不通，这要特别留意！之前可以用就轻易排除接线的问题，这是先入为主的观念在作怪。我们虽然很少会怀疑接线问题，但这种状况一旦真的发生，会让我们耗费大量的时间。预先检查一下连通性可能会让我们少走很多弯路。我们最好将这个步骤固定下来！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59cec8d9f0d011b0bea97ec2c6e5ac34/" rel="bookmark">
			微信小程序——返回上个页面带参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 当前页面：
var pages = getCurrentPages(); //当前页面 var prevPage = pages[pages.length - 2]; //上一页面 prevPage.setData({ //直接给上一个页面赋值 addresschose: that.data.address[index], }); wx.navigateBack({ //返回 delta: 1 }) 要跳转的页面：
onShow: function () { let pages = getCurrentPages(); let currPage = pages[pages.length - 1]; if (currPage.data.addresschose) { this.setData({ //将携带的参数赋值 address: currPage.data.addresschose, addressBack: true }); console.log(this.data.address, '地址') } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0b7db79a3a3d5aed6e1d5ec1f1046d2/" rel="bookmark">
			linux 多线程之信号量 sem_init
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 什么是信号量 linux sem 信号量是一种特殊的变量，访问具有原子性， 用于解决进程或线程间共享资源引发的同步问题。
用户态进程对 sem 信号量可以有以下两种操作：
等待信号量
当信号量值为 0 时，程序等待；当信号量值大于 0 时，信号量减 1，程序继续运行。发送信号量
将信号量值加 1 通过对信号量的控制，从而实现共享资源的顺序访问。
2. 相关函数说明 linux 信号量相关函数都声明头文件 semaphore.h 头文件中，所以使用信号量之前需要先包含头文件
#include &lt;semaphore.h&gt; 信号量的创建就像声明一般的变量一样简单，例如：sem_t sem，之后对该信号量进行初始化和使用。
2.1 sem_init 该函数用于创建信号量，其原型如下：
int sem_init(sem_t *sem, int pshared, unsigned int value); 该函数初始化由 sem 指向的信号对象，并给它一个初始的整数值 value。
pshared 控制信号量的类型，值为 0 代表该信号量用于多线程间的同步，值如果大于 0 表示可以共享，用于多个相关进程间的同步
参数 pshared &gt; 0 时指定了 sem 处于共享内存区域，所以可以在进程间共享该变量
2.2 sem_wait int sem_wait(sem_t *sem); int sem_trywait(sem_t *sem); sem_wait 是一个阻塞的函数，测试所指定信号量的值，它的操作是原子的。若 sem value &gt; 0，则该信号量值减去 1 并立即返回。若sem value = 0，则阻塞直到 sem value &gt; 0，此时立即减去 1，然后返回。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b0b7db79a3a3d5aed6e1d5ec1f1046d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/773b41dc2762ea415aaa53b929886bb6/" rel="bookmark">
			Lucy-Richardson算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		维纳滤波是频域的图像修复算法，而LR算法是时域的一种图像修复算法，LR算法基于贝叶斯理论，泊松分布和最大似然估计算法对图像进行修复。
以下公式及内容参考于论文：“基于 Lucy-Richardson 算法的头部运动模糊
CT 图像复原方法研究”
首先介绍贝叶斯理论：
连续贝叶斯公式：
离散贝叶斯：
那么贝叶斯公式要怎么应用于我们的LR算法呢？
接下来最大似然估计就得出场了，如果模糊图像g是由原始图像f得到，那么我们应该有p(f|g)的概率最大（这就是最大似然了），但是p(f|g)不好求啊怎么办呢？于是我们用贝叶斯进行迂回求解：
又由于p(f)与p(g)是常数，所以我们只需使得p(g|f)最大即可。
那p(g|f)最大怎么求呢？
这时就用到泊松统计模型了，泊松统计模型公式为：
这里u代表给定时间范围内事情发生的平均次数。
假定模糊图像中的各个像素点之间相互独立，根据泊松统计模型，则条件概率分布p(g|f)可用以下式子表示：
其中u=h(x,y)*f(x,y),x=g(x,y)。这样就和泊松公式对应起来了。
那么为什么u=h(x,y)*f(x,y),x=g(x,y)呢？
因为：“在许多情况下，图像需要用泊松随机场来建模，比如天文、共聚焦显微、CT 以及 PET 等图像是许多光子在一定时间内遵循泊松随机过程产生的结果，而 L-R 算法能够按照泊松噪声统计标准对给定点扩散函数的退化图像进行反卷积迭代推演计算，充分考虑了信号的统计涨落特性，经过一定次数的迭代计算后可得到接近理想清晰图像的最大似然估计值”
以上为原论文的说明，我直接引用过来了。
其实上面的公式差一个括号。
然后就是利用梯度为0求解上面那个方程了。
首先取ln化乘为加：
然后求导另结果等于0：
解得：
两边同时乘以f(x,y):
在加入迭代求解的概念：
是不是有点莫名其妙，随便就变成迭代求解形式了？我想作者肯定省略了一万步在里面，这个迭代求解的结果可能是利用牛顿下降法，或者梯度下降法求得的。不过这里你知道就行了。
但是LR算法的缺点也很明显，那就是LR并没有规定迭代结束的条件，如果我们愿意算法可以一直迭代下去，并且LR算法可能还会收敛到局部极值点求不出真正的解，或者出现震荡等迭代算法常常出现的问题。所以初值的选取使非常关键的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68d721dff8c813095eaecb2298269c94/" rel="bookmark">
			维纳滤波
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上一节讲了逆滤波，这一次讲讲维纳滤波，逆滤波在图像没有噪声的情况下是很好的，但在有噪声的情况下，噪声会被放大，所以维纳滤波就横空出世了，维纳滤波能很好的解决有噪声的图像修复。
维纳滤波是诺波特·维纳在二十世纪四十年代提出的一种滤波器，即假定线性滤波器的输入为有用信号和噪声之和，两者均为广义平稳过程且知道它们的二阶统计特性，根据最小军方误差准则（滤波器的输出信号与需要信号之差的均方值最小），求得最佳线性滤波器的参数。
维纳滤波器是一种自适应最小均方差滤波器。维纳滤波的方法是一种统计方法，它用的最优准则是基于图像和噪声各自的相关矩阵，它能根据图像的局部方差调整滤波器的输出，局部方差最大，滤波器的平滑作用就越强。
公式如下：
其中戴帽子的f为我们维纳滤波后的图像，f为清晰的原始图像，g为待恢复的模糊图像（g上式没有，写出来为了说明的完整性）。
这里戴帽子的f我们是不知道的，所以我们要根据这个优化式子求出 f ^ \hat{f} f^​.
具体的推导过程这里不写，因为我也只看了个大概。
求解的结果为：
其中，G(u,v)是退化图形的傅里叶变换；
H(u,v)是退化函数；
p n ( u , v ) = ∣ N ( u , v ) ∣ 2 p_n(u,v)=|N(u,v)|^2 pn​(u,v)=∣N(u,v)∣2是噪声的功率谱；
P f ( u , v ) = ∣ F ( u , v ) ∣ 2 P_f(u,v)=|F(u,v)|^2 Pf​(u,v)=∣F(u,v)∣2是原始图像的功率谱；
s = 1 λ s=\frac{1}{λ} s=λ1​,λ为一常数，是拉格朗日乘数。
之前有说过维纳滤波需要知道原始图像和噪声的二阶统计特性，即要知道关于图像和噪声的先验知识，比如 p f ( u , v ) , p n ( u , v ) p_f(u,v),p_n(u,v) pf​(u,v),pn​(u,v)，但是这恰恰也是我们不知道的，这也是维纳滤波器的局限所在，我们一般将上述两个公式的比值看做是常数带入进行计算，如下所示：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/68d721dff8c813095eaecb2298269c94/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9e0c9cb781d136a4691b02f4c18bb0a/" rel="bookmark">
			软件工程之用户界面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 用户界面设计是以人为中心，使产品达到简单使用和愉悦使用的设计，关于用户界面设计的相关知识点，接下来按照以下几大点讲解本章内容
一、用户界面设计应具备的特性
二、用户界面设计的任务分析
三、用户界面任务和工作设计
四、用户界面设计的基本类型
首先了解界面用户设计的流程： 一、用户界面应具备的特征 1.可使用性 简单、术语标准化、一致性、Help帮助、系统影响、系统成本、容错能力
2.灵活性 算法的显性和隐形、用户可以制定修改、提供丰富的响应信息、与其他系统融合性
3.负责性和可靠性 用户界面简单功能齐全、程序和数据的安全性
二、用户界面设计的任务分析 用户类型： 外行型、初学型、熟练型和专家型
用户特性度量： 用户特性的度量与用户使用模式及观测到的用户群体能力有关。
用户使用的频度、用户是否能够自由选用界面、用户对计算机熟悉程度、用户知识、用户思维能力、用户的生理能力和技能。
用户模型 （1）理论认知模型
由心理学家建立的模型，目的是要了解人的思维过程。
（2）用户知识模型
这种模型描述了一定范畴内的知识以及类型之间的 联系。模型借助各个用户的知识来建立。用遍历知识网络的方法来评价用户如何学习。
（3）用户特性模型
这些模型主要依据在用户特性分析所描述的技能和能力对用户进行分类，它们也被称为用户外观。
（4）用户任务模型
这种模型根据用户要求中提出的任务的功能和操作次序，构想该任务的概念。通过它，可以了解用户知道多少有关系统操作的知识，用户期望系统应当如何工作等等。
（5）用户观点
指系统结构的用户类型。是用户描述和设想现行系统结构的方法。它可以用图形化的方式表述，也可以用语言方式表示。
用户工作分析
也称为任务分析，它是系统内部活动的分解。（人）
用户工作分析与需求分析中结构化分析的方法类似，采用自顶向下，逐步进行功能分解。与常规的功能分解不同的是，所有的系统任务，包括与人相关的活动，都要考虑在内。
系统的功能分解，可以用数据流图和数据词典描述，任务可以由一组动作构成，它们规定了为实现这个任务所必须的一系列活动。
任务的细节可以使用结构化语言来表达。
三、用户界面任务和工作设计 1.任务分配 在每个任务中，动作要分配给计算机、用户或者二者。
一般地，用户承担需要创造、判断和探索的任务，而计算承担重复检查、计算和数据处理的工作。
任务分配产生两个网络：
一个是人的任务网络，一个是计算机的任务网络。人的任务网络说明如何安装、操作和使用系统，它最后将形成操作过程和用户手册的基础。计算机的认为网络则描述计算机应担负的工作。
数据录入、恢复和决策支持
2.任务分配步骤 （1）检查数据流图，标出哪些是单独由计算机完成的任务、哪些是单独由人完成的任务、哪些是由两者共同完成的任务。
（2）对于共同完成的任务，将任务的每一个动作分配给计算机或人。
（3）构成新的计算机的任务网络和人的任务网络。
（4）再进一步细化计算机与人的协同动作，以确定人和计算机如何交互。
3.工作方式 （1）由一个人单独完成一个系统的目标
（2）任务进展跟踪。
（3）工作负荷匀称
4.工作设计
工作设计的目的：是使任务需求与操作员的能力相匹配。
在界面设计中关于人的因素特性的简单的度量如下：
复杂性
专心程度
责任心
变化性
四、用户界面设计的基本类型 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e910ae108e07cd31630287014490182/" rel="bookmark">
			switch 语句编译报错Constant expression required
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		脑抽写了个坑，记录一下填坑过程。。。防止自己再跳。。。。。
先说一下switch支持的类型：switch表达式后面的数据类型只能是byte,short，char，int四种整形类型，枚举类型和java.lang.String类型（从java 7才允许），不能是boolean类型。
非正常类型入参错误如下：
如下是非常量错误：
此处错误：case中使用的的必须是常量，也就是要使用进行判断的值要是常量，要进行final修饰才可以；
有的时候，会有这种并存的错误（入参类型与case不匹配），这样的错误信息如果从上到下处理错误，真的伤不起（不局限于switch错误，其他功能场景也会有）。
有的时候会不注意入参类型，而过多的去关注常量问题，浪费很多时间。
比如：一个类型要转成6种类型才能入参，结果忘记转换就入参了，然后发现常量还没有问题是final修饰，是不是就开始薅头发了。。。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dfcf161ceb14d44f2746929f84345f4e/" rel="bookmark">
			生产环境禁用Swagger
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 打包环境的属性值来禁用 1.1 在属性文件中配置变量 #Swagger开关 SWAGGER.ENABLE = true 1.2 在配置类中设置开关 @Value("${SWAGGER.ENABLE}") private boolean swaggerEnable; @Override public void addResourceHandlers(ResourceHandlerRegistry registry) { if (swaggerEnable) { System.out.println(swaggerEnable); registry.addResourceHandler("swagger-ui.html") .addResourceLocations("classpath:/META-INF/resources/"); registry.addResourceHandler("/webjars/**") .addResourceLocations("classpath:/META-INF/resources/webjars/"); } } 2. 打包环境 使用@Profile注解 项目背景介绍， 我们有三个环境dev，test，prod，我们只在dev环境中使用swagger，test和prod都禁止使用
2.1 添加@Profile注解 @EnableSwagger2 @Profile("dev") public class Swagger2 extends WebMvcConfigurationSupport { @Bean public Docket createRestApi() { return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .select() //为当前包路径 .apis(RequestHandlerSelectors.basePackage("com.yq.demo.controller")) .paths(PathSelectors.any()) .build(); } //构建 api文档的详细信息函数,注意这里的注解引用的是哪个 private ApiInfo apiInfo() { return new ApiInfoBuilder() .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dfcf161ceb14d44f2746929f84345f4e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91a9ce6bbf0b16ac51dcd88beb0d905f/" rel="bookmark">
			C&#43;&#43; 实现大数加法类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里运算符的重载比较难
5:别叫，这个大整数已经很简化了! 查看提交统计提问 总时间限制: 1000ms
内存限制: 65536kB
// 在此处补充你的代码 描述
程序填空，输出指定结果
#include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;cstdlib&gt; #include &lt;cstdio&gt; using namespace std; const int MAX = 110; class CHugeInt { }; int main() { char s[210]; int n; while (cin &gt;&gt; s &gt;&gt; n) { CHugeInt a(s); CHugeInt b(n); cout &lt;&lt; a + b &lt;&lt; endl; cout &lt;&lt; n + a &lt;&lt; endl; cout &lt;&lt; a + n &lt;&lt; endl; b += n; cout &lt;&lt; ++ b &lt;&lt; endl; cout &lt;&lt; b++ &lt;&lt; endl; cout &lt;&lt; b &lt;&lt; endl; } return 0; } 输入
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91a9ce6bbf0b16ac51dcd88beb0d905f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51ce96079e236b17f913049ae3793688/" rel="bookmark">
			linux ps命令介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ps命令 Linux中的ps命令是Process Status的缩写。ps命令用来列出系统中当前运行的那些进程。ps命令列出的是当前那些进程的快照，就是执行ps命令的那个时刻的那些进程，如果想要动态的显示进程信息，就可以使用top命令。
要对进程进行监测和控制，首先必须要了解当前进程的情况，也就是需要查看当前进程，而 ps 命令就是最基本同时也是非常强大的进程查看命令。使用该命令可以确定有哪些进程正在运行和运行的状态、进程是否结束、进程有没有僵死、哪些进程占用了过多的资源等等。总之大部分信息都是可以通过执行该命令得到的。
ps 为我们提供了进程的一次性的查看，它所提供的查看结果并不动态连续的；如果想对进程时间监控，应该用 top 工具。
kill 命令用于杀死进程。
linux上进程有5种状态: 1. 运行(正在运行或在运行队列中等待) 2. 中断(休眠中, 受阻, 在等待某个条件的形成或接受到信号) 3. 不可中断(收到信号不唤醒和不可运行, 进程必须等待直到有中断发生) 4. 僵死(进程已终止, 但进程描述符存在, 直到父进程调用wait4()系统调用后释放) 5. 停止(进程收到SIGSTOP, SIGSTP, SIGTIN, SIGTOU信号后停止运行运行) ps工具标识进程的5种状态码: D 不可中断 uninterruptible sleep (usually IO) R 运行 runnable (on run queue) S 中断 sleeping T 停止 traced or stopped Z 僵死 a defunct (”zombie”) process 1．命令格式：
ps[参数]
2．命令功能：
用来显示当前进程的状态
3．命令参数：
a 显示所有进程
-a 显示同一终端下的所有程序
-A 显示所有进程
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/51ce96079e236b17f913049ae3793688/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/179b08f7f0e50ebc47687ba6685ed3f0/" rel="bookmark">
			浅拷贝与深拷贝的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简单的来说就是，在有指针的情况下，浅拷贝只是增加了一个指针指向已经存在的内存， 而深拷贝就是增加一个指针并且申请一个新的内存，使这个增加的指针指向这个新的内存， 采用深拷贝的情况下，释放内存的时候就不会出现在浅拷贝时重复释放同一内存的错误！ C++中对象的复制就如同“克隆”，用一个已有的对象快速地复制出多个完全相同的对象。一般而言，以下三种情况都会使用到对象的复制： （1）建立一个新对象，并用另一个同类的已有对象对新对象进行初始化，例如：
[cpp] view plaincopy
class Rect { private: int width; int height; }; Rect rect1; Rect rect2(rect1); // 使用rect1初始化rect2，此时会进行对象的复制 （2）当函数的参数为类的对象时，这时调用此函数时使用的是值传递，也会产生对象的复制，例如：
[cpp] view plaincopy
void fun1(Rect rect) { ... } int main() { Rect rect1; fun1(rect1); // 此时会进行对象的复制 return 0; } （3）函数的返回值是类的对象时，在函数调用结束时，需要将函数中的对象复制一个临时对象并传给改函数的调用处，例如：
[cpp] view plaincopy
Rect fun2() { Rect rect; return rect; } int main() { Rect rect1; rect1=fun2(); // 在fun2返回对象时，会执行对象复制，复制出一临时对象， // 然后将此临时对象“赋值”给rect1 return 0; } 对象的复制都是通过一种特殊的构造函数来完成的，这种特殊的构造函数就是拷贝构造函数（copy constructor，也叫复制构造函数）。拷贝构造函数在大多数情况下都很简单，甚至在我们都不知道它存在的情况下也能很好发挥作用，但是在一些特殊情况下，特别是在对象里有动态成员的时候，就需要我们特别小心地处理拷贝构造函数了。下面我们就来看看拷贝构造函数的使用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/179b08f7f0e50ebc47687ba6685ed3f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b3465fe7584dd45a77e7f315f52a0aa/" rel="bookmark">
			request.getContentLength()的值为-1的问题解决方案【HttpPost发起】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、问题的发现，服务端使用DataInputStream的方式获取流，直接上代码说明
try { DataInputStream in = new DataInputStream(request.getInputStream()); // 将请求消息的实体送到b变量中 int totalBytes = request.getContentLength(); byte[] b = new byte[totalBytes]; in.readFully(b); in.close(); String reqContent = new String(b, "UTF-8"); respXml = reqContent; } catch (IOException e) { e.printStackTrace(); } DataInputStream的readFully()需要创新一个与流等长的Byte数组，因为request.getContentLength()的值为-1，读取失败。
2、于是想服务端换一种方式读取，可以规避问题，但是没有解决问题，而且服务端一般是你上游的，你动不了，也不一定会配合你改，以为别的接入可以，为啥你不行，一般都会被怼回来，自讨没趣，但是代码还是要上的。
InputStream inputStream = request.getInputStream(); BufferedReader br = new BufferedReader(new InputStreamReader(inputStream)); StringBuffer msgBuf = new StringBuffer(); String temp = null; while((temp = br.readLine())!=null){ msgBuf.append(temp); } respXml= msgBuf.toString(); 3、针对request.getContentLength()的值为-1，其实就是客户端发送的得数据流的采用的HTTP协议header的Content-Length参数中没有值，于是，准备强制性真进行赋值post.setHeader("Content-Length", xml.getBytes("UTF-8").length+"");，结果提示Caused by: org.apache.http.ProtocolException: Content-Length header already present。于是再次检查客服端代码。InputStreamEntity有四个构造方法，如果不提供长度，默认为-1。因为使用没有length的构造
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b3465fe7584dd45a77e7f315f52a0aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5429273e0647ab538fb790ed0b05e8cf/" rel="bookmark">
			UEFI 启动 win7
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 UEFI启动win7
一 注意事项：
硬盘必须是GPT格式系统必须是64位必须以UEFI方式启动电脑 二 准备工具
用“优启通“制作好的U盘Win7 原版iso镜像包Win8/8.1 原版ios镜像包 三 步骤
插入U盘，以UEFI方式启动电脑进入PE解压win7镜像包将win8/8.1镜像包中 根目录下的 “bootmgr.efi”/“bootmgrfw.efi“ 拷贝到解压的win7 目录下的 ”\EFI\BOOT\”下（没有BOOT 文件夹则自行新建），并重命名为”BOOTX64.EFI”双击win7目录下的“setup.exe”即可进行系统安装 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a906fd951da566118fbaac2064ac3e93/" rel="bookmark">
			如何彻底删除Kafka中的topic  (marked for deletion)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		工作中因为各种原因， 例如topic中消息堆积的太多，或者kafka所在磁盘空间满了等等，可能需要彻底清理一下kafka topic，那么如何彻底删除topic？
方法一（配置delete.topic.enable=true）
修改kafaka配置文件server.properties， 添加delete.topic.enable=true，重启kafka，之后通过kafka命令行就可以直接删除topic
通过命令行删除topic：
./bin/kafka-topics.sh --delete --zookeeper {zookeeper server} --topic {topic name}
方法二（没有配置delete.topic.enable=true）
1、通过命令行删除topic：
./bin/kafka-topics.sh --delete --zookeeper {zookeeper server} --topic {topic name}
因为kafaka配置文件中server.properties没有配置delete.topic.enable=true，此时的删除并不是真正的删除，只是把topic标记为：marked for deletion
你可以通过命令：./bin/kafka-topics --zookeeper {zookeeper server} --list 来查看所有topic
2、删除kafka存储目录（server.properties文件log.dirs配置，默认为"/tmp/kafka-logs"）相关topic目录
3， 若想真正删除它，需要登录zookeeper客户端：
命令：./bin/zkCli.sh
找到topic所在的目录：ls /brokers/topics
执行命令：rmr /brokers/topics/{topic name}即可，此时topic被彻底删除。
另外被标记为marked for deletion的topic你可以在zookeeper客户端中通过命令获得：ls /admin/delete_topics/{topic name}，如果你删除了此处的topic，那么marked for deletion 标记消失
zookeeper 的config中也有有关topic的信息： ls /config/topics/{topic name}暂时不知道有什么用
总结
彻底删除topic：
1、确保kafka的配置文件server.proeprties中设置delete.topic.enable=true，如果没有， 确保cluster的所有kafka配置文件设置该参数并重启，然后直接通过命令删除，如果命令删除不了，直接通过zookeeper命令行删除掉broker下的topic。
2、删除kafka存储目录（server.properties文件log.dirs配置，默认为"/tmp/kafka-logs"）相关topic目录
参考文档：
1， https://stackoverflow.com/questions/17730905/is-there-a-way-to-delete-all-the-data-from-a-topic-or-delete-the-topic-before-ev
stop zookeeper &amp; Kafka server,then go to ‘kafka-logs’ folder , there you will see list of kafka topic folders, delete folder with topic namego to ‘zookeeper-data’ folder , delete data inside that.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a906fd951da566118fbaac2064ac3e93/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b15c84c34794bc8ff16e941b76783581/" rel="bookmark">
			vim常用配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vim常用配置 vim 是程序员最喜欢的编辑器，没有之一。编辑 ~/.vimrc 可以设置一些默认的vim属性，包括缩进、显示行数等等。下面这个配置是我比较喜欢的，拿出来给大家共享。
" Configuration file for vim set modelines=0 "CVE-2007-2438 " Normally we use vim-extensions. If you want true vi-compatibility " remove change the following statements set nocompatible " Use Vim defaults instead of 100% vi compatibility set backspace=2 " more powerful backspacing " Don't write backup file if vim is being called by "crontab -e" au BufWrite /private/tmp/crontab.* set nowritebackup nobackup " Don't write backup file if vim is being called by "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b15c84c34794bc8ff16e941b76783581/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec985b16a0dd5e9d7dafa70b9bb8cf31/" rel="bookmark">
			mysql去重，只留一个（id最小的）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天爬了一堆数据，结果发现有些重复的，无奈之下只好写个sql语句把mysql里去重了。如果大家有一样的需求可以直接拿去改吧改吧用。
表名：你自己数据库的表名字段名：根据什么字段去重id：一般默认就叫“id”，特殊的自己改掉下面的id就好delete from 表名 where 字段名 in (select 字段名from (select 字段名 from 表名 group by 字段名 having count(字段名)&gt;1)a) and id not in (select id from(select min(id) as id from 表名 group by 字段名 having count(字段名)&gt;1)b) 删除重复壁纸信息，只保留id最小的那个
delete from tb_wallpaper where wurl_preview in (select wurl_preview from (select wurl_preview from tb_wallpaper group by wurl_preview having count(wurl_preview)&gt;1)a) and id not in (select id from(select min(id) as id from tb_wallpaper group by wurl_preview having count(wurl_preview)&gt;1)b)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec985b16a0dd5e9d7dafa70b9bb8cf31/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e24d707958b3d67569df0d8e402b80c6/" rel="bookmark">
			单元测试作用范围
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 发现junit的@Test注解无法用。发现原因是junit的@Test注解默认配置是只能在名称为test的目录下面使用，改一下配置就好了。如下图去掉图中箭头标注的scope一行就行了。改完后的配置如下。
&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.7&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;${junit.version}&lt;/version&gt; &lt;/dependency&gt; 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/499/">«</a>
	<span class="pagination__item pagination__item--current">500/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/501/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>