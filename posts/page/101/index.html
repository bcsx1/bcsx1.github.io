<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1193c76da29850130d80a0af52ddd78c/" rel="bookmark">
			MySQL 详细学习教程【万字长文, 建议收藏】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1. Mysql入门1.1 Mysql5.7 安装配置1.2 命令行连接到Mysql1.3 图形化软件1.3.1 Navicat1.3.2 SQLyog 1.4 数据库三层结构 2. Java操作数据库、表2.1 创建数据库2.2 查询数据库2.3 备份恢复数据库2.4 创建表2.5 修改表 3 CRUD3.1 insert插入3.2 update修改3.3 delete修改3.4 select查询3.4.1 模糊查询3.4.2 分页查询 3.5 mysql多表查询3.5.1 多表查询3.5.2 自连接3.5.3 多行子查询3.5.4 查询临时表3.5.5 all any操作符3.5.6 多列子查询3.5.7 表复制 &amp;&amp; 去重3.5.8 合并查询 3.6 mysql外连接3.7 主键3.8 unique3.9 外键3.91 check3.92 自增长3.3错题集 3. Mysql常用数据类型3.1 数值型( )的基本使用3.2 数值型(bit)的基本使用3.3 数值型(小数)的基本使用3.4 字符串的基本使用3.4.1 文本类型使用细节 3.5 日期类型的基本使用 4. 函数4.1 统计函数 count4.2 合计函数 sum4.3 合计函数 avg4.4 合计函数 max/min4.5 分组函数 group by4.6 字符串相关函数4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1193c76da29850130d80a0af52ddd78c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3a4c667e627220b21180aa399c77de3/" rel="bookmark">
			SimpleITK常用指令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说明文档：SimpleITK Sphinx Documentation — SimpleITK 2.0rc2 documentation
import SimpleITK as sitk
1、 数据类型
1）查看
img_itk.GetPixelIDTypeAsString() img_itk.GetPixelID() 2）修改
sitk.Cast(img_itk, sitk.sitkInt16) 注意：signed和unsigned出来的结果可能完全不一样
2、sitk中的一些基本概念
1）redirection/resample，不改变origin和物理坐标
2）
3、导入/写入数据
sitk.ReadImage(path) sitk.WriteImage(img_itk, 'name.nii.gz') 4、与numpy转换（size保持一致）
sitk.GetImageFromArray(img_arr) sitk.GetArrayFromImage(img_itk) 5、物理坐标和index转换
img_itk.TransformContinuousIndexToPhysicalPoint(point[::-1]) img_itk.TransformPhysicalPointToContinuousIndex(point)[::-1] 6、复制图片(version &gt;= 2.0)
img_itk_cp = img_itk.__deepcopy__(None) 7、复制meta信息（direction、spacing、origin）
img_itk.CopyInformation(source_itk) 8、裁剪
sitk.RegionOfInterest(img_itk, length, start) 9、通过构建filter来实现的一些功能
1）像素值缩放到区间（示例为[0, 255]）
Filter = sitk.RescaleIntensityImageFilter() Filter.SetOutputMaximum(255) Filter.SetOutputMinimum(0) output_itk = Filter.Execute(img_itk) 2）图像高斯滤波
Filter = sitk.DiscreteGaussianImageFilter() Filter.SetVariance(3) Filter.SetMaximumError(0.2) output_itk = Filter.Execute(img_itk) 3）图像逻辑运算（输入图像需要进行二值化）
# 异或 Filter = sitk.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3a4c667e627220b21180aa399c77de3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1fef236378511fcecc3efb2e1f6fb2db/" rel="bookmark">
			基于注解优雅的实现接口幂等性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是幂等性 简单来说，就是对一个接口执行重复的多次请求，与一次请求所产生的结果是相同的，听起来非常容易理解，但要真正的在系统中要始终保持这个目标，是需要很严谨的设计的，在实际的生产环境下，我们应该保证任何接口都是幂等的，而如何正确的实现幂等，就是本文要讨论的内容。
二、哪些请求天生就是幂等的 首先，我们要知道查询类的请求一般都是天然幂等的，除此之外，删除请求在大多数情况下也是幂等的，但是ABA场景下除外。
举一个简单的例子
比如，先请求了一次删除A的操作，但由于响应超时，又自动请求了一次删除A的操作，如果在两次请求之间，又插入了一次A，而实际上新插入的这一次A，是不应该被删除的，这就是ABA问题，不过，在大多数业务场景中，ABA问题都是可以忽略的。
除了查询和删除之外，还有更新操作，同样的更新操作在大多数场景下也是天然幂等的，其例外是也会存在ABA的问题，更重要的是，比如执行update table set a = a + 1 where v = 1这样的更新就非幂等了。
最后，就还剩插入了，插入大多数情况下都是非幂等的，除非是利用数据库唯一索引来保证数据不会重复产生。
三、为什么需要幂等 1.超时重试 当发起一次RPC请求时，难免会因为网络不稳定而导致请求失败，一般遇到这样的问题我们希望能够重新请求一次，正常情况下没有问题，但有时请求实际上已经发出去了，只是在请求响应时网络异常或者超时，此时，请求方如果再重新发起一次请求，那被请求方就需要保证幂等了。
2.异步回调 异步回调是提升系统接口吞吐量的一种常用方式，很明显，此类接口一定是需要保证幂等性的。
3.消息队列 现在常用的消息队列框架，比如：Kafka、RocketMQ、RabbitMQ在消息传递时都会采取At least once原则（也就是至少一次原则，在消息传递时，不允许丢消息，但是允许有重复的消息），既然消息队列不保证不会出现重复的消息，那消费者自然要保证处理逻辑的幂等性了。
四、实现幂等的关键因素 关键因素1 幂等唯一标识，可以叫它幂等号或者幂等令牌或者全局ID，总之就是客户端与服务端一次请求时的唯一标识，一般情况下由客户端来生成，也可以让第三方来统一分配。
关键因素2 有了唯一标识以后，服务端只需要确保这个唯一标识只被使用一次即可，一种常见的方式就是利用数据库的唯一索引。
五、注解实现幂等性 定义DistributedLock注解 @Target({ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) @Documented public @interface DistributedLock { /** * 保证业务接口的key的唯一性，否则失去了分布式锁的意义 锁key * 支持使用spEl表达式 */ String key(); /** * 保证业务接口的key的唯一性，否则失去了分布式锁的意义 锁key 前缀 */ String keyPrefix() default ""; /** * 是否在等待时间内获取锁，如果在等待时间内无法获取到锁，则返回失败 */ boolean tryLok() default false; /** * 获取锁的最大尝试时间 ，会尝试tryTime时间获取锁，在该时间内获取成功则返回，否则抛出获取锁超时异常，tryLok=true时，该值必须大于0。 * */ long tryTime() default 0; /** * 加锁的时间，超过这个时间后锁便自动解锁 */ long lockTime() default 30; /** * tryTime 和 lockTime的时间单位 */ TimeUnit unit() default TimeUnit.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1fef236378511fcecc3efb2e1f6fb2db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0327897d4da061bfc1050f182d8425c1/" rel="bookmark">
			android 屏幕适配
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.使用屏幕适配框架(网上太多了，一搜一大把，这里不再赘述)
2.使用不同分辨率下的资源文件(同上)
2.通过屏幕物理尺寸计算：
public static float adapterSize(Context context, float size) { DisplayMetrics dm = context.getResources().getDisplayMetrics(); // 物理尺寸 double x = Math.pow(dm.widthPixels / dm.xdpi, 2d); double y = Math.pow(dm.heightPixels / dm.ydpi, 2d); double screenInches = Math.sqrt(x + y); return (float) (size * screenInches / 5.5d); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a51b1f3ea84e3b8ee1a50e533b00187/" rel="bookmark">
			计算机视觉之三维重建(一)(摄像机几何)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		针孔摄像机 添加屏障： 使用针孔(o=光圈=针孔=摄像机中心)，实现现实与成像一对一映射，减少模糊。其中针孔与像平面的距离为f(焦距)；虚拟像平面位于针孔与真实物体之间，与像平面互为倒立关系。位置映射：利用相似三角形得到现实坐标在像平面上的映射坐标。光圈：随着光圈减小，成像愈加清晰且愈暗。 透镜 将多条光线汇聚到胶片上，增加成像亮度。PS：所有平行于光轴的光线都会汇聚到焦点，焦点到透镜中心的距离成为焦距；穿过中心的光线的方向不发生改变。失焦：透镜将光线汇聚到胶片上，聚焦有特定距离。径向畸变：枕形畸变、桶形畸变。远离针孔中心的光线更加弯曲。 摄像机几何 空间中的点（以摄像机光圈为原始点）与图像坐标对映：利用投影矩阵（每个相机固定参数）实现线性变换。投影矩阵：代表映射关系。PS：摄像机偏斜：图像坐标系非垂直情形，夹角参数放入投影矩阵。
( x , y , z ) (x,y,z) (x,y,z)现实坐标， M M M为投影矩阵，其中 M M M的前三列为摄像机的内参数矩阵（完全决定空间点到图像点的映射）。 规范化投影变换：图像坐标与现实坐标一致。
世界坐标系 不以相机光圈为起始点的转换，无非是多加一个转换矩阵。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a52e1224910dc475a2f823a178e9391a/" rel="bookmark">
			工具-jvmGC之gcview
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、下载地址 https://github.com/chewiebug/GCViewer 2、git克隆/直接下载zip git clone https://github.com/chewiebug/GCViewer.git cd GCViewer
//通过mvn编译 下面命令的意思是：清理 打包 跳过测试阶段
mvn clean install -DskipTests
3、运行jar 进入到target目录，查看对应的jar包。双击运行
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/015330a1026f3fce6400418f295acd54/" rel="bookmark">
			泛微OA E9流程退回后通过DML接口动作删除表单中明细表的数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		创建流程时候通过字段联动出明细表的数据，当流程被退回或者流程干预退回后自动删除原来联动出来的明细表数据
出口信息-附加规则
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/192ecbdd49cb7ede4b0599d18557ada8/" rel="bookmark">
			Codeforces Round 893 (Div. 2)-B. The Walkway
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Problem - B - Codeforces
题目大意：总长度为n的路径上有m个点，主角在从1走到n的过程中需要饼干。规则如下，（1）走到m个点的任意一个点都必须吃饼干，（2）每次行走距离达到d时必须吃饼干，吃完饼干后行走距离归零。要求：（1）计算出主角吃饼干的总数（注意可以删除一个点再计算总数）（2）如果可以删除一个点，哪么可以删除的点的数量。
初步分析：有两种情况，一是可以删除某个点使得次数少一个（需要统计这些点数量），另一种就是删除任何一个点总数都不变（注意这种情况可以看成删除点数量为m）。
解题方法：模拟法。什么是模拟法？如果问人这个问题，你怎么知道删除这个点会不会减少次数呢？哪么你肯定会在草稿纸上算一下。把这个过程不加改变地用在程序中，这是我理解的模拟法。
因为只能删除一个点，可以在计算总数过程中，顺路进行枚举，例如判断a[i]能否删除，计算下吃饼干次数t1+t2和t3的大小可知。具体细节看代码注释。
#include &lt;bits/stdc++.h&gt; typedef long long ll; using namespace std; int main() { ios::sync_with_stdio(0),cin.tie(0); int n,m,d,t,i,j,a[100005]= {1},t1,t2,t3; cin&gt;&gt;t; while(t--) { int sum=1,cnt=0;/**&lt; sum统计次数，cnt统计可以拿走某一个的次数 */ cin&gt;&gt;n&gt;&gt;m&gt;&gt;d; for(i=1; i&lt;=m; i++) cin&gt;&gt;a[i]; a[m+1]=n; for(i=1; i&lt;=m; i++)/**&lt;模拟删除某个a[i]会不会使得整个次数减少一次 */ {/**&lt; t1,t2,t3,分别用于统计次数 */ if((a[i]-a[i-1])%d) t1=(a[i]-a[i-1])/d+1; else t1=(a[i]-a[i-1])/d; if(i&lt;m&amp;&amp;(a[i+1]-a[i])%d) t2=(a[i+1]-a[i])/d+1; else t2=(a[i+1]-a[i])/d; if(i&lt;m&amp;&amp;(a[i+1]-a[i-1])%d) t3=(a[i+1]-a[i-1])/d+1; else t3=(a[i+1]-a[i-1])/d; sum+=t1;/**&lt; 统计不删除结点的次数 */ if(t1+t2&gt;t3)/**&lt; 如果拿掉a[i]的次数t3小 */ cnt++; } sum+=(n-a[m])/d;/**&lt; 最后走到n */ if(cnt&gt;0)/**&lt; 如果可以删除某些结点，哪么总数减少一次 */ sum--; if(cnt==0)/**&lt; 无法减少次数，那么拿走m的任何一个都可以 */ cnt=m; cout&lt;&lt;sum&lt;&lt;' '&lt;&lt;cnt&lt;&lt;endl; } return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/627ff95e142446c7b360b181438755a2/" rel="bookmark">
			给初学者推荐的10个Python免费学习网站,赶紧收藏吧!
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 最近有好多人说刚开始学习，有哪些免费的学习网站可以自学一下。于是，趁着空闲的时间在各大网站上面梳理了一下，找出了5个比较好的学习网站，并且都是免费的，比较适合初学者了解一些基础语法、解决BUG问题。
1、Python 官方中文网站 网站地址：https://docs.python.org/zh-cn/3/
官方网站不仅有基础语法参考、Python标准模块介绍，相关的教程也有，平时查接口文档什么的都是比较方便的。
2、w3school 网站地址：http://www.w3school.com.cn/
这是个比较老的网站了，记得刚开始学编程的时候我经常在上面查找Html标签的应用。不过，Python的应用在上面也是有的，忘记了一些内置函数怎么用来这上面查一查还是比较Nice的。
3、菜鸟教程 网站地址：http://www.runoob.com/
这个也不错，只要是你是新手学习上面各类编程语言都有，包括数据库的安装使用等操作步骤都会一步一步的列出来。相信新手朋友看到这个网站肯定会非常喜欢的，想要什么信息直接搜索就成了。
4、python Code Example 网站地址：https://www.programcreek.com/python/
这是一个英文网站，有一些英文功底可以使用这个网站。主要是收集了大量的python模块的使用实例，使用时通过搜索模块名称来查找相关的实例来进行参考。
比如：可以搜索一下datetime是怎么使用的，就可以搜索一下…
可以直接定位到里面的某个函数是怎么使用的，搜索到之后照着写就成了。
5、LearnPython 网站地址：https://www.learnpython.org/
这个网站也是个英文网站，里面包含了一些初级和高级用法，大佬们有需要也可以来尝试一下。
最后感谢每一个认真阅读我文章的人，礼尚往来总是要有的，虽然不是什么很值钱的东西，如果你用得到的话可以直接拿走：
一、Python入门 下面这些内容是Python各个应用方向都必备的基础知识，想做爬虫、数据分析或者人工智能，都得先学会他们。任何高大上的东西，都是建立在原始的基础之上。打好基础，未来的路会走得更稳重。所有资料文末免费领取！！！
包含：
计算机基础
python基础
Python入门视频600集：
观看零基础学习视频，看视频学习是最快捷也是最有效果的方式，跟着视频中老师的思路，从基础到深入，还是很容易入门的。
二、Python爬虫 爬虫作为一个热门的方向，不管是在自己兼职还是当成辅助技能提高工作效率，都是很不错的选择。
通过爬虫技术可以将相关的内容收集起来，分析删选后得到我们真正需要的信息。
这个信息收集分析整合的工作，可应用的范畴非常的广泛，无论是生活服务、出行旅行、金融投资、各类制造业的产品市场需求等等，都能够借助爬虫技术获取更精准有效的信息加以利用。
Python爬虫视频资料
三、数据分析 清华大学经管学院发布的《中国经济的数字化转型：人才与就业》报告显示，2025年，数据分析人才缺口预计将达230万。
这么大的人才缺口，数据分析俨然是一片广阔的蓝海！起薪10K真的是家常便饭。
四、数据库与ETL数仓 企业需要定期将冷数据从业务数据库中转移出来存储到一个专门存放历史数据的仓库里面，各部门可以根据自身业务特性对外提供统一的数据服务，这个仓库就是数据仓库。
传统的数据仓库集成处理架构是ETL，利用ETL平台的能力，E=从源数据库抽取数据，L=将数据清洗（不符合规则的数据）、转化（对表按照业务需求进行不同维度、不同颗粒度、不同业务规则计算进行统计），T=将加工好的表以增量、全量、不同时间加载到数据仓库。
五、机器学习 机器学习就是对计算机一部分数据进行学习，然后对另外一些数据进行预测与判断。
机器学习的核心是“使用算法解析数据，从中学习，然后对新数据做出决定或预测”。也就是说计算机利用以获取的数据得出某一模型，然后利用此模型进行预测的一种方法，这个过程跟人的学习过程有些类似，比如人获取一定的经验，可以对新问题进行预测。
机器学习资料：
六、Python高级进阶 从基础的语法内容，到非常多深入的进阶知识点，了解编程语言设计，学完这里基本就了解了python入门到进阶的所有的知识点。
到这就基本就可以达到企业的用人要求了，如果大家还不知道去去哪找面试资料和简历模板，我这里也为大家整理了一份，真的可以说是保姆及的系统学习路线了。
但学习编程并不是一蹴而就，而是需要长期的坚持和训练。整理这份学习路线，是希望和大家共同进步，我自己也能去回顾一些技术点。不管是编程新手，还是需要进阶的有一定经验的程序员，我相信都可以从中有所收获。
一蹴而就，而是需要长期的坚持和训练。整理这份学习路线，是希望和大家共同进步，我自己也能去回顾一些技术点。不管是编程新手，还是需要进阶的有一定经验的程序员，我相信都可以从中有所收获。
资料领取 这份完整版的Python全套学习资料已经上传CSDN官方，朋友们如果需要可以点击下方CSDN官方认证微信卡片免费领取 ↓↓↓【保证100%免费】
好文推荐 了解python的前景：https://blog.csdn.net/SpringJavaMyBatis/article/details/127194835
了解python的兼职副业：https://blog.csdn.net/SpringJavaMyBatis/article/details/127196603
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c38974366ff869640a738758670e225f/" rel="bookmark">
			C&#43;&#43;中双冒号（两个冒号）【::】的作用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考文章：c++的两个冒号：：四个点是什么意思，什么作用呢？
20230816
文章目录 C++中双冒号（::）的作用全局命名空间类成员访问命名空间访问解决名称冲突模板类中的双冒号参考资料： 技术投票 C++中双冒号（::）的作用 C++中的双冒号::被称为域解析运算符。这个运算符在多种情况下使用，具有不同的含义。以下我们将详细讨论它们。
全局命名空间 全局命名空间是一个包含所有全局变量、函数和类型的隐式命名空间。如果想要在一个局部作用域内访问全局作用域的实体，可以使用双冒号::。
#include &lt;iostream&gt; int var = 10; // global variable int main() { int var = 20; // local variable std::cout &lt;&lt; "Global var: " &lt;&lt; ::var &lt;&lt; std::endl; // access global variable std::cout &lt;&lt; "Local var: " &lt;&lt; var &lt;&lt; std::endl; // access local variable return 0; } 上述代码中，全局变量和局部变量同名。通过::运算符，我们可以明确地引用全局变量。
类成员访问 在C++中，双冒号::也用于访问类的静态成员。
class MyClass { public: static int static_var; static void static_function() { std::cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c38974366ff869640a738758670e225f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab1c0e00eb7ca923ac6bcc7c1d397cb0/" rel="bookmark">
			轮腿机器人的PID控制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 PID介绍 PID（Proportional Integral Derivative）控制系统。其实质是根据输入的偏差值，按比例、积分、微分的函数关系进行运算，运算结果用以输出进行控制。它是在长期的工程实践中总结出来的一套控制方法，实际运行经验和理论分析都表明，对许多工业过程进行控制时，这种方式都能得到比较满意的效果。
u：输出信号，e: 系统误差信号。Kp比例系数，Ki积分系数，Kd微分系数。
2 腿轮PID整体思路 下面红色箭头形成闭环控制，串联PID，保持平衡并有速度。当静态平衡时，就只需要平衡PID，无需无刷电机和速度PID。
3 旋转PID 只用了比例控制.
Turn.pidout=Turn.Kp*Turn.err;
4 左右轮速度PID Avelocity.integral += Avelocity.err*0.01;
Avelocity.derivative = (Avelocity.err-Avelocity.err_last)/0.01;
Avelocity.pidout = Avelocity.Kp*Avelocity.err + Avelocity.Ki*Avelocity.integral + Avelocity.Kd*Avelocity.derivative;
5 左右平衡PID Abalance.err = Xangle-Target;
Abalance.integral += Abalance.err*0.01;
Abalance.derivative = gy.y //读取陀螺仪的
Abalance.pidout = Abalance.Kp*Abalance.err+Abalance.Ki*Abalance.integral+Abalance.Kd*Abalance.derivative;
6 高度调节PID 这个是单独pid，后上面的pid关系不大。通过调节舵机控制高度。
用了比例系数、积分系数。Kd=0，可以没用。
float p = Height.Kp*(Height.err-Height.err_last);
float i = Height.Ki*Height.err;
float d = Height.Kd*(Height.err-2*Height.err_last+Height.err_last1);
Height.pidout = Height.pidout+p+i+d;
7 滤波 需要对PID输入的参数滤波，保持机器人稳定，如输入的速度、油门等。
8 参考 轮腿机器人Hyun开源地址：GitHub - HuGuoXuang/Hyun: 轮腿机器人：主控esp32 ,陀螺仪MPU6050，PM3510无刷电机和simplefoc驱动器。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b645af51580120d6bae5d21dcfaefbd5/" rel="bookmark">
			Linux——磁盘扩容操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要 本博文主要介绍在linux系统中怎么扩充磁盘容量。博文将从介绍LVM根分区扩容和非根分区扩容两种扩容方式。磁盘操作是比较危险的操作，大家在操作前，请熟读相关扩容的文件和资料，以下示例仅供参考和学习。
一、磁盘扩容的背景 在计算机中磁盘上存储分区信息的两种不同方式主引导记录MBR(Master Boot Record)和GPT(GUID Partition Table)。对于传统的MBR分区方式，有很多的限制：最多4个主分区（3个主分区+1个扩展分区(扩展分区里面可以放多个逻辑分区)，无法创建大于2TB的分区，使用fdisk分区工具，GPT分区方式不受这样的限制。GPT分区方式将不会有这种限制，使用的工具是parted。
逻辑卷管理(LVM)，是逻辑卷管理的简写(Logical Volume Manager)，LVM是卷的一种管理方式，并不是分区工具,也可不采用这种LVM管理方式。LVM扩容思维流程：
创建一个物理分区将这个物理分区转换为物理卷把这个物理卷添加到要扩展的卷组中然后才能用extend命令扩展此卷组中的逻辑卷。 如何查看本地机器是否使用LVM管理？ pvdisplay #查看物理卷 vgdisplay #查看卷组 lvdisplay #查看逻辑卷 如果没有采用LVM管理的话，是查看不到上面卷组，物理卷，逻辑卷的（有可执行fdisk -l查看）。 逻辑卷即是挂载在目录上的卷。
二、linux中LVM根分区扩容 2.1 查看现有分区大小 df -TH 2.2 关机增加大小为30G 2.3 查看扩容后磁盘大小 2.4 创建分区 2.5 刷新分区并创建物理卷 2.6 查看卷组名称，以及卷组使用情况 2.7 将物理卷扩展到卷组 2.8 查看当前逻辑卷的空间状态 2.9 将卷组中的空闲空间扩展到根分区逻辑卷 2.10 刷新根分区 2.11 检查磁盘使用情况 三、linux中非LVM根分区扩容 博文参考 VMware ESXi给虚拟机扩容 - 知乎
Linux 扩容 / 根分区(LVM+非LVM) - 知乎
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78c7b19d8b4f53c1307773ea31ec709c/" rel="bookmark">
			Python简易部署方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.安装Python解释器和vscode或者其他开发工具
下载地址：
1.下载vscode 链接: https://code.visualstudio.com/.
2.下载python解释器 链接: https://www.python.org/downloads/.
二.安装包
打开cmd，输入命令：pip install + 包名
三.配置vscode
进入程序，按快捷键ctrl+shift+p或者进入插件商店输入language。添加中文插件。
同样方法 ,输入命令：Python:python，添加Python插件。
四.vscode写Python程序，可以调试和运行。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4a2a24cd62101f12c4988361d424105/" rel="bookmark">
			Webpact学习笔记记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Webpact学习笔记记录 一.初始化项目1.生成package.json2.安装webpack3.执行webpack体验 二、webpack的配置文件三、less-loader解析less1.安装loader2.配置 四、eslint-loader语法检查1.安装loader2.配置loader3.在package.json中加入 五、js语法转换1.安装loader2.配置loader 六、js兼容性处理1. 第一种方法：使用polyfill2. 第二种方法：借助按需引入core-js 七、url-loader解析样式中的图片1.安装loader2.配置loader 八、打包html文件1.安装插件2.配置插件 九、打包html中图片资源1.安装loader2.配置loader3.执行webpack命令即可 十、打包其他资源1.使用file-loader处理即可，file-loader前面已经下载过 十一、自动编译打包运行1.安装loader2.修改webpack配置3.package.json中修改如下 十一、开启热模替换十二、devtool映射技术十三、清除打包文件目录1.安装插件2.配置与引用插件 十四、提取css成单独的文件1.安装插件2.引入插件3.配置loader 十五、css文件的兼容性处理1.安装2.配置 十六、压缩css1.安装插件2.引入插件3.配置插件 十七、压缩html十八、完整的package.json依赖如下 声明：以下笔记内容均摘自Webpack+react全家桶开发谷粒后台项目 ~张天禹老师的讲课视频，仅供学习使用
这个项目比较旧，因此以下的的安装都加上了版本号，以免新版本不兼容影响学习，如果不加上版本号会有不一样的表现，也可能出错~。
一.初始化项目 1.生成package.json npm init 2.安装webpack yarn add webpack@^4.41.2 webpack-cli@^3.3.10 3.执行webpack体验 webpack ./src/js/index.js -o ./dist/js/index.js --mode development $ webpack ./src/js/index.js -o ./dist/js/index.js --mode development asset main.js 6.53 KiB [emitted] (name: main) runtime modules 670 bytes 3 modules cacheable modules 1.09 KiB ./src/js/index.js 446 bytes [built] [code generated] ./src/js/module1.js 273 bytes [built] [code generated] .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b4a2a24cd62101f12c4988361d424105/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2bff3bc8f32c83d1170c1fe45a15e4dc/" rel="bookmark">
			在docker环境下将ros2功能包构建成Debian软件包，并在另一个docker环境中安装测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ROS 2指南（十七）——构建自定义Debian软件包 - 知乎 (zhihu.com)
小米铁蛋创始团队，教你5分钟学会构建自定义ROS 2安装包 (qq.com)
构建自定义Debian软件包
1. 前提条件 要成功构建自定义软件包，待构建的软件包的所有依赖项都必须在本地或在rosdep工具中可用。此外，该软件包的所有依赖项都应该在其package.xml文件中被正确地声明。
2. 安装依赖项 运行以下命令来安装编译（构建）所需的实用程序：
$ sudo apt install python3-bloom python3-rosdep fakeroot
3. 初始化rosdep 通过调用以下命令初始化rosdep数据库：
$ sudo rosdep init
$ rosdep update
请注意，rosdep init命令如果前面已经被初始化过，则可能会失败； 运行rosdep update就可以安全地忽略前面的初始化。
rosdep init 错误解决终极方法（药到病除） rosdep init 错误解决终极方法（药到病除）_朱国鑫的博客-CSDN博客
ROS安装过程中如何解决 rosdep update 命令出现错误 ROS安装过程中如何解决 rosdep update 命令出现错误 - 知乎 (zhihu.com)
oot@fa647741f188:/usr/lib/python3/dist-packages/rosdistro# sudo vim /usr/lib/python3/dist-packages/rosdep2/gbpdistro_support.py
root@fa647741f188:/usr/lib/python3/dist-packages/rosdistro# sudo vim /usr/lib/python3/dist-packages/rosdep2/sources_list.py
root@fa647741f188:/usr/lib/python3/dist-packages/rosdistro# sudo vim /usr/lib/python3/dist-packages/rosdep2/rep3.py
root@fa647741f188:/usr/lib/python3/dist-packages/rosdistro# sudo vim /usr/lib/python3/dist-packages/rosdistro/manifest_provider/github.py
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2bff3bc8f32c83d1170c1fe45a15e4dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a574842cb1d630bcfbbfb54f4580736/" rel="bookmark">
			Js知识整理 - 日期时间封装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		格式化时间 /** * @description 格式化时间 * @param {String} dateTime 时间戳 * @param cFormat * @returns {string|null} */ // 其他更多是格式化有如下: // yyyy:mm:dd|yyyy:mm|yyyy年mm月dd日|yyyy年mm月dd日 hh时MM分等,可自定义组合 export function timeFormat(dateTime = null, fmt = 'yyyy-MM-dd') { if (isEmpty(fmt)) fmt = 'yyyy-MM-dd' let date = new Date(isDate(dateTime)), hour12 = /(a|A)/.test(fmt), // onedate = date.toLocaleString('chinese', { hour12: hour12 }), ret, opt = { 'y+': date.getFullYear(), // 年 'M+': date.getMonth() + 1, // 月 'd+': date.getDate(), // 日 'h+': Number(date.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a574842cb1d630bcfbbfb54f4580736/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75d619155db3b14076519f87551b7ba3/" rel="bookmark">
			UE4/UE5 照明构建失败 “Lightmass crashed”解决“数组索引越界”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在构建全局光照时,经常会出现“Lightmass crashed”的错误,导致光照构建失败。本文将分析这一问题的原因,并给出解决建议。
UE4 版本4.26
报错如下：
&lt;None&gt; === Lightmass crashed: ===
Assertion failed: (Index &gt;= 0) &amp; (Index &lt; ArrayNum) [File:d:\build\++ue4\sync\engine\source\runtime\core\public\Containers/Array.h] [Line: 611] Array index out of bounds: 60 from an array of size 36
0x00007ffdb619cf19 KERNELBASE.dll!UnknownFunction [].......
一、问题原因 “Lightmass crashed”在技术层面是由于Lightmass运算时数组越界造成的崩溃。简单来说,就是Lightmass在进行光照运算时,需要访问的数组索引超出了数组范围,导致程序崩溃。
造成这一问题的原因通常有:
1. 光照贴图分辨率过大,超过Lightmass所能处理的范围。
2. 系统内存不足,无法支持Lightmass的运算需求。
3. Lightmass进程冲突,多开swarm agent造成进程混乱。
二、解决方法 针对上述原因,可以从以下几点着手解决“Lightmass crashed”的问题:
1. 适当降低光照贴图的分辨率,比如从4096降到2048。
2. 升级系统内存,至少要确保有8GB以上RAM。
3. 清除Derived Data缓存,删除Cache文件夹重新构建。
4. 在Swarm Agent菜单中进行Cache清理和Validate验证。
打开 Swarm Agent &gt; Menu &gt; Cache &gt; Clean，单击清理，然后单击Validate验证。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/75d619155db3b14076519f87551b7ba3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd3c46a52c5024f31cf0155f8532097a/" rel="bookmark">
			【npm install 报错】npm ERR! code ENOENT No such file or dictionary, lstat [path] 解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里写自定义目录标题 安装 NextJS 框架的时候遇到了报错检查 node 版本和 npm 版本检查 AppData\Roaming 下的目录 安装 NextJS 框架的时候遇到了报错 检查 node 版本和 npm 版本 都没有报错，node 安装没有什么问题
检查 AppData\Roaming 下的目录 发现没有 npm 文件夹，新建一个空文件夹命名为 npm 以后再次运行npx create-next-app 命令以后，成功安装。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/624c0a9e5699e1c85bab8c950a7eebd3/" rel="bookmark">
			实验二十五、压控振荡电路的测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、题目 研究压控振荡电路输出波形频率随输入电压幅度的变化。
二、仿真电路 仿真电路如图1所示。集成运放采用 LM324AJ，其电源电压为 ±15 V。输入直流电压采用虚拟电压源，锯齿波才用函数发生器产生的锯齿波输出。
三、仿真内容 （1）分别测量 u I = − 6 V u_{\scriptscriptstyle I}=-6\,\textrm V uI​=−6V、 − 3 V -3\,\textrm V −3V 时 u O u_{\scriptscriptstyle O} uO​ 的频率，观察 u O 1 u_{\scriptscriptstyle O1} uO1​ 与 u O u_{\scriptscriptstyle O} uO​ 的波形。
（2）观察 u I u_{\scriptscriptstyle I} uI​ 幅值为 − 3 V ∼ − 15 V -3\,\textrm V\sim-15\,\textrm V −3V∼−15V 的锯齿波时 u O u_{\scriptscriptstyle O} uO​ 的波形。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/624c0a9e5699e1c85bab8c950a7eebd3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8f0489086544664d9907832f634038e/" rel="bookmark">
			axios 请求重试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在我的request.js 中 基于axios二次封装 添加
设置默认的重试次数和延迟时间
service.defaults.retry = 2; service.defaults.retryDelay = 2000; 在响应拦截器里 添加代码 所有经过这里的接口报错都会重试
// 判断是否配置了重试选项 if (config &amp;&amp; config.retry) { // 设置重试次数，默认为3次 config.retryCount = config.retryCount || 0; if (config.retryCount &lt; config.retry) { // 增加重试次数 config.retryCount += 1; // 创建新的Promise，延迟一段时间后进行重试 const retryPromise = new Promise((resolve) =&gt; { setTimeout(() =&gt; resolve(service(config)), config.retryDelay || 1000); }); // 返回重试的Promise return retryPromise; } } 可在我的请求中单独设置请求重试 retry 为0 次接口不重试
import request from "@/utils/request"; // export function plazaList(params, retry = 2, delay = 2000) { // return request({ // url: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b8f0489086544664d9907832f634038e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0ec086ad35fa29de2691969590625e3/" rel="bookmark">
			Endnote导出文献(包括组名和文件、笔记)到Zotero
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Endnote导出文献(包括组名和文件、笔记)到Zotero Endnote版本：Endnote X9
Zotero版本：6.0.26
找到Endnote的附件文件的存储位置，回到PDF文件夹的位置，并复制到目标文件夹（后续存储Zotero文献库的位置，如F:\zoreto）。Zerote软件中依次选择编辑、首选项。在高级中选择文件和文件夹，更改数据存储位置为F:\zoreto保留组名的方法：点开某一组的文献，全选该组的文献，选择导出为xml格式文件，注意下面勾选导出选中的文献，xml文件的名称设置为分组的名称。Zotero软件选择导入，选择文件导入，选择刚才导出的xml格式文件，按下图选择，然后下一步导入成功了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a282df0682d1b5dc2f28afe4b33f7a63/" rel="bookmark">
			MySQL 自增 ID 默认从 1 开始，如何设置自增 ID 从 0 开始
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL 是一种关系型数据库，它是世界上最流行的关系型数据库之一。在 MySQL 中，自增是一种非常有用的功能，它可以自动给主键赋值，并保证每个主键是唯一的。然而，许多人不知道的是，MySQL 默认情况下从 1 开始自增，这并不总是适合所有情况。
在 MySQL 中，我们可以通过在创建表时明确指定自增开始值和步长来更改自增值的初始值。例如：
CREATE TABLE example ( id INT AUTO_INCREMENT PRIMARY KEY, name VARCHAR(50) ) AUTO_INCREMENT=1000; 在上面的例子中，我们明确设置自增初值为 1000。这意味着在向 example 表插入第一条记录时，id 的值将是 1000，而不是默认值 1。
类似地，在更改步长时，我们可以这样做：
CREATE TABLE example ( id INT AUTO_INCREMENT PRIMARY KEY, name VARCHAR(50) ) AUTO_INCREMENT=1 INCREMENT BY 2; 在上面的例子中，我们将步长更改为 2。这意味着，在向 example 表插入第一条记录时，id 的值将为1，第二条记录为 3，第三条记录为 5，以此类推。
如果想设置自增 id 的值从 0 开始，同样可以通过设置 “AUTO_INCREMENT=0” 来实现。
CREATE TABLE test_table ( id INT(11) UNSIGNED NOT NULL AUTO_INCREMENT, data VARCHAR(255) NOT NULL, PRIMARY KEY (id) ) ENGINE=InnoDB AUTO_INCREMENT=0; 总之，MySQL 的自增特性非常有用，它可以自动为我们生成唯一的主键。然而，在某些情况下，我们可能需要更改自增初值和步长的默认值1。因此，我们只需要在创建表时明确指定即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c675c4ec8c8684d5fb6e7d1eddb668a1/" rel="bookmark">
			VUE中babel.config.js配置按需引入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VUE中babel.config.js配置 @vue/cli-plugin-babel/preset'是一款 babel 插件，它会在编译过程中将 import 引入自动转换为按需引入的方式。
module.exports = { presets: [ '@vue/cli-plugin-babel/preset' ], plugins: [ ['import', { libraryName: 'element-ui', libraryDirectory: 'es', style: true }, 'element-ui'] ] } presets：预置
plugins：插件
libraryName：库名
libraryDirectory：库目录
es：
注： 采用了 es6 module 的项目建议配置 libraryDirectory 为 es，即使用通过 import (es6 module) 引用模块的文件。这种情况打包后的体积要更小一些。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d673c6eae8008ef7ce7d81910a32568/" rel="bookmark">
			深度优先搜索（DFS、深搜）和广度优先搜索（BFS、广搜）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
深度优先搜索（DFS、深搜）和广度优先搜索（BFS、广搜）
深度优先搜索（简称“深搜”或DFS）
广度优先搜索
总结
深度优先生成树和广度优先生成树
非连通图的生成森林
深度优先生成森林
广度优先生成森林
深度优先搜索（DFS、深搜）和广度优先搜索（BFS、广搜） 深度优先搜索（简称“深搜”或DFS） 图 1 无向图
深度优先搜索的过程类似于树的先序遍历，首先从例子中体会深度优先搜索。例如图 1 是一个无向图，采用深度优先算法遍历这个图的过程为：
首先任意找一个未被遍历过的顶点，例如从 V1 开始，由于 V1 率先访问过了，所以，需要标记 V1 的状态为访问过；然后遍历 V1 的邻接点，例如访问 V2 ，并做标记，然后访问 V2 的邻接点，例如 V4 （做标记），然后 V8 ，然后 V5 ；当继续遍历 V5 的邻接点时，根据之前做的标记显示，所有邻接点都被访问过了。此时，从 V5 回退到 V8 ，看 V8 是否有未被访问过的邻接点，如果没有，继续回退到 V4 ， V2 ， V1 ；通过查看 V1 ，找到一个未被访问过的顶点 V3 ，继续遍历，然后访问 V3 邻接点 V6 ，然后 V7 ；由于 V7 没有未被访问的邻接点，所有回退到 V6 ，继续回退至 V3 ，最后到达 V1 ，发现没有未被访问的；最后一步需要判断是否所有顶点都被访问，如果还有没被访问的，以未被访问的顶点为第一个顶点，继续依照上边的方式进行遍历。 根据上边的过程，可以得到图 1 通过深度优先搜索获得的顶点的遍历次序为：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d673c6eae8008ef7ce7d81910a32568/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d24c8ae39dba83b7767fea62e5552d86/" rel="bookmark">
			spyglass之功耗分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 spyglass做power分析的意义 用于功耗分析的软件除了ptpx外，spyglass也可以。ptpx的功耗分析是基于netlist(网表)进行的，一般用于分析综合后的pre功耗和P&amp;R后的post功耗，但这已经是项目进行到比较后期了，如果后期发现功耗数据与我们目标功耗相差较大，则意味着需要功耗优化，这时有可能会将项目计划节点延迟。如果在前期designer可以获得设计模块的功耗数据，可提早优化功耗，spyglass则为designer提供了一个很好的手段去评估功耗，从而提前优化功耗。
2 准备工作 用spyglass做power分析推荐使用GUI界面，原因是在功耗分结束后，点击相应的goal时会出现相应分析结果的表格、图表，这些是功耗分析结果直观、清晰，符合我们平常的阅读理解习惯；在debug时也可以点击相应的fatal、error或者warning查看解决建议，方便debug。
在用GUI进行功耗分析前需准备如下文件：
2.1 RTL设计文件列表 RTL设计文件（.v文件）的文件列表（filelist）文件——这里用top_module.f举例，filelist里面包含了工程中所有的设计文件以及文件中内部include的文件，include的文件即使没有给出具体路径和具体的文件名字，也需要给出include文件的路径；文件中使用的define也需要在这里写出来。top_module.f的文件内容举例如下：
/具体路径/rtl/top_module.v
/具体路径/rtl/module_1.v
/具体路径/rtl/module_2.v
#include dir
+incdir+具体的路径1
+incdir+具体的路径2
#include define +define+RAM
+define+DELAY=0.1
2.2 所有器件的lib文件列表 工程中使用到的所有cell的lib均需要在这个文件中列出来，包括mem IO，即工程中使用到的器件，即在ptpx分析功耗时用到的所有db文件对应的lib文件。这里用lib_filelist.f举例表示，具体内容如下所示：
set lib_file [concat /xx/xxxx/xx_lib1.lib \
/xx/xxx/xx_lib.lib \
]
这里包含了mem、IO等所有cell，是因为在进行功耗估计时这些cell都是功耗器件，在有电时会产生功耗，必须把所有功耗估算进去才能更好的分析功耗、优化功耗。
2.3 RTL设计文件对应的SDC文件 在进行功耗分析时还需要时序文件，时钟对功耗的影响十分大，所以需要时序约束文件，若使用的时序约束文件是sdc文件，需要将sdc文件转换成sgdc文件，这样spyglass才能成功读入。这里用top_module.sgdc文件举例，内容如下：
current_design top_module
sdc_data -file top_module.sdc
2.4 用于功耗分析的fsdb波形文件 进行功耗分析需要读入波形文件，从而获取信号的活动情况。用于spyglass功耗分析的波形文件在生成时需要特别注意，波形文件的引用层级需要和spyglass读取波形时的-sim_topname的名字一致。下面给出仿真时生成spyglass功耗分析fsdb的命令。
$fsdbDumpfile("top_module.fsdb");
$fsdbDumpvars(100,"tb_top.top_module","+all");
3 在GUI界面里的执行过程 在terminal中使用如下命令打开spyglass的GUI界面：
&gt;spyglass &amp;
打开GUI界面后点击shell命令，在其中逐条输入如下命令：
1 set DESIN_TOP top_module
2 read_file -type sourcelist ./xx/xx/top_module.f
3 source -c ./xxx/xxx/top_module_lib.f
4 foreach i $lib_file { read_file -type gatelibs {i}}
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d24c8ae39dba83b7767fea62e5552d86/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/422280630ccf8b67bc26944d7d57163d/" rel="bookmark">
			(已解决)redis.get报错com.alibaba.fastjson.JSONException: autoType is not support
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		redis存取值问题，存自定义实体对象；
第一次取的时候报错：com.alibaba.fastjson.JSONException: autoType is not support。
GenericFastJsonRedisSerializer序列化和反序列化redis的value值，需要bean对象含有无参构造方法。
解决：
检查自定义实体对象是否有无参构造方法；添加有参构造后，jvm不会自动生成无参构造。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/280dac2b35a77504e1b15dbcae249003/" rel="bookmark">
			Python第三方库批量下载到本地，并离线批量安装第三方库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 鉴于公司内网安装的python版本为python3.6.5，而此时又需要安装第三方库pytest，本来是想直接在Python官网PyPI直接搜对应可匹配跑python3.6.5版本的pytest进行下载然后传到内网安装即可，但是发现pytest依赖别的第三方库，根据报错装了几个依赖的第三方库之后，发现还是一堆的问题，故索性在外网环境先安装一个python3.6.5版本的解释器，然后cmd命令行 pip install pytest,然后依据自动下载的第三方库，来确定python3.6.5安装推荐的pytest的版本以及pytest依赖的第三方库的名称及版本：
pip install pytest 在桌面上新建个保存第三方库的目录：softwares，然后我这里将当前python3.6.5解释器安装的所有第三方库都导出输出到该目录下的requirements.txt中：
python -m pip freeze &gt; requirements.txt 然后剔除当前pytest版本不需要的依赖，保留当前pytest所需要安装的所有第三方库名称及版本号：
然后通过国内源下载上面统计的所需要的第三方库：
pip download -r requirements.txt -i https://pypi.tuna.tsinghua.edu.cn/simple/ 下载好了，之后将这些whl后缀的第三方库文件，传到内网，通过cmd直接 pip install xxx就可以啦。
批量安装本地安装包:
pip install --no-index --ignore-installed --find-links=C:/Users/SSCC/Desktop/softwares -r requirements.txt 好了，今天的分享就到这里！如果你对Python感兴趣，想要学习pyhton，这里给大家分享一份Python全套学习资料，里面的内容都是适合零基础小白的笔记和资料，超多实战案例，不懂编程也能听懂、看懂。
学习资源推荐 除了上述分享，如果你也喜欢编程，想通过学习Python获取更高薪资，这里给大家分享一份Python学习资料。
😝朋友们如果有需要的话，可以点击下方链接免费领取或者V扫描下方二维码免费领取🆓
👉CSDN大礼包🎁：全网最全《Python学习资料》免费赠送🆓！（安全链接，放心点击）
学好 Python 不论是就业还是做副业赚钱都不错，但要学会 Python 还是要有一个学习规划。最后大家分享一份全套的 Python 学习资料，给那些想学习 Python 的小伙伴们一点帮助！
因篇幅有限，仅展示部分资料，添加上方即可获取 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4d5e6c4cd5140ca0e2db1f3ce3d5bf1/" rel="bookmark">
			随机过程及应用提纲
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随机过程及应用 一、概率论基础1. 三元体定义2. 随机变量及其分布1. 离散随机变量2. 连续型随机变量 3. 常见的随机变量和分布1. 离散类2. 连续类 4. 二维连续随机变量1. 二维离散2. 二维连续 5. 随机变量函数的分布1. 离散（可浅看）2. 一维连续 r.v 函数分布（重要）3. 二维随机变量的变换 6. 随机变量的数字特征1. 数学期望1. 定义2. 性质 2. 方差1. 定义2. 性质 3. 协方差4. 随机变量数字特征的性质 7. 特征函数 二、随机过程的基本概念2. 随机过程的分布及其数字特征1.分布函数和概率密度2. 数字特征 三、几种重要的随机过程1. 独立过程与独立增量过程2. 正态过程（高斯过程）3. 维纳过程4. 泊松过程 四、马尔可夫过程1. 离散-齐次马尔可夫链2. 随机游动例子3. 求解初始分布、绝对分布、平稳分布等4. 状态转移图5. 生灭过程6. 生灭过程在排队论的应用 五、均方微积分1. 均方极限 六、平稳过程0. 宽平稳和严平稳的关系1. 平稳过程的概念2. 平稳过程及其相关函数的性质3. 平稳过程的均方遍历性（有时间做一下）4. 平稳过程的谱密度5. 线性系统中的平稳过程6. 平稳窄带随机过程 只适用于 CUIT 电子信息 杜江老师 的随机过程及应用课
一、概率论基础 1. 三元体定义 2. 随机变量及其分布 分布函数定义及性质：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b4d5e6c4cd5140ca0e2db1f3ce3d5bf1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29e3025fea73eb327f5040064bace798/" rel="bookmark">
			数字信号复习题纲
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数字信号复习题纲 一、希尔伯特变换器（:heavy_check_mark: ）1. 什么是希尔伯特变换器？2. 试证明信号通过希尔伯特变换器后的输出 二、能量信号的自相关函数、卷积运算与能量谱（:heavy_check_mark:）1. 能量信号（科普的）2. 试证明自相关函数运算与卷积运算的关系（背就好）3. 试证明自相关函数的傅里叶变换是能量谱，即信号幅度谱的平方（背就好） 三、FIR 滤波器（:heavy_check_mark:）1. 相关概念2. 重要结论 四、DFT 与 FFT（:heavy_check_mark:）0. 循环卷积0.5 蝶形运算单元公式1. 画 4 点基 2-DIT（时域抽取）-FFT 和基 2-DIF（频域抽取）-FFT 流图1. 4点 DIT-FFT2. 4点 DIF-FFT 2. 画 8 点基 2-DIT（时域抽取）-FFT 和基 2-DIF（频域抽取）-FFT 流图1. 8点DIT-FFT2. 8点DIF-FFT 3. 会手算有限长序列的 DFT 五、z 逆变换（:heavy_check_mark: ）0. z变换的基本性质和常用变换对1. 求z逆变换2. 根据 H(z) 表达式写出零极点、收敛域3. 会判断在何收敛域情况下， 是因果的/非因果的，以及稳定的/不稳定的4. 系统响应求解 六、用 DFT 估计频谱（:heavy_check_mark: ）七、低通数字滤波器设计1.设计步骤2. 注意点3. 计算流程1. 巴特沃斯求H~s~(s)2. 使用 脉冲响应法求 H(z)3. 使用双线性变换法 八、序列抽取与插值（:heavy_check_mark: ）1. 如何用数学表达式和框图表示 L 倍抽取？ 九、随机信号的基本概念（:heavy_check_mark: ）1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29e3025fea73eb327f5040064bace798/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37a3c4eccef93db95cbb1a730a660ff5/" rel="bookmark">
			电分糊涂日记之《一阶电路的时域分析》
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一阶电路的时域分析 一、动态元件1. 电容元件1.电容概述2.电容元件的VCR 2. 电感元件1.电容概述2.电感元件的VCR 3. 电容与电感元件的串并联1.电容元件串联等效2.电容元件并联等效3.电感元件串并联等效 二、一阶电路的零输入响应分析1. 电路的初始值1. 独立初始值：电容电感的初始值2. 非独立初始值：电阻的初始值 2. RC电路零输入响应3. RL电路零输入响应 三、一阶电路的零状态响应分析1. RC电路零状态响应2. RL电路零状态响应 四、全响应1. 三要素法 五、阶跃与冲击响应1. 阶跃响应1.阶跃函数2.阶跃响应 2. 冲激响应1.一阶RC电路的冲激响应2.一阶RL电路的冲激响应 后面的各种响应其实都是由 电容、电感的伏安特性衍生和推论出来的； 一定要掌握好动态元件的 电容电感的 输入输出电流关系 一、动态元件 1. 电容元件 1.电容概述 电路理论中的 电容元件 是实际 电容器 的理想化模型。电容器由介质隔开的两个金属极板组成，它是一种能存储电荷的器件，电荷依靠电场力的作用聚集在极板上，具有储存电场能量的作用，本身不消耗能量。电容元件常用于收音机接收器的调谐电路、计算机系统的动态存储单元等电路中。 2.电容元件的VCR 在电路分析中，常用电路元件的VCR来描述元件的特性，并建立电路方程。设电容元件电压与电流为关联参考方向，可以得到
【 电路图如下】
第一种关系：
第二种关系：
两种关系其实就是一个微积分的关系，移项一下微积分就能推出来了。
当电容电压和电流取关联参考方向时，电容的功率为
电路图：
功率：
能量计算就是 p（t）的时间积分就行；在时间 t0 到 t 期间，电容电压由 uc(t0) 变为 uc(t)，电容元件吸收的能量为
能量：
记住 WC (t0 , t) = 1 / 2 * C * [ u2C(t) - u2C(t0) ]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37a3c4eccef93db95cbb1a730a660ff5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe95c8553c154700cf2a34f11945235e/" rel="bookmark">
			实验2 电磁波的极化实验 matlab仿真
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		电磁波的极化实验 1、 实验内容：2、 实验源码： 1、 实验内容： 2、 实验源码： 实验内容一 Exm = 3; % x分量幅值 Eym = 3; % y分量幅值 w = 10; % 角频率 z0 = 0; % 起始位置 x = 0:0.01:3; % x轴坐标取样 m0 = zeros(size(x)); % 与x取样序列规模相同的0序列 Qx = 0; %x分量初相角 Qy = pi; %y分量初相角 Qy - Qx = 0, pi时 figure for t=0:500 Ex = Exm*cos(w*x+w*t*1e-2+Qx); % 计算 x方向幅值瞬时序列 Ey = Eym*cos(w*x+w*t*1e-2+Qy); % 计算 y 方向幅值瞬时序列 plot3(x,m0,m0,'black','LineWidth',3); %画参考轴线 hold on plot3(x, m0, Ex,'m','LineWidth', 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe95c8553c154700cf2a34f11945235e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c273e4cb1400a4b2a80bbf26d36ce614/" rel="bookmark">
			使用有限差分法求解无限长直的金属槽内的电位分布
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用有限差分法求解无限长直的金属槽内的电位分布 实验内容：实验源码：实验截图 实验内容： 使用有限差分法求解无限长直的金属槽内的电位分布
实验源码： %控制宽度 Length = 50; %长度 Width = 50; %宽度 Height = 1:1:50; %控制轴的位置 Var_Xz = 25; Var_Yz = 10; Values1 = zeros(Width,Length); %构造一个Width * Length的0矩阵 for m1 = 1 : Length %将金属板盖设置为100V Values1(Width,m1)=100; end m=1;t=0;k=0; Values2 = Values1; while(m&gt;0.001) m=0; k=k+1; %迭代次数 %看做为网格，就是计算完成一个网格里的所有值与最初始的值对比误差 for i=2:Width-1 %控制行；计算列值 for j=2:Length-1 %控制列；计算行值 Values2(i,j)= (Values1(i,j+1) + Values1(i+1,j) + Values1(i-1,j) + Values1(i,j-1)) / 4; t=(Values2(i,j) - Values1(i,j)); % v2 与 v1 偏差 if(t&gt;m) %精度比较控制 m=t; end end end Values1=Values2; end %xoy面等势线截面 subplot(2,3,[1,2]); contour(Values2,40); %矩阵的等高线图 xlabel("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c273e4cb1400a4b2a80bbf26d36ce614/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc3fc37e678f9b904c876356755dd0df/" rel="bookmark">
			指针与字符串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		指针与字符串 一、字符串基础1、字符串声明2、字符串字面量池3、字符串初始化1、初始化字符数组2、初始化字符指针3、从其他输入初始化字符串4、字符串位置小结 二、标准字符串操作1、比较字符串2、复制字符串3、拼接字符串 三、传递字符串1、传递简单字符串2、传递字符常量的指针3、传递需要初始化的字符串4、给应用程序传递参数 四、返回字符串1、返回字面量的地址2、返回动态分配内存的地址 导读： 字符串可以分配在内存的不同区域，通常使用指针来支持字符串操作。指针支持动态分配字符串和将字符串作为参数传递给函数。 了解声明和初始化字符串的不同方法，研究C程序中字面量池的使用及其影响。此外，我们还会了解比较、复制和拼接字符串等常见字符串操作。
字符串通常以字符指针的形式传递给函数和从函数返回。我们可以用字符指针传递字符串，也可以用字符常量的指针传递字符串，后者可以避免字符串被函数修改。
我们也可以从函数返回字符串，从而满足某个请求。可以将这个字符串从外面传给函数并由函数修改，也可以在函数内部分配，还可以返回静态分配的字符串。
指针是保存字符串地址的。我们可以使用地址索引和接引数据的。
一、字符串基础 字符串是以ASCII字符NUL结尾的字符序列。ASCII字符NUL表示为 \0。字符串通常存储在数组或者从堆上分配的内存中。不过，并非所有的字符数组都是字符串，字符数组可能没有NUL字符。字符数组也用来表示布尔值等小的整数单元，以节省内存空间。C语言中有两种字符串
单字节字符串
由char数据类型组成的序列。宽字符串
由wchar_t数据类型组成的序列。 1、字符串声明 声明字符串的方式有三种：字面量、字符数组 和 字符指针。字符串字面量是用双引号引起来的字符序列，常用来进行初始化，它们位于字符串字面量池中。
声明例子如下：
//栈区字符串 char header[32]; //保存字符串的指针 char *header; 2、字符串字面量池 字符串字面量一般分配在只读内存中 (但最好显示声明字符串不可修改)，所以是不可变的。字符串字面量在哪里使用，或者它是全局、静态或局部的都无关紧要，从这个角度讲，字符串字面量不存在作用域的概念。
const char*tabHeader="Media Player"; *tabHeader='L'; //会报错，不能休该 内存示意图：
3、字符串初始化 1、初始化字符数组 //第一种：直接字符字面量赋值 char header[]="Media Player"; //第二种：使用字符操作函数 char header[13]; strcpy(header,"Media Player"); //第三种：逐个赋值 header[0]='M'; header[1]='e'; header[12]='\0'; 2、初始化字符指针 在使用malloc函数分配空间后，这个内存空间不会主动设置字符串结尾的标志 都是要手动设置的。
一定要存在正确的字符串分配地址【不可未分配地址就赋值】一定要记得算上终结符NUL。不要用sizeof操作符，而是用strlen函数来确定已有字符串的长度。
sizeof操作符会返回数组和指针的长度，而不是字符串的长度。 //使用malloc函数分配空间 char *header=(char*)malloc(strlen("Media Player")+1); //第一种：直接字符字面量赋值 char*header="Media Player"; //第二种：使用字符拷贝函数和字面量赋值 strcpy(header,"Media Player"); //第三种：逐个赋值 *(header+0)='M'; *(header+1)='e'; .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fc3fc37e678f9b904c876356755dd0df/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a14361bd3117ace3e4c2323de146fa4/" rel="bookmark">
			Xftp上传文件出现中文乱码问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.问题描述
我们在使用Xftp的时候，可能会遇到上传文件出现中文乱码，如下图所示：
2.解决乱码——设置编码格式为UTF-8
设置编码为UTF-8 重启xftp,乱码问题解决。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7efa918d703be4c11bb6b96efdc940f6/" rel="bookmark">
			【Bug解决】1、Nacos启动成功，但却无法访问（提示：无法访问此网站，192.168.10.133的响应时间过长）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 项目场景： 在虚拟机上通过Docker创建Nacos容器，已经创建成功，查看Nacos启动日志也是成功。但通过端口号加8848/nacos（如：http://192.168.88.10:8848/nacos）无法访问到Nacos管理页面。
问题描述 原因分析： 服务器或虚拟机未开放8848端口
解决方案： 开放8848端口
1、开启防火墙
systemctl start firewalld 2、查询8848端口是否开放
firewall-cmd --query-port=8848/tcp 3、开放8848端口
firewall-cmd --add-port=8848/tcp --permanent 4、重载入添加的端口
firewall-cmd --reload ❀ 移除指定端口
firewall-cmd --permanent --remove-port=8848/tcp ❀ 关闭防火墙
systemctl stop firewalld 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a216d83df2ef217441428194d043e23a/" rel="bookmark">
			源码包安装apache
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先了解源码包安装的基本步骤： 1，下载编译器，由于大部分软件的源代码都是由c语言编写的，所以需要下载gcc编译器（可以通过gcc -v检查gcc是否成功安装，可以看到版本号即成功安装）
2，下载压缩包 → 解压→ 进入目录
3，执行./configure 此处可能会需要配置相关依赖（可以通过--help查看依赖的写法）
/usr/local是默认的源码包安装的位置
4，make &amp;&amp; make install 编译并安装
开始安装： 一，下载gcc： 通过yum安装gcc即可，看到下图即为安装成功
二，下载httpd压缩包并解压 可以通过wget直接在linux内下载也可以在windows下下载好后将压缩包上传到linux内
apache官网：Welcome! - The Apache HTTP Server Project
最好将压缩包单独建一个目录，后续还会有其他依赖需要下载
将httpd压缩包解压后进入httpd目录
三，执行./configure 可以看到缺失apr，去下载并解压apr和apr-util，这是之后需要的依赖： 首先进入apr目录： 执行./configure：（不带参数执行./cionfigure会安装到默认目录/usr/local下）
可以看到以上结果，不影响后续操作，只要查看当前文件夹内是否有Makefile文件即可，有就代表执行成功
再执行make &amp;&amp; make install ,安装不报错后可以在/usr/local下查看是否有apr目录，有就代表安装成功：
再进入httpd目录执行./configure --with-apr=/usr/local/apr: 会看到缺失apr-util,所以返回apr-util目录（前面提到要下载的）： 执行 ./configure --prefix=/usr/local/apr-util --with-apr=/usr/local/apr 此处需要指定安装路径，因为依赖的原因apr-util无法默认下载到/usr/local/
再执行make &amp;&amp; make install
再进入httpd目录 执行 ./configure --prefix=/usr/local/apache --with-apr=/usr/local/apr --with-apr-util=/usr/local/apr-util
会报错，yum缺失即可
重新执行上面语句，再make &amp;&amp; make install，即为安装成功：
四，启动apache测试功能： 进入apache目录，执行./bin/httpd
查看进程和测试连接：
以上代表apache可以正常运行，但此时无法从浏览器打开，需要关闭防火墙
查看防火墙状态并关闭防火墙：（之前是关闭则不影响）
输入ip即可验证：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6815810631f767eab0e589c8281cf63c/" rel="bookmark">
			C语言实现16k、48kpcm数据的双向重采样
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 注意事项重采样代码int16_t数据溢出测试代码测试结果 注意事项 音频重采样过程中使用有符号数，确保计算过程正确。在48k-&gt;16k的下采样过程中，3个采样点数据相加取平均值不用担心溢出问题。已使用测试代码确认在Linux、Windows均正常。 重采样代码 /** * @brief Resample audio from 16kHz to 48kHz * * @param src_data pointer to src data * @param len length of src data * @param channel channel count of src data * @param dst_data pointer to destination data, caller shoud allocate enough * buffer to store */ static void prv_rtc_resample_16k_to_48k(const uint8_t *src_data, int len, int channel, uint8_t *dst_data) { const int16_t *src_data_index = (const int16_t *)src_data; int16_t *dst_data_index = (int16_t *)dst_data; const int samples = len / (channel * (sizeof(int16_t) * sizeof(uint8_t))); for (int i = 0; i &lt; samples; i++) { for (int j = 0; j &lt; channel; j++) { dst_data_index[i * 3 * channel + j * 3 + 0] = src_data_index[i * channel + j]; dst_data_index[i * 3 * channel + j * 3 + 1] = src_data_index[i * channel + j]; dst_data_index[i * 3 * channel + j * 3 + 2] = src_data_index[i * channel + j]; } } } /** * @brief Resample audio from 48kHz to 16kHz * * @param src_data pointer to src data * @param len length of src data * @param channel channel count of src data * @param dst_data pointer to destination data, caller shoud allocate enough * buffer to store */ static void prv_rtc_resample_48k_to_16k(const uint8_t *src_data, int len, int channel, uint8_t *dst_data) { const int16_t *src_data_index = (const int16_t *)src_data; int16_t *dst_data_index = (int16_t *)dst_data; const int samples = len / (3 * channel * (sizeof(int16_t) * sizeof(uint8_t))); for (int i = 0; i &lt; samples; i++) { for (int j = 0; j &lt; channel; j++) { dst_data_index[i * channel + j] = (src_data_index[i * 3 * channel + j * 3 + 0] + src_data_index[i * 3 * channel + j * 3 + 1] + src_data_index[i * 3 * channel + j * 3 + 2]) / 3; } } } int16_t数据溢出测试 代码 #include &lt;stdio.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6815810631f767eab0e589c8281cf63c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f9abd957c437b107c11b503c8ca5f21/" rel="bookmark">
			Nginx配置一个域名多端口&#43;HTPPS协议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要 食用须知：本文档详细配置了关于Nginx的HTTPS的配置，是在一台服务器上监听多个端口，并且只有一个域名的情况下，配置多个端口号采用HTTPS的方式发送请求。
说明 我们先来说说HTTP和HTTPS的区别
HTTP（超文本传输协议）和HTTPS（安全HTTP）是用于在客户端和服务器之间传输数据的两种不同协议。它们之间的主要区别在于安全性。有以下几点区别。
安全性：HTTP是明文协议，数据在传输过程中是以明文形式发送的，容易被窃听和篡改。而HTTPS通过使用TLS（传输层安全）协议对通信进行加密，确保数据传输的机密性和完整性。HTTPS使用公钥加密和私钥解密的方式，使得数据在传输过程中更加安全。
数据传输方式：HTTP使用默认端口80进行通信，而HTTPS使用默认端口443。HTTP的数据传输速度通常比HTTPS快一些，因为HTTPS需要进行加密和解密的过程，会增加一定的计算负担和传输延迟。
证书要求：为了在网站上使用HTTPS，需要获取并安装SSL/TLS证书。这个证书是由经过合法认证的证书颁发机构（CA）签发的，用于验证服务器身份的数字凭证。而HTTP不需要使用证书。
SEO（搜索引擎优化）：搜索引擎通常更喜欢安全的HTTPS网站，在搜索结果中更有可能获得更好的排名。因此，使用HTTPS可以提高网站的可见性和信誉度。
到此我们就明白了为什么要采用HTTPS的协议来发送请求，因为它相对更安全。安全肯定是首位
上述提到了SSL/TLS证书，需要相关人去申请，我们只需要拿到申请的证书做事就可以啦 。
添加ssl证书 当我们拿到ssl证书的时候，我们可以去到nginx的目录下新建一个文件夹cert(mkdir cert)，把相关的证书上传到这个文件夹，一般是两个，一个是.key文件，一个是.pem文件。
配置nginx.conf 1.通过命令找到nginx的位置 whereis nginx 2.切换到/nginx/conf目录 3.配置nginx采用HTTPS协议 如果你需要监听443端口，可以按照如下配置，添加的server配置是在http{}下。
server { listen 443 ssl;#必须加上ssl server_name xxx.com.cn; #可以是域名，可以是ip #charset koi8-r; #access_log logs/host.access.log main; root /var/www/html/test/web; # nginx的访问目录 index index.html index.htm; #首选文件 #设置文件上传大小 client_max_body_size 100m; #配置ssl协议 ssl_certificate /usr/local/nginx/cert/xxx.pem; #ssl证书路径 ssl_certificate_key /usr/local/nginx/cert/xxx.key; #ssl证书路径 ssl_session_timeout 5m; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE; ssl_prefer_server_ciphers on; location / { try_files $uri $uri/ /index.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f9abd957c437b107c11b503c8ca5f21/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6b9d74ce0f88ddecaecc7d0f79d4feb/" rel="bookmark">
			SuperMap iDesktopX 11i 之数据版本管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1. 简介2. 环境准备3. 系统表4. 使用详情4.1. 注册版本4.2. 版本管理4.3. 更新和冲突处理4.4. 提交变更4.5. 历史时刻 5. 总结 1. 简介 SuperMap iDesktopX 和 SuperMap iOjects Java 从 11.1.0 正式版开始提供数据版本管理功能，支持多人协同编辑同一数据集，可隔离多个编辑数据会话，支持同步数据、自动存档、历史回溯。适用于土地利用调查、图斑更新等需多人协助完成的工作。
数据版本管理操作流程
注册版本 创建版本 版本内编辑 版本协调 版本提交 操作说明注册版本 使用版本管理功能，首先必须对数据集注册版本，注册的过程被称为版本化。当前支持对点、线、面、文本、属性表、CAD数据集版本化创建版本 版本表示整个数据源的在某一时刻的快照，一个版本的数据包含数据源下的所有数据集，包括版本化和非版本化数据，创建版本后可分发版本进行多人编辑版本内编辑 可以在创建的子版本内新增、删除对象记录，编辑单个对象的属性和几何信息，但不允许在子版本下对字段值批量编辑，当前仅支持在default版本下对字段值批量编辑，且子版本不存在未提交的变更版本协调 可以在任意时刻提交变更到default版本，提交前，为了防止其他用户对同一数据也进行了变更而发生冲突，需要进行版本协调处理版本提交 将当前编辑版本下的数据变更合并至目标版本，只有在完成协调操作后未对目标版本做出任何修改时，才能完成提交操作 2. 环境准备 产品版本下载地址SuperMap iDesktopX11.1.0 及以上版本iDesktopX 下载地址SuperMap iObjects11.1.0 及以上版本iObjects 下载地址PostGIS2.3.5 及以上版本PostGIS 下载地址Yukon1.0 及以上版本Yukon 下载地址 3. 系统表 SuperMap 数据版本管理功能主要基于 7 张系统表实现：
版本信息表
SMVERSIONS SmVersionID（PK） SmOwner SmVersionName SmDescription SmAccess SmCreationTime SmModifyTime 版本历史信息表
SMVERSIONITEMS SmVersionItemID（PK） SmVersionID（FK） SmHistoryMarkName SmStartTime SmEndTime 数据集注册表
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6b9d74ce0f88ddecaecc7d0f79d4feb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7350a835bab892cef1162cc9b06b0b3/" rel="bookmark">
			node 版本与 node-sass node-loader 版本的对应关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		node 版本与 node-sass 版本的对应关系：
其一、查看文档的地址：
https://www.npmjs.com/package/node-sass
其二、对应关系的表格：
对应版本
node16
“node-sass”: “6.0.1”
“sass-loader”: “10.2.0”
node: v14.19.0;
node-sass: ^4.14.1;
sass-loader: ^7.3.1;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7eb5b6c7023456fe04a677dee5d3130c/" rel="bookmark">
			熟读代码简洁之道，为什么我还是选择屎山
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：蚂小蚁
原文：https://juejin.cn/post/7255686239756533818
代码简洁仍然是一个程序员的基本素养，大家也都对屎山代码非常关注；但是关注归关注，执行起来却非常困难；我明明知道这段代码的最佳实践，但是我就是不那样写，因为我有很多难言之隐；
没有严格的卡口 没有约束就没有行动，比方说eslint，eslint只能减少很少一部分屎山，而且如果不在打包机器上配置eslint的话那么eslint都可以被绕过；对我个人而言，实现一个需求，当然是写屎山代码要来的快一些，我写屎山代码能够6点准时下班，要是写最佳实践可能就要7点甚至8点下班了，没有人愿意为了代码整洁度而晚一点下班的。
没有CodeReview，CodeReview如果不通过会被打回重新修改，直到代码符合规范才能提交到git。CodeReview是一个很好地解决团队屎山代码的工具，只可惜它只是一个理想。因为实际情况是根本不可能有时间去做CodeReview，连基本需求都做不完，如果去跟老板申请一部分时间来做CodeReview，老板很有可能会对你进行灵魂三连问：你做为什么要做CodeReivew？CodeReview的价值是什么？有没有量化的指标？对于屎山代码的优化，对于开发体验、开发效率、维护成本方面，这些指标都非常难以衡量，它们对于业务没有直接的价值，只能间接地提高业务的开发效率，提高业务的稳定性，所以老板只注重结果，只需要你去实现这个需求，至于说代码怎么样他并不关心；
没有代码规约 大厂一般都有代码规约，比如：2021最新阿里代码规范（前端篇）[1]、百度代码规范[2]
但是在小公司，一般都没有代码规范，也就是说代码都无章可循；这种环境助长了屎山代码的增加，到头来屎山堆得非常高了，之后再想去通过重构来优化这些屎山代码，这就非常费力了；所以要想优化屎山代码光靠个人自觉，光靠多读点书那是没有用的，也执行不下去，必须在团队内形成一个规范约定，制定规约宜早不宜迟
没有思考的时间 另外一个造成屎山代码的原因就是没时间；产品经理让我半天完成一个需求，老大说某个需求很紧急，要我两天内上线；在这种极限压缩时间的需求里面，确实没有时间去思考代码怎么写，能cv尽量cv；但是一旦养成习惯，即使后面有时间也不会去动脑思考了；我个人的建议是不要总是cv，还是要留一些时间去思考代码怎么写，至少在接到需求到写代码之前哪怕留个5分钟去思考，也胜过一看到需求差不多就直接cv；
框架约束太少 越是自由度高的框架越是容易写出屎山代码，因为很多东西不约束的话，代码就会不按照既定规则去写了；比如下面这个例子： stackblitz.com/edit/vue-4a…[3]
这个例子中父组件调用子组件，子组件又调用父组件，完全畅通无阻，完全可以不遵守单向数据流，这样的话为了省掉一部分父子组件通信的逻辑，就直接调用父组件或者子组件，当时为了完成需求我这么做了，事后我就后悔了，极易引起bug，比如说下一次这个需求要改到这一部分逻辑，我忘记了当初这个方法还被父组件调用，直接修改了它，于是就引发线上事故；最后自己绩效不好看，但是全是因为自己当初将父子组件之间耦合太深了；
自己需要明白一件事情那就是框架自由度越高，越需要注意每个api调用的方式，不能随便滥用；框架自由不自由这个我无法改变，我只能改变自己的习惯，那就是用每一个api之前思考一下这会给未来的维护带来什么困难；
没有代码质量管理平台 没有代码质量管理平台，你说我写的屎山，我还不承认，你说我代码写的不好，逻辑不清晰，我反问你有没有数据支撑
但是当代码质量成为上线前的一个关键指标时，每个人都不敢懈怠；常见的代码质量管理平台有SonarQube[4]、DeepScan[5]，这些工具能够继承到CI中，成为部署的一个关键环节，为代码质量保驾护航；代码的质量成为了一个量化指标，这样的话每个人的代码质量都清晰可见
最后 其实看到屎山代码，每一个人都应该感到庆幸，这说明有很多事情要做了，有很多基建可以开展起来；推动团队制定代码规约、开发eslint插件检查代码、为框架提供API约束或者部署一个代码质量管理平台，这一顿操作起来绩效想差都差不了；
参考资料 [1] https://developer.aliyun.com/article/850913: https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.aliyun.com%2Farticle%2F850913
[2] https://github.com/ecomfe/spec: https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fecomfe%2Fspec
[3] https://stackblitz.com/edit/vue-4af73c?file=src%2FApp.vue: https://link.juejin.cn?target=https%3A%2F%2Fstackblitz.com%2Fedit%2Fvue-4af73c%3Ffile%3Dsrc%252FApp.vue
[4] https://www.sonarsource.com/products/sonarqube/: https://link.juejin.cn?target=https%3A%2F%2Fwww.sonarsource.com%2Fproducts%2Fsonarqube%2F
[5] https://deepscan.io/: https://link.juejin.cn?target=https%3A%2F%2Fdeepscan.io%2F
最后 如果你觉得这篇内容对你挺有启发，我想邀请你帮我个小忙：
点个「喜欢」或「在看」，让更多的人也能看到这篇内容
我组建了个氛围非常好的前端群，里面有很多前端小伙伴，欢迎加我微信「sherlocked_93」拉你加群，一起交流和学习
关注公众号「前端下午茶」，持续为你推送精选好文，也可以加我为好友，随时聊骚。
点个喜欢支持我吧，在看就更好了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c6ee4dd64b5771bdf6c691e01f77dbc/" rel="bookmark">
			sweetviz工具避坑和简单使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网上关于sweetviz的文章比较少，有些坑这里说一下给大家避坑。
使用sweetviz遇到的错误如下：
KeyError: “None of [‘index’] are in the columns”AttributeError: ‘DataFrame’ object has no attribute ‘iteritems’ （ iteritems在pandas 2.0+中改为items() ）AttributeError: module ‘numpy’ has no attribute ‘warnings’ 解决方法：
都是版本导致的问题，用老版本可以解决，下面是我用的版本。博主没有深究根本原因，感兴趣的可以网络搜索搜索。
pip install pandas==1.5.3 pip install numpy==1.23.4 改完报错就可以愉快的使用sweetviz了，用sweetviz做EDA还是挺香的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5dc861e79d017e23d6953f586afe34a/" rel="bookmark">
			C语言编程：最小二乘法拟合直线
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文研究通过C语言实现最小二乘法拟合直线。
文章目录 1 引入2 公式推导3 C语言代码实现4 测试验证5 总结 1 引入 最小二乘法，简单来说就是根据一组观测得到的数值，寻找一个函数，使得函数与观测点的误差的平方和达到最小。在工程实践中，这个函数通常是比较简单的，例如一次函数或二次函数。
汽车上的毫米波雷达可以探测到其他目标车辆，通过最小二乘法拟合目标车辆历史点，可以简单地预测目标汽车未来的走向。
后文会推导最小二乘法拟合直线，并通过C语言实现，最后进行简单的验证。对于二次及更高次多项式的拟合，采用类似的方法。
2 公式推导 作为工程应用，推导公式不需要像数学上的那么抽象，只需要针对当前需求推导即可。
首先，需要拟合的方程为一次函数：
y = a x + b y = ax + b y=ax+b
并且已知n个观测点：
( x 1 , y 1 ) , ( x 2 , y 2 ) , . . . ( x n , y n ) (x_{1}, y_{1}),(x_{2}, y_{2}),...(x_{n}, y_{n}) (x1​,y1​),(x2​,y2​),...(xn​,yn​)
则拟合的误差的平方和为：
E ( a , b ) = ∑ i = 1 n ( a x i + b − y i ) 2 E(a,b)=\sum_{i=1}^n\left({{}}a{{x}}{}_{{i}}+b-{{y}}{}_{{i}}\right)^2 E(a,b)=i=1∑n​(axi​+b−yi​)2
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5dc861e79d017e23d6953f586afe34a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5da20c3824787cc8f4dec1568f564413/" rel="bookmark">
			实验二十九、正弦波变锯齿波电路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、题目 将峰值为 1 V 1\,\textrm V 1V、频率为 100 Hz 100\,\textrm{Hz} 100Hz 的正弦波输入电压，变换为峰值为 5 V 5\,\textrm V 5V、频率为 200 Hz 200\,\textrm {Hz} 200Hz 的锯齿波电压。利用 Multisim 对所设计的电路进行仿真、修改，直至满足设计要求。
二、设计思路 设计方案方框图如图1所示。
图 1 设计方框图 图1\,\,设计方框图 图1设计方框图
三、仿真电路 仿真电路如图2所示。
图 2 仿真电路 图2\,\,仿真电路 图2仿真电路
四、输出波形 图 3(a) 所示为三角波变锯齿波电路输入电压与输出电压的波形，为了便于观察，在两个波形上分别加了不同的偏压。图（b）所示为输入正弦信号与输出锯齿波的波形。
( a ) (a) (a)
( b ) (b) (b) 图 3 仿真波形 图3\,\,仿真波形 图3仿真波形
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/823cee12ea49b643132d88ef6c9a4cae/" rel="bookmark">
			我的分享：第三章：SpringCloud五大组件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		个人觉得他写的还是比较好的，所以我就不写重复的了，给上博客地址：Spring Cloud原理详解_springcloud_Java程序员-张凯的博客-CSDN博客Cloud
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/025cf69227904c707181abf1278901bb/" rel="bookmark">
			Vue项目中请求接口数据，返回的是__ob__: Observer，无法取值问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 造成这种原因，是因为__ob__: Observer 是 Vue 对数据监控添加的属性，说明这个数据是异步获取的。
可以使用Object.assign()方法。 let newarr = Object.assign([], res.data.data.roomStatus).map(item =&gt; { return Object.assign({},item) }) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98edc80ae1a83056e144c1330b6dec93/" rel="bookmark">
			Zabbix监控Kubernets获取节点模板报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Preprocessing failed for: {“error”:"Request failed with status code 401: {“kind”:“Status”,“apiVersion”:“v1”,"met ad …1. Failed: Discovery error: TypeError: cannot read property 1 of null.
Zabbix 监控 Kubernetes 出现采集错误，导致一直不能自动发现Node，移动到红色感叹号会出现如下错误：
....cannot read property 1 of null.
通过Zabbix自带的 Test item 就可以确认这个问题。如图所示：
原因：
解决方式：
在 宏变量中携带端口号即可，即使已经标明 https，也需要带 443 端口
Reference https://www.zabbix.com/forum/zabbix-troubleshooting-and-problems/459446-aks-monitoring-problem
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/461fba2a964772ca1647417100f2f47c/" rel="bookmark">
			Python采集天气数据，做可视化分析【附源码】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		嗨害大家好鸭！我是小熊猫~ 毕业设计大家着急吗？
没事，我来替大家着急
源码、素材python永久安装包:点击此处跳转文末名片获取
本文知识点: 动态数据抓包
requests发送请求
结构化+非结构化数据解析
开发环境: python 3.8 运行代码
pycharm 2021.2 辅助敲代码
requests
如果安装python第三方模块: win + R 输入 cmd 点击确定
输入安装命令： pip install 模块名 (pip install requests)回车
在pycharm中点击Terminal(终端) 输入安装命令
代码实现: 发送请求获取数据解析数据保存数据 采集天气数据代码 import requests import parsel import csv with open('天气.csv', mode='a', encoding='utf-8', newline='') as f: csv_writer = csv.writer(f) csv_writer.writerow(["日期", "最高温度", "最低温度", "天气", "风向", "城市"]) city_list = [54511, 58362, 59287, 59493] for city in city_list: for year in range(2011, 2022): for month in range(1, 13): url = f'https://tianqi.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/461fba2a964772ca1647417100f2f47c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36c5b5ee6b529a290f797b828c81513c/" rel="bookmark">
			大语言模型发展脉络与国内现状
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/399a869fa80619995b35d431af2db3a2/" rel="bookmark">
			安卓13解决链接问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作为Android用户，你可能已经注意到了一个问题——Android 13不再支持PPTP协议。但请别担心，作为一家专业的代理供应商，我们将与你分享解决方案，让你轻松解决L2TP问题，享受到高水平的连接体验。本文将为你提供实用的操作方法，简单易懂，不再让你为连接 而困扰。
第一步：选择可靠的 协议
新的Android系统里，PPTP协议不再是一个可行的选择，但幸运的是，我们有L2TP协议作为一个可靠且安全的替代方案。L2TP协议提供更好的加密功能，并与Android 13兼容。选择L2TP协议是解决PPTP不支持的一个重要第一步。
第二步：配置L2TP连接
在你的Android 13设备上配置L2TP连接非常简单。下面是具体步骤：
1. 进入手机设置，点击“网络和互联网”。
2. 找到“ ”选项，并点击进入。
3. 点击右上角的“+”号添加新的 连接。
4. 根据你的 提供商提供的信息填写以下字段：名称、服务器地址、预共享密钥（PSK）等。
5. 选择L2TP/IPSec PSK作为 类型，并保存并连接。
请确保你输入的信息准确无误，并且妥善保存预共享密钥（PSK），这对于正确连接 非常重要。
第三步：享受高品质的 连接
恭喜！你已经成功配置了L2TP连接，现在你可以轻松愉快地享受到高品质的 连接体验。你可以自由访问互联网，保护你的个人隐私，并享受更安全的在线活动。
需要注意的是，在选择代理时，一定要选择一家专业的代理供应商，专业意味着可以提供最好的解决方案：
1. 先进的技术：使用最新的技术，保证 连接的稳定性和速度，享受到无缝的网络体验。
2. 安全与隐私：重视安全和隐私，提供高级加密技术保护个人数据，确保在线活动始终受到保护。
3. 全球服务器：拥有多个服务器节点，覆盖全球各地，能够连接到最快速的服务器，同时访问全球内容。
4. 多设备支持：支持各种常见设备，包括Android、iOS、Windows、Mac等，无论在哪里都能享受到高品质的 连接。
虽然Android 13不再支持PPTP协议，但我们有L2TP作为一个可靠的替代方案。通过简单的配置步骤，你可以轻松地连接L2TP协议并享受高品质的 连接。
希望这些技巧对大家有所帮助！如果还有其他相关的问题，欢迎评论区讨论留言，我会尽力为大家解答。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/100/">«</a>
	<span class="pagination__item pagination__item--current">101/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/102/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>