<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1eae5a955364c66615b0b8e0794ae460/" rel="bookmark">
			MFC 绘制直角坐标系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.设计思路：
（1）声明客户区矩形
（2）获得客户区坐标
（3）设置映射模式
（4）画出X轴、Y轴
注意：
映射模式选用的是MM_LOMETRIC，其对应的坐标系特征是：每个逻辑坐标被转换为0.1 mm。正x向右，正y向上。
2.代码
（1）声明客户区矩形并设置映射模式
void CCoordinateSystemView::OnDraw(CDC* pDC)
{
CCoordinateSystemDoc* pDoc = GetDocument();
ASSERT_VALID(pDoc);
// TODO: add draw code for native data here
CRect rect;//声明客户区矩形
GetClientRect(&amp;rect);//获得客户区坐标 int height=(int)rect.Height()*2.5;
int width=(int)rect.Width()*2.5;
int i;
pDC-&gt;SetMapMode(MM_LOMETRIC); //设置映射模式为：MM_LOMETRIC，即每个逻辑坐标被转换为0.1 mm。正x向右，正y向上。
pDC-&gt;SetWindowExt(width,height); //设置窗口
pDC-&gt;SetViewportExt(width,-height); //x轴水平向右，y轴垂直向上
//pDC-&gt;SetViewportOrg(width/2,height/2); //客户区中心为坐标系原点
（2）画X轴和Y轴
//画X轴
pDC-&gt;MoveTo(0,-height/2);
pDC-&gt;LineTo(width,-height/2);
//画Y轴
pDC-&gt;MoveTo(width/2,0);
pDC-&gt;LineTo(width/2,-height);
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7c57e7f1debda153f627fec2a8ea2b9/" rel="bookmark">
			BERT使用过程中的碰到的那些报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		BERT是谷歌2018年提出的语言模型，在十几个任务上达到了state-of-art。在这里本人在使用过程中总结了一下遇到的错误。
BERT推荐在TPU上运行，但是资源有限在GPU上跑也行，不行也能在cpu上跑（ps就是有些慢）
官方BERT的版本建议在tensorflow&gt;=1.11的版本上运行，但是在本人服务器安装的是tensorflow-gpu=1.12的情况下，程序报错，
AttributeError: module 'tensorflow.python.platform.flags' has no attribute 'mark_flag_as_required' 根据官方回答是此版本没有这个属性（ps坑爹），于是只能安装其他版本的tensorflow
但根据测试其实低于1.11版本也可以运行的，就是1.12不能运行。
而且由于服务器的cuda版本是8.0，高版本的tensorflow-gpu不支持，报错
在cuda官网有相应的tensorflow版本推荐
也可以直接安装cpu版本的tensorflow，在linux服务器下安装anaconda比较方便，anaconda自带pyhon环境
可以利用anaconda创建虚拟环境，运行不同版本的tensorflow
conda create --name tf_cpu python=3.6
source activate tf_cpu 激活环境
source deactivate 退出环境命令
环境之间不互相干扰，亲测可行。
conda install tensorflow=1.11
conda install numpy
conda install pandas
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b94b1c2d73fdd218e14f2fea6ff8076f/" rel="bookmark">
			Hive 处理 json 的几个函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文参考：https://cwiki.apache.org/confluence/display/Hive/LanguageManual+UDF
get_json_object hive中解析一般的json是很容易的，使用 get_json_object 就可以了。
get_json_object 函数第一个参数填写json对象变量，第二个参数使用$表示json变量标识，然后用 . 或 [] 读取对象或数组；
例子：
select get_json_object('{"name":"jack","server":"www.qq.com"}','$.server') json_tuple 对与返回多个字段的场景，它比 json_tuple 更加高效。具体是如何使用呢，下面给个实例
select a.timestamp, get_json_object(a.appevents, '$.eventid'), get_json_object(a.appenvets, '$.eventname') from log a; 可以改成如下写法：
select a.timestamp, b.* from log a lateral view json_tuple(a.appevent, 'eventid', 'eventname') b as f1, f2; explode 但如果字段是json数组，比如
[{"bssid":"6C:59:40:21:05:C4"},{"bssid":"AC:9C:E4:04:EE:52","ssid":"and-Business"}] 直接调用 get_json_object 返回空值。这样的话对于不会写UDF的同学来说，解析json数组就变得很棘手，好在 hive 中自带了 explode 函数，从而让解析 json数组 变得有可能了。这里先介绍一下 explode 的使用方法：
explode(array)
select explode(array('A','B','C')) as col; select tf.* from (select 0 from dual) t lateral view explode(array('A','B','C')) tf as col; 运行结果：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b94b1c2d73fdd218e14f2fea6ff8076f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5386819e176a77c91aabbd4230cf5737/" rel="bookmark">
			动态规划原理及例题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是动态规划 动态规划法试图只解决每个子问题一次一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。 「动态规划」中包含三个重要的概念：
【最优子结构】
【边界】
【状态转移公式】
在「 斐波那契数列问题 」中
f(10) = f(9) + f(8) 是【最优子结构】
f(0) 与 f(1) 是【边界】
f(n) = f(n-1) + f(n-2) 【状态转移公式】
斐波那契数列 额外空间，n+1长度数组（0，1，…，n）
自顶向下 if n == 0: memo[0] = 0 if n == 1: memo[1] = 1 if memo[n] == [0]: meno[n] = memo[n-1] + memo[n-2] return memo[n] 自底向上 memo[0] = 0 memo[1] = 1 for i in range(2,n+1): memo[i] = memo[i-1]+memo[i-2] return memo[n] 分割数求最大乘积 用回溯暴力搜索的思路，有重叠子问题
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5386819e176a77c91aabbd4230cf5737/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c855f416719606e873e5fb51d39c3cdc/" rel="bookmark">
			应用程序监听1024以下端口号方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们自己编写的应用程序监听服务端端口号。普通用户只能访问1024以上端口；
当需要使用1024及以下的端口号时，需要应用程序获取root用户权限，操作方法如下（假设我们编写的应用程序名称为 myproc）：
chown root:root myproc
chmod u+s myproc
经过以上操作，myproc就获取到了root的用户权限，这样就可以使用1024以下的端口。有时也需要修改搜索动态连接库路径LD_LIBRARY_PATH。
若myproc无法起来，需要查看 /etc/ld.so.conf，加入应用依赖的 lib路径，再用root执行 ldconfig 命令。
root@A2290:~# cat /etc/ld.so.conf
/usr/lib64
/usr/lib
include /etc/ld.so.conf.d/*.conf
/home/oracle/oracle10g/lib
/home/sybase/OCS-15_0/lib
/home/myhome/lib
root@A2290:~# ldconfig
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff29ae0757d46c535b238df59ed7a52d/" rel="bookmark">
			浙工大计算机考研心得&#43;资料
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		浙江工业大学计算机专硕
今年专硕的分数361，比较高
工大的复试，没有上机没有笔试，只有面试，所以说压力没那么大，面试正常发挥就可以了
专业课 845 和 958 都是C++程序设计
没什么大的区别，建议复习的时候两门真题都做一遍
同时建议每道题的代码都自己跑一遍，编程题的代码自己写，然后自己跑，改改BUG肯定会有提高
像真题的代码我都是写过然后运行过
真题的话都有全的，需要的可以联系我
最后希望每个考工大的同学都能够上岸 有什么问题欢迎联系我 QQ490722826
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f58a30fb36e9d910a314c07e6c284a38/" rel="bookmark">
			批处理：批量删除文件名前N个字符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		可以把当前目录所包含的所有文件（包括子目录下的文件）进行文件名修改，去掉文件名前N个字符。
比如当前目录下的文件如下：
aa12345.txt
bb12345.txt
abc/cc12345.txt
abc/def/dd12345.txt
希望得到的结果如下：
12345.txt
12345.txt
abc/12345.txt
abc/def/12345.txt
批处理脚本如下：
@echo off setlocal enabledelayedexpansion ::批量去掉文件名前N个字符，如果有文件夹会搜索文件夹下的每个文件进行修改 set /p format=请输入需要操作的文件格式： set /p deletenum=请输入需要删除文件名前多少个字符： for /r %%i in (.) do ( for /f "delims=" %%a in (' dir /b "%%i\*.%format%" 2^&gt;nul ') do ( set "t=%%~na" ren "%%i\%%a" "!t:~%deletenum%!%%~xa" ) ) pause 运行脚本即可得到所要结果：
请输入需要操作的文件格式：txt
请输入需要删除文件名前多少个字符：2
请按任意键继续. . .
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67b1f6fa8ba42bc4018f0c4d9062ef10/" rel="bookmark">
			vue --echarts
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		x轴文字横向竖着排列
xAxis: { type: "category", boundaryGap: true, nameGap: 30, splitArea: { show: false }, axisLabel: { show: true, interval: 0, formatter: function(params) { var newParamsName = ""; var paramsNameNumber = params.length; var provideNumber = 1; //一行显示几个字 var rowNumber = Math.ceil(paramsNameNumber / provideNumber); if (paramsNameNumber &gt; provideNumber) { for (var p = 0; p &lt; rowNumber; p++) { var tempStr = ""; var start = p * provideNumber; var end = start + provideNumber; if (p == rowNumber - 1) { tempStr = params.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/67b1f6fa8ba42bc4018f0c4d9062ef10/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b51950c016145fb9cbc9f21ec11aff80/" rel="bookmark">
			一次erlang VM内存泄漏问题复盘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、问题发现
在一次压测中，发现erlang VM使用内存超出预期，其中process使用内存在正常范围内，system使用内存超出预期很多，具体占到整个内存使用量的80%，其中binary一项占用了system的绝大部分使用量，很明显，系统存在binary泄漏。
2、问题追踪
问题发生后，首先想到的就是到底binary在erlang VM中是怎么创建和回收的。众所周知，binary分为两种，小于64bytes存在进程私有堆中，大于64bytes的存在共享堆中，进程私有堆gc策略为分代gc，共享堆gc策略是引用计数Refc，也就是说当一个binary没有任何一个进程引用的时候才会被gc，具体机制不再赘述，相关问题可以参考https://www.cnblogs.com/yunba/p/4816384.html?utm_source=tuicool&amp;utm_medium=referral
什么进程在引用了binary？erlang:process_info/2有个未公开的选项可以查看一个进程引用的所有binary，利用这个我们可以查看到大量引用binary的进程，具体可以参考http://blog.yufeng.info/archives/2882
topN(N)-&gt; [{M, P, process_info(P, [registered_name, initial_call,current_function, dictionary]), B} || {P, M, B} &lt;- lists:sublist(lists:reverse(lists:keysort(2,processes_sorted_by_binary())),N)]. processes_sorted_by_binary()-&gt; [case process_info(P, binary) of {_, Bins} -&gt; SortedBins = lists:usort(Bins), {_, Sizes, _} = lists:unzip3(SortedBins), {P, lists:sum(Sizes), []}; _ -&gt; {P, 0, []} end ||P &lt;- processes()]. 3、代码分析
查看到引用了大量binary的进程都是tcp连接进程，仔细分析代码之后发现以下函数中存在binary泄漏
recieve_msg(Data) -&gt; case get(unrecieve) of undefined -&gt; case Data of &lt;&lt;Length:32, MsgAll/binary&gt;&gt; -&gt; case erlang:byte_size(MsgAll) &gt;= Length of true -&gt; &lt;&lt;Msg:Length/binary, Remain/binary&gt;&gt; = MsgAll, do_sth(Msg), recieve_msg(Remain); false -&gt; put(unrecieve, Data) end; _ -&gt; put(unrecieve, Data) end; Data1 -&gt; erase(unrecieve), recieve_msg(&lt;&lt;Data1/binary, Data/binary&gt;&gt;) end.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b51950c016145fb9cbc9f21ec11aff80/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8924afcb005d87650bf2e1fb631b700/" rel="bookmark">
			三子棋游戏完整版。棋盘，三子棋，五子棋任意定制。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		三子棋游戏实现2.0 上次我的错误部分代码经过我的研究终于发现问题到底出在哪里，原因在于我没有弄清函数引用传递的是实参，而函数创建用的是形参
上次错误部分：是在函数引用的时候传出入了实参board[ROW][COL]，
if (FullBoard(board[ROW][COL], row, col) == 1) { return 'C'; } else { return 'D'; } int FullBoard(char board[ROW][COL], int row, int col) { int i = 0; int j = 0; for (i = 0; i &lt; row; ++i) { for (j = 0; j &lt; col; ++j) { if (board[i][j] == ' ')//在这一行出现读写访问错误。 return 1; } } return 0; } 改正后：将board后面的参数去掉。
if (FullBoard(board, row, col) == 1) { return 'C'; } else { return 'D'; } } static int FullBoard(char board[ROW][COL], int row, int col) { int i = 0; int j = 0; for (i = 0; i &lt; row; ++i) { for (j = 0; j &lt; col; ++j) { if (board[i][j] == ' ') return 1; } } return 0; } 除此之外，我还使用了全局变量，但是在后期其中一个函数实现时又手误在使用全局变量的时候把变量又重新定义了一次，是函数内部产生了一个和全局变量相同名字的局部变量而导致电脑一直无法胜利。以下是正确代码
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c8924afcb005d87650bf2e1fb631b700/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6058d50cb486972c4b3332625335652f/" rel="bookmark">
			JSP实现登录和注册操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先在数据库中建好我们要用的表，设置两个列名代表账号和密码，也可以设置ID列为主键
这里笔者用的数据库是SQL Server2014，由于要用JDBC连数据库，所以要在项目中加入SQLSever的驱动包，当然用别的数据库也可以
(在我的上一篇文章中，有连Mysql和SQLSever的驱动包)
1.数据库操作类
定义一个DBBean类在构造函数中就通过Connection成员连接数据库，
private String driverStr = "com.microsoft.sqlserver.jdbc.SQLServerDriver"; private String connStr = "jdbc:sqlserver://localhost:1433;DatabaseName=db_fortest"; private Connection conn = null; private Statement stmt = null; private PreparedStatement pstm = null; public DBBean() { try { Class.forName(driverStr); //加载数据库驱动 conn = DriverManager.getConnection(connStr,"root","root");//连接数据库 stmt = conn.createStatement();//这里数据库密码根据自己数据库密码填写 } catch (Exception ex) { System.out.println("数据连接失败！"); } } 下面我们要定义具体方法去更方便的为前台传来的数据进行加工
public int executeUpdate(String s) { int result = 0; System.out.println("--更新语句:"+s+"\n"); try { result = stmt.executeUpdate(s); } catch (Exception ex) { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6058d50cb486972c4b3332625335652f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/577725417480aef8d867850992746424/" rel="bookmark">
			微信小程序：页面或者按钮为什么会抖一下？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		其实不仅仅是小程序，我们再搞前端点击按钮或者切换状态时都会出现页面“抖动”的情况。举个例子我们自己设置一些选项按钮，让用户切换选择对应选项，有的会发现切换这个对应的按钮会发现按钮会“抖动一下”。
之所以抖动的原因就是，切换“选择”和“未选择”的两种样式，文字图片位置或者大小不一致导致的，前后细微的差别会给人一种抖一下的感觉，而不是我们设想的仅仅换了个背景或者换个文案之类的那种平滑自然的感觉，抖一下虽然幅度不大（大的话就不叫都懂了）但有的时候还是要注意调整优化，毕竟是直接面对用户的交互。
（1）节点位置样式引起的
这个很好弄，就是两者用差不多一样的CSS样式，保证位置不会因为在切换导致变化。还有一点就是要注意加载图片有的时候会引起这种状况。还有就是选择一些有自适应的框架组件，比如说小程序里面图片的image组件中的mode属性，每次切换一下会计算一下适应的方位，这种计算的也会导致会抖一下，因为会出现这种“抖动”。
（2）boder-box引起的
我本人很喜欢boder-box这个属性，因为他可以避免很多兼容性的问题，就是那种一个手机一个样的尴尬情况。
他主要的作用就是让这个div或者view的boder边框和padding的距离向里面扩展。使这个div不会拉伸所在的父节点。
但是也会遇到问题，就是我遇到一个“抖动“问题，就是由于状态切换的两个css样式都是设置的boder-box，但是一个有边框一个没有。切换的时候就会出现“抖动”，因为boder会向里面“挤”，还是那种东南西北都往里挤你设置的边框宽度的距离。
想了一下各种方案都不满意，人家直接来了一句，你设置一个透明的边框给之前那个没有边框的样式就好了。可以的，完美解决，前端一些问题真的需要变通，要放开思路。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2c4eb963587c41eef8c4dd5d51777e9/" rel="bookmark">
			js二维数组var arr = [[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;],[1,2,3],[&#39;x&#39;,&#39;y&#39;,&#39;z&#39;]]生成一维数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		var arr = [['a','b','c'],[1,2,3],['x','y','z']]
function doExchange(arr){
var newArr= [];
let a1 = arr[0]
let a2 = arr[1]
let a3 = arr[2]
for(var i = 0; i &lt; a1.length; i ++) {
for(var j = 0; j &lt; a2.length; j ++) {
for(var k = 0; k &lt; a3.length; k ++) {
newArr.push(a1[i]+a2[j]+a3[k])
}
}
}
return newArr
}
let arrNew = doExchange(arr)
console.log(arrNew);
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0a0da52001b53d368b2f2fe4b552ab0/" rel="bookmark">
			mouseenter和mouseleave与mouseover和mouseout的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、mouseenter（指针穿过，子集不执行） 当鼠标指针穿过（进入）被选元素时，会发生 mouseenter 事件。
mouseenter() 方法触发 mouseenter 事件，或添加当发生 mouseenter 事件时运行的函数。
注意：与 mouseover 事件不同，mouseenter 事件只有在鼠标指针进入被选元素时被触发，mouseover 事件在鼠标指针进入任意子元素时也会被触发。参见页面底部演示实例。
mouseover/mouseout事件支持冒泡，
二、mouseover（指针上方，子元素执行） 当鼠标指针位于元素上方时，会发生 mouseover 事件。
mouseover() 方法触发 mouseover 事件，或添加当发生 mouseover 事件时运行的函数。
注意：与 mouseenter 事件不同，mouseover 事件在鼠标指针进入被选元素或任意子元素时都会被触发，mouseenter 事件只有在鼠标指针进入被选元素时被触发。
*mouseover() 与 mouseenter() 之间的不同（先执行mouseover后mouseenter） mouseover 事件在鼠标移动到选取的元素及其子元素上时触发 。
mouseenter 事件只在鼠标移动到选取的元素上时触发。
mouseover/mouseout事件支持冒泡，绑定的事件会冒泡到子标签上。
mouseenter/mouseleave事件则只针对所绑定的标签，不会冒泡到子标签上。 （mouseover在进入到子元素也会执行，而mouseenter 只会执行绑定的元素，进入子元素不执行）
mouseover可以看到进入父集元素，进入到子集时、离开子集进入父级，一共三次
而mouseout只有进父级时一次
三、mouseleave（指针离开元素时，子元素不执行） 当鼠标指针离开元素时，会发生 mouseleave 事件。
该事件大多数时候会与 mouseenter 事件一起使用。
mouseleave() 方法触发 mouseleave 事件，或规定当发生 mouseleave 事件时运行的函数。
注释：与 mouseout 事件不同，只有在鼠标指针离开被选元素时，才会触发 mouseleave 事件。如果鼠标指针离开任何子元素，同样会触发 mouseout 事件。
四、mouseout(指针从元素上移开,子元素执行) 当鼠标指针从元素上移开时，发生 mouseout 事件。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b0a0da52001b53d368b2f2fe4b552ab0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d37128b88bc5a7a5d6f753f1644f6358/" rel="bookmark">
			shell中打印带有时间的日志的命令（转）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		echo "`date "+%Y-%m-%d %H:%M:%S"` | [logadm -on@`date "+%Y%m%d%H%M%S"`] "
2013-09-30 11:42:48 | [logadm -on@20130930114248]
转载于:https://www.cnblogs.com/zl1991/p/10736357.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ed2a8545298ce8222120a562caf142e/" rel="bookmark">
			python为字体添加上下标
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		添加上标：^
添加下标：_
举例：
import numpy as np import matplotlib.pyplot as plt t = np.linspace(0, 10, 1000) y = np.sin(t) plt.plot(t, y) plt.xlabel('a/${m_2}$',fontdict={'weight': 'normal', 'size': 15}) plt.show() 效果：
如果去掉斜体格式：
import numpy as np import matplotlib.pyplot as plt t = np.linspace(0, 10, 1000) y = np.sin(t) plt.plot(t, y) plt.xlabel('a/$\mathregular{m_2}$',fontdict={'weight': 'normal', 'size': 15}) plt.show() 效果：
添加上标：
import numpy as np import matplotlib.pyplot as plt t = np.linspace(0, 10, 1000) y = np.sin(t) plt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ed2a8545298ce8222120a562caf142e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec1a77817d212f9f62d343f6c7dbd2de/" rel="bookmark">
			2、用Keil新建TM4C123G工程步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		易错点： 1、单片机选型时不要选错，看清楚每一个字母！
2、工程设置里面添加rvmdk PART_TM4C123GH6PM是必须的，要不然编译无法通过！
3、main.c文件保存好以后要添加到工程里面！
步骤： 1、点击新工程
2、新建一个工程文件夹，并进入
3、在该文件夹内，为该工程起名字，这里叫test，点击保存
4、选择单片机型号，tm4c123gh6pm，点击OK。有的人如果还没有安装器件包，这里是找不到的。
5、这里勾上，不用自己后期再添加，方便一点。
6、新建一个文件，保存。
复制粘贴下列测试代码，保存。
#include &lt;stdint.h&gt; #include &lt;stdbool.h&gt; #include "inc/hw_gpio.h" #include "driverlib/gpio.h" #include "driverlib/pin_map.h" #include "inc/hw_memmap.h" #include "driverlib/sysctl.h" int main() { SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOF); GPIOPinTypeGPIOOutput(GPIO_PORTF_BASE, GPIO_PIN_1); GPIOPinWrite(GPIO_PORTF_BASE, GPIO_PIN_1, GPIO_PIN_1); while(1) { } } 7、将该文件加入工程，右击Sourece Group1，点击该选项。
点击test.c，点击Add，点击Close，即如图。
8、加入函数库路径，依次点击
9、加入库函数
新建Library组，添加库里面driverlib目录下的所有.c文件
10、复制加入下列宏(重要)
rvmdk PART_TM4C123GH6PM debug选择ICDI
11、编译下载
完成。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38c7cfa0302d1c5c5a9ba4314c470504/" rel="bookmark">
			tableau 基本使用【数据源、工作表、字段操作、函数与计算】（超级详细版本）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. Tableau数据提取1.1 先准备要导入tableau的数据 2. Tableau工作表2.1 Tableau工作表2.2 Tableau编辑元数据 3. Tableau字段操作3.1 合并字段3.2 字段分层3.3 字段分组3.4 字段拆分3.5 计算字段3.6 集 4. Tableau函数与计算4.1 Tableau中的运算符4.2 Tableau函数（1）数字函数（2）字符串函数（3）日期函数（4） 逻辑函数IIF判断IF判断case （5）聚合函数（6）类型转换函数（7）Tableau计算字段（8） 字符串计算（9）Tableau日期计算（10）表计算差异计算百分比差异计算百分比计算总额百分比计算排名计算百分位计算汇总计算移动计算快速表计算临时计算 1. Tableau数据提取 1.1 先准备要导入tableau的数据 tableau中的数据提取从数据源创建数据 子集，这有助于通过应用筛选器来提高性能，它还有助于将tableau的某些功能应用于数据源中可能不可用的数据，例如在数据中查找不同的值。但数据提取功能最常用于创建要存储在本地驱动器中的提取，以供tableau脱机访问。数据的提取通过遵循菜单【数据-&gt;编辑数据源筛选器】
提取华北及东北地区的家具销售利润低于5000的数据
先筛选“地区” 再筛选“类别”
最后筛选“利润”
2. Tableau工作表 2.1 Tableau工作表 在tableau中添加工作表在tableau中重命名工作表在tableau中保存和删除工作表在tableau中重新排序和移动工作表
2.2 Tableau编辑元数据 检查元数据
将“订单”表拖动到数据画布，显示列名称及其数据类型。
字符串数据类型显示为Abc，数字数据类型显示为# 2. 更改数据类型
连接到数据源，tableau将捕获源的元数据详细信息，如列及其数据类型，这用于创建视图使用的维度，度量和计算字段，我们可浏览元数拓并更改其某些特定要求的某些属性
3. 列的重命名和隐藏
可以使用重命名选项更改列名称。另外，我们可以隐藏一个列，使它不会出现在我们创建的数据视图中。通过单击元数据网格中的数据类型图标可以获得这些选项。可以试着修改"订单ID"列名为"订单编号"，或尝试隐藏该列
4. 列别名
可以为数据源的每一列分配一个别名，以帮助更好的了解列的性质。我们可以从上面的步骤中选择别名选项，然后出现用于创建或编辑别名选项。
可以尝试着为"省/自治区"的"上海"这一列数据修改别名为:“上海市”
3. Tableau字段操作 3.1 合并字段 我们可以组合两个维度字段来创建一个字段。此组合字段的名称是单个字段的组合。通过将两个字符串连接成一个以逗号分隔的字符串，维度中的值将合并为单个值。但是可以使用重命名字段操作更改此默认名称
例如：将“国家”，“地区”，“城市”合并为一个“地址”字段
第一步：创建（按住CTRL选中要创建的内容）
第二步：编辑
第三步：改名
第四步：效果
3.2 字段分层 某些情况下，我们需要对几个变量创建一个分层结构。以便在制图或数据分析时随时向下钻取数据
例如：将【类别,子类别,产品名称】作为一个分层结构，并命名为【产品类别】，以方便 向下查看
创建分层
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/38c7cfa0302d1c5c5a9ba4314c470504/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23f482213ea1980417de93cbc2c38f33/" rel="bookmark">
			outlook如何撤回邮件？（中英文）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、中文：
已发送的邮件，任意选择一个已发送的邮件，双击进入详情页（这点非常重要！！！如果在列表中查看，是找不到撤回邮件按钮的），“移动”按钮的右侧按钮，点击“回收此邮件“即可。
2、英文：
Home Page中找到sent items，任意选择一个已发送的邮件，双击进入详情页（这点非常重要！！！如果在列表中查看，是找不到撤回邮件按钮的），“Move”按钮的右侧“Actions”按钮，选择“Recall This Message“即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/419ba1ac9f740c9df57583b6a44a4074/" rel="bookmark">
			MATLAB（完备）之图像.tif到真彩色图像、索引色图像、灰度图像、 真彩色图像RGB、YIQ图像、HSV图像、YCbCr图像转换代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		I=imread(‘flower.tif’);%读入图片
whos I
imfinfo(‘flower.tif’)
imshow(I);title(‘原始tif图像’)
%%真彩图像、转索图像、灰度图像、二值图像的相互转换
imwrite(I,‘flower.jpg’,‘quality’,10)%tif转化rgb
I1=imread(‘flower.jpg’);
figure;imshow(I1);title(‘真彩色图像’)
[X,map] = rgb2ind(I1,32);%真彩转索引
figure;imshow(X,map),colorbar,title(‘索引图像’)
rgb=ind2rgb(X,map);%索引转rgb
figure;imshow(rgb);title(‘rgb图像’)
G=rgb2gray(I1);
figure;imshow(G);title(‘rgb转灰度图像’)
G1=ind2gray(X,map);%索引转灰度
figure;imshow(G1);title(‘索引转灰度图像’)
G3=im2bw(I1);%图像转二值图像
figure;imshow(G3);title(‘二值图像’)
%%RGB/YIQ/HSV/YCbCr之间的转换
image = imread(‘lena.jpg’);
figure;subplot(331);imshow(image);title(‘原始图像’)
%RGB&amp;YIQ
YIQ=rgb2ntsc(image);
subplot(332);imshow(YIQ);title(‘YIQ图像’)
rgb=ntsc2rgb(YIQ);
subplot(333);imshow(rgb);title(‘rgb图像’)
%RGB&amp;HSV
HSV=rgb2hsv(image);
subplot(334);imshow(image);title(‘原始图像’)
subplot(335);imshow(HSV);title(‘HSV图像’)
RGB1=hsv2rgb(HSV);
subplot(336);imshow(RGB1);title(‘RGB图像’)
%RGB&amp;YCbCr
yc=rgb2ycbcr(image);
subplot(337);imshow(image);title(‘原始图像’)
subplot(338);imshow(yc);title(‘ycbcr图像’)
rgb2=ycbcr2rgb(yc);
subplot(339);imshow(rgb2);title(‘RGB图像’)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4413390a42cc4937b035a7e2ee64e983/" rel="bookmark">
			iOS开发 Metal Framework基础使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		iOS 8.0起，Apple为了更充分地发挥GPU的潜力，引入了Metal框架，Metal基于C++设计,开发者可以用它来编写在GPU上执行的图形渲染逻辑代码和通用并行计算逻辑代码，目前的Metal框架中可以使用三种着色器——Vertex Shader、Fragment Shader以及Compute Shader。
1、先创建MTLCreateSystemDefaultDevice和CAMetalLayer 2、确定顶点数据，中心点是原点（x, y, z）和顶点缓冲区MTLBuffer let vertexData: [Float] = [
0.5, 0.5, 0.0,
-0.5, 0.5, 0.0,
-0.5, -0.5, 0.0,
0.5, -0.5, 0.0
]
2.1、您需要以字节为单位获取顶点数据的大小。您可以通过将第一个元素的大小乘以数组中元素的计数来实现这一点 let dataSize = vertexData.count * MemoryLayout.size(ofValue: vertexData[0])
2.2、在GPU上创建一个新的缓冲区，从CPU传入数据。为默认配置传递一个空数组 vertexBuffer = device.makeBuffer(bytes: vertexData, length: dataSize, options: [])
3、创建Metal文件 vertex float4 basic_vertex(
const device packed_float3* vertex_array [[ buffer(0) ]],
unsigned int vid [[ vertex_id ]]) {
return float4(vertex_array[vid], 1.0);
}
fragment half4 basic_fragment() {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4413390a42cc4937b035a7e2ee64e983/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7c5081b87ef2a9f54bebf60fde04cb0/" rel="bookmark">
			Redis面试题（一）: Redis到底是多线程还是单线程？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://blog.csdn.net/bird73/article/details/79792548
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a7ec5cdef396e854a85831a4cc17e88/" rel="bookmark">
			Linux下Kibana配置文件参数详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		配置 Kibana Kibana server 启动时从 kibana.yml 文件中读取配置属性。Kibana 默认配置 localhost:5601 。改变主机和端口号，或者连接其他机器上的 Elasticsearch，需要更新 kibana.yml 文件。也可以启用 SSL 和设置其他选项。
Kibana 配置项 （1）server.port:
默认值: 5601 Kibana 由后端服务器提供服务，该配置指定使用的端口号。
（2）server.host:
默认值: "localhost" 指定后端服务器的主机地址。
（3）server.basePath:
如果启用了代理，指定 Kibana 的路径，该配置项只影响 Kibana 生成的 URLs，转发请求到 Kibana 时代理会移除基础路径值，该配置项不能以斜杠 (/)结尾。
（4）server.maxPayloadBytes:
默认值: 1048576 服务器请求的最大负载，单位字节。
（5）server.name:
默认值: "您的主机名" Kibana 实例对外展示的名称。
（6）elasticsearch.preserveHost:
默认值: true 该设置项的值为 true 时，Kibana 使用 server.host 设定的主机名，该设置项的值为 false时，Kibana 使用主机的主机名来连接 Kibana 实例。
（7）kibana.index:
默认值: ".kibana" Kibana 使用 Elasticsearch 中的索引来存储保存的检索，可视化控件以及仪表板。如果没有索引，Kibana 会创建一个新的索引。
（8）kibana.defaultAppId:
默认值: "home" 默认加载的应用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a7ec5cdef396e854a85831a4cc17e88/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8e85da0e476da80943ecb0e455cc423/" rel="bookmark">
			Linux服务器上挂载U盘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0. 查看U盘是否被读取 lsusb 1. 查看U盘位置 sudo fdisk -l 或者：
df -h 根据U盘的大小可以大致判断大致的路径
我这里的输出是
Disk /dev/ram14: 64 MiB, 67108864 bytes, 131072 sectors Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 4096 bytes I/O size (minimum/optimal): 4096 bytes / 4096 bytes Disk /dev/ram15: 64 MiB, 67108864 bytes, 131072 sectors Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 4096 bytes I/O size (minimum/optimal): 4096 bytes / 4096 bytes Disk /dev/sda: 447.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8e85da0e476da80943ecb0e455cc423/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ce24178eb09a0a3d335851dd379ed67/" rel="bookmark">
			渗透测试入门20之渗透测试七阶段
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 PTES标准中的渗透测试阶段
渗透测试执行标准(PTES:PenetrationTesting Executjion Standard)正在对渗透测试的重新定义，新标准的核心理念是通过建立起进行渗透测试所要求的基本准则基线，来定义一次真正的渗透测试过程。
PTES标准中的渗透测试阶段是用来定义渗透测试过程，并确保客户组织能够以一种标准化的方式来扩展一次渗透测试，而无论是由谁来执行这种类型的评估。PTES标准将渗透测试过程分为七个阶段，并在每个阶段中定义不同的扩展级别，而选择哪种级别则由被攻击的客户组织决定。
1.PTES：前期交互阶段
前期交互阶段通常是与客户组织进行讨论，来确定渗透测试的范围和目标。这个阶段最为关键的是需要让客户组织明确清晰地了解渗透测试将涉及哪些目标。选择更加现实可行的渗透测试目标进行实际实施。
2.PTES：情报搜集阶段
在情报搜集阶段，需要使用各种可能的方法来收集将要攻击的客户组织的所有信息，包括使用社交媒体网络、Google Hacking技术、目标系统踩点等等。作为渗透测试人员，最重要的一项技术就是对目标系统的探查能力，包括获知它的行为模式、运行机理，以及最终可以如何被攻击。
在情报搜集阶段中，通过逐步深入的探测，来确定在目标系统中实施了哪些安全防御措施。例如，一个组织在对外开放的网络设备上经常设置端口过滤，只允许接收发往特定端口的网络流量，而一旦在白名单之外的端口访问这些设备时，那么就会被加入黑名单进行阻断。通过这种阻断行为的一个好方法是先从所控制的其他IP地址来进行初始探测，而这个IP地址是预期就会被阻断或者检测到的。当在探测web应用程序时，这个方法非常适用，因为一些保护web应用程序的web应用防火墙通常也会在探测请求数量超过一定阈值后对IP进行阻断，使得无法再使用这个IP发起任何请求。
PS：可以使用一个与你要发起主要攻击行为处于完全不同范围的IP地址，来进行非常“喧闹”的扫描，这样可以帮助确定客户组织是否能够很好地检测和响应所使用的攻击工具和技术。
3. PTES：威胁建模阶段
威胁建模主要使用在情报搜集阶段所获取到的信息，来标识出目标系统上可能存在的安全漏洞与弱点。在进行威胁建模时，确定最为高效的攻击方法、所需要进一步获取到的信息，以及从哪里攻破目标系统。
4. PTES：漏洞分析阶段
在漏洞分析阶段，综合从前面的几个环节中获取到信息，并从中分析和理解哪些攻击途径回事可行的。特别是需要重点分析端口和漏洞扫描结果，获取到的服务“旗帜”信息，以及在情报搜集环节中得到的其他关键信息。
5.PTES：渗透攻击阶段
渗透攻击在实际情况下往往没有所预想的那么“一帆风顺”，而往往是“曲径通幽”。最好是在基本能够确信特定渗透攻击会成功的时候，才真正对目标系统实施这次渗透攻击，当然在目标系统中很可能存在着一些没有预期到的安全防护措施，是的这次渗透攻击无法成功。在尝试要触发一个漏洞时，应该清晰地了解在目标系统上存在这个漏洞。
6.PTES：后渗透攻击阶段
后渗透攻击阶段从已经攻陷了客户组织的一些系统或取得域管理权限之后开始。后渗透攻击阶段将以特定的业务系统作为目标，识别出关键的基础设施，并寻找客户组织最具价值和尝试进行安全保护的信息和资产，当从一个系统攻入另一个系统时，需要演示出能够对客户组织造成最重要业务影响的攻击途径。
在后渗透攻击阶段进行系统攻击，需要投入更多的时间来确定各种不同系统的用途，以及它们中不同的用户角色。
7.PTES：报告阶段
报告是渗透测试过程中最为重要的因素，使用报告文档来交流在渗透测试过程中做了哪些，如何做的，以及最为重要的----客户组织如何修复所发现的安全漏洞和弱点。
当在编写和报告发现时，需要站在客户组织的角度上，来分析如何利用发现来提升安全意识，修补发现的问题，以及提升整体的安全水平，而并不仅仅是对发现的安全漏洞打上补丁。
所撰写的报告至少分为摘要、过程展示和技术发现这几个部分，技术发现部分将会被客户组织用来修补安全漏洞，但这也是渗透测试过程真正价值的体现。例如，在客户组织的web应用程序中找出了一个SQL注入漏洞，渗透测试者会在报告的技术发现部分来建议客户对所有的用户输入进行检查过滤，使用参数化的SQL查询语句，在一个受限的用户账户上运行SQL语句，以及使用定制的出错消息。最可能导致SQL注入漏洞的根本原因是使用了未能确保安全性的第三方应用，在报告中也要充分考虑这些因素，并建议客户组织进行细致检查并消除这些漏洞。
来源：https://blog.csdn.net/henni_719/article/details/77498681 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98e30c2d0d5111b16135c002e18dd915/" rel="bookmark">
			MySQL5.7  连接不上的解决办法（本地无法登录）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Connecting to MySQL server … Access denied for user ‘root’@‘localhost’ (using password: YES)
之前在旧电脑win8上装mysql5.7 时没有出现这个问题，在新电脑上win10也照之前那样装，装完了发现连接不上。最后参考网友的连上了，真的有用，很多地方都说修改DATA文件夹里的某个文件，可是我装完连DATA文件夹都没有，原来执行下命令就有了，按下面的步骤一步步就没问题了：
接下来就是在DOC窗体中进行配置了！
1、在开始菜单中输入cmd，右击管理员运行！
在窗体中输入cd C:\Program Files\MySQL\MySQL Server 5.7\bin (进入mysql安装路径下的bin文件夹)
2、进入bin文件夹后运行mysqld --initialize 命令，这时你的mysql Server5.7下会自动生成一个data文件夹！（我刚装完后没有这个文件夹，执行这个命令就有了）
3、输入mysqld -install 提示 service successfully installed 。
4、输入net start mysql ，启动mysql服务
5、输入mysql -u root -p 回车，让我们输入密码，因为之前版本的mysql都是没有初始密码的，直接回车就可以，不过现在不行了，不输入密码会报错！
所以我们有修改或添加一个mysql的初始密码或用户！首先，我们要停止mysql服务！
1、停止mysql命令：net stop mysql就可以！
2.输入命令mysqld --skip-grant-tables 之后没有反应。就可以了，不过不要把窗体关了，我们另起一个doc窗体。同时也是用管理员运行！
3、我们在新打开的doc窗体中输入cd C:\Program Files\MySQL\MySQL Server 5.7\bin (进入mysql安装路径下的bin文件夹)
4、然后在在doc窗体输入：mysql -u root ，我们就进入了mysql数据库，如下图：
5、在doc窗体中输入：update mysql.user set authentication_string=password(‘123qwe’) where user=‘root’ and Host = ‘localhost’;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98e30c2d0d5111b16135c002e18dd915/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/471e3842e556794d719188837c921ccd/" rel="bookmark">
			K8s部署Vue应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 前面讲述了k8s部署spring boot应用，原理一样，部署vue前端应用也是一样的步骤：打包-制作docker镜像-k8s部署。
二、打包 笔者使用webstorm开发工具，打包命令：
npm run build 打包成功后，会生成文件夹dist。
三、制作镜像 首先要下载nginx基础镜像：
docker pull nginx 该条命令会下载最新版本的nginx基础镜像。
编写nginx.conf文件： #user nobody; worker_processes 1; #error_log logs/error.log; #error_log logs/error.log notice; #error_log logs/error.log info; #pid logs/nginx.pid; events { worker_connections 1024; } http { include mime.types; default_type application/octet-stream; #log_format main '$remote_addr - $remote_user [$time_local] "$request" ' # '$status $body_bytes_sent "$http_referer" ' # '"$http_user_agent" "$http_x_forwarded_for"'; #access_log logs/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; server { listen 32000; server_name localhost; location / { #root html; #index index.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/471e3842e556794d719188837c921ccd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d18c3ac62a762a13ce18726a15b44a75/" rel="bookmark">
			#编码风格# #Google C&#43;&#43;# 其他C&#43;&#43;特性(OtherC&#43;&#43;Fetures)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
引用参数（Reference Arguments）
函数重载(Function Overloading)
默认参数(Default Arguments)
可变长度数组和内存申请(Variable-Length Arrays and alloca())
友元(Friends)
异常处理(Excpetions)
运行时类型信息(Run-Time Type Information, RTTI)
类型转换(Casting)
流(Streams)
前置自增和前置自减(Preincrement and Predecrement)
const修饰符的使用(Use of const)
整型类型(Integer Types)
64位兼容性(64-bit Portability)
预处理宏(Preprocessor Macros)
0和空(0 and NULL)
存储容量运算符(sizeof)
增强库(Boost)
C++ 0x库
引用参数（Reference Arguments） 所有用引用传值的变量应该被const修饰。
定义：
在C语⾔言中，如果函数需要修改一个变量，必须使用指针作为其参数。比如int foo(int*pval)。但在C++中，有了另一种方式，即引用：int foo(int &amp;val)。
利：把一个参数定义为引用可以避免丑陋的代码（比如*pval++）。有些程序需要，比如复制构造函数。使程序更明确，不像指针能取得NULL值。弊：由于引用兼具值表达式和指针的主义，会引起迷惑。 结论：
所有函数引用参数都应该定义为const引用。
void Foo(const string &amp;in, string *out); 实际上，将值或者常引用作为输入参数而将指针作为输出参数是谷歌的一个惯例。输入参数也可以是常指针，但不允许非const(non-const)引用。将常指针作为输入参数的一种情况是，你想强调这个参数将不被复制，它在对象的整个⽣生命周期内必须存在，但最好在注释中说明。标准模板库的适配器（比如bind2nd和mem_fun）不允许引用参数，这时只有用指针了。
函数重载(Function Overloading) 看到一个函数的调用⽴立即能知道其操作而不是需要⾸首先找出是哪个重载版本被调用了时，才使用重载函数。
class MyClass{ Public: void Analyze(const string &amp;text); void Analyze(const char *text,size_t textlen); }; 定义：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d18c3ac62a762a13ce18726a15b44a75/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eabc8d09f0065eadaab7c34b26a141df/" rel="bookmark">
			identityHashCode与hashCode详细对比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自：https://blog.csdn.net/weixin_34268843/article/details/86864970 简介
最近在看dubbo源码时，经常看到System.identityHashCode(obj) 的使用，想了解一下这个跟我们平常的hashcode方法又有啥异同，所以本篇简单的探讨一下。
概念
1、hashCode是 java.lang.Object.hashCode() 或者 java.lang.System.identityHashCode(obj) 会返回的值。他是一个对象的身份标识。官方称呼为：标识哈希码（ identity hash code）。
2、哪些特点?
（1）一个对象在其生命期中 identity hash code 必定保持不变；
（2）如果a == b，那么他们的System.identityHashCode() 必须相等；
如果他们的System.identityHashCode() 不相等，那他们必定不是同一个对象（逆否命题与原命题真实性总是相同）；
（3）如果System.identityHashCode() 相等的话，并不能保证 a == b（毕竟这只是一个散列值，是允许冲突的）。
3、有什么作用？
加速对象去重：由特征2可知，只要判断出两个对象的hashCode不一致，就知道这两个对象不是同一个；又因为hashCode()的性能比 " == "性能高得多，所以多数时候，用它来判断重复。
扩展：为啥hashCode()性能高？
因为hashCode()的结果算出来后缓存起来，下次调用直接用不需要重新计算，提高性能
identityHashCode
看官方提供的API , 对System.identityHashCode()的解释为 :
public static int identityHashCode([Object] x)
返回给定对象的哈希码，该代码与默认的方法 hashCode() 返回的代码一样，无论给定对象的类是否重写 hashCode()。null 引用的哈希码为 0。
obj.hashcode()
hashCode()方法是顶级类Object类的提供的一个方法，所有的类都可以进行对hashCode方法重写。这时hash值计算根据重写后的hashCode方法计算
异同
从上面的概念可以看出identityHashCode是根据Object类hashCode()方法来计算hash值，无论子类是否重写了hashCode()方法。而obj.hashcode()是根据obj的hashcode()方法计算hash值
验证
@Test
public void testHashCode() {
TestExample example = new TestExample();
int exampleCode = System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eabc8d09f0065eadaab7c34b26a141df/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/516ac6086cbb764974b4168019e53f68/" rel="bookmark">
			图像特征之傅里叶描述子
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用C++、opencv获取轮廓的傅里叶描述子 傅里叶描述子是一种图像特征，具体来说，是一个用来描述轮廓的特征参数。其基本思想是用物体边界信息的傅里叶变换作为形状特征，将轮廓特征从空间域变换到频域内,，提取频域信息作为图像的特征向量。即用一个向量代表一个轮廓，将轮廓数字化，从而能更好地区分不同的轮廓，进而达到识别物体的目的。
关于傅里叶描述子的概述可参考论文（http://www.doc88.com/p-7176387138708.html）的2.3节。
在冈萨雷斯的《数字图象处理》一书中介绍了傅里叶描述子的详细原理：
总结：傅立叶描述子可以很好地描述轮廓特征，并且只需少量的描述子（即向量中的数不需要太多）即可大致代表整个轮廓。其次，对傅立叶描述字进行简单的归一化操作后，即可使描述子具有平移、旋转、尺度不变性，即不受轮廓在图像中的位置、角度及轮廓的缩放等影响，是一个鲁棒性较好的图像特征。
注：代码适用于物体已大致分割出来，并且图像中只存在1个目标物体的情况，其他情况需要视需求改代码。
#include "stdafx.h" #include &lt;opencv2/opencv.hpp&gt; #include &lt;iostream&gt; #include &lt;math.h&gt; #include &lt;opencv2/imgproc/imgproc.hpp&gt; #include &lt;opencv2/core/core.hpp&gt; #include &lt;opencv2/highgui/highgui.hpp&gt; using namespace cv; using namespace std; int main() { //读取图像 Mat src_image = imread("D:\\4.PNG"); //图像读取出错处理 if (!src_image.data) { cout &lt;&lt; "src image load failed!" &lt;&lt; endl; return -1; } //显示源图像 namedWindow("原图", WINDOW_NORMAL); imshow("原图", src_image); //此处高斯去燥有助于后面二值化处理的效果 //Mat blur_image; //GaussianBlur(src_image, blur_image, Size(15, 15), 0, 0); //imshow("GaussianBlur", blur_image); /*灰度变换与二值化*/ Mat gray_image, binary_image; cvtColor(src_image, gray_image, COLOR_BGR2GRAY); threshold(gray_image, binary_image, 30, 255, THRESH_BINARY | THRESH_TRIANGLE); imshow("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/516ac6086cbb764974b4168019e53f68/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66564ff48d8a661a207993bdea731cf3/" rel="bookmark">
			elasticsearch7.0无法创建索引
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题来源：QQ群小伙伴反馈 创建索引报错，截图如下。
解决方案：群内大神回复，官方文档中已解释：集群最大分片数只能是1000
总结：如果小伙伴也碰到无法创建索引，不妨先看看是否分片已达上限，然后删除或整理对应索引！
创建了一个技术闲聊群：有兴趣可加我微信，拉你一起讨论杂七杂八的技术，虽然大家都不怎么活跃！
加好友备注：你的博客名 &amp;&amp; 随便给我的任意文章点个赞或留言
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ba1794d1b3ead8e2227c1dc8167bb10/" rel="bookmark">
			java垃圾收集器和内存分配
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 java垃圾收集器 java垃圾收集器在一开始需要考虑完成三个问题：1.哪些内存需要回收，2.什么时候回收，3.如何回收。在java中第一件事就是确定哪些对象还存活，哪些对象需要回收，所以引出了不同策略算法
引用计数算法 给对象添加一个引用计数，当一个地方引用时，计数器加1，当引用无效时，减1，直到引用计数为0，但是缺点是很难解决对象之间相互循环引用问题
可达性分析算法 通过一系列称为“GC Roots”的对象作为起始点，从这些节点开始搜索，搜索的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，表示该对象不存活
可作为GC Roots的对象有：虚拟机栈中引用的对象，方法区中类静态属性引用的对象，方法区中常量引用的对象，本地方法栈中JNI引用的对象
引用 java中垃圾回收器收集无用的对象时，是无轮是何种算法，都是判断该对象是否有其他对象保持了对该对象的引用，如果没有，gc就会回收该对象。在现实中，我们需要保存另外一种情况，比如当内存充足时，保留该对象，当内存不够时，再回收，而这些在java语言中给了我们另外的处理，将引用分为 强引用，软引用，弱引用，虚引用，这4中引用
强引用：就是普通的创建对象过程“Object obj=new Object()”,这些对象永远不会被垃圾收集器回收软引用：在系统内存溢出之前，会对这些对象进行回收，java中提供了SoftReference类来实现软引用弱引用：当垃圾回收器回收对象时，不管内存是否足够，都会回收处理，java提供了WeakReference类来实现虚引用：一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，目的是当对象被回收时，可以得到系统通知，java中提供了PhantomReference来实现 垃圾收集算法 标记清除算法：标记-标记出需要回收的对象，清除- 清理前面标记过的对象 缺点：1.效率不高（标记和清除过程效率不高），2.标记清除会产生不连续的内存碎片 复制算法：将内存按容量大小分为大小相等的两块，每次使用完其中的一块时，将还存活的对象复制到另一块上，然后清除使用过的内存。一种分配策略为：将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden空间和一块Survivor空间，当回收时，将还存活的对象一次性复制到另一块Survivor上。hotSpot上默认的比例为8:1标记整理：第一阶段标记，第二阶段整理，将存活的对象向一端移动，然后直接清理掉端边界以外的内存分代收集算法：对不同区域的内存使用不同的算法，比如：新生代：每次垃圾收集时只有少量对象存活，选择复制算法，对于老年代：由于对象存活率高，所以使用标记整理更适合 stop the world 当jvm执行可达性分析时，发生的java执行线程停顿，主要是为了保证在整个分析期间，整个执行系统不可以出现在分析过程中对象引用关系不断变化的情况，所以导致GC进行时必须停止所有的java执行线程
oopMap 在jvm中如何可以更快的知道GC的根枚举，GC Roots主要在全局性的引用（常量或类静态属性）与执行上下文（本地变量表中的引用）中，很多应用上百兆，如果进行遍历查找，效率会非常低下。所以，jvm中使用OopMap数据结构来存储哪些地方存放着对象的引用，在类加载完成后，jvm就将对象内什么偏移量是什么数据类型计算出来，保存到OopMap中，在jit编译时，在特定的位置记录栈和寄存器中哪些位置是引用，这样在GC时，就可以直接得到信息
安全点 jvm会在特定的位置记录这些类对象地址信息，这个特殊位置称为安全点，既程序执行到达安全点时才能暂停，开始GC回收垃圾，在多线程中，垃圾回收器会等待所有线程进入安全点后才回收垃圾，多线程情况下主要有两种方案可供选择：1.抢先式中断和主动式中断
抢先式中断：在GC发生时，首先将所有线程全部中断，如果有线程中断的地方不在安全点，就恢复线程，继续跑到安全点主动式中断：当GC需要中断时，设置中断标志，当线程执行到安全点时轮询标志，发现中断标志就中断挂起 安全区域 当线程处于sleep或blocked状态时，线程无法响应jvm的中断请求，所以出现安全区域，安全区域是指：在一段代码片段中，引用关系不会发生变化，在这个区域内任何地方开始GC都是安全的。当线程执行到安全区域时，首先标示进入了安全区域，当线程要离开安全区域时，先要检查是否完成根节点枚举，如果完成了就继续执行，否则就等待直到可以安全离开为止
垃圾收集 serial收集器：serial收集器是一个单线程的收集器，它在工作时必须stop the world，直到收集结束ParNew收集器：使用多线程进行垃圾收集，就是多线程版本的serial收集器Paraller scavenge收集器：Paraller 收集器是一个新生带收集器，采用复制算法，采用多线程标记。此收集器目标是达到一个可控制的吞吐量（吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)）。所以主要适合在后台运算而不需要太多交互的任务，可以通过-XX:MaxGCPauseMillis 设置垃圾收集最大停顿时间，虚拟机将会调整堆的大小来适应GC的停顿时间，和-XX:GCTimeRatio设置吞吐量参数：吞吐量为垃圾回收时间与非垃圾回收时间的比值，公式为1/（1+N）。例如，-XX:GCTimeRatio=19时，表示5%的时间用于垃圾回收。默认情况为99serial old 收集器：serial old 收集器是在老年代区域运行的收集器，是一个单线程收集器，使用标记整理算法，Paraller Old 收集器：他是Paraller scavenge收集器的老年版本，使用多线程和标记-整理算法cms收集器：cms收集器是以获取最短回收停顿时 间为目标的收集器，它是以标记-清除算法实现的，主要过程为：1.初始标记(标记GCRoot 能直接关联的对象) 2.并发标记（进行GC root 重新追溯），3.重新标记（修正并发标记产生的误差） 4.并发清除（清除），其中初始标记和重新标记是需要stop the world。但是cms有三个明显的缺点：1.cms收集器对cpu资源敏感，2.cms无法处理浮动垃圾（在并发清理过程中产生的垃圾） 3.cms是基于标记-清除算法的，会产生空间碎片G1收集器:G1收集器是目前最新的垃圾收集器，它的特点有：1.并发与并行，2.分代收集，3.空间整合：不会产生的空间碎片 4.可预测停顿。G1收集器将java内存堆分为大小相等的独立区域，新生代和老年代都是一部分区域的集合。G1收集器在进行垃圾收集的时候，他是有计划地避免在整个java堆中进行全区域的垃圾收集，G1维护了一个不同区域的优先列表，每次根据允许的收集时间，优先回收价值最大的区域 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b4d6deead1890571b2d28644764451b/" rel="bookmark">
			一个LSTM层中隐向量的个数怎么理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考 https://www.reddit.com/r/MachineLearning/comments/87djn7/d_what_is_meant_by_number_of_hidden_units_in_an/
LSTM有input gate, forget gate, output gate，这些gate都是将本时刻的输入和上一时刻的隐含状态作为输入得到的, 在计算过程中会产生3个本时刻输入前的参数 W(i)， W(f)， W(o)和3个上一时刻隐状态前的参数U(i)，U(f)，U(o)
假设某时刻输入的形状是[n_input_feature]， 那3个W的形状就是[n_input_feature, num_units]，其中num_units就是该LSTM单元输出的隐向量的个数。3个U的形状是[num_units, num_units]。num_units就是使用tensorflow的tf.nn.rnn_cell.LSTMCell()函数中需要输入的num_units参数。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/deccba7360f8712e898e776e6f7464c8/" rel="bookmark">
			SSM到Spring Boot 从零开发校园商铺平台11-7到11-12 添加平台账号体系讲解及代码的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、添加平台账号dao层的开发 1.1dao层的LocalAuthDao的代码 1.2dao层的LocalAuthDao.xml的代码 二、添加平台账号service层的开发 2.1接口LocalAuthService的代码及讲解 2.2接口LocalAuthServiceImpl的代码及讲解2.3MD5的加密 三、添加平台账号controller层的开发 3.1LocalAuthController的代码及讲解 四、添加平台账号前端的实现4.1绑定微信页面4.2修改密码页面4.3登录页面 一、添加平台账号dao层的开发 1.1dao层的LocalAuthDao的代码 package com.imooc.o2o.dao; import java.util.Date; import org.apache.ibatis.annotations.Param; import com.imooc.o2o.entity.LocalAuth; public interface LocalAuthDao { /** * 通过账号和密码查询对应信息，登录用 * @param userName * @param password * @return */ LocalAuth queryLocalByUserNameAndPwd(@Param("userName") String userName, @Param("password") String password); /** * 通过用户id查询对应localauth * @param userId * @return */ LocalAuth queryLocalByUserId(@Param("userId") long userId); /** * 添加平台账号 * @param localAuth * @return */ int insertLocalAuth(LocalAuth localAuth); /** * 通过userid，username，password更改密码 * @param localAuth * @return */ int updateLocalAuth(@Param("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/deccba7360f8712e898e776e6f7464c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7edbf724d3e21c8a46eb946a6301b7a/" rel="bookmark">
			apk反编译
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		APK反编译
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fcc31984530dc2118ee8b9662aed2085/" rel="bookmark">
			C&#43;&#43;---之MFC绘制坐标轴及函数图像（运行出现不存在从CStrign到const char*的转换报错问题的解决）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实现步骤：
利用VS建立MFC基于对话框的工程，其他默认。
之后添加两个文本输入控件，两个按钮控件，并为文本控件建立两个Csting型的变量。
打开文件名+Dlg.cpp。找到:OnPaint() 函数，在该函数最后的 }前添加实现代码。
程序运行截图：
本资源下载地址（VS2015解决方案打包，可直接运行）
https://download.csdn.net/download/weixin_44754046/11117713
注：
运行代码过程中，出现不存在从CStrign到const char*的转换报错。
解决方法：
将项目属性的字符集设置从"使用Unicode字符集“转换为”使用多字字符集“，点击”项目“----“属性”----“配置属性”----”常规“----”字符集“更改。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1e2395621e6140c4c6959dce9ec7e68/" rel="bookmark">
			MATLAB的共轭转置和普通转置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MATLAB有两种矩阵转置：
' 共轭转置 .' 普通转置 一定注意在使用转置的时候，当矩阵都是实数的时候，用哪种转置都没有区别，但是一定要注意如果矩阵有虚部的时候，一定不能用共轭转置。
示例如下：
&gt;&gt; A=[1+1i;2+2*1i;3+3*1i]
A =
1.0000 + 1.0000i
2.0000 + 2.0000i
3.0000 + 3.0000i
&gt;&gt; A'
ans =
1.0000 - 1.0000i 2.0000 - 2.0000i 3.0000 - 3.0000i
&gt;&gt; A.'
ans =
1.0000 + 1.0000i 2.0000 + 2.0000i 3.0000 + 3.0000i
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c91dff21dd01368de61a6aaeaf200791/" rel="bookmark">
			pcl笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1直线拟合
import pcl def fit_line_model(pcd): """Fits a line by RANSAC method to points in pcd.""" ransac_distance_threshold = 0.03 if pcd.size == 0: return None point_cloud = pcl.PointCloud(pcd.astype(np.float32)) seg = point_cloud.make_segmenter_normals(ksearch=50) seg.set_model_type(pcl.SACMODEL_LINE) seg.set_method_type(pcl.SAC_RANSAC) seg.set_max_iterations(1000) seg.set_distance_threshold(ransac_distance_threshold) indices, model = seg.segment() inlier_ratio = np.float(len(indices)) / arr.shape[0] logging.info("percentage of points in line model: %f", inlier_ratio) if inlier_ratio &lt; 0.5: logging.warn('Refuse this line model because of less than half of its.' 'points are selected by ransac method.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c91dff21dd01368de61a6aaeaf200791/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc21d88efaa9f8081d3d267f6eadccd5/" rel="bookmark">
			使用OpenCV和Python进行对象检测和跟踪
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在此功能中，我将介绍使用OpenCV和Python代码设置对象检测和跟踪所需的功能。使用随附的代码片段，您可以轻松设置Raspberry Pi和网络摄像头，以便制作用于物体检测的便携式图像传感器。
本文适用于任何希望在Raspberry Pi项目中使用OpenCV的人。一些项目可以包括用于避障或航路点跟踪的Raspberry Pi机器人车辆。此外，包括对象计数和监视。
物体检测 对象检测建立在我上一篇文章的基础上，我在其中应用颜色范围以允许通过蒙版显示感兴趣的区域。在此功能中，我继续使用颜色作为对对象进行分类的方法。如果我可以按颜色对对象进行分类，我可以跟踪从视频帧到视频帧的对象。为此，对象必须与周围区域的颜色不同。但是，可以使用OpenCV方法过滤掉相似颜色的较小对象。
塑料儿童游戏坑球红色，蓝色，黄色和绿色
对于Pi Wars挑战，我的机器人需要能够检测和跟踪不同颜色的圆形塑料球。因此，我将使用这些圆球的示例来测试下面的代码。
我将使用颜色对这些塑料球进行分类，但请注意，这不是对对象进行分类的唯一方法。由于塑料球是一种良好的固体均匀颜色，因此在这种情况下，通过颜色进行物体检测是最佳选择。
使用Python进行对象检测 下面的所有代码片段都包含在本文末尾附近的示例OpenCV示例程序中。
对象分类
颜色阈值
塑料玩坑球作为检测对象
我选择按颜色检测塑料球，所以我需要设置颜色范围，我可以用它来分类每个彩色球。
blue = (104, 117, 222, 121, 255, 255) 我使用数组来保存较低和较高颜色阈值的值。颜色阈值使用HSV（色调饱和度值）颜色配置文件。
颜色转换
frameHSV = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV) 在我可以使用定义彩色球的HSV配置文件值之前，我必须将捕获的网络摄像头帧转换为HSV颜色配置文件。
创建一个面具
物体检测掩模
colorLow = np.array([lowHue,lowSat,lowVal]) colorHigh = np.array([highHue,highSat,highVal]) mask = cv2.inRange(frameHSV, colorLow, colorHigh) 在这里，我使用我为球设置的颜色范围来创建蒙版。掩模将使查找检测到的对象周围的轮廓更有效。白色区域是在上面设置的颜色范围内找到的感兴趣区域。我可以使用各种图像滤镜来改善图像蒙版。然而，应用滤光器以获得完美的掩模在处理能力方面可能是昂贵的。
OpenCV轮廓
查找轮廓
im2, contours, hierarchy = cv2.findContours(mask, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE) 现在我有一个可以使用的图像蒙版，我可以继续寻找轮廓。第三个参数，轮廓近似方法，只收集直线的端点坐标。蒙版中的所有白色斑点都将应用轮廓。找到的轮廓的数组列表将位于轮廓变量中。
（可选）绘制所有轮廓
OpenCV查找轮廓示例
cv2.drawContours(frame, contours, -1, (0,255,0), 3) 检测到两个对象，并且一些较深的蓝色超出了之前设置的阈值范围。如果面罩的质量很嘈杂，那么会有很多轮廓 - 许多小轮廓。为了获得有用的物体检测，我需要删除不需要的轮廓。
上图显示了塑料球盘旋的轮廓; 我的目标是在下一步中将其分离出来。
（可选）查找最大轮廓
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc21d88efaa9f8081d3d267f6eadccd5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb6af40d587686eb232534660d87d3a0/" rel="bookmark">
			泛微 建模 公共下拉框对应数据库表 查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		公共选择框对应实体表是数值，如报表展现选择框值，就可通过主外键关联显示名称;
mode_selectitempagedetail 建模模型下拉选项item存储表。
mainid:对应表单列标识。
ID:建模下拉列表ID；
disorder：实际储存数据库表值ID。disorder初始为0，添加一选项递升。
select ID，t.* from mode_selectitempagedetail t where t.mainid =11 order by disorder
关联查询下拉列表名称：
select t1.name from table t ,mode_selectitempagedetail t1 = t.celvalue = t1.disorder and t1.mainid = ?；
每天记录一点，生活会好一点。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41286ad8a14458b0a1d4a65f41a6a9f1/" rel="bookmark">
			vue前端项目打包并且在服务器上部署过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		两篇推荐博客：
https://blog.csdn.net/qq_33661804/article/details/85340697
https://blog.csdn.net/kaola_l/article/details/80497490
https://blog.csdn.net/qq_32340877/article/details/79105565
https://blog.csdn.net/jingtian678/article/details/80637948
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/288646952dae90318e2b9d2a5ee783a6/" rel="bookmark">
			使用Python进行OpenCV颜色检测和过滤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OpenCV颜色检测和过滤是启动OpenCV Python开发的绝佳场所。在本文中，我将介绍一个基本的Python程序，以便开始使用OpenCV。该程序将允许用户尝试颜色过滤和检测例程。本文标志着我开始创建对象检测机器人的开始。
OpenCV（开源计算机视觉库）用于过滤从视频流，视频文件或图像文件中获取的图像。使用支持的编程语言时，您可以创建程序以使用相机作为传感器来检测和跟踪图像中的元素。如果可以隔离图像中的元素，则可以检测和跟踪视频流中的元素。
塑料球红色，蓝色，黄色和绿色
2018年Pi Wars 4.0
我已经对OpenCV感兴趣了几年了，但直到现在我还没有很好地利用它。我最近与OpenCV合作的动机是最近的Pi Wars 比赛。比赛中的挑战之一叫做“彩虹之上的某个地方”。这一挑战要求竞争机器人检测四种不同颜色（红色，蓝色，黄色和绿色）的四个球。机器人必须以特定的颜色顺序驾驶每个球，以完成对可用最佳点的挑战。
因此，为了能够在“彩虹上的某个地方”挑战中做出一些努力，我将看到如何检测四种不同的颜色。因此，OpenCV颜色检测是识别感兴趣的四种颜色的良好起点 - 红色，蓝色，黄色和绿色。
OpenCV颜色检测 OpenCV颜色检测只是一个起点。最终目标是最终使用Python 3代码在视频流帧中定位彩色元素位置。因此，如果我可以隔离和跟踪视频流中的元素，我可以为机器人设置一个航点，例如。
安装OpenCV
要运行OpenCV颜色检测示例Python程序，您必须在Raspberry Pi或Windows OS上安装OpenCV。
覆盆子皮
要快速将OpenCV安装到Raspberry Pi，您可以按照本文从shell脚本文件安装OpenCV。您可以下载并启动shell脚本，以便一次性安装OpenCV和所有依赖项。
从Shell脚本 - 链接安装OpenCV到Raspberry Pi 。
Windows 10
如果您有兴趣在Windows 10上运行OpenCV，则需要安装Python。然后，使用Python pip包管理器安装Numpy和OpenCV库。我相信Python包含带有Windows Python安装的pip包管理器。
下载并安装适用于Windows的最新Python 3软件。然后在Windows命令提示符下安装以下软件包： pip3 install numpy pip3 install opencv-python 现在，Idle应用程序可用于在Windows中运行和编辑Python代码。
OpenCV颜色检测示例代码 我的GitHub提供了两个版本的OpenCV颜色检测Python 3代码示例。它们之间的唯一区别是它们打开的媒体类型。因此，一个Python代码示例打开一个图像文件，而另一个打开视频流。但是，如果你在一个虚拟机环境中运行Linux或树莓派，像一个精选本后，您可能只能够打开的图像或视频文件。
覆盆子Pi相机
为了我的目的和示例代码兼容性，我使用Banggood的廉价USB Raspberry Pi兼容网络摄像头（产品编号：1023048）。耗费5.10英镑（6.67美元）的网络摄像头，与Raspberry Pi相机相比，使用更长的电缆更加强大。
但是，如果您想将Raspberry Pi相机与下面的代码示例一起使用，请查看以下资源以获取指南的链接。该指南将解释如何在OpenCV中使用Raspberry Pi相机。
示例Python程序如何工作
在Raspberry Pi或Windows桌面上使用Python Idle应用程序运行下面的代码。窗口应该出现在桌面上，如上图所示。您可以操作HSV（色相，饱和度，值）滑块以隔离要在图像中检测的颜色。
使用GUI滑块定义新颜色时，首先重置滑块。因此前三个滑块变为零; 底部三个转到255.应首先更改低和高Hue值以锁定所需的颜色。然后调整低饱和度和值以进行微调。
选择的低和高之间的HSV值范围将用于在要检测的颜色配置文件周围创建掩模。尝试不同的图像，以更好地了解隔离各种颜色的挑战。
请在下面的参考资料中查看GitHub链接到此代码的两个版本和测试图像。
OpenCV颜色检测代码
#!/usr/bin/env python3 """ File: opencv-open-file-color-test.py This Python 3 code is published in relation to the article below: https://www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/288646952dae90318e2b9d2a5ee783a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2184ac42a277a9ab9873ce70a221294b/" rel="bookmark">
			C#反射实现对象关系映射（ORM）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ORM在业界广泛使用，导致程序员对数据库的操作水平不断下降，可能技术发展就是这样吧，老技术终究会被新技术取代，因为其不断地封装，使得代码操作上越来越简单。也许只有BAT和微软更注重老技术的传承了吧。
笔者也简单的封装了一个ORM框架。因为没有研究过别人的ORM到底是怎么封装的，全凭反射和动态拼sql这2个ORM的重要概念。所以封装的不好的地方轻喷
先给出类结构，注意这个类的设计必须符合JavaBean的规范，不明白什么是JavaBean的读者可以百度去查阅相关资料。这里索引列，即id必须放在第一行
class Student { private int id; private string name; private Boolean sex; private string phone; public int Id { get { return id; } set { id = value; } } public string Name { get { return name; } set { name = value; } } public Boolean Sex { get { return sex; } set { sex = value; } } public string Phone { get { return phone; } set { phone = value; } } } class Course { private int id; private string name; private decimal cost; public int Id { get { return id; } set { id = value; } } public string Name { get { return name; } set { name = value; } } public decimal Cost { get { return cost; } set { cost = value; } } } 数据库中创建符合这2个类的表结构，Boolean类型在数据库中是BIT
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2184ac42a277a9ab9873ce70a221294b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/291a5c7845d1bff391b77e15b87586c4/" rel="bookmark">
			关于NLP中自然语言的处理---- bert算法的使用心得 （新手）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里只讲述怎么 用bert来处理 我们文本分类的问题： 具体 代码 见github :
具体的bert 模型可以参考 github 上面的bert 以及肖博士的bert 服务
首先说一下 bert 里面 的 run_classifier.py 用来进行文本分类
run_squad.py 用来做阅读理解类型的
这里修改的内容 主要来自 我们run_classifier.py 其他的可以 不变，主要书写自己的逻辑 定义在
class SelfProcessor(DataProcessor) 中 具体代码：
# coding=utf-8 # Copyright 2018 The Google AI Language Team Authors. # # Licensed under the Apache License, Version 2.0 (the "License"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/291a5c7845d1bff391b77e15b87586c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8dddc1c230d3fc1b92ff873c673076f/" rel="bookmark">
			Python实现二叉树遍历的递归和非递归算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文主要用python实现二叉树的4种遍历算法，除层次遍历外，前序、中序和后序遍历分别包含递归和非递归2种实现方式。 前序遍历 # -----------前序遍历 ------------ # 递归算法 def pre_order_recursive(self, T): if T == None: return print(T.root, end=' ') self.pre_order_recursive(T.lchild) self.pre_order_recursive(T.rchild) # 非递归算法 def pre_order_non_recursive(self, T): """借助栈实现前驱遍历 """ if T == None: return stack = [] while T or len(stack) &gt; 0: if T: stack.append(T) print(T.root, end=' ') T = T.lchild else: T = stack[-1] stack.pop() T = T.rchild 中序遍历 # -----------中序遍历 ------------ # 递归算法 def mid_order_recursive(self, T): if T == None: return self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a8dddc1c230d3fc1b92ff873c673076f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/974a90df06d8707a96427654edebe104/" rel="bookmark">
			3、TM4之GPIO的输入输出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		3、TM4C123G单片机之GPIO 1、输出：点亮LED 原理图
IO口输出高电平点亮LED，下面我们学习如何控制IO口的高低电平。
方式一： SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOF);	//端口F外设使能 GPIOPinTypeGPIOOutput(GPIO_PORTF_BASE, GPIO_PIN_1);	//PF1设置为输出 GPIOPinWrite(GPIO_PORTF_BASE, GPIO_PIN_1, GPIO_PIN_1);	//PF1输出高电平 相应的PF1置低：
GPIOPinWrite(GPIO_PORTF_BASE, GPIO_PIN_1, 0);//PF1输出低电平
方式二： SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOF); GPIOPadConfigSet(GPIO_PORTF_BASE,GPIO_PIN_1,GPIO_STRENGTH_2MA,GPIO_PIN_TYPE_STD); GPIODirModeSet(GPIO_PORTF_BASE, GPIO_PIN_1, GPIO_DIR_MODE_OUT); GPIOPinWrite(GPIO_PORTF_BASE, GPIO_PIN_1, GPIO_PIN_1); 这两种方式其实是一样的，因为这个GPIOPinTypeGPIOOutput函数是又被封装了一次，可以看看其定义：
void GPIOPinTypeGPIOOutput(uint32_t ui32Port, uint8_t ui8Pins) { // // Check the arguments. // ASSERT(_GPIOBaseValid(ui32Port)); // // Set the pad(s) for standard push-pull operation. // GPIOPadConfigSet(ui32Port, ui8Pins, GPIO_STRENGTH_2MA, GPIO_PIN_TYPE_STD); // // Make the pin(s) be outputs. // GPIODirModeSet(ui32Port, ui8Pins, GPIO_DIR_MODE_OUT); } 可以看出里面包含了GPIOPadConfigSet和GPIODirModeSet两个函数。关于这两个函数的详细使用在下面的GPIO输入里面详细讲解。
2、输入：按键检测 原理图
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/974a90df06d8707a96427654edebe104/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/514aed4d5abfad00ca3eb0ea6133cbca/" rel="bookmark">
			springboot使用RequestBody接受请求对象出现405
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2019独角兽企业重金招聘Python工程师标准&gt;&gt;&gt; 如果使用RequestBody接受请求对象时，框架直接反馈给前端状态码405，有可能是数据序列化出现异常。可在这一行断点查看详细报错信息。
具体位置如下：
spring-web-5.0.8
解析requestBody报错出处
org.springframework.http.converter.json.readJavaType
转载于:https://my.oschina.net/u/1788620/blog/3036933
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/327eb614e6a1ca1e20a405b44f9b739c/" rel="bookmark">
			CSS常用的两种投影边框颜色
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基础投影 box-shadow: 0 2px 4px rgba(0, 0, 0, .12), 0 0 6px rgba(0, 0, 0, .04)
浅色投影 box-shadow: 0 2px 12px 0 rgba(0, 0, 0, 0.1)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59bbc06c2d355e2a86e4f4a395cd6b99/" rel="bookmark">
			Java中main方法的6种声明形式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前记：今天刷牛客，遇到了这道题目，平时只见到第一种，没想到居然可以有多种形式。在此记下，谨记共勉。
Java中main方法的6种声明形式： 第一种，最常规形式 public static void main(String[] args) 第二种，方括号在形参后面 public static void main(String args[]) 第三种，可变长参数形式，三个点前后有无空格都可以 public static void main(String... args) 第四到六种：将前三种中的 public 和 static 修饰符更换位置 static public void main(String[] args) static public void main(String args[]) static public void main(String... args) 附上牛客的题目，原来第三选项选错的原因是因为返回值为int：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ccfcade852761610efce2b7d56bff5e9/" rel="bookmark">
			Unity UGUI 如何解决不规则按钮的点击区域问题？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		直接贴代码：
//对不规则的按钮的点击范围进行设置，按钮默认是局限区域。当alphaHitTestMinimumThreshold = 0.5f时，透明区域（没有图片区域）将忽略按钮/射线检测
btn.GetComponent().alphaHitTestMinimumThreshold = 0.5f;
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/482/">«</a>
	<span class="pagination__item pagination__item--current">483/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/484/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>