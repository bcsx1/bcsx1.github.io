<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69a1de97940b87ef2fabf5a1fd53542e/" rel="bookmark">
			python too many values to unpack (expected 3)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 too many values to unpack (expected 3)
这个错误是因为函数返回值少于自己调函数时等号左边给的值
例：
tokens, segments, masks= convert_lines(train["title_content"], MAX_SEQUENCE_LENGTH, tokenizer) 这里等号左边三个值，而函数中只返回一个array，则报错。也有可能是把,号打成.没发现导致这个错误。
按照自己的目的要么改左边的值要么改函数返回值。
def convert_lines(example, max_seq_length,tokenizer): #选取头尾的部分 max_seq_length -=2 all_tokens = [] longer = 0 for text in tqdm(example): tokens_a = tokenizer.tokenize(text) if len(tokens_a)&gt;max_seq_length: # tokens_a = tokens_a[:max_seq_length] half_seq_length = (int)(max_seq_length/2) tokens_a = tokens_a[:half_seq_length] + tokens_a[len(tokens_a)-half_seq_length:] longer += 1 one_token = tokenizer.convert_tokens_to_ids(["[CLS]"]+tokens_a+["[SEP]"])+[0] * (max_seq_length - len(tokens_a)) all_tokens.append(one_token) return np.array(all_tokens) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82026109d6dea6e80915f2eec9b52c2a/" rel="bookmark">
			用OpenCV3进行图像处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 高通滤波器2. Canny算法边缘检测3.直线检测（HoughLines函数和HoughLinesP函数）4.圆检测5. 轮廓检测 1. 高通滤波器 高通滤波器（HPF）是检测图像的某个区域，跟后根据像素和周围像素的亮度差值来提升（boost）该像素的滤波器。
遇到的问题：第一次运行该程序时还出现了 ImportError: DLL load failed: 找不到指定的模块。
问题原因是numpy没找到支持blas的库。
解决办法：
https://www.lfd.uci.edu/~gohlke/pythonlibs/
下载与自己python版本对应的 numpy+mkl
pip install 此安装文件
import cv2 import numpy as np from scipy import ndimage kernel_3x3 = np.array([[-1, -1, -1], [-1, 8, -1], [-1, -1, -1]]) kernel_5x5 = np.array([[-1, -1, -1, -1, -1], [-1, 1, 2, 1, -1], [-1, 2, 4, 2, -1], [-1, 1, 2, 1, -1], [-1, -1, -1, -1, -1]]) img = cv2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/82026109d6dea6e80915f2eec9b52c2a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2ca27ddeb4af2558a2f2ca92aef780e/" rel="bookmark">
			UE4学习制作案例01——资源下载与迁移、场景搭建与光照调整、创建一个蓝图类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 资源下载与迁移 去Epic商场下载免费项目资源（注意资源支持的版本号）。新建项目将其添加到项目既可。
场景搭建与光照调整 简单搭建 -----》加入太阳光-------》加入大气雾-------》设置太阳，将其作为大气雾的光源
加入玩家起点-----》加入天空球，并将其光照对象设置为之前的太阳光
放入球体反射捕捉
调整太阳射光方向（垂直正午，倾斜早晚），天空球上的太阳位置匹配可以通过刷新天空球材质的方法
让太阳看起来更生动。设置太阳的光束，讲光束的阻塞和泛光打开。天空球的太阳亮度调低。以及调整太光束的泛光大小。
光线照不到的地方现在一片黑。加入天空光源解决。
走近会发现过度的曝光补偿。把PostProcessVolume放入场景 ，并设置其曝光的最大最小值，无限延伸。
创建一个蓝图类 在项目目录下创建一个文件夹BP，专门放蓝图类。创建蓝图选择Actor类，以BP为开头命名。蓝图类和上面的场景对象不同，它可以交互。
打开蓝图类，在项目目录找到我们需要的对象放入其中（注意坐标放置在世界坐标中心上）
加入一个光源作为火光。注意光不能像上面一样直接从资源里面拖。需要从组件面板中添加。并调整灯光。
给灯光添加事件。进入事件面板。让 灯光强度变换。灯光变化强度和变化改变时间默认是固定的，缺乏随机性。加入random。
编译。保存。
待解决问题 火光跳动不流畅，光强度变换是离散的。怎么样解决？ 能否添加一个判断语句，碰到场景中的机关面板时火才出现？离开火熄灭？ 本想直接在场景中加入盒体触发器去控制上面蓝图类，没找到办法。就直接在蓝图内添加了组件----盒体碰撞，并调整它的位置，让它和关卡场景中的机关地板位置匹配。 2.添加盒体的事件（进入、离开事件），添加火焰粒子和光的设置可见性函数。
3.一开始是熄灭的，离开盒体也是熄灭的。所以有2个事件去触发设置函数。函数可见性默认布尔值就是0，为不可见，正好。
4.进入盒体出现火焰和光。此时只需注意把设置可见性函数的 “New Visibility”选项勾上，布尔值变成1，为可见。
5.编译，完成。
场景对象选择容易误选择。怎么暂时关闭某个类型的可选择性？ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/471e4e08754921120f20916b29842917/" rel="bookmark">
			快速解决，github打开慢问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文地址：https://www.cnblogs.com/yswenli/p/9419427.html
有人使用github后，在某些网络下发现打开慢，甚至打不开，这都是因为他是国外站；目前互联网的连接机制导致超过一定的路由节点的连接就会出现这个问题，解决办法就是直接告诉本机ip。不要先层层询问域名转ip，这样速度和连接的速度都可以进一步的大副提升，所以将下面的内容帖到本机的hosts文件中，你就有可能见证奇迹~
192.30.253.112 github.com
192.30.253.119 gist.github.com
151.101.100.133 assets-cdn.github.com
151.101.100.133 raw.githubusercontent.com
151.101.100.133 gist.githubusercontent.com
151.101.100.133 cloud.githubusercontent.com
151.101.100.133 camo.githubusercontent.com
151.101.100.133 avatars0.githubusercontent.com
151.101.100.133 avatars1.githubusercontent.com
151.101.100.133 avatars2.githubusercontent.com
151.101.100.133 avatars3.githubusercontent.com
151.101.100.133 avatars4.githubusercontent.com
151.101.100.133 avatars5.githubusercontent.com
151.101.100.133 avatars6.githubusercontent.com
151.101.100.133 avatars7.githubusercontent.com
151.101.100.133 avatars8.githubusercontent.com
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/214ebbed58d5a72955d4d84143e89cce/" rel="bookmark">
			Java面向对象_构造方法，重载，访问权限
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		整理了一些Java面向对象的笔记，记录在这里 @Zeii 构造方法 构造方法是创建对象时，自动调用的方法
语法:
public 类名(){
}
构造方法没有返回类型，名字与类名相同使用new创建对象时，会自动调用 public class Car { // 成员变量 String color; int speed; int seats = 5; // 构造方法,创建对象时自动调用 // 系统默认给一个无参的构造方法 // 当你创建了自己的构造方法时，会将系统的构造方法覆盖掉 public Car(String color, int speed) { this.color = color; this.speed = speed; } // 成员方法 public void run() { System.out.println("跑起来了"); System.out.println(this.color); System.out.println(this.speed); System.out.println(this.seats); } public static void main(String[] args) { Car c = new Car("红色", 180); //	c.color = "红色"; //	c.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/214ebbed58d5a72955d4d84143e89cce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/813f59e16ffa7488714376bc5a32f18d/" rel="bookmark">
			[Matlab]使用suptitle或sgtitle为SubPlot的Figure添加一个总标题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用Maltab画图时，subplot是非常常用的画图指令，它可以让我们将多个图像同时显示在一个figure中。但是，当我们想为这个figure添加一个总的标题时，则显得有点难搞。
Matlab为大家提供了suptitle和sgtitle等指令来实现为一个多subplots的figure添加一个总标题。suptitle和sgtitle在使用上用法相似，但功能上有较大区别。
suptitle及其用法 从help系统上可以看到，suptitle其实就是个普通的function,它的输入参数仅仅为一个字符串，所以在效果上非常非常的局限。
function hout=suptitle(str) %SUPTITLE puts a title above all subplots. % %	SUPTITLE('text') adds text to the top of the figure %	above all subplots (a "super title"). Use this function %	after all subplot commands. % % SUPTITLE is a helper function for yeastdemo. % Copyright 2003-2014 The MathWorks, Inc. % Warning: If the figure or axis units are non-default, this % function will temporarily change the units.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/813f59e16ffa7488714376bc5a32f18d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9df4d48a8a304769213ff9f7141620bb/" rel="bookmark">
			H3C单臂路由配置实验解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【实训名称】
通过路由器实现VLAN间路由
【实训目的】
掌握如何通过路由器实现VLAN间路由。
【实训功能】
使在不同VLAN里的计算机系统能跨交换机进行相互通信，而在不同VLAN里的计算机系统也能进行相互通信。
【实训设备】
MSR 20-40路由器（1台）、S5820V二层交换机（1台）、PC机三台
【相关知识介绍】
1.组网目的
二层交换机的Trunk端口与路由器子接口配合，一个路由器物理接口内的每个子接口对应交换机的一个VLAN，通过路由器内部子接口之间第三层包的相互转发，实现VLAN之间的第三层互通，是此类组网的目的。这是因为二层交换机没有路由功能，无法实现多个VLAN之间的第三层互通。
在此类组网中，路由器以太网子接口在一个VLAN中充当网关的作用。在配置时，其IP地址的子网号一定要正确，属于同一个VLAN的交换机各端口上的PC机的默认网关应该设置为该子接口的IP地址。
2.路由器的子接口介绍
所谓子接口，就是在一个物理接口上配置出来的多个逻辑上的虚接口。这些虚接口共用物理接口的物理层参数，又可以分别配置各自的链路层和网络层的参数。因为这样的多个虚接口可以对应一个物理接口，故常被称为“子接口”。
~~&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;~
在H3C系列的交换机中，支持子接口特性的物理接口包括三种：以太网接口、链路层协议为帧中继的广域网接口和链路层协议为X.25广域网的接口。
在路由器上创建子接口的命令 interface GigabitEthernet interface-number.subinterface-number
其中，interface-number为接口编号，包括槽号、卡号、端口号。
subinterface-number为子接口编号，取值范围为0～4096。 在实际使用中，一个父接口可创建的子接口数目最大为256。
例如，在以太网接口E0/0上创建一个子接口： [H3C]interface GigabitEthernet 0/0.2
[H3C-ethernet0/0.1] 在路由器上设置子接口的封装类型和VLAN ID Vlan-type dot1q vid vid
其中，vid 为VLAN ID号，用来标识一个VLAN，取值范围是1～4096。
此命令用来设置子接口上的封装类型为IEEE802.1Q。默认情况下，子接口上无封装，也没有和子接口关联的VLAN ID。
注意：在子接口设置中，必须先设置子接口封装类型及相应的VLAN，然后才能设置子接口的IP地址和掩码。
例如，设置以太网子接口E0/0.1与VLAN ID 60相关联，以太网子接口E0/0.1的封装类型为IEEE802.1Q：
[H3C-ethernet0/0.1]vlan-type dot1q vid 60
【实验步骤】
1.创建交换机的VLAN，并设置其端口及属性 [H3C]vlan 10
注：把端口划分到VLAN之中
[H3C-vlan10]port GigabitEthernet 1/0/1
[H3C-vlan10]vlan 20
[H3C-vlan20]port GigabitEthernet 1/0/2
[H3C-vlan20]vlan 30
[H3C-vlan30]port GigabitEthernet 1/0/3
interface GigabitEthernet 1/0/4
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9df4d48a8a304769213ff9f7141620bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bcb457d66c003cfaa09966aa4b01c3a1/" rel="bookmark">
			任意进制之间的转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 摘要任意进制转十进制十进制转任意进制二进制转十六进制十六进制转二进制 摘要 本文主要讲解整数的进制转换问题。方便的是，对于低精度整数，java中的整型基类Integer和Long中的parseXXX()方法和valueOf()方法可以将2 ~ 36进制的字符串转化为十进制整数，toString()方法可以将10进制数转化为2 ~ 36进制的字符串。对于高精度数，java中的大数类中也包含可以将2 ~ 36进制的字符串转化为BigInteger的构造函数。
任意进制转十进制 对于二进制数 1001 1001 1001，将其转化为十进制的一般做法： 1 ∗ 2 3 + 0 ∗ 2 2 + 0 ∗ 2 1 + 1 ∗ 2 0 1*2^3 + 0*2^2 + 0*2^1 + 1*2^0 1∗23+0∗22+0∗21+1∗20
同样，对于一个 P P P进制的数，我们同样可以这样做。
将一个 P P P进制的数 a 1 a 2 . . . a n a_1a_2...a_n a1​a2​...an​转化为十进制的数 Y Y Y的通式： Y = a 1 ∗ p n − 1 + a 2 ∗ p n − 2 + .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bcb457d66c003cfaa09966aa4b01c3a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4a6987448aca7de02bb6a5b4e44c5e7/" rel="bookmark">
			Error-State Kalman Filter教程(一)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 第五章：ESKF推导一、目标二、Error-State 卡尔曼滤波三、系统运动学(连续)1. 真实状态运动学2. 名义状态运动学3. 误差状态运动学 四、系统运动学(离散)1. 名义状态运动学2. 误差状态运动学3. 误差状态雅克比矩阵与扰动方程 第六章：IMU与其他传感器融合一、误差状态的观测1、雅克比矩阵 二、误差状态插入到名义状态三、ESKF重置四、仿真1. 仿真数据生成2. ESKF滤波 参考 本文代码， 见github; 如果您有任何疑问或者建议，请在文后留言。谢谢！ 第五章：ESKF推导 一、目标 使用error-state滤波方法优点
二、Error-State 卡尔曼滤波 把传统的状态量分为了三部分：(真实状态)true state, (名义状态)nominal state, (误差状态)error state.
ESKF主要的思想是：名义状态使用非线性的方式进行积分（无近似误差），误差状态使用线性的方式积分（有近似误差），但是和传统卡尔曼比起来，这个线性化误差会小一些。
三、系统运动学(连续) 系统涉及到的变量如下：
真实状态名义状态误差状态组合关系观测量噪声全部状态 x t x_t xt​ x x x δ x \delta x δx x t = x ⊕ δ x x_t = x\oplus \delta x xt​=x⊕δx位置P p t p_t pt​ p p p δ p \delta p δp p t = p + δ p p_t = p + \delta p pt​=p+δp速度v v t v_t vt​ v v v δ v \delta v δv v t = v + δ v v_t = v + \delta v vt​=v+δv加速度a a t a_t at​ a m = a t + a n a_m = a_t + a_n am​=at​+an​ a m a_m am​ a n a_n an​ 需要注意的是，在组合关系中，状态变量中的都是真值=名义状态+误差状态，而测量值中，测量值=真值+噪声，在实际使用过程中，不要弄混淆了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e4a6987448aca7de02bb6a5b4e44c5e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/443835da58505967b6b2ca688d7279e9/" rel="bookmark">
			运放为什么可以虚短虚断
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		运放“虚短” 的实现有两个条件： 1 ） 运放的开环增益A要足够大； 2 ） 要有负反馈电路。 先谈第一点，我们知道，运放的输出电压Vo等于正相输入端电压与反相输入端电压之差Vid乘以运放的开环增益A。即
Vo = Vid * A = （VI+ - VI-） * A （ 1 ）
由于在实际中运放的输出电压不会超过电源电压，是一个有限的值。在这种情况下，如果A 很大，（VI+ - VI-）就必然很小；如果（VI+ - VI-）小到某程度，那么我们实际上可以将其看作0，这个时候就会有VI+ = VI-，即运放的同相输入端的电压与反相输入端的电压相等，好象连在一起一样，这我们称为“虚短路” 。注意它们并未真正连在一起，而且它们之间还有电阻，这一点一定要牢记。
在上面的讨论中，我们是怎样得到“虚短” 的结果的呢？
我们的出发点是公式，它是运放的特性，是没有问题的，我们可以放心。然后，我们作了两个重要的假设，一个是运放的输出电压大小有限，这没有问题，运放输出当然不会超过电源，因此这个假设绝对成立，所以以后我们就不提了。第二个是说运放开环增益A很大。普通运放的A通常都达106，107甚至更高，这个假设一般没问题，但不要忘记，运放的实际开环增益还与其工作状态有关，离开了线性区，A就不一定大了，所以，这第二个假设是有条件的，我们也先记住这一点。
什么情况下运放才能用虚短和虚断的概念 因此我们知道，当运放的开环增益A很大时，运放可以有“虚短” 。但这只是可能性，不是自动就实现的，随便拿一个运放说它的两个输入端是“虚短” 没有人会相信。“虚短” 要在特定的电路中才能实现。
请先看图1的电路，如果我们将反相输入端IN-的电平固定，比如在0V，在同相输入端IN+加一个固定电压V1，并取V1 = 1mV，设运放的A = 10**6。这样，按照公式（ 1 ） ，运放的输出电压Vo应该为
Vo = A * （ V1 – 0 ）
= 1000000 * 1 /1000
= 1000 （V）
显然，Vo 到不了1000V，它上升不到VCC运放就饱和了，A也不再是1000000了，上面的计算完全不成立，输出电压停止在比VCC略小的数值上。
这种是没有负反馈的情况，比较器就工作在这种情况，“虚短” 在这里不存在，两个输入段之间的电压差是1mV。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/443835da58505967b6b2ca688d7279e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd1acc4af22938db3093e2589aeb832f/" rel="bookmark">
			Pr：Lumetri范围
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Pr菜单：窗口/Lumetri范围
Lumetri范围面板中包含了一组图示工具：矢量示波器、直方图、分量和波形等等。即使显示器硬件的色彩不准，通过它们，也可以客观、高效地辅助校色和调色工作。其实，学会看懂示波器，是视频调色中最基础、最重要的事情。
可以通过“预设”来决定显示什么样的图示工具，当然，最好是根据自己的偏好来手动选择。
最常用的有：
（1）波形（亮度）
可用于分析画面的明暗关系。比如，可在使用Lumetri颜色或RGB曲线效果控件调整画面曝光时参考 ；
（2）分量（RGB）或 波形（RGB）
可用于分析画面是否偏色，最好再结合“矢量示波器YUV”。比如，可在使用快速颜色校正器效果控件进行调整时参考。
（3）矢量示波器YUV
除了与上结合来进行校色与调色外，在校正视频中人物肤色时往往发挥关键用途。
五大图示方法
1、矢量示波器HLS（Vectorscope HLS）
显示色相、饱和度、亮度和信号信息。
由于显示不是特别明显，所以一般较少使用。
2、矢量示波器YUV（Vectorscope YUV）
最常用的示波器之一，显示一个圆形图（类似于色轮），用于显示视频的色度信息。
许多电影的橙青色调，就是按照-i线来分布色彩的。
常常配合使用Lumetri 颜色或快速颜色校正器效果控件进行调整。
有关矢量示波器的理解及使用方法，请参阅《影像分析器之：矢量示波器》。
3、直方图（Histogram）
显示每个颜色强度级别上像素密度的统计分析。与PS中的直方图一致，只不过图示逆时针旋转了90°。
直方图可用于准确评估阴影、中间调和高光，并调整总体的图像色调等级。
有关直方图示波器的理解及使用方法，请参阅《影像分析器之：直方图示波器》。
4、分量（Parade）
显示表示数字视频信号中的明亮度和色差通道级别的波形。
有四种分量类型：RGB、YUV、RGB-白色和YUV-白色。
（1）RGB
如果要比较红色、绿色和蓝色通道之间的关系，则使用RGB分量，它显示代表红色、绿色和蓝色通道级别的波形。
（2）YUV
如果习惯查看YUV波形，在调整颜色和明亮度时，则可使用YUV分量类型。
从某种程度上讲，YUV波形类似于PS中的Lab色彩模式。L通道表示亮度信息，a通道表示红绿色度信息，b通道表示黄蓝色度信息。
（3）RGB-白色
以灰度图的方式表现RGB分量。
（4）YUV-白色
以灰度图的方式表现YUV分量。
5、波形（Waveform）
有四种波形类型供选择：
（1）RGB
显示被覆盖的 RGB 信号，以提供所有颜色通道的信号级别的快照视图。
（2）亮度（Luma）
显示介于 -20 到 120 之间的IRE值，可有效地分析镜头的亮度并测量对比度比率。
（3）YC
显示剪辑中的明亮度（在波形中表示为绿色）和色度（表示为蓝色）值。
（4）YC无色度（YC no chroma）
仅显示剪辑中的明亮度值（绿色）。
有关波形示波器的理解和使用方法，请参阅《影像分析器之：波形示波器》。
关于亮度
可以从下列可用的亮度设置中进行选择，从而决定面板显示亮度：
明亮 = 125%
正常 = 100%
暗淡 = 50%
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd1acc4af22938db3093e2589aeb832f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/264f1f1663ce56d2299cd437aef3849a/" rel="bookmark">
			本机内网信息搜集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.查看用户信息 Windows命令net user，Linux命令cat /etc/passwd
2.查看进程信息 Windows命令tasklist，可以taskkill /pid 进程号 /f关闭对应进程
Linux命令ps aux或者top，强制终止进程kill -9 进程号。
3.查看服务类别 Windows命令net start
Linux命令chkconfig –list或者service –status-all
4.查看端口 Windows命令netstat -ano
Linux命令netstat -anptul，ps -aux过滤查看
5.补丁列表 Windows命令wmic qfe list full
Linux命令：uname -a查看版本号，rpm -qa查看源安装情况，再使用grep过滤一下。
6.共享 Windows 查看共享连接用 net use
查看本机共享用 net share
查看共享主机用 net view
df命令用来查看系统的space和inode使用情况,也是常用命令之一
-a 显示所有的文件系统,包括本地的和挂载的网络文件系统
-h 显示大小的时候,以人性化的方式来显示,以更适合的方式来显示
-T 现实文件系统类型
-t 显示指定的文件系统
-l 只显示本地文件系统
-k 以KB为单位显示
-x 不显示指定的文件系统
-i 显示inode使用情况
7.本地用户习惯 c:\windows\SchedLgU.txt，如果未启动Remote Storage Engine服务和Task Scheduler 服务，则不会做任何记录
C:\WINDOWS\Prefetch 文件夹，里面有记录用户曾经运行过什么程序，文件最前面的即为程序名
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/264f1f1663ce56d2299cd437aef3849a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6b9efcaf48be58a4859b3f0d8e28ecd/" rel="bookmark">
			解决Linux多个本地用户之间文件共享的问题，文件夹访问Permission Denied
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 主要思路就是用root权限创建文件夹，然后给文件夹分配用户组的权限，然后把所有需要访问这个文件夹的用户加到这个用户组当中来
例如有alex，bob两个用户，互相无法访问对方的home~文件夹，为了共享文件，可以让root用户在/home中创建一个shared文件夹，然后创建一个用户组dev01
在root或者sudo下： groupadd dev01 创建用户组之后添加文件夹并为文件夹更改组 mkdir /home/dev_shared chgrp dev01 /home/dev_shared 接下来更改文件夹权限，使得owner以及用户组可以访问,+s是为了确保之后添加进去的文件夹也继承同样的权限 chmod 770 /home/dev_shared chmod +s /home/dev_shared 然后将需要共享文件的用户添加到dev01这个用户组 usermod -a -G dev01 alex usermod -a -G dev01 bob 注意，使用root环境运行su - ， 而不是root权限su
至此，两人都可以访问/home/dev_shared文件夹了 另外，用户可以自行检查自己所在的用户组 groups 如果是全新的账户，root用户可以先建立新用户： useradd alex passwd alex 使用root权限查看所有的group情况 cat /etc/groups 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a561080ce1c099ba44ab30be2e3050f/" rel="bookmark">
			达梦数据库 主备
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实时主备由一个主库以及一个或者多个配置了实时（Realtime）归档的备库组成，其主要目的是保障数据库可用性，提高数据安全性。实时主备系统中，主库提供完整的数据库功能，备库提供只读服务。主库修改数据产生的Redo日志，通过实时归档机制，在写入联机Redo日志文件之前发送到备库，实时备库通过重演Redo日志与主库保持数据同步。当主库出现故障时，备库在将所有Redo日志重演结束后，就可以切换为主库对外提供数据库服务。
DM数据守护（DataWatch）的实现原理非常简单：将主库（生产库）产生的Redo日志传输到备库，备库接收并重新应用Redo日志，从而实现备库与主库的数据同步。DM数据守护的核心思想是监控数据库状态，获取主、备库数据同步情况，为Redo日志传输与重演过程中出现的各种异常情况提供一系列的解决方案。
数据库与数据库实例数据库（Database）是一个文件集合（包括数据文件、临时文件、重做日志文件和控制文件），保存在物理磁盘或文件系统中。数据库实例（Instance）就是一组操作系统进程（或者是一个多线程的进程）以及一些内存。通过数据库实例，可以操作数据库，一般情况下，我们访问、修改数据库都是通过数据库实例来完成的。
主库Primary模式，提供完整数据库服务的实例，一般来说主库是用来直接支撑应用系统的生产库。备库Standby模式，提供只读数据库服务的实例。备库除了用于容灾，还可以提供备份、查询等只读功能，并且备库还支持临时表的Insert/Delete/Update操作。备库支持临时表修改主要基于两个因素：1.临时表数据的修改不会产生Redo日志，主库对临时表的修改无法同步到备库；2.可以提供更大灵活性，适应更多应用场景。
根据数据同步情况，备库又可以分为可切换备库和不可切换备库。可切换备库是指，主备库之间数据完全同步，主库发生故障、备库切换为主库后，不会造成任何数据丢失的备库。
DM支持3种数据库模式：Normal模式、Primary模式和Standby模式。
Normal模式提供正常的数据库服务，操作没有限制。正常生成本地归档，但不发送实时归档（Realtime）、即时归档（Timely）和异步归档（Async）。
Primary模式提供正常的数据库服务，操作有极少限制。该模式下部分功能受限，包括：不支持修改表空间文件名、不支持修改arch_ini参数。正常生成本地归档，支持实时归档（Realtime）、即时归档（Timely）和异步归档（Async）。Primary模式下，对临时表空间以外的所有的数据库对象的修改操作都强制生成Redo日志。
Standby模式可以执行数据库备份、查询等只读数据库操作。正常生成本地归档，正常发送异步归档Redo日志；但实时归档（Realtime）、即时归档（Timely）均强制失效。该模式下时间触发器、事件触发器等都失效。
可以通过SQL语句切换数据库模式，模式切换必须在Mount状态下执行。
切换模式SQL语句如下：
将数据库切换为Primary模式：ALTERDATABASEPRIMARY;
将数据库切换为Standby模式：ALTERDATABASESTANDBY;
将数据库切换为Normal模式：ALTERDATABASENORMAL;
修改DMDSC库的模式必须在DMDSC库所有实例都处于MOUNT状态下才能进行，只需要在一个节点上执行以上语句即可。
实时归档（Realtime）将主库产生的Redo日志通过MAL系统传递到备库，实时归档是实时主备和MPP主备的实现基础。实时归档只在主库生效，一个主库可以配置1~8个实时备库。
实时归档的执行流程是，主库在Redo日志（RLOG_PKG）写入联机日志文件前，将Redo日志发送到备库，备库收到Redo日志（RLOG_PKG）后标记为KEEP_PKG，将原KEEP_PKG加入日志重演任务系统，并马上响应主库，不需要等待Redo日志重演结束后再响应主库。
主库收到备库的响应消息，确认备库已经收到Redo日志后，再将Redo日志写入联机日志文件中。
实时主备 实时主备系统由主库、实时备库、守护进程和监视器组成。通过部署实时主备系统，可以及时检测并处理各种硬件故障、数据库实例异常，确保持续提供数据库服务。
实时主备系统主要功能包括：
1.实时数据同步主备库通过实时归档完成数据同步，实时归档要求主库将RLOG_PKG发送到备库后，再将RLOG_PKG写入本地联机Redo日志文件。但要注意的是，备库确认收到主库发送的Redo日志，并不保证备库已经完成重演这些Redo日志，因此主备库之间的数据同步存在一定的时间差。
2.主备库切换主备库正常运行过程中，可以通过监视器的Switchover命令，一键完成主备库角色转换。主备库切换功能可以确保在软、硬件升级，或系统维护时，提供不间断的数据库服务。
3.自动故障处理备库故障，不影响主库正常提供数据库服务，守护进程自动通知主库修改实时归档为Invalid状态，将实时备库失效。
4.自动数据同步备库故障恢复后，守护进程自动通知主库发送归档Redo日志，重新进行主备库数据同步。并在历史数据同步后，修改主库的实时归档状态为Valid，恢复实时备库功能。备库接管后，原主库故障恢复，守护进程自动修改原主库的模式为Standby，并重新作为备库加入主备系统。
5.备库接管
主库发生故障后，可以通过监视器的Takeover命令，将备库切换为主库，继续对外提供服务。如果配置为自动切换模式，确认监视器可以自动检测主库故障，并通知备库接管，这个过程不需要人工干预。
6.备库强制接管如果执行Takeover命令不成功，但主库可能由于硬件损坏等原因无法马上恢复，为了及时恢复数据库服务，DM提供了TakeoverForce命令，强制将备库切换为主库。但需要由用户确认主库故障前，主库与接管备库的数据是一致的（主库到备库的归档是Valid状态），避免引发守护进程组分裂。
7.读写分离访问在备库查询的实时性要求不高的条件下，实时主备也可以配置接口的读写分离属性访问，实现读写分离功能特性。
与DM数据守护相关的配置文件包括：
数据库配置文件dm.ini数据库控制文件dm.ctlMAL配置文件dmmal.iniRedo日志归档配置文件dmarch.ini守护进程配置文件dmwatcher.ini监视器配置文件dmmonitor.ini定时器配置文件dmtimer.iniMPP控制文件dmmpp.ctl dm.ctl不需要用户修改，只要放在指定的目录即可。
各配置文件的存放路径：
1.dm.ini存放目录没有限制，一般直接放在数据库目录中。
2.dmmal.ini、dmarch.ini、dmtimer.ini存放目录由dm.ini的CONFIG_PATH配置项指定
3.dmwatcher.ini存放目录没有限制，一般和dm.ini存放在同一个目录。
4.dmmonitor.ini存放目录没有限制，一般和dm.ini存放在同一个目录。
5.dm.ctl存放目录由dm.ini的CTL_PATH配置项指定。
6.dmmpp.ctl存放目录由dm.ini的SYSTEM_PATH配置项指定。
端口配置关系说明 对上述ini文件中的各个端口之间的对应关系说明如下。
dm.ini dm.ini中端口相关的有两个配置项：PORT_NUM、DW_PORT。PORT_NUM是数据库实例的监听端口，监听用户的连接请求，dmmal.ini中的[MAL_INST_NAME:MAL_INST_PORT]要与dm.ini中的[INSTANCE_NAME:PORT_NUM]保持一致。 DW_PORT是守护系统中数据库监听守护进程连接请求的端口，由守护进程主动建立到数据库的TCP连接，这个端口只用于数据库和守护进程之间的消息交互使用。DM8版本支持DMDSC数据守护后，该参数转移到dmmal.ini的MAL_INST_DW_PORT，dm.ini中无需设置。
dmmal.ini dmmal.ini中每个实例都有一个单独的mal配置项，每个实例中有以下几个端口相关的配置：MAL_PORT、MAL_INST_PORT、MAL_DW_PORT、MAL_INST_DW_PORT。 MAL_PORTMAL监听端口，用于创建MAL链路，同一个实例的MAL配置项中，MAL_PORT不能和实例dm.ini中的两个端口相同，避免端口绑定冲突。MAL_INST_PORT MAL配置项中，MAL_INST_NAME实例的监听端口，和实例dm.ini的PORT_NUM值相同。
MAL_DW_PORT守护进程监听端口，其他守护进程或监视器使用MAL_HOST+MAL_DW_PORT创建TCP连接。监视器配置文件dmmonitor.ini中，MON_DW_IP就是一组MAL_HOST:MAL_DW_PORT。
MAL_INST_DW_PORT实例对守护进程的监听端口，守护进程使用MAL_HOST+MAL_INST_DW_PORT创建到实例的TCP连接。
3.dmwatcher.ini守护进程启动时，需要获取远程实例对应的配置项信息，创建到远程守护进程的TCP连接，这些信息通过INST_INI配置项来获取。守护进程从INST_INI路径找到并读取dm.ini、dmmal.ini、dmarch.ini，综合各个配置项得到远程守护进程的IP、端口等信息并建立连接。
4.dmmonitor.ini监视器配置项中以守护进程组为单位，通过MON_DW_IP配置到每组的所有守护进程的IP和端口信息。配置格式为：“守护进程IP地址:守护进程TCP端口”。其中守护进程IP地址和dmmal.ini中的MAL_HOST保持一致，守护进程TCP端口和dmmal.ini中的MAL_DW_PORT保持一致。dmmal.ini中配置有多少个IP和PORT，dmmonitor.ini就需要配置多少个对应124的“IP:PORT”信息，否则会无法接收到消息。
配置DM数据守护，一般要求配置连接服务名，以实现故障自动重连。连接服务名可以在DM提供的JDBC、DPI等接口中使用，连接数据库时指定连接服务名，接口会随机选择一个IP进行连接，如果连接不成功或者服务器状态不正确，则顺序获取下一个IP进行连接，直至连接成功或者遍历了所有IP。可以通过编辑dm_svc.conf文件配置连接服务名。dm_svc.conf配置文件在DM安装时生成，Windows平台下位于%SystemRoot%\system32目录，Linux平台下位于/etc目录。
连接服务名格式：SERVERNAME=(IP[:PORT],IP[:PORT],......)
例如，配置一个名为dw_svc的连接服务名，使用dw_svc连接数据守护中的数据库，即可实现故障自动重连。dw_svc=(192.168.1.131:5236,192.168.1.132:5236)
LOGIN_MODE=(1)
SWITCH_TIME=(3)
SWITCH_INTERVAL=(1000)
dm_svc.conf的详细设置，请参考《DM8系统管理员手册》
主备库切换 主库维护，滚动升级等场景，可以执行Switchover命令，实现主备库切换。如果存在多个备库，需要先执行ChooseSwitchover命令，选出守护进程组中可以切换的备库。
ChooseSwitchover命令选择可切换备库的条件如下：
1.主库守护进程是Open状态
2.备库守护进程是Open状态
3.主、备库的OPEN记录项内容相同，并且守护进程控制文件是Valid有效状态（内存值）
4.主库正常运行
5.备库正常运行
6.主库处于Open状态
7.备库处于Open状态
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a561080ce1c099ba44ab30be2e3050f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/149c3ecd62552d7b0aa79e43a1ba49c1/" rel="bookmark">
			Nordic nRF52840实战学习--蓝牙广播数据包抓包解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.上图为真实抓到的一个蓝牙广播数据帧，裸数据为： d6 be 89 8e 60 18 d5 73 b5 5c 6b e7 02 01 06 0e 09 45 6d 70 74 79 20 45 78 61 6d 70 6c 65 7a cb 87
按照上面的格式解析裸数据得到以下内容：
– Preamble:aa– Access Address:d6 be 89 8e //0x8e89bed6– PDU:60 18 d5 73 b5 5c 6b e7 02 01 06 0e 09 45 6d 70 74 79 20 45 78 61 6d 70 6c 65– CRC:7a cb 87 //0x5ed3e1 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/149c3ecd62552d7b0aa79e43a1ba49c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a527363870a1045935ade07e697c12a1/" rel="bookmark">
			echarts实现省市区县三级下钻，并且附带中国地图数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		百度echarts在大数据图表开发，图表数据展示中越来越受欢迎！实现柱状图，地图，航线图，电影排行榜等!下面就来一篇echarts实现省市区县三级下钻，并且附带源码，请看下图的案例:
w3c教程中echarts实现省市区县地图下钻 点击上图中的城市，例如：延安市，就会下钻到延安市对应的区县：
w3c教程中echarts实现省市区县地图下钻标题 返回省级地图按钮，就会回到省市页面
部分代码如下：
&lt;body&gt;
&lt;div class='main' style='width:700px;height:580px;margin:10px auto;'&gt;
&lt;div id='p' style='width:700px;height:580px;padding:10px;background:#F6F8F7;'&gt;
&lt;!--下属单位完成项目概况--&gt;
&lt;div class='proj fl pro_map' style='position: relative;'&gt;
&lt;div class='proj_top'&gt;
&lt;p&gt;地图总览&lt;/p&gt;
&lt;/div&gt;
&lt;div class='retPro'&gt;
&lt;a href='javascript:void(0);' οnclick='goBackProeMap()'&gt;
返回省级地图
&lt;/a&gt;
&lt;/div&gt;
&lt;div id='cont_pro_map' style='width:580px;height:440px;float:left;position: absolute;left:10px;top:50px;z-index:1;'&gt;&lt;/div&gt;
&lt;div id='cont_city_map' style='width:580px;height:440px;float:left;display: none;position: absolute;left:10px;top:50px;z-index:99;'&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;script&gt;
$().ready(function(){
/*echarts*/
$.get('https://www.w3cschool.net/js/echarts/china/json/shanxi/shanxi.json', function (mapJson) {
echarts.registerMap('shan_xi', mapJson);
var chart = echarts.init(document.getElementById('cont_pro_map'));//在id为mainMap的dom元素中显示地图
chart.setOption({
tooltip: {
trigger: 'item',
formatter: function loadData(result){//回调函数，参数params具体格式参加官方API
//鼠标放到某个地市上，显示这个地市的名称加人口数
//例如 params.name：当前地市名称。params.value：你传入的json数据与当前地市匹配的一项。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a527363870a1045935ade07e697c12a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd4978cbf917b75e76ab6e53f79943d6/" rel="bookmark">
			Windows CPU 分组问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当Windows的CPU核数超过64以后， Windows会自动分组。以下是我在Windows 2016系统测试到的行为:
1.在多CPU分组环境下，一个进程默认只能在一个CPU分组里运行。至于分配到哪个分组，由系统决定，不固定分配。
2.一个进程只能绑定一个CPU分组， 线程则没有限制。意味着通过控制，可以让一个进程使用到多个CPU分组的资源。
3.进程设置CPU分组，取决于第一个线程所绑定的CPU分组， 如果要设置进程到某个CPU分组，则需要改变第一个线程的CPU分组，再设置进程affinitity。
4.当设置过线程group与进程group不同组以后， 任务管理器查看进程相关性就会不可用。
5.当设置过进程affinitity，而又设置了线程在同一个分组的进程affinitity以外的核心， 则之前设置的进程affinitity就会失效。
SetThreadAffinityMask, SetProcessAffinityMask, SetThreadGroupAffinity的对比
SetThreadAffinitityMask是设置线程的相关性，SetProcessAffinitity则是设置进程的相关性。 以上两个函数都无法改变CPU分组。只有SetThreadGroupAffinitity可以改变CPU分组。在多CPU分组的系统上，设置线程的分组以及相关性，可以同时允许一个进程里的不同线程分配到不同的CPU里运行，提供更灵活的控制。
以上函数的affinitity_mask参数类型是指针，意味着在32位程序，affinitity_mask参数是32位，也就是说最多只能控制使用前面32个核。64位程序affinitity_mask参数是64位的，可以设置到任意一个核，因为CPU分组的核数不会超过64。在32位程序有个硬伤，就是无法控制线程或者进程使用32核以后的核。
有一个技巧，可以让32位程序的进程相关性设置能用到32位以后的核，那就是写一个专门设置进程相关性的64位程序B， 监听某个端口，32位程序通过socket把自己的进程pid以及需要设置的64位相关性发送给B程序，由B程序帮它设置，因为其他进程可以通过进程pid获得进程句柄来调用SetProcessAffinitity函数。但是同样的方法，对线程就无能为力，因为我找不到， 进程能获得另外一个进程里的线程句柄的有效方法，把句柄值直接传过去？觉得挺危险的，后面的就没试了，改成64位是趋势。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a77c198141a26ba582e8f5be260a9dc/" rel="bookmark">
			01-0004关于C/C&#43;&#43;中的转义字符(•́へ•́╬)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C/C++中的转义字符 1.问题描述2.问题分析3.相关实现3.1 使用原始字符串3.2 从控制台读入3.3 转化为双反斜杠3.3.1 通过查找&amp;插入实现3.3.2 自己写函数实现 4.相关链接 1.问题描述 1. 转义字符’‘转化为’\‘或者’/’？
2. 如何将反斜杠转化为正斜杠或者双斜杠？
3. 怎么让编译器不解释转义字符？
4. 如何检测字符是否发生转义？
5. C语言中怎么检测字符是否转义成功？
6. C语言中怎么判断一个字符是转义字符？
7. C语言中有没有原始字符串的用法？
8. Convert to Raw String Literal？
9. Print raw string from variable? C++？
10. Print raw string from variable? (not getting the answers)
11. Replace backward slashes with forwards slashes or double backward slashes in C++
12. C语言中怎么把"C:\name\a.txt"转化为"C:\name\a.txt"或者"C:/name/a.txt"
13. C print raw bytes？
14. Print raw string from variable?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a77c198141a26ba582e8f5be260a9dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80bec7f6854d8baf0ddc7685390b8ff5/" rel="bookmark">
			anaconda下安装tensorflow过慢，导致安装失败
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：电脑重新安装tensorflow，由于国内清华等一些镜像网站已经不能访问，必须在默认的下载地址进行下载，速度很慢，经常断掉下载不下来。
解决：
要安装tensorflow，首先要建立一个python3的虚拟环境，按照开始的建立方法，下载太慢，一直没有下载下来。
参照了这篇文章：
https://blog.csdn.net/qq_44639795/article/details/100693178
通过一下命令：conda create --name myTensorEnv python=3.5 anaconda
PS：python最好不要用3.7，现在有各种问题；
myTensofEnv是环境名字，可以自己设置。
最后结果：
环境配置完成后，通过：
conda activate myTensorEnv 进入tensorflow环境；
参考这篇：
https://www.cnblogs.com/jtzhang163/p/11299962.html
通过下面命令：
python -m pip install tensorflow -ihttp://pypi.douban.com/simple --trusted-host pypi.douban.com
上面是通过豆瓣的镜像进行的安装，默认安装的是2.1版本。
安装了tensorflow 2.1版本。
后面又尝试了中国科技大学的镜像，都没有豆瓣的快。
国内镜像：
阿里云
http://mirrors.aliyun.com/pypi/simple/
中国科技大学
https://pypi.mirrors.ustc.edu.cn/simple/
豆瓣(douban)
http://pypi.douban.com/simple/（我觉得挺快）
清华大学
https://pypi.tuna.tsinghua.edu.cn/simple/（已经停更了）
中国科学技术大学
http://pypi.mirrors.ustc.edu.cn/simple/
参考文章：
https://www.cnblogs.com/jtzhang163/p/11299962.html
https://blog.csdn.net/qq_44639795/article/details/100693178
https://blog.csdn.net/qq_37374643/article/details/90597365
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07f752e57cb00768e3a539fa55cd3c61/" rel="bookmark">
			Linux下搭建iSCSI共享存储的方法 Linux-IO Target 方式CentOS7-1810下实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		iSCSI（internet SCSI）技术由IBM公司研究开发，是一个供硬件设备使用的、可以在IP协议的上层运行的SCSI指令集，这种指令集合可以实现在IP网络上运行SCSI协议，使其能够在诸如高速千兆以太网上进行路由选择。iSCSI技术是一种新储存技术，该技术是将现有SCSI接口与以太网络(Ethernet)技术结合，使服务器可与使用IP网络的储存装置互相交换资料。
iSCSI分为服务端和客户端，服务端需要安装scsi target用来共享存储设备，客户端需要安装iscsi initiator用来连接target端，将target端共享的设备挂载到initiator本地，可以对其进行分区，格式化等操作
一、iSCSI实现数据的访问需要的条件：
1、iSCSI客户端具有的特性：
iSCSI initiator是发起I/O操作的启动者；需要通过发现过程请求远端快设备；可以与target进行持久连接；在Linux系统中可以使用iscsi-initiator-utils软件包来模拟实现；
2、iSCSI服务器端具有的特性：
iSCSI target是I/O操作的执行者；需要导出一个或多个块设备供启动者（initiator）使用；在Linux系统中可以使用两种target工具，分别为tgt，和targetcli，这里先介绍TGT的方法，TGT是Fujita Tomonori于2006年底将SCSI Target Framework (STGT/TGT) 引入Linux内核。它在内核中有一个库，可协助内核控制目标驱动程序，TGT是用户态实现的iscsi target，所有目标处理都在用户空间进行。在2010年底，LIO(Linux-IO)项目被选择来代替TGT作为内核态实现的iscsi target。当选择LIO替换TGT时，它的实现已经进行了调整，以允许TGT用户空态模块继续运行，因此TGT社区支持在内核中包含LIO。在Linux内核 2.6.38 之前都是TGT。
3、iSCSI 命名规则
iSCSI 使用全球唯一的名称标识 iSCSI 设备（目标或启动器）。此名称类似于与光纤通道设备相关联的全球名称 (WWN)，可作为一种通用的设备识别方式使用。
iSCSI 名称有两种不同格式。第一种是通过iSCSI限定名以 iqn.开头通常称为“IQN 名称”。第二种是通过企业唯一标识符，以eui.开头也称为“EUI 名称”，此方法不常用。
有关 iSCSI 命名要求和字符串配置文件的更多详细信息，请参见 IETF 网站上的 RFC 3721 和 RFC 3722。
iSCSI 限定名
iSCSI 限定名采用 iqn.yyyy-mm.naming-authority:unique name 的形式，其中：
yyyy-mm ：
表示“年份-月份“，是公司成立的年份和月份，这里的公司一般为安装软件的这个公司，当然了可以随意选个时间
naming-authority ：
通常是公司的 Internet 域名的逆转格式。例如，pipci 公司的 iSCSI 限定名形式可能是 iqn.2018-01.cc.pipci.iscsi。此名称表示 pipci.cc域名于 2018 年 1 月注册，iscsi 是pipci.cc的子域，子域名可有可无。
unique name：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07f752e57cb00768e3a539fa55cd3c61/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f451c034c724855b09a8037bfccba9f/" rel="bookmark">
			Docker——1.起源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Docker 是一种运行于 Linux 和 Windows 上的软件，用于创建、管理和编排容器。Docker 是在 GitHub 上开发的 Moby 开源项目的一部分。Docker 公司，位于旧金山，是整个 Moby 开源项目的维护者。Docker 公司还提供包含支持服务的商业版本的 Docker。Docker 公司位于旧金山，由法裔美籍开发者和企业家 Solumon Hykes 创立。
Docker 公司起初是一家名为 dotCloud 的平台即服务（Platform-as-a-Service, PaaS）提供商。底层技术上，dotCloud 平台利用了 Linux 容器技术。为了方便创建和管理这些容器，dotCloud 开发了一套内部工具，之后被命名为“Docker”。Docker就这样诞生了。
2013年，dotCloud 的 PaaS 业务并不景气，公司需要寻求新的突破。于是他们聘请了 Ben Golub 作为新的 CEO，将公司重命名为“Docker”，放弃dotCloud PaaS 平台，怀揣着“将 Docker 和容器技术推向全世界”的使命，开启了一段新的征程。如今 Docker 公司被普遍认为是一家创新型科技公司，据说其市场价值约为 10 亿美元。Docker 公司已经通过多轮融资，吸纳了来自硅谷的几家风投公司的累计超过 2.4 亿美元的投资。
“Docker”一词来自英国口语，意为码头工人（Dock Worker），即从船上装卸货物的人。
1. Docker 运行时与编排引擎 多数技术人员在谈到 Docker 时，主要是指 Docker 引擎。Docker 引擎是用于运行和编排容器的基础设施工具。可以将其类比为 ESXi。ESXi 是运行虚拟机的核心管理程序，而 Docker 引擎是运行容器的核心容器运行时。其他 Docker 公司或第三方的产品都是围绕 Docker 引擎进行开发和集成的。
2. Docker版本 Docker 引擎主要有两个版本：企业版（EE）和社区版（CE）。每个季度，企业版和社区版都会发布一个稳定版本。社区版本会提供 4 个月的支持，而企业版本会提供 12 个月的支持。社区版还会通过 Edge 方式发布月度版。从 2017 年第一季度开始，Docker 版本号遵循 YY.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f451c034c724855b09a8037bfccba9f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f6f84118560d47632cf9b4066712e38/" rel="bookmark">
			TPS、QPS、吞吐量，如何计算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.TPS TPS (transaction per second)代表每秒执行的事务数量，可基于测试周期内完成的事务数量计算得出。
TPS=事务数/时间（秒）
例如：
用户每分钟执行6个事务，TPS为6 / 60s = 0.10 TPS。
同时我们会知道事务的响应时间(或节拍)：60秒完成6个事务，代表每个事务的响应时间或节拍为10秒。
2.QPS QPS（Queries-per-second） 每秒查询率
=req/sec=请求数/秒 =总请求数 / ( 进程总数 * 请求时间 ) 单个进程每秒请求服务器的成功次数
日PV=QPS*60*60*24 //即QPS乘以一天的秒数
服务器数量 = ceil( 每天总PV / 单台服务器每天总PV )
峰值QPS=(日PV*80%)/(60*60*24*20%）//通用公式每天80%的访问集中在20%的时间里，这20%时间叫做峰值时间
服务器数=峰值时间每秒QPS / 单台机器的QPS
例如：
问：每天300w PV 的在单台机器上，这台机器需要多少QPS？
答：( 3000000 * 0.8 ) / (86400 * 0.2 ) = 139 (QPS)
问：如果一台机器的QPS是58，需要几台机器来支持？
答：139 / 58 = 3
3.TPS与QPS有何区别 事务：客户端发起请求到收到服务端最终响应的整个过程，这是一个TPS
而在这个TPS中，为了处理第一次请求可能会引发后续多次对服务端的访问才能完成这次工作，每次访问都算一个QPS。
所以，一个TPS可能包含多个QPS
4.吞吐量
单位时间内客户端和服务器成功传递数据的数量
吞吐量的计算公式：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f6f84118560d47632cf9b4066712e38/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45463ed1f2ed72dcbc4db457980b4319/" rel="bookmark">
			【技术分享】机器学习在量化交易方向的应用—基于神经网络的多因子选股策略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文原作者：甘泉，经授权后发布。
一、多因子选股背景 量化交易策略无非三点：择时、选股、仓控。择时为短期套利交易策略，选股为中长期交易策略，目标是在中长期跑赢指数、获取市场超额收益率alpha。多因子选股的关键是找到寻找因子与股票收益率之间的相关性，即对收益率预测能力强的因子。一般多采用如下步骤：
而传统的多因子模型在构建大类因子特征时往往依赖于投资者的主观判断和逻辑推理。机器学习等量化模型，依据某种机制，构建出一个具有自适应和自动学习特征的模型，被广泛应用于多因子模型的构建。相较于SVM、Logistic Regression等机器学习分类器，深度学习可以通过构建具有很多隐层的机器学习模型和海量的训练数据，来学习到更有用的因子特征。因而“深度模型”只是手段，我们的最终目标是利用深度神经网络进行多因子的“特征学习”，从而最终提升分类或预测的准确性。
二、模型特征——股票多因子 我们选股基于的股票池为中证500的成份股票。根据这些公司的财务指标和股票价格表现等数据，构建了盈利、技术、成长、估值、规模五大类因子特征作为模型输入：
盈利因子技术因子BPSCloseAdj/OneMonthMaxCloseAdjDividend Yield1 Month returnDividend Yield Last Year1 Month RSIEPS1 Month ADRSales/Enterprise Value1 Month Amount AverageFCFF/Enterprise Value3 Month returnReturn on P/B1 year daily SkewnessReturn on P/E1 Month Turn Over AverageROE3 MonthTurn Over AverageROICilliquidity
规模因子估值因子成长因子Market Free SharesAcca_Operating Finance InvestmentNet Profit GrowthMarket Total CapitalAsset Impairment Loss To Gross RevenueOperation Profit GrowthMarket log Total CapitalCash From Sales/Operating RevenueOperation Income GrowthCFO/NOIRevenue GrowthP/BROE GrowthP/EChange Of Net Profit GrowthNet Profit Growth
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/45463ed1f2ed72dcbc4db457980b4319/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f441c67af9e9e8b32802b4eabdf93370/" rel="bookmark">
			Unity功能 销毁超出边界的物体
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、添加空物体作为边界
2、给边界添加碰撞
添加 碰撞盒 并设置碰撞盒的大小
添加 刚体 并设置模式为静态（只和动态刚体发生碰撞）
3、添加鱼的碰撞器 和 刚体
给碰撞器勾选触发器
设置刚体的模式为动态（动态刚体可以和任何刚体发生碰撞包括碰撞盒），并将重力缩放设置为0（这样就不受重力的影响了）
4、边界添加tag
5、移除鱼的代码
using UnityEngine; //鱼的属性 public class FishAttr : MonoBehaviour { public int maxNum;//最大的数量 public int maxSpeed;//最大的速度 private void OnTriggerEnter2D(Collider2D collision) { //如果鱼移动出边界则移除掉 if(collision.tag == "Border") { Destroy(gameObject); } } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/429a02e8d87613154fc0e0c715ffb5aa/" rel="bookmark">
			android Room: Pre-packaged database has an invalid schema:
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先说下我出现错误的场景。我需要将sql文件里的数据导入到sqlite数据库。看了下现在推荐使用的数据库框架是Room就是用了这个库来做。先用将sql文件中的数据导入到了sqlite，然后使用Room来查询数据，发现报了这个错。。。
解决问题参考了下边的这个回复：
StackOverflow链接
解决问题的方法是先执行一次Room的查询语句（虽然没有数据）。这样Room会创建好表结构，再执行导入的方法导入数据，最后执行Room查找语句就没问题了。
具体的原因并没有去探究，可能是Room需要一个表结构外其他的配置。如果先使用了别的方法创建好了表，那这个配置并没有存在，然后使用Room查询的时候没有这个结构就会报错。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9534ac4c989b380d5571a380f5fb88ed/" rel="bookmark">
			feign接口返回泛型设置属性为null问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 feign是一种声明式http请求调用方式，工作原理就是根据FeignClient注解生成新的接口（也就是传说中的动态代理），常见使用方式如下所示：
@FeignClient(name="UserFeignService",url="${auth.url}", fallbackFactory = OrgFeignServiceFallback.class, configuration = FeignErrorDecoderConfiguration.class) public interface OrgFeignService { /** * * @param org * @return */ @PostMapping(value="Tenant/AddTenantOrg", consumes="application/json; charset=UTF-8") APIResultTO&lt;TenantOrg&gt; addOrg(OrgDto org, @RequestHeader("token")String token); } 应用场景 1、序列化以及反序列化采用jackson
2、调用第三方采用feign注解式接口
问题分析 APIResultTO是一个api通用接口返回泛型类，TenantOrg为传入的具体泛型类，咱们来看下出问题的类：
@Getter @Setter @NoArgsConstructor public class TenantOrg { /** */ @JsonProperty("Id") private String Id; /** * 父级Id */ @JsonProperty("PId") private String PId; /** * 租户代码 */ @JsonProperty("Tenant") private String tenant; /** * 组织架构名字 */ @JsonProperty("Name") private String name; } 必须要用@JsonProperty("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9534ac4c989b380d5571a380f5fb88ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e31577c57ce2f2c91d3e244f175774a/" rel="bookmark">
			音乐自动播放代码,移动端
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 html
&lt;audio style="display:none;" id="music" src="944393a40df4901f.mp3" controls="controls" loop="loop" autoplay="autoplay"&gt; &lt;source src="song.ogg" type="audio/ogg" /&gt; &lt;source src="song.mp3" type="audio/mpeg" /&gt; Your browser does not support the audio element. &lt;/audio&gt; js
&lt;script&gt; var audio = document.getElementById('music'); function audioAutoPlay(audio) { document.addEventListener("WeixinJSBridgeReady", function () { audio.play(); }, false); document.addEventListener('YixinJSBridgeReady', function () { audio.play(); }, false); } audioAutoPlay(audio); &lt;/script&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ea36b8c0f39c853ebbd701562e05d96/" rel="bookmark">
			CVE-2020-0796漏洞复现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CVE-2020-0796 简介
微软3月11日发布3月例行更新，其中并未公布编号为CVE-2020-0796的高危漏洞资料，但该漏洞却最为引人注目。次日晚（2020年3月12日）微软正式发布CVE-2020-0796高危漏洞补丁。
该漏洞的后果十分接近永恒之蓝系列，都利用Windows SMB漏洞远程攻击获取系统最高权限，WannaCry勒索蠕虫就是利用永恒之蓝系列漏洞攻击工具制造的大灾难。除了直接攻击SMB服务端造成RCE外，该漏洞得亮点在于对SMB客户端的攻击，攻击者可以构造特定的网页，压缩包，共享目录，OFFICE文档等多种方式触发漏洞进行攻击。
漏洞影响
漏洞不影响win7，漏洞影响Windows 10 1903之后的各个32位、64位版Windows，包括家用版、专业版、企业版、教育版。
Windows 10 Version 1903 for 32-bit Systems
Windows 10 Version 1903 for x64-based Systems
Windows 10 Version 1903 for ARM64-based Systems
Windows Server, Version 1903 (Server Core installation)
Windows 10 Version 1909 for 32-bit Systems
Windows 10 Version 1909 for x64-based Systems
Windows 10 Version 1909 for ARM64-based Systems
Windows Server, Version 1909 (Server Core installation)
前期准备
win10一台（win10 1903或者win10 1909系列）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ea36b8c0f39c853ebbd701562e05d96/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb734fdaac04c30862383442fbbd32a8/" rel="bookmark">
			blinker点灯开关组件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一. 简介二. 组件简绍三. 代码部分 一. 简介 前面我们说了，用于通过blinker来实现点亮开发板上面的小灯，但是用的开关组件只是按一下打开灯或者再按一下熄灭灯，从app上看不清到底是开灯的还是关灯着，所以这次说一下，按键后反馈组件的状态
二. 组件简绍 在编辑模式下，点击按键进入编辑组件页面，可以看到 按键类型 有三种：普通按键、开关按键、自定义按键
普通按键
每次按下发送的指令为
{"btn-abc":"tap"} 开关按键
按键本身会保存开关状态，默认为off，按下时会发送
{"btn-abc":"on"} 保存的状态为on时，按下会发送
{"btn-abc":"off"} 设备端可以发送指令改变当前按键的开关状态
三. 代码部分 define BLINKER_WIFI #include &lt;Blinker.h&gt; char auth[] = "Your Device Secret Key"; char ssid[] = "Your WiFi network SSID or name"; char pswd[] = "Your WiFi network WPA password or WEP key"; // 新建组件对象 BlinkerButton Button1("btn-abc"); // 按下按键即会执行该函数 void button1_callback(const String &amp; state) { BLINKER_LOG("get button state: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb734fdaac04c30862383442fbbd32a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3deb0c8522b7ea3b1ac320b380b6b26/" rel="bookmark">
			爬取微博视频页并批量下载python&#43;requests&#43;ffmpeg(连接视频和音频)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		爬取微博视频页并批量下载 可用于任何一个微博用户的视频页中所有视频的下载
这里批量下载的视频量加多，故使用了多线程下载(少量视频的话看心情用不用线程下载)
注：并不是使用多线程就一定会快很多，这里的线程下载还取决于你的网速和你的cpu
所需工具： python3. ffmpeg开源程序 （FFmpeg是一套可以用来记录、转换数字音频、视频，并能将其转化为流的开源计算机程序。因为爬取到的是分为视频和音频两个url，所以需要ffmpeg程序将视频文件和音频文件进行拼接，然后输出一个完整的视频） 原理： 这里的方法可用于任何一个微博用户
我们随便打开一个用户的视频页
F12打开开发者工具，然后刷新一下网页，观察network中的XHR(全称为XMLHttpRequest，用于与服务器交互数据，是ajax功能实现所依赖的对象)数据栏变化
如下图
上图中的红框处的地址https://weibo.com/aj/video/getdashinfo?ajwvr=6&amp;media_ids=1034:4473434474741805,1034:4467940196548627,1034:4463329079656474,1034:4462483658965012,1034:4459902320705548,1034:4432446993926032&amp;__rnd=1584936506079，经过分析发现就是有含视频数据信息的交互url，我们后面就是用该地址进行爬取
我们使用直接复制到浏览器打开会发现，该url所返回的数据就是一大串json数据，我们全选复制，使用在线json解析器进行数据分析，嫌麻烦的同学可以直接在preview预览视图里查看数据，如下图
在data目录下的list中就是包含所有视频信息的地方
逐一打开可以看到，该处包含了0-5一共六个视频(数量按网页动态加载而定)
我们尝试打开其中一个视频目录下的details里面含有0，1，2，3四个不一样的数据
经过分析，其中0，1，2三个分别为不同清晰度的视频数据，而3为音频数据
那现在就好办了
我们展开视频数据下的playerinfo
里面的数据包含了视频的编码格式，视频url地址，时长，宽高比，清晰度等等，待会只需要取出视频url进行下载即可
为了防止出错，我们可以打开其中一个右键视频url直接转到相应网页，对照网页上的视频是否与微博上的视频画面一致
如下图，测试正常
微博上的视频
如果我们尝试往下滑，或者跳转到视频页的第二页，就发现，之前分析的只不过是其中一组视频的信息而已，新的url又出来了，我们可以ctrl+f查找url前缀为‘https://weibo.com/aj/video/getdashinfo’的链接，如下图，不过好像我们这位小姐姐的所发布的视频并不多，只有一页
代码 所需库
import time import requests import os #用于获取当前目录指定下载存放目录 from sys import argv #用于获取当前目录指定下载存放目录 from json import loads import re #用于获取当前目录指定下载存放目录 import subprocess import threading 如不需要程序自动获取当前目录作为下载存放目录的，可不导入os，sys，json库，这里仅仅作为该作用(吃瓜 )
主要代码 def GetResourceUrl(self): print('开始获取网页数据') self.headers = { 'User-Agent': '放入自己浏览器的user-agent', 'Cookie': '放入自己浏览器的cookie' } f = open(root+'\\url.txt', "r") # 设置文件对象 string = f.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e3deb0c8522b7ea3b1ac320b380b6b26/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5789ed9f9dd7ab6aca87238c55a78043/" rel="bookmark">
			C&#43;&#43;线程交叉打印1-100
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		哈哈哈，睡醒了突然觉得昨晚的太简单了，又想起了一道题，交叉打印1-100，虽然难度也还是只提升了一丢丢。但是，复习一下也算嘛。
#include &lt;iostream&gt; #include &lt;condition_variable&gt; #include &lt;mutex&gt; #include &lt;thread&gt; using namespace std; mutex data_mutex; condition_variable flag_cond; bool flag = true; void printji() { int i = 1; while (i &lt;= 100) { //this_thread::sleep_for(chrono::seconds(1)); unique_lock&lt;mutex&gt; lck(data_mutex); flag_cond.wait(lck, [] {return flag; }); cout &lt;&lt; "A " &lt;&lt; i &lt;&lt; endl; i += 2; flag = false; flag_cond.notify_one(); } } void printou() { int i = 2; while (i &lt;= 100) { unique_lock&lt;mutex&gt; lck(data_mutex); flag_cond.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5789ed9f9dd7ab6aca87238c55a78043/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fcddabf5779314b7de4d4f42299f45f5/" rel="bookmark">
			高精度运算（大数运算）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 摘要大数加法大数减法大数乘法高精度乘以低精度 大数除法高精度除以低精度 大数阶乘 摘要 高精度运算是指参与运算的数远大于标准数据类型的数，动辄成百上千位的数。所以高精度数又被称为大数。
本文主要讲解：大数加法，大数减法，大数乘法，大数除法，大数阶乘。
java的大数类做这一类题很方便，效率高代码短，但是学会高精度算法还是很有必要的。
另外注意，不是数大的题就是高精度题，要注意审题，比如裸快速幂的题，虽然数很大，但是跟高精度不沾边。
蓝桥杯基础算法和常用API集合：https://blog.csdn.net/GD_ONE/article/details/104061907
大数加法 例题：
基础练习 高精度加法
先给出大数类的写法：
import java.util.*; import java.io.*; import java.math.*; public class Main{ static BufferedReader in = new BufferedReader(new InputStreamReader(System.in)); static BufferedWriter out = new BufferedWriter(new OutputStreamWriter(System.out)); public static void main(String[] agrs) throws IOException{ String s = in.readLine(); BigInteger a = new BigInteger(s); String s1 = in.readLine(); BigInteger b = new BigInteger(s1); a = a.add(b); out.write(a.toString()); out.flush(); } } 数组模拟:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fcddabf5779314b7de4d4f42299f45f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5d5714c638cd4a95173a78a2716dbaf/" rel="bookmark">
			[机器学习笔记] 混淆矩阵（Confusion Matrix）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		混淆矩阵（Confusion Matrix） 在机器学习领域，混淆矩阵（Confusion Matrix），又称为可能性矩阵或错误矩阵。混淆矩阵是可视化工具，特别用于监督学习，在无监督学习一般叫做匹配矩阵。在图像精度评价中，主要用于比较分类结果和实际测得值，可以把分类结果的精度显示在一个混淆矩阵里面。
混淆矩阵的结构一般如下图表示的方法。
混淆矩阵要表达的含义：
混淆矩阵的每一列代表了预测类别，每一列的总数表示预测为该类别的数据的数目；每一行代表了数据的真实归属类别，每一行的数据总数表示该类别的数据实例的数目；每一列中的数值表示真实数据被预测为该类的数目。 True Positive（TP）：真正类。样本的真实类别是正类，并且模型识别的结果也是正类。
False Negative（FN）：假负类。样本的真实类别是正类，但是模型将其识别为负类。
False Positive（FP）：假正类。样本的真实类别是负类，但是模型将其识别为正类。
True Negative（TN）：真负类。样本的真实类别是负类，并且模型将其识别为负类。 该矩阵可用于易于理解的二类分类问题，但通过向混淆矩阵添加更多行和列，可轻松应用于具有3个或更多类值的问题。
举例 如有150个样本数据，预测为类I，类II，类III 各为50个。分类结束后得到的混淆矩阵为：
每一行之和表示该类别的真实样本数量，每一列之和表示被预测为该类别的样本数量。
第一行第一列中的43表示有43个实际归属第一类的实例被预测为第一类，同理，第一行第二列的2表示有2个实际归属为第一类的实例被错误预测为第二类。
混淆矩阵是对分类问题的预测结果的总结。使用计数值汇总正确和不正确预测的数量，并按每个类进行细分，这是混淆矩阵的关键所在。混淆矩阵显示了分类模型的在进行预测时会对哪一部分产生混淆。它不仅可以让您了解分类模型所犯的错误，更重要的是可以了解哪些错误类型正在发生。正是这种对结果的分解克服了仅使用分类准确率所带来的局限性。
从混淆矩阵得到分类指标 从混淆矩阵当中，可以得到更高级的分类指标：Accuracy（精确率），Precision（正确率或者准确率），Recall（召回率），Specificity（特异性），Sensitivity（灵敏度）。
计算方法 对于二分类问题，可以将样例根据其真实类别与机器学习器预测类别的组合划分为：
样例总数 = TP + FP + TN + FN。
则可以计算指标：
精确率（Accuracy）：精确率是最常用的分类性能指标。可以用来表示模型的精度，即模型识别正确的个数/样本的总个数。一般情况下，模型的精度越高，说明模型的效果越好。
Accuracy = (TP+TN)/(TP+FN+FP+TN)
正确率或者准确率（Precision）：又称为查准率，表示在模型识别为正类的样本中，真正为正类的样本所占的比例。一般情况下，查准率越高，说明模型的效果越好。
Precision = TP/(TP+FP)
召回率（Recall）：又称为查全率，召回率表现出在实际正样本中，分类器能预测出多少。
Recall（召回率） = Sensitivity（敏感指标，True Positive Rate，TPR）= 查全率
表示的是，模型正确识别出为正类的样本的数量占总的正类样本数量的比值。一般情况下，Recall越高，说明有更多的正类样本被模型预测正确，模型的效果越好。
Recall = TP/(TP+FN)
查准率和查全率是一对矛盾的指标。一般来说，查准率高时，查全率旺旺偏低；二查全率高时，查准率往往偏低。
精确率（Accuracy）和正确率（Precision）的区别
Accuracy，不管是哪个类别，只要预测正确，其数量都放在分子上，而分母是全部数据量，说明这个精确率是对全部数据的判断。
而正确率在分类中对应的是某个类别，分子是预测该类别正确的数量，分母是预测为该类别的全部的数量。
或者说，Accuracy是对分类器整体上的精确率的评价，而Precision是分类器预测为某一个类别的精确的评价。
Specificity（特异性）：特异性指标，表示的是模型识别为负类的样本的数量，占总的负类样本数量的比值。
负正类率（False Positive Rate, FPR），计算公式为：FPR=FP/(TN+FP)，计算的是模型错识别为正类的负类样本占所有负类样本的比例，一般越低越好。
Specificity = 1 - FPR Fβ_Score：Fβ的物理意义就是将正确率和召回率的一种加权平均，在合并的过程中，召回率的权重是正确率的β倍。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5d5714c638cd4a95173a78a2716dbaf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/753ae69cb5e1b4a357101a8750460844/" rel="bookmark">
			Android 手动设置屏幕方向后不能自动转屏问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如题，Android在手动设置屏幕方向后不能使用自动转屏了，这是因为手动设置屏幕方向
如：
setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE); 相当于在Manifest文件中Activity节点下配置了：
android:screenOrientation="landscape" 这会导致该Activity方向锁定，不能自动转屏。But，手动转屏是可以的，所以我们只需要加上方向改变监听，然后手动转屏，也就达到了自动转屏的目的：
class OrientationEventListenerImpl extends OrientationEventListener { public OrientationEventListenerImpl(Context context) { super(context); } @Override public void onOrientationChanged(int rotation) { Log.i("旋转角度：","rotation = "+rotation); //以下代码可以根据具体需求去配置 // 设置为竖屏 if (((rotation &gt;= 0) &amp;&amp; (rotation &lt;= 45)) || (rotation &gt;= 315)) { setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT); } // 设置为横屏 if(((rotation &gt;= 225) &amp;&amp; (rotation &lt;= 315))) { setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE); } //设置为横屏（逆向） if(((rotation &gt;= 45) &amp;&amp; (rotation &lt;= 135))) { setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_REVERSE_LANDSCAPE); } } } 然后再注册该监听器，比如在Activity的onCreate()方法中注册：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/753ae69cb5e1b4a357101a8750460844/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1ad0a10c40c54807cb2c28663099ec7/" rel="bookmark">
			STM32之ADC多路采样开发踩过的坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近开发基于PH、ORP数据采集项目，两路PH，两路ORP所以用到了STM32ADC多路采样，
不足之处望指正。
一、存在问题
1、采样数据不准确，几路数据相同。
2、通道间数据互相影响，不准确等。
二、开发过程
非DMA模式
最开始只是在单通道非DMA模式下增加多路通道，结果AD采样数据显示都一样，经过各种修改未发现问题。
DMA模式
在思绪百般无果下，想了下会不会是多路采样导致CPU负担过重，于是想起了DMA（个人理解DMA就是一个中转站，起到存数据，取数据的过程，这个存取过程不需要CPU直接参与，采样数据过大、过多时利用DMA收集数据，再处理，减轻了CPU负担），资源查询过程中又发现了一个问题，在非DMA模式下，多路ADC采集的数据储存位置是相同的，出现了数据覆盖，所以才会有互相影响，数据相同的奇怪现象。然而，开启ADC多通道DMA模式后采集数据还是存在互相干扰，最后查询资料得到的结论是，未连接的端口处于浮空状态，会受干扰，最后将每个采样口接通，恢复正常。
三、下面分享一下源码以及细节部分吧
1、ADC采样GPIO端口配置，这里配置六个PA端口
void ADC1_GPIO_Config(void) { GPIO_InitTypeDef GPIO_InitStructure; RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1| GPIO_Pin_2|GPIO_Pin_3|GPIO_Pin_4|GPIO_Pin_5|GPIO_Pin_6; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;	GPIO_Init(GPIOA, &amp;GPIO_InitStructure); GPIO_ResetBits(GPIOA,GPIO_Pin_0 | GPIO_Pin_1| GPIO_Pin_2|GPIO_Pin_3|GPIO_Pin_4|GPIO_Pin_5|GPIO_Pin_6); } 2、ADC和DMA一起配置
void ADC1_Mode_Config(void) { ADC_InitTypeDef ADC_InitStructure; DMA_InitTypeDef DMA_InitStructure; RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE); DMA_DeInit(DMA1_Channel1); DMA_InitStructure.DMA_PeripheralBaseAddr = ADC1_DR_Address; DMA_InitStructure.DMA_MemoryBaseAddr = (u32)ADCDAT; DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC; DMA_InitStructure.DMA_BufferSize = 6;	DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable; DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable; DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord; DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord; DMA_InitStructure.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e1ad0a10c40c54807cb2c28663099ec7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b7bebf5857edc74b860bc2cfec95991/" rel="bookmark">
			It looks like you are making an HTTP request to a Hadoop IPC port. This is not the correct port for
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		完整的错误：It looks like you are making an HTTP request to a Hadoop IPC port. This is not the correct port for the web interface on this daemon. 先说下版本：
今天在运行hadoop时，在浏览器上输入http://localhost:9000/，显示以下问题
经过思考以及搜索问题原因，发现是单节点的hadoop的问题，正确为http://localhost:8088/cluster
具体见下面说明：
管理界面：http://localhost:8088
NameNode界面：http://localhost:50070
HDFS NameNode界面：http://localhost:8042
博主强烈推荐：https://blog.csdn.net/persistencegoing/article/details/84376427
希望大家关注我一波,防止以后迷路,有需要的可以加群讨论互相学习java ,学习路线探讨,经验分享与java求职 群号:721 515 304
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/651870230f7724de64c3ad71030d0a33/" rel="bookmark">
			VMware Workstation 与 Device/Credential Guard 不兼容。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		昨天机子上搞了下docker，导致vm 启动centOS 出问题。
访问http://www.vmware.com/go/turnoff_CG_DG。 全英文看不懂（我英语都过不了3A）
出现问题的原因： 原因一、出现此问题的原因是Device Guard或Credential Guard与Workstation不兼容。
原因二、Windows系统的Hyper-V不兼容导致。
解决方案： 第一步：
“win+ R“打开运行，输入gpedit.msc，确定打开本地组策略编辑器
转到本地计算机策略 &gt; 计算机配置 &gt; 管理模板&gt;系统 &gt; Device Guard
打开 基于虚拟化的安全设置为“已禁用”
第二步：
“win+ R“打开运行，输入services.msc，确定打开本地服务 &gt; 找到HV主机服务 &gt; 启动类型设置为“禁用”
第三步：
“ 控制面板” &gt;“ 卸载程序” &gt;“ 打开或关闭Windows功能”以关闭Hyper-V，选择不重启
第四步：
通过命令关闭Hyper-V（控制面板关闭Hyper-V起不到决定性作用）
“win+ x”,然后运行以管理员身份运行Windows Powershell (管理员)
也可以选择“cmd” 以管理员身份运行
bcdedit /set hypervisorlaunchtype off 第五步：
重启电脑
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ae5a136316b6bd69899cf7021a2786f/" rel="bookmark">
			记：Debian 7.X的apt-get出现“E:无法定位软件包”以及更换源出现由于“没有公钥，无法验证下列签名： NO_PUBKEY 3B4FE6ACC0B21F32”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		更换源 cd /etc/apt/
先备份源：sudo cp sources.list sources.list.bak
再更换：sudo vi sources.list
阿里云的：
deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted
universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main
restricted universe multiverse
再
sudo apt update
出现
root@root:/etc/apt# sudo apt update
获取:1 http://mirrors.aliyun.com/ubuntu bionic InRelease [242 kB]
获取:2 http://mirrors.aliyun.com/ubuntu bionic-security InRelease [88.7 kB]
错误:1 http://mirrors.aliyun.com/ubuntu bionic InRelease
由于没有公钥，无法验证下列签名： NO_PUBKEY 3B4FE6ACC0B21F32
错误:2 http://mirrors.aliyun.com/ubuntu bionic-security InRelease
由于没有公钥，无法验证下列签名： NO_PUBKEY 3B4FE6ACC0B21F32
正在读取软件包列表… 完成
W: GPG 错误：http://mirrors.aliyun.com/ubuntu bionic InRelease: 由于没有公钥，无法验证下列签名： NO_PUBKEY 3B4FE6ACC0B21F32
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ae5a136316b6bd69899cf7021a2786f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7088130f2fe6b9a0b975611c33d1f8c0/" rel="bookmark">
			win7系统证书错误问题，证书无效，不受信任的网站问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		windows没有足够信息，不能验证该证书 windows 7 证书无效 Google Chrome 您的链接不是私密连接 等证书相关问题解决办法 1.调整系统时间。这种错误大概率是系统时间错误。
方法是点击右下角时间
然后“更改时间和日期设置”之后可以手动设置正确时间或者和互联网时间同步。
如果和互联网时间同步则必须联网
2.是我最近遇到的问题
新装的win7系统，无论是旗舰版还是专业版，某些网站总是提示证书错误或者不受信任。
包括京东 jd.com 苏宁易购等
网上说的重新下载证书或者拷贝证书，都不太管用。没有从根本上解决问题。
根本原因是win7自带的IE8很多网站已经不支持，证书不再支持
所以某些网站可以，某些网站不行。
第一种方法是：升级到IE11以上 如果找不到升级办法可以尝试第二种
第二种方法是下载根证书，链接如下
https://www.wosign.com/download/winroot.htm
WoSign 提醒您更新您的Windows 根证书，请检查发行者签名为Microsoft Corporation，点击“安装”或“是”自动完成!
如果您的电脑已经设置Microsoft为信任的发行者，则不会出现需要您确认的页面而自动完成更新！
该网址的主体网站是沃通SSL证书验证网站。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a7a64994945b2ada95f3ba9a084076c/" rel="bookmark">
			基于BERT的多模学习——VL-BERT篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 BERT的出现让NLP发展实现了一个大飞跃，甚至有大佬说NLP已经没有可以做的啦，后面就是拼机器拼money了。但是，我认为任何领域的进步之后都会有更苛刻的要求，科研没有尽头，需求也永远无法满足。而多模态，要求机器拥有多维度的感知能力，就是一个更强的挑战。 关于这个话题也逐渐成为另外一个新热点。从19年到现在的论文数量就可见一斑。
所以，为了迎上发展的势头，在继videoBERT之后又调研了一番image和BERT结合的工作。下文将介绍MSRA出品的VL-BERT，通过这个模型来一览现阶段 image+BERT 的研究现状吧。
后台回复【VL-BERT】下载论文原文~~
模型介绍 VL-BERT模型以transformer为骨干，将BERT的输入扩展为文本+图像。那么问题来了，怎样将两者花式融合呢？让我们揣测一下作者的炼丹思路：
图片和文本没法直接对齐，暴力输入整张图
于是就有了图中用红色虚线框起来的部分，直接将图像、文本、segment和position embeding加和输入。这样做MLM任务是没问题了，但怎样确定模型能准确提取图像信息呢？
提取图像中的重要部分，增加无文本的图像输入
由于整张图片的粒度远大于文本token，一次性输入整张图片显然不利于图像和文本信息的交互。所以使用了目标检测工具对图片进行分块，提取图像中感兴趣的核心部分RoI（region-of-interest），加上[IMG]标识，输入到模型中（图中浅绿色实线框起来的部分）。 为了不失掉全局信息，在[END]对应的位置又加上了整张图像。另外，我们假设图片的不同区域是没有顺序可言的，即position embedding是一样的。
类比文本输入，模型实际上接受的是文本token（subword）对应的word embedding，所以我们会对所有图像输入（不管是整张图片还是局部RoIs）使用pre-trained R-CNN提取2048维的visual feature embedding输入到模型中。
自监督学习任务（pretrain） 结合上文介绍的模型结构，再强调一下两个预训练任务：
Masked Language Model with visual Clues
根据文本+图像信息预测文本token，升级版的MLM。 唯一不同的是被mask的word除了根据没被mask的文本来预测还可以根据视觉的信息来辅助。比如上图中的例子，被mask后的word sequence是kitten drinking from [MASK]，如果没有图片给我们的视觉信息是无法预测出被mask的词是bottle。
Masked RoI Classification with LinguisticClues
根据文本+图像信息预测RoIs的类别，针对图像的“MLM”。 以下图为例，首先对图片使用目标检测工具提取RoIs并获得所属类别，然后随机mask局部区域（树叶部分）。需要注意的是，由于模型会接收整张图片的输入，为了避免信息泄露，整张图片对应的部分也要mask。最后，模型根据文本信息和被mask的图片信息预测mask区域所属类别。
下游任务（finetune） 模型通过接收&lt;text, image&gt;输入，通过自监督任务学习到general跨模态表示后，可以很自然的应用很多跨模态的任务中。延续原始BERT的设定，[CLS]最后输出的feature可以预测文本和图片的关系（sentence-image-relation），被mask的text token或者RoI的输出用来做word-level或者RoI-level的预测。
下面来看看不同的下游任务是怎么实现的叭~
视觉常识推理(VCR)
给定一张图片中的多个RoIs和问题（Q），需要选出答案（A）并解释为什么（R）。VCR任务超越目标检测（object detection），是需要结合认知层面的复杂推理任务。下图展示了数据中的两个例子[1]，确实很难很复杂????。
整体任务{Q-&gt;AR}可以拆解成两个子任务 {Q-&gt;A}（根据问题Q预测答案A） 和 {QA-&gt;R}（根据QA推理原因R）。而这两个子任务都是选择题，模型只需要从候选答案中挑选认为最正确的选项就好。如下图文本输入由两部分组成Question（已知信息）和Answer（候选答案），图像输入为人工标注的RoIs。针对{Q-&gt;A}任务，已知的文本信息为问题Q的文本描述。对{QA-&gt;R}任务，已知的文本信息为问题Q加上一个任务预测的答案A。两个任务都根据最后一层[CLS]的输出预测该候选答案（A/R）是否正确。
有一个不合理的地方是，正常人的思维模式是先有一个靠谱的理论依据R得出正确答案A。但是上面模型的逻辑是先有正确答案，再去找合理的原因。因果颠倒。
最终结果，不管是对比task-specific模型R2C还是其他多模态模型，VL-BERT都有非常明显的优势的。
视觉问答 (VQA)
文章follow了一个专门针对VQA任务设计的模型BUTD实验设定，把VQA任务转化为一个有3k+候选答案的多分类问题，根据被masked Answer token最后一层的输出预测。
相比special design的网络结构（BUTD），VL-BERT在准确率上提升了5%，和其他多模态pretrain model效果相当。
Referenceing Expression Comprehension（visual grounding）
这个任务呢，是根据一句自然语言的描述，定位图片中的具体区域，即判断这句描述讲的是图片的哪个位置。 因为我们已经对图片划分出了RoIs，所以只需要将每个RoIs最后的输出，接一个Regin classification（二分类），判断Query是否是描述这个区域即可。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a7a64994945b2ada95f3ba9a084076c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b730b149d7d74e02b141cbba583647c/" rel="bookmark">
			计算机网络（7~8）课后题答案（全）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1-6课后题答案链接 https://blog.csdn.net/weixin_39332529/article/details/104740274
https://blog.csdn.net/weixin_39332529/article/details/104854566
前言： 答案仅限参考，不保证全部正确
第七章 1.简述CSMA/CA基本工作原理-253
是IEEE802.11网络采用的访问控制方法
名词解释：
CSMA/CA：带碰撞避免
ＣＳＭＡ／CD：检测
RTS：请求数据帧
CTS：可以通信确认信息，他还要发送给附近所有的通信主机
2.移动网络的间接路由选择的基本工作原理是什么？247
直接路由选择：由通信代理通过归属代理获得转交地址，直接发送到外部代理
间接路由选择：由归属代理转发数据给外部代理。使用隧道技术
3.为什么在无限局域网中不使用CSMA/CD 协议而使用CSMA/CA协议？
CSMA/CA：带碰撞避免
ＣＳＭＡ／CD：检测
CSMA/CD协议的特点是：先听再发，边听边发，冲突停发，随机重发；
CSMA/CA协议的特点是：发送数据时先广播告知其他结点，让其他结点在某段时间内不要发送数据，以免发生碰撞；
4.随着移动节点离开基站越来越远，为了保证传送的帧的丢失概率不增加，基站可以采取的两种策略是什么？
5.如果某主机通过无线网络连接因特网，那么该主机必须是移动的吗？-242
假设一个使用便携计算机的用户带着计算机在室内散步，并且总是通过相同的接入点接入因特网，那么，从网络的角度看，该用户是移动的吗？为什么？-245
不必须是移动的。
6.永久地址与转交地址之间有什么区别？谁为移动主机指派转交地址？
1）永久地址：移动结点在从一个网络移动到另一个网络时保持其地址不变。
转交地址：被访网络生成的。
2）外部代理指派的。
7.IEEE 802.11无线局域网中信标帧协议的主要作用是什么？-252
帮助无线主机发现AP。
8.为什么IEEE 802.11的MAC协议CSMA/CA使用确认帧，而以太网的MAC协议CSMA/CD却不使用？-253
9.假设IEEE 802.11的RTS帧和CTS帧与标准的DATA帧和ACK一样长，使用RTS帧和CTS帧会有好处吗？为什么？
10.考虑IEEE 802.11的移动性，其中一个无线站点从一个BSS移动到同一个子网中的另一个BSS。当AP是通过交换机互联时，为了让交换机能正确转发帧，试想AP可以怎么做？
11.蓝牙中的主设备和IEEE 802.11网络中的基站之间有什么区别？
蓝牙中的主设备真正控制皮可网，即它的时钟确定了皮可网中的时间，可以再每个奇数时隙中发送数据；当主设备在前一时隙与其通信后从设备才可以发送数据，并且只能发送给主设备。
IEEE 802.11网络中的基站：
12.简单比较IEEE 802.11a/b/g/n四个标准的优劣。250
13.目前国际上确定的3G标准有哪4种？
CDMA和TDMA
欧洲和日本：宽带码分多址
美国：CDM2000
中国：TD-SCDMA
14.为什么CSMA/CA协议可以消除隐藏站问题？如何消除？253
在CSMA/CA中有一个站点和服务器建立信道连接之后，服务器会把允许连接的帧发送给所有其他不能连接的站点，这样就只有一个站点在这个时刻可以发送数据。
其他站不会在发送请求连接的请求，造成不必要的冲突。
15.简述IEEE 802.11中无线主机与AP的关联过程。
AP发现：
主动与被动是相对于主机来说
主动扫描-探测帧
使用主动扫描主机耗电量就很大
被动扫描-信标帧
AP发送信标帧通告它的存在，主机接收AP发送的信标帧知道周围有那些AP，之后进行连接
16.试举例说明IEEE 802.11帧中地址字段的取值与意义。254
17.简述移动IP的代理发现与注册过程。 262
2）注册过程
①移动结点向外部代理发送一个移动IP注册报文；
②外部代理记录移动结点的永久IP地址，并发送注册请求给归属代理；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b730b149d7d74e02b141cbba583647c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2183d384972cc3ef7a274b1ba79e83a5/" rel="bookmark">
			从插入排序一窥时间复杂度的计算方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为什么需要分析时间复杂度 通常在运行一段代码之前，我们需要预测其需要的资源。虽然有时我们主要关心像内存、网络带宽或者计算机硬件这类资源，但是通常我们想度量的是计算时间。
接下来我们以插入排序算法为切入点一窥时间复杂度的计算方法。
时间复杂度分析 一般来说，算法需要的时间于输入的规模同步增长，所以通常把一个程序的运行时间描述成其输入规模的函数。为此，我们必须先给出术语运行时间和输入规模。
输入规模通常依赖于研究的问题。比如，对于排序问题来说，最自然的量度是需要排序元素的数量。又比如对于最短路算法而言，其输入是一个图，则输入规模可以用该图中的顶点数及边数来描述。
一个算法在特定输入上的运行时间是指执行的基本操作数或步数。首先我们假设执行一行代码需要常量时间。常量时间是指：无论输入规模如何变化，执行这一行代码的时间都不受输入规模的影响。我们记第 i 行代码的执行时间为 C i C_i Ci​。
在用插入排序举例之前，我们先看下该算法的基本思想：每步将一个待排序的元素，按其值的大小插入前面已经排序的序列中适当位置上，直到全部元素插入完为止。以升序排序为例，具体代码如下：
template&lt;typename Array&gt; void InsertionSort(Array &amp;data) { for(size_t i = 1, n = data.size(); i &lt; n; i++) { // 1 auto key = data[i]; // 2 auto j = i-1; // 3 while(j &gt;= 0 &amp;&amp; data[j] &gt; key) { // 4 data[j+1] = data[j]; // 5 j--; // 6 } data[j+1] = key; // 7 } } 我们设上述代码的 for 循环中七行代码的执行时间分别为：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2183d384972cc3ef7a274b1ba79e83a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3d179a352580b2c369e23e644ab8d97/" rel="bookmark">
			在Unity3D和OpenCV之间传递图片（Texture2D/WebCamTexture转Mat）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面的话：记录Unity调用opencv里的坑。这是趟了无数的坑之后，写下的满纸的辛酸泪。各种奇怪的错误、闪退折磨了N久之后终于得到的一个好的方法用来在Unity和OpenCV之间传递图片。PS:作为一个长期使用C#的程序猿，弄C++实在是太痛苦了,如果代码有什么不合理的地方也希望各位大佬指正批评。
1. 关于DLL 注意，本文不使用OpenCVforUnity!
关于C#调用C++的DLL，可以参考这里：Unity调用动态链接库dll和so.
写的很详细，非常值得参考。需要注意的是，函数一定要按照链接的方式去写，不然可能会找不到函数入口（这是坑之一）。
2.Texture2D=&gt;Mat 首先，我们一般得到的贴图都是一个Texture，那么怎么转成Texture2D呢？可以使用以下方法：
Texture2D TextureToTexture2D(Texture texture) { Texture2D texture2D = new Texture2D(texture.width, texture.height, TextureFormat.RGBA32, false); RenderTexture currentRT = RenderTexture.active; RenderTexture renderTexture = RenderTexture.GetTemporary(texture.width, texture.height, 32); Graphics.Blit(texture, renderTexture); RenderTexture.active = renderTexture; texture2D.ReadPixels(new Rect(0, 0, renderTexture.width, renderTexture.height), 0, 0); texture2D.Apply(); RenderTexture.active = currentRT; RenderTexture.ReleaseTemporary(renderTexture); return texture2D; } 有了这个Texture2D之后，我们需要获取保存图像的指针。代码如下：
pixels = texture2D.GetPixels32(); GCHandle pixelHandle = GCHandle.Alloc(pixels, GCHandleType.Pinned); IntPtr pixelPointer = pixelHandle.AddrOfPinnedObject(); 关于GCHandle可以参考这里：GCHandle。
这里的pixels是一个Color32[]。
以上的代码需要：
using System; using System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3d179a352580b2c369e23e644ab8d97/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9438737c556a80ceaa650c90ac10a615/" rel="bookmark">
			Python爬取猪八戒网站
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		爬取猪八戒网站，方便你接单；
1.下面是猪八戒为托管的单的链接
url="https://task.zbj.com/?s=2&amp;so=2&amp;ss=0" #为托管的连接 url_2="https://task.zbj.com/page2.html?s=2&amp;so=2&amp;ss=0" #第二页的连接 2.第一步想网页发送get请求，解析网页的结构。
获取需求的所有的网页标签。
demands=select.xpath('//*[@id="utopia_widget_7"]/div[@class="demand-list"]//div[@class="demand-card"]') print("总计有%d条发布信息."%len(demands)) 3.根据路径写获取信息的方法，不过有太多的换行，再改正一下。
4.加上了这个之后去除换行，
# -*- coding: utf-8 -*- # @Time : 2020/3/22 15:47 # @Author : 结尾！！ # @FileName: spider_task_zbj.py # @Software: PyCharm import requests #使用xpath from scrapy.selector import Selector header={ 'User-Agent':'Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36' } def parse_zbj(html_url): resp=requests.get(html_url,headers=header) resp.encoding="utf-8" print("网页返回的状态码：",resp.status_code) select=Selector(resp) demands=select.xpath('//*[@id="utopia_widget_7"]/div[@class="demand-list"]//div[@class="demand-card"]') print("总计有%d条发布信息."%len(demands)) for div in demands: release_time=div.xpath('./div[@class="demand-card-head"]/span[1]/text()').extract_first().strip() #发布时间 attend_num=div.xpath('./div[@class="demand-card-head"]/span[2]/text()').extract_first().strip() #参与人数 title=div.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9438737c556a80ceaa650c90ac10a615/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2e4fc335d7e76594050494cdfaabcbe/" rel="bookmark">
			计算机网络---三层ISP结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 计算机网络三层ISP结构IXP网络交换机 计算机网络 是什么：
计算机网络是由若干个节点及连接这些节点的链路组成的，节点可以是计算机、路由器、交换机、集线器
三层ISP结构 ISP：互联网服务提供商，像中国电信、联通、移动，ISP可以从互联网管理机构申请到很多IP地址，然后一些机构和个人从某个ISP获取IP地址的使用权，并可通过该ISP连接到互联网。
三层ISP结构分为主干ISP，地区ISP，本地ISP。本地ISP给用户提供最直接的服务，本地ISP可以连接到地区ISP，也可以连接到主干ISP。从原理上讲。只要每一个本地ISP都安装了路由器连接到某个地区ISP，而每一个地区ISP也有路由器连接到主干ISP，那么在这些相互连接的ISP的共同作用下，就可以完成互联网中的所有的分组转发任务。
————————————————
原文链接：https://blog.csdn.net/ma2595162349/article/details/91402235
IXP 互联网交换点(IXP)：为了更快地转发分组，IXP允许两个网络直接连接并交换分组，而不需要通过第三个网络来转发分组。例如上图中，主机A和主机B通过2个地区ISP连接起来了，就不必经过最上层的的主干ISP来转发分组。典型的IXP由一个或多个网络交换机组成。
网络交换机 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b20da1d988ff3571727ea3549c723c54/" rel="bookmark">
			Python float输出指数形式和小数形式切换（即科学计数法和完整数值切换）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python float输出指数形式和小数形式切换（即科学计数法和完整数值切换） （本文数字全部瞎编，仅作举例之用，请勿相信。
另，本人Python初学者，写个文章作为笔记，也希望可以对他人有所帮助，如有错误或更好地实现方法欢迎各路朋友们指教）
如果float类型位数过多，输出时会自动变成指数形式，如下
import math m = 5.52 #密度 r = float(input('请输入地球直径(km)：')) V = 4*math.pi*r**3/3 W = m*V*1000**3 print('地球重量为',W,'吨') #运行结果 请输入地球直径(km)：1234 地球重量为 4.344833777941348e+19 吨 这样输出的数据很不好看，虽然是科学计数法，但小数点位数过多
可以通过格式化输出，实现完整的整数或漂亮的科学计数法
输出规定格式的科学计数法 有两种方法：
利用字符串格式化操作符 “%”利用字符串的format（）方法 import math m = 5.52 r = float(input('请输入地球直径(km)：')) V = 4*math.pi*r**3/3 W = m*V*1000**3 print('地球重量为%.2e吨'%W) #.2是规定了2位小数 print('地球重量为{:.2e}吨'.format(W)) 请输入地球直径(km)：1234 地球重量为4.34e+19吨 地球重量为4.34e+19吨 可以看到这两种方法的输出结果是一样的
输出完整的float值 实现方法是一样的，只不过把上文类型符的e改为f，代码如下
import math m = 5.52 r = float(input('请输入地球直径(km)：')) V = 4*math.pi*r**3/3 W = m*V*1000**3 print('地球重量为%.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b20da1d988ff3571727ea3549c723c54/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5709334e663f747c8b8eaad9e8140fd9/" rel="bookmark">
			在DW中插入背景图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		打开DW CS4，新建HTML，点击下方的 页面属性 后出现一个页面框，选择 背景图片 浏览 ，把你所需要的图片选中，点击 确定 。
**注意：**保存你当前的操作 ctrl+s 。
重复 是让你当前选中的背景图片在浏览器中重复出现或其他…
在这里插入图片描述
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e5844971be72539ab2e2c6a05f8b80b/" rel="bookmark">
			Filter过滤敏感词汇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		个人博客
过滤敏感词汇的实现，需要对 request 对象进行增强，增强获取参数的相关方法，然后替换敏感词汇为***。使用代理模式实现
过滤器的编写 @WebFilter("/*") public class SensitiveFilter implements Filter { public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException { //创建代理对象增强getparammeter方法 ServletRequest proxy_req = (ServletRequest) Proxy.newProxyInstance(req.getClass().getClassLoader(), req.getClass().getInterfaces(), new InvocationHandler() { @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { //是否是getParameter方法 if (method.getName().equals("getParameter")){ //增强返回值 String value = (String) method.invoke(req,args); if (value != null){ for (String str : list) { if (value.contains(str)){ value = value.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e5844971be72539ab2e2c6a05f8b80b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f1f43b6de3dcca6e57f133073928392/" rel="bookmark">
			C&#43;&#43;中对map按照value进行排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实现方法：如果想要对map中元素按照value进行排序，先把map的元素按pair形式插入到vector中，再对vecotr进行排序(用一个自定义的比较函数),这样就可以实现对map的value排序了。
以下代码实现了按照map中的value进行排序的功能，还给出了遍历map的几种方式，仅供参考哈，各位。
提示：对于map的key-value结构来说，如果key没有重载“&lt;”操作符，是无法插入成功的。因此，对于自定义类型的key，必须实现"&lt;"操作符重载
#define _CRT_SECURE_NO_WARNINGS #include&lt;iostream&gt; #include&lt;cstdlib&gt; #include&lt;vector&gt; #include&lt;algorithm&gt; #include&lt;map&gt; using namespace std; typedef struct my_map_key { int v1; int v2; // 基于v2的大小进行比较 bool operator&lt;(my_map_key const&amp; t) const { if (this-&gt;v2 &gt; t.v2) { return true; } return false;	} }TEST; // 自定义map打印函数：使用for_each遍历打印 inline void Display(map&lt;my_map_key, int&gt;::value_type &amp; v) { cout &lt;&lt; v.second &lt;&lt; endl; } // 按照value进行比较 typedef pair&lt;my_map_key, int&gt; PAIR; bool cmp_by_value(const PAIR&amp; v1, const PAIR &amp; v2) { return v1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f1f43b6de3dcca6e57f133073928392/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51a3a686296700eb1418a8b79a25a01a/" rel="bookmark">
			（转）解决pycharm问题：module &#39;pip&#39; has no attribute &#39;main&#39; 问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在pycharm中安装文件时，突然报module 'pip' has no attribute 'main' 错误，查了资料并实践了一下，需如下方式才解决。
首先找到安装目录下 helpers/packaging_tool.py文件，找到如下代码段：
def do_install(pkgs):
try:
import pip
except ImportError:
error_no_pip()
return pip.main(['install'] + pkgs)
def do_uninstall(pkgs):
try:
import pip
except ImportError:
error_no_pip()
return pip.main(['uninstall', '-y'] + pkgs)
将其修改为如下的代码段并保存：
def do_install(pkgs):
try:
# import pip
try:
from pip._internal import main
except Exception:
from pip import main
except ImportError:
error_no_pip()
# return pip.main(['install'] + pkgs)
def do_uninstall(pkgs):
try:
# import pip
try:
from pip._internal import main
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/51a3a686296700eb1418a8b79a25a01a/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/442/">«</a>
	<span class="pagination__item pagination__item--current">443/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/444/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>