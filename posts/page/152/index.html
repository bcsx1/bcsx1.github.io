<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/129063fa795b2446d28c2949f85456c6/" rel="bookmark">
			更改镜像源的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		更改镜像源的方法 1、备份 /etc/apt/sources.list 文件,另起名为source.list.old
sudo cp /etc/apt/sources.list /etc/apt/sources.list.old 2 打开文件
sudo gedit /etc/apt/sources.list 将这个打开的文件里全部删掉，然后换成下面的新的源，不要害怕，你备份了的．
3　在你打开的sources.list 文件下（此时应该是空白的），将下面阿里源（有的人说清华源不全，我只是用的阿里源）的内容复制进去
deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse deb http://mirrors.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/129063fa795b2446d28c2949f85456c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ddabb8b310375d37a71c11cada045889/" rel="bookmark">
			简单的在OpenCV显示视频基础上使用Qt窗口显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用Qt创建好label控件后，在槽函数实现中把opencv处理程序搬过来，将最后的imshow窗口改成label控件的显示即可。
具体步骤
cv::cvtColor(frame, frame, cv::COLOR_BGR2RGB);//将opencv处理完的图像转为RGB格式
QImage srcImg = QImage((uchar*)(frame.data), frame.cols, frame.rows, QImage::Format_RGB888);//RGB图像转QImage
ui.label-&gt;setPixmap(QPixmap::fromImage(srcImg));//label控件显示图像
ui.label-&gt;resize(1280, 720);//设置控件大小
ui.label-&gt;show();
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6870b08ce5f571f0c69de3bd337b3226/" rel="bookmark">
			Vue中mixins(混入)的介绍和使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是Mixin？ 想要使用一个事物或者工具，我们首要先了解它是什么，这样我们才好对症下药。
其实Mixin不是Vue专属的，可以说它是一种思想，也可以说它就是混入的意思，在很多开发框架中都实现了Mixin(混入)，我们这里主要讲解的是Vue中的Mixin。
老规矩，先看 官方文档。
官方解释：
混入(mixin)提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。
官方的解释通常都是晦涩难懂的，因为要专业和准确嘛！
我们可以用我们自己容易理解的话来说说Vue中的Mixin是什么。
民间解释：
将组件的公共逻辑或者配置提取出来，哪个组件需要用到时，直接将提取的这部分混入到组件内部即可。这样既可以减少代码冗余度，也可以让后期维护起来更加容易。
这里需要注意的是：提取的是逻辑或配置，而不是HTML代码和CSS代码。其实大家也可以换一种想法，mixin就是组件中的组件，Vue组件化让我们的代码复用性更高，那么组件与组件之间还有重复部分，我们使用Mixin再抽离一遍。
Mixin和Vuex的区别？ 上面一点说Mixin就是一个抽离公共部分的作用。在Vue中，Vuex状态管理似乎也是做的这一件事，它也是将组件之间可能共享的数据抽离出来。两者看似一样，实则还是有细微的区别，区别如下：
Vuex公共状态管理，如果在一个组件中更改了Vuex中的某个数据，那么其它所有引用了Vuex中该数据的组件也会跟着变化。
Mixin中的数据和方法都是独立的，组件之间使用后是互相不影响的。
如何使用？ 我们了解了Mixin的概念，那么如何使用它呢？这才是我们的重点。
准备工作 接下来我们的mixin就放在Vue2.x的脚手架项目中演示。
利用Vue-cli初始化一个最简单的项目：
找到你要创建项目的文件夹 例如 这个 Vue 文件夹
输入cmd指令 弹出命令行
命令： vue create 项目名称
这里会弹出提示 创建的是Vue3还是Vue2的项目，这里我用到的是Vue2 看自身条件自行参考
正在安装Vue项目
在你创建的文件夹下就可以找到你的项目了
输入 npm run serve 启动项目
mixin定义 定义mixin也非常简单，它就是一个对象而已，只不过这个对象里面可以包含Vue组件中的一些常见配置，如data、methods、created等等。
在我们的项目src目录下新建mixin文件夹，然后新建index.js文件，该文件存放我们的mixin代码。
代码如下：
// src/mixin/index.js export const mixins = { data() { return {}; }, computed: {}, created() {}, mounted() {}, methods: {}, }; 可以看到我们的mixin非常的简单，主要包含了一个Vue组件的常见的逻辑结构。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6870b08ce5f571f0c69de3bd337b3226/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a86a05ca95557018a72952a39bbcf2e/" rel="bookmark">
			【安装Anaconda3 &#43; Tensorflow &#43; Keras &#43; Jupyter笔记本】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		软件下载： Anaconda3 2020.11(64-bit)版本下载：
链接：https://pan.baidu.com/s/19-lDaxnd4lOE6f6Q9Zzqgg
提取码：yuir
所有步骤开始前，如果是想使用tensorflow的gpu版本，那么要先确定CUDA、cudnn、tensorflow和python四者之间的版本对应：详细可见该笔者给出的版本对应关系：点击查看，不使用gpu版本可直接看下面的安装。
安装Anaconda3步骤： 1、将下载好的压缩包解压，右键以管理员身份运行后缀.exe应用程序；
2、点击Next；
3、点击I Agree；
4、点击Next；
5、选择安装路径，并点击Next；
6、把两个选项勾选上，并点击Next；
7、最后等待安装完成即可。
安装Tensorflow 1、在刚刚安装好的Anaconda中找到【Anaconda Prompt】并打开；
2、首先输入命令：【python -m pip install -U pip】更新一下pip；
如果是最新的pip可以不用更新的，如果不确定是不是最新的pip，就输入命令更新一下。
我这里已经是最新版本的pip了，如果不是最新的pip，更新后应该看到Successfully的字样，表示更新成功。
3、创建Tensorflow环境，同时安装python；
输入命令【conda create --name tensorflow1 python=3.6】
这里写的tensorflow1是tensorflow虚拟环境的名字，当然你也可以使用其它的名字。
输入上面命令后，大概需要等待半分钟，会弹出下面提示，输入命令【y】回车即可；
然后会下载一些文件，等待一会即可；
下载完成后会显示如下界面：
到这里我们就把Tensorflow环境安装好了，接下来需要激活Tensorflow环境：
4、激活tensorflow环境：
输入命令【activate tensorflow1】并回车；
5、继续输入命令【pip install tensorflow==1.15.0 -i https://pypi.tuna.tsinghua.edu.cn/simple/】，这里会下载很多文件，耐心等待一会，如果网络出现故障导致下载失败可以重复输入命令直到下载成功。
提示：如果想安装支持gpu的tensorflow的话，把上面tensorflow改成tensorflow-gpu即可，版本号等都不用改。
6、安装好之后我们继续输入命令查看一下tensorflow是否安装成功；
首先输入【python】，再输入【import tensorflow as tf】，没有报错基本上就是成功了。
注意：第五步和第六步是在tensorflow1的虚拟环境下输入命令的，而不是在base环境下。
使用gpu版本的同学，可以测试一下gpu是否可用，代码如下:
# 在上面的基础上继续输入下面代码： tf.test.is_gpu_available() tf.__version__ 返回True即为gpu版本可用，效果如下（注：下图是笔者再编辑，所用版本和前面不同，只要能正确返回True和版本信息即可）：
安装Keras： 1、重新打开Anaconda Prompt；
2、激活刚刚弄好的tensorflow1的虚拟环境，也就是输入命令【activate tensorflow1】
这样就进入了tensorflow1环境下；
3、输入命令【pip install keras==2.3.1 -i https://pypi.tuna.tsinghua.edu.cn/simple/】
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a86a05ca95557018a72952a39bbcf2e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c04c94e6c5547a00dd7c61fedd91493b/" rel="bookmark">
			人脸生成StyleGAN2——基于PaddleGAN源码分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GAN StyleGAN2论文
PaddleGAN代码仓库
安装过程 本次StyleGAN2的结构解读主要是基于paddleGAN（可以使用百度的算力，所以没有选pytorch），代码直接通过git clone 到本地 按照github上的readme安装相应的包即可。
结构分析 StyleGAN2主要可以分为映射网络，生成网络组成。下面主要分析生成器网络。
映射网络 映射网络（Mapping Network）是StyleGAN2中的一个重要组成部分，它将输入的潜在向量（Latent Vector）映射到一个更高维度的向量空间中，使得生成器能够更好地控制图像的各个方面。
映射网络主要由多个全连接层组成，这些层的作用是将输入的潜在向量映射到一个更高维度的向量空间中。StyleGAN2采用了多个映射网络，每个映射网络的深度和层数不同，以便生成器能够更好地控制不同层次的图像特征。
生成器结构 PaddleGAN关于styleGAN2的模型构建部分代码在：\PaddleGAN\ppgan\models\generators\generator_styleganv2.py
def forward( self, styles, return_latents=False, inject_index=None, truncation=1.0, truncation_cutoff=None, truncation_latent=None, input_is_latent=False, noise=None, randomize_noise=True, ): # 输入映射为w，默认为8层全连接层 if not input_is_latent: styles = [self.style(s) for s in styles] if truncation &lt; 1.0: # # 该操作使得latent code w在平均值附近，生图质量不会太糟 style_t = [] if truncation_latent is None: truncation_latent = self.get_mean_style() cutoff = truncation_cutoff for style in styles: if truncation_cutoff is None: style = truncation_latent + \ truncation * (style - truncation_latent) else: style[:, :cutoff] = truncation_latent[:, :cutoff] + \ truncation * (style[:, :cutoff] - truncation_latent[:, :cutoff]) style_t.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c04c94e6c5547a00dd7c61fedd91493b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd9bb87bc16925c0f65921b77170a06c/" rel="bookmark">
			常见的端口漏洞及常见网络安全设备默认口令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		互联网中的各种服务一般都对应一个默认端口，有的服务可直接匿名访问服务，而有些可通过爆破用户名以及密码来获得管理员权限。 端口对应的服务以及漏洞存在方式----常见的端口漏洞
21 FTP 匿名访问，弱口令 22 SSH 弱口令登录 23 Telnet 弱口令登录 80 Web 常见Web漏洞或后台登录弱口令 161 SNMP public弱口令 389 LDAP 匿名访问 443 openssl 心脏滴血等 445 smb 操作系统溢出漏洞 873 rsync 匿名访问，弱口令 1099 JAVArmi 命令执行 1433 MsSQL 弱口令 1521 Oracle 弱口令 2601 Zebra 默认密码zebra 3128 squid 匿名访问（可能内网漫游） 3306 MySQL 弱口令 3389 RDP 远程桌面弱口令 4440 Rundeck 弱口令admin 4848 GlassFish 弱口令admin/adminadmin 5432 PostGreSQL 弱口令爆破 6379 Redis 匿名访问 7001,7002 Weblogic 弱口令爆破 8080 Tomcat\Jboss 弱口令，Jboss匿名访问 8080-8090 常见Web端口 9043 WebSphere 弱口令爆破 27017 MongoDB 未授权访 常见网络安全设备默认口令
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd9bb87bc16925c0f65921b77170a06c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af3883e4d51957e344a21971bfff0000/" rel="bookmark">
			网络接口 2 ——调用搜狗翻译API
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		package com.mabang.test; import com.mabang.util.SslUtils; import javax.net.ssl.*; import java.io.ByteArrayOutputStream; import java.io.InputStream; import java.io.OutputStreamWriter; import java.net.URL; import java.net.URLConnection; import java.security.cert.CertificateException; import java.security.cert.X509Certificate; import java.time.Duration; import java.time.Instant; import java.util.List; import java.util.Map; /** * 测试调用搜狗翻译 */ public class TestSougou { public static void main(String[] args) { try{ //get获取搜狗翻译cookie String cookie = SSLUtils.getRequest("https://fanyi.sogou.com/ ", 30 * 1000); System.out.println("===================================================="); //获取当前时间 Instant nowTime = Instant.now(); //post调翻译 for (int i =0;i &lt;= 100;i++){ String body="打开"+i; String request = SSLUtils.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/af3883e4d51957e344a21971bfff0000/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66925784d39592a6638df09a0b2c48df/" rel="bookmark">
			Java线程池execute()和submit()方法的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java中的线程池可以使用execute()和submit()方法来提交任务，它们的主要区别如下：
方法签名不同： execute(Runnable command) 接受一个Runnable类型的参数，而 submit(Runnable task) 接受一个Runnable或者Callable类型的参数，因此 submit() 方法可以返回一个结果。异常处理方式不同：如果任务在执行过程中抛出异常， execute()方法不会显示抛出异常，而是将其捕获并记录，而 submit()方法则会将异常包装在Future对象中返回。返回值不同：execute()方法没有返回值，而submit()方法会返回一个Future对象，通过该对象可以获取任务执行的状态、结果等信息。阻塞行为不同：execute()方法一旦提交任务就立即返回，无法阻塞；而 submit()方法可以选择传递一个超时时间作为参数，如果在指定时间内任务没有完成，则取消任务并抛出异常。 总之，execute()更加简单直接，适用于不需要关心任务的返回值以及异常处理的情况，而submit()则更加灵活，适用于需要获取任务的执行状态、结果，并进行相应的处理的情况。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2438f715af3910107f286e0f7ec60409/" rel="bookmark">
			windows如何连接服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 windows连接服务器步骤 1. win + R 键 ，输入mstsc2. 点击确定，进入远程桌面，输入连接的服务器ip地址3. 输入正确的用户名、密码，即可进入服务器桌面 1. win + R 键 ，输入mstsc 2. 点击确定，进入远程桌面，输入连接的服务器ip地址 3. 输入正确的用户名、密码，即可进入服务器桌面 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19b5e8fe8dea3636d139e29177c515d6/" rel="bookmark">
			base64、File、Blob、ArrayBuffer几种文件格式介绍以及互转
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 关系介绍BlobFileFileReader二进制数组ArrayBuffer对象URL.createObjectURLbase64 转化file转base64blob转base64base64转blobbaes64转fileblob转fileblob转ArrayBufferfile转ArrayBuffer 关系 介绍 Blob 介绍
是一个不可变、原始数据的类文件对象本质上是js的对象 size：包含的数据大小（字节）type：包含的数据的MIME类型 里面存储的是二进制数据可以使用FileReader来读取blob中的内容 创建
// 语法 const blob = new Blob(array, options); // 示例 const blob = new Blob([JSON.stringify(debug, null, 2)], {type : 'application/json'}); const myBlob = new Blob([1,2,3],{type:'text/plain'}); console.log(myBlob);//Blob {size: 3, type: "text/plain"} console.log(myBlob.size);//3 console.log(myBlob.type);//'text/plain' File 介绍
File对象是特殊的Blob实例化有3个参数：new File(array, name, options)一般通过上传获取File对象 通过input type=file选择文件，返回fileList对象拖拽文件生成DataTransfer对象 创建
const file = new File([file], file.name, {type: file.type}); // input上传 &lt;input type="file" id="file"&gt; &lt;script&gt; let obj = document.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/19b5e8fe8dea3636d139e29177c515d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29f7b387c0390d87e2484432882f7975/" rel="bookmark">
			微信小程序利用tabs实现标签页demo
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 场景 根据商户信息状态字段的不同值，将其渲染到不同的标签页下。
准备数据 根据状态字段的值不同，将其放到两个数组中。
data: { key: '', active:0, storeData: [], arr1: [], arr2: [] }, onLoad: function () { var newArr1=this.data.arr1 var newArr2=this.data.arr2 var newData=app.globalData.storeData for (let i = 0; i &lt; newData.length; i++) { if (newData[i].status == '1') { newArr1.push(newData[i]) } else if (newData[i].status == '2') { newArr2.push(newData[i]) } } this.setData({ 'storeData': newData, 'arr1':newArr1, 'arr2':newArr2, }) }, 页面结构 根据active的值条件渲染van-tab中的内容
JS代码 页面中为van-tabs标签绑定事件，将切换标签时被选中标签的index值赋值给active。
onAnotherChange(event) { this.setData({ 'active':event.detail.index }) }, 页面效果 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/801f891d8393b04612f8935fe40fc501/" rel="bookmark">
			关于Echarts饼图循环series里data
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		此处为效果图 根据接口返回的数据进行循环
第一步：先将需要循环的series置空 循环你想要的数组(ps:此处我的数组为ytgsList)
var myChart4 = echarts.init(this.$refs.myChart4) var series=[] for (var i=0,len=this.ytgsList.length;i&lt;len;i++){ series.push({ value:this.ytgsList[i].situationCount, name:`${this.ytgsList[i].situationCount} ${this.ytgsList[i].situationName}` }) } 第二步：直接创建 此处color我使用的是渐变色 legend的设置是为了显示上面数据下面昵称的需求
title里是是在环形中央显示文字信息 series里的data直接用上面循环里做的就好了
var option = { tooltip: { trigger: 'item' }, legend:{ orient: 'horizontal',//纵向排列 align:'left', top:'20%', left:'70%', width:'130', itemWidth: 15, textStyle: { color: 'rgba(255,255,255,1)', width: 100, overflow: 'break', } }, color: [ { type: 'linear', x: 0, y: 0, x2: 0, y2: 1, colorStops: [{ offset: 0, color: 'rgba(205, 255, 32, 1)' // 0% 处的颜色 }, { offset: 1, color: 'rgba(1, 16, 23, 1)' // 100% 处的颜色 }], global: false // 缺省为 false }, { type: 'linear', x: 0, y: 0, x2: 0, y2: 1, colorStops: [{ offset: 0, color: 'rgba(1, 101, 254, 1)' // 0% 处的颜色 }, { offset: 1, color: 'rgba(1, 16, 23, 1)' // 100% 处的颜色 }], global: false // 缺省为 false }, { type: 'linear', x: 0, y: 0, x2: 0, y2: 1, colorStops: [{ offset: 0, color: 'rgba(255, 224, 46, 1)' // 0% 处的颜色 }, { offset: 1, color: 'rgba(1, 16, 23, 1)' // 100% 处的颜色 }], global: false // 缺省为 false }, { type: 'linear', x: 0, y: 0, x2: 0, y2: 1, colorStops: [{ offset: 0, color: 'rgba(1, 195, 241, 1)' // 0% 处的颜色 }, { offset: 1, color: 'rgba(1, 16, 23, 1)' // 100% 处的颜色 }], global: false // 缺省为 false }, { type: 'linear', x: 0, y: 0, x2: 0, y2: 1, colorStops: [{ offset: 0, color: 'rgba(46, 229, 165, 1)' // 0% 处的颜色 }, { offset: 1, color: 'rgba(1, 16, 23, 1)' // 100% 处的颜色 }], global: false // 缺省为 false }, ], title: { left: '48.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/801f891d8393b04612f8935fe40fc501/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e84834ec35585e4fc67694a61481e135/" rel="bookmark">
			Playwright系列: 第2章 环境安装与配置安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下方查看历史精选文章
重磅发布 - 自动化框架基础指南pdfv1.1
大数据测试过程、策略及挑战
测试框架原理，构建成功的基石
在自动化测试工作之前，你应该知道的10条建议
在自动化测试中，重要的不是工具
Playwright Playwright支持在Windows、Mac以及Linux系统上安装和使用。
我们可以通过以下方式安装Playwright:
1. 使用NPM安装(适用于Node.js项目)
npm install playwright 2. 使用PIP安装(适用于Python项目)
pip install playwright 3. 下载Playwright二进制包安装
可以在Playwright官网下载针对不同系统的安装包,并按照提示安装。这种方式无需依赖Node.js或Python环境。
4. Docker安装
如果你熟悉Docker,也可以使用Playwright提供的Docker镜像安装:
docker run -it -v /dev/shm:/dev/shm mcr.microsoft.com/playwright:v1.5.2 安装浏览器Playwright
需要安装Chromium、Firefox和/或WebKit浏览器来运行测试。我们可以:
1. 让Playwright自动安装:这是最简单的方式,在使用Playwright时,它会自动下载对应浏览器。2. 手动安装:我们可以手动下载并安装浏览器,然后指定浏览器位置。 3. 使用系统默认浏览器:我们可以让Playwright使用系统默认安装的浏览器。
但Playwright对浏览器版本有要求,系统浏览器版本需要在支持范围内。
以手动安装Chromium为例,我们可以:
1. 下载Playwright支持版本的Chromium:https://playwright.chromium.org/
2. 解压到一个文件夹,如:/Users/username/chromium
3. 设置环境变量
Mac/Linux:
export CHROMIUM_EXECUTABLE_PATH=/Users/username/chromium/chrome Windows:
set CHROMIUM_EXECUTABLE_PATH=C:\Users\username\chromium\chrome.exe 4. 在Playwright脚本中通过环境变量使用Chromium:
python from playwright.sync_api import sync_playwright def run(playwright): chromium = playwright.chromium browser = chromium.launch() # 使用环境变量指定的Chromium # .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e84834ec35585e4fc67694a61481e135/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42f8758ecf169e0c305353cb533d95f5/" rel="bookmark">
			JavaScript中字符串(string)转json的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JavaScript：字符串(string)转换为json 第一种方法： 使用js函数eval();
testJson=eval(testJson);是错误的转换方式。
正确的转换方式需要加(): testJson = eval("(" + testJson + ")");
eval()的速度非常快，但是他可以编译以及执行任何javaScript程序，所以会存在安全问题。在使用eval()。来源必须是值得信赖的。需要使用更安全的json解析器。在服务器不严格的编码在json或者如果不严格验证的输入，就有可能提供无效的json或者载有危险的脚本，在eval()中执行脚本，释放恶意代码。
js代码：
代码如下:
function ConvertToJsonForJs() { //var testJson = "{ name: '小强', age: 16 }";(支持) //var testJson = "{ 'name': '小强', 'age': 16 }";(支持) var testJson = '{ "name": "小强", "age": 16 }'; //testJson=eval(testJson);//错误的转换方式 testJson = eval("(" + testJson + ")"); alert(testJson.name); } 第二种方式使用jquery.parseJSON()方法对json的格式要求比较高，必须符合json格式
jquery.parseJSON() js:代码 代码如下: function ConvertToJsonForJq() { var testJson = '{ "name": "小强", "age": 16 }'; //不知道 //'{ name: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/42f8758ecf169e0c305353cb533d95f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/964bb651dad79df956b4b8806c43b5c3/" rel="bookmark">
			MybatisPlus中的查询条件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Mybatis-Plus是Mybatis的增强工具包，提供了很多便捷的功能，包括自动生成代码、分页、排序、条件查询等。除了LambdaQueryWrapper，Mybatis-Plus中还有以下几种用于定义查询条件的工具：
QueryWrapper: 支持设置查询条件、排序方式等，类似LambdaQueryWrapper，但是使用Java的链式调用方式实现。例如：
QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;(); wrapper.eq("name", "Tom").lt("age", 18).orderByDesc("id").last("limit 10"); List&lt;User&gt; users = userMapper.selectList(wrapper); UpdateWrapper: 与QueryWrapper类似，用于设置更新条件。例如：
UpdateWrapper&lt;User&gt; wrapper = new UpdateWrapper&lt;&gt;(); wrapper.set("age", user.getAge()).eq("name", user.getName()); userMapper.update(null, wrapper); LambdaUpdateWrapper: 类似LambdaQueryWrapper，使用Lambda表达式设置更新条件。例如：
LambdaUpdateWrapper&lt;User&gt; wrapper = new LambdaUpdateWrapper&lt;&gt;(); wrapper.set(User::getAge, user.getAge()).eq(User::getName, user.getName()); userMapper.update(null, wrapper); QueryParam: 用于传递查询条件，在Mapper接口中定义方法时将QueryParam类型参数作为函数参数即可，例如：
List&lt;User&gt; selectByQueryParam(@Param(Constants.WRAPPER) QueryWrapper&lt;User&gt; queryWrapper); 调用时，用QueryWrapper对查询条件进行设置：
QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;(); queryWrapper.eq("name", "Tom").lt("age", 18).orderByDesc("id").last("limit 10"); userMapper.selectByQueryParam(queryWrapper); 除了以上几个工具，Mybatis-Plus还提供了Wrapper接口，可用于自定义条件查询。同时Mybatis-Plus提供了一些实用的方法，例如in、not in、between等，可以方便地构造查询条件。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15db4655146b917d258f9abd579009e2/" rel="bookmark">
			实现绕点旋转，重写osgGA::OrbitManipulation类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们为了达到特定的操作目的，都是通过重写osg操作器来实现业务上的需求，在重写操作器的时候也有不一样的重写悬着。
各个操作的控制目标都不一样，这个时候需要选择不一样的思路来进行重写。
怎么判断一个操作器的控制目标呢？看操作器的私有成员变量，比如osgGA::OrbitManipulation操作器类，她关于操作器相关的重要私有成员变量有三个，osg::Vec3d _center（视点中点）, osg::Quat _rotation（相机变换四元数）, double _distance（相机与视点中点_center的距离） 。注意，osg::Vec3d _center指的是场景的中点坐标，这个中点是相机朝向的法向上的任意一点，相机的位置不变的情况下，_center一旦改变，_distance就跟着变化。所以_center，_rotation，_distance三个参数可以确定唯一的场景图像。
从这几个成员变量我们可以推测，osgGA::OrbitManipulation操作器类是通过改变相机的这三个参数，来实现视图的变换的，也就实现了对场景的控制操作。事实证明也的确如此。
重写osgGA::OrbitManipulation类，实现视图绕指定点旋转：
思路：1，osgGA::OrbitManipulation旋转操作，是通过事件函数，performMovementLeftMouseButton(const double eventTimeDelta, const double dx,const double dy);来实现的。但这个旋转的中心点一直是屏幕的中点，显然这不是我们想要的结果。
2，OrbitManipulation操作器是通过改变_center，_rotation，_distance三个参数来达到控制场景视图，即我们得通过重写performMovementLeftMouseButton()函数改变这三个参数，来达到场景绕指定点旋转的目的。当然，也可以通过外部接口，改变这三个参数来达到控制目的。基础就是改变操作器着三个参数。
3,假设指定点坐标为mCenter；围绕mCenter点旋转之后，计算新的_center，和相机的位置eye，便可得到我们想要的结果。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f96dc469c73e7c8582e7d4bbf47ad814/" rel="bookmark">
			【简单教程】如何用Visual Studio来新建C语言文件（.c后缀）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 用Visual Studio来配置c语言环境的方法就不说了，网上有教程，这里放两个不错的教程C语言/C++初学——Visual Studio环境的安装配置与使用 - 知乎 (zhihu.com)VS2019搭建C语言开发环境（图文教程)_vs c语言_DeRoy的博客-CSDN博客
正文 接下来我们开始正文，我们会发现Visual Studio中似乎只有.cpp后缀的文件，好像没有.c后缀的文件。这是因为.c后缀是需要我们改的：
首先创建项目成功（在我推荐的教程里有）之后需要添加C++文件main.c的，我们把鼠标移至源文件，点击右键，选择如下
这时候如上图红框所示，把cpp后缀改成.c后缀即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d98dfedc6c439086ac4080674dfd6a7f/" rel="bookmark">
			数据算法之反转链表（五种方法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		反转链表 1.常规思路解题2. 常规思路解题方法的优化3. 递归解题方法4. 指针思想解决问题5. 指针方法另一种思路 题目描述： 给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。
示例：
输入：head = [1,2,3,4,5]
输出：[5,4,3,2,1]
提示代码：
/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode reverseList(ListNode head) { } } 这道题来自力扣的第206题，今天我们尝试使用五种不同的方法来实现链表的反转。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d98dfedc6c439086ac4080674dfd6a7f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7974791f9de09970b12e1fa4b01e897/" rel="bookmark">
			npm将软件包安装到哪里
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 npm 安装软件包时，可以执行两种安装类型：
本地安装
默认情况下，输入命令 npm install 命令时，软件包会安装到当前文件树中的 node_modules 子文件夹下
# npm 还会在当前文件夹中存在的 package.json 文件的 dependencies 属性中添加 less 条目 npm install less 全局安装
使用 -g 标志可以执行全局安装 npm install -g less npm 不会将软件安装到本地文件夹下，而是使用全局的位置
全局位置在哪呢
# 查看全局位置 npm root -g macOs /Linux一般是：/usr/local/lib/node_modulesWindows一般是：C:\Users\xxx\AppData\Roaming\node_modules 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/902a14f09b8ac0fa0b25e61c16a0e28c/" rel="bookmark">
			Android Studio升级Gradle Plugin升级导致项目运行失败问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景&amp;错误 升级Android Studio
旧项目无法运行，奇奇怪怪什么错误都有
例如：
java.lang.IllegalAccessError: class org.gradle.api.internal.tasks.compile.processing.AggregatingProcessingStrategy (in unnamed module @0x390ea9fb) cannot access class com.sun.tools.javac.code.Symbol$ClassSymbol (in module jdk.compiler) because module jdk.compiler does not export com.sun.tools.javac.code to unnamed module @0x390ea9fb * Exception is: org.gradle.api.tasks.TaskExecutionException: Execution failed for task ':BaziPaipan_lib:compileDebugJavaWithJavac'. at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.lambda$executeIfValid$1(ExecuteActionsTaskExecuter.java:200) at org.gradle.internal.Try$Failure.ifSuccessfulOrElse(Try.java:263) at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.executeIfValid(ExecuteActionsTaskExecuter.java:198) at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.execute(ExecuteActionsTaskExecuter.java:179) at org.gradle.api.internal.tasks.execution.CleanupStaleOutputsExecuter.execute(CleanupStaleOutputsExecuter.java:109) at org.gradle.api.internal.tasks.execution.FinalizePropertiesTaskExecuter.execute(FinalizePropertiesTaskExecuter.java:46) at org.gradle.api.internal.tasks.execution.ResolveTaskExecutionModeExecuter.execute(ResolveTaskExecutionModeExecuter.java:62) at org.gradle.api.internal.tasks.execution.SkipTaskWithNoActionsExecuter.execute(SkipTaskWithNoActionsExecuter.java:57) at org.gradle.api.internal.tasks.execution.SkipOnlyIfTaskExecuter.execute(SkipOnlyIfTaskExecuter.java:56) at org.gradle.api.internal.tasks.execution.CatchExceptionTaskExecuter.execute(CatchExceptionTaskExecuter.java:36) at org.gradle.api.internal.tasks.execution.EventFiringTaskExecuter$1.executeTask(EventFiringTaskExecuter.java:77) at org.gradle.api.internal.tasks.execution.EventFiringTaskExecuter$1.call(EventFiringTaskExecuter.java:55) at org.gradle.api.internal.tasks.execution.EventFiringTaskExecuter$1.call(EventFiringTaskExecuter.java:52) at org.gradle.internal.operations.DefaultBuildOperationRunner$CallableBuildOperationWorker.execute(DefaultBuildOperationRunner.java:200) at org.gradle.internal.operations.DefaultBuildOperationRunner$CallableBuildOperationWorker.execute(DefaultBuildOperationRunner.java:195) at org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/902a14f09b8ac0fa0b25e61c16a0e28c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ad5e83cdf979a87bb448d44156652c4/" rel="bookmark">
			瓦片地图下载到本地
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用插件：MapDownloader、GISMysqlToLocal
插件下载地址：GitHub - chenwuwen/OffineMap
下载步骤：
1.打开地图下载器
2.找到MapDownloader.exe.config进行修改
3.修改红框中的：改数据库地址，用户名密码等，改成自己的。
4.选择mysql数据库
5.选择地图，最好选择高德地图，其他的容易出现地图不显示问题。
6.选择区域，选择要下载的地图级别。
7.下载完成后，进入mysql数据库，发现新建了一张数据表。
8.打开 GISMysqlToLocal，将瓦片地图下载到本地
导出后的内容是这样的
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43b98a9175106e3e4ccf559b9e919819/" rel="bookmark">
			Android桌面长按图标快捷方式——Shortcuts
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 当我们在长按Android应用的桌面图标时，一般回弹出一个列表，上面一般有应用信息、卸载应用等功能，并且部分应用在这里还添加了自己的快捷方式，今天主要介绍如何添加自定义的快捷方式。
长按桌面显示的快捷方式在Android中叫Shortcut，它有两种创建方式，分为静态创建和动态创建，并且跟Widget一样，也有对应的管理类来进行管理。废话不多说，直接开始
静态创建 第一步 静态创建分两个步骤，第一个是在Manifest文件中指定快捷方式配置文件的位置，首先找到Launcher的activity标签，添加meta-data标签如下：
&lt;activity android:name=".MainActivity" android:exported="true"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt; &lt;meta-data android:name="android.app.shortcuts" android:resource="@xml/shortcuts" /&gt; &lt;/activity&gt; 第二步 在resources资源目录下创建xml文件夹，并在文件夹中创建名为shortcuts的xml文件，其中内容如下：我们创建了两个标签
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;shortcuts xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;shortcut android:enabled="true" android:icon="@mipmap/ic_launcher_round" android:shortcutDisabledMessage="@string/disable_hint_message" android:shortcutId="shortcut1" android:shortcutLongLabel="@string/long_label_one" android:shortcutShortLabel="@string/short_label_one"&gt; &lt;intent android:action="android.intent.action.VIEW" android:targetClass="com.example.helloworld.RecyclerViewTestActivity" android:targetPackage="com.example.helloworld"&gt; &lt;extra android:name="key1" android:value="value1" /&gt; &lt;/intent&gt; &lt;/shortcut&gt; &lt;shortcut android:enabled="true" android:icon="@mipmap/ic_launcher_round" android:shortcutDisabledMessage="@string/disable_hint_message" android:shortcutId="shortcut2" android:shortcutLongLabel="@string/long_label_two" android:shortcutShortLabel="@string/short_label_two"&gt; &lt;intent android:action="android.intent.action.VIEW" android:targetClass="com.example.helloworld.TestViewPagerActivity" android:targetPackage="com.example.helloworld"&gt; &lt;extra android:name="key2" android:value="value2" /&gt; &lt;/intent&gt; &lt;/shortcut&gt; &lt;/shortcuts&gt; &lt;string name="short_label_one"&gt;名称一&lt;/string&gt; &lt;string name="short_label_two"&gt;名称二&lt;/string&gt; &lt;string name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43b98a9175106e3e4ccf559b9e919819/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ee88c9ea1d3107f6b0dedfcee6d4145/" rel="bookmark">
			redis arm镜像报错Unsupported system page size
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个错误的原因是jemalloc导致的，jemalloc是一种内存管理库，主要用于提高程序的内存分配和释放性能，使用jemalloc编译的程序在内存页大小不同的操作系统上运行可能会遇到问题，所以在自己要运行redis的操作系统上构建是最保险的
构建方式： 这里构建redis 5.0.4版本的arm镜像，在arm机器上执行下面命令
git clone https://github.com/docker-library/redis.git # 定位历史提交,需要什么版本自己grep git log | grep -5 'Update to 5.0.4' # 取对应的提交hash值，reset一下 git reset -f --hard dcc0a2a343ce499b78ca617987e8621e7d31515b cd 5.0/alpine # 构建过程中会访问外网，如果下载不了自己配置一下http的网络代理 # docker build --build-arg http_proxy=http://1.1.1.1:123/ --build-arg https_proxy=http://1.1.1.1:123/ -t redis:5.0.4-alpine . docker build -t redis:5.0.4-alpine . 经过测试可成功在自己arm机器上运行
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24560afced492b10b002724f0ae32139/" rel="bookmark">
			拉格朗日乘子法从0到1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 如何理解拉格朗日乘子法问题引出，与原点最短距离问题延伸：等高线拉格朗日乘子法求解定义变形 如何理解拉格朗日乘子法 问题引出，与原点最短距离 假设有方程
x 2 y = 3 x^2y = 3 x2y=3
对应图像如下：
现在我们想求其上的点与原点的最短距离：
这里介绍一种解题思路。首先，与原点距离为 α \alpha α的点全部在半径为 α \alpha α的圆上：
那么，我们逐渐扩大圆的半径：
显然，第一次与 x 2 y = 3 x^2y = 3 x2y=3 相交的点就是距离原点最近的点：
此时，圆和曲线相切，也就是在该点切线相同：
至此，我们分析出了：在极值点，圆与曲线相切！
问题延伸：等高线 为了继续解题，需要引入等高线。这些同心圆：
上图可看做是 f ( x , y ) = x 2 + y 2 f(x,y) = x^2 + y^2 f(x,y)=x2+y2 的等高线
根据梯度的性质，梯度向量：
∇ f = ( ∂ f ∂ x ∂ f ∂ y ) = ( 2 x 2 y ) \nabla f = \left (\begin{aligned} \frac{\partial f}{\partial x} \\ \frac{\partial f}{\partial y} \end{aligned}\right) = \left (\begin{aligned} 2x \\ 2y \end{aligned}\right) ∇f= ​∂x∂f​∂y∂f​​ ​=(2x2y​)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/24560afced492b10b002724f0ae32139/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f439268e7168e636fb4537573612bb0/" rel="bookmark">
			(3/100) cmake指令详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考博客：
1. cmake核心知识点整理
2. cmake - 编译
3. CMake教程
4. Cmake使用教程（看这一篇就够了）(这篇详细的介绍了cmake的安装、创建和使用过程)
5. CMake 入门实战
6. CMake&amp;CMakeList.txt
0、cmake基础知识 0.1 什么是cmake，与make区别 在各种开源项目中，经常会发现项目中除了代码源文件，还包含了 CMakeList.txt、 Makefile 文件，在项目的编译时候需要用到的命令有 cmake 、 make。我们本次想搞清楚他们之前的关系以及CMakeList的语法规则。
正常情况下，我们编写程序的大体流程为： 1）用编辑器（vim、emacs等）编写源代码文件（.h、.cpp等）； 2）用编译器编译代码生成目标文件（.o等）； 3）用链接器连接目标文件生成可执行文件（.exe等）。 一个程序在编写时，可能需要编写很多的代码文件，以及依赖很多第三方的库。在这种情况下，手动依次编译每个文件会变的非常麻烦，效率低下。
make 是一个自动化的批量编译工具，可以实现用一个命令构建整个工程的目的。但是其执行需要依赖一个规则文件，这个文件就是 Makefile。 Makefile 文件里详细描述了构建的细节（文件的依赖关系，编译的先后顺序等）。
对于一个大工程来说，编写 Makefile 文件也是一项非常复杂的事情。
cmake(Cross-platform Make)是一个可以自动生成 Makefile 文件的工具，当然它不只能生成 Makefile ，还能跨平台生成主流IDE(VS, xcode…)构建工程所需的 project 文件。 cmake 的执行同样需要依赖规则文件，这个文件就是 CMakeLists.txt 。
所以，为了能够把一堆c，cc，cpp，h，hpp代码变成可运行的库或者程序，核心还是Makefile，CMakefiles.txt纯粹是为了降低不懂Unix体系的人去编译C/C++代码做的一个自动系统和环境检测和设置工具，同时帮你生成Makefile。
0.2 语法特性介绍 基本语法格式：指令(参数 1 参数 2…) 参数使用括弧括起 参数之间使用空格或分号分开 指令是大小写无关的，参数和变量是大小写相关的 set(HELLO hello.cpp) add_executable(hello main.cpp hello.cpp) ADD_EXECUTABLE(hello main.cpp ${HELLO}) 变量使用${}方式取值，但是在 IF 控制语句中是直接使用变量名 1、指定编译器并同时设置编译选项 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f439268e7168e636fb4537573612bb0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1e3076613b4326e33e0303dfffc8046/" rel="bookmark">
			Servlet配置与使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原生Servlet配置与使用【详解】 接上篇文章介绍了如何创建一个javaweb的项目，这期我们就来看看如何配置servlet，并且使用servlet接收与响应请求。
提示：新手小伙伴可以先看上篇文章，如何创建一个javaweb项目！
文章目录 原生Servlet配置与使用【详解】一、Servlet简介1、Servlet容器2、实现过程3、生命周期1、实例化阶段2、初始化阶段3、服务阶段（处理请求）4、销毁阶段 二、快速开始1.导入jar包2.配置servlet1.web.xml文件2.@WebServlet注解两种方式总结 总结 一、Servlet简介 Servlet（Server Applet）是Java Servlet的简称，称为小服务程序或服务连接器，用Java编写的服务器端程序，具有独立于平台和协议的特性，主要功能在于交互式地浏览和生成数据，生成动态Web内容。
狭义方面来讲 Servlet是指Java语言实现的一个接口，广义的Servlet是指任何实现了这个Servlet接口的类，一般情况下，人们将Servlet理解为后者。Servlet运行于支持Java的应用服务器中。从原理上讲，Servlet可以响应任何类型的请求，但绝大多数情况下Servlet只用来扩展基于HTTP协议的Web服务器。
1、Servlet容器 所谓容器，顾名思义就是放东西的地方。Servlet容器自然就是放Servlet的地方。由J2EE开发。
Tomcat是Servlet的运行环境，即一个Servlet容器。
Servlet容器的作用是负责处理客户请求，当客户端发送请求过来时，Servlet容器获取请求，然后调用某个Servlet，并把Servlet的执行结果返回给客户端。因此，Servlet容器是Web服务器和servlet进行交互的必不可少的组件
2、实现过程 Servlet 的主要功能在于交互式地浏览和修改数据，生成动态 Web 内容，过程为：
1，客户端发送请求至服务器端；
2，服务器将请求信息发送至 Servlet；
3，Servlet 生成响应内容并将其传给服务器。响应内容动态生成，通常取决于客户端的请求；
4，服务器将响应返回给客户端。
3、生命周期 Servlet生命周期是指Servlet从创建直到毁灭的整个过程。可以分为以下几个阶段：
1、加载实例化阶段；
2、初始化阶段：
3、服务阶段：
4、销毁阶段：
1、实例化阶段 Servlet 容器负责加载和实例化 Servlet。当容器启动或第一个发送请求给某个 Servlet 时，容器会读取 web.xml 或 @WebServlet 中的配置信息。对指定的 Servlet 进行加载。加载成功后，容器会通过反射对 Servlet 进行实例化。
2、初始化阶段 当客户端向 Servlet 容器发出请求时，Servlet 容器首先会解析请求，判断是否已经有了该 Servlet 对象，如果有，则直接使用该 Servlet 对象，如果没有，则创建 Servlet 实例对象，然后通过调用 init() 方法（在servlet生命周期内只能调用一次init方法)去初始化 Servlet 实例。
3、服务阶段（处理请求） 这个阶段也是 Servlet 生命周期中最重要的阶段，在这个阶段中，Servlet 容器会为这个请求创建代表 HTTP 请求的 ServletRequest 对象和代表 HTTP 响应的 ServletResponse 对象，然后将它们作为参数传递给 Servlet 的 service() 方法。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f1e3076613b4326e33e0303dfffc8046/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9bc988ead4bb22a1f724dc3e6801c80d/" rel="bookmark">
			sql server 未将对象引用设置到对象的实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		报错 相信报错 =================================== 未将对象引用设置到对象的实例。 ( 在 Microsoft.VisualStudio.Text.Editor.Implementation.WpfTextView.UnsubscribeFromEvents() 在 Microsoft.VisualStudio.Text.Editor.Implementation.WpfTextView.Close() 在 Microsoft.VisualStudio.Text.Editor.Implementation.WpfTextViewHost.Close() 在 Microsoft.VisualStudio.Editor.Implementation.SimpleTextViewWindow.CloseExistingWpfTextView() 在 Microsoft.VisualStudio.Editor.Implementation.SimpleTextViewWindow.CloseBufferRelatedResources() 在 Microsoft.VisualStudio.Editor.Implementation.SimpleTextViewWindow.CloseView() 在 Microsoft.VisualStudio.Editor.Implementation.CompoundTextViewWindow.Close() 在 Microsoft.SqlServer.Management.UI.VSIntegration.ShellCodeWindowControl.UnsinkEventsAndFreeInterfaces() 在 Microsoft.SqlServer.Management.UI.VSIntegration.ShellTextEditorControl.Dispose(Boolean disposing) 在 System.ComponentModel.Component.Dispose() 在 Microsoft.SqlServer.Management.UI.VSIntegration.Editors.ScriptEditorControl.Dispose(Boolean bDisposing) 在 Microsoft.SqlServer.Management.UI.VSIntegration.Editors.ScriptAndResultsEditorControl.Dispose(Boolean bDisposing) 在 Microsoft.SqlServer.Management.UI.VSIntegration.Editors.SqlScriptEditorControl.Dispose(Boolean bDisposing) 在 Microsoft.SqlServer.Management.UI.VSIntegration.ShellWindowPaneUserControl.OnWindowPaneClose() 在 Microsoft.SqlServer.Management.UI.VSIntegration.ShellWindowPaneUserControl.ClosePane() 在 Microsoft.VisualStudio.Platform.WindowManagement.WindowPaneDocumentObject.&lt;&gt;c__DisplayClass19_0.&lt;DisposeManagedResources&gt;b__0() 在 Microsoft.VisualStudio.ErrorHandler.CallWithCOMConvention(Action method, Boolean reportError)) ------------------------------ 程序位置: 在 System.Runtime.InteropServices.Marshal.ThrowExceptionForHRInternal(Int32 errorCode, IntPtr errorInfo) 在 Microsoft.SqlServer.Management.UI.VSIntegration.Editors.ScriptFactory.CreateNewScript(String strFullPathToScript, IVsProject projectToAddScriptTo, UIConnectionGroupInfo connectionInfoList, IDbConnection liveCon, String rootName) 在 Microsoft.SqlServer.Management.UI.VSIntegration.Editors.ScriptFactory.CreateNewScript(String strFullPathToScript, IVsExternalFilesManager extFileMgr, UIConnectionGroupInfo connectionInfoList, IDbConnection liveCon, String rootName) 在 Microsoft.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9bc988ead4bb22a1f724dc3e6801c80d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad5b6a1879824dcf7a4ef33e96c76236/" rel="bookmark">
			java项目引入sdk后打成jar包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天遇到一个需求，需要用到第三方sdk，开发的时候一直都是好好的，但是打成jar包部署上去的时候出现问题。处理了很久处理了这个方法
首先我们的项目是打成一个个分立的jar包的
此时需要在引入sdk的模块的pom文件里，
添加这段maven
&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;!-- 注意此处一定要指定启动类 --&gt; &lt;mainClass&gt;com.haoyu.app.tdc.jiangmen.JiangmenApplication&lt;/mainClass&gt; &lt;includeSystemScope&gt;true&lt;/includeSystemScope&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 然后此时打成了jar包
打开里面是有sdk的
但是注意，在执行maven的package之后，却不会吧上述的jar包里的sdk包也打包，就算jar包里含有sdk，（下图中没有sdk包，即使模块的jar包里含有但是部署也没用）
此时如果一部署就报错。
处理方法，把sdk的jar包也给复制一份，一样扔过去部署。
处理方式不完美，但是算是解决了问题。
如果使用maven引入第三方包的方式可能会完美解决此问题
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e28362c43ad985d9feac65244a482d35/" rel="bookmark">
			Python脚本实现云顶之弈自动挂机刷局数！这操作怎么说？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 1.不使用外部硬件模块，仅使用Python库实现。
2.有些代码可以再优化，处理一些异常的情况。
我会在文章最后附上在win10下使用pyinstaller打包好的可执行程序。如果和我的电脑屏幕分辨率一样的，可以直接下载下来测试使用。
本文下面构建的Python脚本都有详细的配套教程以及源码，都已经打包好上传到百度云了，链接在文章结尾处！
扫码此处领取大家自行获取即可~~~
Python环境
Python 3.7.3 库：PIL,random,threading,pyautogui,keyboard 更新 2021/3/14 更新：测试了奖励界面关闭函数的功能，测试结果是可以正常关闭奖励界面。但是鼠标点的有点偏下，现在提供一个新的关闭奖励界面函数，鼠标能点到按钮中间了：
def close_award_interface2(lol_hwnd): box = (721, 822, 161, 50) # (x,y,width,height) 按钮相对于LOL客户端的坐标 center = convert_lol_to_destop_point(pg.center(box), lol_hwnd) slow_click(center) move_to_empty_area(lol_hwnd) return True 复制代码 主要改动
1.不使用外部硬件模块，但是代码必须使用管理员权限运行才可以。将原来的硬件上报鼠标事件，键盘事件换成了pyautogui和keyboard库上报。因为实际测试的时候，pyautogui库模拟鼠标没遇到什么问题，但是模拟键盘的时候，在游戏中响应不了，所以使用keyboard库来模拟键盘。
import pyautogui as pg import keyboard as kb def slow_click(p, button='PRIMARY', move_time = 0.2, down_time = 0.2, up_time = 0.2): pg.moveTo(p[0], p[1], duration=move_time) pg.mouseDown(p[0], p[1], button=button, duration = down_time) pg.mouseUp(p[0], p[1], button=button, duration = up_time) return True def slow_key_press(key, down_time = 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e28362c43ad985d9feac65244a482d35/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5dc6fe0da665ef1355f005424edb5f85/" rel="bookmark">
			SpringBoot整合Canal1.1.6并同步数据到Redis（超详细和很多踩坑点）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpringBoot整合Canal 一、使用背景二、什么是 Canal?三、准备工作1、准备MySql 8.x1)查看数据库版本2)查看BinLog日志是否开启3)如果未开启binlog4)为canal新建账号5)踩坑点 2、准备Canal1)[Canal1.1.4下载](https://github.com/alibaba/canal/releases/tag/canal-1.1.4)2)解压并配置Canal3)启动Canal4)踩坑点 3、准备项目测试1、构建SpringBoot项目，引入坐标2、新建监听类3、新建启动类 一、使用背景 最近公司新接了一个医院项目，主要是对接医院内营养处方数据，院内his部署在内网环境，因此仅提供一个外网数据库给我们（他们自己应该做了类似主从的方式将我们需要的数据同步一份到外网数据库），又因为落地的数据我们需要立马进行处理并在公众号推送给病人进行付款等一系列其他操作，所以我们需要实时监听数据库的变化。以下是当时能想到的方案：
方案一：轮询数据库
第一个想到的也第一个被pass。原因也不必多说
方案二：数据库触发器
数据库触发器公司内部的小伙伴使用的都极其的少，确实是我们自己学艺不精，而且维护起来不方便，对后面来的开发小伙伴也不友好，最终也被pass
方案三：消息队列
这应该是在没有提供外网数据库的时候想出的方案，也是最符合业务场景的方案之一，但由于甲方不想增加开发成本、业务代码被入侵以及使用第三方插件增加系统风险和不稳定性等一系列原因，这个方案也被pass
方案四：Canal
讨论很久以后才决定使用canal，主要原因第一个是我们需要实时监听院内处方的数据变化，第二个是推过来的处方数据我们需要展示给用户，每个人只能看到自己的处方数据，并且处方有时效性，利用redis的过期时间也能完美代替数据库条件查询。
二、什么是 Canal? 这里简单介绍，具体就不从官网贴图了，啥都没有官网说的清楚，点击进入Canal官网
1、了解什么是Canal之前我们应该首先了解以下MySql的主从复制原理
MySQL master 将数据变更写入二进制日志( binary log, 其中记录叫做二进制日志事件binary log events，可以通过 show binlog events 进行查看)
MySQL slave 将 master 的 binary log events 拷贝到它的中继日志(relay log)
MySQL slave 重放 relay log 中事件，将数据变更反映它自己的数据。
上述中涉及到两个重要的MySql事务日志 binlog和relaylog，简单介绍一下两种日志
BinLog
即binary log，二进制日志文件，也叫作变更日志（update log）。它记录了数据库所有执行的
DDL 和 DML 等数据库更新事件的语句，但是不包含没有修改任何数据的语句（如数据查询语句select、 show等）。
说白了就是MySql记录了除了查询语句之外的几乎任何增删改操作。MySql8以后默认开启。开启会损失约百分之一的性能。
RelayLog
中继日志只在主从服务器架构的从服务器上存在。从服务器为了与主服务器保持一致，要从主服务器读
取二进制日志(binary log)的内容，并且把读取到的信息写入 本地的日志文件 中，这个从服务器本地的日志文件就叫
中继日志 。然后，从服务器读取中继日志，并根据中继日志的内容对从服务器的数据进行更新，完成主
从服务器的 数据同步 。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5dc6fe0da665ef1355f005424edb5f85/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce3a322b1d6a8da57caf21cb24984165/" rel="bookmark">
			2014蓝桥杯国赛排列序数 C语言/C&#43;&#43;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[蓝桥杯 2014 国 A] 排列序数 题目描述 如果用 a b c d 这 4 4 4 个字母组成一个串，有 4 ! = 24 4!=24 4!=24 种，如果把它们排个序，每个串都对应一个序号：
abcd 0 abdc 1 acbd 2 acdb 3 adbc 4 adcb 5 bacd 6 badc 7 bcad 8 bcda 9 bdac 10 bdca 11 cabd 12 cadb 13 cbad 14 cbda 15 cdab 16 cdba 17 ... 现在有不多于10个两两不同的小写字母，给出它们组成的串，你能求出该串在所有排列中的序号吗？
输入格式 一行，一个串。
输出格式 一行，一个整数，表示该串在其字母所有排列生成的串中的序号。注意：最小的序号是 0 0 0。
样例 #1 样例输入 #1 bdca 样例输出 #1 11 样例 #2 样例输入 #2 cedab 样例输出 #2 70 提示 时限 1 秒, 256M。蓝桥杯 2014 年第五届国赛
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce3a322b1d6a8da57caf21cb24984165/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06efc5eef63252f7b47138e4328fc7e3/" rel="bookmark">
			【Web技术】1657- 深度使用html2canvas的经验总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、背景 移动端业务裂变业务最大的难点就是移动端缺少快速裂变的渠道，仅靠搜索引擎的导流，获得的流量和客户引流是极其有限，这也是SEO优化逐渐被人忽视的根本原因。我们的业务肯定希望在微信、微博、抖音等渠道进行快速裂变，但是这些渠道对移动端等网页的引流做了很强的限制，例如二跳限制、合规限制，巧妇难为无米之炊啊。
最常用的解决方案则是依赖图片分享转发来绕开流量平台的URL限制，常见的就是各种海报、截图，形式多种多样。这样一来就给开发带来了更高的要求，分享图必须拟合客户画像，内容丰富且依据客户深度定制，表现的张力很强，才能吸引客户去分享。
在这种业务背景下，前端开发就希望设计一套自动生成丰富多样的截图方案，常规的玩法有两大类：前端生成和后台生成。
1、后台生成是指在Nodejs服务端中，通过调用chrome内核来加载对应的页面，然后使用浏览器等内置API进行截图，例如使用 puppeteer 生成 pdf。
通过后台服务生产的图片在清晰度和字体显示的平滑程度方面效果是最好的，并且开发方式简单，Nodejs 服务器前端可以自己开发和维护，但缺点是服务端生成依赖 Nodejs 服务，增加额外的服务器环境维护工作和开发工作。
2、前端生成则是指在前端浏览器端生成，一般可以选择 html2canvas 或者直接使用 HTML5 canvas 的API直接绘制。
html2canvas 是很成熟的 JavaScript 库，拥有 2.7W+ 的关注，经过长时间的迭代其性能和使用体验可以得到很好的保障。其实 html2canvas 底层是使用 canvas API 实现的，因此也可以直接使用 canvas API 来进行效果绘制，优点就是性能高，不必依赖于 DOM 结构的渲染，可以直接绘制 canvas 生成图片，也可以摆脱 DOM 的限制，做出一些酷炫的效果；缺点就是实现的难度太大，普通开发学习成本高，难以很快上手。
本文主要关注 html2canvas 的前端生成方案，作者把在其中学习到的思路和踩坑经验和大家分享下，帮助大家上线顺利，享受美好的周末。
2、原理和使用 正如 html2canvas 的名字所提示的一样，其实现截图的原理实际是将DOM对象进行迭代克隆和解析，按照层叠关系自顶向下逐步绘制到 canvas 对象里，然后利用 canvas 的底层 API toDataURL和 toBlob转换成图片数据，最终可以上传到后台生成截图的在线地址，方便客户进行预览和下载分享。
本文将结合 html2canvas 的使用给大家介绍下内部调用细节。
import html2canvas from 'html2canvas'; // DidMount 之后 const canvas = await html2canvas(this.posterRef.current as HTMLElement, options: Options); const jpgImgBase64 = canvas.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/06efc5eef63252f7b47138e4328fc7e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0abca188b45157c89600f2176c01fcbb/" rel="bookmark">
			pyqt5安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://blog.csdn.net/Mrbuyi/article/details/127993128
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bed352168c2bcba9e0420b9dd8e58266/" rel="bookmark">
			力扣-两数之和-暴力解法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。
示例 1：
输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
示例 2：
输入：nums = [3,2,4], target = 6
输出：[1,2]
示例 3：
输入：nums = [3,3], target = 6
输出：[0,1]
// 定义一个函数twoSum，接收一个数组nums和一个目标值target作为参数 var twoSum = function(nums, target) { // 获取数组长度 let num=nums.length; // 循环遍历nums数组，从第一个元素开始 for(let i=0; i&lt;num; i++){ // 遍历i后面的元素，因为同一个元素不会被重复使用 for(let j=i+1; j&lt;num; j++){ // 如果nums[i]和nums[j]可以相加得到target if(nums[i]+nums[j]===target){ // 返回它们的下标 return [i,j]; } } } // 如果没有符合条件的一组数，则返回[-1,-1] return [-1,-1]; }; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ffbd97843d3661909ced0d0da1b29349/" rel="bookmark">
			arm系统调用过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		寄存器介绍来自于 https://blog.csdn.net/a999818/article/details/123837580 ARM 处理器一般共有 37 个寄存器，其中包括： 1） 31 个通用寄存器，包括 PC（程序计数器）在内，都是 32 位的寄存器。 2） 6 个状态寄存器，都是 32 位的寄存器。 ARM 处理器共有 7 种不同的处理器模式： （1）USR（10000）：正常用户模式，程序正常执行模式。 （2）FIQ（10001）：快速中断模式，以处理快速情况，支持高速数据传输或通道处理。 （3）IRQ（10010）：外部中断模式，普通中断处理 （4）SVC（10011）：操作系统保护模式（管理模式），即操作系统使用的特权模式（内核），处理软件中断swi reset （5）abt（10111）：数据访问中止模式，用于 虚拟存储器 和 存储器 保护 （6）und（11011）：未定义指令终止模式，用于支持通过软件仿真硬件的协处理器 （7）sys（11111）：系统模式，用于运行特权级的操作系统任务（ armv4 以上版本才具有） 1、 在所有的寄存器中，有些是各模式共用同一个物理寄存器，有些寄存器是各个模式自己拥有独立的物理寄存器 2、CPSR和SPSR都是程序状态寄存器，其中SPSR是用来保存中断前的CPSR中的值，以便在中断返回之后恢复处理器程序状态。 从下图可以看到system和user模式的所有寄存器是共享的。而svc和user模式的r13和r14是不共享。这意味着当从用户态态转到svc模式时，同样是在访问寄存器r13。这个r13在不同模式下的值是不同的.
例如针对同样的汇编指令
mov r0,r13（user模式）--&gt;（假设这条指令直接到了svc模式下）mov r0,r13//svc下的r13就不是用户态的r13。他们只是同名而已，其实是两个不同的寄存器了。
这是为什么说arm有31个通用寄存器 16（user&amp;system）+ 7 (FIQ)+2（svc）+2(abort)+2(irq)+2(undef) = 31
状态寄存器6个=1+1+1+1+1+1
除用户模式之外的其他6种处理器模式被称为特权模式。在这些模式下，程序可以访问所有的系统资源，也可以进行处理器模式切换
系统调用产生过程
如：open ---&gt; __libc_open() ---&gt; svc/swi ---&gt; vector_swi ---&gt;system_call ---&gt; sys_func
svc和swi的区别 svc和swi都是supervisor call指令，都是系统调用. 再armv7之前，用的都是swi， 触发异步异常，进入vector_swi异常向量表; 在armv8-arch64架构下，抛弃了swi，改用了 svc，触发的是同步异常，进入同步异常向量表el1_sync 系统调用和普通的函数调用是不同的。对于普通的函数调用，参数被保存到了r0-r3中，如果形参超过了4个，那么多余的参数可以用栈进行传递。但是对于系统调用(swi/svc)，会引起处理器模式切换user切换到svc，而svc模式下的sp和user模式的sp是不同的。因此系统调用无法使用栈传入参数，需要将所有的参数通过寄存器传递。arm最多支持6个（r0-r5）。sp究竟是怎么切换的呢?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ffbd97843d3661909ced0d0da1b29349/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e8433f9a404f1f3ba601c14b026d321/" rel="bookmark">
			HTTPS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.对称加密
2.非对称加密
中间人攻击
解决
HTTPS 也是一个应用层协议，是在 HTTP 协议的基础上引入了一个加密层。为了实现安全传输，核心就是加密。
1.对称加密 加密时，明文+key=密文，解密时，密文+key=明文，此处的key（密钥）是相同的，这就是对称加密。此处的key可以认为是一串数字或字符串，通过密钥和明文进行一系列数学运算就是密文。
但是服务器同一时刻要给很多客户端服务，如果每个客户端的密钥都相同，那就很容易被中间网络设备识别，因此每个客户端都要有不同的密钥，如此一来服务器就要维护每个客户端和密钥的关联关系。
假设由客户端生成一个密钥，然后把密钥告诉服务器，但这个密钥只能明文传输，就有可能被中间网络设备截获。要上解决安全的把密钥传给服务器就引入了非对称加密。
2.非对称加密 生成一对密钥，公钥和私钥，使用公钥加密，明文+公钥=密文，使用私钥解密，密文+私钥=明文，反过来也行，这就是非对称加密。
开始阶段协商密钥时，通过将对称密钥进行非对称加密，服务器生成一对公钥私钥，客户端向客户端请求公钥，服务器持有私钥，中间网络设备可以知道公钥，但私钥是服务器私有的；客户端使用公钥，来对对称密钥加密，传输给服务器，服务器用私钥解密得到对称密钥，一旦对称密钥到达服务器，后续的传输都使用对称密钥加密，在这个过程中由于对称密钥使用公钥加密，所以中间网络设备无法解密出对称密钥，就不会被截获。
此处为什么还要保留对称加密，不全部使用非对称加密？
因为对称加密较非对称加密快，效率高。
中间人攻击 但是这个过程并不是天衣无缝，还存在中间人攻击。 当客户端向服务器请求公钥时，并不能保证公钥不是中间设备伪造的，如果中间设备生成一对非对称密钥，将伪造的公钥发给客户端，此时客户端生成对称密钥key，并使用伪造的公钥对key加密，客户端将加密好的对称密钥发送给中间设备，中间设备再根据自己的私钥解密，这样就得到了对称密钥key，之后中间设备就可以使用服务器的公钥对key加密，并发给服务器，此时服务器就以为这个对称密钥是客户端发来的，后续交互就直接使用对称密钥进行。
解决 解决中间人攻击的关键，在于客户端能辨别这个公钥是来自与服务器，而不是直接设备的，这里的做法是引入一个“证书”，服务器的公钥包含于这个证书中。
客户端向服务器请求公钥时，会请求整个“证书”，拿到证书后，会对证书进行校验，如果证书是无效的，会直接弹框警告。
这个校验过程为客户端使用认证机构提高的公钥来解密证书中的“签名”（被加密的字符串）字段，得到结果1（相当于一个hash值），根据同样的hash算法，对其他字段再算一次hash值，判断两次hash值是否相同。
黑客无法篡改证书。一旦替换公钥，客户端计算出的两次hash值就对不上，并且，黑客也无法知道认证机构的私钥，即使算好了篡改后的hash值，也无法加密生成签名，因为认证机构有一组公钥私钥，私钥加密hash值得到签名，公钥是客户端解密签名获取hash值的。
以上就是本文的全部内容了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45e44323c513bd9695ad5d91f7660cf0/" rel="bookmark">
			使用MyBatis批量查询(select)、批量插入(insert)、批量更新(update)、批量删除(delete)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记录：412
场景：使用MyBatis批量查询(select)、批量插入(insert)、批量更新(update)、批量删除(delete)操作MySQL数据库。
版本：JDK 1.8,Spring Boot 2.6.3,mybatis-3.5.9,MySQL-5.7.33。
1.批量查询
提供两种方式。
方式一，返回值： List&lt;CityPO&gt;。
方式二，返回值： List&lt;Map&lt;String, Object&gt;&gt;。
1.1在CityBatchMapper中接口代码
@Repository public interface CityBatchMapper { // 1.1批量查询 List&lt;CityPO&gt; queryCity1_1(List&lt;Long&gt; paraList); // 2.1批量查询 } 1.2 在CityBatchMapper.xml中SQL代码
&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt; &lt;mapper namespace="com.hub.example.mapper.CityBatchMapper"&gt; &lt;!--1.1批量查询--&gt; &lt;select id="queryCity1_1" parameterType="java.util.ArrayList" resultType="com.hub.example.domain.CityPO"&gt; select CITY_ID AS "cityId", CITY_NAME AS "cityName", LAND_AREA AS "landArea", POPULATION AS "population", GROSS AS "gross", CITY_DESCRIBE AS "cityDescribe", DATA_YEAR AS "dataYear", UPDATE_TIME AS "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/45e44323c513bd9695ad5d91f7660cf0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a82cfc312d9f922cd33a216e202f0ad7/" rel="bookmark">
			软件测试 - 测试用例常见面试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.测试用例的要素 测试用例是为了实施测试而向被测试的系统提供的一组集合, 这组集合包含 : 测试环境, 操作步骤, 测试数据, 预期结果等要素. 例如 : 在 B 站输入框输入一个空格, 检查结果
测试用例
标题 : 输入框输入空格 测试环境 : Windows 系统, 谷歌浏览器-版本 111.0.5563.65（正式版本） （64 位） 操作步骤 : 1) 打开浏览器, 输入网址 : https://www.bilibili.com/ 2) 在输入框中输入关键词, 回车展示结果 测试数据 : 空格 预期结果 : 不展示任何内容 2. 设计测试用例的万能思路 2.1 设计测试用例的万能公式 功能测试 + 性能测试 + 界面测试 + 兼容性测试 + 易用性测试 + 安全测试
功能测试 : 对产品的功能设计测试用例. 性能测试 : 极端情况: 高并发量, 响应时间等等. (功能测试没用问题不代表性能测试好) 界面测试 : 每个元素的大小, 颜色, 材质, 形状, 页面跳转等都需要进行测试.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a82cfc312d9f922cd33a216e202f0ad7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/576aeb4650fd7521afbd2bdb0d99cabe/" rel="bookmark">
			漏洞篇（CSRF跨站请求伪造）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、CSRF 原理
1、CSRF 漏洞的定义
2、XSS 与 CSRF 的区别
3、CSRF 的简单理解
二、基于 DVWA 的 low 级别演示 CSRF 攻击 1、查看源代码
2、构造 URL 链接
3、验证 CSRF 攻击 4、构造恶意链接
5、短连接介绍
三、基于 DVWA 的 Medium 级别演示 CSRF 攻击
1、查看源代码
2、直接修改密码和通过其他页面提交请求的区别
3、绕过 Referer 过滤
四、使用 CSRFTester 进行自动化探测 CSRF 漏洞
1、探测的目的
2、自动化探测工具介绍
一、CSRF 原理 1、CSRF 漏洞的定义 CSRF（Cross-site request forgery，跨站请求伪造）也被称为 One Click Attack(单键攻击)或 者 Session Riding，通常缩写为 CSRF 或者 XSRF。 forgery [ ˈ f ɔː d ʒə ri] 伪造 ; Riding [ ˈ ra ɪ d ɪŋ ] 驾驭马匹;骑马 2、XSS 与 CSRF 的区别 1、XSS 利用用户对站点的信任，盗取 Cookie； 2、CSRF 通过伪装成受信任用户请求，利用站点对己经身份认证的信任，访问网站。 与 XSS 攻击相比，CSRF 攻击往往不大流行（因此对其进行防范的资源也相当稀少）和难以防范， 所以被认为比 XSS 更具危险性。 3、CSRF 的简单理解 假设用户已经保存某网站的登录信息，下次登录不需要认证，此时黑客构造一个访问该站点的链接并 添加如：修改密码、转账等操作的参数，用户点击链接后，黑客构造的参数被执行。这就是最简单的 CSRF 攻击方式。 CSRF 攻击流程图如下： 二、基于 DVWA 的 low 级别演示 CSRF 攻击 1、查看源代码 代码中没有任何的过滤。 参数直接传递到了$pass_new 和$pass_conf 中并带入数据库中执行。但 是带入数据库中执行时通过 mysql 的函数对 sql 语句进行了过滤，不过并不影响我们正常的修改密码操 作。 2、构造 URL 链接 我们将参数和完整的 URL 拼接起来。伪造一个改用户密码的请求链接，如下：http://192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/576aeb4650fd7521afbd2bdb0d99cabe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/057af4dab526cac1d350ecd23e080c76/" rel="bookmark">
			PHP代码审计 ------------CSRF漏洞
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		漏洞介绍 CSRF( Cross-site request forgery)跨站请求伪造，也有人写出XSRF。黑客伪造用户木匾用户的HTTP请求。然后将这个HTTP请求发送给存在CSRF的网站，有CSRF的网站执行了伪造的HTTP请求，就引发了跨站请求伪造
相对来说，比xss更具有危害性，
漏洞危害 攻击者盗用了你的身份信息，以你的名义发送恶意请求
以你名义发送邮件，发消息，盗取你的账号，甚至于购买商品虚拟货币转账等
造成的问题包括:个人隐私泄露以及财产安全
漏洞本质 攻击者获取到重要的参数，成功构造一个伪造请求
id=1000 是给转账的人 count=3 是金额 决大部分的人，网站上都会记住密码，那么这个操作，就会
攻击流程 挖掘思路 后台功能模块:管理后台、会员中心、添加用户等
被引用的核心文件里面有没有验证token和referer相关的代码
没带token: 可以直接请求这个页面
没带referer: 返回相同的数据
案例 目标要存在CSRF漏洞
受害者，需要保持目标站点的活跃状态
受害者需要点击钓鱼链接
这里我以pikachu靶场为例
GET CSRF 登录的正常状态，用bp抓包，
抓到 get 的提交参数， 可以看到有提交值， 也没有token也没有referer
给这个拿出来
加上对方的IP地址，去让对方 点击这个连接， 这时会修改成 11111111
这时已经修改完毕，
post方式 POST是请求体，不在url中，自己构建一个表单，
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;csrf_post&lt;/title&gt; &lt;script&gt; window.onload = function(){ document.getElementById("postsubmit").click(); } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;form action="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/057af4dab526cac1d350ecd23e080c76/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38b0bf9359a976cb6daa7f92e936a040/" rel="bookmark">
			IntelliJ IDEA创建Servlet（web）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
———————————————————————————————
一、创建Java项目
1、创建java项目
2、选择java
3、next
4、给项目命名
5、新创建完java项目的目录结构
二、变java为servlet项目
1、变servlet项目
2、选择Web Application
3、更新完成后的目录结构
4、在WEB-INF目录中新建“classes” “lib”两个文件夹，用于存放相关文件 5、将新建的文件夹 配置到项目中
6、将第四步两个目录，全部配置成刚才新建的classes下，然后配置完成
三、新建servlet项目，并导入所需要的包
1、创建servlet
2、导入servlet需要的支持包
3、在项目中导入包
四、配置Tomcat
1、配置Tomcat
也可参考 (1条消息) Intellij IDEA创建web项目 [超详细]_idea怎么创建web项目_heiqi_whf的博客-CSDN博客 (1条消息) idea创建一个javaweb项目_idea创建java web项目_熟悉的新风景的博客-CSDN博客
——————————————————————————————— 一、创建Java项目 1、创建java项目 2、选择java 3、next 4、给项目命名 5、新创建完java项目的目录结构 二、变java为servlet项目 1、变servlet项目 2、选择Web Application 3、更新完成后的目录结构 4、在WEB-INF目录中新建“classes” “lib”两个文件夹，用于存放相关文件 5、将新建的文件夹 配置到项目中 6、将第四步两个目录，全部配置成刚才新建的classes下，然后配置完成 三、新建servlet项目，并导入所需要的包 1、创建servlet （此时，extends后会出现错误，因为还没有将servlet包导入。后面也可以利用这一步，导入配置项目所需要的包）
2、导入servlet需要的支持包 （所需要的包，一般都在Tomcat根目录下的lib目录中）
3、在项目中导入包 四、配置Tomcat 1、配置Tomcat （有的需要自己修改配置一下，我的是直接自己就弄好的了）
（运行时，要注意URL的地址）
2、运行Tomcat（此时显示的index.jsp中的内容） 3、运行servlet
（第一种，直接在java中 加上Web注释，用以访问）
（第二种，在web.xml中进行配置）(注意，写完之后需要将Tomcat重新运行一下)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2295d102c6cd68143f7033cd01319073/" rel="bookmark">
			Android Studio 升级 Flamingo 后 Gradle 又挂了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.Gradle 7.2 才支持 Java 17 Unsupported Java.
Your build is currently configured to use Java 17.0.6 and Gradle 5.0.
Possible solution:
- Upgrade Gradle wrapper to 7.2 version and re-import the project
2.Android plugin 7.1 才支持 Gradle 7.2 Unable to find method ''org.gradle.api.file.DirectoryProperty org.gradle.api.file.ProjectLayout.directoryProperty(org.gradle.api.provider.Provider)''
'org.gradle.api.file.DirectoryProperty org.gradle.api.file.ProjectLayout.directoryProperty(org.gradle.api.provider.Provider)'
Gradle's dependency cache may be corrupt (this sometimes occurs after a network connection timeout.)
Re-download dependencies and sync project (requires network)
The state of a Gradle build process (daemon) may be corrupt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2295d102c6cd68143f7033cd01319073/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90e57704e55f75bd0b95e168bf503823/" rel="bookmark">
			【cmake篇】选择编译器及设置编译参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实际开发的过程中，可能有多个版本的编译器，不同功能可能需要设置不同的编译参数。
参考文章链接：选择编译器及设置编译器选项 目录
一、选择编译器
1、查看系统中已有的编译器
2、选择编译器的两种方式
二、设置编译参数
1、add_compile_options
2、通过设置CMAKE_CXX_FLAGS来配置
3、add_compile_options 与 CMAKE_CXX_FLAGS 配置的区别
一、选择编译器 1、查看系统中已有的编译器 既然是手动设置编译器，那么我们需要知道当前系统中有哪些编译器是允许我们使用的，gcc 和 g++ 编译器都放在了 /usr/bin 目录下。
查看gcc：
ls /usr/bin/gcc* 其中 gcc-5 表示的是 gcc 的 5.5 版本，gcc 则表示当前的默认版本 查看g++：
ls /usr/bin/g++* g++ 也是同理，g++ 表示的是 当前默认版本 2、选择编译器的两种方式 cmake 内置了编译器相关的变量来方便我们手动设置编译器，值得注意的是，C 编译器和 C++编译器的设置，使用的是不同的变量：
C 编译器：对应内置变量为 CMAKE_C_COMPILERC++ 编译器：对应内置变量为 CMAKE_CXX_COMPILERps 方式一：命令行设置
使用 cmake 编译时，用的是cmake命令，我们可以在cmake命令的后面携带附加选项l，来指定要使用哪个版本的编译器。
# 设置 C 编译器（如果不指定版本的话，使用的是 gcc 的默认版本） cmake .. -DCMAKE_C_COMPILER=/usr/bin/gcc # 设置 C++ 编译器 (指定的编译器为 g++9 ) cmake .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/90e57704e55f75bd0b95e168bf503823/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb8b53918ac28784c226dd5220abafcf/" rel="bookmark">
			编写程序，使用Linux操作系统中的信号量机制模拟实现生产者-消费者问题。设有一个生产者可以生产水果并放入缓冲区（最多只能放10个水果），有一个消费者，不断从缓冲区中取出水果，并吃掉水果。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;sys/ipc.h&gt; #include &lt;sys/sem.h&gt; #define MAX_FRUITS 10 struct semun { int val; struct semid_ds *buf; unsigned short *array; }; void sem_init(int semid, int sem_num, int val) { struct semun arg; arg.val = val; if (semctl(semid, sem_num, SETVAL, arg) == -1) { perror("semctl"); exit(1); } } void sem_wait(int semid, int sem_num) { struct sembuf sb; sb.sem_num = sem_num; sb.sem_op = -1; sb.sem_flg = SEM_UNDO; if (semop(semid, &amp;sb, 1) == -1) { perror("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb8b53918ac28784c226dd5220abafcf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9508cb7d335e400effc193bf260120d4/" rel="bookmark">
			人工智能大时代——AIGC综述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		生成式AI分类 模型按照输入输出的数据类型分类，目前主要包括9类。
有趣的是，在这些已发布大模型的背后，只有六个组织（OpenAI, Google, DeepMind, Meta, runway, Nvidia）参与部署了这些最先进的模型。
其主要原因是，为了能够估计这些模型的参数，必须拥有极其庞大的计算能力，以及在数据科学和数据工程方面高度熟练且经验丰富的团队。
因此，也只有这些公司，在收购的初创公司和与学术界合作的帮助下，能够成功部署生成式人工智能模型。
在大公司参与初创企业方面，可以看到微软向OpenAI投资了10亿美元，并帮助他们开发模型；同样，谷歌在2014年收购Deepmind。
在大学方面，VisualGPT是由阿卜杜拉国王科技大学（KAUST）、卡内基梅隆大学和南洋理工大学开发的，Human Motion Diffusion模型是由以色列特拉维夫大学开发的。
同样，其他项目也是由一家公司与一所大学合作开发的，比如Stable Diffusion由Runway、Stability AI和慕尼黑大学合作开发；Soundify由Runway和卡内基梅隆大学合作开发；DreamFusion由谷歌和加州大学伯克利分校合作。
Text-to-image模型 DALL-E 2 由OpenAI开发的DALL-E 2能够从由文本描述组成的提示中生成原始、真实、逼真的图像和艺术，而且OpenAI已经对外提供了API来访问该模型。
DALL-E 2特别之处在于它能够将概念、属性和不同风格结合起来，其能力源于语言-图像预训练模型CLIP神经网络，从而可以用自然语言来指示最相关的文本片段。
具体来说，CLIP embedding有几个理想的属性：能够对图像分布进行稳定的转换；具有强大的zero-shot能力；并且在微调后实现了最先进的结果。
为了获得一个完整的图像生成模型，CLIP图像embedding解码器模块与一个先验模型相结合，从一个给定的文本标题中生成相关CLIP图像embedding
其他的模型还包括Imagen，Stable Diffusion，Muse
Text-to-3D模型 对于某些行业，仅能生成2D图像还无法完成自动化，比如游戏领域就需要生成3D模型。
Dreamfusion DreamFusion由Google Research开发，使用预先训练好的2D文本到图像的扩散模型来进行文本到3D的合成。
Dreamfusion使用一个从二维扩散模型的蒸馏中得到的损失取代了CLIP技术，即扩散模型可以作为一个通用的连续优化问题中的损失来生成样本。
其他模型如Magic3D由英伟达公司开发。
Image-to-Text模型 获得一个描述图像的文本也是很有用的，相当于图像生成的逆版本。
Flamingo 该模型由Deepmind开发，在开放式的视觉语言任务上，只需通过一些输入/输出例子的提示，即可进行few-shot学习。
具体来说，Flamingo的输入包含视觉条件下的自回归文本生成模型，能够接收与图像或视频交错的文本token序列，并生成文本作为输出。
用户可以向模型输入query，并附上一张照片或一段视频，模型就会用文本答案来回答。
Flamingo模型利用了两个互补的模型：一个是分析视觉场景的视觉模型，一个是执行基本推理形式的大型语言模型。
VisualGPT VisualGPT是一个由OpenAI开发的图像描述模型，能够利用预训练语言模型GPT-2中的知识。
为了弥合不同模态之间的语义差距，研究人员设计了一个全新的编码器-解码器注意力机制，具有整流门控功能。
VisualGPT最大的优点是它不需要像其他图像到文本模型那样多的数据，能够提高图像描述模型的数据效率，能够在小众领域得到应用或对少见的物体的进行描述。
Text-to-Video模型 Phenaki 该模型由Google Research开发制作，可以在给定一连串文字提示的情况下，进行真实的视频合成。
Phenaki是第一个能够从开放域时间变量提示中生成视频的模型。
为了解决数据问题，研究人员在一个大型的图像-文本对数据集以及数量较少的视频-文本例子上进行联合训练，最终获得了超越视频数据集中的泛化能力。
主要是图像-文本数据集往往有数十亿的输入数据，而文本-视频数据集则小得多，并且对不同长度的视频进行计算也是一个难题。
Phenaki模型包含三个部分：C-ViViT编码器、训练Transformer和视频生成器。
将输入token转换为embedding后，接着经过时序Transformer和空间Transformer，再使用一个没有激活的单一线性投影，将token映射回像素空间。
最终模型可以生成以开放域提示为条件的时间连贯性和多样性的视频，甚至能够处理一些数据集中不存在的新概念。
相关模型包括Soundify.
Text-to-Audio模型 对于视频生成来说，声音也是必不可缺的部分。
AudioLM 该模型是由谷歌开发，可用于生成高质量的音频，并具有长距离一致性。
AudioLM的特别之处在于将输入的音频映射成一个离散的token序列，并将音频生成作为该表示空间的语言建模任务。
通过对原始音频波形的大型语料库进行训练，AudioLM成功学会了在简短的提示下生成自然和连贯的连续的语音。这种方法甚至可以扩展到人声之外的语音，比如连续的钢琴音乐等等，而不需要在训练时添加符号表示。
由于音频信号涉及多个尺度（scale）的抽象，所以音频合成时使得多尺度在显示一致性的同时实现高音频质量非常具有挑战性。AudioLM模型通过结合神经音频压缩、自监督表示学习和语言建模方面的最新进展来实现。
在主观评价方面，评分者被要求听一个10秒的样本，并决定它是人类讲话还是合成的语音。基于收集到的1000个评分，比率为51.2%，与随机分配标签没有统计学差异，即人类无法区分合成和真实的样本。
其他相关模型包括Jukebox和Whisper
Text-to-Text模型 问答任务常用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9508cb7d335e400effc193bf260120d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a463c43390736a2084c83e890f688425/" rel="bookmark">
			国产PIE-SAR软件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1.产品定位2. 软件架构3.支持的传感器类型4.基础处理5.区域网平差处理5.1技术流程5.2 异源匹配样例5.3 DOM成果 6.InSAR地形测绘7.DInSAR形变监测8.时序InSAR形变监测9.水体自动提取 1.产品定位 PIE-SAR是一款针对国内外主流星载SAR传感器的数据处理分析软件，提供图形化操作界面。目前已支持国内外主流星载SAR传感器的数据处理与分析，包括强度图像基础处理、区域网平差处理（含异源匹配、RD/RPC区域网平差）、InSAR地形测绘、时序InSAR形变监测和极化SAR分割分类处理等模块。目前软件涵盖的功能模块相对比较全，主要对标国外的ENVI SARSacpe，PCI GXL、GAMMA等。
2. 软件架构 PIE系列产品基于完全松耦合的底层架构设计，具有弹性可伸缩的体系结构，支持热插拔式负载均衡，支持功能模块可无缝扩展；底层平台采用高性能动态显示技术，以OpenGL作为地图渲染引擎，使用GPU渲染技术对大规模数据进行快速绘制和渲染，并采用混合多级缓存算法实现地图平滑显示，采用异步多线程技术实现流畅的人机交互。产品研发采用标准C++技术，完全自主可控代码，实现Windows、Linux以及国产操作系统的跨平台支持。产品界面层采用QT配置式多语言机制支持多语言版本。
3.支持的传感器类型 目前产品仅支持星载SAR数据，暂不支持机载SAR。支持的星载数据类型包括：ERS1/2、ENVISAT ASAR、ALOS-1 PALSAR、TerraSAR-X/TanDEM-X、COSMO-SkyMed、Radarsat-2、ALOS-2 PALSAR、GF-3、Sentinel-1A/B、TH-02A/B、TY38-C1、ICEYE-X2、HJ2E、LT-1A/B、C-SAR、HT-01等，可对这些数据进行基础处理及DOM产品生产，支持传统条带模式、 Sentinel-1 TOPS模式的数据进行干涉处理。软件也具备在拿到样例数据后，快速支持的能力。
4.基础处理 可实现将L1A级单视斜距复数（SLC）数据转换为地理编码后的L2级强度或幅度数据，满足普通用户对SAR数据的基本处理需求。
5.区域网平差处理 采用基于相位一致性的异源匹配技术，实现了光学与SAR影像间的自动匹配。以已有光学影像作为地理参考基准，通过多模态匹配技术，对SAR数据进行控制点匹配，并可直接获取匹配点高精度地理坐标或投影坐标，并将获取到的匹配点作为区域网平差控制点、连接点，无需人工参与选点，实现从数据准备、数据处理到DOM生成的全自动化流程处理。支持RPC通用模型、R-D严格成像模型平差解算。支持后续智能镶嵌、无缝拼接、标准分幅等。
5.1技术流程 5.2 异源匹配样例 下图为光学与SAR进行匹配的效果图：
5.3 DOM成果 广东省SAR区域网平差案例
6.InSAR地形测绘 支持对两景SAR影像（符合干涉条件）进行InSAR处理，获取DSM成果。
7.DInSAR形变监测 具体时间：2021年05月22号；
地震范围：中国青海玛多；
地震等级：7.4级；
震源深度：10千米；
数据类型：Sentinel-1；
干涉对：20210520 – 20210601。
8.时序InSAR形变监测 湖南耒阳矿区监测：
时间跨度：2019.01-2019.12
Sentinel-1哨兵IW SAR数据
影像数量：30景
分辨率：4*20米
监测结果显示该区域大部分矿区较稳定，少量矿区出现沉降，见图红色区域。
9.水体自动提取 对水体提取算法进行优化，解决大图像占用内存过大导致崩溃问题，支持输入超大尺度影像。利用广东全省GF-3号HV极化正射镶嵌图进行测试，尺寸85353*63444，20G左右，运行时长1小时左右。目视整体结果较好。
基于PIE产品的水体提取解决方案，支撑20余家用户，包括水利部、减灾部、各地高分中心等单位。为洪涝灾害水体提取快速提取，洪水涨势以及淹没情况的快速掌握，防汛抗洪工作的及时开展提供了必要、有效的技术支持。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/062982bab8cab48936ee21631ca6751e/" rel="bookmark">
			VLAN的基本概念和工作过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、基本概念
1、什么是vlan
2、广播域
3、VLAN划分机制
3.1 未划分vlan
3.2 划分vlan
二、VLAN Tag格式
三、access和trunk
1、access口
2、trunk口
四、拓展Hybrid
一、基本概念 1、什么是vlan vlan（Virtual LAN 虚拟局域网），一个局域网是由一个或多个计算机组成的网络，而vlan的作用就是可以将一个大的局域网划分为多个局域网，我们通常将这个大的局域网成为一个广播域，即vlan就是用来将一个广播域划分为多个不同的广播域的作用。
为什么不同VLAN间不通过路由就无法通信。是因为在LAN内的通信，必须在数据帧头中指定通信目标的MAC地址。而为了获取MAC地址，TCP/IP协议下使用的是ARP。ARP解析MAC地址的方法，则是通过广播。也就是说，如果广播报文无法到达，那么就无从解析MAC地址，所以也就无法直接通信了。
2、广播域 广播域是指一个广播帧（目的MAC全为1）在链路上直接传播的范围。二层交换机的所有接口是一个广播域，配置vlan之后可以划分成多个广播域。
3、VLAN划分机制 3.1 未划分vlan 如图，如果PC1只需要和PC3通信，根据数据二层通信而言，PC1需要知道PC3的MAC，所以PC1会发送ARP请求（目的MAC为全1广播包），请求PC3的MAC地址，因为没有划分vlan，交换机的所有接口都在同一个广播域中，所以图中所有的PC都会收到PC1请求PC3MAC地址的arp请求包。PC3收到后会回复ARP应答包给PC1，其他PC则丢弃该请求包。对于一个小的网络来说这点广播包不算什么，但是对于一个大的局域网来说，每个PC都发送arp请求或者其他的广播请求（DHCP、RIP网络环境等），这样不仅会浪费带宽资源，严重还会造成网络拥堵。
使用路由器也可以隔离广播域，但是通常来说路由器的接口是比较少的，交换机接口就很多，路由器更多的是用在网络中起到一个路由转发的作用。
3.2 划分vlan 在交换机上划分两个vlan，红色区域为vlan10 ，橙色区域为vlan20，此时PC1发送广播报文时只有红色区域的PC3可以收到，而PC2发送的广播报文也只有访问橙色区域的PC4可以收到，PC1和PC2处于同交换机的不同vlan，广播包不能转发。隔离的标准就是通过VLAN ID来进行识别的
因为不同广播域之间的连接需要使用路由器，那么要实现不同vlan之间的通信就需要用到路由，也就是通常说的vlan间路由
二、VLAN Tag格式 字段
长度
含义
Type
2Bytes
长度为2字节，表示帧的类型，值为0x8100表示为802.1q Tag帧。如果不支持802.1q的设备收到此帧，会直接丢弃
PRI
3bit
priority优先级，长度为3比特，表示帧的优先级，取值范围为0~7，值越大优先级越高，主要用于当端口阻塞时，优先发送优先级高的数据包，如果设置用户优先级，但是没有VLAN ID，则VLAN ID必须为0x000
CFI
1bit
Canonical Format Indicator规范的格式指示符，长度为1比特，表示MAC地址是否为经典格式，CFI为0表示标准格式，CFI为1表示非标准格式，在以太网中CFI为0。用于区分以太网帧、FDDI帧和令牌环网帧。
VID
12bit
VLAN ID表示该数据帧所属的VLAN编号，VLAN的取值范围为0~4095，其中0和4095为保留编号，所以VLAN ID的有效取值范围为1~4094
三种类型：
Untagged帧：VID 不计Priority-tagged帧：VID为 0x000VLAN-tagged帧：VID范围0～4095三个特殊的VID：
0x000：设置了优先级但无VID0x001：缺省VID0xFFF：预留VID 三、access和trunk PVID：端口(Port)的VLAN ID，交换机的所有端口都自带PVID属性，默认为1，可修改，以华为交换机为例，access口通过配置vlan来修改PVID（port default vlan 10），trunk口通过命令（port trunk pvid vlan 10）来修改，一般常规环境里，access口用于连接计算机，trunk口用于对接交换机。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/062982bab8cab48936ee21631ca6751e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3164aa694a7c4bf8baab9b835b003e2d/" rel="bookmark">
			js canvas绘制gif
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		效果大概这样
（图中用来播放的gif图来源于贴吧。如果你觉得侵权请私信我，我立刻下架）
canvas这个东西只能渲染静态图片，不能渲染动图。即便我们用常规的加载图片的办法去绘制gif。我们也只能绘制他的第一帧。不能动。所以想在 canvas 上渲染 gif，我们必须拿到 gif 的每一帧和每一帧播放的时间。于是我找到一个 gif 的控制的库 -- libgif.js （点击跳转）
观察他的element后发现他就是用 canvas 来进行播放 gif 的。不过他的用法是先得有一个 img元素 然后创建 SuperGif对象 来进行控制。这不是很符合我的需求。我是想要直接读取路径直接把 gif 在 canvas渲染出来。于是花了半天把源码看了下。然后把核心代码整了出来稍加修改。改为就读路径就渲染gif。
大概思路就是 xhr 请求文件 ---- 解析gif ---- 把每一帧的图像和播放时间存在 FRAME_LIST 里面。最后用 setInterval 来进行播放。 因为我们每一帧和播放时间都有了。所以 无论是播放、倍速、暂停、切换 上/下一帧都能轻松实现。我这里只给到播放，暂停之类的大家可以自己扩展。
直接用 loadGIF 方法就会自己加载且自动播放。
loadGIF("./example_gifs/fff.gif"); 播放方法是 playGif。调用 playGif 方法地方就是加载结束的地方。FRAME_LIST 这个全局变量就是存放当前gif所有帧的数组。扩展请在这些地方扩展。其他的地方你要动的话，请三思。毕竟我把源码拿过来后我自己也改了（欸嘿）。
下面是源码：（运行的时候注意，因为读本地文件肯定会存在跨域问题，直接跑铁不行。如要运行，请整为同源 ps：可以看上面效果图的url地址。例如你用vscode 跑的话，可以装一个 Live Server 这样的插件来运行总之方法很多。）
&lt;!DOCTYPE html&gt; &lt;html lang="zh"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;canvas id="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3164aa694a7c4bf8baab9b835b003e2d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56ebd39f08a9a6196237aeabd836a0ad/" rel="bookmark">
			Unity --- 枪类与子弹类的设计初探 与 Physics Material
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.类的设计方法 --- 首先将不同的对象相同的行为和方法做到一个类A中，然后再给每个对象各创建一个类，并且都继承大类A，同时在自己的类中创建自己独有的方法或者属性
1.一般子弹的射击都是用射线检测的方式去做的 --- 用碰撞器会出现我们不想要的物理效果，用触发器的话子弹速度过快会导致触发失效的问题
2.如果想让满足分部位造成不同伤害的话，就需要给被伤害对象的每个部位都套一个对应的碰撞器，某一个部位检测到碰撞了就让这个部位调用对应的碰撞方法造成不同的伤害。
3.给不同的部位加碰撞器也是有讲究的：
一个游戏模型是由不同部位的子物体组成的，当我们要添加碰撞器时，需要做的就是给这些代表不同部位的子物体再添加一个空子物体，这个空子物体中只有两个组件 ---Transfrom表示位置，以及Collider --- 最关键的碰撞器
这种做法就能够保证当代表不同部位的子物体运动起来时，作为这些子物体的子物体的“碰撞器”也会跟着一起运动。
4.一个类为子类，它里面有一个方法从返回类型，函数名到函数参数都与父类相同，此时通过子类中对象调用该方法，那么应该执行的是子类中该方法还是子类继承的父类方法呢？
答：会优先执行子类中该方法
5.public --- 大家都能调用，protected --- 自己和自己的子类能调用（父类不可以），private --- 只有自己能调用
1.目前我们掌握的获取游戏资源的方式有两招：
a.创建一个公开变量，然后将与变量类型相对应的游戏资源拖到Inepector界面处为对应公开变量生成的赋值框
b.上面这种方式需要人手动操作，很不方便，因此我们可以升级为通过代码来查找和载入游戏资源
2.Resource类中有一个方法 --- Load载入方法 --- 方尖框内放资源的类型，括号内传资源的路径 --- 目录1\目录2\...\资源名称（PS：还有一个前提还是资源必须放在Resource文件夹下，也正是因为这个规定，所以Resource不用写入目录中） --- 方法会返回我们想找的游戏资源对象，此时我们需要将其传给对应的引用，用引用来管理游戏资源（PS:此时只是找到了游戏资源！并没有在游戏场景中创建它）
3.如果想要在游戏场景中创建游戏资源的话还需要调用 ---- Instantiate()方法 --- 参数是我们要创建的游戏资源（必须是GameObject类）
1.资源路径示例 --- 如EffectsEnemy的资源路径是：ContactEffects\EffectsEnemy --- 由于资源一定要在Resource文件夹下，所以Resource不需要写入目录
介绍一下 --- 物理材质 --- Physics Metarial 1.创建了物理材质之后，会出现上面这么几个属性 --- 由上到下分别是：动态摩擦力，静态摩擦力，弹力，摩擦力合并，弹力合并。
2.这两个属性的取值的意思如下：（以Bounce Combine为例）
当两个物体相互接触时，物体受到的弹力 = Bounce Combine --- 若为Average则表示两个物体的弹力平均，Min就是选弹力最小的游戏物体，Multiply指受到的弹力等于二者的弹力相乘，Max则是受到的弹力是二者之间弹力的最大值
（Fiction Combine同理）
Physics Material 物理材质属性位于Coliider碰撞器组件处 1.由于用触发器作判定会比较消耗性能，我们一般不会随便用触发器来作判定，适用的场景一般有：a.触发范围的图形比较难用代码来形容（不好用距离来进行判定），此时直接用触发器做个触发范围图形，直接用判定就可以了
（PS：通常用来代替触发器判定的是两个游戏物体之间的距离判定）
1.this.transform.forward获取的是一个向量 --- 这个向量是位于世界坐标系的 ，向量的方向与游戏物体自身坐标系的Z轴正反向一致，向量的起点为世界坐标系的原点，向量的大小为1
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/56ebd39f08a9a6196237aeabd836a0ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b54318b27f71e4a18bb58790c46b1d59/" rel="bookmark">
			Mybatis的批量查询，批量更新
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		批量查询操作 0. 前言 忽略controller、service、repository等逻辑层代码。
1. mapper层定义查询方法 注@Param参数是绑定xml里面的collection参数
List&lt;TestDTO&gt; queryByIds(@Param("idList") List&lt;Long&gt; idList); 2. xml文件中写SQL语句 &lt;select id="queryByIds" resultType="TestDTO"&gt; select * from test_table &lt;where&gt; &lt;if test="idList != null and idList.size() &gt; 0"&gt; id in &lt;foreach collection="idList" index="index" item="item" open="(" separator="," close=")"&gt; #{item} &lt;/foreach&gt; &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; 批量更新操作 0. 前言 假设项目已经连接好数据库，定义好了实体类 且实体类名为MybatisDTO;
id主键address地址 实现需求为通过id批量更新地址信息。
Class MybatisDTO{ Integer id; String address; } 1. Controller层 @ApiOperation("批量更新") @PutMapping(value = "/batchUpdate") public ResponseEntity batchUpdate(@PathVariable("organizationId") Long tenantId, String defaultAddress, @RequestBody List&lt;MybatisDTO&gt; mybatisDTOS){ mybatisService.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b54318b27f71e4a18bb58790c46b1d59/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/151/">«</a>
	<span class="pagination__item pagination__item--current">152/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/153/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>