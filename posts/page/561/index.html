<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0078a36305e6e27a830b17e8caed8804/" rel="bookmark">
			zlib库剖析（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文整理自zlib.net以及zlib 1.2.7的手册页http://zlib.net/manual.html。 zlib是一套免费、通用、法律上不受限制的无损数据压缩库，可以在任何硬件及操作系统上使用。zlib数据格式可以跨平台移植。不像Unix compress(1)和GIF图像格式中使用的LZW压缩方法，当前zlib中使用的压缩算法不会扩充数据（LZW在极端情况下能使文件大小变为原来2 倍或3倍）。zlib的内存印迹也独立于输入数据，并且在压缩时能够被减小。zlib由Jean-loup Gailly与Mark Adler所开发，初版0.9版在1995年5月1日发表。zlib使用抽象化的DEFLATE算法，最初是为libpng函数库所写的，后来普遍为许多软件所使用。此函数库为自由软件，使用zlib授权。 zlib授权是一个自由软件授权协议，但并非copyleft。协议原文在http://www.gzip.org/zlib /zlib_license.html。最新版本为1.2.2，2004年10月3日发布。版权持有人为Jean-loup Gailly和Mark Adler(1995-2004)，类似于BSD许可。任何人都可以使用本软件，用于任何目的，包括闭源的商业应用。源码的修改和重新分发都是自由的，除了必须注明来源，并在发布的软件中保留此授权协议副本。 1、当前版本 #define ZLIB_VERSION "1.2.7" #define ZLIB_VERNUM 0x1270 2、功能特性 zlib压缩库提供内存内压缩/解压缩函数。包括对解压数据完整性检查。这个版本只支持一种压缩方式（deflation），但是以后其他的算法也会被加入进来，并且保持同样的流接口。如果缓存区足够大，压缩被一次完成（例如输入文件被mmap了），否则就重复调用压缩。在后一种情况，程序必须在每次调用时提供更多的输入或更多输出空间。 本压缩库使用的默认压缩数据格式为zlib格式（在RFC 1950中描述），它是对deflate流（在RFC 1951中描述）的一种封装。本压缩库也支持对gzip（.gz）格式文件的读写操作，操作接口以"gz"开头，和stdio相似。gzip格式与 zlib格式不同，在RFC 1952中描述，是对deflate流的另一种封装。 本压缩库不安装任何信号处理器，解码器检查压缩数据的一致性，所以，即使在有损坏的输入情况下，本压缩库也不会崩溃。 （1）数据头 zlib能使用gzip数据头（header）、zlib数据头或者不使用数据头压缩数据。通常情况下，数据压缩使用zlib数据头，因为这提供错误数据检测。当数据不使用数据头写入时，结果是没有任何错误检测的原始DEFLATE数据，那么解压缩软件的调用者知道压缩数据在什么地方结束。 gzip数据头比zlib数据头要大，因为它保存了文件名和其他文件系统信息，事实上这是广泛使用的gzip文件的数据头格式。注意zlib函式库本身不能创建一个gzip文件，但是它能够相当轻松的通过把压缩数据写入到一个有gzip文件头的文件中。 （2）算法 目前zlib仅支持一个LZ77的变种算法，即DEFLATE的算法。这个算法使用很少的系统资源，对各种数据提供很好的压缩效果。这也是在ZIP档案中无一例外的使用这个算法。（尽管zip文件格式也支持几种其他的算法）。看起来zlib格式将不会被扩展使用任何其他算法，尽管数据头可以有这种可能性。 （3）使用资源 函式库提供了对处理器和内存使用控制的能力。不同的压缩级别数值可以指示不同的压缩执行速度。还有内存控制管理的功能。这在一些诸如嵌入式系统这样内存有限制的环境中是有用的。 （4）策略 压缩可以针对特定类型的数据进行优化。若使用者总是使用zlib压缩特定类型的数据，那么可以使用有针对性的策略可以提高压缩效率和性能。例如，如果使用者的数据包含很长的重复数据，那么可以用RLE（运行长度编码）策略，可能会有更好的结果。对于一般的数据，默认的策略是首选。 （5）错误处理 错误可以被发现和跳过，数据混乱可以被检测（只要数据和zlib或者gzip数据头一起被写入）。此外，如果全刷新点（full-flush points）被写入到压缩后的数据流中，那么错误数据是可以被跳过的，并且解压缩将重新同步到下个全刷新点（错误数据的无错恢复被提供）。全刷新点技术对于在不可靠的通道上的大数据流是很有用的，一些过去的数据丢失是不重要的（例如多媒体数据），但是建立太多的全刷新点会极大的影响速度和压缩。 （6）数据长度 对于压缩和解压缩，没有数据长度的限制。重复调用库函数允许处理无限的数据块。一些辅助代码（计数变量）可能会溢出，但是不影响实际的压缩和解压缩。当压缩一个长（无限）数据流时，最好写入全刷新点。 （7）使用zlib的软件 今天，zlib是一种事实上的业界标准，以至于在标准文档中，zlib和DEFLATE常常互换使用。数以千计的应用程序直接或间接依靠zlib压缩函式库（参考http://zlib.net/apps.html），包括： Linux核心：使用zlib以实作网络协定的压缩、档案系统的压缩以及开机时解压缩自身的核心。 libpng，用于PNG图形格式的一个实现，对bitmap数据规定了DEFLATE作为流压缩方法。 Apache：使用zlib实作http 1.1。 OpenSSH、OpenSSL：以zlib达到最佳化加密网络传输。 FFmpeg：以zlib读写Matroska等以DEFLATE算法压缩的多媒体串流格式。 rsync：以zlib最佳化远端同步时的传输。 Subversion 、Git和 CVS等版本控制系统：使用zlib来压缩和远端仓库的通讯流量。 dpkg和RPM等包管理软件：以zlib解压缩RPM或者其他封包。 另外，zlib被用在很多其他的编程语言中。在Java中可通过java.utl.zip使用zlib库；Python中通过import zlib使用zlib库；Perl的zlib接口可在CPAN找到；Tcl的zlib接口参看http://wiki.tcl.tk/4610。因为其代码的可移植性，宽松的授权许可以及较小的内存占用，zlib在许多嵌入式设备中也有应用。 3、流数据结构
[cpp] view plain copy typedef voidpf (*alloc_func) OF((voidpf opaque, uInt items, uInt size)); typedef void (*free_func) OF((voidpf opaque, voidpf address)); struct internal_state; typedef struct z_stream_s { z_const Bytef *next_in; /* 下一个输入字节 */ uInt avail_in; /* next_in中可用的字节数 */ uLong total_in; /* 目前读取的输入总字节数 */ Bytef *next_out; /* 下一个输出字节应该放在这 */ uInt avail_out; /* next_out中剩下的可用空间 */ uLong total_out; /* 目前输出的总字节数 */ z_const char *msg; /* 最后的错误消息，如果没错误为NULL */ struct internal_state FAR *state; /* 对应用程序不可见 */ alloc_func zalloc; /* 用来分配内部状态 */ free_func zfree; /* 用来释放内部状态 */ voidpf opaque; /* 传给zalloc和zfree的私有数据对象 */ int data_type; /* 数据类型的最好猜测：二进制数据或文本 */ uLong adler; /* 解压数据的adler32值 */ uLong reserved; /* 保留为将来使用 */ } z_stream; typedef z_stream FAR *z_streamp; /* 来自或传给zlib例程的gzip头部信息，对这些字段的含义，参考RFC 1952 */ typedef struct gz_header_s { int text; /* 为true，如果压缩数据被认为是文本 */ uLong time; /* 修改时间 */ int xflags; /* 额外标志（写gzip文件时不会用到） */ int os; /* 操作系统 */ Bytef *extra; /* 指向额外的字段，如果没有则为Z_NULL */ uInt extra_len; /* 额外字段的长度（如果extrextra !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0078a36305e6e27a830b17e8caed8804/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f08263140ad1df945c09a152b2ccf982/" rel="bookmark">
			eclipse报错： permission is only granted to system apps
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于eclipse报错：permission is only granted to system apps
安卓项目中，需要修改androidmanifest.xml文件里的uses-permission，添加了以下的代码
&lt;uses-permission android:name="android.permission.HARDWARE_TEST"/&gt;
&lt;uses-permission android:name="android.permission.INSTALL_PACKAGES"/&gt;
&lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" /&gt;
android.permission.HARDWARE_TEST 这个是允许访问硬件。
android.permission.INSTALL_PACKAGES 允许程序安装应用
android.permission.WRITE_EXTERNAL_STORAGE 这个是设置内置sd卡的写权限
可是，修改后eclipse马上来个报错说是 permission is only granted to system apps 。这时候，千万别被迷惑了，这个报错的解决方法是在eclipse的菜单依次点击project-&gt;clean，然后可以了。
这是一个神奇的clean啊，它是将所有的以前编译信息清除，以便我们后面再重新run编译。
我们发现经常修改AndroidManifest.xml的时候，它都会会惊动警惕的编译器报错。
怎么办？只好再次 clean咯。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06c3ee04a78a403d3ce98ba7c8ad7b0f/" rel="bookmark">
			error: SSL certificate problem, verify that the CA cert is OK
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		error: SSL certificate problem, verify that the CA cert is OK. Details:
error:14090086:SSL routines:SSL3_GET_SERVER_CERTIFICATE:certificate verify failed while accessing https://github.com****
解决办法 git config --global http.sslVerify false
转载于:https://www.cnblogs.com/ganmianzhang/p/3785643.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1f91d7dce4601dc372937282c2f265a/" rel="bookmark">
			网络加密的三种方式及比较
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		﻿﻿ 网络数据加密三种方式：
链路加密：又称在线加密，是对在两个网络节点间的某一条通信链路实施加密，是目前网络安全系统中主要采用的方式。
节点对节点加密：在链路加密的基础上，在中间节点装有加密解密保护装置，使节点对节点也加密。
端对端加密：又称脱线加密或包加密，数据在源结点被加密后，到终点的传输过程中始终以密文形式存在。
三种加密方式的比较：
链路加密只对通信链路中的数据加密，而不对网络节点的数据加密；节点对节点加密不允许消息在网络节点中以明文形式存在，它与链路加密有共同弱点：需要公共网络提供者的配合，修改公共网络的交换节点，增加安全单元或保护装置；端对端加密，只有消息到达目的地后才被解密，缺点是不能掩盖消息的源节点和目的节点，不能防止***。
转载于:https://blog.51cto.com/sydugu/1553394
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29c8b8aa3903298e9317e29fa4feffd5/" rel="bookmark">
			无法在服务器上访问指定的路径或文件，请确保您具有必需的安全权限且该路径或文件存在。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天将数据库转移到另外一条服务器上。被迫分离了数据库，转移完后，屁颠屁颠的准备附加回去。。。
结果，瞬间尿了~~~~
于是乎，各种加权限，甚至给了everyone最高权限。%&gt;_&lt;%
但是还是不行。
解决方案：
选择自己的数据库实例，然后将内置账号换成local system，中文名曰 本地账号。解决
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc6f484482bbc928e4b21c6b2832591d/" rel="bookmark">
			以引用对象取代单例模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍： 系统中存在单例的全局访问点，你希望将对单例的访问通过对象引用来实现。往往是将对单例的依赖关系转换为关联关系。 动机： 在系统中引入单例模式往往并没有起到明显的效果却增加了系统的复杂性。不能仅仅因为某个类只需要一个实例而采用单例模式，这些完全可以用引用对象取代。 通过全局访问点使用单例对象往往造成依赖不清、可读性差等问题，我们完全可以通过显式的关联引用来做到在子系统中共享同一个实例，并且只对需要这个实例的对象注入依赖。将对全局变量的依赖转变为对成员对象的依赖使类更易于理解。 当设计需要中不需要强调系统的任何时刻都只需要同一实例的时候，单例模式最大的缺点在于没有优点。单例模式并不是常用的设计模式。 重构: 1. 修改单例类，将构造函数设为public，取消访问方法和相关属性。
2. 查找类的所有引用点，添加对单例类的引用字段并将全局访问改为对引用对象的请求。 3. 修改相关类的构造函数，将引用对象作为参数传递进来。 4. 查找相关类的引用点，增加构造函数的调用参数。 范例： 假设有这样一个类：它封装了输入，外观层修改类的状态，并使具体类可以不同步地访问此类。这样的封装降低了外观类与具体类的耦合。 由于输入类只需要一个实例，可以采用单例模式实现这种设计（不考虑线程安全）： /// &lt;summary&gt; /// 封装用户输入 /// &lt;/summary&gt; public class Input { private Input() { } /// &lt;summary&gt; /// 用户输入实例 /// &lt;/summary&gt; private static Input _instance; /// &lt;summary&gt; /// 获取封装用户输入的唯一实例 /// &lt;/summary&gt; public static Input Instance { get { if (_instance == null) { _instance = new Input(); } return _instance; } } /// &lt;summary&gt; /// 绑定到窗体 /// &lt;/summary&gt; /// &lt;param name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc6f484482bbc928e4b21c6b2832591d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bb1b666318e2494958f201f707763a3/" rel="bookmark">
			关于毛刺
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于毛刺 http://blog.csdn.net/guqian110/article/details/17304065 目录(?)[+]
1. 毛刺的产生原因：冒险和竞争 使用分立元件设计电路时，由于PCB在走线时，存在分布电容和电容，所以在几ns内毛刺被自然滤除，而在PLD内部没有分布电感和电容，所以在PLD/FPGA设计中，竞争和冒险问题比较重要。
信号在FPGA器件内部通过连线和逻辑单元时，都有一定的延时。延时的大小与连线的长短和逻辑单元的数目有关，同时还受器件的制造工艺、工作电压、温度等条件的影响。信号的高低电平转换也需要一定的过渡时间。由于存在这两方面因素，多路信号的电平值发生变化时，在信号变化的瞬间，组合逻辑的输出有先后顺序，并不是同时变化,往往会出现一些不正确的尖峰信号，这些尖峰信号称为"毛刺"。如果一个组合逻辑电路中有"毛刺"出现，就说明该电路存在"冒险"。
可以概括的讲，只要输入信号同时变化，（经过内部走线）组合逻辑必将产生毛刺。 将它们的输出直接连接到时钟输入端、清零或置位端口的设计方法是错误的，这可能会导致严重的后果。 所以我们必须检查设计中所有时钟、清零和置位等对毛刺敏感的输入端口，确保输入不会含有任何毛刺。
存在逻辑冒险的电路：
仿真波形：
2. 判断是否存在冒险 关于冒险的知识，数电书上有详细的说明，当时没有认真学，只了解个大概，现在又要重新看...还记得当年画卡诺图时的痛苦
冒险按照产生方式分为静态冒险 &amp; 动态冒险两大类。静态冒险指输入有变化，而输出不应该变化时产生的窄脉冲；动态冒险指输入变化时，输出也应该变化时产生的冒险。动态冒险是由静态冒险引起的，所以，存在动态冒险的电路也存在静态冒险。
静态冒险根据产生条件不同，分为功能冒险和逻辑冒险两种。当有两个或两个以上的输入信号同时变化时，在输出端有毛刺，称为功能冒险；如果只有一个输入变量变化时，出现的冒险称为逻辑冒险。
因为动态冒险是由静态冒险引起的，所以消除了静态冒险，也就消除了动态冒险。功能冒险是由电路的逻辑功能产生的，只要输入信号不是按照循环码的方式变化，就会产生功能冒险，而且不能通过修改设计来消除，只能通过对输出进行采样来消除。判断逻辑冒险的步骤：
判断信号是否会同时变化判断信号同时变化时，是否会发生冒险（代数法 or 卡诺图） 3. 消除毛刺 我们可以通过改变设计，破坏毛刺产生的条件，来减少毛刺的发生。例如，在数字电路设计中，常常采用格雷码计数器取代普通的二进制计数器，这是因为格雷码计数器的输出每次只有一位跳变，消除了竞争冒险的发生条件，避免了毛刺的产生。
毛刺并不是对所有的输入都有危害，例如D触发器的D输入端，只要毛刺不出现在时钟的上升沿并且满足数据的建立和保持时间，就不会对系统造成危害，我们可以说D触发器的D输入端对毛刺不敏感。 根据这个特性，我们应当在系统中尽可能采用同步电路，这是因为同步电路信号的变化都发生在时钟沿，只要毛刺不出现在时钟的沿口并且不满足数据的建立和保持时间，就不会对系统造成危害。 （由于毛刺很短，多为几纳秒，基本上都不可能满足数据的建立和保持时间）
以上方法可以大大减少毛刺，但它并不能完全消除毛刺，有时，我们必须手工修改电路来去除毛刺。一般有两种方法：
脉冲选择法 一般说来，冒险出现在信号发生电平转换的时刻，也就是说在输出信号的建立时间内会发生冒险，而在输出信号的保持时间内是不会有毛刺信号出现的。如果在输出信号的保持时间内对其进行"采样"，就可以消除毛刺信号的影响。缺点是必须人为的保证sample信号必须在合适的时间中产生
时序逻辑保持法 利用D触发器的D输入端对毛刺信号不敏感的特点，在输出信号的保持时间内，用触发器读取组合逻辑的输出信号，这种方法类似于将异步电路转化为同步电路。
4. 具体信号的讨论 1. 置位/复位信号 清除和置位信号要求象对待时钟那样小心地考虑它们，因为这些信号对毛刺也是非常敏感的。正如使用时钟那样，最好的清除和置位是从器件的引脚单直接地驱动。有一个主复位Reset引脚是常用的最好方法，主复位引脚给设计项目中每个触发器馈送清除或置位信号。几乎所有PLD器件都有专门的全局清零脚和全局置位。如果必须从器件内产生清除或置位信号，则要按照“门控时钟”的设计原则去建立这些信号，确保输入无毛刺。
2. 组合逻辑输出 当PLD输出引脚给出系统内其它部分的边沿敏感信号或电平敏感信号时，这些出信号必须象内部时钟、清除和置位信号一样小心地对待。只要可能就应在PLD输出端寄存那些对险象敏感的组合输出。如果你不能寄存险象敏感的输出，则应符合“门控时钟”中讨论的门控时钟的条件。决不能用多级逻辑驱动毛刺敏感的输出。
3. 异步输入信号 按照定义，异步输入不是总能满足(它们所馈送的触发器的)建立和保持时间的要求。因此，异步输入常常会把错误的数据锁存到触发器，或者使触发器进入亚稳定的状态,在该状态下，触发器的输出不能识别为l或0。如果没有正确地处理，亚稳性会导致严重的系统可靠性问题。
采用附加触发器同步使能信号的方法可保证不违反计数器的建立时间，从而解决可靠性的问题。
参考资料：
1. 《Verilog+HDL程序设计与实践》 云创工作室
2. 关于毛刺问题的探讨
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a9d27290d0ad873c15d79807289b07a/" rel="bookmark">
			Linux中locale 详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		locale 是国际化与本土化过程中的一个非常重要的概念，个人认为，对于中文用户 来说，通常会涉及到的国际化或者本土化，大致包含三个方面：看中文，写中文，与 window中文系统的兼容和通信。从实际经验上看来，locale的设 定与看中文关系不大，但是与写中文，及window分区的挂载方式有很密切的关系。本人认为就像一个纯英文的Windows能够浏览中文，日文或者意大利 文网页一样，你不需要设定locale就可以看中文。那么，为什么要设定 locale呢？什么时候会用到locale呢？ Tags: locale 设定 原因 解释 一、为什么要设定locale 正如前面我所讲的，设定locale与你能否浏览中文的网页没有直接的关系，即便你把locale设置成 en_US.ISO-8859-1这样一个标准的英文locale你照样可以浏览中文的网页，只要你的系统里面有相应的字符集（这个都不一定需要）和合适 的字体（如simsun），浏览器就可以把网页翻译成中文给你看。具体的过程是网络把网页传送到你的机器上之后，浏览器会判断相应的编码的字符集，根据网 页采用的字符集，去字体库里面找合适的字体，然后由文字渲染工具把相应的文字在屏幕上显示出来。 在下文本人会偶尔把字符集比喻成密码本，个人觉得对于一些东西比较容易理解，假如你不习惯的话，把全文copy到任何文本编辑器，用字符集替换密码本即可。 那有时候网页显示乱码或者都是方框是怎么回事呢？个人认为，显示乱码是因为设定的字符集不对(或者没有相应的字符集)，例如网页是用UTF-8编 码的，你非要用GB2312去看，而系统根据GB2312去找字体，然后在屏幕上显示，当然是一堆的乱码，也就是说你用一个错误的密码本去翻译发给你的电 报，当然内容那叫一个乱；至于有些时候浏览的网页能显示一部分汉字，但有很多的地方是方框，能够显示汉字说明浏览器已经正确的判断出了网页的编码，并在字 体库里面找到了相应的文字，但是并不是每个字体库都包含某个字符集全部的字体的缘故，有些时候会显示不完全，找一个比较全的支持较多字符集的字体就可以 了。 既然我能够浏览中文网页，那为什么我还要设定locale呢？ 其实你有没有想过这么一个问题，为什么gentoo官方论坛上中文论坛的网页是用UTF-8编码的（虽然大家一直强烈建议用GB2312编码）， 但是新浪网就是用GB2312编码的呢？而Xorg的官方网页竟然是ISO-8859-15编码的，我没有设定这个locale怎么一样的能浏览呢？这个 问题就像是你有所有的密码本，不论某个网站是用什么字符集编码的，你都可以用你手里的密码本把他们翻译过来，但问题是虽然你能浏览中文网页，但是在整个操 作系统里面流动的还是英文字符。所以，就像你能听懂英语，也能听懂中文。 最根本的问题是：你不可以写中文。 当你决定要写什么东西的时候，首先要决定的一件事情是用那种语言，对于计算机来说就是你要是用哪一种字符集，你就必须告诉你的linux系统，你 想用那一本密码本去写你想要写的东西。知道为什么需要用GB2312字符集去浏览新浪了吧，因为新浪的网页是用GB2312写的。 为了让你的Linux能够输入中文，就需要把系统的locale设定成中文的(严格说来是locale中的语言类别LC_CTYPE )，例如 zh_CN.GB2312、zh_CN.GB18030或者zh_CN.UTF-8。很多人都不明白这些古里古怪的表达方式。这个外星表达式规定了什么东 西呢？这个问题稍后详述，现在只需要知道，这是locale的表达方式就可以了。 二、到底什么是locale？ locale这个单词中文翻译成地区或者地域，其实这个单词包含的意义要宽泛很多。Locale是根据计算机用户所使用的语言，所在国家或者地区，以及当地的文化传统所定义的一个软件运行时的语言环境。 这个用户环境可以按照所涉及到的文化传统的各个方面分成几个大类，通常包括用户所使用的语言符号及其分类(LC_CTYPE)，数 字 (LC_NUMERIC)，比较和排序习惯(LC_COLLATE)，时间显示格式(LC_TIME)，货币单位(LC_MONETARY)，信息主 要是提示信息,错误信息, 状态信息, 标题, 标签, 按钮和菜单等(LC_MESSAGES)，姓名书写方式(LC_NAME)，地址书写方式 (LC_ADDRESS)，电话号码书写方式 (LC_TELEPHONE)，度量衡表达方式(LC_MEASUREMENT)，默认纸张尺寸大小 (LC_PAPER)和locale对自身包含信息的概述(LC_IDENTIFICATION)。 所以说，locale就是某一个地域内的人们的语言习惯和文化传统和生活习惯。一个地区的locale就是根据这几大类的习惯定义的，这些 locale定义文件放在/usr/share/i18n/locales目录下面，例如en_US, zh_CN and de_DE@euro都是 locale的定义文件，这些文件都是用文本格式书写的，你可以用写字板打开，看看里边的内容，当然出了有限的注释以外，大部分东西可能你都看不懂，因为 是用的Unicode的字符索引方式。 对于de_DE@euro的一点说明，@后边是修正项，也就是说你可以看到两个德国的locale： /usr/share/i18n /locales/de_DE@euro /usr/share/i18n/locales/de_DE 打开这两个locale定义，你就会知道它们的 差别在于de_DE@euro使用的是欧洲的排序、比较和缩进习惯，而de_DE用的是德国的标准习惯。 上面我们说到了zh_CN.GB18030的前半部分，后半部分是什么呢？大部分Linux用户都知道是系统采用的字符集。 三、什么是字符集？ 字符集就是字符，尤其是非英语字符在系统内的编码方式，也就是通常所说的内码，所有的字符集都放在/usr/share /i18n/charmaps，所有的字符集也都是用Unicode编号索引的。Unicode用统一的编号来索引目前已知的全部的符号。而字符集则是这 些符号的编码方式，或者说是在网络传输，计算机内部通信的时候，对于不同字符的表达方式，Unicode是一个静态的概念，字符集是一个动态的概念，是每 一个字符传递或传输的具体形式。就像 Unicode编号U59D0是代表姐姐的“姐”字，但是具体的这个字是用两个字节表示，三个字节，还是四个字节表 示，是字符集的问题。例如：UTF-8字符集就是目前流行的对字符的编码方式，UTF-8用一个字节表示常用的拉丁字母，用两个字节表示常用的符号，包括 常用的中文字符，用三个表示不常用的字符，用四个字节表示其他的古灵精怪的字符。而GB2312字符集就是用两个字节表示所有的字符。需要提到一点的是 Unicode除了用编号索引全部字符以外，本身是用四个字节存储全部字符，这一点在谈到挂载windows分区的时候是非常重要的一个概念。所以说你也 可以把Unicode看作是一种字符集（我不知道它和UTF-32的关系，反正UTF-32就是用四个字节表示所有的字符的），但是这样表述符号是非常浪 费资源的，因为在计算机世界绝大部分时候用到的是一个字节就可以搞定的 26个字母而已。所以才会有UTF-8，UTF-16等等，要不然大同世界多好， 省了这许多麻烦。 四、zh_CN.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a9d27290d0ad873c15d79807289b07a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e2739a80215134de59f7479accd70a8/" rel="bookmark">
			ffmpeg转码器移植VC的工程：ffmpeg for MFC
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文介绍一个自己做的FFMPEG移植到VC下的开源工程：ffmpeg for MFC。本工程将ffmpeg工程中的ffmpeg转码器（ffmpeg.c）移植到了VC环境下。并且使用MFC做了一套简单的界面。它可以完成一个视频转码的基本功能：封装格式以及编码格式的转换。通过本程序可以学习视频转码器的原理，以及Windows的消息机制等知识。
平台：VC2010
类库：FFmpeg，MFC
目前正在完善中，先不上传到CSDN下载了。在SourceForge上建立了一个项目。
项目主页
SourceForge：https://sourceforge.net/projects/ffmpegformfc/
Github：https://github.com/leixiaohua1020/ffmpegmfc
开源中国：http://git.oschina.net/leixiaohua1020/ffmpeg-for-MFC
更新记录==============================
1.1版（2014.7.12）
* 更换了部分界面
* 原工程支持Unicode编码
* 修复了一部分内存泄露的问题
* 修正了ffmpeg.c中的exit_program()函数。保证在转码结束后可以释放资源。 * 修正了一部分“任务列表”的功能
* 修正了添加任务的时候“要用按钮去选输入文件，不能自己直接输入”的问题。
1.2版（2014.8.16）
*增加了“内部转码”和“外部转码”选项。“内部转码”即通过原先移植的ffmpeg.c进行转码。“外部转码”支持作为一个GUI直接调用ffmpeg.exe进行转码。通过管道的方式读取转码进度。
发现SourceForge速度很慢，有的时候几乎访问不了，因此还是打算在CSDN上上传了一下源代码和编译后的可执行程序。结果昨天传了一晚上竟然没有传上去。。。每次上传完在自己资源列表里面都看不到，很是郁闷。结果今天早上起来猛然发现资源列表里面竟然有2份。。。这个延迟有点大啊，不过好歹传上去了。
源代码：http://download.csdn.net/detail/leixiaohua1020/7764529
编译好的可执行程序：http://download.csdn.net/detail/leixiaohua1020/7766245
PUDN源代码：http://www.pudn.com/downloads644/sourcecode/multimedia/detail2605161.html
一.主界面 程序的主界面如图所示。主界面中包含一个任务列表，其中包含了需要转码的任务。下方是转码的控制按钮，并且包含了转码的进度信息。
1.1.任务列表 任务列表包含了需要转码的任务。列表的上方包含了4个按钮，包含了对任务列表的4种操作：添加，编辑，删除，清空。此外，在任务列表中选择一个任务然后单击右键，也可以在右键菜单中选择这4项操作。这4项操作如下：
添加：新增加一个任务。
编辑：修改现有的一个任务。
删除：删除一个任务。
清空：删除所有的任务。
列表显示了任务的信息。包含：序号，输入，大小，输出，状态。含义如下：
序号：编号。
输入：输入文件名称。
大小：输入文件大小。
输出：输出文件名称。
状态：该任务所处的状态（准备，处理中，已完成）。
1.2.控制按钮 控制按钮完成了对转码过程的控制功能。包含：开始，暂停，停止。
开始：系统开始转码。
暂停：系统暂停转码。
停止：系统停止转码。
二.任务信息窗口 任务信息窗口用于配置一条任务信息。其中包含了三个部分：输入和输出，输入文件信息，输出配置。
2.1.输入和输出 输入和输出部分用于指定该任务的输入文件和输出文件。输入文件即准备进行转码的文件，输出文件即转码后生成的文件。可以直接在输入框中输入文件路径，也可以单击输入框右侧的“文件”按钮选择文件。此外还可以直接将文件拖拽至对话框的方式选择输入文件。
选择输入文件后，程序会检查输入文件的格式信息。如果输入文件不是视音频文件，程序会报出错误信息。如果输入文件为视音频文件，程序会检测该文件的参数信息，包括封装格式，视频编码，音频编码等信息。并将检测结果显示在“输入文件信息”部分。
为了方便起见，选择输入文件后，程序会在输入文件的目录下生成名为“{输入文件名称}_ffmfc.mkv”的输出文件。可以对该输出文件路径和名称进行更改。
2.2.输入文件信息 包含：封装格式，视频比特率，时长，输出像素格式，视频编码方式，帧率，画面大小，采样率，音频编码方式，声道数。
2.3.输出配置 封装格式
输入封装格式：强制指定输入文件的格式。默认情况下ffmpeg是通过输入文件的后缀判断文件格式的。如果指定了这个选项，则按照该指定的格式对文件进行解析。
输出封装格式：强制指定输出文件的格式。默认情况下ffmpeg是通过输出文件的后缀判断文件格式的。如果指定了这个选项，则按照该指定的格式对文件进行转码。
视频
比特率：视频的码率，默认800kbps。
编码器：视频编码使用的编码器。
帧率：视频编码使用的帧率，默认25fps。
音频
比特率：音频的码率，默认64kbps。
编码器：音频编码使用的编码器。
采样率：音频的采样率，默认44100Hz。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e2739a80215134de59f7479accd70a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14d1cf86c92e171d429a980018113f9b/" rel="bookmark">
			Tanimoto相似度与Bregman距离
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前写过一篇距离与相似性度量的blog，这里添加两个少见的相似性度量方法，并且再扩展一些东西。
之前的blog： http://blog.csdn.net/ice110956/article/details/14143991
Tanimoto 系数 Tanimoto系数由Jaccard系数扩展而来。首先引入Jaccard系数。
Jaccard系数 两个特征向量A,B，如果其值都是0,1的二值数据，那么有一个简单的判定相似性的方法：
F00 = A中为0并且B中也为0的个数
F10 = A1 B0的个数
F01 = A0 B1的个数
F11 = A1 B1 的个数
那么可以定义这么一个similarity：
这叫做（simplematch coefficient）SMC，简单匹配系数。
很多情况下，两个向量中，0的个数会大大多于1的个数，也就很稀疏，类不平衡。这时候不同向量之间的SMC会因为过多出现的0而没有效果。
那么我们可以只考虑F11，得到：
这也就是Jaccard距离。
如果把两个向量看作两个集合，0为此元素不存在，1为此元素存在，那么Jaccard距离就是很好地比较两个集合相似性的度量方法。在集合的相似度计算中，Jaccard距离可以写成：
扩张Jaccard 如果这个时候，还是很稀疏，但是值是非二值的，该怎么办？
一种简单的方法就是用cosine距离：
cosine距离是处理稀疏非二值特征的很好的选择。
但是，我们还想以Jaccard距离的思维来做又要如何？如下：
如果我们的x,y都是二值向量，那么如上公式就会得到Jaccard距离。
分子项，只有两个均非0才会有非0的有用结果，类似于F11，不过这里不是简单的计数，而是用数乘来表示。
分母项，2范数表示大小，也只有非0的项才有贡献，再减去xy即共同的，这个类似
以上是通过观察得出的结论，具体推导不知。
SMC距离在一般的非不平衡二值问题上计算应该比较方便。
Jaccard在文本分类等不平衡二值问题上有所作为
Tanimoto的话，没用过，效果不知道有没有cosine好。应该会得到一个类似cosine的结果。
Bregman 散度距离 （BregmanDivergence）
形式如下：
其中为某个凸函数，表示函数对y求导，&lt;&gt;表示点乘。
我们把y=x^2作为，得到：
即得到欧式距离。
Bregman距离的数学性质及推导不知，wiki上说，其为许多常见距离的一个通式。
wiki http://en.wikipedia.org/wiki/Bregman_divergence
其中包括欧式距离，曼哈顿距离，KL距离等等。水平有限，只能引用到此。
mahalanobis距离 马氏距离：
首先考虑欧式距离，欧式距离有两点明显的缺点：
1.把不同量纲级别的属性同等看待
比如一个特征向量包含人的年龄，收入，那么收入得到的点乘会远远大于年龄，使得年龄没有作用。
一般的做法是归一化属性值。
2.属性间相关性
一个人的体重很多时候正比于身高。如果作为特征中的两个属性，就会重复计算这个值，得到冗余信息。
一种做法是做去相关，降维，特征选择等等。
不同与欧式距离，马氏距离考虑了量纲即属性间相关性。如下：
M(x,y)=(x-y)sigm(x-y)T
其中sigm表示整体特征向量的协方差矩阵。
马氏距离的最大缺点就是计算复杂度要高出很多，具体运用时要考虑这个因素。
补充 补充之前距离没写到的一些信息：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/14d1cf86c92e171d429a980018113f9b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45a57900875d916bb3dbad94176b5149/" rel="bookmark">
			打印机服务出现问题的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、
一般启动不了的话，可以使用
net start spooler
来启动，看看有没有报错；
二、
1.在开始工具栏点运行再输入services.msc或者双击C:\WINDOWS\system32\services.msc打开服务管理器，找到Print Spooler这个服务并停止。 2.找到“C:\WINDOWS\system32\spool\PRINTERS”这个档夹，看它下面是否有档存在，如果有全部删除。再重新启动Print Spooler 这个服务。问题应该可以解决。 3.如果还不行，下载最新的杀毒软件进安全模式全盘杀毒。
三、
1、在安装光盘（I386)里找到spoolsv.ex_使用expand.exe这个命令展开得到spoolsv.exe这个文件
具体的展开命令是：在doc命令提示符下expand spoolsv.ex_ spoolsv.exe(为了方便可以把spoolsv.ex_复制到c盘根目录下
2、把spoolsv.exe复制到C:\WINDOWS\system32\下，再启动Print Spooler这个服务。 OK这时问题应该解决了；
上次遇到过一个奇葩的，就是杀软把spoolsv.exe干掉了，然后你去看服务，打印的服务也没了，于是就把spoolsv.exe放到C:\Windows\System32后，手动注册服务
sc create spooler binpath= c:\windows\system32\spoolsv.exe displayname= "print spooler" 这样你再到服务里面就能看到打印服务了，然后再将其设为自动启动，并且启动服务，就解决了！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6832676e00a326947dd284ed5bedc14/" rel="bookmark">
			latex 如何输入 双斜杠 单斜杠
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		字体大小的双斜杠：$ \verb|\\|$
比较大一号的双斜杠：$\backslash\backslash$
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74935964e6855017c93a4bf85d61c505/" rel="bookmark">
			ffplay播放器移植VC的工程：ffplay for MFC
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文介绍一个自己做的FFPLAY移植到VC下的开源工程：ffplayfor MFC。本工程将ffmpeg项目中的ffplay播放器（ffplay.c）移植到了VC的环境下。并且使用MFC做了一套简单的界面。它可以完成一个播放器播放视频的基本流程：解协议，解封装，视频/音频解码，视音频同步，视音频输出。此外还包含一些控制功能：播放，暂停/继续，前进，后退，停止，逐帧播放，全屏等；以及一些简单的视频码流分析功能：视频解码分析和音频解码分析。通过本程序可以学习视频播放器原理，以及SDL和Windows消息机制。
平台：VC2010
类库：FFmpeg，MFC
项目主页
SourceForge：https://sourceforge.net/projects/ffplayformfc/
Github：https://github.com/leixiaohua1020/ffplaymfc
开源中国：http://git.oschina.net/leixiaohua1020/ffplay-for-MFC
CSDN项目下载
ffplay for MFC 1.0.0(stable)——本版本采用FFmpeg的2012年的类库，稳定
http://download.csdn.net/detail/leixiaohua1020/7452437
ffplay for MFC 1.0.1——本版本采用FFmpeg的2014年5月的类库，支持HEVC和VP9，Debug下稳定，Release下目前还有问题。
http://download.csdn.net/detail/leixiaohua1020/7452493
注：Release下的问题已经得到网友建议并且解决。解决方法如下：
VC工程属性里，linker-&gt;Optimization-&gt;References 选项，改成No(/OPT:NOREF)。
注：以上两个项目由于失误，少了一个SDL.dll文件，去SDL官网
http://www.libsdl.org/download-1.2.php
下载一个Runtime Libraries即可
补充：
该项目原代码简介可以参考：ffplay for mfc 代码备忘 更新记录==============================
1.1版（2014.7.10）
* 更换了部分界面
* 原工程支持Unicode编码
* 修复了Release下的Bug
* 添加了两个宏定义"INT64_MIN INT64_MAX"，在没有安装 Win7SDK的情况下，可能会出现找不到定义的情况。
CSDN上又上传了一份：http://download.csdn.net/detail/leixiaohua1020/7764509
PUDN上也传了一份： http://www.pudn.com/downloads644/sourcecode/multimedia/detail2605167.html 一. 主界面 程序的主界面如图所示。最上方是输入的URL。中间是视频的参数列表。下方是视频的控制按钮。
1.1输入URL 输入URL框用于输入视频的URL。视频源可以是本地视频或者是网络流。单击输入框右侧的“文件”按钮可以方便地选择本地的文件并获取他们的URL（在这里是路径信息）。此外，也可以将本地视频文件直接拖拽到对话框中，也可以获取到该视频的URL。
1.2参数列表 封装格式参数
输入类型：输入视音频采用的传输协议。举例：RTP，FILE（文件），HTTP，RTMP。
封装格式：视音频采用的封装格式。举例：AVI，FLV，MKV，RMVB。
比特率：视音频的码率。举例1Mbps。
时长：视音频的时间长度。
MetaData：视音频元数据信息。
视频参数
输出像素格式：解码后像素数据格式。举例：YUV420P，RGB24，UYVY。
编码方式：视频采用的压缩编码标准。举例：H.264，MPEG2。
帧率：每秒钟视频画面数。举例：25fps。
画面大小：画面的分辨率。举例：1920x1080，720x576。
解码分析：以列表的形式显示每个视频帧的详细信息。
音频参数
采样率：每秒钟采样点个数。举例：44.1kHz，48kHz。
编码方式：音频采用的压缩编码标准。举例：AAC，MP3，WMA。
声道数：声道数量。
解码分析：以列表的形式显示每个音频帧的详细信息。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/74935964e6855017c93a4bf85d61c505/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71ade3c7c8b1a58c01971d9e5af7e0ea/" rel="bookmark">
			Supervised Learning和Unsupervised Learning的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Supervised Learning 和Unsupervised Learning的区别主要在于给定的输入是否打了标签，是否是有结果的。
Supervised Learning的输入一般是有给定的正确结果，比如预测股票价格的时候，我们是已经有以往的时间对应的价格。
Unsupervised Learning的输入更多的是未知的结果，比如新闻分类，我有一堆新闻，我也不知道它们该分哪些类，我就根据不同文章的相关性，然后把他们分类聚合，打上相应的类别标签。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9bb42496acd6a89d160328ce3bd9a211/" rel="bookmark">
			《编译原理》笔记一之编译程序概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 编译程序概述 学习编译原理之前，先给大家推荐一些比较经典的书目吧，呵呵，天影楼主（以后就用这名了~）觉得这些书还是很不错的，对于编译原理各位如果只看一两本书的话，个人觉得还是会很有局限。好了，话不多说，下面直接列书单： 《编译原理(清华版)》+《编译原理及实践》+《编译原理:原则,技术和工具》+《现代编译原理-C语言描述》+《高级编译器设计与实现》+《龙书》 看完这些书的话基本上要有一个宏观的对于编译器的结构以及各组成部分比较清晰的了解还是不成问题的~ 好了，话不多说，进入正题吧。在学习编译原理之初，天影还是觉得应该先从编译原理的概述开始谈起，下面是天影结合各本书籍写出来的关于本章的列表，先给出列表，这样大家看起来也会先有一个总体的印象一些^_^： 1.1 语言的分类 1.2 编译程序与解释程序 1.3 编译器的功能分解和组织结构 1.4 编译程序的复杂性 1.5 编译程序的设计实现 1.6 编译程序的测试与维护 有了这六节，天影觉得可以对编译程序有一个很基本的了解了，在后面的章节中再具体一个细节一个细节地详细介绍： 1.1 语言的分类： 学了很多年的语言，可能很多同学对于语言的分类都还没有很清晰的了解吧，天影觉得，既然是学习编译原理，对于语言的分类还是得有一个比较清晰的图像的，首先，毋庸置疑，大家都知道计算机语言分为高级语言和低级语言，可是要再细分呢，可能就不知道了吧，呵呵，大致的说来，【 低级语言 = 机器语言 + 汇编语言 】，【 高级语言 = 过程式语言 + 函数式语言 + 逻辑式语言 + 对象式语言 】，下面给一张图： 机器语言就是我们知道的0、1代码；而汇编语言则是介于机器语言和高级语言之间的一种语言，它是和硬件有关的这样一个系统，它与高级语言在编译过程中生成目标代码有直接的关系，天影觉得学习汇编语言主要遇到的困难是因为它一定程度受到了硬件环境的影响，所以学起来相对于其它的高级语言会比较吃力一些。 过程式语言：像Fortran、Basic、C、Cobol、Pacal等，它需要用户了解功能是如何实现的。 函数式语言：像Lisp、ML、ASL，在人工智能上一般会用到这些语言，其它地方倒是用的不多。 逻辑式语言：像Prolog，它是在软件工程上用于测试的一种语言。 对象式语言：像C++、Java、Smalltalk，它与过程式语言的主要区别在于它要把要描述的东西看成一个一个的对象，再把对象上的所以操作封装在一起，如Smalltalk是一门纯粹的从内核开始往外都是面向对象的，它是最正宗的面向对象的语言，对于C++，它是在C语言上的一个改进，所以不能说是完完全全纯粹的面向对象的。 对于各种语言的分类有了一个大致的了解，可是这还是不够的，因为并没有弄清楚各种语言程序之间的关系，下面天影为大家再准备一张图，大家看过之后对于各种语言之间的关系自然也就一目了然了，希望对大家能够有所帮助，呵呵~ 看到这里是不是又有一点晕了呢，各种语言程序不放一起还好，这一下子放一起了还真不好区分了，呵呵，下面天影就为大家一一讲解这些语言程序： 汇编语言程序：它与汇编程序只相差两个字，看上去似乎差不多，如果不放在一起的话说不定还真的没有注意到要去区分它们。其实，如果告诉大家汇编语言程序的另外一个名字——汇编语言源程序的话，大家可能就理解多了，呵呵，顾名思义，汇编语言程序是用汇编语言编写的，根据我们前面对语言的分类不难知道它是一种计算机低级语言程序，在经过汇编、连接之后即可得到我们熟悉的exe文件（可执行程序）。 汇编程序：讲解完了汇编语言程序，那么汇编程序又是什么呢，汇编程序是一种把汇编语言书写的程序翻译成为与之等价的机器语言的翻译程序，它输入的是用汇编语言编写的源程序，输出的则是用机器语言表示的目标程序，就这么讲解可能很难懂，结合上面天影给出的图的话会清晰得多的，呵呵。 机器语言程序：前面解释了什么是汇编语言程序，现在大家理解起来机器语言程序应该不难了吧，就是用机器语言表示的目标程序。 高级语言程序：即用高级语言编写的源程序。 编译程序：这里，天影提醒大家要注意的是编译程序与汇编程序的区别，编译程序是把用高级语言编写的源程序翻译成与之等价的用机器语言书写的目标语言的翻译程序，而我们前面说到过的汇编程序是将汇编语言编写的源程序翻译成为等价的用机器语言表示的目标程序。也就是说汇编程序输入的是用汇编语言编写的源程序，输出的是用机器语言表示的目标程序；而编译程序输入的是用高级语言编写的源程序，输出的是用机器语言书写的目标程序，二者之间的区别大家一定要注意区分。 源程序：说源程序之前天影想先说一下什么是源语言，既然叫做源语言，顾名思义，肯定是可以导出另一种语言的，因此，我们可以将源语言理解为可以导出另一种语言的语言，所以，源程序可以是高级语言写的也可以是汇编语言写的。接下来，就来说说什么是源程序，既然是程序，还是“源”的，那么说明它经过“处理机”处理之后会变成别的东西，这个处理机就是编译器，因此，源程序就是指经过编译器编译或解释后生成的具有一定功能的文件或组件或接口，当然，既然是程序，它也就得符合一定的语法，这个不用多说。 目标程序：说完源程序之后再说目标程序想必大家就容易理解多了，目标程序就是由编译程序将源程序翻译成为的等价的由机器码构成的计算机能够直接运行的程序。 下面谈谈机器语言、汇编语言、高级语言这三种语言之间的联系和区别。首先，大家必须明白，计算机所能识别的语言只有机器语言，通俗的来说就是由0和1构成的代码，那么汇编语言与机器语言有什么区别呢，它们二者都是直接对硬件进行操作，这是它们之间的共性，不同之处只在于汇编语言的指令采用了英文缩写的标识符来方便记忆和识别罢了，它们也都需要操作者用命令的形式将每一步的具体操作写出来，而每一个指令对应的又往往只是实际操作中一个很微小的动作，可想而知，用它们写出来的程序势必也就很冗长很复杂而且容易出错了。而高级语言呢，它相对于汇编语言对于机器语言的改进的基础上进一步做了改进，不止是用个简单的名字来替代令人头晕目眩的0、1代码，更是将许多相关的机器指令合成为单条指令，再去掉一下与具体操作有关而与完成工作无关的细节啊，自然也就大大简化了程序的指令，编程者入门的门槛也就更低了，这也就是为什么天影之前说汇编语言学习起来相对于高级语言会更加难一些，但是汇编语言也具备高级语言没有的一些优点，根据前面的分析我们知道高级语言将许多相关的机器指令合成为了单条指令，这也就意味着汇编语言所完成的操作不是一般的高级语言所能实现的，同时，我们可以想想，我们看到的源程序经过汇编之后得到的可执行文件是不是一般也比较小呢，而且执行起来速度很快吧。高级语言相对汇编语言来说的话，已经不仅仅是指某一种语言了，它囊括了很多语言例如我们熟悉的C、C++、Java等等，这些语言的命令格式、语法也是不一样的，我们前面提到过，计算机能识别的只有机器语言，因此高级语言是无法被直接识别的，既然不能被直接识别，那么就只有通过转换，接下来天影就按照转换方式的两类——解释类、编译类，来为大家引入下一节。 1.2 编译程序与解释程序（Compiler and Interpreter）： 先来解释一下编译程序和解释程序是什么~ 编译程序：把高级语言书写的源程序翻译成等价的目标程序的程序。 解释程序：它不会形成目标程序，将源程序作为输入，解释一句后就提交计算机就执行一句。 在这里，天影将会对三种语言处理程序做一个对比，帮助大家理解、记忆，呵呵~ 汇编程序、编译程序、解释程序作为三种语言处理程序，稍不注意，就很容易弄混，下面天影一一解释。汇编程序是将用汇编语言书写的源程序翻译成为由机器语言表示的目标程序；编译程序是用高级语言书写的源程序翻译成为机器语言表示的目标程序；解释程序是直接执行源程序，即读一句源程序，翻译一句，执行一句，不产生目标代码。因此，可以看出汇编程序与编译程序的区别在于输入的待翻译的源程序的书写语言不同；而编译程序与解释程序的区别在于编译程序产生目标代码而解释程序不产生目标代码，一个是读一句，翻译一句，执行一句，而另一个是读好了再翻译好了再执行，可想而知，在执行速度上编译程序肯定是要比解释程序快的，为了执行速度，因此一般的高级语言编写的程序都是编译执行的，不过从另外一个角度来考虑，解释程序的人机交互性会好一些。 下面，还是上图： 编译程序： 有一个概念可能大家都没怎么注意过，那就是我们用过的一些如sin、cos这些子程序是什么呢，是怎么编写的呢，这里向大家介绍一个概念——运行系统子程序：它是协助目标程序工作的一些用机器语言编制好的程序。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba82b8c77be0caa15056b73615e996b7/" rel="bookmark">
			数据结构大作业代写
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【题目】
Given a set of files, of which the sizes will not exceed 10 Gigabytes, find out whether an input string appears or not.
Your program is judged based on correctness and searching time.
Your program is allowed some preparation time no longer than one hour.
【具体要求】
1、题目及示例：
给定几个目标字符串和一系列文件，判断每个字符串分别在哪些文件中出现过。
给定的文件格式如下：
target.txt：需要寻找的字符串
N （需要寻找的字符串个数）
目标字符串，每个字符串一行
filename.txt：需要搜索的文件的文件名
M （文件个数）
各个文件名，所有文件名都是“数字.txt”的格式，而且都是按1、2、3、4的顺序排列的
文件名.txt：需要被搜索的文件，每个里面都是一个很长的字符序列
字符序列
结果写入到output.txt中
分成N行写，N是需要寻找的字符串个数。
第k行写出第k个字符串所在的文件名，文件名按从小到大排列，不用写.txt，文件名之间用空格隔开
例如：
target.txt
2
abc
\5a
filename.txt
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba82b8c77be0caa15056b73615e996b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3202c1fa1d6d6f4f55128704eb7f1118/" rel="bookmark">
			java.lang.NoClassDefFoundError: com/fasterxml/jackson/core/JsonProcessingException
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		When I run junit test, encountered this error:　java.lang.NoClassDefFoundError: com/fasterxml/jackson/core/JsonProcessingException
Solution: add the following dependencies:
&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.1.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.1.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;2.1.0&lt;/version&gt; &lt;/dependency&gt; Reference:
1. http://stackoverflow.com/questions/14333709/spring-mvc-3-2-and-json-objectmapper-issue
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7959d206e870c0c0cfcba1c791ef6899/" rel="bookmark">
			warning:  #223-D: function &#34;assert_param&#34; declared implicitly
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		硬件平台:STM32F205
一点一点跟踪，发现大部分的头文件都包含在stm32f10x_conf.h中，而这个文件又出现在stm32f10x.h中，其中有这样的一段：
#ifdef USE_STDPERIPH_DRIVER #include "stm32f10x_conf.h" #endif 原来是这个USE_STDPERIPH_DRIVER没有被定义，stm32f10x_conf.h 头文件不能被编译进工程，导致的报错。
从网上搜索发现解决办法，
MDK的在工程上点右键，选择options，选择C/C++选项，在defined的框里填上USE_STDPERIPH_DRIVER就可以了。
在那个define中加入“USE_STDPERIPH_DRIVER”
如下图所示
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09cd1b55e8bc61616d5821b8f414d2c9/" rel="bookmark">
			PostgreSQL 中 index scan 与 seq scan 的对比学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据量很小的时候，我们可以看到，seq scan 比 index scan 更加有效。那是因为 index scan 至少要发生两次I/O，一次是 读取索引块， 一次是读取数据块。当index 很大的时候，情况可能会更加复杂。 postgres=# select a.relpages, a.reltuples, a.relfilenode,a.reltype,b.typname from pg_class a, pg_type b where a.relname like 'gaotab%' and a.reltype=b.oid; relpages | reltuples | relfilenode | reltype | typname ----------+-----------+-------------+---------+--------- 1 | 100 | 16396 | 16386 | gaotab 数据量为 100条记录。
预估成本：
postgres=# set session enable_seqscan=false; SET postgres=# explain select name from gaotab where id=50; QUERY PLAN --------------------------------------------------------------------- Index Scan using idx_id on gaotab (cost=0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/09cd1b55e8bc61616d5821b8f414d2c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0c13e0536788353e707e9f06fdb7276/" rel="bookmark">
			【Ant学习】 使用ant打包android项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在这里推荐两篇文章，然后附上一个android工程(含build.xml)。这样可以很直观的应用。
关于ant的一些基本用法,我还得系统的学习,先开个头,以后再写。
http://www.cnblogs.com/liuyue0802/p/3349931.html#commentform
http://blog.csdn.net/wwhh393/article/details/8698373
源码下载
http://download.csdn.net/detail/yigelangmandeshiren/7406601
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9fcb12a6a400ef6dd366159ed240e69b/" rel="bookmark">
			OC基础教程——笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第三章 面向对象编程基础知识
3.1 间接
变量 文件名
3.2 在OOP中使用间接
过程式编程：函数是过程式编程的核心，你决定使用什么函数，然后调用那些函数，传递其需要的数据。过程式程序建立在函数之上，数据为函数服务。
面向对象编程：以程序的数据为中心，函数为数据服务。
面向对象的术语：P34
私有方法说明：P38
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eed518d97b5ac4b9772a70e7f60e842f/" rel="bookmark">
			authz-db = authz 引起的 svn 认证失败
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在svnserve.conf:文件中去掉authz-db = authz前面的#号，会出现的认证失败。 造成此原因的主要问题就是authz文件中权限没有配置好。 例如： 创建prj1库 svnadmin create prj1 修改配置文件
svnserve.conf: [general] anon-access = read auth-access = write password-db = passwd authz-db = authz
passwd [users] tom = tom authz: [groups] project_1 = tom [prj1:/] @project_1 = rw 访问 svn://192.168.1.105/prj1 则会出现认证失败 原因是： svn://192.168.1.105/prj1 访问时找不到tom对应的库，就是因为[prj1:/]不是一个有效的库路径 把 [prj1:/]改为[/]既可以了，[/]代表根目录下所有的资源，如果要限定资源，可以加上子目录即可。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c517b69910713e0c73b4fa2b1d188be4/" rel="bookmark">
			【OpenCV入门教程之十四】OpenCV霍夫变换：霍夫线变换，霍夫圆变换合辑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本系列文章由@浅墨_毛星云 出品，转载请注明出处。 文章链接： http://blog.csdn.net/poem_qianmo/article/details/26977557
作者：毛星云（浅墨） 微博：http://weibo.com/u/1723155442
知乎：http://www.zhihu.com/people/mao-xing-yun
邮箱： happylifemxy@163.com
写作当前博文时配套使用的OpenCV版本： 2.4.9
本篇文章中，我们一起探讨了OpenCV中霍夫变换相关的知识点，以及了解了OpenCV中实现霍夫线变换的HoughLines、HoughLinesP函数的使用方法，实现霍夫圆变换的HoughCircles函数的使用方法。此博文一共有四个配套的简短的示例程序，其详细注释过的代码都在文中贴出，且文章最后提供了综合示例程序的下载。
先尝鲜一下其中一个示例程序的运行截图：
一、引言 在图像处理和计算机视觉领域中，如何从当前的图像中提取所需要的特征信息是图像识别的关键所在。在许多应用场合中需要快速准确地检测出直线或者圆。其中一种非常有效的解决问题的方法是霍夫（Hough）变换，其为图像处理中从图像中识别几何形状的基本方法之一，应用很广泛，也有很多改进算法。最基本的霍夫变换是从黑白图像中检测直线(线段)。这篇文章就将介绍OpenCV中霍夫变换的使用方法和相关知识。
二、霍夫变换概述 霍夫变换(Hough Transform)是图像处理中的一种特征提取技术，该过程在一个参数空间中通过计算累计结果的局部最大值得到一个符合该特定形状的集合作为霍夫变换结果。
霍夫变换于1962年由PaulHough首次提出，最初的Hough变换是设计用来检测直线和曲线，起初的方法要求知道物体边界线的解析方程，但不需要有关区域位置的先验知识。这种方法的一个突出优点是分割结果的Robustness,即对数据的不完全或噪声不是非常敏感。然而，要获得描述边界的解析表达常常是不可能的。　后于1972年由Richard Duda &amp; Peter Hart推广使用，经典霍夫变换用来检测图像中的直线，后来霍夫变换扩展到任意形状物体的识别，多为圆和椭圆。霍夫变换运用两个坐标空间之间的变换将在一个空间中具有相同形状的曲线或直线映射到另一个坐标空间的一个点上形成峰值，从而把检测任意形状的问题转化为统计峰值问题。
霍夫变换在OpenCV中分为霍夫线变换和霍夫圆变换两种，我们下面将分别进行介绍。
三、霍夫线变换 3.1 OpenCV中的霍夫线变换 我们知道，霍夫线变换是一种用来寻找直线的方法. 在使用霍夫线变换之前, 首先要对图像进行边缘检测的处理，也即霍夫线变换的直接输入只能是边缘二值图像.
OpenCV支持三种不同的霍夫线变换，它们分别是：标准霍夫变换(Standard Hough Transform，SHT)和多尺度霍夫变换（Multi-Scale Hough Transform，MSHT）累计概率霍夫变换(Progressive Probabilistic Hough Transform ，PPHT)。
其中，多尺度霍夫变换（MSHT）为经典霍夫变换（SHT）在多尺度下的一个变种。累计概率霍夫变换(PPHT）算法是标准霍夫变换（SHT）算法的一个改进，它在一定的范围内进行霍夫变换，计算单独线段的方向以及范围，从而减少计算量，缩短计算时间。之所以称PPHT为“概率”的，是因为并不将累加器平面内的所有可能的点累加，而只是累加其中的一部分，该想法是如果峰值如果足够高，只用一小部分时间去寻找它就够了。这样猜想的话，可以实质性地减少计算时间。
在OpenCV中，我们可以用HoughLines函数来调用标准霍夫变换SHT和多尺度霍夫变换MSHT。
而HoughLinesP函数用于调用累计概率霍夫变换PPHT。累计概率霍夫变换执行效率很高，所有相比于HoughLines函数，我们更倾向于使用HoughLinesP函数。
总结一下，OpenCV中的霍夫线变换有如下三种：
&lt;1&gt;标准霍夫变换（StandardHough Transform，SHT），由HoughLines函数调用。
&lt;2&gt;多尺度霍夫变换（Multi-ScaleHough Transform，MSHT），由HoughLines函数调用。
&lt;3&gt;累计概率霍夫变换（ProgressiveProbabilistic Hough Transform，PPHT），由HoughLinesP函数调用。
3.2 霍夫线变换的原理 【1】众所周知, 一条直线在图像二维空间可由两个变量表示. 如:
&lt;1&gt;在笛卡尔坐标系: 可由参数: 斜率和截距(m,b) 表示。
&lt;2&gt;在极坐标系: 可由参数: 极径和极角表示。
对于霍夫变换, 我们将采用第二种方式极坐标系来表示直线. 因此, 直线的表达式可为:
化简便可得到: 【2】一般来说对于点, 我们可以将通过这个点的一族直线统一定义为:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c517b69910713e0c73b4fa2b1d188be4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc7cea9851f24a8398c57d05e57efbc3/" rel="bookmark">
			【图文】Latex 中文字体的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用CTex自带编辑器WinEdt，在该环境下如何使用中文字体呢？作为一个菜鸟，折腾了好几天，最终基本解决了这个问题。现在整理下，分享给后来者。
对于使用中文字体，网上的很多教程是CCT、CJK和TY，不过，CCT已经不建议使用，而CJK、TY这些都已经过时了。而且这些方案中使用的中文字体就那么几种，想使用更多的字体，要单独去安装字体，无法直接调用系统安装的字体，这样无疑会很麻烦。最终网上找到的成熟方案是：XeLaTeX。
一、首先，从头讲起，基于LaTeX2对于字体的调用方式：
{\字体名称 正文内容} 使用CTex宏包调用的实例： 1.新建文件，键入下面代码
\documentclass{article} \usepackage{ctex} \begin{document} 中文宏包测试 \par % "\par"表示回车换号 {\songti 这是宋体的样式} \par {\heiti 这是黑体的样式} \par {\fangsong 这是仿宋的样式} \par {\kaishu 这是楷书的样式} \par %{\lishu 这是隶书的样式} \par %CTeX的手册中是支持隶书和幼圆的， %{\youyuan 这是幼圆的样式} \par %但是不知是何原因编译有问题 \end{document} 2.点击保存，这里这里保存类型建议以后一直选择“UTF-8” 注意；保存类型建议以后一直选择“UTF-8”，因为一方面xeCJK格式的汉字字体将无法显示，另一方面， GBK 编码是 ctex 宏包的缺省模式,使用 XeTEX 引擎的情况下总是内部使用 UTF-8 编码，所以不必使用这个选项，但这并不妨碍编写 GBK 编码的文档。
3.选择XeLaTeX编译方式，点击查看
4.效果如下图：
二、基于XeLaTeX的中文字体的使用
XeLaTeX可以直接调用系统中安装的字体，但是字体的名称并不是我们通常见到的那样，比如：华文隶书 在系统中是“STLiti”。而如何找到这种对于关系呢？
开始-&gt;运行-&gt;输入“CMD”,弹出命令窗口：输入："fc-list",回车，就可以看到系统中所有安装字体的这种对于关系。当然，显示的原因，可能看不全，所有不如把它保存下来，方法是命令窗口中输入：“fc-list&gt;&gt;c:font.txt”(这里假设存入到D盘的font.txt文件下)。
注意：笔者按照网上的两种方法：“fc-list:lang=zh-cn”(查看所有安装的中文字体)或者“fc-list:lang=en”(查看所有安装的英文字体)，一直无法查看，在这点上折腾了很长时间。所以，如果你的电脑上可以按这两种方法查看那样最好，如果不能，不妨就用我的方法。当然，如果你搞清楚了其中的原因也欢迎留言。
现在有了这种对应关系，那么就可以继续了。在导言区对全局的字体进行设置：
然后便是对于其它字体的设置和使用，需要注意的是指令的名称是可以自己定义的，但是系统字体名称却一定要按照上面查出来了的字体名称
下面是一个完整的例子：
\documentclass{article} \usepackage{ctex} \setmainfont{Times New Roman}%设置Times New Roman为默认的英文字体 \setCJKmainfont{SimSun} %设置宋体为默认的中文字体 %设置要使用的英文字体 %\newfontinstance{\courier} {Courier} %使用Courier字体 \newfontinstance{\gramond} {Garamond} %使用Garamond字体 %设置要使用的中文字体 \setCJKfamilyfont{mhwxk}{STXingkai} %华文行楷 \newcommand{\stxk}{\CJKfamily{mhwxk}} \setCJKfamilyfont{hwlsh}{STLiti} %华文隶书 \newcommand{\sthwls}{\CJKfamily{hwlsh}} \begin{document} %{\courier This a Courier Style} \par {\gramond This a Garamond font style} \par {\stxk 这是华文行楷字体的式样} \par {\sthwls 这是华文隶书字体的式样} \par \end{document} 注意：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc7cea9851f24a8398c57d05e57efbc3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32fbd1f29983df645f1170921c170858/" rel="bookmark">
			如何设计21点游戏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		21点游戏的设计能够充分体现C语言结构化程序设计的思想，如果你是C语言的初学者，本文对你一定有帮助.
21点游戏的规则如下：扑克牌A、2、3、4、、、、、、10、J、Q、K、大小鬼分别代表数字1、2、3、4、、、、、、10、11、12、13、21；人和电脑轮流坐庄，庄家先发牌。胜利条件：将所取牌点数相加凑成 "和"是21，谁先凑成21就胜出，如果没有人凑到"和"是21，就定"和"最接近21且小于21就胜出。每人至多可取5张扑克牌。要注意"和"超过21者谁先爆掉也就是输了，如果都爆了，点数小的胜；当点数相同时，庄家胜。
首先，理清游戏的运行思路是非常关键的。面对众多杂乱的规则，可以先去除无关紧要的细节，这样细节与游戏总体的思路没有关系，只是影响某些过程的处理细节.比如: 每人至多可取5张扑克牌，注意"和"超过21者谁先爆掉也就是输了，如果都爆了，点数小的胜；当点数相同时，庄家胜。可以概括为”取牌规则和判定规则”,这样整个游戏其实就变成了轮流取牌并计分的过程.只是一次取牌结束后可以自行退出，只是不能取5次以上，然后最终用特定的规则来判定胜负.这样理解的游戏的整体思路后，即使加入再多的细节也能轻松应对.
程序编码的第一步是什么?是先声明变量？写主函数?我个人喜欢的是先完成子函数模块的设计.把子模块完成之后，更高级的模块就变得容易了.就像盖楼房一样，先堆砌基础的模块总让我很放心，而一开始就从上层开始让我有一种悬于空中的感觉。我认为对于小型程序来说，自下而上的设计方式是高效的.
分析的时候从分析主体开始，没想到设计的时候从细节开始,但是，我小手一抖，就写出了几个子模块:
//根据牌点获取其数值
intvalue(int i)
{
if(i &lt;= 52)
return i / 4 + 1; //花牌
return MAXNUM; //鬼牌
}
//电脑取牌
introbot_fetch()
{
if(robot_value &gt;= AVG_POINT) //如果取得平均点，不再取牌
return AVG_POINT;
int id;
do{
id = rand() % SUM + 1; //随机选牌
}while(map[id]);
map[id] = 1; //标记为选择状态
return robot_value + value(id);
}
//玩家取牌
intplayer_fetch()
{
int id;
do{
id = rand() % SUM + 1; //随机选牌
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/32fbd1f29983df645f1170921c170858/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a1d174223133aa3b5221af9bf73400c/" rel="bookmark">
			【转】RHEL6（CentOS6）安装 Oracle 11g R2 手记(完整详细可用版)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文地址：[url]http://blog.csdn.net/kimsoft/article/details/8117575[/url] 选型： 32位的内存是个瓶颈，已经是64位的时代了。使用64位的CentOS6 和 64位的Oracle 11g R2 在虚拟机器安装，采用hostonly方式设置网络 注意：能上网的网卡要设置一下ICS（Internet连接共享）给VMware Network Adapter VMnet1 这样对于虚拟机，网关是192.168.137.1，IP地址请也要设置在192.168.137.0/24段 硬盘40G，内存2G 1、下载软件 1.1、CentOS 6（x86_64） http://mirrors.163.com/centos/ 1.2、Oracle 11g R2（Linux x86-64） http://www.oracle.com/technetwork/database/enterprise-edition/downloads/index.html 附：Oracle 10g下载址： http://www.cnblogs.com/wenlg/archive/2010/05/19/1738893.html 二、安装CentOS安装 虚拟机，40G HDD, 2GRAM 2.1、安装规划 机器名：dbserver a、安装时设置 b、或装好后vim /etc/sysconfig/network 2.2、网络 IPADDR:192.168.137.15 NETMASK:255.255.255.0 GATEWAY:192.168.137.1 DNS1:8.8.8.8 自动连接设置为yes a、安装时设置 b、装好后使用setup c、装好后vim /etc/sysconifg/network-scripts/ifcfg-eth0，改好后service network restart|force-reload 或 ifdown eth0 &amp;&amp; ifup eth0 2.3、磁盘规划 磁盘有限，分区可能不太合理，尽量用LVM /boot 200M 主分区 / 主分区 swap 大小参考以下 swap 大小参考以下： Available RAM Swap Space Required Between 1 GB and 2 GB 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a1d174223133aa3b5221af9bf73400c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da85d3d1a417a5fbd235d80e5017a6f7/" rel="bookmark">
			Eclipse 如何安装单独的一个jar插件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在eclipse的根目录下有一个dropins文件夹，在这个下面建立一个文件夹，比如：myplugin，
在上述文件夹的基础上建立plugins文件夹，把单独的那个jar文件放进去，重新启动eclipse就可以了
如果没有生效，则删除\eclipse\configuration文件夹下的org.eclipse.update文件夹，再重新启动
在进行插件发布时，如果遇到了因中文字符所造成的错误，解决方法如下：
1、windows-&gt;Preferences...打开"首选项"对话框，左侧导航树，导航到 general-&gt;Workspace，右 侧Text file encoding，选择Other，改变为UTF-8，以后新建立工程其属性对话框中的Text file encoding即为UTF-8。
2、windows-&gt;Preferences...打开"首选项"对话框，左侧导航树，导航到 general-&gt;Content Types，右侧Context Types树，点开Text，选择Java Source File，在下面的Default encoding输入框中输入UTF-8，点Update，则设置Java文件编码为UTF-8。其他java应用开发相关的文件 如：properties、XML等已经由Eclipse缺省指定，分别为ISO8859-1，UTF-8，如开发中确需改变编码格式则可以在此指定。经 过上述两步，新建java文件即为UTF-8编码，Eclipse编译、运行、调试都没问题，但是做RCP应用的Product输出 时、或者插件 输出时，则总是出错，要么不能编译通过(输出时要重新compile)、要么输出的插件运行时中文显示乱码。 3.此时需要再RCP应用、或插件Plugin工 程的build.properties中增加一行， javacDefaultEncoding.. = UTF-8 。让输出时编译知道java源文件时UTF-8编码。这个设置需要保证所有的java源文件时UTF-8编码格式
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cda959eaa42d75893505312396415e89/" rel="bookmark">
			ADD加法运算指令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		procedure TForm8.Button2Click(Sender: TObject); var i,j,Count:Integer; begin i:=10; J:=20; asm // MOV EAX,i+j; //不能这样使用 MOV EAX,i; //赋值 MOV ECX,j; ADD EAX,ECX; {EAX:=EAX+ECX;} //进行加法运算 MOV Count,EAX; end; Showmessage(IntToStr(Count)); {30} end; 注解：先把两个变量赋值给两个寄存器，然后再通过寄存器进行加法运算，最后把寄存器中的值赋值给变量。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c74988978f2ba3c952e63b5ade3fa7b/" rel="bookmark">
			leetcode第一刷_Median of Two Sorted Arrays
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 这道题是我最初刷的那20多道之一，但一直没有过，被各种各样的情况折磨死了，直到把所有其他的题都写完，回来看大神对这道题是怎么处理的时候，才惊叹算法的奇妙。再次验证了我的想法，如果要处理各种各样的特殊情况，一定是算法本身有问题。
之前看过很多有关在两个排序数组中找中位数的解法，大多根据两个数组长度不同分了很多种情况，各种讨论。下面要介绍的方法并没有直接求中位数，而是把求中位数转换成了求两个数组合并之后的第（m+n)/2个数（当然根据总数的奇偶有所不同，不过思路上是没有问题的）。用k来表示进入递归的时候，应该求的两个数列合并之后的那个数，用二分的思想，我们先看A[k/2]与B[k/2]的大小关系，如果A[k/2-1]&lt;B[k/2-1]，那么A[0，k/2-1]中有没有可能存在合并之后的第K个数呢？A[k/2-1]大于A中在它之前的k/2-1个数，最好的情况，它也大于B中的在B[k/2-1]之前的k/2-1个数，也就是A[k/2-1]最大在合并后的数列中可以排到第（k/2-1+k/2-1+1)个位置，也即第k-1个位置。因此A[k/2-1]这一部分肯定不包含结果，应该直接扔掉。
对称的，当A[k/2-1]&gt;B[k/2-1]时，有类似的结果。
当A[k/2-1] == B[k/2-1]时呢？说明这个数找到了，返回即可。
在实现的时候有几个技巧，两个数列个数不一样，为了下面编码部分的简便，可以在开头判断一下，如果前面数组个数多，就互换一下。第二点，数组中剩余的的元素可能比k/2要少，这时候就取一个较小的值即可。至于最开始两个数组合并后元素个数奇偶的问题，正是由于我们求的是第k个数而不是中位数，大大简化 了。设总数为t，如果是奇数，就求第t/2+1的那个数，如果是偶数，就分别求第t/2和第t/2+1的数，然后求平均。
28行代码完成了我100多行没有完成的事情，算法太美。
class Solution { public: double findKth(int *A, int m, int *B, int n, int k){ if(m&gt;n){ return findKth(B, n, A, m, k); } if(m == 0) return B[k-1]; if(k == 1) return min(A[0], B[0]); int pa = min(m, k/2), pb = k-pa; if(A[pa-1]&lt;B[pb-1]){ return findKth(A+pa, m-pa, B, n, k-pa); }else if(A[pa-1]&gt;B[pb-1]){ return findKth(A, m, B+pb, n-pb, k-pb); }else{ return A[pa-1]; } } double findMedianSortedArrays(int A[], int m, int B[], int n) { int t = m+n; if(t&amp;0x1){ return findKth(A, m, B, n, t/2+1); }else{ return (findKth(A, m, B, n, t/2)+findKth(A, m, B, n, t/2+1))/2; } } }; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a761caf4a4f0d3187ea9bf63ee56e1d/" rel="bookmark">
			leetcode第一刷_Regular Expression Matching
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 这道题跟有？和*的那道题很像，不过要简单一些。为什么会简单呢，因为*号只能匹配跟它前面相同的字符。需要注意一点，从aab可以用c*a*b来匹配可以看出，*号可以使他之前的那个字符出现次数变成0。
昨天实验室的同学正好在做这个题，说想用递归做，我想都没想就说用递归肯定超时了。她为什么，我跟人家说因为递归的分支太多了，可怎么也想不起当初自己是怎么写的，回来一看，居然用递归做的，打脸啊。。这个题为什么用递归可以呢？我觉得主要是因为*号的匹配规则，比起可以匹配任意字符来说，只能匹配之前的那个字符显得严格多了，很多分支都被剪掉了。
好，确定了整体的思路是递归，那具体怎么做？想一下递归的分支是怎么走的。同样的，两种符号中，‘.’对我们是不构成威胁的，之所以有很多种情况，是因为*，我们就可以按照*来划分，那是不是按照当前位置是不是*来划分呢？no no no，因为*匹配的是前面的那个字符，因此应该在它前面的那个字符的位置就可以考虑* 的问题，按照当前位置的后一个字符是不是*来划分是个不错的选择。
假设当前位置是i，假设i+1位置不是*，那么i位置必须完全匹配，这里的完全匹配分两种情况，要么是字符相同，要么p[i]='.'。注意'.'必须是跟实际的字符相匹配的，不能匹配'\0'。如果i+1位置是*，分支情况就来了，如果当前位置是不匹配的，那么只能用这个*来讲p[i]的出现次数变成0，也就是继续匹配p+2的位置。如果当前位置是匹配的，那么既可以用p[i]匹配多次（此时之更新s的指针），也可以跳过这个字符（分支通过匹配p+2）。
写成代码会很简介：
class Solution { public: bool isMatch(const char *s, const char *p) { if(s==NULL &amp;&amp; p == NULL) return false; if(*p=='\0') return *s=='\0'; if(*(p+1) != '*'){ return (*s==*p||(*p=='.'&amp;&amp;*s != '\0'))&amp;&amp;isMatch(s+1, p+1); } while(*p==*s || (*p=='.'&amp;&amp;*s!='\0')){ if(isMatch(s, p+2)) return true; ++s; } return isMatch(s, p+2); } }; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/634d11bc2dd88b6b48fc90bef42f21da/" rel="bookmark">
			leetcode第一刷_Roman to Integer
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 把罗马的转化成整数就容易多了。
定义一个map，做好所有base跟十进制之间的映射，然后遇到一个base，只要看看这个base是不是比后面的那个base小，如果是的话，说明是4或9的情况，转化后加的应该是两个这两个base对应的十进制之间的差。否则，直接加上base对应的十进制就行了。
class Solution { public: int romanToInt(string s) { if(s == "") return 0; int ba = 0, in = 0, res = 0; map&lt;char, int&gt; baseC; baseC['M'] = 1000; baseC['D'] = 500; baseC['C'] = 100; baseC['L'] = 50; baseC['X'] = 10; baseC['V'] = 5; baseC['I'] = 1; while(in&lt;s.length()){ if(in+1&lt;s.length()&amp;&amp;baseC[s[in]]&lt;baseC[s[in+1]]){ res += baseC[s[in+1]] - baseC[s[in]]; ++in; }else{ res += baseC[s[in]]; } ++in; } return res; } }; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/412fb27b37c8533bd90cb17894700cab/" rel="bookmark">
			最简单的基于FFMPEG的视频编码器（YUV编码为H.264）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		=====================================================
最简单的基于FFmpeg的视频编码器文章列表：
最简单的基于FFMPEG的视频编码器（YUV编码为H.264）
最简单的基于FFmpeg的视频编码器-更新版（YUV编码为HEVC(H.265)）
最简单的基于FFmpeg的编码器-纯净版（不包含libavformat）
=====================================================
本文介绍一个最简单的基于FFMPEG的视频编码器。该编码器实现了YUV420P的像素数据编码为H.264的压缩编码数据。编码器代码十分简单，但是每一行代码都很重要，适合好好研究一下。弄清楚了本代码也就基本弄清楚了FFMPEG的编码流程。目前我虽然已经调通了程序，但是还是有些地方没有完全搞明白，需要下一步继续探究然后补充内容。
本程序使用最新版的类库（编译时间为2014.5.6），开发平台为VC2010。所有的配置都已经做好，只需要运行就可以了。
流程 下面附一张使用FFmpeg编码视频的流程图。使用该流程，不仅可以编码H.264的视频，而且可以编码MPEG4/MPEG2/VP8等等各种FFmpeg支持的视频。图中蓝色背景的函数是实际输出数据的函数。浅绿色的函数是视频编码的函数。
简单介绍一下流程中各个函数的意义：
av_register_all()：注册FFmpeg所有编解码器。
avformat_alloc_output_context2()：初始化输出码流的AVFormatContext。
avio_open()：打开输出文件。
av_new_stream()：创建输出码流的AVStream。
avcodec_find_encoder()：查找编码器。
avcodec_open2()：打开编码器。
avformat_write_header()：写文件头（对于某些没有文件头的封装格式，不需要此函数。比如说MPEG2TS）。
avcodec_encode_video2()：编码一帧视频。即将AVFrame（存储YUV像素数据）编码为AVPacket（存储H.264等格式的码流数据）。
av_write_frame()：将编码后的视频码流写入文件。
flush_encoder()：输入的像素数据读取完成后调用此函数。用于输出编码器中剩余的AVPacket。
av_write_trailer()：写文件尾（对于某些没有文件头的封装格式，不需要此函数。比如说MPEG2TS）。
代码 /** * 最简单的基于FFmpeg的视频编码器 * Simplest FFmpeg Video Encoder * * 雷霄骅 Lei Xiaohua * leixiaohua1020@126.com * 中国传媒大学/数字电视技术 * Communication University of China / Digital TV Technology * http://blog.csdn.net/leixiaohua1020 * * 本程序实现了YUV像素数据编码为视频码流（H264，MPEG2，VP8等等）。 * 是最简单的FFmpeg视频编码方面的教程。 * 通过学习本例子可以了解FFmpeg的编码流程。 * This software encode YUV420P data to H.264 bitstream. * It's the simplest video encoding software based on FFmpeg.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/412fb27b37c8533bd90cb17894700cab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6407149875970aec7a2e701a905aa8d1/" rel="bookmark">
			最简单的基于FFMPEG的音频编码器（PCM编码为AAC）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文介绍一个最简单的基于FFMPEG的音频编码器。该编码器实现了PCM音频采样数据编码为AAC的压缩编码数据。编码器代码十分简单，但是每一行代码都很重要。通过看本编码器的源代码，可以了解FFMPEG音频编码的流程。
本程序使用最新版的类库（编译时间为2014.5.6），开发平台为VC2010。所有的配置都已经做好，只需要运行就可以了。
流程（2014.9.29更新） 下面附一张使用FFmpeg编码音频的流程图。使用该流程，不仅可以编码AAC的音频，而且可以编码MP3，MP2等等各种FFmpeg支持的音频。图中蓝色背景的函数是实际输出数据的函数。浅绿色的函数是音频编码的函数。
简单介绍一下流程中各个函数的意义：
av_register_all()：注册FFmpeg所有编解码器。
avformat_alloc_output_context2()：初始化输出码流的AVFormatContext。
avio_open()：打开输出文件。
av_new_stream()：创建输出码流的AVStream。
avcodec_find_encoder()：查找编码器。
avcodec_open2()：打开编码器。
avformat_write_header()：写文件头（对于某些没有文件头的封装格式，不需要此函数。比如说MPEG2TS）。
avcodec_encode_audio2()：编码音频。即将AVFrame（存储PCM采样数据）编码为AVPacket（存储AAC，MP3等格式的码流数据）。
av_write_frame()：将编码后的视频码流写入文件。
av_write_trailer()：写文件尾（对于某些没有文件头的封装格式，不需要此函数。比如说MPEG2TS）。
代码 /** *最简单的基于FFmpeg的音频编码器 *Simplest FFmpeg Audio Encoder * *雷霄骅 Lei Xiaohua *leixiaohua1020@126.com *中国传媒大学/数字电视技术 *Communication University of China / Digital TV Technology *http://blog.csdn.net/leixiaohua1020 * *本程序实现了音频PCM采样数据编码为压缩码流（MP3，WMA，AAC等）。 *是最简单的FFmpeg音频编码方面的教程。 *通过学习本例子可以了解FFmpeg的编码流程。 *This software encode PCM data to AAC bitstream. *It's the simplest audio encoding software based on FFmpeg. *Suitable for beginner of FFmpeg */ #include &lt;stdio.h&gt; #define __STDC_CONSTANT_MACROS #ifdef _WIN32 //Windows extern "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6407149875970aec7a2e701a905aa8d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/624681cfb6097fcddb8f42712304ce46/" rel="bookmark">
			最简单的基于FFMPEG的封装格式转换器（无编解码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		=====================================================
最简单的基于FFmpeg的封装格式处理系列文章列表：
最简单的基于FFmpeg的封装格式处理：视音频分离器简化版（demuxer-simple）
最简单的基于FFmpeg的封装格式处理：视音频分离器（demuxer）
最简单的基于FFmpeg的封装格式处理：视音频复用器（muxer）
最简单的基于FFMPEG的封装格式处理：封装格式转换（remuxer）
=====================================================
简介 本文介绍一个基于FFMPEG的封装格式转换器。所谓的封装格式转换，就是在AVI，FLV，MKV，MP4这些格式之间转换（对应.avi，.flv，.mkv，.mp4文件）。需要注意的是，本程序并不进行视音频的编码和解码工作。而是直接将视音频压缩码流从一种封装格式文件中获取出来然后打包成另外一种封装格式的文件。传统的转码程序工作原理如下图所示：
上图例举了一个举例：FLV（视频：H.264，音频：AAC）转码为AVI（视频：MPEG2，音频MP3）的例子。可见视频转码的过程通俗地讲相当于把视频和音频重新“录”了一遍。 本程序的工作原理如下图所示： 由图可见，本程序并不进行视频和音频的编解码工作，因此本程序和普通的转码软件相比，有以下两个特点： 处理速度极快。视音频编解码算法十分复杂，占据了转码的绝大部分时间。因为不需要进行视音频的编码和解码，所以节约了大量的时间。 视音频质量无损。因为不需要进行视音频的编码和解码，所以不会有视音频的压缩损伤。 流程（2014.9.29更新） 下面附上基于FFmpeg的Remuxer的流程图。图中使用浅红色标出了关键的数据结构，浅蓝色标出了输出视频数据的函数。可见成个程序包含了对两个文件的处理：读取输入文件（位于左边）和写入输出文件（位于右边）。中间使用了一个avcodec_copy_context()拷贝输入的AVCodecContext到输出的AVCodecContext。
简单介绍一下流程中关键函数的意义：
输入文件操作：
avformat_open_input()：打开输入文件，初始化输入视频码流的AVFormatContext。
av_read_frame()：从输入文件中读取一个AVPacket。
输出文件操作：
avformat_alloc_output_context2()：初始化输出视频码流的AVFormatContext。
avformat_new_stream()：创建输出码流的AVStream。
avcodec_copy_context()：拷贝输入视频码流的AVCodecContex的数值t到输出视频的AVCodecContext。
avio_open()：打开输出文件。
avformat_write_header()：写文件头（对于某些没有文件头的封装格式，不需要此函数。比如说MPEG2TS）。
av_interleaved_write_frame()：将AVPacket（存储视频压缩码流数据）写入文件。
av_write_trailer()：写文件尾（对于某些没有文件头的封装格式，不需要此函数。比如说MPEG2TS）。
代码 贴上代码，代码是从FFmpeg的例子改编的，平台是VC2010。
/* *最简单的基于FFmpeg的封装格式转换器 *Simplest FFmpeg Remuxer * *雷霄骅 Lei Xiaohua *leixiaohua1020@126.com *中国传媒大学/数字电视技术 *Communication University of China / Digital TV Technology *http://blog.csdn.net/leixiaohua1020 * *本程序实现了视频封装格式之间的转换。 *需要注意的是本程序并不改变视音频的编码格式。 * * This software converts a media file from one container format * to another container format without encoding/decoding video files.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/624681cfb6097fcddb8f42712304ce46/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ee925ccd60788ab97ea908e406151e1/" rel="bookmark">
			jeecg利弊分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通过我对jeecg的体验，现将jeecg的分析总结如下： 优势： 1.应用范围主要在企业管理方面，比如ERP,CRM等。
2.页面开发方面 对使用者要求低，不需要太大的工作量就能做出漂亮美观的界面。
3.代码生成方面依靠物理表结构生成对应的实体类和界面结构。
4.代码结构方面，使用了泛型，避免了强制类型转换，提升代码性能。
5.在线开发工具的增加使开发者节省了重复写代码的时间，用鼠标点几下就把一个增删改查的功能做好了。
6.学习成本低，上手快，DEMO中例子多。
7.持久化方面，摆脱了hibernate复杂的xml配置。
8.目前开发环境使用eclipse+meavn方式，技术较新。
劣势： 1.在做大型网站运营方面有所欠缺。页面太呆板，不灵活。
2. UI对跨浏览器支持不太好，低版本的IE，火狐都有不同的显示问题。
3. 对web service的支持不太完善。
改进建议: 1. 持久化方面建议多封装一些工具，比如直接返回bean类型的list,数组类型，map类型等。
2.提高浏览器的兼容性。
3. 在SAAS模式方面多增加支持，增加多租户模式。高度可配置化。
4. 多增加对主流PAAS平台的兼容组件。能实现在主流的PAAS平台上部署，比如百度云，阿里云，新浪云等。
5.增强对手机web app开发的支持。
6.封装带来了很多便利，但是问题就是扩展难，需要找到一个平衡点。
7.增加nosql支持。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3959a90d5734030fd4c0414776b3b42/" rel="bookmark">
			Lua的upvalue和闭包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Lua函数可以被当成参数传递，也可以被当成结果返回，在函数体中仍然可以定义内嵌函数。lua闭包是Lua函数生成的数据对象。每个闭包可以有一个upvalue值，或者多个闭包共享一个upvalue数值。
1、upvalue 如果函数f2定义在函数f1中，那么f2为f1的内嵌函数，f1为f2的外包函数，外包和内嵌都具有传递性，即f2的内嵌必然是f1的内嵌，而f1的外包也一定是f2的外包。
内嵌函数可以访问外包函数已经创建的局部变量，而这些局部变量则称为该内嵌函数的外部局部变量（或者upvalue）
代码如下：
function　f1(n) --　函数参数也是局部变量 local　function　f2() print(n)　--　引用外包函数的局部变量 end return　f2 end g1　=　f1(1979) g1()　--　打印出1979 g2　=　f1(500) g2()　--　打印出500 当执行完g1　=　f1(1979)后，局部变量n的生命本该结束，但因为它已经成了内嵌函数f2的upvalue，它又被赋给了变量g1，所以它仍然能以某种形式继续“存活”下来，从而令g1()打印出正确的值。
2、闭包 Lua编译一个函数时，其中包含了函数体对应的虚拟机指令、函数用到的常量值(数，文本字符串等等)和一些调试信息。在运行时，每当Lua执行一个形如function...end　这样的函数时，它就会创建一个新的数据对象，其中包含了相应函数原型的引用、环境(用来查找全局变量的表)的引用以及一个由所有upvalue引用组成的数组，而这个数据对象就称为闭包。由此可见，函数是编译期概念，是静态的，而闭包是运行期概念，是动态的。g1和g2的值严格来说不是函数而是闭包，并且是两个不相同的闭包，而这两个闭包保有各自的upvalue值。 使用upvalue代码如下： function　f1(n) local　function　f2() print(n) end n　=　n　+　10 return　f2 end g1　=　f1(1979) g1()　--　打印出1989 g1()打印出来的是1989，原因是打印的是upvalue的值。
upvalue实际是局部变量，而局部变量是保存在函数堆栈框架上的，所以只要upvalue还没有离开自己的作用域，它就一直生存在函数堆栈上。这种情况下，闭包将通过指向堆栈上的upvalue的引用来访问它们，一旦upvalue即将离开自己的作用域，在从堆栈上消除之前，闭包就会为它分配空间并保存当前的值，以后便可通过指向新分配空间的引用来访问该upvalue。当执行到f1(1979)的n　=　n　+　10时，闭包已经创建了，但是变量n并没有离开作用域，所以闭包仍然引用堆栈上的n，当return　f2完成时，n即将结束生命，此时闭包便将变量n(已经是1989了)复制到自己管理的空间中以便将来访问。 3、upvalue和闭包数据共享 upvalue还可以为闭包之间提供一种数据共享的机制。
（1）单重内嵌函数的闭包 （函数创建的闭包） 一个函数创建的闭包共享一份upvalue。 代码如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3959a90d5734030fd4c0414776b3b42/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac9d90783334a3f8dd76f85734016734/" rel="bookmark">
			C&#43;&#43;之stack.top()
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 写一个括号匹配函数，用栈实现，思路简单，但再stack.top()使用时遇到错误：
void MatchCheck(char p[], int len) { stack&lt;char&gt; mystack; int leftcount = 0, rightcount = 0; for(int i = 0; i &lt; len; i++) { if(p[i] == '(') { leftcount++; mystack.push('('); //	cout &lt;&lt; mystack.top()&lt;&lt;"	"; } else if(p[i] == ')') { rightcount ++; if(mystack.top() == '(') mystack.pop(); else mystack.push(')'); } } 在测试字符串为if((a==1))&amp;&amp;(b==1))时，内存错误，经分析调试，发现是stack.top()的使用问题：因为当mystack为空时，调用stack.top（）就会出现内存错误！！！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17d9b05ce62e84943e7f494319e732bb/" rel="bookmark">
			在VS2012中使用GitHub
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注册GitHub账号（DeanZhouLin） https://github.com/
向GitHub中添加一个仓库（Test） *创建完成后，记录该仓库的地址：https://github.com/DeanZhouLin/Test.git
同步代码的时候是需要使用该地址的。
GitHub-VS2012设置 1 打开扩展和更新
2 安装扩展，搜索关键字为：visual studio tools for git
3 打开选项设置对话框
4 设置源代码管理项
5 打开团队管理器中的设置框
6 设置GitHub的账号，目录
添加一个项目到GitHub中的新建的Test仓库 1 使用VS2012随便新建一个项目
2 将新建的项目提交到本地
3 打开团队管理器主页
4 打开同步到服务器的对话框
5 将项目发布到指定的仓库中
6 done，如下图，GitHub上的Test的仓库已经有了项目的代码
把GitHub仓库中的项目克隆到本地的指定的文件夹中 指定路径
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2705fa53ab3efa681892a4d6d3ea56f6/" rel="bookmark">
			Hbase总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20515c7642ac3e0c0019b12928a40519/" rel="bookmark">
			oracle中的多表查询方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.等值连接
SELECT e.employee_id, e.last_name, e.department_id, d.department_id, d.location_id FROM employees e , departments d WHERE e.department_id = d.department_id; 2.非等值连接
SELECT e.last_name, e.salary, j.grade_level FROM employees e, job_grades j WHERE e.salary BETWEEN j.lowest_sal AND j.highest_sal; 3.左（右）外连接
①右外连接
SELECT e.last_name, e.department_id, d.department_name FROM employees e, departments d WHERE e.department_id(+) = d.department_id ; 4.自连接
返回“Xxx works for Xxx”
说明：worker和manager同属于一个表，别名
SELECT worker.last_name || ' works for ' || manager.last_name FROM employees worker, employees manager WHERE worker.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/20515c7642ac3e0c0019b12928a40519/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b280e23b839cd01957c3a5335603ab2/" rel="bookmark">
			关于计时函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在用C/C++写一些算法时，经常要分析程序或函数的性能，不可避免地要使用到计时函数。尤其是在做图像处理时，更是要细致到每个函数到底占用了多少时间，以此来作为进一步提高程序效率的依据。
在这儿大致总结一下用过的计时函数。
一、最常使用的time()和clock()
1、time()函数，头文件&lt;time.h&gt;，函数原型：time_t time(time_t * _Time); time_t在VC6.0中定义为long型，在Visual Studio 2010中定义为__int64型，即64位整型（可能是为了防止到2038年1月18日19时14分07秒后清零的情况，64位整型可以表示到3001年1月 1日0时0分0秒（不包括该时间点）之前的时间）。参数为接收该函数返回值的变量的地址，返回值为从1970年1月1日0时0分0秒到当前系统时间所经过的秒数。
注：用C语言的方式输入输出时，64位整型变量的标识符为%I64d或%I64u（无符号）。
2、clock()函数，头文件也是&lt;time.h&gt;，函数原型：clock_t clock(void); clock_t定义为long型（VC和VS2010中都是）。返回值为该进程运行的滴答数。在&lt;time.h&gt;中定义了常量CLOCKS_PER_SEC表示每秒嘀嗒数，Windows下一般是1000，LINUX下一般是1000000。即Windows下clokc()的返回值可当作毫秒用，LINUX下可当作微秒用。（在LINUX下多线程时clock函数不稳定，可能是LINUX下线程实现机制的缘故）。
二、WindowsAPI中提供的GetTickCount()函数
GetTickCount()函数，定义在&lt;WinBase.h&gt;中，但需要包含&lt;Windows.h&gt;，否则会报错。没深入了解过Windows编程，故其具体原因不详。
函数原型：DWORD GetTickCount(void); DWORD定义为为long型。该函数返回从操作系统启动所经过的毫秒数。
注1：该函数并非实时发送，而是由系统每18ms发送一次，因此其最小精度为18ms。（VC6.0测试，在15-18毫秒之间，某篇论文上写到MSDN上关于该函数的时间精度说明为10-16毫秒之间）；
注2：该函数返回值以32位的双字类型DWORD存储，因此可以存储的最大值是2^32 ms约为49.71天，因此若系统运行时间超过49.71天时，这个数就会归0。在使用时需特别注意。尤其是在编写服务端程序时。
三、WindowsAPI中提供的QueryPerformanceCounter()和QueryPerformanceFrequency()函数
1、 QueryPerformanceCounter()函数，定义在&lt;WinBase.h&gt;中，需包含头文件&lt;Windows.h&gt;。
函数原型：BOOL QueryPerformanceCounter(LARGE_INTEGER *lpPerformanceCount );
返回值非零表示硬件支持高精度计数器，零表示不支持。
唯一的参数是被写入的LARGE_INTEGER变量的地址。LARGE_INTEGER是一个联合体，一般可直接引用其QuadPart成员即可，QuadPart定义为LONGLONG，即__int64型，64位整型变量。
该函数（如果硬件支持的话）将硬件的高精度计时器的值写入lpPerformanceCount指向的变量。在某事件前后两次调用该函数，计算差值即可得到计时器间隔。
2、QueryPerformanceFrequency()函数，定义在&lt;WinBase.h&gt;中，需包含头文件&lt;Windows.h&gt;。
函数原型：BOOL QueryPerformanceFrequency(LARGE_INTEGER *lpFrequency);
返回值同上，非零表示硬件支持高精度计数器，零表示不支持。
该函数将硬件支持的高精度计数器的频率写入lpFrequency指向的变量。
将两次调用QueryPerformanceCounter()函数的差值去除以频率，即可得到以秒为单位的时间间隔。
四、在使用OpenCV时，OpenCV中提供了两个用于计算时间的函数
1、cvGetTickCount()函数，定义在&lt;core_c.h&gt;中，一般包含&lt;opencv.hpp&gt;即可。
函数原型：int64 cvGetTickCount( void );
返回值为从依赖于平台的事件(从启动开始 CPU 的ticks 数目, 从1970年开始的微秒数目等等)开始的 tics 的数目。
2、cvGetTickFrequency()函数，定义在&lt;core_c.h&gt;中，一般包含&lt;opencv.hpp&gt;即可。
函数原型：double cvGetTickFrequency( void );
返回值为每个微秒的 tics 的数目。
结合使用cvGetTickCount()与cvGetTickFrequency()即可得到某事件消耗的时间。
五、C++11 中 std::chrono 模块中提供的计时函数
1、头文件 #include &lt;chrono&gt;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b280e23b839cd01957c3a5335603ab2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b05146e75afd313d02049fdd64f29d6/" rel="bookmark">
			软考之路（四）---软件工程一    概念模型，逻辑模型，物理模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自从接触到数据库到现在这三个概念大家理解的还有些不清楚，今天来为大家解答疑惑，共同提高，结合生活理解
概念模型 概念模型就是在了解了用户的需求，用户的业务领域工作情况以后，经过分析和总结，提炼出来的用以描述用户业务需求的一些概念的东西。如销售业务中的“客户”和“定单”，还有就是“商品”，“业务员”。 用USE CASE（用例图）来描述就是：“业务员”与“客户”就购买“商品”之事签定下“定单”。 逻辑模型（关系模型） 逻辑模型就是要将概念模型具体化。要实现概念模型所描述的东西，需要那些具体的功能和处理那些具体的信息。这就到了需求分析的细化阶段。
还以销售业务为例：“客户”信息基本上要包括：单位名称，联系人，联系电话，地址等属性；“商品”信息基本上要包括：名称，类型，规格，单价等属性；“定单”信息基本上要包括：日期和时间属性。并且“定单”要与“客户”，“业务员”和“商品”明细关联。
系统需要建立几个数据表：业务员信息表，客户信息表，商品信息表，定单表。
系统要包括几个功能：业务员信息维护，客户信息维护，商品信息维护，建立销售定单 。
以上这些均属于建立逻辑模型，这些说明只表明系统要实现什么，但怎样实现，用什么工具实现还没有讲，后者属于物理模型范围。 物理模型 物理模型就是针对上述逻辑模型所说的内容，在具体的物理介质上实现出来。如：数据库使用SQLServer2008，这样就可以编写具体的SQL脚本在数据库服务器上将数据库建立起来。其中包括业务员信息表，客户信息表，商品信息表，定单表。客户端使用VS2012开发工具，那么在工作站上用VS建立起功能菜单，包括：业务员信息维护，客户信息维护，商品信息维护，建立销售定单等功能，并用工具将每一个功能编码实现。
总结 这三个过程，就是实现一个软件系统的三个关键的步骤，是一个从抽象到具体的一个不断细化完善的分析，设计和开发的过程，结合PowerDesigner来根据需要分析、设计、到数据库表就是整个理解的过程，学习这块的内容要联系我们的实际学习，虽说是有些抽象，但是联系生活常用的，就显得不那么陌生了，这也是学习联系的好处，学而不乱，学越信息紧密，编制学习的网，生活中无处不再。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33323c1c485f439e8e1734409c7d0a18/" rel="bookmark">
			使用Jquery向一个空白网页动态创建一个iframe,及嵌入页面,和向嵌入页面传参
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		01.using Microsoft.VisualBasic; 02.using System; 03.using System.Collections; 04.using System.Collections.Generic; 05.using System.Data; 06.using System.Diagnostics; 07.using System.Collections.Specialized; 08.using Microsoft.JScript; 09.namespace MCS 10.{ 11. public partial class MyDialog : System.Web.UI.Page 12. { 13. protected string strParam = null; 14. private void Page_Load(System.Object sender, System.EventArgs e) 15. { 16. 17. } 18. 19. public string GetParam() 20. { 21. strParam = string.Empty; 22. int loop1 = 0; 23. int loop2 = 0; 24. string[] arr1 = null; 25.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/33323c1c485f439e8e1734409c7d0a18/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18f0c4bbc8f627d6998ec475751c98a2/" rel="bookmark">
			最短路径问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		只想说：温故而知新，可以为师矣。我大二的《数据结构》是由申老师讲的，那时候不怎么明白，估计太理论化了(ps：或许是因为我睡觉了)；今天把老王的2011年课件又看了一遍，给大二的孩子们又讲了一遍，随手谷歌了N多资料，算是彻底搞懂了最短路径问题。请读者尽情享用……
我坚信：没有不好的学生，只有垃圾的教育。不过没有人理所当然的对你好，所以要学会感恩。
一.问题引入
问题：从某顶点出发，沿图的边到达另一顶点所经过的路径中，各边上权值之和最小的一条路径——最短路径。解决最短路的问题有以下算法，Dijkstra算法，Bellman-Ford算法，Floyd算法和SPFA算法，另外还有著名的启发式搜索算法A*，不过A*准备单独出一篇，其中Floyd算法可以求解任意两点间的最短路径的长度。笔者认为任意一个最短路算法都是基于这样一个事实：从任意节点A到任意节点B的最短路径不外乎2种可能，1是直接从A到B，2是从A经过若干个节点到B。
二.Dijkstra算法
该算法在《数据结构》课本里是以贪心的形式讲解的，不过在《运筹学》教材里被编排在动态规划章节，建议读者两篇都看看。
观察右边表格发现除最后一个节点外其他均已经求出最短路径。
(1) 迪杰斯特拉(Dijkstra)算法按路径长度(看下面表格的最后一行，就是next点)递增次序产生最短路径。先把V分成两组：
S：已求出最短路径的顶点的集合V-S=T：尚未确定最短路径的顶点集合 将T中顶点按最短路径递增的次序加入到S中，依据：可以证明V0到T中顶点Vk的最短路径，或是从V0到Vk的直接路径的权值或是从V0经S中顶点到Vk的路径权值之和（反证法可证，说实话，真不明白哦）。
(2) 求最短路径步骤
初使时令 S={V0},T={其余顶点}，T中顶点对应的距离值， 若存在&lt;V0,Vi&gt;，为&lt;V0,Vi&gt;弧上的权值（和ＳＰＦＡ初始化方式不同），若不存在&lt;V0,Vi&gt;，为Inf。从T中选取一个其距离值为最小的顶点W(贪心体现在此处)，加入S(注意不是直接从S集合中选取，理解这个对于理解vis数组的作用至关重要)，对T中顶点的距离值进行修改：若加进W作中间顶点，从V0到Vi的距离值比不加W的路径要短，则修改此距离值（上面两个并列for循环，使用最小点更新）。重复上述步骤，直到S中包含所有顶点，即S=V为止（说明最外层是除起点外的遍历）。 下面是上图的求解过程，按列来看，第一列是初始化过程，最后一行是每次求得的next点。
(3) 问题：Dijkstar能否处理负权边？(下面的解释引自网上某大虾)
答案是不能，这与贪心选择性质有关(ps：貌似还是动态规划啊，晕了)，每次都找一个距源点最近的点（dmin），然后将该距离定为这个点到源点的最短路径；但如果存在负权边，那就有可能先通过并不是距源点最近的一个次优点（dmin'），再通过这个负权边L(L&lt;0)，使得路径之和更小（dmin'+L&lt;dmin）,则dmin'+L成为最短路径，并不是dmin，这样dijkstra就被囧掉了。比如n=3，邻接矩阵： 0，3，4 3，0，-2 4，-2，0,用dijkstra求得d[1，2]=3，事实上d[1，2]=2，就是通过了1-3-2使得路径减小。不知道讲得清楚不清楚。
二.Floyd算法
参考了南阳理工牛帅(目前在新浪)的博客。
Floyd算法的基本思想如下：从任意节点A到任意节点B的最短路径不外乎2种可能，1是直接从A到B，2是从A经过若干个节点到B，所以，我们假设dist(AB)为节点A到节点B的最短路径的距离，对于每一个节点K，我们检查dist(AK) + dist(KB) &lt; dist(AB)是否成立，如果成立，证明从A到K再到B的路径比A直接到B的路径短，我们便设置 dist(AB) = dist(AK) + dist(KB)，这样一来，当我们遍历完所有节点K，dist(AB)中记录的便是A到B的最短路径的距离。
很简单吧，代码看起来可能像下面这样：
for (int i=0; i&lt;n; ++i) { for (int j=0; j&lt;n; ++j) { for (int k=0; k&lt;n; ++k) { if (dist[i][k] + dist[k][j] &lt; dist[i][j] ) { dist[i][j] = dist[i][k] + dist[k][j]; } } } } 但是这里我们要注意循环的嵌套顺序，如果把检查所有节点K放在最内层，那么结果将是不正确的，为什么呢？因为这样便过早的把i到j的最短路径确定下来了，而当后面存在更短的路径时，已经不再会更新了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/18f0c4bbc8f627d6998ec475751c98a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41c33e3d72d2c9e6be364c64ca88e6f5/" rel="bookmark">
			音频AAC编码的RTMP直播
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RTMP直播，音频编码采用AAC时，需要把帧头的数据去掉。
第一个数据包，发送4个字节，前面两个是0xAF、0x00，我看有文章写的是这个0xAF的A代表的是AAC，说明如下：
0 = Linear PCM, platform endian
1 = ADPCM
2 = MP3
3 = Linear PCM, little endian
4 = Nellymoser 16 kHz mono
5 = Nellymoser 8 kHz mono
6 = Nellymoser
7 = G.711 A-law logarithmic PCM
8 = G.711 mu-law logarithmic PCM
9 = reserved
10 = AAC
11 = Speex
14 = MP3 8 kHz
15 = Device-specific sound
低4位的前2位代表抽样频率，二进制11代表44kHZ。第3位代表 音频用16位的。第4个bit代表声道数，0单声道，1双声道。尽管如此，实际使用发现这个AF00根本不需要更改，我用的24K采样、单声道，这个数据也是AF00没问题，关键是后面两个字节。
后面两个字节叫做AudioSpecificConfig，从最高位到最低位，分别表示：
前5位，表示编码结构类型，AAC main编码为1，LOW低复杂度编码为2，SSR为3。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/41c33e3d72d2c9e6be364c64ca88e6f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b1e81a9b68f70851942983345a5b930/" rel="bookmark">
			php中奖概率算法，可用于刮刮卡，大转盘等抽奖算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		php中奖概率算法，可用于刮刮卡，大转盘等抽奖算法。用法很简单，代码里有详细注释说明，一看就懂
&lt;?php /* * 经典的概率算法， * $proArr是一个预先设置的数组， * 假设数组为：array(100,200,300，400)， * 开始是从1,1000 这个概率范围内筛选第一个数是否在他的出现概率范围之内， * 如果不在，则将概率空间，也就是k的值减去刚刚的那个数字的概率空间， * 在本例当中就是减去100，也就是说第二个数是在1，900这个范围内筛选的。 * 这样 筛选到最终，总会有一个数满足要求。 * 就相当于去一个箱子里摸东西， * 第一个不是，第二个不是，第三个还不是，那最后一个一定是。 * 这个算法简单，而且效率非常 高， * 关键是这个算法已在我们以前的项目中有应用，尤其是大数据量的项目中效率非常棒。 */ function get_rand($proArr) { $result = ''; //概率数组的总概率精度 $proSum = array_sum($proArr); //概率数组循环 foreach ($proArr as $key =&gt; $proCur) { $randNum = mt_rand(1, $proSum); if ($randNum &lt;= $proCur) { $result = $key; break; } else { $proSum -= $proCur; } } unset ($proArr); return $result; } /* * 奖项数组 * 是一个二维数组，记录了所有本次抽奖的奖项信息， * 其中id表示中奖等级，prize表示奖品，v表示中奖概率。 * 注意其中的v必须为整数，你可以将对应的 奖项的v设置成0，即意味着该奖项抽中的几率是0， * 数组中v的总和（基数），基数越大越能体现概率的准确性。 * 本例中v的总和为100，那么平板电脑对应的 中奖概率就是1%， * 如果v的总和是10000，那中奖概率就是万分之一了。 * */ $prize_arr = array( '0' =&gt; array('id'=&gt;1,'prize'=&gt;'平板电脑','v'=&gt;1), '1' =&gt; array('id'=&gt;2,'prize'=&gt;'数码相机','v'=&gt;5), '2' =&gt; array('id'=&gt;3,'prize'=&gt;'音箱设备','v'=&gt;10), '3' =&gt; array('id'=&gt;4,'prize'=&gt;'4G优盘','v'=&gt;12), '4' =&gt; array('id'=&gt;5,'prize'=&gt;'10Q币','v'=&gt;22), '5' =&gt; array('id'=&gt;6,'prize'=&gt;'下次没准就能中哦','v'=&gt;50), ); /* * 每次前端页面的请求，PHP循环奖项设置数组， * 通过概率计算函数get_rand获取抽中的奖项id。 * 将中奖奖品保存在数组$res['yes']中， * 而剩下的未中奖的信息保存在$res['no']中， * 最后输出json个数数据给前端页面。 */ foreach ($prize_arr as $key =&gt; $val) { $arr[$val['id']] = $val['v']; } $rid = get_rand($arr); //根据概率获取奖项id $res['yes'] = $prize_arr[$rid-1]['prize']; //中奖项 unset($prize_arr[$rid-1]); //将中奖项从数组中剔除，剩下未中奖项 shuffle($prize_arr); //打乱数组顺序 for($i=0;$i&lt;count($prize_arr);$i++){ $pr[] = $prize_arr[$i]['prize']; } $res['no'] = $pr; print_r($res); ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b1e81a9b68f70851942983345a5b930/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/641eeb9584937ebddeebfdb7f17856f2/" rel="bookmark">
			类 HttpURLConnection
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java.net 类 HttpURLConnection java.lang.Object java.net.URLConnection java.net.HttpURLConnection 直接已知子类： HttpsURLConnection public abstract class HttpURLConnection extends URLConnection 支持 HTTP 特定功能的 URLConnection。有关详细信息，请参阅 the spec 。 每个 HttpURLConnection 实例都可用于生成单个请求，但是其他实例可以透明地共享连接到 HTTP 服务器的基础网络。请求后在 HttpURLConnection 的 InputStream 或 OutputStream 上调用 close() 方法可以释放与此实例关联的网络资源，但对共享的持久连接没有任何影响。如果在调用 disconnect() 时持久连接空闲，则可能关闭基础套接字。 从以下版本开始： JDK1.1 另请参见： disconnect() 字段摘要protected intchunkLength 使用存储块编码流模式进行输出时的存储块长度。protected intfixedContentLength 使用固定长度流模式时的固定内容长度。static intHTTP_ACCEPTED HTTP 状态码 202：Accepted。static intHTTP_BAD_GATEWAY HTTP 状态码 502：Bad Gateway。static intHTTP_BAD_METHOD HTTP 状态码 405：Method Not Allowed。static intHTTP_BAD_REQUEST HTTP 状态码 400：Bad Request。static intHTTP_CLIENT_TIMEOUT HTTP 状态码 408：Request Time-Out。static intHTTP_CONFLICT HTTP 状态码 409：Conflict。static intHTTP_CREATED HTTP 状态码 201：Created。static intHTTP_ENTITY_TOO_LARGE HTTP 状态码 413：Request Entity Too Large。static intHTTP_FORBIDDEN HTTP 状态码 403：Forbidden。static intHTTP_GATEWAY_TIMEOUT HTTP 状态码 504：Gateway Timeout。static intHTTP_GONE HTTP 状态码 410：Gone。static intHTTP_INTERNAL_ERROR HTTP 状态码 500：Internal Server Error。static intHTTP_LENGTH_REQUIRED HTTP 状态码 411：Length Required。static intHTTP_MOVED_PERM HTTP 状态码 301：Moved Permanently。static intHTTP_MOVED_TEMP HTTP 状态码 302：Temporary Redirect。static intHTTP_MULT_CHOICE HTTP 状态码 300：Multiple Choices。static intHTTP_NO_CONTENT HTTP 状态码 204：No Content。static intHTTP_NOT_ACCEPTABLE HTTP 状态码 406：Not Acceptable。static intHTTP_NOT_AUTHORITATIVE HTTP 状态码 203：Non-Authoritative Information。static intHTTP_NOT_FOUND HTTP 状态码 404：Not Found。static intHTTP_NOT_IMPLEMENTED HTTP 状态码 501：Not Implemented。static intHTTP_NOT_MODIFIED HTTP 状态码 304：Not Modified。static intHTTP_OK HTTP 状态码 200：OK。static intHTTP_PARTIAL HTTP 状态码 206：Partial Content。static intHTTP_PAYMENT_REQUIRED HTTP 状态码 402：Payment Required。static intHTTP_PRECON_FAILED HTTP 状态码 412：Precondition Failed。static intHTTP_PROXY_AUTH HTTP 状态码 407：Proxy Authentication Required。static intHTTP_REQ_TOO_LONG HTTP 状态码 414：Request-URI Too Large。static intHTTP_RESET HTTP 状态码 205：Reset Content。static intHTTP_SEE_OTHER HTTP 状态码 303：See Other。static intHTTP_SERVER_ERROR 已过时。 放错了位置，它不应该存在。static intHTTP_UNAUTHORIZED HTTP 状态码 401：Unauthorized。static intHTTP_UNAVAILABLE HTTP 状态码 503：Service Unavailable。static intHTTP_UNSUPPORTED_TYPE HTTP 状态码 415：Unsupported Media Type。static intHTTP_USE_PROXY HTTP 状态码 305：Use Proxy。static intHTTP_VERSION HTTP 状态码 505：HTTP Version Not Supported。protected booleaninstanceFollowRedirects 如果为 true，则协议自动执行重定向。protected Stringmethod HTTP 方法（GET、POST、PUT 等）。protected intresponseCode 表示三位字数的 HTTP 状态码 (Status-Code) 的 int。protected StringresponseMessage HTTP 响应消息。 从类 java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/641eeb9584937ebddeebfdb7f17856f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/508eb2497ce478c153133813950bd5f4/" rel="bookmark">
			用于汽车电子的CAN、LIN、MOST总线
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		未来 汽车 电子的整个网络将是CAN、LIN、MOST三网合一的整体。MOST负责音视频，CAN负责重要的电子控制单元，如 发动机 、ABS、安全气囊等，LIN负责次要的电子控制单元，如门窗、车灯等。 一、CAN总线技术简介 CAN总线又称作汽车总线，其全称为“控制器局域网（CAN—Controller Area Network）”。CAN总线是一种现场总线（区别于办公室总线），是德国Bosch公司为解决现代汽车中众多的电控模块(ECU)之间的数据交换而开发的一种串行通信协议。CAN总线的设计充分考虑了汽车上恶劣工作环境，可*性高。因此CAN总线在诸多现场总线中独占鳌头，成为汽车总线的代名词。 随着车用电气设备越来越多，从发动机控制到传动 系统 控制，从行驶、制动、转向系统控制到安全保证系统及仪表报警系统，从电源管理到为提高舒适性而作的各种努力，使汽车电气系统形成一个复杂的大系统，并且都集中在驾驶室控制。另外，随着近年来ITS的发展，以3G（GPS、GIS和GSM）为代表的新型电子通讯产品的出现，它对汽车的综合 布线 和信息的共享交互提出了更高的要求。从布线角度分析，传统的电气系统大多采用点对点的单一通信方式，相互之间少有联系，这样必然造成庞大的布线系统。据统计，一辆采用传统布线方法的高档汽车中，其导线长度可达2000米，电气节点达1500个，而且，根据统计，该数字大约每十年增长1倍。无论从材料成本还是工作效率看，传统布线方法都将不能适应汽车的发展。从信息共享角度分析，现代典型的控制单元有电控燃油喷射系统、电控传动系统、防抱死制动系统（ABS）、防滑控制系统（ASR）、废气再循环控制、巡航系统和空调系统。为了满足各子系统的实时性要求，有必要对汽车公共数据实行共享，如发动机转速、车轮转速、油门踏板位置等。但每个控制单元对实时性的要求是因数据的更新速率和控制周期不同而不同的。这就要求其数据交换网是基于优先竞争的模式，且本身具有较高的通信速率，CAN总线正是为满足这些要求而设计的。 8~48 % 二、CAN总线技术优点 数据共享减少了数据的重复处理，节省了成本。比如，对于具有CAN总线接口的电喷发动机，其它 电器 可共享其提供的转速、水温、机油压力、机油温度、油量瞬时流速等等，一方面可省去额外的水温、油压、油温传感器，另一方面可以将这些数据显示在仪表上，便于司机检查发动机运行工况，从而便于发动机的保养维护。 再比如，电涡流缓速器、空气悬架、门控制及巡航定速控制都用到车速数据，结果这些电器都有一套车速处理电路，浪费了资源。而采用总线技术后，大家都从总线上即可获得车速数据。 减少车身布线，进一步节省了成本。由于采用总线技术，模块之间的信号传递仅需要两条信号线。布线局部化，车上除掉总线外，其他所有横贯车身的线都不再需要了，节省了布线成本。另外，数据共享也节省了线路，还拿车速信号打比方，在没有总线的情况，车速信号要接到电涡流缓速器、空气悬架、门控制及电喷发动机。有了总线后只要接到一处，其他电器通过总线共享。
一、汽车电子的分类 1、汽车电子控制装置 发动机控制系统：点火控制、燃油喷射控制、怠速控制、进气控制、排放控制、故障自诊断等 底盘控制系统：电子控制自动变速箱（ECT）、电控悬架（TEMS）、驱动防滑/牵引力控制（ASR/TRC）、巡航控制（CCS）、自动防抱死（ABS）、四轮转向控制等 车身电子控制系统：安全气囊（SRS）、安全带控制、灯光控制、电子仪表、电动座椅、电动车窗、中控门锁、倒车雷达、轮胎气压报警系统等 2、车载汽车电子装置 汽车信息系统：车辆行驶自身系统显示、车载通讯系统、上网设备、语音信息等 导航系统：电子导航系统、GPS定位系统等 娱乐系统：数字视频系统、数字音响等 二、汽车总线的分类 1、概况：总线技术采用若干的传感器、执行机构和ECU（Electronical Control Unit）公用一个公共的数据通道－－总线，在总线控制器的管理下共享传输通道，而不是每个通信的传感器、执行机构和ECU之间通过点对点连成复杂的网状结构。1998年摩托罗拉公司的一个报告显示，用总线网络技术代替宝马车的四门控制系统的点对点连线后，因此减少的连接线就有15公斤之多 2、美国汽车工程师协会（SAE）将汽车网络根据速率划分为A、B、C三个等级 A类：面向传感器/执行器控制的低速网络，速率通常只有1Kbps-10Kbps，主要应用于电动门窗、座椅调节、灯光照明等控制，主流技术为LIN； B类：面向独立模块间数据共享的中速网络，速率一般为10Kbps-100Kbps，主要应用于电子车辆信息中心、故障诊断、仪表显示、安全气囊等系统，主流技术为CAN； C类：面向高速、实时闭环控制的多路传输网，最高位速率可达1Mbps，主要用于悬架控制、牵引控制、先进发动机控制、ABS等系统，主流技术为CAN和FlexRay 3、多媒体信息系统总线标准（又称D类网络） 用于汽车信息娱乐和远程信息设备，特别是汽车导航系统，需要功能强大的操作系统和连接能力，MOST有可能成为主流技术 4、安全总线和标准（又称E类网络） 主要用于安全气囊系统，以连接加速度计、安全传感器等装置，为被动安全提供保障，Byteflight有可能成为主流技术 三、MOST总线技术介绍 MOST（ Media Oriented System Transport，多媒体信息系统总线标准）是专为汽车视频和音频流数据开发的光媒体基协议。它基于塑料光纤的通信协议，定义了标准 OSI 模型的所有七层，实现MOST 结点的主要部分包括光电接口（即发射器模块和接收器模块）和网络控制器IC MOST技术采用环行拓扑机构，可以传送同步数据(音频信号、视频信号等流动型数据)、非同步数据(访问网络及访问数据库等的数据包)和控制数据(控制报文及控制整个网络的数据) MOST 使得汽车制造商更加方便的在车内增加一系列的多媒体设备，如CD播放机、收音机、电视、DVD播放机、导航系统、车载电话和车载PC等。MOST得到包括BMW、Daimler Chrysler、Harman/Becker和SMSC (前 Oasis)公司的支持，已应用在多款车型上，如BMW7系列、Audi A-8、Mercedes E系列等高档车上 目前收发器模块的主要供应商是 Infineon公司，该公司最近推出了自己 ODIN MIT/MIR4 收/发模块的规格，标价大约为3欧元， Melexis 公司准备进入 MOST 收发器市场，开发的 MLX75600/02目标价格在 3欧元～3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/508eb2497ce478c153133813950bd5f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c14a2f6981ca4b435604408c38f1f79/" rel="bookmark">
			UISearchBar作为inputAccessoryView时的响应链
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		UISearchBar对象做为一个普通的视图对象添加到视图控制器的self.view中，定义、初始化、设置delegate，然后becomeFirstResponder，最后resignFirstResponder。
CGRect searchBarFrame= CGRectMake(0, 0, self.view.frame.size.width, 40);
_searchBar = [[UISearchBar alloc] initWithFrame:searchBarFrame];
[_searchBar setPlaceholder:@"Search"];// 搜索框的占位符
//[_searchBarsetPrompt:@"Prompt"];// 顶部提示文本,相当于控件的Title
[_searchBar setBarStyle:UIBarStyleDefault];// 搜索框样式
[_searchBar setTintColor:[UIColor blueColor]];// 搜索框的颜色，当设置此属性时，barStyle将失效
[_searchBar setTranslucent:YES];// 设置是否透明
//[_searchBarsetShowsCancelButton:YES];// 是否显示取消按钮
//[_searchBarsetShowsCancelButton:YES animated:YES];
_searchBar.delegate=self;
[self.view addSubView:_searchBar]; 这一切很正常，也很自然。
但是，这里的应用环境是将searchBar作为一个uiresponder子类的对象gridview的inputAccessoryView。
这样他的响应链条就复杂了。
我开始在searchBarTextDidBeginEditing方法中将searchBar的cancelButton展现出来，然后在searchBarTextDidEndEditing方法中将cancelButton关闭。
但是，我无论在cancel操作、search操作，及触摸虚拟键盘以外的点以调用视图控制器上的touchbegin方法，来resignFirstResponder。
这三个调用方法，都能将searchBar的第一响应者resign掉，但就是不能调用searchBarShouldEndEditing。
在整个响应链条中，当gridview变成firstResponder时，searchBar做为inputAccessoryView出现，再触摸searchBar的搜索框时，firstResponder发生了变化。
gridview不再是firstResponder，searchBar变成了firstResponder。再searchBar进行resignFirstResponder后，gridView又变成了firstResponder。
这个过程理解好，在应用中需要小心处理好这种响应链条的传递操作。
不知道是不是因为firstResponder还在，所以没有调用作为searchBar的delegate的searchBarTextDidEndEditing方法。
将searchBar的delegate所有方法研究一下，发现还有两个方法可以用，可以用来实现这种cancelButton随着firstResponder变化而展现、消失。
这两个方法是searchBarShouldEndEditing和searchBarShouldEndEditing，在firstResponder变化前都会调用这两个方法。
在触摸searchBar的搜索框时，searchBar就变成了firstResponder，那么在这时，会调用searchBarShouldEndEditing。
在我们将searchBar的firstResponder身份取消时，又会调用searchBarShouldEndEditing。那么，我们可以在这两个方法中实现我们要的功能。
结论，关键是理解整个响应链条。在视图控制器类中，gridview首先变成firstResponder，再searchBar变成firstResponder。
然后逐步resignFirstResponder，即使在self.view endEditing。也逐步操作。
代码 -(void)searchBarTextDidBeginEditing:(UISearchBar *)searchBar
{
//无法调用 cancelbuttong 的 关闭功能， 妥协 不用这个吧。
// [_searchBarsetShowsCancelButton:YES animated:YES];
// 发现放到searchBarShouldBeginEditing 方法中也能实现这个功能，
// 在方法searchBarShouldEndEditing 中可以 将 cancelbutton 关闭掉。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c14a2f6981ca4b435604408c38f1f79/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75e39d874953e0d04d0c590b83219189/" rel="bookmark">
			深入详解标准C语言 IO
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载自：http://blog.csdn.net/sun_top/article/details/4235992 标准 C I/O
函数列表：
clearerr() 清除错误 fclose() 关闭一个文件 feof() 如果到达文件尾(end-of-file)返回"True"(真) ferror() 检查一个文件错误 fflush() 书写输出缓存的内容 fgetc() 从流获取一个字符 fgetpos() 获取文件位置指针 fgets() 从一个流获取一串字符 fopen() 打开一个文件 fprintf() 打印格式化的输出到一个文件 fputc() 写一个字符到一个文件 fputs() 写一个字符串到一个文件 fread() 从一个文件读取 freopen() 用一个不同的名称打开一个存在的流 fscanf() 从一个文件读取一个格式化的输入 fseek() 在文件中移动到一个指定的位置 fsetpos() 在一个文件中移动到一个指定的位置 ftell() 返回当前文件的位置指针 fwrite() 写入一个文件 getc() 从一个文件读取一个字符 getchar() 从STDIN(标准输入)读取一个字符 gets() 从STDIN(标准输入)读取一个字符串 perror() 显示当前错误的一个字符串版本到STDERR(标准错误输出) printf() 写格式化的输出到STDOUT(标准输出) putc() 写一个字符到一个流 putchar() 写一个字符到STDOUT(标准输出) puts() 写一个字符串到STDOUT(标准输出) remove() 清除一个文件 rename() 重命名一个文件 rewind() 移动文件位置指针到一个文件的开始处 scanf() 从STDIN(标准输入)读取格式化输入 setbuf() 设置一个指定流的缓冲区 setvbuf() 设置一个指定流的缓冲区和大小 sprintf() 写格式化的输出到缓冲区 sscanf() 从一个缓冲区读取格式化的输入 tmpfile() 返回一个到一个临时文件的指针 tmpnam() 返回一个独特的文件名 ungetc() 把一个字符放回一个流 vprintf, vfprintf, vsprintf 写用参数列表格式化输出
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/75e39d874953e0d04d0c590b83219189/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/560/">«</a>
	<span class="pagination__item pagination__item--current">561/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/562/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>