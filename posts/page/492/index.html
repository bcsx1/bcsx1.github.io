<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/875436cb21b2113a0d17c6f6da492fd7/" rel="bookmark">
			c# 无边框窗体的边框阴影
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Windows API:
using System; using System.Collections.Generic; using System.ComponentModel; using System.Data; using System.Drawing; using System.Linq; using System.Text; using System.Windows.Forms; using System.Runtime.InteropServices; namespace BaseForm { public partial class FormEnumlator : Form { public FormEnumlator() { InitializeComponent(); this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.None; this.SetStyle(ControlStyles.AllPaintingInWmPaint | ControlStyles.OptimizedDoubleBuffer, true); SetClassLong(this.Handle, GCL_STYLE, GetClassLong(this.Handle, GCL_STYLE) | CS_DropSHADOW); //API函数加载，实现窗体边框阴影效果 Location = new Point(0,0); // this.StartPosition = FormStartPosition.Manual; } private bool _IsMouseDown; private Point _oldLocation; private Point _startPoint; #region 窗体边框阴影效果变量申明 private const int CS_DropSHADOW = 0x20000; private const int GCL_STYLE = (-26); //声明Win32 API [DllImport("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/875436cb21b2113a0d17c6f6da492fd7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd627f0614d20a0597c585dafd1234bb/" rel="bookmark">
			RePlugin源码解析之—插件的安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RePlugin插件的安装 RePlugin插件的安装流程相对简单点，整个安装其实就是将APK文件中的dex，res, so等移动到一个特定的路径的过程。
插件具体的安装流程 无论是插件的安装和启动，RePlugin对外暴露的都是RePlugin.java提供的接口.
对于安装会调用install方法： 源码路径:replugin-host-library\replugin-host-lib\src\main\java\com\qihoo360\replugin
/** * 安装或升级此插件 &lt;p&gt; * 注意： &lt;p&gt; * 1、这里只将APK移动（或复制）到“插件路径”下，不释放优化后的Dex和Native库，不会加载插件 &lt;p&gt; * 2、支持“纯APK”和“p-n”（旧版，即将废弃）插件 &lt;p&gt; * 3、此方法是【同步】的，耗时较少 &lt;p&gt; * 4、不会触发插件“启动”逻辑，因此只要插件“当前没有被使用”，再次调用此方法则新插件立即生效 * * @param path 插件安装的地址。必须是“绝对路径”。通常可以用context.getFilesDir()来做 * @return 安装成功的插件信息，外界可直接读取 * @since 2.0.0 （1.x版本为installDelayed） */ public static PluginInfo install(String path) { ... // 若为p-n开头的插件，则必须是从宿主设置的“插件安装路径”上（默认为files目录）才能安装，其余均不允许 if (path.startsWith("p-n-")) { String installPath = RePlugin.getConfig().getPnInstallDir().getAbsolutePath(); if (!path.startsWith(installPath)) { if (LogDebug.LOG) { LogDebug.e(TAG, "install: Must be installed from the specified path. Path="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd627f0614d20a0597c585dafd1234bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/027994d8608c4f7d39de23f96c1bada2/" rel="bookmark">
			IMX6UL eMMC初始化流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境 在uboot中分析emmc初始化流程代码，emmc在uboot中方便添加命令和打印调试，uboot版本：2017.03
开机打印 uboot启动打印
U-Boot 2017.03-g101318f (Jan 09 2019 - 17:37:10 +0800) CPU: Freescale i.MX6UL rev1.2 696 MHz (running at 396 MHz) CPU: Automotive temperature grade (-40C to 125C) at 58C Reset cause: WDOG Model: Freescale i.MX6 UltraLite 14x14 EVK Board Board: MX6UL 14x14 EVK DRAM: 256 MiB SF: Detected n25q256 with page size 256 Bytes, erase size 4 KiB, total 32 MiB Hardware version: 0x0401 MMC: board_mmc_init CONFIG_MX6UL_14X14_EVK_EMMC_REWORK FSL_SDHC: 0 Using default environment SF: Detected n25q256 with page size 256 Bytes, erase size 4 KiB, total 32 MiB In: serial Out: serial Err: serial SF: Detected n25q256 with page size 256 Bytes, erase size 4 KiB, total 32 MiB Net: eth1: ethernet@020b4000, eth0: ethernet@02188000 [PRIME] Normal Boot Hit any key to stop autoboot: 0 内核启动打印
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/027994d8608c4f7d39de23f96c1bada2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d03c86df81d76352693864c7f43d244/" rel="bookmark">
			PyTorch实现简单的图神经网络
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文首发于个人站点 基于PyTorch-DGL 实现图卷积网络 | 梦家
更新：
在此附上图卷积网络GCN理论篇：
图卷积网络GCN（Graph Convolution Network）（一）研究背景和空域图卷积图卷积网络GCN（Graph Convolution Network）（二）图上的傅里叶变换和逆变换图卷积网络GCN（Graph Convolution Network）（三）详解三代图卷积网络理论 基于PyTorch框架实现图卷积神经网络 项目源代码参考本人Github.
依赖库 DGL 0.1.3PyTorch 0.4.1networkX 2.2 利用DGL构建图 # -*- coding: utf-8 -*- """ @Date: 2019/1/11 @Author: dreamhome @Summary: DGL graph. """ import dgl import torch import networkx as nx import matplotlib.pyplot as plt def build_karate_club_graph(): g = dgl.DGLGraph() # add 34 nodes into the graph; nodes are labeled from 0~33 g.add_nodes(34) # all 78 edges as a list of tuples edge_list = [(1, 0), (2, 0), (2, 1), (3, 0), (3, 1), (3, 2), (4, 0), (5, 0), (6, 0), (6, 4), (6, 5), (7, 0), (7, 1), (7, 2), (7, 3), (8, 0), (8, 2), (9, 2), (10, 0), (10, 4), (10, 5), (11, 0), (12, 0), (12, 3), (13, 0), (13, 1), (13, 2), (13, 3), (16, 5), (16, 6), (17, 0), (17, 1), (19, 0), (19, 1), (21, 0), (21, 1), (25, 23), (25, 24), (27, 2), (27, 23), (27, 24), (28, 2), (29, 23), (29, 26), (30, 1), (30, 8), (31, 0), (31, 24), (31, 25), (31, 28), (32, 2), (32, 8), (32, 14), (32, 15), (32, 18), (32, 20), (32, 22), (32, 23), (32, 29), (32, 30), (32, 31), (33, 8), (33, 9), (33, 13), (33, 14), (33, 15), (33, 18), (33, 19), (33, 20), (33, 22), (33, 23), (33, 26), (33, 27), (33, 28), (33, 29), (33, 30), (33, 31), (33, 32)] # add edges two lists of nodes: src and dst src, dst = tuple(zip(*edge_list)) g.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d03c86df81d76352693864c7f43d244/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a0bda4f071f5679ff1be04a31058d35/" rel="bookmark">
			springAop看这篇就够了--  Spring AOP是什么？你都拿它做什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为什么会有面向切面编程（AOP）？我们知道Java是一个面向对象（OOP）的语言，但它有一些弊端，比如当我们需要为多个不具有继承关系的对象引入一个公共行为，例如日志、权限验证、事务等功能时，只能在在每个对象里引用公共行为。这样做不便于维护，而且有大量重复代码。AOP的出现弥补了OOP的这点不足。
为了阐述清楚Spring AOP，我们从将以下方面进行讨论：
代理模式
静态代理原理及实践
动态代理原理及实践
Spring AOP原理及实战
代理模式
代理模式：为其他对象提供一种代理以控制对这个对象的访问。这段话比较官方，但我更倾向于用自己的语言理解：比如A对象要做一件事情，在没有代理前，自己来做；在对 A 代理后，由 A 的代理类 B 来做。代理其实是在原实例前后加了一层处理，这也是 AOP 的初级轮廓。
静态代理原理及实践
静态代理模式：静态代理说白了，就是在程序运行前就已经存在代理类的字节码文件、代理类和原始类的关系在运行前就已经确定。废话不多说，我们看一下代码。为了方便阅读，博主把单独的 class 文件合并到接口中，读者可以直接复制代码运行：
package test.staticProxy; // 接口 public interface IUserDao { void save(); void find(); } //目标对象 class UserDao implements IUserDao{ @Override public void save() { System.out.println("模拟：保存用户！"); } @Override public void find() { System.out.println("模拟：查询用户"); } } /** * 静态代理 * 特点： * 2. 目标对象必须要实现接口 * 2. 代理对象，要实现与目标对象一样的接口 */ class UserDaoProxy implements IUserDao{ // 代理对象，需要维护一个目标对象 private IUserDao target = new UserDao(); @Override public void save() { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5a0bda4f071f5679ff1be04a31058d35/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43f821ffb65dab17078e48b2065c0ba2/" rel="bookmark">
			redis hash只能存储string类型？解决：redisTemplate 存储序列化对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上一篇博文中
讲了redisTemplate的hash数据类型存储｛key(String)-&gt;value(string)｝的方法；
但是实际清楚我们存储对象应该是{key(string)-&gt;value(object)}类型的。
开始测试的时候，报错为 object can not cast to object，发现redis的hash类型只能存储string类型的数据。后经翻阅资料，找到存储序列化对象的方法解决。
实现serializable接口的作用就是可以把对象转化为字节流，并且可以反序列化恢复，对象实现序列化可以进行网络传输，在分布式应用中，就需要进行序列化对象的操作。
implements Serializable实现对象可序列化：
pojo实现serializable接口，使其能够被序列化 import java.io.Serializable; import com.baomidou.mybatisplus.annotation.IdType; import com.baomidou.mybatisplus.annotation.TableId; public class Student implements Serializable { @TableId(type=IdType.AUTO)//标志主键为自增 private int stuid; private String stuname; private int status; 序列化对象并存储 public void setmap() throws FileNotFoundException, IOException, ClassNotFoundException{ //这里使用序列化器Jackson2JsonRedisSerializer让redisTemplate支持序列化 redisTemplate.setHashValueSerializer(new Jackson2JsonRedisSerializer&lt;&gt;(Student.class)); //更新redisTemplate this.redisTemplate=redisTemplate; //为hash设置存储类型(map标志键名，散列key，散列value) HashOperations&lt;String, String, Object&gt; miaoshamap=redisTemplate.opsForHash(); //从数据库获取student列表 List&lt;Student&gt; stulist=findall(); for (Student student : stulist) { //序列化对象操作 ObjectOutputStream obi=null; ByteArrayOutputStream bai=null; bai=new ByteArrayOutputStream(); obi=new ObjectOutputStream(bai); obi.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43f821ffb65dab17078e48b2065c0ba2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5bf0cd104a2a5b8185b2a5317276c1bb/" rel="bookmark">
			ES6中的块级作用域与函数声明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先，在ES5的标准中，函数是不能在块级作用域中声明的。
if(true){ function foo(){} } try{ function foo(){} } catch(e){ } 也就是说类似以上两种情况在ES5中都是非法的。然而，浏览器为了兼容旧代码所以并没有遵守这一规定。所以上面的代码在浏览器中运行并不会出错。
而在ES6的标准中引入了块级作用域，也确定了函数是能够被声明在块级作用域内的。同时还规定了，在块级作用域中声明的函数类似于使用let声明的变量，只能在块级作用域内有效。
function foo(){console.log('Hello');} (function (){ if(false){ function foo(){console.log('World');} } foo(); }()); 上述代码若在ES5中运行，则会输出"World"，原因则是因为发生了函数提升。即真正执行的代码如下，
function foo(){console.log('Hello');} (function (){ function foo(){console.log('World');} if(false){ } foo(); }()); function foo(){console.log('Hello');} (function (){ if(false){ function foo(){console.log('World');} } foo(); }()); 但若是按ES6的标准，上面的代码应该输出的是"Hello"，这样也是符合直觉的一个结果。因为按照前文的说法，声明的在if语句中的函数应该无法影响外部的作用域。
但是运行结果却让人大跌眼镜，
那么问题出在哪儿呢？原因还是出在对老代码的兼容性上，所以实现跟标准还是存在着出入。
允许在块级作用域内声明函数。函数声明类似于var，即会提升到全局作用域或函数作用域的头部。同时，函数声明还会提升到所在的块级作用域的头部。 那么按照这三条规则来看，上面的代码应该是下面的样子的，
function foo(){console.log('Hello');} (function (){ var foo = undefined; if(false){ function foo(){console.log('World');} } foo(); }()); 所以，这样就能理解为啥报错会提示foo不是一个函数了，因为它是一个undefined。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33934df0975577c630c742f08e8729e3/" rel="bookmark">
			css设置图片右上删除按钮
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考：https://blog.csdn.net/qq_33464127/article/details/77506461
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset="UTF-8"&gt;
&lt;title&gt;&lt;/title&gt;
&lt;script src="../js/jquery-1.9.1.min.js"&gt;&lt;/script&gt;
&lt;style type="text/css"&gt;
.imgDiv {
display: inline-block;
position: relative;
}
.imgDiv .delete {
position: absolute;
top: 0px;
right: 0px;
width: 10px;
height: 10px;
/*display: none; */
}
&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;script type="text/javascript"&gt;
// $(document).ready(init);
// function init() {
// $(".imgDiv").mouseenter(function () {
// $(this).find(".delete").show();
// // });
// // // $(".imgDiv").mouseleave(function () {
// $(this).find(".delete").hide();
// });
// // }
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/33934df0975577c630c742f08e8729e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9034aa458add31c9c795b8eed4601f3c/" rel="bookmark">
			python键盘监听及模拟键盘输入keyboard
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		# -*- coding: utf-8 -*- """ Created on Sat Jan 12 14:19:56 2019 QQ群：476842922(欢迎加群讨论学习) @author: Administrator """ import sys, os from pynput.keyboard import Controller,Key,Listener # 监听按压 def on_press(key): try: print("正在按压:",format(key.char)) except AttributeError: print("正在按压:",format(key)) # 监听释放 def on_release(key): print("已经释放:",format(key)) if key==Key.esc: # 停止监听 return False # 开始监听 def start_listen(): with Listener(on_press=on_press,on_release=on_release) as listener: listener.join() if __name__ == '__main__': # 实例化键盘 kb=Controller() # 使用键盘输入一个字母 kb.press('a') kb.release('a') # 使用键盘输入字符串,注意当前键盘调成英文 kb.type("hello world") # 使用Key.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9034aa458add31c9c795b8eed4601f3c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e8fad1be0925a652318703d8fa63613/" rel="bookmark">
			redis java hash存储对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： redis缓存的hash数据类型可以让用户将多个key-value对存储到一个redis键里，适合用来存储对象。本文介绍在spring-redis环境上使用RedisTemplate操作对象。接下来的测试是建立在spring-redis环境上的，没有整合spring redis环境则无法与redis缓存进行交互。 实际操作： 创建对象并以hash数据类型保存到redis缓存 package com.server; import java.util.Map; import java.util.concurrent.TimeUnit; import org.redisson.api.RedissonClient; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.data.redis.core.HashOperations; import org.springframework.data.redis.core.RedisTemplate; import org.springframework.stereotype.Service; import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper; import com.pojo.Student; @Service public class StudentServer { @Autowired private RedisTemplate redisTemplate;//redisTemplate操作redis public void setmap(){ Student stu=new Student(); stu.setStuid("1001"); stu.setStuname("hashtest");//生成一个Student对象 stu.setStugender("man"); //标志map的键、标志value的key、value HashOperations&lt;String, String, String&gt; map=redisTemplate.opsForHash(); //向键名为stu.getStuid的map对象存储key-value对 map.put(stu.getStuid, "name", stu.getStuname); map.put(stu.getStuid, "gender", stu.getStugender); //设置100 seconds存活时间 redisTemplate.expire(stu.getStuid, 100, TimeUnit.SECONDS); } 运行之后：
. 用 hgetall map键名 命令查看redis缓存中的hash数据；. 用 hget map键名 key 命令查看指定key的value；.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e8fad1be0925a652318703d8fa63613/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e4aa4f4b02d3b6f4b5b3963b10bddac/" rel="bookmark">
			ZooKeeper 监听之持续监听java代码实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import static org.junit.Assert.*;
import java.io.IOException;
import java.util.List;
import org.apache.zookeeper.CreateMode;
import org.apache.zookeeper.WatchedEvent;
import org.apache.zookeeper.Watcher;
import org.apache.zookeeper.ZooDefs.Ids;
import org.apache.zookeeper.ZooKeeper;
import org.apache.zookeeper.data.Stat;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;
public class ZKTest {
private String connectString="hadoop101:2181,hadoop102:2181,hadoop103:2181";
private int sessionTimeout=5000;
private ZooKeeper zooKeeper;
// zkCli.sh @Before
public void testConnection() throws Exception {
zooKeeper = new ZooKeeper(connectString, sessionTimeout, new Watcher() {
// process 是watcher的回调方法
@Override
public void process(WatchedEvent event) {
System.out.println(event);
}
});
System.out.println(zooKeeper.getState());
}
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e4aa4f4b02d3b6f4b5b3963b10bddac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb8e29f992e928c2dd07e0835dff3388/" rel="bookmark">
			整理3种常用滚动到底部的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		滚动到底部的常见需求多来自于消息的聊天对话框
场景一:小程序聊天对话框滚动到底部实现
data: { scrollTop: 10000000 }, getPrivateLetterInfo(){ //在请求数据完成之后,直接设置就好,就可以让对话框滚动条置于底部 this.setData({ scrollTop: 10000000000000 }) } 场景二:pc端在vue中利用jquery将消息对话框滚动条置于最底部(在消息请求完成以后调用此方法就行)
methods:{ setBottom(){ setTimeout(()=&gt;{ $('#top').scrollTop(10000) },100) } } mounted(){ this.setBottom(); } 场景三:因为尝试用原生的网上的方法,但是scrollTop一直为0,我解决不了,于是就放弃了那个方法,选择了下面这个方法,实现了滚动条保持在最底部注意滚动产生的元素是外部包裹元素,不是每一条消息内容
下面这个div是产生滚动条的元素
&lt;div class='scroll-div' ref="scrollContent"&gt; &lt;/div&gt; methods:{ // 滚送到底部 setBottom(){ const me = this; setTimeout(()=&gt;{ this.$nextTick(() =&gt; {//一定要在this.$nextTick进行设置 me.$refs.scrollContent.scrollTop = 100000; }) },100) }, }, created(){ this.setBottom(); }, updated:function(){ this.setBottom(); } 注意在消息请求完成之后需要调用一次该函数,才能将消息置于最底部.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a38fd9cd12e1f966af516c275c0246b/" rel="bookmark">
			win10做好备份如何恢复系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		不知不觉，Windows 10系统已经进入秋季创意者更新版本(1709)了，
之前类似一键还原精灵之类的软件，对win10及SSD硬盘的支持越来越吃力，
索性就丢开第三方的工具，好好研究一下Win10系统自带的备份，恢复功能。
本文按照“备份”、“恢复”、“重置”三个方面探讨如何利用系统自带功能玩转系统备份、恢复：
一、备份：
按照如下路径进入系统备份功能界面：“开始” --&gt; “设置” --&gt; “更新和安全” --&gt; “备份” --&gt; “正在查找较旧的备份” --&gt; “转到"备份和还原(Windows7)” --&gt; “创建系统映像”
1、选择系统备份文件的存储位置，可以选择另一块硬盘的任意分区(系统推荐)，也可以选择同一块硬盘的另外一个分区(比如D盘)(大部分人只有一块硬盘，别无选择了:-))
2、选择要备份的分区，默认包含引导分区(默认500MB)和系统分区(默认C盘)
3、确认要备份的分区信息及备份后的文件大小及位置。
4、点击“开始备份”后就启动备份程序了。 5、备份完成后，会提示是否再创建一个备份光盘，在光盘接近绝迹的情况下，当然选择“否”啦！:-) ,到此备份就完成了。
6、备份完成后，我们还要核对一下备份的文件，按照你选择的备份地址，“WindowsImageBackup”目录就是备份文件的保存目录，那2个“vhdx”文件就是备份的核心文件了。
上一篇文章讲了如何备份，这篇就要讲重点，如何用Win10自带功能恢复系统。
先说明系统结构：
系统版本：Windows 10 (1709)
硬盘1(50GB)：C盘(系统盘)，D盘(数据盘)，引导盘(500MB)
硬盘2(40GB)：E盘
一、相同硬盘，不同分区的系统恢复(从D盘恢复系统到C盘)：
大部分情况下，我们只有一块硬盘，平时备份系统(C盘)到D盘，当系统有问题的时候，从D盘恢复系统。
有三种方法可以进入系统恢复程序：
1)、“开始” --&gt; “设置” --&gt; “更新和安全” --&gt; “恢复” --&gt; “高级启动” --&gt; “立即重新启动”
2)、“开始” --&gt; “电源” --&gt; “重启”+Shift
3)、“开始”(右键) --&gt; “运行” --&gt; "shutdown -r -o"
1、进入系统恢复程序界面后，选择“疑难解答”： 2、在高级选项选择“系统映像恢复”，系统会重启，并进入恢复执行界面。
3、系统重启后，选择一个有管理员权限的账户，进行系统恢复的授权。
4、输入相应账户的密码：
5、如果有多个备份项目，选择其中一个来作为恢复源：
6、确认要进行系统恢复，系统恢复完成后，系统的状态会回来备份当天，当然仅限于C盘，其它盘数据不变。
7、 系统还原中。注意：不要轻易点击"停止还原"按钮，否则会造成系统崩溃，不能开机的情况。
8、系统还原完成，重启后即可正常进入系统了。想起了那句广告语：“轻轻一按，昨日重现！” ^_^
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a38fd9cd12e1f966af516c275c0246b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ab3b46b2144f98828c82025497574cd/" rel="bookmark">
			if elif 和if if的区别和好处
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载：https://blog.csdn.net/Emily0308/article/details/79106397
如果程序中判断事件很多，全部用if的话，会遍历整个程序， 用elif 程序运行时，只要if或后续某一个elif之一满足逻辑值为True，则程序执行完对应输出语句后自动结束该轮if-elif（即不会再去冗余地执行后续的elif或else）。 提高效率
a = 88
if a &gt;= 90:
print(“优秀”)
elif a &gt;=80:
print(“良好”)
elif a &gt;= 70:
print(“中等”)
elif a &gt;= 60:
print(“及格”)
总结： 当匹配到if或者elif语句判断为True的时候，那么不会执行下面elif以及else里面的语句；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/888e07ea1cedcb0f712c5c175fbd34a5/" rel="bookmark">
			RabbitMq（1）死信队列、延迟队列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、死信队列 DLX（Dead Letter Exchange），死信交换器。当队列中的消息被拒绝、或者过期会变成死信，死信可以被重新发布到另一个交换器，这个交换器就是DLX，与DLX绑定的队列称为死信队列。
造成死信的原因：
信息被拒绝信息超时超过了队列的最大长度 可以通过设置x-dead-letter-exchange参数指定DLX，设置x-dead-letter-routing-key指定DLX使用的路由键。
Map&lt;String, Object&gt; arg = new HashMap&lt;String, Object&gt;(); // 设置DLX arg.put("x-dead-letter-exchange", "exchange.dlx"); // 设置DLX路由键， arg.put("x-dead-letter-routing-key", "routingkey.dlx"); // 设置消息过期时间，消息过期后，会重新发布到DLX arg.put("x-message-ttl", 5000); channel.queueDeclare("queue.normal", true, false, false, arg); 代码实现：
public class DLX { public static void main(String[] args) throws IOException, TimeoutException { ConnectionFactory factory = new ConnectionFactory(); ConnectionFactory factory = new ConnectionFactory(); factory.setHost("192.168.79.108"); factory.setPort(5672); factory.setUsername("root"); factory.setPassword("root"); Connection connection = factory.newConnection(); Channel channel = connection.createChannel(); // DLX channel.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/888e07ea1cedcb0f712c5c175fbd34a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/749c4bd1b3c4e1009351b1811a189550/" rel="bookmark">
			kafka动态配置topic
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前使用@org.springframework.kafka.annotation.KafkaListener这个注解的时候，是在yml文件中配置，然后使用@KafkaListener(topics = {"${kafka.topic.a2b.name}"})，这样去单独监听某一个topic，生产者也固定在代码里定义变量读取配置文件。昨天改了个需求，希望以后通过配置文件去动态配置生产者和消费者的topic（不知道个数和topic名字），而不需要改代码。
一、踩坑 刚开始的时候，由于考虑不充分（没有考虑到topic个数未知），想到@KafkaListener注解中的topics本身就是个字符串数组，于是想通过传入变量的形式。产生了以下两种方法：
1.传入变量方法一 使用@Value注解提取配置文件中相关配置，@KafkaListener中传入变量
public static String[] topicArr; @Value("${kafka.bootstrap.servers}") public void setTopicArr(String[] value){ String topicArr = value; } @KafkaListener(topics= topicArr) emmmm。。。结果可想而知，不行。
2.传入变量方法二 还是传入变量，不过这次写了个动态配置的代码
注解里这么写 @KafkaListener(topics = "${topicName1}","${topicName2}","${topicName3}") 提前将yml文件里添加 topics: topicName1,topicName2,topicName3 然后加载进来 @Value("${kafka.topics}") public void setTopics(String value){ topics = value; } 动态配置代码： @Configuration public class KafkaTopicConfiguration implements InitializingBean { @Autowired private KafkaConfig kafkaconfig; @Override public void afterPropertiesSet() throws Exception { String[] topicArr = kafkaconfig.split(","); int i = 1; for(String topic : topicArr){ String topicName = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/749c4bd1b3c4e1009351b1811a189550/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41751cfe2bf016927df0baafe86b7ef4/" rel="bookmark">
			第八章 虚拟字节码执行引擎
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		8.1 概述 执行引擎是Java虚拟机最核心的组成部分之一。虚拟机是一个相对于物理机的概念，这两种机器都有代码执行能力，其区别是物理机的执行引擎是直接建立在处理器、硬件、指令集和操作系统层面上的，而虚拟机的执行引擎则是由自己实现的，因此可以自行指定指令集与执行引擎的结构体系，并且能够执行那些不被硬件直接支持的指令集格式。
在Java虚拟机规范中制定了虚拟机字节码执行引擎的概念模型，这个概念模型成为各种虚拟机执行引擎的统一外观。从外观上看起来所有Java虚拟机执行引擎都是一致的：输入的是字节码文件，处理过程是字节码解析的等效过程，输出的是执行结果。
8.2 运行时栈帧结构 栈帧是用于支持虚拟机进行方法调用和方法执行的数据结构，他是虚拟机运行时数据区中的虚拟机栈的栈元素。栈帧存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息。每一个方法从调用开始到执行完成的过程，就对应着一个栈帧在虚拟机里面从入栈到出栈的过程。
每一个栈帧都包含了局部变量表、操作数栈、动态链接、方法返回地址和一些额外的附加信息。在编译程序代码的时候，栈帧中需要多大的局部变量表、多深的操作数栈都已经完全确定了，并且写入到方法表的code属性之中，因此一个栈帧需要分配多少内存，不会受到程序运行期变量数据的影响，而仅仅取决于具体的虚拟机实现。
一个线程中的方法调用链可能会很长，很多方法都同时处于执行状态。对于执行引擎来讲，活动线程中只有栈顶顶栈帧是有效的，成为当前栈帧，这个栈帧所关联的方法称为当前方法。执行引擎所运行的字节码指令都只针对当前栈帧进行操作。
8.2.1 局部变量表 局部变量表是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。局部变量表以变量槽为最小单位。虚拟机规范中并没有明确指明一个slot应占用的空间大小。reference是对象的引用，虚拟机规范没有说明他的长度，也没有明确指出这个引用应有怎样的结构，但一般来说，虚拟机实现至少都应当能从此引用中直接或间接的查找到对象在Java堆中的起始地址索引和方法区中的对象类型数据。对于64位的数据类型，虚拟机会以高位在前的方式为其分配两个连续的slot空间。由于局部变量表建立在线程的堆栈上，是线程私有的数据，无论读写两个连续的slot是否是原子操作，都不会引起数据安全问题。
在方法执行时，虚拟机使用局部变量表来完成参数值到参数变量列表的传递过程，如果是实例方法（非static方法），那么局部变量表中第0位索引的slot默认是用于传递方所属对象实例的引用，在方法中可以通过关键字“this”来访问这个隐含的参数。
8.2.2 操作数栈 操作数栈也常被称为操作栈，他是一个后入先出栈。同局部变量表一样，操作数栈的最大深度也是在编译的时候被写入到code属性max_stacks数据项之中。操作数栈的每一个元素可以是任意的Java数据类型，包括long和double.32位数据类型所占的栈容量为1，64位数据类型所占的栈容量为2.在方法执行的任何时候，操作数栈的深度都不会超过在max_stacks数据项中设定的最大值。
当一个方法开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令指向操作数栈中写入和读取内容，也就是入栈出栈操作。例如，在做算数运算的时候是通过操作数栈来进行的，又或者在调用其他方法的时候是通过操作数栈来进行参数传递的。
Java虚拟机的解释执行引擎称为“基于栈的执行引擎”，其中所指的栈就是操作数栈。
8.2.3 动态连接 每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。我们知道Class文件的常量池中存有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用为参数。这些符号引用一部分会在类加载阶段或第一次使用的时候转化为直接引用，这种转化成为静态解析。另外一部分将在每一次的运行期间转化为直接引用，这部分成为动态连接。
8.2.4 方法返回地址 当一个方法执行后，有两种方式退出这个方法。第一种方式是执行引擎遇到任意一个方法返回的字节码指令，这时候可能会有返回值传递给上层的方法调用者，是否有返回值和返回值的类型将根据遇到何种方法返回指令来决定，这种退出方法的方式称为正常完成出口。
另外一种退出方式是在方法执行过程中遇到了异常，并且这个异常没有在方法体内得到处理。无论是Java虚拟机内部产生的异常还是代码使用athrow字节码指令产生的异常，只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，这种退出方式称为异常完成出口。一个方法使用异常出口是不会给他的上层调用者产生任何返回值的。
8.3 方法调用 方法调用并不等同于方法执行，方法调用阶段唯一的任务就是确定被调用方法的版本（即调用哪一个方法），暂时还不涉及方法内部的具体执行过程。在程序运行时，进行方法调用是最普遍最频繁的操作，Class文件在编译过程中不包含传统编译的连接步骤，一切方法调用在Class文件里面存储的都只是符号引用，而不是方法在实际运行时内存布局中的入口地址（相当于之前所说的直接引用）。这个特性给Java带来了更强大的动态扩展能力，但也使得Java方法的调用过程变得相对复杂起来，需要在类加载期间甚至到运行期间才能确定目标方法的直接引用。
8.3.1 解析 所有方法的调用中的目标方法在Class文件里面都是一个常量池中的符号引用，在类加载的解析阶段，会将其中的一部分符号引用转化为直接引用。这种解析能成立的前提是：方法在程序运行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期是不改变的。换句话说，调用程序在程序代码写好，编译器进行编译时就必须确定下来。这类方法的调用称为解析。
解析调用一定是一个静态的过程，在编译期间就完全确定，在类装载的解析阶段就会把涉及的符号引用全部转变为可确定的直接引用，不会延迟到运行期再去完成。而分派调用则可能是静态的也可能是动态的，根据分派依据的宗量数可分为单分派和多分派。这两类分派方式两两组合就构成了静态单分派、静态多分派、动态单分派、动态多分派四种分派情况。
8.3.2 分派 分派调用过程会揭示多态性特征的一些最基本的体现（如重载和重写）。
静态分派：所有依赖静态类型来定位方法执行版本的分派动作都称为静态分派。静态分派的最典型应用就是方法重载。静态分派发生在编译阶段，因此确定静态分派的动作实际上不是由虚拟机来执行的。另外，编译器虽然能确定出方法的重载版本，但在很多情况下这个重载版本并不是唯一的，往往只能确定一个更加适合的版本。这种模糊的结论在由0和1构成的计算机世界中是个比较“稀罕”的事件，产生这种模糊结论的主要原因是字面量不需要定义，所以字面量没有显式的静态类型，他的静态类型只能通过语言上的规则去理解和推断。
动态分派与“重写”由很大关联。
转载于:https://www.cnblogs.com/strawqqhat/p/10602278.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1c107975a3d056ce881df89e5606019/" rel="bookmark">
			TensorFlow中读取图像数据的三种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Update on 2019.06.18 从tesorflow1.11之后，（大概是这个版本号），谷歌推出了tf.data模块来读取数据，甚至在tensorflow2.0中，取消了数据队列管道，所以我建议大家学习tf.data模块。未来我也会做详细的tf.data模块使用说明。
Upata on 2019.7.22
我已经更新了tf.data的使用方法。建议精读，一定能掌握tf.data API的使用方法。地址点击这里
本文面对三种常常遇到的情况，总结三种读取数据的方式，分别用于处理单张图片、大量图片，和TFRecorder读取方式。并且还补充了功能相近的tf函数。
处理单张图片 我们训练完模型之后，常常要用图片测试，有的时候，我们并不需要对很多图像做测试，可能就是几张甚至一张。这种情况下没有必要用队列机制。
import tensorflow as tf import matplotlib.pyplot as plt def read_image(file_name): img = tf.read_file(filename=file_name) #默认读取格式为uint8 print("img 的类型是",type(img)); img = tf.image.decode_jpeg(img,channels=0) # channels 为1得到的是灰度图，为0则按照图片格式来读 return img def main( ): with tf.device("/cpu:0"): img_path='./1.jpg' img=read_image(img_path) with tf.Session() as sess: image_numpy=sess.run(img) print(image_numpy) print(image_numpy.dtype) print(image_numpy.shape) plt.imshow(image_numpy) plt.show() if __name__=="__main__": main() img_path是文件所在地址包括文件名称，地址用相对地址或者绝对地址都行
输出结果为：
img 的类型是 &lt;class 'tensorflow.python.framework.ops.Tensor'&gt; [[[196 219 209] [196 219 209] [196 219 209] .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e1c107975a3d056ce881df89e5606019/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/faaf9407a284eec9782bb418857a6529/" rel="bookmark">
			解决&#34;No package npm available&#34;问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题
centos环境中没有nmp默认自带包，执行"yum install npm -y"的时候有提示"No package npm available"无安装包的错误提示。
解决方案
执行洗下面命令
rpm -Uvh http://dl.fedoraproject.org/pub/epel/6/x86_64/epel-release-6-8.noarch.rpm 安装成功后，再去执行yum install npm -y命令就可以安装成功了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d4e9a388610159dafd6b73b5e24c7ef/" rel="bookmark">
			【通俗易懂】关系模式范式分解教程 3NF与BCNF口诀!小白也能看懂
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本来是为了复习数据库期末考试，结果找了一圈都没有发现比较好的解释，通过查阅资料和总结，为大家提供通俗易懂的解法，一听就会！并且配有速记口诀！介是你没有玩过的船新版本包含最小依赖集求法候选码求法
在模式分解之前，首先对于1NF,2NF,3NF,BCNF做一个简明扼要的介绍。
1NF是指数据库表的每一列都是不可分割的基本数据项，即实体中的某个属性不能有多个值或者不能有重复的属性。
2NF要求属性完全依赖于主键，不能存在仅依赖主关键字一部分的属性。
3NF要求每一个非主属性既不部分依赖于码也不传递依赖于码。
BCNF消除了主属性对候选码的部分和传递函数依赖。
注：1.相对于BCNF，3NF允许存在主属性对候选码的传递依赖和部分依赖。
2.BCNF比较抽象，略作解释：在学生信息表里，学号是一个候选码，学号可确定学生姓名；(班级,学生姓名）也是一组候选码，有(班级,学生姓名）-&gt;学号，因此在主属性间形成了传递依赖。
3.若对概念不清晰，关于码、候选码、主属性、非主属性的解释可参看：
https://blog.csdn.net/sumaliqinghua/article/details/85872446#commentBox
我们的重点是讲解范式分解：
一、3NF分解 分为保持依赖和无损连接
为了说明求解保持依赖，我们先要会求最小依赖集
（1）最小依赖集求法：
口诀：右侧先拆单，依赖依次删。
还原即可删，再拆左非单。
通过求下面的最小依赖集对口诀进行解释，
（2）3NF分解：
口诀：
保函依赖分解题，先求最小依赖集。
依赖两侧未出现，分成子集放一边，剩余依赖变子集。
若要连接成无损，再添候选做子集。
下面通过几道例题讲解口诀：
例1.已知R(ABCDE), F={A -&gt;D,E-&gt;D,D-&gt;B,BC-&gt;D,DC-&gt;A}求保持函数依赖的3NF分解，和具有无损连接性及保持函数依赖的3NF分解
第一步：保函依赖分解题，先求最小依赖集。先求出R的最小依赖集，可得F={A -&gt;D,E-&gt;D,D-&gt;B,BC-&gt;D,DC-&gt;A}
第二步：依赖两侧未出现，分成子集放一边。首先可以发现没有不出现在两侧的元素不用单独分出一个子集，“剩余依赖变子集”然后我们将各依赖分别划分为子集得到：{AD} {ED} {DB} {BCD} {DCA}，即为所求保持函数依赖的3NF分解
第三步：若要连接成无损，再添候选做子集。
(1)候选码的求解：所谓候选码即能决定整个关系的，我们通过找未出现在依赖右边的和两侧均未出现的元素即可求得，
(2)可以发现C E未出现在右边，因此候选码为{CE}。故所求具有无损连接性及保持函数依赖的3NF分解为{AD} {ED} {DB} {BCD} {DCA} {CE}
例2.关系模式R,有U={A,B,C,D,E,G},F={B-&gt;G,CE-&gt;B,C-&gt;A,CE-&gt;G,B-&gt;D,C-&gt;D}，将关系模式分解为3NF且保持函数依赖
将关系模式分解为3NF且保持函数依赖：
第一步：保函依赖分解题，先求最小依赖集。先求出R的最小依赖集，
假设B-&gt;G冗余，则(B)+=BD,没有G故不冗余。
假设CE-&gt;B冗余，则（CE）+=CEGDA,没有B故不冗余。
假设C-&gt;A冗余，则（C）+=CD,故不冗余。
一次可以得到最小函数依赖集Fm={B-&gt;G,CE-&gt;B,C-&gt;A,B-&gt;D,C-&gt;D}
第二步：依赖两侧未出现，分成子集放一边，剩余依赖变子集。首先可以发现没有不出现在两侧的元素，然后我们将各依赖分别划分为子集得{BG} {CEB} {CA} {BD} {CD}，即为所求保持函数依赖的3NF分解
第三步：若要连接成无损，再添候选做子集。找到R的一个候选码为{CE}。故所求具有无损连接性及保持函数依赖的3NF分解为{BG} {CEB} {CA} {BD} {CD} {CE} (注：范式分解并不唯一，正确即可)
二、BCNF分解： 将关系模式R&lt;U,F&gt;分解为一个BCNF的基本步骤是
1）先求最小依赖集，候码非码成子集
3）余下左侧全候码，完成BCNF题。
例.关系模式R,有U={A,B,C,D,E,G},F={B-&gt;G,CE-&gt;B,C-&gt;A,CE-&gt;G,B-&gt;D,C-&gt;D}，将关系模式分解为3NF且保持函数依赖
将关系模式分解为3NF且保持函数依赖：
第一步：先求最小依赖集。可以发现CE-&gt;G多余，因此最小依赖集为F={B-&gt;G,CE-&gt;B,C-&gt;A,B-&gt;D,C-&gt;D}。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d4e9a388610159dafd6b73b5e24c7ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f72957300445f3dca72e8ba61db20519/" rel="bookmark">
			Mybatis collection 递归查询并自动装填所有子节点（多参数查询传入参数方法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求：项目中想实现无限下拉子菜单功能，后台就需要返回包括子节点的所有数据 数据库表结构如下：
上次是通过在java程序中递归不断通过父级id查询子节点实现的：
https://blog.csdn.net/lianzhang861/article/details/83783796
但这样需要不断连接和断开数据库，比较费时
mybatis可以在数据库内部实现递归查询被自动装填，由于省去了数据库连接步骤，访问速度会更快，但会增加数据库服务器压力，使用时根据实际情况定使用程序递归还是数据库递归
方式是使用 resultMap中的collection，此标签可以一对多级联
&lt;resultMap&gt; &lt;constructor&gt; //适用于不存在没有参数的构造方法 &lt;idArg&gt;&lt;/idArg&gt; &lt;arg&gt;&lt;/arg&gt; &lt;/constructor&gt; &lt;id/&gt;//这个对象的主键 &lt;association/&gt;//一对一级联 &lt;collection/&gt;//一对多级联 &lt;discriminator&gt;//鉴别器 &lt;case/&gt; &lt;/discriminator&gt; &lt;/resultMap&gt; 实现方法： 1.首先添加该表的实体类ArticleCategory
public class ArticleCategory { private String categoryId; private String categoryName; private String categoryParentId; //存放子节点 private List&lt;ArticleCategory&gt; subList; public String getCategoryId() { return categoryId; } public void setCategoryId(String categoryId) { this.categoryId = categoryId; } public String getCategoryName() { return categoryName; } public void setCategoryName(String categoryName) { this.categoryName = categoryName; } public List&lt;ArticleCategory&gt; getSubList() { return subList; } public void setSubList(List&lt;ArticleCategory&gt; subList) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f72957300445f3dca72e8ba61db20519/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ab555555615d3f00b0aab7ab0016b65/" rel="bookmark">
			kafka查看topic和消息内容命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、查询topic，进入kafka目录： bin/kafka-topics.sh --list --zookeeper localhost:2181 2、查询topic内容： bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic topicName --from-beginning 转载于:https://www.cnblogs.com/jylsgup/p/10247685.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81412d174c71aba3e1e5b7f734081f18/" rel="bookmark">
			centos7上安装docker 17.06ce，使用的xfs文件系统不支持d-type的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Jan 9 19:04:13 yanfa11 kernel: overlayfs: upper fs needs to support d_type. This is an invalid configuration. Jan 9 19:04:13 yanfa11 kubelet: W0109 19:04:13.327228 3021 pod_container_deletor.go:75] Container "b5882640988846582cadec740e7487413e78338f05bff827415d7d155ecb856b" not found in pod's containers Jan 9 19:04:13 yanfa11 kernel: overlayfs: upper fs needs to support d_type. This is an invalid configuration. Jan 9 19:04:13 yanfa11 kernel: overlayfs: upper fs needs to support d_type. This is an invalid configuration. Jan 9 19:04:13 yanfa11 kubelet: E0109 19:04:13.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/81412d174c71aba3e1e5b7f734081f18/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72fc5b37c89b9a55f57c065cfd1c274b/" rel="bookmark">
			虚幻4漏光问题解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		虚幻4漏光问题解决方法
https://www.engineworld.cn/thread-235-1-1.html
(出处: 引擎世界丨EngineWorld.CN)
漏光的问题，我再以前的虚幻社区发过一次，现在社区改版了，我在新社区重新发一次改版后的。另外还请大家尊重所有为社区奉献的人们所编写的原创文章版权，以免被不法分子拿去售卖或作为他用。
漏光问题，这个在虚幻4刚出来我就在着手研究，尤其是在LPV动态光照下会更加明显。现在的版本是4.12.3，LPV的光照优化了一点点（其实这一点点根本看不出来），虽然LPV现在来看就是个鸡肋，但毕竟在14年的项目中帮了很大的忙，还是要感谢它。首先每个引擎都会有漏光问题，除非未来的什么黑科技出现了，我所提出的2个解决方案可以解决90%以上的漏光项目，范围包括使用非静态构建的所有动态光照应用场景。
先上个地图，这个地图是官方自带的一个场景，里面包含lightmap分辨率为32到更高情况下的光照信息，以及法线正反面的模型被光照后的情况。如图：
漏光现象是指2个片面或者是阻挡物的相交部分被光照影响后出现的光源溢出现象，在官方的室内demo中，开发组采用了在模型外围添加了一个挡板来阻挡光线的照射，在同官方场景相同的解决方法有：
1、加大lightmap的分辨率，越高越好（要考虑自己计算机性能硬件）；
2、勾选双面材质，让物体的交叉板不单个片面。
除此之外，在动态光照环境下，开启动态光movable模式下，墙角会出现漏光现象，如果墙壁很厚，那么没事，如果墙壁很薄，就会出现漏光，如图：
一些开发者会说这地方漏光，配上材质或者什么得很难看到吧，不用这么纠结啊，可能我是个强迫症患者，如果遇到像这种游戏实际场景，强迫症就犯了：
所以出现这种方法，也不要着急，跟着我来调整一下参数，首先选择定向光，然后调整shadow bias和shadow filter sharpen参数，这两个参数的意思是阴影偏移与锐化，在UDK时代有一个摩尔条纹，shadow bias参数可以调整光照产生阴影的倾斜面，第二个锐化就不说了就是锐度，来一张图：
同时在动态光照下还有几个阴影参数可以选择：
主要的参数就是动态阴影参数、级联阴影参数，动态阴影参数控制显示的距离，超出一定的距离后你会看不到阴影，级联阴影和摩尔条纹的显示有那么一些些的联系，在UDK时期定向光倾斜一定角度后会出现不规则条状阴影，在级联阴影选项中可以有效控制，因为在调整shadow bias和shadow filter sharpen参数后会出现一些细微的条状阴影，使用两个参数来控制效果。
好了就到这里结束了，如果有什么问题可以在群里私聊我。。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7aade5ea1e238643b1b28d35a65b747e/" rel="bookmark">
			扫描微信二维码获取openid
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		扫描二维码后，通过微信网页授权机制，来获取用户基本信息，进而实现业务逻辑。
第一步：确定回调域名，即扫描二维码后你需要跳转的后台URL，例如：
http://www.haha.com/haha/detail?id=xxx http://www.haha.com：外网域名
/haha/detail?id=xxx：路径，生成二维码的条件
第二步：构造URL：
https://open.weixin.qq.com/connect/oauth2/authorize?appid=xxx&amp;redirect_uri=http://www.haha.com/haha/detail?id=xxx&amp;response_type=code&amp;scope=snsapi_userinfo&amp;connect_redirect=1#wechat_redirect" 1、https://open.weixin.qq.com/connect/oauth2/authorize?appid=xxx：是腾讯后台的Oauth2.0鉴权接口，是固定写法，appid为微信公众号的appid
2、redirect_uri=http://www.haha.com/haha/detail?id=xxx：第一步的回调域名（我没有对url进行编码，也可以正常传参，生成二维码，并获取扫描者的openid，原文处作者将url进行了编译，链接在下方）
url编译方式：在浏览器的开发者模式中的console中输入：encodeURIComponent('你的URL') 回车即可
3、response_type=code&amp;scope=snsapi_userinfo&amp;connect_redirect=1#wechat_redirect，见如下说明：
第三步：生成二维码
此处不特意声明了，生成二维码的方式有很多，大家可以自行百度（推荐两个：“草料二维码”，“QRCode”）
第四步：后台代码获取openid
思路：首先获取request中的code，然后通过code调用腾讯微信接口获取用户信息，其中就包括了openid（此处小编用的是MVC框架，原作者用的struts2，有需要的可以去参考，链接在下方）
此处小编只放了获取openid的方法，具体业务逻辑各位随意发挥了~
public String detail(HttpServletRequest request){ String code = request.getParameter("code"); net.sf.json.JSONObject wxUser = CoreService.getOpenid(code); String openid = wxUser.getString("openid"); } public class CoreService { public static String GETOPENID = "https://api.weixin.qq.com/sns/oauth2/access_token?appid=APPID&amp;secret=SECRET&amp;code=CODE&amp;grant_type=authorization_code"; /*通过code获取用户openid*/ public static JSONObject getOpenid(String code) throws IOException{ JSONObject jsonObject = null; String path = GETOPENID.replace("APPID", APPID).replace("SECRET", APPSECRET).replace("CODE", code); StringBuffer buffer = new StringBuffer(); URL url = new URL(path); HttpsURLConnection httpUrlConn = (HttpsURLConnection) url.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7aade5ea1e238643b1b28d35a65b747e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d54037bf2faf31fc1b508b39c38c8327/" rel="bookmark">
			FFMPEG错误速查。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		FFMPEG错误速查。自用。持续更新。
一些常见的FFERRTAG的值转换
AVERROR_BSF_NOT_FOUND = -1179861752
AVERROR_BUG = -558323010
AVERROR_DECODER_NOT_FOUND = -1128613112
AVERROR_DEMUXER_NOT_FOUND = -1296385272
AVERROR_ENCODER_NOT_FOUND = -1129203192
AVERROR_EOF = -541478725
AVERROR_EXIT = -1414092869
AVERROR_FILTER_NOT_FOUND = -1279870712
AVERROR_INVALIDDATA = -1094995529
AVERROR_MUXER_NOT_FOUND = -1481985528
AVERROR_OPTION_NOT_FOUND = -1414549496
AVERROR_PATCHWELCOME = -1163346256
AVERROR_PROTOCOL_NOT_FOUND = -1330794744
AVERROR_STREAM_NOT_FOUND = -1381258232
AVERROR_BUG2 = -541545794
AVERROR_UNKNOWN = -1313558101
/* * This file is part of FFmpeg. * include/libavutil/error.h * * FFmpeg is free software; you can redistribute it and/or * modify it under the terms of the GNU Lesser General Public * License as published by the Free Software Foundation; either * version 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d54037bf2faf31fc1b508b39c38c8327/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10f80abbc2619e559bebb6190aa8cfc4/" rel="bookmark">
			记录一些 FileZillaClient 的基本连接操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本地主机：Window 10FileZilla版本：3.39.0 64位远程主机：CentOS 6.4 需安装FTP服务 小提示：查看CentOS版本命令 # cat /etc/issue
FileZillaClient 是一款能够通过FTP、STFP 远程连接主机的免费开源软件
通过FTP协议连接的方法 FTP 百科介绍：
FTP（File Transfer Protocol，文件传输协议） 是 TCP/IP 协议组中的协议之一。FTP协议包括两个组成部分，其一为FTP服务器，其二为FTP客户端。其中FTP服务器用来存储文件，用户可以使用FTP客户端通过FTP协议访问位于FTP服务器上的资源。
默认情况下FTP协议使用TCP端口中的 20 和 21这两个端口，其中20用于传输数据，21用于传输控制信息。但是，是否使用20作为传输数据的端口与FTP使用的传输模式有关，如果采用主动模式，那么数据传输端口就是20；如果采用被动模式，则具体最终使用哪个端口要服务器端和客户端协商决定。
这里提到了主动和被动模式，那就简单的介绍一下吧：
主动模式（Standard）：就我浅见，客户端用 21端口与服务端建立连接，服务端通过 20端口向客户端发送数据。
被动模式（Passive）：建立连接同上，之后客户端发送Pasv命令，服务端收到Pasv命令后，随机打开一个高端端口（大于1024，需自行设置）向客户端发送数据。
ps：被动模式需要手动在服务端配置，方法如下：
# vim /etc/vsftpd/vsftpd.conf 在最底部加上
pasv_min_port=30000
pasv_max_port=30999
表示被动模式服务端口范围为30000~30999（可以随意改，大于1024即可）
重启一下vsftpd
# service vsftpd restart
防火墙 iptables 也要相应的开启这个端口范围
# vim /etc/sysconfig/iptables
添加下行
-A INPUT -m state --state NEW -m tcp -p tcp --dport 30000:30999 -j ACCEPT
主动模式的端口也要开启 分别是 20 21
-A INPUT -m state --state NEW -m tcp -p tcp --dport 20:21 -j ACCEPT
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/10f80abbc2619e559bebb6190aa8cfc4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7f06195b140710cdd043569363db2ce/" rel="bookmark">
			ip地址为61.179.150.39/28，问其子网号为多少，广播号为多少，可用ip地址范围是多少
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先清楚，
/28 代表前28位为网络位，自然后4位就为主机位。 其次，
子网号：网络位不变，主机位变0
广播号：网络位不变，主机位变1 所以，这里可以得到子网号为：61.179.150.32，就是将原来39的 0100 0111 变为了 0100 0000（网络位不变，主机位变0）
广播号为：61.179.150.47，也是讲原来的39的 0100 0111 变为了 0100 1111（网络位不变，主机位变0）
可用ip地址范围即子网号和广播号之间 ：61.179.150.33~61.179.150.46
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b65e2ca45bde63af5a4d91184b0d859a/" rel="bookmark">
			剖析Activiti源码扩展元素属性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 扩展的目标解析扩展属性底层源码元素属性的设计图解析自定义属性，存入业务系统表 扩展的目标 扩展activiti modeler 的元素属性,activiti modeler读取stencilset.json可动态自定义元素属性.
例如需要扩展状态码属性 { "name" : "stateCode", "properties" : [ { "id" : "stateCode", "type" : "String", "title" : "状态码", "value" : "", "description" : "状态码", "popular" : true } ] }, 自定义的元素ID为stateCode，则再对应的userTask的propertyPackages下注入 { "type" : "node", "id" : "UserTask", "title" : "人工任务", "description" : "指派给特定人来执行的人工任务", "propertyPackages" : ["stateCode" ], "hiddenPropertyPackages" : [ ], "roles" : [ "Activity", "sequence_start", "sequence_end", "ActivitiesMorph", "all" ] } 效果图 解析扩展属性 第一步已经实现了扩展UI编辑器，但是还需要在部署流程的时候同时解析写进bpm.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b65e2ca45bde63af5a4d91184b0d859a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c775a0e0ca1ede3a1af8514416a05b13/" rel="bookmark">
			微信access_token过期问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		WeChatAPIError: invalid credential, access_token is invalid or not latest
hint: [OwEKuA02878053!]
问题： 公众号网页开发，后台使用node去微信服务器换取access_token,微信token的有效时间为7200s，但是换取的token很短的时间就失效了。
解决： 刚开始以为是代码有问题，检查之后发现并没有问题。后来发现原来如果有其他地方重新获取token，那么原来的token将在5分钟之后过期，因为同事使用了同一个公众号获取token，所以我的token很快就失效了。因此同一个公众号的APPID和appsecret在一个工程内只使用同一个接口换取token，然后存储为全局token。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d41ab9a431b8a27b36b4e1915954f6c0/" rel="bookmark">
			Java判断对象是否为空的方法：isEmpty，null，&#34; &#34;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天修改辞职同事遗留的代码才发现这个问题，不能用isEmpty来判断一个对象是否为null，之前没在意这个问题，在报了空指针之后才发现这个问题。
查了一下关于判断为空的几个方法的区别，这里做一个简单的总结：
null 一个对象如果有可能是null的话，首先要做的就是判断是否为null：object == null，否则就有可能会出现空指针异常，这个通常是我们在进行数据库的查询操作时，查询结果首先用object != null，进行非空判断，然后再进行其他的业务逻辑，这样可以避免出现空指针异常。
isEmpty() 此方法可以使用于字符串，数组，集合都可以用。 首先看一下源码：
public boolean isEmpty() { return value.length == 0; } 这里是一个对象的长度，使用这个方法，首先要排除对象不为null，否则当对象为null时，调用isEmpty方法就会报空指针了。
要想返回true，也就是一个对象的长度为0，也就是说首先这个对象肯定不为null了，内容为空时，才能返回true。
这里我想到了之前看过视频里面说到的栈和堆的问题，当创建一个新的对象时，栈里面有一个对象，堆里面有一个对象，栈里的对象指向堆里面的对象。对象包含引用对象和实际对象，也就是栈和值的关系，比如String a = new String();，这句代码就在堆内存中产生了一个String对象""，和栈内存中一个引用对象a，也就是a指向了一个为空的字符串。当没有再次给引用对象a进行赋值时，操作a也即是操作这个空字符串。
栈内存:栈内存首先是一片内存区域，存储的都是局部变量，凡是定义在方法中的都是局部变量（方法外的是全局变量），for循环内部定义的也是局部变量，是先加载函数才能进行局部变量的定义，所以方法先进栈，然后再定义变量，变量有自己的作用域，一旦离开作用域，变量就会被释放。栈内存的更新速度很快，因为局部变量的生命周期都很短。
堆内存:存储的是数组和对象（其实数组就是对象），凡是new建立的都是在堆中，堆中存放的都是实体（对象），实体用于封装数据，而且是封装多个（实体的多个属性），如果一个数据消失，这个实体也没有消失，还可以用，所以堆是不会随时释放的，但是栈不一样，栈里存放的都是单个变量，变量被释放了，那就没有了。堆里的实体虽然不会被释放，但是会被当成垃圾，Java有垃圾回收机制不定时的收取。
下面我们通过一个图例详细讲一下堆和栈：
比如主函数里的语句 int [] arr=new int [3];在内存中是怎么被定义的：
主函数先进栈，在栈中定义一个变量arr,接下来为arr赋值，但是右边不是一个具体值，是一个实体。实体创建在堆里，在堆里首先通过new关键字开辟一个空间，内存在存储数据的时候都是通过地址来体现的，地址是一块连续的二进制，然后给这个实体分配一个内存地址。数组都是有一个索引，数组这个实体在堆内存中产生之后每一个空间都会进行默认的初始化（这是堆内存的特点，未初始化的数据是不能用的，但在堆里是可以用的，因为初始化过了，但是在栈里没有），不同的类型初始化的值不一样。所以堆和栈里就创建了变量和实体：
下面看一个demo：
public static void main(String[] args) { String a = new String(); String b = ""; String c = null; if (a.isEmpty()) { System.out.println("String a is empty"); } if (b.isEmpty()) { System.out.println("String b is empty"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d41ab9a431b8a27b36b4e1915954f6c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67ac14980877911a8b0543bda139767b/" rel="bookmark">
			《VS如何解决Cannot find or open the PDB file问题》
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 VS运行程序时，输出窗口显示大量的Cannot find or open the PDB file，意思是找不到或者打不开PDB文件，这个是Microsoft符号的问题，虽然不会影响程序的正常运行，但是遇到了还是要解决一下的。
解决方法 1、依次选择工具-&gt;选项-&gt;调试-&gt;符号，然后勾选Microsoft符号服务器，然后会弹出一个提示框，说会有延时，但确实会有延时，然后点击确定。
2、选择完之后，运行一下程序，程序会很卡，不要管，那是在下东西，下载的东西在那个缓存目录里，不好意思被挡住了，然后就会出现下面的已加载符号，说明解决了，当程序正常运行完之后，再关掉程序。
已加载“C:\Windows\syswow64\ntdll.dll”，已加载符号(去除源信息)。 已加载“C:\Windows\syswow64\kernel32.dll”，已加载符号(去除源信息)。 已加载“C:\Windows\syswow64\KernelBase.dll”，已加载符号(去除源信息)。 已加载“C:\Windows\syswow64\user32.dll”，已加载符号(去除源信息)。 已加载“C:\Windows\syswow64\gdi32.dll”，已加载符号(去除源信息)。 已加载“C:\Windows\syswow64\oleaut32.dll”，已加载符号(去除源信息)。 已加载“C:\Windows\syswow64\msvcrt.dll”，已加载符号(去除源信息)。 3、关掉程序之后，再回到那个界面把 Microsoft符号服务器这个选项取消掉，不然运行程序会很卡。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20b3c6fb1ab44f04d2bdd5af36a05e9a/" rel="bookmark">
			Linux 时间矫正命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Linux 时间矫正命令 Linux 时间矫正
sudo ntpdate -u ntp.api.bz 第一使用可能提示ntpdate没安装，用以下命令安装即可
sudo apt install ntpdate posted @ 2019-01-08 11:33 Youpeng 阅读( ...) 评论( ...) 编辑 收藏 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9edab33974e9d4e4126a0918660bcf8/" rel="bookmark">
			vmware14安装黑苹果max ox x 10.13懒人版教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		准备材料：
vmware 14.0：链接: https://pan.baidu.com/s/1_fjAngjUZ9HihzboBR0eJA 提取码: wwnn ；；；；vmware文件名后面有永久可用的序列号；14.0目前最高支持mac10.13，故使用这个来测试。
黑苹果10.13懒人版：链接: https://pan.baidu.com/s/1O2tJAcKltgDcWz5C_1Wyag 提取码: 7cqq ；；；；
vmware苹果破解补丁：链接: https://pan.baidu.com/s/1J4gLE4WqJalAXAPkZrufLg 提取码: 7bda ；；；
vmware显卡驱动：没有这个无法调节mac分辨率，链接: https://pan.baidu.com/s/1oaOo5LEr7rxn2JyJ76utxQ 提取码: zkbm 安装过程：
1. 关闭VMware ，win + R，输入services.msc，然后找到vmware相关服务，停止；
2. unlocker：(MAC 补丁):解压 Unlocker 文件，右键选择以管理员身份运行，等待运行完，安装完会自动关闭
这个界面会停留一段时间，耐心等待，安装完成就会退出
目的是使得 win10 环境下的 VMWare14Pro 支持 mac 系统的安装，成功后，在选择客户机操作系统时会有 Mac OS 的选项；
然后重启vmware的所有服务。
3.打开虚拟机创建 Mac 虚拟机
创建新的虚拟机-典型(推荐)
点击完成，完成之后先不要打开虚拟机，先去mac虚拟文件的所在目录修改一个文件
然后使用记事本或者其他工具打开
在 smc.present = "TRUE" 后面添加smc.version = "0"，建议复制，保存退出
打开虚拟机，就可以看到安装的界面了。
进入选项，选择简体中文，下一步
出现下面操作，选择实用工具-》磁盘工具
自己设定名称
退出磁盘工具会发现多了一个磁盘
接下来就是基本用户名密码等操作，根据需要自行设置，完成后界面如下
界面无法全屏，需要安装vmware tools工具
全部设置完毕即可进入系统，首先推出安装磁盘，然后在vmware上方“虚拟机”选择安装vmware tools，安装完vmware tools重启系统即可实现全屏和文件共享功能（如果提示系统扩展被阻挡，请在偏好设置—安全与隐私中选择允许再次安装）。
更新完之后就能够全屏，为了允许任意来源的请求，则可在实用工具-终端中使用如下命令
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b9edab33974e9d4e4126a0918660bcf8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12a61f6af169e96812d9e5b41fbdc325/" rel="bookmark">
			ajax 拼接html问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开发中遇到ajax 拼接前台页面，把数据动态拼接进去的问题
通常这样写
$.ajax({ type:'post', url:'/buyer/h5/approve/ajaxPage', dataType:'json', data:{ pageNum:page, pageSize:size, orderType:type }, success:function (data) { //data是一个对象，里边有状态码，object数据 var content=data.data; for(i in content){ //同意链接 var agreeUrl=base+"/h5Service/toApprovalDetailPage/"+content[i].id+"?from=approval_list"; var refuseUrl=base+"/h5Service/toRefusePage/"+content[i].id+"?from=approval_list" var orderDetailUrl=base+"/usr/h5/order/myOrder/detail/"+content[i].id+"/"+content[i].type+"/"+h5Type; //商品集合 var orderproduct=content[i].orderProductVoList; //订单总计 var sum=content[i].amountExpress+content[i].amountAct //图片 var imgs='' for(j in orderproduct){ imgs+='&lt;li&gt;&lt;img src="'+imageNormalUrl(orderproduct[j].imgUrl)+'"/&gt;&lt;/li&gt;' } //详情 var detail='' for(s in orderproduct ){ detail+='&lt;div class="ol_main"&gt;' detail+='&lt;div class="ol_main_left"&gt;' detail+='&lt;img src="'+imageNormalUrl(orderproduct[s].imgUrl)+'" /&gt;' detail+=' &lt;/div&gt;' detail+='&lt;div class="ol_main_right"&gt;' detail+='&lt;p class="olmr_p01"&gt;' detail+='&lt;span&gt;'+orderproduct[s].name+'&lt;/span&gt;' detail+='&lt;font&gt;￥'+toDecimal2(orderproduct[s].initPrice)+'&lt;br/&gt;&lt;i&gt;×'+orderproduct[s].prodCount+'&lt;/i&gt;&lt;/font&gt;' detail+=' &lt;/p&gt;' detail+='&lt;p class="olmr_p02"&gt;' detail+='&lt;span&gt;规格：'+orderproduct[s].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/12a61f6af169e96812d9e5b41fbdc325/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50780f47f6839d47d60bc4555ee00c3f/" rel="bookmark">
			REST
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 REST，Representational State Transfer。这个概念可以和远程调用一点点关系也没有。他是面向资源的。
Spring中的RestTemplate RestTemplate定义了36个与REST资源交互的方法，其中的大多数都对应于HTTP的方法。常见的有如下
delete() 在特定的URL上对资源执行HTTP DELETE操作 exchange() 在URL上执行特定的HTTP方法，返回包含对象的ResponseEntity，这个对象是从响应体中 映射得到的 execute() 在URL上执行特定的HTTP方法，返回一个从响应体映射得到的对象 getForEntity() 发送一个HTTP GET请求，返回的ResponseEntity包含了响应体所映射成的对象 getForObject() 发送一个HTTP GET请求，返回的请求体将映射为一个对象 postForEntity() POST 数据到一个URL，返回包含一个对象的ResponseEntity，这个对象是从响应体中映射得 到的 postForObject() POST 数据到一个URL，返回根据响应体匹配形成的对象 headForHeaders() 发送HTTP HEAD请求，返回包含特定资源URL的HTTP头 optionsForAllow() 发送HTTP OPTIONS请求，返回对特定URL的Allow头信息 postForLocation() POST 数据到一个URL，返回新创建资源的URL put() PUT 资源到特定的URL 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1fc736b9ccc2a177b609fcb09d1cdade/" rel="bookmark">
			2019年最新个人所得税计算器（源码/网页版/已发布）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2019年最新个人所得税计算器（源码/网页版/已发布），不少朋友已经开始用它算算数了，还是开源的。还可以当 React.js 的一个模版起步项目，推荐。???
项目代码地址 https://github.com/wxqee/2019-CN-PIT （记得好评给个?哟）
直接访问：2019年最新个人所得税计算器（已发布）
如果有任何疏漏，欢迎提交Issue。如果有额外需求，可以留言，得空帮你整整。
关键字：2019,个人所得税,个人所得税计算器,个税,薪资,个税专项附加扣除,六大专项附加,6大项,html,react
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc0629afbf70a1662a0e7df6b8c1320e/" rel="bookmark">
			IEEE 802.3-2015 CL28电口自协商翻译与记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简述： 自协商（Autoneg，AN）兼容10Base-T的NLP（平行检测）。并且向后兼容。在XMII、AUI上传递控制自协商的信息，在PMA层（介质接入适配层）和AUTONEG层间进行AN的信息交互，在MDI和链路上传递FLP信息等，各层各司其职（除了CL28的AN之外还有Cl73的AN，其与CL28大同小异）。
28.2功能规范 AN提供了控制单个MDI到单个PMA类型的连接的机制，其中可能存在多个PMA类型。Management可以通过管理功能提供对自动协商的附加控制，但是不需要管理代理的存在。自动协商功能应提供自动协商发送（Transmit）、接收（Receive）和仲裁（Arbitration）功能，并符合图28-16至图28-19的状态图（注：该图参考IEEE 802.3-2015 Volum 2 Clause28）。如果PHY支持10BASE-T操作，则自动协商功能应提供NLP接收链路完整性测试功能，并符合图28-19的状态图。
自动协商功能将通过与技术相关的接口与依赖于技术的PMA交互。技术相关的PMA包括但不限于100BASE-TX和100BASE-T4。技术相关的链路完整性测试功能只有在设备支持给定技术的情况下才能实现和接口。例如，一个10BASE-T和100BASE-TX自动协商设备必须实现和接口到100BASE-TX PMA/链路完整性测试功能，但是不需要包括100BASE-T4 PMA/链路完整性测试功能。自动协商功能应提供可选的管理功能，以提供控制和状态机制。
28.2.1 Transmit功能要求 Transmit功能提供传输FLP burst的能力（产生FLP burst脉冲）。 上电，链路重启或重新协商后，本地设备及其链路伙伴（Link Partner，LP也可译为链路对端）交换的第一个FLP Burst包含28.2.1.2中定义的基本链路代码字。 本地设备可以修改链接码字以禁用它拥有的能力，但不会传输它不具备的能力。 这使得本地拥有能力和通告能力之间的区别成为可能，使得多模设备可以自动协商到优先级低于最高共同本地能力集（最高共同域HCD）的模式。
28.2.1.1 链路脉冲传输 AN的通信方法建立在由10BASE-T MAU使用的链路脉冲机制上，用于检测链路的状态。兼容10BASE-T MAU发送链路完整性测试脉冲，作为在没有分组数据的情况下确定链路段是否可操作的机制。 10BASE-T NLP序列是在数据发送器空闲时每16 ms±8 ms发送一个脉冲（图14-13，略）。
AN用FLP Burst代替NLP序列中的单个10BASE-T链路完整性测试脉冲（图28-3）。 FLP Burst对用于控制AN功能的数据进行编码。当AN完成且PMA已启用HCD时，不应传输FLP Burst。
FLP Burst被设计为允许在初始链接自动协商之外使用，例如用于链接监视器等类似功能。但是，应禁止使用超出当前链接启动定义的FLP Burst。在FLP LINK GOOD状态下使用FLP Burst的定义是被保留的。
28.2.1.1.1 FLP burst编码 FLP burst包含33个脉冲位。 17个奇数脉冲位应各自分别包含一个链接脉冲并代表时钟信息。 16个偶数脉冲位置应表示如下数据信息：存在于偶数脉冲位置的链路脉冲表示逻辑1，而偶数脉冲位置不存在的链路脉冲表示逻辑0。时钟脉冲通过脉冲之间的间隔与数据脉冲区分开，如图28-5所示，并在表28-1中列出。扩展的FLP burst包含97个类似定义的脉冲位置，具有49个奇数时钟脉冲和48个偶数数据脉冲。使用FLP Burst中的脉冲对数据进行编码如图28-4所示。
28.2.1.1.2发送时序 FLP Burst中的第一个脉冲应定义为时钟脉冲。FLP Burst内的时钟脉冲间隔为125μs±14μs。如果要发送逻辑1的数据位表示，则在前一时钟脉冲之后62.5μs±7μs发生脉冲。 如果要发送表示逻辑0的数据位，则在前一个时钟脉冲的111μs内不应存在链路完整性测试脉冲。
当使用非优化的FLP Burst至FLP Burst时序时，连续FLP Burst中的第一个链路脉冲应以16 ms±8 ms的间隔发生，请参见参数T6（图28-6）。支持扩展下一页的设备应使用优化的FLP Burst到FLP Burst时序。当使用优化的FLP Burst至FLP Burst时序时，连续FLP Burst中的第一个链路脉冲应以8.25 ms±0.25 ms的间隔发生，请参见参数T7（图28-6）。优化的FLP Burst到FLP Burst限制旨在减少协商时间。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc0629afbf70a1662a0e7df6b8c1320e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2dd81be95581b56edf3e9c0230a3258/" rel="bookmark">
			【PAT】1030 完美数列 （25 分）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1030 完美数列 （25 分）
给定一个正整数数列，和正整数 p，设这个数列中的最大值是 M，最小值是 m，如果 M≤mp，则称这个数列是完美数列。
现在给定参数 p 和一些正整数，请你从中选择尽可能多的数构成一个完美数列。
输入格式： 输入第一行给出两个正整数 N 和 p，其中 N（≤10​5​​）是输入的正整数的个数，p（≤10​9​​）是给定的参数。第二行给出 N 个正整数，每个数不超过 10​9​​。
输出格式： 在一行中输出最多可以选择多少个数可以用它们组成一个完美数列。
输入样例： 10 8 2 3 20 4 5 1 6 7 8 9 输出样例： 8 一个测试点运行超时，希望大佬帮忙指正一下。
package basicLevel; import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.util.Arrays; public class T1030 { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String[] str1 = br.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2dd81be95581b56edf3e9c0230a3258/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/534433ede21b8595ce012d34b9b8bfe9/" rel="bookmark">
			PHP获取中文字符串首字母
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;?php //获取整条字符串所有汉字拼音首字母 function pinyin_long($zh){ $ret = ""; $s1 = iconv("UTF-8","GBK//IGNORE", $zh); $s2 = iconv("GBK","UTF-8", $s1); if($s2 == $zh){$zh = $s1;} for($i = 0; $i &lt; strlen($zh); $i++){ $s1 = substr($zh,$i,1); $p = ord($s1); if($p &gt; 160){ $s2 = substr($zh,$i++,2); $ret .= getfirstchar($s2); }else{ $ret .= $s1; } } return $ret; } //获取单个汉字拼音首字母。注意:此处不要纠结。汉字拼音是没有以U和V开头的 /** * 取汉字的第一个字的首字母 * @param string $str * @return string|null */ function getFirstChar($str) { if (empty($str)) { return ''; } $fir = $fchar = ord($str[0]); if ($fchar &gt;= ord('A') &amp;&amp; $fchar &lt;= ord('z')) { return strtoupper($str[0]); } $s1 = @iconv('UTF-8', 'gb2312//IGNORE', $str); $s2 = @iconv('gb2312', 'UTF-8', $s1); $s = $s2 == $str ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/534433ede21b8595ce012d34b9b8bfe9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a87186c72a9b7454acd639b18387f90f/" rel="bookmark">
			MySQL使用IN、EXISTS、ANY、ALL关键字的子查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		子查询是SELECT查询的另一个查询的附属，MySQL 4.1可以嵌套多个查询，在外面一层的查询中使用里面一层查询产生的结果集。这样就不是执行两个（或者多个）独立的查询，而是执行包含一个（或者多个）子查询的单独查询。
创建图书信息表和编号信息表，用于后续的实例使用。
（1）创建图书信息表，并添加数据。
-- 创建图书信息表 CREATE TABLE tb_book ( id INT AUTO_INCREMENT PRIMARY KEY, book_name VARCHAR(30) NOT NULL, row_no INT ); -- 添加数据 INSERT INTO tb_book(book_name,row_no) VALUES ('pan_junbiao的博客',10) ,('Java程序设计',12) ,('PHP经典模块',95) ,('C#项目整合',NULL) ,('MySQL入门',8) ,('Java高级编程',12) ,('Oracle数据库',15) （2）创建编号信息表，并添加数据。
-- 创建编号信息表 CREATE TABLE tb_row ( id INT AUTO_INCREMENT PRIMARY KEY, row_no INT NOT NULL ); -- 添加数据 INSERT INTO tb_row(row_no) VALUES(8),(10),(12),(80),(90); 1、带IN关键字的子查询 只有子查询返回的结果列包含一个值时，比较运算符才适用。假如一个子查询返回的结果集是值的列表，这时比较运算符就必须用IN运算符代替。
IN运算符可以检测结果集中是否存在某个特定的值，如果检测成功就执行外部的查询。
示例：带IN关键字的子查询。
SELECT * FROM tb_book WHERE row_no IN (SELECT row_no FROM tb_row); 执行结果：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a87186c72a9b7454acd639b18387f90f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/518b065827bcc93e5cb9d6320e4f5802/" rel="bookmark">
			电源完整性2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		4.电容退耦的两种解释
采用电容退耦是解决电源噪声问题的主要方法。这种方法对提高瞬态电流的响应速度，降低电源分配系统的阻抗都非常有效。
对于电容退耦，很多资料中都有涉及，但是阐述的角度不同。有些是从局部电荷存储（即储能）的角度来说明，有些是从电源分配系统的阻抗的角度来说明，还有些资料的说明更为混乱，一会提储能，一会提阻抗，因此很多人在看资料的时候感到有些迷惑。其实，这两种提法，本质上是相同的，只不过看待问题的视角不同而已。
4.1 从储能的角度来说明电容退耦原理。
在制作电路板时，通常会在负载芯片周围放置很多电容，这些电容就起到电源退耦作用。其原理可用下图说明。
当负载电流不变时，其电流由稳压电源部分提供，即图中的I0，方向如图所示。此时电容两端电压与负载两端电压一致，电流Ic为0，电容两端存储相当数量的电荷，其电荷数量和电容量有关。当负载瞬态电流发生变化时，由于负载芯片内部晶体管电平转换速度极快，必须在极短的时间内为负载芯片提供足够的电流。但是稳压电源无法很快响应负载电流的变化，因此，电流I0不会马上满足负载瞬态电流要求，因此负载芯片电压会降低。但是由于电容电压与负载电压相同，因此电容两端存在电压变化。对于电容来说电压变化必然产生电流，此时电容对负载放电，电流Ic不再为0，为负载芯片提供电流。根据电容等式：
I=C*dV/dt
只要电容量C足够大，只需很小的电压变化，电容就可以提供足够大的电流，满足负载瞬态电流的要求。这样就保证了负载芯片电压的变化在容许的范围内。这里，相当于电容预先存储了一部分电能，在负载需要的时候释放出来，即电容是储能元件。储能电容的存在使负载消耗的能量得到快速补充，因此保证了负载两端电压不至于有太大变化，此时电容担负的是局部电源的角色。
从储能的角度来理解电源退耦，非常直观易懂，但是对电路设计帮助不大。从阻抗的角度理解电容退耦，能让我们设计电路时有章可循。实际上，在决定电源分配系统的去耦电容量的时候，用的就是阻抗的概念。
4.2 从阻抗的角度来理解退耦原理。
将上图中的负载芯片拿掉，如下图所示。从AB两点向左看过去，稳压电源以及电容退耦系统一起，可以看成一个复合的电源系统。这个电源系统的特点是：不论AB两点间负载瞬态电流如何变化，都能保证AB两点间的电压保持稳定，即AB两点间电压变化很小。
我们可以用一个等效电源模型表示上面这个复合的电源系统，如下图
对于这个电路可写出如下等式：
我们的最终设计目标是，不论AB两点间负载瞬态电流如何变化，都要保持AB两点间电压变化范围很小，根据公式，这个要求等效于电源系统的阻抗Z要足够低。在4.1中，我们是通过去耦电容来达到这一要求的，因此从等效的角度出发，可以说去耦电容降低了电源系统的阻抗。另一方面，从电路原理的角度来说，可得到同样结论。电容对于交流信号呈现低阻抗特性，因此加入电容，实际上也确实降低了电源系统的交流阻抗。
从阻抗的角度理解电容退耦，可以给我们设计电源分配系统带来极大的方便。实际上，电源分配系统设计的最根本的原则就是使阻抗最小。最有效的设计方法就是在这个原则指导下产生的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/748912535593a3c0b3566c4dabd9aa0d/" rel="bookmark">
			Unity端 Android开发环境配置（window系统和macOS High Sierra系统）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		众所周知Unity端发布Android APP需要配置JAVA SDK和Android SDK，那么具体应该如何操作，主要为三个步骤，具体步骤如下：
一在Windows系统
windows系统的配置较为简单百度的方法百试百灵。
1首先下载JavaSDK网址
要点1:点选Accept License Agreement
要点2:根据你的windows系统选择合适的安装包
根据提示一步步安装完成，记住安装位置一会儿待用
2下载AndroidSDK，可以去Android官网下载AndroidStudio整个安装或者只是下载部分工具，因为关键部分是SDK Manager这个组件。
官方网址https://developer.android.com/studio/
AndroidStudio的安装按照提示安装即可
命令行工具是个文件夹，可以自定义存放位置
要点一：AndroidStudio和命令行工具安装一个即可
要点二：打开SDKManager工具下载相关工具
3配置Java和Android环境
右键【我的电脑】–单击【属性】–单击【高级】–单击【环境变量】
一共新建3个环境变量，配置Java环境变量
变量名JAVA_HOME 变量值：C:\Java\jdk1.8.0_22（此处是安装位置，我安装到了C盘所以添加了这个地址）
变量名 PATH 变量值添加：%JAVA_HOME%/bin
变量名 CLASSPATH 变量值：.;%JAVA_HOME%/lib/tools.jar;%JAVA_HOME%/lib/dt.jar
配置Android环境变量
变量名 ANDROID_SDK_HOME 变量值：（为你的SDK安装路径）
变量名PATH 变量值添加： ;%ANDROID_SDK_HOME%\platform-tools;%ANDROID_SDK_HOME%\tools
4在unity中指定JavaSDK和Android SDK，之后就配置完成了。
二在macOS High Sierra系统
macOS High Sierra系统中因为本身自带javaSDK于是带来了很多误区，指定路径之后发布失败。据unity官网技术说如果你的电脑中JDK版本为9或者10，你将构建失败，你需要安装JDK8的版本，或者下载2018.3之后的版本，因为这个版本的unity中集成jdk网址
1首先下载JavaSDK网址
要点1:点选Accept License Agreement
要点2:选择MAC OS系统选择合适的安装包
根据提示一步步安装完成，记住安装位置一会儿待用，因为Mac会自带jdk我的版本是jdk-9.0.1.jdk高于unity能接受的版本所以卸载重新装了一个jdk8就是上图版本的就可以
2下载AndroidSDK，可以去Android官网下载AndroidStudio整个安装或者只是下载部分工具，因为关键部分是SDK Manager这个组件。我下了AndroidStudio安装之后从Configure里面找到了SDKManager，下载了必备的工具
官方网址https://developer.android.com/studio/
3配置Java和Android环境
打开终端输入： open ~/.bash_profile
添加设置Android和JDK的变量控制
#setting Android
export ANDROID_HOME=/Users/pc/Library/Android/sdk
export PATH= P A T H : {PATH}: PATH:{ANDROID_HOME}/platform-tools
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/748912535593a3c0b3566c4dabd9aa0d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8cc65018f2c5a4d5d1a3771f322b415/" rel="bookmark">
			二叉树的基本操作（C语言实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		二叉树的建立、遍历、统计、树状打印 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int c_Node = 0; //节点数 int c_Leaf = 0; //叶子数 int depth = 0; //二叉树高度 typedef char ElemType; typedef struct Node //节点 { ElemType data; //节点数据 struct Node *lchild; //左孩子 struct Node *rchild; //右孩子 } biNode, *biTree; //先序建立二叉树 void createTree(biNode **root) { ElemType data; scanf("%c",&amp;data); if(data == '#') { (*root)=NULL; } else { *root = (biNode *)malloc(sizeof(biNode)); if((*root) == NULL) { printf("分配空间失败!\n"); exit(0); } (*root)-&gt;data = data; createTree(&amp;((*root)-&gt;lchild)); createTree(&amp;((*root)-&gt;rchild)); } } //先序遍历二叉树 void preOrder(biNode *root) { if(root) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c8cc65018f2c5a4d5d1a3771f322b415/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/366a3a54a26ca2de4cddd65206d9d5cb/" rel="bookmark">
			【应用统计学】第一类/α/弃真错误与第二类/β/取伪错误的解释与举例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一类/α/弃真错误与第二类/β/取伪错误的举例与解释 第二类错误图解两种错误α错误β错误 第二类错误 第二类错误，也称取伪错误，或者β错误，是统计学中的一个概念。与β错误一起常常出场的就是α错误（弃真错误/第一类错误）。α错误指：“原假设是正确的，却拒绝了原假设” ，β错误与之相反：“原假设是错误的，却没有拒绝原假设。”
说白了，α错误就是：我认为是这件事是错的，但实际上这件事是对的（所以我犯了α错误）；β错误就是：我认为这件事是对的，但实际上这件事是错的（所以我犯了β错误）。
图解两种错误 α错误 理解α错误通常采用一个正态分布图配上假设检验案例。现在想通过统计验证μ是不是μ_0，只要统计出来的μ落在了接受域里，那么就认为μ=μ_0不能被拒绝。
真实存在的μ不应该是一个固定值吗？为什么落在接受域里就不拒绝了呢？
这里先讨论μ与分布的关系。我个人的理解是，如果μ=μ_0，那么统计出来所得的μ值分布就是现在的分布。即分布代表了μ值。如果实际上，μ不是这个正态分布的均值，那么实际的μ’也对应一个它自己的分布（而且，这个分布仅仅是向前或者向后偏移而已，假设与实际的西格玛相同，因为假设只考虑μ）。
接着再讨论α的特殊情况，所以如果设α＝0.99，可以想象接受域几乎为“一条缝”。只有当统计出的μ落在了这“一条缝”里，才认为μ=μ_0成立（不拒绝原假设）。而实际上，即便实际的μ=μ_0，统计出来的μ也很有可能落在这条“缝”外面，所以，α=0.99时，犯弃真错误的概率很大。所以有了我们常见的套话：“有1%的把握接受原假设”。（1%来自1-α=1-0.99=0.01）
反过来想，如果α小了，那么把握岂不是变大了？
β错误 我个人观点，假设是否成立，看的就是实际分布与假设分布是否相同。
这样才能更好地理解两种错误。
β分布用质量管理中的控制图来理解。
控制图是质量管理传统工具之一。控制图可以检验很多类型的故障，这里只考虑β-risk。通常，对于单个数据点而言，当其落在(LCL,UCL)内，认为系统运行正常。即，如果数据点落在范围外，才认为系统出错（这里认为，系统出错的表现就是实际分布与假设的分布不同。如图，系统出现故障，实际分布偏移了Δ）。
还是对图例进行讨论，如果点落在阴影中，我们认为系统正常。而实际上，分布发生了偏移，系统是存在故障的。所以此时我们犯了取伪错误。
实际的分布服从上面的那条正态曲线，这里证明 β = Φ ( K − t ( n ) ) − Φ ( K − t ( n ) ) \beta=\Phi(K-t\sqrt(n))-\Phi(K-t\sqrt(n)) β=Φ(K−t( ​n))−Φ(K−t( ​n))加深理解。也是我质量管理课上的一道作业题，为了弄懂这道题，我对两类错误展开了些有进展的思考。
证明：
β = F ( U C L ) − F ( L C L ) = F ( μ + K σ ) − F ( μ − K σ ) = Φ ( μ + K σ ′ − ( μ + t σ ) σ ′ ) − Φ ( μ − K σ ′ − ( μ + t σ ) σ ′ ) = Φ ( K − t ( n ) ) − Φ ( K − t ( n ) ) \begin{array}{rl} \beta&amp;amp;=F(UCL)-F(LCL)\\ &amp;amp;=F(\mu+K\sigma)-F(\mu-K\sigma)\\ &amp;amp;=\Phi\left( \frac{\mu+K\sigma&amp;#x27;-(\mu+t\sigma)}{\sigma&amp;#x27;}\right) -\Phi\left(\frac{\mu-K\sigma&amp;#x27;-(\mu+t\sigma)}{\sigma&amp;#x27;} \right)\\ &amp;amp;=\Phi(K-t\sqrt(n))-\Phi(K-t\sqrt(n)) \end{array} β​=F(UCL)−F(LCL)=F(μ+Kσ)−F(μ−Kσ)=Φ(σ′μ+Kσ′−(μ+tσ)​)−Φ(σ′μ−Kσ′−(μ+tσ)​)=Φ(K−t( ​n))−Φ(K−t( ​n))​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/366a3a54a26ca2de4cddd65206d9d5cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a11b4a953570851ddf7bb39d4063681/" rel="bookmark">
			Python str join方法：拼接字符串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
描述
语法
举例
1. 元素序列是列表
2. 元素序列是元组
3. 元素序列是集合
4. 元素序列是字典
5. 元素序列是字符串
注意事项
1. 要连接的字符串序列（参数）必须是字符串
2. 字符串连接符可省略
3. 当可迭代序列是集合时，拼接结果是无序的
4. 当可迭代序列是字典时，拼接结果是键的拼接
join方法和‘+’性能比较
描述 str.join()方法是Python的字符串方法，用于将序列中的元素以指定的字符串连接成一个新的字符串。
语法 string.join(sequence) 名称说明备注string字符串连接符可省略sequence要连接的元素序列不可省略的参数，序列的元素是字符串 举例 1. 元素序列是列表 &gt;&gt;&gt; a = '!@'.join(['Fusion', 'Sphere', 'Cloud']) &gt;&gt;&gt; a 'Fusion!@Sphere!@Cloud' 2. 元素序列是元组 &gt;&gt;&gt; " ".join(('China', 'Japan', 'USA', 'UK')) 'China Japan USA UK' 3. 元素序列是集合 &gt;&gt;&gt; ''.join({'C', 'h', 'i', 'n', 'a'}) 'ahCni' 可以看出，输出的字符顺序与集合中元素的顺序不是保持一致的。
4. 元素序列是字典 &gt;&gt;&gt; ' ~ '.join({'Asia':'China', 'Europe':'UK'}) 'Asia ~ Europe' 可以看出，如果序列是字典，拼接的字符是字典的键。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a11b4a953570851ddf7bb39d4063681/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50565b08e6681495145e2bbc6eda1133/" rel="bookmark">
			kibana 创建index pattern 索引模式时过慢导致无法创建成功 以及解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为什么80%的码农都做不了架构师？&gt;&gt;&gt; 面我具体描述一下我遇到的问题。
在kibana上面创建索引点击创建时，一直显示下面的页面
就看到不停的在那转，始终创建不成功。
查看后台日志，看到状态码为403,报了如下的错误
由于我用的是es6版本，所以怀疑是.kibana没有写入权限
我尝试修改index.blocks.write
执行：
PUT .kibana/_settings { "index.blocks.write": true } 发现报了错：
然后我开放了kibana关于elasticsearch的索引权限
执行成功：
然后，再次尝试修改index.blocks.write
执行：
PUT .kibana/_settings { "index.blocks.write": true } 执行成功：
但最后发现还是这样
着实搞得我头大，最后终于在官网上找到了解决方法，具体参照下面这篇文章
https://www.elastic.co/guide/en/kibana/6.0/migrating-6.0-index.html
一共分为四步：
第一步：设置.kibana的index.blocks.write属性为true
PUT .kibana/_settings { "index.blocks.write": true } 执行失败可参照上面的解决方案
第二步：创建创建 .kibana-6 索引
PUT .kibana-6 { "settings" : { "number_of_shards" : 1, "index.mapper.dynamic": false }, "mappings" : { "doc": { "properties": { "type": { "type": "keyword" }, "updated_at": { "type": "date" }, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/50565b08e6681495145e2bbc6eda1133/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee27f59d760e4a63377dcfc7a2d48b20/" rel="bookmark">
			2019的Flag不能倒
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 2018“渡劫” 刚刚过去的2018年，算是人生中的一次重要的抉择，苦练多年“神功”，只为通过谋一营生可以在江湖中立足。
关于找工作这件事情，占据了整个2018年的四分之三，从2018年2月份准备实习简历，到3,4月份投实习公司，都以失败收场。5月份开始潜心学习工作相关的知识，每天都给自己安排了各种各样的学习，期间，依然不死心的投实习简历，被拒，直到7月份终于收到了一点回音，但是面试却又失败了。知识不扎实，没有相关的项目似乎是我的硬伤。8月份提前批开始投简历，收到了许多面试通知，无疑还是败在了面试上。这样的打击让我更加清晰的认识到自己的短处是什么，所以不断补充自己的知识。9月份，正式校招，笔试，面试，看到别人拿offer拿到手软，我却两手空空的去搏斗，内心的压力巨大。中秋节终于收到了offer，心终于放下了，10月份签三方，总算圆满的找到一份心仪的工作，为此，我压力减小，冒了一脸痘。
工作确定后，准备了DSP2018的汇报，开始了新的劫难——毕设，重新投入到漫长的科研道路中。
2019“修仙” 2018年渡劫过一劫的我，成功步入了2019年，想要修仙的道路依然漫长，道阻且长，行则将至。因此，我要在2019年立下新的誓言，方可修仙成功；
科研
在2019年，我要在2月底完成毕设论文，3月份修改论文内容，4月份整理研究生的学习资料，6月份顺利毕业拿到两证 工作
在2019年7月份入职后，熟悉自己的工作内容，要保持不断学习的态度，向身边的人学习，同时给自己安排固定的充电时间，保持不断的学习工作领域的新的知识 生活
在2019年，要保持每周锻炼三到四次，使自己瘦到50kg;阅读自己专业领域和感兴趣的书籍，尽量保持两周看一本书，同时完成一篇读书笔试；保持每天记录手账的习惯；定期去认识新的朋友。 家庭
每周与父母通话或者视频一次，一年回家三到四次； 财富
每月攒固定数目的钱，同时学习理财的相关知识 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8fb7245e7f35a12d79f65af505eda63/" rel="bookmark">
			DataBinding使用指南（一）DataBinding基本使用，双向绑定，ListView RecycleView使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		databing使用指南 简介简单使用双向绑定ListView、RecycleView中的使用. ListViewListView 中数据的简单展示数据源改变后数据更新方式 . RecycleView 简介 随着Android的发展，最初的MVC框架远远无法满足广大_Android猿_ 的需求，进而出现了MVP、MVVM等开发框架，Databing就是Google官方出品的支持MVVM开发的一个依赖库。或许说依赖库不准确，应该说是一整套开发工具和依赖库的集合
今天我们不讲开发框架的问题，我们只是来看一下 databing 的使用
简单使用 在相关模块下的buidl.gradle中设置对databing的支持 android { ...... //MVVM dataBinding 支持 dataBinding { enabled = true } ...... } 在gradle.properties中添加下面一句代码开启数据绑定编辑
android.databinding.enableV2=true
以上两步完成后我们就可以开心的使用databing的方式进行编码了。代码编写 定义 ViewModel类定义 ViewModel类 public class User extends BaseObservable { private String name; private String sex; private int age; public User(String name, String sex, int age) { this.name = name; this.sex = sex; this.age = age; } public String getName() { return name; } public void setName(String name) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a8fb7245e7f35a12d79f65af505eda63/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf7b357d0fc764cbefc54ff861e6740f/" rel="bookmark">
			Parquet文件格式介绍和读写流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.Parquet文件格式介绍 Parquet是面向分析型业务的列式存储格式，由Twitter和Cloudera合作开发，2015年5月从Apache的孵化器里毕业成为Apache顶级项目，那么这里就总结下Parquet数据结构到底是什么样的
一个Parquet文件是由一个header以及一个或多个block块组成，以一个footer结尾。header中只包含一个4个字节的数字PAR1用来识别整个Parquet文件格式。文件中所有的metadata都存在于footer中。footer中的metadata包含了格式的版本信息，schema信息、key-value paris以及所有block中的metadata信息。footer中最后两个字段为一个以4个字节长度的footer的metadata,以及同header中包含的一样的PAR1。
读取一个Parquet文件时，需要完全读取Footer的meatadata，Parquet格式文件不需要读取sync markers这样的标记分割查找，因为所有block的边界都存储于footer的metadata中(因为metadata的写入是在所有blocks块写入完成之后的，所以吸入操作包含的所有block的位置信息都是存在于内存直到文件close）
这里注意，不像sequence files以及Avro数据格式文件的header以及sync markers是用来分割blocks。Parquet格式文件不需要sync markers，因此block的边界存储与footer的meatada中。
parquet文件格式如图1：
图1：parquet文件的格式结构
Parquet文件在磁盘上的分布情况如图2所示。所有的数据被水平切分成Row
group，一个Row group包含这个Row
group对应的区间内的所有列的column chunk。一个column
chunk负责存储某一列的数据，这些数据是这一列的Repetition levels, Definition levels和values（详见后文）。一个column
chunk是由Page组成的，Page是压缩和编码的单元，对数据模型来说是透明的。一个Parquet文件最后是Footer，存储了文件的元数据信息和统计信息。Row group是数据读写时候的缓存单元，所以推荐设置较大的Row
group从而带来较大的并行度，当然也需要较大的内存空间作为代价。一般情况下推荐配置一个Row group大小1G，一个HDFS块大小1G，一个HDFS文件只含有一个块
图2：文件在磁盘上的分布
2.Parquet的读写 parquet写的时候需要指定schema，读的时候会自动识别schema
每一个字段有三个属性：重复数、数据类型和字段名，重复数可以是以下三种：
required(出现1次)
repeated(出现0次或多次) optional(出现0次或1次)
数据类型有:
INT64, INT32, BOOLEAN, BINARY(字符串), FLOAT, DOUBLE, INT96, FIXED_LEN_BYTE_ARRAY
例如：
private static String schemaStr = "message schema {" + "repeated int64 rowkey;" +"repeated int64 family;"+ "repeated int64 colume;"+"repeated int64 value;}"; static MessageType schema = MessageTypeParser.parseMessageType(schemaStr); 具体代码详见另一篇：https://blog.csdn.net/qiangzi_lg/article/details/86676538
文章摘自：https://www.jianshu.com/p/b823c727fe46和https://www.cnblogs.com/yangsy0915/p/5565309.html
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/491/">«</a>
	<span class="pagination__item pagination__item--current">492/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/493/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>