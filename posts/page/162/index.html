<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd92420820cdfaf3ad933e323b212191/" rel="bookmark">
			Elasticsearch 一些异常报错、注意事项(3)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记录一：(Java High Level REST Client)更新接口UpdateRequest 使用脚本进行更新（实际写法需要根据当前引用的依赖版本决定）
UpdateRequest request = new UpdateRequest("posts", "1"); Map&lt;String, Object&gt; parameters = singletonMap("count", 4); Script inline = new Script(ScriptType.INLINE, "painless", "ctx._source.field += params.count", parameters); request.script(inline); 记录二：script脚本查询更新接口 POST /test_index/_update_by_query? { "query": { "bool": { "must_not": { "exists": { "field": "name" } } } }, "script": { "source": "ctx._source.isPerson = params.isPerson; ", "params": { "isPerson": 1 } } } 记录三：QueryBuilder同时使用must和should进行or条件查询不成功 一开始的写法：
QueryBuilder query = QueryBuilders.boolQuery() .must(QueryBuilders.termQuery("isName", 1)) .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd92420820cdfaf3ad933e323b212191/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eac22cf169c775975f2d65c18199c05d/" rel="bookmark">
			shell编程基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（1）它必须以如下行开始（必须放在文件的第一行）：
#!/bin/sh 符号#!用来告诉系统执行该脚本的程序，本例使用/bin/sh。编辑结束并保存后，如果要执行该脚本，必须先使其可执行： chmod +x filename。此后在该脚本所在目录下，输入 ./filename 即可执行该脚本。
#!/bin/sh &amp; #!/bin/bash的差别，在ubuntu中，可以知道
两者其实是同一个东西，使用起来没有差别。
如果是在嵌入式系统中比如安卓里面，通过文件系统可以知道，运行在它里面的脚本只能加#!/system/bin/sh，且链接内容是这样的
如果安卓中运行脚本，提示No such file or directory，其实是脚本格式的原因，只需要将windows下写的shell脚本转成unix格式即可解决。
（2）变量赋值和引用。Shell编程中，使用变量无需事先声明，需要给变量赋值时，可以这么写： 变量名=值 。要取用一个变量的值，只需在变量名前面加一个$ ( 注意: 给变量赋值的时候，不能在"="两边留空格 ) a，对字符串变量赋值并输出：
a="hello world" # 打印字符串变量a的值：
echo "A is:" $a
执行结果：A is: hello world
b，内部执行shell命令，用单引号，如：
now_date_1=`date`
echo "now_date_1 is " $now_date_1
结果是：now_date_1 is 2014年 12月 29日 星期一 23:51:46 CST
c，字符串连接，多个字符串并在一起即可，如：
FILES=" boota64.bin"
now_date_1="wahaha"
echo "now_date_1 is " $now_date_1$FILES
输出是：now_date_1 is wahaha boota64.bin
（3）if 语句。"if"表达式如果条件为真，则执行then后的部分:
if .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eac22cf169c775975f2d65c18199c05d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c612f58a3a8a00d244b571f54eaa28a/" rel="bookmark">
			读取OSGB数据的几种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、osg自带的osgviewer读取osgb数据 在接触osgb的时候，一般都会先配osg的环境，所以先介绍这种方法
1.1 打开单个osgb数据 需要打开cmd，cd到文件夹下
C:\Users\Administrator&gt;f: F:\&gt;cd F:\Data\Data\Data\Tile_+000_+000 F:\Data\Data\Data\Tile_+000_+000&gt;osgviewer Tile_+000_+000.osgb 1.2 osgviewer批量打开 cd到该文件夹下，在all.desc中存有所有的名字
F:\&gt;cd F:\Data\大雁塔-OSGB\osgb F:\Data\大雁塔-OSGB\osgb&gt;osgviewer .\Tile_+000_+000\Tile_+000_+000.osgb .\Tile_+000_+001\Tile_+000_+001.osgb .\Tile_+000_+002\Tile_+000_+002.osgb .\Tile_+000_+003\Tile_+000_+003.osgb .\Tile_+000_+004\Tile_+000_+004.osgb .\Tile_+000_+005\Tile_+000_+005.osgb .\Tile_+000_+006\Tile_+000_+006.osgb .\Tile_+000_+007\Tile_+000_+007.osgb .\Tile_+000_+008\Tile_+000_+008.osgb .\Tile_+001_+000\Tile_+001_+000.osgb .\Tile_+001_+001\Tile_+001_+001.osgb .\Tile_+001_+002\Tile_+001_+002.osgb .\Tile_+001_+003\Tile_+001_+003.osgb .\Tile_+001_+004\Tile_+001_+004.osgb .\Tile_+001_+005\Tile_+001_+005.osgb .\Tile_+001_+006\Tile_+001_+006.osgb .\Tile_+001_+007\Tile_+001_+007.osgb .\Tile_+001_+008\Tile_+001_+008.osgb .\Tile_+002_+000\Tile_+002_+000.osgb .\Tile_+002_+001\Tile_+002_+001.osgb .\Tile_+002_+002\Tile_+002_+002.osgb .\Tile_+002_+003\Tile_+002_+003.osgb .\Tile_+002_+004\Tile_+002_+004.osgb .\Tile_+002_+005\Tile_+002_+005.osgb .\Tile_+002_+006\Tile_+002_+006.osgb .\Tile_+002_+007\Tile_+002_+007.osgb .\Tile_+002_+008\Tile_+002_+008.osgb .\Tile_+003_+000\Tile_+003_+000.osgb .\Tile_+003_+001\Tile_+003_+001.osgb .\Tile_+003_+002\Tile_+003_+002.osgb .\Tile_+003_+003\Tile_+003_+003.osgb .\Tile_+003_+004\Tile_+003_+004.osgb .\Tile_+003_+005\Tile_+003_+005.osgb .\Tile_+003_+006\Tile_+003_+006.osgb .\Tile_+003_+007\Tile_+003_+007.osgb .\Tile_+003_+008\Tile_+003_+008.osgb .\Tile_+004_+000\Tile_+004_+000.osgb .\Tile_+004_+001\Tile_+004_+001.osgb .\Tile_+004_+002\Tile_+004_+002.osgb .\Tile_+004_+003\Tile_+004_+003.osgb .\Tile_+004_+004\Tile_+004_+004.osgb .\Tile_+004_+005\Tile_+004_+005.osgb .\Tile_+004_+006\Tile_+004_+006.osgb .\Tile_+004_+007\Tile_+004_+007.osgb .\Tile_+004_+008\Tile_+004_+008.osgb .\Tile_+005_+000\Tile_+005_+000.osgb .\Tile_+005_+001\Tile_+005_+001.osgb .\Tile_+005_+002\Tile_+005_+002.osgb .\Tile_+005_+003\Tile_+005_+003.osgb .\Tile_+005_+004\Tile_+005_+004.osgb .\Tile_+005_+005\Tile_+005_+005.osgb .\Tile_+005_+006\Tile_+005_+006.osgb .\Tile_+005_+007\Tile_+005_+007.osgb .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c612f58a3a8a00d244b571f54eaa28a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ddb8c23574473a3ec867e7a9fdb44274/" rel="bookmark">
			【MySQL 视图的操作二-查看视图】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 查看视图SHOW TABLES 语句查看视图名SHOW TABLE STATUS 语句查看视图的详细信息SHOW CREATE VIEW 语句查看视图定义信息DESCRIBE | DESC 语句查看视图设计信息通过系统表查看视图信息 生词表 查看视图 查看视图的语句有很多，例如，SHOW TABLES、SHOW TABLE STATUS、SHOW CREATE VIEW等。
SHOW TABLES 语句查看视图名 从MySQL 5.1 版本开始，实行 SHOW TABLES 语句时不仅会显示表的名字，同时也会显示视图的名字。
使用 SHOW TABLES 语句前必须指定数据库名称，即进入数据库 （USE 数据库名）
例： 首先选择进入数据库 view ，然后查看该数据库中所有表名和视图名。
注： 数据库 view 是我们在上一篇【视图的操作一】建立的
mysql&gt; #选择数据库# mysql&gt; USE view; Database changed mysql&gt; #查看数据库中视图及表的列表# mysql&gt; SHOW TABLES; +--------------------+ | Tables_in_view | +--------------------+ | select_price | | t_group | | t_product | | t_student | | view_selectproduct | | view_test1 | | view_test2 | | view_test3 | | view_test4 | | view_test6 | | view_test7 | +--------------------+ 11 rows in set (0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ddb8c23574473a3ec867e7a9fdb44274/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10b8f7b8b08b1ca2a6f475e1d805e5fb/" rel="bookmark">
			【MySQL 视图的操作三】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、删除视图语法形式例1：删除一个视图例2：删除多个视图 二、修改视图CREATE OR REPLACE VIEW 语句修改视图ALTER 语句修改视图 三、利用视图操作基本表检索（查询）数据利用视图操作基本表数据1、添加数据操作2、删除数据操作3、更新数据操作 一、删除视图 通过 DROP VIEW 可以一次删除一个或者多个视图。
语法形式 DROP VIEW 视图名称 【,视图名称2】…… 例1：删除一个视图 删除数据库 view 中 view_selectproduct 视图
1、 选择（进入）数据库
mysql&gt;#查看数据库名录# mysql&gt; SHOW DATABASES; +--------------------+ | Database | +--------------------+ | company | | information_schema | | mysql | | performance_schema | | sys | | view | +--------------------+ 6 rows in set (0.00 sec) mysql&gt;#进入数据库 view # mysql&gt; USE view; Database changed 2、 删除名为 selectproduct 的视图
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/10b8f7b8b08b1ca2a6f475e1d805e5fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ffe41e2dc1c5416e96a3856d7bebd6bf/" rel="bookmark">
			Android adb调试指令大全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在日常开发中，我们会经常需要用到 adb 调试指令来查看设备的状态、运行信息等。下面是一些常用的 adb 指令，以及它们的用法和调试效果，供大家参考。
查看当前 activity 如果我们想查看当前正在运行的 Activity，可以使用以下指令：
adb shell dumpsys activity top | grep ACTIVITY 这条指令可以显示当前正在运行的 Activity，以及所在应用程序的包名，非常方便。
查看应用程序信息 如果我们有时需要查看设备或应用程序的版本信息，可以使用以下指令：
adb shell dumpsys package 这条指令可以显示设备中所有已安装应用程序的信息，包括包名、版本号、状态等。如果我们只需要某个包名下的信息，可以使用以下指令：
adb shell dumpsys package 包名 | grep version 输入和模拟事件 如果我们想模拟用户在设备上的操作，可以使用以下指令：
发送按键事件，可以模拟用户按下某个物理按键： adb shell input keyevent 输入文本，可以模拟用户在设备上输入文本： adb shell input text 列出已安装的应用程序包名 如果我们需要列出设备中已安装应用程序的包名，可以使用以下指令：
adb shell pm list packages 如果只需要列出包含启动器的应用程序，可以使用以下指令：
adb shell pm list packages | grep launcher 强制停止应用程序 有时候我们需要关闭某个应用程序的运行，可以使用以下指令：
adb shell am force-stop 包名 这条指令可以停止运行指定包名的应用程序。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ffe41e2dc1c5416e96a3856d7bebd6bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d301c90cdfa5f264165ce4b3957d3bb0/" rel="bookmark">
			php使用yield处理大数据文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.概述 yield和return有点像，它是一个生成器，对PHP应用的性能有非常大的影响， 只有在调用的时候才会执行，并不产生多余的值，比如读取一个很大的文件或者计算大量的数据时，如果直接读取很有可能内存就爆了，而yield就可以做到把数据一行行读取到php运行内存，并非一次性读取到php运行内存，这样在运行时就会节省大量的内存;还有就像在循环数据库的所有记录的时候，这个记录可能会很大，例如100万行，那么通过传统的办法就行不通了，首先通过web访问，php有超时时间，默认是30秒，那么就只能通过php cli的方式来执行，这样就没有超时时间了，但由于数据量太大，php循环时需要将数据全部载入内存中执行，由于数据量太大，php会报Fatal error: Allowed memory size of 134217728 bytes exhausted (tried to allocate 4096 bytes)的错误，php默认的内存限制为128M，虽然可以通过修改php.ini中memory_limit的选项的值来提高内存限制，但始终不是最优的解决办法，这时通过生成器函数就可以极大节省内存开销
2.案例引入 先看一个简单的函数
&lt;?php function createRange($number){ $data = []; for($i=0;$i&lt;$number;$i++){ $data[] = time(); } return $data; } ?&gt; 这是一个非常常见的PHP函数，我们在处理一些数组的时候经常会使用。这里的代码也非常简单：
创建一个函数， 函数内包含一个for循环，循环的把当前时间放到data里面for循环执行完毕，把data返回出去。
再写一个函数，把这个函数的返回值循环打印出来：
&lt;?php $result = createRange(10); // 这里调用上面我们创建的函数 foreach($result as $value){ sleep(1);//这里停顿1秒，后续有用 echo $value.'&lt;br /&gt;'; } 在浏览器里面看一下运行结果，非常赖斯，没有任何问题，这时需要思考一个问题：
在调用函数createRange的时候给$number的传值是10，一个很小的数字，如果现在传递一个值10000000（1000万），那么，在函数createRange里面，for循环就需要执行1000万次，且有1000万个值被放到$data里面，而$data数组在是被放在内存里的，所以，在调用函数时候会占用大量内存，非常的不友好，这时生成器(yield)就闪亮登场了，修改一下代码，创建生成器：
&lt;?php function createRange($number){ for($i=0;$i &lt;= $number;$i++){ yield time(); } } ?&gt; 这段代码，删除了数组$data，也没有返回任何内容，而是在time()之前使用了一个关键字yield
使用生成器
&lt;?php $result = createRange(10); // 这里调用上面我们创建的函数 foreach($result as $value){ sleep(1); echo $value.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d301c90cdfa5f264165ce4b3957d3bb0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/546fffa7ce751e4362ff2c94f6efbeb8/" rel="bookmark">
			pip常用镜像源（清华源，阿里源，豆瓣源，百度源）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 国内常用镜像源（清华源，阿里源，豆瓣源，百度源）
清华大学 ：https://pypi.tuna.tsinghua.edu.cn/simple/ 百度源:https://mirror.baidu.com/pypi/simple 阿里云：http://mirrors.aliyun.com/pypi/simple/ 中国科学技术大学 ：http://pypi.mirrors.ustc.edu.cn/simple/ 华中科技大学：http://pypi.hustunique.com/ 豆瓣源：http://pypi.douban.com/simple/ 腾讯源：http://mirrors.cloud.tencent.com/pypi/simple 华为镜像源：https://repo.huaweicloud.com/repository/pypi/simple/ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1fbae5639552de30570b93d0f2946136/" rel="bookmark">
			交叉编译-configure配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		配置configure.ac
用自动生成Makefile的工具来生成Makefile的过程中，需要用autoscan命令来生成configure.scan文件，然后将它改名字为configure.ac或者configure.in,然后就来更改其中的一些相关信息来完成下面需要完成的配置，那么这个configure.ac怎么来写？今天我们就将这个过程分开来和大家共同研究和探讨下。
我们在生成的过程中会用autoconf命令来处理configure.ac/configure.in文件，生成一个configure的脚本。生成后的configure文件是一个可以移植的shell脚本，运行的时候它检查编译环境，来决定哪些库是可以用的，所用到的平台有哪些个特征，那些个头文件和库是已经找到的等等， 然后收集到的这些信息，它修改编译标记，生成一个Makefile文件，同时生成一个包含已定义的预处理符号的config.h文件。configure并不需要运行autoconf，所以我们在发布应用程序之前生成这个文件，如此我们就不必有autoconf的软件包了。
AC_INIT总是configure.in中的第一个宏。它扩展为许多可由其他configure脚本共享的模板文件代码。这些代码解析传到 configure中的命令行参数。这个宏的一个参数是一个文件名，这个文件应该在源代码目录中，它用于健全性检查，以保证configure脚本已正确定位源文件目录。
AM_CONFIG_HEADER指定了要创建的头文件，差不多总是config.h。创建的头文件包含由configure定义的C预处理符号。最低限度应该定义PACKAGE和VERSION符号，这样可以将应用程序名称和版本传送到代码中，而无须对它们硬编码(非公用的源文件应该包含 config.h(#include)以利用这些定义。然而，不要将config.h文件安装到系统中，因为它有可能与其他的软件包冲突)。
AM_INIT_AUTOMAKE初始化automake。传到这个宏里的参数是要编译的应用程序的名称和版本号(这些参数成为config.h中定义的PACKAGE和VERSION值)。
AM_MAINTAINER_MODE关闭缺省时仅供程序维护者使用的makefile目标，并修改以使configure能理解 –enable-maintainer-mode选项。–enable-maintainer-mode将maintaineronly目标重新打开。仅供维护者使用的makefile目标允许最终用户清除自动生成的文件，比如configure，这意味着要修复编译故障，必须安装有autoconf和automake软件。注意，因为autogen.sh脚本主要是给开发人员用的，autogen.sh会自动传递一个–enable- maintainer-mode选项给configure。
AM_ACLOCAL_INCLUDE指定一个附加的目录，用于搜索m4宏。在这里，它指定为macros子目录。在这个目录中应该有Gnome宏的拷贝。
GNOME_INIT给configure添加一个与Gnome相关的命令行参数个数，并为Gnome程序定义一些makefile变量，这些变量中包含了必要的预处理程序和链接程序标志。这些标志是由gnome-config脚本取得的。安装gnome-libs时会安装gnome- config脚本。
AC_PROG_CC定位C编译器。
AC_CHECK_LIB如果程序中加入了多线程用到的锁的话就要加入像 AC_CHECK_LIB([pthread], [main])这样的检测，这个宏的含义如下：
LIBS是link的一个选项，程序中使用了读写锁，所以要测试pthread库中是否存在pthread_rwlock_init函数。
AC_PROG_RANLIB如果是多线程的程序的话要加入这句话，要不运行automake命令时会出错。
AC_ISC_POSIX添加一些在某些平台上实现POSIX兼容需要的标志。
AC_HEADER_STDC检查当前平台上是否有标准的ANSI头文件，如果有，则定义STDC_HEADERS。
AC_ARG_PROGRAM添加一些选项到configure中，让用户能够修改安装程序的名称(如果在用户系统上碰巧有一个与要安装的程序名称相同的程序，这是很有用的)。
AM_PROG_LIBTOOL是由automake用来设置libtool的用途的。只在计划编译共享库或动态可加载模块时才需要设置这个值。
GNOME_COMPILE_WARNINGS给gcc命令行添加许多警告选项，但是在其他绝大多数的编译器上什么也不做。
ALL_LINGUAS=“es”不是一个宏，只是一句shell代码。它包含一个由空格分隔的语言种类缩写表，对应于po子目录下的.po文件。.po文件包含翻译成其他语言的文本，所以ALL_LINGUAS应该列出程序已经被翻译成的所有语言。
另外 配置configure时后缀参数可选择
--host=HOST
是指定软件运行的系统平台.如果没有指定,将会运行`config.guess'来检测.
--build=BUILD
是指定软件包安装的系统平台.如果没有指定,默认值将是'--host'选项的值.
--target=GARGET
是指定软件面向(target to)的系统平台.这主要在程序语言工具如编译器和汇编器上下文中起作用.如果没有指定,默认将使用'--host'选项的值. --prefix=/work/gaoht/gsoap/target
是指定软件安装的位置
一般而言，我们只要指定 --host 就可以了
记住：--host 指定的是交叉编译工具链的前缀
LDFLAGS="-L/usr/non-standard-path/python/lib"
编译流程
交叉编译
确保交叉编译工具链的bin文件在PATH环境变量里，请先透过命令检查下，如果不在，需要手动添加进来。
确认OK之后，查看GCC等相关编译工具的前缀， 这个需要在执行configure时，指定host的
#echo $PATH /usr/local/bin:/bin:/usr/bin:/opt/xxx/bin/ #ls /opt/xxx/bin/ arm-brcm-linux-gnueabi-addr2line arm-brcm-linux-gnueabi-gcov arm-brcm-linux-gnueabi-strip arm-linux-gccbug arm-linux-size arm-linux-uclibc-gcc arm-linux-uclibc-readelf arm-brcm-linux-gnueabi-ar arm-brcm-linux-gnueabi-gprof arm-linux-addr2line arm-linux-gcov arm-linux-strings arm-linux-uclibc-gcc-4.2.3 arm-linux-uclibc-size arm-brcm-linux-gnueabi-as arm-brcm-linux-gnueabi-ld arm-linux-ar arm-linux-gprof arm-linux-strip arm-linux-uclibc-gccbug arm-linux-uclibc-strings arm-brcm-linux-gnueabi-c++ arm-brcm-linux-gnueabi-nm arm-linux-as arm-linux-ld arm-linux-uclibc-addr2line arm-linux-uclibc-gcov arm-linux-uclibc-strip arm-brcm-linux-gnueabi-c++filt arm-brcm-linux-gnueabi-objcopy arm-linux-c++ arm-linux-ldd-VK-copy-test arm-linux-uclibc-ar arm-linux-uclibc-gprof mkfs.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1fbae5639552de30570b93d0f2946136/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce2ea0c5bf1f81645d1ae568c67594ae/" rel="bookmark">
			原生javaScript 模拟鼠标长按事件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原生javaScript 模拟鼠标长按事件
实现 /** * 长按事件模拟 * 有些浏览器有长按复制的功能，需清除默认行为 */ export class LongPress { public element: HTMLElement private callback: Function = () =&gt; {} private duration: number private timer: any constructor(element: HTMLElement, callback: Function, duration = 1000) { this.element = element this.duration = duration this.callback = callback this.timer = 0 this.element.addEventListener('mousedown', this.handleMouseDown.bind(this)) this.element.addEventListener('mouseup', this.handleMouseUp.bind(this)) this.element.addEventListener('mouseleave', this.handleMouseLeave.bind(this)) } handleMouseDown(event: MouseEvent) { event.preventDefault() this.timer = setTimeout(() =&gt; { this.callback?.(event) }, this.duration) } handleMouseUp(event: MouseEvent) { event.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce2ea0c5bf1f81645d1ae568c67594ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79f776bc939e6576bd7bcd9985a256ed/" rel="bookmark">
			Java Telnet客户端
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.第三方库commons-net-*.jar 打开Download Apache Commons Net下载jar包。
2.telnet 客户端 private void connectToServer(String server) { TelnetClient telnetClient = new TelnetClient("VT220"); try { telnetClient.connect(server); InputStream remoteInput = telnetClient.getInputStream(); OutputStream remoteOutput = telnetClient.getOutputStream(); // ReadThread线程监听输入，并输出到System.err ReadThread readThread = new ReadThread(remoteInput); readThread.start(); String line = null; BufferedReader reader = new BufferedReader(new InputStreamReader(System.in)); PrintWriter pw = new PrintWriter(remoteOutput); while ((line = reader.readLine()) != null) { if (line.equals("exit")) { break; } pw.println(line); pw.flush(); System.err.println("request: " + line); } pw.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/79f776bc939e6576bd7bcd9985a256ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9d40ce542127ef6ed5486377602de93/" rel="bookmark">
			Java URI和URL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. URI统一资源标识符 URI(Uniform Resource Identify)，统一资源标识符，是一个用于标识某一互联网资源名称的字符串。
URI的结构是 [scheme:]scheme-specific-part[#fragment]和[scheme:][//authority][path][?query][#fragment]
String[] address = new String[]{ "http://user:pwd@www.abc.com:8080/a/b/c?q=java#fragment", "tel:+123-4567-8910#frag" }; for (String addr : address) { URI uri = new URI(addr); System.out.println("URL: " + uri); System.out.println("Scheme: " + uri.getScheme()); if (uri.isOpaque()) { System.out.println("Specific: " + uri.getSchemeSpecificPart()); } else { System.out.println("UserInfo: " + uri.getUserInfo()); System.out.println("Authority: " + uri.getAuthority()); System.out.println("Host: " + uri.getHost()); System.out.println("Port: " + uri.getPort()); System.out.println("Path: " + uri.getPath()); System.out.println("Query: " + uri.getQuery()); } System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f9d40ce542127ef6ed5486377602de93/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b6fd7c21d1da2178680bb6893337fd8/" rel="bookmark">
			Java 加密算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 散列算法 MD5和SHA主要通过采集文件的信息摘要，以此进行计算并加密。常被用来一致性验证、数字证书和安全访问认证。
1.1 MD5加密 MD5加密后的位数一般为两种，16位与32位。16位实际上是从32位字符串中，取中间的第9位到第24位的部分。
public class MD5 {	public static void encrypt(String value) { try { MessageDigest md = MessageDigest.getInstance("md5"); md.update(value.getBytes()); System.out.println("MD5:" + DatatypeConverter.printHexBinary(md.digest())); } catch (NoSuchAlgorithmException e) {	} } } "Hello World, This is a Test String!"输出
MD5:C1AF26FA2188AF7991B84A8DB1E37C0D
1.2 SHA加密 SHA家族有五个算法，分别是SHA-1、SHA-224、SHA-256、SHA-384、SHA-512。
public class SHA { public static void encrypt(String algorithm, String value) { try { MessageDigest md = MessageDigest.getInstance(algorithm); md.update(value.getBytes()); System.out.println(algorithm + ":" + DatatypeConverter.printHexBinary(md.digest())); } catch (NoSuchAlgorithmException e) { } } } SHA-1输出
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b6fd7c21d1da2178680bb6893337fd8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7594ca1c4e9eb8b64b4e4aac53b2bf12/" rel="bookmark">
			计算 1000!的末尾有多少个零
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		编写程序计算1000！的某尾有多少个0
#include &lt;stdio.h&gt; int main(int argc, char const *argv[]) { int i, k, m; k = 0; for (i = 5; i &lt;= 1000; i = i + 5) { m = i; while (m % 5 == 0) // 含有一个5因子 { k++; m = m / 5; } } printf("%d", k); return 0; } 结尾的每一个0都表示有一个因数10存在。
10可以分解为2 × 5，因此只有质数2和5相乘能产生0，别的任何两个质数相乘都不能产生0，而且2，5相乘只产生一个0。
分解后的整个因数式中有多少对(2, 5)，结果中就有多少个0，而分解的结果中，2的个数显然是多于5的，因此，考虑有多少个5即可。
所以遍历1~1000，分别访问5/10/15....，求出每个数会产生多少个5因子即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f686300b874331cf62b0e7d1afe989c/" rel="bookmark">
			selenium处理弹窗登录认证方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景： 使用selenium开发相关自动化模块时，遇到一个网页需要进行用户认证，如下图所示
需要登录认证后才能进行后续操作。
解决思路： 面对这个弹窗，第一时间想到的是js的prompt弹窗，于是尝试使用webdriver.switch_to_alert()方法对其进行操作，出现如下报错提示：
显然，这个弹窗不属于常规prompt弹窗，无法通过alert对象操作；
经查询资料，得知此认证窗口为HttpBasicAuth请求鉴权时的提示框，从网络分析中也可以看到此时连接未完成，服务端在等待认证；
由此可以从主动提供用户密码这个思路着手，跳过这个认证提示；
查询资料，了解到http协议是可以直接携带用户名密码的，尝试在跳转页面时使用带用户名密码的链接访问：http://username:password@host:port/path/query
username="admin" passwd="123" web.get(f"https://{username}:{passwd}@192.168.xx.xx/Index.html") 成功跳过授权弹窗，直接登录到页面，问题解决！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32dc62d930f1a8e459c37baaad099e2c/" rel="bookmark">
			Java 线程工具类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. CountDownLatch CountDownLatch首先定义任务次数，并调用await()方法等待任务完成。调用countDown()方法表明已经完成一项任务，当任务全部完成后，继续await()方法后的任务。
public class CountDownLatchThread extends Thread { CountDownLatch latch; public CountDownLatchThread(CountDownLatch latch) { this.latch = latch; } public void run() { try { System.out.println(currentThread().getName() + " start"); Thread.sleep(1000); latch.countDown(); System.out.println(currentThread().getName() + " end"); } catch (InterruptedException e) { } } public static void main(String[] args) throws InterruptedException { CountDownLatch latch = new CountDownLatch(2); for (int i = 0; i &lt; 2; i++) { new CountDownLatchThread(latch).start(); } System.out.println(Thread.currentThread().getName() + "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/32dc62d930f1a8e459c37baaad099e2c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8191bfa00851c5ecd1f910527522251/" rel="bookmark">
			conda删除虚拟环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 方法一： # 第一步：首先退出环境 conda deactivate # 第二步：查看虚拟环境列表，此时出现列表的同时还会显示其所在路径 conda env list # 第三步：删除环境 conda env remove -p 要删除的虚拟环境路径 conda env remove -p /home/kuucoss/anaconda3/envs/tfpy36 #我的例子 方法二： # 第一步：首先退出环境 conda deactivate # 第二步：删除环境 conda remove -n 需要删除的环境名 --all 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e98b58639de041962bda08366653fb5/" rel="bookmark">
			重入锁原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 概念：通俗理解：可重入锁的工作原理：ReenTrantLock可重入锁和synchronized的区别：ReentrantLock源码分析:可重入锁代码演示： 概念： Reentrant = Re + entrant，Re是重复、又、再的意思，entrant是enter的名词或者形容词形式，翻译为进入者或者可进入的，所以Reentrant翻译为可重复进入的、可再次进入的，因此ReentrantLock翻译为重入锁或者再入锁。
可重入锁又名递归锁，指的是可重复可递归调用的锁，在外层使用锁之后，在内层仍然可以使用，并且不发生死锁，这样的锁就叫做可重入锁。与可重入锁相反，不可重入锁不可递归调用，递归调用就发生死锁。
可重入锁，当同一个线程在外层方法获取对象锁之后，再进入该线程的内层方法会自动获取锁（前提，锁对象是同一个对象），不会因为之前已经获取过还没释放而阻塞。
重入到哪里：进入同步域（即同步代码块/方法或显式锁锁定的代码）
通俗理解： 通俗来讲：
可重入锁就是一证通/一卡通，只需一张卡就可以通过所有相同关卡。
不可重入锁就是：即使每个关卡相同，你也得再拿一个一摸一样的卡来。
如果把证件/卡看作是同步锁，把关卡看作是同步域（即同步代码块/方法或显式锁锁定的代码），那么可重入锁指的是可重复可递归调用的锁，在外层使用锁之后，在内层仍然可以使用，并且不发生死锁，这样的锁就叫做可重入锁。与可重入锁相反，不可重入锁不可递归调用，递归调用就发生死锁。
在Java中，除了ReentrantLock（显式的可重入锁）以外，synchronized也是重入锁（隐式的可重入锁）。
不可重入锁别名：不可重入锁也叫自旋锁。
可重入锁的工作原理： 可重入锁的工作原理很简单，就是用一个计数器来记录锁被获取的次数，获取锁一次计数器+1，释放锁一次计数器-1，当计数器为0时，表示锁可用。
ReentrantLock实现了Lock接口，Lock接口里面定义了java中锁应该实现的几个方法：
// 获取锁 void lock(); // 获取锁（可中断） void lockInterruptibly() throws InterruptedException; // 尝试获取锁，如果没获取到锁，就返回false boolean tryLock(); // 尝试获取锁，如果没获取到锁，就等待一段时间，这段时间内还没获取到锁就返回false boolean tryLock(long time, TimeUnit unit) throws InterruptedException; // 释放锁 void unlock(); // 条件锁 Condition newCondition(); 总结
可重入锁指的是可重复可递归调用的锁，在外层使用锁之后，在内层仍然可以使用，并且不发生死锁，这样的锁就叫做可重入锁。与可重入锁相反，不可重入锁不可递归调用，递归调用就发生死锁。隐式锁（即synchronized关键字使用的锁）默认是可重入锁，显式锁（即Lock）也有ReentrantLock这样的可重入锁。可重入锁的工作原理很简单，就是用一个计数器来记录锁被获取的次数，获取锁一次计数器+1，释放锁一次计数器-1，当计数器为0时，表示锁可用。不可重入锁也叫自旋锁。 ReenTrantLock可重入锁和synchronized的区别： 可重入性：
从名字上理解，ReenTrantLock的字面意思就是再进入的锁，其实synchronized关键字所使用的锁也是可重入的，两者关于这个的区别不大。两者都是同一个线程每进入一次，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。
锁的实现：
Synchronized是依赖于JVM实现的，而ReenTrantLock是JDK实现的，有什么区别，说白了就类似于操作系统来控制实现和用户自己敲代码实现的区别。前者的实现是比较难见到的，后者有直接的源码可供阅读。
性能的区别：
在Synchronized优化以前，synchronized的性能是比ReenTrantLock差很多的，但是自从Synchronized引入了偏向锁，轻量级锁（自旋锁）后，两者的性能就差不多了，在两种方法都可用的情况下，官方甚至建议使用synchronized，其实synchronized的优化我感觉就借鉴了ReenTrantLock中的CAS技术。都是试图在用户态就把加锁问题解决，避免进入内核态的线程阻塞。
功能区别：
便利性：很明显Synchronized的使用比较方便简洁，并且由编译器去保证锁的加锁和释放，而ReenTrantLock需要手工声明来加锁和释放锁，为了避免忘记手工释放锁造成死锁，所以最好在finally中声明释放锁。
锁的细粒度和灵活度：很明显ReenTrantLock优于Synchronized
ReenTrantLock独有的能力：
ReenTrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。ReenTrantLock提供了一个Condition（条件）类，用来实现分组唤醒需要唤醒的线程们，而不是像synchronized要么随机唤醒一个线程要么唤醒全部线程。ReenTrantLock提供了一种能够中断等待锁的线程的机制，通过lock.lockInterruptibly()来实现这个机制。 ReenTrantLock实现的原理：
在网上看到相关的源码分析，本来这块应该是本文的核心，但是感觉比较复杂就不一一详解了，简单来说，ReenTrantLock的实现是一种自旋锁，通过循环调用CAS操作来实现加锁。它的性能比较好也是因为避免了使线程进入内核态的阻塞状态。想尽办法避免线程进入内核的阻塞状态是我们去分析和理解锁设计的关键钥匙。
什么情况下使用ReenTrantLock：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e98b58639de041962bda08366653fb5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/750efe3b67cee403f63b47d0a855e245/" rel="bookmark">
			n与nodejs（MAC）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是n n是 Mac 下的 node 管理工具,可以在同一台电脑上安装多个Node.js版本灵活切换。
二、nvm 与 n 的区别 n 命令是作为一个 node 的模块而存在，而 nvm 是一个独立于 node/npm 的外部 shell 脚本，因此 n 命令相比 nvm 更加局限。
由于 npm 安装的模块路径均为 /usr/local/lib/node_modules，当使用 n 切换不同的 node 版本时，实际上会共用全局的 node/npm 目录。 因此不能很好的满足『按不同 node 版本使用不同全局 node 模块』的需求。
三、安装 # 1. 清除node缓存: sudo npm cache clean -f # 2. 安装 n 执行: npm install n -g # 3. 查看n是否安装成功： n -V 注意：如果报错如:code EACCES errno -13,表示你没有权限安装，使用管理员身份安装：sudo npm i n -g
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/750efe3b67cee403f63b47d0a855e245/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c512e7e134966ac7b465b4251fda13d/" rel="bookmark">
			SetContentView流程分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、xml加载流程：
Activity
AppCompatActivity
Activity.setContentView流程（android 30）
二、LayoutInflate的参数的作用
// 方式一:将布局添加成功
View view = inflater.inflate(R.layout.inflate_layout, ll, true);
// 方式二：报错，一个View只能有一个父亲（The specified child already has a parent.）
View view = inflater.inflate(R.layout.inflate_layout, ll, true); // 已经addView
ll.addView(view);
// 方式三：布局成功，第三个参数为false
// 目的：想要 inflate_layout 的根节点的属性（宽高）有效，又不想让其处于某一个容器中
View view = inflater.inflate(R.layout.inflate_layout, ll, false);
ll.addView(view);
// 方式四：root = null，这个时候不管第三个参数是什么，显示效果一样
// inflate_layout 的根节点的属性（宽高）设置无效，只是包裹子View，
// 但是子View（Button）有效，因为Button是出于容器下的
View view = inflater.inflate(R.layout.inflate_layout, null, false);
ll.addView(view);
三、描述下merge、include、ViewStub标签的特点
include: 不能作为根元素，需要放在 ViewGroup中findViewById查找不到目标控件，这个问题出现的前提是在使用include时设置了id，而在findViewById时却用了被include进来的布局的根元素id。 为什么会报空指针呢？
如果使用include标签时设置了id，这个id就会覆盖 layout根view中设置的id，从而找不到这个id
代码：LayoutInflate.parseInclude
–》final int id = a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c512e7e134966ac7b465b4251fda13d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14fe27824bde205e336fa1a44578367e/" rel="bookmark">
			C语言之break与continue语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.break语句 功能：在循环语句和switch语句,终止并跳出循环体或开关体。
说明:
(1）break不能用于循环语句和switch语句之外的任何其它语句之中。
(2）在循环语句中，一般break语句与if语句一起使用。
(3）break只能终止并跳出最近一层的结构。
(4)利用break语句可以在循环体的任何位置上结束循环，破坏了循环结构的正常执行顺序，因此，它是一个不符合结构化原则的语句。
例1.在全系1000名学生中，征集慈善募捐，当总数达到10万元时就结束，统计此时捐款的人数，以及平均每人捐款的数目。 问题分析： 1.循环次数不确定，但最多循环1000次。
2.累计捐款总数10万，用if语句检查是否达到10万元。
.如果达到就不再继续执行循环，终止累加。
代码如下：
#include&lt;stdio.h&gt;
void main()
{
int i,a,n=0,sum=0,aver;
for(i=0;i&lt;1000;i++)
{
scanf("%d",&amp;a);
n++;
sum=sum+a;
if(sum&gt;=100000)
break;
}
aver=sum/n;
printf("此时的捐款人数是：%d，平均捐款是：%d",n,aver);
}
例2.输入两个正整数m和n，求其最大公约数和最小公倍数。 穷举法：最大公约数就是同时能整除这两个数的最大整数k。把较小的数从大到小列举，即：对较小数按照从大到小的顺序寻找满足条件的自然数k。
代码如下：
#include&lt;stdio.h&gt;
void main()
{
int m,n,t,i;
printf("请输入m和n：");
scanf("%d%d",&amp;m,&amp;n);
if(m&gt;n)
{
t=m;
m=n,
m=t;
}
for(i=m;m&gt;=1;i--)
{
if(m%i==0&amp;&amp;n%i==0)
{
printf("最大公约数是：%d\n",i);
break;
}
} printf("最小公倍数是：%d",m*n/i);
}
二.continue语句 功能：提前结束本次循环，跳过循环体中尚未执行的语句，进行下一次是否执行循环体的判断。
说明:
(1)仅用于循环语句中，和break一样，通常和if一起使用。
(2)在嵌套循环的情况下，continue语句只对包含它的最内层的循环体语句起作用。
(3)利用continue语句可以在循环体的任何位置上结束本次循环而开始下次的循环，破坏了循环结构的正常执行顺序，因此，它也是一个不符合结构化原则的语句。
例3.输出100~200之间的不能被3整除的数。 代码如下：
#include&lt;stdio.h&gt;
void main()
{
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/14fe27824bde205e336fa1a44578367e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c14a531c3dfb19b51f5eb94b38995e0a/" rel="bookmark">
			如何快速地注释Python代码？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 Python 中，单行注释使用“#”符号，多行注释使用三个单引号（'''）或三个双引号（"""）括起来的块。注释通常用于解释代码的目的，提供对代码的描述、解释、文档等等。
以下是一些快速注释 Python 代码的方法：
单行注释：在需要注释的代码行前加上“#”符号。
# This is a comment print("Hello, World!") 多行注释：使用三个单引号（'''）或三个双引号（"""）括起来的块。
''' This is a multi-line comment. ''' """ This is another multi-line comment. """ 快速注释：选中要注释的代码块，按下 Ctrl + /（Windows、Linux）或 Command + /（macOS）快捷键，即可在所选行前面添加“#”符号进行注释。
# This is a comment print("Hello, World!") # This is another comment print("Goodbye, World!") 使用注释是一种很好的代码习惯，可以帮助其他人更好地理解代码。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59b421cbdbef63eccae1bdfaf419ccd2/" rel="bookmark">
			微信小程序：简单实现查看天气小程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		准备工作 首先注册和风天气账号，创建一个免费版的项目，准备好api接口，查看自己的key
获取位置location 如果想获取某个城市天气信息就必须知道这个城市的location和key去请求
https://devapi.qweather.com/v7/weather/3d?location='地址参数'&amp;key='自己的key' 那么官方也提供了获取地址location的api，调用即可，其中location和key必填，location支持文字、以英文逗号分隔的经度,纬度坐标（十进制，最多支持小数点后两位）、LocationID或Adcode（仅限中国城市）
https://geoapi.qweather.com/v2/city/lookup?[请求参数] 返回的数据:可以取到想要的id
配置页面 在wxml中写一个picker省级选择器用于选择城市
&lt;picker mode="region" bindchange="bindRegionChange" value="{{region}}"&gt; &lt;view class="picker"&gt; 请选择城市：{{region[0]}} {{region[1]}} {{region[2]}} &lt;/view&gt; &lt;/picker&gt; 绑定事件获取城市信息
bindRegionChange(e){ this.setData({ region:e.detail.value }) this.getLocationid()//获取地址location setTimeout(()=&gt;{ //设置计时器保证先获取到location再请求天气信息 this.getWeather() },500) }, 调用接口
//获取地址location的方法 getLocationid(){ wx.request({ url: `https://geoapi.qweather.com/v2/city/lookup?location=${this.data.region[2]}&amp;key=${this.data.key}`, method:'GET', success:(res)=&gt;{ this.setData({ location:res.data.location[0].id }) } }) }, //获取天气的方法 getWeather(){ wx.request({ url: `https://devapi.qweather.com/v7/weather/3d?location=${this.data.location}&amp;key=${this.data.key}`, method:'GET', success:(res)=&gt;{ this.setData({ todayList:res.data.daily[0] }) } }) }, 获取的天气数据（三天）
渲染页面 最后将得到的数据根据自己的需求渲染到页面即可得到一个简易查看各个城市天气的小程序
接口请求失败记得配置小程序域名，将https://devapi.qweather.com配置到域名中
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12a790bc68707cc630a04edf0f131fcd/" rel="bookmark">
			个人对408计算机组成原理中PC（程序计数器）位数的理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先PC程序计数器的位数与主存的容量有关系也和要获取下一条要执行的指令也有关系。
假设PC要获取完主存中所有的指令那么PC要持续+“1”直到获取完最后一条指令，这里的“1”指的是PC指令的条数，PC+"1"等于下一条指令，而不代表指令长度。
根据408真题中2016年的选择题
某计算机主存空间为4GB,字长为32位，按字节编址，采用32位定长指令字格式,若指令按字边界对齐存放,则程序计数器(PC)和指令寄存器（IR）的位数至少为（）。
那么以下用三种情况去理解
1.每一条指令字长刚好等于主存中的存储字长，且按字边界对齐存放
那么PC每次+1就代表刚好指到下一条指令的实际存放地址，同时也刚好对应下一条指令，指令有2^30次方条那么对应PC一共要加上2^30个1，所以需要30位来表示
2.指令分成份放在不同行存储单元，这时要获取每条指令就需要PC+2才能对应到相应的指令地址，有2^30次方条指令，那么要获取完所有指令那么PC一共要加上2^30个2，所以对应2^31，因此需要31位来表示
3.一条指令字长等于存储字长的四倍，那么一条指令需要四个单元去存储，所以PC要一次性+4才能获取到一条完整的指令，同理有2^30次方条指令，那么要4*2^30共需要32位才行。
综上其实可以知道，PC具体有多少位要看PC加几才能获取到下一条指令同时也要知道指令有多少条二者相乘即可得到PC的位数。
以上是本人最近初学计组对PC位数的理解，有很多不足之处，有错误的话希望大家能帮我指出。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3532e6f82559c20d551684e700d06e98/" rel="bookmark">
			在win10系统下右击文件添加使用pycharm打开
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在安装pycharm的时候没有勾选添加右击文件夹打开pycharm的功能，而安装vscode时候勾选了，最近一直在用右击使用vscode打开，感觉这样也挺方便的，查找了一些资料通过添加注册表的方式能够右击使用pycharm打开，固记录一下。
首先打开注册表编辑器，按win键注输入"注册表编辑器"打开即可。
点击找到注册表编辑器中的"计算机\HKEY_CLASSES_ROOT\Directory"，这里面的"Background"字段为右击文件管理器中空白区域弹出的菜单，“shell"字段为右击文件菜单中的各种选项。
想要在右击文件的菜单栏中添加使用pycharm打开，只需要在"shell"字段中添加相关配置即可。在"shell"字段中右击”新建“-&gt;”项“，命名为”PyCharm“
再右击"pycharm"字段，选择"新建”-&gt;”字符串值“，并命名为"Icon"，修改"Pycharm"数据中"默认"字段的数据为"Open PyCharm here"，修改"Icon"为pycharm的exe路径，这个需要根据自己的实际情况进行更改。
接着右击"PyCharm"字段右击选择"新建"-&gt;”项“，命名为"command"，修改"command"字段中"默认"中字段值为"pycharm 路径" “%V”，这里的pycharm路径和上面的路径一致，后面"%V"必须要加。
通过这样的修改，右击文件菜单就可以通过pycharm打开项目工程了，方便了很多，右击在文件管理器打开pycharm的修改过程和上面一致，只需要修改注册表中background字段中shell的值即可，就不再重复说明过程了。
以上为右键添加快捷方式的记录，过程十分的简单，删除右键这些快捷打开方式的原理和添加类似，只需要删除"backgound"和"shell"字段中的相关配置就行。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe5ce04032b408eba16ffdf4e588ac22/" rel="bookmark">
			数制与转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数制也称为计数体制，是一种用一组固定的符号和统一的的规则表示数值大小的计数方法。例如，在日常生活中，24小时为一天，采用的是二十四进制；7天为一个星期，采用的是七进制，12个月为一年，采用的是十二进制......
概念 一组数码：用来表示某种进制的符号。例如0，1，2，3......
基数：数制所用的数码个数。例如：二进制有2个计数符号，所以二进制的基数是2
位权：表示不同位置上的权值。例如，二进制,整数部分从右往左（由低位到高位）依次是、、、......,小数部分从左往右（从高位到低位）依次是、、......。
进制运算规则基数位权前缀后缀数码二进制逢二进一20B/0bB0、1八进制逢八进一80O/0O0、1、2、3、4、5、6、7十进制逢十进一10无D0、1、2、3、4、5、6、7、8、9十六进制逢十六进一160xH0、1、2、3、4、5、6、7、8、9、A、B、C、D、E、F（a、b、c、d、e、f） 数制间的转换 R进制转换为十进制 按权展开法：将任意一个R进制数转换成十进制时，求出每位数字与其位权的乘积之和，即可得到相应的十进制数。 例如：
（11010）B（1*+1*+0*+1*+0*）D=（26）D
（3725）O（3*+7*+2*+5*）D=（2005）D
（a4f）H（10*+4*+15*）D=（2639）D
十进制转换为R进制数 整数部分—除基取余：用十进制整数除以基数R取余数，直到商为0，得到的余数从后面向前排列，就可以得到R进制整数部分各位的数码。小数部分—乘基取整：用十进制小数乘以基数R取整数，直到小数部分为0或满足精度要求为止，得到的整数从前向后排列，就可以得到R进制数小数部分各位的数码。 例如： (29.25)D(11101.01)B
(29.25)D(35.2)O
(29.25)D(1d.4)H
二进制与八进制之间的转换 由于二进制和八进制间存在=8的特殊关系，所以1位八进制数和3位二进制数对应。从小数点开始，将二进制数整数部分从右向左3位一组，小数部分从左向右3位一组进行划分，最后一组若不足3位，则用0补足，然后写出每组对应的八进制字符，即可得到对应的八进制数。
例如：
(1110100110.1011)B=(001 110 100 110 . 101 100)B(1646.54)O
（1 6 4 6 . 5 4）O
（ 5 3 2 1 . 4 6 ）O（101 011 010 001 . 100 110）B
（101 011 010 001 . 100 110）B
二进制与十六进制之间的转换 由于二进制和十六进制间存在=16的关系，所以1位十六进制数和4位二进制数对应。从小数点开始，将二进制整数部分从右向左4位一组，小数部分从左向右4位一组进行划分，最后一组若不足4位，则用0补足，然后写出每组对应的十六进制字符，即可得到对应的十六进制数。
例如：
（1110100110.10101）B=（0011 1010 0110 . 1010 1000）B（3A6.A8）H
（3 A 6 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe5ce04032b408eba16ffdf4e588ac22/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0173fbeca2bc3605bc6f00873bb8aae3/" rel="bookmark">
			c语言经典例题（在一个数字中查找统计特定数字个数）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 &lt;font color = red&gt;题目描述:输入描述：输出描述： &lt;font color = red&gt;代码展示:代码详解: 题目描述: 每一个数字中有多少个数字‘7’。（以7为例）
输入描述： 输入第一行一个整数n(1&lt;=n&lt;=10)
接下来有T组测试数据，对于每组测试数据，输入一个整数k(1&lt;=k&lt;=10000000000)。
输出描述： 对于每组测试数据，输出对应答案。
代码展示: 1.#include&lt;stdio.h&gt; 2.void fun(long long n){ 3. int m=0; 4. while(n&gt;0){ 5. if(n%10==7) m++; 6. n/=10; 7. } 8. printf("%d\n",m); 9.} 10.int main(){ 11. int n; 12. long long k; 13. scanf("%d",&amp;n); 14. int i; 15. for(i=1;i&lt;=n;i++){ 16. scanf("%lld",&amp;k); 17. fun(k); 18. } 19. return 0; 20.} 代码详解: 本题的重点是统计出现个数所以定义了一个m进行统计出现个数，在定义的fun函数中用逐位取余进行筛选符合条件的数，进行m的累加即可。最后注意k的值比较大，要注意进行long long型进行定义，以防空间不够的情况发生。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ab9c367568c8d05a72500f9871d01df/" rel="bookmark">
			[golang gin框架] 5.Cookie以及Session
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.Cookie (1).介绍 HTTP 是无状态协议,简单地说，当浏览了一个页面，然后转到同一个网站的另一个页 面，服务器无法认识到这是同一个浏览器在访问同一个网站,每一次的访问，都是没有任何 关系的,如果要实现多个页面之间共享数据的话就可以使用 Cookie 或者 Session 实 现 cookie 是存储于访问者计算机的浏览器中,可以用同一个浏览器访问同一个域名 的时候共享数据 (2).Cookie 能实现的功能 1).保持用户登录状态
2).保存用户浏览的历史记录
3).电商网站的加入购物车
...
(3).设置和获取 Cookie,多个二级域名共享 cookie 参考文档:https://gin-gonic.com/zh-cn/docs/examples/cookie/
参考文章:https://blog.csdn.net/zhoupenghui168/article/details/128885820
设置 Cookie
c.SetCookie(name, value string, maxAge int, path, domain string, secure, httpOnly bool) 参数说明: 第一个参数 key 第二个参数 value 第三个参数 过期时间.如果只想设置 Cookie 的保存路径而不想设置存活时间，可以在第三个 参数中传递 nil 第四个参数 cookie 的路径 第五个参数 cookie 的路径 Domain 作用域 本地调试配置成 localhost , 正式上线配置成域名 第六个参数是 secure ，当 secure 值为 true 时，cookie 在 HTTP 中是无效，在 HTTPS 中 才有效 第七个参数 httpOnly，是微软对 COOKIE 做的扩展。如果在 COOKIE 中设置了“httpOnly”属性， 则通过程序（ JS 脚本、applet 等）将无法读取到 COOKIE 信息，防止 XSS 攻击产生 获取 Cookie
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ab9c367568c8d05a72500f9871d01df/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff8c59346bf840d133d17beadd8b130c/" rel="bookmark">
			蓝桥杯第十届真题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介：好久不来更新啦！因为学业忙碌，所以码代码的时间持续减少，不过最近省赛临近，应该会陆续更新。废话少说，直接上干货。这次做的真题是第十届省赛题，题目难度不大。
一.题目 二.CubeMX的配置 外设的配置很少，常规的LED，按键和LCD，唯一不同的他需要采集ADC采集内部电压。
三.代码的编写 主函数
unsigned char str1pre[20],str1[20],status[10],status_pre[10]; unsigned char LCD_flag,LEDU_flag=1,LEDL_flag=2,light_flag=1;//light_flag-高亮标志符，LEDL_flag-低位LED标志符，LEDU_flag高位标志符 //LCD_flag页面标志符 uint16_t LED[9]={0x00,0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80}; float ADC_Value,ADC_Upper=2.4,ADC_Lower=1.2; ADC的采集
float ADC(void) { float adc_value; HAL_ADC_Start(&amp;hadc2); HAL_ADC_PollForConversion(&amp;hadc2,0xffff); adc_value=HAL_ADC_GetValue(&amp;hadc2)*3.3/4096; return adc_value; } LCD的显示
void LCD_Disp(void) { unsigned char str[50];	LCD_SetBackColor(Blue); LCD_SetTextColor(White); if(LCD_flag==0) {	if(ADC_Value&gt;ADC_Upper) { strcpy(status,"Upper"); LED_Disp(LED[LEDU_flag]); HAL_Delay(200); LED_Disp(LED[0]); HAL_Delay(200); } else if(ADC_Value&lt;ADC_Lower) { strcpy(status,"Lower"); LED_Disp(LED[LEDL_flag]); HAL_Delay(200); LED_Disp(LED[0]); HAL_Delay(200); } else { strcpy(status,"Normal"); LED_Disp(LED[0]); } if(strlen(status)&lt;strlen(status_pre)) { LCD_Clear(Blue); } strcpy(status_pre,status); sprintf(str1," Main "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ff8c59346bf840d133d17beadd8b130c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f91ccc3f28649affbe7a3b79eab3dc04/" rel="bookmark">
			memset函数的坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前几天开发项目时，需要对一个数组中的每一个元素都赋一个相同的整数值，当时想都没想，就直接调用memset函数进行了处理
int data[64] = {0}; int value = 25; memset(data, value, 64); 结果却发现data中的每一个值都是421075225，并非是想要的25，很奇怪，后来查了一下，原来memset是将目标地址中的每一个字节都赋相同的值，因为int是4个字节，所以是00011001000110010001100100011001（每一个字节都是25--00011001），就是421075225
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ed46f3349def4f7e31d05141f7d6e4a/" rel="bookmark">
			3种伺服电机控制方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		伺服电机速度控制和转矩控制都是用模拟量来控制，位置控制是通过发脉冲来控制。具体采用什么控制方式要根据客户的要求以及满足何种运动功能来选择。
接下来，给大家介绍伺服电机的三种控制方式：
如果您对电机的速度、位置都没有要求，只要输出一个恒转矩，当然是用转矩模式。
如果对位置和速度有一定的精度要求，而对实时转矩不是很关心，用速度或位置模式比较好。
如果上位控制器有比较好的闭环控制功能，用速度控制效果会好一点。如果本身要求不是很高，或者基本没有实时性的要求，用位置控制方式对上位控制器没有很高的要求。
就伺服驱动器的响应速度来看：转矩模式运算量最小，驱动器对控制信号的响应最快；位置模式运算量最大，驱动器对控制信号的响应最慢。
对运动中的动态性能有比较高的要求时，需要实时对电机进行调整。
如果控制器本身的运算速度很慢（比如PLC，或低端运动控制器），就用位置方式控制。
如果控制器运算速度比较快，可以用速度方式，把位置环从驱动器移到控制器上，减少驱动器的工作量，提高效率；
如果有更好的上位控制器，还可以用转矩方式控制，把速度环也从驱动器上移开，这一般只是高端专用控制器才能这么做。
一般说驱动器控制的好坏，有个比较直观的比较方式，叫响应带宽。
当转矩控制或速度控制时，通过脉冲发生器给它一个方波信号，使电机不断的正转、反转，不断的调高频率，示波器上显示的是个扫频信号，当包络线的顶点到达最高值的70.7%时，表示已经失步，此时频率的高低，就能说明控制的好坏了，一般电流环能做到1000HZ以上，而速度环只能做到几十赫兹。
转矩控制 转矩控制方式是通过外部模拟量的输入或直接的地址的赋值来设定电机轴对外的输出转矩的大小，具体表现为例如10V对应5Nm的话，当外部模拟量设定为5V时电机轴输出为2.5Nm：如果电机轴负载低于2.5Nm时电机正转，外部负载等于2.5Nm时电机不转，大于2.5Nm时电机反转（通常在有重力负载情况下产生）。可以通过即时的改变模拟量的设定来改变设定的力矩大小，也可通过通讯方式改变对应的地址的数值来实现。
应用主要在对材质的受力有严格要求的缠绕和放卷的装置中，例如饶线装置或拉光纤设备，转矩的设定要根据缠绕的半径的变化随时更改以确保材质的受力不会随着缠绕半径的变化而改变。
位置控制 位置控制模式一般是通过外部输入的脉冲的频率来确定转动速度的大小，通过脉冲的个数来确定转动的角度，也有些伺服可以通过通讯方式直接对速度和位移进行赋值。由于位置模式可以对速度和位置都有很严格的控制，所以一般应用于定位装置。
应用领域如数控机床、印刷机械等等。
速度模式 通过模拟量的输入或脉冲的频率都可以进行转动速度的控制，在有上位控制装置的外环PID控制时速度模式也可以进行定位，但必须把电机的位置信号或直接负载的位置信号给上位反馈以做运算用。位置模式也支持直接负载外环检测位置信号，此时的电机轴端的编码器只检测电机转速，位置信号就由直接的最终负载端的检测装置来提供了，这样的优点在于可以减少中间传动过程中的误差，增加了整个系统的定位精度。
谈谈三环 伺服电机一般为三个环控制，所谓三环就是3个闭环负反馈PID调节系统。最内的PID环就是电流环，此环完全在伺服驱动器内部进行，通过霍尔装置检测驱动器给电机的各相的输出电流，负反馈给电流的设定进行PID调节，从而达到输出电流尽量接近等于设定电流，电流环就是控制电机转矩的，所以在转矩模式下驱动器的运算最小，动态响应最快。
第2环是速度环，通过检测的电机编码器的信号来进行负反馈PID调节，它的环内PID输出直接就是电流环的设定，所以速度环控制时就包含了速度环和电流环，换句话说任何模式都必须使用电流环，电流环是控制的根本，在速度和位置控制的同时系统实际也在进行电流（转矩）的控制以达到对速度和位置的相应控制。
第3环是位置环，它是最外环，可以在驱动器和电机编码器间构建也可以在外部控制器和电机编码器或最终负载间构建，要根据实际情况来定。由于位置控制环内部输出就是速度环的设定，位置控制模式下系统进行了所有3个环的运算，此时的系统运算量最大，动态响应速度也最慢。
https://mp.weixin.qq.com/s/YZYTh-rf2neYsbWlPTGKOQ
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36a901d8d3cfb9e741900c911ebc3242/" rel="bookmark">
			【pytorch】交叉熵损失函数 nn.CrossEntropyLoss()
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、交叉熵损失函数 交叉熵损失多用于 多分类函数，下面我们通过拆解交叉熵的公式来理解其作为损失函数的意义
假设我们在做一个 n分类的问题，模型预测的输出结果是 [ x 1 , x 2 , x 3 , . . . . , x n ] [x_1, x_2, x_3, ...., x_n] [x1​,x2​,x3​,....,xn​]
然后，我们选择交叉熵损失函数作为目标函数，通过反向传播调整模型的权重
nn.CrossEntropyLoss() 的公式为：
l o s s ( x , c l a s s ) = − l o g ( e x [ c l a s s ] ∑ j e x j ) = − x [ c l a s s ] + l o g ( ∑ j e x j ) \begin{aligned} loss(x, class) &amp;= -log(\frac{e^{x_{[class]}}}{\sum_je^{x_{j}}})\\ &amp;= -x_{[class]} + log(\sum_j e^{x_{j}}) \end{aligned} loss(x,class)​=−log(∑j​exj​ex[class]​​)=−x[class]​+log(j∑​exj​)​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/36a901d8d3cfb9e741900c911ebc3242/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9265eb7c26fe5f5b689f6af3bfc03650/" rel="bookmark">
			Linux下解决Java输出文件，中文变问号和中文乱码问题。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux下Java输出带中文的文件，出现问号或者中文乱码问题：
解决方法很简单，大概分为两个步骤：安装和设置字库、设置语言环境变量。最终效果：
需要注意：
已经由Java等程序输出的文件（???文件名），因为是生成文件时，缺少字符集；添加和更改中文后，还是显示???。一些教程会让你直接修改/etc/default/locale，但是个人不建议修改这个文件为zh。 安装字库 首先，看看系统有没有中文字库：
locale -a | grep zh_CN 1 如果你没有中文字库，需要先安装中文字体。
安装中文字体 安装中文字体很简单：
# Debian sudo apt install fonts-wqy-zenhei # CentOS sudo yum install kde-l10n-Chinese 一般上述字体就足够使用，如果你在后文配置后，依旧无法使用，可以尝试安装全部wqy字体：
# Debian sudo apt install xfonts-intl-chinese sudo apt install wqy\* 激活中文字库 之后，激活中文字体，CentOS一般不需要激活中文字库：
# Debian sudo apt install locales sudo dpkg-reconfigure locales 之后，就会进行语言选择：
通过使用方向键来浏览列表，并使用空格来勾选激活区域设置。这里建议勾选en_US.UTF-8、zh_CN. UTF-8 URF-8 等：
之后，回车：
选择默认系统语言，还是推荐用英文：
![选择en_US.UTF-8](https://img-blog.csdnimg.cn/dfdd550aa39645fbb6e4af83dad2b173.png
之后，再回车。系统会自动开始配置：
很多文章，会直接让你在这里直接设置为zh_CN.UTF-8，我个人不建议这样设置。灵活性有点低，个人建议设置到用户的环境变量（见下文）。
设置中文环境 现在，我们就可以设置中文环境了。也很简单，根据你当前的Shell，设置环境变量，查看当前Shell：
echo $SHELL 可以看到，我的Shell是zsh，你们的可能是/bin/bash，如果是和我一样，那么环境变量就是： ~/.zshrc。如果是/bin/bash，那么环境变量就是：~/.bashrc。
# 编辑环境变量 vim ~/.zshrc 之后，在文末追加：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9265eb7c26fe5f5b689f6af3bfc03650/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7b2027826d8bcad527bab0899856f4b/" rel="bookmark">
			eNSP 生成树基础实验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		端口角色
发送BPDU
接收BPDU
发送数据
接收数据
根端口
是
是
是
是
指定端口
是
是
是
是
预备端口
否
是
否
否
关于本实验 在本实验展示的微型企业环境中，公司网络分为两层结构：核心层和接入层。在多数情况下，根交换机位于核心层，以优化交换效率。实际上，在交换网络中，STP默认可以正常工作，它会自动打破环路，并在网络出现故障时提供一定程度的冗余性和可恢复性。然而，如果没有人为干预，STP在运行时有可能会产生次优的交换路径或较长的等候时间，因此管理员希望使用一些参数对STP的运行进行调整。
实验目的 了解如何切换STP模式：STP、RSTP、MSTP。
指定根交换机和备份根交换机。
调整交换机设备优先级。
调整端口路径开销。
调整端口优先级。
配置根保护。
配置BPDU保护。
配置边缘端口。
配置MSTP。
实验组网介绍 实验任务列表 搭建拓扑，确认当前环境。
启用STP，并将S1设置为根交换机。
启用交换机S4，并观察STP端口状态机。
调整STP参数，影响选举和收敛时间。
配置STP保护参数。
配置MSTP。
实验配置任务 搭建拓扑，确认当前环境。 1.先开启交换机S1、S2和S3，并查看S1、S2、S3上的STP端口角色。
启用STP，并将S1设置为根交换机。 1.在S1上配置STP并将其设置为根交换机。
2.在S2、S3上配置STP。
3.查看S1、S2、S3上的STP端口角色。
4.在S2上使用display stp来查看更多有关STP的详细信息。
启用交换机S4，并观察STP端口状态机。 1.交换机S4的初始化配置。
2.通过交换机S2、S3观察端口STP状态变化。
调整STP参数，影响选举和收敛时间。 1.更改S2的设备优先级。
2.观察S4的根端口变化。
3.查看默认开销。
3.更改S4 G0/0/3的端口开销。
4.查看S4更改后的端口开销。
5.默认的STP计时器值。
6.在根交换机上更改STP计时器值。
7.验证S1、S4上的STP计时器值。
8.在根交换机上配置STP网络直径为3。
配置STP保护参数。 1.启用根保护。
2.查看根保护状态。
3.启用环路保护。
4.查看环路保护状态。
5.查看S3的端口状态。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7b2027826d8bcad527bab0899856f4b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12d31ee36db466dbc6cb97618bc0b3dc/" rel="bookmark">
			Android：ThreadLocal的简单理解和使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ThreadLocal的简单理解和使用 1、背景1.1、背景及问题1.2、每个线程需要一个独享的对象1.2、每个线程需要一个独享的对象 2、ThreadLocal原理2.1、使用说明2.2、ThreadLocal的set方法2.3、ThreadLocalMap 内部结构2.3.1、ThreadLocalMap 的set()方法2.3.1.1、第一种情况， Key值相同2.3.1.2、第二种情况，如果当前位置对应Entry的Key值为null2.3.1.3、第三种情况，当前对应位置为null 2.4、ThreadLocal的get()方法 3、ThreadLocal内存泄漏的问题3.1、为什么使用弱引用3.2、弱引用带来的问题 4、总结参考 1、背景 对于ThreadLocal，日常开发中一般有两种使用场景：
每个线程需要一个独享的对象：比如Android中的Looper，后端中常用的工具类（如SimpleDateFormat）每个线程内需要保存全局变量：都知道Java服务端Controller作为接口响应入口，Service处理业务逻辑，Repository提供数据库CRUD数据接口，类似在拦截器中获取的用户信息这类共享数据，就可以放置到ThreadLocal中，就不用一层一层的通过参数传递下去。 1.1、背景及问题 一般来说，当某些数据是以线程为作用域并且不同线程具有不同的数据副本的时候，就可以考虑采用ThreadLocal。
比如对于Handler来说，它需要获取当前线程的Looper，很显然Looper的作用域就是线程并且不同线程具有不同的Looper，这个时候通过ThreadLocal就可以轻松实现Looper在线程中的存。 如果不采用ThreadLocal，那么系统就必须提供一个全局的哈希表供Handler查找指定线程的Looper，这样一来就必须提供一个类似于LooperManager的类了，但是系统并没有这么做而是选择了ThreadLocal，这就是ThreadLocal的好处。 ThreadLocal另一个使用场景是复杂逻辑下的对象传递，比如监听器的传递，有些时候一个线程中的任务过于复杂，这可能表现为函数调用栈比较深以及代码入口的多样性，在这种情况下，我们又需要监听器能够贯穿整个线程的执行过程，这个时候可以怎么做呢？其实这时就可以采用ThreadLocal，采用ThreadLocal可以让监听器作为线程内的全局对象而存在，在线程内部只要通过get方法就可以获取到监听器。 如果不采用ThreadLocal，那么我们能想到的可能是如下两种方法： 第一种方法是将监听器通过参数的形式在函数调用栈中进行传递，第二种方法就是将监听器作为静态变量供线程访问。 上述这两种方法都是有局限性的。
第一种方法的问题是当函数调用栈很深的时候，通过函数参数来传递监听器对象这几乎是不可接受的，这会让程序的设计看起来很糟糕。第二种方法是可以接受的，但是这种状态是不具有可扩充性的，比如同时有两个线程在执行，那么就需要提供两个静态的监听器对象，如果有10个线程在并发执行呢？提供10个静态的监听器对象？这显然是不可思议的，而采用ThreadLocal，每个监听器对象都在自己的线程内部存储，根本就不会有方法2的这种问题。 1.2、每个线程需要一个独享的对象 对于拿到时间戳，我们通常需要通过SimpleDateFormat类来将其转换成相应的日期格式，假设我们有如下一个工具类：
public class DateUtils { public static String format(long milliSeconds) { SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss"); return dateFormat.format(new Date(milliSeconds)); } } 现在我们通过线程池来模拟多线程环境：
public class ThreadLocalTest2 { private static ExecutorService threadPool = Executors.newFixedThreadPool(5); public static void main(String[] args) { for (int i = 0; i &lt; 10; i++) { int finalI = i; threadPool.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/12d31ee36db466dbc6cb97618bc0b3dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75d2ecdfaa0eec08026463b2100f71f5/" rel="bookmark">
			深度优先搜索
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		:::info
深度优先搜索（Depth-First Search，DFS）是一种用于图遍历或树遍历的算法。它从起点开始沿着一条路径一直走到底，直到无法再继续前进，然后返回上一个节点继续搜索，直到所有节点都被访问过为止。
具体实现时，可以用递归或栈的方式来实现深度优先搜索。在递归实现中，从起点开始递归搜索下一个节点，如果遇到无法继续前进的情况，就返回上一个节点继续搜索；在栈的实现中，每次将当前节点的所有邻居节点压入栈中，然后取出栈顶元素，重复这个过程直到栈为空。
深度优先搜索可以用于找到图或树的某个节点，或者找到图或树中的一条路径。但是需要注意的是，由于深度优先搜索是一种盲目搜索算法，所以在处理大型图或树时可能会出现性能问题，并且不一定能够找到最优解。
填涂颜色（作业问题） 描述
由数字0组成的方阵中，有一任意形状闭合圈，闭合圈由数字1构成，围圈时只走上下左右4个方向。现要求把闭合圈内的所有空间都填写成2。例如：6×6的方阵（n=6），涂色前和涂色后的方阵如下：
0 0 0 0 0 0
0 0 1 1 1 1 0 1 1 0 0 1 1 1 0 0 0 1 1 0 0 0 0 1 1 1 1 1 1 1
0 0 0 0 0 0
0 0 1 1 1 1 0 1 1 2 2 1 1 1 2 2 2 1 1 2 2 2 2 1 1 1 1 1 1 1
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/75d2ecdfaa0eec08026463b2100f71f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0bdaf6622f043322b50387e8653b1738/" rel="bookmark">
			深度优先搜索（DFS）（算法笔记）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文内容基于《算法笔记》和官方配套练题网站“晴问算法”，是我作为小白的学习记录，如有错误还请体谅，可以留下您的宝贵意见，不胜感激。
文章目录 前言一、深度优先搜索概述二、算法设计1.迷宫可行路径数2.指定步数的迷宫问题3.矩阵最大权值4.矩阵最大权值路径 三、备注 前言 深度优先搜索是一种枚举所有完整路径以遍历所有情况的搜索方法，总是以“深度”作为前进的关键词。实现方式是有很多，最常见的是递归。
一、深度优先搜索概述 深度优先搜索属于搜索问题的一种，当问题可以被描述为“路径搜索”时，就可以采用搜素问题的所有解的方式来进行解决，所以DFS本质还是暴力。
深度搜索具有两个关键词，即“岔道口”和“死胡同”，这两个词来源于迷宫问题，这也是搜索问题最原始的表现。当碰到岔道口时，总是以“深度”作为前进的关键词，不碰到死胡同就不回头，因此被称为“深搜”。深搜适合于求解需要遍历所有解或路径的问题，并且剪枝很重要。深搜和广搜在数据结构中的应用就是对非线性存储结构进行遍历。
搜索和分治是两大分析问题的方法，而回溯、剪枝、动态规划可以说是对深度搜索和分治算法进行优化。
二、算法设计 在使用递归进行DFS时，将递归式作为搜索中的“岔道口”，将递归边界作为搜索中的“死胡同”，所以在设计DFS算法时，关键就是找准问题中的“岔道口”和“死胡同”。接下来通过实际例子介绍DFS，这里采用“晴问算法”中的题，书中的例题就不放了。
1.迷宫可行路径数 这道题是接下来一系列问题的核心，下面的问题都是基于这道题进行局部修改。
首先分析“岔道口”：
每次移动可以选择上下左右各一格进行移动，也就是说每次有四种选择，即四个岔道口，设当前坐标为（x ，y），四个岔道口的选择就分别为：（x+1，y），（x-1，y），（x，y+1），（x，y-1）。
其次分析“死胡同”：
当搜索到坐标位置元素为1时，表示无法通过，即无法继续搜索，这时这条路径便走到了尽头；当搜索到终点时，就不用继续搜索了。所以一共存在两个递归边界。
接下来就可以设计DFS（）函数：
根据上面“岔道口”的设计，我们需要设置初始状态，即起点。用x表示行坐标，用y表示列坐标，所以函数看起来设这样的：
void DFS(int x , int y , int n , int m){···}，当然，n和m可以放在外面。
递归边界：
if(number[x][y] == 1) return; //死胡同
if(x == n &amp;&amp; y == m) { //走到终点
countr++; //计数器
return;
}
岔路口的选择：
需要路径在可移动范围内移动：不允许到曾经到过的地方并且不能出界，所以设置散列表标记曾经走过的位置，注意起点的状态，不论哪条路起点肯定是必须走的。如果满足移动条件，就沿岔路口移动。
完整代码如下：
#include&lt;cstdio&gt; //迷宫首先要确定起点和终点 #include&lt;algorithm&gt; #include&lt;iostream&gt; using namespace std; const int MAXN = 5; int number[MAXN][MAXN] = {}; int countr = 0; bool hashTable[MAXN][MAXN] = {true}; //这就不是优化了，如果不设这个条件，就会到达不了递归边界 //注意起点的状态，肯定要经过起点 void DFS(int x , int y , int n , int m){ if(number[x][y] == 1) return; //死胡同 if(x == n &amp;&amp; y == m) { countr++; return; } //核心：四个岔路口 if(x + 1 &lt;= n &amp;&amp; hashTable[x + 1][y] == false) { //短路与，顺序也不能乱，不然会报错 hashTable[x + 1][y] = true; //注意一定是先把状态更新，先选上，再走 DFS(x + 1 , y , n , m); hashTable[x + 1][y] = false; //恢复状态 } if(x - 1 &gt;= 0 &amp;&amp; hashTable[x - 1][y] == false) { hashTable[x - 1][y] = true; DFS(x - 1 , y , n , m); hashTable[x - 1][y] = false; } if(y + 1 &lt;= m &amp;&amp; hashTable[x][y + 1] == false) { hashTable[x][y + 1] = true; DFS(x , y + 1 , n , m); hashTable[x][y + 1] = false; } if(y - 1 &gt;= 0 &amp;&amp; hashTable[x][y - 1] == false) { hashTable[x][y - 1] = true; DFS(x , y - 1 , n , m); hashTable[x][y - 1] = false; } } int main(){ int n , m; scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0bdaf6622f043322b50387e8653b1738/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23385a6653e41200baa7dab132015ff0/" rel="bookmark">
			前端复习笔记--自用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前端学习文章目录 【前端基础篇】第一篇HTML
【前端基础篇】第二篇CSS
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b56cc88bbcc22d1eb073e97f0f5f2c2/" rel="bookmark">
			【前端基础篇】CSS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CSS样式 1、CSS语法格式
2、样式style 的三种创建方式：内部、外部、内联
外部样式两种情况：
link和@input区别：
差别1：本质的差别：link属于XHTML标签，而@import完全是CSS提供的一种方式。
差别2：加载顺序的差别：当一个页面被加载的时候（就是被浏览者浏览的时候），link引用的
CSS会同时被加载，而@import引用的CSS会等到页面全部被下载完再被加载。所以有时候浏览@import加载CSS的页面时开始会没有样式（就是闪烁），网速慢的时候还挺明显。
差别3：兼容性的差别：@import是CSS2.1提出的，所以老的浏览器不支持，@import只有在IE5以上的才能识别，而link标签无此问题。
差别4：使用dom(document o bject model文档对象模型 )控制样式时的差别：当使用javascript控制dom去改变样式的时候，只能使用link标签，因为@import不是dom可以控制的。
3、选择器
元素选择符、class选择符、id选择符、通配符、群组选择符器、包含选择器、伪类选择器(根据状态来选择)
4、选择器的权重
!important 可以使某个样式有最高的优先级
优先级：!important &gt; 行内样式 &gt; ID选择器 &gt; 类选择器 &gt; 标签 &gt; 通配符 &gt; 继承 &gt; 浏览器默认属性。
原因：首先加载标签选择器,再加载类选择器，然后加载ID选择器，最后加载行内样式后加载会覆盖先加载的同名样式
5、命名规则：
CSS样式属性 0、字体属性
字体大小：{font-size:value} 或者使用关键字
字体字体：{font-family:字体1,字体2,...}
文本加粗：{font-weight:bolder/bold/normal/100-900;}
文字倾斜：{font-style:italic/oblique/normal;}
font属性简写：顺序为：font-style font-weight font-size/line-height font-family font-size/line-height只能是一个值，不能分开写
1、文本属性
文本颜色：{color: 三种 ;}
文字行高：{line-height:normal/value;}
水平对齐：{text-align:left/right/center/justify;}
垂直对齐：{vertical-align:top/middle/buttom} 看用于图片和文字的对齐
文本修饰：{text-decoration:none/underline/overline/line-through;}
首行缩进：{text-indent:value只对第一行起作用，可是负值;}
字间距：{letter-spacing:value;}
text-transform控制文本的大小写:capitalize每个单词大写字母开头；uppercase 仅有大写字母；lowercase 仅有小写字母；none 默认
font-variant: normal 默认值 标准字体；small-caps 显示小型大写字母的字体
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b56cc88bbcc22d1eb073e97f0f5f2c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e61b4f2dc9b20a430ab9ab5fdadb6d72/" rel="bookmark">
			Vue 组件中的 data 为什么是函数？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vue 组件中的 data 为什么是函数？ 如何改变文本的样式 一、总结 1.vue中组件是用来复用的，为了防止data复用，将其定义为函数。
2.vue组件中的data数据都应该是相互隔离，互不影响的，组件每复用一次，data数据就应该被复制一次，之后，当某一处复用的地方组件内data数据被改变时，其他复用地方组件的data数据不受影响，就需要通过data函数返回一个对象作为组件的状态。
3.当我们将组件中的data写成一个函数，数据以函数返回值形式定义，这样每复用一次组件，就会返回一份新的data，拥有自己的作用域，类似于给每个组件实例创建一个私有的数据空间，让各个组件实例维护各自的数据。
4.当我们组件的date单纯的写成对象形式，这些实例用的是同一个构造函数，由于JavaScript的特性所导致，所有的组件实例共用了一个data，就会造成一个变了全都会变的结果。
二、代码分析： vue每次会通过组件创建出一个构造函数，每个实例都是通过这个构造函数new出来的
假如data是一个对象，将这个对象放到这个放到原型上去
function VueComponent(){}
VueComponent.prototype. o p t i o n s = d a t a : n a m e : ′ t h r e e ′ l e t v c 1 = n e w V u e C o m p o n e n t ( ) ; v c 1. options = { data:{name:'three'} } let vc1 = new VueComponent(); vc1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e61b4f2dc9b20a430ab9ab5fdadb6d72/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5479ed7bdb10c5d3eeb33c852b170e8c/" rel="bookmark">
			[ERP]IPQC是什么意思?IPQC工作职责和IPQC工作流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IPQC是什么意思?IPQC工作职责和IPQC工作流程
IPQC，in process quality contrl, 过程检验, 简单的说：工作内容包括：首件检查、各类变更文件的跟踪。4M1E的巡查。发现异常的提出、跟踪与验证。
IPQC工作意义：
防止出现批量不合格品，避免不合格品流入下道工序去继续进行加工。
IPQC工作内容：
1.首件检查（各类变更文件的跟踪）
2.4M1E的巡查，
3.发现异常（反馈，要求改善，追踪，验证 ）。
具体工作内容：
1、IPQC人员应于在每天下班之前了解次日所负责制造部门的生产计划状况，以提前准备检验相关资料。 2、制造部门生产某一产品前，IPQC人员应事先了解查找相关资料： （A）生产指令单； （B）检验用技术图纸； （C）产品用料明细表； （D）检验范围及检验标准； （E）工艺流程、作业指导书（作业标准）； （F）品质异常履历记录； （G）其他相关文件； ３、制造部门开始生产时，ＩＰＱＣ人员应协助制造部门主要协助如下： （A）工艺流程查核；
（B）相关物料、工装夹具查核；
（C）使用计量仪器点检；
（D）作业人员品质标准指导，辅导；
（E）首检产品检验记录；
４、ＩＰＱＣ根据图纸、样本所检结果合格时，方可正常生产，并及时填写产品首检检验报告与留首检合格产品（生产判定第一个合格品）作为此批生产样板。 5、制造部门生产正常后，IPQC人员依规定时间按4M1E进行巡检工作。 6、IPQC巡检发现不良品应及时分析原因并追溯不良流程品，及时对作业人员之不规范的动作序以及时纠正。 7、IPQC对检验站之不良需及时反馈并协同制造部门管理人员（拉长，主管）或技术人员（PE）进行处理、分析原因并做出异常之问题的预防对策与预防措施。 8、当发现重大的品质异常，IPQC不能处理时，应开具《制程异常通知单》经生产主管确认后，通知相关部门相部门处理。 9、重大品质异常未能及时得到处理，IPQC有权利要求制造部门停机或停线处理，制止继续制造不良。 10、IPQC应及时将巡检状况记录到《制程巡检记录表》每日上交给部门主管、经理，以方便及时掌握生产品质状况。 制程不良统计区分：
依不良品产生之来源区分如下:
(1) 作业不良 A: 作业失误 （人，法） B: 管理不良 （环） C: 设备问题 （机） D: 其它原因所致不良 (2) 物料不良 （物） A: 采购物料中原有存在的不良 B:前工程之加工不良混入（半成品物料的不良） C: 其它明显为上工程或采购物料所致不良 (3) 设计不良 （环） 因设计失误导致作业中出现的不良 IPQC工作职责：IPQC检验流程图
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e2889aa8f3f30cc226183007a5a419c/" rel="bookmark">
			JS中的执行机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、同步
同步任务都在主线程上执行，形成一个执行栈
二、异步
JS的异步是通过回调函数实现的，一般而言，异步任务有三种类型
（1）普通事件，如click、resize
（2）资源加载，如load、error
（3）定时器，包括setInterval、setTimeout等
异步任务相关添加到任务队列中
三、JS的执行机制
1、先执行栈中的同步任务
2、异步任务放入任务队列中
3、一旦执行栈中的所有同步任务执行完毕，系统就会按次序读取任务队列中的异步任务，于是被读取的异步任务结束等待状态，进入执行栈，开始执行。
例如
console.log(1) setTimeout(function(){ console.log(2) },0) console.log(3) 输出结果
因为2为异步任务，会先执行同步任务
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/741d5e51d353ad3f3a811010070b1223/" rel="bookmark">
			HTML怎么设置input框大小
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 HTML设置input框大小的方法 HTML input元素定义的输入框的大小，可以通过CSS的width属性和height属性来分别设置input框的宽度和高度，如果只是设置这些，input输入框中的字体并不会跟着改变大小，如果还需要设置input输入框内字体的大小，则需要另外进行设置。下面的实例来先介绍一下改变input框大小的设置方法。语法如下：
input{width:value1;height:value2}
提示：input为元素选择器，也可以通过其它的选择器，比如id选择器、类选择器等等。
HTML设置input框大小的实例代码，及在线编辑器 &lt;input type='text'&gt;&lt;br&gt;&lt;br&gt; &lt;input type='text' id='inp'&gt; &lt;style&gt; #inp{width:100%;height:50px;} &lt;/style&gt; 原文及在线编辑器： HTML怎么设置input框大小，实例在线 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26fe166ab7420adad24639efa7185e96/" rel="bookmark">
			解决Error:(3, 38) java: 程序包org.springframework.stereotype不存在的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		导入springMVC项目后，重新配置本地maven仓库以及tomcat服务器，重新刷新maven工具后pom.xml文件并无任何爆红，点击运行之后出现如下报错：
检查本地仓库，配置里的org.pringframework依赖存在
问题原因：导入的spring项目依然使用的是原本的maven仓库，所以重新配置仓库后启动报错
解决方法：重新构建pom.xml文件
点击File—&gt;setting—&gt;BED—&gt;maven下面的runner
将Delegate IDE build/run actions to Maven前面的√打上
再次运行时IDEA会重新自动编译所有模块
运行成功！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc7b40425179d38750dfcd30b1a7d4be/" rel="bookmark">
			安装双系统之Ubuntu
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、下载Ubuntu系统 下载操作系统镜像 首先到Ubuntu中国官网下载最新版本的Ubuntu18.04桌面版
下载传送门：点击这里
选择64位的桌面镜像，其他版本的下载方法类似，可以直接搜索，然后进入下载。
二、制作U盘启动盘 这里推荐使用 Rufus 软件 制作U盘启动盘，这是个免费开源软件，界面简单，没有很多花里胡哨的选项来吓退初学者。假如你已经下载好系统了，那就插上U盘，打开 Rufus ，选择要烧录的U盘以及系统镜像文件，其他地方保持默认就好，就像下面这样
然后点击开始，选择 以ISO 镜像模式写入(推荐) ，这也是系统默认选项。然后静待制作完成就好
三、为Ubuntu的安装腾出磁盘空间 这一步系统磁盘分配，大家多参考几篇文章再做。 如果磁盘删错了，可以参考小弟这篇文章进行恢复： https://blog.csdn.net/caip12999203000/article/details/129775063?spm=1001.2014.3001.5501 （这个操作也可以用来为Windows进行磁盘分区）首先右键点击我的电脑，选择 磁盘管理，界面如下。
四、Ubuntu的启动安装 Windows上的操作已经完成，下面就可以插上刚制作的U盘进行Ubuntu的安装啦。首先吧U盘插电脑上，重启电脑，在启动界面狂按 F2 进入BIOS 的设置界面（我的华硕电脑是F2，其他牌子的可以自行百度）
1、在 Boot Menu 选项中选择对应的U盘系统，我的是 UEFI:**** 那个。
2、然后就会进入系统选择界面，使用方向键选择 ubuntu 后回车就进入了 Ubuntu 的安装引导界面。在侧边栏中选择系统语言，English、Chinese都可，建议英文（进入后再汉化），然后点击 Install Ubuntu 进入安装。
3、选择键盘布局，跟前面一样，按个人喜好选择
4、选择安装方式，选择正常安装就行，会默认安装火狐浏览器等软件。或者选择最小安装的话可以在安装完成后自行安装需要的软件，两种方式影响不大。下面的安装第三方软件选项也可以选上，也可以不选，后面再根据需要手动安装。我这里就只选择了正常安装，然后点击继续。
5、安装类型选择 选择 Something else，即手动及进行磁盘分区。
6、磁盘分区与安装 这里我选择最简单的分区方案，一共四个分区（700G）：
/boot : 1G 主分区。系统的boot启动引导项安装位置
/ : 300G 主分区。根目录，所有目录的根节点，其下包含很多子目录，如/usr /tmp等
/home : 400G 逻辑分区。一般放置自己的数据
（1）首先找到 free space 空间，如下，选中该空间，点击左下角的加号+，进行内存分配
/boot 的分配如下：
/home 与 / 的分配方式同样，注意选择主内存还是逻辑内存。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fc7b40425179d38750dfcd30b1a7d4be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc4f2252acaa6605780b607b3d582109/" rel="bookmark">
			Linux安装MySQL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.查看系统中是否已安装MySQL
2.安装配置MySQL
异常1：密钥配置
解决方案1：
解决方案2：
异常2：启动报错
登录mysql
查看初始密码
修改初始密码
授权远程登陆
开启防火墙
测试连接
1.查看系统中是否已安装MySQL 要查看当前系统是否装有旧版的 MySQL。如果有，最好先卸载旧版的 MySQL，否则可能会产生冲突。输入命令：
[root@localhost local]# rpm -qa|grep -i mysql 显示如下：
[root@localhost local]# rpm -qa|grep -i mysql mysql-libs-8.0.31-1.el7.x86_64 停止 MySQL 服务，卸载 mysql-libs-8.0.31-1.el7.x86_64，命令如下：
[root@localhost local]# service mysql stop [root@localhost local]# rpm -e --nodeps mysql-libs-8.0.31-1.el7.x86_64 查找之前老版本 MySQL 的目录，并且删除老版本的文件和库。
[root@localhost local]# find / -name mysql 显示 MySQL 目录后，可以使用以下命令删除目录。
rm -rf 目录名 再次查找当前系统中是否安装了 MySQL。
[root@localhost local]# rpm -qa|grep -i mysql 如果没有显示结果，说明已经卸载干净，接下来直接安装 MySQL 即可。 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fc4f2252acaa6605780b607b3d582109/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c44dfc6e73f4ed3d81cfe07f754b396/" rel="bookmark">
			如何让虚拟机里的Ubuntu通过连接手机USB数据线上网
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一 前言
二 Windows联网方法
三 Ubuntu联网方法
一 前言 最近遇到了这样一个问题，有一台台式机，地插网口无法访问外网，周边也没有无线路由器，要访问外网，该如何做？进一步的，这台台式机上有一个虚拟机，安装了Ubuntu操作系统，该如何让Ubuntu也访问外网？
博主最近就遇到了这样一个问题。下面我们就看看如何做的。再进一步展开之前，先说明博主的环境。这非常重要，如果你的环境不一样，下面介绍的方法可能就行不通。
1 主机操作系统：Windows10
2 虚拟机：Vmware16
4 虚拟机操作系统：Ubuntu18.04
5 手机：华为系手机，有如下【USB共享网络】功能：
二 Windows联网方法 操作方法：
1 用USB数据线连接手机和电脑。注意，这里要支持数据传输的线，不能是只支持充电功能的线。手机自带的数据线都是支持数据传输的。
2 点击上图中的USB共享网络。注意，可能需要等一小会，不会像其他开关按钮，点了立马有反应。
3 按钮正常选中后，就可以在Windows里面打开浏览器，尝试上网了。
4 查看系统设置里面的网络与共享中心，可以看到多出来一个适配器，如下图：
5 可以进一步查看网卡IP地址等信息。我们会发现，这个网卡被描述为Remote NDIS Compatible Device。
可以看到，本人手机分配的网段为42网段。网关为192.168.42.129
6 关于这个网卡消耗的流量，可以通过系统设置里的网络设置界面查看，如下图：
主机上网的问题解决了，下面看看如何让虚拟机里的Ubuntu上网。
三 Ubuntu联网方法 1 打开虚拟机软件设置，如下图：
选择右边的配置适配器按钮，弹出如下界面：
选择上面的第一项，也就是我们之前看到的虚拟网卡的信息。
2 进入Ubuntu里的网络设置，选择自动获取IP地址，如下图：
执行Apply之后，可以看到网卡的配置信息，如下图：
之后就可以测试联网，如下图：
可以看到，已经ping通网络，联网成功。
下一步，就可以执行apt update更新软件包，安装需要的软件包了。
使用USB的方式，不如WLAN热点的两点是：1流量查看不方便，2不能进行流量限制。但毕竟能联网了，如果担心流量消耗，可以是不是查看流量数据，并及时断开连接。
好了，通过USB连接手机上网的方式就介绍到这里。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7c1ca67c80844137dede1a83fecf34c/" rel="bookmark">
			springboot整合Cannal
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 canal主要用途是对MySQL数据库增量日志进行解析，提供增量数据的订阅和消费，简单说就是可以对MySQL的增量数据进行实时同步，支持同步到MySQL、Elasticsearch、HBase等数据存储中去。
canal会模拟MySQL主库和从库的交互协议，从而伪装成MySQL的从库，然后向MySQL主库发送dump协议，MySQL主库收到dump请求会向canal推送binlog，canal通过解析binlog将数据同步到其他存储中去。
准备工作 组件下载 我们可以根据自己的需要下载canal的各个组件
canal-server（canal-deploy）：可以直接监听MySQL的binlog，把自己伪装成MySQL的从库，只负责接收数据，并不做处理。 canal-adapter：相当于canal的客户端，会从canal-server中获取数据，然后对数据进行同步，可以同步到MySQL、Elasticsearch和HBase等存储中去。canal-admin：为canal提供整体配置管理、节点运维等面向运维的功能，提供相对友好的WebUI操作界面，方便更多用户快速和安全的操作。 因为我们这篇文章只需要一个canal-service，所以看看它的建立方式，根据自己的需要去建立即可：
直接下载启动文档通过docker启动文档直接传递给mq文档 修改mysql配置 由于canal是通过订阅MySQL的binlog来实现数据同步的，所以我们需要开启MySQL的binlog写入功能，并设置binlog-format为ROW模式，我的配置文件为/mydata/mysql/conf/my.cnf，改为如下内容即可；
[mysqld] ## 设置server_id，同一局域网中需要唯一 server_id=101 ## 指定不需要同步的数据库名称 binlog-ignore-db=mysql ## 开启二进制日志功能 log-bin=mall-mysql-bin ## 设置二进制日志使用内存大小（事务） binlog_cache_size=1M ## 设置使用的二进制日志格式（mixed,statement,row） binlog_format=row ## 二进制日志过期清理时间。默认值为0，表示不自动清理。 expire_logs_days=7 ## 跳过主从复制中遇到的所有错误或指定类型的错误，避免slave端复制中断。 ## 如：1062错误是指一些主键重复，1032错误是因为主从数据库数据不一致 slave_skip_errors=1062 注意：针对阿里云 RDS for MySQL , 默认打开了 binlog , 并且账号默认具有 binlog dump 权限 , 不需要任何权限或者 binlog 设置，可以直接跳过这一步
配置完成后需要重新启动MySQL，重启成功后通过如下命令查看binlog是否启用；
show variables like '%log_bin%' +---------------------------------+-------------------------------------+ | Variable_name | Value | +---------------------------------+-------------------------------------+ | log_bin | ON | | log_bin_basename | /var/lib/mysql/mall-mysql-bin | | log_bin_index | /var/lib/mysql/mall-mysql-bin.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d7c1ca67c80844137dede1a83fecf34c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97649207adecc3d8cbf836468e920945/" rel="bookmark">
			Linux-GCC介绍&#43;入门级Makefile使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 （1）我们都知道，在Linux中编译.c文件需要使用 gcc -o .c文件的指令来将C文件变成可执行文件。但是我们有没有发现，如果我们需要编译大一点的工程，后面需要加上的.c文件是不是太多了？感觉非常的麻烦。 （2）那有没有什么方便的方法，帮助我们编译大型文件呢？有，也就是本章需要介绍的Makefile工具。需要注意的是，Makefile工具如果真的想全部学，内容很多想学的看 Makefile详细英文文档或 GNU Make 使用手册（于凤昌中译版）。 本文仅用于新手小白学习。 （3）本文将 先简单介绍GCC的编译流程，然后再讲解Makefile入门级使用。 GCC编译流程 单个.C文件变成可执行文件 简单介绍 （1）首先我们需要知道， 我们写的.c代码是无法直接使用的。如果是搞单片机的同学们都知道，一个.c文件需要先再keil这种编译器中先编译，然后 将生成的hex文件烧录到单片机中。（stlink那个虽然只需要我们点一下烧录就可以，但是实际上也是这么做的） （2）那么这个hex文件是什么东西呢？我们打开hex文件发现，里面都是16进制的数字，而这些代码才是机器真正能够识别的代码。 （3）那么从.c文件到这些机器可执行的过程具体是什么呢？四个步骤： 预处理--&gt; 编译 --&gt; 汇编 --&gt; 链接。 （4）但是在 日常生活中通常使用“编译”统称这 4 个步骤，不是特指这 4 个步骤中的某一个。 有时候也会有人将前三步称为编译，讲法不一，只要知道.c文件到机器可执行文件有四个步骤即可。 预处理 （1）预处理：在C/C++源文件中， 以“ #”开头的命令被称为预处理命令。预处理需要将 &lt;1&gt; 包含的文件放入原文件中。比如一个main.c中第一行写了#include&lt;stdio.h&gt;，那么预处理阶段就需要将stdio.h文件包含到main.c中，上面一大段就是stdio.h文件的内容。 &lt;2&gt; 宏定义展开。比如我们此刻宏定义了printf为CSDN，所以在.i文件中CSDN部分变成了printf。 &lt;3&gt; 根据条件编译命令选择要使用的代码，最后将这些东西输出到一个“ .i”文件中等待进一步处理。 （2）格式： gcc -E .c文件 -o .i文件 （3）需要注意， 如果是直接 gcc -o 可执行文件名 .c文件 ，那么是直接完成了预处理，编译，汇编，和链接的四个步骤。而如果是加上-E，就是只执行预处理。 编译 （1）编译就是把 C/C++代码(比如上述的“.i”文件)“ 翻译” 成汇编代码，所用到的工具为 cc1。（名字为CC1，x86和arm板都有自己的CC1命令）。 （2）格式： gcc -S .c或者.i文件 -o .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/97649207adecc3d8cbf836468e920945/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6bc3118bcc86c8f58202ab372f8f75ab/" rel="bookmark">
			网络安全面试题-SQL注入问题总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、知识储备类
1.SQL与NoSQL的区别？
SQL：关系型数据库
NoSQL：非关系型数据库
存储方式：SQL具有特定的结构表，NoSQL存储方式灵活 性能：NoSQL较优于SQL 数据类型：SQL适用结构化数据，如账号密码；NoSQL适用非结构化数据，如文章、评论 2.常见的关系型数据库？
mysql、sqlserver、oracle、access、sqlite、postgreSQL 3.常见的数据库端口？
关系型：
mysql:3306 sqlserver:1433 orecal:1521 PostgreSQL:5432 db2:50000 非关系型：
MongoDB:27017 redis:6379 memcached:11211 4.简述数据库的存储引擎
数据库存储引擎是数据库底层软件组织，数据库管理系统（DBMS）使用数据引擎进行创建、查询、更新和删除数据。不同的存储引擎提供不同的存储机制、索引技巧、锁定水平等功能，使用不同的存储引擎，还可以获得特定的功能。
InnoDB：主流的存储引擎，mysql默认存储引擎 MyISAM：查询、插入速度快，不支持事务 MEMORY：hash索引、BTREE索引 5.SQL注入有哪几种注入类型？
从注入参数类型分：数字型注入、字符型注入、搜索型注入 从注入方法分：基于报错、基于布尔盲注、基于时间盲注、联合查询、堆叠注入、内联查询注入、宽字节注入 从提交方式分：GET注入、POST注入、COOKIE注入、HTTP头注入 6.SQL注入的危害及防御？
危害：
数据库泄露 数据库被破坏 网站崩溃 服务器被植入木马 防御：
代码层面对查询参数进行转义 预编译与参数绑定 利用WAF防御 7.如果存在SQL注入怎么判断不同的数据库？
根据报错信息判断 根据执行函数返回的结果判断，如len()和lenth()，version()和@@version等 根据注释符判断 8.mysql的网站注入，5.0以上和5.0以下有什么区别？
从sql注入的角度来说，mysql5.0以下版本没有information_schema这个系统库，无法列出表名列名，只能暴力跑 9.Mysql一个@和两个@什么区别
一个@是用户自定义变量 两个@是系统变量，如@@version、@@user 10.MYSQL注入/绕过常用的函数
注入常用函数：
database() 返回当前数据库名 user() 返回当前数据库用户名 updatexml() 更新xml文档，常用于报错注入 mid() 从指定字段中提取出字段的内容 limit() 返回结果中的前几条数据或者中间的数据 concat() 返回参数产生的字符串 group_concat() 分组拼接函数 count() 返回指定参数的数目 rand() 参数0~1个随机数 flood() 向下取整 substr() 截取字符串 ascii() 返回字符串的ascii码 left() 返回字符串最左边指定个数的字符 ord() 返回字符的ascii码 length() 返回字符串长度 sleep() 延时函数 等价函数绕过，反之亦可：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6bc3118bcc86c8f58202ab372f8f75ab/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/161/">«</a>
	<span class="pagination__item pagination__item--current">162/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/163/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>