<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8d9eff5d4e54b26c0d755c67d1f4c52/" rel="bookmark">
			ubuntu 修改虚拟环境的安装目录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.查看conda 信息
conda info
当envs directories 不是你要安装的虚拟环境目录时，执行以下操作
2.修改condarc 文件
修改成你要安装的目录
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fdff9d4897f5daf04344149a17939b45/" rel="bookmark">
			[C语言编程练习][18]输入一个学生的学号，姓名，性别，用结构体存储，通过scanf读取后，然后再通过printf打印输出.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Input
学号，姓名，性别，例如输入 101 xiongda m
Output
输出和输入的内容一致，如果输入的是101 xiongda m，那么输出也是101 xiongda m
#define _CRT_SECURE_NO_WARNINGS #include &lt;stdio.h&gt; //输入一个学生的学号，姓名，性别，用结构体存储，通过scanf读取后，然后再通过printf打印输出 struct student { int num; char name[20]; char sex; };	//定义一个结构体类型student int main() { struct student s; scanf("%d%s %c", &amp;s.num, &amp;s.name, &amp;s.sex); printf("%d %s %c\n",s.num,s.name,s.sex); return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df8b66f7d528c13597f60ce4d3e58e3d/" rel="bookmark">
			python题库--简单
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		案例1：输出1-100的数字 # 方法1： n=1 # 定义变量保存起始的数字 while n&lt;=100: print(n) n+=1 # 方法2： for num in range(1,101): print(num) # 方法3： n=100 # 定义变量保存起始的数字 while n&gt;=0: print(n) n-=1 案例2：编程实现，让用户输入一个整数n，打印输出n以内的全部大于0的偶数（不包含n） # 方法1： # 让用户输入一个数字 userInput=int(input("请输入一个整数")) # 通过range直接生成偶数 for num in range(2,userInput+1,2): print(num) # 方法2： n = int(input("请输入整数：")) num = 1 while num&lt;n: if num%2 == 0: print(num) num += 1 # 方法3： # 让用户输入一个数字 num=int(input("请输入一个整数")) # 判断是否满足循环条件，如果满足，则进入循环 while num&gt;0: if num%2 == 0: # 打印数字 print(num) # 修改num的值，让其自减1【目的是为了将来能结束循环】 num -= 1 案例3：编程实现，实现输出 1,2,3,4,5, 7,8,9, 11,12
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df8b66f7d528c13597f60ce4d3e58e3d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60a0ac71b2b8c5aac2338af0300ce565/" rel="bookmark">
			Spark&#43;Flink&#43;Iceberg打造湖仓一体架构实践探索
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据湖-大数据生态杀青 数据仓库的痛点 只能存储结构化数据，无法采集存储非结构化数据无法存储原始数据，所有的数据须经过ETL清洗过程离线数仓的数据表牵一发而动全身，数据调整工程量大实时数仓存储空间有限，无法采集和存储海量实时数据回溯效率低下，实时数据和离线数据计算接口难以统一Kafka 做实时数仓，以及日志传输。Kafka 本身存储成本很高，且数据保留时间有时效性，一旦消费积压，数据达到过期时间后，就会造成数据丢失且没有消费到将实时要求不高的业务数据入湖、比如说能接受 1-10 分钟的延迟。因为 Iceberg 0.11 也支持 SQL 实时读取，而且还能保存历史数据。这样既可以减轻线上 Kafka 的压力，还能确保数据不丢失的同时也能实时读取 数据湖三剑客对比 Hudi Hudi：Hadoop Upserts Deletes and Incrementals（原为 Hadoop Upserts anD Incrementals），强调了其主要支持 Upserts、Deletes 和 Incremental 数据处理，其主要提供的写入工具是 Spark HudiDataSource API 和自身提供的 HoodieDeltaStreamer在查询方面，Hudi 支持 Hive、Spark、Presto。在性能方面，Hudi 设计了 HoodieKey ，一个类似于主键的东西。对于查询性能，一般需求是根据查询谓词生成过滤条件下推至 datasource。Hudi 这方面没怎么做工作，其性能完全基于引擎自带的谓词下推和 partition prune 功能。 Delta Delta定位是流批一体的 Data Lake 存储层，支持 update/delete/merge。不强调主键，因此其 update/delete/merge 的实现均是基于 spark 的 join 功能。在数据写入方面，Delta 与 Spark 是强绑定的，这一点 Hudi 是不同的：Hudi 的数据写入不绑定 Spark（可以用 Spark，也可以使用 Hudi 自己的写入工具写入）在查询方面，开源 Delta 目前支持 Spark 与 Presto，但是，Spark 是不可或缺的，因为 delta log 的处理需要用到 Spark。这意味着如果要用 Presto 查询 Delta，查询时还要跑一个 Spark 作业 Iceberg Iceberg一个通用化设计的Table Format，高性能的分析与可靠的数据管理，Iceberg 没有类似的 HoodieKey 设计，其不强调主键。上文已经说到，没有主键，做 update/delete/merge 等操作就要通过 Join 来实现，而 Join 需要有一个 类似 SQL 的执行引擎。Iceberg 在查询性能方面做了大量的工作。值得一提的是它的 hidden partition 功能。Hidden partition 意思是说，对于用户输入的数据，用户可以选取其中某些列做适当的变换（Transform）形成一个新的列作为 partition 列。这个 partition 列仅仅为了将数据进行分区，并不直接体现在表的 schema 中。 总结 Delta、Hudi、Iceberg三个开源项目中，Delta和Hudi跟Spark的代码深度绑定，尤其是写入路径。这两个项目设计之初，都基本上把Spark作为他们的默认计算引擎了。而Apache Iceberg的方向非常坚定，宗旨就是要做一个通用化设计的Table Format。它完美的解耦了计算引擎和底下的存储系统，便于多样化计算引擎和文件格式，很好的完成了数据湖架构中的Table Format这一层的实现，因此也更容易 成为Table Format层的开源事实标准Apache Iceberg也在朝着流批一体的数据存储层发展，manifest和snapshot的设计，有效地隔离不同transaction的变更 ，非常方便批处理和增量计算。并且，Apache Flink已经是一个流批一体的计算引擎，二都可以完美匹配，合力打造流批一体的数据湖架构。 Iceberg术语 数据文件 ( data files )
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60a0ac71b2b8c5aac2338af0300ce565/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e0151290fb806821bb71b2b0faa8e55/" rel="bookmark">
			SSH命令批量操作服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		平时远程连接linux服务器时，通常使用一些类似Xshell的工具进行连接。如果需要批量执行命令时，就需要一台一台的执行命令进行登陆，然后执行命令，如果服务器很多的情况下，就比较费时费力。
为了应对上述问题，可以使用SSH管理。ssh可以批量登陆服务器，批量执行命令。
1. ssh登陆 ssh ipXXX.XXX.XXX.XXX
输入yes后，输入对应的130服务器的密码，即可完成登陆。
注意，在首次进ssh远程登录时，会提醒需要输入yes，之后不会提醒。
如果在第一次登录时，也不想进行“yes”的输入，可以修改对应的配置文件，跳过验证。
vim /etc/ssh/ssh_config #修改以下内容 StrictHostKeyChecking no 去掉注释并，修改值为 no
清空之前的记录
vim .ssh/known_hosts 进行ssh登录，发现不再需要验证。
2. 密钥 ssh远程连接服务器时，依旧需要人工输入服务器密码，才能进行登录，在服务器数量较多的情况下，依旧费时费力。
采用密钥的方式进行登录。
2.1 生成密钥 ssh-keygen -t rsa 之后一直回车即可。
生成公私钥，在.ssh文件夹下。
id_rsa 私钥 可以理解为是一把钥匙
id_rsa.pub 公钥 可以理解为是一把金锁
2.2 发送公钥到目标服务器 执行命令
ssh-copy-id 192.168.116.130 输入服务器密码后，看到如下提示表示成功
再次使用ssh连接登陆，
发现可以直接进行登录，并不用进行任何交互式的输入。
2.3 SSH公钥批量下发 下发ssh公钥时，依旧需要输入服务器密码。在服务器较多时，还是会花费大量的精力。
使用sshpass自动输入密码，
yum install sshpass -y sshpass -p '123456' ssh-copy-id 192.168.116.130 编写批量下发公钥的shell脚本
vim deploy_rsa.sh #!/bin/bash IFSBAK=$IFS IFS=$'\n' for line in $(cat /root/deployhost);do myhostname=$(echo "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e0151290fb806821bb71b2b0faa8e55/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5804f83992ed10d71445b4655e80e12/" rel="bookmark">
			as报错：Gradle 7.2 requires Java 8 or later to run. Your build is currently configured to use Java 7
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		android studio创建项目时报错“Gradle 7.2 requires Java 8 or later to run. Your build is currently configured to use Java 7”，意思是说我现在使用的是Java7，需要Java8以上的版本
解决办法：
1.按住ctrl+shift+alt+s调出项目结构，在sdk location里找到gradle settings
2.在gradle jdk选择1.8版本（前提是电脑已经安装了java8，并配置了java8的环境变量）
3.最后点击ok重新build即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8d662e9d1abbabf30af8756e82628f9/" rel="bookmark">
			element table的selection根据条件禁用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在日常开发中表格中的其中一行因为状态不符合选择标准，要禁止选用它，只需要在table的type="selection"列新增一个selectable方法
&lt;el-table-column type="selection" width="55" :selectable="handleDisable" &gt; &lt;/el-table-column&gt; handleDisable(row,index){ if (row.state == 'xxx') { return false }else{ return true } }, 这样就是每一行的状态等于xxx的时候禁止选中
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e988189eb45acf0329fd3e3de9412309/" rel="bookmark">
			Linux 以root用户登录无法启动VSCode | 九七的Linux
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux 以root用户登录无法启动VSCode 环境 Ubuntu18.04
VSCode
复现 以root用户登录Ubuntu后单机VSCode图标打开VSCode
BUG 无法打开VSCode
原因 VSCode默认不允许以root用户打开，主要为防止root权限过高导致破坏操作等
解决 修改启动VSCode的配置文件，使其允许以root用户打开VSCode
操作流程 ①在home目录下使用以下命令打开“.bashrc”文件
sudo gedit .bashrc ②在此文件后面加入如下代码
alias code='/usr/share/code/code . --no-sandbox --unity-launch' ③使新配置文件生效
sudo source .bashrc 来自：九七的Linux
作者原创文章，转载请注明出处，仅供学习交流，请勿用于商业、违法用途！违者追究法律责任！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f14cd1fa857091c1f577b2db7491b0b/" rel="bookmark">
			基于FPGA的频率测量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		正弦波由matlb产生；
clc; clear all; close all; %Sin400hz.m程序清单 %设置系统参数 fi=400;	%输入信号的频率 Fs=8000;	%采样频率 L=10024;	%数据长度 N=10;	%量化位数 x=0:1/(100*fi):2/fi; figure('name','sin(2*pi*fi*x)'); plot(x,sin(2*pi*fi*x)); title('sin(2*pi*fi*x)'); xlabel('x'); ylabel('sin'); %产生400hz正弦信号 t=0:1/Fs:(1/Fs)*(L-1);	%产生采样频率的时间序列 si=sin(2*pi*fi*t); %归一化处理 f_s=si/max(abs(si)); %10bit量化 Q_s=round(f_s*(2^(N-1)-1)); %将生成的输入正弦信号数据，写入外部文本文件(din.txt)中 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %新建文本文件前，必须建好文件存放的目录文件夹，否则出现提示信息: %??? Error using ==&gt; fprintf %Invalid file identifier fid=fopen('D:\a_FPGA\frequency_measure\sim\din.txt','w'); for k=1:length(Q_s) B_s=dec2bin(Q_s(k)+(Q_s(k)&lt;0)*2^N,N); for j=1:N if B_s(j)=='1' tb=1; else tb=0; end fprintf(fid,'%d',tb); end fprintf(fid,'\r\n'); end fprintf(fid,';'); fclose(fid); Verilog源代码：
module frequency_measure( //input clk,//8000Hz; rst_n, //0 valid; data_in, f ); input clk,rst_n; input [9:0] data_in;//10bit digital data; output[9:0] f;	//frequency,unit is Hz; //reg define reg [6:0] cnt0,cnt1;//the count of input signal's period needs reg [1:0] transfer; //main code; always @(posedge clk or negedge rst_n) if(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f14cd1fa857091c1f577b2db7491b0b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d41773792bad2fe0f8b303e748c221ca/" rel="bookmark">
			vue实现甘特图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、引入依赖
npm install dhtmlx-gantt@6.3.7 2、组件代码
&lt;template&gt; &lt;div class="app-container"&gt; &lt;div ref="gantt" class="left-container" /&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import gantt from 'dhtmlx-gantt' // 引入模块 //import 'dhtmlx-gantt/codebase/dhtmlxgantt.css' import 'dhtmlx-gantt/codebase/skins/dhtmlxgantt_terrace.css' //皮肤 import 'dhtmlx-gantt/codebase/locale/locale_cn' // 本地化 import 'dhtmlx-gantt/codebase/ext/dhtmlxgantt_tooltip.js' //任务条悬浮提示 export default { name: 'Gantt', data() { return { tasks: { data: [], }, } }, mounted() { this.initData() /* * 冒烟：fcca02 单元：fec0dc 回归：62ddd4 阶段：d1a6ff * */ //设置图表区域的日期坐标最大值 var date = new Date(dateString.replace(/-/,"/")) // gantt.config.start_date = new Date("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d41773792bad2fe0f8b303e748c221ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98fd686e397eb92c2bcca2cf67e496de/" rel="bookmark">
			python中的 “ FileNotFoundError: [Errno 2] No such file or directory: .jpg ”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于python中的 “ FileNotFoundError: [Errno 2] No such file or directory: '……'问题 ”
使用python打开文件时出现的问题：发现最终还是路径不正确。
特别注意中文路径，极易出错点。
答案在此
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ae3be6e8f0793f4c4fc1b92b844937f/" rel="bookmark">
			CSS图片旋转/暂停后保持旋转状态(音乐播放常用)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目场景： 通常h5项目中的音乐图标会有旋转动画,我们需要进行暂停播放,展示对应的旋转动画
问题描述 通常的做法,创建旋转动画,暂停的时候移除toggleAudioAni类名,达到暂停的效果,但是会存在一个问题,旋转角度会立马转到0,体验效果非常差
@-webkit-keyframes audio_icon { 0% { -webkit-transform: rotate(0deg); transform: rotate(0deg); } 100% { -webkit-transform: rotate(360deg); transform: rotate(360deg); } } .toggleAudioAni{ -webkit-animation: audio_icon 2s linear infinite; animation: audio_icon 2s linear infinite; } 原因分析： 移除类名后,动画会立即被移除,元素会重置到初始化的角度(0)
解决方案： 解决方案也很简单,我们只需把toggleAudioAni换成下列css代码
.toggleAudioAni {
animation-play-state: paused !important;
-webkit-animation-play-state: paused !important;
}
把之前toggleAudioAni的css代码放到图标的css里即可
示例:
.audio_icon {
background: url(../img/kv/audio.png?v=1.0.0)no-repeat center/100% 100%;
-webkit-animation: audio_icon 2s linear infinite;
animation: audio_icon 2s linear infinite;
}
.toggleAudioAni {
animation-play-state: paused !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ae3be6e8f0793f4c4fc1b92b844937f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12979a4d46837c8036af61aad33499f8/" rel="bookmark">
			Vue生命周期详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、生命周期的概念 生命周期，顾名思义就是一个vue组件从 创建 到 销毁 的过程。 二、钩子函数 Vue中有许多内置函数，是随着组件生命周期阶段自动执行的 。我们可以通过钩子函数来在特定的某个生命周期的阶段执行特定的操作，比如能够在 created 中发起 ajax 请求，从而能够初始化 data 数据渲染页面。
生命周期可以分为四个阶段：
初始化阶段挂载阶段更新阶段销毁阶段 每个阶段又有相对应的方法，分别为：
阶段方法名方法名初始化beforeCreatecreated挂载beforeMountmounted更新beforeUpdateupdated销毁beforeDestroydestroyed 官方文档：Vue 实例 — Vue.js
生命周期实例图
三、分步详解 1. 初始化阶段 new Vue() – Vue实例化(组件也是一个小的Vue实例)Init Events &amp; Lifecycle – 初始化事件和生命周期函数beforeCreate – 生命周期钩子函数被执行Init injections&amp;reactivity – Vue内部添加data和methods等created – 生命周期钩子函数被执行, 实例创建----在此函数能够获取到数据，但获取不到真实DOM元素，可以在此进行网络请求或者注册全局事件接下来是编译模板阶段 –开始分析Has el option? – 是否有el选项 – 检查要挂到哪里 没有就调用 $mount() 方法，有就继续检查 template 选项
2.挂载阶段 进行检查是否有 template 选项，有就编译 template 返回 render 渲染函数，没有则编译 el选项对应标签作为 template (要渲染的模板)。虚拟DOM挂载成真实DOM之前 beforeMount --- 钩子函数被执行，预处理 data 数据，updated 不会被触发Create ---把虚拟DOM和要渲染的数据一并挂载真实DOM挂载完成mounted --- 钩子函数被执行，可以在此函数中获取挂载后真实DOM的数据 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/12979a4d46837c8036af61aad33499f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd3ea7f20f5f9e39bd956f54dbff81d3/" rel="bookmark">
			【HAL库】自带HAL_Delay()函数在中回调函数中居然不能用了？一招教你解决~
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		笔者最近在学习HAL库发现一个BUG，属实把我给整懵圈了，之前用自带的延时函数真的是不亦乐乎，如同自带BUFF加成，这下好了，在中断里直接寄了~
就像如下这段程序，小灯点着就灭不了：
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) { i++; if(i==10) { i=0; HAL_GPIO_WritePin(GPIOB, GPIO_PIN_5, 0); HAL_GPIO_WritePin(GPIOE, GPIO_PIN_5, 0); HAL_Delay(100); HAL_GPIO_WritePin(GPIOB, GPIO_PIN_5, 1); HAL_GPIO_WritePin(GPIOE, GPIO_PIN_5, 1); } } 经过我一通胡乱操作，原来问题是这样的：
__weak void HAL_Delay(uint32_t Delay) { uint32_t tickstart = HAL_GetTick(); uint32_t wait = Delay; /* Add a freq to guarantee minimum wait */ if (wait &lt; HAL_MAX_DELAY) { wait += (uint32_t)(uwTickFreq); } while ((HAL_GetTick() - tickstart) &lt; wait) { } } 我们找到延时函数的所在地就会发现，原来开了滴答定时器的中断，而滴答定时器的中断优先级如果我们不做修改的话是最低的，也就是在其它中断函数中是无法进入滴答定时器的中断的，也就会导致程序一直在whlie中死循环。
我们在STM32CubeMX中配置的NVIC是这样的：
你若不做修改的话，Time base: System tick timer 的优先级就是最低的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd3ea7f20f5f9e39bd956f54dbff81d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec763fa06fbe61807c22b97f0ad14cf6/" rel="bookmark">
			服务器维护-ubuntu没有网络，网卡配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天重装了一台服务器，使用的之前的ubuntu的系统盘镜像做了硬盘拷贝，拷贝完之后测试基本功能没有问题。
但是。。。
问题来了，插上网线发现没有网络，这是什么原因呢？
使用命令：ifconfig之后发现了问题所在：
上图
只有一条信息，本地网络127.0.0.1的。
网卡去哪儿了呢？
于是使用命令：ip link 查询网卡信息：
找到了网卡的信息。
再使用命令：vi /etc/network/interfaces 查看网络配置文件
结果发现之前系统里面的网卡enp1s0和配置文件里面的网卡名称不一致
于是修改名称为enp1s0。
重启主机后网络恢复了。
总结一下：
1、ifcong看网络信息
2、ip link查看网卡信息
3、vi /etc/network/interfeaces 修改网卡名称
系统版本ubuntu16.04，打完收工。
ps：遇到问题从基本路径出发，然后按照硬件软件的顺序排查，切记不要乱查一通。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f568f79631e12eaab21a0c44ce35e186/" rel="bookmark">
			UDS/OBD DTC(诊断故障码)格式解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1 OBD DTC格式结构
2 UDS DTC格式结构
3 Body system groupings车身系统组
4 Chassis system groupings底盘系统组
5 Powertrain system groupings动力总成系统组
6 Network and vehicle integration groupings网络和车辆集成组
7 结尾
前一篇链接：
全网最全诊断梳理《UDS/OBD诊断&amp;诊断描述文件CDD》总目录https://blog.csdn.net/qfmzhu/article/details/120425660
1 OBD DTC格式结构 OBD DTC（ISO 15031）使用两个字节，根据SAE J2012-DA解码。
示例：0x0143的动力系统DTC应显示为P0143。
2 字节 DTC
DTC High Byte
DTC Low Byte
DTC十六进制值：0x0143
0
0
0
0
0
0
0
1
0
1
0
0
0
0
1
1
显示字符
第1个字符
第2个字符
第3个字符
第4个字符
第5个字符
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f568f79631e12eaab21a0c44ce35e186/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36021fbb4e17cca835bddb22cb509816/" rel="bookmark">
			HackBar插件绕许可
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用谷歌浏览器安装HackBar插件，按F12键调出HackBar，发现如下提示：无法使用
Please enter your license to use hackbar. Get license
请输入您的许可证以使用hackbar。 获得许可
解决方法一：使用旧版版本的Hackbar 使用没升级前的hackbar，升级完的是2.2.7版本，我们可以找到一个2.1.3版本，没有收费代码，可以直接加载使用。
1、HackBar2.1.3版本下载地址：
github下载地址：https://github.com/Mr-xn/hackbar2.1.3
百度网盘链接：
链接:https://pan.baidu.com/s/1UDJwtQb2XUnLseg4pqe_Xw 提取码:6666
2、手工安装HackBar2.1.3
首先：打开firefox的附加组件；其次：再点 "从文件安装附加组件"；最后再打开“{4c98c9c7-fc13-4622-b08a-a18923469c1c}.xpi”添加扩展即可！
3、按F12后，查看hackbar破解后的结果。
方法二：Chrome谷歌浏览器下的HackBar破解方法 主要是修改hackbar的源码，以达到破解的目的，具体操作步骤如下：
1、打开Chrome插件列表，查看Hackbar的插件ID:djmoeo…… ，在文件搜索里搜这段字符，我这里用的是Everything。
2、用文本编辑器打开这个文件夹下的 2.2.7\theme\js\hackbar-panel.js 文件。
3、在hackbar-panel.js 的第35、40、43行左右的disable_hackbar(); 注释掉，同时添加一行init(); 然后Ctrl+S保存文件。
4、再打开F12 看看，可以用了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c8f2b774f685d043f9b77cdb5a6383b/" rel="bookmark">
			Altium Designer导入3D模型出现：cannot load 3D model from file警告
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这可把我给烦的呀，一整天都在想办法解决这个问题，前前后后安装了8遍，愣是在最后一次才解决。软件的安装都显示破解OK，但是一到封装的时候，想导入3D模型，就显示Cannot load 3D model from file。当我想失望地做最后一遍挣扎的时候，居然可以了。解决办法非常简单，就是让软件默认安装在C盘，其他安装破解步骤相同。
下面是AD17导入3D模型的过程
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5dfb9e9555a13fd1b113a8157795d6c2/" rel="bookmark">
			视频批量旋转
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.下载FFmpeg工具
地址：https://pan.baidu.com/s/1Hz0icRuzcVDEkl1jXrsx0w?_at_=1647351382988
提取码：mydq（如果需要）
2.配置环境变量
将下载下来的文件解压并复制到C:\Program Files
例如：C:\Program Files\ffmpeg4.2.1_vs2017\bin\win64 路径中不要有中文
然后右键此电脑→属性→高级系统设置→环境变量→Path(编辑-新建)然后把上面的路径复制进去
然后一步一步点击确定即可
3.编写批处理文件
桌面右键→新建→文本文档 之后在里面写入如下代码：
for %%a in (*.mp4) do ffmpeg -i "%%a" -c copy -metadata:s:v:0 rotate=90 "newfiles\%%~na.mp4" pause 之后保存回到桌面把文本文档的后缀.txt改为.bat
4.将批处理文件和要转换的视频放在一起，并在此文件夹中新建一个名为newfiles的文件夹，之后运行.bat文件即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a77995ad0d3b866d69a5788365d3b66/" rel="bookmark">
			Linux环境安裝oracle 11g
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 介绍服务器要求准备关闭selinux关闭防火墙配置镜像依赖包修改内核参数配置文件修改用户的限制文件下载安装包 创建用户目录创建用户和用户组删除用户 创建安装目录、赋权设置oracle用户环境变量上传文件到服务器 安装默认密码 配置监听创建数据库 介绍 最近要用到oracle，很久没搞过，要求不能使用Docker。采用虚拟机方式安装。搭建虚拟机，安装了下oracle，记录下安装过程。
服务器要求 采用虚拟机方式安装，服务器为Centos7需要桌面，oracle安装需要桌面支持。
小插曲:开始使用vmware15.2安装虚拟机，镜像支持桌面，启动默认命令行，改了很多配置，不生效。升级vmware到15.5 桌面版正常。
至少2G内存40G硬盘(开始分配20G不够用) 准备 以下操作需要root 权限
关闭selinux vim /etc/selinux/config
SELINUX=disabled setenforce 0 关闭防火墙 systemctl disable firewalld.service systemctl stop firewalld.service 配置镜像 #备份 mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup #下载新的 CentOS-Base.repo 到 /etc/yum.repos.d/，这里使用阿里的yum源。 wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo #清空yum缓存 yum clean all #重建缓存 yum makecache #查看配置目录资源数 yum repolist 依赖包 依赖包可以从安装镜像解压后镜像packages中获取，或网上找
binutils-2.23.52.0.1-12.el7.x86_64 compat-libcap1-1.10-3.el7.x86_64 compat-libstdc++-33-3.2.3-71.el7.i686 compat-libstdc++-33-3.2.3-71.el7.x86_64 gcc-4.8.2-3.el7.x86_64 gcc-c++-4.8.2-3.el7.x86_64 glibc-2.17-36.el7.i686 glibc-2.17-36.el7.x86_64 glibc-devel-2.17-36.el7.i686 glibc-devel-2.17-36.el7.x86_64 ksh libaio-0.3.109-9.el7.i686 libaio-0.3.109-9.el7.x86_64 libaio-devel-0.3.109-9.el7.i686 libaio-devel-0.3.109-9.el7.x86_64 libgcc-4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a77995ad0d3b866d69a5788365d3b66/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b348b586a790d3c962a370932b1dbe63/" rel="bookmark">
			③【蓝桥杯】STM32G4嵌入式竞赛实训平台（CT117E-M4）学习——串口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面——
本文将介绍嵌入式竞赛实训平台（CT117E-M4）开发板上串口的使用。
目录
一、硬件平台 二、软件平台
三、串口原理图
四、配置过程
五、编写函数
（一）重定义printf函数
（二）串口发送/接收函数
（三）串口中断函数
（四）串口查询函数
六、总结
一、硬件平台 嵌入式竞赛实训平台（CT117E-M4）是北京国信长天科技有限公司设计、生产的一款“蓝桥杯全国软件与信息技术专业人才大赛–嵌入式设计与开发科目”专用竞赛平台，平台STM32G431RBT6为主控芯片，预留扩展板接口，可为用户提供丰富的实验场景。
CT117E-M4产片图片
二、软件平台 KEIL5,STM32CubeMX
三、串口原理图 由官方提供的原理图可以看出，DAP Link的串口连接在芯片的PA9和PA10引脚。查阅芯片资料，可以得知PA9和PA10分别是芯片USART1的Tx和Rx： PA9 ---&gt; USART1_Tx PA10 ---&gt; USART1_Rx 注：这与我们平时较常用的STM32F1系列芯片是一样的
四、配置过程 本次配置过程仅仅介绍串口的基本使用，DMA的使用将单独作为一篇博客.
基本配置步骤： 1.点击USATR1 2.设置MODE为异步通信(Asynchronous) 3.波特率为115200Bits/s ；传输数据长度为8 Bit；奇偶检验无；停止位1；接收和发送都使能 4.GPIO引脚设置 USART1_RX/USART_TX
5 .NVIC Settings 一栏使能接收中断
五、编写函数 （一）重定义printf函数 1.在 main.c中包含#include &lt;stdio.h&gt;并声明串口
/* Private includes ----------------------------------------------------------*/ /* USER CODE BEGIN Includes */ #include &lt;stdio.h&gt; /* USER CODE END Includes */ /* Private user code ---------------------------------------------------------*/ /* USER CODE BEGIN 0 */ extern UART_HandleTypeDef huart1; //声明串口 /* USER CODE END 0 */ 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b348b586a790d3c962a370932b1dbe63/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b77bfc7a570a0c506709e07662bcd3d2/" rel="bookmark">
			linux-常用命令-ping、telent、tracert、dig、nc的用法与介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 区别 Ping：基于ICPM协议，用来测试网络连接质量情况
Telnet：基于TCP/IP协议，常用探测指定ip是否开放指定端口号
Tracert：window路由跟踪使用程序，可以用于确认IP数据包访问目标时所选择的路径
dig(域信息搜索器)：用来查询DNS域名服务器的工具
nc：实现任务TCP/UDP端口的侦听，nc可以作为server以TCP或UDP方式侦听端口；端口的扫描，nc可以作为client发起TCP或UDP连接；机器之间传输文件；机器之间网络测速
ping不通的原因 1、服务器没启动/ip不存在
2、网段不同,通过路由也无法找到
3 、防火墙设置，过滤了ping发出的ICMP数据包，导致无反馈，time out
4、Ip地址设置错误，对于多个网卡的服务器来说，每个网口的ip配置必须不能在同一个网段，否则会造成路由不知选择哪一个出口
5、 网线故障
6)、未设置网关，这个对于小网128网段，走路由器的，如果未配置将无法路由
Telnet不同的原因 1、telnet服务本身的问题：服务是否启用
2、防火墙策略问题：telnet服务所在的系统防火墙是否做了限制，从源主机到提供telnet服务的主机之间的防火墙是否做了限制
3、服务是否限制ip，服务是否达到最大连接数
NC常用参数（使用nc 命令需要接收服务器和发送服务器都同时开启端口） 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03cb78d5170e05a76aabe9f1a54d210c/" rel="bookmark">
			CVE-2019-0708（BlueKeep）漏洞分析与复现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、 漏洞简介1、漏洞介绍：2、漏洞原理：3、影响版本： 二、 漏洞复现复现环境：复现过程：1、主机发现：2、使用MSF的漏洞模块：3、对靶机进行漏洞扫描：4、使用攻击模块，对靶机进行攻击5、使用POC，进行蓝屏攻击 一、 漏洞简介 1、漏洞介绍： 2019年5月14日微软官方发布安全补丁，修复了 Windows 远程桌面服务的远程代码执行漏洞，该漏洞影响了某些旧版本的 Windows 系统。此漏洞是预身份验证，无需用户交互，这就意味着这个漏洞可以通过网络蠕虫的方式被利用，与2017年 WannaCry 勒索病毒的传播方式类似。
2、漏洞原理： 存在漏洞的远程桌面服务器，在接收到特殊数据包时会释放一个内部信道 MS_T120 的控制结构体，但并未将指向该结构体的指针删除，而且在远程桌面连接结束之后还会调用 MS_T120 结构体内的一个函数指针，若攻击者可通过远程发送数据重新占据被释放的 MS_T120，并为结构体内的函数指针赋恰当的值，即可实现远程命令执行。
3、影响版本： 目前已知受影响的 Windows 版本包括但不限于：
Windows 7
Windows Server 2008
Windows Server 2008 R2
Windows Server 2003
Windows XP
Windows 8 和 windows10 以及之后的版本不受此漏洞影响
二、 漏洞复现 复现环境： 攻击机：Linux kali（IP：192.168.50.130）
靶机：Windows 7 Enterprise with Service Pack 1 (x64)（IP：192.168.50.132）
条件：两台机子可以相互ping通，并且靶机（无补丁）开启了3389端口，防火墙是关闭的！
复现过程： 1、主机发现： 登录 kali linux，用 nmap 探测本网段存活主机
nmap 192.168.50.0/24 可以看到靶机的3389端口是开放的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/03cb78d5170e05a76aabe9f1a54d210c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4d17dbdcba45e7782a0c8e3aeb5b643/" rel="bookmark">
			pycharm配置使用pytest作为运行方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.Python Integrated Tools 中的default test runner:设置pytest
2.需要设置pytest.mian（）
3 .py文件必须要用test_xxx函数（重点）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03d476861afd384510f2cb80ccfa8511/" rel="bookmark">
			postman
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随机数 随机数概念
大批量测试以及自动化测试过程中，对同一个不允许重复的参数进行传参时，可以保证其不被重复
方式：
1、{{$guid}}：guid
2、{{$timestamp}：将当前的时间戳
3、{{$randomInt}}：添加0和1000之间的随机整数
正则表达式提取 数据 接口测试协议 1.webservice协议：接口地址：http://…?wsdl,走soap协议通过http传输，请求报文和返回报文都是xml格式的。测试的时候需要通过工具才能进行调用，测试（一般实时通讯，比如说QQ会使用）
http://127.0.0.1:8080/adduser
http://127.0.0.1:8080/deluser
http://127.0.0.1:8080/upduser
http://127.0.0.1:8080/setuser
soap协议，wsdl
restful规则：
get获取数据，post提交数据，put修改数据，delete删除数据
http://127.0.0.1:8080/user
2.dubbo协议：接口地址以dubbo://……,走http协议，通过路径来区分调用的方法，请求报文都是key-value形式的，返回报文一般都是json格式
适用于少量数据的创术，大并发
3.http协议：接口地址http:// 80%
验证输出的内容和输入的内容是否一致 1.pre上设置输入的值
3.http协议：接口地址http:// 80%
验证输出的内容和输入的内容是否一致 1.pre上设置输入的值
2.text验证，先获取输入的值，再获取接口返回的值，对这两个值进行判断
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60c1a545718f3631453e35578271bd9d/" rel="bookmark">
			面试题-网络篇-fiddler
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、弱网测试 弱网测试的原理是什么？
fiddler来模拟限速，因为fiddler是作为代理软件，提供了客户端请求前和服务器响应前的回调接口。可以在这些接口自定义一些逻辑。Fiddler通过延迟发送数据和接收数据的时间来限制网络的下载速度和上传速度，从而达到限速的效果。fiddler怎么模拟弱网场景？MQTT是什么？
在Fiddler中rules右键点击Customize Rules(自定义规则)，然后双击大概然后双击打开 Customize Rules.js文档，修改文档中每上传或者是下载1kb数据所需要的时间来模拟我们的弱网环境，然后再rules–performance（性能）下面点击simulate modem speeds（模拟调制解调器速度）开启弱网环境的模拟 ，通过以上三步，就可以实现弱网测试场景的构造。
MQTT是一个基于客户端-服务器的消息发布/订阅传输协议。 二、断点 断点的概念
Break Point：进行接口测试时，拦截和修改数据，测试后端。主要是用来修改请求和响应数据的
比如一个购买的金额输入框，输入框前端做了限制100~1000，那么我们测试的时候，需要测试小于100的情况下，很明显前端只能输入大于100的。那么我们可以先抓到接口，修改请求参数，绕过前端，传一个小于100的数，检查服务端的功能是否可以；断点的方式有哪一些
Before Requests：在请求时，没有达到服务器之前设置断点。 --全局断点（中断fiddler捕获的所有请求）
After responses：服务器响应之后，在fiddler将响应传回给客服端之前。 --全局断点（中端fiddler捕获的所有服务器返回数据）可以修改那些请求
请求：可以修改请求头信息，如cookie，User-Agent等，也可以修改请求数据，如表单限制，字段大小限制
响应：可以修改响应体的数据 三、抓包工具的区别？ 1.Fiddler是免费开源的，但只能在windows下使用，mac和Linux是不支持的
2.Charles支持windows、MacOS和Linux操作系统，但是它不免费
3.Wireshark可以抓取所有协议的内容，非常适合协议的学习和网络问题的分析，但是Wireshark它需要你具备一定的网络知识，所以对于初学者来说不是很友好
4.F12最简单最轻量级，但是和其他的抓包工具还是存在一定的差距
5.TCPdump主要用于Linux命令的抓包工具，前提是你要会操作Linux系统
四、Fiddler能做什么？ Fiddler是一款功能强大的抓包工具，能获取和记录客户端与服务器之间的HTTP（及HTTPS）请求。
1、抓包：抓取HTTP请求和响应内容。
2、改包：设置断点，拦截HTTP请求或响应报文，修改后再放行。
3、模拟各种客户端：fiddler可修改user-agent内容，伪装成各种客户端发送请求。
4、弱网测试：通过限制HTTP请求或响应的速度，来模拟网络延迟。
五、Fiddler为什么能抓包？ Fiddler实际上是一个web代理服务器，代理地址为127.0.0.1，默认端口为8888。代理服务器位于Web浏览器和Web服务器中间，扮演“中间人”的角色。
1、当Fiddler启动抓包时，会将本机internet连接中，设置为使用代理服务器，地址为127.0.0.1，端口号为8888
2、当Fidder关闭抓包时，将本机internet选项中，取消代理设置。
Fiddler只能抓HTTP和HTTPS协议的包，其他协议的包是抓不到的，比如qq聊天时候发送的消息，就是抓不到的。
六、Fiddler怎么修改HTTP协议内容？ 举例，假设对www.baidu.com发送请求，
1、若要修改HTTP请求的内容
1）在fiddler左下角的命令行中，输入bpu www.baidu.com
2）浏览器中打开百度首页，即发送HTTP请求
3）fiddler中，该HTTP请求显示出来，且有个红色的T标志
4）在右侧的界面中，打开raw tab页，可手动修改请求的内容，点击【Run to completion】放行
5）输入bpu则取消断点设置。
2、若要修改HTTP响应的内容，在fiddler左下角命令行中，输入bpafter www.baidu.com，其他同上
七、fiddler如何修改请求参数： 方法一：直接在composer中修改，点击按钮【execute】重新请求就可以了
方法二：用断点的方式修改。fiddler下边有一个设置断点的按钮，箭头向上请求前断电，箭头向下响应断点。
设置断点以后，就可以在webform中修改请求参数了，然后点击按钮【run to connection】就可以重新发送了
八、Fiddler如何实现弱网测试？ 弱网一般指在电梯、地铁、公交车、隧道等场景下使用客户端浏览网页或者APP，此时可能会发生如下问题：
1、操作时间慢
2、用户体验差，出现闪退、卡死等情况
3、非正常情况下，出现bug的可能性增加，比如在电梯里打开app抢代金券，可能因为网络不好点击按钮后无反应，就多次点击按钮，导致网络恢复后，该用户抢了N多张代金券（需求是一个用户只能抢一张代金券）
弱网可分为如下场景：
1、网络慢，有延迟：fiddler的Rules-&gt;Performance-&gt;Simulate Modem Speeds，如果需要设置具体的延迟时间，可在FiddlerScript脚本中修改。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60c1a545718f3631453e35578271bd9d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25862c1a150f88da5650c08b646286d1/" rel="bookmark">
			嵌入式学习笔记（1）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		嵌入式设备驱动学习，主要是Linux设备驱动学习
任何一个计算机系统的运转都是系统中软硬件共同努力的结果，没有硬件的软件是空中楼阁，而没有软件的硬件则只是一堆废铁。硬件是底层基础，是所有软件得以运行的平台，代码最终会落实为硬件上的组合逻辑与时序逻辑；软件则实现了具体应用，它按照各种不同的业务需求而设计，并完成用户的最终诉求。硬件较固定，软件则很灵活，可以适应各种复杂多变的应用。因此，计算机系统的软硬件相互成就了对方。
但是，软硬件之间同样存在着悖论，那就是软件和硬件不应该互相渗透入对方的领地。为尽可能快速地完成设计，应用软件工程师不想也不必关心硬件，而硬件工程师也难有足够的闲暇和能力来顾及软件。譬如，应用软件工程师在调用套接字发送和接收数据包的时候，不必关心网卡上的中断、寄存器、存储空间、I/O端口、片选以及其他任何硬件词汇；在使用printf（）函数输出信息的时候，他不用知道底层究竟是怎样把相应的信息输出到屏幕或者串口。
也就是说，应用软件工程师需要看到一个没有硬件的纯粹的软件世界，硬件必须透明地呈现给他。谁来实现硬件对应用软件工程师的隐形？这个光荣而艰巨的任务就落在了驱动工程师的头上。
对设备驱动最通俗的解释就是“驱使硬件设备行动”。驱动与底层硬件直接打交道，按照硬件设备的具体工作方式，读写设备的寄存器，完成设备的轮询、中断处理、DMA通信，进行物理内存向虚拟内存的映射等，最终让通信设备能收发数据，让显示设备能显示文字和画面，让存储设备能记录文件和数据。
由此可见，设备驱动充当了硬件和应用软件之间的纽带，应用软件时只需要调用系统软件的应用编程接口（API）就可让硬件去完成要求的工作。在系统没有操作系统的情况下，工程师可以根据硬件设备的特点自行定义接口，如对串口定义SerialSend（）、SerialRecv（），对LED定义LightOn（）、LightOff（），对Flash定义FlashWr（）、FlashRd（）等。而在有操作系统的情况下，驱动的架构则由相应的操作系统定义，驱动工程师必须按照相应的架构设计驱动，这样，驱动才能良好地整合入操作系统的内核中。
驱动程序负责硬件和应用软件之间的沟通，而驱动工程师则负责硬件工程师和应用软件工程师之间的沟通。目前，随着通信、电子行业的迅速发展，全世界每天都会生产大量新芯片，设计大量新电路板，也因此，会有大量设备驱动需要开发。这些驱动或运行在简单的单任务环境中，或运行在VxWorks、Linux、Windows等多任务操作系统环境中，它们发挥着不可替代的作用。
并不是任何一个计算机系统都一定要有操作系统，在许多情况下，操作系统都不必存在。对于功能比较单一、控制并不复杂的系统，譬如ASIC内部、公交车的刷卡机、电冰箱、微波炉、简单的手机和小灵通等，并不需要多任务调度、文件系统、内存管理等复杂功能，用单任务架构完全可以良好地支持它们的工作。一个无限循环中夹杂着对设备中断的检测或者对设备的轮询是这种系统中软件的典型架构。在这样的系统中，虽然不存在操作系统，但是设备驱动则无论如何都必须存在。一般情况下，每一种设备驱动都会定义为一个软件模块，包含.h文件和.c文件，前者定义该设备驱动的数据结构并声明外部函数，后者进行驱动的具体实现。其他模块想要使用这个设备的时候，只需要包含设备驱动的头文件，然后调用其中的外部接口函数。
由此可见，在没有操作系统的情况下，设备驱动的接口被直接提交给应用软件工程师，应用软件没有跨越任何层次就直接访问设备驱动的接口。驱动包含的接口函数也与硬件的功能直接吻合，没有任何附加功能。图1.1所示为无操作系统情况下硬件、设备驱动与应用软件的关系。
以上是没有操作系统的时候设备驱动的情况，当系统包含操作系统时，设备驱动会变得怎样呢？
首先，无操作系统时设备驱动的硬件操作工作仍然是必不可少的，没有这一部分，驱动不可能与硬件打交道。其次，我们还需要将驱动融入内核。为了实现这种融合，必须在所有设备的驱动中设计面向操作系统内核的接口，这样的接口由操作系统规定，对一类设备而言结构一致，独立于具体的设备。
由此可见，当系统中存在操作系统的时候，驱动变成了连接硬件和内核的桥梁。如图1.4所示，操作系统的存在势必要求设备驱动附加更多的代码和功能，把单一的“驱使硬件设备行动”变成了操作系统内与硬件交互的模块，它对外呈现为操作系统的API，不再给应用软件工程师直接提供接口。
那么我们要问，有了操作系统之后，驱动反而变得复杂，那要操作系统干什么？首先，一个复杂的软件系统需要处理多个并发的任务，没有操作系统，想完成多任务并发是很困难的。其次，操作系统给我们提供内存管理机制。一个典型的例子是，对于多数含MMU的32位处理器而言，Windows、Linux等操作系统可以让每个进程都可以独立地访问4GB的内存空间。上述优点似乎并没有体现在设备驱动身上，操作系统的存在给设备驱动究竟带来了什么实质性的好处？
简而言之，操作系统通过给驱动制造麻烦来达到给上层应用提供便利的目的。当驱动都按照操作系统给出的独立于设备的接口而设计时，那么，应用程序将可使用统一的系统调用接口来访问各种设备。对于类UNIX的VxWorks、Linux等操作系统而言，当应用程序通过write（）、read（）等函数读写文件就可访问各种字符设备和块设备，而不论设备的具体类型和工作方式，那将是多么便利。
设备的分类及特点
计算机系统的硬件主要由CPU、存储器和外设组成。随着IC制作工艺的发展，目前，芯片的集成度越来越高，往往在CPU内部就集成了存储器和外设适配器。譬如，相当多的ARM、PowerPC、MIPS等处理器都集成了UART、I2C控制器、SPI控制器、USB控制器、SDRAM控制器等，有的处理器还集成了GPU（图形处理器）、视频编解码器等。
驱动针对的对象是存储器和外设（包括CPU内部集成的存储器和外设），而不是针对CPU内核。Linux将存储器和外设分为3个基础大类。·字符设备。·块设备。·网络设备。
字符设备指那些必须以串行顺序依次进行访问的设备，如触摸屏、磁带驱动器、鼠标等。块设备可以按任意顺序进行访问，以块为单位进行操作，如硬盘、eMMC等。字符设备和块设备的驱动设计有出很大的差异，但是对于用户而言，它们都要使用文件系统的操作接口open（）、close（）、read（）、write（）等进行访问。在Linux系统中，网络设备面向数据包的接收和发送而设计，它并不倾向于对应于文件系统的节点。内核与网络设备的通信与内核和字符设备、网络设备的通信方式完全不同，前者主要还是使用套接字接口。
如图1.5所示，除网络设备外，字符设备与块设备都被映射到Linux文件系统的文件和目录，通过文件系统的系统调用接口open（）、write（）、read（）、close（）等即可访问字符设备和块设备。所有字符设备和块设备都统一呈现给用户。Linux的块设备有两种访问方法：一种是类似dd命令对应的原始块设备，如“/dev/sdb1”等；另外一种方法是在块设备上建立FAT、EXT4、BTRFS等文件系统，然后以文件路径如“/home/barry/hello.txt”的形式进行访问。在Linux中，针对NOR、NAND等提供了独立的内存技术设备（MemoryTechnology Device，MTD）子系统，其上运行YAFFS2、JFFS2、UBIFS等具备擦除和负载均衡能力的文件系统。针对磁盘或者Flash设备的FAT、EXT4、YAFFS2、JFFS2、UBIFS等文件系统定义了文件和目录在存储介质上的组织。而Linux的虚拟文件系统则统一对它们进行了抽象。
应用程序可以使用Linux的系统调用接口编程，但也可使用C库函数，出于代码可移植性的目的，后者更值得推荐。C库函数本身也通过系统调用接口而实现，如C库函数fopen（）、fwrite（）、fread（）、fclose（）分别会调用操作系统的API open（）、write（）、read（）、close（）。
Linux设备驱动的学习是一项浩繁的工程，包含如下重点、难点。
·编写Linux设备驱动要求工程师有非常好的硬件基础，懂得SRAM、Flash、SDRAM、磁盘的读写方式，UART、I2C、USB等设备的接口以及轮询、中断、DMA的原理，PCI总线的工作方式以及CPU的内存管理单元（MMU）等。
·编写Linux设备驱动要求工程师有非常好的C语言基础，能灵活地运用C语言的结构体、指针、函数指针及内存动态申请和释放等。
·编写Linux设备驱动要求工程师有一定的Linux内核基础，虽然并不要求工程师对内核各个部分有深入的研究，但至少要明白驱动与内核的接口。尤其是对于块设备、网络设备、Flash设备、串口设备等复杂设备，内核定义的驱动体系结构本身就非常复杂。
·编写Linux设备驱动要求工程师有非常好的多任务并发控制和同步的基础，因为在驱动中会大量使用自旋锁、互斥、信号量、等待队列等并发与同步机制。
上述经验值的获取并非朝夕之事，因此要求我们有足够的学习恒心和毅力。
动手实践永远是学习任何软件开发的最好方法，学习Linux设备驱动也不例外。因此，本书使用的是通过QEMU模拟的ARMvexpress电路板，本书中的所有实例均可在该“电路板”上直接执行。阅读经典书籍和参与Linux社区的讨论也是非常好的学习方法。Linux内核源代码中包含了一个Documentation目录，其中包含了一批内核设计文档，全部是文本文件。很遗憾，这些文档的组织不太好，内容也不够细致。学习Linux设备驱动的一个注意事项是要避免管中窥豹、只见树木不见森林，因为各类Linux设备驱动都从属于一个Linux设备驱动的架构，单纯而片面地学习几个函数、几个数据结构是不可能理清驱动中各组成部分之间的关系的。因此，Linux驱动的分析方法是点面结合，将对函数和数据结构的理解放在整体架构的背景之中。这是本书各章节讲解驱动的方法。
参考文献：宋宝华 《Linux设备驱动开发详解：基于最新的Linux4.0 内核》
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1731deeb1d86a75349f4761cad974f49/" rel="bookmark">
			ffmpeg常用编解码命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ffmpeg常用编解码命令 1 ffplay.exe （1） 播放MP4文件，指定标题以及播放分辨率
ffplay.exe -window_title “视频监控” -x 720 -y 576 -i 2019-09-19-14-21-20-Ch7.mp4
（2）播放yuv格式文件
ffplay.exe -video_size 1920x1080 -i ffmpegVideo.yuv
2 ffprobe.exe （1）ffprobe.exe -i 2019-09-19-14-21-20-Ch7.mp4
3 ffmpeg.exe 一、格式转换
（1） 将mp4格式转换为avi，默认编码格式
ffmpeg.exe -i 2019-09-19-14-21-20-Ch7.mp4 output_origin.avi
（2） 将mp4格式转换为avi,编码格式保持不变
ffmpeg.exe -i 2019-09-19-14-21-20-Ch7.mp4 -c copy output_origin.avi
（3） 将mp4格式转换为avi,指定视频编码格式mjpeg
ffmpeg.exe -i 2019-09-19-14-21-20-Ch7.mp4 -c:v mjpeg output_dest.avi
（4） yuv文件转换为h264
ffmpeg -s 1280x720 -i test.yuv -vcodec libx264 test.h264
（5） 将h264文件转yuv文件
ffmpeg -i text.h264 -vcodec rawvideo -an test.yuv
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1731deeb1d86a75349f4761cad974f49/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/707f3b90a831cd423e1197607108c904/" rel="bookmark">
			关于求解微分方程——初学Matlab里的 ODE求解器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习背景 最近想挖掘一下自己项目的理论深度，于是找到了老师。在老师的建议下，我们开始了漫长的研读老师的论文的旅程（论文名：Optimal Design of Adaptive Robust Control for Fuzzy Swarm Robot Systems 模糊群自适应鲁棒控制的优化设计机器人系统）。这篇文章写的是关于群体智能控制在机器人群中的运用，提到了许多控制理论。诸如李雅普诺夫方程，模糊群分析，优化理论等等。作为一个理论白痴我选择将这些理论的东西的学习理解交给我的大佬队友。然后我选择了学习最后的simulation（实验仿真）。这里面的simulation用到了一种求解隐式微分方程的方法。于是就有了这篇文章的由来。
求解常微分方程组的方法 1、dsolve 函数
dsolve函数用于求常微分方程组的精确解，也称为常微分方程的符号解。如果没有初始条件或边界条件，则求出通解；如果有，则求出特解。
1)函数格式 Y = dsolve(‘eq1,eq2,…’ , ’cond1,cond2,…’ , ’Name’)
其中，‘eq1,eq2,…’:表示微分方程或微分方程组;
’cond1,cond2,…’:表示初始条件或边界条件;
‘Name’:表示变量。没有指定变量时，matlab默认的变量为t；
2)例程
例1.1(dsolve 求解微分方程)
求解微分方程：
在命令行输入: dsolve('Dy=3*x^2','x') ,摁下enter键后输出运行结果。
例1.2（加上初始条件）
求解微分方程：
只需要在命令行添加初始条件即可，此时求出的即为方程的特解。可以看到上例中的C9变为了2。
例2(dsolve 求解微分方程组)
求解微分方程组： 由于x,y均为t的导数，所以不需要在末尾添加’t’。
2、ode函数
在上文中我们介绍了dsolve函数。但有大量的常微分方程，虽然从理论上讲，其解是存在的，但我们却无法求出其解析解，此时，我们需要寻求方程的数值解。
怎么理解数值求解呢？数值分析是一门专门的学科，在此不过多介绍。我主要想通过一个简单的例子来向大家阐述数值求解的思想。
比如，求解微分方程 。我们就可以转化为，那么。因此，我们可以通过迭代的方式来求解y。即可理解为步长。
ode是Matlab专门用于解微分方程的功能函数。该求解器有变步长（variable-step）和定步长（fixed-step）两种类型。不同类型有着不同的求解器。
然后我又从其他大佬那ctrl+v了一份具体点的ODE求解器的整理。
在工程实践中，我们经常遇到一些ODEs，其中某些解变换缓慢，另一些变化很快，且相差悬殊的微分方程，这就是所谓的刚性问题(Stiff)，对于所有解的变化相当我们则称为非刚性问题(Nonstiff)。
变步长模式解法器有：ode45，ode23，ode113，ode15s，ode23s，ode23t，ode23tb和discrete。
a) ode45：缺省值，四/五阶龙格－库塔法，适用于大多数连续或离散系统，但不适用于刚性（stiff）系统。它是单步解法器，也就是，在计算y(tn)时，它仅需要最近处理时刻的结果y(tn-1)。一般来说，面对一个仿真问题最好是首先试试ode45。
b) ode23：二/三阶龙格－库塔法，它在误差限要求不高和求解的问题不太难的情况下，可能会比ode45更有效。也是一个单步解法器。
c) ode113：是一种阶数可变的解法器，它在误差容许要求严格的情况下通常比ode45有效。ode113是一种多步解法器，也就是在计算当前时刻输出时，它需要以前多个时刻的解。
d) ode15s：是一种基于数字微分公式的解法器（NDFs）。也是一种多步解法器。适用于刚性系统，当用户估计要解决的问题是比较困难的，或者不能使用ode45，或者即使使用效果也不好，就可以用ode15s。
e) ode23s：它是一种单步解法器，专门应用于刚性系统，在弱误差允许下的效果好于ode15s。它能解决某些ode15s所不能有效解决的stiff问题。
f) ode23t：是梯形规则的一种自由插值实现。这种解法器适用于求解适度stiff的问题而用户又需要一个无数字振荡的解法器的情况。
g)ode23tb：是TR-BDF2的一种实现， TR-BDF2 是具有两个阶段的隐式龙格－库塔公式。 h)discrtet：当Simulink检查到模型没有连续状态时使用它。
固定步长模式解法器有：ode5，ode4，ode3，ode2，ode1和discrete。
a) ode5：缺省值，是ode45的固定步长版本，适用于大多数连续或离散系统，不适用于刚性系统。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/707f3b90a831cd423e1197607108c904/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/946d5f32a89e59f6fcd0366bbec139d4/" rel="bookmark">
			【计算机视觉01】基础图像处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.opencv的安装
2.图像基础处理 2.1、直方图
2.2、高斯滤波
2.3、直方图均衡化 1.opencv的安装 win+R打开命令提示符窗口，输入如下代码：
pip install opencv-python -i https://pypi.tuna.tsinghua.edu.cn/simple opencv-python pip install opencv-contrib-python -i https://pypi.tuna.tsinghua.edu.cn/simple opencv-python 然后输入import cv2回车，再输入cv2.__version__后出现 表示安装成功。
打开ipycharm，导入cv2模块进行测试：
2.图像基础处理 2.1、直方图 基本原理：直方图，是一种二维统计图表，它的两个坐标分别是统计样本和该样本对应的某个属性的度量。图像的直方图用来表征该图像像素值的分布情况。用一定数目的小区间(bin)来指定表征像素值的范围,每个小区间会得到落入该小区间表示范围的像素数目。图像直方图图形化显示不同的像素值在不同的强度值上的出现频率，对于灰度图像来说强度范围为[0~255]之间，对于RGB的彩色图像可以独立显示三种颜色的图像直方图。同时直方图是用来寻找灰度图像二值化阈值常用而且是有效的手段之一，如果一幅灰度图像的直方图显示为两个波峰，则二值化阈值应该是这两个波峰之间的某个灰度值。并且直方图是调整图像对比度的重要依据，直方图拉伸和直方图均衡化是两种最常见的间接对比度增强方法。
Matplotlib库
Matplotlib库主要的作用，是用来生成绘图，直方图，功率谱，条形图，错误图，散点图等，而Matplotlib是一个Python的2D绘图库，它以各种硬拷贝格式和跨平台的交互式环境生成出版质量级别的图形。
hist函数
hist有直方图的意思，直方图也被称为频数直方图，它用来显示数据集的分布情况。在MATLAB中绘制直方图的函数是hist，用法是hist（y，x），表示以向量x的各个元素为统计范围，绘制y的分布情况。
代码实现：
# -*- coding: cp936 -*- from PIL import Image from pylab import * plt.rcParams['font.sans-serif'] = 'SimHei' plt.rcParams['axes.unicode_minus'] = False im = array(Image.open('E:/JiDaPictures/6.jpg').convert('L')) subplot(131) imshow(im) subplot(132) gray() contour(im, origin='image') axis('equal') axis('off') subplot(133) hist(im.flatten(), 128) print(im.flatten()) title(u'图像直方图') plt.xlim([0,260]) plt.ylim([0,15000]) show() 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/946d5f32a89e59f6fcd0366bbec139d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e75a9abb04839131776d5dd62cf186e/" rel="bookmark">
			RSA 签名用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引用：encoding - Signing and verifying signatures with RSA C# - Stack Overflow
1.首先生成Key
using (RSACryptoServiceProvider RSA = new RSACryptoServiceProvider()) { //Export the key information to an RSAParameters object. //Pass false to export the public key information or pass //true to export public and private key information. //RSAParameters RSAPublicParams = RSA.ExportParameters(false); //RSAParameters RSAPrivateParams = RSA.ExportParameters(false); var publicKye = RSA.ExportXmlPublicKey(); var privateKye = RSA.ExportXmlPrivateKey(); } 2. 使用上面保存的Key
var signText = ""; var originalMessage = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e75a9abb04839131776d5dd62cf186e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb8eac09c7ae3a047d60aeb1902ccbc3/" rel="bookmark">
			Postgis使用工具raster2pgsql批量导入栅格数据（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		另外一种批量导入栅格数据的方式，是使用工具gdalbuildvrt生成vrt文件 。
1.栅格数据 WorldClim是一个高空间分辨率的全球天气和气候数据的数据库。可以从该网站下载天气数据。网址如下：https://www.worldclim.org。
下面是12个月份温度统计数据
2.生成rvt文件 gdalbuildvrt -separate tmax_multi.vrt tmax*.bil 验证vrt文件的正确性
gdalinfo tmax_multi.vrt 结果如下：
Driver: VRT/Virtual Raster Files: tmax_multi.vrt tmax1.bil tmax10.bil tmax11.bil tmax12.bil tmax2.bil tmax3.bil tmax4.bil tmax5.bil tmax6.bil tmax7.bil tmax8.bil tmax9.bil Size is 2160, 900 Coordinate System is: GEOGCRS["WGS 84", DATUM["World Geodetic System 1984", ELLIPSOID["WGS 84",6378137,298.257223563, LENGTHUNIT["metre",1]]], PRIMEM["Greenwich",0, ANGLEUNIT["degree",0.0174532925199433]], CS[ellipsoidal,2], AXIS["latitude",north, ORDER[1], ANGLEUNIT["degree",0.0174532925199433]], AXIS["longitude",east, ORDER[2], ANGLEUNIT["degree",0.0174532925199433]], ID["EPSG",4326]] Data axis to CRS axis mapping: 2,1 Origin = (-180.000000000000057,90.000000000000000) Pixel Size = (0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb8eac09c7ae3a047d60aeb1902ccbc3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c80cb48fae954c0332b29689eb9875f/" rel="bookmark">
			nvm在windows系统的安装和使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		nvm是node版本管理和控制工具
下载 nvm-windows 版本下载地址 https://github.com/coreybutler/nvm-windows/releases
安装 按步骤走
管理员身份打开 cmd 在命令行输入nvm，可看到如下内容代表安装成功：
常用命令 nvm ls 查看已经安装的所有nodejs版本nvm install 版本号，可安装指定版本的nodejs nvm install 14.17.3nvm use 版本号，即可切换到指定版本 nvm use 14.17.3nvm uninstall 版本号，卸载指定版本 nvm uninstall 14.17.3 遇到的问题 问题1 `nvm install 14.17.3时 cmd提示下载npm时候失败` 错误信息 Downloading npm version 6.14.13... Error while downloading https://github.com/npm/cli/archive/v6.14.13.zip - Get "https://github.com/npm/cli/archive/v6.14.13.zip": read tcp 192.168.0.102:51464-&gt;20.205.243.166:443: wsarecv: An established connection was aborted by the software in your host machine. panic: runtime error: invalid memory address or nil pointer dereference 解决方法：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c80cb48fae954c0332b29689eb9875f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f29f07f380916157bb2663a239bf46b6/" rel="bookmark">
			多个Excel合并为一个Excel表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里写自定义目录标题 多个Excel合并为一个Excel表VBA宏代码 多个Excel合并为一个Excel表 使用方法记录：
1、新建一个Excel表格，另存为带宏的工作薄，后缀为xlsm，名为“汇总.xlsm”。
2、打开这个汇总文件，保留sheet1，删除sheet2和sheet3。
3、按“Alt + F11”快捷键，进入宏代码编辑界面，双击左侧sheet1，进入代码编辑窗口。
4、将以下VBA宏代码复制到代码编辑窗中。
注意：(*.xls),*.xls格式为所对应表格后缀格式，xls可以修改为其他格式，如xlsx。
VBA宏代码 合并多个EXCEL文件到一个EXCEL文件不同工作表文件。
把下列内容复制到宏,而后执行宏,选择所有需要合并的文件即可。下面为VBA宏代码：
Sub 合并多个EXCEL() Dim filestoopen, ft Dim x As Integer Application.ScreenUpdating = False On Error GoTo errhandler filestoopen = Application.GetOpenFilename(filefilter:="micrsofe excel文件(*.xls),*.xls", MultiSelect:=True, Title:="要合并的文件") If TypeName(filestoopen) = "boolean" Then MsgBox "没有选定文件" 'goto errhandler End If x = 1 While x &lt;= UBound(filestoopen) Set wk = Workbooks.Open(Filename:=filestoopen(x)) wk.Sheets().Move after:=ThisWorkbook.Sheets _ (ThisWorkbook.Sheets.Count) x = x + 1 Wend MsgBox "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f29f07f380916157bb2663a239bf46b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/edab021b9083ee55ec93f1d1c8967c3a/" rel="bookmark">
			Navicat连接Oracle出现oracle library is not loaded和ORA-12523的错误分析与解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Navicat连接Oracle出现oracle library is not loaded和ORA-12523的错误分析与解决 前言oracle library is not loaded问题解决ORA-12523错误分析与解决 前言 笔者用的是那时最新Navicat Premium 15
什么破解版？下次下次
言归正传
oracle library is not loaded问题解决 连接时可能会出现oracle library is not loaded，可能是oci.dll路径不对造成的问题
解决方案：
打开Navicat Premium程序，打开“工具 - 选项 - 环境 - OCI环境 - OCI library (oci.dll)”，然后将你刚才下载的文件夹中的oci.dll文件的完整目录填上，点击确定。
重启Navicat Premium程序进行测试双击oracle数据库，发现现在可以连接了，完成。
ORA-12523错误分析与解决 若上述问题解决了依然存在如下问题：
网上的解决方案天花乱坠，什么修改ora文件啊，什么服务没开啊，不过也不妨可能是解决方案吧
我们从最根本出发，不就是找不到服务名嘛，所以可能又两种，没有？不太可能，那就是名称不对应~
S:\oracle\product\11.2.0\dbhome_1\NETWORK\ADMIN\tnsnames.ora
OK，大功告成~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48f7037f55b47ea9e6fbe0bcd4b2d9f4/" rel="bookmark">
			Postgis使用工具raster2pgsql批量导入栅格数据（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.栅格数据 WorldClim是一个高空间分辨率的全球天气和气候数据的数据库。可以从该网站下载天气数据。网址如下：https://www.worldclim.org。
下面是12个月份温度统计数据。
2.使用工具raster2pgsql 将栅格数据导入到postgis 首先，生成sql文件。
raster2pgsql -d -I -C -M -F -t 100x100 -s 4326 tmax*.bil public.tmax &gt; tmax.sql 其中，命令参数如下：
参数含义-d表存在时，删除并重新创建-I在栅格数据列上生成GIST空间索引-C在栅格数据列上生成约束-M 在栅格列上运行VACUUM ANALYZE-F增加一列，值为文件名-t将栅格数据切分为片，片的大小格式为WIDTHxHEIGHT，然后插入每一行。-s空间坐标系 然后，执行sql文件。
psql -d postgis_32_sample -U postgres -f tmax.sql 命令中的参数如下：
参数含义-d数据库-U用户名-f文件名 3.查看表raster_columns信息 SELECT * FROM raster_columns where r_table_name = 'tmax'; 在pgAdmin中显示查询结果：
4.查看栅格块元信息 SELECT rid, (foo.md).* FROM (SELECT rid, ST_MetaData(rast) As md FROM public.tmax ) As foo; 在pgAdmin中显示查询结果：
5.统计栅格块数目 SELECT MIN(filename), COUNT(*) AS num_raster FROM public.tmax GROUP BY filename ORDER BY filename; 在pgAdmin中显示查询结果：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/48f7037f55b47ea9e6fbe0bcd4b2d9f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa37a650bb77c500c170a23188bd4020/" rel="bookmark">
			js模拟ps吸管吸取颜色功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用EyeDropper API实现的该功能，下面是代码，复制后到开发工具里面可直接运行到浏览器
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge" /&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt; &lt;title&gt;取色器 EyeDropper API&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;img src="https://img1.baidu.com/it/u=4209628392,3031563562&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=327&amp;h=500" alt="" width="300" /&gt; &lt;button id="btn"&gt;开始取色&lt;/button&gt; &lt;div id="color"&gt;&lt;/div&gt; &lt;script&gt; if ('EyeDropper' in window) { console.log('取色器可以使用') const eyeDropper = new EyeDropper() const btn = document.getElementById('btn') btn.addEventListener('click', async () =&gt; { try { const result = await eyeDropper.open() console.log(result) const colorHexValue = result.sRGBHex document.querySelector('#color').innerHTML = result.sRGBHex } catch (e) { console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa37a650bb77c500c170a23188bd4020/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ac7450cde9e25a834730e67ee6ee551/" rel="bookmark">
			OpenGL学习-高级OpenGL-实例化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
简述：
glDrawArraysInstanced和glDrawElementsInstanced：
gl_InstanceID：
实例化数组：
示例：
实例化渲染示例：
顶点着色器：
设置为实例化数组：
调用glDrawElementsInstanced绘制：
效果展示：
学习链接：
简述： 如果我们想以前一样渲染几千个物体，调用几千个渲染函数会极大的影响性能。
与绘制顶点本身相比，使用glDrawArrays或glDrawElements函数告诉GPU去绘制你的顶点数据会消耗更多的性能，因为OpenGL在绘制顶点数据之前需要做很多准备工作（比如告诉GPU该从哪个缓冲读取数据，从哪寻找顶点属性，而且这些都是在相对缓慢的CPU到GPU总线(CPU to GPU Bus)上进行的）。所以，即便渲染顶点非常快，命令GPU去渲染却未必。
如果我们能够将数据一次性发送给GPU，然后使用一个绘制函数让OpenGL利用这些数据绘制多个物体，就会更方便了。这就是实例化(Instancing)。
实例化这项技术能够让我们使用一个渲染调用来绘制多个物体，来节省每次绘制物体时CPU -&gt; GPU的通信，它只需要一次即可。
glDrawArraysInstanced和glDrawElementsInstanced： 如果想使用实例化渲染，我们只需要将glDrawArrays和glDrawElements的渲染调用分别改为glDrawArraysInstanced和glDrawElementsInstanced就可以了。这些渲染函数的实例化版本需要一个额外的参数，叫做实例数量(Instance Count)，它能够设置我们需要渲染的实例个数。
gl_InstanceID： 并且GLSL在顶点着色器中嵌入了另一个内建变量，gl_InstanceID。在使用实例化渲染调用时，gl_InstanceID会从0开始，在每个实例被渲染时递增1。比如说，我们正在渲染第43个实例，那么顶点着色器中它的gl_InstanceID将会是42。
实例化数组： 如果我们要渲染远超过100个实例的时候（这其实非常普遍），我们最终会超过最大能够发送至着色器的uniform数据大小上限。它的一个代替方案是实例化数组(Instanced Array)，它被定义为一个顶点属性（能够让我们储存更多的数据），仅在顶点着色器渲染一个新的实例时才会更新。
使用顶点属性时，顶点着色器的每次运行都会让GLSL获取新一组适用于当前顶点的属性。而当我们将顶点属性定义为一个实例化数组时，顶点着色器就只需要对每个实例，而不是每个顶点，更新顶点属性的内容了。这允许我们对逐顶点的数据使用普通的顶点属性，而对逐实例的数据使用实例化数组。
示例： 我们先生成buffer，把顶点数据绑上
然后启用location=2的顶点属性
glVertexAttribDivisor的含义是告诉了OpenGL该什么时候更新顶点属性的内容至新一组数据。它的第一个参数是需要的顶点属性，第二个参数是属性除数(Attribute Divisor)。默认情况下，属性除数是0，告诉OpenGL我们需要在顶点着色器的每次迭代时更新顶点属性。将它设置为1时，我们告诉OpenGL我们希望在渲染一个新实例的时候更新顶点属性。而设置为2时，我们希望每2个实例更新一次属性，以此类推。
实例化渲染示例： 顶点着色器： #version330 core
layout (location =0) invec3 aPos;
layout (location =2) invec2 aTexCoords;
layout (location =3) inmat4 aInstanceMatrix;
outvec2 TexCoords;
uniformmat4 projection;
uniformmat4 view;
void main()
{
TexCoords = aTexCoords;
gl_Position = projection * view * aInstanceMatrix *vec4(aPos, 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ac7450cde9e25a834730e67ee6ee551/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fcaec4c4d9ae3295ff3852be9cb4e164/" rel="bookmark">
			用数据说话，序列化框架性能哪家强？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		序列化是我们在日常开发中经常会使用到的技术，比如需要将内存对象持久化存储、需要将对象通过网络传输到远端。目前市面上序列化框架非常多，开发团队在进行技术选型时通常难以抉择，甚至会踩坑。
今天选择几款市面上常用的序列化框架进行测试对比，帮助开发团队搞清楚不同场景该采用哪种序列化框架。
测试对比的框架有四款：
JDK原生、fastjson、Kryo、Protobuf
接下来会从以下这四个方面给出详细的测试对比结果：
（1）是否通用：是否支持跨语言、跨平台；
（2）是否容易使用：是否编译使用和调试；
（3）性能好不好：序列化性能主要包括时间开销和空间开销，时间开销是指序列化和反序列化对象所耗费的时间，空间开销是指序列化生成数据大小；
（3）可扩展强不强：随着业务发展，传输的业务对象可能会发生变化，比如说新增字段，这个时候就要看所选用的序列化框架是否有良好的扩展性；
框架1：JDK原生 是否通用？ JDK 原生是 Java 自带的序列化框架，与 Java 语言是强绑定的，通过 JDK 将对象序列化后是无法通过其他语言进行返序列化的，所以它的通用性比较差。
是否容易使用？ 一个类实现了java.io.Serializable序列化接口就代表这个类的对象可以被序列化，否则就会报错。
简单认识一下Serializable这个类，通过看源码我们知道Serializable仅仅是一个空接口，没有定义任何方法。
public interface Serializable { } 这说明Serializable仅仅是一个标识的作用，用来告诉 JVM 这个对象可以被序列化。
想真正完成对象序列化和反序列化还得借助 IO 核心操作类：ObjectOutputStream和ObjectInputStream。
ObjectOutputStream类的writeObject()方法用于将对象写入 IO 流，完成对象序列化：
/** * 序列化 * * @param obj 待序列化对象 * @return 二进制字节数组 * @throws IOException */ public static byte[] serialize(Object obj) throws IOException { // 字节输出流 ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); // 将对象序列化为二进制字节流 ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream); objectOutputStream.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fcaec4c4d9ae3295ff3852be9cb4e164/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3acf55eaa43efbfdbe562b377eed7bc6/" rel="bookmark">
			docker基础篇-----06-----Docker常用安装、本地镜像推送到阿里云
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考文章：【学习笔记】尚硅谷周阳老师的Docker教程学习笔记。
一 Docker常用安装 实际上下面mysql、redis的安装涉及到的版本以及目录最好根据自己的实际情况来使用，不一定按照下面，下面的安装只是提供学习使用。
1. 安装tomcat 这里不讲了，很简单，已经安装过很多次，可以先docker search看看星最多的，如果想下载指定版本的，可以登录docker hub的网址，找到对应的tag，然后pull的时候带上该tag即可。
2. 安装mysql docker search mysql # docker hub上面查找mysql镜像 docker pull mysql:5.6 # 从docker hub上拉取mysql:5.6镜像到本地 docker images # 查看你是否有拉取到mysql # 运行镜像 docker run -p 12345:3306 --name mysql -v /tyy/mysql/conf:/etc/mysql/conf.d -v /tyy/mysql/logs:/logs -v /tyy/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.6 mysql在我这里的ubuntu测试不成功，但在centos成功。
不过这个不算问题，大家可以在实际开发中安装高版本的mysql，避免漏洞，并且配置路径、日志路径、数据路径都可以按照自己的需求来做。
3. 安装redis docker search redis # docker hub上面查找redis镜像 docker pull redis:3.2 # 从docker hub上拉取redis:3.2镜像到本地 docker images # 查看你是否有拉取到redis # 运行镜像 docker run -p 6379:6379 -v /tyy/myredis/data:/data -v /tyy/myredis/conf/redis.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3acf55eaa43efbfdbe562b377eed7bc6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc5cd54a986bf015623a55a8d959feea/" rel="bookmark">
			iOS实现9Patch图片调整（resizableImageWithCapInsets运用）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		代码实现： #pragma mark - iOS 调整9Patch - (UIImage *)auto9PatchWithImage:(UIImage *)fixedImage { UIImage *image = fixedImage; //決定图片拉伸的位置 CGFloat top = 42; CGFloat bottom = 20; CGFloat left = 42; CGFloat right = 20; UIEdgeInsets insets = UIEdgeInsetsMake(top, left, bottom, right); image = [image resizableImageWithCapInsets:insets resizingMode:UIImageResizingModeStretch]; return image; } UIImageResizingModeStretch： 对于拉伸的方式，有以下两种：
typedef NS_ENUM(NSInteger, UIImageResizingMode) { UIImageResizingModeTile,（瓦片） UIImageResizingModeStretch,（伸展） }; IUIImageResizingModeStretch：拉伸模式，通过拉伸UIEdgeInsets指定的矩形区域来填充图片UIImageResizingModeTile：平铺模式(瓦片)，通过重复显示UIEdgeInsets指定的矩形区域来填充图 capInsets参数为UIEdgeInsetsMake(42, 20, 42, 20)时 当我们向拉伸方法传入该组参数时,代表我们对原始图像除数字5以外的区域进行保护(即两个红色方块围起来的区域).其拉伸效果如图 在该种情况下,我们可以发现拉伸后的图像中:
在X轴上,由于1被左边和上边的设置保护,3被右边和上边的设置保护,所以只能用中间的2来拉伸,同理最底下的7,8,9在Y轴上,由于1被左边和上边的设置保护,7被左边和下边的设置保护,所以只能用中间的4来拉伸,同理最底下的3,6,9 UIImageResizingModeTile： capInsets参数为UIEdgeInsetsMake(42, 20, 42, 20)时 当我们向拉伸方法传入该组参数时,代表我们对原始图像除数字5以外的区域进行保护(即两个红色方块围起来的区域).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc5cd54a986bf015623a55a8d959feea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f59fad9fc14865e86dd7812df2804ae4/" rel="bookmark">
			python报错：cannot import name ‘PDFDocument‘ from ‘pdfminer.pdfparser‘ 解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		显示报错如下 from pdfminer.pdfparser import PDFParser, PDFDocument ImportError: cannot import name 'PDFDocument' from 'pdfminer.pdfparser' 解决办法 1、修改模块导入方式
from pdfminer.pdfparser import PDFParser, PDFDocument: 改为：
from pdfminer.pdfparser import PDFParser from pdfminer.pdfdocument import PDFDocument from pdfminer.pdfpage import PDFPage 2、修改模块调用方式（2处）
1）PDFDocument
doc = PDFDocument() 改为
doc = PDFDocument(parser) parser说明：
fp = open(pdf, 'rb') # 用文件对象创建一个PDF文档分析器 parser = PDFParser(fp) 2）循环方式
for page in doc.get_pages(): 改为
for page in PDFPage.create_pages(doc): 再次运行顺利，解决报错。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c487a5357421319ccf58361d5944be5/" rel="bookmark">
			子网划分(VLSM)和无类域间路由(CIDR)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分类的IPV4地址(IP地址 ::= {&lt;网络前缀&gt;， &lt;主机号&gt;} / 网络前缀所占位数) IP地址是由网络地址(网络号)和主机地址(主机号)构成，分为四段，每段8位二进制，每一段最大值是255
例：192.168.1.1/25该ip的网络号是多少，主机号是多少
答：根据子网掩码进行推算：0000 0000， 0000 0000，0000 0000 , 0000 0000
前面25位代表的是网络号，后面32-25=7位代表的是主机号
为什么要划分子网？ 假设一个网络中的主机为450台，那么分配一个C类地址不够用，分配一个B类地址又很浪费，所以就要划分子网。
子网的定义：把主机地址中的一部分借用为网络位
为了解决IPv4的不足，提高网络划分的灵活性。常用的技术是VLSM(可变长子网掩码)和CIDR(无类别域间路由)
VLSM用于IPv4子网的划分，也就是把一个大的网络划分多个小的子网；而CIDR则用于IPv4子网的聚合，可以把多个小的子网路由汇总成一个大网络的路由条目。
VLSM和CIDR的区别 CIDR是把几个标准网络合成一个大的网络，而VLSM是把一个标准网络分成几个小型网络；
CIDR是子网掩码往左移，VLSM是子网掩码往右移
VLSM（Variable Length Subnet Mask） 比如这是一个公司的电脑数量，市场部有100台电脑，销售部有70台电脑，一般企业中会希望将不同的部门划分成为不同的网段
如果想用c类地址段分别给三个部门划分不同的网段，我们看到需要用到三个c类地址段，我们知道一个c类地址段里就有254个主机地址，而这里用到了三个c类地址段，就造成了ip地址浪费的情况，为了保证ip地址的高利用率，这时候我们用到了vlsm（可变长子网掩码）
1.最多可划分成的网络的个数，n表示要借的主机位位数，2n&gt;=要划分的子网个数,然后取最小值
根据需求，划分两个子网即可，n=1
2.每个子网下的有效主机IP数，m表示主机位的位数，公式为2m-2，本来主机位为32-24=8，但是主机号借了1位给网络号，所以现在的主机位为32-24-1=7，有效主机IP数=2*8-2=126
所以
市场部：网络号为192.168.1.0/25，子网掩码255.255.255.128，可用IP地址访问192.168.1.1~192.168.1.126
销售部：网络号为192.168.1.128/25，子网掩码255.255.255.128，可用IP地址访问192.168.1.129~192.168.1.254
CIDR（Classless Inter-Domain Routing） 看上面这张图，当一台路由器有多个连续子网的时候，它将这些子网通告给其他相邻的路由器时，如果将这些连续子网分别通告，那么对端路由器会收到很多个连续子网的路由条目，我们都知道路由器的转发原理是查表转发，路由表过多就会造成查表速度较慢，这时候我们就用到了CIDR，将多个连续子网汇总成一个汇总路由进行通告。
0000-&gt;1111有16种组合法
例题1
10.100.222.100
255.255.248.0
CIDR表示法：10.100.222.100/21(11111111 11111111 11111000 00000000 前21位都是1，说明IP地址的网络ID位为21位)
netmask（十进制子网掩码）: 255.255.248.0(前26位是网络ID，后6位是主机ID)
主机数多少个？：2^(32-21)-2=2^11-2=2046
网络ID值是什么？网络ID值就是IP与子网掩码相与，10.100.216.0/21
11011110 00000000 10.100.222.100
11111111 11111111 11111000 00000000 255.255.248.0
11011000 00000000 10.100.216.0
公式
1 主机数=2^主机ID位-2
2 网络数=2^可变的网络ID位
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c487a5357421319ccf58361d5944be5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f4c38ed03b09ef75757980109b0e62a/" rel="bookmark">
			超详细Oracle 11g安装步骤（附加Navicat连接以及oracle library is not loaded的问题解决）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		超详细Oracle 11g安装步骤以及oracle library is not loaded的问题解决 前言oracle下载Navicat连接oracle 前言 公司一个内蒙古数据推送项目用的是oracle-&gt;mysql
而此时出了问题，需要我负责解决问题
因此，要搞Oracle，不然无法排查问题
再此，就记录一下重装过程，分享给道友，避免浪费时间。
享受优质模板，进行阅读
oracle下载 官网：下载
百度网盘：下载
1、下载好后进行解压
注意Oracle分成两个文件，下载完后，将两个文件解压到同一目录下即可。
2、到相应的解压路径上面，找到可执行安装文件setup.exe双击安装。如图：
3、win10的系统可能会出现以下问题，无关紧要，放心点击就是
4、安装第一步：配置安全更新，这步可将自己的电子邮件地址填写进去（也可以不填写，只是收到一些没什么用的邮件而已）。取消下面的“我希望通过My Oracle Support接受安全更新(W)”。 如图：
5、安全选项，直接选择默认创建和配置一个数据库(安装完数据库管理软件后，系统会自动创建一个数据库实例)。 如图：
6、系统类，直接选择默认的桌面类就可以了。(若安装到的电脑是，个人笔记本或个人使用的电脑使用此选项) 如图：
7、典型安装。 重要步骤。建议只需要将Oracle基目录放到自己的专有工具dev目录下，目录路径不要含有中文或其它的特殊字符。全局数据库名可以默认，且口令密码，必须要牢记。密码输入时，有提示警告，不符合Oracel建议时不用管。 (因Oracel建议的密码规则比较麻烦， 必须是大写字母加小写字母加数字，而且必须是8位以上。麻烦，可以输入平常自己习惯的短小密码即可) 如图：
我这里是直接以公司的库的密码进行设置，就一点好记~
8、若输入的口令短小简单，安装时会提示不符合Oracle建议的标准。直接确认Y继续安装就是了。
9、概要 安装前的一些相关选择配置信息。 可以保存成文件 或 不保存文件直接点完成即可。如图：
10、安装产品 自动进行，不用管。如图：
11、数据库管理软件文件及dbms文件安装完后，会自动创建安装一个实例数据库默认前面的orcl名称的数据库。如图：
12、实例数据库创建完成了，系统 默认是把所有账户都锁定不可用了(除sys和system账户可用外)
13、安装成功，完成即可.
14、win+R，输入cmd，快速打开命令行窗口
15、判断oracle是否安装成功sqlplus /nolog
16、可以看到本地服务已开启oracle.
Navicat连接oracle 17、连接时可能会出现oracle library is not loaded，这是因为oci.dll路径不对造成的问题
18、打开Navicat Premium程序，打开“工具 - 选项 - 环境 - OCI环境 - OCI library (oci.dll)”，然后将你刚才下载的文件夹中的oci.dll文件的完整目录填上，点击确定。
19、重启Navicat Premium程序进行测试双击oracle数据库，发现现在可以连接了，完成。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f4c38ed03b09ef75757980109b0e62a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e8875c6a4232c6d65811683d1862019/" rel="bookmark">
			Postgis使用工具raster2pgsql导入栅格数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.栅格数据 WorldClim是一个高空间分辨率的全球天气和气候数据的数据库。可以从该网站下载天气数据。网址如下：​​​​​​​https://www.worldclim.org。
下面是12个月份温度统计数据。
2.使用工具gdainfo查询栅格文件信息 &gt;gdalinfo tmax1.bil Driver: EHdr/ESRI .hdr Labelled Files: tmax1.bil tmax1.hdr Size is 2160, 900 Coordinate System is: GEOGCRS["WGS 84", DATUM["World Geodetic System 1984", ELLIPSOID["WGS 84",6378137,298.257223563, LENGTHUNIT["metre",1]]], PRIMEM["Greenwich",0, ANGLEUNIT["degree",0.0174532925199433]], CS[ellipsoidal,2], AXIS["latitude",north, ORDER[1], ANGLEUNIT["degree",0.0174532925199433]], AXIS["longitude",east, ORDER[2], ANGLEUNIT["degree",0.0174532925199433]], ID["EPSG",4326]] Data axis to CRS axis mapping: 2,1 Origin = (-180.000000000000057,90.000000000000000) Pixel Size = (0.166666666666667,-0.166666666666667) Corner Coordinates: Upper Left (-180.0000000, 90.0000000) Lower Left (-180.0000000, -60.0000000) Upper Right ( 180.0000000, 90.0000000) Lower Right ( 180.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e8875c6a4232c6d65811683d1862019/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55b1ff628f5c409d51fcbbb77e5020ee/" rel="bookmark">
			电商搜索场景结构化匹配 使用命名实体识别（NER）&#43;类目预测（意图识别）&#43;bert4keras实现k-bert
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上一篇的文章中电商搜索使用BM25算法召回+其他匹配特征主要讲了BM25算法的召回以及一些特征的融入，本篇继续进行剩余特征如核心词匹配，同义词匹配 ，上下位词，query类目与商品title类目匹配以及商品的业态等特征
整体结构图如下：
示例： 乐事薯片黄瓜 分词： 乐事 薯片 黄瓜 词性：品牌，商品核心词，口位词 这里面 补充一下：
一.分词的话你可以参照 知乎上面的 分词或者命名实体识别融合词典
二.词性匹配要注意 词性消歧义，因为不同的词在不同的商品中可能会有不同的词性，例如山东新鲜黄瓜， 黄瓜味薯片 这里面的黄瓜分别为商品核心词，口位词
具体的做法 当然不局限这些，你都可以尝试：
譬如：
黄瓜薯片 黄瓜为口位词属性
黄瓜茄子组合 黄瓜为商品核心词
基于规则分词处理方法：
1.根据类目信息，假设有分词性中有两个商品核心词a,b ，c为类目信息，要进行过滤
p(a|b,c)=p(a,b,c)/p(b,c)
p(b|a,c)=p(a,b,c)/p(a,c)
比较两个核心词谁是谁的典型
p(a|b,c)&lt;p(b|a,c) 则选取a为核心词否则选取b
2.根据term权重 tfidff,deepct或者其他的
3.相似度模型，可以根据类目预测的模型，或者向量召回的模型 来进行相似度的权重衡量，分别计算不同的term 占原query或者原商品名称的cos值，占比越大可以作为最核心的词
基于模型处理的方法：
1.预训练增加相应的知识 融入类目信息，cls .....sep....sep....sep 分别为 query 商品 类目信息 loss=mlm_loss+quer是否匹配商品 （可以参照美团技术预训练搜索）
2.融入额外知识，k-bert,k-adapter, gcn网络 组合 编造品牌，商品核心词，口位词的图谱关系（spellgcn https://github.com/ACL2020SpellGCN/SpellGCN ）
这里使用k-bert 来实现https://arxiv.org/pdf/1909.07606.pdf
罗列的知识库体系如下：
乐事	类别	品牌 薯片	类别	商品 黄瓜 类别 商品 黄瓜 类别 口位 乐事 售卖 薯片 薯片 属性 黄瓜 可口 竞品 百事 可口 类别 品牌 百事 类别 品牌 可乐 类别 商品 雪碧 类别 商品 巧克力 属性 牛奶味 牛奶味 类别 口味 牛奶 类别 口味 巧克力 类别 商品 法国 售卖 香槟 #本文使用的bert4keras 实现k-bert 将下面的三个函数 粘贴到models.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/55b1ff628f5c409d51fcbbb77e5020ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60a7aa00f8692a9b016ba8e9f2c4e92f/" rel="bookmark">
			实时数仓：基于 Flink CDC 实现 Oracle 数据实时更新到 Kudu
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：于乐，腾讯 CSIG 工程师 解决方案描述 概述 Flink CDC 于 2021 年 11 月 15 日发布了最新版本 2.1，该版本通过引入内置 Debezium 组件，增加了对 Oracle 的支持。本方案主要对 flink-connector-oracle-cdc进行试用。首先在本地对 Oracle CDC 进行调试通过，然后结合腾讯云产品流计算 Oceanus、EMR（Kudu）实现了 Oracle-Oceanus-Kudu 一体化解决方案，其中并无复杂的业务逻辑实现（这里进行最简单的数据转移，用户可根据实际业务情况编写相应代码），并对其中发现的一些问题进行归纳整理与读者分享。
方案架构 这里的 Oracle 数据库环境是通过 Docker 建立在 EMR 集群下的某台 CVM 上，通过手动向 Oracle 数据库写入、更新数据，Oceanus 实时捕获变更的数据后存储在 EMR 的 Kudu 组件上。根据以上方案，设计了如下架构图：
前置准备 创建私有网络 VPC 私有网络（VPC）是一块在腾讯云上自定义的逻辑隔离网络空间，在构建 Oceanus 集群、Redis 组件等服务时选择的网络建议选择同一个 VPC，网络才能互通。否则需要使用对等连接、NAT 网关、VPN 等方式打通网络。私有网络创建步骤请参考 帮助文档 [1]。
创建流计算 Oceanus 集群 流计算 Oceanus 是大数据产品生态体系的实时化分析利器，是基于 Apache Flink 构建的具备一站开发、无缝连接、亚秒延时、低廉成本、安全稳定等特点的企业级实时大数据分析平台。流计算 Oceanus 以实现企业数据价值最大化为目标，加速企业实时化数字化的建设进程。
在 Oceanus 控制台的【集群管理】-&gt;【新建集群】页面创建集群，选择地域、可用区、VPC、日志、存储，设置初始密码等。VPC 及子网使用刚刚创建好的网络。创建完后 Oceanus 的集群如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60a7aa00f8692a9b016ba8e9f2c4e92f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/765d91b261e1be19195fefbf30674eed/" rel="bookmark">
			Docker 安装 MySQL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Docker 安装 Mysql docker run --name mysql5.7 -p 3306:3306 -v /data/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=密码 -d mysql:5.7 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0cb3af80046e8d098990b47b7f0e852c/" rel="bookmark">
			RuntimeError:The size of tensor a (100) must match the size of tensor b (12800) at non-singleton di
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：维度不对应，一个第一维是1，另一个第一维是128
解决：往前追溯，发现问题根源，使用repeat将其改为128维：
注意：这里要使用.size()将其改为128维，而不能直接写128，负责运行几轮后便会报错。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ba579c14d4ce8d1a09c73bef89867a3/" rel="bookmark">
			【直流电机H桥的三种驱动方式：受限单机模式，单极模式，双极模式】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、引出
1、简单的开关串联电机只能控制有刷直流电机的启停，要同时控制正反转和转速就要引入H桥式控制电路。
2、对4个开关管的控制采用PWM，调节占空比可以实现调速。PWM频率一般在10KHz到20KHz之间，频率太低会导致电机转速过低，噪声较大。频率太高，会因为MOS管的开关损耗而降低效率。
3、根据对桥臂上MOS的PWM控制方式不同，分为三种控制模式：受限单极模式、单极模式、双极模式。
二、受限单极模式
电机电枢驱动电压极性是单一的。需要对一个MOS控制PWM控制。
优点：控制方式简单。
缺点：不能刹车，不能能耗制动，在负载超过设定速度时不能提供反向力矩。调速静差大，调速性能很差，稳定性也不好。
三、单极模式
电机电枢驱动电压极性是单一的。需要对同一侧桥臂的两个MOS管进行互补PWM控制。要使用高级定时器的互补通道进行控制。
优点：启动快，能加速，刹车，能耗制动，能量反馈，调速性能不如双极模式好，但是相差不多，电机特性也比较好。在负载超速时也能提供反向力矩。
缺点：刹车时，不能减速到0，速度接近0时没有制动力。不能突然倒转。动态性能不好，调速静差稍大。
控制过程：MOS管1和2由一对互补PWM进行控制，当1为高电平时，由VCC-1-Motor-4-GND形成通路，电机电流上升。当1为低电平时，2变为高电平，根据楞次定律，当不再给电机供电，线圈中存在自感电动势，电流继续往同一方向流动，于是由2-Motor-4形成通路，给线圈电流继续提供通路。
1.4导通 2.4导通 绿控制；红电流；蓝电压 四、双极模式
电枢电压极性是正负交替的。需要两组互补PWM同时对4个MOS管进行控制。
优点：能正反转运行，启动快，调速精度高，动态性能好，调速静差小，调速范围大，能加速，减速，刹车，倒转，能在负载超过设定速度时提供反向力矩，能克服电机轴承的静态摩擦力，产生非常低的转速。
缺点：控制电机复杂，在工作期间，4个MOS管都处于开关状态，功耗大。
控制过程：1和4同时处于PWM的高电平，于是由VCC-1-Motor-4-GND形成通路，电流上升。当1和4同时变为低电平，2和3相应变为高电平，因为楞次定律，线圈上的电流方向不变，于是由GND-2-Motor-3-VCC形成通路，虽然存在反向的供电电压，但是电机的线圈电流更大，于是电流仍然向VCC流动，同时电流下降的更快，线圈电流波动也更大。
1.4导通 2.4导通 绿控制；红电流；蓝电压 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/291/">«</a>
	<span class="pagination__item pagination__item--current">292/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/293/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>