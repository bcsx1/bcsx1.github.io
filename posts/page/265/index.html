<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7934ba843b84fd3fdb2c593073d8f57/" rel="bookmark">
			使用C#编写MVC登录页面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在编写项目时，编写了一部分关于登录页面的一些代码，现在和大家分享一下。
上图是本篇文章所要实现的样式和效果，可以更换身份，点击登录时跳转到主页面。
第一步先判断用户ID是否为空，如果不为空就跳转到登录页面。 public ActionResult Main() { // 读取session中的用户信息 if (Session["UserID"] == null) { return Redirect("/Main/Login"); } return View(); } 2.下面代码是登录页面的样式代码 （1）所要引入的文件 &lt;head&gt; &lt;meta name="viewport" content="width=device-width" /&gt; &lt;title&gt;登录&lt;/title&gt; &lt;link href="~/Plugins/bootstrap-4.6.0/dist/css/bootstrap.min.css" rel="stylesheet" /&gt; &lt;link href="~/Content/css/login.css" rel="stylesheet" /&gt; &lt;link rel="icon" type="image/png" sizes="16x16" href="~/Content/images/logo.ico"&gt; &lt;/head&gt; （2）body的样式代码 &lt;div class="container-fluid"&gt; &lt;div class="row"&gt; &lt;div class="col-sm-8 offset-sm-2 col-md-8 offset-md-2 col-lg-6 offset-lg-3 login"&gt; &lt;div class="card border-info"&gt; &lt;div class="card-body"&gt; &lt;form action="/" method="post" id="fmLogin"&gt; &lt;div class="form-group row"&gt; &lt;label for="UserName" class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f7934ba843b84fd3fdb2c593073d8f57/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd02871351ed066c982e63adc597ecb0/" rel="bookmark">
			vuex之五大属性相关使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.vuex的五大属性：state, getters, mutations, actions, modules
(1）state：vuex的基本数据，用来存储变量
state是放置所有公共状态的属性，如果你有一个公共状态 ， 你只需要定义在 state对象中
(2). getter：从基本数据(state)派生的数据，相当于state的计算属性,具有返回值的方法:
除了state之外，有时我们还需要从state中派生出一些状态，这些状态是依赖state的，此时会用到getters（可以使用 getters 来获取 state 中的数据）自己总结：相当于是 state 的计算属性
3. mutation：提交更新数据的方法，必须是同步的(如果需要异步使用action)。每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。
state数据的修改只能通过mutations，并且mutations必须是同步更新，目的是形成数据快照
数据快照：一次mutation的执行，立刻得到一种视图状态，因为是立刻，所以必须是同步
mutations是一个对象，对象中存放修改state的方法
4. action：和mutation的功能大致相同，不同之处在于 ==》1. Action 提交的是 mutation，而不是直接变更状态。 2. Action 可以包含任意异步操作。
actions则负责进行异步操作，处理的结果交给 muations
方式一：原始调用 - $store;
方式二：辅助函数 - mapActions ----&gt;第一步：导入mapActions;第二步：利用扩展运算符将导出的 actions 映射给 methods
5. modules：模块化vuex，可以让每一个模块拥有自己的state、mutation、action、getters,使得结构非常清晰，方便管理。
简单来说就是可以把以上的 state、mutation、action、getters 整合成一个user.js,然后放到store.js里面
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16a4ce556ca94f9711d85eb5403cb676/" rel="bookmark">
			【路径规划】全局路径规划算法——蚁群算法（含python实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 参考资料1. 简介2. 基本思想3. 算法精讲4. 算法步骤5. python实现 参考资料 路径规划与轨迹跟踪系列算法蚁群算法原理及其实现蚁群算法详解（含例程）图说蚁群算法(ACO)附源码蚁群算法Python实现 1. 简介 蚁群算法（Ant Colony Algorithm, ACO） 于1991年首次提出，该算法模拟了自然界中蚂蚁的觅食行为。蚂蚁在寻找食物源时， 会在其经过的路径上释放一种信息素，并能够感知其它蚂蚁释放的信息素。 信息素浓度的大小表征路径的远近， 信息素浓度越高， 表示对应的路径距离越短。通常， 蚂蚁会以较大的概率优先选择信息素浓度较高的路径， 并释放一定量的信息素， 以增强该条路径上的信息素浓度， 这样，会形成一个正反馈。 最终， 蚂蚁能够找到一条从巢穴到食物源的最佳路径， 即距离最短。
2. 基本思想 用蚂蚁的行走路径表示待优化问题的可行解， 整个蚂蚁群体的所有路径构成待优化问题的解空间。路径较短的蚂蚁释放的信息素量较多， 随着时间的推进， 较短的路径上累积的信息素浓度逐渐增高， 选择该路径的蚂蚁个数也愈来愈多。最终， 整个蚂蚁会在正反馈的作用下集中到最佳的路径上， 此时对应的便是待优化问题的最优解。 3. 算法精讲 不失一般性，我们定义一个具有N个节点的有权图 G = ( N , A ) G=(N,A) G=(N,A)，其中N表示节点集合 N = 1 , 2 , . . . , n N={1,2,...,n} N=1,2,...,n，A表示边， A = ( i , j ) ∣ i , j ∈ N A={(i,j)|i,j\in N} A=(i,j)∣i,j∈N。节点之间的距离（权重）设为 ( d i j ) n × n (d_{ij})_{n\times n} (dij​)n×n​，目标函数即最小化起点到终点的距离之和。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/16a4ce556ca94f9711d85eb5403cb676/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a15ac9477ca5634eda84fd6746c82945/" rel="bookmark">
			SnowFlake雪花算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SnowFlake算法生成id的结果是一个64bit大小的整数
1、1bit不用，因为二进制中最高位是符号位，1表示负数，0表示正数。生成的id一般都是用整数，所以最高位固定为0。
2、41bit时间戳，毫秒级。可以表示的数值范围是 （2^41-1），转换成单位年则是69年。
3、10bit工作机器ID，用来表示工作机器的ID，包括5位datacenterId和5位workerId。
4、12bit序列号，用来记录同毫秒内产生的不同id，12位可以表示的最大整数为4095，来表示同一机器同一时间截（毫秒)内产生的4095个ID序号。
public class IdWorker{ //下面两个每个5位，加起来就是10位的工作机器id private long workerId; //工作id private long dataCenterId; //数据id //12位的序列号 private long sequence; /**通过外部传入机器 workerId 和 dataCenterId * @param workerId * @param dataCenterId */ public IdWorker(long workerId, long dataCenterId){ //workerId可以获取机器IP，然后对机器数取余 //dataCenterId可以设置个随机数 // sanity check for workerId if (workerId &gt; maxWorkerId || workerId &lt; 0) { throw new IllegalArgumentException(String.format("worker Id can't be greater than %d or less than 0",maxWorkerId)); } if (dataCenterId &gt; maxDataCenterId || dataCenterId &lt; 0) { throw new IllegalArgumentException(String.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a15ac9477ca5634eda84fd6746c82945/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30138850edc7846d1d9b0592ea5b79e4/" rel="bookmark">
			【软件使用】使用MobaXterm的时候出现 Network error: Software caused connection abort错误解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、问题描述二、解决方案三、总结四、引用参考 一、问题描述 我们都知道MobaXterm是一款极为强大的全能型终端神器。但作为一个新手，笔者在使用MobaXterm连接到远程服务器时，经常遇到Network error: Software caused connection abort的提示。即如果隔一段时间不进行操作的话，会出现中断连接的现象。
为了解决这个问题，即让连接始终处于活跃状态，我们可以在设置里设置一下，就可以解决长时间无操作造成的服务器连接中止问题了。
二、解决方案 参见以下步骤。
打开菜单栏设置→配置
如果你的MobaXterm是英文版，对应关系就是菜单栏的“Settings”和“Configuration”。
点击SSH，勾选SSH保持连接（英文SSH keepalive），就不会出现Network error: Software caused connection abort问题了
三、总结 小问题，小意思，小进步。
如果本文能给你带来帮助的话，点个赞鼓励一下作者吧！😁
四、引用参考 [1] 因特耐特
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26401fd45fd6887c345219e7bd4054c1/" rel="bookmark">
			PyQt与Pyside2代码移植冲突
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TypeError: QOpenGLWidget(parent: QWidget = None, flags: Union[Qt.WindowFlags, Qt.WindowType] = Qt.WindowFlags()): argument 1 has unexpected type 'PySide2.QtWidgets.QFrame'
这个错误来自于自己将代码从工作电脑copy到个人电脑，然后出现的错误，因为整个开发过是在工作机上完成的，所以工作机并没有出现任何错误。
后来翻阅了相关资料，并没有找到合适的答案，通过解析这段报错信息，发现是窗体继承中的问题。
因为是用pyside2和pyqtgraph开发的，然后自己的电脑中是装有pyqt5的，于是把电脑中PyQt5给卸载了，然后发现问题解决，但是还有一部分代码在运行时会显示错误，等解决了再来补充。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7a3da6cdeb6a32e382e205bb08198eb/" rel="bookmark">
			使用make方法创建slice切片的坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先查看下面的代码
package main import "fmt" func main() { ints := make([]int, 3) ints = append(ints, 1) fmt.Println(ints) } 打印的结果是
[0 0 0 1] 因为使用 内置函数 make([]type, len) 创建slice 时 len参数视为初始长度,会自动初始化,这里我们使用的类型是int,所以初始化值为0 ,如果是指针类型 则初始化值为nil。
并不是我一开始设想的只是给slice一个内置的长度 ,后添加的元素会自动从0开始,这个坑主要是我使用java List的思想套入了golang中。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e12b1386071059a6af4304f3db7ece64/" rel="bookmark">
			matlab如何导入大量数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在处理大量数据时，把数据导入程序是个前提。在matlab中导入数据有很多种方法，可以使用函数，当然，还可以使用下面的方法，更加简单，更加明了。
没错，就是这个：导入数据。
点击这个按钮，会打开文件窗口，选择所要导入的数据文件，一般为excel,csv等等。
等待几秒，会到这个页面。
这是我们发现，数据已经存在了。同时，我们可以看到列矢量，数值矩阵，元胞数组等等，这些是可选的数据格式，一般选择数值矩阵，然后重命名数据，得到下图
最后，点击导入所选内容。于是一个名为data的数据就存在于工作区了。
这时，就可以使用数据了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f8116ace1b566f8957b73c5f93108be/" rel="bookmark">
			WSL Ubuntu 20.04下Android源码编译与导入Android Studio
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		源码下载见前文：WSL Ubuntu 20.04下Android源码下载
idegen 模块编译 在development/tools/idegen/README下可以看到关于 idegen 工具的相关说明。
在编译之前请先apt-get一下make工具。
初始化编译环境 先cd进源码的根目录，随后初始化环境变量。
source build/envsetup.sh 生成 idegen.jar 参考教程：android studio 调试 framework 层代码
如果之前没有进行过编译建议使用make命令，android 是基于 Android.mk（类似 makefile） 进行构建编译的，这个命令会遍历所有的模块找到 idegen 的 Android.mk,，然后计算所有的依赖的库，如果依赖库没有编译会先编译所有的依赖库，所以 make 编译时较慢。
make idegen -j6 # 六核编译 idegen 模块 如果之前已经对整个系统进行过编译，此处使用mmm命令，用于生成idegen.jar。
mmm development/tools/idegen/ m：编译所有的模块
mm：编译当前目录下的模块，当前目录下要有Android.mk文件
mmm：编译指定路径下的模块，指定路径下要有Android.mk文件
注意：
请务必将源码下载到 wsl 的文件系统中编译，不然会报操作不支持的错误： Failed to listen for path logs: listen unix out/.path_interposer_log: bind: operation not supported 请务必使用 wsl2，不然会报更加让人摸不着头脑的错： Failed to listen for path logs: listen unix out/.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f8116ace1b566f8957b73c5f93108be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44a9329bc82106e9609099bf8146e65d/" rel="bookmark">
			QuSim_10.7c_win32安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装原因：32位可以配合debuusy查看波形。64位的不行，只能再moelsim里面看波形
安装说明：
1.安装包
上图红框位win32的安装包，蓝框所示为破解工具
2.安装步骤
（1）首先双击安装exe应用程序“questasim-win32-10.7c.exe”
（2）选择安装路径：
（3）等待安装完成。
（4）完成后，“Install Hardware Security Key Driver”选择“否”
（5）选择“exit”关掉 “License Wizard”。
（6）解压crack文件得到下述文件，复制exe和bat到questasim安装目录下的win64文件下中。
本次为如下目录：
（7）运行该win32下刚才复制的“patch_dll.bat”文件，生成新的LICENSE.TXT文件后，继续存在该文件目录下：
（8）设置环境变量：
右键：“我的电脑”，选择“属性”，点开“高级系统设置”，选择“环境变量”；
在"环境变量"设置界面选择：
（9）以上配置完成之后，打开界面如下：
安装完成。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa08e93fb1f5e2031221074b0bcd207d/" rel="bookmark">
			HbuildX打h5包/web2app包注意事项
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#HBuild打h5包/web2app包注意事项
1.资源文件必须是相对路径
例如vue.config.js
module.exports = { publicPath: process.env.VUE_APP_PACKAGE === 'app' ? './' : '/',//可能其他发版还是用绝对路径,可以写个三元表达式 } 2.如果涉及路由,必须是单机支持的类型,例如:vue中,不能是用history,必须用hash模式
new Router({ mode: process.env.VUE_APP_PACKAGE === 'app' ? 'hash' : 'history', // require }) 3.如果用真机调试,必须打基座包
4.如果Hbuild编译调试无法认到真机,通常是权限问题,多插拔几次,选到文件传输模式,并启用开发者选项
5.认不到真机可以先用基座包安装一次,然后打开基座包的app再插拔usb线,然后就能看到真机选项
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6315499eedffd2cdadb991dbf78f289/" rel="bookmark">
			利用sortablejs对elementui中的table进行拖拽排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Sortable.js是一款优秀的js拖拽库，支持ie9及以上版本ie浏览器和现代浏览器，也可以运行在移动触摸设备中。不依赖jQuery。支持 Meteor、AngularJS、React、Vue、Knockout框架和任何CSS库，如Bootstrap、Element UI。你可以用来拖拽div、table等元素，特点：体积小、功能强大。
官方Demo：SortableJS
Sortable.js可以实现同组内上下拖动元素，也可以实现不同组内互相拖动元素。这里主要说的是组内上下拖动的情况
一.安装
npm i sortablejs -S
二.引用
引用：在需要用到Sortable的 *.vue 中的script部分引用。也可以在main.js中入注册到Vue的根实例中
import Sortable from 'sortablejs'
三.使用
methods: { //拖拽排序处理 rowDrop() { const el = this.$refs.equipTable.$el.querySelectorAll('.el-table__body-wrapper &gt; table &gt; tbody')[0] let _this = this this.sortable = Sortable.create(el, { ghostClass: 'sortable-ghost', setData: function(dataTransfer) { dataTransfer.setData('Text', '') }, onEnd({ newIndex, oldIndex }) { console.log('TabsTreeTable -&gt; onEnd -&gt; newIndex, oldIndex', newIndex, oldIndex); let tableData = _.cloneDeep(_this.tableData); //交换处理 const newOrderId = tableData[newIndex].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6315499eedffd2cdadb991dbf78f289/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c03b1a430fdfec59978797677a1946d9/" rel="bookmark">
			阿里P6和P7待遇差别有多大
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对阿里巴巴来说，对于技术岗阿里内部将员工一共分为了14个等级，其中P1、P2是一般空缺，是为非常低端岗位预留的，P3是助理，P4是初级专员，P5是高级工程师，P6是资深工程师，P7是技术专家，P8是高级专家，P9是资深专家，P10是研究员，P11是高级研究员，P12是科学家，P13是首席科学家，P14就是马云了。
对于管理岗就是基础等级分为5级，从P6开始对应待遇和M1相同，P7对应M2，P8对于M3，P9对应M4，P10对应M5，M5之后就属于董事会成员，工资标准就不能按常理划分。
阿里的等级制度是和工资挂钩的，一般P4年薪大概是10-15w，P5大概15-20万，但是到了P6和P7就是一个分水岭了，因为P6是最接近P7的不持股员工，P7开始就是持股员工，由于有股票分红，所以工资不能按常理计算。那么，阿里巴巴P6和P7待遇差别有多大？
一位网友表示：干的活差不多，工资差很多，P7的待遇是P6的两倍。要知道P6员工一般的年薪在40-50w，如果两倍的话那就是P7年薪在80-100w，这待遇着实是让人眼红了，毕竟仅仅相差一级，待遇却是一个天上一个地上。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55977b5f135bd4274ac7bb8e3d90f7bd/" rel="bookmark">
			c&#43;&#43;的库文件头文件理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		c++的库文件头文件理解 一、库的概念理解二、编写头文件参考： 一、库的概念理解 概念
我们知道C++工程在编译时，含有main()函数的文件会被生成可执行程序。而那些不含main()函数的代码，编译后一般是被其他程序调用，因此我们可以把他们打包成一个“东西”,即为库(Library)。
库一般是许多程序和算法的集合，例如openCV库包含了很多计算机视觉相关算法，Eigen库提供了很多矩阵代数计算的算法。
库的编写
在该文件夹中新建如下的libHelloWorld.cpp文件：
//不含main()函数的库文件 #include &lt;iostream&gt; using namespace std; void printHello() { cout &lt;&lt; "Hello world!"&lt;&lt; endl; } void printHelloSLAM()	{ cout &lt;&lt; "Hello SLAM!"&lt;&lt; endl; } 库的分类：
静态库的代码在编译过程中已经被载入可执行程序，因此生成的可执行程序体积较大。静态用.a为后缀， 例如生成静态库：add_library( hello libHelloWorld.cpp )输出： hello.a 共享库(动态库)的代码是在可执行程序运行时才载入内存的，在编译过程中仅简单的引用，因此生成的可执行程序代码体积较小。 例如生成静态库：add_library( hello_shared SHARED libHelloWorld.cpp )输出： hello_shared.so
二、编写头文件 为什么要编写头文件？
库文件是一个压缩包，里面有编译好的二进制函数，如果仅有.a或者.so库文件，那么我们并不知道里面的函数是什么，调用的形式三怎样的。为了让别人使用这个库，我们需要一个头文件，说明这个库里都包含了什么。因此只要拿到了头文件和库文件，就可以调用这个库。
举例
编写头文件，libHelloWorld.h头文件
#ifndef LIBHELLOWORLD_H_ #define LIBHELLOWORLD_H_ //进行宏定义时为了防止重复引用头文件而引起重定义错误 void printHello(); //声明包含的库函数 void printHelloSLAM(); #endif 编写主函数，useHello.cpp主文件
#include "libHelloWorld.h" //声明头文件 int main() { printHello(); return 0; } 主函数和库文件链接起来，cmake
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/55977b5f135bd4274ac7bb8e3d90f7bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2498fb5164c5532b6b434ce0582aa5f/" rel="bookmark">
			SVN账号密码查找
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、根据路径找到svn.simple
C:\Users\Administrator\AppData\Roaming\Subversion\auth\svn.simple
2、执行 TSvnPwd.exe 查看用户名，密码
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5fd59919bd443ac8a12c585e5a3c9f9e/" rel="bookmark">
			websocket 详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. websocket 是什么？ websocket 是一种网络通信协议，与 http 语义一样，但功能不一样
http 也是一种网络通信协议，为什么不用 http 而用 websocket ?
2. websocket 与 http 有什么区别？ websocket 通信可由服务器发起，也可以由客户端发起。可以实现客户端与服务端长连接
http 通信只能由客户端发起。
举个例子：
websocket 像是面试，你可以询问面试官问题，面试官也可以问你问题，属于双向平等对话。
http 更像是查询银行卡余额的操作，只会返回给你结果。
3. websocket 其他特点： 建立在 TCP 协议之上，在服务端上实现比较容易跟 http 协议有着良好的兼容性，默认端口也是 80 和 443，并且 握手阶段采用 http 协议，因为握手时不容易屏蔽，能通过各种 http 代理服务器。数据格式比较轻量，性能开销小，通信高效。可以发送文本或二进制数据（blob 对象与 Arraybuffer 对象）没有同源限制，客户端可以与任意服务器通信。协议标识符为：ws ( ws-不加密，wss-加密 ) ，服务器网址：ws://example.com:80/some/path 4. websocket 用法： // 1. 新建 WebSocket 实例, 客户端就会与服务器进行连接 // WebSocket() 会 return 一个 object. const ws = new WebSocket("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5fd59919bd443ac8a12c585e5a3c9f9e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c67a9ba997a7d744e2efb04e521a232/" rel="bookmark">
			java.time包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 在JDK1.0中，Date类是唯一的一个代表时间的类，但是由于Date类不便于实现国际化，所以从JDK1.1版本开始，使用Calendar类进行时间和日期处理。实际应用中，使用joda-time比较多（Java7以前），所以从Java8开始有了从joda改进的java.time包。
Date-Time API 由主包 java.time 和四个子包组成：
包名描述java.time表示日期和时间的 API 的核心。它包括日期、时间、日期&amp;时间相结合的类别， 时区/zones，瞬间/instants，持续时间/duration 和 时钟/clocks。这些类基于 ISO-8601 中定义的日历系统， 并且不可变且线程安全。java.time.chrono用于表示除默认 ISO-8601 以外的日历系统的 API。您也可以定义自己的日历系统。本教程不包含任何细节。java.time.format用于格式化和分析日期和时间的类。java.time.temporal扩展 API 主要用于框架和库编写器，允许日期和时间类之间的互操作，查询和调整。字段（TemporalField 和 ChronoField） 和单位（TemporalUnit 和 ChronoUnit）在此包中定义。java.time.zone支持时区的类，时区的偏移和时区规则。如果使用时区，大多数开发人员只需使用 ZonedDateTime 和 ZoneId 或 ZoneOffse ​​​​​​
常用类 类名描述Instant 本质上是一个时间戳LocalDate 存储了日期，如：2010-12-03。可以用来存储生日LocalTime 存储了时间，如：11:30LocalDateTime 存储了日期和时间，如：2010-12-03T11:30ZonedDateTime 存储一个带时区的日期和时间 方法前缀概览 java.time包的API提供了大量相关的方法，这些方法一般有一致的方法前缀
前缀名称功能例子of静态工厂方法DateTimeFormatter.ofPattern("yyyy年MM月d日"))parse静态工厂方法，关注于解析get获取值is用于比较with不可变的setter等价物plus加一些量到某个对象plusMonths(1)minus从某个对象减去一些量minusMonths(1)to转换到另一个类型at把这个对象与另一个对象组合起来，例如date.atTime(time) //获取当前日期时间 LocalDateTime localDateTime = LocalDateTime.now(); System.out.println("localDateTime :" + localDateTime); //格式化输出时间，线程安全的格式化类 DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern("yyyy年MM月d日 hh:mm:ss"); System.out.println("format :" + dateTimeFormatter.format(localDateTime)); // 获取当前年份 Year year = Year.of(2019); System.out.println("year :" + year); // 从Year获取LocalDate LocalDate localDate = year.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c67a9ba997a7d744e2efb04e521a232/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c8e1dd4e094941355ab99cc4d37c850/" rel="bookmark">
			golang数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先说明下Golang中的Slice与数组区别，数组是一种具有固定长度的基本数据结构，一旦创建了它的长度就不允许改变,空余位置用0填补,不允许越界；在golang中有数组和Slice两种数据结构，Slice是基于数组的实现，是长度动态不固定的数据结构，本质上是一个对数组字序列的引用，提供了对数组的轻量级访问。所以以下内容主说明其实是Slice
区别对比 数组slice 长度固定可变元素类型单一固定构成部分一系列元素指针、长度(len)、和容量(cap)（底层引用一个数组对象）指针指向指向数组的第一个元素地址指向第一个slice元素对应的底层数组元素的地址,要注意的是slice的第一个元素并不一定就是数组的第一个元素初始化默认值是零值，需要初始化长度默认值是零值，不需要初始化长度 先上一小小段示例代码：
func main() { data := []int{0, 1, 2, 3, 4} s := data[:2:2] s[0] = 100 s = append(s, 100, 200) fmt.Println(cap(s)) fmt.Println(s, data) ints := []int{0, 1, 2, 3, 4} t := ints[:2] fmt.Println(cap(t)) t = append(t, 100, 200, 300) fmt.Println(t, ints) t = append(t, 400, 500, 600) fmt.Println(cap(t)) t[0] = 700 fmt.Println(t, ints) } data := []int{0, 1, 2, 3, 4}
截取data前两位，并对s设置容量为2，（左开位:右避位:容量）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c8e1dd4e094941355ab99cc4d37c850/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e069f37ed8ff4f40058ff80ad9c8ff1d/" rel="bookmark">
			HTTPS配置说明文档（tomcat）与HTTPS协议请求出现证书不信任问题（ PKIX PATH BUILDING FAILED）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.简介 该文章是自己在项目过程中遇到tomcat配置证书的问题而写的，我也是搞了好久才解决这个问题，每个人遇到的文革都可能大不相同，只是希望能给各位一些参考，本篇文章由以下几位前辈的文章总结而来，详细请自行查看
（1）为了成功配置https,你需要具备以下环境:
java jdk
tomcat
（2）SSL证书简介
要想使用https,首先,我们需要有SSL证书,证书可以通过两个渠道获得:
公开可信认证机构
例如CA,但是申请一般是收费的,一般几百到几千一年.
自己生成
虽然安全性不是那么高,但胜在成本低.
目前证书有以下常用文件格式：JKS(.keystore)，微软(.pfx)，PEM(.key + .crt)。其中,tomcat使用JKS格式,nginx使用PEM格式.
下面讲解的是JKS格式.
1.创建tomcat证书 （1）1、使用jdk自带的keytool.ext生成证书，进入jdk下bin目录；
（2)在路径栏输入cmd——回车打开dos命令窗口，打开之后当前路径为jdk下bin目录
ps：也可直接win+R打开dos命令窗口再进入jdk下bin目录
（3） 使用keytool命令创建tomcat证书
keytool -genkeypair -alias “tomcat” -keyalg “RSA” -keystore “D:\ProgramTools\tomcatkey\tomcat.keystore” -validity 36500 alias: 别名 这里起名tomcat
keyalg: 证书算法，RSA
证书文件名称是tomcat.keystore ；“-validity 36500”含义是证书有效期，36500表示100年，默认值是90天
keystore：证书生成的目标路径和文件名,替换成你自己的路径即可,我定义的是D:\ProgramTools\tomcatkey\tomcat.keystore
在命令行填写必要参数：
A、 输入keystore密码：此处需要输入大于6个字符的字符串。
B、 “您的名字与姓氏是什么？”这是必填项，并且必须是TOMCAT部署主机的域名或者IP[如：gbcom.com 或者 10.1.25.251]（就是你将来要在浏览器中输入的访问地址），否则浏览器会弹出警告窗口，提示用户证书与所在域不匹配。在本地做开发测试时，应填入“localhost”。（这块很重要）
C、 你的组织单位名称是什么？”、“您的组织名称是什么？”、“您所在城市或区域名称是什么？”、“您所在的州或者省份名称是什么？”、“该单位的两字母国家代码是什么？”可以按照需要填写也可以不填写直接回车，在系统询问“正确吗？”时，对照输入信息，如果符合要求则使用键盘输入字母“y”，否则输入“n”重新填写上面的信息。
D、 输入的主密码，这项较为重要，会在tomcat配置文件中使用，建议输入与keystore的密码一致，设置其它密码也可以，完成上述输入后，直接回车则在你在第二步中定义的位置找到生成的文件。
2.配置tomcat服务器 （1）打开tomcat的server.xml配置文件，这里我使用的开发工具是eclipse，所以直接在项目路径下找到
可以直接通过查找关键字Http11NioProtocol，进行修改，该内容默认是被注释掉的
https协议默认端口号为443，可根据自身业务修改端口号，keystorePass为生成证书时所设置的密码
修改为
&lt;Connector port="8443" protocol="org.apache.coyote.http11.Http11NioProtocol" maxThreads="150" SSLEnabled="true" scheme="https" secure="true" clientAuth="false" sslProtocol="TLS" keystoreFile="D:\ProgramTools\tomcatkey\tomcat.keystore" keystorePass="123456" /&gt; port: https的端口,默认8443
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e069f37ed8ff4f40058ff80ad9c8ff1d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1280d2d3a74aaab150ab01b1280a4542/" rel="bookmark">
			观后感《没事别看哲学书！》
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		观后感《没事别看哲学书！》 前言 有点东西，开始只是对这个标题感兴趣，没想到不知不觉就看完了。
《没事别看哲学书！有钱人就快乐吗？朋友分手的原因》2022年5月22日发布的。
里面的观点很有意思，可以借鉴。
文章目录 观后感《没事别看哲学书！》前言内容笔记视频中的评论我的观点 结论 内容 笔记 哲学书普通人可以看，但不能看太多，为什么呢？
你觉得世界上最快乐的人是谁？是不是那些有钱人！不是，也许有钱人的快乐我们体会不到，那些有钱人的痛苦我们也体会不到。
这里面有一个微观经济学（消费者理论研究）中提到的概念：边际效用
比如说吃包子，吃第一个包子感觉这包子不错，但吃到第八个包子的时候，就会边际递减，觉得这包子也就那样。
一、物质层面
有钱人也一样，当赚了200万的时候，会觉得200万很多，自己很满足，当他有2个亿的时候，赚200万会觉得也就这样，不过如果失去这200万，他不会为自己还有1.08亿而满足，反而会有失去的恐惧感。
做视频也一样，当一夜之间增加了20万粉丝，会很兴奋，但是当up主有2000万粉丝的时候，多20万粉丝会觉得也就这样。玩游戏也这样，当没通过的时候，打一遍快乐一次，通过后就索然无味。愉悦程度会随时间增长的曲线一直下降。明星也一样，当有2000万粉丝的时候，增加20万粉丝会觉得也就这样，这个时候会产生新的需求。
人类永远都会追逐稀缺性。
对有钱人来说，钱不是稀缺性的时候，会有新的稀缺性的东西让他们追求，如健康。这样会有求而不得的痛苦，失去的痛苦。
快乐的人就是处在确定性的慢慢增长状态里的人。
一开始可以不用很多，但是你只要一直在增长，有希望就行。
二、精神层面
up主有个朋友，从小特别喜欢看哲学，结果看魔怔了。
他妈妈对他说现在的小孩很富足，他说没用，他失去了自由。人生犹如打游戏，从小学到初中，初中到高中，高中到大学，然后毕业，仿佛从一个副本到另外一个副本，游走与每个NPC之间，做任务，然后获得奖励，循环往复。最后他妈说那中午别吃了，到了晚上，问他要吃饭还是要自由，这时候他选择了吃饭。
谈恋爱的时候也是这样，女朋友问他喜欢自己吗？他说不喜欢，巴拉巴拉；最后他女朋友说他搞精神分析的傻X，最后和他分手，她女朋友是学心理学的。
最后他朋友和他打电话，聊安慰，然后扯到了存在的意义上。
最后结论就是：哲学少看，或者社会科学的书少看，可以看，但不能看太多，看太多，懂太多，但是它还不能对你实际生活起到改善作用，学的东西会无用武之地，那么你会很容易陷入到一种跟现实脱节、对抗、不理解的一种心里特别难受的状态。如果你看的理论还是互相矛盾的那种，那就更难受了，你越察觉世界上可能根本不存在客观的真相，你就越会崩溃，它跟你的快乐没有关系。
不要在年轻的时候就把这方面的阈值拉太高，要让它慢慢增长。
视频中的评论 评论一：怂罗不怂
对于这个我可他妈太有发言权了。因为过去一两年不停看社科哲学类的书，我魔怔的和视频里那个兄弟基本可以说一模一样了。我他妈一个学理工科的，感觉陷到里面就完全拔不出来了，很长时间和人说话的能力都丧失了，脑子里想的东西有时候会莫名其妙让自己亢奋起来，又莫名其妙消沉下去，然后怀疑自己，同时生活中减少掉很多很多乐趣。可是在这种挣扎中，我做的就是接着买书，不停地买书，从西哲史看到理想国系列出版的那一类社科，快走火入魔的时候，康德救了我。说是康德救了我，是因为他的书我确实看的蛋疼读不下去，三大批判一本都没读完。
但是买书这个习惯是停不下来，只是转到看小说了。黑塞，加缪，卡夫卡，陀思妥耶夫斯基这些人的代表作我都去买，去看。但是你别说还真有点用，黑塞的德米安和悉达多让我重新燃起了一丝对生活向往的火苗。托翁的卡拉马佐夫兄弟让我不再那么逆反与愤怒，加缪的鼠疫又让我看到了自己的局限。中途我记得还买过尤利西斯，但弃坑了。这些文学作品的能量在很大程度上吞噬了我心中很多的无知与黑暗。
读太多社科与哲学会莫名其妙让人自大，自以为自己具有了俯首众人的姿态，但本质上太多这一类书都有太强的方向性，我们不一定能获得很多知识，但非常容易被携带着走向极端。在读了这么多以后我静下来思考，发现自己是被裹挟着服从或者说跪拜在了他们的脚下，当观点矛盾冲突时，其实我们心里早已变成了某种主义的信奉者，然后才去觉得该去相信谁，如果实在解决不了，那就再引入一个可做衡量的尺度。到这个时候，已经不再是研究与讨论，而是把很多简单的东西复杂化了，自己也在某种程度上和宗教信徒没什么差别。不是说这一类书不好，只是说伟大的思想本身和艺术品很像，但生活不是如此。你不需要去解构光线与线条，不需要精雕细琢反复考量，它在你的视网膜上成什么像，那它就是什么。愚蠢不代表落后与丢脸，相反这是需要自己去和自己和解，并最终学会接受的东西。
我也有发言权，我是18年开始不停看社科哲学类的书，我魔怔的和这位兄台也是一模一样，我也是学理工科的。
我也是用数学的逻辑思维去归纳总结社会科学，然后同样陷入其中不能自拔，并且也一样很长时间没与人说话，脑子里面有时候会莫名其妙让自己亢奋，也莫名其妙让自己消极。《在10月24日十点二十四谈谈程序员的哲学观》
直到大四才形成健康的逻辑闭环，回归生活。
我的观点 看完视频，其实有一句话我特别有感触：快乐的人就是处在确定性的慢慢增长状态里的人。
道法术器中，道法偏社会科学（社科），术器偏自然科学（理工科）。学理科的很容易产生快乐，每一次解决问题都会让自己产生愉悦，处在确定性的环境中慢慢增长，不过学理科的会慢慢从自己的术器中悟出自己的道法；学文科的很容易把自己绕进去，但是文科的东西直达道法，当悟透了道法，就一通百通，如王阳明的格物致知，每一个哲学家一旦悟透了道法，他去做什么事都会得心应手；
我原本就是学工科的，大一读土木专业，大二转专业到计算机专业，专业上的问题没有问题，但是到了现实生活中缺遇到了问题，不能用专业知识去处理，于是我落入了哲学的坑。大三都在研究哲学，不说话，用自然科学的逻辑去理解归纳社会科学，视图追求不变的真理，结果最后发现不变的真理就是变化。
马克思主义建立认识论,毛中特建立政治观,史纲建立历史观,思修法基建立人生观,时事建立时代观。
我们用马克思主义（认识论）去看历史（史纲），看到在历史上认识论的答案（毛中特），然后带着思修法基在现在的形政中去践行我们的马克思主义。
结论 今天是2022年6月7日，祝高考的同学高考顺利！
暂时写这么多。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/efccde1a2b3f91db5a8c2b64a3d25d9c/" rel="bookmark">
			AD导入原理图库和PCB库及3D封装攻略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AD导入原理图库和PCB库及3D封装
准备软件： Altium Designer（17.0）
嘉立创EDA(专业版)，下载地址：https://lceda.cn/page/download?src=index
FreeCAD 0.19 下载地址: https://www.freecadweb.org/downloads.php
3D封装下载地址：https://www.3dcontentcentral.cn/default.aspx
1.导入原理图库和PCB封装库 第一种办法是自己在AD软件里画原理图，这样比较耗时间并且出错率较高。
第二种办法在嘉立创下载元器件的原理图和PCB封装图，具体方法如下；
注册完毕后，新建工程；
双击打开工程，如下图：
上图中，1.P1为原理图，PCB1为PCB图，在下方添加自己需要的元器件，以网口连接器RJ45为例
选择好器件后，点击放置即可将元器件放置在工作区域中了
点击保存后，选择“文件”-&gt;“导出”-&gt;”Altium Designer”
确认导出Altium Designer，后更改文件名保存即可将原理图和PCB图保存下来
解压后打开文件夹即可看到下载下来的文件,在AD软件中打开文件
生成原理图库和PCB封装库
即可复制粘贴保存到自己的封装库。
2.导入PCB的3D封装图库 方法1： 使用嘉立创的3D模型图，通过FreeCAD删除固定板之后导出文件后才能在AD软件里加载出我们需要的3D封装，具体流程如下图。
文件类型：STEP，导出对象：PCB+元件模型
导出后保存
用FreeCAD打开此文件，打开文件后需要先在“首选项”里配置一下软件，取消“启用STEP复合合并”的选定，重新打开文件，就可以编辑了；
3D模型如图，这自带了一块电路板，需要删除后重新导出模型
选定剩下的3D模型
“文件”-&gt;“导出”后，保存为“.step”文件
之后打开AD软件，将3D模型导入到封装库中，即可完成。
“放置”-&gt;“3D元件体”，选择“Load from file”，导入之前处理保存好的文件。
更改为3D视图，调整封装位置
调整好位置后，保存即可完成，效果图如下。
方法2： 这个方法比较简单，只需要下载3D封装即可直接导入到封装库
https://www.3dcontentcentral.cn/default.aspx
打开上述网址，注册好之后，搜索需要的元器件封装
点击元器件的3D模型图，选择下载格式为“*.step”
点击下载
点击生成的3D模型链接，即可完成下载。
导入3D模型到封装库的方法同方法1一样。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d39fc71dc4fa5a2dfc94d78db1f1cb25/" rel="bookmark">
			cmake target_link_libraries 中的PRIVATE, PUBLIC, INTERFACE 详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网上关于 target_link_libraries 中的 PRIVATE, PUBLIC , INTERFACE 的解释大部分是错的，而且不是一般的错，是胡说。 因为这三个属性在不同的命令中使用时意义不同，有很多是从target_include_libraries中抄来的。
以下的解释主要场景是linux中，windows不存在这种关系，无需考虑。
我们来解释下，假设我们有一个程序 A , A调用库B, B调用库C. A -&gt; B -&gt; C
A link B时不管是private还是public都没关系，毕竟A不需要导出符号，也没有人以API方式调用它。
现在主要问题就是B这个库用private还是public. C是动态库。
如果B是动态或静态库，C是动态库，这个问题就会有影响。同样，如果B、C同为静态库时也会有问题。 B用private link C, 此时A link B,但是不知道B-&gt;C这层关系，可以正常link B. 运行时，A-&gt;B-&gt;C 时，B找不到C中的函数。linux下没有直接依赖关系，所有的B/C的依赖都会转到到A下，可以用LDD命令验证，此时A只依赖于B, 不见C, 当B中的函数调用C中的函数时，因为没有加载C, 所以报找不到符号错误。解决的办法就是在A link B时，同样也写上C. 但是因为private的原因，A是不知道C中的符号这事，只能强制 link C到A才能解决。
如果B link C时用public 指示， 当编译A时，就会检查到C中的符号没有实现，此时你就会知道要把C link到A来解决这个问题了。
其实private/public 解决的是指示问题，本质上可以使用public 来解决， 可以减少坑。
下面是target_link_libraries中的解释，不想看英文的，直接拉到最后。
Link Inheritance
Similarly, for any target, in the linking stage, we would need to decide, given the item to be linked, whether we have to put the item in the link dependencies, or the link interface, or both, in the compiled target.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d39fc71dc4fa5a2dfc94d78db1f1cb25/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24edea4bc5cadfdd8d04d2c2fb90dd93/" rel="bookmark">
			【约束布局】ConstraintLayout 屏幕适配案例 ( 使用代码生成约束布局控件属性 )
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、ConstraintLayout 屏幕适配案例二、使用代码生成约束布局 一、ConstraintLayout 屏幕适配案例 ConstraintLayout 屏幕适配案例 :
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" tools:context=".MainActivity"&gt; &lt;kim.hsl.android_ui.PathMeasureView android:id="@+id/pathMeasureView" android:layout_width="0dip" android:layout_height="0dip" app:layout_constraintHeight_default="percent" app:layout_constraintHeight_percent="0.5" app:layout_constraintWidth_default="percent" app:layout_constraintWidth_percent="0.5" app:layout_constraintDimensionRatio="1:1" app:layout_constraintLeft_toLeftOf="parent" app:layout_constraintRight_toRightOf="parent" app:layout_constraintHorizontal_bias="0.5" app:layout_constraintTop_toTopOf="parent" app:layout_constraintBottom_toBottomOf="parent" app:layout_constraintVertical_bias="0.5" /&gt; &lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; 布局样式如下 :
二、使用代码生成约束布局 public class BoundaryCaculate { public static void main(String[] args) { caculate_constraint(); } // 给定左上值计算 public static void caculate_constraint() { // 相对于父类 比例计算 的原始数据 : 屏幕 宽高 , 其比例肯定是相对于父控件进行计算 float width = 200, height = 260; // 计算 垂直 水平方向 bias 数据 , 子布局 , 如果是相对于父控件 , 就是 750, 1334 // 计算流程 : // ① bias 宽度计算 : 计算出总的 bias 总长度 = width_inner - 控件长度 , 左侧值 / 总长度 = 水平方向的 // bias 值 // ② bias 高度计算 : 计算出总的 bias 总高度 = height_inner - 控件高度 , 顶部值 / 总高度 = // 垂直方向的 bias 值 float width_inner = width, height_inner = height; // 中心点坐标 float[][] left_top_data = { { 0, 0 },	{ 0, 186 }, { 400, 0 }, { 600, 0 }, { 800, 0 }, { 1000, 0 }, { 2, 260 },	{ 200, 260 }, { 400, 260 }, { 600, 260 }, { 800, 260 }, { 1000, 260 } } ; // 图片坐标,0位置是宽,1位置是高 float[][] width_height_data = { { 200, 200 }, { 200, 78 }, { 200, 260 }, { 200, 260 }, { 200, 260 }, { 200, 260 }, { 200, 260 }, { 200, 260 }, { 200, 260 }, { 200, 260 }, { 200, 260 }, { 200, 260 } } ; for (int i = 0; i &lt; left_top_data.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/24edea4bc5cadfdd8d04d2c2fb90dd93/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/059bd1d45c569ac9f653b22fd8420b3c/" rel="bookmark">
			数组的小结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数组：一组有序的数据 数组的作用: 可以一次性存储多个数据 数组的元素:就是数组里面存储的数据
数组的长度:就是元素的个数;
数组的索引(下标):从0开始的,到长度减1结束
索引的作用:
设置数组里面的元素值:
数组名[下标] = 值;
获取数组里面的元素值
数组名[下标];
2.数组的定义方式:
1.通过构造函数的方式定义数组
var 数组名 = new Array();
var arr = new Array();
2.通过字面量的方式定义数组
var 数组名 = [];
如果直接输出数组名,就可以直接查看到数组里面的数据,如果数组是空的,那么就看不到
var arr = new Array(一个值); 那么这个一个值代表是数组的长度
var arr = new Array(多个值); 这个多个值,就代表你往数组里面存的数据
1.构造函数的方式定义数组
var arr = new Array(); //空数组
console.log(arr);
var arr = new Array(5); //声明一个空的数组,但是数组的长度是5,数组里面的所有的值都是undefined, 5是代表数组的长度
console.log(arr);
var arr = new Array(10,20,30,60,1000,100);
console.log(arr); //[10, 20, 30, 60, 1000, 100]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/059bd1d45c569ac9f653b22fd8420b3c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d733fe6d1eb6c546be45248289f22de8/" rel="bookmark">
			RNN以及其改进版（附2个代码案列）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		感谢阅读 RNN简介传统RNN内部结构过程演示内部计算公式RNN輸出激活函数tanhPytorch构建传统RNN梯度计算 LSTM介绍遗忘门结构分析：输入门结构分析:细胞状态更新分析:输出门结构分析:结构图梯度公式现实生活列子加强理解代码示例 GRU介绍结构图个人对GRU的理解LSTM难以比拟的两个地方 RNN示例（人名分类问题）案例介绍数据集下载与解释导包查看常用字符数量构建国家名字，并获取国家数量读数据到内存构建数据源并进行迭代对异常索引的处理的改良 构建三种RNN模型构建传统RNN构建LSTM构建GRU 对三个模型进行测试与训练测试训练传统RNNLSTMGRU 进行预测构建预测函数传统RNNLSTMGRU调用 注意力机制注意力机制简介注意力概念注意力计算规则作用生活场景帮助理解 bmm运算简介代码实现 RNN案例 seq2seq英译法seq2seq介绍seq2seq模型架构模型解释 数据集下载导包并进行文件清洗思路分析数据预处理构建数据源对象并测试编码器和解码器构建基于GRU的编码器思路分析代码实现 基于GRU和Attention的解码器结构图代码实现 训练模型teacher_forcing内部迭代训练函数设置参数代码实现 训练 模型评估与测试评估函数书写评估 关于服务器调试python的说明操作前需要知道的知识点nohuptail 首先进入python文件所在目录并进行编译转后台进程启动一个SSH连接看训练输出执行结果 RNN简介 RNN(Recurrent Neural Network), 中文称作循环神经网络, 它一般以序列数据为输入, 通过网络内部的结构设计有效捕捉序列之间的关系特征, 一般也是以序列形式进行输出
传统RNN 内部结构过程演示 两个黑点一起到达蓝色区域（并在之前形成整体）
内部计算公式 RNN輸出 激活函数tanh 于帮助调节流经网络的值, tanh函数将值压缩在-1和1之间
Pytorch构建传统RNN def dm_run_for_hiddennum(): ''' 第一个参数：input_size(输入张量x的维度) 第二个参数：hidden_size(隐藏层的维度， 隐藏层的神经元个数) 第三个参数：num_layer(隐藏层的数量) ''' rnn = nn.RNN(5, 6, 2) # A 隐藏层个数从1--&gt;2 下面程序需要修改的地方？ ''' 第一个参数：sequence_length(输入序列的长度) 第二个参数：batch_size(批次的样本数量) 第三个参数：input_size(输入张量的维度) ''' input = torch.randn(1, 3, 5) # B ''' 第一个参数：num_layer * num_directions(层数*网络方向) 第二个参数：batch_size(批次的样本数) 第三个参数：hidden_size(隐藏层的维度， 隐藏层神经元的个数) ''' h0 = torch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d733fe6d1eb6c546be45248289f22de8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d5002a437fb643f62308542f0bec88f/" rel="bookmark">
			vue生命周期详细全过程（含图解）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue生命周期 vue生命周期钩子 概念：Vue实例从加载到销毁过程中会执行的一些回调函数
生命周期：vue实例从创建到销毁的过程。（vue实例创建，dom树完成渲染）
钩子：回调函数
生命周期：
1.又名：生命周期回调函数、生命周期函数、生命周期钩子。
2.是什么：Vue在关键时刻帮我们调用的一些特殊名称的函数。
3.生命周期函数的名字不可更改，但函数的具体内容是程序员根据需求编写的。
4.生命周期函数中的this指向是vm 或 组件实例对象。
生命周期详细图解 vue生命周期4个阶段8个钩子 阶段一：创建（初始化） （创建vue实例）
beforeCreate , created
阶段二 ：挂载 （data数据渲染到el）
beforeMount, mounted
阶段三 ： 更新 （检测data变化并更新el）
beforeUpdate, updated
阶段四 ：销毁 （解除data与el的绑定关系）
beforeDestroy, destroyed
阶段说明 Vue-初始化阶段 含义讲解
1.new Vue() – Vue实例化(组件也是一个小的Vue实例)
2.Init Events &amp; Lifecycle – 初始化事件和生命周期函数
3.beforeCreate – 生命周期钩子函数被执行
4.Init injections&amp;reactivity – Vue内部添加data和methods等
5.created – 生命周期钩子函数被执行, 实例创建
6.接下来是编译模板阶段 –开始分析
7.Has el option? – 是否有el选项 – 检查要挂到哪里
没有. 调用$mount()方法
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d5002a437fb643f62308542f0bec88f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/852d134db09dc8de587d14f5b7e9e226/" rel="bookmark">
			Modbus Poll v9.9.2 Build 1690 Modbus测试工具单文件版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自：https://blog.csdn.net/weixin_42793435/article/details/124727041
前言
Modbus Poll是Witte公司开发的Modbus测试工具，用于测试和调试Modbus设备。Modbus管理模拟器软件支持ModbusRTU、ASCII、TCP/IP协议。支持多设备监控，同时监视多个从设备/数据域。
Modbus Poll
支持图形化监控报文信息，循环报文发送，寄存器数值独立增长。可以图形化设定从设备ID, 功能, 地址, 大小和轮询间隔。提供多种格式数据，比如浮点、双精度、长整型（可字节序列交换），并且支持Excel导出。
Modbus从站是模拟多达32个从站设备在32位windows！加快你的PLC编程与此模拟工具。开始编程和测试您从供应商收到从设备前。载有任何打开的文档数据是可访问到主应用程序。相同的用户界面的Modbus投票。支持功能01，02，03，04，05，06，15，16，22和23。
监测串行通信。OLE自动化为使用Visual Basic，excel会等接口要根据您的具体要求解释和显示的Modbus数据。例如编辑编辑在Excel中你的奴隶的数据。尝试包含的程序Excel的example.xls。
Modbus从站内开每个窗口可以被配置为从相同或不同的从节点表示数据。
使用说明
链接（失效留言）：https://pan.baidu.com/s/18Cdl89yNUc0OE1VhcF57xA?pwd=3586
单文件可以直接运行使用
by：71288319
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/172443caf2626d30bbd324ca2de7a52c/" rel="bookmark">
			ByteTrack论文解读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ByteTrack 摘要介绍BYTE关联方法ByteTrack实验结果代码部署 论文地址： https://arxiv.org/abs/2110.06864 代码地址： https://github.com/ifzhang/ByteTrack 摘要 MOT任务旨在评估视频中的目标边界框和身份信息。大多数方法是选项将那些检测置信度高于某一阈值的边界框进行关联，并且直接丢弃那些由于遮挡等问题产生的低置信度的边界框。这带来了不可忽略的真实物体丢失和碎片轨迹。为此ByteTrack提出了一个考虑所有边界框的关联方法。对于低置信度的边界框，利用他们与之前的轨迹进行之间进行相似度对比，实现恢复真实目标和过滤背景检测。当应用于其他多种不同的追踪器上时，IDF1都有明显的提升。并且该论文也是使得MOT任务中MOTA首次突破了80的。
直接贴图，下图为各个追踪器的MOTA-IDF1-FPS的对比图，可以看出ByteTrack的优越性，各种指标均达到了最高。
介绍 ByteTrack描述的现象正如下图所示，在帧 t 1 t_1 t1​时刻，模型初始化了三个高置信度的检测框作为追踪轨迹，但是在 t 3 t_3 t3​和 t 3 t_3 t3​帧时由于遮挡问题，导致这两个真实目标的检测框的置信度被严重降低。如果对于筛选高置信度的检测框的方法，那么这些真实目标就直接被丢弃了，这也就导致了目标的丢失，产生了轨迹的断裂。
实时上ByteTrack思考的就是如何将这些低置信度的目标筛选回来。本文中ByteTrack选择定义低置信度检测目标与轨迹的相似度作为判断的线索（这里主要还是位置信息）。如下图（c）中，红色目标轨迹存在，则导致后面的黄色目标能够被查询到。但是背景目标由于找不到与之前匹配的轨迹，则会被丢弃。
作者将他们的关联方法命名为BYTE，具体做法如下：
首先，基于运动相似度来实现高得分的检测框与轨迹的匹配，具体的使用卡尔曼滤波来预测目标在下一帧中的位置信息，运动相似度的计算由当前帧的检测目标框和卡尔曼滤波预测边界框之间的IoU体现，实现效果如图上图（b）。
然后，实现未匹配轨迹的第二次匹配（红色虚线边界框和低置信度边界框之间的匹配）。匹配成功后如上图（c）效果，真实目标过滤下来，背景目标丢弃。
最终模型的确定，ByteTrack选择了以YOLOX为检测器获取检测信息，BYTE的检测关联方法。并且实验中，他放弃了ReID分支（外貌特征），仅用简单的运动线索，就能很好的处理遮挡与关联问题。
BYTE关联方法 这一节主要介绍BYTE的关联实现，步骤如下伪代码算法图。
首先，算法的输入由一个视频片段 V V V，相应的还有一个检测器 D e t Det Det和一个卡尔曼滤波器 K F KF KF。同时设定三个阈值 τ high , τ low \tau_{\text {high }}, \tau_{\text {low }} τhigh ​,τlow ​ 和 ϵ \epsilon ϵ。前两个为检测的分数阈值，后一个为追踪得分阈值。BYTE的最终输出为视频的轨迹 T \mathcal{T} T，其中的每条轨迹包括目标的检测框和身份。
（3-13行）：对于所有的由检测器产生的检测框和得分信息，将他们分为两部分，检测得分高于阈值 τ high \tau_{\text {high }} τhigh ​的归类为 D high \mathcal{D}_{\text {high }} Dhigh ​ ，同时检测得分高于阈值 τ low \tau_{\text {low }} τlow ​且低于阈值 τ high \tau_{\text {high }} τhigh ​的归类为 D low \mathcal{D}_{\text {low }} Dlow ​。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/172443caf2626d30bbd324ca2de7a52c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a306b5120319270d9f29b18497c13cd/" rel="bookmark">
			壁纸网站：Wallpaper Search: - wallhaven.cc
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Wallpaper Search: - wallhaven.cchttps://wallhaven.cc/search?categories=110&amp;purity=111&amp;sorting=date_added&amp;order=desc
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9fec039153d8e6a590ae13e8ecafcd0b/" rel="bookmark">
			ComplexUpset的简单使用记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Upset 图常用于展示多个数据集的交集或并集。通常数据集数量较多（如6个以上），用Venn图展示就比较杂乱，这时候可以用Upset图展示。
R语言中常用的Upset作图包有两个，UpsetR和ComplexUpset，ComplexUpset的功能更复杂，这里简单记录一下ComplexUpset的使用命令（使用说明中的示例代码不再摘录）。
ComplexUpset其实是作者krassowski用ggplot2对upsetR功能的再现和补充，因此只要理解不同局部图是基于ggplot2的哪个函数实现的，就可以比较容易的对图片进行优化。
library(ggplot2) library(ComplexUpset) fu &lt;- read.table('for_upset.txt',header = 1,sep = '\t') # 第一个输入文件格式：行为组（数据集）内的元素，列为元素的属性信息和不同组，其中某个元素是否在特定组内用布尔值表示，例如： fu[1:5,1:5] Class1 Index A1 B1 C1	... 1 Alkaloids HJKP000649 TRUE TRUE TRUE	... 2 Phenolic acids Hmbp001276 FALSE FALSE FALSE	... 3 Lignans and Coumarins Hmcp002123 FALSE TRUE TRUE	... 4 Others Hmfn000531 FALSE FALSE FALSE	... 5 Phenolic acids Hmgn001653 TRUE TRUE FALSE	... ... #第二个输入文件为需要分析的组名向量 groups groups [1] "A1" "B1" "C1"... # 对一级分类自定义颜色 CC &lt;- c('Alkaloids'='#a6cee3','Phenolic acids'='#1f78b4','Lignans and Coumarins'='#b2df8a','Others'='#33a02c','Lipids'='#fb9a99','Organic acids'='#e31a1c','Amino acids and derivatives'='#fdbf6f','Tannins'='#ff7f00','Flavonoids'='#cab2d6','Terpenoids'='#6a3d9a','Nucleotides and derivatives'='#b15928') upset( fu,groups,name = 'groups',wrap = T,min_degree=3,sort_intersections='ascending',sort_intersections_by=c('cardinality'),queries=list(upset_query(intersect=groups1, color='red')),height_ratio = 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9fec039153d8e6a590ae13e8ecafcd0b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a575f8bf1a53c891cbd7f5aa9259d80/" rel="bookmark">
			yum详解汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		yum yum替换 通知：CentOS 8操作系统版本结束了生命周期（EOL），Linux社区已不再维护该操作系统版本。建议您切换到Anolis或Alinux。如果您的业务过渡期仍需要使用CentOS 8系统中的一些安装包，请根据下文切换CentOS 8的源。
1. 备份
mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup 2. 下载新的 CentOS-Base.repo 到 /etc/yum.repos.d/
centos8（centos8官方源已下线，建议切换centos-vault源）
wget -O /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-vault-8.5.2111.repo 或者
curl -o /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-vault-8.5.2111.repo centos6（centos6官方源已下线，建议切换centos-vault源）
wget -O /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-vault-6.10.repo 或者
curl -o /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-vault-6.10.repo CentOS 7
wget -O /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-7.repo 或者
curl -o /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-7.repo 3. 运行 yum makecache 生成缓存
4. 其他
非阿里云ECS用户会出现 Couldn’t resolve host ‘mirrors.cloud.aliyuncs.com’ 信息，不影响使用。用户也可自行修改相关配置:
sed -i -e '/mirrors.cloud.aliyuncs.com/d' -e '/mirrors.aliyuncs.com/d' /etc/yum.repos.d/CentOS-Base.repo 主要操作
确定自己系统版本
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a575f8bf1a53c891cbd7f5aa9259d80/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1cc37159b8e241104e549c6cecca9793/" rel="bookmark">
			CURL详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 CURL cURL（客户端URL）是一个开放源代码的命令行工具，也是一个跨平台的库（libcurl），用于在服务器之间传输数据，并分发给几乎所有新的操作系统。cURL编程用于需要通过Internet协议发送或接收数据的几乎任何地方。
cURL支持几乎所有的互联网协议（DICT，FILE，FTP，FTPS，GOPHER，HTTP，HTTPS，IMAP，IMAPS，LDAP，LDAPS，MQTT，POP3，POP3S，RTMP，RTMPS，RTSP，SCP，SFTP，SMB，SMBS，SMTP ，SMTPS，TELNET和TFTP）。
常用参数 发送 POST 请求的数据体。
curl -d’login=emma＆password=123’-X POST https://google.com/login
添加 HTTP 请求的标头。
curl -H ‘Accept-Language: en-US’ https://google.com
打印出服务器回应的 HTTP 标头。
curl -i https://www.example.com
将服务器的回应保存成文件，等同于wget命令。
curl -o example.html https://www.example.com
指定只输出错误信息，通常与-s一起使用。
curl -S -o /dev/null https://google.com
上面命令没有任何输出，除非发生错误。
输出通信的整个过程，用于调试。
curl -v https://www.example.com
–trace参数也可以用于调试，还会输出原始的二进制数据。
curl --trace - https://www.example.com
-X参数指定 HTTP 请求的方法。
curl -X POST https://www.example.com
参考资料 curl 的用法指南什么是cURL？ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f229d1e090aa36c885eee002e7bec1f9/" rel="bookmark">
			练习推导一个最简单的BP神经网络训练过程【个人作业/数学推导】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面： 各式资料中关于BP神经网络的讲解已经足够全面详尽，故不在此过多赘述。本文重点在于由一个“最简单”的神经网络练习推导其训练过程，和大家一起在练习中一起更好理解神经网络训练过程。
一、BP神经网络 1.1 简介 BP网络（Back-Propagation Network） 是1986年被提出的，是一种按误差逆向传播算法训练的
多层前馈网络，是目前应用最广泛的神经网络模型之一，用于函数逼近、模型识别分类、数据压
缩和时间序列预测等。
一个典型的BP网络应该包括三层:输入层、隐藏层和输出层。各层之间全连接，同层之间无连接。
隐藏层可以有很多层。
图1 BP神经网络参考图 1.2 训练(学习)过程 每一次迭代(Interation)意味着使用一批(Batch)数据对模型进行一次更新过程，被称为“一次训练”，包含一个正向过程和一个反向过程。
具体过程可以概括为如下过程：
准备样本信息(数据&amp;标签)、定义神经网络(结构、初始化参数、选取激活函数等)将样本输入，正向计算各节点函数输出计算损失函数求损失函数对各权重的偏导数，采用适当方法进行反向过程优化重复2~4直至达到停止条件 以下训练将使用均值平方差（Mean Squared Error， MSE）作为损失函数，sigmoid函数作为激活函数、梯度下降法作为优化权重方法进行推导
二、实例推导练习作业 2.1 准备工作 图2 所定义神经网络、初始化参数、样本信息等 第一层是输入层，包含两个神经元： i1， i2 和偏置b1第二层是隐藏层，包含两个神经元： h1， h2 和偏置项b2第三层是输出： o1， o2每条线上标的 wi 是层与层之间连接的权重激活函数是 sigmod 函数我们用 z 表示某神经元的加权输入和，用 a 表示某神经元的输出 2.2 第一次正向过程【个人推导】 根据上述信息，我们可以得到另一种表达一次迭代的“环形”过程的图示如下：
图3 bp神经网络数量关系“环”图示 我们做一次正向过程(由于需多次迭代，因此我们将第一次正向过程标记为t=0)，得各项数值如下：
图4 初始数值“环”图示(附函数关系表达式) 由此我们可得损失函数值为MSE=0.298371109，假设这超出了我们对损失值的要求，那么我们就需要对各个权重(wi,t=0)进行更新， 作为t=1的初始权重。
2.3 推导计算∂/∂wi【个人推导】 2.3.1 均值平方差损失函数的全微分推导 2.3.2 这一次代入训练实例的数值和各数量名 d
d
d
dM
d
2.3.3 由此我们得到∂/∂wi的表达式 当然如果你喜欢用矩阵表示也可以：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f229d1e090aa36c885eee002e7bec1f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa185d9c2e70b43f14a88a55b63f0b5a/" rel="bookmark">
			Docker安装Kibana
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装 Kibana 7.4.2 下载镜像docker pull elasticsearch:7.4.2。
启动容器
docker run --name kibana\ -e SERVER_BASEPATH=http://主机IP:9200\ -p 5601:5601\ -d kibana:7.10.1 安装常见问题 elasticsearch和kibana版本需要尽量一致Kibana环境变量,启动的时候必须设置ELASTICSEARCH_HOSTS Kibana有关Docker官方文档 安装错误问题解决 None
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/580d5ade4255dc8a930738bc51b2fab2/" rel="bookmark">
			接口自动化常见的几种传参类型及参数传递方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 如何知道接口的传参类型常见的传参类型及参数传入方式content-type: application/jsoncontent-type: application/x-www-form-urlencoded没有content-type，请求参数放在url中，如图content-type: multipart/form-datacontent-type: text/plain 如何知道接口的传参类型 浏览器》F12》查看接口请求头》content-type
常见的传参类型及参数传入方式 content-type: application/json 请求内容写为字典然后使用request方法json参数传入
实例
url = 127.0.0.1/testdemo paylod = { "dataId":"4735355018682293348", "formId":"2375346656471163011", "layoutId":"2375346656472563013", "module":"customer" } headers = { "Content-Type": "application/json", "Cookie": "Cookie" } response = request("POST", url, headers=headers, json=payload) content-type: application/x-www-form-urlencoded 请求内容写为字典然后使用request方法data参数传入
实例
这里我们依然将请求体的参数写为字典，个人感觉字典的可读性强于字符串拼接
url = 127.0.0.1/testdemo paylod = { "customerId": "4735354895615677672", "key": "saleChances_permision" } headers = { "Content-Type": "application/x-www-form-urlencoded", "Cookie": "Cookie" } # 这里需要注意 使用data参数传入即可，无需再对payload做字典转字符串的操作 response = request("POST", url, headers=headers, data=payload) 如果传入参数中，字典的键的值是一个字符串，如下图
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/580d5ade4255dc8a930738bc51b2fab2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e46d8d5e6a293a376aabbf5f4ed8ea0d/" rel="bookmark">
			对齐工具MFA
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MFA（Montreal Forced Aligner）是一种forced alignment工具。MFA底层是使用了kaldi工具，相对于其它的工具MFA使用triphone acoustic model来建模上下文信息，同时包含了和说话人相关的特征，因此可以适应不同的说话人。MFA具有可训练性 (trainability) ，即可由用户自己在新数据上训练acoustic model。
1、MFA安装 MFA有多种安装方式，可参考MFA installation。mfa需要kaldi，kaldi安装参考kaldi安装
2、MFA使用 2.1、查看MFA版本 mfa version 2.2 数据格式 对齐数据或者训练模型需要的数据需要按照如下格式：
+-- prosodylab_corpus_directory | +-- speaker1 | --- recording1.wav | --- recording1.lab | --- recording2.wav | --- recording2.lab | +-- speaker2 | --- recording3.wav | --- recording3.lab | --- ... 数据目录下每个说话人对应一个目录，每个说话人目录下一个语音数据wav文件对应一个文本数据文件lab，文件名除了扩展名之外其他的部分要一一对应。
2.3 、下载预训练模型和词典 MFA提供了已经预先训练好的模型以及词典，下载地址。
词典下载地址
模型下载地址
一种方式是手动下载，另外是使用mfa命令下载，如下以中文为例：
#下载模型 mfa models download acoustic mandarin_mfa #下载词典 mfa models download dictionary mandarin_mfa mfa models download dictionary mandarin_pinyin 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e46d8d5e6a293a376aabbf5f4ed8ea0d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f1646c23d716b975453f19ed46c0bf2/" rel="bookmark">
			快速上手Pinia
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.什么是 Pinia 如果你之前使用过 vuex 进行状态管理的话，那么 pinia 就是一个类似的插件。它是最新一代的轻量级状态管理插件。按照尤雨溪的说法，vuex 将不再接受新的功能，建议将 Pinia 用于新的项目。
详情可查阅官方文档
2.Pinia 的优点 1.简便，存储和组件变得很类似，你可以轻松写出优雅的存储。
2.类型安全，通过类型推断，可以提供自动完成的功能。
3.vue devtools 支持，可以方便进行调试。
4.Pinia 支持扩展，可以非常方便地通过本地存储，事物等进行扩展。
5.模块化设计，通过构建多个存储模块，可以让程序自动拆分它们。
6.非常轻巧，只有大约 1kb 的大小。
7.服务器端渲染支持
3.如何使用(以下代码是在vue3中使用) 1.使用vite创建一个vue3项目
npm init @vitejs/app 2.下载pinia
npm i pinia 3.在main.js中引入
import { createApp } from 'vue' import App from './App.vue' import {createPinia} from 'pinia' const app = createApp(App) app.use(createPinia()) .mount('#app') 4.创建store
import { defineStore } from "pinia"; export default defineStore('main',{ state:()=&gt;{ // 类似于组件的data，用来存储全局状态的 // 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f1646c23d716b975453f19ed46c0bf2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/416163729a67687a116db5a566df02f3/" rel="bookmark">
			前端input操作，修改光标颜色，去除背景色
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 修改光标颜色方法： input输入框的光标颜色修改有两种：第一种设置光标颜色的同时修改光标颜色，使用：color:green;第二种：只修改光标颜色，使用：caret-color:green; 更改input输入框背景色： 从事前端工作半年以上的同志都知道，我们的input输入框是有默认背景色和边框的。但有时候我们有需求放自己的背景色或者没有背景色。更改颜色很：这比较简单，就是平时我们用的background-color:red;就可以了。去掉背景色：首先我们要明白的是背景色是标签自带的样式属性，有时我们不用去除，但可以设置为透明的：背景色透明：background-color:rgba(0,0,0,0);background-color:transparent;去掉默认背景：background:unset; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f24740b52dc3d5d5f8fdf4db5f7202b/" rel="bookmark">
			Next.js 网站部署踩坑经历小记及前端站点部署技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在入职两个月后，我开始了第一个完全由我一个人负责开发的网站项目。这个网站的用途是用于 宣传一个开源社区峰会 以及 沉淀峰会视频内容 ，在峰会进行期间还需要在网站进行 直播 。从网站的开发到部署上线，可谓是踩坑无数，最终实现的网站在这里 apisix-summit.org/
背景 由于时间有限，整体网站的架构是基于 vercel 的一个网站脚手架 virtual-event-starter-kit 之上进行开发，因此并不需要从头构建项目。 这个脚手架使用的是 next.js 实现服务端渲染，其中已经预设了很多第三方平台的接口，例如 datoCMS 和 upstash。
当时的我对于 react 并没有那么的熟悉，更别提 next.js 框架以及一些 react 系的第三方库了，因此这次的开发不仅仅是任务，更是一个学习的过程。
部署过程 服务器基本环境搭建 最初网站是通过 vercel 进行部署的，但是后期需要转移到 AWS 的三台裸金属服务器上进行部署并配置 AWS Elastic Load Balancing 负载均衡。由于网站使用的是服务端渲染，因此不能直接打成一个静态包放在 CDN 上，必须跑一个服务才能使用。
为了防止服务挂掉，我使用的 pm2 来守护服务的进程，关于 node.js 和 pm2 的安装我执行的操作大概如下：
sudo apt update sudo apt install nodejs npm -y sudo npm i n pm2 yarn -g n stable 这里之所以安装 n 是因为 apt 安装的 node.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f24740b52dc3d5d5f8fdf4db5f7202b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/852a1d817d86d299c45befd6b7570e6b/" rel="bookmark">
			Java中关于除0的那些事
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于除0的那些事 我们从小就知道在做除法运算的时候，除数是不能为0的。在Java中如果除数是0，我们有一个大家都知道的异常，那就是java.lang.ArithmeticException: / by zero，但是如果除数为0就一定会抛出这个异常么？那可不一定。
当被除数是int型 当被除数是long型 ​ 当被除数是double型 所以在做除法的时候，如果是涉及到double类型，那么除数是0的时候是不会抛出异常的，而是会返回一个对于计算机而言不算错误的结果。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e623e771666b7a96587bed02318369f8/" rel="bookmark">
			windows平台使用vscode搭建Lua与C&#43;&#43;交互环境（附C&#43;&#43;环境搭建json文件）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.下载Lua源码
注意：如果下载的只是DLL拓展是不能进行Lua与C++交互的，像这种：
必须下载源码。
请下载Lua源码：https://www.lua.org/ftp/lua-5.4.3.tar.gz
二.编译
到lua-xxx/src下进行编译（请自行下载MingW编译器）：
mingw32-make mingw 三.vscode下的设置
1.c_cpp_properties.json文件中设置路径：
"includePath": [ "${workspaceFolder}", "D:/lua-5.4.4/src/**" ], 2.ctrl+shift+P找到Edit Configurations设置包含路径
找到包含路径选项并设置：
3.task.json文件里设置args（这是最主要的一步，上面两步只是让我们写头文件的时候可以不用写绝对路径而已）
"args": [ "-fdiagnostics-color=always", "-g", "${file}", "-L", "D:/lua-5.4.4/src", "-I", "D:/lua-5.4.4/src", "-llua", "-o", "${fileDirname}\\${fileBasenameNoExtension}.exe" ], -I，-L，-l参数大家自行学习
四：简单的一个交互使用
extern "C"//如果是C++文件请这样写 { #include "lua.h" #include "lauxlib.h" #include "lualib.h" #include "lua.hpp" } #include &lt;string.h&gt; char const* scripe = R"( function Print() print('hello world!') end Print(); )"; int main() { lua_State *state = luaL_newstate();//初始化lua虚拟机 luaL_openlibs(state);{ luaL_loadbuffer(state,scripe,strlen(scripe),"Print"); lua_pcall(state,0,0,0); } lua_close(state); return 0; } 五：vscode下C/C++环境配置（直接拿来就可以用）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e623e771666b7a96587bed02318369f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d28980cd6da14c402b192f8733f45cc0/" rel="bookmark">
			unityHub登录不上，跳转界面空白刷新不出来
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在hub上点击登陆跳转网页后空白，网上的办法试了都不行，在咨询克服后
将Unity hub3卸载，并替换为v2版本解决
测试的是Unity hub2.4的版本，大家也可以尝试下其他v2的hub
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8cb329f18e2f7d6bcbef1aa8f75ed527/" rel="bookmark">
			论文阅读：（ICLR 2021） MULTIPLICATIVE FILTER NETWORKS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		论文阅读：ICLR 2021 MULTIPLICATIVE FILTER NETWORKS Code：https://github.com/boschresearch/multiplicative-filter-networks
Paper: https://openreview.net/forum?id=OmtmcPkkhT
其他参考资料：知乎：论文解读 | Multiplicative Filter Networks
首先对文章做个简单机翻，在最后再对文章进行分析。
将该该代码运行，并写一份代码讲解:代码讲解就不弄了，查看了一下代码还是比较简单的，只有四个py文件。主要内容是MFNbased,FourierNet和GaborNet,代码也没啥问题，环境装完就能跑。 这两天再精读一遍理论部分：图像表示部分发现只要把预测图像的尺寸调大一些，网络的性能就会急剧下降并且难以学习，对学习率还是比较敏感的····· Abstract 深度神经网络常用于高维输入上近似函数，但最近的工作探索了神经网络作为低维但复杂信号的函数逼近的作用，例如使用像素坐标表示图像，求解微分方程或者神经辐射场等。成功的原因在于最近的方法使用了Sin激活函数或者傅里叶特征超过了简单了ReLU网络。在本文中，提出并证实了一个更为简单的函数逼近方法同样可以解决此类问题：乘性滤波器网络（multiplicative filter networks）。在此类网络中，避免了合成深度问题，简单的将输入与正弦或者Gabor小波相乘。这种表示方法有个显著的优势，即整个函数可以简单看做是傅里叶级数或Gabor基函数的线性函数逼近。尽管方法简单，但是与最近使用的ReLU激活和Sin激活的傅里叶特征相比，本文的方法大大超过或者匹配这些方法的性能。
1.Introduction 近年来工作关注隐神经表示，用一个连续的图像可以用函数表示为 f : R 2 → R 3 f:\R^2 \rightarrow \R^3 f:R2→R3 ，其中输入是图像的坐标输出是图像的RGB值。最近的研究表示需要使用Sin激活函数（SIREN），或者使用随机傅里叶特征输入ReLU网络才能使MLP适合这项任务。这两篇论文都证明了其方法远优于简单的ReLU网络，并且对于复杂函数有较高的保真度。但使用SIn激活或者使用傅里叶特征作为输入的优势很难表示，或者说尚不清晰。
然而，在这篇论文中，我们论证并实证地证明了一个可论证的更简单的函数类可以在这项任务上与这些先前提出的网络一样好，甚至更好。具体来说，我们提出了一种称为乘法滤波器网络(MFN)的架构。与传统的通过组合深度获得表示能力的多层网络不同，MFN只是简单地对网络的输入重复应用非线性滤波器(如正弦或Gabor小波函数)，然后将这些特征的线性函数相乘。这种表示的显著优点是，由于傅里叶和Gabor滤波器的乘法特性，整个函数最终只是输入的这些傅里叶或Gabor特性的线性函数(一个指数)。事实上，我们可以表达这些MFNs的精确线性形式，这可以使它们的分析比深度网络的分析简单得多，深度网络的非线性激活的组合使整个函数难以描述。
在这项工作中，我们表明，尽管这种简单，提出的网络往往表现相同或更好，比先前提出的SIREN或傅里叶特征网络。具体地说，我们将我们的方法与在SIREN和傅里叶特征论文中提出的精确基准中可比较的参数数量的网络上的方法进行比较。我们表明，当增加网络的深度或宽度时，MFNs可以获得更好的性能增量。尽管如此，我们还是强调这一点，特别是，与MFN相比，SIREN网络似乎保留了一些显著的优势，例如在表示函数及其梯度中偏向于更平滑的区域。然而，特别是考虑到mfn最终只是对应于一个低维函数的线性傅里叶或小波表示，我们认为它们应该被视为未来研究此类问题的标准基准，以表明典型深度网络的组成深度在哪些地方可以提出实质性的好处。
2. Background and related work 我们的方法与以前在傅里叶和小波变换、随机傅里叶特征和隐式神经表征方面的许多工作有关。我们将探讨以下领域之间的联系。
2.1 傅里叶和小波变换 利用傅立叶变换和小波变换等变换将时间或空间域信号转换到频率域已经成为图像处理、信号处理和计算机视觉许多发展的核心。特别是傅里叶变换及其各种形式在无数的应用中发现了用途，如光谱学、量子力学、信号处理。小波变换在多尺度分析中特别有用，在数据压缩中被发现特别有用，JPEG2000就是一个例子。
2.2 随机傅里叶特征 Rahimi &amp; Recht(2008)的一项开创性工作展示了傅里叶变换在机器学习中的应用。他们表明，简单地将原始数据集投影到随机的傅里叶基中，可以极大地提高模型的表达能力，因为它近似于内核计算。许多后续的工作应用傅里叶特征和变化，以提高机器学习算法在许多领域的性能，包括分类，回归，聚类，在线学习。
2.3 隐式神经表示 最近的一项工作是用神经网络参数化的连续函数来表示信号(而不是使用传统的离散表示)，这一工作越来越受欢迎。这种策略被用于表示不同的对象，比如图像，形状，场景和纹理。在这些应用中，通常使用带有多层感知器和ReLU激活函数的标准神经网络架构。最近，受到傅立叶变换在机器学习中的成功的激励，一些论文提出了将周期性非线性集成到网络中的架构变化。Mildenhall等人(2020年);Zhong等(2020);Tancik等人(2020)提出使用输入特征的正弦映射(Rahimi &amp; Recht, 2008)，使用位置编码和高斯随机分布中的映射。其他(Klocek等人，2019;Sitzmann等人，2020年)提出在多层感知器架构中使用正弦激活函数。这两种策略都被证明可以极大地提高许多对象表示任务的结果。
3. 乘性滤波网络 一个K层的深度网络 f : R n → R m f:\R^n \rightarrow \R^m f:Rn→Rm可以由递归式定义如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8cb329f18e2f7d6bcbef1aa8f75ed527/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47d6f0dae3226b44ac8f8fe04426312b/" rel="bookmark">
			PICkits3调试功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PIC单片机的ICD（在线调试功能）。
软件：MPLAB X IDE。
硬件：PICkits3、目标板、ICSP五线连接。
点击图示“调试项目”按钮，便进入在线调试界面。
在此过程中，编程软件会将所需的调试代码烧录到目标单片机中。所以，当调试结束时，应当重新烧入程序。
调试要求：
PICkit3中文使用指南
其中，看门狗功能要求可忽略，点击“调试项目”按钮后，编程软件会自动屏蔽单片机的看门狗功能，并不改动程序。
本文已结束，以下内容请忽略。
为了营造健康有序的技术社区，CSDN对博客标题进行了规范。平台鼓励作者创作清晰、准确反映内容的优质标题，反对为获取点击而乱起标题。一经发现违规标题，将严肃处理。
不符合平台规范的标题情况，包括但不限于以下情况：
一、标题夸张
1、夸张式标题
标题使用「震惊」、「惊爆」、「传疯」、「吓掉半条命」等，言过其实地表达情绪/状态/感受；
标题使用「全世界网友」、「所有男人都」、「某国人」、「99%」等，进行无依据的范围夸大；
标题使用「XX天见效」、「根治」、「立竿见影」等，对效果或结果做不符合常识的断言或保证；
标题使用「重磅」、「要命」、「就在刚刚」等，对事件的严重和紧急程度夸张形容，引起过度警觉和关注；
标题使用「世界之最」、「最高级」、「最佳」、「最烂」等，形容人事物在某些程度上达到极致，但违背事实和大众认知。
————————————————
版权声明：本文为CSDN博主「CSDN官方博客」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/blogdevteam/article/details/105087689
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ebe47c57a33e3446ffcf63bd2f2ff16/" rel="bookmark">
			ASM入网小助手卸载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有些公司或者政府内网的上网认证是用的ASM小助手，不过有时候用自己电脑接入公司内网可能会主动下载到ASM入网小助手的安装包。
如果一不小心双击了安装包，软件就会自动安装，这个软件是无法在控制面板&gt;程序卸载里卸载的，并且可能会禁用我们的U盘。
第一种方法：使用ollydbg卸载小助手
亲自测试，卡在了ollydbg打开汇编文件。
飞机
没有找到划红线的指令。
第二种： 电脑进入安全模式
安全模式，就是电脑只加载基本软件。第三方软件不加载。
然后，把小助手的安装文件夹，修改个名字，让它无法启动。
参考
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50853918a697e6e343fe08ef20c58f85/" rel="bookmark">
			Java选择题集合（四）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说明：这里是怀化学院java考试平台题库里的题，为了方便将题整理出来，但题库还在不断更新中，故此集合整理的题最新截止至发布时间，我将正确答案用红色粗体标注，但这里大概有226道选择题，我将题集分为四个部分，这里是第四部分（181-226），由于题量较大，整理时难免会将某些题的答案标错，如有错误，请各位读者给出 Java选择题集合目录：
Java选择题集合（一）
Java选择题集合（二）
Java选择题集合（三）
Java选择题集合（四）
果str表示一个String对象“73”，那么以下哪些表达式将会把这个字符串转换为int值73？请选出正确答案。（ ）
A、((int) str)
B、(new Integer(str)).intValue()
C、Integer.intValue(str)
D、Integer.getInt(str) 下列哪个类的声明是正确的？（ ）
A、public abstract class Car{}
B、abstract final class HI{}
C、protected private number
D、abstract private move(){} 以下声明合法的是（ ）
A、abstract final double hyperbolicCosine( )
B、 public final static native int w( )
C、abstract double d
D、default String 类Test1定义如下：
1．public class Test1{
2． public float aMethod（float a，float b）{ }
3． 4．}
将以下哪种方法插入行3是不合法的。（ ）
A、public int aMethod（int a， int b）{ }
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/50853918a697e6e343fe08ef20c58f85/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca197f18d0bf995a7a64f9dce4408f0e/" rel="bookmark">
			Spring Boot整合neo4j
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring Boot整合neo4j spring-data-neo4j
版本：springboot 2.3.5 spring-data-neo4j:5.3.5
https://docs.spring.io/spring-data/neo4j/docs/5.3.5/reference/html/#getting-started
添加neo4j依赖
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-neo4j&lt;/artifactId&gt; &lt;/dependency&gt; 添加配置
（注意：不同版本依赖配置可能不一样），可通过neo4j自动配置类查看
# neo4j配置 spring.data.neo4j.uri= bolt://localhost:7687 spring.data.neo4j.username=neo4j spring.data.neo4j.password=12345 创建实体
@NodeEntity：标明是一个节点实体 @RelationshipEntity：标明是一个关系实体 @Id：实体主键
@Property：实体属性 @GeneratedValue：实体属性值自增 @StartNode：开始节点（可以理解为父节
点） @EndNode：结束节点（可以理解为子节点）
import lombok.Data; import java.io.Serializable; @Data @Builder @NodeEntity("person") public class Person implements Serializable { @Id @GeneratedValue private Long id; @Property("name") private String name; } @Data @NoArgsConstructor @RelationshipEntity(type = "徒弟") public class PersonRelation implements Serializable { @Id @GeneratedValue private Long id; @StartNode private Person parent; @EndNode private Person child; @Property private String relation; public PersonRelation(Person parent, Person child, String relation) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca197f18d0bf995a7a64f9dce4408f0e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/591871554406d95c19639a4282be3d26/" rel="bookmark">
			大数据技术Flink开发环境准备和API代码案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Flink开发环境搭建和API基础学习 1、Flink简介2、maven工程环境准备3、Flink流处理API3.1 Environment3.2 Source 4、代码案例：统计单词(wordCount) 1、Flink简介 看到下面这只可爱的松鼠，显然它不仅是一直普通的松鼠，它还是Flink的项目logo，我们都知道计算机领域很多应用和项目都会使用一只动物作为代表。先来看看这只小动物的意义！
在德语中，Flink 一词表示快速和灵巧，项目采用一只松鼠的彩色图案作为 logo与之呼应，因为柏林的松鼠有一种迷人的红棕色，而 Flink 的松鼠 logo 拥有可爱的尾巴，尾巴的颜色与 Apache 软件基金会的 logo 颜色相呼应，也就是说，这是一只 Apache 风格的松鼠。
对于不熟悉大数据相关的，可以不了解Flink是做什么用的，所以接下来认识一下！
Apache Flink 是一个框架和分布式处理引擎，用于对无界和有界数据流进行有
状态计算。Flink 被设计在所有常见的集群环境中运行，以内存执行速度和任意规模来执行计算。
看到这里，可以猜测出Flink的功能和使用场景：（1）数据处理引擎。（2）分布式架构。（3）计算速度快，适用大规模数据。
有界和无界数据流是什么呢？
这里先认识一下流处理的概念：
流处理是无界、实时的, 无需针对整个数据集执行操作，而是对通过系统传输的每个数据项执行操作，一般用于实时统计。
看完之后，就知道数据流是何物了。而有界和无界在Flink中的区分就是数据的存在形式：离线数据是有界限的流，实时数据是无界限的流。
以流式处理的好处就是取得更低的延迟。
Flink的架构分为多层的API，包括底层的ProcessFunction，中间的DataStream API和顶层的Analytics API，通常使用中间的API比较多，用户可以自定义数据处理方式，也是最丰富和表达能力最好的一层。另外，最高级层就是Flink SQL，直接使用SQL表达式来交互，不过这个模块并不完善。
2、maven工程环境准备 现在使用IDEA创建maven工程，为后面代码编写做准备。
项目创建好之后，准备编程环境，Flink支持Java和Scala编程，scala在这里常用，需要在IDEA中下载插件支持。
这样IDEA就支持scala文件，可以自动识别scala和创建文件。
然后可以创建一个test.scala文件试试，一般IDEA会告诉你需要按照Scala SDK，直接点击按照即可，就不需要自己去下载安装包按照，其他按照SDK方法可以参考：Scala SDK安装方法。
自动识别到没有Scala环境，我们就Create一个。
完成之后可以看到SDK的包。
3、Flink流处理API 3.1 Environment 创建一个执行环境，表示当前执行程序的上下文。 如果程序是独立调用的，则
此方法返回本地执行环境；如果从命令行客户端调用程序以提交到集群，则此方法
返回此集群的执行环境，也就是说，getExecutionEnvironment 会根据查询运行的方式决定返回什么样的运行环境，是最常用的一种创建执行环境的方式。
val env = ExecutionEnvironment.getExecutionEnvironment //创建执行环境 val env = StreamExecutionEnvironment.getExecutionEnvironment 3.2 Source 表示数据的来源，可以来自一个集合、文件、消息队列kafka等，还可以自定义数据源。
集合 import org.apache.flink.api.scala._ case class dataFromSet(id:String,timestamp: Long,temperature:Double) object Sensor{ def main(args: Array[String]): Unit = { val env = ExecutionEnvironment.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/591871554406d95c19639a4282be3d26/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6304ebaa3facc520db1e275aa756d8b/" rel="bookmark">
			Dart | flutter sdk 安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 什么是 flutter ？ Flutter是Google开源的构建用户界面（UI）工具包，帮助开发者通过一套代码库高效构建多平台精美应用，支持移动、Web、桌面和嵌入式平台。 Flutter 开源、免费，拥有宽松的开源协议，适合商业项目。
1.1 Flutter 特性 快速开发 Flutter的热重载帮助你快捷方便的试验、重构UI、添加特性和修复bug。在仿真器、模拟器和ios、android硬件上体验亚秒级的重载，而不会丢失状态
绚丽UI 通过Flutter内建的漂亮的质感设计和Cupertino（ios-flavor）小工具、丰富的动画API，平滑的自然滚动和平台感知，让用户感到满意。
响应式 通过Flutter的现代响应式(Reactive)框架和丰富的平台布局和基础组件轻松构建您的用户界面。用强大而灵活的API解决2D、动画、手势、效果等难题。
访问原生功能 通过平台api、第三方sdk和原生代码使您的应用变得生动起来。Flutter让您可以重用您现有的java、swift和Objc代码，并在iOS和Android上访问原生特性和SDK。
1.2 框架结构 Flutter的主要结构包括：
Flutter engine 用C++编写，实现了Flutter的核心库，包括Dart虚拟机、动画和图形、文字渲染、通信通道、事件通知、插件架构等。引擎渲染采用的是2D图形渲染库Skia，虚拟机采用的是面向对象语言Dart VM，并将它们托管到平台的中间层代码(Embedder)
Framework(Dart) 该层是Dart库，google实现一套用Dart语言开发的基础库，包括Widget，手势，绘图，动画等，有Material和Cupertino风格
Embedder(Platform Specific) 嵌入层，为Engine创建和管理线程，作用是把Engine的Task Runners（任务运行器）运行在嵌入层管理的线程上
2 安装 flutter SDK 2.1 windows 下安装 flutter SDK 从GitHub 上的Flutter repo获取源代码，并根据需要更改分支或标签。例如：
C:\src&gt;git clone https://github.com/flutter/flutter.git -b stable 然后，在 flutter 控制台中运行flutter命令。
注意：从 Flutter 的 1.19.0 开发版本开始，Flutter SDK 包含dart命令旁边的flutter 命令，以便您可以更轻松地运行 Dart 命令行程序。下载 Flutter SDK 也会下载 Dart 的兼容版本，但如果您已经单独下载了 Dart SDK，请确保dart您的路径中首先包含 Flutter 版本，因为这两个版本可能不兼容。以下命令告诉您flutter和dart 命令是否来自同一bin目录并因此兼容。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d6304ebaa3facc520db1e275aa756d8b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d918e89f592e4ab1c3a8ce7946f3c053/" rel="bookmark">
			矩阵分析与应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		矩阵的基本运算
幂等矩阵：若矩阵有，则称为幂等矩阵。
对合矩阵：若矩阵有，则称为对合矩阵。
内积：两个矩阵之间的内积是与矩阵乘积密切相关的运算。
矩阵A和B的内积记作
矩阵的指数:
矩阵的对数:
矩阵的导数：如果矩阵A的元素都是参数t的函数，则矩阵的导数定义为：
矩阵的积分：
矩阵的指数函数：
矩阵的指数函数的导数：
矩阵乘积的导数：其中A,B都为变量t的矩阵函数。
向量的线性无关性与线性相关性
m*n的线性方程组可以写为Ax=b的形式，若记,则方程可以简化为：
称为列向量的线性组合。
若方程仅有零解。则该组向量线性无关。
若存在一组不全为零的系数使得上述方程成立，则该组向量线性相关。
向量的非奇异矩阵
若有一个n*n的矩阵A，当且仅当矩阵方程Ax=0只有零解x=0时，则该矩阵为非奇异的。若A不是非奇异的，则称A奇异。
若n*n的矩阵A是非奇异的，当且仅当它的n个列向量线性无关。
初等行变换与阶梯型矩阵
初等行变换：
令m*n的矩阵A的m个行向量分别为。下列运算称为矩阵A的初等行运算或初等行变换：
（1）互换矩阵的任意两行。
（2）一行元素同时乘以一个非零常数。
（3）将第p行的元素同时乘以一个非零常数并加给第q行。
阶梯型矩阵：
若一个m*n的矩阵满足
（1）全部由零组成的所有行都位于矩阵的底部。
（2）每一个非零行的首项元素总是出现在上一个非零行的首项元素的右边。
（3）首项元素下面的同列元素全部为零。
简约阶梯型：
若一个阶梯型矩阵的每一非零行的首项元素都等于1，并且每一个为1的首项元素都是它所在列的唯一的非零元素，则这个矩阵为简约阶梯型矩阵。
如：
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/264/">«</a>
	<span class="pagination__item pagination__item--current">265/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/266/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>