<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c49baff765301af6cf311cea42515d22/" rel="bookmark">
			Python 小工具下载baidu-Pic
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import os import requests import re num = 0 numPicture = 0 file = '' List = [] # global num global num1 def dowmloadPicture(html, keyword): global num # t =0 pic_url = re.findall('"objURL":"(.*?)",', html, re.S) # 先利用正则表达式找到图片url if not os.path.exists('./' + keyword): os.mkdir('./' + keyword) path = './' + keyword print('找到关键词:' + keyword + '的图片，即将开始下载图片...') for each in pic_url: if num &lt; int(num1): print('正在下载第' + str(num + 1) + '张图片，图片地址:' + str(each)) try: if each is not None: pic = requests.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c49baff765301af6cf311cea42515d22/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13fe42b88ecbb7e3a13bbb73ef1461c7/" rel="bookmark">
			安卓android向onenet物联网云平台请求数据（接入协议mqtts）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用android向onenet物联网云平台请求数据
第一步： 在manifest加入&lt;uses-permission android:name="android.permission.INTERNET"/&gt;，如图所示：
第二步： 在xml文件夹中创建一个名为“network_security_config”的xml文件，如图所示：
其内容为：
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;network-security-config&gt; &lt;base-config cleartextTrafficPermitted="true"&gt; &lt;trust-anchors&gt; &lt;certificates src="system" /&gt; &lt;/trust-anchors&gt; &lt;/base-config&gt; &lt;/network-security-config&gt; 第三步： 由于本人是用okhttp进行网络请求的，所以需要在build.gradle中加入此句：
implementation 'com.squareup.okhttp3:okhttp:3.10.0'
okhttp有很多版本，最新版可通过其官网查看Overview - OkHttp (square.github.io)
第四部： 上代码！！
package com.example.???; import androidx.annotation.RequiresApi; import androidx.appcompat.app.AppCompatActivity; import java.io.IOException; import java.util.Arrays; import okhttp3.Call; import okhttp3.Callback; import okhttp3.FormBody; import okhttp3.OkHttpClient; import okhttp3.Request; import okhttp3.Response; import android.os.Build; import android.os.Bundle; import android.os.StrictMode; import android.util.Log; import android.view.View; import android.widget.Button; import android.widget.TextView; import org.json.JSONArray; import org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13fe42b88ecbb7e3a13bbb73ef1461c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f40160398452b68359950505539f7bba/" rel="bookmark">
			.tar和.tar.gz的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		tar只是将文件打包，文件的大小没什么变化，一般用tar -cvf filename.tar filename格式；.tar.gz是加入了gzip的压缩命令，会将文件压缩存放，可以有效压缩文件的大小，以便于缩短传输时间或者释放磁盘空间，一般用tar -czvf filename.tar.gz filename。
解包的时候使用 tar -xvf filename.tar和tar -xzvf filename.tar.gz。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f698f4af79486cf4cdfb3044aa801f00/" rel="bookmark">
			OpenGL学习预备篇——使用premake配置SOIL2库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前言 在这篇博客中，我们来了解一下SOIL2的安装，以及在安装过程中我觉得需要注意的点。
行文目录 前言SOIL2介绍SOIL下载premake下载premake SOILSOIL2文件整理VS2019中的配置 SOIL2介绍 SOIL是简易OpenGL图像库(Simple OpenGL Image Library)的缩写，它支持大多数流行的图像格式，使用起来也很简单。当前的最新版本是SOIL2。
SOIL下载 https://github.com/SpartanJ/SOIL2/releases
上面已经给出了SOIL2的github地址，我们可以点进去，此时我们会发现没有发布版本了
但是不用慌，我们再点一下tag，就可以看到并下载啦，博主这里选择的release 1.2.0
premake下载 首先什么是premake，相信大家都听说过cmake，cmake就是会将我们下载的源码生成工程环境，premake也是通过读取项目脚本，来生成各种开发环境的项目文件。如果更喜欢用cmake也可以使用cmake。
可以去premake的网站： https://premake.github.io/download下载premake，根据自己的系统选择对应的版本。博主自己是windows系统，于是选择下载windows版本的。现在默认下载的是premake-5.0.0
premake SOIL 将下载下来的SOIL和premake进行解压，并将premake5.exe放进SOIL文件夹中，文件夹结构如下所示：
之后我们在此路径下进入控制台，即在文件夹的路径栏输入“cmd”。当然也可以直接在命令行中通过cd指定进入该目录。
在命令行中输入premake5.exe vs2019，因为博主这里用的vs2019，如果你是vs2017，那么可以输入premake5.exe vs2017，依次类推。我们看到最后一行是Done就表明我们make完了。
此时文件夹中会多出一个make的文件夹
进入make文件夹，再进入windows文件夹，可以找到SOIL.sln文件，我们双击打开这个VS项目文件。
进入解决方案资源管理器，对soil2-static-lib右键，点击生成，这里有个要注意的地方就是我们的环境最好和我们的工程一致，否则后面会报错LINK2019错误，找不到lib文件。比如博主这里就改成了和工程一样的×64。修改的位置在我最上面的红圈处。
编译完我们可以获取两个文件夹：lib和obj
SOIL2文件整理 然后我们新建一个文件夹，这里博主命名为SOIL2tool，里面新建两个文件夹，一个是lib，一个叫include。如下所示：
我们之后进入SOIL2-release-1.20文件夹中，即我们刚刚premake的那个文件夹，找到lib文件夹进去，继续进入windows文件夹，找到soil2-debug.lib文件，将其复制进我们刚创建的新文件夹SOIL2tool下的lib文件夹下。
返回SOIL2-release-1.20文件夹中，找到src文件夹进去，将整个SOIL2文件夹复制进我们刚创建的新文件夹SOIL2tool下的include文件夹下。
VS2019中的配置 打开项目属性，打开方式是项目 -&gt; 属性
点击VC++目录 -&gt; 包含目录，在其中添加我们刚刚新建文件夹SOIL2tool下的include文件夹
点击VC++目录 -&gt; 库目录，在其中添加我们刚刚新建文件夹SOIL2tool下的lib文件夹
点击C/C++ -&gt; 常规，在其中添加我们刚刚新建文件夹SOIL2tool下的include文件夹
点击链接器 -&gt; 常规 -&gt; 附加库目录，在其中添加我们刚刚新建文件夹SOIL2tool下的lib文件夹
点击链接器 -&gt; 输入 -&gt; 附加依赖项，在其中添加我们soil2-debug.lib文件
现在完成了所有配置啦，可以开始使用SOIL库了。使用以下代码即可包含进SOIL库
#include &lt;SOIL2/SOIL2.h&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95d9839ef68ea3c4bef217cc44f5f8d1/" rel="bookmark">
			GPT-3：自然语言处理的里程碑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这篇文章介绍了目前最先进的自然语言处理技术之一——GPT-3，并探讨了它的应用、潜在风险以及未来的发展方向。
首先，文章介绍了GPT-3的基本原理和技术特点。GPT-3是一种基于深度学习的自然语言处理模型，它可以自动产生高质量、流畅的文本，并实现多种语言的翻译、生成等任务。GPT-3之所以被认为是自然语言处理领域的里程碑，是因为它可以生成极为自然的文本，几乎难以区分真假。
然后，文章探讨了GPT-3的应用场景。GPT-3的应用非常广泛，包括智能客服、智能写作、语音识别、翻译、语言模型训练等方面。它可以大幅度提高自然语言处理任务的准确性和效率，并帮助人们更快地完成各种文本相关的任务。
接着，文章分析了GPT-3的潜在风险。由于GPT-3可以产生极为自然的文本，它可能被用于虚假信息、欺诈和其他不良行为。此外，它也可能加剧不平等问题，因为只有那些拥有大量计算资源的人才能够使用它。同时，GPT-3的出现也引发了一些哲学和道德上的问题，例如机器生成的文本应该由谁负责？
最后，文章展望了GPT-3的未来发展方向。尽管GPT-3在自然语言处理领域取得了重大突破，但它仍然存在一些局限性。未来的发展方向包括改进语义理解、提高生成文本的可控性、实现多模态自然语言处理等方面。同时，我们也需要警惕潜在的风险，并在使用GPT-3时保持警觉。
总的来说，本文介绍了GPT-3技术的基本原理和应用，分析了它的潜在风险，并展望了未来的发展方向。通过本文的阅读，读者可以更好地了解自然语言处理领域的最新进展，以及这一技术对人类社会的影响和挑战。
详情请阅读：https://download.csdn.net/download/Oliver9987/87579879?spm=1001.2014.3001.5503
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d971ec3b16231bba66fd781a5785cdc3/" rel="bookmark">
			递归寻找子集单位指定类型的上级部门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 public String getParent(List&lt;AssetsOrg&gt; orgs, AssetsOrg orgId){ for (AssetsOrg assetsOrg : orgs) { if (assetsOrg.getId().equals(orgId.getParentId())){ if ("1".equals(assetsOrg.getOrgType())){ return assetsOrg.getName(); }else { return getParent(orgs,assetsOrg); } } } return ""; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb0e48e98b51c26eaa1d8457d73ef7af/" rel="bookmark">
			微信小程序设置背景图的几种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作为前端开发人员来说设置背景图那是多么简单的事，刚开始我就在wxss文件中使用background-image:url()来设置背景图片，结果保存控制台出现错误提示，如图所示：
.page {
width: 100%;
height: 100%;
background-size: 100% 100%;
position: relative;
color: #fff;
background-image: url(’../../../assets//icon-home.png);
}
提示wxss中的本地资源图片无法通过 WXSS 获取，可以使用网络图片，或者 base64，或者使用&lt;image/&gt;标签。
然后我想着能不能在wxml文件引入本地图片，说干就干：
&lt;view class="page" style="background-image: url('../assets/icon-home.png');"&gt;&lt;/view&gt; 在开发工具上显示ok，结果拿着手机预览，图片显示不出来，看来这种也不行，哎只能乖乖的按那三种提示进行设置背景图片啦
1.使用网路图片：
&lt;view class="page" style=" background-image: url('{{ossHost}}nmxy/assets/home/bg.png');"&gt;&lt;/view&gt; 2.base64格式的图片,访问图片转 BASE64 编码 | 菜鸟工具上传图片生成base64
&lt;view class="page" style=" background-image: url('data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAkACQAAD/4QB0RXhpZg***********************ooogD//Z');"&gt;&lt;/view&gt; 3.使用&lt;image&gt;标签
&lt;view class="page" &gt;
&lt;image src="../assets/bg.png"&gt;&lt;/image&gt;
&lt;/view&gt;
image {
position: absolute;
left: 0;
bottom: 0;
display: block;
width: 100%;
height: 100%;
z-index: -999;
}
文章来自于：码书网
作者：漫思，转载请注明原文链接：https://www.cnblogs.com/sexintercourse/p/17078520.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a43acb8580c5a22014a460d7616dede5/" rel="bookmark">
			蜉蝣于天地之旅
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面 很久没写CSDN了。至今还是不知道什么才是我想要。忽而感觉自己的人生不过是苏轼词中的“蜉蝣”，寄于天地，渺沧海之粟。
太过渺小了。
还有那么多的学问没去探究，还有那么广大的天地没去探索。生命很短暂，不愿在悔恨中度过这一生。所以还有很多的书要去读，还要活得彻底，燃烧得热烈。
已经逐渐明白，自己年少时的梦想再也没有机会实现了。可不甘心就这样，就这样只好按部就班，就这样看得见自己的命运。想做那天上自由的云，不知去往何方。人生当如旷野，自由且无畏。且年轻，诗酒趁年华。要以热烈的姿态活着，要成为人生自传中了不起的那个人。
蜉蝣于天地 计算机的学问太多了。本科毕业的自己，不过是企业流水线中的螺丝钉罢了。但人不应该甘心于做螺丝钉。如今的社会存在一个趋势，农村中产化，实质是整个社会的贫富差距越来越大了。努力也比不过资本，这些话暂且不谈。我的思想还是太过简单，肚子里的墨水太少，不敢对此类话题过于深究。
人应该要怎么活着？没有人可以定义。但在我的想象中，我应该要关注社会，要熟读历史，对诗词歌赋有所涉猎，对自己的国家有所贡献。倘若只是心甘情愿作为一颗螺丝钉，整日以度过工作时间为目标，那么度过了今年剩下的只有年轮，按部就班的活着。或许会体验生活中的新奇，或许会得到平常的幸福，但至少我自己来说，我得不到内心的宁静。心里总有一股声音告诉我，但不做普通人，像我这样的人怎么可能随便找到。
学问太多，而平台太低，时间太少，自己太废。从实际的入手，一个java的Spring项目很难吗？可是自己却无从下手，从未主动去学习优秀的项目。每天把时间交给了虚无。还有计算机的前沿领域，我已经两眼黑了。或许我不适合计算机吧。
不过是蜉蝣，但不可失凌云之志。
人生之旅 不可以活得混沌。
人生有诗歌，有音乐，有美学，这些都是浪漫之源。人要浪漫的活着，人要炽烈的活着。
曾有人跟我讲过，二十到三十这十年是实现梦想的最好机会。现以过三分之一，我好像没有完成任何事。我的目标又有几何，我的灵魂又该何往。那自由撒欢的灵魂，应当何处安放。
到底还是走错了路，却又没有从头再来的勇气。所以虚度了光阴，忽略了人的成长。眼中的光还在吗？如今对人生再也没有了期待，真是危险。再也想象不出来未来的模样，因为一切想象的模样都不可能实现了。完美主义者的噩梦。有的东西如果得不到，那么宁愿不要。我就是这样的人，是一个理想主义者。可是要被迫接受这现实主义太难了。真的太难了。
要自由且无畏。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4175c2f309c8f43c0ff99d3219b2358/" rel="bookmark">
			四种确定K-means最佳聚类个数的方法（K-means&#43;&#43;）——附代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
摘要：
1.K-means算法
2.Calinski-Harabasz Criterion（卡林斯基-哈拉巴斯指标，CH值）
3.Davies-Bouldin Criterion（戴维斯-博尔丁指标，DB值）
4.Gap Value（Gap值）
5.Silhouette Coefficient（轮廓系数）
6.基于Matlab的K-means聚类及最佳聚类数选取结果：
7.本文Matlab代码实现：
摘要： Kmeans算法中，K值所决定的是在该聚类算法中，所要分配聚类的簇的多少。Kmeans算法对初始值是⽐较敏感的，对于同样的k值，选取的点不同，会影响算法的聚类效果和迭代的次数。本文通过计算原始数据中的：CH值、DB值、Gap值、轮廓系数，四种指标来衡量K-means的最佳聚类数目，并使用K-means进行聚类，最后可视化聚类的结果。
本文代码已做标准化处理，导入自己数据即可使用，十分方便
通过该代码即可确定最佳的聚类个数，适合数学建模等应用
1.K-means算法 k均值聚类算法（k-means clustering algorithm）是一种迭代求解的聚类分析算法，其步骤是，预将数据分为K组，则随机选取K个对象作为初始的聚类中心，然后计算每个对象与各个种子聚类中心之间的距离，把每个对象分配给距离它最近的聚类中心。聚类中心以及分配给它们的对象就代表一个聚类。每分配一个样本，聚类的聚类中心会根据聚类中现有的对象被重新计算。这个过程将不断重复直到满足某个终止条件。终止条件可以是没有（或最小数目）对象被重新分配给不同的聚类，没有（或最小数目）聚类中心再发生变化，误差平方和局部最小。
​
K-means的计算步骤：
2.Calinski-Harabasz Criterion（卡林斯基-哈拉巴斯指标，CH值） 卡林斯基-哈拉巴斯准则有时被称为方差比准则（VRC）。卡林斯基-哈拉巴斯指数定义为
其中，SSB是总体簇间方差，SSW是总体簇内方差，k是簇数，N是观测数。
定义良好的簇具有较大的簇间方差（SSB）和较小的簇内方差（SSW）。VRCk比率越大，数据分区越好。要确定最佳聚类数，最大化关于k的VRCk。最佳聚类数对应于具有最高卡林斯基-哈拉巴斯指数值的解。
卡林斯基-哈拉巴斯准则最适合于具有平方欧几里德距离的k均值聚类解。
3.Davies-Bouldin Criterion（戴维斯-博尔丁指标，DB值） Davies-Bouldin 准则基于聚类内距离和聚类间距离的比率。戴维斯-博尔丁指数定义为：
其中，Di，j是第i个和第j个簇的簇内到簇间距离比。在数学上：
di是第i个簇中每个点与第i个簇的质心之间的平均距离。dj是第j个簇中每个点与第j个簇的质心之间的平均距离。dij是第i个和第j个簇的质心之间的欧氏距离Dij的最大值表示簇i的最坏簇内-簇间比率。最优聚类解决方案具有最小的Davies Bouldin指数值。
4.Gap Value（Gap值） 一个常见的聚类评估的图形方法是将误差测量值与几个建议的聚类数量作对比，并找出这个图形的 "肘部"。肘部 "出现在误差测量的最大幅度下降处。差距标准通过将 "肘部 "的位置估计为具有最大差距值的聚类的数量来正式确定这一方法。因此，在差距准则下，最佳的集群数量对应于在一个容忍范围内具有最大的局部或整体差距值的解决方案。具体公式如下：
其中，n是样本量，k是被评估的聚类数量，Wk是聚类内分散度的集合测量。
5.Silhouette Coefficient（轮廓系数） 每个点的轮廓系数是衡量该点与同一聚类中的其他点的相似程度，与其他聚类的点相比。第i个点的轮廓系数si定义为：
其中，ai是第i个点到与i相同聚类中其他点的平均距离，bi是第i个点到不同聚类中的点的最小平均距离，在聚类中最小。如果第i点是其聚类中唯一的点，那么轮廓系数si被设置为1。轮廓系数的范围从-1到1。一个高的轮廓系数表明该点与它自己的聚类匹配良好，而与其他聚类匹配较差。如果大多数点有一个高的轮廓系数，那么聚类方案是合适的。如果许多点的轮廓系数较低或为负值，那么聚类方案可能有太多或太少的聚类。可以用轮廓系数作为任何距离指标的聚类评估标准。
6.基于Matlab的K-means聚类及最佳聚类数选取结果： 各种指标评价图像：
​通过该程序即可选取最适合的K-means聚类数目
K-means聚类结果可视化：
7.本文Matlab代码实现： 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6708ff2b72d68a127d9c651fe5e6b23a/" rel="bookmark">
			C#中将字符串转化为字符串数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目：将字符串转化为字符串数组，字符串中有“，”隔开，每一个“，”前面的内容形成每一组数组的每一段的内容。 代码如下： 1.用函数写： using System; namespace _3._14town { class Program { static void Main(string[] args) { string str = ",ab,cad,dd,edas,fasdwasd,gasdq,";//创建一个长度任意的数组 string[] str1 = newstr(str); //定义一个新的数组 for (int i = 0; i &lt; str1.Length; i++) { if (str1[i]!=null) //遍历时，当输出为空的时候不输出，这样不会出现换行的情况 { Console.WriteLine(str1[i]); } } } static string[] newstr(string str) //创建一个数组的函数并使用 { int count1 = count(str); //获取数组的长度 string[] str1 = new string[count1];//在C#中，数组的长度是不可更改的。一旦数组被创建，其长度就会被固定下来。 int index = 0;//下标 for (int i = 0;i &lt; str.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6708ff2b72d68a127d9c651fe5e6b23a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9ae0e037a60e6bcf13bae812ea9154b/" rel="bookmark">
			MySQL 中的 UNION 语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、数据准备一、UNION 和 UNION ALL二、UNION 的执行顺序（UNION 和其他语句一同出现）三、MySQL 使用 UNION（ALL） + ORDER 导致排序失效四、UNION 报错语法 一、数据准备 -- 创建表 CREATE TABLE test_user ( ID int(11) NOT NULL AUTO_INCREMENT, USER_ID int(11) DEFAULT NULL COMMENT '用户账号', USER_NAME varchar(255) DEFAULT NULL COMMENT '用户名', AGE int(5) DEFAULT NULL COMMENT '年龄', COMMENT varchar(255) DEFAULT NULL COMMENT '简介', PRIMARY KEY (ID) ) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8; -- 数据插入语句 INSERT INTO test_user (ID, USER_ID, USER_NAME, AGE, COMMENT) VALUES ('1', '111', '开心菜鸟', '18', '今天很开心'); INSERT INTO test_user (ID, USER_ID, USER_NAME, AGE, COMMENT) VALUES ('2', '222', '悲伤菜鸟', '21', '今天很悲伤'); INSERT INTO test_user (ID, USER_ID, USER_NAME, AGE, COMMENT) VALUES ('3', '333', '认真菜鸟', '30', '今天很认真'); INSERT INTO test_user (ID, USER_ID, USER_NAME, AGE, COMMENT) VALUES ('4', '444', '高兴菜鸟', '18', '今天很高兴'); INSERT INTO test_user (ID, USER_ID, USER_NAME, AGE, COMMENT) VALUES ('5', '555', '严肃菜鸟', '21', '今天很严肃'); SELECT * FROM test_user u; 一、UNION 和 UNION ALL UNION
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c9ae0e037a60e6bcf13bae812ea9154b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d5bd84557bd87c584e28d537eae2e0d/" rel="bookmark">
			使用xlsx.js完成Excel批量数据导入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用xlsx.js完成Excel批量数据导入 直接上代码 需要引入的 xlsx.js 文件地址 https://gitcode.net/mirrors/SheetJS/sheetjs/-/blob/master/xlsx.js
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .btn_color{ color: blue; } &lt;/style&gt; &lt;/head&gt; &lt;!-- 此处需要引入的js文件 --&gt; &lt;script src="xlsx.js"&gt;&lt;/script&gt; &lt;body&gt; &lt;input type="file" id="file" style="display: none;"/&gt; &lt;button class="btn_color" onclick="importBatch()"&gt;批量导入&lt;/button&gt; &lt;script type="text/javascript"&gt; function importBatch(){ document.getElementById('file').click(); } // 读取本地excel文件 function readWorkbookFromLocalFile(file, callback) { var reader = new FileReader(); reader.onload = function(e) { var data = e.target.result; var workbook = XLSX.read(data, {type: 'binary'}); if(callback) callback(workbook); }; reader.readAsBinaryString(file); }	function readWorkbook(workbook) { var sheetNames = workbook.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d5bd84557bd87c584e28d537eae2e0d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfc008009f8646792596f9c88ecc59d3/" rel="bookmark">
			vue2 ant-design记忆表头列表页面组件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		git地址：项目git地址(https://github.com/hgg111/vue2AntdTablePage.git)
实现效果：
代码：
RemberTableHeader.vue组件： 记忆表头组件。将用户选择展示的表头数组存储在 localStorage 中，进入页面时读取，实现记忆表头功能。
&lt;template&gt; &lt;div style="position: absolute;right: -5px;width: 30px;background-color: #f5f7fd;"&gt; &lt;a-popover placement="bottomRight" :arrow="true"&gt; &lt;a&gt;&lt;a-icon type="setting"&gt;&lt;/a-icon&gt;&lt;/a&gt; &lt;template slot="title"&gt; 表头显示字段 &lt;/template&gt; &lt;template slot="content"&gt; &lt;div style="max-height: 200px;overflow-y: auto;"&gt; &lt;div&gt; &lt;a-checkbox value="all" :checked="checkedAll" @change="allChange"&gt;全选&lt;/a-checkbox&gt; &lt;/div&gt; &lt;a-checkbox-group v-model="tableHeader" style="display:flex;flex-direction: column;align-items: flex-start;" @change="tableHeaderChange"&gt; &lt;a-checkbox v-for="item in tableHeaderOptions" :key="item" :value="item"&gt;{{ item }}&lt;/a-checkbox&gt; &lt;/a-checkbox-group&gt; &lt;/div&gt; &lt;/template&gt; &lt;/a-popover&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { props: { // 表头 allColumns: { type: Array, default: ()=&gt;[], }, // 表名（唯一） tableName: { type: String, default: '' }, // 是否有报告操作列 hasReportAction: { type: Boolean, default: false }, // 是否有基本操作列 hasAction: { type: Boolean, default: true }, // 是否有序号列 hasXuhao: { type: Boolean, default: true }, }, data() { return { // 全选框的状态 checkedAll: true, // 所有可选择的表头 tableHeaderOptions: [], // 选择的表头 tableHeader: [], // 操作列内容 actionContent: [], // 报告操作列内容 reportActionContent: [], // 序号列内容 xuhaoContent: [], }; }, watch:{ allColumns: { handler(newVal) { if(newVal.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cfc008009f8646792596f9c88ecc59d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ed0286eeac1fa44c115db39b99f5b06/" rel="bookmark">
			vCenter密码过期策略修改
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vcenter密码提示过期，但是修改密码时，没有发现永久不过期选项；
通过官网查询，可在vc的高级配置里定义，适用于6.5-7.0的vc，如下图所示：
页面修改，如下图所示：
1、登陆到vcenter后，找到菜单-系统管理
2、左侧找到配置-密码策略-修改最长生命周期
3、点击右侧编辑-输入你希望修改的密码周期 0表示永不过期
最后确认即可！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fdf0b3995448941509da4588771d6408/" rel="bookmark">
			论文阅读：Towards Stable Test-time Adaptation in Dynamic Wild World
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天阅读ICLR 2023 ——Towards Stable Test-time Adaptation in Dynamic Wild World
Keywords：Test-time adaptation (TTA)；
文章目录 Towards Stable Test-time Adaptation in Dynamic Wild WorldProblem：motivation：Contributions:IntroRelated workAdaptation without Target Data.Adaptation with Target Data.1. Unsupervised domain adaptation (UDA)2. Test-time adaptation (TTA) Sharpness-aware Minimization (SAM) WHAT CAUSES UNSTABLE TEST-TIME ADAPTATION?Batch Normalization Hinders Stable TTA.Online Entropy Minimization Tends to Result in Collapsed Trivial Solutions, i.e., Predict All Samples to the Same ClassReliable Entropy Minimization methodsSharpness-aware Entropy Minimization ResultBackground：1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fdf0b3995448941509da4588771d6408/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aebf9ff1ba4912151ea894d10d342662/" rel="bookmark">
			普通和hive兼容模式下sql的差异
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		–odps sql
––
–author:宋文理
–create time:2023-03-08 15:23:52
––
– 差异分为三块
– 1.运算符的差异
– 2.类型转换的差异
– 3.内建函数的差异
– 以下是运算符的差异：
– BITAND（&amp;）
– 当输入参数是BIGINT类型的时候，如果BITAND的计算结果是LONG_MIN(-263)，在普通模式下会返回NULL，
– 而Hive模式仍然是LONG_MIN。
select cast((3&amp;5)as string); --返回1
– 示例如下
– 普通模式
set odps.sql.hive.compatible=false;
select cast((a &amp; b) as string) from
values(-9223372036854775807L, -9223372036854775792L) t(a, b);
–返回NULL
– Hive兼容模式
set odps.sql.hive.compatible=true;
select cast((a &amp; b) as string) from
values(-9223372036854775807L, -9223372036854775792L) t(a, b);
–返回-9223372036854775808
Hive
select cast((-9223372036854775807L &amp; -9223372036854775792L) as string);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aebf9ff1ba4912151ea894d10d342662/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a233cc3cf5fae8a24a8fc4bb86229175/" rel="bookmark">
			常用的ubantu命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里写自定义目录标题 常用的ubantu命令ubuntu命令.bashrc, 编辑完之后如何保存退出？ 常用的ubantu命令 ubuntu命令 tar zxvf 文件名 解压文件 ls 将每个由Directory参数指定的目录或者每个由File参数指定的名称写到标准输出
安装cuda时，在执行代码
sudo dpkg -i cuda-repo-ubuntu2004-11-3-local_11.3.0-465.19.01-1_amd64.deb
可能会失败，需要将-i 改成 --install
安装时，执行操作时，如果权限不够，可以先输入sudo sh，然后在这下面输入要执行的命令，然后exit推出。
在linux下安装，
pymarl需要不需要安装docker
安装游戏时，安装SC2.4.10.
smac需要安装
不知道为什么在anaconda中安装虚拟环境时，换源或者加源，或者就是anaconda的源，也都安装不成功，但是把全部的源删除反而可以了，不知道为什么
信任源例子 http://pypi.douban.com/simple --trusted-host pypi.douban.com
恢复默认源 conda config --remove-key channels
通过文件直接修改环境变量配置
打开文件 sudo gedit ~/.bashrc
通过代码 （P.S 打开bashrc之后，先按i键进入insert模式，然后在最后一行输入上面的代码，随后按Esc键退出，之后按Shift+：，然后输入wq加回车退出，会用Ubuntu的忽略哈哈）
可以创建新地图，去靠近庞老师的项目，但是应该有难度，考虑可能性
.bashrc, 编辑完之后如何保存退出？ 这要主要看是用什么程序来编辑文件。
如果是 vi，则：Esc 退出编辑模式，输入以下命令：
:wq 保存后退出 vi，若为 :wq! 则为强制储存后退出（常用）
:w 保存但不退出（常用）
:w! 若文件属性为『只读』时，强制写入该档案
:q 离开 vi （常用）
:q! 若曾修改过档案，又不想储存，使用！为强制离开不储存档案。
:e! 将档案还原到最原始的状态！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf9ae0bb4c92a1fb5a89f96ac7c93262/" rel="bookmark">
			Java的责任链模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 絮絮叨叨 1.1 实际业务场景 1.1.1 学校的奖学金评选 学校的奖学金评选流程如下： 辅导员审核：确认个人信息是否完善、真实系主任审核：根据学生填写的信息，结合自己了解的情况，决定是否推荐该学生参与奖学金评选院长审核：根据学生填写的信息，综合对比候选人，决定该生是否能获得奖学金校长审核：一般，院长审核后的获奖人数都是学校规定的获奖人数，校长只需要同意即可；除非名单公示时，爆出了该生的黑料，取消该生的获奖资格 😂 作为学生，只需要在学校的奖学金评选系统上，诚信地填写自己的信息即可至于，评选能走到哪一步，每一步由谁审批，都不是他关心的。除非，他想搞事情 🤔 1.1.2 公司的请假系统 公司请假系统，业务逻辑如下： 不超过3天的，组长审批超过3天且小于7天的，总监审批超过7天且小于15天的，部长审批超过15天，前端直接拒绝，不会进入审批流程（违反了公司的请假规定） 底层小职员请假，直接去OA系统填写请假申请，生成请假工单系统会根据请假天数，将请假工单派发给对应的审批人 1.2 菜鸟挫挫的实现 哇塞，这个奖学金评选系统好牛逼哦：幸运儿的申请，层层上报，最终会由校长进行审批
哇塞，这个OA系统好智能啊：不同的请假天数，可以到对应审批人的手里
要是我去实现这样一个系统，该怎么做呢？
请假系统倒是好说，直接根据请假天数，来个if-else就可以指定审批人了
但是，奖学金评选系统呢？难道写成这样?
// 辅导员审批 if (isTrue) { instructor.approve(); // 系主任审批 if (isOk) { departmentHead.approve(); // 院长审批 if (isGoodEnough) { dean.approve(); // 校长审批 if (isGood) { headmaster.approve(); } else { System.out.println("很遗憾，未通过全校公示"); } } else { System.out.println("很遗憾，未在学院评选中脱颖而出"); } } else { System.out.println("该生表现欠佳，不予通过"); } } else { System.out.println("信息填写有误，请重新认真填写"); } 我的天，这是什么代码啊，简直像坨屎 🤣
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf9ae0bb4c92a1fb5a89f96ac7c93262/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b30a34753d73017b6f3cad8d250e091/" rel="bookmark">
			CSS基础之定位模式分类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.定位模式分类
1）静态定位static，默认值，通常不做研究
2）相对定位relative
3）绝对定位absolute
4）固定定位fixed
5）粘性定位sticky
2.利用定位调整元素位置思路：
1）先确定用哪种定位模式
2）用偏移值
3.定位特点
1）绝对定位：absolute
特点：（1）从文档流角度：会脱离文档流，不占据位置
（2）层叠顺序：默认按照html代码书写顺序，后者覆盖前者；
可以借助z-index做调整，值越大层级越高，支持负数，不带单位；
（3）参照物：有定位的父级元素，如果这些父级元素都没有定位，就默认按照浏览器窗口的第一屏为参照物。
注意：父级元素定位模式可以是除静态（static）之外的任何一种
推荐：子绝父相
2）相对定位：relative
特点：（1）从文档流角度：不会脱离文档流，占据位置
（2）层叠角度：同上
（3）参照物：自己原来所在位置
3）固定定位：fixed
特点：（1）从文档流角度：会脱离文档流，不占据位置
（2）层叠角度：同上
（3）参照物：永远都是浏览器窗口
使用场景：广告、侧标导航
4）粘性定位：sticky
特点：（1）不滚动时=================相对定位
（2）滚动时================== 固定定位
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0671c96350d162a898d564583be87c1d/" rel="bookmark">
			考虑充电负荷空间可调度特性的分布式电源与电动汽车充电站联合配置方法论文复现——附代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
摘要：
研究背景：
优化配置中的建模方法：
连续时域的离散化及相关简化策略：
光伏电站出力建模：
电动汽车负荷建模：
电力负荷建模：
分布式电源与电动汽车充电站联合配置模型：
目标函数：
约束条件：
算例设置：
运行结果：
本文Matlab代码分享： 摘要： 在含电动汽车充电站的配电系统中，接入恰当容量的分布式电源可以有效促进负荷波动的就地平抑、缓解大功率充电负荷对配电网络的冲击，逐渐成为配电系统规划与运行的新趋势。基于这一背景，本文构建了考虑充电负荷空间可调度特性的分布式电源与电动汽车充电站联合配置模型，以年化社会总成本最小为目标确定配电系统中分布式电源与电动汽车充电站的最佳安装位置和安装容量。该模型以线性化的Distflow潮流方程表征系统中各个状态量间的关系，并应用二阶锥松弛技术处理支路电流约束，最终呈现为一个在多项式时间内可解的混合整数二阶锥规划模型。最后，将IEEE-33节点配电系统与某地区一个实际的地理区域相耦合，并以此为算例系统对光伏电站、微型燃气轮机、电动汽车充电站的最优配置方案进行了求解，验证了所构建模型的有效性。
本代码注释详细，复现结果非常完美，十分精品，具有很强的研究价值。
仿真平台：Maltab+yalmip+cplex
复现文章：博士论文—互动环境下分布式电源与电动汽车充电站的优化配置方法研究（第四章）
研究背景： 随着手机、平板电脑等移动智能终端的普及，以及无线通讯技术的发展，越来越多的汽车车主依赖于实时导航技术决定自己的驾驶及泊车行为。对于电动汽车而言，实时导航技术可以根据目的地周围电动汽车充电桩的分布情况，为电动汽车指引合适的充电场所，使得电动汽车的充电需求在一定程度上、一定空间范围内成为可调度的对象。从配电系统运营商的视角来看，电动汽车发生充电行为的处所，决定了相应的充电负荷接入配电系统的位置。合理利用实时导航技术的引导作用，指引电动汽车充电负荷通过恰当的母线接入配电系统，可以有效改善配电系统负荷的空间分布情况，为配电系统的安全、经济运行提供帮助。
为了更为清晰地描述以上的电动汽车负荷空间可调度特性，图4-1给出了充电负荷空间可调度特性对配电系统运行状态的影响示意图。图中的电动汽车以红色节点为行驶目的地，在其可接受的调度距离范围内，存在充电站2、充电站3、充电站6等3个电动汽车充电站可作为充电行为发生处所。在此基础上，通过实时导航系统引导电动汽车前往哪一个充电站进行充电，将显著影响配电系统负荷的空间分布情况，是一个涉及配电系统运行状态、每个充电站内空闲充电桩数量、调度电动汽车额外行驶距离的费用等诸多因素的优化问题，并会对配电系统内相关设施、设备的优化配置方案产生显著的影响。
优化配置中的建模方法： 分布式电源与电动汽车充电站的联合配置研究涉及到分布式电源出力、电动汽车充电需求、电力用户的负荷需求等诸多元素的建模问题。本节对以上这些资源的建模方法进行了详细的说明。
连续时域的离散化及相关简化策略： 为了在保证模型精度的前提下降低分布式电源与电动汽车充电站联合配置模型的复杂度，本章同样对连续时域进行了离散化处理，并应用了一些合理的简化策略。这些离散化方式和简化策略在前文中有详细的说明，此处不再重复叙述。
含多类型充电桩的电动汽车充电站优化配置方法论文复现——附代码_神经网络与数学建模的博客-CSDN博客
通过这些简化处理，分布式电源与电动汽车充电站联合配置场景由768个确定性的时间断面表征，涵盖了春、夏、秋、冬四季的工作日和周末。
光伏电站出力建模： 为表征目标区域内太阳光照强度的时序波动性，本章基于历史数据拟合了典型的太阳光照强度分布曲线。图4-2基于美国俄勒冈大学太阳辐射监测实验室（SolarRadiationMonitoringLaboratory, UniversityofOregon）公开的华盛顿州西雅图地区（Seattle）历史太阳光照强度数据拟合了一组典型的太阳光照强度分布曲线。考虑到不同季节太阳光照强度的显著不同，在拟合过程中针对不同季节的历史数据进行了各自独立的处理，并通过不同颜色的曲线进行刻画。同时，为了简便起见，图4-2中使用标幺值表征不同季节不同时刻的太阳光照强度，其基值为一年中的最大太阳光照强度。
电动汽车负荷建模： 与前述章节中相关内容一致，本章仍以目的地充电模式下城市内私人电动汽车作为研究对象，其充电负荷分布情况与相应的电动汽车泊车行为密切相关。有关电动汽车泊车行为的表征方法在前述章节中进行了详细的描述，本处不再重复叙述。
电力负荷建模： 与之前文章中电力用户分类与负荷建模方法一致，本文使用基于历史负荷数据拟合的典型负荷曲线替代电力负荷的预测工作。同时，考虑到不同类型负荷（居民小区负荷、商场超市负荷、办公场所负荷）在不同场景下（春、夏、秋、冬、工作日、周末）分布情况的显著不同，对不同类型负荷在不同场景下的历史数据进行了独立分析。
分布式电源与电动汽车充电站联合配置模型： 本节从目标函数和约束条件两个方面详细介绍了所构建的分布式电源与电动汽车充电站联合配置模型。该联合配置模型中嵌入了电动汽车负荷的空间优化调度问题，从而充分考虑了充电负荷空间可调度特性对配电系统负荷的空间分布情况及其运行方式的影响。
目标函数： 约束条件： (1) 系统潮流约束：
（2）等效负荷方程：
（3）电压和电流约束：
其余的约束：(5)分布式电源容量的离散性约束、(6)分布式电源出力约束、(7)电动汽车负荷空间调度约束、（8）电动汽车充电站负荷的表征、（9）充电桩的安装数量约束见原文。
算例设置： 将IEEE-33节点配电系统与某地区一个实际的地理区域相耦合，并以此为算例系统对光伏电站、微型燃气轮机、电动汽车充电站的最优安装位置和最优安装容量（数量）进行求解，验证了本章所述联合配置模型及相关精确松弛方法的有效性。对于松弛后的混合整数二阶锥规划模型，本节在MATLAB环境下使用YALMIP工具箱调用商业求解器GUROBI对其进行了有效求解，并将考虑充电负荷空间可调度特性的分布式电源与电动汽车充电站联合配置方案与传统的基于维诺图的配置方案进行了对比，证明了在优化配置阶段考虑充电负荷空间可调度特性的积极意义。
基于实际信息，系统中的土地区块被分成若干种不同的类型（居民小区、商场超市、办公场所等），并在图 4-4 中使用不同的颜色进行表示。同时，为简单起见，认为配电网络中每个节点处的负荷类型与其所在的土地区块类型一致，且配电系统网络节点、电动汽车充电站、电动汽车的行驶目的地均位于相应土地区块的几何中心点，从而可以使用不同土地区块几何中心点间的直线距离近似表示对应的电动汽车行驶目的地到充电站的距离。
运行结果： 本文Matlab代码分享： 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bffe00480fb16a51ea98c86ef8e454eb/" rel="bookmark">
			Android实现红绿灯检测(含Android源码 可实时运行)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android实现红绿灯检测(含Android源码 可实时运行) 目录
Android实现红绿灯检测(含Android源码 可实时运行)
1. 前言
2. 红绿灯检测数据集说明
3. 基于YOLOv5的红绿灯检测模型训练
4.红绿灯检测模型Android部署
（1） 将Pytorch模型转换ONNX模型
（2） 将ONNX模型转换为TNN模型
（3） Android端上部署模型
（4） 一些异常错误解决方法
5. 红绿灯检测效果
6.项目源码下载
1. 前言 本篇博客是《深度学习目标检测：YOLOv5实现红绿灯检测(含红绿灯数据集+训练代码)》续作Android篇，主要分享将Python训练后的YOLOv5的红绿灯检测模型移植到Android平台。我们将开发一个简易的、可实时运行的红绿灯检测Android Demo。
考虑到原始YOLOv5的模型计算量比较大，鄙人在YOLOv5s基础上，开发了一个非常轻量级的的红绿灯检测模型yolov5s05_320。从效果来看，Android红绿灯检测模型的检测效果还是可以的，高精度版本YOLOv5s平均精度平均值mAP_0.5=0.93919，而轻量化版本yolov5s05_416平均精度平均值mAP_0.5=0.71944左右。APP在普通Android手机上可以达到实时的检测识别效果，CPU(4线程)约30ms左右，GPU约25ms左右 ，基本满足业务的性能需求。
先展示一下Android Demo效果：
【Android APP体验】Android实现红绿灯检测APP(可实时运行))
【项目源码下载】 Android实现红绿灯检测(含Android源码 可实时运行)
【尊重原创，转载请注明出处】https://blog.csdn.net/guyuealian/article/details/128240334
更多项目《智能驾驶 车牌检测和识别》系列文章请参考：
智能驾驶 车牌检测和识别（一）《CCPD车牌数据集》：https://blog.csdn.net/guyuealian/article/details/128704181智能驾驶 车牌检测和识别（二）《YOLOv5实现车牌检测（含车牌检测数据集和训练代码）》：https://blog.csdn.net/guyuealian/article/details/128704068智能驾驶 车牌检测和识别（三）《CRNN和LPRNet实现车牌识别（含车牌识别数据集和训练代码）》：https://blog.csdn.net/guyuealian/article/details/128704209智能驾驶 车牌检测和识别（四）《Android实现车牌检测和识别（可实时车牌识别）》：https://blog.csdn.net/guyuealian/article/details/128704242智能驾驶 车牌检测和识别（五）《C++实现车牌检测和识别（可实时车牌识别）》：https://blog.csdn.net/guyuealian/article/details/128704276智能驾驶 红绿灯检测（一）《红绿灯(交通信号灯)数据集》：https://blog.csdn.net/guyuealian/article/details/128222850智能驾驶 红绿灯检测（二）《YOLOv5实现红绿灯检测(含红绿灯数据集+训练代码)》：https://blog.csdn.net/guyuealian/article/details/128240198智能驾驶 红绿灯检测（三）《Android实现红绿灯检测(含Android源码 可实时运行)》：https://blog.csdn.net/guyuealian/article/details/128240334 智能驾驶 车辆检测（一）《UA-DETRAC BITVehicle车辆检测数据集》：https://blog.csdn.net/guyuealian/article/details/127907325
智能驾驶 车辆检测（二）《YOLOv5实现车辆检测(含车辆检测数据集+训练代码)》：https://blog.csdn.net/guyuealian/article/details/128099672
智能驾驶 车辆检测（三）《Android实现车辆检测(含Android源码 可实时运行)》：https://blog.csdn.net/guyuealian/article/details/128190532
2. 红绿灯检测数据集说明 目前收集了约1W+的红绿灯（交通信号灯）检测数据集：Traffic-Lights-Dataset-Domestic+Traffic-Lights-Dataset-Foreign: 关于红绿灯检测数据集使用说明和下载，详见另一篇博客说明：《红绿灯(交通信号灯)检测数据集》
3. 基于YOLOv5的红绿灯检测模型训练 官方YOLOv5给出了YOLOv5l,YOLOv5m,YOLOv5s等模型。考虑到手机端CPU/GPU性能比较弱鸡，直接部署yolov5s运行速度十分慢。所以本人在yolov5s基础上进行模型轻量化处理，即将yolov5s的模型的channels通道数全部都减少一半，并且模型输入由原来的640×640降低到416×416或者320×320，该轻量化的模型我称之为yolov5s05。从性能来看，yolov5s05比yolov5s快5多倍，而mAP下降了16%（0.93→0.77），对于手机端，这精度勉强可以接受。
下面是yolov5s05和yolov5s的参数量和计算量对比：
模型input-sizeparams(M)GFLOPsmAP0.5yolov5s640×6407.216.50.93919yolov5s05416×4161.71.80.77174yolov5s05320×3201.71.10.71944 yolov5s05和yolov5s训练过程完全一直，仅仅是配置文件不一样而已；碍于篇幅，本篇博客不在赘述，详细训练过程请参考： 《深度学习目标检测：YOLOv5实现红绿灯检测(含红绿灯数据集+训练代码)》
4.红绿灯检测模型Android部署 （1） 将Pytorch模型转换ONNX模型 训练好yolov5s05或者yolov5s模型后，你需要将模型转换为ONNX模型，并使用onnx-simplifier简化网络结构
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bffe00480fb16a51ea98c86ef8e454eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16247b9ad71a808fad88c92bbf1a897e/" rel="bookmark">
			IJKPlayer 编译及运行Demo 教程(详细)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IJKPlayer 编译及运行Demo 教程 编译环境准备1. Ubuntu安装2. 工具安装 安装JDK/SDK/NDK1.安装JDK:2. 安装SDK3. 安装NDK 下载ijkplayer及修改其中配置编译android studio 打开ijkplayer 编译环境准备 1. Ubuntu安装 2. 工具安装 切换root 用户。注意，最好以下都以root身份去操作
sudo su 安装Git、Vim
apt install git apt install vim 安装JDK/SDK/NDK 1.安装JDK: 下载：
wget https://cdn.azul.com/zulu/bin/zulu8.60.0.21-ca-jdk8.0.322-linux_x64.tar.gz 解压：
tar -xvf android-sdk_r24.4.1-linux.tgz 把下载的文件放到 /usr/local/ 下,继续，移动到 /usr/local/java 下
mv zulu8.60.0.21-ca-jdk8.0.322-linux_x64 /usr/local/java 配置java 环境变量
cd ~ vim .bashrc 末尾插入：
export JAVA_HOME=/usr/local/java export PATH=$PATH:/usr/local/java/bin 保存+刷新
source .bashrc java -version，查看是否安装成功：
2. 安装SDK 下载：
wget http://dl.google.com/android/android-sdk_r24.2-linux.tgz 解压：
tar -xvf android-sdk_r24.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/16247b9ad71a808fad88c92bbf1a897e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c90c024e79303d672691189e673a95c8/" rel="bookmark">
			IDEA输入import语句后自动消失
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有些朋友好奇选中邮件点开这个，还勾选上了这个
恭喜你，下次输入import语句的 “;” 时，你会发现import它自动消失了
当你输入Scanner sc=new Scanner(System.in);发现import又回来了
解决方法：点file-settings-editor-general-auto import里面有一个Optimize imports on the fly,把那个√去掉，apply，然后OK
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dca777aa55bed6fe460f048b8eaf797e/" rel="bookmark">
			深入理解Spring两大特性：IoC和AOP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring Boot 专栏：https://blog.csdn.net/dkbnull/category_9278145.html
Spring Cloud 专栏：https://blog.csdn.net/dkbnull/category_9287932.html
GitHub：GitHub - dkbnull/SpringBootDemo: SpringBootDemo
Gitee：SpringBootDemo: SpringBootDemo
众所周知，Spring拥有两大特性：IoC和AOP。IoC，英文全称Inversion of Control，意为控制反转。AOP，英文全称Aspect-Oriented Programming，意为面向切面编程。
Spring核心容器的主要组件是Bean工厂（BeanFactory），Bean工厂使用控制反转（IoC）模式来降低程序代码之间的耦合度，并提供了面向切面编程（AOP）的实现。
简单来说，Spring是一个轻量级的控制反转（IoC）和面向切面编程（AOP）的容器框架。
下面，我们简要说明下这两大特性。
1. Spring常用注解 在具体介绍IoC和AOP之前，我们先简要说明下Spring常用注解
1、@Controller：用于标注控制器层组件
2、@Service：用于标注业务层组件
3、@Component : 用于标注这是一个受 Spring 管理的组件，组件引用名称是类名，第一个字母小写。可以使用@Component(“beanID”) 指定组件的名称
4、@Repository：用于标注数据访问组件，即DAO组件
5、@Bean：方法级别的注解，主要用在@Configuration和@Component注解的类里，@Bean注解的方法会产生一个Bean对象，该对象由Spring管理并放到IoC容器中。引用名称是方法名，也可以用@Bean(name = "beanID")指定组件名
6、@Scope("prototype")：将组件的范围设置为原型的（即多例）。保证每一个请求有一个单独的action来处理，避免action的线程问题。
由于Spring默认是单例的，只会创建一个action对象，每次访问都是同一个对象，容易产生并发问题，数据不安全。
7、@Autowired：默认按类型进行自动装配。在容器查找匹配的Bean，当有且仅有一个匹配的Bean时，Spring将其注入@Autowired标注的变量中。
8、@Resource：默认按名称进行自动装配，当找不到与名称匹配的Bean时会按类型装配。
简单点说，就是，能够明确该类是一个控制器类组件的，就用@Controller；能够明确是一个服务类组件的，就用@Service；能够明确该类是一个数据访问组件的，就用@Repository；不知道他是啥或者不好区分他是啥，但是就是想让他动态装配的就用@Component。
@Controller、@Service、@Component、@Repository都是类级别的注解，如果一个方法也想动态装配，就用@Bean。
当我们想按类型进行自动装配时，就用@Autowired；当我们想按名称（beanID）进行自动装配时，就用@Resource；当我们需要根据比如配置信息等来动态装配不同的组件时，可以用getBean("beanID")。
到这里，如果对这些注解，或是自动装配不太理解，可以继续往下，看完 控制反转(IoC) 内容后再回来理解这里的内容。
2. 控制反转(IoC) 控制反转，简单点说，就是创建对象的控制权，被反转到了Spring框架上。
通常，我们实例化一个对象时，都是使用类的构造方法来new一个对象，这个过程是由我们自己来控制的，而控制反转就把new对象的工交给了Spring容器。
《expert ONE-ON-ONE J2EE Development without EJB》第6章中指出
P128
IoC Implementation Strategies
IoC is a broad concept that can be implemented in different ways.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dca777aa55bed6fe460f048b8eaf797e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0697b2779334da9bc98683ae9b4a3fbc/" rel="bookmark">
			Android setContentView流程分析(一)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于做Android App的小伙伴来说setContentView这个方法再熟悉不过了，那么有多少小伙伴知道它的调用到底做了多少事情呢？下面就让我们来看看它背后的故事吧？
setContentView()方法将分为两节来讲：
第一节：如何获取DecorView和contentParent
第二节：如何创建R.layout.activity_main.xml布局View到contentParent中
这节先来讲如何获取DecorView和contentParent
我们新建一个Activity时,onCreate()方法中就会自动调用setContentView()方法
@Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); } 这里看着是setContentView方法将我们自己写的R.layout.activity_main的布局文件传下去，其实这里这后边还是做了很多事情的。
这里需要分两种情况
一：MainActivity继承于Activity
二：MainAcitivity继承于AppCompatActivity
第一种情况：MainActivity继承于Activity 1.执行setContentView(R.layout.activity_main)方法后会进入到Activity.java的setContentView方法中
public void setContentView(@LayoutRes int layoutResID) { getWindow().setContentView(layoutResID); initWindowDecorActionBar(); } 可以看到会调用getWindow().setContentView(layoutResID);，这个getWindow()是获取的其实就是phoneWindow
2.执行phoneWindow的setContentView方法
@Override public void setContentView(int layoutResID) { // Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window // decor, when theme attributes and the like are crystalized. Do not check the feature // before this happens.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0697b2779334da9bc98683ae9b4a3fbc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7dc6f7118bc43eb97e3eda61fa822eb/" rel="bookmark">
			StringRedisTemplate 一些记录(1)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.一些概念 1-StringRedisTemplate继承RedisTemplate;
2-两者数据不共通,StringRedisTemplate只管StringRedisTemplate里面的数据，RedisTemplate只管RedisTemplate中的数据;
3-两者序列化类不同,RedisTemplate使用的是JdkSerializationRedisSerializer,存入数据会将数据先序列化成字节数组然后在存入Redis数据库;StringRedisTemplate使用的是StringRedisSerializer。
2.使用 1. opsForSet
@Autowired private StringRedisTemplate redisTemplate; //向变量中批量添加值。 redisTemplate.opsForSet().add(Constant.DEVICE_OPT_PREFIX, deviceId); redisTemplate.expire(Constant.DEVICE_OPT_PREFIX, 5, TimeUnit.MINUTES); //获取变量中的值 Set&lt;String&gt; deviceIds = redisTemplate.opsForSet().members(Constant.DEVICE_OPT_PREFIX); 2. opsForValue @Autowired private StringRedisTemplate redisTemplate; Set&lt;String&gt; deviceIdOptKeys = redisTemplate.keys(Constant.DEVICE_OPT_PREFIX.concat("*")); Set&lt;String&gt; failDeviceIds = new HashSet&lt;&gt;(); if (ObjectUtils.isNotEmpty(deviceIdOptKeys)){ failDeviceIds = deviceIdOptKeys.stream().map(x-&gt;x.substring(Constant.DEVICE_OPT_PREFIX.length())).collect(Collectors.toSet()); } if (failDeviceIds.contains(deviceId)){ redisTemplate.opsForValue().append(Constant.DEVICE_OPT_PREFIX + deviceId,"#"); } else { redisTemplate.opsForValue().set(Constant.DEVICE_OPT_PREFIX + deviceId,"#",30,TimeUnit.MINUTES); } redisTemplate.delete(Constant.DEVICE_OPT_PREFIX + deviceId); // 设置键、值和过期时间 redisTemplate.opsForValue().set(Constant.DEVICE_OPT_PREFIX + deviceId, "#", 10, TimeUnit.MINUTES); // 获取键对应的值 String deviceValue = redisTemplate.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d7dc6f7118bc43eb97e3eda61fa822eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/728a7cd4303c85be26d817ce27a1360e/" rel="bookmark">
			【蓝桥杯】嵌入式编程_LCD模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
增加lcd.c
LCD配置
LCD小练习
LCD与按键的搭配使用
无理论
由于赛方已经提前准备了相关的lcd模块的.c文件与头文件
所以我们不需要知晓lcd的原理 直接加入准备好的lcd文件就可以直接使用lcd功能
增加lcd.c 在目录 赛点资源数据包ES_2022\赛点资源数据包ES\2-新版竞赛平台\5-液晶驱动参考程序\HAL_06_LCD\Src
找到lcd.c
复制到当前工程src目录下 平且将相应的头文件复制到inc目录下
要想使用lcd.h声明的函数 要在main.c下引用该头文件
LCD配置 #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include "main.h" #include "lcd.h" __IO uint32_t uwTick_lcd; void lcd_proc(void); int main(void) { LCD_Init(); LCD_Clear(Blue); LCD_SetBackColor(Blue); LCD_SetTextColor(White); //初始化相关配置 while (1) { lcd_proc(); } } void lcd_proc(void) { if((uwTick-uwTick_lcd)&lt;100) return; uwTick_lcd = uwTick; //用sprintf可以打印变量 sprintf(&amp;LCD_string[0],"welcome use LCD"); LCD_DisplayStringLine(Line0,(uint8_t *)LCD_string);//借用line改变行数 } 在lcd.c添加变量LCD_string的声明 在lcd.h扩展出去
lcd.c添加char LCD_string[21];
lcd.h添加extern char LCD_string[21];
查看lcd.h 可使用的相关函数 可以跟过去查看函数功能
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/728a7cd4303c85be26d817ce27a1360e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c029ae50efcc8f8ff7f35af04540b0c/" rel="bookmark">
			pandas dataframe只重命名某列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何指定dataframe的某列改变列名？ 两种方法 如何指定dataframe的某列改变列名？先建立测试用dataframe1.改变所有列名法2.rename可以指定改一列 先建立测试用dataframe #建立数据框 import pandas as pd dic = {"a":[11,22], "b":[33,44]} df = pd.DataFrame(dic) 1.改变所有列名法 直接指定所有列名，保持其他列名不变，只改变目标列的名字。
需要注意的是 这里改变了columns的名字之后，原本的df就被改变了，相当于给dataframe的对象的属性进行重新赋值。
2.rename可以指定改一列 使用rename方法，对指定名字的列改名。
这里注意到 使用方法后会返回一个改名后的dataframe但是不会改变原本的dataframe。因此想要在原本的数据框上进行修改的话，就需要对原本dataframe的值进行重新赋值，old_df = df.rename
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7462cc8e62fefdfabf4773d497f3dbf/" rel="bookmark">
			babel : 无法加载文件，因为在此系统上禁止运行脚本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04d99ca1ed9749e7d27a834a0eca3a14/" rel="bookmark">
			python opencv 绘制矩形、圆、线、多边形
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		👨‍💻个人简介： 深度学习图像领域工作者
🎉总结链接： 链接中主要是个人工作的总结，每个链接都是一些常用demo，代码直接复制运行即可。包括：
📌1.工作中常用深度学习脚本
📌2.torch、numpy等常用函数详解
📌3.opencv 图片、视频等操作
📌4.个人工作中的项目总结（纯干活）
链接： https://blog.csdn.net/qq_28949847/article/details/128552785
🎉视频讲解： 以上记录，通过B站等平台进行了视频讲解使用，可搜索 ‘Python图像识别’ 进行观看
B站：Python图像识别
抖音：Python图像识别
西瓜视频：Python图像识别
1. cv2.rectangle 绘制矩形 cv2.rectangle()函数是OpenCV中用于在图像上绘制矩形的函数。其语法如下：
cv2.rectangle(img, pt1, pt2, color, thickness=None, lineType=None, shift=None) 参数说明：
img：输入的图像矩阵；pt1：矩形的左上角顶点坐标，类型为(x,y)；pt2：矩形的右下角顶点坐标，类型为(x,y)；color：矩形的颜色，可以是RGB元组或灰度值；thickness：可选参数，指定矩形边框的宽度，默认为1，-1 为实心矩形；lineType：可选参数，指定矩形边框的类型，默认为8；shift：可选参数，指定坐标点小数位数，默认为0。 下面是一个例子：
import cv2 import numpy as np # 创建一个黑色的图像 img = np.zeros((512, 512, 3), np.uint8) # 在图像上绘制一个红色矩形 cv2.rectangle(img, (100, 100), (300, 300), (0, 0, 255), 3) # 显示图像 cv2.imshow("rectangle", img) cv2.waitKey(0) cv2.destroyAllWindows() 示例效果：
2. cv2.circle() 绘制圆 cv2.circle()函数是OpenCV中用于在图像上绘制圆形的函数。其语法如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04d99ca1ed9749e7d27a834a0eca3a14/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69f1cd3170802e1e662ed044bd975dd8/" rel="bookmark">
			VSCode 之 设置 settings.json 配置文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这篇文章主要介绍了 VSCode - settings.json 配置 ，
文中通过示例代码介绍的非常详细，对大家的学习或者工作具有一定的参考学习价值
VSCode 从插件库里安装 eslint 和 prettier 两个 插件 ，也 🉑️ 实现自动格式化的设置
Ctrl + Shift + P （ Mac ： command + Shift + P ） ，
或者直接按 F1 ， 打开 展示全局命令面板 ，寻找 settings 配置文件 初始配置 ：
更改覆盖为以下代码后 即可 实现 Ctrl + S 保存 自动格式化 ：
{
// 換行
"editor.wordWrap": "on",
// 是否允许自定义的snippet片段提示
"editor.snippetSuggestions": "top",
// vscode默认启用了根据文件类型自动设置tabsize的选项 不检查缩进，保存后统一按设置项來设置 false
"editor.detectIndentation": false,
// 重新设定tabsize 代码缩进修改成 2 个空格
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/69f1cd3170802e1e662ed044bd975dd8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97c1f6512426026d4c9a8d06a3999b95/" rel="bookmark">
			DES加密解密（java与.net互通 ）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		.Net代码：
加密数据： public string Encode(string str, string key) { try { System.Security.Cryptography.DESCryptoServiceProvider provider = new DESCryptoServiceProvider(); provider.Key = Encoding.ASCII.GetBytes(key.Substring(0, 8)); provider.IV = Encoding.ASCII.GetBytes(key.Substring(0, 8)); byte[] bytes = Encoding.GetEncoding("GB2312").GetBytes(str); MemoryStream stream = new MemoryStream(); System.Security.Cryptography.CryptoStream stream2 = new System.Security.Cryptography.CryptoStream(stream, provider.CreateEncryptor(), CryptoStreamMode.Write); stream2.Write(bytes, 0, bytes.Length); stream2.FlushFinalBlock(); StringBuilder builder = new StringBuilder(); foreach (byte num in stream.ToArray()) { builder.AppendFormat("{0:X2}", num); } stream.Close(); return builder.ToString(); } catch (Exception) { return "xxxx"; } } 解密数据： public string Decode(string str, string key) { try { DESCryptoServiceProvider provider = new DESCryptoServiceProvider(); provider.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/97c1f6512426026d4c9a8d06a3999b95/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f39d80e4f84ea608ef6121c163dc7cf/" rel="bookmark">
			idea的插件商店无法搜索插件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88ba21761a0e471e602ec8dceac15649/" rel="bookmark">
			边框设置渐变色和圆角的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先说明一点，渐变色border-image的设置和圆角的设置 border-radius是不能共同存在的，如果共同存在的话，那么只有渐变色会生效，圆角则显示不出来。我列举几个例子顺带解决一下我在项目中遇到的问题。
1.实例1：
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .border-image-clip-path { width: 200px; height: 100px; margin: auto; border: 8px solid; border-image: linear-gradient(45deg, gold, deeppink) 1; clip-path: inset(0px round 10px); animation: huerotate 6s infinite linear; filter: hue-rotate(360deg); } @keyframes huerotate { 0% { filter: hue-rotate(0deg); } 100% { filter: hue-rorate(360deg); } } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1 class="border-image-clip-path"&gt;&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt; 这个渐变色设置的比较好，还有一定动画效果，同时呢，也设置了圆角。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/88ba21761a0e471e602ec8dceac15649/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88ba39c64e60d97a89a732b9a983c333/" rel="bookmark">
			keras使用gpu训练(tensor1.15 &#43; cuda10.2)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		模型搭建 首先写一个简单的 训练cifar10 的模型，可参考
Keras入门课3 – 使用CNN识别cifar10数据集
CPU训练 安装pip install tensorflow==1.15 , 默认使用CPU 训练，　一个epoch训练时间为：141s
GPU训练 注意：tensorflow-gpu-cudnn-cuda对应版本
正确的步骤是按照对照表去安装。　PS :tensorflow1.15　对应的也是cuda10.0
使用GPU 训练，　一个epoch训练时间为：21s !!!
但是不幸的是，你提前安装了cuda10.2 , 又深知重装之痛苦。那就继续往下看吧
Centos8 运行CUDA10.2+Tensorflow1.15.0
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/797071a18662adce38d1079b014c6a72/" rel="bookmark">
			JRebel本地激活方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 先上图 总共4步操作 先下载激活的exe（下图红框） 地址：https://github.com/ilanyu/ReverseProxy/releases/tag/v1.4（搭个梯子） 删除 C:\Users\用户名\.jrebel下的所有文件。重启IDEA 生成GUID 地址：Generate GUIDs online (guidgen.com) 4、打开Idea的JRebel激活界面。 第一行：http://127.0.0.1:8888/{GUID} 第二行：邮箱地址，随意输入，正确即可。例如test@123.com 勾选同意，点击激活。 5、离线工作 激活后，下图红框点击。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98f1d4b347073375676efe3a77a0bc2d/" rel="bookmark">
			Docker修改默认根目录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Docker安装后的默认根目录在/var/lib/docker，修改根目录的方法如下：
1、使用docker info查看默认的目录 [root@localhost ~]# docker info ... Docker Root Dir: /var/lib/docker ... 2、确保停止docker服务 # systemctl stop docker.service 3、修改docker服务启动文件（docker.service ） vim /usr/lib/systemd/system/docker.service #原配置保持不变， 在EXECStart的后面增加 --graph /xhg/docker (/xhg/docker是自己创建的新存储位置) ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock --graph=/xhg/docker 4、同步docker根目录数据到新目录 [root@harbor ~]# rsync -avz /var/lib/docker/ /xhg/docker/ # 同步数据 [root@harbor ~]# ll /xhg/docker/ # 确认同步后的数据 5、重新加载配置并启动 [root@localhost docker]# systemctl daemon-reload [root@localhost docker]# systemctl start docker 6、查看修改后的docker信息 [root@localhost docker]# docker info ... Docker Root Dir: /xhg/docker #确认目录已更改 ... 如果能看到Docker Root Dir: /xhg/docker，说明docker默认根目录已修改成功。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98f1d4b347073375676efe3a77a0bc2d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55ef59540fcf36460fb5dda53920aa0b/" rel="bookmark">
			Mysql有两张表，表1和表2的字段不要求完全一样，表1中的内容包含了表2，写SQL语句，实现查询表1中剔除表2的数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		假设表1名为table1，表2名为table2，并且表1中包含表2的所有数据，可以使用LEFT JOIN和WHERE子句来查询表1中剔除表2的数据。具体的 SQL 语句如下：
SELECT table1.* FROM table1 LEFT JOIN table2 ON table1.column = table2.column WHERE table2.column IS NULL; 其中，column是表1和表2中的共同字段，可以根据实际情况替换为相应的字段名。这条 SQL 语句的意思是先将表1和表2按照共同字段进行左连接，然后筛选出表2中不存在的记录，最终返回的是表1中剔除表2的数据。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c6495b538a65aab18a72dcae2aa1eb4/" rel="bookmark">
			Mysql有两张表，表1和表2的字段一样，表1中的内容包含了表2，写SQL语句，实现查询表1中剔除表2的数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果表1和表2的字段一样，并且表1中包含表2的所有数据，可以使用 NOT EXISTS 或者 NOT IN 子句来查询表1中剔除表2的数据。具体的 SQL 语句如下：
使用 NOT EXISTS 子句：
SELECT table1.* FROM table1 WHERE NOT EXISTS ( SELECT * FROM table2 WHERE table2.column = table1.column ); 其中，column是表1和表2中的共同字段，可以根据实际情况替换为相应的字段名。这条 SQL 语句的意思是在表1中查询不在表2中出现的记录，最终返回的是表1中剔除表2的数据。
使用 NOT IN 子句：
SELECT table1.* FROM table1 WHERE table1.column NOT IN ( SELECT column FROM table2 ); 这条 SQL 语句的意思也是在表1中查询不在表2中出现的记录，最终返回的是表1中剔除表2的数据。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7c5de8cab2efb152cf48e62fbc04e60/" rel="bookmark">
			如何把云盘挂载、添加到本地？（将各种云盘挂载到本地，可以在本地操作云盘，多网盘变本地硬盘，CloudDrive）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简述：云盘大家都比较熟悉，像我们常用的有阿里云盘、腾讯云盘，还有百度云盘等，那如何在电脑上把云盘添加到本地，方便使用，这里给大家提供一种把云盘添加到本地的方法； 1、首先打开果核剥壳网站，然后搜索CloudDrive（网站如下，网站内容丰富，有很多实用的应用程序）；
果核剥壳https://www.ghxi.com/?post=274搜索结果如下:
2、点击搜索出的应用，拉取，找到网页的这部分，选择一种下载方式；
3、下载完成以后，解压，运行，然后会弹出一个CloudDrive的网页应用，直接注册登录，添加云盘；
登录成功后，会出现以下页面，然后点击添加云盘，选择你需要添加的云盘：
弹出登录框，手机云盘APP扫码登录（或者其它登录）：
4、 登陆成功后，点击挂载到本地，弹出挂载框，然后配置挂载内容；
弹出挂载框：
添加成功，可以直接打开网盘访问云盘文件，当然，在这个本地云盘生成的文件，也会同步到CloudDrive云端网站；
感觉有用，就一键三连，感谢(●'◡'●)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca6c789b506b3570e5a0eeaf5ae46dd7/" rel="bookmark">
			MySQL 查询语句的执行顺序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载链接：https://www.cnblogs.com/yeyuzhuanjia/p/16267558.html
一、编写查询 SQL 顺序 1.select 2.from 3.join on 4.where 5.group by 6.having 7.order by 8.limit 二、MySQL 执行顺序 – from—&gt;on—&gt;join—&gt;where—&gt;group by—&gt;having+(聚合函数)—&gt;select—&gt;distinct—&gt;UNION—&gt;order by—&gt;limit
– UNION 在 ORDER BY 之前
1.from 2.on 3.join 4.where 5.group by 6.having 7.select 8.distinct 9.order by 10.limit 三、MySQL 执行顺序理解 第一步：加载 from 子句的前两个表计算笛卡尔积，生成虚拟表 vt1；
第二步：筛选关联表符合 on 表达式的数据，保留主表，生成虚拟表 vt2；
第三步：如果使用的是外连接，执行 on 的时候，会将主表中不符合 on 条件的数据也加载进来，做为外部行
第四步：如果 from 子句中的表数量大于 2，则重复第一步到第三步，直至所有的表都加载完毕，更新 vt3；
第五步：执行 where 表达式，筛选掉不符合条件的数据生成 vt4；
第六步：执行 group by 子句。group by 子句执行过后，会对子句组合成唯一值并且对每个唯一值只包含一行，生成 vt5,。一旦执行 group by，后面的所有步骤只能得到 vt5 中的列 (group by 的子句包含的列) 和聚合函数。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca6c789b506b3570e5a0eeaf5ae46dd7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b1af7755a8dbb906bd70273bf37a4ee/" rel="bookmark">
			常见ANR问题解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ANR问题，相信是每位开发日常都会遇到的问题，对于这类问题的分析，按照官方的推荐，或网络博客的总结思路能解决一定的问题，但是多数时候大家的困惑就是应用本逻辑很简单，耗时很短或应用堆栈完全正常，或者或处于空闲状态，可系统为什么就认为接收者发生ANR了呢？下面将之前公司的一次内部分享开放出来，用几个实例从不同角度分析导致ANR产生的Root Case。也希望对大家以后分析该类问题有一定参考，不对的地方欢迎大家拍砖。
一 ANR分类 含如下几种类型：
广播ANR
Service ANR
ContentProvider ANR
Input ANR
面向系统：WatchDog
二 产生ANR原因 如下几种：
主线程耗时操作
主线程被其它线程Block
系统级响应阻塞
系统或进程自身可用内存紧张
CPU资源被抢占
对于这些ANR，先给大家的推荐一下大致分析思路和相关日志，通常发生ANR时，首先去查找对应Trace日志，看看主线程是否在处理该广播或被阻塞，如果发现上述现象，那么恭喜你，已经很接近答案了。但如果发现堆栈完全处于空闲状态，那么很不幸，就需要扩大参考面了，需要结合log日志进行分析，日志包括logcat, kernel日志，cpuinfo以及meminfo等，参考顺序从前向后。
1分析logcat思路：首先在日志中搜索（“anr in”，“low_memory”, “slow_operation”）等关键字，通过该类关键字主要是查看系统Cpu负载，如果是发现应用进程CPU明显过高，那么很有可能是该进程抢占CPU过多导致，系统调度不及时,误认为应用发生了超时行为。
2分析kernel思路：在此类日志中直接搜索lowmemorykiller, 如果存在则查看发生时间和ANR时间是否大致对应，相差无几的话，可以从该日志中看到操作系统层面当前内存情况，Free Memory说明的是空闲物理内存，File Free说明的则是文件Cache，也就是应用或系统从硬盘读取文件，使用结束后，kernel并没有这正释放这类内存，加以缓存，目的是为了下次读写过程加快速度。当然，发现Free和Other整体数值都偏低时，Kernel会进行一定程度的内存交换，导致整个系统卡顿。同时这类现象也会体现在log日志“slow_operation”中，即系统进程的调度也会收到影响。
3分析cpuinfo思路：这类日志一目了然，可以清晰的看到哪类进程CPU偏高，如果存在明显偏高进程，那么ANR和此进程抢占CPU有一定关系。当然，如发现Kswapd，emmc进程在top中，则说明遇到系统内存压力或文件IO开销。
4分析meminfo思路：分析该类日志，主要是看哪类应用或系统占用内存偏高，如果应用内存占用比较正常，系统也没有发生过度内存使用，那么则说明系统中缓存了大量进程，并没有及时释放导致系统整体内存偏低。
5综合分析当时系统环境，例如电量（低电可能会引起手机限频，限核等等），手机温度（温度过高也可能会引起限频），以及操作频率（例如执行monkey测试）等等；
上面说了这么多，下面结合实例进行分析：
实例一：主线程进行耗时操作，或被进程内其它线程阻塞 示例：
第一步 观察Trace 主线程堆栈，发现主线程在申请内存过程中被block，等待GC结束，但通过堆栈进一步发现其GC并没有发生在该线程，也就是说在其他线程在执行GC动作，而主线程在申请内存过程中需要等待GC完成，再进一步申请内存。
"main" prio=5 tid=1 WaitingForGcToComplete
native: #00 pc 0000000000019980 /system/lib64/libc.so (syscall+28)
native: #01 pc 000000000013a62c /system/lib64/libart.so (_ZN3art17ConditionVariable4WaitEPNS_6ThreadE+136)
native: #02 pc 0000000000237f14 /system/lib64/libart.so (_ZN3art2gc4Heap19WaitForGcToCompleteENS0_7GcCauseEPNS_6ThreadE+1376)
native: #03 pc 000000000024798c /system/lib64/libart.so (_ZN3art2gc4Heap22AllocateInternalWithGcEPNS_6ThreadENS0_13AllocatorTypeEmPmS5_S5_PPNS_6mirror5ClassE+168)
native: #04 pc 000000000050394c /system/lib64/libart.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b1af7755a8dbb906bd70273bf37a4ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/324c2229efaedce6a4ee5031369d6fbc/" rel="bookmark">
			基于vivado（语言Verilog）的FPGA学习（2）——zedboard开机测试和程序烧写
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于vivado（语言Verilog）的FPGA学习（2）——zedboard开机测试和程序烧写 终于找到之前写的部分了，在OneNote上，以后还是专注写在一个地方
1. 系统架构图 ZedBoard 可以通过四个不同的方法烧写，这些方法是：
USB-JTAG
这是默认的并且是最直接的烧写 ZedBoard 的方法 , 这只要通过 ZedBoard 工具包的 USB 到 micro-USB 连接线就可以直接完成。
传统 JTAG
板卡上有一个可用的 Xilinx JTAG 接口，如果需要的话可用来 替代 USB-JTAG 连接。这会需要一根未包含在 ZedBoard 工具包中的连接线：如一根 Xilinx Platform USB 连接线 [11]，或者一根 Digilent USB-JTAG 烧写线 [10]。
Quad-SPI 闪存
板卡上的闪存是非易失性的，因此它可以用来保存板卡上 次断电时的配置信息。使用这种方法不需要连接线来烧写 Zynq 设备。
SD 卡
ZedBoard 的背面有一个 SD 卡槽。利用这个特性可以通过 SD 卡中存 储的文件来烧写 Zynq，并且不需要任何烧写线。这种方法在 《ZedBoardGetting Started Guide》中有所描述 [6]。
ZedBoard 的用户可以通过一系列的跳线来选择引导 / 烧写方式，这些跳线位于 Digilent logo 的下方，并在图 6.4 中有所标注。在五个跳线中，中间的三个被用 来定义板卡的烧写信息来源 （JTAG，闪存或 SD 卡），最右边的控制 JTAG 的模式，最左边则决定内部 PLL 是否被使用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/324c2229efaedce6a4ee5031369d6fbc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/352a686ea75658348b9976fba7420b28/" rel="bookmark">
			为什么printf在打印float和double型数据的时候，小数都是6位呢？(C语言)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include &lt;stdio.h&gt; int main(int argc, char const *argv[]) { float x = 12.456777777777777777777777777777777777777777777777777777; double y = 12.45677777777777777777777777777777777777777777777777777; printf("%f\n", x); printf("%lf\n", y); return 0; } Result:
原因：编译器默认精确到小数点后六位输出
而两种类型的有效位数如下：
float类型6～7位
double类型15～16位
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c06cadaaa45df5ee5b7d2aa8d782288/" rel="bookmark">
			安卓xml文件无法预览， Sync报错：Unable to resolve dependency for ‘:app@debugAndroidTest/compileClasspath‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因为某些原因修改了一些文件，然后突然发现xml文件无法预览了，提示Design editor is unavailable until after a successful project sync
但是此时程序没有其他问题，点击Run可以安装到模拟器上面，甚至可以正常运行。但就是无法预览xml文件以及Sync会报错。
File -&gt; Sync Project with Gradle Files 后出现报错信息：
ERROR: Unable to resolve dependency for ':app@debugAndroidTest/compileClasspath': Could not resolve androidx.test.services:storage:[1.4.0] 然后网上的好多方法试了无效。
Clean project 无效
Rebuild Project无效
File -&gt; Invalidate and Restart 无效
后来找到了问题原因，是之前修改的时候无意间修改了代理，导致代理中http和https冲突了，需要设置https代理为No proxy，之前设置为Manual proxy cofiguration了，此时设置为No proxy后，还需要在全局的gradle.properties中删除代理设置。
方法：File -&gt; Settings -&gt; 找到HTTP Proxy，选中No proxy
还需要删除gradle.properties文件中的代理才结束，
此文件的路径为：/Users/[用户]/.gradle/gradle.properties，你也可以直接打开此文件进行删除 。至此错误消失。File -&gt; Sync Project with Gradle Files成功，xml文件也可以正常预览了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/789d6583e42f034a61fd75f15cac8cee/" rel="bookmark">
			SQL删除语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SQL中有三种删除语句：DELETE、DROP、TRUNCATE
一.DELETE语句
DELETE FROM &lt;表名&gt; [WHERE 子句] [ORDER BY 子句] [LIMIT 子句] delete删除表中指定数据，能与where一起使用
二.DROP语句
DROP [TEMPORARY] TABLE [IF EXISTS] drop删除整个表，包括结构和内容
三.TRUNCATE语句
TRUNCATE TABLE table_name; truncate删除表中所有数据，但不能与where一起使用
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/567cd25763c27ede25ae49c26094e14b/" rel="bookmark">
			VSCode lua开发插件 跳转以及查找索引功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VSCode lua开发插件 跳转以及查找索引功能 插件名：
EmmyLua
插件所需支持项：
1·需要安装java1.18及以上版本
2·需要建立环境变量 变量名:JAVA_HOME 变量值:为安装的java位置
3·不确定是否需要配置bin目录的环境变量
如果第二步操作之后在VSCode中安装EmmyLua右下角还提示需要JAVA1.18版本或者找不到环境变量可以这样设置 [%JAVA_HOME%\bin]
功能展示 鼠标右键对应的函数或者字段会弹出
转到定义
转到引用
lua代码格式化插件推荐 地址Github
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/485a54971cc99bec81ac5df08fe75221/" rel="bookmark">
			动态代理 多态使用 bean依赖注入 实际使用场景
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		远程调用异常处理jdk动态代理
/* * Copyright (c) Huawei Technologies Co., Ltd. 2021-2021. All rights reserved. */ package com.huawei.it.external.config; import com.alibaba.fastjson.JSON; import com.huawei.it.external.service.ITWoRemoteService; import com.huawei.it.jalor5.core.exception.ApplicationException; import com.huawei.it.jalor5.core.log.ILogger; import com.huawei.it.jalor5.core.log.JalorLoggerFactory; import com.huawei.it.jalor5.vegahsa.client.rpc.factory.RpcClientFactory; import com.huawei.it.util.excetion.BizApplicationException; import org.springframework.beans.factory.FactoryBean; import org.springframework.util.StringUtils; import org.springframework.web.client.HttpClientErrorException; import org.springframework.web.client.HttpServerErrorException; import javax.inject.Named; import java.lang.reflect.InvocationHandler; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; import java.lang.reflect.Proxy; /** * 功能描述：封装ITWoRemoteService的代理对象，对远程调用的异常情况进行处理 * 起因：通过Jalor RPC调用，远程调用发生异常时，会将远程异常封装为非ApplicationException * 具体封装的异常详见VegaRestTemplate.getErrorHandler().handleError() * 而由于Jalor统一对异常进行了封装，详见WebServiceExceptionMapper，此种方式会导致 * 非ApplicationException异常，code统一为unknown，message统一为标准异常术语，最终 * 的结果是远程服务抛出的异常提示无法在客户端正常显示 * 这个类封装了什么：本类对异常各种异常进行了捕获，并对异常提示进行封装 * （1）对于4xx异常，抛出异常为”远程服务网络不通，或您无权限进行相关操作” * （2）对于5xx异常，从code中解析异常信息 * （WO系统中直接使用throw new BizApplicationException("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/485a54971cc99bec81ac5df08fe75221/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5887261b47852eb2f3362fbc795d3c90/" rel="bookmark">
			解读坐标系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 空间参考 地球真实形状 大地水准面 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c05666c114cb1275d152be47ce8cd96/" rel="bookmark">
			ABB技术参考手册、RAPID指令、函数和数据类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		地址：
https://download.csdn.net/download/weixin_47816096/87575468
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/167/">«</a>
	<span class="pagination__item pagination__item--current">168/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/169/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>