<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c10019f367cdd2cbf0b986480597aba8/" rel="bookmark">
			2023亚太杯数学建模竞赛C题思路分析&#43;代码&#43;论文
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C题：The Development Trend of New Energy Electric Vehicles in China中国谈新能源电动汽车的发展趋势
新能源汽车是指采用先进的技术原理、新技术和新结构，以非常规车用燃料为动力来源(非常规车用燃料是指除汽油和柴油以外的燃料)，并集成了车辆动力控制和驱动方面的先进技术的车辆。新能源汽车包括四大类:混合动力电动汽车、纯电动汽车、燃料电池电动汽车和其他新能源汽车。新能源电动汽车作为新能源汽车的一种，由于其低污染、低能耗、调峰能力强等特点，近年来获得了快速发展。新能源电动汽车，包括电动公交车和7座以下家用电动汽车，一直受到世界各国消费者和政府的欢迎。
自2011年以来，中国政府积极推动新能源电动汽车的发展，并制定了一系列优惠政策。新能源电动汽车产业取得巨大发展，逐渐成为继“中国高铁”之后的又一个中国标志。现在邀请您的团队完成以下问题:
背景分析：题目说明了新能源汽车对我国的重要性，写到了电动汽车包括电动公交车和7座以下家用电动汽车，这表明，我们需要重点分析这两种类型，后面说到了中国政府积极推动新能源电动汽车的发展，并制定了一系列优惠政策。新能源电动汽车产业取得巨大发展，这段话说明了，题目可能需要让你们写未来的政策导向，这部分就可以在网上找找往年的研究报告、白皮书之类的，选择一部分进行概括摘抄，再结合一些你们在建模中分析出的结论即可。
在正式分析题目前需要说明的是，这道题目的重中之重是搜集数据，这决定了建模结果的上限。比赛周期不算短，建议第一天着重在搜集数据和处理数据上。另外注意，这次的思路由于暂未搜集到（开赛3小时内）非常全的数据集，所以数据集分析可能后续会补，而思路也偏理论多一点。
问题1：分析影响中国新能源电动汽车发展的主要因素，建立数学模型，描述这些因素对中国新能源电动汽车发展的影响。
问题一分析：分析影响因素，可以在论文中采用先分析，然后带出你们搜集到的相关数据的方式，也可以使用先搜集出数据，然后根据一些数据分析结果，来表明这些是主要因素，建议使用后一种，因为更具有说服力一些。
这里因素作为指标已经确定了，那主要这道题目需要建立的是如何量化中国新能源电动汽车发展。这里不可以使用拟合方法，只能使用评价方法，因为因变量是不确定的。
可以使用灰色综合评价法、模糊综合评价法等，简单一点，也可以直接使用AHP（层次分析法）。
如果可以采用先降维出主要因素，后拟合的方式。通常的方法有：
l 主成分分析（Principal Component Analysis，PCA）：PCA是一种线性降维方法，通过找到数据集中最重要的主成分来实现降维。它将原始数据投影到新的正交坐标系中，使得新坐标系上方差最大化，从而保留了数据中最具信息量的特征。
l 线性判别分析（Linear Discriminant Analysis，LDA）：LDA也是一种线性降维方法，但与PCA不同，LDA是一种监督学习方法，主要用于分类任务。它在降维的同时，试图最大化类间距离并最小化类内距离，以获得一个更具判别性能的低维表示。
l 局部线性嵌入（Locally Linear Embedding，LLE）：LLE是一种非线性降维方法，通过在局部区域内保持样本之间的线性关系来构建低维表示。LLE假设数据在高维空间中局部上是线性可分的，并通过重构每个样本与其邻居之间的线性关系，将高维数据映射到低维空间。
l 非负矩阵分解（Non-negative Matrix Factorization，NMF）：NMF是一种用于非负数据的降维方法。它将原始数据矩阵分解为两个非负矩阵的乘积，从而得到潜在的特征表示。NMF常用于图像处理和文本挖掘等领域。
l t-SNE：t-SNE是一种流行的非线性降维方法，用于可视化高维数据。它通过保持样本之间的局部相似性来将高维数据映射到二维或三维空间中。t-SNE能够很好地展示数据中的类别结构和聚类模式。
而拟合的方法，比如：
l 线性拟合：通过线性方程来逼近数据点的方法。最常用的线性拟合方法是最小二乘法。
l 多项式拟合：利用多项式函数来逼近数据点。这些函数可以是一次、二次或更高次的多项式。
l 非线性拟合：当数据无法被线性模型所描述时，可以采用非线性模型进行拟合。例如，指数函数、对数函数等。
l 最小二乘拟合：适用于估计未知参数的线性和非线性模型，以使观测数据与模型预测值之间的差异最小化。
l 回归分析：通常用于探索变量之间的关系，并且可用于预测。简单线性回归、多元线性回归和逻辑回归是常见的回归分析方法。
都是可以使用的，这里拟合后各个指标是有系数的，文字描述一下他们之间的关系即可
问题2：收集中国新能源电动汽车的行业发展数据，建立数学模型来描述和预测中国新能源电动汽车未来10年的发展。
问题二分析：这道题建议收集尽量多年份的时间序列数据，这样更具可信度，模型效果也会更好。这里同时可以收集传统汽车之前的发展趋势，来纵向预测一下中国新能源电动汽车未来10年的发展。
具体地，可以采用正则化系数的方式，来把传统汽车发展趋势这一指标加入本题的数学建模建立。
注意了，预测未来的发展，第一问的综合模型这里简单提一下就行，主要是对里面的主要指标分别进行预测，这样才可以直观的展示出中国新能源电动汽车未来10年的发展情况。
问题3：收集数据，建立数学模型，分析新能源电动汽车对全球传统能源汽车产业的影响。
问题三分析：这道题目还是相对简单的，影响肯定是负面的，全球传统能源汽车产业会受到很大冲击，这个就是本题目的结论，你们需要做的就是用数据佐证这一结论。这道题目可以使用一些可视化图表来进行辅助说明。这里说一些除了传统的那些可视化之外的可视化方法：
l 平行坐标图：用于显示多个数值变量之间的关系，每个变量对应于图中的一条平行线。
l 网络图：展示节点（点）和边（线）之间的关联，适用于展示复杂网络结构。
l 三维散点图：在三维空间中展示三个数值型变量之间的关系。
l 热力图（Heatmap）与气泡地图：用颜色编码显示矩阵数据的变化情况，常用于显示相关性或密度。
l 时间序列图：展示时间序列数据的趋势和周期性。
l 树形图（Tree Map）：以矩形面积来表示层次型数据的一种可视化方式。
这里如果要做的出彩，可以想想，题目问的是影响，影响一般是多个维度的，一般包括：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c10019f367cdd2cbf0b986480597aba8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33c1a55a49bc87780cf80a8a2aa1c73f/" rel="bookmark">
			jenkins 部署前端代码 一键打包飞升无忧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.配置nodejs 2.创建一个自由风格的项目 3.General配置 4.源码管理 5.构建环境 按照具体情况选择是否勾选：Delete workspace before build starts，博主这里情况特殊不用勾选。
6.Build Steps 备注：前端代码没放到docker容器，直接推送到服务器nginx代理目录下
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f15bbd7b793809ff907e85104838ef8a/" rel="bookmark">
			jenkins 部署 Java后端编译打包到版本备份到docker
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.配置基本环境 按照jdk git over ssh等
2.general配置
源码管理
构建环境
build Steps
服务器端：
docker脚本：
DockerFile
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42ebca7ffefa361a5a2cc8bf4fa50279/" rel="bookmark">
			Java网页版仿QQ实现即时通讯在线聊天系统（附源码） 建议收藏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		疫情期间，整天闷在家里又不能聚会，大把的空余时间差点让我发霉，后来有个客户发来新年祝贺，让我突然想起了一件事情，就是他曾经提起过，要是在后台管理系统里面整合个聊天功能该多好啊，有了这个念头，马上行动起来！！！
一、系统演示 1.1 聊天窗体主界面演示 1.2 模拟两人在线聊天（点击图片查看演示视频） 1.3 在线演示 在线演示，点击进入系统
到这里，若是您想要的，接下来听我娓娓道来↘↘
二、开发工具 开发软件：JDK7.0、MyEclipse 2014
开发语言：Java、HTML、Javascript
数据库：MySQL5.6
服务器：Tomcat7.0
三、系统介绍 本系统采用了 B/S 体系结构，以 MySql 作为数据库管理数据，以 JSP 作为前端开发语音，采用当前最流行的 SSM 框架（Spring+SpringMVC+MyBatis），标准的 MVC 模式，将整个系统划分为表现层，controller 层，service 层，dao 层四层，完美整合即时聊天通讯于后台管理系统当中。
本系统仿QQ整合了一套完整的即时聊天功能，包含一对一聊天以及多对多群聊，往着美观大气用户体验高的方针，把分组、好友、群聊完美完整地呈现于主窗体。
主窗体：个性化签名、快速搜索、消息盒子、查找好友查找群组（添加好友、加入群组）、更换皮肤等功能
分组：添加分组、重命名、删除分组、刷新好友列表
好友：发送即时聊天、查看好友资料、查看好友聊天记录、移动好友分组、删除好友
群组：发送群聊信息、查看群组资料、查看群组聊天记录、修改群组图标、创建群组、解散群组、退出群组、刷新群组列表、添加群成员、踢除群成员
聊天：支持常见的文本、表情、图片聊天，还支持发送文件、分享音乐视频，发送代码等功能
四、功能介绍 下面详细介绍主要功能使用与实现：
4.1 整合右键菜单 聊天主窗体最可观的操作方式莫过于右键菜单，本系统整合几大右键功能，分别是右键友好、右键分组、右键群组、右键好友界面的空白地方、右键群组界面的空白地方（如下图）。
右键友好右键分组右键群组 即时通讯聊天系统：整合右键菜单教程，点击进入
4.2 添加好友、加入群组 聊天系统添加好友为最重要功能，本系统在主窗体底部中间“+”号按钮整合查找好友查找群组功能，如下图。
查找界面可根据姓名、手机号或职位进行搜索，找到目标点击“+好友”按钮，系统将推送一条消息到对方的消息盒子，待对方验证通过后，申请添加好友便成功，加入群组也是同理。
即时通讯聊天系统：添加好友进入群组教程，点击进入
4.3 查看更多聊天记录 查看好友的聊天记录、查看群组的聊天记录，是即时通讯不可或缺的功能，本系统在好友的右键菜单中整合了该功能，好友聊天界面也整合了便捷入口，查看记录界面如下图：
即时通讯聊天系统：查看更多聊天记录教程，点击进入
4.4 绑定未读消息数量 在您离线的时候，您的好友发送消息给你，当您登录系统时，避免未能及时查看，应当绑定未读数量于好友末尾，并高亮显示，如下图，对未读消息一目了然！
即时通讯聊天系统：绑定未读消息数量教程，点击进入
4.5 移动好友分组 为了容易管理和查找好友，本系统整理了移动好友功能，比如将您们都喜欢的杨幂小姐姐移动到女神分组，如下图，下次找女神聊天就简单多了。
即时通讯聊天系统：移动好友分组教程，点击进入
4.6 刷新好友列表 右键分组或右键好友窗体空白地方时，右键菜单绑定刷新好友列表，重新绑定即可，看是简单，其中暗藏玄机，值得关注！
即时通讯聊天系统：刷新好友列表教程，点击进入
4.7 邀请好友加入群组 打开群组成员，在成员列表前面绑定添加群成员与删除群成员图标（如下左图），点击添加群成员图标，弹出添加群员界面（如下右图）。
群成员加入好友 即时通讯聊天系统：邀请好友加入群组教程，点击进入
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/42ebca7ffefa361a5a2cc8bf4fa50279/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6401e79c38df3d04a6db3666ea26978f/" rel="bookmark">
			查看linux系统信息的常用命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 查看linux系统内核版本
uname -a
uname -r
cat /proc/version
2. 查看linux系统版本
lsb_release -a
cat /etc/redhat-release
3. 查看linux系统的架构是amd还是arm arch
返回x86_64就是amd的
4. 查看linux系统是32还是64
getconf LONG_BIT
5. 查看系统是实体机还是虚拟机
lspci | grep -i "VMware"
是否有返回值，实体机无返回值
6. 查看网卡是千兆还是万兆
先ifconfig查看使用的网卡，再使用 ethtool 网卡 查看，显示的Speed就是，单位是Mbit
7. 查看系统cpu
cat /proc/cpuinfo
说明：
processor 条目包括这一逻辑处理器的唯一标识符.
physical id 条目包括每个物理封装的唯一标识符。几个物理的cpu.
core id 条目保存每个内核的唯一标识符。
siblings 条目列出了位于相同物理封装中的逻辑处理器的数量。
cpu cores 条目包含位于相同物理封装中的内核数量。
如果处理器为英特尔处理器，则 vendor id 条目中的字符串是 GenuineIntel。
如果cpu cores与 siblings 相同,则说明没有使用超线程,如果siblings 是cpu cores的2倍，则说明支持2个超线程。
8. 查看系统内存
free -m 详细情况：cat /proc/meminfo
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6401e79c38df3d04a6db3666ea26978f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2301524dde8fa8f4818d95ae3f8cb6ca/" rel="bookmark">
			Open AI！50行代码实现GPTs
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		# 关注并星标腾讯云开发者
# 第6期 | 打开新世界大门，50 行 Python 代码调用自己在 ChatGPT 创建的私有 GPTs
OpenAI 5 天令人目不暇接的宫斗大戏看起来好像落下了帷幕，背后的故事细节相信在未来的时间里会逐渐浮现清晰。本文旨在 Drama 新闻如雪花般飞舞的这几天里，为你提供一些技术上的输入。知识的价值，历久弥新。
近期，OpenAI 举办了自己的第一次开发者春晚，并现场推出了新模型 GPT-4 Turbo，及 Plus 会员用户可以基于新模型进行功能自定义的 GPTs。
GPTs，其实就是一个允许用户不使用任何编程技术、不需要调用 ChatGPT API 即可完成训练的一个 AI。有人说，我不需要 GPTs，我用 LangChain+Agent+ChatGPT API 或其它大语言模型的 API，也能实现一个自定义的 GPT。
没错，这么理解是对的！但不是所有人都会编程，也不是所有人都知道 LangChain 如何调用以及 AI Agent 如何开发。ChatGPT 适时推出的 GPTs，它的目标用户群体其实是面向广大不会编程的用户。据 OpenAI 官方宣称，ChatGPT 周活已经达到了 1 亿，预测不久，几百万个甚至几千万个 GPTs 将出现在 GPT Store上。
我在这篇文章“不用编码，也不用会写严格的提示，创建自己的第一个GPT”中已经详细介绍过徒手创建 GPTs 的方法，整个过程很简单只需要七步，首先简单设置一下，再上传一些文件，即可大功告成。在发布的时候，我们还可以选择私有、分享可用及完全公开。
如下图所示，这是我创建的 GPTs —Story Weaver，它是一个私有的GPTs。
对于我们不想让别人看到的，只想让我们自己或团队成员使用的模型，我们则要发布为私有。对于私有的 GPTs，如果我们还想实现在本地自如地调用、并且程序自动化调用，我们应该怎么做呢？
有人可能会想：“我们可以使用 OpenAI 官方提供的 API。”但很遗憾的是，目前 OpenAI 还没有公布这样的接口；即使以后有，它极有可能也是需要付费的。我们在购买 Plus 会员基础上，调用自己创建的 GPTs 的时候，是否可以避免再次付费呢？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2301524dde8fa8f4818d95ae3f8cb6ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08e357d075975c9ad54c63ea1a9233ef/" rel="bookmark">
			javaweb毕设项目 - 网上购物商城系统(含源码&#43;论文)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1 项目简介2 实现效果2.1 界面展示 3 设计方案3.1 概述3.2 系统开发流程3.3 系统结构设计 4 项目获取 1 项目简介 Hi，各位同学好呀，这里是M学姐！
今天向大家分享一个今年(2022)最新完成的毕业设计项目作品，【基于SSM的网上购物商城】
学姐根据实现的难度和等级对项目进行评分(最低0分，满分5分)
难度系数：3分
工作量：5分
创新点：3分
界面美化：5分
界面美化的补充说明：使用vue的基本都能达到5分
本项目完成于2022年6月份，包含内容 : 源码 + 论文 + 答辩PPT
2 实现效果 视频地址：https://www.bilibili.com/video/BV1hW4y1S7qE
2.1 界面展示 管理员登录界面 商品信息管理界面 前台首页功能界面 商品信息界面 3 设计方案 3.1 概述 本文研究的网上购物商城基于当前较为流行的B/S结构，采用Java技术和MYSQL数据库进行开发设计。通过本系统，实现了不同权限的用户登录，包括用户和管理员。管理员:首页、个人中心、用户管理、关于我们管理、商品信息管理、商品类型管理、新闻类别管理、举报投诉管理、订单信息管理、售后管理、新闻信息管理、我的收藏管理、留言板管理、交流论坛、系统管理。用户：首页、个人中心、举报投诉管理、订单信息管理、售后管理、我的收藏管理，前台首页；首页、关于我们、商品信息、新闻信息、交流论坛、留言反馈、个人中心、后台管理、在线客服等功能。本系统经过测试，运行效果稳定，操作方便、快捷，是一个功能全面、实用性好、安全性高，并具有良好的可扩展性、可维护性的网上购物商城。
本系统的开发是基于B/S结构，采用Java程序设计语言及MYSQL数据库进行开发；主要完成了系统的总体设计与规划、数据库的设计、系统页面的制作与美化、系统安全级别的定制和系统程序的编写、调试与修改等工作。
3.2 系统开发流程 系统流程分析是调查分析系统所涉及到的每个环节的业务流程，从网上购物商城的登录着手，以实际操作为出发点，掌握所有网上购物商城内容，保证信息能够正确的输入和输出，数据存储的完整性以及信息处理方法过程，并根据实际操作步骤来绘制出具体的流程图。
3.3 系统结构设计 通过系统需求分析，本网上购物商城包括管理员:首页、个人中心、用户管理、关于我们管理、商品信息管理、商品类型管理、新闻类别管理、举报投诉管理、订单信息管理、售后管理、新闻信息管理、我的收藏管理、留言板管理、交流论坛、系统管理，用户：首页、个人中心、举报投诉管理、订单信息管理、售后管理、我的收藏管理等功能。
4 项目获取 本项目完成于2022年6月份，包含内容 : 源码 + 论文 + 答辩PPT
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45d8864c3c052a2fdca5a76e84ae0273/" rel="bookmark">
			【两种方式愉快的使用go.mod引用自己开发的package包(库）】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GO引用自己写的模块方式1 ——仅使用“根”路径的go.mod 在go中开启了GO111MODULE=on 就可以使用go语言自带的mod来管理自己开发的项目的依赖，从而可以摆脱传统的必须把依赖的模块放在GOROOT或者GOPATH下的src,pkg等目录下的方式。
当我们自己开发了一个公共的模块，并且想要在其他的项目中使用它，那么我们在项目的顶层文件夹的“根路径“下使用如下命令：
go mod init chatroomgo mod tidy 其中 chatroom是自定义的项目名称。
如下的项目，有一个公共的message模块，想要在client和server两个单独的路径下的go程序文件中引用它，
那么我们需要在message这个模块的外层执行上面提到的两个命令。这样做就是把client,server,message视为一整个的大package，用一个go.mod来管理。
整体文件结构如下：
CHATROOM
│ go.mod
│
├─client
│ │ client.exe
│ │ main.go
│ │
│ └─login
│ login.go
│
├─message
│ message.go
│
└─server
main.go
server.exe
而在具体引用message包时，如在client下的login的子pacakge中，引用message模块：
其中引用的时候开头的chatroom是因为在根路径下，使用go mod init命令时把根路径下mod自定义为了chatroom,通过查看go.mod可以看到：
也就是说在根路径下使用go mod init初始化mod时指定的什么mod名称，那么在引用的时候，import的书写形式就以自定义的mod名称开头，然后再按照要引入的模块相对于go.mod的路径进行导入。
这里message模块相对于go.mod的路径就是 go.mod/message 所以导入import的语句就是”chatroom/message”.
而在使用了顶层根路径下的go.mod这种方式管理之后，如果自己的项目文件中有自己单独的内部package需要导入——如client下有一个client自己内部的名为login的package，要在client下的main.go文件中引用它：
那么在client项目下，client/main.go文件中，import时候的形式就如下：
也是从顶层根路径的mod名称开始，按照要引用的package的相对路径进行import.因为login这个package相对于顶层根路径下的go.mod的路径为 go.mod/client/login，所以其在clinet/main.go导入形式就是 “chatroom/client/login”.
容易犯的错误:
如果使用一个顶层go.mod管理这个大项目时，不要在各个子项目下在初始化各个子项目自己的go.mod 如下：
如果除了在顶层文件夹路径下的go.mod之外，在子项目client下使用go mod init client把client又添加go.mod进行定义，此时原来的go文件中的引用形式将不可用：
即使修改import从client的go.mod开始，虽然没有提示错误但是，编译报错：
这样又回归到了最原始的GOROOT和AOPATRH下src的用法，也就是说只要不是处于GOROOT下的src中的package，那么当自己项目路径下的go.mod和要导入的自己开发的模块的go.mod同时存在的时候，就会存在问题。
解决办法有两个：
把自己开发的package模块挪到GOROOT下的src目录下去，作为golang全局公共模块，能被其他项目引用;或者是就只保持在项目的顶层路径下的唯一的一个go.mod即可，不在除顶层文件夹根路径下的其他子项目路径下再初始化任何的go.mod。如在本例中，只保持chatRoom下的唯一一个go.mod，在其余的client,server,message等路径下不再初始化任何自己子项目的mod； 方式1总结：在引用自己开发的package时，把整个项目作为一个大的package用一个go.mod进行管理，开发的公共模块作为其中一个子包package来使用，在顶层文件夹路径下(根路径)进行go mod init的初始化，并且只保持这个根路径下的唯一go.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/45d8864c3c052a2fdca5a76e84ae0273/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2fc693ee197b21121161d8938fb1deba/" rel="bookmark">
			【三维几何学习】自制简单的网格可视化软件 — Mesh Visualization
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自制简单的网格可视化软件 — Mesh Visualization 引言一、整体框架1.1 三角形网格1.2 界面管理1.3 VTK可视化界面 二、核心源码2.1 三角形网格：TriMesh类2.2 界面Widget_Mesh_Manager2.3 VTK可视化2.4 main 引言 使用PyQt自制简单的网格可视化软件 - 视频展示
本是为了方便输入模型分析、网格分割结果可视化，使用PyQt做的一款小软件，后续通过增删变成了Mesh Visualization，主要针对三角形网格。主要功能包括：读取网格(目前仅支持.obj)，关于网格顶点、边、面的一些可视化小操作(是否显示、更改颜色等)、比较简单的灯光以及背景设置、一些基本功能(模型列表、操作日志等)。
一、整体框架 MainWindow：主窗体。包含缩小、放大、关闭、菜单栏等Mesh：三角网格，包含网格的读取、保存、网格的一些基本属性Resource：资源文件夹。包含界面样式和图片Widget_Mesh_Manager：界面管理，内含多个子控件。包含模型列表、网格信息显示界面、日志界面Widget_Vtk：模型渲染界面，就是VTK渲染窗口。包含VTK显示代码actor、mapper、light等
关于界面 统一采用一个界面三个文件：
xxx.ui (可编辑的界面，pyqt插件可打开)ui_xxx.py (ui界面转的py界面文件) 参数设置 $FileName$ -o ui_$FileNameWithoutExtension$.py -xxxx.py (主要在这里写代码) 1.1 三角形网格 三角形网格Mesh文件夹中含有两个文件：
load_and_save.py 读取保存三角形网格，目前只支持obj文件，可用现有的库代替 /todoTriMesh.py 三角形网格类，保存三角形网格的文件名、格式、顶点、面片等信息，每个网格都有一个独立vtk actor，方便操作以及显示 1.2 界面管理 模型列表：显示打开的每一个模型，可以进行模型间的切换显示模型信息：包括顶点和面片数量，可修改点、边、面以及灯光颜色日志显示：记录每一步操作，但目前只显示部分操作 /todo
1.3 VTK可视化界面 主要用于模型渲染显示 (self.vtk_widget = QVTKRenderWindowInteractor(self))：
mapper 映射器，将数据转为图形数据renderer 渲染器，将三维图形转为二维图片light 灯光，只设置了一个灯光 /todo交互方式 vtk.vtkInteractorStyleTrackballCamera() 其中actor每个三角形网格一个，方便单独操作
二、核心源码 2.1 三角形网格：TriMesh类 import ntpath import numpy as np from scipy.sparse import csr_matrix from Mesh.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2fc693ee197b21121161d8938fb1deba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d3d22691599d8fc8ccc442d1317186e/" rel="bookmark">
			华为OD机试-分割均衡字符串（Java&amp;Python&amp;Js）100%通过率
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题意 均衡串定义: 字符串只包含两种字符，且两种字符的个数相同。
给定一个均衡字符串，请给出可分割成新的均衡子串的最大个数。
约定字符串中只包含大写的X和Y两种字符。
输入 均衡串: XXYYXY
字符串的长度[2.100001。给定的字符串均为均衡串
输出 可分割为两个子串:
XXYY
XY
示例 示例1
输入XXYYXY输出2说明无 备注
分割后的子串，是原字符串的连续子串。
题目解析 Java代码 import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner cin = new Scanner(System.in); String s = cin.next(); int n = s.length(); char[] cs = s.toCharArray(); int ans = 0; for (int i = 0; i &lt; n; ) { int j = i + 1, score = cs[i] == 'X' ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d3d22691599d8fc8ccc442d1317186e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/111aabf8b63d171e4370b05941cd7c93/" rel="bookmark">
			deque容器结构学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.结构图 2.deque对比vector和list deque双端队列，就像是list和vector的结合
vector： 优点：1.可以随机读取
2. 空间利用率高
缺点：1. 除了尾插尾删，其他插入删除效率比较低
2. 扩容效率低
list： 优点：1.插入删除效率高
2. 无扩容消耗
缺点：1. 不支持随机读取
2. 空间利用率低
deque： 优点： 1. 支持随机读取
2. 尾插尾删头插头删效率高
3. 扩容消耗低
缺点： 中间位置插入删除很难搞
若扩容数组，中间插入删除效率会高一些，但随机读取的效率会降低
若挪数据，中间插入删除效率会低一些，但随机读取的效率会高
deque的特点是在头尾处理效率高，适合作为栈和队列的适配器容器 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37151e67f0c1acc115990d6c06c91c55/" rel="bookmark">
			Html&#43;Css:美食网页制作(大学生期末大作业详解)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 这是我前几周学html+css时写的简单四川美食首页界面,等我JS学完后会再加以改进,到时重写改一遍,我在这篇详细介绍了首页的总体框架和布局,对于具体css样式我并未做详细讲解,底端附录了我的代码,有需要的可以进行参考.
总体框架 由三个div组成（.header .content .footer），header部分就只是一个标题列表+轮播图；comtent部分是川菜结束+经典菜品+友情链接组成。footer是最底端部分.
总体效果图 .header 顶部导航栏是用table标签内嵌a标签(也可以用li标签内嵌a标签来写),导航栏下边是由四张图片组成轮播图，第二张图.header大纲
.content 川菜介绍用一个div左浮,川菜热点用一个div右浮,经典作品和友情链接是个div.
川菜热点:用li 标签里面包了一个span和文字,span里面写数字并为其设置样式，
经典菜品和友情链接用table标签,不同的是前者文字用span后者文字用包裹
.footer .footer内容比较简单，具体代码如下：
首页.html &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link rel="stylesheet" href="主页.css" /&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="header"&gt; &lt;div class="nav"&gt; &lt;div class="nav-left"&gt;&lt;span&gt;四川美食&lt;/span&gt;&lt;/div&gt; &lt;div class="nav-right"&gt; &lt;table class="table1"&gt; &lt;tr&gt; &lt;td&gt;&lt;a href="主页.html""&gt;首页&lt;/a&gt;&lt;/td&gt; &lt;td&gt;&lt;a href="川菜介绍.html"&gt;川菜介绍&lt;/a&gt;&lt;/td&gt; &lt;td&gt;&lt;a href="经典菜品.html"&gt;经典川菜&lt;/a&gt;&lt;/td&gt; &lt;td&gt;&lt;a href="菜谱大全.html"&gt;菜谱大全&lt;/a&gt;&lt;/td&gt; &lt;td&gt;&lt;a href="联系我们.html"&gt;联系我们&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id="screen"&gt; &lt;div id="tv"&gt; &lt;img src="images/01.jpg" alt="" /&gt; &lt;img src="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37151e67f0c1acc115990d6c06c91c55/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4dbca3ea9e190ee21b42760c970a5d0f/" rel="bookmark">
			论文阅读 Forecasting at Scale (一)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在看时间序列的文章，回顾下经典
论文地址
项目地址
Forecasting at Scale 摘要1、介绍2、时间业务序列的特点3、Prophet预测模型3.1、趋势模型3.1.1、非线性饱和增长3.1.2、具有变化点的线性趋势3.1.3、自动转换点选择3.1.4、趋势预测的不确定性 摘要 预测是一项常见的数据科学任务，能够帮助组织进行容量规划、目标设定和异常检测。尽管其重要性不言而喻，但在生产可靠且高质量的预测时面临着严峻挑战，特别是当涉及到多样的时间序列且具有时间序列建模专业知识的分析师相对稀缺时。为了解决这些挑战，我们描述了一种实用的、可扩展的预测方法，将可配置的模型与分析师参与的性能分析相结合。我们提出了一个模块化回归模型，具有可解释的参数，可以由对时间序列具有领域知识的分析师直观地调整。我们描述了性能分析来比较和评估预测过程，并自动标记需要人工审查和调整的预测。帮助分析师最有效地利用其专业知识的工具能够可靠地、实践地预测业务时间序列。
1、介绍 预测是数据科学中的一项核心任务，对组织内的许多活动都至关重要。例如，各行业的组织必须进行容量规划，以有效地分配有限资源，并进行目标设定，以衡量相对基准的绩效。然而，对于机器和大多数分析师来说，生成高质量的预测并不容易。我们观察到在创建业务预测的实践中存在两个主要问题。首先，完全自动化的预测技术往往难以调整，并且往往过于僵化，无法纳入有用的假设或启发式方法。其次，负责组织内数据科学任务的分析师通常对所支持的特定产品或服务具有深入的领域专业知识，但往往没有时间序列预测的培训。因此，能够产生高质量预测的分析师非常罕见，因为预测是一项需要丰富经验的专业技能。
结果是，对高质量预测的需求往往远远超过了它们的生产速度。这一观察结果是我们进行研究的动机，我们打算为在不同规模下产生预测提供一些有用的指导。
我们首先考虑的两种规模是：1）适用于大量进行预测的人员，可能没有时间序列方法的培训；2）适用于各种可能具有特殊特征的预测问题。在第3节中，我们提出了一个时间序列模型，它足够灵活，适用于各种业务时间序列，同时可以由非专家配置，这些非专家可能对数据生成过程具有领域知识，但对时间序列模型和方法了解有限。
我们所讨论的第三种规模是在大多数实际情况下，将会创建大量的预测，因此需要高效自动的方式来评估和比较它们，并在性能较差时及时发现。当进行数百甚至数千个预测时，让机器来进行模型评估和比较的工作变得非常重要，同时还要有效地利用人类反馈来解决性能问题。在第4节中，我们描述了一个预测评估系统，该系统利用模拟的历史预测来估计样本外性能，并识别存在问题的预测，供人类分析人员了解出了什么问题并进行必要的模型调整。
值得注意的是，我们并不关注典型的规模考虑因素：计算和存储。我们发现，在大量时间序列的预测中，计算和基础设施问题相对来说比较简单，通常这些拟合过程很容易进行并行处理，并且预测结果也不难存储在关系数据库中。我们在实践中观察到的实际规模问题涉及到预测问题的多样性引入的复杂性，以及在生成了大量预测之后如何建立对其的信任。
我们在图1中总结了我们在大规模业务预测中的“分析师在回路中”的方法。我们首先使用灵活的规范对时间序列进行建模，每个参数都有直观的人类解释。然后，我们为该模型和一组合理的基准线在各种历史模拟预测日期上生成预测，并评估预测性能。当预测性能较差或其他方面需要人工干预时，我们按优先顺序将这些潜在问题通知给人类分析师。分析师可以检查预测结果，并根据这些反馈可能调整模型。
2、时间业务序列的特点 商业预测问题的有多样性和共同性。以Facebook活动的时间序列数据为例进行说明，数据显示了每天在Facebook上创建的活动数量。这个时间序列表现出明显的季节效应，包括每周和每年的周期性变化，以及圣诞节和新年期间的显著下降。这些季节效应是由人类活动产生的时间序列中自然而然地出现的。此外，该时间序列在最近六个月显示了明显的趋势变化，可能是由于新产品或市场变化的影响。同时，真实的数据通常会存在异常值，这个时间序列也不例外。
这个时间序列说明了完全自动化方法在产生合理预测方面的困难。图3展示了使用R语言中的forecast包中几种自动化方法进行的预测。这些方法分别是：auto.arima，它拟合一系列ARIMA模型并自动选择最佳模型；ets，它拟合一系列指数平滑模型并选择最佳模型；snaive，一种具有每周季节性的随机游走模型；tbats，一种具有每周和每年季节性的TBATS模型。从图中可以看出，这些方法在匹配时间序列的特征方面都存在困难。自动ARIMA方法在趋势发生变化时容易产生大的趋势误差，并且无法捕捉到任何季节性。指数平滑和季节性随机游走方法能够捕捉到每周的季节性，但无法捕捉到更长期的季节性。所有这些方法都对年末的下降过度反应，因为它们没有充分建模年度季节性。
当预测结果不理想时，我们希望能够调整方法的参数以适应具体问题。然而，调整这些方法需要对底层时间序列模型的工作原理有深入的了解。例如，自动ARIMA方法的第一个输入参数是差分、自回归分量和移动平均分量的最大阶数。普通分析师通常不知道如何调整这些阶数以避免图3中的行为，这是一种难以扩展的专业知识。
3、Prophet预测模型 现在我们描述一个时间序列预测模型，设计用于处理图2中所见到的业务时间序列的共同特征。重要的是，它还被设计为具有直观的参数，可以进行调整，而无需知道底层模型的详细信息。这对于分析师有效地调整模型是必要的，如图1所述。我们的实现以Python和R的形式提供作为开源软件，称为Prophet（https://facebook.github.io/prophet/）。
我们使用分解时间序列模型（Harvey＆Peters 1990），其中包括三个主要模型组件：趋势、季节性和节假日。它们组合在以下方程中：
y ( t ) = g ( t ) + s ( t ) + h ( t ) + ε t y(t)=g(t)+s(t)+h(t)+ε_t y(t)=g(t)+s(t)+h(t)+εt​ (1)
这里，g(t)是趋势函数，用于建模时间序列值的非周期性变化，s(t)表示周期性变化（例如，每周和每年的季节性），h(t)表示在一个或多个日期上可能不规则安排的假日效应。误差项 ε t ε_t εt​表示模型无法适应的任何特异性变化；稍后，我们将对εt做出参数假设，即服从正态分布。
这个规范类似于广义加性模型（GAM）（Hastie＆Tibshirani 1987），一类回归模型，其中对回归器应用了潜在非线性平滑器。在这里，我们只使用时间作为回归器，但可能使用时间的几个线性和非线性函数作为组件。将季节性建模为加法组件的方法与指数平滑（Gardner 1985）采用相同的方法。通过对数转换，可以实现乘法季节性，其中季节效应是乘以g(t)的因子。
GAM的优点在于它很容易进行分解，并根据需要适应新的组件，例如当发现新的季节性来源时。GAM也非常快速适配，可以使用反向逐步回归或L-BFGS（Byrd等，1995）（我们更喜欢后者），以便用户可以交互地更改模型参数。
实际上，我们将预测问题视为一种曲线拟合的过程，这与明确考虑数据中时间依赖结构的时间序列模型本质上是不同的。虽然我们放弃了使用生成模型（如ARIMA）的一些重要推断优势，但这种规范提供了许多实际优势：
灵活性：我们可以轻松地适应具有多个周期的季节性，并让分析人员对趋势做出不同的假设。与ARIMA模型不同，测量值不需要定期间隔，我们也不需要插值缺失值，例如从去除异常值中插值。拟合速度非常快，允许分析人员交互式地探索许多模型规范，例如在Shiny应用程序中（Chang等，2015）。预测模型具有易于解释的参数，分析人员可以更改这些参数以对预测施加假设。此外，分析人员通常具有回归的经验，并且很容易将模型扩展到包括新组件。 自动预测有着悠久的历史，有许多方法专门针对特定类型的时间序列（Tashman＆Leach 1991，De Gooijer＆Hyndman 2006）。我们的方法受到Facebook预测的时间序列的特性（分段趋势、多重季节性、浮动假日）以及大规模预测所涉及的挑战的驱动。
3.1、趋势模型 我们已经实现了两种趋势模型，涵盖了许多Facebook应用程序：饱和增长模型和分段线性模型。
3.1.1、非线性饱和增长 对于增长预测，数据生成过程的核心组成部分是对人口增长的模型以及预期的持续增长模式的建模。在Facebook上进行增长建模通常类似于自然生态系统中的人口增长（例如Hutchinson 1978），其中存在非线性增长，在达到一个承载能力后趋于饱和。例如，在某个特定区域内，Facebook用户数量的承载能力可能是可以接入互联网的人数。这种增长通常使用逻辑增长模型进行建模，在其最基本的形式下是：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4dbca3ea9e190ee21b42760c970a5d0f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bec5ede7666430ba7d673c9d16588a08/" rel="bookmark">
			实用调试技巧2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
6. 如何写出好（易于调试）的代码
6.1 优秀的代码：
6.2 示范（模拟实现strcpy）
6.3 const的作用
6.3.1.模拟实现一个strlen函数
7. 编程常见的错误
7.1 编译型错误
7.2 链接型错误
7.3 运行时错误
6. 如何写出好（易于调试）的代码 6.1 优秀的代码： 1. 代码运行正常
2. bug很少
3. 效率高
4. 可读性高
5. 可维护性高
6. 注释清晰
7. 文档齐全
常见的coding技巧：
1. 使用assert
2. 尽量使用const
3. 养成良好的编码风格
4. 添加必要的注释
5. 避免编码的陷阱。
6.2 示范（模拟实现strcpy） 模拟实现strcpy
可以在cpluscplus里面查看strcpy函数
//void my_strcpy(char* dest, char* src) //{ //	while (*src!='\0') //	{ //	*dest = *src; //	dest++; //	src++; //	} //	*dest = *src; //} //void my_strcpy(char* dest, char* src) //{ //	while (*dest++ = *src++) //	{ //	; //	} //} #include&lt;assert.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bec5ede7666430ba7d673c9d16588a08/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68d342d007b3a733e7b9a8096ad060d5/" rel="bookmark">
			七牛云产品使用介绍之Kodo篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前不久刚参加完七牛云举办的第二届1024创作节（虽然只是我单方面的被各方大佬碾压）
赛题是网页短视频应用开发，要求作品中使用七牛云的相关产品，于是我决定分享下七牛云产品的使用（这么好用的产品很难忍住不想分享的心情😝😝😝）
主要分享下新手如何快速使用，以及仅仅进行想进行测试的小伙伴怎么使用能不产生计费，不仔细看文档随便瞎使用可能会产生计费
【温馨提示】：要使用下面的产品记得先注册账号，绑定邮箱和实名认证哦
安装SDK 七牛云很贴心的帮我们封装好了一个工具包，里面提供各种的类和方法来让我们实现快速对接、开发
&lt;!--七牛云SDK--&gt; &lt;dependency&gt; &lt;groupId&gt;com.qiniu&lt;/groupId&gt; &lt;artifactId&gt;qiniu-java-sdk&lt;/artifactId&gt; &lt;version&gt;[7.7.0, 7.10.99]&lt;/version&gt; &lt;/dependency&gt; 对象存储 Kodo 作用：文件存储，但不仅仅是文件存储，kodo可以跟七牛的其他多种产品结合使用，实现1+1&gt;3的效果
首先要去kodo控制台：https://portal.qiniu.com/kodo/bucket?ref=www.qiniu.com，创建一个存储桶（bucket），bucket是存储文件的容器
点击新建空间，输入空间名称，选择一个区域，选择公开空间（私有也可以，刚入门还是公开吧，以后还能改）
​
创建完了bucket，就可以开始写我们可爱的代码了，咦嘻嘻嘻
先给完整demo代码，再解释含义
public class UploadToQiniu { String bucket = "bucket名"; String AccessKey = "你的ak"; String SecretKey = "你的sk"; Auth auth = Auth.create(AccessKey, SecretKey); // 文件上传 @Test public void uploadV2() { Configuration cfg = new Configuration(Region.region2()); cfg.resumableUploadAPIVersion = Configuration.ResumableUploadAPIVersion.V2; cfg.useHttpsDomains = true; cfg.resumableUploadMaxConcurrentTaskCount = 3; String localFile = "/Users/lixianhe/Downloads/86dac233-65d5-4b38-b40f-cb23dd618489.jpg"; InputStream is = null; try { is = new FileInputStream(localFile); } catch (FileNotFoundException e) { e.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/68d342d007b3a733e7b9a8096ad060d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ebd55490c7a63ca0af473e1bb372dd63/" rel="bookmark">
			Android JNI 异常定位（2）—— addr2line
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android native报错有时候只有一句 signal 11 (SIGSEGV)，这种情况仅通过log是很难定位到问题的。不过Android 在/data/tombstones目录保存了错误的堆栈信息，为定位bug提供了路径。不过一般这里的log都无法像java一样直接定位的出错的行数。如下图：
--------- beginning of crash 11-21 11:31:40.633 F/libc ( 1127): Fatal signal 11 (SIGSEGV), code 1, fault addr 0xcbb45812 in tid 1260 (RenderThread) 11-21 11:31:40.633 W/ ( 203): debuggerd: handling request: pid=1127 uid=1000 gid=1000 tid=1260 11-21 11:31:40.646 E/JNI_MANAGER( 1127): WebRtcAecm_BufferFarend 11-21 11:31:40.647 E/JNI_MANAGER( 1127): WebRtcAecm_BufferFarend 11-21 11:31:40.731 F/DEBUG ( 2352): *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** 11-21 11:31:40.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ebd55490c7a63ca0af473e1bb372dd63/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/524f42218df8f526b8999ca0ea0c1b55/" rel="bookmark">
			2023年七牛云第二届1024创作节-校园黑客马拉松
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		还记得那是 2023年10月8日，一个适合打游戏而不适合学习的日子，那一天，在经历了排位连跪的打击后，我带着激动的心情报名了七牛云第二届1024创作节的比赛（主要是不收报名费🤣）。
本以为在本次比赛中我们组能够大展身手、大杀四方、大显神通、大......，但最终出结果的那一刻，我才发现："这是什么情况😣，大家怎么都这么强"。
本以为是个简单的Web应用开发赛，随便用个Go的框架就顶大天了，没有什么微服务、各种黑科技啥的，结果大家的作品里都是AI、深度学习、算法（明明在参赛群里大家都说什么都不会的，各种放弃，各种游戏，原来都是烟雾弹，原来只有我当真了😭😭😭），下面带着悲壮的心情分享下我们组的作品和参赛经历。
赛题：网页短视频应用 要求：使用七牛云存储、七牛视频相关产品（如视频截帧等）开发一款Web端短视频应用
基础功能（必须实现）
视频播放：播放、暂停、进度条拖拽；内容分类：视频内容分类页，如热门视频、体育频道；­视频切换：可通过上下键翻看视频； 高级功能（可选实现）
账户系统：用户可登录，收藏视频；可参考常见短视频应用自由增加功能，提升完善度，如点赞、分享、关注、搜索等； 看到赛题的要求，我嘴角微微上扬，就这？？？七牛云看不起老子？？？
项目名称 - 牛小音 于是经过的十多天的不断敲代码、内卷、改Bug和熬夜，一个集合了抖音、抖音和抖音的网站初步完成
抖音有的我们没有，抖音没有的我们也没有；（别问，问就是抖音抄袭我们的）
Gitee地址：https://gitee.com/liuhuiying/qiniu.git
作品展示 http://wxapp.qiniu.ijemy.com/lixianhe/docs/%E7%89%9B%E5%B0%8F%E9%9F%B3.mp4
项目技术栈 是不是看起来简单易懂，但是这点东西差点干的我吐血，也可能是我太菜了（┭┮﹏┭┮） 作品实现功能 基本功能 视频播放：支持功能如下： 播放、暂停、进度条拖拽；播放倍速调整（0.5倍、0.75倍、1倍、1.5倍、2倍、5倍）；画中画播放；全屏播放、声音调节；内容分类：将视频分为12个类别，可以按照类别查看对应类别视频；视频切换：支持 上下键切换视频 和 鼠标上下滚动切换视频； 高级功能 登录、注册（注册使用邮箱验证码）、退出登录推荐机制：登录后为用户弹出推荐视频类别，用户勾选类别后，刷视频时，出现该类视频的权重上升 可基于用户级别在个人中心关闭登录推荐用户勾选类别后，以后不会再弹出推荐框 互动功能：收藏、点赞、分享、搜索视频； 其他功能 视频上传：登录后可以进行上传视频（使用Go SDK上传到Kodo存储，上传时通过上传策略操作进行转码和截帧，同时对视频进行审核）
个人中心
查看用户点赞的所有视频；查看用户收藏的所有视频；查看用户上传的所有视频；修改用户的关注的视频类别；设置登录时不弹出类别推荐框； 到此为止，要求中的所有功能已经完成，还附加了不少功能；此刻的我嘴角微微一笑🤭；
心得体会 虽然本次只获得了创作奖，但是以后会继续努力;虽然我已经大四了，明年参加不了;虽然....，😭虽然不下去了，都是泪啊; 不悲观了，从本次竞赛中，学到的很多东西，无论是编程知识上，还是团队协作上，结果也是不错的，创作奖（400块奖金，嘿嘿嘿，都买学习资料去，卷死你们）。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8725f5214c92b5236942348e9f121880/" rel="bookmark">
			GIT | 基础操作 | 初始化 | 添加文件 | 修改文件 | 版本回退 | 撤销修改 | 删除文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GIT | 基础操作 | 初始化 | 添加文件 | 修改文件 | 版本回退 | 撤销修改 | 删除文件 文章目录 GIT | 基础操作 | 初始化 | 添加文件 | 修改文件 | 版本回退 | 撤销修改 | 删除文件前言一、安装git二、git基本操作2.1 初始化git2.2 配置局部生效2.3 配置全局生效 三、认识工作区、暂存区、版本库3.1 添加文件场景一3.2 查看添加的文件3.3 添加文件场景二 四、修改文件4.1 查看工作区的状态 五、版本回退六、撤销修改6.1 情况一：对于工作区的代码，还没有add6.2 情况二：已经add ，但没有commit6.3 情况三：已经add ，并且也commit 了 七、删除文件 前言 Git（读音为/gɪt/）是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。也是Linus Torvalds为了帮助管理Linux内核开发而开发的一个开放源码的版本控制软件。
我们这里就不多介绍这里的GIT了，百度百科和维基百科上都有很多介绍，我们这里就不再介绍，直接来演示~~
下面演示的均是Centos7.6系统，
我们先来检测以下git有没有安装 git --version 如果提示的是这样的就说明没有安装 一、安装git 执行以下命令，安装git yum instal -y git 如果执行失败的话就先更新一下系统 yum update -y 然后再检测是否安装成功~ 二、git基本操作 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8725f5214c92b5236942348e9f121880/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0987d40328fcfa65e2c86bedb78a44bb/" rel="bookmark">
			AHB总线介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 AHB（Advanced High Performance Bus）高级高性能总线，如同USB（Universal Serial Bus）一样，也是一种总线接口。
AHB主要用于高性能模块(如CPU、DMA和DSP等)之间的连接，作为SoC的片上系统总线，它包括以下特性：支持突发传输；支持分段传输；支持多个主控制器；可配置32位~128位总线宽度；支持字节、半字和字的传输。AHB 系统由主模块、从模块和基础结构(Infrastructure)3部分组成，整个AHB总线上的传输都由主模块发出，由从模块负责回应。基础结构则由仲裁器(arbiter)、主模块到从模块的多路器、从模块到主模块的多路器、译码器(decoder)等。
本文主要介绍AHB总线的简化本本AHB-lite总线，相对于AHB总线的区别是他只有一个主机，结构相对AHB总线要简单一些，在很多实际应用中实际上也只有一个Master，因此可以简化设计。
AHB总线的结构如下：
当主机需要对从机进行操作时，首先会根据地址进行译码，选择要操作的从机，将SEL信号给到对应的从机。对于从机来说，只有当输入的片选信号有效时，才能够进行后续的一些操作。
AHB总线的信号 信号名位宽方向
（对于CPU）说明clk1IN总线时钟rst_n1IN总线复位Trans2OUT传输方式控制
0：总线空闲
1：总线忙
2：只传输一个数据
3：连续传输数据Size3OUT数据大小控制
0：每次传输1字节
1：每次传输2字节
2：每次传输4字节
3：每次传输8字节
4：每次传输16字节
5：每次传输32字节
6：每次传输64字节
7：每次传输128字节write1OUT传输方向控制
0：CPU读取设备
1：CPU像设备写数据Port4OUT数据保护策略
bit0：表示传输数据类型。为0表示传输指令，为1表示传输数据；
bit1：表示数据权限。为0时表示使用普通用户权限，为1时表示使用特权；
bit2：是否允许数据被Buffer存储和延迟。为0时表示不允许，为1表示允许；
bit3：是否允许数据被Cache缓存，为0时表示不允许，为1表示允许。Burst3OUTBurst传输策略。
0：只传一个数据；
1：不定长的Burst传输；
2：4次连续传输；
3：8次连续传输；
4：16次连续传输；
5：4次连续WRAP传输；
6：8次连续WRAP传输；
7：16次连续WRAP传输；addr32OUT读写操作地址wdata32OUT写数据rdata32IN读数据HRESP1IN设备状态反馈
0：传输成功；
1：传输中出现错误HREADY1IN全部设备状态反馈。
0：总线上有设备在忙，需等到空闲时才能进行传输；
1：所有设备空闲闲 HSIZE指的是一次传输的数据宽度，而AHB读写数据线的宽度只有32位，因此其HSIZE只会出现0、1、2。
反馈信号HRESP 指的是设备是否处于错误状态，当传输中出现错误即HRESP为1时，表示设备无法满足CPU对其的读写要求，可能出现设备错误导致读写操作无法进行，亦或是设备的处理速度慢，读写存在一定的延时。
反馈信号HREADYOUT是设备内部有一定读写时延时来向CPU反馈的信号，当其 为1时表示总线上的所有设备都是空闲的，此时可以正常进行操作；当其为0时表示总线上有设备正在忙，无法写入数据，只有等待其为1时才能将上次要写入的数据写入设备。而HREADY信号是所有从机HREADYOUT信号相与后的结果
读写时序 AHB总线的读写时序分为两拍完成，分别成为地址阶段和数据阶段，其时序图如下：
在地址阶段，将所有的控制信号都给出，以便使设备能够获取必要的传输信息，主要包括地址等；
在数据阶段，如果为写数据，则主机将会在地址出现的下一拍将数据信号送到总线上；如果为读数据，那么被读设备将会在地址的下一拍将读地址对应的数据传输到总线上。 数据的传输是按照流水线的方式，也就是说在本轮地址给出的下一拍，下一轮的地址便可紧接着给出，此时也正是第一轮的数据被给出的时候。
上面的时序图是在反馈信号HREADY信号一直为1的情况下，当某个设备反应速度较慢并不能在下一拍立刻完成读写时，从机会将自己的HREADYOUT信号拉低，对于主机的HREADY信号也将同时变低，本次读写将不能正常进行，直至这个从机的HREADYOUT信号拉高，才能进行正常写入，时序图如下：
当传输发生错误时，操作地址对应设备的HRESP信号会拉高，此时的传输时序图如下：
AHB总线的优点 优点：
高性能：AHB总线采用分段和流水线设计，可实现高带宽、低延迟的数据传输，适用于高性能系统。可扩展性：AHB总线允许多个主设备和多个从设备同时连接，通过地址映射和优先级控制实现对不同设备的访问管理，提供了灵活的系统扩展性。多设备支持：通过优化的仲裁方案和属性控制线，AHB总线可以同时支持多个主设备和多个从设备，实现对系统资源的共享和并行访问。可靠性和容错性：AHB总线支持错误检测和纠正机制，可以通过错误检查位和冗余数据传输进行数据完整性的验证和故障容错。 缺点：
复杂性：AHB总线的设计较为复杂，包括仲裁、地址映射、优先级控制等方面，需要相应的硬件和软件支持，并且需要清晰的总线协议来确保正确的通信。功耗：AHB总线的高性能和复杂性可能会导致相对较高的功耗，特别是在高频率和大数据传输的情况下。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95776c560ecbafa02e3ea1ea67400b82/" rel="bookmark">
			支持向量机简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		支持向量机（SVM）是一类非常经典的算法，在深度学习成为主流之前，曾一度统治着机器学习界。支持向量机就是要在两个类别中找到一条分隔边界，这条分隔边界可以很好的分开两个类别，并且这个边界到两个类别的距离是最大的。其中两个类别中到这条边界最近的向量叫做支持向量。如下图所示：
支持向量机一般分为三种：线性可分支持向量机，线性支持向量机（也叫软间隔支持向量机，近似线性可分支持向量机），非线性支持向量机。
一般我们所说的就是线性可分支持向量机，事实上，现实生活中更多的是近似线性可分的情况。所谓的“软间隔”就是允许某些样本不满足约束条件，但是在最大化间隔的同时，不满足约束的样本应该尽可能少。
而非线性支持向量机，就是指两个类别的间隔不再是一条直线，而是非线性的，如下图所示：
由于支持向量机算法比较复杂，涉及数学知识较多，我这次就直接用sklearn实现了，从应用角度出发，数学原理方面的内容可以参考周志华的《机器学习》和李航的《统计学习方法》，里面讲的很清楚。
下面我们通过具体的程序来熟悉一下支持向量机的使用方法。首先，从sklearn自带的鸢尾花数据集开始：
import numpy as np from sklearn import datasets from sklearn.pipeline import Pipeline from sklearn.preprocessing import StandardScaler from sklearn.svm import LinearSVC iris = datasets.load_iris() X = iris["data"][:,(2,3)] # 长度，宽度 y = (iris["target"]==2).astype(np.float64) # 第二种类型的鸢尾花 svm_clf = Pipeline([("scaler", StandardScaler()), ("linear_svc", LinearSVC(C=1, loss="hinge"))]) # pipeline是一种类似流水线的机制 # LinearSVC，代表线性支持向量机，C是一个用来进行正则化的参数，C越小，错分会越多， # 但是泛化性较好；C越大，错分越少，但容易过拟合， # hinge损失函数 svm_clf.fit(X,y) # 预测 svm_clf.predict([[5.5,1.7]]) # 输出：array([1.]) 这里我们使用鸢尾花的长度和宽度特征来训练，标签值为是否是第二种类型的鸢尾花，1代表是，0代表否。使用pipeline机制对特征进行标准化，然后使用一个线性支持向量机来学习。可以看到，预测时候，给出特定的鸢尾花长度和宽度，即可判断该鸢尾花是否是第二种鸢尾花类型。
上次我们在介绍逻辑回归的时候使用过手写数字识别数据集，现在用支持向量机SVM来试试结果如何。
from sklearn.svm import SVC digits = datasets.load_digits() x = digits['data'] y = digits['target'] svm_clf = SVC(kernel="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/95776c560ecbafa02e3ea1ea67400b82/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f7cab0935b1b97b9c3013358dca145e/" rel="bookmark">
			Targeting S&#43; (version 31 and above) requires that one of FLAG_IMMUTABLE or FLAG_MUTABLE be specified
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Caused by: java.lang.IllegalArgumentException: com.benben.xxxx: Targeting S+ (version 31 and above) requires that one of FLAG_IMMUTABLE or FLAG_MUTABLE be specified when creating a PendingIntent.
Strongly consider using FLAG_IMMUTABLE, only use FLAG_MUTABLE if some functionality depends on the PendingIntent being mutable, e.g. if it needs to be used with inline replies or bubbles.
targetSdkVersion 31 引起的错误
处理方法
1：创建PendingIntent的时候判断当前系统版本，根据不同系统版本创建带有不同flag的PendingIntent
PendingIntent pendingIntent;
if (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.S) {
pendingIntent = PendingIntent.getActivity(this, 123, intent, PendingIntent.FLAG_IMMUTABLE);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f7cab0935b1b97b9c3013358dca145e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fdecbd1a907af0c8d8df041aaad3ef37/" rel="bookmark">
			Basemap的投影
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Basemap是一个用于绘制地图和空间数据可视化的Python库。它支持多种投影方式，以下是一些常用的投影方式：
1. Cylindrical Equidistant Projection（等经纬度投影）: 'cyl'
2. Plate Carrée Projection（等面积投影）: 'cea'
3. Mercator Projection（墨卡托投影）: 'merc'
4. Miller Cylindrical Projection（米勒圆柱投影）: 'mill'
5. Lambert Conformal Conic Projection（兰伯特等角圆锥投影）: 'lcc'
6. Albers Equal Area Projection（阿尔伯斯等面积投影）: 'aea'
7. Orthographic Projection（正射投影）: 'ortho'
8. Stereographic Projection（立体投影）: 'stere'
9. Mollweide Projection（莫尔维德投影）: 'moll'
10. Robinson Projection（罗宾逊投影）: 'robin'
11. Eckert IV Projection（埃克特四型投影）: 'eck4'
12. Azimuthal Equidistant Projection（等距方位投影）: 'aeqd'
13. Hammer Projection（哈默投影）: 'hammer'
这只是一些常见的投影方式，还有其他投影方式可供选择。您可以根据您的需求选择适合的投影方式来绘制地图。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eaa104931fa5f5f680ea6814952363b7/" rel="bookmark">
			QT QJsonObject 插入 QByteArray十六进制数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		场景描述 有一组十六进制数使用QByteArray进行存储；需要将其插入QJsonObject，然后通过网络发送出去；接收到后，再转换回QByteArray；
操作代码 1. QByteArray转换QString插入QJsonObject QString str = ""; QJsonObject jsonObj; QByteArray byteArray; byteArray.resize(2); byteArray[0] = 0x3c; byteArray[1] = 0xb8; /* QByteArray 转 QString */ str.append(byteArray.toHex()); /* 插入到QJsonObject */ jsonObj.insert("obj", str); /* 网络传输... */ 2.QString解析转换QByteArray // 接收到字符串后... /* QString 转 QByteArray */ QByteArray ba = GetHexValue(str); QString十六进制数据转换QByteArray 参考链接
QByteArray Main::GetHexValue(QString str) { QByteArray senddata; int hexdata,lowhexdata; int hexdatalen = 0; int len = str.length(); senddata.resize(len/2); char lstr,hstr; for(int i=0; i&lt;len; ) { hstr=str[i].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eaa104931fa5f5f680ea6814952363b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e669f2d4547a8c7a287061efc6574de2/" rel="bookmark">
			ubuntu借助overlay方案实现重启自动还原
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		配置重启还原OS 首先：sudo apt install overlayroot 安装一下软件
然后编辑配置文件：/etc/overlayroot.conf
* overlayroot=tmpfs or overlayroot=tmpfs:PARAMETERS write all changes to a temporary (ram only) backing device A tmpfs mount will be created, and usable filesystem can grow to 1/2 available memory. available parameters: * see COMMON PARAMETERS examples: overlayroot=tmpfs 将最后的：overlayroot=“” 改成 overlayroot=“tmpfs:dirs=/home”
临时关闭 到如下界面时，按键盘上的字母‘’
在开机到 grub2 的时候，编辑引导参数加上 overlayroot=disable 即可进入正常模式
参考 https://blog.dustinkirkland.com/2012/08/introducing-overlayroot-overlayfs.html
https://forum.ubuntu.org.cn/viewtopic.php?t=486416
https://bbs.deepin.org/zh/post/261919
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46c83125d8ca7ecbbab8c58d6d90c1d0/" rel="bookmark">
			RK平台查看板子上的dts信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 dts文件描述了硬件每个模块的信息，我们嵌入式软件的调试很多时候都是在改dts文件，有时候我们不确定板子上的固件是否已经更新了我们的修改，这时候我们可以直接读取板子上的dts信息，下面来演示一下。
进入uboot命令行模式 RK的默认SDK中，如果想进入uboot命令行模式，开机的时候在调试串口界面按住键盘的CTRL+C，上电，这时候如果看到如下信息，就说明已经进入uboot命令行模式：
Hit key to stop autoboot('CTRL+C'): 0 =&gt; &lt;INTERRUPT&gt; =&gt; &lt;INTERRUPT&gt; =&gt; &lt;INTERRUPT&gt; fdt基本操作 FDT，flatted device tree，直接翻译过来是：扁平设备树，大概意思就是把设备信息结构存放到device tree文件中。这里我们可以通过帮助选项看其应用：
=&gt; fdt fdt - flattened device tree utility commands Usage: fdt addr [-c] &lt;addr&gt; [&lt;length&gt;] - Set the [control] fdt location to &lt;addr&gt; fdt apply &lt;addr&gt; - Apply overlay to the DT fdt move &lt;fdt&gt; &lt;newaddr&gt; &lt;length&gt; - Copy the fdt to &lt;addr&gt; and make it active fdt resize [&lt;extrasize&gt;] - Resize fdt to size + padding to 4k addr + some optional &lt;extrasize&gt; if needed fdt print &lt;path&gt; [&lt;prop&gt;] - Recursive print starting at &lt;path&gt; fdt list &lt;path&gt; [&lt;prop&gt;] - Print one level starting at &lt;path&gt; fdt get value &lt;var&gt; &lt;path&gt; &lt;prop&gt; - Get &lt;property&gt; and store in &lt;var&gt; fdt get name &lt;var&gt; &lt;path&gt; &lt;index&gt; - Get name of node &lt;index&gt; and store in &lt;var&gt; fdt get addr &lt;var&gt; &lt;path&gt; &lt;prop&gt; - Get start address of &lt;property&gt; and store in &lt;var&gt; fdt get size &lt;var&gt; &lt;path&gt; [&lt;prop&gt;] - Get size of [&lt;property&gt;] or num nodes and store in &lt;var&gt; fdt set &lt;path&gt; &lt;prop&gt; [&lt;val&gt;] - Set &lt;property&gt; [to &lt;val&gt;] fdt mknode &lt;path&gt; &lt;node&gt; - Create a new node after &lt;path&gt; fdt rm &lt;path&gt; [&lt;prop&gt;] - Delete the node or &lt;property&gt; fdt header - Display header info fdt bootcpu &lt;id&gt; - Set boot cpuid fdt memory &lt;addr&gt; &lt;size&gt; - Add/Update memory node fdt rsvmem print - Show current mem reserves fdt rsvmem add &lt;addr&gt; &lt;size&gt; - Add a mem reserve fdt rsvmem delete &lt;index&gt; - Delete a mem reserves fdt chosen [&lt;start&gt; &lt;end&gt;] - Add/update the /chosen branch in the tree &lt;start&gt;/&lt;end&gt; - initrd start/end addr NOTE: Dereference aliases by omitting the leading '/', e.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/46c83125d8ca7ecbbab8c58d6d90c1d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4b19f859abda7cf65b58f7b7791508c/" rel="bookmark">
			vue 获取元素的大小信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在模板中为元素添加一个ref属性：
&lt;template&gt; &lt;div ref="myElement"&gt;Hello, World!&lt;/div&gt; &lt;/template&gt; 然后，在组件的setup函数中使用ref获取元素，并获取元素的信息：
vue2获取方式： mounted() { console.log(this.$refs.myElement); // 输出元素的信息 }, vue3获取方式： import { ref, onMounted } from 'vue'; export default { setup() { const myElement = ref(null); onMounted(() =&gt; { const rect = myElement.value.getBoundingClientRect(); console.log(rect.height); // 输出元素的高度 console.log(rect.width); // 输出元素的宽度 }); return { myElement }; }, }; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8a452bdd3fa2e093d3a8acc4585bd6b/" rel="bookmark">
			大语言模型之十四-PEFT的LoRA
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在《大语言模型之七- Llama-2单GPU微调SFT》和《大语言模型之十三 LLama2中文推理》中我们都提到了LoRA（低秩分解）方法，之所以用低秩分解进行参数的优化的原因是为了减少计算资源。
我们以《大语言模型之四-LlaMA-2从模型到应用》一文中的图3 LLama-2 图例过程为例说明内存的消耗。首先是有32层的Transformer，它们每层的内存占用如下图：
图中有六个大矩阵是打了勾的，原始的LLama2中矩阵的维度是4096*4096，单精度是float（4字节），那么一个矩阵的消耗将是64MB，七个矩阵大约是448MB，共计三十二层，那么总计消耗的内存将约16GB，在训练的时候还要计算梯度和学习率，需要的内存量将是翻倍的大小。例如参数量为1750亿Bloom的，其推理需要约350GB内存。
所以有没有什么办法能够减少内存和算力的需求进行微调呢？降低精度（混合精度、单精度）和量化是一些方法，最新的研究通过微调部分参数来达到精调模型。传统的迁移学习会冻结模型所有权重参数，然后添加额外的迁移学习层来实现迁移学习的任务，这种方法的缺点是
由此针对大语言模型的PEFT的方法被提出来，这里主要是介绍LoRA方法，因为在《大语言模型之十三 LLama2中文推理》合并模型使用的就是这种方法。
LoRA是微软开源的方法，原始paper，其核心思想是减少冗余信息，
矩阵的秩度量的就是矩阵的行列之间的相关性。为了求矩阵A的秩，我们是通过矩阵初等变换把A化为阶梯型矩阵，若该阶梯型矩阵有r个非零行，那A的秩rank(A)就等于r。 如果矩阵的各行或列是线性无关的，矩阵就是满秩的，也就是秩等于行数。
如果X是一个m行n列的数值矩阵，rank(X)是X的秩，假如rank (X)远小于m和n，则我们称X是低秩矩阵（上一篇博客的LoRA采用的方法中，原矩阵是40964096，将其分为409664和64*4096的两个矩阵，这两个矩阵的秩远小于原矩阵 ）。低秩矩阵每行或每列都可以用其他的行或列线性表出，可见它包含大量的冗余信息。利用这种冗余信息，可以对缺失数据进行恢复，也可以对数据进行特征提取。
LoRA 微软的LoRA方法的核心思想如下图所示，预训练的权重用 W W W表示，而需要新训练的矩阵用 A A A和 B B B表示，各层的输出最终变为：
h = W 0 x + Δ W x = W 0 x + B A x h=W_0x+\Delta Wx=W_0 x+BAx h=W0​x+ΔWx=W0​x+BAx
在《大语言模型之十三 LLama2中文推理》基座模型和LoRA 微调模型merge的操作就是实现上述公式的功能。
在大语言模型之十三 LLama2中文推理》中各层Attention的 W q , W k , W v W_q, W_k,W_v Wq​,Wk​,Wv​的维度是 4096 ∗ 4096 4096*4096 4096∗4096，而A和B的权重参数量分别是 4096 ∗ 64 4096*64 4096∗64和 64 ∗ 4096 64*4096 64∗4096，即采用了秩为64（为什么选择这个秩？）的子矩阵训练。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b8a452bdd3fa2e093d3a8acc4585bd6b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6d50d18def106f47e6c309b0e817640/" rel="bookmark">
			华为防火墙USG6000V---内网访问外网---外网访问内网服务器（NAT服务器）示例配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、配置要求
二、配置步骤
1. ping通防火墙接口IP地址的条件
2. 内网ping通外网终端的条件
3. 内网ping通DMZ（内网服务器）的条件
三、命令解析
一、配置要求 内网可以ping通防火墙；内网可以访问外网；外网可以访问内网服务器。 二、配置步骤 1. ping通防火墙接口IP地址的条件 配置接口IP地址；接口添加到域（如trust）；在连接终端（PC）的接口上配置接口允许ping---service-manage ping permit 注：连接在防火墙允许ping接口上的终端，可以ping通防火墙所有已经连接且配置了IP地址的接口。
2. 内网ping通外网终端的条件 配置接口IP地址；接口添加到域；进入安全策略，配置内网到外网互通规则；进入nat策略，配置内网到外网互通规则；配置默认路由。 3. 内网ping通DMZ（内网服务器）的条件 配置接口IP地址；接口添加到域；进入安全策略，配置内网到DMZ互通规则； USG6000V防火墙默认用户名为admin，默认密码为Admin@123 system-view interface GigabitEthernet 1/0/1 ip address 192.168.1.254 24 service-manage ping permit interface GigabitEthernet 1/0/2 ip address 192.168.0.254 24 interface GigabitEthernet 1/0/3 ip address 8.0.0.1 27 firewall zone name DMZ add interface GigabitEthernet 1/0/2 firewall zone trust add interface GigabitEthernet 1/0/1 firewall zone untrust add interface GigabitEthernet 1/0/3 security-policy rule name nei-to-wai source-zone trust destination-zone untrust action permit nat-policy rule name nei-to-wai source-zone trust destination-zone untrust action source-nat easy-ip security-policy rule name fuwuqi source-zone trust destination-zone DMZ action permit ip route-static 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6d50d18def106f47e6c309b0e817640/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0b4125b42c2b320d8151e2a68852695/" rel="bookmark">
			STM32日历读取，设置和输出——实时时钟RTC
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、问题导出
二、 RTC简介
2.1、RTC介绍：
2.2、RTC特征：
2.3、RTC原理框图：
2.4、RTC结构：
2.5、RTC具体流程：
2.6、RTC时钟选择：
2.7、RTC复位过程：
2.8、RTC中断：
三、搭建STM32开发环境（HAL库环境）
四、利用HAL库新建第一小问的工程 （串口显示工程）
五、完善 keil5工程
六、第一小问工程烧录运行 七、利用库函数搭建第二小问工程（OLED显示工程）
1、关于如何搭建STM32库函数环境与库函数工程：
2、完善keil5工程---&gt;编写工程代码：
八、第二小问的电路连接
九、第二小问库函数工程烧录运行
十、总结
十一、参考资料
一、问题导出 阅读资料了解 STM32F103的RTC（实时时钟）原理，使用带SPI或IIC接口的OLED屏显模块实现以下功能：
1) 读取STM32F103C8T6 内部的时钟(年月日时分秒)，日历(星期x），1秒周期，通过串口输出到PC上位机，；
2) 读取AHT20的温度和湿度，通过OLED，把年月份时分秒、日历和实时温度、湿度显示出来，2秒周期。
二、 RTC简介 2.1、RTC介绍： RTC (Real Time Clock)：实时时钟。RTC是个独立的定时器。RTC模块拥有一个连续计数的计数器，在相应的软件配置下，可以提供时钟日历的功能。修改计数器的值可以重新设置当前时间和日期 RTC还包含用于管理低功耗模式的自动唤醒单元。
在断电情况下 RTC仍可以独立运行 只要芯片的备用电源一直供电,RTC上的时间会一直走。RTC实质是一个掉电后还继续运行的定时器,从定时器的角度来看,相对于通用定时器TIM外设,它的功能十分简单,只有计时功能(也可以触发中断)。但其高级指出也就在于掉电之后还可以正常运行。
两个 32 位寄存器包含二进码十进数格式 (BCD) 的秒、分钟、小时（ 12 或 24 小时制）、星期几、日期、月份和年份。此外，还可提供二进制格式的亚秒值。系统可以自动将月份的天数补偿为 28、29（闰年）、30 和 31 天。
上电复位后，所有RTC寄存器都会受到保护，以防止可能的非正常写访问。无论器件状态如何（运行模式、低功耗模式或处于复位状态），只要电源电压保持在工作范围内，RTC使不会停止工作。
2.2、RTC特征： 可编程的预分频系数：分频系数高为220。
32位的可编程计数器，可用于较长时间段的测量。
2个分离的时钟：用于APB1接口的PCLK1和RTC时钟(RTC时钟的频率必须小于PCLK1时钟 频率的四分之一以上)。
可以选择以下三种RTC的时钟源：
HSE时钟除以128；LSE振荡器时钟；SI振荡器时钟 2个独立的复位类型：
APB1接口由系统复位；RTC核心(预分频器、闹钟、计数器和分频器)只能由后备域复位 3个专门的可屏蔽中断：
1.闹钟中断，用来产生一个软件可编程的闹钟中断2.秒中断，用来产生一个可编程的周期性中断信号(长可达1秒)。3.溢出中断，指示内部可编程计数器溢出并回转为0的状态。 RTC时钟源：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0b4125b42c2b320d8151e2a68852695/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c340e704aa6a731743fe2cec3852b84a/" rel="bookmark">
			AI时代的技术底座-向量数据库：一文讲清，建议收藏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、向量数据库是什么
（一）向量数据库发展历史
（二）向量是什么
二、向量数据库的应用场景
（一）向量数据库应用场景
（二）向量数据库产品
（三）向量数据库的搜索原理
（四）向量索引
三、向量数据库的使用
四、向量数据库的发展趋势
一、向量数据库是什么 （一）向量数据库发展历史 向量数据库的发展历程并非严格遵循时间线，而是随着向量检索需求的变化而发展。早期，向量检索的需求相对简单，主要是应用于推荐服务等相似性推荐方面。此时，向量数据库更多地被视为一种程序库，代表性的产品是Facebook开源的FAISS插件库。但是随着技术的进步和应用的不断拓展，向量数据库也逐渐向着更为复杂和多样化的方向发展。
随着不断地发展 ，一些标准化的数据库产品已经认识到了向量检索的重要性，开始在各自的产品中集成了一部分向量特性。这些特性使得它们可以进行一些简单的向量检索，但总体来说，其性能和适用场景仍有较大的局限性。在这其中，比较有代表性的包括像Elastic Search这样的全量检索数据库，还有像PostgreSQL以及Redis这样的数据库，它们都提供了一些向量的特性。
到了现在，随着去年ChatGPT的爆火，向量数据库从幕后正式走向了前台。实际上，向量数据库并不是今年或近两年才出现的新事物，它已经存在很长时间了，但去年ChatGPT的火爆让它真正被大家所了解。
一个完整的AI应用包含了4个重要的环节：
第一个环节是关于大语言模型（LLM)，这是大家在AI体系中接触最多的部分；
第二个环节是与模型相关的Embedding；
第三个环节是向量数据库；
最后一个环节是Promote Engineer。
这些环节共同构成了开发一个完整的AI应用所必需的知识体系。
（二）向量是什么 我们首先探讨一下向量究竟是什么，为了更好地理解，这里我举一个简单的例子。对于从事开发或接触过计算机的朋友们来说，大家都知道颜色的表示法。我们都知道，基础颜色是红色、绿色和蓝色。任何一种颜色都可以通过这三种颜色的组合来得到，这就是一个非常经典的向量表示案例。
在这个例子中，我们看到了几个维度。首先，红、绿、蓝这三种颜色可以被视为一个基准维度，它们构成了一个三维坐标系。这个坐标系可以用来定位一个点。当我们混合这三种颜色时，我们实际上是在这个坐标系上从一个点移动到另一个点。这个移动的过程可以看作是一个向量。
我们再举一个复杂一些的例子，设想一下当我们使用向量来描述一个候选人时，我们可能会考虑几个重要的方面。包括候选人的基本信息，例如学历、工作经历、爱好和综合素质等。
当我们进一步细化这些信息时，我们就可以得到更具体的指标。例如，性别可以细分为男性或女性，年龄可以具体到岁数，而学历则可以包括最高学历以及毕业于哪个学校，工作经历也可以具体到工作年限，以及是否曾在知名公司工作过等等。
通过这些细化的指标，我们可以更全面地了解候选人的背景和特点，从而更准确地评估他们的适合程度和潜力。
假设我们选取了十几个维度来描述一个候选人，以编号为1的候选人小王为例，他的个人信息如下：
小王，男性，28岁，清华大学本科毕业。 我们可以通过这些指标对这个候选人进行抽象化的描述。
我们也可以用同样的方式来描述所有的候选人，将候选人的信息进行定量化表示，从而进行更精确的评估。
进一步地，我们可以将这些信息引入到数学模型中。比如，我们可以根据姓名的规则生成一个数字，使用哈希函数将姓名转换为一个数值。这样，我们就可以将候选人的信息表示为一个向量。
通过这种方式，我们将十几个维度通过数学方式表现出来，最终得到了一个简单的向量化的表示，也就是下图中的3。将候选人的信息进行数字化处理，从而更好地进行比较和分析。
向量数据库中存储的数据实际上是一堆浮点数，这些浮点数排列在一起就像一个数组。这些浮点数的个数在向量数据库中被称为维度。通过这些维度，向量数据库可以存储和检索海量的高维数据，支持复杂的查询和分析操作。
总结一下，向量数据库是一种特殊的数据库，它具备数据存储和读取的基础能力，同时也有一个特殊的查询操作，即向量检索。
向量检索是通过向量的匹配来找到最相似的数据，而不仅仅是简单地查出一行数据。除了这个特殊的功能，向量数据库还具备了数据库的基本特征：数据的改查。对于开发者来说，改查是最基本的需求，而向量数据库也必须具备这些基本功能。
此外，一些向量数据库产品还需要与结构化数据进行结合。在关系模型和关系数据库中，有些需求需要与向量进行结合才能更好地满足。且向量数据库还能够利用硬件特性来加速计算过程，例如使用CPU、GPU等显卡来提高计算效率。
对于一个成熟的数据库，特别是分布式产品，它还必须具备高可用性和分布式的弹性能力。因此，在选择和使用向量数据库时，我们需要考虑这些特点以及我们的具体需求，以便更好地实现我们的目标。
常见数据库类型
上图中展示了几种常见的数据库类型，对比一下平时使用较多的各种数据库：
●第一种就是关系型数据库，其表现特征为二维表格，行和列清晰分明；
●第二个是KV数据库，它以键值对的形式存储数据，且value可以是多种类型，如字符串、数字或二进制等；
●第三种是文档型数据库，如MongoDB，它是通过一对一的映射关系来存储数据；
●第四种是图数据库，以网状结构呈现数据；
●第五个就是向量数据库，在向量数据库中，我们看到了一个三维向量的图，每个向量的数据都可以映射到这个三维坐标系上的一个点；
●最后是分析型数据库，即OLAP数据库，它通常是列存数据库，是在实际应用中使用较多的一类数据库。
回到向量数据库，最终存储到数据库里的实际上是一堆浮点数字。通过将一张图片进行embedding处理，我们得到了它所对应的浮点数向量。这个向量的维度越高，说明转化后的精细度也越高，但相应的计算资源消耗和对硬件条件的要求也会随之增加。
向量数据的结构
二、向量数据库的应用场景 （一）向量数据库应用场景 在初步了解向量数据后，我们来进一步看一下它的应用场景。基于现代数据库的向量检索特性，我们可以将向量数据应用在多个特定场景中。其中，推荐系统是我们日常最常见的应用之一。例如，在刷视频、新闻、购物等相关推荐时，向量数据可以发挥重要作用。
除此之外，图像检索也是向量数据的应用场景之一。相信大家应该都使用过图像搜索功能，现在许多电商APP都具备通过图片扫描产品直接进行搜索的功能，而无需我们自己手动输入产品名称。例如，我们想要购买一台电脑，只需用手机拍摄该电脑，APP即可帮助我们搜索同款产品。类似的，人脸识别、OCR技术用于识别图片中的某些信息等也是向量数据的应用场景。
除了上述举例的之外，许多非结构化数据也是向量数据库可以处理的。非结构化数据指的是那些不能单纯使用传统关系模型描述的数据，如音频、视频、图像等。通过转化处理，这些非结构化数据可以得到相应的数据库，再进行关键性分析。
//一个以图搜图的具体过程示范：
首先，假设我们有一个数据集，里面包含一万张图片。将这些图片通过embedding算法转化成向量数据，比如1000维的向量。然后，这些向量数据会被存储到一个向量数据库中。
当数据库构建完毕后，我们如何找到与指定图片相似的图片呢？可以通过search操作来完成。例如，我指定一张图片，通过相同的embedding模型，在embedding过程中会引入领域中的大语言模型。通过大语言模型的能力，我们可以得到这张图片的向量表示，然后将其传送到向量数据库中进行检索。
在检索过程中，我们利用向量之间的相似度关系进行匹配。当我们找到匹配的图片时，可以选择返回最相似的5张图片。每张图片都有一个距离描述与指定图片的相似度。这个距离越小，说明这两张图片越相似。
通过找到匹配图片的ID和路径，就可以在前端展示搜索结果了。
（二）向量数据库产品 目前市场上存在许多向量数据库产品。从国内和国外两个维度来看，国内有Milvus Manu、京东的VEARCH、蚂蚁金服的ZSearch等产品。Milvus是目前向量数据库赛道里较为热门的产品，而京东和蚂蚁更多的是将它们的应用于内部场景，外部使用较少。
在海外来看，大公司都有自己的向量数据库产品，比较知名的有如Qdrant和Weaviate等等。此外，Pinecone是目前商业向量数据库市场最热门的产品。国内的商业数据库产品有联汇和爱可生自己开发的向量数据库产品，当然这些产品都是基于开源产品进行包装的。
从三个维度来看，这些向量数据库可以分为：向量检索库、向量插件和向量字段。在检索库方面有Meta的Faiss、微软的SPTAG，谷歌的ScaNN等等。插件方面包括ES、OpenSearch和PG等产品中都集成了向量的特性。而向量字段则是数据库本身集成的向量特性，但功能相对较弱。
（三）向量数据库的搜索原理 了解完数据库的产品后，我们先返回来给大家讲解一下向量数据库的搜索原理。这一部分可能会需要一些数学知识。首先，我们回顾一下常用的两种搜索方式：欧氏距离和余弦相似度。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c340e704aa6a731743fe2cec3852b84a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54d7b089bc485417c302d6fc9796e75b/" rel="bookmark">
			Java实现文件管理系统（附源码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文件管理越来越受到企业的重视，最近自己也做了个简单的文件管理系统，现与大家分析交流。
一、系统演示 1.1 主界面 1.2 主要操作 右键文件夹右键文件右键空白地方 1.3 在线演示 在线演示，点击进入系统
二、开发工具 开发软件：JDK7.0、MyEclipse 2014
开发语言：Java、HTML、Javascript
数据库：MySQL5.6
服务器：Tomcat7.0
三、系统介绍 本系统采用了 B/S 体系结构，以 MySql 作为数据库管理数据，以 JSP 作为前端开发语音，采用当前最流行的 SSM 框架（Spring+SpringMVC+MyBatis），标准的 MVC 模式，将整个系统划分为表现层，controller 层，service 层，dao 层四层，完美整合文件资源管理于后台管理系统当中。
往着美观大气用户体验高的方针，本系统仿 window 整合了一套完整的文件资源管理功能，便捷的右键菜单，以及右键菜单各功能的整合。
主页面：头部面包屑，右上角排序方式，主体加载当前文件夹下的所有文件，单击打开文件夹/浏览文件。
右键文件夹：打开文件夹、打包下载、剪切、重命名、删除文件夹。
右键文件：在线浏览文件、下载、剪切、重命名、删除文件。
右键空白地方：新建文件夹、上传文件、排序方式、粘贴、刷新、返回根目录、返回上一层。
四、功能介绍 4.1 头部面包屑 循环当前文件夹的目录，点击其中任意一个目录，系统自动切换到该目录并加载该目录的文件呈现于主体中。
4.2 打包下载 右键文件夹，点击右键菜单中的“压缩下载”，系统自动把该文件夹的首层文件打包在一个文件夹里，然后压缩进行下载。
4.3 剪切、粘贴 右键文件夹或者文件时，点击右键菜单中的“剪切”，切换到目标文件夹下，右键空白地方，点击右键菜单中的“粘贴”，选中的文件夹或者文件就会移动到目标文件夹。
4.4 在线浏览文件 右键文件时，点击右键菜单中的“打开”，或者单击文件时，便可在线浏览文件，可支持所有办公文件（如word、execl、ppt、pdf等）、图片、视频、文本。
4.5 上传文件 右键空白地区时，点击右键菜单中的“上传文件”，可进行多文件上传，上传成功后自动刷新当前页面。
4.6 排序方式 右键空白地区时，鼠标悬浮“排序方式”，在右侧加载二级菜单，可根据类型、名称、修改时间进行排序。
4.7 其他功能 其他功能包括打开文件夹、重命名、删除、新建文件夹、刷新、返回根目录、返回上一层等，听名字便知道大概功能，不一一细说了。
五、附上源码 帅气的人就要唾手可得，源码下载：点击下载源码
六、猜您喜欢 更多小系统与您见面：搭我一程
创作不容易，若对您有帮助，欢迎收藏，记得赏个好评。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b54173de140cf5c85b610e1b2d91ff78/" rel="bookmark">
			写出屎山代码的 12 个技巧 ，一定得会 ！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		来源｜juejin.cn/post/7286155742850449471
👉 欢迎加入小哈的星球 ，你将获得: 专属的项目实战/ Java 学习路线 / 一对一提问 / 学习打卡/ 赠书福利
目前, 正在星球内部带小伙伴做第一个项目：全栈前后端分离博客，手摸手，后端 + 前端全栈开发，从 0 到 1 讲解每个功能点开发步骤，1v1 答疑，直到项目上线。目前已更新了156小节，累计24w+字，讲解图：1027张，还在持续爆肝中.. 后续还会上新更多项目，目标是将Java领域典型的项目都整一波，如秒杀系统, 在线商城, IM即时通讯，Spring Cloud Alibaba 等等，戳我加入学习，已有490+小伙伴加入(早鸟价超低)
工作六七年以来，接手过无数个烂摊子，屎山雕花、开关编程已经成为常态。下面细数一下 降低代码可读性，增加维护难度的 12 个编码“技巧”。
假设一个叫”二狗“ 的程序员，喜欢做以下事情。
1二狗积极拆分微服务，一个表对应一个微服务 二狗十分认可微服务的设计思想。认为微服务可以独立开发和发布，每次改动不会影响其他系统。大大提高了开发人员的效率和线上稳定性。还可以在新服务里使用新的技术，例如JDK 21
于是狗哥把微服务的思想发挥到极致，每一张表都是一个服务。系统的应用架构图十分壮观。狗哥自豪的跟新同学讲解自己设计的系统。新同学看着十几个服务陷入了思考，不停地问着每个服务的作用，干了什么。狗哥很满足。
新同学第一次开发需求，表现很差。虽然他要改10个服务，但是每个服务只改动了一点点。并且由于服务之间都是Rpc调用，需要定义大量的接口，他需要发布好多的 jar，定义版本号，解决测试环境版本冲突，测试和上线阶段可把他忙坏了。
光是梳理上线顺序，新同学就请教了狗哥 三次。最后还是狗哥帮他上线了3 个服务，新同学才赶在 凌晨 3 点前把所有的服务发完。看着新同学买了奶茶的份上，狗哥这次才没有和领导吐槽，“这个同学不行啊，上个线都这么费劲”
微服务过多，也困扰着狗哥。虽然线上流量不高，但是由于 “微服务太多，系统架构复杂"，接口性能不行。
于是狗哥开始进行重构，他重新加了一个开关，新逻辑可以减少Rpc，调用提高性能。狗哥在代码中加了注释 "新逻辑"。
狗哥把代码上线了，但是在线上环境不敢放开，只在测试环境打开了开关。
2二狗积极重构代码，但是线上不放量 狗哥喜欢对代码进行重构，狗哥和领导吹牛，说“ 重构后的代码性能更强，更稳定”。狗哥还添加了注释 ”这是新逻辑“。
但是狗哥在线上比较谨慎，并没有进行放量。只是在测试环境，放开了全量。
新接手的同学不知道线上还没放量，看到“这是新逻辑” ，他就在狗哥的“新逻辑”上改代码。测试环境验证一切正常，到了线上阶段却怎么也跑不通。
此时新同学才发现 ”新逻辑“ 的开关没有打开，你猜，他敢打开这个开关吗？于是他只能删代码，在旧逻辑上重新开发。等到改完代码，再上线时，已经天亮了。
由于这次上线问题，大家一起熬夜加班，需求上线被推迟。新同学被产品和测试一顿骑脸输出。新同学委屈的想要离职。
3二狗喜欢挑战自我，方法长度一定要超过1000行 二狗写代码天马行空。二狗认为提炼新方法会打断自己的编码思路，代码越长，逻辑越连贯，可读性越高。二狗还认为 优秀的程序员写的方法都是 非常长的。这能体现个人的能力。
二狗不光自己写超长的方法，在改别人的代码时，也从不提炼新的方法。二狗总是在原来的方法中添加更长的一段代码。
新同学接手代码时速度很慢，即使加班到凌晨，也不理解狗哥代码设计的艺术。狗哥还向领导抱怨，”你最近招的人不行啊，一个小需求开发这么久，上线还出了bug。“
4二狗喜欢挑战自我，一个方法 if/try/else 要嵌套10层以上 二狗写代码十分认真，想到哪里就写哪里。if/else/try catch 层层嵌套。狗哥的思路很快，并且思考全面， 嵌套十几层的代码一点bug都没有，测试同学都夸赞狗哥 ”代码质量真高啊“，一个bug都没有。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b54173de140cf5c85b610e1b2d91ff78/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/436bdf629c69e51acbbc35b0838d8e41/" rel="bookmark">
			基于猕猴感觉运动皮层的神经元Spike信号分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		公开数据集中文版详细描述参考前文：https://blog.csdn.net/qq_43811536/article/details/134359417?spm=1001.2014.3001.5502
目录 0. 公开数据集1. 神经元的raster和PSTH图1.1 Raster1.2 PSTH 2. 运动轨迹图 (center_out)3. 神经元的运动调制曲线 (tuning curve) 0. 公开数据集 网址：Nonhuman Primate Reaching with Multichannel Sensorimotor Cortex Electrophysiology 1Session：" indy_20170124_01 " 1. 神经元的raster和PSTH图 1.1 Raster 神经元的raster图是一种用于可视化神经元活动的图表，它以时间为横轴，每个神经元的不同脉冲或活动事件为纵轴。每个脉冲或事件用一个点或线表示，多个神经元的活动可以在同一个图表中显示，以便比较它们的活动模式。
在这里，我们将猕猴控制光标向一个新出现的target移动的全过程作为一个trial，并且将二维界面划分为8个不同的方向作为不同的condition，神经元的raster图呈现选定神经元在某一个condition下的所有trials的spike活动。具体处理如下：
提取Spike矩阵：我们将神经元全时程的发放率阈值设定为2，然后从原始数据中得到spike矩阵为[n_neuron, n_time]。其中n_neuron代表预处理后的神经元个数，n_time为整个session的所有时间点，这里“spike_array = [138, 147501]”。划分trials：每一个新的target对应一个trial，由于第一个trial没有规定好的初始位置，所以我们只考虑后486个；同时将360度的二维界面等分为8个方向，即8种不同的conditions。绘制raster：我们选定138个神经元中的前两个，以new_target出现为原点，最长的trial时长为时间轴右边界，-200 ms的上文信息为左边界；将8个方向作为不同conditions，纵轴为当前condition的所有trials。 神经元1-2的raster图如 Figure 1 所示：
Figuer 1. Raster. a. 神经元1. b. 神经元2. 1.2 PSTH PSTH（Peri-Stimulus Time Histogram）图是一种用于显示神经元对特定刺激或事件的响应模式的图表。它以时间为横轴，神经元的活动频率为纵轴，显示在特定时间段内神经元的活动频率。PSTH图通常用于研究神经元对刺激的响应时间和模式。
在这里，我们沿用上一节的数据预处理方式，然后将一个时间段bin大小设为20ms，由于神经信号采样率为250Hz，即一个bin包含5个数据点。我们神经元在单个bin内的所有发放trials个数作为其活动频率的指标，其他设置同raster，最终得到前两个神经元的PSTH图如 Figure 2 所示：
Figuer 2. PSTH. a. 神经元1. b. 神经元2. 2. 运动轨迹图 (center_out) 神经元的运动轨迹图（center_out）是一种常用的方法来可视化神经元的活动模式。该图可以用来显示神经元在不同中心位置的刺激下的活跃程度。通常，"center_out"图使用极坐标来表示刺激的方向和距离。刺激的中心位置通常位于圆心，而刺激的方向和距离则通过圆周上的点来表示。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/436bdf629c69e51acbbc35b0838d8e41/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c16d1617e283087b5e8e227d7fc6354/" rel="bookmark">
			【Java】 Shell 重启 SpringBoot 项目脚本（含服务守护）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 本文介绍了如何使用 Bash 脚本来管理和守护运行服务。将展示一个示例脚本，该脚本可以停止、启动和守护运行一个服务，并提供了相应的解释和用法说明。
引 在实际的软件开发和部署过程中，经常需要使用脚本来管理和控制服务的运行。这些脚本可以方便地停止、启动和监控服务，并在服务意外停止时自动重新启动。在本文中，将展示一个使用 Bash 脚本来管理和守护运行服务的示例。
步骤 首先，看一下示例脚本的结构和关键部分。以下是示例脚本的完整代码：
#!/bin/bash JAR=your_service.jar LOG_FILE=your_service_log_file.log SERVER_HOST=localhost SERVER_PORT=9998 # 停止服务 function stopServer(){ # 检查进程是否正在运行 pid=$(ps -ef | grep "$JAR" | grep -v grep| awk '{print $2}') if [ -n "$pid" ]; then # 杀死进程 kill -9 $pid echo "服务已停止" else echo "服务未运行" fi } # 启动服务 function startServer(){ # 启动服务 nohup java -jar "$JAR" &gt; "$LOG_FILE" 2&gt;&amp;1 &amp; echo "服务正在启动……" # 检测服务是否启动 sleep 10 while !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c16d1617e283087b5e8e227d7fc6354/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9963619649c7ca0394dc18fdf61dd4d/" rel="bookmark">
			【uni-app】uniapp中弹出输入框的示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 uni.showModal({ title: '请输入企业名称', content: '', editable: true, //是否显示输入框 placeholderText: '请输入企业名称', //输入框提示内容 confirmText: '确认', cancelText: '取消', success: (res) =&gt; { if (res.confirm) { this.checkDesc.name = res.content; // console.log('输入的内容：', res.content); } } }); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9e66d486d3ce7b28fcaf56acafcd34d/" rel="bookmark">
			黑猫带你学NandFlash第3篇：nandflash介质工作原理，你想要的都在这里！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 前言 1.1 声明 本文依据不同型号NandFlash spec、个人工作经验及部分网络资料整理而成，如有错误请留言。
文章为付费内容，已加入原创侵权保护，禁止私自转载及抄袭。
文章所在专栏：《黑猫带你学：NandFlash详解》
1.2 注意 该章节节中出现的电压值（例如5V、10V、20V）只是用来举例来解释清楚nand的工作原理，但并不一定表示nand在源极、漏极、控制栅极上加的电压就是这么多。具体的要看每款厂商的nand型号及其说明文档。
1.3 从本文你将获得什么？ 1、nand组成的cell是什么？什么原理用来存储电荷？
2、NAND Flash存储单元组织结构是什么样子的？
3、nand的读写擦的本质原理是什么？
4、program前必须erase的本质原因。
2 NAND Flash存储单元物理组成 NAND的存储单元通常有两种，一种是浮栅极MOSFET(Floating gate MOSFET)，一种是CTF技术存储单元。
较早的都是浮栅极MOSFET(Floating gate MOSFET)，现在更多的NAND采用的是CTF存储技术，其原理基本一样。因此本文档依旧使用浮栅极MOSFET(Floating gate MOSFET)进行介绍。
2.1 浮栅极MOSFET(Floating gate MOSFET) NAND内部存储是金属-氧化层-半导体-场效晶体管(MOSFET)，里面有个浮置栅极(Floating Gate)，是真正存储数据的单元。
了解MOSFET的同学都知道，浮置栅极表面使用绝缘体包围，电子一旦在浮置栅极内部，就出不来了，通过电子的多少（电荷大小），也就能表示0或1，也就是NAND非易失性存储数据的原理。
一般浮置栅极上层的氧化层厚度小于20nm，而控制栅极氧化层的厚度小于10nm。为了避免发生击穿情况，浮置栅极上下两层氧化物的厚度大于5纳米。
这里再简单回顾一下，MOS管的导通原理：
如图所示，是N型MOS管，当给两个N型半导体供电，怎么样都不能导通，因为两个N和P之间就相当于形成了两个反接的二极管，无论怎么样都不能导通。
但是给外面弄上金属导体和绝缘层后，这个金属导体叫做栅级，当给正电时候，P型半导体内部的电子就会被吸引到绝缘层一侧，和N型半导体的电子连在一起，形成N沟道。于是，电路就可以导通了。
2.2 CTF CTF（Charge Trap Flash） ：将多孔（Trap）氮化物（N）作为绝缘体，在孔内填入电荷来区分0与1的方式。用绝缘体氮化物替代原本导体浮栅的存储方式，从根源上杜绝邻近单元间的串扰问题。CTF是一种非平面设计，绝缘体环绕沟道(channle)，控制栅极又环绕着绝缘体层。这种结构设计里面的电荷是储存在一个绝缘层而非之前的导体上，像奶酪一样捕获电子，使其难以动弹。
3 NAND Flash存储单元组织结构 NAND的内部阵列结构如图所示：
关于block、page、WL、BL、string
BL：
每个存储单元的源极和漏极连接在一起，这条线叫做bitline。
WL：
Physical gate connected serially on the same page。NAND Flash将一串存储单元的控制栅极都串联在一条线上，这条线成为wordline。
对SLC来说，一个Wordline 对应一个Page； MLC则对应2个Page，这两个Page是一对(Lower Page和Upper Page)；TLC 对应3个Page ( Lower Page、Upper Page和Extra Page，不同闪存厂家叫法不一样；Lower Page：LSB / Upper Page：CSB / Extra Page：MSB)。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9e66d486d3ce7b28fcaf56acafcd34d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1bb461238896c80948be0dced345775a/" rel="bookmark">
			日期计算星期几及c#代码实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		日期代码+月份代码+年份代码
就可以秒算任意年份任意日期的星期数
方法
1、日期代码指的是日期数，如3月18号，日期代码为18。4月7号，日期代码为7。
2、月份代码（需要小小记忆）
五月 是 0
八月 是 1
二月 三月 十一月 是 2
六月 是 3
九月 十二月 是4
四月 七月 是5
一月 十月 是 6
如果遇到闰年 则二月代码变为1，一月代码变为5，其它不变。即，非闰年的月份代码为622503 514624，闰年的月份代码为512503 514624。
3、年份代码
举个例子 2010年的代码，我们用尾数10除以4（忽略余数）再加上10得到数字12，再用12除以7，得到的余数5就是2010年的代码。
也就是说，心算出2000到2099任意年份的代码，只需将其后两位数X除以4（忽略余数）,然后与X相加，并除以7就可以了，得到的余数就是其年份代码。10年的年份代码是5,11年年份代码为6。
4、秒算任意日期的星期数
如，我们算一下2010年4月25日
日期代码25
月份代码5
年份代码5
日期代码+月份代码+年份代码=25+5+5=35
35是7的倍数，所以2010年4月25日是星期日
再比如算一下2010年10月1日
日期代码1
月份代码6
年份代码5
日期代码+月份代码+年份代码=1+6+5=12
12除以7余5，所以2010年10月1日是星期五
如果得到的代码和是小于7的数，那么此数直接是星期数
如果得到的代码和是大于7的数，那么将该数除以7得到的余数为星期数。
方法二
原理：蔡勒公式
1、W=[C/4]-2C+y+[y/4]+[26(m+1)/10]+d-1 （其中[ ]为取整符号）
2、其中,W是所求日期的星期数.如果求得的数大于7,可以减去7的倍数,直到余数小于7为止.c是公元年份的前两位数字,y是已知公元年份的后两位数字;m是月数,d是日数.方括[ ]表示只截取该数的整数部分。
3、还有一个特别要注意的地方:所求的月份如果是1月或2月,则应视为前一年的13月或14月.所以公式中m 的取值范围不是1-12,而是3-14.
下面时使用c#实现计算过程 方法1 您可以使用.NET框架中的DateTime和DayOfWeek枚举类型来实现这个功能。以下是一个简单的C#代码示例，它将日期转换为星期几：
using System; class Program { static void Main() { // 输入日期 Console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1bb461238896c80948be0dced345775a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45709fc07a275612a1c62e4b64eb6acb/" rel="bookmark">
			python正则表达式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python正则表达式 基础知识 模式（pattern），模式是正则表达式最重要的概念之一，模式可以理解为模版，设计好了模板之后可以利用此模板与未知字符串进行匹配，得到自己想要的结果。比如设计一个电话号码的模式(pattern)，就可以匹配一大串文字中的电话号码。
元字符 元字符通俗地理解就是：并不代表本身字符的含义，而是被赋予了特殊含义的字符。
例如.，在模式里面被用来匹配任意一个字符，与其本身的’点’的含义相去甚远。
又比如?，在模式里面表示前面字符(组)出现的次数为0或1次。
换言之，被占用的无法表征本身含义的字符称之为元字符。元字符包含以下内容：
. ^ $ * + ? { } [ ] \ | ( ) 元字符含义 字符含义举例.任意字符^匹配开头$匹配结尾*匹配0次或多次+匹配1次或多次?匹配0次或1次{}指定匹配重复次数{m,n}至少重复 m 次，至多重复 n 次。m 和 n 不是必填的，缺失的情况下会设定为默认值。缺失 m 会解释为最少重复 0 次 ，缺失 n 则解释为最多重复无限次。[]匹配括号中的任意一个字符[abc]表示a或b或c中的任意一个。匹配正负号：[+-]?
可以使用-连接多个字符，以简化书写，[a-z]、[a-zA-Z]\转义()组类似于改变优先级 元字符^和$在正则表达式中具有特殊的含义，它们可以用来匹配输入字符串的开头和结尾。
^：匹配输入字符串的开头。
例子1：^abc匹配任何以"abc"开头的字符串，例如"abcdef"、"abc123"等。
例子2：^a.b匹配任何以"a"后跟任何字符（除了换行符）再后跟"b"开头的字符串，例如"appleb"和"abab"，但不匹配"ab"或"banana"。
$：匹配输入字符串的结尾。
例子1：def$匹配任何以"def"结尾的字符串，例如"abcdef"、"123def"等。
例子2：a.b$匹配任何以"a"后跟任何字符（除了换行符）再后跟"b"结尾的字符串，例如"appleb"和"abab"，但不匹配"ab"或"banana"。
注意：在多行模式中，^和$的行为与它们在单行模式中的行为不同。
在多行模式中，^和$分别匹配每行的开头和结尾，而不是整个字符串的开头和结尾。
要启用多行模式，请使用re.MULTILINE标志。
如何解除元字符的特殊含义？ 答案是使用反斜杠\
匹配?，需要将模式写为\?匹配.，需要将模式写为\.匹配\，需要将模式写为\\ 存在的问题，多个反斜杠给阅读带来了巨大的障碍，如果需要需要匹配的结果存在的多个斜杠，那么就需要双倍的斜杠用于取消其元字符含义。
例如需要匹配\\，模式写为\\\\。
解决方案，使用原始字符前缀r
使用 Python 的原始字符串表示法来表示正则表达式；反斜杠不以任何特殊的方式处理前缀为 'r' 的字符串字面，因此 r"\n" 是一个包含 '\' 和 'n' 的双字符字符串，而 "\n" 是一个包含换行符的单字符字符串。 正则表达式通常使用这种原始字符串表示法用 Python 代码编写。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/45709fc07a275612a1c62e4b64eb6acb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23b436ff2f4716086ee8b1e1cd3d30bd/" rel="bookmark">
			2.4 矩阵的运算法则
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		矩阵是数字或 “元素” 的矩形阵列。当矩阵 A A A 有 m m m 行 n n n 列，则是一个 m × n m\times n m×n 的矩阵。如果矩阵的形状相同，则它们可以相加。矩阵也可以乘上任意常数 c c c。以下是 A + B A+B A+B 和 2 A 2A 2A 的例子，它们都是 3 × 2 3\times2 3×2 的矩阵： [ 1 2 3 4 0 0 ] + [ 2 2 4 4 9 9 ] = [ 3 4 7 8 9 9 ] , 2 [ 1 2 3 4 0 0 ] = [ 2 4 6 8 0 0 ] \begin{bmatrix}1&amp;2\\3&amp;4\\0&amp;0\end{bmatrix}+\begin{bmatrix}2&amp;2\\4&amp;4\\9&amp;9\end{bmatrix}=\begin{bmatrix}3&amp;4\\7&amp;8\\9&amp;9\end{bmatrix},\kern 10pt2\begin{bmatrix}1&amp;2\\3&amp;4\\0&amp;0\end{bmatrix}=\begin{bmatrix}2&amp;4\\6&amp;8\\0&amp;0\end{bmatrix} ​130​240​ ​+ ​249​249​ ​= ​379​489​ ​,2 ​130​240​ ​= ​260​480​ ​矩阵的加法和向量的加法一样，每次处理一个元素。我们也可以将列向量看成是只有一列的矩阵（ n = 1 n=1 n=1）。 − A -A −A 可以看成是 c c c 乘矩阵 A A A（ c = − 1 c=-1 c=−1），它与 A A A 中全部元素的符号都相反。 A A A 加上 − A -A −A 是零矩阵，它的全部元素均为零。这些是基础知识，下面将考虑矩阵的乘法。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23b436ff2f4716086ee8b1e1cd3d30bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2752720f648caceaf7c64a7543753a0c/" rel="bookmark">
			【二分查找的实现方法----Java的binarySearch()方法】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		二分查找 一、 二分查找简介：二、 二分查找的实现方法：1、普通的迭代：2、普通的递归：3、使用Java自带的方法——Arrays类的binarySearch方法：（1）查找的过程：（2）方法的应用：a.数组内元素唯一：b.数组内元素存在重复值： （3）源码的分析：a.对于第一个现象的解释：b.对于第二个现象的解释： 一、 二分查找简介： 二分查找也称折半查找（Binary Search），它是一种效率较高的查找方法。时间复杂度为O(logn)。
注意： 二分查找要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列。这是实现二分查找的前提。（排序可以使用sort方法）
二、 二分查找的实现方法： 1、普通的迭代： public static void main(String[] args) { int[] arr = {10,14,16,25,28,30,35,88,100}; int index1 =binarySearch(arr,100); int index2 =binarySearch(arr,9); int index3 =binarySearch(arr,101); System.out.println("100的索引为："+index1); System.out.println("9的索引为："+index2) System.out.println("101的索引为："+index3); } //二分查找，递归方法 public static int binarySearch(int[] arr,int key){ int low = 0; int high = arr.length-1; while (low &lt;= high){ int mid = (low + high)/2; if (arr[mid] &lt; key){ low = mid+1; }else if (arr[mid] &gt; key){ high = mid -1; }else if (arr[mid] == key) return mid; } return -1; } 运行结果：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2752720f648caceaf7c64a7543753a0c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b963b6c2d77fe2779bff40aff62fa27b/" rel="bookmark">
			ensp课程设计（实例）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		课程设计报告
需要完成后的topo的可以联系我 课程名称：网络高级优化技术
课题名称：基于校园网络搭建
内容摘要
本文首先规划一个校园的网络，采用接入层、核心层、汇聚层三层网络。所有交换机运行MSTP和VRRP协议，做冗余备份，保护链路安全。运行OSPF动态路由协议，方便路由维护。使用DHCP动态分配地址，便于IP地址管理。配置SSH方便管理，出口采用LSP路由设备，配置ACL合理控制路由。同时在路由器上做EASY-IP，可以让公司内网访问外网。
关键字
OSPF动态路由协议、冗余备份、DHCP动态分配
目录
内容摘要.......................................................................................................................... 2
关键字............................................................................................................................. 2
模拟校园网络实例............................................................................................................ 4
第一章、网络规划与设计................................................................................................. 4
1.1、公司网络设计.................................................................................................... 4
1.2、IP地址和VLAN划分.......................................................................................... 5
1.2.1、LSW1交换机配置..................................................................................... 5
1.2.2、LSW2交换机配置..................................................................................... 6
1.2.3、LSW3交换机配置..................................................................................... 7
1.2.4、LSW4和LSW5交换机配置........................................................................ 8
1.2.5、LSW6交换机配置..................................................................................... 9
1.2.6、LSW7交换机配置..................................................................................... 9
1.2.7、LSW8交换机配置................................................................................... 10
1.2.8、LSP路由器ip地址配置........................................................................... 10
1.2.9、AR1路由器ip地址配置.......................................................................... 10
1.3、OSPF规划与配置............................................................................................. 10
1.3.1、LSP上ospf配置：.................................................................................. 11
1.3.2、核心交换机配置..................................................................................... 11
1.3.3、汇聚交换机LSW2配置........................................................................... 12
1.3.4、汇聚交换机LSW3配置........................................................................... 12
1.4、VRRP规划与配置............................................................................................. 12
1.4.1、汇聚交换机LSW2的vrrp配置................................................................ 13
1.4.2、汇聚交换机LSW3的vrrp配置................................................................ 14
1.5、MSTP规划与配置............................................................................................. 14
1.6、DHCP配置....................................................................................................... 15
1.7、LSP出口路由器ACL配置和NAT地址地址转换配置........................................... 16
1.8、配置SSH服务的验证....................................................................................... 17
第二章、验证测试.......................................................................................................... 18
2.1、实现全网互通................................................................................................. 18
2.1.1、接入层部门（pc）互通......................................................................... 18
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b963b6c2d77fe2779bff40aff62fa27b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d218aa768f0bc7eef0761203382b4cf/" rel="bookmark">
			vue3使用tsx自定义弹窗组件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.在ts代码中使用css 我这里使用了@styils/vue，npm install @styils/vue --save-dev，在tsx文件中引入即可：import { styled } from "@styils/vue";
2.在tsx中初始化组件，创建在src的utils目录中创建messagebox.tsx import { createApp} from "vue"; // 这里使用了element-plus的组件，请自行引入即可 import { ElButton } from "element-plus"; import { styled } from "@styils/vue"; const DivModal = styled('div', { position: 'fixed', width: '100%', height: '100%', left: 0, top: 0, background: '#00000050', display: 'flex', justifyContent: 'center', alignItems: 'center' }); const DivBox = styled('div', { display: 'flex', minWidth: '25%', background: '#fff', padding: '10px 0', color: '#333', borderRadius: '10px', boxShadow: '0 0 3px #00000080', flexDirection: 'column', alignItems: 'center' }); const DivText = styled('div', { marginBottom: '1em' }); const Messagebox = { props: { msg: { type: String, required: true }, }, render(ctx: any) { const { $props, $emit } = ctx; return ( &lt;DivModal class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d218aa768f0bc7eef0761203382b4cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95119f66e5bae7263f5d534ec42b93bb/" rel="bookmark">
			HarmonyOS应用开发者基础认证【闯关习题 满分答案】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章 HarmonyOS应用开发者基础认证【闯关习题 满分答案】
HarmonyOS应用开发者基础认证【满分答案】
HarmonyOS云开发基础认证【最新题库 满分答案】
目录 系列文章【习题】运行Hello World工程【习题】ArkTS基础知识【习题】应用程序框架【习题】构建漂亮的页面【习题】构建更加丰富的页面【习题】属性动画【习题】从网络获取数据【习题】保存应用数据【习题】给应用添加通知和提醒【习题】HarmonyOS应用/元服务上架【习题】使用DevEco Studio高效开发【习题】三方库【习题】HarmonyOS云开发 【习题】运行Hello World工程 判断题
1.DevEco Studio是开发HarmonyOS应用的一站式集成开发环境。 （正确）
2.main_pages.json存放页面page路径配置信息。（正确）
单选题
1.在stage模型中，下列配置文件属于AppScope文件夹的是？（C）
A. main_pages.json
B. module.json5
C. app.json5
D. package.json
多选题
1.如何在DevEco Studio中创建新项目？（B C）
A. 在计算机上创建一个新文件，并将其命名为“new harmonyOS项目”
B. 如果已打开项目，从DevEco Studio菜单选择’file&gt;new&gt;Create Project’
C. 如果第一次打开DevEco Studio，在欢迎页点击“Create new Project”
2.module.json5配置文件中，包含了以下哪些信息？（A B D）
A. ability的相关配置信息
B. 模块名
C. 应用的版本号
D. 模块类型
【习题】ArkTS基础知识 判断题
1.循环渲染ForEach可以从数据源中迭代获取数据，并为每个数组项创建相应的组件。（正确）
2.@Link变量不能在组件内部进行初始化。（正确）
单选题
1.用哪一种装饰器修饰的struct表示该结构体具有组件化能力？（A）
A. @Component
B. @Entry
C. @Builder
D. @Preview
2.用哪一种装饰器修饰的自定义组件可作为页面入口组件？（B）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/95119f66e5bae7263f5d534ec42b93bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e391e7acb2600df872903f4741f4ef2/" rel="bookmark">
			sqlyog报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前情提要 上次把数据库里几个自带的账号的加密方式本来是caching_sha2_password改成了mysql_native_password。
本来的样子:
被我之前都改成了mysql_native_password
sqlyog连接报错 The user specified as a definer (’mysql.infoschema‘@’localhost‘) does not exist 提示show database错误
改回三个默认账户的plugin都改回caching_sha2_password就ok了
原因分析 为什么没有马上报错？还是不懂，大概可能是链接断开了需要重新链接就不行了
几个账号的介绍
infoschema
sys
all
mysql.infoschema:系统用户，管理和访问系统自带的information_schema数据库
mysql.session：mysql的插件将会使用该用户访问mysql数据库服务器。客户端不能直接使用该用户进行链接
mysql.sys：该用户避免数据库管理重命名或者删除root用户时发生的问题，客户端不能直接使用该用户进行链接
root：mysql的超级用户，用于管理mysql数据库，拥有所有权限，可执行任何操作，不建议使用该用户操作mysql数据库。
转载博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ccda59f8b201c3b98b30ed8b31879dd8/" rel="bookmark">
			【Spring】使用xml配置AOP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.前言2.xml配置AOP3. 总结 1.前言 在之前的学习中,都是使用注解的方式进行AOP的配置.其实使用xml配置文件也可以配置AOP.
2.xml配置AOP xml配置AOP方法如下:
添加相关依赖
&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.3.29&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.7&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 相关bean放到Spring容器中
@Service public class StudentService { public void insert(){ System.out.println("StudentService中的insert方法"); } } 创建切面类注入到Spring中,我这里使用的是@Component注解,也可以在配置文件中使用Bean标签
@Component public class Aspect { @Pointcut("execution(* com.example.service..*.*(..)") public void pt(){ System.out.println(""); } public void methodBefore(JoinPoint joinPoint){ Object[] args = joinPoint.getArgs(); Object target = joinPoint.getTarget(); MethodSignature signature = (MethodSignature) joinPoint.getSignature(); System.out.println("Before"); } } 在配置文件中开启组件扫描(因为我在将相应的Bean注入到Spring中时,使用的是注解,如果使用Bean标签,这一步可以省略)
&lt;context:component-scan base-package="com.example"&gt; &lt;/context:component-scan&gt; 在配置文件中配置AOP,将切面类(StudentService)中的methodBefore方法设置为前置通知
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ccda59f8b201c3b98b30ed8b31879dd8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8490489456d5fa73f72e0b4c5e7c84ca/" rel="bookmark">
			pytorch学习笔记（3）--数据集与数据导入（Datasets&amp;DataLoaders）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章 pytorch学习笔记（1）–QUICKSTART
pytorch学习笔记（2）–Tensor
pytorch学习笔记（3）–数据集与数据导入
pytorch学习笔记（4）–创建模型(Build Model)
pytorch学习笔记（5）–Autograd
文章目录 系列文章Datasets &amp; DataLoaders导入数据集迭代和可视化数据集用自己的文件创建自定义数据集initlengetitem 使用 DataLoaders 准备数据以进行训练通过DataLoader进行迭代NormalizationToTensor()Lambda transforms Datasets &amp; DataLoaders pytorch提供两个数据库：torch.utils.data.DataLoader 和torch.utils.data.Dataset
Dataset 存储样本及其相应的标签，
DataLoader 围绕 Dataset 包装一个可迭代对象，以便轻松访问样本。
导入数据集 这里，我们使用FasionMNIST数据集,包含60000个训练样本和10000个测试样本，每个样本大小为28*28，样本标签有10个类别。
每张图片宽W=28像素点，高H=28像素点，一共784个像素。10个类别标签，如T恤、裤子、裙子、包等每个像素的灰度值范围为[0,255],0表示白色，255表示黑色。 数据下载的方式如下：
root:：训练/测试数据的存储路径 train：用于区分训练集/测试集 download = True：如果root没有数据集的话，从网上下载这些数据集 transform 和target_transform区分特征和标签转换。 import torch from torch.utils.data import Dataset from torchvision import datasets from torchvision.transforms import ToTensor import matplotlib.pyplot as plt training_data = datasets.FashionMNIST( root="data", train=True, download=True, transform=ToTensor() ) test_data = datasets.FashionMNIST( root="data", train=False, download=True, transform=ToTensor() ) 输出：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8490489456d5fa73f72e0b4c5e7c84ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6867d53d632c4abff7cdd25e7f4b39ad/" rel="bookmark">
			实用调试技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. 什么是bug？
2. 调试是什么？有多重要？
2.1 调试是什么？ 2.2 调试的基本步骤
2.3 Debug和Release的介绍。
3. Windows环境调试介绍 3.1 调试环境的准备
3.2 学会快捷键
3.3 调试的时候查看程序当前信息
3.3.1 查看临时变量的值
3.3.2 查看内存信息 ​编辑3.3.3 查看调用堆栈
3.3.4 查看汇编信息 3.3.5 查看寄存器信息
4.多多动手，尝试调试，才能有进步。
5. 一些调试的实例
5.1 实例一
5.2 实例二
1. 什么是bug？ 第一代的计算机是由许多庞大且昂贵的真空管组成，并利用大量的电力来使真空管发光。 可能正是由于计算机运行产生的光和热，引得一只小虫子（Bug）钻进了一支 真空管 内，导致整个计算机无法正常工作。
第一次被发现的导致计算机错误的飞蛾，也是第一个计算机程序错误。 2. 调试是什么？有多重要？ 所有发生的事情都一定有迹可循，如果问心无愧，就不需要掩盖也就没有迹象了，如果问心有愧， 就必然需要掩盖，那就一定会有迹象，迹象越多就越容易顺藤而上，这就是推理的途径。 顺着这条途径顺流而下就是犯罪，逆流而上，就是真相
一名优秀的程序员是一名出色的侦探。
每一次调试都是尝试破案的过程。
我们是如何写代码的？
又是如何排查出现的问题的呢？
拒绝-迷信式调试！！！！
2.1 调试是什么？ 调试（英语：Debugging / Debug），又称除错，是发现和减少计算机程序或电子仪器设备中程序 错误的一个过程。
2.2 调试的基本步骤 1.发现程序错误的存在
2.以隔离、消除等方式对错误进行定位
3.确定错误产生的原因
4.提出纠正错误的解决办法
5.对程序错误予以改正，重新测试
2.3 Debug和Release的介绍。 Debug 通常称为调试版本，它包含调试信息，并且不作任何优化，便于程序员调试程序。 Release 称为发布版本，它往往是进行了各种优化，使得程序在代码大小和运行速度上都是最优 的，以便用户很好地使用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6867d53d632c4abff7cdd25e7f4b39ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b6b96923f1b9dfa2f88b6dc24db9e96/" rel="bookmark">
			Javaweb实现数据库简单的增删改查
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JDBC介绍 JDBC （ Java Data Base Connectivity ） 是一 种 Java 访问 数据库 的技术，它提供 执行 SQL 语句的 Java API ，由 一组 类 和接口组成，可以为 不同的 数据库提供统一访问 JDBC工作原理 JDBC应用编程 1、准备工作 安装 MySQL 创建数据库 ( db ) 及表 (user) 的结构、插入一条数据（可借助工具） 项目中引入连接 MySQL 的 JDBC 驱动 Jar 文件。 不同版本的 MySQL ，其 JDBC 驱动文件不同。 在 MyEclipse 的数据库浏览器视图 下，可视化方式创建 MySQL 数据库的连接。 这一步不是 必需的 ， 也可使用 navicat for MySQL 等工具 。但是创建 连接的 作用是， JDBC 编程需要 使用这些连接参数 2、JDBC编程步骤 （1）注册JDBC驱动程序
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b6b96923f1b9dfa2f88b6dc24db9e96/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3cfb383e1a0013609ea3e668fe4ecf72/" rel="bookmark">
			ubuntu系统配置vscode编译调试运行c&#43;&#43;、cmake、ros程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、直接运行c++代码1.配置 tasks.json2.配置 launch.json2.1 默认调试2.2 配置launch自定义调试！很重要！ 3 C/C++ 配置 二、配置VS code运行cmake文件1.建立CmakeLists.txt和cpp文件2. 选择 kit3.选择variant（选择程序编译方式）4. 生成build文件，CMake: Configure5.Build cpp代码6.程序运行或调试6.1 选择运行程序6.2 启动运行或者调试 三、VScode运行和调试ros程序方式一：vscode直接运行ros节点方式二、调试ros节点debug方式三、调试 用launch启动节点 四、配置VS code编译运行多个执行文件参考教程：VS code官网：博客 一、直接运行c++代码 通过使用 GCC C++ 编译器 （g++） 和 GDB 调试器，在 VS Code 中编译和调试一个简单的C++程序。
其中，GCC 代表 GNU 编译器集合；GDB 是 GNU 调试器。
三个关键文件介绍：
tasks.json ：compiler build settingslaunch.json ：debugger settingsc_cpp_properties.json ：compiler path and IntelliSense settings 1.配置 tasks.json tasks.json（run helloworld.cpp）
1.打开cpp文件，使其成为活动文件。
2.按编辑器右上角的播放按钮。
3.生成task文件
从系统上检测到的编译器列表中选择 g++ 生成和调试活动文件（g++ build and debug active file）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3cfb383e1a0013609ea3e668fe4ecf72/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f72180d9c8012087ced225d34b757f5/" rel="bookmark">
			电路负压芯片可选
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.由正压转负压 1.1 TPS5430 可选TI公司DCDC芯片TPS5430DDAR，这款芯片输入电压范围5.5V-36V，输出电压1.221V~32.04V，输出电流最大3A。
博主棒棒糖所设计的24V转±12V模块原理图如下所示：
上图参考链接https://oshwhub.com/hshgc/tps5430-dan-dian-yuan-zhuan-zheng-fu-shuang-dian-yuan
datasheet中12V转5V应用如下：
同理，需要产生-5V电压只需要将GND与5V引脚互换即可。
1.1.1 本人所设计12V转-5V原理图如下： 1.1.2 由上述原理图所设计PCB模块如下： 1.1.3 焊接成品如下： 通过测量，-5V输出电压正确，表明方案可行。
1.2 LT1611 ADI公司的DCDC芯片LT1611，输入电压900mV到10V，输出电压为-10V到-900mV，最大输出电流550mA，该芯片可以直接将正电压转换为负电压。
其150mA输出电流典型电路如下：
2.由负压转负压 2.1 LDO 7905 市面上的7905芯片非常多，常见的主要包括江苏长晶的CJ7905、华冠的LM7905T、TI的 LM7905CT等。其中长晶CJ7905芯片为例：其输出电压最大-35V，输出电压为固定-5V，输出电流最大1.5A。
其典型应用如下：
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/56/">«</a>
	<span class="pagination__item pagination__item--current">57/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/58/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>