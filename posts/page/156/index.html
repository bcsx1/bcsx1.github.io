<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8d8171c81016e7a373289a1341a5bf1/" rel="bookmark">
			SAP开发环境ABAP的搭建(客户端和服务器),Developer Key和AccessKey的绕过方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一.前言
二.客户端GUI安装
1.下载好SAP GUI 750
2.解压后找到SAPGUISetup.exe
3.安装
4.安装完整教程
三.服务端搭建
1.安装VmWare虚拟机
2.下载虚拟机镜像
3.打开虚拟机
4.调整内存大小
5.启动虚拟机
四.创建程序
1.创建包
2.创建程序
3.Developer Key和AccessKey问题及绕过方法
一.前言 这学期选修了SAP技术应用,寻遍全网千辛万苦方才搭建好ABAP的客户端和服务器,满怀喜悦使用SE38准备编程,又遇到Accesskey访问键值的阻碍.秉持着开源共享精神,写下此篇.
二.客户端GUI安装 环境搭建使用到的资源链接：https://pan.baidu.com/s/1Ny9XhE0jFuhc0CznjqoNrw?pwd=ckzl 提取码：ckzl
1.下载好SAP GUI 750 2.解压后找到SAPGUISetup.exe 路径:\SAP GUI 750\50139435_6\BD_NW_7.0_Presentation_7.50_Comp._1_\PRES1\GUI\WINDOWS\WIN32
3.安装 勾选上最上面的SAP GUI Suite,剩下的最好创建一个文件夹用于安装客户端,默认是C盘.其他的next即可
4.安装完整教程 推荐观看视频: SAP客户端安装
三.服务端搭建 这里推荐一篇文章: SAP环境搭建(ABAP环境搭建)的教程及相关资源分享
推荐视频:MM模块初级顾问培训-SAP 服务端虚拟机安装
1.安装VmWare虚拟机 这里不多赘述,推荐视频:完全免费的VMware虚拟机下载安装激活教程
2.下载虚拟机镜像 上方链接中的ECC6.0 EHP7虚拟机无数据,压缩包共有15g,解压后的文件夹有70g,所以最好下载在冗余100g左右的硬盘中 3.打开虚拟机 点击打开虚拟机
找到虚拟机镜像所在位置,路径E:\BaiduNetdiskDownload\ECC6.0 EHP7 虚拟机无数据\SAP ECC6 EHP7 VM\Windows Server 2003 Enterprise x64 Edition.vmdk
选中.vmdk镜像打开即可
4.调整内存大小 这个虚拟机镜像默认的最大内存大小貌似是4还是2个g,不记得了,最好调整到8g左右,因为服务端耗费内存较多.点击编辑虚拟机设置即可调整最大内存大小
5.启动虚拟机 点击开启此虚拟机
在上面的虚拟机镜像文件所在文件夹中,还有个虚拟机使用文档,这里面保存了登录密码和用户名
启动虚拟机后需要登录,密码输入686470 即可(可能输出不进去数字,这是由于虚拟机默认关闭了右侧数字输入区,按一下num lock即可)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c8d8171c81016e7a373289a1341a5bf1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b24d82121e4e5d580672d00ec35ced09/" rel="bookmark">
			Sumo学习日记-day2 路网编辑及仿真流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Sumo学习日记-day2 路网编辑及各个文件说明 很久没有写博客了，因为最近比较忙碌，但是自己还是在不断的学习。最近对sumo学习的一些相关经验一直想写一个系列的博客跟大家分享，但是还没有一个具体的思路，目前是按照自己学习的一些路线跟大家分享，有错误的话大家多多担待！
文章目录 Sumo学习日记-day2 路网编辑及各个文件说明路网编辑文件一、nod.xml文件二、 edg.xml三、rou.xml四、net.xml四、其余xml文件1.con.xml2.add.xml 五、sumocfg文件总结 路网编辑文件 Sumo的运行是离不开路网文件的，包括VISSIM在内的一系列交通仿真软件都是需要进行路网编辑的，这里先对路网文件进行一些具体的说明，也为后面Sumo的学习补充一些基础知识。
一、nod.xml文件 node是sumo中比较基础的节点，它一般表示道路的一个节点，学过其它仿真软件的话应该了解相关的概念。一般道路开始、结束点都是一个节点。nod.xml文件就是用来定义这些节点。
&lt;?xml version="1.0" ?&gt; &lt;nodes&gt; &lt;node id="1" x="0" y="0" type="traffic_light"/&gt; &lt;node id="2" x="0" y="300"/&gt; &lt;node id="3" x="0" y="1000"/&gt; &lt;node id="4" x="300" y="0"/&gt; &lt;node id="5" x="1000" y="0"/&gt; &lt;node id="6" x="0" y="-300"/&gt; &lt;node id="7" x="0" y="-1000"/&gt; &lt;node id="8" x="-300" y="0"/&gt; &lt;node id="9" x="-1000" y="0"/&gt; &lt;/nodes&gt; 一个简单的交叉口路网的nod.xml文件就像上面所展示的一样，id表示节点的唯一ID，这个id不能重复，不然会报错，x和y分别表示节点的坐标（这个坐标比较坑，因为和traci里的坐标不一样），坐标以左下角为原点，x轴为横向，y轴为纵向。
二、 edg.xml edge文件即edg.xml文件主要是定义路线信息，包括车道数量信息，主要是确定起始节点和结束节点以及是否允许换道，因为交叉口在靠近交叉口的地方不允许换道，所以需要定义多个节点。
&lt;?xml version="1.0" ?&gt; &lt;edges&gt; &lt;edge from="1" id="N_out_1" to="2" numLanes="2"/&gt; &lt;edge from="2" id="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b24d82121e4e5d580672d00ec35ced09/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/826613036fde07233ba841c312b6e159/" rel="bookmark">
			回文链表：给一个单链表的头节点 head ，请判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		回文链表
思路三步走：
第一步：找中间结点
第二步：反转后半段链表
第三步：判断是否回文
//核心代码段 bool isPalindrome(struct ListNode* head){ struct ListNode* mid = head; struct ListNode* end = head; struct ListNode* next = NULL; struct ListNode* rhead = NULL; if(head == NULL) { return false; } // 找中间结点 while(end &amp;&amp; end-&gt;next) { mid = mid-&gt;next; end = end-&gt;next-&gt;next; } //逆序后半部分链表 while(mid) { next = mid-&gt;next; mid-&gt;next = rhead; rhead = mid; mid = next; } //判断是否回文 while(head &amp;&amp; rhead) { if(head-&gt;val !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/826613036fde07233ba841c312b6e159/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3bced044d2c887286dee74721eb6ddc/" rel="bookmark">
			CSRF(跨站请求伪造)详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.什么是CSRF CSRF全称Cross-Site Request Forgery，也被称为 one-click attack 或者 session riding，即跨站请求伪造攻击。
当发现网站存在CSRF漏洞时，攻击者会利用网站源码，构建一个存有恶意请求的网站或者是链接，引诱受害者访问，那么当受害者在访问攻击者伪造的网站，同时，又在访问攻击者攻击的目标网站且没有关闭会话，那么攻击者就成功完成了CSRF攻击！
攻击者可以发送请求包，比如：修改邮箱的，上传文件的等等。与XSS不同的是，CSRF只是利用cookie，而不是窃取cookie。
CSRF的高危触发点
论坛交流，用户中心，反馈留言，交易管理，后台管理
2.原理 广义的理解
游览器在你不知道的情况下偷偷的发送了数据包。
核心在于游览器你的cookie得到了游览器的信任，然后通过Ajax异步传输获取信息（通过JS发送了带有恶意代码的请求包）！
狭义的理解
1、受害者打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A；
2、在受害者信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时受害者登录网站A成功，可以正常发送请求到网站A；
3、受害者未退出网站A之前，在同一浏览器中请求了攻击者的B网站
4、网站B接收到受害者请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A；
5、浏览器在接收到这些攻击性代码后，根据网站B的请求，在受害者不知情的情况下携带Cookie信息，向网站A发出请求。网站A并不知道该请求其实是由B发起的，所以会根据受害者的Cookie信息以受害者的权限处理该请求，导致来自网站B的恶意代码被执行。
3.CSRF的分类 A.GET型
我们有的时候会遇到数据修改是通过GET请求来发送的，比如:
/news/index.php?id=1&amp;&amp;email=666@qq.com
此链接是用户id=1将邮箱修改666@qq.com，当我们知道CSRF之后，可以伪造邮箱修改为777@qq.com的链接发送给用户，当用户游览此网页时，点击了链接，邮箱就成功被修改了。这样我们就可以利用邮箱来修改用户的密码。
B.POST型
假如一个网站的用户密码修改功能存在CSRF，我们可以通过修改密码时抓包，伪造一个相同的数据包，发给正在访问密码修改功能的用户，当用户访问链接时，写入自动提交的JS代码，这样用户的密码将自动更改！
Burp可以帮助我们伪造数据包，例如：
JS自动提交的代码
&lt;script&gt; document.getElementByld('标签名').submit(); &lt;/script&gt; 4.条件 a.用户已经登录了站点 A，并在本地记录了 cookie;
b.在用户没有登出站点 A 的情况下（也就是 cookie 生效的情况下），访问了恶意攻击者提供的引诱危险站点 B (B 站点要求访问站点A);
c.站点 A 没有做任何 CSRF 防御;
5.CSRF检测方法 a.抓取一个正常请求的数据包，如果没有Referer字段和token，那么极有可能存在CSRF漏洞;
b.如果有Referer字段，但是去掉Referer字段后再重新提交，如果该提交还有效，那么基本上可以确定存在CSRF漏洞;
c.利用工具进行CSRF检测。如：CSRF TESTER，CSRF REQUEST BUILDER等;
6.防御方法 a.验证HTTP Referer字段
HTTP请求头中的referer字段记录了请求来源的地址，可以验证请求来源是用户自己，还是黑客！因为黑客构造的拦截或者是网站，用户访问后产生的数据包里的Referer肯定是指向黑客的！
b.在请求地址中添加 token 并验证(Anti-CSRF token)
CSRF攻击主要是黑客伪造了网站相似的链接或者是页面，只要在数据包中加入让黑客无法运算出的随机值，并且每次接收时都要验证该值，即可抵制黑客伪造的数据包！
该方法有一个缺点是难以保证 token 本身的安全。特别是在一些论坛之类支持用户自己发表内容的网站，黑客可以在上面发布自己个人网站的地址。由于系统也会在这个地址后面加上 token，黑客可以在自己的网站上得到这个 token，并马上就可以发动 CSRF 攻击。为了避免这一点，系统可以在添加 token 的时候增加一个判断，如果这个链接是链到自己本站的，就在后面添加 token，如果是通向外网则不加。不过，即使这个 csrftoken 不以参数的形式附加在请求之中，黑客的网站也同样可以通过 Referer 来得到这个 token 值以发动 CSRF 攻击。这也是一些用户喜欢手动关闭浏览器 Referer 功能的原因。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b3bced044d2c887286dee74721eb6ddc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9073bf3a61d7940b2acb11e8dcf05f70/" rel="bookmark">
			半年总结 -永远不变的就是变
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		匆匆的半年又过去了，回想上大学已经是4年前的事情了，omg，当总结的时候，感觉时间过的真的好快呀。
工作 半年，工作发生了很大的变化，离开了之前的公司，来到了现在的公司，考虑到了在疫情最严重的12月离职，我觉得我真的很有勇气，考虑到疫情很多公司都比较困难，所以选择了一个外包公司，虽然知道外包公司有很多不好，但是外包到了GE，我觉得短短几个月，学习到了很多，他们的工作方式，他们的价值观，还有同事的办事风格，工作的内容都和之前有很大的不同可以说。所以觉得在这个公司，收获还是很大的。
与之前的互联网公司有所不同，在这里又接触了好久之前只接触到皮毛的linux有关知识，还有C++，虽然有时候觉得还得熟悉才能干活，效率很低，但是从长远看还是会有收获，那些东西会潜移默化到人的心中和价值观中。
学习 又增加了一次败北的考试，心态也有了变化，我之前如果成绩不好，会承认自己不够努力，学习方式不对，或者自己不够聪明，但是这次我考试，让我想到的天命，命运这样的东西，为什么会这么想呢，因为觉得自己学习很高效，知识点也都掌握了，所以是第一次非常非常自信觉得自己可以，但是现实给了我狠狠的一击，让我明白了一些道理，经过2周的调节吧，慢慢的心态恢复过来了，以后只会多多去努力，多往自己身上找原因，尽人事，听天命，不再怨天尤人。
在工作中也增进了C++，linux的学习，所以也浅浅记录一下吧!
生活 因为又从新回到北京工作，生活有了很大的变化，可能会有孤独，失落，无聊，但是乐观的去想有时候去尝试新的生活又何尝不是一种勇气呢
每次都会提醒自己不忘初心，要一直一直学习，学习获得的快乐比起一些刺激获得的快乐是长久而稳定的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed96af7c2f7346d7bb2a3815e16cc9db/" rel="bookmark">
			python对接chatGPT的API踩坑历程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果python版本3.7.1以上，可以直接【目前测试官网3.9版本比较稳定！】
本人实测，正常运行
python3 -m pip install --upgrade pip
No matching distribution found for pandas&gt;=1.2.3 (from openai==0.10.5) python3 -m pip install --upgrade pip
AttributeError: module 'openai' has no attribute 'ChatCompletion'或者 AttributeError: module 'openai' has no attribute 'Model' 从https://pypi.org/project/openai/#files下载，上传到服务器， openai-0.27.0-py3-none-any.whl然后在该路径下pip3 install openai-0.27.0-py3-none-any.whl ERROR: Package 'openai' requires a different Python: 3.6.8 not in '&gt;=3.7.1' 显示python版本需要更高等级
Linux 下安装Python3.8_linux安装python3.8_dongfs-821的博客-CSDN博客
(Caused by SSLError("Can't connect to HTTPS URL because the SSL module is not available.")) 【改装python3.9】
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e9ad06e95883189c318eb488b736f13/" rel="bookmark">
			CentOS7中使用yum安装Nginx
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 linux centos7.6安装 nginx
1、添加源 默认情况Centos7中无Nginx的源，最近发现Nginx官网提供了Centos的源地址。因此可以如下执行命令添加源：
sudo rpm -Uvh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm 2、安装Nginx 1.使用命令，看看是否已经添加源成功 yum search nginx 2.如果成功则执行下列命令安装Nginx。 sudo yum install -y nginx 3、设置开机自启 输入nginx -t 命令，如果反回 successful表示配置文件无错误，否则说明配置文件有错误。
nginx -t -c /etc/nginx/nginx.conf 开机自启命令
systemctl enable nginx 只有返回类似，提示才能够确定设置成功
Created symlink from /etc/systemd/system/multi-user.target.wants/nginx.service to /etc/systemd/system/nginx.service 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f17523de9e26bbbaaef9485d77a5b88/" rel="bookmark">
			【创作者】创作者   工作中的压力管理——养成健康的工作习惯
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		近年来，随着互联网、科技和经济的快速发展，工作压力逐渐成为一个常见的问题。工作中的高强度和高负荷常常会给我们带来焦虑、紧张、疲劳等不良情绪和身体反应。如何正确看待并应对工作压力？如何养成健康的工作习惯？下面，我将就这些问题进行讨论和分析。
一、认识工作压力
工作压力是指在工作中受到的各种要求、期望、责任和限制所产生的心理、生理和行为反应。正常的工作压力有助于激发个体的成长和发展，但过度或长时间的压力则易导致身心不适、工作效率下降、健康问题等。因此，正确认识和管理工作压力非常重要。
二、有效应对工作压力
1. 保持平衡的心态
要想有效应对工作压力，首先需要保持平衡的心态。帮助自己放松身心，调整情绪。可以通过运动、听音乐、看电影等方式放松身心，让自己变得更加平静和放松。同时，适当调整自己的工作和生活方式，建立健康的心理和生活习惯。
2. 加强时间管理
时间管理是有效应对工作压力的关键。要制定合理的工作计划和时间表，并优先处理重要事项。不要过分追求完美，而是根据实际情况进行灵活调整。同时，也要学会拒绝一些不必要的事情和任务，以保证自己的时间和精力。
3. 学会沟通和合作
在工作中，与同事和上级的沟通和合作是十分重要的。可以通过积极的沟通和协作来减轻工作压力。与同事分享自己的经验、感受和困惑，在交流中探寻解决问题的方法和建立信任感。
三、养成健康的工作习惯
另外，为了长期防范和管理工作压力，还需养成健康的工作习惯。
1. 合理安排工作和休息时间
保持良好的工作和生活节奏非常重要。需要学会在工作与休息之间进行平衡，比如每隔一段时间就休息一下，适当参加一些有趣的活动和社交。同时，深度睡眠也十分重要，应确保每晚充足的睡眠时间。
2. 注意饮食和体育锻炼
饮食和体育锻炼对于身体和心理健康至关重要。要多吃蔬菜水果、适量摄入蛋白质和碳水化合物，避免过度饮酒和吸烟。体育锻炼可以让身体得到锻炼、血液循环加速，从而减轻身体压力、增强体质和提高抵抗力。
四、结语
压力是现代人面临的一个普遍问题。如何正确认识和应对工作压力、养成健康的工作习惯，是每个人都需要思考和探索的问题。希望通过本文的讨论和分析，能够帮助读者更好地认识和管理工作压力，享受健康和愉悦的工作和生活。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4826716d04b55315da739c0eb7764257/" rel="bookmark">
			当用的RestTemplate去调用api时，解决报错java.security.cert.CertificateException: No name matching
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果想忽略主机名验证，你可以使用一些第三方库来实现，比如Apache HttpClient或者OkHttp。这些库通常提供了一些方法或者参数来关闭主机名验证。或者，你也可以自己编写一个自定义的主机名验证器，让它总是返回true，然后设置给RestTemplate。请参考以下代码⁴：
```java
// create a custom hostname verifier that always returns true
HostnameVerifier hostnameVerifier = new HostnameVerifier() {
@Override
public boolean verify(String hostname, SSLSession session) {
return true;
}
};
// create a custom SSL socket factory that trusts all certificates
TrustManager[] trustAllCerts = new TrustManager[] {
new X509TrustManager() {
@Override
public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {
}
@Override
public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4826716d04b55315da739c0eb7764257/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aeee5348674c35554ca979c7d740e77d/" rel="bookmark">
			SQL连接的理解和使用（内连接：自然连接&amp;等值连接，外连接：左连接&amp;右连接&amp;全外连接）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、连接的介绍连接是什么？连接分几种？条件连接等值连接自然连接 二、连接的使用内连接 INNER JOIN内连接与等值连接区别内连接与自然连接区别 外连接 OUTER JOIN左连接 LEFT JOIN右连接 RIGHT JOIN全外连接 FULL JOIN外连接规则 一、连接的介绍 连接是什么？ 连接（Join）是指将两个或多个表中的数据按照一定的条件关联起来，形成一个新的虚拟表。也可以理解为两个表的笛卡尔积中筛选符合条件的行。
什么是笛卡尔积？
图中名词解析：
元素：集合中{d1,d2}，每一个值称为一个元素，如：d1是一个元素；在表中表示每一行；
元组：一个元素就是一个元组，所以集合{d1,d2}中有2个元组，一个元组在数据表中指的是一行数据；
分量：一个元组里的每一个值，如：元组d1的数据是[张三,24,湖北]，那么张三就是一个分量；
域：每一列数据称为一个域，如：元组d1的数据是[张三,24,湖北]，元组d2的数据是[李三,25,湖南]，那么 张三,李三 就是一个域；
连接分几种？ 三种类型：条件连接、等值连接、自然连接
条件连接 条件连接又称为θ连接
定义：多个表的笛卡尔积中选取满足条件的行的连接（定义和连接定义一样，连接不分家）
举例：select * from R,S where R.A &lt; S.B 有条件的查询
1.现将R和S的笛卡尔积列出（R x S 中的x是笛卡尔积的集合运算符）
2.筛选出符合R.A &lt; S.B的条件的行，除去圈出的部分其余都是符合R.A &lt; S.B条件，即生成一张新的虚拟表（⋈表示连接运算符）
等值连接 等值连接又称为逗号连接
定义：特殊的条件连接，当条件连接的条件为“=”时，称为等值连接
举例：
select * from R,S where R.A = S.A 如图中圈出的两行则是SQL查询出来的数据
自然连接 定义：特殊的等值连接，要求多个表有相同的属性字段，条件为相同的属性字段值相等，且再将表中重复的属性字段去掉，称为自然连接。
举例：
-- natural join：自然连接，不允许带on/using select * from R natural join S --上语句等价于下语句 select R.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aeee5348674c35554ca979c7d740e77d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2f2da98a348d422737bd5b5c5465665/" rel="bookmark">
			使用Spingboot的RestTemplate发送GET请求，并附带参数，返回结果保存为csv
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果你想把返回的结果输出到本地csv文件里，你可以使用java.io包中的类来操作文件，比如FileWriter，BufferedWriter，PrintWriter等。你可以把返回的结果转换成逗号分隔的字符串，然后写入到文件中。请参考以下代码³：
```java
// request url
String url = "https://example.com/api?name={name}&amp;age={age}";
// create an instance of RestTemplate
RestTemplate restTemplate = new RestTemplate();
// create a map for url parameters
Map&lt;String, String&gt; params = new HashMap&lt;&gt;();
params.put("name", "张三");
params.put("age", "25");
// make an HTTP GET request with parameters
String result = restTemplate.getForObject(url, String.class, params);
// print result
System.out.println(result);
// create a csv file
File csvFile = new File("result.csv");
// create a writer
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e2f2da98a348d422737bd5b5c5465665/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1df603a3c7a5f4183591f89e78f58eb/" rel="bookmark">
			MyBatis-Flex、MyBatis-Plus与Fluent-Mybatis三者的比较
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Mybatis-Flex 是什么 Mybatis-Flex 是一个优雅的 Mybatis 增强框架，它非常轻量、同时拥有极高的性能与灵活性。我们可以轻松的使用 Mybaits-Flex 链接任何数据库，其内置的 QueryWrapper^亮点 帮助我们极大的减少了 SQL 编写的工作的同时，减少出错的可能性。
总而言之，Mybatis-Flex 能够极大地提高我们的开发效率和开发体验，让我们有更多的时间专注于自己的事情。
特征 1、轻量：除了 MyBatis，没有任何第三方依赖轻依赖、没有任何拦截器，其原理是通过 SqlProvider 的方式实现的轻实现。同时，在执行的过程中，没有任何的 Sql 解析（Parse）轻运行。 这带来了几个好处：1、极高的性能；2、极易对代码进行跟踪和调试； 3、把控性更高。
2、灵活：支持 Entity 的增删改查、以及分页查询的同时，Mybatis-Flex 提供了 Db + Row^灵活 工具，可以无需实体类对数据库进行增删改查以及分页查询。 与此同时，Mybatis-Flex 内置的 QueryWrapper^灵活 可以轻易的帮助我们实现 多表查询、链接查询、子查询 等等常见的 SQL 场景。
3、强大：支持任意关系型数据库，还可以通过方言持续扩展，同时支持 多（复合）主键、逻辑删除、乐观锁配置、数据脱敏、数据审计、 数据填充 等等功能。
功能对比 MyBatis-Plus：老牌的 MyBatis 增强框架Fluent-Mybatis：阿里开发的 Mybatis 增强框架（是阿里开发的吗？） 功能或特点MyBatis-FlexMyBatis-PlusFluent-Mybatis对 entity 的基本增删改查✅✅✅分页查询✅✅✅分页查询之总量缓存✅❌❌分页查询无 SQL 解析设计（更轻量）✅❌✅多表查询： from 多张表✅❌❌多表查询： left join、inner join 等等✅❌✅单主键配置✅✅✅多种 id 生成策略✅✅✅支持多主键、复合主键✅❌❌字段的 typeHandler 配置✅✅✅除了 Mybatis，无其他第三方依赖（更轻量）✅❌❌逻辑删除✅✅✅乐观锁✅✅✅SQL 审计✅❌❌数据填充✅✅（收费）✅数据脱敏✅✅（收费）❌字段权限✅✅（收费）❌字段加密✅✅（收费）❌字典回显✅✅（收费）❌Db + Row✅❌❌Entity 监听✅❌❌多数据源支持✅✅❌ 对比功能参考地址：与 Mybatis-plus 对比，Mybatis-Flex v1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f1df603a3c7a5f4183591f89e78f58eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2bc213a72c052a8a129665c217f07922/" rel="bookmark">
			JAVA的我选择了在职考研
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面的话 我是专科2019年毕业的，毕业就做了JAVA，直到一年前冒出了考研的想法，其实当时只是对朋友开的一句玩笑话，那时我没有了解过考研，也不懂其中要付出什么，现在想起来真是年少轻狂，想做就去做了
从开始准备到收到录取通知，历时大约一年半，专科生直接考研，从始至终一个人，没有研友，长胖10斤，最终考上，我的心境从早期的迷茫、焦虑，中期的咬牙坚持、自我鼓励，到考上后的轻松和成就感
现在落笔成文可能显得轻松和平淡，我写完了12支笔，看了10本书，刷了80套试卷，努力了一年，才写下这篇文章，回首一年前，如梦一场，没想过自己专科也有这份可能
准备初试 每天赶上早晨8.26分的地铁8号线，到公司前能背大约35分钟单词，有时候还能遇到一些同事，经常看到我拿本书低头走路，忙碌一天的工作后8点多下班，回去的地铁路上再背背单词，真的很累。
回到家休息20分钟学习其他课，所以我晚上饮食及其不规律，有时候不吃晚饭，这里不得不感谢我的女朋友偶尔让我一回家就吃到晚饭。
不知不觉考试就要来了，但新冠疫情放开比它来的更早，在我考试的前一周，不出意外的阳了，跟大家一样高烧不断，咳嗽、喉咙像刀割一样，最厉害的时候咳出血了，没敢告诉父母，因为还有一周就初试了，怕他们为我担心。
12月23日去到考场附近的酒店，碰到了葬礼，心里有点紧，开头就这么恐怖，确实有点吓到我了
图片
到了酒店后就去熟悉了考场，然后晚上就狂背肖四，心里有点紧张，晚上一晚上也没睡着，早上六点半起床，然后吃饭，搞完一直在教学楼外面排队，排队虽然在看肖四，但其实看不进，没啥效果，然后进去的时候一直在教室外面看肖四，大概看到8：20才进去。
考完就回到了酒店吃完饭7点多就睡了，怕自己睡过头，给自己设定5:00的闹钟起来复习，最后一天考试了，早点去考场，买了一瓶牛奶和面包边吃边走，还下着小雨，有点冷
考完后感觉身上都释怀了，不知道该说什么，心里很空，呆呆地启程回家
初试考完后的第一个晚上我哭了，哭了很久，眼泪止不住，也许是憋了很久情绪上需要释放，也许是认识了另一个自己。
“新冠”这个词困扰了大家整整三年，但也困扰了“我们”，那时候刚好放开，有人说23考研不仅拼头脑还要拼身体，是特种兵的选拔。
我所在的考场只来了11个人（一个教室总共30个人），听到的最多的就是咳嗽声，无论是阴性考场还是阳性考场，考试3个小时，从未间断过，跟我一个考场的考生带着药来考试，清楚的记得第二列的倒数第三个女生顶着退烧贴奋笔疾书，心里不由着燃起敬佩之意
准备复试 初试后休息了几天由于咳嗽的太厉害，已经半个月了，怕咳出肺炎，下了班就去挂急诊，没想到很多人也都是咳嗽，不得不说新冠太厉害
初试考的再高，复试没过也是一票否决，所以初试过了也要继续认真复习，准备三门专业课的笔试，英语交流，综合面试，我承认字写的有点丑了
当分数线出来的时候，查了成绩成功进入复试，开心，但是越来越焦虑，精神压力比初试的时候还大，因为复试被刷的比比皆是。
第一天是三门专业课的笔试，从早上9:00考到了晚上9:00，不得不说数据结构和算法考的有点难，还是手写
第二天参加面试，我认识了很多跟我一组的人，比如在我后面一个的阿娇(化名)，在我前面的一个叫红梅(化名)，她给我的印象尤为深刻，坐在我旁边等待复试一直跟我说紧张紧张，聊的过程中得知她已经是快要当妈的人了，我很惊讶，心想她究竟是为了什么？对她竖起了大拇指。我们在走廊上来来回回地走，以缓解紧张的情绪
徘徊的时候，收到了来自陌生人面带笑容的加油，真挚的眼神让我心里有了一丝温暖，现在回想起来，没有加个联系方式很遗憾。
轮到我面试的时候，即使做了准备，但进去后发现是10个左右的老师面试我，确实受宠若惊了，我在网上了解到的都是5个老师，开始英语自我介绍、英语交流，抽题、然后每个老师轮番伺候我，不得不说老师们确实是有真本事的，问题可以从大到小，由浅入深，只要你还能答，一直深问，招架不住，有点慌了，过了没多久就面试结束了，我心总算松了一下了；
回家后感觉很累直接睡了一觉，醒来时已经是下午4点了，这时候心里空落落的，给橙子（他是我在复试时认识的，人很真诚，带个眼镜，一毕业就进入了政府单位工作，我问他为什么要考研，他说他周围都是研究生，让我无言以对）发了一条QQ，说现在考完了，我心里空落落的，他说他也是，给我发来了巴朗山的风景，告诉我考完了，放松下
结果 对于23考研人来说一定是一个难忘的一年
“2023考研录取率仅为16%。数据统计,2023年全国864个招生单位总计招考761763人,而报考人数为474万人。也就是说在录取率不到20%的情况下,会有接近400万的考生落榜,最终能上岸的只有一个零头。”
出成绩后惊讶的发现我从初试排名17通过复试到了第9名，复试成绩第二名，当初给自己的预期是能过就行了，因为我是专科所以还需要等待加试成绩，只要有一门加试科目低于60分的直接淘汰，成绩出来后只有我一个人过了
我在复试时认识的一个叫年的家伙，我从他身上看到了很多学生的地方（真诚、眼神里充满希望），出成绩时，我和他的对话：
祝他调剂顺利吧
收获 无论结果好与坏，对我来说并不仅仅是为了一个研究生的学历了（在当前这么卷的情况下），这段经历给了我很多，感谢自己一年前荒唐的想法，照进了现实,未来的路还很长，继续前进
特别感谢：lzf学长，也是我大学的室友，感谢这一路上的答疑与鼓励。
感谢我的女朋友阿秋，感谢一路上的陪伴鼓励与安慰，给我加油打气，别人家的男朋友都是带女朋友到处旅游的，只有我每天宅在家，你的存在也是我考研路上的很大动力。
如果你觉得写得好就动动手指点个赞并分享一下，如果有人的经历和我相似，正好你有什么问题的话，欢迎聊天，希望认识更多的朋友。
我的公众号【人人架构师】，专注分享JAVA架构，高并发，领域驱动，面试，海量数据，微服务，框架源码等硬核技术
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d0fd6bd0a4926cea9d66aee9203d73f/" rel="bookmark">
			uniapp 小程序端使用uni-popup组件时，页面用了scroll-view滚动组件，uni-popup组件也使用了scroll-view滚动出现组件滚动导致页面也滚动的解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 uni-popup上给一个禁止滚动 @touchmove.stop.prevent="" 和一个样式height: 100vh;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f956d5657eb82d469078dd55ef39729/" rel="bookmark">
			Linux shell 阿里云IPV6 DNS解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux shell 阿里云IPV6 DNS解析 记录一下本地服务器自动更新IPV6 DNS解析的过程
需求 由于移动不提供动态公网IPV4（联通，电信有动态公网IP），需要在外访问家中的网络设备。
只要有IPV6网络，就可以访问家中的设备，无需购买有公网IP的服务器，可以做域名解析，速度还是很快的，跟局域网访问差不多，速度差别根据你的带宽而定，主要有以下用途：。
搭建IPV6网站Webdav文件服务远程SMB服务远程RDP桌面连接远程管理家中智能设备只要能用IPV6地址的地方 本教程以OPENWRT为例 // 安装必要依赖 opkg update opkg install openssl-util bash curl jq 配置阿里DNS的登录ID和秘钥并设置你需要自动更新的域名，记录，解析类型 # ----------------------------------------------------------------------------- api_domain='alidns.aliyuncs.com' # https://ram.console.aliyun.com/manage/ak ak_id="yourid" ak_secret="yoursecret" # Fixed, only one signature_method='HMAC-SHA1' # Alidns Domain properties # ----------------------------------------------------------------------------- domain="yourdomain" records=('yourrecord') records_type="AAAA" 获取本机IPV6地址,RE正则匹配 语法 ipconfig [interface] | egrep -o [re] | head -n 1
移动IPV6 2409开头
电信IPV6 240e开头
联通IPV6 2408开头
get_public_ip() { public_ip= ifconfig pppoe-wan | egrep -o "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f956d5657eb82d469078dd55ef39729/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1606ee1cc59334f80ed88b8d9984195/" rel="bookmark">
			解决kali换源出错: 无法下载 暂时不能解析域名；E:仓库没有数字签名；N: 无法安全地用该源进行更新，所以默认禁用该源。W: GPG 错误：http://mirrors.ustc.e
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		给kali换中科大源，一直各种问题，如图。
┌──(root💀kali)-[~] └─# apt update 1 ⚙ 获取:1 http://mirrors.ustc.edu.cn/kali kali-rolling InRelease [41.2 kB] 错误:1 http://mirrors.ustc.edu.cn/kali kali-rolling InRelease 下列签名无效： EXPKEYSIG ED444FF07D8D0BF6 Kali Linux Repository &lt;devel@kali.org&gt; 正在读取软件包列表... 完成 W: GPG 错误：http://mirrors.ustc.edu.cn/kali kali-rolling InRelease: 下列签名无效： EXPKEYSIG ED444FF07D8D0BF6 Kali Linux Repository &lt;devel@kali.org&gt; E: 仓库 “http://mirrors.ustc.edu.cn/kali kali-rolling InRelease” 没有数字签名。 N: 无法安全地用该源进行更新，所以默认禁用该源。 N: 参见 apt-secure(8) 手册以了解仓库创建和用户配置方面的细节。 └─# apt update 1 ⚙ 忽略:1 http://mirrors.ustc.edu.cn/kali kali-rolling InRelease 忽略:1 http://mirrors.ustc.edu.cn/kali kali-rolling InRelease 忽略:1 http://mirrors.ustc.edu.cn/kali kali-rolling InRelease 错误:1 http://mirrors.ustc.edu.cn/kali kali-rolling InRelease 暂时不能解析域名“mirrors.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e1606ee1cc59334f80ed88b8d9984195/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4140b3995718fc7e0e3df964a5792b29/" rel="bookmark">
			vue项目通过jenkins部署到K8s
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说明 本文主要介绍基于jenkins完成前端vue项目自动化ci的过程，开发人员可以使用此流水线自动部署服务。用户提交代码到gitlab，触发jenkins拉取gitllab上的代码，然后编译构建后，通过k8s部署起来。此处使用的jenkins是使用docker部署起来的，并没有使用K8s部署，服务使用k8s相当于集成了外部的k8s去部署服务。
环境准备 环境准备部署可以参考我的另一篇文章：https://blog.csdn.net/weixin_37069728/article/details/125975192
使用idea创建vue项目 参考链接: https://blog.csdn.net/qq_29247945/article/details/95601148
在gitlab上创建项目并把创建好的项目上传到gitlab上 已经公开到gitee上，地址：https://gitee.com/jsonsvn/vue-demo.git
配置文件准备 Dockerfile文件（放到项目根目录下） FROM nginx RUN mkdir /usr/share/nginx/dist \ &amp;&amp; rm -rf /etc/nginx/nginx.conf \ &amp;&amp; /bin/cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime \ &amp;&amp; echo 'Asia/Shanghai' &gt;/etc/timezone COPY ./nginx/nginx.conf /etc/nginx/nginx.conf COPY ./dist/ /usr/share/nginx/dist EXPOSE 8080 deploy.yaml文件 在项目根目录下创建k8s目录，将该文件放到k8s目录下
apiVersion: apps/v1 kind: Deployment metadata: name: vue-demo-deployment namespace: dev spec: replicas: 2 selector: matchLabels: app: vue-demo-pod template: metadata: labels: app: vue-demo-pod spec: containers: - name: vue-demo image: 192.168.59.129:8888/hello/vue-demo:latest ports: - containerPort: 8080 imagePullSecrets: - name: docker-login --- apiVersion: v1 kind: Service metadata: name: vue-demo-service namespace: dev spec: selector: app: vue-demo-pod type: NodePort ports: - port: 30011 targetPort: 8080 集成jenkins 创建流水线项目 在项目根目录下创建Jenkinsfile文件 并先编写本项目需要的jenkinsfile的模板
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4140b3995718fc7e0e3df964a5792b29/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3258f4cbab06ba809eb8f0a26bd98cb5/" rel="bookmark">
			安装最新版Calico
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		准备calico.yaml 进入calico网站：
Install Calico networking and network policy for on-premises deployments
找到 Install Calico &gt; Kubernetes &gt; Self-managed on-premises &gt; Install Calico networking and network policy for on-premises deployments
往下滑动页面，找到Install Calico步骤下的Manifest &gt; Install Calico with etcd datastore：
点击Install Calico with etcd datastore然后跳转:
如下找到Calico.yaml的下载连接，在k8s环境执行：
这个是比较新的版本v3.25.1的 calico：
curl https://raw.githubusercontent.com/projectcalico/calico/v3.25.1/manifests/calico-etcd.yaml -o calico.yaml 也可以根据自己的需要，在calico网站找到以前的版本下载。
下载好calico.yaml.
编辑calico.yaml里的Secret段，data下定义的证书base64加密数据 etcd-ca: etcd-key:etcd-cert: ====================================
这3个分别是： etcd的ca证书数据etcd的证书key数据etcd的证书数据 把这三个证书数据经过base64 方式加密，然后把加密后的数据粘贴到yaml中，但是注意负值加密后的数据不要把shell的提示符复制进去：
如：cat /opt/etcd/certs/ca.pem | base64 | tr -d '\n'
修改好后内容如下：
编辑etcd_endpoints: 我的k8s集群3个节点的etcd 的url分别是如下，编辑加到etcd_endpoints：后面
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3258f4cbab06ba809eb8f0a26bd98cb5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fcc10684c74fcb4d994d0ef4344587e2/" rel="bookmark">
			#include ＜math.h＞中sin，cos函数的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用QT的时候遇到绘制类似仪表盘的问题，要定位仪表盘上刻度的坐标然后进行刻度线的绘制，需要把仪表盘角度等分，然后通过角度正余弦函数sin,cos函数获得刻度线的坐标。
math.h中的sin和cos等函数的入参原型如下：
double sin(double _X); double cos(double _X); 解释一下：
这两个函数的入参类型都是double, 而入参_X是角度的弧度值，返回的是弧度值对应的角度的正余弦的值；
那么，什么是弧度值呢？ (初中知识，在这里温习下）：
某个角度的弧度值，其实就是 角度值*(π/180°），我们用通俗易懂的方式来解释一下：
π/180° 其实就是单位角度的弧度值，也就是角度为1°时对应的弧度值，那么我们知道了1°对应的弧度值，要求得出给定角度的弧度值就很好计算了。
计算给定角度对应的弧度值 比如我把一个圆360°分为10份，那么每份就是36°，从而得到36°对应的弧度值就是：
36° * (π/180°）
可以写成 π * （36°/180°）= π * （1/5）
因为分子分母都是度数单位，约得36°的占据180°的分数就是 1/5 ,然后和π相乘，得从而得到36°对应的弧度就是：π/5；
从而如果计算36°对应的正弦值就是: sin(π/5)
因为π在math.h中的定义是M_PI,如下：
所以36°的正弦值的函数调用写成：
sin(M_PI/5)
余弦也同理，36°对应的余弦就是cos(M_PI/5)
通过正余弦值得到刻度坐标 我们得到了角度对应的正余弦值之后，就可以联合圆的半径长度获得某个角度在圆上的坐标，如下：
因sin值又是直角三角形中角的对边和直角三角形斜边的比值，所以在坐标系中，r为半径的圆上，
某个弧度为n的角度在圆上的坐标(△x,△y) ，有 △x/r = cos(n) 以及 △y/r = sin(n)
所以某个角度的 x轴距离△x=cos(n)* r , y轴距离△y= sin(n)* r:
那么如果把一个半径为r长度的圆10等分，36°对应的坐标(x,y) =&gt; （cos(M_PI/5)*r, sin(M_PI/5)*r)
36° * 2 = 72°对应的坐标为：( cos(2*M_PI/5), sin(2*M_PI/5) )
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fcc10684c74fcb4d994d0ef4344587e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3293c1eb12acd0947b30683645b8e01/" rel="bookmark">
			QString字符串如何移除最后一位
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当我们基于Qt开发项目时，经常会用到QString这个类按照某种格式对字符串进行拼接，拼接完后有时候最后一位是多余的，就需要把最后一位给移除。
以下是不同实现方法：
方法一：
使用QString的left()函数，left()的作用是获取字符串左边n个字符。获取总个数减一个字符就相当于去除了最后一个字符。例：
QString str("hello world,"); QString strTmp = str.left(str.size()-1); qDebug().noquote() &lt;&lt; "strTmp:" &lt;&lt; strTmp; 如果字符串是汉字，则删除最后一个完整的汉字。
方法二：
使用QString的chop()函数，chop()的作用就是删除字符串右边n个字符。例：
QString str("hello world,"); QString strTmp = str.chop(1); qDebug().noquote() &lt;&lt; "strTmp:" &lt;&lt; strTmp; 调用chop()，会对字符串本身进行删除。
方法三：
使用QString的remove()函数，remove()有好多重载函数，其中一个是移除某下标开始n个字符。例：
QString str("hello world,"); QString strTmp = str.remove(str.size()-1, 1); qDebug().noquote() &lt;&lt; "strTmp:" &lt;&lt; strTmp; 从最后一个下标位置开始移除一个字符也能达到目标。remove虽然有返回值，但str自身也发生了改变。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbed0f58fbf15a4b57152d64b9644a73/" rel="bookmark">
			图BFS/DFS的探索与处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解剖B F S/D F S ：
BFS:
探索即将连接且未探索的加入队列
处理有许多种处理
过程：用一个点寻找和他连接的点。在计算机中用队列实现。
用BFS 分为 探索与处理过程
探索过程：放入连接的节点
处理： 你需要进行的操作
有时候探索与处理放在一起。满足未探索条件即可
代码体现：图:题目详情 - 7-10 列出连通集 (pintia.cn)
7-10 列出连通集
分数 25
全屏浏览题目切换布局
作者 陈越
单位 浙江大学
给定一个有N个顶点和E条边的无向图，请用DFS和BFS分别列出其所有的连通集。假设顶点从0到N−1编号。进行搜索时，假设我们总是从编号最小的顶点出发，按编号递增的顺序访问邻接点。
输入格式: 输入第1行给出2个整数N(0&lt;N≤10)和E，分别是图的顶点数和边数。随后E行，每行给出一条边的两个端点。每行中的数字之间用1空格分隔。
输出格式: 按照"{ v1 v2 … v**k }"的格式，每行输出一个连通集。先输出DFS的结果，再输出BFS的结果。
输入样例: 8 6 0 7 0 1 2 0 4 1 2 4 3 5 输出样例: { 0 1 4 2 7 } { 3 5 } { 6 } { 0 1 2 7 4 } { 3 5 } { 6 } 题解 裸题 求 连通情况 有边输出即可
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fbed0f58fbf15a4b57152d64b9644a73/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c709132b8bad9b40e451c1a22d43fc1b/" rel="bookmark">
			7 款 Vue 3 富文本编辑器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		富文本编辑器作为直接与用户交互的内容输入生产工具，对大家的项目来说非常重要。选不好，配置不好，直接影响产品质感和用户体验，所以说在选择编辑器方面花点时间是值得的。
我试用了市面上所有主流富文本编辑器，筛掉长期不更新，bug 明显，社区活跃度低，功能单一的编辑器，把最好、最有特点的 7 款编辑器挑出来，分享给大家。这些编辑器各有各的特点，有些功能多样，但整体很重，有些功能虽然少，但某一项功能优化的特别好。希望我的测评可以帮助你选到合适你需求的编辑器。 本文测评的 7 款 Vue 富文本编辑器 TinyMCE - 富文本编辑器里的 Word ，功能想不到的丰富tiptap - 多人在线实时协同编辑CKEditor 5 - 开源免费可商用，行内编辑Quill - 易扩展、轻量级二开、代码高亮好用Froala - 插件丰富，UI友好，编辑器里的苹果summernote - 恰到好处的轻，可直接粘贴图片Trumbowyg - 超轻量，体积小巧，仅 8KB 一. TinyMCE - 富文本编辑器里的 Word ，功能想不到的丰富 TinyMCE是富文本编辑器领域的头部玩家之一，主流富文本编辑器，功能非常全，你需要的大多数功能它都支持。排出复杂又美观文章样式，代码高亮等都是基础功能。它甚至有点像在线版的Word，可以在顶部的各种菜单中找到你要的功能。但它的优势也恰恰是它的劣势，如此之多的功能都放上来导致整个编辑器非常重，如果只是需要简单功能，上这么复杂的编辑器，大材小用。
TinyMCE 对 Vue.js 的集成和安装非常友好，支持 Vue3 和 TypeScript，文档写的也非常好。
二. tiptap - 多人在线实时协同编辑 tiptap 最初是为 Vue2 开发的，现在已发展成为独立框架工具，对 Vue3、React、Svelte 集成友好。 它基于 Prosemirror 进行扩展开发，是一款无头(headerless)富文本编辑器，默认情况下，它没有任何 UI样式，你完全可以自己来配置想要的 UI，不需要重写 class，也不需要 important 代码。
tiptap功能非常强大，功能插件丰富。但它比其他编辑器更棒的地方在于多人在线实时编辑。类似于谷歌文档那种效果，所有使用者在同一个页面彼此能看到对方的光标位置和名字，大家同时在线协同编辑。整个协同体验流畅，如果你的应用场景需要多人实时协同编辑，选 tiptap 就对了。
三. CKEditor 5 - 开源免费可商用，行内编辑 CKEditor 5 是基于 Vue 的富文本编辑器组件，开源，可免费用于商业用途，官方下载量已经过千万。CKEditor 是编辑器前辈FCkEditor 的基础上开发的全新版本。它的 UI设计现代，支持行内编辑模式。免费付费功能分布合理，付费主要是小部件、实时协同和历史记录。CKEditor 5有详细的文档，从入门到自定义编辑器，再到如何与不同框架集成，写的非常详细。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c709132b8bad9b40e451c1a22d43fc1b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/edf627e6fc153055f223a105ce6a534b/" rel="bookmark">
			Python 入门指南：从初学者到专家
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python 是一种高级编程语言，因其简单易学、易读且具有广泛的应用而备受欢迎。随着大数据、人工智能等领域的快速发展，Python 的需求越来越高。若您想成为一名 Python 开发者，可通过以下入门指南从初学者到专家。
1. 安装 Python
首先，需要在本地计算机上安装 Python 程序。可以访问Python官网（python.org）下载适合自己的操作系统版本并进行安装。
2. 掌握基础语法
Python 语法相对于其他编程语言来说比较简单，但仍需掌握必要的基础语法。如：注释、变量、常量、数据类型、条件语句、循环语句、函数等。
3. 学习常用库和框架
Python 的强大之处在于其拥有大量的库和框架，这些库和框架可帮助开发者更快、更高效、更容易地编写代码。如：NumPy、Pandas、Matplotlib、Django 等。
4. 学习面向对象编程
面向对象编程是 Python 的一个核心概念，掌握它可帮助开发者更好地组织代码并使其更易于维护。需要了解类、对象、封装、继承、多态等相关的概念。
5. 学习数据分析和机器学习
Python 在数据分析和机器学习领域有广泛应用，因为它拥有一系列专门用于处理和分析数据的库和框架。如：NumPy、Pandas、Scikit-learn 等。
在学习过程中，可以通过在线教程、实战课程、书籍等途径来深入了解 Python。此外，也可以参加线下社区活动、讨论小组等，与其他 Python 开发者一起交流学习心得。
总结：
Python 是一种灵活简单、易学易用的编程语言。通过掌握基础语法、重要库和框架、面向对象编程、数据分析和机器学习，你能够成为一名 Python 专家。除了以上学习方法，积极参加学习活动和与他人交流也是快速提升技能的关键。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6099593e9ef7f528cc8b4750902d485d/" rel="bookmark">
			【Tensorflow安装】通过Anaconda3安装Tensorflow 1.15.0 记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、安装Anaconda3
1.1 通过Anaconda官网即可安装。
1.2 查看conda版本
二、创建TensorFlow环境
三、安装TensorFlow
3.1 安装GPU版本
3.2 安装CPU版本
四、测试安装结果
4.1 简单测试
4.2 测试代码
一、安装Anaconda3 1.1 通过Anaconda官网即可安装。 1.2 查看conda版本 打开Anaconda Prompt，输入代码：
conda --version 同样查看Python版本：
python --version 二、创建TensorFlow环境 2.1 创建环境 在Anaconda Prompt中输入
conda create -n tensorflow_env python=3.7 TensorFlow版本要与Python的版本对应，如果后续安装TensorFlow时出错，提示Python版本低于TensorFlow安装的版本，则可通过这步重新创建更高版本的环境。
两者版本对应见：TensorFlow的历史版本与对应Python版本
2.2 检查环境安装 创建成功后，输入以下命令查看conda environments：
conda env list 说明环境创建成功（*为当前所处环境）。
# 进入环境 activate tensorflow_env # 退出环境 deactivate conda安装在D盘，可通过以下代码修改路径
cd c:\ d: # 根据自己的路径修改 cd downloads\apps\Anaconda3 三、安装TensorFlow 根据电脑显卡配置选择安装CPU版本或GPU版本，两者区别是GPU运行更快，但GPU需要提前下载cuda和cudnn，而CPU版本无需额外下载。
参考tensorflow详细安装教程（Win10, Anaconda，Python3.9）
3.1 安装GPU版本 参考使用anaconda 3安装tensorflow 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6099593e9ef7f528cc8b4750902d485d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3cea1769c306ac85d325c88a374ef1e7/" rel="bookmark">
			2023最新华为OD机考题库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 2023最新OD机考题库 基础题 100 分进阶题 200 分 基础题 100 分 编号题目时间1字符串重新排列22Q42租车骑绿岛22Q43无向图染色22Q44单向链表中间节点22Q45不包含101的数22Q46最多颜色的车辆22Q47完美走位22Q48真正的密码22Q49积木最远距离22Q410打印机队列22Q411日志首次上报最多积分22Q412二元组个数22Q413计算中心数组位置22Q414最长的密码22Q415最大利润22Q416端口合并22Q417最左侧冗余覆盖字串22Q418星际篮球争霸赛22Q419最多获得短信条数22Q420最短目标长度22Q421优选核酸监测点22Q422挑选字符串22Q423数组合并22Q424箱子之字形摆放22Q425对称美学22Q426快递业务站22Q427密室逃生游戏22Q428匿名信22Q429任务调度22Q430寻找路径22Q431新学校选址22Q432机器人22Q433整理扑克牌22Q434货币单位换算22Q435查找但入口空闲区域22Q436预定酒店22Q437简单的自动曝光22Q438获取最大软件版本号22Q439最大报酬22Q440通信误码22Q441开心消消乐22Q442投篮大赛22Q443开放日活动22Q444相同数字的积木游戏22Q445表格单元格数值铜级22Q446硬件产品销售方案22Q447异常打卡记录22Q448字符串解密22Q449任务中执行时长22Q450单词倒序22Q451找出重复代码22Q452数字加减游戏22Q453猜字谜22Q454农场施肥23Q155快速开租建站23Q156统计友好度最大值23Q157区块链文件转储系统23Q158新词挖掘23Q159查找充电设备组合23Q160上班之路23Q161机房布局23Q162静态扫描23Q163快递投放问题23Q164人数最多的站点23Q165寻找相似单词23Q166严格递增字符串23Q167微服务的集成测试23Q168组合出合法最小数23Q169最小调整顺序次数23Q170模拟商场优惠打折23Q171信号发射与接收23Q172Linux发行版的数量23Q173模拟商场打折223Q174日志限流23Q175最优芯片资源占用23Q176工单调度策略23Q177统一限载最小值23Q178几何平均值最大子数组23Q179最长回文字串23Q180检测热点字符23Q181数组限制数23Q182银行插队23Q183天然货舱23Q184幻方修复23Q185新员工考试23Q1 进阶题 200 分 编号题目时间1题目名称时间2最大化控制资源成本22Q43等和子数组最小和22Q44过滤组合字符串22Q45羊、狼、农夫过河22Q46探索地块建设22Q47最大评分数组22Q48区间交叠问题22Q49连接器问题22Q410分奖金22Q411计算快递业务主站点22Q412去除多余空格22Q413最差产品奖22Q414最多等和不相交连续子序列22Q415基站维护最短距离22Q416二进制差异数22Q417士兵过河22Q418查找二叉树节点22Q419计算网络信号22Q420核酸最快检测效率22Q421删除重复数字后的最大数字22Q422找等值元素22Q423水库蓄水问题22Q424优雅子数组22Q425组装新的数组23Q126荒地建设电站23Q127简单的压缩算法23Q128最优高铁城市修建方案23Q129垃圾短信识别23Q130优秀学员统计23Q131处理器问题23Q132九宫格游戏23Q133服务中心选址23Q134实力差距最小总和23Q135最多组合直角三角形个数23Q136构建二叉树23Q137大炮攻城23Q138称砝码22Q4 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7c553a8cd0c784d0c5f07e337e27a19/" rel="bookmark">
			Chrome扩展程序导出备份与本地导入浏览器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现在即使在国内下载个chrome，转个插件也千难万难。现在科学上网也越来越难，由于众所周知的原因，连qiang这个话题都是敏感词。哀默于心死，还是回避这个话题
只要把之前装的chrome打包，然后再重新安装一遍。操作步骤如下：
Chrome导出扩展程序 对于之前安装过插件，需要备份或者其他Chrome皮的国产浏览器，都可用用此方法打包，然后倒入chrome浏览器安装。
打开chrome打开扩展程序管理界面
查看插件的id，开到相应的插件文件，打包
找到扩展程序目录 找到插件安装位置，路径如下：
C:\Users\zhoulujun\AppData\Local\Google\Chrome\User Data\Default\Extensions
具体操作如图所示
打包扩展程序 load/浏览插件文件(扩展程程序的id文件夹)，个人用，Private key file/私钥文件不用不安，点击 Pack extention/打包扩展程序，
然后在该扩展程序目录下，ctx 即开插件的打包文件。在其他浏览器，拖该ctx文件，到chrome 扩展程序管理界面，即可导入安装
chrome常用插件列表 个人打包从插件列表
AlexaTrafficRank.crx：http://zhoulujun.cn/media/chromePluging/AlexaTrafficRank.crx
AlloyDesigner.crx：http://zhoulujun.cn/media/chromePluging/AlloyDesigner.crx
Axure.crx：http://zhoulujun.cn/media/chromePluging/Axure.crx
editThisCookies.crx：http://zhoulujun.cn/media/chromePluging/editThisCookies.crx
GoogleAnalyticsDebugger2.8_0.crx：http://zhoulujun.cn/media/chromePluging/GoogleAnalyticsDebugger2.8_0.crx
JSONView0.0.32.3_0.crx：http://zhoulujun.cn/media/chromePluging/JSONView0.0.32.3_0.crx
pageSpeed.crx：http://zhoulujun.cn/media/chromePluging/pageSpeed.crx
ProxySwitchyOmega.crx：http://zhoulujun.cn/media/chromePluging/ProxySwitchyOmega.crx
reactDeveloper.crx：http://zhoulujun.cn/media/chromePluging/reactDeveloper.crx
reactDeveloper.pem：http://zhoulujun.cn/media/chromePluging/reactDeveloper.pem
reduxDevelopTools.crx：http://zhoulujun.cn/media/chromePluging/reduxDevelopTools.crx
UrlToQRcode.crx：http://zhoulujun.cn/media/chromePluging/UrlToQRcode.crx
vedioDownload.crx：http://zhoulujun.cn/media/chromePluging/vedioDownload.crx
vueDevelopTools.crx：http://zhoulujun.cn/media/chromePluging/vueDevelopTools.crx
seleniumIde.crx： http://zhoulujun.cn/media/chromePluging/seleniumIde.crx
日常用这些插件有够了
其他一些插件下载，推荐一些还能访问的网站（安全性存疑，最好官网安装）：
Crx4Chrome
https://www.chromefor.com/selenium-ide_v3-16-1/
http://www.cnplugins.com/ 转载本站文章《Chrome扩展程序导出备份与本地导入浏览器》,
请注明出处：Chrome扩展程序导出备份与本地导入浏览器 - webkit - 周陆军的个人网站
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b0a0e4c497071e08b8a6a8771432abb/" rel="bookmark">
			python最好用的第三方库资源下载网址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Windows安装python库，如果你python使用pip安装库文件不成功的话，你可以尝试下面的网址，里面文件太多，你可以ctrl+f来搜索你需要的文件，找到你需要的文件download下来，在本地使用pip安装就行了
下载链接：https://www.lfd.uci.edu/~gohlke/pythonlibs/
另外附 pytorch 历史版本whl下载链接：https://download.pytorch.org/whl/torch_stable.html
本地安装方式说明（对于老手可以忽略这个提示）：
pip install 刚刚下载的包名(小白的话，建议直接使用绝对路径) # 比如：我下载的文件在目录： /tmp/ # 包名是：pandas-2.1.3.whl # 1、那么使用绝对路径就是： pip install /tmp/pandas-2.1.3.whl # 2、相对路径的安装方式是：切换到对应目录，然后直接" pip install 包名 "即可 cd /tmp/ pip install pandas-2.1.3.whl 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/574131ec7a0f19c601f764ff9d77c7b9/" rel="bookmark">
			AD20绘制板框
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.在机械层（keep-out layer）用线条（PL）画出边框
2.选中边框的一条边，按Tab键可以全选刚才绘制的边框，执行快捷键(DSD)
3.也可通过CAD画出板框，导出DXF格式文件，在AD20中执行F-I-DXF/DWG，进行导入
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/176043758a68faaea575a986585b7bf3/" rel="bookmark">
			运算放大器虚短和虚断概念在实际产品电路中的运用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先明白虚短和虚短的概念：
虚短：由于运放的电压放大倍数很大，一般通用型运算放大器的开环电压放大倍数都在80 dB以上。 而运放的输出电压是有限的，一般在 10 V～14 V。因此运放的差模输入电压不足1 mV，两输入端近似等电位，相当于 “短路”。开环电压放大倍数越大，两输入端的电位越接近相等。“虚短”是指在分析运算放大器处于线性状态时，可把两输入端视为等电位，这一特性称为虚假短路，简称虚短。显然不能将两输入端真正短路。虚短得出正负输入端等电位的结论。
虚断：由于运放的差模输入电阻很大，一般通用型运算放大器的输入电阻都在1MΩ以上。因此流入运放输入端的电 流往往不足1uA，远小于输入端外电路的电流。故 通常可把运放的两输入端视为开路，且输入电阻越大，两输入端越接近开路。“虚断”是指在分析 运放处于线性状态时，可以把两输入端视为等效开路，这一特性 称为虚假开路，简称虚断。显然不能将两输入端真正断路。虚断得出电流不流入流出放大器输入端，而外端电流相等的结论。
如下图的电路原理图：
首先根据分压原理在LM358的第3输入脚处的电压为12V，根据虚短的概念LM358两输入端2、3的电压相等，因此LM358的1引脚输出电压为12V；同理根据分压原理可以得到R504处电压大约为13.5v，运用虚短的概念可得LM358第5、6脚等电压，可知6脚处电压也为12v；运用虚断的概念可知流入6脚的电流近似为0，因此流过R506的电流和流过R505的电流也全部流过R507，那么设LM358第7脚上的输出电压U，运用节点电流发，假设流入LM358第6引脚的电流等于0，则有下面的式子：(Vout-12)/R506 + (13.5-12)/R505 +(U-12)/100K=0=&gt;
(Vout-12)/R506 + (13.5-12)/R505 = -(U-12)/100K =&gt;U=24-1.5-Vout
这样就通过LT6106将mbus总线上的电流转为电压，然后经过LM358进行电压偏移，偏移的电压正好进入LM2903的线性放大区（输入到LM2903中的比较电压不靠近电源电压也不靠近地电压）进行比较，这样就可以识别出总线上的数据。同时通过上面的式子可以看出总线负载越大，Vout越大，输出电压U就越接近LM2903比较器的电源电压的中间段，比较效果就越好。
知识拓展：
三极管与放大器：三极管的基本功能是放大，通过这一特性，三极管构成各种电路，体现出了很多工程思想。三极管基本电路就是放大器，例如功放就是一个放大器，输入的声音很小，输出的声音却很大。放大器的输出和输入电压（或电流）之比称为放大倍数，又叫做增益。对于一个电压来说，如果以时间为横轴、电压为纵轴作图，这个图形则为这个电压的波形。如果一个放大倍数为5的放大器，输入恒定的1V电压（波形如下左图），则输出应该始终是5V（波形如下中图），既不会随时间改变，也不会随温度而变化，输出和输入的电压形状完全一样。但如果放大倍数不稳定，不断变化，原先输入的信号就会变形（如下右图），信号可能由一条水平直线变成了一条曲线。这种波形变化叫做失真。
一个理想的放大器，希望其放大倍数是恒定值。如果功放的放大倍数不稳定，声音就会忽大忽小，波形变化还会导致声音发生变化，即失真。现实总是和理想相违背。很不幸，三极管的特性并不理想，它在放大电路中工作时，放大倍数不仅受输入电压、电源电压影响，而且自身发热导致温度变化，也会影响它的放大倍数。这实在是让很多工程师头疼，如果不能找到有效的方法，减少这一特性带来的影响，三极管很难应用到实际中来。于是一些非常厉害的人找到了好方法：负反馈。什么是负反馈呢？
负反馈：负反馈是指将系统的输出又返回到输入端而影响输入，从而对系统整体输出产生作用。反馈可分为正反馈和负反馈。负反馈是使输出起到与输入相反的作用，使系统输出趋于稳定。
负反馈放大器：我们忽略具体电路，只画一个简单的框图，来说明三极管放大电路是如何利用负反馈的。下面三角形表示一个三极管构成的放大器，放大倍数为 A，输入为 I ，则输出 O=A*I ，由于放大倍数A不稳定，所以输出波形会有失真。
在电路中添加了一些器件如下。紫色的圆形是相加器，结合紫色的“+”、“-”符号，表示其输出 Y=(+I)+(-X)=I-X ，在实际电路中用电阻就可以实现；方框F是反馈器件，表示从输出O取出信号，并将其与F相乘，得到 X ，所以 X=0*F ，这里 F＜1 （这个部分在实际电路中可以用电阻实现）；三角形表示的放大器A，主要用三极管构成，满足 O=A*Y ，且A的放大倍数不稳定，很容易受干扰。
可以列出方程组：解得整个电路的放大倍数：
如果设计电路让放大倍数A非常大，同时F不至于很小，则​​ ​​​​​A*F&gt;&gt;1，符号"&gt;&gt;"表示远大于。根据近似的思想，上述整个电路放大倍数：
由于反馈器件可由电阻实现，普通电阻的阻值不容易受外界干扰，因此F的值很稳定，于是整个电路的放大倍数就很稳定。我们成功的通过负反馈解决了三极管的放大倍数稳定性问题。可以看到这里的反馈部分和放大部分构成了一个环形，所以将整个电路的放大倍数称为环路增益，或者闭环增益；而把增加反馈之前，电路的放大倍数A称为开环增益。由于是负反馈，虽然电路增益稳定性提高了，但也有代价：由于AF&gt;&gt;1，于是A&gt;&gt;1/F，即开环增益远大于闭环增益，也就是放大器增益大大降低。但总的来说，为了稳定性，这样做是值得的。
运算放大器：在上面的电路中，为了实际制造出开环增益A很大的放大器，往往要用多级三极管放大电路串联的方式设计。由于这种高增益放大器的需求很常见，于是历史上有人就把它们做成一个成品电路板模块，要用的时候直接当成一个元件用就行了，非常方便。这就是最初的运算放大器，简称运放。集成电路的发展，使得大量晶体管元器件集成在一个小芯片上成为可能，于是就有了今天十分常用的集成运算放大器。“运算放大器”由于最初用于模拟计算机上进行数学运算而得名。尽管现在广泛使用的数字计算机不再用运放进行计算操作，但名称还是保留了下来。而今天，运放在模拟电路中发挥着十分重要的作用，也成为模电课程的重点之一。
运放的虚短虚断特性：通常运放有两个输入端U+和U−，一个输出端Uo，它们之间满足​​​​​​​​​​​​​​运放开环增益A常常高达几十万~几百万，但运放的输出电压受电源电压限制，不能超出电源电压。于是运放的输入--输出关系类似下图形状。图中横轴是(U+-U-)，纵轴是Uo.
在中间那一段直线区域，运放在正常放大状态，称为线性区，满足Uo=A∗(U+−U−)，而当输入的绝对值稍大一点时，输出就会受到电源限制，不再满足上述关系式，Uo的值通常比电源电压范围略小（注意运放可以用双电源，即电源电压范围可以在一个负值和一个正值之间），称为非线性区。轨对轨运放的输出可以达到电源电压，有兴趣可以自行在网上搜索学习。当运放工作在线性区时，Uo的值很有限，但是A很大，所以U+−U−=Uo/A≈0，即U+≈U−。此时运放正负输入端电压几乎相等，就像短路了一样，称为虚短。所以只有当运放工作在放大区才会有“虚短”的特点，而非运放自身固有属性。另一方面，由于运放内部结构特性，其输入阻抗很大。输入阻抗可以简单理解为：输入阻抗 = 输入端电压 / 输入端电流。输入阻抗大，意味着运放输入端只需很小的电流就能正常工作。正因为如此，运放才能用于一些微弱电流的检测，比如人体的脑电波、肌电波，其最高电压值只有几mV，电流值也非常小。运放这一特性被称为虚断，也就是输入端和断路一样，几乎没有电流流入。与虚短不同，虚断是运放自身固有属性，不会随着电路的不同而改变。
运放的非理想特性：运放由三极管构成，显然和三极管一样，也会有很多不理想的特性。前面讲的都是理想运放的特点。而实际运放，它不会完全满足虚短虚断特性，正常工作时输入端需要电流流入，这个电流便被称作输入偏置电流。同样运放还有输入偏置电压、输入失调电压、输入失调电流等非理想参数。这些非理想特性，比如输入偏置电流虽然很小，但有时候却会对电路造成很大影响，导致电路无法工作。因此则需要通过一些手段减小这些因素造成的影响。在实际应用中，运放的非理想特性是一个非常重要的问题。运放非理想特性的消除有很多方法，这里不做介绍。模电课程的核心就是三极管和运放。围绕这些器件，讲解多种电路，包括：
●放大电路的计算分析、多级放大电路、放大器的频率特性、反馈的思想；
●功率放大电路；
●比较器、振荡器、积分器、微分器、波形发生等；
●信号运算处理；
●滤波器；
●集成稳压电源电路等。
运放和三极管的比较：在实际设计电路时，运放比三极管用的相对会多一些。因为运放的很多特性比三极管要优秀，电路设计简单，而且往往运放的成本并不高。很多时候用三极管和运放实现同样的效果，使用运放的成本反而更低。因为运放是将大量晶体管集成在一块的，平均每个晶体管的制造成本非常低。例如一个常规音频前级放大器，一个通用运放就能搞定，成本可能是0.2元，而用三极管实现同样的效果，可能需要10个甚至更多三极管，成本或许要0.5元，并且设计时所花费的人力成本远比运放方案高。当然三极管也有其优势。在一些非常简单的电路中，并不严格要求放大倍数的稳定性，一两个三极管就能完成任务，往往会用三极管以节省成本。另外在一些比较极端的条件下，比如工作在高频率、大功率的环境下（例如射频信号发射电路），设计良好的三极管电路的性能会比运放效果好很多，或者成本低很多，甚至有些情况下只有直接使用晶体管才能完成，这时就需要使用三极管来搭建电路了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07b5b98536627d530181c6a757feb03b/" rel="bookmark">
			ubuntu系统分区扩充-以根目录为例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 ubuntu系统根目录扩充1. 安装Gparted软件2. 采用U盘启动，进入Ubuntu试用系统3. 打开Gparted，更改磁盘大小4. 最后点击 编辑-应用全部系统，重启OK!可能遇到的问题及解决方法开机启动慢，系统经常卡住 ubuntu系统根目录扩充 之前安装Ubuntu系统，还不知道各个分区的作用，于是就按照网上的教程进行的分区，最近使用的时候，发现根目录空间不够，而home空间还很大，参考了很多网上的教程，采用了Gparted磁盘管理工具对根目录进行扩充，将步骤记录如下：
1. 安装Gparted软件 ``` sudo apt install gparted sudo gparted ``` 打开之后可以看到自己的磁盘大小情况（我这里已经扩充好了），我的磁盘情况是，p9、p10、p11、p12分别是boot、swap、根目录、home分区，之前根目录比较小，home比较大，需要把home删除一点分给根目录，但是现在的情况是这几个盘是锁定状态，修改不了，因此进入Ubuntu试用系统进行修改
2. 采用U盘启动，进入Ubuntu试用系统 我的那个U盘是之前安装Ubuntu系统时候用的U盘，内容还没删，直接拿过来就用了。
电脑重启，进入bios设置成U盘启动，然后进入Ubuntu系统试用模式（这个选项try ubuntu without installing）
3. 打开Gparted，更改磁盘大小 在试用模式下的软件打开界面，可以发现磁盘前边没有锁了，可以编辑了
我发现这个软件修改磁盘大小具方便，你打开一个磁盘，右键，选择更改大小/移动（英文好像是叫resize/move），打开之后就出现下边这个界面，
直接拖动上边这个滑块，就能实现对该部分磁盘操作，灰色的是删除后空闲的，黄色的是已经使用的，白色的是磁盘还剩下的，
左边灰色空闲的部分会生成在该磁盘上边，右边灰色空闲的磁盘会生成在该磁盘的下边
4. 最后点击 编辑-应用全部系统，重启OK !可能遇到的问题及解决方法 开机启动慢，系统经常卡住 看swap分区是否异常
查看当前swap分区的UUID编号对不对，不对则改正 https://blog.csdn.net/Will_Ye/article/details/121902199
查看swap是否损坏，损坏则格式化重建一个 打开GParted,找到交换分区（交换分区一般很小，看你所分大小了），然后格式化该分区(右键—&gt;格式化为—&gt;linux-swap)然后，点击“Appley All Operations”。上述操作完成后，右键点击新建的交换分区，查看“Information信息”,复制UUID 序号。在终端中输入接下来命令： sudo gedit /etc/fstab复制刚才拷贝的序号到 UUID= 后面。保存文件修改。参考链接 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b19c82e4c4d538d7569449bca175da0c/" rel="bookmark">
			数据结构|输出二叉排序树采用中序线索链表作为存储结构进行存储后中所有值在a，b之间的关键字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目：
假设二叉排序树采用中序线索链表作为存储结构进行存储，请写出该线索链表的存储结构，并编写算法输出该二叉排序树中所有值在a，b之间的关键字，其中a &lt; b，二叉排序树左子树结点的值小于根结点的值，右子树结点的值大于根结点的值，树中没有关键字相重的结点。
代码：
// 二叉排序树的结点定义如下： typedef struct Node { int data; struct Node *lchild, *rchild; //左右孩子指针 int LTag, RTag; //左右标志，0表示孩子，1表示线索 } BSTNode； //算法如下： void report(BSTNode *T, int a, int b){ p = T-&gt;lchild; // p指向根结点 while (p != T) { // 空树或遍历结束时，p==T while (p-&gt;LTag==0) p = p-&gt;lchild; // 寻找第一个结点 if(p-&gt;data &gt; a &amp;&amp; p-&gt;data &lt; b) printf(“%d\n”, p-&gt;data); while (p-&gt;RTag==1 &amp;&amp; p-&gt;rchild!=T) { p = p-&gt;rchild; if(p-&gt;data &gt; b) return; // 结点的值大于b，算法结束 if(p-&gt;data &gt; a &amp;&amp; p-&gt;data &lt; b) printf(“%d\n”,p-&gt;data); } p = p-&gt;rchild; // p进至其右子树根 } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d91769e5632f25fe391ee8d00c6bc594/" rel="bookmark">
			EaxyExcel读取多个sheet的数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 EaxyExcel不仅导出多个sheet页，还可以读取多个sheet。核心是为每个sheet分别配置监听器。
效果 实现 导入依赖 &lt;!-- https://mvnrepository.com/artifact/com.alibaba/easyexcel --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;easyexcel&lt;/artifactId&gt; &lt;version&gt;2.2.7&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/com.google.guava/guava --&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.guava&lt;/groupId&gt; &lt;artifactId&gt;guava&lt;/artifactId&gt; &lt;version&gt;30.1-jre&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Lombok --&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;!-- springboot test启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;/dependency&gt; 继承AnalysisEventListener类 EaxyExcel读取excel采用监听者模式，监听器的命名以Listener结尾。要实现的是invoke和doAfterAllAnalysed方法。
EaxyExcel每读一行数据都调用invoke方法，读完当前sheet后调用doAfterAllAnalysed。
AnalysisEventListener是个泛型类，假设传入的泛型是Map&lt;Integer, String&gt;，那就取到每个格子的列号和值，再配合invoke的参数，可以拿到行号。列号和行号都有了，干啥不行？
import com.alibaba.excel.context.AnalysisContext; import com.alibaba.excel.event.AnalysisEventListener; import lombok.Data; import lombok.extern.slf4j.Slf4j; import java.util.*; /** * 不能交给spring管理，每次读取都要new * * @date 12/23/2020 18:52 */ @Slf4j @Data public class LunchDataListenerMultiSheetForCSDN extends AnalysisEventListener&lt;Map&lt;Integer, String&gt;&gt; { private List&lt;List&lt;String&gt;&gt; dataList; public LunchDataListenerMultiSheetForCSDN() { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d91769e5632f25fe391ee8d00c6bc594/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a593d29bb8283da94687d3400c38fa0/" rel="bookmark">
			一个评测模型&#43;10个问题，摸清盘古、通义千问、文心一言、ChatGPT的“家底”！...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		‍数据智能产业创新服务媒体
——聚焦数智 · 改变商业
毫无疑问，全球已经在进行大模型的军备竞赛了，“有头有脸”的科技巨头都不会缺席。昨天阿里巴巴内测了通义千问，今天华为公布了盘古大模型的最新进展。不久前百度公布了文心一言、360也公布了大模型产品，另外还有字节跳动、腾讯、京东、网易等都在积极投入这个赛道。
可以预见，2023年我们将见证多个大模型产品的发布，甚至可以试用多个大模型产品。既然这么多同类产品，那到底孰优孰劣呢？目前业界还没有比较科学合理的评测标准。为此，数据猿试图建立一个大模型产品的评测体系，来评估同类产品的能力。
影响大模型表现的核心因素
为了让评测体系更加科学合理，我们需要搞清楚影响一个大模型产品表现的核心因素有哪些，这些因素是如何影响大模型的最终表现的。在此基础上，来构建一个评分体系。
评估一个大模型的能力需要从多个方面来考虑。以下是一些主要的评估因素：
数据集
数据集的质量直接影响模型学到的知识和泛化能力。一个高质量的数据集应具有多样性、平衡性和一定的规模。多样性意味着数据集包含不同领域、风格和类型的文本；平衡性意味着数据集中各类别的样本数量相对均衡；规模则关乎数据集的大小。
数据集就像是一位老师教的课程内容。优质的课程能让学生全面了解各个领域的知识，而质量较差的课程可能让学生只了解某些领域，导致知识结构不均衡。
虽然许多企业从公开渠道获取数据集，但它们可能会对数据进行筛选、清洗和扩充，以构建具有自身特点的数据集。
模型架构
模型架构决定了模型的基本结构和计算方式。模型架构就像是建筑物的结构设计。不同的结构设计具有不同的功能和性能。例如，Transformer 架构提供了强大的处理长序列数据的能力，使其能够更好地理解和生成语言。
不同企业可能会针对自己的需求和场景对模型架构进行调整和优化。例如，一些企业可能会采用更高效的模型架构，以在减少计算资源消耗的同时保持良好的性能。
算法优化
优化算法负责在训练过程中调整模型的参数，以最小化损失函数。合适的优化算法可以加速模型收敛，提高模型的性能。
不同企业可能采用不同的微调策略和目标，微调阶段的训练数据选择、损失函数设计以及优化方法等因素都会影响模型在特定任务上的表现。一些企业可能拥有独家的技术和专利，如模型并行化、梯度累积等，这些技术可以提高模型训练的效率和性能。
参数规模
参数规模决定了模型的复杂度和学习能力。需要注意的是，更多的参数可以帮助模型学习更多的知识和特征，但同时可能导致过拟合。
参数规模就像是一个人的记忆力。记忆力越强，能记住的知识越多。然而，如果一个人只是机械地记忆而不能灵活运用知识，那么这种记忆力就不是很有用。适当的参数规模可以保证其在学习丰富知识的同时，保持良好的泛化能力。
计算资源
计算资源对模型的训练速度和扩展性有很大影响。越充足的计算资源，模型的训练速度就越快。大模型的训练对芯片有较高要求，通常需要使用专门为深度学习设计的高性能芯片，如 GPU（图形处理器）或 TPU（张量处理器）。例如，对于一个1000亿参数规模的模型，训练过程可能需要数百到数千个高性能 GPU（如 NVIDIA V100 或 A100 等）。
计算资源的消耗与模型参数规模、数据集规模、批量大小和训练轮数等因素密切相关：参数较多的模型需要更多的内存来存储参数，同时在训练过程中需要进行更多的计算；数据集越大，模型需要处理的数据就越多，从而增加了训练的计算量；批量大小是指每次训练迭代中输入模型的样本数量，较大的批量大小可以更好地利用 GPU 和 TPU 的并行计算能力，提高训练速度。然而，较大的批量大小也会增加显存或内存的消耗。因此，选择合适的批量大小是在计算资源消耗和训练速度之间找到平衡的关键；更多的训练轮数意味着模型需要进行更多次的迭代，相应地，计算资源的消耗也会增加。
总结一下，从技术角度来看，数据集、模型架构、参数规模、算法优化和计算资源这几个因素对模型的最终表现具有重要影响。我们可以将模型训练比喻成烹饪过程：数据集就像食材，高质量的食材会让菜肴更美味；模型架构就像烹饪方法，合适的烹饪方法可以充分发挥食材的特点；微调策略就像调料，恰当的调料可以使菜肴更具特色；专有技术和专利则像独特的烹饪技巧，让厨师能在短时间内炮制出高水平的菜肴。
以 ChatGPT 为例，其在数据集、模型架构、参数规模、算法优化和计算资源等多方面都进行了优化，才让其有如此惊艳的表现。例如，在数据集方面，OpenAI的GPT系列模型除了使用大规模的网络数据集，还会采集其他特定领域的数据集来扩展模型的知识覆盖。在微调阶段，针对特定任务使用更为精细的数据集，例如对话任务的数据集或者特定领域的文本数据。此外，OpenAI在分布式训练、模型压缩和模型优化等方面拥有一些专有技术。例如，OpenAI发布了名为“Megatron”的大规模模型训练技术，该技术通过模型并行化和流水线并行化来提高训练速度。
大模型能力的评测体系
基于上面的分析，我们试图来构建一个评测体系，以更科学合理的方式来评估一个大模型的能力。
我们将主要影响因素分为以下几个方面，并为每个方面分配权重（100分制）：
数据集质量（25分）
覆盖面：模型覆盖的领域和主题是否全面（10分）
多样性：数据集中包含的文本样式和类型是否丰富（10分）
清洗程度：数据集中的噪声、重复和无关内容的处理程度（5分）
模型架构与算法优化（25分）
架构创新：模型架构是否具有独特性和优势（10分）
优化方法：采用的优化算法是否能有效提高模型性能（10分）
参数规模：模型的参数规模与性能之间的平衡（5分）
微调策略与任务适应性（25分）
微调数据集选择：针对特定任务选择的微调数据集质量（10分）
损失函数与优化方法：微调过程中的损失函数设计和优化方法选择（10分）
任务适应性：模型在各种任务上的适应性和泛化能力（5分）
性能表现与计算资源消耗（25分）
准确性：模型在各种任务和数据集上的准确性表现（10分）
实用性：模型在实际应用场景中的实用性和可扩展性（10分）
计算资源消耗：模型训练和推理过程中的计算资源消耗（5分）
对于一个刚推出的大模型，我们可以参考以上评估模型，根据其在每个方面的表现给予相应分数。这可能需要查阅相关文献、测试报告和实际应用案例等信息。在为每个因素分配分数后，可以将分数加总以得到该大模型的总评分。
当然，这个评估模型只是数据猿的一个初步建议，实际评估过程可能需要根据具体情况进行调整和优化。
有了评测模型，接下来我们就试着用这个模型来评估一下市面上的一些大模型产品。需要说明的是，虽然国内的百度、阿里巴巴、华为都在研发大模型产品，有些已经开启内测，但公开的资料相对较少，还不足以支撑我们对其进行完整评测。
因此，我们在此只能选取一些国外公布相关数据较为充分的大模型产品来进行评测。暂且选取GPT-3、BERT和T5这三个产品作为样本，试用一下我们的评测模型。以下，我们将套用评测模型，基于能搜集的公开信息分别对GPT-3、BERT、T5的各项指标进行打分。
1、GPT-3（OpenAI）
数据集质量：22分
覆盖面：10分，GPT-3使用了大量的文本数据，包括Common Crawl数据集，覆盖了多个领域和主题。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5a593d29bb8283da94687d3400c38fa0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b3fe0d6e55af806d5699edf6a257dd8/" rel="bookmark">
			uniapp 页面设置高度百分百，当页面超过百分百的时候底部会出现一块白色解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用scroll-view包裹，并且给scroll-view设置高度100%
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b8738191c00d9a9c8fa34c1dce26ca8/" rel="bookmark">
			Qt图表绘制（QtCharts）-绘制三种样式的散点图（9）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Qt图表绘制（QtCharts）-绘制三种样式的散点图（9）🐔 文章目录 Qt图表绘制（QtCharts）-绘制三种样式的散点图（9）🐔1、概述🐓2、实现步骤🐤3、主要使用的类🐥4、主要代码🐦5、实现效果🦢6、源代码🦉 更多精彩内容👉个人内容分类汇总 👈 注意：我使用的QtCharts是基于Qt 5.12.12版本 1、概述🐓 Qt Charts 模块提供了一组易于使用的图表组件，能够创建时尚、交互式、以数据为中心的用户界面。
它使用 Qt Graphics View 框架，因此可以轻松地将图表集成到现代用户界面中。
Qt Charts 可以用作 QWidgets、QGraphicsWidget 或 QML 类型。 用户可以通过选择图表主题之一轻松创建令人印象深刻的图表。
这一个Demo干了啥：🤏🤏🤏
演示了如何使用QtCharts绘制圆点、矩形点、五角星点三种样式的散点图；将绘制三种点的功能代码分离到三个函数中，不糅合在一起，使代码尽可能的简单、简洁，便于学习；取消了Qt示例中继承QChartView的实现方式，降低代码复杂度；在源码中包含使用的详细注释和注意事项 ；将UI和代码分离，使实现图表绘制的代码更单一简洁，便于学习。 2、实现步骤🐤 打开.pro文件，输入Qt += charts，引入Qt Charts模块；
打开ui设计器，选择一个Graphics View控件，鼠标右键提升为；
输入QChartView，点击添加、提升；
在窗口右上角就可以看见控件类型变成QChartView了，然后将控件命名为chartView； 注意：由于QChartView需要引入命名空间，所以这里提升后编译时不通过的。
添加三个QPushButton用于分别绘制三种样式的散点。
在代码中添加QtCharts头文件，引入命名空间；一般我们最好在cpp文件中添加头文件和引入命名空间，尽量避免在.h文件中引入（这里为了方便，代码简洁直接在头文件中引入命名空间），而在cpp文件中引入命名空间需要在ui_widget.h文件前，否则编译会失败，因为在ui文件中会用到QChartView类。
#include &lt;QtCharts&gt; // 导入QtCharts所有的头文件，也可以单独导入某一个 // 引入qchart命名空间（注意：如果是在ui中提升为QChartView， // 则QT_CHARTS_USE_NAMESPACE一定要放在#include "ui_widget.h"前面，否则编译会失败） QT_CHARTS_USE_NAMESPACE 3、主要使用的类🐥 类名作用QScatterSeries创建一个用于绘制散点的数据集对象QRandomGenerator生成随机数QPainterPath提供了一个用于绘制操作的容器（用于保存绘制五角星的线条）QPainter在小部件和其他绘制设备上执行低级绘制（用于绘制一个五角星图案） 4、主要代码🐦 在widget.cpp的构造函数中调用initChart()函数；在UI中添加三个按键，分别用于绘制圆形散点、矩形散点、五角星散点； /** * @brief 初始化绘制图表，在initChart没有添加散点，在点击按键后再绘制散点图 */ void Widget::initChart() { ui-&gt;chartView-&gt;setRenderHint(QPainter::Antialiasing); // 设置抗锯齿 ui-&gt;chartView-&gt;chart()-&gt;setTitle("散点图标题"); // 设置图表标题 ui-&gt;chartView-&gt;chart()-&gt;setDropShadowEnabled(false); // 设置不启用背景阴影效果。 ui-&gt;chartView-&gt;chart()-&gt;legend()-&gt;setMarkerShape(QLegend::MarkerShapeFromSeries); // 在图例中显示点的形状样式 ui-&gt;chartView-&gt;chart()-&gt;setTheme(QChart::ChartThemeBlueCerulean); // 设置表的样式 } /** * @brief 在图表中添加圆点样式散点 */ void Widget::on_pushButton_clicked() { QScatterSeries* series = new QScatterSeries(); // 创建一个散点数据集对象 series-&gt;setName("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b8738191c00d9a9c8fa34c1dce26ca8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/460de253fb2623a91cea688a3e44670f/" rel="bookmark">
			Java栈
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 栈 1.1栈的概念 栈是一种特殊的线性表，其只允许在固定的一端进行插入和删除操作。栈中的元素遵循先进后出的原则。
压栈：栈的插入操作（入数据在栈顶）出栈：栈的删除操作（出数据在栈顶） 1.2 栈的使用 注意注释
package stackdemo; import java.util.Stack; public class TestDemo { public static void main(String[] args) { Stack&lt;Integer&gt; stack=new Stack&lt;&gt;(); //给栈里面放元素 stack.push(12); stack.push(23); stack.push(34); stack.push(45); //出栈 //pop弹出并且删除元素 int ret=stack.pop(); System.out.println(ret);//45出，栈中已经没有了45 //peek获取元素但是不删除 int ret1=stack.peek(); System.out.println(ret1); //栈是否为空 System.out.println(stack.empty()); System.out.println(stack.isEmpty()); } } 2 栈的应用 1 若进栈序列为1,2,3,4，进栈过程中可以出栈，则下列不可能的一个出栈序列是（）A :1,4,3,2 B :2,3,4,1 C :3,1,4,2 D :3,4,2,1
答案：C
进栈过程中可以出栈，比如A选项，先进1 再出1，再进2、进3、进4，再出4、出3、出2，即符合题意。
2 一个栈的初始状态为空。现将元素1、2、3、4、5、 A 、 B 、 C 、 D 、 E 依次入栈，然后再依次出栈，则元素出栈的顺序是（)。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/460de253fb2623a91cea688a3e44670f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7698ec2b7e10ebbce696930baa98f4c/" rel="bookmark">
			react-redux入门版-你想了解的这里都有
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 什么是redux？ redux 是一个独立的，开源的，第三方的集中式的状态管理器。redux除了和React一起用外，还支持其它界面库。它体小精悍(只有2kB，包括依赖)我们知道react是一个单项数据流框架，state数据具有只读属性，在组件通讯中:
父传子：直接通过prop传递，
子传父：通过父传递给子方法，子组件调用这个方法进行传参，
子传子︰兄弟传参，状态提升，可以把他们的状态提升到公共的父组件中或者使用exentBus创建公共容器。那么更复杂的组件关系该如何传参，如果某个状态组件需要被其他所有组件共享，那是不是每个组件都需要进行传递参数和接收参数，因此，redux就是为了解决这个问题，为我们提供一个可以存放共享状态的仓库。 我们来看一下redux的工作原理图
2. redux的核心概念： 核心概念：store、action、reducer
2.1 store store：仓库，Redux 的核心，整合 action 和 reducer
特点：
一个应用有且只能有一个store， 整个应用需要管理的数据都在这个Store里面，他相当于一个最高指挥家，他负责把action动作交给对应的reducer进行执行，也就是说将state、action和reducer联系在一起的对象。这个Store我们不能直接去改变，我们只能通过返回一个新的Store去更改它。redux提供了一个createStore来创建state import { createStore } from 'redux' const store = createStore(reducer) action：动作
一个js对象，包含两个属性：
type： 标识属性，值是字符串。多个type用action分开payload：数据属性，可选。表示本次动作携带的数据这个 action 指的是视图层发起的一个操作，告诉Store 我们需要改变。比如用户点击了按钮，我们就要去请求列表，列表的数据就会变更。每个 action 必须有一个 type 属性，这表示 action 的名称，然后还可以有一个 payload 属性，这个属性可以带一些参数，用作 Store 变更： const action = { type: 'ADD_ITEM', payload: 'new item', // 可选属性 } reducer：处理器
初始化状态
修改状态
在redux中，reducers是用来处理action的纯函数。当一个action发生时，reducers会根据action中的type和payload来更新store中的state。reducers接收当前的state和action，并返回一个新的state，而不会对原有的state进行修改。
reducers被设计为纯函数，所以它们不会有副作用，也不会改变传递给它们的参数。它们始终使用同样的输入来产生同样的输出，因此非常易于测试和调试。
比如像计算器我们需要在原来的数据上进行加1的操作，那么旧状态旧对应原来的数据，action对应加1的操作，返回的新状态就是计算器加完之后重新返回的结果。
在reduces定义 加减的案例
reducers: { // 处理加法 increment: (state) =&gt; { state.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a7698ec2b7e10ebbce696930baa98f4c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e97188356bd764f014aba216fa617cf/" rel="bookmark">
			ubuntu18.04安装（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、安装虚拟机二、安装VM-tools三、安装ros 前言 本人经历了多次的安装，决定记录一下自己的安装过程。
提示：以下是本篇文章正文内容
一、安装虚拟机 本人使用的是windows系统，需要在电脑上安装虚拟机umware来装ubuntu系统。
这是附带的虚拟机安装包：链接：https://pan.baidu.com/s/1o9E_wuNGKEc8qKSJpq-HNQ
提取码：bu17
–来自百度网盘超级会员V5的分享
我是在某一磁盘里创建了一个umware文件夹，把下载的都放在里面。
可以参考其他博客虚拟机的安装，基本上大差不差，软件包中有许可证，可以直接复制粘贴使用。安装完成后桌面上有显示图标：
1.打开虚拟机，创建新的虚拟环境。选择第二个。
2.点击后出现，点击next
3.选择图片上的，点击next。对于ubuntu的软件包，我用的给出百度云链接。我是把软件包直接下载到umware文件夹中，不需要解压。
链接：https://pan.baidu.com/s/15OKgW8gpGxcO2c6FJioWVw
提取码：bu18
–来自百度网盘超级会员V5的分享
4.如图
5.选择自己的位置，我在umware中创建ubuntu18.04文件夹用来储存。
6.如图
7.如图
8.如图
9.如图
10.如图
11.如图，进行创建
12.如图
13.如图
14.点击最左边按钮
15.打开如图
16.移除打印机，printer给remove掉
17.选择镜像包
18.取消3d加速，后续可能因为点击这个出现故障，我直接把它关闭了。
19.出现这个界面
20.选择中文简体，点击安装ubuntu
21.选择汉语，点击继续
22.继续
23.继续
24.继续即可25.点击继续
26.设置密码
27.等待安装
28.安装完毕后，选择重启
29.出现，please remove the installation medium，the reboot。我是选择关机，再重新启动，就解决了。如果有没解决的，可以参考相关博客：https://blog.csdn.net/weixin_42081389/article/details/104072902
30.重启后，选择不升级
31.选择更新
31.选择更新软件
32.等待软件安装好。切换源
二、安装VM-tools 打开终端（Ctrl+Shift+T），ctrl+alt+t，手动输入以下命令，再重启ubuntu系统就可以实现。
即通过安装VMtools实现了Windows与Ubuntu跨系统复制粘贴，也实现了Ubuntu窗口自适应
代码如下）：
sudo apt-get autoremove open-vm-tools sudo apt-get install open-vm-tools sudo apt-get install open-vm-tools-desktop 三、安装ros 18.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e97188356bd764f014aba216fa617cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1670803e52f823d48760a6dccd10cb23/" rel="bookmark">
			js中数字运算结果与预期不一致的问题和解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文主要是和大家聊聊关于js中经常出现数字运算结果与预期结果不一致的问题，与及解决该问题的的方案。
一、问题现象 如：0.1 + 0.2的预期结果是0.3，但是在js中得到的计算结果却是0.30000000000000004，如下图所示
如：0.3 - 0.2的预期结果是0.1，但是在js中得到的计算结果为0.09999999999999998，如下图所示
要想明白出现上述问题的原因，还需要了解在js中数字是如何编码的。
二、js中的数字编码 JavaScript 的 数字Number 类型(可表示整数和小数)是一个双精度 64 位二进制格式 IEEE 754 值，类似于 Java 或者 C# 中的 double。这意味着它可以表示小数值，但是存储数值的大小和精度有一些限制。简而言之，IEEE 754 双精度浮点数使用 64 位来表示 3 个部分：
1 比特符号位（sign）（0-正数，1-负数）11 比特指数位（exponent）（-1022 到 1023）52 比特尾数位（mantissa-小数部分）（表示 0 和 1 之间的数值） 尾数（也称为有效位数）是表示实际值的数值（有效数值）部分。指数是尾数应乘以的 2 的幂。将其视为科学计数法：
尾数使用 52 比特存储，在二进制小数中解释为 1.… 之后的数值。因此，尾数的精度是 2的-52次方幂（可以通过 Number.EPSILON 获得），或者十进制小数点后大约 15 到 17 位；高于该精度级别的算术需要舍入。
一个数值可以容纳的最大值是 2的1024次方减1（基于二进制的指数为 1023，尾数为 0.1111...），这可以通过 Number.MAX_VALUE 获得。大于该值的数值，被特殊数常数 Infinity 取代。
只有在 范围内的整数才能在不丢失精度的情况下被表示（可通过 Number.MIN_SAFE_INTEGER 和 Number.MAX_SAFE_INTEGER 获得），因为尾数只能容纳 53 位（包括前导 1）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1670803e52f823d48760a6dccd10cb23/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/beb83716a96231c66a2be645d166d99e/" rel="bookmark">
			抓包微信下线的操作思路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我来详细介绍一下实现微信下线操作的思路：
1. 首先，你需要清楚微信客户端和服务器之间的通信流程。微信客户端通过向服务器发送登录请求完成登录操作，而微信下线操作则需要模拟微信客户端向服务器发送下线请求。
2. 接下来，你需要使用网络抓包工具对微信客户端和服务器之间的通信数据进行捕获，并分析出微信下线请求所在的数据包。你可以按照以下步骤进行：
- 打开网络抓包工具，设置要监控的网络适配器。
- 启动微信客户端并登录账号。
- 在网络抓包工具中查看所有网络数据包，并筛选出微信客户端的数据包。你可以使用过滤规则来快速筛选，例如“host wx.qq.com”或“host login.weixin.qq.com”。
- 找到可能包含下线请求的数据包，选择并进行分析，查看其中的请求参数、请求头等信息，了解微信下线请求的整个结构。
3. 接下来，你需要编写代码或者脚本来模拟微信客户端向服务器发送下线请求。你需要了解微信下线请求的请求参数，请求方式，请求 URL 等信息，并根据这些信息来实现请求的构造和发送。
4. 如果你发现微信下线操作无效，那么你需要使用清除缓存和 Cookies 的方式，强制让微信客户端重置登录状态。这个过程可以通过代码来实现，具体的实现方式可以参照微信开放平台提供的文档。
总的来说，实现微信下线操作需要你具备网络抓包、编程以及与微信客户端和服务器交互的相关知识。同时，你也需要遵循相关法律法规，并保护用户的隐私和信息安全。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02958653fbaaa4f2002b236cf70fe2ec/" rel="bookmark">
			labview 创建路径
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.引沿
在labview 的动态调用中，遵循创建路径-打开vi引用-调用节点-面板插入vi 4个步骤,
当我们拷贝程序到本电脑或其它电脑的另一个路径时，如果用的是绝对路径，会报错。所以最好是用相对路径。
下面分别列出绝对路径和相对路径
2.绝对路径
在基路径指出了绝对的路径，文件位置变化，会报错。
3.相对路径
如上图，基路径由用用程序目录vi获得，文件位置变化了，不报错。 4.应用程序目录
5.创建路径
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/022ecac88db9dbb86895eebf6ecb485f/" rel="bookmark">
			Git（五）：历史提交与远程仓库修改
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
4、查看提交历史
4.1 查看日志详细信息
4.2 查看某次提交信息
4.3 查看更改
5、撤销操作
5.1 取消暂存的文件
5.2 撤销对文件的修改
5.3 撤销远程记录
6 远程仓库的使用
6.1 查看远程仓库
6.2 添加远程仓库
6.3 从远程仓库中抓取与拉取
6.4 同步远程仓库
6.4.1 远程推送
6.4.2 同步远程
6.5 查看远程仓库
6.6 远程仓库的移除与重命名
6.6.1 代码退回
4、查看提交历史 4.1 查看日志详细信息 在提交了若干更新，又或者克隆了某个项目之后，通过 git log 命令回顾提交历史。
# 按提交时间列出所有的更新，最近的更新安排在最上面 $ git log # 会列出每个提交的： # SHA-1 校验和、提交作者和电子邮件地址、提交时间以及提交说明 # 简易查看 常用的有：
-p 用来显示每次提交的内容的差异；
-2 仅显示最近两次的提交（除了显示基本信息之外，还附带了每次 commit 的变化）；
--stat 查看每次提交的简略的统计信息： 列出所有被修改过的文件、有多少修改文件以及修改文件的那些行被移除或者添加、总结。
--pretty 指定使用不同于默认格式的方式展示提交历史： 内建的子选项：如 oneline ：将每个提交放一行显示；还有 short，full 和 fuller。 format 定制显示的记录格式： # --pretty=format 列出了常用的格式占位符写法及其代表的意义 $ git log --pretty=format:"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/022ecac88db9dbb86895eebf6ecb485f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e2f9c1d393af27904c422e9c950eba6/" rel="bookmark">
			（五）二分法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		二分法应用场景
存在一个有序的数列题目能建模为在一个有序数列上查找一个合适数值 特点速度快，效率很高，二分法的复杂度O(logn)
n次二分后，区间缩小到(b-a)/2^n，给定a,b和精度要求e，可以计算出二分次数n
(b-a)/2^n&lt;e。
如函数在区间[1,100000]内单调，要求根的精度10^-8，那么由100000/2^n&lt;10^-8可知二分次数
n&gt;log2(10^13)，44次。
整数二分
左闭右开循不变，
左中位数找后继，
右中位数找前驱，
欲寻后继收右边，
移左莫忘再加一。
例：在单调递增序列种查找x或x的后继，在单调递增序列种查找x或x的前驱
跳石头
看完贪心后回来补
青蛙过河
看完贪心回来补 实数二分
两种写法：while,for
1e-7表示10^-7，也可以用for循环来写，直接100次二分，一定会分到一个极小区间，但这个100不能滥用，达到精度即可，否则会超时。
练习：
一元三次方程求解
直接在区间上做二分无法找到3个解，题目给了个很好的条件，根与根之差绝对值大于等于1，
在每个[i,i+1]内做二分查找，共有200个长度为1的区间
题目要求精确到小数点后2位，（这里做10次二分，即1/1024的精度，足以达到题目要求确保不会出错）。
y(mid)*y(right)&gt;=0表示mid和right都在target的右侧，right=mid，y(mid)*y(right)&gt;=0则相反
解立方根
分巧克力 暴力法
二分法
用二分法来做，相当于是整数二分里求x或x的前驱，
需要注意的是，初始right必须是理论最长的边 ，不一定要比所有巧克力的宽高要小
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e161fe1829cb4b64db5281e842fcd879/" rel="bookmark">
			深入理解MCU启动原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前面写了一篇 STM32的完整启动流程分析，但是感觉有些地方没有完全理明白，因此对不清楚的地方又做了一些总结。
1. MCU最开始一启动后去哪里读代码？ CPU上电启动后被设计为去地址0x00000000位置处读取代码；首先会连续读取两个字，分别是栈指针初始值和复位异常处理函数的地址；然后跳去执行复位异常处理函数。
当然在一些早期的ARM处理器设计中，如Arm7TDMI，复位后会直接读取0地址处的代码进行执行，由软件初始化栈指针，0地址处存放的直接就是中断处理函数，而不是函数地址。
所以我们可以有理由推测出，第一个字是栈地址是因为接下来的复位中断处理函数涉及函数跳转，可能已经需要存放内容在栈里了。
2. 0x0地址处是bootROM代码吗，还是用户bootloader代码？ 答案是都可以。这其实取决于用户的代码是存放在哪里的。
比如说对于一些性能强的MCU（如Cortex-A系列）来说，代码本身体积比较大，存放在SD卡里或者QSPI/SPI Flash里都有可能，这些MCU启动一定是先去bootROM执行代码，因为SD卡、SPI Flash的储存不在MCU的统一编址空间里，没初始化这些外设前根本无法访问，bootROM这块Nor Flash就一定是可以被MCU直接通过总线地址访问的，0地址的代码位于bootROM中。代码从bootROM中起来后，通过启动引脚判断从哪个外设中搬用户程序，并去初始化相应外设，将外设中存储的用户代码搬到内部SRAM中执行。后续的启动流程不赘述。
对于一些小容量的MCU来说，比如Cortex-M3/M4，他们的芯片里有内置Flash，这个Flash的特点跟上面说的bootROM很像，是MCU可以直接通过地址总线去访问到的，不需要进行外设初始化的。当然，这些MCU内部也是有bootROM的，因此这些MCU一上电可以选择从bootROM中启动，也可以选择从内置Flash中启动，是通过外部引脚进行选择的，选择了谁，就把谁的起始地址映射到0地址处。
3. 类似Cortex-M3/M4是如何保证Flash起始地址是栈指针和复位异常处理函数指针的？ 这一点实际是通过编译的链接文件制定的。比如说如下是我截取的IAR的链接文件.icf。
4. MCU有可能不从0地址开始读代码吗？ M7内核芯片比较灵活了，改变了固定从0x0000 0000地址读取中断向量表的问题，以STM32H7为例，可以从 0x0000 0000 到 0x3FFF 0000 所有地址进行启动。专门安排了个选项字节来配置。
参考：
Definitive Guide to Arm® Cortex®-M23 and Cortex-M33 ProcessorsSTM32单片机启动流程分析： https://blog.csdn.net/qq_44971108/article/details/124051734bootrom是什么？ https://blog.csdn.net/weixin_44586903/article/details/129767640【不是问题的问题】为什么STM32的Flash地址要设置到0x08000000 https://cloud.tencent.com/developer/news/871044 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9dc4535334c42a0fd167e79308b3b6e7/" rel="bookmark">
			VMware Workstation Pro运行虚拟机卡顿问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、进入VMware 然后选择 左上角编辑-首选项
2、选择内存 额外内存 处 勾选第一个选项 3、选择优先级 抓取的输入内容 选择 高
然后点击确定
上述设置完成确定。
其具体原因是：如果虚拟机的物理内存划分不太够，那虚拟机系统会自动使用硬盘作为虚拟内存，但是速度却如蜗牛一般。同时，默认设置下【允许交换部分虚拟机内存】虚拟机与主机之间内存可以进行交换，也就是说，如果你主机的内存不够了，会从虚拟机抢一部分内存过去，这也是导致虚拟系统运行速度下降的原因。
4、虚拟机设置
编辑虚拟机设置，切换到【选项】选项卡
5、选择高级 同样是 将 抓取的输入内容 高 以及 勾选 禁用内存页面修整
现在再次打开虚拟机后，操作后也一点不卡了，MSI Afterburner检测到的帧率也能达到30fps以上了，甚至能跑到 60fps。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d4339ab37dd2626162eb138f9b54c14/" rel="bookmark">
			A.图机器学习(GML)&amp;图神经网络(GNN)原理和代码实现(前置学习系列二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图学习图神经网络算法专栏简介：主要实现图游走模型(DeepWalk、node2vec)；图神经网络算法(GCN、GAT、GraphSage)，部分进阶 GNN 模型（UniMP标签传播、ERNIESage）模型算法等，完成项目实战
专栏链接：图学习图神经网络算法专栏简介：含图算法（图游走模型、图神经网络算法等）原理+项目+代码实现+比赛
前人栽树后人乘凉，本专栏提供资料：快速掌握图游走模型(DeepWalk、node2vec)；图神经网络算法(GCN、GAT、GraphSage)，部分进阶 GNN 模型（UniMP标签传播、ERNIESage）模型算法，并在OGB图神经网络公认榜单上用小规模数据集（CiteSeer、Cora、PubMed）以及大规模数据集ogbn-arixv完成节点分类算法，省去你大把时间，效率提升。 帮助你快速完成任务落地，以及科研baseline。
更多内容见文末（含项目链接和码源）
图机器学习(GML)&amp;图神经网络(GNN)原理和代码实现（PGL）[前置学习系列二] 上一个项目对图相关基础知识进行了详细讲述，下面进图GML
networkx ：NetworkX 是一个 Python 包，用于创建、操作和研究复杂网络的结构、动力学和功能
https://networkx.org/documentation/stable/reference/algorithms/index.html
import numpy as np import random import networkx as nx from IPython.display import Image import matplotlib.pyplot as plt from sklearn.metrics import accuracy_score from sklearn.metrics import roc_curve from sklearn.metrics import roc_auc_score 1. 图机器学习GML 图学习的主要任务
图学习中包含三种主要的任务：
链接预测（Link prediction）节点标记预测（Node labeling）图嵌入（Graph Embedding） 1.1链接预测（Link prediction） 在链接预测中，给定图G，我们的目标是预测新边。例如，当图未被完全观察时，或者当新客户加入平台（例如，新的LinkedIn用户）时，预测未来关系或缺失边是很有用的。
详细阐述一下就是：
GNN链接预测任务，即预测图中两个节点之间的边是否存在。在Social Recommendation，Knowledge Graph Completion等应用中都需要进行链接预测。模型实现上是将链接预测任务看成一个二分类任务：
将图中存在的边作为正样本；负采样一些图中不存在的边作为负样本；将正样例和负样例合并划分为训练集和测试集；可以采用二分类模型的评估指标来评估模型的效果， 例如：AUC值在一些场景下例如大规模推荐系统或信息检索，模型需要评估top-k预测结果的准确性，因此对于链接预测任务还需要一些其他的评估指标来衡量模型最终效果：
MR（MeanRank）MRR（Mean Reciprocal Rank）Hit@n MR, MRR, Hit@n指标含义：假设整个图谱中共n个实体，评估前先进行如下操作：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d4339ab37dd2626162eb138f9b54c14/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c15635740fdd369170dcbae4d0b2b93/" rel="bookmark">
			android11 wifi 自动连接流程分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		android11 wifi 自动连接流程分析 \frameworks\opt\net\wifi\service\java\com\android\server\wifi\WifiConnectivityManager.java // wifi扫描回调 onResults(WifiScanner.ScanData[] results) // wifi扫描回调 handleScanResults(List&lt;ScanDetail&gt; scanDetails, String listenerName, boolean isFullScan) //获取可自动连接wifi List&lt;WifiCandidates.Candidate&gt; candidates = mNetworkSelector.getCandidatesFromScan( frameworks\opt\net\wifi\service\java\com\android\server\wifi\WifiNetworkSelector.java public List&lt;WifiCandidates.Candidate&gt; getCandidatesFromScan( List&lt;ScanDetail&gt; scanDetails, Set&lt;String&gt; bssidBlacklist, WifiInfo wifiInfo, boolean connected, boolean disconnected, boolean untrustedNetworkAllowed) { ... //遍历历史连接wifi列表，推荐连接列表，并返回相关的wifi信息 for (NetworkNominator registeredNominator : mNominators) { localLog("About to run " + registeredNominator.getName() + " :"); Log.i(TAG,"registeredNominator.getName():" + registeredNominator.getName()); registeredNominator.nominateNetworks( new ArrayList&lt;&gt;(mFilteredNetworks), currentNetwork, currentBssid, connected, untrustedNetworkAllowed, (scanDetail, config) -&gt; { WifiCandidates.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c15635740fdd369170dcbae4d0b2b93/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3be2a5a3b7a8f2b71e46500d16b551e4/" rel="bookmark">
			基于lstm的风力发电机健康监测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Predicting Remaining Useful Life of Wind Turbines Using LSTM
Abstract: Wind power has become one of the most promising and rapidly developing renewable energy sources. However, the reliability and stability of wind turbines are critical factors for ensuring the stable operation of wind power systems. Accurately predicting the remaining useful life (RUL) of wind turbines is of great significance for reducing maintenance costs and ensuring safe and efficient operation. In this study, we propose an LSTM-based RUL prediction method for wind turbines.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3be2a5a3b7a8f2b71e46500d16b551e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6610cdee23c86f3380273a8f1762fc5/" rel="bookmark">
			C语言读取一个多位数的每一位数字，读取一个字符串的每一个字符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 C语言读取一个多位数的每一位数字
#include&lt;stdio.h&gt; int main() { int num=0,i,ch; for(i=1;i&lt;=2020;i++) { ch=i; while(ch) { if(ch%10==2) { num++; } ch=ch/10; } } printf("%d",num); return 0; } C语言读取一个字符串的每一个字符
#include &lt;stdio.h&gt; int main() { char str[] = "hello"; char *ptr = str; while(*ptr) { printf("%c ", *ptr); ptr++; } return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f563d4e84a89e576a0262aed7c146cfc/" rel="bookmark">
			JS计算小数点精度丢失问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		造成小数点精度丢失的原因? 由于小数转二进制是乘 2 取整法，将十进制中的小数部分乘以 2 作为二进制的一位，然后继续取小数部分乘以 2 作为下一位，直到不存在小数为止。
话不多说，我们就以 8.625 转二进制作为例子，直接上图：
最后把「整数部分 + 小数部分」结合在一起后，其结果就是 1000.101。
但是，并不是所有小数都可以用二进制表示，前面提到的 0.625 小数是一个特例，刚好通过乘 2 取整法的方式完整的转换成二进制。
如果我们用相同的方式，来把 0.1 转换成二进制，过程如下：
可以发现，0.1 的二进制表示是无限循环的。
由于计算机的资源是有限的，所以是没办法用二进制精确的表示 0.1，只能用「近似值」来表示，就是在有限的精度情况下，最大化接近 0.1 的二进制数，于是就会造成精度缺失的情况。
对于二进制小数转十进制时，需要注意一点，小数点后面的指数幂是负数。
比如，二进制 0.1 转成十进制就是 2^(-1)，也就是十进制 0.5，二进制 0.01 转成十进制就是 2^-2，也就是十进制 0.25，以此类推。
举个例子，二进制 1010.101 转十进制的过程，如下图：
计算机是怎么存小数的？ 1000.101 这种二进制小数是「定点数」形式，代表着小数点是定死的，不能移动，如果你移动了它的小数点，这个数就变了， 就不再是它原来的值了。
然而，计算机并不是这样存储的小数的，计算机存储小数的采用的是浮点数，名字里的「浮点」表示小数点是可以浮动的。
比如 1000.101 这个二进制数，可以表示成 1.000101 x 2^3，类似于数学上的科学记数法。
既然提到了科学计数法，我再帮大家复习一下。
比如有个很大的十进制数 1230000，我们可以也可以表示成 1.23 x 10^6，这种方式就称为科学记数法。
该方法在小数点左边只有一个数字，而且把这种整数部分没有前导 0 的数字称为规格化，比如 1.0 x 10^(-9) 是规格化的科学记数法，而 0.1 x 10^(-9) 和 10.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f563d4e84a89e576a0262aed7c146cfc/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/155/">«</a>
	<span class="pagination__item pagination__item--current">156/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/157/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>