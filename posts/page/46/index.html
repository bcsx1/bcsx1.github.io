<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c76034688dcd3a90a43a1c2fc0d86d7/" rel="bookmark">
			STM32超声波——HC_SR04
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一.超声波图片二.时序图三.超声波流程四.单位换算五.取余计算六.换算距离七.超声波代码 一.超声波图片 测量距离：2cm——400cm
二.时序图 (1).以下时序图要先提供一个至少10us的脉冲触发信号，告诉单片机我准备好了，然后该超声波模块内部将发出8个40Khz的的周期电平并检测回波，这时候是超声波模块发送的波，检测能不能发送超声波，与单片机无关，所以代码就不用写写这里的代码，然后一旦检测到有回波信号后则向单片机输出回响信号，高电平持续的时间就是超声波发出波到返回的时间。
(2).以超声波为主体，Trig是接受触发信号RX，Echo是发送超声波TX。
三.超声波流程 四.单位换算 五.取余计算 六.换算距离 从下图手册可知，我们距离s可以等于时间微妙us/58，单位是cm，所以把定时器设置成1ms，在然后在定时器中断里面设置一个标志位，进去一次就是1ms，然后标志位在乘于一个1000，就是把1ms换算成1000us了，然后这个是来回的时间，但是要注意超声波回来的最后一刻，定时器没有达到ARR自动重装值的话，就结束了，这个也要算进去时间，就是TIM_GetCounter，然后t得到之后，t需要/2，因为是来回的时间，然后因为声速是340m/s，需要把us换成s，就是t * 0.00001/2=t/2000000，然后340m/s需要换成cm，也就是340 * 100，所以s=t/2000000 * 340 * 100，最后换算就是t/58。
七.超声波代码 main.c
#include "stm32f10x.h" // Device header #include "Delay.h" #include "Buzzer.h" #include "OLED.h" float distance; int main() { Ultrasonic_Init(); OLED_Init(); OLED_ShowString(1,1,"distance"); OLED_ShowString(2,1,"000.000cm"); while(1) { distance=Ultrasonic_Getdistance(); OLED_ShowNum(2,1,distance,3);//最多3位，因为最高测量4m，也就是400cm OLED_ShowNum(2,5,(uint16_t)(distance*1000)%1000,3);//小数也是3位，然后这里OLED_ShowNum是只显示整数，所以需要把float类型强转int类型 Delay_ms(66);//周期至少60ms } } Buzzer.c
#include "stm32f10x.h" // Device header #include "Delay.h" #include "Buzzer.h" uint32_t Ultrasonic_Num=0;	// 计数值 void Ultrasonic_Port() { RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE); GPIO_InitTypeDef GPIO_InitStructure; //GPIOA0--RX--Trig GPIO_InitStructure.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c76034688dcd3a90a43a1c2fc0d86d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/148130cd3360bc494fbaa351687bc36e/" rel="bookmark">
			我们一起做过的SPA——Nuxt.js介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Nuxt.js 1 我们一起做过的SPA SPA（single page web application）单页 Web 应用，Web 不再是一张张页面，而是一个整体的应用，一个由路由系统、数据系统、页面（组件）系统等等，组成的应用程序。
我们之前学习的Vue就是SPA中的佼佼者。
SPA 应用广泛用于对SEO要求不高的场景中
2 什么是SEO SEO：搜索引擎优化（Search Engine Optimization）, 通过各种技术（手段）来确保，我们的Web内容被搜索引擎最大化收录，最大化提高权重，最终带来更多流量。
非常明显，SPA程序不利于SEO
SEO解决方案：提前将页面和数据进行整合
前端：采用SSR后端：页面静态化 （freemarker 、thymeleaf、velocity） 3 什么是SSR技术 服务端渲染（Server Side Render），即：网页是通过服务端渲染生成后输出给客户端。
在SSR中，前端分成2部分：前端客户端、前端服务端前端服务端，用于发送ajax，获得数据前端客户端，用于将ajax数据和页面进行渲染，渲染成html页面，并响应给调用程序（浏览器、爬虫） 如果爬虫获得html页面，就可以启动处理程序，处理页面内容，最终完成SEO操作。
4 SPA和SSR对比 SPA单页应用程序SSR服务器端渲染优势1.页面内容在客户端渲染
2. 只关注View层，与后台耦合度低，前后端分离
3.减轻后台渲染画面的压力1.更好的SEO，搜索引擎工具可以直接查看完全渲染的画面
2.更快的内容到达时间 (time-to-content)，用户能更快的看到完整渲染的画面劣势1.首屏加载缓慢
2.SEO(搜索引擎优化)不友好1.更多的服务器端负载
2.涉及构建设置和部署的更多要求，需要用Node.js渲染
3.开发条件有限制，一些生命周期将失效
4.一些常用的浏览器API无法使用 5 什么是Nuxt.js Nuxt.js 是一个基于 Vue.js 的通用应用框架。
Nuxt支持vue的所有功能，此类内容为前端客户端内容。Nuxt特有的内容，都是前端服务端内容。 通过对客户端/服务端基础架构的抽象组织，Nuxt.js 主要关注的是应用的 UI 渲染。
`内容。
通过对客户端/服务端基础架构的抽象组织，Nuxt.js 主要关注的是应用的 UI 渲染。
Nuxt.js 预设了利用 Vue.js 开发服务端渲染的应用所需要的各种配置。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a3a8da137c0c7e40851914407e755ab/" rel="bookmark">
			个人ACM模板（待持续补充）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言1.排序(1) 快速排序(2) 归并排序（求逆序对） 2.基础算法(1) 二分 3.数学(1) 线性筛（朴素，最小质因子，因子数，欧拉函数）- 朴素线性筛- 最小质因子筛- 因子数筛- 欧拉函数筛 (2) 快速幂 (龟速乘)(3) 欧几里得算法 (gcd, exgcd)(4) jiangly的模板元板子(5) jiangly的组合数板子(6) ygg的组合数板子 4.数据结构(1) 单调队列 (单调递减，递增)(2) 树状数组（前缀和，差分）(3) 线段树（维护区间和模板）(4) 重链剖分（维护树结构）(5) 分块（维护区间和模板）(6) 并查集(7) 可持久化线段树（维护区间和）(8) 珂朵莉树（ODT）(9) 莫队模板(10) 主席树模板（静态查询区间第 k 小） 5.图论(1) Dijkstra （堆优化）(2) Spfa- 朴素- SLF优化- LLL优化- SLF + LLL 优化 (3) Kruskal最小生成树(4) 最近公共祖先LCA (倍增，重链剖分)- 倍增- 重链剖分 (5) 求树的重心(6) Johnson全源最短路(7) 匈牙利算法 (二分图匹配)(8) Tarjan- 缩点 / 强连通分量- 割点 / 割顶- 桥- 点双连通分量- 边双连通分量 6.网络流(1) 网络最大流- Dinic（当前弧优化）- ISAP（当前弧优化） (2) 最小费用最大流- Dinic + SPFA 7.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a3a8da137c0c7e40851914407e755ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3c1c58c910ee44ae9a8abecc32dfb23/" rel="bookmark">
			问题汇总20231208
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 继电器的作用是什么2. 计算机网络在单片机项目中的应用有哪些3. 类似于MQTT的网络连接有哪些？4. 不同种类的电机的作用和应用场景5. 多核任务调度的时候 在每个任务里面加printf 就会导致一个核挂起呀 把printf 删除 所有任务就可以正常调度了，这可能是什么原因6. 为什么数据采样时间较快时不适合使用中值滤波？7. SPI通信属于串行传输吗？常见的并行传输的通信方式还有哪些？7. 单片机的OTP、MTP8. 一个函数的返回值是8位，但是计算结束后该返回值是12位，调用函数时会自动转成8位吗、9. 锁存器和寄存器是一个东西吗？10.调档风扇使用的电机一般是什么电机11. 协议栈是什么？有什么作用？里面包含什么内容？12. socket通信总是会断开的原因有哪些13.STM32Cubemx软件的作用，一般拿来做什么？ 1. 继电器的作用是什么 继电器是一基于电磁感应原理，通过控制小电流来开关或切换大电流电路。
继电器的主要作用如下：
电流放大：继电器可以将小电流信号转换为大电流信号，以便在电路中驱动或控制高功率负载。通过操纵继电器的控制电流，可以控制继电器的开关状态，进而控制大电流电路的通断。信号转换：继电器可以将一个电路的信号转换为另一个电路的信号。例如，将低电压信号转换为高电压信号，或将交流信号转换为直流信号，以满足不同电路之间的兼容性和互联需求电路保护：继电器可以用作电路保护装置，当电路中的异常条件出现时，如过载、短路或过压，继电器可以迅速切断或断开电路，以保护电路和相关设备免受损坏。逻辑控制：继电器可以用作逻辑控制开关，根据输入信号的状态来控制输出电路的通断。这种逻辑控制可以应用于自动化系统、计算机控制系统和工业控制系统中。时序控制：继电器可以用于控制电路的时序操作，例如按顺序打开或关闭多个电路，实现特定的操作顺序和时间延迟功能。
继电器是一种广泛应用于各种电气和电子系统中的重要组件，它们提供了可靠的控制和保护功能，使得电路能够按需工作，并实现复杂的电气控制和自动化操作 2. 计算机网络在单片机项目中的应用有哪些 计算机网络在单片机项目中可以具有以下应用：
远程控制和监控：通过网络连接，可以实现对单片机项目的远程控制和监控。例如，您可以通过网络远程控制家庭自动化系统，监控环境参数或实时获取传感器数据。数据采集和传输：单片机可以通过网络将采集到的数据传输到远程服务器或其他设备。这对于物联网应用中的传感器网络、环境监测系统或数据采集系统等非常有用。远程固件更新：通过网络连接，可以实现对单片机项目的远程固件更新。这样，您可以在不接触实际设备的情况下，通过网络将新的软件或固件版本传输到单片机上，以升级功能或修复漏洞。远程诊断和调试：通过网络连接，可以对单片机项目进行远程诊断和调试。这对于分布式系统或远程设备非常有用，可以帮助快速定位和解决问题，减少维护和故障排除的时间和成本。通信和协议转换：通过网络连接，可以实现单片机项目与其他设备或系统之间的通信和协议转换。例如，您可以使用单片机通过网络与PC进行通信，或将不同通信协议之间进行转换，以实现设备之间的互操作性。数据存储和访问：通过网络连接，可以将单片机项目中的数据存储到远程服务器或云存储中。这样，您可以实现数据的长期存储和备份，并且可以通过网络随时访问和共享数据。
在将计算机网络应用于单片机项目时，需要考虑硬件资源和单片机处理能力的限制。此外，网络安全也是一个重要的考虑因素，确保单片机项目与其他设备或网络之间的通信安全性和保密性。 3. 类似于MQTT的网络连接有哪些？ 除了MQTT，还有一些类似的网络连接协议可用于物联网和消息传递场景。以下是一些常见的类似于MQTT的网络连接协议：
CoAP（Constrained Application Protocol）：CoAP是一种专为受限环境下的物联网设备设计的轻量级应用层协议。它基于UDP协议，具有低开销和低带宽需求，并支持消息传递和资源发现。AMQP（Advanced Message Queuing Protocol）：AMQP是一个高级消息队列协议，用于在分布式系统中进行可靠的消息传递。它提供了消息的可靠性、顺序性和事务性，并支持灵活的消息路由和消息队列管理。XMPP（Extensible Messaging and Presence Protocol）：XMPP是一种基于XML的开放式标准协议，用于实时通信和消息传递。它最初设计用于即时通信，但也可以用于物联网场景中的设备间通信和状态传递。DDS（Data Distribution Service）：DDS是一种用于数据分发和实时通信的协议。它为广域网和局域网上的分布式应用程序提供了高性能、实时数据交换和发布/订阅模型。WebSocket：WebSocket是一种在Web浏览器和Web服务器之间进行全双工通信的协议。它提供了持久性连接和实时数据传输的能力，适用于实时通信和消息传递应用。 4. 不同种类的电机的作用和应用场景 直流电机（DC Motor）：直流电机是一种将直流电能转化为机械能的电机。它们具有简单的控制特性和高转矩输出，适用于需要快速启动、加速和反向运动的应用场景。直流电机广泛应用于机器人技术、自动化设备、电动车辆、风力发电机组等领域。交流电机（AC Motor）：交流电机是一种将交流电能转化为机械能的电机。最常见的交流电机包括感应电机和同步电机。交流电机具有高效率、低成本和长寿命等优点。它们广泛应用于家用电器、工业驱动、空调系统、水泵和风扇等领域。步进电机（Stepper Motor）：步进电机是一种旋转运动电机，它们可以精确地按照一定角度步进运动。步进电机通常用于需要精确位置控制的应用，如3D打印机、数控机床、精密仪器和机器人等。无刷直流电机（Brushless DC Motor）：无刷直流电机是一种将直流电能转化为机械能的电机，它们没有传统的碳刷和换向器。无刷直流电机具有高效率、低噪音和长寿命等优点。它们广泛应用于无人机、电动工具、电动车辆、家用电器和工业自动化等领域。齿轮电机（Gear Motor）：齿轮电机是一种结合了电机和齿轮传动的装置。它们具有高扭矩输出和较低的转速，适用于需要高扭矩和减速功能的应用。齿轮电机广泛应用于自动门、自动窗帘、机械臂、机械钟表和自动售货机等领域。
这只是一些常见的电机类型和应用场景的示例。实际上，还有其他类型的电机，如线性电机、声音电机、伺服电机等，在不同的应用领域有着各自特定的作用和用途。选择适合特定应用需求的电机类型至关重要。 5. 多核任务调度的时候 在每个任务里面加printf 就会导致一个核挂起呀 把printf 删除 所有任务就可以正常调度了，这可能是什么原因 在多核任务调度中，如果在每个任务中使用printf语句，可能会导致一个核挂起的原因是因为printf函数通常是线程不安全的。当多个任务同时执行并尝试在控制台输出时，可能会发生竞争条件，导致输出的混乱或不正确。
在单核系统中，由于任务是按顺序执行的，因此printf函数可能会按照预期顺序打印输出。但在多核系统中，多个任务可以并行执行，它们可能同时尝试访问控制台输出，导致竞争条件的发生。
为了解决这个问题，可以采取以下几种方法：
使用线程安全的输出函数：可以使用线程安全的输出函数，例如printf的线程安全版本（如printf_s）或专门为多线程环境设计的输出函数（如pthread_printf）。这些函数能够处理并发访问控制台输出的情况，避免竞争条件。使用互斥锁（Mutex）：在每个任务中使用互斥锁来保护对printf函数的访问。在任务中访问printf之前，先获取互斥锁进行加锁，完成后释放锁。这样可以确保只有一个任务能够访问printf函数，避免竞争条件。使用日志文件代替控制台输出：将任务的输出写入日志文件而不是直接在控制台输出。每个任务可以将输出写入独立的日志文件，避免竞争条件。然后，在需要查看输出时，可以单独读取和处理日志文件。 6. 为什么数据采样时间较快时不适合使用中值滤波？ 数据采样时间较快意味着采集到的数据更新速度较高，数据点之间的时间间隔较短。当数据采样时间较快时，中值滤波可能会导致时序关系丢失、受到临时突发噪声的影响，并且计算开销较大。因此，对于高采样速率的数据，通常需要考虑其他滤波方法，如滑动平均滤波、卡尔曼滤波等，以更好地处理动态信号并保持较好的实时性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3c1c58c910ee44ae9a8abecc32dfb23/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff407a2b5cc6565bb126a7c16d7cefa2/" rel="bookmark">
			RocketMq简介及安装、docker安装rocketmq、安装rocketmq可视化管理端
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 本文主要简单介绍rocketmq及使用docker安装rocketmq的方法。
rocketmq简介 rocketmq有两部分，nameserver和broker，nameserver用来维护broker的地址、向生产者、消费者推送broker的最新地址；broker用来存储、转发消息；也就是说，生产者首先要连接nameServer获取到broker的地址，然后将消息发送到broker，通过broker再将消息传递到消费者；
所以用docker安装rocketmq时，要启动两个容器，一个nameserver、一个broker，这两者要网络互通；
nameServer暴露的端口通常是9876；broker暴露的端口通常是10911，生产者就是往这个端口发送消息；消费者可能也是通过这个接口拉取消息；
下图中的Message Storage可认为是nameserver+broker
大体的结构示意图
安装 拉取镜像 docker pull apache/rocketmq:5.1.0 创建nameserver容器 docker run -d -p 9876:9876 --name rmqnamesrv apache/rocketmq:5.1.0 sh mqnamesrv docker run命令选项解释
--name rmqnamesrv，指定容器的名称为rmqnamesrvsh mqnamesrv，启动mqnamesrv，是个脚本文件 进入容器docker exec -it 容器id /bin/bash后能看到mqnamesrv两个文件，
[rocketmq@99e974741937 bin]$ ls -l mqnames* -rwxr-xr-x 1 rocketmq rocketmq 1472 Feb 14 2023 mqnamesrv -rwxr-xr-x 1 rocketmq rocketmq 1165 Feb 14 2023 mqnamesrv.cmd 创建broker容器 创建broker配置文件 在宿主机上，创建/etc/rocketmq/conf/broker.conf文件，添加如下配置
brokerIP1 = 宿主机ip namesrvAddr = 宿主机ip:9876 为了实现客户端与broker的通信可达性，这里必须要指定ip为 宿主机ip，默认使用的docker私有ip，客户端与私有ip通信不可达；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ff407a2b5cc6565bb126a7c16d7cefa2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bfcd24f5bd4793985fd3dfdee921f209/" rel="bookmark">
			Linux 文件权限
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 因为在做一个任务的时候，调接口要到某个路径下的文件下记录log，但是调接口总是报一个错误：
SEVERE: Local file cretaion error! I/O exception! File: /xxx/xxx/xxx/xx.log 发现是一个创建文件的错误，根据提示，想到一种可能就是文件缺少写入的权限，导致创建文件失败，因为尝试给文件和文件夹添加权限，添加权限时候，确实可以了，正好做一下总结，作为一个思路。
文件权限 我们可以看一下例子：
第一列展示的就是此文件的读写等权限，分成3组，通过-来分组的
三类：
owner 属主，缩写 ugroup 属组，缩写gother 其他，缩写o 三种权限：
r：Read 读w：Write 写x：eXecute 执行
修改权限的方法 方法1：mode法 格式：chmod who opt per file
who：u g o a（all）
opt：+ – =
per：r w x X
方法2：数字法 格式：chmod XXX file
rwx rw- r–
111 110 100
7 6 4
r：4
w：2
x：1
还有一些其他有关文件权限的，可以参考此篇博文，写的很详细：
https://www.cnblogs.com/75qiwu/p/17862092.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/486883feef2de7d03f3a171ec3ec7012/" rel="bookmark">
			python&amp;shell展示任务进度条
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		执行任务时，为了便于查看任务整体进行进度，经常使用进度条，本文就Python和shell展示进度条展开
一、python python 使用tqdm模块，如下：
from tqdm import tqdm import time num = 8 with tqdm(total=num, desc="task Processing", unit="task") as pbar: for i in range(0, 8): time.sleep(3) pbar.update(1) # 结果如下 task Processing: 62%|███████████████████████████████████████████████████████████████████▌ | 5/8 [00:15&lt;00:09, 3.00s/task] 二、shell #!/bin/bash # 定义进度条长度 bar_length=50 # 定义总任务数量 total_tasks=100 # 循环执行任务 for ((i=1; i&lt;=total_tasks; i++)) do # 执行任务 sleep 0.1 # 清空当前行 echo -en "\r" # 计算进度条长度 progress=$((i * bar_length / total_tasks)) # 打印进度条 echo -n "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/486883feef2de7d03f3a171ec3ec7012/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2b7208aa864947ca8eec3ce90b542f4/" rel="bookmark">
			【Java】JDK 17 Foreign Function &amp; Memory API 替代 JNI
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当使用Java与本地代码（如C和C++）交互时，一直以来都需要使用JNI（Java Native Interface）来进行繁琐的手动映射。然而，JDK 17引入了Foreign Function &amp; Memory API，为 Java 开发者提供了一种更简单和安全的方式来调用本地函数并操作内存。
Foreign Function &amp; Memory API 的目标是简化 Java 与本地代码的交互过程，并提供更安全的方式来处理本地代码。它允许 Java 程序直接调用本地函数，无需手动编写JNI代码。这使得在 Java 中调用本地函数和操作内存变得更加直观和易于理解。
printf 示例 首先，需要导入相关的类和接口： import jdk.incubator.foreign.CLinker; import jdk.incubator.foreign.FunctionDescriptor; import jdk.incubator.foreign.LibraryLookup; import jdk.incubator.foreign.MemoryAddress; import static jdk.incubator.foreign.MemoryAddress.NULL; 然后，加载本地库并查找要调用的函数：
LibraryLookup libc = LibraryLookup.ofDefault(); MemoryAddress printfFn = libc.lookup("printf").orElseThrow(); 接下来，定义本地函数的接口和参数：
FunctionDescriptor printfDescriptor = FunctionDescriptor.of(CLinker.C_POINTER, CLinker.C_CHAR, CLinker.C_POINTER); 然后，分配内存并将数据复制到本地内存中：
MemoryAddress formatStr = MemoryAddress.ofUtf8String("Hello, %s!\n"); MemoryAddress nameStr = MemoryAddress.ofUtf8String("World"); 接下来，调用本地函数并传递参数：
CLinker.C_POINTER.execute(printfFn, printfDescriptor, formatStr, nameStr); 最后，释放先前分配的内存：
MemoryAddress.free(formatStr); MemoryAddress.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d2b7208aa864947ca8eec3ce90b542f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bbeee87fa5cf033b9866adab0d94bf6/" rel="bookmark">
			Power BI通过ODBC连接MaxDB步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、从SAP官网下载MaxDB 7.9 - SP10 Build 04 Windows Server on x64 64bit安装包；
2、解压缩安装包，双击运行“”安装程序；
3、选择“Install”：
4、选在“SQL Connectivity”-“ODBC”：
5、保留默认选项，完成安装；
6、打开“”；
7、在“系统DSN”里点击“添加”，选择“SAP MaxDB CL_MAXDB(Unicode)”（如果数据库中有中国字段），点击“完成”：
8、输入自定义的“Data Source Name”，在“Server and Database”输入MaxDB IP地址和数据库名，点击“Connect“输入用户名和密码可以测试ODBC是否连接成功。
9、打开“Power BI Desktop“，选择”Get data“-“More”：
10、选择“Other”-“ODBC”，点击“Connect”：
11、选择刚才创建的DSN，点击“OK”：
12、稍等片刻，就可以选择需要分析的MaxDB数据了：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5d210750d8457e7b658c555763032c1/" rel="bookmark">
			【算法系列篇】递归、搜索和回溯（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言1. 两两交换链表中的节点1.1 题目要求1.2 做题思路1.3 代码实现 2. Pow(X,N)2.1 题目要求2.2 做题思路2.3 代码实现 3. 计算布尔二叉树的值3.1 题目要求3.2 做题思路3.3 代码实现 4. 求根节点到叶结点数字之和4.1 题目要求4.2 做题思路4.3 代码实现 前言 前面为大家介绍了关于递归的知识，以及使用递归解决了几个问题，那么这篇文章将带大家巩固一下关于递归的知识。
1. 两两交换链表中的节点 https://leetcode.cn/problems/swap-nodes-in-pairs/description/
1.1 题目要求 给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。
示例 1：
输入：head = [1,2,3,4] 输出：[2,1,4,3] 示例 2：
输入：head = [] 输出：[] 示例 3：
输入：head = [1] 输出：[1] 提示：
链表中节点的数目在范围 [0, 100] 内 0 &lt;= Node.val &lt;= 100 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d5d210750d8457e7b658c555763032c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d52a937cecac5bf11d3680b3a7b3fac/" rel="bookmark">
			网站项目基于SSM的152家庭财务管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、系统截图（需要演示视频可以私聊） 摘 要
现代经济快节奏发展以及不断完善升级的信息化技术，让传统数据信息的管理升级为软件存储，归纳，集中处理数据信息的管理方式。本家庭财务管理系统就是在这样的大环境下诞生，其可以帮助管理者在短时间内处理完毕庞大的数据信息，使用这种软件工具可以帮助管理人员提高事务处理效率，达到事半功倍的效果。此家庭财务管理系统利用当下成熟完善的SSM框架，使用跨平台的可开发大型商业网站的Java语言，以及最受欢迎的RDBMS应用软件之一的Mysql数据库进行程序开发.家庭财务管理系统的开发根据操作人员需要设计的界面简洁美观，在功能模块布局上跟同类型网站保持一致，程序在实现基本要求功能时，也为数据信息面临的安全问题提供了一些实用的解决方案。可以说该程序在帮助管理者高效率地处理工作事务的同时，也实现了数据信息的整体化，规范化与自动化。
关键词：家庭财务管理系统；SSM框架；Mysql；自动化
目 录 目 录 1 绪论 1.1 研究背景 1.2 目的和意义 1.3 论文结构安排 2 相关技术 2.1 SSM框架介绍 2.2 B/S结构介绍 2.3 Mysql数据库介绍 3 系统分析 3.1 系统可行性分析 3.1.1 技术可行性分析 3.1.2 经济可行性分析 3.1.3 运行可行性分析 3.2 系统性能分析 3.2.1 易用性指标 3.2.2 可扩展性指标 3.2.3 健壮性指标 3.2.4 安全性指标 3.3 系统流程分析 3.3.1 操作流程分析 3.3.2 登录流程分析 3.3.3 信息添加流程分析 3.3.4 信息删除流程分析 4 系统设计 4.1 系统概要设计 4.2 系统功能结构设计 4.3 数据库设计 4.3.1 数据库E-R图设计 4.3.2 数据库表结构设计 5 系统实现 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d52a937cecac5bf11d3680b3a7b3fac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf2a97ac7562223567568d8f69aef1ca/" rel="bookmark">
			如何理解HTML下的网页结构？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HTML（Hypertext Markup Language）是一种标记语言，用于描述网页的结构和内容。以下是对网页结构的理解以及网络爬虫在处理不同类型网页时可能遇到的情况：
1. HTML基本结构 HTML文档的基本结构通常包括以下几个部分：
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;页面标题&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 页面内容 --&gt; &lt;/body&gt; &lt;/html&gt; &lt;!DOCTYPE html&gt;：声明文档类型和版本。&lt;html&gt;：整个HTML文档的根元素。&lt;head&gt;：包含元数据，如页面标题、引用的样式表、脚本等。&lt;title&gt;：定义页面的标题，显示在浏览器标签页上。&lt;body&gt;：包含页面的主要内容。 2. HTML标签和元素 HTML文档由标签（Tags）和元素（Elements）组成。标签用于定义文档的结构，而元素是标签的实例，包含开始标签、内容和结束标签。
&lt;p&gt;This is a paragraph.&lt;/p&gt; &lt;a href="https://example.com"&gt;Visit our website&lt;/a&gt; &lt;img src="image.jpg" alt="An image"&gt; &lt;p&gt;：段落标签。&lt;a&gt;：超链接标签。&lt;img&gt;：图像标签。 3. HTML属性 HTML标签可以包含属性，用于提供附加信息或配置元素的行为。属性总是以键值对的形式出现，放在标签的开始标签中。
&lt;a href="https://example.com" target="_blank"&gt;Visit our website&lt;/a&gt; &lt;img src="image.jpg" alt="An image" width="300" height="200"&gt; href：超链接的目标地址。target：定义链接在何处打开，例如 _blank 表示在新标签页中打开。src：图像的源文件地址。alt：图像的替代文本。width 和 height：图像的宽度和高度。 4. 处理动态内容 在处理动态生成的内容时，网络爬虫可能会遇到以下情况：
AJAX和JavaScript加载的内容： 一些网页使用AJAX或JavaScript在页面加载后动态生成内容。爬虫需要分析这些脚本以获取完整的数据。
模板引擎生成的内容： 服务器端动态生成的网页可能使用模板引擎。爬虫需要了解模板结构以正确抽取信息。
5. 使用正则表达式和选择器 网络爬虫通常使用正则表达式或HTML选择器来匹配和提取感兴趣的信息。正则表达式可以用于模糊匹配或精确匹配文本模式，而HTML选择器则通过选择HTML元素的类型、类名、ID等属性来定位元素。
import re import requests from bs4 import BeautifulSoup url = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf2a97ac7562223567568d8f69aef1ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff8ad40c366af17d5ee8e2ab512aabd9/" rel="bookmark">
			《工业互联网安全与密码生成器应用案例》
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.简介 工业互联网（Industrial Internet）是指运用物联网、传感器、云计算等技术实现工业设备、生产流程、网格化能源和场所建筑自动化等信息化领域的应用系统。随着工业互联网应用的不断扩大和深入，工业互联网安全问题日益凸显。针对工业互联网的安全威胁，密码生成器是一种非常有用的工具，可以帮助工业企业保障密码安全。
随着密码攻击技术的不断更新和发展，传统的“密码+账号”认证方式已经不能满足工业互联网的安全需求。密码生成器在此时应运而生，可以为用户生成随机且高强度的密码，有效避免密码被攻击者破解的可能性。密码生成器可以通过使用特定的算法和规则生成密码，具有良好的可靠性、预测性和安全性。
在这篇博客里，我们将介绍如何使用Python编写密码生成器，以及如何将密码生成器应用到工业互联网安全领域。我们将讨论工业互联网的主要威胁和安全措施，包括物理安全、网络安全和数据安全等方面。我们还将提供工业互联网安全和密码生成器的应用案例，以帮助读者更好地理解密码生成器的作用和重要性。
2.工业互联网安全 工业互联网是指将传统工业设备、生产线以及其他相关服务、系统等连接在一起的网络，能够实现实时监控、数据分析、自动化控制等功能，提高生产效率、降低成本。然而，工业互联网也面临着许多安全威胁，其中包括以下几个方面：
2.1.1物理安全威胁： 主要是指系统设备受到破坏、盗窃、恶意损坏等物理攻击，从而导致生产停顿或信息泄露。
2.1.2网络安全威胁： 主要是指黑客攻击、病毒、木马、网络钓鱼、拒绝服务攻击等各种网络攻击方式，从而导致系统崩溃、网络瘫痪、机密数据泄露等问题。
2.1.3数据安全威胁： 主要是指敏感数据泄露、数据篡改、数据丢失等问题，从而导致生产效率下降、财务损失等。
为保护工业互联网的安全，需要采取以下安全措施：
2.2.1实施物理安全保护措施： 包括安装监控摄像头、维护门禁系统、加强设备保护等。
2.2.2加强网络安全： 包括加强网络防火墙、升级软件版本等，以防黑客攻击和各种网络安全威胁。
2.2.3制定完备的数据安全策略： 包括数据备份、数据加密等，以保护工业互联网的敏感信息不受恶意攻击。
2.2.4培训员工安全意识： 加强员工安全意识培训，让员工知道如何识别网络攻击、遵守信息安全规则，以减少工业互联网的安全风险。
2.2.5采用安全认证机制： 包括远程身份验证、数字证书等，以加强对工业互联网系统的控制和保护。
工业互联网（IIoT）是指将工业设备和生产线连接到互联网上，实现实时监控、分析和控制的技术。随着IIoT应用的普及，安全威胁也日益增多。以下是一些实际的案例，说明工业互联网面临的安全威胁：
2.3.1斯特拉斯特勒病毒攻击： 斯特拉斯特勒病毒是一种针对工业控制系统（ICS）的恶意软件，它使工业设备停止工作或者失去控制，甚至造成破坏。斯特拉斯特勒病毒首次在乌克兰的一个电网被攻击时被发现，随后在全球范围内蔓延。
2.3.2物联网设备攻击： 物联网设备的安全漏洞容易被黑客利用。例如，2016年10月，一家工业互联网设备制造商的设备被黑客攻击，攻击者利用设备的漏洞，将其作为僵尸网络的一部分，进行DDoS攻击。
2.3.3内部威胁： 由于工业互联网设备通常需要被多个用户和管理员使用，因此内部威胁也是一个重要的安全问题。例如，员工滥用权限或操纵数据可能会导致设备损坏或生产线停工。
2.3.4物理攻击： 工业控制设备通常被安装在工厂的物理环境中，可能受到自然灾害或人为因素的影响，例如：火灾、洪水、爆炸和恐怖袭击等。
总之，工业互联网的安全威胁不断增加，需要采取综合措施来保护IIoT系统的安全。企业可以采取基于人工智能和机器学习的安全策略、强化物理安全措施、加强员工安全意识和培训等方法来防止和响应安全威胁。
3.密码生成器： 密码生成器是一种工具，可以帮助用户生成强度高、难以猜测的密码。其原理是利用随机数生成器，根据一定的算法生成一串随机字符组成的密码。在密码生成过程中，可以根据设定的密码策略和要求进行筛选和调整，以生成符合要求的安全密码。
密码生成器的主要功能包括：
3.1.1.密码的生成方法： 使用随机字符生成器、密码算法和密码模板来生成密码。
3.1.2.密码质量评估： 评估生成的密码的复杂性和安全性。
3.1.3.密码策略： 设定密码的长度、特殊字符、数字、字母大小写等要求，以供生成器生成符合策略的密码。
密码生成器的密码生成方法如下：
3.2.1.随机字符生成器： 随机字符生成器是通过使用随机数生成器来产生随机性的。可用于生成数字、字母或特殊字符。
3.2.2.密码算法： 密码算法使用一套密码规则，将随机字符生成器产生的字符转换为密码。这些规则可以包括重复字符、随机字符、转换和加密等操作。
3.2.3.密码模板： 密码模板是由密码算法和密码策略组成的一系列规则。这些规则确保密码符合特定的安全标准，例如长度、复杂性和随机性。
密码质量评估指标包括：
3.3.1.安全性： 密码应该是难以猜测和破解的。
3.3.2.复杂性： 密码应该由数字、字母和特殊字符组成。
3.3.3.长度： 密码的长度应该足够长，以提高其安全性和难度。
密码策略包括：
3.4.1.密码长度： 密码的长度应该足够长，一般推荐至少8位，最好12位或更长。
3.4.2.特殊字符： 建议使用至少一个特殊字符（如@、#或!等）。
3.4.3.数字和字母大小写： 密码中应该包含数字和字母大小写，以提高其复杂性和随机性。
总的来说，密码生成器可以帮助我们生成强度高且安全性较高的密码。但是，也要注意不要将这些密码随意泄露给他人，以保证我们的账户和信息的安全。
4.Python实现密码生成器 Python可以用来编写非常强大的密码生成器，以下是一个简单的样例代码，它可以生成不同长度、不同类型（包含字母、数字和符号）的随机密码。
4.1代码如下： import random import string def generate_password(length): password = '' password += random.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ff8ad40c366af17d5ee8e2ab512aabd9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d4904843838afa2a2f3a0f21b36ee70/" rel="bookmark">
			如何让GPT类大模型成为文章编辑的高效助手
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GPT类大模型是当今人工智能技术领域中的重要里程碑之一，它们不仅在对话生成和自然语言处理领域有着广泛应用，而且在文章编辑方面也展现出了巨大的潜力。本文将介绍GPT类大模型在文章编辑上的应用，以及它们如何为用户、编辑和创作者带来便利。
本文将从以下部分进行介绍，所有功能均可在小程序RdFast智能创作机器人中无限使用。
（1）文章创作（创作生成、初稿、灵感）
（2）文章修改（润色、风格、语法、拼写、格式、语言表达）
（3）文章摘要（摘要、总结、标题、宣传语、智能评论）
（4）文章翻译（跨语言文本转换）
（5）自定义编辑功能
（6）多篇文章编辑
（7）使用方法（支持输入文章链接地址）
为了快速实现GPT文章编辑效果，下面提供了输入文章链接地址即可对文章编辑的方式。
1 文章创作 GPT可以根据输入的主题或关键词生成全新的文章内容，帮助用户创作新的稿件或补充已有的内容或提供创作灵感。这对于那些需要频繁产出大量文字内容的行业，如作者、编辑和市场营销人员来说，极大地提高了生产效率和创作速度。
示例：
输入：人工智能在医疗行业的应用
输出：如下图所示。
图1 GPT文章创作——人工智能在医疗行业的应用
2 文章修改 GPT可以根据用户提供的文章进行修改和润色，包括语法、拼写、格式等方面的优化。
（1）内容润色：GPT可以对文章进行润色和优化，使得表达更加清晰、生动，并增强文章的可读性和吸引力。
（2）段落重组：GPT可以根据用户需求重新组织文章的段落顺序，使得文章更加连贯和有条理。
（3）风格转换：GPT可以根据指定的要求调整文章的语言风格，例如正式、轻松、学术等，以适应不同的写作需求。
（4）文章重写：GPT可以根据用户提供的文章内容进行重写，改变句子结构、调整表达方式，使得文章更加流畅或符合特定需求。
（5）语法检查：GPT可以检测文章中的语法错误，并提供修正建议，帮助改善句子结构和语言表达。
（6）拼写检查：GPT还可以帮助发现并纠正文章中的拼写错误，确保文章的准确性和专业性。
输入参考示例：
（1）请对该文章的语言表达进行优化和补充，并给出相应理由。
（2）请检查该文章的语法，指出需要改动的地方。
（3）请将上文改写为风格更加正式的表述形式。
输出示例如下图所示。
图2 GPT文章优化示例
3 文章摘要 GPT可以根据输入的文章内容生成简洁的摘要，提炼出文章的核心信息，适用于摘要、总结、标题、宣传语、智能评论。
GPT技术的文章摘要功能强大而高效，能够迅速从大量文本中提炼出关键信息，生成凝练的摘要。同时，它还具备创造性地构思标题的能力，不仅能够紧扣文章主旨，还能够吸引读者的注意力。此外，GPT还能够根据内容特点设计富有创意和说服力的宣传语，助力营销和品牌推广。智能评论功能更是为社交媒体和论坛等平台提供了即时、相关且深度的互动可能。通过这些先进的功能，GPT正在改变我们处理和生成文本信息的方式，它不仅提升了工作效率，也丰富了数字内容的表现形式。
输入参考示例：
（1）请提取上文的主要内容/摘要、请对上文进行总结。
（2）请为上文设计3条宣传广告词。（适合营销、文章转发等）
（3）请为上文拟3个标题，标题需要新颖，引起读者关注。
（4）请为上文生成3条网络评论。
输出示例如下图所示。
图3 GPT文章宣传语示例
4 文章翻译 GPT技术具备强大的语言理解和生成能力，这使得它在翻译任务中也表现出色。通过大量的多语言训练数据，GPT模型能够把一种语言的文本准确地转换为另一种语言，同时尽可能保留原意和语境。GPT的翻译不仅限于单词和短语的直接对应，它能够理解整个句子甚至段落的深层含义，确保翻译的自然流畅和文化适应性。随着模型的不断优化和训练，GPT在翻译领域的应用前景广阔，有望为跨文化交流和国际合作提供更加高效和精准的语言服务。
输入参考示例：
（1）请将上文翻译成英文。
（2）请将上文翻译成中文。
输出示例如下图所示。
图4 GPT文章翻译示例
5 自定义编辑功能 根据上文描述，我们知道其使用方法主要是：文章内容+任务描述。我们可以自定义任务描述来实现自己的要求，可以多样化和精细化。例如，我们可以输入“请根据上文生成20~50字朋友圈文案以进行宣传推广”，从而实现快速转发朋友圈。
图5 GPT自定义编辑功能——生成朋友圈转发文案
6 多篇文章编辑 根据上文描述，我们知道其使用方法主要是：文章内容+任务描述。我们可以将多篇文章内容合并到一起，GPT可以同时理解并编辑。下面示例当中，不同文章地址之间用分号进行间隔。
图6 GPT多篇文章编辑
7 使用方法（支持输入文章链接地址） GPT智能文章编辑使用方法有如下两种：
（1）输入文章完整内容+任务描述。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d4904843838afa2a2f3a0f21b36ee70/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59cc838f9a3dc50ac8c05132ffc77cd7/" rel="bookmark">
			Transformer源码（带注释）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		代码来源：Transformer代码(源码Pytorch版本)从零解读(Pytorch版本）
在up主的注释下增加了一些自己的注释
在看Transformer源码前，必须要先从李宏毅/李沐那里把注意力机制/自注意力/多头注意力的原理和Transformer的架构原理先搞明白，才可以看得懂代码。
我是先把多头自注意力机制那块公式/代码手推过一遍之后，再结合up主的讲解补充了mask和position encoding，就能搞懂transformer了
如果有学不懂的欢迎评论/私信加qq交流，也当是自己巩固知识
## from https://github.com/graykode/nlp-tutorial/tree/master/5-1.Transformer import numpy as np import torch import torch.nn as nn import torch.optim as optim import matplotlib.pyplot as plt import math def make_batch(sentences): ''' 将原始文本数据预处理成神经网络可以处理的格式的典型例子 :param sentences:输入句子、输出句子和目标句子 :return:句子中单词在词汇表中的索引 ''' input_batch = [[src_vocab[n] for n in sentences[0].split()]] output_batch = [[tgt_vocab[n] for n in sentences[1].split()]] target_batch = [[tgt_vocab[n] for n in sentences[2].split()]] return torch.LongTensor(input_batch), torch.LongTensor(output_batch), torch.LongTensor(target_batch) ## 10 def get_attn_subsequent_mask(seq): """ 生成“后续掩码”，防止模型在预测序列中的元素时“偷看”到后续的元素 seq: [batch_size, tgt_len] seq序列张量的维度 批次大小*目标序列长度 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/59cc838f9a3dc50ac8c05132ffc77cd7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2fa909d36cd2c303972969c4eff68d8/" rel="bookmark">
			如何使用ArcGIS进行点抽稀（优化版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 有的时候我们手上的数据很密集（比如POI数据），全部加载出来会很挤，在我们只需要部分数据的情况下就需要对其进行抽稀，这里为大家介绍一种比较简单的抽稀方法，希望能对大家有所帮助。
按百分比抽稀 在ArcToolbox中点击“Geostatistical Analyst工具/工具/子集要素”，调用子集要素工具，如下图所示。
调用子集要素工具 在显示的子集要素对话框内，输入要素为需要抽稀POI文件，设置输出要素类，训练要素子集的大小根据实际需求填写，这里提取20%的数据出来，设置为20，子集大小单位设置为PERCENTAGE_OF_INPUT，如下图所示。
子集要素设置 点击确定可以完成抽稀，抽稀的结果如下图所示。
抽稀结果 按实际个数抽稀 除了按照百分比抽稀之外还可以按照实际个数抽稀，在子集要素对话框内，子集大小单位选择ABSOLUTE_VALUE，个数设置为2000，如下图所示。
子集要素设置
点击确定完成抽稀，抽稀结果如下图所示。
抽稀结果
结语 以上就是如何使用ArcGIS进行点抽稀的详细说明，主要包括了按百分比抽稀和按实际个数抽稀等功能。
————————————————
版权声明：本文为CSDN博主「水经注GIS」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/mrib/article/details/128392453
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec12c7890630714a364bc4ef3b5ffdfe/" rel="bookmark">
			工业互联网概念及意义
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.工业互联网概念和意义
2.工业互联网平台架构
3.国内外发展概况
4.总结
一.工业互联网概念和意义
工业互联网（Industrial Internet）是新一代信息通信技术与工业经济深度融合的新型基础设施、应用模式和工业生态，通过对人、机、物、系统等的全面连接，构建起覆盖全产业链、全价值链的全新制造和服务体系。它以网络为基础、平台为中枢、数据为要素、安全为保障，既是工业数字化、网络化、智能化转型的基础设施，也是互联网、大数据、人工智能与实体经济深度融合的应用模式，同时也是一种新业态、新产业，将重塑企业形态、供应链和产业链。
工业互联网的意义主要体现在以下几个方面：
促进工业数字化转型：工业互联网通过连接人、机、物、系统等，可以促进工业数字化转型，提高生产效率和质量。
推动产业升级：工业互联网的应用可以推动产业升级，通过数据分析和智能化决策，提高企业的竞争力和创新能力。
促进可持续发展：工业互联网的应用可以促进可持续发展，通过优化资源配置和能源利用，减少环境污染和资源浪费。
培育新业态和新产业：工业互联网的发展可以培育新业态和新产业，推动经济增长和就业增长。
总之，工业互联网是第四次工业革命的重要基石，对于推动工业数字化转型、产业升级、可持续发展以及培育新业态和新产业都具有重要意义。
二.工业互联网平台架构
工业互联网平台架构由三个核心层级构成：边缘、平台（工业PaaS）、应用。
边缘层：主要通过大范围、深层次的数据采集，以及异构数据的协议转换与边缘处理，构建工业互联网平台的数据基础。同时，依托协议转换技术实现多源异构数据的归一化和边缘集成，利用边缘计算设备实现底层数据的汇聚处理，并实现数据向云端平台的集成。
平台层：基于通用PaaS叠加大数据处理、工业数据分析、工业微服务等创新功能，构建可扩展的开放式云操作系统。
应用层：形成满足不同行业、不同场景的工业SaaS和工业APP，形成工业互联网平台的最终价值。同时，构建了良好的工业APP创新环境，使开发者基于平台数据及微服务功能实现应用创新。
此外，工业互联网平台还包括端层，指生产现场的各种物联网型工业设备，如数控机床、工业传感器、工业机器人等，它们贯穿产品全生命周期，分别起到生产、检测、监控等不同作用，以监测生产现场，灵活处理生产过程中的不同情况。
总的来说，工业互联网平台是面向制造业数字化、网络化、智能化需求，构建基于海量数据采集、汇聚、分析的服务体系，支撑制造资源泛在连接、弹性供给、高效配置的工业云平台。
三.国内外发展概况
工业互联网在国内外的发展概况如下：
国内方面：
企业数量：中国工业互联网企业数量已经超过50万家，其中大中型企业占比超过70%。这些企业主要集中在智能制造、工业物联网和工业云平台等领域，涉及制造、能源、交通等多个行业。
政策支持：中国政府积极推动工业互联网的发展，启动了国家工业互联网创新发展试点工作，一些重点项目已经实现了产业化。
应用场景：工业互联网应用场景已经涵盖了制造、物流、能源、医疗、农业等各个行业，其中大规模数字化车间、智能码头、供应链管理等场景表现突出。
国外方面：
市场规模：全球工业互联网市场预计到2025年将突破1万亿美元。
基础设施：工业互联网需要更加智能化的设备和技术，同时也需要全新的网络基础设施。国内外企业纷纷投入大量资金研发各种工业互联网应用平台和数据中心，加速了设施的配套建设。
总体来说，工业互联网在全球范围内的发展迅速，被视为第四次工业革命的重要基石。无论在国内还是国外，都在积极推动工业互联网的发展，以促进工业数字化转型和产业升级。 四.总结
工业互联网是工业数字化、网络化、智能化转型的基础设施，通过连接人、机、物、系统等全要素，实现全面互联，打造覆盖全产业链、全价值链的全新制造和服务体系。工业互联网平台作为工业互联网的核心组成部分，为各类工业应用场景提供数据采集、传输、处理、分析、建模和应用等服务，是工业互联网的核心枢纽。
工业互联网平台具有三大核心能力：数据采集能力、PaaS平台能力、应用能力。数据采集能力是工业互联网平台的基础，通过数据采集能够实现数据的全面感知和互联互通；PaaS平台能力是工业互联网平台的支撑，通过PaaS平台能够实现数据的处理、分析和建模，为各类应用提供强大的后台支撑；应用能力是工业互联网平台的最终体现，通过各类应用能够满足不同行业、不同场景的需求。
工业互联网平台的应用场景已经非常广泛，涵盖了智能制造、智慧城市、智慧交通、智慧医疗等多个领域。在智能制造领域，工业互联网平台能够实现生产过程的自动化、智能化和可视化，提高生产效率和产品质量；在智慧城市领域，工业互联网平台能够实现城市资源的全面感知和优化配置，提高城市管理和服务水平；在智慧交通领域，工业互联网平台能够实现交通信息的全面感知和共享，提高交通运行效率和交通安全水平；在智慧医疗领域，工业互联网平台能够实现医疗资源的全面感知和优化配置，提高医疗服务水平和效率。
总的来说，工业互联网已经成为全球范围内的重要发展趋势，对于推动工业数字化转型和产业升级具有重要意义。未来，随着技术的不断进步和应用场景的不断扩展，工业互联网平台将会迎来更加广阔的发展空间。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/951684872de9eef0f6f3ca7881dbcd52/" rel="bookmark">
			爬楼梯的算法面试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一个小孩爬楼梯，每次可以爬1个、2个或3个台阶，编程求出这个小孩爬完10个台阶的楼梯一共有多少种走法。 这个问题可以用递归的方法来解决。我们可以定义一个函数f (n)，表示爬n个台阶的楼梯有多少种走法。那么，f (n) = f (n-1) + f (n-2) + f (n-3)，因为每次可以爬1个、2个或3个台阶。当n为0、1、2、3时，f (n)分别为1、1、2、4。用python编程，可以写成如下的代码：
def f (n): if n == 0 or n == 1 or n == 2: return 1 elif n == 3: return 4 else: return f (n-1) + f (n-2) + f (n-3) print (f (10)) # 输出结果为274 这是一种可能的解答，你也可以尝试其他的方法，比如动态规划或者数学公式。
一个小孩爬楼梯，每次可以爬1个、2个或3个台阶，编程求出这个小孩爬完100个台阶的楼梯一共有多少种走法。 这个问题可以用不同的方法来解决，比如递归、动态规划、矩阵快速幂或者斐波那契数列公式。我可以用Python编程给你展示一些可能的解法。
方法一：递归 def f (n): if n == 0 or n == 1 or n == 2: return 1 elif n == 3: return 4 else: return f (n-1) + f (n-2) + f (n-3) print (f (100)) # 输出结果为180396380815100901214157639 这种方法的时间复杂度是O(3^n)，空间复杂度是O(n)，效率很低，因为会重复计算很多子问题。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/951684872de9eef0f6f3ca7881dbcd52/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ff3c77159c2424a1f87043714f59883/" rel="bookmark">
			DHCP与IP地址管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习重点 目录
学习重点
DHCP与IP地址管理定义
目标
DHCP基础
DHCP服务器配置与管理
DHCP客户端配置与管理
复杂网络的DHCP部署
配置DHCP故障转移
DHCP与名称解析的集成
部署IP地址管理
总结
· DHCP与IP地址管理定义 DHCP（动态主机配置协议）是一种网络管理协议，它自动为网络设备分配IP地址和其他网络配置参数。DHCP通过服务器进行IP地址的分配和管理，使得计算机和设备可以自动获取所需的网络配置信息，而无需手动配置。
DHCP的IP地址分配策略针对不同的客户端需求，提供了三种分配方式：
手工分配地址：由管理员为特定客户端（如WWW服务器等）静态绑定固定的IP地址。
自动分配地址：DHCP服务器为客户端自动分配一个IP地址，该地址只能由该客户端使用。
动态分配地址：DHCP服务器为客户端动态分配一个IP地址，当客户端不再需要使用这个IP地址时，该地址可以被其他客户端使用。
通过DHCP，网络管理员可以更高效地管理IP地址分配，减少配置错误，提高网络稳定性和安全性。
·目标 DHCP的主要目标是简化网络管理，减少手动配置的工作量，并确保网络设备能够正确地连接和通信。通过集中管理IP地址分配和配置参数，DHCP可以实现自动化的IP地址分配和配置，提高网络管理的效率。
DHCP的设计目标包括：
集中管理TCP/IP IP子网，将所有IP地址和配置参数存储在DHCP的中心数据库中。
自动为客户端分配TCP/IP IP地址、子网掩码、默认网关和DNS服务器等配置信息。
使得IP地址分配更加灵活，支持动态分配和释放IP地址，以适应网络设备的移动和变化。
提高网络安全性，通过将IP地址与MAC地址绑定，可以防止非法设备接入网络。
减少配置错误和管理工作量，自动化IP地址分配和配置过程可以减轻管理员的工作负担。
总之，DHCP与IP地址管理的目标是通过自动化和集中化管理，提高网络配置的效率和安全性，减少管理员的工作量，使得网络管理更加便捷和高效。
·DHCP基础 DHCP（Dynamic Host Configuration Protocol，动态主机配置协议）是一种网络协议，它可以帮助计算机自动获取IP地址和配置网络参数。DHCP可以用于局域网和广域网，它使用UDP协议工作，可以实现网络动态合理的分配IP地址给主机使用。
DHCP的工作原理包括四个阶段：发现阶段、提供阶段、请求阶段和确认阶段。在发现阶段，客户端发送广播包，寻找DHCP服务器；在提供阶段，DHCP服务器发送包含IP地址等配置信息的单播包给客户端；在请求阶段，客户端发送广播包，告知服务器要使用哪个IP地址；在确认阶段，服务器发送确认报文，确认IP地址的分配。
DHCP的优点包括：可以集中管理IP地址分配和配置参数，减少管理员的工作量；可以实现IP地址的自动分配和动态配置，提高网络管理的效率；可以确保网络设备能够正确地连接和通信；可以提高网络的安全性，防止非法设备接入网络。
总之，DHCP是一种重要的网络协议，可以帮助计算机自动获取IP地址和配置网络参数，提高网络管理的效率和安全性。
·DHCP服务器配置与管理 DHCP服务器的配置与管理包括以下步骤：
安装DHCP服务器：在操作系统中，可以通过添加角色来安装DHCP服务器。在安装过程中，系统会提示您选择“Active Directory域服务”和“DNS服务器”，并按照提示完成安装。
创建DHCP作用域：在DHCP服务器上，需要创建一个或多个DHCP作用域，以指定IP地址池和分配范围。可以选择手动分配IP地址、自动分配IP地址或动态分配IP地址。
配置DHCP作用域选项：在DHCP作用域中，可以配置一些选项，如租约期限、保留的IP地址、排除的IP地址等。可以根据需要进行配置。
配置DHCP客户端：为了从DHCP服务器获取IP地址和配置信息，需要配置DHCP客户端。在客户端上，需要设置IP地址、子网掩码、默认网关和DNS服务器等参数。
测试DHCP配置：可以通过ping命令或其他工具来测试DHCP配置是否正常。如果一切正常，客户端应该可以自动获取IP地址和配置信息。
管理DHCP服务器：可以对DHCP服务器进行管理，如备份和还原数据库、添加或删除作用域、监视DHCP服务器状态等。可以根据需要进行相应的管理操作。
以上是DHCP服务器配置与管理的一般步骤，具体操作可能会因操作系统和网络环境的不同而有所差异。建议在进行配置前仔细阅读相关文档或咨询专业人士。
·DHCP客户端配置与管理 DHCP客户端的配置与管理相对简单，以下是一般步骤：
获取DHCP客户端软件：首先需要获取DHCP客户端软件。在Windows操作系统中，DHCP客户端通常已经内置，不需要额外安装软件。
打开DHCP客户端：在安装了DHCP客户端的计算机上，可以打开DHCP客户端以开始配置。
配置DHCP客户端参数：在DHCP客户端中，需要设置一些参数，如IP地址、子网掩码、默认网关和DNS服务器等。可以根据需要进行设置。
连接DHCP服务器：当DHCP客户端连接到网络时，会自动尝试与DHCP服务器进行通信。如果网络中存在DHCP服务器，客户端会从服务器获取IP地址和配置信息。
测试网络连接：当DHCP客户端获取了IP地址和配置信息后，可以尝试使用ping命令或其他工具测试网络连接是否正常。如果一切正常，说明DHCP客户端已经成功配置和管理。
手动配置IP地址：如果DHCP服务器无法为客户端分配IP地址或需要特定配置时，可以手动配置IP地址。手动配置时，需要注意避免IP地址冲突或子网掩码等参数错误。
管理DHCP客户端：可以对DHCP客户端进行管理，如查看IP地址分配情况、监视网络连接状态等。可以根据需要进行相应的管理操作。
以上是DHCP客户端配置与管理的一般步骤，具体操作可能会因操作系统和网络环境的不同而有所差异。建议在进行配置前仔细阅读相关文档或咨询专业人士。
·复杂网络的DHCP部署 在复杂网络的DHCP部署中，可以采取以下步骤：
确定DHCP服务器的位置：DHCP服务器可以部署在网络的中心位置，以便为整个网络提供DHCP服务。也可以将DHCP服务器部署在各个子网中，以便更好地控制IP地址的分配。
配置DHCP服务器：在DHCP服务器上，需要创建多个作用域，每个作用域对应一个子网。可以设置每个作用域的IP地址池、租约期限、排除的IP地址等选项。
配置客户机：在客户机上，需要设置IP地址、子网掩码、默认网关和DNS服务器等参数。可以将客户机的网卡设置为和DHCP服务器网卡一样，并关闭VMware Workstation中的DHCP服务器。
测试DHCP配置：可以通过ping命令或其他工具来测试DHCP配置是否正常。如果一切正常，客户端应该可以自动获取IP地址和配置信息。
监控DHCP服务器状态：需要定期监控DHCP服务器的状态，包括CPU利用率、内存利用率、连接数等指标。如果发现异常情况，需要及时进行处理。
备份和还原DHCP服务器：需要对DHCP服务器的配置和数据进行定期备份，以防止意外情况发生。如果需要还原DHCP服务器，需要根据备份文件进行还原。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ff3c77159c2424a1f87043714f59883/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d366374620b9e487a4ca6f2510ce1b7/" rel="bookmark">
			docker build构建报错：shim error: docker-runc not installed on system
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题：
docker构建镜像时报错：shim error: docker-runc not installed on system
解决：
ln -s /usr/libexec/docker/docker-runc-current /usr/bin/docker-runc 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9d6d0fdf10d50a8f604f72f9210861d/" rel="bookmark">
			【合集】SpringBoot——Spring，SpringBoot，SpringCloud相关的博客文章合集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 本篇博客是spring相关的博客文章合集，内容涵盖Spring，SpringBoot，SpringCloud相关的知识，包括了基础的内容，比如核心容器，springMVC，Data Access；也包括Spring进阶的相关知识，SpringMVC的深入理解，自动装配原理，项目部署运维等；此外，还有springCloud相关的博客文章。
目录 前言引出Spring基础核心容器SpringMVCData AccessSpringBoot spring进阶深入理解SpringMVC深入理解面向切面AOP深入理解Spring自动装配Spring项目部署运维SpringBoot项目架构 SpringCloud合集文章 总结 引出 1.Spring，SpringBoot，SpringCloud相关的知识；
2.包括了基础的内容，比如核心容器，springMVC，Data Access；
3.Spring进阶的相关知识，SpringMVC的深入理解，自动装配原理，项目部署运维等；
4.springCloud相关的博客文章合集；
Spring基础 核心容器 Spring基础（核心容器）——从配置文件到注解开发 &amp; 创建对象+成员变量赋值IOC &amp; 增强方法AOP
SpringMVC Spring基础（Web-MVC）——在idea中新建springWeb项目 &amp; 浏览器请求 和 服务器响应 &amp; SpringMvc文件相关
Data Access Spring基础（Data Access数据库）——Spring+SpringMVC &amp; 集成mybatis &amp; 拦截器
SpringBoot SpringBoot基础——追根溯源servlet是啥，tomcat是啥，maven是啥 &amp; springBoot项目初步，maven构建，打包 &amp; 测试
spring进阶 深入理解SpringMVC SpringMvc框架——【深入】SpringMVC 的运行流程：从客户端发送请求request到springMvc框架返回响应response的全流程分析 &amp; DispatcherServlet
深入理解面向切面AOP Spring进阶（AOP的理解）——静态/动态代理 &amp; 面向切面编程AOP（Aspect Oriented Programming） &amp; 日志记录 &amp; 增强方法
Spring进阶（AOP的应用）—— 动态代理AOP后controller层的private方法访问失效的问题
深入理解Spring自动装配 @SpringBootApplication注解的理解——如何排除自动装配 &amp; 分布式情况下如何自动加载 &amp; nacos是怎么被发现的
SpringApplication.run(OrderApp.class)——拆解SpringBoot启动流程，run方法的拆解 &amp; SpringBoot是怎么跑起来的？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f9d6d0fdf10d50a8f604f72f9210861d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f824db761ac5016a5fa9efd9aa464aab/" rel="bookmark">
			【MIdjourney】几个特殊的人物动作(2)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.回旋踢/旋风踢 (spin kick) 虽然事实上回旋踢(spin kick)和旋风踢(540 kick)是两个动作，但是在画面的实际表现里差不多，而回旋踢的成图效果更好，所以我推荐使用 spin kick 这个关键词来生成图片。
关键词：woman,spin kick,taekwondo uniform ,Gymnasium,arena
当然这种幅度较大的动作在实际成图的时候绘制出奇行种也不是什么怪事。
2.JACK-O挑战 (JACK-O Pose) 鬼知道MIdjourney为什么会收录这个动作......
前两年这个动作大火过一段时间，本来这是游戏《罪恶装备》里的角色JACK-O的下蹲动作，后来被国内外画师各种二创带火过一段时间，现在MIdjourney已经能稳定生成这个动作的相关图片了...
关键词：JACK-O Pose
挑个喜欢的角色试试去。
3.跪坐 (Kneeling，tatami) 为什么这个姿势需要两个关键词？这是一个很有意思的问题。
首先要明确一点，当今世界这个姿势几乎只在日韩地区有，而我在实际测试的时候，无论是使用特有名词(Kneeling)还是详细描述动作(Knees on the ground)都没有办法生成我想要的图片，大部分结果都是盘腿坐，然而当我在关键词中添加tatami(榻榻米:一种日式地板)后很容易就生成了正确的姿势，所以该姿势只能在固定场合出现，我猜测应该还有其他关键词能达到该效果，如果有发现的欢迎在评论区补充。
关键词：Kneeling ,front view,tatami --niji 5
顺带一提如果生成图片的时候使用的是标准生成器只输入Kneeling关键词，那么生成的图片会倾向于单膝跪地的姿势：
4.盘腿坐 (sit cross-legged/Lotus Pose) 以上两个单词都能生成盘腿坐的姿势，下面说说区别。
sit cross-legged，本意是双腿交叉的坐姿，生成的图片人物身体相对放松，不过成图的精度差一些，毕竟双腿交叉的坐姿不止盘腿一种。
Lotus Pose 是从瑜伽中引申出来的一种坐姿，直译过来是观音坐莲莲花座，其生成的人物状态相对更庄重一些。
上方是用sit cross-legged生成的图片，下方是用Lotus Pose 关键词：cross-legged sit/Lotus Pose,cyberpunk
莲花座关键词生成的图片里容易真的带莲花，可以使用 --no Lotus 来去掉。
5.一字马 (split stretch exercise，the splits) 我就直说吧，不知道是受限于素材库还是生成器，总之没有办法生成标准的一字马图片，我反复尝试了各种与劈叉有关的关键词，最终结果也只能表现出大概的意思，而且必须要把长宽拉到一定比例才能生成这样的图片。
关键词：split stretch exercise，the splits --ar 16:9
可以看到即使生成了图片人物的四肢也还是会出现一定程度的扭曲，MIdjourney画直线的能力着实堪忧。
如有问题欢迎在评论区留言
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8656915a8f46da74bceb619a3edd3628/" rel="bookmark">
			typedef 与#define 的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 typedef 与#define 的区别 typedef ： 给一个已经存在的数据类型（注意：是类型不是变量）取一个别名，而非定义一个新的数据类型
#define宏定义： #define宏定义：在预编译时直接进行简单的文本替换
举例：
#define INT_P int* typedef int* int_p; INT_P a,b; int_p c,d; 宏定义在预处理时候会直接替换，所以替换为int a,b。这样b是一个int变量，而不是指针；
typedef 作用是给已存在的数据类型引入一个别名，语法 typedef 已有类型名 类型别名，所以 int_p
是int整型指针类型的别名
注意事项：
1、宏定义时若宏体表达式应该有必要的括号约束，否则很容易出错；
2、关于把空格写在类型修饰符和变量名中间，合法但容易产生误导，或者例如：
char* p1, p2; // 合法但容易产生误导，一般不这样写，容易误导，改为如下： char *p1, *p2; // 修饰符和变量标识写在一起 //或者如下写法，修饰符和类型名写在一起，每次只定义一个变量 int* p1; // int* p2; // 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04d1c29ec0874fe78a5badb2490c06d4/" rel="bookmark">
			【laBVIEW学习】4.声音播放，自定义图标，滚动条设置，保存参数以及恢复参数，工具选板（透明边框）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一。声音播放（报错，未实现）
1.报错4810
2.解决方法：
暂时未解决。
二。图片修改
1.目标：灯泡---》自定义灯泡
2.步骤：
1.右键点击--》自定义运行
表示可以制作自定义类型
2.右键--》打开自定义类型
这样就可以在出现的界面中修改类型
结果：
3.修改时需要切换至（自定义类型）。
想修改另一个状态时，需要在（编辑类型）下修改。
4.图片导入方式
5.保存地址
6.使用方法，直接拖图标过来即可
3.实例
结果：
按下点亮，在按下灭
三。滚动条设置
1.打开滚动条
经典----&gt;经典数值----&gt;水平滑动杆
2.修改滚动条
1.进入自定义类型编辑模式
2。从ppt中保存一串字符为图片
添加到控件中
3.拖动到数据中，解决
3.代码设置
结果：
四。保存参数，修改参数
1.使用的数据
2.实践：保存数据
1.保存数据
上述解释错误：
写入键，放在根目录下，名称为（打开配置数据文件夹）的路径中，断键值放在文件中
2.注意事项--&gt;注意写入键保存的类型，他需要设置
结果：
1.运行
2.结果：保存成功
3.恢复数据
结果：
补充：工具选板
注意：
1.T为透明色
2.使用后记变成箭头，否则一直是笔（即：没有退出功能）
举例：
注意：
点击这个就是只能模式，这个好用
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c43e7706a4285f23253472be354b9a35/" rel="bookmark">
			【MySQL】之死锁问题及其解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 数据库死锁问题是我们老生常谈的问题了，在我们实际开发过程中经常会遇到，为了尽量避免出现死锁，我们需要了解出现死锁的场景。同时，如果线上出现了死锁之后怎么去分析、排查和解决，下面我就这两点介绍一下。
一、数据库死锁介绍 1、什么是数据库死锁？ 数据库的死锁是指：不同的事务在获取资源时相互等待，导致无法继续执行的一种情况。当发生死锁时，数据库系统会自动中断其中一个事务，以解除死锁。在数据库中，事务可以分为读事务和写事务。读事务只需要获取读锁，而写事务需要获取写锁。当多个事务同时操作同一组数据时，可能会引发死锁的出现。
2、MySQL 发生死锁的场景 2-1、事务同时更新多个表
当一个事务同时更新多个表并且使用了不同的顺序，可能会导致死锁的发生。例如，事务 A 首先更新表 X，此时获取到了 X 表的锁，并在未释放该锁的情况下尝试更新表 Y；而事务 B 首先更新表Y，此时获取到了 Y 表的锁，并在未释放锁的情况下尝试更新表 X。这种情况下，两个事务会相互等待对方的锁释放，从而形成死锁。
2-2、事务嵌套
当一个事务内部开启了另一个事务，并在内层事务中更新了某个表，而外层事务也需要更新该表的同一行记录时，就有可能发生死锁。因为外层事务需要等待内层事务释放锁，而内层事务需要等待外层事务释放锁。
2-3、索引顺序不一致
当多个事务按照不同的顺序访问相同的数据行，并且使用了不同的索引时，可能会发生死锁。例如，事务 A 按照索引 1 的顺序访问数据行，事务 B 按照索引 2 的顺序访问同一组数据行，这样两个事务之间就会产生死锁。
2-4、不同事务同时更新相同的索引
当多个事务同时更新相同的索引时，可能会导致死锁。这是因为事务在更新索引时会获取对应的锁，并在未释放锁的情况下尝试更新其他数据，从而形成死锁。
二、解决死锁问题 如果线上发生了死锁，我们应该采取以下步骤进行处理：
1、 监控死锁 正常情况下我们都会建立死锁监控机制，以便及时掌握死锁情况；同时设置相应的预警机制，以便在死锁发生时能够及时处理。
通过数据库的监控工具或命令可以查看是否存在死锁情况，如果出现则了解死锁的具体情况，包括死锁的事务和死锁的资源。
2、终止死锁事务 根据监控结果，找到造成死锁的事务，并手动选择其中一个事务终止。可以根据事务的执行时间、影响行数、优先级等因素进行终止决策。可以通过 select * from information_schema.innodb_trx 语句查看死锁情况。
在 innodb 中，有三张表可以帮助我们更好去分析死锁信息：
information_schema.innodb_trx：事务信息表。information_schema.innodb_locks：事务锁的信息表。information_schema.innodb_lock_waits：锁等待关系表。 系统自动解除死锁：
正常情况下，当发生死锁时，MySQL 系统会自动解除死锁，至于解除哪个事务的锁，需要亏了一个代价，在解除死锁方面，会选择回滚事务产生影响最小的一个进行回滚。
这里就要提一下两个概念了，一个是事务的权重（trx_weight），另外一个是事务的调度权重（trx_schedule_weight）：
事务的权重：与回滚事务的选择有关。具体与事务 undo 版本链的长度有关，回滚的 undo 记录越多，产生的影响就会越大，MySQL 就不会选择这样的事务，倘若事务权重一样，会选择事务等待队列等待时间短的事务进行回滚。事务的调度权重：与事务获取资源的先后有关。MySQL8.0.20 之前在等待锁的事务优先级排序采取 FIFO 算法，之后采取 CATS 算法。该算法通过分配调度权限对等待的事务进行优先级排序，该权重是根据事务阻塞的事务数量计算的。例如，两个事务正在等待同一对象上的锁，那么阻塞最多事务的事务将被分配更大的调度权重，如果权重相等，则优先考虑等待时间最长的事务分配资源。 3、重试事务 终止死锁事务后，需要重新执行被终止的事务。这可能需要一些逻辑处理，例如对数据进行回滚或者重新执行一些操作。
4、分析死锁原因 通过数据库的日志和监控信息，分析死锁的原因。下面是查看死锁日志的命令语句：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c43e7706a4285f23253472be354b9a35/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23180fcf6ca6ee6fd63d29168a6eff09/" rel="bookmark">
			体系化学习运筹学基础算法的实践和总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 引言目标设计目标实践文章汇总经验总结一则预告 引言 眨眼间已经12月了，眼看着2023年马上要过完了。
女朋友最近总说，工作以后感觉时间过的好快。事实上，我也是这么认为的。年纪越大，越会担心35岁危机的降临。所以，人还是应该持续学习和进步的。具体来说，就是在工作时间之外，每年都能有一些关于自身的成长。
23年初，我给自身成长设置了一系列目标，其中之一就是体系化。这里的体系化，主要包含两项，第一项是运筹学基础算法的体系化，第二项是机器学习算法的体系化。到了年尾，应该为一年的工作做一个总结了。
本文将着重分享今年在第一项（运筹学基础算法）上的实践和总结，后续文章将再聊另外一个内容。
正文见下。
目标设计 科学体系化的方式，私以为应该是参考各种专业书的目录，然后结合自己的认知，做个性化设计。 举个例子，《运筹学》（清华大学出版社）这本书是直接从线性规划问题开始的，但是求解线性规划问题的单纯形法，对我来说已经比较复杂，不能算入门了。
下图是我今年初给自己安排的体系化学习目标。
我认为，学习过程要从简单到复杂。而最简单的运筹问题，应该是一维无约束问题，在此基础上再提升问题维度和增加不同类型的约束条件。这些内容，在我年初的体系化学习目标中被归类为非线性规划模块。现在想来，“非线性规划”这个模块的标题并不是很准确，不过也没想到更好的，就继续用这个吧。
理解了以上普适性较好的基本算法体系后，我觉得才适合来研究线性/整数规划这一类在实际业务中被广泛研究的问题和对应的求解算法。
除了非线性规划、线性规划和整数规划外，还要学习智能优化算法的主要原因，是我觉得这些算法的改进尝试中，针对迭代方向和迭代步长的设计很有艺术感，虽然缺乏严格的数学证明，但在实践中已经被证明为非常有效的手段。
目标实践 对于大部分算法，我给自己预设的目标是两周学习完，这样最终评估下来能有19周的剩余时间。
从剩余时间来说，我给自己安排的计划，算是比较宽松的。我一直觉得，工作和学习应该是为生活服务的，如果发生了冲突，那幸福的生活体验应该放在第一位。所以我从一开始就没想着给自己太大的压力，如果觉得有些累了，偷懒玩游戏、看视频，甚至只是无聊发呆，也不会有太大的负罪感。
实际也是如此——从完成度来看，我最后一篇文章是VNS，11月12号完成的，距离12月31号只剩6周，也就是说我在年中的时候荒废了13周左右的时间。
我对算法学习完成的定义是，写一篇与算法内容对应的文章，里面至少应该包含2个模块：
第一个是用自己的逻辑描述清楚算法原理。我对自己的要求是，让算法小白都能看懂内容，如果未来真的有机会教书育人，这应该是我宝贵的财富了；
第二个是自己编写代码实现算法全过程。我对自己的要求是，分别用Python和Java编程实现，以验证自己是否真的理解了算法原理，同时提升代码能力。
从实际完成度来看，每一个算法相关的文章都算是及格了。对算法原理的描述，我还是比较满意的，特别是收到小伙伴们的暖心评论和留言时，都会备受鼓舞。在代码实现方面，并没有达到预期，开始阶段一些简单的算法还能用Python和Java分别实现，到了中后期算法复杂度提升后就有些力不从心了。在认清现实后，我去掉了使用Java实现算法过程的目标。针对特别复杂的算法，甚至都不要求自己手写了。
看，我就是这么容易和自己和解。
文章汇总 本节汇总了近一年运筹学基础算法的相关文章和链接，并按照此前的目标设计进行了分类。
分类文章和链接非线性规划-黄金分割法Python和Java代码实现：黄金分割法求解一维最优化问题非线性规划-切线法Python和Java代码实现：切线法求解一维最优化问题非线性规划-坐标轮转法Python代码实现：坐标轮换法求解多维最优化问题非线性规划-梯度类算法梯度类算法原理：最速下降法、牛顿法和拟牛顿法 拟牛顿法：python代码实现非线性规划-间接法求解包含约束的最优化问题：拉格朗日乘子法和KKT条件非线规划-直接法求解包含约束的最优化问题：罚函数法线性规划-单纯形法线性规划和单纯形法-原理篇 线性规划模型-工程应用篇线性规划-整数规划求解整数规划问题的割平面法和分支定界法 稍微憋个招，聊聊为什么不能止步于会调求解器线性规划-对偶问题线性规划对偶问题：理论推导和实际应用智能优化-DE差分进化算法，依旧强势智能优化-ACO蚁群算法求包含34个国内城市的TSP，和最优解相差没那么大智能优化-ALNS着实不错的自适应大邻域搜索算法ALNS 经验总结 关于这一年来对于运筹算法的学习和感悟，总结如下：
首先，这些算法在运筹学中算是基础内容。通过对这些知识点的学习和总结，我自身受益匪浅，在一定程度上弥补了我因为非科班出身导致基础知识储备的欠缺。不过这只是一个开始，随着认知的提升，可能会发现未知的内容也越来越多，后续还有很多内容需要去慢慢探索。
其次，在学习上我是偏应用导向的。当初选择运筹学作为自己未来长期从事的行业，主要是觉得把这些算法策略应用到实际场景中能带来极大的成就感，所以我不太会执着于理论上的推导，在学习知识时，会优先选择工业实践中最常用的运筹算法，并辅以部分基础的算法原理，以知其然并知其所以然。
最后，这些知识点的串联方式是基于我目前的认知。图中的分类仅依赖于我当前体系化学习的实践路径，算不上权威，可以作为大家构建自己知识体系的参考。
一则预告 明年运筹优化领域的文章主题，偷偷预告一下，大概率是随机优化和鲁棒优化，即，模型输入存在不确定性情况下的最优决策。
具体的学习路径，我还没思考清楚——当然了，即使已经想清楚了，我也不会直接公开出来，大概率会类似于这样，等明年年底总结吧！
最后的最后，愿大家都能持之以恒地做一件件小事，慢慢努力，惊艳众人。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e5e970accd4d2d9b12518f14e02ee25/" rel="bookmark">
			HTTP深度解析：构建高效与安全网络的关键知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. HTTP基础及其组件 我首先想和大家分享的是HTTP的基础知识。HTTP，即超文本传输协议，是互联网上最常用的协议之一。它定义了浏览器和服务器之间数据交换的规则，使得网页内容可以从服务器传输到我们的浏览器上。想象一下，每当你点击一个链接或输入网址时，就是HTTP在起作用。除了这些，了解HTTP还涉及到网络模型的五个层次：应用层、运输层、网络层、链路层和物理层。每一层都有其独特的功能，共同确保数据安全、高效地在网络中传输。此外，OSI模型、浏览器、Web服务器等也都是与HTTP密切相关的组件。这些知识对于理解网站和网络应用的运作至关重要。
2. HTTP报文与标头 深入了解HTTP，我们不得不提及HTTP报文和标头的重要性。HTTP报文是在HTTP请求和响应过程中传输的数据块，它包含了请求方法（如GET或POST）、请求的URL、HTTP版本等信息。这些报文的结构非常规范，以确保浏览器和服务器之间的通信无误。更为精彩的是HTTP标头，它提供了额外的信息，如缓存策略、数据类型、内容编码等。了解这些标头对于优化网站性能和用户体验至关重要。例如，Cache-Control标头可以控制资源的缓存策略，而Content-Type则指定了资源的类型。掌握这些知识，对于任何希望深入了解网络通信的人来说都是宝贵的。
3. HTTP内容协商与认证 内容协商是HTTP协议中一个有趣且重要的概念。简单来说，它是指客户端和服务器之间就响应的最佳格式进行协商的过程。为什么这么重要呢？因为不同的用户可能需要不同格式的数据。例如，根据用户的语言偏好返回不同语言的网页，这就是内容协商的实际应用。内容协商依赖于各种HTTP标头，如Accept和Content-Type。这些标头帮助服务器了解客户端的偏好，并据此提供合适的响应。另一方面，HTTP认证则是一个安全机制，用于验证请求者的身份。它确保只有授权用户才能访问特定资源。了解这些机制对于构建安全且用户友好的Web应用至关重要。
4. HTTP缓存 HTTP缓存是一个至关重要的概念，对于提高网站加载速度和减少服务器负载具有重要意义。缓存允许浏览器存储已下载的资源，如图片、JavaScript文件等，以便在下次访问时快速加载。但是，不是所有的资源都适合缓存。这就是为什么HTTP提供了复杂的缓存控制策略，如标明资源是否可以被缓存、缓存多久等。例如，Cache-Control标头可以设置资源的最大缓存时间，而Etag标头则用于验证缓存的资源是否仍然是最新的。了解和正确应用这些缓存策略，对于提高网站性能至关重要。
5. HTTP跨域资源共享（CORS） CORS，即跨域资源共享，是一个解决Web应用中跨源HTTP请求问题的机制。在默认情况下，浏览器出于安全考虑会限制从一个源加载的脚本如何与另一个源的资源进行交互。CORS通过添加特定的HTTP标头，允许服务器声明哪些来源有权访问它的资源。例如，Access-Control-Allow-Origin标头指明了哪些源可以访问资源。了解CORS对于现代Web开发者来说非常重要，因为它不仅涉及到安全性，还直接影响到应用的功能性和可访问性。
6. HTTP Cookies与Session 在HTTP的世界里，Cookies和Session是实现状态保持的关键。由于HTTP是无状态的，这意味着服务器默认情况下不会记住用户的任何信息。Cookies和Session通过在客户端和服务器之间传递数据解决了这一问题。Cookies是小型数据片段，存储在用户的浏览器中，可用于追踪和识别用户。而Session则是在服务器端保存用户信息的机制。理解这两者的区别和使用场景，对于构建有状态的Web应用非常关键。例如，Cookies常用于持久化用户登录状态，而Session则更适合存储短期的、敏感的用户数据。
7. HTTPS与SSL/TLS 在探讨网络安全时，我们不得不提及HTTPS和SSL/TLS。HTTPS，或安全的HTTP，是HTTP的安全版本。它通过SSL/TLS协议加密HTTP请求和响应，保护数据免受中间人攻击。SSL/TLS提供了端到端的安全通信，确保只有客户端和服务器能够理解通信内容。了解HTTPS和SSL/TLS的工作原理对于任何关心Web安全的人来说都是必须的。例如，电子商务网站使用HTTPS来保护用户的信用卡信息。在这个数字化快速发展的时代，了解并实施这些安全措施是至关重要的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60a0e9dbf07862826c4761e24fd8ab90/" rel="bookmark">
			Windows文件默认打开程序注册表修改
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.修改默认的打开程序
方法一:右键-&gt;打开方式-&gt;选择指定的exe打开
搜索regedit.exe注册表 Ctrl+F搜索指定exe,打开方式注册表:
Software\Microsoft\Windows\CurrentVersion\Explorer\FileExts\.brf
二.exe位置变化后注册表修改
系统存放了exe和文件路径的映射关系,所以需要修改注册表:
Software\Classes\Applications\openBrf.exe\shell\open\command
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9646e9f3c56018fbfe8dc31ac8669e9/" rel="bookmark">
			运算符的介绍（java版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java的运算符（也称为操作符）的写法和功能与C语言基本一致，本文章介绍java的运算符
java的运算符包括：算术运算符、关系运算符、逻辑运算符、位运算符和其他运算符
1.算术运算符
算术运算符包括一元运算符、二元运算符、算术赋值运算符
1.1一元运算符
一元运算符有：-、++、--
一元运算符的名称作用和例子在表格中显示
运算符名称功能例子-取反符号取反运算a=-a++自加1先用后加，先加后用a++,++a--自减1先用后减，先减后用a--,--a 取反符号是把变量等的符号位取反。
先用后加意思是我最先用它，最后再加1。先加后用意思是我最先加1，最后再用它。
先用后减，先减后用和上一句话同理。先用后减意思是我最先用它，最后再减1。先减后用意思是我最先减1，最后再用它。
因为++和--的运算符优先级很高仅次于引用号(.)和中小括号，所以不用担心因为优先级的原因而等不到想要的结果。文章最后面会介绍运算符的优先级顺序，本作者会把列表列出来。
1.2二元运算符
二元运算符：+、-、*、/、%
二元运算符的名称作用和例子在表格中显示
运算符名称功能例子+加用于求a+b的和，还可以用于String类型，进行字符串的连接操作a=a+b-减用于求a-b的差a=a-b*乘用于求a*b的积a=a*b/除用于求a/b的商a=a/b%求余 用于求a/b的余数
a=a%b 上面的加减乘除相当于数学的四则运算，'+'有点儿特殊，它可以用于字符串之间的连接。这种运算符在大多数编程中都可以用于字符串的连接，比如像C语言比较特殊。C语言是要先引用&lt;string.h&gt;头文件，再使用strcat函数把两者的字符串连接起来。而且strcpy函数只能一次性连接两个字符串。C语言的 '+' 运算符只能用于求和，不能用于字符串连接。
求余运算符是求a/b的余数
例子：10%3 &lt;==&gt; 10/3 ····· 余1
求余的值就是1.
1.3算术赋值运算符
算术运算符：+=、-=、*=、/=、%=
算术运算符的名称作用和例子在表格中显示
运算符名称功能例子+=加赋值相当于a=a+ba+=b-=减赋值相当于a=a-ba-=b*=乘赋值相当于a=a*ba*=b/=除赋值相当于a=a/ba/=b%=取余赋值相当于a=a%ba%=b 算术运算符只是一种简写，一般用于变量自身的变化。
2.关系运算符
关系运算符：==、!=、&gt;、&lt;、&gt;=、&lt;=、
关系运算符的名称作用和例子在表格中显示
运算符名称功能例子==等于a等于b时返回true，否则返回false。可以用于基本数据类型和引用数据类型a==b!=不等于a不等于b时返回true，否则返回false。只能用于基本数据类型a!=b&gt;大于a大于时返回true，否则返回false。只能用于基本数据类型a&gt;b&lt;小于a小于b时返回true，否则返回false。只能用于基本数据类型a&lt;b&gt;=大于等于a大于等于b时返回true，否则返回false。只能用于基本数据类型a&gt;=b&lt;=小于等于a小于等于b时返回true，否则返回false。只能用于基本数据类型a&lt;=b 3.逻辑运算符
逻辑运算符：!、&amp;、|、&amp;&amp;、||
逻辑运算符的名称作用和例子在表格中显示
运算符名称功能例子!逻辑非a为true时，为false；a为false时，为true!a&amp;逻辑与ab都为true，结果true，否则falsea&amp;b|逻辑或ab都为false，结果false，否则truea|b&amp;&amp;短路与ab都为true，结果true，否则都为false.&amp;&amp;和&amp;的区别：如果a为false，不计算ba&amp;&amp;b||短路或ab都为false，结果false，否则都为true.||和|的区别：如果a为true，不计算ba||b 短路与（&amp;&amp;）和短路或（||）能够采用最优化的计算方式，是因为短路与（&amp;&amp;）如果a为false，不计算b和短路或（||）如果a为true，不计算b。减少一些没有必要的计算，从而更快的效率。在实际生产中尽量使用一些像短路与（&amp;&amp;）和短路或（||）的运算符等方法，提高效率，减少一些多余的成本。
4.位运算符
位运算符：~、&amp;、|、^、&gt;&gt;、&lt;&lt;、&gt;&gt;&gt;、&amp;=、|=、^=、&lt;&lt;=、&gt;&gt;=、&gt;&gt;&gt;=
位运算符的名称作用和例子在表格中显示
运算符名称功能例子~位反将x的值按为取反~x&amp;位与x与y进行位与运算x&amp;y|位或x与y进行位或运算x|y^位异或x与y进行位异或运算x^y&gt;&gt;有符号右移x右移y位，高位用符号位补位x&gt;&gt;y&lt;&lt;左移x左移y位，低位用0补位x&lt;&lt;y&gt;&gt;&gt;无符号右移x右移y位，高位用0补位x&gt;&gt;&gt;y&amp;=位与等于相当于x=x&amp;yx&amp;=y|=位或等于相当于x=x|yx|=y^=位异或等于相当于x=x^yx^=y&lt;&lt;=左移等于相当于x=x&lt;&lt;yx&lt;&lt;=y&gt;&gt;= 有符号右移等于相当于x=x&gt;&gt;yx&gt;&gt;=y&gt;&gt;&gt;=无符号右移等于相当于x=x&gt;&gt;&gt;=yx&gt;&gt;&gt;=y 注意：无符号右移（&gt;&gt;&gt;）运算符只能用在int类型和long类型，如果用于byte和short这两个类型，则数据位移前，先转换为int类型再进行位移计算。
5.其他运算符
其他运算符的名称作用和例子在表格中显示
运算符名称功能例子? :三元运算符（也称三目操作符）三元运算符的格式如下：表达式1?表达式2:表达式3。如果满足表达式1运行表达式2否则运行表达式3max=(x&gt;y)?x:y()小括号 起到改变表达式运算顺序的作用，它的优先级最高
[]中括号是数组的下标arr[10]引用号(.)引用号对象调用实例变量或实例方法的操作符，也是类调用静态变量或静态方法的操作符=赋值给x赋值x=10;instanceof判断某个对象是否属于某个类new对象内存分配运算符-&gt;箭头java8新增加的，用于声明Lambda表达式::双冒号java8新增加的，用于Lanmbda表达式中方法的引用 6、运算符优先级
运算符的优先级如下：
优先级运算符1引用号（.）、中括号 、小括号2 ++、--、-（取反）、~（位反）、!（逻辑非）、类型转换小括号
3*、/、%4+、-5&lt;&lt;、&gt;&gt;&gt;、&gt;&gt;6&lt;、&gt;、&lt;=、&gt;=、instanceof7==、!=8&amp;（逻辑与和位与）9^（位异或）10|（逻辑或、位或）11&amp;&amp;12||13?:14-&gt;15=、*=、/=、%=、+=、-=、&lt;&lt;=、&gt;&gt;=、&gt;&gt;&gt;=、&amp;=、^=、|= 运算符优先级的总结：从高到底是算术运算符&gt;位运算符&gt;关系运算符&gt;逻辑运算符&gt;赋值运算符
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05b2f9fcb729ea97bc77fcdf5abb5553/" rel="bookmark">
			Spring Cloud Gateway &#43; Nacos &#43; LoadBalancer实现企业级网关
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. Spring Cloud Gateway 整合Nacos、LoadBalancer 实现企业级网关 前置工作：
创建 SpringBoot 多模块项目创建网关（gateway-service）、用户（user-service）模块用户模块添加 Nacos discovery 支持以及 Spring Web，并配置 Nacos 连接信息 准备用户模块的 controller ：
@RestController @RequestMapping("/user") public class UserController { @Autowired // 获取动态端口 private ServletWebServerApplicationContext context; @RequestMapping("/getname") public String getName() { return context.getWebServer().getPort() + "--UserService：name=java-"+ new Random().nextInt(100); } } 【实现步骤】
1. 添加依赖
Gateway、Nacos、LoadBalancer 2. 设置路由
配置 Gateway 路由规则：（id、uri、predicates）设置 Nacos 注册中心地址 1.1 添加依赖 此处的依赖添加在 gateway-service 子模块中：
&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05b2f9fcb729ea97bc77fcdf5abb5553/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b573ce519ab251e5edbebcf1f5636126/" rel="bookmark">
			Unity 3D子弹发射制作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.导入一个枪的模型,调整好枪的位置
2.点击ScifiRifle(枪)右键创建一个Crete Empty（空的物体）命名fireponint代表子弹生成的位置
3. 制作一个简易的子弹，右键3D object→spher这里我们选用spher将其命名为bulletpoint放到合适的位置
4.编写子弹发射脚本 点击Add Component→Guncontral在Assets右键Create→C# Script
5脚本内容 using System.Collections;
using System.Collections.Generic;
using UnityEngine;
public class guncontral : MonoBehaviour
{
//子弹生成位置
public Transform bulletpoint;
//子弹物体
public GameObject bulletper;
//子弹个数
private int bulletCount = 10;
//开火间隔
private float cd = 0.2f;
//开火实际的时间 计时器
private float timer=0;
private AudioSource gunvoice;
public AudioClip clip;
public Text bulletcount;
// Start is called before the first frame update
void Start()
{
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b573ce519ab251e5edbebcf1f5636126/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0743181f00fcdf597479b7918a04092/" rel="bookmark">
			unity 3D如何使用c#代码实现发射子弹
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.先创建基本场景、枪、子弹。
2.点击右上角GaneObject选择3D Object创建一些物体。
3.搭建一个场景，也可以去下载现成的模型。
4.创建一个胶囊体当人物，下载一把枪的模型
5.调整好枪的角度和位置，再在游戏画面中添加准心
触发射击后，我们会在指定位置实例化子弹的实体，并使之向固定方向移动。
首先我们创建子弹实体的预制件，记得要添加rigidbody组件。
6.再创建c# 代码
public class guncontral : MonoBehaviour { //枪口火焰生成位置 public Transform firepoint; //枪口火焰物体 public GameObject fireper; //子弹生成位置 public Transform bulletpoint; //子弹物体 public GameObject bulletper; //子弹个数 private int bulletCount=10; // 开火间隔 private float cd = 0.2f; //实际开火的时间 计时器 private float timer=0; private AudioSource gunvoice; public AudioClip clip; public Text bulletcount; // Start is called before the first frame update void Start() { gunvoice = GetComponent&lt;AudioSource&gt;(); } // Update is called once per frame void Update() { //计算实际开火间隔 timer = timer + Time.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b0743181f00fcdf597479b7918a04092/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e61a2cc78fce78b00d95a0dc263bf706/" rel="bookmark">
			Gradle问题解决 Unable to make field private final java.lang.String java.io.File.path accessible: module
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下载最新的 Android Studio（2023.12）
版本如下
运行后错误如下
Unable to make field private final java.lang.String java.io.File.path accessible: module java.base does not "opens java.io" to unnamed module @1130dfcd 百度google一圈发现没有什么线索，然后咨询gpt4得结果如下：
如果您在 Android Studio 中打开一个 GitHub 上的项目并遇到了“Unable to make field private
final java.lang.String java.io.File.path
accessible”这样的错误信息，这通常是因为您的项目中有代码尝试通过反射来访问 java.io.File 类的私有字段
path，但这在 Java 模块系统中是不被允许的。
您可以尝试以下步骤来解决此问题：
更新 Android Studio 和 Gradle: 确保您的 Android Studio 和 Gradle 插件是最新版本，因为最新版本的工具通常会更好地与 Java 模块系统兼容。
检查第三方库: 如果您的项目中使用了第三方库，确保它们都是最新版本。有时候，库的旧版本可能不兼容最新的 Java 平台更改。
Gradle 配置: 检查项目的 build.gradle 文件中是否有任何不兼容的配置或者插件，它可能导致了您的问题。尝试更新到最新的配置，并按照官方文档进行设置。
项目的 JDK 版本: 检查 Android Studio 使用的 JDK 版本是否与项目兼容。通常，Android 项目应该使用 Google 提供的 Android Studio 内置 JDK。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e61a2cc78fce78b00d95a0dc263bf706/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc99ee95d28fe4d965e1a2ee62de9431/" rel="bookmark">
			Linux——缓冲区与实现C库的fopen，fwrite，fclose
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一.缓冲区
1缓冲区的概念
2.缓冲区存在的意义
3.缓冲区刷新策略 4.什么是刷新？
C语言的缓冲区在哪里？
​编辑
仿写C库里的fopen，fclose，fwrite。
mystdio.h
mystdio.c
main.c(向文件中写入20次msg)
一.缓冲区 1缓冲区的概念 缓冲区的本质就是一段内存
2.缓冲区存在的意义 提高使用者的效率
同时因为缓冲区的存在也提高了操作系统的效率
举例一个例子：
假如你在云南要给你北京的朋友寄东西。方法一：你可以亲自己去北京把东西交给他，方法二：把东西给快递站，让它帮你送给他。
这里虽然整个事件持续的事件基本一样，但是对于你来说方法二比方法一效率要高的多，因为你只需要把东西交给快递站，对于你来说就结束了，接下来就可以做其他事情了。而快递站，也会根据你的需求以及自身制定发送快递的策略，不会收到一个快递就发送。
这里：你就是正在执行的进程，快递站是缓冲区。朋友就是文件，快递发送策略：缓冲区刷新策略
3.缓冲区刷新策略 1，无缓冲（立即刷新）--fflush()
2，行缓存（行刷新）--遇到换行就刷新
一般对于显示器文件，采用行刷新
3，全缓冲（缓冲区满了，再刷新）
磁盘文件采用全缓冲
特殊情况：
1.强制刷新
2.进程退出时，一般要进行刷新缓冲区（属于强制刷新的一种特殊情况）
一个例子：（同一份代码不同结果）
#include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;unistd.h&gt; int main() { fprintf(stdout, "C: hello fprintf\n"); printf("C: hello printf\n"); fputs("C: hello fputs\n", stdout); const char *str = "system call: hello write\n"; write(1, str, strlen(str)); fork(); // 注意fork的位置！ return 0; } 可以看出，当重定向到log.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc99ee95d28fe4d965e1a2ee62de9431/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88e689eafbbf73b9c2955603b2091d11/" rel="bookmark">
			vite脚手架，配置动态生成路由,添加不同的layout以及meta配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实现效果，配置了layout和对应的路由的meta 我想每个模块添加对应的layout，下边演示一层layout及对应的路由 约束规则：
每个模块下，添加对应的 layout.vue 文件
每个文件夹下的 index.vue 是要渲染的页面路由
每个渲染的页面路由对应的 page.json 是要配置的路由的meta
以下demo目录结构，页面放到了pages下，如果你是在其它文件夹名字，请自己修改
以上路径会生成如下结构
[ { "path": "/admin", "meta": { "title": "管理系统", "isAuth": true }, "children": [ { "path": "/admin/about", "meta": { "title": "关于我们", "isAuth": true } }, { "path": "/admin/home", "meta": {} } ], "redirect": "/admin/home" }, { "path": "/crm", "meta": {}, "children": [ { "path": "/crm/dust", "meta": {} } ], "redirect": "/crm/dust" } ] 直接上代码了，多级有需要的自己递归下 router/index.ts import { createRouter, createWebHistory, type RouteRecordRaw } from 'vue-router'; // page module const pagesModule = import.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/88e689eafbbf73b9c2955603b2091d11/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb319b0629d1557002234495e32ac57c/" rel="bookmark">
			nextTick源码解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		nextTick()的解释： 前情提要：在vue中修改状态时，DOM更新不是同步的。vue会把所有数据变更缓存到一个队列中，到下一次触发时间的时候才执行。
好处是：可以讲多次数据更新合并成一次，减少DOM的更新次数，提高性能。
nextTick()：
接受一个回调函数，这个回调函数在数据修改之后立即使用。可以确保传入的回调函数会在数据更新完成之后执行。
nextTick()的源码分析： 实现原理： nextTick中维护了一个回调函数队列，一个pending，一个timeFunc()。
pendin的作用：用来标识同一个时间只执行一次。
timeFunc的作用： 选择当前环境优先支持的异步方法，多次调用nextTick函数中，timeFunc只会执行一次。
步骤： （1）将回调函数放入回调函数队列中等待
（2）如果是第一次使用nextTick函数，会使用timeFunc判断一下当前环境中支持的异步方式。
（3）将执行任务放入微任务或者任务中。事件循环到任务时，依次执行回调函数队列中的函数。
// 标记 nextTick 最终是否以微任务执行 export let isUsingMicroTask = false // 回调函数队列，保存使用 nextTick 时传入的回调函数 const callbacks = [] // 用来标记任务队列中是否含有任务，如果有，就执行timeFunc函数； let pending = false // 声明 nextTick 函数，接收一个回调函数和一个执行上下文作为参数 // 回调的 this 自动绑定到调用它的实例上 export function nextTick(cb?: Function, ctx?: Object) { let _resolve // 将传入的回调函数存放到数组中，后面会遍历执行其中的回调 callbacks.push(() =&gt; { if (cb) { try { cb.call(ctx) } catch (e) { // 进行统一的错误处理 handleError(e, ctx, 'nextTick') } } else if (_resolve) { _resolve(ctx) } }) // timeFunc 函数选择当前环境优先支持的异步方法 if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb319b0629d1557002234495e32ac57c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2924f4d5e8db940911c22cf38258fc6e/" rel="bookmark">
			ssh免密登录及scp/rsync免密传输文件的方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在通过ssh登录其它电脑或通过scp/rsync同其它电脑之间传输文件时，每次都需要输入密码，如下图所示：在windows10上通过ssh登录虚拟机，每次登录都需要输入密码；若端口默认为22,可省略通过-p指定
可通过将本机上的公钥key存放到要访问电脑的~/.ssh/authorized_keys文件解决ssh免密登录及scp/rsync免密传输文件的问题：此方法适用于linux与linux、windows到linux、及linux本机执行scp/rsync的操作；Mac与Mac间应该也是可以的，未验证
1.通过ssh-keygen产生公私钥：执行：ssh-keygen -t rsa ,如下图所示：连续3次回车，默认生成的文件存放到~/.ssh目录下，也可指定存放到其它目录；密码为空
执行完ssh-keygen后，会在~/.ssh目录下生成id_rsa和id_rsa.pub两个文件，其中id_rsa为私钥，id_rsa.pub为公钥，需要将公钥内容存放到要操作的电脑的~/.ssh/authorized_keys文件中；其实通过ssh方式从GitHub、GitLab、Gitee、Gerrit上clone代码时，也是需要将此公钥文上传
2.将id_rsa.pub文件内容拷贝到~/.ssh/authorized_keys：可以有两种方式：cat或sh-copy-id
(1).通过cat: 首先将id_rsa.pub拷贝到其它电脑上，然后cat,如下图所示：如果~/.ssh目录下没有authorized_keys文件，则会生成一个新authorized_keys文件
(2).通过sh-copy-id：如下图所示，authorized_keys文件可存放多个公钥，此时~/.ssh/authorized_keys 文件中存放着两个公钥
ssh-copy-id -i ~/.ssh/id_rsa.pub spring@127.0.0.1 3.验证是否生效：
(1).windows10通过ssh登录ubuntu虚拟机：可见通过ssh登录不再需要输入密码
(2).linux本机执行scp/rsync：此操作过程同不同linux电脑之间完全一致，可见通过scp/rsync传输文件不再需要输入密码
scp -r /home/spring/GitHub/src/* spring@10.0.2.15:/home/spring/GitHub/dst/ rsync -rav -e ssh --exclude="*.txt" /home/spring/GitHub/src/ spring@10.0.2.15:/home/spring/GitHub/dst/ 4.若不生效，检查文件权限：
(1).~/.ssh目录权限需要为700
(2).~/.ssh/authorized_keys文件权限需要为600
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/034982d30f820831e5470409bc223409/" rel="bookmark">
			Redis多场景应用案例分析和代码实现（SpringBoot环境）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言一、使用Redis实现文章阅读量、收藏、点赞数量记录功能二、使用 Redis 实现生成分布式全局唯一ID三、使用 Redis 实现分布式锁，解决分布式锁原子性、死锁、误删、可重入、自动续期等问题四、使用 Redis BitMap 实现签到与查询历史签到以及签到统计功能五、使用 Redis Zset 有序集合实现排行榜功能六、SpringBoot 环境使用 Redis + AOP + 自定义注解实现接口幂等性七、使用 Redis GEO 获取两个坐标的直线距离、以及给定坐标获取半径不超过指定距离的元素八、使用 Redis Set 集合模拟微信朋友圈只有共同好友才能看见点赞和评论功能 前言 在日常开发中除了关系型数据库，使用最多的中间件就是Redis，本文针对Redis做多场景应用案例分析和代码实现。
需要Redis部署集成资料可以查看：
Redis常用命令集：https://blog.csdn.net/weixin_44606481/article/details/133672258
Linux安装Redis：https://blog.csdn.net/weixin_44606481/article/details/133983010
使用Docker部署Redis ：https://blog.csdn.net/weixin_44606481/article/details/133649705
SpringBoot集成Lettuce客户端操作Redis：https://blog.csdn.net/weixin_44606481/article/details/133907103
一、使用Redis实现文章阅读量、收藏、点赞数量记录功能 https://blog.csdn.net/weixin_44606481/article/details/134284550
二、使用 Redis 实现生成分布式全局唯一ID https://blog.csdn.net/weixin_44606481/article/details/134312515
三、使用 Redis 实现分布式锁，解决分布式锁原子性、死锁、误删、可重入、自动续期等问题 https://blog.csdn.net/weixin_44606481/article/details/134373900
四、使用 Redis BitMap 实现签到与查询历史签到以及签到统计功能 https://blog.csdn.net/weixin_44606481/article/details/134446032
五、使用 Redis Zset 有序集合实现排行榜功能 https://blog.csdn.net/weixin_44606481/article/details/134468751
六、SpringBoot 环境使用 Redis + AOP + 自定义注解实现接口幂等性 https://blog.csdn.net/weixin_44606481/article/details/134468637
七、使用 Redis GEO 获取两个坐标的直线距离、以及给定坐标获取半径不超过指定距离的元素 https://blog.csdn.net/weixin_44606481/article/details/134373951
八、使用 Redis Set 集合模拟微信朋友圈只有共同好友才能看见点赞和评论功能 https://blog.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/034982d30f820831e5470409bc223409/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/828db2d078cb7872b5499ffeff792dc3/" rel="bookmark">
			Java JVM类加载机制原理剖析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言一、什么是类加载二、类加载子系统三、类的加载过程2.1、加载2.2、验证2.3、准备2.4、解析2.5、初始化 四、类加载器(ClassLoader) 前言 Java类要加载到JVM中的，会经过一系列的加载过程，这个过程就是在类加载子系统中实现的，当我们用Java命令运行某个类的main函数启动程序时，首先需要通过类加载器把主类加载到JVM中，本文会对这个加载过程以及双亲委派机制做剖析。
一、什么是类加载 类加载其实是在硬盘上查找通过io读入字节码文件（class文件）并加载到JVM方法区/元空间中作为一个元数据模板，可以根据这个模板实例化出N个一模一样的实例对象，一个类只会被加载一次，并且是第一次使用时动态加载的。
加载.calss文件的方式： 从本地系统直接加载通过网络下载.class从zip、jar、war等归档文件中加载.class 二、类加载子系统 类加载器子系统负责从文件系统或者网络中加载Class文件，class文件在文件开头有特定的文件标识。
加载阶段只负责class文件的加载，至于它是否可以运行，则由字节码执行引擎决定。
加载的类信息存放于一块称为方法区/元空间的内存空间。除了类的信息外，方法区/元空间中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是Class文件中常量池部分的内存映射），不同版本JDK也有各自的区别。
三、类的加载过程 当JVM需要用到某个类时，虚拟机会加载它的.class文件，加载了相关的字节码信息后，会为它创建对应的Class对象，而这个过程就被称为类加载。但需额外注意的是：类加载机制只负责class文件的加载，至于是否可以执行，则是由执行引擎决定。
类的生命周期包括 加载 &gt;&gt; 验证 &gt;&gt; 准备 &gt;&gt; 解析 &gt;&gt; 初始化 &gt;&gt; 使用 &gt;&gt; 卸载这7个阶段，其中类加载过程为加载 &gt;&gt; 验证 &gt;&gt; 准备 &gt;&gt; 解析 &gt;&gt; 初始化。
2.1、加载 加载阶段是由类加载器进行的，加载.class文件的方式有：
从本地系统中直接加载
通过网络获取
从zip压缩包中读取，比如：jar、war格式的文件
运行时计算生成，如：动态代理技术
加载过程完成以下三件事： 1、通过类的完全限定名称获取定义该类的二进制字节流。2、将该字节流表示的静态存储结构转换为方法区的运行时存储结构。3、在内存中生成一个代表该类的 Class 对象，作为方法区/元空间中该类各种数据的访问入口。 2.2、验证 JVM 会在该阶段对二进制字节流进行校验，只有符合 JVM 字节码规范的才能被 JVM 正确执行。该阶段是保证 JVM 安全的重要屏障，下面是一些主要的检查。
确保二进制字节流格式符合预期（比如说是否以 cafe bene 开头）。是否所有方法都遵守访问控制关键字的限定。方法调用的参数个数和类型是否正确。确保变量在使用之前被正确初始化了。检查变量是否被赋予恰当类型的值。 2.3、准备 JVM 会在该阶段对类变量（也称为静态变量，static 关键字修饰的）分配内存并初始化（对应数据类型的默认初始值，如 0、0L、null、false 等），此时不会分配实例变量的内存，因为实例变量是在实例化对象时一起创建在Java 堆中的。从概念上讲，类变量所使用的内存都应当在 方法区/元空间 中进行分配。不过有一点需要注意的是：JDK 7 之前，HotSpot 使用永久代来实现方法区的时候，实现是完全符合这种逻辑概念的。 而在 JDK 7 及之后，HotSpot 已经把原本放在永久代的字符串常量池、静态变量等移动到堆中，这个时候类变量则会随着 class 对象一起存放在 Java 堆中。这里所设置的初始值"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/828db2d078cb7872b5499ffeff792dc3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ab4c93dcea6e5b0a23b08e536f2973f/" rel="bookmark">
			Java 类加载器和双亲委派机制原理剖析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、类加载器(ClassLoader)二、四种类加载器之间的关系三、双亲委派机制3.1、为什么要设计双亲委派机制3.2、类加载器loadClass(String name) 源码解析3.3、打破双亲委派机制 一、类加载器(ClassLoader) JVM的类加载机制是按需加载的模式运行的，也就是代表着：所有类并不会在程序启动时全部加载，而是当需要用到某个类发现它未加载时，才会去触发加载的过程。
引导/启动类加载器: Bootstrap ClassLoader，负责加载存放在jdk\jre\lib(jdk代表jdk的安装目录，下同)下，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库(如rt.jar，所有的java.*开头的类，比如java.lang.Integer均被Bootstrap ClassLoader加载)。启动类加载器是无法被Java程序直接引用的。
注意：因为JVM是通过全限定名加载类库的，所以，如果你的文件名不被虚拟机识别，就算你把jar包丢入到lib目录下，引导类加载器也并不会加载它。出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类文件。
扩展类加载器: Extension ClassLoader，该加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载JDK\jre\lib\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库(如javax.*开头的类)，开发者可以直接使用扩展类加载器。
这个类加载器是由sun公司实现的，位于HotSpot源码目录中的sun.misc.Launcher$ExtClassLoader位置。它主要负责加载&lt;JAVA_HOME&gt;\lib\ext目录下或者由系统变量-Djava.ext.dir指定位路径中的类库。它可以直接被开发者使用。
系统/应用程序类加载器: Application ClassLoader，也被称为应用程序类加载器，也是由sun公司实现的，位于HotSpot源码目录中的sun.misc.Launcher$AppClassLoader位置。它负责加载系统类路径java -classpath或-D java.class.path指定路径下的类库，也就是经常用到的classpath路径。应用程序类加载器也可以直接被开发者使用。
一般情况下，该类加载器是程序的默认类加载器，我们可以通过ClassLoader.getSystemClassLoader()方法可以直接获取到它。
自定义类加载器: Application ClassLoader，也被称为应用程序类加载器，也是由sun公司实现的，位于HotSpot源码目录中的sun.misc.Launcher$AppClassLoader位置。它负责加载系统类路径java -classpath或-D java.class.path指定路径下的类库，也就是经常用到的classpath路径。应用程序类加载器也可以直接被开发者使用。
二、四种类加载器之间的关系 如上分析的类加载器关系链如下：
Bootstrap引导类加载器 → Extension拓展类加载器 → Application系统类加载器 → User自定义类加载器
Bootstrap类加载器是在JVM启动时初始化的，它会负责加载ExtClassLoader，并将其父加载器设置为BootstrapClassLoader。BootstrapClassLoader加载完ExtClassLoader后会接着加载AppClassLoader系统类加载器，并将其父加载器设置为ExtClassLoader拓展类加载器。而自己定义的类加载器会由系统类加载器加载，加载完成后，AppClassLoader会成为它们的父加载器。
要注意的是：类加载器之间并不存在相互继承或包含关系，从上至下仅存在父加载器的层级引用关系。
例：
// 继承ClassLoader类，JDKClassLoaderDemo 相当于一个自定义类加载器 public class JDKClassLoaderDemo extends ClassLoader{ public static void main(String[] args) { JDKClassLoaderDemo classLoader = new JDKClassLoaderDemo(); System.out.println("自定义加载器：" + classLoader); System.out.println("自定义加载器的父类加载器：" + classLoader.getParent()); System.out.println("Java程序系统默认的加载器：" + ClassLoader.getSystemClassLoader()); System.out.println("系统类加载器的父加载器：" + ClassLoader.getSystemClassLoader().getParent()); System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ab4c93dcea6e5b0a23b08e536f2973f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de39c52e50a180cad38e6c4ac527b6a8/" rel="bookmark">
			【MySQL】之联合索引与最左匹配原则
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： 最左匹配原则在我们 MySQL 开发过程中和面试过程中经常遇到，为了加深印象和理解，我在这里把 MySQL 的最左匹配原则详细的讲解一下，包括它的原理以及是否导致索引失效的场景。
在讲解 MySQL 的最左匹配原则之前，我们需要了解一下 MySQL 的联合索引（也称复合索引），因为最左匹配原则是在联合索引的基础上产生的，没有联合索引就没有最左匹配原则这个概念。
一、联合索引 1、什么是联合索引 我们知道，单值索引指的是只使用一个字段作为索引字段的索引，而联合索引则是使用多个字段来共同构建成一个索引：
KEY idx_abc (a, b, c); 2、为什么要使用联合索引 2-1、减少开销 建一个联合索引 (a, b, c)，实际上相当于建了 (a)、(a, b)、(a, b, c) 三个索引。这样我们就不需要创建 (a)、(b)、(c) 三个单值索引了。我们知道，每多一个索引，都会增加数据库写操作的开销和磁盘空间的开销，对于大量数据的表，使用联合索引会大大的减少开销！
2-2、覆盖索引 对联合索引 (a, b, c)，如果有如下的 SQL：select a, b, c from test where a=1 and b=2。那么 MySQL 可以直接通过遍历索引取得数据，而无需回表，从而减少了很多的随机 IO 操作。而减少 IO 操作，而减少随机 IO 是 DBA 主要的优化策略，在真正的实际应用中，覆盖索引是主要的提升性能的优化手段之一。
2-3、提高效率 联合索引的字段越多，通过索引筛选出的数据越少。假如有 1000W 条数据的表，有如下 sql: select * from table where a=1 and b=2 and c=3，假设每个条件可以筛选出 10% 的数据，如果只有单值索引，那么通过该索引能筛选出 1000W * 10% = 100w 条数据，然后再回表从 100w 条数据中找到符合 b=2 and c=3 的数据，然后再排序，再分页。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de39c52e50a180cad38e6c4ac527b6a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7818c4dcf6e8d5ef9fe72247c51221c/" rel="bookmark">
			【算法专题】分治 - 快速排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分治 - 快速排序 分治 - 快速排序1. 颜色分类2. 排序数组(快速排序)3. 数组中的第K个最大元素4. 库存管理Ⅲ5. 排序数组(归并排序)6. 交易逆序对的总数7. 计算右侧小于当前元素的个数8. 翻转对 分治 - 快速排序 1. 颜色分类 做题链接 -&gt; Leetcode -75.颜色分类
题目：给定一个包含红色、白色和蓝色、共 n 个元素的数组 nums ，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。
我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。
必须在不使用库内置的 sort 函数的情况下解决这个问题。
示例 1：
输入：nums = [2, 0, 2, 1, 1, 0]
输出：[0, 0, 1, 1, 2, 2]
示例 2：
输入：nums = [2, 0, 1]
输出：[0, 1, 2]
提示：
n == nums.length
1 &lt;= n &lt;= 300
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d7818c4dcf6e8d5ef9fe72247c51221c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b32ef91f6eb3807c108542b6c160ec54/" rel="bookmark">
			关于振动试验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这是试验的说明（来自gbt4710-2009）
这是试验的参数： 一、试验方向： 振动试验中有几个方向
除有关规范另有规定外，应在产品的三个互相垂直方向上进行振动试验。
一般定义产品长边为X轴向，短边为Y轴向，产品正常摆放上下为Z轴向。
一般情况下振动试验的方向是三个方向，也有只需要做水平方向或只做垂直方向的；
二、频率循环范围： 振动频率范围表示振动试验由某个频率点到某个频率点进行往复扫频。
例如：试验频率范围5-50Hz，表示由5Hz到50Hz进行往复扫频。
振动试验的参数 - 百度文库
3.4扫频循环 sweepcycle
在每个方向按规定的频率范围往返。例如，10 Hz到150 Hz到10 Hz。
注：数字正弦控制系统生产厂商提供的手册经常以f1到f2表示扫频循环，而不是f1到f2到f1。
这一条也是经常容易混淆的地方，有的试验给出的条件没有给出充分的信息，常常导致试验无法顺利开展需要反复的确认，而如果这一点上能比较明确、统一可以节省不少的时间。
正弦振动试验标准与解读（GB/T 2423.10-2008）_检测资讯_嘉峪检测网
三、振幅值： 有关规范应规定振动幅值（位移幅值或加速度幅值，或两者都要）
四、扫频循环次数: 试验的持续时间及其选择
试验的持续时间是描述产品的耐受振动能力的重要参数。对试验持续时间的选择相对于上述二个参数的选择要困难得多。因为目前一般很难给出多长的试验时间相当于实际使用的多少时间。对扫频试验，通常以扫频循环数给出试验时间。对定频试验，则直接以分钟和小时给出试验时间。IEC和国标对扫频试验给出了1，2，5，15，20，50，100等七个扫频循环数等级，对定频试验给出了10分，30分，1小时，1.5小时，2小时，10小时等六个试验时间等级；对微电子器件试验方法与程序和电子及电气元件试验方法的美军标和国军标，给出了12个（三方向）和36个（三方向）二种扫频循环数等级。在这里还需指出的是进行扫频试验时，其扫频速率通常为1倍频程/min。如何具体地选择试验的持续时间，通常是根据振动对产品的破坏机理来确定的。
振动对产品的破坏，一般可以分为三种，即对产品工作性能的破坏，对产品结构完好性的破坏，对产品寿命的破坏。如果主要考虑振动对产品工作性能的影响，如工作不正常、不稳定、失灵、甚至不能工作等，通常是振动一旦停止，工作性能就能恢复正常，所以其试验时间可按设备所需的最长连续工作时间结合实践经验来确定。结构破坏主要是指脱焊、螺钉松动、连接件脱开、部件的相互撞击。对这种破坏一般在30分钟到一小时就能发现。对其中的螺钉松动和连接件脱开、部件的撞击也可按最长的连续工作时间来考虑。在某些情况下，也可按全部寿命时间来考虑。如果是为了确定产品承受累积应力的能力（疲劳），其时间应根据产品的使用要求，按使用时可能出现的应力循环数来确定，或按无限寿命，即10⁷次应力循环来确定试验时间。
全面了解正弦振动试验 - 知乎
扫频循环：在规定的频率范围内往返扫描一次：
例如：5Hz→50Hz→5Hz,从5Hz扫描到50Hz后再扫描到5Hz。
五、扫频速率： 什么是扫描速度
扫描速度(sweep speed):指从最低频率扫描到最高频率的速度。有以下几种：
1）Oct/min:多少倍频程每分钟。
例:1Oct/min,5Hz到10Hz需1分钟,10Hz到20Hz需1分钟。
2）min/sweep:多少分钟每次扫频。
例:5-500Hz,扫描速度:1分钟/sweep,表示从5Hz到500Hz需1分钟。
3）Hz/s:多少Hz每秒。
例:5-10Hz,扫描速度:1Hz/s,表示5Hz到6Hz需1秒,6Hz到7Hz需1秒。
对数扫描频率变化按对数变化，扫描率可以是oct/min、oct是倍频程。如果上限频率fH，下限fL，fH/fL=2^n，n就是下限频率到上限频率经过了n个倍频程。
对数扫描的意思是相同的时间扫过的频率倍频程数是相同的，例如从5-20Hz是两个倍频程，从500-2000Hz也是两个倍频程。在对数扫描的情况下，扫过这两段的时间是相同的。就是说对数扫描时低频扫得慢而高频扫得快（这当然是指单位时间扫过的频率范围）。有时对数扫描率还用于Dec/min，含义是每分钟扫多少个十倍频程。
六、扫频试验： 扫频试验是指在试验过程中维持一个或两个振动参数（位移、速度或加速度）量级不变，而振动频率在一定范围内连续往复变化的试验。
线性扫描化是线性的，即单位时间扫过多少赫兹，单位是Hz/s或Hz/min，这种扫描用于细找共振频率的试验。
对数扫描频率变化按对数变化，扫描率可以是oct/min、oct是倍频程。
如果上限频率fH，下限fL，fH/fL=2n，n就是下限频率到上限频率经过了n个倍频程。
对数扫描的意思是相同的时间扫过的频率倍频程数是相同的，例如从5-20Hz是两个倍频程，从500-2000Hz也是倍频程。在对数扫描的情况下，扫过这两段的时间是相同的。就是说对数扫描时低频扫得慢而高频扫得快（这当然是指单位时间扫过的频率范围）。有时对数扫描率还用于Dec/min，含意是每分钟扫多少个十倍频程。
正弦振动试验到底有什么用？
正弦振动试验及其相关参数的计算 - 百度文库
关于振动试验的国标：
GB-T 4857.23-2003 运输包装件随机振动试验
GB/T 4857.10-2005 包装 运输包装件基本试验 第10部分：正弦变频振动试验方法
GJB 150.25-1986 军用装备实验室环境试验方法 第25部分：振动-噪声-温度试验
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b32ef91f6eb3807c108542b6c160ec54/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed81dd76ad7e9db1ac7b6d7ce808079c/" rel="bookmark">
			Linux基础命令6
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		源码编译安装：软件功能可按需选择/定制 源码包进行包装就产生了RPM软件包 源码包--通过开发工具gcc与make---变成可执行程序---运行安装 安装开发工具gcc、make tar解包，释放源代码到指定目录，把从真机上传递过来的tools包解压到/usr/local/目录下 解压inotify压缩包 查看该源码包的内容 ./configure 配置，它能检测当前系统是否安装gcc， 指定安装位置与功能，生成Makefile文件（制作程序的大纲）。 查看帮助信息 必须相对路径运行该脚本， prefix选项：指定安装位置 进行make编译，变成可以执行的程序（放在内存中，二进制文件） make install 安装，将编译好的文件复制到安装路径 查看安装 如果要卸载，只要卸载该目录 rsync基本使用 rsync：Remote Sync 远程同步 复制是完全拷贝源到目标，同步则是增量拷贝，只传输 变化过的数据 rsync [选项] 源目录 目标目录 -n：测试同步过程，不做实际修改 --delete：删除目标目录文件夹内多余的文档 -a：归档模式，相当于 -rlptgoD（保持大部分的属性不变） -v：显示详细操作信息 -X：保持acl策略不变 创建两个目录 向mydir目录中添加内容 同步数据内容，需要加 ‘/’ 查看目标目录，此时数据已经同步过去 原目录添加文件，再次同步会添加新增的文件 如果目标目录中比原目录多文件，使用---delete会删除多余的文件 查看目标目录 测试同步，表示将要同步的内容 远程同步 rsync + ssh rsync [..] 本地目录 user@host:远程目录 rsync [..] user@host:远程目录 本地目录 在pc2主机查看内容 如何实现，只要原目录数据变化，就数据远程同步：虚拟机A上生成公钥与私钥，把公钥传递给虚拟机B，此时rsync远程数据同步就不在需要密码 生成密钥 传递公钥 此时数据远程同步就不需要密码验证 使用上面下载的源码包程序inotify,监控原目录的变化 inotifywait [选项] 目标文件夹 -m：持续监控（捕获一个事件后不退出） -r：递归监控，包括子目录及文件 -q：减少屏幕输出信息 -e：指定监视的modify、move、create、delete等事件 监控文件的变化，要在开一个终端 在另一个终端中修改文件内容 此时监控就输出监视的结果 脚本：可以运行的一个文件，实现某种功能 例如：使用脚本输出 hello world 需要编写shell脚本，让两个命令相关联起来，只要inotifywait一检测到文件变化，就执行rsync命令让数据远程同步。 -rqq两个q表示不在屏幕上输出 执行脚本并放入到后台（&amp;） 在虚拟机A是修改内容， 此时使用虚拟机B查看内容，已经同步数据 数据库：存放数据的仓库 在数据库系统中，有很多的数据库，每个数据库中有很多的表格 MariaDB数据库： 安装软件包 mariadb-server 启动服务 使用mysql命令登录默认以数据库管理员登录不需要密码 show datebases; : 显示数据库，以分号结尾 create database ：创建数据库 查看创建的数据库 删除数据库drop 退出数据库 exit use + 数据库名：进入该数据库 show tables ：查看表格 数据库系统没有返回命令，如果需要进入其他数据库直接use + 数据库；就能切换到该数据库。 表格的操作：增、删、改、查；表的类型叫做表字段，表的内容叫表记录。 数据的恢复，把表导入到数据库中（之前导出的表或者下载的表） 进入数据库，查看表格 查看该数据库的表格，select *(所有字段) from 表名 当在其他数据库中查看另一个数据库的表时，需要加上该数据库的名称 查看特定的命令，where、and、or insert插入数据，update修改数据，delete删除数据 数据库系统管理员：对于数据库系统有最高权限，名称为root，能够登录数据系统的用户信息，由mysql中user表进行存储。 为数据库系统管理员设置密码： mysqladmin [-u 用户名] [-p 旧密码] passwd '新密码' 此时登录数据库就需要密码了 修改密码 邮件服务器：为用户提供电子邮件存储空间（用户名@邮件域名），处理用户发出的邮件--传递给收件服务器，处理用户收到的邮件--投递到邮箱。 安装软件包postfix 发送邮件 mial -s '标题名' -r 发送用户名 接收用户名 查看邮件 容器： 将软件打包成标准化单元，用于开发，交付和部署，容器技术已经成为应用程序封装和交付的核心 优点：相较于传统的虚拟化技术，容器更加简洁高效，容器使用的共享公共库和程序 缺点：容器的隔离性没有虚拟化强，共用Linux内核，缺乏安全性 podman是完整的一套容器管理系统，它提供的一组命令，让用户更加方便直接地使用容器技术，而不需要过多的关心底层内核技术， 需要关闭SELinux，设置禁用模式（重新开机才会生效） 卸载防火墙 yum remove firewalld 修改网卡命名规则（eth0）： 编辑/etc/default/grub文件 链接到/boot/grub2/grub.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed81dd76ad7e9db1ac7b6d7ce808079c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9704ec96dd82e20854e77f7d8dc75774/" rel="bookmark">
			【SCI一区级】灰狼算法结合卷积神经网络优化短时间记忆神经网络注意力机制多变量多步时间序列预测GWO-CNN-LSTM-selfAttention【含Matlab源码 359
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		⛄一、灰狼算法结合卷积神经网络优化短时间记忆神经网络注意力机制多变量多步时间序列预测GWO-CNN-LSTM-selfAttention 1 Matlab实现GWO-CNN-LST M-self Attention灰狼算法优化卷积长短期记忆神经网络融合自注意力机制多变量多步时间序列预测， 灰狼算法优化学习率， 卷积核大小， 神经元个数， 以最小MAPE为目标函数；
CNN卷积核大小：卷积核大小决定了CNN网络的感受野， 即每个卷积层可以捕获的特征的空间范围。选择不同大小的卷积核可以影响模型的特征提取能力。较小的卷积核可以捕获更细粒度的特征，而较大的卷积核可以捕获更宏观的特征。
LSTM神经元个数：LSTM是一种适用于序列数据的循环神经网络， 其神经元个数决定了模型的复杂性和记忆能力。较多的LST M神经元可以提高模型的学习能力， 但可能导致过拟合。
学习率：学习率是训练深度学习模型时的一个关键超参数，它控制每次参数更新的步长。学习率过大可能导致模型不稳定和发散，学习率过小可能导致训练过慢或陷入局部最小值。
自注意力层(Self-Attention) ：Self-Attention自注意力机制是一种用于模型关注输入序列中不同位置相关性的机制。它通过计算每个位置与其他位置之间的注意力权重，进而对输入序列进行加权求和。自注意力能够帮助模型在处理序列数据时，对不同位置的信息进行适当的加权，从而更好地捕捉序列中的关键信息。在时序预测任务中，自注意力机制可以用于对序列中不同时间步之间的相关性进行建模。
2 运行环境为Matlab 2023a及以上， 提供损失、RMSE迭代变化极坐标图； 网络的特征可视化图；
测试对比图；适应度曲线(若首轮精度最高，则适应度曲线为水平直线)；
3 excel数据集(负荷数据集) ， 输入多个特征， 输出单个变量， 考虑历史特征的影响， 多变量多步时间序列预测(多步预测即预测下一天96个时间点) ， main.m为主程序， 运行即可， 所有文件放在一个文件夹；
4 命令窗口输出SSE、RMSE、MSE、MAE、MAP E、R2、r多指标评价， 适用领域：负荷预测、风速预测、光伏功率预测、发电功率预测、碳价预测等多种应用。
程序乱码是由于Matlab版本不一致造成的， 处理方式如下：先重新下载程序， 如XXX.m程序出现乱码， 则在文件夹中找到XXX.m， 右击选择打开方式为记事本文本文档(txt) ， 查看文档是否乱码， 通常不乱码， 则删除Matlab中的XXX.m的全部代码， 将文本文档中不乱码的代码复制到Matlab中的XXX.m中。
⛄二、部分源代码 %% 清除内存、清除屏幕
clc
clear
%% 导入数据
data = xlsread(‘负荷数据.xlsx’);
rng(0)
%% 数据分析
daynum=30; %% 数据量较大，选取daynum天的数据
step=96; %% 多步预测
data =data(end-step*daynum+1:end,:);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9704ec96dd82e20854e77f7d8dc75774/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5938dee9f9aa5554cacac53a40f4683/" rel="bookmark">
			我的世界Bukkit服务器插件开发教程（二）命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		二、命令 这一章节，我们会讲讲怎么开发一个可以输入指令的插件
首先你需要知道指令（命令）
都应该用过cmd吧，比如/ping，/pause，/cls等，这些就是指令
那么怎么自己开发一个可以输入指令的插件呢？
编写教程 老规矩，照样继承JavaPlugin，来重写一下加载和卸载两个方法
public class MyCommand extends JavaPlugin { public void onEnable() { say("插件已加载"); } public void onDisable() { say("插件已卸载"); } public void say(String s) { CommandSender sender = Bukkit.getConsoleSender(); sender.sendMessage(s); } } 那么此时需要添加一个新成员：onCommand
也需要重写一下，参数不变（废话）
public boolean onCommand(CommandSender sender, Command cmd, String label, String args[]) { //... return true;	} CommandSender：输入指令的玩家Command：执行的命令label：被执行命令的别名args：命令参数，如/ping s，s就是参数，args[0]就是s 注意看重载的方法是布尔类型的，那么一定有返回值true或者是false
如果返回值是false会把plugin.yml提示信息发送给玩家
现在我想输入一个命令test，并想返回一条消息：Hello World!
if(label.equalsIgnoreCase("test")) { return true; } 这个if是判断玩家输入的是否是/test（不区分大小写）
如果是，则：
sender.sendMessage("Hello World!"); 如果不是，则返回false
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5938dee9f9aa5554cacac53a40f4683/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50a7522a83cec710f208bee4f555d3f6/" rel="bookmark">
			Spring Cloud Gateway 网关的基础使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 什么是网关？网关有什么用？ 在微服务架构中，网关就是一个提供统一访问地址的组件，它解决了内部微服务与外部的交互问题。网关主要负责流量的路由和转发，将外部请求引到对应的微服务实例上。同时提供身份认证、授权、限流、监控以及日志记录等功能。
从上图就能看出网关的作用了，它就是充当客户端与内部微服务之间的桥梁的。前端虽然可以发送ajax，但是它没有健康检测、没有负载均衡，所以需要使用网关来充当一个统一的入口。当前端的请求来到了网关，网关再去分发，因为网关是用 Java 代码来写的，所以可以在网关这里引入Nacos进行健康检测，引入LoadBalancer进行负载均衡。而且它还有超时重试等高级功能。
🍁网关的主要作用
提供统一的访问入口点：网关作为唯一的网络流量入口和出口，简化了客户端的访问。安全控制：网关能够提供安全检查，例如统一登录和授权。协议转换：网关可以在不同网络协议之间转换数据，例如处理HTTPS和HTTP之间的转换。网络地址的转换：它允许局域网内的多个设备共享一个公共IP地址与外部网络通信，这样做可以提高安全性，节省IP地址，并使内部网络结构对外部不可见。数据的过滤和处理：网关可以对流经的数据进行过滤和必要的处理。 2. Spring Cloud Gateway 的基础使用 2.1 Spring Cloud Gateway 的组成 路由：定义访问的目标地址。断言：定义一组规则，让匹配到当前路由的请求去调用某个目标。过滤器：对请求进行特殊处理。 2.2 Spring Cloud Gateway 最基础的使用 准备工作：
创建SpringBoot多模块项目创建三个模块：网关、订单、用户 假设订单、用户模块在内网中，不能直接访问，需要通过网关路由到对应的服务上面。
准备相关模块中的 controller：
@RestController @RequestMapping("/order") public class OrderController { @RequestMapping("/getcount") public int getCount() { return new Random().nextInt(1000); } } @RestController @RequestMapping("/user") public class UserController { @Autowired private ServletWebServerApplicationContext context; // 获取动态端口 @RequestMapping("/getname") public String getName() { return context.getWebServer().getPort() + "--UserService：name=java-"+ new Random().nextInt(100); } } 以上两个某块只需要添加 Spring Web 依赖即可。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/50a7522a83cec710f208bee4f555d3f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5259c5b74ca630c05a45f8619c64e1fe/" rel="bookmark">
			class065 A星、Floyd、Bellman-Ford与SPFA【算法】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		class065 A星、Floyd、Bellman-Ford与SPFA【算法】 2023-12-9 19:27:02
算法讲解065【必备】A星、Floyd、Bellman-Ford与SPFA
code1 A*算法模版 // A*算法模版（对数器验证）
package class065; import java.util.PriorityQueue; // A*算法模版（对数器验证） public class Code01_AStarAlgorithm { // 0:上，1:右，2:下，3:左 public static int[] move = new int[] { -1, 0, 1, 0, -1 }; // Dijkstra算法 // grid[i][j] == 0 代表障碍 // grid[i][j] == 1 代表道路 // 只能走上、下、左、右，不包括斜线方向 // 返回从(startX, startY)到(targetX, targetY)的最短距离 public static int minDistance1(int[][] grid, int startX, int startY, int targetX, int targetY) { if (grid[startX][startY] == 0 || grid[targetX][targetY] == 0) { return -1; } int n = grid.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5259c5b74ca630c05a45f8619c64e1fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5bf7f194afb668670ec24e290b53cc02/" rel="bookmark">
			基于 Linux 内核驱动模块的简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于 Linux 内核驱动模块的简介 最简内核驱动原理 内核编程的最简单表现就是内核模块， 它可以作为一段可动态加载的成熟的内核级的代码使用。使用时一般不限制模块个数和类型，即插即用， 高效快捷、 性能稳定。缺点为性能和内存利用缺失， 模块间的依赖关系有着严密的逻辑结构，使用不当可能造成系统崩溃， 因为对于一般程序而言， 内核都会有安全保护机制以防其止造成内核故障。 但是在运行内核级代码的时候， 使用不当可能会出现异常而影响整个系统，造成系统锁定、内存泄漏或引入死循环等问题。 所以在编写内核代码时首先要保证代码的严谨性，其次要遵循内核库的标准， 最后在卸载内核模块时要回收内存和清理系统垃圾。
在 PC 机上通过交叉编译器编译内核模块时，会根据包含的头文件对源码进行索引， 因此必须要保证代码编译依赖源码和目标机运行内核源码版本相符。此环境中编译的模块才能（也是只能） 被运行于该版本内核系统中，否则一个微小的异常就可能引起内核锁定或模块编译异常失败。 所以编译内核模块必需有相对应的内核源码和相关的编译配置文件以及所需要编译的程序代码。以一个最简驱动模块举例， 其编译时所需的几个主要部分如图所示：
以一个最简字符驱动代码为例，其主要包含如表 2-1 所示的几项内容。
使用 make 命令编译内核驱动模块时，会根据 Makefile 文件中的 KERNELDIR 参数索引到 Linux 内核源码中去编译[5]， 结合所需资源， 在当前目录下生成很多临时文件以及驱动模块文件*.ko。 *.ko 文件即所需要的内核驱动模块， 大致编译过程为如图所示。 首先调用 Makefile， 然后分为两条路径进行，一是通过添加的源码路径搜索需要的编译用的源码， 会索引源码相关目录，添加对应头文件等， 然后整合资源信息在 Makefile 同级目录下找到需要编译的.c 文件， 编译需要的.ko 文件。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a0f8e8fafc6fa371520b681887d1271/" rel="bookmark">
			【数电笔记】58-同步D触发器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
说明：
1. 电路组成
2. 逻辑功能
3. 特性表、特性方程
4. 状态转移图
例题
5. 同步D触发器的特点
6. 集成同步D触发器：74LS375
74LS375内部原理
说明： 笔记配套视频来源：B站本系列笔记并未记录所有章节，只对个人认为重要章节做了笔记；标题前面的数字标号就是对应的视频章节，请大家自行对应学习 1. 电路组成 2. 逻辑功能 3. 特性表、特性方程 ​​​​​​​
4. 状态转移图 例题 5. 同步D触发器的特点 6. 集成同步D触发器：74LS375 74LS375内部原理 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/45/">«</a>
	<span class="pagination__item pagination__item--current">46/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/47/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>