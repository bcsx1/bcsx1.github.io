<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e30299497b047de649dfefa9b9dd1d1e/" rel="bookmark">
			pyqt5 使用Qthread多线程的两种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一种 在主控窗口中实例化工作对象（工作对象需要继承QObject），以及实例化QThread对象，然后工作对象moveToThread; 下面是一个把工作对象moveToThread,使用Qthread去运行工作任务，由工作任务返回进度。去更新主控窗口进度条progressBar的例子
import sys import time from PyQt5.QtCore import QObject,QThread,pyqtSignal,pyqtSlot from PyQt5.QtWidgets import QWidget,QApplication,QGridLayout,QProgressBar class DoSome(QObject): resultReady = pyqtSignal(int) #自定义resultReady信号，该信号带参数int finish = pyqtSignal() #自定义finish信号，向外通知工作结束 def __init__(self): super(DoSome, self).__init__() def do(self): for i in range(1,101): print("send:",i) self.resultReady.emit(i) #每变化一个数字发送一个信号，同时发出当前的进度值 time.sleep(0.2) self.finish.emit() #结束后，发送自定义的finish信号 class Ctrl(QWidget): operate = pyqtSignal() def __init__(self): super(Ctrl, self).__init__() gridlayout = QGridLayout(self) self.progressbar = QProgressBar(self) gridlayout.addWidget(self.progressbar) self.setLayout(gridlayout) self.worker = DoSome() self.workth = QThread() self.worker.resultReady.connect(self.handle_result) self.worker.moveToThread(self.workth) # 一定先把工作对象移动到thread中然后再connect连接工作对象中的循环工作函数 # 否则会导致主控窗口在工作对象循环时显示不出来 self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e30299497b047de649dfefa9b9dd1d1e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57ad70ae2a6b53c6a7e59cd9edbc0120/" rel="bookmark">
			Qt获取鼠标移动事件，窗口内任意位置按下鼠标左键拖动窗口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 重写窗口的两个事件函数mousePressEvent和mouseMoveEvent即可：
在mousePressEvent 中，按下鼠标左键时，记录窗口坐标，其中窗口坐标的计算是由鼠标事件获取到鼠标在整个屏幕中的坐标（ev-&gt;globalpos()），然后再使用pos()获取到鼠标在窗口内的相对位置，两者之差就是窗口在整个屏幕上的坐标x,y。如下：
在Qt中可以直接使用ev-&gt;globalPos() - pos()，两者相减获取到程序窗口在屏幕上的坐标（x,y）;
在mouseMoveEvent中，事件是不断实时触发的，通过move方法传入实时计算的窗口目标位置，然后实时刷新移动窗口;
void Dialog::mousePressEvent(QMouseEvent *ev) { //鼠标左键按下时记录坐标 if(ev-&gt;button() == Qt::LeftButton){ // ev-&gt;globalPos() 获取鼠标的全局坐标（在整个屏幕中） // pos()获取的是鼠标在窗口中的相对位置坐标(在程序窗口内) // last_pos为前者与后者的差（鼠标的绝对坐标-鼠标在窗口内的相对坐标偏移），也就是窗口左上角在桌面的坐标x,y last_pos = ev-&gt;globalPos()-pos(); qDebug()&lt;&lt;"last_pos:"&lt;&lt;last_pos; } return QDialog::mousePressEvent(ev); } void Dialog::mouseMoveEvent(QMouseEvent *ev) { if( ev-&gt;buttons() &amp; Qt::LeftButton){ //注意这里是&amp;按位与，不是&amp;&amp;，只有鼠标左键按下时才触发 move(ev-&gt;globalPos()-last_pos); // 实时计算窗口的x,y坐标 // qDebug()&lt;&lt;"move"&lt;&lt;ev-&gt;globalPos()-last_pos; last_pos = ev-&gt;globalPos() - pos(); } return QDialog::mouseMoveEvent(ev); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6797fbf72bae8a4b17e87b9321fa5fe7/" rel="bookmark">
			OpenMVG与OpenMVS之OpenCV编译
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 本文章主要介绍三维重建库OpenMVG与OpenMVS的依赖库OpenCV的编译安装，首先从OpenCV官网下源码，并通过CMake编译源码，主要在VS2015进行编译测试。
文章目录 文章目录一、OpenCV下载二、CMAKE编译三、总结 一、OpenCV下载 https://opencv.org/，下载最新版opencv-4.7.0.zip即可，如下展示opencv-4.7.0.zip、opencv-3.4.13-vc14_vc15.exe源码的编译。
二、CMAKE编译 2.1 opencv-3.4.13-vc14_vc15.exe 安装解压到third_party下opencv目录，通过cmake-gui工具进行编译，源码目录选择oepncv下的sources目录，在third_party下新建并选择的opencv_build目录作为编译生成路径，设置需要生成x64，以及vs的版本。
2.2 编译设置，取消勾选BUILD_WITH_STATIC_CRT、BUILD_PERF_TESTS、BUILD_TESTS、WITH_CUDA，以及与CUDA相关的选项，勾选BUILD_SHARED_LIBS。
2.3 设置CMAKE_INSTALL_PREFIX为安装目录，主要用于安装编译后的include头文件、.lib文件以及.dll文件。
2.4 设置完后点击Configure，知道没有红色条目，让后点击Generate，当这两步都成功之后，点击Open Project即可打开工程文件。打开工程文件之后，点击vs的菜单上的生成，选择批生成，勾选工程ALL_BUILD的debug、release，点击生成即可一键生opencv的debug和release版本。点击INSTALL工程即可执行分别对dubug和release执行安装操作。
三、总结 经过编译测试，在VS2015上进行两个版本的编译，opencv-3.4.13-vc14_vc15.exe的release版本全部成功，debug版本仅opencv_python3工程编译失败，而最新版的iopencv-4.7.0debug和release都只部分编译成功。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7ea41f2c3b753c38e3742e4773d663f/" rel="bookmark">
			Altium Designer(AD)软件使用记录15-PCB布线部分之优化和DRC处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 Altium Designer(AD)软件使用记录15-PCB布线部分之优化和DRC处理一、线路优化二、顶层和底层（信号层）铺铜三、添加缝合孔四、DRC处理 Altium Designer(AD)软件使用记录15-PCB布线部分之优化和DRC处理 一、线路优化 走线：尽量等间距处理，美观；不要出现直角和锐角走线
过孔：能对齐的尽量对齐处理
二、顶层和底层（信号层）铺铜 线路都优化完成了，下一步就需要对顶层和底层进行铺铜处理了。
这里的铺铜都是GND网络。
整个板框进行铺铜。
操作：选择整个板框，快捷键TVG（从选择的元素创建铺铜），然后可以根据自己对铜皮的情况进行设置铜皮的类型等。
三、添加缝合孔 操作：快捷键THA（给网络添加缝合孔）
以上的内容根据PCB的情况自己设置即可。（添加缝合孔需要一点时间，要耐心等待）
如果不想使用AD这个添加缝合孔的方法，可以自己手动添加过孔，结果都是一样的。
四、DRC处理 操作：允许DRC（快捷键TDR）
观察DRC出来的结果，有报错的，会显示绿色的，然后一个一个的修改过来。
这个过程需要耐心，细心。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99697ed2670b3396b84872ca92a1d9d4/" rel="bookmark">
			BT下载磁力下载工具，这几款，不限速
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		想看个电影，迅雷限速，经常还因为某些原因下不了，下载电影，BT下载工具总少不了，今天给大家推荐这几款BT下载磁力链接下载工具。不限速下载，超爽！
一、Motrix
Motrix是一款全能的下载工具，支持下载 HTTP、FTP、BT、磁力链、百度网盘等资源。Motrix使用aria2作为内核，下载速度非常快，支持多线程下载，可以同时下载多个文件。Motrix的界面非常简洁、操作起来也很方便。Motrix支持Windows、macOS和Linux等多个平台。
二、uTorrent
uTorrent以体积小和占用内存低而著称，BT下载磁力链接下载很多用户用来下载电影音乐等。uTorrent支持Windows、Mac、Android、Linux系统。支持多任务同时下载，支持设置文件下载优先级，可以根据计划任务调整占用的带宽，全局/单个任务的速度限制，快速断点续传机制，支持UPnP，支持流行的BT扩展协议。
三、qBittorrent
qBittorrent 是一个免费的开源 BitTorrent 客户端，允许用户使用 BitTorrent 协议下载和共享文件。它适用于多种操作系统，包括 Windows、macOS 和 Linux。qBittorrent和µTorrent类似。
四、比特彗星
比特彗星是一款免费的BT/HTTP/FTP下载软件。比特彗星支持同时下载多个文件，支持断点续传，还具有流量控制、IP过滤、种子制作和磁力链接等功能。
BT下载工具有很多，这些工具都可以不限速下载，下载速度和资源链接有关系，建议多进行尝试。可以根据自己的喜好选择BT下载工具。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e8db17ad1162804aa57d5e79c03d924/" rel="bookmark">
			GhostNetV2（2022）（全文翻译）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GhostNetV2: Enhance Cheap Operation with Long-Range Attention Abstract 轻量级卷积神经网络 (CNN) 专为推理速度更快的移动设备上的应用而设计。卷积运算只能捕获窗口区域的局部信息，这阻碍了性能的进一步提高。将self-attention引入卷积可以很好地捕捉全局信息，但会在很大程度上阻碍实际速度。在本文中，我们提出了一种硬件友好的注意力机制（称为 DFC 注意力），然后提出了一种用于移动应用程序的新 GhostNetV2 架构。所提出的DFC 注意力是基于全连接层构建的，它不仅可以在普通硬件上快速执行，还可以捕获远程像素之间的依赖关系。我们进一步重新审视了之前 GhostNet 的表达瓶颈，并提出用 DFC 注意力增强廉价操作产生的扩展特征，以便GhostNetV2 块可以同时聚合本地和远程信息。大量实验证明了 GhostNetV2优于现有架构的优势。例如，它在具有 167M FLOPs 的 ImageNet 上实现了75.3% 的 top-1 准确率，显着抑制了具有相似计算成本的 GhostNetV1(74.5%)。源代码可在
https://github.com/huawei-noah/Efficient-AI-Backbones/ tree/master/ghostnetv2_pytorch and https://gitee.com/mindspore/ models/tree/master/research/cv/ghostnetv2.
1 Introduction 在计算机视觉中，深度神经网络的架构在各种任务中起着至关重要的作用，例如图像分类 [19、10]、目标检测 [27、26] 和视频分析 [18]。在过去的十年中，网络架构一直在快速发展，已经开发出包括 AlexNet [19]、GoogleNet [29]、ResNet [10] 和 EfficientNet [32] 在内的一系列里程碑。这些网络将各种视觉任务的性能提升到了一个高水平。
要在智能手机和可穿戴设备等边缘设备上部署神经网络，我们不仅需要考虑模型的性能，还需要考虑其效率，尤其是实际推理速度。矩阵乘法占据计算成本和参数的主要部分。开发轻量级模型是减少推理延迟的一种有前途的方法。 MobileNet [13] 将标准卷积分解为深度卷积和点卷积，这大大降低了计算成本。 MobileNetV2 [28] 和 MobileNetV3 [12]进一步引入了反向残差块并改进了网络架构。 ShuffleNet [42] 利用 shuffle 操作来促进通道组之间的信息交换。 GhostNet [8] 提出了廉价操作来减少通道中的特征冗余。WaveMLP [33] 替换了复杂的self-attention 模块与简单的多层感知器 (MLP) 以降低计算成本。这些轻量级神经网络已应用于许多移动应用程序。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e8db17ad1162804aa57d5e79c03d924/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0178553e1b48176c0707d7b1fed6295/" rel="bookmark">
			Hutool的Http调用简单使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Hutool的Http调用简单使用 Http调用 http调用即通过http方式调用第三方接口，现成的工具库有很多，如HttpClient、RestTemplate、OKHttp，今天主要介绍Hutool-http
前置环境 Spring Initializr初始化项目 选择Spring Web和Lombok依赖 Java版本1.8
application.yml配置如下：
server: servlet: context-path: /api port: 8123 引入Hutool依赖：
&lt;dependency&gt; &lt;groupId&gt;cn.hutool&lt;/groupId&gt; &lt;artifactId&gt;hutool-all&lt;/artifactId&gt; &lt;version&gt;5.8.15&lt;/version&gt; &lt;/dependency&gt; 先写一个简单的被调用接口 主要功能就是：
GET调用返回名字POST调用返回名字POST调用返回User对象 Controller
package com.zd.zdinterface.controller; import com.zd.zdinterface.model.User; import org.springframework.web.bind.annotation.*; /** * 查询名称 * @author zd */ @RestController @RequestMapping("/name") public class NameController { @GetMapping("/") public String getNameByGet(String name) { return "GET 你的名字是：" + name; } @PostMapping("/") public String getNameByPost(@RequestParam String name) { return "Post 你的名字是：" + name; } @PostMapping("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0178553e1b48176c0707d7b1fed6295/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3dd84abb07d0049e3e7e9848bc60639/" rel="bookmark">
			c&#43;&#43;之运算符重载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
运算符重载的定义
运算符重载的技术推演
运算符重载的两种方法
重载运算符的写法
重载=号运算符
自己实现一个数组类
运算符重载的定义 所谓重载，就是重新赋予新的含义。函数重载就是对一个已有的函数赋予新的含义，使之实现新功能，因此，一个函数名就可以用来代表不同功能的函数，也就是”一名多用”。
运算符也可以重载。实际上，我们已经在不知不觉之中使用了运算符重载。例如，大 家都已习惯于用加法运算符”+”对整数、单精度数和双精度数进行加法运算，如5+8， 5.8 +3.67等，其实计算机对整数、单精度数和双精度数的加法操作过程是很不相同的， 但由于C++已经对运算符”+”进行了重载，所以就能适用于int, float, double类型的运算。
运算符重载的技术推演 int a = 0, b = 0; int c; c = a + b; //基础数据类型 编译器已经知道了如何运算 我们都知道基础类型可以直接进行运算操作，而像如果是自己定义的类型想要进行运算符运算编译器就会直接报错。
这是因为编译器不知道怎么进行运算导致错误 。所以c++编译器提供了一种机制即运算符重载来让我们自己编写如何进行运算。
在c++中使用operator来声明运算符重载的操作。
Complex operator+(Complex c2) { Complex tmp(this-&gt;a + c2.a, this-&gt;b + c2.b); return tmp; } 例如重载+法运算符操作的话就可以使用operator+来说明。
运算符重载的两种方法 运算符重载有两种方法：一种是使用成员函数法，一种是使用全局变量法。
//通过类成员函数完成-操作符重载
//函数声明 Complex operator-(Complex &amp;c2)
//函数调用分析
//用类成员函数实现-运算符重载
Complex c4 = c1 - c2;
c4.printCom();
//c1.operator-(c2);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b3dd84abb07d0049e3e7e9848bc60639/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2afb52377494671c46ee931dadc0d913/" rel="bookmark">
			12.typedef的使用与结构体定义
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		欢迎访问个人网络日志🌹🌹知行空间🌹🌹
文章目录 1.基础介绍2.typedef 的常用的几种情况3.使用typedef可能出现的问题参考资料 1.基础介绍 typedef是C/C++语言中保留的关键字，用来定义一种数据类型的别名。
typedef并没有创建新的类型，只是指定了一个类型的别名而已。
typedef定义的类型的作用域只在该语句的作用域之内， 也就是说如果typedef定义在一个函数体内，那么它的作用域就是这个函数。如果typedef定义在一个命名空间中，则其作用域只在当前命名空间中。
使用 typedef 关键字可以用来定义自己习惯的数据类型名称，来替代系统默认的基本类型名称、数组类型名称、指针类型名称与用户自定义的结构型名称、共用型名称、枚举型名称等。
2.typedef 的常用的几种情况 给基本数据类型定义别名 // 1 typedef doule REAL； // 2 typedef float REAL; 定义数据类型REAL，在不同平台上通用的代码，如需改动，只需要修改typedef语句即可。
为复杂类型定义别名，简化代码 typedef int *(*pFun)(int, int); // 定义函数指针 int *add(int x, int y) { int *p = new int; *p = x + y; return p; } pFun fp[1]; // 定义函数指针数组 fp[0] = add; std::cout &lt;&lt; "r " &lt;&lt; *fp[0](1,2) &lt;&lt; std::endl; typedef 与struct/enum/union等自定义数据类型共同使用 在C语言中，对标签标识符强制了自己单独的命名空间，如自定义结构体时
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2afb52377494671c46ee931dadc0d913/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4fa972fd40387dc3c732aaa9d6188dcd/" rel="bookmark">
			CityGML标准文档（11）（第六章——6.8~6.12)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 6.8 城市对象组 CityGML的分组概念允许根据用户定义的标准聚合任意城市对象，并将这些聚合结果作为城市模型的一部分进行表示和传输（UML图见第10.11章；XML模式定义见附件a.6）。可以为一个组分配一个或多个名称，并可以根据特定属性进行进一步分类，例如，“火灾场景中从1212号房屋43号房间逃生的路线”作为名称，“逃生路线”作为类型。可以选择为组的每个成员分配一个角色名称，该名称指定该特定成员在组中扮演的角色。例如，该角色名称可以描述逃生路线中该对象的序列号，或者在建筑群的情况下，表示主建筑。一个组可以包含其他组作为成员，允许任意深度的嵌套分组。分组概念由CityGML的主题扩展模块CityObjectGroup提供（参见第10.11章）。
6.9 外观 关于表面外观的信息，即表面的可视化属性，除了语义和几何学外，也是虚拟3D城市模型的组成部分。 外观与任何基于表面的主题相关，例如红外辐射或噪音污染，而不仅仅是视觉特性。因此，外观也可作为三维模型的表达内容或作为空间分析中的输入要素。
CityGML支持每个城市模型任意数量的主题外观。且在每个LOD层级，都可以具有单独的外观特性。外观可以表示纹理和地理参考纹理等。CityGML的外观模型封装在其自己的扩展模块Appearance中（参见第9章）。
6.10 原型对象/场景图 在CityGML中，形状相同的对象（如树木和其他植被对象、交通灯和交通标志）可以表示为原型，在不同位置多次实例化（图7）。通过局部坐标系来定义原型的几何结构。每个实例都由对原型的参照、世界坐标参考系中的基点和便于原型缩放、旋转和平移的变换矩阵表示。该原理采用了VRML和X3D等计算机图形标准中使用的场景图概念。由于GML3几何模型不支持场景图概念，因此通过GML3几何结构模型的扩展来实现（有关进一步描述，请参阅第8.2章）。
6.11 通用城市对象和属性 CityGML算是一个通用的地形信息模型，它定义了对象类型和属性，对大多数应用非常有用。在实际应用中，特定3D城市模型中的对象很可能包含CityGML中未明确建模的属性。此外，可能存在CityGML主题类未涵盖的3D对象。CityGML提供了两个不同的概念来支持此类数据的交换：1）通用对象和属性，以及2）应用程序域扩展（参见第6.12章）。通用对象和属性允许在运行时扩展CityGML应用程序，即任何_CityObject都可以通过其他属性来扩展，这些属性的名称、数据类型和值可以由正在运行的应用程序提供，而无需更改CityGML-XML模式。类似地，可以使用通用对象对未由CityGML数据模型的预定义主题类表示的特征进行建模和交换。类似的，不由CityGML数据模型的预定义主题类表示的要素，可以使用通用对象进行建模和交换。CityGML的通用扩展由主题扩展模块Generics提供（参见第10.12章）。
例如，当前版本的CityGML不包括路堤、挖掘和城墙的明确主题模型。这些对象可以使用通用对象和属性来存储或交换。
6.12 应用程序域扩展（ADE） 应用程序域扩展（ADE）规定了对CityGML数据模型的扩展内容。这些增加包括在现有CityGML类中引入新的特性，如建筑物的居住人数或新对象类型的定义。ADE与通用对象和属性之间的区别在于，ADE必须在具有自己命名空间的额外的XML模式文件中定义。此文件必须能显式导入扩展CityGML模块的XML模式。
这种方法的优点是扩展是正式指定的。扩展的CityGML实例文档可以根据CityGML和相应的ADE模式进行验证。ADE可以由对特定应用领域感兴趣的信息团体定义（甚至标准化）。在同一数据集中可以主动使用多个ADE（更多说明参见第10.13章）。
可以为一个或甚至几个CityGML模块定义ADE，从而使得向CityGML数据模型添加附加信息变得高度灵活。因此，ADE机制与CityGML的模块化方法正交。因此，ADE没有单独的扩展模块。
本标准中包括两个ADE示例：
噪声排放模拟ADE（附录H），用于根据欧盟委员会环境噪声指令（2002/49/EC）模拟环境噪声扩散；通用网络机器人服务ADE（附件I），演示了CityGML在室内环境中的机器人导航。
ADE的其他示例包括用于设施管理的CAFM ADE（Bleifuß等人，2009年）、用于多公用设施网络及其相互依赖性的集成3D建模的UtilityNetworkADE（Becker等人，2011年）、，水文应用的HydroADE（Schulte和Coors，2008年）和GeoBIM（IFC）ADE（van Berlo等人，2011年），后者将IFC（来自bSI）的BIM信息与CityGML相结合，并在开源模型服务器BIMserver.org中实现。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1835bb3c09e52e70326b3f7621069156/" rel="bookmark">
			CityGML标准文档（12）（第七章——序言)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		7 模块化 CityGML标准，无论是从数据模型的主题层面来讲，还是从其几何拓扑层面来讲，都堪称是一个内容丰富的标准。从主题方面来说，CityGML定义了城市地物的类别和关系，其中包括建筑结构、高程、植被、水体、城市家具等组成的区域模型。除了几何和外观内容外，还可以在模拟、城市数据挖掘、设施管理和主题查询等不同应用领域中，使用虚拟3D城市模型进行复杂的分析。
我们可以将CiytGML视作一个框架，这个框架为地理空间中的三维数据提供了足够的空间，来满足这些三维数据全生命过程中，在几何图形、拓扑和语义上内容的增加。如此一来，就可以灵活地构建城市对象的几何和语义（而不仅仅是纯几何数据集），直至形成复杂的、几何拓扑健全且空间语义连贯的数据。通过这种方式，CityGML定义了一个单对象模型和数据交换格式，适用于3D城市建模的连续过程，从几何图形采集、数据鉴定和细化到为特定的最终用户应用准备数据，从而实现迭代数据逐步丰富以及信息的无损交换（cf. Kolbe et al. 2009）。
按照“框架”这个想法，应用程序不需要通过支持CityGML的所有主题领域以达到严格符合符合标准的目的，而是可以使用与应用程序领域或过程的特定相关要求，相对应地构造子集。CityGML的逻辑子集的使用减少了整个数据模型的复杂性，并允许在部分内容中可以实现。至于CityGML标准的2.0版本，数据模型的可能子集由称作 CityGML模块 的内容来定义和接受。CityGML模块是对各方面的规范性（或称标准）的集合，所有这些方面都必须作为一个整体，由一个一致的系统来实现。CityGML由一个核心模块和主题扩展模块组成。
CityGML核心模块定义了CityGML数据模型的基本概念和组件。它被视为整个CityGML数据模型的下界，也是所有主题扩展模块的依赖。因此，核心模块是唯一的，必须由一致的系统来实现。在CityGML核心模块的基础上，每个扩展模块都包含CityGML数据模型一个逻辑上独立的主题组件。核心的扩展是通过对整个CityGML数据模型进行垂直切片而得到的。由于核心模块包含（通过引用）在每个扩展模块中，因此其一般概念和组件对所有扩展模块都是通用的。CityGML标准2.0版引入了以下13个主题扩展模块。它们与本文的条款直接相关，每个条款都涵盖了CityGML的相应主题领域：
外观（参见第9条）桥梁（参见第10.5条）建筑物（参见第10.3条）城市家具CityFurniture（参见第10.9条），城市对象组CityObjectGroup （参见第10.11条）泛型（通用）Generics（参见第10.12条）土地使用（参见第10.10条）Relief（参见第10.2条）运输（参见第10.7条）隧道（参见第10.4条）植被（参见第10.8条）水体（参见第10.6条）纹理表面[已弃用]（参见第9.8条） CityGML数据模型的主题分解后，可支持扩展模块与核心模块的任何组合，以符合CityGML。因此，扩展模块可以根据应用程序或应用程序域的信息需求任意组合。模块的组合称为CityGML配置文件。所有模块的集合定义为CityGML基本配置文件。基本配置文件在任何给定时间都是唯一的，并构成整个CityGML数据模型的上限。任何其他CityGML配置文件都必须是基本配置文件的有效子集。只要遵循CityGML模块和配置文件的概念标准，就可以通过明确的定义方式实现CityGML数据模型的有效内容。
至于未来的开发内容，每个CityGML模块都可以由专家组和信息团体独立于其他模块进行进一步开发。在不影响其他模块有效性的情况下，由此产生的建议和模块变更可能会被引入CityGML标准的未来修订中。此外，当前CityGML数据模型未涵盖的主题组成部分可能会通过额外的主题扩展模块，添加到该标准未来的修订版中。这些额外的扩展可以建立与任何其他现有CityGML模块的依赖关系，但至少应依赖于CityGML核心模块。因此，随着新扩展的增加，CityGML的基本配置文件可能会随着时间的推移而变化。然而，如果特定应用程序需要建模和交换的信息超出了CityGML数据模型的范围，则该应用程序数据也可以使用CityGML的应用程序域扩展机制（ADE）（参见第10.13条）或通过使用通用城市对象和属性的概念（参见第10.1 2章）合并到现有模块中。
引入的模块化方法支持CityGML作为一种数据建模框架和交换格式的多功能性，可解决3D城市建模的各种应用领域和不同步骤。为了清楚起见，应用程序应通过声明所使用的CityGML配置文件来说明对CityGML标准的符合程度。由于核心模块是所有简介的一部分，因此应通过列举已实施的主题扩展模块来实现这一点。例如，如果一个应用除了核心模块之外，还支持建筑模块、Relife模块和植被模块，那么它应该叫作“CityGML[Building, Relief, Vegetation]”。如果支持基本配置文件，则应使用“CityGML[full]”表示。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/209cd9279d6120d0743b3ff19d68dc81/" rel="bookmark">
			数学建模-如何用matlab画出漂亮的图（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 画图基本指令 hold on :保持打开的命令关闭图形保持功能hold off:
title ( xx')命名
xlabel (xx’ ) x轴标注
ylabel (xx’ ) y轴标注
figure (x) 创建图窗
hidden on 将网格设为不透明
hidden off 将网格设为透明
legend (xx)加图例
grid on加网格线
subplot (2,2.4).显示第4个图形
yyaxis left 激活当前坐标区中与左侧y 轴关联的一侧yyaxis right 激活当前坐标区中与左侧 y 轴关联的一侧
plot (x,y) :描点连线，画简单的折线图
plot(x，y，'s’) : 设置点的类型
2 散点图 ① 最基础的散点图 x = 0.01:0.01:0.08; y = [3.0743,3.0707,3.0716,3.1133,3.1685,3.1778,3.2467,3.2634]; scatter(x, y); ② 函数专用散点图 x = linspace(-2, 2, 100); y = x .^ 3; scatter(x, y); ③ 设置圆圈大小的散点图 x = linspace(-2, 2, 100); y = x .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/209cd9279d6120d0743b3ff19d68dc81/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e25f8ab81e48d8a162578bb0524b3bf/" rel="bookmark">
			启动RabbitMQ服务以及基本使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、环境配置 RabbitMQ 3.9.15
Erlang 24.3.3
二、启动服务 在RabbitMQ\rabbitmq_server-3.9.15\sbin目录下，执行以下命令
rabbitmq-server.bat 三、访问RabbitMQ管理界面 在浏览器输入：
http://localhost:15672 初始账号和密码如下：
Username：guest
Password：guest
即可看到管理界面
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8136b6128e5e04c1ae9326611c70001b/" rel="bookmark">
			python姿态检测实现多人多姿态识别python行为识别openpose行为骨骼框架检测动作识别动作检测行为动作分类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		效果演示：
视频演示：
python行为识别行为骨骼框架检测动作识别动作检测行为动作分类
项目下载链接：https://download.csdn.net/download/babyai996/87552750
0环境项目配置教程：https://download.csdn.net/download/babyai996/87552768
一、背景技术
由于在人机交互、智能交通系统、视频监控等多个领域的巨大需求，人体的动作识别越来越受到计算机视觉领域的重视。为了能使计算机识别来自不同场景的动作，其核心是利用判别特征来表征动作，然后对其进行分类。与静态图像识别不同，除了空间运动特征外，还有更为重要的时间运动特征，那么，如何有效提取动作的空间运动特征和时间运动特征是人体动作识别要解决的两个主要问题。
传统的动作识别方法侧重于手工提取有效的时空特征，然后使用不同的分类器对特征进行分类。基于手工特征的动作识别方法的第一步是提取局部特征，在各种外观特征中，方向梯度直方图(HOG)因其对人体空间运动特征的高鲁棒性和高效性而被广泛研究。受HOG的启发，Laptev等人将HOG与光流相结合，设计了光流直方图(HOF)。此外，HOG还被扩展为HOG-3D来提取时空特征。Wang和Schmid提出融合了HOG、HOF和运动边界直方图(MotionBoundary Histograms，MBH)的密集轨迹算法(Dense Trajectories，DT)。在此基础上，又提出了改进的密集轨迹算法(ImprovedDense Trajectories，iDT)，主要引进了对背景光流的消除方法，使得所提取的运动特征更集中于对人体动作的描述。同时，Harris-3D、Hessian-3D和3D-SIFT等都是常用的局部描述子。
随着CNNs在图像分类领域取得的巨大成功，人们尝试从原始图像通过多层的卷积层和池化层自动学习动作特征。与图像分类相比动作具有时间运动特征，用于动作识别的CNNs通常会比较复杂，大多数基于CNNs的动作识别方法按照两个步骤来实现：首先利用静态图像建立空间CNNs，然后在时间上将它们融合，这就导致动作之间的时间关系丢失，因此Ji等人设计了3D-CNNs架构，提出通过3D卷积核去提取视频数据的时间和空间特征，这些3D特征提取器在空间和时间维度上操作，因此可以捕捉视频流的运动信息，但是动作识别的准确率较低。
二、内容
本发明的目的是为解决传统动作识别方法存在的动作识别的准确率低的问题。
本发明为解决上述技术问题采取的技术方案是：
步骤一、选用InceptionV3为基础网络结构，建立空间通道卷积神经网络；
步骤二、迁移在ImageNet数据集上预训练好的InceptionV3基础网络结构模型的前10层参数至步骤一建立的空间通道卷积神经网络；将UCF101视频数据集切割为单帧静态图像，将切割好的单帧静态图像随机分成训练集和测试集数据，对空间通道卷积神经网络进行训练和测试；
步骤三、采集待识别视频序列，将待识别视频序列切割为每帧静态图像来作为训练集和测试集数据，对步骤二训练好的空间通道卷积神经网络的参数进行微调后，利用训练集和测试集的每帧静态图像对空间通道卷积神经网络进行训练和测试，输出待识别视频序列的每帧静态图像对应的各个类别的概率值P1,P2，…，PN；
步骤四、建立全局时域通道卷积神经网络，所述全局时域通道卷积神经网络仅在空间通道卷积神经网络的输入层之后增加一层卷积核尺寸为3×3的卷积层，其余的网络结构与空间通道卷积神经网络相同；
步骤五、利用步骤二训练集中每帧静态图像对应的能量运动历史图来训练步骤四建立的全局时域通道卷积神经网络；利用步骤二测试集中每帧静态图像对应的能量运动历史图来测试全局时域通道卷积神经网络；
步骤六、对步骤五训练好的全局时域通道卷积神经网络的参数进行微调后，利用步骤三训练集和测试集的每帧静态图像对应的能量运动历史图对全局时域通道卷积神经网络进行训练和测试，输出待识别视频序列每帧静态图像对应的能量运动历史图的各个类别的概率值P1′,P2′，…，PN′；
步骤七、在待识别视频序列中，分别将每帧静态图像对应的空间通道卷积神经网络输出与全局时域通道卷积神经网络输出融合，即计算出每帧静态图像的每个类别的概率平均值将概率平均值最大的类别作为每帧静态图像的动作识别结果。
本发明的有益效果是：本发明提供了一种融合全局时空特征的卷积神经网络人体动作识别方法，本发明建立空间通道卷积神经网络和全局时域通道卷积神经网络，利用UCF101视频数据集对建立的空间通道卷积神经网络和全局时域通道卷积神经网络进行训练和测试；将待识别视频序列的每帧静态图像输入训练好的空间通道卷积神经网络，对网络参数进行微调后，进行训练和测试，并输出待识别视频序列的每帧静态图像对应的各个类别的概率值；将待识别视频序列的每帧图像对应的能量运动历史图依次输入训练好的全局时域通道卷积神经网络进行训练和测试，并输出待识别视频序列每帧静态图像对应的能量运动历史图的各个类别的概率值；再将空间通道卷积神经网络和全局时域通道卷积神经网络的输出结果融合，得到待识别视频序列中每帧静态图像的动作识别结果；与传统的动作识别方法相比，本发明的动作识别方法的识别准确率可以提高至87％以上。
本发明融合了人体动作的空间和时间特征，对人体动作的识别起到很好的作用。
附图说明
图1为本发明所述的一种融合全局时空特征的卷积神经网络人体动作识别方法的流程图；
图2为本发明所述的空间通道多帧融合示意图；
图中表示3帧静态图像的输出融合；
图3为本发明所述的全局时域通道输入配置的示意图；
其中：299×299×1为输入层，299×299×3为经过卷积层后的结果。
三、具体实施方式
下面结合附图对本发明的技术方案作进一步的说明，但并不局限于此，凡是对本发明技术方案进行修改或者等同替换，而不脱离本发明技术方案的精神和范围，均应涵盖在本发明的保护范围中。
具体实施方式一：结合图1说明本实施方式。本实施方式所述的一种融合全局时空特征的卷积神经网络人体动作识别方法，该方法的具体步骤为：
步骤一、选用InceptionV3为基础网络结构，建立空间通道卷积神经网络；
步骤二、迁移在ImageNet数据集上预训练好的InceptionV3基础网络结构模型的前10层参数至步骤一建立的空间通道卷积神经网络；将UCF101视频数据集切割为单帧静态图像，将切割好的单帧静态图像随机分成训练集和测试集数据，对空间通道卷积神经网络进行训练和测试；
步骤三、采集待识别视频序列，将待识别视频序列切割为每帧静态图像来作为训练集和测试集数据，对步骤二训练好的空间通道卷积神经网络的参数进行微调后，利用训练集和测试集的每帧静态图像对空间通道卷积神经网络进行训练和测试，输出待识别视频序列的每帧静态图像对应的各个类别的概率值P1,P2，…，PN；
步骤四、建立全局时域通道卷积神经网络，所述全局时域通道卷积神经网络仅在空间通道卷积神经网络的输入层之后增加一层卷积核尺寸为3×3的卷积层，其余的网络结构与空间通道卷积神经网络相同；
步骤五、利用步骤二训练集中每帧静态图像对应的能量运动历史图来训练步骤四建立的全局时域通道卷积神经网络；利用步骤二测试集中每帧静态图像对应的能量运动历史图来测试全局时域通道卷积神经网络；
步骤六、对步骤五训练好的全局时域通道卷积神经网络的参数进行微调后，利用步骤三训练集和测试集的每帧静态图像对应的能量运动历史图对全局时域通道卷积神经网络进行训练和测试，输出待识别视频序列每帧静态图像对应的能量运动历史图的各个类别的概率值P1′,P2′，…，PN′；
步骤七、在待识别视频序列中，分别将每帧静态图像对应的空间通道卷积神经网络输出与全局时域通道卷积神经网络输出融合，即计算出每帧静态图像的每个类别的概率平均值将概率平均值最大的类别作为每帧静态图像的动作识别结果。
本实施方式提出的一种融合全局时空特征的卷积神经网络，可以更好的提取动作的时空信息。
具体实施方式二：本实施方式对实施方式一所述的一种融合全局时空特征的卷积神经网络人体动作识别方法进行进一步的限定，本实施方式中步骤一具体过程为：
选用InceptionV3为基础网络结构，去掉基础网络结构最后的全连接层后，从前往后依次增加神经元个数为1024的全连接层、神经元个数为256的全连接层和神经元个数为N个动作类别的全连接层。
本实施方式中的神经元个数为1024的全连接层和神经元个数为256的全连接层的激活函数为relu，神经元个数为10个动作类别的全连接层的激活函数为softmax。
具体实施方式三：本实施方式对实施方式二所述的一种融合全局时空特征的卷积神经网络人体动作识别方法进行进一步的限定，本实施方式中的步骤二的的具体过程为：
迁移在ImageNet数据集上预训练好的InceptionV3基础网络结构模型的前10层的参数，即将模型的第1个卷积层到第3个Inception模块的参数迁移至步骤一建立的空间通道卷积神经网络，将UCF101视频数据集切割为尺寸299×299的标准输入单帧静态图像，将切割好的单帧静态图像随机分成训练集和测试集数据，将训练集中的静态图像依次输入空间通道卷积神经网络，采用Adam梯度下降法进行训练，mini-batch大小设置为32，参数采用Keras默认参数，若对测试集静态图像的识别准确率至少连续10次都未增加，则停止训练。
具体实施方式四：本实施方式对实施方式三所述的一种融合全局时空特征的卷积神经网络人体动作识别方法进行进一步的限定，本实施方式中的步骤三中采集摔倒动作数据集作为待识别视频序列，待识别视频序列包括摔倒、走路和坐下的动作，每个动作包含M个视频序列，将M个视频序列随机分为训练集和测试集，且每个视频序列切割为K帧静态图像；
对空间通道卷积神经网络的参数进行微调，即修改空间通道卷积神经网络最后一层的输出类别为3；
将训练集静态图像依次输入参数微调后的空间通道卷积神经网络，采用Adam梯度下降法训练最后一层全连接层，训练至少10次epoch后，采用随机梯度下降法训练最后两层全连接层，学习率设置为0.0001，Momentum设置为0.9，若对测试集静态图像的识别准确率至少连续10次都未增加，则停止训练；
在空间通道卷积神经网络中采用多帧融合的方式进行动作识别，将输入的当前帧静态图像和之前帧静态图像的输出取平均；输出待识别视频序列的每帧静态图像对应的3个类别的概率值P1,P2和P3。
本实施方式中，多帧融合的方式是指：若输入的当前帧静态图像为第n帧，输出的结果三个类别的概率分别为Pn 1,Pn 2和Pn 3，那么，取平均是指：Pn 1,Pn 2和Pn 3是当前帧单独的输出结果与前面n-1帧的输出结果取平均值。
因为动作是一个三维的时空信号，若空间通道只以当前帧的输出作为判别依据可能会出现较大误差，所以本实施方式在空间通道采用多帧融合的方式进行动作识别，对当前帧和之前固定帧数的识别结果加权平均。如图2所示，将当前帧与前2帧的输出融合，虽然当前帧的识别出现错误，但通过前2帧的矫正最终输出了正确的结果，提高了识别的准确率。
具体实施方式五：本实施方式对实施方式四所述的一种融合全局时空特征的卷积神经网络人体动作识别方法进行进一步的限定，本实施方式中的步骤五的具体过程为：
将步骤二训练集的单帧静态图像的能量运动历史图依次输入建立好的全局时域通道卷积神经网络，采用Adam梯度下降法来训练全局时域通道卷积神经网络，mini-batch大小设置为32，参数采用Keras默认参数，若测试集的动作识别准确率至少连续10次都未增加，则停止训练；
第t帧静态图像对应的能量运动历史图中的坐标为(x,y)的像素点的灰度值为Hτ(x,y,t)，按照更新函数得到：
式中：(x,y)是第t帧静态图像对应的能量运动历史图中的像素点的位置，max代表取0和Hτ(x,y,t-1)-δ中较大的值，Hτ(x,y,t-1)是第t-1帧静态图像对应的能量运动历史图中的坐标为(x,y)的像素点的灰度值；τ为持续时间，δ为衰退参数；
ψ(x,y,t)为更新函数，判断各个像素点在当前帧是否为前景，若为前景则ψ(x,y,t)等于1，否则ψ(x,y,t)等于0；
ψ(x,y,t)通过帧间差分法得到：
D(x,y,t)＝|I(x,y,t)-I(x,y,te)|
式中：I(x,y,t)是第t帧静态图像中位于(x,y)坐标的像素点的灰度值；I(x,y,te)是前一有效帧静态图像中位于(x,y)坐标的像素点的灰度值；ξ是用来判别前景和背景的阈值；D(x,y,t)是I(x,y,t)与I(x,y,te)的差的绝对值；
计算能量运动历史图的过程为：
若当前帧静态图像为有效帧，则更新一次能量运动历史图，否则不更新；
有效帧的判断原则是：设第一帧静态图像为有效帧，若当前帧静态图像相对于前一有效帧静态图像的运动能量大于阈值μ，则当前帧为有效帧；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8136b6128e5e04c1ae9326611c70001b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e02d9d5beab12503231cea320fad988/" rel="bookmark">
			IDEA离线安装JRebel插件并激活
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. 下载JRebel安装包
2.解压安装包到IDEA安装目录plugins下
3.重启IDEA
4.激活
1. 下载JRebel安装包
JRebel and XRebel - IntelliJ IDEs Plugin | Marketplace
2. 解压安装包到IDEA安装目录plugins下
3.重启IDEA
4.在IDEA菜单选择 File | Settings | JRebel &amp; XRebel进行激活
TeamUrl：
https://jrebel.qekang.com/{GUID}
GUID在线生成：
GUID生成工具-在线全局唯一标识符GUID-UUID生成_蛙蛙工具
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7f01f7d1ed82fbbc4c97db58ff1011c/" rel="bookmark">
			【玩转Jetson TX2 NX】（三）TX2 NX挂载 M.2 固态硬盘&#43;移动系统（详细教程）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 Jetson TX2 NX安装 M.2 固态硬盘 将 M.2 固态硬盘安装到Jetson TX2 NX，并贴上散热片，如图所示：
Jetson TX2 NX上电开机，打开终端，输入命令
df -h 检查硬盘信息，此时没有识别到硬盘，如图所示，此时需要对硬盘进行格式化并挂载到系统上
2 格式化硬盘并挂载到系统 输入命令检查所有分区信息
sudo fdisk -l 找到/dev/nvme0n1，有 M.2 固态硬盘，如图所示：
然后，打开Jetson TX2 NX系统自带的磁盘分区工具Disks，如图所示：
选择接入的 M.2 固态硬盘，如图所示：
上图右上角三条横岗位置，打开后选择Format Disk，弹出如下窗口：
上图中点击Format，弹出如下窗口，输入系统密码并确认：
选择 M.2 固态硬盘，点击“+”号创建硬盘分区，直接将整个硬盘空间作为一个分区即可，点击Next：
填写磁盘名称，磁盘格式为Ext4，然后点击Create：
挂载 M.2 固态硬盘，点击三角键，挂载后，三角键变为停止键，如图所示：
终端输入命令
df -h 查看挂载的硬盘，如图所示：
3 移动系统到固态硬盘 打开Jetson TX2 NX的终端，输入命令
git clone https://github.com/jetsonhacks/rootOnNVMe.git 安装rootOnNVME软件，然后进入rootOnNVME目录，输入命令
cd rootOnNVMe/ 查看文件，输入命令
ls 如图所示：
复制系统文件到硬盘，输入命令
./copy-rootfs-ssd.sh 输入密码，开始复制，如图所示：
复制完成后，输入命令
./setup-service.sh 查看系统是否成功移动，然后输入重启命令
sudo reboot 重启Jetson TX2 NX系统，然后终端输入命令
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d7f01f7d1ed82fbbc4c97db58ff1011c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5e9cf71bd920045b1abad92b02718d1/" rel="bookmark">
			“Explorer.EXE R6030 - CRT not initialized”的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Microsoft Visual C++ Runtime Library
Runtime Error!
Program: C:\WINDOWS\Explorer.EXE
R6030
- CRT not initialized
自从更新Windows11以来，数不清的BUG不堪困扰。
其中最麻烦的一个就是这个提示框。
正常的运行着运行着就突然出现这个，点击“确定”后又会一而再再而三的出来。
运气好的话，可能在第三次第四次成功不再被烦。
运气不好的话，只能手动Ctrl+Shift+Esc呼唤出任务管理器找到“Windows 资源管理器”选择“重新启动”。
它的本质原因是某个DLL文件的类型问题，加载时出错。
解决办法为，用管理员身份启动Powershell
然后输入“sfc /scannow"，自检。
按照官方的说法，它会替换损坏的文件。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3284768a36ede49258afc39df426334e/" rel="bookmark">
			JDBC超详细封装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 JBDC封装（超详细）1.前言2.导入第三方jar包2.1普通java项目2.2Maven项目 3.JDBC连接核心参数4.JDBC连接数据库5.资源管理工具类6.增删改封装（BaseDao）7.查询操作的封装7.1返回值类型7.2接口设计7.3统一查询query7.4接口实现类7.4.1MapHandler7.4.2MapListHandler7.4.3BeanListHandler7.4.4BeanHandler7.4.5ArrayListHandler7.4.6ArrayHandler 8.总结 JBDC封装（超详细） 1.前言 ​ JDBC（Java Database Connectivity）是什么？它是一种规范，SUN公司要求数据库公司必须按照JDBC规范实现对应数据库Java代码，提供数据库的相关资源给java程序。在JDBC出来之前，各种数据库提供给java程序数据的方法各式各样，可以说，JDBC极大地方便了我们java开发程序员，目前和java配合最好的数据库是Oracle和MySQL数据库。
​ JDBC只是一种规范，数据库厂商根据这个标准实现自家的驱动Dirver，例如MySQL驱动com.mysql.cj.jdbc.Driver，Oracle驱动oracle.jdbc.OracleDriver，加载过驱动，我们就可以对数据库进行操作了。
2.导入第三方jar包 2.1普通java项目 如果创建的是普通的java项目，需要手动导入第三方jar包，可以自行去官网下载。 ​ jar包导入项目的方法我这里就不过多赘述了。
2.2Maven项目 Maven是java项目统一管理工具，可以解决后期项目频繁导入jar包繁琐操作的问题，同时，如果是传统项目，jar包的更新迭代，我们还需要对整个项目的jar包进行替换，这里也可以用Maven项目来解决。 方法： 在pom.xml文件中写入依赖： 如下代码： &lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt; &lt;/dependency&gt; ​ 注释里面是这个网址，可以在里面直接复制此代码。
3.JDBC连接核心参数 1.明确连接的是哪一个数据库，提供对应驱动 导入第三方jar包 2.url：统一资源定位符，可以明确数据库在哪 需要数据库对应的主机名，域名和IP地址以及【端口号】 3.连接数据库的用户名和密码 可以新建一个jdbc.properties文件,将连接参数都写入进去。
driverClass=com.mysql.jdbc.Driver jdbcUrl=jdbc:mysql://localhost:3306/gp_01?serverTimezone=Asia/Shanghai&amp;useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false username=root password=root 4.JDBC连接数据库 ​ 我们用一个小Demo来看一下简单流程：
@Test public void testInsert() { //1.准备数据库连接必要参数 String jdbcUrl = "jdbc:mysql://localhost:3306/gp_01?serverTimezone=Asia/Shanghai&amp;useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false"; String username = "root"; String password = "root"; Connection connection = null; Statement statement = null; try { //2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3284768a36ede49258afc39df426334e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fdb0e824acd85199dc263ba606a5731f/" rel="bookmark">
			ChatGPT｜必看 10 篇论文
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ChatGPT 是一种专注于对话生成的语言模型。它能够根据用户的文本输入，产生相应的智能回答。这个回答可以是简短的词语，也可以是长篇大论。其中 GPT 是 Generative Pre-trained Transformer（生成型预训练变换模型）的缩写。
本人已经收集，下载打包了该模型相关的10篇论文。需要的可以下载，是英文的。
地址：ChatGPT论文 10篇下载地址 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d4a822a00030c86094e4292e8fea473/" rel="bookmark">
			树莓派 ifconfig 没有wlan0
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		树莓派无法联网，ifconfig发现没有wlan0，输入命令
sudo ifconfig -a
发现可以检测到wlan0，那么输入
rfkill unblock all
再次输入ifconfig就可以了，重启也一样有效
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e98d5658777eed412447545b91db0b18/" rel="bookmark">
			HCIA-WLAN
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、WLAN的802.11制式
【WiFi1】802.11【1997】2.4G2Mbps
【WiFi2】802.11b【1999】2.4G11Mbps
【WiFi3】802.11a 【1999】 5G54Mbps
【WiFi3】802.11g 【2003】 2.4G54Mbps
【WiFi4】802.11n【2009】2.4G/5G 600Mbps
【WiFi5】802.11ac【2013】 5G&gt;1Gbps
【WiFi6】802.11ax 【2018】2.4G/5G9.6Gbps
二、企业无线路由器的种类：
胖AP【家用、SOHO居家办公、小型办公室】
瘦AP【瘦AP依靠AC（AccessController）】
注：PoE【Power over Ethernet】
三、有线侧的管理协议---CAPWAP
AC于AP之间使用有线的方式进行连接，在连接的链路上运行CAPWAP协议，构建CAPWAP隧道。
CAPWAP隧道中负责传送2种流量。
2.1、控制流量【AC用来统一管理瘦AP的控制信令流量】
2.2、业务流量【移动终端用户通过连接AP所发送的数据流量】
四、AP于AC的组网方式：
AP与AC之间用二层交换机连接，通过二层交换机的多端口，使多个AP接入交换机，实现和AC的配置下发，集中管理，所有设备都属于同一个广播域当中，适用于小型网络。
AP与AC之间使用三层交换机互联，通过三层交换机的多VLNA，多网段的功能，实现AC对不同网络之间的AP的控制，适用于大型网络的互联。
五、AC在组网中的连接方式：
直连式：AC于AC直连，对AP进行统一的直接管理，AC也作为流量的出口设备，作为内网的转发网管。缺点：容易成为流量转发的瓶颈，AC的转发速率成为全网的最高速率。
旁挂式：AC不直接于AP相连，而是通过其他网络于其进行互联。优势在于不会成为网络的瓶颈，实现最大带宽的透传。缺点在于无法对多个AP的数据进行统一的集中管理。
六、无线电磁波频段：
极低频(3Hz-30Hz):潜艇通讯或直接转换成声音。
超低频(30Hz-300Hz):直接转换成声音或交流输电系统(50-60赫兹)。特低频(300Hz-3KHz):矿场通讯,或直接转换成声音。
甚低频 (3KHz-30KHz): 直接转换成声音、超声、地球物理学研究。低频(30KHz-300KHz):国际广播。
中频(300KHz-3MHz):调幅(AM)广播、海事及航空通讯。高频(3MHz-30MHz):短波、民用电台。
其高频(30MHz-300MHz):调频(FM)广播、电视广播、航空通讯。 特高频(300MHz-3GHz):电视广播、无线电话通讯、无线网络、微波炉。超高频(3GHz-30GHz):无线网络、雷达、人造卫星接收。
极高频(30GHz-300GHz):射电天文学、遥感、人体扫描安检仪。300GHz以上:红外线、可见光、紫外线、射线等。
七、无线信道问题
八、无线侧面网络组网的基本概念：
BSS【基本服务集】：一个AP所发射的无线覆盖范围
范围：通过改AP连接的用户都可以互访
SSID【服务集标识符】：一个无线信号的名称
BSSID【基本服务集标符】:无线AP的MAC地址
4.VAP【虚拟接入点】：一个AP可以发射多个BSS,每个BSS就是一个VAP，每个BSS都有一个单独的SSID信号。
ESS【扩展服务集】：由多个相同SSID的AP所组成的一个大的无线通讯范围。
九、WLAN的工作流程
【一】AP上线
获取地址
a、静态分配地址
b、让AP向AC获取IP地址
c、让AP向网络中的DHCPSERVER获取IP地址
让AC之间建立CAPWAP隧道
发现隧道隧道：有两种
a、静态建立隧道：管理员在AP内配置其所需要寻找的AC【在该方式下，AP所发送的DiscoveryRequest 是以单播方式发送】
b、动态建立隧道：令AP以广播的形式发送Discovery Request 消息，在全网范围内寻找AC
建立隧道：
3. 在AC接收到所发送的DiscoveryRequest消息后，将会回应Discovery Reponse消息与AP 建立CAPWAP隧道。
4.CAPWAP隧道中包含两个子隧道
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e98d5658777eed412447545b91db0b18/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa4391d2808ab59eb1dec73d02cc02e5/" rel="bookmark">
			C语言实例：输出字符的几种方式和实际编程中的应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在C语言中，要输出单个字符可以使用多种方式。以下是一些常见的方法：
使用putchar函数 putchar函数可以输出单个字符到标准输出设备（通常是屏幕）。例如，下面的代码将字符’A’输出到屏幕上：
putchar('A'); 使用printf函数 printf函数可以用于格式化输出。如果只想输出单个字符，则需要使用格式化控制符’%c’。例如，下面的代码将字符’B’输出到屏幕上：
在C语言中，%c是一个格式控制符，用于输出一个字符。在使用printf函数时，可以在字符串中使用%c来指定要输出的字符。例如，下面的代码将字符’A’输出到屏幕上：
printf("%c", 'A');
%c还可以与scanf函数一起使用，用于读取输入中的单个字符。例如，下面的代码将从输入中读取一个字符并将其存储在变量ch中：
scanf("%c", &amp;ch);
printf("%c", 'B'); 使用putc函数 putc函数与putchar函数类似，可以将单个字符输出到指定的文件流。例如，下面的代码将字符’C’输出到文件中：
FILE *fp; fp = fopen("example.txt", "w"); putc('C', fp); fclose(fp); 使用fputc函数 fputc函数与putc函数类似，也可以将单个字符输出到指定的文件流。例如，下面的代码将字符’D’输出到文件中：
FILE *fp; fp = fopen("example.txt", "w"); fputc('D', fp); fclose(fp); 以上是C语言中常见的输出单个字符的方法。根据不同的需求，可以选择不同的方法来输出单个字符。
如果您需要在C语言中输出多个字符，还可以使用字符串。以下是一些常见的方法：
使用printf函数 printf函数也可以用于输出字符串。如果要输出字符串中的某个字符，可以使用格式化控制符’%c’。例如，下面的代码将字符串"Hello World"中的第一个字符’H’输出到屏幕上：
printf("%c", "Hello World"[0]); 使用puts函数 puts函数可以输出整个字符串，如果需要输出字符串中的某个字符，可以通过下标访问。例如，下面的代码将字符串"Hello World"中的第二个字符’e’输出到屏幕上：
char str[] = "Hello World"; printf("%c", str[1]); 以上是一些常见的C语言输出单个字符和多个字符的方法。希望对您有帮助！如果您还有其他问题，请随时提出。
在实际编程中，字符输出可以用在很多地方。以下是一些常见的场景：
输出调试信息：在程序调试过程中，可以使用字符输出函数将某些中间结果或调试信息输出到屏幕上，以便于调试程序。输出用户界面：在编写控制台程序时，可以使用字符输出函数将用户界面输出到屏幕上。文件操作：在文件读写操作中，可以使用字符输出函数将字符逐个写入文件中。网络操作：在网络编程中，可以使用字符输出函数将字符逐个发送到网络中。 在程序调试过程中，可以使用字符输出函数将某些中间结果或调试信息输出到屏幕上，以便于调试程序。以下是一些常见的方法：
使用printf函数输出调试信息。可以使用格式化字符串，将变量的值插入到字符串中。例如，下面的代码将变量x的值输出到屏幕上： int x = 10; printf("The value of x is %d\\n", x); 使用puts函数输出调试信息。puts函数可以输出指定的字符串，并自动添加换行符。例如，下面的代码将字符串"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa4391d2808ab59eb1dec73d02cc02e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d67a419553b9f44540d000c6e6635def/" rel="bookmark">
			初识爬虫以及电影信息爬取案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		初识HTTP HTTP为超文本传输协议，其作用是把超文本数据从网络传输到本地浏览器。
HTTP请求过程 在网址栏输入一个url，按下回车便可观察到对应的页面内容。这个过程是浏览器先向网站所在服务器发送一个请求，网站服务器接收到请求后对其进行处理和分析，然后返回对应的响应，接着传回浏览器。浏览器再对响应里所含的源代码进行解析，最后呈现出来。
开发者界面 在网页中鼠标右击，选择“检查”（或者按下快捷键F12），即可打开浏览器开发者界面，此时切换到Network面板，刷新界面，面板下会出现很多条目，每一条条目就代表一次发送请求和接受响应的过程。
4. 爬虫的基本原理 （1）爬虫概述 获取网页 获取网页源代码
提取信息
分析网页源代码，从中提取我们想要的数据。最通用的方法是正则表达式。
保存数据
将获得的数据保存方便后续使用，存储数据的方式多种多样，可以简单保存为TXT文本或者JSON文本，也可以保存到数据库。
自动化程序
爬虫代替人完成上述操作。
（2）能爬怎样的数据 常规网页，网页对应HTML源代码
网页返回的JSON字符串（API接口大多采用这样的形式）
网页中包含的二进制数据（图片、视频和音频等）
CSS、JavaScript和配置文件等
（3）JavaScript渲染的页面 渲染过程
在浏览器中打开打开页面时，首先加载这个HTML内容，接着里浏览器会发现其中引入了一个app.js文件，便去请求这个文件，获取文件后，执行其中的JavaScript代码，JavaScript会改变HTML中的节点，向其中添加内容，最后得到完整的页面。
爬取思路
一，分析源代码后台Ajax接口
二，使用库函数来模拟JavaScript渲染
电影信息爬取案例 我们要爬取的是一个电影信息网，打开页面如下图
点击电影便会出现电影详情页，点击页码会出现另一页电影。
爬取目标 1.爬取每一页的电影列表，以及顺着列表去爬取每个电影的详情页
2.用正则表达式提取每部电影各种信息
3.将爬取内容保存为表格
分析过程 分析，我们需要获得电影的详情信息，只要获得电影详情页的URL,爬虫爬取详情页，提取信息即可，要获得电影详情页就得从分页列表中获取，所以还得获取每一页列表页的URL。
首先分析每个列表页的URL,在点击页码时，便能获取到不同页码的列表页，所以url信息隐藏在页码节点附近，在站点根页面中，打开开发者工具，观察HTML代码。如下图：
观察规律URL里的数字与页码相对应，将站点根URL与提取的URL结合便构成了列表页完整的URL。URL构造代码如下：
index_url = f'{BASE_URL}/page/{page}' #构造分页的URL 在站点根页面中，打开开发者工具，观察HTML代码。选择一部电影的元素，观察节点，可以得到其对应详情页的URL（/detail/1）,点开详情页观察其完整URL（站点根URL加上文详情页的URL）如下图：
只要将每一页的十个URL信息爬取出来，并与站点根URL结合便可获得所有电影详情页的URL,构造URL使用urljion函数，代码如下：
detail_url = urljoin(BASE_URL,item) 上述分析已经介绍如何获取列表页和详情页的URL，接下来上代码。代码与图片一起食用更美味哦！！
案例代码实现 导入库，初始化参数
import requests import logging #输出信息 import re from urllib.parse import urljoin #做URL的拼接 from openpyxl import Workbook logging.basicConfig(level =logging .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d67a419553b9f44540d000c6e6635def/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/423a873d9c4ef801dba88076ca798381/" rel="bookmark">
			Mysql安装及常用命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、下载安装 下载连接：https://downloads.mysql.com/archives/community/
解压后配置环境变量
1.1、初始化Mysql mysqld --initialize-insecure 1.2、注册Mysql服务 mysqld -install 1.3、启动Mysql服务 net start mysqld 1.4、修改root密码 mysqladmin -u root password 1234//1234为设置的密码 1.5、登录Mysql mysql -uroot -p1234 2、数据库及表操作 # 操作数据库 -- 显示所有数据库 show databases; -- 创建数据库 create database db1; -- 删除数据库 drop database db1; -- 使用数据库 use db2; -- 查询当前正在使用的数据库 select database(); # 表操作 -- 查询当前数据库下所有表 show tables; -- 创建表 create table if not exists tb1( id int, username varchar(30), password varchar(30) ); -- 查询表结构 desc tb2; -- 删除表 drop table tb1; -- 修改表 -- 修改表名 alter table tb1 rename to tb2; -- 添加一列 alter table tb2 add nicename varchar(30); -- 修改数据类型 alter table tb2 modify username char(10); -- 修改列名和数据类型 alter table tb2 change username uname varchar(30) not null; -- 删除列 alter table tb2 drop nicename; 3、数据操作 # 数据操作 -- 给全部列添加数据 insert into tb2(id,uname,password) value(1,"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/423a873d9c4ef801dba88076ca798381/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d45e165d7a18e24893f6946ca9ee4232/" rel="bookmark">
			com.alibaba.nacos.api.exception.NacosException: Request nacos server failed:报错解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 背景解析报错日志 背景 服务注册nacos，版本2.0.4，出现如下错误
解析 看报错可以看出是服务器被拒绝，网上说版本问题可能导致这个问题，不过我的这个不是这种原因引起的；
nacos从2+版本开始，增加了9848，9849端口来进行GRPC通信，所以在使用docker-compose搭建nacos的同时，要额外转发另外两个端口即可：
ports: # 映射端口 - "8848:8848" - "9848:9848" - "9849:9849" 报错日志 21:36:55.037 [main] ERROR c.a.c.n.d.NacosWatch - [stop,178] - namingService unsubscribe failed, properties:NacosDiscoveryProperties{serverAddr='xxxxxx:8848', username='', password='', endpoint='', namespace='', watchDelay=30000, logName='', service='ruoyi-gateway', weight=1.0, clusterName='DEFAULT', group='DEFAULT_GROUP', namingLoadCacheAtStart='false', metadata={preserved.register.source=SPRING_CLOUD}, registerEnabled=true, ip='192.168.1.3', networkInterface='', port=8080, secure=false, accessKey='', secretKey='', heartBeatInterval=null, heartBeatTimeout=null, ipDeleteTimeout=null, instanceEnabled=true, ephemeral=true, failureToleranceEnabled=false}, ipDeleteTimeout=null, failFast=true} com.alibaba.nacos.api.exception.NacosException: Request nacos server failed: at com.alibaba.nacos.client.naming.remote.gprc.NamingGrpcClientProxy.requestToServer(NamingGrpcClientProxy.java:290) at com.alibaba.nacos.client.naming.remote.gprc.NamingGrpcClientProxy.doUnsubscribe(NamingGrpcClientProxy.java:260) at com.alibaba.nacos.client.naming.remote.gprc.NamingGrpcClientProxy.unsubscribe(NamingGrpcClientProxy.java:241) at com.alibaba.nacos.client.naming.remote.NamingClientProxyDelegate.unsubscribe(NamingClientProxyDelegate.java:157) at com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d45e165d7a18e24893f6946ca9ee4232/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5bd1ed067914ac4285bde6ef4ef6535b/" rel="bookmark">
			C语言关于输入数字后再次输入字符串的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		例如:要求删除一个字符串（不含空格符）中指定下标的字符。第一行输入字符串组数，第二行输入第一组字符串，下一行输入要删除的字符下标。
样例输入：
2
abcdef
0
ABCDE
2
输出
bcdef
ABED
在C语言中先scanf输入一个整型变量后，再次输入字符串会导致字符串无法正常输出，要在每个数字输入以后用一个getchar（）消除缓冲区里的回车，或者用fflush（stdin）将缓冲区清空。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fba82838958da065a791c9ddc96bd3a6/" rel="bookmark">
			Awesome Gait Recognition-步态识别公开资源库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		步态识别资源开源项目（https://github.com/BNU-IVC/Awesome-Gait-Recognition）点击Github
（按时间顺序整理了从早期到目前的步态识别相关研究）
基于外表的步态识别基于模型的步态识别步态识别数据库步态识别综述步态识别教程步态识别框架步态识别比赛
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/999f821020de29185873af6074ce5cc9/" rel="bookmark">
			关于返回数组{…}, {…}, {…}, __ob__: Observer的取值使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先来贴个图：
后端的数据结构是这样的，展开来就是
我的目的是获取这个imagesList数组，然后在HTML上面用v-for循环出每一张图片。
按照以前的步骤，
在data中定义一个接收数组：
然后请求成功之后直接赋值：
但是，最后发现这个imaList数组返回的事underfind ,后面发现加上索引才可以取到每一个imagesList里面的image_url，但是我要的是将这个数组都获取到怎么办呢？
网上主要有两种方法：
1、使用同步请求数据
2、使用JSON.parse(JSON.stringify(this.momentsList[i].imagesList))。
但是，还是不能解决我的问题，虽然方法2能够输出
但是，怎么用渲染到页面上呢？
考虑到我的页面设计是一个嵌套的数组，所以整个代码如下：
这样效果就出来了，所以这里想说的是，如果已经获取到整个的数组了，就直接在标签上使用“：src”绑定数据。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d18056cba80a2027ab63c60c8ac0472/" rel="bookmark">
			CSS基础之省略号的制作（单行&amp;多行）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		应用场景： 例如：相信很多小伙伴在初学css绘制页面时，都会遇见文本超出指定区域，用...代替的情况；下面详细为大家介绍了单行文本如何制作省略号以及多行文本如何制作省略号
单行文本制作省略号 实现效果：
单行文本制作省略号 实现效果：
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;style&gt; .box{ height: 300px; //1.设置元素的宽度为300像素，可根据实际需要进行调整 width: 300px; background-color: aqua; //2.设置不换行 white-space: nowrap; //3.超出隐藏 overflow: hidden; //4.文本超出绘制小黑圆点（省略号） text-overflow: ellipsis; } &lt;/style&gt; &lt;body&gt; &lt;div class="box"&gt;Lorem ipsum dolor sit amet consectetur adipisicing elit. Sequi ab neque earum, molestias quos excepturi nihil cupiditate ex esse perferendis? Cum necessitatibus est nostrum consectetur error quidem distinctio deleniti natus.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d18056cba80a2027ab63c60c8ac0472/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51aa6cbf2deeb6080076ab586d9ccf1b/" rel="bookmark">
			Xcap安装和简单使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		xcap是一个免费的网络发包工具，可以使用xcap制造和发送报文，不如比较常用的arp、IP、icmp、udp、tcp等 一、xcap安装
安装xcap
打开压缩包，双击xcap.exe，如果显示报错：未安装winpcap话，点击winpcap_4_1_3.exe安装后再双击xcap.exe
winpcap版本太低也会报错，WinPcap下载链接：https://www.winpcap.org/install/default.htm
二、xcap工具简单使用
1、xcap构造报文
1.1 创建报文首先要创建报文组，点击报文组-创建报文组，输入报文组名称
1.2 可以看到报文组上方有几个图标，依次为：增加、删除、拷贝、分片、复制、粘贴、向上移动、向下移动、发送选中的报文(鼠标选中的)、循环发送报文组(复选框选中的)
1.3 点击新建报文，双击刚刚新建的报文进行设置，以ARP为例：
1.4 输入源目的MAC，可以设置MAC固定、增加、减少（循环发送的时候可以根据需求看是否修改）
1.5 ARP包中的字段内容
1.6报文长度设置
1.7点击保存后，如图
在发送报文时，选择多个报文，可以按住ctrl键就可以进行多选
发送间隔表示报文每隔多少时间发送一次，也可以输入“1000/3”则表示每1000ms发送3次
循环即一直发送；限制即指定发送次数；递增/递减即在执行过程中是否执行递增递减策略（数据包中的设置）
速率显示：显示发送的总时间，发送的次数，以及pps和kb/s的值
1.8 在客户端使用wireshack抓包可看到制作的数据包已发送，也有回包
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52bf6409e133dd92affce73f965f4d4f/" rel="bookmark">
			Flink之教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		全文完全由chatGPT生成，不对文中的正确性和严谨性作出保证，仅供参考。
Flink是一个流处理引擎，它提供了快速、可扩展的流处理和批处理能力。本教程将介绍Flink的基本概念、架构、数据处理模式和常用API，并提供详细的案例和图片。
基本概念 流和批处理 在Flink中，有两种数据处理模式：流处理和批处理。流处理是指实时处理无限流数据的过程，而批处理是指处理有限大小的数据集的过程。
任务和作业 Flink中的任务是指一个具体的数据处理操作，比如对数据进行过滤、转换或聚合等。而作业则是由多个任务组成的数据处理流程。
窗口 在流处理中，窗口是将无限流数据分为有限大小的块的一种方式。窗口可以基于时间或者数据量来定义，比如每5秒或者每100个元素为一个窗口。
状态 Flink中的状态是指在数据处理过程中需要保存的中间结果。状态可以是键控状态，也可以是操作符状态。
时间 Flink中的时间分为三种：事件时间、处理时间和摄取时间。事件时间是数据产生的时间，处理时间是数据到达Flink时的时间，而摄取时间是Flink接收数据的时间。
架构 Flink的架构可以分为四层：API、运行时、资源管理和外部集成。
API Flink的API层包括批处理API、流处理API和Table API。批处理API是基于DataSet的，而流处理API是基于DataStream的。Table API是一种SQL-like的API，可以将数据流转换为表格形式进行处理。
运行时 Flink的运行时层包括核心引擎、执行引擎和状态后端。核心引擎负责作业的调度和管理，执行引擎负责任务的执行，而状态后端则负责状态的管理和持久化。
资源管理 Flink的资源管理层包括任务管理器和资源管理器。任务管理器是Flink中的工作节点，负责执行具体的任务，而资源管理器则负责分配和管理任务管理器的资源。
外部集成 Flink可以与各种外部系统进行集成，比如Kafka、Hadoop、HBase等。
常用API 批处理API Flink的批处理API基于DataSet，其中最常用的操作包括map、flatMap、filter、reduce、groupBy等。下面是一个示例代码：
val env = ExecutionEnvironment.getExecutionEnvironment val data = env.fromElements(1, 2, 3, 4, 5) val result = data.filter(_ &gt; 2).map(_ * 2).reduce(_ + _) result.print() 上述代码中，我们创建了一个批处理的执行环境，然后从一个包含1到5的集合中创建了一个DataSet，并对其进行了过滤、映射和聚合操作，最后打印结果。
流处理API Flink的流处理API基于DataStream，其中最常用的操作包括map、flatMap、filter、keyBy、window、reduce等。下面是一个示例代码：
val env = StreamExecutionEnvironment.getExecutionEnvironment val data = env.socketTextStream("localhost", 9999) val result = data.flatMap(_.split("\\s+")).filter(_.nonEmpty).map((_, 1)).keyBy(0).sum(1) result.print() env.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/52bf6409e133dd92affce73f965f4d4f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/575c7267c7dd2a59c05176b91f9bbe2d/" rel="bookmark">
			uniapp刷新页面后使用uni.navigateBack()无法返回上个页面,h5端页面刷新之后页面栈会消失，此时navigateBack不能返回
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 h5端页面刷新之后页面栈会消失，此时navigateBack不能返回，如果一定要返回可以使用history.back()导航到浏览器的其他历史记录。
let canNavBack = getCurrentPages() if( canNavBack &amp;&amp; canNavBack.length&gt;1) { uni.navigateBack() } else { history.back(); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2754f99402dce5090aa34c8e774486b/" rel="bookmark">
			WSL(Windows Subsystem for Linux)忘记用户密码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		进入root wsl.exe --user root 查看当前用户是否是root whoami 修改xxxx用户密码passwd xxxx 退出root，进入xxxx用户su xxxx 参考：
修改密码步骤: https://zhuanlan.zhihu.com/p/387283272
切换用户:https://blog.csdn.net/weixin_42504649/article/details/116605201
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38c5f94b214f20be486fb61fedc42d0a/" rel="bookmark">
			前端打印界面某个部分
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、window.print() 趋向于打印整个界面，且界面打印后需要重载原界面，否则原界面的所有事件将不再生效，打印方式简单
2、使用iframe进行截图打印 可以满足更加复杂的打印需求，且兼容IE9及以上浏览器及各大主流浏览器，打印完后不用刷新原浏览器界面
（1）安装html2canvas：npm i html2canvas --save 使用html2canvas插件将需要打印的html转化成canvas，再将canvas转为base64图片；
（2）动态创建iframe，将图片放入iframe中，打印iframe即可 此种方法既打印了我们所需要的html元素，保留了其样式，也无需刷新原浏览器界面。
/** * @function: 使用iframe打印指定html * @pramas: printDom: 打印的dom区域 **/ import html2canvas from 'html2canvas' export function printHtml (printDom) { // html2canvas将当页面渲染成一个Canvas图片，通过读取DOM并将不同的样式应用到这些元素上实现 html2canvas(printDom).then((canvas) =&gt; { const imgSrc = canvas.toDataURL('image/png') // 把canvas转为base64图片 const iframe = document.createElement('IFRAME') iframe.setAttribute('style', 'width:0px;height:0px;') // 设置iframe不可见 document.body.appendChild(iframe) const printObj = iframe.contentWindow const doc = printObj.document doc.open() // 将目标区域的html写入iframe doc.write(`&lt;img id="imgDom" src="${imgSrc}" alt=""&gt;`) // 必须加上，不然ie没发调出打印的弹框,关闭iframe，释放内存，防止内存泄漏 doc.close() // 样式插入进去 const style = doc.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/38c5f94b214f20be486fb61fedc42d0a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7f3e38f55b69245f6c01e0381682306/" rel="bookmark">
			对信号做降采样处理时，需要先滤波，后抽取（降采样）；升采样操作与之相反
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、对信号做降采样处理时，需要先滤波，后抽取（降采样）的原因解释：
一句话就能概括，如果抽取时不先做滤波，就会导致信号混叠，这里的滤波器是抗混叠滤波器。
1、如果不滤波，为什么混叠？
因为抽取后的信号频谱将以新的采样率fs为周期做频谱的延拓。
2、为什么降采样，信号频谱会延拓？
这貌似才是问题的根结，原因其实也很好解释。时域离散化会导致频域的周期化；频域离散化会导致时域的周期化
首先，假设你要处理的信号，它长这样：
假设它在频域上，长这样：
你想处理这段信号，当然先需要通过AD采样，于是AD转换为数字信号，它从时域上看就变成了这样了：
根据“时域是离散的意味着频域是周期的”，这里的周期指的就是采样频率，就是上面那个图里面T1的倒数。现在信号在频域上可就不是原来那个样子了，而是变成这个样子：
对AD采完的离散信号，我们进行抽取处理，完全可以理解成对一段已经离散的信号，再进行一次“离散处理”：
也就是说，原本周期性的频域信号，将继续“周期”一把，于是又发生了变化：
这是什么鬼？这就是所谓的混叠啊！所以赶紧的，在抽取前赶紧滤波，滤的只剩下一个“三角形”当然就不会混成这个鬼样子了。
当然也有一些聪明的小伙伴也会问，如果这个三角形的底足够窄（带宽足够小），抽的没那么狠，是不是就不会叠成这么难看了。理论上说，的确存在这种不滤波也不会混叠的情况。
但是现实中，频域上除了三角形，也会在没有三角形的地方会有一些乱七八糟的谐波啊、噪声啊什么的，所以机智的信号处理工程师们就会非常谨慎的不管什么咋地，先滤波再说！
滤波了之后，三角形被削成了竹笋，这时候再抽一把，就没那么凌乱:
二、对信号做升采样处理时，需要先对信号进行插值（升采样），然后进行滤波操作的原因解释：
这里的滤波器称为抗镜像滤波器，不同于抗混叠滤波器的是，抗镜像滤波器则是必须要进行的操作，即插值完必须进行抗镜像滤波操作。这是因为直接进行插值后，采样率变大，原始的频谱的镜像会在其他地方（出现在K×fs处）。整个增采样过程如下：
实际上，插值操作就是在两个信号点之间插入若干个0值，这样的过程就导致了频谱的周期延拓，为了让插值之后的波形依然平滑，此时就需要在插值之后进行平滑滤波，因此实际上抗镜像滤波也可称之为平滑滤波器（个人观点）。理论上的周期延拓频谱可以有具体公式去推导，而直观上解释为啥会出现对应的插值之后就会出现高频部分的信号，可以观察x（m），从原来的两点信号中插入若干0值，这样从实际信号间从有值到0值或者从0值到有值，信号发生突变，而信号的突变就意味着信号包含丰富的高频信息（如图像的边缘、孤立点，还有矩形波）。这就出现了高频频谱，而具体高频频谱以何种方式展现，出现在具体的那些频率则需要公式进行推导了。
三、为什么需要进行降采样和升采样的过程
直接原因当然是采用了高采样率的ADC和DAC，那为什么要用高采样ADC和DAC，答案是降低模拟滤波器（模拟抗混叠滤波器和抗镜像滤波器）的成本。评价滤波器的好坏有很多指标，对于模拟滤波器来说，很容易知道过渡带越窄，滤波器越陡，阻带衰减越大，滤波器阶数则越高，而越高阶数则意味着模拟滤波器越昂贵，甚至到几乎不可能实现。因此模拟滤波器的过渡带就需要设计宽一些，越宽则意味阶数越低，越容易实现，越便宜。而宽过渡带则意味着需要更高采样率的ADC，因此ADC采样率越高，越可以降低模拟前端的设计要求。
参考文献：
https://www.zhihu.com/question/23474073
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31a2706418e8401b0bc6f1633b5b5546/" rel="bookmark">
			Unity 优化之灯光
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		灯光 Shadow Type 阴影的类型: 1，No Shadows：无阴影，不显示阴影
2，Soft Shadows：软的阴影，比较耗性能，抗锯齿较小
3，Hard Shadows:硬的阴影，耗性能较小，抗锯齿较大
Lightmapping Windowns-&gt;Rendering-&gt;Lighting(Scnen)
Mixed Lighting Lighting Mode 这里要先说明下Project Setting-&gt;Quality-&gt;Shadow Distance这里设置的模型到摄像机的距离。
其次在模型能产生阴影和灯光产生阴影时，灯光设置Baked模式时都会在lightmapping产生阴影。
最后：以下模式是在灯光设置成Mixed 时生效
Baked Indirect 模式时
在Shadow Distance距离内静态模型用实时光，否则使用lightmapping阴影。
Shadowmask与Subtractive
不受Shadow Distance距离影响都采用lightmapping阴影。
区别参考下图：Subtractive
Lightmapping Settings
Lightmapper 使用什么硬件渲染分GPU 和 CPU ，默认是CPU ，但是CPU 慢，我们这里一般选择 GPU 。GPU 一般能比CPU 快10-50倍，具体要看显卡的性能。
Prioritize View： 勾选后会优先渲染视窗内看到的部分(通过这个方式，我们可以快速预览Scene窗口当前画面的间接光照信息，及时做出相应修改)
Multiple ImportanceSampling：（默认是禁用状态）这是针对环境光采样的设置。如果开启，可以缩短光照贴图的生成时间，但是在场景中某些较暗的地方会产生明显的噪点。
Direct Samples：用于设置从每一个纹素（Texel）射出的采样路径数（针对直接光照）。数值越大效果越好，烘焙时间也越长。
间接光采样数 ，影响间接光照烘焙质量，数值越大效果越好，烘焙越慢，这个值一般是 DirectSamples 的10倍，建议预览时用小值，最终烘焙时用大值
Environment Samples：针对环境光的采样数。数值越大效果越好，烘焙时间也越长。默认数值为500。
Light Probe SampleMultiplier：如要使用此功能，必须在Project Settings &gt; Editor&gt; Graphics中禁用Use legacy Light Probe sample counts，如下图所示：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/31a2706418e8401b0bc6f1633b5b5546/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e2fa877c51791df609d694d12b3fea7/" rel="bookmark">
			【FPGA】 十二、Vivado DDS IP核实现扫频信号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录
前言
一、DDS IP核概述
二、DDS IP核配置
三、调用DDS IP核
总结
前言 在我前面的工程中，都是一些比较通用的设计工程，没有用到哪一家的IP核，所以代码具有很好的移植性；今天我就来讲一下基于Xilinx厂家的芯片做一期DDS的设计与验证，这里我所采用的EDA工具是Vivado 2018.3，里面集成了DDS的IP核，我们直接进行调用即可。
Xilinx公司是FPGA的主要生产商，即使在现在的FPGA领域它都有着很大的话语权，目前市面上的FPGA芯片主要有Xilinx和Altera两家，其中Xilinx占据主导地位，其产品在各个方面的应用更是炉火纯青。我们都知道FPGA的优点是基于它的可编程性，使得其开发周期短，但为了提升FPGA开发的周期性，各家都提供了一些通用功能的IP核，包括固化在芯片内的硬IP核和可编程调用的软IP核，并在开发工具中提供了IP和的实例化和调用功能，下面我就在Vivado中调用DDS IP核来进行设计。 一、DDS IP核概述 上图是DDS IP核的方案图，从图中我们可以看到DDS IP核主要由5部分组成，其中DDS IP核的核心是相位累加器和LUT查找表，它们可以独立使用，也可与一个可选的相位发生器一起使用。相位累加器实现查找表地址的产生，LUT查找表用来存储输出波形。还有泰勒级数矫正模块和抖动产生器，用来改善SFDR。最两边是AXI4接口，是基于AXI4总线协议的接口模块，用来实现相位累加字配置，多通道配置以及相位累加器输出和sin/cos波形输出。
二、DDS IP核配置 1、首先创建一个工程文件，然后点击IP Catalog，直接在搜索框中搜索DDS，创建DDS IP核。
2、 然后双击DDS Compiler，进行DDS IP核的配置界面。
DDS IP核可以配置成三种模式，分别是相位累加器和SIN/COS LUT模式、仅相位产生器模式、仅SIN/COS LUT模式；这里我们选择第一种相位累加器和SIN/COS LUT模式。
输入时钟：根据系统时钟定，我这里选择100MHz
通道数：我这里选择单通道
参数选择有系统参数（System Parameter）和硬件参数（Hardware Parameter）两种，当选择系统参数时，需要根据频率位宽来计算SFDR和FR(频率控制字）；当选择硬件参数时，直接定义输出的相位宽度和频率宽度即可，我这里选择硬件参数，相位位宽是32位，频率位宽是8位。
根据Xilinx官方手册，phase width(相位位宽)，Frequency Resolution(频率分辨率)，channels(通道数)，output width(输出波形位宽)，SFDR之间的对于关系为：
关于output width的位宽不同，输出的数据格式如下：
3、进入第二页配置界面，配置频率控制字、相位控制字和输出波形。
由于在本次实验中需要连续输出不同的频率信号，达到一个扫频的目的，所以这里将频率可控制字和相位控制字都设置为可编程模式，输出的波形为正余弦波形。如果你想输出固定频率的波形，就可以选择锁定模式。这个根据实验要求进行更改即可。
4、第三页和第四页本次实验没有要求，保持默认即可。在第四页，由于频率控制字是可编程的，在代码中会进行改变，这里就不用做任何处理。
5、第5页就是配置的总览界面了，在这里你可以看到你所配置的信息，方便查看配置是否有问题。
6、最后点击OK就生成DDS IP核了，然后就将DDS IP核例化到我们所设计的工程当中，就可以直接使用了。
三、调用DDS IP核 调用DDS IP核实现扫频信号，我这里设计的扫频范围是1KHz--10KHz，通过控制频率控制字来更改输出的波形的频率，让其在1KHz到10KHz直接变化，又让其从10KHz变化到1KHz，展现在频域中是三角波的形式。
1、顶层模块
`timescale 1ns / 1ps // // // Create Date: 2023/03/16 09:54:38 // Design Name: 卡夫卡与海 // Module Name: DDS_top // Project Name: DDS顶层模块 // // // module DDS_top( input sys_clk ,//系统时钟 100MHz input sys_rst_n ,//系统复位 output m_data_tvalid ,//数据有效标志 output [7:0] m_data_sin ,//sin波形 output [7:0] m_data_cos //cos波形 ); //中间信号定义 wire s_phase_tvalid ;//相位有效标志 wire [31:0] s_phase_tdata ;//相位控制字 wire s_config_tvalid ;//频率有效标志 wire [31:0] s_config_tdata ;//频率控制字 wire m_phase_tvalid ;//输出相位有效标志 wire [31:0] m_phase_tdata ;//输出相位 wire [15:0] m_data_tdata ;//输出为16位，高8位是sin波形，低8位是cos波形 //assign m_data_sin = m_data_tdata[15:8]; //assign m_data_cos = m_data_tdata[7:0]; assign m_data_sin = {~m_data_tdata[15],m_data_tdata[14:8]};//将输出转为有符号数据输出 sin assign m_data_cos = {~m_data_tdata[7],m_data_tdata[6:0]} ;//将输出转为有符号数据输出 cos //模块例化 //DDS_IP模块 dds_compiler_0 u_dds_0 ( .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e2fa877c51791df609d694d12b3fea7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe5b1b2df6d9397d15a5f604cef1dacc/" rel="bookmark">
			Centos镜像国内最全下载地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CentOS 官方下载地址：https://www.centos.org/download/
Centos国内下载源
http://man.linuxde.net/download/CentOS
http://mirrors.btte.net/centos/7/isos/x86_64/
http://mirrors.cn99.com/centos/7/isos/x86_64/
http://mirrors.sohu.com/centos/7/isos/x86_64/
http://mirrors.aliyun.com/centos/7/isos/x86_64/
http://centos.ustc.edu.cn/centos/7/isos/x86_64/
http://mirrors.neusoft.edu.cn/centos/7/isos/x86_64/
http://mirror.lzu.edu.cn/centos/7/isos/x86_64/
http://mirrors.163.com/centos/7/isos/x86_64/
http://ftp.sjtu.edu.cn/centos/7/isos/x86_64/
CentOS 提供了三种ISO镜像文件的下载：
DVD ISO 标准安装版，一般下载这个就可以了（推荐）
Everything ISO 对完整版安装盘的软件进行补充，集成所有软件。（包含centos7的一套完整的软件包，可以用来安装系统或者填充本地镜像）
Minimal ISO 精简版，自带的软件最少
以下针对各个版本的ISO镜像文件，进行一一说明以7版本为例：
CentOS-7.0-x86_64-DVD-1503-01.iso 标准安装版，一般下载这个就可以了（推荐） CentOS-7.0-x86_64-NetInstall-1503-01.iso 网络安装镜像（从网络安装或者救援系统） CentOS-7.0-x86_64-Everything-1503-01.iso 对完整版安装盘的软件进行补充，集成所有软件。（包含centos7的一套完整的软件包，可以用来安装系统或者填充本地镜像） CentOS-7.0-x86_64-GnomeLive-1503-01.iso GNOME桌面版 CentOS-7.0-x86_64-KdeLive-1503-01.iso KDE桌面版 CentOS-7.0-x86_64-livecd-1503-01.iso 光盘上运行的系统，类拟于winpe CentOS-7.0-x86_64-minimal-1503-01.iso 精简版，自带的软件最少 转载于CSDN
原链接：https://blog.csdn.net/weixin_42430824/article/details/81019039
作者CSDN：Xcn_小企鹅
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac462feffafabaf98bf23965243e6844/" rel="bookmark">
			registerForActivityResult 报错：LifecycleOwners must call register before they are STARTED.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Intent intent = new Intent(MainActivity.class, BActivity.class); registerForActivityResult(new ActivityResultContracts.StartActivityForResult(), result -&gt; { Log.e("TAG", result.getData().toString()); }).launch(intent); 报错信息：LifecycleOwners must call register before they are STARTED.
java.lang.IllegalStateException: LifecycleOwner com.example.demo.MainActivity@324a655 is attempting to register while current state is RESUMED. LifecycleOwners must call register before they are STARTED. at androidx.activity.result.ActivityResultRegistry.register(ActivityResultRegistry.java:123) at androidx.activity.ComponentActivity.registerForActivityResult(ComponentActivity.java:682) at androidx.activity.ComponentActivity.registerForActivityResult(ComponentActivity.java:691) 解决方案：
先在onCreate 中声明： @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); mActivityResult = registerForActivityResult(new ActivityResultContracts.StartActivityForResult(), result -&gt; { Log.e("TAG", result.getData().toString()); }); } 然后再去跳转的时候调用 mActivityResult.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac462feffafabaf98bf23965243e6844/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3048d3304df42d5c774b2e575b4c4912/" rel="bookmark">
			vben admin框架 useForm 时间选择器固定填入实时时间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 vben admin框架 useForm 时间选择器固定填入实时时间 时间表单时间默认显示一天区间，且从前一天的 00：00：00到当前日期的23：59：59
例如（2023-03-17 00：00：00 2023-03-17 23：59：59）
import moment from 'moment'; { field: '[startOperationDate,endOperationDate]', label: '日期查询', colProps: { span: 12 }, component: 'RangePicker', defaultValue: [moment().subtract('day').format('YYYY-MM-DD 00:00:00'), moment().endOf('day')], componentProps: { valueFormat: 'X', showTime: { defaultValue: [moment('00:00:00', 'HH:mm:ss'), moment('23:59:59', 'HH:mm:ss')], }, }, }, 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5010d6e9234c16cf951420eb2a637590/" rel="bookmark">
			BUUCTF MISC 61-80
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		61、 打开题目给的TXT文件发现很像文件的十六进制，导入010查看一下，发现是一个rar文件
将文件另存为rar得到一个加密的压缩包，无任何提示，先尝试四位纯数字爆破
得到一张无法打开的图片，放入010查看
校验发现不是PNG文件，既然文件头有问题，尝试看一下文件尾FF D9
明显是JPG文件尾（PNG文件尾：AE 42 60 82），于是修改文件头为FF D8 FF
62、你能看懂音符吗 题目给出的压缩包无法打开，使用010查看文件
发现文件头格式顺序错误，RAR的文件头为52 61 72 21 1A 07 00（文件尾一般为C4 3D 7B 00 40 07 00）
正常打开后得到一个Word文档，打开后没有有效信息
尝试用formost提取，得到很多文件
在document.xml文件中发现一串奇怪的音符
使用音符在线解密即可
♭♯♪‖¶♬♭♭♪♭‖‖♭♭♬‖♫♪‖♩♬‖♬♬♭♭♫‖♩♫‖♬♪♭♭♭‖¶∮‖‖‖‖♩♬‖♬♪‖♩♫♭♭♭♭♭§‖♩♩♭♭♫♭♭♭‖♬♭‖¶§♭♭♯‖♫∮‖♬¶‖¶∮‖♬♫‖♫♬‖♫♫§=
63、caesar 题目提示凯撒加密，尝试用大佬的穷举脚本跑一下
def change(c,i): num=ord(c) if(num&gt;=33 and num&lt;=126): num=33+(num+i-33)%(94)#126-33=93 return chr(num) def kaisa_jiAmi(string,i): string_new='' for s in string: string_new+=change(s,i) print(string_new) return string_new #本题有种暴力解密感觉 def kaisa_jiEmi(string): for i in range(0,94): print('第'+str(i+1)+'种可能:',end=' ') #区别在于 string 是该对象原本就是字符串类型, 而 str()则是将该对象转换成字符串类型。 kaisa_jiAmi(string,i) #你要知道input输入的数据类型都是string def main(): print('请输入操作，注意不是平常26种:') choice=input('1:恺撒加密,2:凯撒穷举解密.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5010d6e9234c16cf951420eb2a637590/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb6471cff286c3cef08dbec3433006c8/" rel="bookmark">
			IPv4、IPv6地址、组播地址及子网子划分详解一
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IPv4、IPv6地址、组播地址及子网子划分详解一 一、IPv4地址1、IP地址的定义2、IP术语3、IP地址的组成3.1、我们前面讲到IP地址是软件地址，那硬件地址是什么？3.2、IP地址的编址方案4、IP地址的分类4.1、网络地址4.2、保留的IP地址4.3、私有IP地址4.4、组播地址4.4.1、什么是组播？4.4.2、保留的永久组播地址（属于局部链路组播地址范围）：4.4.3、用于在互联网上组播地址（包含在用户组播地址范围内）：4.4.4、本地管理组播地址 一、IPv4地址 1、IP地址的定义 IP地址是分配给IP网络中每台机器的数字标识符，它指出了设备在网络中的具体位置。由 32 位二进制数组成。IP地址是软件地址，而不是硬件地址。
在因特网中给每台电脑设备和其它设备都配置一个唯一的地址，才能正常通信，使数据能正常的转发。在 TCP/IP 通信中使用 IP 地址识别主机和路由器。
举例：IP地址如每个人的手机号，我们进行通信时就能通过这个唯一的号码，准确的联系到需要找的人。
2、IP术语 比特(bit)：
一个比特相当于一位，取值为1或0。
字节(Byte)：
8bit就称为一个字节，字节包含8位。CPU位数指的是CPU一次能处理的最大位数。例如32位计算机的CPU一次最多能处理32位数据。
项目11111111二进制12864321684212的n次幂2⁷2⁶2⁵2⁴2³2²2¹2° 半字节：半字节包含4位，十六进制使用半字节。
项目1111二进制84212的n次幂2³2²2¹2° 八位组(Octet)：
由8位组成，是普通的8位二进制数。网络地址：
是设备所在区域的一种标识，网络地址相同的设备位于同一个网段内。广播地址：
是专门用于同时向网络中所有工作站进行发送的一个地址。在使用TCP/IP 协议的网络中，主机位段二进制全为1的IP 地址为广播地址。举例：常见的是有255.255.255.255，在一个局域网内所有的节点，包含路由器和交换机、主机等设备。 3、IP地址的组成 3.1、我们前面讲到IP地址是软件地址，那硬件地址是什么？ 硬件地址也称为MAC地址，固化在每个设备中的网卡使用，MAC地址长48位，采用十六进制格式，比如：00-12-BC-ED-3A-68。MAC地址基于物理的，能够识别具体网络设备，它是固化在网卡里面的。在命令提示符下输入命令“ipconfig /all”回车之后可以查看到MAC地址。
第一字节第8位为I/G位：如果I/G=0，则是某台设备的MAC地址，即单播地址；如果I/G=1，则是多播地址（组播+广播=多播）。
第一字节第7位为G/L位，也称为U/L位，如果G/L=0，则是全局管理地址，由IEEE分配；如果G/L=1，则是本地管理地址，是网络管理员为了加强自己对网络管理而指定的地址。
注意：十六进制是由两个半字组成一个字节。
这里讲硬件地址有什么作用？我们要明白，网络传输是通过一个个的硬件进行数据转发，比如我们访问百度能过域名解析成IP地址，由我们的本机网卡到达路由器进入运营商网络再进入百度服务器，通过一个个具体的硬件进行转发。
就如我们的手机号可以通过运营商随时更换或者使用双卡双号，手机是物理硬件，IP地址可以比作手机号，而MAC地址如手机的机器码，通过软件来识别具体的手机，是不常更换的，机器码代码表示我们手中这一台手机，是唯一的一台没有其它编码一样的手机。
3.2、IP地址的编址方案 IP地址长32位，划分成4组，每组8位，每组以“ . ”隔开，再将每组数转换为十进制数。
分类IP地址点分十进制划分172.16.10.6二进制10101100.00010000.00001010.00000110十六进制AC.10.0A.06 十六进制方式表示IP地址，是某些程序使用这种方式储存IP地址，Windows注册表就是以十六进制方式储存IP地址。
IP地址二进制转换成十进制
2⁷＝128 2⁶＝64 2⁵＝32 2⁴＝16 2³＝8 2²＝4 2¹＝2 2°＝1
类型内容内容内容内容二进制101011000001000000001010000001108421方式计算2⁷＋2⁵＋2³＋2²2⁴2³＋2¹2²＋2¹十进制17216106 二进制与十进制最方便转换方法：
通过 Windows 系统自带的计算器，选择程序员，可实现二进制和十进制的快速转换。默认十进制（“ DEC ”）输入，单击“ BIN ”切换成二进制输入。同步显示十六进制、十进制、八进制和二进制的数值。
2³²＝4,294,967,296
2019 年 11 月 25 日已分配完公网 IPv4 地址，以后就没有多余地址可以分配了。但是现在很多用户仍然还在用 IPv4 ，并没有因为地址没了而无法上网。这是因为使用 NAT 技术缓解了地址不足的问题。后面部分将详解IPv6地址。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb6471cff286c3cef08dbec3433006c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/723b0e203cc969cb9dd9a68be81e8080/" rel="bookmark">
			全面解读Java的23种设计模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java语言在使用设计模式时有很多可供选择的模式，其中最常用的是23种设计模式。在本文中，我将对Java中的这23种设
Java的23种设计模式 Java中的23种设计模式主要分为三类：
创建型模式：主要解决对象创建问题结构型模式：主要解决对象组合问题行为型模式：主要解决对象之间的交互问题 创建型模式 Java中的创建型设计模式主要用于对象的创建和组装。这些模式通过抽象化和解耦对象的创建过程，可以使系统更加灵活和可扩展。下面是Java中的5种创建型设计模式：
单例模式：确保一个类只有一个实例，并提供一个全局访问点。
工厂模式：在不暴露创建对象的逻辑的前提下，使用工厂方法来创建对象。
抽象工厂模式：提供一个接口，用于创建相关或依赖对象的系列，而不需要指定实际实现类。
建造者模式：将复杂对象的构建与表示分离，使得同样的构建过程可以创建不同的表示。
原型模式： 通过克隆来创建对象，避免了通过new关键字显式调用构造函数的开销。
结构型模式 Java中的结构型设计模式主要用于描述对象之间的关系，包括类和对象的组合、接口和继承等方面。这些模式可以帮助我们更好地组织和管理代码，提高代码的重用性和可维护性。下面是Java中的7种结构型设计模式：
适配器模式：将一个类的接口转换成客户希望的另一个接口，使得原本由于接口不兼容而无法一起工作的类可以一起工作。
桥接模式：将抽象部分与它的实现部分分离，以便它们可以独立地变化。
组合模式：将对象组合成树形结构以表示“部分-整体”的层次结构，使得客户端使用单个对象或者组合对象具有一致性。
装饰器模式：动态地给一个对象添加一些额外的职责，就增加功能而言，装饰器模式比生成子类方式更为灵活。
外观模式：为子系统中的一组接口提供一个一致的界面，使得子系统更容易使用。
享元模式：运用共享技术来有效地支持大量细粒度对象的复用。
代理模式：为其他对象提供一种代理以控制对这个对象的访问。
行为型模式 Java中的行为型设计模式主要用于描述对象之间的通信和协作方式，包括算法、责任链、状态等方面。这些模式可以帮助我们更好地组织和管理代码，提高代码的可维护性和可扩展性。下面是Java中的11种行为型设计模式：
责任链模式：为解除请求的发送者和接收者之间的耦合，而将请求的处理对象连成一条链，并沿着这条链传递请求，直到有一个对象处理它为止。
命令模式：将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。
解释器模式：给定一个语言，定义它的文法的一种表示，并定义一个解释器，使用该解释器来解释语言中的句子。
迭代器模式：提供一种方法顺序访问一个聚合对象中各个元素，而又不需要暴露该对象的内部表示。
中介者模式：用一个中介对象封装一系列的对象交互，使得这些对象不需要显示地相互引用，从而降低耦合度。
备忘录模式：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。
观察者模式：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动更新。
状态模式：允许一个对象在其内部状态发生改变时改变其行为，对象看起来似乎修改了它的类。
策略模式：定义一系列的算法，将每个算法封装起来，并使它们之间可以互换。
模板方法模式：定义一个操作中的算法骨架，将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下重新定义算法中的某些步骤。
过滤器设计模式：允许在不改变原始对象的情况下，动态地添加或删除对象的行为。
设计原则与设计模式 在了解完设计模式之后，我们再来了解下:六大设计原则
单一职责原则：一个类应该只有一个引起它变化的原因。换句话说，一个类应该只有一项职责。这样可以保证类的内聚性，并且降低类之间的耦合性。
开闭原则：一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。这意味着当需要添加新功能时，应该尽量通过扩展已有代码来实现，而不是修改已有代码。
里氏替换原则：子类应该能够替换父类并且不影响程序的正确性。这意味着在使用继承时，子类不能修改父类已有的行为，而只能扩展父类的功能。
接口隔离原则：客户端不应该依赖于它不需要的接口。一个类应该只提供它需要的接口，而不应该强迫客户端依赖于它不需要的接口。
依赖倒置原则：高层模块不应该依赖于低层模块，它们都应该依赖于抽象。抽象不应该依赖于具体实现，而具体实现应该依赖于抽象。
迪米特法则：一个对象应该对其他对象保持最少的了解。换句话说，一个对象只应该与它直接相互作用的对象发生交互，而不应该与其它任何对象发生直接的交互。这样可以降低类之间的耦合性，提高系统的灵活性和可维护性。
设计模式与设计原则他们有什么不同呢？
设计原则和设计模式是面向对象设计中的两个重要概念，它们相互关联，但又有不同的含义和作用：
设计原则是一些通用的设计指导方针，它们提供了如何设计一个优秀的软件系统的基本思想和规则。指导着设计者如何组织代码以实现高内聚、低耦合、易扩展和易维护的软件系统。
设计模式则是在特定情况下解决常见问题的经验性解决方案，它们提供了如何实现这些设计原则的具体方法。
设计模式往往是在满足设计原则的基础上被应用的。设计模式可以看作是实现设计原则的一种具体方式。
组合使用 在实际开发中，我们很少只使用单一的设计模式来解决问题，而是将多种设计模式混合使用，以达到更好的效果。
工厂模式 + 单例模式 使用工厂模式来创建对象，通过单例模式来保证该工厂只有一个实例，从而减少创建对象时的开销。
首先，创建一个工厂类，该类使用单例模式来保证只有一个实例，该实例负责创建对象。然后，根据需要创建多个工厂方法，每个方法用于创建不同的对象。
public class SingletonFactory { private static SingletonFactory instance; private SingletonFactory() { // 私有构造方法 } public static SingletonFactory getInstance() { if (instance == null) { synchronized (SingletonFactory.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/723b0e203cc969cb9dd9a68be81e8080/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de3b70069c937d94736a791601930dab/" rel="bookmark">
			Java常见进制转换(未完)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java中各类基础类型所占的字节和位，1字节8位(1 byte = 8 bite)
基础类型字节数位数(bit数)取值范围默认值包装类byte18-2^7 ~ 2^7-10Byteboolean18true falsefalseBooleanshort216-2^15 ~ 2^15-10Shortchar216u0000~uFFFF（‘’~‘？’）'0'Characterint432-2^31 ~ 2^31-10Integerfloat432-3.4e+38 ~ 3.4e+380.0fFloatdouble864-1.7e+308 ~ 1.7e+3080.0dDoublelong864-2^63 ~ 2^63-10Long 常用进制
进制(数值)102816进制(英文)DecimalBinaryOctalHex进制(中文)十进制二进制八进制十六进制字符集0-90,10-70-9,A-F(a-f)进位方法满10进1满2进1满8进1满16进1前导字符无ob或OB数字00x或0X 二进制
java二进制位移后补零_Java位运算符详解_weixin_39633252的博客-CSDN博客
java基本数据类型所占字节 | 后端沉思录
Java一个16进制字符占多少个字节_MariaOzawa的博客-CSDN博客_16字符是几个字节
Java二、八、十、十六进制介绍 - 简书
题解 | #整数与IP地址间的转换#_牛客博客
Java基础之移位运算，为什么高位补1？_Jason_Lee155的博客-CSDN博客_高位补1是什么意思
为什么二进制要高位补位和低位补位 也许是二进制转十进制的时候
二进制转十进制如何计算 : 看每三位+7那个How Can I Convert Very Large Binary in String to Octal In Java - Stack Overflow
不使用库的写法
JAVA Program to Convert Octal to Binary
位移
十六进制
1个16进制占4位(bit)，单位最大的16进制是"FF"或"0xFF"
参考文章 :
1. java二进制位移后补零_Java位运算符详解_weixin_39633252的博客-CSDN博客
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de3b70069c937d94736a791601930dab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1397973c3dc0f097409dbd6dc185b97/" rel="bookmark">
			商业虚拟专用网络技术五IPSec
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		商业虚拟专用网络技术五IPSec 一、IPSec技术1、IPSec虚拟专用网概述2、IPSec体系结构2.1、IPSec体系框架2.2、IPSec工作模式2.3、IPSec安全联盟2.3.1、IPSec工作流程中的专业术语2.3.2、安全联盟建立方式3、AH验证头协议3.1、AH报文格式3.1、AH封装3.1.1、传输模式中的AH封装3.1.2、传输模式中的AH封装４、ESP安全封装载荷4.1、ESP报文格式4.2、ESP封装4.2.1、传输模式下报文封装4.2.2、隧道模式下报文封装4.2.3、AH协议和ESP协议比较5、IKE因特网密钥交换5.1、 ISAKMP报文头5.2、IKE与IPSec的关系5.3、IKEv1协商的两个阶段5.3.1、阶段15.3.2、阶段25.4、Cookie5.5、IKEv1的主模式5.6、IKEv1的野蛮模式5.7、IKEv1阶段2快速模式5.7、IKEv2简介 一、IPSec技术 IPSec(Internet Protocol Security)：是一组基于网络层的，应用密码学的安全通信协议族。IPSec不是具体指哪个协议，而是一个开放的协议族。
1992年，互联网工程任务组（IETF）成立了IP安全工作组，以规范对IP的公开指定的安全扩展，称为IPsec。1995年，工作组批准了NRL开发的IPsec标准，从RFC-1825到RFC-1827发布，NRL在1996年USENIX会议论文集中，描述 NRL 的开放源代码IPsec，由麻省理工学院在线提供，并成为大多数初始商业实现的基础。
1、IPSec虚拟专用网概述 网络传输中，数据被窃听、篡改、伪装的问题不断发生，IP网络安全性问题已经暴露出来。IETF在RFC2401中描述了IP的安全体系结构IPSec(Internet Protocol Security),用以保证在IP网络上传输数据的安全性。IPSec协议定义了如何在IP数据包中增加字段来保证IP包的安全性、私有性和真实性，以及如何加密数据包。IPSec不是具体指哪个协议，而是一个开放的安全标准构成。IPSec不受限于任何一种特定算法，而是引入多种加密算法、验证算法和密钥管理机制。
机密性：对数据进行加密，确保数据在传输过程中不被其它人员查看；完整性：对接收到数据包进行完整性验证，以确保数据在传输过程中没有被篡改；真实性：验证数据源，以保证数据来自真实的发送者（IP报文头内的源地址）；抗重播：防止恶意用户通过重复发送捕获到的数据包所进行的攻击，即接收方会拒绝旧的或重复的数据包。 IPSec实现访问控制、机密性、完整性校验、数据源验证、拒绝重播报文等安全功能。IPSec是运行在IP网络层，其上层TCP、UDP以及依赖于这些协议的应用协议都受到隧道的保护。
IPSec虚拟专用网：就是利用开放的公众IP/MPLS网络建立专用数据传输通道，将远程的分支机构、移动办公人员等连接起来。这个专用数据传输通道称为IPSec隧道，位于OSI模型的第三层，传送IP包。
IPSec的中间设备，在主机、路由器、防火墙硬件设备上实现。又称为"安全网关"，安全网关之间可以利用IPsec对数据进行安全保护，保证数据不被偷窥或篡改。
IPSec虚拟专用网的缺点：配置复杂难以部署、消耗运算资源较多、增加延迟、不支持组播(只能对点到点的数据保护) 、不利于语音视频实时这种要求高的应用。
2、IPSec体系结构 2.1、IPSec体系框架 IPsec协议不是一个单独的协议，它给出了应用于IP层上网络数据安全的一整套体系结构：
1、安全协议：
AH（Authentication Header，验证头）安全协议ESP（Encapsulating Security Payload，安全载荷）安全协议 2、IKE（Internet Key Exchange，因特网密钥交换）密钥交换协议。
3、用于网络认证及加密的一些算法等。
AH或ESP安全服务的工作模式：
传输模式（Transport Mode）：实现端到端保护隧道模式（Tunnel Mode）：实现站点到站点保护
IPsec获取密钥的两种途径：
手工配置：管理员为通信双方预先配置静态密钥，这种密钥不便于随时修改，安全性低，不易维护。
通过IKE协商：IPsec 通信双方可以通过IKE动态生成并交换密钥，获取更高的安全性。
2.2、IPSec工作模式 １、传输模式(Transport mode)：
计算机终端之间的端对端传输，AH和ESP直接用于保护上层协议，OSI的第四层传输层。传输点也是加密点。
２、隧道模式(Tunnel mode)：
用于站点到站点(site-to-site)之间的安全传输，运用AH或者ESP对这些数据进行保护。传输点不等于加密点。
2.3、IPSec安全联盟 2.3.1、IPSec工作流程中的专业术语 Negotiate：协商，两个节点要开始安全发送数据之前，必须完成的事情。IPsec对等体：IPsec的两个端点被称为是IPsec对等体，要在两个对等体（安全网关）之间实现数据的安全传输，就要在两者之间建立安全关联/联盟。SA(Security Association，安全联盟)：协商的结果，类似合约书。SPI(Security Parameter Index，安全参数索引)：SA内包含，用于区分多个SA。是一个32比特的数值，在每一个IPsec报文中都携带有该数值。IKE(Internet Key Exchange，因特网密钥交换)：SA协商的方法和标准。 IPSec对数据流提供安全服务通过SA(Security Association，安全联盟)来实现。SA是通信双方如何保障安全协商的一个结果，包含协议、算法、密钥等内容，具体确定了如何对IP报文进行处理。
每个IPSec SA都是单向的，具有生存周期的。一个SA就是两个IPSec系统之间的一个单身逻辑连接，入站数据流和出站数据流由入站SA与出站SA分别处理。两个对等体之间的双向通信，至少需要两个SA。
一个SA由一个（SPI安全参数索引，IP目的地址，安全协议标识符）三元组唯一标识。
2.3.2、安全联盟建立方式 安全联盟建立方式：手工方式和IKE自动协商方式。二者的主要区别为：
手工方式下，建立SA所需的全部参数，包括加密、验证密钥，都需要用户手工配置，也只能手工刷新，在中大型网络中，这种方式的密钥管理成本很高；IKE方式下，建立SA需要的加密、验证密钥是通过DH算法生成的，可以动态刷新，因而密钥管理成本低，且安全性较高。 SA的生存时间(Life Time)一种是以时间进行限制，一种是以流量进行限制(达到多少字节进行更新)。
生存时间不同：
手工方式建立的SA，一经建立永久存在；IKE方式建立的SA，其生存周期由双方配置的生存周期参数控制。
生存时间期满，SA就会被删除。 专业术语：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1397973c3dc0f097409dbd6dc185b97/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f5efdc2620390022877bd05c01cba99/" rel="bookmark">
			QoS服务质量一QoS概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		QoS服务质量一QoS概述 一、QoS概述1、服务质量指标1.1、带宽1.2、时延1.3、抖动1.4、丢包率1.5、常见业务 QoS 指标1.6、提高服务质量办法1.7、QoS的功能2、Qos服务模型2.1、Best-Effort模型2.2、IntServ模型2.2.1、RSVP资源预留协议2.2.2、IntServ模型的特点2.3、DiffServ模型2.3.1、DiffServ模型体系结构2.3.2、DiffServ模型边界行为 一、QoS概述 随着网络技术的飞速发展，IP网络承载的数据网络向集成数据、语音、视频、游戏的多业务网络转变。网络中所承载的数据呈几何级倍数增长。在传统的IP网络中，各类型数据如语音、视频、远程即时视频、电视会议、网络游戏、FTP、网页浏览、电子邮件报文无区别对待，导致业务服务质量下降，甚至不可用。同时，由于硬件芯片研发的难度大、周期长、成本高等原因，带宽逐渐成为互联网发展的瓶颈，导致网络发生拥塞，产生丢包，业务质量下降，严重时甚至造成业务不可用。
QoS技术就是在这种背景下发展起来的。QoS(Quality of Service，即服务质量)，其目的是针对各种业务的不同需求，为其提供端到端的服务质量保证。QoS是有效利用网络资源的工具，它允许不同的流量不平等的竞争网络资源，语音、视频和重要的数据应用在网络设备中可以优先得到服务。QoS技术在当今的互联网中应用越来越多，其作用越来越重要。
1、服务质量指标 影响网络质量的因素包括：带宽、时延、时延抖动、丢包率。这些影响网络服务质量的因素，也就成为QoS的度量指标。
1.1、带宽 传输链路的带宽：单位时间内许可的最大数据流量，单位为bps(bit per second)。吞吐量是每秒通过的数据包的个数，单位为pps(packet per second)。带宽分为两个方向的速率，当用户向网络发送信息时的数据传输速率，称为上行速率，反之，网络向用户发送信息时的传输速率，称为下行速率。带宽越大，单位时间通过的数据能力就越强，就好似水管越粗，传输水的量就越大。
这一条链路上最大带宽=数据传输路径上最小带宽=10Mbps
1.2、时延 报文传送时延：衡量数据包穿越网络所用时间的指标，以毫秒为单位。指一个报文或分组从网络的发送端到接收端所需要的延迟时间，一般由传输延迟及处理延迟组成。
处理延迟是指网络设备从接收到报文到将其提交到出接口准备发出所消耗的时间。主要包括两个部分：
(1)、交换延迟：报文从入接口被交换到出接口所用时间。取决于设备内部处理能力，如带宽总线和交换板容量。 设备既定的条件下可以认为是固定值。
(2)、排队延迟：出接口队列中等待和被调度的时间，这部分延迟受网络拥塞情况，高度算法和CPU负载的影响，是一个不确定值。
传播延迟：指报文在链路上传播所消耗的时间。主要包括两个部分：
(1)、串行化延迟：指报文被发送到链路上时转为串行信号所用时间。
(2)、传输延迟：指物理信号在介质上传输所用的时间。取决于链路长度和物理性质。
上图两个终端之间的延迟=10+0.2+25+0.2+0.25
以语音传输为例，时延是指从说话者开始说话到对方听到所说内容的时间。大多数用户察觉不到小于 100 毫秒的延迟，当延迟在 100 毫秒和 300 毫秒之间时，通话方可以察觉到对方回复的轻微停顿，这种停顿可能会使通话双方都感觉到不舒服。超过 300 毫秒，延迟就会很明显，用户双方开始互相等待对方的回复，当通话的一方不能及时接收到期望的回复时，通话方可能会重复所说的话，这样会与远端延迟的回复碰撞，导致重复。
1.3、抖动 抖动描述延迟变化的物理量，是衡量网络延迟稳定性的指标，单位：毫秒，等于延迟的变化量的绝对值。抖动产生的原因是延迟随机性，在网络环境中，由于分组转发的原因，同一数据流中的两个包通过不同的路径到达对端，时延相差较大。就是在相同的路径中，网络设备和链路资源的情况也是不断在变化的，也就会造成两个包到达对端的时延。
由于每个报文的端到端时延不一样，就会导致这些报文不能等间隔到达目的端，这种现象叫做抖动。一般来说，时延越小则时延抖动的范围越小。
特别是语音和视频等实时业务是极其不能容忍抖动的。报文到达时间的差异将在语音或视频中造成断续；另外，抖动也会影响一些网络协议的处理，有些协议是按固定的时间间隔发送交互性报文，抖动过大就会导致协议震荡，而实际上所有传输系统都有抖动，但只要抖动在规定容差之内就不会影响服务质量，另外，可利用缓存来克服过量的抖动，但这将会增加时延。
1.4、丢包率 丢包率是指在网络传输过程中丢失报文的数量占传输报文总数的百分比。少量的丢包对业务的影响并不大，例如，在语音传输中，丢失一个比特或一个分组的信息，通话双方往往注意不到。在视频的传输中，丢失一个比特或一个分组可能造成在屏幕上瞬间的波形干扰，但能很快恢复正常。在UDP的传输中，没有重传机制，所以丢包相对于TCP会比较严重。最严重的网络问题，一般要未有少于1%，大于5%为不能容忍。
原因：传输错误、流量限制、网络拥塞，主要为后两者。
1.5、常见业务 QoS 指标 应用类型典型应用带宽时延抖动丢包率批量传输FTP、批量备份高影响小容许抖动低交互音频IP电话低低低低单向音频在线广播低影响小低低交互视频可视电话、视频会议高低低低单向视频视频高影响小低低实时交互操作Telnet低低影响小低严格任务电子交易低影响小影响小低 业务类别时延抖动丢包视频会议≤50ms≤10ms≤0.1%电子商务≤200ms≤100msTCP保证流媒体≤1s≤200ms≤0.1%电子邮件、文件传输NANATCP保证HTML网页浏览NANANAFTPNANATCP保证 1.6、提高服务质量办法 (1)、提高物理带宽
(2)、增加缓冲:发送方增加缓冲区，在拥塞发生时将来不及发送的报文缓存起来，等拥塞缓解时再发送，在一定程度上缓解突发性的拥塞和高抖动，但是增加上被缓冲报文的延迟。
(3)、对数据包压缩：缓解带宽不足，降低传播延迟，增加处理延迟，降低丢包率。
(4)、优先转发：解决带宽不足，降低重要应用延迟和敏感应用抖动，降低重要应用丢包率。
(5)、分片和交错：降低重要应用延迟和敏感应用抖动。
1.7、QoS的功能 QoS具体作用包含几个方面：
(1)、尽力避免网络拥塞
(2)、在不能避免拥塞时对带宽进行有效的管理
(3)、降低丢包率
(4)、调控IP网络流量
(5)、为特定用户或特定业务提供专用带宽
(6)、支撑网络上的实时业务
2、Qos服务模型 QoS模型不是一个具体功能，而是端到端QoS设计的一个方案。例如，网络中的两个主机通信时，中间可能会跨越各种各样的设备。只有当网络中所有设备都遵循统一的QoS服务模型时，才能实现端到端的质量保证。IETF、ITU-T等国际组织都为自己所关注的业务设计了QoS模型。下面就来介绍一下主流的三大QoS模型。
2.1、Best-Effort模型 Best-Effort 是最简单的 QoS 服务模型，应用程序可以在任何时候，发出任意数量的报文， 而且不需要通知网络。对 Best-Effort 服务，网络尽最大的可能性来发送报文，但对时延、 可靠性等性能不提供任何保证。 Best-Effort 服务模型适用于对时延、可靠性等性能要求不高的业务进行质量保证，是现在 Internet 的缺省服务模型，它适用于绝大多数网络应用，如 FTP、E-Mail 等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f5efdc2620390022877bd05c01cba99/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57c35ca9c07bc1d822ceadcbfe7f66bd/" rel="bookmark">
			QoS服务质量五QoS边界行为之流量整形
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		QoS服务质量五QoS边界行为之流量整形 3、流量整形3.1、GTS的原理3.2、自适应流量整形3.3流量监管和流量整形应用场景3.4、配置限速(流量监管和流量整形)3.4.1、配置流量整形3.4.2、基于流分类MQC的流量监管3.4.3、自适应流量整形 3、流量整形 流量整形TS（Traffic Shaping）是一种主动调整流量输出速率的措施，其作用是限制流量与突发，使这类报文以比较均匀的速率向外发送。流量整形通常使用缓冲区和令牌桶来完成，当报文的发送速度过快时，首先在缓冲区进行缓存，在令牌桶的控制下，再均匀地发送这些被缓冲的报文。
单速率双色单桶,缺点是上一秒令牌未用完，则下一秒将会被清空；单速率三色双桶，有两个令牌桶。可以有积存机制，解决超发问题；双速率三色双桶，整形红色流量进行缓存，等待下次获得令牌通过，未被丢弃。一般适用于高带宽向低带宽发送数据。
流量整形通常使用缓冲区或队列和令牌桶来完成，当报文的发送速度过快时，首先在缓冲区或队列进行缓存，在令牌桶的控制下，在均匀的发送这些缓存的报文。缓冲区的空间是有限的，如果缓冲区空间不足，则被延迟发送的报文会被丢弃。
流量监管和流量整形的比较：
名称流量监管流量整形流量方向差异应用于端口入方向应用于端口出方向超额流量差异丢弃超额流量或将超额流量重标记为低优先级缓存超额流量内存使用差异不需要额外的内存资源，不会带来延迟和抖动需要缓存超额流量，可能会带来延迟和抖动丢包率的差异丢包可能引发重传较少的丢包，因而较少导致重传重标记的差异可以重标记流量不能重标记双方共同点都是监控网络流量、都是用令牌桶算法评估流量速率、用于网络边缘一样 从上可以看出不同流量监管优点：是不需要内存，延迟小。缺点：丢包率大，抗突发能力弱；流量整形的优点：丢包率小，抗突发能力强，缺点：要内存，延迟高。两种的优点缺点互补。
从上图可以看出流量整形将上游不规整的流量进行削峰填谷，使流量输出比较平稳，从而解决下游设备的拥塞问题。
3.1、GTS的原理 GTS(Generic traffic shaping，通用流量整形)在收到报文后会先进行分类，符合GTS匹配条件的报文由GTS进行整形，不符合匹配条件的报文绕过GTS直接转发。GTS使用的令牌桶技术为单桶单速，只对出接口有作用。
解决下游设备的接口速率小于上游设备的接口速率，从而导致下游设备接口入方向丢包的问题。
GTS处理流程
GTS在收到报文后会先进行分类，使报文进入不同的队列。没有配置队列整形功能的报文绕过GTS直接转发。
符合GTS匹配条件的报文(配置队列整形功能)由GTS进行整形，GTS采用停牌桶技术对各类报文分别进行测量。
对需要流量整形的报文进行测量分为两种情况，一种是令牌桶中令牌数量足够多，也就是来的报文的符合所设置的CIR和CBS，放行此报文。
另一种情况是发送过来的报文不符合所设置的CIR和CBS，也就是令牌桶中令牌数量不足，这时报文被缓存在队列里，等待有足够令牌时再继续发送。
如果该接口和子接口同时配置了接口整形，则系统还要逐级按照子接口整形速率、接口整形速率对报文流进行速率控制。则报文全部进行流量整形。
3.2、自适应流量整形 有些场景下，下游设备的接口速率是不确定的，上游设备无法确定应该把整形参数设置为多少。此时可以配置自适应模板来实现自适应流量整形，通过在上游设备和下游设备间开启NQA检测，根据NQA检测到的下游设备丢包率动态调整整形参数。
NQA(Network Quality Analysis，网络质量分析)，是设备上集成网络检测功能，不仅可以实现对网络运行情况的准确测试，输出统计信息，有效的节约成本。NQA可以检测网络上运行的各种协议的性能，时运营商能够实时采集到各种网络运行指标，例如：HTTP的总时延、TCP连接时延、DNS解析时延、文件传输时延、FTP连接时延、DNS解析错误等等。
NQA把测试两端称为客户端和目的端，并在客户端发起测试，目的端接收报文后，返回给源端相应的回应信息。根据返回的回应信息，就可以了解相应的网络状况。
自适应模板规定了：
NQA测试例：通过此测试例检测下游设备接口入方向丢包率，根据检测结果调整整形参数。整形速率范围：上游设备接口出方向的整形速率上下限，整形速率在此范围内动态调整。整形速率调整步长：动态调整整形速率时，每次调整的速率大小。丢包率范围：下游设备接口入方向允许的丢包率范围。当丢包率在此范围之内时，不调整整形速率；当丢包率过大，减小上游设备整形速率；当丢包率过小，且上游设备发生拥塞，增大上游设备整形速率。整形速率增大的时间间隔：当丢包率在阈值附近频繁变化时，就需要频繁调整整形速率，用户可以通过设置此参数，限制增大整形速率的时间间隔，避免频繁更新。 系统根据NQA检测结果中的丢包率等调整整形速率：
自适应模板在流行为中绑定后，将流行为与流分类在流策略下进行绑定，并在接口下应用流策略，才能使自适应模板中配置的整形参数在该接口下生效。
3.3流量监管和流量整形应用场景 企业网中语音、视频和数据等多种不同的业务，报文从高速链路进入设备，再由低速链路转发出去。可能会因为带宽不足产生拥塞，需要对三种业务提供不同的保证带宽，优先保证语音业务的带宽，其次是视频业务，最后是数据业务，因此可以对不同业务进行不同的流量监督，为语音报文提供最大保证带宽，视频报文次之，数据报文保证带宽最小，从而在网络产生拥塞时，可以保证语音报文优先通过。
流量监管
流量整形
3.4、配置限速(流量监管和流量整形) 配置限速时，需要配置cir cir-value和cbs cbs-value等参数，其中cir cir-value指承诺信息速率，即保证能够通过的平均速率；cbs cbs-value指承诺突发尺寸，即瞬间能够通过的承诺突发流量。例如，用户想要配置限速4Mbit/s，则配置cir-value=4*1024 kbit/s=4096 kbit/s。cbs-value建议配置为cir-value的100–200倍，如果用户没有配置cbs-value，则设备会自动指定其为缺省值。cbs-value缺省为cir-value的125倍。突发流量速率 PIR 的设置，在工程上 PIR 的速率一般定义为 CIR 的 1.5 倍，即PIR=CIRx1.5，过大的 PIR 会导致设备过高的负荷。
3.4.1、配置流量整形 Switch通过接口GE0/0/2与路由器互连，局域网终端发送的语音、视频、数据，这些业务可经由交换机和路由器到达用户。各终端设备与SW2构成的局域网，速率远大于由SW1和R1构成的WAN速率，这种情况下SW1出接口GE0/0/1处容易发生带宽抖动。为减少带宽抖动，为减少抖动进行以下处理：
1、基于接口的流量整形
也叫接口限速 LR（Line rate），限制接口发送的所有报文（包括紧急报文）的总速率，是对整个出接口进行流量整形，不区分优先级。LR使用的令牌技术为单通单速，不允许突发流量的通过。
缺点：不能基于业务区别对待。
在SW1入口上配置限速，进入的速率限制在20000kbit/s。在SW2上配置端口整形，将端口出口速率限制在20000kbit/s。lr针对于接口下的所有流量。LR使用单速单桶。
[SW1]interface g0/0/1 [SW1-GigabitEthernet0/0/1]qos lr inbound cir 20000 cbs 2000000 //配置入方向的接口限速速率为20000kbit/s，CBS大小为2000000bit。 [SW2]interface g0/0/1 [SW2-GigabitEthernet0/0/1]qos gts cir 20000 //配置接口的发送数据的速率为20Mbps/s,对接口配置流量整形。 cbs是整形模型中使用的令牌桶的大小，cbs不是越大越好，越大则流量波动就越大：反之，流量波动就较小，但cbs一定要大于1500。cbs-value缺省为cir-value的125倍。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57c35ca9c07bc1d822ceadcbfe7f66bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6e0f9c60e2b0e53035a8b292e2a0e33/" rel="bookmark">
			QoS服务质量四QoS边界行为之流量监管
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		QoS服务质量四QoS边界行为之流量监管 二、QoS域边界节点的功能和行为1、流分类1.1、简单流分类1.2、复杂流分类2、流量监管2.1、标记2.1.1、流量监管工具CAR2.1.1.1、CAR两个功能2.1.1.2、CAR的位置2.1.1.3、CAR的处理步骤:分类、评估和处置。2.1.1.4、CAR处置动作2.1.1.5、CAR的处理流程2.1.1.6、CAR令牌桶参数设置2.1.1.7、接口下配置流量管制2.1.2、QoS优先级映射2.1.2.1、CoS调度优先级PHB2.1.2.2、信任边界2.1.2.3、实际应用对应二层、三层优先级2.2.2、QoS优先级配置2.2.3、交换机优先级映射的配置 二、QoS域边界节点的功能和行为 基于 DiffServ 服务模型的 QoS 业 务可以分为以下几大类：
流分类和标记（Traffic classification and marking）：要实现差分服务，需要首先将 数据包分为不同的类别或者设置为不同的优先级。将数据包分为不同的类别，称为 流分类，流分类并不修改原来的数据包。将数据包设置为不同的优先级称为标记， 而标记会修改原来的数据包。流量监管和整形（Traffic Policing and Shaping）：是指将业务流量限制在特定的带 宽，当业务流量超过额定带宽时，超过的流量将被丢弃或缓存。其中，将超过的流量丢弃的技术称为流量监管，将超过的流量缓存的技术称为流量整形。拥塞管理和避免（Congestion Management and Avoidance）：拥塞管理在网络发生 拥塞时，将报文放入队列中缓存，并采取某种调度算法安排报文的转发次序。而拥 塞避免可以监督网络资源的使用情况，当发现拥塞有加剧的趋势时采取主动丢弃报 文的策略，通过调整流量来解除网络的过载。端口镜像和流镜像（Port Mirror and Traffic Mirror）：镜像是将指定端口的指定报 文复制一份到镜像目的端口，镜像目的端口会与数据监测设备相连，用户利用这些 数据监测设备来分析复制到目的端口的报文，进行网络监控和故障排除。 流分类和标记是实现差分服务的前提和基础；流量监管、流量整形、拥塞管理和拥塞避免从不同方面对网络流量及其分配的资源实施控制，是提供差分服务的具体体现。
各层设备的作用：
接入层业务识别：接入交换机LSW作为边界交换机，在接入侧需要担负数据流的识别、分类以及流标记的工作；在网络侧需要担负不同应用数据流的拥塞管理、拥塞避免、流量整形等工作。出方向应用流量监管，限制进入广域网的流量。
汇聚层/核心层提供差分服务：汇聚层和核心层设备端口信任基于接入层标识的QoS参数，通过队列调度、流量整形、拥塞避免等方式实施QoS策略，保证高优先级业务优先获得调度。
1、流分类 分类的目：的是将符合条件的数据流划分到相应的类别中，以便后续的QoS 机制做实施控制处理。
当报文在 DiffServ 域边界被分类之后，网络的中间节点就可以根据分类，对不同类别的流量给予差别服务。下游（downstream）节点可以选择使用上游（upstream）节点的分类结果，也可以按照自己的分类标准对数据流重新进行分类。
分类方法：
业务流进入DS域时，可以有多种方法对它进行分类，例如依据报文携带的Cos、IP precedence、DSCP或MPLS 报文的 EXP 等优先级标记对其划分类别；或根据 MAC、目的 MAC、内外层 Tag、源 IP 地址、源端口号、目的 IP 地址、目的端口号或应用程序的端口号等信息对流进行分类，也可以根据业务等级协议 SLA 规定的一些策略给每个数据包加上标记，从而对数据包进行分类。
根据不同的方法实现流分类的技术可以被分成“简单流分类（Behavior Aggregate Classifier）”与“复杂流分类（Multi-Field Classifier）”。
1.1、简单流分类 根据 IP 报文的 VLAN 报文的 802.1p 值，IP 报文 的 ToS 值、IPv6 报文的 TC 值、MPLS 报文的 EXP 域值，对报文进行粗略的分类，以识别出具有不同优先级或服务等级特征的流量，实现外部优先级和内部优先级之间的映射。即根据优先级映射表，将上行报文携带的 QoS 优先级统一映射到设备内部的服务等级和颜色，将下行报文的内部的服务等级和颜色映射成为 QoS 优先级。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c6e0f9c60e2b0e53035a8b292e2a0e33/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32a6bc4ef26532309cabf480db502ff1/" rel="bookmark">
			BUUCTF MISC 41-60
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		41、秘密文件 题目提示的盗取了文件，于是首先过滤FTP协议，追踪一下TCP流，发现存在一个压缩包
于是尝试用foremost提取，得到一个加密的压缩包
没有任何提示，尝试四位数暴力破解即可得到flag
42、菜刀666 题目提示是菜刀，菜刀基本都是POST，因此直接过滤POST的包
http.request.method==POST
从1开始追踪流都是正常的菜刀shell，直到追踪流7发现传了两个参数z1/z2
z1使用base64解码得到了一个图片地址
z2保存十六进制得到一张图片
1、使用Editor导入十六进制
2、使用脚本
import struct a = open("1.txt", "r") # 十六进制数据文件 lines = a.read() res = [lines[i:i + 2] for i in range(0, len(lines), 2)] with open("res.jpg", "wb") as f: for i in res: s = struct.pack('B', int(i, 16)) f.write(s) 实际上里面还有flag.txt和hello.zip
使用foremost分离文件，得到一个加密的压缩包，密码就是图片上的文件
43、just_a_rar 得到一个加密的压缩包，提示四位数，直接爆破得到一张图片，查看图片属性在exif中发现flag
44、鸡你太美 得到两张gif但是有一张无法查看，怀疑是文件头缺失，于是尝试用十六进制器查看文件
第二张图片果然少了文件头，插入四个字节，加上文件头47 49 46 38
修改后保存即可得到flag
45、一叶障目 用010 Editor打开图片，没发现什么特别的，但是这好像是图片的一块
于是尝试校验crc，果然有问题，说明图片宽高被修改过
用大佬的CRC修复脚本即可得到正常的图片得到flag
import zlib import struct # 读文件 file = '123.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/32a6bc4ef26532309cabf480db502ff1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47945ff504df9bae96e0992562a52312/" rel="bookmark">
			OnlyOffice配置文档
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OnlyOffice配置参数文档 更多内容可以访问官方文档
https://api.onlyoffice.com/editors/basic
1、基础参数 参数名称类型描述例子documentTypestring定义要打开的文档类型:
word - 文档 (.doc, .docm, .docx, .docxf, .dot, .dotm, .dotx, .epub, .fodt, .fb2, .htm, .html, .mht, .odt, .oform, .ott, .oxps, .pdf, .rtf, .txt, .djvu, .xml, .xps),
cell - 表格 (.csv, .fods, .ods, .ots, .xls, .xlsb, .xlsm, .xlsx, .xlt, .xltm, .xltx),
slide - 幻灯片 (.fodp, .odp, .otp, .pot, .potm, .potx, .pps, .ppsm, .ppsx, .ppt, .pptm, .pptx).
text, spreadsheet 和 presentation 从6.1版开始就被弃用。请改用新值。“word”heightstring在浏览器窗口中定义文档高度（默认为 100%）。“100%”widthstring定义浏览器窗口中的文档宽度（默认为 100%）。“100%”tokenstring定义以令牌形式添加到文档服务器配置的加密签名。“eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.e30.t-IDcSemACt8x4iTMCda8Yhe3iZaWbvV5XKSTbuAn0M”typestring定义用于访问文档的平台类型。可以：优化为从台式机或笔记本电脑访问文档-台式机，优化为从平板电脑或智能手机访问文档-移动，特别设计为易于嵌入网页-嵌入式。默认值为“desktop”。“desktop” 2、高级参数 （1）document对象 参数名称类型描述例子fileType*string定义源查看或编辑文档的文件类型。必须小写。以下文件类型可用:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47945ff504df9bae96e0992562a52312/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/165/">«</a>
	<span class="pagination__item pagination__item--current">166/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/167/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>