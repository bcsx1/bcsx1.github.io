<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d15466af75878e7ebd141e5556054e03/" rel="bookmark">
			Codeforces 1632 E2. Distance Tree (hard version) —— 思维，有丶东西
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		This way
题意： 给你一棵树，每条边权为1，f(x)表示点x到1的路径上权重和。
你可以增加一条边权为k的边，使得f(x)最大值最小。问你k在[1,n]时最大f(x)最小是多少。
题解： 我想着只搜一次，搜的时候维护上面距离当前点最远的点的距离。我感觉可以是树链剖分或者动态开点线段树，然后加一些骚操作，但是好累啊，想想都绝望，写写200行打底。
于是放弃了，还是看题解去。毕竟有段时间没打了，这个思维有时候跟不上，想这个题的时候并不能很快地想通，后面还是多做做水题锻炼思维吧。
假设我们现在答案的权重为x，如果没有新连边的话，设dep[i]是点i的深度，dep[i]&lt;=x的这些点能够覆盖到，但是dep[i]&gt;x的这些不行（这好像是句废话），那么对于dep[i]&gt;x的这些点我们加一条边上使得全部能够覆盖到，最优的解法是什么？当然是距离最远的两个点的路径上最中间的位置和1连边啊，这样如果这两个最远的点a,b能够覆盖到，其它未覆盖到的点都能被覆盖到了。但是当然不能每次都找未覆盖到的点的最远距离，我们需要预处理出来。
mx[i]表示深度&gt;=i的点中，两个点的最远距离是多少。
那么在dfs的时候我们只需要维护子树的最大距离和第二大距离即可。
mx[m2]=max(mx[m2],m1+m2-2*dep[x]);
就维护在深度为m2(m2&lt;=m1)的时候的最远距离，为什么不是赋值到m1上？因为如果你答案能覆盖到m2了，m2和m1之间的最远关系也就消失了，我们需要找未覆盖到的最远点。
最后从后往前for一下将更深的点的答案往前传递即可。
然后找答案时怎么找？假设当前的权重为ans，那么只需要满足：未被覆盖到的点中距离最远的两个点的距离（也就是mx[ans+1]），它们的一半（(mx[ans+1]+1&gt;&gt;1)）+k要能够被覆盖到（也就是&lt;=ans）即可。
#include&lt;bits/stdc++.h&gt; using namespace std; const int N=3e5+5; int dep[N],mx[N],low; vector&lt;int&gt;son[N]; int dfs(int x,int fa){ dep[x]=dep[fa]+1; low=dep[x]&gt;dep[low]?x:low; int m1=dep[x],m2=dep[x]; for(int ne:son[x]){ if(ne==fa)continue; int mm=dfs(ne,x); if(mm&gt;m1)m2=m1,m1=mm; else if(mm&gt;m2)m2=mm; } mx[m2]=max(mx[m2],m1+m2-2*dep[x]); } int main() { int t; scanf("%d",&amp;t); dep[0]=-1; while(t--){ int n,x,y; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++)son[i].clear(),mx[i]=0; for(int i=1;i&lt;n;i++) scanf("%d%d",&amp;x,&amp;y),son[x].push_back(y),son[y].push_back(x); low=0; dfs(1,0); for(int i=dep[low]-1;i;i--)mx[i]=max(mx[i],mx[i+1]); int ans=1; for(int i=1;i&lt;=n;i++){ while(ans&lt;dep[low] &amp;&amp; (mx[ans+1]+1&gt;&gt;1)+i&gt;ans)ans++; printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d15466af75878e7ebd141e5556054e03/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d310a71325df67267b73c62799e3233/" rel="bookmark">
			echarts图形铺满容器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 只需要在配置项加上：
grid: { top: '50px', left: '50px', right: '15px', bottom: '50px' }, 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7712fa6b5a281e3b18542696e06c377a/" rel="bookmark">
			Leetcode-D45-数组-56. 合并区间&amp;57. 插入区间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、复习 54、 螺旋矩阵,通过了，写起来难度不大——除了应该和rows、cols比大小，错写成col和row了。
我觉得这道题最神奇的地方就是方向移动的表示以及转变了——通过数组记录方向变化+利用%的机制实现循环妙啊！！！
class Solution: def spiralOrder(self, matrix: List[List[int]]) -&gt; List[int]: rows = len(matrix) cols = len(matrix[0]) size = rows*cols directions = [[0,1],[1,0],[0,-1],[-1,0]] dir_index = 0 row,col=0,0 res=[] hash = [[False]*cols for _ in range(rows)] for i in range(size): item = matrix[row][col] res.append(item) hash[row][col]=True next_row=row+directions[dir_index][0] next_col = col+directions[dir_index][1] if next_row&gt;=rows or next_col&gt;=cols or hash[next_row][next_col]==True: dir_index = (dir_index+1)%4 row=row+directions[dir_index][0] col = col+directions[dir_index][1] else: row = next_row col = next_col return res 56.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7712fa6b5a281e3b18542696e06c377a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf591bf66ee9e14b8514790440f1a1ab/" rel="bookmark">
			C语言 回文链表（给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false ）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		思路：求出链表的长度，将链表前面一般的元素入栈，然后逐个出栈与后一半的元素进行比较，如果一旦不相等立马返回FALSE，停止比较，如果到最后栈不为空也要返回FALSE，只有当栈为空且出栈的元素和链表后一半的元素都想得才能返回TRUE；另外要注意的一点是长度为1的链表都是回文链表所以要进行特殊处理，即当length=1时直接返回TRUE不用进行后续的操作。
/** * Definition for singly-linked list. * struct ListNode { * int val; * struct ListNode *next; * }; */ typedef struct stacknode { int data; struct stacknode* next; }stacknode; int l(struct ListNode* head) { struct ListNode* p=head; int i=0; while(p!=NULL) { i++; p=p-&gt;next; } return i; } void push(struct stacknode **s,int n) { struct stacknode *p; p=(stacknode*)malloc(sizeof(stacknode)); p-&gt;data=n; p-&gt;next=(*s); (*s)=p; } int pop(struct stacknode** s) { int e=(*s)-&gt;data; (*s)=(*s)-&gt;next; return e; } int empty(struct stacknode* S) { if(S==NULL) return 0; else return 1; } bool isPalindrome(struct ListNode* head){ if(head==NULL) return false; struct stacknode* S; S=NULL; struct ListNode* p=head; int length=l(head); if(length==1) return true; for(int i=1;i&lt;=length/2;i++) { push(&amp;S,p-&gt;val); p=p-&gt;next; } if(length%2!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf591bf66ee9e14b8514790440f1a1ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e64c3d267d88ba53dfb5c5ed227eace6/" rel="bookmark">
			推特开发者账号申请 Academic 学术【推特开发者文档V2系列6】——tweepy4 获取推文的点赞列表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于推特开发者账号 elevated academic 请看此贴： 推特开发者账号申请权限 或 搜索微信公众号 twitterDeveloper 获得帮助 tweepy怎么用看这里：
使用tweepy4 搜索历史推文
文档：https://docs.tweepy.org/en/stable/client.html#tweets
长话短说，怎么获取某个推文的点赞列表呢，就是想知道哪些用户给这个推文点赞了。
代码如下：
import tweepy bear_token = 'XXXXXXXX' client = tweepy.Client(bear_token) response = client.get_liking_users(id='1488360836850540544') print(response) print("=======分割线==========") for i in response[0]: print(i.id) print(i.name) print(i.username) 对应的文档链接：
https://docs.tweepy.org/en/stable/client.html?highlight=get-tweets-id-liking#tweepy.Client.get_liking_users
运行结果如图：
有的时候点赞人数太多，一条返回可能只返回有限的数据，这时候把代码稍加改动
运行：
可以看到有剩余数量和next_token这个参数，根据next_token就可以继续往下取了。next_token怎么用可以翻下之前的博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/293278a601a6da6174ca5f1d59981815/" rel="bookmark">
			Kestrel简介_Kestrel Web 服务器简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Kestrel简介_Kestrel Web 服务器简介
一、Kestrel简介
Kestrel 是一个跨平台的适用于 Kestrel。
Kestrel 是包含在 ASP.NET Core 项目模板中的 Web 服务器，默认处于启用状态。
.NET Core 支持的所有平台和版本均支持 Kestrel。
更多详细配置和使用：ASP.NET Core 中的 Kestrel Web 服务器实现 | Microsoft Docs
未使用 IIS 托管时，ASP.NET Core 项目模板默认使用 Kestrel。 在“Program.cs”中， 方法调用 UseKestrel：
var builder = WebApplication.CreateBuilder(args); var app = builder.Build(); app.MapGet("/", () =&gt; "Hello World!"); app.Run(); 二、服务器配置终结点
var builder = WebApplication.CreateBuilder(args); //配置服务器 builder.WebHost.UseUrls("http://localhost:8080"); // Add services to the container. builder.Services.AddControllersWithViews(); var app = builder.Build(); 更多详细配置参考：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/293278a601a6da6174ca5f1d59981815/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2cdfaf9d537998195c0fd5c194997a28/" rel="bookmark">
			周志华《机器学习》个人笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这本书比较像导论性质，整体给你介绍下机器学习领域有哪些研究分支，以及这些研究分支中成熟的经典算法。
这本书虽然也有算法描述，但这些算法都是实现底层机器学习算法的，如果没有编程基础或者现在主流的分布式编程的思想，想要直接自己动手据此写代码还是比较困难的。如果你想找的是直接上手coding的实践应用类的书籍，这本书可以放一放，等你先上手了再来。不是这本书难，其实它讲的东西都很简单，只是纯粹的它不是实践类的书籍。
它能给你打下的是不错的概念基础。让你整体认识下机器学习的门道。让你跟专业的人对话的时候，on the same page。
个人学习笔记。
我以前看了蛮多的综艺节目，节目里总是有些为了效果而让嘉宾出糗、令人发笑的游戏环节。
没有想到这些游戏会在今天我看周志华老师《机器学习》这本书的时候派上用场。而且还发现这些游戏简直就是真人版的机器学习模型训练的过程。不要太神奇！
比如：马尔可夫随机场是个报数游戏。
玩家围坐一圈，有些人之间要报数相同通关，有些人之间要报数不同才通关，否则游戏失败，大家要接受惩罚。
当主持人不告诉玩家谁跟谁之间要报数相同（即高相关）、谁跟谁要报数不同（即负相关），但他自己会根据已知的规则判断游戏是成功还是失败。
经过几轮游戏成败之后，玩家摸索出这个规律的过程就是找到模式的过程，即模型训练的过程。
高级版的可以做的复杂一些，比如将玩家分组（团、极大团的概念），还可以设置协调室，主持人在内组织各团队成员进行沟通（类比分离集的概念），要求每团队出的沟通人员都是固定的。
另外一个有趣的游戏就是“传声筒”游戏。 万万想不到这就是一个隐马尔科夫模型。
主持人写一段话，让带有各地方言口音的人去念这段话，然后你根据声音去写出原话是什么。
​​​​​​​​​​​​​​​​​​​​​
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e5b768d893b5d4f51bbc3eddf246f0e/" rel="bookmark">
			sql 报错：Error updating database. Cause: com.mysql.jdbc.exceptions.jdbc4.MySQLIntegri
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文链接:这里
0.报错详情
insert语句插入的时候报错。
报错详情如下：
org.springframework.dao.DuplicateKeyException: \r\n### Error updating database. Cause: com.mysql.jdbc.exceptions.jdbc4.MySQLIntegrityConstraintViolationException: Duplicate entry ‘f098779b-3148-4bf5-b553-3274416dacd8-922a6ffe-142d-495d-b5d1-987’ for key ‘uni_company_binding_product’\r\n### The error may involve com.xxx.xxxx.buildingmaterials.dao.CompanyBindingProductMapper.insertCompanyBindingProduct-Inline\r\n### The error occurred while setting parameters\r\n### SQL: INSERT INTO company_binding_product(id, org_id, product_id, certificate_number, valid_time, attachment_url, type,classification) VALUES (?,?,?,?,?,?,?,?)\r\n### Cause: com.mysql.jdbc.exceptions.jdbc4.MySQLIntegrityConstraintViolationException: Duplicate entry ‘f098779b-3148-4bf5-b553-3274416dacd8-922a6ffe-142d-495d-b5d1-987’ for key ‘uni_company_binding_product’\n; SQL []; Duplicate entry ‘f098779b-3148-4bf5-b553-3274416dacd8-922a6ffe-142d-495d-b5d1-987’ for key ‘uni_company_binding_product’; nested exception is com.mysql.jdbc.exceptions.jdbc4.MySQLIntegrityConstraintViolationException: Duplicate entry ‘f098779b-3148-4bf5-b553-3274416dacd8-922a6ffe-142d-495d-b5d1-987’ for key ‘uni_company_binding_product’"
主要原因是这个表设置了主键，主键唯一，而插入的数据重复了，所以会报这个错。
另外，不要忽略了还有联合主键这个，我的报错就是因为联合主键，id本身是UUID不会重复，但是和联合主键一块就出现了重复的情况，所以这个也要排查一下。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ccc43e1a7c868a51b9d4c079b2b3967/" rel="bookmark">
			过年刷【千言数据集：文本相似度】比赛
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		过年刷千言数据集：文本相似度数据集 1.比赛信息2. 数据集介绍3. 模型细节3.1 数据增强：3.2 模型：3.3 训练：3.4 模型融合： 其他：可以提高的点 或者 没有用尝试。1.领域数据进一步预训练。2.半监督训练（self-training的思想）：3. simCSE的训练：4.stacking模型融合： 1.比赛信息 “千言数据集：文本相似度” 是网易易智在 CCF 和百度联合举办的行业测评任务，这个榜单在2021年出提出。刚好过年有时间刷一下这个任务，由于时间有限，且已经有相当多的提交，最后在假期结束取得15/2000的成绩。
代码地址：https://github.com/xxyliuyang/qianyan_similarity
依赖： allennlp2.0.1、transfomers4.1.0、torch==1.7.1
2. 数据集介绍 具体数据来源查看官网数据介绍，这里介绍三个数据比较大的问题：千言数据集：文本相似度述
问题一：领域数据：BQ Corpus是金融领域相关的数据。问题二：文本质量： PAWS-X的输入文本质量不高，存在很多中英混合句子，英文大部分是英文实体词汇。问题三：label质量：观察部分数据，标签存在标注错误的情况。 3. 模型细节 3.1 数据增强： 交换句子度，将训练数据翻倍。
3.2 模型： bert构建句子对模型，使用[CLS]的输出的向量做二分类。
3.3 训练： 使用R-drop正则方法，其训练逻辑类似于对抗训练。
3.4 模型融合： 使用robert，albet，macbert分别训练，然后将输出的概率求平均。
其他：可以提高的点 或者 没有用尝试。 还有很多方法没有尝试，读者可以自行尝试，进入前十还是不难。
1.领域数据进一步预训练。 条件是可以获取或者爬取相关领域的文本。
2.半监督训练（self-training的思想）： 条件是获取相关数据。
3. simCSE的训练： 尝试simCSE的训练，但是没有收益，猜测是因为simCSE提高句子embedding的方法，然而这个任务是句子对的任务，两个任务的出发点有区别。如果有更好的解释，欢迎评论。
4.stacking模型融合： 更好的融合模型可以提高效果
参考文献
[1] R-Drop
[2] simCSE
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c19968d3191ea6e175f92f3970915ab/" rel="bookmark">
			C语言-数组练习题（附答案）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.输入10名学生的成绩，计算总分和平均分，输出平均分。
2.输入10个学生的成绩，输出高于平均分的学生成绩。
3.打印图片
4.杨辉三角 5.输入一个以回车符为结束标志的字符串（少于10个字符），提取其中的所有数字字符,将其转换为一个十进制整数,再将十进制整数转化为二进制数输出。
6.判断回文
7.输入3个字符串，要求找出其中最大的。
8.编一个程序，将两个字符串连接起来，不用strcat函数。
9.编写一个程序，将字符数组S2中的全部字符复制到字符数组S1中。不用strcpy函数。复制时，‘\0’也要复制过去。‘\0’后面的字符不复制。
10.输入一行字符，统计其中有多少个单词，单词之间用空格分隔开。
1.输入10名学生的成绩，计算总分和平均分，输出平均分。 #include&lt;stdio.h&gt; #define N 10 int main() { float score[N],s=0; int i; for(i=1;i&lt;N;i++) { scanf("%f",&amp;score[i]); s=s+score[i]; } printf("avervage=%.lf\n",s/N); return 0;} 2.输入10个学生的成绩，输出高于平均分的学生成绩。 #include&lt;stdio.h&gt; int main() { int a[9],s=0,i; float ave; for(i=0;i&lt;=9;i++) { scanf("%d",&amp;a[i]); s=s+a[i];} ave=s/10; for(i=1;i&lt;10;i++) {	if(a[i]&gt;ave) printf("%d",a[i]);} return 0;} 3.打印图片 #include&lt;stdio.h&gt; int main() {int i,j; int a[10][10]; for(i=0;i&lt;10;i++) {a[i][0]=1; a[i][i]=1; for(j=1;j&lt;i;j++) a[i][j]=a[i-1][j-1]+a[i-1][j];} for(i=0;i&lt;10;i++) {for(j=0;j&lt;=i;j++) printf("%3d",a[i][j]); printf("\n");} return 0;} 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c19968d3191ea6e175f92f3970915ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad5e9cc53ea55f8cf14fea8de7b7302c/" rel="bookmark">
			GAMES101【lecture5-8】-现代计算机图形学入门-闫令琪-笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Lecture 5：光栅化 Rasterization 引入：经过上一节课的MVP，把物体放在了一个1x1x1的正方体里，之后该做什么呢？——&gt;画在屏幕上
一些定义
接下来的问题就变成了：如何用像素表示三角形？
采样 考察像素块中心点与三角形的关系
使用的一个非常简单的函数判断，点(x,y)在三角形t里面就是1，否则为0
如何判断点Q在三角形p1p2p3里面呢？
用p2p1叉乘p1Q，根据右手定则，朝上，说明Q在p1p2左边，同理，按方向顺序判断其他三条边，若Q都在三条边的左边或右边，说明Q在三角形里面
最终得到：
Lecture 6：反走样（反锯齿）与深度缓冲 采样会出现瑕疵 发生的根本原因：采样速率跟不上物体的运动速率
解决方法：模糊滤波
先模糊，再采样，填充像素颜色填充的是模糊后的颜色（有深有浅）
实际效果：
但是如果先采样后模糊就不行
为什么呢？ 滤波：去掉某个频率段
有关图像频率：
图像的频率被称为空间频率，空间频率是指单位长度内亮度做周期性变化的次数，它反映了图像的像素灰度在空间中的变化情况，从傅里叶频谱上可以看到明暗不一的亮点，反映的就是某点与邻域间的差异程度。 举个例子，一帧图像的背景或者变化缓慢的区域，也就是灰度值分布比较平坦，那么，低频分量就比较强。图像的边缘、细节以及噪声的像素灰度在空间的变化非常剧烈。因此为高频分量。
卷积定理
怎么进行模糊操作？ 原理：
用这个卷积核平均了每个像素周围的像素点，达到了模糊的效果。
视频到这个地方一直后面一直讲的是为什么采样会出现瑕疵， 为什么'先模糊再采样'是正确的。 但是我并没有听懂，就不贴在这里了。:P 解决的办法——反走样的策略 反走样的原理：（没听懂）
平均像素值来进行反走样 平均像素中被图形覆盖的面积：
具体做法：把每个像素再分成小的像素
最后效果：
这种在每个像素内增加采样点的方法叫做MSAA（Multi-Sample Anti-Aliasing）
*知乎 对于MSAA的解释
为了使用MSAA，增大了计算量
深度缓冲 在这节之前 我们可以画出来一个三角形了。但当多个三角形叠加时，如何确定遮挡关系呢？
Z-buffreing
Lecture 7：Shading着色1 Blinn-Phong 光照模型 （布林冯光照模型） 是一种光照模型，它在速度上相当快，成为许多 CG 软件中的默认光照渲染方法。此外它也集成在了大多数图形芯片中，用以产生实时快速的渲染。
考虑了漫反射、高光、环境光
漫反射项 单位面积上光线能量强度与传播距离成r²的反比，单位面积上的能量将由距离的增加而衰减
图中蓝色写错了，应该是由余弦定理计算的接受的能量 公式中的max是因为如果n·l的值是负的，那么就取0漫反射与观测的方向没有关系，漫反射向四面八方发射的能量球壳是均匀的 高光项 与漫反射不同，高光与视野角度有关，视线方向离镜面反射越近看到的高光越亮，这个模型认为视线v与光照方向I的对角线方向h离法线方向越近（α角度越小）则高光越亮系数p的解释如下：
cosα是小于1的，其他系数不变时，p越大，高光L就越小，目的是为了防止计算出来的高光太大而不真实
环境光照项 做了一个非常大胆的简化操作，他认为环境光与光照方向、视线都没关系，由四面八方过来的光是一样的强度I， K给予颜色此时环境光变成了一个常数，就是为了保证不是全黑 布林冯光照模型汇总 Lecture 8：着色2-图形管线，纹理映射 着色频率 着色频率：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad5e9cc53ea55f8cf14fea8de7b7302c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/442227734772e57879ae647d767e37b4/" rel="bookmark">
			【opencv4】opencv视频教程 C&#43;&#43;（opencv教程）3、矩阵的掩膜操作（filter2D）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上一讲：【opencv4】opencv视频教程 C++（opencv教程）2、加载，修改，保存图像
下一讲：【opencv4】opencv视频教程 C++（opencv教程）4、Mat对象使用（深拷贝：clone()、copyTo()，create()创建图片，Scalar()创建向量）
[opencv_C++] 入门强推！！！【B站最全】
文章目录 矩阵的掩膜操作获取图像像素指针像素范围处理`saturate_cast`函数调用filter2D功能 代码示例关于filter2D计算原理 矩阵的掩膜操作 获取图像像素指针 像素范围处理saturate_cast&lt;uchar&gt; 函数调用filter2D功能 代码示例 #include &lt;opencv2/opencv.hpp&gt; #include &lt;iostream&gt; using namespace cv; int main(int argc, const char* argv[]) { Mat src, dst; src = imread("./test.jpg"); //if (src.empty()) { if (!src.data){ printf("could not load image...\n"); return -1; } namedWindow("input img");	//默认自动窗口大小 imshow("input img", src); /* //看不懂啊！20220201 大年初一 int cols = (src.cols - 1) * src.channels();	//src分辨率是580×326的，src.cols=580是列数，src.channels()=3是通道数，最终计算cols=1737（579×3） int offsetx = src.channels();	//3 int rows = src.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/442227734772e57879ae647d767e37b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/627d7efae0a04f6fe686ee674d69cd1a/" rel="bookmark">
			stm32进不去串口中断的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天遇到了特别棘手的问题，程序进入串口中断
原本应该进入这段程序：
void USART1_IRQHandler(void) { if(USART_GetITStatus(USART1,USART_IT_RXNE)!=RESET) { USART_SendData(USART1,USART_ReceiveData(USART1)); while(USART_GetFlagStatus(USART1,USART_FLAG_TXE)==RESET); } } 将发送给串口的文字，通过串口输出出来
但是我发现以前的程序能用，这次的程序不能用，后来我对比了半天，发现程序一模一样。
就是后来写的哪个不能用，后来只能一段一段复制，最后发现，
原来是主函数没有加while(1);
中断没有这个函数就进不去了
哈哈哈啊哈哈哈哈哈哈哈哈哈哈啊哈。。。。。。。。。。。。。。。。。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d6f705a951aee6e3f15bf056e8cdb0c/" rel="bookmark">
			Xshell7下载与安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Xshell 7官方中文 下载与安装
2.解压有关文件 2.1 下载完成后进行解压，并进入解压后的文件夹
2.2 点击评估版进入下一级目录，并将NetSarang.7.x.Patch.rar 文件解压，解压密码：
www.jb51.net 1 3.安装Xshell 7 3.1 双击Xshell-7.0.0076.exe，进入安装程序，下一步
3.2 在目的地文件夹记得按照自己电脑的内存和使用习惯修改安装目录路径，并记住路径（后面要用），其余的一律默认并下一步即可
3.3 在最后一步时，记得取消下图中的复选框，不要立即运行Xshell 7，并点击完成
4.使用注册补丁文件，脱离产品密钥依赖 4.1 将解压后的NetSarang.7.x.Patch.exe从下载文件夹复制至xshell的安装目录(即3.2 中安装时指定的安装目录）
4.2 双击NetSarang.7.x.Patch.exe，点击应用，完成后直接关闭窗口即可
5.运行Xshell，已能照常使用 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0a0fa66fb34f19a8621b34cc4b292e0/" rel="bookmark">
			win11打开文件夹卡顿解决办法汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		汇总网上的一些解决办法，可以挨着尝试一下：
方法一： cmd执行重启资源管理器可以免重启
针对我的电脑挺有用的，但作用不大
taskkill /im explorer.exe /f start c:\windows\explorer.exe 方法二： 对我来说没用，而且又产生黑框框的bug。（2021-12月更新：这个方法由好用了）
1：WIN+R ,输入 regedit, 打开注册表。
2：打开注册表如下位置：
计算机\HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Shell Extensions\Blocked
注意：若没有Blocked文件夹需要自己新建一个Blocked文件夹。
3：右键→新建→字符串值。输入如下值：{e2bf9676-5f8f-435c-97eb-11607a5bedf7}。
4：重启电脑（非常重要）。若要恢复删除新建的值即可（不影响正常使用）
方法三： 1、双击打开此电脑
2、点击此电脑顶部的更多
点击选项
3、点击查看，在下面找到”在单独的进程中打开文件夹窗口“
点击确定即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54247b7009a6761a3e2e99f931b096f7/" rel="bookmark">
			算法入门到进阶（三）——搜索技术（BFS和A*算法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 用BFS求最短路径A*算法与最短路径A*算法与八数码问题双向广搜题目思路 用BFS求最短路径 最短路径是图论的一个基本问题，有很多复杂的算法。不过，在特殊的地图中，BFS也是很好的最短路径算法。下面仍然以之前讲的“红黑瓷砖”为例进行分析，任务是求两点之间的最短路径。
如下图所示，黑点表示可以走的路，#表示不能走，求起点@到所有黑点的最短距离
方法很简单，从@出发用BFS搜索所有点，记录到达每个点时经过的步数，即可得到从@到所有黑点的最短距离，图c给出了答案。
在这个例子中，BFS搜最短路径的计算复杂度是O(V+E)，非常好。
这个例子很特殊，图是方格形的，相邻两点之间的距离相同。也就是说，绕路肯定更远，BFS先扩展到的路径，肯定就是最短的。
如果相邻的距离不同，绕路就可能更近，BFS就不适用了。关于最短路径的通用算法后面会详细介绍。
下面是A*算法和BFS的优化
A*算法与最短路径 BFS是一种“盲目的”搜索技术，它在搜索的过程中并不理会目标在哪里，只顾自己乱走，当然最后总会走到终点。
稍微改变上面的方格图，如下，现在的任务是求起点@到终点t的最短路径。
如果仍用BFS求解，程序会搜索所有的点，直到遇到t点。不过，如果让一个人走这个图他会一眼看出向右上方走可以更快地到达t地最短路径。人有“智能”，那么能否把这种智能教给程序呢？这就是“启发式”搜索算法。启发式搜索算法有很多种，A算法是其中比较简单的一种。
简单地说，A算法是“BFS+贪心”，有关贪心算法地解释，后面博客会介绍。（这里给大家推荐一篇博客，这个网页用动画演示了BFS，A*，Dijkstra算法的原理。
推荐网页-算法原理
）
在图a中，程序如何知道向右上方走能更快到达t？这里引入曼哈顿距离是指两个点在标准坐标系上的实际距离，在上图中@的坐标和t的坐标在横向和纵向的距离之和，它也被形象地称为“出租车距离”。
图b是从起点开始的第一轮BFS搜索，邻居点上标注的数字3是这个点到终点t的曼哈顿距离。图c是第2轮搜索，标注2的点是离终点更近的点，从这些点继续搜索；标注4和5的点距离终点远，先暂时停止搜索。经过多轮搜索，最后到达了终点t，如图d所示。
在这个过程中，图中很多“不好的”点并不需要搜索到，从而优化了搜索过程。
上面的图例比较简单，如果起点和终点之间有很多的障碍，搜索范围也会沿着障碍兜圈子，之后才能到达终点，不过，仍然有很多点不需要搜索。以下面的这幅图为例，进行分析
A是起点，B是终点，黑色方块是障碍，浅色阴影方块是用曼哈顿距离进行启发式搜索所经过的部分，其他无色方块是不需要搜索的。搜索结束后，得到一条最短路径，如上图的虚线。
这个方法就是A算法，下面给出他的一般性描述。
在搜索过程中，用一个评估函数对当前情况进行评估，得到最好的状态，从这个状态继续搜索，直到目标。设x是当前所在状态，f(x)是对x的评估函数，有：
f(x)=g(x)+h(x)
g(x)表示从初始状态到x的实际代价，它不体现x和终点的关系。
h(x)表示x到终点的最优路径的评估，它就是“启发式”信息，把h(x)称为启发函数。很显然，h(x)决定了A的算法优劣。
特别需要注意的是：h(x)不能漏掉最优解。
在上面的例子中，曼哈顿距离就是启发函数h(x)。曼哈顿距离是一种简单而且常用的启发函数。
在上面这个例子中，可以看出A*算法包含了BFS和贪心算法。
如果h(x)=0,有f(x)=g(x),就是普通的BFS算法，会访问大量的方块。如果g(x)=0,有f(x)=h(x),就是贪心算法，此时上图标注的“*”方块也会被访问到。贪心法的缺点是可能陷在局部最优中，例如陷在“ * ”的方块中，被堵在障碍后面，无法到达终点。 A*算法与八数码问题 八数码问题也可以用A*算法进行优化。通常考虑3种评估函数：
以不在目标位置的数码的个数作为评估函数以不在目标位置的数码与目标位置的曼哈顿距离作为估价函数。以逆序数作为评估函数（逆序数可以判断八数码是否有解） 双向广搜 双向广搜是BFS的增强版。
前面提到，可以把BFS想象成在一个平静的池塘丢一块石头，激起的波浪一层层扩散到整个空间，直接到达目标，就得到了从起点到目标点的最优路径。那么，如果同时在起点和目标点向对方做BFS，两个石头激起的波浪向对方扩散，将在中间的某个位置遇到，此时，即得到了最优路径。在绝大多数情况下，双向广搜比只做一次BFS搜索的空间要少很多，从而更有效率。
从上面的描述可知，双向广搜的应用场合是知道起点和终点，并且正向和逆向都能进行搜索。
下面是一个典型的双向广搜问题
题目 有一个8x8的棋盘，上面有4个棋子，棋子可以上下左右移动。给定一个初始状态和一个目标状态 ，问能否在8步之内到达 思路 题目确定了起点和终点，十分适合双向BFS。要求在8步之内到达，可以从起点和终点分别开始，各自广搜4步，如果出现交点则说明可达。
程序比较繁琐，也有很多细节，有兴趣的同学可以尝试练习此题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72720925ae5a42b2c48522e21ea65c90/" rel="bookmark">
			GPU并行计算与CUDA编程第2课第一节
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		来自炼数成金罗老师的课
并行编程的通讯模式（Communication Patterns）
1.1 什么是通讯模式
并行计算：很多线程的通力合作来解决一个问题。拿For循环距离，比如一个For循环循环一百次，CPU的话就是这100次一次一次的执行，但是GPU的话是这100次同时执行。
并行模式：1.同时读取同个位置。2.所有循环都往一个地方写数据。3. 不同的数据位置，还有一部分内容或结果是需要交换的。
最常见的通讯模式分别有：
1. 映射（Map）：输入输出关系：一一对应（one-to-one）。例子：每个元素倍数扩大，y[i]=3*x[i]
2. 聚合（gatter）:输入输出关系：多对一(many-to-one)，例如，每相邻三个元素求平均,y[i]=(x[i-1+x[i]+x[i+1]])/3。gather模型在图像领域用的非常多。
3. 分散（scatter）：与gatter对应，输入输出关系：一对多（one-to-many）不一定读入的值一个是一个，但一定是比输出的值少一些。
4. 模板(stencil):以固定的模式读取相邻的内存数值。输入输出关系：serveral-to-one 5.转置：输入输出关系：一对一(one-to-one) 6. 压缩reduce：输入输出关系：多对一(all-to-one) 输入输出关系：多对一（all-to-one） 7. 重排scan/sort，输入输出关系：多对多 1.2通讯模式的类型和原理
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e517a65c6c71c60ae598b23acdf432c/" rel="bookmark">
			centos7安装promethus(普罗米修斯)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 Prometheus(go语言开发)是一套开源的监控&amp;报警&amp;时间序列数 据库的组合。适合监控docker容器。因为kubernetes(俗称k8s)的流行带动 了prometheus的发展。
官网地址：https://prometheus.io/docs/introduction/overview/
Prometheus 主要特征 多维度数据模型灵活的查询语言不依赖分布式存储单个服务器节点是自主的 以HTTP方式，通过pull模型拉去时间序列数据也可以通过中间网关支持push模型 通过服务发现或者静态配置，来发现目标服务对象 支持多种多样的图表和界面展示 原理架构图 下面给出一张关于Prometheus 的原理架构图
图中主要组件及工作流程介绍：
Prometheus server 包含数据采集scrapes job, stores time series data；push gateway : Prometheus server的一个代理节点, 当一些节点没有提供HTTP endpoint时，可将数据push到代理节点，Prometheus会去代理节点获取数据;exporters: 数据采集插件, 暴露一个http服务的接口给Prometheus server定时抓取;alertmanager: 报警插件； Prometheus 适用的监控目标 系统监控对于任何一个庞大的应用来说都是必不可少的，设想类似淘宝这样的大型电商系统，支撑起正常高效运转的背后是众多的服务器组成的集群，设想如果在双11期间，某一台服务器发生了故障，没有及时的监控到故障，带来的损失将是不可估量的；
在《SRE: Google运维解密》一书中指出，监控系统需要能够有效的支持白盒监控和黑盒监控。通过白盒能够了解其内部的实际运行状态，通过对监控指标的观察能够预判可能出现的问题，从而对潜在的不确定因素进行优化。而黑盒监控，常见的如HTTP探针，TCP探针等，可以在系统或者服务在发生故障时能够快速通知相关的人员进行处理。通过建立完善的监控体系，从而达到以下目的：
长期趋势分析：通过对监控样本数据的持续收集和统计，对监控指标进行长期趋势分析。例如，通过对磁盘空间增长率的判断，我们可以提前预测在未来什么时间节点上需要对资源进行扩容；对照分析：两个版本的系统运行资源使用情况的差异如何？在不同容量情况下系统的并发和负载变化如何？通过监控能够方便的对系统进行跟踪和比较；告警：当系统出现或者即将出现故障时，监控系统需要迅速反应并通知管理员，从而能够对问题进行快速的处理或者提前预防问题的发生，避免出现对业务的影响故障分析与定位：当问题发生后，需要对问题进行调查和处理。通过对不同监控监控以及历史数据的分析，能够找到并解决根源问题数据可视化：通过可视化仪表盘能够直接获取系统的运行状态、资源使用情况、以及服务运行状态等直观的信息 Prometheus 优势及适合场景 Prometheus非常适合记录任何纯数字时间序列。它既适合以机器为中心的监视，也适合于高度动态的面向服务的体系结构的监视。在微服务世界中，它对多维数据收集和查询的支持是一种特别的优势Prometheus的设计旨在提高可靠性，使其成为中断期间要使用的系统，以使您能够快速诊断问题。每个Prometheus服务器都是独立的，而不依赖于网络存储或其他远程服务。当基础结构的其他部分损坏时，您可以依靠它，并且无需设置广泛的基础结构即可使用它 搭建步骤 下面来演示如何基于centos7快速搭建起Promethus的环境
1、环境准备
两台机器，Node1 ，用于安装Promethus，Node2 用于被监控或者在上面安装其他被监控的服务Promethus 安装包，grafana安装包以及node_exporter安装包 2、Node1上传prometheus-2.26.0 安装包
上传并解压prometheus 安装包
tar -zxvf prometheus.... mv prometheus-2.26.0.linux-amd64 prometheus2.26 3、启动prometheus服务
默认情况下，不需要做任何的配置和修改，直接使用下面的命令启动即可
./prometheus --config.file=prometheus.yml &amp; 启动成功后，prometheus 默认暴露的服务访问端口为 9090 ，可以使用下面的命令检查prometheus服务状态 ，
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e517a65c6c71c60ae598b23acdf432c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/633f88832178d8f3435bf8a417f4c0ae/" rel="bookmark">
			【蓝桥杯单片机学习记录7】DS18B20的温度转换与读取流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
DS18B20的温度转换与读取流程
DS18B20的数据处理
主程序
onewire.h
onewire.c DS18B20的温度转换与读取流程 DS18B20复位写入字节0xcc，跳过ROM指令写入字节0x44，开始温度转换延时700~900msDS18B20复位写入字节0xcc，跳过ROM指令写入字节0xbe，读取高速暂存器读取暂存器的第0字节，即温度数据的LSB读取暂存器的第1字节，即温度数据的MSBDS18B20复位，表示读取数据结束将LSB和MSB整合成一个16位数据判断读取结果的符号，进行正负温度的数据处理 //DS18B20温度采样与结果处理参考代码 void Read_Temperature() { unsigned char LSB,MSB ; Init_DS18B20();	//DS18B20复位	Write_DS18B20(0xCC);	//跳过ROM操作指令 Write_DS18B20(0x44); //开始温度转换 Delay(1000); //延时700ms左右，等待温度转换完成 Init_DS18B20();	//DS18B20复位 Write_DS18B20(0xCC);	//跳过ROM操作指令	Write_DS18B20(0xBE);	//开始读取高速暂存器	LSB = Read_DS18B20();	//读取温度数据的低8位 MSB = Read_DS18B20();	//读取温度数据的高8位 Init_DS18B20();	//DS18B20复位，停止暂存器数据读取 T_dat = 0x0000; T_dat = MSB; T_dat &lt;&lt;= 8; T_dat = T_dat | LSB; //将LSB和MSB整合成为一个16位的整数 //首先通过温度数据的高5位判断采用结果是正温度还是负温度 if((T_dat &amp; 0xf800) == 0x0000) //正温度的处理办法 { T_dat &gt;&gt;= 4; //取出温度结果的整数部分 T_dat = T_dat*10; //放大10倍，然后加上小数部分 T_dat = T_dat + (LSB&amp;0x0f)*0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/633f88832178d8f3435bf8a417f4c0ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6e0733539ac0fc3e0b10bf929b12cd1/" rel="bookmark">
			Linux中函数库文件依赖关系查找网站 www.rpmfind.net
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		例如，手动安装光盘里的httpd软件包，会提示需要依赖其他的包，前面几个还可以根据名字用tab键补全，但是最后发现需要安装“libodbc.so.2”函数库文件，看到这个.so结尾的就知道是函数库文件，这时会发现在光盘中根本找不到这个文件。那是因为函数库没有单独成包，是包含在某一个软件包中的。而如果要知道在哪个软件包中，需要查询网站:
www.rpmfind.net
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74e8ed56d73ce905d17c98cc3f2d3e72/" rel="bookmark">
			OpenCV 配置选项参考文档
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OpenCV 配置选项参考文档 介绍通用选项和附加模块一起构建调试（Debug）构建静态构建生成 pkg-config 信息构建测试、示例和应用只构建部分模块下载的依赖项CPU 优化级别性能分析、代码覆盖率、清理、强化、size optimization 功能特性与依赖项相关选项命名规范异构计算对 CUDA 的支持对 OpenCL 的支持 图像的读写（imgcodecs 模块）内置格式对 PNG, JPEG, TIFF, WEBP 的支持GDAL 集成GDCM 集成 视频的读写（videoio 模块）Video4LinuxFFmpegGStreamerMicrosoft Media FoundationDirectShowAVFoundation其它后端videoio plugins 并行处理多线程插件 GUI 后端（highgui 模块）OpenGLhighgui 插件 深度学习神经网络推断后端和选项 （dnn 模块） 安装布局安装根目录组件和位置 其他功能自动化构建Contrib 模块 尚未写入文档的其它选项 本文参考官方文档 OpenCV configuration options reference，更新的内容请参考此文档。
由于博主水平有限，且刚接触 OpenCV，翻译有不通顺、错误的地方，请大佬们指正。本文会龟速长期纠正更新。
介绍 💡 NOTE: 本文假设您已阅读 OpenCV installation overview 教程或具有 CMake 的操作经验。
可以通过几种不同的方式设置配置选项：
命令行：cmake -Doption=value ...初始缓存文件： cmake -C my_options.txt ...通过图形用户界面（GUI，cmake-gui）进行交互操作 本文中将使用常规命令行。
大部分选项都可以在 OpenCV 的根 CMake 脚本中找到：opencv/CMakeLists.txt。 一些选项可能在特定的模块中被定义。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/74e8ed56d73ce905d17c98cc3f2d3e72/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04c71a5bb659195ac7998a9f9e1b0ada/" rel="bookmark">
			LeetCode -1631 最小体力消耗路径
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		class Solution { public class Edge{ int len; int x; int y; public Edge(int len,int x,int y){ this.len = len; this.x = x; this.y = y; } } public int minimumEffortPath(int[][] heights) { int m = heights.length; int n = heights[0].length; List&lt;Edge&gt; edges = new ArrayList&lt;&gt;(); for(int i=0;i&lt;m;i++){ for(int j=0;j&lt;n;j++){ if(i &lt; m-1){ int num1 = i * n + j; int num2 = (i+1) * n + j; edges.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04c71a5bb659195ac7998a9f9e1b0ada/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b97760b077f91234c68c18a3aa1670ba/" rel="bookmark">
			Verilog &#43;: -:语法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		“+:”、"-:"语法
看到这个语法的时候是在分析AXI lite 总线源码时碰见的，然后查阅了资料，做出如下解释。
1.用处
这两个应该算是运算符，运用在多位的变量中，如下：
slv_reg0[(byte_index8) +: 8] &lt;= S_AXI_WDATA[(byte_index8) +: 8]；
2."+:"
变量[起始地址 +: 数据位宽] &lt;–等价于–&gt; 变量[(起始地址+数据位宽-1)：起始地址]
data[0 +: 8] &lt;--等价于--&gt; data[7:0]
data[15 +: 2] &lt;--等价于--&gt; data[16:15]
1
2
3."-:"
变量[结束地址 -: 数据位宽] &lt;–等价于–&gt; 变量[结束地址：(结束地址-数据位宽+1)]
data[7 -: 8] &lt;--等价于--&gt; data[7:0]
data[15 -: 2] &lt;--等价于--&gt; data[15:14]
1
2
End
相关语法为自己的理解，如有不对的地方，请大家留言讨论
————————————————
版权声明：本文为CSDN博主「我看唔人生」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/feiliantong/article/details/107782129
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08ff35db9706098fcc3b679f6137f1c9/" rel="bookmark">
			《华为机试》刷题之HJ54 表达式求值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、题目 二、示例 输入：400+5 输出：405 三、代码 print(int(eval(input()))) 四、算法说明 使用eval()函数，一行代码搞定。
胡萝卜
我不知道将去向何方，但我已在路上！ 时光匆匆，虽未曾谋面，却相遇于斯，实在是莫大的缘分，感谢您的到访 ！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e7f5859405fa7ebeaeb272fdc15f6e0/" rel="bookmark">
			C&#43;&#43;自动化(模板元)编程基础与应用(3)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#if 0
在前面的两章里面讨论了C++模板元作为C++的一门二级语言的问题，并给出了常用的
程序设计语言的语素的实现，是一个完备的体系。总的来说，前面的章节里面是采用了下
面的方法来实现这些语素的：
(1)整数计算结果通过enum变量进行保存
(2)类型计算结果通过typedef进行保存
(3)?:运算符可用来实现静态整型表达式的选择功能
(4)模板特化可用来实现静态类型表达式的选择功能
(5)模板递归可用来实现静态循环，循环变化元素只能够是整数
(6)通过整数可以映射到类型，所以循环变化元素也可以间接为类型
这一章里面我们将要讨论另外的问题，所采用的方法也是这些方法。那么本文将要讨
论的问题是：
如何实现类型循环，也就是上面总结出来的第(6)种技巧。
关于这一点的讨论，我认真参考了&lt;&lt;Modern C++ Design&gt;&gt;一书的Typelist，在本文中
将会以cons来表达类型列表的概念，并对&lt;&lt;Modern C++ Design&gt;&gt;一书的Typelist相关的操
作进行精简，得到我们将会在生成代码的过程中使用的模板元函数。不用的根本不会考虑
，所以为了使撤销和重做库尽可能的独立些，所以我不采用Loki库，这样使得该撤销和重
做库的安装比较简单。
为此，首先实现一个类型串类型名叫cons，代码如下：
#endif
#ifdef CODE_NOTE
//cons的实现，采用和STL类似的类型命名方式
template &lt;class FirstType,class SecondType&gt;
struct cons
{
typedef FirstType first_type;
typedef SecondType second_type;
};
//有了上面的cons的实现，现在就可以很容易的将类型放入到这个串中了：
typedef cons&lt;char,
cons&lt;int,
cons&lt;short,
cons&lt;long,
cons&lt;float,
double&gt; &gt; &gt; &gt; &gt; CONS;
//上面的代码定义了一个6中基本类型作为元素的类型串CONS，那么该怎么实现对上面的类
//型的操作呢？仔细想想C语言里面的字符串是如何处理字符串的终结的啊！呵呵可能你已
//经想到了，需要一个特殊的终结符，对了，为了能够操作上面的类型容器我们需要定义
//一个终结符类型：
struct null_type;
//有了上面的null_type，现在的类型容器CONS重新表述如下：
typedef cons&lt;char,
cons&lt;int,
cons&lt;short,
cons&lt;long,
cons&lt;float,
cons&lt;double,
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e7f5859405fa7ebeaeb272fdc15f6e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c696750b3c4a0558b50f594576de5263/" rel="bookmark">
			C&#43;&#43;自动化(模板元)编程基础与应用(4)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#if 0
这一章，我们将要开始的讨论C++里面的代码生成技术。说起代码生成技术，实际上这
并不是C++的专利，作为C++子集的C语言早就已经使用了一定的代码生成技术，这就是C宏
。我想C宏大家应该非常熟悉了吧，特别是能够实现带参数的宏使得大量的库利用这种技术
来生成那些格式重复的代码，例如：微软的MFC库，跨平台的GUI库wxWidget，Boost库等等
都使用了C宏。虽然C宏在这些库里面扮演了非常重要的角色，并且仍将扮演非常重要的角
色，但是也不得不说：C宏存在着很大的问题。最基础的就是类型不安全性，这也是C++里
面出现模板语素的一个比较重要的原因。更重要的是使用C宏生成的代码仅仅只是实现了简
单的格式填空能力，并不能表达特定的算法。正是C宏的表达设计思想的不足限制了C宏的
使用范围。
说起C++模板的代码生成能力，说起来这也是一种巧合，自从90年代初期第一个C++模
板元程序（用来在编译期输出质数）被发现以来，C++迷们对模板元程序的研究就热闹起来
了，并出现了大量的关于C++模板元程序的文献。在这里我所介绍的模板元代码生成技术主
要参考了&lt;&lt;Modern C++ Design&gt;&gt;一书的GenScatterHierarchy结构，并对这种结构进行了
扩展应用，采用了前面的LOOP静态循环实现对这种结构生成的代码的操作，从而完成了一
个C++普通类的自动生成过程。所谓的C++普通类指的是一般的手工直接编写的一个类，这
种类通常包含成员变量，生成成员变量的过程可以由GenScatterHierarchy结构完成，但是
仅仅有了成员变量还不能成为一个C++类，或许成为结构体更合适；另外普通类一般还包含
了成员函数，这种成员函数的自动生成就不能通过Loki库来实现自动生成了，虽然Loki库
的GenLinearHierarchy结构可以生成函数接口，但是函数体里面的内容就不能够随心所欲
的编写了。这后面的一点正是在本文中将要进行详细讨论的。
好了，现在我们来分析前面的章节中介绍的模板元技术中已经蕴涵的代码生成技术。
实际上LOOP静态循环中已经实现了静态函数的自动生成，也就是说，编译器在编译的时候
确确实实是看到了循环所产生的所有的静态函数，而并不是运行的时候进行的函数递归调用
。下面我们来看看C++里面的多继承现象和参数化继承现象：
#endif
#ifdef CODE_NOTE
//多继承现象
class Base1{};
class Base2{};
class Base3{};
class Derived:public Base1,public Base2,public Base3{};
//模板参数化继承现象：
template &lt;class T&gt;Base{};
class Derived:public Base&lt;char&gt;,public Base&lt;int&gt;,public Base&lt;float&gt;{};
#endif//CODE_NOTE
#if 0
从上面的多继承和参数化的多继承我们可以得到什么灵感呢？如果没有，那么再考虑
一下上一章中所介绍的类型串类型，^_^这时候有没有灵感了呢？呵呵，实际上上面的代码
中的参数化多继承的基类就是一个类型遍历过程，针对每一个类型，用Base包裹住每一个
类型并作为Derived类的基类，这样就可以生成一个自己定制的类了。如果能够使这个过程
自动化，那么我们就可以认为代码被自动生成了。
现在考虑一下上面的自动化过程所需要的输入和输出分别是什么：
输入：一个cons类型串记录所有的需要的类型，一个包裹模板类
输出：生成一个由所有的cons类型串中的类型作为模板参数的包裹类作为基类的类
这样如果在包裹类里面定义了一个模板参数类型的成员变量，那么生成的类中就有所
有的这些类型的变量，也就是说这些变量都成了生成的类的成员变量。
好了，说到这里，我们来看看具体的实现过程是怎样的：
#endif
#ifdef CODE_NOTE
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c696750b3c4a0558b50f594576de5263/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df54b06bbe82ee0ee48ef9aebbe8882b/" rel="bookmark">
			org.apache.catalina.connector.ClientAbortException: java.io.IOException: Broken pipe
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		场景：客户端向服务端发起请求后，服务端向客户端返回数据时，服务端抛出异常
java.io.IOException: Broken pipe org.apache.catalina.connector.ClientAbortException: java.io.IOException: Broken pipe at org.apache.catalina.connector.OutputBuffer.realWriteBytes(OutputBuffer.java:351) at org.apache.catalina.connector.OutputBuffer.flushByteBuffer(OutputBuffer.java:776) at org.apache.catalina.connector.OutputBuffer.append(OutputBuffer.java:681) at org.apache.catalina.connector.OutputBuffer.writeBytes(OutputBuffer.java:386) at org.apache.catalina.connector.OutputBuffer.write(OutputBuffer.java:364) at org.apache.catalina.connector.CoyoteOutputStream.write(CoyoteOutputStream.java:96) at org.springframework.session.web.http.OnCommittedResponseWrapper$SaveContextServletOutputStream.write(OnCommittedResponseWrapper.java:624) at com.fasterxml.jackson.core.json.UTF8JsonGenerator._flushBuffer(UTF8JsonGenerator.java:2137) at com.fasterxml.jackson.core.json.UTF8JsonGenerator._writeBytes(UTF8JsonGenerator.java:1226) at com.fasterxml.jackson.core.json.UTF8JsonGenerator.writeFieldName(UTF8JsonGenerator.java:288) at com.fasterxml.jackson.databind.ser.BeanPropertyWriter.serializeAsField(BeanPropertyWriter.java:725) at com.fasterxml.jackson.databind.ser.std.BeanSerializerBase.serializeFields(BeanSerializerBase.java:722) at com.fasterxml.jackson.databind.ser.BeanSerializer.serialize(BeanSerializer.java:166) at com.fasterxml.jackson.databind.ser.BeanPropertyWriter.serializeAsField(BeanPropertyWriter.java:727) at com.fasterxml.jackson.databind.ser.std.BeanSerializerBase.serializeFields(BeanSerializerBase.java:722) at com.fasterxml.jackson.databind.ser.BeanSerializer.serialize(BeanSerializer.java:166) at com.fasterxml.jackson.databind.ser.impl.IndexedListSerializer.serializeContents(IndexedListSerializer.java:119) at com.fasterxml.jackson.databind.ser.impl.IndexedListSerializer.serialize(IndexedListSerializer.java:79) at com.fasterxml.jackson.databind.ser.impl.IndexedListSerializer.serialize(IndexedListSerializer.java:18) at com.fasterxml.jackson.databind.ser.BeanPropertyWriter.serializeAsField(BeanPropertyWriter.java:727) at com.fasterxml.jackson.databind.ser.std.BeanSerializerBase.serializeFields(BeanSerializerBase.java:722) at com.fasterxml.jackson.databind.ser.BeanSerializer.serialize(BeanSerializer.java:166) at com.fasterxml.jackson.databind.ser.impl.IndexedListSerializer.serializeContents(IndexedListSerializer.java:119) at com.fasterxml.jackson.databind.ser.impl.IndexedListSerializer.serialize(IndexedListSerializer.java:79) at com.fasterxml.jackson.databind.ser.impl.IndexedListSerializer.serialize(IndexedListSerializer.java:18) at com.fasterxml.jackson.databind.ser.BeanPropertyWriter.serializeAsField(BeanPropertyWriter.java:727) at com.fasterxml.jackson.databind.ser.std.BeanSerializerBase.serializeFields(BeanSerializerBase.java:722) at com.fasterxml.jackson.databind.ser.BeanSerializer.serialize(BeanSerializer.java:166) at com.fasterxml.jackson.databind.ser.DefaultSerializerProvider._serialize(DefaultSerializerProvider.java:480) at com.fasterxml.jackson.databind.ser.DefaultSerializerProvider.serializeValue(DefaultSerializerProvider.java:319) at com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df54b06bbe82ee0ee48ef9aebbe8882b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/829bd03d85bfef2c93dce5c0d1ec1181/" rel="bookmark">
			六、计算机网络-子网划分
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为什么要进行子网划分？
方便管理 方便识别
什么是子网划分
网络位向主机位借位
T1.192.168.1.0/24划分为4个小网段，求每个子网的有效ip地址段、子网掩码、广播地址
192.168.1.0默认子网掩码为255.255.255.0，即192.168.1为网络号，子网划分需要从第四个个字节第一个比特开始。划分4个子网需要向主机位借2位{00,01,10,11}
子网1网络地址:192.168.1.00000000，即192.168.1.0
子网2网络地址:192.168.1.01000000，即192.168.1.64
子网3网络地址:192.168.1.10000000，即192.168.1.128
子网4网络地址:192.168.1.11000000，即192.168.1.192
所以每个子网的有效ip段为（全0和全1均不采用）广播地址为：
子网1：192.168.1.1 ~ 192.168.1.62 192.168.1.63
子网2：192.168.1.65 ~ 192.168.1.126 192.168.1.127
子网1：192.168.1.129 ~ 192.168.1.190 192.168.1.191
子网1：192.168.1.193 ~ 192.168.1.254 192.168.1.255
子网掩码为192.168.11000000，即192.168.1.192
T2.192.168.99.4/26：计算这个IP地址所在子网的有效ip的范围，以及所在子网的广播地址
子网掩码为：255.255.255.192
ip地址与子网掩码相与得到网段号192.168.99.0
有效的ip地址范围为192.168.99.1~192.168.99.62
广播地址为192.168.99.63
T3可变长子网掩码
192.169.100.0/24 --》
192.168.100.0/25 /
192.168.100.128/25--&gt;
192.169.100.128/26 /
192.169.100.192/26
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52bc2ae40d2898c61de85b0c478e1fab/" rel="bookmark">
			linux下GPU显存无法释放
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.背景 使用pytorch中的ddp训练模型的时候，由于程序报错，我反复运行py文件，导致显存不够
2. 解决方法 使用 nvidia-smi 命令（或者该fuser -v /dev/nvidia* ）看有哪些进程，使用kill -9 PID
nvidia-smi kill -9 PID 实际中，我先使用了 nvidia-smi +kill -9 PID，但是显存还是无法清理干净。故使用了fuser -v /dev/nvidia +kill -9 PID*
fuser -v /dev/nvidia* kill -9 PID 3.参考 https://www.freesion.com/article/39066220/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4a5d49b532ee42a50ac4309a52cec60/" rel="bookmark">
			Matlab R2018b 安装时提示【弹出DVD1 并插入DVD2】 解决办法汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 matlab安装包越来越大，有时分为两个镜像文件，DVD1 和 DVD2
安装时两个DVD都有用，都要下载和打开
安装过程 打开DVD1，点击setup.exe就开始安装
安装过程中会出现 “弹出DVD1并插入DVD2” 的提示，安装被中断
原因，是两个镜像文件打开后，驱动器序号不同，如下图所示
DVD1：J
DVD2：K
由于我是用 DVD1 的 setup.exe，安装 Matlab。电脑只认驱动器 J，找不到 K
所以情况就是：
两个DVD都打开了，安装过程中仍提示 “弹出DVD1，并插入DVD2” 。它们的驱动号不同，电脑根据驱动号J只找到DVD1
解决办法 弹出提示后，打开磁盘管理器 windows打开磁盘管理器修改DVD2的驱动器号，把它改成DVD1的驱动器号。 不同电脑中显示的DVD驱动器号不一样，在我这是把DVD2的K改为J
具体的过程见下面方法1
方法1：
修改驱动器号
https://blog.csdn.net/Lasper_csdn/article/details/79776393
效果：尝试。可以！
方法2
安装前将两个iso文件解压到同一个文件夹中
https://blog.csdn.net/m0_37638031/article/details/78982498 或者
https://jingyan.baidu.com/article/f7ff0bfc32700e2e26bb130f.html
效果：并未亲自尝试，未知
方法3
共享DVD2
https://blog.csdn.net/niuxiaolei/article/details/80596183
效果：无效
方法4
把两个光驱全部弹出后，然后加载镜像2 文件，最后点击继续
https://blog.csdn.net/dawn_after_dark/article/details/54845956
效果：无效，除非打开DVD2的驱动器号碰巧是DVD1的驱动器号
方法5
安装前把两个iso文件都打开
https://blog.csdn.net/Bthsky/article/details/78230285
效果：无效
上一步完成后再激活，就安装成功了
本篇完~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/715e66fce1a660470d9f175b67666fda/" rel="bookmark">
			【SpringBoot&#43;Vue】完结——小型部门管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 项目构建1.1 前端项目搭建1.2 后端项目搭建1.3 数据库设计 2. 查询数据2.1 后端实现2.2 前端实现 3. 加载菜单3.1 引入Element UI3.2 菜单 4. 带分页数据查询4.1 后端接口实现4.2 前端实现 5. 部门员工信息的录入5.1 后端接口的实现5.2 前端实现 6. 部门数据编辑6.1 后端接口实现6.2 前端实现 7. 部门数据删除7.1 后端接口实现7.2 前端实现 整本书学习过程所有文档以及项目文件以及作者的项目文件都已上传至网盘，提取码如下：链接：https://pan.baidu.com/s/1LQPqtQiqVYjkUNAQWESGSQ
提取码：ziyi
1. 项目构建 1.1 前端项目搭建 使用Vue-cli脚手架快速搭建前端项目
vue init webpack deptvuenpm install 1.2 后端项目搭建 使用Spring Initializer快速创建SpringBoot模板项目
1.3 数据库设计 采用MySQL，表结构如下：
2. 查询数据 2.1 后端实现 配置文件
在application.yml文件中配置数据库连接、JPA及端口等信息：
spring: datasource: #key：后必须加空格，否则执行报错 url: jdbc:mysql://localhost:3306/test4?serverTimezone=CTT&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;allowMultiQueries=true username: root password: admin123 driver-class-name: com.mysql.cj.jdbc.Driver jpa: show-sql: true properties: hibernate: formate_sql: true server: port: 8081	#需要修改端口，否则和前端端口冲突 实体类
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/715e66fce1a660470d9f175b67666fda/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36015d9358a26fb7ae0698a7c4794492/" rel="bookmark">
			禅道备份、迁移和恢复
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
备份
迁移和恢复
1.安装相同版本的zbox
2.恢复原禅道上的数据
解决禅道admin忘记密码
备份 需拷贝在以下路径的数据：备份/opt/zbox/app/zentao/www/data/upload/1和/opt/zbox/data/mysql/zentao的数据
迁移和恢复 前提条件：在目标服务器上，安装相同版本的zbox一键安装包
1.安装相同版本的zbox 具体操作步骤如下：
# 1.从备份服务器上将对应禅道开源版的安装包拷贝到目标服务器上 $ scp root@xx.xx.xx.xx:/public/install/setup/ZenTaoPMS.12.0.1.zbox_64.tar.gz /data/download root@dj:/data/download# ls ZenTaoPMS.12.0.1.zbox_64.tar.gz # 2.解压安装包到/opt目录下 $ tar -zxvf ZenTaoPMS.12.0.1.zbox_64.tar.gz -C /opt # 3.修改禅道自带的apache、mysql端口，默认的apache和mysql的端口号为80/3306 $ /opt/zbox/zbox -ap 8070 -mp 3308 # 4.启动禅道服务并查看禅道服务的状态 $ /opt/zbox/zbox start Start Apache success Start Mysql success $ /opt/zbox/zbox status Apache is running Mysql is running # 5.配置iptables防火墙规则，允许端口访问 Ubuntu20.04一般都默认安装了UFW（Uncomplicated Firewall），它是一款轻量化的工具，主要用于对输入输出的流量进行监控，如果没有安装，执行命令安装：sudo apt install ufw 1）启用ufw $ ufw enable Command may disrupt existing ssh connections.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/36015d9358a26fb7ae0698a7c4794492/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c186a57bb46dd563307851fefd534cb/" rel="bookmark">
			【SpringBoot】SpringBoot——Spring Security安全框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 6. Spring Boot安全框架6.1 认识Spring Security6.1.1 入门项目6.1.2 角色访问控制 6.2 基于数据库的认证6.2.1 Spring Security基于数据库认证6.2.2 角色访问控制6.2.3 密码加密保存6.2.4 用户角色多对多关系6.2.5 角色继承 6. Spring Boot安全框架 6.1 认识Spring Security Spring Security致力于为Java应用提供核心功能认证(Authentication)和授权管理(Authorization)。
认证：主要是为了解决我是谁的问题，通过提供证据证明你是你说的那个人。
授权：主要是为了解决我能干什么的问题。
它是一个强大的、高度自定义的认证和访问控制框架。其核心就是一组过滤器链，项目启动后会自动配置。最核心就是Basic Authentication Filter用来认证用户的身份，在Spring Security中一种过滤器处理一种认证方式，如下所示：
(图源：https://www.jianshu.com/p/ef1e218f014a)
6.1.1 入门项目 创建项目
创建一个Spring Boot的Web项目，添加Spring Security依赖：
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; 控制器
新建HelloController类，添加/hello接口：
@RestController public class HelloController { @RequestMapping("/hello") public String home() { return "Hello ,spring security!"; } } 测试
启动项目，在浏览器访问http://localhost:8080/login接口会自动跳转到登录页面，这是Spring Security提供的，如下所示：
说明Spring Security已经起作用了，它会把项目里的资源保护起来。Spring Security默认用户名是user，Spring Security启动的时候会生成默认密码，在启动日志可以看到。填入用户名和密码后就可以成功访问接口了。
自定义用户名和密码
也可以自己设置用户名和密码，在application.yml中添加如下配置：
spring: security: user: name: admin password: 123456 重启项目，访问被保护的/hello接口。自动跳转到了默认的登录页面，输入用户名和密码后成功跳转到了/hello。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c186a57bb46dd563307851fefd534cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/264ae5a30689754b152ac377b817db3e/" rel="bookmark">
			C&#43;&#43;中的复制构造函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Copy Constructor in C++
What is a copy constructor? （什么是复制构造函数？） A copy constructor is a member function that initializes an object using another object of the same class. A copy constructor has the following general function prototype:
复制构造函数是一个成员函数，它使用同一类的另一个对象来初始化一个对象。复制构造函数具有以下通用函数原型：
ClassName (const ClassName &amp;old_obj); Following is a simple example of copy constructor.
#include&lt;iostream&gt; using namespace std; class Point { private: int x, y; public: Point(int x1, int y1) { x = x1; y = y1; } // Copy constructor Point(const Point &amp;p1) {x = p1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/264ae5a30689754b152ac377b817db3e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a38a7e446727e3605ecec4aaa61a2d0/" rel="bookmark">
			Linux中网卡绑定的基础知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 简介2. 配置bond绑定2.1 概述2.2 常用bond配置2.3 BONDING_OPTS选项说明 3. 修改bond配置4. 查询bond配置4.1 查询bond情况4.2 查询网络情况 5. 交换机配置要求参考文档 1. 简介 Linux网卡绑定程序提供了一种将多个网络接口聚合为单个逻辑接口的方法。逻辑接口的行为取决于模式，一般来说，不同模式分别提供热备或负载均衡的服务。
2. 配置bond绑定 2.1 概述 您可以使用发行版的网络初始化脚本配置网络绑定，也可以使用iproute2或sysfs接口手动配置网络绑定。发行版通常使用三个包中的一个初始化网络：initscripts、sysconfig或interfaces。iproute2多用于SuSE 8；安装sysfs文件系统才能使用sysfs接口进行bond配置；sysconfig多用于SuSE 9；initscripts多用于Red Hat；interfaces多用于Debian。如果实在不知道操作系统可以使用哪种方式做bond，可以尝试以下方法：
首先，在/etc/network目录中查找名为interfaces的文件。如果系统中存在此文件，则系统将使用interfaces。
否则，测试以下命令：
$ rpm -qf /sbin/ifup 它的响应为一行以“initscripts”或“sysconfig”开头的文本，后跟一些数字。这是提供网络初始化脚本的软件包。
2.2 常用bond配置 本节适用于支持网卡绑定的具有initscripts软件包的发行版，例如Red Hat Enterprise Linux 3或更高版本、Fedora等。在这些系统上，网络初始化脚本可以配置为绑定控制设备。
在企业版Linux中，除非ethX设备配置了IP地址，否则系统不会自动加载网卡驱动程序。由于此限制，用户必须为bondX成员的所有物理网卡手动配置网络脚本文件。网络脚本文件位于目录中：
/etc/sysconfig/network-scripts 文件名必须以“ifcfg-eth”作为前缀，并以网卡的物理网卡号作为后缀。例如，eth0的脚本名为 /etc/sysconfig/network-scripts/ifcfg-eth0。将以下文本放入文件中：
# vi /etc/sysconfig/network-scripts/ifcfg-eth0 DEVICE=eth0 USERCTL=no ONBOOT=yes MASTER=bond0 SLAVE=yes BOOTPROTO=none 每个ethX设备的 “DEVICE=” 行将不同，并且必须与文件名相对应，即ifcfg-eth1的相应行必须为“DEVICE=eth1”。“MASTER=” 行的设置取决于绑定接口名称。与其他网络设备一样，它们通常从0开始，每个设备向上一个，即第一个绑定实例是bond0，第二个是bond1，依此类推。
接下来，创建一个绑定网络脚本。此脚本的文件名为 /etc/sysconfig/network-scripts/ifcfg-bondX，其中X是绑定的编号。对于bond0，文件名为“ifcfg-bond0”，对于bond1，文件名为“ifcfg-bond1”，依此类推。在该文件中，写入以下文本：
# vi /etc/sysconfig/network-scripts/ifcfg-bondX DEVICE=bond0 IPADDR=192.168.1.1 NETMASK=255.255.255.0 NETWORK=192.168.1.0 BROADCAST=192.168.1.255 ONBOOT=yes BOOTPROTO=none USERCTL=no 更改特定行（IPADDR，NETMASK，NETWORK 和 BROADCAST）以匹配您的网络配置。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a38a7e446727e3605ecec4aaa61a2d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5692958c116b6cb6faea0853dafa34ef/" rel="bookmark">
			ARM 汇编指令集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		寄存器 寄存器的寄存器用于数据处理及控制。
如内存中数据处理，需先从内存中加载数据到寄存器中，处理完毕后，再把寄存器的数据存放到内存中。
寄存器组拥有16个寄存器，R0R12是通用寄存器，R13R15是特殊寄存器。
寄存器作用commentR0~R7通用寄存器-Low register16 bits 指令R8~12通用寄存器-Hig Register16 bits 指令 + 32 bits 指令R13Stack Pointer-SPMSP：（Main stack pointer) 复位默认的SP指针，PSP：(Process stack pointer):进入线程后的指针R14Link Register-LC函数调用时，会首先将LC的值存入堆栈中，用于保存返回地址，当调用函数完毕后，将LC的值赋给PC。R15Program conutner当前执行指令的地址 Thumb2 指令集：可以16bits指令与32位指令的混合使用。
ARM汇编指令语法格式： label mnemonic operand1, operand2, ....;comments label 标签用以表示一个参考地址。 Label放在指令前，Label用以表达指令的地址。 Label也可以用以表达数据的地址。 mnemonic 助记符，助记符是指令的名字，。 operand 操作数有，操作可以是立即数，也可以是寄存器，操作数的个数视具体汇编指令。 ;comment 注释 eg： MOVS R0, #0x12 ; Set R0 = 0x12 (hexadecimal) MOVS R1, #’A’ ; Set R1 = ASCII character A 后缀 ARM处理器汇编器中，一些指令支持带后缀，常用的后缀如下：
后缀简写备注S需要更新APSR标志EQEqualNENot EqualLTLesser ThanGTGreat Than.N使用16位指令集.W使用32位指令集 汇编指令集： 1 Moving data within the processor 数据拷贝
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5692958c116b6cb6faea0853dafa34ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e713ec7f129072d8a0106510655a3e9/" rel="bookmark">
			BFS（宽度优先算法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.BFS简介 宽度优先搜索算法（又称广度优先搜索）是最简便的图的搜索算法之一，这一算法也是很多重要的图的算法的原型。其别名又叫BFS，属于一种盲目搜寻法，目的是系统地展开并检查图中的所有节点，以找寻结果。换句话说，它并不考虑结果的可能位置，彻底地搜索整张图，直到找到结果为止。简单来说，bfs好像是一个耳听六路眼观八方的人，搜索时是一层一层的搜索的。BFS利用的数据结构是queue，空间复杂度为o(2^n)，另外BFS可以用来解决最短路问题。BFS是一个从近到远的扩散过程。
2.基本思想 从初始状态S开始，利用规则，生成所有可能的状态。构成树的下一层节点，检查是否出现目标状态G，若未出现，就对该层所有状态节点，分别顺序利用规则。生成再下一层的所有状态节点，对这一层的所有状态节点检查是否出现G，若未出现，继续按上面思想生成再下一层的所有状态节点，这样一层一层往下展开。直到出现目标状态为止。
3.算法步骤 （1）把起始节点S线放到queue 表中克祥
(2)如果queue是空表，则失败退出，否则继续。
(3)在queue表中取最前面的节点node 移到 CL OSED 表中。（出队）
(4)扩展node节点。若没有后继即叶节点），则转向（2）循环。
(5)把node的所有后继节点放在queue表的末端。各后继结点指针指向node节点。(入队)
(6)若后继节点中某一个是目标节点，则找到一个解，成功退出。否则转向(2)循环。
4.例题 BFS和DFS一样搜索框架比较多，所以我们也是来看两个经典例题
4.1AcWing 844 走迷宫
给定一个 n×m 的二维整数数组，用来表示一个迷宫，数组中只包含 0 或 1，其中 0 表示可以走的路，1 表示不可通过的墙壁。最初，有一个人位于左上角 (1,1) 处，已知该人每次可以向上、下、左、右任意一个方向移动一个位置。请问，该人从左上角移动至右下角 (n,m) 处，至少需要移动多少次。数据保证 (1,1) 处和 (n,m) 处的数字为 0，且一定至少存在一条通路。
输入格式
第一行包含两个整数 n和 m。
接下来 n 行，每行包含 m 个整数（0 或 1），表示完整的二维数组迷宫。
输出格式
输出一个整数，表示从左上角移动至右下角的最少移动次数。
数据范围
1≤n,m≤100
输入样例：
5 5 0 1 0 0 0 0 1 0 1 0 0 0 0 0 0 0 1 1 1 0 0 0 0 1 0 输出样例：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e713ec7f129072d8a0106510655a3e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b25f6838d22bf970b0ca20e4daa4de4/" rel="bookmark">
			Pygame简易版2048小游戏：超详细解说，看完还不会可以剁手了（附完整源码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		导语 哈喽！大家好，我是栗子，感谢大家的支持！
新的一天，新气象，程序猿们的日常开始敲敲敲，改改改——今天给大家来一款简单的小游戏！
2048小游戏——准确的来说确实是一个简单版本的！
呐呐呐 ，主要是担心很多小伙伴儿直接上界面版本的看不懂，所以做了这款简单的2048，先看这
篇简单版本的吧！
正文 为了搞懂这个游戏的规则，小编去直接下载了一款2048的小游戏，上手玩了一波！
然后.........完全停不下来！23333~
玩法： 用手指或键盘上下左右滑动，将两个相同的数字合并，例如：2 + 2 = 4， 4 + 4 = 8... 直到 1024 + 1024 = 2048！
正式开始： # 练习1：定义函数，将列表中0元素，移动到末尾。 # [2,0,2,0] --&gt; [2,2,0,0] # [0,4,2,4] --&gt; [4,2,4,0] # 适合零基础同学 def zero_to_end(list_target): # 选出非零元素 形成新列表 # [2, 0, 2, 0] --&gt; [2, 2] new_list = [] for item in list_target: if item != 0: new_list.append(item) # 追加零元素 [2, 2] --&gt; [2,2,0,0] # 判断原列表零元素数量： list_target.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b25f6838d22bf970b0ca20e4daa4de4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7235724b6ad461bb303e33744ca3f208/" rel="bookmark">
			make_classification函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		make_classification函数 sklearn.datasets.make_classification(n_samples=100, n_features=20, *, n_informative=2, n_redundant=2, n_repeated=0, n_classes=2, n_clusters_per_class=2, weights=None, flip_y=0.01, class_sep=1.0, hypercube=True, shift=0.0, scale=1.0, shuffle=True, random_state=None)
参数类型默认值含义n_samplesint100样本数量n_featuresint20特征总数。这些包括n_informative 信息特征、n_redundant冗余特征、 n_repeated重复特征和 n_features-n_informative-n_redundant-n_repeated随机抽取的无用特征。n_informativeint2信息特征的数量。n_redundantint2冗余特征的数量。这些特征是作为信息特征的随机线性组合生成的。(假设n_informative=F1,F2,…那么n_redundant= aF1+bF2+… a,b,c就是随机数)n_repeatedint0从信息特征和冗余特征中随机抽取的重复特征的数量。n_classesint2分类问题的类（或标签）数。n_clusters_per_classint2每个类的集群数。random_stateintNone类似随机种子，复现随机数 返回值输出值含义Xndarray(n_samples, n_features)生成的n+samples个样本yndarray(n_samples)每个样本的类别成员的整数标签。 生成一个随机的 n n n 类分类问题。
在不打乱的情况下，X按以下顺序水平堆叠特征：主要n_informative特征，然后n_redundant 是信息特征的线性组合，然后是n_repeated 重复，随机抽取信息和冗余特征的替换。其余特征充满随机噪声。因此，无需改组，所有有用的特征都包含在列中 。X[:, :n_informative + n_redundant + n_repeated]
from sklearn.datasets import make_classification X, y = make_classification(n_samples=6, n_classes=2, n_features=5, n_informative=5,n_redundant=0,n_clusters_per_class=1) display(X,y) """ n_samples=6 - 6行6个数据 n_classes=2 - 结果分为2类即二分类 n_features=5 - 5个特征 n_informative=5 - 5个全部有效的特征 n_redundant=0 - 冗余特征为0 n_clusters_per_class=1 - 每一个类别聚为一个簇 array([[ 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7235724b6ad461bb303e33744ca3f208/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/425f93d01c7ffd6183e86ac6a6909b4c/" rel="bookmark">
			ntp错误: no server suitable for synchronization found
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题 假如我们配置了ntp服务以后，始终无法同步，执行命令 ntpdate -u serverip
直接报错：no server suitable for synchronization found
解决 结论：一般都是ntp server有问题，不然就是client和server网络不通。
这里假设ntpserver 的ip是X1
依次按以下步骤来排查
1. 使用命令 ntpdate -d X1
返回信息中关注2个错误：
错误1：X1: Server dropped: strata too high
这个错误下，并且显示“stratum 16”。而正常情况下stratum这个值得范围是“0~15”。这是因为NTP server还没有和其自身或者它的上一层server同步上。所以这里就要去检查ntpserver是否是配置正确的，比如server是和自身同步，还是再和上一层服务器同步，查看是否配置正确，如果配置的是还和上一层服务器同步则查看上一层是否正常。（当然在ntp server上重新启动ntp服务后，ntp server自身或者与其server的同步的需要一个时间段，这个过程可能是5分钟，但是一般用不了这么久，在这个时间之内在客户端运行ntpdate命令时会产生no server suitable for synchronization found的错误。）查看ntpserver是否完成了和自身同步，可以使用命令 ntpq -p，
同步则最前面会显示 * 号，不然则没有。
错误2：X1: Server dropped: no data
出现该错误则，先查看和ntp服务端是否能联通（ping x1），能联通则再看是否是开启了防火墙禁止了123端口的访问，再不是就去看ntpserver机器上ntp服务是否正常（service ntpd status; ntpq -p）。
如果以上都不是那再看是否是ntp的版本问题。比如ntp4.2（包括4.2）之后的版本，在restrict的定义中使用了notrust的话，会导致以上错误。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ccba7185a284f799133bc423d0289ec5/" rel="bookmark">
			OneHotEncoder函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OneHotEncoder函数 一、函数功能与参数二、函数使用参考修改时间 仅介绍常用功能，详情请看结尾参考链接。
一、函数功能与参数 将分类特征编码为one-hot数字数组。
这个转换器的输入应该是一个类似数组的整数或字符串，表示分类（离散）特征所采用的值。使用 one-hot（又名“one-of-K”或“dummy”）编码方案对特征进行编码。这将为每个类别创建一个二进制列并返回一个稀疏矩阵或密集数组（取决于sparse 参数）。
默认情况下，编码器根据每个特征中的唯一值派生类别。或者，您也可以categories 手动指定。
注意：y 标签的 one-hot 编码应该使用 LabelBinarizer。
使用说明：
from sklearn.preprocessing import OneHotEncoder OneHotEncoder(categories='auto', sparse='True', dtype='float')
函数参数参数说明categories默认’auto’，根据根据训练数据自动确认类别；默认数组的列表，categories[i]保存第 i 列中预期的类别。传递的类别不应在单个特征中混合字符串和数值，并且应在数值的情况下进行排序。使用的类别可以在categories_属性中找到。sparse默认为True，如果设置为 True 将返回稀疏矩阵，否则将返回一个数组。dtype默认为float，所需的输出数据类型。 函数属性属性说明categories_属性名称和类型 函数方法方法说明get_feature_names()查看拟合后的特征名称fit(X)使X拟合OneHotEncoderfit_transform(X)使X拟合OneHotEncoder，并且转换X 二、函数使用 生成OneHotEncoder类模型。
import pandas as pd data = {'degree':['master','master','PHD'],'grade':['A', 'B', 'C']} df = pd.DataFrame(data) from sklearn.preprocessing import OneHotEncoder # 拟合模型 enc = OneHotEncoder() enc.fit(df) # 展示原始每个特征的不同种类 enc.categories_ # [array(['PHD', 'master'], dtype=object), array(['A', 'B', 'C'], dtype=object)] # 不同特征的不同属性值列举出来 enc.get_feature_names() """ array(['x0_PHD', 'x0_master', 'x1_A', 'x1_B', 'x1_C'], dtype=object) "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ccba7185a284f799133bc423d0289ec5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b6c3ad616a7a1b6eb48cde11a394215/" rel="bookmark">
			【SpringBoot】SpringBoot——整合持久层技术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 5. 整合持久层技术5.1 整合JdbcTemplate5.2 整合MyBatis5.3 Spring Data JPA5.3.1 JPA、Spring Data、Spring Data JPA的故事5.3.2 整合Spring Data JPA5.3.3 CORS跨域配置 5. 整合持久层技术 持久层的实现是和数据库紧密相连的，在JAva领域内，访问数据库的通常做法是使用JDBC，JDBC使用灵活而且访问速度较快，但JDBC不仅需要操作对象，还需要操作关系，并不是完全面向对象编程。目前主流的持久层框架包括：MyBatis、JPA等。这些框架都对JDBC进行了封装，使得业务逻辑开发人员不再面对关系型操作，简化了持久型开发。
5.1 整合JdbcTemplate Spring JDBC抽象框架core包提供了JDBC模板类，其中JdbcTemplate是core包的核心类，所以其他模板类都是基于它封装完成的。JDBC模板类是第一种工作模式。
JdbcTemplate类通过模板设计模式帮助我们消除了冗长的代码，只做需要做的事情(即可变部分)，并且帮我们做了固定部分，如连接的创建及关闭等。
SpringBoot自动配置了JdbcTemplate数据模板。
配置文件
在application.yml中添加如下配置：
spring: datasource: url: jdbc:mysql://localhost:3306/test?serverTimezone=GMT%2B8 username: root password: admin123 driver-class-name: com.mysql.jdbc.Driver JDBC默认采用org.apache.tomcat.jdbc.pool.DataSource数据源，数据源的相关配置参考都封装在org.springframework.boot.autoconfigure.jdbc.DataSourceConfiguration类中。默认使用Tomcat连接池，可以使用spring.datasource.type指定自定义数据源类型。
SpringBoot默认支持的数据源：
org.apache.tomcat.jdbc.pool.DataSourceHikariDataSourceBasicDataSource 整合Druid数据源
导入Druid依赖：
&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;/dependency&gt; 修改application.yml配置文件：
spring: datasource: url: jdbc:mysql://localhost:3306/test?serverTimezone=GMT%2B8 username: root password: admin123 driver-class-name: com.mysql.jdbc.Driver type: com.alibaba.druid.pool.DruidDataSource tomcat: initial-size: 5 min-idle: 5 max-active: 20 max-wait: 60000 time-between-eviction-runs-millis: 60000 min-evictable-idle-time-millis: 300000 validation-query: SELECT 1 FROM DUAL test-on-borrow: false test-while-idle: true test-on-return: false dbcp2: pool-prepared-statements: true filter: stat: enabled:true log-show-sql:true wall: enabled:true 配置type:com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b6c3ad616a7a1b6eb48cde11a394215/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5d1b89aa395fa2f71c449bb5a405d6b/" rel="bookmark">
			Git代码统计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
Git命令代码统计
gitstats工具统计Git仓库代码
1.使用Windows的子工具wsl操作
2.使用虚拟机的方式进行操作
Git命令代码统计 从仓库中克隆代码到指定的位置，进入到对应项目代码的路径后，使用git进行如下的操作：
1.查看git上的个人代码量（username为gitlab的账户名）：
$ git log --author="username" --pretty=tformat: --numstat | awk '{ add += $1; subs += $2; loc += $1 - $2 } END { printf "added lines: %s, removed lines: %s, total lines: %s\n", add, subs, loc }' - 2.统计每个人的增删行数：
$ git log --format='%aN' | sort -u | while read name; do echo -en "$name\t"; git log --author="$name" --pretty=tformat: --numstat | awk '{ add += $1; subs += $2; loc += $1 - $2 } END { printf "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e5d1b89aa395fa2f71c449bb5a405d6b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/457064ad081d86d0c5ee584849b0ea87/" rel="bookmark">
			【Java】——MyBatis 中mapper.xml的语法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 MyBatis是"半自动"的ORM框架，即SQL语句需要开发者自定义，MyBatis的关注点在POJO与SQL之间的映射关系。那么SQL语句在哪里配置自定义呢？就在Mapper.xml中配置。当然了该配置文件可以自定义文件名。文件的样式如下：
&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" &gt; &lt;mapper namespace="com.scau.demo.mapper.UserMapper"&gt; ## ...具体内容... &lt;/mapper&gt; 其中，namespace用于绑定Mapper接口。不同mapper接口对应到不同的xml。
二、mapper.xml mapper：指定唯一的namespace，一般设置成mapper类的全路径名。 insert：对应SQL中的insert插入语句。
id：为该语句的属性，通常与mapper java 文件的方法名相同。
parameterType：参入插入语句的参数类型。
useGeneratedKeys：主键使用数据库自增策略，需要数据库底层支持，并返回主键到keyProperty指定的属性名。
keyProperty：指示主键映射到实体类的属性名。
&lt;mapper namespace="org.mybatis.mapper.UserMapper"&gt; &lt;!-- useGeneratedKeys:返回主键 keyProperty:返回的主键对应实体类的属性字段 --&gt; &lt;insert id="saveUser" parameterType="com.mybatis.domain.User" useGeneratedKeys="true" keyProperty="id"&gt; insert into user values(#{id},#{username},#{birthday},#{sex},#{address}) &lt;/insert&gt; &lt;/mapper&gt; 三、sql代码段 这个元素可以被用来定义可重用的 SQL 代码段，可以包含在其他语句中。它可以被静态地(在加载参数) 参数化. 不同的属性值通过包含的实例变化。
&lt;sql id="userColumns"&gt; ${alias}.id,${alias}.username,${alias}.password &lt;/sql&gt; &lt;select id="selectUsers" resultType="map"&gt; select &lt;include refid="userColumns"&gt;&lt;property name="alias" value="t1"/&gt;&lt;/include&gt;, &lt;include refid="userColumns"&gt;&lt;property name="alias" value="t2"/&gt;&lt;/include&gt; from some_table t1 cross join some_table t2 &lt;/select&gt; 四、parameterType 如果传递的是简单的参数，是简单的数据类型，参数类型可以省略，原生的类型或简单数据类型（比如整型和字符串）因为没有相关属性，它会完全用参数值来替代。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/457064ad081d86d0c5ee584849b0ea87/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/796efd51afa0dfcd0b206fe7ccfba7dd/" rel="bookmark">
			opencv学习笔记(三)——掩膜操作(C&#43;&#43;)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1 . 定义2. 自定义的滤波器实现3 . filter2D API实现4 . 关于RGB三通道的说明 1 . 定义 掩膜操作是指根据掩膜矩阵（也称作核kernel）重新计算图像中每个像素的值。掩膜矩阵中的值表示了邻近像素值（包括该像素自身的值）对新像素值有多大的影响。从数学的观点来看，我们用自己设置的权值，对像素领域内的值做了个加权平均。
比如，下面这个公式表示用5倍当前像素的值减去该像素上、下、左、右四个像素值和，得到的结果赋值给当前像素。使用该公式可以用于提升图像的对比度。调节I(i,j)的系数权重可以得到不同的对比度提升效果。
I(i,j)=5∗I(i,j)−[I(i−1,j)+I(i+1,j)+I(i,j−1)+I(i,j+1)] 上面的公式可以用掩膜矩阵表示成如下的形式。
2. 自定义的滤波器实现 #include &lt;opencv2/imgcodecs.hpp&gt; #include &lt;opencv2/highgui.hpp&gt; #include &lt;opencv2/imgproc.hpp&gt; #include &lt;opencv2/highgui/highgui_c.h&gt; #include &lt;iostream&gt; using namespace std; using namespace cv; int main() { Mat img, dst; img = imread("D:/VS项目/opencv3/1.jpg", IMREAD_UNCHANGED); //如果没有读取到图像信息，直接退出 if (!img.data) return -1; dst = Mat::zeros(img.size(), img.type()); //自己定义的全零图像 int rows = img.rows; int cols = (img.cols - 1) * img.channels(); //因为原图是个RGB图像，所以需要乘以通道数，因为每个列都是三个值 int offsetx = img.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/796efd51afa0dfcd0b206fe7ccfba7dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22c92ebb37e82bba7967a0102ad2d317/" rel="bookmark">
			【算法题】位运算的使用总结 且或非异或左移右移
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		位运算的奇巧淫技 表 1 位逻辑运算符 运算符 含义 实例 结果 &amp; 按位进行与运算（AND） 4 &amp; 5 4 | 按位进行或运算（OR） 4 | 5 5 ^ 按位进行异或运算（XOR） 4 ^ 5 1 ~ 按位进行取反运算（NOT） ~ 4 -5 表 2 位移运算符 运算符 含义 实例 结果 » 右移位运算符 8»1 4 « 左移位运算符 9«2 36 位运算的四大功能
判断奇偶数
x&amp;1 = 1 奇数
x&amp;0 = 0 偶数
获取二进制位是1还是0
num&gt;&gt;(i-1)&amp;1
交换两个整数变量的值
一个数与自身进行异或为0，一个数与0异或得到自身
a=a^b;
b=a^b;
a=a^b;
不用判断语句，求整数的绝对值
int i = n &gt;&gt; 31; //int 为32位，右移31位得到符号位，赋值给i，若为正，则i=0；负，i=-1
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/22c92ebb37e82bba7967a0102ad2d317/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93a5e0c6b2a5fe29c405c86811e51e28/" rel="bookmark">
			Python之sort函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 描述：sort() 函数用于对原列表进行排序，如果指定参数，则使用比较函数指定的比较函数。
语法：
list.sort( key=None, reverse=False)
key -- 主要是用来进行比较的元素，只有一个参数，具体的函数的参数就是取自于可迭代对象中，指定可迭代对象中的一个元素来进行排序。reverse -- 排序规则，reverse = True 降序， reverse = False 升序（默认）。 （无返回值，只会对列表进行排序）
实例：
#!/usr/bin/python # -*- coding: UTF-8 -*- # 列表 vowels = ['e', 'a', 'u', 'o', 'i'] # 降序 vowels.sort(reverse=True) # 输出结果 print ( '降序输出:', vowels ) 输出：
降序输出: ['u', 'o', 'i', 'e', 'a'] 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77aa4c2d26d97efa05d7382f97d6d40e/" rel="bookmark">
			WPF编程，Live Charts使用说明（10）——自定义工具提示和图例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		默认情况下，每个需要工具提示或图例的图表都将初始化DefaultLegend 或 DefaultTooltip的新实例 。
自定义默认值 可以自定义这些类，例如背景色，项目符号大小或方向: &lt;lvc:CartesianChart Series="{Binding SeriesCollection}"&gt; &lt;lvc:CartesianChart.ChartLegend&gt; &lt;lvc:DefaultLegend BulletSize="20" Background="Red"/&gt; &lt;/lvc:CartesianChart.ChartLegend&gt; &lt;lvc:CartesianChart.DataTooltip&gt; &lt;lvc:DefaultTooltip BulletSize="20" Background="Gray"/&gt; &lt;/lvc:CartesianChart.DataTooltip&gt; &lt;/lvc:CartesianChart&gt; 还可以设置工具提示的选择模式，例如，使用下一个代码，我们强制工具提示仅显示悬停的点。 &lt;lvc:CartesianChart Series="{Binding SeriesCollection}"&gt; &lt;lvc:CartesianChart.DataTooltip&gt; &lt;lvc:DefaultTooltip SelectionMode="OnlySender" /&gt; &lt;/lvc:CartesianChart.DataTooltip&gt; &lt;/lvc:CartesianChart&gt; 事例 &lt;lvc:CartesianChart&gt; &lt;lvc:CartesianChart.Resources&gt; &lt;Style TargetType="lvc:DefaultTooltip"&gt; &lt;Setter Property="Background" Value="DarkOrange"&gt;&lt;/Setter&gt; &lt;Setter Property="Foreground" Value="White"&gt;&lt;/Setter&gt; &lt;Setter Property="ShowTitle" Value="False"&gt;&lt;/Setter&gt;&lt;!--new property--&gt; &lt;Setter Property="ShowSeries" Value="False"&gt;&lt;/Setter&gt;&lt;!--new property--&gt; &lt;Setter Property="FontSize" Value="16"&gt;&lt;/Setter&gt; &lt;Setter Property="FontWeight" Value="Bold"&gt;&lt;/Setter&gt; &lt;Setter Property="CornerRadius" Value="20"&gt;&lt;/Setter&gt; &lt;Setter Property="Width" Value="40"&gt;&lt;/Setter&gt; &lt;Setter Property="Height" Value="40"&gt;&lt;/Setter&gt; &lt;Setter Property="BorderThickness" Value="0"&gt;&lt;/Setter&gt; &lt;/Style&gt; &lt;/lvc:CartesianChart.Resources&gt; &lt;lvc:CartesianChart.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/77aa4c2d26d97efa05d7382f97d6d40e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4635527c0c841973db946313c2c55b0/" rel="bookmark">
			SNMP弱口令导致的网络入侵
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录​​​​​​​
1、SNMP简介
2、SNMP架构组成
3、工作原理
4、通信方式
5、检测攻击
1）Snmpwalk:
2）MSF用于SNMP扫描：
1、SNMP简介 SNMP --Simple Network Management Protocol 简单网络管理协议。
SNMP是基于TCP/IP协议族的网络管理标准，是一种在IP网络中管理网络节点（如服务器、工作站、路由器、交换机等）的标准协议，它通过UDP协议来操作，端口号是161/162。
协议版本：
SNMP V1: SNMP协议最初版本(1998年)。 SNMP V2: SNMP协议第二个版本，对比第一版，再性能、安全、机密性和管理者之间通信等方面进行了大量改进。 SNMP V3: SNMP协议目前最新的版本(2004年)，提升协议的安全性，增加了认证和密文传输功能。 2、SNMP架构组成 社区：同一个管理框架下的网络管理站和所有的节点的集合。
网络管理站：一个管理控制台，也称为网络管理系统(NMS)。
节点：网络上的设备(被管理的设备)。
3、工作原理 管理员通过NMS获取网关监控数据的工作流程，涉及的一些SNMP协议关键信息:
MIB(管理信息库): 任何一个被管理设备都表示成一个对象，并称为被管理对象。而MIB就是被管理对象的集合。定义了被管理对象的一系列属性，如对象的名称、对象的访问权限和对象的数据类型等。
SNMP代理: 是一种嵌入再设备中的网络管理软件模块，主要来控制本地机器的管理信息，负责将管理信息转换成SNMP兼容的格式，传递给NMS。
工作流程步骤:
1）管理员查询被管理设备中的对象相关值时，通过网络管理站NMS中的MIB找到相关对象
2）网络管理站NMS向SNMP代理申请MIB中定义对象的相关值
3）SNMP代理在自己的MIB库中进行查找
4）SNMP代理将找到的对象相关值返回给网络管理站NMS
4、通信方式 SNMP采用客户机/服务器模式进行通信。
客户端 —— 网络管理站NMS
服务器 —— SNMP代理
代理在UDP的161端口接收NMS的读写请求消息。
管理站在UDP的162端口接收代理的事件通告消息。
网络管理站NMS向SNMP代理发出请求，询问一个MIB定义的信息的参数值。SNMP代理收到请求后，返回关于MIB定义信息的各种查询。
5、检测攻击 1）Snmpwalk: snmpwalk是SNMP的一个工具，它使用SNMP的GETNEXT请求查询指定OID（SNMP协议中的对象标识）入口的所有OID树信息，并显示给用户。
参数说明：
–h：显示帮助。 –v：指定snmp的版本, 1或者2c或者3。 –c：指定连接设备SNMP密码。 –V：显示当前snmpwalk命令行版本。 –r：指定重试次数，默认为0次。 –t：指定每次请求的等待超时时间，单为秒，默认为3秒。 –l：指定安全级别：noAuthNoPriv|authNoPriv|authPriv。 –a：验证协议：MD5|SHA。只有-l指定为authNoPriv或authPriv时才需要。 –A：验证字符串。只有-l指定为authNoPriv或authPriv时才需要。 –x：加密协议：DES。只有-l指定为authPriv时才需要。 –X：加密字符串。只有-l指定为authPriv时才需要。 使用举例：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e4635527c0c841973db946313c2c55b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72e21f2cc8d5c0b527f9e1628b8920ea/" rel="bookmark">
			springbatch的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、相关注解 使用springbatch需要设置一些注解，方便使用
@EnableBatchProcessing :自动补全一些相关属性
EnableBatchProcessing provides a base configuration for building batch jobs. Within this base configuration, an instance of StepScope is created in addition to a number of beans made available to be autowiredobRepository:
bean name “jobRepository”
JobLauncher: bean name “jobLauncher”
JobRegistry: bean name “jobRegistry”
PlatformTransactionManager: bean name “transactionManager”
JobBuilderFactory: bean name “jobBuilders”
StepBuilderFactory: bean name “stepBuilders”
Configuring and Running a Job
@ JobScope:在任务实例化的时候创建Bean,开启延迟Bean实例功能
Because it is not part of the Spring container by default, the scope must be added explicitly, by using the batch namespace, by including a bean definition explicitly for the JobScope, or using the @EnableBatchProcessing annotation。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/72e21f2cc8d5c0b527f9e1628b8920ea/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/301/">«</a>
	<span class="pagination__item pagination__item--current">302/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/303/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>