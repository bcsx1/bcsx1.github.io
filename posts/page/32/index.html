<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/664776ffedf6123b9008e4b05f1af0c8/" rel="bookmark">
			MATLAB - 读取双摆杆上的 IMU 数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章目录 前言 本示例展示了如何从安装在双摆杆上的两个 IMU 传感器生成惯性测量单元 (IMU) 读数。双摆使用 Simscape Multibody™ 进行建模。有关使用 Simscape Multibody™ 构建简易摆的分步示例，请参阅简易摆建模（Simscape Multibody）。
open_system("doublePendulumIMU.slx"); 一、模型 Simscape Multibody™ 中的惯性参考框架（或世界框架）默认为右手笛卡尔坐标框架。旋进式关节仅可围绕主体参考框架的 Z 轴进行旋转。起初，惯性框架和车身参考框架是对齐的。刚性变换块将身体参照系的 X 轴旋转-90 度，这样变换后的 Y 轴就指向重力矢量的方向，而链接可以沿变换后的 Z 轴自由旋转。
将两个链接的末端帧作为模拟 IMU 的传感器帧。每个 IMU 都定义在一个 IMU 子系统中。
二、IMU 子系统 打开第一个 IMU 子系统。
您可以选择 IMU 输入的参考框架为 NED（北-东-下）或 ENU（东-北-上）框架。在本模拟中，您选择的是 ENU 框架，该框架与右手坐标框架对齐。第一个传感器变换块测量传感器框架和惯性框架之间的相对空间关系。重力加速度值将从总加速度中减去，因为 IMU 模块默认将重力加速度纳入惯性框架。IMU 模块将此信息转化为加速度计、陀螺仪和磁力计传感器数据。
第二个变换传感器模块提供 IMU 的预期地面实况测量数据。它测量惯性帧与传感器帧之间的相对空间关系，传感器帧的测量方法与 IMU 类似。加速度被否定，以补偿 IMU 模型中对加速度的否定。在 IMU 模型中这样做是为了在加速度计处于自由落体状态时获得零总加速度读数。有关 IMU 建模的更多详情，请参阅 imuSensor。
三、模拟和可视化 IMU 数据 由于双摆的主要旋转沿传感器框架的 Z 轴进行，因此 IMU 测量的主要加速度沿 X 轴和 Y 轴进行，主要旋转沿 Z 轴进行。下图显示了来自第二个 IMU 的模拟 IMU 数据，并将这些数据与地面实况进行了比较。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/664776ffedf6123b9008e4b05f1af0c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d55a1f37cd79239b0ce62284c9a38cce/" rel="bookmark">
			.net core 生成jwt&#43;swagger-通过 IHttpContextAccessor读取token信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.安装jwt相关包
&lt;ItemGroup&gt; &lt;PackageReference Include="Microsoft.AspNetCore.Authentication.JwtBearer" Version="6.0.25" /&gt; &lt;PackageReference Include="Microsoft.IdentityModel.Tokens" Version="7.0.3" /&gt; &lt;PackageReference Include="Swashbuckle.AspNetCore" Version="6.2.3" /&gt; &lt;PackageReference Include="System.IdentityModel.Tokens.Jwt" Version="7.0.3" /&gt; &lt;/ItemGroup&gt; 2.appsetting.json配置jwt的验证信息
"JwtSetting": { "Issuer": "pzx", //颁发者 "Audience": "everyone", //受众 "SecurityKey": "appapap122344kkappapap122344kkappapap122344kkappapap122344kkappapap122344kkappapap122344kkappapap122344kkappapap122344kk", //密钥 //token //和我配置一样可以拿我生成的token测试 "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwOi8vc2NoZW1hcy54bWxzb2FwLm9yZy93cy8yMDA1LzA1L2lkZW50aXR5L2NsYWltcy9uYW1lIjoiSm9obiBEb2UiLCJodHRwOi8vc2NoZW1hcy54bWxzb2FwLm9yZy93cy8yMDA1LzA1L2lkZW50aXR5L2NsYWltcy9lbWFpbGFkZHJlc3MiOiJqb2huZG9lQGV4YW1wbGUuY29tIiwiaHR0cDovL3NjaGVtYXMubWljcm9zb2Z0LmNvbS93cy8yMDA4LzA2L2lkZW50aXR5L2NsYWltcy9yb2xlIjoiQWRtaW4iLCJleHAiOjE3MDMyNzMwODYsImlzcyI6InB6eCIsImF1ZCI6ImV2ZXJ5b25lIn0.ePY0ZkDQGF1GJWKqiCQjUn2y7aSNG1WesfBH5xPy1Fg" } 3.校验token的合法性（在progam文件）
#region JWT 认证 builder.Services .AddAuthentication(JwtBearerDefaults.AuthenticationScheme) //.AddCustomAuth(o =&gt; { }) .AddJwtBearer(options =&gt; { options.TokenValidationParameters = new TokenValidationParameters { ValidIssuer = builder.Configuration["JwtSetting:Issuer"], ValidAudience = builder.Configuration["JwtSetting:Audience"], IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(builder.Configuration["JwtSetting:SecurityKey"])) // 默认允许 300s 的时间偏移量，设置为0 //ClockSkew = TimeSpan.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d55a1f37cd79239b0ce62284c9a38cce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51dc242e62d694af3f17c946cd2c66d1/" rel="bookmark">
			.net core webapi 大文件上传到wwwroot文件夹
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.配置staticfiles(program文件中)
app.UseStaticFiles(); 2.在wwwroot下创建upload文件夹
3.返回结果封装
namespace webapi; /// &lt;summary&gt; /// 统一数据响应格式 /// &lt;/summary&gt; public class Results&lt;T&gt; { /// &lt;summary&gt; /// 自定义的响应码，可以和http响应码一致，也可以不一致 /// &lt;/summary&gt; public int Code { get; set; } /// &lt;summary&gt; /// 中文消息提示 /// &lt;/summary&gt; public string? Msg { get; set; } /// &lt;summary&gt; /// 是否成功 /// &lt;/summary&gt; public bool Success { get; set; } /// &lt;summary&gt; /// 响应的数据 /// &lt;/summary&gt; public T? Data { get; set; } /// &lt;summary&gt; /// 返回的Token: 如果有值，则前端需要此这个值替旧的token值 /// &lt;/summary&gt; public string?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/51dc242e62d694af3f17c946cd2c66d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31c68f39040b7819b6184cfa24fdd4e2/" rel="bookmark">
			Java之LinkedList核心源码解读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LinkedList核心源码解读 LinkedList 是一个基于双向链表实现的集合类，经常被拿来和 ArrayList 做比较
LinkedList 插入和删除元素的时间复杂度？ 头部插入/删除：只需要修改头结点的指针即可完成插入/删除操作，因此时间复杂度为 O(1)。尾部插入/删除：只需要修改尾结点的指针即可完成插入/删除操作，因此时间复杂度为 O(1)。指定位置插入/删除：需要先移动到指定位置，再修改指定节点的指针完成插入/删除，因此需要移动平均 n/2 个元素，时间复杂度为 O(n)。 LinkedList 为什么不能实现 RandomAccess 接口？ RandomAccess 是一个标记接口，用来表明实现该接口的类支持随机访问（即可以通过索引快速访问元素）。由于 LinkedList 底层数据结构是链表，内存地址不连续，只能通过指针来定位，不支持随机快速访问，所以不能实现 RandomAccess 接口。
LinkedList 源码分析 这里以 JDK1.8 为例，分析一下 LinkedList 的底层核心源码。
LinkedList 的类定义如下：
public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable { //... } LinkedList 继承了 AbstractSequentialList ，而 AbstractSequentialList 又继承于 AbstractList 。
阅读过 ArrayList 的源码我们就知道，ArrayList 同样继承了 AbstractList ， 所以 LinkedList 会有大部分方法和 ArrayList 相似。
LinkedList 实现了以下接口：
List : 表明它是一个列表，支持添加、删除、查找等操作，并且可以通过下标进行访问。Deque ：继承自 Queue 接口，具有双端队列的特性，支持从两端插入和删除元素，方便实现栈和队列等数据结构。需要注意，Deque 的发音为 “deck” [dɛk]，这个大部分人都会读错。Cloneable ：表明它具有拷贝能力，可以进行深拷贝或浅拷贝操作。Serializable : 表明它可以进行序列化操作，也就是可以将对象转换为字节流进行持久化存储或网络传输，非常方便 LinkedList 中的元素是通过 Node 定义的：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/31c68f39040b7819b6184cfa24fdd4e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fdc151b67cda2ac93b37f3c396a864e4/" rel="bookmark">
			【docker笔记】docker常用命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、帮助启动类命令 1.1 启动、重启、查询当前状态、停止 systemctl start docker systemctl stop docker systemctl restart docker systemctl status docker 1.2 设置开机启动 systemctl enable docker 1.3 查看docker概要信息 docker info 1.4 查看docker帮助文档 docker --help docker 具体命令 --help 2、镜像命令 2.1 查看本地镜像（表头：REPOSITORY–仓库源 TAG–镜像标签 IMAGE ID–镜像id CREATED–镜像创建时间 SIZE–镜像大小） 同一个仓库源可以多个TAG版本，代表这个仓库源的不同的版本，使用REPOSITORY：TAG来定义不同的镜像，如果不指定一个镜像的版本标签，docker将默认使用最新的latest镜像
docker images options： -a：列出本地所有镜像（含历史镜像） -q：只显示镜像id 2.2 搜索某个镜像是否在远程仓库（表头：NAME–名字 DESCRIPTION–描述 STARS–点赞数量 OFFICIAL–是否是官方 AUTOMATED–是否能够自动构建） docker search [options] imagesname options: docker search --limit 5 redis 只列出前5个 2.3 下载镜像 docker pull imagesname[:TAG] such: docker pull redis:6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fdc151b67cda2ac93b37f3c396a864e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82979f4e6998f67d22c25288945b8b1a/" rel="bookmark">
			为什么 如果栈不为空就是top ＞= 0
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		class Solution { public String removeDuplicates(String S) { StringBuffer stack = new StringBuffer(); int top = -1; for (int i = 0; i &lt; S.length(); ++i) { char ch = S.charAt(i); if (top &gt;= 0 &amp;&amp; stack.charAt(top) == ch) { stack.deleteCharAt(top); --top; } else { stack.append(ch); ++top; } } return stack.toString(); } } 变量 top 被用来追踪 StringBuffer（在这里充当栈的角色）的栈顶位置。这里的逻辑是：
当 stack（StringBuffer 实例）为空时，意味着没有任何元素被添加进去。在这种情况下，top 的值为 -1。这是因为在空的 StringBuffer 中，没有任何字符的索引可以是 0 或更大的数（在Java中，索引通常是从 0 开始的）。因此，-1 被用作表示“栈空”或“没有元素”的标记。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/82979f4e6998f67d22c25288945b8b1a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f162f01998a9ae6244fc8cc2b6259d4/" rel="bookmark">
			删除字符串中的所有相邻重复项
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 给定一个字符串 s，需要重复地删除其中所有相邻的重复项，直到没有任何相邻字符是重复的。最后返回处理后的字符串。
示例 示例 1:
输入: abbaca输出: ca解释: 先删除 bb（得到 aaca），然后删除 aa（得到 ca）。 示例 2:
输入: abbbabaa输出: ab 或 ba解释: 删除可能有不同的顺序，比如先删除第一个 bb 再删除第二个 bb 得到 abaa，然后再删除 aa 得到 ab。 class Solution { public String removeDuplicates(String S) { StringBuffer stack = new StringBuffer(); int top = -1; for (int i = 0; i &lt; S.length(); ++i) { char ch = S.charAt(i); if (top &gt;= 0 &amp;&amp; stack.charAt(top) == ch) { stack.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f162f01998a9ae6244fc8cc2b6259d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4cdff0a434ccac0c8da18c012deafbf/" rel="bookmark">
			StringBuilder和StringBuffer区别是什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		想象一下，你在写信，但是你需要不断地添加新的内容或者修改一些词句。在编程中，当你需要这样操作字符串时，就可以用StringBuffer或StringBuilder。
StringBuffer StringBuffer就像是一个多人协作写作的工具。如果你和你的朋友们一起写信，每个人都可以随时添加或改变内容，而且不会弄乱彼此的部分。这就是StringBuffer的线程安全性，确保在多人同时操作时，内容不会混乱。
常用方法 append( )：添加内容，就像在信的末尾继续写东西。insert(int offset, String str)：在特定位置插入内容，比如在第三段话之后加点什么。delete(int start, int end)：删除一段内容，就好比用橡皮擦抹掉某些字句。reverse( )：把所有内容倒过来写，比如把“hello”变成“olleh”。 StringBuilder 现在想象一下，你自己在写信，不需要担心别人会来改动你的内容。这时候你可以用StringBuilder，它不考虑多人协作的问题，因此写作更快，但如果有人突然加入，可能会出问题。
常用方法 append( )：和StringBuffer一样，用来添加内容。insert(int offset, String str)：在指定位置插入新内容。delete(int start, int end)：删除特定范围的内容。reverse( )：内容反转。 总的来说，如果你在一个需要考虑多个人同时操作字符串的场景（比如多线程编程），就用StringBuffer。如果你只是自己操作字符串，那么StringBuilder会更快一些。两者的用法很相似，主要差别在于线程安全性和性能。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc3ea039e0604b1d96f0895014ff6759/" rel="bookmark">
			FPFA.一种二倍频电路代码描述以及测量详情
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 1、因为需要倍频电路所以找了个二倍频的电路，通过fpga实际测量发现经过倍频后的电路峰值降低。不过这个也正常，因为该电路只要过触发点就会开始发生波形变化，而电路的触发值不是峰值。​​​​​​​
2、继续对电路做倍频后信号做二倍频，发现已经无法继续倍频，因为峰值电压的降低后触发d触发器的电压已经距离峰值非常接近了，没有足够的高电平保持时间，而倍频后的时钟边沿斜率又大致跟原时钟一样。（如图黄、蓝信号为一次跟二次倍频结果，紫色为原时钟）​​​​​​​
3、所以使用触发器的倍频方法：二倍频后就到头了。暂时还没找到优化电路的方法。
4、电路图​​​​​​​
二、代码描述（模块名为文件名） 1、模块代码
//倍频电路 module f_double( input clk_in, output clk_out ); reg Q_n; assign clk_out = ~(Q_n ^ clk_in); always @(posedge clk_out) begin Q_n = !Q_n; end endmodule 2、顶层测试代码
module da_qian_ju_shi_233( input clk_27Mhz, output clk1, clk2, clk3 ); wire clk_54Mhz; assign clk3 = clk_27Mhz; f_double j1( .clk_in (clk_27Mhz), .clk_out (clk_54Mhz) ); assign clk1 = clk_54Mhz; reg clk_t = 1'b0; always @(posedge clk_54Mhz) begin clk_t &lt;= !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc3ea039e0604b1d96f0895014ff6759/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff1ff2bf1f17edb9c9708776ee09c22b/" rel="bookmark">
			Java 中的 Stream API 常用总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java 8 引入了 Stream API，它提供了一种新的抽象，使得在集合数据上进行函数式编程变得更加简单、高效和可维护。下面我们将探讨 Stream API 的几个常用方法和功能：
创建流
创建流操作 ● 从集合创建： 使用 stream() 方法从集合（如 List、Set、Map）创建 Stream。 List&lt;String&gt; myList = Arrays.asList("apple", "banana", "orange"); Stream&lt;String&gt; stream = myList.stream(); ● 从数组创建： 使用 Arrays.stream() 方法从数组创建 Stream。 int[] numbers = {1, 2, 3, 4, 5}; IntStream stream = Arrays.stream(numbers); 中间操作 filter() ● 注意事项： ○ 用于筛选流中的元素，需提供一个 Predicate。
○ 操作结果是一个新的 Stream，其中只包含符合条件的元素。
○ 注意 Predicate 条件的复杂性和可读性。
List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4, 5); List&lt;Integer&gt; evenNumbers = numbers.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ff1ff2bf1f17edb9c9708776ee09c22b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96395d3ca428b5585287e023bc620d6f/" rel="bookmark">
			折半枚举(题目)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因为最近连续两次遇到折半枚举都不会做
想写个博客记录一下遇到的折半枚举的题目
帮大家省去一些时间去找一些例题
如果还遇到的话会持续更新，大家也可以发题目连接在评论区，有时间的话可以把遇到的折半枚举的题目都更新上去
2021年中国大学生程序设计竞赛女生专场
Problem - C - Codeforces
题解的话有很多，大家可以自己去搜，我是看这篇懂的
https://www.cnblogs.com/re0acm/p/16750763.html
牛客小白月赛84 登录—专业IT笔试面试备考平台_牛客网
这里就给大家放一个官方题解吧
小白月赛84出题人题解_ACM竞赛_ACM/CSP/ICPC/CCPC/比赛经验/题解/资讯_牛客竞赛OJ_牛客网
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c50887168881c624768f59f76a738ae7/" rel="bookmark">
			RIPV1配置实验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 查看路由器路由表： 删除手工配置的静态路由项： Route1-&gt;Config-&gt;static
Remove删除路由项
删除Route3的路由项，方法同上删除Route2的路由项，方法同上 完成路由器RIP配置： Route1-&gt;Config-&gt;RIP-&gt;Network
Network：输入直连路由项的网络地址，网络地址用分类编制方式输入
Route1:
Network ：
192.1.1.0
192.1.4.0
192.1.5.0
Route2:
Network:
192.1.2.0
192.1.4.0
192.1.6.0
Route3:
Network:
192.1.3.0
192.1.5.0
192.1.6.0
测试PC0与PC2的连通性： 测试PC2与PC1的连通性： 测试PC1与PC0的连通性： 关键命令 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d91a92e0708293cc39892ad653ced63/" rel="bookmark">
			【GIS前言技术】甘肃积石山6.2级地震烈度图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		12月18日23时59分，甘肃临夏州积石山县发生6.2级地震。地震发生后，应急管理部组织中国地震局派出地震现场工作队，依照《地震现场工作：调查规范》（GB/T 18208.3-2011）、《中国地震烈度表》(GB/T 17742-2020)，对灾区668个调查点展开了实地震害调查，并充分参考震区断裂构造、仪器烈度、余震分布、震源机制、遥感等科技支撑成果，确定了此次地震的烈度分布，完成了《甘肃积石山6.2级地震烈度图》编制工作，现正式向社会发布。
甘肃积石山6.2级地震最大烈度为Ⅷ度（8度），等震线长轴呈北北西走向，长轴124公里，短轴85公里，Ⅵ度（6度）区及以上面积8364平方公里，其中甘肃省5232平方公里，青海省3132平方公里。此次地震涉及甘肃省3个市（州）9个县（市、区）88个乡镇（街道）以及太子山天然林保护区、盖新坪林场，涉及青海省2个市（州）4个县（市）30个乡镇。
Ⅷ度（8度）区面积331平方公里，其中包含异常区面积15平方公里，主要涉及甘肃省临夏回族自治州积石山保安族东乡族撒拉族自治县吹麻滩镇、大河家镇、石塬镇、刘集乡、柳沟乡、关家川乡、胡林家乡、寨子沟乡、盖新坪林场，青海省海东市民和回族土族自治县官亭镇、甘沟乡、中川乡、杏儿藏族乡，共计12个乡镇和1个林场。
Ⅶ度（7度）区面积1514平方公里，主要涉及甘肃省临夏回族自治州积石山保安族东乡族撒拉族自治县17个乡镇和盖新坪林场、永靖县3个乡镇、临夏县3个乡，青海省海东市民和回族土族自治县8个乡镇、循化撒拉族自治县3个乡镇、化隆回族自治县1个乡，共计35个乡镇和1个林场。
Ⅵ度（6度）区面积6519平方公里，主要涉及甘肃省临夏回族自治州积石山保安族东乡族撒拉族自治县4个乡镇、永靖县13个乡镇、临夏县25个乡镇、临夏市11个乡镇（街道）、东乡族自治县8个乡镇、和政县4个乡镇，甘南藏族自治州合作市1个乡、夏河县7个乡镇，兰州市红古区2个镇，太子山天然林保护区；青海省海东市民和回族土族自治县13个乡镇、循化撒拉族自治县7个乡镇、化隆回族自治县4个乡镇，黄南藏族自治州同仁市1个乡；共计100个乡镇（街道）和1个自然保护区。
此外，位于Ⅵ度（6度）区之外的部分地区也受到波及，个别房屋出现破坏受损现象。
本图涉及名词解释
Ⅷ度（8度）：多数土木、砖木房屋严重破坏，少数不设防砖混房屋严重破坏，少量框架房屋中等破坏。
Ⅶ度（7度）：多数土木、砖木房屋中等破坏，多数砖混房屋轻微破坏，个别框架房屋轻微破坏，部分斜坡失稳，出现崩塌、滑坡等次生灾害。
Ⅵ度（6度）：少数土木、砖木房屋中等破坏，少数不设防砖混房屋轻微破坏，多数框架房屋基本完好。
本文摘自：应急管理部
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1fdde22961b585ccf0d08b1c0d8f0a33/" rel="bookmark">
			PostGIS学习教程十四：更多的空间连接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PostGIS学习教程十四：更多的空间连接 在上一节中，我们看到了ST_Centroid(geometry)和ST_Union([geometry])函数，以及一些简单的示例。在本节中，我们将用它们做一些更详细的事情。
提示：写完文章后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 PostGIS学习教程十四：更多的空间连接一、创建人口普查区域图表1.1、加载nyc_census_sociodata.sql1.2、创建人口普查区域空间表1.3、将属性数据连接到空间数据1.4、回答一个有趣的问题二、多边形 / 多边形连接2.1、那Flatbush呢？ 三、大的半径距离的连接 一、创建人口普查区域图表 在网盘中准备了nyc_census_sociodata.sql包含属性数据，但不包含几何图形数据。该表包含有关纽约的、有趣的社会经济数据：通勤时间、收入和教育程度。然而有一个问题：数据按"人口普查区域（census tract）"汇总，而我们没有普查区域的几何图形数据！
在本节中，我们将：
1、加载nyc_census_sociodata.sql表
2、创建人口普查区域空间表
3、将属性数据连接到几何图形数据
4、然后利用我们的新数据进行一些分析
1.1、加载nyc_census_sociodata.sql 1、在PgAdmin中打开SQL查询窗口
2、从菜单中选择File-&gt;Open，并浏览到nyc_census_sociodata.sql文件
3、按"Run Query"按钮
4、如果你在PgAdmin中按下"Refresh"按钮，那数据表的列表现在应该包含nyc_census_sociodata表。
1.2、创建人口普查区域空间表 正如我们在上一节中所看到的，我们可用通过对blkid键的子串进行汇总，从人口普查块（census block）中构建更高级别地理区划的几何图形。为了得到人口普查区域（census tract），我们需要对blkid的前11个字符进行汇总分组。
360610001001001 = 36 061 000100 1 001 36 = State of New York 061 = New York County (Manhattan) 000100 = Census Tract 1 = Census Block Group 001 = Census Block 使用ST-Union创建新表：
-- Make the tracts table CREATE TABLE nyc_census_tract_geoms AS SELECT ST_Union(geom) AS geom, SubStr(blkid,1,11) AS tractid FROM nyc_census_blocks GROUP BY tractid; -- Index the tractid CREATE INDEX nyc_census_tract_geoms_tractid_idx ON nyc_census_tract_geoms (tractid); 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1fdde22961b585ccf0d08b1c0d8f0a33/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d77a08d265d821622a82d72f13515169/" rel="bookmark">
			一分钟搭建宠物用品小程序，快速实现电商创业
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着移动互联网的普及，越来越多的消费者通过手机购物。宠物用品市场潜力巨大，为了吸引更多的用户，许多宠物用品店开始开发自己的小程序商城。对于没有任何开发经验的小白，如何才能快速开发一个宠物用品小程序呢？本文将为您提供从需求明确到提交审核的完整开发指南。
选择一个专业成熟的小程序商城制作平台，能大大简化开发过程。乔拓云平台是一个集商城、小程序、网站、APP四合一的智能建站平台，其亲少儿教育小程序模板功能强大，轻松实现各种业务逻辑，是一个值得考虑的选择。
一、设计搭建
1.登录乔拓云平台，点击【商城】进入后台管理页面。
2. 在后台管理页面中找到【小程序商城】，点击【去装修】进入设计搭建页面。
二、选择模板
在设计搭建页面的左边栏目内选择【模板】，通过搜索“宠物用品”或相关关键词，找到适合的小程序商城模板。
三、编辑修改
选好模板后，您可以根据需要对模板进行修改。可以直接点击要修改的内容进行编辑，也可以点击左边的功能选项进行编辑设置。平台提供了丰富的组件和功能，您可以根据需求自由组合和调整。
四、预览确认
完成编辑修改后，您可以点击预览按钮，查看小程序商城的最终效果。确认无误后，即可进入下一步。
五、提交审核
完成设计搭建后，您需要提交小程序商城进行审核。按照平台指引，完成相关信息的填写和配置，等待审核通过后即可发布上线。
总之，开发一个宠物用品小程序需要结合实际需求，选择合适的平台，通过模板快速搭建，并进行个性化的编辑修改。希望本文能为您提供从需求明确到提交审核的完整开发指南，帮助您顺利开发出满意的小程序商城。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95c1a595b1bb65d7f84da52df9b340c8/" rel="bookmark">
			2023年第七届强网杯初赛 WP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MISC easyfuzz 1、通过尝试输入字符串判断该程序对输入字符的验证规则为9位字符，并且只要满足输入正确字符使最后返回值全部为111111111即可得flag
继续大胆猜测并尝试，发现前两位字符可以为任何字符，都满足110000000，由此可以对后七位字符进行爆破
2、逐位爆破，验证思路正确，最后一位为字符串"d"
3、编写爆破脚本，当字符串长度为9位并输入时，将回显不为“Here is your code coverage: 110000000”的结果打印，脚本如下
from pwn import * from string import printable conn = remote('101.200.122.251', 12199) non_matching_strings = [] for i in range(9): for char in printable: payload = 'a'*i + char + 'a'*(8-i) print(conn.recvuntil(b'Enter a string (should be less than 10 bytes):')) conn.sendline(payload.encode()) response = conn.recvline().decode().strip() if response != "Here is your code coverage: 110000000": non_matching_strings.append(payload) for string in non_matching_strings: print(string) FLAG：qwb{YouKnowHowToFuzz!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/95c1a595b1bb65d7f84da52df9b340c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89dda9da43b17add91c173678b212786/" rel="bookmark">
			小米相机包 徕卡/原生相机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ht删tps://www.aliyundrive.com/s/ZNqmo53xTbw
提取码: r8ca 包含：
4700.apk
Apk-MIUI_Camera-v230210.apk
Camera_4.5.000511.0.apk
Camera_4.5.000761.0.apk
Camera_4.5.000941.0.apk
Camera_4.5.002870.0.apk
Camera_4.5.002920.0.apk
Camera_4.5.002940.0.apk
CameraMod_GLNRALR_4.7.230127.0.apk
com.android.camera_5.0.230629.3.apk
com.android.camera_...0001300_minAPI29.apk
LSPosed-v1.9.2-7024-zygisk-release.zip
Magisk-MIUI_Camera-...7-release-MIUI14.zip
适用于12sp的13u出厂相机.apk
相机（13U移植）_Leica_Mod_figure3.apk
相机（13U移植）_Leica_Mod_figure15.apk
相机（13U移植）_Leica_Mod_Ultra4.apk
相机_Mod_GLNRALR_4.7.230127.0.apk
相机_养老-04（发布版).apk
相机5.0-10u测试通过.apk
相机-com.android.came...ial_5.0.000640.2.apk
相机莱卡.apk
(徕卡算法大部分机型适用)相机_LEICA_水印修复.apk
4.5.002000.0.apk
4.5.2700.apk
4.9.002540.1模块版.zip
4.9.2540圣小熊付费版.apk
5.1.000150.0.apk
5.1.000274.0.apk
12S-4660.apk
12SPro-4700.apk
如有侵权，联系删除！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9210ed15f4a783cf0950f6f158bdfc9/" rel="bookmark">
			CSS3多列&amp;分页属性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CSS3多列 Firefox浏览器支持该属性的形式是-moz-column-count，而基于Webkit的浏览器，例如Safari和Chrome，支持该属性的形式是-webkit-column-count
column-count：该属性定义多列文本流中的栏数
语法：column-count:integer | auto
integer是一个表示文本分为多少栏的正值
column-gap：该属性定义了多列文本流中，列与列之间的距离
语法：column-gap:length | normal
length可以是CSS度量的任意正值
colums：该属性用于为多列文本流定义列数和列度
语法：colums:column-count width
column-rule-style：该属性定义多列文本流中列与列之间分割线的样式（初始值为none）
语法：column-rule-style:dashed | dotted | double | groove | hidden | inset | inherit | none | outset | ridge | solid
column-rule-width：该属性定义多列文本流中列与列之间分割线的宽度（默认值为medium）
语法：column-rule-width:non-negative length | medium | thick | thin | inherit
column-rule-color：该属性定义多列文本流中列与列之间分割线的颜色
语法：column-rule-color:color
color是任何有效的CSS颜色值
column-rule：该缩写属性定义了多列文本流中列与列之间分割线的样式、宽度和颜色。
语法：column-rule:rule-width rule-style color
column-width：该属性定义多列文本流中的列宽
语法：column-width:length | auto
CSS3分页 示例：
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e9210ed15f4a783cf0950f6f158bdfc9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a8e5520caf3c4c00fc7df1fe3d475df/" rel="bookmark">
			2023 巅峰之作 | AIGC、AGI、GhatGPT、人工智能大语言模型的崛起与挑战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 01 《ChatGPT 驱动软件开发》内容简介 02 《ChatGPT原理与实战》内容简介 03 《神经网络与深度学习》04 《AIGC重塑教育》内容简介 05 《通用人工智能》目　录 2023年是人工智能大语言模型大爆发的一年，一些概念和英文缩写也在这一年里集中出现，很容易混淆，甚至把人搞懵。
LLM：Large Language Model，即大语言模型，旨在理解和生成人类语言。LLM的特点是规模庞大，包含成百、上千亿的参数，可以捕捉语言的复杂模式，包括句法、语义和一些上下文信息，从而生成连贯的、有意义的文本。ChatGPT、GPT-4、BERT、文心一言等都是典型的大型语言模型。
GPT：Generative Pre-training Transformer，是OpenAI开发的一种基于Transformer的大规模自然语言生成模型。
AIGC：Artificial Intelligence Generated Content，即AI生成内容。指的是利用AI技术生成的内容，比如AI写文章、画画甚至做视频等等。
AGI：Artificial General Intelligence，即通用人工智能。AGI的目标是创造一个能像人类一样思考、学习、执行多种任务的系统，成为全能的“超级大脑”，未来可能在任何领域都超越人类。
除了概念之外，如果你想进一步了解这些技术的细节和进展，推荐你读这几本书。
01 《ChatGPT 驱动软件开发》 《 C h a t G P T 驱动软件开发》 《ChatGPT 驱动软件开发》 《ChatGPT驱动软件开发》
AI 在软件研发全流程中的革新与实践
推荐语：中国IT领军者陈斌新作，详解ChatGPT在软件研发全流程的应用，大幅提升研发效率，塑造工程师AI时代竞争优势。
适读人群 ：架构师、开发工程师、数据库工程师、测试工程师、运维工程师、项目经理、产品经理、UI/UX工程师和技术管理者
内容简介 这是一本讲解以ChatGPT/GPT-4为代表的大模型如何为软件研发全生命周期赋能的实战性著作。它以软件研发全生命周期为主线，详细讲解了ChatGPT/GPT-4在软件产品的需求分析、架构设计、技术栈选择、高层设计、数据库设计、UI/UX 设计、后端应用开发、Web 前端开发、软件测试、系统运维、技术管理等各个环节的应用场景和方法。让读者深刻地感受到，ChatGPT/GPT-4在革新传统软件工程的方式和方法的同时，还带来了研发效率和研发质量的大幅度提升。
.
更为重要的是，本书能帮助架构师、开发工程师、数据库工程师、测试工程师、运维工程师、项目经理、产品经理、UI/UX工程师和技术管理者深入地理解ChatGPT/GPT-4的原理和应用，全面塑造他们在AI时代的核心竞争力，实现价值创新并形成竞争优势，为未来的发展奠定基础。
02 《ChatGPT原理与实战》 《 C h a t G P T 原理与实战》 《ChatGPT原理与实战》 《ChatGPT原理与实战》
大型语言模型的算法、技术和私有化
推荐语：BAT资深AI专家和大模型技术专家撰写，MOSS系统负责人邱锡鹏等多位专家鼎力推荐！系统梳理并深入解析ChatGPT的核心技术、算法实现、工作原理、训练方法，提供大量代码及注解。
适读人群 ：大模型工程师、AI工程师
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a8e5520caf3c4c00fc7df1fe3d475df/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57231f6319affd12b9cccb32bb414c44/" rel="bookmark">
			Autogen4j: the Java version of Microsoft AutoGen
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://github.com/HamaWhiteGG/autogen4j
Java version of Microsoft AutoGen, Enable Next-Gen Large Language Model Applications.
1. What is AutoGen AutoGen is a framework that enables the development of LLM applications using multiple agents that can converse with each other to solve tasks. AutoGen agents are customizable, conversable, and seamlessly allow human participation. They can operate in various modes that employ combinations of LLMs, human inputs, and tools.
The following example in the autogen4j-example.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57231f6319affd12b9cccb32bb414c44/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f8cf9a97cb5ca073ae9af7b9f7ee204/" rel="bookmark">
			python爬虫进阶篇：Scrapy中使用Selenium模拟Firefox火狐浏览器爬取网页信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 接着上一篇的笔记，Scrapy爬取普通无反爬、静态页面的网页时可以顺利爬取我们要的信息。但是大部分情况下我们要的数据所在的网页它是动态加载出来的（ajax请求后传回前端页面渲染、js调用function等）。这种情况下需要使用selenium进行模拟人工操作浏览器行为，实现自动化采集动态网页数据。
二、环境搭建 Scrapy框架的基本依赖包（前几篇有记录）selenium依赖包 pip install selenium==4.0.0a6.post2pip install certifipip install urllib3==1.25.11 安装Firefox浏览器和对应版本的驱动包 火狐浏览器我用的是最新版121.0驱动的版本为0.3.0，见上方资源链接把驱动放到python环境的Scripts文件夹下 三、代码实现 settings设置 SPIDER_MIDDLEWARES = { 'stock_spider.middlewares.StockSpiderSpiderMiddleware': 543, } DOWNLOADER_MIDDLEWARES = { 'stock_spider.middlewares.StockSpiderDownloaderMiddleware': 543, } ITEM_PIPELINES = { 'stock_spider.pipelines.StockSpiderPipeline': 300, } middlewares中间件 from selenium.webdriver.firefox.options import Options as firefox_options spider.driver = webdriver.Firefox(options=firefox_options()) # 指定使用的浏览器 process_request def process_request(self, request, spider): # Called for each request that goes through the downloader # middleware. # Must either: # - return None: continue processing this request # - or return a Response object # - or return a Request object # - or raise IgnoreRequest: process_exception() methods of # installed downloader middleware will be called spider.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f8cf9a97cb5ca073ae9af7b9f7ee204/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89b44e05e70d4c4b4a495b9581998aa1/" rel="bookmark">
			栈与队列part01-算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		栈与队列 今日任务：
● 理论基础
● 232.用栈实现队列
● 225. 用队列实现栈
1.232.用栈实现队列 232. 用栈实现队列
class MyQueue { //使用两个栈实现先入先出队列 //定义两个Stack集合//就已经拥有了这个集合的方法了push pop peek isEmpty等等 //但是我们这里是实现队列的逻辑 //用来入栈 Stack &lt;Integer&gt; stackIn; //一个用来出栈 Stack&lt;Integer&gt; stackOut; public MyQueue() { //初始化属性 stackIn=new Stack&lt;&gt;();//负责进栈 stackOut=new Stack&lt;&gt;();//负责出栈 } public void push(int x) { //队列的进列操作是直接进 //栈的入栈操作也是直接进 stackIn.push(x); } public int pop() { //队列出列是先出（先进先出） //栈的出栈是后出（先进后出） //那么我们现在定义两个栈，一个用来入栈 //一个用来入栈 //将入栈的栈的元素一个一个出到作为出栈的栈里面 //再从这个作为出栈的栈进行取出元素，此时取出的元素就是队列先进先出那个 //把作为入栈的所有元素都移到作为出栈的那个栈里 if(stackOut.isEmpty()){ while(!stackIn.isEmpty()){ //不为空就一直移到作为出栈的那个栈中 stackOut.push(stackIn.pop()); //存进作为出栈的栈里之后，别忘将作为入栈的栈顶元素去除 //stackIn.pop();//这一步已经不用做了，上一步这样子的已经生效了（不像c) } } //现在作为出栈的栈里头就是队列出列顺序了 //在进行移除之前，我们先将这个要被移除的元素保存下来，待会进行返回 int result=stackOut.pop(); //stackOut.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89b44e05e70d4c4b4a495b9581998aa1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6774376e3c52ecba6b4f772fd1b646a6/" rel="bookmark">
			Qt制作定时关机小程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 完成效果图ui界面ui样图 main函数窗口文件头文件cpp文件 引言
一般定时关机采用命令行模式，还需要我们计算在多久后关机，我们可以做一个小程序来定时关机
完成效果图 ui界面 &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;ui version="4.0"&gt; &lt;class&gt;MainWindow&lt;/class&gt; &lt;widget class="QMainWindow" name="MainWindow"&gt; &lt;property name="geometry"&gt; &lt;rect&gt; &lt;x&gt;0&lt;/x&gt; &lt;y&gt;0&lt;/y&gt; &lt;width&gt;330&lt;/width&gt; &lt;height&gt;240&lt;/height&gt; &lt;/rect&gt; &lt;/property&gt; &lt;property name="minimumSize"&gt; &lt;size&gt; &lt;width&gt;330&lt;/width&gt; &lt;height&gt;240&lt;/height&gt; &lt;/size&gt; &lt;/property&gt; &lt;property name="maximumSize"&gt; &lt;size&gt; &lt;width&gt;330&lt;/width&gt; &lt;height&gt;240&lt;/height&gt; &lt;/size&gt; &lt;/property&gt; &lt;property name="font"&gt; &lt;font&gt; &lt;pointsize&gt;10&lt;/pointsize&gt; &lt;/font&gt; &lt;/property&gt; &lt;widget class="QWidget" name="centralwidget"&gt; &lt;layout class="QGridLayout" name="gridLayout_2"&gt; &lt;item row="3" column="1"&gt; &lt;widget class="QWidget" name="widget" native="true"&gt; &lt;layout class="QGridLayout" name="gridLayout"&gt; &lt;item row="2" column="0"&gt; &lt;layout class="QHBoxLayout" name="horizontalLayout_2"&gt; &lt;item&gt; &lt;widget class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6774376e3c52ecba6b4f772fd1b646a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa1c63354835d853ae7de1c72a78730c/" rel="bookmark">
			PHP下载安装以及基本配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
引言
官网
下载
配置
1. 鼠标右键“此电脑”&gt;“属性”
2. 打开高级系统设置
3. 打开环境变量
4. 双击系统变量中的path
5. 新建新的path
6. 将刚刚安装的位置加入环境变量
7. 检查是否安装成功
引言 PHP（"PHP: Hypertext Preprocessor"，超文本预处理器的字母缩写）是一种被广泛应用的开放源代码的多用途脚本语言，它可嵌入到 HTML中，尤其适合 web 开发。
和客户端的 JavaScript 不同的是，PHP 代码是运行在服务端的。如果在服务器上建立了如上例类似的代码，则在运行该脚本后，客户端就能接收到其结果，但他们无法得知其背后的代码是如何运作的。甚至可以将 web 服务器设置成让 PHP 来处理所有的 HTML 文件，这么一来，用户就无法得知服务端到底做了什么。
使用 PHP 的最大的好处是它对于初学者来说极其简单，同时也给专业的程序员提供了各种高级的特性。当看到 PHP 长长的特性列表时，请不要害怕。可以很快的入门，只需几个小时就可以自己写一些简单的脚本。
官网 首先打开php官网：PHP: Hypertext Preprocessor
进入下载页面
选择windows版本进行下载
下载 下载zip文件
解压到你所需要的目录。
打开命令行，进入到你所解压的目录下：
D: # 进入相应盘符 cd your_path # 输入你所解压的路径 输入
php.exe -v 如果有像我这样的输出，就说明安装成功啦！
配置 为了方便后续开发测试，我们需要将php所在安装路径加入环境变量：
1. 鼠标右键“此电脑”&gt;“属性” 2. 打开高级系统设置 如果是win11或者win7的话或许界面ui不一样但是都在这里配置，稍微找一下就行啦~
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa1c63354835d853ae7de1c72a78730c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0034955862dc37ca1b89cddd4d9fae4/" rel="bookmark">
			RocketMQ高级原理：深入剖析消息系统的核心机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、基础概念： 1. 消息模型 RocketMQ基于Producer、Broker、Consumer三部分构建。其中，Producer负责生成消息，Consumer处理消息，而Broker则承担消息存储的角色。Broker服务器可以存储多个Topic的消息，并支持消息在不同Broker间的分片存储。此外，ConsumerGroup由多个Consumer实例构成，以实现高效的消息处理。
2. 消息生产者（Producer） 作为消息生产的角色，Producer将业务系统生成的消息发送至Broker。RocketMQ支持多种发送方式，包括同步发送、异步发送、顺序发送和单向发送。同步和异步发送方式需要Broker返回确认信息，而单向发送则不需要。此外，RocketMQ支持将同类Producer组成生产者组，用以处理事务消息和实现高可用性。
3. 消息消费者（Consumer） Consumer主要负责从Broker拉取并消费消息。RocketMQ提供了拉取式消费和推动式消费两种模式。拉取式消费允许应用主动从Broker拉取消息，而推动式消费则由Broker主动将消息推送至Consumer。Consumer组的概念也同样适用于消费者，实现了负载均衡和容错。
4. 主题（Topic） Topic是RocketMQ进行消息订阅的基本单位，代表一类消息的集合。每个Topic的数据可以分片保存到不同的Broker上，而MessageQueue作为生产者发送消息与消费者消费消息的最小单位，确保了消息处理的高效性。
5. 代理服务器（Broker Server） Broker Server作为消息中转的核心角色，负责消息存储和转发。它存储消息相关的元数据，如消费者组、消费进度偏移等。Broker Server由多个重要子模块组成，包括远程模块、客户端管理器、存储服务、高可用服务和索引服务。RocketMQ的高可用性依赖于主从集群架构，支持普通集群和Dledger高可用集群两种模式。
6. 名字服务（Name Server） Name Server作为消息路由的提供者，承担重要的路由服务。Broker Server在启动时会向所有Name Server注册自己的服务信息，确保路由信息的及时更新。此外，多个Name Server实例构成集群，但它们相互独立，保证了系统的稳定性和可靠性。
7. 消息（Message） 作为消息系统的物理载体，每条消息必须属于一个Topic，并拥有唯一的Message ID。RocketMQ支持通过Message ID和Key查询消息，增强了消息追踪的能力。此外，Message上的Tag标签为同一主题下不同类型的消息提供了有效区分，优化了RocketMQ的查询系统。
Dledger技术和Raft算法 RocketMQ的Dledger技术采用了Raft算法进行节点选举和多副本的消息同步，确保了集群的高可用性和数据一致性。在Raft算法中，每个节点开始时都是follower状态，通过选举产生leader节点。Raft协议通过心跳机制和term概念来维护集群的状态和领导者的地位。
二、消息存储 消息存储时机与介质 RocketMQ在收到消息后立即返回ACK响应并存储消息，确保高可靠性。此外，它还负责标记消费者已消费的消息，并定期删除过期消息以维持系统的可用性。RocketMQ采用类似于Kafka的文件存储机制，直接使用磁盘文件存储消息，而不依赖如MySQL这类索引工具。这种机制利用了高性能磁盘的顺序写速度优势，实现高效的消息存储。
零拷贝技术 在处理文件和网络操作时，RocketMQ通过零拷贝技术减少数据复制，提高文件读写效率。这在Linux系统中是通过mmap（内存映射）实现的，能够省去向用户态内存的复制过程。RocketMQ利用了Java NIO包中的MappedByteBuffer来实现这一机制，有效提高了消息存盘和网络发送的速度。不过，这种内存映射方式存在文件大小的限制，这也是为什么RocketMQ默认将单个CommitLog日志数据文件设为1G的原因。
消息存储结构 RocketMQ的消息存储结构分为三个部分：
CommitLog：存储所有消息的元数据，由多个固定大小（1G）的文件组成。ConsumerQueue：为每个MessageQueue提供索引，记录消息被哪些消费者组消费。IndexFile：支持基于key或时间区间的消息查询，不影响消息的发送与消费流程。 刷盘机制 为确保消息的持久化，RocketMQ提供同步刷盘和异步刷盘两种机制。同步刷盘保证消息写入磁盘后再返回成功状态，提高了数据的可靠性但牺牲了吞吐量。异步刷盘则在内存中积累一定量的消息后统一写入磁盘，提高了性能但可能存在数据丢失的风险。这两种方式可以通过Broker配置文件中的flushDiskType参数进行设置。
消息主从复制 在集群部署中，RocketMQ通过主从复制机制确保高可用性。同步复制方式确保了数据的完整备份，但会增加数据写入的延迟。异步复制虽然提高了吞吐量和降低了延迟，但在主节点故障时可能会导致数据丢失。复制方式的选择取决于系统对数据可靠性和性能的权衡，可通过brokerRole参数进行配置。
负载均衡 在Producer和Consumer中，RocketMQ实现了高效的负载均衡机制。Producer默认采用轮询策略，均匀地将消息分布到不同的MessageQueue上。Consumer在集群模式下，通过平均分配或其他分配算法，均匀分配MessageQueue给每个消费者实例，确保了系统的高效和稳定性。
总结 RocketMQ的消息存储机制和负载均衡策略展现了其作为高性能分布式消息中间件的核心优势。通过高效的文件存储机制、零拷贝技术、灵活的刷盘选项以及高效的主从复制和负载均衡策略，RocketMQ能够在保证消息可靠性的同时，提供高吞吐量和低延迟的性能，满足企业级应用的需求。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f052382768a4141fd8070cbcd9bfc19/" rel="bookmark">
			《剑指offer》Java版--13.机器人的运动范围（BFS）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		剑指offer原题13:机器人的运动范围
地上有一个m行n列的方格。一个机器人从坐标(0,0)的格子开始移动，它每次可以向左、右、上、下移动一格，但不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时,机器人能够进入方格(35,37),因为3+5+3+7=18。但它不能进入方格(35,38)，因为3+5+3+8=19。请问该机器人能够到达多少个格子?
LeetCode原题：https://leetcode.cn/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/description/
class Solution { public int wardrobeFinishing(int m, int n, int cnt) { // ps:这是力扣题目有点不一样，方向只有两个。 int[][] dir = new int[][]{{1, 0}, {0, 1}}; boolean[][] vis = new boolean[m][n]; LinkedList&lt;Pair&lt;Integer, Integer&gt;&gt; queue = new LinkedList&lt;&gt;(); queue.push(new Pair&lt;&gt;(0, 0)); int res = 0; while(queue.size() &gt; 0) { Pair&lt;Integer, Integer&gt; pair = queue.pollFirst(); vis[pair.getKey()][pair.getValue()] = true; res++; for(int i = 0; i &lt; 2; ++i) { int nextX = pair.getKey() + dir[i][0]; int nextY = pair.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f052382768a4141fd8070cbcd9bfc19/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b008382aae380324b20932a71b07ac7/" rel="bookmark">
			数据结构 | 查漏补缺
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
数据的基本单位
冒泡排序 DFS和BFS中文
Prim
比较
中序线索二叉树
顺序栈
链栈
时间复杂度
循环队列
求第K个结点的值
数据的基本单位 数据元素
循环队列sq中，用数组elem[0‥25]存放数据元素，设当前sq-&gt;front为20，sq-&gt;rear为12，则当前队列中的元素个数为（ D）。
A.8
B.16
C.17
D.18
计算：（sq-&gt;rear - sq-&gt;front+maxsize）% maxsize = （12-20+26）%26 = 18
7.设有一个10阶的对称矩阵A，采用压缩存储方式以行序为主序存储，a00为第一个元素，,其存储地址为0，每个元素占有1个存储地址空间，则a45的地址为 冒泡排序 Rectype R[n]; { int i = 1; do { exchang = False; for (j = n; j &gt;= 2; j--) { if (R[j] &lt; R[j - 1]) { temp = R[j - 1]; R[j - 1] = R[j]; R[j] = temp; exchang = true; } break; } } while (exchang==false); } DFS和BFS中文 Prim 比较 中序线索二叉树 顺序栈 链栈 时间复杂度 循环队列 求第K个结点的值 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc0804995b842912f61ba030ef7e5f32/" rel="bookmark">
			MapReduuce配置&amp;YARN集群部署并启动(非常详细！！)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🐮博主syst1m 带你 acquire knowledge！
✨博客首页——syst1m的博客💘
😘《CTF专栏》超级详细的解析，宝宝级教学让你从蹒跚学步到健步如飞🙈
😎《大数据专栏》大数据从0到秃头👽，从分析到决策，无所不能❕
🔥 《python面向对象(人狗大战)》突破百万的阅读量，上过各种各样的官方大型专栏，python面向对象必学之一！🐽
🎉希望本文能够给读者带来帮助，更好地理解这个问题或解决你的困惑🐾
1.部署集群概述 1.1 修改YARN和MapReduce相关配置文件,仅修改YARN的相关进程(MapReduce无需启动进程,需要时会运行YARN内部(容器中)) 1.2 查看YARN运行页面 1.3 环境概述
hadoop YARN分布式资源调度,会启动ResourceManager进程作为管理节点,NodeManager进程作为工作节点,ProxyServer，JobHistoryServer这两个辅助节点
2.集群规划 有三台服务器,其中node1配置较高,集群如下:
3.MapReduce配置文件 3.1 在$HADOOP_HOME/etc/hadoop文件夹内，修改mapred-env.sh文件，添加如下环境变量 3.2 mapred-site.xml文件 3.3 yarn-env.sh文件 3.4 yarn-site.xml 核心配置 额外配置
3.5 分发文件 配置好文件之后，和之前的HDFS一样分发文件到root2，root3，分发到其他的服务器节点中 scp mapred-env.sh mapred-site.xml yarn-env.sh yarn-site.xml root2:`pwd`/ scp mapred-env.sh mapred-site.xml yarn-env.sh yarn-site.xml root3:`pwd`/ 分发完成配置文件，就可以启动YARN的相关进程了 4.启动集群 集群启动命令介绍： 一键启动YARN集群：$HADOOP_HOME/sbin/start-yarn.sh 会基于yarn-site.xml中配置的yarn.resourcemanager.hostname来决定哪台机器上启动resourcemanager 会基于workers文件配置的主机启动NodeManager 一键停止YARN集群：$HADOOP_HOME/sbin/stop-yarn.sh 在当前机器，单独启动或停止进程 $HADOOP_HOME/bin/yarn --daemon start|stop resourcemanager | nodemanager | proxyserver start和stop决定启动和停止 历史服务器启动和停止 $HADOOP_HOME/bin/mapred --daemon start | stop | historyserver 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fc0804995b842912f61ba030ef7e5f32/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f96072e2f3c5812406340caaaf171722/" rel="bookmark">
			PTA判断上三角矩阵（C语言）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题意： 上三角矩阵指主对角线以下的元素都为0的矩阵；主对角线为从矩阵的左上角至右下角的连线。
本题要求编写程序，判断一个给定的方阵是否上三角矩阵。
输入格式： 输入第一行给出一个正整数T，为待测矩阵的个数。接下来给出T个矩阵的信息：每个矩阵信息的第一行给出一个不超过10的正整数n。随后n行，每行给出n个整数，其间以空格分隔。
输出格式： 每个矩阵的判断结果占一行。如果输入的矩阵是上三角矩阵，输出“YES”，否则输出“NO”。
输入样例： 3 3 1 2 3 0 4 5 0 0 6 2 1 0 -8 2 3 1 2 3 1 4 5 0 -1 6 输出样例： YES NO NO 鸣谢中水七局机电安装分局喻春桥补充数据！
代码长度限制
16 KB
时间限制
400 ms
内存限制
64 MB
代码如下（示例）： 代码： #include &lt;stdio.h&gt; #define MAXN 10 int Init_trueORfalse(int a[][MAXN],int n){//初始数组并判断 int cnt=0;//计算符合条件的0的个数 int k=n*(n-1)/2;//当方阵规模为n*n，三角矩阵中符合条件的0应该有k个； for(int i=0;i&lt;n;i++){//k用数列求和来求，求出通项公式 for(int j=0;j&lt;n;j++){ scanf("%d",&amp;a[i][j]); if(i&gt;j&amp;&amp;a[i][j]==0) cnt++;//符合条件的0的个数累加 } } return cnt==k;//若a[][]是三角矩阵，则返回1，否则返回0； } int main(){ int T,n; scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f96072e2f3c5812406340caaaf171722/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f6169bcac8476fce8a4d909e4fd9c37/" rel="bookmark">
			springboot学习笔记（五）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MybatisPlus进阶
1.MybatisPlus一对多查询
2.分页查询
1.MybatisPlus一对多查询
场景：我有一个表，里面填写的是用户的个人信息（姓名，生日，密码，用户ID）。我还有一个表填写的订单信息（订单编号，订单价格，下单用户id）。现在我想查询用户信息的时候，将用户的订单信息一并查询出来。
a.编写User类
第一步肯定是编写User类，User里应该包含用户ID，密码，生日，用户对应订单。这里需要注意，根据ORM，我们编写的User类是对应了User表的，但是User表里是不包含订单这个字段的。所以，我们在编写的时候，需要注明该字段是不存在User表中，不然会报错。
package com.example.mpdemo; import java.util.List; import com.baomidou.mybatisplus.annotation.TableField; import com.baomidou.mybatisplus.annotation.TableName; @TableName("t_user") public class User { private int id; private String username; private String password; private String birthday; @TableField(exist = false) private List&lt;Order&gt; orders; public int getId() { return id; } public void setId(int id) { this.id = id; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getPassword() { return password; } public void setPassword(String password) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f6169bcac8476fce8a4d909e4fd9c37/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8bdbae2ef0511daf8797465cc0c2484e/" rel="bookmark">
			面试遇到了接口分析和测试用例分析题，该如何下手？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		只要有软件产品的公司百分之九十以上都会做接口测试，要做接口测试的公司那是少不了接口测试工程师的，接口测试工程师相对于其他的职位又比较轻松并且容易胜任。如果你想从事接口测试的工作那就少不了对接口进行分析，同时也会对测试用例进行研究。
当然要从事接口测试工作，必需得先过面试关。最近对于接口测试经常问的面试有：
******科技服务有限公司
第一轮：
1、自我介绍
2、你有做个几个项目，都说一下
3、你个人有什么优势？
4、你擅长uI接口还是接口自动化？
5、接口自动化是测什么？
6、你是怎么分析接口的？
7、接口测试用例是从哪些方面去思考的？ 8、python的环境怎么搭建
9、你封装做过哪些自定义函数
10、讲一下冒泡排序
11、你写好代码之后用什么来管理
第二轮面试：
1、怎么做自动化的？
2、封装过什么函数
3、了解正则表达式吗
******有限公司深圳分公司
1.离职原因？
2.你现在住在哪里？
3.自我介绍
4.项目介绍
5.查询模块中的日期查询是怎么去测试的？
6.UI自动化怎么去做的？
7.项目需求多吗？
8.项目组的组成
9.公司是做什么的？
10.项目有多少接口？
11.怎么去做接口测试的？
12.你做了哪些接口？
13.你在做接口测试的之前是如何分析接口的？
14.接口测试用例思维是什么？ 15.有没有做过性能测试？里面涉及到哪些参数？
16.登录模块怎么去测？
17.还有什么要问的吗？
18.你会怎么去把控测试的质量和进度？
19.开发认为不是bug你认为是bug该怎么处理？
对于接口，在面试的时候如果遇到了下面的两个问题可以按照小编的总结去回答。
现在我也找了很多测试的朋友，做了一个分享技术的交流群，共享了很多我们收集的技术文档和视频教程。 如果你不想再体验自学时找不到资源，没人解答问题，坚持几天便放弃的感受 可以加入我们一起交流。而且还有很多在自动化，性能，安全，测试开发等等方面有一定建树的技术大牛 分享他们的经验，还会分享很多直播讲座和技术沙龙 可以免费学习！划重点！开源的！！！ qq群号：691998057【暗号：csdn999】 1.你在做接口测试之前是你如何分析接口的？
1）.分析接口文档了解接口的详细信息掌握接口实现的功 能：包括接口的请求和响应格式、参数说明、返回值等。
2）.分析接口与接口之间的关联关系:是单接口关联还是多接口关联。
3）.分析请求和响应：根据接口文档，请求信息中请求的方法（GET、POST、PUT、DELETE等）、请求头、请求体、请求参数等；响应信息中响应的状态码、响应头、响应体进行分析。
4）.确定测试数据：根据接口文档，确定测试所需的请求数据和响应数据。通常情况下，接口测试需要提供正确的请求数据以模拟用户操作，并验证返回的响应数据是否符合预期。 5）.确定测试场景：根据接口的功能和业务需求，确定需要测试的场景。
6）.确定测试方法：根据接口的特点和业务需求，选择合适的测试方法。
7）.编写测试计划：编写详细的测试计划，包括测试场景、测试数据、预期结果等。
8）.执行测试：执行测试，记录测试结果并进行分析。如果发现缺陷，需要及时跟踪。
2.接口测试用是从哪些方面着手来写的？
1）.正常数据的业务和异常数据的业务逻辑
2）.必填项不填写时，接口的容错能力的测试
3）.入参规则的测试，各类型 的返回码的构造数据的测试
4) .接口的权限测试--有无权限时接口的表现
5) .性能测试----并发测试，分布式测试等
6）.与钱有关的接口一定要按上面3条来执行 7）.与钱无关的接口，有可能只要做主业务流程的自动化脚本
END今天的分享就到此结束了！点赞关注不迷路~！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/412e02fc7d90064459c06499d288fb90/" rel="bookmark">
			深度剖析Ajax实现方式(原生框架、JQuery、Axios，Fetch）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ajax学习 简介： ​ Ajax 代表异步 JavaScript 和 XML（Asynchronous JavaScript and XML）的缩写。它指的是一种在网页开发中使用的技术，通过在后台与服务器进行数据交换，实现页面内容的更新，而无需刷新整个页面。Ajax 技术可以使网页更加动态和交互性，提供更好的用户体验。
场景： 页面懒加载登录注册相关提示鼠标移上去才加载 XML： ​ XML (eXtensible Markup Language) 是一种用于描述数据的标记语言。它被设计用于传输和存储数据，同时具有跨平台和跨应用程序的特性。XML 使用标记来标识和组织数据，类似于 HTML，但不同于 HTML，XML 的目标是描述数据，传输数据而不是展示数据。
&lt;student&gt; &lt;name&gt;孙悟空&lt;/name&gt; &lt;age&gt;18&lt;/age&gt; &lt;gender&gt;男&lt;/gender&gt; &lt;/student&gt; &lt;person&gt; &lt;name&gt;John Doe&lt;/name&gt; &lt;age&gt;30&lt;/age&gt; &lt;email&gt;john.doe@example.com&lt;/email&gt; &lt;/person&gt; JSON： ​ JSON (JavaScript Object Notation) 是一种轻量级的数据交换格式。它基于 JavaScript 的语法，但已成为一种独立于编程语言的通用数据格式。JSON 使用易于阅读和编写的文本格式，用于表示结构化的数据。
{"name":"孙悟空","age":18,"gender":"男"} { "name": "John Doe", "age": 30, "email": "john.doe@example.com", "hobbies": ["reading", "traveling", "photography"], "address": { "street": "123 Main St", "city": "Exampleville", "country": "USA" } } 服务端框架： ​ 因为Ajax的学习需要与服务器端进行交互，为了学习方便，我们采用express框架作为服务器端。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/412e02fc7d90064459c06499d288fb90/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac404255aa2101d890b4a9d86bac95f3/" rel="bookmark">
			音视频基本概念
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		多线程好处 充分利用cpu资源的工具
多线程带来的问题 多线程管理问题
线程的互斥与同步 互斥 资源 有限多个人去抢
同步 有序进行
锁的种类 读写锁 读写分离
自旋锁 等待资源释放（例如）
可重入锁
SDL锁
互斥锁
SDL_CreateMutex/SDL_DestroyMutex
SDL_LockMutex/SDL_UnlockMutex
信号量
SDL_CreateCond/SDL_DestroyCond
SDL_CondWait/SDL_CondSignal
使用锁 typedef struct _PacketQueue{ AVPacketList *first_pkt, *last_pkt; int nb_packets; int size; SDL_mutex *mutex; SDL_cond *cond; }PacketQueue; 基本概念 pts：Presentation timestamp 展示音频和视频时间戳 最终渲染也是根据这个时间戳
dts: Decoding timestamp 解码时间戳 I帧 （关键帧 帧内压缩）
p帧（向前参考帧 帧间压缩 只记录前一帧变化的部分）
B帧（帧间压缩 记录前一帧和后一帧的差别 可参考前后几帧 ）
实际帧顺序 I B B P 存放顺序 I P B B
解码时间戳 1423
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac404255aa2101d890b4a9d86bac95f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79c49b02564e87970a38b75157268e74/" rel="bookmark">
			从功能测试到测试开发，薪资翻倍，我整理的全网最全学习指南！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在这个吃技术的IT行业来说，我刚入行的时候每天做的也是最基础的工作，但是随着时间的消磨，我产生了对自我和岗位价值和意义的困惑。
一是感觉自己在浪费时间，另一个就是做了快2年的测试，感觉每天过得浑浑噩噩，薪资也从不见涨，岗位也一直得不到提升，我身边的许多同事要么升职加薪，要么跳槽去了更好的公司工作，特别觉得我自己碌碌无为。
我开始思考怎么去改变现状。当时最简单的想法是挤出时间去学习各种测试技术和工具，提高自己的价值，也就是核心竞争力。后来被测试组长偶然发现，给了我一些资源和文档，建议我去研究下自动化测试。当时来说，我还没有接触过自动化测试，但是通过组长给我的资源，让我认识到开发知识对于测试工作的帮助，编程语言的能力会决定你测试技术的深度。当然也能带来收入的高度
那时候正是脚本语言开始流行起来，因为当时项目的原因跟Python结缘，开始用Python语言和Selenium来尝试做自动化测试。那时，关于Python版的Selenium并不多，在学习的同时我开始发表相关博客。分享是学习新技术的驱动力，大多数时候我们很难坚持学一个新技术的原因就在于缺少反馈，不管是做内部分享或者是博客都是很好的反馈机制。当然，也很有成就感。
到后来转型自动化测试，再到测试开发，不知不觉间已经有了6年多测试开发的经验，月薪也是突破了30K的门槛，在美团测试开发框架组呆过，搭建过美团platuo测试框架，thrift测试框架，自动化测试平台，这也是让我熟悉了python3，vue，陆陆续续也是在多家公司从0到1搭建过自动化测试框架，保障过亿级流量服务的质量工作。
这两天和朋友谈到软件测试的行业趋势，随着转行以及毕业的大学生疯狂涌入软件测试行业。想要获得更好的待遇和机会，不断掌握新的技能，提高业务能力也就变成了目前软件测试从业人员迫在眉睫需要解决的问题。不论是面试哪个级别的测试工程师，面试官都会问一“会编程吗？有没有做过自动化测试？”，所以还停留在功能测试层面，不去提升技术，还要面临长江后浪推前浪的压力。就只能接受窘境，最后甚至是面临淘汰。更别说升值加薪了
所以如何从功能测试到自动化测试，达到技术提升的目的，是很多初级测试人必经的一个阶段。作为一个过来人，对学习过程中的困难深有体会。所以我热衷于收集整理资源，记录踩坑到爬坑的过程。希望能把自己所学，实际工作中使用的技术、自学方法、心得及踩过的一些坑，记录下来。一是更好的梳理自己，二也是能做到更好的社区分享。
一、自动化测试工具使用 首先是测试工具的使用，比如说我要去进行web自动化是不是我要去进行自动化测试环境搭建，环境工具。比如说去安装Python安装，这些环境安装。
至于AppUI自动化，除了上面的一些技能还要会比如说adb的命令，app的环境，app的压力测试之类的。
接口测试其实也是一种功能测试，但是它并不等于功能测试，因为对于接口测试的话也分为
接口功能测试（需要借助工具进行测试）；接口压力测试；接口安全性测试。 而且接口的功能测试是需要借助工具来完成，工具的话就有比如：Postman、Jmeter；抓包的工具fiddler等。
二、Python编程语言 编程语言的能力会决定你测试技术的深度，我当时学的是Python语言，了解编程的都知道Python对新人比较友好，相比其他编程语言来说会比较简单。
在网上找了很多的学习资料和学习视频，但是学起来就会遇到很多问题，没有人能帮我解答，还有很多编程的相关知识，也不太懂，自己一个人学起来很费劲的。容易从入门到放弃
所以也是到处去找那种软件测试的学习社区，有幸遇到了一位测试行业的技术大佬，进到了一个很不错的学习交流群内，里面有很多人都和我一样想要提升，所以都在一起学习，有什么问题都会在群里相互讨论、技术交流，这也极大的提高了学习效率。
现在我也找了很多测试的朋友，做了一个技术分享的交流群，共享了很多我们收集的视频教程和技术文档。如果你不想再体验找不到资源，没人解答问题，坚持几天便放弃的感受，可以加入我们一起讨论交流。而且还有很多在自动化，性能方面有一定建树的技术大牛，分享他们的经验，还会分享很多直播讲座和视频教程资源，可以免费学习，开源分享的内容。
Python是软件测试进阶的第一步，我们需要掌握Python编程语法，具有一定的编码能力，为基础自动化测试做准备，其次还要掌握Python在自动化中的应用、掌握代码的函数封装、类封装的技能。
三、测试框架 我们还要懂测试框架，Selenium，appium，unittest，pytest，这都是一些开源的框架你至少要懂中间的一到两个。
比如说做WebUI自动化的话，我要懂Selenium+python；做AppUI自动化的话，我要懂appium+python。
如果是进行接口测试的话肯定也是需要去做一个接口的框架，比如：requests。
✪ 测试框架开发 一般一个框架的诞生过程会经过三个阶段：
学会使用 大致了解框架的使用，可以去看框架的官方文档，一般里面都有详细的介绍，安装之后便可以开始尝试直接拿它来做项目。
2. 阅读源码
想要提升自己的能力、达到进阶的效果，当然不能只局限于框架的使用层面上。需要自己多花几周甚至几个月的时间去阅读框架的源码，这样有助于框架使用过程的各种问题的处理和排查。
3. 自研框架
自研框架的要求就比较高，一般都是企业对性能有极高的要求，所有的开源或商业的框架都无法满足公司需求才会走上自研的道路。我们可以尝试分析整个框架性能瓶颈，用更高性能的语言替换关键模块，或用寻找、研究更好的算法去实现关键功能。
关于这些知识点的掌握肯定是需要自己多花时间和精力的，关于这些学习资料和学习教程你可以去咱们交流群的群文件直接获取，还很多录制的视频教程，大佬的讲解非常详细，能够帮助你快速理解与掌握。
根据这个学习架构路线，不断地去摸索与提升，突破技术的瓶颈，可以说，这个过程会让你痛不欲生，但只要你熬过去了。以后的生活就轻松很多。正所谓万事开头难，只要迈出了第一步，你就已经成功了一半，等到完成之后再回顾这一段路程的时候，你肯定会感慨良多。我也是走过这样一段路，才能获得更多高薪职位的机会，付出终有回报，也算是对我能力的一种认可吧，真正的证明了自己的价值。至少税后30+的薪水是我当前状态下比较满意的。
如果说你在自动化测试工程师阶段还想往性能测试方面去进行发展，要求就会更多了，其实性能也是一种自动化。所以第一个你也必须要掌握一门编程语言，第二个语言脚本，第三个指标，第四个调优。
今天主要是和大家分享我的学习路线和视频资源，后续我会分享更多关于软件测试资源教程，有被帮助到的朋友，大家可以关注和点赞一下~
自动化测试相关教程推荐： 2023最新自动化测试自学教程新手小白26天入门最详细教程,目前已有300多人通过学习这套教程入职大厂！！_哔哩哔哩_bilibili 2023最新合集Python自动化测试开发框架【全栈/实战/教程】合集精华，学完年薪40W+_哔哩哔哩_bilibili 测试开发相关教程推荐 2023全网最牛，字节测试开发大佬现场教学，从零开始教你成为年薪百万的测试开发工程师_哔哩哔哩_bilibili postman/jmeter/fiddler测试工具类教程推荐 讲的最详细JMeter接口测试/接口自动化测试项目实战合集教程，学jmeter接口测试一套教程就够了！！_哔哩哔哩_bilibili 2023自学fiddler抓包，请一定要看完【如何1天学会fiddler抓包】的全网最详细视频教程！！_哔哩哔哩_bilibili 2023全网封神，B站讲的最详细的Postman接口测试实战教学，小白都能学会_哔哩哔哩_bilibili 总结： 光学理论是没用的，要学会跟着一起敲，要动手实操，才能将自己的所学运用到实际当中去，这时候可以搞点实战案例来学习。 如果对你有帮助的话，点个赞收个藏，给作者一个鼓励。也方便你下次能够快速查找。
如有不懂还要咨询下方小卡片，博主也希望和志同道合的测试人员一起学习进步
在适当的年龄，选择适当的岗位，尽量去发挥好自己的优势。
我的自动化测试开发之路，一路走来都离不每个阶段的计划，因为自己喜欢规划和总结，
测试开发视频教程、学习笔记领取传送门！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb69c5008a70aa33128cda527615081f/" rel="bookmark">
			iptables访问规则
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		--dport:目标端口 --sport:源端口 -d:目标ip -s:源ip -A:添加一条INPUT的规则(添加现有规则后面) -I:添加一条INPUT的规则(添加现有规则前面) -j:指定ACCEPT或DROP -p:协议 -m iprange： -m 添加模块iprange,可同时设置多个ip或者连续ip段 iprange模块指定连续的ip地址范围 --src-range：源地址范围 --dst-range：目标地址范围 1.只允许指定ip、端口访问 单独ip： iptables -I INPUT -p tcp --dport 9090 -j DROP iptables -I INPUT -s 192.168.1.1 -p tcp --dport 9090 -j ACCEPT #只允许192.168.1.1访问本机的9090端口 连续ip段： iptables -I INPUT -p tcp --dport 9090 -j DROP iptables -I INPUT -m iprange --src-range 192.168.1.1-192.168.1.5 -j ACCEPT #只允许192.168.1.1-192.168.1.5访问本机的9090端口 #允许192.168.1.1和192.168.1.5访问本机的3306和8080端口 #添加多ip时使用逗号分开 #添加多端口时使用"-m multiport"然后使用逗号分隔 iptables -I INPUT -s 192.168.1.1,192.168.1.5 -p tcp -m multiport --dport 3306,8080 -j ACCEPT 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb69c5008a70aa33128cda527615081f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34a7a188a98b73bdc0b3a04acc11631f/" rel="bookmark">
			AI算法相关就业向学习（算法、部署、加速）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 整个文章内容是在微信公众号oldpan播客中的原创文章进行的笔记总结和个人感悟
本人本科通信，研究生是cv医学影像方向，初识算法模型相关还是在本科参加数学建模，那个时候用matlab实现最简单的机器学习方法解决的问题，后来研究生开始了解深度学习和CV相关的知识和代码，整个学习过程也不是很系统，很多问题也是一知半解，到现在做算法工作，发现AI整个方向有太多不我了解的，某天看到了老潘的文章，首先普及了我很多基础知识和词条，也能很清晰的指清楚学习的方向。
CV 深度学习 最初的学习是导师给我们的学习课程，《TensorFlow实战Google深度学习框架》。其实那各时候大多代码都是pytorch了，tf用得比较少了，刚开始学习我因为tf和pytorch得差异晕了好一阵。不过技术更迭，跟着大波走总是没错的。最近，pytorch重写SAM代码，使代码速度比原始实现快 8 倍，而且没有损失准确性。更加坚定了我pytorch的选择。
不过归根结底，不论是Pytorch还是TensorFlow都只是你学习的一个工具，而且这俩库都很牛逼，哪个你用的舒服，就用哪个就对了。不顺手就扔掉，只不过现在tf1还是tf2可能都没有Pytorch顺手，所以用Pytorch上手的人更多，更有甚者，import torch as tf
深度学习资料：
《周志华的机器学习》《机器学习实战》《深度学习》（大家熟知的圣经）吴恩达的机器学习课 (个人非常推荐)CS231n （也很推荐）OpenCV系列（星云大佬、OpenCV3官方文档）C++各种乱七八槽的书（primer、effective、more effective）图像处理相关的书 算法工程师的流程与方向（个人向） 在学校主要精力都在构建模型算法提点和发论文上，没有涉及到过实际场景应用和部署相关内容，在工作之后有很多欠缺需要弥补的。工作后，模型算法只是落地的一个步骤，针对各种场景训练模型需要多个步骤，我总结了一下，大致分为以下：
预研确定项目需求数据收集和标注模型选择和优化模型部署及硬件优化 当然，这些步骤是需要在某些步骤之间根据效果和需求，进行及时的调整的，并非能够完美的完成一个步骤而进入下一个步骤。
预研确定项目需求 不同的项目产品，有各种合理和不合理需求，我们根据项目方向进行竞品调查和方法预研。竞品调查就是针对这些需求进行市面上的产品在功能、效果和实现可行性上进行分析，方法预研就是检索目前能够实现这些方法的各种文献。
关于竞品调查，首先要熟悉所在行业市场，并了解行业top的产品和最新动向，最好能结实行业top内伙伴是最好的；
其次，方法的预研最好是先通过专利进行一波初筛，同时也能够了解行业top的技术路线，然后根据最新的论文去弥补在细节方法上的不足。
数据收集和标注 相较于自然图像，医学图像收集是比较困难且质量参差不齐的，所以数据的整理和清洗是非常有必要的。但是这些都可以建立自己的脚本库来实现。
数据标注就是各显神通了，目前有很多基于Segment Anything Model的标注软件，在检测和分割上都有很好的效果（如果需要可以私我）。
数据的收集整理和标注是很耗时的，因为数据量多少、数据质量和标注质量的好坏都会对后续模型训练和泛化有很大的影响。认真把这步做好，后面都会提效。
模型选择和优化 模型环境：重复的配环境是很耗费时间的，所以在一次配完后可以用docker
模型训练：主要涉及到调参、实验结果分析，小问题可以通过loss和模型的小改动实现，大问题就需要再去找更SOTA的模型了。
其实这阶段只要有经验了不会太耗费时间，主要还是要不断学习，了解最新的论文和方向，在遇到问题时才能有更好的解决方法。根据目前结果寻求产品反馈，后续大部分都是一些性能的优化了。
在研究生阶段，能做到的也就是到这一步了，开发新的算法都是那些大佬和研究院的工作，对于迫切落地的企业来说，在目前情况下能够尽快跑通的项目才有价值。尤其是在医学领域，有些任务连医生完成都很困难，更何况算法呢？0-50的任务就直接可以pass了，50-90的才有改进的空间，90+再从算法上提升还不如考虑一下硬件。当初找工作，我以为自己就是收集收集数据，调调模型参数的日子里了，但刚进入岗位就给不怎么会C++的我重磅一击。
（剩下内容学习中，会更新的~）
模型部署 AI编译器 硬件底层 就业方向 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30a988977c79acd47e8ff9f8f7eada46/" rel="bookmark">
			基于ERC20代币协议实现的去中心化应用平台
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 内容简介设计逻辑ERC20TokenLoanPlatform 合约事件结构体状态变量函数 Remix 运行实现部署相关智能合约存款和取款贷款和还款 源码地址 内容简介 使用 solidity 实现的基于 ERC20 代币协议的借贷款去中心化应用平台(极简版)。实现存款、取款、贷款、还款以及利息计算的功能。
设计逻辑 平台提供ERC20协议代币的相关存取和利息计算工作。部署智能合约时初始化贷款和存款的年利率、代币实现地址。用户可以将手中的代币存入平台，等到一定的期限再次拿出获得本金加利息。也可以向平台申请代币，在一定的期限之后自主还款即可。 ERC20TokenLoanPlatform 合约 事件 合约包含4个事件，包括 Deposit 存款、Withdrawal 取款、CreateLoan 贷款、PayLoan 还款。
// SPDX-License-Identifier: MIT pragma solidity ^0.8.4; import "erc-token-standard/ERC/IERC20.sol"; // 基于ERC20代币协议的借贷款平台 contract ERC20TokenLoanPlatform { event Deposit(address depositor, uint amount ,uint DepositTime); event Withdrawal(address payee, uint amount, uint WithdrawalTime); event CreateLoan(address loanAddress, uint amount, uint interest, uint CreateLoanTime); event PayLoan(address loanAddress, uint amount, bool total, uint PayLoanTime); 结构体 合约包含2个结构体， 包括 Client 客户信息、Loan 贷款信息。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/30a988977c79acd47e8ff9f8f7eada46/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/910fdd158f6970c3dea60cce4ffb84ed/" rel="bookmark">
			uniapp websocket 封装断线重连
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.新建一个工具类js文件
2. 把我封装的代码复制进去
//引入vuex,因为我需要使用vuex存储得到的数据 import store from "@/store/index.js" // 连接 let socketTask = null // 是否主动关闭连接 let meClose = false // 地址 写你的后端连接地址 let url = "ws://192.168.1.2:8888/ws/" let token = null // 重连定时器 let Time = null // 心跳定时器 let XTime = null // 开启连接 const sokcet = () =&gt; { // 我这个项目需要在连接的时候带token，不需要可以只写url地址 token = uni.getStorageSync("token") //token // console.log(url + token); //判断是否有websocet对象，有的话清空 if (socketTask) { uni.closeSocket() socketTask = null; } // 进行连接 socketTask = uni.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/910fdd158f6970c3dea60cce4ffb84ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17d538c9a24929251bb62b858465c5a0/" rel="bookmark">
			C#中的流程控制语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		流程控制语句：分支语句、迭代语句、跳转语句三类
1、分支语句 1.1 if语句 Console.WriteLine("请输入数值，判断它与10的关系："); int a = int.Parse(Console.ReadLine()); //int.Parse用于将屏幕输入的语句转换为整型 if(a&lt;10){ Console.WriteLine("a小于10"); } else if(a==10){ Console.WriteLine("a等于10"); } else{ Console.WriteLine("a大于10"); } Console.ReadKey(); Console.WriteLine("请输入1-7判断是星期几："); int week = int.Parse(Console.ReadLine()); //int.Parse用于将屏幕输入的语句转换为整型 if(week == 1) Console.WriteLine("星期一"); if(week == 2) Console.WriteLine("星期二"); if(week == 3) Console.WriteLine("星期三"); if(week == 4) Console.WriteLine("星期四"); if(week == 5) Console.WriteLine("星期五"); if(week == 6) Console.WriteLine("星期六"); if(week == 7) Console.WriteLine("星期日"); Console.ReadKey(); 1.2 switch语句 Console.WriteLine("请输入1-7判断是星期几："); int week = int.Parse(Console.ReadLine()); //int.Parse用于将屏幕输入的语句转换为整型 switch(week){ case 1:Console.WriteLine("星期一");berak; case 2:Console.WriteLine("星期二");berak; case 3:Console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/17d538c9a24929251bb62b858465c5a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5b99e2d7d3fe748b1aa67a62078bec9/" rel="bookmark">
			大创项目推荐 深度学习&#43;python&#43;opencv实现动物识别 - 图像识别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 0 前言1 课题背景2 实现效果3 卷积神经网络3.1卷积层3.2 池化层3.3 激活函数：3.4 全连接层3.5 使用tensorflow中keras模块实现卷积神经网络 4 inception_v3网络5 最后 0 前言 🔥 优质竞赛项目系列，今天要分享的是
🚩 **基于深度学习的动物识别算法 **
该项目较为新颖，适合作为竞赛课题方向，学长非常推荐！
🥇学长这里给一个题目综合评分(每项满分5分)
难度系数：3分工作量：3分创新点：3分 🧿 更多资料, 项目分享：
https://gitee.com/dancheng-senior/postgraduate
1 课题背景 利用深度学习对野生动物进行自动识别分类,可以大大提高野生动物监测效率,为野生动物保护策略的制定提供可靠的数据支持。但是目前野生动物的自动识别仍面临着监测图像背景信息复杂、质量低造成的识别准确率低的问题,影响了深度学习技术在野生动物保护领域的应用落地。为了实现高准确率的野生动物自动识别，本项目基于卷积神经网络实现图像动物识别。
2 实现效果 3 卷积神经网络 受到人类大脑神经突触结构相互连接的模式启发，神经网络作为人工智能领域的重要组成部分，通过分布式的方法处理信息，可以解决复杂的非线性问题，从构造方面来看，主要包括输入层、隐藏层、输出层三大组成结构。每一个节点被称为一个神经元，存在着对应的权重参数，部分神经元存在偏置，当输入数据ｘ进入后，对于经过的神经元都会进行类似于：y＝w*x＋b的线性函数的计算，其中ｗ为该位置神经元的权值，b则为偏置函数。通过每一层神经元的逻辑运算，将结果输入至最后一层的激活函数，最后得到输出output。
3.1卷积层 卷积核相当于一个滑动窗口，示意图中３x３大小的卷积核依次划过６x６大小的输入数据中的对应区域，并与卷积核滑过区域做矩阵点乘，将所得结果依次填入对应位置即可得到右侧４x４尺寸的卷积特征图，例如划到右上角３x３所圈区域时，将进行０x０＋１x１＋２x１＋１x１＋０x０＋１x１＋１x０＋２x０x１x１＝６的计算操作，并将得到的数值填充到卷积特征的右上角。
3.2 池化层 池化操作又称为降采样，提取网络主要特征可以在达到空间不变性的效果同时，有效地减少网络参数，因而简化网络计算复杂度，防止过拟合现象的出现。在实际操作中经常使用最大池化或平均池化两种方式，如下图所示。虽然池化操作可以有效的降低参数数量，但过度池化也会导致一些图片细节的丢失，因此在搭建网络时要根据实际情况来调整池化操作。
3.3 激活函数： 激活函数大致分为两种，在卷积神经网络的发展前期，使用较为传统的饱和激活函数，主要包括sigmoid函数、tanh函数等；随着神经网络的发展，研宄者们发现了饱和激活函数的弱点，并针对其存在的潜在问题，研宄了非饱和激活函数，其主要含有ReLU函数及其函数变体
3.4 全连接层 在整个网络结构中起到“分类器”的作用，经过前面卷积层、池化层、激活函数层之后，网络己经对输入图片的原始数据进行特征提取，并将其映射到隐藏特征空间，全连接层将负责将学习到的特征从隐藏特征空间映射到样本标记空间，一般包括提取到的特征在图片上的位置信息以及特征所属类别概率等。将隐藏特征空间的信息具象化，也是图像处理当中的重要一环。
3.5 使用tensorflow中keras模块实现卷积神经网络 ​
class CNN(tf.keras.Model): def __init__(self): super().__init__() self.conv1 = tf.keras.layers.Conv2D( filters=32, # 卷积层神经元（卷积核）数目 kernel_size=[5, 5], # 感受野大小 padding='same', # padding策略（vaild 或 same） activation=tf.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5b99e2d7d3fe748b1aa67a62078bec9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45da98781efb5c746152986687063151/" rel="bookmark">
			11-网络安全框架及模型-软件安全能力成熟度模型（SSCMM）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
软件安全能力成熟度模型
1 背景概述
2 主要内容
3 成熟度等级定义
4 关键过程和实践
5 评估方法
6 改进建议
7 持续改进
8 主要价值
9 应用场景
10 优势和局限性
备注
软件安全能力成熟度模型 1 背景概述 SSCMM模型是软件安全能力成熟度模型，它描述了一个组织中为确保优质安全工程而必须具备的安全工程过程的基本特性。该模型没有规定具体的过程或顺序，而是汇集了在行业中普遍遵循的实践。
SSCMM模型诞生于一个对软件安全性和质量越来越重视的时代。在软件工程领域，保证软件产品的安全性和质量已经成为一项至关重要的任务。因此，许多组织和研究机构都在努力研究和开发新的方法和技术，以帮助开发人员更好地管理和提高软件的安全性和质量。
SSCMM模型的出现，是为了提供一个框架和指导，帮助组织评估和提高软件安全能力。该模型提供了一个可重复使用的框架，组织可以使用这个框架来评估和改进他们的软件安全流程和实践。此外，SSCMM模型还可以帮助组织更好地了解他们当前的安全状况，识别潜在的安全风险，并采取适当的措施来缓解这些风险。
总之，SSCMM模型的诞生是为了帮助组织评估和提高软件安全能力，以确保软件产品的安全性和质量。
2 主要内容 软件安全能力成熟度模型（SSCMM）的主要内容是围绕软件安全能力的评估和提升而展开的。该模型将软件安全能力划分为不同的成熟度等级，并为每个等级定义了一系列的关键过程和实践。
以下是SSCMM模型的主要内容：
成熟度等级定义：SSCMM模型定义了多个成熟度等级，每个等级代表了组织在软件安全能力方面的不同阶段和水平。这些等级通常包括初始级、可重复级、定义级、管理级和优化级等。
关键过程和实践：对于每个成熟度等级，SSCMM模型定义了一系列的关键过程和实践，这些过程和实践是组织在该等级下需要关注和实施的重要活动。这些关键过程和实践涵盖了组织建设、制度流程、技术工具和人员能力等方面。
评估方法：SSCMM模型提供了一套评估方法，用于评估组织的软件安全能力成熟度等级。这些评估方法通常包括文档审查、访谈、观察和实践验证等，以收集和分析相关数据，确定组织的成熟度等级。
改进建议：根据评估结果，SSCMM模型提供针对性的改进建议，帮助组织提升其软件安全能力。这些改进建议可能涉及组织结构的调整、流程的优化、技术工具的采用和人员能力的提升等方面。
持续改进：SSCMM模型强调持续改进的重要性，鼓励组织在达到某个成熟度等级后，继续努力提升软件安全能力，追求更高的成熟度等级。
总之，SSCMM模型的主要内容是帮助组织评估和提升软件安全能力，通过定义成熟度等级、关键过程和实践，以及提供评估方法和改进建议，引导组织逐步提高软件安全性的水平。
3 成熟度等级定义 软件安全能力成熟度模型（SSCMM）的成熟度等级主要分为五级，包括初始级、可重复级、已定义级、已管理级和优化级。
初始级(Initial)：工作无序，项目进行过程中常放弃当初的计划。管理无章法，缺乏健全的管理制度。开发项目成效不稳定，项目成功主要依靠项目负责人的经验和能力，他一但离去，工作秩序面目全非。
可重复级(Repeatable)：管理制度化，建立了基本的管理制度和规程，管理工作有章可循。初步实现标准化，开发工作比较好地按标准实施。变更依法进行，做到基线化，稳定可跟踪，新项目的计划和管理基于过去的实践经验，具有重复以前成功项目的环境和条件。
已定义级(Defined)：已将软件管理和工程两方面的过程文档化、标准化，并综合成该组织的标准软件过程。所有项目均使用经批准、剪裁的标准软件过程来开发和维护软件，软件产品的生产在整个软件过程是可见的。
已管理级(Managed)：产品和过程已建立了定量的质量目标。已建立过程数据库。可预测过程和产品质量趋势，如预测偏差，实现及时纠正。
优化级(Optimizing)：过程的量化反馈和先进的新思想、新技术促使过程持续不断改进。
4 关键过程和实践 软件安全能力成熟度模型的关键过程和实践主要包括以下几个方面：
安全管理：这是确保软件安全性的基础，包括建立安全策略、制定安全规章制度、进行安全培训等。通过安全管理，可以确保所有员工都了解并遵守安全规定，从而减少安全风险。
风险评估：对软件系统进行全面的风险评估，识别潜在的安全威胁和漏洞。这包括对系统架构、功能模块、数据传输等方面的分析，以及利用漏洞扫描工具进行测试。
安全编码：在软件开发过程中，采用安全编码实践，避免常见的安全漏洞。这包括输入验证、输出编码、参数化查询等，以防止SQL注入、跨站脚本攻击等常见攻击。
渗透测试：通过模拟黑客攻击，对软件系统进行渗透测试，以发现潜在的安全漏洞。渗透测试可以帮助开发团队了解系统的脆弱性，并及时修复漏洞。
安全审计：定期对软件系统进行安全审计，检查系统的安全性是否符合预期。这包括检查安全策略的执行情况、安全漏洞的修复情况等。
应急响应：建立应急响应机制，当发生安全事件时，能够迅速响应并采取措施防止事件扩大。这包括制定应急预案、建立应急响应团队、进行模拟演练等。
这些关键过程和实践可以帮助组织提高软件的安全性，减少潜在的安全风险。同时，这些过程也需要持续的改进和优化，以适应不断变化的网络安全环境。
5 评估方法 软件安全能力成熟度模型的评估方法主要包括以下几个步骤：
准备工作：首先，评估团队需要了解被评估组织的软件安全能力成熟度模型的应用情况，包括其组织结构、流程、技术工具和人员能力等方面。
文档审查：评估团队会对被评估组织的文档进行审查，包括软件开发过程中的各种文档，如需求文档、设计文档、测试文档等。通过文档审查，评估团队可以了解被评估组织的软件开发过程和安全实践。
员工培训：评估团队会对被评估组织的员工进行培训，让他们了解软件安全能力成熟度模型的相关知识和评估方法。员工培训可以帮助员工更好地理解评估过程和结果，并促进他们在未来的工作中改进软件安全能力。
问卷调查和统计：评估团队会向被评估组织的员工发放问卷，了解他们对软件安全能力成熟度模型的理解和应用情况。同时，评估团队还会对问卷结果进行统计和分析，以了解被评估组织的整体情况。
数据分析：评估团队会对收集到的数据进行深入的分析，包括软件开发过程中的各种数据，如缺陷数量、漏洞数量、安全事件数量等。通过数据分析，评估团队可以了解被评估组织的软件安全状况和问题。
与企业的高层领导讨论：评估团队会与被评估组织的高层领导进行讨论，了解他们对软件安全能力成熟度模型的理解和应用情况，以及他们对未来改进的期望和建议。
撰写评估报告：最后，评估团队会撰写评估报告，对被评估组织的软件安全能力成熟度模型的应用情况进行总结和分析，并提出改进建议。
通过以上步骤，评估团队可以对被评估组织的软件安全能力成熟度模型进行全面的评估，并为其提供针对性的改进建议，以提升其软件安全能力。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/45da98781efb5c746152986687063151/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/190dd3b4ff2a2d4afe77373f78d90468/" rel="bookmark">
			寒冬里的互联网行业，寒冬里的程序员
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前言 今年虽说是 AI 之年，但也是国内互联网行业惨淡的一年，这又到年底了，各种裁员消息在大厂纷纷传出。字节的游戏业务部门裁撤算是比较大的新闻了。怎么来评价当前的这种情况呢，未来该怎么样对待呢？今天咱们就来好好唠唠吧！！
互联网现状 首先，移动互联网的发展已经过了高速期，一下子放缓了，原来都是成指数的增长，突然间不涨了，那么资本就会收缩，所以降本增效这个词今年也比较火，也比较正常，作为一个老板降本增效肯定是正常的，高速发展期钱多花点无所谓。
但是一旦发展没那么快了，必然要求稳了，不能把公司玩死了，用我们老板的话，我们要珍惜手中的美金。现在国内互联网公司基本都是头部的那几个，中小公司都是勉强活着。做海外业务的今年有一波。
招聘岗位不给力 从招聘角度分析下，今年招聘真的是很少，但是应聘的人很多。从这一点来看，对程序员不是什么好事，公司可以优中选优，但是由于这些年互联网高速发展，程序员更是参差不齐，还有就是大龄程序员基本没什么优势了，基本筛简历就 pass 了。那么该怎么办呢？
我觉得可能对程序员来说是好事吧，在一线城市飘着就为了那份高薪的工作，当这个没有了的话，必然导致待不下去了，城市降级也是可能的。
对于大龄程序员这个说实话我觉得国内的互联网公司真不太健康，35岁正是能干的时候，而且经验丰富，pass 掉了的真可惜。
我觉得从我的角度来讲，未来我是不推荐年轻的孩子干这一行了，当然非常优秀的另算。干十年身体累废了，然后没赚钱还得另谋出路，太让人有压力了。还不如好好考个公务员呢，没必要到30多岁再想上岸。
技术储备 技术行业变化迅速，每年都有新的编程语言、框架和工具出现，然后长期不更新自己的技术知识，就会导致技术落后从而增加被淘汰的风险。
后端目前分为 java go c++ 等，前端基本就是js，客户端目前java kotlin oc swift flutter 都得会。目前华为鸿蒙也出来了，这远比我刚入行的时候卷多了。
最后 互联网行业的竞争激烈程度不容小觑，程序员们应时刻保持技术的学习和更新，持续提升自己的能力。在技术迅速发展的时代，只有不断学习和跟进，才能在竞争中立于不败之地。年轻程序员也需要关注积累工作经验和提升创造力，这将是他们在职业发展中的竞争优势。
职场如战场，我们每个人都是战士。在这个卷的时代里，想要不被淘汰，就要学会不断提升自己，善用身边的资源。只有这样，我们才能在35岁的职场分水岭上，笑对挑战，活出自己的色彩。
感谢你们的阅读和喜欢，我收藏了很多技术干货，可以共享给喜欢我文章的朋友们，如果你肯花时间沉下心去学习，它们一定能帮到你。
因为这个行业不同于其他行业，知识体系实在是过于庞大，知识更新也非常快。作为一个普通人，无法全部学完，所以我们在提升技术的时候，首先需要明确一个目标，然后制定好完整的计划，同时找到好的学习方法，这样才能更快的提升自己。
一、Android所有方向的学习路线 为了成为更好的 Android 开发者，这里为大家提供了总的路线图。它的用处就在于，你可以按照上面的知识点去找对应的学习资源，保证自己学得较为全面。如果下面这个学习路线能帮助大家成为一个更好的 Android 开发者，那么我的使命也就完成了：
包括：Android应用开发、系统开发、音视频开发、Flutter开发、小程序开发、UI界面、车载系统开发等等
二、学习软件 工欲善其事必先利其器。学习Android常用的Android Studio视频教程和Android Studio最新的安装包都在这里了，给大家节省了很多时间。
三、进阶学习视频 我们在学习的时候，往往书籍源码难以理解，阅读困难，这时候视频教程教程是就很适合了，生动形象加上案例实战，科学有趣才能更方便的学习下去。
四、实战案例 光学理论是没用的，要学会跟着一起敲，要动手实操，才能将自己的所学运用到实际当中去，这时候可以搞点实战案例来学习。
五、经典书籍阅读 阅读Android经典书籍可以帮助读者提高技术水平，开拓视野，掌握核心技术，提高解决问题的能力，同时也可以借鉴他人的经验。对于想要深入学习Android开发的读者来说，阅读Android经典书籍是非常有必要的。
六、面试资料 我们学习Android必然是为了找到高薪的工作，下面这些面试题是来自阿里、腾讯、字节等一线互联网大厂最新的面试资料，并且有阿里大佬给出了权威的解答，刷完这一套面试资料相信大家都能找到满意的工作。
这份完整版的Android全套学习资料已经上传CSDN，朋友们如果需要可以微信扫描下方CSDN官方认证二维码免费领取【保证100%免费】 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5bd1d69d6e599fd54bcf2e618847e8c6/" rel="bookmark">
			(安卓扫码)uniapp中使用智能终端扫描仪
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		直接上代码
&lt;script&gt; var main = plus.android.runtimeMainActivity(); var receiver; export default { onLoad() { this.registerBroadcast() plus.key.addEventListener("keydown", function(e) { console.log(urovoPlatformModule) if (e.keyCode == 520 || e.keyCode == 523) { console.log("扫描按键触发，键值为 " + e.keyCode); }else{ console.log("按键触发，键值为 " + e.keyCode); } }) }, methods:{ registerBroadcast() { console.log('注册扫描广播') receiver = plus.android.implements('io.dcloud.feature.internal.reflect.BroadcastReceiver', { onReceive: doReceive }); var that = this; var IntentFilter = plus.android.importClass('android.content.IntentFilter'); var filter = new IntentFilter(); filter.addAction( "android.intent.ACTION_DECODE_DATA"); //监听扫描广播“urovo.rcv.message” //android.intent.ACTION_DECODE_DATA main.registerReceiver(receiver, filter); //注册监听 function doReceive(context, intent) { plus.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5bd1d69d6e599fd54bcf2e618847e8c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91327a892bc87b4d9f810d6525e783c2/" rel="bookmark">
			关于Android图像Bitmap类你要知道的一切
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Bitmap介绍 Bitmap是一种图像文件格式，它由像素阵列组成，每个像素都有自己的颜色信息。在计算机图形学中，Bitmap图像可以被描述为一个二维的矩阵，其中每个元素代表一个像素的颜色值。
Android中的Bitmap是用来表示图像的类，它可以用来加载、显示和处理图像。你可以通过Bitmap类来创建一个图像对象，然后在屏幕上显示或者对其进行进一步的处理。
以下是一个ImageView显示Bitmap对象示例：
// 从资源文件中加载一张图片到Bitmap对象 Bitmap bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.image); // 将Bitmap对象显示在ImageView中 ImageView imageView = (ImageView) findViewById(R.id.imageView); imageView.setImageBitmap(bitmap); 除了加载和显示图像外，Bitmap还提供了一些方法来对图像进行操作，比如缩放、裁剪、旋转等。同时，Bitmap也可以用来处理图像的像素数据，进行像素级的操作。
需要注意的是，Bitmap对象在内存中占用的空间较大，因此在使用过程中需要注意内存的管理，避免出现内存溢出的情况。
Bitmap颜色通道 在Android中，Bitmap的颜色通道通常是以ARGB（Alpha、Red、Green、Blue）的顺序存储的。每个通道通常占据8位，即一个字节，取值范围为0-255。这种存储方式被称为32位色深（每个像素占32位）。
具体来说，ARGB的存储方式如下：
Alpha通道：用于表示像素的透明度，0表示完全透明，255表示完全不透明。Red通道：表示红色分量的强度。Green通道：表示绿色分量的强度。Blue通道：表示蓝色分量的强度。 在内存中，Bitmap的像素通常是按行存储的，每个像素占用4个字节，分别对应ARGB四个通道，即每个像素占32位。
Bitmap占用内存大小计算 在Android中，可以通过以下公式来计算一个Bitmap占用的内存大小：
[ 大小（字节） = 宽度 × 高度 × 每个像素占用的字节数 ]
其中，每个像素占用的字节数取决于Bitmap的配置。常见的配置包括：
ARGB_8888：每个像素占用4个字节（一个字节用于Alpha通道，每个RGB通道各占用1个字节）RGB_565：每个像素占用2个字节（5位用于红色，6位用于绿色，5位用于蓝色） 因此，如果你有一个宽度为w，高度为h的ARGB_8888格式的Bitmap，那么它占用的内存大小为：
[ w \times h \times 4 ]
如果是RGB_565格式的Bitmap，则占用的内存大小为：
[ w \times h \times 2 ]
需要注意的是，这只是Bitmap本身占用的内存大小，实际上在Android中，Bitmap还会占用一定的额外内存，比如Bitmap的配置信息、像素数据等。
Bitmap使用 在Android中，可以使用Bitmap类来处理图像。Bitmap类可以用于加载、显示、保存和处理图像等。
可以使用以下方法来加载Bitmap：
从资源文件中加载Bitmap： Bitmap bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.image); 从文件中加载Bitmap： Bitmap bitmap = BitmapFactory.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91327a892bc87b4d9f810d6525e783c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3c168350634fcdef7d249118bbfbfce/" rel="bookmark">
			Vue开发实践：解决Chrome浏览器禁止通过代码关闭窗口的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在开发 Electron 桌面端应用时，软件有一个退出软件的按钮，用于关闭应用程序。然而，在实现这一功能的过程中，我们可能会遇到一些问题。本文将探讨这个问题，并给出解决方案。 实现 询问负责 Electron 的同学，得知直接关闭当前窗口就行。
没有花多少时间去思考，第一时间赶到的代码是 window.close();
但是实际运行一下发现并没有关闭窗口，打开控制栏发现警告 " 只能关闭由代码打开的窗口 "：
这是因为 Chrome 浏览器的安全限制，window.close() 方法只能在通过 window.open() 方法或脚本创建的窗口中调用。这意味着我们只能关闭由 JavaScript 打开的窗口或标签页。
解决原理 网上查询了下相关解决方法，发现解决方案都是： 通过 JavaScript 打开一个新窗口到自身，新窗口（具有"由 JavaScript 创建"属性）会覆盖原来的窗口（不具有 "由 JavaScript 创建"属性），然后再执行 window.close() 即可关闭窗口。
以下是各种方法汇总：
序号关闭代码需要确认无任何作用无需确认测试1window.close()IE7firefox,chrome, safariOperaClose2window.opener=null; window.open('','_self'); window.close();firefoxIE7,Opera， chrome,safariClose3window.open('','_self'); window.close();firefoxIE7,Opera， chrome,safariClose4window.opener=null; window.close();IE7firefox，safarichrome,OperaClose5const opened=window.open('about:blank','_self'); opened.opener=null; opened.close();firefoxsafari,IE7, chrome,OperaClose6const opened=window.open('about:blank','_self'); opened.close();safari,firefoxfirefox，IE7, chrome,OperaClose 但是经过我的测试，以上统统只能跳转到空白页，并没有实现关闭窗口！
问题原因 偶然的，我发现在首页（此时 history 栈只有当前页记录）点击关闭软件按钮可以完美的实现功能，一旦进入软件，再返回首页点击关闭软件按钮就只能跳转到空白页。那么问题就出在历史记录上面，查阅发现是因为 Chrome 浏览器为了保护用户数据的安全，不允许直接关闭包含历史记录的窗口。历史记录是用户在浏览器中浏览过的网页记录，如果允许直接关闭窗口，可能会导致用户丢失未保存的浏览数据，或者导致误操作关闭了包含重要信息的窗口。
那么我们知道是因为存在历史记录导致我们的代码无法正确执行，那么让历史记录一直为空就好了，参考我之前写的 Element UI导航菜单之秘：无痕迹浏览与历史记录栈的管理 ，将项目内所有路由跳转从 push 修改为 replace 模式，这样 history 栈就会一直为当前页对应记录，就不会影响到我们关闭窗口了。
解决方案 通过 JavaScript 打开一个新窗口到自身，新窗口（具有"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c3c168350634fcdef7d249118bbfbfce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aeb0e3de13e16fbec8a0b23f0ab5a428/" rel="bookmark">
			llama大模型部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		看模型加载的参数设置.
import torch # 初始化Half Tensor h = torch.tensor([1.0,2.0,3.0], dtype=torch.half) # h = torch.tensor([1.0,2.0,3.0], dtype=torch.float16) # 跟上面一行一样. # 查看数据类型 print(h.dtype) import accelerate import bitsandbytes from transformers import AutoTokenizer, AutoModelForCausalLM,TextIteratorStreamer from transformers import AlbertTokenizer, AlbertModel model = AlbertModel.from_pretrained('./albert',device_map='auto',torch_dtype=torch.float16,load_in_8bit=True,low_cpu_mem_usage=True) # torch_dtype 模型本身的类型, 不写的话就自己根据权重文件查询出来.这个是权重文件本身决定的,一般在config.json里面 # load_in_8bit 会把模型转化为8bit类型.这个可以自己设置. print(1) low_cpu_mem_usage algorithm:
This is an experimental function that loads the model using ~1x model size CPU memory Here is how it works: 1. save which state_dict keys we have 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aeb0e3de13e16fbec8a0b23f0ab5a428/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/431c648a206d628e4ce43919b8a64d2d/" rel="bookmark">
			函数柯里化(Currying) 函数反柯里化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		函数柯里化(Currying) 函数反柯里化
1）柯里化是一种关于函数的高阶段技术。他不仅被用于JavaScript,还被用于其他编程语言。
2）柯里化是一种函数转换，他是将一个函数从可调用的f(a,b,c)转换为可调用的f(a)(b)©
柯里化不会调用函数。他只是对函数进行转换
判断变量的类型 常用的判断类型的方法有四种：
1.typeof 不能判断对象类型 typeof [] typeof {}
2.constructor 可以找到这个变量是通过谁构造出来的
3.instanceof 判断谁是谁的实例 proto
4.Object.prototype.toString.call() 缺陷就是不能细分是谁的实例
function isType(type, value) { return Object.prototype.toString.call(value) === `[object ${type}]`; } //实现通用的函数柯里化方法 const currying = (fn, arr = []) =&gt; { let len = fn.length; // 这里获取的是函数的参数的个数 return function(...args) { // 高阶函数 let arr = [...arr, ...args]; if (arr.length &lt; len) { return currying(fn, arr); // 递归不停的产生函数 } else { return fn(.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/431c648a206d628e4ce43919b8a64d2d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f30a7b29cd658a8d7bcf768ab93a7ba9/" rel="bookmark">
			uniapp中如何使用百度tts生成文字语音并播放
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 第一步先在百度云里面申请一个tts应用，这里默认你们都会了哈，申请完是这样的
第二步在manifest.json注册一下
第三步进项目,先获取token
handleGetToken() { // client_id和client_secret就是百度API Key和Secret Key uni.request({ url: 'https://aip.baidubce.com/oauth/2.0/token?grant_type=client_credentials&amp;client_id=&amp;client_secret=', method: 'POST', success: (res) =&gt; { this.token = res.data.access_token } }); }, 第四步生成语音
// str就是你想转化成语音的文字,token就是你刚刚保存的token const src = `https://tsn.baidu.com/text2audio?lan=zh&amp;ctp=1&amp;cuid=abcdggg&amp;tok=${this.token}&amp;tex=${str}&amp;vol=5&amp;per=0&amp;spd=5&amp;pit=5&amp;aue=3`; 第五步开始播放
const innerAudioContext = uni.createInnerAudioContext(); innerAudioContext.src = src; innerAudioContext.stop(); innerAudioContext.play(); innerAudioContext.onError((res) =&gt; { console.log("InnerAudioContext() errCode:" + res.errCode + " errMsg:" + res.errMsg); }); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc00ffe99091b5cc23712ccd6a76597b/" rel="bookmark">
			如何学习英语
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 首先写一些自己的感言吧，其实从大学的时候就在不断地听英语，学英语，但是到毕业十几年后，英语一直没起到什么作用，当然最有作用的时候就是几次英语面试吧。
工作之后有一段学习英语的经历，当时花费了很多时间看了一些英文名著，听了很多英文有声小说，感觉这应该是自己最大的积累吧，后来还特么学习一下发音。
现在重新要捡起来是因为后期工作中大概率要用得上，不要到时候真的用的时候发现晚了。因为我觉得抗35岁的另外一个就是去外企。哈哈
学习英语这十几年来最大的一次改进应该是几年前的时候，当时下载了四五本英语名著的音频，然后看着书跟着音频听了几遍，估计有500多个小时，因为这500多个小时，后来基本上可以大概能听懂油管上一些简单的视频，也就仅此而已，但是说来惭愧，这竟然是自己学习英语来收获最大的一次。
拿着这个底子，现在重新捡起来学英语就比以前好多了，可以直接在油管上打开字幕（english only ）基本可以实现通过英语学习英语了。
总结以前学习英语都没有坚持下来，实在是太无聊了，每当听到那句“listen to the dialog…balabal”头皮发麻，唯一听了500多小时的那次还是因为哈利波特那七本书，所以这次我改变策略，通过自己喜欢的内容来学习，特别是现在可以畅通无阻油管。
初步一个星期发现，效果明显，主要是在油管上找那些自己能听懂的，开字幕后基本就能理解90%的视频，这样既能学习到英语又不枯燥，哈哈，以前为什么没有发现这个好处。
所以现在以听为主，计划听300个小时后再说，当然中间穿插语法和句法学习。
20231216
第一天
20231217
第二天
20231218
第三天
20231219
第四天
前几天忘了写体会了，今天最大的体会是，学英语要从句子开始，我们知道一个句子的结构，剩下的就是填词，可能我们不知道很多词，但是句子机构记住后，什么样的场景表达不出来是不是。
文章目录 前言视频 视频 1.我是如何学好英语的 —— 10年+学习全记录
这里视频中作者分享了几个观点：
1.不要以为在一个英语环境就能很快的学习英语，作者用亲身经历证明了不行，作者到东南亚留学几个月，发现效率还不如自己自学。
2.详细科学方法，很多时候自己折腾很久发现不行，大概率是方法不到位。
1.材料选择：哲学、历史、刷剧 （适合自己兴趣的，不需要每个单词都懂）
2.巨大的输入量（刷剧—看英文原本书，可理解输入）
3.重输入，再输出（看完，再复述）
4.语言习得源于输入
2.最火英语外教合集-整整70个小时-英语听力口语单词语法–Tiffani老师
3.最顶的纠音教程！
4.地道美音 美中小学精选课程
5.最好的英语口语老师Tiffany会带你走出低谷，重拾信心！！！【中英字幕
6.口语听力干货 English With Bob
7.英语核心口语句型9000句（合集 共151课）
8.英语单词口语听力课合集，从零开始学英语
9.从零开始学英语】跟洋妞学英语
10.再谈如何学习英语（为什么要建立以听力为主导的英语学习方式，以及如何轻松地突破英语听说读写）
11.[语法学习]
12.英语语法：本质就是“结构+修饰+时态”
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27f3845fd66586348ed11510d761a2b9/" rel="bookmark">
			大象机器人发布万元级水星Mercury人形机器人产品系列，联结未来，一触即达！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		十四五机器人产业发展规划指出机器人的研发、制造、应用是衡量一个国家科技创新和高端制造业水平的重要标志。当前，机器人产业蓬勃发展，正极大改变着人类生产和生活方式，为经济社会发展注入强劲动能。
人形机器人作为机器人产业中重要的一环，其有着独特的技术和功能，广泛应用于教育、科研、服务、娱乐和工业等领域，带来了前所未有的便利和效率。
2023年10月，工信部发布了《人形机器人创新发展指导意见》，报告中指出，机器人技术已有成熟的技术基础，以大模型等人工智能技术突破为引领，人形机器人技术加速演进，已成为科技竞争的新高地、未来产业的新赛道、经济发展的新引擎，发展潜力大、应用前景广。
结合大象机器人的产品布局与发展路径，公司正式发布万元级售价的水星Mercury人形机器人产品系列。 水星Mercury机器人系列共有三款产品：
水星Mercury A1 七轴协作机械臂
水星Mercury B1 半人形双臂机器人
水星Mercury X1 通用人形机器人
三款产品的工业设计皆由瑞典团队精心设计而成，集成七大机器人核心算法，多种使用与开发方式，旨在满足教育、科研、服务、娱乐和VR遥操作等五大应用场景的需求。
水星机器人产品家族：
水星Mercury A1
七轴协作机器人 水星Mercury A1是一款轻量级7自由度协作机器人，由7颗大象机器人自研谐波模组驱动；全新的七轴工业设计由瑞典团队精心操刀，整机使用超轻量碳纤维外壳，减重的同时大幅提高整机强度和刚性。
水星Mercury A1采用单主控，双副控控制方式。主控采用Cortext A72 - 1.5GHz、搭载2.0英寸IPS-LCD电容触摸屏，配合大象机器人自主开发的机器人便捷开发操作系统myPanel OS，可实现无需编程的快速部署应用。
水星Mercury B1
双七轴半人形机器人
水星Mercury B1双臂半人形机器人共拥有17个自由度，搭载两台A1七轴机械臂，具备单臂独立操作和双臂协同操作的能力；
头部搭载一块9英寸高清液晶显示触摸屏，支持多点操控及用户定制化表情显示；搭配NVIDIA Xavier主控芯片和四个独立副控进行控制。配合一体式3D摄像头，可以完成2D/3D机器视觉引导、抓取以及VR实现遥操作。
作为ChatGPT for Robotics最早适配的机器人品牌，Mercury B1内置了高清晰度麦克风阵列，支持实时语音采集，将带来AI语音智能识别交互的全新体验。
水星Mercury X1
通用人形机器人
水星Mercury X1轮式人形机器人共拥有19自由度，由水星Mercury B1和高性能移动底座组合而成。
整机配备英伟达Jetson Xavier和Jetson Nano双主控，上半身独立四个副控，下半身独立一个副控进行搭配控制。
移动底座配备高性能激光雷达，超声波传感器和2D视觉等丰富感知；采用直驱电机驱动，最大运行速度达1.2m/s； 最大爬坡高度2CM；最大爬坡角度15度。整机最大续航高达8小时，满足个人及商业应用的需求。
“
力源系列谐波模组，大扭矩轻自重，全新自研模组输出澎湃动力
水星机器人全系产品搭载大象机器人全新自研力源系列谐波模组。全新模块化设计模组标配电磁制动刹车，中空走线。具有高精度、高惯量、低自重等特点。
最大输出扭矩可达80Nm，编码器分辨率19Bit，重复定位精度高达0.6弧分。配合机械臂整机外壳采用的铝合金与碳纤维材质，进一步降低整机自重，优化动力表现。
“
强大算力加持
赋能具身智能新疆界
水星Mercury人形机器人B1,X1采用了全新英伟达Jetson Xavier边缘计算核心作为主控模组。
高达21TOPS 的 AI 性能使这些模组为处理视觉测距、传感器融合、定位和地图构建、障碍物检测和路径规划算法提供了强大的算力保障，为具身智能领域开发和应用创造无限可能。
尤其在克服VR遥操作技术难题的过程中，确保获取低延迟的视频流⼀直是关键挑战之⼀。
大象机器人采⽤了⼀项创新性的解决⽅案，即通过利⽤NVIDIA Xavier平台提供的Accelerated GStreamer插件，成功实现了GPU加速的视频编解码，在保障实时性的同时，最⼤程度地优化带宽利⽤率，为VR遥操作提供硬件加速。
“
七大集成算法
打造机器智能
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/27f3845fd66586348ed11510d761a2b9/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/31/">«</a>
	<span class="pagination__item pagination__item--current">32/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/33/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>