<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62e6bbb4c826a4b950c20c1a3d09521f/" rel="bookmark">
			Qt_QWidget窗体设置模态显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		QWidget是Qt中的窗口类，实现QWidget窗口显示有三个步骤。
1.实例化一个窗口类对象（类QWidget的对象可以是QWidget，也可以是QWidget的继承类）
QWidget* pW = new QWidget(NULL); 2.调用函数QWidget::setWindowsModality(Qt::WindowModality windowModality)设置窗口类型，其中Qt::WindowModality windowModality取值如下：
Qt::NonModal 不阻塞（非模态对话框）
Qt::WindowModal 阻塞父窗口，所有祖先窗口及其子窗口（半模态对话框）（没特殊要求的话，一般用这个）
Qt::ApplicationModal 阻塞整个应用程序（模态对话框）
3.调用函数QWidget::show()显示该窗口
QWidget设置模态显示，示例代码如下：
// 示例1 QWidget* pW = new QWidget(); pW-&gt;setWindowModality(Qt::ApplicationModal); pW-&gt;show(); // 示例2 QWidget* pW2 = new QWidget(this); pW2-&gt;setWindowModality(Qt::ApplicationModal); pW2-&gt;show(); 特别注意：如果要给QWidget窗体设置模态显示，就不能指定父对象。再上述示例中，示例1窗体模态显示，示例2不会显示。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c155f813d872060326879a4f402ddd8f/" rel="bookmark">
			密钥协商（密钥交换）机制的讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		国标文件涉及密钥协商算法的函数 生成密钥协商参数并输出计算会话密钥产生协商数据并且计算会话密钥 密钥协商（交换）算法及其原理 密钥交换/协商目的 “密钥协商机制”是：（在身份认证的前提下）规避【偷窥】的风险。通俗地说，即使有攻击者在偷窥客户端与服务器的网络传输，客户端（client）依然可以利用“密钥协商机制”与服务器端（server）协商出一个只有二者可知的用来对于应用层数据进行加密的密钥（也称“会话密钥”）。 密钥交换/协商机制的几种类型 1，依靠非对称加密算法 原理：
拿到公钥的一方先生成随机的会话密钥，然后利用公钥加密它，再把加密结果发给对方，对方用私钥解密；于是双方都得到了会话密钥。 举例：
RSA、SM2 秘钥协商/交换步骤：
客户端连上服务端服务端发送 CA 证书给客户端客户端验证该证书的可靠性客户端从 CA 证书中取出公钥客户端生成一个随机密钥 k，并用这个公钥加密得到 k’客户端把 k’ 发送给服务端服务端收到 k’ 后用自己的私钥解密得到 k，此时双方都得到了密钥 k，协商完成。 例子：
RSA的秘钥协商流程 SM2的秘钥协商流程参考链接：SM2密钥协商流程 - 百度文库 2，依靠专门的密钥交换算法 简介：
DH 算法又称“Diffie–Hellman 算法”,它可以做到“通讯双方在完全没有对方任何预先信息的条件下通过不安全信道创建起一个密钥”, 即通讯双方事先不需要有共享的秘密。而且，使用该算法协商密码，即使协商过程中被别人全程偷窥（比如“网络嗅探”），偷窥者也无法知道最终协商得出的密钥结果。 缺点：
此算法不支持认证，虽然可以抵抗偷窥但是无法抵抗篡改，无法对抗中间人攻击。一般此算法会配合其余的签名算法搭配使用，比如RSA、DSA算法。 例子：
Alice和Bob约定使用一个模 p = 23和g = 5Alice选择一个保密的整数 a = 4作为私钥，计算出公钥 A = g^a mod p，将公钥A发送给Bob；A = 5^4 mod 23 = 4Bob选在一个保密的整数 b = 3，计算出公钥 B = g^b mod p，将公钥B发送给Alice；B = 5^3 mod 23 = 10Alice 计算出共享密钥 s = B^a mod p s = 10^4 mod 23 = 18Bob 计算共享密钥 s = A^b mod p s = 4^3 mod 23 = 18Alice和Bob现在就共享一个密钥（s = 18） 优势：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c155f813d872060326879a4f402ddd8f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/548b4cc78ba880a48b86a4505b362464/" rel="bookmark">
			C&#43;&#43;自增运算符重载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		运算符重载++下面从成员函数，和友元函数两种方法进行实现
#include&lt;iostream&gt; using namespace std; class zuobiao { public: int a, b, c; zuobiao(int x,int y,int z) { a = x; b = y; c = z; } //重载两个++一个是前置运算符，一个是后置运算符 friend zuobiao operator++(zuobiao&amp;j); friend zuobiao operator++(zuobiao&amp;k, int); }; zuobiao operator++(zuobiao&amp;j) { j.a++; j.b++; j.c++; return j; } zuobiao operator++(zuobiao&amp;k, int) { zuobiao temp(k); k.a++; k.b++; return temp; } int main() { zuobiao zuobiao1(3,2,4), zuobiao2(2,1,4),zuobiao3(0,0,0),zuobiao4(0,0,0); zuobiao1++; cout &lt;&lt; zuobiao1.a &lt;&lt; " "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/548b4cc78ba880a48b86a4505b362464/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff4add3d562bc57cb9ed209f5c3549ff/" rel="bookmark">
			[Bug]Process finished with exit code -1073741819 (0xC0000005)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目场景： 环境：Windows, Tensorflow 2.0 + python 3.6
问题描述 同样的一套代码， 在之前的数据集上运行无误，换了个新的数据集进行实验，结果在读取数据训练的时候报错然后程序自动终止：
错误信息： Process finished with exit code -1073741819 (0xC0000005)
通过调试定位错误的代码位置如下：
for idx，(train_x, train_y) in enumerate(train_data): train_epoch(parser, train_x, train_y,...) ... 确认train_data是没有问题的， 问题恰好出在遍历获取batch: (train_x, train_y)那儿。
尝试网上各种办法，都没有解决我的问题…
原因分析及解决方案： 该Bug编号应该与文件系统有关。 由于新的数据集很大，开始怀疑是不是内存/显存不够了，启动程序发现内存和显存都没到一半。
尝试各种方法无果后，最后，试探性的把数据量减到一半，发现上述问题消失了， 不过又爆出了新的Bug: OOM， xxxx, 这个很明显是显存的问题， batchsize减小之后OK.
回顾一下： 开始的Bug应该是数据量太大的缘故，导致在取Batch 数据是触发了Python的某个错误， 后面Bug是因为网络复杂再加上数据量大，从而导致在运行过程中显存不足。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4af3413f639d2dfd5ae76a748fdb319c/" rel="bookmark">
			模型评价-期望对数似然和对应的估计量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		期望对数似然和对应的估计量 我们可以通过计算KL信息来评估给定模型的合适性。 但是，KL信息在真实建模中只能在有限的几个例子中使用，因为KL信息包含了未知分布 g g g，这使得KL信息不能被直接计算。
KL信息可以被分解为
I ( g ; f ) = E G [ log ⁡ { g ( X ) f ( X ) } ] = E G [ log ⁡ g ( X ) ] − E G [ log ⁡ f ( X ) ] I(g ; f)=E_G\left[\log \left\{\frac{g(X)}{f(X)}\right\}\right]=E_G[\log g(X)]-E_G[\log f(X)] I(g;f)=EG​[log{f(X)g(X)​}]=EG​[logg(X)]−EG​[logf(X)]
此外，等式右边的第一项是一个常数，因为它仅仅依赖于真实模型 g g g，显然为了比较不同的模型，仅考虑上式的第二项即可。 这一项被称为期望对数似然（expected log-likelihood）. 这一项的值越大，KL信息越小，则该模型越好。
因为期望对数似然可以表达为
E G [ log ⁡ f ( X ) ] = ∫ log ⁡ f ( x ) d G ( x ) = { ∫ − ∞ ∞ g ( x ) log ⁡ f ( x ) d x , 连续模型, ∑ i = 1 ∞ g ( x i ) log ⁡ f ( x i ) , 离散模型, \begin{aligned} E_G[\log f(X)] &amp;=\int \log f(x) d G(x) \\ &amp;=\left\{\begin{array}{ll} \int_{-\infty}^{\infty} g(x) \log f(x) d x, &amp; \text {连续模型, } \\ \sum_{i=1}^{\infty} g\left(x_i\right) \log f\left(x_i\right), &amp; \text {离散模型, } \end{array}\right.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4af3413f639d2dfd5ae76a748fdb319c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fcc8d4dc39199954b9175fa153da113d/" rel="bookmark">
			API网关功能一览
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		API网关功能一览
无论是单体应用，SOA或者现在流行的微服务架构，都需要一个API网关。
API网关作为内网的入口；统一对外提供服务。
一些公共服务的建设，也可以在网关层统一处理。
网关应该是无状态，容易线性扩展的;运行时弱依赖持久层(只依赖redis等内存数据库，不依赖db)，最大化提升网关整体性能。
网关解决的问题：
微服务的统一对外输出，服务路由减少客户端与微服务之间的调用次数，提高效率；便于监控，可在网关中监控数据，可以做统一切面任务处理；便于认证，只需要在网关进行认证即可，无需每个微服务都进行认证；降低客户端与服务端的耦合度。 功能说明认证鉴权支持多种认证方式,TOKEN认证、JWT认证等。流量管控进行流量管控，防止客户端恶意获取数据；基于API的流量管理，进行限流。服务安全网关提供一些统一的安全机制，比如报文加密，签名验证，防重放攻击等。服务路由识别请求参数和路径转发上游API服务。日志记录记录各种调用日志，请求报文和返回报文，调用时间协议转换支持协议转换，比如将Webservice服务转换成Restful对外提供服务；支持protobuf协议转换json等。负载均衡支持网关内部负载均衡，用户可以选择注册代理和服务实例地址，网关通过心跳检测机制自动探测服务实例的可用性。超时熔断通过API配置访问超时时间，超时熔断立即返回。灰度发布产品支持让指定部分客户端应用使用新版本API，其他应用继续使用以前的API。数据脱敏敏感数据的脱敏全链路监控收集数据，提供链路图Api管理api信息维护，统一验证(参数，加解密)配置管理参数管理台统一配置刷新服务编排整合多API调用，提高效率； 罗列了可能的网关功能，当然认证鉴权有些项目会有专门的统一用户认证系统去处理，加解密也会有加密机系统提供。
还有什么功能可以集成到API网关？
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b972de980141558fbf0347b12e9b2fcb/" rel="bookmark">
			【SSM】SpringMVC运行报错：500 Servlet[SpringMVC]的Servlet.init（）引发异常 描述 服务器遇到一个意外的情况，阻止它完成请求。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		具体报错日志 org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'homeController': Unsatisfied dependency expressed through field 'springMVCTwoServiceImpl'; nested exception is org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type 'kgc.cn.service.SpringMVCTwoService' available: expected at least 1 bean which qualifies as autowire candidate. Dependency annotations: {@org.springframework.beans.factory.annotation.Autowired(required=true), @org.springframework.beans.factory.annotation.Qualifier(value=springMVCTwoServiceImpl)} 02-Aug-2022 12:59:52.624 信息 [localhost-startStop-1] org.apache.catalina.startup.HostConfig.deployDirectory 把web 应用程序部署到目录 [D:\TomCat\apache-tomcat-8.5.69\webapps\manager] 02-Aug-2022 12:59:52.697 信息 [localhost-startStop-1] org.apache.catalina.startup.HostConfig.deployDirectory Web应用程序目录[D:\TomCat\apache-tomcat-8.5.69\webapps\manager]的部署已在[73]毫秒内完成 02-Aug-2022 13:00:05.256 信息 [http-nio-8080-exec-4] org.springframework.web.servlet.FrameworkServlet.initServletBean Initializing Servlet 'SpringMVC' 02-Aug-2022 13:00:06.378 警告 [http-nio-8080-exec-4] org.springframework.context.support.AbstractApplicationContext.refresh Exception encountered during context initialization - cancelling refresh attempt: org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b972de980141558fbf0347b12e9b2fcb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c38a1bd95bfbc8a6c99c88fa8494385/" rel="bookmark">
			【Web技术】1505- Web Audio API 太强了，让我们一起领略音频之美
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在浏览器中，我们通常使用 audio 标签来播放音频：
&lt;audio controls&gt; &lt;source src="myAudio.mp3" type="audio/mpeg"&gt; &lt;source src="myAudio.ogg" type="audio/ogg"&gt; &lt;/audio&gt; 虽然 audio 标签使用起来很简单，但也存在一些局限。比如它只控制音频的播放、暂停、音量等。如果我们想进一步控制音频，比如通道合并和拆分、混响、音高和音频幅度压缩等。那么仅仅使用 audio 标签是做不到的。为了解决这个问题，我们需要使用 Web Audio API。
Web Audio API 提供了一个非常高效和通用的系统来控制 Web 上的音频，允许开发人员为音频添加特殊效果、可视化音频、添加空间效果等等。Web Audio API 让用户能够在音频上下文（AudioContext）中进行音频操作，具有模块化路由的特点。基本的音频操作是在音频节点上执行的，这些节点连接在一起形成一个音频路由图。
接下来，我将演示如何利用 AudioContext 对象来播放音频：
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Audio Context&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;input id="audioFile" type="file" accept="audio/*"/&gt; &lt;script&gt; const inputFile = document.querySelector("#audioFile"); inputFile.onchange = function(event) { const file = event.target.files[0]; const reader = new FileReader(); reader.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c38a1bd95bfbc8a6c99c88fa8494385/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/424b0877f75c29fcc905812434088d21/" rel="bookmark">
			Feign 踩坑指南 (接口返回泛型设置属性为null)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Feign 简介 Feign 的英文表意为“假装，伪装，变形”， 是一个http请求调用的轻量级框架，可以以Java接口注解的方式调用Http请求，而不用像Java中通过封装HTTP请求报文的方式直接调用。Feign通过处理注解，将请求模板化，当实际调用的时候，传入参数，根据参数再应用到请求上，进而转化成真正的请求，这种请求相对而言比较直观。
Feign和OpenFeign的关系 Feign本身不支持Spring MVC的注解，它有一套自己的注解
OpenFeign是Spring Cloud 在Feign的基础上支持了Spring MVC的注解，如@RequesMapping等等。
OpenFeign的@FeignClient可以解析SpringMVC的@RequestMapping注解下的接口，
并通过动态代理的方式产生实现类，实现类中做负载均衡并调用其他服务。
使用 依赖
&lt;!-- 引入open-feign --&gt;&lt;dependency&gt;&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;&lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- Feign默认所有带参数的请求都是Post，想要使用指定的提交方式需引入依赖 --&gt;&lt;dependency&gt;&lt;groupId&gt;io.github.openfeign&lt;/groupId&gt;&lt;artifactId&gt;feign-okhttp&lt;/artifactId&gt;&lt;/dependency&gt; 权限拦截器
这里针对服务与服务之间权限验证
// 定义拦截器public class MyBasicAuthRequestInterceptor implements RequestInterceptor {@Overridepublic void apply(RequestTemplate template) {// TODO Auto-generated method stubtemplate.header("Authorization", "Basic cm9vdDpyb290");}} 配置文件feign:client: config: service-valuation: request-interceptors:- com.online.taxi.passenger.feign.interceptor.MyBasicAuthRequestInterceptor 通用配置
feign:compression:# 配置请求GZIP压缩request:enabled: true# 配置压缩支持的MIME TYPEmime-types: text/xml,application/xml,application/json# 配置压缩数据大小的下限min-request-size: 2048# 配置响应GZIP压缩response:enabled: true# 采用 apache的 okhttp 作为 http访问okhttp:enabled: true# feign 客户端配置client:config:# 默认配置 -&gt; 可单独指定 feignNamedefault:# 链接超时时间connectTimeout: 5000# 读取超时时间readTimeout: 5000# 日志等级loggerLevel: full 调用
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/424b0877f75c29fcc905812434088d21/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55a5873b3e90d26a05102c517d419ce5/" rel="bookmark">
			1.Type类型详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.Type类型1.1 什么是Type？1.2 Type的用处1.3 ParmeterizedType(参数化类型)的作用1.3.1 测试ParmeterizedType1.3.2 测试结果 1.4 TypeVariable的作用1.5 GenericArrayType的作用1.6 WildcardType的作用1.6.1 WildcardType测试1.6.2 测试结果 1.Type类型 1.1 什么是Type？ Type是一个空接口，是所有类型的公共接口（父接口），其意义表示Java所有类型。这里所谓的类型是从Java整个语言角度来看的，比如原始类型、参数化类型（泛型）、类型变量及其数组等，可以理解为，Class（类）是Java对现实对象的抽象，而Type是对Java语言对象的抽象。
Type的实现类型，所有Type一共可以表示以下这5类数据。主要介绍的就是四个子接口。
实现了Type接口的子接口为
GenericArrayType(泛型数组类型)，ParmeterizedType(参数化类型)，TypeVariable(类型变量),WildcardType(通配符类型)。 实现了Type接口的子类
Class(类)。 1.2 Type的用处 由于java1.5引入了泛型这一概念，大大方便了我们代码的编写和优化，但是考虑到泛型擦除这一问题，当我们的代码在运行时期会擦除所有的泛型，这一我们在运行时期想要获取某一类原来是带有泛型的，而后来被擦除了的数据的泛型类型时就会有问题。所以java引入了Type这一概念。Type也主要是为在运行时期获取泛型而服务。
1.3 ParmeterizedType(参数化类型)的作用 ParmeterizedType主要是用来表示 如 Collection或者Class。 ParmeterizedType表示的类型非常的简单，只要带着泛型，除了不可以是数组和本类上定义的泛型以外，其他都被列入ParameterizedType的范围。
ParameterizedType表示的是参数化类型，例如List、Map&lt;Integer,String&gt;、Service这种带有泛型的类型。
ParameterizedType接口中常用的方法有三个，分别是: Type getRawType() 返回参数化类型中的原始类型，例如List&lt;String&gt;的原始类型为List Type[] getActualTypeArguments() 获取参数化类型的类型变量或者是实际类型列表，例如Map&lt;Integer, String&gt;的实际泛型列表Integer和String。改列表的所有类型都是Type，也即是说，可能存在多层嵌套的情况。 Type getOwnerType() 返回是类型所属的类型，例如存在A&lt;T&gt;，其中定义了内部类InnerA&lt;T&gt;,则InnerA&lt;T&gt;的所属类型是A&lt;T&gt;，如果是顶层类型则返回null，这种关系比较常见的是Map&lt;K, V&gt;接口与Map.Entry&lt;K, V&gt;接口，Map&lt;K,V&gt;接口是Map.Entry&lt;K,V&gt;接口的ownerType。 1.3.1 测试ParmeterizedType @Test public void test() throws ClassNotFoundException, InstantiationException, IllegalAccessException { Class&lt;TypeBean&gt; bean = (Class&lt;TypeBean&gt;) Class.forName("com.noahgroup.supervise.TypeBean"); Field[] declaredFields = bean.getDeclaredFields(); int i = 1; for (Field field : declaredFields) { field.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/55a5873b3e90d26a05102c517d419ce5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8afe374e01fb56fd3c39737c0a30cb6/" rel="bookmark">
			7:1 error Expected indentation of 2 spaces but found 4 indent 11:35 error Newline requir
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、首行缩进
2、最后一行换行
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08e4a1fd1a9c08353850c690a3cda09a/" rel="bookmark">
			无人车智能挑战赛自主巡航篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.建图 1.1启动脚本 打开终端输入： $ ./1-gmapping.sh 可以通过I（前）、J（左）、K（右）、L（后）控制小车的移动 1.2保存地图 打开终端输入：
$ roslaunch robot_slam save_map.launch 2.自主导航 2.1关闭第二个终端 2.2重启地图终端 打开终端输入：
$ ./3-mission.sh 在这个终端输入 1 即可
3.调整 3.1巡航点 goallistX 方向为前后方向（前为正后为负）单位：米 goallistY 方向为前后方向（左为正右为负）单位：米 goallistZ 为旋转（左为正右为负）单位：弧度 第一个航点信息为机器人启动运行到二维码附近的航点第二个航点信息为机器人启动运行到 1 号目标点的航点第三个航点信息为机器人启动运行到 2 号目标点的航点第四个航点信息为机器人启动运行到 3 号目标点的航点第五个航点信息为机器人启动运行到 4 号目标点的航点第六个航点信息为机器人启动运行到 5 号目标点的航点第七个航点信息为机器人启动运行到 6 号目标点的航点第八个航点信息为机器人启动运行到终点的航点 3.2语音 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa77b52a7174dfabf55e21b995b2c4f8/" rel="bookmark">
			50:26 error Trailing spaces not allowed no-trailing-spaces
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		不允许尾随空格出现，删除空格
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69abd70a729960c7435654c07d6f1b23/" rel="bookmark">
			Python Matplotlib数据可视化绘图之（一）————柱状图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、所用到的模块二、单一颜色的普通不分组柱状图1.示例数据如下2.代码如下2.1 代码如下（示例）：2.1.1 Case1：2.1.2 Case2:2.1.3 Case3: 三、多种颜色的普通不分组柱状图1.示例数据如下2.代码如下2.1 代码如下（示例）：2.1.1 Case1： 四、多种颜色的普通分组柱状图1.示例数据如下2.代码如下2.1 代码如下（示例）：2.1.1 Case1： 2.2 我们可以看到，在上述作图过程中，我们把画布(fig)背景色设置为#B0C4DE，把轴域(ax)背景色或者称为绘图区域背景色设置为white(纯白色)，以上图片都是我截图保存下来的，所以能够保持我们对fig和ax的背景色的设置，但是如果我们想用plt.savefig()语句把图片保存到本地，且仍然保留我们对fig和ax的背景色的设置的话，需要使用以下语句参数，如下所示： 五、总结 前言 本文我们主要介绍利用Python中的Matplotlib模块进行几种柱状图的画法，包括整张图片只有一种颜色的不分组柱状图、整张图片有好几种颜色的不分组柱状图、整张图片有好几种颜色的分组柱状图等。
一、所用到的模块 主要利用Python中的Matplotlib模块完成该功能。
二、单一颜色的普通不分组柱状图 1.示例数据如下 表格如下（示例）：
语言种类2020年用户量(人数)C2000C++3000Python3000Java5000Java Script2000PHP1000Ruby800 现在需要把表格中的数据绘制成柱状图，从而进一步分析各类语言的用户的使用情况。
2.代码如下 2.1 代码如下（示例）： 2.1.1 Case1： import matplotlib import matplotlib.pyplot as plt import numpy as np # 设置字体, 解决中文乱码问题 plt.rcParams['font.sans-serif'] = ['Microsoft YaHei'] # 解决图像中的'-'负号的乱码问题 plt.rcParams['axes.unicode_minus'] = False x_labels = ['C', 'C++', 'Python', 'Java', 'Java Script', 'PHP', 'Ruby'] y = [2000, 3000, 3000, 5000, 2000, 1000, 800] fig = plt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/69abd70a729960c7435654c07d6f1b23/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8eb64dc2586de5edadeb1d909e2dabc/" rel="bookmark">
			SpringCloud基础知识【Hystrix熔断器】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpringCloud基础知识【Hystrix熔断器】 1. Hystrix概述2. Hystix-隔离2.1 线程池隔离2.2 信号量隔离2.3 Hystix隔离小结 3. Hystix-降级3.1 服务提供方降级3.2 消费方降级3.3 Hystix降级小结 4. Hystix-熔断4.1 代码演示4.1 熔断监控 5. Hystix-限流 1. Hystrix概述 Hystix，是Netflix开源的一个延迟和容错库，用于隔离访问远程服务、第三方库，防止出现级联失败(雪崩)。
雪崩:一个服务失败。导致整条链路的服务都失败的情形。 那么如何预防雪崩的出现呢？
Hystix为我们提供了隔离、降级、熔断、限流等方法防止雪崩的发生。 2. Hystix-隔离 资源隔离要解决的核心的问题：就是将多个依赖服务的调用分别隔离到各自的资源池内。
避免对某一个依赖服务的调用，因为依赖服务的接口调用的延迟或者失败，导致服务所有的线程资源全部耗费在这个服务的接口调用上。一旦某个服务的线程资源全部耗尽的话，可能就导致服务就会崩溃，甚至说这种故障会不断蔓延。如下图所示：
2.1 线程池隔离 线程池隔离：适合绝大多数的场景，Hystix默认采用线程池隔离
如下图所示，A 服务将Threadpool中拆分成Threadpool-B、Threadpool-C、Threadpool-D3个单独对B\C\D进行服务。各线程池相互独立。一个服务[C]挂掉并不会引起整条链路都失败的情况发生。 线程池隔离优缺点
优点∶
使用线程池隔离可以完全隔离依赖的服务(例如图中的 B、C、D服务)，请求线程可以快速放回当线程池出现问题时，线程池隔离是独立的，不会影响其他服务和接口。当失败的服务再次变得可用时，线程池将清理并可立即恢复，而不需要一个长时间的恢复。独立的线程池提高了并发性。 缺点∶
线程池隔离的主要缺点是它们增加计算开销(CPU)。每个命令的执行涉及到排队、调度和上下文切换都是在一个单独的线程上运行的。 2.2 信号量隔离 信号量隔离：适合与对内部的一些比较复杂的业务逻辑的访问，而不是对外部依赖的访问。
一个线程池、但对不同的服务上加上一个阀门(访问的次数)。超过该数量，就拒绝后续的服务。 2.3 Hystix隔离小结 是否有线程切换是否支持异步是否支持超时是否支持熔断是否支持限流开销线程池√√√√√大信号量×××√√小 什么情况下，用线程池隔离?
请求并发量大，并且耗时长(计算量大，或读数据库）原因：可以保证大量的容器(tomcat)线程可用，不会由于服务原因，一直处于阻塞或等待状态，快速失败返回。 什么情况下，用信号量隔离?
请求并发量大，并且耗时短（计算量小，或读缓存）原因：这类服务的返回通常会非常的快，不会占用容器线程太长时间，而且也减少了线程切换的一些开销，提高了缓存服务的效率。 3. Hystix-降级 Hystix降级：当服务发生异常或调用超时，返回默认处理方案(默认数据)。
3.1 服务提供方降级 Hystrix初始代码和Fiegn初始代码一样，这里就不再赘述。
在服务提供方(hystrix-provider)，引入 hystrix依赖定义降级方法使用@HystrixCommand 注解配置降级方法在启动类上开启Hystrix功能:@EnableCircuitBreaker 实例操作
引入 hystrix依赖 &lt;!-- hystrix --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt; &lt;/dependency&gt; 在服务提供方启动类开启开启Hystrix功能 package com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e8eb64dc2586de5edadeb1d909e2dabc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1622021b1d424b1303784a827bb5475c/" rel="bookmark">
			Quartus中运用多种方式设计一个D触发器，并进行仿真，时序波形验证
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、D触发器介绍1、D触发是什么？2、结构 二、自定义D触发器1、创建Quartus项目2、自定义D触发器原理图3、编译4、波形仿真 三、调用D触发器1、调用D触发器的原理图2、仿真图 四、Verilog语言实现一个触发器1、创建一个Verilog HDL 文件2、配置代码3、编译4、仿真图 五、总结六、参考资料 前言 环境要求：
Quartus Prime 18.0
modelsim 10.5
一、D触发器介绍 1、D触发是什么？ D触发器是一个具有记忆功能的，具有两个稳定状态的信息存储器件，是构成多种时序电路的最基本逻辑单元，也是数字逻辑电路中一种重要的单元电路。
因此，D触发器在数字系统和计算机中有着广泛的应用。触发器具有两个稳定状态，即"0"和"1"，在一定的外界信号作用下，可以从一个稳定状态翻转到另一个稳定状态。
D触发器有集成触发器和门电路组成的触发器。触发方式有电平触发和边沿触发两种，前者在CP(时钟脉冲)=1时即可触发，后者多在CP的前沿（正跳变0→1）触发。
D触发器的次态取决于触发前D端的状态，即次态=D。因此，它具有置0、置1两种功能。
对于边沿D触发器，由于在CP=1期间电路具有维持阻塞作用，所以在CP=1期间，D端的数据状态变化，不会影响触发器的输出状态。
2、结构 D触发器（data flip-flop或delay flip-flop）由4个与非门组成，其中G1和G2构成基本RS触发器。电平触发的主从触发器工作时，必须在正跳沿前加入输入信号。如果在CP高电平期间输入端出现干扰信号，那么就有可能使触发器的状态出错。而边沿触发器允许在CP触发沿来到前一瞬间加入输入信号。这样，输入端受干扰的时间大大缩短，受干扰的可能性就降低了。边沿D触发器也称为维持-阻塞边沿D触发器。边沿D触发器可由两个D触发器串联而成，但第一个D触发器的CP需要用非门反向。
结构图
功能表
方程
时序图
二、自定义D触发器 1、创建Quartus项目 下面两种方式均可以进行创建
点击next
设置项目路径及项目名，然后next 选择一个空项目，next next
芯片选型：EP4CE6F17C8
EDA设置
检查配置并点击finish
2、自定义D触发器原理图 打开原理图编辑窗
双击编辑界面，在弹出的框框里左边的文件夹寻找需要的元件，或者通过Name进行查找：
注意： D触发器需要4 个 nand2 与非门，1 个 not 非门，2个输入管脚和2个输出管脚：
然后第一次连线就用下面这个吧，其他我用起来生成的效果图是错的，然后就是连的时候释放的点不对也会出现x,再者就是选择元件之后，不需要了可以点击Esc重置，不然他一直会携带那个元件。
D触发器： 点击保存 3、编译 点击下面三角进行编译
查看硬件电路图
效果
4、波形仿真 注意：
仿真分为功能仿真和时序仿真，两者有什么不同？
1、进行时间不同
1、功能仿真：功能仿真是在布线前进行。
2、时序仿真：时序仿真是在布线后进行。
二、关注不同
1、功能仿真：功能仿真仅仅关注输出和输入的逻辑关系是否正确，不考虑时间延时信息。
2、时序仿真：时序仿真不仅关注输出和输入的逻辑关系是否正确，同时还计算了时间延时信息。
三、要求不同
1、功能仿真：功能仿真了解实现的功能是否满足设计要求，其仿真结果与电路设计的真值表的结果相对应。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1622021b1d424b1303784a827bb5475c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4515f5fcfd5b1f2de94b6532c7f3cc72/" rel="bookmark">
			创建和使用光学介质(DVD)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1 介绍
2 dvd+r光盘可以多次刻录吗
3 刻录数据 DVD
4 使用 DVD+RW
5 使用 DVD-RW
6 多区段
7 更多的信息
参考：第 19 章 存储 | FreeBSD Documentation Portal
1 介绍 DVD 可以容纳比任何 CD 更多的数据，已经成为现今视频出版业的标准。
我们称作可记录 DVD 的有五种物理记录格式：
DVD-R：这是第一种可用的 DVD 可记录格式。 DVD-R 标准由 DVD Forum 定义。 这种格式是一次可写的。
DVD-RW：这是 DVD-R 标准的可覆写版本。 一张 DVD-RW 可以被覆写大约 1000 次。
DVD-RAM：这也是一种被 DVD Forum 所支持的可覆写格式。 DVD-RAM 可以被看作一种可移动硬盘。 然而，这种介质和大部分 DVD-ROM 驱动器以及 DVD-Video 播放器不兼容； 只有少数 DVD 刻录机支持 DVD-RAM。 请参阅 使用 DVD-RAM 以了解关于如何使用 DVD-RAM 的进一步详情。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4515f5fcfd5b1f2de94b6532c7f3cc72/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c0a2e1dcefdc091b33a15cb8baccba3/" rel="bookmark">
			uniapp app 实现长按文字实现复制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注意：模拟器上没效果，我直接打了包安装就有效果了
效果图：
全局
在app.vue
-webkit-user-select: text; user-select: text; 单个text标签
&lt;text class="headerTitle" selectable="true"&gt;文本复制&lt;/text&gt;
text | uni-app官网
学习一下css user-select
引用：H5_0026：使用CSS里的user-select属性控制用户在页面上选中的内容 - 走看看
//获取系统剪贴板内容，没有验证只是备在这里。uni-app官网
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e40f1547c2ba3db42bcae1850e5f06a/" rel="bookmark">
			传统图像处理(二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 目标检测图像分割GrabCut算法 图像搜索 目标检测 目标检测可以使用HOG+SVM的方式实现。在单类别物体检测任务中，可以使用OpenCV的"特征点检测+特征描述"匹配方式快速检测目标，但是这种方式一般适用于单个物体检测。如果图片中存在多个同类别物体，就需要借助聚类方法来实现。
OpenCV中的ORB检测器算法采用FAST算法来检测特征点，使用BRIEF进行特征点描述（用于匹配特征点）。
其中FAST算法寻找角点的依据是：若某像素与其邻域内足够多的像素相差较大，则该像素可能是角点。
cv2.ORB_create(nfeatures = 500, scaleFactor = 1.2, nlevels = 8, edgeThreshold = 31, firstLevel = 0, WTA_K = 2, scoreType = HARRIS_SCORE, patchSize = 31, fastThreshold = 20) nfeatures - int：确定要查找的最大要素（关键点）数。 scaleFactor - float：金字塔抽取率，必须大于1。ORB使用图像金字塔来查找要素，因此必须提供金字塔中每个图层与金字塔所具有的级别数之间的比例因子。scaleFactor = 2表示经典金字塔，其中每个下一级别的像素比前一级低4倍。大比例因子将减少发现的功能数量。 nlevels - int：金字塔等级的数量。最小级别的线性大小等于 input_image_linear_size / pow（scaleFactor，nlevels）。 edgeThreshold - - int：未检测到要素的边框大小。由于关键点具有特定的像素大小，因此必须从搜索中排除图像的边缘。 edgeThreshold的大小应该等于或大于patchSize参数。 firstLevel - int：此参数允许您确定应将哪个级别视为金字塔中的第一级别。它在当前实现中应为0。通常，具有统一标度的金字塔等级被认为是第一级。 WTA_K - int：用于生成定向的BRIEF描述符的每个元素的随机像素的数量。可能的值为2,3和4，其中2为默认值。例如，值3意味着一次选择三个随机像素来比较它们的亮度。返回最亮像素的索引。由于有3个像素，因此返回的索引将为0,1或2。 scoreType - int：此参数可以设置为HARRIS_SCORE或FAST_SCORE。默认的HARRIS_SCORE表示Harris角算法用于对要素进行排名。该分数仅用于保留最佳功能。 FAST_SCORE生成的关键点稍差，但计算起来要快一些。 patchSize - int：面向简要描述符使用的补丁的大小。当然，在较小的金字塔层上，由特征覆盖的感知图像区域将更大。 前两个参数（nfeatures和scaleFactor）可能是最有可能改变的参数。 利用orb.detectAndCompute()检测关键点并计算 kp,des = orb.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e40f1547c2ba3db42bcae1850e5f06a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bdd9d81acdb93ea034fc1d73a74af474/" rel="bookmark">
			pytorch [GPU版]  安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 众所周知啊，在我们安装 GPU 版的 pytorch 之前，需要安装 CUDA，CUDA 的安装教程在此不过多追叙，详情可以看官方文档。
版本一览 win 10cuda：11.6python：3.8pytorch 三宝：
安装教程 咱首先要做的是确认我们的 CUDA 的版本
打开cmd，输入 nvidia-smi
知道 CUDA 版本之后，去pytorch官网一键下载就好了
复制下边的下载指令到 pycharm 命令行下载就行了
查看 torch 以及 torchvision 的版本
import torch import torchvision print("pytorch version:",torch.__version__) print("torchvision version:",torchvision.__version__) 注：这里如果你CUDA版本是11.6，并按照我上边的流程去弄，接下来会报一个错
如果 CUDA 是其它版本的可以忽略我下边说的直接点赞加收藏就好了【🐶】
报错详解 “NotImplementedError: Could not run ‘torchvision::nms‘ with arguments from the ‘CUDA‘ backend.”
这里解释一下为什么会报错，原因是你 CUDA11.6 在官方网首页直接下载的 pytorch 三宝合集包里边，torchvision 这个是默认给你下 cpu 版本的，所以这边咱需要换一下它的版本
点击我下边指出的地方，这里是进去看 pytorch 历史版本
找到你 CUDA 的版本，复制去下载就好了
最后查看一下版本，发现 torchvision 变成了cu116，这才是对的GPU版本
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bdd9d81acdb93ea034fc1d73a74af474/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/130fee48a01486a3b2aecf8fb28a42b4/" rel="bookmark">
			渗透测试完整流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、信息收集 (一)、收集域名信息 1、whois (二)、收集子域名信息 1、fofa domain=“域名”
(三)、查找真实IP 1、有无cdn 1.通过ping
2.nslookup查询
(四)、收集常用端口信息 端口号服务程序21FTP ，文件传输协议22SSH，安全登录、文件传送（SCP）23Telnet，不安全的文本传送80HTTP，超文本传送协议（WWW）110POP3，Post Office Protocol（E-mail）443主要用于HTTPS服务，是提供加密和通过安全端口传输的另一种HTTP1433Microsoft的SQL服务开放的端口3306MySQL服务开放的端口3389远程桌面默认的端口 21端口： 运行在21端口的是FTP服务，FTP用于在Internet上控制文件的双向传输。同时，他也是一个应用程序。基于不同的操作系统有不同的FTP应用程序，而所有这些应用程序都遵守同一种协议以传输文件。
21端口为ftp版本漏洞 当查看有开放的21端口时，就可以查看ftp的版本，搜索ftp版本漏洞。
例如：
21端口测试 查看到ftp的版本，搜索得知ftp为ProFTPD 1.3.3c存在后门漏洞
启动MSF的终端
msfconsole 搜索proFTPD的攻击模块，并载入
search proFTPD //搜索proFTPD的攻击模块 use exploit/unit/ftp/proftpd_133c_backdoor //载入选择模块 填写模块内容 并执行，之后反弹shell
不知该填写什么参数可以 show一下
show options //需要填写的信息 set RHOSTS 192.168.*.** //目标IP run //执行 还可以尝试爆破登录ftp账号
22端口： dc-4
https://blog.csdn.net/qq_45590470/article/details/127449700
使用kali的工具hydra对目标IP的22端口进行暴力破解
爆破命令：
hydra -l(用户名) root -P(爆破字典) /usr/pass.txt(绝对路径，pass.txt为字典文件名，可以将自己的字典加入到该目录下) -V(显示爆破过程) -t(指定线程数) 10 ssh://127.0.0.1(如果是默认端口，可以不写，如果不是默认端口，要加端口xx,如ssh://127.0.0.1:xx)
暴力破解获得密码，获得用户及密码后可以使用ssh进行连接22端口。
ssh 用户名@IP地址 这里介绍一下hydra的一些参数
-R 继续从上一次进度接着破解 -S 大写，采用SSL链接 -s 小写，可通过这个参数指定非默认端口 -l 指定破解的用户，对特定用户破解 -L 指定用户名字典 -p 小写，指定密码破解，少用，一般是采用密码字典 -P 大写，指定密码字典 -e 可选选项，n：空密码试探，s：使用指定用户和密码试探 -C 使用冒号分割格式，例如“登录名:密码”来代替-L/-P参数 -M 指定目标列表文件一行一条 -o 指定结果输出文件 -f 在使用-M参数以后，找到第一对登录名或者密码的时候中止破解 -t 同时运行的线程数，默认为16 -w 设置最大超时的时间，单位秒，默认是30s -v /-V显示详细过程 各协议的具体命令：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/130fee48a01486a3b2aecf8fb28a42b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94eedf8dce4aa7028ddab0fe766d42ad/" rel="bookmark">
			LSTM基础理论与实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 关于深度学习的算法，主要有CNN卷积神经网络、RNN循环神经网络、CAN生成对抗网络三种。LSTM（Long Short-Term Memory）就是基于RNN而来。本文将主要介绍LSTM的基础理论与文字预测的实例。
LSTM基础理论 1.基础框架图 其中的符号含义如下图所示：
2.分步解析 第一步，处理单元通过遗忘门来决定我们需要丢弃的信息。该门会读取时刻向量值与时刻的输入，然后通过激活层 σ 输出一个0-1之间数值（激活层函数一般为ReLU）。1表示“完全保留”，0表示“完全舍弃”。
为 σ网络激活层; 为 权重 ; ,为 输入; 为 偏执量;
第二步,这一步要确定什么样信息放到处理单元中，包含两个处理步骤：
1.首先：通过时刻向量值与时刻的输入然后通过 σ 网络激活层 决定哪些信息要更新，最终放入传送带。
2. 然后：通过tanh层，通过tanh层生成一个向量，对输入端进行激活，对细胞进行更新将更新为。
第三步：现在是更新旧处理单元的时间了， 更新为 。把旧状态与 相乘，丢弃掉我们确定需要丢弃的信息。接着加上 。这就是新的候选值，根据我们决定更新每个状态的程度进行变化。
最后，需要确定输出什么值。这个输出将会基于我们的细胞状态，但是也是一个过滤后的版本。首先，我们运行一个 sigmoid 层来确定细胞状态的哪个部分将输出出去。接着，我们把细胞状态通过 tanh 进行处理（得到一个在 -1 到 1 之间的值）并将它和 sigmoid 门的输出相乘，最终我们仅仅会输出我们确定输出的那部分。
单词预测实例 基于pytorch
import torch import torch.nn as nn import numpy as np from torch.utils.data import DataLoader, Dataset class Net(nn.Module): def __init__(self, features, hidden_size): super(Net, self).__init__() self.features = features # 输入特征维度 self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94eedf8dce4aa7028ddab0fe766d42ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99ca6d4bf00501fdf0b863bca8443ebb/" rel="bookmark">
			android源码编译环境准备（1）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 若需要对android源码framework层进行修改，则需要重新编译固件。
1.环境配置 1.1基础信息： 系统：Ubuntu16.04
交换内存：8G
硬盘容量：120G
JDK：openJDK7
源码：android5.1
1.2 unbuntu系统环境建立 （1）首先在根目录打开终端：若是虚拟机请检查网络，执行更新下载工具
sudo apt-get update （2）执行下载其他需要的包
sudo apt-get install git-core gnupg flex bison gperf build-essential \ zip curl zlib1g-dev gcc-multilib g++-multilib libc6-dev-i386 \ lib32ncurses5-dev x11proto-core-dev libx11-dev lib32z-dev ccache \ libgl1-mesa-dev libxml2-utils xsltproc unzip m4 （3）单独安转JDK7的离线包，若是编译android7.1及以上则可直接通过命令安装JDK8。安装之前需要先建立配置文件：
mkdir -p /usr/share/man/man1 然后下载离线包：OpenJDK7，然后在离线包所在目录打开终端执行以下命令：
sudo dpkg -i *.deb 验证JDK7是否安装成功
java -version javac -version javap -version 2.编译android固件 2.1. 下载 Android SDK Android SDK 源码包比较大(约6.3G),可以通过如下方式获取源码包：
[下载链接]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/99ca6d4bf00501fdf0b863bca8443ebb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c40516188593ae724e332956ae5de8f/" rel="bookmark">
			vs code实现XML代码补全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 vs code的XML代码自动补全必备插件XML支持代码补全 优缺点优点：免费开源，主要功能能正常使用缺点：功能不够完善 vs code的XML代码自动补全 必备插件 XML支持 代码补全 优缺点 优点：免费开源，主要功能能正常使用 缺点：功能不够完善 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3154c7ddf14939a0b8f50c3d558e17db/" rel="bookmark">
			[附源码]java毕业设计哈金院食堂美食评价系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目运行
环境配置：
Jdk1.8 + Tomcat7.0 + Mysql + HBuilderX（Webstorm也行）+ Eclispe（IntelliJ IDEA,Eclispe,MyEclispe,Sts都支持）。
项目技术：
SSM + mybatis + Maven + Vue 等等组成，B/S模式 + Maven管理等等。
环境需要
1.运行环境：最好是java jdk 1.8，我们在这个平台上运行的。其他版本理论上也可以。
2.IDE环境：IDEA，Eclipse,Myeclipse都可以。推荐IDEA;
3.tomcat环境：Tomcat 7.x,8.x,9.x版本均可
4.硬件环境：windows 7/8/10 1G内存以上；或者 Mac OS；
5.是否Maven项目: 否；查看源码目录中是否包含pom.xml；若包含，则为maven项目，否则为非maven项目 6.数据库：MySql 5.7/8.0等版本均可；
毕设帮助，指导，本源码分享，调试部署(见文末)
3.1 需求分析 该款哈金院食堂美食评价系统的主要功能有：注册、登录界面，哈金院食堂美食信息的查询和查看等。
(1) 登入界面：首次打开软件，会出现账号以及密码的填写页面，当然也可以进行新学生的注册，新学生注册需要完成学生学号，学生姓名，密码，确认密码，专业，联系电话等信息的填写；
(2)学生界面：学生可以根据自身要求在搜索栏进行关键词搜索，随即会显示有关哈金院食堂美食的具体信息等，进入用户后台可以对首页，菜品信息，系统公告，个人中心，后台管理等功能进行相应的操作；
(3) 管理员：管理员可以对所有信息进行查看，修改和删除等，包括对学生的信息进行操作。
3.2 系统可行性分析 3.2.1技术可行性 本哈金院食堂美食评价系统使用的是Eclipse开发环境及Java语言。Java是编写程序的面向对象的编程语言，封装了各种数据和处理数据的方法，方便了程序员的设计与开发。其跨平台的特性，使得其不被平台环境束缚。另外，其具有多线程的处理能力，这使得程序具有更好的交互性和实时性。
3.2.2 操作可行性 现在随着科技的飞速发展，计算机早已经进入了人们的日常生活中，人们的工作环境也不像以前有那么多的要求，需要员工一定要到公司办公，有的工作在家也可以完成。这使得人们的工作效益有了很大的提高。操作的多样性也变高了。因此，管理的计算机化，智能化是社会发展而带来的必然趋势，各种智能的软件层出不穷，不同的软件能完成用户不同的需求，这不仅提高了工作效率还能完成一些客户特定的一些需求。本系统不仅界面简洁明了还采用可视化界面，用户只要用鼠标和键盘就可以完成对相关信息的修改，删除，添加等操作。因为这个系统的操作十分简单，方便上手，对于第一次使用系统的人，只需要很少的时间就可以上手操作。由此可见，本系统在操作上是可行的。
3.2.3 经济可行性 哈金院食堂美食评价系统环境仅需要一台电脑和一款模拟器，成本预算少，外加搭建开发环境和安装开发工具即可。
4 系统软件的总体设计 4.1 系统开发流程 （1）需求分析：初步分析用户的需求，列出功能模块。
（2）系统设计：相关数据库、各功能的设计。
（3）界面设计：根据各个模块准备素材，设计界面。
（4）代码编写：实现相关功能代码的编写。
（5）测试运行：按照规划测试软件各项功能是否正常运行。
4.2 系统总体架构设计 该款哈金院食堂美食评价系统；学生可以通过注册账号从而登入系统主界面来实现相对应的功能，分别是查看首页，菜品信息，系统公告，个人中心，后台管理等功能。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3154c7ddf14939a0b8f50c3d558e17db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36e0177a905c2b90dcb431082b0adb39/" rel="bookmark">
			Unity移除EventTrigger上侦听的事件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、移除EventTrigger上的侦听事件 //Remove all listeners myEventTrigger.triggers.RemoveRange (0, myEventTrigger.triggers.Count); 二、移除OnClick上的侦听事件 button.onClick.RemoveAllListeners(); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/998cd8d950a203e99c772548150267c2/" rel="bookmark">
			关于 “微前端----乾坤” 的概念
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微前端 – 乾坤 产生背景： 在 toB 的前端开发工作中，我们往往就会遇到如下困境：
工程越来越大，打包越来越慢
团队人员多，产品功能复杂，代码冲突频繁、影响面大
技术栈单一，无法灵活扩展
微前端到底是什么？ 微前端是一种多个团队通过独立发布功能的方式来共同构建现代化 web 应用的技术手段及方法策略。
微前端借鉴了微服务的架构理念，将一个庞大的前端应用拆分为多个独立灵活的小型应用，每个应用都可以独立开发、独立运行、独立部署，
再将这些小型应用联合为一个完整的应用。微前端既可以将多个项目融合为一，又可以减少项目之间的耦合，提升项目扩展性，相比一整块的前端仓库，
微前端架构下的前端仓库倾向于更小更灵活。
微前端架构模式？ 基座模式
通过一个主应用，来管理其它应用。设计难度小，方便实践，但是通用度低。
自组织模式。应用之间是平等的，不存在相互管理的模式。设计难度大，不方便实施，但是通用度高。
就当前而言，基座模式实施起来比较方便，方案也是蛮多的。
注册表模式
和微服务架构相似，不论是哪种微前端方式，都需要有一个应用注册表的服务。这个应用注册表拥有每个应用及对应的入口，即路由。
它可以是一个固定值的配置文件，如 JSON 文件，又或者是一个可动态更新的配置，又或者是一种动态的服务。
作用：
应用注册。即提供新的微前端应用，向应用注册表注册功能。
应用发现。让主应用可以寻找到其它应用。
Qiankun 可以去官方网站看一下用法：
qiankun官方网址
生命周期 微前端每个应用都拥有自己的生命周期：
bootstrap， 只会在微应用初始化的时候调用一次，下次微应用重新进入时会直接调用 mount 钩子，不会再重复触发 bootstrap。 通常我们可以在这里做一些全局变量的初始化，比如不会在 unmount 阶段被销毁的应用级别的缓存等。
Mount，应用每次进入都会调用 mount 方法，通常我们在这里触发应用的渲染方法
Unload，删除应用的生命周期
Unmount，应用每次 切出/卸载 会调用的方法，通常在这里我们会卸载微应用的应用实例
乾坤的一些特性？ 乾坤，作为一款微前端领域的知名框架，其建立在single-spa基础上。相较于single-spa，乾坤做了两件重要的事情，其一是加载资源，第二是进行资源隔离。而资源隔离又分为Js资源隔离和css资源隔离.
css隔离，确保微应用之间样式互相不干扰。 JS沙箱，确保微应用之间 全局变量/事件 不冲突。
每个微应用对全局的影响都会局限在微应用自己的作用域内。比如 A 应用在 window 上新增了个属性 test，这个属性只能在 A 应用自己的作用域通过 window.test 获取到，主应用或者其他应用都无法拿到这个变量。
乾坤Js隔离机制（沙箱）的发展史
1、快照沙箱
const window = {}; class SnapshotSandbox { windowSnapshot = {}; // 保存window快照 modifyPropsMap = {}; // 修改的内容 // 沙箱激活 active() { // 记录window当时的状态 for (const prop in window) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/998cd8d950a203e99c772548150267c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e96f5b2ebadbc677815ac7fe20e4ab9/" rel="bookmark">
			ubuntu20.4编译AOSP安卓源码（AndroidP android-9.0.0_r9）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
代码下载
安装初始化依赖工具
配置repo工具
配置git信息 初始化仓库
配置编译环境
安装jdk
安装编译依赖
编译
初始化编译环境
选择编译目标
编译源码
启动模拟器
windows和Linux协同工作
遇到的问题解决 安装依赖冲突解决
编译时找不到libncurses.so.5库
启动模拟器失败
附：
ubuntu20.4LTS下载地址
AOSP国内镜像地址
后续使用hyper-V遇到的问题
清华大学ubuntu镜像源报错
repo init 报错
引用：
代码下载 安装初始化依赖工具 sudo apt-get install curl python git 配置repo工具 mkdir ~/bin curl https://storage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repo chmod a+x ~/bin/repo repo的运行过程中会尝试访问google官方的git源更新自己，需要翻墙，可通过修改repo默认源，通过国内镜像源更新，具体操作为：在~/.bashrc文件里添加如下两行，保存退出，然后执行source ~/.bashrc更新环境变量
PATH=~/bin:$PATH export REPO_URL='https://mirrors.tuna.tsinghua.edu.cn/git/git-repo/' 配置git信息 邮箱和姓名可以用真实的，也可以随便编一个
git config --global user.email "you@example.com" git config --global user.name "Your Name" 初始化仓库 mkdir AOSP cd AOSP repo init -u https://mirrors.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e96f5b2ebadbc677815ac7fe20e4ab9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6aab305e16b4ccf8703175b695391ee9/" rel="bookmark">
			Blender2.9基础七：外部插件篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、插件安装 1、安装插件
2、插件显示位置
二、材质贴图相关插件 1、GrabDoc（贴图烘培插件） GrabDoc可以运行一键式场景设置，然后开始建模！对形状进行建模后（甚至在建模阶段），你可以实时预览材质在视口中的外观！主要特点 实时材质预览：只需按一下按钮，即可实时预览材质，例如法线，曲率，环境光遮挡，高度和材质ID。
快速，低文件大小的烘焙：烘焙非常快，并且甚至可以通过用户指尖进行可选的无损压缩而变得很小。
【下载地址、详细教程】
2、NodeCustomBuilder（材质节点预置制作插件） 【下载地址】作用：不想重复制作多个材质节点时，可以制作一个预置，再导入预置节点反复使用。用法：
3、Bpainter（手绘贴图插件） 可以绘制PBR各种贴图下载： 【官方下载】人人上面也有 教程： bilibili上面有youtube【官方文档】 快捷键： 吸色：S/Alt+左键不放笔刷大小：F键不放+左右移动鼠标 三、UV插件 1、UvSquares（分UV插件） 【下载地址】【详细教程】这个插件用于打直UV、管线展UV都非常的好用。 2、uv_toolkit（分UV插件）（推荐使用） 【文档】
- 棋盘格 设置棋盘格分辨率
选择棋盘格类型
生成并显示棋盘格
初始材质与棋盘格材质切换显示
切换并显示棋盘格类型
清除棋盘格
3、uvpackmaster2（摆UV插件）（非常非常推荐使用） 非常NB的插件，可以节省很多时间。比你手动摆的好。【下载】【文档】 ▶插件安装 会经常使用以下几点功能，其他的不用去管。
▶自动摆UV（打包） ▶UV间距，默认值（0.005） ▶UV打包精度值 精度值越大，包装质量越好，打包时间更长。大多数情况下200精度值就够用了。做4K以上贴图可能会要加大一点。精度太低的值可能会导致打包后UV孤岛重叠，并把重叠UV显示出来。 ▶锁定当前打包的UV 比如一些重要的大块的UV优先打包，之后锁定当前打包的UV。然后再选择那些不重要的细碎的UV，另外打包他们，并自动把他们塞到大块UV缝隙里。 ▶ UV旋转角度值 Rotation Step参数决定了在打包过程中每个孤岛将考虑多少个方向旋转UV。例如：如果参数设置为90（度），则将考虑4个方向：基本方向（岛旋转0度）、岛旋转90度、岛旋转180度和岛旋转270度。默认值为90度将在较短打包时间内提供最佳打包效果。
四、建模插件 1、Fast Carve（快速雕刻） 下载地址：Fast Carve
教程：Blender 2.8 Addon Fast Carve : New UI
Blender 2.8 Fast Carve Addon : Extrude
Blender 2.8 Hardsurface Modeling : Addon Fast Carve
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6aab305e16b4ccf8703175b695391ee9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46ca82f1fa9684233383702bdc5bb503/" rel="bookmark">
			【Verilog】二、Verilog基础语法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录
前言
一、简单的Verilog知识
1.1、Verilog端口定义
1.2、Verilog的标识符
1.3、Verilog的逻辑值
1.4、Verilog的数字进制
1.5、Verilog的数据类型
1.5.1、reg型 1.5.2、wire型
1.5.3、参数类型
1.6、Verilog的运算符
1.6.1、算术运算符
1.6.2、关系运算符
1.6.3、逻辑运算符
1.6.4、条件运算符
1.6.5、位运算符
1.6.6、移位运算符
1.6.7、拼接运算符
二、Verilog程序设计
2.1、Verilog程序框架搭建
2.2、Verilog程序注释
2.3、Verilog关键字
总结
前言
上文我们对Verilog语言有了一定的了解，知道了Verilog语言是一种硬件描述语言，他能够在EDA工具上综合成实际的电路，在FPGA或者单片机开发领域有着很高的地位。
我们学习一门语言，肯定需要学习它的语法结构，就像学习C语言一样，我们相应对某一事件重复操作，我们可以用for循环实现，这就是一种语法结构，弄清楚了会极大地提高我们的开发效率。Verilog语言的语法结构还是挺简单的，相信比其他语言来得容易。
一、简单的Verilog知识 1.1、Verilog端口定义 下面我们看一端简单的代码来了解Verilog的端口定义基础知识：
module adder(
input [2:0] a ,
input [2:0] b ,
input cin ,
output count ,
output [2:0] sum );
assign {count,sum} = a + b + cin;
endmodule
这个例子通过连续赋值语句描述了一个模块名为adder的三位加法器可以根据两个三比特数a、b和进位cin计算出和（sum）和进位（count）。
通过这个例子，一个模块由module开头，endmodule结束，紧跟着module后面的是模块名。模块名后面括号里面的是输入输出端口信号，input为输入端口，output为输出端口，中括号里面是位宽，当没有指定位宽时默认为32位宽，{}叫做位拼接运输符，中间用逗号隔开，后面我们会细讲。
1.2、Verilog的标识符 标识符用于定义模块名、端口名和信号名等，上面代码里的adder就是一个标识符，也是模块名。Verilog的标识符可以是任意一组数字、字母、下划线等符号的组合，但是标识符的第一个字符必须是字母或者下划线。
标识符虽然可以任意定义，但是它是区分大小写的，比如Count和count就不是同一个标识符，这点需要注意。对于标识符的定义虽然没有限制，但是我们最好还是遵循一定的规则，以便于你以后回来对代码升级维护时一眼就能知道这个模块是干什么的。
关于标识符的规范，我这里有几个建议：
① 模块名定义最好见名知其意，定义的模块名最好和代码实现的功能相关，如sum等。
② 用下划线来隔开两个词组，看起来简单易懂，如cpu_addr就要比cpuaddr好很多。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/46ca82f1fa9684233383702bdc5bb503/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ddbeb3930eabb346d38fa1bb35e8e41/" rel="bookmark">
			【又一天坑】Win11 22H2 22623.730 WSL debug
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		幺蛾子更新之后将企业版安全功能下放到了专业版Win11上，如下：
这些选项严重影响了性能，导致我输入法卡顿，所以重启后全部关闭，发现WSL似乎依赖于某些项，再也不能打开。wsl -l -v仅刚开机有一次响应，之后就无响应。wsl --shutdown，netsh winsock reset也没用。
再次重启打开Win7时就有的DEP，其他保持关闭，仍然不行。
干脆打开所有安全选项，这时候WSL可以打开，但是Pycharm和某些常用程序报错，不能打开。
多次排查发现是强制映像随机性的问题。仅关闭ALSR，回到和默认值一样的情况即可。折腾这么多下，居然输入法也不卡顿了，WSL和Pycharm都能用了。
FK U, 印度MS。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/387daab1d08287f3ace327df9d20710c/" rel="bookmark">
			Error: EACCES: permission denied, open ‘/Users/xxx/
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		创建了一个vue3项目，初始化创建就跑不起来，找了很多办法都不太行，看了这篇博文解决了
记录一下
解决
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95eb35c1e4fb373af02e4111052cde10/" rel="bookmark">
			cutterman网盘免费下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 cutterman下载链接放在最后啦，创作不易，如果对你有帮助记得点赞收藏哦！
官网：http://www.cutterman.cn/zh/cutterman
注意：cutterman插件要求ps必须是完整版，不能是绿色版。
先解压得到
双击直接安装
重新启动ps
窗口-&gt;扩展功能-&gt;是否有cutterman-切图神器
点击之后会看到如下的弹窗
在这个官网中注册账号然后回到ps中登录就ok啦
http://www.cutterman.cn/zh/cutterman
链接：https://pan.baidu.com/s/15vofVvydwSwTpi5KEL4zjg 提取码：pguy 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca42cd1a965f51770c852778f6cd8bc8/" rel="bookmark">
			MaxEnt全套教程 (软件安装 文章解读 参数设定 优化 质心转移 结果出图)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MaxEnt全套教程 (软件安装 文章解读 参数设定 优化 质心转移 结果出图)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4bbac4320a3b53bc5e9b8f2a60f8867/" rel="bookmark">
			C&#43;&#43;运算符重载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		运算符重载 运算符重载一、重载‘+’运算符1.非成员函数版本重载2.成员函数版本 二、重载关系运算符三、重载左移运算符四、重载下标运算符五、重载赋值运算符六、重载new和delete1.重载2.内存池 七、重载括号运算符八、重载一元运算符 运算符重载 C++将运算符重载扩展到自定义的数据类型，它可以让对象操作更美观。
例如字符串string用加号（+）拼接，cout用两个左尖括号（&lt;&lt;）输出。
语法：返回值 operator 运算符（参数列表）
非成员函数版本的重载运算符函数：形参个数与运算符操作数个数相同；
成员函数版本的重载运算符函数：形参个数比运算符的操作数个数少一个，其中一个操作数隐式传递了调用对象。
一、重载‘+’运算符 1.非成员函数版本重载 #include&lt;iostream&gt; using namespace std; class CStudent { public: int score; int ID; CStudent(){score=80;ID=0;} void show(){cout&lt;&lt;"ID:"&lt;&lt;ID&lt;&lt;endl;cout&lt;&lt;"分数："&lt;&lt;score&lt;&lt;endl;} }; void operator+(CStudent &amp;s,int a) { s.score=s.score+a; } int main() { CStudent s; operator+(s,1); s.show(); s+2; s.show(); return 0; } 执行结果：
空返回值的运算符重载有个弊端，就是在同一条语句下不能连续使用，如：
如果需要在同一条语句中连续使用，返回值类型不能为空。如下所示：
#include&lt;iostream&gt; using namespace std; class CStudent { public: int score; int ID; CStudent(){score=80;ID=0;} void show(){cout&lt;&lt;"ID:"&lt;&lt;ID&lt;&lt;endl;cout&lt;&lt;"分数："&lt;&lt;score&lt;&lt;endl;} }; CStudent&amp; operator+(CStudent &amp;s,int a)//返回值类型不为空 { s.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4bbac4320a3b53bc5e9b8f2a60f8867/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7997f337ff551b18af02e6fc2f55c1b/" rel="bookmark">
			云原生k8s之资源限制以及探针检查
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、资源限制
1、资源限制的使用
2、request资源（请求）和limit资源（约束）
3、Pod和容器的资源请求和限制
4、官方文档示例
5、资源限制实操
二、健康检查 1、健康检查的定义
2、探针的三种规则
livenessProbe存活探针
readinessProbe就绪探针
startupProbe启动探针（1.17版本新增）
同时定义
3、Probe支持的三种检测方法
exec
tcpSocket
4、探测结果
5、exec方式
6、httpGet方式 7、tcpSocket方式
总结
1、探针
2、检查方式
3、常用的探针可选参数
4、重启策略
一、资源限制 1、资源限制的使用 当定义Pod时可以选择性地为每个容器设定所需要的资源数量。最常见的可设定资源是CPU和内存大小，以及其他类型的资源。
2、request资源（请求）和limit资源（约束） ①当为Pod中的指定了request资源时，调度器就使用该信息来决定将Pod调度到哪个节点上。当还为容器指定了limit资源时，kubelet就会确保运行的容器不会使用超过所设的limit资源量。kubelet还会为容器预留所设的request资源量，供该容器使用
②如果Pod所在的节点具有足够的可用资源，容器可用使用超过所设置的request资源量。不过，容器不可以使用超过所设置的limit资源量。
③如果给容器设置了内存的limit值，但未设置内存的request值，Kubernetes会自动为其设置于内存limit相匹配的request值。类似的，如果给容器设置了CPU的limit值但未设置CPU的request值，则Kubernetes自动为其设置CPU的request值，并使之与CPU的limit值匹配。
3、Pod和容器的资源请求和限制 定义创建容器时预分配的CPU资源 spec.containers[].resources.requests.cpu 定义创建容器时预分配的内存资源 spec.containers[].resources.requests.memory 定义创建容器时预分配的巨页资源 spec.containers[].resources.requests.hugepages-&lt;size&gt; 定义cpu的资源上限 spec.containers[].resources.limits.cpu 定义内存的资源上限 spec.containers[].resources.limits.memory 定义巨页的资源上限 spec.containers[].resources.limits.hugepages-&lt;size&gt; 4、官方文档示例 apiVersion: v1 kind: Pod metadata: name: frontend spec: containers: - name: app image: images.my-company.example/app:v4 env: - name: MYSQL_ROOT_PASSWORD value: "password" resources: requests: memory: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d7997f337ff551b18af02e6fc2f55c1b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa441dc75268bec1081c05b2ea04e185/" rel="bookmark">
			WebRTC架构分析-WebRTC 的线程模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 WebRTC 作为一个实时音视频通信系统，包含了信令控制、音视频传输、音视频采集、音视频编码、音视频解码、音视频渲染等所有功能。由于其功能多样性，注定了系统结构的复杂性，再加上音视频需要做很多编码前后的处理，算法非常复杂，逻辑结构也复杂。为了在复杂网络环境下，保证音视频通信的流畅性，WebRTC 还做了很多流控、带宽预测、拥塞控制算法。
为此，为了降低系统的复杂性，提高系统的运行效率，WebRTC 设计了一套多线程框架，并且做了精心的设计。下来我们就分析一下 WebRTC 中的线程模型。
线程结构图 WebRTC 的线程模型相对复杂一些，哪些模块要在哪些线程下运行，都是有规定的。要想更好的理解 WebRTC 的实现，分析 WebRTC 的线程框架是必不可少的。线程框架结构图如下：
图中每一个矩形框都代表了一个线程，我们这里列出了 11 个线程，当然这些是最主要的线程。线程之间的通信要么是通过图中标出的 Packet 队列，要么是通过 WebRTC 的 MessageQueue 来实现的。图中蓝色的线和橘色的线分别标出了数据包输出和输入时，在各个线程流向情况。
图中标出的信令线程、工作线程、网络线程，WebRTC 是允许定制的。
下来，我们就详细说明一下每一个线程的功能，以及具体代码实现位置。
线程功能说明 信令线程（Signal Thread）
一般是工作在 PeerConnection 层，主要是完成控制平面的逻辑，用于和应用层交互。比如，CreateOffer，SetRemoteSession 等接口都是通过 Signal threa 完成的。默认是采用 PeerConnectionFactory 初始化线程作为信令线程。工作线程（Worker Thread）
主要是工作在媒体引擎层（media engine），具体工作如下: 音频设备初始化视频设备初始化流对象的初始化从网络线程接收数据，传给解码器线程从编码器线程接收数据，传给网络线程网络线程（Network thread ）
主要是工作在传输（transport）层，具体工作如下： Transport 的初始化从网络接收数据，发送给 Worker thread从 Worker thread 接收数据，发送到网络 视频采集线程
主要工作是完成视频原始数据的采集。在 Windows 上，这个线程是由directshow 提供。视频数据接收函数是 CaptureInputPin::Receive，实现文件是 http://sink_filter_ds.cc。视频编码线程
主要工作是对视频的原始数据进行编码，从 Capture 接收 VideoFrame，然后调用编码器执行编码逻辑，将编码后的视频数据发送到 PacerSender。视频编码线程是通过 TaskQueue 实现的，线程名称是 EncodeThread。具体实现位置是 VideoStreamEncoder::TaskQueue，文件名是 video/video_stream_encoder.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa441dc75268bec1081c05b2ea04e185/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab394b37967bb874dc3ec67a9cc089af/" rel="bookmark">
			Java获取UTF-8中文及其它字符串长度代码实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		//utf8字符长度1-6，可以根据每个字符第一个字节判断整个字符长度：
//0xxxxxxx {0x00 ~ 0x7F ASCII 占1个字节}
//110xxxxx 10xxxxxx {0xC0 ~ 0xDF UTF-8 占2个字节}
//1110xxxx 10xxxxxx 10xxxxxx {0xE0 ~ 0xEF UTF-8 占3个字节}
//11110xxx 10xxxxxx 10xxxxxx 10xxxxxx {0xF0 ~ 0xF7 UTF-8 占4个字节}
//111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx {0xF8 ~ 0xFB UTF-8 占5个字节}
//1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx {0xFC ~ 0xFD UTF-8 占6个字节}
//如果一个字节，最高位（第 8 位）为 0，表示这是一个 ASCII 字符（00 - 7F）。可见，所有 ASCII 编码已经是 UTF-8 了。
//如果一个字节，以 11 开头，连续的 1 的个数暗示这个字符的字节数，例如：110xxxxx 代表它是双字节 UTF-8 字符的首字节。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab394b37967bb874dc3ec67a9cc089af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b82f9df49c5bfae5fe724611763c6ef4/" rel="bookmark">
			广度优先搜索（BFS）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注意：本内容主要是介绍用BFS实现图的遍历，所以需要对图的结构有所了解。 一、什么是BFS？ BFS（Breadth First Search，广度优先搜索，又名宽度优先搜索），与深度优先算法DFS往一个方向“死磕到底，不撞南墙不回头”的思维方式不同，广度优先搜索算法关注的重点在于对每一层结点进行下一层的访问。
二、BFS算法介绍 BFS算法和核心思路就是：从某个点一直把其邻接点走完，然后任选一个邻接点把与之邻接的未被遍历的点走完，如此反复走完所有结点。类似于树的层序遍历。
所以，BFS的核心就是要把当前在哪作为一个状态存储，并将这个状态交给队列进行入队操作
算法步骤（用队列实现）
a) 访问指定起始点。
b) 访问当前顶点的邻接顶点有未被访问的顶点，并将之放入队列中。
c) 删除队列的队首节点。访问当前队列的队首，前面的步骤。直到队列为空。
d) 若途中还有顶点未被访问，则再选一个点作为起始顶点。重复前面的步骤（针对非连通图）。
三.、案例图示 我们直接上案例进行说明，就本图而言，其访问顺序可以是：1--2--3--4--5（并不唯一）
遍历图的具体步骤如下：
首先从1开始，1结点处连接着2，3两个结点，所以我们先访问2，3两个结点。同时我们把两个结点按照访问顺序入队，比如，选择2，3为入队顺序，所以之后我们先出队状态2，再来依次访问结点2所连接的4，5两个结点，同样的，按照顺序入队4，5结点，然后操作完状态2之后，我们再出队状态3，并依次访问它的后续，但此时发现3的后续结点已经访问过了，并且检查发现所有的结点都已经被访问完毕，说明遍历结束了。最后我们得到图的遍历次序：1--2--3--4--5
四、相关代码 具体实现遍历图的代码示例：
void BFSL(int pos,pGraph G,int visited[30])//从pos点开始进行广度优先遍历无向图 { int queue[G-&gt;Vnum];//队列辅助BFS遍历 int head=0,tail=0;//队头、队尾指针 Arcnode* p; queue[tail]=pos; visited[pos]=1;//标记遍历过 tail++; while(head!=tail) { pos=queue[head];//出队操作 head++; printf("%d ",pos); p=G-&gt;vertice[pos].firstarc; while(p!=NULL) { if(visited[p-&gt;adjvex]==0)//判断是否遍历过 { queue[tail]=p-&gt;adjvex;//入队操作 visited[p-&gt;adjvex]=1;//标记遍历过 tail++; } p=p-&gt;next; } } } 我们使用BFS解决问题的一般模板如下：
/** * 返回合适的检索数据 */ int BFS(Node root, Node target) { Queue&lt;Node&gt; queue; //创建队列 int step = 0; // 当前队列的步骤点 // initialize add root to queue; // BFS while (queue is not empty) { step = step + 1; //步数逐渐增加 int size = queue.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b82f9df49c5bfae5fe724611763c6ef4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c9629180791464a2af0dc5be3322d61/" rel="bookmark">
			前端-浮动问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		传统网页布局的三种方式：
网页布局的本质—用css来摆放盒子，把盒子摆放到相应位置
Css提供了三种传统布局方式（简单来说，就是盒子如何进行排列顺序）：
普通流（标准流） 浮动 定位
标准流：（普通流/标准流）
所谓标准流：就是标签按照规定好默认方式排列
块级元素会独占一行，从上向下顺序排列 常用元素：div hr p h1-h6 ul ol dl form table
行内元素会按照顺序，从左到右顺序排列，碰到父元素边缘自动换行 常用元素：span a i em 等
以上都是标准流布局，我们前面学习的就是标准流，标准流是最基本的布局方式
这三种布局方式都是用来摆放盒子的，盒子摆放到合适位置，布局自然就完成了。
注意：实际开发中，一个页面基本都包含了这三种布局方式，后面移动端学习新的布局方式。
为什么需要浮动？
提问：我们用标准流能很方便的实现如下效果吗？
1.如何让多个块级盒子（div）水平排列成一行，没有缝隙？
比较难，虽然转换为行内块元素可以实现一行显示，但是他们之间会有大的空白缝隙，很难控制。
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;行内块元素中间有缝隙&lt;/title&gt; &lt;style&gt; * { margin: 0; padding: 0; } div { width: 150px; height: 200px; background-color: pink; display: inline-block; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;1&lt;/div&gt; &lt;div&gt;2&lt;/div&gt; &lt;div&gt;3&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c9629180791464a2af0dc5be3322d61/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82a644653e10386e45fedec066e603ff/" rel="bookmark">
			47:1 error Expected indentation of 2 spaces but found 4 indent 51:35 error Newline required
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		应该是两个空格，敲成了4个
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9bd95e1e25ff8c8f96e76190093debc5/" rel="bookmark">
			Module not found: Error: Can‘t resolve ‘./components/AppAside‘ in ‘C:\Users\13785447213\Desktop\CODE
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		错误原因：
1、大小写错误
2、文件名错误
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf5e2befc346163a76efe320212bd558/" rel="bookmark">
			git 报错Failed to connect to github.com port 443 after 21224 ms: Timed out 解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 git 报错Failed to connect to github.com port 443 after 21224 ms: Timed out 解决办法报错情况报错前提解决办法一：配置http代理解决方法二：配置 SSH 代理Windows 平台Linux 或 Mac OS git 报错Failed to connect to github.com port 443 after 21224 ms: Timed out 解决办法 报错情况 在git clone或者git push时，一直报错Failed to connect to github.com port 443 after xxx ms: Timed out
报错前提 网页可以正常打开github电脑连接VPN 解决办法一：配置http代理 windows 中 git 默认不会使用系统代理，所以即使连接代理或者打开代理软件，浏览器仍然可以访问 GitHub 或 Gitee；但是使用 git 命令行连接 GitHub 或 Gitee 远程仓库可能会出现无法访问的现象。通过为 git 配置代理解决出现的问题。 Windows、Linux、Mac OS 中 git 命令相同：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf5e2befc346163a76efe320212bd558/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c72e1c90430fee0b3d1fb8b6f6ac1d1c/" rel="bookmark">
			【计算机组成原理】IEEE 754
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		移码的定义 移码=真值+偏置值(使用补码计算)
一般情况下8位移码偏置值为2n-1
十进制(原码)原码反码补码移码-0（-128）1000 00001111 11111000 00000000 0000-2^7-11111 11111000 00001000 00010000 0001-2^7-21111 11101000 00011000 00100000 0002-21000 00101111 11011111 11100111 1110-11000 00011111 11101111 11110111 1111+00000 00000000 00000000 00001000 000010000 00010000 00010000 00011000 000120000 00100000 00100000 00101000 00102^7-20111 11100111 11100111 11101111 11102^7-10111 11110111 11110111 11111111 1111 IEEE 754 该定义的偏置值为：2n-1-1
即为：0111 1111 B
真值=-128
移码=1000 0000 + 0111 1111 = 1111 1111
真值=-127
移码=1000 0001 + 0111 1111 = 0000 0000
十进制(原码)补码移码-0（-128）1000 00001111 1111-2^7-11000 00010000 0000-2^7-21000 00100000 0001-21111 11100111 1101-11111 11110111 1110+00000 00000111 111110000 00011000 000020000 00101000 00012^7-20111 11101111 11012^7-10111 11111111 1110 IEEE 754如下表示
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c72e1c90430fee0b3d1fb8b6f6ac1d1c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22975a40c34a82ecbe67c58f0b5f5ead/" rel="bookmark">
			1053 住房空置率(python)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		n,e,d = input().split() q = 0 qq = 0 qqq = 0 for i in range(int(n)): a,*s = input().split() sum = 0 for j in s: if float(j) &lt; float(e): sum += 1 if sum &gt; int(a) // 2 and int(a) &gt; int(d): q += 1 elif sum &gt; int(a) // 2: qq += 1 qs = round(q / int(n) * 100,1) qqs = round(qq / int(n) * 100,1) print(f"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/22975a40c34a82ecbe67c58f0b5f5ead/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b793bdb5a970f4b4a093ce66759719c/" rel="bookmark">
			华为eNSP实现企业内网双出接口访问外网（VRRP、MSTP、DHCP、NAT-easy IP、nat server、ACL）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、背景介绍 Xan20公司新建了一栋办公大楼作为分公司，为了满足日常的办公需求，公司决定为财务部、项目管理部、技术部、行政部和服务器群建立互联互通的有线网络。其中，为方便各部门开展业务，需要自动获取公司DHCP服务器的IP地址；公司内部需要一台服务器，满足各部门上传下载文件；总部可以通过外网访问公司分部的WEB服务器，并且总部的网络管理员可以远程登录管理分公司网络设备；公司已经申请了两条不同运营商互联网专线并配有公网IP地址，希望除财务部不能访问Internet外，其他部门都能访问Internet；后期规划所有设备由网络管理员进行远程管理。
二、项目需求分析
DHCP服务器通过接入交换机连接到核心交换机上采用一条链路互连。服务器群连接到核心交换机，两台核心交换机配置端口聚合，以防止单链路出现故障。财务部、项目管理部、技术部、行政部和服务器群处于不同区域，各部门的接入交换机连接到两台核心交换机，当上行链路出现故障时，可以通过另一条链路到达核心交换机区域。核心交换机区域上做两台核心冗余备份，以防止其中一台核心交换机出现故障，可以通过另一台核心交换机转发数据连接外网。采用以上连接方式时，多台交换机会形成环路，可以采用生成树技术解决该问题。
为方便员工获取DHCP服务器的IP地址，财务部、项目管理部、技术部和行政部可以采用DHCP方式配置IP地址池自动分配IP地址及DNS地址。
服务器群交换机、核心交换机和出口路由器均采用三层互连，可以配置动态路由协议自动学习路由，实现全网互连互通。
Xan20的分公司配有两个不同运营商的公网IP地址，除财务部以为，其他部门的所有员工都有访问Internet的需求，可以在出口路由器上配置NAT。
为方便网络管理员对设备进行远程管理，需要启用所有设备的Telnet服务。
综上所述，本项目的实施具体分为以下工作任务。
1.根据网络拓扑及项目需求分析，对本项目进行详细规划设计。
（1）实现PC通过DHCP动态获取地址参数
（2）实现PC访问服务器
（3）核心层交换机做链路聚合
（4）网关冗余方案实施
（5）实现二层线路冗余备份
（6）实现内网访问外网
（7）外网访问内网WEB服务器
（8）实现外网远程登录管理
2.根据规划完成设备的调试。
3.测试项目能否达到预期效果
三、项目要求 1. 公司不同部门的PC属于不同的网段
2. 实现各部门PC通过DHCP地址获取参数
3. 实现各部门PC能够访问WEB服务器
4. 冗余网关备份（VRRP）
5. 实现二层网络链路冗余备份
6. 核心层交换机做链路聚合
7. 实现公司内网访问外网
8. 实现外网设备访问内网服务器
9.实现远程访问telnet技术
四、拓扑搭建 五、项目实施步骤 步骤一：
（一）实现PC通过DHCP动态获取地址参数；实现PC访问WEB服务器
为方便各部门开展业务，需要自动获取公司DHCP服务器的IP地址，由于DHCP服务器和DHCP客户端不在同一网段，需要在核心交换机上开启DHCP中继功能；为提高链路可靠性，在核心交换机配置链路聚合。
搭建拓扑图 交换机配置 （1）所有交换机创建VLAN10、20、30、40、66、88
[SW1]vlan batch 10 20 30 40 66、88
[SW2]vlan batch 10 20 30 40 66、88
[SW3]vlan batch 10 20 30 40 66、88
[SW4]vlan batch 10 20 30 40 66、88
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b793bdb5a970f4b4a093ce66759719c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b577a7722cd1857cba18dae0acb92ee/" rel="bookmark">
			【2023最新版】Spring Cloud面试题总结（35道题含答案解析）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录
1、什么是Spring Cloud？
2、使用Spring Cloud有什么优势？
3、服务注册和发现是什么意思？Spring Cloud如何实现？
4、负载平衡的意义什么？
5、什么是Hystrix？它如何实现容错？
6、什么是Hystrix 断路器？我们需要它吗？
7、什么是Netflix Feign？它的优点是什么？
8、什么是Spring Cloud Bus？我们需要它吗？
9、SpringBoot和SpringCloud的区别？
10、Spring Cloud和SpringBoot版本对应关系
11、SpringCloud由什么组成
12、使用 Spring Boot开发分布式微服务时，我们面临什么问题？
13、Spring Cloud和dubbo区别?
Eureka
14、服务注册和发现是什么意思？Spring Cloud如何实现？
15、什么是Eureka？
16、Eureka怎么实现高可用
17、什么是Eureka的自我保护模式？
18、DiscoveryClient的作用
19、Eureka和ZooKeeper都可以提供服务注册与发现的功能,请说说两个的区别？
Zuul
1、什么是网关?
2、网关的作用是什么？
3、什么是Spring Cloud Zuul（服务网关）
4、网关与过滤器有什么区别？
5、常用网关框架有那些？
6、Zuul与Nginx有什么区别？
7、既然Nginx可以实现网关？为什么还需要使用Zuul框架
8、如何设计一套API接口？
9、ZuulFilter常用有那些方法？
10、如何实现动态Zuul网关路由转发？
11、Zuul网关如何搭建集群？
Ribbon
1、负载平衡的意义什么？
2、Ribbon是什么？
3、Nginx与Ribbon的区别？
4、Ribbon底层实现原理？
Hystrix
1、什么是断路器？
2、什么是Hystrix？
3、谈谈服务雪崩效应？
4、在微服务中，如何保护服务?
5、服务雪崩效应产生的原因
6、谈谈服务降级、熔断、服务隔离
7、服务降级底层是如何实现的？
Feign
1、什么是Feign？
2、SpringCloud有几种调用接口方式？
3、Ribbon和Feign调用服务的区别？
Bus
1、什么是 Spring Cloud Bus？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b577a7722cd1857cba18dae0acb92ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c92634ebf37fdfe1823756c22a3646a7/" rel="bookmark">
			在windows上部署jenkins
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. Jenkins介绍
Jenkins是一个开源软件项目，是基于Java开发的一种持续集成工具，用于监控持续重复的工作，旨在提供一个开放易用的软件平台，使软件项目可以进行持续集成。
2. Jenkins的功能
持续的软件版本发布/测试项目。监控外部调用执行的工作。 3. Jenkins实现的思路
1、开发人员将对应的代码编写完毕之后，将对应的分支提交到集成代码库（Git或者SVN)
2、在Jenkins创建服务项目
3、发布项目人员点击【构建版本】从Git或者SVN上拉取最新代码分支
4、编译代码并打包成war包
5、通过脚本发布到对应的容器中（tomcat/weblogic），并启动项目
4. Jenkins的下载路径 在使用Jenkins时一定要先安装JDK环境，百度一大把
在windows系统上搭建jenkins持续集成有两种方法：
1、war文件，可以用tomcat或者java命令直接运行2、msi安装，作为系统服务后台运行 war文件
下载地址：http://mirrors.jenkins-ci.org/war/latest/jenkins.war
下载放到Tomcatwebapps目录下，启动tomcat即可
或者用命令
java -jar jenkins.war msi安装
下载地址：http://ftp.yz.yamagata-u.ac.jp/pub/misc/jenkins/windows-stable/ 选择最新的下载，然后一键安装即可。
5. Jenkins安装及启动
Jenkins默认端口是8080，启动后可以直接访问 IP:8080 就可以访问进去了。如果想要改端口，我们可以修改Jenkis的xml文件。
第一次登录会要求登录密码，直接按照给的路径去找即可。
然后按照向导去操作就好了，最后就会进入到这个页面。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4b6891b75c7cfb29cb7bf7aa15d3fc3/" rel="bookmark">
			【NLP论文翻译】Learning Opinion Summarizers by Selecting Informative Reviews
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本博客为博主论文阅读记录，原论文和github代码地址如下：
论文：https://arxiv.org/abs/2109.04325
代码：https://github.com/abrazinskas/SelSum
英国爱丁堡大学Mirella Lapata教授：
个人主页：https://homepages.inf.ed.ac.uk/mlap/index.php?page=index
dblp：https://dblp.uni-trier.de/pid/59/6701.html
仅供学习，请勿转载。如有侵权，请联系作者删除。
Learning Opinion Summarizers by Selecting Informative Review 摘要
意见摘要传统上是采用无监督、弱监督和小样本学习进行的。在这项工作中，我们收集一个包含超过31000个产品的用户评论的大量摘要数据集，从而实现了有监督学习。然而，每个产品的评论数量很大（平均320条），这使得摘要——尤其是训练一个摘要器（总结器）——不切实际。此外，许多评论的内容没有反映在人类的书面摘要中，因此，根据随机评论子集训练的摘要器会产生幻觉。为了应对这两个挑战，我们制定了一项任务，即联合学习选择信息丰富的评论子集，并对这些子集中表达的意见做摘要。所选择的评论子集被视为一个潜在变量，由一个小而简单的选择器预测。然后将子集输入到一个更强大的摘要器中。对于联合学习，我们使用摊销变分推理和策略梯度方法。我们的实验证明了选择信息性评论的重要性，从而提高了摘要质量并减少幻觉。
joint learning：将多个子模型集成为一个模型，完成最终的目标任务。（参考：Joint Learning 与 Multi-Task Learning浅析）
amortized variational inference：（参考：Variational Inference with Normalizing Flows翻译）
policy gradient methods：策略梯度法PG（参考：强化学习七、强化学习系列（十三）：Policy Gradient Methods）
1 Introduction 在线资源（如博客、评论、社交媒体或互联网论坛）中表达的用户意见摘要因其潜在的各种信息访问应用（如创建摘要、搜索和报告生成）而备受关注。尽管在非主观文本中的有监督摘要（如新闻文章）中观察到了重大进展，目前的深度学习方法依赖于大量注释数据，这样的数据在意见摘要领域并没有现有数据并且制作成本高昂。具体而言，带注释的数据集范围从50到200个带注释的产品。
之前由于缺乏大量高质量的有监督学习资源，便需要创造性的解决方案。将无监督和弱监督方法应用于意见摘要已有很长的历史。
在这项工作中，我们引入了最大的多文档意见摘要数据集AMASUM，包括对31000多种亚马逊产品的总结、优点和缺点。这些摘要由专业的产品评论员撰写，指导在线使用者做出更好的购买决策。相应地，每个产品平均链接320多个评论。然而，这实际上不可能使用标准硬件来训练传统的编码器-解码器模型（encoder-decoder model）。此外，并非所有评论都涵盖了摘要内容。因此，如我们将在第5.2节中实证证明的那样，基于随机评论子集预测摘要的训练会导致幻觉。这需要专门的方法来选择相关评论的较小子集，并将其提供给摘要器。我们通过引入SELSUM来探索这一方向，联合学习使用摊销变分推理和政策梯度优化来选择和摘要评论子集。
为了在训练中选择相关的评论子集，我们利用摘要来预先计算词汇特征。然后，我们用一个只有0.1%深度编码器参数的小神经选择器来评分评论相关性。与深度编码器表示相反，这些简单的特性允许我们从大型集合中选择评论，而无需大量的计算负担。随后，只有选定的评论被“昂贵”的编码器编码，以便预测摘要。为了在测试时选择质量好的评论子集，当摘要不可用时，我们使用另一个神经选择器来近似摘要相关性。在我们的实验中，我们展示了准确的评论选择的重要性，影响了训练中的摘要器及其测试中的输出。此外，我们表明我们的模型在ROUGE分数和内容保真度方面优于其他方案。总的来说，我们的贡献可以概括为以下几点：
我们为多文档意见摘要提供了最大的数据集我们提出了一个端到端的模型，选择和总结评论我们从经验上证明了我们的模型优于替代方案 ROUGE:
参考：（NLP评估指标之ROUGE）
2 Dataset 该数据集（AMASUM）基于专业评论员用英语编写的消费产品摘要。我们专注于四种主要的专业产品评论平台：bestreviews.com (BR); cnet.com; pmag.co.uk (PM); runrepeat.com (RR)。前三家主要为电子产品提供内容，而最后一家则为运动鞋提供内容。这些摘要提供了产品的快速概览，以帮助用户进行明智的购买。与亚马逊等公共平台上的客户评论员不同，专业评论员专注于高质量的写作，并有意利用许多信息来源。这些来源包括在公共平台上阅读客户评论、进行在线调查、向专家用户征求意见以及测试产品。一般来说，摘要有两种形式。第一个是总结（verdicts），通常是几句话，说明产品最重要的要点。第二个是优点和缺点，其中介绍了产品最重要的正面和负面细节。这些往往更详细，并侧重于细粒度的产品方面，如蓝牙连接、分辨率和CPU时钟速度。
随着内容提供商争夺在线用户，摘要是用户想要的，而不是研究人员认为用户想要的。这与众包(crowd-sourcing)形成了对比，在众包中，研究人员偏向根据员工的写作过程去假设什么是好的摘要。这些假设很少通过市场调查或用户测试来验证。反过来，这导致了即使在同一领域，总结风格和组合也存在很大差异。
2.1 Content Extraction 我们为每个平台编写了HTML爬取程序，并提取了包含判决和利弊的片段。此外，从广告链接中，我们提取了亚马逊标准标识号（ASIN），它允许我们识别哪些被评论的亚马逊产品并将摘要链接到亚马逊产品目录。
我们使用各种付费服务来获取亚马逊评论和产品元数据。我们获取了所有产品的经过验证的评论，并且仅对于不受欢迎的产品（&lt;50条评论）利用了未经验证的评论。我们还利用了公开可用的亚马逊评论数据集。
该论文中的评论数据是“爬”的
2.2 Filtering 我们删除了所有少于10个单词、超过120个单词的评论。我们还删除了所有评论少于10条的不受欢迎的产品。此外，我们删除了所有少于5个单词的摘要，以及所有缺少优点和缺点的摘要。表2显示了将我们的最终数据集与可用备选方案进行比较的总体统计数据。我们的数据集在摘要数量及其相关评论方面远大于备选方案。
从数据集说明中可以看出，本文中做的有监督意见摘要适用于多个短文本的情况（产品评价、电影评论、美食评价等）
2.3 Summary Statistics 如表3所示，我们分析了来自不同平台的摘要，包括其长度和关于评论的ROUGE召回。首先，总结（verdicts）往往比优点和缺点意见更短，集中在较少的方面。他们还表现出与用户评论更高的词重叠，如较高的ROUGE分数所示。我们还观察到，优点缺点倾向于集中在特定的产品特性，这些特性通常可以在产品元信息（产品描述、特性项目列表）中找到。我们认为，缺点往往比优点短，主要是因为大多数总结产品的评分很高（平均4.32/5.0）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f4b6891b75c7cfb29cb7bf7aa15d3fc3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e83da5fd7d275872003249bda63326f0/" rel="bookmark">
			解决Eclipse中没有SVN的情况
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述：
​​​​​​​我们想使用SVN向SVN服务器上传代码，但Eclipse默认情况下却没有SVN选项，如下图所示。
解决办法：
第一步：如下图所示。
第二步：在"Find"搜索框中输入"subclipse"然后回车进行搜素，搜索完后可以看到如下图所示的搜索结果，我们安装"Subclipse 1.10.13"，点击"install"。
第三步：我们使用默认全选，点击"Confirm"。
第四步：选择"I accept the terms of the license agreements"。然后点击"Finish"。
第五步：安装过程中会有警告，我们直接点击"OK"即可。
第六步：安装完插件之后，我们需要重启Eclipse，点击"Yes"。
第七步：Eclipse重新打开后，会有如下图所示的提示框，我们直接点击"OK"即可。
第八步，重新打来eclipse 查看svn选项已经存在
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/210/">«</a>
	<span class="pagination__item pagination__item--current">211/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/212/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>