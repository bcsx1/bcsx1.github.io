<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b85e8b0f92021845e188ce5a56e6bb8/" rel="bookmark">
			placement new
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 重载new和deleteoperator new接口和operator delete接口malloc函数与free函数 placement new表达式new VS placement new什么时候使用placement new？怎么删除通过placement new分配的内存使用placement new的优点显式的析构函数调用 重载new和delete 重载new和delete，与重载其他运算符的过程大不相同。
当我们使用一条new表达式时：
string* sp = new string("a value");	//分配并初始化一个string对象 string* arr = new string[10];	//分配10个默认初始化的string对象 实际上执行了三步操作。第一步，new表达式调用一个名为operator new（或者operator new[]）的标准库函数。该函数分配一块足够大的，原始的，未命名的内存空间以便存储特定类型的对象（或者对象的数组）。第二部，编译器运行相应的构造函数以构造这些对象，并为其传入初始值。第三步，对象被分配了空间并构造完成，返回一个指向该对象的指针。
当我们使用一条delete表达式删除一个动态分配的对象时：
delete sp;	//销毁*sp,然后释放sp指向的内存空间 delete[] arr;	//销毁数组中的元素,然后释放对应的内存空间 实际上执行了两步操作。第一步，对sp所指向的对象或者arr所指向的数组中的元素执行对应的析构函数。第二部，编译器调用名为operator delete（或者operator delete[]）的标准库函数释放内存空间。
如果应用程序希望控制内存分配的过程，则它们需要定义自己的operator new函数和operator delete函数。即使在标准库中已经存在这两个函数的定义，我们仍旧可以定义自己的版本。编译器不会对这种重复定义提出异议，相反，编译器将使用我们自定义的版本替换标准库定义的版本。
当自定义了全局的operator new函数和operator delete函数后，我们就担负起了控制动态内存分配的职责。这两个函数必须是正确的：因为它们是程序整个处理过程中至关重要的一部分。
应用程序可以在全局作用域中定义operator new函数和operator delete函数，也可以将它们定义为成员函数。当编译器发现一条new表达式或delete表达式后，将在程序中查找可供调用的operator函数。如果被分配（释放）的对象是类类型，则编译器首先在类及其基类的作用域中查找。此时如果该类含有operator new成员或operator delete成员，则相应的表达式将调用这些成员。否则，编译器在全局作用域中查找匹配的函数，此时如果编译器找到了用户自定义的版本，则使用该版本执行new表达式或delete表达式；如果没找到，则使用标准库定义的版本。
我们可以使用作用域运算符令new表达式或delete表达式忽略定义在类中的函数，直接执行全局作用域中的版本。例如，::new只在全局作用域中查找匹配的operator new函数，::delete与之类似。
operator new接口和operator delete接口 标准库定义了operator new函数和operator delete函数的8个重载版本。其中前4个版本可能抛出bad_alloc异常，后4个版本则不会抛出异常。
//这些版本可能抛出异常 void* operator new(size_t);	//分配一个对象 void* operator new[](size_t);	//分配一个数组 void* operator delete(void*) noexcept;	//释放一个对象 void* operator delete[](void*) noexcept;	//释放一个数组 //这些版本承诺不会抛出异常 void* operator new(size_t, nothrow_t&amp;) noexcept; void* operator new[](size_t, nothrow_t&amp;) noexcept; void* operator delete(void*, nothrow_t&amp;) noexcept; void* operator delete[](void*, nothrow_t&amp;) noexcept; 类型nothrow_t是定义在new头文件中的一个struct，在这个类型中不包含任何成员。new头文件还定义了一个名为nothrow的const对象，用户可以通过这个对象请求new的非抛出版本。与析构函数类似，operator delete也不允许抛出异常。当我们重载这些运算符时，必须使用noexcept异常说明符指定其不抛出异常。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b85e8b0f92021845e188ce5a56e6bb8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0817564e08c0b1907a38bc68c3f1af9a/" rel="bookmark">
			RS锁存器和RS触发器（个人理解）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、RS锁存器二、RS触发器三、两者总结和区分 一、RS锁存器 RS锁存器，电平触发，随输入随时变化，可由 或非门组成 或 与非门组成。
这是数电教材上的或非门组成的RS锁存器
如图可见
输出是随输入随时变化的，和时钟无关
真值表
RSQ00Q11X011100 可以看到
（一）当R端可S端都为0时，它是保持上次输出不变的，这也是它的锁存特性（？）
（二）当R端和S端都为1时，就会让电路进入一个危险的状态，推导可知，此时输出 Q 和 Q非 均为0，但由于实际电路的延迟，S端和R端不可能同时变为0，就会出现不确定值，故R端和S端都为1时称为非法状态，设计电路时应避免这个状态
（三）当R端为0，S端为1，由电路图可知，Q始终为1，故称S端为置位端（置1端）
（四）当R端为1，S端为0，由电路图可知，Q始终为0，故称R端为复位端（置0端）
当然，从置位端和复位端的称谓来看，也不能让两者同时有效（同时为1），这也没有实际上的意义。
二、RS触发器 RS触发器，这里我讲的是电平触发的RS触发器（与非门）
这是书上的图
真值表
CLKRSQ0XXQ100Q10111100111X 由图表可知
（一）RS触发器高电平触发，当CLK为0时，输出不变
（二）当CLK为1，输入都为0时，输出不变，这是触发器的特性（？）
（三）当CLK为1，R端为0，S端为1时，Q端为1，S端为置位端
（四）当CLK为1，R端为1，S端为0时，Q端为0，Q端为复位端
（五）当CLK为1，输入都为1时，输出不稳定
三、两者总结和区分 实际上个人对两者实际上到底是怎么样的，也不是太清楚，不敢说绝对了
共性：
（一）都有存储数据的功能
（二）都由与非门 或 或非门 组成
（三）真值表除CLK外，实际上是一样的（可能是巧合，上述的RS锁存器由或非门组成，RS触发器由与非门组成）
（四）都是时序逻辑
差异：
（一）RS触发器电平敏感（加了一个CLK信号），RS锁存器随输入变化随时变化（根据真值表）
这是个人在收集RS触发器和RS锁存器相关资料时遇到的，因为看了很多博客发现不太对劲，参照了教材上的内容做出的一点总结。
有不对的地方请大佬指出来，万分感谢
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e2ce6a37e7a067fb889ea099130a51f/" rel="bookmark">
			c&#43;&#43;之位运算（详解，初学者绝对能看懂）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一 位运算符号
移位运算：
二 常用技巧：
三 运算符号优先级：
四 位运算常用技巧
1 判断奇偶性
2 求a的b次方
3 找处未重复的数
4 用O(1)时间检测整数n是否是2的幂次.
5 计算在一个 32 位的整数的二进制表示中有多少个 1
6 快速幂
7 二进制状态压缩
8 二进制优化递归
9 一道经典题
一 位运算符号 &amp;
按位与
如果两个相应的二进制位都为1，则该位的结果值为1，否则为0
|
按位或
两个相应的二进制位中只要有一个为1，该位的结果值为1
^
按位异或
若参加运算的两个二进制位值相同则为0，否则为1
~
取反
~是一元运算符，用来对一个二进制数按位取反，即将0变1，将1
举例：
1000101 1000101 1000101 1000101
&amp; 0101100 | 0101110 ~ ^ 0101110
= 0000100 = 1101111 = 0111010 1101011
移位运算： &lt;&lt;
左移
用来将一个数的各二进制位全部左移n位，低位以0补充，高位越界后舍弃。
1左移n位： 1 &lt;&lt; n=2^n(这里指2的n次方)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e2ce6a37e7a067fb889ea099130a51f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6060ec3091135871482c7f8c678fafd9/" rel="bookmark">
			pycharm设置pytest使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e18ab6057ed35f56ac3ac4c21756d5ca/" rel="bookmark">
			Unity（设置鼠标指针贴图）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 步骤
1、先将需要设置的图片更改为Cursor格式
2、查看图片比例，更改图片显示大小
3、代码更改
使用方法
Cursor.SetCursor(Texture 2D,Vector2(鼠标点击偏移量),CursorMode); ​​​​​​​ ​​​​​​​ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef780bf4c1ad7067479990a21c0e88b8/" rel="bookmark">
			轻松学会Python turtle库的运用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、turtle简单介绍 1.Turtle库是python语言中一个很流行的函数库，基于thinker模块打造，提供一些比较简单的绘画工具，通过一组或多组函数指令的控制，在坐标系中移动，绘制图形 2.Turtle库近年来也多被用于新手学习python的一种方式 二、Turtle基础知识 1.创建窗口（或画布Canvas） 1.1画布为我们用来展开绘图区域，可以选择它的大小和初始位置 大小turtle.screensize(canvwidth=None, canvheight=None, bg=None)
canvwidth:画布的宽(单位像素，默认值400)
canvheight:画布的高(单位像素，默认值300)
背景颜色
1|t.screensize(800,600,'blue') 2|turtle.setup(width=0.5, height=0.75, startx=None, starty=None) 2、画笔(pen) 2.1画笔（pen)的设置包括画笔属性(如尺寸、颜色)和画笔状态。Turtle模块已经定义了画笔属性和状态的函数。 (1)设置画笔属性 pensize(&lt;width&gt;) #设置画笔尺寸 speed(speed) #设置画笔移动速度 color(color) #设置画笔颜色 width()函数是pensize()函数的别名，它们具有相同的功能。
speed()函数的参数speed用于设置画笔移动的速度，其取值范围为[0,10]内的整数。数值越大，速度越快。
color()函数的参数用于设置画笔颜色，该参数值有以下几种表达方式:
-字符串，如"red",“orange”,“yellow”,“green”。
-RGB颜色，又分为RGB整数值和RGB小数值两种，整数值如(255,255,255),(190,213,98),小数值如(1,1,1),(0.65,0.7,0.9)。
-十六进制颜色,如"#FFFFFF","#0060F6"
-常见颜色表示方法及其对应关系
(2)画笔状态及相关函数 Turtle库中画笔分为提起(UP)和放下(DOWN)两种状态
import turtle turtle.penup() #提起画笔 turtle.pendown() #放下画笔 turtle.done() turtle模块中penup()和pendown()函数定义了别名，penup()函数的别名为pu(),pendown()函数的别名为pd()。
3.绘制图形 3.1Turtle模块中画笔分为移动控制、角度控制、图形控制和图形填充3种。 (1)移动控制 移动控制函数控制画笔向前、向后移动
foward(distance) #向前移动 backward(distance) #向后移动 goto(x,y=None) #移动到指定位置 函数forward()和backward()的参数distance用于指定画笔移动的距离，单位为像素；函数goto()用于将画笔移动到画布上指定的位置，该函数可以使用参数x、y分别接受表示目标位置的横坐标和纵坐标，也可以接受一个表示坐标向量的参数。
(2)角度控制 角度控制函数可以更改笔画朝向
right(degree) #向右移动 left(degree) #向左移动 seth(angle) #转动到某个方向 函数right()和left()的参数degree用于指定画笔向右和向左转动的角度。函数seth()的参数angle用于设置画笔在坐标系中的角度。angle以x轴正向为0°，以逆时针为正，角度从0°逐渐增大；以顺时针方向为负，角度从0°逐渐减小。
若要使画笔向右或向左移动某段距离，应先调整画笔角度，在使用移动函数。
绘制边长为100像素的正方形
import turtle as t t.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef780bf4c1ad7067479990a21c0e88b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80f968efbf15ea16c2c8435004856b68/" rel="bookmark">
			uniapp启动页，底部虚拟按钮向上闪一下的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		manifest.json “app-plus” -&gt; “distribute” -&gt; "splashscreen节点
新增 “androidTranslucent”: true 可以解决此问题
转载：https://ask.dcloud.net.cn/question/121410
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e00876a5fb2ae8d346e9b9bc6fa81b21/" rel="bookmark">
			RGBA代表什么意思?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		R:代表红色，G:代表绿色，B:代表蓝色，A:代表alpha值。
前三个值的取值范围在 0-255之间，A的取值范围在 0-1之间，可以是小数。
A的值规定色彩的透明度，0：完全不透明，0.5：半透明，1：完全透明。
例如：纯绿色：rgba(0,255,0) 透明度看自己需要什么就写什么即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d48cd701861ecad8e4ef499fa74c078d/" rel="bookmark">
			PCB的流程化设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 器件封装的导入及常见问题解决找不到对应的封装识别不到管脚号 板框大小 层数的评估及24层板的优缺点对比板框大小的评估层数的评估二四层优缺点的对比 四层板的叠层及正负片介绍PCB模块化及布局思路分析接插件固定器件的摆放及固定孔接插件固定器件固定孔 局部模块化布局及布局优化PCB布线常用Class创建及规则设置PCB的扇孔PCB敷铜及编辑Altium 19 Activeroute自动布线介绍PCB的快速布线一级目录 器件封装的导入及常见问题解决 新建PCB文件：【文件】-【新的】-【PCB】
找不到对应的封装 导入器件：【设计】-【Import Changes From …】
接下来会有以下界面：
解决办法如下：
点击上述图片中的【报告变更】-【导出】
就会导出一个Excel表格，如下：
之后我们根据表格中的内容对封装进行更正。
以表格中的J7为例：
打开原理图，快捷键【J】+【C】,快速查询元件
找到需要修改的元件后，鼠标左键双击，在跳出的界面中进行以下操作：
即可完成修改。
小结
一般常见的问题是“封装名与原理图中的名字不对应”或者“封装库中没有元件相对应的封装”，具体问题还需具体对待，可以通过bom表对封装名进行查询。
识别不到管脚号 下面我们再进行第二次导入：
常见问题及解决办法：
没有填写封装名字 出现上述问题先定位相关元件，再检查其封装有没有填写。
元件库中，将管脚名字和管脚序号写反了；或者是删除了管脚号 先定位相关元件，再将相应管脚修改正确即可。
常见于二极管，正极管脚号用A表示，负极管脚号用K表示时，管脚号不匹配 原理图中的管脚号与焊盘上的管脚号应该是一致的，所以将原理图中的元件管脚号修改成与焊盘中一致的即可。
板框大小 层数的评估及24层板的优缺点对比 板框大小的评估 将器件全部选中再点击【工具】-【器件摆放】-【在矩形区域排列】将所有器件摆放紧密（一般以正方形排列）
隐藏飞线【V】-【C】在机械层画线，进行框选，【编辑】-【原点】-【设置原点】，设置原点，再对边框大小进行调节，注意：一般都设置为整数。
层数的评估 默认是两层
看飞线最密集的地方需要几层，评估最密的地方，一般为MCU处，
有BGA的板子，评估：测量焊盘间距，判断可以走几条线，进而再判断需要几层板子
在原有基础上再添加两层
一层规划成电源，一层规划成地
【设计】-【类…】
四层板有一个完整的地平面
加两个层
【设计】-【层叠管理器】
右击，添加新的平面层即可
添加一个完整的地平面
【设计】-【板子形状】-【根据板子外形生成线条】
再点击快捷键【D】【S】【D】
这样可以有效减短回流路径
二四层优缺点的对比 层数越多，走线越容易，能用两层的情况下，最好用四层
层数越多，生产成本越高
层数越多，设计越简单
四层板的叠层及正负片介绍 层数的添加：【设计】-【层叠管理器】
快捷键：【D】+【K】
在PCB板中，
正片：画线（红）的地方是有铜的，其他地方是无铜的；信号层，小电源
负片：画线（绿）的地方是无铜的，其他地方是有铜的。地，大电源（需要大面积铺铜的）
PCB模块化及布局思路分析 对器件进行布局：（模块化布局）
在【菜单栏】空白处，右击，选择【垂直分割】；
为保证原理图中的元件与PCB板中的元件同时被选中，我们进行如下操作，首先，切换到PCB界面中，点击【工具】-【交叉选择模式】，再切换到原理图界面中，再次重复之前的步骤，保证两个界面中的都选择了交叉选择模式；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d48cd701861ecad8e4ef499fa74c078d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48c5b1837a17cadeb899d22d07b743ad/" rel="bookmark">
			【解决】office 2010 无法加载 endnote
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 问题描述 装好endnote之后，按照配置教程给word 2010 配置endnote
word2010如何加载endnote
但是word中始终不会出现endnote插件
正常应该如下图
解决方法 试了多种网上的方法依然不行
我发现，在选择的时候，有如下字样
用户已选择禁止宏，估计是这里出现了问题
于是百度搜索用户已选择禁止宏
搜到下面这篇文章
关于word2010加载项宏禁用
按照这篇文章的方法，我解决了问题
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c6ef76d1ebbc6f17cc5619414ade21d/" rel="bookmark">
			RK Android11 系统常见修改
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系统常见修改：
去除系统锁屏：
frameworks/base diff --git a/packages/SettingsProvider/res/values/defaults.xml b/packages/SettingsProvider/res/values/defaults.xml old mode 100644 new mode 100755 index 761d8bcbed00..227d5e1c1dbb --- a/packages/SettingsProvider/res/values/defaults.xml +++ b/packages/SettingsProvider/res/values/defaults.xml @@ -82,7 +82,7 @@ &lt;integer name="def_max_sound_trigger_detection_service_ops_per_day" translatable="false"&gt;1000&lt;/integer&gt; &lt;integer name="def_sound_trigger_detection_service_op_timeout" translatable="false"&gt;15000&lt;/integer&gt; - &lt;bool name="def_lockscreen_disabled"&gt;false&lt;/bool&gt; + &lt;bool name="def_lockscreen_disabled"&gt;true&lt;/bool&gt; 设置默认语言为中文：
build/target/product/full_base.mk PRODUCT_LOCALES := zh_CN 修改默认休眠时间：
frameworks\base\packages\SettingsProvider\res\values\defaults.xml &lt;integer name="def_screen_off_timeout"&gt;60000&lt;/integer&gt; 修改默认亮度：
frameworks\base\packages\SettingsProvider\res\values\defaults.xml 或者 common/overlay/frameworks/base/packages/SettingsProvider/res/values/defaults.xml &lt;integer name="def_screen_brightness"&gt;102&lt;/integer&gt; 默认关闭提示音：
diff --git a/packages/SettingsProvider/res/values/defaults.xml b/packages/SettingsProvider/res/values/defaults.xml index a7ec5a3ea3f6..e2a65a1878bf 100755 --- a/packages/SettingsProvider/res/values/defaults.xml +++ b/packages/SettingsProvider/res/values/defaults.xml @@ -136,7 +136,7 @@ &lt;!-- Default for DTMF tones enabled --&gt; &lt;bool name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c6ef76d1ebbc6f17cc5619414ade21d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46671a2e621566d52f49c5adc89b24ea/" rel="bookmark">
			python学习第四章习题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 4-10
#4-10 a = ['dsf','hhh','flfll','5550','7788'] print(a[0:3]) print(a[1:4]) print(a[-3:]) 4-11
pizzas = ['番茄披萨','芝士披萨','水果披萨'] friend_pizzas = pizzas[:] pizzas.insert(3,'烤肉披萨') #插入方式：append()和insert() friend_pizzas.append('玉米披萨') print(f"My favorite pizza is:") for pizza in pizzas: print(pizza) print(f"But,My friend favorite pizza is:") for friend_pizza in friend_pizzas: print(friend_pizza) 4-5元组
foods = ('烤肉','油焖大虾','牛排','火锅','清蒸鲫鱼') #foods[2] = '地锅鸡' print(f'origanl foods:') for food in foods: print(food) #更换菜单： foods = ('烤肉','油焖大虾','冰激凌','米线','清蒸鲫鱼') print(f'\nnew foods:') for food in foods: print(food) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c1e03c5a3385804ce6ad366575b5046/" rel="bookmark">
			第六天22号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目来源：OpenJudge - 2406:Card Stacking
翻译如下：
描述：
贝西正在和她的N-1（2&lt;=N&lt;=100）头牛朋友玩纸牌游戏，他们使用一副K（N&lt;=K&lt;=100000；K是N的倍数）牌。牌组包含M=K/N“好”牌和K-M“坏”牌。贝西是一个庄家，当然，她想把所有的“好”牌都卖给自己。她喜欢胜利。她的朋友们怀疑她会作弊，所以他们设计了一个交易系统，试图阻止贝西作弊。他们告诉她按如下方式处理：
1.首先将牌组顶部的牌交给她右边的母牛
2.每次发牌时，她必须将下一张P（1&lt;=P&lt;=10）牌放在牌组底部；和
3.继续以这种方式按逆时针顺序向每位玩家进行交易
贝西急于获胜，请你帮她弄清楚应该把“好”牌放在哪里，这样她就能得到所有的牌。值得注意的是，最上面的牌是牌1，下一张牌是牌2，依此类推。
输入：
*第1行：三个空格分隔的整数：N、K和P
输出：
*第1行。。M：从顶部开始按升序排列的位置，贝西应该放置“好”牌，这样当发牌时，贝西将获得所有好牌。
样例输入：
3 9 2
样例输出：
3.
7.
8.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0bf8673fdf122749c00e98bb8a68ce97/" rel="bookmark">
			LeetCode 45 跳跃游戏 II（Java）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目：
给你一个非负整数数组 nums ，你最初位于数组的第一个位置。
数组中的每个元素代表你在该位置可以跳跃的最大长度。
你的目标是使用最少的跳跃次数到达数组的最后一个位置。
假设你总是可以到达数组的最后一个位置。
示例1：
输入: nums = [2,3,1,1,4]
输出: 2
解释: 跳到最后一个位置的最小跳跃数是 2。
从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。
示例2：
输入: nums = [2,3,0,1,4]
输出: 2
提示：
1 1 1 &lt;= nums.length &lt;= 1 0 4 10^4 104
0 0 0 &lt;= nums[i] &lt;= 1000 1000 1000
解题代码：
class Solution { public int jump(int[] nums) { int end = 0; // 当前跳远能跳到的最远位置 int temp = 0; // 当前跳了几下 int maxPos = 0; // 下一次能跳到的最远位置 for(int i = 0; i &lt; nums.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0bf8673fdf122749c00e98bb8a68ce97/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/032f9d44eae01f1388847dd44159441c/" rel="bookmark">
			根据数组构造二叉树最强解法总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法论 构造二叉树题目一般都是用数组构造，可以两个数组或者一个数组构造。
用两个数组构造一棵二叉树的递归函数需要四个参数，每个数组都要指定起始和结束位置：
TreeNode* build(vector&lt;int&gt;&amp; inorder, int inbegin, int inend, vector&lt;int&gt;&amp; postorder, int postbegin, int postend){} 题目包括：
LT106 从中序与后序遍历序列构造二叉树
LT105 从前序与中序遍历序列构造二叉树
用一个数组构造一棵二叉树只需要2个参数，指定起始和结束位置：
TreeNode* build(vector&lt;int&gt;&amp; nums, int begin, int end){} 题目包括：
LT654 最大二叉树
LT108 有序数组转换为二叉搜索树
不管是几个数组，最终的代码写法都是很相似的。分为几个步骤：
1.找到分割点，也就是根节点
2.切割数组，如果是两个数组的，需要分别切割
3.递归构造左右子树，递归函数的返回值给root节点
另外代码编写过程中要坚持循环不变量原则，统一使用左闭右开原则。
LT106 从中序与后序遍历序列构造二叉树 循环不变量：左闭右开
方法一：使用临时数组，这种方法空间复杂度比较大，时间复杂度也大，容易超时
注意类似用数组构造二叉树的题目，每次分隔尽量不要定义新的数组，而是通过下表索引直接在原数组上操作，这样可以节约时间和空间上的开销。
/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: TreeNode* build(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder){ cout &lt;&lt; endl &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/032f9d44eae01f1388847dd44159441c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/220d12af7f52115830603d3f2849c804/" rel="bookmark">
			Domain adaptation 与 Domain generalization
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Domain adaptation （DA） 1. 基本介绍 1. 什么是domain?:
一堆数据服从相同的分布。
2. Domain adaptation 研究的问题
给了一个training set 这个set可能是由一个或多个domain 构成的，给定的testing set的domain与training set是不同的。利用training有Label 的数据训练模型，使得这个模型在testing数据上也可以使用，并且取得良好的效果。
在经典的机器学习中，当 源域 和 目标域 数据分布不同，但是两者的任务相同时，这种 特殊 的迁移学习就是域自适应（Domain Adaptation）。
上面含义若看不太懂，简要解释如下：我们一般都是假设训练集和测试集分布一致，但是在实际中，训练集和测试集其实分布会有差异，因为测试场景非可控，因此存在测试集和训练集分布有很大差异的情况，这时候训练好的模型在测试集上效果却不理想，为解决这样的问题，出现了迁移学习。 简单举例来说：我们熟知的人脸识别，如果用东方人人像来训练，最后用于识别西方人，那当然性能会明显下降。
3. Domain adaptation 的解决思路
解决Domain adaptation问题主要的思路就是将source训练好的模型能够用在target上，域适配问题最主要的就是如何减少source和target不同分布之间的差异。
域适配包括无监督域适配和半监督域适配，前者的target是完全没有label的，后者的target有部分的label，但是数量非常的少。
这里主要介绍基于深度学习的方法，在我们已知finetuning之后，其实很容易想到，将在有标签的域A上训练好的模型用在无标签或者少量标签的域B上，中间的操作只需要改变输入，但是这种方式就会由于域A和域B数据分布不同导致效果并不一定会非常好，如果有方式能够减少A和B的差异，那就可以用同一个模型来跑A和B的数据。
2. Shallow DA 样本自适应 Instance adaptation :对源数据每一个样本加权，学习一组权重使得分布差异最小化，然后重新采样，从而逼近目标域的分布。源域总有一部分数据类似于目标域，找到那部分数据就可以了，越像的数据，给的权重就越大。特征自适应 Feature adaptation：将源域和目标域投影到公共特征子空间，这样两者的分布相匹配，通过学习公共的特征表示，这样在公共特征空间，源域和目标域的分布就会相同。将源域和目标域提取到一个共同的特征空间中，使他们之间足够近，足够对齐，目标域的性能就可以提升。模型自适应 Model adaptation：考虑目标域的误差，对源域误差函数进行修改。假设利用上千万的数据来训练好一个模型，当我们遇到一个新的数据领域问题的时候，就不用再重新去找几千万个数据来训练，只需把原来训练好的模型迁移到新的领域，在新的领域往往只需相对较少的数据就同样可以得到很高的精度。实现的原理则是利用模型之间存在的相似性。 以下是三种自适应的公式表达
3. Deep DA 在深度DA中，DA大部分是特征自适应（Feature adaptation）。
fine-tune(微调):冻结预训练模型的部分卷积层（通常是靠近输入的多数卷积层），训练剩下的卷积层（通常是靠近输出的部分卷积层）和全连接层。
卷积神经网络的核心：
1）浅层卷积提取基础特征，即信息是更general, 更边缘的信息，如边缘，轮廓等基础特征。
2）深层卷积提取抽象特征，如整个脸型。越深层，提取的特征就越是特定的某个任务，即特征中融入了很多domain的信息，其特征更适用于源域而不适用目标域。
3.1 关于Fine-tune的一个实验 3.1 .1 实验操作 使用Dataset A,在一个固定的网络结构上进行训练得到model A(下图第一行绿色)再使用Dataset B,在相同的网络结构上训练得到model B（下图第二行紫色）。固定model B的前3层，在Dataset B上训练得到B3B（下图第三行上半部分），不固定model B的前3层，在Dataset B上训练得到B3B+（下图第三行下半部分）同理固定/不固定model A的前三层，在Dataset B上训练得到A3B/A3B+（下图第四行）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/220d12af7f52115830603d3f2849c804/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/437f334acd467eb7a1afcf1cf729e7ff/" rel="bookmark">
			Windows系统Bat命令批量删除文件名中特定字符串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当文件名过长，看着不爽，或者复制到手机文件名显示不全怎么办，手动修改文件太多，太麻烦，下载专用软件还怕病毒，这里教你们一个脚本，新建一个文本文档，把下面代码附近进去，然后另存为批量重命名.bat，放到文件夹中双击运行
@echo off Setlocal Enabledelayedexpansion set "str=你要删除的文字" for /f "delims=" %%i in ('dir /b *.*') do ( set "var=%%i" &amp; ren "%%i" "!var:%str%=!") 例：
脚本
@echo off Setlocal Enabledelayedexpansion set "str=高清_720P_" for /f "delims=" %%i in ('dir /b *.*') do ( set "var=%%i" &amp; ren "%%i" "!var:%str%=!") 运行后
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/216091d1ce32eba1128b0066e656ff88/" rel="bookmark">
			2021年值得阅读的AI领域论文（偏重计算机视觉方向）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一位国外博主以时间顺序总结了40篇2021年的AI论文。需要的可以查看。
原文链接中有论文原文和代码
原文链接：https://www.louisbouchard.ai/2021-ai-papers-review/
文章列表
DALL·E: Zero-Shot Text-to-Image Generation from OpenAI [1]
VOGUE: Try-On by StyleGAN Interpolation Optimization [2]
Taming Transformers for High-Resolution Image Synthesis [3]
Thinking Fast And Slow in AI [4]
Automatic detection and quantification of floating marine macro-litter in aerial images [5]
ShaRF: Shape-conditioned Radiance Fields from a Single View [6]
Generative Adversarial Transformers [7]
We Asked Artificial Intelligence to Create Dating Profiles. Would You Swipe Right? [8]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/216091d1ce32eba1128b0066e656ff88/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ed3905fc24dfe9eb5b591dfdcba71a5/" rel="bookmark">
			java.lang.reflect.InvocationTargetException (no error message) 的解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 开发中偶尔会碰到这个问题：
Execution failed for task ':app:kaptDebugKotlin'. &gt; A failure occurred while executing org.jetbrains.kotlin.gradle.internal.KaptExecution &gt; java.lang.reflect.InvocationTargetException (no error message) 很是操蛋，自己有时直接build 文件删除 ，AS invalidate cache and restart 竟然又编译通过了，就没有深究，今天合并代码后又出现这个问题了，这时又按照如上做了三两编搞不起来了emo，，，，于是决定研究一下。
解决 1、无从下手的提示 碰到这个问题时估计大家都见到同样的UI提示
2、查找原因 只要知道到报错的原因，问题就迎刃而解，，，关键是这个报错提示隐藏的有点深，对于这类问题编译器不直接提示，而大部分我们按照Try提示也看不到主要提示。
其实这时我们点击编译器找到 build-&gt;build output 窗口点击build failed 红色提示，错误就直接展示了（贴图不贴了，贴一张自己工作中碰到的这个问题，关键信息打码图片被csdn识别为违规图片，，，，）。
具体错误大家可能遇到的不一样，找到原因基本也就知道怎样解决了，但是这类的都报这个提示真是操蛋，藏得够深，，，，，想想之前删除build 重启AS可能是类似情况，只是当时编译器抽风重启后导包又正确的了原因吧！！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23284a0287c5defbbf637e5d88673d88/" rel="bookmark">
			STL：vector容器动态增长原理、定义、初始化、赋值、取数、插入、删除、大小、交换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vector容器：动态数组、可变数组、单口容器。
vector实现动态增长原理：
当插入新元素的时候，如果空间不足，那么vector会重新申请更大的一块内存空间，将原空间数据拷贝到新空间，释放旧空间数据，再把新元素插入新申请空间。
一.vector构造函数 vector&lt;int&gt; v，v1;//采用模板实现类，默认构造函数 v(v1.begin(), v1.end());//将v[begin(),end()]区间的元素拷贝给本身 v(int n, elem);//构造函数将n个elem拷贝给本身 v(const vector &amp; vec);//拷贝构造函数 例子，使用第二个构造函数 int arr[] = { 2,3,4,1,9 }; vector&lt;int&gt; v1(arr, arr + sizeof(arr) / sizeof(int)); vector&lt;int&gt; v2(v1.begin(), v1.end()); vector&lt;int&gt; v3(v2); 二.vector赋值 assign(beg,end);//将[beg，end]区间中的数据拷贝赋值给本身 assign(n, elem);//将n个elem拷贝赋值给本身 vector&amp; operator=(const vector &amp; vec);//=号操作符重载 第一个赋值函数，可以这样写：
int arr[] = { 0,1,2,3,4,5 }; vector&lt;int&gt; v; v.assign(arr, arr + sizeof(arr) / sizeof(int)); for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) { cout &lt;&lt; *it &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23284a0287c5defbbf637e5d88673d88/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5d7974463bab5784e9c20e803d17956/" rel="bookmark">
			关于工作的感慨
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		昨天的无法改变，既然已经发生，再多的后悔也无法改变
明天的还未到来，既然都要面对，再多的恐惧也无济于事
能做的只有珍惜今天
人的焦虑啊，总是来自于想得太多，做的太少
让我们专注于眼下，学习扩展已有的知识体系
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b2fde8dd88973cb42de75f5314df0fb/" rel="bookmark">
			Redisson——分布式锁引发的一场线上事故
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目场景： 最近帮朋友看项目上分布式锁失效（暂时推测，实则不然）引起严重事故，他给我看了出事故的代码，描述相关的业务场景，分布式锁在他们项目里面一直都在使用，而且暂时没有出现相关问题。
问题描述： 第三方软件商会通过接口传输数据，为了避免数据重复（不想重复就让推送者控制一下呗，纯属个人唠叨，对业务不了解，所以不清楚为什么会出现重复推数据），将数据的为唯一标识用作分布式锁的key,在锁生效的时间内，不会接收重复的一批数据，就是这个分布式锁（使用姿势错了）没生效，这一天导致有大概6W左右的重复数据，出问题的代码我就不附上了，附我自己模拟的环境吧。
@Test void contextLoads() { ConcurrencyTester tester = ThreadUtil.concurrencyTest(10000, () -&gt; { // 测试的逻辑内容 HttpUtil.get("http://localhost:9952/getOrder"); }); } String order = "12306"; String name = Thread.currentThread().getName(); /** * 获redis锁 */ if (RedisUtils.tryLock(order, TimeUnit.SECONDS, 2, 30)) { System.out.println(String.format("%s 抢到订单啦", name)); } else { System.err.println(String.format("%s 抢订单失败", name)); } 看了代码是不是觉得没什么问题呀，但是看实际打印结果，发现同一线程重复抢购了多次，他们怀疑是线程竞争引起的，我用上面的截图马上就打破了这种说法，因为重复抢购的都是同一个线程。
原因分析： 看到这个现象我也很疑惑，为啥都是同一个线程出的问题，其他线程都是好好的。
随后我就去看了一下官网文档对分布式锁的介绍，猜测引发事故的锁是：可重入锁（Reentrant Lock），为何这么说：可重入锁，在同一线程内，外层函数获得锁之后，内层递归函数仍然可以获取到该锁。 说白了就是同一个线程再次进入同样代码时，可以再次拿到该锁。 它的作用是：防止在同一线程中多次获取锁而导致死锁发生。这下就真相大白了，就有我个人相对应的解决方案了：换锁或者在此基础针对同一线程进行特殊处理。
解决方案： 在去设置锁之前先去校验锁的状态即可。
String order = "12306"; String name = Thread.currentThread().getName(); /** * 获redis锁 */ if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b2fde8dd88973cb42de75f5314df0fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd23d1879d129905a648030c872520ee/" rel="bookmark">
			对于Python selenium操作的总结（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.对于驱动的安装 驱动包:webdriver（在cmd执行help(webdriver)可查看所支持的浏览器类型，在此只提其中的Chrome和Edge）
Chrome驱动插件: chromedriver.exe
Edge驱动插件:MicrosoftWebDriver.exe(Edge这个驱动名称要根据配置文件中标注名称进行相应的改动)
同时也要看对应版本：
下载完成相应插件后，将驱动插件放入python安装路径中的Script文件夹即可
2.对于获取元素的详解（元素只针对"响应元素"，并不会查找其他元素） 查找元素可以有两种方式：
直接采用方法导入from selenium.webdriver.common.by import By,调用其中的方法 methodexplanationBy’s methodfind_element_by_name直接根据元素的name属性来获取By.Namefind_element_by_id直接根据元素的id属性来获取By.IDfind_element_by_xpath根据xpath选择器来获取By.XPATHfind_element_by_link_text直接根据页面中的完整链接获取By.LINK_TEXTfind_element_by_partial_link_text根据部分链接文本获取By.PARTIAL_LINK_TEXTfind_element_by_tag_name根据tag的name属性获取By.TAG_NAMEfind_element_by_class_name根据class的name属性获取By.CLASS_NAMEfind_element_by_css_selector通过css选择器来获取By.CSS_SELECTOP 先通过打开Chrome浏览器用bing搜索bilibili来进入b站试一下:
#载入驱动器 from selenium import webdriver #载入模拟按键 --如果你想的话可以通过获取搜索按钮的元素来搜索 from selenium.webdriver.common.keys import Keys #可以导入快捷包 from selenium.webdriver.common.by import By #声明浏览器对象 browser = webdriver.Chrome() #browser = webdriver.Edge() #打开bing搜索界面(用百度也可以，不过会跳出人机验证，故此建议使用bing) browser.get("https://www.bing.com/") #根据控制台获取bing搜索框元素id，并输入"bilibili" input_str = browser.find_element_by_id('sb_form_q') #这里可以替换为: #input_str = browser.find_element(By.ID, 'sb_form_q') input_str.send_keys("bilibili") #直接通过ENTER键来搜索 input_str.send_keys(Keys.ENTER) #如果想通过搜索按钮的话可以采取以下方式 # clmethod = browser.find_element_by_class_name("nav-search-submit") # clmethod.click() #由于Chrome浏览器一般不会跳出第二个窗口故此可以不用窗口操作 #借助部分关键词搜索链接 link = browser.find_element_by_partial_link_text("哔哩哔哩") #便捷包可替换成:link = browser.find_element(By.PARTIAL_LINK_TEXT, "哔哩哔哩") link.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd23d1879d129905a648030c872520ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca794c05b1a3a981fe9fea29983187e3/" rel="bookmark">
			什么是场效应管
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 一、分类二、管脚定义三、MOSFET1、MOS管的伏安特性曲线1) 开启电压U~UGTH~2）转移特性曲线的数学表达式3）可变电阻区和恒流区的分界线 2、MOS管的工作状态 一、分类 场效应管是单极性晶体管。 场效应管大类上分为结型场效应管和金属氧化物场效应管。结型场效应管工作电流很小，适合于模电信号放大。他分为N沟道和P沟道两种。N沟道跟P沟道的电流相反。 金属氧化物场效应管（MOSFET）可分为耗尽型和增强型，也分N沟道跟P沟道。以电流跟电压可分为小信号管和功率管（POWER）。 二、管脚定义 所有FET都有三个管脚，分别为栅极G（gate）对应双极性晶体管的基极b，漏极D（drain）对应双极性晶体管的集电极c，源极S（source）对应双极性晶体管的发射极e。
三、MOSFET 1、MOS管的伏安特性曲线 1) 开启电压UUGTH 图中可以看到UGSTH=1V，当MOS管的UGS＜UGSTH时，无论UDS多大，电流iD均为0（UDS为正 ）；只在UGS＞UGSTH时，晶体管才能存在电流，即是所谓的开启。一般MOS管的开启电压为0.5V~3V之间。
2）转移特性曲线的数学表达式 3）可变电阻区和恒流区的分界线 随着UGS的增加，分界点电压UDS_dv也在增加，近似满足：UDS_dv=UGS - UGSTH
2、MOS管的工作状态 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75318c7ffca88a0e32f874e573d9ffc2/" rel="bookmark">
			c#“ORA-00933: SQL 命令未正确结束“ 解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 报错：{“ORA-00933: SQL 命令未正确结束”}
sql语句：
`string upSql = @"update T_OCV3_PRODUCT set voltage='" + volcVal + "' where cellcode = '" + battcodeVal + "';";` 解决办法：- -!去掉语句里的 “ ; ”
正确写法：
string upSql = @"update T_OCV3_PRODUCT set voltage='" + volcVal + "' where cellcode = '" + battcodeVal + "'";` 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d7eca0df8c4207d875ad621091e810a/" rel="bookmark">
			数据库连接数查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Oracle 使用DOS命令链接Oracle
假设有一个 Oracle 数据库信息如下：
IP:192.168.0.1
SID:orcl
端口号：1521
用户名：testuser
密码：123456
在本地客户端中配置的服务名为：server1
1、通过服务名连接数据库
sqlplus userName/userPassword@netServiceName 例：sqlplus testuser/123456@server1 2、通过IP 连接数据库：
sqlplus userName/userPassword@//IP:port/SID 例：sqlplus testuser/123456@//192.168.0.1:1521/orcl 如果是超级管理员需要在用户名/密码后面加上 as sysdba,是以系统管理员的身份来登录的
用户的切换
在登录的状态下输入：conn 用户名/密码 [as sysdba]
查看锁表进程SQL语句1：
select sess.sid, sess.serial#, lo.oracle_username, lo.os_user_name, ao.object_name, lo.locked_mode from v$locked_object lo, dba_objects ao, v$session sess where ao.object_id = lo.object_id and lo.session_id = sess.sid; 查看锁表进程SQL语句2：
select * from v$session t1, v$locked_object t2 where t1.sid = t2.SESSION_ID; 杀掉锁表进程：
如有记录则表示有lock，记录下SID和serial# ，将记录的ID替换下面的738,1429，即可解除LOCK
alter system kill session '738,1429'; mysql 查看链接数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d7eca0df8c4207d875ad621091e810a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/215ce3f3048e6da743f2d44b5641c764/" rel="bookmark">
			详解Springboot@ConditionalOnProperty注解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		该注解的作用是可以通过配置文件中的属性值来判定configuration是否被注入，这样就可以灵活的配置组件的启用。
先上注解源码：
package org.springframework.boot.autoconfigure.condition; import java.lang.annotation.Documented; import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; import org.springframework.context.annotation.Conditional; @Retention(RetentionPolicy.RUNTIME) @Target({ElementType.TYPE, ElementType.METHOD}) @Documented @Conditional({OnPropertyCondition.class}) public @interface ConditionalOnProperty { /** * 该属性与下面的 name 属性不可同时使用， * 当value所对应配置文件中的值为false时，注入不生效，不为fasle注入生效 * value有多个值时，只要有一个值对应为false,则注入不成功 */ String[] value() default {}; /** * 配置文件中key的前缀，可与value 或 name 组合使用 */ String prefix() default ""; /** * 与 value 作用一致 */ String[] name() default {}; /** * 与value 或 name 组合使用，只有当value 或 name 对应的值与havingValue的值相同时，注入生效 */ String havingValue() default "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/215ce3f3048e6da743f2d44b5641c764/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62a846c556d99598cdc9a829739d4d09/" rel="bookmark">
			数码管的原理及静态显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数码管的原理及静态显示 数码管的结构和原理 显示字符共阴极字段码共阳极字段码显示字符共阴极字段码共阳极字段码03FHC0HC39HC6H106HF9HD5EHA1H25BHA4HE79H86H34FHB0HF71H8EH466H99HP73H8CH56DH92HU3EHC1H67DH82HT31HCEH707HF8HY6EH91H87FH80HL38HC7H96FH90H8．FFH00HA77H88H“灭”00FFHB7CH83H……………… LED数码管的显示方式 静态显示和动态显示
静态显示方式 特点：
公共端直接接地(共阴极)或接电源(共阳极) 。每个数码管的段选线与一组I/O接口线相连。每个数码管一直显示。 绘制
下面有一条线的就是共阴极的，相反共阳极的在上面
先亮0
根据这个，我们可以写出完整代码
#include "reg51.h" #include "string.h" //定义一个数组，共阴0-9 unsigned char s[] = { 0x3F,0x06,0x5B,0x4F,0x66,0x6D,0x7D,0x07,0x7F,0x6F }; void delay(unsigned int n) { //给变量一个初始值，防止变量初始化的时候是一个随机数 //可能造成程序的误动作 unsigned int i=0,j=0; for(i=0;i&lt;n;i++) { for(j=0;j&lt;120;j++); } } void seg() { //P2 = 0x3F;//0011 1111,横和接地不亮 int i=0; for(i=0;i&lt;strlen(s);i++) { //P2 = s[i];//共阴 P2 = ~s[i];//共阳 delay(500); } } void main() { while(1) { //子函数，执行数码管的操作 seg(); } } 编译运行
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/62a846c556d99598cdc9a829739d4d09/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9da7f2db1c9cb78de55170e62032abcd/" rel="bookmark">
			（超详细）2022年最新版java 8（ jdk1.8u321）安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2022年最新版java 8（ jdk1.8u321）下载及安装 JunLeon——go big or go home
目录
2022年最新版java 8（ jdk1.8u321）下载及安装
一、环境准备
jdk下载
二、jdk安装
三、配置环境变量
1、配置Java 8的环境变量
2、验证是否安装成功
一、环境准备 jdk下载 截止2022年1月，官方出的jdk1.8目前已更新到8u321的版本。
下载官网：Java Downloads | Oracle
下载版本：jdk-8u321-windows-x64.exe
百度网盘：链接：https://pan.baidu.com/s/1F43G56vjd5JtZXxbkQJlIA 提取码：8888
进入上述网址后，选择Java 8，然后根据自己系统位数选择对应安装包即可，我电脑是64位，即选择
注：现在官方下载需要登录账号，我已登录账号，直接下载即可。（自行注册、登录Oracle账号，如果不想注册、登录账号，可选择百度网盘下载即可）
二、jdk安装 安装Java8包括jdk1.8和jre1.8，双击已下载好的安装包即可：
1、点击已下载好的安装包，进入Java8安装向导，点击下一步：
2、修改安装路径，自行修改
3、进入安装过程
4、安装jre1.8，修改jre的安装路径，建议放在jdk同级目录
5、jre安装过程
6、安装完成
7、安装完成后可在你的控制面板--&gt;程序和功能 中看到以下两个程序
接下来即可配置环境变量了。
三、配置环境变量 1、配置Java 8的环境变量 步骤如下：
我的电脑右键属性（win11则在系统控制面板找到关于） --&gt; 高级系统设置 --&gt; 环境变量
1）新建JAVA_HOME变量，添加：
变量名：JAVA_HOME
变量值：D:\Program Files\Java\jdk1.8.0_321
2）配置PATH路径
找到系统变量中的PATH
配置bin目录
新建 --&gt; 输入 %JAVA_HOME%\bin
输入完成，确定即可
2、验证是否安装成功 配置好环境变量，需要验证是否安装成功：
打开Windows的运行（可用win+R快捷键打开），输入cmd
验证Java版本：java -version
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9da7f2db1c9cb78de55170e62032abcd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3dea70dc07a6b7ffd3f8e30aa245fda7/" rel="bookmark">
			最新快递鸟接口快递公司编码汇总（国际版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		支持快递鸟接口快递公司编码列表（国际版）
备注：编码正确。该物流公司统一用DNWL编码。
DHL DHL
Fedex Fedex
UPS UPS
TNT TNT
AAE全球专递 AAE
ACS雅仕快递 ACS
ADP Express Tracking ADP
安圭拉邮政 ANGUILAYOU
APAC APAC
Algeria EMS ALGERIAEMS
APG eCommerce APGECOMMERCE
Aquiline Aquiline
AUS AUS
Aramex ARAMEX
奥地利邮政 AT
AOL（澳通） AOL
Australia Post Tracking AUSTRALIA
Asendia USA ASENDIAUSA
Asendia UK ASENDIAUK
Asendia Germany ASENDIADE
AIR21 AIR21
安世通快递 ASTEXPRESS
Airspeed International Corporation AIRSPEED
ACommerce ACOMMERCE
ABX Express ABXEXPRESSMY
Aplus物流 APLUSEX
Airpak Express AIRPAKEXPRESS
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3dea70dc07a6b7ffd3f8e30aa245fda7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5acb93dc19615202813978720f3658cc/" rel="bookmark">
			Android adb 命令详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Android开发中，为了方便测试某一个组件，会直接使用adb 命令行来实现，下面分享实现方法
一、adb启动Activity:
adb shell am start -n ｛包(package)名｝/｛包名｝.{活动(activity)名称}
如：启动Activity
adb shell am start -n com.xinrui/com.android.xinrui.MainActivity
二、adb关闭Activity:
adb shell am force-stop ｛包(package)名｝
如：关闭Activity
adb shell am force-stop com.xinrui
三、adb启动service：
adb shell am startservice -n ｛包(package)名｝/｛包名｝.{服务(service)名称}
如：启动自己应用中一个service
adb shell am startservice -n com.xinrui/com.xinrui.maniservice
四、adb发送broadcast：
adb shell am broadcast -a &lt;广播动作&gt;
如：发送一个网络变化的广播
adb shell am broadcast -n com.xinrui -a android.net.conn.CONNECTIVITY_CHANGE
五、导出日志
C:\Users\swmqry\Desktop&gt;adb logcat &gt; log.txt
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba60336c1f4f6bf1d93a94736311ca66/" rel="bookmark">
			二分查找算法（折半查找算法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		二分查找算法（折半查找算法） 二分查找又称折半查找、二分搜索、折半搜索等，是在分治算法基础上设计出来的查找算法，对应的时间复杂度为O(logn)。
二分查找算法仅适用于有序序列，它只能用在升序序列或者降序序列中查找目标元素。
二分查找算法的实现思路
在有序序列中，使用二分查找算法搜索目标元素的核心思想是：不断地缩小搜索区域，降低查找目标元素的难度。
以在升序序列中查找目标元素为例，二分查找算法的实现思路是：
初始状态下，将整个序列作为搜索区域（假设为 [B, E]）；
找到搜索区域内的中间元素（假设所在位置为 M），和目标元素进行比对。如果相等，则搜索成功；如果中间元素大于目标元素，表明目标元素位于中间元素的左侧，将 [B, M-1] 作为新的搜素区域；反之，若中间元素小于目标元素，表明目标元素位于中间元素的右侧，将 [M+1, E] 作为新的搜素区域；
重复执行第二步，直至找到目标元素。如果搜索区域无法再缩小，且区域内不包含任何元素，表明整个序列中没有目标元素，查找失败。
举个简单的例子，在下图所示的升序序列中查找元素 31。
二分查找算法的具体实现过程为：
初始状态下，搜索区域是整个序列。找到搜索区域内的中间元素。指定区域内中间元素的位置可以套用如下公式求出： Mid = ⌊ Begin + (End - Begin) / 2 ⌋
End 表示搜索区域内最后一个元素所在位置，Begin 表示搜索区域内第一个元素所在的位置，Mid 表示中间元素所在的位置。
图 1 中，所有元素的位置分别用 0~9 表示，中间元素的位置为 ⌊ 0 + (9 - 0) / 2 ⌋ = 4，如下图所示：
中间元素 27 &lt; 31，可以断定 [0, 4] 区域内绝对没有 31，目标元素只可能位于 [5, 9] 区域内，如下图所示：
在 [5, 9] 区域内，中间元素的位置为 ⌊ 5 + (9 - 5) / 2 ⌋ = 7，如下图所示： 中间元素 35 &gt; 31，可以断定 [7, 9] 区域内绝对没有 31，目标元素只可能位于 [5,6] 中，如下图所示：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba60336c1f4f6bf1d93a94736311ca66/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f0cb95827cf55862c2addac0ed59c48/" rel="bookmark">
			使用antd-vue 的a-table自定义展开图标
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		效果图：
代码：
columns: [{ title: "指标", dataIndex: "chapterName", key: "chapterName", align: "left", width: "31%", scopedSlots: { customRender: "chapterName" }, }, ...... ] &lt;a-table :columns="columns" :data-source="tableData" :row-selection="rowSelection" :expanded-row-keys.sync="expandedRowKeys" :pagination="false" :defaultExpandAllRows="true" :rowKey="(record) =&gt; record.id" &gt; &lt;!-- 展开图标 --&gt; &lt;template slot="expandIcon" slot-scope="props"&gt; &lt;span v-if="props.record.children.length &gt; 0"&gt; &lt;div v-if="props.expanded" style="display: inline-block; margin-right: 10px" @click="(e) =&gt; {props.onExpand(props.record, e)}"&gt; &lt;a-icon type="down" /&gt; &lt;/div&gt; &lt;div v-else style="display: inline-block; margin-right:10px" @click="(e) =&gt; {props.onExpand(props.record, e)}"&gt; &lt;a-icon type="right" /&gt; &lt;/div&gt; &lt;/span&gt; &lt;/template&gt; .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f0cb95827cf55862c2addac0ed59c48/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61e82c54f2050305e60675882b9bbca8/" rel="bookmark">
			VScode神仙插件，程序员必备
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 Visual Studio Code(VS Code)是微软2015年推出的一个轻量但功能强大的源代码编辑器，基于 Electron 开发，支持 Windows、Linux 和 macOS 操作系统。它内置了对JavaScript，TypeScript和Node.js的支持并且具有丰富的其它语言和扩展的支持，功能超级强大。Visual Studio Code是一款免费开源的现代化轻量级代码编辑器，支持几乎所有主流的开发语言的语法高亮、智能代码补全、自定义快捷键、括号匹配和颜色区分、代码片段、代码对比 Diff、GIT命令 等特性，支持插件扩展，并针对网页开发和云端应用开发做了优化。
VS Code提供强大的扩展，版本更新很及时，功能丰富且强大。而且官网提供了丰富的说明文档和视频等支持。安装扩展以添加新语言、主题、调试器并连接到其他服务。 扩展在单独的进程中运行，不会减慢编辑器的速度。
一，推荐主题 当我们无论是使用手机、平板、还是电脑，都会设计设计自己喜欢的主题，作为一名优秀的程序员，Vscode编辑器我们也应该拾掇拾掇，下面几款主题是我个人推荐的，如果有喜欢的小伙伴建议收藏！
Moonlight Moonlight更像是晚上手机开启夜间模式一样，适合晚上敲代码或者重度暗色爱好者
Nord Nord是一款北极蓝主色调、干净、优雅的主题，可能更适合大多数女生。
Noctis Noctis主题暖色和冷色混合的均衡，看起来很舒服，减少眼睛疲劳。
Palenight Palenight是柔和而舒适的紫色主题，喜欢紫色的女生或者男生不要错过。
Ayu Ayu是一款白色主题，简单、明亮、优雅。深色模式也很适合晚上使用。
二，万能插件 语言支持 Java 提供代码调整、自动补全、jdk 文档查询、Lint、类型检查、debug等功能。但一般Java开发工程师不用vscode写Java代码，因为Java的工程往往比较庞大，而vscode相对比较轻量级，相对来说不是非常合适。而且Java工程需要的插件也非常多，比如Tomcat、spring、数据库等等……全部安装下来还是比较重的。所以还不如直接使用全部环境都集成好的IDEA。
C/C++ 提供C++语法识别、智能补全、代码跳转、调用依赖识别等，一般来说学生党安装这一个就可以了。还有一些其他的插件也非常不错，如C++ Intellisense, C/C++ Clang Command Adapter等。
MySQL SQLTools 有智能提示，如果谈论颜值的话比较偏向MySQL。
HTML/CSS HTML/CSS语法支持，前端党必备。
Markdown markdown语法支持，可以在vscode当中编辑markdown文档，还支持图床的图片上传功能。
由于很多github的repo都提供了markdown语法格式的readme文件，所以还是需要安装一下，这样才方便阅读。
Python Python的语法支持，支持Python的单测、lint、语法高亮、代码格式化、debug、jupyter等功能。
代码神器 Auto Close Tag 前端神器，只需要编写左标签，例如,,等，会自动替我们完成右侧标签的填充如：, , 等。
Better Comments 美化注释，可以将我们的多行注释按照类别自动高亮
Bracket Pair Colorizer 开发神器，当使用多层括号嵌套时，自动将不同层次的括号设置成不同的颜色，防止配对时眼瞎。
leetcode 上班摸鱼、实验室摸鱼神器，再也不用担心刷题被老板看到了。
live server 前端神器，可以在vscode中预览编写的网页。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61e82c54f2050305e60675882b9bbca8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02cfd81d7b188f29e9decd9261e763cb/" rel="bookmark">
			mybatis-plus多数据源事务报错 No qualifying bean of type ‘org.springframework.transaction.TransactionManager‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目中使用了多数据源配置,在添加事务的时候,出现了如下异常
No qualifying bean of type 'org.springframework.transaction.TransactionManager' available 这个是因为找不到对应的事务管理器报出的错误.网上有很多种方法,其实已经说的很明确了.
就是给自己配置的数据源,分别添加各自的事务管理,然后在使用事务的地方注明自己的事务管理
数据源配置时,添加自己的事务管理
@Bean(name = "middleDataSourceDruid") @ConfigurationProperties("spring.datasource.middle-druid") public DataSource middleDataSourceDruid() { return DruidDataSourceBuilder.create().build(); } @Bean(name = "midDataSourceTransactionManager") public PlatformTransactionManager midDataSourceTransactionManager(@Qualifier("middleDataSourceDruid") DataSource dataSource) { return new DataSourceTransactionManager(dataSource); } 使用事务时,通过value指定事务管理器
@Transactional(rollbackFor = Exception.class,value = "midDataSourceTransactionManager") 这样就可以解决这个报错.
但有一些特殊情况,由于我在项目中使用的是mybatis-plus.调用公共方法saveBatch()时,还是会报错,说找不到事务管理器.(有时候也报找到多个)但是调用save()方法就不会有这个问题.这个就很尴尬了.在网上找了找.没有找到解决办法.只能自己去跟源码找了
事务管理器的选择主要看
TransactionAspectSupport 类下的这个方法determineTransactionManager @Nullable protected Object invokeWithinTransaction(Method method, @Nullable Class&lt;?&gt; targetClass, final InvocationCallback invocation) throws Throwable { // If the transaction attribute is null, the method is non-transactional.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/02cfd81d7b188f29e9decd9261e763cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c630bde6ad5004632d43014e902ab62/" rel="bookmark">
			win11文件夹打开延迟怎么办 Windows11文件打开延迟的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 win11是微软发布的最新操作系统,很多小伙伴都跑去升级体验了下,由于是预览版,所以我们在使用时可能会遇到很多bug，最近就有许多小伙伴遇到win11打开文件夹延迟的问题，那么接下来小编就把win11打开文件夹卡顿的解决方法带给大家。快来一起看看吧。更多Windows11系统教程，可以参考小白装机网。
win11打开文件夹延迟：
1.首先我们可以按win+r键打开运行窗口，然后输入命令”regedit"回车确认。
2.进入到注册表编辑器当中，依次打开“计算机\HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Shell Extensions”。
3.然后我们点击Shell Extensions 右键新建“项”。
4.将其命名为“Blocked：，接着右键 Blocked ，新建”字符串值“。
5.然后将其命名为{e2bf9676-5f8f-435c-97eb-11607a5bedf7}。
6.最后重启资源管理器，就可以发现资源管理器的样式变成Win10的样式了，使用起来非常流畅。
7.如果想要返回之前的状态，删除 Blocked 并重启资源管理器即可。
不知道如何开启tpm无法安装Windows11？看这里，直接绕过微软tpm检测的方法，在线安装步骤如下 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66b596622e445530c8811b2182783611/" rel="bookmark">
			关于头文件.h的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		头文件.h其实就相当于函数调用，
例如：#include&lt;reg52.h&gt;
例如上图的头文件中就包含了宏定义
调用#include &lt;sys.h&gt;，这个sys头文件其实也相当于内嵌的一个子程序。
还有函数声明，只不过多了防止重复编译
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64168bb2a76a553b001452972721fda9/" rel="bookmark">
			LED原理及流水灯的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LED原理及流水灯的实现 原理 Library中
ACTIVE：可视化的，可以看清LED的活动
LED_BIBY的意思是：两种极性的LED颜色：B-blue，Y-yellow
LED是蓝色的，发光后颜色为黄色。
像LED_BIGY ,LED_BIRG,LED_BIRY都是类似的意思
选中
电流方向P极–》N极
流水灯的实现 流水灯通常是由八个LED组成的轮流、滚动显示的效果。
LED发光二极管是单向导电的一种元器件,它分共阳极和共阴极两个极。
构成流水灯的元器件 AT89C51
电阻（RES）
LED*8（LED-BIBY）
加入89C51，然后排列8个led
演示共阳极接法： 连上所有LED 添加电源，用单片机的p2口控制流水灯
引出线，由于单片机IO口可以承受的电流是有限的，如果直接接线会烧掉单片机的IO口，所以我们需要加入电阻进行限流，电阻大于250
共阴极连接： 代码 sbit是定义特殊功能寄存器的位变量。
bit和sbit都是C51扩展的变量类型。
典型应用是：sbit P0_0=P0^0;//即定义P0_0为P0口的第1位，以便进行位操作。
bit和int char之类的差不多，只不过char=8位, bit=1位而已。
都是变量，编译器在编译过程中分配地址。
#include "reg51.h" //sbit是定义特殊功能寄存器的位变量 //这里我们操作D1亮灭，对应单片机P2.0 sbit LED0=P2^0; void delay(unsigned int n) { //给变量一个初始值，防止变量初始化的时候是一个随机数 //可能造成程序的误动作 unsigned int i=0,j=0; for(i=0;i&lt;n;i++) { for(j=0;j&lt;120;j++); } } void main() { while(1) { //亮 LED0=0; //延时函数，亮和灭之间切换太快，延时5毫秒 delay(5); //灭 LED0=1; delay(5); } } 为单片机导入hex文件
双击单片机
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/64168bb2a76a553b001452972721fda9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dade342d7f5cf0cd9b4f50733bb3a28a/" rel="bookmark">
			Spring Batch中@StepScope的适用范围及理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一.说明: 使用Spring Batch批处理框架时,由于初期不理解该注解的使用范围导致走了一些弯路.特此记录batch框架中特有的bean作用范围注解@StepScope的使用注意事项:
在此之前,先说一下IOC容器中几种bean的作用范围:
a.singleton单例模式 – 全局有且仅有一个实例b.prototype原型模式 – 每次获取Bean的时候会有一个新的实例c.request – request表示该针对每一次HTTP请求都会产生一个新的bean，同时该bean仅在当前HTTP request内有效d.session – session作用域表示该针对每一次HTTP请求都会产生一个新的bean，同时该bean仅在当前HTTP session内有效e.globalsession – global session作用域类似于标准的HTTP Session作用域，不过它仅仅在基于portlet的web应用中才有意义 二.@StepScope注解： Spring batch框架只有在批处理时才需要实例化job以及对应的最底层处理单位(reader,processor,writer,tasklet)且 在job启动后的运行参数一旦确定便无法修改。
为了使每一次启动job时使处理单位的参数可以动态修改(比如第一次job启动时参数tranDate=“20210101”,第二次job参数启动时参数改为tranDate=“20210102”).
所以设计了@StepScope配合@Value("#{jobParameters[‘contractInfoDat’]}") 从job的启动参数中获取所需参数。
三.使用注意事项: 只能用在最底层处理单位(reader,processor,writer,tasklet)的方法上,配合@Bean使用。被@StepScope注解修饰的bean只会在job启动时进行初始化,job处理完成后便会被销毁
(也就是说被@StepScope注解所修饰bean的生命周期与job的生命周期保持同步 （经指正：“是和Step一致，同一个Step执行两次你会发现Writer创建了两次”）) @Bean @StepScope public FlatFileItemWriter&lt;Map&gt; contInfoMyItemWriter(@Value("#{jobParameters['contractInfoDat']}") String contractInfoDat) { return getGbkFlatFileItemWriter(contractInfoDat); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a64dc5349cf1f44185c7e8479a2fe56f/" rel="bookmark">
			子网划分实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先得了解以下概念
网络地址: 网络号 + 子网号 + 主机号(全为0)
广播地址：网络号 + 子网号 + 主机号(全为1)
子网掩码：网络号(全为1) + 子网号(全为1) + 主机号(全为0)
IP地址总数:根据主机号的位数进行确定
可分配IP地址数:IP地址总数-2(去除主机号全为0的网络地址和主机号全为1的广播地址)
A类地址 网络号8位主机号24位 地址范围是1.0.0.0-126.0.0
B类地址 网络号16位主机号16位 地址范围是128.0.0.0-191.255.0.0
C类地址 网络号24位主机号8位 地址范围是192.0.0.0-223.255.255.0
划分子网是从主机号中借位进行划分的！！！
子网划分方式有两种 ①定长子网划分 ②可变长度子网划分
知道了这些概念，下面用例题来理解子网划分
例题1.某公司申请了一个C类202.60.31.0的IP地址。该公司有120名员工在销售部，60名在财务部，60名在设计部。请对该三部门分别组建子网，请问采用划分等大小子网方式还是采用可变子网大小方式？请说明理由，并列出各子网的可用IP地址范围，子网地址，广播地址和各子网掩码。 解：C类地址中主机号仅8位，若划分三个大小相等的子网(定长子网划分)，即从主机号中拿出前两位进行分配，可分配结果有00 01 10 11（为什么是两位？如果拿出1位 只有0和1两种划分结果，但题目有三个部门）
202.60.31.00...
202.60.31.01...
202.60.31.10...
202.60.31.11...
(...表示省略6位主机号)
即需要占用2位主机号，每个子网能容纳的主机个数为2^6 = 64位。
但是销售部要求120名员工，显然采用定长子网划分是无法满足要求的。所以需要采用可变长度子网划分。
由于2^6=64位无法满足销售部要求。但是2^7=128位所以我们将主机号第一位为0的地址空间全部划分给销售部（剩余7位主机号），这样就能满足需求了。剩下主机号第一位为1的地址空间，将主机号10开头的地址空间全部划分给财务部，将主机号11开头的地址空间全部划分给设计部。
答案如下:
部门子网掩码可分配地址范围子网地址广播地址销售部255.255.255.128202.60.31.1~202.60.31.126202.60.31.0202.60.31.127财务部255.255.255.192202.60.31.129~202.60.31.190202.60.31.128202.60.31.191设计部255.255.255.192202.30.31.193~202.60.31.254202.60.31.192202.60.31.255 解析: 以销售部为例 将主机号第一位为0的全部划分给销售部
将主机位全部置为0 即202.60.31.0000000 得到子网地址 202.60.31.0
将主机位全部置为0 即202.60.31.01111111 得到广播地址 202.60.31.127
将网络号+子网号全部置为1，主机号全部置为0，得到子网掩码255.255.255.10000000 即 255.255.255.128
可分配ip地址范围就是子网地址+1 ~ 广播地址 -1
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a64dc5349cf1f44185c7e8479a2fe56f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2891cb6946eb8e274de533ff9817409b/" rel="bookmark">
			搜推广系统里的bias &amp; debias
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考Paper《Bias and Debias in Recommender System: A Survey and Future Directions》
1、selection bias
选择性偏差指的是在研究过程中因样本选择的非随机性而导致得到的结论存在偏差。用户倾向于给自己喜欢或者不喜欢的物品进行打分。通常的解决办法有propensity score，同时学习打分预测任务和缺失数据预测任务。例如Improving Ad Click Prediction by Considering Non-displayed Events https://www.csie.ntu.edu.tw/~cjlin/papers/occtr/ctr_oc.pdf 同时对两种方法建模。通常这类偏差会作为exposure bias 解决。
2、exposure bias
这一问题通常见于计算广告中，曝光样本无法立刻知道是否会发生最终转化，通常的解决办法有，增加缓存，曝光日志等待时间足够长，直到有反馈回流再上报，确保样本的正确性。这应该也是最有效的办法，毕竟大力出奇迹。但是当硬件不允许时，就需要通过样本纠偏来矫正，也就是传说中的 delayed feedback. 有很多论文研究过相关的工作，通常的做法有对bias单独建模、通过importance sampling推导样本权重公式。
Modeling Delayed Feedback in Display Advertising是对延迟时间单独建模，主要思想就是对于还未观察到 conversion 的样本，不直接将其当做负样本，而是当前考虑 click 已发生的时间长短给模型不同大小的 gradient.
importance sampling 可以通过观测分布和真实分布之间的关系推导出采样权重，把这个权重作为样本的权重放到loss中，例如Addressing Delayed Feedback for Continuous Training with Neural Networks in CTR prediction中，将所有的样本在一开始都当做负样本，然后在正样本回传时多传一个正样本。那么就可以推导出观测值分布与真实分布的关系，通过权重纠偏。
3、position bias
收到推荐位置的影响，不同位置的样本是有偏的，第一个出现的内容作为正样本的概率会比后面的高，如果在训练时不做区分，那么位置靠后的样本也会受到不公平的待遇。
简单的做法可以是对位置靠后的正样本加权，负样本降权。如果一个用户看了50个视频，还能继续点赞，说明这个更大概率是他喜欢的，如果快滑，也更大可能是看了多个类似内容产生疲劳，而不是完全不感兴趣。因此可以设计与位置相关的正负样本权重，作为先验知识告诉模型。还有比较容易实现的方式有把postion作为一个特征放到模型中学习，但是这个特征只有在训练的时候可以获得，在线上预测时由于后面会经过混排等操作，是无法提前预知推荐的位置的，因此在预测时通常把这个特征置空。还有一种常用的办法就是添加一个debias 网络。在线下学习时，可以将位置作为一个特征输入到网络中，网络的输出作为一个bias加到最后的logit中，线上预测时就不用这个debias网络了。
4、popularity bias
用户经常会有从众心理。比如一个高热的视频，用户看到了他的点赞量，心里就会先入为主，觉得这个视频好看，从而有更高的概率完播或者点赞。这样会对低热的视频不友好，使得推荐系统的头部更加严重，而且从用户的正样本中，无法准确的获得用户的真实兴趣。准确的推荐重中之重是有清晰的label定义，必须首先告诉模型什么是用户真正感兴趣的，才能指望模型作出准确的预测。因此这个bias的纠正十分必要。
DICE（Disentangling Interest and Conformity with Causal Embedding）认为分数是用户兴趣和流行度分数的和，因此对流行度单独通过网络建模，和position bias 类似，这个网络输入可以是视频的流行度等特征，具体的样本选择时，loss时BPR loss，对每一个样本pair，分用户与视频是否有交互及视频之间的热度具体讨论，将两部分loss相加来分离兴趣和从众。详细讲解可见Glenn：流行度偏差：Disentangling User Interest and Conformity for Recommendation
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2891cb6946eb8e274de533ff9817409b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c00eda296d2cd647298cf2caacbdbea0/" rel="bookmark">
			为什么卷积核通常都是奇数（1x1、3x3...）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1，为了方便same padding时的处理。如步长为1时，要补充k-1的zero padding才能使输出输出的尺寸一致，这时候如果核大小k是偶数，则需要补充奇数的zero padding，不能平均分到feature map的两侧。
padding时对称：保证了 padding 时，图像的两边依然相 对称 。 在卷积时，我们有时候需要卷积前后的尺寸不变。这时候我们就需要用到padding。假设图像的大小，也就是被卷积对象的大小为nn，卷积核大小为kk，padding的幅度设为(k-1)/2时，卷积后的输出就为(n-k+2((k-1)/2))/1+1=n，即卷积输出为nn，保证了卷积前后尺寸不变。但是如果k是偶数的话，(k-1)/2就不是整数了。
输出图像大小 = （输入图片大小 - 卷积核大小 + 2*padding）/ stride步长 + 1 见下图，输入图像大小4x4，如果通过3x3卷积，输出图像大小不变，那么(4 - 3 + x) / 1 + 1 = 4.需要padding大小为x = 2，那么上下左右各填0即可，
如下图，如果采用偶数2x2卷积，那么需要(4 - 2 + x) / 1 + 1.= 4填充为x = 1，那么只能在一边添加。
2，为了统一标准。卷积核的滑动是默认使用中心点作为基准而进行的，而奇数核拥有这样天然的基准。这样每次计算完后的数放在中心位置。（其实自己定义偶数核的基准也是可以的，如使用核的左上角作为基准。）
3，为了更好地获取中心信息。由于奇数核拥有天然的绝对中心点，因此在做卷积的时候能更好地获取到中心这样的概念信息。
保护位置信息：保证了锚点刚好在中间，方便以模块中心为标准进行滑动卷积，避免了位置信息发生偏移 。 在CNN中，进行卷积操作时一般会以卷积核模块的一个位置为基准进行滑动，这个基准通常就是卷积核模块的中心。若卷积核为奇数，卷积锚点很好找，自然就是卷积模块中心，但如果卷积核是偶数，这时候就没有办法确定了，让谁是锚点似乎都不怎么好。
道生一，一生二，二生三，三生万物
综上，卷积核一般都把size设为奇数，主要有以下两个原因：
1.保证锚点（卷积核的中心）刚好在中间，方便以模块中心为标准进行滑动卷积。
2.保证了padding时，图像的两边依然相对称
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4faf969054aa84ffcd23265a27bebfe/" rel="bookmark">
			HTML标签学习 &#43; 案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一.工具的使用
1.操作步骤 二、基本语法的概述
1.标签介绍
2.基本html结构
三、常见的标签
1.标签语义
四.标签使用
1.标题标签
2.段落标签
3.换行标签
4.文本格式化标签
​
5.div和span标签 6.图像标签
7.路径
8.超链接标签
9.特殊字符
总结
一.工具的使用 我们使用的工具是：HBuilder
1.操作步骤 双击打开----新建项目
2.打开index.html
因为目前我们没有写入任何其他内容，所以里面只有简单的结构 二、基本语法的概述 1.html标签是由尖括号包围着关键字，例如：&lt;html&gt;
2.标签的分类
①双标签：html的标签通常是成对出现，称为双标签；标签中出现的第一个标签称为开始标签，最后一个称为结束标签
列如：&lt;html&gt;........&lt;/html&gt;
1.标签介绍 双标签的关系可以分为两类：包含关系和并列关系
包含关系（父子关系）：
&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; 并列关系（兄弟关系）：
&lt;head&gt; 头部标签 &lt;/head&gt; &lt;body&gt; 主题标签 &lt;/body&gt; 2.基本html结构 &lt;html&gt;&lt;/html&gt;:html标签，页面中最大的标签；页面内容在里面写&lt;head&gt;&lt;/head&gt;:文档的头部，主要在head标签中我们必须设置文档标签&lt;title&gt;&lt;/title&gt;:文档的标题,使页面有自己的网页标题&lt;body&gt;&lt;/body&gt;:文档的主体，元素包含文档中的所有内容，页面的内容基本都是放到body中 注意html文档必须是.html或者.htm结尾，浏览器读取html文档，并以网页的形式展示。
&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 以上是html的基本结构图
三、常见的标签 1.标签语义 根据标签的语义我们可以在不同的地方使用，使用一个合理的标签，可以让我们的页面看起来更整洁；
以下是一个没有语义标签的文章；看起来杂乱无章
接下来是一个使用了正确的语义标签的文章，同上对比我们可以看到整洁的文章，标题清晰可见
同样的一篇文章就看我们如何的去正确的使用其中的语义；让我们一起学习简单的标签使用吧！！
四.标签使用 1.标题标签 标题标签：见名知意，就是对标题使用的标签
分为六个标签，从上倒下依次排列大小：
&lt;body&gt; &lt;h1&gt;一级标签&lt;/h1&gt; &lt;h2&gt;二级标签&lt;/h2&gt; &lt;h3&gt;三级标签&lt;/h3&gt; &lt;h4&gt;四级标签&lt;/h4&gt; &lt;h5&gt;五级标签&lt;/h5&gt; &lt;h6&gt;六级标签&lt;/h6&gt; &lt;/body&gt; 效果如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b4faf969054aa84ffcd23265a27bebfe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b473140e52d3ce7334a673e0ffc1784d/" rel="bookmark">
			基于FME实现excel经纬度坐标转平面坐标
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 需求：将excel表中的经纬度数据，计算出其3度分带的平面坐标值。
1、原始数据：excel格式，具体如下样式：
2、FME实现技术路线
具体参数如下：
3、转换后结果： 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03c57ffe89a15ff78aca1ee564b03ca9/" rel="bookmark">
			C语言中的阶乘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、阶乘的使用 在c语言中，一些数学中的公式也可以用代码的形式去表达，以便于更好的去使用。
下面，我将用简单介绍阶乘是如何使用代码的形式去使用的
比如，
#include &lt;stdio.h&gt; int main() { int a = 0; int ret = 1; int n = 0; scanf("%d", &amp;n); for(a =1;a &lt;= n;a++) { ret = ret * a; } printf("%d", ret); return 0; } 注意：
1、在初始赋值的时候，ret的值不能为0。如果将其值设为零，由于零乘任何数恒为零，最终输出的值，是0.
2、阶乘的相加 在 1 中介绍了阶乘在c语言中是如何表达，那么接下来将介绍阶乘的相加的使用。
int main()//阶乘相加 { int a = 0; int ret = 1; int sum = 0; int n = 0; for (n=1;n&lt;=3;n++)// { ret = 1; for (a = 1; a &lt;= n; a++) { ret = ret * a; } sum = sum + ret; } printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/03c57ffe89a15ff78aca1ee564b03ca9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/109bfccef9d0df66a1231551fe819bb8/" rel="bookmark">
			音视频开发学习--01音视频基础知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、视频中的主要概念：
1、视频码率：
2、视频帧率：
3、视频分辨率：
二、I帧、 P帧、 B 帧、GOP帧
1、I 帧（Intra coded frames）:
2、P帧 （Predicted frames）:
3、B帧（Bi-directional predicted frames）:
4、GOP（ group of pictures）
5、DTS、PTS 的概念
三、音频中的一些概念
1、采样频率：每秒钟采样的点的个数。
2、采样量化：
采样精度（采样深度）：每个样本点的大小，常见的大小为8bit、16bit、24bit.
通道数:单声道、双声道、四声道、5.1声道
比特率：每秒传输的bit数，单位为：bps(Bit Per Scecond)
码率：
1.帧
2.帧长
四：关于封装格式的一些知识
封装格式
音视频同步问题
一、视频中的主要概念： 1、视频码率： kb/s 是指视频文件在单位时间内使用的数据流量，也叫码流率。码率越大，说明单位时间内取样率越大，数据流精度就越高。
2、视频帧率： fps 通常说的一个视频60帧 即1秒显示25张图
3、视频分辨率： 分辨率就是常说的640*480 1920*1080
二、I帧、 P帧、 B 帧、GOP帧 1、I 帧（Intra coded frames）: I帧不需要参考其他画面而生成，解码时仅靠自己就能重构完整图像。 I帧又称帧内编码帧，是一种自带全部信息的独立帧，无需参考其他图像便可独立进行解码，可以简单理解为一张静态画面。视频序列中的第一个帧始终都是I帧，因为它是关键帧。I帧是P帧和B帧的参考帧，且I帧是周期性出现在图像序列中，出现频率可以由编码器来设置。I帧是帧组GOP 的基础帧即第一帧，在一组中只有一个I帧。
2、P帧 （Predicted frames）: 根据本帧与相邻的前一帧（I帧或P帧）的不同来压缩本帧数据，P帧为向前预测，参考的是前面最靠近的I帧或P帧。解码时需要用之前缓存的画面叠加上本帧定义的差别，生成最终画面。与I帧相比，P帧通常占用更少的数据位，但不足是，由于P帧对前面的P和I参考帧有着复杂的依耐性，因此对传输错误非常敏感。
3、B帧（Bi-directional predicted frames）: B帧图像采用双向时间预测，可以提高压缩倍数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/109bfccef9d0df66a1231551fe819bb8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4e0ae336b8b542550069c59f722039a/" rel="bookmark">
			js 两个时间之间工作日的计算问题（包含节假日）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		录用2018年和2019年所有节假日期
&lt;script&gt; let arr = ["2018/01/01", "2018/01/06", "2018/01/07", "2018/01/13", "2018/01/14", "2018/01/20", "2018/01/21", "2018/01/27", "2018/01/28", "2018/02/03", "2018/02/04", "2018/02/10", "2018/02/15", "2018/02/16", "2018/02/17", "2018/02/18", "2018/02/19", "2018/02/20", "2018/02/21", "2018/02/25", "2018/03/03", "2018/03/04", "2018/03/10", "2018/03/11", "2018/03/17", "2018/03/18", "2018/03/24", "2018/03/25", "2018/03/31", "2018/04/01", "2018/04/05", "2018/04/06", "2018/04/07", "2018/04/14", "2018/04/15", "2018/04/21", "2018/04/22", "2018/04/29", "2018/04/30", "2018/05/01", "2018/05/05", "2018/05/06", "2018/05/12", "2018/05/13", "2018/05/19", "2018/05/20", "2018/05/26", "2018/05/27", "2018/06/02", "2018/06/03", "2018/06/09", "2018/06/10", "2018/06/16", "2018/06/17", "2018/06/18", "2018/06/23", "2018/06/24", "2018/06/30", "2018/07/01", "2018/07/07", "2018/07/08", "2018/07/14", "2018/07/15", "2018/07/21", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c4e0ae336b8b542550069c59f722039a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8e3107f65e647ce5badcbb71865370a/" rel="bookmark">
			实验六 基于有限状态机的序列检测、按键消抖
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		6.1实验目的 掌握有限状态机的设计。实现并仿真：
1)基于mealy状态机进行序列“1101”的检测；
2)基于moore或mealy状态机的按键消抖电路设计。
6.2实验内容 (1)基于mealy状态机进行序列“1101”的检测；
(2)基于moore或mealy状态机的按键消抖电路设计。
(3)按照本模版撰写实验报告，版面排版要求及评分标准：
6.3基于mealy状态机进行序列“1101”的检测 (1)设计代码
`timescale 1ns / 1ps module Seq_det_mealy(Clk,Rst_,din,y); input Clk,Rst_,din; output reg y; //状态符号声明 localparam [1:0] s0=2'b00,s1=2'b01,s2=2'b10,s3=2'b11; //状态信号声明 reg [2:0] cs,nst; //现态 always @(posedge Clk) if(!Rst_) cs&lt;=s0; else cs&lt;=nst; //次态 always @* begin case(cs) s0: if(din) nst=s1; else nst=s0; s1: if(din) nst=s2; else nst=s0; s2: if(din) nst=s2; else nst=s3; s3: nst=s0; default:nst=s0; endcase end //输出 always @* begin if((cs==s3)&amp;&amp;(din==1)) y=1; else y=0; end endmodule (2)RTL原理图
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c8e3107f65e647ce5badcbb71865370a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf230f2aa3130a116ff5f325c2bffe8d/" rel="bookmark">
			vue 表单数据修改，导致页面列表数据被同步修改问题的解决。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在vue的项目开发中，有时候在表单提交的时候，尤其是页面中对话层编辑数据，在修改的时候，会看到列表页面的数据也在跟着改变，这是vue 的双向数据绑定的弊端，实时更新数据，因为是一个数据源，因为在修改对象的时候，对象的指针直接指向页面数据 了，解决办法是：
在修改的时候，会获取到当前行的对象数据，那么我们不是直接赋值给我们的页面对象数据，而是：
this.addRoleFrom =JSON.parse(JSON.stringify(row)) // 改过之后的 this.addRoleFrom =Oject.assign(row,{}) // 原来的 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/297c5bf2f959017963cb2bdbc7346eb0/" rel="bookmark">
			Java对浮点数按照整数和小数进行拆分的代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		将开发过程经常用到的代码片段记录起来，下面代码段是关于 Java对浮点数按照整数和小数进行拆分的代码，应该是对各朋友有较大用处。
public class helloworld {
public static void main(String[] args) {
String msg, s; int i; System.out.println("请输入浮点数?"); String[] output = { "整数部分:", "小数部分:" }; s = st.nextToken(); System.out.println(output[i] + s); } } }
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/303/">«</a>
	<span class="pagination__item pagination__item--current">304/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/305/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>