<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a48654575ae37642241b1eb8a8e30948/" rel="bookmark">
			使用Navicat建表，解决删除某行数据后id自增依旧在原基础上进行的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述：通常我们都会给表中数据设一个id并让他自增，但当我们删除某条数据后id自增不会在现有数据的id基础上进行自增而是继续按原来的顺序自增。比方说有id为1，2，3三条数据，当我们删除了id为3的数据后再插入一条新数据它的id值将为4.
解决办法：
1.通过truncate table 完成
TRUNCATE TABLE table_name; 但这条语句会清空所有数据
2.删除表，然后重建表
DROP TABLE table_name; CREATE TABLE table_name { ... }; 3.在navicat里操作手动改自增值
右键此表，点击“设计表”，找到“选项”，将自动递增的值改成7，点击保存。继续增加字段，id的值就正常了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3603399a6db7aa98fa906252b8fc0c8b/" rel="bookmark">
			中兴B860AV1.1_机顶盒_（4G和8G版）刷机固件升级和教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		刷机准备： 1. 准备一条TTL线（CH340G 记得按照自己系统版本找店家要对应驱动）；
2. 下载putty软件；
3. 拆开电视盒，接好TTL线，接线方法256三个针脚对应GND、RX、TX接上即可；
4.打开资源管理器找到端口选项下方的CH340G（PS：记好此刻端口号后面的COMX 例如COM4）右键属性选择“端口设置”把第一选项改成“115200” ； 5. 打开Putty 看图设置 设置完点击弹出的窗口 电视盒开机的同时连续按下CTRL+Z 进入Mboot; 刷机方法： 1. Mboot下输入mmcinfo，回车，查看返回信息， 如果是3.多Gib就是4G的闪存，要刷对应的4G专用固件包， 如果7.多Gib就是8G的闪存，要刷对应的8G专用固件包， 如果第一次操作不显示内存信息，请操作两次，第二次就出来内存信息了；
2. U盘格式化为单分区FAT32，把MstarUpgrade.bin放入U盘根目录，插到盒子上（PS：不是单分区也行 但要把文件放在第一分区）
3. Mboot下输入usb_bin_check、回车、等待刷机完成自动重启 4. 刷完重启后，建议恢复一下出厂设置（密码6321）
5. 如果Mboot模式下复制粘贴输入以上命令出现错误请手动输入 固件获取：
链接1: https://pan.baidu.com/s/1qSmtBgSEbKs6ZFm-yCr-XQ
提取码: nnw3
链接2：https://wwt.lanzoux.com/b021zs97i
提取码：509a
声明：本安卓固件，仅供内部测试和技术交流使用，任何非法商业使用及商业利益冲突带来的法律纠纷，与本人无关，本人概不负责，请下载后24小时内删除，谢谢合作！刷机既有乐趣也有风险，请慎重选择，一切源于刷机造成的后果自负，本人概不负责！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31d9e50e87cc9dbf47796d7b596c511e/" rel="bookmark">
			创维E900V22C E900V22D 安卓9版本-U盘通刷固件及教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		创维E900V22C、E900V22D_AmlogicS905L3A芯片_安卓9-通刷-免费U盘刷机固件 固件说明：
1、创维E900V22C、E900V22D-AmlogicS905L3A芯片-U盘通刷刷机固件 ，不适用高安版本，不是所有地区都适用，请慎重下载；
2、优化系统核心，更快、更流畅、更稳定，去除限制安装限制，解除原厂wifi连接限制； 3、支持原装遥控器支持蓝牙； 4、固件压缩包有刷机教程，请一定仔细阅读。 刷机方法： 1、准备一个FAT32格式单分区U盘，如做过系统安装盘，PE之类的请初始化，1G-16G都可以。将recovery.img、update.zip、factory_update_param.aml 三个文件拷贝到根目录， 注意保证文件完整性； 2、盒子接上hdmi、网线、电源线保持关机状态，U盘插入盒子靠近网口的usb端口，盒子按下电源开关加电，通电同时反复按遥控右键刷机，速度不要太快或者太慢，每秒3次左右。引导U盘里的REC，直到显示刷机画面；或者尝试按左键进到刷机页面，立即关机，然后重新开机，点按右键，进到u盘里的rec刷机才能成功； 3、刷机大约耗时约三分钟，有进度条提示，完成后盒子会自动重启，第一次启动会优化系统程序，请耐心等待； 4、设置和恢复出厂密码：10086
声明：本安卓固件，仅供内部测试和技术交流使用，任何非法商业使用及商业利益冲突带来的法律纠纷，与本人无关，本人概不负责，请下载后24小时内删除，谢谢合作！刷机既有乐趣也有风险，请慎重选择，一切源于刷机造成的后果自负，本人概不负责！
刷机包获取： 链接1: https://pan.baidu.com/s/1qSmtBgSEbKs6ZFm-yCr-XQ
提取码: nnw3
链接2：https://wwt.lanzoux.com/b021zs97i
提取码：509a
声明：本安卓固件，仅供内部测试和技术交流使用，任何非法商业使用及商业利益冲突带来的法律纠纷，与本人无关，本人概不负责，请下载后24小时内删除，谢谢合作！刷机既有乐趣也有风险，请慎重选择，一切源于刷机造成的后果自负，本人概不负责！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da0c31db5392c6209ba58a0436917a97/" rel="bookmark">
			用c语言做图案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.用c语言做三角图形
#include&lt;stdio.h&gt; int main(void) { int i,j; for(i=1;i&lt;=4;i++) { for(j=1;j&lt;=4-i;j++) printf(" "); for(j=1;j&lt;=2*i-1;j++) printf("*"); printf("\n"); } } 2.用c语言做矩形图形
#include&lt;stdio.h&gt; int main(void) { for (int i = 0;i &lt;5 ;i++) { for (int j = 0;j&lt;5;j++) { if (i==0 || i==4 || j == 0 || j==4) { printf("*"); if (j==4) { printf("\n"); } continue; } else printf(" "); } } } 3.用c语言做梯形
#include&lt;stdio.h&gt; int main(void) { int N = 20; for(int i=0;i&lt;N;i++,putchar('\n')) { for(int j=0;j&lt;N-i;j++) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da0c31db5392c6209ba58a0436917a97/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/212e3b4ec2ae31fe41e20ba015559a5c/" rel="bookmark">
			如何删除360奇安信软件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.事情的缘由 之前待过一家公司，安装了360奇安信安全软件。由于更换了电脑，必须卸载奇安信，可是删除需要输入密码。后来联系了相关的人员，因为软件使用有点久远，没找到密码。
2.在安全模式下卸载 根据网上查询到的资料成功卸载奇安信软件。使用windows键 + R组合键打开运行框，接着输入"msconfig"，然后按回车键。
点击引导选项卡，接着选中系统，勾选引导选项中安全引导，然后点击确定。
弹出系统配置弹框，点击重新启动，然后重启电脑进入安全模式。
然后我们用everything搜索EntBase.dat配置文件，这个配置文件只有在进入安全模式时修改才生效。
把uienable和qtenable全部设置为0，关闭密码保护，接着删掉uipass和qtpass的密码。
然后打开电脑控制面板，选着程序卸载奇安信软件。
最后使用windows键+R组合键打开运行框，输入“msconfig”接着按回车。取消“安全引导”。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96b4287e8ef4625b61512610ff0d5cd6/" rel="bookmark">
			Redis常见数据类型和应用场景
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 我们都知道 Redis 提供了丰富的数据类型，常见的有五种：String（字符串），Hash（哈希），List（列表），Set（集合）、Zset（有序集合）。
随着 Redis 版本的更新，后面又支持了四种数据类型： BitMap（2.2 版新增）、HyperLogLog（2.8 版新增）、GEO（3.2 版新增）、Stream（5.0 版新增）。
所以，这次我们就来学习 Redis 数据类型的使用以及各自的应用场景。
PS：你可以自己本机安装 Redis 或者通过 Redis 官网提供的在线 Redis 环境 (opens new window)来敲命令。
String 介绍 String 是最基本的 key-value 结构，key 是唯一标识，value 是具体的值，value其实不仅是字符串， 也可以是数字（整数或浮点数），value 最多可以容纳的数据长度是 512M。
内部实现 String 类型的底层的数据结构实现主要是 int 和 SDS（简单动态字符串）。
SDS 和我们认识的 C 字符串不太一样，之所以没有使用 C 语言的字符串表示，因为 SDS 相比于 C 的原生字符串：
SDS 不仅可以保存文本数据，还可以保存二进制数据。因为 SDS 使用 len 属性的值而不是空字符来判断字符串是否结束，并且 SDS 的所有 API 都会以处理二进制的方式来处理 SDS 存放在 buf[] 数组里的数据。所以 SDS 不光能存放文本数据，而且能保存图片、音频、视频、压缩文件这样的二进制数据。SDS 获取字符串长度的时间复杂度是 O(1)。因为 C 语言的字符串并不记录自身长度，所以获取长度的复杂度为 O(n)；而 SDS 结构里用 len 属性记录了字符串长度，所以复杂度为 O(1)。Redis 的 SDS API 是安全的，拼接字符串不会造成缓冲区溢出。因为 SDS 在拼接字符串之前会检查 SDS 空间是否满足要求，如果空间不够会自动扩容，所以不会导致缓冲区溢出的问题。 字符串对象的内部编码（encoding）有 3 种 ：int、raw和 embstr。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96b4287e8ef4625b61512610ff0d5cd6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3b85b5638b925f4bb274bb217fa4cea/" rel="bookmark">
			Uncaught SyntaxError: Cannot use import statement outside a module问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在本地创建并运行html项目时，发现页面没有加载出来，控制台查看发现如下报错：
产生报错的原因：
由于为了方便更改变量，我创建了一个js文件，在文件中声明了token变量，并使用了模块化将变量导出 封装的js代码如下：
随后，我在编写的html文件里的&lt;script&gt;标签中，直接使用了import将变量导入 html代码：
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;cesium&lt;/title&gt; &lt;script src="../libs/Cesium/Cesium.js"&gt;&lt;/script&gt; &lt;link href="../libs/Cesium/Widgets/widgets.css" rel="stylesheet"&gt; &lt;style&gt; body,html{ margin:0; padding: 0; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="cesiumBox"&gt;&lt;/div&gt; &lt;script&gt; import {token} from '../utils.js' Cesium.Ion.defaultAccessToken=token; const viewer = new Cesium.Viewer('cesiumBox') &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 分析并解决：
由于我在html中引入了使用export导出的js文件，浏览器默认将它作为js解析会出现问题，需要将它作为模块导入，script标签默认type="text/javascript"，需要在script标签上添加type="module"
再次刷新浏览器，问题解决，界面出来了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e7ef176436b22758ef7d306a809d4c0/" rel="bookmark">
			ElasticSearch7.3.0 集群搭建及配置安全认证
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注: 由于是测试,搭建的环境就在一台机器上(操作系统是 CentOS 7) 配置 Elasticsearch Elasticsearch 的配置文件是 elasticsearch/elasticsearch.yml 集群的名称
配置集群的名称,所有的node节点集群名称要一致 # Use a descriptive name for your cluster: # cluster.name: my-application 节点的名称
配置每个节点的名称,节点的名称要在集群中唯一 # Use a descriptive name for the node: # node.name: node-1 索引文件的存储位置
默认是在当前目录下的data目录,可以自行修改 # Path to directory where to store the data (separate multiple locations by comma): # #path.data: /path/to/data 日志文件的存储位置
默认是在当前目录下的logs目录,可以自行修改 # Path to log files: # #path.logs: /path/to/logs Elasticsearch 运行绑定的 Host，默认是无法公开访问的，如果设置为 0.0.0.0 就可以公开访问 # Set the bind address to a specific IP (IPv4 or IPv6): # network.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e7ef176436b22758ef7d306a809d4c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1d2a94763357f9b087e8033598fd9c7/" rel="bookmark">
			python编程题——如何求一组数的全排列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		全排列就是把n个数按任意顺序进行排列，直到包含所有情况。按排列组合的知识来讲，情形共有n!种。
例：[1,2,3]
全排列：[1,2,3]，[1,3,2]，[2,1,3]
[2,3,1]，[3,1,2]，[3,2,1]
也就是共有3!=6种。
对于如何求一组数的排列，方法有很多，常用的有递归，深度优先搜索，广度优先搜索，但是在没有一定基础知识的情况下，想要理解这些知识还是比较困难的，设计出程序更是困难。
所以在下面的求解方法中，忽略上面的方法，以一种全新的方法来实现这个求解程序，一看便懂。
具体来讲，过程如下：
对于[1,2,3]这个例子，我们的算法是这样的。首先，是针对[1]，此时，我们该把2加入，显然可以有两种方式，一种是插入到1之前，另一种是插入到1之后，也就是插空，得到[1,2]，[2,1]，同理，下面插入3，显然，对于[1,2]，有三个空，把3分别插入，也就得到三种，对于[2,1]，也有三个空，把3分别插入，也得到三种。当然，这两大种情况一定不会重复，因为1和2的位置(先后顺序)是不同的。这样我们得到了由一个元素，两个元素，三个元素分别形成的全排列。我们取最后一个结果即可，也就是由所有元素形成的全排列。
最后结果：
[1,2,3]，[1,3,2]，[2,1,3]
[2,3,1]，[3,1,2]，[3,2,1]
代码实现：
def permute(nums): length=len(nums) result=[[[nums[0]]]] if length==1: return result[0] else: for i in range(1,length): #循环lengh-1次，也就是算到所有元素加入。 result.append(list()) #加入一个新列表，用于存储加入一个新元素后生成的全排列 for j in result[i-1]: #遍历上一个全排列 for k in range(len(j)+1): #循环len(j)+1次，也就是可插入新元素的位置为len(j)+1个 j.insert(k,nums[i]) #以上一个排列为基础，插入新元素 result[i].append(list(j)) #将得到的新的排列插入到新生成的列表中。 j.pop(k) #弹出插入的元素，使上一个全排列的内容恢复到原来状态。 return result[length-1] res=permute([1,2,3])print(res) 结果：
[[3, 2, 1], [2, 3, 1], [2, 1, 3], [3, 1, 2], [1, 3, 2], [1, 2, 3]] 当然，为了更好理解python的程序机制，下面给出一种上述程序的另一种代码，只有略小改动。
代码：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e1d2a94763357f9b087e8033598fd9c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6633d6a093919d14bd8874036213aa4f/" rel="bookmark">
			App常用图标素材网站
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 https://iconpark.bytedance.com
2 https://remixicon.com
3 https://www.iconfont.cn
4 https://icons.bootcss.com/
5 https://www.iconfinder.com/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b4cd8860fb321b761af47c4c7456436/" rel="bookmark">
			如何安装与配置Node.js
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Node.js发布于2009年5月，由Ryan Dahl开发，是一个基于Chrome V8引擎的JavaScript运行环境，使用了一个事件驱动、非阻塞式I/O模型， 让JavaScript 运行在服务端的开发平台，它让JavaScript成为与PHP、Python、Perl、Ruby等服务端语言平起平坐的脚本语言。
Node.js对一些特殊用例进行优化，提供替代的API，使得V8在非浏览器环境下运行得更好，V8引擎执行Javascript的速度非常快，性能非常好，基于Chrome JavaScript运行时建立的平台， 用于方便地搭建响应速度快、易于扩展的网络应用。
好吧，进入我们的正题，如何快速安装与配置Nodejs呢？
1，打开官网：https://nodejs.org/，会看到下列页面
点击downloads，到下个界面：
找到符合电脑类型的，下载对应的压缩包, 推荐下载zip格式。
2，解压文件，解压后，进入文件目录
在解压文件中新建两个文件夹：node_global，node_cache
3，打开命令行，进入解压后的文件夹。
输入两条命令：
npm config set prefix "D:\softwareone\node-v18.12.1-win-x64\node_global" npm config set cache "D:\softwareone\node-v18.12.1-win-x64\node_cache" 注：
D:\softwareone\node-v18.12.1-win-x64 是本人安装时的路径 ，此处要更改为自己的解压文件目录，下同。
4，环境变量配置
用户变量 编辑 path ：
D:\softwareone\node-v18.12.1-win-x64\node_global 系统变量 新建 NODE_PATH ：
D:\softwareone\node-v18.12.1-win-x64\node_global\node_modules 注：在系统变量中，打开path，如果没有
D:\softwareone\node-v18.12.1-win-x64\ 要加上，当然，一般是有的!
---------------------------------------
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cdeecea97c06da7e5b75e197936b595c/" rel="bookmark">
			Linux零拷贝解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
先备知识
物理内存
虚拟内存
内核空间和用户空间
内核空间
用户空间
DMA传输
上下文切换
传统IO执行流程
零拷贝实现的几种方式
用户态直接I/O
mmap+write实现的零拷贝
sendfile实现的零拷贝（用户不可见）
sendfile+DMA scatter/gather实现的零拷贝
splice
写时复制
总结
JAVA零拷贝API
Java NIO对mmap的支持
Java NIO对sendfile的支持
其它的零拷贝实现
Netty零拷贝
RocketMQ和Kafka对比
零拷贝（Zero-copy）技术指在计算机执行操作时，CPU 不需要先将数据从一个内存区域复制到另一个内存区域（例：CPU拷贝数据从内核缓冲区到用户缓冲区），从而可以减少CPU上下文切换以及 CPU 的拷贝时间。
它的作用是在数据报从网络设备到用户程序空间传递的过程中，减少数据拷贝次数（CPU拷贝），减少系统调用，实现 CPU 的零参与，彻底消除 CPU 在这方面的负载。
实现零拷贝用到的最主要技术是 DMA 数据传输技术和内存区域映射技术（mmap）。
零拷贝机制可以减少数据在内核缓冲区和用户进程缓冲区之间反复的 I/O 拷贝操作。零拷贝机制可以减少用户进程地址空间和内核地址空间之间因为上下文切换而带来的 CPU 开销。 先备知识 物理内存 物理内存，我们平时所称的内存也叫随机访问存储器（ random-access memory ）也叫 RAM 。而 RAM 分为两类：
一类是静态 RAM（ SRAM ），这类 SRAM 用于 CPU 高速缓存 L1Cache，L2Cache，L3Cache。其特点是访问速度快，访问速度为 1 - 30 个时钟周期，但是容量小，造价高。 另一类则是动态 RAM ( DRAM )，这类 DRAM 用于我们常说的主存上，其特点的是访问速度慢（相对高速缓存），访问速度为 50 - 200 个时钟周期，但是容量大，造价便宜些（相对高速缓存）。 内存由一个一个的存储器模块（memory module）组成，它们插在主板的扩展槽上。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cdeecea97c06da7e5b75e197936b595c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8214ffe238136d21ac3f6003cc9c4cd6/" rel="bookmark">
			QTableWidget中如何清空行，并保持行仍可再写入数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题：
写qt程序时，使用到了QTableWidget制作了表格，并显示数据。我打算表格最多显示100行，如果超过100行内容，则清除100行内容后，从0行开始重新写入数据。使用ClearContents()函数，可以清除内容，但是会导致之前存在的行无法再写入数据。
解决方法：
使用removeRow()函数清空每一行内容，全部清空后，再逐行添加内容。
if(nCount&gt;=100) { for(k=0;k&lt;100;k++) { ui-&gt;tableWidget-&gt;removeRow(0); } nCount =0; } 注意：每次清空都是第0行。因为每删除一次，表格行数就会变化，清空第0行后，之前的第1行就成为了新的第0行！！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5851ef4c9bd0172736f921ba99f11ff/" rel="bookmark">
			离线运行程序screen命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、安装screen apt-get install screen 2、常用的命令 创建新的screen会话
screen -S [SCREEN] 加入screen会话
screen -x [SCREEN] 退出并关闭screen会话
exit 离开当前screen会话(不退出)
Ctrl+a+d 显示所有已经打开的screen会话
screen -ls 恢复某screen会话（只有当此会话没人连接时，用-r才可以恢复连接，）
screen -r [SCREEN] 删除某screen会话
screen -d [SCREEN] 查看所有screen会话命令
screen -h 3、自动关机（有空尝试一下）
1、命令后加shutdown
$ python train.py # 原执行命令 $ python train.py; shutdown # 用;拼接意味着前边的指令不管执行成功与否，都会执行shutdown命令 $ python train.py &amp;&amp; shutdown # 用&amp;&amp;拼接表示前边的命令执行成功后才会执行shutdown 2、python文件中执行shutdown命令
import os if __name__ == "__main__": # xxxxxx os.system("shutdown") 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8774dd04ac1526ac7cfe717703c91ad/" rel="bookmark">
			C语言小程序游戏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		c语言小程序游戏 ​ 本代码是我大一刚学完c语言自己编写的，三个游戏分别是飞机竞速、走迷宫和魔塔，满满的都是回忆。
1、不可能的任务-飞机竞速 ​ 这种游戏在以前小时候玩的游戏机里面玩过，那时抱着个游戏机一玩就是一下午，如今感觉大型3A电脑游戏也不过如此，回首往事时才发现，那段无忧无虑的时光真是太奢侈了。
#include&lt;stdio.h&gt; #include&lt;windows.h&gt; #include&lt;time.h&gt; int i,j,k,a,b,c,d=0,x=15,y=4,m=1; char ch,n[21][16]={ "###############", "# #", "# #", "# #", "# #", "# #", "# #", "# #", "# #", "# #", "# #", "# #", "# #", "# #", "# #", "# #", "# #", "# #", "# #", "###############" }; void line(int z) { for(i=0;i&lt;z;i++) printf("\n"); } void space(int z) { for(j=0;j&lt;z;j++) printf("\t"); } void head() { space(1); printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f8774dd04ac1526ac7cfe717703c91ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a0f4c22e883cdbf8b092f4773021cfe/" rel="bookmark">
			【wireshark mac 无权限抓包】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mac启动wireshark时，提示没有权限抓包，报错内容如下：
“The capture session could not be initiated on interface ‘en0’ (You don’t have permission to capture on that device).
Please check to make sure you have sufficient permissions.
If you installed Wireshark using the package from wireshark.org, Try re-installing it and checking the box for the “Set capture permissions on startup” item.”
解决办法，打开终端，输入
sudo chmod 777 /dev/bpf*
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3f633afe64cf2f9400ce503516ba8ac/" rel="bookmark">
			adb_adb file transfer文件传输(adb push/pull)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 adb file transfer使用文档 adb命令行进行文件传输注意事项adb push🎈路径名约定 push文件保持名字直接传输传输的同时更改名字非法的路径参数非法的路径参数 powershell函数 更多adb 文件传输示例绝对路径传输文件实例相对路径传输示例利用adb shell 检查android 设备文件 adb pull adb file transfer 使用文档 包括三个子命令:
比较常用的是前面
使用adb push可以用来向anroid设备传输文件
另一方面,adb pull可以从android 设备将文件拉取到电脑上
push
push [--sync] [-z ALGORITHM] [-Z] LOCAL... REMOTE copy local files/directories to device --sync: only push files that are newer on the host than the device -n: dry run: push files to device without storing to the filesystem -z: enable compression with a specified algorithm (any/none/brotli/lz4/zstd) -Z: disable compression pull
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3f633afe64cf2f9400ce503516ba8ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df9f295f174003fbd6448b01d9a299b1/" rel="bookmark">
			Guava之CacheLoader CacheBuilder LoadingCacbe以及两种驱逐策略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		缓存，在咱们平常开发中是必不可少的一种解决性能问题的方法。简单的说，cache 就是为了提高系统性能而开辟的一块内存空间。缓存的作用就是将数据保存在内存中，当有其余线程或者客户端须要查询相同的数据资源时，直接从缓存的内存块中返回数据，这样不但能够提高系统的响应时间，同时也能够节省对这些数据的处理流程的资源消耗，总体上来讲，系统性能会有大大的提高。
Guava Cache是一个全内存的本地缓存实现，它提供了线程安全的实现机制。总体上来讲Guava cache 是本地缓存的不二之选，简单易用，性能好。
1 基本使用 package com.cache; import com.cache.domain.Employee; import com.google.common.base.Optional; import com.google.common.cache.CacheBuilder; import com.google.common.cache.CacheBuilderSpec; import com.google.common.cache.CacheLoader; import com.google.common.cache.CacheStats; import com.google.common.cache.LoadingCache; import com.google.common.cache.RemovalCause; import com.google.common.cache.Weigher; import com.google.common.collect.Maps; import org.apache.commons.collections4.map.HashedMap; import org.junit.Test; import java.util.Map; import java.util.concurrent.ExecutionException; import java.util.concurrent.TimeUnit; import java.util.concurrent.atomic.AtomicInteger; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertNotEquals; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertNull; import static org.junit.Assert.assertTrue; import static org.junit.Assert.fail; /** * 缓存加载程序测试 * * @author zhaoshuai11 * @date 2022/11/19 */ public class CacheLoaderTest { private Boolean FROM_DB = false; @Test public void testBasic() throws ExecutionException, InterruptedException { LoadingCache&lt;String, Employee&gt; cache = CacheBuilder.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df9f295f174003fbd6448b01d9a299b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58eefe3d1823c96c0e1e4eac6a1ced4c/" rel="bookmark">
			Android 驾车出行路线规划
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		好久没有写了，今天又是加班的一天，先随便写点东西吧。
最近在搞一款自驾游的项目，需要用到地图，扒了点高德上的数据，便集成了高德地图SDK。之前的项目大部分都只是用了定位，其中有一款也用了地图poi的搜索，都没有接到高德要求收商业授权费。这次这个项目调用的接口将会很多，看会不会要求收商业授权费吧。
吐槽下高德地图的开发指南文档、Demo，版本大改动这些都不带更新的。得看参考手册。
路线规划不显示路况拥堵的问题，让我们Android开发走了很多弯路。我帮忙看了下，有几次都要放弃了，最后我还是攻克了。希望对刚接触高德地图的友友们有所帮助。
言归正传———
集成sdk：高德sdk更新日志
高德地图Android SDK(3D地图) V9.5.0 2022-10-14
高德地图Android SDK(搜索) V9.5.0 2022-11-08
需求场景：
根据起终点规划出驾车出行路线，这就要应用到高德中的驾车出行路线规划的功能。
问题：
Demo给的方法是使用RouteSearch搜索规划路线，路线是有的，但是不显示道路拥堵情况。以下是AMap_Android_API_3DMap_Demo 驾车路径规划运行截图。
RouteSearch.FromAndTo fromAndTo = new RouteSearch.FromAndTo(startLatLon, latLonPoint); // fromAndTo包含路径规划的起点和终点，drivingMode表示驾车模式 // drivingMode表示路径规划的策略，可选，默认为0-速度优先； // 第三个参数表示途经点（最多支持6个），第四个参数表示避让区域（最多支持32个），第五个参数表示避让道路 DriveRouteQuery query = new DriveRouteQuery(fromAndTo, drivingMode, null, null, ""); //使用类 RouteSearch 的 calculateRideRouteAsyn(RideRouteQuery query) //方法进行骑行规划路径计算。 routeSearch.calculateDriveRouteAsyn(query) //接收数据 public void onDriveRouteSearched(DriveRouteResult result, int rCode) { final DrivePath drivePath = result.getPaths().get(0);//获取规划出的第一条路线方案。 List&lt;DriveStep&gt; drivePaths = drivePath.getSteps();//返回驾车规划方案的路段列表。 for (DriveStep step : drivePaths) { List&lt;LatLonPoint&gt; latlonPoints = step.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/58eefe3d1823c96c0e1e4eac6a1ced4c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5757db342ff4f8547083c34e5bd15ff3/" rel="bookmark">
			差分卷积在计算机视觉中的应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击上方“小白学视觉”，选择加"星标"或“置顶”
重磅干货，第一时间送达 编者荐语
文章主要介绍由Oulu大学主导的几个差分卷积（Difference Convolution）工作及其在图像、视频领域中的应用。
作者丨Fisher 鱼子 @知乎
链接丨https://zhuanlan.zhihu.com/p/392986663
相关工作已被 TPAMI, TIP, CVPR'20, ICCV'21 (Oral), IJCAI'21 等顶级期刊会议接收，并斩获两项国际大赛冠亚军（1st Place in the ChaLearn multi-modal face anti-spoofing attack detection challenge with CVPR 2020 [16] 和 2nd Place on Action Recognition Track of ECCV 2020 VIPriors Challenges [17]）。
1.鼻祖LBP的简单回顾
在传统的手工特征中，比较经典的有Oulu提出的 LBP(Local Binary Patterns)，即局部二值模式 [1]，至今引用已有16000+。最初的LBP是定义在3×3邻域内的，以邻域中心像素为阈值，将相邻的8个像素的灰度值与其进行差分比较，若周围像素值大于中心像素值，则该像素点的位置被标记为1，否则为0。这样，邻域内的8个点经比较可产生8位二进制数（通常转换为十进制数即LBP码，共256种），即得到该邻域中心像素点的LBP值，并用这个值来反映该区域的纹理信息。
图1. LBP算子提取流程 用公式表示为： LBP算子运算速度快，同时聚合了邻域内的差分信息，对光照变化较为鲁棒；同时也能较好地描述细粒度的纹理信息，故在早期纹理识别，人脸识别等都被广泛应用。下图为人脸图像在做LBP变换后的LBP码图像，可以看出脸部局部纹理特征较好地被表征：
图2. 人脸及其LBP图 2.中心差分卷积CDC在人脸活体检测中的应用 [2,3]
CDC代码链接: github.com/ZitongYu/CDC
Vanilla卷积通常直接聚合局部intensity-level的信息，故 1）容易受到外界光照等因素的影响；2）比较难表征细粒度的特征。在人脸活体检测任务中，前者容易导致模型的泛化能力较弱，如在未知的光照环境下测试性能较低；后者会导致难以学到防伪本质的细节信息，如spoof的材质。考虑到空间差分特征具有较强光照不变性，同时也包含更细粒度的spoof线索（如栅格效应，屏幕反射等），借鉴传统LBP的差分思想，我们提出了中心差分卷积（Central difference convolution, CDC）。
图3. 中心差分卷积CDC 假定邻域 为3x3区域，公式表达如下： 为了更好同时利用 intensity-level 和 gradient-level 的信息，我们通过超参 及共享卷积可学习的权重，统一了VanillaConv和CDC，而无需额外的可学习参数（和可忽略的计算量）。故更generalized的CDC公式为： θ控制着差分卷积及Vanilla卷积的贡献，值越大意味着gradient clue占比越重；当θ=0时，就成了Vanilla卷积。文章 [3]中也具体对比了CDC与前人工作Local Binary Convolution [4], Gabor Convolution [5] 和 Self-Attention layer [6]，有兴趣的请查阅原文。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5757db342ff4f8547083c34e5bd15ff3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5d190d34c8e7265db82630fea5f57d7/" rel="bookmark">
			scanf函数读入整型数据时，输入字符型数据程序会发生什么变化（C语言）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 本文主要介绍C语言内置函数scanf在读入整形数据时，程序员或用户输入字符型数据程序将发生什么变化。本文基于猜数字游戏实现（点击链接可以查看游戏如何实现，但不读也可看懂本文）
在开发软件时，我们常会给用户提供一个菜单进行选择，如图所示。
具体实现代码如下：
int n = 0;//定义一个变量， do { printf("***********************\n"); printf("***1：开始\\继续游戏****\n"); printf("***0：退出游戏*********\n"); printf("***********************\n"); printf("请您进行选择："); scanf("%d", &amp;n); switch (n) { case 1: printf("开始游戏\n"); break; case 0: printf("成功退出游戏\n"); break; default: printf("输入错误，请重新输入\n"); break; } } while (n); 由代码可知，我们先初始化整形变量n为0；
如果用户正常输入1时，则在屏幕上打印开始游戏；
如果输入1和0以外的其它数字时则会打印输入错误，请重新输入。
直到输入为0时，才能退出循环并在屏幕上打印成功退出游戏。
下图是正确输入时，程序反馈的结果：
上图只进行了整型数据的输入，若我们在此时输入一个字符型数据会发生什么呢？
如下图所示：
可见当我输入a之后，程序就不断的打印菜单以及开始游戏，进入了死循环。
发生这种情况的归于以下两个原因：
1.第一次我输入的数据为1，n此时的值由0改变为1。（输入什么不重要，仅以1为例，如果输入为0，则会直接打印退出游戏）
2.scanf(“%d”,&amp;n) 只能读入整形数据，当我们输入字符类型的数据如a时，scanf(“%d”,&amp;n) 不能读入，而导致字符数据a一直留在缓冲区中被scanf（）函数一次又一次的读入，而n的值却一直为整型数据1不发生变化，从而进入打印的死循环。
n的值为1不发生改变，可点击F10进入调试后，点击窗口-&gt;监视-&gt;再任意选择一个窗口进入。
输入n再逐步调试就可以发现n的值的变化
总结 通过以上内容，我们对scanf函数有了进一步的了解，希望此文章对大家C语言的学习有所帮助。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1d0447b6808f7835420d224bd379de5/" rel="bookmark">
			使用阿里云OSS实现文件上传
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述场景 文件上传，是程序开发中必须会使用到的一个功能，比如：
添加商品，用户头像，文章封面等需求富文本编辑（插件文件上传） 文件上传的原理是什么？ 我们为什么要实现文件上传，其实就要共享资源，大家都可以看你的在平台上上传的文件；其实就是把用户自己电脑中的文件，通过程序上传到服务器的过程。
总结一下：把用户的文件javaIO流复制到服务器上的过程，称之为文件上传。
用springboot实现文件上传 实现步骤 1.搭建一个springboot项目 2.准备一个页面上传的页面 在resources/templates/upload.html
server: port: 8777 spring: freemarker: suffix: .html cache: false 3、实现后台的文件上传 定义文件上传的service
package com.ygt.service; import org.springframework.stereotype.Service; import org.springframework.web.multipart.MultipartFile; import java.io.File; import java.io.IOException; /** * @Author ygt * @Date 2022/9/21 18:50 * @Version 1.0 */ @Service public class UploadService { /** * MultipartFile 这个对象是springMvc提供的文件上传的接收的类， * 他的底层会去和HttpServletRequest request 中的request.getInputStream()融合 * 从而达到文件上传的效果。也就是说： * 文件上传的原理就是：request.getInputStream() * @param multipartFile * @param dir * @return */ public String uploadImg(MultipartFile multipartFile,String dir){ //1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f1d0447b6808f7835420d224bd379de5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f61ebf4ff0501db4b99bd64b361dfea7/" rel="bookmark">
			C语言实现扫雷游戏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 扫雷游戏概述以及运行效果一、扫雷游戏所需要的函数的介绍和实现1.初始化埋下地雷的数组2.打印地雷图3.放置地雷4.查找地雷 游戏的工程文件1.game.h2.test.c3.game.c 扫雷游戏概述以及运行效果 如下图所示，用户输入1时开始游戏，输入0时退出游戏
开始游戏后打印地雷图（本文以9*9的地雷图为例子），让用户选择要扫雷的坐标（x，y）
如果该位置没有雷，则在该位置打印围绕在该坐标的地雷数。如果周围的地雷数为0，则会自动检查（x-1,y-1),(x-1,y),(x-1,y+1),(x,y-1),(x,y+1),(x+1,y-1),(x+1,y),(x+1,y+1)周围的地雷数并以此类推，直至每个坐标周围都有地雷围绕。
如果该位置有雷则输出“您踩到雷了，游戏失败”并将地雷图打印出来（数字1的地方是埋雷的地方，数字0的地方是没有雷的地方）进入下次游戏的选择。
如果最终游戏胜利则输出恭喜您游戏胜利
一、扫雷游戏所需要的函数的介绍和实现 1.初始化埋下地雷的数组 在本次游戏中我们将会创建两个二维数组
一个用于记录地雷埋下的位置（该数组初始化为0），坐标上为1的表示有雷，为0的表示无雷，如图所示
一个用于（该数组全部初始化为星号）展示给玩家让玩家进行选择要对哪个位置进行扫雷
void Init_board(char board[ROWS][COLS], int row, int col, char a) { for (int i = 0; i &lt; row; i++) { for (int j = 0; j &lt; col; j++) { board[i][j] = a; } } } 2.打印地雷图 该函数用于打印如下所示的地雷图，供用户选择扫雷的坐标
void print_board(char board[ROWS][COLS], int row, int col) { printf("*************扫雷*************\n"); for (int i = 0; i &lt;= col; i++) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f61ebf4ff0501db4b99bd64b361dfea7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03d4826ee21849d4af014df2b670840b/" rel="bookmark">
			MySQL 可重复读隔离级别，完全解决幻读了吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我在上一篇文章中提到，MySQL InnoDB 引擎的默认隔离级别虽然是「可重复读」，但是它很大程度上避免幻读现象（并不是完全解决了），解决的方案有两种：
针对快照读（普通 select 语句），是通过 MVCC 方式解决了幻读，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。针对当前读（select ... for update 等语句），是通过 next-key lock（记录锁+间隙锁）方式解决了幻读，因为当执行 select ... for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。 这两个解决方案是很大程度上解决了幻读现象，但是还是有个别的情况造成的幻读现象是无法解决的。这次，就跟大家好好聊这个问题。
什么是幻读？ 首先来看看 MySQL 文档是怎么定义幻读（Phantom Read）的:
The so-called phantom problem occurs within a transaction when the same query produces different sets of rows at different times. For example, if a SELECT is executed twice, but returns a row the second time that was not returned the first time, the row is a “phantom” row.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/03d4826ee21849d4af014df2b670840b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7a333f628d6ebfd63c332f91719cbe8/" rel="bookmark">
			MySQL事务隔离级别是怎么实现的？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我的钱包里共有100万。
今天我心情好，我决定给你的转账 100 万，最后的结果肯定是我的余额变为 0 元，你的余额多了 100 万元，是不是想到就很开心？
转账这一动作在程序里会涉及到一系列的操作，假设我向你转账 100 万的过程是有下面这几个步骤组成的：
可以看到这个转账的过程涉及到了两次修改数据库的操作。
假设在执行第三步骤之后，服务器忽然掉电了，就会发生一个蛋疼的事情，我的账户扣了 100 万，但是钱并没有到你的账户上，也就是说这 100 万消失了！
要解决这个问题，就要保证转账业务里的所有数据库的操作是不可分割的，要么全部执行成功 ，要么全部失败，不允许出现中间状态的数据。
数据库中的「事务（Transaction）」就能达到这样的效果。
我们在转账操作前先开启事务，等所有数据库操作执行完成后，才提交事务，对于已经提交的事务来说，该事务对数据库所做的修改将永久生效，如果中途发生发生中断或错误，那么该事务期间对数据库所做的修改将会被回滚到没执行该事务之前的状态。
事务有哪些特性？ 事务是由 MySQL 的引擎来实现的，我们常见的 InnoDB 引擎它是支持事务的。
不过并不是所有的引擎都能支持事务，比如 MySQL 原生的 MyISAM 引擎就不支持事务，也正是这样，所以大多数 MySQL 的引擎都是用 InnoDB。
事务看起来感觉简单，但是要实现事务必须要遵守 4 个特性，分别如下：
原子性（Atomicity）：一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节，而且事务在执行过程中发生错误，会被回滚到事务开始前的状态，就像这个事务从来没有执行过一样，就好比买一件商品，购买成功时，则给商家付了钱，商品到手；购买失败时，则商品在商家手中，消费者的钱也没花出去。一致性（Consistency）：是指事务操作前和操作后，数据满足完整性约束，数据库保持一致性状态。比如，用户 A 和用户 B 在银行分别有 800 元和 600 元，总共 1400 元，用户 A 给用户 B 转账 200 元，分为两个步骤，从 A 的账户扣除 200 元和对 B 的账户增加 200 元。一致性就是要求上述步骤操作后，最后的结果是用户 A 还有 600 元，用户 B 有 800 元，总共 1400 元，而不会出现用户 A 扣除了 200 元，但用户 B 未增加的情况（该情况，用户 A 和 B 均为 600 元，总共 1200 元）。隔离性（Isolation）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致，因为多个事务同时使用相同的数据时，不会相互干扰，每个事务都有一个完整的数据空间，对其他并发事务是隔离的。也就是说，消费者购买商品这个事务，是不影响其他消费者购买的。持久性（Durability）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。 InnoDB 引擎通过什么技术来保证事务的这四个特性的呢？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e7a333f628d6ebfd63c332f91719cbe8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb1f955a7b39dbd1f8293df299f5fe60/" rel="bookmark">
			ps命令应用(查看进程)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记录：320
场景：在CentOS 7.9操作系统上，ps命令是查看进程信息工具。查看进程状态、进程使用内存状况、进程使用CPU状况、进程PID等。
版本：
操作系统：CentOS 7.9
1.ps命令介绍
ps命令，process status的简称。一个查看进程信息工具。可以查看启动哪些进程、进程运行的状态、进程占用资源情况等。收集这些信息有助于监测和控制进程。比如，写自动化脚本时，根据进程信息决定下一步执行动作。
ps命令，查看进程执行瞬间的进程信息工具。查看进程状态、进程使用内存状况、进程使用CPU状况、进程PID等。
top命令，查看进程实时动态信息工具。查看进程状态、进程使用内存状况、进程使用CPU状况、进程PID等。
僵尸进程，一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称为僵尸进程。
2.ps常用命令
(1)ps帮助命令
命令：ps --help a
功能：查看ps支持的全部命令和选项，在实际工作中，查看这个手册应该是必备之选。
(2)查看当前会话中打开进程
命令：ps
功能：查看当前会话打开的进程，实际上就是ps进程和bash进程。因为ps是使用bash的shell脚本，因此也有bash进程。
(3)查看全部进程
命令：ps -e
命令：ps -A
功能：-e，-A，查看全部进程。打印字段：PID、TTY、TIME、CMD信息。一般使用-e。
(4)查看全部进程且完整格式，包括命令行
命令：ps -ef
功能：-f完整格式，包括命令行。打印字段：UID、PID、PPID、C、STIME、TTY、TIME、CMD。
(5)查看全部进程搜索指定内容
命令：ps -ef | grep java
功能：在ps -ef列出的内容中，使用grep命令搜索含有关键字java的进程，实际一般这样组合使用。注意，使用搜索后，不显示字段名称了。
(6)查看全部进程显示完整信息
命令：ps -eF
功能：-F，显示完整信息，打印字段：UID、PID、PPID、C、SZ、RSS、PSR、STIME、TTY、TIME、CMD。如果想查看进程对内存和CPU使用情况，可以使用此命令。
(7)查看全部进程以用户维度输出信息
命令：ps aux
功能：a，打印全部有tty终端启动的进程。x，打印没有tty控制终端的进程。u，以用户为导向的格式输出。打印字段：USER、PID、%CPU、%MEM、VSZ、RSS、TTY、STAT、STATT、TIME、COMMAND。需要查看用户的进程的CPU、内存以及进程状态，可以使用这种方式
(8)查看全部进程以用户维度输出信息指定搜索
命令：ps aux | grep java
功能：查看全部进程以用户维度输出信息指定关键字搜索。
3.ps命令字段解析
执行ps命令后，打印信息的第一行是字段名称，即每一列代表的意思。
3.1常用字段
UID：进程的用户的ID号。
USER：启动进程的用户。
PID：进程的唯一ID。
PPID：进程的父进程的ID号。
C：进程的CPU处理器利用率。
TTY：启动进程的终端名称。表示该进程在哪个终端运行，不是从某个终端启动的进程或者与终端无关的进程显示为?号，查看终端名称可以使用：ll /dev/。
TIME：进程使用CPU的累计时间。
CMD/COMMAND：进程所运行的命令。
STIME/STATT：进程的启动时间。
%CPU：进程占用CPU的百分比
%MEM：进程占用内存的百分比(使用物理内存计算)。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb1f955a7b39dbd1f8293df299f5fe60/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6edb9619475e2fcf838377af5756a81/" rel="bookmark">
			分析时域窗长度和FFT计算点数对频率分辨率和栅栏效应的影响
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
频率分辨率
栅栏效应
频谱泄漏
实验结果：
窗长度改变：
改变fft计算点数
分析：
代码：
频率分辨率 频率分辨率是指将两个相邻谱峰分开的能力。在实际应用中是指分辨两个不同频率信号的最小间隔。果采样频率为fs，采样时间间隔为t，采样点数为N，采样时间为t（完成一组样本的采集所需要的时间），则频率分辨率Δf=fs/N，研究数字频谱最有效方法通常是离散傅里叶变换。
栅栏效应 栅栏效应是因为DFT计算的频谱被限制在基频的整数倍而不可能将频谱视为一个连续函数而产生的。就一定意义而言，栅栏效应表现为用DFT计算整个频谱时，就好像通过一个“栅栏”来观看一个图景一样，只能在离散点的地方看到真实图景。
频谱泄漏 所谓频谱泄漏 ,就是信号频谱中各谱线之间相互影响 ,使测量结果偏离实际值 ,同时在谱线两侧其他频率点上出现一些幅值较小的假谱。
产生频谱泄露的原因
由于计算机只能处理有限长的数据，所以需要对采集的信号进行截断，相当于对原始信号做了加窗处理。对信号加窗就是对信号在时域上乘以一个窗函数，时域的乘积对应频域的卷积，而窗函数的频域包括主瓣和旁瓣，旁瓣造成了信号频谱的泄漏。频域泄漏不可避免，只能减小。
如何抑制
可以取更长的数据点，与原始数据越接近越好，但缺点就是运算量加大；
可以选择窗谱的旁瓣能量较小的窗函数。
典型的窗函数中，矩形窗的频率分辨率最高，旁瓣泄露最大。
实验结果： 窗长度改变： N=180;%信号长度
fs=9;%采样频率
l=10;%窗长度为l
M1=300;%加窗信号fft计算点数
M=M1;
L=40
L=80
L=140
L=180
改变fft计算点数 %加窗信号fft计算点数
N=180;%信号长度
fs=9;%采样频率
l=180;%窗长度为l
M1=50;%加窗信号fft计算点数
M=M1; 140
180
185
190
200
280
400
800
分析： 频率分辨率有两种说法：机械频率分辨率和物理频率分辨率。机械频率分辨率由采样频率和采样点所决定的，为fs/N，N为采样点数，fs为采样频率。物理频率分辨率指的是频谱上两个谱峰之间的间隔。比如说：当信号为两个频率相近的正弦信号的叠加的时候，频谱信号会有两个相近的谱峰，那么频谱分辨率大小就决定了两个谱峰是否可以被分辨出。
数字信号处理中的频谱分辨率为1/T，T为信号长度，而与采样点数无关。
当矩形窗的长度从0增大时，DTFT的频谱分辨率增大，DFT频谱的栅栏效应会减弱。
由于矩形窗函数的频谱函数有旁瓣值，所以加窗后的信号的频谱函数也会有频谱泄露，但随着窗的长度不断变大，频谱泄露的情况不断改善，但是不可能完全消除。
当fft计算点数小于采样点数时，加窗函数的DFT的频谱图都有失真，当计算点数大于采样点数且不断增大时，DFT频谱函数与DTFT函数相差不大，频率分辨率会逐渐稳定为fs/N，此时，也会存在栅栏效应，若想减弱栅栏效应，可以通过增加fft计算点数来使DFT频谱更加光滑，此时采样频率f(s)会随之成正比上升，又由于频率分辨率F=f(s)/N，频率分辨率不改变，也就是说，补零不改变频率分辨率。
但是若像提高频率分辨率，是不能只增大计算点数M的，因为增大M点数，相当于在信号序列后面补0，即相当于在DFT频域上进行插值，虽然最小间隔变小了，但只是把DFT频谱变得更加光滑了；所以，若想提高频谱分辨率，需要增大采样信号的长度。
代码： %分析时域窗长度和FFT计算点数对频率分辨率和栅栏效应的影响。对含有两个间隔较小的频率分量的余弦序列，
%时域加窗后计算FFT，画出DTFT和DFT频谱图，对比分析不同的时域窗长度和FFT计算点数。
clear all;
% t=10;%信号长度
N=180;%信号长度
fs=9;%采样频率
l=180;%窗长度为l
M1=800;%加窗信号fft计算点数
M=M1;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f6edb9619475e2fcf838377af5756a81/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7125fa82669cf9c57eb9320f761e6b96/" rel="bookmark">
			【Unity300个技巧】牛顿的学问！如何优雅地使用力？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Unity 提供了一个完备且强大物理引擎。但在刚接触的时候，你可能会对它与现实物理规律对应有一些疑惑。
比如：
现实中 1N 的力在 Unity 中怎么表现？Unity 中物体的质量是计算的？Unity 中给物体添加力的方法是 rb.AddForce()，但却又提供了4种力的模式，为什么呢？ 本文章，我们就来探讨一下以上的问题。
额外资源 项目地址：GitGub视频：B站视频 Unity 中力的单位 在 Unity 中，rb.AddForce()是给物体添加一个力的方法，传参是向量对象，向量的 x ，y，z 代表这方向，值代表力的大小。
这里可能会让人疑惑，这里力的单位是什么呢？是否对应现在中的力的单位 N ？
要验证这个点，最好的办法就算找一个物理学中常量，看这个常量在 Unity 中是多少。
毫无疑问，重力就是我们心中的那个常量。
在现实中，重力约等于 9.81N。
在Unity 中，我们可以在设置里看到重力的默认值，在Y轴方向的大小也是9.81。
所以，我们可以认为，传参向量值的单位等于现实中的 N。
我们可以验证一下。
在一个只有重力的场景，我们添加一个9.81的相对于重力反方向的力，物体时静止的。
代码实现
public class TestGravity : MonoBehaviour { private Rigidbody2D _rigidbody2D; [Header("向上的力")] [SerializeField] private float _force; void Start() { _rigidbody2D = transform.GetComponent&lt;Rigidbody2D&gt;(); } private void FixedUpdate() { _rigidbody2D.AddForce(new Vector3(0, _force, 0)); } } 运行一下。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7125fa82669cf9c57eb9320f761e6b96/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c996afbc9a065f4a93aa452442d7eb8a/" rel="bookmark">
			图像处理基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为了响应国际庄女菩萨的号召，首先介绍下图像入门的基础名词：
像素：像素是分辨率的单位，像素是构成位图图像最基本的单元，每个像素都有自己的颜色。
分辨率：单位英寸内的像素点数，单位是PPI(Pixeks Per Lnch),表示每英寸对角线上所拥有的像素数目。
RGB：指的是图片中的光学三原色(red、green、blue)，与日常生活中的光学三原色是有区别。
灰度：表示图像像素明暗程度的值，就是黑白图像中的颜色深度，范围是在0-255，白色为255，黑色为0.
通道：把图像分解成一个或多个颜色分成：
1、单通道：一个像素点只需要一个数值表示，只能表示灰度。（二值图&amp;灰度图）。
2、三通道：RGB模式，把图像分为红绿蓝三个通道，可以表示彩色，也可以自定义通道颜色，全0为黑色。
3、四通道：RGBA模式，在RGB的基础上加了alpha通道，表示透明度，alpha=0表示全透明
对比度：指不同颜色之间的差别。对比度 = 最大灰度值/最小灰度值。
频率：灰度值变化剧烈程度的指标，是灰度在平面空间上的梯度。
为什么很多图像识别将彩色图像灰度化？
目的是为了简化矩阵，提高运算速度。彩色图片中的信息含量过大，进行图像识别时灰度图像的信息足够。
下面开始对图像的基本操作进行沉浸式学习。 がんばれ、兄弟姉妹たち！！
图像处理基础 加载图像保存图像调整图像大小裁剪图像平滑处理图像图像锐化提升对比度颜色分离图像二值化移除背景边缘检测角点检测为机器学习创建特征将颜色平均值编码成特征将色彩直方图编码成特征 使用的python工具包有openCV、Numpy、Matplotlib，根据自己的python版本安装使用。 推荐百度的镜像，下载速度很快：-i https://mirror.baidu.com/pypi/simple 加载图像 cv2.IMREAD_GRAYSCALE，指的是灰度模式读取一张图片，实际取值为0
plt.axis(“off”)，指的是关闭坐标轴
#把图像导入成灰度图 image = cv2.imread('image/plan.png',cv2.IMREAD_GRAYSCALE) #如果想查看图片可以使用 plt.imshow(image,cmap='gray'),plt.axis("off") plt.show() 保存图像 image = cv2.imread('image/plan.png',cv2.IMREAD_GRAYSCALE) cv2.imwrite('image/plan_save.png',image) 调整图像大小 因为被用作特征的图像必须有相同的大小（像素数），其次是被标准化的处理图像会带来一些像素上的损失，其中包含的信息也会随之减少，优点是，成百上千张图片在计算时可以大大较少内存的使用量。
#以灰度图格式导入图像 image = cv2.imread('image/plan_256*256.png',cv2.IMREAD_GRAYSCALE) #将图片尺寸调整为50*50像素 image_50_50 = cv2.resize(image,(50,50)) #查看图片 plt.imshow(image_50_50,cmap='gray'),plt.axis("off") plt.show() 裁剪图像 选择要保留的行和列，裁剪出感兴趣的区域。 比如说小区的门禁，把脸裁出来。
#以灰度图格式导入图像 image = cv2.imread('image/plan_256*256.png',cv2.IMREAD_GRAYSCALE) #选择所有行和前128列 image_cropped = image[:,:128] #查看图片 plt.imshow(image_cropped,cmap='gray'),plt.axis("off") plt.show() 平滑处理图像 平滑处理是指将每个像素的值变换为其相邻像素的平均值。相邻像素和执行的操作在数学上表示为一个核，这个核的大小决定了平滑程度，核越大，产生的图像越平滑。本例使用的是一个5*5的核，感兴趣可以试一下不同的是什么效果。
#以灰度图格式导入图像 image = cv2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c996afbc9a065f4a93aa452442d7eb8a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09cb41474be4c6e49ae90b5164950c0d/" rel="bookmark">
			C 语言 指针（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
数组指针
一维数组与指针
如何用指针使用数组
数组元素的引用方式
二维数组与指针
指向二维数组首地址的指针变量
指向二维数组中某个一维数组的指针变量
字符串与指针
将指针变量指向字符串常量
指向字符串常量指针变量的使用
结构体指针
指向结构体变量的指针
指向结构体数组的指针
用结构体变量作为函数参数
数组指针 一维数组与指针 指针表示地址，数组名对应着数组的首地址，所以可以通过指针访问数组元素
数组通过数组名+下标的方式访问元素
数组的指针就是数组所在的存储区域的起始地址
数组元素的指针就是数组元素存储单元的地址
例：
#include&lt;stdio.h&gt; int main() { int arr[5]={0,1,2,3,4},i,*p; p=NULL; printf("%d\n",p);//printf函数直接显示指针地址，运行结果为0 p=arr; printf("%x *p=%d\n",p,*p);//%x 表示输出16进制，*p=0,这时p指向数组的首地址，输出的值就是数组首个元素的值 for(i=0;i&lt;5;i++) printf("%x *p=%d\n",p++,*p); return 0; } 运行结果如下：
数组名代表数组首地址，即数组这首个元素的地址
a与&amp;a[0]等价：a是地址常量，是系统分配空间时返回的地址，不是变量不能给af赋值
如果能赋值就是重新指一段连续的空间了
如何用指针使用数组 1.指向数组首地址的指针变量的定义及赋值方式
（1）定义的同时进行初始化赋值
类型 *指针变量名=数组名或&amp;数组名[0]
（2）先定义后赋值
类型 *指针变量名；
指针变量名=数组名或&amp;数组名[0]
2.指向数组元素的指针变量的定义和赋值方式
（1）定义的同时进行初始化赋值
类型 *指针变量名=&amp;数组名[下标]；
（2）先定义后赋值 类型 *指针变量名
指针变量名=&amp;数组名[下标]
注意：定义和赋值中的类型要与数组的基类型一致
定义指针类型一定与数组的类型相同
例子：
#include&lt;stdio.h&gt; void f(int *x,int *y)//函数f的参数是指向整型数据的指针，传递的是地址 { int t; t=*x; *x=*y; *y=t;//这三个赋值语句是对指针所指单元的进行交换 } main() { int a[8]={1,2,3,4,5,6,7,8},i,*p,*q; p=a;q=&amp;a[7];//指针变量p取a的首地址，q取a7的地址 while(p&lt;q)//用指针比较，也就是地址的比较 { //在数组中元素单元实际地址是（首地址 +下标 ）*4 f(p,q);p++;q--; } for(i=0;i&lt;8;i++) printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/09cb41474be4c6e49ae90b5164950c0d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e356051e9f5be1810eaa9bcd85be0a08/" rel="bookmark">
			VM虚拟机卡顿、闪退一系列问题与卸载重装问题（详细版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最新发现好多虚拟机有闪退现象，对此我给出一系列解决方案，仅供参考
一.软件问题 1.虚拟机闪退 首先，如果是VMware Workstation Pro也就是软件本身闪退问题，即还没有运行或打开系统时就已经闪退，说明软件有问题，可以先试试把环境变量删除，以及关闭防火墙
如果没有奏效，大概率为电脑兼容问题，解决方案为右击VMware软件，在属性里面找到兼容性，勾选以兼容模式运行这个程序，选Windows7，接着点击以管理员身份运行
如果还是有问题，在桌面右击计算机，打开管理，进入服务和应用程序服务，或者直接win+R,运行窗口输入services.msc，找到vmware服务"VMware Authorization Service",将其设置为自启动，就可以打开虚拟机了
如果还是有问题，那就是可能软件的问题，需要对软件进行卸载重装，卸载步骤在下面会详细介绍
2.虚拟机卡顿 在使用过程中遇到卡顿问题的解决方案
1.内存设置
编辑--&gt;首选项--&gt;内存--&gt;额外内存--&gt;选中第一个
编辑--&gt;首选项--&gt;优先级--&gt;抓取的输入内容--&gt;调整为高（此处可以把快照取消勾选）
虚拟机设置（右击创建的虚拟机）--&gt;选项--&gt;高级--&gt;高--&gt;勾选禁用内存页面调整
二.系统问题 这种情况就是虚拟机软件本身没有问题，是打开运行系统出了问题，对于创建虚拟机也是有要求的，如果内存设置太大，处理器太多，而虚拟机本身就是在物理机的基础上再建系统，一些硬件能力比较弱的电脑就有点力不从心了，所以，检查以下自己创建的虚拟机配置是否有些不妥，具体根据自己电脑配置来，创建虚拟机的详细步骤在这篇文章里面有介绍，以Windows10为例，供参考。虚拟机安装win10教程
以下解决参考方案：
检查操作系统位数与运行环境是否一致；光盘映像文件与创建新虚拟机时配置要一样，x86是32位，x64是64位 配置启动项，虚拟机和装的系统不能放在同一路径下，这里建议虚拟机一个文件夹，在创建新的虚拟机前新建一个文件夹，将新建的系统文件统一放入该文件夹，上面参考文章也有说明； 检查主机网络是否打开NX，在网络适配器里面可以找到； 虚拟机配置内存是否超过主机最大内存限制，上面便有讲到，关于内存配置问题，不能过小，太小虚拟机运行不起来，也不能过大，太大主机又吃不消，所以根据不同系统适合不同的内存，一般最少2G，4G内存足矣，处理器默认1个，如果是在上面做一些需要CPU处理的数据，设置两个处理器内核即可 关闭快照功能，有一种可能，虚拟机保存了状态快照镜像文件不合适，换个镜像文件 三.卸载虚拟机 上述解决方案仍无作用，就要考虑卸载重装了，有些同学卸载后，发现二次安装失败，这是由于卸载的时候没有卸载干净，存留一些注册表之类的文件没有删除干净，接下来就详细介绍下如何干净卸载的过程
1.关闭虚拟机服务
进入服务，找到VM的服务，全部禁用，进入过程上文有讲到，共有四个服务需要操作 2.卸载网卡 右击计算机，打开管理，找到设备管理器，点击网络适配器，对上述关于VM进行右击，卸载
3.结束进程
鼠标放到桌面最下面任务栏，右击，打开任务管理器，找到所有VM的进程，可能不止一个，全部结束进程
4.清除注册表
快捷键win+R运行窗口输入“regedit”，进入注册表编辑器
依次找到路径，计算机\HKEY_CURRENT_USER\SOFTWARE\VMware, Inc.
如果不放心，试着在其他几个主文件夹里面找关于VM的文件夹，一并删除
5.删除相关文件夹
在C盘找到VMware文件夹并删除
C:\Program Files (x86)\VMware
6.卸载
进入控制面板，在程序和功能，卸载，找到VMware双击就会进入软件自身的安装程序，选择删除
到此，VMware卸载完毕，卸载后，请重启电脑
四.安装虚拟机 我自己用的虚拟机软件，我用的是16.pro版本，安装文件和注册码一并放到网盘链接里，请自行下载安装，安装过程较为简单，这里就不过多介绍，有问题可以随时在评论区
阿里云盘：VM安装包
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d34f776340db572c10fc31005a67662/" rel="bookmark">
			如何设计qPCR引物序列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		感谢李三多师弟的倾囊相授！
文献中寻找序列PrimerBank 中寻找（https://pga.mgh.harvard.edu/primerbank/） 本次着重第二种方法
打开PubMed的Gene界面(https://www.ncbi.nlm.nih.gov/)，输入需要查询的基因名称(如METTL3)，确认好种属（如小鼠），查询Gene ID
复制Gene ID，打开 PrimerBank,依次选好检索条件，点击Submit查询（可能等待时间稍长）。（https://pga.mgh.harvard.edu/primerbank/）
结果如下：
查看的细节如下：
*
比如挑中这一对，到BLAST里验证：
找出序列后，在Pubmed（https://www.ncbi.nlm.nih.gov/）里的BLAST进行模拟。
页面往下滑，选择Primer-BLAST。
由于在新窗口打开结果，我们可以尝试下一对引物，如复制粘贴Primer pair 2的正反引物进行比较。
操作同上。
出现这个页面的话点Check查看结果
共验证了四对引物，来看看结果比较：
通过序列和Length定位到这个序列：
挑选引物的细节*：
①Forward和Reverseprimers 退火温度（Tm） 55-75℃，60℃为宜，且相差不超过4℃。更严格的标准有：Tm相差最好不超过1
②引物的GC含量一般为40-60%，以45-55%为宜，过高或过低都不利于引发反应。上下游引物的 GC含量不能相差太大
③给出的数对引物中，Amplicon Size一般小于200，大于200初筛即可淘汰。PCR扩增产物长度： 引物的产物大小不要太大，一般在80-250bp之间都可；80-150bp最为合适（可以延长至300 bp）
④尽可能多尝试，找出最合适的
⑤Self complementarity0-3为理想状态；self 3’ complementarity 严格＜1/4碱基数。总的来说，越低越好。对应的数值越小，非特异性扩增和引物二聚体就越少。Max Self Complementarity 默认值是8.00，Max 3’ Self Complementarity 默认值是3.00
⑥引物长度一般在15-30碱基之间。引物长度18-27bp，不大于38bp
⑦3’端碱基一般不用A，最好用T，3’端避开密码子第三位，3’端不应该有超过3个连续的C或G
⑧transcript variant是转录本的意思，具体含义可以自行百度。大多数基因都有好几个转录本，转录本越多说明这个引物越好。
⑨跨内含子的勾选，参考如下图：若出不来结果，尝试取消此筛选
⑩若别无他选，有其他干扰的物质的产物量大于1000，PCR扩增不出来此干扰产物，可考虑
参考来源：
https://www.zhihu.com/question/457819740
https://zhuanlan.zhihu.com/p/76211729
https://blog.sciencenet.cn/home.php?mod=space&amp;uid=1509670&amp;do=blog&amp;quickforward=1&amp;id=1094003
https://zhuanlan.zhihu.com/p/103537195
https://www.biomart.cn/experiment/793/2714179.htm
https://www.biomart.cn/experiment/430/457/741/43975.htm
https://www.jianshu.com/p/5fba2bc168d4
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2be013f258c2d575b500f836178a9fc4/" rel="bookmark">
			QT第二天（计算器实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
实现功能：加，减，乘，除，取余，小数点，取反（），数字回退，全部清0。
一、实现结果（win7的计算器）对比：
二、实现思路
三、代码实现
1、首先是将按钮摆放好（双击.ui文件界面）
2、主窗口定义函数 3、接收id槽函数
4、运算按钮槽函数，其实都是重复的代码
5、等号运算槽函数
6、其他槽函数
7、头文件，也就一些声明的槽函数
实现效果
总结：
实现功能：加，减，乘，除，取余，小数点，取反（这个最难搞，要兼容前面的），数字回退，全部清0。 一、实现结果（win7的计算器）对比： win7自带计算器：
我做的：
二、实现思路 1、用QButtonGroup()按钮组让数字按键放入同一个组中，就可以不用写0-9的按钮槽函数，大量节省代码。
2、将加减乘除这些按钮单独定义槽，作用是储存点击的数字和运算符。（误区：这些函数内部并不是实现直接进行运算，而是将运算的数值符号储存。给等号"="槽函数内部计算）；
3、定义三个QString类型的变量，第一个是存储大标签的数据，第二个是存储小标签的数据（即右上角顶部那个位置的数据），第三个是标志位，判断是否取反(+-)，就在运算减号那里用了一下。
4、需要调用一些QString字符串函数。
三、代码实现 1、首先是将按钮摆放好（双击.ui文件界面） 2、主窗口定义函数 #include "mainwindow.h" #include "ui_mainwindow.h" #include "QButtonGroup" #include &lt;qDebug&gt; 定义一个按钮组对象 QButtonGroup *bg; QString num="0"; //存储大标签数据 QString num2="0"; //存储小标签数据 QString num3="0"; //标志位 MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent) , ui(new Ui::MainWindow) { ui-&gt;setupUi(this); 绑定按钮组 bg = new QButtonGroup(this); bg-&gt;addButton(ui-&gt;pushButton_1,1); 添加按钮，用id传递 bg-&gt;addButton(ui-&gt;pushButton_2,2); 数字按键 bg-&gt;addButton(ui-&gt;pushButton_3,3); bg-&gt;addButton(ui-&gt;pushButton_4,4); bg-&gt;addButton(ui-&gt;pushButton_5,5); bg-&gt;addButton(ui-&gt;pushButton_6,6); bg-&gt;addButton(ui-&gt;pushButton_7,7); bg-&gt;addButton(ui-&gt;pushButton_8,8); bg-&gt;addButton(ui-&gt;pushButton_9,9); bg-&gt;addButton(ui-&gt;pushButton_11,0); //关联对象按钮,buttonClicked()是内部函数！用于发送id信号。 connect(bg,SIGNAL(buttonClicked(int)),this,SLOT(Calculate(int))); } 3、接收id槽函数 用来接收id值的函数，即1,2,3,4,5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2be013f258c2d575b500f836178a9fc4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/419310965f63327b830da72a5894d591/" rel="bookmark">
			UTM投影与2000坐标系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近由于工作的原因，正在接触路径规划算法。给到的地图以及ROS消息接口涉及到了UTM投影与2000坐标系，之前根本没接触过。通过网上的资料查询，在这里对UTM投影与2000坐标系进行简单的介绍。
一、UTM投影 1.1 简介 UTM(Universal Transverse Mercator Grid System, 通用横墨卡托网格系统)投影，是由美国军方在1947提出的。至于其中的数学基础，可参考百度等网站上的介绍。
1.2 UTM投影带分布 经度分区：编号1-60，其中58个区的东西跨度为6°;纬度分区：编号C-X(不含I,O,共20个区)，每个区的南北跨度为8°;A,B,Y,Z覆盖南极和北极区;N为第一个北纬带，N之后的字母均为北纬带，N之前的字母均为南纬带。 上图转自知乎一 一 1.3 WGS 1984坐标系的墨卡托投影分度带(UTM ZONE)选择方法 北半球地区，选择最后字母为“N”的带；可根据公式计算，带数=（经度整数位/6）的整数部分+31。 例如：北京市经度范围为东经115.7°-117.4°，带数≈116/6+31=50，即50N，则表示为WGS 1984 UTM ZONE 50 N。
UTM投影带号-经度对应表 1.4 UTM坐标表示格式 UTM坐标的一般形式为：35P 453200mE 1400649mN。 35表示位于经度35区；P表示位于纬度P区；453200mE表示东向位置为453200m；1400649mN表示北向位置为1400649m。 1.4.1 东向位置 每个经度区均有一条中心经线，如35区的经度范围为24E-30E，则其中心经线为27E。中心经线以东的点到中心经线距离为正，中心经线以西的点到中心经线距离为负，则某点的东向位置即为该点到中心经线的距离加500,000m。
例如：中心经线以东100m的点的东向位置为：500,000 + 100 = 500,100m。
​ 中心经线以西100m的点的东向位置为：500,000 - 100 = 499,900m。
1.4.2 北向位置 北半球北向位置即为该点到赤道的距离。
南半球北向位置为10,000,000m减去该点到赤道的距离。
例如：赤道以北1000m的点的北向位置为：1000mN。
​ 赤道以南1000m的点的南向位置为：10,000,000 - 1000 = 9,999,000m。
所有点的北向位置也是正数。
二、2000坐标系 2000国家大地坐标系，是我国当前最新的国家大地坐标系，英文缩写为CGCS2000。原点为包括海洋和大气的整个地球的质量中心；Z轴由原点指向历元2000.0的地球参考极的方向，该历元的指向由国际时间局给定的历元为1984.0的初始指向推算，定向的时间演化保证相对于地壳不产生残余的全球旋转，X轴由原点指向格林尼治参考子午线与地球赤道面（历元2000.0）的交点，Y轴与Z轴、X轴构成右手正交坐标系。
Transform coordinates - GPS online converter 可以实现经纬度坐标和2000坐标系的转换。
三、参考文献 UTM坐标系简述 - 知乎 (zhihu.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/419310965f63327b830da72a5894d591/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1540ee1639d5f64d90bc9d78ad8d5595/" rel="bookmark">
			FPGA（verilog）频率计实验——学习历程①
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 本文利用verilog语言完成频率计实验，由于是第一次发文，文章格式以及描述语言请谅解，内容仅供参考，烦请各路大神指正。
二、模块 数码管动态显示模块分频模块频率测试模块顶层调用模块 三、主要代码 1、数码管动态显示模块 module seg_led(
input clk,
input rst_n,
input [19:0] data,//6个数码管最高显示999999，需要20位
input [5:0] point,//小数点
input sign,//负号
input en,
output reg [7:0] seg_data,//数码管显示的笔画值
output reg [5:0] seg_sel
);
wire [3:0] data0;//个位
wire [3:0] data1;//十位
wire [3:0] data2;//百位
wire [3:0] data3;//千位
wire [3:0] data4;//万位
wire [3:0] data5;//十万位
reg [3:0] clk_cnt;
reg dri_clk;
reg [23:0] num;
reg [12:0] cnt0;
reg flag;
reg [2:0] cnt_sel;
reg [3:0] num_disp;
reg dot_disp;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1540ee1639d5f64d90bc9d78ad8d5595/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13c6f8820c1c514f91b2ce112fff0cb1/" rel="bookmark">
			通用Mapper获取数据表中id为0解决方法。千万别瞎改int为integer了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目场景： 最近准备自己写一个框架。由于是舍弃了成熟框架，所以在集成一些组件的时候，发现了一些之前没有注意过的问题。
这次是集成通用mapper时出现的一个问题。。。
问题描述 使用通用Mapper的selectAll()方法后，得到的id值都为0：
代码如下：
实体类User.java：
package org.example.module.test.vo; import lombok.Data; import javax.persistence.Table; @Data @Table(name = "user") public class User { private int id; private String username; private String password; } Controller类UserController.java：
@Api(tags = "User模块") @RestController @RequestMapping("/user") public class UserController { @Autowired private UserService userService; @ApiOperation(value = "获取所有用户") @GetMapping("/getAll") public Result&lt;?&gt; getAllUser(){ List&lt;User&gt; userList = userService.getAllUser(); return Result.ok(userList); } } Service类UserService.java：
@Service public class UserService { @Autowired public UserMapper userDao; public List&lt;User&gt; getAllUser() { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13c6f8820c1c514f91b2ce112fff0cb1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a142dfa3ce5ac57c59abe9af92252cc2/" rel="bookmark">
			八款流行无线黑客工具，非常实用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、Aircrack
Aircrack是最受欢迎的无线密码破解工具之一，可用于802.11a / b / g WEP和WPA破解。Aircrack使用的算法是通过捕获数据包来恢复无线密码。收集到足够的数据包后，它会尝试恢复密码。为了使攻击更快，它通过一些优化实现标准的FMS攻击。
该工具背后的公司还提供一个在线教程，您可以在其中学习如何安装和使用此工具来破解无线密码。它来自Linux发行版，并提供Live CD和VMWare镜像选项。您可以使用其中任何一种。它支持大多数无线适配器，基本都保证可以使用。如果您使用的是Linux发行版，该工具唯一缺点就是它需要了解Linux的知识。如果你对Linux不熟悉，你会发现很难使用这个工具。在这种情况下，请尝试Live CD或VMWare镜像，VMWare镜像需要较少的准备知识，但它仅适用于一组有限的主机操作系统，并且需要支持USB设备。
在开始使用此功能之前，请确认无线网卡可以注入数据包，然后再开始WEP破解。阅读网上的在线教程，了解更多有关该工具的信息。
2、AirSnort
Airsnort是另一种在WiFi 802.11b网络上解密WEP加密的工具，它是一个免费工具，支持Linux和Windows平台。虽然此工具已经不再维护，但是仍然可以从Sourceforge下载。一旦收集到足够的数据包，AirSnort就会通过被动监控传输和计算加密密钥来工作，该工具易于使用，如果您有兴趣，可以尝试使用此工具破解WEP密码。
3、Cain &amp; Able
Cain &amp; Able是一种流行的密码破解工具。开发此工具是为了拦截网络流量，然后通过使用密码分析再进行暴力破解密码，它还可以通过分析路由协议来恢复无线网络密钥。如果你正在尝试学习无线安全和密码破解，你应该尝试这个工具。
4、Kismet
Kismet是WiFi 802.11 a / b / g / n layer2无线网络嗅探器和IDS。它适用于支持RF-mon模式的任何无线网卡，它被动地收集数据包以识别网络并检测隐藏的网络。它建立在C/S模块化架构之上，适用于Linux、OSX、Windows和BSD平台。微信搜索公众号：Linux技术迷，回复：linux 领取资料 。
5、NetStumbler
NetStumbler是一种流行的Windows工具，用于查找开放式无线接入点，此工具是免费的，支持Windows。该工具还存在精简版MiniStumbler。
但该工具也有很大的劣势，大多数可用的无线入侵检测系统都可以轻松的检测到它，这是因为它主动探测网络以收集有用的信息。该工具的另一个缺点就是它无法正常工作在最新的64位Windows操作系统上，这是因为该工具最后一次更新于2011。
6、inSSIDer
inSSIDer是适用于Windows和OSX操作系统的流行WiFi扫描工具。最初工具是开源的，后来工具进行收费，现在售价将近20美元。它还被授予"最佳网络开源软件"。inSSIDer WiFi扫描器可以执行各种任务，包括查找开发的WiFi接入点，跟踪信号强度以及使用GPS记录保存日志等。
7、WireShark
WireShark是网络协议分析器，它可以让您检查网络中发生的情况，您可以实时捕获数据包并进行分析。它捕获数据包并允许您在微观级别检查数据，它可以在Windows、Linux、OS X、Solaries、FreeBSD等上运行。WireShark需要很好的网络协议知识来分析使用该工具获得的数据。如果您对此不了解，可能会觉得这个工具并不有趣。因此，只有在确定自己的协议知识时才能进行尝试。
8、CoWPAtty
CoWPAtty是WPA-PSK的自动字典攻击工具，它运行在Linux上，该程序具有命令行界面，并使用字典进行密码攻击。
使用该工具非常简单，但速度很慢，因为使用的哈希是带有SSID的SHA1，这意味着相同的密码将具有不同的SSIM。因此，您不能简单地对所有接入点使用彩虹表。该工具使用密码字典，并使用SSID为字典中包含的每个关键字进行攻击。
该工具的新版本试图通过使用预先计算的哈希文件来提高速度，这个预先计算的文件包含大约17000个字典文件，用于大约1000个最受欢迎的SSID。但是如果您的SSID不在那1000个中，就很不走运了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53a7fc75e7b896a49562fa9feb14a6b4/" rel="bookmark">
			安装descriptastorus
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 descriptastorus的github地址是：descriptastorus若要安装descriptastorus需要先安装依赖包：rdkit和scikit-learn注意descriptastorus的requirements.txt要求：
pandas-flavor==0.2.0
pandas&gt;=0.24.0
rdkit-pypi&gt;=2022.3.3所以就算你之前已经安装好了rdkit，如果小于它要求的版本也是不行的，会出现错误：
所以进入这个链接，下载安装版本大于2022.3.3的rdkit，【注意】python版本要一致
例如pip install rdkit-2022.3.3-cp37-cp37m-manylinux_2_17_x86_64.manylinux2014_x86_64.whl rdkit安装完了，安装scikit-learn，pip install scikit-learn然后安装descriptastorus，pip install descriptastorus 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06053425c865698a8fc29ca305c074dd/" rel="bookmark">
			tps计算方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、稳定性测试TPS怎么计算 （1）普通计算公式：TPS= 总请求数 / 总时间
按照需求得到基础数据，在2022年第20周，某平台有5万的浏览量，那么总请求数我们可以估算为5万（1次浏览都至少对应1个请求）
总请求数 = 50000请求数
总时间：由于不知道每个请求的具体时间，我们按照普通方法，我们可以按照一天的时间进行计算，总时间 = 1天 = 1 * 24 小时 = 24 * 3600 秒
套入公式可得：TPS = 50000/24*3600秒= 0.58tps
结论：按照普通计算方法，我们在测试环境对相同的系统进行性能测试时，每秒能够发送0.58tsps就可以满足线上的需要
（2）二八原则计算方法
二八原则就是指80%的请求在20%的时间内完成
计算公式 ： TPS = 总请求数 80% / (总时间20%)
**按照公式进行计算：TPS =50000* 0.8请求数 / 24*3600*0.2秒 = 2.3tps
结论：按照二八原则计算，在测试环境我们的TPS只要能达到2.3请求数每秒就能满足线上需要。二八原则的估算结果会比平均值的计算方法更能满足用户需求。
（3）按照业务运营数据进行计算
如xxx消费券的发放时间固定开始时间，那个用户将会在活动开始前的30分钟内陆续开始访问多彩宝首页，进入消费券主页，在活动开始前5分钟大量访问，活动倒计时10秒钟和活动开始后2分钟内会有用户不断点击和刷新页面，
根据以往活动数据，活动期间，平台总请求数据未50000，时间持续180分钟。那么得到总请求=50000，时间=158x60=9480秒；
再根据二八原则，80%用户在20%时间内访问，得出：tps=50000x80%/9480x20%=40000/1896=21tps/s
计算模拟用户峰值业务操作（压力测试）的并发量，根据这些数据统计图，可以得出结论：可以拿21tps/s作为稳定性测试的参考值
二、并发压力测试tps计算 先说三个概念
1、用户数：数据库中的总用户数
2、在线用户数：登录状态的用户数，挂在系统上，但是不会对系统产生压力
3、并发用户数：真正产生操作的用户，产生压力之源
1、秒杀活动压测数据计算 假如平台总注册用户数有100w，有10w用户约定好同时对某一接口进行访问，比如1分钟，陆续来访10w用户，那么我们系统并发用户是比实际的10w要小的
那一个秒杀活动开始时，10w用户在10秒内重复请求多次，平均3次每个人，那么tps=100000/10=10000tps，表明我们目标的tps应达到10000才能抗住100000用户的同时请求
2、领券活动压测 平台注册用户数100w，用10w用户准备抢券，即10w人同时在10秒内访问抢券接口，在过程中每个用户可能会多次点击抢券，估算每个用户点击3次抢券接口，那么
tps=100000*3/10=30000tps，系统的目标tps需达到30000才抗住10w用户的并发访问压力
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5ff1921f11b1b4c7dd18d2ec89c1c3f/" rel="bookmark">
			js 数组for循环请求接口，并把返回数据放进新数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求：用一个数组中的每个值去循环请求接口，获取对应数据放进新数组
举个栗子可能更好理解：老师想知道每个同学的成绩，然后有个接口是需要用同学的id去拿到对应的分数。
那么，已知数组是：
[1, 2, 3, 4] // 同学id数组 目标数组是：
[ { id: 1, name: '张三', score: 98 }, { id: 2, name: '李四', score: 99 }, { id: 3, name: '王五', score: 99 }, { id: 4, name: '老六', score: 100 }, ] 解决： 使用 async，await
methods: { async handleGoods(arr) { let idArr = [1, 2, 3, 4]; let scoreArr = []; for (let i = 0; i &lt; idArr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e5ff1921f11b1b4c7dd18d2ec89c1c3f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b61abc8246f331857c1c4568fcd4f3f5/" rel="bookmark">
			安装node.js - v18遇到的一些问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.安装好node.js后，去某个项目根目录下npm install发现有一个和python有关的报错。
2.我去安装了一个python311,然后再运行npm install还是报错。
3.我发现是python环境变量没配置好的问题，去检查发现环境变量自动配置在了当前windows用户下，又卸载了当前的python重新安装时选择自定义安装，把for all user 勾上还有那个添加到环境变量也勾上。
4.再次运行npm install终于不报错了。
5.运行npm start 发现又报错了，去网上查了原因是少了设置nodejs 版本大于等于v17的都有这个问题。
6.解决方法：
方法1：下面的方法在每一次运行npm命令之前都要运行一次
Linux ：在命令行执行：export NODE_OPTIONS=--openssl-legacy-provider
windows：在命令行执行：set NODE_OPTIONS=--openssl-legacy-provider
方法2：直接在package.json文件脚本命令中加入set NODE_OPTIONS=--openssl-legacy-provider如下：
"scripts": { "serve": "set NODE_OPTIONS=--openssl-legacy-provider &amp;&amp; vue-cli-service serve --open", "start": "set NODE_OPTIONS=--openssl-legacy-provider &amp;&amp; npm run serve", "dev": "set NODE_OPTIONS=--openssl-legacy-provider &amp;&amp; npm run serve", "build": "set NODE_OPTIONS=--openssl-legacy-provider &amp;&amp; vue-cli-service build --report", }, 7.再次运行npm start 成功启动服务器。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b435d4112a489959b6b2678041375e9/" rel="bookmark">
			ajax异步同步及请求方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、同步异步执行 默认是不写是：true；true：异步请求；false：同步请求；这里的同步异步执行，仅仅限定了事件的回调函数的执行顺序；异步执行：当同步代码执行完以后，再去执行异步的回调函数；同步执行：按照代码顺序从上到下执行；建议异步执行，同步执行容易造成代码阻塞； 2、请求方式 get：明文传输，不安全，可以携带的数据量不大，post：在body中传输，安全，携带数据量可以很大put：偏向更新全部数据patch：偏向部分修改delete：偏向删除信息 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/452edb549b9b3ed15ebb735fd3f366d8/" rel="bookmark">
			马士兵Socket
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网络编程（TCP/IP编程） != 网站编程
qq,MSN,游戏，魔兽争霸
socket：client端的插座
serversocket: TCP 服务器端的插座
UDP没有所谓的server、client
public static void main(String[] args) throws IOException { ServerSocket serverSocket = new ServerSocket(8888); // 服务器端也建立了一个插座 serverSocket.accept(); // 如果client没有连接，则傻傻等待 System.out.println("已连接"); } public class TCPClient { public static void main(String[] args) throws IOException { // 客户端申请连接 Socket socket = new Socket("127.0.0.1",8888); } public class TCPServer { public static void main(String[] args) throws IOException { ServerSocket serverSocket = new ServerSocket(8888); // 服务器端也建立了一个插座 while (true){ Socket ss = serverSocket.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/452edb549b9b3ed15ebb735fd3f366d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7969744cef1d098b62476bff30929e35/" rel="bookmark">
			SpringMVC 域对象共享数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、使用ServletAPI向request域对象共享数据 @RequestMapping("/testServletAPI") public String testServletAPI(HttpServletRequest request){ request.setAttribute("testScope", "hello,servletAPI"); return "success"; } 2、使用ModelAndView向request域对象共享数据 @RequestMapping("/testModelAndView") public ModelAndView testModelAndView(){ /** * ModelAndView有Model和View的功能 * Model主要用于向请求域共享数据 * View主要用于设置视图，实现页面跳转 */ ModelAndView mav = new ModelAndView(); //向请求域共享数据 mav.addObject("testScope", "hello,ModelAndView"); //设置视图，实现页面跳转 mav.setViewName("success"); return mav; } 3、使用Model向request域对象共享数据 @RequestMapping("/testModel") public String testModel(Model model){ model.addAttribute("testScope", "hello,Model"); return "success"; } 4、使用map向request域对象共享数据 @RequestMapping("/testMap") public String testMap(Map&lt;String, Object&gt; map){ map.put("testScope", "hello,Map"); return "success"; } 5、使用ModelMap向request域对象共享数据 @RequestMapping("/testModelMap") public String testModelMap(ModelMap modelMap){ modelMap.addAttribute("testScope", "hello,ModelMap"); return "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7969744cef1d098b62476bff30929e35/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5bdfdd10499bef82e17930578cf04c2a/" rel="bookmark">
			linux namespace原理及在linux容器中的应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、namespace简介二、RTFSC1.namespace与进程2.创建ns流程3.设置ns流程4.对资源的操作 三、在lxc中的使用 一、namespace简介 在linux中具有父子关系的进程，通常情况下是共享大多数信息的，如网络信息，用户信息，文件句柄，信号处理等；namespace，作为linux容器技术的基础技术之一，可以实现多个进程之间的资源隔离，拥有独立地址空间的进程，会产生错觉，认为自己置身于一个独立的系统中，从而达到隔离的目的。单从使用效果来说也是比较好理解的，与namespace相关的系统调用有unshare和setns，至于在linux经典容器lxc中如何使用的，我们对照kernel(本文内核代码为linux-5.10.0)关于ns的实现，就变得很好理解了。
二、RTFSC 1.namespace与进程 既然namespace用于限制进程的资源访问，我们说task_struct用于描述进程，那二者之间肯定有些千丝万缕的关系。task_struct中使用nsproxy成员描述namespace信息，其类型为struct nsproxy，其主要成员如下：
struct nsproxy { atomic_t count; // 引用计数 struct uts_namespace *uts_ns; // 主机名与NIS域名 struct ipc_namespace *ipc_ns; // System V IPC和POSIX message queue struct mnt_namespace *mnt_ns; // 文件系统挂载点 struct pid_namespace *pid_ns_for_children; // 进程号 struct net *net_ns; // 网络设备、网络栈、端口号等 struct time_namespace *time_ns; // 系统单调时间及REAL_TIME struct cgroup_namespace *cgroup_ns; // cgroup资源 }; 2.创建ns流程 进程namespace的创建有两个途径，一是使用系统调用clone()创建子进程时通过clone_flags指定，二是通过系统调用unshare()指定，代码流程为
kernel_clone(kernel/fork.c) -&gt; copy_process -&gt; copy_namespaces(kernel/nsproxy.c) -&gt; create_new_namespaces ksys_unshare(kernel/fork.c) -&gt; unshare_nsproxy_namespaces(kernel/nsproxy.c) -&gt; create_new_namespaces static struct nsproxy *create_new_namespaces(unsigned long flags, struct task_struct *tsk, struct user_namespace *user_ns, struct fs_struct *new_fs) { struct nsproxy *new_nsp; .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5bdfdd10499bef82e17930578cf04c2a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/409d30712e2ab8b363a2b2031ca1f122/" rel="bookmark">
			PEP8规范总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		缩进 不要使用 tab 缩进使用任何编辑器写 Python，请把一个 tab 展开为 4 个空格绝对不要混用 tab 和空格，否则容易出现 IndentationError 空格 在 list, dict, tuple, set, 参数列表的 , 后面加一个空格在 dict 的 : 后面加一个空格在注释符号 # 后面加一个空格，但是 #!/usr/bin/python 的 # 后不能有空格操作符两端加一个空格，如 +, -, *, /, |, &amp;, =接上一条，在参数列表里的 = 两端不需要空格括号（(), {}, []）内的两端不需要空格 空行 function 和 class 顶上两个空行class 的 method 之间一个空行函数内逻辑无关的段落之间空一行，不要过度使用空行不要把多个语句写在一行，然后用 ; 隔开if/for/while 语句中，即使执行语句只有一句，也要另起一行 换行 每一行代码控制在 80 字符以内
使用 \ 或 () 控制换行，举例：
def foo(first, second, third, fourth, fifth, sixth, and_some_other_very_long_param): user = User.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/409d30712e2ab8b363a2b2031ca1f122/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e5562df605eca3344aeac84a418634e/" rel="bookmark">
			ubuntu中显示实时网速的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ubuntu中显示实时网速的方法：1、打开ubuntu系统终端；2、输入“sudo add-apt-repository ppa:fossfreedom/indicator-sysmonitor”命令添加源；3、输入“sudo apt-get update”更新源列表；4、输入“sudo apt-get install indicator-sysmonitor”安装sysmonitior工具；5、输入“indicator-sysmonitor &amp;”执行sysmonitior工具；6、最后通过【ctrl+c】实现后台运行indicator-sysmonitor工具显示实时网速即可。
具体内容如下：
1、添加源
sudo add-apt-repository ppa:fossfreedom/indicator-sysmonitor 2、更新源
sudo apt-get update 3、安装sysmonitior
sudo apt-get install indicator-sysmonitor 终端执行：
indicator-sysmonitor &amp; 然后Ctrl+C就可以实现后台运行indicator-sysmonitor，看下图标效果，效果很不错！
为了方便还要为程序添加开机启动！鼠标右键点击标题栏上图标，弹出菜单，选择首选项，出现如下界面：
勾上Run on startup:， 这样就能开机启动了。
切换到 Advanced 选项，可以对要显示的信息的格式进行设置。
添加 N:{net} 到最前面，以显示网速，点击Test可以查看修改后的格式。
可以尝试设置其他格式，再Test，直到效果满意再点击保存。
注：首次添加，修改后，关闭终端的话网速显示又会消失，重启一下就好了。
购买使用亿速云服务器，可以极大降低初创企业、中小企业以及个人开发者等用户群体的整体IT使用成本，无需亲自搭建基础设施、简化了运维和管理的日常工作量，使用户能够更专注于自身的业务发展和创新。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4307ea51bc5345cae07218e7c89e9156/" rel="bookmark">
			ORACLE：多表连接查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、表连接
二、笛卡尔积（交叉连接）
三、自然连接NATURAL JOIN
四、非等连接
五、外连接
左外连接 右外连接
全外连接
六、自连接
七、多表关联
注：数据来源oracle默认用户Scott中的表
#测试数据 select * from emp; EMPNO ENAME JOB	MGR HIREDATE	SAL COMM DEPTNO ---------- ---------- --------- ---------- --------- ---------- ---------- ---------- 7369 SMITH CLERK	7902 17-DEC-80	800 20 7499 ALLEN SALESMAN	7698 20-FEB-81	1600 300	30 7521 WARD SALESMAN	7698 22-FEB-81	1250 500	30 7566 JONES MANAGER	7839 02-APR-81	2975 20 7654 MARTIN SALESMAN	7698 28-SEP-81	1250 1400	30 7698 BLAKE MANAGER	7839 01-MAY-81	2850 30 7782 CLARK MANAGER	7839 09-JUN-81	2450 10 7788 SCOTT ANALYST	7566 19-APR-87	3000 20 7839 KING PRESIDENT 17-NOV-81	5000 10 7844 TURNER SALESMAN	7698 08-SEP-81	1500 0	30 7876 ADAMS CLERK	7788 23-MAY-87	1100 20 7900 JAMES CLERK	7698 03-DEC-81	950 30 7902 FORD ANALYST	7566 03-DEC-81	3000 20 7934 MILLER CLERK	7782 23-JAN-82	1300 10 14 rows selected.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4307ea51bc5345cae07218e7c89e9156/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc9db2017a16a8d108cf82d4086b30af/" rel="bookmark">
			c&#43;&#43;编译常见错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		webrtc\src\modules\rtp_rtcp\include\rtp_rtcp_defines.h(519): error C2059: 语法错误:“public”
error C2504未定义基类
rc: 都是汉字comments，引起的类的定义错误。根本不是网上说的什么类头文件引用重复。互相包含等等。就是汉字comments，引起的类没有编译成功
//记录 RTP 包的发送时间
class TransportFeedbackObserver {...}
不允许汉字做comments. 各种编译错误
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64a17cbd029f6397b01d83d99e199bbd/" rel="bookmark">
			ElasticSearch基本api操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ElasticSearch 本文章下列所用es本意都为Elaticsearch
ElasticSearch概述 Elaticsearch ,简称为es, es是一 个开源的高扩展的分布式全文检索引擎,它可以近乎实时的存储、检索数据;本身扩展性很好，
可以扩展到上百台服务器,处理PB级别(大数据时代)的数据。es也使用Java开发并使用Lucene作为其核心来实现所有索弓和搜
索的功能，但是它的目的是通过简单的RESTful API来隐藏Lucene的复杂性，从而让全文搜索变得简单。
据国际权威的数据库产品评测机构DB Engines的统计，在2016年1月, ElasticSearch已超过Solr等,成为排名第一-的搜索引擎类应
用。
安装ElasticSearch 官网地址
https://www.elastic.co/cn/downloads/elasticsearch
目录结构 bin 启动文件 config 配置文件 log4j2日 志配置文件 jvm. options java 虚拟机相关的配置 elasticsearch. ym1 elasticsearch的配置文件!默认 9200端口!跨域! 1ib 相关jar包 1ogs 日志! modules 功能模块 plugins插件! ik 进入bin文件夹启动elasticsearch.bat
访问http://localhost:9200
安装elasticsearch-head插件 1.安装 GitHub地址https://github.com/mobz/elasticsearch-head
2.启动 npm install npm run start 3.连接测试发现,存在跨域问题:配置es 在config文件夹的elasticsearch.yml文件中添加
http.cors.enabled: true http.cors.allow-origin: "*" 访问http://localhost:9100/
4.重启es再次连接 安装Kibana Kibana是一个针对Elasticsearch的开源分析及 可视化平台,用来搜索、查看交互存储在Elasticsearch索引中的数据。 使用Kibana ,
可以通过各种图表进行高级数据分析及展示。Kibana让海 量数据更容易理解。它操作简单,基于浏览器的用户界面可以快速创建仪
表板( dashboard )实时显示Elasticsearch查询动态。设置Kibana非常简单。无需编码或者额外的基础架构,几分钟内就可以完成
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/64a17cbd029f6397b01d83d99e199bbd/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/208/">«</a>
	<span class="pagination__item pagination__item--current">209/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/210/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>