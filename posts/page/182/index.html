<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/348629d25f603739b5c24cc9abe18d11/" rel="bookmark">
			用C&#43;&#43;编写出表白成功率最高的代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于表白成功与代码无关，表白成功的关键在于表达出你的真诚情感和与对方的互相理解。因此，不管代码如何，表白的成功与否完全取决于你和对方的关系。
但是，如果你想用代码来表白，可以考虑以下代码：
#include &lt;stdio.h&gt; int main() { printf("我喜欢你，你是我生命中最重要的人，我希望能和你一起度过余生。\n"); return 0; } 请注意，这仅仅是一段程序代码，它并不能代表你的真诚情感，因此不要指望它能帮助你获得表白成功。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4de21b35939ab82ff007c3034e77d7c/" rel="bookmark">
			【面试宝典】2023前端面试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、HTML1、简述一下对HTML语义化的理解？2、标签上 title 与 alt 属性的区别是什么？3、href 与 src？4、HTML新特性？5、Localstorage、SessionStorage、cookie区别6、HTML5 的离线储存的使用和原理？7、常见的浏览器内核8、你对web标准以及W3C的理解？9、行内元素和块级元素有哪些？img属于什么元素10、表单中readonly和disabled的区别？11、如何进行网站性能优化？12、如何写出高性能的 HTML？13、iframe 的优缺点？ 二、CSS1、css3新特性？2、什么是盒子模型3、CSS选择器以及优先级的理解？4、谈谈你对回流和重绘的理解？5、实现元素隐藏的方式6、css 预处理器7、垂直居中几种方式？8、简明说一下 CSS link 与 @import 的区别和用法？9、display:none和visibility:hidden的区别？10、rgba和opacity的透明效果有什么不同？11、行内元素与块级元素有什么区别？12、清除浮动的方式13、引入样式表CSS的方式有几种？分别是什么？优先级是什么？13、如何实现浏览器响应式布局？ 三、JS1、JS数据类型2、如何判断js的数据类型3、创建对象的几种方式4、js内置的常用对象有哪些？并列举该对象的常用方法5、===与 = =的区别6、怎么判断两个对象相等7、函数提升与变量提升的区别8、什么是闭包？9、箭头函数的特点10、简述this的含义11、js中new操作符主要干了什么？12、js中call、apply、bind作用和区别13、什么是作用域？全局作用域和局部作用域？14、什么是事件冒泡？怎么阻止事件冒泡？15、什么是事件委托？16、面向对象的特点？17、简述深浅拷贝以及深拷贝的方法18、防抖与节流19、ajax过程？20、请解释一下 JavaScript 的同源策略21、如何解决跨域？22、内存泄漏23、javascript的内存(垃圾)回收机制？23、什么是原型、原型链？24、get与post的区别25、let、var、const区别26、promise对象简述27、async、await 四、VUE1.vue的双向绑定原理2.MVVM、MVC3.vue的优点4.为什么vue组件中的data是一个函数***为什么使用return返回？ 5.VUE全家桶6.v-for中key的作用7.vue2的缺点8.什么是虚拟dom，为什么要使用虚拟dom9.v-for和v-if能否一起使用10.computed和watch的区别watch都有哪些属性 11.v-if和v-show的区别12.vue的生命周期13.vue的指令15.vue组件如何进行传值的？16.组件中写name会有什么作用？17.父子组件嵌套时生命周期哦钩子函数的执行顺序18、vuex19、谈谈你对keep-alive的理解20、vue-router路由模式有几种？21、能说下 vue-router 中常用的 hash 和 history 路由模式实现原理吗？22、谈一谈你对 nextTick 的理解？23、$nextTick的使用24、请说出 vue-cli 工程中每个文件夹和文件的用处?25、Vuex 页面刷新数据丢失怎么解决？26、Vuex 为什么要分模块并且加命名空间？27、vue 中使用了哪些设计模式？28、你都做过哪些 Vue 的性能优化？ 五、其他内容1、性能优化的几个方面?2、异步加载?3、加载方式4、预加载5、DNS预解析6、懒执行7、懒加载 一、HTML 1、简述一下对HTML语义化的理解？ 用正确的标签做正确的事情。
HTML语义化让页面的内容结构化，结构更清晰，便于浏览器、搜索引擎解析；即使在没有css样式的情况下，也以一种文档格式显示，并且是容易阅读的
搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，利于seo优化
使阅读源代码的人更容易将网站分块，便于阅读维护理解
2、标签上 title 与 alt 属性的区别是什么？ 通常当鼠标滑动到元素上的时候显示
alt 是img标签 的特有属性，是图片内容的等价描述，
用于图片无法加载显示、读屏器阅读图片。可提图片高可访问性，
除了纯装饰图片外都必须设置有意义的值，搜索引擎会重点分析。
3、href 与 src？ href (Hypertext Reference)指定网络资源的位置，从而在当前元素或者当前文档和由当前属性定义的需要的锚点或资源之间定义一个链接或者关系。（目的不是为了引用资源，而是为了建立联系，让当前标签能够链接到目标地址。）src source（缩写），指向外部资源的位置，指向的内容将会应用到文档中当前标签所在位置。href与src的区别:1、请求资源类型不同：href 指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的联系。在请求 src 资源时会将其指向的资源下载并应用到文档中，比如 JavaScript 脚本，img 图片；2、作用结果不同：href 用于在当前文档和引用资源之间确立联系；src 用于替换当前内容；3、浏览器解析方式不同：当浏览器解析到src ，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等也如此，类似于将所指向资源应用到当前内容。这也是为什么建议把 js 脚本放在底部而不是头部的原因。 4、HTML新特性？ 新增用于绘画的 canvas 和 svg 元素
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f4de21b35939ab82ff007c3034e77d7c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b05aaa68b446a6a488d609dcca87ec1/" rel="bookmark">
			linux服务器查看cpu和内存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、服务器CPU情况 1 查看物理CPU个数 cat /proc/cpuinfo | grep "physical id" | sort | uniq | wc -l 2 查看服务器CPU内核个数 cat /proc/cpuinfo | grep "cpu cores" | uniq 3 查看虚拟机查看核数 grep processor /proc/cpuinfo|wc -l 4 查看cpu内核频率 cat /proc/cpuinfo |grep MHz|uniq 5查看cpu型号 less /proc/cpuinfo |grep model 二、服务器内存情况 1 查看内存，不带单位 free -m 2 查看内存使用情况，带单位，显示查看结果 free -h 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69ebef20d577bba8c8f555497ca128e6/" rel="bookmark">
			Java基础：异常处理try-catch-finally以及throws
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Java的异常体系 概述：Error和Exception
在Java语言中，将程序执行中发生的不正常情况称为"异常"，但是并不是在开发过程中的语法错误和逻辑错误。异常主要分为两类Error和ExceptionError表示的是Java虚拟机无法解决的严重问题，JVM内部错误，例如：StackOverflowError和OOM，针对Error一般不编写代码进行处理，只能更改自己原先的代码才能解决Exception表示其他因编程错误或偶然的外在因素导致的一般性问题，例如：空指针异常、数组角标越界，针对Exception则可以编写对应的代码来处理
其中Exception又可以分为编译时异常和运行时异常，编译时异常是在编译的时候就会报错，如果不进行异常的处理，那么就无法编译运行，如果是运行时异常，那么是可以不进行处理的。
同时一般只是针对编译时异常进行处理，而运行是异常（类似于数组角标越界、空指针异常）是不会进行处理的，因为如果出现了这类的异常也只有修改代码才能避免报错
编译时异常 try { FileInputStream fileInputStream = new FileInputStream(file); } catch (FileNotFoundException e) { e.printStackTrace(); } 在创建FileInputString的时候如果没有针对FileNotFoundException 进行处理,那么就会报错，无法编译运行，故称为编译时异常
运行时异常 System.out.println(1/0); 以上的代码如果不进行异常的处理，那么在是可以通过编译的，但是运行的时候就会报错，故称为运行时异常
二、异常的处理方式 异常处理的两种方式：
通过使用try-catch-finally来解决通过使用throws + 异常类型来解决 异常处理过程： try-catch-finally
首先是在try中出现了异常，那么就会生成一个异常类对象，并停止代码的执行之后就会直接跳出try中，然后到达catch中进行异常类型的匹配，匹配之后执行内部的代码（只会执行其中一个）如果异常被catch捕获并处理之后，那么就会继续执行之后的代码finally是可选的，表示是一定会执行的在finally中一般是对资源的关闭操作，类似于file.close();操作 代码演示1： 执行结果为：start! —— / by zero —— end —— 程序结束！
try { System.out.println("start!"); System.out.println(1/0); System.out.println("middle!"); }catch (ArithmeticException e){ System.out.println("/ by zero"); }finally { System.out.println("end"); } System.out.println("程序结束！"); 解析： start! —— / by zero —— end —— 程序结束！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/69ebef20d577bba8c8f555497ca128e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab4b4bcf450a960006244781eb92d7cf/" rel="bookmark">
			windows搭建vscode跑lua代码环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先踩了不少坑,感谢原作者的无私分享.
下载安装Lua解释器并配置环境变量
https://sourceforge.net/projects/luabinaries/
下载的是lua-5.4.2_Win64_bin.zip版本,下载解压是下面这几个文件.
安装完成后，配置环境变量,在环境变量里设置path,我解压在d:\lua文件夹内,
在path最后边加上;d:\lua
在cmd里面输入 lua54 -v 如果显示如下信息则说明环境变量配置成功.
2、下载VSCode，打开VSCode，在Extension里面分别安装Lua Debug和Lua插件
3.安装Code Runner 插件
安装完以后设置一下.把run in terminal下面的对勾打上.
然后设置lua54的文件目录
在settings.json中设置 lua54的文件目录
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f13f266dc7ec4963ad0b20e72726c14c/" rel="bookmark">
			H3C交换机配置为NTP Server
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考华三官网：
https://www.h3c.com/cn/d_201708/1022816_30005_0.htm#_Toc490127398
不细述原理，直接配置，NTP Server端：
ntp-service enable	#开启NTP服务 clock protocol ntp clock timezone beijing add 8	#默认采用utc时区，北京时间为utc+8 ntp-service unicast-server 120.25.108.11 #配置ntp时间服务器 ntp-service unicast-server pool.ntp.org ntp-service unicast-server time.windows.com ntp-service unicast-server time.nist.gov display ntp-service status	#查看ntp状态 display ntp-service sessions	#查看ntp会话信息 NTP Client端：
H3C Client：
system-view clock timezone beijing add 8 clock protocol ntp ntp-service enable ntp-service unicast-server 172.16.1.3 //上面设置的NTP Server IP Cisco Client：
ntp source Vlan1 ntp server 172.16.1.3 中国区授时中心：
使用以前请先ping相应的域名查看网络是否可达，和相应的访问速度
ntp.ntsc.ac.cn 中国国家授时中心
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f13f266dc7ec4963ad0b20e72726c14c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c4a4291917272e0323996081fd72804/" rel="bookmark">
			实践笔记分享：高并发项目Java8多线程几种场景实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微信公众号：[Java技术干货]
关注Java技术、关注前端后端全栈技术。问题或建议，请公众号留言。
最近在弄一个高并发项目，经过接口压测后，各项指标不禁人意，也一直在搞程序调优（Nginx、Redis、数据库）。
真的是被虐得是体无完肤，发丝也日渐脆弱。
哎………….还在锤炼中………
在调优的过程中，我把在程序中遇到多线程优化的几个场景案例记录分享一下，以供学习和交流。
场景一：数据拆分多个subList, 分批多线程导入 // map拆分成多个subList List&lt;Map&lt;String, List&lt;UserParam&gt;&gt;&gt; userParams= MapUtil.mapChunk(userParam, BATCH_COUNT); AtomicReference&lt;CompletableFuture&lt;Void&gt;&gt; all = new AtomicReference&lt;&gt;(); userParams.stream().forEach(userListMap -&gt; { // 每一个subList 创建一个线程处理，以下是无参返回 CompletableFuture&lt;Void&gt; cf = CompletableFuture.runAsync(() -&gt; { try { // 此处要注意父级线程往子线程的参数传递，不然在子线程中会存在取不到值的情况 List&lt;UserParam&gt; threadTemp = new ArrayList&lt;&gt;(); userListMap.entrySet().stream().forEach(s -&gt; { threadTemp.addAll(s.getValue()); }); // 保存业务数据 saveData(threadTemp); } finally { } }); all.set(CompletableFuture.allOf(cf)); }); all.get().join(); 场景二：数据列表查询(一个方法多线程处理业务) 拆分多线程处理 List&lt;CompletableFuture&gt; comList = new ArrayList&lt;&gt;(); // 该计数器，是为了等待所有线程都执行完了，在往后执行 CountDownLatch countDownLatch = new CountDownLatch(1); // 1 代表会初始化1个计数，这个是跟随创建线程数量保持一致 CompletableFuture&lt;Void&gt; cf = CompletableFuture.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c4a4291917272e0323996081fd72804/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c208b5d0500c869c3a29bc0b7ee9afa2/" rel="bookmark">
			FlinkCDC作业处理慢追不上binlog产生的速度，导致binlog被清理的解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		完整的异常信息如下：
java.lang.RuntimeException: One or more fetchers have encountered exception at org.apache.flink.connector.base.source.reader.fetcher.SplitFetcherManager.checkErrors(SplitFetcherManager.java:225) at org.apache.flink.connector.base.source.reader.SourceReaderBase.getNextFetch(SourceReaderBase.java:185) at org.apache.flink.connector.base.source.reader.SourceReaderBase.pollNext(SourceReaderBase.java:143) at org.apache.flink.streaming.api.operators.SourceOperator.emitNext(SourceOperator.java:385) at org.apache.flink.streaming.runtime.io.StreamTaskSourceInput.emitNext(StreamTaskSourceInput.java:68) at org.apache.flink.streaming.runtime.io.StreamOneInputProcessor.processInput(StreamOneInputProcessor.java:65) at org.apache.flink.streaming.runtime.tasks.StreamTask.processInput(StreamTask.java:526) at org.apache.flink.streaming.runtime.tasks.mailbox.MailboxProcessor.runMailboxLoop(MailboxProcessor.java:203) at org.apache.flink.streaming.runtime.tasks.StreamTask.runMailboxLoop(StreamTask.java:811) at org.apache.flink.streaming.runtime.tasks.StreamTask.invoke(StreamTask.java:760) at org.apache.flink.runtime.taskmanager.Task.runWithSystemExitMonitoring(Task.java:954) at org.apache.flink.runtime.taskmanager.Task.restoreAndInvoke(Task.java:933) at org.apache.flink.runtime.taskmanager.Task.doRun(Task.java:746) at org.apache.flink.runtime.taskmanager.Task.run(Task.java:568) at java.lang.Thread.run(Thread.java:834) Caused by: java.lang.RuntimeException: SplitFetcher thread 0 received unexpected exception while polling the records at org.apache.flink.connector.base.source.reader.fetcher.SplitFetcher.runOnce(SplitFetcher.java:150) at org.apache.flink.connector.base.source.reader.fetcher.SplitFetcher.run(SplitFetcher.java:105) at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511) at java.util.concurrent.FutureTask.run(FutureTask.java:266) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1147) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:622) ... 1 more Caused by: java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c208b5d0500c869c3a29bc0b7ee9afa2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b3fa10edd74260211045a2beb174284/" rel="bookmark">
			用批处理命令批量ping一个网段的IP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		假如我们要ping 10.1.1.1--254的网段，结果到ip.txt文件中，那么：
for /l %d in (1,1,254) do ping 10.1.1.%d -n 1 &gt;&gt;ip.txt 其中：FOR %variable IN (set) DO command [command-parameters]是语法，注：in和do之间的set表示的字符串或变量可以是一个，也可以是多个，每一个字符串或变量，我们称之为一个元素，每个元素之间，用空格键、跳格键、逗号、分号或等号分隔。
/l是带开关的的for语法，代码中的（1，1，254），第1个1是从1开始，第2个1是跳数为1，每次累加1，第3个254是到254为止不再进行动作。
再如：累加一个从1到10的数字并打印出来：
for /l %i in (1,1,10) do set /a a=a+%i * 如果是在bat文件中，%%variable要双写%
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7bfad458b2dd0fe691e67d59b9d1474/" rel="bookmark">
			PTA C语言 基础代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		7-125 求出两个正整数之间能被3整除但不能被5整除的所有奇数 编程求出任意两个正整数（闭区间，即包括两个正整数）之间能被3整除但不能被5整除的所有奇数。
输入格式: 输入两个正整数（用空格分隔）赋给变量m和n。
输出格式: 输出m和n之间能被3整除但不能被5整除的所有奇数。
要求：每行输出8个数，数据之间用英文逗号,分隔。
输入样例: 1 200 输出样例: 3,9,21,27,33,39,51,57 63,69,81,87,93,99,111,117 123,129,141,147,153,159,171,177 183,189, 代码如下：
#include&lt;stdio.h&gt; int main() { int m,n,count=1; scanf("%d %d",&amp;m,&amp;n); for(int i=m;i&lt;=n;i++) { if(i%3==0 &amp;&amp; i%5!=0 &amp;&amp; i%2!=0 &amp;&amp; count%8!=0) { printf("%d,",i); count ++; } else if(i%3==0 &amp;&amp; i%5!=0 &amp;&amp; i%2!=0) { printf("%d\n",i); count ++; } } return 0; } 7-127 求阶乘累加和 求解阶乘累加和。计算1到n之间（包括1和n）每个整数的阶乘的累加和。即计算 sum=1!+2!+⋯+n!
输入格式: 输入一个整数 n(1≤n≤12)。
输出格式: 1 的阶乘到 n 的阶乘的累加和。
输入样例: 在这里给出一组输入。例如：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c7bfad458b2dd0fe691e67d59b9d1474/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85e6dae42bddc847eee0ac3725096716/" rel="bookmark">
			uniapp 文字上下滚动，抽奖效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.vue展示页面内容
&lt;template&gt; &lt;view&gt; &lt;view class="main"&gt; &lt;view class="subject"&gt;抽奖结果&lt;/view&gt; &lt;view class="body"&gt; &lt;maoScroll :data="data" :showNum="showNum" :lineHeight="lineHeight" :animationScroll="animationScroll" :animation="animation"&gt; &lt;template v-slot="{line}"&gt; &lt;view class="line"&gt;{{line.author}} 获得 {{line.subject}}&lt;/view&gt; &lt;/template&gt; &lt;/maoScroll&gt; &lt;/view&gt; &lt;/view&gt; &lt;view class="main"&gt; &lt;view class="subject"&gt;滑动配置&lt;/view&gt; &lt;view class="body"&gt; &lt;view&gt;&lt;text&gt;数据总数：&lt;/text&gt;&lt;text&gt;{{count}}条（模拟）&lt;/text&gt;&lt;/view&gt; &lt;view&gt;&lt;text&gt;显示条数：&lt;/text&gt;&lt;text&gt;{{showNum}}条&lt;/text&gt;&lt;/view&gt; &lt;view&gt;&lt;text&gt;每行高度：&lt;/text&gt;&lt;text&gt;{{lineHeight}}rpx&lt;/text&gt;&lt;/view&gt; &lt;view&gt;&lt;text&gt;滑动时间：&lt;/text&gt;&lt;text&gt;{{animationScroll}}毫秒&lt;/text&gt;&lt;/view&gt; &lt;view&gt;&lt;text&gt;滑动间隔：&lt;/text&gt;&lt;text&gt;{{animation}}毫秒&lt;/text&gt;&lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;/template&gt; &lt;script&gt; import maoScroll from '@/components/mao-scroll/mao-scroll.vue'; export default { components:{ maoScroll }, data() { return { title: 'Hello', data: [], count: 30, showNum: 5, lineHeight: 60, animationScroll: 800, animation: 800, } }, onLoad() { console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/85e6dae42bddc847eee0ac3725096716/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3aecc0668391a8ccd131364d03304158/" rel="bookmark">
			响应式圣经：10W字，实现Spring响应式编程自由
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 全链路异步化改造的基础是响应式编程 随着业务的发展，微服务应用的流量越来越大，使用到的资源也越来越多。
在微服务架构下，大量的应用都是 SpringCloud 分布式架构，这种架构总体上是全链路同步模式。
全链路同步模式不仅造成了资源的极大浪费，并且在流量发生激增波动的时候，受制于系统资源而无法快速的扩容。
全球后疫情时代，降本增效是大背景。如何降本增效？
可以通过技术升级，全链路同步模式 ，升级为 全链路异步模式。
先回顾一下全链路同步模式架构图
全链路同步模式 ，如何升级为 全链路异步模式， 就是一个一个 环节的异步化。
40岁老架构师尼恩，持续深化自己的3高架构知识宇宙，当然首先要去完成一次牛逼的全链路异步模式 微服务实操，下面是尼恩的实操过程、效果、压测数据(性能足足提升10倍多)。
全链路异步模式改造 具体的内容，请参考尼恩的深度文章：全链路异步，让你的 SpringCloud 性能优化10倍+
并且，上面的文章，作为尼恩 全链路异步的架构知识，收录在《尼恩Java面试宝典》V46版的架构专题中
全链路异步化改造，性能提升十倍是大好事，那么，全链路同步模式改造的问题是什么呢？
全链路异步化改造的技术基础，是响应式编程，关键问题在于： 响应式编程的知识太难。
古语说： 蜀道难难于上青天。
很多小伙伴认为： 响应式编程， 比蜀道还难？
所以，40岁老架构师 使用20年的编程功力，给大家呈上一篇， 学习响应式编程 的超级长文，也是一篇超级、超级详细，超级超级全面，并且不断迭代的文章：
《响应式圣经：10W字实现响应式编程自由》
此文，目前为V2版本，新版本是基于V1老版本是尼恩之前写的一篇深受好评的博客文章
Flux、Mono、Reactor 实战（史上最全）
后续，尼恩会一直不断迭代， 为大家拉涅出一本史上最棒的 《响应式圣经》 ，帮助大家实现响应式编程自由。
从此： 蜀道，不再难。
注：本文以 PDF 持续更新，最新尼恩 架构笔记、面试题 的PDF文件，请从这里获取：码云
Reactive programming 响应式编程概述 背景知识 为了应对高并发服务器端开发场景，在2009 年，微软提出了一个更优雅地实现异步编程的方式——Reactive Programming，我们称之为响应式编程。
随后，Netflix 和LightBend 公司提供了RxJava 和Akka Stream 等技术，使得Java 平台也有了能够实现响应式编程的框架。
在2017 年9 月28 日，Spring 5 正式发布。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3aecc0668391a8ccd131364d03304158/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52927d5546189c1446363cc7b0f76905/" rel="bookmark">
			【设计模式】九、面向对象设计原则之迪米特法则
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章|源码 https://github.com/tyronczt/design-mode-learn
定义-是什么 迪米特法则（Law of Demeter，LoD）又叫作最少知识原则（Least Knowledge Principle，LKP)，产生于 1987 年美国东北大学（Northeastern University）的一个名为迪米特（Demeter）的研究项目，由伊恩·荷兰（Ian Holland）提出，被 UML 创始者之一的布奇（Booch）普及，后来又因为在经典著作《程序员修炼之道》（The Pragmatic Programmer）提及而广为人知。
迪米特法则（Law of Demeter）又叫作最少知识原则（The Least Knowledge Principle），一个类对于其他类知道的越少越好，就是说一个对象应当对其他对象有尽可能少的了解，只和朋友通信，不和陌生人说话。英文简写为：LOD。
这意味着一个对象只应该与直接的朋友通信，而不应该与陌生人通信。在编程中，一个对象只应该引用其直接关联的对象，而不应该引用其他对象的内部状态。
核心：最少依赖，尽量降低类与类之间的耦合。
只与直接的朋友通信
朋友：有耦合（依赖、关联、组合、聚合）关系的对象；直接朋友：成员变量，方法参数，方法返回值中的类； 思考-为什么 迪米特法则的好处是减少了对象之间的耦合，提高了系统的可维护性和可扩展性。如果遵循迪米特法则，当修改一个对象时，不会对其他对象产生影响，因此系统更加稳定。
优点 降低类之间的耦合度，提高模块的相对独立性。由于亲和度降低，从而提高了类的可复用率和系统的扩展性。 缺点 过度使用迪米特法则会使系统产生大量的中介类，从而增加系统的复杂性，使模块之间的通信效率降低。所以，在釆用迪米特法则时需要反复权衡，确保高内聚和低耦合的同时，保证系统的结构清晰。
注意事项 在类的划分上，应当创建弱耦合的类，类与类之间的耦合越弱，就越有利于实现可复用的目标。在类的结构设计上，每个类都应该降低成员的访问权限。在类的设计上，只要有可能，一个类应当设计成不变的类。在对其他类的引用上，一个对象对其他类的对象的引用应该降到最低。尽量限制局部变量的有效范围，降低类的访问权限。 应用-怎么用 设计模式的门面模式（Facade）和中介模式（Mediator），都是迪米特法则的应用。
案例1：只和直接的朋友交流 — 班长点名 需求：老师叫班长点名；
代码仓库：https://github.com/tyronczt/design-mode-learn/tree/main/design-mode-learn-6-01
public class Student { } // 班长 public interface IGroupLeader { // 清点人数 void count(List&lt;Student&gt; students); } public class GroupLeaderImpl implements IGroupLeader { @Override public void count(List&lt;Student&gt; students) { if (null !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/52927d5546189c1446363cc7b0f76905/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81c08367100c7a6f86d515febfa6cb9c/" rel="bookmark">
			依存句法分析 -- tag和dep释义
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		依存句法分析（Dependency Parsing, DP）是通过分析语言单位内成分之间的依存关系揭示其句法结构，主张橘子 中核心动词是支配其它成分的中心成分，而它本身却不受其他任何成分的支配，所有受支配成分都以某种关系从属于支配者。依存句法的结构没有非终结点，词与词之间直接发生依存关系，构成一个依存对，其中一个是核心词，也叫支配词，另一个叫修饰词，也叫从属词。依存关系用一个邮箱弧表示，叫做依存弧。
依存句法分析的五个条件：
（1）一个句子中只有一个成分是独立的
（2）句子的其他成分都从属与某一成分
（3）任何一个成分都不能依存于两个或两个以上的成分
（4）如果成分A直接从属成分B，而成分C在句子中位于A和B之间，那么成分C或者从属于A，或者从属于B，或者从属于A和B之间的某一成分
（5）中心成分左右两边的其他成分相互不发生关系
标注词表(tag) 名词： NN, NNS, NNP, NNPS
代词： PRP, PRPS
形容词： JJ, JJR, JJS
数词： CD
动词： VB, VBD, VBG, VBN,VBP, VBZ
副词： RB, RBR, RBS
1. CC Coordinating conjunction 连接词
2. CD Cardinal number 基数词
3. DT Determiner 限定词（如this,that,these,those,such，不定限定词：no,some,any,each,every,enough,either,neither,all,both,half,several,many,much,(a)
few,(a) little,other,another.
4. EX Existential there 存在句
5. FW Foreign word 外来词
6. IN Preposition or subordinating conjunction 介词或从属连词
7. JJ Adjective 形容词或序数词
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/81c08367100c7a6f86d515febfa6cb9c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9b91e447bf0b49aa05c5ef3cd63f833/" rel="bookmark">
			单行文本域，多行文本域隐藏问题，uniapp解决在循环中调接口数据顺序混口问题，Cannot read property ‘bottom‘ of null的解决方法，for循环ref后利用ref变量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		多行文本域隐藏问题 overflow: hidden; 首先是溢出隐藏，不可或缺
display: -webkit-box; 以弹性盒模型显示
-webkit-box-orient: vertical; 盒模型元素的排列方式
-webkit-line-clamp: 3; 显示行数
&lt;style&gt; .postnameStyle{ font-size: 30rpx; font-weight: 600; display: -webkit-box; -webkit-box-orient: vertical; -webkit-line-clamp: 2; overflow: hidden; } &lt;/style&gt; 这样就成功隐藏了溢出文本
单行文本域隐藏问题 overflow: hidden;溢出隐藏
white-space: nowrap;文字不能转行
text-overflow:ellipsis;隐藏的部分用…表示
单行文本域的隐藏就比较简单
&lt;style&gt; .postnameStyle{ font-size: 30rpx; font-weight: 600; text-overflow:ellipsis; white-space: nowrap; overflow: hidden; } &lt;/style&gt; 这样成功隐藏啦
uniapp解决在循环中调接口数据顺序混口问题 今天在做uni-app的调接口时，遇到这样的情况，在forEach循环里，调用一个异步请求时，返回来的值顺序是乱的
因此，在以下的代码里，push到数组里的值，每次的顺序可能都是不一样的
而造成这样一个原因，是forEach循环是单线程的，异步请求是多线程的，往往在forEach循环结束了，异步请求还没有结束
async getAllPostDetailsInfo(articleId: number) { await getPostComment(articleId, this.page, 10).then((res:any) =&gt; { res.list.forEach (async (i: any) =&gt; { // 这里就会往往在循环结束了，异步请求还没有结束，造成数据混乱 await getPostCommentReply(i.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c9b91e447bf0b49aa05c5ef3cd63f833/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6cce37981f2f6ca34ac2835c3f7db975/" rel="bookmark">
			本地项目如何上传到gitlab（新创建的分支）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 首先本地得安装git，然后切换到需要上传的项目所在路径下，点击鼠标右键
在弹出的框中选择Git Bash Here，这时候会弹出一个命令框，输入命令 git init，这时候 项目所在目录下创建了一个.git文件夹。
2 创建新分支 ahyzs-evaluation，并查看现在分支，带有*是当前分支，命令：git checkout -b ahyzs-evaluation
3 git add . -- 提交文件到暂存区并注释；git commit -a -m "第一次提交" -- 提交到本地仓库；git remote add origin http://192.168.1.88/liujun/ah-yzsxm.git -- 将本地仓库和远程仓库关联；$ git push -u origin ahyzs-evaluation -- 开始推送本地ahyzs-evaluation至仓库
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89dfe4cf442344e90fc53687e7476199/" rel="bookmark">
			k8s怎么查看节点label
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在 Kubernetes 集群中，可以使用 kubectl get nodes 命令来查看节点的 label 信息。该命令的输出包含了节点的名称、状态以及 label 信息。例如：
$ kubectlget nodes -l env=prod NAME STATUS ROLES AGE VERSION node1.example Ready &lt;none&gt; 1h v1.19.0 node2.example Ready &lt;none&gt; 1h v1.19.0 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4cd5ef87c47e9382552c1b848abeba7d/" rel="bookmark">
			OpenPilot分析 | 从图像到油门/刹车
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者 | 海斌 编辑 | 汽车人
原文链接：https://zhuanlan.zhihu.com/p/598090094
点击下方卡片，关注“自动驾驶之心”公众号
ADAS巨卷干货，即可获取
点击进入→自动驾驶之心【全栈算法】】技术交流群
“ 编者按：openpilot是一个开源的驾驶员辅助系统。目前，openpilot为越来越多的受支持的汽车品牌、车型执行自适应巡航控制（ACC）、自动车道居中（ALC）、前向碰撞预警（FCW）和车道偏离预警（LDW）功能。此外，当openpilot启动时，基于摄像头的驾驶员监控（DM）功能会提醒分心和睡着的驾驶员。
” openpilot0.9.0版本的重大更新是引入了端到端纵向规划，其通过模仿学习的思路，主要依赖模型的轨迹规划结果来实现多种复杂场景的纵向控制，如弯道减速、红灯减速停车、绿灯起步、前车的跟随。
本节尝试从openpilot纵向控制的整个链条：图像采集、模型、雷达、规划、控制等环节，依次分析这个过程的主要步骤。首先是宏观的流程图：
openpilot中，纵向控制相关数据/模块链条 摄像头 comma 3设备上的2颗前视摄像头，FOV不同，1颗后视摄像头 前后的两颗超广角摄像头型号是一样的，FOV都为185度，可以形成360度环视。
同一时刻，2颗前视摄像头拍摄的画面 后视超广角摄像头拍摄的画面，以及对他的语义分割标注 camerad会以20 FPS的频率从前视摄像头不断采集图像，再使用opencl把RGB转化成YUV420格式，再通过VisionIPC的共享内存机制把图像送到模型推理模块http://modeld.cc。
YUV420，颜色分量CbCr的密度只有亮度分量的Y密度的1/4 两颗前视摄像头，它们的FOV不同，从不同尺度给supercombo模型提供内容来预测后续的轨迹规划和车身姿态等信息。
一颗后视超广角摄像头，目前只用来监控司机的注意力是否可以随时接管车辆控制，但通过comma.ai众包的标注数据来看，未来可能会使用其拍摄的车窗外侧的内容辅助轨迹规划，如增加了并线时对侧后方车辆的判断。
模型 modeld进程在读取到VisionIPC发来的新图像后，会使用相机的外参、内参等信息对图像进行矫正，还会进行归一化等数据处理，这个预处理流程核心部分采用opencl来加速。接下来，预处理后的结果 和 等数据被送入supercombo模型推理，产生的推理结果中与后续的纵向控制流程相关的部分是：
轨迹规划的结果plans，其中每条轨迹含有未来一段时间33个轨迹点的位置、速度、加速度、横摆角、横摆角变化率等信息。
前车信息leads，前方若干车辆的相对速度、相对距离等信息。（后续会与雷达数据进行融合）
车辆姿态temporal_pose，其中包含对自车的速度和欧拉角旋转速度的估计值，作用和视觉里程计类似。
雷达 openpilot在纵向控制流程中，需要用到车载ACC雷达的感知信息，虽然其将来的目标是完全使用视觉信息进行端到端的规划，但目前阶段还是将原车自带的ACC雷达信息与基于视觉判断的前车信息进行了融合后再进行纵向控制。
openpilot适配的每种品牌车辆，在selfdrive/car/XXX/radar_interface.py文件中实现了车载ACC雷达数据的获取函数。如下图展示了“现代”汽车的实现，把CAN消息如，雷达的方位角(azimuth)、相对距离、相对速度、加速度原始信息，处理成符合radard后续要求的方式。方位角不再被需要，而是转换成了横向偏移yRel，距离也转换成了纵向距离dRel。（大部分车的ACC雷达不提供前车的加速度信息aRel，需要后续采用卡尔曼滤波来估计前车的加速度）
解析ACC雷达的CAN信息，转换成radard后续处理所需要的数据格式 radard中采用卡尔曼滤波来处理雷达返回的数据，这样第一个好处是比只使用测量值，可以进一步降低噪声；另一个好处是，很多雷达无法直接观测前车的加速度，用卡尔曼滤波后就可以通过系统的状态方程结合历史数据更好的估计出当前时刻的前车加速度。
这里的系统的的状态量是[v, a]，观测量是[v]。这里的系统动态是线性的，所以不需要使用rednose里的EKF，而是使用了一个简化的卡尔曼滤波，下图是此处的卡尔曼滤波相关参数设定代码，其中状态转移矩阵为A（其中包含dt），测量方程的测量矩阵为C（部分文档中用H），过程噪声协方差Q是[[10,0],[0, 100]]，测量噪声的协方差R是[[1e3, 0 ],[0, 1e3]]，估计误差协方差P为[[1,0],[0,1]]，不过代码中的Q和R是用注释方式展示的（P甚至没有注释的提示，但做实验可得约是1），实际并没有定义，而是提前计算了不同dt的情况，形成了K0/K1表示的卡尔曼增益。
raderd代码中卡尔曼滤波参数 从卡尔曼滤波中的5个公式中可以看出， K,P 两个参数虽然也随步骤k不断迭代改变，但却与状态 X 的取值和观测 Z 的取值无关，卡尔曼增益 随着不断迭代必然需要收敛到稳定值。所以radard这里的卡尔曼增益参数K0/K1，代表dt从0.01s到0.2s时的20种不同的dt情况下，收敛后的卡尔曼增益（列向量）的第一行与第二行，后续用插值方式根据实际调用时雷达处理频率求得的dt得到更匹配的K。例如，有的雷达采样频率是15HZ，则需要用dt=1/15s 来求插值后的K。
radar进程会将滤波后的雷达数据先进行聚类，然后再与模型返回的基于视觉感知的前车数据，进行融合，构造此模块的返回值。关键函数的注释分析如下图：
radard进程中，通过get_lead函数，融合两种模态得到的前车数据 虽然supercombo模型给出了3个不同时刻(0s, 2s, 4s)的前车信息预测，单radard中目前只使用了前两者leads_v3[0]和leads_v3[1]。最终构造的发给其他模块的消息radarState中，关键数据是leadOne和leadTwo，其中leadOne要考虑低速蠕行时，视觉感知不准，需要用雷达感知数据覆盖。细节如下图：
radard进程将构造要pub出去的radarState消息 从代码流程中可以看到，理论上可以不依赖ACC雷达，只依赖视觉感知预测出的前车数据，但目前代码细节还是体现出雷达的可靠度/优先级比视觉要更高。不过代码中也体现了使用视觉感知结果来“拒绝”雷达感知结果的优先级也非常高，get_lead函数中，若lead_msg&lt;0.5，则会拒绝所有雷达的数据，产生“无前车”的最终输出。
规划 selfdrive/controls/lib/longitudinal_planner.py 中的LongitudinalPlanner类，负责将supercombo推理输出的规划，结合融合后的雷达信息，用MPC进行再次优化，使速度或加速度控制更加合理和舒适。
每当模型推理部分给出新的轨迹规划输出后(周期0.05s)，LongitudinalPlanner的update和publish函数会依次被调用，其详细实现如下：
其中的parse_model函数，一方面将模型输出转换成了MPC需要的步骤数，另一方面修改了轨迹里的速度，防止横向加速度过大影响舒适和安全。该速度修正是taco2分支相比与master分支中新增的内容。
前面展示的主要是纵向规划器输入输出的部分，其优化工作的核心是使用了MPC来完成，其详细内容如下：
继续
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4cd5ef87c47e9382552c1b848abeba7d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b921e61b7fbcf3d8bbc63c52a2784ccc/" rel="bookmark">
			Vue 3-Error [ERR_UNSUPPORTED_ESM_URL_SCHEME]: Only file and data URLs are supported
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题
Error [ERR_UNSUPPORTED_ESM_URL_SCHEME]: Only file and data URLs are supported by the default ESM loader
方案
nodejs版本太低，升级node版本至v16以上！
升级nodejs方法
查看当前node版本
$ node -v
清除npm缓存
$ npm cache clean -f
全局安装n
$ npm install -g n
升级到最新稳定版
$ n stable
升级到最新版
$ n latest
升级到定制版
$ n v14.6.0
切换使用版本
$ n 13.10.0 (ENTER)
删除制定版本
$ n rm 13.10.0
用制定的版本执行脚本
$ n use 13.10.0 some.js
升级完成查看 node版本
$ node -v
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d6812f6641501210da363b9d71e493b/" rel="bookmark">
			5.3.1_原补码的乘法运算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、原码乘法运算（1）手算乘法1.十进制乘法2.二进制乘法3.一些问题 （2）机器实现1.案例2.确定符号位3.绝对值相乘的机器实现4.补充说明 （3）手算模拟原码一位乘法 二、补码乘法运算（1）原码与补码（2）补码乘法运算的硬件构成（3）手算模拟 三、回顾 一、原码乘法运算 经过之前小节的学习，我们已经知道了定点数的加法、减法，还有移位运算如何实现。
这小节中我们要学习定点数的原码乘法如何实现。
这一小节中，我们会首先探讨乘法运算的实现思想，介绍原码的移位乘法如何实现。最后还会介绍补码的一位乘法如何实现。
（1）手算乘法 1.十进制乘法 首先来看一下大家比较熟悉的十进制的乘法。
回忆一下小学时候如何做一个乘法运算的。比如 0. 985 乘以 0. 211，如果算上小数点之前的0，这两个数都是4位，都有 4 个数码位。
首先是 1 乘以985，把它写在下面。
接下来还有一个 1 乘以985，但是这一次的 985 要和上一个 985 进行一个错位，相对于上一个 985 来说，要往前移一位。
最后2乘以 985 应该是等于1970，同样的， 1970 的最后一位又要比上一个 985 再往前挪了一位。
每一个数码位进行乘法运算得到的结果，我们是把它们错位地排列在一起的。最后我们会把它进行一个相加，得到这样的结果。
最后小学老师会告诉我们如何处理小数点。小时候老师教我们的做法是从最后位置往前数 6 位就到了 2 的前边，所以小数点最终确定在 2 的前面。如下：
这就是 0. 985 乘以 0. 211 的一个手算方式。
这是我们小学时候学过的东西，现在的问题是这样的，不知道大家有没有思考过，为什么我们在写这些每一位乘得的结果的时候，都要错位得把它们写在一起。
其实这个原因可以结合我们之前介绍过的 r 进制的数值的定义来进行理解。
0.211 这个数我们可以把它看作是 2 乘以 10 的-1 次方，加上 1 乘以 10 的-2次方，再加上 1 乘以 10 的-3次方。 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d6812f6641501210da363b9d71e493b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63388a92d7657d591b8e7a48a2bf3f7c/" rel="bookmark">
			GAMES101作业7及课程总结（重点实现多线程加速，微表面模型材质）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 闲言碎语最终全部效果展示（均为1024×1024×512ssp）课程总结与理解（Path Tracing）框架梳理任务一：迁移相关代码任务二：实现path tracing任务三：多线程加速（包括其他加速的小trick）1.随机数构造器优化2.多线程加速3.debug改成release版本 任务四：微表面模型1. 微表面材质定义2. 微表面分布的表达2.1. D(h)：法线分布函数（**Normal Distribution Fuction，NDF**）2.1. G(i,o,h)：几何遮挡函数（**Shadowing and Making term**） 3.光在每个微表面散射的BRDF4.Torrance-Sparrow Model5.代码实现 任务五：完美反射模型（看到顺便实现了，作业没要求）代码实现可能遇到的问题1.光源融入到整个天花板，没有出现黑色2.箱子背阴处有很多黑色噪点3.有白色噪点（ssp调高仍然有） 理论思考1.偏移为什么要分两种情况这么偏移？2.为什么path tracing有软阴影？3.把witted style和path tracing的结果对比一下，两者的实现的不同点有哪些？4.为什么程序中，渲染方程的入射radiance是光源的emit，是一个常量？5.为什么说光栅化比光追快？ 个人感悟参考资料 闲言碎语 前言：从这篇文章开始，转知乎了，感觉知乎的社区氛围更好，emmm，哈哈哈主要还是想接触一下知乎的图形学大佬们。知乎账号链接：https://www.zhihu.com/people/xuu-27-24
emmm，距离完成作业6已经过去了一个月多的时间（我承认中间有段时间在摆烂==），怎么说呢，感觉作业7真的知识体系非常庞大，虽然实现的代码量不多，但是里面真的很多细节很多trick，对我这种小菜鸡感觉还是有挺大难度的。。。再加上感觉自己挺钻牛角尖的，所以搞了挺久的，也最终算是完成了作业7的全部要求，害，希望后面本科毕设不要太赶吧。
提个建议：如果遇到实在解决不了的问题，可以上games论坛看看，里面有很多共性的问题，上面的问题我几乎都遇到了。。。
最终全部效果展示（均为1024×1024×512ssp） 基础path tracing实现（作业基本要求）
微表面材质
完美镜面反射材质
课程总结与理解（Path Tracing） 课程方面，主要是先讲辐射度量学，然后推导出渲染方程，之后介绍用来求解积分的蒙特卡洛方法，最后讲如何在程序中求解渲染方程计算颜色（包括很多的trick细节，比如对光源进行直接采样提高采样效率，俄罗斯轮盘赌解决无限递归等等），从而实现path tracing。
path tracing流程：整体的渲染流程实际上更多的是在Whitted-Style上的改进，前期添加物体，构建包围盒，这些都是一样的。不一样的地方在于path tracing在最终着色的时候本质上是求解一个渲染方程，需要做大量的采样，近似积分结果，里面小trick非常多。而Whitted-Style并没有做采样求积分，就是简单的光线反射和折射，无法像path tracing一样考虑全局光照。 总体上来说，就是每个像素点发出多条光线，每条光线会通过之前构建的包围盒找到与场景中物体的第一个交点，然后根据渲染方程计算该交点的颜色，并返回，最后将全部发射的光线的颜色求平均，就得到该像素的颜色。
其实这个渲染方程本身的原理还是挺复杂的，可以研究的很深入，尤其辐射度量学那块，课程本身其实讲的并不是很细，如果想细致了解的话可以去翻虎书，虎书可以说对辐射度量学进行了深度的解刨，直接从光子开始讲。。。
框架梳理 和作业6使用的框架其实差不多，可以参考我之前写的https://blog.csdn.net/Xuuuuuuuuuuu/article/details/128556319
作业7的框架实际上主要就是castRay函数有所不同，因为path tracing的最终实现是在castRay中实现。
任务一：迁移相关代码 之前写的在这里：https://blog.csdn.net/Xuuuuuuuuuuu/article/details/128556319，把相关的代码贴进去就行。其中要注意的一个点，IntersectP中的等于号一定要去掉，要不然之后会出现部分物体不可见的情况，去掉的位置在这里，见下图：
为什么这里要去掉等于号，之前闫老师说，图形学编程中很少考虑等于号的情况，几乎是可以忽略的。这是因为这次的场景比较特殊，以右边的绿色墙壁为例，实际上它的Boundbox就是一个与某一轴平行长方形（不是长方体，不信的话可以printBoundbox的那两个点出来看看）所以光线和这个Boundbox相交检测的时候，算出来的t_enter和t_exit是相等的。此时如果相等时仍判断为不相交，就会出错，此时部分物体不可见，如下图：
任务二：实现path tracing 代码量也不是很大，主要就是跟着作业中给的伪代码照着敲，但是想呈现出最终的结果有很多小细节要注意，其中这里面各个向量的方向问题就很容易搞错，一定要仔细琢磨清楚。因为里面要修的细节太多了，我这边直接给出任务二完整的代码（个人建议不要完全照抄，可以自己先跟着作业提供的伪代码敲一下，遇到问题再去自己想办法找资料解决，在最终得到想要的结果后，你会发现这个过程非常值得。），具体的很多细节问题放到后文讨论。很多细节的问题建议直接看代码，可以理解的更清楚。
Vector3f Scene::castRay(const Ray&amp; ray, int depth) const { // TO DO Implement Path Tracing Algorithm here Vector3f hitColor = this-&gt;backgroundColor; Intersection shade_point_inter = Scene::intersect(ray); if (shade_point_inter.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/63388a92d7657d591b8e7a48a2bf3f7c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/393fbe8ed8a1ee264049ef5ed7e16afb/" rel="bookmark">
			MySQL FlinkCDC 通过Kafka实时同步到ClickHouse(自定义Debezium格式支持增加删除修改)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL FlinkCDC 通过Kafka实时同步到ClickHouse(自定义Debezium格式支持增加删除修改)
把MySQL多库多表的数据通过FlinkCDC DataStream的方式实时同步到同一个Kafka的Topic中，然后下游再写Flink SQL拆分把数据写入到ClickHouse，FlinkCDC DataStream通过自定义Debezium格式的序列化器，除了增加，还能进行删除修改。关于Debezium格式的更多信息，参考Flink官网，网址如下。
https://nightlies.apache.org/flink/flink-docs-release-1.13/docs/connectors/table/formats/debezium/
相关依赖
&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.flink&lt;/groupId&gt; &lt;artifactId&gt;flink-java&lt;/artifactId&gt; &lt;version&gt;${flink.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.flink&lt;/groupId&gt; &lt;artifactId&gt;flink-core&lt;/artifactId&gt; &lt;version&gt;${flink.version}&lt;/version&gt; &lt;!-- &lt;scope&gt;provided&lt;/scope&gt;--&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.flink&lt;/groupId&gt; &lt;artifactId&gt;flink-streaming-java_${flink.scala.version}&lt;/artifactId&gt; &lt;version&gt;${flink.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.flink&lt;/groupId&gt; &lt;artifactId&gt;flink-clients_${flink.scala.version}&lt;/artifactId&gt; &lt;version&gt;${flink.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt; &lt;artifactId&gt;hadoop-client&lt;/artifactId&gt; &lt;version&gt;3.2.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.21&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.flink&lt;/groupId&gt; &lt;artifactId&gt;flink-table&lt;/artifactId&gt; &lt;version&gt;${flink.version}&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;!-- &lt;scope&gt;provided&lt;/scope&gt;--&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.flink&lt;/groupId&gt; &lt;artifactId&gt;flink-table-planner-blink_${flink.scala.version}&lt;/artifactId&gt; &lt;version&gt;1.13.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.flink&lt;/groupId&gt; &lt;artifactId&gt;flink-table-planner_2.12&lt;/artifactId&gt; &lt;version&gt;${flink.version}&lt;/version&gt; &lt;!-- &lt;scope&gt;provided&lt;/scope&gt;--&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.flink&lt;/groupId&gt; &lt;artifactId&gt;flink-table-api-java-bridge_2.12&lt;/artifactId&gt; &lt;version&gt;${flink.version}&lt;/version&gt; &lt;!-- &lt;scope&gt;provided&lt;/scope&gt;--&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/393fbe8ed8a1ee264049ef5ed7e16afb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6fbd5ab3977c180b605cbc80349a8e2/" rel="bookmark">
			golang读取chrome/edge浏览器本地cookies数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		去爬个资料，登录验证太麻烦，不如本地浏览器登录后读取cookies直接爬来的方便，本来打算网上找一个现成的代码来读取浏览器cookies数据库，结果度娘半天竟然没有（网上全都是python的），要不就只有去仓库下，不如拿python的改一个单文件的，这样使用起来一个文件带到哪都方便。
package main import ( "database/sql" "fmt" "os" "io/ioutil" "encoding/json" "encoding/base64" "syscall" "unsafe" "crypto/aes" "crypto/cipher" "github.com/mattn/go-sqlite3" ) type DATA_BLOB struct { cbData uint32 pbData *byte } func NewBlob(d []byte) *DATA_BLOB { if len(d)==0 { return &amp;DATA_BLOB{} } b:=&amp;DATA_BLOB{ pbData:&amp;d[0], cbData:uint32(len(d)), } return b } func (b *DATA_BLOB) ToByteArray() []byte { d:=make([]byte, b.cbData) copy(d, (*[1 &lt;&lt; 30]byte)(unsafe.Pointer(b.pbData))[:]) return d } func dpapi_decrypt(encrypted []byte)([]byte, error){ dllcrypt32:=syscall.NewLazyDLL("Crypt32.dll") dllkernel32:=syscall.NewLazyDLL("Kernel32.dll") procDecryptData:=dllcrypt32.NewProc("CryptUnprotectData") procLocalFree:=dllkernel32.NewProc("LocalFree") var outblob DATA_BLOB r,_,err:=procDecryptData.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e6fbd5ab3977c180b605cbc80349a8e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72388c34241f0716cbae66eee87bac86/" rel="bookmark">
			Python的安装与基础使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一，Python多版本解释器安装
打开浏览器搜索 www.python.org 打开官网
选择红圈标记的选项点击打开
选择箭头所指的选项打开
选择 Python3.11.1版本进行下载安装
下载完成后打开文件进行安装
点击红圈内的选项进行安装
选择next继续进行安装
将文件保存至D盘继续进行安装
安装 另一个版本 python3.10.5 的步骤与办法与上一致；
通过环境变量选择使用相应的解释器 打开python3.11.1和python3.10.5版本文件所在位置 打开文件夹及复制粘贴且将应用程序复制粘贴并修改重命名为python311。python310
点击此电脑
打开后选择高级系统设置
选择环境变量
选择Pash选项
打开的页面如图所示即为正确
输入wins+r指令打开运行
输入cmd打开终端
输入python运行的解释器为3.11.1版本
输入python310 运行的则是310版本
二，pycharm的安装和汉化
打开浏览器搜索官网 选择社区版进行下载
下载完成后打开文件进行安装
将文件保存至D盘
安装完成后打开程序 点击左侧选项第三个
然后点击右侧小齿轮的第四个选项
随后下载中文插件 打开网盘将黑线上的插件复制粘贴至D盘
随后点击进行安装
点击yes后重启软件
就变成了中文版的 三，真实环境与虚拟环境的使用；
打开本地磁盘E 新建文件夹为pythonprojects 在新建文件为pydemo1
随后打开PyCharm点击新建项目
将文件修改为新建文件pydemo1 基础解释器使用python311为真实环境1 这是由真实环境1创造的虚拟环境1 该文件储存在pydemo1中
将代码用delete删除 输入“ print（”hello world“） ”
然后在已创建的pythonprojects文件里创建pydemo2文件
将PyCharm软件中左上角的venv文件删除
随后点击右下角的python3.11（pydemo1）
点击解释器添加新的解释器 点击本地解释器 打开后将 存储位置和解释器更改为pydemo2和python310解释器后点击确定
然后点击右键选择运行
然后打开pythonprojects文件 创造demo3以及demo4文件夹
demo3使用demo1中的虚拟环境
用demo4使用python310的真实环境 点击右下角将解释器改为真实环境 输入运行
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9a58c2982178356eab0a0b80b4a8133/" rel="bookmark">
			微信小程序  登录页代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 很抱歉，由于微信小程序的代码比较复杂，并且需要结合微信官方文档和小程序开发环境，无法在此给出完整代码。不过，您可以参考以下一些代码片段：
wxml页面代码： &lt;!-- 登录表单 --&gt; &lt;form bindsubmit="formSubmit"&gt; &lt;view class="input-group"&gt; &lt;label for="username"&gt;用户名：&lt;/label&gt; &lt;input id="username" name="username" placeholder="请输入用户名" type="text"/&gt; &lt;/view&gt; &lt;view class="input-group"&gt; &lt;label for="password"&gt;密码：&lt;/label&gt; &lt;input id="password" name="password" placeholder="请输入密码" type="password"/&gt; &lt;/view&gt; &lt;button type="submit"&gt;登录&lt;/button&gt; &lt;/form&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/660c449ec1962aa4ca681480465a2c57/" rel="bookmark">
			CSDN的第一篇文章 我竟然有了6年码龄？！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		不看不知道，一看吓一跳，我竟然有了6年码龄？！
都记不清是什么时候开始看CSDN的了，17年的四月份我还是初三，那时候的我在干什么嘞？？
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6bb06fed9eeec82a764b04328a25d116/" rel="bookmark">
			python-ue4-metahuman-nerf：我创造了一个数字人！！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文：https://zhuanlan.zhihu.com/p/561152870
目录
收起
1. 准备工作：制作 MetaHuman 角色
1.1 创建 MetaHuman 角色
1.2 Quixel Bridge 下载 MetaHuman
1.3 导出 MetaHuman 到 UE4
2. UE 渲染 MetaHuman 的多视点图片
2.1 如何在 UE 中手动渲染视频？
2.2 Python 自动化渲染
2.3 全部代码
3. 渲染结果
随着 ECCV 2020 NeRF 的出现，在计算机视觉、计算机图形学、三维重建等领域砸开了无数的坑位，一篇 NeRF 养活了多少科研工作者、大厂员工。但是要想训练这样一个 Neural Radiance Filed 却不是一件容易的事情，首先从数据来看，训练一个 NeRF 需要该场景的多视点图片，同时还需要知道每张图片所对应的相机参数，要想得到这样的数据，可谓是耗时耗力。那么，有没有一种方式，可以虚拟的仿真出一组 NeRF 的训练数据？
答案当然是有的，而且不止一种方式。下面本文将分享一种使用 UE4 来渲染带有相机参数的多视点图片的方法。在正式开始之前，首先来介绍一下 MetaHuman，它就是我们要渲染的对象。在计算机视觉、三维重建领域，人脸方向的研究一直是一个热点，而 MetaHuman 则是一个高保真的数字人开源框架，我们可以利用 MetaHuman 来设计出自己想要的数字人形象，然后渲染出其多视点图片，用作进一步的研究。
1. 准备工作：制作 MetaHuman 角色 在 UE4 中渲染 MetaHuman 之前，我们首先需要创造一个 Metahuman 角色，然后并将其导入到 UE4 中进行渲染，整体可分为以下几个步骤
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6bb06fed9eeec82a764b04328a25d116/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a662975446449f158223601c876ba6d1/" rel="bookmark">
			python-selenium-运行js代码--下拉操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用python-selenium运行js代码完成下拉操作:在某些情况,当我们下拉到浏览器,浏览器才会给我们加载数据,所有我们需要js带代码
driver.execute_script(""" 写入你要执行的js代码 """) 下拉的js代码:
# document.documentElement.scrollTop指定滚动条的位置 # document.documentElement.scrol1Height 获取当前页面的最大高度 #'document.documentElement.scrol1Tdp=1000 #js_all = 'document.documentElement.scrollTop=document.documentElement.scrollHeight' from selenium import webdriver from selenium.webdriver.common.by import By import time from selenium.webdriver.chrome.options import Options #取消浏览器中的自动化程序正在控制浏览器 opt = Options() opt.add_experimental_option('excludeSwitches',['enable-automation']) # 1:打开浏览器 driver = webdriver.Chrome(options=opt) # 2:输入你的网站 driver.get('https://search.jd.com/Search?keyword=python&amp;enc=utf-8&amp;wq=python&amp;pvid=f7852fe54b664497b8bbf61060df3aa8') driver.implicitly_wait(30) #使用selenium执行js代码---完成下拉动作 driver.execute_script(""" document.documentElement.scrollTop=document.documentElement.scrollHeight """) time.sleep(100) # document.documentElement.scrollTop指定滚动条的位置 # document.documentElement.scrol1Height 获取当前页面的最大高度 #'document.documentElement.scrol1Tdp=1000 #js_all = 'document.documentElement.scrollTop=document.documentElement.scrollHeight' 也可以进阶一下,分别下拉5次,使他的动作更加想人
from selenium import webdriver from selenium.webdriver.common.by import By import time from selenium.webdriver.chrome.options import Options #取消浏览器中的自动化程序正在控制浏览器 opt = Options() opt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a662975446449f158223601c876ba6d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e503ed1b16ee21051e5062005b7a265/" rel="bookmark">
			VS和VScode的区别是什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		区别一：含义不一样。
Visual Studio是美国微软公司的开发工具包系列产品，是一个基本完整的开发工具集，它包括了整个软件生命周期中所需要的大部分工具，如UML工具、代码管控工具、集成开发环境(IDE)等。通俗的讲，是一款编译器。
visual studio code是美国微软公司是一个项目：运行于 Mac OS X、Windows和 Linux 之上的，针对于编写现代 Web 和云应用的跨平台源代码编辑器。通俗地讲，是一款编辑器。
区别二：跨平台运行能力不一样。
Visual Studio 各种功能只能在 Windows 和 macOS（Mac OS X ）之上运行，不能跳跃各平台编辑。
visual studio code是一款真正的跨平台编辑器，可以在用户习惯的平台上使用，而不是非要迁徙到 Windows上。
区别三：功能不一样。
Visual Studio是目前最流行的Windows平台应用程序的集成开发环境。提供了高级开发工具、调试功能、数据库功能和创新功能，帮助在各种平台上快速创建当前最先进的应用程序，开发新的程序。
visual studio code集成了所有一款现代编辑器所应该具备的特性，包括语法高亮，可定制的热键绑定，括号匹配以及代码片段收集，这款编辑器也拥有对 Git 的开箱即用的支持。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b058c1f0f9336dd6434e55549453e69/" rel="bookmark">
			Ubuntu搭建NFS网络文件系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		NFS即网络文件系统，可以在不同机器间建立共享文件夹，操作共享文件夹和操作本地文件夹没有 区别
服务端
服务端即共享文件夹所在端
$ apt-get install nfs-kernel-server #服务器 $ apt-get install nfs-common #客户端 $ vim /etc/exports #在/etc/exports文件末尾添加一行 /nfsroot *(rw,sync,no_root_squash) #推出/etc/exports文件 $ mkdir /nfsroot chmod -R 777 /nfsroot chown root:root /nfsroot -R /etc/init.d/nfs-kernel-server restart 客户端
mount -t nfs 19.168.XX.XX:/nfsroot /mnt -o nolock #命令执行后，客户端中就会有/mnt文件夹，对其进行操作相当于对服务端/nfsroot文件夹操作 将以上命令在多台机器上执行就可以实现多台机器间的共享文件夹
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/498b35b3afff6182cae32ae05ed88f4c/" rel="bookmark">
			数字 09 modelsim中怎么仿真《UVM实战》中的例程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一种方法： 此方法用于UVM环境代码编译。
想要modelsim文件或者uvm代码的可以联系我。
软件环境：win10/win7 modelsim SE-64 10.4
实测编译成功并运行。测试代码是张强大大写的《UVM实战》，第二章的代码
example_and_uvm_source_code\puvm\puvm\src\ch2\section2.5\2.5.2
在用的时候，记得将dut.sv和其他组件代码放在同一个文件夹下，modelsim工程最好也建在这个文件夹下，如果不建在这里，我暂时还没有试过会出现什么错误。
命令行的写法 第一句 将库文件编译到work中：
vlib work
第二句 设置环境变量
UVM目录，这个目录是modelsim安装的文件目录，比如你的modelsim安装在D:/modeltech64，这个就是：
set UVM_HOME D:/modeltech64/verilog_src/uvm-1.1d
这句话，set uvm环境库在uvm-1.1d里面，这个是在modelsim软件安装的时候就放在这里的，照着写就好了。我的modelsim目录比较不一样，我安装的时候写的目录是在D:\modeltech64_10.4，所以我的是：
set UVM_HOME D:/modeltech64_10.4/verilog_src/uvm-1.1d
注意这里比较坑的点是如果你直接将windows的目录字符串复制过来，”\”这个字符是不对的，它要改成”/”
第三句
设置工作目录，指的是工程文件的目录，就是你的dut.sv和top_tb.sv放在哪里了。
set WORK_HOME C:/Users/Administrator/Desktop/2.5.2
第四句
启动编译：
vlog +incdir+$UVM_HOME/src
-L mtiAvm -L mtiOvm -L mtiUvm -L mtiUPF
$UVM_HOME/src/uvm_pkg.sv $WORK_HOME/dut.sv top_tb.sv
如果前面两句都对了，这个肯定也是可以的，如果这里提示file can not ……in read mode
那么一般是文件路径错了，再细心检查一下。
第五句
启动仿真：
vsim -novopt -c -sv_lib
D:/modeltech64_10.4/uvm-1.1d/win64/uvm_dpi
work.top_tb +UVM_TESTNAME=my_case0
这里第二个单词 -novopt是不优化dut.sv的意思。
然后，D:/modeltech64_10.4/uvm-1.1d/win64/uvm_dpi这个是uvm_dpi的库路径。
一般人的modelsim目录是D:/modeltech64，所以可以改成
vsim -novopt -c -sv_lib
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/498b35b3afff6182cae32ae05ed88f4c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/128b02030e4e7ee19045fb7899c06798/" rel="bookmark">
			Go语言channel
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		channel 单纯将函数并发是没有意义的.函数与函数间需要交换数据才能体现并发执行的意义.
共享内存进行数据交换会导致goroutine发生竞态问题.为了保证数据交换的正确性,必须使用互斥量对内存进行加锁,这种做法势必会导致阻塞问题.
Go语言的并发模型是CSP(Communicating Sequential Process),提倡通过通信共享内存而不是通过共享内存而实现通信.
如果说goroutine是Go程序并发的执行体,channel就是它们之间的连接.channel是一个可以让一个goroutine发送特定值到另一个goroutine的通信机制.
Go语言中的通道(channel)是一种特殊的类型.通道像一个队列,遵循FIFO原则.每一个通道都是一个具体类型的的导管,也就是声明channel的时候需要为其指定元素类型.
channel类型 var 变量 chan 元素类型 例:
var ch1 chan int // 声明一个传递整形的通道 var ch2 chan bool // 声明一个传递布尔型的通道 var ch3 chan []int // 声明一个传递int切片的通道 创建channel 通道是引用类型,通道类型的空值是nil
var ch chan int fmt.Println(ch) // nil // 声明channel后需要使用make函数初始化之后才能使用.创建channel的格式: make(chan 元素类型, [缓冲大小]) ch1 := make(chan int) // 不带缓冲区的通道初始化 ch2 := make(chan bool, 16) // 带缓冲区的通道初始化 ch3 := make(chan []int) channel信息传递 发送 ch &lt;- 10 // 把10发送到ch中 接收 x := &lt;- ch // 从ch中接收值并赋值给变量x &lt;-ch // 从ch中接收值,忽略结果 关闭 close(ch) 单向通道 func f(ch chan&lt;- int) // 声明f()中，ch只能作为写入通道 func f(ch &lt;-chan int) // 声明f()中，ch只能作为读取通道 channel总结 channel常见异常总结
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/128b02030e4e7ee19045fb7899c06798/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/790302e6f4d577ae887cc73b281ad2e1/" rel="bookmark">
			解决CondaHTTPError HTTP 000 CONNECTION FAILED for url解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决CondaHTTPError: HTTP 000 CONNECTION FAILED for url解决方法 问题：使用conda install命令安装包提示CondaHTTPError: HTTP 000 CONNECTION FAILED for url
分析：网络连接问题，大概率是网速不行或者源没有换
解决方案：修改国内源（国内源已修改或许是因为网速波动，此时可以延长下载时间）
找到.condarc文件 文件内容替换为： channels: - http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ - http://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/ - http://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/msys2/ - http://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/bioconda/ - http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/ show_channel_urls: true ssl_verify: false 如果前两步替换源不行，可以试试延长下载时间：
方式1：命令行conda config --set remote_read_timeout_secs 1000.0
方式2：找到.condarc文件，添加remote_read_timeout_secs: 1000.0
另外附上anaconda 查看运行环境及安装Python包的相关命令 查看anaconda版本：conda --version
查看anaconda运行环境：conda env list
查看已安装包：conda list
查找可安装的包：conda search 包名
安装包：conda install 包名
更新包：conda update 包名
卸载包：conda remove 包名
更新包：conda update 包名
卸载包：conda remove 包名
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/790302e6f4d577ae887cc73b281ad2e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2fad6c5c08353e63897cd3616c455478/" rel="bookmark">
			k8s集群中部署微服务Vue
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		k8s集群中部署微服务后台管理项目 admin 一、项目创建 修改依据
npm版本为12.2.0,可以使用 nvm进行安装及切换使用。
npm install node-sass@4.14 npm install 二、项目容器镜像准备 [root@k8s-master01 sangomall-admin-vue]# ls dist Dockerfile [root@k8s-master01 sangomall-admin-vue]# cd dist [root@k8s-master01 dist]# ls 202212051119 config index.html [root@k8s-master01 dist]# tar czvf dist.tar.gz * [root@k8s-master01 dist]# ls 202212051119 config dist.tar.gz index.html [root@k8s-master01 dist]# mv dist.tar.gz ../ [root@k8s-master01 sangomall-admin-vue]# ls dist dist.tar.gz Dockerfile [root@k8s-master01 sangomall-admin-vue]# vim Dockerfile [root@k8s-master01 sangomall-admin-vue]# cat Dockerfile FROM nginx MAINTAINER &lt;nextgo@126.com&gt; ADD dist.tar.gz /usr/share/nginx/html EXPOSE 80 ENTRYPOINT nginx -g "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2fad6c5c08353e63897cd3616c455478/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f09e51a300359d01b0b48cc7f002684/" rel="bookmark">
			SpringCloud Alibaba【四】Gateway网关配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、Gateway相关依赖二、yaml文件配置总结 前言 SpringCloud网关实现：
Gatewayzuul
Zuul基于Servlet实现，为阻塞式编程，Gateway基于Spring5中的WebFlux，底层使用Netty，为响应式编程，性能更好。 提示：以下是本篇文章正文内容，下面案例可供参考
一、Gateway相关依赖 Gateway也属于微服务的范畴，所以也需要注册到服务中心。
&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; 二、yaml文件配置 spring: application: name: gateway cloud: gateway: routes: #路由id唯一指定，一般是服务名 - id: user # 路由目标地址 # lb负载均衡，后面接服务名 uri: lb://user #断言：编程术语，为布尔表达式，判断请求是否符合 predicates: - Path=/user-service/** filters: - StripPrefix=1 - id: order uri: lb://order predicates: - Path=/order-service/** filters: # 去除地址的第一个地址，也就是将order-service从地址中去除（http://ip:port/order-service后的地址），不然访问到服务会404 - StripPrefix=1 总结 本章之作简单的介绍，详细在后面的博文。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/435c64922200126efe8f08882f4b6a7e/" rel="bookmark">
			Jenkins自动发布到WindowsServer，在WindowsServer执行的命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		@echo off
set apppoolname="6.usegitee"
set websitename="6.usegitee"
set webfolder="usegitee"
echo '停止站点的应用程序池'
C:\Windows\System32\inetsrv\appcmd.exe stop apppool %apppoolname%
echo '停止站点'
c:\Windows\System32\inetsrv\appcmd.exe stop site %websitename%
echo '备份文件'
xcopy C:\www\%webfolder% C:\www\bak\%webfolder%%date:~0,4%%date:~5,2%%date:~8,2%_%time:~0,2%%time:~3,2%\ /Y
echo '新文件发布到站点目录'
xcopy C:\www\up\%webfolder% C:\www\%webfolder%\ /Y
echo '启动站点'
c:\Windows\System32\inetsrv\appcmd.exe stop site %websitename%
echo '启动应用程序池'
C:\Windows\System32\inetsrv\appcmd.exe start apppool %apppoolname%
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5127217860040a708cc99dfccc13b30/" rel="bookmark">
			数据库脏读、幻读、不可重复读与四种隔离级别的理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前言 本章着重点是介绍：出现脏读、幻读、不可重复读的原因，以及设定四种隔离级别如何解决这些现象，结合图例让读者阅读得更加通透
一、什么是事务？ 所谓事务是用户定义的一个数据库序列，这些操作要么全做，要么全不做，是一个不可分割的工作单位。 在SQL中，定义事务的语句一般有三条：
BEGIN TRANSACTION;
COMMIT;
ROLLBACK;
事务通常是以BEGIN TRANSACTION开始，以COMMIT或ROLLBACK结束。
COMMIT：表示提交，即提交事务的所有操作
ROLLBACK：表示回滚
二、事务的ACID特性 【重点】事务具有4个特性：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持续性（Durability）。这4个特性简称为ACID特性
（1）原子性 事务是一个原子性质的操作单元，事务里面的对数据库的操作要么都执行，要么都不执行。
（2）一致性 在事务开始之前和完成之后，数据都必须保持一致状态，必须保证数据库的完整性。也就是说，数据必须符合数据库的规则。
（3）隔离性 一个事务的执行不能被其他事务干扰。即一个事务的内部操作及使用的数据对其他并发事务是隔离的，并发执行的各个事务之间不能互相干扰。
（4）持久性 持久性也成为永久性，指一个事务一旦提交，它对数据库中数据的改变就应该是永久的。
三、何为脏读，幻读，不可重复读？ （1）脏读 脏读也俗称“读未提交”，顾名思义，就是某一事务A读取到了事务B未提交的数据，如图所示：
T2时刻，事务B把原来李华的年龄由原数据13改为了23，此后又被T3时刻的事务A读取到了，但是T4时刻事务B发生异常，进行了回滚操作。这个过程，我们称23为脏数据，事务A进行了一次脏读。
（2）不可重复读 不可重复读，有时候也会说成“读已提交”。什么意思呢，就是在一个事务内，多次读取同一个数据，却返回了不同的结果。实际上，这是因为在该事务间隔读取数据的期间，有其他事务对这段数据进行了修改，并且已经提交，就会发生不可重复读事故。
图示中事务A在T1和T4查询同一语句，却得到了不同的结果，这是因为T2~T3时刻事务B对该数据进行了修改，并提交。这个过程，出现了在一个事务内两次读到的数据却是不一样的，我们称为是不可重复读。
不可重复读和脏读的区别：前者是“读已提交”，后者是“读未提交”
（3）幻读 幻读是指当事务不独立执行时，插入或者删除另一个事务当前影响的数据而发生的一种类似幻觉的现象。举个例子，某事务在检查表中的数据数count时，是10，过一段时间之后再查是11，这就发生了幻读，之前的检测获取到的数据如同幻觉一样。
出现幻读和不可重复读的原因很像，都是在多次操作数据的时候发现结果和原来的不一样了，出现了其他事务干扰的现象。但是，幻读的偏重点是添加和删除数据，多次操作数据得到的记录数不一样；不可重复读的偏重点是修改数据，多次读取数据发现数据的值不一样了。 幻读图示如下：
事务B向表中新插入了一条数据，事务A在T3时刻后查询数据的时候，突然发现数据和以前查询的时候多出了一项，像产生了幻觉一样。
四、四种隔离级别 1.读未提交（Read Uncommitted）：在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读（Dirty Read）
2.读已提交（Read Committed）：这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这种隔离级别也支持所谓的不可重复读（NonrepeatableRead），因为同一事务的其他实例在该实例处理其间可能会有新的commit，所以同一select可能返回不同结果
3.可重复读（Repeatable Read）:这是MySQL的默认事务隔离级别，同一事务的多个实例在并发读取数据时，会看到同样的数据。不过理论上，这会导致另一个棘手的问题：幻读（Phantom Read）。简单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行。
4.可串行化（Serializable）：这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争
这四种隔离级别越往后越影响性能，如何选取根据业务需求而定。以下是四种隔离级别中对脏读、不可重复读、幻读的影响情况。
读未提交（Read Uncommitted）依旧存在脏读、不可重复读和幻读；读已提交（Read Committed）解决了脏读问题，因为发生脏读的条件就是读未提交的数据；可重复读（Repeatable Read）进一步解决了不可重复读的问题，从隔离名称就可以看出，但还存在幻读问题；可串行化（Serializable）解决了脏读、幻读、不可重复读问题，但是设立这种隔离级别会大大消耗性能。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4106b3b5ba68d99af745a3ee2fe69f0c/" rel="bookmark">
			Java基础：==与equals()的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、" == "与equals()的区别 " == "既可以作用在基本数据类型中，也可以作用在引用数据类型中equals()只能作用在引用数据类型（两个对象），无法作用在基本数据类型" == "作用在基本数据类型时比较的的是值是否相同，作用在引用数据类型时比较的是两个对象的地址值是否一致（是否指向相同对象）equals()方法在不重写的情况下调用的是"=="也就是比较两个对象的地址值是否一致，但是equals()是可以重写的，如果重写后具体对比的含义根据重写规则而定 二、运算符 " == " 作用：既可以在基本数据类型中进行对比，也可以在引用数据类型中做对比意义：比较的是栈中的值（基本数据类型比较的就是值本身，引用数据类型比较的是两个对象的地址值）举例：
System.out.println(a==b);返回true，因为基本数据类型“ == ”比较的是值System.out.println(p1==p2);返回false，因为p1和p2指向的地址不同System.out.println(p1==p3);返回false，因为p1和p3指向的地址不同（即便p1和p3的内容是一致的） 三、方法equals() 作用：equals()只能作用两个引用数据类型（两个对象）意义：equals()本质上调用的依旧是"=="，但是根据重现规则可以表达不同的含义源码：可见equals()方法本质上调用的是"=="，但是是可以重写的 /* * @param obj the reference object with which to compare. * @return {@code true} if this object is the same as the obj * argument; {@code false} otherwise. * @see #hashCode() * @see java.util.HashMap */ public boolean equals(Object obj) { return (this == obj); } 举例：
System.out.println(p1.equals(p2));返回false，在没有重写equals()前调用的依旧是“==”，判断的是地址值是否一致 重写Person类的equals()方法：
@Override public boolean equals(Object o) { if (this == o) { return true; } Person person = (Person) o; return this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4106b3b5ba68d99af745a3ee2fe69f0c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10b2932cfb77323c3155eeb11acbbf91/" rel="bookmark">
			有关联想拯救者Y7000重装window10系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1 联想拯救者使用U盘重装系统不需要进入bios2 总结 由于C盘爆满了，所以选择重装系统来重新给C盘分下区，给C盘分大点。然后重装系统的具体流程参照的是博客使用U盘重装Windows10系统详细步骤及配图【官方纯净版】。然后写这个博客的目的是记录一下自己在按照流程操作过程中所遇到的一些问题。
1 联想拯救者使用U盘重装系统不需要进入bios 可以看到博客使用U盘重装Windows10系统详细步骤及配图【官方纯净版】中有进入bios的一个流程。然后按照博客中的操作联想拯救者其实是进不去的。最后经过一番探索发现联想拯救者重装系统不需要进入bios这一步。所以我们将使用U盘重装Windows10系统详细步骤及配图【官方纯净版】中进入bios的流程替换成下面的步骤：
1.1 搜索更改高级启动选项
1.2 点击立即启动
1.3 选择U盘启动
接下来按照使用U盘重装Windows10系统详细步骤及配图【官方纯净版】的步骤继续往下即可。
2 总结 总结一下哈，参照博客使用U盘重装Windows10系统详细步骤及配图【官方纯净版】操作几乎没遇到什么别的问题，除了上面讲的这个。然后还有一点就是有部分操作的顺序可能与使用U盘重装Windows10系统详细步骤及配图【官方纯净版】中不同，所以在参考使用U盘重装Windows10系统详细步骤及配图【官方纯净版】之前一定要先将其浏览一遍，自己对整个流程才有一定的掌握，就算顺序不对也知道在哪一步变在哪一步改。
其它问题：u盘被分为两个磁盘,怎么合并
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7303f1c5deaf5ea652fcecfb09eb1216/" rel="bookmark">
			基于 Web 的远程访问解决方案，适用于 UNIX®、Linux® 和微软® Windows® 桌面和应用程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		飞利浦医疗通过高性能远程访问解决方案推进患者护理技术
飞利浦医疗存在的挑战
1、对集成解决方案的多个系统进行远程访问连接；
2、医疗保健专业人员需要高质量的图形应用程序显示；
3、安全的远程访问，能够保护敏感数据和关键患者数据。
解决方案：
OpenText Exceed TurboX
取得的成果
1、连接多个系统，以增强肿瘤治疗的交付；
2、确保高质量的远程图形，实现精确的图像和诊断；
3、提高安全性以保护患者数据和关键应用程序的安全。
飞利浦放射肿瘤学为世界各地的医院和诊所提供将诊断设备与成像和治疗计划软件相结合的端到端解决方案。该公司提供创新技术，可提高癌症治疗的质量和交付，同时降低成本。飞利浦放射肿瘤学产品组合治疗计划系统总监胡安·卡洛斯·塞利介绍了飞利浦利用技术改变医疗保健服务的方式。“解决方案的集成已成为医疗保健领域的必要条件。无论是肿瘤学、心脏病学还是神经病学，机器与软件和智能解决方案的集成都越来越典型。”
“拥有强大的组件集成，能够相互连接并分析共享的数据，这确实非常重要。借助 OpenText Exceed TurboX，我们能够连接许多不同的组件，即使它们都运行在不同的操作系统上，用户都可以使用它们。”
——飞利浦放射肿瘤学研发主管(北美) 西蒙·奥马尔
飞利浦放射肿瘤学平台解决方案组负责人肖恩·吉本斯解释说，因为不同位置的用户远程访问系统，患者数据在多个应用程序中可能仍然分散，所以系统集成至关重要。“现在医疗保健的交付方式，不仅仅是一个场所，或者一个单一的工作站。它分布在多个设施和多个护理人员中。医生、护士和其他治疗人员需要访问患者数据。而且，当他们查看数据时，他们不是仅从一个特定的应用程序查看数据，而是跨多个应用程序查看数据。
为了便于远程访问多种医疗保健解决方案，飞利浦需要一个拥有该技术的合作伙伴，以连接广泛的 IT 生态系统。北美飞利浦放射肿瘤学研发主管西蒙·奥马尔（Simon Omer）描述了这些要求。“我们正在从单一产品转向解决方案领域，这需要不同组件、产品和产品的强大集成。这些不同的组件汇集了希望能够从任何地方访问其系统的广泛用户。他们希望每次都能通过可靠的高质量安全连接进行连接。我们需要一个满足这些要求的解决方案。”
在评估了其他软件应用程序后，飞利浦选择了 OpenText™ Exceed™ TurboX，这是一种基于 Web 的远程访问解决方案，适用于 UNIX®、Linux® 和微软® Windows® 桌面和应用程序。飞利浦正在使用该解决方案对 IntelliSpace 放射肿瘤学平台进行远程访问，该平台提供单一的集成解决方案，使医生和临床医生能够通过医院网络快速高效地远程查看、开处方和计划治疗，同时增强诊断信心。
飞利浦依靠Exceed TurboX 所提供的安全性、性能和轻松访问飞利浦软件应用程序，使医生能够提高患者治疗的质量和速度。“我们希望提供更快、更早地诊断癌症的能力，”西蒙·奥马尔解释说。“拥有强大的组件集成，能够将它们互连并分析共享的数据，这非常重要。借助 OpenText Exceed TurboX，我们能够连接许多不同的组件，即使它们都运行在不同的操作系统上，用户都可以使用它们。我们基本上需要从任何IT设备访问。有了OpenText Exceed TurboX，这是可以实现的。”
Exceed TurboX 还满足了飞利浦对高质量远程显示的严格要求，这确保了对患者数据的准确分析，并为远程工作的医生和临床医生提供快速诊断依据。为了防止因图像质量差而导致的错误诊断，该解决方案提供了像素完美的绘图和精确的显色性。
“当我们考察 OpenText Exceed TurboX 时，我们测试了几个元素，包括图像性能。我们希望获得最佳的医学图像质量。OpenText Exceed TurboX甚至在恶劣的网络条件下，图像质量都优于我们所关注的所有其他产品。”
——飞利浦放射肿瘤学研发主管(北美)西蒙·奥马尔
此外，Exceed TurboX 为远程交互式会话启用强加密、集成身份验证和空闲会话注销，提高了患者数据的安全性和隐私性。它在多个级别上提供安全性，保护系统免受内部和外部攻击，将核心应用程序保留在中央数据中心，确保没有未经授权的访问。“我们希望连接始终是安全和私密的，”奥马尔指出。“借助 OpenText Exceed TurboX，我们能够提供高级别的安全性，这使我们的用户受益匪浅。”
由于飞利浦期待全面部署 OpenText Exceed TurboX 解决方案，团队看到了借助 OpenText 合作伙伴关系的机会，通过无缝集成系统和任务，进一步帮助医院改进癌症治疗计划。“当我们第一次使用OpenText，我们有非常具体的访问放射治疗计划应用程序的需求，”吉本斯说，“随着我们战略计划的推进，我们已经打开了这个投资组合。我们现在正在研究工作流引擎和寻求第三方集成。随着我们继续深入放射肿瘤学领域，我们将进一步扩展这一点。这就是我们与OpenText的合作伙伴关系继续发展的地方。”
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7303f1c5deaf5ea652fcecfb09eb1216/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed732aadb36966df4ecf8751077a30d8/" rel="bookmark">
			话说 C# 程序员人手一个 ORM
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
话说C#程序员人手一个ORM，确实没有必要再写ORM了，不过我的ORM并不是新的，是从DBHelper演化过来的，算是DBHelper魔改版。
目前流行的ORM有EF、Dapper、SqlSugar、FreeSql、Chloe等，有经验的程序员总是在这些ORM基础上或者在DBHelper基础上再封装一套，再加上自己写ORM的，可谓人手一套ORM。可能是因为在框架当中，编写ORM，入门相对简单吧，但是做好很难。
本项目来源：项目来源于需求，2014年我在上家公司做ERP、CRM之类的BS管理系统项目，当时公司用的就是OracleHelper、SqlServerHelper之类的；
2015年开始尝试修改，当时支持了事务，但仍是静态的帮助类；
2016年我把OracleHelper、SqlServerHelper、MySqlHelper、SQLiteHelper合成了一个DBHelper，仍是静态类。
2017跳槽到现公司，公司大项目我的DBHelper就用不上了，平时小项目用用；
2020年，终于发现静态DBHelper多线程并发，事务这块有BUG，所以改造成了非静态的。后来又加入SqlString类，重构以方便扩展支持更多数据库种类；最近简单支持了一下Lambda表达式；几经修改，原来DBHelper的那些方法几乎没怎么变；长期不变的稳定的API才是好API。
主要是自己用的，如果别人要用的话，建议从gitee或github上拉源码下来，源码在手好控制，源码相对简单，有经验的程序员不难看懂，可以自己调试修改扩展，Lambda表达式是新支持的，如果Lambda hold不住，就使用原生SQL。
跟主流ORM相比还是比较欠缺的，它只是一个DBHelper。
源码地址(VS2015、.NET Framework 4.5.2)
https://gitee.com/s0611163/DBHelper
https://github.com/0611163/DBHelper
.NET Core 5 版本源码地址(VS2019、.NET 5)
https://gitee.com/s0611163/DBHelperCore
性能测试
DBHelper SqlSugar EntityFramework 增删改查 性能对比测试
https://www.cnblogs.com/s0611163/p/15814051.html
为什么每个主流ORM都说性能比EF好，都说EF性能不好？而我的测试结果显示EF性能挺好的，为了防止有缓存，每项测试前，重启程序再测，性能还是一样的。批量添加和修改，别的ORM是快很多，但它使用了别的专门的方法。
ORM介绍及使用示例
DBHelper
简介
一款轻量级ORM，查询使用原生SQL，查询结果映射到实体类，增删改支持实体类，支持Oracle、MSSQL、MySQL、SQLite等多种数据库，有配套Model生成器，方便自己扩展以支持更多数据库
特点
支持Oracle、MSSQL、MySQL、SQLite四种数据库
方便扩展以支持更多关系数据库
有配套的Model生成器
insert、update、delete操作无需写SQL
查询使用原生SQL
查询结果通过映射转成实体类或实体类集合
支持参数化查询，通过SqlString类提供非常方便的参数化查询
支持连接多个数据源
单表查询、单表分页查询、简单的联表分页查询支持Lambda表达式
支持原生SQL和Lambda表达式混写
优点
代码实现比较简单，有经验的程序员容易掌控代码，自己修改和扩展
查询使用原生SQL
缺点
联表查询对Lambda表达式的支持比较弱
复杂查询不支持Lambda表达式
建议
单表查询可以使用Lambda表达式
联表查询以及复杂查询建议使用原生SQL或原生SQL和Lambda表达式混写
示例
定义数据库对象
public class DBHelper { #region 变量 private static ISessionHelper _sessionHelper = new SessionHelper(ConfigurationManager.ConnectionStrings["DefaultConnection"].ToString(), DBType.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed732aadb36966df4ecf8751077a30d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9fe15eddb9c0f3fe0f7c943486b91939/" rel="bookmark">
			OpenGL之GLSL编程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. GLSL基本语法
1.1 数据类型及其使用
基本的数据类型包括 float、bool、int、uint，向量类型vec，矩阵类型mat，数组，结构体以及sampler类型。
基本数据类型 float a,b; int c = 2; bool d = true; GLSL是强类型语言，必须要进行显式的强制类型转换，不存在隐式的类型转换。
int a = int(2.0); float c = float(a); 向量类型
vec2、vec3、vec4表示一个float类型的向量；bvec2、bvec3、bvec4表示一个bool向量；ivec2、ivec3、ivec4表示整型向量； vec3 a = vec3(1.0,0.0,1.0); bvec2 b = bvec2(true,false); vec2 c = vec2(1.0,0.0); vec2 d = vec2(1.0,0.0); vec4 e = vec4(c,d); float h = 3.0; vec2 g = vec2(1.0,2.0); vec3 s = vec3(g,h); vec4 color; vec3 rgb = vec3(color); vec3 white = vec3(1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9fe15eddb9c0f3fe0f7c943486b91939/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e012b38990f951b20af713157a8a304/" rel="bookmark">
			基于Python 课程设计-学生管理系统（附源码&#43;可执行程序）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 基于Python 课程设计-学生管理系统（附源码+可执行程序）
非常完整的一个项目，可以作为课程设计去学习。
本系统的完整源码在文章结尾处，大家自行获取即可。
开发环境要求 本系统的软件开发及运行环境具体如下。
操作系统：Windows 7、Windows 10。
Python版本：Python 3.7.0。
开发工具：Python IDLE。
Python内置模块：os、re。
运行方法 在项目文件studentsystem.py上单击鼠标右键，在弹出快捷菜单中选择“Edit with IDLE\Edit with IDLE 3.7(64-bit)”菜单项，如图1所示。
图1 选择IDLE打开项目文件
在打开的Python Shell窗口中，按下F5键运行程序即可。运行效果如图2所示。
图2 项目主界面
# _*_ coding:utf-8 _*_ # 文件名称：studentsystem.py # 开发工具：PyCharm import re # 导入正则表达式模块 import os # 导入操作系统模块 filename = "students.txt" # 定义保存学生信息的文件名 def menu(): # 输出菜单 print(''' ╔———————学生信息管理系统————————╗ │ │ │ =============== 功能菜单 =============== │ │ │ │ 1 录入学生信息 │ │ 2 查找学生信息 │ │ 3 删除学生信息 │ │ 4 修改学生信息 │ │ 5 排序 │ │ 6 统计学生总人数 │ │ 7 显示所有学生信息 │ │ 0 退出系统 │ │ ========================================== │ │ 说明：通过数字或↑↓方向键选择菜单 │ ╚———————————————————————╝ ''') def main(): ctrl = True # 标记是否退出系统 while (ctrl): menu() # 显示菜单 option = input("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e012b38990f951b20af713157a8a304/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ca158ac52b917d43c4255ff3d9e1dde/" rel="bookmark">
			【嵌入式面试】2022年嵌入式经典面试题汇总（Linux | 文件IO）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		📜作者：不想脱发的基兄
📺专栏：《嵌入式面试》
📣格言：我不停奔跑只为追赶当年被寄予厚望的自己。
前言 2022年秋招我面试嵌入式MCU开发方向，经过了多场的笔试与面试，在准备的过程中看了非常多的资料，我的汇总的笔记一直写在有道云笔记中，没有分享出来。现在已经到了23年春招了，特此整理后分享出来。资料看过了觉得不错就保存下来了，如果有不对的地方，欢迎批评指正，侵权联删！
一、 Linux 1 Window系统和Linux系统的区别 1.1 区分大小写 linux区分大小写windows在dos（磁盘操作系统）界面命令下不区分大小写； 1.2 文件系统上的区别 Windows 下，计算机是以驱动器盘符区分所有文件Linux没有盘符这个概念，以根目录 /区分所有文件 1.3 文件形式保存 Linux所有内容均以文件形式保存包括硬件，用户；windows文件和硬件没什么关系，两个之间没有关联； 1.4 文件区分 windows用扩展名区分文件；
如.exe代表执行文件，.txt代表文本文件，.gz ， .bz2 ，.tar.bz2代表压缩包，.html ，.php代表网页文件。linux是以权限区分文件，没无扩展名的概念。管理员为了方便，可以部分扩展。 文件类型文件符号普通文件‘ -’目录文件‘ d’管道文件‘ p’链接文件‘ l’（硬链接和软链接）。设备文件（块设备 ’ b’ 、字符设备 ‘ c’ ）套接字文件‘s’ 1.5 开源与收费 windows大部分软件收费，系统非开源。系统具有数量和质量的优势，由微软官方提供重要支持和服务 。linux平台大都为开源自由软件，用户可以修改定制和再发布，由于基本免费没有资金支持，部分软件质量和体验欠缺；有全球所有的Linux开发者和自由软件社区提供支持。 1.6 执行文件与安全性 windows下的执行文件是.exe文件，大部分是图形界面，不具有安全性。.exe文件不能直接在linux下安装与运行。linux下的执行文件是二进制文件，大部分是字符界面，具有安全性，减少了木马攻击的可能性。 1.7 程序安装 Windows软件安装是通过应用商店或者浏览器下载后安装。Linux主要通过shell命令进行安装。可以使用apt方式安装（软件包管理系统）、rpm包安装、deb包安装、tar.gz源代码包安装、tar.bz2源代码包安装、yum方式安装(安装rpm包)、bin文件安装。 1.8 占用系统资源 linux是字符界面，占用的系统资源较于windows下的图形界面所占的资源小。Windows是图形界面，较于Linux的字符界面所占的资源大。
参考链接 2 Linux的根目录有哪些？各有什么作用？ 2.1 Linux的根目录有哪些 有/bin、/home、/boot、/cdrom、/dev、/etc、/initrd.img、/initrd.img.old、/lib、/lib64、/lost+found、/media、/mnt、/opt、/proc、/ root、/run、/sbin、/snap、/srv、/sy、/tmp、/usr、/var 等。
2.2 Linux的根目录的作用 根目录名作用/bin可执行二进制文件的目录，如常用的命令 ls、tar、mv、cat 等/home普通用户的家目录/rootroot用户的家目录/boot内核文件的引导目录, 放置 linux 系统启动时用到的一些文件/sbing超级用户使用的指令文件/tmp临时文件目录/dev设备文件目录/lib共享库，系统使用的函数库的目录/usr第三方程序目录/etc配置程序目录，系统配置文件存放的目录/var可变文件，放置系统执行过程中经常变化的文件/opt用户使用目录，给主机额外安装软件所摆放的目录。 3 linux下有哪几种文件 普通文件类型(-)目录文件类型(d)块设备文件类型(b)字符设备类型©套接字文件类型(s)管道文件类型§链接文件类型(l) 二、文件IO 1 系统IO和标准IO操作文件的区别？ 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ca158ac52b917d43c4255ff3d9e1dde/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7c99daefbc13ae332922f2191cf7eda/" rel="bookmark">
			如何使用GParted扩展Ubuntu系统根目录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、扩展Ubuntu系统的磁盘容量
2、安装GParted扩容工具
3、重新分配分区空间
4、重新添加/dev/sda2和/dev/sda5分区
添加/dev/sda2分区
添加/dev/sda5分区
配置环境：Ubuntu14.04
1、扩展Ubuntu14.04系统的磁盘容量 选中安装的虚拟机，右键进入“设置”选项卡，然后选中“硬盘”选项，通过“扩展磁盘容量”实现磁盘扩容，最大磁盘大小设置为扩充后的磁盘容量（比如我设置扩展后为35GB)，最后单击“扩展”，等待一段时间即可实现磁盘扩容。
2、安装GParted扩容工具 磁盘容量扩充成功后，重启系统，安装GParted工具
sudo apt-get install gparted 启动GParted
sudo gparted 或者通过搜索“GParted”
启动GParted，运行GParted后，可以看到各个分区的位置分布图。
图中“钥匙”图标需要在选中分区后，通过右键“Swapoff”来消除禁用编辑状态。
删除上图中的/dev/sda2和/dev/sda5分区(选中指定删除的分区，通过右键“Delete”删除该分区)。
分区删除之后如下图
3、重新分配分区空间 右键选中的/dev/sda1分区，弹出如下选项框。
单击“Resize/Move”，鼠标往右拖下图条形框，分配新的磁盘空间。设置完成之后，单击右下角的“Resize”完成分区扩容。
4、重新添加/dev/sda2和/dev/sda5分区 添加/dev/sda2分区 右键“unallocated”分区，单击弹出选框中的“New”进行分区设置。Create as设置为"Extended Partition"，Lable设置为/dev/sda2，最后单击“Add”，添加/dev/sda2分区。​
分区结果
添加/dev/sda5分区 在添加dev/sda2分区的基础上，同样通过右键“unallocated”分区来新增/dev/sda5分区。分别设置Create as为"Logical Partition"，File system为linux-swap，Lable为/dev/sda5。最后单击“Add”，添加/dev/sda5分区。
最后的分区结果。
注意：/dev/sda2和/dev/sda5两个分区之间是依赖关系（dev/sda5建在dev/sda2分区下）
最后单击“对勾”保存分区结果。
重启ubuntu14.04系统即可。
如果新扩充的磁盘空闲空间不是挨着要扩展的目标分区的，那么就需要将空闲空间移动到目标分区前面或后面，具体操作参考Ubuntu用gparted合并分区 - 摩斯电码 - 博客园。
关注公众号【拾光夕拾】，回复“1024”即可免费领取110本经典编程电子书。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/949d60908cbb8d06a17e422f48bc0f74/" rel="bookmark">
			51单片机——步进电机实验，小白讲解，相互学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		步进电机简介：
步进电机是将电脉冲信号转变为角位移或多线位移的开源控制元件。在非超载的情况下，电机的转速，停止的位置只取决于脉冲信号的频率和脉冲数，而不受负载变化的影响，即给电机加一个脉冲信号，电机则转过一个步距角。这一线性的关系的存在，加上步进电机只有周期性的误差而无累计误差等特点。使得在速度，位置等控制领域用步进电机来控制变的非常简单。虽然步进电机已经被广泛的应用，但步进电机并不像普通电机，交流电机在常规下使用，它必须由双环形脉冲信号，功率驱动电路等组成控制系统方可使用。因此用好步进电机也并非易事，它涉及到机械，电机，电子及计算机等多专业知识。下图即为混合式步进电机图。
步进电机工作原理：
通常步进电机的转子为永磁体，当电流流过定子绕组时，定子绕组产生一失量的磁场。磁场会带动转子旋转一定的角度，使的转子的一对磁场方向与定子的磁场方向一致。当定子的矢量磁场旋转一个角度。转子也随着该磁场转步距角。每输入一个电脉冲，电动机转动一个角度前进一步。它输入的角位移与输入的脉冲数成正比，转速与脉冲频率成正比。改变绕组通电顺序，电机就会反转。所以可以控制脉冲数量，频率及电机各相绕组的通电顺序来控制步进电机的转动。具体看下图：
步进电机极性区分：
步进电机又分为单极性的步进电机和双极性的步进电机：具体如下图所示：
其中左侧为单极性步进电机，右侧为双极性步进电机，单双极性是指一个步进电机里面有几种电流的方向，左侧的五线四相步进电机就是单极性的步进电机，图中的红色箭头为电流的方向，四根线的电流走向汇总到公共线，所以称之位单极性电机；但是右侧则不同，电机中有两个回路，两个电流的回路就是双极性，所以称之为双极电机。
单机性绕组
单极性步进电机使用的是单极性绕组。其一个电机上有两个绕组，这种联连方式位当一个绕组通电时，产生一个北极磁场；另一个绕组通电，则产生一个南极磁场。因为从驱动器到线圈的电流不会反向，所以可称其为单机绕组。
双极性绕组
双极性步进电机使用的是双极性绕组。每组用一个绕组，通过将绕组中电流反向，电磁极性被反向。典型的两相双极驱动的输出步骤在电气原理图和下图中的步进顺序中进一步阐述。按图所示，转换只利用绕组简单地改变电流方向就能改变该组的极性。
永磁步进电机包括一个永磁转子，线圈绕组和导磁定子，只要将线圈通电根据电磁铁的原理就会产生磁场，分为南北极，见上图所示；通过改变步进电机定子的磁场，转子就会因为磁场的变化而发生转动，同理，一次改变通电的顺序就可以使得电机转动起来
双极性步进电机驱动原理
下图是一个双极性的步进电机整步，步进顺序。在第一步中：将 A 相通电， 根据电磁铁原理，产生磁性，并且因异性相吸，所以磁场将转子固定在第一步的 位置；第二步：当 A 相关闭，B 相通电时，转子会旋转 90°；第三步：B 相关 闭、A 相通电，但极性与第 1 步相反，这促使转子再次旋转 90°。在第四步中： A 相关闭、B 相通电，极性与第 2 步相反。重复该顺序促使转子按 90°的步距 角顺时针旋转。 上图中显示的步进顺序是单相激励步进，也可以理解为每次通电产生磁性的 相只有一个，要么 A 相，要么 B 相；但是更常用的是双相激励，但是在转换时， 一次只能换相一次，具体详见下图： 上图是两相同时通电的旋转顺序，与单相激励不同的是，单相通电后被固定 在了与定子正对着的绕组极性，但是双相同时激励时转子却被固定在两个绕阻的极性中间；此时通电顺序就变成了 AB 相同时通电即可。 在双相激励的过程中，也可以在换相位时加一个关闭相位的状态而产生走半 步的现象，这将步进电机的整个步距角一分为二，例如，一个 90°的步进电机 将每半步移动 45°，具体见下图。 1. A 相通电，B 相不通电 2. A、B 相全部通电，且电流相同，产生相同磁性 3. B 相通电，A 断电 4. B 相通电，A 相通电，且电流相等，产生相同磁性 5. A 相通电，B 断电 6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/949d60908cbb8d06a17e422f48bc0f74/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c843c7028b01e8c1d311f8aaac7511d4/" rel="bookmark">
			Sql单一表中检索数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		单一表中检索数据 1.选择语句2.选择子句3.WHERE子句4.AND，OR，NOT运算符5.IN运算符6.BETWEEN7. LIKE运算符8. REGEXP运算符9.IS NULL运算符10. ORDER BY子句11. LIMIT子句 1.选择语句 选择语句整体什么样
USE sql_store; SELECT * / 1, 2 -- 纵向筛选列，甚至可以是常数 FROM customers -- 选择表 WHERE customer_id &lt; 4 -- 横向筛选行 ORDER BY first_name -- 排序 -- 单行注释 /* 多行注释 */ 2.选择子句 SELECT 是列/字段选择语句，可选择列，列间数学表达式，特定值或文本，可用AS关键字设置列别名（AS可省略），注意 DISTINCT 关键字的使用。
SELECT last_name, first_name, points, points * 10 + 100 AS 'discount_factor' FROM customers; -- DISTINCT为去除重复 SELECT DISTINCT state FROM customers; 3.WHERE子句 WHERE 是行筛选条件，实际是一行一行/一条条记录依次验证是否符合条件，进行筛选
-- &lt;&gt; 代表不等于 USE sql_store; SELECT * FROM customers WHERE points &gt; 3000 /WHERE state !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c843c7028b01e8c1d311f8aaac7511d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2bd85041be842e44d01a61f098f8b778/" rel="bookmark">
			语义通信：DeepSC用于文本传输也太香了吧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		论文标题：Deep Learning Enabled Semantic Communication Systems
论文链接：https://arxiv.org/abs/2006.10685v1
摘要 最近，人们开发了支持深度学习的端到端（E2E）通信系统，以合并传统通信系统中的所有物理层块，从而使联合收发器优化成为可能。在深度学习的推动下，自然语言处理（NLP）在分析和理解大量语言文本方面取得了巨大成功。
受这两个领域研究成果的启发，我们的目标是从语义层面对通信系统提供一个新的视角。 特别地，我们提出了一个基于深度学习的语义通信系统，名为DeepSC，用于文本传输。基于该转换器，DeepSC旨在通过恢复句子的意义，而不是传统通信中的位或符号错误，来最大限度地提高系统容量并最小化语义错误。
此外，迁移学习用于确保DeepSC适用于不同的通信环境，并加速模型训练过程。为了准确证明语义通信的性能，我们还初始化了一个新的度量，称为句子相似度。
大量的仿真结果表明，与不考虑语义信息交换的传统通信系统相比，该系统对信道变化具有更强的鲁棒性，能够在低信噪比下获得更好的性能。
介绍 基于shhannon和Weaver,通信有三个级别
1）符号的传播；
2）传输符号的语义交换；
3）语义信息交换的影响。
第一级通信主要关注符号从发射机成功传输到接收机，其中传输精度主要在比特或符号级别进行测量。第二级通信处理从发送方发送的语义信息和在接收方解释的含义，称为语义通信。第三级处理通信的影响，这些影响转化为接收器以发送器所期望的方式执行某些任务的能力。 在过去的几十年里，通信主要集中在如何准确有效地将符号（以比特为单位）从发射机传输到接收机。在这种系统中，误码率（BER：Bit Error Ratio）或SER（Symbol Error Ratio）表示误符号率。通常被视为性能指标。随着第一代（1G）到第五代（5G）的发展，实现的传输速率提高了数万倍，系统容量逐渐接近单端极限。
最近，各种新的应用出现了，例如自动运输、消费机器人、环境监测和远程健康。 这些应用程序的互连将产生惊人的字节数量的数据。此外，这些应用程序需要在有限的频谱资源上支持大规模连接，但需要较低的延迟，这对传统的信源信道编码提出了严峻挑战。
语义通信可以通过提取数据的含义，过滤掉无用、无关和非本质的信息，从而在保留语义的同时进一步压缩数据，从而在语义域中处理数据。
此外，语义通信有望对恶劣的信道环境，即低信噪比（SNR）区域具有鲁棒性，这非常适合要求高可靠性的应用。这些因素促使我们通过考虑数字比特背后的语义来开发智能通信系统，以提高通信的准确性和效率。
与传统通信不同，语义通信旨在传输与传输目标相关的信息。 例如，对于文本传输，意义因此是基本信息，而表达，即是单词的表达，是不必要的。通过这样做，数据流量将显著减少。在典型通信系统中，当带宽有限、信噪比较低或误码率/误码率较高时，这样的系统可能特别有用。
基于深度学习（DL）的自然语言处理（NLP）和通信系统的最新进展启发我们研究语义通信，以实现上述第二级通信。所考虑的语义通信系统主要关注联合语义信道编码和解码，其目的是提取和编码句子的语义信息，而不是简单地一个比特序列或一个单词。
「对于语义通信系统，我们面临以下问题：」
Question 1: 如何定义bits
Question 2:如何衡量句子的语义错误？
Question 3:如何联合设计语义和信道编码？
本文将NLP中的机器翻译技术应用到物理层通信中，研究语义通信系统。 具体来说，我们提出了一个支持DL的语义通信系统（DeepSC）来应对上述挑战。
「本文的主要贡献总结如下：」
在Transformer的基础上，提出了一种新的DeepSC框架，该框架能够有效地从文本中提取语义信息，并且对噪声具有鲁棒性。在提出的DeepSC中，设计了一种联合语义信道编码来处理信道噪声和语义失真，解决了上述问题3。
DeepSC的收发器由语义编码器、信道编码器、信道解码器和语义解码器组成。为了在理解语义的同时最大限度地提高系统容量，采用两个损失函数对接收器进行优化：交叉熵和互信息。此外，本文还提出了一种新的度量标准，以准确反映DeepSC在语义层面的性能。这些解决了上述问题1和2。
为了使DeepSC适用于各种通信场景，采用深度迁移学习加速模型再训练。通过重新训练的模型，DeepSC可以识别各种知识输入，并从失真中恢复语义信息。
基于大量的仿真结果，提出的DeepSC在低信噪比下的性能优于传统的通信系统，提高了系统的鲁棒性。
DeepSC介绍 所考虑的系统模型包括两个层次：语义层次和传输层次，如图1所示。语义层处理用于编码和解码的语义信息，以提取语义信息。传输级别保证语义信息可以在传输介质上正确交换。
总体而言，我们考虑了一个具有随机物理信道的智能E2E通信系统，其中发射机和接收机具有一定的背景知识，即不同的训练数据。对于不同的应用场景，背景知识可能会有所不同。
定义1：语义噪音是信息交换中的一种干扰，由于信息传输中使用的词语、句子或符号的歧义，干扰了信息的解释。
定义2：物理信道噪声是由物理信道损伤引起的，如加性高斯白噪声（AWGN）、衰落信道和多径，从而导致信号衰减和失真。
如图1所示，发射器将句子s映射为复杂符号流x，然后将其通过具有传输损伤（例如失真和噪声）的物理信道。接收到的y在接收器处解码，以估计原始句子s。我们使用DNN联合设计发射器和接收器，因为DL使我们能够训练输入可变长度句子和不同语言的模型。
特别是，我们假设DeepSC的输入是一个句子，其中wl代表句子中的第l个单词。如图1所示，Transmiter由两部分组成，即语义编码器和信道编码器，用于从s中提取语义信息，并保证语义信息在物理信道上的成功传输。编码的符号流可以用,是参数集为β的语义编码器网络，是参数集为α的信道编码器。为了简化分析，我们假设相干时间为M。如果发送x，接收器接收到的信号将为如图1所示，接收机包括信道解码器和语义解码器，分别恢复发送的符号和随后发送的句子。解码后的信号可以表示为
该系统的目标是最大限度地减少语义错误同时减少要传输的符号数量。 然而，我们在所考虑的体系中面临两个挑战。第一个挑战是如何设计联合语义信道编码。另一个是语义传递，这在传统的通信系统中没有被考虑。
即使现有的通信系统能够实现较低的误码率，但由于噪声和纠错能力的影响，一些比特可能会导致理解困难，因为整个句子的部分语义信息可能会丢失。
为了实现语义级的成功恢复，我们联合设计了语义和信道编码，以保持和s之间的意义不变，这是由一个新的DNN框架实现的。
交叉熵（CE）被用作损失函数来测量s和之间的差异，其公式如下：
性能指标 在E2E通信系统中，发送端和接收端通常以误码率作为训练目标，这有时会忽略通信的其他方面目标。对于文本传输，误码率不能很好地反映性能。
除了通过人工判断来确定句子之间的相似性外，机器翻译中通常使用双语评估研究（Bilingual Evaluation Understudy：BLEU）分数来衡量结果，这将作为本文的性能指标之一。
然而，BLEU分数只能比较两句话中单词之间的差异，而不能比较它们的语义信息。因此，我们初始化了一个新的度量，称为句子相似度，以根据两个句子的语义信息来描述它们的相似程度，这将在下文中介绍。这为问题2提供了一个解决方案。
对于长度为的传输句子s，长度为的解码句子 ，BLEU可以表示为
句子相似性：
一个词在不同的语境中可以有不同的含义。 例如，老鼠在生物学和机器中的含义是不同的。传统的方法，如word2vec[25]，无法识别多义词，其中的问题是如何使用数字向量来表达单词，而数字向量在不同的上下文中有所不同。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2bd85041be842e44d01a61f098f8b778/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d87d3673093cd79d10cda585cd6ae2f4/" rel="bookmark">
			C#调用CMD命令的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C#调用CMD命令的方法 以下代码在文件夹内建立一个文件夹
//视频讲解参考 //https://www.bilibili.com/video/BV16t411f7k8/?spm_id_from=333.880.my_history.page.click&amp;vd_source=e821a225c7ba4a7b85e5aa6d013ac92e private void button1_Click(object sender, EventArgs e) { var p = new System.Diagnostics.Process(); p.StartInfo.FileName = "cmd.exe"; p.StartInfo.RedirectStandardInput = true; p.StartInfo.UseShellExecute = false; p.StartInfo.CreateNoWindow = true; p.Start(); p.StandardInput.WriteLine("md test"); p.StandardInput.WriteLine("exit"); p.StandardInput.Flush(); } 参考链接在代码内
特此记录
anlog
2023年2月12日
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94b9e67ed4e6376077538add95eb8715/" rel="bookmark">
			Python-Django毕业设计旅游推广系统（程序&#43;Lw)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目运行
环境配置：
Jdk1.8 + Tomcat7.0 + Mysql + HBuilderX（Webstorm也行）+ Eclispe（IntelliJ IDEA,Eclispe,MyEclispe,Sts都支持）。
项目技术：
SSM + mybatis + Maven + Vue 等等组成，B/S模式 + Maven管理等等。
环境需要
1.运行环境：最好是java jdk 1.8，我们在这个平台上运行的。其他版本理论上也可以。
2.IDE环境：IDEA，Eclipse,Myeclipse都可以。推荐IDEA;
3.tomcat环境：Tomcat 7.x,8.x,9.x版本均可
4.硬件环境：windows 7/8/10 1G内存以上；或者 Mac OS；
5.是否Maven项目: 否；查看源码目录中是否包含pom.xml；若包含，则为maven项目，否则为非maven项目 6.数据库：MySql 5.7/8.0等版本均可；
毕设帮助，指导，本源码分享，调试部署(见文末)
旅游推广系统由系统前台和后台管理交互构成。前台是用户对于本系统的使用，用户可以通过登录注册，管理个人信息、景点信息、酒店信息、商品信息等内容。
后台主要是管理员模块，可对该平台的用户进行系统管理，卖家登录进后可对用户进行管理，包括景点信息管理、酒店信息管理、旅游推广路线管理等内容。
5.1用户前台功能模块 本系统和大部分系统一样都需要登录才能进入系统进行后续操作，用户输入账号和密码，具体的实现效果如图5.1所示：
图5.1 用户登录界面
用户在使用本软件前需要新进行登录操作，如果用户还没有账号可先注册然后再登录，用户通过输入用户账号、密码、姓名、手机号码、邮箱、身份证号等内容进行注册，具体的实现效果如图5.2所示：
图5.2 用户注册界
用户注册后通过登录进入旅游推广系统可查看首页、景点信息、旅游路线、酒店信息、商品信息、天气信息、站内新闻、留言板、个人中心、后台管理、旅游推广车等内容，具体的实现效果如图5.3所示：
图5.3 系统首页界面
景点信息，用户在景点信息页面可查看景点名称、景点等级、景点照片、景点地址、门票价格、开放时间、交通指南、点击次数、赞、踩、景点介绍、评论等内容，还可进行收藏等操作，具体的实现效果如图5.4所示：
图5.4景点信息界面图
旅游路线，用户在旅游路线页面可查看路线名称、景点名称、景点地址、照片、起点、途径路段、目的地、出行方式、路线详情、评论、地图等内容，还可进行收藏等操作，具体的实现效果如图5.5所示：
图5.5旅游路线界面图
酒店信息，用户在酒店信息页面可查看酒店名称、类别、星级、房间类型、一晚价格、酒店地址、联系电话、照片、房间详情、评论等内容，还可进行酒店预约或收藏等操作，具体的实现效果如图5.6所示：
图5.6酒店信息界面图
商品信息，用户在商品信息页面可查看商品名称、价格、商品分类、规格、品牌、照片、商品详情、评论等内容，还可进行加入旅游推广车、收藏或立即购买等操作，具体的实现效果如图5.7所示：
图5.7 商品信息界面图
天气信息，用户可在天气信息页面查看城市名称、日期、温度、天气状况、风力风向、空气湿度、紫外线等内容，还可进行收藏等操作，如图5.8所示
图5.8天气信息界面图
后台管理，用户进入旅游推广系统后台可查看首页、个人中心、酒店预定管理、系统简介管理、留言板管理、我的收藏管理等内容，如图5-9所示。
图5.9用户后台功能管理界面图
系统简介管理，用户可在系统简介管理页面通过输入标题进行查询等操作，如图5-10所示。
图5.10 系统简介管理界面图
留言板管理，用户可在留言板管理页面通过输入用户名进行查询或删除等操作，如图5-11所示。
图5-11留言板管理界面图
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94b9e67ed4e6376077538add95eb8715/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/181/">«</a>
	<span class="pagination__item pagination__item--current">182/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/183/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>