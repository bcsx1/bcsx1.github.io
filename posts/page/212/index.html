<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2225d4d3d319fc98a95eb01b664bed51/" rel="bookmark">
			SpringCloud基础知识【Feign声明式系统调用】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpringCloud基础知识：Feign 1. Feign 概述2. Feign快速入门2.1 前期准备(`初始默认代码`)2.1.1 `feign-parent模块`2.1.2 `eureka-server模块`2.1.3 `feign-consumer模块`2.1.4 `feign-provider模块` 2.2 Feign应用(`代码修改`)2.2.1 `feign-consumer模块` 3. Feign 其他功能3.1 超时设置3.2 日志记录 1. Feign 概述 Feign是一个声明式的REST客户端，它用了基于接口的注解方式，很方便实现客户端配置。Feign最初由Netflix公司提供，但不支持SpringMC注解，后由SprinaCloud.对其封装，支持了SpringMMC注解，让使用者更易于接受。Feign是用于简化RestTemplate和Ribbon的调用方式的。 2. Feign快速入门 2.1 前期准备(初始默认代码) 2.1.1 feign-parent模块 在父模块中，我们只需要在父模块的pom.xml中引入spring-cloud依赖即可
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.itheima&lt;/groupId&gt; &lt;artifactId&gt;feign-parent&lt;/artifactId&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;modules&gt; &lt;module&gt;eureka-server&lt;/module&gt; &lt;module&gt;feign-provider&lt;/module&gt; &lt;module&gt;feign-consumer&lt;/module&gt; &lt;/modules&gt; &lt;!--spring boot 环境 --&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.0.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;!--spring cloud 版本--&gt; &lt;spring-cloud.version&gt;Greenwich.RELEASE&lt;/spring-cloud.version&gt; &lt;/properties&gt; &lt;!--引入Spring Cloud 依赖--&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2225d4d3d319fc98a95eb01b664bed51/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8083c415a3468148fc0aef7d40c4b76a/" rel="bookmark">
			编写程序，从键盘输入一个字符串，统计并输出该字符串中字符的个数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include&lt;stdio.h&gt; int main() { char str[100];/*定义str字符串，这里用str[100]是因为剩下的可以用\0补齐*/ int cnt=0,i;/*定义cnt用作计数器，初始值为0*/ /*输入字符串*/ printf("请输入字符串"); gets(str);/*gets和puts函数只能输入或者输出一个字符串*/ /*用循环数来表示字符串中的字符数量，可以理解为扫描*/ for(i=0;str[i];i++) cnt++; printf("%s串中字符的个数为：%d个\n",str,cnt); } 上面是我的C语言代码，下面是结果，因为我看CSDN里面没有这道题简单陈述，这些是我的大致理解，中间注释比较多，希望能够帮到你们。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f0f4eb8ddc4bce541b310ea8b99f1c0/" rel="bookmark">
			linux shell脚本执行sql语句建表建库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		linux shell脚本执行sql语句建表建库 1. 创建sql脚本2. 创建shll脚本 1. 创建sql脚本 创建contract_ddl.sql
-- 创建数据库contract_user CREATE DATABASE `contract_user` DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci; -- 创建合同表contract DROP TABLE IF EXISTS `contract`; CREATE TABLE `contract` ( `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT COMMENT 'ID主键', `name` varchar(64) NOT NULL COMMENT '合同名称', `code` varchar(64) NOT NULL COMMENT '合同编号', `deleted` tinyint NOT NULL DEFAULT 0 COMMENT '是否删除 0 未删除 1 删除 默认是0', `create_id` bigint(20) NOT NULL DEFAULT 0 COMMENT '创建人账号id', `create_time` timestamp(0) NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间', `update_id` bigint(20) NOT NULL DEFAULT 0 COMMENT '更新人账号id', `update_time` timestamp(0) NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '更新时间', PRIMARY KEY (`id`) USING BTREE, index `idx_code_name`(`code`,`name`) USING BTREE ) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '合同表' ROW_FORMAT = Dynamic; 创建template_ddl.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f0f4eb8ddc4bce541b310ea8b99f1c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5ab15b2aa2987d6aa3650a41bdaf6d0/" rel="bookmark">
			java实现Apriori算法——频繁项集的计算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 《数据挖掘》：用Apriori算法求特定支持度的频繁项集。
算法本身不难，java萌新我却花费了一天的时间，特此记录。
算法描述 我们目的是求出项数为K的频繁项集即L(K)。
Apriori算法的核心步骤是：
L(K-1)通过自连接求出项数为K的候选项集合C(K)通过对C(K)进行一系列处理（剪枝 + 支持度判断） 得到L(K)集合 在说明下面更多内容之前，先对一部分概念进行说明：
事务：如第一张图中，每一行就是一个事务，如 T100 I1,I2,I5。其中T100是事务编号，这个随便命名，只要保证唯一即可。后面的I1 I2 I5是该事务中的项数据集：如图一，整个表就是数据集，就是所有的事务的集合。即D = {T100,T200…}项集：包含若干个项（如I1 、I2这样的项）的集合。可以看出项集和事务似乎有点项。但是项集更随意一点，任意几个项都能组成一个项集。但是事务是人为规定好的。可信度：项集在数据集中出现的重复次数。项集不一定需要在事务中连续出现。如{I1,I2,I5}项集在数据集中出现的次数为2次，分别是第一个和倒数第二个事务。 接下来，详细分析算法中的两个步骤：
1. 自连接：
怎么个连接法呢？以图二中的L2频繁集的集合为例：
项集	支持度 {I1,I2}	4 {I1,I3}	4 {I1,I5}	2 {I2,I3}	4 {I2,I4}	2 {I2,I5}	2 判断两个项集是否可以自连接要看两个项集的K-1项是否完全相同。如果满足条件，连接后的项集 = 第一个项集 + 第二个项集的最后一个元素。
比如{I1 I2}与{I1 I3}满足自连接条件，连接后的项集为{I1 I2 I3}。
2. 剪枝：
剪枝是这个算法的核心，如果不进行这个步骤的话，也能得出正确结果，但是时间就会大大增加了。
剪枝的核心是若某个集合存在一个非空子集不是频繁项集，则该集合不是频繁项集。
我们通过自连接组成新的K项的候选项集后，需要通过剪枝判断是否满足条件。
即找出该候选项集的含有(K-1)项的子集，并分别判断每个子集是否存在于K-1项频繁项集里。只要有一个不存在，那么该K项候选项集也不可能是频繁项集。
这里我们只需要找含有K-1项的子集，而不用找所有的子集，因为这个算法是从下不断递归上来的，含有更少项的子集肯定是在频繁子集里的。
问题关键是怎么寻找某个K项集的K-1项子集呢？
很简单，依次把K项集中的每个元素去掉一个就可以了。
完成了这两步骤，就完成了这个算法了核心步骤。
3. 对精简后候选集统计每一个项集的支持度
4. 根据最小支持度将候选项集转换为K项频繁项集合
可以看出，如果不剪枝的话，第三步的工作量是非常大的。剪枝过后，候选集的体积大大减小了。
但是获取含有一项的频繁项集因为没有候选项集，就需要特殊处理。
这个很简单，就是统计数据集中的每一项的支持度，并和最小支持度进行比较，得到含有一项的频繁项集。
代码分析 import java.io.BufferedReader; import java.io.File; import java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5ab15b2aa2987d6aa3650a41bdaf6d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d40b73cf548acf63112e4b8624f4b41/" rel="bookmark">
			《寂寞歌唱》读后感
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		11.11日读完《寂寞歌唱》一书，使用时间----一周
《寂寞歌唱》一书出自作家刘醒龙
本书以20世纪90年代县城龙头企业农机厂改革为背景
本文主角林奇，是铸造厂的退休厂长，退休之后由其儿子续任了农机厂厂长一职。
本故事在铸造厂即将倒台的前提下进行
本文的主人公主要有
1. 林奇：林茂父亲，前铸造厂退休厂长，退休后仍坚持踩脚踏车，性格好强、刚正不阿；但是在与儿子的选择之间总是会选择后者，希望儿子可以不贪污；年轻时曾经爱慕石雨，所以将自己踩脚踏车的前几乎全部给予石雨
2. 林茂：林奇儿子，农机厂厂长，在罗县长和江书记的庇护下，吸足了农机厂的血，并创建了八达公司，后使用计谋将八达公司变为私有企业，为个人所得；在我看来，林茂处事圆滑却又有想法，在那个年代，算是一位人才吧；但最后死于车祸
3. 龙飞：林奇的司机，这个角色在全文中描述不多，但是在很多时候却又起到了关键性作用
4. 何友谅：林茂的姐夫，做事情和林奇一样，刚正不阿，时刻为了工人们着想；但是做事情上却又缺乏大度，确实是有才华，但是度量上还是差了一点。最后也是成功接手八达公司和农机厂，也算是圆了他的梦。
5. 林青：林茂的姐姐，全文中提及不多，但是对于何友谅后期的人物烘托可谓起到了不晓得作用，同时做事情也比较有想法，最后在铸造厂改革后成为主要合伙人之一。
6. 赵文：林茂的妻子，本文中描述赵文非常的爱林茂，林茂可以有勇气在外闯荡也会有赵文背后的支持与关怀这一部分原因，但是本文中不得不佩服赵文的洞察力，很轻易的洞察了林茂出轨，难道这就是女人的第六感。
7. 罗县长：本文中的罗县长有比较大的权力，同时也给了林茂敢于挪用农机厂钱的勇气。
8. 江书记：类似于江书记，但是看似很公正，实则还是会纵容手下的人去做事，在本文中权力大似乎确实是可以做不少的事情
9. 石雨：本文出场挺少，但是，他也为衬托主人公林奇和林茂起到了不小的作用，也是因为他的存在，使得林奇做事情上有了一些的犹豫并缺乏果敢。
10. 肖汉文：在全文中后半段出场，也是因为他，林茂有了计谋将八达公司变为私有财产！同时他也是很有计谋，为了钱敢于冒险！
在读完本书之后，我个人最深刻的并不是主角，而是江书记，在本文中江书记出场其实是很少的，但是每次他出场的时候都是在关键的时候。
比如在林茂被调查的时候，赵文和林奇来到了江书记家里面，和江书记说明了情况，江书记一个简单的电话就解决了这个问题，并且顺利的把林茂放了出来。
还有就是在最后林茂出车祸死亡之后，江书记要何友谅接手八达公司的时候，何友谅表示这个公司按理来说最后的继承者应该是赵文，因为八达公司已经是私有企业的时候，江书记表示没有他的批准下，县里面没有一家公司可以正常运行，这也进一步体现出了江书记权力之大！在本文中我也看到了权力之大有多大的影响，权力的力量，这是让我觉得唾弃的！
本文中很多人都想要为自己谋得利益，并且为之勾心斗角，同时很多买卖看似是靠自己的谈判争取而来，可实际确实有潜规则的---无论是权力的压制还是一个色字，似乎都给本文中的农机厂和八达公司的生存带来了不少的影响。
也许现实社会也是这样，只是我们没有体验过也就无从知晓，我想我从作者这里读到的是权力、潜规则的存在！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a3f78ad2656952cd45d5b7beacd59cf/" rel="bookmark">
			vben admin 中 BasicTable 组件 useTable 的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vben admin 中 BasicTable 组件 useTable 的使用 前期准备表格数据以及 API准备表头数据准备表格中的数据准备API 一、在 index.vue 当中使用 BasicTable 以及 useTable二、实现效果 前期准备表格数据以及 API 准备表头数据 这里采用在外部的文件当中定义表头数据,当需要使用的时候,引入就可以了
export function getBasicColumns2(): BasicColumn[] { return [ { title: 'sim卡号（iccid）', dataIndex: 'iccid', sorter: true, width: 130, align: 'center', }, { title: '设备编号', dataIndex: 'deviceId', sorter: true, width: 130, align: 'center', }, { title: '设备名称', dataIndex: 'deviceName', width: 150, align: 'center', }, { title: 'sim状态', dataIndex: ['state', 'text'], sorter: true, width: 130, align: 'center', }, { title: '注册时间', dataIndex: 'createTime', sorter: true, width: 150, format: 'date|YYYY-MM-DD HH:mm:ss', }, { title: '激活时间', dataIndex: 'activeDate', sorter: true, width: 150, helpMessage: '激活后系统会有10-15分钟延迟，请耐心等待', format: 'date|YYYY-MM-DD HH:mm:ss', }, { title: '开卡时间', dataIndex: 'openDate', sorter: true, width: 150, format: 'date|YYYY-MM-DD HH:mm:ss', }, ]; } 准备表格中的数据 可以通过请求来获取
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a3f78ad2656952cd45d5b7beacd59cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9fd5b94c450e423f68fb7076ba20382/" rel="bookmark">
			JAVA中取整数的四种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.向下取整
Math.floor()，向下取整就是取最小的整数，如1.9就返回值为1.0，-1.9就返回-2.0，返回的总是小于等于原数。
2.向上取整
Math.ceil()，向上取整顾名思义就是取最大的整数，如1.9就返回2.0，-1.9就返回-1.0，返回的总是大于等于原数，如图。
3.接近取整
Math.rint()，接近取整顾名思义就是接近哪个取整哪个，如1.6接近2，所以就取2；1.4接近1，所以就取1；那么1.5呢，1.5跟1和2都很接近，这时候就取偶数，如图。
4.四舍五入或（+0.5向下取整）
Math.round()，这个round就有点意思了，如果只考虑正整数的情况下就很简单，就是我们平时说的四舍五入来算就行了，如果是负数，那么的话就要负数+0.5然后再向下取整，如Math.round(-0.6) = (-0.6+0.5)=-0.1，然后向下取整就是-1，
5.类型强转（int）double,(int) float......
注意：此种方法将会直接截取小数后面的部分，直接拿到整数。
public class demo_2 { public static void main(String[] args) { // 向下取整 System.out.println(Math.floor(1.9)); System.out.println(Math.floor(-1.9)); System.out.println("--------"); // 向上取整 System.out.println(Math.ceil(1.9)); System.out.println(Math.ceil(-1.9)); System.out.println("--------"); // 接近取整 System.out.println(Math.rint(1.6)); System.out.println(Math.rint(1.4)); System.out.println(Math.rint(1.5)); System.out.println(Math.rint(2.5)); System.out.println("--------"); // 四舍五入 System.out.println(Math.round(2.5)); System.out.println(Math.round(-2.5)); System.out.println(Math.round(1.2)); } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0f228111e2d367ffea13873064bf5ed/" rel="bookmark">
			Charles&#43;VMOS Pro 抓取Https请求
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Charles+VMOS Pro 抓取Https请求 文章目录 Charles+VMOS Pro 抓取Https请求@[TOC](文章目录) 前言一、Charles1.安装2.配置Charles2.1.Proxy Settings2.2.SSL Proxying Settings2.3.开启电脑代理2.4.安装证书（最重要）2.5.使用浏览器测试 二、VMOS Pro1.虚拟机配置2.虚拟机配置代理3.开启虚拟机adb中设备2的代理设置：4.虚拟机安装证书5.测试 问题总结 前言 一、Charles 1.安装 Charles下载地址
License Key
Registered Name: https://zhile.io License Key: 48891cf209c6d32bf4 2.配置Charles 以Windows10为例
2.1.Proxy Settings 2.2.SSL Proxying Settings 设置需要代理的路径，* 代表所有
2.3.开启电脑代理 Windows 是 ：Windows Proxy
Mac 是：Mac Proxy
2.4.安装证书（最重要） 以下是Windows环境，如果是Mac环境的话，需要找到安装的证书，进行信任设置即可。
2.5.使用浏览器测试 查看证书安装地址
浏览器进入此地址后，会自动下载证书，点击证书安装即可
注意：
如果打开网址后发现并不会自动下载证书，在软件里面查看本地IP（电脑中安装了虚拟机会造成识本机IP有多个），并更换wifi代理地址并再次尝试
使用浏览器查看百度等网址，看看是否能抓包,出现以下信息，就表示成功了。
二、VMOS Pro 1.虚拟机配置 将超级用户、Xposed配置打开，并打开网络ADB设置
2.虚拟机配置代理 3.开启虚拟机adb中设备2的代理设置： #建立连接 ./adb connect 192.168.0.14:5666 #展示有那些设备 ./adb devices #唤起adb中设备2的代理设置： ./adb -s 192.168.0.14:5666 shell am start -a android.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0f228111e2d367ffea13873064bf5ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7409bc541441e07488b2a497c97c5bd8/" rel="bookmark">
			【PTA】均是素数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在给定的区间 [m,n] 内，是否存在素数 p、q、r（p&lt;q&lt;r），使得 pq+r、qr+p、rp+q 均是素数？
输入格式：
输入给出区间的两个端点 0&lt;m&lt;n≤1000，其间以空格分隔。
输出格式：
在一行中输出满足条件的素数三元组的个数。
输入样例：
1 35 输出样例：
10 样例解读
满足条件的 10 组解为：
2, 3, 5 2, 3, 7 2, 3, 13 2, 3, 17 2, 5, 7 2, 5, 13 2, 5, 19 2, 5, 31 2, 7, 23 2, 13, 17 运行超时
#include&lt;stdio.h&gt; int isPrime(int n) { if(n&lt;2) return 0; for(int i=2;i*i&lt;=n;i++) { if(n%i==0) return 0; } return 1; } int main() { int m,n,sum=0; scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7409bc541441e07488b2a497c97c5bd8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dbe397247958a4efc82e002a6d7ae165/" rel="bookmark">
			基于51单片机的水塔水位检测自动加水Proteus仿真
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		资料编号：140 下面是相关功能视频演示：
132-基于51单片机的水塔水位检测自动加水Proteus仿真（源码+仿真+全套资料）
功能讲解：
1.可以通过按键设置当前的水位
2.如果是低水位（水位1），则启动电机进行抽水
3.按下水满按键，代表水已经抽慢，抽水电机自动停止
4.数码管显示当前水位状态
全套资料齐全：
下面是该程序部分展示：
main()
{
P0=0;
while(1)
{ if(shuiman==0&amp;&amp;sw5==1&amp;&amp;sw4==1&amp;&amp;sw3==1&amp;&amp;sw2==1&amp;&amp;sw1==1)//当唯一的闭合一个传感器单元:水位6时发生
{
dianji=1;//关电机
state=1;//电机工作指示灯熄灭
P0=table[6];//显示水位深度:6**** 已满
delay02s();//延时一段时间让数码管显示给人以提示：水已满
}
//水位5
if(shuiman==1&amp;&amp;sw5==0&amp;&amp;sw4==1&amp;&amp;sw3==1&amp;&amp;sw2==1&amp;&amp;sw1==1)//当唯一的闭合一个传感器单元:水位5时发生
{
P0=table[5];//显示水位深度:5
}
//水位4
if(shuiman==1&amp;&amp;sw5==1&amp;&amp;sw4==0&amp;&amp;sw3==1&amp;&amp;sw2==1&amp;&amp;sw1==1)//当唯一的闭合一个传感器单元:水位4时发生
{
P0=table[4];//显示水位深度:4
}
//水位3
if(shuiman==1&amp;&amp;sw5==1&amp;&amp;sw4==1&amp;&amp;sw3==0&amp;&amp;sw2==1&amp;&amp;sw1==1)//当唯一的闭合一个传感器单元:水位3时发生
{
P0=table[3];//显示水位深度:5
}
//水位2
if(shuiman==1&amp;&amp;sw5==1&amp;&amp;sw4==1&amp;&amp;sw3==1&amp;&amp;sw2==0&amp;&amp;sw1==1)//当唯一的闭合一个传感器单元:水位2时发生
{
P0=table[2];//显示水位深度:2
}
//水位低
if(shuiman==1&amp;&amp;sw5==1&amp;&amp;sw4==1&amp;&amp;sw3==1&amp;&amp;sw2==1&amp;&amp;sw1==0)//当唯一的闭合一个传感器单元:水位1时发生
{
dianji=0;//开电机
state=0;//电机工作指示灯打开
P0=table[1];//显示水位深度:1
}
//手工上水
if(shougong==0)//当按手工上水按钮时发生
{ dianji=0;//开电机
state=0;//电机工作指示灯打开
P0=table[0];//显示0表示手工上水已有反应
delay02s();//延时一段时间让数码管显示给人以提示：已开始手工上水
}
}
} 下面是该资料的分享下载链接：
https://pan.baidu.com/s/1FXnVCnopLCQVkDuAQRD8gA?pwd=nmc4
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51641b09c20dd5ed9a48ebdc70998421/" rel="bookmark">
			基于stm32单片机的矩阵键盘按键检测显示Proteus仿真
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		资料编号：140 下面是相关功能视频演示：
140-基于stm32单片机的矩阵键盘按键检测显示Proteus仿真（源码+仿真+全套资料）
功能介绍：该仿真采用stm32单片机，使用Proteus8.9版本进行仿真，采用矩阵键盘进行输入，数码管进行显示，将按键按下的数值显示到数码管上，采用了矩阵键盘扫描检测，下面是该设计的仿真截图：
下面是对程序讲解：
数码管段选：
u8 DSY_CODE[]={0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90};
下面是延时函数：
void delay1ms(unsigned int n)
{
unsigned int i,j;
for(i=0;i&lt;n;i++)
{
for(j=0;j&lt;123;j++);
}
}
下面是该程序的主函数：
int main(void)
{
u16 KeyNum=0;
KEY_Init(); //初始化与LCD连接的硬件接口
SEG_Init();
while(GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_4)||GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_5)||GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_6)||GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_7)==0)
{ KeyNum=keyscan();
GPIO_Write(GPIOA,DSY_CODE[KeyNum%10]);
GPIO_Write(GPIOC,DSY_CODE[KeyNum/10]);
delay1ms(20);
}
}
下面是按键的初始化函数，用来初始化按键：采用switch语句进行识别判断：
void KEY_Init()
{ GPIO_InitTypeDef GPIO_InitStructer;
RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);
GPIO_InitStructer.GPIO_Pin=GPIO_Pin_4|GPIO_Pin_5|GPIO_Pin_6|GPIO_Pin_7;
GPIO_InitStructer.GPIO_Mode=GPIO_Mode_IPU;
GPIO_Init(GPIOB, &amp;GPIO_InitStructer);
GPIO_InitStructer.GPIO_Pin=GPIO_Pin_0|GPIO_Pin_1|GPIO_Pin_2|GPIO_Pin_3;
GPIO_InitStructer.GPIO_Mode=GPIO_Mode_Out_PP;
GPIO_InitStructer.GPIO_Speed=GPIO_Speed_50MHz;
GPIO_Init(GPIOB, &amp;GPIO_InitStructer);
}
下面是矩阵键盘的检测函数：
u8 keyscan(void)
{
u16 temp,num;
GPIO_Write(GPIOB,0xf0);
while(1)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/51641b09c20dd5ed9a48ebdc70998421/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9db7589ab3128360a2ac26f8364a5845/" rel="bookmark">
			【微信小程序】scroll-view滚动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.竖向滚动 wxml文件
&lt;!--pages/list/index.wxml--&gt; &lt;scroll-view class="container1" scroll-y&gt; &lt;view&gt;A&lt;/view&gt; &lt;view&gt;B&lt;/view&gt; &lt;view&gt;C&lt;/view&gt; &lt;/scroll-view&gt; wxss文件
/* pages/list/index.wxss */ .container1 view{ display: inline-block; width:100px; height:100px; text-align: center; line-height: 100px; } .container1 view:nth-child(1){ background-color: lightblue; } .container1 view:nth-child(2){ background-color: lightcoral; } .container1 view:nth-child(3){ background-color: lightgreen; } .container1{ border: 1px solid red; width: 100px; height: 120px; } 2.横向滚动 wxml文件
&lt;!--pages/list/index.wxml--&gt; &lt;scroll-view class="container1" scroll-x&gt; &lt;view&gt;A&lt;/view&gt; &lt;view&gt;B&lt;/view&gt; &lt;view&gt;C&lt;/view&gt; &lt;/scroll-view&gt; wxss文件
/* pages/list/index.wxss */ .container1 view{ display: inline-block; width:100px; height:100px; text-align: center; line-height: 100px; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9db7589ab3128360a2ac26f8364a5845/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12276d04bc52ffcd29f7689248a21209/" rel="bookmark">
			Flutter 如何使用在线转码工具将 JSON 转为 Model
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		国内大佬CrazyCodeBoy提供的工具：
JSON 转Dart - CrazyCodeBoy的技术博客官网|CrazyCodeBoy|Devio|专注移动技术开发(Android&amp;IOS)、Flutter开发、Flutter教程、React Native开发、React Native教程、React Native博客
支持空安全的有：
JSON to Dart
Json To Dart Model
正文开始。
目标 json:
{ "posts": [ { "id": "0", "created": 1590453935992, "content": "提供基于GraphQL API的数据查询及访问,「Hasura」获990万美元A轮..." }, { "id": "1", "created": 1590453935992, "content": "为什么GraphQL是API的未来" }, { "id": "2", "created": 1590453935992, "content": "Netflix:我们为什么要将 GraphQL 引入前端架构?" } ] } 打开 quicktype 网站（可能需要科学访问网络）：Instantly parse JSON in any language | quicktype
点击右上角 Options 按钮，并作如下配置：
粘贴 JSON 到输入框中，并在左上角输入模型名称 PostsData：
右侧会自动生成模型：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/12276d04bc52ffcd29f7689248a21209/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73744229cab1e62e455ee20def29d010/" rel="bookmark">
			Oracle SQL Developer 设置ID自增长（通过UI设置&amp;执行脚本）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Oracle实现ID自增长需要三个步骤： 1）首先创建表并设定主键； 2）创建序列（即：定义一个增长逻辑）； 3）创建触发器并启动（即：将增长逻辑与列绑定，并说明何时触发增长逻辑，最后让绑定生效）。 一、通过Developer的UI设定 1.创建表并设定ID主键 CREATE TABLE "SAP_APP_COMM_T" ( "ID" NUMBER, "BASE_KEY" VARCHAR2(50 BYTE), "BASE_NAME" VARCHAR2(100 BYTE), "BASE_DESC" VARCHAR2(50 BYTE), "BASE_TYPE" VARCHAR2(50 BYTE), "BASE_SON" VARCHAR2(50 BYTE), "DATA_TYPE" VARCHAR2(10 BYTE), CONSTRAINT "SAP_APP_COMM_T_PK" PRIMARY KEY ("ID") ) 2.创建序列 （1）序列文件夹 → 右键 新建序列；
（2）选择用户，填写序列名称，增长的初始值，最大值，递增值，递增方式，排序等。
3.创建触发器并启动 （1）在表名上右击 → 触发器 → 创建序列的主索引建；
（2） 依次填好触发器名称、序列名和列名；
（3） 选择表，右键-&gt;触发器-&gt;全部启动。
至此，ID自增长设置完成。
二、通过脚本设置自增ID 1.首先建表並設置主鍵 CREATE TABLE "JG_OPERATION_LOG_T" ( "ID" NUMBER(10,0), "FORM_TYPE" VARCHAR2(10 BYTE), "PROD_GROUP" VARCHAR2(40 BYTE), "PROD_LOCALE" VARCHAR2(40 BYTE), "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/73744229cab1e62e455ee20def29d010/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f42c3f77a19f11d7ca74425762cadf13/" rel="bookmark">
			python例题（05）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.输入一个十进制数，输出二进制、八进制、十六进制 a = int(input('请输入一个十进制整数:')) print(a,'转化的二进制为',bin(a)) print(a,'转化的八进制为',oct(a)) print(a,'转化的十六进制为',hex(a)) # 请输入一个十进制整数:12 # 12 转化的二进制为 0b1100 # 12 转化的八进制为 0o14 # 12 转化的十六进制为 0xc 2.输入华氏温度，输出摄氏温度，公式为：C=5/9*（F-32） f=int(input('请输入华氏温度:')) c=5/9*(f-32) print('摄氏温度为%.2f'%c) # 请输入华氏温度:75 # 摄氏温度为23.89 3.键盘输入两个整数a和b，合并成一个新四位数，例如：a=54,b=12,c=5142 a=int(input('请输入一个两位数整数：')) b=int(input('请输入一个两位数整数：')) if a&gt;=100 and b&gt;=100: print('输入数据有误，请重新输入！') elif a&lt;=10 and b&lt;=10: print('输入数据有误，请重新输入！') else: c=a//10*1000+b//10*100+a%10*10+b%10 print('合成的新四位数为：',c) # 请输入一个两位数整数：54 # 请输入一个两位数整数：12 # 合成的新四位数为： 5142 4.发工资遇到一个问题，根据每个人工资总额计算钞票面值的张数，且总张数最少。如：15896 a=int(input('请输入你的工资总额：')) print('100元的张数为：',a//100) print('50元的张数为：',a%100//50) print('20元的张数为：',a%100%50//20) print('10元的张数为：',a%100%50%20//10) print('5元的张数为：',a%100%50%20%10//5) print('1元的张数为：',a%100%50%20%10%5) # 请输入你的工资总额：15896 # 100元的张数为： 158 # 50元的张数为： 1 # 20元的张数为： 2 # 10元的张数为： 0 # 5元的张数为： 1 # 1元的张数为： 1 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f42c3f77a19f11d7ca74425762cadf13/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e6c532cbe726d02b0fd1f1e2e075a79/" rel="bookmark">
			Android 9 系统设置中添加以太网开关按钮
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android 9 系统设置中添加以太网开关按钮
本章突出新手可以简单快速实现该需求。（具体以太网流程自行百度）
首先在系统Settings设置选项中添加选项。（该部分逻辑以及如何在获取设置按钮的开关状态，不在这里介绍，过往有做过介绍）
这里采用广播的方式通知framework层去开关以太网。
Android P 对广播做了保护
因此我们需要在/frameworks/base/core/res/AndroidManifest.xml中定义我们的广播
广播名称可以随意定义，注意勿重复！
&lt;protected-broadcast android:name="android.eth0.power.status" /&gt; 接着就是最关键部分
frameworks/opt/net/ethernet/java/com/android/server/ethernet/EthernetTracker.java
先看代码：
package com.android.server.ethernet; ... final class EthernetTracker { private final static String TAG = EthernetTracker.class.getSimpleName(); private final static boolean DBG = EthernetNetworkFactory.DBG; /** Product-dependent regular expression of interface names we track. */ private final String mIfaceMatch; /** Mapping between {iface name | mac address} -&gt; {NetworkCapabilities} */ private final ConcurrentHashMap&lt;String, NetworkCapabilities&gt; mNetworkCapabilities = new ConcurrentHashMap&lt;&gt;(); private final ConcurrentHashMap&lt;String, IpConfiguration&gt; mIpConfigurations = new ConcurrentHashMap&lt;&gt;(); private final INetworkManagementService mNMService; private final Handler mHandler; private final EthernetNetworkFactory mFactory; private final EthernetConfigStore mConfigStore; private final RemoteCallbackList&lt;IEthernetServiceListener&gt; mListeners = new RemoteCallbackList&lt;&gt;(); private volatile IpConfiguration mIpConfigForDefaultInterface; + private Context mContext; + String eth0Action = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e6c532cbe726d02b0fd1f1e2e075a79/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d74d868f40e824b8e7aca72600bc2566/" rel="bookmark">
			动态路由协议——OSPF、BGP、RIP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常见的IGP内部网关协议：RIP（端口号UDP５２０）、OSPF（IP协议８９）
常见的EGP外部网关协议：BGP（TCP１７９）
OSPF 3张表、5个包、6个状态
邻居表、LSDB、路由表
init、2-way、exchange-start、exchang、loading、full
1、分类 ospfv2是针对于ipv4的
ospfv3是针对于ipv6的
2、概念 Router-ID是路由器的标识，开启ospf的时候需要指定router-id，router-id格式是IP地址的格式，只是一个名字，并不代表就有这个IP地址
区域
OSPF Area用于标识OSPF的区域，区域是从逻辑上将设备划分为不同的组，每个组用区域号Area ID来标识。
开销
开销cost是路由的度量值，由接口带宽决定，cost=10^8/带宽，相当于1Gbps/带宽。cost越小越优。
3、OSPF工作原理 五个包 报文名称
报文功能
hello包
用于发现和维护邻居关系，定期发送
Database Description（DBD包）
描述本地LSDB链路状态数据库的摘要信息，用于两台设备进行数据库同步
LSDB即所有LSA链路状态信息的集合
先发送LSDB摘要信息获取自己缺少的路由信息，再通过LSA去发送对方没有的路由信息
Link State Request （LSR）
用于向对方请求所需要的LSA，设备只有在OSPF邻居双方交换DD报文之后才会向对方发出LSR报文
Link State Update （LSU）
用于向对方发送其所需要的LSA
Link State ACK
用来对收到的LSA进行确认
先发送hello包建立邻居关系（形成邻居表）；发送DBD包同步LSDB链路状态数据库信息；发送LSR链路状态请求包向对方请求自己没有的LAS；发送LSU链路状态更新信息向对方发送所需要的LAS（LSDB）；最后发送LAS确认信息，确认已收到对方发送的LSA。（路由表）
邻居关系建立过程
R1、R2
首先R1发送hello包，R2收到之后把R1 加入到自己的邻居表中状态标记为init；R2发送hello包告诉R1 自己已经知道R1 是自己的邻居，此时R1 将R2 加入到邻居表中状态为2-way；R1 发送hello包告诉R2自己已经知道R2是自己的邻居，此时R2把状态改为2-way。
邻居关系建立完成之后，建立邻接关系
exchang-start状态选主从；exchange状态发送带有LSA摘要信息的DBD包；loading状态发送LSR、LSU、LSACK；数据库同步完毕之后达到full状态
七个状态 DR和BDR，只需要找DR进行LSDB进行同步
选举：优先级；优先级一样，就比较router-id ，越大越优先。
选举结束后：当网络中加入一个更高优先级的路由器，处于稳定性考虑，此时它 只能成为非指定路由器；当DR失效时，BDR立刻成为新的DR，非指定路由器竞争成为新的BDR。
４、邻居关系无法建立的原因 router　id一致：每台路由器的router　id需要不一致area　id不一致：同一网段的所有端口应当配置在同一区域网络接口类型不一致：hello和hellodown的时间需要一致路由器掩码不一致同一区域的验证类型不一致、验证码不一致 ５、单区域存在的问题 LSDB庞大，SPF计算开销大；
LSA洪泛范围大，拓扑变化影响范围大；
路由表庞大，不能汇总。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d74d868f40e824b8e7aca72600bc2566/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43647ff8ee1ad5fd04516dfa1a7cacc9/" rel="bookmark">
			OSPF建立不起来的原因
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、邻居建立不起来，导致ospf建立不起来 邻居建立和Hello包有关，所以我们要看看Hello包里有什么东东会影响邻居建立。
a、Route ID一致。Route ID是唯一的，所以Route ID一致会导致邻居建立不成功
b、area ID不一致。
c、认证方式不一致。（不需要认证、明文认证、密文认证）
d、认证密码不一致。
e、掩码不一致
f、Hello time和Dead time不一致
其他原因：
g、接口链路故障，或者接口没有启用OSPF，导致接口收不到对端发送的Hello报文。
h、网络类型不一致（比如一边是P2P对等网络，一边是Broadcast广播；hello报文里没有网络类型这个字段，但是两边网络类型不一致有可能Hello time一致，也会有影响，有一种特例，如果Hello time时间一致，则可以建立邻居，但是接口类型不一致会导致学不到路由信息）
Cisico路由器可以使用show ip ospf interface f0/0查看f0/0的ospf接口信息
i、区域类型不一致（特殊区域和非特殊区域）
j、接口加入了静默接口（静默（被动）接口不会发送Hello报文，简单来说就是路由器连接PC的接口，PC不需要收到路由器发送的hello包等数据包，所以为了优化链路带宽，就可以将这个接口配置为静默（被动）接口）
2、OSPF邻居卡在不同的邻居状态 （1）init状态
什么情况状态一直处于init状态？
不发送Hello报文；接收不到Hello报文（ACL访问控制过滤了OSPF报文）。
R1给R2发送Hello包，但是R2一直不给R1发送Hello包，所以对于R1 来说就不认识R2 ，就会认为R2一直处于init状态。
如果想要R2状态处于init状态，那么R2 不发送Hello包给R1 即可；或者配置R1不接收R2发送的Hello报文，可以做ACL过滤。
（2）2-way状态
当接口优先级为0的时候不进行DR和BDR的选举，DRother之间处于2-way状态
Cisico路由器修改接口优先级ip ospf priority 0
（3）Exstart/Exchange状态
Exstart状态发送的DD报文不包含LSA摘要信息，这个状态是选主从的；exchange状态发送的DBD报文包含LSA摘要信息。
Exstart/Exchange状态交互DBD报文，在Exstart状态会进行MTU的检查。Cisico设备默认会检查，华为设备默认不检查，所以值为0。Cisico可以使用ip ospf mtu-ignore忽略MTU检查。
Cisico重新启动OSPF进程R1#clear ip ospf 1 process 修改接口的mtu：R1(config-if)#ip mtu 1300
三种情况：
1、两端的MTU不一致，任意一方开启了MTU检测，可以正常进入FULL状态。
因为不开启MTU检查的一端收到对端发送的DBD报文后会直接忽略MTU检查直接接收报文，MTU向小兼容，如图：假设R5开启了MTU检查，R4不开，R4的DBD报文发送给R5的时候检查MTU值大小，本端MTU值大于对端兼容收下数据包，R5发送DBD给R4，MTU虽然大于R4，但是R4不对MTU进行检查，所以收下数据包，两端进入exstart状态。DBR-R5发送带有LSA摘要的DBD报文给DR-R4，收下，都进入exchange状态。进入loading状态，交换路由更新信息，进入FULL状态。
2、两端都开启MTU检测
（1）、从设备的MTU大于主设备情况，主设备处于exchange状态，备设备处于exstart状态。
因为交互完DBD报文之后都进入了exstart状态，从设备给主设备发送DBD报文，从设备状态变为exchange，而主设备MTU比较小，MTU检查不通过，只能丢弃这个包，主设备无法进入exchange状态。
（2）、从设备的MTU小于主设备，两者都处于exstart状态。
两边都可以发送DBD选举主从进入exstart状态，但是从设备的MTU小，从设备接收不到主设备发送的第一个DBD报文，也就不会发送带有LSA摘要信息的DBD给主设备，也就无法进入exchange状态。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/677f942c77c5055b04fa1372a79924c0/" rel="bookmark">
			容器数据卷
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		容器数据卷的作用 可以把容器内的数据备份+持久化到本地主机目录，完全独立于容器的生存周期，docker不会在容器删除时删除其挂载的数据卷。
命令格式 docker run -it --privileged=true -v /宿主机绝对路径目录:/容器内目录 镜像名或镜像ID
#需要加--privileged=true 这个参数，不然可能会报权限错误 docker run -it --privileged=true -v /宿主机绝对路径目录:/容器内目录 镜像名或镜像ID 案例： docker run -it --privileged=true -v /tmp/host_data:/tmp/docker_data ubuntu /bin/bash # /host_data是宿主机上要存放数据的目录，docker_data是容器内存放数据的目录，执行命令时如果没有目录会自动生成这两个目录 #在容器内新建文件 cd /tmp/docker_data touch docker.txt #这时ctrl+q+p退出容器, 打开宿主机的/tmp/host_data目录，里面会自动同步了docker.txt文件 cd /tmp/host_data ls #又在宿主机的/tmp/host_data目录创建一个文件，也会自动同步到容器的/tmp/docker_data目录 echo "hello world" &gt; a.txt #把ubuntu容器停止，再启动，数据还是能成功同步回来 docker stop ubuntu的容器ID docker start ubuntu的容器ID 限制容器只能读取不能写入：
docker run -it --privileged=true -v /tmp/host_data:/tmp/docker_data:ro ubuntu # 这里的ro是read-only，容器内的目录被限制了，无法写入东西，宿主机是可以正常写的，一般是默认可读可写 容器数据卷间的继承 命令格式：
docker run -it --privileged=true --volumes-from 父类 容器名/ID #父类是要继承的容器的名字或ID
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/677f942c77c5055b04fa1372a79924c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f516d69cad9bedaf736f51afe2b8e403/" rel="bookmark">
			Jmeter接口测试（三）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.Jmeter通过非配置元件代理服务器创建接口测试脚本 2.Jmeter中的Bean Shell组件以及相关的语言详解
3.Jmeter执行数据库断言操作
4.Jmeter非GUI命令行执行方式和常用命令详解
5.Jmeter+Ant+Jenkins实现接口自动化持续集成
一、当没有接口文档时,如何使用Jmeter录制和创建脚本 1.抓包
2.badboy
3. jmeter自带的http代理服务器
(1)新建线程组
(2)新建代理服务器测试计划-&gt;非配置元件-&gt;代理服务器
端口: 8888
目标控制器:设置为你录制的目标线程组。
Type：默认httpclient4
(3)点击[启动]按钮,运行代理服务器。
(4)客户端设置:让客户端的请求通过代理服务器发送。
在控制面板-Internet选项-连接-局域网配置
4.调试接口测试脚本
二、Jmeter执行数据库操作 1、引入数据库的驱动jar包
放到jmeter/lib目录下
2、新建JDBC connection configuration
连接池？最大设置多少个连接
自动提交
事务隔离级别
是否立即初始化连接池
3、新建JDBC Request
4、使用
三、Jmeter非GUI命令详解 1、-n 使用非ui方式，不能单独用，必须和-t（指定jmeter的脚本）一起用
jmeter -n -t test.jmx
只会生成一个log日志文件，没有任何报告输出
2、-l 生成jtl格式的报告
注意：修改jmeter.properties配置文件
jmeter.save.saveservice.output_format=xml
jmeter.save.saveservice.response_data=true
jmeter.save.saveservice.samplerData=true
3、-e 生成html报告，不能单独用，一般和-o（输出一起用）
注意：修改jmeter.properties配置文件
jmeter.save.saveservice.output_format=csv
四、jmeter+ant+jenkins 1、下载ant并且解压，并且配置如下环境变量到path路径
2、配置build.xml，执行并构建的报告
然后放到和jmx文件同级的目录。
3、配置jmeter.properties文件
jmeter.save.saveservice.output_format=xml
4、在dos里面执行如下命令
ant
有工具还要做接口自动化
1.MD5,RSA.BASE64,SHA1等等。很多项目都是自定义加密( java加密)
2.签名接口。
3.大型项目都是敏捷开发，项目接口上万,团队协作。版本控制。 4.微服务架构项目。http,webservice.websock,dubbo,thift
5.定位问题。
6.监控接口。
7.生成报告太丑。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f516d69cad9bedaf736f51afe2b8e403/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a8be164b54da9a976c02bc51f9557da/" rel="bookmark">
			小程序轮播图实时更新
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于小程序轮播图实时更新不借助webSocket来实现，为你们提供以下思路 博主就是这样搞得已经实现很好用
1. 关于轮播图后台肯定有维护页面也就是说和后端商量好，如果后台新增、修改、删除了某个轮播图，小程序调用列表接口的时候返回一个时间戳
2. 小程序这边在onshow的生命周期里面调用轮播图列表函数，定义一个变量来保存这个时间戳
3.每次请求根据这个时间戳的变化来决定要不要更新数据
4. 这样做的好处是 如果每次调接口都更新数据 会导致页面渲染很慢 图片会有空白时间很难看，这样就解决了每次调接口按照后台的更新来更是小程序的数据
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c02db9bb4c505e3bc588f049aae2dfa/" rel="bookmark">
			原生JS实现页面滚动到底部时自动加载数据效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在我们日常开发中为了避免一次性数据加载量过大，而导致页面加载缓慢，运行卡顿。通常会使用懒加载进行按需加载，在提高项目运行流畅度的同时也可以增加用户体验。懒加载有很多场景很多方式，那么今天就教大家如何一个原生js实现页面懒加载的方式，也就是当滚动到页面最底部时会触发回调去请求数据。
当原生的理解后，对于我们后续使用框架开发的遇到类似情况也会更加容易变通和实现。
看代码
引入Axios
&lt;script src="https://cdn.bootcdn.net/ajax/libs/axios/1.1.3/axios.min.js"&gt;&lt;/script&gt; CSS部分
&lt;style&gt; * { padding: 0; margin: 0 auto; list-style: none; transition: all 0.5s ease; } body { background-color: #475164; background-image: url(http://zhongguose.com/img/texture.png); padding-bottom: 50px; } h2 { text-align: center; margin: 20px 0; } .row { width: 1290px; } .list_contrant { width: 100%; overflow: hidden; } .cidPage_Separate { width: 300px; height: 400px; /* background-color: aqua; */ background-color: white; margin-right: 30px; margin-bottom: 30px; border-radius: 10px; padding: 0 15px; box-sizing: border-box; float: left; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c02db9bb4c505e3bc588f049aae2dfa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ceae1e0e1f66e7acce8178a028f4c7a1/" rel="bookmark">
			SpringBoot&#43;Vue使用WebSocket
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一:什么是Websocket?
WebSocket是HTML5下一种新的协议（websocket协议本质上是一个基于tcp的协议）它实现了浏览器与服务器全双工通信，能更好的节省服务器资源和带宽并达到实时通讯的目的Websocket是一个持久化的协议 二:websocket的原理
1.websocket约定了一个通信的规范，通过一个握手的机制，客户端和服务器之间能建立一个 类似tcp的连接，从而方便它们之间的通信,在websocket出现之前，web交互一般是基于http 协议的短连接或者长连接
2.websocket是一种全新的协议，不属于http无状态协议，协议名为"ws"
三:后端代码
1.导入maven
&lt;!--WebSocket--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt; &lt;/dependency&gt; 2.配置Config
import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.web.socket.server.standard.ServerEndpointExporter; /** * @Author: 海绵宝宝 * @Explain: 开启webSocket 在线测试地址：http://www.websocket-test.com/ * @DateTime: 2022/5/29 15:54 * @Params: * @Return */ @Configuration public class WebSocketConfig { @Bean public ServerEndpointExporter serverEndpointExporter(){ return new ServerEndpointExporter(); } } 3.配置Server
import com.alibaba.fastjson.JSON; import com.alibaba.fastjson.JSONObject; import lombok.extern.slf4j.Slf4j; import org.apache.commons.lang3.StringUtils; import org.springframework.stereotype.Component; import javax.websocket.*; import javax.websocket.server.PathParam; import javax.websocket.server.ServerEndpoint; import java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ceae1e0e1f66e7acce8178a028f4c7a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7fa8b86df0505a673983a93c16cc237/" rel="bookmark">
			数据异动思维模式（各行业形式）Continuous Updating...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		持续更新各行业的数据异动思维模式，思维模式都是看各类文章+个人理解总结。欢迎大家也一起来分享经验~(后有思维导图）
目录
GMV下降了怎么办
DAU、MAU异动怎么办
GMV下降了怎么办 1 首先是观察是否是端口问题，导致的GMV出现下降显示 数据暂时性波动数据周期性波动 2 端口没有问题，那就回归到GMV指标的拆解 指标拆解 GMV=UV*CVR*CPT客单价 维度拆解——人货场 A 人 用户类型 新老用户比例和新老用户转化形式B 货 品类价位 高端、中端、低端供应链C 场 区域/地区 国家/省份时间 访问时段/产品周期性平台 Ios/Android/PC版本 平台新老版本行业整体表现 3 结合2的拆解流程，回到归因分析上 外部 政策天气社会竞争者 更新迭代经济 内部 产品侧 类目选品功能迭代转化模块运营侧 推广投放活动运营用户运营策略 促活方式、引导方式、文案创意技术侧 页面bug接口不稳定系统故障 DAU、MAU异动怎么办 1 首先还是要观察数据波动性问题，20%以上属于比较大的数据波动，如果每日数据持续波动，可做同期群分析表 数据暂时性波动数据周期性波动 2 接下来就开始划分维度分析 用户分析 国家/地区 国家B 投放量影响地区地方政策影响区域运营策略影响新老用户 新用户 投放渠道 渠道A 投放预算投放人群定向渠道平台问题老用户 分析用户特征 用户生命周期分析user journey模型分析分析新版产品、bug影响 运营分析 Continuous Updating....
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d660acd7aae2a9b8fdff05b3aae88517/" rel="bookmark">
			PHP 一句话木马 @eval($_POST[‘hack‘])； 语句解析及靶机演示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一句话木马如下，利用文件上传漏洞，往目标网站上传该木马，即可获取和控制整个网站主机目录
&lt;?php @eval($_POST['hack']); ?&gt; 语句解析 @符号 @符号表示后面的语句即使执行错误，也不报错。
eval()函数 eval()函数的作用是把括号内的字符串全部当作php代码来执行。
$_POST['hack'] post方法是html中&lt;form&gt;标签中的方法，在页面中，所有的POST方法都会由submit输入方式向action中的php文件返还信息，通常这样的php文件是连着着数据库的，甚至可以直接对文件进行操作。当使用&lt;form&gt;标签的post方法时候，同时&lt;form&gt;标签里面的name属性等于hack
例如：
&lt;form action="mm.php" name="hack" method="post"&gt; 会在php文件中产生一个$_POST[cmd]变量，变量中储存有用户提交的数据。
利用原理 当用户输入phpinfo();
那么$_POST[hack]变量便会变成"phpinfo();"这个字符串
eval()函数配合$_POST变量输入的字符串来执行php语句，就可以达到操作数据库和服务器的效果
靶机演示 我们找一道简单的CTF文件上传题目做一下
可以看到本题目很简单明了，写上了“无限制”，这道题用来演示该木马正好，不用进行隐写和免杀等操作，我们直接上传该木马
上传成功后可以看到页面回显了上传文件的路径
然后我们打开“中国蚁剑”进行连接
连接密码即为传入$_POST['hack'] 内的值“hack”
连接成功后即可看到如下信息
打开该连接，我们看到了整个网站主机的结构和文件，甚至可以进行任意非法增删查改操作，至此可以说该主机已经被我们掌控了
在网站主页同目录下，我们找到了本题的flag文件
打开该文件，即可拿到我们需要的flag
以上便是对该木马的简单使用做的一个演示
在实际使用中，我们面对的防御者通常还会对文件类型、大小进行过滤，还会有管理员对木马进行查杀等，所以在实际运用中，我们还得进行更多其他的操作
本篇文章到这里就结束了，如果感兴趣的话可以自行去了解相关的知识
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1db4c37ce4898942b23721079a6ee16a/" rel="bookmark">
			【FPGA】五、蜂鸣器播放音乐
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录
前言
一、蜂鸣器简介
二、音频音符简介
三、任务要求
四、程序设计
1、设计思路
2、程序代码 总结
前言 蜂鸣器（Buzzer）是现代常用的一种电子发声器，主要用于产生声音信号。它是一种一体化结构的电子讯响器，采用直流电压供电，被广泛用于计算机、报警器、电子玩具、定时器等一些列电子产品中。
一、蜂鸣器简介 蜂鸣器按照其驱动方式不同主要分为有源蜂鸣器和无源蜂鸣器，两者的主要区别为蜂鸣器内部是否还有振荡源。一般有源蜂鸣器内部自带振荡源，通电就会发声，而无源蜂鸣器内部不含振荡源，需要外接振荡信号才能发声。
相较于有源蜂鸣器，无源蜂鸣器的成本较低，而我们FPGA开发板上的蜂鸣器一般都是无源蜂鸣器，需要我们对其进行编程配置，我们利用不同的频率变化，控制蜂鸣器发出不同音调的声音。
二、音频音符简介 我们是通过不同的频率去控制蜂鸣器的音调变化的，所以我们想要使蜂鸣器播放音乐，首先我们要直到不同音符所对应的频率，下面是低、中、高音下不同音符的频率对应表：
根据上图可以计算出不同音符振动的周期，我所采用的Cyclong IV开发板上的晶振时钟为50MHZ，每一个周期就是20ns。那么每个音调的分频系数为：50 000 000 / 音调频率（可四舍五入）。
三、任务要求 本次设计的要求就是利用FPGA开发板上的无源蜂鸣器，通过不同振动频率播放歌曲两只老虎。
四、程序设计 1、设计思路 ① 首先我们需要计算出每个不同的音符对应的分频系数，由此产生不同的音调，我们需要设计一个分频计数器，来计数当前发出音调的分频系数。
② 然后我们需要一个节拍计数器，我们定义为半拍300ms，一拍500ms。
③ 利用组合逻辑case语句进行设计，将需要的节拍和要发出的音调写入case语句中。
2、程序代码 /*========================================* filename : beep_music.v description : 无源蜂鸣器播放音乐实验 time : 2022-11-010 author : 卡夫卡与海 *========================================*/ module beep_music( input clk ,//系统时钟 50MHZ input rst_n ,//系统复位 output reg beep //蜂鸣器控制信号 ); //参数定义 //每个音符震动一次所占用的时钟周期 //低音 parameter MIN_DO = 18'd190800,//(50_000_000/262) MIN_RE = 18'd170050,//(50_000_000/294) MIN_MI = 18'd151500,//(50_000_000/330) MIN_FA = 18'd143250,//(50_000_000/349) MIN_SO = 18'd127550,//(50_000_000/392) MIN_LA = 18'd113600,//(50_000_000/440) MIN_XI = 18'd101200;//(50_000_000/494) //中音 parameter MID_DO = 17'd95600,//(50_000_000/523) MID_RE = 17'd85150,//(50_000_000/587) MID_MI = 17'd75850,//(50_000_000/659) MID_FA = 17'd71600,//(50_000_000/698) MID_SO = 17'd63750,//(50_000_000/784) MID_LA = 17'd56800,//(50_000_000/880) MID_XI = 17'd50600;//(50_000_000/988) //高音 parameter MAX_DO = 16'd47755,//(50_000_000/1047) MAX_RE = 16'd42553,//(50_000_000/1175) MAX_MI = 16'd37907,//(50_000_000/1319) MAX_FA = 16'd35790,//(50_000_000/1397) MAX_SO = 16'd31887,//(50_000_000/1568) MAX_LA = 16'd28409,//(50_000_000/1760) MAX_XI = 16'd25419;//(50_000_000/1967) parameter TIME_300ms = 24'd14_999_999,//300ms,半拍 TIME_500ms = 25'd24_999_999;//500ms,一拍 parameter NOTE_NUM = 6'd33;//音符个数 34个 //信号定义 reg [24:0] cnt_delay ;//300ms或500ms计数器 reg [5:0] cnt_note ;//音符计数器 reg [18:0] cnt_freq ;//音符播放计数器 reg [18:0] freq_data ;//音符数据寄存器 wire [17:0] duty_data ;//占空比 wire end_note ;//单个音符播放结束标志 wire end_flag ;//所有音符结束标志 reg [24:0] cnt_delay_r ; reg flag ;//蜂鸣器输出标志 //300ms计数器 cnt_delay always @(posedge clk or negedge rst_n)begin if(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1db4c37ce4898942b23721079a6ee16a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c130f9fd79fc97452a9b549797b718b7/" rel="bookmark">
			uniapp开发微信小程序生成二维码海报
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;template&gt; &lt;view&gt; &lt;button @click="open"&gt;&lt;/button&gt; &lt;view class="canvasPop" v-if="canvasPopBool" style="z-index: 9999999;"&gt; //关闭按钮 &lt;uni-icons class="close" type="close" size="30" @click="canvasPopBool=false"&gt;&lt;/uni-icons&gt; //uniapp自带的组件 canvas-id是组件的标识符 画布组件 &lt;canvas canvas-id="firstCanvas" id="firstCanvas"&gt;&lt;/canvas&gt; &lt;view class="btn" @click="saveCanvasFn"&gt;保存图片&lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;/template&gt; &lt;script&gt; export default { data():{ return{ canvasPopBool:false } }, methods:{ open:{ this.canvasPopBool=true const obj={ imgUrl: this.baseUrl + this.bannerList[0].fileUrl, //内容图片地址 title: this.routeItem.name,//内容 标题 str: 'money', price:this.routeItem.consumeAmount, //金额 } this.poster(obj) }, //生成海报方法 poster(obj){ let context = uni.createCanvasContext('firstCanvas'); //获取到画布组件的唯一标识符ID //下面两行代码获取到背景图片地址（后端返给存在了本地存储）	let allImg = uni.getStorageSync('allImg'); let newUrl = allImg.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c130f9fd79fc97452a9b549797b718b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a00910202999a57e577058ab63b852d/" rel="bookmark">
			python操作ffmpeg来合成视频
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一，音频处理 1.提取音频 一、从原有视频提取音频
ffmpeg -i video原版.mp4 -vn audio提取版.mp3 2、截取音频片段 ffmpeg -i input.mp3 -ss hh:mm:ss -t hh:mm:ss -acodec copy output.mp3 参数说明：
-ss : 指定从那裡开始
-t : 指定到那裡结束
-acodec copy : 编码格式和来源档桉相同（就是mp3）
3.将m4a转wav ffmpeg -i input.m4a -acodec pcm_s16le -ac 2 -ar 16000 output.wav -ar 采样率16K
二.合成视频的命令 修该图片名称为00000.jpg_andrew P的博客-CSDN博客
ffmpeg -threads 2 -y -r 8 -i image%06d.jpg 1234.mp4 利用ffmpeg就可以完成这项任务了，下面是具体指令，再附上每个指令的说明：
-threads：线程，这里可以设2个，加快视频生成速度
-y：图片合成视频会有很多个覆盖操作，此处一律同意覆盖
-r：fps，这个是关键，设置多少帧/s，这里我自己设的是8，就是每八张图片合成1s的视频
-i：后接的第一个参数是输入的图片，我的图片都是以image%06d命名的，按自己图片的实际命名排序来设置，最后的是输出视频的格式。image%06d 表示图片名称是以image开头，后面通配6个int类型的数字。
最后1234.MP4是生成的视频的名称
2.将mp4视频和MP3音频合成命令
ffmpeg -i 1.mp3 -i 1.mp4 outputname.mp4 -i ：表示imput,后跟视频/音频
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a00910202999a57e577058ab63b852d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a0e3591e045c5549a50ae45586799fd/" rel="bookmark">
			云原生k8s之Pod基础概念
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、资源限制
二、Pod的两种使用方式
三、Pod资源共享
四、底层容器Pause
1、Pause共享资源
网络
存储
2、Pause主要功能
3、Pod与Pause结构的设计初衷
五、Pod容器的分类
1、基础容器（infrastructure container）
2、初始化容器（init container）
Init 的容器作用
3、应用容器（main container）
六、操作示例
1、编写myapp.yaml
2、myapp.yaml配置资源 3、查看pod创建过程
5、编写myservice.yaml 6、创建myservice.yaml配置资源 7、编写mydb.yaml 8、创建mydb.yaml配置资源 9、chakan myapp-pod创建全过程 10、总结
七、镜像拉取策略（Image PullPolicy）
1、官方示例
2、不指定版本，查看默认拉取策略
3、测试案例（非循环命令） 4、测试案例（循环命令）
一、资源限制 Pod是kuberbetes中最小的资源管理组件，Pod也是最小化运行容器化应用的资源对象。一个Pod代表着集群中运行的一个进程。kubernetes中其他大多数组件都是围绕着Pod来进行支撑和扩展Pod功能的，例如用于管理Pod运行的StatefuSet和Deployment等控制器对象，用于暴露Pod应用的Service和Ingress对象，为Pod提供存储的PersistenVolume存储资源对象等。
二、Pod的两种使用方式 一个Pod中运行一个容器，每个Pod中一个容器的模式是最常见的用法，在这种使用方法中，你可以把Pod想象成是单个容器封装，kubernetes管理的是 Pod而不是直接管理容器。
在一个Pod中同时运行多个容器。一个Pod也可以同时封装吉哥需要紧密耦合互相协作的容器，它们之间共享资源。这些在同一个Pod中的容器可以互相协作成为一个service单位，比如一个容器共享文件，另一个sidecar容器来更新这些文件。Pod将这些容器的存储作为一个实体来管理。
三、Pod资源共享 一个 Pod 下的容器必须运行于同一节点上。**现代容器技术建议一个容器只运行一个进程，该进程在容器中 PID 命令空间中的进程号为 1，可直接接收并处理信号，进程终止时容器生命周期也就结束了。
若想在容器内运行多个进程，需要一个类似Linux操作系统init进程的管控类进程，以树状结构完成多进程的生命周期管理。运行于各自容器内的进程无法直接完成网络通信，这时由于容器间的隔离机制导致，k8s中的Pod资源抽象正是解决此类问题，Pod对象是一组容器的集合，这些容器共享Network，UTS及IPC命令空间，因此具有相同的域名、主机名和网络接口，并可通过IPC直接通信。
namespace功能说明mnt提供磁盘挂载点和文件系统的隔离能力ipc提供进程间通信的隔离能力net提供网络隔离能力uts提供主机名隔离能力pid提供进程隔离能力user提供用户隔离能力 四、底层容器Pause Pod资源中针对各容器提供网络命名空间等共享机制的是底层基础容器pause，基础容器（也可成为父容器）pause就是为了管理Pod容器间的共享操作，这个父容器需要能够准确的知道如何去创建共享运行环境的容器，还能管理这些容器的生命周期。为了实现这个父容器的构想，kubernetes中，用于pause容器来作为一个Pod中所有容器的父容器。这个pause容器有两个核心的功能，一是它提供整个Pod的Linux命名空间的基础。二来启用PID命名空间，它在每个Pod中都作为PID为1进程（init进程），并回收僵尸进程。
1、Pause共享资源 网络 每个Pod都会被分配一个唯一的IP地址。Pod中的所有容器共享网络空间，包括IP地址和端口。Pod内部的内容可以使用localhost互相通信。Pod中的容器与外界通信时，必须分配共享网络资源（例如使用宿主机的端口映射）。
存储 可以Pod指定多个共享Volume。Pod中的所有容器都可以访问共享的Volume。Volume也可以用来持久化Pod中的存储资源，以防容器重启后文件丢失。
每个 Pod 都有一个特殊的被称为 “基础容器” 的 Pause 容器。Pause 容器对应的镜像属于 Kubernetes 平台的一部分，除了 Pause 容器，每个 Pod 还包含一个或者多个紧密相关的用户应用容器。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a0e3591e045c5549a50ae45586799fd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a553d57437a9eda37308ff6fd5bfcd0e/" rel="bookmark">
			YAPI修改超级管理员密码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用shell工具连接服务器，执行
mongo 这样就连接上了。然后执行
show dbs use yapi 记得官方说，用户在uesr表里面，咱们去那里看看
db.user.find() 终于找到了，但是password是加密处理的，看来还想改改密码还需要一点手段了。
例如我这个账户，是普通的账户权限，但是密码这个账户的密码是1234qwer!@#$
"password" : "224179069e921d923a2059de27d60ab2cb58cc4f", "passsalt" : "w4byep62al" 我就把管理员的密码，改成这样的就可用登录后台了（记住，一定要带passsalt这个盐值），执行：
db.user.update( {_id: 11} ,{ $set: {password: '224179069e921d923a2059de27d60ab2cb58cc4f', passsalt: 'w4byep62al'}}) 这样就把管理员的账户改成1234qwer!@#$，然后登录后台，再手动的修改下密码，完事！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3656d119304521ba39a7a826bc38fed/" rel="bookmark">
			云原生k8s之Yaml文件详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、K8S支持的文件格式
1、yaml和json的主要区别
二、YAML
1、查看API资源版本标签
2、编写资源配置清单
3、创建service服务对外提供访问并测试 四、试运行生成yaml模板后创建实例
1、-dry-run：试运行
2、查看生成yaml格式 3、查看生成json格式 4、使用yaml格式导出生成模板 5、使用yaml模板创建实例 6、将现有资源生成yaml模板导出来保存为文件 7、查看字段帮助信息 一、K8S支持的文件格式 kubernetes支持YAML和JSON文件格式管理资源对象
JSON格式：主要用于api接口之间消息的传递
YAML格式：用于配置和管理，YAML是一种简洁的非标记性语言，内容格式人性化，较易读。
1、yaml和json的主要区别 ①Yaml使用空格缩进，这是Python开发人员熟悉的领域
②JavaScript开发人员喜欢Json，因为它是JavaScript的一个子集，可以直接再JavaScript中解释和编写，同时使用简写方式声明Json，在使用没有空格的典型变量名时，不需要键中的双引号。
③有很多解释器在Yaml和Json的所有语言中都能很好地工作
④在许多情况下，Yaml地空白格式可以更容易查看，因为格式化需要更人性化地方法
⑤如果您的编辑器中没有空格可见或缩进线指示符，那么 YAML 的空白虽然更紧凑，更容易查看，但可能难以手动编辑。
⑥JSON 的序列化和反序列化要快得多，因为要检查的功能明显少于 YAML，这使得更小更轻的代码能够处理 JSON。
⑦一个常见的误解是 YAML 需要较少的标点符号并且比 JSON更紧凑，但这完全是错误的。空格是不可见的，所以看起来字符较少，但是如果你计算实际的空格是必要的，以便正确解释 YAML以及正确的缩进，你会发现 YAML 实际上需要比 JSON 更多的字符。JSON不使用空格来表示层次结构或分组，并且可以通过删除不必要的空格来轻松展平，以实现更紧凑的传输
二、YAML 1、查看API资源版本标签 kubectl api-versions 2、编写资源配置清单 编写nginx-test.yaml资源配置清单
vim nginx-test.yaml #指定api版本标签 apiVersion: apps/v1 #定义资源的类型/角色，deployment为副本控制器 #此处资源类型可以是Deployment、Job、Ingress、Service等 kind: Deployment #定义资源的元数据信息，比如资源的名称、namespace、标签等信息 metadata: #定义资源的名称，在同一个namespace空间中必须是唯一的 name: nginx-deployment labels: app: nginx #定义deployment资源需要的参数属性，诸如是否在容器失败时重新启动容器的属性 spec: #定义副本数量 replicas: 3 #定义标签选择器 selector: #定义匹配标签 matchLabels: #需与后面的.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e3656d119304521ba39a7a826bc38fed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ae275c47442f2d1b8620b2dd5fe84bd/" rel="bookmark">
			SQL case when 的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		case when用于按条件筛选：
select case when logo='123' then cardName else 'xyk' end as card_name from table where dt='20220202' case when用于统计
count用于，当值赋予NULL时，count不会累计，其他值会累计，例如有一个SQL：select count(1) from t where name='A’的结果为5，表总数为10。使用case when count效果如下：
select count(case when name='A' then 1 else NULL end) as numA from t 以上结果为5.
select count(case when name='A' then 1 else 0 end) as numA from t 以上结果为10.
sum的效果：
select sum(case when name='A' then 1 else 0 end) as numA from t 以上结果为5
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ae275c47442f2d1b8620b2dd5fe84bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5bcec85542129509745ebab644b9a63f/" rel="bookmark">
			Dockert--DockerFile-Docker网络-Docker-compose容器编排-portainer-GAdvisor监控收集&#43;InfluxDB存储数据&#43;Granfana展示图表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DockerFile 一：什么是DockerFile二：DockerFile构建过程解析2.1：DockerFile的执行大致流程2.2：FROM2.3：MAINTAINER2.4：RUN2.5：EXPOSE2.6：WORKDIR2.7：USER2.7：ENV2.8：VOLUME2.9：ADD2.10：CMD2.10：ENTRYPOINT 三：自定义功能增强版centos7镜像三：虚悬镜像四：Docker部署Springboot项目五：Docker网络4.1：Docker网络作用4.2底层容器的变化4.3docker的bridge4.3docker的host4.3docker的none4.3docker的container新建自定义网络 六：Docker-compose容器编排6.1：Docker-compose核心概念6.2：Docker-compose使用的三个步骤6.3 普通部署项目6.3 docker-compose部署项目6.3 docker-compose常用命令 七：docker轻量级可视化工具portainer7.1：portainer操作7.2：portainer安装nginx7.1：GAdvisor监控收集+InfluxDB存储数据+Granfana展示图表7.1.1 GAdvisor7.1.1 InfluxDB7.1.3 Granfana7.1.4 compose一键部署 一：什么是DockerFile DockerFile是用来构建Docker的文本文件，是由一条条构建镜像所需的指令参数构成的脚本
二：DockerFile构建过程解析 每条保留字指令时都必须为大写字母且后面要很一个参数指令按照从上到下，顺序执行#表示注释每条指令都会创建一个新的镜像并对镜像进行提交 2.1：DockerFile的执行大致流程 docker从基础镜像运行一个容器执行一条指令并对容器进行修改执行类似于docker commit的操作提交一个新的镜像层docker再基于刚提交的镜像运行一个容器执行dockerfile中的下一条指令直到所有指令都加载完毕
2.2：FROM 基础镜像，当前的新镜像是基于哪个镜像的，指定一个已经存在的镜像作为模板，第一条必须是from 2.3：MAINTAINER 镜像维护者的姓名和邮箱地址 2.4：RUN 容器构建时需要运行的命令两种格式：shell格式 exec格式run是在docker build时运行 2.5：EXPOSE 当前容器对外暴露的端口 2.6：WORKDIR 指定容器创建后，终端默认登录的进来工作目录，一个落脚点 2.7：USER 指定镜像以什么样的用户去执行，如果不指定，默认是root 2.7：ENV 用来构建镜像过程中，设置环境变量 2.8：VOLUME 容器卷，用于保存数据和持久化工作 2.9：ADD 将宿主目录下的文件拷贝镜像且会自动处理URL和解压缩tar 压缩包 2.10：CMD 指定容器启动后要干的事情可以有一个cmd命令，但只有最后一个会生效，cmd会被之前docker run之后的参数替换CMD和RUN的区别cmd是在docker run时运行run 是在docker build时运行 2.10：ENTRYPOINT 也是用来指定一个容器启动时要运行的命令类似于cmd命令但是ENTRYPOINT不会被docker run后面的命令覆盖，而这些命令行参数会被当做参数传递给ENTRYPOINT指令指定的程序
三：自定义功能增强版centos7镜像 #下载 docker pull centos #运行 docker run -it 5d0da3dc9764 #里面vim ifconfig 等等什么命令都没有，接下来用dockerfile来进行一个功能的增强 # 创建文件夹 mkdir myfile -将java的安装包拷贝到目录下 #在当前目录 vim Dockerfile #这边拉取了一个7的centos FROM centos:7 MAINTAINER lxy&lt;2050298183.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5bcec85542129509745ebab644b9a63f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65910c85628ae4b01700e84633d9dfa8/" rel="bookmark">
			阿里云验证SSL证书
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在阿里云购买收费SSL或者免费SSL证书后，阿里云会自动提交进行验证；你所需要进行的下一步是验证SSL。
验证SSL步骤 1:根据阿里云官方文档提示操作
我这边域名和SSL证书不是在同一账号主体下，因此需要采用手工DNS验证
2:在需要绑定SSL证书的域名重新解析一个域名
点击解析按钮，进入域名解析界面，点击添加记录
然后将SSL证书申请时的对应信息添加即可
3：验证
单击验证，验证成功后，点击审核即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4776937b50fb70b0243fc114bcec8b6/" rel="bookmark">
			一个C语言的基本教程—指针篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 9. C语言真正的灵魂——指针(1). 指针到底是什么？(2). 指针的基本结构(3). 取地址(&amp;)和解引用(*)操作符(4). 指针有什么用呢？#1.swap函数的例子#2.只传值的C语言函数#3.总结#4.其他语言一瞥 (5). 令人头疼的多重指针(6). 数组和指针的关系#1.指针的加减运算#2.连续的内存#3.传入数组的函数#4.返回数组的函数#5.一些运算符的优先级#6.以指针的方式访问数组#7.为什么数组下标要从0开始？#8.数组指针与指针数组 (7). 动态内存分配#1.从malloc说起：#2.改进后的calloc#3.灵活伸缩的realloc#4.多维数组和malloc函数#5.健忘的人们和迷茫的人们 (8). 等会儿，void* 是个啥？(9). 字符串去哪儿了？#1.我们见到的字符串#2.自定义的字符串 (10). 字符串/数组的更多操作#1.strlen()#2.strcpy()#3.strcat()#4.strcmp()#5.memcpy()#6.memset() (11). 现在我们就可以说说int argc和char* argv[]是什么东西了(12). 自由的指针和不自由的程序员(13). 关于“地址”的思考——我们能不能做个游戏修改器(CE)？(14). 关于函数指针小结 9. C语言真正的灵魂——指针 我想大家就算可能没有学过编程语言，也应该听说过指针的大名，指针的确是C语言中最重要的概念之一了，再我们具体讲完这一章之后，我相信你也会对我说的这句话有自己的理解。
(1). 指针到底是什么？ 有这么一件事情，AAA路上有两三百个商铺，而其中有 一家大型连锁奶茶店“好茶” 在这条街的头和尾各开了一家“好茶”，有一天你来逛街，朋友说：“去好茶买杯奶茶吧！”你表示认同，不过这条街上有两家好茶，要去哪一家呢？
我当然不是来让你考虑去哪一家的，只是我们可以把这个事情类比成C语言中的一些东西，我们来看下面这个程序：
#include &lt;stdio.h&gt; int main() { int a = 1; { int a = 2; printf("a = %d\n", a); } printf("a = %d\n", a); return 0; } 它的运行结果如下：
他们都叫做a，但是值不一样，就像是我们刚说的那条街上的两家店，虽然名字一样，但是他们肯定不是同一家店，那我们有什么办法区分它们吗？在现实中，我们可以用地址来区分它们：AAA路0100号好茶和AAA路3300号好茶，所以在C语言中对于变量我们也有这样的地址，这个地址就是变量在内存中的具体位置，而存储地址的变量，就称为指针(pointer)。
当然，指针并不一定都用在相同名字的变量上面，只是这个例子更加有助于我们理解“变量的位置”这个概念。我们也可以把指针想象成是一张写着地址的纸。
(2). 指针的基本结构 要声明一个指针变量还是比较简单的，只需要在各种数据类型后加一个*就好了，例如下面的三种写法：
int* p0; double * p1; float *p2; 从语言的角度来看，他们没有任何区别，不过我更推荐使用int* p的格式，将int* 看作int型指针这样一个新的数据类型。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c4776937b50fb70b0243fc114bcec8b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a44b9b32ba573dfd9cf824acd266357/" rel="bookmark">
			Java绘图库JFreeChart的详细使用教程(入门级)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 图表是一种以简单方式显示信息的图形，通常使用直线和曲线来显示金额。 JJFreeChart 由 David Gilbert 于 2000 年创立。如今，JFreeChart 是 Java 开发人员中使用最广泛的图表库。
JFreeChart 允许创建各种交互式和非交互式图表；可以广泛地定制； 它允许修改图表项目的颜色和绘制，图例，线条或标记的样式。 它会自动绘制轴刻度和图例。可以创建折线图，条形图，面积图，散点图，饼图，甘特图和各种专用图，例如风向图或气泡图。它支持多种输出格式，包括 PNG，JPEG，PDF 和 SVG。
相关jar包：JFreeChart绘图包-Java文档类资源-CSDN下载
类级结构构解释了库中的各种类如何相互交互以创建各种类型的图表。下图为JFreeChart的类级结构：
Units DescriptionFile具有用户输入的源，用于在文件中创建数据集。Database具有用户输入的源，用于在数据库中创建数据集。Create Dataset接受数据集并将数据集存储到数据集对象中。General Dataset这种类型的数据集主要用于饼图。Category Dataset此类数据集用于条形图、折线图等。Series Dataset这种类型的数据集用于存储一系列数据和构建折线图。Series Collection Dataset将不同类别的系列数据集添加到系列集合数据集中。这种类型的数据集用于 XY 线图。Create Chart这是为创建最终图表而执行的方法。Frame/Image该图显示在一个Swing框架或创建映像。 一、快速绘图教程 1. 折线图 package plot; import org.jfree.chart.ChartFactory; import org.jfree.chart.ChartFrame; import org.jfree.chart.JFreeChart; import org.jfree.chart.plot.PlotOrientation; import org.jfree.data.category.DefaultCategoryDataset; public class Example { public static void main(String[] args) { // 创建数据 DefaultCategoryDataset dataset = new DefaultCategoryDataset(); dataset.addValue(15, "schools", "1970"); dataset.addValue(30, "schools", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a44b9b32ba573dfd9cf824acd266357/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26b8390618f9bcaa78ec4c4e50f5d85f/" rel="bookmark">
			PC_溢出概念&#43;判断方法&#43;示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 PC_溢出概念+判断方法+示例ref分类定点计算机中的溢出定点机溢出示意图 在浮点计算机中的溢出浮点机溢出示意图 溢出简易判断规律溢出的必要条件定点数🎈补码运算判断溢出方法用一位符号位判断溢出例例 双符号位:变形补码判断溢出例例硬件实际情况 采用一位符号位并根据最高数据位进位情况判断 PC_溢出概念+判断方法+示例 算术溢出（arithmetic overflow）是指计算机进行算术运算产生的结果超出机器所能表示的范围。 ref 计组_浮点数表示/定点数和浮点数比较/溢出_xuchaoxin1375的博客-CSDN博客_浮点数的补码怎么算 分类 根据溢出方向:
上溢
下溢
在浮点机中可以进一步分为:
正上溢
负上溢
正下溢
负下溢
正下溢和负下溢是连在一起的区间(是0的去心邻域)
浮点数可以表达0,但是可能表示不了不等于但是很接近0的数 根据小数点类型:
定点机定点数溢出浮点机浮点数溢出 定点计算机中的溢出 从正方向超过了数的表示范围，称为上溢；从负方向超过了数的表示范围，则称为下溢。 定点机溢出示意图 定点数小数的溢出示意 可见,定点小数只可以表示纯小数 否则会上溢 定点整数溢出: 定点整数只能够表示纯整数,否则会出现下溢 在浮点计算机中的溢出 浮点数的表示范围主要由阶码来决定。(尾数决定的是精度)
不论数的符号是正还是负，若阶码从正的方向超出了阶码的表示范围，称为上溢；
若阶码从负的方向超出阶码的表示范围，或者尾数为“0”时，统称为下溢。
浮点机溢出示意图 一般来说，计算机对于浮点数的下溢，则自动当作“0”来处理，不输出错误信息(精度的溢出)；
而产生的上溢(范围溢出)，计算机则产生==“溢出中断”==，并输出溢出的错误信息，甚至停止程序的运行
溢出简易判断规律 定点数加减运算结果出现溢出时,得到的是错误的结果 溢出的必要条件 仅当两个符号相同的数相加或两个符号相异的数相减才可能产生溢出 上面两种情况才有可能引发进位
(换句话说,如果两个参与计算的数(本身没有溢出)且计算过程没有进位,则该计算也不可能发生溢出)
进位是溢出的必要条件 但是如果只知道发生了进位,不可以断定发生溢出
设机器数 S = x 0 , x 1 x 2 ⋯ x n S=x_0,x_1x_2\cdots{x_n} S=x0​,x1​x2​⋯xn​
更有具体的是,最高位数值位 x 1 x_1 x1​处发生进位(以原码为例)
口诀:同号加,异号减,进位是发生溢出的必要条件
比如:两个正数相加，结果的符号位却为 1 (结果为负);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/26b8390618f9bcaa78ec4c4e50f5d85f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ada1eae73f64d9a65ea5ea4ace268a6e/" rel="bookmark">
			把字典文本转化为字典
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、问题与目标：
字典文本保存在txt文件中：
内容为：
目标就是将其转化为字典，方便提取其中的网址。
二、方法
1.读取字典文本文件，并进行规范处理。即只含有字典文本部分，把空白、换行号、逗号等全部去掉。
代码：
f = open(r'C:\Users\Lenovo\Desktop\字典文本文件.txt','r',encoding='utf-8') a = f.readlines() b = [] for i in a: a0 = i.strip('\n') a0 = a0.strip(',') a0 = a0.strip() b.append(a0) f.close() 运行结果：
列表的元素就是字典文本，当使用a0['url']来提取链接时，提示错误：
显然，这里还是字典字符串，不是字典。
2. 利用json模块，将字典字符串转化为字典。
import json d = [] for i in b : c = json.loads(i) d.append(c) 运行结果：
这里的列表元素就是字典了。验证一下：
for i in d: print(i['url']) 运行结果： 三、关于单引号和双引号的问题
完成文章后又看了一下其他人的文章，提到json模块在遇到字典里是单引号时会出现，试验了一下，果然有问题。
把文本换成了单引号的：
运行结果：
解决的办法：
使用ast模块。
ast模块中的literal_eval方法可以把数据还原成它本身或者是能够转化成的数据类型。同时在转换时会判断需要计算的内容计算后是不是合法的python类型，如果是则进行运算，否则就不进行运算，比较安全
import ast d = [] for i in b : c = ast.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ada1eae73f64d9a65ea5ea4ace268a6e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/272e20be4856f03908d673dea8b600a5/" rel="bookmark">
			空间索引-点在线上
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、建表，同时建索引
SRID 取 0，代表平面坐标系。
create table spatial_point_in_line ( `id` int unsigned not null auto_increment primary key , `min` int unsigned not null default 0, `max` int unsigned not null default 0, `line_geo` geometry not null srid 0, SPATIAL INDEX index_spatial_line_geo(`line_geo`) ) 2、插入数据
insert into spatial_point_in_line (min, max, line_geo) values -- (80, 90, ST_GeomFromText(CONCAT('LINESTRING(', min, ' 0,', max, ' 0)'), 0)), -- (80, 100, ST_GeomFromText(CONCAT('LINESTRING(', min, ' 0,', max, ' 0)'), 0)), -- (90, 100, ST_GeomFromText(CONCAT('LINESTRING(', min, ' 0,', max, ' 0)'), 0)), -- (100, 110, ST_GeomFromText(CONCAT('LINESTRING(', min, ' 0,', max, ' 0)'), 0)), -- (100, 120, ST_GeomFromText(CONCAT('LINESTRING(', min, ' 0,', max, ' 0)'), 0)) (80, 90, LineString(Point(min, 0), Point(max, 0))), (80, 100, LineString(Point(min, 0), Point(max, 0))), (90, 100, LineString(Point(min, 0), Point(max, 0))), (100, 110, LineString(Point(min, 0), Point(max, 0))), (100, 120, LineString(Point(min, 0), Point(max, 0))) 3、点在线上，不在两端
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/272e20be4856f03908d673dea8b600a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2110f44cff1577840d0ab809a942293b/" rel="bookmark">
			Linux 文件权限的修改
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先我们要清楚Linux文件的权限信息
在Linux中输入ls -l 或者 ll查看文件和目录的详细信息
实例中，a目录的第一个属性用“d”标识这个a是一个目录。
anaconda-ks.cfg第一个属性用“-”标识他是一个文件。
在Linux文件详情的后面属性需要分为三组查看
rwx： 代表文件拥有者的权限
rwx： 代表文件所属组用户的权限
rwx： 代表其他用户对当前文件的操作权限
r： 代表read，读的权限
w： 代表write，写的权限
x： 代表execute，代表执行权限
其余信息
后续的第一个root：代表当前文件的拥有者
后续的第二个root： 代表当前文件的所属组
后续分别为：文件的大小和最后修改时间等信息
对文件的权限修改 使用chmod对文件的权限进行修改，一种使用数字，一种使用符号……
数字方式方便操作，不过要修改整体权限信息
符号方式更细粒度华，不过操作麻烦
数字方式 chmod [-R] 777 文件|目录
# rwx在这三个权限中r：4，w：2，x：1
# -R： 当修改一个目录权限时，可以添加-R，将目录下的全部内容，都修改权限。
符号方式 chmod [-R] a=rw 文件|目录
# user：u，group：g，other：o，all：a
# read：r，write：w，execute：x
# 赋予权限的方式 , 添加：+，减掉：-，设定：=
# -R： 当修改一个目录权限时，可以添加-R，将目录下的全部内容，都修改权限。
文件拥有者及所属组修改 chown可以直接修改拥有者和所属组，chgrp只能修改所属组……
# 修改文件的拥有者和所属组
chown [-R] 拥有者：所属组 文件|目录
# 修改文件的拥有者
chown [-R] 拥有者 文件|目录
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2110f44cff1577840d0ab809a942293b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8322a2450e5fecd57a36c574f6e001b/" rel="bookmark">
			JVM线程安全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
线程安全
Java语言中的线程安全
1.不可变
2.绝对线程安全
3.相对线程安全
4.线程兼容
5.线程对立
线程安全的实现方法
1.互斥同步（悲观锁）
synchronized
java.util.concurrent.locks.Lock
优先使用synchronized
2.非阻塞同步（乐观锁）
3.无同步方案（不涉及共享数据，天生线程安全）
在软件业发展的初期，程序编写都是以算法为核心的，程序员会把数据和过程分别作为独立的部 分来考虑，数据代表问题空间中的客体，程序代码则用于处理这些数据，这种思维方式直接站在计算 机的角度去抽象问题和解决问题，被称为面向过程的编程思想。
与此相对，面向对象的编程思想则站 在现实世界的角度去抽象和解决问题，它把数据和行为都看作对象的一部分，这样可以让程序员能以符合现实世界的思维方式来编写和组织程序。
线程安全 当多个线程同时访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为（单次调用）都可以获得正确的结果，那就称这个对象是线程安全的。
上述要求线程安全的代码都必须具备一个共同特征：代码本身封装了所有必要的正确性保障手段（如互斥同步等），令调用者无须关心多线程下的调用问题，更无须自己实现任何措施来保证多线程环境下的正确调用。
Java语言中的线程安全 Java语言中各种操作共享的数 据分为以下五类：不可变、绝对线程安全、相对线程安全、线程兼容和线程对立。
1.不可变 在Java语言里面，不可变 （Immutable）的对象一定是线程安全的，无论是对象的方法实现还是方法的调用者，都不需要再进行任何线程安全保障措施。
只要一个不可变的对象被正确地构建出来（即没有发生this引用逃逸的情况），那其外部的可见状态永远都不会改变，永远都不会看到它在多个线程之中处于不一致的状态。“不可变”带来的安全性是最直接、 最纯粹的。
Java语言中，如果多线程共享的数据是一个基本数据类型，那么只要在定义时使用final关键字修饰 它就可以保证它是不可变的。
如果共享数据是一个对象，由于Java语言目前暂时还没有提供值类型的支持，那就需要对象自行保证其行为不会对其状态产生任何影响才行。类比java.lang.String类的对象实例，它是一个典型的不可变对象，用户调用它的 substring()、replace()和concat()这些方法都不会影响它原来的值，只会返回一个新构造的字符串对象。
在Java类库API中符合不可变要求的类型，除了上面提到的String之外，常用的还有枚举类型及 java.lang.Number的部分子类，如Long和Double等数值包装类型、BigInteger和BigDecimal等大数据类型。
2.绝对线程安全 一 个类要达到“不管运行时环境如何，调用者都不需要任何额外的同步措施”可能需要付出非常高昂的， 甚至不切实际的代价。在Java API中标注自己是线程安全的类，大多数都不是绝对的线程安全。
package create; import java.util.Vector; public class Solution { private static Vector&lt;Integer&gt; vector = new Vector&lt;Integer&gt;(); public static void main(String[] args) { while (true) { for (int i = 0; i &lt; 10; i++) { vector.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8322a2450e5fecd57a36c574f6e001b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e7c732b9e97447195374016f6fa8b12/" rel="bookmark">
			rtc的计时方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1-时钟配置：RTCCLK / RTC_PRL = TR_CLK，配置PRL的值就能配置RTC的时钟频率，决定着最小指令周期时间；DIV是一个自减计数器，其最初的加载值是PRL，然后随着RTCCLK的指令周期一个一个减，减到0时，正好对外输出个TR_CLK，因为分频嘛就是有个PRL的倍数关系，输出TR_CLK后也刚好再把PRL加载到DIV中继续自减。DIV的每一步是根据RTCCLK的指令周期的，精度更高点，比如说，为40kHz，指令周期为1/40k = 25us，也就是DIV每减少1就是过了25us，若PRL取100，则TR_CLK的指令周期只有10025 = 2500us，显然分辨率第一点。当DIV的值为80，我们能知道过了（100-80) * 25us = 500us，提高了分辨率，如果此时还检测到TR_CLK已经过了2个指令周期，那么总走过的时间是：22500+25=5025us。
2-定时器中断：首先是一个秒中断：RTC定时器每走过1秒的时间就会触发秒中断；然后是溢出中断：当计数器RTC_CNT溢出并变回0时触发中断，RTC_CNT每过1秒才会增加1，并且是个32位的寄存器，存储范围很大的，另外是把1970年对应RTC_CNT为0，然后根据CNT当前的值就可以基于1970年这个时间远点推测当前是什么日期和时间，举个随意的值，比如此时RTC_CNT 被设置为1004556，说明距离1970年已经过了1004556秒，假设计算和后刚好是2017年5月20号13点14分25秒（这只是随口说的，并没有仔细去算，大概理解过程就行），这不就起到了日历的作用了吗。并且RTC_CNT这个最大能记录到136年后，足够用了。最后是闹钟中断：把RTC_ALR设置成某个数，当CNT=ALR时就会触发闹钟中断。
此处转自RTC时钟：一个日历_学点东西吧的博客-CSDN博客_rtc 1970
要知道在已经编辑好的获取时间函数中基本都会调用固件函数库中的RTC_GetCounter函数，
代码如下：（源自stm32f10x.c）
实时时钟 (RTC) 是一个独立的 BCD 定时器/计数器。 RTC 提供一个日历时钟、两个可编程闹钟中断，以及一个具有中断功能的周期性可编程唤醒标志。 RTC 还包含用于管理低功耗模式的自动唤醒单元。
两个 32 位寄存器包含二进码十进数格式 (BCD) 的秒、分钟、小时（ 12 或 24 小时制）、星期几、日期、月份和年份。此外，还可提供二进制格式的亚秒值。
系统可以自动将月份的天数补偿为 28、 29（闰年）、 30 和 31 天。并且还可以进行夏令时(在夏季的某一天会在凌晨时分跳过一小时，而后会在冬季补回来)补偿。
其它 32 位寄存器还包含可编程的闹钟亚秒、 秒、分钟、小时、星期几和日期。此外，还可以使用数字校准功能对晶振精度的偏差进行补偿。
上电复位后，所有 RTC 寄存器都会受到保护，以防止可能的非正常写访问。
无论器件状态如何（运行模式、低功耗模式或处于复位状态），只要电源电压保持在工作范围内， RTC 便不会停止工作。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb01c65490d9b85ad991720fb00ece8b/" rel="bookmark">
			mybatis-plus拦截器&#43;token自动填充创建人，更新人
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、新建类BaseContext
package com.example.springbootmybatisplus.utils; public class BaseContext { private static ThreadLocal&lt;Integer&gt; threadLocal = new ThreadLocal&lt;&gt;(); public static void setUserId(Integer id){ threadLocal.set(id); } public static Integer getUserId(){ return threadLocal.get(); } public static void remove(){ threadLocal.remove(); } } 2、拦截器模块
package com.example.springbootmybatisplus.handler; import com.example.springbootmybatisplus.config.JwtUtil; import com.example.springbootmybatisplus.utils.BaseContext; import io.jsonwebtoken.ExpiredJwtException; import io.jsonwebtoken.Header; import lombok.extern.slf4j.Slf4j; import org.springframework.web.servlet.HandlerInterceptor; import org.springframework.web.servlet.ModelAndView; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; @Slf4j public class InterceptorPre implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { String token=request.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb01c65490d9b85ad991720fb00ece8b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71567905044a008a1edf2873807a777e/" rel="bookmark">
			transformer ViT DERT
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 transformer Attention Is All You Need https://arxiv.org/abs/1706.03762 NLP 机器翻译
具有全局语义特征提取融合及并行计算的特点。
1.1 整体模型结构 是一个encoder--decoder的结构，最核心的是attention模块。
​
Transformer 中有两种注意力机制，self-attention 和 cross-attention。主要区别是query Q 的来源。
self attention 可以看作是原始特征域中的特征增强器，而 cross attention 则可以被视为跨域解码器。
1.2 Attention计算 并行计算，全局attention
​
1.3 Position Embedding 在NLP中它是为了保持输入序列中单词顺序，这个向量决定了当前词的位置。
在CV领域就代表图像Patch的空间位置以及Patch之间的相互关系。图片天然是有强几何信息。
通常有两种位置编码方式： 一种通过训练学习 Position Embedding 向量，即是个可学习更新的向量； 一种使用编码公式来计算得到 Position Embedding向量，这种方式的编码值不变。 正余弦函数位置编码公式
​给定词语的位置pos，就可以把它编码成d_model维的向量，即与输入单词向量大小一致，两者相加作为encoder的输入。
2 ViT Vision Transformer An image is worth 16x16 words: Transformers for image recognition at scale https://arxiv.org/abs/2010.11929
ViT使用Transformer self attention机制，对图片编码得到全局特征融合的高级语义特征，实现图像分类任务。 其中没有使用CNN，相当于把Transformer encoder当作一个backbone。
ViT的结构
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/71567905044a008a1edf2873807a777e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c14286fe86afc5fa02beab9b1f9266e6/" rel="bookmark">
			Unity AR 两指手势实现物体放大缩小功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		//C#脚本如下，将脚本挂在物体上即可
Zoom.cs
using UnityEngine; public class Zoom : MonoBehaviour { //旧的触摸点位置 Vector2 oldPos1; Vector2 oldPos2; // Start is called before the first frame update void Start() { } // Update is called once per frame void Update() { //判断触摸点的数量是否为两个 if(Input.touchCount == 2) { //判断两个触摸点的状态是否为手指进行了移动 if (Input.GetTouch(0).phase == TouchPhase.Moved||Input.GetTouch(1).phase==TouchPhase.Moved) { //新的触摸点的位置 Vector2 newPos1 = Input.GetTouch(0).position; Vector2 newPos2 = Input.GetTouch(1).position; //判断触摸的手势是否为放大 if(isEnLarge (oldPos1,oldPos2,newPos1,newPos2)) { //获取transform组件缩放属性x轴数值 float oldScale = transform.localScale.x; //新的数值为旧的数值放大1.025倍 float newScale = oldScale * 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c14286fe86afc5fa02beab9b1f9266e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/110df550f292abfc8195289126606b29/" rel="bookmark">
			【沉浸式腾讯云服务器部署安装docker】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		重置密码 sudo passwd root
[lighthouse@VM-12-2-centos ~]$ sudo passwd root Changing password for user root. New password: Retype new password: passwd: all authentication tokens updated successfully. 切换root用户 su
[lighthouse@VM-12-2-centos ~]$ su Password: 查看系统版本 uname -r
[root@VM-12-2-centos lighthouse]# uname -r 3.10.0-1160.71.1.el7.x86_64 uname -a
docker官方说至少3.8以上，建议3.10以上
[root@VM-12-2-centos lighthouse]# uname -a Linux VM-12-2-centos 3.10.0-1160.71.1.el7.x86_64 #1 SMP Tue Jun 28 15:37:28 UTC 2022 x86_64 x86_64 x86_64 GNU/Linux [root@VM-12-2-centos lighthouse]# 更新yum包 yum update
[root@VM-12-2-centos lighthouse]# yum update Loaded plugins: fastestmirror, langpacks Repository epel is listed more than once in the configuration Determining fastest mirrors epel | 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/110df550f292abfc8195289126606b29/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6809afea7545c4c9119e4f6e95d3380/" rel="bookmark">
			2022最详细最快微信聊天记录备份＆导出方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		12-1
在有些情况下，比如需要换电脑的时候，或者需要对某些重要的聊天对话做一些备份，就凭微信本身的功能，是不行的，微信根本不提供聊天记录导出功能。
使用本文章的方法，可以自动地导出所有人的聊天记录，甚至语音都可以导出MP3，还可以指定导出某个人的所有微信聊天记录，是备份聊天记录最快的方法。
具体是什么方法呢？请继续往下看。
这里需要使用一个小工具，总体的原理是这样：
1，在电脑上登录微信
2，检测这个微信的密钥
3，解码这个微信的数据文件
4，从解码后的数据文件导出聊天记录
以下是具体实践
一、电脑登录微信后，点击左下角的【菜单】【设置】
二、在打开的设置窗口中点击【文件管理】【打开文件夹】
三、电脑就会打开这个微信的数据文件夹，如下图
四、双击文件夹里的【Msg】文件夹进去
五、把这个文件夹地址栏里的路径复制下来
六、打开“微信聊天记录挖掘机”这个小工具，可以下面这个链接获取的：
https://www.qinyuanyang.com/zb_users/upload/2022/11/20221104162400166755024017266.zip
​
七、软件打开后，长下面这样
​
八、第一个格子粘贴刚才复制的路径，第二个格子选择一个保存聊天记录的文件夹，如下图
​
九、如果你想把语音也导出的话，就把这个勾上
​
十、最后点击“一键导出所有聊天记录”，然后就是等待了，这时候可以去喝个咖啡
​
十一、在导出的过程中可以看到相应的导出进度信息的，如下图
​
十二、最后在导出的地方可以看到两个文件夹，分别是放聊天记录和聊天里的语音的MP3的
​
十三、如果你只想导出某个人的，也是可以的，点击以下这个地方，可以看到导出某个人或者某个群的方法
​
十四、本软件也有离线导出功能，也就是不登录微信的导出方法，具体使用方法可以参考这里：
​
十五、导出的聊天记录结果可以用表格软件打开，也就是OFFICE或者WPS，电脑里需要安装办公软件才可以打开的，文件越大，聊天记录越多，可以看到和谁聊得最多
​
十六、到这里就搞定了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8c1f85f58cfbe48032c5931a623ed9e/" rel="bookmark">
			python读取和保存图片的三种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python读取和保存图片 opencv import cv2 #load img = cv2.imread('0.png') #show cv.imshow('title', img) #save cv2.imwrite('1_cv2.png',img) 可以看到opencv读取的图片数据类型是uint8格式（属于numpy），uint8是专门用于存储各种图像的（包括RGB，灰度图像等），范围是从0–255。
读取的形状为（H,W,C），BGR
matplotlib import matplotlib.pyplot as plt # load img = plt.imread('0.png') #读取后的dtype为float32（属于numpy），范围是[0,1] #读取后的形状是（H,W,C），RGB # show plt.imshow(img) plt.axis('off') plt.show() # save #plt.imsave('1_plt.png',img) 还有一个保存方式叫plt.savefig(),但是使用这种方式保存的时候，保存的图片会显示空白，参考了plt.savefig保存图片一片空白或者显示内容不完整、错乱后把plt.savefig()放在了show的前面得以解决。
import matplotlib.pyplot as plt # load img = plt.imread('0.png') #读取后的shape为 # show plt.imshow(img) plt.axis('off') plt.savefig('1_plt2.png') plt.show() PIL from PIL import Image # load img = Image.open('0.png') #读取后形状是（W,H） # show img.show() #save img.save('1_pil.png') 但是使用PIL读取的图片，matplotlib保存的图片会显示错误。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8c1f85f58cfbe48032c5931a623ed9e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81b45958a1c746bf9f8578f87d238334/" rel="bookmark">
			统计字符串中字母、数字以及其他字符的个数，并把统计结果在主函数中输出。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. 定义整形数组实现
在主函数中，首先要创建一个足够大的字符数组，char[x]，x根据你所输入的字符串大小来确定，能装得下就行，用来存储字符串。
传值调用中，return只能传回一个值，所以不能采用这种方式。
由题目可知，需要传回的是字母，数字，其他字符的个数。也就说，需要传回三个值，这时我们自然而然的想到了用一个数组来存放这三个值。因此，我们定义一个整形数组int num[]来存放，字母，数字，其他字符的个数。
通过gets()将字符串输入。
通过自定义的jishu函数，将字符串，num数组传给jishu函数，并在jishu函数中计算得到三个数据的具体值，同时存放进num数组中。
最后，通过printf,将结果输出在显示屏上。
for循环中的判断条件也可以写成s[i]！='/0'。目的是遇到字符串结束标志就挑出循环。
通过if else语句，逐一的对字符串中每个字符进行判断。如果条件成立，就存储到相应的数组中。由于num是数组，其内部空间是一致的。所以在jishu函数中改变，也会影响到主函数中num的变化。
代码如下：
#include &lt;stdio.h&gt;
void main()
{
void jishu(char s[],int num[3]);
char arr[10];
int num[3]={0};
printf("请输入字符串");
gets(arr);
jishu(arr,num);
printf("字母：%d\n数字：%d\n字符%d\n",num[0],num[1],num[2]);
}
void jishu(char s[],int num[])
{
int i;
for(i=0; s[i]; i++)
{
if('a'&lt;=s[i]&amp;&amp;s[i]&lt;='z'||'A'&lt;=s[i]&amp;&amp;s[i]&lt;='Z')
num[0]++;
else if('0'&lt;=s[i]&amp;&amp;s[i]&lt;='9')
num[1]++;
else
num[2]++;
}
}
二.定义全局变量实现
全局变量：
在函数之外定义的变量称为全局变量，也称为外部变量。有效范围为从定义变量的位置开始到本源文件结束。全局变量在编译时分配内存，且在程序的全部执行中都占用内存。
通过上述定义可以得知，我们定义的sz，zm，zf这三个变量，其不但可以在主函数中起作用，同时也可以在自定义的jishu函数中起作用。在编译时分配内存，全部执行中都占用内存意味着，自定义jishu函数中的变量与主函数中的变量一直共用一块空间，所以可以相互影响。
这时，我们只需要向自定义的jishu函数传入一个字符串。所以，形参只有一个字符数组就行。
代码如下：
#include &lt;stdio.h&gt;
int sz=0,zm=0,zf=0;
void main()
{
void jishu(char s[]);
char arr[10];
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/81b45958a1c746bf9f8578f87d238334/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86259bb3ea9c02693582a4e290609bea/" rel="bookmark">
			npm使用问题汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 基本命令 安装最新版express
npm install express -g
安装指定版本express
npm install express@2.5.0
删除express
npm remove express -g
npm更新
npm i -g npm
空白目录下执行npm init生成package.json文件
npm init
npm卸载 即需要卸载Node JS。
Windows 步骤：
打开控制面板，卸载nodewhere node，如果输出：信息: 用提供的模式无法找到文件说明环境变量已经清除重启，为了卸载干净，可省略 修改node.js默认的npm安装目录 减轻C盘负担，先提前创建好目录：
npm config set prefix "D:\Program Files\nodejs\node_global" npm config set cache "D:\Program Files\nodejs\node_cache" 验证：npm install -g express
确实安装到新的目录。
npm vs cnpm npm config set registry https://registry.npm.taobao.org npm install -g cnpm --registry=https://registry.npm.taobao.org package.json npm的package.json文件类似于，maven的pom.xml，pip的requirements.txt文件。文件样例：
{ "name": "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/86259bb3ea9c02693582a4e290609bea/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/211/">«</a>
	<span class="pagination__item pagination__item--current">212/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/213/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>