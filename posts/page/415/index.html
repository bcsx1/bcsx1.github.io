<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e93a0ab048ade351d913a66ea6047fa5/" rel="bookmark">
			python中id()函数、is操作符、zip()函数、map()函数、lambda函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		展示 id函数
参考链接: 内置函数
参考链接: 对象、值与类型
id(object):
返回对象的“标识值”。该值是一个整数，在此对象的生命周期中保证是唯一且恒定的。两个生命期不重叠的对象可能具有相同的 id() 值。CPython implementation detail: This is the address of the object in memory.
每个对象都有各自的编号、类型和值。一个对象被创建后，它的 编号 就绝不会改变；你可以将其理解为该对象在内存中的地址。 ‘is’ 运算符可以比较两个对象的编号是否相同；id() 函数能返回一个代表其编号的整型数。
CPython implementation detail: 在 CPython 中，id(x) 就是存放 x 的内存的地址。
描述： id() 函数用于获取对象的内存地址。 语法： id([object]) 参数说明：object – 对象。 返回值: 返回对象的内存地址。 示例： a = 2 b = 3 print(id(a)) print(id(b)) 输出：
140713021632800 140713021632832 ------------------ (program exited with code: 0) 请按任意键继续. . . is 和 is not操作符:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e93a0ab048ade351d913a66ea6047fa5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67ddd480abe89266601cb04d4402327f/" rel="bookmark">
			深聊性能测试，从入门到放弃之：Locust性能自动化(二)代码实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Locust代码实战 1. 引言2. Locust实例展示2.1 官网代码示例2.2 Locust 代码模板及执行顺序 3. Locust 类代码分析3.1 实例代码展示3.2 classTaskSet 用法及展示3.2.1 定义3.2.2 代码展示 4. Locust高级用法4.1 关联4.2 参数化4.2.1 聊一聊参数化4.2.2 三个场景认识参数化 4.3 检查点 5. Locust运行模式5.1 单进程运行模式5.1.1 定义及解析5.1.2 有Web UI模式5.1.3 无Web UI模式5.1.4 启动locust 5.2 多进程分布式运行5.2.1 master启动5.2.2 slave 启动 6. Locust 结果分析 1. 引言 在本章节，你可以学习到：
1、Locust代码实例展示及解读：
①官网代码示例
②demo模板代码
3、Loucst的高级用法：
①关联
②参数化
③检查点
4、Locust的运行模式：
①单进程运行模式
②多进程分布式运行
5、Locust界面展示及结果分析
2. Locust实例展示 2.1 官网代码示例 我们来看看官网的第一个例子，
很简单：
# -*- coding: utf-8 -*- """ @ auth : carl_DJ @ time : 2020-9-23 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/67ddd480abe89266601cb04d4402327f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3b3a36b152a6a887943aa3905b34b2f/" rel="bookmark">
			Python中对csv文件进行转置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		利用pandas对csv文件进行转置
import pandas as pd for i in range(NO_number): # 批量转置 num = str('{:g}'.format(i)) path = os.getcwd() + '/new_output/new_NO.' + num + '_S.csv' df = pd.read_csv(path, header=None) # path为csv文件的路径 data = df.values # data是数组，直接从文件读出来的数据格式是数组 indexl = list(df.keys()) # 获取原有csv文件的标题，并形成列表 data = list(map(list, zip(*data))) # map()可以单独列出列表，将数组转换成列表 data = pd.DataFrame(data, index = indexl) # 将data的行列转换 data.to_csv(path, header=0) ps：如果原文件第一行为有用数据，可以在 pd.read_csv函数中加上header=None避免删掉原文件的第一行（把原文件的第一行当成了名字），不加即为删除原第一行内容
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31891ca3f32e808e59dde74ca045cae4/" rel="bookmark">
			bsearch的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		bsearch(二分法查找) 原型:
void* bsearch (const void* key, const void* base, size_t num, size_t size, int (*compar)(const void*,const void*));
基本定义:
在有序表中，取中间记录作为比较对象，若给定值与中间记录的值相等，则查找成功；若给定值小于中间记录的值，则在中间记录的左半区继续查找；若给定值大于中间记录的值，则在中间记录的右半区继续查找。不断重复上述过程，直到找到为止。
限制条件:
在查找需要对列表进行sort，使列表变为有序状态。
Parameters key-pointer to the element to search for(要搜索元素的指针)ptr-pointer to the array to examine（要检查的数组的指针）count-number of element in the array（数组中的元素数量）size-size of each element in the array in bytes（数组中每个元素的大小）comp-comparison function which returns ​a negative integer value if the first argument is less than the second, a positive integer value if the first argument is greater than the second and zero if the arguments are equivalent.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/31891ca3f32e808e59dde74ca045cae4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a09bfaab9554f4ddbd07b246e0e1ac0/" rel="bookmark">
			堆参数调优入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java7 和 Java8 堆内存的区别 Java7 Java8 JVM 默认占用内存的大小 JVM默认的初始占用内存大小 和 默认的最大占用内存大小 # JVM默认的初始占用内存大小 ：宿主机的 1/64 # JVM默认的最大占用内存大小 ：宿主机的 1/4 通过 java代码怎么查看 JVM 内存大小 public class Test { public static void main(String[] args) { long l = Runtime.getRuntime().maxMemory();//JVM最大占用内存 long l1 = Runtime.getRuntime().totalMemory();//JVM内存总量 System.out.println("max_memory="+l+"字节、"+(l/1024/1024)+"M"); System.out.println("total_memory="+l1+"字节、"+(l1/1024/1024)+"M"); } } # 测试机器为 8G 内存，我们可以看出，最大内存为1/4，当前占用的总内存(最小内存)为 1/64 通过 idea 怎么设置最大占用内存和最小占用内存 设置堆内存大小：-Xms8m -Xmx8m
设置显示GC日志：-XX:+PrintGCDetails
JVM 系统默认值的修改简写 # -Xms： 查看 初始堆 内存大小 # -Xmx： 查看 堆内存 的最大值 # -Xss： 查看 初始栈 空间的大小 JVM 的参数类型 # 标配参数：稳定的、一直都存在的参数 -version 、 -help 。。。 # X参数 -Xint：解释执行 -Xcomp：第一次使用就编译成本地代码 -Xmined：混合模式（java默认）【先编译、后解释】 # XX参数(重点) Boolean类型： 公式： -XX:+ 【表示开启】 -XX:- 【表示关闭】 KV 设值类型： 公式： -XX:属性key=属性值value 标配参数 和 X参数 的使用例子：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a09bfaab9554f4ddbd07b246e0e1ac0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e944c264b0b14173462570184522e3b0/" rel="bookmark">
			51单片机之数码管
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.静态数码管原理图 LED数码管根据LED的不同接法分为两类：共阴和共阳
为了显示数字或字符，必须对数字或字符进行编码。七段数码管加上一个小数点，共计8段。因此为LED显示器提供的编码正好是一个字节。
共阴数码管码表
0x3f , 0x06 , 0x5b , 0x4f , 0x66 , 0x6d
0 1 2 3 4 5
0x7d , 0x07 , 0x7f , 0x6f , 0x77 , 0x7c
6 7 8 9 A B
0x39 , 0x5e , 0x79 , 0x71 , 0x00
C D E F 无显示
静态显示原理
LED显示器工作方式有两种：静态显示方式和动态显示方式。静态显示的特点是每个数码管的段选必须接一个8位数据线来保持显示的字形码。当送入一次字形码后，显示字形可一直保持，直到送入新字形码为止。这种方法的优点是占用CPU时间少，显示便于监测和控制。缺点是硬件电路比较复杂，成本较高。
开发板电路图
74H573锁存器
OE为使能端，当他为低电平的时候， 锁存器开始工VCC和GND为电源和地端LE为锁存端，当LE为高电平的时候，Q0-Q7都跟D0-D7状态一样，当LE为低电平的时候，Q0-Q7都锁存数据，无论D0-D7怎么变化，Q0-Q7都保持锁存之前的那个状态。 #include "reg52.h" #include&lt;intrins.h&gt; typedef unsigned int u16; typedef unsigned char u8; sbit LSA=P2^2; sbit LSB=P2^3; sbit LSC=P2^4; sbit beep=P1^5; u16 code ta[]={0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f}; void delay(u16 i) { while(i--); } void DigDisplay1() { u8 i; u8 j; j=0; for(i=0;i&lt;8;i++) { switch(i) { case(0): LSC=0;LSB=0;LSA=0;P0=ta[1];break; case(1): LSC=0;LSB=0;LSA=1;P0=ta[2];break; case(2): LSC=0;LSB=1;LSA=0;P0=ta[3];break; case(3): LSC=0;LSB=1;LSA=1;P0=ta[4];break; case(4): LSC=1;LSB=0;LSA=0;P0=ta[5];break; case(5): LSC=1;LSB=0;LSA=1;P0=ta[6];break; case(6): LSC=1;LSB=1;LSA=0;P0=ta[7];break; case(7): LSA=1;LSB=1;LSC=1;P0=ta[8];break; } delay(100); P0=0x00; } } void main() { u8 i; while(1) { DigDisplay1(); } } 添加摘要 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e944c264b0b14173462570184522e3b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2d81e886b155e93981fc88a0b9ecfa5/" rel="bookmark">
			WinServer2012 IIS  安装一个或多个角色、角色服务或功能失败。找不到源文件。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		服务器中的IIS安装时，可能本机没有联网。此时可以选择用镜像文件来作为源进行安装 先装载镜像文件
截图抄袭自：https://www.cnblogs.com/Zbuxu/p/13188244.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a871986bda336851325959e055e2765e/" rel="bookmark">
			如何配置选择CH341芯片功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CH341 芯片通过 SCL 和 SDA 引脚配置芯片的功能，可选的芯片功能有：1）USB转异步串口， 2）USB转EPP/MEM并口及同步串口，3）转换并口打印机到USB打印机
有两种配置方式：直接组合配置和外部芯片配置。
直接组合配置： 直接组合配置是将 SCL 引脚和 SDA 引脚进行连接组合，配置 CH341 的功能。其特点是：无需增加额外成本，但是只能使用默认的厂商 ID 和产品 ID 等信息。在直接组合配置方式下，除了产品 ID 之外，其它信息与外部芯片配置的默认值相同。 SCL与SDA的组合与CH341的功能和产品ID的对应关系如下：
SCL和SDA的引脚状态芯片功能默认的产品IDSDA 悬空，SCL 悬空USB 转异步串口，仿真计算机串口5523HSDA 接低电平，SCL 悬空USB 转 EPP/MEM 并口及同步串口5512HSDA 与 SCL 直接相连转换并口打印机到标准 USB 打印机5584H 外部芯片配置： 外部芯片配置是由 SCL 引脚和 SDA 引脚组成两线同步串口，连接外部的串行 EEPROM 配置芯片，
通过 EEPROM 芯片定义芯片功能、厂商 ID、产品 ID 等。配置芯片应该选用 7 位地址的 24CXX 系列芯
片，例如：24C01A、24C02、24C04、24C16 等。其特点是：可以灵活地定义芯片功能和 USB 产品的各
种常用识别信息。通过 Windows 下的工具软件 CH341CFG.EXE，可以随时在线修改串行 EEPROM 中的数
据，重新定义 CH341 的芯片功能和各种识别信息 。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a871986bda336851325959e055e2765e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/004da458cf798aed31d52167bbe7eea0/" rel="bookmark">
			@Mapper的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用SSM做项目的时候，发现大量的配置文件要写，真的蛋疼。要知道懒是推进技术发展的源泉，所以有么有办法可以使用注解，以注解的形式让机器自己帮我们配置这些苦力活，毫无疑问，答案是肯定有的，因为懒，所以有了@mapper注解
和往常开发一样，dao接口层是我们要进行配置的，就在这里配置@mapper注解
@Mapper public interface Inter { @Insert("insert into sysuser values('e212te','2','jjj','pwd','ljk','男',1)") int addUser(); } 有参数的情况
@Mapper public interface Inter { @select("select * from sysuser where userid=#{id}") int queryUserByid(int id); } 多参数情况
@Mapper public interface Inter { @select("select * from sysuser where userid=#{id} and uanme=#{uname}") int queryUserByid(@param("id") int id,@param("uname") String uname); } 如果是实体类呢
@Mapper public interface Inter { @Select("select * from sysuser where userid=#{userid} or username=#{username}") List&lt;Sysuser&gt; selectUser(Sysuser u); } 首先我们肯定要保证的是数据库连接成功，IOC环境一切正常
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/004da458cf798aed31d52167bbe7eea0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9a97f6a21fa484e439aaee6b573890d/" rel="bookmark">
			如何把非正态分布数据转换为正态分布数据？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大部分的数据分析都希望原始数据是满足正态分布的定距变量。然而，显示是残酷的，在各种研究中，常常需要面对非正态分布的定距数据。为了解决数据的正态性问题，数学家们总结了很多转化方法，但是没有万能神药，都需要对症下药（根据数据的实际分布情况，选择合适的转化方法）。
下面不会介绍具体的转化方法，只是帮助大家理顺正态转化的思路，明白正态转化的逻辑，不至于将正态转化看做神秘领域，高不可攀。
正态转化四步骤 第一步：计算数据的分布状况及两个参数：偏度（Skewness）和峰度（Kurtosis）。
第二步：根据变量的分布形状和参数，决定是否做转换。
1、对称判断 看Skewness（偏差度）的取值。如果偏度为0，则是完全对称（但罕见）；如果偏度为正值，则说明该变量的分布为正偏态；如果偏度为负值，则说明该变量的分布为负偏态。然而，偏度值还不能完全判断偏态的分布是否与正态分布有显著差别，所以还需要做显著性检验。如果检验结果显著，我们可能（注意是“可能”）可以通过转换来达到或接近对称。
2、峰度检验 Kurtosis（峰度）是判断曲线陡峭和平缓的指标。如果峰度为0，说明该变量分布合适（但罕见）；如果峰度为正值，说明该变量的分布陡峭；反之，如果峰度为负值，说明变量的分布平缓。峰度也需要通过显著检验来判断与正态分布是否有显著差别。我们可能可以通过转换来达到或接近正态分布。
第三步：如果需要做正态转换，根据变量的分布形状，确定相应的转换公式。下面简单介绍3种常见的正态转换方法
1、如果是中度偏态 如果偏度为其标准误差的2-3倍，可以考虑取根号值来转换。
2、如果高度偏态 如果偏度为其标准误差的3倍以上，则可以取对数，其中又可分为自然对数和以10为基数的对数。
3、对于双峰或多峰数据 秩分的正态得分的转化方法，SPSS软件中常用。
第四步：再次检验转换后变量的分布形状。如果没有解决问题，或者甚至恶化，需要再从第二或第三步重新做起，然后再回到第一步的检验。直至达到比较令人满意的结果。
数据正态化注意点 1、偏度和峰度的标准误差与样本量直接有关。具体说来，偏度的标准误差约等于6除以n后的开方，而峰度的标准误差约等于24除以n后的开方，n为样本量。由此可见，样本量越大，标准误差越小。
2、数据的正态转化方法不是通用的，要根据不同的数据分布情况，选择合适的或创造合适的转化公式，转化后必须验证转化效果，最终达到转化的目的。
3、不是所有的非正态分布的数据都能够通过正态转化而转化为正态分布数据。非正态分布的数据也可以使用非参数方法进行分析。
延伸阅读： 非正态分布数据转换成正态分布
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b4e730d2756c8d55e46ed41e8d7b11a/" rel="bookmark">
			注意力机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：张俊林 链接：https://www.zhihu.com/question/68482809/answer/264632289 来源：知乎 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 注意力模型最近几年在深度学习各个领域被广泛使用，无论是图像处理、语音识别还是自然语言处理的各种不同类型的任务中，都很容易遇到注意力模型的身影。所以，了解注意力机制的工作原理对于关注深度学习技术发展的技术人员来说有很大的必要。
人类的视觉注意力
从注意力模型的命名方式看，很明显其借鉴了人类的注意力机制，因此，我们首先简单介绍人类视觉的选择性注意力机制。
图1 人类的视觉注意力
视觉注意力机制是人类视觉所特有的大脑信号处理机制。人类视觉通过快速扫描全局图像，获得需要重点关注的目标区域，也就是一般所说的注意力焦点，而后对这一区域投入更多注意力资源，以获取更多所需要关注目标的细节信息，而抑制其他无用信息。
这是人类利用有限的注意力资源从大量信息中快速筛选出高价值信息的手段，是人类在长期进化中形成的一种生存机制，人类视觉注意力机制极大地提高了视觉信息处理的效率与准确性。
图1形象化展示了人类在看到一副图像时是如何高效分配有限的注意力资源的，其中红色区域表明视觉系统更关注的目标，很明显对于图1所示的场景，人们会把注意力更多投入到人的脸部，文本的标题以及文章首句等位置。
深度学习中的注意力机制从本质上讲和人类的选择性视觉注意力机制类似，核心目标也是从众多信息中选择出对当前任务目标更关键的信息。
Encoder-Decoder框架
要了解深度学习中的注意力模型，就不得不先谈Encoder-Decoder框架，因为目前大多数注意力模型附着在Encoder-Decoder框架下，当然，其实注意力模型可以看作一种通用的思想，本身并不依赖于特定框架，这点需要注意。 Encoder-Decoder框架可以看作是一种深度学习领域的研究模式，应用场景异常广泛。图2是文本处理领域里常用的Encoder-Decoder框架最抽象的一种表示。
图2 抽象的文本处理领域的Encoder-Decoder框架
文本处理领域的Encoder-Decoder框架可以这么直观地去理解：可以把它看作适合处理由一个句子（或篇章）生成另外一个句子（或篇章）的通用处理模型。对于句子对&lt;Source,Target&gt;，我们的目标是给定输入句子Source，期待通过Encoder-Decoder框架来生成目标句子Target。Source和Target可以是同一种语言，也可以是两种不同的语言。而Source和Target分别由各自的单词序列构成：
Encoder顾名思义就是对输入句子Source进行编码，将输入句子通过非线性变换转化为中间语义表示C：
对于解码器Decoder来说，其任务是根据句子Source的中间语义表示C和之前已经生成的历史信息
来生成i时刻要生成的单词
每个yi都依次这么产生，那么看起来就是整个系统根据输入句子Source生成了目标句子Target。如果Source是中文句子，Target是英文句子，那么这就是解决机器翻译问题的Encoder-Decoder框架；如果Source是一篇文章，Target是概括性的几句描述语句，那么这是文本摘要的Encoder-Decoder框架；如果Source是一句问句，Target是一句回答，那么这是问答系统或者对话机器人的Encoder-Decoder框架。由此可见，在文本处理领域，Encoder-Decoder的应用领域相当广泛。
Encoder-Decoder框架不仅仅在文本领域广泛使用，在语音识别、图像处理等领域也经常使用。比如对于语音识别来说，图2所示的框架完全适用，区别无非是Encoder部分的输入是语音流，输出是对应的文本信息；而对于“图像描述”任务来说，Encoder部分的输入是一副图片，Decoder的输出是能够描述图片语义内容的一句描述语。一般而言，文本处理和语音识别的Encoder部分通常采用RNN模型，图像处理的Encoder一般采用CNN模型。
Attention模型
本节先以机器翻译作为例子讲解最常见的Soft Attention模型的基本原理，之后抛离Encoder-Decoder框架抽象出了注意力机制的本质思想，然后简单介绍最近广为使用的Self Attention的基本思路。
Soft Attention模型（就理解为soft max 的吧！）
图2中展示的Encoder-Decoder框架是没有体现出“注意力模型”的，所以可以把它看作是注意力不集中的分心模型。为什么说它注意力不集中呢？请观察下目标句子Target中每个单词的生成过程如下：
其中f是Decoder的非线性变换函数。从这里可以看出，在生成目标句子的单词时，不论生成哪个单词，它们使用的输入句子Source的语义编码C都是一样的，没有任何区别。
而语义编码C是由句子Source的每个单词经过Encoder 编码产生的，这意味着不论是生成哪个单词，y1,y2还是y3，其实句子Source中任意单词对生成某个目标单词yi来说影响力都是相同的，这是为何说这个模型没有体现出注意力的缘由。这类似于人类看到眼前的画面，但是眼中却没有注意焦点一样。
如果拿机器翻译来解释这个分心模型的Encoder-Decoder框架更好理解，比如输入的是英文句子：Tom chase Jerry，Encoder-Decoder框架逐步生成中文单词：“汤姆”，“追逐”，“杰瑞”。
在翻译“杰瑞”这个中文单词的时候，分心模型里面的每个英文单词对于翻译目标单词“杰瑞”贡献是相同的，很明显这里不太合理，显然“Jerry”对于翻译成“杰瑞”更重要，但是分心模型是无法体现这一点的，这就是为何说它没有引入注意力的原因。
没有引入注意力的模型在输入句子比较短的时候问题不大，但是如果输入句子比较长，此时所有语义完全通过一个中间语义向量来表示，单词自身的信息已经消失，可想而知会丢失很多细节信息，这也是为何要引入注意力模型的重要原因。
上面的例子中，如果引入Attention模型的话，应该在翻译“杰瑞”的时候，体现出英文单词对于翻译当前中文单词不同的影响程度，比如给出类似下面一个概率分布值：
（Tom,0.3）(Chase,0.2) (Jerry,0.5)
每个英文单词的概率代表了翻译当前单词“杰瑞”时，注意力分配模型分配给不同英文单词的注意力大小。这对于正确翻译目标语单词肯定是有帮助的，因为引入了新的信息。
同理，目标句子中的每个单词都应该学会其对应的源语句子中单词的注意力分配概率信息。这意味着在生成每个单词yi的时候，原先都是相同的中间语义表示C会被替换成根据当前生成单词而不断变化的Ci。理解Attention模型的关键就是这里，即由固定的中间语义表示C换成了根据当前输出单词来调整成加入注意力模型的变化的Ci。增加了注意力模型的Encoder-Decoder框架理解起来如图3所示。
图3 引入注意力模型的Encoder-Decoder框架
即生成目标句子单词的过程成了下面的形式：
而每个Ci可能对应着不同的源语句子单词的注意力分配概率分布，比如对于上面的英汉翻译来说，其对应的信息可能如下：
其中，f2函数代表Encoder对输入英文单词的某种变换函数，比如如果Encoder是用的RNN模型的话，这个f2函数的结果往往是某个时刻输入xi后隐层节点的状态值；g代表Encoder根据单词的中间表示合成整个句子中间语义表示的变换函数，一般的做法中，g函数就是对构成元素加权求和，即下列公式：
其中，Lx代表输入句子Source的长度，aij代表在Target输出第i个单词时Source输入句子中第j个单词的注意力分配系数，而hj则是Source输入句子中第j个单词的语义编码。假设下标i就是上面例子所说的“ 汤姆” ，那么Lx就是3，h1=f(“Tom”)，h2=f(“Chase”),h3=f(“Jerry”)分别是输入句子每个单词的语义编码，对应的注意力模型权值则分别是0.6,0.2,0.2，所以g函数本质上就是个加权求和函数。如果形象表示的话，翻译中文单词“汤姆”的时候，数学公式对应的中间语义表示Ci的形成过程类似图4。
图4 Attention的形成过程
这里还有一个问题：生成目标句子某个单词，比如“汤姆”的时候，如何知道Attention模型所需要的输入句子单词注意力分配概率分布值呢？就是说“汤姆”对应的输入句子Source中各个单词的概率分布：(Tom,0.6)(Chase,0.2) (Jerry,0.2) 是如何得到的呢？
为了便于说明，我们假设对图2的非Attention模型的Encoder-Decoder框架进行细化，Encoder采用RNN模型，Decoder也采用RNN模型，这是比较常见的一种模型配置，则图2的框架转换为图5。
图5 RNN作为具体模型的Encoder-Decoder框架
那么用图6可以较为便捷地说明注意力分配概率分布值的通用计算过程。
图6 注意力分配概率计算
对于采用RNN的Decoder来说，在时刻i，如果要生成yi单词，我们是可以知道Target在生成Yi之前的时刻i-1时，隐层节点i-1时刻的输出值Hi-1的，而我们的目的是要计算生成Yi时输入句子中的单词“Tom”、“Chase”、“Jerry”对Yi来说的注意力分配概率分布，那么可以用Target输出句子i-1时刻的隐层节点状态Hi-1去一一和输入句子Source中每个单词对应的RNN隐层节点状态hj进行对比，即通过函数F(hj,Hi-1)来获得目标单词yi和每个输入单词对应的对齐可能性，这个F函数在不同论文里可能会采取不同的方法，然后函数F的输出经过Softmax进行归一化就得到了符合概率分布取值区间的注意力分配概率分布数值。
绝大多数Attention模型都是采取上述的计算框架来计算注意力分配概率分布信息，区别只是在F的定义上可能有所不同。图7可视化地展示了在英语-德语翻译系统中加入Attention机制后，Source和Target两个句子每个单词对应的注意力分配概率分布。
图7 英语-德语翻译的注意力概率分布
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b4e730d2756c8d55e46ed41e8d7b11a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/291089def592ffb41b602cf4b0628c5c/" rel="bookmark">
			NumPy数组的高级操作第五关
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		NumPy(Numerical Python) 是 Python 语言的一个扩展程序库，支持大量的维度数组与矩阵运算，此外也针对数组运算提供大量的数学函数库。是在学习机器学习、深度学习之前应该掌握的一个非常基本且实用的Python库。
本实训将介绍NumPy的一些更高级的知识与使用方法。实训通关后你将学会NumPy的进阶使用技能，并为后续的综合练习部分打好基础。如果你对NumPy的基础知识不熟，可以看看这里。
PS：若需要更加详细的查阅NumPy所提供的接口，可以查阅官方文档。
任务描述
相关知识
numpy的线性代数
常用函数
编程要求
任务描述
本关任务：编写一个能求解线性方程的函数。
相关知识
为了完成本关任务，你需要掌握：1.如何使用numpy进行矩阵运算；2.点积和matmul的区别。
numpy的线性代数
线性代数（如矩阵乘法、矩阵分解、行列式以及其他方阵数学等）是任何数组库的重要组成部分，一般我们使用*对两个二维数组相乘得到的是一个元素级的积，而不是一个矩阵点积。因此numpy提供了线性代数函数库linalg，该库包含了线性代数所需的所有功能。
常用的numpy.linalg函数：
函数 说明
dot 矩阵乘法
vdot 两个向量的点积
det 计算矩阵的行列式
inv 计算方阵的逆
svd 计算奇异值分解（SVD）
solve 解线性方程组 Ax=b，A是一个方阵
matmul 两个数组的矩阵积
常用函数
dot()：该函数返回俩个数组的点积。对于二维向量，效果等于矩阵乘法；对于一维数组，它是向量的内积；对于N维数组，它是a的最后一个轴上的和与b的倒数第二个轴的乘积。
a=np.array([[1,2],[3,4]])
a1=np.array([[5,6],[7,8]])
np.dot(a,a1)
‘’’
输出：array([[19, 22],
[43, 50]])
‘’’
det()：该函数用于计算输入矩阵的行列式。
a = np.array([[14, 1], [6, 2]])
a=linalg.det(a)
print(a)
‘’’
输出：21.999999999999996
‘’’
inv()：该函数用于计算方阵的逆矩阵。逆矩阵的定义维如果两个方阵A、B，使得AB = BA = E，则A称为可逆矩阵，B为A的逆矩阵，E为单位矩阵。
a=np.array([[1,2],[3,4]])
b=linalg.inv(a)
print(np.dot(a,b))
‘’’
输出：array([[1.0000000e+00, 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/291089def592ffb41b602cf4b0628c5c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1466896fc1a6a174ba74f49f659b43ef/" rel="bookmark">
			Ubuntu安装MySQL8.0，并用Navicat远程连接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.安装MySQL sudo apt-get install mysql-server 2.查看默认用户名和密码 新版的MySQL安装后，默认用户名不是root，为了方便，一般我们需要修改成我们想要的用户名和密码。进入配置文件：
root@vivobook:/home/thanlon# vim /etc/mysql/debian.cnf debian.cnf: # Automatically generated for Debian scripts. DO NOT TOUCH! [client] host = localhost user = debian-sys-maint password = UwPyJArufIVRvuYC socket = /var/run/mysqld/mysqld.sock [mysql_upgrade] host = localhost user = debian-sys-maint password = UwPyJArufIVRvuYC socket = /var/run/mysqld/mysqld.sock 可以看到配置文件中的默认用户名和密码，在这里我们先使用配置文件中的用户名user和password登录到数据库。
3.使用默认用户登陆MySQL mysql -udebian-sys-maint -p 4.修改用户名和密码 查看mysql中默认数据库：
show databases; 使用数据库mysql：
use mysql; 将root用户的密码设置为空：
update user set authentication_string='' where user='root'; 注意：不可以使用update user set authentication_string=password(密码) where
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1466896fc1a6a174ba74f49f659b43ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4772f735d1e0d65a47d6c7c04ca99abb/" rel="bookmark">
			排序算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		排序 排序：将一个数据元素（或记录）的任意序列，重新排列成一个按关键字有序的序列。
排序的稳定性：两个元素Ri、Rj(i!=j)，其对应的关键字Keyi=Keyj，且在排序前Ri在Rj前面，如果使用排序算法排序后，Ri仍然在Rj的前面，则称这个排序算法是稳定的，否则称排序算法是不稳定
插入排序 直接插入排序 将一个记录插入到已排好序的有序表中，从而得到一个新的、记录数增1的有序表，直到所有记录插入到有序表中。
#include&lt;iostream&gt; using namespace std; void InsertSort(int a[],int n) { int j; for(int i=2;i&lt;=n;i++) { if(a[i]&lt;a[i-1]) { a[0]=a[i]; for(j=i-1;a[0]&lt;a[j];j--) { a[j+1]=a[j]; } a[j+1]=a[0]; } cout&lt;&lt;"i="&lt;&lt;i&lt;&lt;": "; for(int k=0;k&lt;=8;k++) cout&lt;&lt;a[k]&lt;&lt;" "; cout&lt;&lt;endl; } } int main() { int a[]={0,49,38,65,97,76,13,27,49}; cout&lt;&lt;"排序前序列: "; for(int i=1;i&lt;=8;i++) cout&lt;&lt;a[i]&lt;&lt;" "; cout&lt;&lt;endl; InsertSort(a,8); cout&lt;&lt;"排序后序列: "; for(int i=1;i&lt;=8;i++) cout&lt;&lt;a[i]&lt;&lt;" "; cout&lt;&lt;endl; return 0; } 运行结果：
直接插入排序的排序稳定性是稳定的，时间复杂度O(n2)
折半插入排序 在插入之前，需找到插入的位置，因此在查找的部分，可以使用折半查找已排好序的序列。查找部分使用折半，其他与直接插入排序类似。
#include&lt;iostream&gt; using namespace std; void BInsertSort(int a[],int n) { int low,high,mid; for(int i=2;i&lt;=n;i++) { a[0]=a[i]; low=1,high=i-1; while(low&lt;=high) { mid=(low+high)/2; if(a[mid]&gt;a[0]) high=mid-1; else low=mid+1; } for(int j=i-1;j&gt;=high+1;j--) a[j+1]=a[j]; a[high+1]=a[0]; cout&lt;&lt;"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4772f735d1e0d65a47d6c7c04ca99abb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79f06438cd91afe743201bec439156db/" rel="bookmark">
			router-view 组件间传值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		情况一：router-view 子组件发生变化导致父组件发生改变
父组件中：
&lt;router-view @getMessage="showMsg"&gt;&lt;/router-view&gt; showMsg (val) { // methods方法 val即为子组件传过来的值 console.log(val) } 子组件中：
this.$emit('getMessage', “传给父组件的值”); } 情况二：router-view 父组件发生变化导致子组件发生改变
父组件中：
&lt;router-view :searchVal="searchVal"&gt;&lt;/router-view&gt; searchVal: '', // data里面申明 this.searchVal = ‘需要传给子组件的值’; // 在需要传值的方法中处理 子组件中：
props: ['searchVal'], watch: { searchVal: function (val) { console.log(val); // 接收父组件的值 } }, 以此来记录下，总是容易弄混
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/790d4ff7b0b1d05c5a4a00771b3d3fb3/" rel="bookmark">
			图形学入门：坐标变换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在几何阶段，我们不妨想象这样一个过程：我们在真实世界中，是如何拍照的呢？
1，寻找拍摄对象（模型变换）
2，摆放相机（相机变换）
3，调节相机参数（投影变换）
4，拍照（视口变换）-&gt;光栅化（下一阶段）
首先看一下坐标变换的原理:
蓝色坐标系在红色坐标系中的表示：
首先由于蓝色坐标系跟红色坐标系的坐标方向是相反的，所以在矩阵中，单位向量的值为负值。
模型变换
将本地坐标变换为世界坐标：比如我想要将一个模型导入UE4，这个模型本身是有形状的，它各个顶点的相对位置都是固定的，所以有一个本地的坐标。而我要将这个模型导入世界，它在世界中就要有自己的坐标，这个过程就是模型变换。
这个过程里，矩阵是四维的。（三维的单位向量+一个相对坐标值）
具体的变换过程如图：要得到本地模型在世界中的坐标，首先要有一个模型变换矩阵，这个矩阵就是M。
M相对世界的偏移是(0,0,-5)，那么模型变换矩阵就是一个单位矩阵+偏移量。本地坐标P是(0,3,0)，而其
向量对应就是(0,3,0,1)，1代表它是一个点。世界坐标就是MP。
相机变换
比如相机坐标的偏移是（0,0,5），那么相机坐标系就是单位矩阵+偏移量。那么相机坐标是否就是Mview*Mmode呢？
答案是错；
要得到相机坐标下的位置，首先要把相机坐标系移动到世界坐标系中，即相机坐标系的逆变换。
所以相机坐标系就如上图所示
正交投影变换
正交投影：设置相机时会设置一个视锥体，那么从相机的位置看来，其他的坐标就已经固定好了。
步骤如下：
1，移动视锥体到相机坐标的中心。
2，归一化，将边的大小缩放到-1到1之间。
3，Z的方向要反向，z本来是默认指向屏幕外的方向，但这并不是相机拍摄的方向。
1，位移矩阵
最后就是，相机会从视锥体的中心向外看。
2，缩放矩阵
3，Z反向矩阵
只把Z轴的单位向量取反即可
最后，矩阵运算
这里注意，最先运算的放在最右边，最晚运算的放在最左边，这是矩阵乘法的性质。因为矩阵乘法对顺序敏感。
最后合成的正交变换投影矩阵就是这个。
所需参数：6个。即近平面和远平面的两个点，是一个对角线。Xmax,Ymax,Zmaxa,Xmin,Ymin,Zmin。将这两个点的值代入，即可得到矩阵。
透视投影
符合近大远小原理的投影
上图的左图就是原始图的俯视图，右图是从x轴负方向看过去的图。可以看出Znear/Z=Xp/X;
Z值为了符合习惯，要乘以-1取反方向，上下同乘以一个z，再经过变化，可以得到右侧的矩阵。
然后对应平面上的所有点乘以这个矩阵，就会得到投射的对应点。
视口变换
将（-1,1）范围转换到屏幕坐标，深度值从（-1,1）转换到（0,1），缩放2倍
1，缩放
2，移动
合成到一起之后就变成了了下图的公式；（左侧移动，右侧缩放）：
移动：(Xmin+Xmax)/2,(Ymax+Ymin)/2,1/2;
缩放：(Xmax-Xmin)/2,(Ymax-Ymin)/2,1/2;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97596f39376f83c0e33c074fbb4b64d0/" rel="bookmark">
			nba2konline2 竞品分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		nba2konline2 游戏模式页面布局不好，很难让新手找到需要做的事情的窗口，并且希望球员交易界面能增加返回功能而不是直接返回到搜索之前界面，让用户很不舒服从而影响用户体验。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57825fe093664a301220253668f2e23f/" rel="bookmark">
			simulink中使用FFT tool进行信号频域分析方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		趁着simulink run的功夫。把今天遇到的问题总结下。
最初只是想对电流的输入信号进行FFT，看看直流分量的大小，依稀记得simulink 中的电力电子库中是带有FFT的tool的。但是无奈运气不佳，在web 中各种寻找教程，能不能成功将波形log 到workspace。只能自己默默研究(╥╯^╰╥)。还行最后也是成功了，先将步骤总结如下，供参考（matlab2019版）：
step 1打开你要准备进行FFT的信号的scope(其实log任意信号都行) step2:点击属性配置-&gt;点击log -&gt;勾选logdata 输入name以及选择类型 。
step3:一般其他的经验贴到这步就可run了，但是可能是版本的问题，还需要下面配置。还有就是要将single simulation &gt; output 给去掉，这样log出去的数据就会是一个一个包，FFTtool才 能够识别，而不会又被给封装到out中。 &gt; step4：打开FFT tool &gt; step5：刷新，配置参数分析就OK了。 end
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da631d2d437e19667d4e7c12034fb182/" rel="bookmark">
			Hello Mr.J——这刷题也就2000分水平
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从上次总结以来，断断续续的边看书边继续做题，书没看下去多少，题做的还行吧，最严重的问题是每天处理的事情比较多，回到家吃了饭躺在场上看直播就完全不会去想继续做做题的事情了，看起来是我跟进的东西比较多吧，分散的注意力太多了，以后想做的事情可以尽量分配给其他人做做看，不然很难腾出自己的时间来。
之前说要看算法导论来着，确实看了，大概看了没几节就看不下去了，这本书怎么说呢，就感觉需要硬啃，或者有一些代码基础然后进阶学习理论的时候更合适，看来我还差了一些，看着满屏幕的公式和说明，看着看着就满脑子反手一个超级加倍闷声发大财了，心理浮躁果然没法静心看书。
上次给自己定的目标是leetcode 100题达成，这个倒是在8月底完成了，这期间试着把能想到的每个题方案尽量都运行了一下，看着我完全没思路的题被标记成easy也是挺难受的，不过抗住精神打击之后做来还挺好玩的，做题的过程不只是思考把这道题解决掉，是提交完成后看题解，学习其他代码写法，看看比你快的提交到底哪里快，看一下同等套路的题目是否有了思路，一直持续着直到做完总结的。
这个会也是我第二阶段的目标，暂定先把leetcode的explore里面的数据结构的题学一下吧，每种题型和结构做一些总结，像其他博客一样写写gitbook之类的。
再后面还是要回来啃算法导论，至于这几天先缓缓学别的吧，再看那本书要吐了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a1ee5003c48993257e34c346215a9d7/" rel="bookmark">
			List存储对象根据某个属性去重的三种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、废话不多说直接上代码，第一种采取的是重写hashCode和equals的方法，后面两种都是使用java8新特性
2、对象代码：
@Data public class ImportResume { private Integer age; private String phone; //用于去重 @Override public boolean equals(Object object){ ImportResume importResume=(ImportResume)object; return phone.equals(importResume.phone); } @Override public int hashCode(){ String in = phone; return in.hashCode(); } } 3、java代码：
public void save(List&lt;ImportResume&gt; list) { long l = System.currentTimeMillis(); System.out.println("去重前"+list.size()); Set&lt;ImportResume&gt; set=new HashSet&lt;&gt;(list); System.out.println("set"+set.size()); List&lt;ImportResume&gt; resumeList=new ArrayList&lt;&gt;(set); long l1 = System.currentTimeMillis(); long l2 = l1 - l; System.out.println("去重后"+resumeList.size()+"时间:"+l2); long l3 = System.currentTimeMillis(); ArrayList&lt;ImportResume&gt; collect = list.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a1ee5003c48993257e34c346215a9d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0444a2586e00872c80407cbadcbb79db/" rel="bookmark">
			判断鼠标点击到UI上
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 判断鼠标点击到UI上 主要代码（unity自带方法） if (EventSystem.current.IsPointerOverGameObject()) return; 改进代码 void Update(){ if (IsPointerOverGameObject(Input.mousePosition)) return; } private bool IsPointerOverGameObject(Vector2 mousePos) { PointerEventData eventData = new PointerEventData(EventSystem.current); eventData.position = mousePos; List&lt;RaycastResult&gt; listResult = new List&lt;RaycastResult&gt;(); EventSystem.current.RaycastAll(eventData, listResult); return listResult.Count &gt; 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba08ec4bd9949235e32111494fbd560d/" rel="bookmark">
			Product-based Neural Networks
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、背景：
二、PNN(Product-based Neural Networks )
motivation
PNN网络结构
IPNN
OPNN网络结构图
PNN*
三、EXPERIMENTS
四、相关部分 五、参考
一、背景： 基于DNN的ctr预估存在特征维度爆炸及极度稀疏，且未考虑特征之间的交互性。理解深度神经网络——DNN(Deep Neural Networks) | 码农家园
上一版本ctr预估使用的是DNN模型：Deep Neural Network(DNN)
下图为DNN网络结构， 其本质就是传统的多层感知机（MultiLayer Perceptron，简称MLP）。在MLP网络中，输入是原始的特征n维特征空间，假设第一层隐层节点数为H1，第二层为H2，以此类推。在第一层网络中，需要学习的参数就是n*H1。对于大多数CTR模型来说，特征体系都极其庞大而且稀疏，典型的特征数量级n从百万级到千万级到亿级甚至更高，这么大规模的n作为网络输入在ctr预估的工业界场景中是不可接受的。DNN待学习参数： n*H1+H1*H2+H2*H3+H3*o(o为输出层大小，在ctr预估中为1）
DNN模型结构
存在的问题：
DNN的输入往往是dense real vector， 但是对于类别型特征通常需要one-hot，得到的结果是高维且稀疏的。目前ltr使用的特征有七十二维，存在的问题是非常稀疏，0值较多。 解决方案：对特征进行Embedding，通过加入Embedding Layer将输入映射到低维度的Embedding空间中。 通常，NN层之间都使用“add operation” ，通过激活函数来引入非线性。实际应用场景中“product”相比“add”能更好得捕捉特征间的交互属性，（eg：相关性高且是重要公司与相关性高和重要公司，画图表示交集和并集的关系）。DNN直接把Embedding之后的特征或者原始特征输入到神经网络中进行计算对特征的交叉组合不充分，没有考虑特征之间的相互性关系。 二、PNN(Product-based Neural Networks ) motivation 通过Embedding解决高维稀疏问题“product”相比“add”能更好得捕捉特征间的dependence，在DNN结构中引入product layer更好地学习不同Field特征间的相关性 PNN网络结构 Embedding + Product + MLP
Embedding Layer：最开始的输入太稀疏维度太高，没法直接放到DNN中去学习，所以比较通用的做法就是通过Embedding到一个低维的稠密的实数向量中，作为原始特征的在Embedding空间中的表示。Embedding Layer跟DeepFM中相同，将每一个field的特征转换成同样长度的向量。
Product Layer：然后PNN利用Product Layer来学习filed之间的交互特征，这也就引入了非线性的组合特征。可以采用内积、外积、内积+外积的形式。Full-connect Layer：最后利用全连接层充分的学习高阶组合特征，并得到最终CTR预测概率。 （1）Input: 一个Field就是一个类别型特征。注意：上图中的Input是one-hot之后的，而且只给出了类别型特征。所以每个Field都是一个向量，向量的大小就是类别型特征one-hot之后的维度，即不同Field的维度是不同的。
（2）Embedding Layer： Embedding是Field-wisely Connected，就是一个Field只与一个embedding关联，Field之间网络的权重毫无关系（看箭头）。而且只有权重，没有bias。一个Field经过嵌入后，得到一个Feature，也就是对应的Embedding Vector嵌入向量。其维度一般是预先设定好的定值，论文中采用的是10。也就说是不同Feature的维度都是一样的。
（3）Product Layer： Product Layer分为两部分，一部分叫做z，一部分叫做p。我们说下结论：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba08ec4bd9949235e32111494fbd560d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2bc3bfb28fd754fe095253c7e4889be7/" rel="bookmark">
			执行shell命令，在脚本中直接执行有结果显示，赋值给变量然后打印却没有结果？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这种问题第一反应应该是有缓冲没有刷新出来，那为啥直接执行会显示，赋值执行的时候没有呢？
直接执行的时候，命令执行完成之后，强制刷新到界面
赋值执行的时候，因为执行命令后结果内容比较少，导致在赋值的时候因为缓冲内容不够所以没有刷新给变量，这个时候就需要强制刷新一下
定位这类问题最好的办法是：想办法让输出的数量比较大然后验证结论是否符合预期
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d0633364bb3ed80122da896855f8ecf/" rel="bookmark">
			ROS多Topic接收的时间同步
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ROS多Topic接收的时间同步 ROS多Topic接收的时间同步。网上一搜教程挺多的，但是都是官网上的两个Topic的同步，说明文档说C++支持9个通道，如何同步两个以上的Topic我也摸索了很久，记录一下。
代码 这里采用的是近似同步的方式。
1）两个Topic的代码
void packetCallback(const joint::packet::ConstPtr &amp;packet,const joint::packet::ConstPtr &amp;packet2) { t=packet-&gt;t; cout &lt;&lt; "time: " &lt;&lt;t &lt;&lt; endl; cout&lt;&lt;"time2:"&lt;&lt;packet2-&gt;t&lt;&lt;endl; } main(int argc, char **argv) { ros::init(argc, argv, "joint"); ros::NodeHandle nh; //要订阅的2个Topic message_filters::Subscriber&lt;joint::packet&gt; uav1_sub(nh, "/uav1_packet", 1); message_filters::Subscriber&lt;joint::packet&gt; uav2_sub(nh, "/uav2_packet", 1); typedef sync_policies::ApproximateTime&lt;joint::packet,joint::packet&gt; MySyncPolicy; Synchronizer&lt;MySyncPolicy&gt; sync(MySyncPolicy(10), uav1_sub,uav2_sub); //queue size=10 sync.registerCallback(boost::bind(&amp;packetCallback ,_1, _2)); ros::spin(); return 0; } 2）三个Topic的代码
void packetCallback(const joint::packet::ConstPtr &amp;packet,const joint::packet::ConstPtr &amp;packet2,const joint::packet::ConstPtr &amp;packet3) { t=packet-&gt;t; cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d0633364bb3ed80122da896855f8ecf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/847d5d4dd1713c63ad9a001bc98e380e/" rel="bookmark">
			Python 中fractions模块下Fraction函数使用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Python 中fractions模块下Fraction函数使用方法 Fraction函数支持分数运算，输入参数可以是一对整数，一个分数，一个小小数或者一个字符型数字。
1.Fraction(分子=0, 分母=1)
默认参数分子为0，分母为1。
输入两个整数(分别作为分子、分母)，返回两数约分后的结果。
&gt;&gt;&gt; Fraction() Fraction(0, 1) &gt;&gt;&gt; Fraction(10,6) Fraction(5, 3) &gt;&gt;&gt; Fraction(1,2) Fraction(1, 2) 2.Fraction(浮点数)
输入浮点数，会返回该数的分子分母形式。
&gt;&gt;&gt; Fraction(3.5) Fraction(7, 2) 3.Fraction(分数)
输入分数，会返回该数的分子分母形式。
&gt;&gt;&gt; Fraction(3/2) Fraction(3, 2) 4.Fraction(十进制整数)
输入一个整数，默认输入的是分子，分母为1。
&gt;&gt;&gt; Fraction(4) Fraction(4, 1) 5.Fraction(字符串)
输入字符型数字，会返回该数的分子分母形式。
&gt;&gt;&gt; Fraction('4.2') Fraction(21, 5) &gt;&gt;&gt; Fraction('5/3') Fraction(5, 3) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/826c6601fc2fe009f1fd19662053639c/" rel="bookmark">
			【学习笔记】电机学
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		电枢的感生电动势
E a = C e n Φ E_a=C_e n \Phi Ea​=Ce​nΦ，其中 C e = p N 60 a C_e=\frac{pN}{60a} Ce​=60apN​为电动势常数 电枢的电磁转矩
T e = C T Φ I a T_e =C_T \Phi I_a Te​=CT​ΦIa​，其中 C T = p N 2 π a C_T=\frac{pN}{2 \pi a} CT​=2πapN​为转矩常数 式中:
Φ \Phi Φ：每极的总磁通量
n n n：转速
I a I_a Ia​：电枢电流
p p p：电机的极对数
N N N：电枢绕组的总导体数
a a a：电枢绕组的支路对数
对于单叠绕组， a = p a=p a=p；对于单波绕组， a = 1 a=1 a=1 直流发电机的电压方程
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/826c6601fc2fe009f1fd19662053639c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97bc1c9a605d87e4bfbbd9ad6f1f3f07/" rel="bookmark">
			Git中的merge和rebase
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		merge和rebase
git的merge和rebase都是用来合并分支的, 将一个分支的更改并入另一个分支。
git merge：将两个分支，合并结果提交为一个新提交，并且此新提交有2个parent。
比如现在的工程是这样的, 箭头是指向当次提交的父节点.
在此基础上执行merge, 会在 新分支上生成一个新的commit.C7有2个父节点
git rebase：会取消合并分支中的每个提交，并把他们临时存放，然后把当前分支更新到最新的origin分支，最后再把所有提交应用到分支上。
git rebase 可以把它理解成是“重新设置基线”，将你的当前分支重新设置开始点。这个时候才能知道你当前分支于你需要比较的分支之间的差异。
原理很简单：rebase需要基于一个分支来设置你当前的分支的基线，这基线就是当前分支的开始时间轴向后移动到最新的跟踪分支的最后面，这样你的当前分支就是最新的跟踪分支。
先把C5,C6生成一份拷贝, 然后在当前分支更新到最新的C4, 在把复制后的C5' 和C6'加到C4的后面, 旧的C5,C6会被删除
什么是分支
分支就是便于多人在同一项目中的协作开发。比方说：每个人开发不同的功能，在各自的分支开发过程中互不影响，完成后都提交到develop分支。极大的提高了开发的效率。
合并分支
每个人创建一个分支进行开发，当开发完成，需要合并到develop分支的时候，就需要用到合并的命令。
什么是冲突
合并的时候，有可能会产生冲突。
冲突的产生是因为在合并的时候，不同分支修改了相同的位置。所以在合并的时候git不知道那个到底是你想保留的，所以就提出疑问（冲突提醒）让你自己手动选择想要保留的内容，从而解决冲突。
merge和rebase的区别
1、采用merge和rebase后，git log的区别，rebase命令不会保留分支信息, 看不到分叉点：
2、处理冲突的方式：
（一股脑）使用merge命令合并分支，解决完冲突，执行git add .和git commit -m'fix conflict'。这个时候会产生一个commit。（交互式）使用rebase命令合并分支，解决完冲突，执行git add .和git rebase --continue，不会产生额外的commit。这样的好处是，‘干净’，分支上不会有无意义的解决分支的commit；坏处，如果合并的分支中存在多个commit，需要重复处理多次冲突。 3、git pull和git pull --rebase区别
git pull = git fetch + git merge 。
git pull --rebase 多加了rebase就是以rebase的方式进行合并分支，相当于是git fetch + git rebase
如何选择合并分支的方式
合并的目的就是能够有效的管理代码, 当你是新手时, 无脑使用merge就行了, 当你觉得merge不好看, 时间线比较乱, 那认真的理解下rebase的作用, 然后在合适的情况下选择rebase或merge。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/97bc1c9a605d87e4bfbbd9ad6f1f3f07/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60cef229e1c13664053f9283d300825f/" rel="bookmark">
			明码（进制转换）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include&lt;iostream&gt; using namespace std; int main(){ int m,n,w[16]; while(cin &gt;&gt; m &gt;&gt; n){ for(int i = 7;i &gt;= 0;i--){//注意数组是从0开始的 w[i] = m&amp;1; m &gt;&gt;= 1;//向左移位操作，判断其是不是1 } for(int i = 15;i &gt;= 8;i--){ w[i] = n&amp;1; n &gt;&gt;= 1; } for(int i = 0;i &lt;= 15;i++){ if(w[i] != 0){ cout &lt;&lt; w[i] &lt;&lt; " "; }else{ cout &lt;&lt; " " &lt;&lt; " "; } } cout &lt;&lt; endl; } return 0; } 题目链接
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60cef229e1c13664053f9283d300825f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab6f8a8809b3b8b6f3a1c933389b3217/" rel="bookmark">
			STM32 CUBEIDE MacOS首次使用笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文参考代码
https://letanphuc.net/2015/02/stm32f0-tutorial-gpio-blinking-led-cubemx-keil-source-insight/
ide版本信息：
STM32CubeIDE Release Note v1.4.0
CubeMX V6.0.0 integration
Additional support for STM32MP1 devices : OpenSTLinux 2.0 SDK &amp; Projects support
Additional support for STM32H7 devices
itional support for STM32G4 devices
OpenOCD support improvements
It uses an enhanced GNU tool chain for STM32, based on GNU Arm Embedded.
It has an integrated version of STM32CubeMX and MCUFinder
ntegrates the command-line version of STM32CubeProgrammer (STM32CubeProg) for Flash memory handling while using the ST-LINK GDB server.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab6f8a8809b3b8b6f3a1c933389b3217/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4be2519bcd36871744fce4d9fe98de70/" rel="bookmark">
			C&#43;&#43;11，C&#43;&#43;14，C&#43;&#43;17以及C&#43;&#43;20所有新特性总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在github上有人总结了：
C++新特性总结
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56b288e7364f8a53acff3e8caae6a24a/" rel="bookmark">
			爬梯：设计模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		资料学习整理自：B站尚硅谷
我自己写了套代码理解，已上传 码云
由于设计模式是个大题，内容繁多，我的计划是先学部分常用的，再逐步全面化。
设计模式 Design Pattern
概念介绍
1）设计模式是程序员在面对同类软件工程设计问题所总结出来的有用的经验，是某类问题的通用解决方案，设计模式代表了最佳的实践。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。
2）设计模式的本质提高软件的维护性、通用性和扩展性，并降低软件的复杂度。
类型
23个设计模式分为三种类型：
1）创建型模式：单例模式、抽象工厂模式、工厂模式、原型模式、建造者模式；
2）结构型模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式；
3）行为型模式：模版方法模式、命令模式、访问者模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式（Interpreter）、状态模式、策略模式、职责链模式（责任链）。
1、单例模式（创建型） 定义：在整个软件系统中，确保某个类只有一个实例，并且只提供一个获取实例的入口。
场景
重量级对象，不需要多个实例。如：线程池、数据库连接池等
实现方法： 1、饿汉式（静态常量）
private Singleton(){} private static Singleton singleton = new Singleton(); public Singleton getInstance(){ return singleton; } 结论：可能会造成内存浪费。
2、饿汉式（静态代码块）
private Singleton(){} private static Singleton singleton; static{ if(singleton==null){ singleton = new Singleton(); } } public Singleton getInstance(){ return singleton; } 结论：可能会造成内存浪费。
3、懒汉式（单线程）
private Singleton(){} private static Singleton singleton; public Singleton getInstance(){ if(singleton==null){ singleton = new Singleton(); } return singleton; } 结论：多线程不安全。不使用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/56b288e7364f8a53acff3e8caae6a24a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b23b3991a1d1f40f8921d7ef7611238/" rel="bookmark">
			图像处理基本流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 自动光学检查（AOI）
例子：对象的检测和分类
步骤：
1. 预处理 去除噪音和光照效果来得到最佳的二值化图像，从而减少检测错误。
（1）噪声消除 噪声分类：
椒盐噪声 - 中值滤波器 - medianBlur
散粒噪声
高斯噪声
medianBlur(); （2）光消除 （3）二值化 2. 分割 轮廓检测算法 findContours(); 连通组件算法 3. 特征提取 4. 分类处理 5. 后期处理 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cbd1e5767df18eff20dc869b275276ac/" rel="bookmark">
			常用坐标系汇总（更新）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 随着接触的地图种类越来越多，每种产品对地图服务的坐标系的要求不同，今天遇到了整理的好文，整理记录分享。
投影坐标系：墨卡托坐标系地理坐标系：经纬度坐标系 常用坐标系 （一）WGS84坐标系 WGS-84坐标系（World Geodetic System一1984 Coordinate System）
一种国际上采用的地心坐标系。坐标原点为地球质心，其地心空间直角坐标系的Z轴指向BIH （国际时间服务机构）1984.O定义的协议地球极（CTP)方向，X轴指向BIH 1984.0的零子午面和CTP赤道的交点，Y轴与Z轴、X轴垂直构成右手坐标系，称为1984年世界大地坐标系统。
（二）WGS84 Web墨卡托 Web墨卡托是2005年谷歌在谷歌地图中首次使用的，当时或更早的Web墨卡托使用者还是称其为世界墨卡托 World Mercator - Spherical Mercator (unofficial deprecated ESRI)，代号 WKID 54004 （在 EPSG:54004 或 ESRI:54004 中，非官方）。
在2006年，OSGeo在提出的 Tile Map Service (TMS) 标准中使用代号 OSGEO:41001，WGS84 / Simple Mercator - Spherical Mercator (unofficial deprecated OSGEO / Tile Map Service)。
2007年8月6日 Christopher Schmidt （OpenLayers的重要贡献者之一）在通过一次GIS讨论中为了在OpenLayers中使用谷歌投影，提出给谷歌投影（Web墨卡托）使用一个统一的代号（已有如54004、41001之类的代号）900913（也形似 Google），并与同年9月11日在OpenLayers的OpenLayers/Layer/SphericalMercator.js中正式使用代号 900913。
在2008年5月EPSG在6.15版本中正式（可能是谷歌地图取得了巨大成功）给谷歌地图投影赋予 CRS 代号 EPSG:3785（Popular Visualisation CRS / Mercator），这也是Web墨卡托正式被EPSG组织承认（由于Web墨卡托不是标准的地图投影，之前一直没有被EPSG没有收录）。
很快EPSG于2009年2月9号使用新代号EPSG:3857 代替之前的 EPSG:3785，给谷歌地图投影方法命名为“公共可视化伪墨卡托投影”（PVPM），投影运算方法代号 1024。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cbd1e5767df18eff20dc869b275276ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96d3fc1c6bf89d811498aed0f6a6bdb8/" rel="bookmark">
			UTM 投影坐标系条带号Zone与EPSG代号计算（Python 实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#以python 代码为例
#该方法非常简单
import numpy as np
Zone = np.round((183+longitude)/6,0)
print(“Zone is”,zone)
EPSG=32700-np.round((45+Latitude)/90,0)*100+np.round((183+Longitude)/6,0)
EPSG = int(EPSG)
print(“EPSG is”,EPSG)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f60eef63387b529f5066e9187b562da8/" rel="bookmark">
			MySQL死锁 centos数据库死锁解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		发生情况：由于某种错误操作导致数据库死锁
解决方法：
使用xshell连接远程服务器输入命令whereis mysql查看MySQL安装位置
安装位置如图所示，共有四个（不一定，这个服务器上有四个，看个人服务器情况），只能一个个去试，当前使用的是那个数据库（我试到第二个就登录进去了）
cd到MySQL安装位置后，输入命令mysql -u root -p进入数据库，密码可以在宝塔中查看
成功进入数据库后，输入命令select * from information_schema.innodb_trx;查看当前进行的事务
kill掉当前的线程
重新查看是当前事务是否进行
当前已经没有事务再进行，死锁问题解决
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4148ef86f510597e11c6e9501c199ab1/" rel="bookmark">
			java list集合根据时间字段排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 // list列表根据元素中的时间字段进行排序 public List listSort2(List&lt;AppChatApiRes&gt; initList) {// 接收实体类list List&lt;AppChatApiRes&gt; list = initList; // System.out.println("排序前----:" + list); Collections.sort(list, new Comparator&lt;AppChatApiRes&gt;() { @Override public int compare(AppChatApiRes h1, AppChatApiRes h2) { return h1.getRegTime().compareTo(h2.getRegTime()); } }); Collections.reverse(list); // System.out.println("排序后----:" + list); return list; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/533a991bd20defffd59c3cc940f75124/" rel="bookmark">
			宝塔部署nginx后配置反向代理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 server { listen 8085; # 要代理的端口号 server_name localhost; # 名字 location / { root /www/wwwroot/test; # 项目目录 autoindex on; # on表示开启 } } 访问时直接使用 IP+端口号 即可访问 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b210e9eb237f87ca7f8c9ee4413a9775/" rel="bookmark">
			mysql 存在则更新某个字段或不操作，不存在则新增 ON DUPLICATE KEY UPDATE 或REPLACE
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 uid weekly_id已经设置索引（唯一索引）
效果：如果 插入一条uid 跟 weekly_id 相同的数据，则会进行时间的更新 insert into read_not (weekly_id,uid,create_time) values (1,4,now()) ON DUPLICATE KEY UPDATE create_time = now() REPLACE语句实现（未测试，仅作为了解）
使用REPLACE的最大好处就是可以将DELETE和INSERT合二为一，形成一个原子操作。这样就可以不必考虑在同时使用DELETE和INSERT时添加事务等复杂操作了。在使用REPLACE时，表中必须有唯一索引，而且这个索引所在的字段不能允许空值，否则REPLACE就和INSERT完全一样的。在执行REPLACE后，系统返回了所影响的行数，如果返回1，说明在表中并没有重复的记录，如果返回2，说明有一条重复记录，系统自动先调用了DELETE删除这条记录，然后再记录用INSERT来插入这条记录。
语法和INSERT非常的相似，如下面的REPLACE语句是插入或更新一条记录。
REPLACE INTO users (id,name,age) VALUES(1, 'binghe', 18); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d16d69d2df5bd64026dffd92fff8f445/" rel="bookmark">
			java @JsonFormat注解 规定时间日期返回值格式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 用法
@Data public class proRes { @JsonFormat(pattern = "yyyy-MM-dd HH:mm",timezone = "GMT+8") private Date startTime; // pattern 规定返回值的格式； @JsonFormat(pattern = "yyyy-MM-dd HH:mm",timezone = "GMT+8") private Date endTime; } 详解（一搜一大堆）
@JsonFormat(pattern = “yyyy-MM-dd’T’HH:mm:ss.SSSZ”, locale = “zh”, timezone = “GMT+8”) 1.pattern 指定转化的格式SSSZ(S指的是微秒，Z指时区)，此处的pattern和java.text.SimpleDateFormat中的Time Patterns一致 2.locale主要指语言，如果中文的话，月份输出是五月，但是英文就是May，尤其是在反序列化的时候特别重要 3.timezone主要解决“8小时”问题 三、pattern对应关系 Letter Date or Time Component Presentation Examples G Era designator Text AD y Year Year 1996; 96 Y Week year Year 2009; 09 M Month in year Month July; Jul; 07 w Week in year Number 27 W Week in month Number 2 D Day in year Number 189 d Day in month Number 10 F Day of week in month Number 2 E Day name in week Text Tuesday; Tue u Day number of week (1 = Monday, …, 7 = Sunday) Number 1 a Am/pm marker Text PM H Hour in day (0-23) Number 0 k Hour in day (1-24) Number 24 K Hour in am/pm (0-11) Number 0 h Hour in am/pm (1-12) Number 12 m Minute in hour Number 30 s Second in minute Number 55 S Millisecond Number 978 z Time zone General time zone Pacific Standard Time; PST; GMT-08:00 Z Time zone RFC 822 time zone -0800 X Time zone ISO 8601 time zone -08; -0800; -08:00 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22aa934ef8428a4b072f49e5b5411f81/" rel="bookmark">
			java 开启异步 异步注解 @Async
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 需要配合启动类注解 @EnableAsync 使用
注意：异步的调用方法跟被调用方法不能在同一个类中，否则会不生效如果异步方法有返回值，此时获取的方法返回值则会为null。 解决方法：将返回值作为参数，传入方法中，并将方法的返回值改为void 调用异步方法 public Result statistics(@RequestBody ModularTimeParam param) throws Exception { long startTime = System.currentTimeMillis(); // 设置线程锁，多少个子线程，后面的数字就写几 final CountDownLatch latch = new CountDownLatch(7); Map&lt;String,Map&lt;String,Object&gt;&gt; listMap = new HashMap&lt;&gt;(); // 子线程 Map&lt;String,Object&gt; htmlTest = new HashMap&lt;&gt;(); controller.htmlTest(param.getProId(),latch,htmlTest); // 主线程 等待线程执行完毕（为0则为执行完毕） latch.await(); listMap.put("htmlTest",htmlTest); System.out.println("总耗时："+(System.currentTimeMillis() - startTime)+" 毫秒"); return Result.ok("arrange",listMap); } 异步方法 @Async public void htmlTest(int id, CountDownLatch latch,Map&lt;String, Object&gt; map){ map.put("status",flag); latch.countDown(); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42a185bdbac8beeb5b1f82ed8f7daf80/" rel="bookmark">
			MySQL Group By 分组后保留最新一条记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		错误方法：
select a.* from (select * from user order by id desc) a group by a.id 先在子查询中进行倒序排列，查询排列完成的数据
首先 评论区说的对，上面的确实不能用。但是也确实可以用，想省事的小伙伴可以试试，报错或者不能用的话就用下面的方案。上面的方案是跟数据库配置有关，MySQL配置了group by 查询的相关东西
下面是我本次更新时测试的结果
MySQL版本 -&gt; 5.7.26 截图为证！
表中原始数据
正常分组查询结果
这个没毛病吧，就是正常的分组查询。不过是多了个any_value()，具体原因的话你么可以不加，然后测试一下，如果报错就去百度一下，很容易查到。没报错就不用加（最近遇到这个坑的。之前从来没发现过）
符合需求的sql
需要注意的是，子查询里面有个limit 9999，这个要加上，才可以符合需求，不然就跟正常的分组查询结果一样。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64d09690743f6f5ab96160b634fcdc8f/" rel="bookmark">
			任务栏微信图标显示为白框，解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.同时按Windows键+R键打开运行对话框，输入ie4uinit.exe -show然后回车即可修复。
2.打开计算机（Win7），此电脑（Win10）或任意文件夹，然后在地址栏输入cmd.exe /c ie4uinit.exe -show然后回车即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31d329ab2687a5918a140da189d2f206/" rel="bookmark">
			最简单易懂二分法详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		二分法和三分法是算法竞赛中常见的算法思路，本文介绍了它们的理论背景、模板代码、典型题目。
二分法的理论背景
在《计算方法》教材中，关于非线性方程的求根问题，有一种是二分法。
方程求根是常见的数学问题，满足方程：
f(x) = 0 (1-1)
的数x’称为方程(1-1)的根。
所谓非线性方程，是指f(x)中含有三角函数、指数函数或其他超越函数。这种方程，很难或者无法求得精确解。不过，在实际应用中，只要得到满足一定精度要求的近似解就可以了，此时，需要考虑2个问题：
（1）根的存在性。用这个定理判定：设函数在闭区间[a, b]上连续，且f(a) ∙ f(b) &lt; 0,则f(x) = 0存在根。
（2）求根。一般有两种方法：搜索法、二分法。
搜索法：把区间[a, b]分成n等份，每个子区间长度是∆x，计算点xk = a + k∆x (k=0,1,2,3,4,…,n)的函数值f(xk)，若f(xk) = 0，则是一个实根，若相邻两点满足f(xk) ∙ f(xk+1) &lt; 0，则在(xk, xk+1)内至少有一个实根，可以取(xk+ xk+1)/2为近似根。
二分法：如果确定f(x)在区间[a, b]内连续，且f(a) ∙ f(b) &lt; 0，则至少有一个实根。二分法的操作，就是把[a, b]逐次分半，检查每次分半后区间两端点函数值符号的变化，确定有根的区间。
什么情况下用二分？两个条件：上下界[a, b]确定、函数在[a, b]内单调。 图1.1　单调函数
复杂度：经过n次二分后，区间会缩小到(b - a)/2n。给定a、b和精度要求ε，可以算出二分次数n，即满足(b - a)/2n &lt;ε。所以，二分法的复杂度是O(logn)的。例如，如果函数在区间[0, 100000]内单调变化，要求根的精度是10-8，那么二分次数是44次。
二分非常高效。所以，如果问题是单调性的，且求解精确解的难度很高，可以考虑用二分法。
在算法竞赛题目中，有两种题型：整数二分、实数二分。整数域上的二分，注意终止边界、左右区间的开闭情况，避免漏掉答案或者死循环。实数域上的二分，需要注意精度问题。
整数二分模板
2.1 基本形式
先看一个简单问题：在有序数列a[]中查找某个数x；如果数列中没有x，找它的后继。通过这个问题，给出二分法的基本代码。
如果有x，找第一个x的位置；如果没有x，找比x大的第一个数的位置。
图2.1 (a)数组中有x　(b)数组中没有x 示例：a[] = {-12,-6,-4,3,5,5,8,9}，其中有n = 8个数，存储在a[0]～a[7]。
1)查找x = -5，返回位置2，指向a[2] = -4；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/31d329ab2687a5918a140da189d2f206/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae03707097ccd48246b4751dd8fbaf68/" rel="bookmark">
			javax.servlet.ServletException: Servlet[SpringMvc]的Servlet.init（）引发异常处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		javax.servlet.ServletException: Servlet[SpringMvc]的Servlet.init（）引发异常处理 分析错误描述错误原因分析原因解决办法 分析 关于javax.servlet.ServletException: Servlet[SpringMvc]的Servlet.init（）引发异常处理情况
Servlet[SpringMvc]的Servlet.init（）引发异常
错误描述 Servlet[SpringMvc]的Servlet.init（）引发异常
创建Servlet.init（）时失败
错误原因 创建名为“org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter”的bean时出错
我们找到这个类①，它属于spring-webmvc没有什么问题
但是可以知道原因出在springmvc依赖里面
分析原因 检查上面spring版本②，发现与springmvc版本不一致
解决办法 在pom.xml文件中更改spring和springmvc版本一致，再运行（普通项目下载相关版本jar包）
事实证明springmvc的版本在spring的版本以下也是可以运行的。
运行成功！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/315f3562bc2f10b1406443a93e3948a6/" rel="bookmark">
			Linux修改文件的读写权限
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在root用户登录的情况，赋予opt目录给liuhai这个用户权限 示例代码：
# 将目录/opt 及其下面的所有文件、子目录的文件主改成 liuhai chown -R liuhai:liuhai /opt 参数 用户：组：指定所有者和所属工作组。当省略“：组”，仅改变文件所有者； 文件：指定要改变所有者和工作组的文件列表。支持多个文件和目标，支持shell通配符。 ** 实例 ** # 将目录/opt 及其下面的所有文件、子目录的文件主改成 liuhai chown -R liuhai:liuhai /opt 参考：
https://www.cnblogs.com/jiangfeilong/p/11141208.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41fcdd379364b4a2df72db04cbfbd22c/" rel="bookmark">
			Hive架构原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		hive是hadoop的数据仓库处理工具，可以将一些整理后的结构化的数据文件映射一张可供查询的表。Hive底层提供了mapreduce模板，将HQL转化为mapreduce程序，Hive处理的数据保存在hdfs上，执行计算程序通过mapreduce，程序运行在yarn上。
hdfs的结构化文件是底层如何映射的成一张可供查询的表？ 首选，hive的元数据保存在mysql中，记录hive的创建的表、库等信息。通过把hdfs上的文件导入到hive之前创建的表中
hadoop fs -put stu.txt /user/hive/warehouse/xxx.db/xxx_表/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/324de4b182d325b956720b466ad490cf/" rel="bookmark">
			Linux和WIN10路由配置：有线和WIFI双网卡分流
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境：电脑同时连接有线网络（公司内网）和无线网络（手机热点连外网）
目标：既能访问外网（WIFI），又能访问内网（有线），外网优先
关键步骤：
1、首先，将 无线网卡的优先级设置为调高，有线网卡的优先级调低
打开网络适配器，找到网卡，然后点属性，找到IPv4的设置，然后点“高级”，找到 自动跃点，将其取消，设置 跃点值，值越小，优先级越高，比如一个设置为1，一个设置为10。
2、步骤1设置后，内网地址应该访问不了，按下面设置，将内网网段 绑定到 有线网卡上
确定自己要访问的内网网段，比如我想访问的内网网段为 172.16.55.*，转换成网段和子网标识就是：
172.16.55.0/24 或者 172.16.55.0 mask 255.255.255.0，写法不同，两者等价。
然后 查看自己网卡的“默认网关”，Windows的话CMD输入ipconfig查看，我的为有线网卡的默认网关为172.16.50.1。
以下是绑定网段到网卡的命令：
Windows命令：（参考手册）
route add 172.16.55.0 mask 255.255.255.0 172.16.50.1 -p
Mac/Linux命令：
route -n add -net 172.16.55.0/24 172.16.50.1
3、如果有内网域名要解析的话，怎么办
最简单的办法，就是先ping 一下这个域名，看看IP地址是多少，然后按上面的办法将IP段加入网卡绑定，并将域名与IP的映射关系，写在本地 hosts文件中。
还有一个办法，就是将内网DNS地址，加入到 WIFI网卡的DNS服务器列表里，优先级放在最后。
怎么查看内网DNS地址，方法为：右键点击 有线网卡适配器，查看 状态，查看详情，里面有显示。
自定义DNS服务器时，第一个可以设置为 8.8.8.8，或者 114.114.114.114，这两个都是常用的公网DNS服务器。
Linux命令如下： 使用 ip route show 查看路由信息：
default via 172.16.53.1 dev enp0s31f6 proto static metric 100 default via 192.168.43.1 dev wlp58s0 proto static metric 600 169.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/324de4b182d325b956720b466ad490cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fab0057a10c4b26435f702bb0bc2f7e3/" rel="bookmark">
			uniapp中生命周期有哪些
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		应用生命周期（仅可在App.vue中监听）
1.onLaunch ：当 uni-app 初始化完成时触发（全局只触发一次）
App.vue里的onLaunch中option作用：获取用户进入小程序或退出小程序的场景值
2.onShow ：当 uni-app 启动，或从后台进入前台显示 //监听用户进入小程序
3.onHide :当 uni-app 从前台进入后台 //监听用户离开小程序
4.onError :当 uni-app 报错时触发
5.onUniNViewMessage :对 nvue 页面发送的数据进行监听
页面生命周期（在页面中添加）
1.onLoad （监听页面加载）
2.onShow （监听页面显示）
3.onReady （监听页面初次渲染完成）
4.onHide （监听页面隐藏）
5.onUnload :监听页面卸载
6.onResize :监听窗口尺寸变化
7.onPullDownRefresh :监听用户下拉动作，一般用于下拉刷新
当页面中需要用到下拉刷新功能时，打开pages.json，在"globalStyle"里设置"enablePullDownRefresh":true
此时所有页面都可以完成下拉刷新功能
如果想在单个页面中不执行刷新功能：在pages.json里单个页面上添加
如果想在单个页面中执行刷新功能：在pages.json里单个页面上添加
{ "path": "pages/index/index", "style": { "navigationBarTitleText": "首页", "enablePullDownRefresh":true } }, "enablePullDownRefresh":true
8.onReachBottom :页面滚动到底部的事件（不是scroll-view滚到底），常用于下拉下一页数据
9.onTabItemTap :点击 tabBar 时触发
10.onShareAppMessage :用户点击右上角分享
可以在转发时设置转发标题，路径和图片
11.onPageScroll :监听页面滚动
12.onNavigationBarButtonTap :监听原生标题栏按钮点击事件
13.onBackPress :监听页面返回
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fab0057a10c4b26435f702bb0bc2f7e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2dc60d0053420826e403912705a1d1e1/" rel="bookmark">
			金融rate函数解析【附java实现】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Rate本质就是根据PMT公式反推利率而已，但是因为rate没有界限及收敛域所以没法通过简单的极限求解来获取解。
最终就是通过牛顿迭代式，利用切线与曲线的关系构建新的收敛函数，求最优解。
1、构建利率函数【来源PMT公式】
f ( r a t e ) = f v + p v ∗ ( r a t e + 1 ) n p e r + p m t ∗ ( 1 + r a t e ∗ t y p e ) ∗ ( r a t e + 1 ) n p e r − 1 r a t e f(rate)=fv+pv*(rate+1)^{nper}+pmt*(1+rate*type)*\frac{(rate+1)^{nper}-1}{rate} f(rate)=fv+pv∗(rate+1)nper+pmt∗(1+rate∗type)∗rate(rate+1)nper−1​
2、求解利率函数的导数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2dc60d0053420826e403912705a1d1e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff574f1b103e8de6e9f41db79704ebf9/" rel="bookmark">
			跟我一起学.NetCore之依赖注入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
现阶段而言，依赖注入相关组件如果不会用一两个，感觉在Code的世界里肯定是落伍了，最起码得有工厂模式的思想，知道这样做的好处；提及到依赖注入，通常会关联出两个概念：Ioc(控制反转)和DI(依赖注入)
控制反转（Inversion of Control，缩写为IoC），是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度。其中最常见的方式叫做依赖注入（Dependency Injection，简称DI）。通过控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体将其所依赖的对象的引用传递给它。也可以说，依赖被注入到对象中。
百度百科
个人理解：
IoC(控制反转): 就是将原先的new对象这个操作交由第三方容器，由容器统一创建对象并管理其创建对象的生命周期；
DI(依赖注入): 我理解其中“依赖”有两层意思：
类与类之间的依赖关系；
对象的创建依赖于容器；
"注入"：不用主动从容器中获取对象，由容器根据对象依赖关系自动注入；
依赖注入：程序将对象控制权交给容器，统一依赖容器创建对象，类之间的依赖，也是通过容器自动注入；
注：注入的前提是要把对象的控制权交给容器；
依赖注入优点：
轻松管理类及类之间的依赖；
减少代码耦合性；
提高代码维护性和可扩展性；
由容器统一创建对象和管理生命周期；
好了，先不详细深究了，这里先说说.NetCore中自带的依赖注入框架怎么玩；
正文
先看看.NetCore中的自带的依赖注入怎么用，先创建一个Asp.NetCore 程序：
上图是模板程序，只在Action 方法中直接使用了模板中已经注入好_logger的对象，此对象通过构造函数的形式注入，刚开始接触的Asp.NetCore的小伙伴会疑问，都没注册对应服务，怎么会注入，其实在我们启动过程的时候简单说到过，框架会自动注入一些默认的服务，其中就用ILogger，用起来就是这么简单；
.NetCore中依赖注入有几个关键的类型，简单介绍一下：
IServiceCollection：负责存储注册的服务，可以通过其扩展方法进行服务注册；
ServiceDescriptor：服务注册时的信息，如服务类型、实现类型、实例类型、生命周期等；
IServiceProvider： 理解是常说的容器，是IServiceCollection创建出来的，用来提供实例的；
IServiceScope：表示一个容器的子容器的生命周期；
通过以上可以简要理解注入的简要过程：
通过容器创建的出来的对象，根据不同的注入方式有以下三种生命周期：
Singleton(单例) ：整个根容器的生命周期内是同一个对象；通过 services.AddSingleton()方法进行注册；
Scoped(作用域) ：在容器或子容器的生命周期内，对象保持一致，如果容器释放掉，那就意味着对象也会释放掉；通过 services.AddScoped()方法进行注册；
Transient(瞬时) ： 每次使用都会创建新的实例；通过 services.AddTransient()方法进行注册；
注：services 是 IServiceCollection services ；
以下通过程序演示常用的注入方法及其对应的生命周期；在以上创建的项目中针对不同的生命周期添加不同的类型，里面没有任何代码，如下图；
在Startup文件的ConfigureServices方法中进行注册，如下：
注册完毕之后，在Controller中的Action方法就可以使用了，如下：
通过对比每个对象的HashCode, 如果一样就代表是同一个对象，运行程序看结果(这里以项目的形式运行，在控制台中方便看输出)：
以上实例只是常规注册方式，还有以下常用注册方式，如下图；
新增一个IUserService，方便后续演示
Asp.NetCore自带依赖注入的注册方式，如下：
增加一个Action方法，打了个断点运行调试：
其他注入方式就不一一运行演示了，这里主要演示排他注册的结果，如下：
所以结果成立
IUserService和IStudentService都注册了三次，但最终通过排他注册方式，最后成功的只一个和两个；
泛型注册方式，提供模板注册，如下：
先定义一个泛型：
注册，只能通过参数的形式注册：
使用方式和上面一样；
依赖注入其他操作：
两种常用注入方式：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ff574f1b103e8de6e9f41db79704ebf9/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/414/">«</a>
	<span class="pagination__item pagination__item--current">415/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/416/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>