<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6dc8af0897f01385cad885dc7b8e87cd/" rel="bookmark">
			电子科大软件系统架构设计——设计模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		设计模式概述 设计模式的背景 设计面向对象软件比较困难，而设计可以复用的面向对象软件更加困难不是解决任何问题都需要从头做起，最好能复用以往的设计方案经验面向对象软件设计经验需要有一定的模式记录下来，以提供给其他设计者使用，这就产生了设计模式。 什么是设计模式 设计模式 (Design pattern)是一套被反复使用的、经过分类编目的面向对象程序设计经验总结。它是面向对象程序设计中典型问题的解决方案。
GoF模式是四位著名面向对象设计专家 (Elich Gamma、Richard Helm、Ralph Johnson、 John Vlissides) 所提出的23种面向对象程序设计模式。这四个人常被称为Gang of Four，简称GoF。
设计模式作用 帮助设计者更快、更好完成面向对象程序设计。提高实现代码编写的规范性，标准化开发软件构件。支持编写可扩展、易维护、好管理的程序代码。让代码更容易被他人理解，确保代码可靠性、重用性。 设计模式类型 序号模式类型说明1创造模式与对象创建有关，提供一种创建对象而隐藏创建逻辑，给出灵活创建对象的解决方案。典型模式有5种。2结构模式处理类或对象的组合，给出利用继承、接口组合对象以获得新功能的解决方案。典型模式有7种。3行为模式用于描述对象之间协作完成特定功能及其职责分配，给出对象之间通信的解决方案。典型模式有11种。 创建型模式 创建型模式的关注点是“怎样创建对象？”它的主要特点是“将对象的创建与使用分离”，从而降低对象之间的耦合度。
一、创建型模式类型
单例模式 (Singleton Pattern)工厂模式 (Factory Pattern)抽象工厂模式 (Abstract Factory Pattern)建造者模式 (Builder Pattern)原型模式 (Prototype Pattern) 单例模式 (Singleton Pattern) 单例模式是指一个类只能有一个实例，且该类能自行创建这个实例的一种程序设计模式。
模式动机 虽然软件系统可以创建多个进程任务并发运行，但系统在同一时段只允许一个进程任务运行处理。如下一些计算机软件程序需要采用单一进程处理。
打印机程序Windows 的回收站操作系统中的文件系统多线程中的线程池、数据库的连接池应用程序的对话框Web应用的配置对象 模式解决问题 如何让系统只允许唯一的实例进行服务资源访问，从而解决多实例模式带来的系统开销问题。
解决问题思想：
单例模式类只允许创建一个实例对象；该实例对象必须在单例模式类初始化时自行创建；单例模式类对外仅提供一个访问该单例的全局访问点。 模式设计方案 采用一个类仅能创建一个实例对象。该类需自行创建这个实例对象。该类提供全局公开方法让外部来获取这个实例对象。 模式实现方案 饿汉式单例类：在单例类被初始化加载时，就实例化一个对象交给自己的引用。
// 饿汉式单例类 public class Singleton { private static Singleton singletonVar = new Singleton();//在定义变量时就创建对象 private Singleton() { } //私有的构造方法 public static Singleton getInstance() { //静态公有方法返回创建的对象 return singletonVar; } } 懒汉式单例类：在访问实例对象时才实例化对象。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6dc8af0897f01385cad885dc7b8e87cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2cfdd4e6c6f6a163dc496f0ad8106e2b/" rel="bookmark">
			Java可视化物联网智慧工地云平台源码支持人脸识别考勤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		智慧工地是指利用云计算、大数据、物联网、移动互联网、人工智能等技术手段，为建筑施工现场提供智能硬件及物联网平台的解决方案，以实现建筑工地的实时化、可视化、多元化、智慧化和便捷化。智慧工地通过全新的工程全生命周期管理理念，利用物联网技术和新型技术，如传感网络、远程视频监控、地理信息系统、云计算等，围绕施工过程实现建造互联协同、智能生产和科学管理的信息化生态圈。其目标是实现全天候的管理监控，提高施工效率，减少资源浪费，并为管理者提供决策支持。
APP端功能一览
一、项目人员 1.信息采集：
（1）身份信息（确保二代身份证有效，并且头像清晰）
（2）实名头像：人脸实名考勤，请规范拍摄头部照片
请按照以下说明完成人脸识别：
1.请在光线明亮的环境中进行
2.请保持人脸在平模中央
3.请确认面部无遮挡
（3）劳务信息
2.劳务人员管理：
分包单位、劳务工种、人员姓名、身份证号、是否零工。
3.现场管理：
劳务信息、缺勤人数、出勤人数、在场状态、出勤率、全场工种（砌筑工、架子工、建筑电工、木工）、全场班组人数、全场性别和名族。
4.考勤记录：
开始日期、截止日期、打卡方向（进场、出场）、班组名称。
二、视频监控 1.视频监控：位置名称
2.视频回放：点击回放时间
3.AI危险源识别：设备编号、报警内容、报警时间、报警类型
三、危大工程 1.设备报警：设备名称、报警值、报警时间、处理详情、处理时间、处理人、处理措施、处理后结论、附件。
2.吊钩可视化
3.塔机监测：塔吊基本信息、实时统计、运行状态、司机设备信息
4.升降机监测：升降机基本信息、实时统计、运行状态、司机设备信息
四、绿色施工 1.环境实时监测：环境信息、PM2.5、PM10、噪音、温度、风力
2.环境历史数据：环境历史监测、空气质量、TSP、PM2.5、 PM10
TSP的含义：
在大气质量评价中，TSP是指总悬浮微粒，又称总悬浮颗粒物，指悬浮在空气中的空气动力学当量直径≤100μm的颗粒物。它是一种重要的环境空气质量评价指标。
3.喷淋设备：扬尘监测数据、喷淋控制器、自动喷淋控制器、喷淋设备雾炮车、围栏和喷淋
五、安全隐患 1.管理人员证书：分包管理人员证件、新建、分包单位、岗位证书名称、证书编号、人员类型
2.安全人员证书：安全从业人员证件、分包单位、工种、证书名称、证书编号、发证机关
3.隐患排查管理：安全隐患排查、隐患信息、隐患等级、事故类型、隐患描述、主要治理措施
4.安全隐患统计：危险源、检查问题数量统计、整改超时预警、安全隐患趋势
六、系统开发环境 微服务架构+Java+Spring Cloud +UniApp +MySql
支持多端展示（PC端、手机端、平板端）;
数字孪生可视化大屏，一张图掌握项目整体情况;
使用轻量化模型，部署三维可视化管理，与一线生产过程相融合，集成数据后台，统一前端入口，呈现多方项目信息;
用户PC端、移动端数据同步，依托组件化开发平台。;
依托数据交互子平台，形成用户多系统间数据融合；
依托智慧工地平台，满足省、市级住建数据监管要求；
利用5G及智能终端算法，实现IOT设备数据抓取与处理。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70659d16cf29bf498c461eab771e1646/" rel="bookmark">
			HTTP限流控制：Go语言中的精细把关
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开场白：
在Web应用中，流量控制是一个关键的防护措施，用于防止资源过度消耗和潜在的安全威胁。特别是在面对DDoS攻击或异常请求时，限流显得尤为重要。今天，我们将探讨如何在Go语言中实现HTTP的限流控制。
知识点一：限流的基本概念
限流，简单来说，就是限制单位时间内通过某个节点的请求数量。这有助于维护系统的稳定性，防止因过多的请求而导致的服务器过载。
知识点二：常见的限流算法
计数器算法：记录单位时间内的请求数量，超过阈值则拒绝请求。滑动窗口算法：维护一个时间窗口内的请求计数，当新请求到来时，检查计数是否超限。漏桶算法：请求进入漏桶，按照固定的速率从漏桶中流出，从而实现限流。 知识点三：在Go中实现限流
以下是一个简单的计数器算法的示例：
go复制代码
package main import ( "fmt" "sync" "time" ) type RateLimiter struct { limit int // 限流阈值 counter int // 当前计数 lastUpdate time.Time // 上次更新时间 mutex sync.Mutex // 互斥锁，确保并发安全 } func NewRateLimiter(limit int) *RateLimiter { return &amp;RateLimiter{ limit: limit, counter: 0, lastUpdate: time.Now(), } } func (rl *RateLimiter) Allow() bool { rl.mutex.Lock() defer rl.mutex.Unlock() now := time.Now() elapsed := now.Sub(rl.lastUpdate) // 计算时间间隔 rl.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70659d16cf29bf498c461eab771e1646/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d275d5eaad690d7509bef9e409afdf3/" rel="bookmark">
			处理HTTP错误响应：Go语言中的稳健之道
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开场白：
在Web开发中，HTTP错误响应是不可避免的一部分。当请求无法成功完成时，服务器会返回一个错误响应。今天，我们将深入探讨如何在Go语言中优雅地处理这些HTTP错误响应。
知识点一：HTTP错误响应的常见类型
HTTP错误响应通常由状态码和相应的消息组成。常见的状态码包括：404（未找到）、500（内部服务器错误）等。了解这些状态码及其含义是正确处理错误响应的基础。
知识点二：Go语言中的错误处理机制
Go语言鼓励显式错误处理，通过返回错误值来通知函数调用者可能出现的问题。在处理HTTP错误响应时，我们可以通过检查返回的http.Response对象中的错误状态码，来决定如何处理这些错误。
知识点三：处理HTTP错误响应的示例代码
以下是一个简单的示例，展示如何在Go中处理HTTP错误响应：
go复制代码
package main import ( "fmt" "io/ioutil" "net/http" ) func main() { // 发起GET请求 resp, err := http.Get("http://example.com/api/data") if err != nil { fmt.Println("请求出错:", err) return } defer resp.Body.Close() // 检查响应状态码 if resp.StatusCode == http.StatusNotFound { // 处理404错误 fmt.Println("资源未找到") return } else if resp.StatusCode == http.StatusInternalServerError { // 处理500错误 fmt.Println("服务器内部错误") return } else if resp.StatusCode &gt;= 400 { // 其他错误处理逻辑... fmt.Println("其他HTTP错误") return } // 正常处理响应数据.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d275d5eaad690d7509bef9e409afdf3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf024016b5e302a000afa599bbd143ab/" rel="bookmark">
			【服务器】安装Node.js开发环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		部署Node.js环境(使用NVM安装多个Node.js版本): NVM（Node VersionManager）是Node.js的版本管理软件，使您可以轻松在Node.js各个版本间进行切换。适用于长期做node开发的人员或有快速更新node版本、快速切换node版本的场景。
具体操作步骤如下： 服务器系统:CentOS 7.9.2009 x86_64(Py3.7.9)
a. 安装分布式版本管理系统Git。 yum install git -y b. 使用Git将NVM的源码克隆到本地的~/.nvm目录下，并检查最新版本。 说明：由于网络原因，可能会出现无法克隆的问题，建议您多尝试几次。
git clone https://gitee.com/mirrors/nvm.git ~/.nvm &amp;&amp; cd ~/.nvm &amp;&amp; git checkout `git describe --abbrev=0 --tags` c. 依次运行以下命令，配置NVM的环境变量。 echo ". ~/.nvm/nvm.sh" &gt;&gt; /etc/profile source /etc/profile d. 运行以下命令，修改npm镜像源为阿里云镜像，以加快Node.js下载速度。 export NVM_NODEJS_ORG_MIRROR=https://npmmirror.com/mirrors/node e. 运行以下命令，查看Node.js版本。 nvm list-remote f. 安装多个Node.js版本。 i. 安装v14.0.0版本。 nvm install v14.0.0 ii. 安装v16.0.0版本。 nvm install v16.0.0 g. 查看已安装的Node.js版本。 nvm ls 返回结果如下所示，表示当前已安装v14.0.0、v16.0.0两个版本，正在使用的是v16.0.0版本。
v14.0.0 -&gt; v16.0.0 default -&gt; v14.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf024016b5e302a000afa599bbd143ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dddd43fc5b6fecaff492eb4fe7896529/" rel="bookmark">
			处理HTTP请求的gzip压缩
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开场白：
在互联网的浩瀚海洋中，数据传输是不可或缺的一环。为了提高传输效率，许多服务采用gzip压缩技术对数据进行压缩。今天，我们将深入探讨如何在Go语言中优雅地处理HTTP请求的gzip压缩。
知识点一：gzip压缩的原理
Gzip压缩是一种广泛使用的压缩算法，通过将数据中的重复模式和冗余信息进行压缩，从而减小文件大小。在HTTP传输中，当服务器端设置了正确的Content-Encoding标头，客户端收到数据后可以对其进行解压。
知识点二：如何在Go中处理gzip压缩
Go语言的net/http包为我们提供了处理gzip压缩的便利方法。以下是一个简单的示例，展示如何从HTTP响应中优雅地解压gzip数据：
go复制代码
package main import ( "bytes" "fmt" "io/ioutil" "net/http" ) func main() { // 发起HTTP GET请求 resp, err := http.Get("http://example.com/api/data?gzip=true") if err != nil { fmt.Println("请求出错:", err) return } defer resp.Body.Close() // 检查是否支持gzip解压 if resp.Header.Get("Content-Encoding") == "gzip" { // 创建一个缓冲区用于存储解压后的数据 body, err := ioutil.ReadAll(resp.Body) if err != nil { fmt.Println("读取响应出错:", err) return } // 使用gzip解压数据 unzippedData, err := gzip.NewReader(bytes.NewReader(body)) if err != nil { fmt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dddd43fc5b6fecaff492eb4fe7896529/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ee412f146112eb1521987e627f06682/" rel="bookmark">
			HTTP代理服务器：Go语言下的“网络翻译官”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开场白：
在这个全球化的网络时代，有时我们需要一个“翻译官”来帮助不同系统、不同语言进行交流。今天，我们就来探讨如何使用Go语言，轻松实现这样一个角色——HTTP代理服务器，让我们的网络请求更加畅通无阻！
知识点一：什么是HTTP代理服务器？
想象一下，你是一名只会说中文的游客，身处一个只会说英语的国家。这时，如果有一个翻译官在你身边，是不是就可以轻松解决沟通问题？HTTP代理服务器就是这样一个角色，它可以帮助客户端与服务器之间进行“翻译”和转发请求。
知识点二：为何需要HTTP代理服务器？
有时候，由于网络限制、安全问题或者仅仅是想要加速网络请求，我们需要通过代理服务器来发送请求。代理服务器可以隐藏客户端的真实IP、缓存请求结果，甚至可以对请求进行一定的处理。
知识点三：使用Go实现HTTP代理服务器的简单示例
Go语言由于其简洁和高效的特性，非常适合用来实现代理服务器。下面是一个简单的示例代码：
go复制代码
package main import ( "io" "log" "net/http" "net/http/httputil" "net/url" ) func main() { // 目标服务器的地址 targetURL := "http://example.com" target, err := url.Parse(targetURL) if err != nil { log.Fatal("Error parsing target URL:", err) } // 创建一个反向代理的处理器 proxy := httputil.NewSingleHostReverseProxy(target) // 创建一个处理所有请求的处理器函数 handler := func(w http.ResponseWriter, r *http.Request) { // 在这里可以添加一些自定义的逻辑，比如日志、请求修改等 proxy.ServeHTTP(w, r) // 将请求转发给目标服务器 } // 注册处理器并启动服务器 http.HandleFunc("/", handler) log.Println("Proxy server is listening on port 8080"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ee412f146112eb1521987e627f06682/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9dbf9fca047e15a7cebbcea72c281a93/" rel="bookmark">
			电脑屏幕分辨率，这些知识要记好！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		“我的电脑显示最近好像不太对劲，我想调节一下电脑屏幕分辨率，让电脑显示更清晰。应该怎么做呢？有什么方法可以快速对它进行调节吗？” 在使用电脑的时候，分辨率决定了屏幕上的像素数量，从而影响图像的清晰度和显示效果。如果电脑屏幕分辨率设置不正确会让用户在使用电脑时感到视觉疲惫。
为了提高使用体验和保护眼睛，我们应该掌握电脑屏幕分辨率的正确调节方法，下文已经为大家总结了，有需要的朋友可以进行参考。
电脑屏幕分辨率正确调节的重要作用 经常使用电脑的用户可能都意识到了显示器分辨率是很重要的，但是它具体的用处有哪些呢？主要有这么几个。
1.提高用户的视觉舒适度。选择合适的分辨率设置，确保屏幕上的文字和图像清晰、锐利，有助于减轻眼睛的疲劳感，提高用户的视觉舒适度；
2.有助于提高工作效率。对于需要长时间使用电脑工作的用户来说，屏幕分辨率的调节直接影响到他们的工作效率；
3.有助于保护眼睛健康。屏幕分辨率设置得当，可以减少眼睛长时间注视屏幕时的疲劳感，从而降低眼睛受到损伤的风险。
如何调节电脑屏幕分辨率 既然电脑的屏幕分辨率对用户来说如此重要，我们应该怎么对它进行调节呢？如果不知道如何操作的朋友，可以尝试按照下方的步骤进行。
步骤一：进入操作系统 电脑屏幕分辨率突然变大了怎么办？首先，你需要登录到你的电脑操作系统。在大多数情况下，操作系统会在启动后自动显示登录界面，你只需输入正确的用户名和密码即可进入操作系统。
步骤二：找到显示设置 显示分辨率在哪里调？通过来说，如果需要调节分辨率，可以在显示设置中进行调节。只需要按下快捷键【win＋s】搜索【设置】，并在设置中点击【系统】找到并进入显示设置。
步骤三：选择分辨率 最舒服的电脑分辨率是多少呢？这个需要用户根据平常的使用习惯和个人的喜好进行选择。在【显示设置】中，用户会看到一个或多个分辨率选项。这些选项通常会显示在【分辨率】或【显示设置】选项卡下。选择一个适合你屏幕分辨率的选项。
步骤四：应用更改 选择适合的分辨率后，点击【应用】或【确定】按钮来应用更改电脑屏幕分辨率。系统可能会要求你重新启动电脑以使更改生效。在重新启动电脑后，新的分辨率设置应该已经生效。
总之，使用电脑时，正确的分辨率对用户来说是很重要的。调节电脑屏幕分辨率是一个相对简单的过程，但需要注意选择适合自己眼睛的分辨率，以避免眼睛疲劳和不适。通过合适的设置，你可以更加灵活地调节屏幕分辨率和显示效果，从而提高使用体验和工作效率。
往期推荐：
电脑键盘大小写切换按哪个键？正确操作分享！https://blog.csdn.net/datarecover/article/details/135237780?spm=1001.2014.3001.5501
SD卡格式化恢复，3个方法解决问题！https://blog.csdn.net/datarecover/article/details/135237122?spm=1001.2014.3001.5501
电脑数据删除了还能恢复吗？分享正确答案！https://blog.csdn.net/datarecover/article/details/135238359?spm=1001.2014.3001.5501
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1ca840c696189e02595cfcd9663fbd2/" rel="bookmark">
			php 二维数组排序，二维数组按照指定字段排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		php 二维数组排序，二维数组按照指定字段排序 如下，定义一个二维数组，现在想要按照数组内id进行倒序排列。
// 定义变量 $temp_list = [ { "id": "1", "name": "菜鸟教程", "url": "www.runoob.com" }, { "id": "2", "name": "菜鸟工具", "url": "c.runoob.com" }, { "id": "3", "name": "Google", "url": "www.google.com" } ] 采用这样的方法，将会变得非常简单。
usort($temp_list , array_sort('id', 'desc')); 对二维数组中的 id 键进行排序，按照倒序排列。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6e30aa37293d789c345be846bfab0d2/" rel="bookmark">
			洛谷 P8664 [蓝桥杯 2018 省 A] 付账问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目link
分析 对于第 i i i 个人，假设他前面的都已经付完，那么他的期望付钱数就是他后面的（包括他）的人数除以剩余的钱数，也就是： S ′ n − i + 1 \Large \frac{S^\prime}{n-i+1} n−i+1S′​，但如果第 i i i 个人没有这么多钱，他就只能付 a i a_i ai​ 元，最后计算标准差即可。
考试时在期望付钱数这里卡住了，其余的跟正确思路大差不差。
注意开 long double 不然会挂 30 30 30 分。 代码 #include &lt;bits/stdc++.h&gt; using namespace std; const int N = 5 * 1e5 + 5; int n; long double s, ans, avg, a[N]; int main(){ cin &gt;&gt; n &gt;&gt; s; for(int i = 1; i &lt;= n; i ++){ cin &gt;&gt; a[i]; } avg = s / n; sort(a + 1, a + n + 1); for(int i = 1; i &lt;= n; i ++){ long double cur = min(a[i], s / (n - i + 1)); s -= cur; ans += (cur - avg) * (cur - avg); } ans /= n, ans = sqrt(ans); cout &lt;&lt; fixed &lt;&lt; setprecision(4) &lt;&lt; ans; return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/375ede5d014c1632966f1ec55a6387ae/" rel="bookmark">
			2013年第二届数学建模国际赛小美赛B题寄居蟹进化出人类的就业模式解题全过程文档及程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2013年第二届数学建模国际赛小美赛 B题 寄居蟹进化出人类的就业模式 原题再现： 寄居蟹是美国最受欢迎的宠物品种，依靠其他动物的壳来保护。剥去寄居蟹的壳，你会看到它柔软、粉红色的腹部卷曲在头状的蕨类叶子后面。大多数寄居蟹喜欢蜗牛壳，虽然有些用双壳类的壳，如蛤蜊和扇贝，还有一些用浮木，石头和玻璃或塑料瓶。
当一只孤独的螃蟹遇到一个漂亮的新贝壳时，它立即用它的腿和触角检查了这个庇护所，然后冲出它现在的家去试新庇护所的大小。如果新的贝壳很合适，螃蟹就会认领它。典型的寄居蟹行为。但是如果新发现的壳太大，螃蟹并没有失望地逃走，而是在15分钟到8小时的时间里等待着它的发现。这是不寻常的。最后，其他的螃蟹出现了，每个螃蟹都在试壳。如果贝壳对新来者来说也太大，他们也会四处游荡，有时会组成20多人的团体。然而，螃蟹并不是随机聚集在一起的。相反，它们在一条从最大到最小的康加蛇线上互相夹住——生物学家称这种行为为“背驮”。一只螃蟹刚找到新家，所有排队的螃蟹就按顺序迅速交换贝壳。队伍前面最大的螃蟹抓住了螃蟹被遗弃的壳。第二大螃蟹偷偷地钻进了第一大螃蟹的旧壳里。依此类推。寄居蟹真的需要考虑和评估这些贝壳资源——这些是生死攸关的决定，从这个角度来看它们很有趣。它们比普通螃蟹聪明。
社会学家和经济学家使用“空缺链”一词来描述资源的有序交换，使序列中的每一个人受益。空缺链是一种很好的资源分配方式：与更典型的竞争不同，单个空缺链有利于参与的每个人，每个人都可以升级。因此，寄居蟹进化出复杂的社会行为来充分利用空缺链是有道理的。研究这些动物的行为可以帮助我们改善我们如何分配资源，例如公寓、汽车和工作。
模型的目标
1、发展社会策略，在队列中交换工作，让每个人都受益。我们能把它们应用到所有行业吗？如果没有，需要满足哪些条件？
现在一个新的人力资源网站想采纳你的想法，有多少求职者需要同时满足雇主和雇员。运行您的模型，预测未来五年内某些企业客户的人力资源支出变化。
除了格式化的解决方案之外，为网站准备一到两页的广告单，突出显示您的策略和结果。
整体求解过程概述(摘要) 卢梭曾经说过，人生来就是自由的，他到处都被枷锁着。然而，它并不是在传播悲观的世界观。相反，只有通过人与人之间的互动，我们的社会才能取得进步。
就像寄居蟹会聚在一起交换贝壳，这样每个人都可以得到一个更大的家。我们人类社会也存在类似的现象，称之为空缺链。然而，在人与人之间分配贝壳是一项相对容易的工作，如何在人与人之间交换贝壳是一个相当困难的问题。
为了解决上述问题。本文总结了三个子问题及其解决方法：1）找出空缺链所需满足的条件，使空缺链成为每个人都能受益的优化工具。2） 建立一个模型来评估一个人的能力，并提出一个算法作为社会策略来交换空缺链中的工作，使每个人都受益。3） 建立一个不等式来回答需要多少工作申请才能同时满足雇主和雇员，并运行我们的模型来预测未来5年内一些企业客户的人力资源支出的变化。
在第一个子问题中，我们讨论了不同组织层级对空缺链的不同影响。结果表明，中层管理者较少的层级组织形式最有可能受到空缺链的调控。幸运的是，大多数企业的组织形式与之相似，也就是说，空缺链可以适用于大多数情况。其次，在第二个子问题中，我们提出了一个线性方程作为评价函数，并得到每个人的综合得分，这代表了一个人的能力。然后，基于总体得分，采用贪心算法对空缺链中的人员进行职位交换。人的素质将与工作要求相适应。在这种情况下，每个人都会得到最合适的工作。最后，在第三个子问题中，由于空缺链也有其成本，如更换成本和培训成本。我们不会让总成本超过它的好处。因此，我们将提出一个需要满足的不等式，以便成本不会超过收益。也就是说，我们将计算出在某些情况下，有多少求职者需要同时满足雇员和雇主的要求。最后，我们将使用我们的模型来显示未来五年内一些企业客户的人力资源支出的变化。
在整个建模过程中，充分考虑了模型的有效性、可行性和成本效益。
模型假设： •我们假设组织形式类似于前一节中的模型4。
•我们假设工作要求、员工能力以及工作带来的福利都可以量化。
•我们假设相对较低阶层的人会服从较高阶层的安排。
•我们认为初始安排是合理的。也就是说，工作和从事这个工作的人是相容的。在要求高、福利高的企业中，高能力的人会有较高的地位。
问题重述： 空位链的概念来源于对寄居蟹种群中一种现象的科学观察。随着寄居蟹体形的增长，它必须找到一个更大的壳，并抛弃上一个壳。一些寄居蟹物种，包括陆地和海洋，利用空位链寻找新的壳：当一个新的，更大的壳变得可用时，寄居蟹聚集在它周围，形成一种从大到小的队列。当最大的螃蟹进入新壳时，第二大的螃蟹进入新空出的壳，从而使第三只螃蟹可以得到它以前的壳，依此类推。自从这一生物学发现以来，空位链这个术语被赋予了更多的含义。
目前，空缺链是一种将资源分配给消费者的社会结构。在空缺链中，到达总体的新资源单元由第一个在行的个体获取，然后该个体将其旧单元留在后面，该旧单元由第二个个体获取，将其旧单元留在后面，依此类推。通常，当出现空缺时，填补职位的大部分人来自内部劳动力市场，而不是雇用新人。被调动或提升到新工作或职位的个人通常会获得更高的工资和更多的福利，这对组织有重要影响。
本文提出了一个以雇主和雇员利益最大化为目标的职位空缺链模型，并利用该模型预测了部分企业的工作变动。我们总结了本文要解决的三个子问题。
讨论了空缺链何时可以作为优化员工岗位分配的工具，以及需要满足哪些条件才能发挥空缺链的作用。
建立了一个计算员工胜任力的模型，该模型可用于在空缺链发生时安排员工，并开发了一个使每个员工受益的职位分配算法。
讨论有多少求职者需要同时满足雇主和雇员，并运行我们的模型来预测未来5年内一些企业客户的人力资源支出的变化。在整个建模过程中，充分考虑了模型的有效性、可行性和成本效益。
模型的建立与求解整体论文缩略图 全部论文请见下方“ 只会建模 QQ名片” 点击QQ名片即可 部分程序代码：(代码和文档not free) clear all K=[]; % We need to input rxr matrix K and K is the number of different levels of work % [r,r]=size(K); % r is rows or columns of matrix K % N=[]; % We need to input rxr matrix N and N is different levels of total vacant job at present % I=eye(3); % I is rxr unit matrix % P=K.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/375ede5d014c1632966f1ec55a6387ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6e2d297c97dcca2dba8f21bec5535ba/" rel="bookmark">
			【C语言】程序练习（三）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，这里是争做图书馆扫地僧的小白。非常感谢各位的支持，也期待着您的关注。
目前博主有着C语言、C++、linux以及数据结构的专栏，内容正在逐步的更新。
希望对各位朋友有所帮助同时也期望可以得到各位的支持，有任何问题欢迎私信与我。
个人主页：争做图书馆扫地僧的小白_-CSDN博客
C语言专栏：C语言_争做图书馆扫地僧的小白的博客-CSDN博客
C++专栏：C++系列_争做图书馆扫地僧的小白的博客-CSDN博客
linux系统：linux系统_争做图书馆扫地僧的小白的博客-CSDN博客
数据结构：数据结构_争做图书馆扫地僧的小白的博客-CSDN博客
最后送大家一句话，路好不好走，也许我不能决定，但走不走，却只有我能决定。
目录
前言
一、分支控制语句
1.switch...case语句
1.1 练习题：
1.2 练习题
二、循环控制语句
1使用goto实现循环
1.1练习题
2 while循环
2.1 练习题
3.do...while循环
4. for循环
4.1练习题1
4.2练习题2
5.综合练习题
总结
前言 C语言是一门面向过程的计算机编程语言，与C++、C#、Java等面向对象编程语言有所不同。C语言的设计目标是提供一种能以简易的方式编译、处理低级存储器、仅产生少量的机器码以及不需要任何运行环境支持便能运行的编程语言。
本篇程序练习时对应博主的C语言学习笔记（中）-CSDN博客，本次博客内容将围绕学习笔记中的相关知识点进行整理程序的相关练习，也是博主在学习C语言的过程中所练习的一些题目，希望对有需要的朋友有所帮助，鉴于笔记内容较多，预计将C语言学习笔记（中）-CSDN博客对应的知识点分成两次进行程序讲解。本篇将包含分支控制语句中的switch...case语句、循环控制语句中的goto，while循环，do...while循环以及for循环的练习题。
提示：以下是本篇文章正文内容，下面案例可供参考
一、分支控制语句 1.switch...case语句 1.1 练习题： 1.使用switch..case语句
实现简易的计算器功能： ( 实现 + - * )功能即可
要求，在终端输入 表达式 如： 2+9
输出计算的结果 ：11
代码示例如下所示：
#include &lt;stdio.h&gt; int main(){ int value1 = 0; char operator = 0; int value2 = 0; scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6e2d297c97dcca2dba8f21bec5535ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15edc5d4fc9ad1a55234890810f5d6e6/" rel="bookmark">
			laravel Log日志指定文件位置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 laravel Log日志指定文件位置 使用build方法，可以指定 driver 类型，使用 path 可以指定文件位置。
Log::build([ 'driver' =&gt; 'single', 'path' =&gt; storage_path('logs/custom.log'), ])-&gt;info('Something happened!'); return 1; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f67bad5d5b74fafdaaa111316b62975/" rel="bookmark">
			禁止浏览器记住密码和自动填充 element-ui&#43;vue
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue 根据element-ui 自定义密码输入框，防止浏览器 记住密码和自动填充
&lt;template&gt; &lt;div class="el-password el-input" :class="[size ? 'el-input--' + size : '', { 'is-disabled': disabled }]" &gt; &lt;input class="el-input__inner" :placeholder="placeholder" ref="input" :style="{ paddingRight: padding + 'px' }" :disabled="disabled" :readonly="readonly" @focus="handleFocus" @blur="handleBlur" @input="handleInput" @change="change" @compositionstart="handleCompositionStart" @compositionend="handleCompositionEnd" /&gt; &lt;div class="tools"&gt; &lt;i v-if="clearable !== false" v-show="pwd !== '' &amp;&amp; isfocus" @mousedown.prevent class="el-input__icon el-icon-circle-close el-input__clear" @click="clearValue" &gt;&lt;/i&gt; &lt;i v-if="showPassword !== false" v-show="pwd !== '' || isfocus" class="el-input__icon el-icon-view el-input__clear" @click="changePasswordShow" &gt;&lt;/i&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import emitter from "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f67bad5d5b74fafdaaa111316b62975/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed37616ea682f51dd929351a1c49ac26/" rel="bookmark">
			如何恢复电脑系统还原？这3个方法要记好！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		“我的电脑用了好几年了，最近使用的时候总是莫名其妙系统崩溃，想问问大家有什么方法可以快速对电脑系统进行还原吗？” 在遇到电脑系统崩溃或者系统出现重大问题时，系统还原可以快速地解决问题，而不需要重装系统。恢复电脑系统还原是每个电脑使用者都可能遇到的问题，也是一个很重要的问题。
如何恢复电脑系统还原呢？下文小编已经为大家总结好了简单有效的方法，有需要的朋友可以进行尝试。
方法一：启用系统还原 电脑怎么进行系统还原？在Windows系统中，默认情况下系统还原功能是开启的。如果之前关闭了此功能，可以通过以下步骤启用：
步骤1：打开【此电脑】，右键点击【C盘】，选择【属性】；
步骤2：在【属性】窗口中，选择【常规】选项卡；
步骤3：勾选【磁盘清理】选项，点击【确定】；
步骤4：在新打开的【磁盘清理】窗口中，勾选【系统还原和卷影复制】选项，点击【确定】。
方法二：创建系统还原点 将电脑恢复出厂设置怎么做？在启用系统还原功能后，需要创建一个还原点。这样在需要还原系统时，可以快速回到这个点。创建步骤如下：
步骤1：搜索并进入【控制面板】，选择【系统和安全】选项；
步骤2：点击【系统】选项卡，找到【系统属性】，点击【系统保护】；
步骤3：选择【C盘】，点击【配置】按钮；
步骤4：弹出【系统保护】后，单击【启用系统保护】，并设置适当的磁盘空间使用量，点击【应用】按钮，然后点击【确定】按钮；
步骤5：在【系统保护】窗口中，点击【创建】按钮，为当前状态创建一个还原点。
方法三：使用系统还原恢复系统 当我们的电脑遇到崩溃等情况时，如何恢复电脑系统还原呢？可以尝试使用之前创建的还原点来恢复系统。操作如下：
步骤1：打开【控制面板】，选择【系统和安全】选项；
步骤2：点击【系统】选项卡，在【系统属性】窗口中，选择【系统保护】选项卡；
步骤3：选择【C盘】，然后点击【系统还原】按钮；
步骤4：在弹出的【系统还原】窗口中，选择之前创建的还原点，然后点击【下一步】按钮，确认还原点信息无误后，点击【完成】按钮开始还原过程。
步骤5：系统会自动重启并开始还原过程。等待一段时间后，系统还原完成。
系统还原后数据丢失如何恢复？ 如果在系统还原之前用户未对重要的数据进行恢复，在进行还原操作后数据可能会有丢失的情况。此时应该怎么恢复丢失的数据呢？因为系统还原会对数据进行删除，在回收站中或许也无法找回删除的数据。此时建议用户借助专业的数据恢复软件对数据进行恢复。
比较推荐的是 数 据 蛙 恢 复 专 家 ，它的扫描和恢复功能都比较好，同时支持免费扫描，如果需要恢复数据，建议先使用软件对数据进行扫描。软件的操作方法如下。
操作环境： 演示机型：惠普(HP)战X 系统版本：Windows10 软件版本：数 据 蛙 恢 复 专 家 3.2.12 步骤1：安装并运行软件后，点击【免费试用】，即可获得免费的扫描机会；
步骤2：在选择需要扫描的文件类型时，新用户建议全选，并选择需要扫描的磁盘，点击【扫描】；
步骤3：第一次扫描完成后，用户可根据恢复需求，选择需要查看的文件类型，并在右侧对需要恢复的文件进行勾选，若此次扫描没找到需要恢复的文件，点击【深度扫描】；
步骤4：深度扫描完成后，可以对扫描到的结果进行再一次的勾选和查看，在选择时，用户可借助【筛选器】对数据进行快速的定位，找到需要恢复的文件后，点击【导出】，等待导出完成即可。
在平常使用电脑时，我们应该注意爱惜电脑。当电脑出现崩溃现象时，很多用户可能都会选择将其还原。上文已经给大家分享了如何恢复电脑系统还原的简单方法了，但要注意，在进行电脑还原操作前，要备份好重要的信息，以防数据丢失。
往期推荐：
电脑数据删除了还能恢复吗？分享正确答案！https://blog.csdn.net/datarecover/article/details/135238359?spm=1001.2014.3001.5501
SD卡格式化恢复，3个方法解决问题！https://blog.csdn.net/datarecover/article/details/135237122?spm=1001.2014.3001.5501
电脑键盘大小写切换按哪个键？正确操作分享！https://blog.csdn.net/datarecover/article/details/135237780?spm=1001.2014.3001.5501
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86e41e3cb36c1dfd41e86863190cb90a/" rel="bookmark">
			GPT-4 API曝重大安全漏洞，研究人员成功越狱； Pika 1.0 全面开放免费试用！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🦉 AI新闻 🚀 GPT-4 API曝重大安全漏洞，研究人员成功越狱 摘要：FAR AI实验室的团队通过微调、函数调用和搜索增强三个方向成功让GPT-4 API越狱，暴露了其重大安全漏洞。他们通过微调模型，生成有害内容并提取私人信息，还插入恶意URL。研究表明，即使是最先进的GPT-4也存在泄露功能漏洞的问题。此外，GPT-4 Assistants模型容易暴露函数调用格式，并可能被诱导执行任意函数调用。这些安全漏洞的发现引起了广泛关注和警惕。
🚀 Pika 1.0 全面开放！现阶段免费试用！ 摘要：Pika 1.0的初体验的分享，介绍了如何使用Pika 1.0生成视频的功能，包括修改局部区域、画布扩展、延长视频、提升画质等功能。作者还提到了AI破局俱乐部的AI航海实战活动，并分享了报名方式。最后，作者简要介绍了自己的背景和对AI、副业的持续探索。
🚀 黑客利用AI创建钓鱼邮件日益增加，安全公司研发检测工具对付 摘要：安全公司Abnormal发布报告称，现在黑客利用各种模型批量创建钓鱼邮件，并使用脚本群发，进行高效率网络诈骗活动。他们已将生成式AI融入攻击策略中，传统安全软件难以察觉。研究人员开发了检测工具GLTR，精确识别AI钓鱼邮件。黑客让AI使用更正式的措辞创建邮件，但GLTR可以判断哪些部分由人工智能生成。虽然误判率存在，但使用AI对付AI反而更有效。黑客利用AI构造钓鱼邮件的现象及防御方法引起关注。
🚀 纽约时报起诉OpenAI和微软未经授权使用数百万文章训练AI模型 摘要：纽约时报在法庭起诉OpenAI和微软，声称对方公司未经授权使用了大量文章来训练AI模型，导致AI生成的内容与纽约时报的内容直接竞争。纽约时报称，这破坏了与读者的关系，并剥夺了其订阅、广告和附属收入。纽约时报要求对方公司承担数十亿美元的法定和实际损失。此前，纽约时报已经屏蔽了OpenAI的爬虫，并禁止其使用从其网站上抓取的内容训练AI模型。
🚀 商汤科技旗下AI下棋机器人元萝卜登陆日本市场 摘要：商汤科技旗下元萝卜AI下棋机器人围棋版将于2024年1月5日在日本正式发售。这款机器人能够支持定义初始棋力水平并开启相应的等级关卡，提供超过20级的高棋力体验。商汤科技副总裁史军表示，希望为数百万日本围棋爱好者带来全新的对弈体验，续写中日围棋交流的佳话。这也标志着商汤科技将在海外市场推出更多消费级AI产品。该新闻对于围棋爱好者和人工智能领域的发展具有一定影响力和重要性，对公众兴趣和新颖性也较高。
🗼 AI知识 🔥 一文了解ChatGPT的发展浪潮 近一段时间在学Prompt，刚好学到了ChatGPT的一些发展史，因此沉淀一些相关的概念内容。
以下开始本文的讲解~👨‍🚀
🔥 2023年谷歌AI研究回顾 这篇文章总结了Google Research和Google DeepMind在2023年在人工智能研究和应用方面取得的进展。文章提到了他们在生成AI、语言模型、图像编辑、语音识别等方面的创新，以及在机器学习、算法优化和隐私保护等领域的研究成果。他们致力于开发和交付有用和有益的应用程序，并在人类价值观的基础上应用伦理原则，同时努力减轻人工智能的风险。
更多AI工具，参考国内AiBard123，Github-AiBard123
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a1e28e17ec86583bbac4202f6446421/" rel="bookmark">
			ajax的完整写法——success/error/complete&#43;then/catch/done&#43;设置请求头两种方法——基础积累
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ajax的完整写法——success/error/complete+then/catch/done+设置请求头两种方法——基础积累 1.完整写法——success/error/complete1.1 GET/DELETE——query传参1.2 GET/DELETE——JSON对象传参1.3 PUT/POST——JSON对象传参 2.简化写法——then/catch/done2.1 GET/DELETE——query传参2.2 PUT/POST——JSON对象传参 1.完整写法——success/error/complete 1.1 GET/DELETE——query传参 $.ajax({ url: "/bigscreen/home/getDeptRiskInfoById", async: false,//是否异步，如果开启，则接口同步进行 type: "GET",//大写的GET等同于小写的get data: { deptId: id, }, headers: { "token": token },//设置请求头 success: function (data) { // } }); 下面介绍设置请求头的第二种方法：
$.ajax({ url: "/api/SchemeMain?id=" + row.id, type: "delete", beforeSend: (request) =&gt; { request.setRequestHeader("operator", encodeURIComponent(this.userName)); request.setRequestHeader("operatorId", this.userId); }, xhrFields: { withCredentials: true }, success: res =&gt; { if (res.success) { this.$message.success('删除成功'); } else { this.$message.error(res.message); } }, complete: () =&gt; {} }) 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a1e28e17ec86583bbac4202f6446421/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20b7bfa28c42aab69e24dbe6c9d84d31/" rel="bookmark">
			应用在网络摄像机领域中的国产音频ADC芯片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IPC：其实叫“网络摄像机”，是IP Camera的简称。它是在前一代模拟摄像机的基础上，集成了编码模块后的摄像机。它和模拟摄像机的区别，就是在新增的“编码模块”上。模拟摄像机，顾名思义，输出的是模拟视频信号。这个新增的编码模块就出现了，就是为了把原来模拟视频编码压缩后，变为数字视频，为了方便在网络上传输，把数字视频封装为网络格式的，以适合在以太网上传输。我们就叫这新的摄像机为“网络摄像机”，简称IPC。
与模拟摄像机一样，IPC的分类方法有多种，可以按照外形分类、按照清晰度分类、按照室内及室外应用进行分类。通常的分类方法是按照固定摄像机、PTZ摄像机、半球摄像机、一体球摄像机等直观外形特征进行分类。
IPC的主要功能模块：
视频编码：采集并编码压缩视频信号。
音频功能：采集并编码压缩音频信号。
网络功能：编码压缩的视音频信号通过网络进行传输。
云台、镜头控制功能：通过网络控制云台、镜头的各种动作。
缓存功能：可以把压缩的视音频数据临时存储在本地的存储介质中。
报警输入输出：能接受、处理报警输入/输出信号，即具备报警联动功能。
移动检测报警：检测场景内的移动并产生报警。
视频分析：自动对视频场景进行分析，比对预设原则并触发报警。
视觉参数调节：饱和度、对比度、色度、亮度等视觉参数的调整。编码参数调节：帧率、分辨率、码流等编码参数可以调整。
系统集成：可以视频管理平台集成，实现大规模系统监控。
IPC的硬件构成一般包括镜头、图像传感器、声音传感器、信号处理器、模/数转换器、编码芯片、主控芯片、网络及控制接口等部分组成。光线通过镜头进入传感器，然后转换成数字信号由内置的信号处理器进行预处理，处理后的数字信号由编码压缩芯片进行编码压缩，然后通过网络接口发送到网络上进行传输。
ADC芯片全称模拟数字转换器，是一个帮助我们将模拟信号转换成为数字信号的转换器芯片。ADC芯片主要看两个基本指标—速度和精度，速度代表的是ADC可以转换多大带宽的模拟信号，带宽对应的就是模拟信号频谱中的较大频率。而精度代表的是衡量转换出来的数字信号与原来的模拟信号之前的差距。从模拟信号转化为数字信号的转换过程处理要经过采样，保持，量化，编程四个阶段，根据不同的处理方式，它也可以分为多种结构和不同的应用场景。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22c20f61c76885ad927d7c1fba2a8572/" rel="bookmark">
			LeetCode刷题笔记之双指针算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、数组相关操作 1. 27【移除元素】 题目： 给你一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，并返回移除后数组的新长度。不要使用额外的数组空间，你必须仅使用 O(1)额外空间并原地修改输入数组。元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。
代码：
class Solution { public int removeElement(int[] nums, int val) { //快慢指针 int slow = 0; for(int j=0;j&lt;nums.length;j++){ if(nums[j] != val){ nums[slow++] = nums[j]; } } return slow; } } 2. 26【删除排序数组中的重复项】 题目： 给你一个非严格递增排列的数组 nums ，请你原地删除重复出现的元素，使每个元素只出现一次 ，返回删除后数组的新长度。元素的相对顺序应该保持一致 。然后返回 nums 中唯一元素的个数。考虑 nums 的唯一元素的数量为 k ，你需要做以下事情确保你的题解可以被通过：
更改数组 nums ，使 nums 的前 k 个元素包含唯一元素，并按照它们最初在 nums 中出现的顺序排列。nums 的其余元素与 nums 的大小不重要。返回 k 。代码： class Solution { public int removeDuplicates(int[] nums) { //快慢指针 int slow = 1; for(int i=1;i&lt;nums.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/22c20f61c76885ad927d7c1fba2a8572/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9022d929c80c9ebeb780cc0d570f500a/" rel="bookmark">
			Java版企业电子招标采购系统源码——鸿鹄电子招投标系统的技术特点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在数字化时代，采购管理也正经历着前所未有的变革。全过程数字化采购管理成为了企业追求高效、透明和规范的关键。该系统通过Spring Cloud、Spring Boot2、Mybatis等先进技术，打造了从供应商管理到采购招投标、采购合同、采购执行的全过程数字化管理。通过待办消息、招标公告、中标公告和信息发布等功能模块，实现了内外协同，为供应商集中推送展示与其相关的所有采购业务信息，支持供应商信息的自助维护，实时风险自动提示。
功能模块： 待办消息，招标公告，中标公告，信息发布
描述：
全过程数字化采购管理，打造从供应商管理到采购招投标、采购合同、采购执行的全过程数字化管理。通供应商门户具备内外协同的能力，为外部供应商集中推送展示与其相关的所有采购业务信息（历史合作、考察整改，绩效评价等），支持供应商信息的自助维护，实时风险自动提
服务框架：Spring Cloud、Spring Boot2、Mybatis、OAuth2、Security
前端架构：VUE、Uniapp、Layui、Bootstrap、H5、CSS3
涉及技术：Eureka、Config、Zuul、OAuth2、Security、OSS、Turbine、Zipkin、Feign、Monitor、Stream、ElasticSearch等
业务服务
业务服务：通过服务与服务之间的内部（Feign）、外部通讯（Restful），满足不同业务需求。外部服务通过标准化协议，对外提供安全稳定的Restful服务，对内通过Spring Cloud Feign方式进行通讯，数据库完整CRUD操作。
全过程数字化采购管理平台通过采用先进的技术和服务框架，实现了从供应商管理到采购招投标、采购合同、采购执行的全过程数字化管理。该平台具备内外协同的能力，为外部供应商集中推送展示与其相关的所有采购业务信息，支持供应商信息的自助维护，实时风险自动提示。同时，通过VUE、Uniapp、Layui等前端技术，实现了与供应商的快速交互和信息共享。该平台不仅提高了采购工作效率和质量，还为企业带来了更多的商业机会和竞争优势。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e28f2027e8515818e09fd69e9ba21a6/" rel="bookmark">
			视频格式网络地址转换视频到本地，获取封面、时长，其他格式转换成mp4
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用ffmpeg软件转换网络视频，先从官网下载对应操作系统环境的包
注意:网络地址需要是视频格式结尾，例如.mp4,.flv 等
官网地址：Download FFmpeg window包：
linux包：
如果下载缓慢，下载迅雷安装使用下载。
解压缩后对应截图：
window:
linux：
在maven项目的pom.xml引入依赖包:
&lt;dependency&gt; &lt;groupId&gt;net.bramp.ffmpeg&lt;/groupId&gt; &lt;artifactId&gt;ffmpeg&lt;/artifactId&gt; &lt;version&gt;0.7.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.bytedeco&lt;/groupId&gt; &lt;artifactId&gt;javacpp&lt;/artifactId&gt; &lt;version&gt;1.4.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.bytedeco&lt;/groupId&gt; &lt;artifactId&gt;javacv&lt;/artifactId&gt; &lt;version&gt;1.4.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.bytedeco.javacpp-presets&lt;/groupId&gt; &lt;artifactId&gt;ffmpeg-platform&lt;/artifactId&gt; &lt;version&gt;3.4.2-1.4.1&lt;/version&gt; &lt;/dependency&gt; 引入类：
import cn.hutool.core.date.DateUtil; import lombok.extern.slf4j.Slf4j; import net.bramp.ffmpeg.FFmpeg; import net.bramp.ffmpeg.FFmpegExecutor; import net.bramp.ffmpeg.FFprobe; import net.bramp.ffmpeg.builder.FFmpegBuilder; import org.bytedeco.javacv.FFmpegFrameGrabber; import org.bytedeco.javacv.FrameGrabber; import org.bytedeco.javacv.Java2DFrameConverter; import javax.imageio.ImageIO; import java.awt.image.BufferedImage; import java.io.File; import java.io.IOException; import java.io.InputStream; import java.io.RandomAccessFile; import java.net.HttpURLConnection; import java.net.URL; 网络地址转换成本地视频方法：
/** * 视频链接转换成本地视频 * @param videoUrl * @param downloadPath * @return */ public static boolean downVideo(String videoUrl,String downloadPath){ HttpURLConnection connection = null; InputStream inputStream = null; RandomAccessFile randomAccessFile = null; boolean re; try{ URL url = new URL(videoUrl); connection = (HttpURLConnection) url.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e28f2027e8515818e09fd69e9ba21a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d36ae33d53ef19fa6fe900c8945d705/" rel="bookmark">
			Feign和openFeign区别和openFeign教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpringCloud-OpenFeign官方文档使用大全详解 一、Feign与OpenFeign的区别 1）Feign是Spring Cloud组件中一个轻量级RESTful的HTTP服务客户端，Feign内置了Ribbon，用来做客户端负载均衡，去调用服务注册中心的服务。Feign的使用方式是：使用Feign的注解定义接口，调用接口，就可以调用服务注册中心的服务。 Feign的依赖
1 &lt;dependency&gt; 2 &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; 3 &lt;artifactId&gt;spring-cloud-starter-feign&lt;/artifactId&gt; 4 &lt;/dependency&gt; 2）OpenFeign是Spring Cloud在Feign的基础上支持了SpringMVC的注解，如@RequestMapping等等。OpenFeign的@FeignClient可以解析SpringMVC的@RequestMapping注解下的接口，并通过动态代理的方式产生实现类，实现类中. OpenFeign的依赖
1 &lt;dependency&gt; 2 &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; 3 &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; 4 &lt;/dependency&gt;　说明：
springcloud F 及F版本以上 springboot 2.0 以上基本上使用openfeign，openfeign 如果从框架结构上看就是2019年feign停更后出现版本，也可以说大多数新项目都用openfeign ，2018年以前的项目在使用feign
二、openFeign教程 Spring-Cloud-OpenFeign使用教程 - 知乎
Spring Cloud OpenFeign使用教程 Spring Cloud OpenFeign Demo 之前项目中需要在Spring Cloud中使用OpenFeign的情况，Spring Cloud的版本是目前最新的Greenwich.SR2版本，对应的Spring boot是2.1.7.RELEASE。
在网上找了很多资料，大多言之不详，并且版本也比较低，不适合我的最新版本Spring Cloud的需求。 所以决定还是自己写个教程。
本教程要解决如下几个问题：
怎么配置OpenFeignServer怎么配置OpenFeignClient多个参数传递问题FeignClient的日志问题多个FeignClient使用同一个name的问题 怎么配置OpenFeignServer 我们知道OpenFeign是用在Spring Cloud中的声明式的web service client。
OpenFeignServer就是一个普通的Rest服务，不同的是我们需要将他注册到eureka server上面，方便后面的OpenFeignClient调用。
启动类如下：
@SpringBootApplication @EnableDiscoveryClient public class OpenFeignServer { public static void main(String[] args) { SpringApplication.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d36ae33d53ef19fa6fe900c8945d705/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae0aab82bc973b42e1c4a0632a6ee6ce/" rel="bookmark">
			06. Springboot admin集成Actuator（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、前言
2、快速使用
2.1、服务端集成
2.1.1、添加依赖
2.1.2、配置启动类
2.1.3、配置application.yml
2.1.4、定制security config
2.1.5、启动程序
2.2、客户端集成
2.2.1、添加依赖
2.2.2、配置application.yml
2.2.3、启动程序
2.3、告警通知
2.3.1、邮件通知
2.3.2、Notifier 接口
1、前言 在《Springboot admin集成Actuator（一）》一文中简单演示了Actuator的初步使用，但是可以发现都是json形式返回的结构，那么是否有能够可视化的方式来展示这些指标呢？当然有，就是接下来要说的Springboot Admin。Spring Boot Admin能够将 Actuator 中的信息进行界面化的展示，也可以监控所有 Spring Boot 应用的健康状况，提供实时警报功能。
注：虽然名叫Springboot Admin，但却不是Spring团队研发的。而是由Codecentric公司创建的，代码在Github： spring-boot-admin在新窗口打开上。
2、快速使用 springboot admin分为服务端（spring-boot-admin-server）和客户端（spring-boot-admin-client）。服务端和客户端之间采用 http 通讯方式实现数据交互；单体项目中需要整合 spring-boot-admin-client 才能让应用被监控。在 SpringCloud 项目中，spring-boot-admin-server 是直接从注册中心抓取应用信息，不需要每个微服务应用整合 spring-boot-admin-client 就可以实现应用的管理和监控。
2.1、服务端集成 2.1.1、添加依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 添加security模块，可以对spring boot admin设置登录账号密码，添加安全性 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;de.codecentric&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-admin-starter-server&lt;/artifactId&gt; &lt;version&gt;${spring.boot.admin.version}&lt;/version&gt; &lt;/dependency&gt; 2.1.2、配置启动类 启动类需要添加注解@EnableAdminServer。
@EnableAdminServer @SpringBootApplication public class SbaServerLauncher { public static void main(String[] args) { SpringApplication.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae0aab82bc973b42e1c4a0632a6ee6ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/445d188d7fc8a641bfd51dfe45c0a6b5/" rel="bookmark">
			【iptables】增加规则和删除规则
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们在另外一台机器上，使用ping命令，向当前机器发送报文，如下图所示，ping命令可以得到回应，证明ping命令发送的报文已经正常的发送到了防火墙所在的主机，ping命令所在机器IP地址为31.133（黑色），当前测试防火墙主机的IP地址为31.132（白色），我们就用这样的环境，对iptables进行操作演示。
3.1 增加规则 iptables -t 表名 -I/-A 链名 -s 源地址 -j 处理动作
-I选项，指明将”规则”插入至哪个链中，-I表示insert，即插入的意思，默认在第一行添加-A选项，在指定链的末尾添加一条规则-s选项，指明”匹配条件”中的”源地址”，即如果报文的源地址属于-s对应的地址，那么报文则满足匹配条件，-s为source之意，表示源地址。-j选项，指明当”匹配条件”被满足时，所对应的动作，有ACCEPT、DROP等 那么此处，我们就在132上配置一条规则，拒绝192.168.31.133上的所有报文访问当前机器，之前一直在说，规则由匹配条件与动作组成，那么”拒绝192.168.31.
133上的所有报文访问当前机器”这条规则中，报文的”源地址为192.168.31.133″则属于匹配条件，如果报文来自"192.168.31.133″，则表示满足匹配条件，而”拒绝”这个报文，就属于对应的动作
此时我们可以再通过192.168.31.133去ping 192.168.21.132，看能否ping通
如上图所示，ping 132主机时，PING命令一直没有得到回应，看来我们的iptables规则已经生效了，ping发送的报文压根没有被132主机接受，而是被丢弃了，所以更不要说什么回应了
此时我们可以再次查看iptables中的规则，可以看到已经有186个包被对应的规则匹配到
拓展：规则的顺序问题 思考：
现在INPUT链中已经存在了一条规则，它拒绝了所有来自192.168.31.133主机中的报文，如果此时，我们在这条规则之后再配置一条规则，后面这条规则规定，接受所有来自192.168.31.133主机中的报文，那么，iptables是否会接受来自133主机的报文呢？
使用如下命令在filter表的INPUT中追加一条规则：
执行完添加规则的命令后，再次查看INPUT链，发现规则已经成功”追加”至INPUT链的末尾，那么现在，第一条规则指明了丢弃所有来自192.168.31.133的报文，第二条规则指明了接受所有来自192.168.31.133的报文，那么结果到底是怎样的呢？
在133主机上再次使用ping命令向133主机发送报文，发现仍然是ping不通的，看来第二条规则并没有生效。
而且从上图中第二条规则的计数器可以看到，根本没有任何报文被第二条规则匹配到。发生上述情况，会不会与规则的先后顺序有关呢？测试一下，我们再添加一条规则，新规则仍然规定接受所有来自192.168.31.133主机中的报文，只是这一次，我们将新规则添加至INPUT链的最前面试试。
使用如下命令，在filter表的INPUT链的前端添加新规则
在第一条规则就是接受所有来自192.168.31.133的报文，而且此时计数是0，此刻，我们再从133上向132发起ping请求。
133上已经可以正常的收到响应报文了，那么回到132查看INPUT链的规则，第一条规则的计数器已经显示出了匹配到的报文数量
看来顺序很重要，如果报文已经被前面的规则匹配到，iptables则会对报文执行对应的动作，即使后面的规则也能匹配到当前报文，很有可能也没有机会再对报文执行相应的动作了，就以上图为例，报文先被第一条规则匹配到了，于是当前报文被”放行”了，因为报文已经被放行了，所以，即使上图中的第二条规则即使能够匹配到刚才”放行”的报文，也没有机会再对刚才的报文进行丢弃操作了。这就是iptables的工作机制。
之前提过的--line-numbers选项，可以列出规则序号
我们也可以在添加规则时，指定新增规则的编号，这样我们就能在任意位置插入规则了，我们只要把刚才的命令稍作修改即可，如下
iptables -t filter -I INPUT 2 -s 192.168.31.133 -j DROP
3.2 删除规则 有两种方法：
方法一：根据规则的编号去删除规则 iptables -t 表名 -D 链名 规则编号
方法二：根据具体的匹配条件与动作删除规则 iptables -t 表名 -D 链名 -s 源地址 -j 处理动作
（1）根据规则的编号去删除规则 先查看一下filter表中INPUT链的规则
假设我们需要删除第14条规则，可以使用下面命令
（2）根据具体的匹配条件与动作删除规则 删除下图中源地址为192.168.31.133，动作为ACCEPT的规则，于是，删除规则的命令如下
删除对应规则时，仍然使用-D选项，-D INPUT表示删除INPUT链中的规则，剩下的选项与我们添加规则时一样，-s表示以对应的源地址作为匹配条件，-j ACCEPT表示对应的动作为接受，所以，上述命令表示删除INPUT链中源地址为192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/445d188d7fc8a641bfd51dfe45c0a6b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8f96d252a47d3c09130d09a2729e2b7/" rel="bookmark">
			网络管理与运维：SNMP的原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、概述
简单网络管理协议SNMP（Simple Network Management Protocol）是广泛应用于TCP/IP网络的网络管理标准协议。SNMP提供了一种通过运行网络管理软件的中心计算机（即网络管理工作站）来管理设备的方法。
二、基本组件
SNMP基本组件包括网络管理系统NMS（Network Management System）、代理进程（Agent）、被管对象（Managed Object）和管理信息库MIB（Management Information Base）。如图所示，他们共同构成SNMP的管理模型，在SNMP的体系结构中都起着至关重要的作用。
1.NMS
NMS在网络中扮演管理者角色，是一个采用SNMP协议对网络设备进行管理/监视的系统，运行在NMS服务器上。
2.Agent
Agent是被管理设备中的一个代理进程，用于维护被管理设备的信息数据并响应来自NMS的请求，把管理数据汇报给发送请求的NMS。
3.Managed Object
Managed Object指被管理对象。每一个设备可能包含多个被管理对象，被管理对象可以是设备中的某个硬件，也可以是在硬件、软件（如路由选择协议）上配置的参数集合。
4.MIB
MIB是一个数据库，指明了被管理设备所维护的变量，是能够被Agent查询和设置的信息。MIB在数据库中定义了被管理设备的一系列属性：对象的名称、对象的状态、对象的访问权限和对象的数据类型等。通过MIB，可以完成以下功能：
SNMP的MIB采用树型结构，它的根在最上面，根没有名字。如图18-2所示，是MIB的一部分，它又称为对象命名树。每个对象标识符OID（object identifier）对应于树中的一个管理对象，该树的每个分支都有一个数字和一个名称，并且每个点都以从该树的顶部到该点的完整路径命名，如system的OID为1.3.6.1.2.1.1，interfaces的OID为1.3.6.1.2.1.2。
三、版本
SNMP有三种版本：SNMPv1，SNMPv2c和SNMPv3。
1.SNMPv1
SNMP的第一个版本，它提供了一种监控和管理计算机网络的系统方法，它基于团体名认证，安全性较差，且返回报文的错误码也较少。如图所示，
SNMPv1定义了5种协议操作：
Get-Request：NMS从被管理设备的代理进程的MIB中提取一个或多个参数值。Get-Next-Request：NMS从代理进程的MIB中按照字典式排序提取下一个参数值。Set-Request：NMS设置代理进程MIB中的一个或多个参数值。Response：代理进程返回一个或多个参数值。它是前三种操作的响应操作。Trap：代理进程主动向NMS发送报文，告知设备上发生的紧急或重要事件。 2.SNMPv2c
第二个版本SNMPv2c引入了GetBulk和Inform操作，支持更多的标准错误码信息，支持更多的数据类型。如图所示，
SNMPv2c新增了2种协议操作：
GetBulk：相当于连续执行多次GetNext操作。在NMS上可以设置被管理设备在一次GetBulk报文交互时，执行GetNext操作的次数。Inform：被管理设备向NMS主动发送告警。与Trap告警不同的是，被管理设备发送Inform告警后，需要NMS进行接收确认。如果被管理设备没有收到确认信息则会将告警暂时保存在Inform缓存中，并且会重复发送该告警，直到NMS确认收到了该告警或者发送次数已经达到了最大重传次数。 3.SNMPv3
SNMPv3增加了身份验证和加密处理的功能。
身份验证：身份验证是指代理进程（NMS）接收到信息时首先必须确认信息是否来自有权限的NMS（代理进程）并且信息在传输过程中未被改变。
加密处理：SNMPv3报文中添加了报头数据和安全参数字段。比如当管理进程发出SNMPv3版本的Get-Request报文时可以携带用户名、密钥、加密参数等安全参数，代理进程回复Response报文时也采用加密的Response报文。这种安全加密机制特别适用于管理进程和代理进程之间需要经过公网传输数据的场景。
本文部分内容参考《HCIA-datacom认证学习指南》
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2970f38797cf3cc02ae0f1c481b46a31/" rel="bookmark">
			[MySQL] MySQL 高级(进阶) SQL 语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、高效查询方式 1.1 指定指字段进行查看 事先准备好两张表
select 字段1，字段2 from 表名; 1.2 对字段进行去重查看 SELECT DISTINCT "字段" FROM "表名"; 1.3 where条件查询 SELECT "字段" FROM 表名" WHERE "条件"; 1.4 and 和 or 进行逻辑关系的增加 SELECT "字段" FROM "表名" WHERE "条件1" AND "条件2"; SELECT "字段" FROM "表名" WHERE "条件1" OR "条件2"; 1.5 查询取值列表中的数据 SELECT "字段" FROM "表名" WHERE "字段" IN ('值1'， '值2'， ...); #in,遍历一个取值列表 1.6 between的引用 SELECT "字段" FROM "表名" WHERE "字段" BETWEEN '值1' AND '值2'; 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2970f38797cf3cc02ae0f1c481b46a31/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c579db5f3e30d0571230f5eb969a58d9/" rel="bookmark">
			（附源码）SSM便民电子政务系统 计算机毕设45475
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目 录
摘要 1 绪论 1.1 研究意义 1.2研究方法 1.3ssm框架 1.4Vue.js 主要功能 1.4论文结构与章节安排 2
2 便民电子政务系统系统分析 2.1 可行性分析 2.2 系统流程分析 2.2.1 数据增加流程 2.2.2 数据修改流程 2.2.3数据删除流程 2.3 系统功能分析 2.3.1功能性分析 2.3.2非功能性分析 2.4 系统用例分析 2.5本章小结 3 便民电子政务系统总体设计 3.1 系统架构设计 3.2 系统功能模块设计 3.2.1整体功能模块设计 3.2.2用户模块设计 3.2.3 评论管理模块设计 3.3 数据库设计 3.3.1 数据库概念结构设计 3.3.2 数据库逻辑结构设计 3.4本章小结 4 便民电子政务系统详细设计与实现 4.1用户功能模块 4.1.1 前台首页界面 4.1.2 用户注册界面 4.1.3 用户登录界面 22
4.1.4 新闻动态界面 4.1.5 网上办事界面 4.1.6办事界面 4.1.7便民服务界面 4.2管理员功能模块 4.2.1 轮播图管理界面 4.2.2 系统用户管理界面 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c579db5f3e30d0571230f5eb969a58d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd318a651ec2cb3600fbdc043b468713/" rel="bookmark">
			【面试】1908- 面试官：跨页面通信的方式有哪些？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		面试官：跨页面通信的方式有哪些？
我：1. Web Worker；2.本地存储；3.postMessage等
面试官：本地存储都有哪些？
我：localStorage，sessionStorage，cookie。
面试官：sessionStorage可以吗？
我：不可用吧？
面试官：localStorage新开页面和当前页面open新页面都可以吗？
我：都可以吧?
....
有没有经历过面试用跨页面通信的问题不断深入的摧残你，但是你又不能给出明确回答的经历。巧了在下就经历过这个过程。为了痛定思痛决定从头开始将这些东西揉碎了吃到嘴里，然后面试的时候嚼碎了喂给面试官😈。
好了心碎的事情说完了下面直接上才艺。
同源页面间通信 什么是同源这个不过多解释了，大家可以自己了解一下[浏览器同源策略](developer.mozilla.org/zh-CN/docs/…[1])
1. localStorage 可以通过 localStroage.setItem() 在一个页面去写入一个值，然后在另一个页面中去获取。我们在A页面中添加一个按钮，用来设置 localStroage，然后在B页面添加一个定时器获取A页面设置的 localStroage，分别用直接链接访问和A页面跳转的方式打开B页面看是否能获取到A页面设置的 localStroage 的值。
A页面设置 localStroage值
直接通过A页面调整B页面的结果 image.png image.png 可以看到是可以访问到的。
通过链接直接访问B页面结果 image.png 结果同上是可以访问到的。
2. sessionStroage 操作方式同上面 localStroage，下面看一下结果
首先看A页面设置结果：
image.png 然后通过A页面跳转和直接访问B页面都得到结果是获取不到A页面设置的 sessionStroage：sessionStroage不支持跨页面通信。
image.png image.png 3.cookie 操作方式同上，在A页面设置了 testCookie=123 但是并不会在cookie中马上显示要刷新才能显示
image.png 通过两种方式打开B页面的结果 通过两种方式打开的B页面都可以获取到在A页面的cookie，所以可以通过Cookie进行跨页面通信。
image.png image.png 4. indexedDB 和 Web sql 如果页面有大量的数据需要交互，同时也需要做一些持久化的操作，前端的sql操作是一个比较好的选择，可以通过indexedDB创建一个关系型数据库来做数据存储，通过sql操作实现页面间的通信，更多的内容可以了解一下IndexedDB[2]的使用。
5.Broadcast Channel API Broadcast Channel API是HTML5提供的一种跨页面通信机制。它允许不同页面之间通过共享一个频道来进行通信。一个页面可以向频道发送消息，其他页面可以监听该频道以接收消息。
通过创建一个监听某个频道下的 `BroadcastChannel`[3] 对象，你可以接收发送给该频道的所有消息。一个有意思的点是，你不需要再维护需要通信的 iframe 或 worker 的索引。它们可以通过构造 `BroadcastChannel`[4] 来简单地“订阅”特定频道，并在它们之间进行全双工（双向）通信。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd318a651ec2cb3600fbdc043b468713/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19373cae8b7f3183f08aff0b943fbb15/" rel="bookmark">
			C语言多线程编程-线程基础概念
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍 线程基础概念主要包括以下几点：
线程定义：
线程是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一个进程可以包含一个或多个线程。
进程与线程的区别：
进程是系统资源分配的基本单位，每个进程都有独立的内存空间和系统资源。线程是CPU调度的基本单位，同一进程内的多个线程共享相同的内存空间（包括代码段、数据段和堆），但每个线程有自己的栈空间。 线程的优点：
提高程序的并发性：通过在一个进程中创建多个线程，可以同时执行多个任务，提高系统的利用率和响应速度。资源共享：同一进程中的线程可以共享全局变量、文件描述符等资源，减少数据复制和通信开销。更好的模块化：线程可以将复杂的任务分解为更小、更易于管理的模块。 线程的状态：
线程通常有以下几种状态：
新建（New）：线程已被创建但尚未启动。就绪（Ready）：线程已经准备好运行，等待CPU调度。运行（Running）：线程正在CPU上执行。阻塞（Blocked/Waiting）：线程由于等待某个事件（如I/O操作完成、锁的释放等）而暂停运行。死亡（Terminated）：线程已完成其任务或被取消，资源被回收。 线程同步：
由于多个线程共享相同的内存空间，可能会出现数据竞争、死锁等问题。因此，需要使用同步机制来协调线程之间的执行顺序和数据访问，常见的同步机制包括互斥锁、条件变量、信号量等。
线程生命周期：
线程从创建到结束的过程包括：创建、就绪、运行、阻塞、终止等阶段。线程的创建通常通过特定的API函数（如pthread_create在POSIX环境下），线程的终止可以通过返回、调用特定的退出函数（如pthread_exit）或被其他线程取消。
总结 理解这些线程的基础概念是进行多线程编程的前提，能够帮助开发者设计和实现高效的并发解决方案。在实际编程中，还需要注意处理线程安全问题，确保数据的一致性和正确性。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/031eb701968af3742eb16e589747253b/" rel="bookmark">
			php如何在header增加key，sign，timestamp,怎么实现鉴权？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、要在PHP中的header中增加key、sign和timestamp，并实现鉴权 ，可以按照以下步骤进行操作：
生成timestamp：使用time()函数获取当前时间戳。
生成sign：将需要鉴权的数据（例如请求参数）按照一定规则进行拼接，并使用密钥进行加密，生成sign。具体的拼接规则和加密方法可以根据实际需求选择，常见的有md5、sha1、HMAC等。例如：
$params = $_GET; // 假设请求参数在GET中 $key = 'your_secret_key'; // 替换为实际的密钥 ksort($params); // 对参数按照键名进行排序 $signStr = ''; foreach ($params as $k =&gt; $v) { $signStr .= "{$k}={$v}&amp;"; } $signStr .= "timestamp={$timestamp}&amp;key={$key}"; // 拼接需要加密的字符串 $sign = md5($signStr); // 使用md5加密生成sign 添加header：使用header()函数将生成的key、sign和timestamp添加到请求的header中。例如：
header('X-Auth-Key: your_key'); header('X-Auth-Sign: ' . $sign); header('X-Auth-Timestamp: ' . $timestamp); 服务端鉴权：在服务端接收到请求后，获取请求header中的key、sign和timestamp，然后根据同样的规则和密钥进行签名验证。验证的过程与生成sign的过程类似，将接收到的参数按照规则拼接，并使用密钥进行加密，然后与接收到的sign进行比对，如果一致则鉴权通过。
请注意，以上示例仅为演示目的，实际应用中需要根据具体情况进行调整和加强安全性措施，例如使用HTTPS传输等。
二、完整案例： 以下是一个示例的完整代码，用于在PHP中实现鉴权并在header中添加key、sign和timestamp：
&lt;?php function generateSign($params, $timestamp, $key) { ksort($params); // 对参数按照键名进行排序 $signStr = ''; foreach ($params as $k =&gt; $v) { $signStr .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/031eb701968af3742eb16e589747253b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d43307148f39eb9f32e91ddd02eae86/" rel="bookmark">
			用PHP做图片防盗链，你再也盗不了图片了？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考gpt，您可直接把问题或代码输入 https://www.askchat.ai?r=237422
可以使用PHP来实现图片防盗链。防盗链是一种措施，用于防止其他网站在未经授权的情况下直接链接到你的图片资源。下面是一种简单的PHP代码示例，可以用来检测并阻止盗链：
&lt;?php // 获取当前请求的域名 $referer = $_SERVER['HTTP_REFERER']; // 检查请求的来源是否为空或者不属于你的域名 if($referer &amp;&amp; !strstr($referer, "yourdomain.com")){ // 返回403 Forbidden header('HTTP/1.1 403 Forbidden'); exit; } // 如果检查通过，则输出图片 $imagePath = 'path_to_your_image.jpg'; header('Content-Type: image/jpeg'); readfile($imagePath); ?&gt; 在上述代码中，我们通过检查$_SERVER['HTTP_REFERER']来获取请求的来源，然后判断来源是否属于你的域名。如果来源不为空且不属于你的域名，那么就返回403 Forbidden状态码，阻止图片的显示。
请注意，这种简单的盗链防护方法可以容易地被绕过，因为$_SERVER['HTTP_REFERER']可以被伪造或者被某些浏览器禁用。更加安全可靠的防盗链方法可能需要结合其他技术和策略来实现。
如果你想要更可靠的图片防盗链方法，可以考虑以下几个方案：
服务器端配置：
使用服务器配置文件（如Apache的.htaccess文件）限制图片的直接访问。你可以设置只允许特定的域名或IP地址访问图片资源。这样，除了你允许的来源，其他网站将无法直接链接到你的图片。使用服务器脚本语言（如PHP）生成临时的授权链接，只有通过授权链接访问的请求才会被允许显示图片。 生成动态图片链接：
每次请求图片时，动态生成一个带有有效期的链接。这样，每个链接只能用于一次或者一段时间，防止链接被滥用。将图片链接中的一部分参数进行加密或哈希处理，使其不易被猜测或伪造。 检查请求头信息：
除了检查$_SERVER['HTTP_REFERER']外，还可以根据其他请求头信息来判断请求的合法性。例如，检查User-Agent、Accept等头信息，以确认请求是否来自合法的浏览器。 使用验证码或身份验证：
在图片显示之前，要求用户输入验证码或进行身份验证。只有通过验证的用户才能正常显示图片。 请注意，即使使用了多种防盗链技术，也无法完全阻止图片的盗链。对于高价值或敏感图片，建议采取更多的安全措施，如加密存储、访问控制等。最终，完全防止图片的盗链可能是不可行的，但以上方法可以增加盗链的难度和成本。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3931b2b6f00353ba89092c11573c3694/" rel="bookmark">
			Java 不同excel 版本poi如何给单元格设置背景颜色
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		poi poi-ooxml 5.2.3 &lt;dependency&gt;--&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt;--&gt; &lt;artifactId&gt;poi&lt;/artifactId&gt;--&gt; &lt;version&gt;5.2.3&lt;/version&gt;--&gt; &lt;/dependency&gt;--&gt; &lt;dependency&gt;--&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt;--&gt; &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt;--&gt; &lt;version&gt;5.2.3&lt;/version&gt;--&gt; &lt;/dependency&gt;--&gt; 可以自定义色号
CellStyle cellStyle = workbook.createCellStyle(); cellStyle.setFillForegroundColor(new XSSFColor(new Color(181, 230, 181),new DefaultIndexedColorMap())); poi poi-ooxml 4.1.2 读取超大Excel使用的流式输入，版本最高为4.1.2
&lt;dependency&gt; &lt;groupId&gt;com.monitorjbl&lt;/groupId&gt; &lt;artifactId&gt;xlsx-streamer&lt;/artifactId&gt; &lt;version&gt;2.2.0&lt;/version&gt; &lt;/dependency&gt; // 输出颜色目录 public static void exportExcelColorExample() throws Exception { XSSFWorkbook wb = new XSSFWorkbook(); Sheet sheetName = wb.createSheet("ColorExample"); Row row = sheetName.createRow(0); row.createCell(0).setCellValue("AQUA"); row.getCell(0).setCellStyle(getCellStyle(wb, IndexedColors.AQUA)); row.createCell(1).setCellValue("AUTOMATIC"); row.getCell(1).setCellStyle(getCellStyle(wb, IndexedColors.AUTOMATIC)); row.createCell(2).setCellValue("BLUE"); row.getCell(2).setCellStyle(getCellStyle(wb, IndexedColors.BLUE)); row.createCell(3).setCellValue("BLUE_GREY"); row.getCell(3).setCellStyle(getCellStyle(wb, IndexedColors.BLUE_GREY)); row.createCell(4).setCellValue("BRIGHT_GREEN"); row.getCell(4).setCellStyle(getCellStyle(wb, IndexedColors.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3931b2b6f00353ba89092c11573c3694/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6d8c6fafcafde181f6a2b53e453fa22/" rel="bookmark">
			Vue v-html中内容图片过大自适应处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前图片如下，图片已经超出了页面的展示范围
对v-html增加样式处理
&lt;div class="body padding-l scroll " v-html="docData.content"&gt; &lt;/div&gt; &lt;style scoped&gt; .body &gt;&gt;&gt; img { max-width: 100% ; } &lt;/style&gt; 效果如下：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa00705c512a300308bea76caa58c80b/" rel="bookmark">
			座舱音频系统的架构设计和音频体验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		编者按
近年来，智能座舱体验日益成为汽车竞争力的核心，智能座舱的多样体验正在成为用户购车时考虑的重要因素。
LiveVideoStack2023深圳站邀请到蔚来汽车座舱音频系统软件负责人高林，从主流音频架构设计、算法集成方案及体验影响、音频体验与整车融合的挑战三个方面，为大家介绍音频软件架构设计是如何影响智能座舱体验的。同时他希望通过此次分享，呼吁业界各方共同努力，大胆革新，化机遇为挑战。
文/高林
整理/LiveVideoStack
大家好，我是高林，蔚来汽车座舱音频系统软件负责人，拥有十余年音频系统开发经验。
蔚来汽车NT1/NT2平台座舱音频系统的软件架构设计和研发工作都由我负责，涉及到Android、QNX、Hypervisor等系统的音频设计。今天与大家交流的主题是：汽车座舱音频软件架构中算法集成方面的设计，以及对音频体验产生的影响。近两年，新能源汽车座舱这一领域发展较快，大家开始慢慢关注到这一行业。
下面来介绍座舱音频现状。
此前的传统汽车，消费者对座舱的音频体验不太关注，只要能播放音乐、广播就能满足需求，关注更多的是汽车的驾驶性能或是乘坐性能。近两年，随着智能汽车行业逐渐发展之后，消费者开始提出新的要求，例如是否能支持互联网接入、全景声音乐和多声道音乐体验，是否能将游戏APP融入座舱，这些逐渐成为大家购车时的重要考虑因素。
由于座舱的独特性，在驾驶的过程无法长时间通过屏幕观看视频，大众相较于视频会更关注音频，因此，座舱音频的重要性日益提升。座舱音频也得到了车企的广泛重视，音频系统APP在座舱中的推进也越来越快。例如，在这一波智能座舱浪潮当中，蔚来汽车首先将Dolby全景声功能集成到座舱中。半年之后，各个车厂便开始跟进这个功能。目前，Dolby全景声基本已经成为了新发布的新能源车的标配。通过这个案例，可以有效感受到音频功能在座舱推进的速度。
随着消费者对体验的要求越来越高，音频的需求也在不断增加。蔚来汽车每个月都会将许多APP添加到座舱当中，落地后便可以体验。座舱里的麦克风和扬声器的数量在不断地提升，比如蔚来汽车第二代的座舱有23个喇叭，可以满足消费者对于Dolby全景声的体验要求。
音频需求的增加对算力提出了更高的要求。虽然智能座舱芯片SOC的算力，相较于手机有所提升，但是仍旧无法满足座舱的要求，所以算力资源愈发紧张。正是由于算力有瓶颈，所以在来汽车在集成音频功能，包括音频的体验算法时，就需要全方位考虑各类因素。因此后续会谈谈音频领域的新挑战，包括目前在架构设计方面遇到的问题该如何解决，希望能和业界同仁一起推动音频技术在座舱领域更快更多运用。
接下来正式进入今天的主题。今天的主题分为三部分：首先介绍目前智能座舱的主流音频架构设计，其次分析智能座舱音频算法集成方案以及体验影响，最后再谈音频体验与整车功能融合方面的挑战。
01
智能座舱主流音频架构设计
在座舱系统领域，目前不同车企采用的架构各有不同。
这点与手机不同，目前手机行业基本分为两大系统，即Android系统和Apple系统。这两个系统在市场上占有率很高，因此消费者很难买到较为个性化的手机，每种手机的体验都较为相似。
而目前各大车企在座舱中采用的架构各不相同，市面上正在销售的汽车的座舱系统，很难找到完全相同的座舱设计，这给消费者带来了个性化、多样化的选择，但同时也给架构设计带来了挑战。
目前，主流的两种硬件方案可以分为单SOC和双SOC。在单SOC中有一个Hypervisor的虚拟机架构。Hypervisor虚拟机上可以跑其他的操作系统，有些支持QNX/Android架构，有些支持QNX/Linux架构的。单SOC和单系统架构，有支持单Android架构的，也有支持单Linux架构的。双SOC一般支持双系统架构，它有QNX/Android架构，也支持Linux/Android架构，以及Android/Android架构。根据不同厂商的设计和需求，可以选择不同的架构。
可以看几个案例：
第一类是单SOC、Hypervisor音频架构。如上图，左边为QNX系统，右边是Android系统。
Android系统分为几个简单的层次，包括APP层、Framework层（中间层）、还有Hal（硬件适配层），以及Kernel层。图上列了一些目前座舱基本都支持使用的典型APP，包括音乐类应用、视频类应用、语音类应用、TTS导航应用、游戏应用、广播应用。
QNX是传统车厂使用的系统，包括仪表盘、一些简单的广播应用，使用的就是QNX系统。报警音、AVAS（车外低速行驶音）、UPA、DVR（行车记录仪）等与车机安全相关的、与车身本身的功能联系较为紧密的功能，一般在QNX系统中做。其中，WTI与AVAS是法规规定要有的，也是传统车机里面所必需的，所以集中在QNX这个轻量化的系统里面做，可以满足法规的延时性需求。
单SOC的两个系统之间通过Hypervisor这一虚拟的通信机制进行通信。底层有专门给Audio（音频）提供算法运行的单独的处理单元，即ADSP，这也是大多数SOC厂商提供的架构。
第二类是单SOC和单Android的音频架构。有些车厂会采用这种架构，因为可以节省一些CPU资源。其中，Android架构基本没有变化，QNX中的一些功能会提升在Android的底层，比如Native层。这类轻量化的功能放在底层运行，延迟更低，处理起来更轻便，也能满足法规要求。
第三类是双SOC音频架构。双SOC架构拥有两个SOC芯片，它的底层有两路ADSP，同时拥有两个CPU，因此算力较为富余。双SOC架构为了兼容Android的生态，能够快速地将Android的APP移植进来，一般需要有一个Android系统。另外一个系统可以根据各个厂商的要求，选择QNX、Linux或Android系统。与法规相关的轻量化的功能，会单独在一个系统里运行。
02
智能座舱音频算法集成方案及体验影响
从系统的角度出发，目前座舱常用的音频算法可总结为五类。第一是语音交付类，目前使用较广的是前端的算法、语音识别的算法；第二是语音通话类，包括回声消除、降噪（即ECNR）等功能；第三是音乐音效类，包括了空间音效和Dolby全景声、音场模式、AGC、DRC等算法；第四是K歌娱乐类，包括防啸叫、降噪、评分、修音等功能；最后是与车身功能相关的功能，例如氛围灯随音乐律动、AVAS、3D WTI、RNC、ANC，以及主动降噪等功能。
接着以单SOC与Hypervisor的架构为例，介绍目前座舱音频算法的集成方法。
从系统的层面来讲，常用的集成方法是集成在Android Framework中。音效类的可以集成在Framework、APP、 HAL、Kernel、ADSP中，功放里面也可以集成一个音效算法。在QNX系统中，也可以有专门的Audio-Service来处理，它也可以集成一些音效算法。
常用的算法会集成在Framework、HAL、DSP、功放、QNX中，APP和Kernel则不是系统算法常用的集成方法。如果集成在单个APP中，可能只有单个的APP才能使用，不符合厂商车机的需求。如果集成在kernel中，由于Kernel是一个比较完整的系统，可能不符合架构上的需求，对Kernel影响比较大，所以不常用。
下面介绍一些目前各个厂商的车机都会用到的、已经落地的算法，包括算法的集成以及对体验的影响。
电话ECNR算法是一种很常见的算法，从工程化的角度上来说，它的集成难点在于MIC录音和参考信号相位对齐挑战较大。
电话ENCR算法的一种方案是集成在APP中，多应用于Voip通话方面。这种方案的底层录音和参考信号的获取通道，从底层延伸到最上层，还有一些与进程调度相关的问题。因此，这种方案会带来MIC录音和参考信号相位抖动、难以对齐的问题，回声消除效果难以保证。现在很多APP集成的ENCR算法，包括WebRTC，有些可能不是从底层直接获取到参考信号，而是截流的从VIP应用上播放的声音的参考信号，所以处理效果更难以保证。
另一个方案是集成在Hal层，这种方案更为常见，一般车体里的蓝牙电话就会用到这种方法。这个方法经过的层级比较少，Kernel运行的性能较为稳定，所以这个方案相位对齐较好，回声消除效果也较好。这个方案的劣势是，在CPU算力消耗比较高的情况下，Hal层的进程也会受到影响，这时它的相位抖动和回声消除效果也难以保证。
可以在底层获取到录音信号和参考信号时，将其拼接成一体，再从底层传到上层。通过这种方式，录音信号与参考信号在底层就能够对齐，减少抖动。
第三种方案是集成在音频专用的DSP中，例如ADSP中。这是最靠近录音前端的一个方案，也是最优的方案，适用于蓝牙通话。
这种方案的相位抖动较少，信号对齐问题也不大，最关键的是，它采用一个单独的处理单元，不会影响到CPU的算力。如果集成了较多功能，CPU受到影响，蓝牙通话的回声降噪效果也不会受到影响，这是其很大的优势之一。
目前各个新能源厂商基本都支持Karaoke功能。从集成的角度来看，这一功能最大的难点在于延时，例如通过话筒录音再播放，这个过程的延时要短。如果延时太长，用户就可能听到自己唱歌的声音，体验不佳。
方案一是集成在Hal中。如图所示，Karaoke的APP中带有评分算法，用户能够播放伴奏，用话筒录音，通过防啸叫和修音算法，然后分出一路传到APP上评分，另一路传到ADSP，从AMP功放播出。这是集成在Hal的方案，当然也可以选择集成在APP中，但是因为延时太长，目前各个厂商都放弃了这种方案。
Hal的方案，延时可以达到50毫秒左右。除了延迟较小，这个方案还有一大优势是不依赖于SOC的供应商，可以自主完成，工作量有保障。这个方案的劣势是会受到CPU系统性能的影响，如果算力没有富余，话筒录音可能会有丢帧和杂音的风险，延时难以保证。
方案二是集成在Kernel中，可以进一步缩短Loopback延时，相较于集成在Hal层，可以减少7~8毫秒。
这个方案也会受到系统性能的影响，如果CPU消耗太高，可能也会有丢帧、杂音的风险。它的劣势之一是需要SOC供应商提供技术支持，因为它对靠近底层的SOC硬件、DMV配合的依赖度较高，需要供应商提供技术支持，所有很多厂商放弃了这种集成方案。
最后一种是理论上最好的一个方案，即集成在ADSP中。录音通过Kernel传到ADSP里面，最后直接播出。这个方案延时最短，并且单独使用ADSP的功能，不会受到系统算力的影响。但这种方案的劣势在于，它依赖供应商支持。录音要传到CPU，再从CPU转到ADSP，而话筒多数是用USB接口传输语音，基本现在的SOC厂商都不支持从USB接口传到ADSP的功能，所以此方案虽然在理论上能给用户最好体验，但是推动起来技术难度非常高。目前，市面上基本没有车厂采用这个方案。
再举一个氛围灯的案例。氛围灯功能与车身的ECU联系比较紧密，也是多数厂商都已经落地的一个功能。它的技术难点之一是需要和音乐的节奏同步。
目前的车身ECU通过CAN信号传输而非互联网。互联网传输速度能达到千兆，而CAN的传输速度根据各个ECU的性能，有些ECU目前仅有几十兆的传输带宽，有些ECU能达到百兆的上传带宽，所以它的传输速度比较慢。
方案一是集成在APP里。在获取到音乐的节奏、响度等信号后，通过Android系统的Framework传到QNX系统的CANService，然后把CAN信号传输到氛围灯的ECU中，也就是其他供应商提供的氛围灯的ECU中。
CAN信号的传输路径在系统内部比较长，再通过CAN总线传到ECU上，信号的延时就更长。这种方案因为集成在APP中，所以只有单个APP才能使用氛围灯的节奏同步。整个的CAN信号传输链路，目前可以达到200毫秒，虽然它目前也有很多约束性条件，例如它的同步算法需要在APP里进行，同时如果CPU系统算力消耗过多，音乐和氛围灯的节奏就会出现不同步现象。
方案二是集成在Hal里。Hal层距离CANService更近，传输时间更短。该方案的优势之一是不会受到单个APP的局限，所有的APP都可以使用氛围灯算法。同时，与集成在App里相比，该方案氛围灯CAN信号链路的传输时间短50ml以上，达到150ms。当在Hal里做音乐播放和氛围灯节奏同步的算法时，如果CPU算力消耗比较多，Hal的节奏同步方案同样也会受到影响，出现音乐和氛围灯节奏不同步的现象。
方案三是集成在ADSP里。从理论上来看，该方案是最好的方案。首先，所有的音乐APP都能使用氛围灯的功能。其次，氛围灯CAN信号链路的时延最短，可达到100ms以上。此外，在ADSP里做节奏同步算法不会受到系统性能的影响。该方案的难点之一在于，由于SOC厂商提供的是一个约束性较强的处理单元，所以ADSP的内存有限，在CPU系统算力消耗较多时，音乐播放和氛围灯节奏同步会受到影响，无法满足需求。因此，虽然理论上这是很好的一个方案，但是由于种种约束条件，目前多数厂商未采用该方案。
总的来看，座舱架构设计影响音频算法效果的因素主要有延时、抖动、性能消耗、集成难度和音频硬件这几点。从技术上看，前四点影响较大。
其中，延时包括音频数据传输本身的延时、车身信号CAN信号传输和处理的延时以及对Karaoke和氛围灯的影响；
抖动包括ECNR相位的需求，与其他相位比较，其处理要求更高、影响更大。此外，语音识别会用到声源定位的算法，其对多MIC相位性要求较高；
从性能消耗因素来看，如果CPU算力不够用，会对算法产生影响，出现丢帧、卡帧等现象；
从集成难度来看，需要考虑能否解决对外依赖的问题，能否推动SOC厂商解决成本问题、人力问题。一些理论上好的方案可能由于实际集成起来难度较大而无法采用；
从音频硬件来看，MIC和喇叭的器件选型布局、电路布线、信噪比和扬声器解析度都会影响声音的播出效果和录音效果。
03
音频体验与整车融合的挑战
第一个挑战是复杂的座舱内音频环境。与座舱相比，手机的音频硬件环境更为简单。主要表现为手机对MIC和喇叭的数量有一定限制，通常为两到三个。然而，车舱的MIC数和扬声器数则越来越多，对音频算法的要求也越来越高。同时，座舱内的声学环境也比较复杂，尤其是车辆在中高速公路行驶的过程中会产生大量噪音，手机的算法挪用到车舱时对噪音的处理无法达到用户的需求。许多厂商在尝试各种方式来降低噪音或提升音效体验，但目前音效算法的噪音处理效果大多无法满足需求。
第二个挑战是复杂的座舱音频需求。一方面，随着座舱内部的MIC和扬声器数越来越多，手机的音频算法挪用到车机时无法满足处理需求，所以需要对算法进行重新开发和适配。同时，许多Android APP希望能在座舱内适配和落地。因此，对音频需求的落地速度和落地质量要求也越来越高。
另一方面，多个大屏的音频需求和分区播放音频已成为未来的座舱发展趋势。比如四座或六座车，每个座位前排都有一个单独的大屏可以分区播放不同的音频，使用不同的娱乐APP。目前谷歌专门给Android系统开发了车机版以适应这些需求，未来其开发方向也沿着分区播放趋势发展。
第三个挑战是Android音频架构的大量定制化。Android系统是针对手机开发的操作系统，它的很多功能与手机融合得较好。由于车机的MIC和扬声器数量较手机都增加较多，所以手机版Android对许多座舱音频功能都不支持，蔚来对Android架构修改较多。虽然谷歌也专门给Android系统开发了car版，但也无法满足音频处理的需求，也不支持Dolby的7.1.4和5.1声道的播放。同时，目前的Android也不支持多个大屏的音频需求定制和分区播放音频定制，都需要进行大量修改。
因此，尽管有些车机上有Android系统，许多APP仍然不能随意安装，需要各个厂商适配。每个厂家的Android系统都定制较多，第三方APP安装到车机上需要考虑是否能和Android系统融合，是否会影响车机的安全性能。
从多声道算法的集成角度来看，各厂商都在将手机的算法进行重新开发和适配以适应车机的多声道等算法要求，搭建多声道算法的集成架构。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa00705c512a300308bea76caa58c80b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a14831a0ef2be287b9602548eb5e02c/" rel="bookmark">
			【宝塔面板建站】本地连接云服务器的数据库 以阿里云服务器为例子（保姆级图文）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 实现效果实现过程1. 获取云服务的数据库root密码2.尝试本地连接2.1 端口放行2.2 云服务器授权本地访问MySQL权限 实现效果总结 『宝塔面板建站』分享宝塔面板从安装到实战的宝塔面板本机免云服务器免域名搭建网站等内容。 欢迎关注 『宝塔面板建站』 系列，持续更新中
欢迎关注 『宝塔面板建站』 系列，持续更新中
如果还没有安装好宝塔面板，可以参考前文。
【宝塔面板建站】01. 5分钟windows宝塔面板的安装（保姆级图文）
实现效果 在本地使用Navicat访问云服务器中的数据库.
实现过程 1. 获取云服务的数据库root密码 数据库-&gt;root密码
得到了密码
2.尝试本地连接 这一过程你可能会遇到下面的问题(之前连接过就不会遇到),后面的小结会分别说明
端口放行云服务器授权本地访问MySQL权限 配置成功
2.1 端口放行 mysql宝塔面板的默认端口3306,阿里云安全组中放行端口(最好是限制你的本地ip,安全一点)
2.2 云服务器授权本地访问MySQL权限 如果你出现错误：
1045 - Access denied for user ‘username’@‘IP’ (using password: YES)
这是因为没有给到远程用户访问云服务MySQL的权限
授权用户远程访问命令:GRANT {权限} ON {库表名} TO ‘{用户名}’@‘{访问地址}’ IDENTIFIED BY ‘{密码}’
参数说明: 权限：授权的操作权限，这里我用了all privileges 代表所有权限，或者是select,insert,update,delete等组合权限；库表 : 可以操作的库和表，指定数据库mydb的某个表mytable"数据库名.数据库中指定的表名",也即"mydb.mytable",指定数据库中全部的数据表"mydb."，全部数据库中全部的数据表,“.*”;用户名：远程访问的用户名,这里我是root访问地址：只允许用户在特定ip上链接数据库，“%”标识不限制IP。密码：用户远程链接数据库的密码，默认密码规则需要包括大小写字符、特殊字符和数字。这里我是用了我们前面获取的root密码 在终端中登录mysql
#登录到MySQL服务器 mysql -u root -p #mysql中执行授权本地ip可以访问命令 GRANT ALL PRIVILEGES ON *.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a14831a0ef2be287b9602548eb5e02c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/382d94dc19a75a07ef3fe6d4e408796f/" rel="bookmark">
			2024年JavaScript新潮流：探索5大构建系统，让你的项目更加高效！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着2024年的到来，JavaScript的世界再次迎来了技术革新的浪潮。今天，我有幸阅读了一篇国外技术大咖对即将主导这一年的5大JavaScript构建系统的深度解析。这不仅仅是一篇文章，而是一扇通往未来前端开发世界的窗户。我决定将其翻译并整理，与大家一同探索这些可能改变我们工作方式的工具。在这篇文章中，我们将一起揭开2024年构建系统的神秘面纱。让我们一起开始这场技术之旅，看看这些构建系统如何在新的一年里助我们一臂之力。以下，是我为您准备的精彩内容。
引言 随着JavaScript技术的不断进步，开发者面临着越来越多的挑战，尤其是在应用部署方面。从代码编译、测试执行到创建和更新发布版本，这一系列工作不仅耗时耗力，还需要持续监控以优化构建系统。这不仅分散了我们关注业务价值的精力，也可能使我们在竞争中落后。
应用部署的挑战与构建系统的重要性 部署应用程序是一个复杂且耗时的过程。作为开发者，我们需要考虑多个环节：
代码编译：将源代码转换成可执行的程序。
测试执行：确保代码的稳定性和可靠性。
发布版本的创建：生成可以部署的应用版本。
更新最新版本：保持应用与最新技术同步。
如果从零开始，这一系列工作需要几个月的时间来设置，且需要持续监控以不断优化构建系统。这意味着，你花在提供业务价值上的时间减少了，同时也让竞争对手有了超越的机会。
在这种情况下，构建系统（Build Systems）在开发流程中变得至关重要。它们提供了一个自动化的流程来处理上述要求，并确保提高慢速构建和协作的效率。
因此，本文将探讨2024年最值得关注的5大JavaScript构建系统，帮助你为下一个重要项目选择合适的构建工具。
五大JavaScript构建系统概览 Bit：专注于组件的构建系统，优化前端组件库的管理和构建。
Lerna：多包管理工具，适用于管理大型代码库中的多个包。
Turborepo：高性能的构建工具，专注于提升构建速度和效率。
NX：为现代Web应用提供全面的工作流管理和构建解决方案。
Bazel：Google开发的多语言支持的构建工具，适用于大型项目和多平台构建。
接下来，我们将逐一深入了解这些构建系统的特点和优势，以便为你的项目做出明智的选择。
Lerna：JavaScript项目的多包管理大师 Lerna。这可不是什么传统工具，而是一个专门用于管理多个包的JavaScript项目的强大利器。如果你还没听说过Lerna，那就真的out了！
Lerna的优势：为什么要用它？
管理多包项目的能手： Lerna的最大亮点在于它对多包项目（我们称之为“monorepo”）的高效管理。如果你的项目里有很多小包，用Lerna来管理会让事情简单得多。
版本控制和发布的轻松之选： Lerna让那些相互依赖的包的版本控制和发布变得轻松愉快。这意味着在整个项目中，你可以保持各个部分的一致性和同步。
并行执行： 对于开发者来说，Lerna支持并行执行，这大大加快了开发周期。
Lerna的局限性：它适合谁？
虽然Lerna听起来很棒，但它并不是每个项目都适用的。比如：
对于新手来说，Lerna的学习曲线可能有点陡峭。要想真正掌握它，可能需要一些时间和努力。
对于那些小型项目，Lerna可能会带来不必要的复杂性和开销。
因此，Lerna更适合那些大型的、包含多个相互依赖包的项目，或者是需要在一个仓库中维护共享组件的场景。
为什么Lerna很酷？
提高效率：在快节奏的开发环境中，谁不想快人一步？Lerna就是你的加速器。
现代化的项目管理： 对于追求新鲜和前沿技术的年轻开发者来说，Lerna代表了现代化的项目管理方式。
开源社区的支持： 加入使用Lerna的开发者行列，意味着你将成为一个活跃和充满活力的开源社区的一部分。
总的来说，Lerna是一个强大的工具，特别适合那些大型、复杂的JavaScript项目。它可能不适合每个人，但如果你正在处理一个包含多个包的大型项目，那么Lerna绝对值得一试。把握住它，你的项目管理效率将飞跃提升！
提示：如果你对Lerna感兴趣，或者想要开始一个大型的JavaScript项目，不妨尝试一下Lerna，看看它能给你带来怎样的变化！
NX：多框架支持的开发工具包 NX，这是一个基于Angular CLI构建的先进开发工具包。NX不仅仅局限于Angular，它还支持React、Node.js、Deno、Nuxt、Next.js等多种前端和后端框架！对于那些喜欢探索新技术、追求多样性的年轻开发者来说，NX简直是一种福音。
NX的亮点：为什么它这么受欢迎？
智能任务执行： NX优化了构建过程，其智能任务执行功能可以加快编译时间，提高开发者的工作效率。
框架无关性： NX不仅仅支持Angular，还能够适应多种不同的前端和后端框架，给开发者提供了极大的灵活性。
内置代码生成器： NX包含的代码生成器可以简化项目结构的维护，让开发过程更加顺畅。
NX的局限性：它适合什么样的项目？
虽然NX非常强大，但它也有一些局限性：
对于初次使用NX的开发者来说，初期的设置可能会有些复杂。
对于那些小型、需求简单的项目来说，NX可能会显得有些过于庞大。
因此，NX更适合那些大型应用，特别是那些涉及到多种技术的项目，或者是采用mono repo架构的团队。
NX的魅力在哪里？
技术多样性： NX支持多种框架，对于那些喜欢尝试新技术的年轻开发者来说，这提供了广阔的选择空间。
提升协作效率： 在多人团队中，NX的mono repo结构可以大幅提高代码共享和协作效率。
创新体验： 使用NX，你可以体验到最前沿的开发工具和方法，这对于追求新鲜事物的年轻人来说，无疑是非常吸引人的。
NX是一个功能强大、适应性强的开发工具包，非常适合那些大型、技术多样化的项目。它可能对新手来说有一定的挑战，但一旦掌握，将大大提升你的开发效率和项目管理能力。
小提示：如果你在寻找一个可以支持多种技术、提高团队协作效率的工具，那么NX绝对值得一试！尤其是对于那些涉足多种技术栈的大型项目，NX可以说是一个理想的选择。
Bit：现代化的JavaScript构建系统 简介
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/382d94dc19a75a07ef3fe6d4e408796f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/690a78e0df388845c8dcd4a1fc044b7b/" rel="bookmark">
			Java设计模式-组合模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、学校院系展示需求
二、传统方案解决 三、组合模式
（一）基本介绍
（二）原理类图
（三）能够解决的问题
（四）解决院系展示需求
（五）组合模式在JDK集合的源码分析 一、学校院系展示需求 编写程序展示一个学校院系结构：需求是这样，要在一个页面中展示出学校的院系组成，一个学校有多个学院，一个学院有多个系。如图： 二、传统方案解决 1) 将学院看做是学校的子类，系是学院的子类，这样实际上是站在组织大小来进行分层次的 2) 实际上我们的要求是 ：在一个页面中展示出学校的院系组成，一个学校有多个学院，一个学院有多个系， 因此这种方案，不能很好实现的管理的操作，比如对学院、系的添加，删除，遍历等
3) 解决方案：把学校、院、系都看做是组织结构，他们之间没有继承的关系，而是一个树形结构，可以更好的实现管理操作。 =&gt; 组合模式
三、组合模式 （一）基本介绍 1) 组合模式（ Composite Pattern ），又叫部分整体模式，它创建了对象组的树形结构，将对象组合成树状结构以表示“整体- 部分”的层次关系。 2) 组合模式依据树形结构来组合对象，用来表示部分以及整体层次。 3) 这种类型的设计模式属于结构型模式。 4) 组合模式使得用户对单个对象和组合对象的访问具有一致性， 即 ：组合能让客户以一致的方式处理个别对象以及组合对象 （二）原理类图 对原理结构图的说明-即(组合模式的角色及职责 ) 1) Component :这是组合中对象声明接口，在适当情况下，实现所有类共有的接口默认行为,用于访问和管理Component 子 部件, Component 可以是抽象类或者接口 2) Leaf : 在组合中表示叶子节点，叶子节点没有子节点 （三）能够解决的问题 1) 组合模式解决这样的问题，当我们的要处理的对象可以生成一颗树形结构，而我们要对树上的节点和叶子进行操作时，它能够提供一致的方式，而不用考虑它是节点还是叶子 2) 对应的示意图 （四）解决院系展示需求 抽象类OrganizationComponent public abstract class OrganizationComponent { private String name; // 名字 private String des; // 说明 protected void add(OrganizationComponent organizationComponent) { //默认实现 throw new UnsupportedOperationException(); } protected void remove(OrganizationComponent organizationComponent) { //默认实现 throw new UnsupportedOperationException(); } //构造器 public OrganizationComponent(String name, String des) { super(); this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/690a78e0df388845c8dcd4a1fc044b7b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67a0eec1d3e9fa248d390bb5e260fd86/" rel="bookmark">
			编写程序javapb对A[]={30，1，-9，70，25}数组由小到大排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		编写程序java对A[]={30，1，-9，70，25}数组由小到大排序，冒泡排序法
public class booktest {
public static void main(String[] args) {
int a[]={30,1,-9,70,25};
数组原始顺序：“);
for (int i=0;i&lt;;i++) + ” ”);
for (int i = 0; i &lt; ; i++) {
int lowerIndex = i;
for (int j = i + 1; j &lt; ; j++)
if (a[j] &lt; a[lowerIndex]) lowerIndex = j;
int temp = a[i];
a[i] = a[lowerIndex];
a[lowerIndex] = temp;
}
数组排序后的顺序： “);
for (int i=0;i&lt;;i++) + ” ”);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/67a0eec1d3e9fa248d390bb5e260fd86/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/460168c43f5f4fd84add570cda2a8e41/" rel="bookmark">
			uniapp中globaldata的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在uni-app中，globalData是一个全局的数据管理对象，可以在整个应用中访问和修改。通过globalData，你可以存储和获取全局变量，从而实现数据的共享和传递。
使用globalData可以大大减少代码的使用，避免在多个组件之间传递数据时出现各种复制和计算的问题。你可以在需要使用全局数据的页面中直接获取和修改globalData下的数据。
要设置或修改globalData中的数据，你需要在页面的生命周期函数中（例如onLoad、onShow等）使用getApp()方法获取app实例，然后通过app实例的globalData属性进行操作。例如：
需要注意的是，由于uni-app的多端运行特性，globalData在不同端的表现可能会有所不同。例如，在微信小程序中，globalData是全局唯一的，而在H5、APP等端上，每个页面都可以有自己的globalData。因此，在使用globalData时需要注意不同端的差异。
在 App.vue 可以定义 globalData ，也可以使⽤ API 读写这个值。 globalData⽀持vue和nvue共享数据。 是⼀种⽐较简单的全局变量使⽤⽅式。
&lt;script&gt;
export default{
globalData:{
text:'text'
},
onLaunch:function(){
console.log('App Launch')
},
onShow:function(){
console.log('App Show')
},
onHide:function(){
console.log('App Hide')
}
}
&lt;/script&gt;
&lt;style&gt;
/*每个页⾯公共css */
&lt;/style&gt;
js中操作globalData的⽅式如下：
赋值：getApp().globalData.text = ‘test’
取值：console.log(getApp().globalData.text)
如果需要把globalData的数据绑定到页⾯上，可在页⾯的onshow声明周期⾥进⾏变量重赋值。HBuilderX 2.0.3起，nvue页⾯在uni-app 编译模式下，也⽀持onshow。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/690f09628d3a1f0f3b6ea800db5c2884/" rel="bookmark">
			监控ip地址在哪里找出来
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​随着互联网的快速发展，越来越多的人开始关注网络安全和个人隐私保护问题。而监控IP地址成为了一种常见的手段，用来追踪和监视网络活动。那么，我们应该在哪里寻找监控IP地址的方法呢？本文将为您详细介绍寻找监控IP地址的方法和技巧。
首先，我们可以从网络安全公司和工具提供商那里寻找监控IP地址的方法。这些公司通常会开发和提供一些专门用于监控IP地址的工具和软件。您可以通过搜索引擎或咨询技术专家，寻找到这些可靠的资源。这些工具通常会提供详细的IP地址监控报告，包括IP地址的地理位置、使用者的身份信息等。通过这些信息，我们可以更加准确地了解网络活动的来源和目的。
其次，您还可以通过网络扫描工具来寻找监控IP地址的方法。网络扫描工具可以帮助我们主动探测网络上的设备和主机，并获取其IP地址和相关信息。通过使用这些工具，我们可以扫描整个网络或特定的IP地址范围，找到我们感兴趣的监控目标。网络扫描工具通常提供了丰富的功能和选项，可以根据不同的需求和目的进行定制。因此，您可以根据具体的需求选择适合自己的网络扫描工具。
另外，一些互联网平台和社交媒体上也提供了寻找监控IP地址的方法。比如，一些在线社交媒体平台上的“位置标签”功能可以让我们知道某个用户的IP地址所在地。通过查看用户的IP地址所在地，我们可以获得一些线索，找出这些用户的真实身份和活动轨迹。此外，大部分的搜索引擎也提供了类似的功能，可以通过搜索关键词来获取相关的IP地址信息。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e703341a9cb441af2acd19d4e172d64b/" rel="bookmark">
			Prim算法：如何快速求解最小生成树？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、普里姆（Prim）算法概述二、普里姆（Prim）算法的基本思路三、Prim算法实战 一、普里姆（Prim）算法概述 Prim算法是图论中的一种算法，可在加权连通图里搜索最小生成树。
最小生成树，简称MST。是给定一个带权的无向联通图，如何选取一颗生成树，使树上所有边权的总和为最小，这个树就叫最小生成树。最小生成树有以下特点：
N个顶点，一定有N-1条边包含全部顶点N-1条边都在图中 这个算法的常见用途就是在包含n个顶点的连通图中，找出只有（n - 1）条边包含所有n个顶点的连通子图，也就是最小生成树。
二、普里姆（Prim）算法的基本思路 Prim算法的思路如下：
设G=(V，E)是连通网，T=(U，D)是最小生成树，V,U是顶点集合，E,D是边集合。若从顶点u开始构造最小生成树，则从集合V中取出顶点u放进集合U中，并标记顶点v的visted[u]=1，表示该顶点已经使用（已经连通）。若集合U中顶点ui与顶点V-U中的顶点vj之间存在边，则寻找这些边中的权值最小的边，但不构成回路，将顶点vj加入集合U中，将边（ui，vj）加入集合D中，标记visted[u]=1重复步骤2，直到U与V相等，即所有顶点都被标记为已经访问过，此时D中有N-1条边 估计看了这个思路，人都蒙了，没事，继续看看下面的图解就会一目了然了。
三、Prim算法实战 1584. 连接所有点的最小费用 - 力扣（LeetCode）
在力扣1584题，是求坐标轴上的点的最小生成树，具体题目请看上述链接。
解题思路：使用Prim算法。
根据顶点的信息，生成邻接表定义几个变量 record：记录已经使用过的点recordDistance： 用来存储每个未被选中的点到record的最短距离。若已经被放入record中则设置为-1 初始化变量 将第0个顶点作为生成最小生成树的起始顶点初始化recordDistance，记录其他未使用的订单到最小生成树的最小距离，由于一开始最小生成树只有一个节点，于是最小距离就是其余顶点到这个最小生成树的节点的距离，也就是weight[0][i] 开始构造最小生成树 遍历recordDistance，找出其余顶点到最小生成树的最小距离，记录其下标以及最小距离。收集得到的最小距离将该下标的recordDistance最小距离设置为-1，表示已经使用了 更新recordDistance数组，更新其余顶点到最小生成树的最小距离，Math.min(recordDistance[i], weight[minIndex][i])，因为最小生成树新增了一个节点，那么有可能导致其他顶点到这个新增的节点的距离更近，于是需要更新recordDistance。 class Solution { public int minCostConnectPoints(int[][] points) { // 最终结果 int result = 0; // 邻接表 int[][] weight = new int[points.length][points.length]; // 初始化邻接表 for (int i = 0; i &lt; points.length; i++) { for (int j = i + 1; j &lt; points.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e703341a9cb441af2acd19d4e172d64b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8781ccdb49c7d56edc4f817e654a0229/" rel="bookmark">
			信息安全概论考试题目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、计算题二、网络安全协议应用(30 分)三、材料分析(15 分)四、系统安全配量(共 15 分) 一、计算题 1、Playfair 算法属于经典对称加密方式。曾经在相当长的一段时期内，Playfair算法被认为是一种牢不可破的加密方法。现有明文 introduction to informationsecurity 密钥关键词为: computer school。回答如下问题:
1，如何利用密钥关键词获得 Plafair 算法的密钥矩阵? (10 分)
2.请问明文中字母 i 对应的密文字母都有哪些? (10 分)
2. RSA 算法是一种公开密码算法。由于其形式优雅，原理简单且安全可靠，被
广泛的应用于多种系统中。在某一 RSA 系统中，已知用户 A 的公钥信息是[391，
7]，用户 B 截获到 A 加密后的密文为 30。回答如下问题:
1.给出 B 利用公钥数据，求解私钥的过程(10 分)。
2，给出 B 利用第一步获得的私钥，求解明文的过程，并给出具体的明文。(10
分)
二、网络安全协议应用(30 分) 学院现有一个创新团队正在设计实现一个安全的网络应用
系统该系统对数据安全的主要关注点是数据的完整性。开发团队最后决定使用
IPSec 协议实现安全通信。如果你是项目负责人，请回答如下问题:
(1) 为了使用 IPSec 协议提供的完整性安全服务，你选择哪个子协议，为什
么?(本小题 10 分)
(2) 如果通信系统使用的是 IPV4 且用传输模式，你认为数据包应该是什么样子
请图示出来。(本小题 10 分)
(3) 如果该系统的应用场景是某公司的两台服务器，请你选择一种身份认证的方
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8781ccdb49c7d56edc4f817e654a0229/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb35c4ae1b7041f45f6e45004d2cc428/" rel="bookmark">
			【Java EE初阶三 】线程的状态与安全（下）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		3. 线程安全 线程安全：某个代码，不管它是单个线程执行，还是多个线程执行，都不会产生bug，这个情况就成为“线程安全”。
线程不安全：某个代码，它单个线程执行，不会产生bug，但是多个线程执行，就会产生bug，这个情况就成为 “线程不安全”，或者 “存在线程安全问题”。 举个线程不安全例子,我们计算一个变量的自增次数，它循环了100000次，用两个线程去计算，各自计算循环50000次的次数。 3.1 线程不安全样例 根本原因：线程的随机调度，抢占式执行
代码结构：不同线程修改同一数据
直接原因：多线程操作不是原子的
由于线程的随机调度，抢占式执行（不可避免），代码结构会促进该原因加剧不良后果；
1、代码一分析----&gt;代码随机调度，抢占执行的例子
代码如下：
public class ThreadDemo4 { private static int count = 0; public static void main(String[] args) throws InterruptedException { Thread t1 = new Thread(() -&gt; { for (int i = 1; i &lt; 50000; i++) { count++; } }); Thread t2 = new Thread(() -&gt; { for (int i = 50000; i &lt;= 100000; i++) { count++; } }); t1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb35c4ae1b7041f45f6e45004d2cc428/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02da7ff1117e81a68e72630c794d26fc/" rel="bookmark">
			unity学习笔记----游戏练习01
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、添加游戏背景和卡片槽
1.植物在卡片槽上的状态有三种，高亮、灰色、冷却状态，现在以向日葵为列作为示例：
因此要创建三个Image，为其添加不同的状态：
然后去控制植物在冷却时的效果，这个时候需要设置图片的图像类型，将其设置为以填充，最后通过控制填充总数的值的变化来达到，冷却的显示效果。
设置好了之后为其创建一个公共的父类，然后将其设置为预设体。如下效果：
2.通过脚本控制不同状态，在CardTemplate上添加脚本来控制。
定义枚举来控制不同状态，在冷却完毕后会进入等待阳光的状态，当阳光够了之后会直接进入Ready状态，当我们点击后进入Cooling状态。
enum CardState
{
Cooling,
WaitingSun,
Ready,
}
定义一个默认状态的属性：
private CardState cardState = CardState.Cooling;
定义两个游戏物体引用，定义一个Image属性
public GameObject cardLight; public GameObject cardGray;
public Image cardMask;
定义冷却时间属性和计时器
public float cdTime = 2;
public float cdTimer = 0;
在Update里面使用switch语句来对不同状态进行判断，并在对应的状态调用对应的方法。
private void Update()
{
switch (cardState)
{
case CardState.Cooling:
CoolingUpdata();
break;
case CardState.WaitingSun:
WaitingSunUpdata();
break;
case CardState.Ready:
ReadyUpdata();
break;
default:
break;
}
}
现在为具体的方法写对应的逻辑
现在为不同状态的转换写入相应方法
切换到等待阳光状态：
void TransitionTowaitingSun()
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/02da7ff1117e81a68e72630c794d26fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/853e287181ed3ee059fc2b88a7e415f8/" rel="bookmark">
			Java 读取超大excel文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注意：此参考解决方案只是针对xlsx格式的excel文件！
Maven &lt;dependency&gt; &lt;groupId&gt;com.monitorjbl&lt;/groupId&gt; &lt;artifactId&gt;xlsx-streamer&lt;/artifactId&gt; &lt;version&gt;2.2.0&lt;/version&gt; &lt;/dependency&gt; 读取方式1 private static void readBigExcel(String filePath) throws FileNotFoundException { FileInputStream in = new FileInputStream(filePath); StreamingReader reader = StreamingReader.builder() .rowCacheSize(100) // number of rows to keep in memory (defaults to 10) .bufferSize(4096) // buffer size to use when reading InputStream to file (defaults to 1024) .sheetIndex(0) // index of sheet to use (defaults to 0) .read(in); // InputStream or File for XLSX file (required) for (Row r : reader) { for (Cell c : r) { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/853e287181ed3ee059fc2b88a7e415f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7aa337574fb8d9e6dccd3eab04036871/" rel="bookmark">
			SpringBoot——集成Jersey
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 Jersey1、SpringBoot依赖配置资源类测试 2、Actuator依赖解决根路径冲突 Jersey 1、SpringBoot 依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jersey&lt;/artifactId&gt; &lt;/dependency&gt; 注意：jersety starter模式使用jackson解析JSON
配置 @Component @ApplicationPath("/ws") public class JerseyConfig extends ResourceConfig { public JerseyConfig() { //注册单个资源类 register(DemoResource.class); //或直接声明资源包所在位置 // packages("pers.zhang.resource"); } } 资源类 @Path("hi") public class DemoResource { @GET @Produces("application/json") public List&lt;String&gt; hi() { List&lt;String&gt; result = new ArrayList&lt;&gt;(); result.add("hello world"); result.add("hello Jersey"); return result; } } 测试 @Test public void testGet() { Client client = ClientBuilder.newClient(); WebTarget webTarget = client.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7aa337574fb8d9e6dccd3eab04036871/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5bcbae48f0532b0a9ee191e56ec3715d/" rel="bookmark">
			Ps：图像处理器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ps菜单：文件/脚本/图像处理器
Scripts/Image Processor
尽管在 Photoshop 中有多种方式来存储和导出图像，但图像处理器 Image Processor脚本有着更强大的功能。
提示：
可在 Adobe Bridge 中打开 Photoshop 的图像处理器。
Br菜单：工具/Photoshop/图像处理器
Photoshop/Image Processor
◆ ◆ ◆
图像处理器的主要用途
1、可将一个或多个图像文件（包括 Raw 格式文档）输出为 JPEG、PSD 或 TIFF 格式，或者同时输出其中两种或全部三种格式。
JPEG 文件常用于 Web 发布。
TIFF 文件常用于打印输出。
PSD 文件常用于备份或进一步编辑。
2、输出时可调整图像大小，使其转换为指定的像素大小。
3、输出时可指定要运行的 Ps 动作。
比如，对一组图像进行统一的调色处理，或者进行基于 AI 技术的磨皮祛痘处理。
4、在输出的图像中还可嵌入 ICC 配置文件和版权元数据。
◆ ◆ ◆
命令选项说明
①选择要处理的图像
①Select the images to process
仅处理来自 Bridge 的文件
Process files from Bridge Only
使用 Adobe Bridge 打开“图像处理器”时才显示此选项。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5bcbae48f0532b0a9ee191e56ec3715d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5178478c607281e4b2662c4c9849e957/" rel="bookmark">
			【SpringCloud笔记】（12）分布式请求链路跟踪之Sleuth
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Sleuth 背景
在微服务框架中，一个由客户端发起的请求在后端系统中会经过多个不同的的服务节点调用来协同产生最后的请求结果，每一个前段请求都会形成一条复杂的分布式服务调用链路，链路中的任何一环出现高延时或错误都会引起整个请求最后的失败。
通俗的说：随着系统变得庞大，微服务模块增多，微服务之间的调用也变得极其复杂，我们有需要知道微服务一次请求走过哪些微服务，走过了哪些节点，当某个微服务出现故障时，我们能够及时追踪到
概述 https://github.com/spring-cloud/spring-cloud-sleuth
Spring Cloud Sleuth提供了一套完整的服务跟踪的解决方案
在分布式系统中提供追踪解决方案并且兼容支持了zipkin
搭建链路监控步骤 zipkin
Sleuth整合了zipKin
SpringCloud从F版起已经不需要自己构建Zipkin Server了，只需调用jar包即可
下载地址：https://dl.bintray.com/openzipkin/maven/io/zipkin/java/zipkin-server/2.12.9/zipkin-server-2.12.9-exec.jar
打开本地终端 使用 [java -jar zipkin-server-2.12.9-exec.jar]启动
访问地址：http://localhost:9411/zipkin/
出现该界面，访问成功
完整调用链路
表示一请求链路，一条链路通过Trace ld唯一标识，Span标识发起的请求信息，各span通过parent id关联起来
Trace:类似于树结构的Span集合，表示一条调用链路，存在唯一标识span:表示调用链路来源，通俗的理解span就是一次请求信息 精简图
Trace ld是一整条链路的唯一标识，Span id是每个环节的唯一标识，parent id与上一级的Span id一致，就是通过这种关系将各span关联起来
完成一次简单的调用
使用消费者80及提供者8001模块
pom（80同8001）
&lt;!-- 引入sleuth + zipkin --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-zipkin&lt;/artifactId&gt; &lt;/dependency&gt; yml（80同8001）
spring: zipkin: base-url: http://localhost:9411 sleuth: sampler: #采样率值介于 0 到 1 之间，1 则表示全部采集 probability: 1 8001 controller
@GetMapping("/payment/zipkin") public String paymentZipkin() { return "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5178478c607281e4b2662c4c9849e957/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4c843849855fa7651ed49544578f002/" rel="bookmark">
			计算机网络（第八版）期末复习（第一章概述）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 此处重要知识点已加粗，可以快速的过一遍。
二十一世纪的重要特征是：数字化、网络化、信息化。互联网、因特网（Internet）由数量极大的各种计算机网络互连起来的，具有两个重要基本特点：连通性、共享 ；指当前全球最大的、开放的、有众多网络相互连接而成的特定互联网，采用了TCP/IP协议族作为通信的规则。计算机网络（简称网络）由若干节点个连接这些节点的链路组成（由许多计算机互相连接在一起）。互联网（internet）：有多个网络通过一些路由器互相连接起来（形成的多个计算机网络），构成一个覆盖范围更大的计算机网络。互联网的三个阶段 第一阶段是从单个网络ARPANET互联网发展的过程。1969年美国国防部创建第一个分组交换网（只是单个的分组交换网并不是互连的网络）、1983年TCP/IP协议成为ARPANET上的标准协议。第二阶段的三个特点是建成了三级结构的互联网：NSFNET（国家科学基金网）提出的主干网、地区网、校园网（企业网）第三阶段的特点形成全球范围的多层次ISP结构的互联网，NSFNET被若干商用的互联网主干网替代，产生新名词：互联网服务提供者（ISP）如：中国联通...互联网协会（ISOC）下面有个组织互联网体系结构委员会（IAB）负责互联网有关协议的开发,IAB下面又设有两个工程部： 互联网工程部（IETF）：研究短期或中期的工程问题互联网研究部（IRTF）：研究长期考虑的问题，包括互联网的一些协议、应用、体系结构等制定互联网正式标准经过下面三个阶段： 互联网草案，有6个月有效期此时还不是RFC文档（互联网的标准都是以RFC文档在互联网上发表的，类似于开源项目，它可以从互联网上免费下载，还能通过邮件对某个RFC文档发表意见/建议）建议标准互联网标准互联网的组成 边缘部分（用户使用进行通信、资源共享）核心部分（为边缘部分提供服务的，连通性和交换）互联网的边缘部分 主机A和主机B进行通信 == 主机A的某个进程和主机B上的某个进程通信（计算机间的通信）端系统（互联网上的每台主机、手机、服务器...）的两种通信方法： 客户-服务器方式（C/S）：客户(client)和服务器(server)都是指通信中所涉及的两个应用进程。客户-服务器方式所描述的是进程之间服务和被服务的关系。(客户需要知道服务器地址web，服务器不用知道客户地址) 对等连接方式(P2P)：对等连接是指两个主机在通信时并不区分哪一个是服务请求方还是服务提供方。只要两个主机都运行了对等连接软件（P2P软件），它们就可以进行平等的、对等连接通信。（此时仍然使用客户-服务器方式只是每台主机即是客户又是服务器）互联网的核心部分（服务器） 电路交换：三个步骤的交换方式： 建立连接（占用通信资源）通话（一直占用）释放连接（归还）是端到端的，常用来传大数据和实时性的数据分组交换（互联网采用的就是分组交换） 特点：采用存储转发技术、不用建立连接、优点：高效（动态分配带宽、对通信链路逐段占用）、灵活（分组独立转发路由）、迅速（分组并且不用建立连接）、可靠（保证可靠性的网络协议）报文交换（用的很少了）按照网络的作用范围进行分类 广域网（WAN）：几十到几千公里，有时称为远程网。互联网的核心部分。城域网（MAN）：5~50公里（一个城市的距离）局域网（LAN）：局限较小的范围（1公里左右）个人局域网（PAN）：范围很小大约在10m左右，无线个人局域网WPAN单位转换：计算机网络的性能指标 速率宽带，网络宽带表示单位时间内网络中的某信道所能通过的最高数据率。单位就是数据率的单位 bit/s 比特每秒吞吐量：单位时间内通过某个网络的实际数据量（所有加起来）时延（延迟）：一端传送到另一端所需的时间 发送时延 = 数据帧长度（bit）/ 发送速率（bit/s）传播时延 = 信道长度（m）/ 电磁波在信道上的传播速率（m/s）。电磁波传播速率：自由空间的传播速率是光速 = 3.0 ⅹ 105 km/s、在铜线、电缆中的传播速率约 = 2.3 ⅹ 105 km/s、在光纤中的传播速率约 = 2.0 ⅹ 105 km/s处理时延 排队时延总时延 = 发送时延 + 传播时延 + 处理时延 + 排队时延例题：时延带宽积 = 传播时延 * 带宽往返时间RTT：表示从发送方发送完数据，到发送方收到来自接收方的确认总共经历的时间。 发送时间 = 数据长度 / 发送速率 有效数据率 = 数据长度 / 发送时间 + RTT 例题：利用率：有信道率和网络利用率两种 D = D0 / 1 - U （D0表示网络空闲时延、D表示网络当前的时延、设U为现在的网络利用率）利用率越高 , 时延越大 , 此时就会产生网络堵塞 ;协议与划分层次 网络协议：简称为协议，是为进行网络中的数据交换而建立的规则、标准或约定。网络协议有三个组成要素： 语法：数据与控制信息的结构或格式语义：要完成的功能同步：事件实现顺序的详细说明分层规则：相互独立（每层只有一个独立功能 ）、界限清晰（每层之间界限清晰 , 层级之间的交流尽量减少）、实现技术（每层都采用合适的技术实现）、独立特定（ 下层对上层是独立的 , 上层需要使用下层的服务）、标准工作（分层的结构可以促进标准化工作 ）协议结构（OSI的法定标准（理论成功，市场实践失败）、TCP/IP4层协议美国国防部提出（市场竞争成功）、五层协议的体系结构（学习时使用））： 应用层： 任务：通过应用进程间的交互来完成特定网络应用。协议是应用进程间通信和交互的规则（把应用层交互的数据单元称为报文），有DNS，HTTP，SMTP运输层：负责向两台主机中进程之间的通信提供通用的数据传输服务。 主要使用两种协议：传输控制协议（TCP）：面向连接的、可靠的传输服务、数据传输单位报文段用户数据报协议（UDP）：提供无连接的尽最大努力的数据传输服务、不可靠的数据传输服务、数据传输的单位是用户数据报网络层：为分组交换网上的不同主机提供通信服务。 任务： 路由选择（在互联网中每一个路由器上，生成用来转发分组的转发表）转发（路由器接收到分组时，会根据转发表转发到指明下一个的路由器）互联网使用的网络层协议是无连接的网络协议IP和许多路由选择协议，互联网的网络层也叫网际层/IP层，IP协议分组也叫做IP数据报数据链路层（链路层）：数据传输总是在一段段链路上传送的，故需要使用专门的链路层协议。 任务：实现两个相邻节点之间的可靠通信，将网络层传送下来的IP数据报组装成帧，在两个相邻节点间的链路上传送帧。物理层：在物理层上所传送数据的单位是比特，实现比特（0 或 1）的传输。实体：表示任何可发送或接收信息的硬件或软件进程（每一层 的活动 元素 是实体 ; 同一层的实体称为对等实体）。协议：控制两个对等实体（或多个实体）进行通信的规则（ 保证能够向上提供服务）的集合（对用户透明的、协议是水平方向的）。在协议的控制下，两个对等实体间的通信使得本层能够向上一层提供服务。要实现本层协议，还需要使用下一层所提供的服务。服务：是由下层向上层通过层间接口提供的操作（上层使用下层服务：即是垂直的）。服务访问点（SAP）：在同一系统中相邻两层的实体进行交互（交换信息）的地方。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9f8bf263d8a79abc66ab1b03b66ba22/" rel="bookmark">
			invalid credential,access_token is invalid or not latest,could get access_token by getStableAccess排查
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题 某次应用上线后，作为一个极其负责的开发者，对生产应用，即App进行功能验收。发现用户输入的敏感词内容没有被检测出来，一开始还以为是前端没有对接后端提供的接口。秉着怀疑他人前先怀疑自己的意识和职业素养，查看起ELK日志来，发现如下报错日志：
敏感词返回结果：{"errcode":40001,"errmsg":"invalid credential, access_token is invalid or not latest, could get access_token by getStableAccessToken, more details at https://mmbizurl.cn/s/JtxxFh33r rid: 657fb5df-054a7b70-55249500"} 排查 初步分析 敏感词检测逻辑方法源码如下：
private int sensitiveCheck(String content) { try { String accessToken = redisTemplate.opsForValue().get("ACCESS_TOKEN_CACHE:" + configService.getAppIdSelf()); if (null == accessToken) { accessToken = WxUtils.getAccessToken(configService.getAppIdSelf(), configService.getAppSecretSelf()); redisTemplate.opsForValue().set(RedisConstants.ACCESS_TOKEN_CACHE_PREFIX + configService.getAppIdSelf(), accessToken, 7200, TimeUnit.SECONDS); } return WxUtils.sensitiveCheck(accessToken, content); } catch (Exception e) { log.error("sensitiveCheck failed: ", e); // 网络异常等暂不考虑 return 0; } } 从Redis里获取到Access-Token，然后拿着这个Access-Token去请求微信提供的敏感词检测接口，参考官方给出的API文档。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b9f8bf263d8a79abc66ab1b03b66ba22/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/9/">«</a>
	<span class="pagination__item pagination__item--current">10/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/11/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>