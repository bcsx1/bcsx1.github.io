<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f21c241b1bea0c353eb18e618b14eb45/" rel="bookmark">
			WPF中的绑定知识详解（含案例源码分享）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✅作者简介：2022年博客新星 第八。热爱国学的Java后端开发者，修心和技术同步精进。
🍎个人主页：Java Fans的博客
🍊个人信条：不迁怒，不贰过。小知识，大智慧。
💞当前专栏：WPF 案例及知识分享专栏
✨特色专栏：乐趣国学-心性养成之路
🥭本文内容：WPF中的绑定知识详解（含案例源码分享）
文章目录 1、单向绑定2、双向绑定3、单向到源绑定4、命令绑定 当谈到WPF中的绑定，我们通常指的是数据绑定。数据绑定是一种机制，用于将数据源与用户界面元素（如控件）进行连接，以便在数据源发生更改时自动更新界面元素。这种机制使得开发人员能够轻松地实现MVVM（Model-View-ViewModel）模式，将数据和界面逻辑分离开来。
在WPF中，有几种不同类型的绑定可供选择，包括：
单向绑定（OneWay Binding）：数据源的更改会自动更新目标元素，但目标元素的更改不会反向更新数据源。双向绑定（TwoWay Binding）：数据源的更改会自动更新目标元素，同时目标元素的更改也会反向更新数据源。单向到源绑定（OneWayToSource Binding）：只有目标元素的更改会反向更新数据源，数据源的更改不会更新目标元素。命令绑定（Command Binding）：将命令与界面元素进行绑定，以便在用户交互时执行特定的操作。 1、单向绑定 单向绑定是一种数据绑定模式，它将数据源的值绑定到目标元素（如控件）的属性，使得当数据源的值发生变化时，目标元素的属性会自动更新。但是，目标元素的属性的更改不会反向更新数据源。
在WPF中，可以使用单向绑定来实现将数据源的值显示在界面上，而不需要手动更新界面元素。这对于显示静态数据或只读数据非常有用。
下面是一个示例，演示了如何在WPF中使用单向绑定：
&lt;Window x:Class="WpfApp.MainWindow" xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation" xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" Title="OneWay Binding Example" Height="200" Width="300"&gt; &lt;StackPanel&gt; &lt;TextBlock Text="{Binding Name}" /&gt; &lt;TextBlock Text="{Binding Age}" /&gt; &lt;/StackPanel&gt; &lt;/Window&gt; public class Person : INotifyPropertyChanged { private string _name; public string Name { get { return _name; } set { _name = value; OnPropertyChanged(nameof(Name)); } } private int _age; public int Age { get { return _age; } set { _age = value; OnPropertyChanged(nameof(Age)); } } public event PropertyChangedEventHandler PropertyChanged; protected virtual void OnPropertyChanged(string propertyName) { PropertyChanged?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f21c241b1bea0c353eb18e618b14eb45/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2943e666d4dbf39f8400ef7c07b6d532/" rel="bookmark">
			WIN11打开文件夹打开快捷方式等卡顿问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		笔者是2023年9月24置办的新电脑，如下：
今天使用过程中，突然发现操作卡顿，干啥都卡，比如打开计算机图标，等了2-3秒才有反应，重启电脑也没用，在不断尝试网上的各种方式后，总算找到一种靠谱的，特分享出来。
1.快捷键WIN+R，收入regedit（注册表），
2.找到
\HKEY_LOCAL_MACHINE
\SOFTWARE
\Microsoft
\Windows
\CurrentVersion
\Shell Extensions
\Blocked，如果没有Blocked这一项，请选择Shell Extensions右键新建(项)，项命名为Blocked（注意大小写）。
3.在Blocked项目中，右键，选择字符串值这一项，然后就会生成一个 新值，然后双击或者右键选择字符串这一项，就会弹出一个窗口，在下方填入
{e2bf9676-5f8f-435c-97eb-11607a5bedf7}后，重启电脑即可，你会发现，速度确实提升不少。
原理总结：就是手动调整WIN11资源器版本回退到WIN10，毕竟WIN10还是比WIN11稳定靠谱点。希望后面WIN官方可以优化这一块，如果对你有帮忙，请点个赞吧！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4a0ecd6df3cd53c3086731260199ad7/" rel="bookmark">
			如何利用echart实现数据可视化?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		工具包：
1.第三方可视化图表库:
Apache ECharts 2.echart.js下载地址：https://cdn.jsdelivr.net/npm/echarts@5.3.3/dist/echarts.min.js
一、具体使用ECharts 其实echart官方非常贴心，文档里面的使用手册写的很详细，在众多官方使用手册里，算的上是最容易让人理解，并能让小白最快速上手的官方说明了。
简单来说echarts所有的图表制作固定为三个步骤： 1.引入JS文件
&lt;!-- 1.引入 ECharts 文件 --&gt;
&lt;script src="./echarts/echarts.min.js"&gt;&lt;/script&gt;
2.准备HTML结构：一个盒子
&lt;!-- 2.为ECharts准备一个具备大小（宽高）的Dom --&gt;
&lt;div id="main" style="width: 600px;height:400px;"&gt;&lt;/div&gt;
3.JS初始化
不同的图表仅仅只是配置项和数据不同而已
注意：
官网CV过来声明变量用的是var，自行手动改成let或const，以及获取元素的方式也需要修改
真实项目中运用，找到项目里面对应装图表的盒子，更改一下3.1里面的dom元素
3.2 指定图表的配置项和数据需要替换，其他直接CV即可
CV注意检查Js引入的地址是否正确
以下是修改好的初始化内容：
&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
&lt;meta charset="UTF-8"&gt;
&lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
&lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt;
&lt;title&gt;Document&lt;/title&gt;
&lt;!-- 1.引入 ECharts 文件 --&gt;
&lt;script src="./echarts/echarts.min.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;!-- 2.为ECharts准备一个具备大小（宽高）的Dom --&gt;
&lt;div id="main" style="width: 600px;height:400px;"&gt;&lt;/div&gt;
&lt;script type="text/javascript"&gt;
// 3.1 基于准备好的dom，初始化echarts实例
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4a0ecd6df3cd53c3086731260199ad7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c781cbf3431f0d50377126bd83e5f0c6/" rel="bookmark">
			CDC实时数据同步
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一丶CDC实时数据同步介绍 CDC实时数据同步指的是Change Data Capture（数据变更捕获）技术在数据同步过程中的应用。CDC技术允许在数据源发生变化时，实时地捕获这些变化，并将其应用到目标系统中，从而保持数据的同步性。CDC实时数据同步具有以下优点：
实时性：能够几乎实时地将数据变更同步到目标系统中，保持数据的实时性。
高效性：只传输变更数据，减少了数据传输量，降低了网络带宽和存储需求。
灵活性：能够支持不同类型的数据源和目标系统，并适应复杂的数据同步需求。
可靠性：通过对变更操作进行校验和持久化，保证数据同步的可靠性和一致性。
二丶CDC实现方式 1.数据库日志解析：这是最常见的CDC实现方式之一。数据库引擎会以日志文件的形式记录数据变更操作，包括插入、更新和删除等。通过解析数据库的事务日志，可以捕获到数据的变更操作，并将其传输到目标系统进行同步。
2.触发器（Trigger）机制：数据库触发器也是常用的CDC实现方式之一。通过在源数据库表上添加触发器，当数据发生变更时，触发器会被激活并执行相应的逻辑，将变更操作记录下来，并发送到目标系统进行同步。
3.采集工具或代理程序：有些CDC工具提供了自己的采集器或代理程序，这些程序可以监控数据库的变更，并将变更数据捕获并传输到目标系统。这些工具通常会使用轮询或订阅发布模式来实现数据的实时捕获和同步。
4.日志追加（Log Appending）方式：这种方式适用于非关系型数据库或其他不支持传统CDC方法的数据存储系统。它基于日志追加的原理，将数据变更操作记录到一个日志文件中，然后将该日志文件传输到目标系统，目标系统根据日志文件进行数据同步。
三丶常用CDC工具 Sqoop Sqoop CDC通过监视源数据库的事务日志来实现数据的增量抽取。它能够检测到源数据库中发生的更改操作，并将这些更改操作应用于目标数据库，以保持两者的数据同步。使用CDC，用户可以在不间断的情况下将更新的数据批量和实时地移动到目标数据库中，而无需整体导出整个数据集。
DataX DataX CDC基于DataX框架，为用户提供了一种灵活、高效的数据同步解决方案。它通过监视源数据库的事务日志或数据库增量日志来捕获源数据库中的变更操作，并将这些操作应用于目标数据库，以保持两者之间的数据同步。这种增量方式可以大大减少数据传输的时间和成本，并提供更及时的数据更新。
Flink CDC Flink CDC利用Flink框架的流式计算能力来处理和转换变更数据。它使用源数据库的增量日志或者事务日志作为输入源，通过Flink的流处理引擎对日志进行实时解析和处理，并将解析后的数据应用于目标数据库，以实现数据的增量传输和同步。
ETLCloud ETLCloud CDC能够自动根据不同的数据库类型捕获数据变化日志可实现数据表的实时毫秒级同步，实时数据可同时并行分发到多个目标库或应用中。支持实时数据传输到Hive、MongoDB 、Doris、MQ中，同时也支持从MongoDB 、MQ、文件实时传输到SQL数据库中，支持一对多传输，支持多流合并传输，传输过程中支持数据质量检查，能实时把脏数据分发到指定表中并发送告警通知。
四丶CDC方案比较 上图为常用的CDC方案对比:
可以看到 ETLCloud 和 Flink CDC 在全量以及增量同步方面非常突出,并且都支持断点续传。而且ETLCloud CDC实现机制同时可兼容日志方式和查询方式。
ETLCloud CDC 相比于其他CDC方案,它的学习难度特别低,不像Flink CDC 学习难度比较高,还需要去编码去实现CDC。
在这些CDC方案中,ETLCloud CDC拥有极其丰富的说明文档和学习视频, 并且社区活跃度很高。
ETLCloud提供了简单易用的可视化管理界面,不仅可以轻松管理实时和离线数据,还支持监控集成任务的性能指标和运行状态,支持多种Sass和数据源。
零代码,简单,好用,只需几分钟就能快速实现CDC,下面我们就来体验下ETLcloud 的 CDC 数据实时同步:
登录ETLcloud 在首页选择实时数据集成
点击新建监听器
只需要简单的配置一下监听器,监听器可以选择实时输出到数据库或者ETL流程等
对监听的表写入100条数据
监听器立马监听到了这100条记录
我们来看一下源表数据:
我们再来看一下目标表数据,这里可以看到,我们的数据被自动的同步了过来
通过上述配置，轻松几步就可以快速监听同步实时变更的数据，整个过程非常简单，小白用户也能快速上手。
总结: 1.ETLcloud 的 CDC 免费使用, 并且比其他的CDC解决方案拥有更简单更好用的管理界面以及功能。
2.不需要较高的技术理解和配置,小白用户也能轻松上手。
3.支持大批量的数据同步处理。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c781cbf3431f0d50377126bd83e5f0c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf1718e71a3e82ab4440384d80ec5a89/" rel="bookmark">
			解决chrome浏览器netWork响应数据中文乱码的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目中遇到返回值出现如下图所示情况：
开发起来很麻烦，可以通过添加Source code扩展程序解决。
具体操作：
1、下载
地址：
https://github.com/jinliming2/Chrome-Charset/releases
或者：https://download.csdn.net/download/zuoyiran520081/88343308
下载Source code（我是直接下载的第三个）
2、添加到扩展程序
打开chrome设置——左侧菜单的扩展程序——打开”开发者模式“——”加载已解压的扩展程序“，选中后确定，出现如图
3、切换编码模式
如图进行对应切换即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1880daf95142c09813477766b107c90/" rel="bookmark">
			opencv学习笔记（十）：图像缩放、平移、旋转变换理论推导及应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		opencv学习笔记（十）：图像缩放、平移、旋转变换理论推导及应用 文章目录 opencv学习笔记（十）：图像缩放、平移、旋转变换理论推导及应用基础知识I——图像仿射变换基础知识II——图像插值算法1.为什么会有图像插值的概念？2.经典的图像插值算法最近邻插值（最简单的插值方法）双线性插值双三次插值 缩放变换——resize函数函数原型探究将一张图片缩小a倍，再将缩小后的图像放大a倍 平移变换——warpAffine函数函数原型实现一幅图像的平移 旋转变换——warpAffine函数原理推导情况1：绕原点旋转情况2：绕任意点旋转 函数原型实现一幅图像的旋转实现图像绕中心点无损旋转理论推导 仿射变换放射变换的变换矩阵推导函数原型实现仿射变换 透视变换——在车道线检测上的应用 基础知识I——图像仿射变换 仿射变换包括如下所有变换，以及这些变换任意次序次数的组合：
平移（translation）和旋转（rotation）顾名思义，两者的组合称之为欧式变换（Euclidean transformation）或刚体变换（rigid transformation）；
放缩（scaling）可进一步分为uniform scaling和non-uniform scaling，前者每个坐标轴放缩系数相同（各向同性），后者不同；如果放缩系数为负，则会叠加上反射（reflection）——reflection可以看成是特殊的scaling；
刚体变换+uniform scaling 称之为，相似变换（similarity transformation），即平移+旋转+各向同性的放缩；
剪切变换（shear mapping）将所有点沿某一指定方向成比例地平移。
上述变换都可以通过矩阵操作进行：
没有平移或者平移量为0的所有仿射变换可以用如下变换矩阵描述：
为了增添平移这一变换，变换矩阵写为：
基础知识II——图像插值算法 1.为什么会有图像插值的概念？ 以小图像放大为大图像为例：
从上图可以看出，当一个小图像放大为大图像时，像素点的位置坐标随之变化，放大后的图像会存在像素缺失（图中橙色点所示），如果这些位置上的像素不做处理就会造成图像严重失真，为了解决这个问题，便有了图像内插问题的提出。
2.经典的图像插值算法 最近邻插值（Nearest）双线性插值（Bilinear）双三次插值（Bicubic） 最近邻插值（最简单的插值方法） 如上图所示，图2.1是原始图像，图2.2是图2.1放大2倍以后得到的图像，其像素点的横纵坐标均扩大为原来的两倍，那么会产生出其他位置的新像素，如图2.2中浅色圆圈所示。
最近邻插值是将图2.2中五个未知像素点横纵坐标缩小2倍，那么这5个像素点的位置一定落在图2.1中四个像素的四邻域内，对于一个未知像素的像素点来说，其像素值和离它最近的已知像素点的像素值相同。
最近邻插值简单便捷，其计算速度快，但是当一个图片需要放大较大倍数时，会出现马赛克现象。举个简单例子，当一个图像放大500倍时，此时两个原有像素点之间就存在499个待插值，那么必定会存在有连续位置上的像素值相同，这样就会出现马赛克现象。
双线性插值 双线性插值有前提假设：假设原图像的灰度是线性变化的。
如上图所示，假设代插点映射回原图的位置为 e ( u , v ) e(u,v) e(u,v), u u u , v v v显然都是非整数， A A A, B B B, C C C, D D D四点对应的灰度值分别为 I ( i , j ) I(i,j) I(i,j), I ( i , j + 1 ) I(i,j+1) I(i,j+1), I ( i , j + 1 ) I(i,j+1) I(i,j+1), I ( i + 1 , j + 1 ) I(i+1,j+1) I(i+1,j+1)。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1880daf95142c09813477766b107c90/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/316697837057182d1edc47587015630b/" rel="bookmark">
			Antv G6入门之旅--combo图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
什么是AntV G6
G6 的特性
G6 文档
安装
1 在项目中使用 NPM 包引入
2 在 HTML 中使用 CDN 引入
使用
Step 1 创建容器
Step 2 数据准备
Step 3 创建关系图
Step 4 配置数据源，渲染
React 中使用 G6
Combo图
什么是AntV G6 G6 是一个图可视化引擎。它提供了图的绘制、布局、分析、交互、动画等图可视化的基础能力。旨在让关系变得透明，简单。让用户获得关系数据的 Insight，为数据科学家和开发者提供了一种全新的方式来展示和探索数据。我曾经使用过 ECharts 与 D3.js，当我遇见 AntV G6 后，突感惊喜，其内含丰富的效果与强大的功能。相对于 ECharts，AntV G6 的图表种类更多，也更灵活，更容易上手；而相对于 D3.js，AntV G6 的 API 更为简单易用，适合快速上手。
基于 G6，用户可以快速搭建自己的 图分析 或 图编辑 应用。
如果您还没有使用过 G6， 建议通过 快速上手 抢先体验 G6 的魅力。
G6 的特性 G6 作为一款专业的图可视化引擎，具有以下特性：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/316697837057182d1edc47587015630b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d5b102b38ec255b794978ce347852fa/" rel="bookmark">
			什么是XSS：XSS攻击、防御和C#编程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		XSS - 或跨站点脚本 - 是 Web 应用程序中最常见的漏洞之一。它已经出现在 OWASP Top 10 列表（Web 应用程序最严重的安全风险列表）中已有一段时间了。今天就带大家一起弄清楚浏览器是如何从第三方网站获取和执行脚本，以及这可能导致的后果，我们一起谈谈保护自己免受 XSS 攻击的方法。
什么是 XSS
跨站点脚本 (XSS) 是一种攻击 Web 系统的方法。入侵者将恶意代码嵌入到网页中。此代码与入侵者的服务器交互。代码通常在用户的浏览器中执行，作为网页呈现，或者在用户执行某些操作后执行，频率较低。通常，入侵者需要你做的一切就是打开一个嵌入了恶意代码的网页——入侵者就可以利用 XSS 漏洞。XSS在 2017 年 OWASP 十大漏洞列表Web 应用程序中最危险的漏洞列表中排名第 7 的原因之一。
当我们搜索网页时，浏览器无法区分纯文本和 HTML 标记。这就是为什么浏览器在呈现网页时会执行标签。浏览器的这种特性，是 XSS 攻击网站的主要手段的原因。
要进行 XSS 攻击，需要执行以下操作：
将与入侵者的网络服务器交互的恶意代码嵌入到网页中；
当页面在浏览器中呈现或当用户执行特定操作时执行嵌入代码。
我们看一下 XSS 攻击示例
从头开始。首先是如何将代码嵌入网页？我的第一个方法是使用 GET 请求参数。使用下面逻辑创建示例网页，如果GET请求的xss参数为空，则在网页上显示如下信息：Empty 'xss' parameter ;否则，显示来自xss参数的数据。
该页面的代码：
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;title&gt;XSS Example&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div style="text-align: center"&gt;Value of the 'xss' parameter: &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; &lt;script&gt; var urlParams = new URLSearchParams(window.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d5b102b38ec255b794978ce347852fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13c5eddf5721a119410cbd41cf9cd8e6/" rel="bookmark">
			java中前&#43;&#43;、后&#43;&#43;和return的执行顺序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		直接po代码案例
运行结果如下：
完整的代码如下：
package test; public class Test { int a = 5; int b = 10; int c = 200; int d = 500; int e = 800; public int functionA() { System.out.println("操作变量a之前，a = " + a); a++; System.out.println("操作变量a之后，a = " + a); return a; } public int functionB() { System.out.println("操作变量b之前，b = " + b); ++b; System.out.println("操作变量b之后，b = " + b); return b; } public int functionC() { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13c5eddf5721a119410cbd41cf9cd8e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7dc7748d42264393c565717d51cb0785/" rel="bookmark">
			python 小案例105
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下面是一个使用Python进行假设检验的案例，涉及到概率分布和正态分布的概念：
假设我们有一家电子产品公司，想要评估他们生产的某个产品的平均寿命是否符合标准。标准要求平均寿命应大于等于1000小时。
步骤：
建立假设：
原假设（H0）：产品的平均寿命 ≥ 1000小时
备择假设（H1）：产品的平均寿命 &lt; 1000小时
收集样本数据：
从生产线上随机选择一批产品，并记录每个产品的寿命（以小时为单位）
计算样本均值和标准差：
使用Python的统计库（如numpy或pandas）计算样本的均值（mean）和标准差（std）
假设检验：
假设产品的寿命服从正态分布，我们可以使用正态分布的性质进行假设检验。
计算样本均值的标准误差（standard error）
根据样本均值、标准误差和样本容量，计算t统计量（t-statistic）
根据t统计量和自由度（样本容量减去1），计算p-value
结果解释：
如果p-value小于预先设定的显著性水平（通常为0.05），我们拒绝原假设，接受备择假设，即认为产品的平均寿命小于1000小时。
如果p-value大于等于显著性水平，我们无法拒绝原假设，即没有足够的证据支持产品的平均寿命小于1000小时。
下面是一个简单的Python代码示例，演示了上述步骤：
import numpy as np from scipy import stats # 收集样本数据 sample_data = [985, 1002, 1023, 992, 1015] # 计算样本均值和标准差 sample_mean = np.mean(sample_data) sample_std = np.std(sample_data) # 假设检验 population_mean = 1000 # 总体均值 alpha = 0.05 # 显著性水平 # 计算标准误差 standard_error = sample_std / np.sqrt(len(sample_data)) # 计算t统计量 t_statistic = (sample_mean - population_mean) / standard_error # 计算p-value p_value = stats.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7dc7748d42264393c565717d51cb0785/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e336726786dfdc2b2b0672a1ab39d6a/" rel="bookmark">
			微信小程序之微信授权登入及授权的流程讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、微信登录流程讲解 1. 微信登录图解 2.认识openid，unionid 和code 2.1 openid
openid是用来唯一标识用户的一个字符串。在微信小程序中，每个用户的openid都是唯一的。通过openid，小程序可以获取用户的基本信息，如头像、昵称等。
注意： 同一个用户在不同的小程序中拥有不同的openid。因此，在开发小程序时，不能使用openid来进行用户的唯一性判断。
2.2 unionid
unionid是在用户绑定同一微信开放平台账号下的多个应用时，用来唯一标识用户的一个字符串。如果用户在多个小程序中使用同一个微信号进行登录授权，那么这些小程序中的unionid都是相同的。
注意： 用户的unionid只有在用户将多个应用绑定到同一个微信开放平台账号下时才会生成。因此，如果用户没有绑定多个应用，那么小程序将无法获取用户的unionid。
2.3 code
code是用户登录凭证，由微信服务器颁发给小程序。在用户授权登录后，小程序可以通过调用微信登录接口获取用户的code。然后，通过code向微信服务器请求用户的openid和session_key等信息。
注意： 每个code只能使用一次，且有效期为5分钟。因此，在使用code进行登录时，需要及时将其转换成用户的openid和session_key等信息，以免出现code过期的情况
openid、unionid和code是微信小程序登录授权中非常重要的三个参数，了解这些参数的作用和用法，有助于开发者更好地设计和开发小程序登录授权功能。
解释：
通过wx.login()获取code。将这个code发送给后端，后端会返回一个token，这个token将作为你身份的唯一标识。将token通过wx.setStorageSync()保存在本地存储。用户下次进入登录界面时，会先通过wx.getStorageSync() 方法判断token是否有值，如果有值，则可以请求其它数据，如果没有值，则进行登录操作。 二、登录方法讲解 wxLogin 调用接口获取登录凭证（code）。通过凭证进而换取用户登录态信息，包括用户在当前小程序的唯一标识（openid）、微信开放平台账号下的唯一标识（unionid，若当前小程序已绑定到微信开放平台账号）及本次登录的会话密钥（session_key）等。用户数据的加解密通讯需要依赖会话密钥完成。
效果图：
该方法对于用户的体验及安全性问题有所欠缺，点击就直接获取到了用户的信息，进行了一个显示，这个方法官方已经不推荐了。
wx.getUserProfile 获取用户信息。页面产生点击事件（例如 button 上 bindtap 的回调中）后才可调用，每次请求都会弹出授权窗口，用户同意后返回 userInfo。该接口用于替换 wx.getUserInfo，详见 用户信息接口调整说明。
效果图:
需要用户允许才能进行下一步,安全性大大提高
三、数据交互授权登入 1. 前端 api.js
// 以下是业务服务器API地址 // 本机开发API地址 var WxApiRoot = 'http://localhost:8080/oapro/wx/'; // 测试环境部署api地址 // var WxApiRoot = 'http://192.168.191.1:8080/oapro/wx/'; // 线上平台api地址 //var WxApiRoot = 'https://www.oa-mini.com/demo/wx/'; module.exports = { IndexUrl: WxApiRoot + 'home/index', //首页数据接口 SwiperImgs: WxApiRoot+'swiperImgs', MettingInfos: WxApiRoot+'meeting/list', AuthLoginByWeixin: WxApiRoot + 'auth/login_by_weixin', //微信登录 UserIndex: WxApiRoot + 'user/index', //个人页面用户相关信息 AuthLogout: WxApiRoot + 'auth/logout', //账号登出 AuthBindPhone: WxApiRoot + 'auth/bindPhone' //绑定微信手机号 }; 个人中心
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e336726786dfdc2b2b0672a1ab39d6a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2bd0f285e758bf46d698da2bcc7b80e5/" rel="bookmark">
			non-manifold edges found for part“shell“
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9dcfa6f820e979ea4a908082788c3abd/" rel="bookmark">
			阿里云服务器x86计算架构ECS实例规格汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		阿里云企业级服务器基于X86架构的实例规格，每一个vCPU都对应一个处理器核心的超线程，基于ARM架构的实例规格，每一个vCPU都对应一个处理器的物理核心，具有性能稳定且资源独享的特点。阿里云服务器网aliyunfuwuqi.com分享阿里云企业级X86计算架构云服务器ECS实例规格大全：
目录
阿里云企业级服务器ECS实例规格大全
企业级x86计算架构ECS云服务器实例规格
共享型x86计算架构ECS云服务器实例规格
阿里云企业级服务器ECS实例规格大全 企业级云服务器也可以理解为独享型云服务器，与企业级对应的是共享型云服务器，二者区别参考：阿里云服务器ECS共享型和独享型有什么区别？共享是什么意思？
阿里云服务器架构和ECS实例规格
企业级x86计算架构ECS云服务器实例规格 通用型实例规格族g8a通用型实例规格族g8i通用平衡增强型实例规格族g8ae存储增强通用型实例规格族g7se通用型实例规格族g7a通用型实例规格族g7安全增强通用型实例规格族g7t网络增强型实例规格族g7ne网络增强通用型实例规格族g7nex通用算力型实例规格族u1海光通用型实例规格族g7h海光通用型实例规格族g6h通用型实例规格族g6通用型实例规格族g6a安全增强通用型实例规格族g6t通用平衡增强型实例规格族g6e网络增强通用型实例规格族g5ne阿里云CLUB中心：aliyun.club 领取专属代金券计算型实例规格族c8a计算型实例规格族c8i计算平衡增强型实例规格族c8aeRDMA增强型实例规格族c7re存储增强计算型实例规格族c7se网络增强计算型实例规格族c7nex计算型实例规格族c7a计算型实例规格族c7安全增强计算型实例规格族c7t计算型实例规格族c6计算型实例规格族c6a安全增强计算型实例规格族c6t计算平衡增强型实例规格族c6e密集计算型实例规格族ic5内存型实例规格族r8a内存型实例规格族r8i内存平衡增强型实例规格族r8ae内存增强型实例规格族re7p内存型实例规格族r7p存储增强内存型实例规格族r7se内存型实例规格族r7a内存型实例规格族r7安全增强内存型实例规格族r7t内存型实例规格族r6持久内存型实例规格族re6p内存型实例规格族r6a内存平衡增强型实例规格族r6e内存增强型实例规格族re6大数据存储密集型实例规格族d3s大数据计算密集型实例规格族d3c大数据计算密集型实例规格族d2c大数据存储密集型实例规格族d2s大数据网络增强型实例规格族d1ne本地SSD型实例规格族i4本地SSD型实例规格族i4g本地SSD型实例规格族i4r性能增强型本地盘实例规格族i4p本地SSD型实例规格族i3g本地SSD型实例规格族i3本地SSD型实例规格族i2本地SSD型实例规格族i2g本地SSD型实例规格族i2ne本地SSD型实例规格族i2gne高主频计算型实例规格族hfc8i高主频计算型实例规格族hfc7高主频计算型实例规格族hfc6高主频通用型实例规格族hfg8i高主频通用型实例规格族hfg7高主频通用型实例规格族hfg6高主频内存型实例规格族hfr8i高主频内存型实例规格族hfr7高主频内存型实例规格族hfr6通用型实例规格族g5通用网络增强型实例规格族sn2ne计算型实例规格族c5计算网络增强型实例规格族sn1ne内存型实例规格族r5内存增强型实例规格族re4内存增强型实例规格族re4e内存网络增强型实例规格族se1ne内存型实例规格族se1大数据型实例规格族d1本地SSD型实例规格族i1高主频计算型实例规格族hfc5高主频通用型实例规格族hfg5 共享型x86计算架构ECS云服务器实例规格 经济型实例规格族e突发性能实例规格族t6共享标准型实例规格族s6突发性能实例规格族t5CPU超分型实例规格族v5上一代共享型实例规格族xn4、n4、mn4、e4 阿里云服务器企业级不只是X86计算架构，还包括ARM计算架构、企业级异构计算GPU、弹性裸金属服务器和超级计算集群（SCC）等，更多关于云服务器ECS说明请参考：aliyunfuwuqi.com/go/ecs 有ECS云服务器的详细配置和报价说明。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05b9226f892b36b27497240596b142e7/" rel="bookmark">
			Unity编辑器扩展 --- AssetPostprocessor资源导入自动设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		unity导入资源的编辑器设置: 防止策划资源乱导入,资源导入需要的格式，统一资源管理
AssetPostprocessor资源导入管线
AssetPostprocessor用于在资源导入时自动做一些设置，比如当导入大量图片时，自动设置图片的类型，大小等。AssetPostprocessor作为资源导入的管理器，可以根据不同的资源类型，在导入前、导入后做一些处理。
示例：对图片纹理的设置需要放在OnPreprocessTexture方法中执行
using System.Collections; using System.Collections.Generic; using UnityEditor; using UnityEngine; public class TexturePostProcessor : AssetPostprocessor { void OnPreprocessTexture() { TextureImporter textureImporter = (TextureImporter)assetImporter; textureImporter.textureType = TextureImporterType.Default; textureImporter.mipmapEnabled = false; textureImporter.alphaIsTransparency = true; textureImporter.npotScale = TextureImporterNPOTScale.ToNearest; textureImporter.isReadable = false; textureImporter.wrapMode = TextureWrapMode.Clamp; int width = 0, height = 0; textureImporter.GetSourceTextureWidthAndHeight(out width, out height); Debug.LogErrorFormat("宽{0}， 高{1}", width, height); if (assetPath.Contains("Assets")) { Debug.LogError(assetPath); } } } 一般常用的几个方法：
OnPreprocessTexture：在导入纹理贴图之前调用
OnPreprocessModel：在导入模型之前调用
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05b9226f892b36b27497240596b142e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6a265471b60d66acbbf7c855a636614/" rel="bookmark">
			CSDN提供的Markdown常用模板
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		标题 新的改变 我们对Markdown编辑器进行了一些功能拓展与语法支持，除了标准的Markdown编辑器功能，我们增加了如下几点新功能，帮助你用它写博客：
全新的界面设计 ，将会带来全新的写作体验；在创作中心设置你喜爱的代码高亮样式，Markdown 将代码片显示选择的高亮样式 进行展示；增加了 图片拖拽 功能，你可以将本地的图片直接拖拽到编辑区域直接展示；全新的 KaTeX数学公式 语法；增加了支持甘特图的mermaid语法1 功能；增加了 多屏幕编辑 Markdown文章功能；增加了 焦点写作模式、预览模式、简洁写作模式、左右区域同步滚轮设置 等功能，功能按钮位于编辑区域与预览区域中间；增加了 检查列表 功能。 功能快捷键 撤销：Ctrl/Command + Z
重做：Ctrl/Command + Y
加粗：Ctrl/Command + B
斜体：Ctrl/Command + I
标题：Ctrl/Command + Shift + H
无序列表：Ctrl/Command + Shift + U
有序列表：Ctrl/Command + Shift + O
检查列表：Ctrl/Command + Shift + C
插入代码：Ctrl/Command + Shift + K
插入链接：Ctrl/Command + Shift + L
插入图片：Ctrl/Command + Shift + G
查找：Ctrl/Command + F
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c6a265471b60d66acbbf7c855a636614/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/461d045882adae617d01690f5b913e70/" rel="bookmark">
			无线局域网技术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近几年，无线局域网开始在市场中独霸一方。越来越多的机构发现无线局域网是传统有线局域网不可缺少的好帮手，它可以满足人们对移动、布局变动和自组网络的需求，并能覆盖难以铺设有线网络的地域。无线局域网是利用无线传输媒体的局域网。就在前几年，人们还很少使用无线局域网。原因包括成本高、数据率低、职业安全方面的顾虑以及需要许可证。随着这些问题的逐步解决，无线局域网很快就开始流行起来了。
无线局域网的应用
局域网的扩展
在20世纪80年代后期出现的无线局域网早期产品都是作为传统有线局域网替代品而问世的。无线局域网可以节省局域网缆线的安装费用，简化重新布局和其他对网络结构改动的任务。但是，无线局域网的这个动机被以下一系列的事件打消。首先，随着人们越来越清楚地认识到局域网的重要性，建筑师在设计新建筑时就包括了大量用于数据应用的预先埋设好的线路。其次，随着数据传输技术的发展，人们越来越依赖于双绞线连接的局域网。特别是3类和5类非屏蔽双绞线。大多数老建筑中已经铺设了足够的3类电缆，而许多新建筑里则预埋了5类电缆。因此，用无线局域网取代有线局域网的事情从来没有发生过。
但是，在有些环境中无线局域网确实起着有线局域网替代品的作用。例如，象生产车间、股票交易所的交易大厅以及仓库这样有大型开阔场地的建筑；没有足够双绞线对，但又禁止打洞铺设新线路的有历史价值的建筑；从经济角度考虑，安装和维护有线局域网划不来的小型办公室。在以上这些情况下，无线局域网向人们提供了一个有效且更具吸引力的选择。其中大多数情况下，拥有无线局域网的机构同时也拥有支持服务器和某些固定工作站的有线局域网。因此，无线局域网通常会链接到同样建筑群内的有线局域网上。所以我们将此类应用领域成为局域网的扩展。
建筑物的互连
无线局域网技术的另一种用途是邻楼局域网之间的连接，这些局域网可以是无线的也可以是有线的。在这种情况下，两个楼之间采用点对点的无线链接。被链接的设备通常是网桥或路由器。这种点对点的单链路从本质上看不是局域网，但通常我们也把这种应用算作无线局域网。
漫游接入
漫游接入提供局域网和带有天线的移动数据终端之间的无线链接，如膝上型电脑和笔记本电脑。这种应用的一个例子是从外地出差回来的职员将数据从个人移动电脑传送到办公室的服务器上。漫游接入在某种延伸的环境下也是十分有用的，如在建筑群之外操作的一台电脑或一次商务行为。在以上两种情况下，用户会带着自己的电脑随意走动，并希望可以从不同的位置访问有线局域网上的服务器。
自组网络
自组网络（ad hoc network）是为了满足某些即时需求而临时而建立的一种对等网络（没有中央服务器）例如，有一群职员，每人带着一台膝上电脑或掌上电脑，会聚在商务会议室或课堂上。这些职员会将他们的电脑链接起来，形成一个临时性的、仅仅在会议期间存在的网络。
无线局域网的要求
无线局域网必须满足所有局域网的典型要求，包括大容量、近距离的覆盖能力、相连站点间的完全连接性以及广播能力。另外，无线局域网环境还有一些特殊的要求。以下是一些无线局域网最终要的要求：
吞吐量：媒体接入控制协议应当尽可能地有效利用无线媒体以达到最大的容量。
节点数量：无线局域网可能需要支持分布在多个蜂窝中的上百个节点。
连接到主干局域网：在大多数情况下，要求能够与主干有线局域网的站点相互连接。对于有基础设施的无线局域网，很容易通过利用控制模块完成这个任务，控制模块本身就连接着这两种类型的局域网。对于移动用户和自组无线网络来说，可能需要满足这个要求。
电池能量消耗：移动工作人员用的是由电池供电的工作站，它需要在使用无线适配器的情况下，电池供电时间足够长。这就是说，要求移动节点不停地监视接入点或者经常要与基站握手的MAC协议是不适用的。通常，无线局域网的实现都具有在不使用网络时减少能量消耗的特殊性能，如睡眠模式。
传输健壮性和安全性：除非涉及合理，无线局域网很容易受到干扰并且容易被窃听。无线局域网的设计必须做到即使在噪音较大的环境中也能可靠传输，并且为应用提供某种程度的安全性，以防窃听。
并列的网络操作：随着无线局域网变得越来越流行，很可能有两个或者更多无线局域网同时存在于一个区域内，或在局域网之间可能存在干扰的某些区域内运行。这种干扰可能会阻碍MAC算法的正常运行，还可能造成对特定局域网的非法接入。
不需要许可证的操作：用户希望购买和运行的是这样的无线局域网产品，它们不需要专门为局域网所使用的频带而申请许可证。
切换和漫游：无线局域网中使用的MAC协议应当让移动站点能够从一个蜂窝移动到另一个蜂窝。
动态配置：局域网在MAC地址机制和网络管理方面应当允许端系统能够动态且自动地增加、删除和移动位置，并且不打扰到其他用户。
无线局域网技术
无线局域网通常根据它所采用的传输技术进行分类。目前所有无线局域网产品都可归为以下三个大类之一：
红外线（IR）局域网：红外线局域网的一个蜂窝只能限制在一个房间里，因为红外线无法穿过不透明的墙。
扩频局域网：这种类型的局域网利用了扩频传输技术。在大多数情况下，这些局域网运行在ISM(个人、科学和医学)波段内，因此，在美国使用这些局域网不需要联邦通信委员会（FCC）发放的许可证。
窄带微波：这些局域网运行在微波频率是，但没有使用扩频技术。其中有些产品运行的频率需要FCC的许可证，而其他一些产品则使用了不需要许可的波段。
无线局域网有一个特性是人们乐意接受的，虽然不是必要的，那就是不需要通过麻烦的授权过程就能使用。每个国家的许可证发放制度都不一样，这就使事情变得更加复杂。在美国，FCC在ISM波段内特许了两个不需要许可证的应用：最大功率为1瓦的扩频系统合最大运行功率为0.5瓦的低功率系统。自从FCC开放了这个波段以来，在扩频无线局域网中的应用就越来越普遍。
1990年IEEE802.11工作组成立，它的宪章就是要为无线局域网开发MAC协议以及物理媒体规约。
无线局域网中最小的模块是基本服务集（Basic Service Set, BSS）,它由一些执行相同MAC协议并争用同一共享媒体完成接入的站点组成。基本服务集可以是孤立的，也可以通过接入点（Access Point, AP）连到主干分发系统（Distribution System, DS）上。接入点的功能相当于网桥。MAC协议可以是完全分布式的，也可以由位于接入点的中央协调功能控制。BBS通常与文献中的蜂窝相对应，而DS则有可能是交换机或有线网络，也可以是无线网络。
MAC层的主要任务是在MAC实体之间传送MSDU，这个任务是由分发服务实现的。分发服务的正常运行需要该ESS内所有站点的信息，而这个信息是由与关联（association）相关的服务提供的。在分发服务向站点交付数据或者接收来自站点的数据之前，该站点必须要建立关联。标准基于移动性定义了三种转移类型：
无转移：这种类型的站点或者是固定的，或者只在一个BSS的直接通信范围内移动。
BSS转移：这种类型的站点移动是在同一ESS内从一个BSS移动到另一个BSS。在这种情况下，该站点的数据交付需要寻址功能，能识别出该站点的新位置。
ESS转移：它的定义是指站点从一个ESS的BSS到另一个ESS的BSS移动。只有从某种意义上看该站点是能够移动的，才能支持这种类型的转移。
802.11工作组考虑了两类MAC算法建议：分布式接入协议和集中式接入协议。分布式接入协议类似于以太网，采用载波监听机制把传输的决定权分布到所有节点。集中式接入协议由一个集中的决策模块来控制发送。分布式接入协议对于对等工作站形式的自组网络是有意义的，同时也可能对主要是突发性通信量的其他一些无线局域网颇具吸引力。如果一个局域网的配置是由许多互连的无线站点和以某种形式连接到主干有线局域网的基站组成，则采用集中式接入控制是自然而然的事情。当某些数据是时间敏感的或者是高优先级的时，这种方法特别有用。
IEEE802.11的最终结果是一个称为分布式基础无线MAC（Distributed Foundation Wireless MAC,DFWMAC）的算法，它提供了一个分布式接入控制机制，并在顶端具有可选的集中式控制。MAC层的低端子层是分布式协调功能（Distributed Coordination Function , DCF）.DCF采用争用算法向所有通信量提供接入。正常的异步通信量直接使用DCF。点协调功能（Point Coordination Function, PCF）是一个集中式MAC算法，用于提供无争用服务。
分布式协调功能
DCF子层使用一种简单的CSMA（载波监听多点接入）算法。如果站点有一个MAC帧要发送，则先监听媒体。如果媒体空闲，站点可以发送。否则，该站点必须等待直到当前的发送结束。DCF不包括冲突检测功能（CSMA/CD），因为在无线网络中进行冲突检测是不实际的。媒体上信号变动范围很大，所以如果正在传输的站点接收到微弱信号，它无法区分这是噪声还是因为自己的传输而带来的影响。
为了保证算法的平稳和公平运行，DCF包含了一组等价于优先级策略的时延。我们首先考虑一个称为帧间间隔（InterFrame Space,IFS）时延。采用IFS后CSMA的接入规则如下：
1。有帧要传输的站点先监听媒体。如果媒体是空闲的，等待IFS长的一段时间，再看媒体是否空闲，如果是空闲，立即发送。
2。如果媒体是忙的（或是一开始就发现忙，或是在IFS空闲时间内发现媒体忙），则推迟传输，并继续监听媒体直到当前的传输结束。
3。一旦当前的传输结束，站点再延迟IFS一段时间。如果媒体在这段时间内都是空闲的，则站点采用二进制指数退避策略等待一段时间后再监听媒体，如果媒体依然是空闲的，则可以传输。在退避期间，如果媒体又变忙了，退避定时器暂停，并在媒体变空闲后恢复计时。
点协调功能
PCF是在DCF之上实现的另一种接入方式。其操作由中央轮询主控器（点协调器）的轮询构成。点协调在发布轮询时采用PIFS。因为PIFS比DIFS小，所以点协调器在发布轮询和接收响应时能获取媒体并封锁所有的异步通信量。
点协调器不断地发布轮询，并永远封锁所有异步通信量。为了避免这种情况，定义了一个称为超帧（superframe）的时间间隔。在超帧时间的开始部分，点协调器以循环方式向所有配置成轮询的站点发布轮询。然后，在余下的超帧时间里，点协调器空闲，允许异步通信量有一段争用接入的时间。
在超帧开始时，点协调器可以在给定时间内获得控制权和发布轮询，这由选项决定。由于响应站点发出的帧的长度是变化的，所以这个时间间隔也是变化的。超帧剩余的时间用于基于争用的接入。在超帧末尾，点协调器泳PIFS时间争用媒体接入权。如果媒体是空闲的，点协调器可以立刻接入，然后又是一个全超帧期。不过，媒体在超帧末尾有可能是忙的。在这种情况下，点协调器必须等待直到媒体空闲并获得接入。其结果是下一个循环中相应缩短的超帧期。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c6134f2c3b240670356cb55cb185fa6/" rel="bookmark">
			2023CSPJ 旅游巴士 —— dijkstra
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		This way
题意： 给你一个有向图，1号点为起点，n为终点。你可以在k的倍数的时间点在起点开始，每条边的边长为1，同时，每条边有一个限定时间ai，表示你必须在大于等于ai的时间点才能走这条边。
你需要在k的倍数的时间点到终点，问你在终点的最早时间，如果不存在输出-1.
题解： 应当是一条最短路，在思考每条边的限定时间的时候会发现，假设这条边从a到b，边权为c。那么如果在d(d&lt;c)的时刻到达a时，通不过，所以我们要么延迟k的倍数次从起点开始，使得到达a的时候是d+nk时刻,并且满足d+nk&gt;=a且最小，要么就是绕个路再回到a点。
于是我们发现这两种情况，第一种可以快速处理，不需要重新走一遍，直接假设已经是晚了nk的时间到达即可。
第二种情况，假设再次到达a的时刻为e，满足e&gt;=a，那么对于这种情况又细分为两种：
1.k|(e-d)也就是d+nk=e。这个就如同上一种情况一般假设晚到即可。
2.e!=d+nk，那么我思考至此发现，其实到达a的时候，总共只有k种情况，也就是：到达a位置的步长%k的不同情况。对于每一种情况，存下来最短路长即可。
所以设置dis[i][j]表示到达i位置，走过的路长%k=j时，最短路程。知道了这个以后直接d。
#include&lt;bits/stdc++.h&gt; using namespace std; #define pii pair&lt;int,int&gt; const int N=1e4+5,mx=1e9; vector&lt;pii&gt;vec[N]; int dis[N][105],k,n,m; struct node{ int u,v,res;//pos,step,res bool operator&lt; (const node&amp; a)const { return v&gt;a.v; } }; priority_queue&lt;node&gt;Q; int dij(){ Q.push({1,0,0}); dis[1][0]=0; while(!Q.empty()){ node u=Q.top();Q.pop(); if(u.v&gt;dis[u.u][u.res])continue; for(pii ne:vec[u.u]){ int nv; if(ne.second&gt;u.v)nv=u.v+1+(ne.second-u.v+k-1)/k*k; else nv=u.v+1; int nr=nv%k; if(dis[ne.first][nr]&gt;nv) dis[ne.first][nr]=nv,Q.push({ne.first,nv,nr}); } } return dis[n][0]; } int main() { int x,y,z; scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c6134f2c3b240670356cb55cb185fa6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6bef93d54ac7ac6e6bb9c5d1d34ef29/" rel="bookmark">
			《红蓝攻防对抗实战》四.内网探测协议出网之ICMP协议探测出网
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一.Windows系统探测ICMP协议出网
1. Ping命令
2.Tracert 命令
二.Linux系统探测ICMP协议出网
1. Ping命令
ICMP（Internet Control Message Protocol）是一种面向无连接的协议，属于网络层的协议，用于检测网络通信故障和实现链路追踪。当我们需要判断探测ICMP协议是否出网时，可通过Ping和Tracert命令进行探测，下面以这两个命令为案例进行演示。
一.Windows系统探测ICMP协议出网 1. Ping命令 Ping命令想必是大家最熟悉的命令了，Ping命令经常用于测试网络连通性，由于该命令是基于ICMP协议来实现的，因此Ping是ICMP出网测试中最常用的命令，执行ping baidu.com，可以看到如图1-1所示的返回信息，即证明ICMP协议出网探测成功。
图1-1Ping 命令探测出网成功
2.Tracert 命令 Tracert命令是Windows中用来跟踪路由的命令，它依靠ICMP协议实现，在ICMP出网测试中只需要使用Tracert命令跟踪下目标地址即可，以百度为案例，执行tracert baidu.com命令，获得如图1-2所示的返回信息，即证明出网成功。
图1-2Tracert命令探测出网成功
二.Linux系统探测ICMP协议出网 1. Ping命令 在Linux系统中探测ICMP协议出网通常可以使用ping命令，同上述Windows系统操作实验类似，但linux系统需要使用-c来指定次数，Windows系统下ping 命令执行第4次后会自动停止，linux系统则不会自动停止。执行ping -c 4 baidu.com命令，通过图1-3所示的结果证明探测出网成功。
图1-3 Ping命令探测出网成功
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f432456870ed5892dea76bb50d1a250d/" rel="bookmark">
			2023CSPS 种树 —— 二分&#43;前缀和
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		This way
题意： 一开始以为是水题，敲了一个二分+贪心检查的代码，20分。发现从根往某个节点x走的时候，一路走来的子树上的节点到已栽树的节点的距离会变短，那么并不能按照初始情况贪心。
于是就想着检查时候用线段树，存的是(每个节点最晚开始时间-它距离最近栽树的点的距离)往后就将这个称为ddl。每一步都往当前最小值的位置走，每走一步，将当前这一步的子树区间+1，如此往复。当走到一个点发现已经走的步数&gt;这个点最晚开始时间时候就是not。但是代码过于繁杂，最终放弃了这样思路，而且常数可能会比较大，最终如果TLE了血亏。
首先这道题的答案满足二分的性质，考虑使用二分。二分出来结束时间的时候，我们可以求出每个点的最晚到达时间，首先分c&gt;=0和c&lt;0两种情况。对于c&lt;0的时候又要分三种情况。其实就是等差数列求和公式，但是注意会爆longlong，所以转乘为除。我这里使用二分去找答案，当然直接算好像也行？
发现其实每个点的ddl就是它子树的ddl最小值，也就是每个点的ddl可视为子树中最小ddl-当前点到ddl最小的节点的距离，例如：
假设点1的最晚开始时间是第10天，点2是第3天，点3是第50天，点4是第90天，点5是第4天。那么转换过来，其实它们真实的ddl如下：
这个时候我们只需要将所有真·ddl存到桶里面，再做一个前缀和，记为num[i]。若i&lt;num[i]，则表示你走了i步，但是有超过i个点的ddl在i步之内（我们在上图处理完之后，所有链上的ddl必然是递增的也就是如果点x需要走10步，那father[x]最大为9,father[father[x]]最大为8，也就是为x做铺垫），那么表示无法在i步内满足num[i]个点的ddl。
#include&lt;bits/stdc++.h&gt; using namespace std; #define ll long long const int N=1e5+5; ll a[N],b[N],c[N],en[N],e,shou,mo; int n,x,y,dep[N],u,tim,num[N],t[N]; vector&lt;int&gt;vec[N]; bool vis[N]; #define pii pair&lt;int,int&gt; vector&lt;pii&gt;day; int dfs(int x,int fa){ for(int ne:vec[x]){ if(ne==fa)continue; t[x]=min(t[x],dfs(ne,x)-1); } num[t[x]]++; return t[x]; } bool check(ll d){ day.clear(); memset(num,0,sizeof num); for(int i=1;i&lt;=n;i++){ ll l=1,r=min(1ll*n,d);t[i]=-1; while(l&lt;=r){ ll x=l+r&gt;&gt;1; if(c[i]&gt;=0){ if((a[i]*2ll+d-x)/(d-x+1)&lt;=2*b[i]+(x+d)*c[i])t[i]=x,l=x+1; else r=x-1; } else{ c[i]=-c[i]; if(en[i]&lt;=x){ if(a[i]&lt;=d-x+1)t[i]=x,l=x+1; else r=x-1; } else if(en[i]&lt;=d){ e=en[i]-1; shou=b[i]-x*c[i],mo=b[i]-e*c[i]; if((2*a[i]-2*(d-e)+e-x)/(e-x+1)&lt;=(shou+mo))t[i]=x,l=x+1; else r=x-1; } else{ ll shou=b[i]-x*c[i],mo=b[i]-d*c[i]; if((2*a[i]+d-x)/(d-x+1)&lt;=(shou+mo))t[i]=x,l=x+1; else r=x-1; } c[i]=-c[i]; } } if(t[i]-dep[i]&lt;=0)return 0; } dfs(1,0); for(int i=1;i&lt;=n;i++){ num[i]+=num[i-1]; if(num[i]&gt;i) return 0; } return 1; } int main() { ll l=n,r=0,ans=-1; scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f432456870ed5892dea76bb50d1a250d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a7013a92efd053d9e83254f7479621d/" rel="bookmark">
			2015款MacBook Pro从Big Sur升级到Monterey
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		机器信息 存储是1TB的固态硬盘。
升级后的使用体验 开机速度 比之前Big Sur系统开机时间快了至少三分之一（进入系统的进度条停顿时间很短，未升级之前，进度条加载缓慢，动不动就停顿半天）
应用app使用情况 从Big Sur升级到Monterey，大部分应用正常使用，因为本人乃程序员，安装的应用也不少基本都正常使用，没啥大的毛病。
程序坞的情况 现在应用缩小到程序坞的动画，或者从程序坞点击程序最大化的动画，动画给人的感觉平滑了不少，肉眼可见的流畅多了。
系统自带输入法 未升级之前，系统自带的输入法卡顿经常出现。升级后，自带输入法打字感觉很流畅，用了一大天也没有出现打字卡顿的问题。
其他 升级后无线网使用正常。只不过之前自定义的壁纸需要重新制定下文件夹。其他的啥问题暂时还没发现。起码在一整天的体验中，比起Big Sur流畅了不少。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1946cdb463fecc5800d12145d14e56fa/" rel="bookmark">
			【Ubuntu18.04】Livox Tele-15使用教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Livox Tele-15使用教程 引言1 下载并安装Livox Viewer1.1 打开Livox Viewer程序1.2 设备ip链接 2 览沃Livox SDK二次开发并封装ROS2.1 览沃Livox SDK安装2.2 览沃驱动 livox_ros_driver 安装2.3 Launch 配置文件描述 3 保存lvx格式的数据文件3.1 使用览沃Viewer保存lvx文件3.2 使用Livox-SDK保存lvx文件3.3 将lvx文件（v1.0/v1.1）转换为rosbag文件（仅支持Ubuntu系统） 4 外参标定与点云显示4.1 使用 Livox Viewer 标定外参4.2 在Livox Ros Driver 中修改 config 配置表 引言 激光雷达型号：Livox Tele-15
用于配置的系统：Ubuntu 18.04
1 下载并安装Livox Viewer 前往Livox官网，建议下载如图的Livox Viewer版本 用户手册链接
1.1 打开Livox Viewer程序 解压文件后，进入文件夹并运行启动指令如下： ./livox_viewer.sh 打开界面如下： 1.2 设备ip链接 电脑设置静态IP
注意：在设电脑与Livox设备连接前，需要电脑的IP设置中设置一个静态IP
（1）找到物理网卡的名称，我这里是enp0s31f6
# 先ifconfig查看电脑的网卡信息，如下图 ifconfig （2）实际需要依次设置enp0s31f6网卡的静态IP地址、网关、DNS，dhcp4设置为false，最后一行添加：renderer: networkd。
# 输入route -n命令，打印路由表，这里主要是为了查看网关地址，后续会用到 route -n # 输入 sudo vim /etc/netplan/00-installer-config.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1946cdb463fecc5800d12145d14e56fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ac10fbeb4084dad7e71b6951ac455fd/" rel="bookmark">
			python(10):批量修改文件名、获取脚本所在目录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 使用Python的字符串操作来去除文件名高位的多余零说明代码示例 2. 将文件夹中的文件重命名为递增的数字加上原始文件名的后缀代码运行前后： 3. 使用Python获取脚本所在目录以及相关目录 1. 使用Python的字符串操作来去除文件名高位的多余零 说明 一个目录下的文件名是6位数字序号加上后缀的格式，例如 000001.txt，000002.jpg，000003.csv，你可以使用Python的字符串操作来去除高位的多余零。
代码 下面是一个示例代码：
import os directory = '/path/to/directory' # 替换为你的目录路径 # 获取目录下所有文件名 filenames = os.listdir(directory) # 遍历文件名并去除高位多余的零 for filename in filenames: basename, extension = os.path.splitext(filename) new_filename = basename.lstrip('0') + extension old_path = os.path.join(directory, filename) new_path = os.path.join(directory, new_filename) os.rename(old_path, new_path) 在上述代码中，我们首先使用 os.listdir 函数获取目录下的所有文件名。然后，对每个文件名进行处理。通过 os.path.splitext 函数，我们将文件名拆分为基本名称和扩展名。接下来，使用 lstrip 函数去除基本名称前面的多余零，并将其与扩展名重新组合成新的文件名。最后，使用 os.rename 函数将原始文件名修改为新的文件名。
注意：在使用代码之前，请确保备份目录中的文件，以免意外修改导致数据丢失。
示例 操作前
操作后
2. 将文件夹中的文件重命名为递增的数字加上原始文件名的后缀 使用Python中的os模块来遍历文件夹中的文件，并使用os.rename函数来进行文件重命名。下面是一个示例代码，展示了如何将文件夹中的文件重命名为递增的数字加上原始文件名的后缀：
代码 import os folder_path = 'path/to/folder' # 文件夹路径 file_list = os.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ac10fbeb4084dad7e71b6951ac455fd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/778112dd65751b075e51c93de05efbf7/" rel="bookmark">
			CentOS 编译安装TinyXml2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装 TinyXml2 Git 源码下载地址:https://github.com/leethomason/tinyxml2
步骤1：首先，你需要下载tinyxml2的源代码。你可以从Github或者源代码官方网站下载。并上传至/usr/local/source_code/
步骤2：下载完成后，需要将源代码解压，可以使用以下命令：
tar -zxvf tinyxml2-8.1.0.tar.gz 步骤3：解压后，切换到源代码目录：
cd tinyxml2-8.1.0 步骤4：执行make &amp;&amp; make install 命令进行安装：
make &amp;&amp; make install 温馨提示：完成以上步骤后，在/usr/local/lib下会生成libtinyxml2.so动态库和/usr/local/include下生成tinyxml2.h头文件。你可以使用以下命令查看是否安装成功：
ls /usr/local/lib | grep tinyxml2 ls /usr/local/include | grep tinyxml2 如果看到libtinyxml2.so和tinyxml2.h，则说明成功安装了tinyxml库。
TinyXml2 库 简介 TinyXML2 是简单实用的开源的 C++XML 文件解析库，可以很方便的应用到现有的项 目之中。 TinyXML2 解析器相对 TinyXML1 在代码上是完全重写，使其更适合于游戏开发 中使用。它使用更少的内存，更快，并使用更少的内存分配。
由于 XML 的树状结构，TinyXML2 将 XML 的节点抽象为 XMLNode，XML 中除了把属 性 key-value 抽象为 XMLAttribute 类型外，其余的都看作 XMLNode 的子类，首先将整个 XML 文档抽象为 XMLDocument，将声明部分抽象为 XMLDeclaration，将注释抽象为 XMLComment，将元素抽象为 XMLElement，将文本抽象为 XMLText。
核心：节点、元素、属性和值 XMLAttribute 是解析 XML 的属性的类，XML 中的属性都与 XML 的 Element 绑定，并且为 key-value 类型。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/778112dd65751b075e51c93de05efbf7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c04305c3696ce92ebac9fdb0eaf4d0e/" rel="bookmark">
			linux下新建用户后登录显示$及添加用户后开通ssh和sudo
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、新建用户后登录显示$，类似于下图
修改/etc/passwd，对应的用户名后面，把默认shell 由/bin/sh改为/bin/bash
2、新增用户后开通ssh
一般执行以下命令就可以了
sudo usermod -a -G ssh username
密码登陆或者证书登陆此处不详述
3、新增用户后开通sudo（admin权限）
sudo usermod -a -G sudo username （有的系统sudo组名字可能为sudoers，可以看一下/etc/group)
编辑/etc/visuoders不要用vim，可以用visudo
下图配置中%sudo ALL=(ALL:ALL) ALL一句是指sudo组的用户可以运行所有命令，一般不需要特别指定某个用户，只要把用户加到sudo组里就可以了。（sudo usermod -a -G sudo username）
Defaults env_reset Defaults mail_badpass Defaults secure_path="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin" root ALL=(ALL:ALL) ALL # Allow members of group sudo to execute any command %sudo ALL=(ALL:ALL) ALL #includedir /etc/sudoers.d 验证sudo：sudo -l -U username
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d79bb9c6f8039d5af4a44dfdedf85640/" rel="bookmark">
			Premiere Pro 2024(pr2024)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Premiere Pro 2024是一款专业的视频编辑软件，它属于Adobe Creative Cloud的一部分，提供了全面的视频剪辑、音频编辑、动态效果、色彩校正和字幕制作等功能。
在Premiere Pro 2024中，用户可以轻松地将多个视频片段、音频文件和图片组合在一起，并使用各种过渡效果、动画效果和滤镜来增强视频的视觉吸引力。此外，Premiere Pro 2024还支持多种格式，包括常用的AVCHD、HDV和HDR等，可以满足不同用户的需求。
除了基本的剪辑功能外，Premiere Pro 2024还提供了丰富的音频编辑工具，包括音频混合、降噪、EQ调整和音频效果等。它可以帮助用户制作出清晰、动听的音频，使视频的音效更加出色。此外，Premiere Pro 2024还提供了强大的色彩校正工具，可以帮助用户对视频的色彩进行精细调整，以达到最佳的视觉效果。
Premiere Pro 2024还具有智能辅助功能，例如自动剪辑和智能修复功能，可以大大减少用户的编辑时间，而自适应音频和色彩工具则使音频和视觉效果达到最佳状态。无论用户是专业剪辑师、内容创作者还是初学者，Premiere Pro 2024都将成为用户的得力助手。
总的来说，Adobe Premiere Pro 2024是一款功能强大、直观易用的视频编辑软件，适用于各种类型的用户，无论是专业剪辑师还是初学者，都可以在Premiere Pro 2024中找到适合自己的工具和功能。
Premiere Pro 2024(pr2024)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/507df645fca52c04c8e8557be5fd2f80/" rel="bookmark">
			网络安全（黑客）自学
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、网络安全学习的误区 1.不要试图以编程为基础去学习网络安全 不要以编程为基础再开始学习网络安全，一般来说，学习编程不但学习周期长，且过渡到网络安全用到编程的用到的编程的关键点不多。一般人如果想要把编程学好再开始学习网络安全往往需要花费很长时间，容易半途而废。
建议在学习网络安全的过程中，哪里不会补哪里，这样更有目的性且耗时更少。学习编程能决定你能在网络安全这条路上到底能走多远，所以推荐大家自学一些基础编程的知识
2.不要刚开始就深度学习网络安全 学习讲究这方法，需要一步一步的来，由浅至深，慢慢的加大难度，很多人刚开始就猛学，很容易到后面的时候乏力，越学可能就越学得枯燥，到最后就很容易放弃了。
3.收集适当的学习资料 网上有很多网络安全的学习资料。而很多朋友都有“收集癖”，一下子很多书籍，收藏几十个视频，觉得学习资料越多越好，然而网上的学习资料重复性极高。建议选择大众受用的学习资料。
4.适当的报班学习 很多人觉得报班就是浪费钱财，觉得自己自学就很好了，但其实自学也是需要一定的天赋和理解能力，且自学的周期较长，一些急躁的学习者或者急于找到工作的学习者，还是报班学的比较轻松，学习周期不长，学到的东西也不会少，建议学习者根据自己的自身条件选择是否报班。
二、学习网络安全的些许准备 1.硬件选择 学习网络安全不需要配置很高的电脑，黑客用的电脑,从来不是根据高配置选择电脑,只要稳定就行。因为黑客所使用的一些程序,低端 CPU 也可以很好的运行,而且不占什么内存。黑客是在 DOS 命令下对进行的,电脑能使用到最佳状态就可以了
2.软件选择 很多人会纠结学习黑客到底是用 Linux 还是 Windows 或者是 Mac 系统，Linux 系统对于新人入门并不友好。Windows 系统一样可以用虚拟机装靶机进行学习，当然是根据学习者自己的感觉来选择系统。
至于编程语言，Python、PHP、 C++、Java 都是可以的，学习编程只是工具不是目的，我们的目标不是成为程序员，而是成为网络安全员，编程只是为了看懂程序。
3.外语能力 计算机最早诞生于宾西法利亚大学，很多名词或者代码都是英文，一个漏洞翻译成中文需要一个星期的时间，在这个时间上漏洞可能都修补了。如果不理解一些专业名词，在与其他黑客交流时也会有障碍，所以需要一定量的英文量和了解一些专业名词。
三、网络安全学习路线 如图片过大被平台压缩导致看不清的话，大家记得点👉关注自取！ 1、基础阶段 中华人民共和国网络安全法 （包含18个知识点）Linux操作系统 （包含16个知识点）计算机网络 （包含12个知识点）SHELL （包含14个知识点）HTML/CSS （包含44个知识点）JavaScript （包含41个知识点）PHP入门 （包含12个知识点）MySQL数据库 （包含30个知识点）Python （包含18个知识点） 入门的第一步是系统化的学习计算机基础知识，也就是学习以下这几个基础知识模块:操作系统、协议/网络、数据库、开发语言、常用漏洞原理。
前面的基础知识学完之后，就要进行实操了。
因为互联网与信息化的普及网站系统对外的业务比较多,而且程序员的水平参差不齐和运维人员的配置事物，所以需要掌握的内容比较多。
2、渗透阶段 SQL注入的渗透与防御（包含36个知识点）XSS相关渗透与防御（包含12个知识点）上传验证渗透与防御（包含16个知识点）文件包含渗透与防御（包含12个知识点）CSRF渗透与防御（包含7个知识点）SSRF渗透与防御（包含6个知识点）XXE渗透与防御（包含5个知识点）远程代码执行渗透与防御（包含7个知识点） 掌握常见漏洞的原理、使用、防御等知识。Web渗透阶段还是需要掌握一些必要的工具。
主要要掌握的工具和平台：burp、AWVS、Appscan、Nessus、sqlmap、nmap、shodan、fofa、代理工具ssrs、hydra、medusa、airspoof等，以上工具的练习完全可以利用上面的开源靶场去练习，足够了；
3、安全管理（提升） 渗透报告编写（包含21个知识点）等级保护2.0（包含50个知识点）应急响应（包含5个知识点）代码审计（包含8个知识点）风险评估（包含11个知识点）安全巡检（包含12个知识点）数据安全（包含25个知识点） 主要包括渗透报告编写、网络安全等级保护的定级、应急响应、代码审计、风险评估、安全巡检、数据安全、法律法规汇编等。
这一阶段主要针对已经从事网络安全相关工作需要提升进阶成管理层的岗位。 如果你只学习参加工程师方面的岗位，这一阶段可学可不学。 4、提升阶段（提升） 密码学（包含34个知识点）JavaSE入门（包含92个知识点）C语言（包含140个知识点）C++语言（包含181个知识点）Windows逆向（包含46个知识点）CTF夺旗赛（包含36个知识点）Android逆向（包含40个知识点） 主要包括密码学、JavaSE、C语言、C++、Windows逆向、CTF夺旗赛、Android逆向等。
主要针对已经从事网络安全相关工作需要提升进阶安全架构需要提升的知识。
如果你真的想通过自学的方式入门web安全的话，那建议你看看下面这个学习路线图，具体到每个知识点学多久，怎么学，自学时间共计半年左右，亲测有效（文末有惊喜）：
1、Web安全相关概念（2周） 熟悉基本概念（SQL注入、上传、XSS、CSRF、一句话木马等）。通过关键字（SQL注入、上传、XSS、CSRF、一句话木马等）进行Google/SecWiki；阅读《精通脚本黑客》，虽然很旧也有错误，但是入门还是可以的；看一些渗透笔记/视频，了解渗透实战的整个过程，可以Google（渗透笔记、渗透过程、入侵过程等）； 2、熟悉渗透相关工具（3周） 熟悉AWVS、sqlmap、Burp、nessus、chopper、nmap、Appscan等相关工具的使用。了解该类工具的用途和使用场景，先用软件名字Google/SecWiki；下载无后门版的这些软件进行安装；学习并进行使用，具体教材可以在SecWiki上搜索，例如：Brup的教程、sqlmap；待常用的这几个软件都学会了可以安装音速启动做一个渗透工具箱； 3、渗透实战操作（5周） 掌握渗透的整个阶段并能够独立渗透小型站点。网上找渗透视频看并思考其中的思路和原理，关键字（渗透、SQL注入视频、文件上传入侵、数据库备份、dedecms漏洞利用等等）；自己找站点/搭建测试环境进行测试，记住请隐藏好你自己；思考渗透主要分为几个阶段，每个阶段需要做那些工作，例如这个：PTES渗透测试执行标准；研究SQL注入的种类、注入原理、手动注入技巧；研究文件上传的原理，如何进行截断、双重后缀欺骗(IIS、PHP)、解析漏洞利用（IIS、Nignix、Apache）等，参照：上传攻击框架；研究XSS形成的原理和种类，具体学习方法可以Google/SecWiki，可以参考：XSS；研究Windows/Linux提权的方法和具体使用，可以参考：提权；可以参考: 开源渗透测试脆弱系统； 4、关注安全圈动态（1周） 关注安全圈的最新漏洞、安全事件与技术文章。通过SecWiki浏览每日的安全技术文章/事件；通过Weibo/twitter关注安全圈的从业人员（遇到大牛的关注或者好友果断关注），天天抽时间刷一下；通过feedly/鲜果订阅国内外安全技术博客（不要仅限于国内，平时多注意积累），没有订阅源的可以看一下SecWiki的聚合栏目；养成习惯，每天主动提交安全技术文章链接到SecWiki进行积淀；多关注下最新漏洞列表，推荐几个：exploit-db、CVE中文库、Wooyun等，遇到公开的漏洞都去实践下。关注国内国际上的安全会议的议题或者录像，推荐SecWiki-Conference。 5、熟悉Windows/Kali Linux（3周） 学习Windows/Kali Linux基本命令、常用工具；熟悉Windows下的常用的cmd命令，例如：ipconfig,nslookup,tracert,net,tasklist,taskkill等；熟悉Linux下的常用命令，例如：ifconfig,ls,cp,mv,vi,wget,service,sudo等；熟悉Kali Linux系统下的常用工具，可以参考SecWiki,《Web Penetration Testing with Kali Linux》、《Hacking with Kali》等；熟悉metasploit工具，可以参考SecWiki、《Metasploit渗透测试指南》。 6、服务器安全配置（3周） 学习服务器环境配置，并能通过思考发现配置存在的安全问题。Windows2003/2008环境下的IIS配置，特别注意配置安全和运行权限，可以参考：SecWiki-配置；Linux环境下的LAMP的安全配置，主要考虑运行权限、跨目录、文件夹权限等，可以参考：SecWiki-配置；远程系统加固，限制用户名和口令登陆，通过iptables限制端口；配置软件Waf加强系统安全，在服务器配置mod_security等系统，参见SecWiki-ModSecurity；通过Nessus软件对配置环境进行安全检测，发现未知安全威胁。 7、脚本编程学习（4周） 选择脚本语言Perl/Python/PHP/Go/Java中的一种，对常用库进行编程学习。搭建开发环境和选择IDE，PHP环境推荐Wamp和XAMPP，IDE强烈推荐Sublime，一些Sublime的技巧：SecWiki-Sublime；Python编程学习，学习内容包含：语法、正则、文件、网络、多线程等常用库，推荐《Python核心编程》，不要看完；用Python编写漏洞的exp，然后写一个简单的网络爬虫，可参见SecWiki-爬虫、视频；PHP基本语法学习并书写一个简单的博客系统，参见《PHP与MySQL程序设计（第4版）》、视频；熟悉MVC架构，并试着学习一个PHP框架或者Python框架（可选）；了解Bootstrap的布局或者CSS，可以参考：SecWiki-Bootstrap; 8、源码审计与漏洞分析（3周） 能独立分析脚本源码程序并发现安全问题。熟悉源码审计的动态和静态方法，并知道如何去分析程序，参见SecWiki-审计；从Wooyun上寻找开源程序的漏洞进行分析并试着自己分析；了解Web漏洞的形成原因，然后通过关键字进行查找分析，参见SecWiki-代码审计、高级PHP应用程序漏洞审核技术；研究Web漏洞形成原理和如何从源码层面避免该类漏洞，并整理成checklist。 9、安全体系设计与开发（5周） 能建立自己的安全体系，并能提出一些安全建议或者系统架构。开发一些实用的安全小工具并开源，体现个人实力；建立自己的安全体系，对公司安全有自己的一些认识和见解；提出或者加入大型安全系统的架构或者开发；看自己发展咯~ 在学习基础入门课程的同时，同时阅读相关的书籍补充理论知识，这里比较推荐以下几本书：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/507df645fca52c04c8e8557be5fd2f80/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f5307efaec5fb258933ebe7b2bbfd91/" rel="bookmark">
			jdk17运行程序报错module java.base does not open java.lang.reflect to unnamed module @
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 jdk17运行程序报错module java.base does not open java.lang.reflect to unnamed module @ 解决方案 增加配置
--add-opens java.base/java.lang=ALL-UNNAMED --add-opens java.base/sun.net.util=ALL-UNNAMED --add-opens java.base/java.lang.reflect=ALL-UNNAMED 启动jar包时
java --add-opens java.base/java.lang=ALL-UNNAMED --add-opens java.base/sun.net.util=ALL-UNNAMED --add-opens java.base/java.lang.reflect=ALL-UNNAMED -jar xxx.jar 注意参数要放在-jar前面，否则无效
IDEA调试时
增加配置
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30f2b60419f29f9164b35f47c07ab6bc/" rel="bookmark">
			面试中经常问道的问题二
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		深入理解前端跨域方法和原理
前言
受浏览器同源策略的限制，本域的js不能操作其他域的页面对象（比如DOM）。但在安全限制的同时也给注入iframe或是ajax应用上带来了不少麻烦。所以我们要通过一些方法使本域的js能够操作其他域的页面对象或者使其他域的js能操作本域的页面对象（iframe之间）。
这里需要明确的一点是：所谓的域跟js的存放服务器没有关系，比如baidu.com的页面加载了google.com的js，那么此js的所在域是baidu.com而不是google.com。也就是说，此时该js能操作baidu.com的页面对象，而不能操作google.com的页面对象。
跨域的方法总结
单向跨域（一般用于获取数据）
一、使用JSONP跨域
原理：因为通过script标签引入的js是不受同源策略的限制的（正如前文提到的baidu.com的页面加载了google.com的js）。所以我们可以通过script标签引入一个js或者是一个其他后缀形式（如PHP，jsp等）的文件，此文件返回一个js函数的调用，如返回JSONP_getUsers(["paco","john","lili"])，也就是说此文件返回的结果调用了JSONP_getUsers函数，并且把["paco","john","lili"]传进去，这个["paco","john","lili"]是一个用户列表。那么如果此时我们的页面中有一个JSONP_getUsers函数，那么JSONP_getUsers就被调用到，并且传入了用户列表。此时就实现了在本域获取其他域数据的功能，也就是跨域。
实现例子如下：
前端引入远程js并定义好JSONP_getUsers函数，注意需要先定义好JSONP_getUsers函数，避免在远程js加载完成并调用JSONP_getUsers时，此函数不存在：
[html] view plain copy print?
1.//本域为baidu.com 2.&lt;script&gt; 3. function JSONP_getUsers(users){ 4. console.dir(users); 5. } 6.&lt;/script&gt; 7.//加载google.com的getUsers.php 8.&lt;script src="http://www.google.com/getUsers.php"&gt;&lt;/script&gt; 需要google.com提供支持，getUsers.php代码如下：
[html] view plain copy print?
1.&lt;?php&gt; 2. echo 'JSONP_getUsers(["paco","john","lili"])';//返回一个js函数的调用 3.?&gt; 为什么script标签引入的文件不受同源策略的限制？因为script标签引入的文件内容是不能够被客户端的js获取到的，不会影响到被引用文件的安全，所以没必要使script标签引入的文件遵循浏览器的同源策略。而通过ajax加载的文件内容是能够被客户端js获取到的，所以ajax必须遵循同源策略，否则被引入文件的内容会泄漏或者存在其他风险。
JSONP的缺点则是：它只支持GET请求而不支持POST等其它类型的HTTP请求（虽然采用post+动态生成iframe是可以达到post跨域的目的，但这样做是一个比较极端的方式，不建议采用）。一般get请求能完成所有功能。比如如果需要给其他域服务器传送参数可以在请求后挂参数（注意不要挂隐私数据），即
[html] view plain copy print?
1.&lt;script src="http://www.google.com/getUsers.php?flag=do&amp;time=1"&gt;&lt;/script&gt;。 JSONP易于实现，但是也会存在一些安全隐患，如果第三方的脚本随意地执行，那么它就可以篡改页面内容，截获敏感数据。但是在受信任的双方传递数据，JSONP是非常合适的选择。可以看出来JSONP跨域一般用于获取其他域的数据。
一般能够用JSONP实现跨域就用JSONP实现，这也是前端用的最多的跨域方法。
二、动态创建script标签
这种方法其实是JSONP跨域的简化版，JSONP只是在此基础上加入了回调函数。
比如上例中的getUsers.php返回的如果不是一个js函数的调用，而是一个js变量，如：
[html] view plain copy print?
1.&lt;?php&gt; 2. echo 'var users=["paco","john","lili"]';//返回一个js变量users 3.?&gt; 那么在本域下就可以取到data变量，这里需要注意判断script节点是否加载完毕，如：
[html] view plain copy print?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/30f2b60419f29f9164b35f47c07ab6bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90d9c1341b2bab68c02cf0d630ef8982/" rel="bookmark">
			如何实现LIN多通道测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 在汽车的世界里，各个控制模块之间的通信就如同人体的神经系统一样，任何一个环节的失误都可能导致整个系统的崩溃。因此，通信的稳定性和可靠性验证就成为了我们必须要面对的重要问题。LIN（Local Interconnect Network）作为一种基于控制器局域网的通信协议，广泛应用于汽车控制系统中。LIN协议一致性测试可以确保所有相关的电子设备都能正常工作，从而防止由于软件错误或硬件故障导致的安全问题。在之前的文章中，我们给大家介绍了LIN总线高效测试方案，今天我们来谈一谈如何实现LIN多通道测试。
痛点 在LIN的实际测试场景中，我们常常会遇到包含多个LIN网段的主节点样件。在进行测试时，常规的操作是把这个LIN件视为多个LIN主节点样件进行测试。
假设现在要测试一个包含5个LIN网段的样件，那么我们在测试的时候就需要将同样的测试规范，同样的测试步骤重复5遍。如果每次对一个LIN主节点的测试需要2个小时，那么对这个包含5个LIN网段样件的完整测试就需要测试人员在工作时间内每隔2小时进行一次操作，一天的时间浪费掉了。
假设我们实现了多通道测试，那测试人员仅需在下班的时候点击测试开始按钮，第二天上班就可以看到测试结果啦。
难点 有需求就有了动力。我们先来整理一下多通道测试需要工程代替测试人员实现什么。
同时测试五个网段对测试机柜和工控机要求很高，我们可以模仿测试人员把样件分成五个主节点测试。5个主节点就有5条LIN线。因此我们的第一个需求就是实现工程代替测试人员自动切换LIN线。
LIN协议一致性测试可以大致分为物理层测试，通信层测试和网络管理测试3个部分。通信层测试和网络管理层测试对测试人员没有过多要求，这部分我们略过。物理层测试包含了LIN信号电平，占空比等波形的测试和LIN线容错的测试。因此我们的第二个需求就是需要实现工程代替测试人员在测试时切换示波器测试通道，第三个需求需要实现工程代替测试人员制造LIN线短路断路等故障。
硬件的部分解决了，我们再来看看软件需要实现什么。测试规范是不变的，测试网段的内容是可变的，我们按照测试规范准备一份测试工程代码循环网段测试即可。第四个需求就是实现代码自动区分不同网段的测试输入资料。第五个需求便是实现循环网段测试。
解决方案 让我们来逐一实现需求。首先简单介绍一下怿星自研板卡EH6466。
EH6466 是一款 CAN/LIN 测试板卡，分别支持 6 路独立的 CAN 和 LIN 通道测试，能够接入示波器，万用表，VH6501等设备，能够设置各种 CAN/LIN 总线故障，支持 CAN 管理控制。
1、实现工程代替测试人员自动切换LIN线。
这个部分可以通过EH6466实现。我们把样件的5条LIN线分别通过机柜预留接口接到EH6466的5个通道上，通过CAN 管理控制实现不同网段的LIN线接入测试环境。
2、实现工程代替测试人员切换示波器测试通道。
CANoe软件支持scope直接分析LIN报文。但需要提前设置好测量的LIN通道：
如果样件网段过多scope测量通道也会不够用。而我们在测试的时候既不能手动切换测量通道也不能通过内部函数实现切换。这么看来scope切换测量通道似乎不好实现。既然软件不支持那我们借助硬件解决。EH6466支持6条LIN通道测试，现在我们在Simulation Setup中预留出LIN6作为scope测量专用通道，同时将示波器的测量通道指定为LIN6。每次调用scope测试的时候都通过EH6466控制将测试LIN网段共享到LIN6上，这样的话就可以在LIN6上获取到测试LIN的报文啦。
3、实现工程代替测试人员制造各种LIN线故障。
EH6466板卡可以完美解决这个问题。EH6466内置了故障注入模块。在测试的时候只需通过CAN 管理控制就能制造出LIN线短路断路等故障。
4、实现代码自动区分不同网段的测试输入资料。
不同的测试网段就需要不同的测试输入资料。常规操作是准备一份测试资料输入配置表Project_LIN，测试不同网段的时候由测试人员更改配置。现在我们来做个小改动。
首先按照网段名将测试资料输入配置表分为5份：
然后在测试工程中按照网段名新建5个系统变量：
最后在测试代码中，我们只需要提前指定测试通道（将对应通道的系统变量置1）就可以实现通过系统变量指定读取相应网段的测试资料输入配置表。
5、实现循环网段测试。
这是多通道测试的核心部分。先正常实现一个网段的测试。
按照单网段测试的方式新建一个Test Moudles，加入提前准备好的.can和.VXT文件（.can文件为测试脚本，.vxt文件可以指定用例的测试执行顺序）：
在实现第四个需求的时候我们将测试输入资料分成了5份，通过系统变量实现了读取不同网段的测试资料输入配置表，那么同样可以使用这个方法来区分不同网段。将Test Moudles复制5次：
CANoe可以通过调用系统变量的方式实现模块之间衔接，我们可以借助这种方法实现循环测试。在配置Testnode Configuration的时候将System variable与不同网段的系统变量关联，并将其初始值设为0即可。
最后一步，在测试代码中确定测试顺序。我们可以通过将不同网段的系统变量置位实现。网段测试顺序由系统变量置位顺序决定，在测试开始之前将网段对应的系统变量置1，测试结束之后将网段对应的系统变量置0，下一个网段对应的系统变量置1：
这样做不仅可以实现各网段之间的衔接测试，还可以通过更改系统变量置位的方式实现固定网段的测试。到这里我们就实现了工程自动执行多通道测试啦。
方案核心 硬件
怿星自研EH6466板卡。本方案中5个需求有3个是靠EH6466板卡实现的。
1.通过EH6466板卡的6路独立CAN/LIN通道实现不同网段的切换测试。
2.通过EH6466板卡的内部6路通道集连实现scope抓取不同网段报文。
3.通过EH6466板卡的故障注入模块实现LIN短路断路等故障测试。
软件
CANoe的使用。本方案中5个需求有2个是靠CANoe系统变量调用实现的。
1.通过系统变量实现读取不同的资料输入配置表。
2.通过系统变量实现调用不同的Test Moudles模块。
成果展示 最后来看一下成果：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16be0680b1b947bc219f88ff51950452/" rel="bookmark">
			《红蓝攻防对抗实战》三.内网探测协议出网之HTTP/HTTPS协议探测出网
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一. 在 Windows 操作系统中探测 HTTP/HTTPS 出网
1. Bitsadmin 命令
2.Certuil 命令
2.Linux系统探测HTTP/HTTPS出网
1.Curl命令
2.Wget命令
对目标服务器探测 HTTP/HTTPS 是否出网时，要根据目标系统类型执行命令，不同类型的操作系统使用的探测方式也不同。例如，在 Windows 操作系统中可以使用自带的 bitsadmin、certutil 等命令来对 HTTP 或 HTTPS 进行出网探测，而在 Linux 操作系统中可以使用其自带的 curl、wget 等命令进行出网探测。下面以不同类型操作系统自带的命令为例， 进行 HTTP/HTTPS 探测出网。
一. 在 Windows 操作系统中探测 HTTP/HTTPS 出网 1. Bitsadmin 命令 Bitsadmin命令在Windows操作系统是用于创建、下载或上传作业，并监视作业进度的命令行工具。可通过该命令行工具测试能否从网站下载文件，以此来检测http或https是否出网，下面我们以百度官网的robots.txt为例进行演示，使用Bitsadmin命令下载百度官网目录下的robots.txt文件，并保存到本地C盘下的robots.txt中。
执行bitsadmin /rawreturn /transfer down "https://www.baidu.com/robots.txt" c:\robots.txt"命令，此时已成功下载robots.txt文件到C盘目录下。然后通过"type C:\robots.txt "命令读取查看，验证其存在，如若正常则证明探测出网成功，如图1-1所示。
图1-1 Bitsadmin命令探测出网成功
2.Certuil 命令 Certuil命令是windows操作系统中的一款下载文件的命令行工具，可作为证书服务的安装，用来转储和显示证书颁发机构 (CA) 配置信息，配置证书服务，备份和还原CA组件，以及验证证书、密钥对和证书链。
下面我们还是以百度网站下的的robots.txt文件为案例，使用Certuil命令执行certutil -urlcache -split -f https://www.baidu.com/robots.txt c:\robots.txt"将百度网站下的robots.txt文件保存到本地C盘目录下，通过验证发现robots.txt文件存在，则证明http/https协议出网，如图1-2所示。
图1-2 certuil命令探测出网成功
2.Linux系统探测HTTP/HTTPS出网 1.Curl命令 Curl是Linux自带的命令行工具，用于传输来自服务器或者到服务器的数据，可支持的协议有很多，Curl测试出网时使用命令很简单，只需要curl验证的url即可。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/16be0680b1b947bc219f88ff51950452/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11edbc5e8ec2bbb2808f01fe24f62c03/" rel="bookmark">
			如何破解压缩包密码，CTF压缩包处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		I. 引言 压缩包我们经常接触，用于对文件进行压缩存储/传输。压缩包处理在CTF比赛中是非常重要的一块，因为压缩包中可能包含重要信息：许多CTF题目会将关键信息隐藏在压缩包中，参赛者需要解压并查看其中的内容才能获取有用的线索。解密压缩是常见的CTF技能：参赛者需要掌握各种压缩文件格式的解压缩方法和工具，以及如何对压缩包进行加密和解密。压缩包处理可以提高解题效率：如果参赛者能够快速解压和查看压缩包中的文件列表和内容，就可以更快地找到关键信息，提高解题效率。对出题方而言，压缩包处理可以增加题目难度：如果一个CTF题目涉及到多个压缩包或复杂的加密算法，那么它会更加具有挑战性，考验参赛者的技术水平和耐心。
II. 常见的压缩文件格式 平时我们接触到的压缩包，主要有以下类型：zip格式、rar格式、7z格式、tar格式、gzip格式
其中zip和rar是最常见的其余7z、tar、gzip主要在linux上运行，出题常见于zip和rar，接下来我们简单介绍一下zip和rar两种压缩包
Zip压缩包： 典型特征后缀“.zip”，它的MIME格式为application/zip，zip压缩是一种有损压缩格式，即数据会因压缩而有损失，但是这种损失不会明显影响文件的质量。zip格式可以支持多种压缩算法，如存储、缩小、增强、最佳压缩等，可以根据不同的需求进行选择。zip压缩支持加密压缩。
特点1：数据记录格式：压缩源文件数据区+压缩源文件目录区+压缩源文件目录结束标志
压缩源文件数据库：[文件头+ 文件数据 + 数据描述符]
文件头： 50 4B 03 04 :这是文件头标记（0x04034b50），也可看到是“PK…”开头的
压缩源文件目录区为：50 4B 01 02
压缩源文件目录结束标志：50 4B 05 06
需要注意的加密点，每组四位数字，只和第二个数字有关系。
第二个数字为奇数时 –&gt;加密
第二个数字为偶数时 –&gt;未加密
① 无加密
压缩源文件数据区的全局加密应当为00 00 （50 4B 03 04两个bytes之后）
且压缩源文件目录区的全局方式位标记应当为00 00（50 4B 01 02四个bytes之后）
② 假加密
压缩源文件数据区的全局加密应当为00 00
且压缩源文件目录区的全局方式位标记应当为09 00
③ 真加密
压缩源文件数据区的全局加密应当为09 00
且压缩源文件目录区的全局方式位标记应当为09 00
RAR压缩包 典型特征“.rar”，rar 文件主要由标记块，压缩文件头块，文件头块，结尾块组成。
RAR 文件头 52 61 72 21 1A 07 00
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/11edbc5e8ec2bbb2808f01fe24f62c03/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d257289943c0a7d3a46662bcc177499a/" rel="bookmark">
			鱼哥赠书活动第②期：《AWD特训营：技术解析、赛题实战与竞赛技巧》《ATT&amp;CK视角下的红蓝对抗实战指南》《智能汽车网络安全权威指南》上下册
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		鱼哥赠书活动第②期： 《AWD特训营：技术解析、赛题实战与竞赛技巧》1.1介绍： 《ATT&amp;CK视角下的红蓝对抗实战指南》1.1介绍： 《Kali Linux高级渗透测试》1.1介绍： 《智能汽车网络安全权威指南》上册1.1介绍： 《智能汽车网络安全权威指南》下册1.1介绍： 适合阅读对象：赠书抽奖规则: 《AWD特训营：技术解析、赛题实战与竞赛技巧》 1.1介绍： 这是一本能指导你在AWD竞赛中速胜的标准参考书，也是一本能让你在高段位的CTF竞赛技高一筹的攻防秘籍，还是一本能全面提升你的网络安全攻防技术与水平的实战指南。
本书兼顾攻击与防守的双重视角，围绕AWD竞赛的内容全面展开，包括安全工具、主机安全加固、网络攻击、入侵检测、权限维持、应急响应、自动化攻防等技术主题。不仅剖析了AWD竞赛背后的技术细节，还总结了AWD竞赛的战略和战术。书中精选了大量真实案例和赛题，详细讲解了解题的方法和经验。此外，书中还有一个完整的AWD竞赛模拟演练，让读者能参与比赛的全过程并获得实战经验。
具体的，本书包含如下内容，它将助力你打造攻防一体的安全战线。
（1）安全竞赛的起源、竞赛模式、知名赛事以及AWD竞赛规则等。
（2）AWD竞赛中常用的安全工具，如信息搜集工具、后门木马检测工具、代码审计工具、漏洞扫描工具、流量采集工具、逆向分析工具等。
（3）主机加固的方式，包括操作系统加固、Web中间件加固、数据库加固及系统日志的安全配置等。
（4）AWD竞赛过程中涉及的靶场环境、CMS常见漏洞以及AWD竞赛中常考的五类Web通用型安全漏洞。
（5）PWN漏洞类型以及修复方式，包括栈溢出漏洞、格式化字符串漏洞、堆溢出漏洞、释放再利用漏洞等。
（6）Linux系统常规的后门部署方式，包括木马后门、系统账号后门、时间计划后门、SSH类后门、PAM后门等。
（7）Linux系统常规的入侵排查方式、安全监控方式和应急处置技巧，对于日常工作和安全竞赛都有所帮助。
（8）常见的开源自动化利用工具，帮助读者在比赛中简便、快速地编写自动化工具。
（9）通过模拟竞赛环境带领读者进行实战实操，包括信息搜集、挖掘漏洞、修复漏洞、检测防御、权限维持等，进一步加深理解安全技术知识。
《ATT&amp;CK视角下的红蓝对抗实战指南》 1.1介绍： 这是一本能同时帮助红队和蓝队建立完整攻击和防御知识体系的著作，也是一本既能指导企业建设和完善网络安全防御系统，又能打造安全工程师个人安全能力护城河的著作。
全书以ATT&amp;CK框架模型为基座，系统、详细地讲解了信息收集、隧道穿透、权限提升、凭据获取、横向渗透、持久化6大阶段所涉及的技术原理、攻击手段和防御策略。既能让红队理解攻击的本质、掌握实战化的攻击手段，又能让蓝队看透红队的攻击思路，从而构建更为强大的防御体系。
本书的宗旨是“以攻促防、以战训战”，所以书中精心整理了大量来自实践的攻防案例，每个案例都提供了详细的思路、具体的步骤，以及实战中的经验、技巧和注意事项，尽可能让读者感受到真实的攻防对抗氛围。
本书内容丰富，讲解又极为细致，所以篇幅巨大，具体包含如下7个方面的内容。
（1）Windows安全基础
详细介绍Windows的安全认证机制（NTLM认证、Kerberos域认证）、协议（LLMNR、NetBIOS、WPAD、LDAP）和域的基础知识。
（2）信息收集
详细讲解主机发现、Windows/Linux操作系统信息收集、组策略信息收集、域控相关信息收集、Exchange信息收集等各种信息收集手段。
（3）隧道穿透
全面、透彻讲解隧道穿透技术基础知识、利用多协议进行隧道穿透的方法、常见的隧道利用工具、以及检测防护方法。
（4）权限提升
详细讲解内核漏洞提权、错配漏洞提权、第三方服务提权等红蓝对抗中常用的提权手法，既讲解这些手法在实际场景中的利用过程，又提供针对性的防御手段。
（5）凭据获取
从攻击和防御两个维度，详细讲解主要的凭证获取手法，包括软件凭证获取、本地凭证获取、域内凭证等。
（6）横向移动
全面分析利用任务计划、远程服务、组策略、WSUS、SCCM、Psexec、WMI等系统应用服务及协议进行横向移动的原理与过程。
（7）持久化
既详细讲解红队常用的持久化手法，如Windows持久化、Linux持久化、Windows域权限维持等，又系统分析蓝队针对持久化攻击的检测和防御思路。
《Kali Linux高级渗透测试》 1.1介绍： 对于企业网络安全建设工作的质量保障，业界普遍遵循PDCA（计划（Plan）、实施（Do）、检查（Check）、处理（Act））的方法论。近年来，网络安全攻防对抗演练发挥了越来越重要的作用。企业的安全管理者通过组织内部或外部攻击队，站在恶意攻击者的视角，识别自身网络安全建设过程中的防护短板，检验安全应急预案的有效性并持续优化，为业务发展提供更强的保驾护航能力。
本书是企业进行网络安全对抗演练不可多得的参考书，对攻击队和防守队都适用。
本书系统地介绍了安全测试流程的最佳实践和常见误区，围绕Kali Linux这个开源工具，详细阐述了各类测试技术的原理和操作方法。即使是初学者，也可以在本书深入浅出的指引下轻松上手。对于富有经验的渗透测试人员，本书更是提供了进阶实战场景的实用脚本和代码库资源，相信能给读者带来新的启发。
企业攻防对抗演练是攻防双方的思路、策略、技术和情报能力的综合比拼。“敌暗我明”“攻防力量不对称”的情况往往瞬息万变，结果胜负是一时的，过程常态化才是主旋律。在现实的网络空间安全中，这样的常态化每天都在上演，安全团队只有正确制定攻防演练的目标，才能得到企业对安全工作的认可。
《智能汽车网络安全权威指南》上册 1.1介绍： 这是一本能帮助汽车从业者和安全从业者全面构建汽车网络安全知识体系、快速掌握汽车网络安全攻防经验的权威指南。它由国内知名电动汽车厂商安全团队负责人带领核心团队成员撰写，以“安全左移”为指导思想，围绕安全合规、安全标准、安全体系、安全测试、安全研发、安全运营、网络攻防、威胁评估、自动驾驶安全等9大核心主题对汽车的网络安全进行了全面且透彻的阐述，是汽车网络安全领域的标准性著作。
由于内容覆盖面广，而且比较深入和细致，因此本书篇幅较大。为了方便不同需求的读者阅读和各取所需，全书分为了上、下两册。
上册（第1~10章）
（1）梳理了汽车安全的发展脉络，以及汽车的功能安全、预期功能安全、网络安全3大安全主题，旨在让读者对汽车网络安全有一个宏观和整体的认知。
（2）详细讲解了汽车的网络组成、网络通信协议、电子电气架构以及架构视角和功能视角的网络安全，旨在让读者精准地掌握与汽车相关的网络知识。
（3）重点解读了汽车网络安全的合规体系，主要内容包括国内外网络安全法规、汽车网络安全管理体系及其应用，旨在让读者了解汽车网络安全的标准并结合业务场景进行多体融合，建立对应的汽车网络安全管理体系。
（4）从攻防的视角讲解了黑客如何零门槛破解一辆汽车以及针对各种不同场景的网络安全测试工具的用法。
《智能汽车网络安全权威指南》下册 1.1介绍： （1）详细总结了汽车黑客的攻击思维和方法，并列举了汽车网络安全架构视角和汽车功能应用视角下的常用攻击手法和防御措施。
（2）系统讲解了覆盖整车研发周期的网络安全策略，包括威胁分析与风险评估、汽车网络安全架构、汽车网络安全监控与响应等。
（3）前瞻性地讲解了高级辅助驾驶安全和汽车充电网络安全，相关知识非常稀缺，能帮助读者开阔眼界。
本书不仅理论体系全面，能帮助读者构建对汽车和网络安全的立体认知；而且实操指导具体，为读者总结了汽车网络安全攻防的各种方法和手段。全书包含大量案例、模型和数百个图表，看了就能懂，学会就能用！
适合阅读对象： 网络安全相关专业在校学生网络安全初学者 高校教师企业网络安全工程师其他具备计算机基础知识并对网络安全攻防感兴趣的组织或个人智能汽车安全领域感兴趣的 从业者，爱好者等。CTF爱好者 赠书抽奖规则: 本次送书2本活动时间：截止到2023-10-24参与方式：关注博主、点赞、收藏并任意评论
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d257289943c0a7d3a46662bcc177499a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b616e3988f9a1ccf70754551a8deaf97/" rel="bookmark">
			如何将Qstring赋值给一个字符数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		将QString赋值给一个字符数组需要进行字符串的转换。可以使用QString的toUtf8()或toLatin1()方法将QString转换为QByteArray，再使用QByteArray的data()方法获取字符数组的指针。
下面是一个示例代码：
```cpp
QString qstr = "Hello, World!";
QByteArray bytearray = qstr.toUtf8(); // 或者使用 toLatin1()
const char* chararray = bytearray.constData();
```
在上面的示例中，首先将QString对象qstr转换为QByteArray对象bytearray，使用toUtf8()方法将QString转换为UTF-8编码的字节数组。如果需要使用Latin1编码，可以使用toLatin1()方法。然后使用constData()方法获取字符数组的指针，将其赋值给chararray。
需要注意的是，转换后的字符数组指针chararray是一个常量指针，不能修改其中的内容。如果需要修改字符数组的内容，可以使用QByteArray的data()方法获取非常量指针。
另外，为了避免内存泄漏，如果在使用完字符数组后不再需要，可以使用delete[]释放字符数组的内存：
```cpp
delete[] chararray;
```
这样可以确保内存得到正确释放。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17d15a34a899f2be6ad7f121fb82019b/" rel="bookmark">
			乾坤（qiankun）微前端介绍及实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.什么是微前端？
2.核心价值
3.意义
4. qiankun 实现
主应用
微应用
最后
1.什么是微前端？ 微前端是一种多个团队通过独立发布功能的方式来共同构建现代化 web 应用的技术手段及方法策略。
2.核心价值 ①技术栈无关：主框架不限制接入应用的技术栈，微应用具备完全自主权。
②独立开发、独立部署：微应用仓库独立，前后端可独立开发，部署完成后主框架自动完成同步更新。
③增量升级：在面对各种复杂场景时，我们通常很难对一个已经存在的系统做全量的技术栈升级或重构，而微前端是一种非常好的实施渐进式重构的手段和策略。
④独立运行时：每个微应用之间状态隔离，运行时状态不共享。
3.意义 微前端架构旨在解决单体应用在一个相对长的时间跨度下，由于参与的人员、团队的增多、变迁，从一个普通应用演变成一个巨石应用(Frontend Monolith)后，随之而来的应用不可维护的问题。这类问题在企业级 Web 应用中尤其常见。
4. qiankun 实现 主应用 ①安装 qiankun
只需在主应用安装即可，微应用无需安装。
yarn add qiankun ②注册微应用(main.js)
import Vue from "vue"; import App from "./App"; import router from "./router"; import store from "./store"; import ElementUI from "element-ui"; import "element-ui/lib/theme-chalk/index.css"; import { registerMicroApps, start } from "qiankun"; Vue.config.productionTip = false; Vue.use(ElementUI); registerMicroApps([ // 注册应用 { name: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/17d15a34a899f2be6ad7f121fb82019b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd5197e24a6a89d1b07c3bff1fce89c9/" rel="bookmark">
			case when 结合sum()函数使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.正确语法 sum(case when 条件 then 1 else 0 end) as result1; 2.错误案例 case WHEN code = 'CNY' THEN SUM(balance) END AS sum_CNY; -- sum求得balance的和，case 条件无效。 3. 二者逻辑上的区别 sum(case when 条件 then 1 else 0 end) as result1; # 无论是否满足case when条件，都会执行sum() case WHEN code = 'CNY' THEN SUM(balance) END AS sum_CNY; #满足case when,则执行sum(),但sum()不包含case when条件，即sum()会取到全部的值 4.关于case when 的其他注意事项 case when 嵌套使用，或将case when的值做数学运算（±*/）时，不可用别名。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/682869bd1a3dca1192dd9e788d18f7a7/" rel="bookmark">
			2023 CSP-J2（入门级复赛）第二轮认证真题及答案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		小苹果(apple)
【题目描述】小 Y 的桌子上放着 n 个苹果从左到右排成一列，编号为从 1 到 n。
小苞是小 Y 的好朋友，每天她都会从中拿走一些苹果。 每天在拿的时候，小苞都是从左侧第 1 个苹果开始、每隔 2 个苹果拿走 1 个苹果。
随后小苞会将剩下的苹果按原先的顺序重新排成一列。 小苞想知道，多少天能拿完所有的苹果，而编号为 n 的苹果是在第几天被拿走的?
【输入格式】
从文件 apple.in 中读入数据。 输入的第一行包含一个正整数 n，表示苹果的总数。
【输出格式】
输出到文件 apple.out 中。
输出一行包含两个正整数，两个整数之间由一个空格隔开，分别表示小苞拿走所有 苹果所需的天数以及拿走编号为 n 的苹果是在第几天。
【样例 1 输入】 8
【样例 1 输出】 5 5
【样例 1 解释】
小苞的桌上一共放了 8 个苹果。 小苞第一天拿走了编号为 1、4、7 的苹果。 小苞第二天拿走了编号为 2、6 的苹果。 小苞第三天拿走了编号为 3 的苹果。 小苞第四天拿走了编号为 5 的苹果。 小苞第五天拿走了编号为 8 的苹果。
【样例 2】
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/682869bd1a3dca1192dd9e788d18f7a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51727090e3c9921f05184d9f68692e12/" rel="bookmark">
			微信小程序中使用ECharts方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		官网中介绍到：为了兼容小程序 Canvas，微信小程序提供了一个小程序的组件，echarts-for-weixin用这种方式可以方便地使用 ECharts。
进入github下载
下载完项目后把文件中ec-canvas文件，放到你的小程序的page目录下，或者你的components组件文件夹下，将echarts.js引入到你需要展示图表的.json文件，如果希望减小包体积大小， 可以使用自定义构建生成并替换掉你文件内 echarts.js；
在需要展示图表的文件夹对应的.json文件内引入echarts.js，如下：
//例如你的页面名叫myEcharts,需在myEcharts.json中配置，如下： { "usingComponents": { "ec-canvas": "../../../components/ec-canvas/ec-canvas" }, } 在myEcharts.wxml使用，如下：
&lt;view&gt; &lt;!--ec是组件对象，对应着js文件里data的ec，canvas需要给一个宽度、高度--&gt; &lt;ec-canvas id="mychart-dom-bar" class="myCanvas" canvas-id="mychart-bar" ec="{{ec}}"&gt;&lt;/ec-canvas&gt; &lt;/view&gt; 在myEcharts.wxss中加入宽高：
.myCanvas canvas{ width: 100%; height: 300rpx!important; } 在myEcharts.js中写法，如下：
import * as echarts from "../../components/ec-canvas/echarts.js"; //这个是ec-canvas 目录下的 echarts.js // 获取应用实例 const app = getApp() let chart = null; function setOption(chart) { var option = { legend: { // Try 'horizontal' orient: 'vertical', right: 10, top: 'center' }, dataset: { source: [ ['product', '2015', '2016', '2017'], ['Matcha Latte', 43.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/51727090e3c9921f05184d9f68692e12/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ccb6b67e159f4953a2dd193703be4277/" rel="bookmark">
			吞吐量（TPS）、QPS、并发数、响应时间（RT）概念
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		QPS 原理：每天80%的访问集中在20%的时间里，这20%时间叫做峰值时间。
公式：( 总PV数 * 80% ) / ( 每天秒数 * 20% ) = 峰值时间每秒请求数(QPS) 。
机器：峰值时间每秒QPS / 单台机器的QPS = 需要的机器 。
每天300w PV 的在单台机器上，这台机器需要多少QPS？
( 3000000 * 0.8 ) / (86400 * 0.2 ) = 139 (QPS)。
一般需要达到139QPS，因为是峰值。
QPS 每秒查询率QPS是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准。
每秒查询率
因特网上，经常用每秒查询率来衡量域名系统服务器的机器的性能，其即为QPS。
对应fetches/sec，即每秒的响应请求数，也即是最大吞吐能力。
计算机语言
一种计算机编程语言。用于数据分析和报表产出。运作的平台是MRDCL。支持的数据文件包括ASC格式和CSI格式。
其中CSI格式为QPS独有数据格式。是极其专业的用于数据分析、数据清理和报表产出的语言，目前应用最广的是市场调研行业。中国国内运用的相对比较少。
开发的原因，需要对吞吐量（TPS）、QPS、并发数、响应时间（RT）几个概念做下了解，查自百度百科，记录如下：
1. 响应时间(RT) 响应时间是指系统对请求作出响应的时间。直观上看，这个指标与人对软件性能的主观感受是非常一致的，因为它完整地记录了整个计算机系统处理请求的时间。由于一个系统通常会提供许多功能，而不同功能的处理逻辑也千差万别，因而不同功能的响应时间也不尽相同，甚至同一功能在不同输入数据的情况下响应时间也不相同。所以，在讨论一个系统的响应时间时，人们通常是指该系统所有功能的平均时间或者所有功能的最大响应时间。当然，往往也需要对每个或每组功能讨论其平均响应时间和最大响应时间。 对于单机的没有并发操作的应用系统而言，人们普遍认为响应时间是一个合理且准确的性能指标。需要指出的是，响应时间的绝对值并不能直接反映软件的性能的高低，软件性能的高低实际上取决于用户对该响应时间的接受程度。对于一个游戏软件来说，响应时间小于100毫秒应该是不错的，响应时间在1秒左右可能属于勉强可以接受，如果响应时间达到3秒就完全难以接受了。而对于编译系统来说，完整编译一个较大规模软件的源代码可能需要几十分钟甚至更长时间，但这些响应时间对于用户来说都是可以接受的。
2. 吞吐量(Throughput) 吞吐量是指系统在单位时间内处理请求的数量。对于无并发的应用系统而言，吞吐量与响应时间成严格的反比关系，实际上此时吞吐量就是响应时间的倒数。前面已经说过，对于单用户的系统，响应时间（或者系统响应时间和应用延迟时间）可以很好地度量系统的性能，但对于并发系统，通常需要用吞吐量作为性能指标。 对于一个多用户的系统，如果只有一个用户使用时系统的平均响应时间是t，当有你n个用户使用时，每个用户看到的响应时间通常并不是n×t，而往往比n×t小很多（当然，在某些特殊情况下也可能比n×t大，甚至大很多）。这是因为处理每个请求需要用到很多资源，由于每个请求的处理过程中有许多不走难以并发执行，这导致在具体的一个时间点，所占资源往往并不多。也就是说在处理单个请求时，在每个时间点都可能有许多资源被闲置，当处理多个请求时，如果资源配置合理，每个用户看到的平均响应时间并不随用户数的增加而线性增加。实际上，不同系统的平均响应时间随用户数增加而增长的速度也不大相同，这也是采用吞吐量来度量并发系统的性能的主要原因。一般而言，吞吐量是一个比较通用的指标，两个具有不同用户数和用户使用模式的系统，如果其最大吞吐量基本一致，则可以判断两个系统的处理能力基本一致。
3. 并发用户数 并发用户数是指系统可以同时承载的正常使用系统功能的用户的数量。与吞吐量相比，并发用户数是一个更直观但也更笼统的性能指标。实际上，并发用户数是一个非常不准确的指标，因为用户不同的使用模式会导致不同用户在单位时间发出不同数量的请求。一网站系统为例，假设用户只有注册后才能使用，但注册用户并不是每时每刻都在使用该网站，因此具体一个时刻只有部分注册用户同时在线，在线用户就在浏览网站时会花很多时间阅读网站上的信息，因而具体一个时刻只有部分在线用户同时向系统发出请求。这样，对于网站系统我们会有三个关于用户数的统计数字：注册用户数、在线用户数和同时发请求用户数。由于注册用户可能长时间不登陆网站，使用注册用户数作为性能指标会造成很大的误差。而在线用户数和同事发请求用户数都可以作为性能指标。相比而言，以在线用户作为性能指标更直观些，而以同时发请求用户数作为性能指标更准确些。 4. QPS每秒查询率(Query Per Second) 每秒查询率QPS是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准，在因特网上，作为域名系统服务器的机器的性能经常用每秒查询率来衡量。对应fetches/sec，即每秒的响应请求数，也即是最大吞吐能力。（看来是类似于TPS，只是应用于特定场景的吞吐量）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68f34b5137fa78d4f51d02f0bbd43b9f/" rel="bookmark">
			【Maven】Unknown lifecycle phase “.skip.test=true“.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 idea 终端执行如下命令时 mvn clean install -Dmaven.skip.test=true 报： Unknown lifecycle phase ".skip.test=true". You must specify a valid lifecycle phase or a goal in the format &lt;plugin-prefix&gt;:&lt;goal&gt; or &lt;plugin-group-id&gt;:&lt;plugiprepare-package, package, pre-integration-test, integration-test, post-integration-test, verify, install, deploy, pre-clean, clean, post-clean, pre-site, site, post-site, site-deploy. -&gt; [Help 1] 原因：命令没有被终端有效的识别到解决方法： 1、打开 idea 设置
2、切换为：C:\Windows\system32\cmd.exe
3、或者也可以在默认终端（powershell.exe）运行命令的时候加上引号，如：
mvn clean install '-Dmaven.skip.test=true' 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e29682a288fd436a45636137713709c4/" rel="bookmark">
			算法（三）数组之二分法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		leetcode [hot] 33. 搜索旋转排序数组 题目 整数数组 nums 按升序排列，数组中的值 互不相同 。
在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。
给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的索引，否则返回 -1 。
示例 1： 输入：nums = [4,5,6,7,0,1,2], target = 0 输出：4 示例 2： 输入：nums = [4,5,6,7,0,1,2], target = 3 输出：-1 示例 3： 输入：nums = [1], target = 0 输出：-1 题解 通过二分法解决问题，首先确定搜索范围，之后l和r指针不断缩小范围，从而找到最终结果，示例代码如下所示：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e29682a288fd436a45636137713709c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70e286ed9b7604dd1bee95c25c317bee/" rel="bookmark">
			Android学习之路(21) 进程间通信-AIDL与Servce基本使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Service 与 Thread 和 进程 之间的关系 进程：应用程序在内存中分配的空间。（正在运行中的程序）线程：负责程序执行的单元，也称为执行路径。（需要线程来执行代码）。一个进程至少包含一条线程，如果一个进程中出现了条线程，此程序就为多线程程序。Service是一个组件：默认运行在Main线程（进程中）。和Thread没关系。如果Service在清单文件中用 android:process 属性另开进程运行此Service组件，就算Service被销毁进程也不会停止。 Service的生命周期图
!
|
【Android】跨进程通信——AIDL、之Service基本细节使用之：精通
Service 与 Thread 和 进程 之间的关系 进程：应用程序在内存中分配的空间。（正在运行中的程序）线程：负责程序执行的单元，也称为执行路径。（需要线程来执行代码）。一个进程至少包含一条线程，如果一个进程中出现了条线程，此程序就为多线程程序。Service是一个组件：默认运行在Main线程（进程中）。和Thread没关系。如果Service在清单文件中用 android:process 属性另开进程运行此Service组件，就算Service被销毁进程也不会停止。 Service的生命周期图 回调方法详解 onCreate()，创建Service时调用，整个生命周期中只执行一次。onBind()，必须实现的方法，客户端调用bindService()时回调该方法，返回一个IBind对象，通过此对象与被绑定Service通信。此后如果再次使用bindService绑定Service，系统不会再调用onBind()方法，只会直接把IBinder对象传递给其他后来增加的客户端！onStartCommand()，早期版本是onStart()。客户端通过startService()时调用。可多次调用startService()，但不会创建新的Service对象，继续复用已创建的Service，会继续回调onStartCommand()方法。onUnbind()，当该Service上绑定的所有客户端都断开时会回调该方法！onDestroy()，服务被关闭前调用此方法。如调用stopService()，或者调用unbindService()。 三种服务的启动方式 startService()启动Service 方法回调：onCreate() —&gt; onStartCommand() —&gt; 进入运行状态。联系绑定：与调用者无联系，就算调用者结束了生命，只要不调用stopService()方法，Service还会继续运行。结束方法：stopService() bindService()启动Service 方法回调：onCreate() —&gt; onBind() —&gt; 进入运行状态。联系绑定：服务与调用者进行联系绑定。1. 如果调用者没有手动调用unbindService()关闭服务，当调用者销毁后，服务也会被销毁，并回调 onUnbind() —&gt; onDestroy()。 2. 如果是多个客户端绑定同一个Service的话，当所有的客户端都和service解除绑定或销毁后，系统才会销毁service。结束方法：unbindService()注意：如果中途中通过startService() 方法启动服务，则服务不会和全部调用者进行联系绑定。 startService()启动Service后，调用bindService()绑定Service 方法回调：onCreate() —&gt; onStartCommand() —&gt; onBind() —&gt; 进入运行状态。方法回调2：如果两条语句在一个方法内：onCreate() —&gt; onBind() —&gt; onStartCommand() —&gt; 进入运行状态。联系绑定：与调用者无联系，因为服务是通过startService()启动的。结束方法：先unbindService()解绑，再调用stopService()关闭Service 不管哪种方法启动服务，都可以调用 stopService() 关闭服务。上面是按照规范关闭服务，当然你有需求的话。
清单文件声明 Service 组件及属性 android:exported表示是否允许除了当前程序之外的其他程序访问这个服务android:enabled表示是否启用这个服务android:permission是权限声明android:process是否需要在单独的进程中运行,当设置为android:process=”:remote”时，代表Service在单独的进程中运行。注意“：”很重要，它的意思是指要在当前进程名称前面附加上当前的包名，所以“remote”和”:remote”不是同一个意思，前者的进程名称为：remote，而后者的进程名称为：App-packageName:remote。android:isolatedProcess设置 true 意味着，服务会在一个特殊的进程下运行，这个进程与系统其他进程分开且没有自己的权限。与其通信的唯一途径是通过服务的API(bind and start)。 &lt;service android:name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70e286ed9b7604dd1bee95c25c317bee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98410896f426aef72f3d95e4d99dd6f0/" rel="bookmark">
			100097. 合法分组的最少组数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		给你一个长度为 n 下标从 0 开始的整数数组 nums 。
我们想将下标进行分组，使得 [0, n - 1] 内所有下标 i 都 恰好 被分到其中一组。
如果以下条件成立，我们说这个分组方案是合法的：
对于每个组 g ，同一组内所有下标在 nums 中对应的数值都相等。
对于任意两个组 g1 和 g2 ，两个组中 下标数量 的 差值不超过 1 。
请你返回一个整数，表示得到一个合法分组方案的 最少 组数。
示例 1：
输入：nums = [3,2,3,2,3]
输出：2
解释：一个得到 2 个分组的方案如下，中括号内的数字都是下标：
组 1 -&gt; [0,2,4]
组 2 -&gt; [1,3]
所有下标都只属于一个组。
组 1 中，nums[0] == nums[2] == nums[4] ，所有下标对应的数值都相等。
组 2 中，nums[1] == nums[3] ，所有下标对应的数值都相等。
组 1 中下标数目为 3 ，组 2 中下标数目为 2 。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98410896f426aef72f3d95e4d99dd6f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/667d3fb4819eaaf6ec6a6d4edd268cc4/" rel="bookmark">
			No appropriate protocol(Connections could not be acquired from the underlying database! ）报错解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 我把前后端服务都部署好，正准备运行的时候这时候出现一个错误，我在开发者工具中查看返回的主要错误信息是Could not get JDBC Connection; nested exception is java.sql.SQLException: Connections could not be acquired from the underlying database!
我在网上查阅了相关信息，大部博客的解释是密码错误，或者相关配置没有正确配置，我检查了很多边但是依然出错，然后我去tomcat日志文件查看错误，tomcat给我报出的错误是No appropriate protocol，翻译就是：javax.net.ssl.ssl握手异常：没有合适的协议。
所以之前的错误(Connections could not be acquired from the underlying database!)这个应该是通用错误，很多错误都会导致浏览器返回这个信息，要不是看tomcat可能我还蒙在鼓里，不知道如何具体的错误内容是什么，这里也提醒大家遇到错误第一步先看日志文件，这里应该jdk版本的问题，我是直接用yum安装的，这个jdk版本太高支持了一些安全协议。
解决办法1：修改jre/lib/security/java.security中的disabledAlgorithms，删除SSLv3, TLSv1, TLSv1.1，然后重启应用即可。在vim下，可以使用/disabledAlgorithms快速查找。尽量把 解决办法2：如果上一个方法修改依然报错，在原来修改的基础上再修改一个配置
修改jdk配置文件/etc/crypto-policies/back-ends/java.config，类似上面方法一样，删除`SSLv3, TLSv1, TLSv1.1``，保存重启应用。
解决办法3：如果以上三个办法都无效，那就用最暴力的方法，直接重新安装jdk。
总结： 通过这次错误，我希望大家在写什么项目的时候，一定要先确定好每一个开发过程的工具版本，这一点可以让你在开发过程减少很多不必要的错误，提高开发速度。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74eb30c8de592e0c197c4b5159a610e1/" rel="bookmark">
			在ESP32-Arduino开发中添加其它Arduino库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
原理说明
操作步骤
下载Bounce
安装Bounce
将下载的文件夹(压缩包需要解压)移动到components/arduino/libraries路径下，并重命名为Bounce2
查看添加库里所有的源文件位置
在arduino的CMakeList.txt里添加库源文件
使用Bounce
前言 乐鑫官方的esp-arduino把ESP32的大部分外设做了arduino驱动开发(仍在持续进行中)，并且也提供了一部分有趣的应用库，但有时，还需要使用一些其它esp-arduino中未提供的arduino库，这种情况也是可以很容易搞定的
原理说明 将待添加的arduino库，添加到esp-arduino components中，这样便安装在ESP-IDF框架中，可以在工程中被调用了
操作步骤 这里以添加Bounce2库为例进行说明
下载Bounce GitHub - thomasfredericks/Bounce2: Debouncing library for Arduino and Wiring
在这里使用git或下载zip包均可
安装Bounce 将下载的文件夹(压缩包需要解压)移动到components/arduino/libraries路径下，并重命名为Bounce2 查看添加库里所有的源文件位置 （在linux下可使用如下命令：find libraries/Bounce2/src/ -name '*.c' -o -name '*.cpp'），可以看到在Bounce2/src路径下有.h和.cpp文件
在arduino的CMakeList.txt里添加库源文件 打开/idf/components/arduino/CMakeLists.txt文件
添加头文件include路径 在set(includedirs字段末尾加上源文件include路径，如：libraries/Bounce2/src
添加源文件路径 在set(LIBRARY_SRCS字段末尾添加，如：libraries/Bounce2/src/Bounce2.cpp
使用Bounce 在工程里include头文件，并调用库API即可使用该库，如下所示：
参考资料：https://docs.espressif.com/projects/arduino-esp32/en/latest/esp-idf_component.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fcf41e93ecf06510c8b9978a1d99d0fd/" rel="bookmark">
			【MATLAB】点运算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		欢迎来到博主 Apeiron 的博客，祝大家旅程愉快 ！时止则止，时行则行。动静不失其时，其道光明。
目录
1、缘起
2、缘聚
2.1、基本算数运算符
2.2.1 矩阵加法 2.2.2 矩阵减法 2.2.3 矩阵乘法
2.2、点运算示例
3、缘落
1、缘起 大一下半学期，学校开设了 MATLAB 课程。但是，那个时候心思没在学习上，痴迷于悟“道”，就是传统文化中的 道家思想 ，所以当时 MATLAB 也就学的稀里糊涂，而且那个时候也没有认识到 MATLAB 在工科领域的地位。当然，这课门最后也是挂了，补考也是 60 分飘过。哎，说多了都是泪啊 ~~
在之后的学习当中，用到 MATLAB 的场合也不多，只要是遇到不会的，或者遗忘的 MATLAB 知识点就去百度一下，只要把当前的作业完成就好了。然而，最后发现这样学习到的 MATLAB 知识点非常碎片化，不成体系，所以遗忘也就非常大。在每每用到相关知识点的时候，由于遗忘，总是再一次的去资源浩如烟海的网上查询，这样就导致学习效率就很低下。
在觉醒之后，我内心深处有一个声音响起：“该回到正轨了”。这时，我才把心思从道家思想慢慢地转移到学习上。是啊，专注内观，聆听心声；遍体阳和，金华出露；回光循循然行去，不要废弃正业，不要废弃正业，不要废弃正业哇 ~ 。这时的我，在专业课程上已经被同学甩开了一大截。课程落下了，知识没学到，这都没关系，再去重新学一遍就好了。从表面上看，我和同学相比是有点晚了，但是我觉得一点都不晚，学习从什么时候开始都不晚。我是什么样的人，我就会看到什么样的世界；我有什么样的眼光，我就会从世界里面看出什么样的世界意义；从这个意义上来说，世界本身是什么样的并不重要，重要的是我是怎么样的。
现在回忆起之前的经历，我对我之前的选择，一点都不后悔。如果没有当时力排众议的选择，就不会有后面的经历，没有这些奇特的经历，就不会有今天的我。他们总说我瓜，其实我一点都不瓜，大多时候我都是机智的一批。因为 智慧的获得 是可遇而不可求的，要看机缘，看悟性。人一旦开了窍，人生就像开了挂一样，做事也会顺利很多。开窍后的我就像是被打通了任督二脉，突然就不再害怕书本上的那些晦涩难懂的知识点了。
这时，踏入道境，我再也不是大一时懵懵懂懂、傻啦吧唧和极其浮躁的我了。我发现人与人的差距在两个方面上，一是在社会关系上，二在认知水平上。读书是对认知水平的塑造，但是能塑造多高，跟书的数量没有必然关系，而在于对知识 “领悟运用的能力” 和 “结合自身实践的能力”。
在此之后，我在学习的时候，开始注重建立知识逻辑，知识体系和知识框架。学习再也不以考试不挂科为目的，而是以把知识理解透彻，能用其展现创造力，体会知识对我们的文明产生了什么样的影响和探究知识的边界为目的。
2、缘聚 回顾过往的经历，是为了更好的筹划未来。在以往学习 MATLAB 的过程中，这个 MATLAB 点运算 是最让我抓狂的一个知识点。运算没有加 "点"，图像出不来。说到底，还是没有深入透彻理解点运算，不知道在什么时候加“点”，什么时候不加“点”。老是学，老是忘；然后学，然后再忘；就陷入一个 while( 1 ) 循环中了。
就在今天，我想去用 MATLAB 画一个数学图像，需要用到点运算，然后又忘了。得，又去重新学习了一遍。然后我把这个学习点运算的笔记在博客上 ，以求深入理解和纯熟应用，同时也希望能够帮助到有需要的同学。等到再次忘记的时候，直接简单快捷地翻阅这篇博客就可以啦 ！
2.1、基本算数运算符 在学习点运算之前，先了解一下 MATLAB 中的最基本的算数运算符，这样在学习点运算的时候便会事半功倍。其基本的算数运算符如下：
+（加）、-（减）、*（乘）、^ (乘方）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fcf41e93ecf06510c8b9978a1d99d0fd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff5667c8d38dee2606243f3daa3a8197/" rel="bookmark">
			《红蓝攻防对抗实战》二.内网探测协议出网之TCP/UDP协议探测出网
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一.TCP/UDP协议探测出网
1.NC工具探测TCP协议出网
2.Telnet命令探测TCP协议出网
3.UDP协议探测出网
当红队人员在进行内网渗透时，经常会遇到目标主机不出网的场景，而主机不出网的原因有很多，常见的原因例如目标主机未设置网关，被防火墙或者其他防护设备拦截设置了出入站策略，只允许特定协议或端口出网等。当我们遇到这种情况时，可以通过本章节中所讲到的方法，利用各种包含该协议的方式探测目标主机允许哪些协议出网，根据探测到的协议信息进行隧道穿透。在已经获取到目标系统的权限前提下，可以通过下述所讲到的各种协议探测手段来进行探测是否出网。
一.TCP/UDP协议探测出网 在对目标服务器进行TCP/UDP协议探测出网前，需要满足前文中所提到的已经获取目标管理权限的前提下进行本次实验。本次实验环境拓扑如图所示
图1-1 TCP/UDP协议探测出网实验拓扑
1.NC工具探测TCP协议出网 1）根据图1-1 所描述的实验拓扑环境中，使用nc工具和Telnet命令来探测TCP协议是否出网，首先介绍一下Netcat(NC)这款工具，它是一款比较简单并且非常有用的工具，既支持通过TCP和UDP在网络连接中读写数据，也是一个稳定的后门工具，支持其它程序和脚本驱动，同时它还是一个功能强大的网络调试和探测工具，可以建立使用中所需要的几乎所有类型的网络连接，若要利用NC工具来探测TCP协议是否出网，首先我们先使用NC工具在目标服务器中执行nc.exe -lvp 8888"命令来监听目标服务器的8888端口，如图1-2所示。在使用nc开启监听执行连接的过程中，会发起TCP请求和响应时，同时也会产生数据包，通过在本地主机中使用Wireshark流量分析软件来抓取发起连接过程的数据包，后续通过抓取到的数据包来查看TCP三次握手连接过程。
图1-2 使用NC工具开启服务端监听
2）在Windows 10主机中使用nc工具连接目标服务器8888端口，检测其是否出网。执行nc.exe -nv 8.130.xxx.xxx 8888"命令，发现成功连接，显示open开启端口状态，可证明目标服务器TCP协议出网，如图1-3所示。
图1-3 客户端连接成功
3）在使用nc工具连接探测到出网成功的同时，在本地主机中可以看到从wireshark软件中抓取的数据包，分析本地主机和目标服务器TCP协议建立连接的过程，在过滤栏使用"tcp.port == 8888"，过滤TCP端口，即可看到TCP三次握手成功的情况，如图1-4所示。
图1-4 TCP三次握手过程
2.Telnet命令探测TCP协议出网 1）使用Telnet命令来探测目标服务器是否出网，首先需要在目标服务器使用nc工具开启监听8888端口，执行命令nc.exe -lvp 8888，成功开启目标服务器监听，如图1-5所示。
图1-5 nc开启服务端监听
2）当开启监听后，在本地主机中使用Telnet命令连接到目标服务器。执行telnet 8.130.xx.xx 8888命令，如图1-6所示则证明连接成功，即代表允许TCP出网。
图1-6 Telnet客户端连接成功
3.UDP协议探测出网 1）探测目标服务器UDP协议是否出网前，需要上传nc到目标服务器，在目标服务器上执行nc.exe -ulvp 8888"命令来开启目标服务器监听, 如图1-7所示，其中-u参数是指nc使用udp协议进行数据传输（nc默认使用tcp）。
图1-7 nc使用Udp协议开启服务端监听
2）由于UDP是无连接传输协议，发送端和接收端之间没有握手，每个UDP报文段都会被单独处理，在Windows 10主机中启动wireshark流量分析软件，抓取本地流量包，开启监听后在Windows 10主机利用nc工具发起连接。执行nc.exe -uv 8.130.xx.xx 8888"命令，测试返回响应后，发现显示open，连接成功，如图1-8所示。
图1-8 nc客户端使用udp协议连接成功
3）通过在本地Wireshark流量分析软件抓取到的UDP数据包，可以看出本机和目标服务器通过UDP协议进行通讯，证实UDP协议出网，如图1-9所示。
图1-9 wireshark捕获Udp数据包
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df83e5c1d2d7c72169fa2dae71bb47b4/" rel="bookmark">
			java8分区函数partitioningBy()使用示例|过期提醒
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		partitioningBy分区是一种特殊的分组，可以将List划分为两个子List。
比如，如果我们需要两个子List，分别表示已过期和未过期的数据， 就可以向下面这样实现了：
package com.vada.rfsplus.service.resource.service.impl; import cn.hutool.core.date.DateUnit; import cn.hutool.core.date.DateUtil; import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper; import com.baomidou.mybatisplus.core.metadata.IPage; import com.baomidou.mybatisplus.core.toolkit.Wrappers; import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl; import com.vada.rfsplus.service.resource.common.ResourceConstants; import com.vada.rfsplus.service.resource.dto.CountOfResourceModule; import com.vada.rfsplus.service.resource.dto.NameOrLabelDTO; import com.vada.rfsplus.service.resource.entity.RfsResourceExpirationReminder; import com.vada.rfsplus.service.resource.mapper.RfsResourceExpirationReminderMapper; import com.vada.rfsplus.service.resource.service.RfsResourceChangeService; import com.vada.rfsplus.service.resource.service.RfsResourceExpirationReminderService; import org.apache.commons.lang3.StringUtils; import org.springframework.stereotype.Service; import javax.annotation.Resource; import java.util.*; import java.util.stream.Collectors; import java.util.stream.Stream; /** * &lt;p&gt; * 服务实现类 * &lt;/p&gt; * * @author lgz * @since 2022-05-24 */ @Service public class RfsResourceExpirationReminderServiceImpl extends ServiceImpl&lt;RfsResourceExpirationReminderMapper, RfsResourceExpirationReminder&gt; implements RfsResourceExpirationReminderService { @Resource private RfsResourceChangeService changeService; @Resource private RfsResourceExpirationReminderService expirationReminderService; @Override public IPage&lt;RfsResourceExpirationReminder&gt; listPage(IPage&lt;RfsResourceExpirationReminder&gt; page, RfsResourceExpirationReminder arg) { QueryWrapper&lt;RfsResourceExpirationReminder&gt; criterion = Wrappers.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df83e5c1d2d7c72169fa2dae71bb47b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ff82fbf55315fe486e0a1ba0d3fd454/" rel="bookmark">
			Baize_h1mini六足机器人零件准备
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		导航在这里： Baize_H1mini六足机器人制作教程（开源）_ros 六足机器人教程-CSDN博客 视频教程：手把手带你做开源六足机器人（3D图纸+硬件图纸+软件源码+制作说明书在视频下方自取！）_哔哩哔哩_bilibili 你现在在地图的红色字体位置（走到终点就制作完成了）：
重要提示：自己使用打印机打印零件时，对于新手来说肯定会由于参数设置问题将零件打废，因此要仔细配置参数确保参数正确。对于需要添加支撑的零件，一定要记得添加支撑。
首先要找到零件的图纸，打开我们刚刚下载的整个项目资料文件夹，找到如下路径1.3D model\Baize_HexapodRobot_Arduino_3DPrinter\STL Files，可以看到该文件夹下有很多可以打印的STL格式图纸，如下图2-2-1红框中所示：
接下来就可以开始打印了，完成之后的实物如下图所示：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc6a8dd51b0cb9c1b4d7270903598303/" rel="bookmark">
			编程软件大全(下载&#43;安装&#43;破解)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 软件目录 ①电脑办公电脑系统(U盘安装）PE系统Win7Win8Win10XP电脑系统（直接安装）Win7Win8Win10Officeoffice2003office2007office2010office2013office2016office2019Project/Visiovisio2003visio2007visio2010visio2013visio2016visio2019project2019AcrobatAcrobat 9 ProAcrobat XI ProAcrobat DC ②室内/外设计CAD3dsMaxPhotoShopVraySketchupLumion天正（建筑、暖通、给排气、电气、结构）SketchBook ③平面设计PhotoShopillustratorIn DesignlightroomACDSeeBridgeSAI ④机械设计CADSolidworksPro/E Creo
AdaqusUnigraphics NXMastercamCatiaRhinoMatlabAdamsInventor ⑤影视动画 PremiereAfter EffectsMedia Encoder3Ds MAXMayaC4DAudition ⑥建筑设计3Ds MAXSketchupRevit(BIM)Civil3DNavisworksPowerMill ⑦网页设计 Dreamweaver
Flash/AnimateXD Axure RP
⑧屏幕录像屏幕录像专家 ⑨开发编程 VB6.0
VC++6.0eclipse AndroidStudio
MyEclipse10MyEclipse2017 Sublime Text3LabVIEWKeilVisual StudioVS2008VS2010VS2012VS2013VS2015VS2017VS2019JDKjdk软件大全PyCharmPyCharm3.4PyCharm4.0PyCharm4.5PyCharm5.0PyCharm2017PythonPython2.X.XPython3.XX其他AnacondaUnity3DIDEAWebStormQuartus ⑩电子绘图 Altium Designer
Multisim
Proteus
Eplan
⑪数据分析 SQL Server
MySQL
SPSS
R语言
Minitab
⑫理科工具LingoOriginMathematica ⑬虚拟机VMware8VMware11VMware12VMware14VMware15 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6de3e1f8523f0adb388d13c6996053f/" rel="bookmark">
			【HIKROBOT】海康机器人：工业相机SDK二次开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		海康机器人：工业相机SDK二次开发 引言1 软件安装步骤1.1 SDK安装1.1.1 Ubuntu18.04系统安装1.1.2 Windows 11 系统安装 1.2 打开软件1.3 软件功能说明 2 python+opencv：二次开发SDK2.1 相机控制步骤2.1 主代码GrabImage_opencv.py 引言 海康机器人官网链接：https://www.hikrobotics.com/cn
根据购买设备的型号下载用户说明书
笔者实验室购买了两款，一款GigE网口接口的，一款USB接口
GigE网口接口
USB接口：MV-CA050-20UC
1 软件安装步骤 1.1 SDK安装 服务支持”&gt;“下载中心”&gt;“机器视觉”中下载MVS客户端安装包及SDK开发包。
1.1.1 Ubuntu18.04系统安装 下载安装压缩包，并解压
查看README如下：
安装包对应的操作系统 arm架构64位系统： MVS-2.1.2_aarch64_20221024.deb MVS-2.1.2_aarch64_20221024.tar.gz arm架构32位系统： MVS-2.1.2_armhf_20221024.deb MVS-2.1.2_armhf_20221024.tar.gz MVS-2.1.2_arm-none_20221024.tar.gz x86架构64位系统： MVS-2.1.2_i386_20221024.deb MVS-2.1.2_i386_20221024.tar.gz x86架构32位系统： MVS-2.1.2_x86_64_20221024.deb MVS-2.1.2_x86_64_20221024.tar.gz 说明：
树莓派选armhf架构，jetson选aarch64，pc机选x86_64，i386是32位pc。
armhf和aarch64区别就是armhf是armv7架构，如树莓派。aarch64是armv8架构，如jetson nano。
arm-none只有Samples，没有编译好的bin，也没有dpkg包，海康也没有提供源码，所以用不上。
1. 根据系统名称选择相对应的安装包：在终端中输入“uname -a”命令，根据输出的信息选择安装包，例如：输出的信息包含aarch64就选择aarch64的安装包； 2. .deb安装包通过dpkg命令安装，主要应用于ubuntu等系统； 3. .tar.gz安装包是一个压缩包，通tar命令解压后，再执行setup.sh脚本进行安装。 实际安装：
方法1：
根据自己的系统选择解压相应的压缩包，打开INSTALL查看安装步骤
To install the MVS Camera Software Suite in /opt/MVS # 软件安装目录 follow these steps: 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6de3e1f8523f0adb388d13c6996053f/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/72/">«</a>
	<span class="pagination__item pagination__item--current">73/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/74/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>