<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e928eec40c55b2918cf33f5c966b0b20/" rel="bookmark">
			github上面所有图片无法加载出来
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述如下： github上面所有图片无法加载出来……
解决方案： 感恩参考如下：
https://blog.csdn.net/qq_38232598/article/details/91346392
修改host文件,终端中：
sudo gedit /etc/hosts 将下面复制到host文件中：
# GitHub Start 140.82.113.3 github.com 140.82.114.20 gist.github.com 151.101.184.133 assets-cdn.github.com 151.101.184.133 raw.githubusercontent.com 151.101.184.133 gist.githubusercontent.com 151.101.184.133 cloud.githubusercontent.com 151.101.184.133 camo.githubusercontent.com 151.101.184.133 avatars0.githubusercontent.com 199.232.68.133 avatars0.githubusercontent.com 199.232.28.133 avatars1.githubusercontent.com 151.101.184.133 avatars1.githubusercontent.com 151.101.184.133 avatars2.githubusercontent.com 199.232.28.133 avatars2.githubusercontent.com 151.101.184.133 avatars3.githubusercontent.com 199.232.68.133 avatars3.githubusercontent.com 151.101.184.133 avatars4.githubusercontent.com 199.232.68.133 avatars4.githubusercontent.com 151.101.184.133 avatars5.githubusercontent.com 199.232.68.133 avatars5.githubusercontent.com 151.101.184.133 avatars6.githubusercontent.com 199.232.68.133 avatars6.githubusercontent.com 151.101.184.133 avatars7.githubusercontent.com 199.232.68.133 avatars7.githubusercontent.com 151.101.184.133 avatars8.githubusercontent.com 199.232.68.133 avatars8.githubusercontent.com # GitHub End OK!
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f097ab8562fbfa72e5c961842ce773b/" rel="bookmark">
			ValueError: need more than 2 values to unpack
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述：
binary, contours, hierarchy = cv2.findContours(mask, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)
ValueError: need more than 2 values to unpack
解决方案：
感恩参考如下：https://blog.csdn.net/weixin_39755659/article/details/90106846
在新版的OpenCV中cv.findContours()返回的值为2个，OpenCV3的返回值为3个，而赋值的变量为三个，所以将代码中的赋值变量变为两个，如下：
问题解决！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1cbc84d8fe12a73c139f53748bd7cc7/" rel="bookmark">
			[Leedcode][JAVA][第76题][最小覆盖子串]滑动窗口]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【问题描述】[第76题][最小覆盖子串][中等] 给你一个字符串 S、一个字符串 T，请在字符串 S 里面找出：包含 T 所有字符的最小子串。 示例： 输入: S = "ADOBECODEBANC", T = "ABC" 输出: "BANC" 说明： 如果 S 中不存这样的子串，则返回空字符串 ""。 如果 S 中存在这样的子串，我们保证它是唯一的答案。 【解答思路】 1. 滑动窗口 map 时间复杂度：O(N^2) 空间复杂度：O(1)
class Solution { public String minWindow(String s, String t) { if (s == null || t == null || s.length() == 0 || t.length() == 0) return ""; // 定义一个数字，用来记录字符串 t 中出现字符的频率，也就是窗口内需要匹配的字符和相应的频率 int[] map = new int[128]; for (char c : t.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f1cbc84d8fe12a73c139f53748bd7cc7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41c309101272e58008fa385c2f2096ff/" rel="bookmark">
			Spring Batch示例– MySQL数据库到XML
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在本教程中，我们将向您展示如何使用JdbcCursorItemReader和JdbcPagingItemReader从MySQL数据库读取数据，并将其写入XML文件。 使用的工具和库 Maven 3 Eclipse 4.2 JDK 1.6 Spring Core 3.2.2。发布 Spring OXM 3.2.2。发布 Spring Batch 2.2.0。发布 MySQL Java驱动程式5.1.25 PS此示例– MySQL jdbc（读取器）– XML（写入器）。 1.项目目录结构 查看最终项目结构，这是一个标准的Maven项目。 2.数据库 “用户”表仅包含5条记录，以后使用jdbc读取它。 users table id, user_login, password, age '1','mkyong','password','30' '2','user_a','password','25' '3','user_b','password','10' '4','user_c','password','25' '5','user_d','password','40' 3.物品阅读器 创建一个行映射器以将数据库值映射到“用户”对象。 User.java package com.mkyong; public class User { int id; String username; String password; int age; //... getter and setter methods } UserRowMapper.java package com.mkyong; import java.sql.ResultSet; import java.sql.SQLException; import org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/41c309101272e58008fa385c2f2096ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/892bbe70400dff8a91e990cd8893b736/" rel="bookmark">
			Unable to mount 63 GB Volume
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题描述：Unable to mount 63 GB Volume
将U盘插入笔记本后，得到如下提示：
解决方案：
感恩参考下面的作者：http://mycllab.com/blog/%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%8064gb%E5%8D%A1%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9Aunable-to-accessmount-64-gb-volume/
运行如下：
sudo apt-get install exfat-fuse exfat-utils 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25769c03cb4072c0a0536067ea26a48c/" rel="bookmark">
			【菜鸟笔记】实际地址、物理地址、逻辑地址和有效地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		菜鸟笔记 最近学习微机原理和接口技术，再一次重温了物理地址、逻辑地址等概念，但是仍对于这些概念有许多不理解，所以将他们记录下来，以备未来温习
概念 物理地址：物理地址就是存储器实际上的地址，是内存单元的绝对地址，例如你有一个4G的内存条，物理地址0x0000就表示内存条的第一个存储单元，0x0010就表示内存条的第17个存储单元，而不管CPU内部怎么处理地址，最终访问的都是物理地址。
实际地址：物理地址的别称，就是存储器实际上的地址。
逻辑地址：逻辑地址由两个16位地址分量组成，段地址和偏移量，一般会这样表示–&gt;段地址：偏移量。是应用程序角度看到的内存单元地址。 不同于物理地址（physical address），通过地址翻译器（address translator）或映射函数可以把逻辑地址转化为物理地址。
线性地址：CPU在保护模式下，“段基址+段内偏移地址”叫做线性地址，注意，保护模式下段基址寄存器中存储的不是真正的段基值（和实模式的含义不一样），而是被称为“段选择子”的东西，通过段选择子在GDT（全局描述表）中找到真正的段基值。另外，如果CPU在保护模式下没有开启分页功能，则线性地址就被当做最终的物理地址来用，若开启了分页功能，则线性地址就叫虚拟地址（在没开启分页功能的情况下线性地址和虚拟地址就是一回事）。但是，如果开启分页功能，虚拟地址（或线性地址）还要通过页部件电路转换成最终的物理地址。
有效地址：有效地址（EA）即偏移地址（偏移地址=偏移量）。有效地址可以由几部分组成：基址寄存器内容、变址寄存器内容、比例因子和位移量。
参考：
通俗理解CPU中物理地址、逻辑地址、线性地址、虚拟地址、有效地址的区别
微机中的实际地址、物理地址、有效地址、逻辑地址之间的区别
扩展阅读：
浅析逻辑地址与物理地址映射关系
有效逻辑地址所对应的物理地址
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c76019ba75e3b82c6c7a59d8b559b3cf/" rel="bookmark">
			Laya学习笔记-05textInput
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、laya.ui.textInput中所有的API参数： 二、代码实现单行输入 export default class TextInputCrtl extends Laya.Script { constructor() { super(); /** @prop {name:name, tips:"提示文本", type:Node, default:null}*/ this.xx=null; } onAwake() { this.createSingleInput(); } createSingleInput() { var inputText=new Laya.TextInput(); inputText.size(700, 200); inputText.x =576; inputText.y =459; // 移动端输入提示符 inputText.prompt = "Type some word..."; // 设置字体样式 inputText.bold = true; inputText.bgColor = "#666666"; inputText.color = "#ffffff"; inputText.fontSize = 20; Laya.stage.addChild(inputText); } } （运行效果）
三、代码实现多行输入 export default class TextInputCrtl extends Laya.Script { constructor() { super(); /** @prop {name:name, tips:"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c76019ba75e3b82c6c7a59d8b559b3cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2b3665528390b02b6e2875140e3d4d2/" rel="bookmark">
			Ubuntu16.04中修改文件名时遇到sftp error #2:No sucn file
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、右键Rename失败 在向服务器上传了一个大文件后，由于文件名带着中文字符，在MobaXterm中显示的是乱码，右键Rename的时候，报错sftp error #2:No sucn file
2、使用mv命令进行重命名 mv命令是move的缩写，可以用来移动文件或者进行文件改名（move (rename) files），是Linux系统下常用的命令，经常用来备份文件或者目录。
例如：mv 原文件名 修改后的文件名
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c60a617711da8a10a7e0bfc6b86e0ed/" rel="bookmark">
			电脑无缘无故不停的重启，究竟是人性的扭曲还是道德的沦丧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前两年网上有一个段子，就是电脑出现什么问题重启就可以，但是如果电脑一直重启就是你所遇到的问题那该怎么办？
经过小编的学习和总结电脑不停的重启而起不起来大概有这几个方面的原因：
第一 遇到这种情况首先我们所要去寻找原因的点就是电源问题，如果电脑自动重启，有一半的可能电源出问题了，电压不稳定，造成供电不足。这时候解决的方法就是换一个新的电源。
第二 可能是由于主板上的内存插槽和内存之间接触不良造成的，这样你需要内存拨出现在的内存，然后用橡皮擦擦对准金手指的地方擦一下或者吹一吹，主要目的是做一个灰尘的清洁。或者做一个更换问题就会迎刃而解了。
第三 重启的原因和散热情况有关系。这可能是你的CPU温度过高，电脑风扇不工作，电脑温度降不下来，当温度达到主板的设定温度，主板启动保护，就自动重启了，知道了造成的原因解决方法也自然出现了。你只要将风扇恢复自动工作使CPU的温度降下来就可以了。
第四 常见的情况是：显卡的显存集成块存在虚焊，造成加电后，和主板接触不良，就会自动重启，处理方法就是：就是给显存加焊才可以解决，或者换显卡。
第五 重启的原因就是，恭喜你中奖了。你的电脑中了病毒从而破坏了引导区和系统，就会反复重启了，解决这个问题的方法就是修得引导区，这样的话就必须要重新安装一下系统。
这几个就是电脑不断重启时我们所能使用的方法了希望给你真的帮助。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d17ab6fc8d7839ba5500ab908bbc1f7/" rel="bookmark">
			深入了解Go Slice（一）—— make的详细处理过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 数组（Array）是一个由固定长度的特定类型元素组成的序列，一个数组可以由零个或多个元素组成。因其长度的不可变动，数组在Go中很少直接使用。作为替代是Slice（切片），它是可以增长和收缩的动态序列，Slice功能也更灵活，在Go中有着广泛使用。
关于Slice的使用有很多文章已经介绍了，本系列文章无意再重复介绍使用过程，主要专注于了解Slice的结构及底层的处理逻辑，从源码的角度加深对使用的了解，解决一些常见的使用错误点。
本系列文章涉及到的builtin/builtin.go的func或Go的关键字都是在编译期间进行处理，这些调用过程在cmd/compile/internal/gc包下，其处理细节大多复杂。为简化细节，文章会使用部分reflect包中的代码来说明处理逻辑。reflect需要在runtime时重新构建出相关的Type、Value，其与直接调用的处理过程可能并不完全一致，但处理逻辑是一致的，因为两者操作的结果是一致的。
reflect内的func仅用来说明处理逻辑，实际使用builtin内的type/func或者Go关键字，都需要在编译时进行处理。
概念 先从一个问题开始热身：
以下哪个变量的类型是Array？哪个是Slice?
var a [10]int b := make([]int,10) c := a[5:9] 定义 A slice is a data structure describing a contiguous section of an array stored separately from the slice variable itself. A slice is not an array. A slice describes a piece of an array.1
以上定义来自Go官方博客关于slices相关机制的说明，大致意思如下：
Slice是一种数据结构，描述与Slice变量本身分开存储的Array的连续部分。 Slice不是Array。Slice描述了Array的一部分。
类型与声明 Array的类型：
[len]Type
Slice的类型：
[]Type
声明变量时如下：
var a [10]int// Array b := make([]int,10)// 直接声明Slice 结构 Slice由3部分组成：指针、长度和容量，指针指向的底层数组，长度是当前容纳的数据长度，容量是能容量数据的最大长度。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d17ab6fc8d7839ba5500ab908bbc1f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b60c937f042bc86f8e1fd35ea02dca0/" rel="bookmark">
			找最大值及其下标。在一维整型数组中找出其中最大的数及其下标。。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		找最大值及其下标。 在一维整型数组中找出其中最大的数及其下标。 函数接口定义：
int fun(int *a,int *b,int n); 其中形参a 、b、n都是用户传入的参数。函数fun的功能是在指针a所指向的一维数组中找出其中最大的数及其下标，下标存到指针b所指的变量里，函数返回最大值。
裁判测试程序样例：
#include&lt;stdio.h&gt; #define N 10 int fun(int *a,int *b,int n); int main() { int a[N],i,max,p=0; for(i=0;i&lt;N;i++) scanf("%d",&amp;a[i]); max=fun(a,&amp;p,N); printf("max=%d,position=%d\n",max,p); return 0; } /* 请在这里填写答案 */ 输入样例：
2 1 5 4 8 4 5 8 9 1
输出样例：
max=9,position=8
答案：
int fun(int *a,int *b,int n){ int i,max,d; max=a[0]; for(i=0;i&lt;N;i++) if(a[i]&gt;a[i+1]) { max=a[i]; d=i; } *b=d; return max; } 最近在学习java，顺便复习c语言基础，不会的地方欢迎评论~我会解答的 QAQ
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3122d3616f5c9639e1a07435bfc05cb0/" rel="bookmark">
			统计专业人数。本题要求实现一个函数，统计学生学号链表中专业为计算机的学生人数。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		统计专业人数 本题要求实现一个函数，统计学生学号链表中专业为计算机的学生人数。链表结点定义如下： struct ListNode { char code[8]; struct ListNode *next; }; 这里学生的学号共7位数字，其中第2、3位是专业编号。计算机专业的编号为02。
函数接口定义：
int countcs( struct ListNode *head ); 其中head是用户传入的学生学号链表的头指针；函数countcs统计并返回head链表中专业为计算机的学生人数。
裁判测试程序样例：
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; struct ListNode { char code[8]; struct ListNode *next; }; struct ListNode *createlist(); /*裁判实现，细节不表*/ int countcs( struct ListNode *head ); int main() { struct ListNode *head; head = createlist(); printf("%d\n", countcs(head)); return 0; } /* 你的代码将被嵌在这里 */ 输入样例：
1021202
2022310
8102134
1030912
3110203
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3122d3616f5c9639e1a07435bfc05cb0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4423b2732c4a58e95f00138a1e1490da/" rel="bookmark">
			记录Docker安装与Docker中Jenkins安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Docker安装 使用的yum方式安装
1.1 先安装工具包 提供依赖
yum install -y yum-utils 1.2
1.3
【继续更新】
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc55e92647295e99fb439623d7698ece/" rel="bookmark">
			干货！K8S之5种控制器详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、概述二、有状态、无状态服务区别三、Deployment控制器四、SatefulSet控制器五、DaemonSet控制器六、Job控制器七、CronJob 控制器 一、概述 Pod控制器：又称之为工作负载，由master的kube-contriller-manager组件提供，常见的有：
DeploymentStatefulSetDaemonSetJobCronJob
Pod对象的管理通常是有某种控制器的特定对象来实现的，包括其创建、删除及重新调度等。 二、有状态、无状态服务区别 无状态：
1）deployment 认为所有的pod都是一样的
2）不用考虑顺序的要求
3）不用考虑在哪个node节点上运行
4）可以随意扩容和缩容
有状态
1）实例之间有差别，每个实例都有自己的独特性，元数据不同，例如etcd，zookeeper
2）实例之间不对等的关系，以及依靠外部存储的应用
三、Deployment控制器 部署无状态应用管理Pod和ReplicaSet具有上线部署、副本设定、滚动升级、回滚等功能提供声明式更新，例如只更新一个新的Image应用场景：web服务 更新策略：
滚动更新：旧控制器的Pod数量不断减少，同时新控制器的Pod不断增加，具有以下两个属性:
maxSurge：最多扩容内容是原本的百分之多少 maxUnavailabe：最多缩减内容是原本的百分之多少 灰度发布：在第一批新的Pod资源创建完成后立即停止更新，然后筛选小部分用户的请求路由至新版本的Pod应用，并持续观察其是否能够稳定地按期望的方式运行。确定没有问题就继续滚动更新，否则立即回滚更新操作。
四、SatefulSet控制器 部署有状态应用kind：service解决Pod独立生命周期，保持Pod启动顺序和唯一性稳定，唯一的网络标识符，持久存储（例如：etcd配置文件，节点地址发生变化，将无法使用）有序，优雅的部署和扩展、删除和终止（例如：mysql主从关系，先启动主，再启动从），有序，滚动更新应用场景：数据库 常规service和无头服务区别
service：一组Pod访问策略，提供cluster-IP群集之间通讯，还提供负载均衡和服务发现。Headless service 无头服务，不需要cluster-IP，直接绑定具体的Pod的IP 官方案例：https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/
五、DaemonSet控制器 在每一个Node上运行一个Pod新加入的Node也同样会自动运行一个Pod应用场景：Agent官方案例（监控）
https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
六、Job控制器 Job分为普通任务（Job）和定时任务（CronJob）一次性执行应用场景：离线数据处理，视频解码等业务 官方案例：https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
七、CronJob 控制器 周期性任务，像Linux的Crontab一样。应用场景：通知，备份 官方案例：https://kubernetes.io/docs/tasks/job/automated-tasks-with-cron-jobs/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff2c5b11ddd64b4c107bc4aa3820103f/" rel="bookmark">
			解决 安装cuda时“E: 无法修正错误，因为您要求某些软件包保持现状，就是它们破坏了软件包间的依赖关系”      问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决“E: 无法修正错误，因为您要求某些软件包保持现状，就是它们破坏了软件包间的依赖关系。” 打开软件和更新
点击“更新”，并选中其中的重要安全更新，“推荐更新” 和“不支持的更新”，主要勾选前两个，然后点右上角×，然后点击更新，
然后等待更新完毕后，输入
sudo apt-get -y install cuda 发现没有报错
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32a3d256ff53a41d231000a397d74a23/" rel="bookmark">
			SpringMVC中获取前端数据的三种基础方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面 本文记录并分享一下在SpringMVC中，接收前端请求的参数的三种比较基础的方法。
下面以学生登录功能为例，后端接收前端传来的数据并返回结果。
PS：Student类与StudentService类已经写好，不在这里展示了。
基础方法1 通过@RequestParam注解依次获取参数
@RequestMapping("login") @ResponseBody public Map login(@RequestParam("sID") String sID , @RequestParam("sPwd") String sPwd){ Student student = new Student(sID , sPwd); int result = studentService.login(student); Map&lt;String,User&gt; resultMap = new HashMap&lt;&gt;(); resultMap.put("result",result); return resultMap; } 基础方法2 当Student类中包含了sID与sPwd属性，并有相应的set与get方法时，可以直接接受Studnet对象。
注意此时不需要加@RequestParam注解！
@RequestMapping("login") @ResponseBody public Map login(Student student){ int result = studentService.login(student); Map&lt;String,User&gt; resultMap = new HashMap&lt;&gt;(); resultMap.put("result",result); return resultMap; } 基础方法3 通过Map获取前端的参数集合。
实际在get参数之前需要判断接收的map里是否含有相应的key，这里就简单省略了。
@RequestMapping("login") @ResponseBody public Map login(@RequestParam Map map){ Student student = new Student(map.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/32a3d256ff53a41d231000a397d74a23/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6075c332f21f469bda39d930a819a1b/" rel="bookmark">
			跳跃游戏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目：给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个位置。
解题思路：从后往前，数组的倒数第二个元素(l-1)开始，如果能够到达最后一个元素(l)就截断，然后剩下的数组重复此过程。可以预知：如果能够到达最后一个位置，那么整个数组一定能够截取完，即最后l=0，时间复杂度O(n)。
func canJump(nums []int) bool { var l = len(nums) - 1 for i := l-1; i &gt;= 0; i-- { if nums[i]+i &gt;= l { l = i } } return l == 0 } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c8ae0a7e183d6b9494cf1603633f721/" rel="bookmark">
			我的大学三年
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		时光匆匆，岁月任然。三年的大学时光在青春的回忆中渐行渐远…
我们也渐渐退去了少年的稚嫩，多了几分成熟老练和担当。
曾经以为 大学四年的生活承载了青春最美的四年时光，可以在这段时光中尽情的挥洒激情和梦想。良师益友身边绕，满腹经纶自才华。。现在回头看看，也就剩下些许的回忆了。渐渐发现，曾经的信誓旦旦以及很多很多承诺几乎都没有实现，大学交的诸多朋友，能够交心的也是寥寥无几，坚定的学习信念也就剩下书柜中那几本只有期末前才会翻看的专业课本了。
也许并不是我一个人是这样，很多人的大学都是这样，来的后知后觉，走的悄无声息。回首过去的三年时光，我们把最美的三年过成了最狼狈的三年。
今夕未竟明夕催，秋风才往春风回 大学时光的匆匆是我们始料未及的，但是相比于之后的大二大三，我觉得大一的日子过得别样的充实与快乐，是这三年中相比较而言回忆最多最缓慢的，少了几分时间给予的仓促感。
2017的盛夏，伴随着六月的燥热，结束了高中三年的拼搏时光，也是从那时开始对于大学的一切都充满了好奇。
17年的金秋九月，抱着对大学生活的渴望走进了科大…硕大的校园，我想走遍他的每一个角落。一张张生疏的面孔组成了计科三班，无数陌生的面孔组成了计算机学院大一新生，还清楚的记得第一次班会上大家的自我介绍，羞涩又稚嫩。军训的苦累还是那样历历在目，但是却成了大一最美的回忆，夜晚的操场灯火通明，遍地的迷彩服中歌声此起彼伏。那种酣畅淋漓真的让人意犹未尽。
第一次团活，第一次班会，第一次班级的轰趴，第一次喜欢一个人，第一次被拒绝，大学很多的第一次都是发生在大一。大一也成了大学生活中最浓厚的一份回忆。数年后回忆自己的青春，这段记忆将是永远也抹不去的。
人生就是这样，经历了一些东西，总会留下点什么；就像那句话：“人生的每一段经历都是有用的”。
韶华不为少年留，恨悠悠，几时休？ 大二的我们，也许相比于大一的时候，少了几分稚嫩，多了几分对校园的熟悉。总感觉大一的时候我们是校园的客人，大二就成了主人，因此对于校园的好奇和尊敬便少了几分。大二的时光奔波于课堂之上和团委学生会办公室之中，生活少了大一的那种悠闲。转眼又是一年，感觉自己什么都没有留下。
我们都一样，都想把自己的生活过得丰富多彩。但是真正经历的时候却发现，自己也只能过成现在这样，无奈，感叹…
我生待明日,万事成蹉跎. 转眼间就是大三，这时候的生活，真的是度月入日，时间的匆匆让人害怕。后知后觉的我才发现，原来曾经充满憧憬的大学生活已经所剩无几。这时候的我们更多的便是对于时间流逝之快的感叹和对未来的迷茫了吧。一面是对于大学的不舍，一面是对于未来生活的恐惧，渐渐的，从这个时候我们的脸上少了曾经的笑容，更多的是嘴角微微颤抖和夜晚的无数个失眠。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da18c341c95c031b5ad9a49c55e208b7/" rel="bookmark">
			520表白——送她一片星空模拟
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#代码目标：模拟3D星空 #完整代码评论区留言或者发邮箱 from turtle import * from random import random,randint screen = Screen() width ,height = 1200,600 #画布长宽 screen.setup(width,height) #输入宽和高为整数时, 表示像素; 为小数时, 表示占据电脑屏幕的比例 。。。 。。。 printer = Turtle() printer.hideturtle() printer.penup() printer.color('white') 。。。 。。。 。。。 t = Turtle(visible = False,shape='circle') t.pencolor("white") #设置画笔的颜色 t.fillcolor("white") #设置图形填充颜色 t.penup() #抬起画笔 t.setheading(-90) #设置当前朝向角度 t.goto(width/2,randint(-height/2,height/2)) #把画笔移动到定点 stars = [] for i in range(300): star = t.clone() #当前海龟的位置处克隆出另一只位置方向等属性相同的海龟，并且取名叫star s =random()/3 if s&gt;0.01 and s&lt;0.03: star.pencolor("black") star.fillcolor("black") elif s&gt;0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da18c341c95c031b5ad9a49c55e208b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/586aa10fade8a558c619ce6305a9294d/" rel="bookmark">
			520表白——每天都是爱你的一天
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		# coding=utf-8 #（完整代码评论区留言，或者发邮箱） import turtle from datetime import * # 抬起画笔，向前运动一段距离放下 def Skip(step): turtle.penup() turtle.forward(step) turtle.pendown() def mkHand(name, length): # 注册Turtle形状，建立表针Turtle turtle.reset() Skip(-length * 0.1) # 开始记录多边形的顶点。当前的乌龟位置是多边形的第一个顶点。 turtle.begin_poly() turtle.forward(length * 1.1) # 停止记录多边形的顶点。当前的乌龟位置是多边形的最后一个顶点。将与第一个顶点相连。 turtle.end_poly() # 返回最后记录的多边形。 handForm = turtle.get_poly() turtle.register_shape(name, handForm) 。。。 。。。 。。。 。。。 def Date(t): y = t.year m = t.month d = t.day return "%s年%d月%d日" % (y, m, d) def Tick(): # 绘制表针的动态显示 t = datetime.today() second = t.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/586aa10fade8a558c619ce6305a9294d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29596cfb78b4d0e41f034022ba1d11cd/" rel="bookmark">
			安装脚本文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#echo "\033[33mif the dependence file is not exist, show the error and write the log to install-apollo.log. But still continue the install \033[0m" &gt; ${LOGfile}
#echo "yellow color is successful flags" &gt; $LOGfile
#echo "red color is error flags" &gt;&gt; $LOGfile
#Do you want to continue? [Y/n]
#Press [ENTER] to continue or ctrl-c to cancel adding it
echo " ";
echo " ";
echo -e "\033[31;46mPlease make sure that you have installed CUDA and nvidia driver before running!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29596cfb78b4d0e41f034022ba1d11cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a8762b1fe9e6a85e5cc04e3fed86a04/" rel="bookmark">
			CT影像数据(nrrd文件和dicm文件)的读取和预处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说点题外话：最近参加了一个学院老师的创新项目（其实早就参加了，咸鱼划水到了现在才动 ），内容是使用机器学习算法对肾癌CT影像数据进行预测，所以就有了第一步–数据预处理（给自己挖了一个大大的坑 ），就一个数据预处理代码我写了一个多星期，我也是服了我自己了。数据保密，大家就不要想找我要数据了，我是不会给的，这个博客只是用来记录一下我的惨淡经历。
数据处理过程中遇到的坑：
1、由于自己第一次接触医学，第一次用代码实现CT数据预处理，所以都是从网上现学现用，从如何读入 n r r d nrrd nrrd文件到学长教我如何实现 d i c m dicm dicm文件数据的有效读入（这里面涉及到的知识点我忘记了，我还傻乎乎的调用了 p y t h o n python python读 d i c m dicm dicm文件的库函数，后来学长指出我的错误，索性我就直接用了学长的读 d i c m dicm dicm文件的函数），注意是需要归一化操作的。
2、一开始我基本实现了功能之后我就没管挂机了，后面我组长（和我一起进行数据预处理工作，她要是有博客的话我就@她了，一个超好看的妹子 ），比对结果图和用软件打开的原图时发现有很大的问题（遇事不要慌，有问题就解决问题 ），切出来的肾癌部分完全对不上，而且纹路也不对，然后我就陷入了无穷的调 b u g bug bug中，但是始终不知道哪错了，其实现在回想起来当时应该发现第3条里面的错误的，但是并没有（因为自己懒 ），于是尝试失败！
3、之后向学长汇报结果，请教学长时，学长跟我们（我和前面提到的组长妹子）说，图片横纵坐标是反的，然后从 n r r d nrrd nrrd文件对应的 d i c m dicm dicm索引不是正向对应的，而是反向的（不是 i i i到 i i i的，而是 i i i到 l e n − 1 − i len-1-i len−1−i的），我幡然醒悟，原来我是这里没注意啊，赶紧又是滚回去调 b u g bug bug。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a8762b1fe9e6a85e5cc04e3fed86a04/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29f9c3597be60469068756e01d1f0732/" rel="bookmark">
			ArcGIS一直处于Loading Document或者加载文档中可能的原因之一
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.适用场景 在公司或者连着公司的vpn时ArcMap打开很快，一回家就很卡，断网时又好了。卸载、重装、删注册表、删除模板等都不起作用。
2.解决办法 删除公司的打印机
2.1win10删除打印机方法 1.在设置中找到设备
2.找到公司的打印机，删除
3.原因 ArcMap依赖系统默认的打印机，在加载文档时，会去连接默认的打印机。但是在家且有网时，无法连接到公司的打印机，但是ArcMap会去不断的尝试，这个过程会耗费很长的时间。本人通过Google找到原因，地址：https://community.esri.com/thread/61771
原文如下图所示：
翻译如下：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6227d957ceebd65cedee55f3e816e63/" rel="bookmark">
			ArcEngine遍历面（Polygon）中的所有环（Ring）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ArcEngine中内环和外环的定义方式如下图所示（来在AE帮助文档）
具体代码实现： public static List&lt;IRing&gt; PolygonToRings(IPolygon polygon) { IPolygon4 polygon4 = polygon as IPolygon4; //获取外部环 IGeometryBag exteriorRingBag = polygon4.ExteriorRingBag; IGeometryCollection exteriorRings = exteriorRingBag as IGeometryCollection; List&lt;IRing&gt; rings = new List&lt;IRing&gt;(); //对外部环遍历 for (int i = 0; i &lt; exteriorRings.GeometryCount; i++) { IGeometry exteriorRing = exteriorRings.get_Geometry(i); rings.Add(exteriorRing as IRing); //获取当前外环的内部环 IGeometryBag interiorRingBag = polygon4.get_InteriorRingBag(exteriorRing as IRing); IGeometryCollection interiorRings = interiorRingBag as IGeometryCollection; for (int j = 0; j &lt; interiorRings.GeometryCount; j++) { IGeometry interiorRing = interiorRings.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c6227d957ceebd65cedee55f3e816e63/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/463b6139b2b1962c0611645cdf526225/" rel="bookmark">
			idea 同时debug启动两个项目，简单粗暴的教程！！！！！！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先当你在idea启动两个debug项目的时候，往往另一个成功，另一个会报一个类似错误：Unable to open debugger port (127.0.0.1:51325): java.net.SocketException "socket closed"。
解决方案：Ctrl + Alt +S - Debugger中，选中shared memory （共享内存）。
然后就是修改端口，和JMX port把其中的一个项目的随意改下就行了。
基本到这里就可以直接运行项目了但是！！！！！！！！！
还会报一个这样的错没想到吧！！！！！！！！！
Error running 'tomcat': Invalid arguments : Already listening [timeout, name]
这个错误呢是因为另一个idea里的tomcat的名字没有修改，所以报这个tomcat已经被监视了不能启用。修改名字就好了，这样子就可以启动两个tomcat项目了。
顺带解释一下，什么叫内存共享，简单点说就是在同一个tomcat的webapps里面运行了两个war包。。。。。。。。。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05f469413fcbb92196d5f43564029473/" rel="bookmark">
			git push报错：ssh: Could not resolve hostname -: Name or service not known
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用git pull拉取一下远程仓库的代码,然后再使用git push即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a02d5524d581ebcb0b9d011e594d7f6b/" rel="bookmark">
			详解Java中的数组异常问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		详解Java中的数组异常问题 1.打印数组
// 格式一：数组类型 数组名[]=new 数组类型[] double[] ds = new double[5]; int[] arr = new int[3];// 表示定义了一个长度为3的数组，数组里面只能放int类型的数据 // 打印数组 System.out.println(arr);// [I@15db9742，输出的是数组在内存中的地址 System.out.println(ds);// [D@6d06d69c 1.1异常解释：输出【I@15db9742】，表示输出的是数组在内存中的地址； *正常打印方法如下： 打印数组中的内容：Arrays.toString(数组名) // 打印数组中的内容：Arrays.toString(数组名) System.out.println(Arrays.toString(ds)); System.out.println(Arrays.toString(bs)); System.out.println(Arrays.toString(sts)); 2.获取数组的长度 数组名.length
// 格式三：数据类型[] 数组名 = new int[]{值1,值二,....，值n}; String[] books = new String[] { "诛仙", "坏蛋是怎样练成的", "昆仑", "雪中悍刀行" }; // 获取数组的长度 数组名.length System.out.println(books.length); 3.获取数组中的最后一个元素：数组名[数组名.length-1] // 获取数组最后一个元素 数组名[数组名.length-1] System.out.println(books[books.length - 1]); 3.1假如误用了：数组名[数组名.length]获取最后宇哥元素，则会出现以下异常：
ArrayIndexOutOfBoundsException： ****：【ArrayIndexOutOfBoundsException】表示：数组下标下标越界 或访问了数组不存在的元素；
解决异常的方法： **数组的下标都是从零开始的，最后一个元素应该是.length-1，所以我们只需要修改length为length-1即可正常运行； 4.遍历数组:
也就是将数组中的元素逐个访问到
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a02d5524d581ebcb0b9d011e594d7f6b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e603e667602e5135713c235b997ebc17/" rel="bookmark">
			如何在Hibernate中调用存储过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在本教程中，您将学习如何在Hibernate中调用存储过程。 MySQL存储过程 这是一个MySQL存储过程，该过程接受股票代码参数并返回相关的股票数据。 DELIMITER $$ CREATE PROCEDURE `GetStocks`(int_stockcode varchar(20)) BEGIN SELECT * FROM stock where stock_code = int_stockcode; END $$ DELIMITER ; 在MySQL中，您可以使用call关键字简单地调用它： CALL GetStocks('7277'); 休眠调用存储过程 在Hibernate中，有三种方法可以调用数据库存储过程。 1.本机SQL – createSQLQuery 您可以使用createSQLQuery（）直接调用存储过程。 Query query = session.createSQLQuery( "CALL GetStocks(:stockCode)") .addEntity(Stock.class) .setParameter("stockCode", "7277"); List result = query.list(); for(int i=0; i&lt;result.size(); i++){ Stock stock = (Stock)result.get(i); System.out.println(stock.getStockCode()); } 2.注解中的NamedNativeQuery 在@NamedNativeQueries批注中声明存储过程。 //Stock.java ... @NamedNativeQueries({ @NamedNativeQuery( name = "callStockStoreProcedure", query = "CALL GetStocks(:stockCode)", resultClass = Stock.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e603e667602e5135713c235b997ebc17/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f40d80350363b2f8456869794443857/" rel="bookmark">
			一步步教你SSM框架整合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、SSM框架整合思路二、整合环境搭建1、创建数据库和表结构2、引入依赖3、编写实体类4、编写dao接口5、 编写service接口 三、Spring框架代码的编写1、applicationContext.xml的配置文件，编写具体的配置信息2、使用注解配置业务层和持久层3、测试 Spring 能否独立运行 四、Spring整合Spring MVC框架1、在web.xml中配置DispatcherServlet前端控制器2、在web.xml中配置DispatcherServlet过滤器解决中文乱码3、 创建springmvc.xml的配置文件，编写配置文件4、测试Spring MVC的框架搭建是否成功（1）编写index.jsp和list.jsp（2）创建AccountController类，编写方法，进行测试 5、整合Spring 和 Spring MVC（1）、 在web.xml中配置监听器实现启动服务创建容器（2）、在controller中注入service对象，调用service对象的方法进行测试 五、Spring整合MyBatis框架1、编写SqlMapConfig.xml的配置文件2、在AccountDao接口的方法上添加注解，编写SQL语句3、编写测试代码4、整合 Spring 和 MyBatis（1）Spring 接管 MyBatis 的 Session 工厂（2）配置自动扫描所有 Mapper 接口和文件（3）配置 Spring 的事务 六、测试 SSM 整合结果1、编写jsp页面2、修改service和controller3、测试结果 一、SSM框架整合思路 1、 搭建整合的环境
2、把Spring的配置搭建完成
3.、再使用Spring整合SpringMVC框架
4.、最后使用Spring整合MyBatis框架
即以Spring框架为核心，整合Spring MVC和MyBatis。
二、整合环境搭建 1、创建数据库和表结构 create database ssm; use ssm; create table account( id int primary key auto_increment, name varchar(20), money double ); 2、引入依赖 &lt;properties&gt; &lt;spring.version&gt;5.0.2.RELEASE&lt;/spring.version&gt; &lt;slf4j.version&gt;1.6.6&lt;/slf4j.version&gt; &lt;log4j.version&gt;1.2.12&lt;/log4j.version&gt; &lt;mysql.version&gt;5.1.6&lt;/mysql.version&gt; &lt;mybatis.version&gt;3.4.5&lt;/mybatis.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f40d80350363b2f8456869794443857/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57900921715b43637972217bb342bacd/" rel="bookmark">
			表格固定第一行，且增加横向与竖向滚动条
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;title&gt;表格固定第一行，且增加横向与竖向滚动条&lt;/title&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;style type="text/css"&gt; .th{ width: 120px !important; text-align: center; } .container{ overflow-x: auto; width: 360px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="container"&gt; &lt;!--此处722px，是由于border有1px，加上两边的总共有722px，这样保证内容720px，才能使两个表格对齐--&gt; &lt;table style="width: 722px;" border="1" cellspacing="0" cellpadding="0"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th class="th"&gt;序号&lt;/th&gt; &lt;th class="th"&gt;姓名&lt;/th&gt; &lt;th class="th"&gt;性别&lt;/th&gt; &lt;th class="th"&gt;住址&lt;/th&gt; &lt;th class="th"&gt;电话&lt;/th&gt; &lt;th class="th"&gt;.......&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;/table&gt; &lt;div style="width: 722px;overflow-y: auto;height: 200px !important;overflow-x: hidden;"&gt; &lt;table style="width: 722px;" border="1" cellspacing="0" cellpadding="0"&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57900921715b43637972217bb342bacd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97826f6e09f2efb4f019324aa0ee0b3f/" rel="bookmark">
			3.1对偶变量法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		统 计 实 验 及 R 语 言 模 拟 \color{#0000FF}{统计实验及R语言模拟} 统计实验及R语言模拟 第 3 章 方 差 缩 减 方 法 \color{#0000FF}{ 第3章 方差缩减方法} 第3章方差缩减方法 代码如下：
#——————————————————————————3.方差缩减方法——————————————————————# ##——————————————————————3.1对偶变量法—————————————————————————## ### [例3.1] set.seed(1) n &lt;- 1000 x1 &lt;- runif(n) mu.e &lt;- mean(x1) sigma2.e &lt;- var(x1) / n mu.e sigma2.e ### 产生与x1完全负相关的随机数 x2 &lt;- 1 - x1 x &lt;- (x1 + x2) / 2 mu.avm &lt;- mean(x) sigma2.avm &lt;- var(x) / n mu.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/97826f6e09f2efb4f019324aa0ee0b3f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22f8df517e3762c9429f5586c3953e93/" rel="bookmark">
			Pthon.习题二 字符串的基本处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Pthon.习题二 字符串的基本处理
1.给定一个字符串"www.moe.gov.cn"，编写程序，实现如下功能。
（1）输出第一个字符
（2）输出前三个字符
（3）输出后三个字符
（4）输出字符串的总长度
（5）输出字符"o"在字符串中第一个位置的索引值（可使用index()的方法）
（6）输出字符"o"出现的总次数（可使用count()方法）
（7）将字符串中所有的".“替换为”-"并输出
（8）将字符串中所有的字母全部转换为大写字母并输出
（9）删除字符串中的标点符号，把字符串拆分为四个字符串
a="www.moe.gov.cn" print(a[0]) print(a[0:3]) print(a[-3:]) print(len(a)) print(a.index("o")) print(a.count("o")) print(a.replace(".","-")) print(a.upper()) print(a.split(".")) 2.编写程序，自动生成宿舍的组合名。从键盘上依次输入自己和室友的中文名，把所有名字的最后一字取出来并拼在一起，作为宿舍的组合名，然后输出。（假设有三个室友）
a=input("我的名字是:") b=input("第一个室友的名字是:") c=input("第二个室友的名字是:") d=input("第三个室友的名字是:") n=a[-1]+b[-1]+c[-1]+d[-1] print("我们的组合是:",n) 3.编写程序，实现月份数字向英文缩写转换。从键盘上输入一个表示月份的数字（1~12），输出对应的英文缩写，不同月份对应的缩写：1月为Jan，2月为Fab，3月为Mar，4月为Apr，5月为May，6月为Jun，7月为Jul，8月为Aug，9月为Sep，10月为Oct，11月为Nov，12月为Dec。
moths="JanFebMarAprMayJunJulAugSepOctNovDec" n=input("请输入月份数1~12:") pos=(int(n)-1)*3 mothAbbrev=moths[pos:pos+3] print("{}月对应的英文缩写是:".format(n),mothAbbrev) 4.编写程序，实现货币的转换。从键盘上输入人名币的币值，转换为美元的币值并输出，结果2位小数。假设人民币兑换美元的汇率是0.1456。
rmb=input("请输入想转换的人民币币值，以￥结束:") mei=float(rmb[0:])*0.1456 print("{}元人民币可以兑换{:.2f}美元".format(float(rmb[0:]),mei)) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37ba32319df29a289278527df95da69e/" rel="bookmark">
			C&#43;&#43;之类和对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		给大家讲解下我学习C++的经验；
那就是不要看太多理论之后再去实践，有人觉得不懂不就应该先看会才行吗，不不不，编程是门实践课，曾经我的导师跟我说这的知识你在书本上是看不会的，当你动手操作才能学会，我实际学起来才发现导师说的非常对。
出错了，按照错误去学习，该怎么写比直接看定义好太多太多（当然不是不让你看，是你只需要看一个框架，具体的细节你要在错误中获取）
就说类，网上书上知识点很多，那我就直接跟大家说你该怎么写，该注意什么。（之后的学习过程我还会补充）
通用结构
从下面的结构上你要看出几个点，第一个点就是class，class是一个关键字表示你是要写一个类，classname是你要定义的类的名字，另一个点非常重要就是最后的分号’ ;’ 千万不要忘记写，很容易忘。 class classname{ }; 类中的访问修饰符public (公有成员) ,private （私有成员） protected（保护成员） class Base { public: // 公有成员 protected: // 受保护成员 private: // 私有成员 }; 几个要注意的点
这三个修饰符在一个class中你可以写多个
class Base { public: // 公有成员 protected: // 受保护成员 private: // 私有成员 public: // 公有成员 public: // 公有成员 }; 完全可以这么写；
然后知道结构了之后你就要了解三个修饰符都是干嘛用的
public的成员可以随意访问，private的成员是除了类内函数和友元函数之外不可访问，而protected成员可private一样但是可以让派生类访问。
private的写法;
#include &lt;iostream&gt; using namespace std; class Box { public: double length; void setWidth( double wid ); double getWidth( void ); private: double width; }; // 成员函数定义 double Box::getWidth(void) { return width ; } void Box::setWidth( double wid ) { width = wid; } // 程序的主函数 int main( ) { Box box; // 不使用成员函数设置长度 box.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37ba32319df29a289278527df95da69e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2cd3ed6bc6ed33da973275767b1014a6/" rel="bookmark">
			java判断list中是否包含有某一元素
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在我的项目中，有很多地方会用到这一功能，在此将知识点记录一下：
List 有一个叫contains的方法用来判断List中是否已经有这个值：
以下三种方式都可进行判断，原理如下：
1.List的contains(obj)方法
实际上，List调用contains(Object obj)方法时，会遍历List中的每一个元素，然后再调用每个元素的equals()方法去跟contains()方法中的参数进行比较，如果有一个元素的equals()方法返回true则contains()方法返回true，否则所有equals()方法都不返回true，则ontains()方法则返回false。因此，重写了Course类的equals()方法，否则，testListContains()方法的第二条输出为false。
2.Set的Contains(obj)方法
当调用HashSet的contains(Object obj)方法时，其实是先调用每个元素的hashCode()方法来返回哈希码，如果哈希码的值相等的情况下再调用equals(obj)方法去判断是否相等，只有在这两个方法所返回的值都相等的情况下，才判定这个HashSet包含某个元素。因此，需重写Course类的hashCode()方法和equals()方法。
3. Map中是否包含指定的Key和Value
在Map中，用containsKey()方法，判断是否包含某个Key值；用containsValue()方法，判断是否包含某个Value值。
注：跟List中的Contains()方法一样，Map中的ContainsValue()方法也需要调用某个Value值的equals()方法，去和参数对象进行比较，如果匹配成功，返回结果为true，说明在Map中的Value值确实包含参数对象。因此，需要重写Student类的equals()方法。
程序员可以根据自己的实际情况进行选择。
原文链接：https://blog.csdn.net/weixin_38670122/article/details/80570956
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e225b64cf70295838aa77710f5572e9e/" rel="bookmark">
			Ghost Module/GhostNet：一种模型压缩的轻量级模块/网络(论文阅读)（1）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 温馨提示：（1）讲Ghost模块 （2）讲GhostNet，文章过于话多，快速理解内容只需看图
（2）GhostNet网络架构请看博客下篇
Ghost Module是一种模型压缩的方法，即在保证网络精度的同时减少网络参数和计算量，从而提升计算速度（speed），降低延时（latency）。Ghost 模块可以代替现有卷积网络中的每一个卷积层。基于Ghost模块，论文作者堆叠Ghost模块构建了GhostNet。
Ghost Module
模型提出的缘由：卷积输出的一组特征图在通道方向上，有部分通道内容相似。
比如下图是对Resnet-50某层输出的可视化，每张图代表一个通道，图中三组颜色相连的图非常相似。论文将一组中的一张图称为本征图（intrinsic），其他和本征图相似的图称为本征图的魅影（ghost）。那么，既然ghost和Intrinsic非常相似，我们是否可以通过一种相对简单的、计算量较少的运算代替运算量大的卷积操作生成ghost图？ghost模块就是基于这种想法，提出用简单的线性运算生成ghost，但总共的通道数（# intrinsic+ghost）以及生成特征图的大小和原来保持一致。
Ghost模块：生成ghost图的过程采用简单的线性运算Φ，代替原本的卷积操作。如下图所示，假设原始卷积操作中输入Input与n组k x k的Kernel卷积后生成通道数为n，尺寸为h’ x w’大小的输出。在ghost模型中，我们用m组k x k的Kernel与input进行卷积，生成m x h’ x w’的本征图intrinsic，之后本征图进行线性变换Φ产生ghost图，将intrinsic和ghost一起作为输出。
线性变换Φ究竟是什么函数？原理上可以是仿射变化函数，小波变换等。但考虑到统一计算形式有利于硬件部署，现在的硬件架构有许多针对卷积的优化计算，论文中的Φ是depthwise conv。
m层intrinsic进行线性变化，每层的Φ是否相同，具体到depth wise conv运算就是指kernel的尺寸是否都相同？原理上，如下图所示，可以每层用不同的Φ1，Φ2……，但是，计算越不规整统一，硬件执行的效率越低。由此在论文中，Φ其实是相同的。具体到depthwise conv kernel的尺寸多少合适，这个超参数的值是做实验选出来的。 下图中可以看到，需要生成s-1组ghost图，使得ghost模块的输出和原始卷积输出的大小相同。S（或者说m）多少合适呢？这也是做实验选出来的。
模型压缩量定量计算
下面计算用一个ghost模块取代原始的一层卷积操作带来多少计算量、参数量上的优势。
加速比（rs：speed up ratio）：这里用计算量来近似代替速度。
压缩比（compression ratio）：
ghost模块效率验证
ghost模块可以替代现有神经网络架构中的卷积层。（区别于作者提出的GhostNet，前者以Ghost模块代替原有网络中卷积操作命名为ghost-xxnet，比如ghost-Resnet-50。而GhostNet是作者提出的一种网络架构）从下图的实验结果看来，相比于其他模型压缩方法，ghost 有出色表现。
特别说明：禁止转载，欢迎交流学习！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7fe20f169cbc3a45a312d6a362a4c6c2/" rel="bookmark">
			Qt错误：This application failed to start because it could not find or load the Qt platform plugin cocoa
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 运行程序报错：
objc[18135]: Class QMacAutoReleasePoolTracker is implemented in both /Users/zheyima/anaconda3/envs/IR_camera/lib/python3.6/site-packages/PyQt5/Qt/lib/QtCore.framework/Versions/5/QtCore (0x119b8f060) and /Users/zheyima/anaconda3/envs/IR_camera/lib/python3.6/site-packages/cv2/.dylibs/QtCore (0x125015700). One of the two will be used. Which one is undefined.
objc[18135]: Class QT_ROOT_LEVEL_POOL__THESE_OBJECTS_WILL_BE_RELEASED_WHEN_QAPP_GOES_OUT_OF_SCOPE is implemented in both /Users/zheyima/anaconda3/envs/IR_camera/lib/python3.6/site-packages/PyQt5/Qt/lib/QtCore.framework/Versions/5/QtCore (0x119b8f0d8) and /Users/zheyima/anaconda3/envs/IR_camera/lib/python3.6/site-packages/cv2/.dylibs/QtCore (0x125015778). One of the two will be used. Which one is undefined.
objc[18135]: Class KeyValueObserver is implemented in both /Users/zheyima/anaconda3/envs/IR_camera/lib/python3.6/site-packages/PyQt5/Qt/lib/QtCore.framework/Versions/5/QtCore (0x119b8f100) and /Users/zheyima/anaconda3/envs/IR_camera/lib/python3.6/site-packages/cv2/.dylibs/QtCore (0x1250157a0). One of the two will be used. Which one is undefined.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7fe20f169cbc3a45a312d6a362a4c6c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa6f3881f64a70c39690df0ee1b7ace1/" rel="bookmark">
			Ubuntu18.04解决蓝牙耳机无法连接问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ubuntu18.04解决蓝牙耳机无法连接问题 在连接蓝牙耳机时候，出现耳机可以检测到但是一点打开连接就断开的问题
已经解决但是不知道是那种方法解决的
因此本文提供两种思路
解决方法一：
首先点击右上角的蓝牙区域，选择蓝牙设置
然后点击设备，移除设备，然后再搜索连接。 解决方法二：
参考链接：https://qastack.cn/ubuntu/689281/pulseaudio-can-not-load-bluetooth-module
输入代码
尝试加载蓝牙模快出现： (base) wangfan@wangfanlinux:~$ sudo pactl load-module module-bluetooth-discover 失败：模块初始化失败 错误和可能的解决方案：实际上，我发现一个错误使耳机无法使用，似乎脉冲音频模块：module-bluetooth-discover仅在X11会话启动后才能启动。所以我有一个解决方法。
2 在su下编辑文件：
sudo gedit /etc/pulse/default.pa 并注释掉（#在行的开头）以下行：
#load-module module-bluetooth-discover 现在编辑文件： sudo gedit /usr/bin/start-pulseaudio-x11 然后在其中以下代码下面
if [ x”$SESSION_MANAGER” != x ] ; then /usr/bin/pactl load-module module-x11-xsmp “display=$DISPLAY session_manager=$SESSION_MANAGER” &gt; /dev/null fi 添加以下行：
/usr/bin/pactl load-module module-bluetooth-discover 这样，Pulse音频的蓝牙模块将不会在启动时下载，而是在x11启动后下载。
然后再移除设备后重新连接即可
连接成功
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a596d0fee516756ef2269d658e4acac2/" rel="bookmark">
			【图像超分辨】Densely Residual Laplacian Super-Resolution
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Densely Residual Laplacian Super-Resolution AbstractIntroductionNetwork ArchitectureCascading Residual on the ResidualDense Residual Laplacian Module ExperimentsConclusion Abstract 超分辨率卷积神经网络最近证明了能对单个图像进行高质量的还原。但是，现有算法通常需要非常深的架构和较长的训练时间。 此外，当前用于超分辨率的卷积神经网络无法利用多个尺度的特征并对其进行平均加权，从而限制了它们的学习能力。我们提出了一种紧凑而准确的超分辨率算法，即密集残差拉普拉斯网络（DRLN）。 所提出的网络在残差结构上采用级联残差，以允许低频信息流动从而专注于学习高级和中级特征。此外，我们提出了拉普拉斯人注意力来对关键特征进行建模，以学习特征图之间的层间和层内依赖性。
Introduction 本文的主要贡献：
我们提出了紧密连接的残差块和Laplacian注意力网络，以实现精确的图像超分辨率。 我们的网络通过多快捷连接和多级表示实现了更好的性能；我们新颖的设计在残差体系结构上采用了残差级联，可以帮助训练深度网络；我们提出力拉普拉斯注意力，主要有两个目的：1、学习多个子带频率上的特征。2、自适应地重新缩放特征和对特征依赖性进行建模。总的来说提高了特征的捕获能力； Network Architecture Cascading Residual on the Residual 在本节中，我们将提供有关残差结构上的级联残差的更多详细信息，该残差结构具有层次结构并由级联块组成。每个级联块都有一个中间跳过连接（MSC），级联特征是串联的，并且由密集的残余拉普拉斯模块（DRLM）组成，每个模块都由密集连接的残余单元，压缩单元和拉普拉斯金字塔关注单元组成。
Dense Residual Laplacian Module 这里建议直接看源码，里面有具体的卷积操作。
Experiments Conclusion 我们提出了一种用于高精度图像超分辨率的模块化卷积神经网络。 我们还采用各种组件来提高超分辨率的性能。 我们彻底分析并提出对我们网络设计选择的全面评估。
我们在残差结构上采用级联残差，以使用长跳过连接，短跳过连接和局部连接来设计大深度网络。 残差架构上的级联残差有助于低频信息流动，使网络学习高中频信息。 我们使用密集连接的残差块，这些残差块重新使用了先前计算的特征。 这种类型的设置具有多个优点，例如隐式的“深度监督”和从高级复杂功能中学习。 我们还将提出了拉普拉斯注意力，它可以在多个尺度上对基本特征进行建模，并学习特征图之间的层间和层间依赖性。
此外，我们对超分辨率数据集，低分辨率噪点图像和真实图像（未知的模糊降采样）进行了广泛的评估。 我们还显示了Bicubic内核和模糊内核的结果，以证明我们提出的方法的有效性。 此外，我们提出了通过不同方法对超分辨图像进行目标识别的性能。 我们已经说明了网络在图像超分辨率方面的潜力； 但是，我们的网络是通用的，可以应用于其他低级视觉任务，例如图像恢复，合成和转换问题。（言外之意就是泛化能力强）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/750b5a1a203b82b46d14127fd7565c2f/" rel="bookmark">
			使用canvas在图片上画矩形及文字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		效果图
上代码 &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div style="display: flex;"&gt; &lt;canvas id="myCanvas" width="520" height="720" style="border:1px solid #d3d3d3;"&gt; 这是浏览器不支持canvas时展示的信息 &lt;/canvas&gt; &lt;img id="img" width="400px" height="400px" /&gt; &lt;/div&gt; &lt;div&gt; &lt;input accept=".png,.jpg,.jpeg" type="file" id="file" onchange="myFile(file)" /&gt; &lt;button onclick="window.close()"&gt;关闭窗口&lt;/button&gt; &lt;/div&gt; &lt;script&gt; const img = document.getElementById("img") // 把图片转base64 function myFile(file) { const imgsize = file.files[0] const render = new FileReader() render.readAsDataURL(imgsize) render.onload = (e) =&gt; { // console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/750b5a1a203b82b46d14127fd7565c2f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2472dc09d1f2e98e70c5b582eb2db22b/" rel="bookmark">
			source insight 中文注释乱码原因及解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题现象 在我们使用source insight 查看代码时经常会出现中文乱码问题，严重影响我们的代码阅读体验。
网友提供的两种解决方案 方法一： 设置source insight 编码方式
单个文件乱码解决办法：
菜单栏中【File】 &gt; 【Reload As Encoding…】 &gt; 【Chinese Simplified (GB18030)】 &gt; 选择后，点击load，问题解决！！！
所有文件乱码解决办法：
菜单栏中 【Options】 &gt; 【Preferences】 &gt;File标签中，最下面的“Default encod­ing” ：改成System Default(Windows ANSI) 或者Chinese Simplified(GB2312) CP:936，点击确定，问题解决！！！
方法二： 在第一种方案未能成功实现目标时，可以尝试第二种方案。
以下内容为转载：https://cloud.tencent.com/developer/article/1417198
最近使用source insight查看一些开源代码，显示中文就乱码，据说是因为source insight不支持utf-8编码，默认编码方式为ANSI码。所以需要将utf-8等非ANSI码的文件转换成source insight默认支持的ANSI码格式才能显示中文不乱码。
解决方案如下：
一、单个文件转换
对于单个文件，好说，只要将非ANSI码格式的文件转换成ANSI码格式即可，方法如下：
1、将文件用ultraEdit32打开，选择 文件-&gt;转换-&gt;UTF-8到ANSI， 然后保存。重新用source insight打开就好了。
或者使用记事本打开非ANSI格式的源代码文件，另存为，在保存选项对话框中，在编码格式一栏中发现是UTF-8，选择ANSI一项，保存，再用Source Insight打开就可以正常显示中文注释了。具体可参考百度经验的一篇文章：source insight 中文乱码的解决方案。
2、借助Linux下的iconv命令
(1)关于iconv命令的用法，可以在Linux下的终端键入iconv --help或者iconv --usage来查看
可以参考这篇文章：http://www.firekyrin.com/archives/249.html
即可以使用iconv库函数（包含在glib中）和iconv命令来执行编码转换，即：
iconv -f utf-8 -t gb18030 file1.txt -o file2.txt
将utf-8编码的file1.txt文件转换成gb18030编码的file2.txt文件。
(2)使用Ruby脚本转换
参考这篇文章：使用Iconv将Utf-8转换成ASCII(on Linux)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2472dc09d1f2e98e70c5b582eb2db22b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7486b4c03ee07435111a620aef96b988/" rel="bookmark">
			将彩色图像变换到 YCbCr、 HSV 空间，熟悉各分量数据并显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eab1c587e800952764cb8de5fbbb8afb/" rel="bookmark">
			6个月计算机专硕408备考经验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 考研情况 一志愿：华东师范大学计算科学与技术学院计算机专硕。初试成绩：总分332，政治：70，英语二：67，数学二：95，408计算机综合：100。初试排名37。复试400分，总分=初试x0.7 +复试x0.3 = 352 ，最终排名43。招生人数：37 + 13 + 2 = 52人，考前统招37，复试前一次扩13人，拟录取后二次扩2人。2019年9月，专业课从839自命题改408全国统考。 个人情况 本科北京某双非一本大学，信息与计算科学专业（408四门课全都学过，但不是很精通）。班级排名2/66，绩点3.99/5.0。参加过多次数学建模竞赛，拿过校级二等、MathorCup三等奖。数学竞赛，北京地区二等、三等、全国（初赛）三等。校三好、优干、担任学院组织负责人之一。国家奖学金、校学习奖学金一等、二等两次、科创奖学金三等两次。项目：毕设论文（图像相似性判别算法），操作系统、计算机网络、数据库等课设。备考时间：上半年（只背了英语单词和过了四级），从7月开始正式复习（6个月）。每天复习10个小时，暑假：4h数学、4h专业课、2h英语。9月份后：3h数学、专业课 ，2h政治、英语每周休息一下午+晚上（打游戏解压），一周1-2次健身房（时间紧可以少去）。 择校 结合个人情况+专业排名+竞赛经历（复试会看）+学习能力+自律能力+本科数学和专业课成绩理智选择一志愿学校（不要头铁硬冲名校）。一般情况，本科双非冲211，本科211冲985。（在此基础上，本科成绩专业前5名的可以冲一冲更好的学校）。选择名校+非强势学科、文科类的理工科专业、师范类的理工科专业、新成立的学院和研究所、偏远地区的名校（例如东北、西北地区）。一般今年分数低的学校明天肯定炸、一般今年炸的学校明年会缓和很多（名校除外）。备考408 ，赌一波2021专业课从自命题改408的学校（分数线一般会降），自命题的学校越会来越少，因此非常建议考研计算机的学408（优点：复习资料多，出题规范，缺点：复习东西多、杂）。运气&gt;选择&gt;努力。 初试备考 关于如何复习，每个人的学习习惯和方式不同，具体方法因人而异。我只是简单介绍一下我个人的经验和心得还有总结出来比较适合我的学习方法。
本文主要备考内容：数学-zhang宇，英语-kaochong，政治-xu涛，408-王dao。
任课老师都会教你如何学习、复习、什么时间该做什么。
这些任课老师都十分风趣幽默，会让你想起高中时的老师，时不时讲讲笑话，给你备考缓解压力（王dao除外，就硬讲知识点）。
英语：（踏踏实实跟kaochong + 4000词至少20遍以上） 由于我基础不好（4级是在备考的时候才低分飘过473分），2019年上半年由于要上课还有学生活动，因此80%的备考时间都用在背单词+看kaochong四级课程的视频（只掌握核心的4000词就够了），前4000词背了20遍以上。然后做真题，精做2遍近十年的真题（kaochong会教如何做真题）。非常不建议英语上来就做真题的，跟着kaochong老师的安排走就行。
英语基础不好的，非常建议kaochong，支持正版，因为会邮寄讲义。英语基础好的，可以听听kaochong的做题技巧，掌握这些技巧+4000词，正常发挥70+，如果基础好可以更高。
时间安排：现在就开始，开始跟着kaochong的课程的，跟着直播走就行（一般我是不听直播，看录播可以倍速，但尽量跟着进度），老师声音好听，很逗。
政治：（跟着xu涛就完事） xu涛全家桶，干就完了。老师讲课非常非常非常有意思，还能学到很多哲理。
建议时间安排：
8月中旬可以开始，跟着老师走。
8月中旬听强化课，每天1-2小时。
听完强化课开始刷xu涛1000题和真题，结合视频讲解+做好笔记。
最后一两个月是最重要的，刷预测卷子+背。
专业课408：（四本书看10遍以上，你啥都会了） 王dao4大本 和后面的真题+模拟题（9、10月份mai）。第一遍先听课走一遍，然后做题，遇到不会的再回去翻书。把书上的解题视频mai了。408东西很多，复习方法就是重复重复重复。这四本书看10遍你就吃透了，真题和王dao课后题很重要，吃透它。408能110以上。
最有效的复习方法就是：重复重复重复+细致细致细致。
建议时间安排：现在就开始，越早越好。
4门课，根据自己的情况去安排学习顺序。假如你结构学的好，可以放在后面学，计组学的不好，先学计组。
王dao的课程视频（个人建议先听完全部章节，然后再逐章节做课后题）然后在书上标记错题，做好笔记。学习主要课程的时候，假如说现在学的是计组，之前已经学完了网络和结构，每天都花10-15分钟/科复习结构和网络的知识。（跟线代和高数一样，不能断了）
10月份之前能把四门课题都做完就很好了，然后反复的复习，回顾。然后10月中旬就可以做真题。
数学 （跟着宇哥，立即推：研究生） zhang宇一整套，看最新的课程2021版的，线代+高数全听zhang宇就完事，老师很逗。（我线代跟着李永乐，反正线代没拿到几分，可能我学的不太细致）
由于我是数学专业，觉得考研数学不是问题，结果教训还是很惨烈的（95分）。个人没听基础课，直接做的汤jiafeng的1800，然后后面换zhang宇闭关修炼，然后又1800…反正很乱，各个机构的出题风格不一样，不如全跟zhang宇，避免手忙脚乱。
踩的坑1.
刷了很多题（所有题都在笔记本上直接写，一共写了4个笔记本），到最后复习看都看不过来。所以最好做完一题，在书上记录关键步骤，把做错题的总结到一个错题本，后面复习时可以有针对性地复习（到后面复习真的很重要）。
踩的坑2.
高数和线代最好要不间断地学，不然很容易忘记的。重新捡起来会浪费很多时间。其他学科也是一样。我之前是一直刷高数题，然后把线代放一边了。刷完高数题后重新拿起线代书，基本上学过的全忘了，又重新学了一遍，又花了一个礼拜的时间。建议刷题高数和线代同时进行。时间分配按照分数占比来。
汤jiafeng1800
缺点是：题太多，做完要花很多很多时间（我花了2-3个月，每天3小时）。然后题型大部分都是真题稍微修改一下。做真题的时候会发现很爽，到真正考的时候就傻眼了（我就是），以后的考研数学只会越来越难，题海战术未必最有效，因此理解解题思路非常重要。
优点是：分为三部分，基础、提高、进阶。基础题相对比较简单，比较适合刚开始刷题时刷这些。提高题的题型和基础题类似，如果时间充裕可以刷，如果时间不太充裕的话，题型已经掌握的的可以跳过。
zhang宇1000题
缺点是：题目比较难、偏。第一遍做题很大概率没有思路，第一遍结合答案和讲解视频慢慢做，做好笔记、总结、培养自己的做题思路。然后自己再刷第二遍。
优点是：配套讲解视频全、题量适中1000题、对数学基础好的人提升比较大。
建议的时间安排：（简单的就是跟着zhang宇老师的时间安排走）
在暑假之前：把基础课程内容掌握，做好笔记结合着刷1000题（或者汤jiafeng1800基础篇）。
暑假期间 7-8月：刷1000题和听强化课。错题做好笔记，其他题标记关键步骤。（如果刚开始刷题比较费力，可以把汤jiafeng1800的基础题做了）。
开学9-10月：刷1000题第二遍（如果时间不够，可以选择性地刷），如果速度快可以做真题。
11月：真题1天1套，知识点回顾，看自己记的笔记。时间不够的话可以从2000年开始做。
12月：做模拟题，看笔记总结（很重要）。
复试机考 《suanfa笔记》在PTA上练吧，没编程基础的可能要疯狂练习2个月左右。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9dc497d3c1361ed5314164adbbd5422/" rel="bookmark">
			PTA-B 1035 插入与归并 (25分)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述 根据维基百科的定义：
插入排序是迭代算法，逐一获得输入数据，逐步产生有序的输出序列。每步迭代中，算法从输入序列中取出一元素，将之插入有序序列中正确的位置。如此迭代直到全部元素有序。
归并排序进行如下迭代操作：首先将原始序列看成 N 个只包含 1 个元素的有序子序列，然后每次迭代归并两个相邻的有序子序列，直到最后只剩下 1
个有序的序列。
现给定原始序列和由某排序算法产生的中间序列，请你判断该算法究竟是哪种排序算法？
输入格式 输入在第一行给出正整数 N (≤100)；随后一行给出原始序列的 N
个整数；最后一行给出由某排序算法产生的中间序列。这里假设排序的目标序列是升序。数字间以空格分隔。
输出格式 输入在第一行给出正整数 N (≤100)；随后一行给出原始序列的 N
个整数；最后一行给出由某排序算法产生的中间序列。这里假设排序的目标序列是升序。数字间以空格分隔。
输入样例1: 10
3 1 2 8 7 5 9 4 6 0
1 2 3 7 8 5 9 4 6 0
输出样例1: Insertion Sort
1 2 3 5 7 8 9 4 6 0
输入样例2 10
3 1 2 8 7 5 9 4 0
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f9dc497d3c1361ed5314164adbbd5422/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/610dc5331b8e9ed4033c49555cefec5e/" rel="bookmark">
			解决！连接Oracle时候出现oracle library is not loaded错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先确定一下你安装Navicat版本是否和你的win系统是否一致，如果Windows系统和Oracle的版本都是64位的那么你就下载64位的Navicat，是32位你的Navicat也要下载是32位，否侧会尝试各种错误，希望对你们有帮助！ ps：（我这里就是64位的系统安装了32位的Oracle，然后报各种蛋疼的问题）
连接Oracle时候出现oracle library is not loaded错误，一般来讲是因为oci.dll这个文件匹配不上Navicat。。。。。
匹配不上就得自己去Oracle官网下载了
链接：“http://www.oracle.com/technetwork/database/database-technologies/instant-client/downloads/index.html”
下载插件在这个页面下载和你数据库版本一致的instantclient，重要的是说3遍，
一定要和你的数据库版本一致......
一定要和你的数据库版本一致......
一定要和你的数据库版本一致.......
不知道自己数据库版本号的可以去安装路径找一下，或者输入sql：select * from v$version命令行也可找到：
我这里是安装在F盘版本是10.2.0
看好自己的系统是32位的还是64的，现在基本上都是64位系统了， 我一般下载软件基本都是64位的软件！
看你的 Navicat是64位的是就选择第一个Instant Client for Microsoft Windows (x64)的，你的Navicat是32位的就选择第二个Instant Client for Microsoft Windows (32-bit)，点击登录下载就可以了
然后选择与自己Orcale数据库匹配的“Instant Client”客户端版本如下： 在说一遍一定要和Orcale数据库版本对应上，不然插件不生效还是会报：oracle library is not loaded错误，我也不知道为什么。。。。。。
一定要勾选I reviewed and accept the Oracle License Agreement下载协议
登陆上就直接下载了！ 接下来就是配置了，解压下载好的Instant Client，文件放在那里都可以，打开Navicat 然后选择----&gt;工具---&gt;选项
然后重启Navicat！！！
然后重启Navicat！！！
然后重启Navicat！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/537e404d4f434617d99c1580c4be690d/" rel="bookmark">
			用C&#43;&#43;语言实现双端队列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.目的
基于双链表实现双端队列的典型操作（判空、头插、头删、尾插、尾删、普通构造、拷 贝构造、赋值运算符重 载、析构） 2.原理
双端队列头插：
双端队列尾插：
双端队列头删：
双端队列尾删：
3.代码
dlist.cpp
#include &lt;iostream&gt; using namespace std; template &lt;typename T&gt; class Dlist { public: bool isEmpty() const; //判空 void insertFront(T *o); //在表头插入元素 void insertBack(T *o); //在表尾插入元素 T *removeFront(); //删除一个表头元素 T *removeBack(); //删除一个表尾元素 Dlist(); //构造函数 Dlist(const Dlist &amp;l); //拷贝构造函数 Dlist&amp; operator=(const Dlist &amp;l); //"="运算符重载 ~Dlist(); //析构函数 private: struct Node { Node(){ //给指针赋初始值 this-&gt;next = NULL; this-&gt;prev = NULL; this-&gt;o = NULL; } Node *next; //指向下一个节点 Node *prev; //指向前一个节点 T *o; }; Node *first; //指向表头 Node *last; //指向表尾 void makeEmpty(); //建立一个空表 void removeAll(); //删除表中所有元素 void copyAll(const Dlist &amp;l); //将l表中的元素值拷贝到当前表 }; template &lt;typename T&gt; bool Dlist&lt;T&gt;::isEmpty() const //判空 { return first == NULL; } template &lt;typename T&gt; void Dlist&lt;T&gt;::insertFront(T *o) //在表头插入元素 { Node *new_node = new Node(); //定义一个新的节点 new_node-&gt;o = o; //给新节点赋初值，将要插入的值放入新节点 if(first == NULL) //当原表为空时，表明要插入的节点为表头 { first = last = new_node; } else{ //当原表不为空 first-&gt;prev = new_node; //将原表头的前指针指向新节点 new_node-&gt;next = first; //将新节点的后指针指向原表头 first = new_node; //让表头指向新节点 } } template &lt;typename T&gt; void Dlist&lt;T&gt;::insertBack(T *o) //在表尾插入元素 { Node *new_node = new Node(); //定义一个新的节点 new_node-&gt;o = o; //给新节点赋初值，将要插入的值放入新节点 if(first == NULL) //当原表为空时，表明要插入的节点为表头 { first = last = new_node; } else{ //当原表不为空 last-&gt;next = new_node; //将原表尾的后指针指向新节点 new_node-&gt;prev = last; //将新节点的前指针指向原表尾 last = new_node; //让表尾指向新节点 } } template &lt;typename T&gt; T* Dlist&lt;T&gt;::removeFront() //删除一个表头元素 { Node *new_node = NULL; //定义一个新的节点 T* p; if(NULL == first) return NULL; //如果表是空的则返回空 new_node = first; //让新指针指向表头 p = new_node-&gt;o; //保存表头元素值 first = first-&gt;next; //表头向后移一位 if(NULL !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/537e404d4f434617d99c1580c4be690d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f2c8ec1580296a7308264ef76b7b585/" rel="bookmark">
			HttpURLConnection  getContentLength值为-1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HttpURLConnection getContentLength值为-1 一个android项目有一个点击更新可以下载更新apk，在更新时需要显示一个进度，这里用：
URL url = new URL(downLoadPath); HttpURLConnection conn = (HttpURLConnection) url.openConnection(); conn.setRequestMethod("GET"); conn.setConnectTimeout(8 * 1000); conn.setReadTimeout(8 * 1000); conn.connect(); long length = conn.getContentLength(); 这样取得文件的总长度，结果发现conn.getConentLength()取到的值 为-1，查了一下有说设置 conn.setRequestProperty(“Accept-Encoding”, “identity”); 就可 了正常获取长度了，添加后值还是-1。
于是把downLoadPath,下载地址放在浏览器上下载可以成功下展，看他NetWork:
这图是我修改后的，修改前发现response里并没有content_lenght这个头信息，所以获取一直就是-1，然后去修改服务端，加上这个值：
resp.setHeader(“Content-Length”, String.valueOf(new FileInputStream(file).available()));
加上后便如上图所示可以发现头信息里有了contentLength这个值，然后客户端就可以成功获取了，下面展示一下详细代码
服务端
private void fileLoad(HttpServletRequest req, HttpServletResponse resp) throws IOException { String param = req.getParameter("param") == null ? "" : req.getParameter("param"); String callback = req.getParameter("callback") == null ? "" : req.getParameter("callback"); String filename = req.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f2c8ec1580296a7308264ef76b7b585/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/615d6a58ebe640862fc7b0f9e5cf596a/" rel="bookmark">
			【matlab】对添加噪声的总结，以及如何给多张图片添加相同的噪声
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、matlab自带的imnoise 注意：imnoise()用于强度介于0和1之间的图像，并且超出范围[0,1]的值将被剪切
噪声种类有：椒盐、高斯、泊松、随机等
参考： http://blog.csdn.net/Zhangcong2014/article/details/40404413?locationNum=4
https://blog.csdn.net/qq_38843532/article/details/90454559
在MATLAB中，可以使用imnoise函数给一幅图像添加噪声。
g = imnoise(f, type, parameters)
参数说明：
输出：g是添加噪声之后的图像。
输入：f是原图像，type是加入的噪声类型，parameters是噪声的一些参数。
概括地说，imnoise的函数原型为：g = imnoise(f, type, parameters)，注意这个只是一个概括性的函数原型，因为parameters根据噪声种类的不同可以指定多个值，也可以指定一个值。所以真正可以直接调用的函数原型是下面的这些函数接口。
g=imnoise(f，‘gaussian’，m，var)是将均值为m，方差为var的高斯噪声加到图像f上。m的默认值是0，var默认值是0.01。
g=imnoise(f，‘salt &amp; pepper’，d)给图像f添加椒盐噪声，其中d是噪声密度（即包含噪声值的图像区域的百分比）。因此，大约有d*numel（f）个像素受到污染，默认的噪声密度为0.05。
g=imnoise(f，‘speckle’，var)用方程g=f + n*f将乘性噪声添加到图像f上，其中n是均值为0、方差为var的均匀分布的随机噪声。var的默认值为0.04。
椒盐噪声也称为脉冲噪声，是图像中经常见到的一种噪声，它是一种随机出现的白点或者黑点，可能是亮的区域有黑色像素或是在暗的区域有白色像素（或是两者皆有）。盐和胡椒噪声的成因可能是影像讯号受到突如其来的强烈干扰而产生、类比数位转换器或位元传输错误等。例如失效的感应器导致像素值为最小值，饱和的感应器导致像素值为最大值。
当噪声类型是 ‘salt &amp; pepper’ 注意空格的位置 ，较严格
当噪声类型是’salt &amp; pepper’的时候，第三个参数的意思是噪声密度，比如0.1，那么总像素个数的10%为黑白点，**是黑点还是白点都是随机的。**对我的需求不适用
另外用matlab里特定的函数imnoise 所生成的椒盐噪声的数值是 0和 255 ，**1、**如果想要值是 0~100之间的 34，可以把生成的数字乘一个系数，34/255；**2、*对于0255区间的数值转换到ab 令 生成数（b-a）/255+a 就行了
参考：https://www.ilovematlab.cn/thread-133585-1-1.html
2、自己写代码，构造随机点 可参考https://blog.csdn.net/weixin_44225182/article/details/100898895
这位作者是对jpg图像进行处理的，我这边需要对bmp图像进行处理，不适用
3、被忽略的一种最简单方法——利用rand/randn 产生指定方差和均值的随机数
设某个随机变量x均值为mu，方差为var2，若要产生同样分布的随机变量y，但使新的随机变量参数改变，均值为mu_1，方差为var_12，可以用如下公式进行变换：y=var_1/var*(x-mu)+mu_1，其中x为随机变量，其余为常数（原分布参数）。具体到正态分布，若要产生均值为u，方差为o^2的MN的随机数矩阵，可以用
y=orandn(M,N)+u得到。对于均匀分布，若要产生[a,b]区间的均匀分布的MN的随机数矩阵，则可以用
y=rand(M,N)(b-a)+a得到。
%=========================================%
rand产生的是[0，1]上的均匀分布的随机序列randn产生均值为0，方差为1的高斯随机序列，也就是白噪声序列；
%=========================================%
也就是说，可以直接使用上面两个函数对原始信号添加噪声（例如y=x+rand(length(x),1)或者=x+randn(length(x),1)）
————————————————
原文链接：https://blog.csdn.net/u011650143/article/details/74358296 randn函数产生高斯随机噪声
randn(N,1)就是产生服从方差为1，均值为0 （ 即N(0,1) ）的Gaussian分布的NX1随机噪音矩阵，
根据Gaussian概率密度函数的特性，
产生均值为5，标准差为0.05的Gaussian分布的NX1随机噪音矩阵：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/615d6a58ebe640862fc7b0f9e5cf596a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1cae3da09d67d396b730ae00e021a957/" rel="bookmark">
			Dart sdk 安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Dart SDK安装 1、下载Dart SDK安装包 Dart SDK安装包网址：
https://gekorm.com/dart-windows/
其中有两个可选择项，一个是稳定版本一个是最新的版本，二者选其一
我们选择稳定的版本即stable版本
下载完成并点击运行
安装中
点击finish，安装完成
2、在控制台中检验是否安装成功 若出现版本号则安装成功
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c896eac2a84ba609eb9e53a2e800242/" rel="bookmark">
			【汽车总线技术】CAN FD与CAN网络共存的解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.CAN FD发展的背景介绍 随着总线技术在汽车电子领域越来越广泛和深入的应用，特别是自动驾驶技术的迅速发展，汽车电子对总线宽度和数据传输速率的要求也越来也高，传统CAN（1MBit/s，8Bytes Payload）已难以满足日益增加的需求。
因此在2012年，Bosch发布了新的CAN FD标准 (CAN with Flexible Data Rate) ，CAN FD继承了CAN的绝大多数特性，如同样的物理层，双线串行通信协议，基于非破坏性仲裁技术，分布式实时控制，可靠的错误处理和检测机制等；同时CAN FD弥补了CAN在总线带宽和数据长度方面的不足。
2015年6月30日，国际标准化组织（ISO）已经正式认可CAN FD，并无反对票通过ISO 11898-1作为国际标准草案。
2.CAN FD简介 2.1CAN FD的报文结构 CAN FD在控制场中新引入了三个位：
EDL位（Extended Data Length），原CAN数据帧中的保留位r， 该位功能为：
隐性： 表示 CAN FD 报文 （采用新的 DLC 编码和 CRC 算法
显性： 表示 CAN 报文
BRS位（Bit Rate Switch）：该位功能为：
隐性：表示转换可变速率
显性：表示不转换速率
ESI位（Error State Indicator）：该位的功能为：
隐性：表示发送节点处于被动错误状态（Error Passive）
显性：表示发送节点处于主动错误状态（Error Active)
另外，CAN FD采用新的DLC编码方式，控制场有四个位组成了数据长度码（DLC），DLC包含了扩展的有效数据长度；有效数据长度可能为12，16，20，24，32，48和64个字节，如图2所示。
2.2CAN FD提高通信速率的方法 CAN FD提高通信速率主要是两种方法：一是提高波特率；二是提高有效载荷。
2.3CAN FD的优势 基于背景所述以及如上关于报文结构和提高通信速率的方法的说明，我们可以总结出一些CAN FD的优势：
该协议能够支持更高的速率，可以更快的刷写ECU；在单个数据帧内传送率可达64字节，避免了经常发生的数据分拆传输的状况；对汽车行业而言，CAN-FD协议显得非常重要，CAN线束和其它物理层面元件可重新再利用；更高的带宽，在电动车以及今后的动力CAN上应用更有优势上层应用层架构不需要改变，在原来基础上扩展即可。 3. CAN与CAN FD通信的问题 因为受制于产品的稳定性考验，改造成本等问题，没法快速全面普及CAN FD。另外，在2012年底提出CAN FD到2015年中成为ISO CAN FD。也就是说目前市场上大部分都还是在用传统的CAN2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c896eac2a84ba609eb9e53a2e800242/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3eb83c26481de335661620ed98c9c5c5/" rel="bookmark">
			Android四大基本组件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		所有的Android应用都是由以下四大组件组成的：
Activity、BroadcastReceiver、Service、ContentProvider
Activity(活动) Activity是最基本的Android应用程序组件，应用程序中，一个Activity通常就是一个单独的屏幕。每个Activity都被实现为一个独立的类，并且从Activity基类继承而来， Activity类会提供视图控制组件的用户接口，并对事件作出响应，大多数应用程序都是由多个Activity组成的。
BroadcastReceiver（广播消息接收器） BroadcastReceiver 是Android系统中常用的一种机制，用户让应用对一个外部的事件作出响应。例如：当电话呼入时，数据网络可用时等
Service（服务） 一个服务是具有一个较长生命周期且没有用户界面的程序。例如：一个正在从播放列表中播放歌曲的媒体播放器。
ContentProvider（内容提供者） 应用程序能够将它们的数据保存到文件、SQLite数据库中，甚至是任何有效的设备中。当需要将当前应用数据与其它应用共享时，ContentProvider类实现了一组标准方法，从而能够让其它的应用保存或读取此ContentProvider处理的各种数据类型。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/433/">«</a>
	<span class="pagination__item pagination__item--current">434/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/435/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>