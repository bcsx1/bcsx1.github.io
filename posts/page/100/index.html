<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f26ff871c072d8bf8fcf6b9bdf450bad/" rel="bookmark">
			Android LiveData原理之-setValue和数据倒灌原理分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一图胜万言，直接上图吧！有需要的同学们可以对着这张泳道图阅读源码，相信能够快速加深理解。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d29f0c88f9f05733cc514ff0c3ac667/" rel="bookmark">
			指向二维数组的指针
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、认识指向二维数组的指针 定义一个整型的二维数组：
int a[3][4]={{0,1,2,3},{4,5,6,7},{8,9,10,11}};
指向这个二维数组的指针定义为：
int (*p)[4]=a;
来理解下 int (*p)[4] 这个定义形式：[]的优先级高于*，所以需要是 int (*p)[4] 而不是 int *p[4]（这种形式为指针数组）。 int (*p)[4]即：*p表示这是一个指针，剩余的部分 int[4] 可以理解为一维数组，即a中所包含数据的类型。即这个指向二维数组的指针还可以理解为指向几个一维数组的指针。
2、使用指向二维数组的指针 那么怎么通过 int (*p)[4] 实现对a的使用呢？
p+i 表示指向第 i 行整行数据（从第零行开始）
*(p+i) 表示取第 i 行整行数据，也表示指向第 i 行的首地址
*(p+i)+j 表示指向第 i 行第 j 个数据的地址
*(*(p+i)+j ) 表示取第 i 行第 j 个数据的值
3、理解指向二维数组的指针 这个需要一层一层的理解，首先 p 是指向了二维数组 a 第零行的整行数据，即 a 中的{0，1，2，3}，如果对 p 进行加减，那么所指的行数将发生变化，比如：p+1 指向了第一行，相应的 *(p+1) 就是对所指的第一行取数据，但要注意的是，取数据取的是整行的数据，但取整行的数据又没有意义，所以编译器会把取整行的数据转换为取行的首地址，例如 *(p+1) 就是取第一行第零个数据的地址，即 4 的地址。如果要取第一行第零个数据的数值，则需要再加一个 * ，即：**(p+1)。
如果我要取第一行第一个数据的值呢？书接上回， *(p+1) 表示的是取第一行第零个数据的地址，那么我再加1，就能实现在第一行第零个数据偏移一位，即 *(p+1)+1 就是取第一行第一个数据的地址，再加 *，就实现了取数值，即 *(*(p+1)+1) 就代表了数字5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d29f0c88f9f05733cc514ff0c3ac667/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb403bec8b0b1c706192997f016d219c/" rel="bookmark">
			（已解决）PySpark ： AttributeError: ‘DataFrame‘ object has no attribute ‘iteritems‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 AttributeError: ‘DataFrame’ object has no attribute ‘iteritems’
原因在使用SparkSession对象中createDataFrame函数想要将pandas的dataframe转换成spark的dataframe时出现的
因为createDataFrame使用了新版本pandas弃用的iteritems()，所以报错
解决办法，把pandas还原成老版本
# 卸载新版本 pip uninstall pandas # 安装老版本 pip install pandas==1.5.3 -i https://pypi.tuna.tsinghua.edu.cn/simple 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d961642f8d8ffecb27ad70ceea1a828e/" rel="bookmark">
			VS Code 运行输出中文时，出现‘‘菱形问号?‘‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		发现这个问题的时候，我当即就去VS Code官网查解决办法
可全都是在代码输入过程显示乱码的解决方法
后来，在某Q群论坛进行讨论，终于也是有了结果
下面我来帮助有上述现象的朋友
一，添加系统变量
打开设置&gt;系统&gt;系统信息
点击 相关链接&gt;高级系统设置
点击高级&gt;环境变量...
在系统变量栏上点击新建(注意不是用户变量)
变量名：PYTHONIOENCODING 变量值：UTF8
点击所有确定以保存 二，重启VS Code
再次输出
完美解决！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67e02a4c7436788543b0716c0a1004fa/" rel="bookmark">
			CSS高度塌陷解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		高度塌陷的解决方案：
1. 给塌了的元素写oveflow:hidden;
弊端：oveflow:hidden;的本意是超出隱藏，如果将来这个子盒子里
2•在塌陷的盒子最后面创建一个空标签，写一个行内样式：做一下清除浮动即可
弊端：创建了空标签了，造成标签过多，代码冗余。
3.万能清除法
•clear fix:tafter{
content: "":
display: block:
width: 0;
height: 0;
overflow: hidden;
visibility: hidden;
clear: both;
]
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cec009bcc48d8639a89b408a0d34c69d/" rel="bookmark">
			关于ubuntu实现启动自动挂载硬盘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境 ubuntu 20
使用场景 对硬盘进行启动自动挂载
步骤1 查看需要挂载硬盘的uuid 可使用命令 lsblk -f root@192-168-19-133:~# lsblk -f NAME FSTYPE LABEL UUID FSAVAIL FSUSE% MOUNTPOINT sda ├─sda1 vfat 9A7E-2AE4 511M 0% /boot/efi ├─sda2 ├─sda3 ext4 newexpand cde06c91-959e-4391-99c5-56543e280365 5.2G 68% /media/zgxt/newexpand ├─sda4 ext4 rocfile ddbb123a-ff0c-4dcb-be8d-bde58fc6b4fc 65.3G 40% /media/zgxt/rocfile └─sda5 ext4 77fba3cf-7e03-4471-bedc-07d263822b33 12.8G 73% / 步骤2 进行挂载 编辑 /etc/fstab # /etc/fstab: static file system information. # # Use 'blkid' to print the universally unique identifier for a # device; this may be used with UUID= as a more robust way to name devices # that works even if disks are added and removed.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cec009bcc48d8639a89b408a0d34c69d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8e0b9dca77acb98b3f0f9d3e33e9724/" rel="bookmark">
			大语言模型之三 ChatGPT训练过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大语言模型 GPT历史文章中简介的大语言模型的的发展史，并且简要介绍了大语言模型的训练过程，本篇文章详细阐述训练的细节和相关的算法。
2020年后全球互联网大厂、AI创业公司研发了不少AI超大模型（百亿甚至千亿参数），典型代表是NLP领域的GPT-3，LlaMA，视觉领域的DALL*E2，Stable Diffusion以及V-MoE。现有的生成式AI工具大部分基于大厂研发的预训练模型，用针对特定场景的小数据进行Fine-Tune的模式快速迭代。
DALL-E2：DALL-E2是OpenAI在2021年提出的一种图像生成模型，它基于GPT-3的预训练模型，并使用自注意力机制来处理输入图像。DALL-E2可以生成高质量的图像，并且可以根据文本描述来生成图像。
Stable Diffusion：Stable Diffusion是Facebook AI Research在2021年提出的一种图像生成模型，它基于扩散过程和随机微分方程，并使用自注意力机制来处理输入图像。Stable Diffusion可以生成高质量的图像，并且可以进行无监督学习和控制生成图像的样式。
ChatGPT的训练过程分为如下四个步骤：
1.预训练（pretrain）模型是基于海量未人工标注的自监督学习模型，因为从互联网上爬虫的数据并没有经过清洗，因而网络上一些虚假信息、阴谋论、偏见以及常识错误都会被模型训练得到，因而通常称这一阶段的模型为预训练模型；
2.然后用更高质量的数据上微调预训练模型，这些高质量的数据，诸如StackOverflow、Quora、Wikipedia、百度百科以及人类标注等，这使得模型尽量少的输出有害、无用的等内容。
3.然后使用RLHF对模型进一步调节，使其更加符合特定的应用需要。
在上面模型训练的三个步骤中，第一步的预训练（Pretraining)模型占用了绝大多数的算力和数据，根据OpenAI官网数据，InstructGPT在预训练模型阶段占用了98%（https://openai.com/research/instruction-following）的算力和数据。可以将SFT和RLHF视为解锁预训练模型已经具有但用户很难仅通过提示访问的功能。所以第二步的SFT和第三步的RLHF本质上并没有赋予模型新的能力，而是将不好的能力封印起来，把好的、需要的能力解锁出来。
第一阶段 预训练 预训练模型的产物是大语言模型，比如GPT-x (OpenAI), Gopher (DeepMind), LLaMa (Meta)。
语言模型编码了语音的信息，在一个特定的上下文中，不同字/词出现的概率是不一样的，语言模型的任务是预测下一个词。可以把语音模型看成是填词任务，给定提示（Prompt），补充下文。
Prompt (用户输入):今天天气真好，我打算出去逛街， 补充 (语言模型): 去买买衣服和包包。 这看起来是一件很简单的事情，但确实非常强大的功能，其可以完成翻译、总结、写代码、做算术题、写文案等等，比如给定Prompt：How are you in Chinese is …，语言模型的补全会输出 你好吗，这就是实现了翻译功能。
预训练的数学化的表示 训练数据：未标注低质量数据
数据规模：在写这篇文章时，大语言模型使用的训练数据的token在万亿数量级，按照现在大模型预训练数据集的增速，几年之后网上公开的数据大概率可以被头部企业爬完。到那时数据维度的优势将是私有数据带来的。
GPT-3（OpenAI）数据集token规模，使用的是0.5万亿，GPT-4未公开LlaMA-1（Meta）数据集的token规模在1.4亿，LlaMA-2使用了2万亿token预训练。 公式描述：
L L M ϕ LLM_{\phi} LLMϕ​：待训练大语言模型，其中 ϕ \phi ϕ是参数，训练的目标是得到交叉熵损失最小的参数集 ϕ \phi ϕ； [ T 1 , T 2 , … , T V ] [T_1, T_2, …, T_V] [T1​,T2​,…,TV​]：词汇表，训练集中token的总数，GPT-2（OpenAI）的词汇表是50257。LlaMA-1和LlaMA-2的词汇表数量都是32000。 V V V:是词汇表的大小。对于LlaMA-1/LlaMA-2都是32000。 f ( x ) f(x) f(x):将token映射到其在词汇中的位置，如果token x x x在词汇表的位置为 T k T_k Tk​, 则 f ( x ) = k f(x)=k f(x)=k.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8e0b9dca77acb98b3f0f9d3e33e9724/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84796b0cc58ce2c0d8966ec2b4a11ab0/" rel="bookmark">
			scp命令用于Windows和Linux之间复制文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		scp使用 简述Windows和Linux之间复制文件使用示例从本地复制到远程复制文件复制文件夹 从远程复制到本地复制文件复制文件夹 在Linux下（从Linux复制到Windows）复制文件复制文件夹 在Windows下（从Windows复制到Linux）复制文件复制文件夹 在Linux下（从Windows复制到Linux）复制文件复制文件夹 在Windows下（从Linux复制到Windows）复制文件复制文件夹 简述 Linux scp 命令用于 Linux 之间复制文件和目录。
scp 是 secure copy 的缩写, scp 是 linux 系统下基于 ssh 登陆进行安全的远程文件拷贝命令。
scp 是加密的，rcp 是不加密的，scp 是 rcp 的加强版。
Windows和Linux之间复制文件 Windows本身不支持ssh协议，因此要互传文件，需在Windows系统上安装ssh for Windows的软件
如winsshd，可以使Windows系统支持ssh协议；或者用Windows自带的openssh
流程：右键左下角“开始”-&gt;“设置”-&gt;“应用”-&gt;“可选功能”-&gt;进行操作
如下图：
使用 Windows下是在shift+鼠标右键进行powershell下键入命令
linux是在terminal终端下键入命令：Ctrl+Alt+T
scp [可选参数] file_source file_target 基本参数：
-f：表示复制文件
-r：表示递归文件夹
参数可参考：链接: https://www.runoob.com/linux/linux-comm-scp.html
示例 从本地复制到远程 复制文件 本地文件-&gt;远程文件夹 scp local_file remote_username@remote_ip:remote_folder 本地文件-&gt;远程文件 scp local_file remote_username@remote_ip:remote_file 输入完，敲回车，需输入远程密码
复制文件夹 本地文件夹-&gt;远程文件夹 scp -r local_folder remote_username@remote_ip:remote_folder 输入完，敲回车，需输入远程密码
从远程复制到本地 复制文件 远程文件-&gt;本地文件 scp remote_username@remote_ip:remote_file local_file 输入完，敲回车，需输入远程密码
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/84796b0cc58ce2c0d8966ec2b4a11ab0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c53252b07d8d956c25adfeb3382b7c53/" rel="bookmark">
			C语言知识点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、一个函数内的复合语句中定义的变量可以在本函数范围内有效 ①结论：错误 ②验证： ③正确结论：在复合语句(代码块)中定义的变量，不可以在复合语句之外使用。 2、转义字符 ‘\0‘ 和 ‘\012‘如何识别 ①结论：取决于后续是否为合法的八进制。 ②示例 # 以\开始，最少1位，最多3位，且必须是合法的8进制数字，即0~7。 如"\012"。 # 例：在"\08"中，’\0’为结束符。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b035b3bf7305427de9db6c01d6e8765f/" rel="bookmark">
			从零到一制作扫雷游戏——C语言
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是扫雷游戏？ 扫雷游戏作为一种老少咸宜的益智游戏，
它的游戏目标十分简单，就是要求玩家在最短的时间内，
根据点击格子之后所出现的数字来找出所有没有炸弹的格子，
同时在找的时候要避免点到炸弹，一旦踩到炸弹则游戏结束。
扫雷游戏的规则 扫雷的棋盘是9*9的格子，默认随机布置10个雷。
如果位置不是雷，就显示周围有几个雷，如果位置是雷，游戏结束。
玩家需要找到雷区中所有不是地雷的方格，同时避免踩到地雷。
为什么我们要学习制作扫雷游戏呢？ C语言是一门重要的基础课程，应用广泛，也是不少后续课程的基础。
然而，由于C语言语法规则较多，在实际编程时又相对灵活，
很多初学者接触这门课程会觉得有难度，普遍有畏惧心理。
而通过制作扫雷等小游戏可以逐步将已学的语法知识用起来，
帮助我们更好的理解C语言里蕴含的知识点，逐步提高对编程的兴趣和能力。
制作扫雷游戏的步骤 1.先设计三个⽂件： test.c // ⽂件中写游戏的测试逻辑 game.c // ⽂件中写游戏中函数的实现等 game.h // ⽂件中写游戏需要的数据类型和函数声明等 2.game.h #define _CRT_SECURE_NO_WARNINGS #pragma once #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt; #define EASY_COUNT 10 #define ROW 9 #define COL 9 #define ROWS ROW+2 #define COLS COL+2 //初始化棋盘 void InitBoard(char board[ROWS][COLS], int rows, int cols, char set); //打印棋盘 void DisplayBoard(char board[ROWS][COLS], int row, int col); //布置雷 void SetMine(char board[ROWS][COLS], int row, int col); //排查雷 void FindMine(char mine[ROWS][COLS], char show[ROWS][COLS], int row, int col); 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b035b3bf7305427de9db6c01d6e8765f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d2c3f327eb7fa5937c7be44fcb43a9e/" rel="bookmark">
			Linux环境安装redis
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文链接：Linux环境安装redis – 编程屋
步骤一：创建一个redis的安装目录
[root@VM-16-7-centos ~]# mkdir -p /usr/local/src/redis
步骤二：查看安装程序（若之前安装过redis，下次安装之前一定要删除干净）
[root@VM-16-7-centos ~]# rpm -qa | grep -i redis
步骤三：命令下载redis包
[root@VM-16-7-centos ~]# wget http://download.redis.io/releases/redis-6.2.6.tar.gz
在哪个目录下进行下载命令，下载后安装包就会下载到哪个目录
步骤四：将下载下来的安装包移到新建的redis目录下
[root@VM-16-7-centos ~]# mv redis-6.2.6.tar.gz /usr/local/src/redis
步骤五：进行解压
[root@VM-16-7-centos redis]# tar -zxvf redis-6.2.6.tar.gz
步骤六：进入到解压后的目录进行编译
[root@VM-16-7-centos redis-6.2.6]# make
如果编译失败可以检查是否安装了gcc。因为redis是C语言编写的，所以在进行第六步之前可以先安装gcc，安装命令如下：
yum install gcc-c++
步骤七：进入redis-6.2.6/src 文件目录下进行安装
[root@VM-16-7-centos src]# make install
步骤八：为了方便管理可以将Redis文件中的conf配置文件和常用命令移动到统一文件中
1）创建bin和etc文件夹
2）将redis-6.2.6目录下的 redis.conf 移动到 redis-6.2.6目录下的etc文件夹下，将mkreleasehdr.sh、redis-benchmark、redis-check-aof、redis-cli、redis-server 移动到 /usr/local/redis-6.2.6/bin/ 目录下
[root@VM-16-7-centos redis-6.2.6]# mv redis.conf ./etc/
[root@VM-16-7-centos redis-6.2.6]# cd ./src/
[root@VM-16-7-centos src]# mv mkreleasehdr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d2c3f327eb7fa5937c7be44fcb43a9e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6f516b1991d5750060a31fc34501e02/" rel="bookmark">
			C#执行CMD
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		代码如下
using System; using System.Diagnostics; namespace ExecuteCommandExample { class Program { static void Main(string[] args) { string command = "ping www.baidu.com"; // 替换成需要执行的命令 ExecuteCommand(command); } static void ExecuteCommand(string command) { var processInfo = new ProcessStartInfo() { FileName = "cmd.exe", Arguments = $"/C {command}", CreateNoWindow = true, UseShellExecute = false, RedirectStandardOutput = true }; using (var process = new Process()) { process.StartInfo = processInfo; process.OutputDataReceived += (sender, e) =&gt; Console.WriteLine(e.Data); process.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6f516b1991d5750060a31fc34501e02/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e1a0250866e974ab6b5313d297478ef/" rel="bookmark">
			【ROS】参数服务器--理论模型与参数操作(C&#43;&#43;)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、概念介绍 参数服务器在ROS中主要用于实现不同节点之间的数据共享。参数服务器相当于是独立于所有节点的一个公共容器，可以将数据存储在该容器中，被不同的节点调用，当然不同的节点也可以往其中存储数据。
作用：存储一些多节点共享的数据，类似于全局变量。
二、理论模型[Autolabor-ROS] 参数服务器实现是最为简单的，该模型如下图所示,该模型中涉及到三个角色:
ROS Master (管理者)
Talker (参数设置者)
Listener (参数调用者)
ROS Master 作为一个公共容器保存参数，Talker 可以向容器中设置参数，Listener 可以获取参数。
整个流程由以下步骤实现:
1.Talker 设置参数
Talker 通过 RPC 向参数服务器发送参数(包括参数名与参数值)，ROS Master 将参数保存到参数列表中。
2.Listener 获取参数
Listener 通过 RPC 向参数服务器发送参数查找请求，请求中包含要查找的参数名。
3.ROS Master 向 Listener 发送参数值
ROS Master 根据步骤2请求提供的参数名查找参数值，并将查询结果通过 RPC 发送给 Listener。
注意:参数服务器不是为高性能而设计的，因此最好用于存储静态的非二进制的简单数据
三、参数操作(C++) 在 C++ 中实现参数服务器数据的增删改查，均可以通过两套 API 实现:
ros::NodeHandle
ros::param
下面为具体操作演示：
1.参数服务器新增(修改)参数 【增、改】 /* 参数服务器操作之新增与修改(二者API一样)_C++实现: 在 roscpp 中提供了两套 API 实现参数操作 ros::NodeHandle setParam("键",值) ros::param set("键","值") 示例:分别设置整形、浮点、字符串、bool、列表、字典等类型参数 修改(相同的键，不同的值) */ #include "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e1a0250866e974ab6b5313d297478ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0a445fed9289b046b600f7951cd387a/" rel="bookmark">
			算术移位和逻辑移位
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.逻辑移位 逻辑移位是对无符号数进行的，左移和右移都是补零
例如：0101
左移1位：1010
右移1位：0010
2.算术移位 算术移位是对有符号数进行的，符号位不变，对数值位进行移动。移位的规则如下:
真值码制移动方式正数原码，反码，补码左移和右移都加0负数原码左移和右移都加0负数补码左移加0负数补码右移加1负数反码左移和右移都加1 例如：
正数 0，0110（+6）
左移1位：0，1100
左移2位：0，1000
右移1位：0，0011
右移2位：0，0001
负数 1，0110（-6原码）
左移1位：1，1100
左移2位：1，1000
右移1位：1，0011
右移2位：1，0001
负数 1，1010（-6补码）
左移1位：1，0100
左移2位：1，1000
右移1位：1，1101
右移2位：1，1110
负数 1，1001（-6反码）
左移1位：1，0011
左移2位：1，0111
右移1位：1，1100
右移2位：1，1110
3.对网上其他说法的说明 网上说逻辑左移和算术左移一样都是低位补零，逻辑右移高位补0，算术右移高位补和符号位一样的数字，这种说法是针对补码而言的。实际上由于计算机中所有数字都是以补码的形式存在，在设计cpu时设计的移位运算也是针对补码进行的，所以网上的说法是没错的。在考试做题时要分清是原码，补码，反码，负数对这三种机器数的算术移位操作是不同的，尽管实际设计硬件只实现了补码的算术移位。个人建议按正数和负数分别记忆。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88d3c332ac6fdc5e64dcff5a0586472d/" rel="bookmark">
			常用的电参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		电参数根据电流的特点可以分为直流电参数和交流电参数，在电参数中有些是可以通过电参数表测得，有些参数则为通过测得的参数计算而来。
一、电参数 1.1 直接可测电参数 ——瞬时电压值
——瞬时电流值
n——采样点数
f——频率
time——时间
其中，频率表示采样频率，
1.2 间接可求电参数 交流直流有效值（均方根值）直流分量交流分量正峰值负峰值峰值峰峰值峰值因数 1.3 功率与效率 有功功率P 保持用电设备正常工作的功率
，
其中U,I为有效值；为瞬时采样值；为连续值。
在直流电中，由于电流和电压方向相同，因此功率直接为电压有效值和电流有效值的乘积；在单相电路中，有功功率等于电压有效值和功率因数的乘积；
三相电的电功率的计算公式_200KW三相四线制线路，需要多少A电源空开？ - 知乎
三相电中由于相之间角度为120°，所以三相电的电功率的计算公式：
其中P有功功率，U电源的线电压，I线电流，cosφ功率因数。
在纯电阻电路cosφ是1，在感性负载为主的电力拖动cosφ取0.75，在以电解电度负载cosφ取0.6。知道了功率，电压和功率因数，我们就可以计算出设备的电流。
阻性负载：I=P/（1.732*U*cosφ）=200KW/1.732/380V/1 =304A
感性负载：I=P/（1.732*U*cosφ）=200KW/1.732/380V/0.75 =405A
电解电镀负载：I=P/（1.732*U*cosφ）=200KW/1.732/380V/0.6 =506A
通过上面计算，我们可以选择设备的开关了，那就是，
电加热类的负载开关选用： I=304*1.1=334A 查断路器选型手册，选用350A断路器。
感性负载：I=405*1.25=506A 查断路器选型手册，选用500A断路器。
电解电镀负载： I=506*1.1=557A 查断路器选型手册，选用630A断路器。
由于在采样电路中采集的数据均为离散数据，因此使用求和；当为连续点时，求和变为积分。
无功功率 不对外做功，用于电磁或电感充能的功率
视在功率 电压电流有效值的乘积
功率因数 决定于电路元件参数和工作频率，线性电阻电路为1，纯电容/电感电路为0
电路传输效率 输出功率比上输入功率，交流输电由于
1.4 电能量和电量 二、关于电参数基础的理解 2.1、关于交直流的定义 直流：方向和大小保持不变，电流方向始终与电压相同，电荷流速不变，输出恒定。
交流：方向和大小随时间变化，电流方向可以与电压方向不同，电荷流速随时间变化，通常用频 率表示，会出现周期性变化。
直流电和交流电之间的能量传输效率会受到电源电压、线路长度、线路阻抗等影响。
一般情况下，交流电能够更好地传输电力，因为交流电在传输过程中可以利用变压器进行电压变换，从而有效地减少电线的损耗和成本，并且通过调整频率可以改变电流和电压之间的相位差，进一步优化传输效率。
另外，直流电在较长距离的传输中会有比较大的能量损失，因为直流电线路上存在电流、电压不稳定等问题，这些问题难以通过直接的变压或调节频率来解决，因此相比之下，交流电在能量传输效率上更为优越。
2.2、有效值 根据电流的热效应来定义的，直流电中电流电压的方向相同直接进行积分就可以；在交流电中，让交流电和直流电分别通过相同的电阻，如果在相同时间内产生的热量相同，那么直流电的数值叫做这个交流电的有效值。上面表中有对应的量化。
2.3、直流分量与交流分量 直流分量：指信号中的直流成分，信号的直流分量就是信号的平均值，一个与时间无关的常数。 直流分量是指频率为0的信号分量，信号的时间均值。求取：求和取平均、低通滤波 器、FFT、f=0的分量、采样直流偏置、AD不接交流信号。零次谐波
交流分量：频率不为0的部分，值等于根号下有效值和直流分量的平方差。
2.4、谐波 参考链接：谐波_银河百科
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/88d3c332ac6fdc5e64dcff5a0586472d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d493e2837b8bb08faf33f78d352c14fb/" rel="bookmark">
			CentOS7系统更新默认Python版本到新版Python3.9.0版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		步骤一 安装依赖：
确保您的系统已经安装了一些必要的依赖库，以便于编译和安装新的Python版本。在终端中运行以下命令：
sudo yum install gcc openssl-devel bzip2-devel libffi-devel zlib-devel
步骤二 下载Python3.9.0：
在终端中使用wget或curl下载Python 3.9的源代码压缩包。您可以从Python官方网站获取下载链接。命令如下：
wget https://www.python.org/ftp/python/3.9.0/Python-3.9.0.tgz
步骤三 解压并编译安装：
解压下载的源代码压缩包，命令如下：
tar -xzvf Python-3.9.0.tgz
进入解压后的目录，命令如下：
cd Python-3.9.0
配置编译参数，命令如下：
./configure --enable-optimizations
编译，命令如下：
make
安装，命令如下：
sudo make altinstall
#注意使用make altinstall而不是make install，以避免覆盖系统默认的Python版本。
步骤四 更新软链接：
默认情况下，新安装的Python 3.9将被安装在/usr/local/bin目录中。您可以将新Python版本的可执行文件链接到/usr/bin中，以便在终端中直接使用。命令如下：
sudo ln -s /usr/local/bin/python3.9 /usr/bin/python3.9
步骤五 验证更新：
现在，您应该能够在终端中使用新的Python版本。运行以下命令验证Python 3.9是否正确安装并可用：
python3.9 --version
如果输出显示Python 3.9的版本信息，那么更新已经成功。
请注意，在更新Python版本之前，一定要确保您的应用程序和脚本兼容新的Python版本，以免出现不兼容的问题。某些旧代码可能需要进行调整才能在新版本上运行。另外，如果您之前安装了一些Python包，您可能需要使用pip重新安装它们，以使其与新的Python版本兼容。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8cbe54397b0e3ed8bf8e94916b9511ca/" rel="bookmark">
			【ROS】服务通信--从理论介绍到模型实现(C&#43;&#43;)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、概念介绍 服务通信也是ROS中一种极其常用的通信模式，服务通信是基于请求响应模式的，是一种应答机制。也即: 一个节点A向另一个节点B发送请求，B接收处理请求并产生响应结果返回给A。
一个节点需要向相机节点发送拍照请求，相机节点处理请求，并返回处理结果。
与上述应用类似的，服务通信更适用于对实时性有要求、具有一定逻辑处理的应用场景。
二、理论模型 服务通信较之于话题通信更简单些，理论模型如下图所示，该模型中涉及到三个角色:
ROS master(管理者)
Server(服务端)
Client(客户端)
ROS Master 负责保管 Server 和 Client 注册的信息，并匹配话题相同的 Server 与 Client ，帮助 Server 与 Client 建立连接，连接建立后，Client 发送请求信息，Server 返回响应信息。
整个流程由以下步骤实现:
0.Server注册
Server 启动后，会通过RPC在 ROS Master 中注册自身信息，其中包含提供的服务的名称。ROS Master 会将节点的注册信息加入到注册表中。
1.Client注册
Client 启动后，也会通过RPC在 ROS Master 中注册自身信息，包含需要请求的服务的名称。ROS Master 会将节点的注册信息加入到注册表中。
2.ROS Master实现信息匹配
ROS Master 会根据注册表中的信息匹配Server和 Client，并通过 RPC 向 Client 发送 Server 的 TCP 地址信息。
3.Client发送请求
Client 根据步骤2 响应的信息，使用 TCP 与 Server 建立网络连接，并发送请求数据。
4.Server发送响应
Server 接收、解析请求的数据，并产生响应结果返回给 Client。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8cbe54397b0e3ed8bf8e94916b9511ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b7720ad6e186fea48bccd80958e9917/" rel="bookmark">
			Clion控制台中文输出乱码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.点击【file】——【New Project Settings】——【Setting New Project】设置Clion新项目的全局设置
2.将如图所示几个文件编码方式设置为【UTF-8】
此时控制台输出依旧乱码
3.快捷键Ctrl+Shift+Alt+/，选择Registry
然后将【run.process.with.pty】后value下的复选框取消勾选，然后再次运行代码程序，控制台的中文显示正常。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18c9a5e5384c7333447f73db60c38846/" rel="bookmark">
			如何删除Edge表单“保存的数据“
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		打开设置
打开这个
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8eabf41e2063f565b16c60e36f4d6791/" rel="bookmark">
			Mac mongodb 安装、配置启动及命令行操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、 4.2.5版本下载 链接: https://pan.baidu.com/s/1qKQ9Kzb7qtjfwu8msBNRHA 密码: seun
二、安装 先将下载好的压缩包解压，然后打开 shell 终端，切换到你已经解压好的文件的bin目录下，然后执行下面的命令：
install_compass mongod mongoexport mongoimport mongorestore mongostat /usr/local/bin/ 三、配置及启动 1.如果直接在终端运行mongod命令，会报错提示缺少/data/db目录。
2.然而直接创建该目录，又会提示只读文件系统无法创建。
➜ ~ sudo mkdir -p /data/db Password: mkdir: /data/db: Read-only file system 3.解决方案：
在另外一个目录下创建 data/db文件夹，此处在/Users/wangjianwen目录下。
➜ ~ cd /Users/wangjianwen ➜ ~ mkdir data ➜ ~ mkdir data/db 启动mongo
➜ ~ mongod --dbpath /Users/wangjianwen/data/db 四、命令行操作 查看所有数据库 show dbs 查看所有集合 show tables | show collections 查看当前所在数据库 db 使用数据库 use db_name 创建用户命令
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8eabf41e2063f565b16c60e36f4d6791/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/288ad3b6706f6d04abc7a3b1df840c1d/" rel="bookmark">
			格式化磁盘时的文件系统和分配单元大小是什么意思?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.文件系统 NTFS（New Technology File System） NTFS是Windows系统常用的文件系统。支持大容量存储和超大分区，单个文件大小可以达到几TB。它还提供了许多高级功能，如权限控制、文件压缩、磁盘配额等。NTFS对断电和系统崩溃有较好的恢复能力。
但是对其他操作系统的兼容性较差。
exFAT（Extended File Allocation Table） exFAT是一种用于移动存储设备的文件系统，兼容性良好，可以在多个操作系统（包括Windows、Mac和Linux）之间读写数据。支持更大的文件和分区大小。
exFAT相对于NTFS来说在安全性和可靠性方面略差。
FAT32（File Allocation Table 32） FAT32是一种较早的文件系统。兼容性良好，能与几乎所有操作系统兼容。
FAT32对单个文件大小限制为4GB，磁盘容量限制为2TB。并且碎片问题较为严重，文件删除和写入速度相对较慢。
2.分配单元大小 转载知乎的回答
作者：一起学点什么 来源：知乎
分配单元大小”就是分区中的“簇”，“簇”是分区的最小存储单元。一个数据在存入硬盘前，会事先按照簇大小将其均分成N等份，然后存入分区中不同的簇内。例如名叫“毕业论文.pdf”文件，大小是1600KB。
（1）如果分配单元大小设置为512KB，数据存入前，系统会先将其分为512KB、512KB、512KB、64KB四份，然后分别存入硬盘对应的四个簇中，这样一来存在一个问题，最后的64KB不够填满一个512KB的簇，那么剩下的448KB空间也就被浪费了。其实，即使最后一个簇中仅使用了1个字节，这个簇剩下的全部空间也会被弃之不用。
（2）如果将分配单元大小设置为64KB，数据存入前，系统会按64KB将这个数据分为25份，然后存入对应的25个簇中。将单元大小设置为512KB时，最后会有一部分空间被浪费，但是它存取数据时，只分成4份就完成了，效率更高。而将其分成64KB时，虽然不存在浪费了，但存取效率也低了。因此，簇越小，效率越低，但浪费的空间也小；簇越大，效率越高，浪费的空间也多。
在格式化时，如果不调整这个参数，系统默认将“分配单元大小”设置为4096字节，即4KB，由于在x86时代，每个内存页的大小被定义为4KB，因此认为将硬盘的块大小也分成4KB可以与内存页吻合而提升硬盘的运行效率。
快速格式化 与完整格式化相比，快速格式化只会清除文件系统的元数据，而不会执行物理上的数据擦除操作。
具体来说，快速格式化的作用是在文件系统中创建一个新的文件目录，并清除存储介质上的文件索引和其他元数据信息，使其看起来像是一个全新的空存储介质。这个过程相对较快，只需几秒钟或几分钟的时间，取决于存储介质的大小。
需要注意的是，快速格式化并不会对存储介质上的实际数据进行擦除操作。被删除的文件仍然可以通过专业的数据恢复工具或方法来恢复。
如果你希望彻底擦除存储介质上的所有数据，以确保敏感数据不会被恢复，建议选择完整格式化或使用专门的数据擦除工具。
因此，选择使用格式化还是快速格式化取决于你的需求。如果只是清除U盘的文件并重新使用，快速格式化就可以了。如果想相对彻底清除文件，确保数据不可恢复，并不考虑数据隐私，且不介意格式化时间，那么建议选择格式化或使用专门的数据擦除工具。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/868e00267635632f3828f6894008da64/" rel="bookmark">
			锂电池充放电曲线、设置充电电流、检测TP4054的3种充电状态
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0、开场 以前在公司画的板是12V/24V供电，用的是成品大功率开关电源，或者电源适配器，自己随便画的板倒是低电压的5V，但是供电方式就是留个USB接口，对于很多小型或便携的产品是不太方便啦，刚好现在需要做的项目用到了锂电池，填补知识的空白，开心，我也不知道为啥激动，反正抑郁的时候难受要死不如就现在好好享受心底自然流露的好奇和愉悦。
1、锂电池放电曲线 通常说的锂电池3.7V，指的是放电的平台电压（有点拐点的感觉），4.2V说的是充满电的时候，下图是放电曲线。
在4.18V到4V的区间，电池电压下降的很快；在4.0V到3.71V的区间，电压下降的趋势比较缓和；在3.71V再往下的区间，电压下降的趋势又变陡； 2、锂电池充电曲线 充电的方案用的是TP4054，典型电路是比较简单的，根据不同的应用需求手册上有提供更完善的电路；
下图是以时间为X轴，以电压、电流为Y轴的充电曲线。 在电压小于2.9V的时候，充电电流为设置的恒定电流的1/10，也就是400mA的1/10即40mA来充电；当电压大于2.9V后，以400mA的恒定电流充电；当电压快充到4.2V的时候，降低电流，改为恒压充电，当电流降到设置电流的1/10停止充电，电流降为0，停止充电循环； 3、设置锂电池充电电流 上面提到设置充电电流，是通过PROG引脚外接的电阻决定的，公式为：
其中IBAT指的就是你要设置的充电电流，根据电流的范围对应公式1和公式2，以IBAT=400mA为例应使用公式一，计算出Rprog=1.66K；
4、TP4054锂电池充电的3种模式检测 4.1、3种实际情况与CHRG引脚的状态 我们想要知道是否外接着5V在充电，是否已经充满，也就是3种情况：
压根没有外接5V，不在充电；有外接的5V，正在充电中；有外接的5V，已经充满了； 手册中这个图是有关充电阶段与CHRG的状态的，其中2分为三个阶段在上面也有介绍；
那么总结一下，现在可以得到如下条件，问题就是如何检测CHRG的三种状态来对应实际的三种情况就行了。
CHRG高阻抗：没有外接5V的情况，不在充电；CHRG强下拉（10mA）：正在充电；CHRG弱下拉（20uA）：已经充满； 4.2、检测电路与思路 将OUT设置为高电平：
强下拉时检测IN是低电平，即正在充电； 将OUT设置为高阻抗：
弱下拉时检测IN是低电平，即已经充满；高阻抗时检测IN是高电平，即没有充电； 代码上高阻抗的话，就是将GPIO设置为浮空输入；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5537c4f62311f35ec7dd5b0f36fe2ef2/" rel="bookmark">
			TypeScript学习笔记——2022.08.17
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、基本类型 1、类型声明 类型声明是TS非常重要的一个特点通过类型声明可以指定TS中变量（参数、形参）的类型指定类型后，当为变量赋值时，TS编译器会自动检查值是否符合类型声明，符合则赋值，否则报错简而言之，类型声明给变量设置了类型，使得变量只能存储某种类型的值 2、自动类型判断 TS拥有自动的类型判断机制当对变量的声明和赋值是同时进行的，TS编译器会自动判断变量的类型如果你的变量的声明和赋值同时进行，可以省略掉类型声明 3、类型 number：任意数字string：任意字符串boolean：布尔值true或false字面量：限制变量的值就是该字面量的值any：任意类型，可以赋值给任意变量unkonwn：类型安全的any，不能直接赋值给其他变量void：没有值（或undefined），表示空，以函数为例，就表示没有返回值的函数never：不能是任何值，表示永远不会返回结果object：任意的js对象array：任意的js数组tuple：元祖，TS新增类型，固定长度的数组enum：枚举，TS新增类型 4、编译选项 自动编译文件
①编译文件时，使用-w指令后，TS编译器会自动监视文件的变化，并在文件发生变化时对文件进行重新编译 tsc xxx.ts -w 自动编译整个项目
①如果直接使用tsc指令，则可以自动将当前项目下的所有ts文件编译为js文件
②但是能直接使用tsc命令的前提时，要现在项目根目录下创建一个ts的配置文件tsconfig.json
③tsconfig.json，添加配置文件后，只需要tsc命令即可完成对整个项目的编译
④配置选项
include：指定哪些ts文件需要被编译
** 表示任意目录 * 表示任意文件
exclude：定义需要排除在外的目录 [“xx/xx”, “xx/xx”]
extends：定义被继承的配置文件
files：指定被编译文件的列表，只有需要编译的文件少时才会用到
compilerOptions：编译选项是配置文件中非常重要也比较复杂的配置选项，在compilerOptions 中包含多个子选项，用来完成对编译的配置
1、target 用来知道ts被编译为js的版本（es3、es5、es6、es2015、es2018、es2019、es2020…）
2、module：指定要使用的模块化标准（none、commonjs、amd、system、umd、es6、es2015、es2020…）
3、lib：指定项目中要使用的库
4、outDir：用来指定编译后文件所在的目录
5、outFile：将代码合并为一个文件，设置outFile后所有的全局作用域中的代码会合并到同一个文件中
6、allowJs：是否对js文件进行编译，默认是false
7、checkJs：是否检查js代码是否符合语法规范，默认是false
8、removeComments： true 是否移除注释
9、noEmit：false 不生成编译后的文件
10、noEmitOnError：true 当有错误时不生成编译后的文件
11、alwaysStrict：false 用来设置编译后的文件是否使用严格模式，默认是false
12、noImplicitAny：true 不允许隐式的any类型
13、noImplicitThis：true 不允许不明确类型的this
14、strictNullChecks：true 严格的检查空值 二、面相对象 1、类（class） 直接定义的属性是实例属性，需要通过对象的实例去访问 const per = new Person(); per.name 使用static开头的属性是静态属性（类属性），可以直接通过类去访问 Person.name 2、构造函数（constructor） 构造函数会在对象创建时调用在实例方法中，this就表示当前的实例在构造函数中当前对象就是当前新建的那个对象，可以通过this向新建的对象中添加属性在方法中可以通过this来表示当前调用方法的对象 3、继承（extends） 使用继承后，子类会拥有父类所有的方法和属性通过继承可以将多个类中共有的代码写在一个父类中，这样就只需要写一个即可让所有的子类同时拥有父类中的属性；如果希望在子类中添加一些父类中没有的属性或方法直接加就行如果在子类中添加了和父类相同的方法，则子类方法会覆盖掉父类的方法，这种子类覆盖掉父类方法的形式叫做方法的重写 4、超类（super） 代表的是当前类的父类，最关键的是在子类的构造函数中必须调用父类的构造函数 5、抽象类（abstract） 以abstract开头的类是抽象类；抽象类和其他类区别不大，只是不能用来创建对象；抽象类就是专门用来被继承的类抽象类中可以添加抽象方法，抽象方法使用abstract开头，没有方法体抽象方法只能定义在抽象类中，子类必须对抽象方法进行重写 6、接口（interface） 用来定义一个类的结构，用来定义一个类中应该包含哪些属性和方法，同时也可以当成类型声明去使用可以在定义类的时候限制类的结构；接口中的所有属性都不能有实际的值，接口只定义对象的结构而不考虑实际值，在接口中所以的方法都是抽象方法定义类时，可以使类去实现一个接口；实现接口就是使类满足接口的要求 7、属性的封装 定义一个person的类，现在属性是直接在对象中设置的，属性可以任意的被修改，可能会导致对象中的数据变的非常不安全TS可以在属性前面添加属性的修饰符
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5537c4f62311f35ec7dd5b0f36fe2ef2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a8d15dfe158b88257e35dabdaa565bf/" rel="bookmark">
			cmake扩展(5)——file命令排除部分文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在cmake中可以使用file命令获取需要的文件，并且支持正则/通配符，使用起来还是很方便的。
#语法 file({GLOB | GLOB_RECURSE} &lt;out-var&gt; [...] [&lt;globbing-expr&gt;...]) #example file(GLOB_RECURSE SOURCES "src/*.h" "src/*.cpp" "src/*.ui") 但是由于file命令并不包含exclude这样的参数，所以无法排除某个文件，比如对于下面的目录：
我们本来可以使用
file(GLOB_RECURSE SOURCES "src/*") 获取所有文件(1,2,3,4.cpp,5.cpp)。而我们如果想要排除cpp文件的话，无法直接排除。
但是因为file命令获得的变量是一个列表，所以可以借助list命令进行排除：
list(REMOVE_ITEM &lt;list&gt; &lt;value&gt; [&lt;value&gt; ...]) list的REMOVE_ITEM命令表示从list中移除部分元素内容，需要注意的是不支持正则/统配符.
因此我们不能使用
list(REMOVE_ITEM SOURCES "src/*.cpp") 这样的方式。
我们仍然需要借助file命令，将"src/*.cpp"的全部文件的完整名称获取到：
file(GLOB_RECURSE REMOVE_SOURCES "src/*.cpp") 然后在使用list命令
list(REMOVE_ITEM SOURCES ${REMOVE_SOURCES}) 这样，就可以排除掉不需要的文件啦。
完整cmakelist.txt如下：
cmake_minimum_required(VERSION 3.27) project(foreachTest) variable_watch(SOURCES) file(GLOB_RECURSE SOURCES "src/*") file(GLOB_RECURSE REMOVE_SOURCES "*.cpp") message("REMOVE_SOURCES：" ${REMOVE_SOURCES}) list(REMOVE_ITEM SOURCES ${REMOVE_SOURCES}) 打印内容如下：
Variable "SOURCES" was accessed using MODIFIED_ACCESS with value "E:/个人/project/cmake/test04/06/src/1;E:/个人/project/cmake/test04/06/src/2;E:/个人/project/cmake/test04/06/src/3;E:/个人/project/cmake/test04/06/src/4.cpp;E:/个人/project/cmake/test04/06/src/5.cpp". REMOVE_SOURCES：E:/个人/project/cmake/test04/06/build/CMakeFiles/3.27.0/CompilerIdCXX/CMakeCXXCompilerId.cppE:/个人/project/cmake/test04/06/src/4.cppE:/个人/project/cmake/test04/06/src/5.cpp CMake Debug Log at CMakeLists.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5a8d15dfe158b88257e35dabdaa565bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51e70117306ee0e1fbccb3b22a82a2db/" rel="bookmark">
			复用InputStream
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是 InputStream InputStream就是Java标准库提供的最基本的输入流。它位于java.io这个包里。java.io包提供了所有同步IO的功能。
要特别注意的一点是，InputStream并不是一个接口，而是一个抽象类，它是所有输入流的超类
为什么要复用 InputStream 在实际的工作当中，某些场合下我们常常会需要多次读取一个InputStream的需求,比如：从流中提取文本、文档格式转换、文件复制移动等。但InputStream具有不可重复使用的特性，如果第一次使用后就关闭了流，第二次使用就会报出java.io.IOException: Stream Closed的异常，如果第一次使用没有关闭流，第二次使用的时候读取到的字节数就是0，因为在InputStream读取的时候，会有一个pos指针，他指示每次读取之后下一次要读取的起始位置，当读到最后一个字符的时候，pos指针不会进行重置。 方法一【不建议使用】 先将InputStream转为string，需要用到的时候再将string转为InputStream
注意：读取excel等office文件时会损坏文件流
将InputStream转为string public static String inToStr(InputStream in){ return new BufferedReader(new InputStreamReader(in)).lines().collect(Collectors.joining(System.lineSeparator())); } 将string转为InputStream public static InputStream strToIn(String str){ return new ByteArrayInputStream(str.getBytes()); } 方法二【建议使用】 转为ByteArrayInputStream，每次使用完都使用reset方法将指针指向开头
将InputStream转为ByteArrayInputStream /** 1. 将InputStream转换成ByteArrayOutputStream */ public static ByteArrayOutputStream toOutByteStream(InputStream in) throws IOException { ByteArrayOutputStream out =new ByteArrayOutputStream(); byte[] buffer=new byte[1024]; int len; while((len=in.read(buffer))&gt;-1){ out.write(buffer,0,len); } out.flush(); in.close(); return out; } /** * InputStream转成ByteArrayInputStream */ public static ByteArrayInputStream toByteArrayInputStream(InputStream in) throws IOException { return getInput(toOutByteStream(in)); } 重置指针 public static void reset(ByteArrayInputStream in){ if (in !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/51e70117306ee0e1fbccb3b22a82a2db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7c56378398f3fa0eac8ce0c1cb4c702/" rel="bookmark">
			【Java】SpringBoot的统⼀用户登录权限验证、统⼀异常处理与统⼀数据返回格式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		统一用户登录权限验证Spring 拦截器拦截器的实现原理实现原理源码分析 统一异常处理统一数据返回格式 Spring Boot 统⼀功能处理也就是前面学习过的AOP 的实战。接下来实现三种统一的功能处理。 统一用户登录权限验证 原来实现一个用户登录权限验证的功能存在一些缺点：
1.每个方法中都要单独写用户登录验证的⽅法，即使封装成公共用法，也⼀样要传参调用和在方法中进行判断。
2. 添加控制器越多，调用用户登录验证的方法也越多，这样就增加了后期的修改成本和维护成本。
3. 这些用用户登录验证的方法和接下来要实现的业务几乎没有任何关联，但每个方法中都要写⼀遍。
此时我们想到的第⼀个实现方案是 Spring AOP 前置通知或环绕通知来实现。但是这里依旧存在一些问题：
1.获取参数复杂；
2. 我们要对⼀部分方法进行拦截，而另⼀部分方法不拦截，如注册方法和登录方法是不拦截的，这样的话排除方法的规则很难定义，甚至没办法定义。
Spring 拦截器 对于以上问题 Spring 中提供了具体的实现拦截器：HandlerInterceptor，拦截器的实现分为以下两个步骤：
创建自定义拦截器，实现 HandlerInterceptor 接口的 preHandle（执行具体方法之前的预处理）方法。将自定义拦截器加入 WebMvcConfigurer 的 addInterceptors 方法中。 1.自定义拦截器：实现HandlerInterceptor
@Component public class LoginInterceptor implements HandlerInterceptor{ @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { //判断是否登录 HttpSession session = request.getSession(false); if(session != null &amp;&amp; session.getAttribute("username") != null){ //通过，不进行拦截 return true; } response.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f7c56378398f3fa0eac8ce0c1cb4c702/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82edbdeea3fff5e4a72b97ccd923a121/" rel="bookmark">
			Matlab 频谱图中如何设置频率刻度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Matlab 频谱图中如何设置频率刻度（横坐标） 1、概述 时域信号经FFT 变换后得到了频谱，在作图时还必须设置正确的频率刻度，这样才能从图中得到正确的结果。下面来介绍如何设置正确的频率刻度。
2、案例分析 有一个余弦信号，信号频率为30Hz，采样频率为100Hz，信号长128，在FFT后做频谱图。
clear; clc; close all; fs=128; % 采样频率 N=128; % 信号长度 t=(0:N-1)/fs; % 时间序列 x=cos(2*pi*30*t); % 余弦信号 y=fft(x,N); % FFT f = linspace(0,64,64); % 设置频率刻度 stem(f,abs(y(1:64)),'k'); % 作图 xlim([25 35]); xlabel('频率(Hz)'); ylabel('幅值'); title('(a)幅频曲线'); 频谱分析后，最大值谱线应该在 30Hz 处。从图中可以看出，最大值谱线在 30Hz 和 31Hz 之间，这表明信号不是 30Hz 的余弦信号，其频率在 30Hz 与 31Hz 之间，这明显不符合初始设置。发生这种错误的原因是在频率刻度的设置错误。
3、解决方法
当N 为偶数和 N为奇数时，频率刻度的设置方法稍有不同，如下图所示：
（1）当 N 为偶数时，频率刻度设置方法一 信号长为 N ，采样频率为 fs，在 DFT(FFT)以后信号的频率在 之间，谱线之间的频率间隔为：
式中： 是采样周期。频率刻度从0开始，最大频率为 。频率刻度简单设置如图2-2-2(a)所示。
clear; clc; close all; fs=128; % 采样频率 N=128; % 信号长度 t=(0:N-1)/fs; % 时间序列 x=cos(2*pi*30*t); % 余弦信号 y=fft(x,N); % FFT % f = linspace(0,64,64); % 设置频率刻度 % stem(f,abs(y(1:64)),'k'); % 作图 % xlim([25 35]); % xlabel('频率(Hz)'); ylabel('幅值'); % title('(a)幅频曲线'); figure('Name','正确的频率刻度') freq=(0:N/2)*fs/N; % 按式(2-2-6c)设置正频率刻度 % 作图 stem(freq,abs(y(1:N/2+1)),'k') xlabel('频率(Hz)'); ylabel('幅值'); title('(b) 只有正频率刻度') xlim([25 35]); set(gcf,'color','w'); 由图可知，图中频率刻度，只用了正频率来表示，最大值的谱线在 30Hz 处，与信号设置频率一致。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b1dd1915dad4c3ee4c3ce22d554f754/" rel="bookmark">
			C&#43;&#43;四种强制类型转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、C强制转换与C++强制转换 c语言强制类型转换主要用于基础的数据类型间的转换，语法为：
(type-id)expression//转换格式1 type-id(expression)//转换格式2 c++除了能使用c语言的强制类型转换外，还新增了四种强制类型转换：static_cast、dynamic_cast、const_cast、reinterpret_cast，主要运用于继承关系类间的强制转化，语法为：
static_cast&lt;new_type&gt; (expression) dynamic_cast&lt;new_type&gt; (expression) const_cast&lt;new_type&gt; (expression) reinterpret_cast&lt;new_type&gt; (expression) 二、C++四种强制类型转换 static_cast
int a = 10; double b = static_cast&lt;double&gt;(a); static_cast相当于传统的C语言里的强制转换，该运算符把expression转换为new_type类型，用来强迫隐式转换，例如non-const对象转为const对象，编译时检查，用于非多态的转换，可以转换指针及其他，但没有运行时类型检查来保证转换的安全性。它主要有如下几种用法：
①用于类层次结构中基类（父类）和派生类（子类）之间指针或引用的转换。
进行上行转换（把派生类的指针或引用转换成基类表示）是安全的；
进行下行转换（把基类指针或引用转换成派生类表示）时，由于没有动态类型检查，所以是不安全的。
②用于基本数据类型之间的转换，如把int转换成char，把int转换成enum。这种转换的安全性也要开发人员来保证。
③把空指针转换成目标类型的空指针。
④把任何类型的表达式转换成void类型。
注意：static_cast不能转换掉expression的const、volatile、或者__unaligned属性。
dynamic_cast
dynamic_cast&lt;type*&gt;(e) dynamic_cast&lt;type&amp;&gt;(e) dynamic_cast&lt;type&amp;&amp;&gt;(e) type必须是一个类类型，在第一种形式中，type必须是一个有效的指针，在第二种形式中，type必须是一个左值，在第三种形式中，type必须是一个右值。在上面所有形式中，e的类型必须符合以下三个条件中的任何一个：e的类型是是目标类型type的公有派生类、e的类型是目标type的共有基类或者e的类型就是目标type的的类型。如果一条dynamic_cast语句的转换目标是指针类型并且失败了，则结果为0。如果转换目标是引用类型并且失败了，则dynamic_cast运算符将抛出一个std::bad_cast异常(该异常定义在typeinfo标准库头文件中)。e也可以是一个空指针，结果是所需类型的空指针。
dynamic_cast主要用于类层次间的上行转换和下行转换，还可以用于类之间的交叉转换（cross cast）。
在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的；
在进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全，向下转型的前提必须是安全的，要借助 RTTI 进行检测，所有只有一部分能成功。dynamic_cast是唯一无法由旧式语法执行的动作，也是唯一可能耗费重大运行成本的转型动作。
dynamic_cast 与 static_cast 是相对的，dynamic_cast 是“动态转换”的意思，static_cast 是“静态转换”的意思。dynamic_cast 会在程序运行期间借助 RTTI 进行类型转换，这就要求基类必须包含虚函数；static_cast 在编译期间完成类型转换，能够更加及时地发现错误。
const_cast
const_cast，用于修改类型的const或volatile属性。
该运算符用来修改类型的const(唯一有此能力的C++style转型操作符)或volatile属性。除了const 或volatile修饰之外， new_type和expression的类型是一样的。
①常量指针被转化成非常量的指针，并且仍然指向原来的对象；
②常量引用被转换成非常量的引用，并且仍然指向原来的对象；
③const_cast一般用于修改底指针。如const char *p形式。
#include&lt;iostream&gt; using namespace std; int main() { const int a = 10; const int * p = &amp;a; int *q; q = const_cast&lt;int *&gt;(p); *q = 20; //fine cout &lt;&lt;a&lt;&lt;"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b1dd1915dad4c3ee4c3ce22d554f754/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9af8f18cfd14b9edcd72b564e49a5c0/" rel="bookmark">
			Ubuntu添加swap分区和删除swap分区
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 添加swap分区 生成swap文件：sudo dd if=/dev/zero of=/var/swapfile bs=1M count=4096，swap大小为bs*count格式化swap文件：sudo mkswap /var/swapfile启用swap文件：sudo swapon /var/swapfile配置开机自动挂载：sudo nano /etc/fstab，在最后添加/var/swapfile swap swap defaults 0 0成功，查看内存：free -h 删除swap分区 卸载swap文件：sudo swapoff /var/swapfile删除自动挂载：sudo nano /etc/fstab，删除 /var/swapfile 对应的行删除swap文件：rm -rf /var/swapfile 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9096d05e3d567d7c8fe43cd66f061492/" rel="bookmark">
			HLS错误记录（1）ERROR: [HLS 214-126] Parameter ‘led‘ is a C language arbitrary-precision integer type
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 官网解决方案：
建议都是用C++语言来进行HLS的开发
将代码换成C++语言风格后，此错误得到解决，
#include &lt;ap_int.h&gt; #define DELAY 50000000 void led_twinkle(ap_int&lt;2&gt; *led){ int i = 0; for(i = 0; i &lt; DELAY; i++){ if(i &lt; DELAY/2) *led = 1; else *led = 2 ; } } 原在C综合是报错的代码：
#include &lt;ap_cint.h&gt; #define DELAY 50000000 void led_twinkle(uint2 *led){ #pragma HLS INTERFACE ap_none port=led #pragma HLS INTERFACE ap_ctrl_none port=return int i = 0; for(i = 0; i &lt; DELAY; i++){ if(i &lt; DELAY/2) *led = 1; else *led = 2 ; } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd6507b9a4ecfdabeabfadc3781f6db9/" rel="bookmark">
			android TextView 超出长度使用省略号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Android中最常见的需求，就是在在外部展示信息时，需要简要展示内容。TextView仅需在静态布局文件中设置以下几个属性：
android:maxWidth=“100dp” // 宽度是多少才算超出 android:maxLines="2" // 高度多少才算超出 android:ellipsize="end" // 代表启用省略号 容易被忽略的问题：
在布局中，大部分人喜欢设置 wrap_content、match_parent 为TextView的宽高。match_parent 和wrap_content 这两个参数又不是一个明确的值，导致省略号无法显示(因为系统不知道边界在哪)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d983b351765fdbb2cd217bfac27722f5/" rel="bookmark">
			Ubuntu ssh的安装及使用，测试联通
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、服务器安装ssh 1.安装openssh-server和net-tools：sudo apt install openssh-server net-tools
2.查看服务器主机地址：ifconfig或ip a
如图，inet部分即为服务器主机地址
二、连接服务器 1.连接服务器：ssh username@IP，或连接服务器图形界面：ssh username@IP -X
其中username为服务器端用户名，IP为服务器主机地址
2.执行后如图所示，输入yes
3.提示"ssh username@IP’s password: "，在后面输入服务器端用户密码
出现下图界面即为成功
4.客户端测试联通：ping 主机名
三、配置公私钥 接上ssh之后，可以通过配置公私钥的方法设置免密登录
1.客户端生成密钥对：ssh-keygen，一路回车即可，其中id_rsa为私钥，id_rsa.pub为公钥
2.SFTP连接服务器：sftp username@IP，并上传文件：put /home/客户端用户名/.ssh/id_rsa.pub /home/服务器用户名/.ssh
服务器端做如下操作：
3.进入.ssh目录：cd ~/.ssh
4.写入密钥：cat id_rsa.pub &gt;&gt; authorized_keys
5.修改authorized_keys权限：sudo chmod 600 authorized_keys
6.重启服务：service sshd restart
7.删除公钥文件：rm ~/.ssh/id_rsa.pub
附加 客户端连接时遇到如下报错：
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@ WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED! @
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!
Someone could be eavesdropping on you right now (man-in-the-middle attack)!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d983b351765fdbb2cd217bfac27722f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/baef9d92da916709e01505f54e2a4e44/" rel="bookmark">
			VET：基因变异VCF数据集便捷提取工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VET：Vcf Export Tools 工具简介 VET是一个基于R语言开发的变异位点信息批量提取工具，主要功能是根据VCF数据集，按照基因ID、样品ID、变异位点ID等参数，实现批量提取，同时支持变异位点结构注释，一步搞定变异数据的快速提取。
########## WelCome to VCF Export Tools ###########
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Design By BioNote &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
可选参数：
[1]根据基因ID提取变异数据
[2]根据物理位置提取变异数据
[3]根据样品名称提取变异数据
[4]根据SNP名称提取变异数据
--------------------------------------------------
[INFO]第一个参数填选项，第二个参数填项目备注名称
[INFO]第三个参数选择是否过滤样本，默认为“N”
[INFO]第四个参数选择是否进行结构注释，默认为“N”
[INFO]运行方法 $ Rscript ./run.R 1 test Y Y
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 程序版本：V 2.0.1 &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
##################################################
功能与应用 基因测序后经过上游分析得到的VCF文件储存了所有样本对应的所有变异信息，通常数据量非常大，在实际使用中需要根据情况对指定信息进行提取。目前已有vcftools或bcftools等工具能够实现上述操作，但是用的时候参数比较复杂，整个过程略显繁琐。
本工具集成了R、tidyverse、Python、vcftools、bcftools、snpEff等常用工具，开发便捷式流程实现批量操作。
主要应用场景是对大规模VCF原始数据集进行提取，支持多种个性化方式：
按基因ID提取指定基因内变异信息 按材料名称提取某些材料变异信息 按变异位点名称筛选指定变异信息 按照物理位置提取指定区段内数据 支持流式操作，提取后筛选指定样品并对每个变异位点进行结构注释（判断错义突变、移码突变等），最终将结果文件打包生成压缩包。
使用方法 第一步：输入待提取的信息 第二步：运行Run.R脚本 第三步：下载结果文件 可以批量操作，无需手写代码。
原理介绍 VCF是生信研究中储存基因变异信息的重要格式，通常经过测序上游分析后得到一份具有丰富信息量的vcf或者vcf.gz文件。
以“##”开头的行表示注释信息，一般记录了字段类型和历史命令，这部分相当于一个日志信息。剩下的数据部分类似一个表格，大体上每行是一个变异位点，每列是一个材料样本。
变异位点（简称SNP）是按照染色体上不同位置进行统计的，展示不同材料中在某个位置碱基差异。
按照突变的类型可以分为3种类型：
缺失：Del，某些碱基不见了 插入：Ins，新出现了某些碱基 替换：SNP，单核苷酸多态性变异 一般常见的VCF文件主要由上述信息组成，对于大规模测序得到的多个样品合并VCF文件，可能包含几千万行×几千列（亿级数据量）。
在实际进行分析时，可能只需要考虑某几个基因或者是一小段区间内的变异数据，因此需要对VCF文件进行提取，只取出想要的一小部分，这个过程涉及到Linux下不同软件的相互配合。
VET 源代码 首先，建立项目文件夹并生成以下结构：
Aug 9 16:30 00_scripts
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/baef9d92da916709e01505f54e2a4e44/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37414fe3c27af3a6074777c49ad90687/" rel="bookmark">
			ORACLE树结构查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ORACLE树结构查询 我们在日常程序设计中，经常会遇到树状结构的表示，例如组织机构、行政区划等等。这些在数据库中往往通过一张表进行展示。这里我们以一张简单的行政区划表为例进行展示，在实际使用过程中，可以为其添加其他描述字段以及层级。
表中通过ID和PID关联，实现树状结构的存储。建表以及数据语句如下：
-- Create table create table TREETEST ( id NVARCHAR2(50), pid NVARCHAR2(50), name NVARCHAR2(50) ) insert into TREETEST (ID, PID, NAME) values ('1', null, '山东省'); insert into TREETEST (ID, PID, NAME) values ('2', '1', '青岛市'); insert into TREETEST (ID, PID, NAME) values ('3', '1', '烟台市'); insert into TREETEST (ID, PID, NAME) values ('4', null, '河南省'); insert into TREETEST (ID, PID, NAME) values ('5', null, '河北省'); insert into TREETEST (ID, PID, NAME) values ('6', '2', '市南区'); insert into TREETEST (ID, PID, NAME) values ('7', '2', '市北区'); insert into TREETEST (ID, PID, NAME) values ('8', '2', '即墨市'); 那对于树状结构如何查询呢？Oracle提供递归查询的方式进行查询，基本语法如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37414fe3c27af3a6074777c49ad90687/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18189ff1f4257a177db37b313367fd46/" rel="bookmark">
			【Linux命令详解 | ssh命令】 ssh命令用于远程登录到其他计算机，实现安全的远程管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章标题 简介一，参数列表二，使用介绍1. 连接远程服务器2. 使用SSH密钥登录2.1 生成密钥对2.2 将公钥复制到远程服务器 3. 端口转发3.1 本地端口转发3.2 远程端口转发 4. X11转发5. 文件传输与远程命令执行5.1 文件传输5.1.1 从本地向远程传输文件5.1.2 从远程服务器下载文件 5.2 远程命令执行5.2.1 在远程服务器上执行单个命令5.2.2 在远程服务器上执行脚本 6. SSH配置和安全性增强6.1 修改SSH配置文件6.2 使用多因素认证6.3 配置防火墙规则6.4 禁用Root登录 总结 简介 在编程和系统管理领域，远程管理是一项至关重要的任务。SSH（Secure Shell）命令是一种加密的网络协议，它提供了一种安全的方式，使您能够在不同的计算机之间进行远程连接和管理。通过使用SSH命令，您可以在远程计算机上执行命令、传输文件以及进行安全的远程登录。SSH的加密特性使其成为保护数据和系统安全的理想选择。
一，参数列表 以下表格列出了SSH命令的常用参数及其功能：
参数功能-l &lt;username&gt;指定登录的用户名-p &lt;port&gt;指定远程SSH服务器端口（默认为22）-i &lt;identity&gt;指定用于身份验证的私钥文件-C启用压缩以加速数据传输-X开启X11转发，允许远程显示GUI界面-L &lt;local:remote&gt;创建本地端口转发-R &lt;remote:local&gt;创建远程端口转发 二，使用介绍 1. 连接远程服务器 要连接到远程服务器，您可以使用以下命令：
ssh -l username hostname 其中，username是您要登录的远程服务器的用户名，hostname是服务器的主机名或IP地址。执行此命令后，系统将提示您输入密码，验证后即可登录。
2. 使用SSH密钥登录 使用SSH密钥对进行身份验证比使用密码更加安全和方便。以下是使用SSH密钥登录的步骤：
2.1 生成密钥对 在本地计算机上执行以下命令生成密钥对：
ssh-keygen -t rsa -b 4096 -f ~/.ssh/mykey 这将生成一个名为mykey的RSA密钥对，保存在~/.ssh/目录中。
2.2 将公钥复制到远程服务器 执行以下命令将公钥复制到远程服务器，替换username和hostname：
ssh-copy-id -i ~/.ssh/mykey.pub username@hostname 现在您可以使用私钥连接到远程服务器，而无需输入密码：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/18189ff1f4257a177db37b313367fd46/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83b174c40c9a01a1104755875f3d9067/" rel="bookmark">
			【MySQL系列】-回表、覆盖索引真的懂吗
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【MySQL系列】-回表、覆盖索引真的懂吗 文章目录 【MySQL系列】-回表、覆盖索引真的懂吗一、MYSQL索引结构1.1 索引的概念1.2 索引的特点1.3 索引的优点1.4 索引的缺点 二、B-Tree与B+Tree2.1 B-Tree2.2 B+Tree2.3 B-Tree 与B+Tree树的区别2.4 那么为什么InnoDB的主键最好要搞成有序的？ 三、回表查询3.1 InnoDB 聚集索引3.2 InnoDB非聚集索引3.3 InnoDB回表 四、覆盖索引五、最左前缀原则六、索引失效七、索引下推 在面试时常会被问一些概念性的东西。这些内容其实在开发中比较少用，但是为了显示你的知识储备你必须学习。博主最近在考Mysql认证时，也常碰到这样的问题。整理MySQL概念输出这篇博文。 一、MYSQL索引结构 1.1 索引的概念 MYSQL官方对索引的定义为：索引（Index）是帮助MySQL提高获取数据的数据结构。索引的本质是数据结构。可以简单理解为"预先排好一组能快速查询的数据结构"。这些数据结构以某种方式指向数据，可以通过这些数据结构实现高级查询算法。
1.2 索引的特点 索引一个排序的数据结构可以加速数据库的检索速度。索引降低了数据库Insert、Update、Delete等维护任务的难度MySQL索引只能创建在表上，不能创建在视图上。查询处理器执行SQL语句，一个表上，一次只能使用一个索引 1.3 索引的优点 提高数据检索的效率，降低数据库的IO成本创建唯一性的索引，保证数据库表中每一行数据的唯一性。加速表和表之间的连接。在使用分组和排序子句进行数据检索时，可以显著减少查询中分组和排序的时间。 1.4 索引的缺点 创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，降低了数据的维护速度 二、B-Tree与B+Tree 2.1 B-Tree B-Tree及为B树。B树是一种自平衡的树，能够保持数据有序。这种数据结构能够让查询数据，顺序访问、插入数据及删除的动作，都在对数时间内完成。B数概况来说是一个一般化的二叉查找树，可以拥有多于2个子节点。与自平衡二叉查找树不同，B树为系统大块数据的读写操作做了优化。B树减少定位记录时所经历的中间过程，从而加快存取速度。B树这种数据结构可以用来描述外部存储。
2.2 B+Tree B+Tree是B-Tree的一种优化。节点上只存储键值，不存储数据。这样的设计在有限的节点空间（页空间）内可以存放更多的键值、指针。所有数据都存放在叶子节点中，所有叶子节点之间有链指针（双向循环列表），便于范围查询，也便于排序。
2.3 B-Tree 与B+Tree树的区别 B-Tree 中，所有节点都会带有指向具体记录的指针；B+Tree 中只有叶子结点会带有指向具体记录的指针。B-Tree 中不同的叶子之间没有连在一起；B+Tree 中所有的叶子结点通过指针连接在一起。B-Tree 中可能在非叶子结点就拿到了指向具体记录的指针，搜索效率不稳定；B+Tree 中，一定要到叶子结点中才可以获取到具体记录的指针，搜索效率稳定。 B+Tree 中，由于非叶子结点不带有指向具体记录的指针，所以非叶子结点中可以存储更多的索引项，这样就可以有效降低树的高度，进而提高搜索的效率。
B+Tree 中，叶子结点通过指针连接在一起，这样如果有范围扫描的需求，那么实现起来将非常容易，而对于 B-Tree，范围扫描则需要不停的在叶子结点和非叶子结点之间移动。
2.4 那么为什么InnoDB的主键最好要搞成有序的？ InnoDB中主键索引是聚集索引，所有数据都存在主键索引所在的聚集索引的B+Tree结构的叶子节点中。如果每次插入的主键是大小随机的话，每次数据进来找到的叶子节点的位置是随机的，这样的话，有些叶子节点所在页本来就排满了，结果又来了一条数据，就势必要引起页分裂，所以导致性能下降；但是如果主键是有序的话，每次进行都找到当前叶子前面的位置，一个一个叶子按顺序排满一个页再排一个页，就不会又页分裂的问题了。所以自增主键对于InnoDB这种使用B+Tree索引的存储引擎来说，性能更好。
三、回表查询 回表查询就是在数据查询过程中MySQL内部需要两次查询。既先定位查询数据所在表的主键值，在根据主键定位行记录。
要弄清楚回表查询，我们就要先从InnoDB的索引实现说起，InnoDB索引分为两大类：聚集索引（Clustered Index）和普通索引（Secondary Index）
3.1 InnoDB 聚集索引 聚集索引是索引结构和数据一起存放的索引。主键索引为聚集索引。
InnoDB聚集索引的叶子节点存储行记录，因此InnoDB 必须要有且只有一个聚集索引。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/83b174c40c9a01a1104755875f3d9067/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4fa828ec6cb3e73760d75afc9f4e2419/" rel="bookmark">
			微信支付接口返回的连接动态生成二维码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		.1 安装必要的库 npm install qrcode 2. 从后端获取微信支付二维码链接 你需要从后端获取微信支付二维码链接。这通常涉及到与微信支付API的交互，但这部分通常由后端处理。以下是一个简化的示例，展示如何使用axios发送POST请求到后端，并从响应中获取二维码链接：(连接一般是weixin://wxpay//XXX
)
import axios from 'axios'; async function getWeChatPayLink(orderId) { try { const response = await axios.post('/api/wechat-payment', { orderId }); return response.data.payLink; // 根据你的API响应调整这里 } catch (error) { console.error('Failed to get pay link:', error); throw error; } } 3. 在Vue组件中生成二维码并显示在弹窗中 我们使用qrcode库来生成二维码并在Vue组件中显示。
&lt;template&gt; &lt;div&gt; &lt;!-- 按钮触发支付二维码弹窗 --&gt; &lt;button @click="generateQRCode"&gt;支付&lt;/button&gt; &lt;!-- 二维码弹窗 --&gt; &lt;div v-if="showQRCodeModal" class="qr-code-modal"&gt; &lt;img :src="qrCodeImage" alt="微信支付二维码" /&gt; &lt;button @click="closeModal"&gt;关闭&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import axios from 'axios'; import QRCode from 'qrcode'; export default { data() { return { qrCodeImage: '', showQRCodeModal: false, }; }, methods: { async generateQRCode() { try { const payLink = await getWeChatPayLink('your-order-id'); // 将'your-order-id'替换为你的订单ID const dataUrl = await QRCode.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4fa828ec6cb3e73760d75afc9f4e2419/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29b85ba8c8e72401135ce82d0fe817cd/" rel="bookmark">
			ByteBuffer 使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ByteBuffer 使用 1 java.nio包中的类定义的缓冲区类型2 缓冲区常用属性2.1缓冲区的容量(capacity)2.2 缓冲区的位置(position)2.3 缓冲区的限制(limit)2.4 缓冲区的标记(mark)2.5 剩余容量 remaining/hasRemaining 3 缓冲区常用方法3.1 创建缓冲区3.1.1 allocate方法3.1.2 wrap通过封装数组来创建缓冲区 3.2 创建视图缓冲区3.3. 复制缓冲区 duplicate3.4 切分缓冲区slice3.5 标记和重置mark和reset3.6 翻转flip3.7 清除clear3.8 压缩compact3.9 rewind(倒回)3.10 写数据3.11 读数据 4 常用使用方式4.1 读写范式4.2 与字符串之间的转换 参见java7入门经典 1 java.nio包中的类定义的缓冲区类型 类描述ByteBuffer用来存储 byte 类型值的缓冲区，也可以在这种缓冲区中存储任意其他基本类型的进制值(boolean 类型除外)。存储的每个二进制值在缓冲区中占据的字节长度根据类型长度决定char 或short 类型值占据2字节int 类型值占据4字节，等等CharBuffer只存储char类型值的缓冲区ShortBuffer只存储short 类型值的缓冲区IntBuffer只存储int类型值的缓冲区LongBuffer只存储 long 类型值的缓冲区Doublebuffer只存储double类型值的缓冲区 虽然有不同的类可以定义缓冲区，但是只使用 BvteBuffer 类型的缓冲区来读写其他类型的缓冲区被称为视图缓冲区，因为通常将它们创建为已有 ByteBuffer 类型缓冲区的视图视图缓冲区提供了一种容易的方式可以将各种类型的数据项从 ByteBuffer 中读出或者写入到其中
2 缓冲区常用属性 2.1缓冲区的容量(capacity) 缓冲区的容量是指缓冲区所能包含的值的最大数目而不是字节数目(除ByteBuffer外)创建缓冲区时，缓冲区的容量是固定的并且不能在随后进行修改。通过调用从 Buffer 类继承而来的 capacity0方法，可以获取 int 类型的缓冲区对象的容量。
2.2 缓冲区的位置(position) 位置（position）是指可用于读或写的下一个缓冲区元素的索引位置
2.3 缓冲区的限制(limit) 限制（limit）是指缓冲区中第一个不应该被读或写的值的索引位置，所以从 position 所指的元素到 limit-1所指的元素都可以被读取或写入。如果想要填充缓冲区，位置必须是零，因为这是第一个数据项所要存储的位置，而且限制必须等于缓冲区的容量，因为最后一个数据项必须存储到缓冲区的最后一个元素中，值为 capacity-1。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29b85ba8c8e72401135ce82d0fe817cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d164949a1a6b029d99089acd1dbe8a2f/" rel="bookmark">
			python virtualenv 如何更改mkvirtualenv默认新建虚拟环境的路径？WORKON_HOME
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		虚拟环境默认存c盘，日后可能会变得超大，c盘直接见红，怎么才能更改虚拟环境的默认存放位置呢？
①先新建要存放虚拟环境的文件夹
②然后打开我的电脑——属性——高级系统设置——环境变量，在系统变量里添加这个WORKON_HOME变量，然后将刚才的文件夹路径填进去
③然后重启电脑，系统变量即可生效
20230816
文章目录 改变Python Virtualenv的默认虚拟环境路径背景知识更改默认虚拟环境路径临时更改路径永久更改路径 参考文章 改变Python Virtualenv的默认虚拟环境路径 在这篇文章中，我们将讨论如何更改Python Virtualenv工具mkvirtualenv默认新建虚拟环境的路径。这个功能对于需要在特定位置管理所有虚拟环境的开发者来说非常有用。
背景知识 Virtualenv是Python的一个非常强大的库，它可以创建独立的Python运行环境。这就意味着你可以在同一台机器上安装和运行不同版本的Python以及各种库，而不会互相干扰。
mkvirtualenv是Virtualenvwrapper工具集中的一个命令，它提供了一种简单易用的方式来创建和管理Virtualenv环境。默认情况下，mkvirtualenv会在用户的主目录下创建一个名为.virtualenvs的文件夹，并在其中创建新的虚拟环境。
更改默认虚拟环境路径 要更改mkvirtualenv的默认虚拟环境路径，需要修改环境变量WORKON_HOME。这个环境变量定义了mkvirtualenv新建虚拟环境的默认路径。
临时更改路径 打开终端，输入以下命令：
export WORKON_HOME=/path/to/your/directory 这条命令会将新的路径暂时保存在当前的Shell会话中。如果关闭终端或开始新的Shell会话，这个设置就会失效。
永久更改路径 如果想要永久更改默认的虚拟环境路径，那么需要将上述命令添加到bash或zsh的配置文件中。
对于bash用户，在~/.bashrc文件中添加以下代码：
export WORKON_HOME=/path/to/your/directory 对于zsh用户，在~/.zshrc文件中添加以下代码：
export WORKON_HOME=/path/to/your/directory 然后，重新加载配置文件，或关闭并重新打开终端，新的设置就会生效。
参考文章 Virtualenv DocumentationVirtualenvwrapper Documentation ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b499d6f75ba181a4eb8e7ef20c994a3/" rel="bookmark">
			用MASM32编程更新sysInfo的一些收获
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		近日正在更新用MASM32编写的sysInfo，通过WMI访问Win32_UserCount来获取系统用户帐号信息，访问Win32_Product来获取系统中安装的产品信息。
在进行更新过程中，有一些新的收获跟大家分享。
一、HTML+JavaScript构建C++类代码一键转换MASM32代码平台 在MASM32中使用WMI访问这些对象及其成员，必须用Unicode DW 字符串。比如要访问Win32_Product对象：
[Provider("MSIProv"), Dynamic] class Win32_Product : CIM_Product { uint16 AssignmentType; string Caption; string Description; string IdentifyingNumber; string InstallDate; datetime InstallDate2; string InstallLocation; sint16 InstallState; string HelpLink; string HelpTelephone; string InstallSource; string Language; string LocalPackage; string Name; string PackageCache; string PackageCode; string PackageName; string ProductID; string RegOwner; string RegCompany; string SKUNumber; string Transforms; string URLInfoAbout; string URLUpdateInfo; string Vendor; uint32 WordCount; string Version; }; 那对象名称Win32_Product要定义为：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b499d6f75ba181a4eb8e7ef20c994a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f1a78ab5fa9a2b68f294884dc95fb65/" rel="bookmark">
			linux shell脚本执行命令时创建子进程问题（特定的情况，例如后台运行、管道、分支或子shell等，脚本可能会创建子进程执行命令）grep
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Shell脚本在执行每个命令时，不一定会创建子进程。
在大多数情况下，每条命令都在主进程中依次执行，不会创建子进程。
但是，当遇到特定的情况，例如后台运行、管道、分支或子shell等，脚本可能会创建子进程。
我说怎么在执行ps -ef | grep的过程中去grep脚本名，就会多一个进程。。。
20230816
文章目录 Linux Shell脚本中创建子进程后台运行管道分支子shell Linux Shell脚本中创建子进程 Linux shell脚本执行命令时，往往会创建子进程来执行特定的任务。这种行为在多种情况下发生，例如后台运行、管道、分支或子shell等。在本文中，我们将深入探讨这些情况以及如何使用grep命令。
后台运行 在Linux系统中，我们可以通过在命令后加上&amp;符号将其置于后台运行，此时系统会为该命令创建一个新的子进程。
command &amp; 例如，如果我们希望在后台查找含有特定字符串的文件，可以使用以下命令：
grep -r "pattern" /path/to/directory &amp; 这样，grep命令就会在后台执行，而用户则可以继续在前台执行其他命令。
管道 管道（pipe）是一种将多个命令连接起来的方式，每个命令的输出都作为下一个命令的输入。每一个管道命令都在其自己的子进程中运行。
command1 | command2 例如，如果我们想要查找含有特定字符串的文件，然后计算这些文件的数量，可以使用以下命令：
grep -rl "pattern" /path/to/directory | wc -l 在这个例子中，grep命令和wc命令都在各自的子进程中运行，并通过管道进行通信。
分支 在Shell脚本中，我们可以使用分支（branch）结构来根据特定条件执行不同的命令。每个分支都在其自己的子进程中运行。
if [ condition ]; then command1 else command2 fi 例如，我们可以编写一个脚本，根据是否存在含有特定字符串的文件，来执行不同的命令：
if grep -q "pattern" /path/to/file; then echo "Pattern found." else echo "Pattern not found." fi 在这个例子中，grep命令在一个子进程中运行，echo命令在另一个子进程中运行。
子shell 在Shell脚本中，我们可以创建子shell来执行一组命令。子shell是当前shell的复制品，拥有自己的环境变量、工作目录等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f1a78ab5fa9a2b68f294884dc95fb65/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c5233fc01cd8bb2f13929a9c3fcf6b9/" rel="bookmark">
			Unity 鼠标实现对物体的移动、缩放、旋转
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 代码2. 测试场景 1. 代码 using UnityEngine; public class ObjectManipulation : MonoBehaviour { // 缩放比例限制 public float MinScale = 0.2f; public float MaxScale = 3.0f; // 缩放速率 private float scaleRate = 1f; // 新尺寸 private float newScale; // 射线 private Ray ray; private RaycastHit hitInfo; private bool isDragging = false; private Vector3 offset; // 旋转 private float rotationSpeed = 5.0f; private void OnMouseDown() { isDragging = true; offset = gameObject.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c5233fc01cd8bb2f13929a9c3fcf6b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da7d3229cf2c2a4b784c2163f0919b26/" rel="bookmark">
			NodeJs导出PDF
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（优于别人，并不高贵，真正的高贵应该是优于过去的自己。——海明威） 场景 根据订单参数生成账单PDF
结果 示例代码 /* eslint-disable no-unused-vars */ /* eslint-disable no-undef */ /* eslint-disable complexity */ const PDFDocument = require('pdfkit'); const fs = require('fs'); const dayjs = require('dayjs'); const AgencyWithdrawOrderStatus = { Completed: 'Completed', Submitted: 'Submitted', Rejected: 'Rejected', } const agencyName = 'Jasin'; const agencyEmail = 'pdfkit@dev.com'; const order = { "id": "FI-AWO-20230718-8657637839", "accountID": { "id": "ID-AGE-20230707-6351711990", "type": "AGENCY" }, "transactionNo": "FIAWO202307180650601146", "referenceID": "", "transferWay": "Bank card", "walletID": "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da7d3229cf2c2a4b784c2163f0919b26/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7689f1bc88d82738099ed0af7cc23708/" rel="bookmark">
			springboot文件上传配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		springboot文件上传配置
前言 小兄弟在做文件上传时，发现文件超过1M报错了。没加配置！
于是赶紧加上文件上传的配置，配置成下面
servlet: multipart: enabled: true max-request-size: 50MB max-file-size: 50MB 文件小于50M的时候，文件上传ok. 满心欢喜的下班走人。
问题 在某天文件上传刚刚好50M大小的文件时暴雷了，提示如下
the request was rejected because its size (52429346) exceeds the configured maximum (52428800)
分析 max-file-size 指定上传文件允许的最大大小。 默认值为1MB
max-request-size 指定multipart/form-data请求允许的最大大小。 默认值为10MB。
文件确实为50M，没有超过限制，怎么还提示报错呢？
提示请求大小超过限制，一看报错的上传请求中包含了一些业务参数，不仅仅是文件。
于是看了一眼现有配置，发现问题。文件大小50M+业务参数，大于了max-request-size配置的大小，导致报错。
当2个配置大小一样时，就出现问题了。
原来是想着最大支持50M的文件上传，但是极有可能有些上传请求会附加额外的业务参数，这样就容易导致请求大小超过了设置的大小。
小兄弟图省事，一顿复制。没有细看配置的含义，导致问题。
修改 max-request-size 配置大小时要比max-file-size大，多出来的空间就可以传递参数。
spring: servlet: multipart: max-file-size: 50MB #上传文件大小上限50MB max-request-size: 55MB 上传文件大小限制为50M，单次请求限制大小为55M。
这下OK了。文件大小还是限制为50M，预留了5M的额外业务参数空间。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9b2e1c0d2eb1977edec1c8cbd76bbf9/" rel="bookmark">
			ansible的三种安装方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法一、通过本地yum源安装 centos 使用默认的yum源安装 ——&gt; ansible-core
rhel yum 源安装 ——&gt; ansible
这里实验用的是2.9的版本
ansible的安装文件 Index of /ansiblehttps://releases.ansible.com/ansible/ ansible依赖与python它是通过python进行开发的
[root@rhce ~]# lsblk //查看是否连接成功
NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT
sr0 11:0 1 9.4G 0 rom /media
sr1 11:1 1 22.6M 0 rom /run/media/root/ytlab-ansible2.9_for-RHEL8.
nvme0n1 259:0 0 100G 0 disk ├─nvme0n1p1 259:1 0 512M 0 part /boot
├─nvme0n1p2 259:2 0 6G 0 part [SWAP]
└─nvme0n1p3 259:3 0 93.5G 0 part /
[root@rhce ~]# mkdir /ansible_repo //建立挂载点 [root@rhce ~]# mount /dev/sr1 /ansible_repo/
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d9b2e1c0d2eb1977edec1c8cbd76bbf9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb7b1fcad5dea3b40a0545b2b4a969c3/" rel="bookmark">
			Ubuntu开机自动挂载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通过sudo fdisk -l命令查看分区，确定我们要将/dev/sda1磁盘挂载到/mnt/usb中
1.创建挂载目录：sudo mkdir /mnt/usb
2.挂载：sudo mount /dev/sda1 /mnt/usb
3.查询挂载硬盘UUID：sudo blkid /dev/sda1
返回如下信息：
/dev/sda1: UUID=“8B0C-F55F” TYPE=“vfat”
4.修改**/etc/fstab**文件：sudo gedit /etc/fstab
在文档末尾添加磁盘信息，格式为：
UUID=xxx 挂载磁盘分区 挂载磁盘格式 0 2
我们添加：
UUID=8B0C-F55F /mnt/usb vfat defaults 0 2
第一个数字：0表示开机不检查磁盘，1表示开机检查磁盘
第二个数字：0表示交换分区，1代表Linux启动分区，2表示普通分区
挂载完成
卸载：
umount 设备文件名或挂载点
umount /dev/sda1或umount /mnt/usb
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d38c2723fa1bcb67b8823d1379d760d/" rel="bookmark">
			前端基础（HTML）——html介绍 &amp; 常用标签 &amp; 几个案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 引出一、概述1.1 HTML是什么？1.2 网页的组成部分1.3 页面中的元素 二、创建HTML文件三、HTML骨架四、常用的标签4.1 排版标签4.1 排版案例4.2 图片【重点】4.2 图片案例（音视频）4.3 超链接【重点】4.3 超链接案例4.3 招聘网站案例4.4 列表标签（了解）4.5 表格标签【重点】4.5 表格合并案例4.6 表单标签【重要】4.6 表单标签案例4.7 语义化标签4.8 **iframe** 框架标签【内嵌窗口】4.9 字符实体 五、案例-健康码1.二维码页面2.更新信息页面 总结 引出 html是啥，常见的标签，几个例子
一、概述 1.1 HTML是什么？ Hyper Text Markup Language (超文本标记语言) 简写:HTML，HTML 通过标签来标记要显示的网页中的各个部分。网页文件本身是一种文本文件， 通过在文本文件中添加标记符，可以告诉浏览器如何显示其中的内容(如:文字如何处理，画面如何安排，图片如何显示等)
1.2 网页的组成部分 页面由三部分内容组成，
分别是内容(结构)、表现、行为。
内容(结构)，是在页面中可以看到的数据。称之为内容。一般内容 使用 html 技术来展示。
表现，指的是这些内容在页面上的展示形式。比如。布局，颜色，大小等等。一般使用 CSS 技术实现
行为，指的是页面中元素与输入设备交互的响应。一般使用 javascript 技术实现。
示例：
x &lt;button type="button" style="background: #7ED321;width: 80px;height: 40px;color: #ffffff" onclick="alert('题目还未答完')"&gt;提交答案&lt;/button&gt; 1.3 页面中的元素 文字显示，图片，按钮，输入框
输入框，多选框，下拉框
表格，多选框，按钮
二、创建HTML文件 写html用一般的文字编辑器都可以，也可以使用专业的工具，Hbuilder,webstorm ,VScode等；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d38c2723fa1bcb67b8823d1379d760d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad9687de6628ef706d41eb20737b4dba/" rel="bookmark">
			Python 协程详解，都在这里了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		嗨害大家好鸭！我是小熊猫~ 什么是协程 协程（co-routine，又称微线程、纤程）
是一种多方协同的工作方式。
协程不是进程或线程，其执行过程类似于 Python 函数调用，
Python 的 asyncio 模块实现的异步IO编程框架中，
协程是对使用 async 关键字定义的异步函数的调用。
当前执行者在某个时刻主动让出（yield）控制流，
并记住自身当前的状态，
以便在控制流返回时能从上次让出的位置恢复（resume）执行。
一个进程包含多个线程,
类似于一个人体组织有多种细胞在工作，
同样，一个程序可以包含多个协程。
多个线程相对独立，
线程的切换受系统控制。
同样，多个协程也相对独立，但是其切换由程序自己控制。
简而言之，协程的核心思想就在于执行者对控制流的 “主动让出” 和 “恢复”。
相对于，线程此类的 “抢占式调度” 而言，
协程是一种 “协作式调度” 方式，
协程之间执行任务按照一定顺序交替执行。
源码、素材python永久安装包:点击此处跳转文末名片获取
Python 对协程的支持经历了多个版本： Python2.x 对协程的支持比较有限，通过 yield 关键字支持的生成器实现了一部分协程的功能但不完全。
第三方库 gevent 对协程有更好的支持。
Python3.4 中提供了 asyncio 模块。
Python3.5 中引入了 async/await 关键字。
Python3.6 中 asyncio 模块更加完善和稳定。
Python3.7 中内置了 async/await 关键字。
gevent 是对greenlet进行的封装，
而greenlet 又是对yield进行封装。
一、协程实现方法： 1、greenlet，早期模块 greenlet包是一个Stackless（无栈化的）CPython版本，支持微线程（tasklet)。tasklet可以伪并行的运行并且同步的在信道上交换数据
①首先要先安装greenlet模块
pip install greenlet from greenlet import greenlet ###免费领python源码籽料qun：5403 05994 def func1(): print(1) # 第1步 输出1 # 该方法遇到阻塞可以切换到函数2中进行使用 gr2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad9687de6628ef706d41eb20737b4dba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f57d50652f4aa313bef6abb58489905/" rel="bookmark">
			大数据hudi之集成spark:spark-shell 方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 启动 spark-shell插入数据查询数据更新数据增量查询指定时间点查询删除数据覆盖数据 启动 spark-shell 1）启动命令
#针对Spark 3.2 spark-shell \ --conf 'spark.serializer=org.apache.spark.serializer.KryoSerializer' \ --conf 'spark.sql.catalog.spark_catalog=org.apache.spark.sql.hudi.catalog.HoodieCatalog' \ --conf 'spark.sql.extensions=org.apache.spark.sql.hudi.HoodieSparkSessionExtension' 2）设置表名，基本路径和数据生成器
import org.apache.hudi.QuickstartUtils._ import scala.collection.JavaConversions._ import org.apache.spark.sql.SaveMode._ import org.apache.hudi.DataSourceReadOptions._ import org.apache.hudi.DataSourceWriteOptions._ import org.apache.hudi.config.HoodieWriteConfig._ val tableName = "hudi_trips_cow" val basePath = "file:///tmp/hudi_trips_cow" val dataGen = new DataGenerator 不需要单独的建表。如果表不存在，第一批写表将创建该表。
插入数据 新增数据，生成一些数据，将其加载到DataFrame中，然后将DataFrame写入Hudi表。
val inserts = convertToStringList(dataGen.generateInserts(10)) val df = spark.read.json(spark.sparkContext.parallelize(inserts, 2)) df.write.format("hudi"). options(getQuickstartWriteConfigs). option(PRECOMBINE_FIELD_OPT_KEY, "ts"). option(RECORDKEY_FIELD_OPT_KEY, "uuid"). option(PARTITIONPATH_FIELD_OPT_KEY, "partitionpath"). option(TABLE_NAME, tableName). mode(Overwrite). save(basePath) RECORDKEY_FIELD_OPT_KEY：每条记录的唯一ID,支持多个字段
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f57d50652f4aa313bef6abb58489905/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9fe7936baaaca1a50e3885517be69517/" rel="bookmark">
			vue照片悬浮
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 使用el-popover模块
&lt;el-table-column prop="title" label="广告标题"&gt; &lt;template slot-scope="scope"&gt; &lt;el-popover placement="top-start" width="200" trigger="hover"&gt; &lt;img :src="scope.row.imageUrl" alt="" width="200px" /&gt; &lt;el-button slot="reference"&gt;{{ scope.row.title }}&lt;/el-button&gt; &lt;/el-popover&gt; &lt;/template&gt; &lt;/el-table-column&gt; 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/99/">«</a>
	<span class="pagination__item pagination__item--current">100/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/101/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>