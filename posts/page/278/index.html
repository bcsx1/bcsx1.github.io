<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d86f3d0c138dc4f86f5722a8c578607/" rel="bookmark">
			modelsim脚本化仿真总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		modelsim脚本化仿真总结 Modelsim 相对于vivado自带的仿真器，仿真起来更快，效率更高，但是仿真带有IP核的文件时，需要额外加载对应的库文件，这一步容易搞混，导致仿真失败，之前也有总结过，这个月在用的时候算是弄清楚了来龙去脉，下面来总结一下使用Modelsim脚本仿真的流程。
1.1 modelsim 脚本框架
脚本在启动之后就可以自动执行了，效率比较高，不需要人为再操作GUI界面。下面是一个典型的modelsim脚本框架。
vlib work 该命令的作用是在该目录下建立一个work目录。
vmap work work 该命令的作用是将目前的逻辑工作库work和实际工作库work映射对应。
vlog *.v 是编译当前目录下的所有verilog文件。
vsim 是启动仿真，-novopt是禁止modelsim优化，这样可以防止modelsim优化掉一些比较重要的信号。-gui则是以gui模式(也就是有界面)打开仿真。work. 后面接的就是仿真顶层文件的名字。
上面这个框架在设计中没有IP核的前提下，是完全可以套用的。当设计中存在IP核时，仿真所需的文件就可以分为如下几类：设计文件、仿真文件、IP的仿照网表文件（通常文件名为xxxxxxsim.v或者sim_netlist.v）、IP核相关的库文件。
设计文件和仿真文件与上面的框架中基本一样，仿真文件有时候可能是System verilog文件，编译时，应写为vlog .sv。
IP核的仿真网表文件一般在工程相应的文件夹中，Vivado的相应路径为
IP核相关的库文件一般需要专门生成，Vivado 生成IP库文件的步骤可以参考这个链接https://blog.csdn.net/shuwei1990/article/details/116748672
在完成上述步骤后，将设计文件，仿真文件，IP核网表文件进行编译（在脚本中使用vlog 指令，这里可以将设计文件，仿真文件，IP核网表文件分别放在不同的文件夹），同时加载IP核的相应仿真库文件（-L指令，后面是相应的IP库文件路径）如下图所示：
注意要将工作路径切换到对应路径上（使用cd指令）。编写完后保存为do文件（如sim_all. do）。
然后将此do文件用modelism打开，打开后在modelsim命令行中输入：do xxxx.do后按回车，便可以按照脚本所编写的内容进行仿真。如下所示：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9a84968d5a91f6d21f2019cb1010f79/" rel="bookmark">
			leetCode_28. 实现 strStr()
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		leetcode_28. 实现 strStr() 一、题目描述 实现 strStr() 函数。
给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回 -1 。
说明：
当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。
对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与 C 语言的 strstr() 以及 Java 的 indexOf() 定义相符。
示例 1： 输入：haystack = "hello", needle = "ll" 输出：2 二、思路 indexOf() 方法有以下四种形式：
public int indexOf(int ch): 返回指定字符在字符串中第一次出现处的索引，如果此字符串中没有这样的字符，则返回 -1。
public int indexOf(int ch, int fromIndex): 返回从 fromIndex 位置开始查找指定字符在字符串中第一次出现处的索引，如果此字符串中没有这样的字符，则返回 -1。
int indexOf(String str): 返回指定字符在字符串中第一次出现处的索引，如果此字符串中没有这样的字符，则返回 -1。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e9a84968d5a91f6d21f2019cb1010f79/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a0cc79929d65d847e279fea03a874ec/" rel="bookmark">
			详解TCP的三次握手
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TCP定义及特点 定义 TCP是一种面向连接（连接导向）的、可靠的基于字节流的传输层通信协议。TCP将用户数据打包成报文段，发送后会启动一个定时器，然后另一端收到的数据进行确认、对失序的数据重新排序、丢弃重复数据
特点 TCP是面向连接的传输控制层协议每一条TCP连接只能有两个端点，每一条TCP连接只能是点对点的TCP提供可靠交付的服务TCP提供全双工通信。数据在两个方向上独立的进行传输，因此，连接的每一端必须保持每个方向上的传输数据序号。面向字节流。面向字节流的含义：虽然应用程序和TCP交互是一次一个数据块，但应用程序交下来的数据仅仅是一连串的无结构的字节流 TCP报文 在开始三次握手之前，看下TCP报文的数据结构
TCP首部TCP数据部分
着重看TCP头部结构，如下
了解一下什么是序列号和确认号
Sequence number 表示的是我方（发送方）这边，这个packet的数据部分的第一位应该在整个data stream中所在的位置。（注意这里使用的是“应该”。因为对于没有数据的传输，如ACK，虽然它有一个seq，但是这次传输在整个data stream中是不占位置的。所以下一个实际有数据的传输，会依旧从上一次发送ACK的数据包的seq开始）
Acknowledge number 表示的是期望的对方（接收方）的下一次sequence number是多少，一旦连接建立成功，ACK值一直为1。
三次握手 三次握手（Three-way Handshake）其实就是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备。
第一次握手：标志位SYN = 1，随机生成一个序列号seq1 = x
第二次握手：标志位SYN ,ACK = 1，确认号ack = x + 1，随机生成一个序列号seq2=y
第三次握手：标志位ACK = 1, 确认号ack = y + 1，seq2= x + 1
SYN/FIN的传输虽然没有data，但是会让下一次传输的packet seq增加一，但是，对于ACK的传输，不会让下一次的传输packet加一，也就是说，下一个实际有数据的传输，依旧从上一次发送ACK的数据包的seq开始计算
网络抓包分析 上面给了具体的连接过程，但是偏理论，下面实战一下，通过抓包进行分析
具体查看每一次握手都做了什么（主要看序列号，确认号）
有图有真相，不怕你不信
参考链接：https://www.jianshu.com/p/15754b4e9458
常见问题 问题一：为什么不是两次握手，而是三次握手
前两次握手客户端可以确认服务端的接收和发送是正常的（一个来回），但是服务端却不知道客户端的发送能力是否正常，那 TCP 的可靠性就无从谈起，所以需要第三次握手来确认双方的收发能力，以确保TCP连接的可靠性。
问题二：TCP的三次握手都可以携带数据吗？如果不是，那么哪一次握手可以携带数据，其他的为啥不能携带数据？
假设第一次握手客户端携带数据到服务器，服务器解析并存储此次连接的信息，如果数据量大，服务端就要分配足够的内存来进行存储，假如有黑客while（1000000000）来新建连接，结果可想而知，服务器将会被占用大量的内存。
第三次握手，此时对于客户端来说，连接已经建立，客户端携带数据完全没有问题
问题三：传输的过程中，报文丢失了怎么办
第一次握手报文丢失 客户端发送 SYN 报文，然后进入到 SYN_SENT 状态。 客户端迟迟收不到服务端的 SYN-ACK 报文，就会触发客户端的超时重传机制。 在 Linux 里，客户端的 SYN 报文最大重传次数由/proc/sys/net/ipv4/tcp_syn_retries内核参数控制，这个参数是可以自定义的，默认值一般是 5。每次超时的时间是上一次的 2 倍。当第五次超时重传后，会继续等待 32 秒，如果服务端仍然没有回应 ACK，客户端就不再发送 SYN 包，然后断开 TCP 连接。 第二次握手报文丢失 第二次握手时，服务端会进入 SYN_RCVD 状态 客户端角度：客户端第一次握手发出去的报文没有得到回复，那么客户端就会觉得自己的 SYN 报文丢失，于是客户端就会触发超时重传机制，重传 SYN 报文。 服务端角度：发送SYN_ACK报文后将会开启一个定时器，如果报文没有得到回应，就会触发超时重传机制，重传 SYN-ACK 报文，重传的次数由/proc/sys/net/ipv4/tcp_synack_retries控制，默认是5次。 第三次握手报文丢失 服务端角度：发送SYN_ACK报文后将会开启一个定时器，如果超过了定时器设置的时间都没有收到客户端的ACK，将会重发SYN_ACK包。由/proc/sys/net/ipv4/tcp_synack_retries控制，默认是5次。 客户端角度：此时非彼时，现在我是 ACK 报文，拥有独特的权限，所以我是不会重传的 问题四：什么情况下报文失效或丢弃
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a0cc79929d65d847e279fea03a874ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8a6c24c0368265e01ae8fd03e6e0079/" rel="bookmark">
			高云FPGA(二)：
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、管脚绑定 1，参考《SUG918_Gowin 云源软件快速入门指南》，3.3。详细《SUG935_设计物理约束》 2，生成的管脚约束文件为.cst 3，管脚绑定后如下： 二、专用管脚复用 1，绑定完管脚以后报错，说专用管脚不能做普通GPIO 2，参考《UG290_编程配置手册》，第5章。查询到这个管脚可以复用为普通GPIO 3， Project&gt;Configuration&gt;Dual-Purpose Pin 4，编译通过 三、解决vhdl语法编译报错 1，移植VHDL代码后报如下错： 2，在《SUG100_Gowin 云源软件》中找到支持vhdl的版本 3，找到默认选项 4，修改为VHDL 2008 5，编译通过 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24c1bb0063b6824568ec8ac84f7b0982/" rel="bookmark">
			Gson详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Gson 使用 对象转Json字符串 Json字符串转对象 字符串转List集合
字符串转Map集合
参考 Gson的基本使用 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e59ea1bcd628b85b1a4d72e3e935faaf/" rel="bookmark">
			[R]_从字符串中截取有用字段
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近解决字符串提取的问题，网上搜了一圈，没有很好的回答，不得不采用科学上网的方法，去stackoverflow上找回答，最后用str_match()解决了。另外，stringr包在处理字符串上还是很能打的，里面有不少好用的函数，大家遇到字符串处理问题时，可以阅读stringr的官方文档。
library("stringr") string&lt;-c("第一题","第二题","第三题","第四题","第五题") data&lt;-data.frame(string) 在这里我们想要把“一”，“二”，“三”，“四”，“五”提取出来，别问为什么，就是玩儿。
string_new&lt;-str_match(data$string,"第\\s*(.*?)\\s*题") 这时候我们会发现，返回的string_new其实是两列。
我们需要的其实是第二列，所以我们改一下代码
string_new&lt;-str_match(data$string,"第\\s*(.*?)\\s*题")[,2] 这时候我们就把需要的字段提取出来了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6dca23adf345fb76f5b21d1a52ef0ada/" rel="bookmark">
			coalesce，sql函数去判断查询出来的东西符合条件返回‘0’，否则返回1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 select lcaa.clmnum, COALESCE((SELECT 1 FROM clm_subtask_swfswti sub WHERE t.clmnum=sub.clmnum LIMIT 1),'0') AS iscleancase-- 是否清洁件 from clm_baseinfo_lcaa lcaa LEFT JOIN clm_worktask_swflwti t on lcaa.clmnum = t.clmnum and t.status = 1 where lcaa.status = 1 and lcaa.procecode='C' and lcaa.inspectflag is null and t.submitdte BETWEEN CAST(date_format(date_add(now(), interval - 1 day),'%Y%m%d') AS SIGNED integer) AND CAST(date_format(date_add(now(), interval - 1 day),'%Y%m%d') AS SIGNED integer) -- perid 是有效的督查规则那边传递过来的外包商id &lt;if test="perid!=null and perid!=''"&gt; and t.fircheckusr in (#{perid}) &lt;/if&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a4b63d158311576e76c3cc0ee7a81d5/" rel="bookmark">
			SVPWM模块为什么会出现扇区判断错误？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近有小伙伴问我，在输入给定速度为0的时候，为什么SVPWM总会报如下的错误？
翻译过来的意思就是控制输入的端口值7不在1和6之间， 为了抑制这个错误，你可以将设置窗口中的报错选项改成None。但是虽然是可以改设置窗口让他不报错，但是改了之后系统波形会出现跑飞的现象，这是指标不治本的，还是要从源头上对问题进行解决。电压空间矢量分布图如下图所示，在整个360°周期内存在6个扇区。
空间电压矢量的扇区仅有6个，那么出现端口值为7的现象，可推测是N的计算过程出现问题，书中对于扇区号N的计算如下图所示：
通过Ualpha和Ubeta计算出三个变量A、B、C的值，并通过 N = 4C + 2B + A 计算扇区号。当输入Ualpha和Ubeta全为0的时候，A = 0 、B = 1 、C = 1 ，因此 N = 4+2+1 = 7，从而超过扇区号的范围1-6，进而报错。仿真模型的搭建框图如下图所示，对其进行仿真后发现，确实会出现Ualpha = 0，Ubeta = 0时 N = 7的情况，由于Ualpha = 0，Ubeta = 0是变频器无任何输出的情况，从上图中空间电压矢量的分布图可看出，其实此时的电压空间矢量不属于任何扇区，他属于坐标系的原点（0,0)。因此这种特殊情况特殊处理即可，即加一个判断条件，当扇区号N = 7时，将其分配到N=1即可，因为没有电压矢量没有任何幅值，也不会对输出造成任何的影响。
加入判断条件最简单的方式就是写一个function函数，函数代码如下：
function y = fcn(u) %#codegen temp = u; if temp == 7 y = 1; else y = temp; end 加入后的框图如下：
然后系统就可以正常运行了。 ————————————————
版权声明：本文为CSDN博主「沉沙丶」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/sy243772901/article/details/123943675
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1af6f9c03f9d92b2289e2aa647f76e1f/" rel="bookmark">
			3秒换发型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先上几张图看效果
换发型的论文非常多了，比如LOHO，HairClip，StyleClip，Barbershop。其中，hairclip以及styleclip速度快，但只能指定特定类型发型，无法实现将Person B的发型包括细节搬到Person A。LOHO以及Barbershop可以一定程度上实现这种细节搬迁，但对于人脸不是对齐的情况效果不佳，另外相当耗时，Barbershop一张图片处理需要约10分钟上下。
对iOS App Store上的相关APP做了一番研究，其中有个名为B72的应用效果最佳。对它的方法作了一番调查，复现了上面的结果。大体思路参考Barbershop，对其中几个环节进行做了优化，
1. 首先提取参考人脸的相关特征，预先保存，并且不丢失头发细节，节省大量优化时间
2. 将原图的人脸pose对齐到参考图片的人脸，同时能解决人脸不对齐情况下效果问题
3. 对齐后的的目标人脸mask生成
4. 类似Barbershop在特定空间上进行融合
由于第一步是预先准备好的，整个pipeline走下来，主要时间花费在2，3，4，基本上3秒内完成换发型操作。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/702c24b3e2c8b352750badc51b6c2db6/" rel="bookmark">
			【linux kernel】对linux内核__init机制的实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、开篇 在linux内核源码中，随处都可以看见类似于__init这样的宏，如下代码片段：
# define __section(S) __attribute__ ((__section__(#S))) #define __init	__section(.init.text) 从上述代码片段可见，当使用__init宏修饰一个函数后，那么在进行编译构建过程中，会出现一些不一样的现象。
在比如说__setup宏，该宏定义如下代码片段所示【出自linux dir/include/init.h】：
#define __setup_param(str, unique_id, fn, early)	\ static const char __setup_str_##unique_id[] __initconst	\ __aligned(1) = str; \ static struct obs_kernel_param __setup_##unique_id	\ __used __section(.init.setup)	\ __attribute__((aligned((sizeof(long)))))	\ = { __setup_str_##unique_id, fn, early } #define __setup(str, fn)	\ __setup_param(str, fn, fn, 0) 综上所述
在代码中出现__attribute__和__section__这两个关键字，这两个关键字是实现该机制的基石，在分析了linux内核源码的实现机制后，本文就使用这两个宏来亲自实践该机制，以便加深理解。
二、实践过程 实践过程准备： （1）创建一个公用头文件：common_define.h （2）创建一个模块文件：module_1.c （3）创建第二个模块文件：module_2.c （4）创建一个主应用文件：app_demo.c （5）创建一个makefile文件 【2-1】各文件中内容如下：
/* common_define.h */
#ifndef COMMON_DEFINE_H #define COMMON_DEFINE_H typedef int (*init_call_fn)(void); #define __init __attribute__((unused,__section__("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/702c24b3e2c8b352750badc51b6c2db6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/475bb61c8db5539f5375ffc5915cbade/" rel="bookmark">
			verilog 时刻卡死，$time 不递增解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#verilog #问题记录 #已解决
verilog 时刻卡死，$time 不递增解决方案 先说结论， 在写testbench 时，需要注意在一些 always 中加上延时，避免某个 always 不间断的一直仿真运行，导致仿真时刻卡住，时刻不递增。
经过查阅一些资料，个人理解，iverilog 仿真为伪并发，所以某个时刻，多个块的执行会按照优先级执行，某个块执行结束切换到下一个块，这个时刻块执行结束换下一个块。如果某一个块一直占用一直循环会导致 time 无法增加，即仿真卡在这个时刻这个块。
（个人理解，若有实际有出入，感谢指出，先谢过）
现象， vvp 仿真卡在第 0 个时刻 起因是在写testbench 时候写了如下 ：
real CYCLE_200HZ = 5; initial in = 1'b1; always begin if(#time &gt;= 5) begin #(CYCLE_200HZ) in = ~in; end end 接着
调用 iverilog 编译生成.out 文件再 vvp xxx.out 进行仿真生成 .vcd 文件。调用 GTKwave 波形。 但是再第二步之后，vvp 进程一直没有返回，卡住。 按下 ctrl+C 暂停后，vvp 返回：
** VVP Stop(0) ** ** Flushing output streams.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/475bb61c8db5539f5375ffc5915cbade/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53692ae427fc6075d2462deb24e6415e/" rel="bookmark">
			C#获取系统毫秒时的方法（对应java的currentTimeMillis）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JDK1.7.0_45文档中对System.currentTimeMills()的描述：
Returns the current time in milliseconds. Note that while the unit of time of the return value is a millisecond, the granularity of the value depends on the underlying operating system and may be larger. For example, many operating systems measure time in units of tens of milliseconds.
See the description of the class Date for a discussion of slight discrepancies that may arise between “computer time” and coordinated universal time (UTC).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/53692ae427fc6075d2462deb24e6415e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbc205645de99fbb5e4097db52616e75/" rel="bookmark">
			Vue3使用vite-plugin-vue-setup-extend 不生效问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用 Vue3.2 的 setup 语法糖后，无法优雅的定义组件的 name 值，虽然 vite 会根据组件的文件名自动生成组件名，但是需要自定义的组件名时，就很不方便。
解决方法 方案1：写两个 script 标签 最简单的方法就是写两个script 标签，一个用 setup 语法，一个不用 setup 语法，代码如下：
&lt;script&gt; export default { name: 'demo' } &lt;/script&gt; &lt;script setup&gt; // do something... &lt;/script&gt; 这种方法简单，但确实不够优雅
方案2：使用 vite 插件 vite-plugin-vue-setup-extend 安装
npm i vite-plugin-vue-setup-extend -D
配置 vite.config.ts
import { defineConfig } from 'vite' import VueSetupExtend from 'vite-plugin-vue-setup-extend' export default defineConfig({ plugins: [ VueSetupExtend() ] }) 使用
&lt;script lang="ts" setup name="demo"&gt; &lt;/script&gt; 问题：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fbc205645de99fbb5e4097db52616e75/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ea8568c32934ca464efca2cb5f7bdbe/" rel="bookmark">
			8 hours golang
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 8 hours golanggo优势1.极简部署2.静态类型语言3.语言层面的并发4.强大的标准库5.简单易学6.大厂领军 go指令变量声明方式业务场景打出变量的数据类型 const与iota使用const定义枚举类型 函数返回值init函数与import导包匿名与别名导入 指针defer数组slicemap使用 struct面向对象中类的表示与封装面向对象中的继承面向对象中的多态interface空接口万能类型与类型断言机制变量的内置pair结构反射结构体标签taggoroutinechannelclose与range与select 其他 8 hours golang go优势 1.极简部署 可直接编译成机器码不依赖其他库直接运行即可部署 2.静态类型语言 编译期可查出大多数隐藏问题（go build a.go） 3.语言层面的并发 天生的基因支持充分利用多核 4.强大的标准库 runtime系统调度机制高效的GC垃圾回收丰富的标准库 5.简单易学 25个关键字C语言简洁基因，内嵌C语法支持面向对象特性（继承、封装、动态）跨平台 6.大厂领军 GoogleFacebook腾讯百度京东… go指令 go mod init projectname 初始化go项目go run hello.go或go build hello.go+./hello执行 变量声明方式 var a intvar b int = 100var c = 100e := 100（推荐）只能在函数体内使用，无法声明全局变量 声明多个变量
var xx, yy int = 100, 200
var kk, ll = 100, "abc"
var (
​ vv int = 100
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ea8568c32934ca464efca2cb5f7bdbe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/452e9ce88135b2f1f0ab4f939f9f1f6d/" rel="bookmark">
			flutter 获取当前屏幕宽高
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考一
参考二
1.系统提供的方法
这个方法可以得到当前控件的宽，高
final size =MediaQuery.of(context).size;
final width =size.width;
final height =size.height;
2.使用起来最简单的方法
使用这个方法，能够快速的得到屏幕的宽高
import ‘dart:ui’;
final width = window.physicalSize.width;
final height = window.physicalSize.height;
3.获取某个container的宽高
使用globalkey,但是只能在按钮点击的时候触发
final GlobalKey globalKey = GlobalKey();
container (
key: globalKey,
)
final width = globalKey.currentContext.size.width;
final height = globalKey.currentContext.size.height;
宽度可以用 // width: double.infinity,
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13f75811b732f232f889344299c471b9/" rel="bookmark">
			查找链表的中间节点(Java)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 获取链表的中间节点，这个题有两种解法。
方法一：先遍历一遍链表，求出链表的长度length，然后使用length/2获取链表的中间节点。
但是这个方法有一个弊端，我们需要遍历两遍链表。
方法二：快慢指针法，定义一个fast和一个slow。让fast的速度是slow速度的两倍，当fast到链表的最后一个节点位置时，slow就处于中间节点，这个时候，输出slow。
快慢指针法的图解：
快慢指针法的代码如下：
public Node middleNode(){ //当fast的速度是slow速度的两倍时，当fast走到最后一个节点时，slow出于中间位置。 Node fast=head; Node slow=head; while(fast!=null&amp;&amp;fast.next!=null){ fast=fast.next.next; slow=slow.next; } return slow; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6bc86754647db926a25947932c2f3453/" rel="bookmark">
			Vue父组件控制子组件里面某item的显示与隐藏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目场景： 知识产权模块
问题描述 子组件的新增和编辑弹窗共用，现需编辑弹窗隐藏文件上传
解决方案： &gt; 1.子组件点击编辑按钮： @click="handleEdit(record)" &gt; 2.在子组件methods中传递数据给父组件： this.$emit("handleEdit","编辑") &gt; 3.在父组件的子组件标签中接收： &lt;son @handleEdit="handleEdit" /&gt; &gt; 4.在父组件的data中定义显示与隐藏的初始值： fileHidden: true, &gt; 5.在父组件的methods中定义接收的方法根据参数判断显示与隐藏： &gt; handleEdit(index) { if(index == '编辑') { this.fileHidden = false } } &gt; 6.再把结果通过子组件标签反馈给子组件： &lt;son :fileHidden="fileHidden" /&gt; &gt; 7.在子组件里接收数据： props: ['fileHidden'], &gt; 8.在item上加 v-if="接收的数据": &lt;a-form-model-item label="文件" v-if="fileHidden"&gt;&lt;/a-form-model-item&gt; 效果：
具体实施： 父组件：
&lt;!-- 切换区域 --&gt; &lt;son @handleEdit="handleEdit" :fileHidden="fileHidden" /&gt; &lt;script&gt; // 子组件引入 import son from './son.vue' export default { components: {son} data() { return { fileHidden: true, } }, methods: { handleEdit(index) { if(index == '编辑') { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6bc86754647db926a25947932c2f3453/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74f6cf5e7a9c468762e06cf38a58b694/" rel="bookmark">
			华为[ENSP]生成树协议配置实例（STP）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 拓扑图如下：
一、启用和禁用STP
在SWA上启用和禁用STP，默认情况下STP是开启的。
stp disabled//手动关闭交换机的STP
stp enable//开启STP
二、修改交换机STP模式
同理，SWB配置与SWA一致。
1.修改桥优先级以控制根桥选举
在SWA上修改桥优先级，配置SWA为根桥。
stp priority 0//修改SWA的桥优先级为0，那么SWA具有最大可能性成为根交换机。
红色方框内显示了根交换机的信息，根桥是SWA，同时到达根桥的开销是20000。
2.修改端口优先级以控制根端口和指定端口的选举
dis stp brief//STP收敛后，SWB的G0/0/1端口成为根端口
在SWA上修改端口优先级，让SWB的G0/0/2端口被选举为根端口。在SWA上有两种调整方法：
将G0/0/1的端口优先级调大； 将G0/0/2的端口优先级调小 。
（1）将G0/0/1的端口优先级调得比128大（默认值为128）
（2）将G0/0/2的端口优先级调得比128小，要先删除（1）中的配置
三、修改端口开销、控制根端口和指定端口的选举
在SWB上修改端口开销，让SWB的G0/0/2端口成为根端口。请先清除以上实验的配置。
清除端口配置：
忘记操作的朋友可以转移至我的另一篇文章：
https://blog.csdn.net/weixin_62594100/article/details/124151755https://blog.csdn.net/weixin_62594100/article/details/124151755
在SWB上修改端口优先级，让SWB的G0/0/2端口选举为根端口。在SWA上有两种调整方法：
将G0/0/1的端口开销调大；
将G0/0/2的端口开销调小。
（1）将G0/0/1的端口开销调大，选举G0/0/2口为根端口。
由于SWB的G0/0/1和G0/0/2的端口开销一样，无法比较出哪个端口到达根桥的总路径开销更小。继续比较BPDU报文发送者的网桥ID，两个端口收到的BPDU报文都是SWA发送的，网桥ID一样。下面继续比较BPDU报文发送者的端口ID，由于BPDU报文发送者SWA的G0/0/1端口的ID更小，所以SWB的G0/0/1端口被选举为根端口。
将SWB的G0/0/1端口的端口开销（PC）修改为30000，使其大于G0/0/2的端口开销。让G0/0/2端口被选举为根端口。
（2）将G0/0/2的端口开销调小，使G/0/2口被选举为根端口。请先清除以上实验的配置。 四、配置边缘端口将SWA和SWB的E0/0/1端口配置为边缘端口，因为SWA和SWB的配置一致，下面只以SWA为例进行配置 。
注意：本例在端口下配置边缘端口，管控范围是该端口；如在全局配置，那么该交换机上所有交换端口全部成为边缘端口。
查看STP端口信息，显示端口被配置为边缘端口并且活动状态。
sto edged-port enable//配置E0/0/1为边缘端口。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/255114f9b684d821fd2e4cbc34464376/" rel="bookmark">
			软件工程——软件需求分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、选择题 1、需求分析的任务是分析系统做什么；；；；；；；；；；；；；；；；；；；；；；；。
2、需求分析阶段，开发人员那里获得的最重要的信息是用户要让软件做什么。
3、“为了解决这个问题，目标系统必须做什么？”这是生存周期中需求分析阶段要确定的事。
4、需求分析是软件开发工作的基础。
5、从瀑布模型看，在它的生存周期中的八个阶段中，需求分析阶段出问题了对软件的影响最大。
6、需求分析是要完整、准确、清晰、具体地确定系统所要完成的工作，其依据是前一阶段的文档可行性研究报告。
7、需求分析是由分析人员经了解用户的需求，认真仔细的调研、分析、最终应建立目标统一的逻辑模型并写出需求规格说明书。
8、需求分析是分析员经过了解用户的要求，认真细致的调研、分析，最终应建立目标系统的逻辑模型，并写出软件规格书明书。
9、在不同的软件需求中，功能需求描述了用户使用产品必须要完成的任务，可以在用例模型或方案脚本予以说明，非功能需求是从各个角度对系统的约束和限制，反映了应用对软件系统质量和特性的额外要求。
10、软件需求分析阶段的工作，可以划分为四个方面：对问题的识别、分析与综合，编写需求分析文档以及需求分析评审。
11、结构化分析建立功能模型的工具是DFD。
12、数据流图和数据字典共同组成系统的功能模型。
13、数据流图是进行软件需求分析常用的工具，其中最基本的图符是：处理，数据流，数据存储和数据源点/终点，其中“椭圆”可用来代表流图中的数据处理。
14、数据流是数据流图的基本成分，多个不同的数据流可以流向一个加工，也可以从一个加工中流出。
15、数据流图中的每个处理至少有一个输入流和一个输出流。
16、在分层数据流图中，若某层的加工K分解成下层的数据流图L，则K与L的输入、输出数据流必须相同。
17、画分层DFD图的基本原则是数据守恒原则，子、父图平衡的原则、数据流封闭的原则。
18、需求规格说明书的作用包括：软件验收的依据、用户与开发人员对软件要做什么的共同理解、软件设计的依据。
19、需求分析是由分析人员经了解用户的需求，认真仔细的调研，分析，最终建立目标系统的逻辑模型并写出需求规格说明书。
20、软件需求规格说明书是软件需求分析的重要文件，其包含数据描述、功能描述、性能描述。
21、数据字典是对数据定义信息的集合，它所定义的对象都包含在数据流图中。
22、数据字典是软件需求分析阶段的最重要工具之一，其最基本的功能是数据定义。
23、数据流图是描述数据在软件中流动和变换的过程，面对数据流图中所包含的元素的定义则是数据字典。
24、数据字典的作用是为用户与开发人员之间统一认识、作为概要设计的依据、为需求分析阶段定义各类条目。
25、描述复杂的事务时，图形远叙述优越的多，在需求分析阶段可以使用IPO图和层次方框图等图形工具。
26、信息建模方法是从数据角度对现实世界建立模型，其基本工具是实体联系图。
27、使用实体-联系图（ER图）建立的概念性数据模型中包含数据对象、属性、联系3种互相关联的信息。
28、使用结构化分析方法，采用的基本手段是分解和抽象。
二、判断题 1、软件的生存周期中，软件开发时期有需求分析、软件设计、编码和测试四个阶段。
2、软件需求是指用户对目标软件系统在功能、性能、行为、设计约束等方面的期望。
3、需求分析实际上就是一个用户意图不断进行揭示和判断的过程，并不考虑系统的具体实现，而是完整的、严密的描述系统应该“做什么“的一个过程。
4、数据流图是SA方法中用于表示系统逻辑模型的一种工具，它以直观的图形清晰地描述了系统数据的流动和处理过程。
三、填空题 1、软件定义过程可通过系统的可行性研究和需求分析两个阶段来完成。
2、结构化分析方法的分析策略是自项向下逐层分解。
3、需求分析过程包括需求获取、需求提炼、需求描述和需求验证4个步骤。
4、数据流图中描述加工逻辑一般使用三种工具，分别是结构化语言，判定表、判定树。
5、需求分析阶段产生最重要的文档是软件需求规格说明书。
6、数据流图的信息流可分为变换型和事务型两种类型。
7、变换型数据流图基本呈线型形状的结构，由输入、变换和输出组成。
8、对数据流的分析主要是找到变换中心，这是导出数据结构的关键。
9、在画分层的DFD时，父图和子图的输入输出数据流要平衡、守恒。
10、需求分析图形工具分为三类，非形式化、半形式化和形式化。
11、软件需求分析方法包括功能分解法、结构化分析方法、信息建模法和面向对象分析法。
12、在需求分析方法中，功能分解法是最早的分析方法。
13、功能分解法将系统看成是由若干个功能构成的集合，每个功能又能进一步分解成若干个子功能。思想体现的是“自项向下、逐步求精”。
14、在结构化分析方法中，数据流图和数据字典共同构成系统的逻辑模型。
15、信息建模方法的基本工具是实体联系图。（E-R图）
16、实体联系图由实体、属性和联系组成。
17、数据流图中的每一个加工至少有一个输入数据。
18、数据流图中的箭头表示数据流。
19、结构化分析是面向数据流的方法，该方法由数据流图和数据字典构成系统的逻辑模型。
20、层次方框图是需求分析阶段用来描述数据的图形工具。
四、名次解释 1、结构化分析：是面向数据流的分析方法，是使用数据流图、数据字典、结构化语言、判定树和判定表等工具，来建立一种新的称为结构化说明书的目标文档。 2、软件需求分析：软件需求分析是整个系统开发的基础，在此阶段结束前，系通分析员应该写出软件需求规格说明书，以书面形式准确地描述软件需求。 3、数据流图（DFD）：是SA方法中用于表示系统逻辑模型的一种工具，它以直观的图形清晰地描述了系统数据的流动和处理过程。 4、数据字典（DD）：数据字典是关于数据信息的集合，也就是对数据流图中所包含元素的定义的集合。 五、简答题 1、简述需求分析的常用方法 ①：功能分解法
②：结构化分析方法
③：信息建模法
④：面向对象方法
2、需求分析阶段的基本任务是什么 ①：确定对系统的综合需求。分析员和用户双方确定对系统的综合要求，具体有功能需求、性能需求、环境需求、接口要求、用户界面需求等的综合需求。
②：分析系统的数据需求。分析系统的数据要求通常用建立数据模型方法（E-R图），复杂的数据结构利用图形工具辅助描绘。常用工具有层次方框图和Warnier图等
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/255114f9b684d821fd2e4cbc34464376/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75aed38d3dfe67514457c76a1d952688/" rel="bookmark">
			QT有关QCobobox控件的样式设置（圆角、下拉框，向上展开、可编辑、内部布局等）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 QT设计界面时，难免会遇到修改QCombobox样式的问题。相比于其他的QLabel、QPushButton等控件，QCobobox的样式设置明显困难并复杂很多。以下介绍一下目前为止，本人参考网上代码，制作的一款QCobobox下拉框的样式风格。
效果图：
正文 一、基础样式表 /*QCombobox主体*/ QComboBox { border: 2px solid #f3f3f3;/*设置线宽*/ background-color: rgb(237, 242, 255);/*背景颜色*/ border-radius: 15px;/*圆角*/ padding: 1px 2px 1px 2px; /*针对于组合框中的文本内容*/ text-align:bottom; min-width: 9em; /*# 组合框的最小宽度*/ /*min-height: 5em;*/ border-style:solid;/*边框为实线型*/ border-width:2px;/*边框宽度*/ border-color:rgb(77, 123, 255);/*边框颜色*/ padding-left: 10px;/*左侧边距*/ } /*QCombobox右侧按钮*/ QComboBox::drop-down { subcontrol-origin: padding; subcontrol-position: top right;/*放于右方顶部*/ width: 50px;/*设置按钮范围宽度*/ /*border-radius: 15px; border-left-width: 1px; border-left-color: darkgray; border-left-style: solid;*/ border-top-right-radius: 3px;/*设置边框圆角*/ border-bottom-right-radius: 3px; /*padding-right: 50px;*/ } /*QCombobox右侧按钮的箭头图标*/ QComboBox::down-arrow { border-image: url(:/image/down_list.png);/*自定义图片填充*/ width: 10px;/*设置该图标的宽高*/ height: 10px; } /* 下拉后，整个下拉窗体样式 */ QComboBox QAbstractItemView { border: 2px solid #f3f3f3;/*边框宽度、线形、颜色*/ background-color: rgba(237, 242, 255, 1);/*背景颜色*/ border-radius: 15px;/*圆角*/ padding: 1px 2px 1px 2px; /*针对于组合框中的文本内容*/ min-width: 9em; /*# 组合框的最小宽度*/ } /* 下拉后，整个下拉窗体每项的样式 */ QComboBox QAbstractItemView::item { border-radius: 15px;/*圆角*/ height: 30px; /* 项的高度（设置pComboBox-&gt;setView(new QListView());后，该项才起作用） */ background-color: rgb(237, 242, 255); } /*以下部分不知为何不生效，有待调试*/ /* 下拉后，整个下拉窗体越过每项的样式 */ QComboBox QAbstractItemView::item:hover { color: #FFFFF0; /* 整个下拉窗体越过每项的背景色 */ background-color: rgb(98, 0, 255); } /* 下拉后，整个下拉窗体被选择的每项的样式 */ QComboBox QAbstractItemView::item:selected { color: #FFFFF0; background-color: rgb(0, 85, 200); } 补充：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/75aed38d3dfe67514457c76a1d952688/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6411b6e8a6dd8328b215540f1b2e97d9/" rel="bookmark">
			打开微信的X5调试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微信: debugmm.qq.com/?forcex5=true
https://x5.tencent.com/tbs/guide/debug/faq.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a5a03318e280c05f3331da0c2649bce/" rel="bookmark">
			Android 对话框(Dialog)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对话框是提示用户做出决定或输入额外事件的小窗口。对话框不会填充屏幕，通常用于需要用户采取行动才能继续执行的模式事件。
Dialog类是对话框的基类，我们可以使用Dialog来构建一个对话框。但Android建议避免直接使用Dialog，而应该使用其子类。下面是一些Dialog的子类实现：
AlertDialog一个可以显示标题，可选项列表或自定义布局，最多还可以显示三个按钮的对话框。
DatePickerDialog或TimerPickerDialog一个带有允许用户选择日期或时间的预定义UI的对话框。
构建一个简单的提醒对话框
AlertDialog.Builder(this).apply { setTitle("我是标题") setMessage("我是内容") setPositiveButton("确认") { dialog, _ -&gt; //点击了确认按钮 dialog.dissmiss() } setNegativeButton("取消") { dialog, _ -&gt; //点击了取消按钮 dialog.dismiss() } create() show() } 上面的对话框包括三个区域： 1.标题区域，这是一个可选项，只应在内容区域被详细消息，列表，或自定义布局占据时使用。如果显示的是一条简单的消息或问题，则不需要标题。
2.内容区域，它可以显示消息，列表，或其他自定义的布局。
3.操作按钮，一个对话框中最多只允许存在三个操作按钮。
构建一个单选列表对话框
val colors = arrayOf("黄色", "红色", "绿色") AlertDialog.Builder(this).apply { setTitle("选择颜色") setItems(colors) { _, which -&gt; //which 选择项的索引位置 } create() show() } 使用setItems()方法创建一个包含标题和列表的对话框，默认状态下，触摸列表会清除对话框。
构建永久性的单选多选对话啊框
上面的单选对话框默认在触摸列表后清除，要想添加永久性的单选或多选可以分别使用setSingleChoiceItems()或setMultiChoiceItems()方法。setSingleChoiceItems()方法中的第二个参数表示表示默认选中，如果不希望默认选中可传入-1。
val colors = arrayOf("Red", "Green", "Blue") AlertDialog.Builder(this).apply { setTitle("选择颜色") setSingleChoiceItems(colors, -1) { _, which -&gt; //每次选中一个选项时都会调用该方法 //which 选择项的索引位置 } setPositiveButton("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a5a03318e280c05f3331da0c2649bce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ecd3019fa3dea899f43809efc33fee34/" rel="bookmark">
			postgre报错：RETURNING “id“ was aborted: ERROR: null value in column “id“ violates not-null constraint
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我在使用 postgre 插入数据的时候报了一个错：
RETURNING "id" was aborted: ERROR: null value in column "id" violates not-null constraint 表的创建 sql 语句如下:
CREATE TABLE city( id int8 PRIMARY KEY NOT NULL , name varchar(30) NOT NULL , gov_area VARCHAR(100) NOT NULL ); 后来我对比了其他表的接口，返现 id 设置这里缺少了这个配置：
其他表多了这个配置，例如 student 表：
nextval('student_id_seq'::regclass) 我不管三七二十一复制这个配置到我创建的表里面，发现表可以插入数据了，但是奇怪的是，id 是自增的，但是不是从 1 开始自增，而是从 2215817 自增。之前用 mysql 设置 int 类型的 id 自增的时候根本没这么出现过，我记得 mysql 表 int 自增只需要配置（甚至直接勾选自增即可）：
UNSIGNED AUTO_INCREMENT 后来我上网查了一下，发现 postgre 没有这样的配置，但是可以在 id 这个字段上设置序列和索引来实现 id 的自增。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ecd3019fa3dea899f43809efc33fee34/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07ca56547c12960af1551c79630386cc/" rel="bookmark">
			路由配置（笔记）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		静态路由的配置 华为 1.ip route-static ip-address(目的IP地址) { mask l mask-length } interface-type（端口类型）加interface-number（端口号）下一跳的IP地址 [nexthop-address] 命令用来配置静态路由。参数ip-address指定了一个网络或者主机的目的地址，参数mask指定了一个子网掩码或者前缀长度。如果使用了广播接口如以太网接口作为出接口，则必须要指定下一跳地址;如果使用了串口作为出接口，则可以通过参数interface-type和interface-number(如Serial 1/0/0）来配置出接口，此时不必指定下一跳地址。
2.在串行网络中配置静态路由时，可以只指定下一跳地址或只指定出接口
3.以太网是广播类型网络，和串行网络情况不同。在以太网中配置静态路由，必须指定下一跳地址。ip route-static 192.168.2.0 24 10.1.1.2
实验 IP和网关不同，PC3通过路由到PC4
IP已经配置完成，ping不通
AR1
AR2 ping不通，通过路由表我们发现，并没有我们目的IP和下一跳IP地址，所以我们必须添加192这个IP并指定我们下一跳的路由器IP，让他通过下一跳的IP访问到192.
AR1：ip route-static 192.168.1.0 24 172.1.1.2
AR2：ip route-static 10.1.1.0 24 172.1.1.1
思科 这里就不搞图了，原理都是差不多的，命令不同而已。
各种接口的IP配置完了以后再进行路由配置（接口IP配置完成记得no sh开启）
全局配置模式下
AR1 (config)# ip route 192.168.1.0 255.255.255.0 172.16.1.2
AR2 (config)#ip rpute 10.1.1.0 255.255.255.0 172.16.1.1
查看路由表
1
2
通，简单的一个静态路由配置完成
路由分担 1.当源网络和目的网络之间存在多条链路时，可以通过等价路由来实现流量负载分担。这些等价路由具有相同的目的网络和掩码、优先级和度量值。
2.本示例中RTA和RTB之间有两条链路相连，通过使用等价的静态路由来实现流量负载分担。
在RTB上配置了两条静态路由，它们具有相同的目的IP地址和子网掩码、优先级〈都为60)、路由开销(都为0)，但下一跳不同。在RTB需要转发数据给RTA时，就会使用这两条等价静态路由将数据进行负载分担。
3.在RTA上也应该配置对应的两条等价的静态路由
简单讲：就是将两个路由器之间再次连接一个G口并给两边的G口分配IP，然后再进行路由配置，可以理解为，以前是一个通道，均衡负载就是两个或多个通道只是IP不相同而已。（思科同原理）
浮动路由--路由备份 浮动静态路由在网络中主路由失效的情况下，会加入到路由表并承担数据转发业务
在配置多条静态路由时，可以修改静态路由的优先级，使一条静态路由的优先级高于其他静态路由，从而实现静态路由的备份，也叫浮动静态路由。在本示例中，RTB上配置了两条静态路由。正常情况下，这两条静态路由是等价的。通过配置preference 100，使第二条静态路由的优先级要低于第一条（值越大优先级越低)。路由器只把优先级最高的静态路由加入到路由表中。当加入到路由表中的静态路由出现故障时，优先级低的静态路由才会加入到路由表并承担数据转发业务。
在主链路正常情况下，只有主路由会出现在路由表中。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07ca56547c12960af1551c79630386cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75e9fe25c2b48420529376695e5aeb28/" rel="bookmark">
			cf四大战区合区列表？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为给玩家提供了更大的游戏平台，让高手与更多高手进行竞技对抗，突破服务器的限制，对几个大区服务器合区分为四大战区。
南部战区：华中战区、华南战区；
北部战区：华北战区、山东战区、东北战区、河南战区；
东部战区：原东部战区、江苏战区；
西部战区：原西部战区保持不变。
战区地区大区东部战区东部福建一区安徽一区上海一区上海二区浙江一区浙江二区江苏江苏一区江苏二区教育网区移动专区南部战区华中江西一区南方大区湖南一区湖南二区湖北一区湖北二区华南广东一区广东二区广东三区广东四区广西一区西部战区西部四川一区四川二区重庆一区云南一区陕西一区北部战区华北河北一区山西一区北京一区北京二区北京三区北京四区山东山东一区山东二区河南二区北方大区东北吉林一区黑龙江一区辽宁一区辽宁二区辽宁三区河南河南一区 在官方的宣传活动上可以看出，南朱雀北玄武，东青龙西白虎，四大神兽同台竞技，一副群雄争霸模样，整体外观看起来非常的酷炫。游戏讲述了全球两大国际佣兵组织保卫者（Global Risk）和潜伏者（Black List）之间的对决。潜伏者从不为强国服务，潜伏者的成员身上流动的是野性的血——这让他们愿意为弱小国家服务，甚至执行某些“特殊服务”。但对于外人来说，有关他们的一切都仅仅是猜测罢了。
操纵西方世界利益的雇佣兵“保卫者”和受弱小国家在内的第三世界国家之托出战的 " 潜伏者"军团。游戏有团队竞技模式、战队赛、爆破模式、幽灵模式、生化模式、挑战模式等多种模式玩法，并引进了“缺人补充”的形式即时加入系统。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23ab50c3a29cd6b86185fdfe33096c40/" rel="bookmark">
			Ubuntu20.04运行VINS-Fusion
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ROS的安装参考Ubuntu20.04安装ROS Noetic的详细教程，安装源用清华源，软件和更新里的下载自改到腾讯源；Ceres的安装参考官方安装步骤。
下载编译代码跟HKUST-Aerial-Robotics官方代码一致：
cd ~/catkin_ws/src git clone https://github.com/HKUST-Aerial-Robotics/VINS-Fusion.git cd ../ 参考Ubuntu20.04运行Vins-fusion-作者-可即修改.cpp和.h文件有关代码。
再在此终端运行：
catkin_make 如果Ubuntu系统里之前装了Anaconda，Python解释器路径会出问题，改为运行：
catkin_make -DPYTHON_EXECUTABLE=/usr/bin/python3 成功后打开四个终端分别运行：（大概是分别都需要设置工作空间）
source ~/catkin_ws/devel/setup.bash roslaunch vins vins_rviz.launch source ~/catkin_ws/devel/setup.bash rosrun vins vins_node ~/catkin_ws/src/VINS-Fusion/config/euroc/euroc_mono_imu_config.yaml source ~/catkin_ws/devel/setup.bash rosrun loop_fusion loop_fusion_node ~/catkin_ws/src/VINS-Fusion/config/euroc/euroc_mono_imu_config.yaml source ~/catkin_ws/devel/setup.bash rosbag play YOUR_DATASET_FOLDER/MH_01_easy.bag 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48ec24893e98c40ab1dc15d5ad97fb7d/" rel="bookmark">
			UE4和Maya的链接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 给UE4安装Maya live Link 插件
2 UE4插件窗口里面找到LiveLink插件，确保它已经启用
3 打开UE4安装位置， E_4.27\Engine\Plugins\Marketplace\MayaLiveLink\Binaries
文件夹下对应的Maya版本文件
4 将年份文件夹整个复制到 Maya2019\plug-ins 下
5 打开Maya，窗口-设置/首选项-&gt;插件管理器-》浏览，分别打开复制的年份文件夹下的两个插件，然后关闭窗口
6 左下角 MEL输入框 输入MayaLiveLinkUI 回车，弹出链接窗口
7将需要链接的模型fbx文件拖到场景中打开，左边大纲菜单下选中骨骼Root，然后点窗口中的add selection ，在Character后输入一个名字
8 打开UE4，打开LiveLink窗口，点击源，消息总线程，选中右边
9 打开UE4，角色的动画蓝图修改为下，Root是上一步起的名字
9链接成功
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cab89b1fdcbced119949aa64006d5770/" rel="bookmark">
			【c语言】如何在VS（Visual Studio2013）中创建C项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当新手程序员使用vs面临的第一个问题，是如何使用VS创建C项目。新手使用vs软件的好处是界面清晰，不用配置环境。接下来进入正题，如何创建C项目：
第一步打开VS软件：
进入软件后，我们可以看到下面界面：
第二步，我们点击“新建项目” 。
第三步，在下图界面中，我们首先在左侧找到如图中（1）箭头位置的"Visual C++",并点击；
接下来在如图（2）箭头位置找到"空项目"，并点击；
在（3）箭头位置中，设置我们要建立项目的项目名以及项目存储位置；
设置好后点击右下角的"确定"按钮。
接下来，我们接下来进入项目内部：
第四步，我们在左侧（或右侧）（1）箭头位置找到"源文件”，并右键点击，找到 （2）箭头位置"添加":
在"添加"中，找到下图箭头位置的"新建项",并点击:
第五步，在下图中，确认是"C++文件"（如箭头（1）位置）；并在（2）箭头位置"名称"处修改文件名字，后缀改为".c",后缀".c"文件表示c文件，后缀".cpp"表示c++文件。
最后，点击右下角的"添加"，即可开始c程序代码编写。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e91814505754e0868fc534cbbfbcc7a/" rel="bookmark">
			java设置pdf平铺图片水印 且移出Evaluation Warning : The document was created with Spire.PDF for Java.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在项目中，遇到需要给pdf添加水印的情况。pdf是使用润乾api生成的。但是由于使用的版本比较低，不支持水印，所以需要自己用java来设置水印。 首先需要使用第三方jar包Spire.Pdf.jar，可以网上找。
代码可以参考文档：官网指南参考代码
由于亲测以上链接的参考代码发现有些小问题。
再生成新的pdf时会有一串英文备注：
该备注只会标记再报表的第一页的顶部。所以可以在给报表生成水印前，添加一页空白页面，然后再删除空表页面的方式接解。
下面时代码示例：
import com.spire.pdf.PdfDocument; import com.spire.pdf.PdfPageBase; import com.spire.pdf.graphics.PdfImage; import com.spire.pdf.graphics.PdfTilingBrush; import java.awt.*; import java.awt.geom.Dimension2D; import java.awt.geom.Rectangle2D; public class BookMark { public static void main(String[] args) { //创建PdfDocument对象,并加载PDF测试文档 PdfDocument pdf = new PdfDocument(); pdf.loadFromFile("demo.pdf"); //添加一个空白页，目的为了删除jar包添加的水印，后面再移除这一页 pdf.getPages().add(); int rows = 3; //指定一行有多少个图片 int col = 3; //指定一个pdf页有多少行图片组 //遍历文档每一页,加载图片，并设置成平铺背景（水印） for (int i = 0; i &lt; pdf.getPages().getCount();i++) { PdfPageBase page = pdf.getPages().get(i); Dimension2D dimension2D = new Dimension(); dimension2D.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e91814505754e0868fc534cbbfbcc7a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c9ccd28dfb5d9d752061bbcc3811338/" rel="bookmark">
			电脑进不了系统怎么重装系统win11
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近有用户反映,在使用Win11系统的时候,突然发现开机死机了,反正进不了系统。这时我们只能通过重装系统的方法进行修复，那么电脑死机怎么重装系统win11呢?下面，小编就把电脑死机重装win11系统的步骤教程分享给大家。
更多重装系统教程尽在小白系统重装官网
1.首先需要一台能使用的电脑，下载小白一键重装系统。插入u盘点击【开始制作】。
2.选择Windows11系统，再点击【开始制作】。
3.正在下载所需要的资源，请耐心等待。
4.u盘制作完成，点击【预览】电脑品牌的启动热键。
5.重启之后，插入u盘。按照品牌快捷键进入bios设置启动。F10保存。
6.进入pe之后，自动开始安装win11.
7.安装完成后，点击【立即重启】准备进入系统部署。
8.等待部署完成后就会进入全新的桌面。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66daba1ca774a358ea0be334e78bf7ce/" rel="bookmark">
			[转]使用Dependency Walker工具查看DLL文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DLL是动态链接库的简称，每个DLL文件都相当于一个封闭的函数库。本文主要讨论如何使用DependencyWalker工具查看DLL文件内的导入函数与导出函数。
DependencyWalker软件
Dependency Walker(DLL依赖性分析工具) V2.2.6000.0 绿色版(32/64)
类型：系统其它大小：741KB语言：简体中文时间：2015-10-13 查看详情
配置正确的DLL文件
方法/步骤
1、打开DependencyWalker软件
2、在左上角的“文件”菜单中找到“打开”按钮，或者直接使用快捷键Ctrl+O打开。
3、在“打开”对话框中，找到一个DLL文件选中后，就可以查看此DLL文件的信息了。这里我们查看的是System32文件夹中的kernel32，这是操作系统中的一个比较重要的DLL文件。
4、在界面左上部分的树状图中可以看到该DLL文件调用了哪些其他的文件中的内容。单击这些文件可以查看这些文件各自的导入与导出函数。
5、右上方一共有两个部分，其中，PI是Parent Import Function List View的简写，E是Export Function List View的简写。通过这两个部分，用户可以观察到该DLL文件从哪些其他文件中调用了函数（PI），又提供了哪些接口，让其他的程序调用（E）。需要特别注意的是，DependencyWalker中提供的函数名是C语言可以调用的函数名。
6、中下侧模块中的内容与左上方的树状图是对应的。该模块详细描述了要这次检查的DLL文件所调用的其他文件详细信息。
7、最下侧的模块是信息模块，如果DependencyWalker在解析某个DLL文件时出错，错误信息会显示在该模块中。就如下图打开的一个带有错误的DLL文件。
8、在左上方的“文件”菜单内可以“保存”或“另存为”本次对DLL文件的解析结果。
9、在保存或另存为界面中，可以将解析结果保存到DWI格式的文件。保存成此类的文件可以直接用DependencyWalker快速识别并打开。
10、到这里DependencyWalker的主要功能就介绍完毕了。下面再介绍两个该软件实用的附加功能。在上方“查看”菜单中的“系统信息”中可以看到自己当前的系统信息。
11、在上方“查看”菜单中的“属性”中可以看到当前被解析DLL文件的属性。
DependencyWalker是个非常实用的软件。其操作非常简单，细心些就好。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f63c0c02356233ecd81312cfcce027e/" rel="bookmark">
			GAMES101-计算机图形学-作业1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记录111
1 总览
到目前为止，我们已经学习了如何使用矩阵变换来排列二维或三维空间中的
对象。所以现在是时候通过实现一些简单的变换矩阵来获得一些实际经验了。在接下来的三次作业中，我们将要求你去模拟一个基于CPU 的光栅化渲染器的简化版本。
本次作业的任务是填写一个旋转矩阵和一个透视投影矩阵。给定三维下三个
点v0(2.0, 0.0,−2.0), v1(0.0, 2.0,−2.0), v2(−2.0, 0.0,−2.0), 你需要将这三个点的坐标变换为屏幕坐标并在屏幕上绘制出对应的线框三角形(在代码框架中，我们已经提供了draw_triangle 函数，所以你只需要去构建变换矩阵即可)。简而言之，我们需要进行模型、视图、投影、视口等变换来将三角形显示在屏幕上。在提供的代码框架中，我们留下了模型变换和投影变换的部分给你去完成。
如果你对上述概念有任何不清楚或疑问，请复习课堂笔记或询问助教。
以下是你需要在main.cpp 中修改的函数（请不要修改任何的函数名和其他
已经填写好的函数，并保证提交的代码是已经完成且能运行的）：
• get_model_matrix(float rotation_angle): 逐个元素地构建模型变换矩
阵并返回该矩阵。在此函数中，你只需要实现三维中绕z 轴旋转的变换矩阵，而不用处理平移与缩放。
• get_projection_matrix(float eye_fov, float aspect_ratio, float
zNear, float zFar): 使用给定的参数逐个元素地构建透视投影矩阵并返回
该矩阵。
• [Optional] main(): 自行补充你所需的其他操作。
1 get_model_matrix(float rotation_angle):
Eigen::Matrix4f get_model_matrix(float rotation_angle) { // TODO: Implement this function // Create the model matrix for rotating the triangle around the Z axis. // Then return it. rotation_angle = rotation_angle / 180 * M_PI; Eigen::Matrix4f model = Eigen::Matrix4f::Identity(); Eigen::Matrix4f translate; translate &lt;&lt; cos(rotation_angle), -sin(rotation_angle), 0, 0, sin(rotation_angle), cos(rotation_angle), 0, 0, 0, 0, 1, 0, 0, 0, 0, 1; model = translate * model; return model; } 2 get_projection_matrix(float eye_fov, float aspect_ratio, float
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f63c0c02356233ecd81312cfcce027e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f56caf7edf32f676c0f27602f318e8b/" rel="bookmark">
			v-bind 和 v-model 的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		v-bind 是单向绑定，绑定的是value （如果想改变值只能在data数据里面改，在input标签里无法修改）此外他的语法糖是":"举一个小例子
&lt;!DOCTYPE html&gt; &lt;html lang="en" xmlns:v-bind="http://www.w3.org/1999/xhtml"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt; &lt;input type="text" v-bind:value="message" /&gt; &lt;h2&gt;您输入的值是:{{message}}&lt;/h2&gt; &lt;/div&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js"&gt;&lt;/script&gt; &lt;script&gt; const app = new Vue({ el:"#app", data:{ message:'你好啊', }, methods:{ } }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 删除input框中的“好啊”，下方的值并没有改变，所以是单向的。
v-model是双向绑定，而且绑定的也是value，修改input里面的值，下面的message 的值也会改变，例子如下：
&lt;!DOCTYPE html&gt; &lt;html lang="en" xmlns:v-bind="http://www.w3.org/1999/xhtml"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt; &lt;!-- &lt;input type="text" v-bind:value="message" /&gt; --&gt; &lt;input type="text" v-model="message" /&gt; &lt;h2&gt;您输入的值是:{{message}}&lt;/h2&gt; &lt;/div&gt; &lt;script src="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f56caf7edf32f676c0f27602f318e8b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cea773d1e28f7324c36f6870dcd87e5e/" rel="bookmark">
			路由的原理，笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是路由 总所周知，当两个网络IP网段不一样的时候（掩码相同），是没有办法建立连接的，那么路由器就可已通过路由得原理给不同得IP建立连接。这就是路由得作用。
以太网交换机工作在数据链路层，用于在网络内进行数据转发。而企业网络的拓扑结构一般会比较复杂，不同的部门，或者总部和分支可能处在不同的网络中，此时就需要使用路由器来连接不同的网络，实现网络之间的数据转发。
路由选路 1.路由器作用就是路由!是源主机到目标主机的一个互联网来转发数据包的过程。简单来说路由器是对数据包选择最佳路径的过程!
⒉.路由器收到数据包后，会根据数据包中的目的IP地址选择一条最优的路径，并将数据包转发到下一个路由器，路径上最后的路由器负责将数据包送交目的主机。数据包在网络上的传输就好像是体育运动中的接力赛一样，每一个路由器负责将数据包按照最优的路径向下一跳路由器进行转发，通过多个路由器一站一站的接力，最终将数据包通过最优路径转发到目的地。当然有时候由于实施了一些特别的路由策略，数据包通过的路径可能并不一定是最佳的。
3.路由器能够决定数据报文的转发路径。如果有多条路径可以到达目的地，则路由器会通过进行计算来决定最佳下一跳。计算的原则会随实际使用的路由协议不同而不同。
说白了路由选路就是再进行路由的时候选择最优先的路线走。
路由表 华为路由表
1.路由器转发数据包的关键是路由表。每个路由器中都保存着一张路由表，表中每条路由表项都指明了数据包要到达某网络或某主机应通过路由器的哪个物理接口发送，以及可到达该路径的哪个下一跳路由器，或者不再经过别的路由器而直接可以到达目的地。
2.路由表中包含了下列关键项:
(1）目的地址(Destination):用来标识IP数据包的目的地址或目的网络。
(2）网络掩码(Mask)︰在路由表中网络掩码也具有重要的意义。IP地址和网络掩码进行“逻辑与”便可得到相应的网段信息。如本例中:目的地址为8.0.0.0，掩码为255.0.0.0，相与后便可得到一个A类的网段信息(8.0.0.0/8)。网络掩码的另一个作用还表现在当路由表中有多条目的地址相同的路由信息时，路由器将选择其掩码最长的一项作为匹配项。如255.255.255.255优先于255.255.255.248
(3）输出接口(Interface):指明IP数据包将从该路由器的哪个接口转发出去。
(4)下一跳IP地址(NextHop）:指明IP数据包所经由的下一跳路由器的接口地址。
(5)协议类型（Proto）华为路由器的协议类型有四种，Direct、OSPF、Static、RIP。
(6)管理距离值（pre）越小越优先
路由表是路由器中维护的路由条目的集合，如果把路由器当作十字路口，路由表相当于路标!
路由优先级 1.路由器可以通过多种不同协议学习到去往同一目的网络的路由，当这些路由都符合最长匹配原则时，必须决定哪个路由优先。
⒉.每个路由协议都有一个协议优先级（取值越小、优先级越高）。当有多个路由信息时，选择最高优先级的路由作为最佳路由。
3.如图所示，路由器通过两种路由协议学习到了网段10.1.1.0的路由。虽然RIP协议提供了一条看起来更加近的路线，但是由于OSPF具有更高的优先级，因而成为优选路由，并被加入路由表中。
路由表只会记录最优先的路径，但是并不代表其他路由路径无效，如果最优路径挂掉那么其他路径也会选择一个最优的路径写入路由表。也是如图所示，如果OSPF的路由路径挂掉了，那么会自动使用RIP路由的路径。
华为思科路由优先级比较 华为：d&gt;ospf&gt;s&gt;s*&gt;rip
思科：c&gt;s&gt;ospf&gt;rip&gt;s*
这幅图乘着上面的实验看起来应该是通顺多了。。。
路由度量 1.如果路由器无法用优先级来判断最优路由（优先级相同)，则使用度量值(metric)来决定需要加入路由表的路由。
2.一些常用的度量值有:跳数，带宽，时延，代价，负载，可靠性等。
3.跳数是指到达目的地所通过的路由器数目。
4.带宽是指链路的容量,高速链路开销（度量值)较小。
5.metric值越小，路由越优先;因此，图示中metric=1+1=2的路由是到达目的地的最优路由，其表项可以在路由表中找到。
最长匹配原则 路由表中如果有多个匹配目的网络的路由条目，则路由器会选择掩码最长的条目，应为路由环境小啊。
如图所示，目的10IP的协议，优先级，度量值。端口都是相同的，那么路由器就会对mask进行判断，最长的过。
1.路由器在转发数据时，需要选择路由表中的最优路由。当数据报文到达路由器时，路由器首先提取出报文的目的IP地址，然后查找路由表，将报文的目的IP地址与路由表中某表项的掩码字段做“与”操作，“与”操作后的结果跟路由表该表项的目的IP地址比较，相同则匹配上，否则就没有匹配上。当与所有的路由表项都进行匹配后，路由器会选择一个掩码最长的匹配项。
⒉.如图所示，路由表中有两个表项到达目的网段10.1.1.0，下一跳地址都是20.1.1.2。如果要将报文转发至网段10.1.1.1，则10.1.1.0/30符合最长匹配原则.
静态路由 静态 1.静态路由是指由管理员手动配置和维护的路由。静态路由配置简单，并且无需像动态路由那样占用路由器的CPU资源来计算和分析路由更新。
⒉.静态路由的缺点在于，当网络拓扑发生变化时，静态路由不会自动适应拓扑改变，而是需要管理员手动进行调整。
3.静态路由一般适用于结构简单的网络。在复杂网络环境中，一般会使用动态路由协议来生成动态路由。不过，即使是在复杂网络环境中，合理地配置一些静态路由也可以改进网络的性能。
创作于千锋教育网工视频
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a8468fdff2ac6178cc5d40b4bfb1c05/" rel="bookmark">
			基于pycharm的NAO机器人python开发（1）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		继上篇在pycharm上配置环境成功后，开始准备写入简单的代码测试。
首先
一、安装naoqi包 下载SDK：Downloads Softwares | SoftBank Robotics
1.1 添加环境变量 变量名：PYTHONPATH
变量值：下载的SDK的lib文件夹路径
此时打开命令行：
输入python后尝试import naoqi
3. 1.2 直接安装 双击安装，选择版本，不过博主这个方法未成功，大概原因应该是我的pyhton2.7安装的是64位，该naoqi包是32位，所以找不到我的python2.7的版本。
1.3 复制大法 虚拟环境配置好后，打开环境的Lib文件夹
将下载的SDK中lib文件夹中所有东西复制到环境的Lib中
随后即可成功import naoqi了
三、其他软件包 3.1 opencv 首先是opencv，直接在解释器里安装即可
参考该博主步骤pycharm（Python2）+Naoqi+OpenCV配置（非常详细）_想清楚再敲的博客-CSDN博客
# coding=utf-8 from naoqi import ALProxy IP = "192.168.1.107" # 机器人的IP地址 PORT = 9559 # 机器人的端口号，默认9559 ttsProxy = ALProxy("ALTextToSpeech", IP, PORT) def sayHi(): ttsProxy.say("你好") if __name__ == '__main__': sayHi() 运行成功，现象一致
注：代码首行要加入# -*- coding: utf-8 -*-的编码格式就不会报错
3.2 其他 博主安装了一个pillow的包，一开始pycharm安装失败，pip安装失败，后来重启pycharm就安装成功了，emmm.m。。
然后在运行其他一些比赛代码时，发现报错，有个 almath 的包没安装，在解释器中安装后又报错
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a8468fdff2ac6178cc5d40b4bfb1c05/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e57dfd153273fe8e933d250465e2b906/" rel="bookmark">
			信息学奥赛一本通（c&#43;&#43;）：2035：【例5.2】平移数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、题目 2035：【例5.2】平移数据
时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】 将a数组中第一个元素移到数组末尾,其余数据依次往前平移一个位置。
【输入】 第一行为数组a的元素个数；
第二行为n个小于1000的正整数。
【输出】 平移后的数组元素，每个数用一个空格隔开。
【输入样例】 10 1 2 3 4 5 6 7 8 9 10 【输出样例】 2 3 4 5 6 7 8 9 10 1 二、思路 定义一个中间变量t等于第一个数 然后数组依次向前挪一位 最后一位等于变量t
三、代码 #include &lt;bits/stdc++.h&gt; using namespace std; int main() { int n; cin&gt;&gt;n; int a[n]; for(int i=0;i&lt;n;i++) { cin&gt;&gt;a[i]; } int t=a[0]; for(int i=0;i&lt;n-1;i++) { a[i]=a[i+1]; } a[n-1]=t; for(int i=0;i&lt;n;i++) { cout&lt;&lt;a[i]&lt;&lt;"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e57dfd153273fe8e933d250465e2b906/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/547946f0821b5453f94be142fdf0909a/" rel="bookmark">
			FORTRAN数值分析01求定积分与微分(VScode环境下)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.矩形法求定积分
program definiteintegralbyrectangular implicit none real,parameter::pi=3.1415926 integer,parameter::N=100!调整精度 real lowbound,upbound,len,x,sum,f lowbound = 0 !输入下界 upbound = pi!输入上界 len = (upbound - lowbound)/N sum = 0.0 x = lowbound do while(x&lt;upbound) f = cos(x)-x**2 !输入要积分的函数 sum = sum + f * len x = x + len end do write(*,*)'The final result = ',sum pause end 2.梯形法求定积分
program definiteintegralbyrectangular implicit none real,parameter::pi=3.1415926 integer,parameter::N=100!调整精度 real lowbound,upbound,len,x,sum,f1,f2 lowbound = 0 !输入下界 upbound = pi!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/547946f0821b5453f94be142fdf0909a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f68bd84bfe608828f12849f526c5216e/" rel="bookmark">
			反转一个单链表（Java）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		看到反转链表，可能第一时间的想法便是遍历一遍这个单链表，然后把链表里的元素都取出来，放到一个数组里，然后逆置这个数组。这个想法是错的！！！
所以什么是反转链表呢？见下图：
反转一个单链表，我们需要的是改变这个链表内节点的指向。
反转链表第一步：
判断链表是否为空，如果链表为空，则直接返回null。
if (this.head == null) { //没有节点 return null; } 反转链表第二步：
判断链表是否只有一个节点，如果头结点的下一节点等于空，则说明该链表只有一个节点，即返回头结点。
if (this.head.next == null) { //只有一个节点 return this.head; } 反转链表第三步：
//至少两个节点 Node cur=this.head.next; this.head.next=null; while (cur!=null){ Node curNext=cur.next; cur.next=head; this.head=cur; cur=curNext; } return head; 第三步详解如下：
链表反转后，它原本的头结点的下一节点就为空null了。但是不能在一开始就将头结点的下一节点置为空。因为将它置为空后，便失去了与链表本来head.next的联系；所以，我们定义一个cur记录头结点下一节点的位置；也就是说让head不动，将记录头结点下一节点位置的cur用头插法的方式插入到head的前边，在cur头插到head前再定义一个curNext记录cur的下一节点，使cur到了head前，也不会失去与后边节点的联系。当所有的链表都反转后，cur就会为空。
图解
完整代码如下：
class Node{ public int val; public Node next; //类型是Node null public Node(int val){ this.val=val; } } public class SingleLinkedList { public Node head; //反转链表 //反转链表并不能使用逆置数组，需要改变链表元素的指向（使用头插法） public Node reverseList() { if (this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f68bd84bfe608828f12849f526c5216e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4ea67ae3d3810710cac166ca5043977/" rel="bookmark">
			TIA博图——基本操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、个人注意
二、添加新块
2.1 组织块(OB)
2.2 程序块(FC：函数)
2.3 功能块(FB：函数块)
2.4 数据块(DB)
三、基本指令
3.1 位逻辑运算
（1）常开
（2）常闭
（3）线圈（赋值）
（4）赋值取反
（5）置位输出
（6）复位输出
（7）扫描信号的上升沿
（8）扫描信号的下降沿
（9）移动值
一、个人注意 出现HMI画面“无法启动运行系统仿真”问题，博主出现两次问题，第一次去年暑假，当时一直没解决，不得已重装系统，然后重装软件才没啥问题，因为一开始需要的软件全装了也没啥问题，使用了一段时间后才出现的这个问题，所以一直不晓得问题原因。我的是win10专业版，博图v15.1。
第二次上周又出现这个问题，直接给我吓到了，因为前面还能用，那天我安装了plcsim adv后才出现的这个问题，我就尝试删除plcsim，没解决，又重装博图的全部软件后又可以了，所以可能是兼容问题，如果不需要用plc仿真的话最好还是不要安装plcsim吧。。。。。
二、添加新块 2.1 组织块(OB) 组织块（OrganizationBlocks，简称OB）提供了PLC内部CPU操作系统与用户程序间的接口，它是由CPU操作系统直接进行调用的逻辑块，用来管理PLC程序中各组成部分的调用和执行中断。OB决定了PLC用户程序的结构与块的调用顺序，起到了“管理”用户程序的作用。
OB块的调用条件被称为“触发事件”，根据“触发事件”的不同，OB块可以分为若干级别，各个级别有不同的优先级，高优先级的OB可以中断低优先级OB的执行。如果需要，S7系列PLC除OB1外，还可以使用多个OB块。
2.2 程序块(FC：函数) 程序块(Function，简称FC)是由用户编写的、不需要专门数据块的常用逻辑块。
FC块在程序中一般不可以重复调用，在大多数场合，FC块应直接使用PLC的“绝对地址”或“符号地址”进行编程，但根据需要，可以定义部分程序变量。
2.3 功能块(FB：函数块) 功能块（FunctionBlocks，简称FB块）是由用户编写的、需要专用数据块(InstanceDataBlocks，称为“即时数据块”或“背景数据块”，简称DI)支持的常用逻辑块。
FB块与FC块的作用基本相同，但FB中除可以使用“绝对地址”或“符号地址”进行编程外，在结构化编程时必须使用“程序变量”进行编程，因此，FB必须配套的、独立的数据存储区域——“即时数据块DI”。DI-方面可以为调用FB提供执行程序所需要的“程序变量”赋值与其他数据，另一方面，功能块FB也能通过DI给调用它的逻辑块返回所需要的数据。
2.4 数据块(DB) 数据块(DataBlocks，简称DB)是用来存放执行用户程序时所需的数据与存储程序执行结果的数据存储区，其作用与标志寄存器类似，但数量更多。数据块DB按不同的用途可以分为即时数据块(InstanceDataBlocks，又称背景数据块，简称DI)和通用数据块(DataBlocks，又称共享数据块，简称DB)两类。
即时数据块(DI)用于传递功能块的参数，只能被指定的功能块FB访问。调用功能块FB时，必须同时指定用于该功能块的即时数据块DI，即时数据块内的数据可以自动生成，它们可以是FB变量声明表中的数据（不含临时变量）。
通用数据块(DB)用于存储PLC的全局数据，所有的FB、FC或OB都可以对通用数据块进行读写操作，因此，又被称为共享数据块。通用数据块内的数据不会因用户程序的结束而删除。
三、基本指令 3.1 位逻辑运算 （1）常开 通电闭合，查询的操作数为1时闭合
（2）常闭 通电闭合，查询的操作数为0时闭合
（3）线圈（赋值） 设置指定操作数的位
（4）赋值取反 将逻辑运算结果取反并返回操作数
（5）置位输出 指定操作数输出置位为1
（6）复位输出 指定操作数输出复位为0
（7）扫描信号的上升沿 操作数的信号由“0”到“1”时，返回1
（8）扫描信号的下降沿 操作数的信号由“1”到“0”时，返回1
（9）移动值 将IN处的输入操作数赋值到OUTx处输出
可能未完。。。。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1afcdd36d358251592827a8c0065392/" rel="bookmark">
			turtle库的使用，让你的代码动起来
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 ✨turtle库概述🔥两个turtle库使用实例❤️‍🔥turtle库导入⭐绘图窗体🏈空间坐标体系💡goto函数使用实例 ⚾角度坐标体系💡角度函数使用实例 🎱RGB色彩体系🏐画笔控制函数⚽运动控制函数🏀方向控制函数 🔮小结 ✨turtle库概述 turtle库是Python语言的标准库之一，可以直接使用
入门级的图形绘制函数，下图中的图片都是由turtle库中的函数编写的
turtle英文翻译为海龟，所以turtle库也成为海龟库
由turtle库绘制的图形也就是海龟总过的路径
🔥两个turtle库使用实例 超有趣的Python画图——绘制日期
超有趣的Python画图——科赫雪花
❤️‍🔥turtle库导入 我们有三种方法可以导入turtle库
（1）import turtle 最直接简介的办法,使用库函数时要加上turtle，例如turtle.setup()
（2）from turtle import * 使用库函数时可以不用加turtle，例如setup()，但是有时会与其他函数重名，引起歧义
（3）import turtle as a 将turtle重命名为a，也可以为其他名称，这样可以简写代码，例如a.setup()
⭐绘图窗体 🏈空间坐标体系 程序开始时海龟默认再窗口中心
我们可以用 turtle.goto() 令海龟进行移动
可以用 turtle.fd() 函数控制海龟前进， turtle.bk() 函数控制海龟后退，要注意当前海龟的朝向
💡goto函数使用实例 ⚾角度坐标体系 💡角度函数使用实例 🎱RGB色彩体系 🏐画笔控制函数 ⚽运动控制函数 🏀方向控制函数 🔮小结 turtle 常用库函数 turtle.fd(distance) 向当前画笔方向移动distance像素长度
turtle.bk(distance) 向当前画笔相反方向移动distance像素长度
turtle.right(degree) 顺时针移动degree°
turtle.left(degree) 逆时针移动degree°
turtle.goto(x,y) 将画笔移动到坐标为x,y的位置
turtle.seth(angle) 设置当前朝向为angle角度
turtle.home() 返回原点，朝向右。
turtle.circle() 画圆，半径为正(负)，表示圆心在画笔的左边(右边)画圆
turtle.speed() 速度
turtle.pendown() 画笔落下
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1afcdd36d358251592827a8c0065392/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2784e8256a6a2349b38db433e5561757/" rel="bookmark">
			概念梳理：C&#43;&#43;中iostream头文件和命名空间的基础介绍和拓展内容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：陌生人要天天开心
文章目录 前言一、iostream头文件cin和cout的运行原理个人梳理 二、命名空间std::cin与cin和std::cout与cout 结语参考文献： 前言 本文要记录的大概内容：
本文主要记录C++中的iostream头文件和命名空间的内容，包含cin和cout的运行原理，std::cin和cin还有std::cout和cout之间的差别，并针对它们的使用方法展开拓展。
新手小白，如有错误，请见谅。
以下是本篇文章正文内容，下面代码案例可供参考
一、iostream头文件 #include&lt;iostream&gt; iostream，iostream的io分别是input（输入）和output（输出）的首字母，iostream的stream其实是英语单词stream(流）。
iostram头文件包含了对输入输出流进行相关操作所需的基本信息，像我们在C++中常用的cin和cout便要在包含此头文件时才能投入使用。
名称介绍cinistream的派生类istream_withassign的对象，其与标准输入设备相联系，默认情况下指键盘coutostream的派生类ostream_withassign的对象，其与标准输出设备相联系，默认情况下指显示器 下列表格表头中的名称指的是经由iostream头文件重载后的名称
符号名称介绍原型&gt;&gt;提取运算符（输入运算符）原为右位移运算符，在iostream头文件将其进行重载后，它能够被用作标准类型数据的输入运算符，常与cin搭配使用istream &amp;operator&gt;&gt;(istream &amp;,类型名&amp;)&lt;&lt;插入运算符（输出运算符）原为左位移运算符，在iostream头文件将其进行重载后，它能够被用作标准类型数据的输出运算符，常与cout搭配使用ostream &amp;operator&lt;&lt;(ostream &amp;,类型名) ps:表格中介绍原型的目的是帮助大家在学习运算符函数重载的时候可以根据其原型来针对性地重载’&gt;&gt;‘和’&lt;&lt;'。
由于istream和ostream类都是在头文件iostream中声明的，'&gt;&gt;‘和’&lt;&lt;'的相关重载内容又被iostream头文件所涵盖，所以只要用预编译命令包含iostream头文件后就可以将cin与’&gt;&gt;‘或cout与’&lt;&lt;'搭配使用来进行基础的输入输出操作。
cin和cout的运行原理 上文的表格提到cin和cout分别是istream_withassign和ostream_withassign的对象，如普通的对象一样，cin和cout都是这个对象的名称，对象代表数据流。
cin是从标准输入设备(键盘)输入到内存的数据流，称为cin流或标准输入流。
cout是从内存输入到标准输出设备(显示器) 的数据流，称为cout流或标准输出流。
个人梳理 当需要输入内容时:
1、由于cin在默认情况下和我们的键盘相连接，所以我们从键盘上按下的按键产生的字符数据会被导入到cin所代表的数据流中；
2、提取运算符&gt;&gt;将数据从这条数据流中提取出来再输入到对应的变量之中，从而完成对变量数据的赋值。
输入流中的数据不会消失，只会不再读取该数据。
当需要输出内容时:
1、插入运算符&lt;&lt;将数据从其右侧的变量中提取出来，再将数据导入到右侧名为cout的数据流中；
2、由于cout这条数据流在默认情况下与我们的显示器相连接，数据就出现在了屏幕上，数据的输出就由此完成了。
程序举例：
#include&lt;iostream&gt; using namespace std; int main(){ int name; cin&gt;&gt;name; cout&lt;&lt;name; return 0; } 当我们输入数据时，数据会先到cin这个输入流中，然后提取运算符&gt;&gt; 将该数据导入到变量name中。
当我们输出数据时，插入运算符&lt;&lt;就会将name变量之中的数据复制一份，随后导入到cout所代表的的输出流当中，进而出现在我们的显示屏上。
因为提取运算符&gt;&gt;关于变量形参是带引用符号(‘&amp;’)的（该名称代表原有变量的别名，也就是一个变量多个名称），因此&gt;&gt;是可以改变变量数据的，也就是变量name的数据。
二、命名空间 下文内容来自C++ Primer Plus（第6版）中文版，P15
名称空间支持是一项C++特性，旨在让您编写大型程序以及将多个厂商的现有的代码组合起来的程序时更容易，它还有助于组织程序。一个潜在的问题是，可能使用两个已封装好的产品，而它们都包含一个名为wanda()的函数。这样使用wanda()的函数时，编译器将不知道指的是哪个版本。名称空间让厂商能够将其产品封装在一个叫做名称空间的单元中，这样就可以用名称空间的名称来指出想使用哪个厂商的产品。因此，Microflop Industries 可以将其定义放在一个名为Microflop的名称中。这样，其wanda（）函数的全称为Microflop::wanda()；同样，Piscine公司的wanda()版本可以表示为Piscine::wanda()。这样，程序就可以使用名称空间来区分不同的版本了。
一种新思想的出现会对从前的代码产生巨大的影响。
命名空间是人们为了解决名称冲突所找到的方法，至于头文件iostream.h则是人们不想让原有的大量代码被迫修改所找到的权宜之计，C++标准是明确不支持这种用法的。
std::cin与cin和std::cout与cout 当我们没有包括其他与cin或cout重名的命名空间时，若加入
using namespace std; cin这个对象则可以直接写成cin而不必写成std::cin。若没有上述的语句，想使用cin对象进行输入则必须写成std::cin来进行使用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2784e8256a6a2349b38db433e5561757/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d93a2c18b9fdb7384a21baf6c020cd86/" rel="bookmark">
			win10安装docker desktop后无法使用vmware
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文
https://blog.csdn.net/weixin_42172261/article/details/123727550
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd1e5cf9a4cba2dd43ad4af754fb09c5/" rel="bookmark">
			jquery之锚点定位和jquery模拟锚点定位效果，页面滚动到相对应的位置时，所在的导航文字高亮显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.常见的锚点定位效果： &lt;a name="print"&gt;&lt;/a&gt; &lt;div id="print"&gt; &lt;!-- HTTP请求没有 # --&gt; 或
&lt;a href="#print"&gt;&lt;/a&gt; &lt;div id="print"&gt; &lt;!-- HTTP请求有 # --&gt; 这种方法，如果网页中有顶部固定导航栏，那么常见的锚点定位就会被遮住了一部分，很难用样式弥补。于是可以考虑第二种方法 js模拟锚点跳转效果
2.js模拟锚点跳转效果 见上一篇详细介绍 这是锚点上一篇：jquery模拟锚点定位效果：锚点定位——如何设置锚点居页面顶部距离，锚点定位并距离顶部一定偏移
但是，这样模拟url是没有#（hash）值的 如果导航有其他分页，就不容易跳回了，比如：
当前页是楼盘信息详情页，如果我想点楼盘相册，想要的效果是跳转到首页，再锚点定位到楼盘相册的位置；
解决方案：
html:
给导航a标签 添加一个#锚点（与模拟锚点点击事件的class同名），后面再用js获取url的hash值，面加载后判断url 是否带有hash值，如有，侧js执行点击相应的hash 事件（附代码如下）
&lt;div class="listnav cenbox"&gt; &lt;div class="cenbox clearfix"&gt; &lt;ul class="xiangqingul"&gt; &lt;li class="on"&gt; &lt;a href="#huxingmao" class="huxingmao"&gt;楼盘户型&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href="#xiangcemao" class="xiangcemao"&gt;楼盘相册&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href="#xinximao" class="xinximao"&gt;楼盘信息&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href="#mapmao" class="mapmao"&gt;位置配套&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href="#fangdaimao" class="fangdaimao"&gt;贷款计算&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href="#zixunmao" class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd1e5cf9a4cba2dd43ad4af754fb09c5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00d33e245f659e05fe9f3713d8f491ff/" rel="bookmark">
			【数学和算法】协方差矩阵、方差
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.方差 方差是判断一个变量（如，身高）距离平均值的偏离程度的量，如，一个班的50个同学的身高方差。
方差只是一个维度，而协方差是多个维度之间的相关性。
方差的性质：
V a r ( x ) = E ( x 2 ) − E 2 ( x ) \displaystyle\color{blue}Var(x) = E(x^2) - E^2(x) Var(x)=E(x2)−E2(x)
对于正态分布来说，期望为0，即：
E ( x ) = 0 \displaystyle\color{blue}E(x) = 0 E(x)=0
那么，正态分布的方差为：
V a r ( x ) = E ( x 2 ) \displaystyle\color{blue}Var(x) = E(x^2) Var(x)=E(x2)
-----------------------------------------------------------------------------
2.协方差与协方差矩阵： 协方差矩阵 的理解可以参考这篇博客：https://zhuanlan.zhihu.com/p/70644127
也可以去看B站的视频，讲的很透彻: https://www.bilibili.com/video/BV12D4y1S7fU/
如果要研究几个变量的相关性，如身高、体重、年龄这三个变量的两两之间的相关性，那么协方差矩阵就是三行三列的矩阵，矩阵的对角线元素是各个变量自己的方差，非对角线的每个元素是各个变量两两之间的协方差。
所以，方差只能说所有人的身高的方差，不能说身高与体重之间的方差。而协方差矩阵的对角线上都是各变量的方差。所以，协方差矩阵包含了各个变量的方差。
-----------------------------------------------------------------------------
2.1 协方差： 注意上面的E[(X-Ux)(Y-Uy)]是对(X-Ux)(Y-Uy)的整体求期望，并不能分别对(X-Ux)和(Y-Uy)求期望，上面公式中(X-Ux)是行向量，(Y-Uy)是列向量。看看下面协方差的公式就明白了：
设X、Y分别表示身高和体重，那么上面的Cov(X,Y)就是所有人的身高与体重二者的协方差，只是一个数字，并不是协方差矩阵。身高与体重的协方差需要对每个人计算(自己身高 - 所有人身高均值)*(自己体重 - 所有人体重均值)，然后再把他们相加求均值，得到的均值也叫期望E，就是身高和体重的协方差。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/00d33e245f659e05fe9f3713d8f491ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5273e278596093aff177a0945c007275/" rel="bookmark">
			【vue-infinite-scroll滚动多次】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考：element
需要在每一次异步加载的开始时禁用这个滚动加载，等异步加载完再打开。否则默认是一直滚动就自动提前触发好几次。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab035aa4783b2da889700ae53124a985/" rel="bookmark">
			SpringIOC底层实现原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、IOC（概念和原理） 1、什么是 IOC 控制反转，把对象创建和对象之间的调用过程，交给 Spring 进行管理使用 IOC 目的：为了耦合度降低 2、IOC 底层原理 xml 解析——XML有三种解析方式：DOM4J SAX STAX DOM工厂模式——把对类的创建初始化全都交给一个工厂来执行，而用户不需要去关心创建的过程是什么样的反射 ——反射可以在运行时根据指定的类名获得类的信息 3、画图讲解 IOC 底层原理 原始方式：
工厂模式：
IOC模式:
4、IOC（BeanFactory 接口） 1、IOC思想是基于IOC容器完成，IOC容器底层就是对象工厂
2、Spring框架中对IOC容器实现提供了两种方式（即两种接口）
第一种接口（BeanFactory接口）：此接口是IOC容器的基本实现，也是Spring框架内部使用的接口，不提供给开发人员进行使用注：此接口是在加载配置文件时不会创建对象，而是在获取对象或使用时才去创建对象第二个接口（ApplicationContext）：此接口是BeanFactory接口的子接口，提供了更强大的功能，一般由开发人员进行 3、ApplicationContext 接口有实现类
FileSystemXmlApplicationContext：这个方法是从文件绝对路径加载配置文件，例如：
ApplicationContext ctx = new FileSystemXmlApplicationContext( "C:/Test/spring.xml ");
ClassPathXmlApplicationContext：这个方法是从classpath下加载配置文件(适合于相对路径方式加载)，例如：
ApplicationContext ctx = new ClassPathXmlApplicationContext( "/spring.xml ");
注：此接口在加载配置文件时就会创建配置文件中所配置的对象
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/922c80d70fd594fd84be62b5d859b8d2/" rel="bookmark">
			提高电脑性能增加fps的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.显卡设置
鼠标设置
键盘设置
电源管理
高级系统设置
360设置
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be1bd8aa623125026b681cba261cd870/" rel="bookmark">
			微信小程序编译.wxml文件编译错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微信小程序编译.wxml文件编译错误 在编写小程序页面的时候，经常会遇到报.wxml文件编译错误。 [ WXML 文件编译错误] ./pages/mine/wallet.wxml
Bad value with message
1 | &lt;view
刚开始找了半天都没发现错误，后面才发现原来是我写页面的时候，插值语法忘记换成后端传过来的数据了，无语子- -。 把插值语法中的中文改掉就不会报错了，不过不同原因都会报这个错误，错误原因大部分都是页面编写问题，可以看报错信息，翻译一下是什么原因。
（希望能帮助到你哦）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/355eb7c4c53d24f728e081b0855c42dc/" rel="bookmark">
			HashMap源码中重要的常量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf231dbc8893bd246e65f660f97ddf82/" rel="bookmark">
			Hadoop3的resourceManager无法启动的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		平台 操作系统：CentOS 8Hadoop版本：3.3.1jdk版本：1.8Java IDE：Eclipse 问题及解决 在window下的eclipse中开发Hadoop程序,一切准备就绪之后,运行代码,没有出现预期的效果,而是一直在尝试连接
在linux中jsp之后发现resourceManager没有启动:
来到在linux中安装Hadoop的目录下,进入到logs目录下,找到resourcemanager的日志文件
发现是端口号被占用:
在网上找了很多,都说是需要杀死进程,最后我打开我的yarn-site.xml文件,发现ip地址写错了
修改成用ifconfig看出来的本身的ip然后保存,重启hadoop
启动成功!
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/277/">«</a>
	<span class="pagination__item pagination__item--current">278/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/279/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>