<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00a7ec1297379f13a933a7c6087ae1ff/" rel="bookmark">
			（四）Flink初体验-1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章基于flink1.15，谨防走错房间
flink官网
first steps Flink旨在以闪电般的速度处理连续的数据流。这篇简短的指南将向您展示如何下载、安装和运行Flink的最新稳定版本。你还将运行一个Flink作业示例，并在web UI中查看它。
下载flink Flink运行在所有类unix环境中，例如Linux、Mac OS X和Cygwin(用于Windows)。您需要安装Java 11。要检查安装的Java版本，在你的终端输入:
$ java -version 进入到下载页面download
将flink压缩包上传到linux服务器（虚拟机啥的都行，容器请自行移步官网），执行解压命令
$ tar -xzf flink-*.tgz # 进入flink解压目录，查看列表信息 $ cd flink-* &amp;&amp; ls -l 上面图片中，有几个地方需要记下来：
bin/ directory contains the flink binary as well as several bash scripts that manage various jobs and tasksconf/ directory contains configuration files, including flink-conf.yamlexamples/ directory contains sample applications that can be used as is with Flink bin目录下是各种脚本，conf目录下是各种配置文件，examples是各种程序demo
启动和停止flink本地集群 执行命令:
$ .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/00a7ec1297379f13a933a7c6087ae1ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/424cfdb210d7c6bef980cacf2ddc58de/" rel="bookmark">
			普通人劳动仲裁全流程详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.办理流程 提出申请——登记——立案受理(不予受理)——庭前调解——开庭审理——裁决——执行——撤销裁决和起诉
2.提出申请 劳动仲裁可以向劳动合同履行地或者用人单位所在地的劳动争议仲裁委员会申请
劳动争议申请仲裁的时效期间为一年。仲裁时效期间从当事人知道或者应当知道其权利被侵害之日起计算。
提交材料
(1)劳动争议仲裁申诉登记表;
(2)申诉书(详细陈述申诉理由和要求，一式两份或按被诉人人数提供);
(3)申诉人身份证明及复印件;
(4)有委托代理人的，需当面签定并提交《授权委托书》，注明委托事项，同时提交受委托代理人的身份证复印件。如委托人的代理人是律师事务所派出的执业律师，应提供执业律师的证件复印件：如委托人的代理人是公民，应提供与委托人签订的不收费代理协议书，以及代理人和委托人之间的关系的法律资料;
(5)被诉人工商注册信息资料;
(6)申诉人与被诉人存在劳动关系的证明材料;(证明材料包括：劳动合同、暂住证、工作证、厂牌、工卡、工资表(单)、入职登记表、押金收据、以及被处罚凭证和被开除、除名、辞退、解除(或终止)劳动关系通知或证书等。申诉人提交证明材料时，应附原件及复印件各一份，审核后退回原件;
(7)《提交证据材料清单》一式两份;
材料来源
公司方的材料可查询国家企业信用信息公示系统
网址为
http://www.gsxt.gov.cn/index.htmlhttp://www.gsxt.gov.cn/index.html
3.登记 劳动争议仲裁委员会收到仲裁申请之日起五日内，认为符合受理条件的，应当受理，并通知申请人;认为不符合受理条件的，应当书面通知申请人不予受理，并说明理由。对劳动争议仲裁委员会不予受理或者逾期未作出决定的，申请人可以就该劳动争议事项向人民法院提起诉讼。
4.立案受理 劳动争议仲裁委员会受理仲裁申请后，应当在五日内将仲裁申请书副本送达被申请人。
被申请人收到仲裁申请书副本后，应当在十日内向劳动争议仲裁委员会提交答辩书。劳动争议仲裁委员会收到答辩书后，应当在五日内将答辩书副本送达申请人。被申请人未提交答辩书的，不影响仲裁程序的进行。
5.开庭审理 一、仲裁庭的组成：
仲裁庭由三名仲裁员组成，设首席仲裁员。简单劳动争议案件可以由一名仲裁员独任仲裁。
二、劳动争议仲裁委员会应当在受理仲裁申请之日起五日内将仲裁庭的组成情况书面通知当事人。
三、回避
1、回避的理由
(1)是本案当事人或者当事人、代理人的近亲属的;
(2)与本案有利害关系的;
(3)与本案当事人、代理人有其他关系，可能影响公正裁决的;
(4)私自会见当事人、代理人，或者接受当事人、代理人的请客送礼的。
四、延期开庭
仲裁庭应当在开庭五日前，将开庭日期、地点书面通知双方当事人。当事人有正当理由的，可以在开庭三日前请求延期开庭。是否延期，由劳动争议仲裁委员会决定。
五、鉴定
仲裁庭对专门性问题认为需要鉴定的，可以交由当事人约定的鉴定机构鉴定;当事人没有约定或者无法达成约定的，由仲裁庭指定的鉴定机构鉴定。
六、撤诉
1、申请人收到书面通知，无正当理由拒不到庭或者未经仲裁庭同意中途退庭的，可以视为撤回仲裁申请。
2、和解撤诉。
七、审理期限
仲裁庭裁决劳动争议案件，应当自劳动争议仲裁委员会受理仲裁申请之日起四十五日内结束。案情复杂需要延期的，经劳动争议仲裁委员会主任批准，可以延期并书面通知当事人，但是延长期限不得超过十五日。逾期未作出仲裁裁决的，当事人可以就该劳动争议事项向人民法院提起诉讼。
6.办理地点 武汉劳动仲裁委员会。
武汉劳动仲裁委员会地址、电话及传真一览表（各区）http://wh.bendibao.com/live/201516/65131.shtm
当事人向当地劳动仲裁委员会提出申请，由劳动仲裁委员会组成仲裁庭，实行一案一庭制。
仲裁庭对追索劳动报酬、工伤医疗费、经济补偿或者赔偿金的案件，根据当事人的申请，可以裁决先予执行，移送人民法院执行。
仲裁庭裁决先予执行的，应当符合下列条件：
(一)当事人之间权利义务关系明确;
(二)不先予执行将严重影响申请人的生活。
劳动者申请先予执行的，可以不提供担保。
7.注意事项 1.钉钉和企业微信等工具，公司将你移除，你所有的记录将会没有，一定要及时录制视屏，录制视屏时一定要录下当前时间，打卡记录，登录app的过程等，不然不具有法律效应
2.所有的证据，要去公证处做公证，不要嫌麻烦。
3.劳动仲裁是不需要钱的，而且可以申请援助律师，也不需要钱
4.一定要表现自己的弱势地位，显得公司才是咄咄逼人的样子，自己表现的受了欺负一样，但是不能软弱，对面提供的证据，一定要质疑，是否编造造价，是否做过公证，是否有理由，造成什么影响。
5.你的每一个需求都需要有理有据，法官很聪明，如
1.请求精神损失，你就出示，领导欺凌，pua,加班，骂人的语音或者聊天记录截屏。
2.无故辞退，你就根据工作年限要求对方赔付1至n个月的工资，提供出工资流水，打卡记录，工牌，劳动合同。
3.误工费，你可以先去面试一家公司，通过这家公司提供的证明和offer要求对方赔付在劳动仲裁期间的误工费，根据您的offer上的工资计算。
需有理有据每一句话都是有证据，对方的每一句话都要质疑，每一个证据都要反驳。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a17994fb733d55b056d3d597c1e7924a/" rel="bookmark">
			wangeditor3.0上传本地图片和本地视频至服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.效果
2.注意:我下载的3.0版本
3.组件(在components文件里创建一个wangEditoe.vue文件)
&lt;template lang="html"&gt; &lt;div class="editor"&gt; &lt;div ref="toolbar" class="toolbar"&gt; &lt;/div&gt; &lt;div ref="editor" class="text" :style="{minHeight:h,width:w}"&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import E from "wangeditor"; import { imgUrl } from "@/api/allApi.js"; import { getToken } from "@/utils/auth"; export default { name: "editor", props: { w: { type: String, default:'100%' }, h: { type: String, default:'600px' }, value: { type: String, default: "", }, isClear: { type: Boolean, default: false, }, }, data() { return { getToken: getToken(), action: imgUrl + "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a17994fb733d55b056d3d597c1e7924a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d8e713462c6c325f10b78d0f40a0d8f/" rel="bookmark">
			node&#43;express 的前后端分离项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		早就听说nodejs功能强大，前后端都涉及的到，尝试学习一下如何利用node去搭建后端项目。nodejs是express的基础，最好先去了解一下nodejs的大概功能。
目录 一、Express项目搭建Express-Generator项目生成器运行项目 目录结构详情bin/www文件app.js处理请求(有必要了解一下路由)views视图模板 热部署 二、添加路由和控制器路由器（Router）和控制器（Controller）定义和使用单独路由模块 三、仿数据库之jsonfs的使用 一、Express项目搭建 假设已经安装了node。
搭建express后端项目有两种方式，第一种就是直接安装express然后去一步一步搭建，第二种则是最为简便的使用express项目生成器，就是express项目脚手架，他会为你自动创建后端所需要的内容，比如路由、http、path以及中间件。
先来了解一下第二种方法
Express-Generator项目生成器 通过应用生成器工具 express-generator 可以快速创建一个应用的骨架。
//全局安装express项目生成器 npm install -g express-generator //使用命令创建express项目 express --view=pug myapp express命令
以下是项目目录结构
├── app.js ├── bin │ └── www ├── package.json ├── public │ ├── images │ ├── javascripts │ └── stylesheets │ └── style.css ├── routes │ ├── index.js │ └── users.js └── views ├── error.pug ├── index.pug └── layout.pug 运行项目 set DEBUG=myemplyservice:*; npm start 接下来就可以访问项目：localhost:3000
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d8e713462c6c325f10b78d0f40a0d8f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0dc2e5cb8d82fec6a605d19bec65b197/" rel="bookmark">
			用GATK进行二代测序数据 SNP Calling 流程：（四）变异过滤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GATK推荐的最好的过滤方式是用 VQSR功能，它通过机器学习算法来判断SNP的优劣，因此至少需要两个已存在的 SNP 数据集，一个是经过验证的高质量 SNP 数据集作为真集（如 HapMap），还需要一个质量不是特别高，允许存在小部分假阳性的数据集做训练集（如，1000G）。这些数据集在人类研究中很容易找到，但是在植物中比较困难，因此本流程用硬过滤（hard-filtering）的方法进行变异过滤。
提取SNP和INDEL SNP 和 INDEL 的过滤参数有所不同，因此分开过滤。
#vcf索引 nohup gatk SelectVariants -V raw.vcf.gz -select-type SNP -O snp..vcf.gz &amp; nohup gatk SelectVariants -V raw.vcf.gz -select-type INDEL -O indel.vcf.gz &amp; SNP 过滤 查看过滤参数的分布情况 可以先查看一下想用的过滤参数的分布情况
#使用gatk的variantstotable功能提取过滤参数信息 nohup gatk VariantsToTable -V snp.vcf.gz -F CHROM -F POS -F QD -F QUAL -F SOR -F FS -F MQ -F MQRankSum -F ReadPosRankSum -O snps.recode.table &amp; nohup gatk VariantsToTable -V indel.vcf.gz -F CHROM -F POS -F QD -F QUAL -F SOR -F FS -F MQ -F MQRankSum -F ReadPosRankSum -O indel.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0dc2e5cb8d82fec6a605d19bec65b197/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d4ca7416387f5c1905b642793e08a7f/" rel="bookmark">
			git之merge和rebase
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面 不管是merge，还是rebase都是将一个分支的修改合并到另一个分支，但是方式方法有所不同，下面我们具体来看下每种情况。
1：merge merge就是合并代码，这种方式合并代码后，合并的结果会生成一个新的commit（效果同手动修改后的提交），而merge又有两种方式分别是fast-forward和，非fast-forward，分别来看下这两种方式。
1.1：fast-forward 当合并代码的时候，如果是没有冲突(更准确的表述应该是文件不需要合并时)，git就会默认采用这种方式，接下来看下具体操作。
基于master创建分支dev100 $ git checkout -b dev100 Switched to a new branch 'dev100' JHP+Administrator@jhp MINGW64 /d/test/test-cherry-pick (dev100) $ git push origin dev100:dev100 Total 0 (delta 0), reused 0 (delta 0), pack-reused 0 remote: Powered by GITEE.COM [GNK-6.3] remote: Create a pull request for 'dev100' on Gitee by visiting: remote: https://gitee.com/dongsir2020/test-cherry-pick/pull/new/dongsir2020:dev100...dongsir2020:master To https://gitee.com/dongsir2020/test-cherry-pick.git * [new branch] dev100 -&gt; dev100 JHP+Administrator@jhp MINGW64 /d/test/test-cherry-pick (dev100) $ git branch --set-upstream-to=origin/dev100 Branch 'dev100' set up to track remote branch 'dev100' from 'origin'.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d4ca7416387f5c1905b642793e08a7f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2a9af67562e1ecd60cbe09ea2807bc6/" rel="bookmark">
			MySQl中所有约束详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 🌲约束1.1 🎃概念1.2 🎃分类1.3 🎃非空约束1.4 🎃唯一约束1.5 🎃主键约束1.6 🎃默认约束1.7 🎃约束练习1.8 🎃外键约束1.8.1 👓概述1.8.2 👓 语法1.8.3 👓 练习 ✨✨大家好,我是Cx_330✨✨ 😘😘😘许久不见，甚是想念 🌲约束 上面表中可以看到表中数据存在一些问题：
id 列一般是用标示数据的唯一性的，而上述表中的id为1的有三条数据，并且 马花疼 没有id进行标示
柳白 这条数据的age列的数据是3000，而人也不可能活到3000岁
马运 这条数据的math数学成绩是-5，而数学学得再不好也不可能出现负分
柳青 这条数据的english列（英文成绩）值为null，而成绩即使没考也得是0分
针对上述数据问题，我们就可以从数据库层面在添加数据的时候进行限制，这个就是约束。
1.1 🎃概念 约束是作用于表中列上的规则，用于限制加入表的数据
例如：我们可以给id列加约束，让其值不能重复，不能为null值。
约束的存在保证了数据库中数据的正确性、有效性和完整性
添加约束可以在添加数据的时候就限制不正确的数据，年龄是3000，数学成绩是-5分这样无效的数据，继而保障数据的完整性。
1.2 🎃分类 非空约束： 关键字是 NOT NULL
保证列中所有的数据不能有null值。
例如：id列在添加 马花疼 这条数据时就不能添加成功。
唯一约束：关键字是 UNIQUE
保证列中所有数据各不相同。
例如：id列中三条数据的值都是1，这样的数据在添加时是绝对不允许的。
主键约束： 关键字是 PRIMARY KEY
主键是一行数据的唯一标识，要求非空且唯一。一般我们都会给每张表添加一个主键列用来唯一标识数据。
例如：上图表中id就可以作为主键，来标识每条数据。那么这样就要求数据中id的值不能重复，不能为null值。
检查约束： 关键字是 CHECK
保证列中的值满足某一条件。
例如：我们可以给age列添加一个范围，最低年龄可以设置为1，最大年龄就可以设置为300，这样的数据才更合理些。
注意：MySQL不支持检查约束。
这样是不是就没办法保证年龄在指定的范围内了？从数据库层面不能保证，以后可以在java代码中进行限制，一样也可以实现要求。
默认约束： 关键字是 DEFAULT
保存数据时，未指定值则采用默认值。
例如：我们在给english列添加该约束，指定默认值是0，这样在添加数据时没有指定具体值时就会采用默认给定的0。
外键约束： 关键字是 FOREIGN KEY
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e2a9af67562e1ecd60cbe09ea2807bc6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc0d256071fa086ef2af57223caf22e1/" rel="bookmark">
			RT-Thread 开启 DFS_USING_POSIX 编译问题的分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 环境 RT-Thread 4.1.0Keil MDK5RT-Thread Studio DFS_USING_POSIX RT-Thread 前面的版本：使用头文件：dfs_posix.h，新版本，这个头文件不存在了经过全局的搜索，发现新版本的RT-Thread，如RT-Thread 4.1.0，需要使用： unistd.h仔细看了下代码，推荐使用的替代方法为： #ifdef DFS_USING_POSIX #include &lt;unistd.h&gt; #include &lt;fcntl.h&gt; #endif /* DFS_USING_POSIX */ fcntl.h 这个里面，有我们熟悉的：open，fcntl 类似于 ioctl int open(const char *file, int flags, ...); int fcntl(int fildes, int cmd, ...); int creat(const char *path, mode_t mode); unistd.h 这个文件的函数比较的多，除了上面的open外，其他的都有了，也就是文件操作函数声明（设备也是文件）都齐全了，如 close read write lseek 等 具体实现 RT-Thread的POSIX 接口（文件系统操作接口），实现的接口主要来自：dfs_posix.c 这个文件，这个文件如 open 调用 dfs_file_open 小结 可以通过全局的搜索，确认函数的组织方式，存在哪里，头文件的引用可以通过头文件，找到函数的具体实现，从而揭开posix的实现方法了解【函数封装】在操作系统中的作用，标准接口的实现原理 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5cfe7600a55819d132bc6f429c657931/" rel="bookmark">
			如何批量的将jpg文件转换为png格式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		生产环境上有一批图片有jpg和png,现需要将他们统一格式，linux上使用图片转换没有安装成功，便在windows上进行转化，很简单也很方便如下：
此处利用脚本实现 jpg-png 转换：
1.文件夹A下全部都是jpg图像
2.在文件夹A下新建txt文本，命名为“批量修改图片格式”
3.打开该文本，输入 ren *.jpg *.png
4.保存，将该txt扩展名改为 .bat
5.双击打开修改扩展名后的txt文件(也就是 .bat 文件)，等待几秒就看到图像全变成png格式了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/314f9435b3dccefae332119e2b8bc09e/" rel="bookmark">
			Android Framework实战开发-binder通信常见（oneway，in，out，inout）元素介绍及binder双向通信的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		csdn在线学习课程，课程咨询答疑和新课信息：QQ交流群：422901085进行课程讨论
android跨进程通信实战视频课程（加群获取优惠）
aidl的一些关键字： 1、oneway介绍 oneway 关键字用于修饰远程调用的行为，被oneway修饰了的方法不可以有返回值，也不可以有带out或inout的参数。
使用oneway时，远程调用不会阻塞；它只是发送事务数据并立即返回。接口的实现最终接收此调用时，是以正常远程调用形式将其作为来自 Binder 线程池的常规调用进行接收。
2、in，out，inout介绍 in、out、inout表示跨进程通信中数据的流向（基本数据类型默认是in，非基本数据类型可以使用其它数据流向out、inout）。
in 表示数据只能由客户端流向服务端。（表现为服务端修改此参数，不会影响客户端的对象）
out 表示数据只能由服务端流向客户端。（表现为服务端收到的参数是空对象，并且服务端修改对象后客户端会同步变动）
inout 则表示数据可在服务端与客户端之间双向流通。（表现为服务端能接收到客户端传来的完整对象，并且服务端修改对象后客户端会同步变动）
注意如果aidl中发现对象类型参数可以不带in，out，inout任何一个，那么它一定属于默认in类型，而且也不能强制给其加上out或inout
具体这里可以看google官方文档的原话：
https://developer.android.google.cn/guide/components/aidl#Create
When defining your service interface, be aware that: Methods can take zero or more parameters, and return a value or void. All non-primitive parameters require a directional tag indicating which way the data goes. Either in, out, or inout (see the example below). Primitives, String, IBinder, and AIDL-generated interfaces are in by default, and cannot be otherwise.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/314f9435b3dccefae332119e2b8bc09e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1eca9a4153aab2f8bd9e0c09483a8b1a/" rel="bookmark">
			Multisim实现D触发器模拟同步计数器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		D触发器模拟同步计数器 一. 元器件介绍二. 原理分析三. 仿真实验1. 单步触发计数器2. 沿时钟触发计数器 一. 元器件介绍 这里用到的元器件有：
DIgital power（VCC）数字电源DIGITAL-CLOCK 数字时钟逻辑分析仪（XLA）ground 数字地SPST 单刀单掷开关74HC74D_4V D触发器芯片DCD_HEX 数码管(带译码器四位二进制输入)PROBE 电位探测灯PB_DPST 弹簧式触发开关SPDT 单刀双掷开关XOR2 双输入异或门AND2 双输入与门AND3 三输入与门 二. 原理分析 D触发器模拟同步计数器以异步计数器为前提
核心仍为使用D触发器作为进位器
关于D触发器模拟异步计数器的相关内容参考如下：
D触发器模拟异步计数器
D触发器的原理也在上文中有所提及，此处不再赘述
同步计数器原理：
（1）先说同步，同步的实现依赖于不同的计数器在相同输出信号的时钟源下同时变化
严格来说，是接在同一时钟源上(考虑到接线等特殊原因需要使用多个时钟源时需要保证信号输出完全相同——一般来说这是不可能的)
即如下图：
D触发器接入同一时钟源，沿时钟上升沿同时输出信号
（2）同步计数器原理：
要将D触发器作为进位器且不影响同步信号
只能在D输入输出信号之间做手脚了
先取一个二位同步计数器来看看我们要实现的输入输出真值表关系：
二位同步计数器真值表 D1A(INPUT1)D2A(INPUT)Q1-D1A(OUTPUT)2Q2-D2A(OUTPUT)digit(decimal)300000101010101211113 以第一列为例
可以看到D1触发器输入输出值一直在翻转，即为输入值取输出值的非值，输出值再取输入值的非值，如此循环进位
是不是非常熟悉
即将 Q ‾ \overline{\mathsf{Q}} Q​输出接入D1输入
如图黑线
D1触发器的进位实现了
那么对D2触发器的进位呢？
对真值表作分析得到三种或更多进位方式
以第三四列为例
可以看到：
当两个输出值相同时，下一时刻(这里指下一个时钟触发沿)，D2输出0；
当两个输出值不同时，下一时刻(这里指下一个时钟触发沿)，D2输出1；
以此提供了异或门实现进位的思路 可以看到：
当Q1、Q2输出值分别对应为1、0时
下一时刻(这里指下一个时钟触发沿)，信号翻转
Q1、Q2输出值分别对应为0、1，此时一次进位
当Q1、Q2输出值分别对应为1、1时
下一时刻(这里指下一个时钟触发沿)，信号翻转
Q1、Q2输出值分别对应为0、0，此时一次进位
以此提供了与非门实现进位的思路 可以看到：
当Q1输出值为1时，下一时刻Q2输出值总是发生翻转
以此提供了与非门的另一种实现进位的思路 以芯片中最常见(1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1eca9a4153aab2f8bd9e0c09483a8b1a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a83945631ad75bb3c82360902beca02/" rel="bookmark">
			Multisim实现D触发器模拟异步计数器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		D触发器模拟异步计数器 一. 元器件介绍二. 原理分析三. 仿真实验1. 单步触发计数器2. 沿时钟计数器 一. 元器件介绍 这里用到的元器件有：
DIgital power（VCC）数字电源DIGITAL-CLOCK 数字时钟逻辑分析仪（XLA）ground 数字地SPST 单刀单掷开关74HC74D_4V D触发器芯片DCD_HEX 数码管(带译码器四位二进制输入)PROBE 电位探测灯PB_DPST 弹簧式触发开关SPDT 单刀双掷开关 二. 原理分析 先来说说D触发器的原理：
74HC74D_4V D触发器芯片有六个：D输入、Preset输入、Clear输入、 Q \mathsf{Q} Q输出、 Q ‾ \overline{\mathsf{Q}} Q​输出、Clock时钟输入
图中对应输入输出电平值： D C L K ‾ \overline{\mathsf{CLK}} CLK Q \mathsf{Q} Q Q ‾ \overline{\mathsf{Q}} Q​0↓011↓10 ↓ = clock transition HIGH to LOW
先来纠正一个错误：
图中74HC74D_4V D触发器芯片为下降沿触发
可实际上查阅相关芯片信息，描述为
the 74hc74 are dual posiN/Ave edge triggered d-type flip-flop.
依据74HC74D数据手册(及实验所得结果)
74HC74D数据手册
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5a83945631ad75bb3c82360902beca02/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4dc6ccb0a4f3abb695277205e19eeaee/" rel="bookmark">
			win10，edge打不开，点了没反应
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点了之后没反应，到这个路径下
C:\Program Files (x86)\Microsoft\Edge\Application\101.0.1210.47
101.0.1210.47这个路径可能每个人不一样，但是纯数字的文件夹。
这个路径下
点这个就可以打开了
然后就可以打开了，但是具体不知道什么原因！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9d90656bd3a4d17a3319d02d83e61d2/" rel="bookmark">
			（三）Flink1.15 发布最新版本说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		官网 https://nightlies.apache.org/flink/flink-docs-release-1.15/release-notes/flink-1.15
变化的依赖概况 在Flink 1.15中有几个变化，当从早期版本升级时，需要更新依赖项名称，主要包括从非Scala模块中选择排除Scala依赖项，以及重新组织表模块。 一个快速的依赖变化清单如下:
对以下模块的任何依赖都需要更新，以不再包含后缀:
flink-cep flink-clients flink-connector-elasticsearch-base flink-connector-elasticsearch6 flink-connector-elasticsearch7 flink-connector-gcp-pubsub flink-connector-hbase-1.4 flink-connector-hbase-2.2 flink-connector-hbase-base flink-connector-jdbc flink-connector-kafka flink-connector-kinesis flink-connector-nifi flink-connector-pulsar flink-connector-rabbitmq flink-container flink-dstl-dfs flink-gelly flink-hadoop-bulk flink-kubernetes flink-runtime-web flink-sql-connector-elasticsearch6 flink-sql-connector-elasticsearch7 flink-sql-connector-hbase-1.4 flink-sql-connector-hbase-2.2 flink-sql-connector-kafka flink-sql-connector-kinesis flink-sql-connector-rabbitmq flink-state-processor-api flink-statebackend-rocksdb flink-streaming-java flink-test-utils flink-yarn flink-table-api-java-bridge flink-table-runtime flink-sql-client flink-orc flink-orc-nohive flink-parquet 对于Table / SQL用户，新的模块flink-table-planner-loader取代了flink- Table - planner_1 .12，并且避免了Scala后缀的需要。 为了向后兼容，用户仍然可以将其与位于opt/中的flink-table-planner_2.12进行交换。 Flink-table-uber被分为flink-table-api-java-uber, flink-table-planner(-loader)和flink-table-runtime。 Scala用户需要显式地添加对flink-table-api-scala或flink-table-api-scala-bridge的依赖。
所涉及问题的详细情况如下。
添加对opting-out Scala的支持 Java DataSet/-Stream api现在独立于Scala，不再传递地依赖于它。具体如下：
如果你只打算在Java类型中使用Java api，那么你可以通过从发行版的lib/目录中删除Flink -scala jar来选择加入一个没有scala的Flink。 然后你就可以使用任何Scala版本和Scala库了。 你可以把Scala本身捆绑到你的user-jar中; 或者放到发行版的lib/目录中。如果您依赖于Scala api，而没有对它们的显式依赖，那么在构建项目时可能会遇到问题。 您可以通过向您正在使用的api添加显式依赖来解决这个问题。 这将主要影响Scala DataStream/CEP api的用户。 许多模块已经失去了它们的Scala后缀。 当混合来自不同Flink版本(例如，一个旧的连接器)的依赖关系时，建议进一步注意，因为您现在可能会拉入单个模块的多个版本(这在以前是通过名称相等来防止的)。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9d90656bd3a4d17a3319d02d83e61d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51566a69c589efbb341195b761f3d1b4/" rel="bookmark">
			论文R语言复现 | 基于 EM 算法的高斯混合模型参数估计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		高斯混合概率在众多领域都有重要应用，依据已知观测数据估计高斯模型中未知参数就显得尤为重要，由于观测值具体来自于高斯分布的哪个分模型是未知的，那么利用传统的极大似然( MLE) 方法进行参数估计就变得十分困难。引入 EM 算法，该方法通过构造分布已知的潜变量对模型进行参数估计，经过多次迭代优化可以使估计值逐渐逼近真实值。本文主要复现该篇文章的实证部分~
目录 一、复现内容二、复现代码 一、复现内容 二、复现代码 alpha_1&lt;-0.5 alpha_2&lt;-0.5 mu_1&lt;-0.36 mu_2&lt;-0.25 sigma_1&lt;-1.4 sigma_2&lt;-1.3 fi&lt;-function(x,mu,sigma){ y&lt;-1/(sqrt(2*pi)*sigma)*exp(-(x-mu)**2/(2*sigma**2)) return(y) } x&lt;-c(0.900,-2.618,1.235,-0.382,0.850,0.443,0.444,0.185,1.502,1.071) gauss_em&lt;-function(x,alpha,mu,sigma){ z&lt;-alpha*fi(x,mu,sqrt(sigma))/(alpha_1*fi(x,mu_1,sqrt(sigma_1))+alpha_2*fi(x,mu_2,sqrt(sigma_2))) mu&lt;-sum(z*x)/sum(z) sigma&lt;-sum(z*((x-mu)**2))/sum(z) alpha&lt;-mean(z) parms&lt;-list(alpha,mu,sigma) return(parms) } gauss_em(x,alpha_1,mu_1,sigma_1) gauss_em(x,alpha_2,mu_2,sigma_2) alpha1_vec&lt;-c() alpha2_vec&lt;-c() mu1_vec&lt;-c() mu2_vec&lt;-c() sigma1_vec&lt;-c() sigma2_vec&lt;-c() for(i in 1:20){ result_1&lt;-gauss_em(x,alpha_1,mu_1,sigma_1) result_2&lt;-gauss_em(x,alpha_2,mu_2,sigma_2) alpha_1&lt;-result_1[[1]] mu_1&lt;-result_1[[2]] sigma_1&lt;-result_1[[3]] alpha_2&lt;-result_2[[1]] mu_2&lt;-result_2[[2]] sigma_2&lt;-result_2[[3]] alpha1_vec&lt;-c(alpha1_vec,alpha_1) alpha2_vec&lt;-c(alpha2_vec,alpha_2) mu1_vec&lt;-c(mu1_vec,mu_1) mu2_vec&lt;-c(mu2_vec,mu_2) sigma1_vec&lt;-c(sigma1_vec,sigma_1) sigma2_vec&lt;-c(sigma2_vec,sigma_2) } em_rst&lt;-data.frame(alpha1_vec,alpha2_vec, mu1_vec,mu2_vec,sigma1_vec,sigma2_vec) em_rst plot_rst&lt;-function(x,xlab,title){ plot(1:20, x, type='o', xlab=xlab, main=title, xaxt='n', col='red') axis(1,1:20) } par(mfrow=c(2,3)) params_names&lt;-c("alpha1","alpha2","mu1","mu2","sigma1","sigma2") params_list&lt;-list(alpha1_vec,alpha2_vec,mu1_vec,mu2_vec,sigma1_vec,sigma2_vec) for(i in 1:length(params_list)){ plot_rst(params_list[[i]], params_names[i], paste0('EM算法——',params_names[i],'迭代趋势')) } 注意：论文表格中的 σ \sigma σ 和 μ \mu μ 标记反了！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/51566a69c589efbb341195b761f3d1b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9fd293ca65e0bd34396f96cb63c3fb8/" rel="bookmark">
			堆排序(详情讲解)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.概述 小顶堆：每个节点的值都小于或者等于它的左右子节点的值
2.0示意图 大堆顶：
堆排序是一种重要的选择排序方法，它只需要一个记录大小的辅助存储空间，每个待排序的记录仅占用一个记录大小的存储空间，因此弥补了树形选择排序的弱点。
大顶堆：每个节点的值都大于或者等于它的左右子节点的值。
一般升序采用大顶堆，降序采用小顶堆
基本思想：
首先将这n条记录按关键字值的大小建立堆（称为初始堆），将堆顶元素r[0]与r[n-1]交换
然后，将剩下的{r[0]..r[n-2]}序列调整成堆
再将 r[0]与r[n-2]交换，再将剩下的{r[0]..r[n-3]}序列调整成堆
如此反复，直到整个序列有序。
这个过程称为堆排序
要实现堆排序需解决以下两个主要问题：
将n条记录的序列按关键字值的大小建成初始堆。
将堆顶记录r[0]与r[i]交换后，如何将序列{r[0]..r[i-1]}按其关键字值的大小调整成一个新堆
3.0筛选法调整堆：算法 代码 //将以low为根的子树调整成小顶堆，low、high是序列下界和上界 public void sift(int low, int high) { int i = low; //子树的根 int j = 2 * i + 1; //j为i结点的左孩子 RecordNode temp = r[i]; while (j &lt; high) { //沿较小值孩子结点向下筛选 if (j &lt; high - 1 &amp;&amp; r[j].key.compareTo(r[j + 1].key) &gt; 0) { j++; //数组元素比较,j为左右孩子的较小者 } if (temp.key.compareTo(r[j].key) &gt; 0) { //若父母结点值较大 r[i] = r[j]; //孩子结点中的较小值上移 i = j; j = 2 * i + 1; } else { j = high + 1; //退出循环 } } r[i] = temp; //当前子树的原根值调整后的位置 // System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f9fd293ca65e0bd34396f96cb63c3fb8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13a1471e50eda32c8ba64db73cf43d67/" rel="bookmark">
			C语言与，或，非，同或，异或，左移，右移及优先级，查表法计算一个十进制数中1的个数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.与：&amp;
2.或：|
3.非：~
4.异或：^
5.同或：~^
6.左移：(&lt;&lt;)
7.右移：(&gt;&gt;)
注意：位运算符中求反运算“~“优先级最高，而左移和右移相同，居于第二，接下来的顺序是按位与 “&amp;“、按位异或 “∧“和按位或 “|“。顺序为~ &lt;&lt; &gt;&gt; &amp; ∧ | 。﻿
在c语言中，!和~均表示取反，这两个的区别在于：
! :代表逻辑取反，即：把非0的数值变为0，0变为1;
~ :表示按位取反，即在数值的二进制表示方式上,将0变为1，将1变为0；
查表法计算一个十进制数中1的个数：
#include&lt;stdio.h&gt; int getbit(int x) { int sum=0; int ar[]={0,1,1,22,1,2,2,3,1,2,2,3,2,3,3,4}; for(int i=0;i&lt;sizeof(int)*2;++i) { sum=sum+ar[x&amp;0x0f]; x=x&gt;&gt;4; } return sum; } int main() { int x; scanf("%d",&amp;x); int sum=getbit(x); printf("%d",sum); return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88d22ea7674438b539e2134886bc8fb1/" rel="bookmark">
			GAMES101学习-第8课进行shader的初步了解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
理解GLSL代码
uniform变量
OpenGL&amp;Direct API的运作
什么是API
什么是OpenGL
什么是DirectX
shadertoy网站
理解GLSL代码 下面是对老师课上举的一个GLSL(OpenGL-shader-language)的shader例子做一个简单的注释，便于理解：
uniform变量 GLSL shader中的全局变量，类似于C++里的static/extern（这里先不考虑static和extern的不同），可以在任意shader（vertex/geometry/fragment shader）中访问，一旦初始化就不能随意修改，不然会引起编译错误。
关于uniform的定义和使用后续再进行探讨，这里主要是为了理解老师代码里uniform的含义。
//GLSL是一个简单的像素着色器的小程序，告诉一个像素的颜色是什么 //uniform变量是GLSL shader中的全局变量，可以随意在任意shader uniform sample2D myTexture;//纹理全局变量 uniform vec3 lightDir;//光照方向，认为每个像素有个固定的光照方向 varying vec2 uv; varying vec3 norm;//插值出来每个像素的法线是norm，插值这个步骤OpenGL来做 void diffuseShader() //对每一个像素都执行一次，因此不需要循环 { vec3 kd; kd = texture2d(myTexture, uv);//漫反射系数（与纹理相关） //dot表示向量点乘；clamp函数限制了值在[0,1] kd *= clamp(dot(-lightDir, norm), 0.0, 1.0);//最最简单的Phong模型的漫反射步骤，这里的光的方向是朝向shading point的，是负数，跟games101学到的“light朝着光源”不一样 gl_FragColor = vec4(kd, 1.0);//表示该像素的颜色是什么 } 课程的末尾部分，老师还提到去了解一下OpenGL和Direct的运作：
OpenGL&amp;Direct API的运作 什么是API 该部分参考：什么叫做API？看完你就理解了
全称Application Progarmming Interface，即应用程序编程接口。程序员在开发应用程序时，通过API来编写程序就可以避免编写一些无用程序。API大多数由后端编写，前端开发人员进行直接调用。用户提出某项请求，开端开发人员将请求传递传递给后端，后端再根据请求地址返回结果。
比如在用C语言编程时，我们（程序员）可以直接调用sort()函数实现排序，十分简单。这段过程其实很复杂，要先扫描硬盘查找文件-&gt;读取文件数据-&gt;将数据放入内存-&gt;翻译数据-&gt;显示在屏幕上，这些复杂的操作都被放在了函数sort()，附带在了操作系统里，程序员只需调用函数即可。
这些封装好的函数就叫做API。
我们用的各种编程语言自带的标准库就是API（文件后缀为.lib的一些文件），这些库由开发者们编写，完善，便于我们使用。
C语言API以函数形式呈现：例如printf();
Java API主要以类形式呈现：String;
C++是C的扩展，C++ API既包含函数也包含类；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/88d22ea7674438b539e2134886bc8fb1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd1c1d0f82d5997afaf4ae4b1c38703d/" rel="bookmark">
			python&#43;GDAL给图像设置地理参考（GeoTransform和Projection的设置）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用GDAL给遥感影像设置地理参考和投影，分别设置两个参数：GeoTransform和Projection。对于没有附带地理信息的影像，需要从其它途径获取参数，如xml等元数据。
GDAL 中，GeoTransform是一个六个元素的元组。六个参数分别为：
（左上角x坐标， 水平分辨率，旋转参数， 左上角y坐标，旋转参数，-垂直分辨率） 应该注意，最后一个参数是负值，旋转参数一般是0。而对于没有投影的图像（如WGS 84只有地理坐标系），它的分辨率不是以米位单位，而是经纬度，所以不能简单地指定分辨率这两个参数。我是通过获取xml元数据中的经纬度范围和图像尺寸（像素数）计算得到的。如：
Lon_Res = (TopRightLongitude - TopLeftLongitude) / (float(ysize)) Lat_Res = (TopLeftLatitude - BottomLeftLatitude) / (float(xsize)) 通过6个参数，就能确定图像在地理空间的位置。投影信息只需指定ESPG代码。代码如下：
# 设置geotransform。只需要左上角经纬度和横纵分辨率。 geotransform = (TopLeftLongitude, Lon_Res, 0, TopLeftLatitude, 0, -Lat_Res) out_img.SetGeoTransform(geotransform) # 设置投影坐标 # 获取地理坐标系统信息，用于选取需要的地理坐标系统 srs = osr.SpatialReference() srs.ImportFromEPSG(4326) # 定义输出的坐标系为"WGS 84" out_img.SetProjection(srs.ExportToWkt()) # 给新建图层赋予投影信息 完成地理参考设置后，图像在地理空间中的位置就确定了，在arcgis加载的效果如下：
而实际效果应该为：
可以看出，设置地理参考后，能够将图像呈现在对的位置（左上角坐标和分辨率固定），但无法纠正其几何形变。对高分影像而言，几何校正需要结合提供的rpb文件完成。下一步将使用rpb文件完成几何校正。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1c718456a8bb0889bc61dcfd7115a16/" rel="bookmark">
			别怕手速慢了，我用Python自动抢红包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		相信大家在节假日期间都会和亲戚朋友互发红包吧，有时候是给个人发红包，有时候是在群里抢红包，其实大家都知道真正的意义并不在于红包里的那点钱，最重要的是红包增进了相互之间的感情，并且还增添了几分节日气氛。
但是气氛归气氛，总是让你抢到最小的红包，或者当你看到红包的时候已经被抢光了，这时我们难免会有些不愉快。怎么办呢？别忘记我们有Python啊，号称除了生孩子其余的都会的一种编程语言！
抢红包不得不提一个Xposed框架，它可以说是专为抢红包而生的，但是很有点难受的是：使用Xposed框架有一个前提条件就是手机需要root，所以如果你是苹果手机，那么就需要越狱了，但是手机想要越狱就比较难，尤其是苹果这种国外品牌的手机，想要越狱难度就更大了。
为了自动抢红包，python能帮我们实现吗？
答案是肯定的，本文就带大家一起探索下用Python如何实现自动抢红包。
1 环境 操作系统：Windows
Python版本：3.7.2
手机系统：Android
2 需求分析 制定的需求就是实现自动抢红包，打开微信，然后进入到要抢红包的群聊，识别群中的微信红包，再执行抢红包的动作就行。
当然这只是抢红包的关键动作，怎么实现还需要一步一步来，值得一提的是电脑版微信没有抢红包这个功能，所以还是需要通过电脑控制手机来自动抢，那就要确保「adb」命令可正常执行。
识别微信中的消息，是红包还是普通的信息，这里我们通过聊天消息的元素标识来判断。这里我们借助了「Airtest IDE」工具来实现。
3：前置准备 3.1 打开手机的USB调试 想要使用「adb」，需要打开手机的USB调试功能，然后在设置中会出现手机系统设置的“开发人员选项”。
在手机上打开USB调试后，接下来我们通过Airttest IDE验证 adb 运行是否正常。
3.2 下载安装Airtest 下载地址：http://airtest.netease.com/
下载之后，解压打开就可以使用。
使用AirtestIDE对Android应用进行操作，先连接Android设备。
4 抢红包流程回顾 打开微信，在最左侧的Tab页，微信消息列表，我们需要从这里选择指定的群聊来抢红包。
分析下里面的元素标识：
▲聊天页面中整体的群聊消息的元素标识
▲聊天页面中单个群聊消息的元素标识
接下来在要抢红包的群中，识别红包并执行抢红包的操作。
先看下红包标识：
▲红包标识1：com.tencent.mm:id/aql
▲红包标识的示例2 ：com.tencent.mm:id/aql
点击红包，记录下弹出的红包页面中“开”的标识
▲大红包页面中”开“的标识 com.tencent.mm:id/d02
这里需要添加一个判断，检测这个红包是不是有效红包，如果已经被领取完，或者已经被自己领取，还是就是指定领取人的红包，在执行的时候就可以跳过。
▲已领取红包的标识 com.tencent.mm:id/apk
▲已被领完红包的标识 com.tencent.mm:id/apk
我们用的各元素的标识都已取到，接下来就是组织我们的代码。
5 代码梳理 # 打开手机微信 poco(text='微信').click() #获取当前页面中所有所有群聊的名称 群聊消息的元素标识Chat_msg = poco(name='com.tencent.mm:id/d1v').offspring('com.tencent.mm:id/b6e') # 获取当前页面中所有群聊的名称 Chat_names = [] Chat_names = list(map(lambda x: x.get_text(), Chat_msg)) # 指定抢红包的群聊名称 chat = input('请指定群聊名称:') if chat in Chat_names: index = Chat_names.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f1c718456a8bb0889bc61dcfd7115a16/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77b86707c77ba0b820bf6cca4abc7862/" rel="bookmark">
			DevOps运维实战- 在目标服务器配置命令脚本，拉取镜像并且运行。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如题目所讲，这篇的主要目的就是在目标服务器配置sh脚本。目的：
1. 停止当前正在跑的容器。
2. 删除容器，
3， 删除镜像
4.拉取指定镜像
5.运行镜像。
1/2代码：
harbor_addr=$1 harbor_repo=$2 project=$3 version=$4 port=$5 imageName=$harbor_addr/$harbor_repo/$project:$version echo $imageName containerid=`docker ps -a| grep ${project} | awk '{print $1}'` echo $containerid if [ "$containerid" != "" ] then docker stop $containerid docker rm $containerid fi 3代码：
tag=`docker images |grep ${project} |awk '{print $2}'` echo $tag docker rmi $imageName 4 代码：
docker login -u admin -p Harbor12345 192.168.0.51:80 docker pull $imageName 5代码：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/77b86707c77ba0b820bf6cca4abc7862/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dece7899b830f64ec37cf1072ad7bab6/" rel="bookmark">
			java特性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 前言一、面向对象二、平台无关性三、简单性四、分布式五、健壮性六、高性能七、安全性 前言 Java 语言是一种分布式的面向对象语言，它继承了 C++ 语言面向对象的技术核心，也拋弃了 C++ 的一些缺点，比如说容易引起错误的指针以及多继承等，同时也增加了垃圾回收机制，释放掉不被使用的内存空间，解决了管理内存空间的烦恼。
Java具有面向对象、平台无关性、简单性、解释执行、多线程、安全性等很多特点，下面针对这些特点进行逐一介绍。
一、面向对象 在面向对象编程世界里，一切皆为对象。对象是程序的基本单元，我们通常把对象的数据(字段)称为属性，把对象的行为称为方法。对象把程序与数据封装起来提供对外访问的能力，提高软件的重用性，灵活性和扩展性。面向对象的三大特性是封装、继承和多态，我们下一期对这三大特性详细讲解。
二、平台无关性 Java是可以跨平台，实现“一次编写，到处运行”的语言。Java之所以可以跨平台，这离不开JVM（java虚拟机）。JVM是一个软件，在不同的平台上，JVM有不同的版本。Java在编译之后会生成一种.class文件，这种文件成为字节码文件。JVM虚拟机就是将Java编译后的.class文件翻译成特定平台下的机器码，然后运行。也就是说，在不同平台上装上平台对应的JVM虚拟机后，就可以将Java字节码文件转换，然后运行我们的Java程序。
值得注意的是，Java编译后的结果是生成字节码，而不是机器码。字节码是不可以直接运行的，必须通过JVM再次翻译成机器码才可以运行。即使是将Java程序打包成可执行文件，也仍然需要JVM的支持才可以运行。
三、简单性 Java 语言的语法与 C 语言和 C++ 语言很相近，它舍弃了很多 C++ 中难以理解的特性，如操作符的重载和多继承等，而且 Java 语言不使用指针，加入了垃圾回收机制，解决了程序员需要管理内存的问题，使编程变得更加简单。
四、分布式 Java 语言支持 Internet 应用的开发，在 Java 的基本应用编程接口中就有一个网络应用编程接口，它提供了网络应用编程的类库，包括 URL、URLConnection、Socket 等。Java 的 RIM 机制也是开发分布式应用的重要手段。
五、健壮性 Java 的强类型机制、异常处理、垃圾回收机制等都是 Java 健壮性的重要保证。另外，Java 的异常机制也是健壮性的一大体现。Java程序不可能造成计算机崩溃。即使Java程序也可能有错误。如果出现某种出乎意料之事，程序也不会崩溃，而是把该异常抛出，再通过异常处理机制加以处理。
六、高性能 Java 的高性能主要是相对其他高级脚本语言来说的，随着 JIT（Just in Time）即时编译技术的发展，Java 的运行速度也越来越高。
七、安全性 Java 通常被用在网络环境中，为此，Java 提供了一个安全机制以防止恶意代码的攻击。除了 Java 语言具有许多的安全特性以外，Java 还对通过网络下载的类增加一个安全防范机制，分配不同的名字空间以防替代本地的同名类，并包含安全管理机制。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d27a47972640d7c809f4ed35552f907/" rel="bookmark">
			DevOps运维实战---jenkins 自动化生成镜像并推送到harbor服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 这个内容就比较简单了。
之前我们的流程是直接发送 docker-compose命令去编排生成，运行。
在这一节，我们的目的是docker build 生产镜像，然后推送到docker 镜像服务器，然后下一节我们在目的服务器运行sh 文件抓取镜像并且运行。
在构建里面操作。ssh exec command。
cd /usr/local/docker/jenkins_docker/data/workspace/mytest
docker build -t mytest:$tag .
这里我们生成了一个镜像。至于dockerfile 文件和前面保持一致，这里我们删除掉docker-compose 文件了
docker login -u admin -p Harbor12345 192.168.0.51:80
docker tag mytest:$tag 192.168.0.51:80/repo/mytest:$tag
docker push 192.168.0.51:80/repo/mytest:$tag
这里我们登陆harbor 服务器，然后把我们的镜像推送到harbor 服务器。
这里有个需要注意的地方，我们拉取的镜像是要jenkins 容器里面操作的，所以我们需要jenkins 容器能够使用宿主机器的docker，这个地方很重要：
cd /var/run 下面的这个文件 Docker.sock ，把它修改为root ：root 并且读写权限。 chown root:root docker.sock Chmod o+rw docker.sock 修改jenkins 的 docker-compose.yml 文件 加3个 文件映射 - /var/run/docker.sock:/var/run/docker.sock -/usr/bin/docker:/usr/bin/docker -/etc/docker/daemon.json:/etc/docker/daemon.json 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e58437a011546f91b437aaaf38810095/" rel="bookmark">
			openEuler Linux 下载安装 JDK 配置环境变量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		openEuler Linux 下载安装 JDK 配置环境变量 下载页面:https://www.oracle.com/java/technologies/downloads/ 下载常用软件 yum -y install wget tar vim 下载安装包 wget https://download.oracle.com/java/17/latest/jdk-17_linux-x64_bin.tar.gz 解压缩安装包到指定目录 tar -zxvf jdk-17_linux-x64_bin.tar.gz -C /opt 修改目录名 mv /opt/jdk-17.0.3.1/ /opt/jdk-17 检查软件是否可以 /opt/jdk-17/bin/java -version 配置环境变量 系统环境变量用户环境变量读取时机/etc/profile~/.bash_profile用户登录读取一次/etc/bashrc~/.bashrc每次运行shell都会读取一次 vim /etc/profile vim /etc/bashrc vim ~/.bash_profile vim ~/.bashrc 以 /etc/profile 文件举例
vim /etc/profile 在文件末尾追加以下内容
jdk9及以上版本
export JAVA_HOME=/opt/jdk-17 export PATH=$PATH:$JAVA_HOME/bin export CLASSPATH=.:%JAVA_HOME%/lib/jrt-fs.jar jdk1.8
export JAVA_HOME=/opt/jdk-8 export PATH=$PATH:$JAVA_HOME/bin export CLASSPATH=.:%JAVA_HOME%/lib/dt.jar:%JAVA_HOME%/lib/tools.jar 检查环境变量 printenv 结果如下：
SHELL=/bin/bash HISTCONTROL=ignoredups HISTSIZE=1000 HOSTNAME=openEuler PWD=/root LOGNAME=root MOTD_SHOWN=pam HOME=/root LANG=zh_CN.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e58437a011546f91b437aaaf38810095/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cac57fbff050f339721ce0e72752d47c/" rel="bookmark">
			操作系统——信号量（理解什么是信号量，信号量如何解决同步互斥问题，信号量一些注意点）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 信号量是什么 信号量（semaphore）是操作系统用来解决并发中的互斥和同步问题的一种方法。
信号量是一个与队列有关的整型变量，你可以把它想象成一个数后面拖着一条排队的队列，如图：
那信号量上面值n代表什么意思呢？
n&gt;0：当前有可用资源，可用资源数量为n
n=0：资源都被占用，可用资源数量为0
n&lt;0：资源都被占用，并且还有n个进程正在排队
那信号量拖着的那个队列就是用来放正在排队想要使用这一资源的进程
信号量伪代码 信号量的伪代码又如何实现呢
在代码中我们可以看到有两个对信号量的count值和阻塞队列的操作，一个是semWait，一个是semSignal，前者也被称为P操作，后者也被称为V操作。
这两个操作的用途是什么呢？
semWait我们可以理解为申请资源
semSignal我们可以理解为释放资源
当申请资源的时候，资源数count值-1，我们注意到资源数如果在-1之后&lt;0,那么这个这个进程就会加入到等待队列
为什么这个条件设置成&lt;0呢？
其实很好理解，当这个资源已经其他进程占有完了，即为0或者负数，那么新进程要申请这个资源时资源数再减1必然count&lt;0，那么这个进程就要被被阻塞，进入阻塞队列
再看semSignal操作
一个进程终会使用完这个进程，然后离开，那么此时可用资源数+1
为什么这个条件设置成&lt;=0呢？
一个进程用完资源走了，count++，如果还有进程在排队（count即值是-1或者更小），那+1之后必然count&lt;=0，此时就唤醒一个排队中的进程
信号量解决互斥同步问题 用一个经典例子来说——生产者/消费者问题
首先我们分析这里有几种进程，很显然有两种： 消费者生产者 分析进程之间的关系有什么： 互斥关系：缓冲区是临界资源，各进程互斥访问
两组同步关系
只有缓冲区未满，生产者才能往缓冲区放产品
只有缓冲区非空，消费者才能从缓冲区取产品
根据以上分析，写出大致的伪代码如下： 总结 semWait(S)：请求分配一个资源。
semSignal(S)：释放一个资源。
semWait、semSignal操作必须成对出现。
用于互斥时，位于同一进程内（初始值为1）；用于同步时，交错出现于两个合作进程内。
（且在前事件后加semSignal，在后事件前加semWait），比如先刷牙再吃饭，那刷牙这个事件后加semSignal，在吃饭这个事件前加semWait 多个semWait操作的次序不能颠倒，否则可能导致死锁。
多个semSignal操作的次序可任意。
转载： https://blog.csdn.net/weixin_43914272/article/details/108317212 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bab878ac2d377ee51d4aa76038a865a7/" rel="bookmark">
			VMware Workstation安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 软件介绍
VMware Workstation 寄居架构（实验环境、测试环境）
a) 虚拟机作为应用软件安装在操作系统上；
b) 可以在此应用软件上安装多个操作系统；
c) 直接安装在硬件上的系统为宿主；
简单的说就是，好比寄居蟹，贝壳好比如电脑硬件，螃蟹好比电脑系统，螃蟹在贝壳中生活，在螃蟹体内又长出很多小螃蟹。
下载地址
1、官网地址：
https://www.vmware.com/cn.html
2、在下方公众号回复【VMware Workstation】，也可直接获取下载链接。
网络安全学习圈
分享网络安全技术、入门到进阶教程、前沿领域资讯等！
8篇原创内容
公众号
以下是安装流程，一起来看看吧~
安装步骤
安装环境：windows10系统 + vmware workstation 15.5.5 安装包
1.双击安装包
2.点击下一步
3.选中我接受许可协议中的条款，选择下一步
4.更改软件安装目录，可以安装在除c盘以外的任意目录
5.用户体验设置，点击下一步
6.选择生成快捷方式，下一步
7.点击安装
8.等待安装完成，桌面会生成一个vmware workstaion软件快捷方式
想要学习更多内容，加下方小姐姐微信，领取免费资料 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/394e146913f90e01c15931593a3ff30b/" rel="bookmark">
			elementui el-table的sortable排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		附上elementui的官网
安装elementui以及引入 安装 npm i element-ui -S 引入，在main.js中 全部引入 import Vue from 'vue'; import ElementUI from 'element-ui'; import 'element-ui/lib/theme-chalk/index.css'; import App from './App.vue'; Vue.use(ElementUI); new Vue({ el: '#app', render: h =&gt; h(App) }); 按需引入,创建elementui.js,在main.js中直接引入 elementui.js import Vue from 'vue'; import 'element-ui/lib/theme-chalk/index.css'; import { Table, TableColumn } from 'element-ui'; Vue.use(Table); Vue.use(TableColumn); main.js import "../plugins/elementui"; el-table排序 给el-table-column添加sortable属性
&lt;el-table-column width="100" prop="name" label="账号" sortable&gt; &lt;/el-table-column&gt; 这个只是当前页面的排序，如果翻到下一页，排序还是默认的第二页的排序
如果排序需要用到后端去排序，需要将sortable的属性值设置为custom，
并且给el-table添加sort-change方法,
设置默认排序类型和默认以哪一列排序 :default-sort =“{‘prop’: prop,‘order’:type}”
排序的字符为prop，如果排序的字符和td显示的字符不一样，可以用template
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/394e146913f90e01c15931593a3ff30b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20b8c612da13e7e4f183fdd85d29e49d/" rel="bookmark">
			DevOps运维实战--Harbor的安装和配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是Harbor？？？ VMware开源的企业级Registry项目Harbor，以Docker公司开源的registry 为基础，提供了管理UI, 基于角色的访问控制(Role Based Access Control)，AD/LDAP集成、以及审计日志(Audit logging) 等企业用户需求的功能
简单的说就是一个类似dockerhub的镜像仓库。
安装步骤 下载 harbor-offline-installer-v1.10.1。 建议找个百度网盘地址下载，官网下载太惊人了。
解压缩当前文件：
[root@localhost harbor]# tar -zxvf harbor-offline-installer-v1.10.1.tgz -C /usr/local/harbor
注意找到里面的harbor.yml 文件。 修改它： vi harbor.yml
三个小地方要注意：
1. Hostname: 当前centos服务器的ip
2. Https 的都注释掉，我们先不走这个地方。
3. 记住默认密码。
运行安装harbor 服务器：
./install.sh.这个地方安装还是需要docker docker-compose 支持的，如果你本机没有它会跑的慢一点。
好了，到这里应该装完了，我们打开站点看一下： you ip address: 80
新建一个repo的项目，这里我们设置公开访问。我们尝试把现有的一个镜像推送过去。首先 docker login -u admin -p Harbor12345 192.168.0.51，不幸的消息出现： WARNING! Using --password via the CLI is insecure. Use --password-stdin. Error response from daemon: Get "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/20b8c612da13e7e4f183fdd85d29e49d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99ce39d5e89d81a5fbe721e95ba0504d/" rel="bookmark">
			【C&#43;&#43;】错误 C4996 ‘localtime‘：This function or variable may be unsafe.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 char ch[64]; strftime(ch, sizeof(ch), "%Y-%m-%d-%H-%M-%S", localtime(&amp;t)); //年-月-日 时-分-秒 报错如下：
严重性 代码 说明 项目 文件 行 禁止显示状态
错误 C4996 'localtime': This function or variable may be unsafe. Consider using localtime_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details. MyCardTest d:\mycardtest\mycardtest\mycontrolcard.cpp 2071 注意：这是报错，不是警告，在网上找了一些解决方案，都没有解决。
这是网上找的解决方法：
Answer：
1, 在项目设置的C/C++选项中，把检查64位移植性去掉。
2, 方案a：使用_localtime_s, _localtime32_s, _localtime64_s这3个函数代替localtime
方案b：去掉C4996警告，比如按照提示所说 #define _CRT_SECURE_NO_WARNINGS 1
或者直接#pragma warning( disable : 4996 )
我的解决方案：
项目——属性——C/C++——命令行——其它选项 输入 /D _CRT_SECURE_NO_WARNINGS 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8689bd4869719246350bca72178ff425/" rel="bookmark">
			Bazel官方教程 -- 通用C&#43;&#43;使用案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Bazel官方教程 – 通用C++使用案例 官方参考：https://docs.bazel.build/versions/main/cpp-use-cases.html
在这里，您将找到一些使用 Bazel 构建 C++ 项目的最常见用例。 如果您还没有学习构建 C++ 项目，请先完成教程 Bazel官方教程 – 构建C++工程基础知识，然后再来循序渐进学习，下文标黄色的重点是与官方提供代码有出入的细节。
有关 cc_library 和 hdrs 头文件的信息，请参阅 cc_library。
1. 在一个目标中包含多个文件 您可以使用 glob 在单个目标中包含多个文件。 例如：
cc_library( name = "build-all-the-files", srcs = glob(["*.cc"]), hdrs = glob(["*.h"]), ) 使用此目标，Bazel 将找寻 BUILD 文件相同的目录下所有 .cc 和 .h 文件（不包括子目录），来构建项目。
2. 使用传递包含 如果文件包含头文件，则文件的规则应取决于该头文件的库。 相反，仅需要将直接依赖项指定为依赖项。 例如，假设sandwich.h 包含bread.h，而bread.h 包含flour.h。sandwich.h 不包括floor.h（谁想要 floor.h 在sandwich.h 中？），所以 BUILD 文件看起来像这样：
cc_library( name = "sandwich", srcs = ["sandwich.cc"], hdrs = ["sandwich.h"], deps = ["
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8689bd4869719246350bca72178ff425/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82ee36ebaa97423b29878aba4fa49e64/" rel="bookmark">
			SuperMap iDesktop 10i / 11i 扩展插件开发 - 加载 SuperMap iServer 三维服务和地图服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 SuperMap iDesktop 10i / 11i 扩展插件 - 加载 SuperMap iServer 三维服务和地图服务1. SuperMap iDesktop 10i / 11i 扩展插件开发2. SuperMap iDesktop 10i / 11i 插件 “加载 SuperMap iServer 三维服务和地图服务” 设计2.1. SuperMap iServer 服务列表2.2. 地图服务列表2.3. 三维服务列表2.4. 插件流程设计 3. SuperMap iDesktop 10i / 11i 插件 “加载 SuperMap iServer 三维服务和地图服务” 使用3.1. SuperMap iServer 服务支持3.2. “加载 SuperMap iServer 三维服务和地图服务” 插件使用教程 SuperMap iDesktop 10i / 11i 扩展插件 - 加载 SuperMap iServer 三维服务和地图服务 1. SuperMap iDesktop 10i / 11i 扩展插件开发 SuperMap iDesktop 10i 下载地址、SuperMap iDesktop 11i 下载地址、SuperMap iServer 10i 下载地址
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/82ee36ebaa97423b29878aba4fa49e64/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/157b5d42264c59ed7271fe1d6773c071/" rel="bookmark">
			【JVM】类加载过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 类加载过程类的生命周期类加载过程类初始化时机类与类加载器类加载器分类双亲委派模型 以下是类加载过程中信息的执行顺序： 类加载过程 在Java中，所谓类的加载是指将类的相关信息加载到内存。在Java中，类是动态加载的，当第一次使用这个类的时候才会加载，加载一个类时，会查看其父类是否已加载， 如果没有，则会加载其父类。
类的生命周期 包括以下 7 个阶段：
加载（Loading）验证（Verification）准备（Preparation）解析（Resolution）初始化（Initialization）使用（Using）卸载（Unloading） 类加载过程 包括了加载、验证、准备、解析和初始化这5个阶段
1、加载
加载是类加载的一个阶段，注意不要混淆。
加载过程完成以下三件事：
通过类的完全限定名称获取定义该类的二进制字节流。将该字节流表示的静态存储结构转换为方法区的运行时存储结构。在内存中生成一个代表该类的 Class 对象，作为方法区中该类各种数据的访问入口。 其中二进制字节流可以从以下方式中获取：
从 ZIP 包读取，成为 JAR、EAR、WAR 格式的基础。从网络中获取，最典型的应用是 Applet。运行时计算生成，例如动态代理技术，在java.lang.reflect.Proxy使用 ProxyGenerator.generateProxyClass 的代理类的二进制字节流。由其他文件生成，例如由 JSP 文件生成对应的 Class 类。 2、验证
确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。
3、准备
类变量是被 static 修饰的变量，准备阶段为类变量分配内存并设置初始值，使用的是方法区的内存。
实例变量不会在这阶段分配内存，它会在对象实例化时随着对象一起被分配在堆中。应该注意到，实例化不是类加载的一个过程，类加载发生在所有实例化操作之前，并且类加载只进行一次，实例化可以进行多次。
初始值一般为 0 值，例如下面的类变量 value 被初始化为 0 而不是 123。
public static int value = 123; 如果类变量是常量，那么它将初始化为表达式所定义的值而不是 0。例如下面的常量 value 被初始化为 123 而不是 0。
public static final int value = 123; 4、解析
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/157b5d42264c59ed7271fe1d6773c071/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3aea2f46b1b6a0e32441829a79af690d/" rel="bookmark">
			【工作笔记】Kettle打开后没有出现资源库的连接按钮解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Kettle作为ETL数据处理工具，且又是免费开源软件，在市面比较流行。它可以创建转换和作业两种任务，转换以.ktr结尾，作为以.kjb结尾。Kettle将保存和管理这些转换和作业的方式称为资源库，资源库分为文件资源库和数据库资源库。
在打开Kettle的Spoon进行开发工作时，我们不时会遇到找不到资源库的连接按钮的情况，如下图：
通常这种情况为Kettle在打开时读取相关配置文件出现错误导致，而读取文件出错又一般为文件中存在乱码情况。我们进入KETTLE_HOM\.kettle目录下，找到repositories.xml文件，这个是资源库的配置文件，用文本编辑器打开可以发现里面有乱码，问题找到了。
解决方法：
1.简单粗暴，直接删除repositories.xml文件。重新打开Kettle，此时连接资源库按钮就出现了。不过我们之前保存的连接信息需要重新配置。
2.细致些，将存在乱码的对应组删除。
对于repositories.xml文件中出现代码问题，在我看来是由于Kettle对于中文的支持不太好，我们在开发或使用过程中，如果使用了中文（特别是路径和文件名），Kettle在保存时无法识别即成为乱码。
所以，作为开发人员哪怕英文再烂也要养成文件名使用英文的习惯，切忌使用中文或含空格字符，否则经常会出现一些莫名奇妙的问题。
PS：无论哪种方法，在操作前都需要先备份！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f17c8a0960e09988e867ea6fb0d58fae/" rel="bookmark">
			C语言的常量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下面介绍C语言常量
常量是在程序执行过程中，其值不发生改变的量，分为直接常量和符号常量两种。
直接常量
直接常量又分为整型常量，实型常量，字符型常量和字符串常量。
1. 整型常量
整型常量即整数，包括正整数、负整数和零。C语言中，整型常量可以用十进制、八进制和十六进制表示。
八进制表示：由数字0~9，正、负符号组成，如369，-663等；
十进制表示：以o为前缀，其后由数字0~7组成，如0163，036等；八进制数一般是无符号数。如0192，-011都是不合法的八进制常量。
十六进制表示：以0x或0X为前缀，其后由数字0~9和字母A–Z(字母大小写均可）组成，如0x12cd，0X6Fa等。十六进制数一般是无符号数。
注意：
（1）在一个整型常量后加一个字母u或U，认为是unsigned int 型，如246U.
（2）在一个整型常量后加一个字母l或L，认为是long int 型，如12L。
2.实型常量
实型常量即实数，又称为浮点数。C语言中，实数只能用十进制数表示，实数的表示方法有两种：小数形式和指数形式。
（1）小数形式：由整数部分、小数点和小数点部分组成，当整数部分或小数部分为0时可以省略不写，但是小数点不可以省略。如12.345，3.，-.123等均为正确的实数。
（2）指数形式：由尾数部分，字母E或e和指数部分组成，格式为：±尾数E指数。
如1.23E-2、3.14E+3等，它们表示的数值分别为0.0123、3140.00.
注意：
（1）以小数形式表示实数时，必须有小数点，并且小数点的前、后至一边要有数字。
（2）以指数形式表示实数时，字母E或e的前后必须有数字，并且指数指数部分只能是整数。如12.-E3、1.5E、E6都是不正确的实数。
在C语言中，实型常量默认为是double型的实数，如果在数的后面加字母f或F（如 1.65f、654.87F），则认为是float型的实数。
3.字符型常量
字符常量指单个字符，用一对双引号及其括号所括起的字符表示。如’a’、‘B’、‘=’、‘&amp;’、‘？’等都是合法的字符常量。在C语言中，字符常量有以下特点：
（1）字符常量只能用括号括起来，不能用双引号或其它括号。
（2）字符常量只能是单个字符，不能是字符串。
（3）字符可以是ASCII字符集中的任意字符。按ASCII码的大小，不同的字符之间存在着次序，以字符的ASCII码值按升序连续排列。如小写字母的ASCII码大于大写字母的ASCII码，大写字母的ASCII码大于数字的ASCII码。
使用字符常量时，每个字符在内存中占用一个字节，用于存储他的ASCII码值。所以C语言中的字符常量具有数值特征，可以像整数一样参与运算，此时相当于对字符的ASCII码值进行运算。
如4和‘4’是不同的，‘4’+1的值是53，因为‘4’的ASCII码值是52，字符‘a’的ASCII码是97，则’a’+1=98，对应于字符‘b’。这是因为字母’a’~‘z’的ASCII码按升序连续排列，字符‘a’的ASCII码值加1，就是字符’b’的ASCII码值。
另外，对于控制符（如回车，换行等）与不可见字符，在C语言中通过转义字符来表示。转义字符是用’\‘开头后面加上一个字符或用八进制、十六进制表示的ASII码值组成。‘'的作用是改变其后面的字符或ASCII码值的原有意义，转义为另外的的含义。
常见的转义字符如表：
转义字符|转义功能 |ASCII码值
\0 |空字符 |0
\a | 响铃 |7
\b |退格 |8
\t |水平制表符|9
\n |回车换行 |10
\v |竖向跳格 |11
\f |换页 |12
\r |回车 |13
\" |双引号 |34
\’ |单引号 |39 \? |问号 |63
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f17c8a0960e09988e867ea6fb0d58fae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f49f8060bb8fc7aed635056d530a6ac9/" rel="bookmark">
			JS面试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		七、Js基础 JavaScript相关 JavaScript分三个部分:
ECMAScript标准—基本语法DOM—&gt;Document Object Model 文档对象模型,操作页面元素的BOM—&gt;Browser Object Model 浏览器对象模型,操作浏览器的
浏览器中有个顶级对象:window----皇上
页面中顶级对象:document-----总管太监
页面中所有的内容都是属于浏览器的,页面中的内容也都是window的，因为页面中的所有内容都是window的,window是可以省略的.
变量是window的 一、数据类型 基本数据类型（值类型）： Number、String、Boolean、Undefined、Null、Symbol（es6新增独一无二的值） 和 BigInt（es10新增）；
引用数据类型: Object。包含Object、Array、 function、Date、RegExp。
备注： 基本数据类型，又称值类型。
1.基本数据类型和引用数据类型的区别： 基础数据类型，都有固定的大小,往往都保存在栈内存中（闭包除外），由系统自动分配存储空间。我们可以直接操作保存在栈内存空间的值，因此基础数据类型都是按值访问 。
引用数据类型，引用数据类型的值是保存在堆内存中的对象。JS不允许直接访问堆内存中的位置，因此我们不能直接操作对象的堆内存空间。因此，引用类型的值都是按引用访问的。
2.Typeof运算符： typeof 能有效检测基本类型，检测引用类型都返回object,其中null属于特殊的引用类型返回object,function属于特殊引用类型不用于存储数据，typeof检测返回function.
3.和= ===三等表示全等，判断左右两边对象或值是否类型相同且值相等。
二等表示值相等。判断操作符两边对象或值是否相等类型可以不同，类型不同时，使用Number()转换成Number类型在进行判断。例外规则，nullundefined，null/undefined进行运算时不进行隐式类型转换。通常把值转为Boolean值，进行条件判断。Boolean(null)=Boolean(undefined)&gt;false=false 结果为true
4.if语句和逻辑运算 所有基本类型中Boolean值是false的只有6个，分别是 : 0 NaN ’ ’ null undefined false
引用类型Boolean值全是true.
if条件是单个值时，如果是truly值，条件成立， 如果是falsely值，条件不成立
三、类型判断 数据类型判断大概有四种typeof、instanceof、constructor、Object.prototype.toString.call()
二、null和undefined区别 在 if 语句中 null 和 undefined 都会转为false两者用相等运算符比较也是相等
1.null表示没有对象，可能将来要赋值一个对象，即该处不应该有值
1） 作为函数的参数，表示该函数的参数不是对象
2） 作为对象原型链的终点
undefined表示缺少值，即此处应该有值，但没有定义
1）定义了形参，没有传实参，显示undefined
2）对象属性名不存在时，显示undefined
3）函数没有写返回值，即没有写return，拿到的是undefined
4）写了return，但没有赋值，拿到的是undefined
1.Typeof: 不用知道函数返回什么类型，可以使用typeof()定义一个用于接收该函数返回值的变量
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f49f8060bb8fc7aed635056d530a6ac9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b0c788f58e6a9cae664da0f97b6f308/" rel="bookmark">
			HTML&amp;CSS相关面试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是盒模型 1.在我们HTML页面中
每一个元素都可以被看作一个盒子，而这个盒子由：内容区（content）、填充区（padding）、边框区（border）、外边界区（margin）四部分组成。
2.盒子模型有标准盒子模型和怪异盒子模型
标准模式下: 一个盒子的总宽度(页面中占的宽度)= width + margin(左右) + padding(左右) + border(左右)
怪异模式下: 一个盒子的总宽度= width + margin(左右)（即width已经包含了padding和border值）（IE浏览器）
标准和怪异模型的转换
box-sizing:content-box; 将采用标准模式的盒子模型标准
box-sizing:border-box; 将采用怪异模式的盒子模型标准
box-sizing:inherit; 规定应从父元素继承 box-sizing 属性的值。
二、清除浮动 1.为什么要清除浮动？ 清除浮动主要是为了解决高度塌陷 ，父元素的高度默认是被子元素撑开的，父元素因为子级元素浮动引起的内部高度为0的问题
1.比如,我给父盒子设置一个boder,内部放两个盒子一个big、一个small，未给big和small设置浮动，则他们会默认撑开父盒子
2.如果给这两个盒子都加上了float属性的时候，底部的盒子就会顶上来，因为父盒子没设置高度，变成一条线，big和small已经浮动了
小结：当父元素不给高度的时候，内部元素不浮动的时候会撑开，而浮动时父元素会变成一条线，所以这个时候就需要解决浮动
2.清除浮动的四种方式
1.额外标签法（给最后一个浮动的标签后，新加一个标签，给其设置clear:both;,）（但这种方式是不推荐使用的，因为添加无意义的标签，语义化差）
2.父元素添加overfiow属性（触发BFC的方式，实现清除浮动）
3.使用after伪元素清除浮动
&amp;:after { content: ""; display: table; clear: both; } 优点：符合闭合浮动思想，结构语义化正确,不容易出现其他为题
缺点：IE6-7不支持伪元素：after，使用zoom:1触发
使用before和after双伪元素清除浮动 cler
除了这四种还有一种更为简单的方式，给父元素定义好height高度，就解决了父级元素无法获取到高度的问题。
三、BFC BFC就是“块级格式化环境”的意思，简单来说，BFC 就是一种属性，这种属性会影响着元素的定位以及与其兄弟元素之间的相互作用。
BFC是一块用来独立的布局环境，保护其中内部元素不受外部影响，也不影响外部。
1.BFC触发的几种方式： 1.浮动元素，float 除 none 以外的值；
2.绝对定位元素，position（absolute，fixed）；
3.display 为以下其中之一的值 inline-block，table-cell，table-caption；
4.overflow 除了 visible 以外的值（hidden，auto）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b0c788f58e6a9cae664da0f97b6f308/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b64e71d882fea25bdcf3bf0ac857df87/" rel="bookmark">
			Webpack常见面试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Webpack打包原理 webpack五大模块 Entry入口：以哪个文件为入口起点开始打包，分析构建内部依赖图
Output输出：指示Webpack打包后的资源bundles输出位置和命名
Loader加载器：让Webpack可以处理非js文件，比如样式文件，图片文件
Plugins插件：增强Webpack，打包优化，Gzip压缩，重新定义环境中的变量等
Mode模式：本地环境development 生产环境production
Webpack介绍 webpack只是一个打包模块的机制，只是把依赖的模块转化成可以代表这些包的静态文件。
webpack就是识别你的 入口文件。识别你的 模块依赖，来打包你的代码。至于你的代码使用的是commonjs还是amd或者es6的import。webpack都会对其进行分析。来获取代码的依赖。
webpack做的就是分析代码。转换代码，编译代码，输出代码。webpack本身是一个node的模块，所以webpack.config.js是以commonjs形式书写的(node中的模块化是commonjs规范的)
2.解析点vue文件过程 vue-loader 会把.vue文件中的内容拆分为 template，script，style 三个“虚拟模块”，
然后分别匹配 webpack 配置中对应的 rules，比如 script 模块会匹配所有跟处理 JavaScript 或 TypeScript 相关的 loader。
Webpack打包构建流程
初始化参数
配置文件和Shell语句中读取与合并参数开始编译
根据参数初始化Compiler对象，加载配置插件，执行对象的run方法开始执行编译确定入口
根据配置中的entry找出所有的入口文件编译模块
调用所有配置的Loader对模块进行编译，再找到该模块的依赖的模块，在递归本步骤直到所有入口依赖的文件都本步骤处理完成模块编译
得到每个模块被翻译后的最终内容以及它们之间的依赖关系输出资源输出完成 2.模块热更新 模块热更新是webpack的一个功能，他可以使代码修改过后不用刷新就可以更新，是高级版的自动刷新浏览器
devServer中通过hot属性可以控制模块的热替换
3.如何提高webpack构建速度 1、通过externals配置来提取常用库
2、利用DllPlugin和DllReferencePlugin预编译资源模块 通过DllPlugin来对那些我们引用但是绝对不会修改的npm包来进行预编译，再通过DllReferencePlugin将预编译的模块加载进来
3、使用Happypack 实现多线程加速编译
要注意的第一点是，它对file-loader和url-loader支持不好，所以这两个loader就不需要换成happypack了，其他loader可以类似地换一下
4、使用Tree-shaking和Scope Hoisting来剔除多余代码 5、使用fast-sass-loader代替sass-loader 6、babel-loader开启缓存
5.babel-loader在执行的时候，可能会产生一些运行期间重复的公共文件，造成代码体积大冗余，同时也会减慢编译效率 可以加上cacheDirectory参数或使用 transform-runtime 插件试试
6.不需要打包编译的插件库换成全局"script"标签CDN引入的方式
8、优化构建时的搜索路径
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/638aa76befa201147e0fbb9bb453d384/" rel="bookmark">
			汉诺塔问题以及青蛙跳台阶问题（附C语言代码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		汉诺塔问题： 汉诺塔问题的源于印度一个古老传说的益智玩具。大焚天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照先大后小的顺序摞着64片圆盘。大焚天命令婆罗门把圆盘从下面按大小顺序重新摆放在另一根柱子上，并且规定在小盘子上不能放大盘子，在三根柱子之间一次只能移动一个盘子。
要把A柱上的盘子全部都移动到B柱上，并且要遵循以下规则：
1、一次只能移动原著最上面的一个盘子
2、小盘子上面不能放大盘子。
将一个圆盘从一根柱子移动到另一根柱子上，算是移动一次，那么将n个盘子全部从A柱移动到B柱至少移动多少次呢？
代码实现：
//汉诺塔问题 int x= 0; void Move(char from, char dest)//移动一个盘子，将盘子从from柱移动到dest柱 { printf("将盘子从%c柱移动到%c柱\n", from, dest); } void Han(int n, char x, char y, char z) { if (n == 1) { Move(x, z);//如果只有一个盘子的话，就将盘子从A柱移动到C柱 } else { Han(n - 1, x, z, y);//如果有多个(假设是n个)盘子的话，就先将n-1个盘子借助C柱从A柱移动到B柱 Move(x, z);//将A柱剩下的一个盘子移动到C柱 Han(n - 1, y, x, z);//再将B柱上的n-1个盘子借助A柱移动到C柱 } } int main() { int num = 0; printf("请输入一个数："); scanf("%d", &amp;num);//几层汉诺塔 char A = 'A'; char B = 'B'; char C = 'C'; Han(num, A, B, C); //将num个盘子借助B柱从A柱移动到C柱 return 0; } 其中具体代码的实现功能我都加了详细的注释。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/638aa76befa201147e0fbb9bb453d384/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09b1678ae889ffae7ec2af0bb3c1be7f/" rel="bookmark">
			全志T7 Display驱动简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		可先阅读《Sunxi_display2模块使用文档.pdf》、《图形开发用户指南.pdf》
DE：Display Engine
Write-Back：capture data between display engine and TCON for Miracast application.
下图参考《Allwinner_DE2.0_Spec_V1.0.pdf》：
在全志linux代码drivers\video\sunxi目录下有disp和disp2，在A20、A33、A80采用的是disp的框架，而2013年后A83T、V5、T7采用DISP2的框架，即DE2.0版本。
概述 配置信息：
这样就配置了CONFIG_DISP2_SUNXI=y
全志平台显示驱动架构如下：
注：可参考《全志平台LCD调试说明文档V1.0_图文_百度文库》
即有两个驱动，一个Framebuffer，另一个是Display，在代码t7linux-auto\linux-3.10\drivers\video\sunxi\disp2\disp中。这里主要分析Display驱动。
源码结构介绍 video:.
│fbmem.c framebuffer core
├─sunxi
│ ├─disp2/ disp2的目录
│ │ ├─disp
│ │ │ ├─dev_disp.c display driver层
│ │ │ ├─dev_fb.c framebuffer driver层
│ │ │ ├─disp_sys_intf.c
│ │ │ ├─dev_disp_debugfs.c
│ │ │ ├─dev_composer.c
│ │ │ ├─dev_composer2.c
│ │ │ ├─de bsp层
│ │ │ │ ├─disp_manager.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/09b1678ae889ffae7ec2af0bb3c1be7f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d60a48f4f0f01f99bc619e0aae56ea59/" rel="bookmark">
			大数据可视化-Tableau
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习目标： 使用Tableau绘制数据可视化图表
学习内容： 1.连接本地数据选择”已保存数据源“下的”世界发展指标“
2.制作全国各区域内2012年的城市人口总数图表
3.制作全球各区域的城市人口与出生率图表
4.制作中国在2010-2012年的人均医疗费用图表
学习产出： 1.制作全国各区域内2012年的城市人口总数图表
2.制作全球各区域的城市人口与出生率图表
3.制作中国在2010-2012年的人均医疗费用图表
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a28eb6aa5231b16a60f4e6fda5ebb0fa/" rel="bookmark">
			通俗解释hash碰撞是什么以及如何解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Hash如何存数据
hash表的本质其实就是数组，hash表中通常存放的是键值对Entry。
如下图:
这里的学号是个key，哈希表就是根据key值来通过哈希函数计算得到一个值，这个值就是下标值，用来确定这个Entry要存放在哈希表中哪个位置。
Hash碰撞
hash碰撞指的是，两个不同的值（比如张三、李四的学号）经过hash计算后，得到的hash值相同，后来的李四要放到原来的张三的位置，但是数组的位置已经被张三占了，导致冲突。
解决方法
hash碰撞的解决方式是开放寻址法和拉链法。
开放寻址法指的是，当前数组位置1被占用了，就放到下一个位置2上去，如果2也被占用了，就继续往下找，直到找到空位置。
拉链法采用的是链表的方式，这个时候位置1就不单单存放的是Entry了，此时的Entry还要额外保存一个next指针，指向数组外的另一个位置，将李四安排在这里，张三那个Entry中的next指针就指向李四的这个位置，也就是保存的这个位置的内存地址。如果还有冲突，就把又冲突的那个Entry放到一个新位置上，然后李四的Entry指向它，这样就形成一个链表。
总结起来：开放寻址法和拉链法都是想办法找到下一个空位置来存发生冲突的值。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8918fbe1dbc8a1cadc5736ccc9cbff16/" rel="bookmark">
			Obsidian使用手册
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 obsidian 官网：https://obsidian.mdobsidian 官方中文帮助文档：https://publish.obsidian.md/help-zh/由此开始obsidian 官方使用手册：https://publish.obsidian.md/help-zh/使用指南/格式化你的笔记 Obsidian 精髓——反向链接 使用两个中括号[[]]，可以链接到本地文件，也可以输入先【#】可以链接到标题，也可以先输入【^】链接文本块，也可以先输入【|】指定的文本
反向链接到文件示例：[Obsidian反向链接文件](Obsidian反向链接文件.md)
备注，支持以下文件的嵌入：
Markdown 文件：md;图像文件：png, jpg, jpeg, gif, bmp, svg; 其中外引图片不会直接显示图片；音频文件：mp3, webm, wav, m4a, ogg, 3gp, flac;视频文件：mp4, webm, ogv;PDF 文件：pdf. 标题 # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 备注：最高支持六级标题 引用 引用的使用方式：&gt;
代码块 行内代码使用方式：``
代码块使用方式：```+ 编程语言
表格的使用 |表头1|表头2|表头3| |-|-|-| |单元格1|单元格2|单元格3| 备注：必须要存在第二行的|-|-|-|
如需复制示例，请将隐藏起来的 br 标签去掉 序列列表 1. 有序列表使用语法：数值 + . + 空格 2. 无序列表使用语法：+ 或者 - 或者 * + 空格
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8918fbe1dbc8a1cadc5736ccc9cbff16/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2606640bfc085944168c9bc0b18bc4b0/" rel="bookmark">
			【算法】剑指 Offer 专项突击版 Day1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 【算法】剑指 Offer 专项突击版 Day1 题目地址：https://leetcode-cn.com/study-plan/lcof/?progress=wgzvtig
目标：要点总结，分享思路
文章目录 【算法】剑指 Offer 专项突击版 Day1【中等】014. 字符串中的变位词 【中等】014. 字符串中的变位词 难度：
要点：
思路： 代码如下：
class Solution: def checkInclusion(self, s1: str, s2: str) -&gt; bool: l1,l2 = len(s1),len(s2) if l1&gt;l2:return False cnt1,cnt2 = [0 for _ in range(26)],[0 for _ in range(26)] for i in range(l1): cnt1[ord(s1[i])-ord('a')]+=1 cnt2[ord(s2[i])-ord('a')]+=1 if cnt1==cnt2:return True """ 举例s1=abc s2 =bbdacba l1 = 3, l2 = 7 在上面我们统计s1的字母量时，已经比对过s2的前3个字母了即bbd，此时窗口不满足 因此滑动窗口，右指针指向3，代表s2中的a（注意角标从0开始） 此时我们仅需要将窗口右指针的a加入统计，同时删除窗口左指针的b，即此时窗口为bda不满足 以此类推寻找 """ for right in range(l1,l2): cnt2[ord(s2[right])-ord('a')]+=1 left = right-l1 cnt2[ord(s2[left])-ord('a')]-=1 if cnt2==cnt1:return True return False 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b897b5ffae8207e3a7b46c71d487af6/" rel="bookmark">
			js比较俩个对象是否相等
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、使用JSON.stringify()或。适用于俩个对象属性顺序相同
let bankInfo = { accountType : 2, nationality:'CHN',	//国籍 bankName : '',	//银行名称 bankCode : '',	//银行code } let oldBankInfo = { accountType : 2, nationality:'CHN',	//国籍 bankName : '',	//银行名称 bankCode : '',	//银行code } let flag2 = JSON.stringify(bankInfo) == JSON.stringify(oldBankInfo) console.log(flag2) // true 二、使用Object.keys()或者Object.entries().toString()
Object.keys()是将对象中键先取出来组成数组，然后先比较键。而后通过键在比较值
Object.entries()是将键和值分别组成俩个数组。然后使用toString将键值数组转化为字符串去比较
checkInfo() { // object.keys let bankInfo = Object.keys(this.params.bankInfo), oldBankInfo = Object.keys(this.params.oldBankInfo) if (oldBankInfo.length !== bankInfo.length) return false for (let i = 0; i &lt;= bankInfo.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b897b5ffae8207e3a7b46c71d487af6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5d82cd1bb7f53647266f2719ebc38c3/" rel="bookmark">
			vue-element-upload 文件上传打开选择文件弹框前进行提示或操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目场景： 数据中台
问题描述 导入文件之前先下载
解决方案： 1.组件中：
2.方法中：
3.样式中：因为多了个按钮，所以将它隐藏不占位
效果：
解决参考：https://www.cnblogs.com/liangpi/p/13086110.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/576d9342d699b10b8760114a8336b606/" rel="bookmark">
			关于微信小程序流量主拉取视频显示暂无广告
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 出现这种情况分2中情况 1.代码问题 2.因为小程序广告组件在审核中，因此在开发版本中就会出现暂无广告、线上版本啥也会没有，等到审核通过了，就可以显示视频广告了 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d9e39098e4be3c5b554981c4e3724cd/" rel="bookmark">
			python的三种图像读取处理存储方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python中常用的图像读取处理存储方法有三种，分别基于pillow、matplotlib和opencv库。本文分别使用这三种对同一张图片进行读取、灰度化、像素修改、显示、存储操作。
目录
1 Pillow
2 Matplotlib
3 OpenCV 1 Pillow 按照Pillow官方文档的介绍，Pillow是一个图像处理库。同学们可以把官方文档的网址收藏下来，上面提供了各个函数的详细介绍。
from PIL import Image import numpy as np im = Image.open("Mikasa.png") gray = im.convert('L') im_array = np.array(im) for i in range(im_array.shape[0]): for j in range(im_array.shape[1]): im_array[i, j, 0] = 0 im2 = Image.fromarray(im_array) im2.save("Mikasa-r.png") im.show() gray.show() im2.show() 首先通过open()函数读取图像，使用的图像如下。
之后通过convert()函数将图像灰度化，convert()函数支持的参数如下图，该图截自官方文档对convert()函数的介绍。
得到的灰度图像如下。
Pillow读取的图像无法直接对像素操作，需要先转换位numpy的array。上述代码将图像的R通道置为零，再通过fromarray()函数重新转换为图片。再通过save()函数存储为图像文件，最后使用show()函数显示图片。PIL使用系统的图片浏览器显示图片，显示效果如下图。
2 Matplotlib 按照Matplotlib官网的介绍，matplotlib是一个2D绘图库，与图像处理库的侧重点有所不同。
import matplotlib.pyplot as plt im = plt.imread("Mikasa.png") plt.figure(1) plt.imshow(im) for i in range(im.shape[0]): for j in range(im.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d9e39098e4be3c5b554981c4e3724cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3512f660854b8f4410ab3a4133f635ed/" rel="bookmark">
			关于在VScode中多行代码注释的快捷键操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		多行代码注释及取消注释的方法： 1.选中要注释的代码块：Alt+shift+A；取消注释：Alt+shift+A
2-1.选中要注释的代码块：(1）Ctrl+K（2）Ctrl+C；取消注释：（1）Ctrl+K（2）Ctrl+U
2-2.选中要注释的代码块：Ctrl+/；取消注释：Ctrl+/
1.Alt+shift+A注释，用（1）Ctrl+K（2）Ctrl+U取消注释可以吗？我们试试
答案是不可以
那Alt+shift+A注释，用（1）Ctrl +/取消注释可以吗？我们试试
答案是不可以
而且再次Ctrl+/只是消解掉新一层的注释，变回原来一样
2.（1）Ctrl+K（2）Ctrl+C注释，用Alt+shift+A取消注释可以吗？我们试试
答案是不可以
那（1）Ctrl+K（2）Ctrl+C注释，用（1）Ctrl +/取消注释可以吗？我们试试
看到这里我们就知道了
/可以等同于K+C或者K+U
总结 在编写代码时最好统一注释的方式，以达到操作的省时和方便。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0fbc8522cdb958dd9f736c8b9c58da69/" rel="bookmark">
			Python之面向对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		面向对象基础 目标 理解面向对象类和对象添加和获取对象属性魔法方法 一. 理解面向对象 面向对象是一种抽象化的编程思想，很多编程语言中都有的一种思想。
例如：洗衣服
思考：几种途径可以完成洗衣服？
答： 手洗 和 机洗。
手洗：找盆 - 放水 - 加洗衣粉 - 浸泡 - 搓洗 - 拧干水 - 倒水 - 漂洗N次 - 拧干 - 晾晒。
机洗：打开洗衣机 - 放衣服 - 加洗衣粉 - 按下开始按钮 - 晾晒。
思考：对比两种洗衣服途径，同学们发现了什么？
答：机洗更简单
思考：机洗，只需要找到一台洗衣机，加入简单操作就可以完成洗衣服的工作，而不需要关心洗衣机内部发生了什么事情。
总结：面向对象就是将编程当成是一个事物，对外界来说，事物是直接使用的，不用去管他内部的情况。而编程就是设置事物能够做什么事。
二. 类和对象 思考：洗衣机洗衣服描述过程中，洗衣机其实就是一个事物，即对象，洗衣机对象哪来的呢？
答：洗衣机是由工厂工人制作出来。
思考：工厂工人怎么制作出的洗衣机？
答：工人根据设计师设计的功能图纸制作洗衣机。
总结：图纸 → 洗衣机 → 洗衣服。
在面向对象编程过程中，有两个重要组成部分：类 和 对象。
类和对象的关系：用类去创建一个对象。
2.1 理解类和对象 2.1.1 类 类是对一系列具有相同特征和行为的事物的统称，是一个抽象的概念，不是真实存在的事物。
特征即是属性行为即是方法 类比如是制造洗衣机时要用到的图纸，也就是说类是用来创建对象。
2.1.2 对象 对象是类创建出来的真实存在的事物，例如：洗衣机。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0fbc8522cdb958dd9f736c8b9c58da69/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/250c907d3f0262f3009c800571d4128b/" rel="bookmark">
			UE4针对特殊的透明物体不应用后期效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这是之前的做法 https://blog.csdn.net/maxiaosheng521/article/details/121854323
比较简单粗暴，效果是所有的透明材质都不应用后期，这次是通过custom stencil 设置为111 过滤掉指定透明材质的后期渲染流程
代码和思路说明 https://github.com/HeartlessLD/UE4CustomtranslucencyNoPost-
实现对指定透明材质物体不应用后期效果 （在SceneCapture中捕捉的对象也不受效果）
说明 受限于目前对引擎的了解 这种修改方式绝对不是最优的方法
使用说明：
使用ue4.26源码版引擎 大概率4.27也可以 4.25应该是不行
引擎文件拷贝对应的文件进行覆盖
ComposeSeparateTranslucency.usf NoPostProcessCustomStencil.usf放到UnrealEngine\Engine\Shaders\Private中
ConsoleVariables.ini 调试shader 使用 如果不需要调试查看shader可以不用
NoPostProcessCustomStencil.h .cpp 放到UnrealEngine\Engine\Source\Runtime\Renderer\Private
项目设置
Custom Depth-Stencil Pass EnableWithStencil
Separate Translucency enable
将想要设置不受影响的物体 属性 RenderCustomDepthPass enable
customDepth Stencil Value 111 (这里设置111 是针对后期材质中 只针对111 进行处理 非111的透明材质 保持原样)
透明材质要开启 Allow Custom Depth Write
这里面说一下大概思路（可能有错误 仅供参考）
文件中所有///&gt;nopost的地方都是修改的内容，具体的逻辑可以自己看
首先自定义一条Pass 放在后期的最后进行渲染，
这里参考 https://zhuanlan.zhihu.com/p/407093510
///&gt;nopost
PassSequence.SetEnabled(EPass::NoPostProcess, true);
在Post之前对透明物体进行渲染处理时，在合成透明的shader中过滤掉111的透明，
ComposeSeparateTranslucency.usf
uint CustomStencil = CustomStencilTexture.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/250c907d3f0262f3009c800571d4128b/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/269/">«</a>
	<span class="pagination__item pagination__item--current">270/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/271/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>