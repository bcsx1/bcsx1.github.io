<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/075c651c040195b51fc1434f1b401fc0/" rel="bookmark">
			孩子还是有一颗网安梦——Bandit通关教程：Level 18 → Level 19
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🕵️‍♂️ 专栏《解密游戏-Bandit》
🌐 游戏官网： Bandit游戏
🎮 游戏简介： Bandit游戏专为网络安全初学者设计，通过一系列级别挑战玩家，从Level0开始，逐步学习基础命令行和安全概念。玩家需通过阅读信息、使用命令和解决问题来完成每个级别。在不清楚时建议查阅手册、使用内建命令或搜索引擎，旨在培养初学者的基本技能。
📖 博客说明： 本系列博客记录个人通关教程，一起探索网络安全的奇妙世界吧！ 🚀
零、Level 18 → Level 19 游戏直通车-&gt;🚗 🚕 🚙
一、关卡解读 密码存在于home目录下的readme里,但是由于.bashrc文件被修改,所以当SSH登录时会被弹出.
二、通关教程 尝试用密码直接SSH连接:
会直接被断开SSH连接.
SSH连接的时候可以执行命令,输入如下命令:
ssh -p 2220 bandit18@bandit.labs.overthewire.org "ls; cat readme"
即可得到密码: awhqfNnAbc1naukrpqDYcF95h7HoMTrC
ssh -p 2220 bandit18@bandit.labs.overthewire.org "ls; cat readme"命令解释如下:
ssh: 远程登录协议，用于通过加密的方式连接到远程主机。 -p 2220: 指定SSH连接的端口号，这里是2220。 bandit18@bandit.labs.overthewire.org: 连接的用户名为bandit18，连接的目标主机是bandit.labs.overthewire.org。 "ls; cat readme": 在远程主机上执行的命令，以分号分隔。首先执行ls命令，然后执行cat readme命令。 Voila!，恭喜通关🎉🥳~
三、学习资料 推荐一个不错的Linux命令学习网站：Linux Tutorial
👨‍💻 关于我：我是zh4men9，一个曾经有过网安梦的孩子。如果你对我的学习经验和网络安全故事感兴趣，欢迎访问我的CSDN博客：CSDN博客。
📚 更多分享： 你还可以在我的知乎博客上找到我更多的观点和经验分享：知乎博客。
💻 GitHub链接： 如果你对我的项目和代码感兴趣，可以在我的GitHub上找到更多：GitHub链接。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba7070309d3d72df3b06eb8e05eef559/" rel="bookmark">
			数模论文研读方法推荐
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		论文写作学习，一定要优秀论文才行，如下是优秀论文推荐：
国赛看每年的高教社杯和matlab创新奖，如果有时间看看相应题目官网给出的优秀论文；美赛看o奖论文。
研读需学习的方向： 1 学习整体框架。根据3-5篇论文整理出一套可以在比赛时直接用的写作模版
2 学习写作格式。方法同上
3 学习语言表达。整理优秀的论文中的措辞，以及用什么什么方法，有什么好的表述方法没有。建议最后将一些好的表达放在一个整理的文档中，方便变比赛时使用
4 学习算法及模型。这里尤其要强调，并不是需要学习优秀论文涉及的所有算法，一般只需要学习用了现在常用的算法（比如元胞自动机等）流程、实现及表述即可，将其按照算法进行分类整理。很多论文有部分仅适用于那个问题，自创的模型，这种费时费力，收效甚微，不建议学习
5 学习摘要的表述
6 学习可视化用的工具及如何去展示
研读方法推荐：（建议队伍一起学习，一个题目用时4-6天） step1 根据题目，写出自己对问题的分析，然后查阅资料，改进自己的问题分析【半天】
step2 和队友讨论，形成自己队伍对于问题的解决方案（不需要具体做，写出问题分析即可）【半天】
step3 阅读优秀论文（上文提到了怎样才算优秀论文），注意此时不要看优秀论文的摘要，从问题分析开始看起。然后根据前文提到的方向分别进行整理【两天】
step4 优秀论文的思路与自己的思路进行对比【半天】
step5 根据优秀论文后面的内容，给此优秀论文写摘要。写完后对比论文的摘要，总结自己表述的优缺点【半天】
step6 可选任务 再挑两篇优秀论文进行学习，从step3到step5，此时取长补短，浓缩精华即可【2天】
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3bfdfb212571750122fd4f4094ebd58e/" rel="bookmark">
			第七节TypeScript 循环
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、简述
有的时候，我们可能需要多次执行同一块代码。一般情况下，语句是按顺序执行的：函数中的第一个语句先执行，接着是第二个语句，依此类推。
循环语句允许我们多次执行一个语句或语句组。
循环语句流程图：
2、for循环
for循环用于多次执行一个语句序列，简化管理循环变量的代码。
语法：
for (init; condition; increment) { // 循环执行代码块 } 参数说明：
init会首先执行，且只会执行一次，这一步允许您声明并初始化任何循环控制变量。之后，会判断condition。如果是true，则执行循环主体。如果是false，则不执行循环主体。且控制流会跳转到紧接着for循环下一条语句。在执行完for循环主体后，控制流会跳回上面的increment语句。该语句允许您更新循环控制变量。该语句可以留空，只要在条件后有一个分号出现即可。条件再次被判断，如果为true，则执行循环，这个过程是不断重复的。一直到条件变为false时，for循环终止。 实例（ts代码）：
var num:number = 5; var i:number; var factorial = 1; for(i = num;i&gt;=1;i--) { factorial *= i; } console.log(factorial) 使用tsc命令编译后的js代码：
var num = 5; var i; var factorial = 1; for (i = num; i &gt;= 1; i--) { factorial *= i; } console.log(factorial); 执行结果：120
3、for...in循环
For...in语句用于一组值的集合或者列表进行迭代输出。
语法：
for (var val in list) { // 语句 } val需要为string或any类型
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3bfdfb212571750122fd4f4094ebd58e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93e7bee859da260a0067da0ea08263da/" rel="bookmark">
			污水处理厂可视化：让环保与科技共舞
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着科技的飞速发展，我们的生活环境变得越来越美好。然而，随着城市化进程的加快，污水处理问题也日益凸显。如何有效、高效地处理污水，成为了一个亟待解决的问题。而“污水处理厂可视化”技术的出现，为这个问题提供了一个全新的解决方案。
一、什么是污水处理厂可视化？ 污水处理厂可视化，是指通过先进的计算机技术，将污水处理厂的运行情况实时展示在计算机屏幕上，以便于管理人员更加直观地了解污水处理厂的运行状况。这种技术不仅可以提高污水处理效率，还可以降低能耗和运营成本，为环保事业贡献一份力量。
如下图：
这是使用山海鲸可视化搭建的污水处理厂3D模型，通过数字孪生技术，基于真实污水处理厂场景建模，最大程度还原了真实场景，能够为污水处理厂相关的数字孪生项目提供有力支持，实现了更加直观、精细化的污水处理管理，大幅提高了污水处理管理水平。
二、污水处理厂可视化的优势 提高管理效率：通过实时展示污水处理厂的运行数据，管理人员可以更加直观地了解污水处理厂的运行状况，从而更加快速地做出决策，提高管理效率。
降低能耗和运营成本：通过实时监测污水处理厂的运行数据，可以及时发现并解决潜在的问题，从而降低能耗和运营成本。
提高环保意识：通过展示污水处理厂的运行数据，可以让更多的人了解污水处理的重要性，从而提高环保意识。
如下图：
这是使用山海鲸可视化搭建的污水处理流程3D示意模型，是基于真实污水处理流程建模，最大程度还原了真实污水处理流程实景，能够为污水处理相关数字孪生项目提供有力支持，实现了更加直观、精细化的污水处理管理，大幅提高了污水处理管理水平。
三、如何实现污水处理厂可视化？ 实现污水处理厂可视化需要借助先进的计算机技术。具体来说，可以通过以下步骤实现：
采集数据：通过安装各种传感器和仪表，实时采集污水处理厂的运行数据。
数据传输：将采集到的数据传输到计算机服务器中，以便于进行实时展示和分析。
数据分析：通过专业的软件对采集到的数据进行实时分析，以发现潜在的问题并预测未来的趋势。
数据展示：将分析结果以图表、报表等形式展示在计算机屏幕上，以便于管理人员更加直观地了解污水处理厂的运行状况。
做可视化可以使用山海鲸可视化，内置3D场景编辑器，自研的Web端3D引擎甚至可以媲美游戏效果，且制作三维大屏的全过程都是免费的。
四、未来的展望 随着科技的不断发展，污水处理厂可视化的应用前景将更加广阔。未来，我们可以期待更多的创新技术应用于污水处理领域，为环保事业贡献更多的力量。同时，我们也应该加强环保意识的宣传和教育，让更多的人了解和关注污水处理问题，共同为我们的环境做出贡献。
五、总结 污水处理厂可视化不仅可以提高污水处理效率，降低能耗和运营成本，还可以提高环保意识。让我们一起期待这个技术在未来能够为环保事业带来更多的惊喜和改变吧！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6be35d5523ce381db60973d199b1bd25/" rel="bookmark">
			【【迭代16次的CORDIC算法-verilog实现】】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		迭代16次的CORDIC算法-verilog实现 -32位迭代16次verilog代码实现 CORDIC.v module cordic32#( parameter DATA_WIDTH = 8'd32 , // we set data width parameter PIPELINE = 5'd16 // Optimize waveform )( input clk , input rst_n , input signed [DATA_WIDTH - 1 : 0] phase , input ena , output reg signed [DATA_WIDTH - 1 : 0] sin_out , output reg signed [DATA_WIDTH - 1 : 0] cos_out ); // ----------------------------------------------- \\ // next is define and parameter \\ // ------------------------------------------------- \\ reg signed [DATA_WIDTH - 1 : 0] phase_reg ; reg signed [DATA_WIDTH - 1 : 0] phase_reg1 ; reg signed [DATA_WIDTH - 1 : 0] X0 ; reg signed [DATA_WIDTH - 1 : 0] Y0 ; reg signed [DATA_WIDTH - 1 : 0] Z0 ; wire signed [DATA_WIDTH - 1 : 0] X1 , Y1 , Z1 ; wire signed [DATA_WIDTH - 1 : 0] X2 , Y2 , Z2 ; wire signed [DATA_WIDTH - 1 : 0] X3 , Y3 , Z3 ; wire signed [DATA_WIDTH - 1 : 0] X4 , Y4 , Z4 ; wire signed [DATA_WIDTH - 1 : 0] X5 , Y5 , Z5 ; wire signed [DATA_WIDTH - 1 : 0] X6 , Y6 , Z6 ; wire signed [DATA_WIDTH - 1 : 0] X7 , Y7 , Z7 ; wire signed [DATA_WIDTH - 1 : 0] X8 , Y8 , Z8 ; wire signed [DATA_WIDTH - 1 : 0] X9 , Y9 , Z9 ; wire signed [DATA_WIDTH - 1 : 0] X10 , Y10 , Z10 ; wire signed [DATA_WIDTH - 1 : 0] X11 , Y11 , Z11 ; wire signed [DATA_WIDTH - 1 : 0] X12 , Y12 , Z12 ; wire signed [DATA_WIDTH - 1 : 0] X13 , Y13 , Z13 ; wire signed [DATA_WIDTH - 1 : 0] X14 , Y14 , Z14 ; wire signed [DATA_WIDTH - 1 : 0] X15 , Y15 , Z15 ; wire signed [DATA_WIDTH - 1 : 0] X16 , Y16 , Z16 ; reg signed [DATA_WIDTH - 1 : 0] XN15 , YN15 ; reg [1:0] quadrant[PIPELINE : 0] ; integer i ; // We will convert all new angles to the first quadrant // always@(posedge clk or negedge rst_n) begin if( rst_n == 0 ) begin phase_reg &lt;= 0 ; phase_reg1 &lt;= 0 ; end else if( ena == 1) begin phase_reg1 &lt;= phase ; case(phase[DATA_WIDTH - 1 : DATA_WIDTH - 2]) 2'b00 : phase_reg &lt;= phase ; 2'b01 : phase_reg &lt;= phase - 32'h40000000 ; // -90 2'b10 : phase_reg &lt;= phase - 32'h80000000 ; // -180 2'b11 : phase_reg &lt;= phase - 32'hC0000000 ; // -270 default : phase_reg &lt;= 32'h00 ; endcase end end // We begin the initialization operation // we set 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6be35d5523ce381db60973d199b1bd25/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/138fd3796bea615661d2d5d27e344676/" rel="bookmark">
			使用PE信息查看工具和Beyond Compare文件比较工具排查dll文件版本不对的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、问题说明
2、修改了代码，但安装版本还是有问题
3、使用PE信息查看工具查看音视频库文件（二进制）的时间戳
4、使用Beyond Compare比较两个库文件的差异
5、找到原因
6、最后
C++软件异常排查从入门到精通系列教程（专栏文章列表，欢迎订阅，持续更新...）https://blog.csdn.net/chenlycly/article/details/125529931C/C++基础与进阶（专栏文章，持续更新中...）https://blog.csdn.net/chenlycly/category_11931267.htmlVC++常用功能开发汇总（专栏文章列表，欢迎订阅，持续更新...）https://blog.csdn.net/chenlycly/article/details/124272585C++软件分析工具从入门到精通案例集锦（专栏文章，持续更新中...）https://blog.csdn.net/chenlycly/article/details/131405795开源组件及数据库技术（专栏文章，持续更新中...）https://blog.csdn.net/chenlycly/category_12458859.html网络编程与网络问题分享（专栏文章，持续更新中...）https://blog.csdn.net/chenlycly/category_2276111.html 最近在项目中使用了PE信息查看工具和Beyond Compare文件比较工具排查了一个dll库文件版本不对的问题，正好借此案例，给大家介绍一下这两个小工具的使用。
1、问题说明 某天测试人员在一台Win7电脑上测试客户端软件时，发现软件在SIP协议下入会后看不到视频，于是找到音视频模块的同事来排查。通过查看打印得知，是在使用D3D绘制视频图像时绘图接口返回失败，所以视频图像没有绘制上去。于是修改了一下代码，在D3D绘图失败时，自动切换到其他模式。
2、修改了代码，但安装版本还是有问题 维护音视频模块的小伙，修改了一下代码，本地临时编译了一个Release版本的dll库，发给测试同事，让其验证一下还有没有问题。如果没问题，就走发布流程，提交代码然后编译代码，然后将生成的.lib和.dll发布到产品代码流上来。
测试同事用临时库验证了一下，入会后可以看视频了，所以修改的代码是有效的。音视频模块的同事提交代码，并发起编译让编译机编译版本，编译完成后将库发布过来。然后我们这边再编译代码，重新打程序的安装包，然后让测试同事安装新的安装包程序。测试同事安装新的安装包后，发现入会后还是看不到视频，还是有问题。
在这里，给大家重点推荐一下我的几个热门畅销专栏：
专栏1：（该专栏订阅量接近350个，有很强的实战参考价值，广受好评！专栏文章持续更新中，预计更新到200篇以上！）
C++软件调试与异常排查从入门到精通系列文章汇总https://blog.csdn.net/chenlycly/article/details/125529931
本专栏根据近几年C++软件异常排查的项目实践，系统地总结了引发C++软件异常的常见原因以及排查C++软件异常的常用思路与方法，详细讲述了C++软件的调试方法与手段，以图文并茂的方式给出具体的实战问题分析实例，带领大家逐步掌握C++软件调试与异常排查的相关技术，适合基础进阶和想做技术提升的相关C++开发人员！
专栏中的文章均是通过项目实战总结出来的（通过项目实战积累了大量的异常排查素材和案例），有很强的实战参考价值！专栏文章还在持续更新中，预计文章篇数能更新到200篇以上！
专栏2： C/C++基础与进阶（专栏文章，持续更新中...）https://blog.csdn.net/chenlycly/category_11931267.html
以多年的开发实战为基础，总结并讲解一些的C/C++基础与进阶内容，以图文并茂的方式对相关知识点进行详细地展开与阐述！专栏涉及了C/C++领域的多个方面的内容，同时给出C/C++及网络方面的常见笔试面试题，并详细讲述Visual Studio常用调试手段与技巧！
专栏3： 开源组件及数据库技术https://blog.csdn.net/chenlycly/category_12458859.html
以多年的开发实战为基础，分享一些开源组件及数据库技术！ 3、使用PE信息查看工具查看音视频库文件（二进制）的时间戳 难道发布的库的版本有问题？于是先用PE工具打开mediasdk.dll二进制文件，查看二进制文件的时间戳（编译生成时间），如下所示：
文件的修改时间为：2023/12/08 13:26:52，确实就是这个时间点编译的，所以从二进制文件的编译生成时间上看是没问题的。
注意，不能把电脑中文件的修改时间当成二进制文件的生成时间，文件修改时间仅仅表示在本机器上操作的时间，应该使用专用的PE信息查看工具去查看文件生成时的时间戳。
这个地方说一下PE查看工具PeViewer和MiTeC EXE Explorer：
我这边之前使用的PE信息查看工具叫PeViewer，以前排查问题时，用该工具打开64位二进制文件发生了闪退。后来在网上搜到了MiTeC EXE Explorer工具，这个工具兼容性比较好，打开64位二进制文件没有问题。
4、使用Beyond Compare比较两个库文件的差异 既然时间对的上，为啥之前验证时没问题，使用新版本的安装包安装后的软件还有问题呢？于是让测试同事使用Beyond Compare软件比较一下音视频开发同事给的mediasdk.dll和新版本安装目录中的mediasdk.dll文件，看看二者有没有区别。
对于Beyond Compare，默认是Text Compare模式，需要切换到Hex Compare二进制比较模式。具体切换入口为：
在菜单栏中点击Session，然后在弹出的菜单中点击Compare in New View Using，然后在弹出的子菜单中点击Hex Compare，这样就切换到二进制内容比较模式了，如下所示：
比较了一下两个mediasdk.dll文件，确实有很多不同的地方：
但最近两天没修改该模块的代码，两个应该不会有差异的，所以还是mediasdk.dll库的版本不对。
5、找到原因 目前处理这个问题的音视频开发同事是刚毕业没多久的新人，可能相关代码环境还是不熟悉，是不是只修改了每日流，没有修改封闭流？我们当前产品就要发布了，使用的是音视频模块的封闭流版本，很有可能是没修改封闭流导致的。于是亲自到这个新同事的机器上看了一下，确实是只修改了每日流，没修改封闭流的代码。修改一下，重新发布就可以了。
6、最后 本文通过项目中遇到的库文件版本问题，介绍了PE信息查看工具PeViewer和MiTeC EXE Explorer，以及文件比较工具Beyond Compare。这些小工具虽然比较小，但在日常工作中还是挺有用的，所以在这里给大家分享一下。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0472eb45a8019bd8796f9ec3b6472029/" rel="bookmark">
			备忘: 通过java反射机制实现自动执行配置文件注册类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		把操作类注册在配置文件中，主程序通过java反射机制执行相应的操作类(Class),实现各类任务，便于在程序框架基本不动的前台下，按任务需要编写或修改相关服务，以满足敏捷化开发的需求。
项目目录结构
config.ConfigParser 解析配置文件，并实现反射机制
controll.MyTaskProcess 主程序
controll.TaskManage.java 定时框架 datasource.DatasourceService Interface
datasource.GraphQLServiceImp graphql数据接口类
targetdb.targetdbService Interface
target.EsServiceImp ES库的操作类
task.taskService Interface
task.TracingAutoOrder 定时任务类
关键依赖， json解析用的jackson， &lt;!-- jackson库解析json文件 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.9.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;2.9.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.6&lt;/version&gt; &lt;/dependency&gt; graphql处理用的是graphql-client
&lt;dependency&gt; &lt;groupId&gt;org.mountcloud&lt;/groupId&gt; &lt;artifactId&gt;graphql-client&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; elasticsearch7.9
&lt;!-- elasticsearch7.9.2 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.elasticsearch&lt;/groupId&gt; &lt;artifactId&gt;elasticsearch&lt;/artifactId&gt; &lt;version&gt;7.9.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt; &lt;artifactId&gt;elasticsearch-rest-high-level-client&lt;/artifactId&gt; &lt;version&gt;7.9.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- elasticsearch 依赖 2.x 的 log4j --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-api&lt;/artifactId&gt; &lt;version&gt;2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0472eb45a8019bd8796f9ec3b6472029/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3339302cbaf74f9c1d93ad9f57bd581/" rel="bookmark">
			【计算理论】05 可判定性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 概述DFA可判定性 A D F A A_{DFA} ADFA​是可判定的 A N F A , A R E X A_{NFA}, A_{REX} ANFA​,AREX​是可判定的 E D F A E_{DFA} EDFA​是可判定的 E Q D F A EQ_{DFA} EQDFA​是可判定的 CFG可判定性 A C F G A_{CFG} ACFG​可判定 E C F G E_{CFG} ECFG​可判定 E Q C F G EQ_{CFG} EQCFG​不可判定 语言关系不可识别语言存在性证明单射满射，双射可数所有串构成的集合 Σ ∗ \Sigma^* Σ∗可数所有图灵机构成的集合可数所有语言集合不可数结论 不可识别存在性的另一种思路 A T M A_{TM} ATM​不可判定补图灵可识别与可判定的关系 A T M A_{TM} ATM​可识别结论 参考 概述 称一个语言是可识别的，当且仅当存在一台识别该语言的图灵机。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b3339302cbaf74f9c1d93ad9f57bd581/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0fa3115e1bc386e14d36b8ff3d61ece7/" rel="bookmark">
			Spring Boot &#43; EasyUI 全屏布局（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、创建一个Spring Boot + EasyUI项目 Spring Boot + EasyUI 创建第一个项目（一）_springboot整合easyui-CSDN博客
二、相关知识点总结 布局（layout）是有五个区域（北区 north、南区 south、东区 east、西区 west 和中区 center）的容器。中间的区域面板是必需的，边缘区域面板是可选的。每个边缘区域面板可通过拖拽边框调整尺寸，也可以通过点击折叠触发器来折叠面板。布局（layout）可以嵌套，因此用户可建立复杂的布局。
布局(Layout)属性：
名称类型描述默认值fitboolean当设置为 true 时，就设置布局（layout）的尺寸适应它的父容器。当在 'body' 标签上创建布局（layout）时，它将自动最大化到整个页面的全部尺寸。falsetitlestring布局面板（layout panel）的标题文本。nullborderboolean当设置为 true 时，就显示布局面板（layout panel）的边框。truesplitboolean当设置为 true 时，就显示拆分栏，用户可以用它改变面板（panel）的尺寸。false 数据网格（DataGrid）属性：
三、项目举例 1 项目框架 2 代码实现 SpringBootMainApplication.java:
package com.xj.main; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.context.annotation.ComponentScan; /** * @Author: xjfu * @Create: 2023/10/20 7:33 * @Description: SpringBoot启动类 */ @ComponentScan("com.xj") @SpringBootApplication public class SpringBootMainApplication { public static void main(String[] args) { try{ SpringApplication.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0fa3115e1bc386e14d36b8ff3d61ece7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb69c67bece0f0f547a035f07c347825/" rel="bookmark">
			记录grid布局实现从左至右均匀布局，自动换行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 均匀布局,去掉右侧空白
grid-template-columns: repeat(auto-fit, minmax(200px, 1fr))
tailwindcss写法： grid gap-10px grid-cols-[repeat(auto-fit,minmax(200px,1fr))] display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); grid-gap: 10px 20px; grid-auto-rows: 50px; 固定列宽度，改变列数量
grid-template-columns: repeat(auto-fit, 200px) grid-template-columns: repeat(auto-fit, 200px); grid-gap: 10px 20px; grid-auto-rows: 50px; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/314745be1abb5548b6bb3361f8e811f0/" rel="bookmark">
			20231221将NanoPC-T4(RK3399)开发板适配Android12的挖掘机并打开AP6398SV
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		20231221将NanoPC-T4(RK3399)开发板适配Android12的挖掘机并打开AP6398SV
2023/12/21 17:46
SDK使用：rk356x_android12_220722.tgz
android12-rk3588-new_20221229_1732toybrick.tgz【TB3588X】
1、【必须更换AP6398SV征集的驱动程序！】
Z:\3TB\91rk_android12_220722\kernel-4.19\arch\arm64\configs\rockchip_defconfig
CONFIG_WL_ROCKCHIP=y
CONFIG_WIFI_BUILD_MODULE=y
CONFIG_AP6XXX=m
修改为：
CONFIG_WL_ROCKCHIP=y
CONFIG_WIFI_BUILD_MODULE=y
#CONFIG_AP6XXX=m
CONFIG_AP6XXX_WIFI6=m
2、【不用修改，确认一下】
Z:\3TB\91rk_android12_220722\kernel-4.19\drivers\net\wireless\rockchip_wlan\rkwifi\bcmdhd_wifi6\Makefile
# SPDX-License-Identifier: GPL-2.0
# bcmdhd
#MODULE_NAME := bcmdhd_wifi6
MODULE_NAME := bcmdhd
CONFIG_BCMDHD_SDIO := y
#CONFIG_BCMDHD_PCIE := y
#CONFIG_BCMDHD_USB := y
3、
N:\nanopc_t4\12\ToyBrick\82Image-rk3399_Android12\81android12-rk3588-new\device\rockchip\rk3399\rk3399_Android12\BoardConfig.mk
include device/rockchip/rk3399/BoardConfig.mk
BOARD_SENSOR_ST := true
BOARD_SENSOR_COMPASS_AK8963-64 := true
BOARD_SENSOR_MPU_PAD := false
BOARD_COMPASS_SENSOR_SUPPORT := true
BOARD_GYROSCOPE_SENSOR_SUPPORT := true
CAMERA_SUPPORT_AUTOFOCUS:= false
BOARD_CAMERA_SUPPORT := true
BOARD_CAMERA_SUPPORT_EXT := true
#PRODUCT_KERNEL_DTS := rk3399-evb-ind-lpddr4-android-avb
#PRODUCT_KERNEL_DTS := rk3399-firefly-aio
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/314745be1abb5548b6bb3361f8e811f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/766e24732698f2034b332e06777d1590/" rel="bookmark">
			孩子还是有一颗网安梦——Bandit通关教程：Level 17 → Level 18
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🕵️‍♂️ 专栏《解密游戏-Bandit》
🌐 游戏官网： Bandit游戏
🎮 游戏简介： Bandit游戏专为网络安全初学者设计，通过一系列级别挑战玩家，从Level0开始，逐步学习基础命令行和安全概念。玩家需通过阅读信息、使用命令和解决问题来完成每个级别。在不清楚时建议查阅手册、使用内建命令或搜索引擎，旨在培养初学者的基本技能。
📖 博客说明： 本系列博客记录个人通关教程，一起探索网络安全的奇妙世界吧！ 🚀
零、Level 17 → Level 18 游戏直通车-&gt;🚗 🚕 🚙
一、关卡解读 密码在passwords.old和passwords.new两个文件中被改变的内容.
二、通关教程 直接利用diff命令求解diff passwords.new passwords.old:
p6ggwdNHncnmCNxuAt0KtKVq185ZU7AW 或者 hga5tuuCLF6fFzUpnagiMN8ssu9LFrdg
经过尝试,hga5tuuCLF6fFzUpnagiMN8ssu9LFrdg 为正确密码.
但是在登录18关的时候,终端会一闪而过.
根据题目提示,这是18-19关的内容,所以直接开始解密下一关~
Voila!，恭喜通关🎉🥳~
三、学习资料 推荐一个不错的Linux命令学习网站：Linux Tutorial
👨‍💻 关于我：我是zh4men9，一个曾经有过网安梦的孩子。如果你对我的学习经验和网络安全故事感兴趣，欢迎访问我的CSDN博客：CSDN博客。
📚 更多分享： 你还可以在我的知乎博客上找到我更多的观点和经验分享：知乎博客。
💻 GitHub链接： 如果你对我的项目和代码感兴趣，可以在我的GitHub上找到更多：GitHub链接。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22422208c51f700b50b8783657b66388/" rel="bookmark">
			孩子还是有一颗网安梦——Bandit通关教程：Level 16 → Level 17
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🕵️‍♂️ 专栏《解密游戏-Bandit》
🌐 游戏官网： Bandit游戏
🎮 游戏简介： Bandit游戏专为网络安全初学者设计，通过一系列级别挑战玩家，从Level0开始，逐步学习基础命令行和安全概念。玩家需通过阅读信息、使用命令和解决问题来完成每个级别。在不清楚时建议查阅手册、使用内建命令或搜索引擎，旨在培养初学者的基本技能。
📖 博客说明： 本系列博客记录个人通关教程，一起探索网络安全的奇妙世界吧！ 🚀
零、Level 16 → Level 17 游戏直通车-&gt;🚗 🚕 🚙
一、关卡解读 和上一关类似,向localhost的指定port发送本关的密码即可获得下一关的密码.但,有一点不同: port在一个范围内: 31000 - 32000.
为了找到唯一的port,需要做三件事:
找31000 - 32000范围内,被监听的端口找到使用SSL的端口找到能给出答案的端口 二、通关教程 首先,利用nmap命令,对范围31000 - 32000内的端口进行扫描:
nmap localhost -p 31000-32000
发现共5个端口是被监听的.
由于端口数不多,可以手动尝试,openssl s_client localhost:XXX
最终,在端口31790下,找到了正确答案.
-----BEGIN RSA PRIVATE KEY----- MIIEogIBAAKCAQEAvmOkuifmMg6HL2YPIOjon6iWfbp7c3jx34YkYWqUH57SUdyJ imZzeyGC0gtZPGujUSxiJSWI/oTqexh+cAMTSMlOJf7+BrJObArnxd9Y7YT2bRPQ Ja6Lzb558YW3FZl87ORiO+rW4LCDCNd2lUvLE/GL2GWyuKN0K5iCd5TbtJzEkQTu DSt2mcNn4rhAL+JFr56o4T6z8WWAW18BR6yGrMq7Q/kALHYW3OekePQAzL0VUYbW JGTi65CxbCnzc/w4+mqQyvmzpWtMAzJTzAzQxNbkR2MBGySxDLrjg0LWN6sK7wNX x0YVztz/zbIkPjfkU1jHS+9EbVNj+D1XFOJuaQIDAQABAoIBABagpxpM1aoLWfvD KHcj10nqcoBc4oE11aFYQwik7xfW+24pRNuDE6SFthOar69jp5RlLwD1NhPx3iBl J9nOM8OJ0VToum43UOS8YxF8WwhXriYGnc1sskbwpXOUDc9uX4+UESzH22P29ovd d8WErY0gPxun8pbJLmxkAtWNhpMvfe0050vk9TL5wqbu9AlbssgTcCXkMQnPw9nC YNN6DDP2lbcBrvgT9YCNL6C+ZKufD52yOQ9qOkwFTEQpjtF4uNtJom+asvlpmS8A vLY9r60wYSvmZhNqBUrj7lyCtXMIu1kkd4w7F77k+DjHoAXyxcUp1DGL51sOmama +TOWWgECgYEA8JtPxP0GRJ+IQkX262jM3dEIkza8ky5moIwUqYdsx0NxHgRRhORT 8c8hAuRBb2G82so8vUHk/fur85OEfc9TncnCY2crpoqsghifKLxrLgtT+qDpfZnx SatLdt8GfQ85yA7hnWWJ2MxF3NaeSDm75Lsm+tBbAiyc9P2jGRNtMSkCgYEAypHd HCctNi/FwjulhttFx/rHYKhLidZDFYeiE/v45bN4yFm8x7R/b0iE7KaszX+Exdvt SghaTdcG0Knyw1bpJVyusavPzpaJMjdJ6tcFhVAbAjm7enCIvGCSx+X3l5SiWg0A R57hJglezIiVjv3aGwHwvlZvtszK6zV6oXFAu0ECgYAbjo46T4hyP5tJi93V5HDi Ttiek7xRVxUl+iU7rWkGAXFpMLFteQEsRr7PJ/lemmEY5eTDAFMLy9FL2m9oQWCg R8VdwSk8r9FGLS+9aKcV5PI/WEKlwgXinB3OhYimtiG2Cg5JCqIZFHxD6MjEGOiu L8ktHMPvodBwNsSBULpG0QKBgBAplTfC1HOnWiMGOU3KPwYWt0O6CdTkmJOmL8Ni blh9elyZ9FsGxsgtRBXRsqXuz7wtsQAgLHxbdLq/ZJQ7YfzOKU4ZxEnabvXnvWkU YOdjHdSOoKvDQNWu6ucyLRAWFuISeXw9a/9p7ftpxm0TSgyvmfLF2MIAEwyzRqaM 77pBAoGAMmjmIJdjp+Ez8duyn3ieo36yrttF5NSsJLAbxFpdlc1gvtGCWW+9Cq0b dxviW8+TFVEBl1O4f7HVm6EpTscdDxU+bCXWkfjuRb7Dy9GOtt9JPsX8MBTakzh3 vBgsyi/sN3RqRBcGU40fOoZyfAMT8s1m/uYv52O6IgeuZ/ujbjY= -----END RSA PRIVATE KEY----- 返回的答案是通往下一关的ssh private key.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/22422208c51f700b50b8783657b66388/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/177da298cc20c1077c91daeff11f475c/" rel="bookmark">
			数据结构 | 手写堆
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天我们来实现一个简单好用的数据结构，堆。
要实现一个手写堆，需要实现它的三个功能，我们需要能初始化一个堆，能取出堆顶元素和将一个元素插入堆。
在开始实现之前，我们先回顾一下堆的初始化、插入和删除过程。
堆的定义
① 堆中的每个结点最多有两个子节点。
② 结点的排列顺序垂直从上到下，水平从左到右。
③ 子节点key必须大于父母结点。
堆的数据结构
根据堆的定义，堆是一棵完全二叉树，既然是一棵完全二叉树，就可以采用数组的方式实现，并且，如果从1开始对结点编号，那么，编号为i的结点的父亲结点为i/2。
堆的初始化
堆的初始化过程从倒数第二排开始，遍历检查从n/2结点到1结点的合法性，如图所示，我们计划实现一个小根堆，那么它的初始化过程可以表示为（图像第四步 6和4 不合法，制图失误，抱歉）：
每一次不合法时的调整过程是将该节点与左右孩子中更小的一个互换。
堆的插入
堆的插入过程也是类似的，与初始化过程的差异就是，只需要针对可能受影响的结点做合法性调整即可。
堆的删除
我们要取出堆顶元素，就会打破树的完全二叉树性质，因此，我们得把最后一个元素放到堆顶，然后从堆顶开始向下调整。
堆排序
堆排序则是将堆元素插入或初始化后，不断取出，从而获得一个有序结果的排序方法。如上图删除过程，实际上是将第一个结点与第七个结点互换，并使得堆大小减一，这样，当堆大小为0时，原来存放堆的数组就是一个有序数组。
实现手写堆的关键
通过分析上述过程，实际上要实现一个手写堆，只需要实现两个函数，一个函数自下而上(up)的检查某个点合法性，用于插入操作，一个函数自上而下(down)的检查某个点合法性，用于删除操作。实现了这两个函数后，就可以轻松地实现插入和删除操作。
#include &lt;iostream&gt; using namespace std; #define MAX_NR 100005 int heap[MAX_NR]; // 存放堆的数组 int heap_size; // 堆大小 // 从上到下调整堆 void down_heap(int idx){ int t = idx; //t存储三个结点中存在的最小的结点的下标，初始化为当前结点idx if (idx * 2 &lt;= heap_size &amp;&amp; heap[idx * 2] &lt; heap[t]) t = idx * 2; // 左子节点存在并且小于当前结点，更新t的下标 if (idx * 2 + 1 &lt;= heap_size &amp;&amp; heap[idx * 2 + 1] &lt; heap[t]) t = idx * 2 + 1; //右子节点存在并且小于当前结点，更新t的下标 if (t !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/177da298cc20c1077c91daeff11f475c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/212cc5f1c600cff3eec446bbe9e90f99/" rel="bookmark">
			快速创建1个G的文件 -----window平台
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 window平台下 cmd 中,到跳转到指定目录下
1G: 1073741824 个字节: 1 * (102410241024)2G: 2147483648*3G: 32212254724G: 42949672964.5G: 48318382085G: 5368709120 生成1G的文件,名称为big1g.txt
fsutil file createNew big1g.txt 1073741824 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/337f06786c791fd0f78974e8d37a2595/" rel="bookmark">
			大模型之二十-中英双语开源大语言模型选型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从ChatGPT火爆出圈到现在纷纷开源的大语言模型，众多出入门的学习者以及跃跃欲试的公司不得不面临的是开源大语言模型的选型问题。
基于开源商业许可的开源大语言模型可以极大的节省成本和加速业务迭代。
当前（2023年11月17日)开源的大语言模型如下：
模型所属公司发布时间开放模型许可词表大小语料Huggingface下载量模型结构位置编码激活函数隐变量维度dimension自注意力头的个数n heads层数n layers输入序列长度sequence length训练时长LLaMA-2Meta2023年8月7B 13B 70B允许商用，月活超7亿需向Meta申请许可320002.0T70B-chat下载量1.69M，变种还有若干Casual decoderRoPESwiGLUPre RMS Norm7B 4096, 13B 5120, 70B 81927B 32, 13B 40, 70B 647B 32, 13B 40, 70B 804096A100 7B 184320, 13B 368640, 70B 1720320baichuan-2百川智能2023年9月6日7B 13B base/chat代码Apache 2.0，模型非商用1256962.6T1-7B 95.5k，2-13B 40.8k, 2-7B 20.5kPrefix decoderRoPEGeGLUPost Deep Norm7B 4096, 13B 51207B 32, 13B 407B 32, 13B 404096ChatGLM3智普2023年10月6B填问卷登记后允许免费商业使用650241.5T左右中英8kCasual decoderRoPESwiGLUPost Deep Norm409632288192千问阿里2023年8月7B 14B允许商用，超过1亿用户机构需申请1519367B 2.4T，14B 3.0T25kCasual decoderRoPESwiGLUPre Layer Norm409632328192BloomBigScience2022年7月560M 1.1B 1.7B 3B 7.1B允许商用250880366B125MCasual decoderALiBiGeLUPre Layer Norm409632302048 LLaMA-2的词表是32k，在中英文上的平均token数最多，对中英文分词比较碎，比较细粒度。尤其在中文上平均token数高达1.45，这意味着大概率会将中文字符切分为2个以上的token。ChatGLM3-6B是平衡中英文分词效果最好的tokenizer。由于词表比较大，中文处理时间也有增加。BLOOM虽然是词表最大的，但由于是多语种的，在中英文上分词效率与ChatGLM-6B基本相当。 还有很多其他的开源中英大语言模型，但基本都有Llama的影子，有些是直接扩充Lllama的词汇再用新的数据集重新训练，这些大语言模型包括Chinese-LLaMA-Alpaca-2、OpenChineseLLaMA、Panda、Robin (罗宾)、Fengshenbang-LM等，这里就不一一列出了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/337f06786c791fd0f78974e8d37a2595/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/649455b5ff8d786eca2e2bfff9ad53a0/" rel="bookmark">
			解决Maven找不到依赖的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 如果经过Reload Maven项目，清除Idea缓存，甚至重启Idea等方法都解决不了Dependency xxx not found的问题，不妨试试手动安装。
1. 进入maven仓库，搜索自己需要的对应版本的依赖。
2. 点击下图红框jar图标下载对应的jar包，记住下载好的jar包的位置，比如放在了D盘的Downloads目录下。
3. 在下方找到自己的maven依赖。比如我的是：
&lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt&lt;/artifactId&gt; &lt;version&gt;0.9.0&lt;/version&gt; &lt;/dependency&gt; 4. 进入刚刚下载好的jar包的所在目录，比如D盘的Downloads目录，点击下图所示位置变蓝后输入cmd，进入cmd命令行。
5. 命令行输入以下指令回车等待BUILD SUCCESS
mvn install:install-file -Dfile=jjwt-0.9.0.jar -DgroupId=io.jsonwebtoken -DartifactId=jjwt -Dversion=0.9.0 -Dpackaging=jar 6. 命令解释
-Dfile：下载好的 jar 包的名字-DgroupId：maven 仓库上对应的 groupId-DartifactId：maven 仓库上对应的 artifactId-Dversion：maven 仓库上对应的 version 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ec4b3a616822a80b2b36b2b99884f8f/" rel="bookmark">
			java的字符串的详细介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.字符串的介绍
字符串是由双引号括号起来的多个字符例如：" hello" 、" 花朵"、"A"都是字符串
java是使用Unicode编码，Unicode编码包含中文等多个字符， 所以在java中使用由中文构成的字符串合法。
很多计算机语言提供了两种字符串，不可变字符串和可变字符串，它们之间的区别在于当字符串进行拼接等修改操作时，不可变字符串会创新新的字符串对象，而可变字符串不会创新对象
java SE提供了三个字符串类：String、StringBuffer、StringBuilder。String是不可变字符串。
StringBuffer和StringBuilder是可变字符串
注意：字符串有一个极端情况，就是 "" 表示的是空字符串，双引号中没有内容，空字符串不是NULL，空字符串是分配内存空间，而NULL是没有分配内存空间的。
2.不可变字符串
java中不可变字符串类是String，属于java.lang包，它也是java非常重要的类
创建String对象通过String对象构造方法实现，常用的构造方法如下：
String()：使用空字符串创建并初始化一个新的String对象
String(String original)：使用另外一个字符串创建并初始化一个新的String对象
注意：java.lang包中提供了很多java基础类，包括Object、Class、String和Math等基本类。在使用java.lang包中的类时不需要引入(import)该包，因为它是由解释器自动引入的。当然，引入java.lang包程序也不会有编译错误
String(StringBuffer buffer)：使用可变字符串对象(StringBuffer)创建并初始化一个新的String对象
String(StringBuilder Builder)：使用可变字符串对象(StringBuilder)创建并初始化一个新的String对象
String(byte[] bytes)：使用平台的默认字符解码指定的byte数组，通过byte数组创建并初始化一个新的String对象
String(char[] value)：通过字符数组创建并初始化一个新的String对象
String(char[] value,int offset,int count)：通过字符数组的子数组创建并初始化一个新的String对象；office参数是子数组第一个字符的索引，count参数指定子数组的长度
创建字符串对象例题如下：
String s1 = new String(); String s2 = new String("hello"); String s3 = new String("\u0048\u0065\u006c\u006c\u006f"); System.out.println("s2=" + s2); System.out.println("s3=" + s3); char ch[] = {'a', 'b', 'c'}; String s4 = new String(ch); String s5 = new String(ch, 1, 4); System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ec4b3a616822a80b2b36b2b99884f8f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb68c329eb16afdae701dde556c8b0bc/" rel="bookmark">
			在使用正运动控制器时，常见问题解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、电机不转动 1.轴类型ATYPE配置是否正确；
2.确认是否有硬件限位、软件限位、报警信号起作用，轴状态是否正常；
3.电机是否使能成功；
4.确认脉冲当量UNITS、速度的值是否合适，如果有编码器反馈查看MPOS是否变换；
5.确认脉冲模式和驱动器的脉冲模式是否匹配；
6.控制器端或驱动器端是否产生报警；
7.检查接线是否正确；
确认控制器是否正常发送脉冲。
二、限位信号不起作用 1.限位传感器工作是否正常，“输入口”视图是否可以监控到限位传感器的信号变化；
2.限位开关的映射是否正确；
限位传感器和控制器的公共端是否相连。
三、输入口检测不到信号 1.限位传感器工作是否正常，“输入口”视图是否可以监控到限位传感器的信号变化；
2.限位开关的映射是否正确；
3.限位传感器和控制器的公共端是否相连。
四、输出口操作无响应 1.检查是否需要IO电源；
检查输出口编号是否与操作的一致。
五、POWER灯亮，RUN灯不亮 1.检查供电电源功率是否充足，此时最好给控制器单独供电，调整好后重启控制器；
ALM灯是否有规律的闪烁（硬件问题）。
六、RUN灯亮，ALM灯也亮 程序运行错误，请查验ZDevelop错误代码，检查应用程序。
七、控制器与PC串口连接失败 1.串口参数是否被运行程序修改，可以通过?*SETCOM查看当前的所有串口配置；
2.查看PC的串口参数与控制器是否匹配；
3.打开设备管理器，查看PC的串口驱动是否正常。
八、CAN扩展模块连接不上 1.检查CAN接线和供电回路，120欧姆电阻是否有安装在两端；
2.检查主从端配置，通讯速度配置等；
3.检查拨码开关，是否有多个扩展模块采用同样的ID；
4.干扰严重的场合使用双绞线、屏蔽层接地，使用双电源供电（扩展模块主电源和IO电源分开供电）。
九、控制器与PC网口连接失败 1.检查PC的IP地址，需要与控制器IP在同一网段；
2.检查控制器IP地址，可以用串口连接后查看、获取；
3.网口灯不亮时检查接线是否正常；
4.控制器的电源灯POWER和运行指示灯RUN是否正常亮起；
5.网线是否有问题，更换质量好的网线再尝试连接；
6.检查控制器IP是否和其他设备冲突；
7.检查控制器的网口通道ETH是否全部被其他设备占用，将其他设备断开之后在尝试连接；
8.多网卡的情况下建议禁用其他网卡，或者更换电脑再连接；
9.检查PC防火墙设置；
10.Ping一下控制器IP，看是否能Ping通控制器，若无法Ping通，检查物理接口，或者网线；
11.arp -a查询IP地址和MAC地址。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9e1ac7f93a048d03479bc8bdfdfe901/" rel="bookmark">
			大模型落地，从知识管理“助理”开始？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文 | 智能相对论
作者 | 叶远风
在李彦宏喊出要押注“AI原生应用”后，落地已经成为千模竞争下的行业共识。
但具体如何落地、做原生应用，行业内仍然八仙过海各显神通。
落地共识的推动者百度，最近又以一个动作，昭示了大模型场景落地最可能的“先行领域”——针对“泛内容管理”的“助手”类应用。
近期，百度智能云发布基于文心一言的伴随式Copilot——“超级助理”，这是国内首个面向办公场景，结合大模型的开放式浏览器插件。
直观上，这个插件的用途，在于让浏览器产品变得更加“聪明”，能够给用户提供更多的基于智能化能力的自动化辅助价值，比如文章翻译、文案创作、网页总结、知识问答等。
而在其背后，实际上是大模型的本质以及这种本质如何影响到大模型落地。充分抓住了这个本质的厂商，将更值得用户/客户选择。
大模型的本质，决定了“泛知识管理”式场景将最先落地
大模型是走向AGI通用人工智能的重要契机，即以“认知智能”的方式与过去AI深度耕耘的“感知智能”形成互补，让机器既有“大脑”也有“躯干四肢”。
在这个过程中，大模型最本质的意义之一，是在数据成为新型生产资料的情况下，实现了对“数据要素”的充分挖掘，从而获得认知与自主判断能力，可以自动化完成很多工作——就如同人因为不断吸收外界信息、转化成自身认知而有充分的自主性一样。
于是，最接近“数据要素”的领域，将最先体现大模型的“挖掘”价值。
“泛知识管理”首当其冲。
在企业内部，对日积月累的数据信息，对外部市场的各种信息报告进行总结、提炼，辅助业务能力提升，是典型的“知识管理”工作。但很多时候，例如一个在浏览器上寻找各种信息并需要达成某些目的的用户，也是在做着“知识管理”的事。
对广泛信息内容处理要求最为直接和集中的场景，都是“泛知识管理”的囊括范围。
这种场景落地，往往都是辅助性质、赋能性质的，因此常常以“助理”、“助手”等应用形式出现，但其本质更像是请了一个“副手”或者“副驾驶”，有自己的责任模块，不需要人为干涉就能自动化完成很多知识管理的配合工作（Copilot的含义来源就在于此）。
可以看到，百度智能云发布的“超级助理”一方面针对网页上繁杂的信息为生活和工作带来了困扰这个现实，为用户提供智能和高效的浏览器体验；另一方面，实际上这种对内容与信息的挖掘能力本身就契合企业知识管理类工作，可以集成到各类企业业务系统中，因此“超级助理”支持通过插件方式调起、串联多个业务系统，打造企业一站式超级入口，“让每个企业系统都轻松拥有自己的Copilot”。
目前，“超级助理”已经开放公测，用户可进入“百度智能云超级助理”官网下载插件进行安装，也可直接在Chrome、Edge、360浏览器的应用商店搜索“超级助理”安装。
下一步，“超级助理”走入企业将是大概率事件，浏览器插件更像是一个预演。
大模型“助理”价值呈现，遵循知识管理四步骤
用知识管理典型的四项工作来看待所有此类“助理”的价值呈现，关键点就变得十分清晰——从不同价值维度用智能化能力推动自动化工作。
1、前置的知识“入库”过程
海量的内容和信息要等着成为“数据要素”，首先要完成一个整理“入库”的过程。
加工、打标、编目……大模型能力将这一系列工作自动化，大大节约了人力、提升了效率。
“超级助理”提供给用户的有一个特别的能力：当一个求职者面对海量信息和繁琐的求职流程迷茫无助时，可以成为用户的“贴心小助手”，挖掘各种求职信息保驾护航。
例如，当用户想要了解面试公司情况时，“超级助理”能够像侦探一样帮助用户精装找到目标公司、总结相关情况，提供公司的背景、文化、业务等关键信息，让用户做好相关准备。
这背后，实际上就是“超级助理”在无形中已经对所有相关的信息完成了某种打标签的“入库”过程，为用户做好了“全网编目”，等待一个特定目标的匹配。
2、知识提取与挖掘过程
海量的内容和信息，在入库后，需要进行大量的人、项目、合同、事件、名词等的关系、事件知识的提取，将杂乱的内容变成有价值的知识点，去匹配、支撑业务的需求。
在“超级助理”这里，表现为帮助用户将某些内容或信息关联的知识联动起来，提升尤其是日常工作中使用浏览器的体验。
例如，当一个关注运营的用户划选网页中与运营活动相关的黑话（官方演示“从内核到外延”），“超级助理”将基于其知识提取与挖掘，提供通俗的解释：
当“超级助理”已经完成了知识提取与挖掘的工作，用户将可以更快速地获取知识、适应工作，这对很多新员工将十分友好。
3、知识运营过程
知识主题的定义、挖掘、聚合与关联是一件十分考验个人理解的事，而且需要大量的内容与信息浏览、吸收过程。
大模型的介入，让这一过程自动化解决。
如果用户需要精读一份冗长而专业的行业报告，原本需要数小时，现在在“超级助理”的支持下，几秒钟就能一键提取、总结出报告的核心、关键信息，快速吸收一份报告的重要信息，大大节约时间、提升效率，助力业务能力升级。
与此类似，“超级助理”还支持一键生成论文摘要，数十页的专业论文（可以是外文），原本一天时间才能看完，现在十秒就能把作者研究的问题、主要观点以及论文中的闪光点这些“精华”部分都能被捕捉到，帮助用户大大提升阅读效率。
这些Copilot能力的展现，说到底，都基于大模型能够成功做好知识运营，即知识主题的定义、挖掘、聚合与关联等工作。
4、知识创造与改进过程
在知识管理全周期中，除了吸收，用户还需要进行创造，要自主撰写一些工作文档。
这方面，大模型同样能够进行价值覆盖。
例如，当用户需要撰写某个领域的方案时，只是规划一个选题，“超级助理”就能以某种“头脑风暴”的方式给出多个灵感方向，帮助用户举一反三，甚至完成内容的扩写、续写、修改等工作。
可以看到，这其中，内容创造完成后的改进工作，大模型也实现了涉及。事实上，“超级助理”还可以对用户各种形势的文档进行改进，例如对用户的简历提供更有成功几率、更符合目标企业需求的修改建议，提升简历的吸引力。
总的看来，几乎所有的针对内容与信息的大模型“助理”，都离不开知识管理的这四个维度，而能够做好这些能力的产品，无疑将能够全面满足用户需求，更值得用户选择。
知识管理“助理”走入企业实现价值落地，还面临两道坎
在公测后，对“超级助理”的发展，百度方面透露了两个方向：
在能力上，将支持一键生成PPT、一键数据分析等更多功能（本质都是强化知识运营、知识创造能力），最终实现“让智能工作替代勤奋工作”。
在场景上，要“为工业、金融、政务、法律、教育、汽车等行业打造专属智能助理”，即“超级助理行业版”，推动“企业进行智能化升级”。
毫无疑问，“超级助理”将是百度进行大模型价值落地的重要案例。
当下，市面上类似的“助理”产品已经在冒出，而它们要走入企业被最终接纳，转化为商业价值，实际上还面临的两道坎——百度的自信满满，恰恰来自于这两个方面都已经做好了准备。
首先，是无论什么样的大模型产品，其智能化能力表现，或者自动化价值呈现，一定都离不开背后的大模型能力。
产品说得天花乱坠，Copilot的自主性、协同性，最终都依赖大模型这个“脑子”的能力，“够聪明”是基础的要求。
“超级助理”以及未来的各版本背后的重要“智力”支撑，来自于国内领先、国际上有话语权的文心大模型。虽然落地是当下的主旋律，但技术创新始终是一切价值的来源。
然后，作为知识管理应用，各种“助理”在形式上是智慧办公类应用的延展，还必须懂企业实际业务，与企业原本的数字化应用融合。
换言之，这可能并不是一个能够“白手起家”的领域，厂商必须先对企业数字化办公有长期的积淀，才能将一个Copilot无缝融入到业务流程当中。做不好数字化办公，也就一定做不好“助理”类产品。
这方面，百度的信心毫无疑问来自于如流等产品的长期深耕。
当下的百度，以AI、大模型为聚焦，正在集整个集团之经验与能力做好商业落地，这在过去可能是没有过的，也显示出百度未来深耕大模型的决心。
对用户而言，选择这样的厂商来上线“助理”类产品，无疑也是更好的选择。
*本文图片均来源于网络 #智能相对论 Focusing on智能新产业新服务，这是智能的服务NO.257深度解读
此内容为【智能相对论】原创，
仅代表个人观点，未经授权，任何人不得以任何方式使用，包括转载、摘编、复制或建立镜像。
部分图片来自网络，且未核实版权归属，不作为商业用途，如有侵犯，请作者与我们联系。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d9e1ac7f93a048d03479bc8bdfdfe901/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c21565f7169fe26218ab093aa626faf6/" rel="bookmark">
			scala 整合 springboot
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		scala 整合 springboot 新建spingboot项目 pom.xml &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;3.2.0&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;cn.lihaozhe&lt;/groupId&gt; &lt;artifactId&gt;scala-boot&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;name&gt;scala-boot&lt;/name&gt; &lt;description&gt;scala-boot&lt;/description&gt; &lt;properties&gt; &lt;jdk.version&gt;21&lt;/jdk.version&gt; &lt;!-- 公共配置 --&gt; &lt;maven.compiler.source&gt;21&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;21&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;21&lt;/maven.compiler.compilerVersion&gt; &lt;maven.compiler.encoding&gt;utf-8&lt;/maven.compiler.encoding&gt; &lt;project.build.sourceEncoding&gt;utf-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;maven.test.failure.ignore&gt;true&lt;/maven.test.failure.ignore&gt; &lt;maven.test.skip&gt;true&lt;/maven.test.skip&gt; &lt;commons-dbutils.version&gt;1.8.1&lt;/commons-dbutils.version&gt; &lt;commons-io.version&gt;2.14.0&lt;/commons-io.version&gt; &lt;commons-lang3.version&gt;3.13.0&lt;/commons-lang3.version&gt; &lt;druid.version&gt;1.2.20&lt;/druid.version&gt; &lt;fastjson.version&gt;2.0.41&lt;/fastjson.version&gt; &lt;gson.version&gt;2.10.1&lt;/gson.version&gt; &lt;hutool.version&gt;5.8.22&lt;/hutool.version&gt; &lt;jackson.version&gt;2.15.3&lt;/jackson.version&gt; &lt;junit.version&gt;5.10.0&lt;/junit.version&gt; &lt;lombok.version&gt;1.18.30&lt;/lombok.version&gt; &lt;mysql.version&gt;8.2.0&lt;/mysql.version&gt; &lt;scala.version&gt;2.13.12&lt;/scala.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-j&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c21565f7169fe26218ab093aa626faf6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ca2d73d689c73d01ee025ac8e5dc511/" rel="bookmark">
			微信开发工具修改编译一直报Cannot read property ‘call‘ of undefined？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我个人的解决方法
更新HbuilderX和微信小程序开发者工具到最新版，微信开发者工具-设置-本地设置-调试基础库也换成最新的3.2.4，打开又报错，
把manifest.json文件内的 “mp-weixin” : {“libVersion”: “latest”}配置上就好了
如果不能解决，参考社区其他人的方法。
https://developers.weixin.qq.com/community/develop/doc/000e4eb89cc29023f20d701be59c00
https://ask.dcloud.net.cn/question/id-82087__sort-DESC__page-2
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c1faada61e8ba29a4de3363d7ddc49c/" rel="bookmark">
			Unable to make field private final java.lang.String java.io.File.path accessible:moudle java.base
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、报错信息 二、报错原因 你项目的gradle版本和as版本不匹配，也就是你遇到下面报错时候，采用系统的提示方法将gradle改成了7.2导致上面的报错。
三、解决方法 关闭Android Studio，删除刚刚的项目目录。然后重新解压导入，遇到Java版本问题按照下面博客解决：Your build is currently configured to use Java 17.0.6 and Gradle 5.6.4.
学者们对于好色、求名、求利、易怒等等过错，不必每种都去考查戒除的办法，只需要一心一意地行善，光明正大的念头在眼前，那些邪念自然污染不了你。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30e7c3b2950446fb3a78a985b8d05b75/" rel="bookmark">
			LeetCode203移除链表元素两种实现方法（Java实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天来分享的是移除链表元素的题目。
题目描述如下。
那么本道题目操作的是单链表，需要注意的是，单链表只能顺序通过next访问数组中的元素。
实现方法1：不使用虚拟节点进行求解
不使用虚拟节点我们在处理头结点需要进行判断，如果要删除的元素是头结点，那么我们此时让head=head.next；
如果删除的不是头结点，那么就让head.next=head.next.next即可删除元素。
那么具体呢，我们来结合代码进行讲解下。
代码如下：
class Solution { public ListNode removeElements(ListNode head, int val) { while (head!=null&amp;&amp;head.val==val){ head=head.next; } //将头结点赋值给cur，操作的是cur不要直接操作head节点。 ListNode cur=head; //特别说明，这里定义cur要指向的是head，而不是head.next // 如果定义的cur=head.nextd的话，那么此时发现被删除的元素是head，这样就无法对head节点进行操作。 // 单链表是没有办法操作前一个元素 //循环结束条件是链表为空 while (cur!=null){ //如果删除的元素的值与目标值相同 while (cur.next!=null&amp;&amp;cur.next.val==val){ //将cur.next指向cur.next.next完成删除操作 cur.next=cur.next.next; } //如果没有找到目标元素，cur向后移动 cur=cur.next; } return head; } } 具体的需要注意的事项和点，我写在了上面的代码注释部分大家可以看着理解一下。
方法2：使用一个虚拟节点解题
在这里我们定义一个虚拟节点VirNode，并让VirNode的next指向头节点head，这样就可以完成对头结点和其它节点一致的操作，而不需要像方法1一样要特别对head节点进行一个判断。
具体代码实现如下：
/** * 使用虚拟节点 */ //定义虚拟节点 ListNode VirNode = new ListNode(); //虚拟节点的next指向head结点 VirNode.next = head; //定义节点指向VirNode不要操作VirNode ListNode node = VirNode; //循环中止条件是node.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/30e7c3b2950446fb3a78a985b8d05b75/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c174f4ad4e8c076eb070e164cb2caecf/" rel="bookmark">
			电脑通过Ready for将访问MOTO 手机桌面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是Ready for ？ 通过Ready for可以将手机体验无缝卓展到外屏显示屏或设备关联，可以丰富您多设备间的交互，获得沉浸式桌面体验
操作步骤 1、摩托罗拉 ready-for 功能介绍 (lenovo.com.cn)，电脑客户端通过官网获取下载安装（win10及以上），手机进入设置-显示-进入Ready For（MYUI1.0以上）：
2、电脑端运行助手，手机点击右上角扫一扫进行扫描电脑二维码（按照要求授予电脑端和手机端蓝牙、定位等权限）
3.手机和电脑必须在同一网络环境下才可实现无线同屏；或通过USB有线连接
3.电脑模式——电脑远程访问手机桌面，可以运行手机上的APP
4、还可以在手机与电脑之间复制文件。从电脑复制文件后，通过访问任务栏中的已复制文件图标，可将文件保存在手机上
电脑文件传到手机：直接将电脑文件拖拽到同屏框内任意位置，手机会直接接收到文件
手机文件传电脑或手机：手机选择文件，相册图片为例-点击分享-选择Ready for互传-选择要传输到哪台设备，完成传输即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea401703873aabe445950e9df21f3f49/" rel="bookmark">
			在nodejs中使用讯飞星火大模型3.0的demo
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求： 在nodejs引入讯飞星火大模型的api接口,
思路 看了一下官方文档 api连接为一个WebSocket Secure（WSS）连接，具体思路如下：
引入 crypto 和 ws 模块，分别用于生成加密签名和创建 WebSocket 连接。（这里要提前下载这两个模块）获取当前时间的 GMT 字符串，构建访问路径 tmp。获取讯飞星火的 API 密钥和密钥，以及应用程序的 ID。使用 HMAC-SHA256 算法生成 tmp 的签名，并将其与 API 密钥等信息组成授权头。将授权信息编码为 Base64 格式，构建访问星火 API 的 WebSocket URL。创建 WebSocket 连接，并在连接打开时发送聊天请求。监听连接的错误、消息和关闭事件，根据事件执行相应的处理，最终将结果通过 resolve 或 reject 返回。 总体而言，是通过 WebSocket 连接与讯飞星火 API 进行通信，发送聊天请求并获取对应的响应。
获取appid，apiSecret，apiKey，检查token次数 首先要注册星火大模型账号，然后进入控制台控制台-讯飞开放平台创建应用如下，自己创建（中间过程忘记了）
最重要的获取次数选择自己需要的模型购买
最后检查控制台有无次数，获取到appid,apiSecret,apiKey
代码 // 访问讯飞星火 API 的方法 function initUrl() { return new Promise((resolve, reject) =&gt; { // 初始化问题值为空字符串 let questionValue = ''; // 引入加密和 WebSocket 模块 const crypto = require('crypto'); const ws = require('ws'); // 获取当前时间的 GMT 字符串 const dateString = new Date().
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ea401703873aabe445950e9df21f3f49/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e2c7cf808284f96d20e824b503483b6/" rel="bookmark">
			SM5321 是一款带动态路径管理的开关型单节锂电池充电电路。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SM5321 2.5A.1MHz 带动态路径管理的开关型单节锂电池充电电路 简介： SM5321 是一款带动态路径管理的开关型单节锂电池充电电路。SM5321 可提供 2.5A 的充电电流，特别适合移动电源、平板电脑等配备超大容量锂电池的设备。SM5321 内部集成了大电流同步降压模块，充电控制模块，动态路径管理，输入限流自动检测，以及所有锂电池充电所需要的各种功能和各种保护电路，如涓流、恒流、恒压充电、电池过温保护、充电指示、充电电流设定无需昂贵的毫欧级电阻、充电时间过长关闭、IC 短路保护和过温保护（仅芯片内部温度）等。SM5321的 SYS 和 BATT 双端口反向截止功能，也防止了输入接口短路时电池的反向倒灌。SM5321 还提供电池移除检测功能。 特性： 动态路径管理＋开关型充电 高达 95%的开关降压效率 高达 2.5A 的充电电流 输入限流自动检测，维持输入电压 电池移除检测 无需昂贵的毫欧级电阻设定充电电流 电池过温保护 开关频率 1MHz ESOP8 封装 应用范围：
移动电源
平板电脑、学习机
移动音箱、移动 3G 路由器
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/473daf1ef97588eee0ddde4848ac6919/" rel="bookmark">
			Vue 理解数据代理 object.defineProperty
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要想理解数据代理就需要对object.defineProperty这个方法特别熟。这个方法在object身上，名字叫做defineProperty，这个方法可不要小瞧，vue底层很多地方都使用到了。
比如vue里面使用的数据劫持就使用到了这个方法，数据代理用到了这个方法，后面计算属性也使用到了这个方法。
给对象添加属性
这个defineProperty就是给一个对象添加属性使用的，或者说给一个对象定义属性用的。
这里传入三个参数，第一个是给哪个对象添加属性，第二个添加的属性叫做什么名字，最后就是一个特别重要的参数叫做配置项，配置项里面可以写很多的配置。
其实你在person对象里面直接添加age属性就行了，但是这种方式没有defineProperty方法高级。
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;首页&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script type="text/javascript"&gt; //定义对象 let person = { name: "zhangsan", sex: "male" } //现在想要张山有年龄，添加一个属性age 18 Object.defineProperty(person,'age',{ value: 18 //这样person对象就有了age这个属性，并且是18 }) console.log(person) //添加了这个属性，但是不参与遍历，也就是不可以枚举 //这个方法可以将传入对象里面的所有属性名提取出来变成数组 console.log(Object.keys(person)) //for i in既可以遍历数组，也可以遍历对象 for(i in person){ console.log(i) } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; enumerable: true 控制属性是否可以枚举，默认值是false
如果属性可以遍历那就需要借助另外一个配置项了， enumerable，这样虽然可以遍历了，但是需要修改该属性值还是修改不了的。 writable: true 可以修改属性值 configurable: true 可以删除属性值
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;首页&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script type="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/473daf1ef97588eee0ddde4848ac6919/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c8958531aa1d38fd3b9657e9f16a496/" rel="bookmark">
			Node.js教程-package.json文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 简介 在Node.js中，package.json是管理其依赖的配置文件。定义了项目所需的各种模块，以及项目的配置信息(如：项目名称、版本、作者信息、许可证等)。package.json文件其实就是一个JSON对象，其位于项目的根目录下。
npm install命令会根据这个配置文件自动下载所需的模块。
配置说明 属性说明name项目名称。长度不能大于214个字符，不能以.或_开头，不能包含大写字母version项目版本author项目开发者。必须为 https://npmjs.org 中有效账户名，遵从 账户名&lt;邮箱&gt;规则description项目描述keywords项目关键字private是否私有。为true时拒绝发布license软件许可证bugsbug提交地址contributors项目共享者repository项目参考地址homepage项目官网地址dependencies生产环境下，项目运行所依赖的包devDepandencies开发环境下，项目运行所依赖的包scriptsnpm 执行命令bin内部命令对应的可执行文件的路径main项目默认执行文件moduleES6模块化方式加载eslintConfigEslint检查配置engines项目运行平台browserlist供浏览器使用的版本列表style供浏览器使用时，样式文件所在的位置files被项目包含的文件名man指定 man 文档位置 扩展 package-lock.json package-lock.json用于锁定模块的版本。(包括主模块和所有依赖的子模块)
执行npm init命令时，在项目根目录下会自动生成package.json和package-lock.json文件
dependencies 中版本 Node.js中，包的版本号以点分十进制形成，一般模式版本由三部分组成。
第一部分：大版本第二部分：功能版本第三部分：Bug修复版本 dependencies中定义了版本的限定，主要由：
指定版本~ + 指定版本 仅能安装当前的bug修复版本。 如：~1.1.3，表示只能安装1.1.x的最新版本(不低于1.1.3)^ + 指定版本 仅能安装当前大版本的新功能和bug修复版本。 如：^1.1.3，表示只能安装1.x.x的最新版本(不低于1.1.3)latest 最新版本 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7db06a8ae0e39db6761379b3e03f111d/" rel="bookmark">
			H5 拍照上传图片,压缩图片方法 ImageCompressor
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考文章：js-image-compressor 图片压缩插件-CSDN博客
&lt;!-- //相机 //capture：user（前置摄像头）、environment（后置摄像头） --&gt;
&lt;div class="file-box"&gt;
&lt;span class="btn"&gt;拍照压缩上传&lt;/span&gt;
&lt;input
class="file-btn"
type="file"
id="photo"
capture="environment"
accept="image/*"
name="photo"
@change="selectPhoto()" /&gt;
&lt;/div&gt;
样式：
.file-box {
height: 32px;
width: 74px;
display: inline-block;
position: relative;
overflow: hidden;
}
.file-btn {
position: absolute;
width: 100%;
height: 100%;
top: 0;
left: 0;
opacity: 0;
}
.btn {
display: inline-block;
width: 100%;
height: 100%;
text-align: center;
line-height: 32px;
border-radius: 3px;
font-weight: 400;
font-size: 14px;
background: #3274f9;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7db06a8ae0e39db6761379b3e03f111d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/111232cbfa05d75e1083bb0c53347f54/" rel="bookmark">
			containerd和docker有哪些区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Containerd和Docker都是容器技术的代表，但它们之间有一些区别。Docker是一种完整的容器解决方案，它包括了容器运行时、镜像管理、网络和存储等多个方面的功能。而Containerd则是一种更为轻量级的容器运行时，它主要负责容器的生命周期管理，包括容器的创建、启动、停止和销毁等。
从架构上来看，Docker是一个完整的容器平台，它包括了Docker Engine、Docker Swarm、Docker Compose等多个组件。而Containerd则是一个更为简单的容器运行时，它的主要功能是管理容器的生命周期。因此，如果你只需要一个轻量级的容器运行时来运行你的应用程序，那么Containerd可能更加适合你。
在实际使用中，Docker拥有更丰富的功能和更广泛的应用场景，它可以用于开发、测试、部署和运维等多个方面。而Containerd则更加适合于轻量级的容器场景，例如边缘计算、物联网等。总的来说，Containerd和Docker都是容器技术的代表，它们都有自己的优缺点和适用场景。选择哪种容器技术取决于你的具体需求和应用场景。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2d1241c966a524908cf16b07f01499e/" rel="bookmark">
			全网最细，Jmeter性能测试-入门级接口压测思路，一文打通...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录：导读 前言一、Python编程入门到精通二、接口自动化项目实战三、Web自动化项目实战四、App自动化项目实战五、一线大厂简历六、测试开发DevOps体系七、常用自动化测试工具八、JMeter性能测试九、总结（尾部小惊喜） 前言 1、压力测试重点关注点是什么？
1）先捋一下压测的目的是什么？
压测主要目的是结合当前服务资源以及当前环境配置基础下，对应用接口在不同压力场景下得出各指标结果是否满足实际应用需求【所以要优化性能指标的话，除从应用接口的代码逻辑和设计链路去优化的话，还需要结合环境的配置（例：连接数、队列值、jvm配置等）以及本身的物理资源去出发；能调到最合理的、最充分的利用率那就是性能大咖了】；
2）对“并发”名词说明
并发这个词在项目中很容易混淆，所以在此先讲解下这个词；
并发分为相对并发和绝对并发；
相对并发是指在一个时间段内发生的事务（可理解跟tps挂钩），绝对并发是指在同一时刻发生的事情（可理解为跟线程数挂钩，jmeter的“集合点”功能可以实现这种方式）；
以下讲的并发都是依据绝对并发来说。
所以首先列下重点关注点，根据如下四点去判断压测是否达标通过：
TPS指标、响应时间、出错率、服务资源情况
下述分享个样例：
【测试结果】：
TPS拐点峰值：依据压测结果，在90并发时达到峰值（2277笔/s），而后续持续递增并发数后TPS呈平稳趋势，即保持峰值在2200左右；–【达到预期≥1557笔要求】
接口响应时间指标((以负载并发截图为准)：依据tps峰值下进行并发，平均响应时间为63.83ms,95%百分位响应时间为92ms；–【达到预期≤100ms要求】
出错率：整个梯级压测过程中出现0.29%异常情况，经核查为环境XXXX问题受影响，非业务逻辑或资源问题，即忽略此错误率；–【达到预期99.9%成功率要求】
服务资源消耗：整体服务资源利用正常，内存及CPU利用平稳无异常情况；TPS下降时cpu正常对等下降，压测结束后资源也可正常释放；–【符合预期，详见报告链接】
3）先说下TPS指标方面
TPS是主要是为了测出拐点峰值，得出当前服务环境下最大的事务处理量（例如上述得出2277笔/s）；
TPS峰值达标判断：需要结合本身实际要求（例如上述-结合实际生产要求得出不小于1557笔），那我峰值已经覆盖预期要求，那TPS指标就算满足达标了；
TPS峰值不满足或者需要达到更佳情况下：就要考虑怎么去调优了，主要方向：从业务代码方面优化、服务配置的优化、再到物理资源的提升；
额外说明：关于实际预期要求多少，这个是需要参考生产实际使用量有多少；目前普遍比较多的是有埋点功能，可以统计到调用量；
再结合有一定参考价值的二八原则计算（指80%的业务量在20%的时间里完成，另此公式不一定适合所有项目，具体需要结合每个系统项目应用场景）；
4）响应时间指标
需结合要求衡量取哪个响应时间，一般主要关注平均值和95%分位值；
如果严谨一点的话可以以99%分位为准(这样情况下确保每个调用都能达标)；
响应时间达标判断：首先先知道指标要求是多少，一般可以从产品经理那给出或者下游调用方超时设置值为参考，这些都算指标要求；
另这块一般都是和tps事务处理量 and 并行要求的（例如：上述相当于说在每秒tps不低于1557的时候,并且95%分位要小于100ms）；
5）出错率
出错率也是一个重点关注项，如果都异常了肯定是不可接受的；
另对整体的指标可能要考虑是否有价值了，但这块肯定需要结合异常情况去分析，在给出结论（如在压测过程报错，有些业务层面上认为是合理的。但往往比较容易忽略，其实可能隐藏很大的性能问题）
注意点：当整体压测下出现小部分概率异常，这个需要自身衡量下指标是否有价值，因为那一小部分影响整体指标可能会很大(比如百分98都是在200毫秒左右，百分之二因为异常5毫秒就响应了，导致整体指标影响很大)
6）服务资源消耗
服务资源主要关注施压机(即请求方)和压力机(被请求方)，施压机需要确保自身环境资源够满足（避免因自身请求方机器原因无法满足设置场景，导致未压出真实指标）；
服务资源利用情况常规的需要重点关注下cpu（例如是互联网产品cpu使用率应该不能超50%，内部使用的一般80%；保证预期最大tps下，服务器还是很健康的）、内存（需要关注应用内存，如jvm的内存变化，只关注服务器内存意义不大），磁盘读写、网络接收发送 --&gt;&gt;各资源消耗不合理的变化或者有较大的异常波动需要再结合分析；
这块服务监听的工具还是很多的，jmeter插件的探针工具也有的，虽然不是很强大，勉强能用【插件下载1：jmeter-PerfMon服务监听；服务资源探针2：Stepping Thread Group】
2、压力测试怎么做？（以TPS为例）
常规的压测大家基本都会做，这里讲下另一种压测方式，既通过梯度增压方式去找出核心指标：TPS峰值
在jmeter中，可以利用【插件下载：Stepping Thread Group】来做到递增压测，直接在一次线程组中找出TPS峰值（详解如下图）
1）配置思路
①上述第一点–&gt;最高并发值：可预估一个较高的并发值，确保在最高并发值内找出tps峰值（如果在此预估配置下未找到tps拐点，需设置更大值）；
②上述第二点–&gt;持续增压（高度）：递增的并发数值需要更准确一点的话，建议设置以最高并发值5-10%区间递增（此处主要避免在递增爬坡的时候出来了tps拐点峰值）；
③上述第三点–&gt;恒定并发量时间（长度）：此处的设置长度（即时长），如果确保要精确些可以设置时间久一点（这里的设置时长：确保tps是趋向平稳状态，如非平稳状态需设置更长或者可能需要考虑其他因素）
TPS效果参考图【插件下载：Transactions per Second】
①确保已经到tps峰值判别：即tps是曲线是横向状态（停止继续上升了）或者tps拐点往下走；
②tps峰值横向一段时间的解释：到峰值时是在现状资源环境下，可最大处理事务量；横向是后续持续增加处于最大队列内，此时段响应时间相对而言增加会更大（每个服务系统不一样，具体需要对应分析）；
附上-响应时间插件【插件下载：ResponseTimesOverTime】
下面是我整理的2023年最全的软件测试工程师学习知识架构体系图 一、Python编程入门到精通 二、接口自动化项目实战 三、Web自动化项目实战 四、App自动化项目实战 五、一线大厂简历 六、测试开发DevOps体系 七、常用自动化测试工具 八、JMeter性能测试 九、总结（尾部小惊喜） 困难是通往成功的必经之路，坚持不懈，终将闯过风雨，绽放出属于自己的辉煌。在奋斗的道路上，每一步都是成长，每一次努力都是收获。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2d1241c966a524908cf16b07f01499e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58bee3f682a0859b5b3d5f88337d87dd/" rel="bookmark">
			matlab的solve函数解方程组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、solve函数的用途
用于求解方程组或者方程的符号解
调用格式
s=solve（eqn，var）
其中eqn表示方程组的表达式，var表示变量
二、使用举例
1.直接调用
s=solve(x+1==0,x)%计算结果为s=-1 [a,b]=solve([x^2+y^2==1,x+y==1],[x,y])%计算结果为a=0,b=1或者a=1,b=0 上述函数中的第一变量为方程组，第二个为待求变量
2.建立方程组再调用
syms x y eq1=x^2+y^2==1 eq2=x+y==1 [a,b]=solve([eq1,eq2],[x,y]) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30438d6c6f952c9b30578f21dd272446/" rel="bookmark">
			获利能力分析COPA配置及应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SAP-COPA 获利能力分析 - 知乎
COPA的应用真的是一言难尽，如果只是为了结算过去，不对账、不用copa报表，那很轻松。要是和财务对账，动不动出问题真得非常人能承受的。要命啊。一般真是CO大神才玩的东西，咱也只能初窥门道。
COPA目的很多，我用到的主要是三方面：
1.生产成本9类差异分析。例如分析某类产品，历次生产过程中，到底和标准价差异在哪。
2.销售成本拆分。例如产品分割结构有15类成本，在销售出库或开票时，能看到这15类成本分别占比多少
3.项目盈利分析。把项目收入、成本按照结果分析定义的行类别，进行拆分，分析项目各类收入和成本占比情况
特征值和值字段，这两个概念对没做过分析类系统的小伙伴而言，可能有些吃力。
举例，我按照时间、单位、项目分类等维度，分析项目收入和成本。那么时间、单位、项目分类这些维度就是特征值，值字段是收入、成本等。
1 先上通用的配置 1.1 特征值 1.1.1 系统预先定义特征值 - KEA5 白色为可添加的，如下图：
这样我们就把地区添加进去了。如果没有维护特征值也无所谓，系统默认已经添加了好多预定义的特征值了，新加的特征值也都可以根据老的特征值关联回来的。但是一定要注意，尽量在系统上线前把该添加的特征值都加上，否则运行了一段时间，再添加新的特征值，那么老的特征值就不会有数据。
1.1.2 自定义特征值 比如我们要定义客户的类型，客户是属于系统内的，还是系统外的
保存并激活
1.1.3 维护自定义特征值的内容 比如系统内外，有3个类别，一个是系统内-集团内、一个是系统内-集团外、一个是系统外，那么需要维护这3个特征。
此处需要激活经营范围才能看到并维护，具体激活经营范围的参见4.3
1.1.4 维护系统字段到自定义特征值的映射（派生规则） 其数据来源于客户主数据中的“客户科目分配组”字段，对应的字段为KNVV-KTGRD（这儿只是简单的模拟，正常其实系统有这个字段了，多次一举，肯定需要更复杂的才用到推导规则，本次用一下简单的推导规则）
特征值不是凭空产生的，自定义特征值必须也得能从系统默认特征值推导出来，推导不出来就写增强推导出来，说白了你增加的分析维度，不能是0或者空吧。
1.2 值字段 值字段，就是你要按维度分析的指标。值字段要全部自定义。一般都是自定义
我们以项目所需值字段为例，在结果分析的行中，定义了人工、物料、费用和收入4个，再多定义一个主营业务成本以及毛利。
数量的话，基本只定义销售数量、发货数量、开票数量，这个要分析哪些字段，可能要上线前反复推敲。就是生产差异、销售、项目、FI记账等等，都需要考虑清楚。
最终我定义的值字段如下：
其中包括项目用的成本拆分，销售开票用的成本拆分，生产订单差异用的差异明细
1.3 经营范围 经营范围，基本配置和控制范围是一对一的，说白了就是你定义了这么多维度和指标，但是你成本控制范围用的维度和指标到底是哪些呢？
1.3.1 创建经营范围 1.3.2 分配经营范围 1.3.3 维护经营关注点 1.此处是分两种模式的，一种是基于成本的，一种是基于科目的。
基于成本的要求把特征值+值字段都进行分配。
基于科目的只需要维护特征值即可，值数据都传递到科目了。
本次两个都勾选，其实S4推荐是基于科目的，这样的话，生产成本的9大差异、成本组件都会转到对应的科目中去。
2.如果加值字段，可以如下：
3.其实系统默认也会把一些固定的特征值加进来，这个是系统强制默认的。在附加-显示固定字段。这些固定的其实差不多都够全了。
4.维护经营范围的属性：就是货币和变式
5.在环境中激活
1.3.4 看看表 CE16888：COPA明细行项目-实际值，每笔发生值
CE26888：COPA明细行项目-计划值，一般很少有人用
CE36888：COPA的汇总数据，按照不同获利能力段 ，可以理解为sum+ group by
CE46888：COPA获利能力段有哪些，可以理解为group by的内容
2 基于成本的配置关键点 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/30438d6c6f952c9b30578f21dd272446/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dcfde6f308eec0f5bb78cfd94463b630/" rel="bookmark">
			Nuclei POC 编写教程（非常详细）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
0x00 前言
0x01 YAML 简介
0x02 YAML POC 编写流程
0x03 Nuclei POC 案例 1 - CVE-2023-28432（匹配结果）
0x04 Nuclei POC 案例 2 - CVE-2022-30525（匹配交互）
0x05 Nuclei POC 模版生成 BP 插件
0x00 前言 希望和各位大佬一起学习，如果文章内容有错请多多指正，谢谢！ 个人博客链接：CH4SER的个人BLOG – Welcome To Ch4ser's Blog
0x01 YAML 简介 YAML 是 “YAML Ain’t a Markup Language”（YAML 不是一种标记语言）的递归缩写。在开发的这种语言时，YAML 的意思其实是：“Yet Another Markup Language”（仍是一种标记语言）。
参考文章：
https://blog.csdn.net/qq_41315957/article/details/126594572
https://blog.csdn.net/qq_41315957/article/details/126594670
基本语法规则：
大小写敏感使用缩进表示层级关系（不允许使用Tab键，只允许使用空格）缩进的空格数目不重要，只要相同层级的元素左侧对齐即可 YAML POC 基本组成：(总的来说，可以看成三个部分：基本信息、请求、匹配或提取）
1、编号 id2、信息 info3、请求 http file tcp...4、匹配 matchers Interactsh5、提取 extractors 具体使用匹配还是提取，要根据实际情况来看。比如，当利用成功条件是页面返回里有特定关键字时，用的是匹配；当需要根据页面返回的长度判断有没有利用成功时，用的是提取。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dcfde6f308eec0f5bb78cfd94463b630/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/edbf6352d72cd9c544064d2b64a95979/" rel="bookmark">
			Postman测试文件上传接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、Postman测试文件上传接口1、创建一个请求→选择请求方式→填写请求的URL→填写请求的参数值2、选择 "Body" → "form-data" → "Test" → "File"3、点击 "Select Files"4、选择要上传的文件5、点击 ''Send'' 进行测试6、查看测试结果7、可以将测试结果返回的URL复制到浏览器的地址栏进行查看 一、Postman测试文件上传接口 1、创建一个请求→选择请求方式→填写请求的URL→填写请求的参数值 2、选择 “Body” → “form-data” → “Test” → “File” 3、点击 “Select Files” 4、选择要上传的文件 5、点击 ‘‘Send’’ 进行测试 6、查看测试结果 7、可以将测试结果返回的URL复制到浏览器的地址栏进行查看 响应的URL内容有转义符 “\” ，访问前需要删除掉转义符
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c7525c19a26079a6729b26f65f27ae9/" rel="bookmark">
			JMeter接口测试高阶——精通JMeter接口测试之BeanShell及调用java和python脚本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、BeanShell组件二、BeanShell自带的语法（BeanShell常用变量和语法）1.log打印2.vars用来操作JMeter的局部变量（只能在一个线程组里面使用的变量）3.props用来操作JMeter的全局变量（能够跨线程组取值的变量）3.prev获取前一个请求返回的信息 三、BeanShell调用java文件、jar包1.BeanShell调用java文件2.BeanShell调用jar包 四、BeanShell调用python无参、一个参数、多个参数的函数文件1.BeanShell调用无参函数2.BeanShell调用有一个参数的函数3.BeanShell调用有多个参数的函数（无变量）4.BeanShell调用有多个参数的函数（有变量） 一、BeanShell组件 BeanShell组件完全符合java的语法以及自带语法的组件，总共有6种
BeanShell 断言BeanShell 前置处理器BeanShell 取样器BeanShell 后置处理器BeanShell 定时器BeanShell 监听器 二、BeanShell自带的语法（BeanShell常用变量和语法） 1.log打印 信息打印
//在日志中打印张三 log.info("张三"); 错误信息打印
//在日志中打印错误信息 log.error("打印错误信息"); 拼接打印
//不支持整类，需要使用字符串拼接 log.info(123 + ""); java打印
//java打印，在控制台显示 System.out.println("java打印"); 2.vars用来操作JMeter的局部变量（只能在一个线程组里面使用的变量） 1.对于 [用户定义的变量] 可以直接通过vars.get()取值
2.对于通过 [正则表达式] 或其他表达式获取到的中间变量可以直接通过vars.get()取值
3.不同的BeanShell之间可以相互设置或者获取值
获取变量
//获取用户定义变量中的值 log.info(vars.get("name")); 定义变量
//定义一个变量 vars.put("age","18"); 3.props用来操作JMeter的全局变量（能够跨线程组取值的变量） //定义一个变量 props.put("age","18"); //获取线程组1中BeanShell取样器1定义变量的值 log.info(props.get("age")); 注意：执行的时候记得勾选测试计划中的 [独立运行每个线程组] ，因为线程组执行是无序的
3.prev获取前一个请求返回的信息 //获取响应码 log.info(prev.getResponseCode()); //获取响应的内容 log.info(prev.getResponseDataAsString()); 三、BeanShell调用java文件、jar包 1.BeanShell调用java文件 准备一个java文件
public class Test{ public int sum(int a,int b){ return a+b; } } BeanShell调用java文件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c7525c19a26079a6729b26f65f27ae9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8442dfaf50ce1c84b9e42c996d110e89/" rel="bookmark">
			当文字成为雨滴：HTML、CSS、JS创作炫酷的“文字雨“动画！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 在本篇技术文章中，将介绍如何使用HTML、CSS和JavaScript创建一个独特而引人注目的"文字(字母&amp;数字)"雨🌧️动画效果。通过该动画，展现出的是一系列随机字符将从云朵中下落像是将文字变成雨滴从天而降，营造出与众不同的视觉效果。
文字雨
HTML 创建一个基本的HTML结构，这段HTML代码定义了一个容器，其中包含了"云朵"和"雨滴"(即文字元素)。基本结构如下：
首先是类名为container的容器，表示整个动画的容器；其次是类名为cloud的容器，表示云朵的容器；接着是cloud容器中的文字元素，表示雨滴(即文字元素)； 然后引入外部创建的css和js文件，可以先定义几个text容器，用于调整样式；
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Text Rain Animation&lt;/title&gt; &lt;link rel="stylesheet" href="./css/style.css"&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="container"&gt; &lt;div class="cloud"&gt; &lt;!-- &lt;div class="text"&gt;a&lt;/div&gt; --&gt; &lt;!-- &lt;div class="text"&gt;b&lt;/div&gt; --&gt; &lt;!-- &lt;div class="text"&gt;c&lt;/div&gt; --&gt; &lt;!-- 雨滴将会在这里出现 --&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src="./js/main.js"&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; CSS CSS是为文字雨效果增色添彩的关键，使动画效果更加丰富，关于一些 CSS 样式：
使用了自定义的颜色变量来为背景色和文本颜色提供值，有助于使代码易于维护和修改；利用CSS的阴影效果和动画功能，创造逼真的"云朵"和流畅的"雨滴"动画； * { margin: 0; padding: 0; box-sizing: border-box; } :root { --body-color: #181c1f; --primary-color: #ffffff; } body { display: flex; justify-content: center; align-items: center; min-height: 100vh; background-color: var(--body-color); } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8442dfaf50ce1c84b9e42c996d110e89/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c28dbde8f2380ee61f47e76bae8b7d4/" rel="bookmark">
			SAP CO内部订单详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在SAP里面，内部订单是一种成本对象，它和成本中心可以视为 CO 成本管理中的最常用的两种成本费用流出流入的“容器”。我们可以对内部订单进行成本的计划、认定、控制和分摊。和成本中心不同的是内部订单有明确的开始和结束，它不是一种组织机构，而是一个个小的项目（Project）。
为什么要使用内部订单呢，有如下应用场景:
某个市场活动的预算是多少? 实际发生多少费用?
某个研发项目的预算是多少? 实际发生多少费用?
某个工程项目的预算是多少? 实际发生多少费用?
某个销售人员或者管理人员的每月费用是多少?
内部订单用于计划、收集、监控和结算在公司内部进行的特定操作或任务。
这里的“订单”不同于生产订单、销售订单或采购订单，用户可以根据业务需要，
对内部订单赋予不同的意义，用它来追踪某个有起始时间的事件（如展销会）；
内部订单也可以用于对某持续的事件或服务，如设备维护和修理，进行费用控制。
内部订单可用于不同的目的。这种功能分类反映在不同的订单类型中，其属性定义了在系统中处理订单的方式。
内部订单的特点如下:
内部订单是一种特殊的成本对象;
可以用于跟踪归集一个特定活动的计划和实际成本;
可以用于对成本中心核算的一个细分;
可以用于跨成本中心的费用的归集;
在不使用 PS 模块的情况下，可以用于小型项目的成本管理。
一、内部订单类别
SAP 系统提供的内部订单类别（Order Category）,下表标识说明的为常用的
订单类别；
二、订单类别和订单类型的定义及区别:
订单类别由系统预先设定，用来组织订单的业务功能。
内部订单的订单类别为 01（Order Category）,而订单类型（order type）根据需求而定。每个订单类型归属到一个系统预先设置的订单类别。订单类别和订单类型是一对多的关系,可用事务码:KOT2 可以看到所有订单类型。
三、常见的内部订单类型分类：
间接费用订单：费用订单是用于归集特殊事件和临时项目成本的对象。
投资订单：用于监视在固定资产生产过程中发生的成本，如建造厂房及安装设备。
应计订单：对未来发生的费用提前入账，然后在一定期间范围内进行摊销。
带收入的内部订单：如果某些收入的业务不用销售订单模块管理，可以使用内部订单简化管理。
模型订单：这个只是一个模型，不是一个操作实际业务的订单。
对象分类：
内部订单的分类订单类别对象分类备注间接费用订单1-内部订单OCOST-间接费用成本常用投资订单1-内部订单INVST-投资较少使用应计订单1-内部订单不用带收入的内部订单1-内部订单PROFT-利润中心分析不用模型订单3-模型订单不用 费用订单分统计型费用订单和实际费用订单。
统计型费用订单；不用维护订单结算规则，因为统计型费用订单只用于报表分析的用途。
内部订单主数据（KO02）
实际费用订单；需要维护结算规则，成本发生时，可将明细费用项记账到该内部订单，收入确认时，可以收入记账到该订单。月末内部订单结账，可自动将内部订单中归集的费用结转至销售成本科目，并完成按订单分析该项业务活动的利润实现情况。
上图，“统计订单”，被勾选，说明内部订单是统计性的；如果没有勾选，说明内部订单是实际的。
如果是统计性的内部订单，在费用记账时，该订单是统计记账，还需要一个真实记账的成本对象，如成本中心；
如果是一个实际内部订单，则该订单是真实记账，可以不用附加其他的成本对象，如果附加了，则其他的成本对象“沦为”统计记账。
费用记账时同时输入内部订单和成本中心时的结果
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26e50eb839f5e73b261054f53f167ebd/" rel="bookmark">
			LA@线性代数学习总结@主要对象和问题@思想方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 线性代数研究对象主要问题联系核心概念核心定理 核心操作和运算基础高级小结 性质和推导方法问题转换为线性方程组求解问题验证和推导性质定理 线性代数研究对象 线性代数的研究对象主要是行列式和矩阵(向量)矩阵这种对象可以做的操作和运算很多,特别是方阵,它们的计算量天然就有较大的特点,例如:伴随矩阵的计算,矩阵乘法,计算逆矩阵等,其中又以矩阵乘法运算最为重要,几乎贯穿整个学科的始终,是许多其他概念和计算的基础 主要问题 为了解决几个重要问题,提出了许多概念,例如秩,初等变换和基于这些概念的方法
矩阵方程和线性方程组的解向量组的线性相关性特征值和特征向量问题 矩阵(方阵)相似对角化问题二次型问题 联系 向量组线性相关问题和特征值和特征向量问题,本质上可以转化为线性方程组的解的问题
例如向量组 A A A线性相关用线性方程组描述为 A x = 0 \bold{Ax=0} Ax=0(1)存在非零解,这又等价于 R ( A ) &lt; n R(A)&lt;n R(A)&lt;n问题(其中 n n n为 x \bold{x} x的维数,或向量组 A A A包含的向量个数)
向量组 B B B能够由 A A A线性表出,则 A X = B \bold{AX=B} AX=B(2)有解
矩阵 A \bold{A} A关于特征值 λ \lambda λ的特征向量 A α = λ α \bold{A\alpha=\lambda\alpha} Aα=λα(3)求解,可以转换为线性方程组 ( λ E − A ) α = 0 (\lambda\bold{E}-A)\alpha=\bold{0} (λE−A)α=0(3-1)或 ( A − λ E ) α = 0 (\bold{A}-\lambda\bold{E})\alpha=0 (A−λE)α=0(3-2)有求非零解问题(方程(3,3-1,3-2)是等价方程)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/26e50eb839f5e73b261054f53f167ebd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a00d666673b13933549a5bfa4daf29f6/" rel="bookmark">
			低代码和纯代码：双向奔赴，共创未来ing……
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		低代码开发是近年来迅速崛起的软件开发方法，让编写应用程序变得更快、更简单。有人说它是美味的膳食，让开发过程高效而满足，但也有人质疑它是垃圾食品，缺乏定制性与深度。你认为低代码到底是美味的膳食还是垃圾食品呢，来分享一下吧！
一、什么是低代码 低代码译自Low-Code，而Low-Code则源于Low-Code Development Platform。早在2014年，著名的研究机构Forrester就提出了“Low-Code Development Platform（低代码开发平台，LCDP）”的概念，其定义为：
Platforms that enable rapid delivery of business applications with minimum hand-codling and minimal upfront Investment in setup, training. and deployment.
直译过来就是：
这些平台能够以最少的手工编码和最少的前期投资快速交付业务应用程序，包括设置、培训和部署。
维基百科上对低代码开发平台给出的定义是：
A low-code development platform (LCDP) is software that provides an development environment programmers use to create application software through graphical user interfaces and configuration instead of traditional hand-coded computer programming.
直译过来就是：
低代码开发平台 （LCDP） 是一种软件，它为程序员提供了一个开发环境，用于通过图形用户界面和配置创建应用软件，而不是传统的手工编码计算机编程。
二、低代码的优缺点 （一）低代码的优点 低代码开发平台基于经典的可视化和模型驱动理念，结合最新的云原生与多端体验技术，其优点在于它不仅能够降低业务应用的开发成本，而且可以实现业务应用的快速交付。
这主要体现在两个方面：一方面，低代码开发代码编写更少、环境设置和部署成本也更简单，从而在软件全生命周期流程上的投入都要更低；另一方面，低代码开发还显著降低了开发人员的使用门槛，非专业开发者经过简单的IT基础培训就能快速上岗，从而大幅降低对薪资不菲的专业开发者资源的依赖。根据Forrester在2016年的调研，大部分公司反馈低代码平台帮助他们把开发效率提升了5-10倍。而且我们有理由相信，随着低代码技术、产品和行业的不断成熟，这个提升倍数还能继续上涨。
有了低代码开发平台，软件开发者并不需要使用传统的手写代码方式进行编程，而是通过低代码平台管理后台的可视化界面，进行图形化拖拽、参数配置等更高效的方式来完成开发工作，从而让开发者在没有任何编程语言基础的情况下也能开发出各种业务场景的应用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a00d666673b13933549a5bfa4daf29f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/828392a9ff1cd6a98d806c3804839c3b/" rel="bookmark">
			安卓Activity、AppCompatActivity的setContentView()流程分析及视图结构分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.Activity的视图加载过程 1.1 Activity.java --&gt;setContentView() public void setContentView(@LayoutRes int layoutResID) { getWindow().setContentView(layoutResID); initWindowDecorActionBar(); } 1.2 Activity.java --&gt;getWindow() 返回mWindow对象，此处的mWindow对象实例化为PhoneWindow，实例化过程涉及Activity的启动流程，在此不做过多介绍。
第1个视图为PhoneWindow对象。
public Window getWindow() { return mWindow; } 1.3 PhoneWindow.java --&gt;setContentView() 重点关注installDecor()方法，对mContentParent进行判断如果为空使用 installDecor()方法安装Decor。
// This is the view in which the window contents are placed. It is either // mDecor itself, or a child of mDecor where the contents go. /* 这是放置窗口内容的视图。要么mDecor本身，或者内容所在的mDecor的子级。 */ ViewGroup mContentParent; // Whether the client has explicitly set the content view.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/828392a9ff1cd6a98d806c3804839c3b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c3d99f235c9c89961eb8c9f8f69704b/" rel="bookmark">
			在vue中使用axios发送请求
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
如何在vue中使用axios发起请求？
1.安装
2.axios配置项
3.axios发起get、post等请求方法
4.方法别名/快捷方法
5.全局默认值
6.请求拦截器、响应拦截器
前言 axios是基于promise的http库，可以运行在浏览器和nodejs。
特性：
1.运行在浏览器和nodejs
2.基于promise，可以使用promise实例方法
3.可以对请求和响应拦截处理
4.运行在浏览器创建XMLHttpRequests
5.运行在nodejs创建http请求
如何在vue中使用axios发起请求？ 1.安装 cnpm/npm install axios -S bootcdn：
&lt;script src="https://unpkg.com/axios/dist/axios.min.js"&gt;&lt;/script&gt; 2.axios配置项 // 发起axios请求 axios({ // 请求路径 必填项 url:"", // 请求方法 method:"", // 基础路径 拼接在url之前 baseURL:'', // get delete head 一类请求携带参数选项 params:{ }, // post put patch 一类请求携带参数选项 data:{ }, // 设置请求头 headers:{}, // 请求超过2s未完成中断请求 timeout:2000 }) 3.axios发起get、post等请求方法 先介绍一下，Axios常用的几种请求方法有哪些：get、post、put、patch、delete
get：（一般用于）获取数据
post：提交数据（表单提交+文件上传）
put：更新（或编辑）数据（所有数据推送到后端（或服务端））
patch：更新数据（只将修改的数据推送到后端）
delete：删除数据
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c3d99f235c9c89961eb8c9f8f69704b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6aa31bbf6d82fb86ea8dadf302798517/" rel="bookmark">
			Python PDF格式转PPT格式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要将PDF文件转换为PPT，我实在python3.9 环境下转成功的，python3.11不行。
需要
pip install PyMuPDF 代码说话
# -*- coding: utf-8 -*- """ @author: 赫凯 @software: PyCharm @file: xxx.py @time: 2023/12/21 11:20 """ import fitz # PyMuPDF from pptx import Presentation from pptx.util import Inches # 设置ppt的长和宽 width_X = Inches(13.33) height_Y = Inches(7.5) def pdf_to_ppt(input_pdf, output_ppt): # 打开PDF pdf_document = fitz.open(input_pdf) # 创建一个空的PPT文档 ppt = Presentation() # 设置幻灯片尺寸为16:9 ppt.slide_width = width_X ppt.slide_height = height_Y for page_number in range(pdf_document.page_count): # 创建一个新的PPT幻灯片 slide = ppt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6aa31bbf6d82fb86ea8dadf302798517/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27a3883a3c27a27aa661287441631a8d/" rel="bookmark">
			关于 jsconfig.json 文件在导入文件路径提示方面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前文：以前我弄不清 jsconfig.json 文件的作用是什么，只觉得 tsconfig.json 文件是用来 ts 编译的配置项，js 又不用编译为什么会需要 jsconfig.json 文件。搬了这么久的砖，也算是有所心得，今日记下以备不时之需。
jsconfig.json 文件是用于配置 JavaScript 项目的 Visual Studio Code 设置的文件。它类似于 TypeScript 项目中的 tsconfig.json 文件，但是用于纯 JavaScript 项目。以下是关于 jsconfig.json 文件的一些说明，重点放在文件导入提示和与 tsconfig.json 文件的共性，以及与 Path Autocomplete 插件的对比：
1. 文件导入提示（Path Intellisense）： 基础设置：
jsconfig.json 可以包含基础的配置信息，例如 compilerOptions、include 和 exclude 等，以帮助 Visual Studio Code 更好地理解项目结构。示例：{ "compilerOptions": { "baseUrl": "./src" }, "include": ["src/**/*.js"] } 路径提示：
使用 baseUrl 配置根路径，可以让你使用相对路径或者基于根路径的绝对路径进行导入。示例：// 使用相对路径 import { someFunction } from './utils/helper'; // 使用根路径 import { someFunction } from 'utils/helper'; 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/27a3883a3c27a27aa661287441631a8d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29fd92a11214996f71e949edbccda12e/" rel="bookmark">
			嵌入式Linux应用程序开发实践分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		近年来，随着物联网技术的快速发展，嵌入式系统应用越来越广泛。作为嵌入式系统的核心，Linux操作系统也变得越来越重要。在这个背景下，嵌入式Linux应用程序开发成为了一个热门话题。本文将从实践出发，逐步分析嵌入式Linux应用程序开发的相关内容。
一、熟悉Linux内核
首先，要想深入了解嵌入式Linux应用程序开发linux makefile，必须对Linux内核有比较深入的了解。包括Linux内核的架构、启动过程、驱动程序等等。只有对内核有一定的掌握，才能更好地进行应用程序开发。
二、掌握交叉编译技术
在进行嵌入式Linux应用程序开发时，需要在PC机上进行交叉编译，生成可在目标平台上运行的可执行文件。因此，掌握交叉编译技术是非常重要的。需要了解交叉编译工具链的安装、配置和使用方法。
三、选择合适的开发环境
目前市面上有很多种嵌入式Linux应用程序开发环境，如Eclipse、Qt Creator等等。选择一个合适的开发环境对于提高开发效率是非常重要的。需要根据实际需求和经验进行选择。
四、熟悉C/C++编程语言
C/C++是嵌入式Linux应用程序开发中最常用的编程语言。需要对C/C++语言有比较熟练的掌握，包括变量类型、指针、函数调用等等。同时，还需要了解一些常用的库函数和API。
五、掌握Linux文件系统
在嵌入式Linux应用程序开发中，文件系统是非常重要的一部分。需要了解文件系统的结构、目录结构、文件权限等等相关内容。同时，还需要知道如何在应用程序中读取和写入文件。
六、熟悉网络编程
在物联网时代，网络编程也是嵌入式Linux应用程序开发中必不可少的一部分。需要了解TCP/IP协议栈、socket编程等相关内容，才能进行网络通信。
嵌入式Linux应用程序开发实践分析嵌入式Linux应用程序开发实践分析
七、了解常见的嵌入式设备接口
嵌入式设备通常有很多种接口从实践中学嵌入式linux应用程序开发，如GPIO、I2C、SPI等等。需要了解这些接口的使用方法，才能进行对设备的控制和数据的读写。
八、熟悉嵌入式系统调试技术
嵌入式Linux应用程序开发实践分析嵌入式Linux应用程序开发实践分析
在进行嵌入式Linux应用程序开发时，难免会遇到各种问题。需要掌握一些常见的调试技术从实践中学嵌入式linux应用程序开发，如printf调试、GDB调试等等，才能快速定位和解决问题。
九、注重实践和经验积累
最后，要想成为一名优秀的嵌入式Linux应用程序开发工程师，需要注重实践和经验积累。通过多做项目、多写代码、多总结经验，才能不断提升自己的技术水平。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3ad2b1d81ef2112ab308298e01f5a05/" rel="bookmark">
			远端连接vscode
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 安装remote ssh连接远端插件安装编译代码 安装remote ssh 进入vscode拓展页，搜索remote ssh进行安装
连接远端 然后f1，输入remote ssh add，添加自己的服务器
这个路径就存储着我们的配置信息
然后进入远程资源管理器
右键，选择连接
选择Linux，然后输入密码
这样代表连接成功
然后进入资源管理器打开文件，选择我们要进入的路径（不建议直接进入一个大的路径，选择要进入的具体文件路径）
中间可以还需要选择系统和输入密码，照常选择输入即可。
这样我们就可以在vscode里面编写代码然后同步到云端了
插件安装 连接到远端之后再进行安装
编译代码 这里用指令即可，ctrl+ ~调出终端
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db4acb7c66e206b71d34f48e754b3a31/" rel="bookmark">
			左右滚动的内容加点提示。滚动到第二页第二个点点高亮。模拟轮播图效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1，微信小程序可以使用scroll-view组件。然后利用她的@scroll事件获取到scrollLeft &lt;scroll-view scroll-x="true" @scroll="scrollPrice"&gt; 。。。
&lt;/scroll-view&gt;
点点的数量。一页面放了三个块。所以用总的长度处以3.向上取整。
&lt;view class="bottom-dot" v-if="package.length&gt;3"&gt; &lt;text v-for="i in Math.ceil(package.length/3)" :class="['dot']" &gt;&lt;/text&gt; &lt;/view&gt; .bottom-dot{ margin-top:25px; display: flex; align-content: center; justify-content: center; .dot{ width: 10px; height: 10px; background: #E0E0E0; border-radius:50%; margin-right:10px; &amp;.active{ background:#999999; } } } // 套餐滚动获取高亮显示的点 function scrollPrice(e){ activeDot.value=Math.ceil(e.detail.scrollLeft/400) } 2，vue项目中。可以利用ref &lt;div ref="srcollpriceA" @scroll="scrollPrice"&gt; 。。。
&lt;/div&gt;
这里本来我用了和上面一样获取scroll的参数。但是看着她的e.detail.scrollLeft一直是0.所以最后修改用了ref
scrollPrice(){ let scrollLeft=this.$refs.srcollpriceA.scrollLeft; this.activeDot=Math.ceil(scrollLeft/400) } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84dc65528a2f9d23ec0e2e3960193450/" rel="bookmark">
			基于GD32单片机的12位ADC压力采集（50kg压力），附源码和原理图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1，静止状态下采集的各项数值： 上位机监测到的ADC采集到的数据，该处采集的电压值是3.287mv,电压及压力值如下图：
示波器采集的电压值：3.26V，与上述单片机采集的数值基本一致
2，施加一定压力下采集的各项数值： 上位机监测到的ADC采集到的数据，该处采集的电压值是2.454mv，电压及压力值如下图：
示波器采集的电压值：2.50V，与上述单片机采集的数值基本一致
3，我们来看看其原理图，VCC这里接的是3.3V，U4便是我们的待测压力传感器，使用PA1的ADC0通道一进行检测： 4，源码，这里面加了均值滤波，电压，压力转换函数，用户只需要调用Get_Frc()接口函数即可，源码如下： bsp_adc.c文件
#include "bsp_adc.h" #include "bsp_usart.h" #include "stdio.h" /*********************************FSRADC*************************************************/ #define PRESS_MIN 20 // 最小量程 20g #define PRESS_MAX 49999 // 最大量程 50kg 以具体型号的数据手册为准 #define VOLTAGE_MIN 1150 // 有效电压范围 可调节 这里指的是1.33V到3.28V #define VOLTAGE_MAX 3280 long PRESS_AO = 0; /********************************************************** * 函 数 名 称：adc_config * 函 数 功 能：ADC初始化 * 传 入 参 数：无 * 函 数 返 回：无 * 作 者： * 备 注：无 **********************************************************/ void adc_config(void) { // 使能引脚时钟 rcu_periph_clock_enable(RCU_GPIOC); // 使能ADC时钟 rcu_periph_clock_enable(RCU_ADC0); // 配置ADC时钟 adc_clock_config(ADC_ADCCK_PCLK2_DIV4); // 配置引脚为模拟输入模式 gpio_mode_set(GPIOA, GPIO_MODE_ANALOG, GPIO_PUPD_NONE, GPIO_PIN_1); // 配置ADC为独立模式 adc_sync_mode_config(ADC_SYNC_MODE_INDEPENDENT); // 使能扫描模式 adc_special_function_config(ADC0, ADC_SCAN_MODE, ENABLE); // 数据右对齐 adc_data_alignment_config(ADC0, ADC_DATAALIGN_RIGHT); // ADC0设置为12位分辨率 adc_resolution_config(ADC0, ADC_RESOLUTION_12B); // ADC0设置为规则组 一共使用 1 个通道 adc_channel_length_config(ADC0, ADC_REGULAR_CHANNEL, 1); // ADC外部触发禁用, 即只能使用软件触发 adc_external_trigger_config(ADC0, ADC_REGULAR_CHANNEL, EXTERNAL_TRIGGER_DISABLE); // ADC0使能 adc_enable(ADC0); // 开启ADC自校准 adc_calibration_enable(ADC0); } /********************************************************** * 函 数 名 称：Get_ADC_Value * 函 数 功 能：读取ADC值 * 传 入 参 数：ADC_CHANNEL_x=要采集的通道 * 函 数 返 回：测量到的值 * 作 者：LiangXia * 备 注：无 **********************************************************/ unsigned int Get_ADC_Value(uint8_t ADC_CHANNEL_x) { unsigned int adc_value = 0; // 设置采集通道 adc_regular_channel_config(ADC0, 0, ADC_CHANNEL_x, ADC_SAMPLETIME_15); // 开始软件转换 adc_software_trigger_enable(ADC0, ADC_REGULAR_CHANNEL); // 等待 ADC0 采样完成 while (adc_flag_get(ADC0, ADC_FLAG_EOC) == RESET) { ; } // 读取采样值 adc_value = adc_regular_data_read(ADC0); // 返回采样值 return adc_value; } /********************************************************** * 函 数 名 称：map * 函 数 功 能：ADC函数处理 * 传 入 参 数：待测值 x, 输入最大最小值：in_min,in_max, 输出最大最小值：out_min,out_max * 函 数 返 回：处理后的值 * 作 者：LiangXia * 备 注：无 **********************************************************/ long map(long x, long in_min, long in_max, long out_min, long out_max) { return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min; } /********************************************************** * 函 数 名 称：Get_Adc_Average * 函 数 功 能：均值滤波 * 传 入 参 数：通道 * 函 数 返 回：均值滤波处理后的值 * 作 者：LiangXia * 备 注：无 **********************************************************/ uint16_t Get_Adc_Average(uint8_t ch) { uint32_t temp_val = 0; uint8_t t; for (t = 0; t &lt; 40; t++) { temp_val += Get_ADC_Value(ch); delay_1ms(5); } return temp_val / 40; } /********************************************************** * 函 数 名 称：Get_Frc * 函 数 功 能：压力测试 * 传 入 参 数：无 * 函 数 返 回：无 * 作 者：LiangXia * 备 注：无 **********************************************************/ void Get_Frc() { /* value convert */ int VOLTAGE_AO = map(Get_Adc_Average(ADC_CHANNEL_1), 0, 4095, 0, 3300); // 前两位是采集ADC值（一般是0-4095，此处实际测试是2374-3907） 后两位是电压值 if (VOLTAGE_AO &lt; VOLTAGE_MIN) { PRESS_AO = PRESS_MAX; } else if (VOLTAGE_AO &gt; VOLTAGE_MAX) { PRESS_AO = 0; } else { PRESS_AO = map(VOLTAGE_AO, VOLTAGE_MAX, VOLTAGE_MIN, PRESS_MIN, PRESS_MAX); } delay_1ms(10); printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/84dc65528a2f9d23ec0e2e3960193450/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8880d40b30ee2aae0b716b4b69c8c712/" rel="bookmark">
			2023华为OD机试真题目录汇总 B&#43;C&#43;D卷（470道）（Python语言）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 🚀前言🚀其他华为OD机试题清单一、什么是华为OD，什么是华为OD机试？二、华为OD面试流程？三、华为OD机试通过率高吗？四、华为OD薪资待遇？🚀五、怎么刷题？通过华为OD机试？华为OD机试真题刷题列表🔰部分文章试读演示🔰部分思路及代码参考演示🔰刷题列表：华为OD机试真题（Python） B+C+D卷2023年B+C+D卷 新题库(100分)2023年B+C+D卷 新题库(200分) 作者：KJ.JK 🚀前言 本文是华为OD机试真题（Python 语言） 专栏的目录贴（持续更新中…）
🚀其他华为OD机试题清单 🔥2023华为OD机试真题(C C++ Java Py JS) B+C+D卷🔥
🔥2023华为OD机试真题(C语言) B+C+D卷🔥
🔥2023华为OD机试真题(Python语言) B+C+D卷🔥
🔥2023华为OD机试真题(Java 语言) B+C+D卷🔥
🔥2023华为OD机试真题(C++语言)B+C+D卷🔥
🔥2023华为OD机试真题(JS 语言) B+C+D卷🔥
🔥2023华为OD机试真题(Golang语言) B+C+D卷🔥
🔥2023华为OD机试真题(C++ Java Python) 🔥
一、什么是华为OD，什么是华为OD机试？ 华为OD是Outsourcing Dispacth模式，是华为和外企德科联合招聘的简称。目前华为大多数是OD招聘。OD模式也是华为提出的一种新的用工形式，每年都会从OD项目挑优秀员工转为正编。所有OD和正式员工一样对待，没有差别，部门平时开会、评审等活动都是一起参加的，是同薪同酬，都是由华为的HR直接定的薪资，看的是我们技术能力。华为是大企业，能到华为上班也是有能力的，每个部门都有好多职位，是金子，在哪都会发光。薪资对华为OD也是有绝对的优势，在互联网一线的大厂中，华为的工作环境和薪资都是很好的，OD其实简单说就是外包，现在有很多公司都在给华为供给外包服务，比如中软，因为华为有很多业务部门，去年一个很熟的猎头给我推荐了几个技术岗位的华为OD都通过了
而华为OD机试是指华为公司的在线笔试，是华为公司用于筛选招聘岗位候选人的一种考核方式，
华为OD机试通常由多个题目组成，包括算法设计、编程、调试等多个环节，考察候选人的基础知识、实际能力和算法编写能力等多个方面，是华为招聘流程中非常重要的一环
二、华为OD面试流程？ 华为OD面试流程一般包括以下几个步骤：
1、笔试：考察候选人的基础知识、算法设计和编程能力等多个方面，题目通常包括算法题、编程题、数据结构题等
2、性格测试(综合测试)：这部分是用来评估候选人的性格特质，以便更好地了解其适应能力、沟通能力和团队合作能力等
3、技术一面：该面试官通常是该项目组的技术负责人，主要考察候选人对技术的理解和实际应用能力。面试内容通常包括代码题和项目问题解决，围绕计算机/编程基础+项目经验+代码能力进行考察，如应届生无项目经验，重点复习八股文+刷算法题
4、HR面：围绕求职动机、稳定性、薪酬期望、Gap经历、延毕等异常情况进行考察
5、终面：终面是在参加完所有面试后进行的最后一轮面试，，主要考察候选人的综合素质和领导潜力；其中，笔试和性格测试是比较常见的部分，而技术一面和群面则比较特殊，通常会根据不同的岗位和项目有所不同，最终的面试结果也会根据个人的表现和竞争情况而定，不会限制通过人数
全流程线上进行，一般机考通过后2-3周内出offer，特殊情况时间过长的话需要积极联系接口人HR
三、华为OD机试通过率高吗？ 据华为官方公布的数据，华为OD机试的通过率约为75%。具体来说，华为OD机试一共有五个级别，从D1到D5，对应13到17级，每个级别的题目数量和难度都有所不同。在过去的招聘中，据说只有25%左右的候选人能够通过第一轮机试。第二轮性格测试也是招聘流程中的重要环节，会刷掉一部分人。不过，华为表示，最终的通过率取决于候选人的实际表现和竞争情况，不会限制通过人数
此外，华为还将机试分为上机考试和在线作业两部分，上机考试主要考察算法设计和编程能力，在线作业主要考察算法思维和解决问题的能力。华为表示，在线作业部分是考察候选人的综合能力，包括解决问题的能力、沟通能力和团队合作能力等。
综合来看，华为OD机试的通过率虽然不是100%，但是也是在高水平范围内的。对于候选人来说，需要全面提升自己的能力，才能更好地通过机试
四、华为OD薪资待遇？ 薪资结构：
1、基本工资+绩效工资+年终奖（2-4个月，一般绩效A-4个月，B-2个月）；
2、D1-D5分别对应华为13-17级，参考范围10-40K；
3、试用期内（6个月）工资不打折，按B绩效发绩效工资，转正时重新评绩效，一般分A、B、C三档（主要A或B，C概率较小），和正式员工分开评，半年评一次；
4、五险一金基数按基本工资，公积金比例5%-12%，具体看base地。
5、福利补贴：带薪年假、入职&amp;年度免费体检、免费夜宵、班车/加班打车免费、下午茶、节假日礼品等
13级薪资：9k-13k
14级薪资：13k-17k
15级薪资：17k-21k
16级薪资：21k-25k
17级薪资：25k-29k
🚀五、怎么刷题？通过华为OD机试？华为OD机试真题刷题列表 🔥2023华为OD机试真题(C C++ Java Py JS) B+C+D卷🔥
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8880d40b30ee2aae0b716b4b69c8c712/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/35/">«</a>
	<span class="pagination__item pagination__item--current">36/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/37/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>