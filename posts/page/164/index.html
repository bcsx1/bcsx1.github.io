<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a76a8627170d78969fe8d49f89a5431/" rel="bookmark">
			重载Overload与重写Override的简洁快速记忆(帮你技巧记忆)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		重载Overload与重写Override： 写在前面：从开始接触重载和重写就有点容易被混淆，尤其是他们的定义。到后面就变成了应用时没有问题，但被问及时定义，偶尔会突然有点犯懵哪个是哪个。。。不知道你们有没有这个困扰，反正我是彻底被恶心到了。。。再次我又多方查找各种解释，给自己总结各种记忆方法，才勉强又挽回了自己徘徊在崩溃边缘的自信心，再次也记录并分享一下！！！！！
一、首先说一下两者的含义： 1、重载(Overload)
在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数 类型不同即可。
记忆技巧：
1). 发生在一个类中，方法名相同，参数列表不同，方法体不同
2). 遵循"编译期绑定"，看参数/引用的类型来绑定方法
2、重写(Override)
在子类中可以根据需要对从父类中继承来的方法进行改造，也称 为方法的重置、覆盖。在程序执行时，子类的方法将覆盖父类的方法。
记忆技巧：
1). 发生在父子类中，方法名称相同，参数列表相同，方法体不同
2). 重写方法被调用时，看对象的类型
3). 重写遵循"两同两小一大"原则
–3.1) 两同:
----3.1.1) 方法名称相同
----3.1.2) 参数列表相同
–3.2) 两小:
----3.2.1) 子类方法的返回值类型小于或等于父类方法的(void和基本数据类型时，必须相同；引用数据类型时，小于或等于)
----3.2.2) 子类方法抛出的异常小于或等于父类方法的
–3.3) 一大:
----3.3.1) 子类方法的访问权限大于或等于父类方法的
二、再说一下两者的区别： 1、概念方面
重载(Overload)发生在一个类中，方法名相同，参数列表不同，方法体不同
重写(Override)发生在父子类中，方法名相同，参数列表相同，方法体不同
2、绑定方法
重载(Overload)遵循"编译期绑定"，看参数/引用的类型来绑定方法
重写(Override)遵循"运行期绑定"，看对象的类型来绑定方法
===========================================================
记忆方法（重点来了）！！！！ 比喻成路上的一辆出租车，这辆车不会变（同一个类），参数就是承载的乘客。如果需要改变乘客（参数改变），就是重载！！！
===========================================================
大神们如果有其他好的方法，也可以分享出来，共同增加记忆
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e939c12e04cd3ffdb58a848ccea25ad/" rel="bookmark">
			【模型部署】yolox模型部署 |ERROR: Could not install packages due to an OSError: [WinError 206] 文件名或扩展名太长。 | 报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目场景： 在学习yolox模型部署时遇到的bug
问题描述 例如：部署yolox模型需要几个包：
其中onnx相关的包我是第一次安装
在安装onnx-simplifier包的时候使用以下指令时出现了报错：
pip install -i https://pypi.douban.com/simple onnx-simplifier 在网上查找原因后，在后面加上–user 依然报错：
pip install -i https://pypi.douban.com/simple onnx-simplifier --user 后面发现 ，人家这里指定了版本号 onnx-simplifier=0.4.10,所以我们这里指定版本号：
pip install -i https://pypi.douban.com/simple onnx-simplifier==0.4.10 --user 这下就不报错了。
接下来生成onnx文件一切顺畅：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7713a215938f174e1d714ac2b2683a62/" rel="bookmark">
			雷达影像信息处理系统SARInfo
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		软件简介
雷达影像信息处理系统SARInfo由中国测绘科学研究院自主研发，是一款专注于单极化/双极化/全极化SAR遥感影像变化检测的软件，具备国内外主流商业SAR卫星从数据预处理到变化检测的全流程处理能力，同时赋有光学影像变化检测以及影像分类能力等，可应用于自然资源调查监测、灾害监测与评估等领域。
软件特点
支持SAR数据源包括：我国的高分三号（GF-3）、海丝一号（HiSea-1）；德国TerraSAR-X；意大利Cosmo-SkyMed；加拿大Radarsat-2；日本ALOS-2；欧空局Sentinel-1。
软件主要功能包括：SLC数据导入导出、影像配准、辐射校正、相干斑滤波、变化检测、影像分类/分割、几何纠正、极化矩阵转化、极化目标分解、双极化/全极化SAR彩色合成、SAR影像自适应降位（32位转8位）等。
基于VC++2017研发，具有友好的人机交互界面，并提供了开源软件PolSARPro的数据接口，提高数据处理的灵活性。
高分3号武汉市江夏区变化检测
Cosmo北京通州区变化检测
Radarsat-2北京大兴机场变化检测
TerraSAR北京鸟巢商圈变化检测
Sentinel-1安徽六安市变化检测
Sentinel-2安徽凤阳县变化检测
下载方式
点击下载链接或微信扫描百度网盘二维码
https://pan.baidu.com/s/1UhBj1W0Kzh0gahQB-g3GEA，提取码：6k5c
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bddbf328402fe0729221b5a6367b2352/" rel="bookmark">
			《ChatGPT是怎样炼成的》
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ChatGPT 在全世界范围内风靡一时，我现在每天都会使用 ChatGPT 帮我回答几个问题，甚至有的时候在一天内我和它对话的时间比和正常人类对话还要多，因为它确实“法力无边，功能强大”。
ChatGPT 可以帮助我解读程序，做翻译，提供思路等等。
所以我就很好奇 ChatGPT 是怎么训练得到的，怀揣着好奇心，我带着大家一探究竟。
当然，ChatGPT 的论文还没有正式发布，想要完美解读它现在是不可能的，不过我们知道 ChatGPT 和 Open AI 的另一项工作 InstructGPT 息息相关。
这是 ChatGPT 官网上面的模型训练过程。
这是 InstructGPT 论文中的模型训练过程。
对比这两张图片，不能说一模一样，只能说完全一致。
所以我们就按照 InstructGPT 的论文讲一讲 ChatGPT 吧。
1. 学习文字接龙🐉 GPT (Generative Pre-trained Transformer) 模型就是在海量的文本数据上学习文字接龙，通过训练掌握基于前文内容生成后续文本的能力。这样的训练不需要人类标注数据（自监督学习），只需要给一段话的上文同时把下文遮住，将 GPT 模型的回答与语料中下文的内容做对比，进行优化。
如上图所示，我们输入“我爱”让 GPT 做文字接龙，绿色柱子的高低理解为输出概率的大小，GPT 的输出最有可能是“你”，当然也可能是“吃”或“玩”。
GPT 的输出通常是通过概率采样得到的。在生成文本时，模型根据前面的文本内容和当前的上下文，计算每个可能的输出单词的概率分布。然后，模型会根据这个概率分布对下一个单词进行采样，得到最终的输出单词。在采样的过程中，模型通常使用一种称为 “softmax” 的函数来转换概率分布，从而确保所有可能的输出单词的概率总和为1。
由于采样的过程是基于随机性的，因此即使提供相同的输入和上下文，模型生成的文本输出也可能会有所不同。使用概率采样可以产生更有趣、更有意思的文本输出。这就可以解释为什么 ChatGPT 对于相同的问题往往会有不一样的答案，当然，概率采样也可能会导致一些质量较低的输出，例如语法错误、重复和不相关的单词。
2. 人类老师的引导👮 只是让 GPT 自己做自监督的文字接龙是有局限性的，因为机器是没有感情的，因为 GPT 不知道什么样的答案是有效的，所以需要人类力量的介入，引导 GPT 生成有用的答案。
首先，我们从问题数据集（prompt dataset）中挑出一些问题。让真正的人类（labeler）给出这些问题的正确答案。这样就形成了有标签的数据集，这些数据用于微调 GPT-3.5，这个过程也称作 supervised fine-tuning (SFT) 3. 模仿人类老师的喜好📊 可是人类的力量也是有限的，我们不可能让人类老师给出所有问题的答案，但是我们可以给 GPT 生成的答案进行评分，这就相对轻松很多了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bddbf328402fe0729221b5a6367b2352/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5616c516f368e177059afeef0006e6e0/" rel="bookmark">
			uniapp电子签名
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;template&gt; &lt;view&gt; &lt;view class="wrapper"&gt; &lt;view class="handBtn"&gt; &lt;image @click="selectColorEvent('black','#1A1A1A')" :src="selectColor === 'black' ? '../static/other/color_black_selected.png' : '../static/other/color_black.png'" :class="[selectColor === 'black' ? 'color_select' : '', 'black-select']"&gt;&lt;/image&gt; &lt;image @click="selectColorEvent('red','#ca262a')" :src="selectColor === 'red' ? '../static/other/color_red_selected.png' : '../static/other/color_red.png'" :class="[selectColor === 'red' ? 'color_select' : '', 'black-select']"&gt;&lt;/image&gt; &lt;button @click="retDraw" class="delBtn"&gt;重写&lt;/button&gt; &lt;button @click="saveCanvasAsImg" class="saveBtn"&gt;保存&lt;/button&gt; &lt;button @click="previewCanvasImg" class="previewBtn"&gt;预览&lt;/button&gt; &lt;button @click="uploadCanvasImg" class="uploadBtn"&gt;上传&lt;/button&gt; &lt;button @click="subCanvas" class="subBtn"&gt;完成&lt;/button&gt; &lt;/view&gt; &lt;view class="handCenter"&gt; &lt;canvas class="handWriting" :disable-scroll="true" @touchstart="uploadScaleStart" @touchmove="uploadScaleMove" @touchend="uploadScaleEnd" canvas-id="handWriting"&gt;&lt;/canvas&gt; &lt;/view&gt; &lt;view class="handRight"&gt; &lt;view class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5616c516f368e177059afeef0006e6e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae1009bfd73c1e6d7044847955321917/" rel="bookmark">
			一个简单的pytorch神经网络训练手写数字识别数据集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		只有七十行代码，可以很方便学习者理解神经网络的整个训练过程。
代码：
import torch import torch.nn as nn import torch.optim as optim from torch.utils.data import DataLoader from torchvision.datasets import MNIST from torchvision.transforms import ToTensor from tqdm import tqdm # Define the neural network class Net(nn.Module): def __init__(self): super(Net, self).__init__() self.fc1 = nn.Linear(28*28, 128) self.fc2 = nn.Linear(128, 10) def forward(self, x): x = x.view(-1, 28*28) x = nn.functional.relu(self.fc1(x)) x = self.fc2(x) return x # Load the data train_data = MNIST(root='./data', train=True, transform=ToTensor(), download=True) test_data = MNIST(root='.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae1009bfd73c1e6d7044847955321917/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8ff3f1184cbb6be7a3c9d0198f3fdb9/" rel="bookmark">
			麒麟V10 误删/卸载系统自带的python3.7，导致yum、dnf命令不可用/无法使用的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1-问题描述
openEuler20.03自带的python3为3.7版本，为了安装3.9版本，参考了一些文章，卸载了3.7版本与相关残余文件。
参考文章截图如下图所示，强烈建议没有遇到问题的小伙伴们不要去尝试！
这个方法可以卸载和系统没什么影响的python3，但是我用这个方法卸载了系统自带的那个。
但是openEuler依赖Python2.7、3.7环境。
结果就是yum、dnf命令不可用，找不到命令。
查看/usr/bin下的yum、dnf，指向的文件均为dnf-3，但是找不到该文件。
2-解决方法
全程使用rpm命令进行安装。
1.安装python3.7
python3-3.7.4-8.oe1.x86_64.rpm
1
检查安装结果
python3 -V
2.安装yum相关包
rpm -ivh --nodeps https://repo.huaweicloud.com/openeuler/openEuler-20.03-LTS/everything/x86_64/Packages/yum-4.2.15-8.oe1.noarch.rpm
rpm -ivh --nodeps https://repo.huaweicloud.com/openeuler/openEuler-20.03-LTS/everything/x86_64/Packages/yum-metadata-parser-1.1.4-24.oe1.x86_64.rpm
rpm -ivh --nodeps https://repo.huaweicloud.com/openeuler/openEuler-20.03-LTS/everything/x86_64/Packages/yum-metadata-parser-help-1.1.4-24.oe1.x86_64.rpm
rpm -ivh --nodeps https://repo.huaweicloud.com/openeuler/openEuler-20.03-LTS/EPOL/x86_64/Packages/yum-langpacks-0.4.5-10.oe1.noarch.rpm
1
2
3
4
3.安装dnf相关包
rpm -ivh https://repo.huaweicloud.com/openeuler/openEuler-20.03-LTS/everything/x86_64/Packages/dnf-4.2.15-8.oe1.noarch.rpm
rpm -ivh https://repo.huaweicloud.com/openeuler/openEuler-20.03-LTS/everything/x86_64/Packages/libdnf-0.37.2-2.oe1.x86_64.rpm
1
2
4.安装python3-dnf
为安装python3-dnf-4.2.15-8.oe1.noarch.rpm，需要先安装一些依赖包，然后再安装python-dnf。
rpm -ivh https://repo.huaweicloud.com/openeuler/openEuler-20.03-LTS/everything/x86_64/Packages/python3-gpgme-1.13.1-5.oe1.x86_64.rpm
rpm -ivh https://repo.huaweicloud.com/openeuler/openEuler-20.03-LTS/everything/x86_64/Packages/python3-rpm-4.15.1-12.oe1.x86_64.rpm
rpm -ivh https://repo.huaweicloud.com/openeuler/openEuler-20.03-LTS/everything/x86_64/Packages/python3-libdnf-0.37.2-2.oe1.x86_64.rpm
rpm -ivh https://repo.huaweicloud.com/openeuler/openEuler-20.03-LTS/everything/x86_64/Packages/python3-libcomps-0.1.8-20.oe1.x86_64.rpm
rpm -ivh https://repo.huaweicloud.com/openeuler/openEuler-20.03-LTS/everything/x86_64/Packages/python3-hawkey-0.37.2-2.oe1.x86_64.rpm
rpm -ivh https://repo.huaweicloud.com/openeuler/openEuler-20.03-LTS/everything/x86_64/Packages/python3-dnf-4.2.15-8.oe1.noarch.rpm
1
2
3
4
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a8ff3f1184cbb6be7a3c9d0198f3fdb9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/420ba165325ae33761ff76f93af8f111/" rel="bookmark">
			维度建模基本流程总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、维度建模基本流程图 数据RD进行业务调研和数据现状调研，产出符合相关模版规范的业务知识文档和数据现状文档。数据PM也会调研相关业务产出需求设计文档，三方参与需求评审，评审通过后基建数据RD进行需求拆解，产出技术方案，三方进行技术方案评审，如果技术方案评审通过进入基建需求池、排期、开发、上线并做相关数据运营动作。
二、维度建模流程详情 详细流程主要介绍每个步骤的参与方、行动详情、产出结果并明确相关的check机制。
2.1 业务调研 关键动作：业务调研主要是业务方、数据PM、数据RD参与，数据RD具体动作如下：
1）理解业务环境，通过和业务方代表交流发现需求，用于理解他们基于关键性能指标、竞争性商业问题、决策制定过程、支持分析需求的目标。
2）梳理业务过程，通过和源系统专家交流信息、业务方的描述信息梳理业务过程，业务过程是一个不可拆分的行为事件。
3）分析关键业务和核心问题，分析关键业务及其动作是什么，明确业务现阶段所关注的核心问题，对核心问题的理解有助于我们覆盖业务场景。
核心成果
业务调研完成后，需要编写业务知识文档，此文档可以按照如下思路整理
1）业务简介，源系统业务简单概述，明确决策过程和分析目标等。
2）统一业务概念，将源数据（即业务系统）中隐含的、有歧义的概念进行清晰化。
3）业务流程介绍，重点关注源系统的ER模型，整理业务流程图，梳理业务基本动作等。
4）总结业务对数据的需求，重点梳理业务指标。
业务调研步骤可重可轻，重：基建层面从质量、效率、成本和扩展性长远考虑需要深入调研并理解。①质量: 通过数据集成和一致性建设，提升数据指标的一致性及及时性；②效率：提升计算、存储、查询效率，提升用户体验；③成本：减少不必要的数据冗余、提升模型复用度，降低存储、计算以及维护开发、降低成本。④扩展：屏蔽业务及上游系统的变更影响，能灵活快速兼容业务变更以及支撑新业务。
轻：根据需求紧急程度，结合原有调研的相关知识，快速支持业务需求。
2.2 数据现状调研 关键动作：数据现状调研主要是数据PM、数据RD参与，关键动作如下：
1）数据PM需要梳理历史定义的数据指标口径，这部分口径解决什么问题（随着时间推移历史指标口径不明确，解释不清等）。
2）从数据RD角度需要梳理之前产出的模型、看板、数据产品，不同的交付方式所对应的模型是否相同，有没有口径不统一的风险。同时将这部分涉及的底表列出来，还没有接入的提前接入。
核心成果
1）数据RD明确指标如何使用：主要是通过表格描述清楚之前的看板和产品使用的模型、模型对应的指标。
2）历史指标及其口径，从数据PM角度需要了解之前定义的数据指标口径，这部分口径解决什么问题。
3）初步给出一些优化改进建议，比如重复逻辑下沉、重复开发优化等。
2.3 主题抽象&amp;总线矩阵 关键动作：主要由数据RD完成，关键动作如下：
1.明确数仓建设的相关分层和命名规范。
2.明确数据域的抽象划分。
3.明确主题、业务过程及其对应关系。
4.明确业务过程和一致性维度关系。
核心成果
产出相关文档，主要包含①主题、词根和主题对应业务过程关系表；②主题和一致性维度矩阵，方便从宏观认识整个数仓；③每个主题下业务过程和一致性维度关系矩阵。
2.4 数据需求设计 关键动作：主要由数据PM完成，关键动作如下：
1）明确背景和业务价值。
2）如果是涉及到产品化的项目需要明确产品或报表工具，设计相关原型图。如果只提供数据集，需要明确指标如何使用，作用的结果。
3）定义清楚维度和指标（偏应用层指标）
4）明确期望交付时间、交付结果，数据回刷范围等。
关键产出就是需求文档（PRD）
需求PRD产出后需要组织业务方、数据RD和PM进行需求评审，主要check 需求评审文档，是否符合既定规范，价值描述清晰、维度和指标口径，数据范围、交付时间等。
2.5 数据需求拆解 关键动作：主要由数据RD完成，关键动作如下：
事实表设计：
1）选择业务过程：选择主题域明确主题下的业务过程，选择具体的业务过程（在主题域内根据情况会抽象新增/合并业务过程）开始拆解。
2）确定事实表，根据需求设计合适的事实表类型，事务事实表、周期快照事实表、累积快照事实表。
3）声明粒度，在从给定的业务过程中获取数据时，原子粒度是最低级别的粒度，建议优先关注原子粒度数据开始设计，原子粒度数据能承受无法预期的用户查询，然后根据针对业务公共问题和性能出发设计上卷汇总粒度数据表。
4）确认维度：维度是度量的环境，用来反映业务的一类属性，这类属性的集合构成一个维度，也可以成为实体对象。在实际工作中好的维度设计可以层次递进的反应业务情况
5）确认事实：事实就是度量，一般是对某个业务事件的衡量，通常为数字，如定单量，订单金额等。尽可能包含业务过程下所有原子指标，只选择和业务过程相关的原子指标，统一同类指标的单位。根据规范对指标拆解：①确定原子指标：基于某一业务时间行为下的度量，是业务定义中不可再拆分的指标（比率等指标除外），具有明确业务含义和业务完整定义的名词。原子指标=业务过程（动作）+度量，比如推单量，下单金额，支付金额；②确定派生指标：派生指标=一个原子指标+多个修饰词（可选）+时间周期。可以理解为对原子指标业务统计范围的圈定。比如昨日新用户下单量
6）梳理具体业务过程下的指标维度矩阵。
维表表设计
1）选择实体
维度表设计首先要选择实体，也就是维度表所要描述的抽象对象。如，互联网电商在交易过程中涉及到的实体有：买家、卖家、订单、广告等等，当然还有一些在不同业务场景下衍生出来的一些业务抽象实体，如优惠券、活动、商圈等都可以作为维度实体。 实体的选择主要是结合业务流程，在需要建模的业务流程环节涉及到了哪些参与者，这些不同的参与者便是维度表描述的实体对象，维度表中的属性，就是用来区分不同实体的特性。
2）确定主维表
确定主维表，主要是识别出维度表的主要数据来源。通常，业务系统中也会将相同类型业务实体进行统一存储（即一张表），亦或是在大型企业有建设业务中台会提前做同类业务实体的数据融合（如，商品中心、用户中心等）。但在没有类似业务中台可以直接获取全量维度实体数据的情况下，就需要自行确定业务实体数据的来源，并做融合。一般情况会将常规主要业务流程中产生的业务系统数据做为主维度表，因为其一般是维度表的主要数据来源，并且数据准确、丰富。
3）确定辅维表
辅维表存在的目的有两方面。一方面是补全主维表在维度实体的数据；另一方面是为了寻找维度表所表示的业务实体的一些其他属性描述辅助表，这些辅维表用来丰富维度表的属性描述，增强维度表的表现性，同样也能扩展维度表的分析能力。
4）识别维度属性
维度表的维度属性一般可以分为相对稳定的“固化属性”和变动频繁“动态属性“。由于“固化属性”和“动态属性”的变更周期差异巨大，一般会在维度表的构建过程中结合具体的场景进行拆分，一方面是保证维度表能够高效的产出，另一方面也是为追溯历史数据提供合理的技术实现。
注意点：增加文字描述（枚举和中文对应关系）；统一单位；统一标志值（0/1，Y/N）等。
关键结果
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/420ba165325ae33761ff76f93af8f111/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b6a434c35250fcb0e3378e3d1ff320e/" rel="bookmark">
			怎么查看服务器的核数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		查看CPU核数 1、cpu信息记录在/proc/cpuinfo中
2、Linux中的Top相当于win系统下的任务管理器，也可以用来查询
3、CPU总核数 = 物理CPU个数 * 每颗物理CPU的核数
4、总逻辑CPU数 = 物理CPU个数 * 每颗物理CPU的核数 * 超线程数
[root@node01 ~]# cat /proc/cpuinfo |grep 'process' |sort |uniq |wc -l 1 命令：lscpu [root@node01 ~]# lscpu Architecture: x86_64 # cpu架构 CPU op-mode(s): 32-bit, 64-bit Byte Order: Little Endian CPU(s): 8 # 总共有8核 On-line CPU(s) list: 0-7 # 序号分别是0,1,2,3,4,5,6,7 Thread(s) per core: 1 # thread就是每个core上的硬件线程数，即超线程， # 每个cpu核，只能支持1个线程. Core(s) per socket: 4 # 主板上插CPU的槽的数量，每个Socket有4个CPU socket(s): 2 # 有2个Socket NUMA 节点： 1 厂商 ID： GenuineIntel CPU 系列： 6 型号： 85 型号名称： Intel Xeon Processor （Skylake，IBRS） 步进： 4 CPU MHz： 2294.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b6a434c35250fcb0e3378e3d1ff320e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cee47f780d9e6e1fcc131a210c59fdcb/" rel="bookmark">
			【数据结构】Java实现栈
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. 概念
2. 栈的使用 3. 自己动手实现栈（使用动态数组实现栈） 1. 创建一个MyStack类
2. push入栈
3. pop出栈
4. 查看栈顶元素
5. 判断栈是否为空与获取栈长
6. toString方法
4. 整体实现
4.1 MyStack类
4.2 Test类
4.3 测试结果
1. 概念 栈：一种特殊的线性表，其 只允许在固定的一端进行插入和删除元素操作 。进行数据插入和删除操作的一端称为栈 顶，另一端称为栈底。栈中的数据元素遵守后进先出LIFO（Last In First Out）的原则。 压栈：栈的插入操作叫做进栈/压栈/入栈，入数据在栈顶。 出栈：栈的删除操作叫做出栈。出数据在栈顶。 2. 栈的使用 public static void main(String[] args) { Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); // 将e入栈，并返回e stack.push(1); stack.push(2); stack.push(3); stack.push(4); stack.push(5); // 将栈顶元素出栈并返回 System.out.println(stack.pop()); // 获取栈顶元素 System.out.println(stack.peek()); // 检测栈是否为空 System.out.println(stack.empty()); // 获取栈中有效元素个数 System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cee47f780d9e6e1fcc131a210c59fdcb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e9a7432fba51209f2e23ba3b19b763e/" rel="bookmark">
			mysql数据库安装及使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、数据库介绍
基本概念
数据库类型
版本演变
二、Mysql安装
官网下载yum安装
手动配置yum安装
三、Mysql基本操作
登录与改密
检测数据库健康
库的创建与使用
数据类型
修饰符
表的创建与使用 分组查询
查询排序及取值
一、数据库介绍 基本概念 ①数据：描述事务的符号记录
②表：将不同的记录组织在一起
③数据库：表的集合
④主键：不能重复，每个表中只能有一个。且不能为空。
⑤唯一键：一个表可以有多个，且可以为空
⑥域：属性的额取值范围，如性别只能是男和女俩个值。
数据库类型 ①关系型数据库：结构是二维数据库表，二维表当中每个字段（列）用来描述对象的一个属性，
每个记录（行）用来描述一个对象的信息（完整信息）表与表之间可能存在联系。
②非关系型数据库：是一种数据结构化存储方法的集合，可以是文档或者键值对等。
版本演变 MySQL：5.1--&gt; 5.5 --&gt; 5.6 --&gt; 5.7 --&gt; 8.0(没有6.0、7.0等)
MariaDB：5.1 --&gt;5.5 --&gt;10.0--&gt; 10.1 --&gt; 10.2 --&gt; 10.3 --&gt; 10.4 --&gt; 10.5(从5.1开始，跳到10.0)
二、Mysql安装 官网下载yum安装 ①由于centos7系统无Mysql的yum源只有MariaDB的，所以需要到官网下载yum源。
②访问官网网址mysql.com，选择DOWNLOADS。
③ 拉到最下面选择MySQL Community(GPL) Downloads&gt;&gt;。
④选择MySQL Yum Repository，进入后选择自己对应的版本下载。
⑤ 下载若提示需要登录点击左下角No thanks，just start my download即可。
⑥下载完成后将文件拖入机器中，然后rpm -ivh 文件名安装后就可以yum install mysql -y安装mysql了。 ⑦补充：以上步骤是安装最新版mysql，若需要安装特定版本则在第三步选择MySQL Community(GPL) Downloads&gt;&gt;后选择右下角的Download Archives,进入后选择MySQL Community Server，根据自己的需求下载对应版本包。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e9a7432fba51209f2e23ba3b19b763e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbb3590655b51833839e6767a42b1e77/" rel="bookmark">
			精通使用postman接口测试工具（全）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Postman是谷歌开发的一款网页调试和接口测试工具，能够发送任何类型的http请求，支持GET/PUT/POST/DELETE等方法。Postman非常简单易用，可以直接填写URL，header，body等就可以发送一个请求，用来测试api接口非常方便。
Postman的优点
使用简单，无需搭建环境，直接使用，可以快速构建请求。
保存以供以后回放使用。
Postman有响应结果的断言功能，可以用来写测试用例。
可以把测试用例放在同一个目录下批量运行管理，可以设置迭代次数。
可以设置环境变量，方便测试环境和生产环境使用同一套测试用例。
调试结果方便查看。
Postman接口测试工具的使用 1.创建文件夹 创建文件夹来保存我们接口请求的数据。
postman创建文件夹
菜单栏介绍：
1）同步请求-同步请求数据到本地
2）分享图标
3）抓包图标-使用Postman抓取API请求和cookie
4）设置图标-应用程序设置
5）通知图标-接收通知或广播
6）账户管理
2.完成get请求和post请求 Get请求：参数在params里设置。
get请求：
Post请求：参数在body里设置。
post请求：
方式一：表单提交，在body中选择x-www-form-urlencoded
等价于application/x-www-from-urlencoded,会将表单内的数据转换为键值对。
方式二：Form-data 传参
就是http请求中的multipart/form-data,它会将表单的数据处理为一条消息，以标签为单元，用分隔符分开。既可以上传键值对，也可以上传文件。
方式三：row传参
可以上传任意格式的文本，可以上传text、json、xml、html等，一般消息主体是序列化的JSON字符串。
设置参数
设置参数可以使用bulk edit模式和Key-value edit模式。
设置参数：
3.导出和导入接口文件 1）文件的导出
4.断言（检查点） Postman添加响应处理，通过检查响应数据是否符合预期来判断用例是否通过。
Postman提供了很多常用断言方式：比如对响应状态码、响应内容等进行断言。
断言（检查点）：
常见断言代码
//判断返回状态码为200
pm.test("Status code is 200", function () {
pm.response.to.have.status(200);
});
//判断返回元素中含有ok
pm.test("Body matches string", function () {
pm.expect(pm.response.text()).to.include("OK");
});
//判断返回json数据中某个键对应的值，Your test name表示这个测试片段的名称，可以自己任意定义；jsonData.value表示响应json串中的某个键，
pm.test("Your test name", function () {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fbb3590655b51833839e6767a42b1e77/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a356a213b93353405a5f75a00bfcc7a/" rel="bookmark">
			postgresql通过explain命令查看查询性能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 PostgreSQL 数据库中，`EXPLAIN` 是查看 SQL 查询性能最基本的方法之一。使用 `EXPLAIN` 命令，我们可以了解 PostgreSQL 中的查询优化器 (query optimizer) 如何处理语句，并为我们提供关于语句执行计划的详细信息。在本文中，我们将介绍如何在 PostgreSQL 中通过 `EXPLAIN` 命令查看查询性能的方法。
基础语法
首先，让我们来看一下基本的 `EXPLAIN` 查询语法：
```sql
EXPLAIN SELECT * FROM table_name WHERE column_name = 'value';
```
以上 SQL 查询语句用于查询名为 `table_name` 的表中满足 `column_name = 'value'` 条件的所有行。我们在该查询前加上 `EXPLAIN` 关键字，即可预计该查询的性能。执行结果将显示查询计划的详细信息，如下所示：
```
QUERY PLAN
------------------------------------------------------
seq scan on table_name (cost=0.00..10.00 rows=1 width=832)
filter: (column_name = 'value'::text)
```
上述输出结果中，`cost` 列显示了该查询花费的预估成本。`rows` 列表示查询返回的行数。此外，我们可以看到该查询使用的扫描方法 (`seq scan`) 以及查询使用的过滤器 (`filter`)。这个例子中，我们使用顺序扫描方法扫描整个表格，但是，如果数据量很大，这样做就会变得非常低效。这时，我们就需要使用更高效的查询方法来优化查询性能。
查询优化
了解查询优化器（query optimizer）是了解 PostgreSQL 查询性能优化的关键。查询优化器会自动决定具体执行每个 SQL 的最优计划，并使用最佳访问方法来访问数据。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a356a213b93353405a5f75a00bfcc7a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d420fc78f41363bb43cc48070e0783e1/" rel="bookmark">
			Thymeleaf 标签学习 之 th:each 的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、使用范围 支持 Iterable、Map、数组、List等
二、结构属性详解 遍历List &lt;div th:each="temp,status :${list}&gt;&lt;/div&gt; ${list}：是后台传过来的要进行遍历的集合temp：${list}中的遍历的对象 【可以随便取名】status：是循环体的信息，通过该变量可以获取如下遍历的状态对象 【可以随便取名】
3-1. status.index → 当前索引，从0开始
3-2. status.count → 当前迭代对象的个数，从1开始
3-3. status.size → 被迭代对象的长度
3-4. status.current → 当前对象
3-5. status.even → 当前索引是否为偶数
3-6. status.odd → 当前索引是否为奇数
3-7. status.first → 当前遍历对象是否是第一个
3-8. status.last → 当前对象是否是最后一个 遍历Map &lt;div th:each=" temp : ${map}"&gt;&lt;/div&gt; getKey() → 获取当前对象的keygetValue() → 获取当前对象的value 二、使用详解 JAVA代码 @GetMapping(value = "/test") public ModelAndView th2(ModelAndView model) { ModelAndView model1 = new ModelAndView("thymeleaf"); // List集合作成 List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d420fc78f41363bb43cc48070e0783e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d032bfe2802b3e252dc28599ac511510/" rel="bookmark">
			前端基于Supermap二次开发上传文件，并存储到SQL Server数据库（涉及文件格式：blob、buffer、blobUrl、base64）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章目录 本篇文章主要介绍从前端上传本地文件，并存储到SQL Server数据库中，同时存储到Supermap工作空间中。如果只想了解存储到SQL Server数据库的部分，一下也会介绍，二者会分开陈述。上传本地文件的方式和类型有很多种，将在前言部分进行详细介绍。
文章目录 系列文章目录前言一、前端Supermap文件上传二、后台存储本地文件至数据库1.前端文件上传2.后台建立 三、后端读取的文件显示总结 前言 如果有做基于Supermap开发，并且涉及文件上传功能可以参考前端Supermap文件上传，这一部分介绍的是上传小型文件（例如jpg、png、pdf等文件），文件大小是kb级的。本人参考官方给出的示例文档并没有找到上传大型文件的方法。虽然Supermap软件的字段类型中有二进制的数据类型，但是小编尝试了base64及blob数据的上传，仍然没有成功。所以选择使用文本型的数据类型存储base64数据（本地文件转化后的数据格式）。超图官方提供的参考链接文件上传。
第二部分讲述从本地上传大型文件到后台服务器，由后端服务器存储至SQL Server数据库。
一、前端Supermap文件上传 原理：在Supermap工作空间中某一数据集中建立一个文本型数据字段，用于存储base64数据（仅限于kb级小型文件）。前端由&lt;input&gt;标签实现本地文件数据上传，其中upload方法在文件上传后立即执行，传入文件为base64格式。
注：网上有一种方法，也是上传本地文件进行存储。他们的方法是将上传得到的base64格式数据转为blob格式，因为blob格式数据可以存储大型文件，这个方法可以用后台存储本地文件至数据库这一部分描述的原理，但是不可以直接套用代码。还有一点，这个方法无法使文件存入Supermap工作空间。
vue文件代码：
&lt;template&gt; &lt;div&gt; &lt;input type="file" accept="image/*" ref="file" @change="upload" multiple/&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { Base64Arr:[] } }, methods:{ upload(){ let dataFiles = this.$refs.file.files; for(let i=0;i&lt;dataFiles.length;i++){ let imgFile = new FileReader(); imgFile.readAsDataURL(dataFiles[i]); imgFile.onload = res =&gt; { this.Base64Arr.push(res.target.result) }; } this.Base64Arr = [] //第二次上传时将数组刷新 // URL.createObjectURL(this.dataURLtoBlob( ))	blob文件转url链接 } } } &lt;/script&gt; 这里我放一个Base64转Blob的代码：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d032bfe2802b3e252dc28599ac511510/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e50be5e6ef161b21d11fb6281cabdca/" rel="bookmark">
			Atcoder Beginner 293 题解 A-E
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Atcoder Beginner 293 题解 A - Swap Odd and Even 注意下标开始的序号
#include&lt;bits/stdc++.h&gt; using namespace std; int main(){ string s; cin&gt;&gt;s; int len=s.length(); for(int i=1;i&lt;=len/2;i++){ swap(s[2*i-2],s[2*i-1]); } cout&lt;&lt;s; } B - Call the ID Number 模拟，可以另设一个数组标记出哪一个人没有被点到
#include&lt;bits/stdc++.h&gt; using namespace std; const int N=2e5+5; int a[N]; bool b[N]; int main(){ int n; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i]; int num=0; for(int i=1;i&lt;=n;i++){ if(b[i]==true) continue; b[a[i]]=true; } for(int i=1;i&lt;=n;i++){ if(b[i]==false) num++; } cout&lt;&lt;num&lt;&lt;endl; for(int i=1;i&lt;=n;i++){ if(b[i]==false) cout&lt;&lt;i&lt;&lt;' '; } } C - Make Takahashi Happy DFS
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e50be5e6ef161b21d11fb6281cabdca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb5f68c0e69e20495ff692eb64fdf44a/" rel="bookmark">
			【免费分享】全球海洋测深DEM（GEBCO）数据集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（本文首发于“水经注GIS”公号，订阅“水经注GIS”公号，为你分享更多GIS技术 ）
1、概述 GEBCO（General Bathymetric Chart of the Oceans）全球 DEM数据集（Geo-Engineering Digital Savage）是基于“全球地球系统计划”（Global Earth System Project）的最新数据集。
GEBCO
数据包括了从格网尺度到流域尺度的全球 DEM数据，覆盖了从海平面变化和海洋地形等，将格网 DEM与高分辨率卫星遥感影像相结合，并进行了全球陆地和海洋区域的划分。
海平面变化和海洋地形
2、数据介绍 该数据集由地球系统科学数据中心（GEBCO）建立。通过 GEBCO平台，可以获得高分辨率海洋 DEM和高分辨率陆地 DEM，以及全球海陆结合的 DEM数据集，可为研究地球系统与全球变化、海洋与大气相互作用等提供有力的科学支持。
GEBCO数据集
本次分享的DEM数据就是由GEBCO提供的2022年覆盖全球范围的包含陆地高程和海洋深度的数据。
GEBCO栅格数据是整合许多国际和国家数据存储库和区域测绘计划的数据集而得到的连续的全球海洋和陆地地形模型，2022年数据是目前最新的测深数据集，数值单位为米，空间分辨率为 15 弧秒,精度相当于500M, 赤道区域实测分辨率450m。
GEBCO栅格数据
GEBCO_2022提供了两个版本的数据，一个是包含陆地和冰面高程信息，另一个版本还包含格陵兰岛和南极洲的冰下地形信息。
以下为数据的详细指标：
坐标投影：GCS_WGS_1984
数据格式：.tif格式
空间分辨率：15 弧秒（约500米）
3、数据下载 官网主要提供了三种不同数据。
三种不同数据
Ice-surface elevation ：存在冰面时，以冰表面为准的高程数据
under-ice topography：存在冰面时，以冰底面为准的地形数据
Type Identifier (TID) Grid：类型标识网格，标识了区域数据获取方式 。
下载格式分别有：netCDF格式、Esri ASCII栅格和数据GeoTiff格式提供全球覆盖。
安装需求选择下载即可。
我们也下载好了这些数据，可以免费分享给大家，现在只需要关注我们的微信公众号“水经注GIS”，并回复“GEBCO”即可获取数据的下载链接。
4、自定义区域下载数据 进入自定义下载页面（https://download.gebco.net/），选择区域可以通过按住Ctrl加鼠标左键来选择区域，也可以通过自定义坐标信息来选择范围，但是选择范围不超过八个分块的面积（每个分块的面积为90 x 90）。
如果你想自己下载全球的数据，可以参考以下坐标范围，还支持JPG和PNG等格式选择，需要的话选择勾上即可，把设置好区域添加下载即可。
GEBCO栅格数据下载
n0.0_s-90.0_w0.0_e90.0；
n0.0_s-90.0_w-90.0_e0.0；
n0.0_s-90.0_w90.0_e180.0；
n0.0_s-90.0_w-180.0_e-90.0；
n90.0_s0.0_w0.0_e90.0；
n90.0_s0.0_w-90.0_e0.0；
n90.0_s0.0_w90.0_e180.0；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb5f68c0e69e20495ff692eb64fdf44a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d424b1d8daff85b17c1be9cb0ba1036/" rel="bookmark">
			Atcoder Beginner Contest 293 题目翻译
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Atcoder Beginner Contest 293 纯纯的自己翻译，有翻译不准确的地方请参考原文
https://atcoder.jp/contests/abc293
A - Swap Odd and Even 给出一个长度为偶数只包含小写英文字母的字符串 S S S， S i S_i Si​为字符串 S S S的第 i i i个字符，对 i = 1 , 2 , ⋯ ∣ S ∣ / 2 i=1,2,\dots ∣S∣/2 i=1,2,⋯∣S∣/2，交换 S 2 i − 1 S_{2i-1} S2i−1​和 S 2 i S_{2i} S2i​，请输出交换后的字符串 S S S
数据范围 字符串的长度在100以内
输入格式 输入一行字符串 s s s
输出格式 输出答案
题目样例 样例输入1 abcdef 样例输出1 badcfe 样例输入2 atcoderbeginnercontest 样例输出2 taocedbrgeniencrnoetts B - Call the ID Number 有 N N N个人，他们的ID分别是从 1 1 1到 N N N，并且每个人手里都有一张卡片 A i A_i Ai​，上面写着另一个人的ID
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d424b1d8daff85b17c1be9cb0ba1036/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f6897b028f92190d20f3ff6afce5409/" rel="bookmark">
			uniapp 使用leaflet加载天地图 app端
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用天地图---appp端 依靠leaflet和uniapp中的renderjs来渲染天地图 1.下载依赖：cnpm i leaflet 2.下载依赖：cnpm i leaflet.chinamsproviders 一.Dom结构: &lt;view&gt; &lt;view class="mapBox" id="mapId" :prop="markerArr" :change:prop="leaflet.updatePsArr" :prop='marker2' :change:prop="leaflet.updatePsArr2" ...&gt;&lt;/view&gt; &lt;view @click="leaflet.emitData"&gt;&lt;/view&gt; &lt;/view&gt; &lt;script&gt; //调接口在普通script中，然后传递给视图层 ... method:{ receiveRenderData(val){ console.log('视图层传递的值',val) } } &lt;/script&gt; &lt;script module="leaflet" lang="renderjs"&gt; //拿到逻辑层接口返回的数据进行渲染 export default{ data(){}, method:{ //dom结构，点击事件触发 emitData(e, ownerVm){ ownerVm.callMethod('receiveRenderData', '视图层传递至逻辑层') }, //renderjs中触发 } } &lt;script&gt; ps: 1.prop绑定的是renderjs所监听的数据 2.change:prop所绑定的是renderjs中的module的属性值+'.'+方法名 renderjs中： updatePsArr(newValue, oldValue, ownerInstance, instance){ console.log('所监听的值',newValue) } 3.视图层(renderjs)传递数据给逻辑层(普通script标签): this_.$ownerInstance.callMethod('逻辑层中的method方法',参数1，参数2...) 二.开始使用leaflet天地图 &lt;template&gt; &lt;view class="leafletMap"&gt; &lt;view class="mapBox" id="mapId" :prop="markerArr" :change:prop="leaflet.updatePsArr"&gt;&lt;/view&gt; &lt;view class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f6897b028f92190d20f3ff6afce5409/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e93c8e6c3c819433182c5ebc5ce6410/" rel="bookmark">
			Apache Commons Math库求解线性规划问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Apache Commons Math 是一个非常流行的 Java 数学库，其中包含了求解线性规划和非线性规划问题的功能。使用 Apache Commons Math 来构建线性规划问题可以分为以下几个步骤：
定义目标函数
在 Apache Commons Math 中，可以通过 LinearObjectiveFunction 类来定义线性规划问题的目标函数。在构造函数中，需要传入一个由变量系数和常数项组成的线性函数。例如，下面这个例子中的目标函数为：2x + 3y - 5。
LinearObjectiveFunction f = newLinearObjectiveFunction(newdouble[]{2, 3}, -5); 定义约束条件
在 Apache Commons Math 中，可以通过 LinearConstraint 类来定义线性规划问题的约束条件。每个约束条件都可以表示为一个由变量系数和常数项组成的线性不等式，例如，下面这个例子中的约束条件为：2x + y &lt;= 10。
LinearConstraint c = newLinearConstraint(newdouble[]{2, 1}, Relationship.LEQ, 10); 其中，Relationship 是一个枚举类型，用于表示不等式的类型，包括 LEQ（小于等于）、GEQ（大于等于）和 EQ（等于）。
可以定义多个约束条件，并将它们放在一个列表中：
List&lt;LinearConstraint&gt; constraints = new ArrayList&lt;&gt;(); constraints.add(new LinearConstraint(newdouble[]{2, 1}, Relationship.LEQ, 10)); constraints.add(new LinearConstraint(newdouble[]{-1, 2}, Relationship.GEQ, 0)); constraints.add(new LinearConstraint(newdouble[]{1, 2}, Relationship.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e93c8e6c3c819433182c5ebc5ce6410/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb8fce45eff0feaebb67ff1a8fbb3591/" rel="bookmark">
			超详细-安装vCenterv Server Appliance 7.0
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
介绍：
第一阶段安装：
第二阶段安装：
最近在玩虚拟化记录下过程~~~~
介绍： VMware vCenterServer 提供了一个可伸缩、可扩展的平台，为 虚拟化管理奠定了基础。 VMware vCenter Server（以前称为 VMware VirtualCenter），可集中管理 VMware vSphere 环境，与其他管理平台相比，极大地提高了 IT 管理员对虚拟环境的控制。
VMware vCenter Server：提高在虚拟基础架构每个级别上的集中控制和可见性，通过主动管理发挥 vSphere 潜能，是一个具有广泛合作伙伴体系支持的可伸缩、可扩展平台。
第一阶段安装： 挂载镜像：选择“install”打开安装程序：选择“安装”： 提示安装分为两个阶段
勾选“我接受许可协议条款”：指定VCSA 7.0部署到ESXi主机：证书：配置VCSA ：选择部署大小：（根据自己需求来。）选择VCSA虚拟机存储：配置VCSA虚拟机网络：确认第一阶段参数： 等一会哦~~~
完成第一阶段部署：（点击继续可以直接进行第二阶段部署） 第二阶段安装： 从第一步中跳转过来的可以忽略1-3步骤
访问：(ESXi中查看点开虚拟机状态可以看到要访问的地址) https:// xxx:5480
输入密码：点击”安装程序”：配置NTP服务器：(根据情况选择)配置SSO参数确认是否加入CEIP（不太愿意参加这种体验计划）确认第二阶段配置继续等待哦~~~~完成部署配置许可证分配许可证完成 刷新后红框处提示消失~~~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad3eb686fd675ef055b9e732c4ea21b0/" rel="bookmark">
			Python函数基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		函数声明、调用、返回基础 Python中使用def关键字来声明函数，声明函数的格式为：
1 2 3 def func_name(args): ...body... [return ...] 有3个需要注意的地方：
函数名后面必须加冒号如果函数体和def不在同一行，则必须缩进return指定函数返回值，用来结束函数 但return语句是可有可无的，如果不给return，则等价于加上了return None，即函数默认返回None结构 如果函数体body语句只有一行，或者可以简写为一行，则可以写在def的同行。例如：
def myfunc(x,y,z): print(x+y+z) 函数声明好之后，就可以执行函数，执行函数也称为调用函数，方式为func_name(args)，例如：
myfunc(1,2,3) 函数中往往会包含一个return或多个return语句，它可以出现在函数中的任意位置处，它用来结束函数的执行，并返回给定的值。例如：
1 2 def func(x): return x+5 表示返回x+5的值，返回值是一种值类型，所以可以赋值给变量、可以输出、可以操作等等。例如：
1 2 3 4 5 6 print(func(3)) # 输出返回值 a=func(4) # 赋值给变量 print(a) print(func(5)+3) # 数值操作 return语句是可选的，如果函数中不指定return语句，则默认返回None，即类似于return None。
关于函数参数 函数的参数其实也是变量，只不过这些变量是独属于函数的本地变量，函数外部无法访问。在函数调用的时候，会将给定的值传递给函数的参数，这实际上是变量赋值的过程。
1 2 3 4 def myfunc(x,y,z): print(x,y,z) myfunc(1,2,3) def首先声明好函数，然后到了myfunc(1,2,3)时，表示调用函数(执行函数)，调用函数时会将给定的值1,2,3传递给函数的参数x,y,z，其实就是变量赋值x=1,y=2,z=3，然后使用print输出它们。
由于python是动态语言，无需先声明变量，也无需指定变量的类型，所以python的函数参数和返回值非常的灵活。任何类型的变量或数据结构都可以传递给参数，这实际上是变量赋值的过程。例如：
1 2 3 myfunc(1,2,3) myfunc("abc",2,"def") myfunc([1,2,3],4,5) 上面几个函数调用语句中，赋值给参数的值可以是数值类型，可以是字符串类型，可以是列表类型，也可以是其它任何数据类型。
python函数的参数相比其它语言要复杂一些，意味着要灵活很多，短短一个小节的篇幅完全没法解释清楚，关于参数细节，详细内容后续再见
函数声明、调用的过程详述 def用来声明一个函数，python的函数包括函数名称、参数、函数体、函数体中涉及到的变量、返回值。
实际上，函数名称其实是一个变量名，def表示将保存在某块内存区域中的函数代码体赋值给函数名变量。例如：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad3eb686fd675ef055b9e732c4ea21b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07bbca01861dc158215ade07825ef4e4/" rel="bookmark">
			如何将Findshell连接上
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 FinalShell连接虚拟机（Ubuntu）（csdn） 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab5a14ee5993af25b53a6dba26c4ab1c/" rel="bookmark">
			Python Matplotlib数据可视化绘图之（四）————柱状图与折线图的叠加图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、所用到的模块二、柱状图与折线图的叠加图的绘制1.示例数据如下2.代码如下2.1 代码如下（示例）：2.1.1 Case1： 2.2 我们可以看到，在上述作图过程中，我们把画布(fig)背景色设置为#B0C4DE，把轴域(ax)背景色或者称为绘图区域背景色设置为white(纯白色)，以上图片都是我截图保存下来的，所以能够保持我们对fig和ax的背景色的设置，但是如果我们想用plt.savefig()语句把图片保存到本地，且仍然保留我们对fig和ax的背景色的设置的话，需要使用以下语句参数，如下所示： 三、总结 前言 本文我们主要介绍利用Python中的Matplotlib模块进行柱状图与折线图的叠加图的画法。
一、所用到的模块 主要利用Python中的Matplotlib模块完成该功能。
二、柱状图与折线图的叠加图的绘制 1.示例数据如下 2020年、2021和2022年每种语言的用户量情况，数据如下表所示（示例）：
语言种类2020年用户量人数2021年用户量人数2022年用户量人数C200030005000C++300040006000Python3000600010000Java500040006000Java Script200040003000PHP100020002000Ruby80010001000 现在需要把表格中的数据绘制成柱状图和折线图的叠加图，从而进一步分析各类语言的用户的使用情况。
2.代码如下 2.1 代码如下（示例）： 2.1.1 Case1： 代码如下： import matplotlib import matplotlib.pyplot as plt import numpy as np # 设置字体, 解决中文乱码问题 plt.rcParams['font.sans-serif'] = ['Microsoft YaHei'] # 解决图像中的'-'负号的乱码问题 plt.rcParams['axes.unicode_minus'] = False x_labels = ['C', 'C++', 'Python', 'Java', 'Java Script', 'PHP', 'Ruby'] y_2020 = [2000, 3000, 3000, 5000, 2000, 1000, 800] y_2021 = [3000, 4000, 6000, 4000, 4000, 2000, 1000] y_2022 = [5000, 6000, 10000, 6000, 3000, 2000, 1000] y_middle = [] for i in range(len(y_2020)): y_middle.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab5a14ee5993af25b53a6dba26c4ab1c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43eb6ff49c9f1f4fc4e2b00fc7fbe90c/" rel="bookmark">
			JavaScriptAPI
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		知识点一 一、API的概念二、获取元素通过Id名获取元素通过类名获取元素通过标签名获取元素通过name名获取通过querySelector()获取通过querySelector()获取 一、API的概念 APT预先定义好的函数
二、获取元素 通过Id名获取元素 // html代码 &lt;header id="header" class="head"&gt;头部标签&lt;/header&gt; // script代码 var header = document.getElementById("header"); console.log(header); 通过类名获取元素 // html代码 &lt;header id="header" class="head"&gt;头部标签&lt;/header&gt; &lt;section class="head"&gt;区间标签&lt;/section&gt; &lt;article class="head"&gt;文章标签&lt;/article&gt; //js代码 var head = document.getElementsByClassName("head"); console.log(head); console.log(head[0]); console.log(head[1]); 通过标签名获取元素 // html代码 &lt;article class="head"&gt;文章标签&lt;/article&gt; //js代码 var article = document.getElementsByName("article"); console.log(article); 通过name名获取 // html代 &lt;input type="text" name="abc" /&gt; //js代码 console.log(document.getElementsByName("abc")[1]); 通过querySelector()获取 // html代码 &lt;header id="header" class="head"&gt;头部标签&lt;/header&gt; &lt;section class="head"&gt;区间标签&lt;/section&gt; &lt;article class="head"&gt;文章标签&lt;/article&gt; &lt;article class="head"&gt;文章&lt;/article&gt; //js代码 var head_1 = document.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43eb6ff49c9f1f4fc4e2b00fc7fbe90c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5816e6ff1ec9c638364ddda2b9a7311f/" rel="bookmark">
			开发板ifconfig时，没有wlan0
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：开发板起来后，输入ifconfig指令时，只能看到eth0和lo，没看到wlan0；
原因：没有挂载wifi驱动模块；
具体操作如下：
输入lsmod指令，查看是否有挂载wifi模块；
输入insmod wlan.ko 挂载wifi模块；（wlan.ko为wifi驱动模块文件）
输入ifconfig wlan0 up 打开wifi功能；
输入iwlist wlan0 scan 显示搜索到的wifi;
补充：rmmod wlan 下载模块
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b1afd5bc8464d68f160fc840ed4a3eb/" rel="bookmark">
			自动驾驶数据闭环系列之二——如何降本增效
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		交流群 | 进“传感器群/滑板底盘群/汽车基础软件群/域控制器群”请扫描文末二维码，添加九章小助手，务必备注交流群名称 + 真实姓名 + 公司 + 职位（不备注无法通过好友验证）
作者 | 张萌宇
自动驾驶数据闭环的原理和框架早已不是秘密，但是数据闭环在量产车上的落地仍然是一个难题。如何打造一套好的数据闭环系统，尽可能高效、低成本地用数据驱动的方式促进自动驾驶系统能力的提升成了大家关心的问题。
1. 如何提高数据闭环的效率
那么，如何提高数据闭环的效率？笔者在与各位行业专家交流后，按照数据闭环的流程，总结了以下几点。
1.1 优化车端数据采集的逻辑
工程师可以根据模型失效分析以及模型决策边界分析，提前设定要采集的场景并制定采集逻辑，然后，在车端设置trigger层——数据回传触发器，再根据场景算法检测，自动化获取所需要的场景数据集。
在设计车端trigger层的时候，要尽量提高准确率和召回率——既要防止无价值的数据被回传，又要防止有价值的数据被漏掉。
为了提高准确率和召回率，工程师在新开发筛选逻辑时，需要先用之前采集的数据做一些验证。例如，工程师可以查看按照新开发的筛选逻辑，哪些数据会被筛选出来、哪些不会，另外也可以看筛选出来的数据是否符合预期，以及没有被筛选出来的数据中有没有系统需要的部分。假如筛选逻辑的效果符合预期，再将该筛选逻辑部署到车端。
另外，工程师在车端设置trigger层的时候，要考虑到单车的4/5G 带宽以及流量问题，可以将不同的trigger按照重要程度分成不同的组，按照事件的优先程度回传数据，尽量保证多传重要程度高的数据，例如可以优先回传稀缺场景的数据。
1.2 保证车端数据传输链路的通畅
在车端采集数据的时候，车内需要有高效的数据传输链路，来保证数据传输的速度及容量，假如只能通过传统的CAN传输，那么能传输的数据量就会非常有限。此外车端还需要配备4/5G模块，方便数据上传到云端。
目前，市面上量产的很多车型基本具备了批量回传数据的能力，尤其是高端车型。而一些中低端车型，在解决好了网络问题后也可以批量回传数据。
1.3 提高将数据场景化的能力
要从海量数据中提取真正有用的数据，需要把数据场景化。
有自动驾驶公司在关于数据闭环的文稿中提到：“场景是数据需求的基本单位，场景化是数据打通的中枢环节，足够强的场景提取能力，是一家自动驾驶公司的重要技术壁垒。”
何为场景？场景就是构成汽车驾驶环境的独立变量的随机组合，不同的场景组合在一起，就成了场景库。有业内专家将场景库比作考生的“题库”，题库越丰富，考生做过的题越多，在考试中得到高分的概率越高。相应地，场景库越丰富，自动驾驶系统能通过的场景越多，那么它在真实世界中的表现可能就会越好。
一般来说，场景库里的场景可以根据odd——即自动驾驶运行设计域来划分，odd主要包括时空、道路、道路参与者三部分。场景标签主要包括时间、天气、能见度、城市、道路等级、道路状况、交通流等，例如，“一辆车在雨天的傍晚行驶在高速公路上”就可以是一个场景。在此基础上，每一个场景标签还可以进一步细分，例如雨天还可以分为大雨、中雨、小雨等，细分程度取决于实际需求。所以说，场景库基本是无限的。
一个场景标签可以从多段数据中提取，例如很多数据可能都是在下雨天气下采集的；同一段数据也可以出现在多种场景中，此间的对应关系取决于工程师如何定义场景。
也即是说，如何给数据打标签从而映射到场景库里的一个个场景，每个场景的标签要细分到什么程度都是可调的，从某种意义上来讲，这是公司将数据场景化的能力之一。因为一个高质量的场景库离不开科学合理的分类，只有将场景科学合理地分类才能在增加场景库丰富度的同时不过分增加冗余度。
目前，市面上有部分公开的场景库可供从业者使用，这些公开的场景库有相对标准地将数据映射到场景的方式。当然了，自动驾驶公司一般也会根据需求建立自己的场景库或者在公开场景库的基础上添加数据来进一步丰富场景库。
在需要丰富场景库的时候，工程师们可以根据时间、天气、道路状况、交通流等条件来做组合，对于目前的场景库里欠缺的场景，设置相应的采集条件来采集包含这些场景的数据。
具体来讲，假如工程师希望尽可能多地采集早高峰时交通拥堵的数据，那他可以把采集时间设置在上午8点至10点；假如希望尽可能多地采集某个特定地点的数据，那他可以根据地图，把相应地点做好标记，在车辆经过这个地方的时候触发数据采集。后续希望采集其他场景的时候，工程师直接在配置文件里修改采集条件即可。
当然了，这种采集方式，主要适合一些相对简单的场景，或者是说比较容易枚举的场景。
那些更复杂的，不太容易枚举的场景，使用模型来采集可能是更合适的方式。比较常见的使用模型采集的方式就是我们常说的影子模式。
实际上，使用模型来采集数据并不局限于影子模式，也可以是用当前的模型版本和前一模型版本的比较，或者采集条件不基于一些很简单的规则叠加，而是基于更加复杂的神经网络模型，这样收集来的数据可能跟已有的数据有更大的差异性。
某新能源主机厂专家告诉笔者，“长期来看，我认为比较好的采集数据的方式是在云端训练出一个模型，这个模型可以比较好地判断哪些数据对当前的自动驾驶系统是有价值的。然后，我们可以在车端部署这个模型的简化版本，这个简化版的模型负责筛选需要上传到云端的数据。
“假如我们基于规则来筛选，就需要把规则设置成可配置的。因为基于特定的规则来筛选数据时，一个规则用的时间越长，基于这个规则筛选出来的数据的价值就会越低。那么，我们就需要一直更改筛选规则，更改规则是越往后越难的，因为容易枚举的场景会越来越少。
“以后更好的方式大概率不是一直更改规则，而是用模型来判断什么是有价值的数据，然后根据已经积累的数据不断更新模型。”
1.4 灵活更新筛选逻辑
在车端更新数据筛选逻辑时，当前主流的方式是OTA和筛选逻辑配置文件下发相结合。一般来说，筛选逻辑配置文件下发适合较小的筛选逻辑改变，OTA适合较大的筛选逻辑改变，具体采用哪种方式要结合实际情况分析。
魔视智能产品经理苏林飞介绍到：“在国内，按照工信部装备中心[2022]229号文件要求，汽车生产企业OTA需要提前向工信部报备。几乎所有OEM的量产车的OTA流程都很繁琐，首先在OTA前企业的研发部门需要向质量部门汇报发起OTA的缘由，然后提交完整的测试和验证报告给质量部门，质量部门拿到OTA需求输入后，内部开启ECR确定流程，明确变更的合理性，之后下发ECN。上述步骤完成后再开启工信部流程，最后完成OTA。
“因此，汽车OTA频率比较低。涉及到ADAS系统的OTA一般是以季度或者半年度为单位评估更新，极少数主机厂会月度更新。”
针对这一痛点，智协慧同销售副总裁牛国浩称：“我们可以提供一套不需要通过OTA，直接使用传统的车联网通道来更新的数据采集机制，这套机制支持用户把算子化的触发数据采集的逻辑部署在车端。采用这套触发机制的用户可以以天为单位甚至是以小时为单位来更新数据采集逻辑。”
灵活更新数据采集逻辑有什么好处呢？
假如某OEM有10万辆量产车，他们在这些车上都部署了采集急刹车数据的逻辑，那么，只要急刹车逻辑被触发，相关数据都会被回传到云端。不过，实际上，由于OEM来不及更新触发逻辑，尽管采集到的急刹车数据很多，但真正对算法改进有帮助的也许只有前100条，之后的急刹车数据可能都没有新增信息；但如果采集逻辑的更新频率大幅度提升，则数据的有效率会大幅度提升。
1.5 标注自动化，且标注模型不断进化
尽量提高数据闭环整个流程中的自动化比例，降低人工参与度，是提高效率的一个重要方式。尤其是标注环节，自动化可以带来很大的效率提升，同时也可以降低人员管理的难度。
目前，很多自动驾驶公司都在开发自动标注系统。自动标注系统标注好数据后，人基本只需要做质检工作——即检验自动标注系统的工作质量，例如目标物体有没有做好标记、标记的范围是否准确等。在质检阶段，一些自动化的质检算法也可以作为辅助从而减少人的工作量。
有了自动标注系统，对于大部分通用场景来说，标注工作产出成果的主要决定因素从人力资源转到了计算资源和模型精度，计算资源可以很方便地在云端拓展，因此，标注效率可以实现极大的提升。
很多公司采用场景重建的结果来实现自动标注。那么，如何基于场景重建的结果完成标注任务呢？ 以 BEV的静态感知标注为例，假设有一辆车，在一个路口右转了一次，另外一辆车在路口直行了一次，还有一辆车反方向直行一次，那么我们把这些信息聚合起来，就可以重建出关于这个路口的基本完整的场景。
有了完整的场景后，当需要标注经过这个路口的车辆的相关数据时，可以拿需要标注的图像信息和重建好的场景信息匹配，从而实现对图像的标注。哪个是真值啊？重建好的场景 ？
类似的，BEV下的高度、光流、三维检测等，都可以通过同样的全息场景重建的方式来提取真值。
除了静态环境的重建，我们还可以进行动态场景重建，或面向动态的感知结果，根据这些结果拼成一个完整的、全息的4D世界信息，来给云端感知模型使用。
魔视智能产品经理苏林飞介绍到：“ 一些比较容易识别的物体——例如车辆、正常行走的行人等，模型可以识别出来，人只需要做一些质检工作，把自动标注系统没有识别出来的物体手工标记好，同时修正系统识别错误的物体。
“引进自动标注系统后，标注的工作量大致可以降低80%。随着自动化标注工具的进步，标注效率有望进一步提升。”
然而，也有数据标注服务供应商表示，在单一企业的特定任务中，假如已经把用于标注的模型训练地很好，那这个模型确实可以帮助我们实现很高比例的预标注——大概80%。但是，在面临新的任务时，原先训练好的模型可能不再适用，我们需要重新依赖人工标注——80%的预标注并不是一个普适性的比例，即使我们将语境限定在自动驾驶的任务中。
在实操中，假如传感器安装的位置改变，可能就会影响数据的识别，预标注的效果会相应降低。假如我们能够做出更通用的预标注模型，在面临不同场景时都能做到较高的预标注程度，而不是每当场景改变时都需要适配，那么标注工作的效率将能大大提高。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b1afd5bc8464d68f160fc840ed4a3eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83797b38fc8160073541171515c2f06a/" rel="bookmark">
			BFS算法（Java）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述
迷宫由 n 行 m 列的单元格组成，每个单元格要么是空地，要么是障碍物。其中1表示空地，可以走通，2表示障碍物。给定起点坐标startx,starty以及终点坐标endx，endy。现请你找到一条从起点到终点的最短路径长度。
输入
第一行包含两个整数n,m（1&lt;=n,m&lt;=1000）。接下来 n 行，每行包含m个整数（值1或2），用于表示这个二维迷宫。接下来一行包含四个整数startx，starty，endx，endy，分别表示起点坐标和终点坐标。
输出
如果可以从给定的起点到终点，输出最短路径长度，否则输出-1。
测试数据
输入
5 4
1 1 2 1
1 1 1 1
1 1 2 1
1 2 1 1
1 1 1 2
输出
7
import java.util.Queue; import java.util.Scanner; import java.util.LinkedList; class point { int x,y,step; public point(int x,int y,int step){ this.x=x; this.y=y; this.step=step; } } public class Bfs { static int[][] a=new int[50][30];//地图 static int[][] b=new int[50][30]; static int[][] t= {{ 1, 0 }, { 0, 1 }, { -1, 0 }, { 0, -1 }}; static int startx,starty,endsx,endsy; public static void bfs(int x,int y,int step) { point p=new point(x,y,step); LinkedList&lt;point&gt; q=new LinkedList&lt;point&gt;(); q.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/83797b38fc8160073541171515c2f06a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a82913a24ab7f6ff8f66057f40fe65e4/" rel="bookmark">
			python中datetime不同时区转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 概念 GMT时间：Greenwich Mean Time， 格林尼治平均时间
UTC时间：Universal Time Coordinated 世界协调时，可以认为是更精准的GMT时间，但两者误差极小，在1s以内，一般可视为等同
LMT：Local Mean Time, 当地标准时间
可能存在的问题 在使用datetime获取当前时间时，可能会根据计算机或系统环境不同产生区别，最好使用统一的时间戳或规定时区的方式。
比如当前系统默认东八区的当地时间，那么获取datetime.now()时返回的日期时间可能是2023-03-22 01:00:00， 对于本地而言是3月22日，但如果换一台服务器，datetime.now()时返回的日期时间可能是UTC时间， 那就是2023-03-21 17:00:00，此时日期会变成3月21日.
时间格式转换 # 当前时间戳 time_now = time.time() &gt;&gt;1679461972.1435885 # 时间戳转为datetime。规定时区-东八区 time_local = datetime.datetime.fromtimestamp(time_now, tz=pytz.timezone('Etc/GMT-8')) &gt;&gt;2023-03-22 13:12:52.143589+08:00 # 时间戳转字符串 time_str = time_local.strftime('%Y%m%d') &gt;&gt;'20230322' # 获取当前日期0时0分 today = datetime.datetime.strptime(time_str, '%Y%m%d') &gt;&gt;2023-03-22 00:00:00 # 获取当前日期0时0分。规定时区-东八区 today = datetime.datetime.strptime(time_str, '%Y%m%d').astimezone(pytz.timezone('Etc/GMT-8')) &gt;&gt;2023-03-22 00:00:00+08:00 # 获取统一的时间戳（单位为秒） today.timestamp() &gt;&gt;1679414400.0 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2970163098c4d83e5f480997c4a2c903/" rel="bookmark">
			VUE进行前后端交互
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、 跨域
1. 什么是跨域？
2. 什么是本域？
3. 浏览器请求的三种报错
二、SpringBoot解决跨域问题+其他前后端跨域请求解决方案
1. SpringBoot上直接添加@CrossOrigin
2. 处理跨域请求的Configuration
3. 采用过滤器的方式
3.1 方式一
3.2 方式二
4. 其他解决方案---NGINX反向代理
三、VUE的前后端交互
1. 前后端交互模式
1.1 传统的交互方式
1.2 传统的URL
1.3RESTFUL风格的URL
2. Promise相关概念与使用
2.1 promise使用的优势
2.2 promise的基本用法
2.3 then参数的函数返回值
2.4 Promise常用API
2.5 Fetch接口调用
2.5.1 fetch的基本语法
2.5.2 fetch请求参数
2.6 Axios进行接口调用
2.6.1 axios基本用法
2.6.2 axios常用API
2.7 asyns/await接口调用
2.7.1 async/await的基本用法
参考文章：(8条消息) 三、vue前后端交互（轻松入门vue）_vue如何和后端交互_莫逸风的博客-CSDN博客
一、 跨域 1. 什么是跨域？ 在了解什么是跨域的时候，我们首先要了解一个概念，叫同源策略，什么是同源策略呢，就是我们的浏览器出于安全考虑，只允许与本域下的接口交互。不同源的客户端脚本在没有明确授权的情况下，不能读写对方的资源。
2. 什么是本域？ 本域指的是同协议、同端口、同域名
3. 浏览器请求的三种报错 ① 请求未发送
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2970163098c4d83e5f480997c4a2c903/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7dc35788a792817a51fc3b376270f6a4/" rel="bookmark">
			ECC椭圆曲线密码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		密码学中的椭圆曲线 密码学中普遍采用的是有限域上的椭圆曲线。
设GF(p)表示阶为p的有限域，p通常是一个大素数。定义标准椭圆曲线为E:，其中,且满足，这类椭圆曲线通常用(a,b)表示。群G是定义在E上，阶数为q，生成元为P且包含一个无穷远点O的可加性椭圆曲线群。群G具有如下性质：
点加：设P，Q是群G上的两点，且P≠Q，若R=P+Q，则R是P，Q两点的连线与椭圆曲线的交点；若P=Q，则R=2P，R是P（Q）点处的切线与椭圆曲线的交点。若P=-Q，则P+Q=O。
标量乘法：对于且m&gt;0，E上的标量乘法定义为mQ=Q+Q+...+Q
椭圆曲线离散对数问题（ECDLP）:
对于，存在椭圆曲线上的一点Q，满足Q=x·P，已知Q和P，求x是困难的。
ECC密钥生成算法 以Alice为例，生成其公私钥对。步骤如下：
选择一个椭圆曲线：，构造椭圆曲线群(a,b)
在(a,b)中挑选生成元点，P应使得满足nP=O的最小的n是一个非常大的素数
选择一个小于n的整数作为其私钥，则公钥
椭圆曲线公钥加密体制 密钥生成算法
公钥
E：椭圆曲线群 n：非常大的素数 P：生成元
私钥
s
加密算法
随机选择k， m：明文消息的编码
加密数据：
解密算法
明文：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da0d3333acf00b072e08bd501408867b/" rel="bookmark">
			5分钟带你了解音视频开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 想赚钱，第一点就得选对自己的方向，有的行业和领域，无论你如何努力，天花板也不过如此。选对时代的风口，就算是头猪都能被吹上天，今天我们就来聊聊音视频开发。
蓬勃发展的音视频开发 时至今日，短视频App可谓是如日中天，一片兴兴向荣。随着短视频的兴起，音视频开发也越来越受到重视，但是由于音视频开发涉及知识面比较广，入门门槛相对较高，让许许多多开发者望而生畏。接下来我介绍一下音视频开发的基础部分，帮助大家学习。
一. 颜色模式 RGB RGB颜色模型的主要目的是在电子系统中检测，表示和显示图像，比如电视和计算机，但是在传统摄影中也有应用。
RGB
基础的部分不过多描述，更多内容点击标题见维基百科。
YUV Y’UV的发明是由于彩色电视与黑白电视的过渡时期。黑白视频只有Y（Luma，Luminance）视频，也就是灰阶值。到了彩色电视规格的制定，是以YUV/YIQ的格式来处理彩色电视图像，把UV视作表示彩度的C（Chrominance或Chroma），如果忽略C信号，那么剩下的Y（Luma）信号就跟之前的黑白电视频号相同，这样一来便解决彩色电视机与黑白电视机的兼容问题。Y’UV最大的优点在于只需占用极少的带宽，因为人眼对亮度敏感，对色度不敏感，因此减少部分UV的数据量，但人眼感知不到。
YUV也称为YCbCr，对于每个分量如下：
Y：Luminance, 亮度，也就是灰度值。除了表示亮度信号外，还含有较多的绿色通道量。U：Cb，蓝色通道与亮度的差值。V：Cr，红色通道与亮度的差值。 如下图，可以看到3个分量的效果差值。
YUV示例图
RGB与YUV转换公式 (RGB取值范围均为0~255)
Y=0.299R＋0.587G＋0.114B ⁄ R=Y＋1.14VU=－0.147R－0.289G＋0.436B ⁄ G=Y－0.39U－0.58VV=0.615R－0.515G－0.100B ⁄ B=Y＋2.03U HSV 色调H: 用角度度量，取值范围为0°～360°，从红色开始按逆时针方向计算，红色为0°，绿色为120°,蓝色为240°。它们的补色是：黄色为60°，青色为180°,品红为300°；
饱和度S: 饱和度S表示颜色接近光谱色的程度。一种颜色，可以看成是某种光谱色与白色混合的结果。其中光谱色所占的比例愈大，颜色接近光谱色的程度就愈高，颜色的饱和度也就愈高。饱和度高，颜色则深而艳。光谱色的白光成分为0，饱和度达到最高。通常取值范围为0%～100%，值越大，颜色越饱和。
明度V: 明度表示颜色明亮的程度，对于光源色，明度值与发光体的光亮度有关；对于物体色，此值和物体的透射比或反射比有关。通常取值范围为0%（黑）到100%（白）。
hsv_1.png
hsv_2.png
RGB和CMY颜色模型都是面向硬件的，而HSV（Hue Saturation Value）颜色模型是面向用户的。
HSV模型的三维表示从RGB立方体演化而来。设想从RGB沿立方体对角线的白色顶点向黑色顶点观察，就可以看到立方体的六边形外形。六边形边界表示色彩，水平轴表示纯度，明度沿垂直轴测量。
HSV在做颜色检测方面比较常用，可以参考文章HSV颜色检测。
二. 视频基础概念 帧(Frame) 简单的理解帧就是为视频或者动画中的每一张画面，而视频和动画特效就是由无数张画面组合而成，每一张画面都是一帧。
帧数(Frames) 帧数其实就是为帧生成数量的简称，可以解释为静止画面的数量
帧率(Frame Rate) 帧率(Frame rate) = 帧数(Frames)/时间(Time)，单位为帧每秒(f/s, frames per second, fps)。
刷新率 屏幕每秒画面被刷新的次数，分为垂直刷新率和水平刷新率，一般我们提到的都是指垂直刷新率，以赫兹(Hz)为单位，刷新率越高，图像就越稳定，图像显示就越自然清晰。
目前， 大多数显示器根据其设定按 30Hz、 60Hz、 120Hz 或者 144Hz 的频率进行刷新。 而其中最常见的刷新频率是 60 Hz。 这样做是为了继承以前电视机刷新频率为 60Hz 的设定。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da0d3333acf00b072e08bd501408867b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f22008372f8964eefa234d7af7d3706/" rel="bookmark">
			leetcode 1631. Path With Minimum Effort（最小消耗路径）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从(0, 0) 到 矩阵右下角 找出一条最短路径，
注意路径的cost不是数字的和，而是这条路径上每两个相邻点的差有个绝对值，路径的cost定义为这些差的绝对值中最大的。每个路径对应一个cost。
在所有路径中找出cost最小的。返回cost。
思路：
我们知道最短路径算法有Dijkstra算法，
dist[v]表示从起点(0, 0)到点v的距离，cost(u, v)表示点u到点v的距离。
如果途中经过u点，那么dist[v] = dist[u] + cost(u, v)
Dijkstra算法是这么个流程：
dist数组初始化为最大值。
从起点(0, 0)出发，计算从(0,0)点到与它相连的所有点的距离，
如果(0, 0)到点v的距离cost[v] &lt; dist[v]，那么更新dist[v] = cost[v]
并把(v, dist[v])装入优先队列。
下次从优先队列中取出dist最小的，再从取出的点出发，重复上面的过程，直到优先队列中没有点。
思想就是每次取出从起点到现在路径最短的点，以这个点为中转点，计算它到下一个点的距离，并更新最小距离。
当然上面的算法基于的距离是边的权重，那我们这里如何定义边的权重呢，
假如现在从u点出发，那么与它连接（有边）的点 v 就是它的上下左右四个点，
边的权重就是两个点的height差的绝对值，记为cost。
因为路径的COST是每步cost（差的绝对值）中最大的那个，所以只需要把cost和dist[u]相比，取较大的那个，
也就是cost[v] = max(dist[u], cost),
但是假如计算出来的cost[v]比之前保存的dist[v]大，也就是说当前不是最优路径，那么直接丢弃，不再保存到优先队列，也不更新dis[v]。
如果是最优路径，cost[v] &lt; dist[v], 那么更新dist[v] = cost[v],
并把(v, dist[v])存入优先队列。
下次从优先队列中取出dist最小的，重复上面的过程，直到优先队列中不再有值。
*注意这里的cost是计算整个路径COST时其中的一步，而整个路径COST是所有这些cost中最大的。
计算每条路径COST时取cost最大，最后从众多路径中选择的时候取COST最小。
public int minimumEffortPath(int[][] heights) { int[] move = new int[]{-1, 0, 1, 0, -1}; int rows = heights.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f22008372f8964eefa234d7af7d3706/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd6ba4a19597892bfa6e40942e40c7d4/" rel="bookmark">
			使用uni.saveFile，找不到路径
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 需求：下载网络图片到系统相册
问题：找不到uni.saveFile保存的临时路径
解决：使用 uni.saveImageToPhotosAlbum 将临时文件保存到本地
#注意：官方文档，由于其不支持网络图片路径，所以在使用前还是需要调用downloadFile来生成文件的临时路径
uni.downloadFile({//下载 url: //网络图片资源路径, success(res) { if (res.statusCode == 200) { success(saveRes) { uni.saveImageToPhotosAlbum({//保存 filePath: res.tempFilePath, success(saveImgRes) { // 手机会自动保存到系统相册，电脑可以自己选择保存的地址 uni.showToast({ title: '以保存至系统相册' }) } }); }, } } }) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81e245f028d21db7befb9d166f53bd7f/" rel="bookmark">
			Spring Security 用户认证的方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 Spring Security 中，用户认证的方式有多种，包括基于内存、基于数据库、LDAP 认证等。
在实际开发中，我们可以根据自己的业务需要选择合适的用户认证方式。
基于内存认证（基于内存的认证方式适用于用户数量较少，且用户信息不经常变动的场景） 在Spring Security中，我们可以通过配置一个实现了UserDetailsService接口的类来实现基于内存的用户认证。UserDetailsService接口提供了一个方法loadUserByUsername(String username)，该方法返回一个UserDetails对象，Spring Security会根据该对象中的用户名、密码和权限信息来完成认证。
@Override protected void configure(HttpSecurity http) throws Exception { http.authorizeRequests() .antMatchers("/admin/**").hasRole("ADMIN") .antMatchers("/user/**").hasAnyRole("ADMIN", "USER") .antMatchers("/").permitAll() .and().formLogin(); } } @Configuration @EnableWebSecurity public class SecurityConfig extends WebSecurityConfigurerAdapter { @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { auth.inMemoryAuthentication() .withUser("admin").password("{noop}admin").roles("ADMIN") .and() .withUser("user").password("{noop}user").roles("USER"); } 这段代码是一个实现了基于内存用户认证的方法，在 Spring Security 的配置类中重写了 configure(AuthenticationManagerBuilder auth) 方法。 在该方法中，通过 auth.inMemoryAuthentication() 方法创建了一个内存中的用户认证服务，并添加了两个用户，一个是 admin，另一个是 sang。其中，withUser() 方法指定了用户的用户名，password() 方法指定了用户的密码（密码已经被加密），roles() 方法指定了用户的角色。这里的角色只是一个字符串，可以自定义，可以根据自己的业务需要指定不同的角色。
另外，我们在密码前面加了{noop}，表示不使用任何加密方式。
在configure(HttpSecurity http)方法中，通过authorizeRequests()方法来配置访问权限，其中antMatchers()方法用于指定访问路径，hasRole()和hasAnyRole()方法用于指定角色。另外，我们还通过formLogin()方法启用了表单登录功能。
基于数据库认证
在Spring Security中，我们可以通过配置一个实现了UserDetailsService接口的类来实现基于数据库的用户认证。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/81e245f028d21db7befb9d166f53bd7f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d797d0b816d1022b2815875923a40d3/" rel="bookmark">
			下载python第三方库离线数据包官网链接（Anaconda环境也可使用的方法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下载地址： https://pypi.org/
这个是python的第三方库的下载官方，点击搜索框，输入要查找的库的名称，选择对应的库，然后选择适合你的计算机的、对应操作系统和Python的版本，下载对应的文件，存放再该python工程的scripts中。在文件栏中输入cmd，跳转命令窗口，pip install 库的文件名，successful即安装成功。文件栏如下图所示：
这样安装会出现你在pycharm或anaconda检查库list时找不到该库的存在，但程序中是默认存在了，不会报错，可以使用该库，具体原因，我也不清楚。
本人新手，期待指点。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46d7516ef74b46205420dfd03c8893fb/" rel="bookmark">
			JAVA常用加密方式介绍及使用汇总（全集）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、摘要加密（Hash加密）1.MD5加密2.SHA加密3.BCrypt加密二、对称加密1.AES加密(Rijndael[读作rain-dahl]加密)2.PBE加密三、非对称加密1.RSA加密(1)基本使用示例(2)RSA与AES组合使用示例四、加密相关其他技术1.BASE64 引文： 传说在古罗马时代，发生了一次大战。正当敌方部队向罗马城推进时，古罗马皇帝凯撒向前线司令官发出了一封密信：VWRS WUDIILF。这封密信被敌方情报人员翻遍英文字典，也查不出这两个词的意思。 此时古罗马皇帝同时又发出了另一个指令：“前进三步”。然后古罗马军队司令官根据第二个指令很快明白了这封密信的含义。 “前进三步”这个提示的意思是向前推算三位的意思。推算出的结果就是：STOP TRAFFIC 停止运输或停止交通的意思！据说恺撒是率先使用加密函的古代将领之一，因此这种加密方法被称为凯撒密码。 它是一种替代密码，通过将字母按顺序推后起3位起到加密作用，如将字母A换作字母D，将字母B换作字母E。凯撒算法是最早使用的算法之一，是最简单的一种对称加密算法。 一、摘要加密（Hash加密） 引文：
如果开发者需要保存密码（比如网站用户的密码），要考虑如何保护这些密码数据，网站用户密码的泄露是一件非常严重的事情，容易引起用户恐慌，
所以在安全方面是重中之重，直接将密码以明文写入数据库中是极不安全的，因为任何可以打开数据库的人，都将可以直接看到这些密码。
解决的办法是将密码加密后再存储进数据库，比较常用的加密方法是使用哈希函数（Hash Function），也就是摘要加密。
通过哈希函数，我们就可以将密码的哈希值存储进数据库。用户登录网站的时候，我们可以检验用户输入密码的哈希值是否与数据库中的哈希值相同。
由于哈希函数是不可逆的，即使有人打开了数据库，也无法看到用户的密码是多少。（但不意味着存储经过哈希函数加密后的密码就是绝对的安全！）
介绍：摘要加密是一种不需要密钥的加密算法，生成的密文是唯一的、定长的并且无法破解，具有不可逆性、唯一性。常见的算法有MD5、SHA等。
原理：通过hash算法（单向算法）对目标信息生成一段特定长度的唯一hash值。
应用场景：密码加密，数字签名，文件完整性的校验 ，版权等应用场景。
1.MD5加密 介绍：全称Message Digest Algorithm(信息摘要算法)，是将任意长度的数据字符串转化成短小的固定长度的值的单向操作，任意两个字符串不应有相同的散列值。
(1)不加盐版
使用示例：
public static byte[] encryMD5(byte[] data) throws Exception { MessageDigest md5 = MessageDigest.getInstance("MD5"); md5.update(data); return md5.digest(); } (2)加盐版
需要注意的是，如果直接对密码进行散列，那么黑客可以对通过获得这个密码散列值，然后通过查散列值字典（例如MD5密码破解网站），得到某用户的密码。
以及彩虹表技术（在字典法的基础上改进，以时间换空间）的兴起，可以建立彩虹表进行查表破解，目前这种方式已经很不安全了。
此时我们可以通过加盐来解决这个问题。
盐（Salt） 是什么？就是一个 随机生成的字符串。我们将盐与原始密码连接（concat）在一起（放在前面或后面都可以），然后将concat后的字符串加密。Salt这个值是由系统随机生成的，并且只有系统知道。
加盐版算法：
每次保存密码到数据库时，都生成一个随机16位数字，将这16位数字和密码相加再求MD5摘要，然后在摘要中再将这16位数字按规则掺入形成一个48位的字符串。
在验证密码时再从48位字符串中按规则提取16位数字，和用户输入的密码相加再MD5。按照这种方法形成的结果肯定是不可直接反查的，且同一个密码每次保存时形成的摘要也都是不同的。
加盐使用示例：
public static String encryMD5Salt(String data) throws Exception { MessageDigest md5 = MessageDigest.getInstance("MD5"); //每次的盐都是随机的 String salt = UUID.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/46d7516ef74b46205420dfd03c8893fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ffd2238ee5c09270179862d971c7d84/" rel="bookmark">
			nginx配置https泛型域名方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
nginx泛型域名域名SSL配置 一、如何申请免费泛型域名证书？二、nginx配置文件 一、如何申请免费泛型域名证书？ 下载地址：https://freessl.cn/
1.安装acme.sh
建议切换到root模式，可以减少证书安装时的问题
sudo su 注意：MacOS 不用切换到root更简单。
curl https://get.acme.sh | sh -s email=my@example.com 如果上面官方下载地址失败 或者 太慢，可以选用国内的备用地址
curl https://gitcode.net/cert/cn-acme.sh/-/raw/master/install.sh?inline=false | sh -s email=my@example.com acme.sh --install-cert -d example.com \ --key-file /path/to/keyfile/in/nginx/key.pem \ --fullchain-file /path/to/fullchain/nginx/cert.pem \ --reloadcmd "service nginx force-reload" 注意：安装完成后，再重新打开命令行（如果是 SSH，选择重新连接），以使acme.sh命令生效。
二、nginx配置文件 server { listen 443 ssl; server_tokens off; keepalive_timeout 5; index index.php index.html; server_name *.myDomain.com; #填写您的证书绑定的域名 ssl_certificate fullchain.pem; #填写您的证书文件名称 ssl_certificate_key *.myDomain.com.pem; #填写您的私钥文件名称 ssl_session_timeout 5m; ssl_protocols TLSv1 TLSv1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ffd2238ee5c09270179862d971c7d84/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74659604bb0fb1dba0a86de07e867ab7/" rel="bookmark">
			记录electron vite&#43;vue3 项目es module 禁用问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用vite创建vue3 项目生成package.json 文件会默认使用module类型
{ "name": "vue3-electron", "private": true, "version": "0.0.0", "main": "main.js", "type": "module", // 创建项目会默认开启es module "scripts": { "dev": "vite --host", "build": "vue-tsc &amp;&amp; vite build", "preview": "vite preview", "start": "chcp 65001 &amp; nodemon --exec electron . --watch ./ --ext .html,.css,.scss,.vue,.ts,.js" }, "dependencies": { "vue": "^3.2.47" }, "devDependencies": { "@types/node": "^18.15.5", "@vitejs/plugin-vue": "^4.1.0", "electron": "^23.1.4", "nodemon": "^2.0.21", "typescript": "^4.9.3", "vite": "^4.2.0", "vue-tsc": "^1.2.0" } } 启动electron 报错如下
因此，将type类型删除即可，即支持commonjs类型
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6ff2778edfcf966eda1e8fdb0984f90/" rel="bookmark">
			List＜Long＞ 类型数据转为string字符串类型 jdk1.8新特性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		话不多说，直接上代码
List&lt;Long&gt; list = Arrays.asList(1L, 2L, 3L); String result = list.stream() .map(Object::toString) .collect(Collectors.joining(", ")); System.out.println(result); // 输出 "1, 2, 3" 这里，我们首先将 List&lt;Long&gt; 转换为 Stream&lt;Long&gt;，然后使用 map() 方法将每个 Long 类型的元素转换为字符串类型，再使用 Collectors.joining() 方法将所有字符串连接起来并用逗号和空格分隔。
需要注意的是，Collectors.joining() 方法返回的是一个字符串类型的结果，而不是一个 List&lt;String&gt; 类型的结果。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a7dd8bcd439eed9ebbc4f62a08d9947/" rel="bookmark">
			Pycharm的汉化方法（pycharm改为中文版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很多开始接触python的朋友都会用到一款工具：pycharm，但默认是英文版的不知从何下手，本文介绍两种不同的pycharm汉化方法，将其变为中文版的界面。（对于windows电脑和mac电脑均有说明） 方案一： 不需要手动下载汉化包，使用pycharm自带的功能即可实现
1、点击File-settings
（如果是苹果电脑，打开左上角Pycharm-Preferences）
2、点击plugins，在红框处输入Chinese后点击右侧的Marketplace，点击之后选中名为chinese（Simplifiled）Language pack / 中文语言包，点击install按钮等待其安装即可（如果速度特别慢，可更换网络环境或手机热点尝试）
3、点击install下载完成后，install按钮会变为Restart IDE 按钮，点击此按钮后pycharm会重启，重启之后所有的菜单将变为中文。
※如果windows系统版本较低，如win7，可能上述方法会无效，请参考下方的方案二
方案二： 手动安装汉化包（pycharm官方汉化包）
1、点击下方链接进入官方汉化包下载页
官方汉化包下载地址https://plugins.jetbrains.com/plugin/13710-chinese-simplifiled-language-pack---/versions2、点击versions，找到和自己pycharm相同年份/版本的汉化包，后点击Download，浏览器会自动下载
3、下载到电脑中的任意位置（自己能记住就行）
4、进入pycharm-file-settings-plugins-Install Plugins form Disk（从磁盘安装插件）
5、选择刚刚下载到电脑中的汉化包进行加载即可
※以上两种方法均为安全可靠方案，汉化包都是官方提供的，放心下载，如有疑问欢迎评论区留言或私信我进行讨论。
❤关注我，不迷路❤
******我的本文相关专栏******
软件测试 &amp; 开发（单击此处进入）
******我的其它作品专栏******
PC常见故障汇总专栏（点击进入）
EXCEL综合场景应用详解（点击此处进入）
全国计算机等级考试-二级python基础（点击此处进入）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6229893942ae3acc91caa0a7a5075615/" rel="bookmark">
			字符串比较 python
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		。在Python中，字符串是一种常见的数据类型，它由一系列字符组成，可以用单引号、双引号或三引号表示。
字符串比较是Python中常见的操作之一，它可以用来判断两个字符串是否相等。在Python中，字符串比较使用==运算符，例如：
str1 = \hello\str2 = \world\if str1 == str2:
print(\两个字符串相等\else:
print(\两个字符串不相等\上述代码中，str1和str2分别表示两个字符串，如果它们相等，则输出“两个字符串相等”，否则输出“两个字符串不相等”。
除了使用==运算符进行字符串比较外，Python还提供了其他比较运算符，如&lt;、&gt;、&lt;=、&gt;=等。这些运算符可以用来比较字符串的大小，例如：
str1 = \apple\str2 = \banana\if str1 &lt; str2:
print(\str1小于str2\else:
print(\str1大于等于str2\上述代码中，str1和str2分别表示两个字符串，如果str1小于str2，则输出“str1小于str2”，否则输出“str1大于等于str2”。
需要注意的是，在Python中，字符串比较是区分大小写的，即大写字母和小写字母是不同的。因此，在进行字符串比较时，需要注意大小写的问题。
在进行字符串比较时，需要注意大小写的问题，以免出现错误。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/232d4fbd606bf4e0803d18c807fada97/" rel="bookmark">
			Nginx服务部署及基础配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
Nginx介绍
Nginx简介
I/O模型相关概念
Nginx事件驱动模型
部署Nginx
yum部署Nginx
编译安装Nginx
Nginx使用
基础使用
nginx信号
web服务选择及优化
Nginx与Apache对比
Nginx服务调优
Nginx介绍 Nginx简介 作用：支持七层(应用层)和四层(传输层)反向代理、可做web服务器。
特性：高可靠性、支持热部署、可扩展性好、高并发高性能、单机部署。
进程：一个主进程master生成多个worker子进程，worker子进程负责处理工作。
I/O模型相关概念 ①Nginx服务使用异步非阻塞模式：请求不需要排队，会反馈任务的完成结果。
②Apache服务使用同步阻塞模式：请求需要排队，且不会主动返回结果。
③同步/异步：关注的是消息通信机制，即调用者在等待一件事情的处理结果时。被调用者是否提供完成。
④同步：调用者需要主动询问结果。
⑤异步：调用者不需要主动询问结果，被调用者会主动返回结果。
⑥阻塞：系统同时只能处理1个请求，另外的请求需要排队。
⑦非阻塞：系统同时处理多个请求。
Nginx事件驱动模型 ①select：一个应用程序，代理系统功能处理异步请求，最大连接数是1024个。
它仅仅知道了，有I/O事件发生了，却并不知道是哪那几个流（可能有一个，多个，甚至全部），我们只能无差别轮询所有流，找出能读出数据，或者写入数据的流，对他们进行操作。所以select具有O(n)的无差别轮询复杂度，同时处理的流越多，无差别轮询时间就越长。
②poll：select加强版取消了1024最大连接数。
poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态， 但是它没有最大连接数的限制，原因是它是基于链表来存储的。
③epoll：poll的加强版。
epoll可以理解为event poll，不同于忙轮询和无差别轮询，epoll会把哪个流发生了怎样的I/O事件通知我们。所以我们说epoll实际上是事件驱动（每个事件关联上fd）的，此时我们对这些流的操作都是有意义的。
部署Nginx yum部署Nginx 使用yum部署Nginx需要先安装epel-release扩展包，官方源默认没有Nginx的yum源。
yum install epel-release -y #安装epel-release扩展源 扩展源安装完后直接安装Nginx。
yum install nginx -y #安装nginx服务 使用yum安装的nginx配置文件位置在：/etc/nginx.conf。默认根目录在：/usr/share/nginx/html。默认日志文件在：/var/log/nginx/路径下。
编译安装Nginx 官网下载安装包，nginx官网地址nginx，进入后找到右边菜单栏的download,进入后选择自己想要下载的版本可以直接下载到本地然后传到Linux系统中或右键复制该包的下载连接在Linux系统中wget此地址直接下载到Linux系统中
安装包下载完成后安装编译需要的依赖环境和工具，然后进入对应的目录进行解压编译。
yum -y install gcc pcre-devel openssl-devel zlib-devel #安装编译安装需要的依赖包和工具 cd /opt #进入指定安装包下载的目录 /opt下 tar xf nginx-1.18.0.tar.gz #将nginx包解压到当前文件夹 cd nginx-1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/232d4fbd606bf4e0803d18c807fada97/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9240c437cf04a86bbe61255df9f6f05/" rel="bookmark">
			VMware vCenter Server 7.0 完整安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VMware vCenter Server 7.0 完整安装教程
链接：https://pan.baidu.com/s/1b8zxEhGX6S3BlTYgUuGseQ
提取码：4mad
以下为安装教程--------------------------------------------------------------------------------------------------------------------
一、 将下载的文件进行装载或者解压
二、 进到\vcsa-ui-installer\win32的目录。就可以看见安装的程序，双击开始安装
三、 右上角选择语言，点击安装
四、 直接点击下一步
五、 勾选接受许可协议条款，然后下一步
六、 填写ESXI主机名或者IP地址，输入用户密码，端口默认，然后下一步
七、 连接到目标服务器，如果有证书警告点击是
八、 设置vCenter Server 的机器名字以及密码，这里的密码是登录VC控制台root的密码然后下一步
九、 根据自己的实际情况来选择，我这里测试就默认了，如果有不符合项，点击下一步，它会提示
十、 选择在ESXI主机存储的存放位置，以及选择精简模式 ，然后下一步
十一、 配置vCenter Server的网络信息 ，然后下一步
十二、 配置完成后，点击完成
十三、 开始部署
十四、 第一阶段部署完成，点击继续
十五、 开始部署第二阶段
十六、 选择时间同步，有NTP的可以选择NTP，没有的选择与ESXI主机同步；禁用SSH访问
十七、 配置SSO信息
十八、 选择是否加入客户体验提升，然后下一步
十九、 确认第二阶段配置信息，然后点击完成
二十、 提示【安装操作一旦开始便无法暂停或停止，直至安装完成。单击“确定”继续，或者单击“取消”停止安装】，点击确定
二十一、 开始第二阶段配置，等待大约十几分钟
二十二、 第二阶段配置完成，点击关闭
二十三、 进入到ESXI的管理界面，检查刚刚配置vCenter server的虚拟机，如果电源没打开，就把电源打开。
二十四、 开机完成后，屏幕上有三个地址，第一个是管理地址
二十五、 进入管理地址界面，输入账号密码
二十六、 登陆后的整体界面
二十七、 安装就到此结束了，欢迎各位朋友借鉴阅读，有不详细的地方，欢迎朋友指出，如果此文帮助了你，还望各位看官点个赞。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5cd390f68d60e1fa4d968942317c9669/" rel="bookmark">
			（四）大数据实战——hadoop模板虚拟机网络配置及主机名IP设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 本节内容我们主要介绍一下虚拟机的网络配置，网络使用NAT网络模式，将我们的虚拟机的网络设置为固定IP，不要动态分配IP，这样每次启动服务器，我们的IP地址都是固定的，不会动态变化，方便使用。完成主机名的修改和配置主机名与网络IP的映射，实现通过主机名也能实现虚拟机的访问。
正文 虚拟机网络配置 ①选择编辑，虚拟网络编辑器
②选择VMnet8，点击更改设置
③设置子网IP，作者这里设置为了10网段的，可以根据实际情况设置 ④点击NAT设置，设置网关，这里必须与子网IP是同一个网段，点击确定，完成虚拟机的网络设置
⑤进入实体机的VMnet8网络设置中心
⑥右键属性，双击IPv4协议，选择固定IP，填写IP地址和子网掩码以及虚拟机的默认网关和域名解析，完成实体机的网络配置 将模板虚拟机的IP改为固定IP，并设置虚拟机的主机名，以及主机名和IP的映射关系 ①使用vi编辑器修改模板虚拟机的IP为固定IP地址
vi /etc/sysconfig/network-scripts/ifcfg-ens33
②使用vi编辑器修改模板虚拟机的主机名
vi /etc/hostname
③使用vi编辑器修改模板虚拟机的主机名和IP的映射关系
vi /etc/hosts
测试模板虚拟机 ①重启虚拟机
②查看虚拟机ip地址以变为固定IP地址
结语 至此，关于hadoop模板虚拟机网络配置及主机名IP设置及映射到这里就结束了，我们下期见。。。。。。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/878f35a7681f409a101b738b1003b776/" rel="bookmark">
			前缀和,二分,数学----123（待优化）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前缀和是指将一个序列中每个位置前面所有元素的和预处理出来，以便于后续查询。这个技巧在一些区间求和问题中非常有用，比如统计数组中某一段区间内的元素和。时间复杂度为O(n)。
二分查找是一种高效的查找算法，在已排序的数组中查找特定值的位置。它的时间复杂度是O(log n)。这个算法的基本思想是将待查找区间不断缩小，直到找到目标值。
题目描述 小蓝发现了一个有趣的数列，这个数列的前几项如下：
1,1,2,1,2,3,1,2,3,4,⋯1,1,2,1,2,3,1,2,3,4,⋯
小蓝发现，这个数列前 11 项是整数 11，接下来 22 项是整数 11 至 22，接下来 33 项是整数 11 至 33，接下来 44 项是整数 11 至 4，依次类推。
小蓝想知道，这个数列中，连续一段的和是多少。
输入描述 输入的第一行包含一个整数 TT，表示询问的个数。
接下来 TT 行，每行包含一组询问，其中第 ii 行包含两个整数 lili​ 和 riri​，表示询问数列中第 lili​ 个数到第 riri​ 个数的和。
输出描述 输出 TT 行，每行包含一个整数表示对应询问的答案。
输入输出样例 示例
输入
3 1 1 1 3 5 8 输出
1 4 8 评测用例规模与约定 对于 1010% 的评测用例，1≤T≤30,1≤li≤ri≤1001≤T≤30,1≤li​≤ri​≤100。
对于 2020% 的评测用例，1≤T≤100,1≤li≤ri≤10001≤T≤100,1≤li​≤ri​≤1000。
对于 4040% 的评测用例，1≤T≤1000,1≤li≤ri≤1061≤T≤1000,1≤li​≤ri​≤106。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/878f35a7681f409a101b738b1003b776/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36fbfde532e0413a9839094ea017c05a/" rel="bookmark">
			linux下安装python插件selenium遇到的问题汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我已经配置好一些内容:
1.安装了谷歌驱动
2.已经把这个驱动包移动到了usr/bin目录下
3.我也安装了selenium
执行python脚本的内容:
from selenium import webdriver browser = webdriver.Chrome() browser.get("http://www.baidu.com") print(browser.page_source) browser.close() 1.顺着第一个报错走
出现了报错:raise WebDriverException( selenium.common.exceptions.WebDriverException: Message: ‘chromeDriver
看描述也就是selenium模块无法找到chromeDriver,
来个排查步骤吧.把目录切换到chromeDriver的哪个目录下,执行下命令.chromeDriver，看看是否能加载这个驱动:可能会出现以下报错:
1.切换到目录下执行下命令:
.chromeDriver ibnss3 : Depends: libnspr4 (&gt;= 2:4.12) but 2:4.10.2-1ubuntu1 is to be installed libnss3-nssdb : Depends: libnss3 (= 2:3.23-0ubuntu0.14.04.1) but 2:3.28.4-0ubuntu0.14.04.3 is to be installed E: Unmet dependencies. Try ‘apt-get -f install’ with no packages (or specify a solution).
刚开始尝试着通过apt-get -f install类似命令安装，但是有报了错: 提示缺少libnss3这个包:
【Linux】-- apt-get install 出错，Python 未配置 上个报错的解决方案是:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/36fbfde532e0413a9839094ea017c05a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74f0faf83d56ac32ebb793e20c1b02f6/" rel="bookmark">
			前端js循环修改对象属性，得到新数组数据属性是最后一个数（深拷贝与浅拷贝）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目场景： 在前端项目的开发中，我将JSON格式的对象数组（例如：[{a:1},{b:2}]）引入js文件，在js文件中通过循环修改对象数组中的数据，然后把新的数据push添加到新建数组中。
这一过程涉及深拷贝与浅拷贝的问题，困扰了一下午，总算是解决了，特此记录一下。
问题描述 作为入门级选手的我，不出意外的出错了。下面是我写的错误代码，并没有考虑到深拷贝与浅拷贝的问题（因为大脑里就没有存储相关知识…）。
APP 中js文件代码：
//引入外部JSON格式的对象数组 [{id:1,age:23},{name:ww,school:xx}] static DataMoudle = require("../../static/documentModel.json"); static addPicture(ruleForm,latlngsArr){ let transformData = [] let fileArr = [11,12,13] let temp = this.DataMoudle[0] fileArr.forEach(value =&gt; { temp.id = value transformData.push(temp) }); console.log(transformData) //打印出来的数据是[{id:13,age:23},{id:13,age:23}，{id:13,age:23}]，三个数据相同，且是最后一个id=13 } 原因分析： 对于一般问题，是由于在循环中直接修改了原始对象，而不是创建一个新的对象副本来修改。当你把原始对象推入新数组时，它只是一个指向原始对象的引用，所以当原始对象被修改时，新数组中的所有引用都会被更新。你可以尝试在循环中创建一个新的对象副本，然后修改副本中的属性，并将副本推入新数组。这样每次循环都会创建一个新的独立的对象，而不会影响其他已经推入数组中的对象。
下面是一个简单的示例，它演示了如何在循环中创建对象副本并修改副本中的属性：
let originalObject = { a: 1, b: 2 }; let newArray = []; for (let i = 0; i &lt; 3; i++) { let newObject = {...originalObject}; // 创建一个新的对象副本 newObject.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/74f0faf83d56ac32ebb793e20c1b02f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c48e696250544421a828f42a8fff3e3/" rel="bookmark">
			嵌入式面试题(持续更新)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、编写一个函数，作用是把一个char组成的字符串循环右移n个。比如原来是“abcdefghi”如果n=2，移位后应该是“hiabcdefg”。右移字符串。
按照最笨的方法：
申请(malloc)一个buf为100的空间，传字符串和buf和右移个数给func函数，经过一系列转换，得到最终值，返回buf并打印。
#include&lt;stdio.h&gt; #include&lt;string.h&gt; #include&lt;stdlib.h&gt; #include&lt;unistd.h&gt; char* func(char *str,char *buf,int n2) { char *p = str; while (*p!='\0') p++; //p指向字符串末尾 int n = n2; while (n--) p--; //利用n来让p偏移 printf("右移字符:%s\n",p); for (int i = 0; *p!='\0'; i++) //将需要移动的字符寸给buf { buf[i] = *(p++); } strcat(buf,str); //将字符串追加到buf中 int k = strlen(buf); //得到buf长度 while (n2--) buf[--k]=0;; //把最后要移动字符删除 return buf; //返回buf } int main() { char *str = "abcdefg"; char *buf = malloc(100); printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c48e696250544421a828f42a8fff3e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac69ef51e68b98f7c2b4f5540abe0042/" rel="bookmark">
			如何运用JavaScript中的函数做出一个简易计算器呢？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用JS的函数功能，制作一个简易的计算器，包括加、减、乘、除的功能。输入任意操作数，使用函数传参的方式完成计算器的功能。
&lt;body&gt; &lt;div id="one"&gt; &lt;div&gt; 第一个数:&lt;input type="text" id="box1"&gt; &lt;/div&gt; &lt;div&gt; 第二个数:&lt;input type="text" id="box2"&gt; &lt;/div&gt; &lt;div style="margin-left: 70px;"&gt; &lt;button onclick="cal('+')"&gt;+&lt;/button&gt; &lt;button onclick="cal('-')"&gt;-&lt;/button&gt; &lt;button onclick="cal('*')"&gt;*&lt;/button&gt; &lt;button onclick="cal('/')"&gt;/&lt;/button&gt; &lt;button onclick="cal('%')"&gt;%&lt;/button&gt; &lt;/div&gt; &lt;div&gt; 计算结果:&lt;input type="text" id="box3"&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; function cal(res){ var _box1=document.getElementById('box1'); var _box2=document.getElementById('box2'); var _box3=document.getElementById('box3'); var a=_box1.value; var b=_box2.value; var box3=eval(a+res+b); // 录入结果 _box3.value=box3; // 清空第一个和第二个数值 _box1.value=""; _box2.value=""; } &lt;/script&gt; &lt;/body&gt; 效果图如下：
这就是利用JS中的函数做出的很简易的一个计算器的效果，各位小伙伴快去试试吧！
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/163/">«</a>
	<span class="pagination__item pagination__item--current">164/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/165/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>