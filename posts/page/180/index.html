<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f4f654c34ec79d208910fa0287bd3f9/" rel="bookmark">
			怎么找到一份Java后端的工作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		呢？
找工作是一件很重要的事情，有很多方法可以找到一份合适的Java后端工作。首先，你可以通过网络平台，如拉勾网、智联招聘等，查找适合你的工作。其次，你也可以通过与周围的人联系，如朋友、同事、前任同事等，寻求帮助。最后，你也可以直接去企业宣讲会，了解更多关于企业的信息，以及可能有的工作机会。总之，要想找到一份合适的工作，需要多方面的努力。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/497b8f1af43029bc7ef8475ccb5e63bd/" rel="bookmark">
			Jetson Nano B01 从零入门笔记系列（二）python环境构建-pycharm安装-pytorch安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Jetson Nano B01 从零入门笔记系列（二）python环境构建-pycharm安装-pytorch安装Bug与报错 1、前言 时隔N年我居然又回来搞这个了，真是命运弄人。
为了应付万恶甲方的BT需求，只能硬着头皮上了，至少得先把算法移植到板子上
2、virtualenvwrapper安装报错与conda安装 看大部分的攻略都安装的是这个虚拟环境，虽然很想装annaconda，但还是先按攻略做
首先pip安装我就做不了，只能用pip3安装，这个暂且不管,替换成pip3即可
// 虚拟环境安装 sudo -H pip3 install virtualenv virtualenvwrapper 到这先报了一次错，后来莫名其妙消失了，但是装到virtualenvwrapper的时候死活装不下去
老是卡在：
Collecting virtualenvwrapper Downloading https://files.pythonhosted.org/packages/c1/6b/2f05d73b2d2f2410b48b90d3783a0034c26afa534a4a95ad5f1178d61191/virtualenvwrapper-4.8.4.tar.gz (334kB) 100% |████████████████████████████████| 337kB 1.7MB/s 然后就不动弹了，后来查了好久发现了这篇攻略：
https://blog.csdn.net/ramblerviper/article/details/118882897
还是源的问题，需要做以下换源操作
sudo pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pbr sudo pip install -i https://pypi.tuna.tsinghua.edu.cn/simple --no-deps stevedore sudo pip install -i https://pypi.tuna.tsinghua.edu.cn/simple --no-deps virtualenvwrapper 然后再安装显示就正常了 ：
sudo pip install virtualenvwrapper 好吧最后还是出bug了，没法运行老是显示
python2报错，下次再解决试试
还是决定安装annaconda了
https://blog.csdn.net/YMWM_/article/details/107022521
conda aarch64：https://github.com/Archiconda/build-tools/releases
第一次把包下下来放到板子里居然无法sh，不知道为什么
后来到git上重新下载了一遍，然后重启了下板子莫名其妙又可以安装了，果然重启解决一切问题。
3、pycharm安装 还是想依赖pycharm，于是还得装一下
一开始参考的是这篇文章
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/497b8f1af43029bc7ef8475ccb5e63bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/803406164faeeecd2be2177e49b2a895/" rel="bookmark">
			我问chatGPT，在JavaScript中构造函数和类的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问：构造器函数和面向中的类是同样的东西吗|？
答：构造器函数和面向对象中的类并不是同样的东西，它们之间有些许不同。
在面向对象编程中，类是一种抽象的概念，它描述了一类具有相同属性和行为的对象。类可以看作是对象的蓝图，包含了对象的属性和方法。而对象是类的一个实例，是类的具体实现，通过实例化类来创建对象。
构造器函数则是一种特殊类型的函数，用于创建和初始化对象。它通常用于面向对象编程中，特别是在使用类来创建对象时。构造器函数通常与类名相同，用于创建一个新的实例对象。在创建新的实例对象时，构造器函数会自动被调用，并为该对象执行必要的初始化操作，例如为对象的属性赋初值。
因此，可以说构造器函数是用来创建类的实例对象的函数。在面向对象编程中，类和构造器函数是紧密相关的概念，但并不是同一概念。
问：类能实例化对象，构造器也能实例化对象，二者实例化过程好像并没有什么不同？
答：在面向对象编程中，类和构造器函数都能用来实例化对象，它们的实例化过程确实有相似之处，但实例化对象的方式略有不同。
类通过定义属性和方法的方式描述了对象的特征和行为，而实例化类则是通过调用类来创建一个新的对象。在创建一个类的实例时，我们需要使用关键字 new，并提供相应的构造参数（如果有的话），从而生成一个新的对象。具体而言，实例化类的过程涉及到以下几个步骤：
创建一个新的对象，该对象继承自类的原型。
将该对象作为函数调用 this 上下文，即将该对象作为函数的 this 参数，使其在构造函数内部可以访问该对象。
执行构造函数内部的初始化操作，例如为对象的属性赋初值等。
返回该新对象。
而构造器函数本身就是用来创建对象的函数。在调用构造器函数时，实际上就是在创建一个新的对象并对其进行初始化。具体而言，实例化构造器的过程涉及到以下几个步骤：
创建一个新的对象。
将该对象作为函数调用 this 上下文，即将该对象作为函数的 this 参数，使其在构造函数内部可以访问该对象。
执行构造函数内部的初始化操作，例如为对象的属性赋初值等。
返回该新对象。
因此，尽管类和构造器函数的实例化过程类似，但它们的作用和用法有所不同，不能混为一谈。类是一种抽象的概念，描述了一类对象的特征和行为，而构造器函数是用来创建和初始化对象的函数。
问：你提供的信息很多，我现在有点混乱，能再整合概括一下，关于在JavaScript中构造函数和类的区别以及实例化对象过程的不同吗。
答：
当在 JavaScript 中定义一个类时，实际上是定义了一个构造函数。类和构造函数的语法很相似，但类提供了更多的语法糖和面向对象的特性，如继承和多态等。
在 JavaScript 中，实例化一个对象的方式对于构造函数和类来说是不同的。对于构造函数，我们可以通过 new 操作符创建一个新的实例对象，并且可以直接调用构造函数中定义的属性和方法。而对于类，我们需要使用 class 关键字来定义一个类，然后使用 new 操作符创建一个新的实例对象。
当我们使用类来实例化对象时，实际上是通过类的构造函数创建了一个新的实例对象。类中定义的属性和方法会被添加到该对象的原型中，所以该对象可以继承类的属性和方法。
总的来说，类是构造函数的语法糖，并且提供了更多的面向对象的特性。实例化对象的过程对于构造函数和类来说有所不同，但本质上都是创建一个新的对象并调用相应的构造函数来初始化该对象。
问：类是构造函数的语法糖这句话我不太明白，以及我对语法糖这个词的定义不是太了解，能顺便介绍一下吗？
答：
当我们说一个语言的某个特性是“语法糖”时，意思是这个特性的实现是建立在这个语言的基础特性之上的，并不是一个全新的特性。这个特性的作用通常是让代码更加简洁易读，或者让代码符合更广泛的编程约定。
在 JavaScript 中，类是一种使用更加简洁明了的方式来定义对象和对象的行为的方法，而它实际上是在构造函数和原型链的基础上构建的。因此，当我们说类是构造函数的语法糖时，我们的意思是类的实现基本上是通过构造函数和原型链来实现的，但使用类的语法可以让我们以更加直观和简洁的方式来定义对象和行为，从而让代码更加易读易懂。
总结起来，类和构造函数本质上是相同的，只是使用了不同的语法。在 JavaScript 中，类是构造函数的语法糖，通过类可以以更加简洁的方式来定义对象和对象的行为。
问：“特别是在使用类来创建对象时。构造器函数通常与类名相同”这句话，你能距离一个JavaScript的代码段来证明吗？
答：
当使用类创建对象时，类的构造函数与类名相同。以下是一个使用类创建对象的JavaScript代码示例：
class Person { constructor(name, age) { this.name = name; this.age = age; } sayHello() { console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/803406164faeeecd2be2177e49b2a895/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5afd658612767cb68c969f3ce345dda/" rel="bookmark">
			网络数据采集技术snmp/netflow/sflow/network telemetry简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 snmp介绍原理snmp的优缺点 NetFlow、sFlowsflownetflownetflow 和 sflow对比netflow 和 snmp的区别 Network telemetry背景/需求telemetry 对比 snmp、netflow/sflow和 snmp对比和 netflow/sflow对比 out-band network telemetry简介怎么区分带外和带内 in-band network telemetryTelemetry涉及的技术telemetry原理INT（inband telemetry）的优势INT小结 参考 snmp 介绍 SNMP(Simple Network Management Protocol : 简单网络管理协议)是一种简单网络管理协议，它属于TCP/IP五层协议中的应用层协议，使用udp传输(默认端口是UDP161,也会用到162端口接收trap数据)，用于网络管理的协议。
SNMP用于收集和组织有关IP网络上被管理设备的信息，同时支持修改该信息以更改设备行为，此外，SNMP可监控路由器和交换机端口的带宽利用，以及CPU负荷和内存利用等设备读数。
因此：SNMP可通过“利用网络管理网络”的方式，实现对网络设备的批量管理，从而提高设备管理效率。
关键词：批量管理网络设备，网络设备的资源（cpu、内存、通过的字节数/包数）使用获取。
原理 SNMP协议主要由两大部分构成
SNMP管理站是一个中心节点，负责收集维护各个SNMP元素的信息，并对这些信息进行处理，最后反馈给网络管理员
SNMP代理agent运行在各个被管理的网络节点之上，负责统计该节点的各项信息，并且负责与SNMP管理站交互，接收并执行管理站的命令，上传各种本地的网络信息。
1&gt; snmp使用UDP协议进行通讯，默认端口是UDP161(也会用到162端口接收trap数据);
关键词：snmp： udp 161端口；
2&gt; SNMP管理站通过向SNMP代理发送请求命令（GetRequest,GetNextRequest, GetBulkRequest或InformRequest)，当SNMP代理收到命令后返回响应（Response)；
关键词：请求–响应模式；中心节点&lt;-----&gt;agent
3&gt; SNMP管理站向SNMP代理发送SetRequest，代理设备执行设置操作；
关键词：中心节点—&gt;agent 发送设置命令，agent执行。
4&gt; SNMP代理发生特定重要状况改变时主动向SNMP管理站发送Trap消息。
关键词：特定情况，agent发送trap消息主动上报
snmp的优缺点 SNMP可以采集到网络设备CPU、内存、日志等信息，但缺点是无法采集到网络数据流量，无法判断链路拥塞情况。
关键词：有cpu、内存、日志等；无网络数据流；
NetFlow、sFlow sflow sFlow（sampled flow：采样流）是一种用于监控交换机或路由器流量转发状况的技术，采用内置在硬件中的专用芯片，旨在消除路由器或交换机的CPU和内存负担。
关键词：内嵌在交换机/路由器的芯片中（硬件采样），减少cpu负担；
组成 &amp; 原理
一个sFlow系统主要由若干内嵌于交换机或路由器等转发设备（即sFlow Agent，sFlow代理）和一个核心sFlow Collector（即sFlow采集器）组成。
分布在网络不通位置的sFlow代理把sFlow数据报源源不断地传送给中央sFlow采集器，然后采集器会对sFlow数据报进行分析并生成丰富、实时、全网范围的传输流视图或表报，帮助网络管理员更加有效地管理整个站点的网络流量。
sFlow收集器将得到的信息按接收方地址类型、协议类型等进行分类处理，能够统计不同类型的通信信息。
关键词：sflow agent、sflow collector
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d5afd658612767cb68c969f3ce345dda/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f787f54a8e72721080e7e0b74cece29c/" rel="bookmark">
			Uncaught SyntaxError: Cannot use import statement outside a module
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 报错原因：
浏览器报错的原因是我们用了算是在2022年比较现代的es6的语法， 但是浏览器将它作为以前版本的js解析，所以出现问题
正确用法：
为了让 JavaScript 更模块化、更整洁以及更易于维护，ES6 引入了在多个 JavaScript 文件之间共享代码的机制。 它可以导出文件的一部分供其它文件使用，然后在需要它的地方按需导入。 为了使用这一功能， 需要在 HTML 文档里创建一个 type 为 module 的脚本。 例子如下：
test.js
export const add = (x, y) =&gt; { return x + y; } index.html
&lt;script type="module"&gt; import { add } from './test.js'; console.log(add(1,2)); // 打印出3 &lt;/script&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b548bede6a144de3bd0a4e60132b9f4/" rel="bookmark">
			[linux服务器深度学习环境搭建]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 总结一下花费三天在服务器上搭建的服务器：
1、先在本地下载linux版anaconda，然后使用xftp传到服务器，然后解压即可。
2、安装CUDA，https://blog.csdn.net/scl52tg/article/details/126299974,https://blog.csdn.net/weixin_45690176/article/details/119062059，不需要使用root权限（不需要sudo）.
CUDA下载网址如下,注意选择runfile文件，我这里的服务器没有root权限，且yum无法正常使用，指令安装时去掉sudo，使用sh即可。
https://developer.nvidia.com/cuda-toolkit-archive 在bash安装cuda时无法修改路径，可以用以下格式指令安装
bash ./cuda_10.1.243_418.87.00_linux.run --toolkit --toolkitpath=/home/data/yangwg/qh/cuda_10.1 --defaultroot=/home/data/yangwg/qh/cuda_10.1 2.5、中途出现的空间不够但实际上空间充足（[Errno 28] No space left on device），可以创建一个tmp文件夹替换系统tmp文件夹,更改tmp路径(tmp为创建的文件夹)，原因是系统临时内存不足：
export TMPDIR=/data/liuyichen/tmp 3、安装cudnn，链接同上
检查cudnn是否安装成功
https://blog.csdn.net/tangjiahao10/article/details/125227005 4、去torch官网安装合适版本的torch，记得拉到最后选择准确的CUDA版本(以下错误示例，注意到-f后跟的链接里是cu113，可能是这个原因导致我下载cu111没成功)
# CUDA 11.1 pip install torch==1.10.1+cu111 torchvision==0.11.2+cu111 torchaudio==0.10.1 -f https://download.pytorch.org/whl/cu113/torch_stable.html 5、常用清华源
-i https://pypi.tuna.tsinghua.edu.cn/simple 6、查看服务器支持的CUDA版本以及查看CUDA是否安装成功
nvidia -smi nvcc -V 7、查询torch是否可用
import torch print(torch.cuda.is_available()) torch.cuda.get_device_name(0) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae0999d69734fbd13de7df1f6967dc9c/" rel="bookmark">
			Springboot使用@Aspect、自定义注解记录日志
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、前言
2、切面方法说明
3、AOP日志记录方式
3.1、扫描包的方式
3.2、自定义注解方式
3.2.1.Maven依赖：
3.2.2. 自定义注解:
3.2.3. TakeTimeAspect（使用AOP技术统计方法执行前后消耗时间）：
3.2.4. 在接口方法上加上注解
3.2.5. 打印查看接口耗时：
1、前言 日志的作用不言而喻，协助运维故障排查，问题分析，数据统计，记录查询等。
故障排查：通过日志可对系统进行实时健康度监控，系统日志记录程序 Syslog 就是为这个目的而设计的。
数据分析：通过对业务系统日志进行关联分析，可以掌握业务系统的整体运行情况，并可通过日志进一步掌握用户画像、用户访问地域、用户访问热点资源等信息，从而为业务平台的市场营销、销售策略等提供数据支撑。
安全合规审计：根据国家网络安全法等级保护要求，需要对安全设备日志进行集中存储和分析。
内网安全监控：很多企业的信息泄露源于内部，使用日志进行用户行为分析以监控内网安全，已成为行业共识。
智能运维：随着大数据时代的到来，数据管理和分析方案越来越智能，自动化运维已逐渐普及。机器数据作为智能运维的基础数据，必将发挥越来越重要的作用。
日志各位大佬记录都会，但是规范有效记录日志的很少，本文为工具类文章，开箱即用，直接导入项目即可，CV大法一键搞定
2、切面方法说明 @Aspect -- 作用是把当前类标识为一个切面供容器读取
@Pointcut -- (切入点):就是带有通知的连接点，在程序中主要体现为书写切入点表达式
@Before -- 标识一个前置增强方法，相当于BeforeAdvice的功能
@AfterReturning -- 后置增强，相当于AfterReturningAdvice，方法退出时执行
@AfterThrowing -- 异常抛出增强，相当于ThrowsAdvice
@After -- final增强，不管是抛出异常或者正常退出都会执行
@Around -- 环绕增强，相当于MethodInterceptor AOP五种通知工作
前置通知：在目标方法调用之前执行，可以获得切入点信息；
后置通知：在目标方法执行后执行，目标方法有异常不执行；
异常通知：在目标方法抛出异常时执行，可以获取异常信息；
最终通知：在目标方法执行后执行，无论是否有异常都执行；
环绕通知：最强大的通知类型，在目标方法执行前后操作，可以阻止目标方法执行。
3、AOP日志记录方式 aop解决的这个办法有很多种，这里介绍两种最简单、最常用的
扫描包的方式。传入的参数在请求头里面(企业常用)自定义注解 3.1、扫描包的方式 1）添加依赖
&lt;--AOP的依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt; &lt;/dependency&gt; &lt;--JSON的依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.79&lt;/version&gt; &lt;/dependency&gt; &lt;--mysql-data-jpa的依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae0999d69734fbd13de7df1f6967dc9c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aeffa8c15e174230a58b417fa96dc4ba/" rel="bookmark">
			java中的数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 本章目标 为什么需要数组 什么是数组 小结 如何使用数组 声明数组 分配空间 数组赋值 处理数据 使用数组求平均分 常见错误 数组排序 Arrays类的各种方法 求最大值 总结 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a33d81f84bb2126da3ee79f798f73de/" rel="bookmark">
			java.lang.NullPointerException: Attempt to invoke virtual method ‘void android.view.View.setScaleX(f
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 开发SystemUi的时候遇到的问题,遇到这个问题加一个判空的方法就好了,
//简代码 privite void animateBounceEffext(){ if(isWindowVisible()){ return; } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87c5ffdd92f7342cd4ace8e1058aab9e/" rel="bookmark">
			【Node】mac 安装n进行node版本管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装 清除node缓存:sudo npm cache clean -f
安装 n 执行: npm install n -g
注意：如果报错如：code EACCES errno -13，表示你没有权限安装，使用管理员身份安装：sudo npm i n -g
查看n是否安装成功：n -V
使用n管理node 查看node可以使用的列表：n ls
安装制定版本 node
查看官方 node 版本 npm view node versions 或者 node官网
安装指定的node版本: n node 版本号 如：n 17.2.0
注意：如果最终显示的还是原来node的版本号则需要在管理员权限下运行: sudo n node 版本号
切换node版本 首先执行 n，通过上下键进行切换选择，最后使用 enter 键选中版本。
如果选中后还是原来版本，则使用 sudo n，后再通过上下键进行切换选择，最后使用 enter 键选中版本。
3.删除指定版本 node
运行命令 n rm node 版本号或者运行 sudo n rm 版本号
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/87c5ffdd92f7342cd4ace8e1058aab9e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/234dcdde923855a441368f844a8158af/" rel="bookmark">
			如何使用断点续传上传大文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概念 大文件上传的需求介绍 不管怎样简单的需求，在量级达到一定层次时，都会变得异常复杂。
文件上传简单，文件变大就复杂
上传大文件时，以下几个变量会影响我们的用户体验
服务器处理数据的能力请求超时网络波动
上传时间会变长，高频次文件上传失败，失败后又需要重新上传等等，为了解决上述问题，我们需要对大文件上传单独处理，这里涉及到分片上传及断点续传两个概念。 分片上传 分片上传，就是将所要上传的文件，按照一定的大小，将整个文件分割成多个数据块（Part）来进行分片上传
如下图
一般实现方式有两种：
服务器端返回，告知从哪开始浏览器端自行处理
上传完之后再由服务端对所有上传的文件进行汇总整合成原始文件
大致流程如下：
1，将需要上传的文件按照一定的分割规则，分割成相同大小的数据块。
2，初始化一个分片上传任务，返回本次分片上传唯一标识。
3，按照一定的策略(串行或并行)发送各个分片数据块。
4，发送完成后，服务端根据判断数据上传是否完整，如果完整，则进行数据块合成得到原始文件 断点续传 断点续传指的是在下载或上传时，将下载或上传任务人为的划分为几个部分(分片)
每一个部分采用一个线程进行上传或下载，如果碰到网络故障，可以从已经上传或下载的部分开始继续上传下载未完成的部分，而没有必要从头开始上传下载。从而让用户节省时间，提高速度。
一般实现方式有两种：
服务器端返回，告知从哪开始浏览器端自行处理 上传过程中将文件在服务器写为临时文件，等全部写完了（文件上传完），将此临时文件重命名为正式文件即可
如果中途上传中断过，下次上传的时候根据当前临时文件大小，作为在客户端读取文件的偏移量，从此位置继续读取文件数据块，上传到服务器从此偏移量继续写入文件即可
实现思路 获取文件之后,保存文件唯一性标识,使用Blob.slice切割文件，分段上传，每次上传一段，根据唯一标识判断文件上传进度，直到文件的全部片段上传完毕
具体如下图
总结 在获取文件之后，使用Blob.slice方法将大文件切割成多个切片，并将文件唯一标识(一般指的md5)与切片下标组合成切片的hash,从而让上传切片的时候不仅能保证每个切片的唯一性还可以保证后端能够识别切片顺序，然后借助http的可并发性，同时上传多个切片，这样从原本传一个大文件，变成了同时传多个小的文件切片，从而大大减少上传时间。并且为了保证上传的可连续性，可以让服务端保存已上传的切片hash，前端每次上传前向服务端获取已上传的切片hash，通过切片hash获取上传进度，从而实现断点续传功能，进而避免了重复上传。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/661d09e09b535503d5701a3859ffab9a/" rel="bookmark">
			CentOS 7下Samba服务安装与配置详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CentOS 7下Samba服务安装与配置详解 一、Samba简介 Samba是在Linux和UNIX系统上实现SMB协议的一个免费软件，由服务器及客户端程序构成。SMB（Server Messages Block，信息服务块）是一种在局域网上共享文件和打印机的一种通信协议，它为局域网内的不同计算机之间提供文件及打印机等资源的共享服务。SMB协议是客户机/服务器型协议，客户机通过该协议可以访问服务器上的共享文件系统、打印机及其他资源。通过设置“NetBIOS over TCP/IP”使得Samba不但能与局域网络主机分享资源，还能与全世界的电脑分享资源。
Samba最大的功能就是可以用于Linux与windows系统直接的文件共享和打印共享，Samba既可以用于windows与Linux之间的文件共享，也可以用于Linux与Linux之间的资源共享。
Samba由两个主要程序组成，它们是smbd和nmbd。这两个守护进程在服务器启动到停止期间持续运行，功能各异。Smbd和nmbd使用的全部配置信息全都保存在smb.conf文件中。Smb.conf向smbd和nmbd两个守护进程说明输出什么以便共享，共享输出给谁及如何进行输出。
Samba提供了基于CIFS的四个服务：文件和打印服务、授权与被授权、名称解析、浏览服务。前两项服务由smbd提供，后两项服务则由nmbd提供。 简单地说，smbd进程的作用是处理到来的SMB软件包，为使用该软件包的资源与Linux进行协商，nmbd进程使主机(或工作站)能浏览Linux服务器。
二、Samba安装与配置 1.Samba安装与查看 a.安装samba应用 [root@Linuxidc-Server ~]# yum -y install samba samba-client b.启动Samba应用 [root@Linuxidc-Server ~]# systemctl start smb nmb c.查看Samba服务进程 #将smb/nmb添加到开机启动项 [root@Linuxidc-Server ~]# systemctl enable smb nmb d.查看smb和nmb进程状态 [root@Linuxidc-Server ~]# ps -ef | grep -E 'smb|nmb' root 9885 1 0 14:48 ? 00:00:00 /usr/sbin/nmbd root 9887 1 0 14:48 ? 00:00:00 /usr/sbin/smbd root 9888 9887 0 14:48 ? 00:00:00 /usr/sbin/smbd root 9889 9887 0 14:48 ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/661d09e09b535503d5701a3859ffab9a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e1f65fe5aa8f32e968ad78e1b85447b/" rel="bookmark">
			华为od机考攻略，参考资料
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		od机考大部分题目网上都能搜索到原题，答案有查重，需要修改答案
一、题型、编译问题 关于题型：
机考共三题，两道简单题目各100分，一道较难题目200分，满分400，150分及以上通过
简单：字符串/数组
简单：最短路径/关键路径
困难：二叉树/哈希算法
所有题型中，字符串处理是大头，占比接近30%，主要是分割匹配排序较多。 数组的运算题型较多，排列组合，连续数列的条件匹配较多。
困难题型主要有两类:
复杂的树，图，堆栈算法:考察最短路径和关键路径，图结构较多。或者是比较麻烦的功能类实现:考察模块化编程思想
数学运算的题型较多求模或者需要找到数学规律来做来设计，不要按照题型步骤编程，比如因式分解，就是找素数乘积，对于连续数组匹配，需要将数组转化处理不要想太复杂的排列组合优化等算法 关于编译：
1.建议人选使用牛客网编译器，因为牛客网没有快捷键，如果使用本地编译器则需要经常调试编译环境，否则就算本地跑通复制到牛客网后也会出现用例不通过的情况
2.人选一定要注意审题，按照题目要求做题，比如题目要求使用树，则必须用树的知识点进行解题，若用其他技术点就算跑通最后得分也是0
如果像算法题没有明确的要求使用某技术点，则可以用数学思维进行解题
3.如果实在没有解题思路，且题中没有具体的解题要求，可以尝试暴力拆解，最终得分要看具体情况
二、 判分标准 1、代码规范及可读性
最基本的要求，需要大家都能保证。不要随意命名、建议使用一种命名风格。禁止出现如下这种将代码写到一行的。完成代码后，将代码里面多余的注释、不用的代码等删掉再提交。
2、基本测试用例通过率
保证基本的用例能通过。算法实现后自测相关数据。
3、边缘测试用例通过率
算法实现后需要根据题目去自测边缘的相关数据。
三、 做题方法 牛客网的题目与leetcode等网站不一样，leetcode会给一个接口名，考生只需要实现该接口即可，而牛客网的题目不仅需要实现题目本身的算法内容，还需要接收输入和打印输出。
1、处理输入：将题目中描述的输入存入到变量中，大家可以提前熟悉下怎么获取输入。
2、接口实现：（建议：可以独立一个接口出来实现，将输入的数据传入这个接口处理，然后该接口返回输出数据。这种做法便于后续测试，测试时可以独立测试这个接口。）
3、处理输出：一般是将数据输出到控制台。
四、必练题型 1、输入输出样题
90%以上的人败在输入的处理上，机考题目本身的算法并不复杂，请各位注意一定练习，否则遇到较难处理的输入时会导致题目不过。
OJ在线编程常见输入输出练习：https://www.nowcoder.com/test/27976983/summary#question
必练输入题：https://ac.nowcoder.com/acm/contest/5657/J 此题必须练习，熟悉如何处理较为复杂的输入和输出。https://ac.nowcoder.com/acm/contest/5657#question 该链接可以查看正确答案。
2、算法、知识点
数学知识：素数、公约数、矩阵等
重要数据结构知识：字符串（概率很大）、数组（概率很大）、链表、队列、堆、栈、map/set，以及它们的排序算法。树、图等可以自行准备，考的概率不大。
字符串最后一个单词的长度、二叉树的遍历、最大括号深度、春游名单、勾股数元组
华为在线笔试练习链接：https://www.nowcoder.com/ta/huawei
考试注意事项（可以在系统里看到详细考前须知）：
1、请使用最新版 chrome 浏览器作答（72 版本以上） ，考试需开启摄像头，请确保电脑 带有摄像头；
2、考生只能在笔试页面在线编写和调试代码，手机监控，电脑摄像头都要打开，考试过程中不要故意取消监控。考试前关闭网页 QQ，网页微信等其它网站，考试过程中不要访问百度等其他网站，否则判定作弊成绩会作废。
3、考试答题时间 150 分钟，尽量在早上和安静情况下答题。
4、考试共三道编程题，考察更多的是基础知识和代码的规范性。答题前请注意查看示例（计 入 考试时长），代码完成后请务必点击【保存并调试】按扭，否则答案不作保存，不限制提 交运行次数（以提交中最高得分计分），调试完成点击【提交本题型】按钮，最后交卷；
5、考试时允许使用草稿纸，请提前准备纸笔。考试过程中允许上厕所等短暂离开，但请控制离开时间；
6、考试期间如遇到断电、断网、死机等问题，可以关闭浏览器重新打开试卷链接即可继续做题；
7、遇到问题请即时反馈给考试主办方。
8、机考链接为一周有效期，机考参加后半年之内不能再考
请提前登陆以下网址：熟悉题目方向、考点、试题难度，及所用编译包能否跑通
https://www.nowcoder.com/ta/huawei/
9、提升通过率链接 https://www.bilibili.com/video/BV1n5411t7WL?from=search&amp;seid=8904837019105257491
如果基础稍弱些：可以去搜文章"牛客网剑指offer+自己选择的编程语言"（例：牛客网剑指offer66题Java试题），也可以直接搜牛客网剑指offer+自己不太会的题型，这些文章上面都有详细的注解和编码步骤分析，可以自己关注一下
参考题目
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e1f65fe5aa8f32e968ad78e1b85447b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01705766f29511f621334334da4b3a33/" rel="bookmark">
			从零开始学C语言数据结构 : 二叉树的顺序结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		二叉树的顺序结构 1.树1.1树的概念1.2树的表示1.3二叉树 2.二叉树的顺序结构1.堆2.堆的实现2.1.向下调整2.2堆的创建——向下调整实现2.3建堆的时间复杂度2.4堆的插入——向上调整实现2.5堆的删除——向下调整实现2.6堆的作用——选数2.7二叉树的顺序结构 1.树 1.1树的概念 树是一种非线性的数据结构
顶层的第一个数据被称为根节点除了根节点外，其余结构与树类似的集合是子树树是递归定义的子树与子树时间不能有交集
———————————————————————————————
节点的度：一个节点含有的子树个数
叶节点：度为0的节点
分支节点：度不为0的节点
父节点：若一个节点有子节点，则称这个节点为子节点的父节点
子节点：一个节点包含其子树的跟节点称为该节点的子节点
兄弟节点：有相同父节点的节点
树的度：一整棵树中，最大的节点的度
节点的层次：从跟开始，跟为第一层，依次向下
树的深度/高度：树中节点的最大层次
节点的祖先：从根到该节点所经分支上的所有节点
子孙：以某节点为跟到该节点所经分支上的所有节点
森林：多颗互不相交的树称为森林 1.2树的表示 树有很多种表示方式如：双亲表示法，孩子表示法、孩子双亲表示法以及孩子兄弟表示法。
typedef int DataType; struct Node { strcut Node* Child; //指向下一个孩子 struct Node* Brother; //指向下一个兄弟 DataType data; //数据 } 1.3二叉树 二叉树不存在度大于2的节点二叉树子树有左右之分，不能颠倒，二叉树是有序树根节点的层数看成1（方便计算） 特殊二叉树：
1.满二叉树
如果一个二叉树的层数为K，节点总数是2^K-1，他就是满二叉树
（ 20+21+…+2(k-1)=2k-1 )
2.完全二叉树
前k-1层是满的，最后一层可以不满，但必须从左到右连续
（满二叉树是一种特殊的完全二叉树）
二叉树的性质：
非空二叉树第i层最多有2^(i-1)个节点若满二叉树有n个节点，则其深度k深度为k的二叉树，最大节点数为2^k-1 最小节点数为2^(k-1)
度为0节点总是比度为2的节点多一个——n0=n2+1（叶子节点度为1，是n1）二叉树从0依次编号，有：
LeftChild = Priests * 2 + 1 (左孩子：奇数)
RightChild = Priests * 2 + 2 (右孩子：偶数)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/01705766f29511f621334334da4b3a33/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6fbc5bbda0d11ecb1cb56544d1347977/" rel="bookmark">
			MAC AOSP代码编译和下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 前提：首先用mac的磁盘工具将mac的文件系统改一下，不然会报错
20:14:33 Failed to increase file limit: invalid argument 20:15:20 ************************************************************ 20:15:20 You are building on a case-insensitive filesystem. 20:15:20 Please move your source tree to a case-sensitive filesystem. 20:15:20 ************************************************************ 20:15:20 Case-insensitive filesystems not supported 修改如下：
或者用命令修改也可以
2. 配置aosp环境 &amp; 下载代码
mkdir AOSP &amp;&amp; cd AOSP/ curl https://storage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repo chmod a+x ~/bin/repo curl https://mirrors.tuna.tsinghua.edu.cn/git/git-repo &gt; ~/bin/repo chmod a+x ~/bin/repo export REPO_URL='https://mirrors.tuna.tsinghua.edu.cn/git/git-repo/' repo init -u https://mirrors.tuna.tsinghua.edu.cn/git/AOSP/platform/manifest -b android-13.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6fbc5bbda0d11ecb1cb56544d1347977/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0dee0b9c81028a4cf683fa79827d57da/" rel="bookmark">
			大海捞针 Skia(C&#43;&#43;) 第 3 期：绘制文本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 本期将正式给大家介绍Skia的使用。文章将涉及一个目的的多种方案多种情况。文章较长，请大家耐心阅读。
关键词：PNG图像、文件、文本、字符串、UTF8、UTF16、UTF32、编码转换、Visual Studio 设置、高级保存选项
案例 注意：接下来的案例都将使用PNG图像来存储查看绘制结果 Visual Studio 应将代码文件默认编码设置为UTF-8(建议不带BOM，即标准UTF8编码，操作教程如下：
Visual Studio 设置默认编码格式为 UTF-8 或 GB2312-80 与文件没有高级保存选项怎么显示
这里的常字符串不是专业术语，这里表达的意思是，代码中的字符串以及常量字符串。例如，我们在给一个string类付初始值时即会使用一个字符串例如"Hello, Skia!"，这样的字符串是固定的，因为代码中就是这样。因此编译的程序里也一定默认这样初始化。至于常量字符串，则是指const char*。
绘制代码中字符串步骤和上一期绘制"Hello, Skia!"一致，这里将详细介绍。
在绘制前，应确保你的Visual Studio项目已经配置好Skia库，具体步骤参考《大海捞针 Skia(C++) 第 1 期：Skia 环境搭建》。
绘制图像，就像画画一样，我们需要一个介质来存储我们的笔画痕迹。因而在Skia中，我们使用SkBitmap作为这个介质。
实例化一个SkBitmap：
SkBitmap bitmap; 好比绘画所用的纸也有规格参数，同样，上述这个介质也需要。用于描述这个参数的类叫做SkImageInfo。
我们可以通过如下方式，手动指定规格信息，但值得注意的是，生活中，绘画纸的参数是用于描述纸的，而在这里，参数是用于生成纸的，详情将在后面指出。这里，我们创建了一个信息块，同时为其填写信息，即：宽600px、高400px、RGBA颜色，同时设置使用Alpha通道。
SkImageInfo bitmapInfo = SkImageInfo::Make(600, 400, kRGBA_8888_SkColorType, kPremul_SkAlphaType); 接下来我们需要用这个信息分配空间。
bitmap.allocPixels(bitmapInfo); 接下来就是看起来不能理解但很合理的部分。bitmap作为我们绘制的介质我们却无法直接对其进行绘制，而提供一个SkCanvas供我们绘制。虽然显得有些繁琐，但其实却很合理。bitmap仅作为我们存储的地方。而SkCanvas作为绘制的部分。好比GUI程序界面与其内部数据是分离的，但却不可割舍其中一个。同理，绘制也是如此。SkCanvas并不存储数据，但却提供给我们绘制的方法；而SkBitmap不提供绘制方法，却允许我们将图像数据存储其中。这自然是很合理的。
那如何使用SkCanvas呢？首先，我们知道SkCanvas是不存储数据的，但提供绘制方法，那我们调用方法绘制时数据存何处？自然是SkBitmap，因此，我们需要为SkCanvas绑定一个存储数据的地方——SkBitmap。如下：
SkCanvas canvas(bitmap); 既然SkCanvas为我们提供了绘制的方法，那么，我们想要达成绘制字符串的目的，自然需要调用其中的方法。
这里有两个方法可以使用。
第一种，使用drawSimpleText方法；
第二种，使用drawString方法。
我相信大家也许去尝试使用这两个方法，然而发现这两个方法有许多参数。不急，我们慢慢解析。
第一种方法原型如下：
void drawSimpleText(const void *text, size_t byteLength, SkTextEncoding encoding, SkScalar x, SkScalar y, const SkFont &amp;font, SkPaint &amp;paint); text：待绘制的字符串
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0dee0b9c81028a4cf683fa79827d57da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c8b8b8d95f159e5226358633732cd16/" rel="bookmark">
			Java常用数据结构优劣势和应用场景
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 数组(Array)
定义
优势
劣势
应用场景
Java代码部分
链表(Linked List)
定义
优势
劣势
应用场景
Java代码部分
栈(Stack)
定义
特点
优势
劣势
应用场景
Java代码部分(使用栈)
Java代码部分(使用链表)
队列(Queue)
定义
特点
优势
应用场景
Java代码部分(使用数组)
Java代码部分(使用链表)
二叉树(Binary Tree)
定义
特点
优势
劣势
应用场景
Java代码部分
二叉查找树(Binary Search Tree)
定义
特点
优势
劣势
Java代码部分
堆(Heap)
定义
特点
优势
劣势
应用场景
Java部分代码(最大堆)
散列表/哈希表(Hashing)
定义
特点
优势
劣势
常用的Hash数据结构
应用场景
Java代码部分(查找唯一的字符串)
Java部分代码(计算一个字符串的字符)
图(Graph)
定义
特点
优势
劣势
应用场景
Java代码部分
数组(Array) 定义 数组是由相同类型的元素(element)的集合所组成的数据结构，分配一块连续的内存来存储。利用元素的索引(index)可以计算出该元素对应的存储地址。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c8b8b8d95f159e5226358633732cd16/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51ac295547f8f3e80aedd9e88134ad17/" rel="bookmark">
			用python写抢红包程序的具体代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		具体的代码取决于你想要实现的功能，但是可以参考下面的代码：# 导入模块 import random# 定义红包函数 def red_packet(amount,total_num): """ amount：总钱数 total_num：总份数 """ # 将总金额按照份数均分，保留2位小数 per_amount = round(amount / total_num, 2) # 生成一个随机数列表，长度为份数 random_list = [random.uniform(0, per_amount) for _ in range(to
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af0173b87cf4735e7bc890ccbacba1ce/" rel="bookmark">
			雪花算法的原理和实现Java
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SnowFlake 算法，是 Twitter 开源的分布式 id 生成算法。其核心思想就是：使用一个 64 bit 的 long 型的数字作为全局唯一 id。在分布式系统中的应用十分广泛，且ID 引入了时间戳，基本上保持自增的，后面的代码中有详细的注解。
这 64 个 bit 中，其中 1 个 bit 是不用的，然后用其中的 41 bit 作为毫秒数，用 10 bit 作为工作机器 id，12 bit 作为序列号。
给大家举个例子吧，比如下面那个 64 bit 的 long 型数字：
第一个部分，是 1 个 bit：0，这个是无意义的。
第二个部分是 41 个 bit：表示的是时间戳。
第三个部分是 5 个 bit：表示的是机房 id，10001。
第四个部分是 5 个 bit：表示的是机器 id，1 1001。
第五个部分是 12 个 bit：表示的序号，就是某个机房某台机器上这一毫秒内同时生成的 id 的序号，0000 00000000。
①1 bit：是不用的，为啥呢？
因为二进制里第一个 bit 为如果是 1，那么都是负数，但是我们生成的 id 都是正数，所以第一个 bit 统一都是 0。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/af0173b87cf4735e7bc890ccbacba1ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca2bd4e56b43831e9091e4f6f1b915a6/" rel="bookmark">
			多视图点云配准算法综述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：杨佳琪,张世坤,范世超等
转载自：华中科技大学学报（自然科学版）
编辑：东岸因为@一点人工一点智能
原文：​​多视图点云配准算法综述​​
摘要：以多视图点云配准为研究对象，对近二十余年的多视图点云配准相关研究工作进行了全面的分类归纳及总结。首先，阐述点云数据及多视图点云配准的概念。根据配准的任务不同，将多视图点云配准分为多视图点云粗配准和多视图点云精配准两大类，并对其各自算法的核心思想及算法改进进行介绍，其中，多视图点云粗配准算法进一步分为基于生成树和基于形状生成两类；多视图点云精配准算法进一步分为基于点云的点空间、基于点云的帧空间变换平均、基于深度学习和基于优化四类。然后，介绍了四种多视图点云配准数据集及主流多视图配准评价指标。最后，对该研究领域研究现状进行总结，指出存在的挑战，并给出了未来研究展望。
随着激光雷达(LiDAR)和Kinect等三维传感器的快速发展，点云已成为表征三维世界的主要数据格式。点云配准是计算机视觉、移动机器人学和计算机图形学等领域的一项基本任务，其在三维重建、三维定位、自动驾驶、位姿估计、逆向工程及虚拟现实等领域有着广泛应用。点云配准其实质是估计点云之间的刚体变换关系，通过变换关系将点云数据变换到统一参考坐标系。点云配准根据点云视图的数量，可分为两两视图点云配准和多视图点云配准。与两两视图点云配准相比，由于多视图点云配准须要求解大量的配准参数，其求解参数量远高于两两视图点云配准，因此难度更大，也是当前研究领域的热点问题。
然而，目前仍缺少全面的综述文献对多视图点云配准算法进行全面和系统的梳理，为了解决该问题，本研究对近二十余年的多视图点云配准算法研究进行了分类归纳及总结，旨在更加深入和全面地认识多视图点云配准算法的发展历程、算法思路、最新进展、常用​​数据库​​、评价指标、领域现存问题及未来潜在的发展趋势。
01 点云配准概述 随着计算机扫描技术与坐标测量技术的日益强大，获得包含物体几何属性与空间三维信息的海量离散点云数据，即离散点的集合，变得极为便捷。点云存储更加符合人对事物的观察习惯，以立体的形式直观展现。此外，点云数据结构简单，可以通过较小的存储代价精确地记录三维模型的几何结构和拓扑关系，避免了传统存储方式在处理过程中为了保持拓扑关系而强加的各种限制条件。
根据点云数据获取方式的不同，可分为接触式获取点云与非接触式获取点云。接触式获取点云[1]主要通过传感探头与被测模型的物理接触来获取三维点云数据，该方式不受物体表面颜色及光照等因素的限制，可以准确捕捉物体的轮廓边缘，但是速度很慢，且效率低。非接触式获取点云[2]主要是基于光学、磁学等领域的基本原理进行​​数据采集​​，其测量速度较快，效率较高，但是难以精确获得三维物体的轮廓边缘。基于光学方法的非接触式获取点云是目前主流的三维点云数据获取方法，图1展示了从不同角度所采集斯坦福大学数据集兔子模型10个视图的点云数据。
图1 斯坦福数据库兔子模型采集的多视图点云数据 点云配准旨在将不同坐标系获取的点云数据变换到同一坐标系，根据视图数量可分为两两视图点云配准和多视图点云配准。两两视图点云配准旨在将具有一定重叠区域的两组点云配准到一个坐标系，主要流程为：首先，将两组点云分别视为源点云与目标点云，提取两组点云的特征；然后，根据提取到的特征确定两组点云间的对应点；最后，根据对应点估计旋转平移参数，源点云根据旋转平移参数变换到目标点云坐标系。两两视图点云配准算法的研究已有较为全面的综述文献[3-6]。
相比之下，多视图点云配准因为求解参数量的增加及累积误差的存在，更具挑战性。多视图点云配准通过算法建立点云间的关联，将所有不同坐标系下的点云数据配准到参考坐标系。在多视图点云配准整个流程中，先进行多视图点云粗配准再进行多视图点云精配准是当前最广泛使用的多视图点云配准策略。多视图点云配准步骤如图2所示。
图2 多视图点云配准流程图 根据配准任务不同，可将多视图点云配准划分为多视图点云粗配准和多视图点云精配准，其中：多视图点云粗配准将所有视图点云数据初始对齐，为精配准提供良好的初始条件；多视图点云精配准则是在多视图点云粗配准的基础上，进一步消除所有视图点云间的累计误差，使得多个点云之间的配准累计误差尽最大可能被消除。鉴于目前尚无关于多视图点云刚性数据配准的综述工作，本研究首次对近二十余年的多视图点云配准算法进行归纳总结。如图3所示，本研究依据是否须要建立点云数据间的网络拓扑关系，将多视图点云粗配准算法分为基于生成树的多视图点云粗配准算法和基于形状生成的多视图点云粗配准算法；多视图精配准算法根据使用的点云和帧空间信息及核心算法不同，可进一步分为基于点空间多视图精配准算法、基于帧空间变换平均多视图精配准算法、基于深度学习的多视图精配准算法和基于优化的多视图精配准算法这四类。根据算法分类，本研究对该领域算法的发展历程、算法思路、最新进展、常用数据库、评价指标、领域现存问题及未来潜在的发展趋势进行介绍。
图3 多视图点云配准算法分类图 本研究的主要工作如下：a．针对多视图点云配准领域缺少全面综述的问题，对近二十余年的多视图点云配准算法进行分类、思路概述及优缺点总结；b．整理了四个当前主流的配准数据集及通用的多视图配准评价指标作为评判基准，为方法的公平对比提供参考，也揭示了该领域缺乏统一的数据库及方法评价指标的问题；c．根据算法综述，总结了领域的研究进展和现存挑战，并指出了未来发展趋势，为后续研究提供明确思路。
02 多视图点云粗配准 多视图点云粗配准在两两视图点云配准的基础上，直接或间接初始对齐多视图点云数据，其更多关注配准能否成功以及配准时间开销，该类算法只须要大致对齐多视图点云数据，在后续的多视图点云精配准中会消除多视图点云粗配准阶段所产生的配准累积误差。多视图粗配准算法根据是否建立点云数据间的网络拓扑关系，可分为基于生成树的多视图粗配准算法和基于形状生成的多视图粗配准算法。
2.1 基于生成树的多视图点云粗配准 基于生成树多视图点云粗配准算法的核心思想是把每个点云看作节点，首先根据节点间的关系构建生成树，根据生成树可以直接或间接配准任意两组点云；然后选择参考坐标系，通过相应点云间的运动变换将所有视图点云数据配准到参考坐标系。在基于生成树的多视图点云粗配准中，有三个关键问题须要在设计该类算法时考虑：a．判断两两视图点云配准成功与失败的评判依据；b．两两视图点云配准算法的选择；c．生成树根节点的选择。
基于生成树的多视图点云粗配准有两种方案获得生成树。第一种方案[7-9]：首先进行所有两两视图点云配准，若配准成功则建立连接，否则不建立连接；然后根据两两视图配准结果生成连通图；最后在连通图中根据一定的约束条件和最优条件获得生成树。虽然该类生成树算法能够得到较好的粗配准结果，但是生成树通过暴力穷举所有两两视图配准获得，假设有N片点云，使用同一种两两视图点云配准算法，该类生成树粗配准算法的时间复杂度高达O(N2)。
针对穷举两两视图点云配准来生成树算法存在的问题，于是便有了第二种方案，即改进的生成树多视图点云粗配准算法[10-12]：选择一点云作为生成树根节点，将剩余点云依次与根节点进行两两视图点云配准，若存在节点无法与根节点成功配准，则待所有节点与根节点完成配准，选择一个与根节点直接相连的节点作为新的根节点，继续两两视图点云进行配准，直到建立生成树。该算法相较于穷举两两视图点云配准来生成树的多视图粗配准算法，使用相同的两两配准算法，配准次数大幅度减少，从而大规模降低了粗配准时间开销。
改进的生成树多视图点云粗配准算法输入为个点云数据，输出为N个刚性变换矩阵。该算法首先选出根节点，放入根节点集合，剩余节点放入待配准集合。当待配准集合不空时，a．待配准集合的节点依次与根节点两两配准；b．若两两配准结果满足一定的条件，则与当前根节点建立连接，将当前节点从待配准集合移除并加入根节点集合，否则选择待配准集合中下一片点云；c．判断待配准集合的所有点云是否完成配准，若待配准集合为空，则该算法完成，否则从根节点的集合中选择一个节点作为新的根节点，返回步骤a。
文献[7]使用基于自旋图像特征描述子的生成树多视图点云粗配准算法。首先，该算法根据所有视图两两点云配准结果构建连通图；然后，根据连通图构建生成树；最后，通过生成树建立点云间关系完成多视图点云粗配准。由于该算法须要进行所有两两视图点云配准，因此非常耗时，不适用于大规模点云数据多视图点云配准。文献[8-9,13]使用相同构建生成树的方法，分别使用方向直方图特征、指数映射和极坐标映射算法进行两两视图点云配准。
针对第一类生成树算法时间复杂度高的问题，文献[14]首先将第一个读取点云作为根节点，设计双重评价标准判断两两视图点云配准的可靠性；然后依次添加点云进行两两视图点云配准，直到生成树构造完成；最后根据生成树完成多视图点云粗配准。随后，文献[10]进一步改进：使用点云间的重叠率作为判断一组点云是否进行两两视图点云配准的依据；依次将重叠率大于阈值的点云对进行两两视图点云配准，直到生成树构造完成；根据生成树完成多视图粗配准。
文献[11]提出连通图算法和超图算法来构建生成树，连接图算法将曲面面积最大的点云作为根节点，然后作为算法的输入，得到一颗生成树。超图算法与连接图算法类似，当根节点与所有点云配准完成后，从所有未能成功配准的点云中重新选择一个节点作为根节点来依次两两配准来生成连通图；通过子节点与其他连通图根节点连接得到生成树。文献[15]使用类似技术，基于三重旋转图像特征来完成多视图点云配准。文献[12]将点云中点数量最多的点云作为根节点替代曲面面积最大的点云，替代后配准效果不会明显变差，同时减少根节点选择所带来的时间开销，然后将根节点与其他节点划分到两个不同的集合；其他节点和根节点依次进行两两视图点云配准；通过随机抽样一致性算法的内点数来判断是否建立两节点之间的有向边。
文献[16]提出任意选择一点云作为根节点，将根节点的局部坐标系设置为全局参考坐标系；每个点云与根节点直接或间接完成两两视图点云配准，选取加权最短路径作为点云间接配准的最优路径；根据子节点到根节点的加权路径最短来构建最小生成树。
2.2 基于形状生成的多视图点云粗配准 基于形状生成的多视图点云粗配准算法核心是迭代生成种子性状点云数据，将其作为目标点云，增加源点云与目标点云的重叠率，从而提高配准成功的可能性。该类算法适用于点云之间重叠率较低的数据集。形状生成算法首先将所有点云初始化到搜索集合，然后任意选择一点云作为种子形状点云，并将种子形状点云从搜索集合移除；当搜索集合不为空集时，a．从搜索集合中选择一点云作为源点云与种子性状点云两两视图点云配准；b．若两两配准成功，则将种子形状点云更新，将源点云与种子性状点云非重叠部分点云数据加到种子形状点云中，并将源点云从搜索集合中移除，若两两配准失败，则选择搜索集合中的其他点云作为源点云。
文献[17]提出基于形状生成的多视图点云粗配准算法，该算法随机选择一个点云作为种子形状点云，剩余点云依次与种子形状点云两两配准，配准成功后更新种子形状点云，直到所有点云成功配准．该算法使用旋转投影统计特征提取匹配，根据设计的判断标准来寻找有效的两两点云配准进行点云形状生长。
与基于生成树多视图粗配准算法相比，形状生成多视图粗配准算法更适用于低重叠率的点云数据且不须要构造点云间网络拓扑结构。基于形状生成多视图粗配准示意图如图4所示。
图4 基于形状生成多视图粗配准示意图 ​03 多视图点云精配准算法 多视图点云粗配准得到一组点云初始对齐的变换矩阵作为多视图精配准的输入，多视图点云精配准则更多关注于多视图点云配准的精度。近年来，多视图点云精配准引起越来越多学者关注，陆续出现各种多视图点云精配准问题的解决方案。多视图点云精配准算法的关键是尽最大可能快速消除所有变换误差和配准累计误差。图5以时间顺序展示了多视图点云精配准研究历程中部分经典的算法。
图5 多视图点云精配准经典算法概述 ​3.1 基于点云的点空间变换多视图精配准算法 基于点云的点空间多视图精配准算法要求充分利用所有点云中可用点信息，考虑点云中对应点关系，将其作为约束优化变换参数。这里概述基于点云点空间的多视图精配准算法：基于正态分布变换，基于聚类，基于迭代最近点(ICP)及变种，基于信息熵理论的多视图精配准算法。基于点云的点空间多视图点云配准算法的分类如图6所示。
图6 基于点云点空间变换多视图精配准算法分类图 3.1.1 基于迭代最近点的多视图精配准 文献[18]提出ICP算法，后续众多基于迭代最近点的多视图点云精配准算法以该算法为核心展开研究。为找到点云间正确的点对应关系，该算法计算粗配准变换后源点云上所有点到目标点云的距离，将两片点云中距离最小的点对视为对应点；保证源点云上的点和目标点云的点相互对应，同时构造残差平方和目标函数；使用最小二乘法对误差函数进行最小化处理，经过反复迭代直到均方误差小于设定的阈值。ICP两两点云配准算法精度高，但该算法容易陷入局部最优解且容易受到噪声点的干扰。ICP算法选中两片点云分别作为源点云和目标点云，核心步骤如下：a．在目标点云Q中取点集；b．找出源点云P中对应点集，使对应点的距离最小；c．计算旋转矩阵和平移向量，使误差函数最小；d．对源点云进行刚性变换；e．计算对应点集的平均距离；f．若小于某一给定的阈值或大于预设的最大迭代次数，则停止迭代，否则返回步骤b，直到满足收敛条件为止。
文献[19]提出直接对两两ICP算法扩展，将多视图点云精配准视为两两点云ICP精配准；通过两个点云不断地用ICP精配准和合并点云数据的策略，依次配准和合并两个点云数据，直到所有点云数据合并到一个点云。该算法提供对齐和合并的多视图点云精配准框架，任意两两视图点云精配准算法都能直接应用到该框架，从而完成多视图点云精配准。该算法简单可行，但随着点云数据的合并，ICP精配准算法的对应点搜寻时间会增加，同时存在配准误差累计问题。
文献[20]首次提出针对多视图点云精配准的算法。该算法首先通过星形网络在所有点云间建立连接，星形网络的中心点云与其他点云互相寻找点对应关系；然后通过ICP算法估计点云数据间刚性变换；最后将配准误差最小作为目标函数优化每个点云的刚性变换参数。该算法同时考虑所有点云数据来优化配准参数，一定程度上解决误差累计问题，但须要为中心点云建立多个点对应关系，每个中心点云须要与其他所有点云数据进行两两配准，导致该算法耗时较长。
考虑到文献[20]提出的星网络ICP算法在建立点云间对应点关系过程中非常耗时，文献[21]使用高斯球型的多缓冲区来加速重叠区域点对应关系的建立，在建立点对应关系后，通过星网络ICP精配准算法来完成多视图精配准。
文献[22]提出利用颜色信息的ICP多视图点云精配准算法，同样使用两两点云ICP精配准和合并的方法。与之前方法不同的是：该方法不仅考虑点云数据中点空间的信息，而且考虑点云数据的颜色信息。由于该类算法使用点云数据的颜色信息，因此不适用于激光扫描等传感器获取不到颜色信息的点云数据。
文献[23]提出使用ICP算法配准多个点云，同时最小化所有点云的配准误差来获得全局最优刚性变换的算法。将配准问题转换为最小二乘配准误差函数最小化，将配准误差函数简化为包含未知矩阵和常数矩阵的二次表达式。
文献[24]提出使用广义普鲁克分析考虑同时配准所有点云数据，将其嵌入到ICP算法框架；在寻找匹配点对期间，只有两个点互相为最近邻点才是匹配点对；对于有多个匹配关系的点云，则忽略这些点对匹配；将每个匹配点对的质心求出，使用ICP算法求解最优刚性变换。
文献[17]将列文伯格-马奈尔特(LM)算法嵌入到ICP算法。该算法须要建立最小生成树，对所有点云沿最短加权路径，全局使用LM-ICP算法配准到全局参考坐标系。
文献[10]提出局部到全局多视图点云修剪迭代最近点精配准算法。该算法依次选中粗配准阶段生成树的第二层的一个节点作为源点云，根节点和第二层的其他节点点云合并作为目标点云，源点云和目标点云通过修剪迭代最近点算法(TrICP)进行配准；第二层点云经过层次遍历完成配准后；将根节点与第二层节点合并成为新的根节点；再进行新的根节点和第二层节点的局部多视图点云配准；直到所有节点合并到一个节点，局部多视图点云精配准完成。在此基础上进行全局多视图点云精配准，将每个点云依次作为源点云，其他所有点云数据作为目标点云，依次对源点云和目标点云通过TrICP进行多视图精配准。
文献[12]提出形状增长迭代最近点算法来消除多视图粗配准产生的累积误差。该算法将根节点作为形状生成的基准节点，通过对生成树的层次遍历依次将子节点与根节点进行两两ICP精配准，然后将子节点的点云数据非重叠部分添加到根节点合并，直到遍历完所有的节点。
文献[15]提出采用从粗到精的采样点云数据的方法以提高计算效率。当使用ICP算法时，只取源点云的一部分点，对点云进行随机采样和均匀采样，在ICP算法中配准性能相似。该算法使用随机采样获取点云，每次选取采样点的点数与配准误差相关，最初使用少量样本点以降低ICP算法的时间开销，当误差减小时，使用更多的样本点以提高配准精度。为进一步提高ICP算法的准确性和稳定性，在每次迭代中拒绝点到点距离大于平均网格分辨率两倍的所有异常点对。
3.1.2 基于聚类的多视图精配准 聚类可分为硬聚类和软聚类：硬聚类是指将数据确切地划分到一个确定的簇；软聚类是指将数据以一定概率分到各簇中。本研究将基于聚类的多视图精配准算法分为基于K均值(K-means)聚类多视图精配准算法和基于混合分布模型的多视图精配准算法。基于K-means聚类多视图精配准算法属于硬聚类，将所有点云数据的点划分到一个簇，簇内所有点跟对应的簇中心点进行对齐；基于混合分布模型的多视图精配准算法是软聚类问题，使用混合模型来表示点云数据，通过期望最大化算法来优化混合模型的参数，从而完成多视图点云精配准。基于聚类的多视图精配准算法精度高，且对噪声和异常值鲁棒，但由于须要建立大量的点对应关系，因此耗时较长。
a．基于K-means聚类的多视图精配准
K-means聚类算法最初由文献[25]引入点云配准领域，起初用于检测和合并点云重叠区域的对应点，不涉及更新刚性变换，后续便开始使用K-means聚类算法来完成多视图点云精配准。该类算法将不同视图点云配准问题转化为不同簇内点云对齐问题，将同一个簇内的点向簇中心逼近，没有考虑点云之间的一致性关系，一定程度上会影响配准精度。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca2bd4e56b43831e9091e4f6f1b915a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c797c1b809a8d96a186a27286eb4621/" rel="bookmark">
			配置samba服务实现Linux(CentOS7)与Windows之间的文件共享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Samba是一个开源软件套件，提供了在Windows和Linux操作系统上实现文件和打印机共享的功能，允许Windows、Unix、Linux等不同的操作系统之间共享文件和打印机资源。Samba可以将Linux或Windows系统配置为一个文件服务器，能够处理Windows客户端请求并提供文件和打印机服务，同时还支持Windows域控制器和活动目录服务，可以使Linux或Unix系统作为Windows网络中的一个成员。Samba还支持CIFS（Common Internet File System）协议，可以通过Internet或广域网访问共享资源。Samba软件套件包含一些主要组件：
smbd：实现文件和打印机共享服务nmbd：实现NetBIOS名称服务和WINS服务器winbindd：提供Windows域控制器认证和用户信息服务Samba在许多企业和组织中被广泛使用，它提供了一种便捷的方式，使得不同操作系统的计算机之间可以轻松地共享文件和打印机资源。 要在Windows和CentOS 7之间实现文件共享，可以使用Samba服务。以下是配置Samba服务的步骤：
安装Samba软件包 在CentOS 7中，使用以下命令安装Samba软件包：
sudo yum install samba 配置Samba服务 在CentOS 7中，Samba的配置文件位于 /etc/samba/smb.conf。使用以下命令备份原始配置文件：
sudo cp /etc/samba/smb.conf /etc/samba/smb.conf.bak 使用文本编辑器（如nano或vim）打开配置文件：
sudo nano /etc/samba/smb.conf 在文件末尾添加以下内容：
[share] path = /path/to/shared/folder writable = yes valid users = username guest ok = no 其中，[share]是共享文件夹的名称，path是共享文件夹的路径，writable指定该共享文件夹是否可写，valid users指定可以访问该共享文件夹的用户名，guest ok是否允许匿名访问该共享文件夹。
创建Samba用户 创建可以访问共享文件夹的用户。使用以下命令创建用户：
sudo useradd username sudo smbpasswd -a username 第一行创建一个新用户，第二行将该用户添加到Samba用户列表中。
启动Samba服务 使用以下命令启动Samba服务：
sudo systemctl start smb sudo systemctl enable smb 第一行启动Samba服务，第二行设置Samba服务在系统启动时自动启动。
防火墙配置 如果启用了防火墙，请确保将Samba端口添加到防火墙规则中：
sudo firewall-cmd --add-service=samba --permanent sudo firewall-cmd --reload 配置完成后，可以从Windows访问共享文件夹。在Windows资源管理器中，输入以下地址：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c797c1b809a8d96a186a27286eb4621/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/710849a51cf73f48d64fc02da2467dfe/" rel="bookmark">
			uniapp 使用高德地图 对路线进行纠偏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		红的是纠偏前路线,蓝的是纠偏后路线
安装依赖
npm i @amap/amap-jsapi-loader --save 例子代码
&lt;template&gt; &lt;div&gt; &lt;div id="container" style="width: 100%; height: 300px;"&gt;&lt;/div&gt; &lt;button @click="Polyline"&gt;点击测试&lt;/button&gt; &lt;button @click="graspRoad1"&gt;轨迹纠偏&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import AMapLoader from '@amap/amap-jsapi-loader'; window._AMapSecurityConfig = { securityJsCode: ''//你的安全秘钥 } export default { data() { return { map: null, AMap:null, graspRoad:null } }, mounted(){ this.init(); }, methods: { init(){ AMapLoader.load({ "key": "", // 申请好的Web端开发者Key，首次调用 load 时必填 "version": "2.0", // 指定要加载的 JSAPI 的版本，缺省时默认为 1.4.15 "plugins": ["AMap.GraspRoad"], // 需要使用的的插件列表，如比例尺'AMap.Scale'等 }).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/710849a51cf73f48d64fc02da2467dfe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83254150c893c33f96aef711db021fa9/" rel="bookmark">
			设计模式第七讲-外观模式、适配器模式、模板方法模式详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. 外观模式 1. 背景 在现实生活中，常常存在办事较复杂的例子，如办房产证或注册一家公司，有时要同多个部门联系，这时要是有一个综合部门能解决一切手续问题就好了。
软件设计也是这样，当一个系统的功能越来越强，子系统会越来越多，客户对系统的访问也变得越来越复杂。这时如果系统内部发生改变，客户端也要跟着改变，这违背了“开闭原则”，也违背了“迪米特法则”，所以有必要为多个子系统提供一个统一的接口，从而降低系统的耦合度，这就是外观模式的目标。
2. 定义和特点 (1). 定义
是一种通过为多个复杂的子系统提供一个一致的接口，而使这些子系统更加容易被访问的模式。该模式对外有一个统一接口，外部应用程序不用关心内部子系统的具体的细节，这样会大大降低应用程序的复杂度，提高了程序的可维护性。
(2). 优点
A. 降低了子系统与客户端之间的耦合度，使得子系统的变化不会影响调用它的客户类。
B. 对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加容易。
C. 降低了大型软件系统中的编译依赖性，简化了系统在不同平台之间的移植过程，因为编译一个子系统不会影响其他的子系统，也不会影响外观对象。
(3). 缺点
A. 不能很好地限制客户使用子系统类。
B. 增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”。
3. 具体实现 (1). 模式结构
A. 外观角色：为多个子系统对外提供一个共同的接口。
B. 子系统角色：实现系统的部分功能，客户可以通过外观角色访问它。
C. 客户端：通过一个外观角色访问各个子系统的功能。
结构图如下：
(2). 使用场景
见下面代码。
(3). 代码实操
子系统代码
/// &lt;summary&gt; /// 子业务类1 /// &lt;/summary&gt; public class ChildService1 { public void MyHandler1() { Console.WriteLine("我正在处理业务1"); } } /// &lt;summary&gt; /// 子业务类2 /// &lt;/summary&gt; public class ChildService2 { public void MyHandler2() { Console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/83254150c893c33f96aef711db021fa9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50929ce885b6bee36e17aee2ba41a378/" rel="bookmark">
			反射和注解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、反射——框架设计的灵魂
二、反射获取字节码Class对象的三种方式
三、Class对象的功能概述
四、注解
4.1 JDK中预定义的注解
1.限定父类重写方法:@Override
2.标示已过时:@Deprecated
3.抑制编译器警告:@SuppressWarnings
4.“堆污染”警告与@SafeVarargs
5.函数式接口与@Functionallnterface
4.2 自定义注解
4.3 元注解
4.4 在程序中使用（解析）注解：获取注解中定义的属性值
一、反射——框架设计的灵魂 框架：半成品软件。可以在框架的基础上进行软件开发，简化代码。
反射：将类的各个部分封装为其他对象，这就是反射机制。
好处：
1.可以在程序运行过程中操作这些对象
2.可以解耦，可以提高程序的可扩展性
java在计算机中经历的阶段： 二、反射获取字节码Class对象的三种方式 获取Class对象的方式：
1.Class.forName("全类名")：将字节码文件加载进内存，返回Class对象（多用于配置文件，将类名定义在配置文件中。读取文件，加载类）
2.类名.class：通过类名的属性class获取（多用于参数的传递）
3.对象.getClass()：getClass()方法在object类中定义着（多用于对象的获取字节码方式）
结论：同一个字节码文件（*.class）在一次程序运行过程中，只会被加载一次，不论通过哪一种方式获取的class对象都是。
三、Class对象的功能概述 class对象的功能：
1.获取成员变量
Field[ ] getFields:获取所有public修饰的成员变量
Field getField(String name):获取指定名称的成员变量
Field[ ] getDeclaredFields():获取所有的成员变量
Field getDeclaredField(String name):
2.获取构造方法
Constructor&lt;?&gt;[ ] getConstructors()
Constructor&lt;?&gt;[ ] getConstructor(类&lt;?&gt;... parameterTypes)
Constructor&lt;?&gt;[ ] getDeclaredConstructor(类&lt;?&gt;...parameterType)
Constructor&lt;?&gt;[ ] getDeclaredConstructors()
3.获取成员方法
Method[ ] getMethods()
Method getMethod(String name,类&lt;?&gt;... paramterTypes)
4.获取类名
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/50929ce885b6bee36e17aee2ba41a378/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/626e3a2e608eb65bbb503e33b6392dea/" rel="bookmark">
			SpringBoot起步依赖、自动配置、整合其他框架、事件监听、监控、部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、SpringBoot功能
二、SpringBoot快速入门
三、SpringBoot起步依赖原理分析
四、SpringBoot配置
4.1 配置文件分类
4.2 yaml
4.3 yml数据格式
4.4 读取配置内容
4.5 profile
​4.6 内部配置加载顺序
4.7 外部配置的加载顺序
五、SpringBoot整合其它框架
5.1 SpringBoot整合Junit
5.2 SpringBoot整合Redis
5.3 SpringBoot整合Mybatis
六、 Springboot自动配置 6.1 Condition
6.2 切换内置服务器
6.3 Enable*注解
6.4 Import注解
6.5 EnableAutoConfiguration注解
​6.6 自定义starter步骤分析
七、SpringBoot监听机制
八、SpringBoot启动流程分析
九、SpringBoot监控
十、SpringBoot项目部署
一、SpringBoot功能 二、SpringBoot快速入门 导入父工程：
&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.6.1&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; 导入JavaWeb起步依赖： &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; 定义Controller：
import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; @RestController public class HelloController { @RequestMapping("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/626e3a2e608eb65bbb503e33b6392dea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5571e357fda1db6386ae50be141340ca/" rel="bookmark">
			Building wheel for opencv-python (PEP 517) 卡住
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在pip3 install opencv-python时，在如下地方卡住不动了
Building wheel for opencv-python (PEP 517) ... 经过调查发现是pip3版本低了，使用下面命令升级pip3即可
pip3 install --upgrade pip 本机的环境用这种方法解决了，当然不同的环境出现这个问题的原因也不同。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d29f345483b42f722628b7bf1299da30/" rel="bookmark">
			统信UOS配置IP地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 配置IP地址 首先查看我们有什么网卡 命令修改IP地址 nmcli connection modify ens33 ipv4.method manual ipv4.addresses 192.168.10.1/24 autoconnect yes #使用nmcli命令可以配置IP地址 nmcli connection reload #重启网卡 nmcli connection up ens33 #开启ens33网卡 配置文件修改IP地址 vim /etc/sysconfig/network-scripts/ifcfg-ens33 TYPE=Ethernet #网卡类型为以太网类型 PROXY_METHOD=none BROWSER_ONLY=no BOOTPROTO=none #网卡设置为none DEFROUTE=yes IPV4_FAILURE_FATAL=no IPV6INIT=yes IPV6_AUTOCONF=yes IPV6_DEFROUTE=yes IPV6_FAILURE_FATAL=no NAME=ens33 UUID=1651f482-5841-4579-b91c-75eac2756096 DEVICE=ens33 ONBOOT=yes #加入到开机自启 IPADDR=192.168.10.1 #配置IP地址 PREFIX=24 #子网掩码为24位 systemctl restart network-online.target #重启网络 ip add #查看IP地址 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d67b5dceb26bff4cb81f92908a430387/" rel="bookmark">
			Microsoft.Extensions.Configuration 中检测到版本冲突。直接安装/引用 Microsoft.Extensions.Configuration 3.0.1...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很抱歉，我不了解Microsoft.Extensions.Configuration，但是可以提供一些建议：检查是否有不同版本的Microsoft.Extensions.Configuration程序集在应用程序中引用；检查NuGet包的依赖关系，确保不存在冲突；卸载旧版本的Microsoft.Extensions.Configuration，然后安装新版本的Microsoft.Extensions.Configuration 3.0.1。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4cfcff60ee6cf26f512fd09a460821a/" rel="bookmark">
			python 利用chinese_calendar 获取上一个工作日日期
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 **截止文章发布chinese_calendar版本为1.8.0，大约在每年的11月份更新次年的节假日新版本
import datetime from chinese_calendar import is_workday def get_pervious_work_day(day: datetime): """获取上一个工作日""" day = day - datetime.timedelta(days=1) if is_workday(day): return day return get_pervious_work_day(day) 测试周六日：
today = datetime.date.today().replace(day=20) date = get_pervious_work_day(today) print(date) 测试2023春节：
today = datetime.date.today().replace(day=28).replace(month=1) date = get_pervious_work_day(today) print(date) 测试2023劳动节：
today = datetime.date.today().replace(day=4).replace(month=5) date = get_pervious_work_day(today) print(date) 测试2023国庆节：
today = datetime.date.today().replace(day=7).replace(month=10) date = get_pervious_work_day(today) print(date) Everything is going smoothly. 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6959601e2c3c3e7d904d382949853fd7/" rel="bookmark">
			Spring基础总结(上)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring基础总结(上) 1. Spring 如何创建一个 Bean 对象 通过调用对象的无参构造方法创建一个新对象，然后通过依赖注入得到bean对象(默认单例)依赖注入这一步对新对象中添加了 @Autowired 或者@Resource 等注解的属性赋值，得到 Bean 对象，如下是一段伪代码
//1.通过无参构造函数创建一个新对象 userService UserService userService = new UserService(); //2.遍历对象的属性，给添加了 @Autowired 注解的属性赋值 for(Field field : userService.getClass().getDeclaredFields()) { if(field.isAnnotationPresent(Autowired.class)) { field.set(userService, ??) } } ... ... 2. 什么是单例池？作用是什么？先看如下代码 AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class); UserService userService1 = (UserService)context.getBean("userService"); UserService userService2 = (UserService)context.getBean("userService"); System.out.println(userService1.equals(userService2)); // true 我们可以发现获取到的两个 UserService 对象是相同的，这说明 spring 有一个类似 Map 的集合来保存单例 Bean，key 值为 bean 的 name 属性，value 的值为 bean 本身，这个保存 bean 的集合就是单例池，它的作用就是用来存储单例 Bean 对象；如果是多例 Bean，就不会被放入到单例池
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6959601e2c3c3e7d904d382949853fd7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2bce32dbaeaa6ba6b3fa31f2a7699ed7/" rel="bookmark">
			AD从文档中复制文字批量放置不同网络标签
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当遇到特别是主芯片引脚网络标号较多时，在画原理图的过程中，可以使用AD自带的智能粘贴功能 在可复制文字的文档中，试过Excel表格，ctrl+c(复制)，然后在AD原理图窗口中shift+ctrl+v（智能粘贴），就会弹出如下界面：
选择完之后，就会生成和文本内容一致的网络标号（Net Labels）。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c7c1dc7079e89c480b40ac7e9f6ce7f/" rel="bookmark">
			【ArcGIS自定义脚本工具】批量执行栅格计算器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、功能介绍二、脚本代码三、工具参数四、用例4.1 批量单位换算4.2 批量计算植被覆盖度4.3 批量填充空值 系列文章目录： ArcGIS自定义脚本工具 一、功能介绍 功能
将多个栅格文件按照某以代数表达式执行栅格计算器(Raster Calculator) 工具，并将输出栅格文件保存至指定的文件夹中。该工具接受代数表达式的动态输入。通过修改代数表达式可以实现批量对栅格执行四则运算（加、减、乘、除）、计算掩膜、填充空值（固定值、插值）、设为空等操作。关于代数表达式
提供的代数表达式需要满足栅格计算器工具代数表达式的基本语法，并且包含字符串"{A}“，字符串”{A}"代表输入栅格在代数表达式中的位置。在用例章节提供了几个案例。
二、脚本代码 #!/usr/bin/python # -*- coding: UTF-8 -*- import arcpy import os import time rasters = arcpy.GetParameterAsText(0) expression = arcpy.GetParameterAsText(1) # expression including {A} out_path = arcpy.GetParameterAsText(2) prefix = arcpy.GetParameterAsText(3) rasters = rasters.split(";") nums = len(rasters) num = 1 for raster in rasters: raster_path = raster.replace("'","") raster_dir,raster_name = os.path.split(raster_path) arcpy.env.workspace = raster_dir out_raster = os.path.join(out_path, prefix + raster_name) exp = expression.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c7c1dc7079e89c480b40ac7e9f6ce7f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05eb8e88edd9d6aafbe893d14c2a77d6/" rel="bookmark">
			Java创建对象时静态代码块、动态代码块、构造函数、初始化的顺序及方法区、堆、栈的变化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 Reyco郭-Spring4-010-SpringIoc第一个程序-对象创建的复习 package com; public class Test { public int k = 999; static { System.out.println("执行静态块"); //System.out.println("k = "+k); // 编译错误 } { System.out.println("执行动态块"); System.out.println("k = "+k); // 输入99 } public Test() { System.out.println("执行构建方法"); System.out.println("k = "+k); // 输入99 } public static void main(String args[]) { Test t = new Test(); } } 从上面的执行结果得出的执行顺序： 静态代码块动态代码块无参构造函数问题1：什么是创建一个对象（java类的实例）？jvm在堆中给新对象分配内存空间和对对象进行初始化，哪个先哪个后？ 答：创建一个对象（java类的实例）分为2步： 第1步：就是在堆内存中给它分配内存空间。第2步：对对象进行初始化。问题2：jvm在堆内存中给新对象分配内存空间，具体分配内存空间给什么东西？ 答：在堆中给对象分配内存空间，其实就是给对象的成员变量分配堆内存空间。如上面的Test.java类在创建对象时，在堆内存中分配内存空间就是给成员变量 int k = 99分配的那个空间（12个字节）。问题3：什么叫对象初始化完毕？ 答：如果新对象中的所有成员变量都初始化完了，才说明整个对象初始化完毕。问题4：开始执行无参构造函数的前，JVM给是否已经给这个新对象分配堆中的堆内存空间？开始执行无参构造函数的前，新对象的初始化完毕了没有？当无参构造器执行的时候，对象创建了没有？是执行无参构造器的时候，对象已经创建好了？还是执行无参构造器的过程中创建对象的？还是无参构造器的方法执行完毕以后对象才创建好？ 答：执行构造器的前，jvm已经在堆内存中给此新对象分配堆内存空间了，并且jvm也已经给新对象初始化完毕了。证明：因为创建对象的执行顺序是静态代码块 》动态代码块 》无参构造函数，而且在执行动态代码块时输出了"k = 99"，所以说明在执行无参构造函数之前已经创建好对象（堆内存中给它分配内存空间，且对对象进行初始化）完毕了。问题5：一个空类（没有任何成员变量，如Object obj = new Object()）在创建对象时，jvm会在堆内存中给此新对象分配多少个字节知道吗？1个没有成员变量的对象在堆内存中占有几个字节？ 答：8个字节。因为所有的类都是继承自Object.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05eb8e88edd9d6aafbe893d14c2a77d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d7d7dfed4c2af2a5e9626f468abc2b6/" rel="bookmark">
			思科模拟器：交换机&amp;路由器 密码设置（明文&amp;密文&amp;加密明文）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境：思科模拟器
一个路由器一个交换机
两者密码配置一样！！！！！！！！！！！
两者密码配置一样！！！！！！！！！！！
两者密码配置一样！！！！！！！！！！！
均为 console 口密码 还有 进入特权模式密码
这是没有配置密码的直接进入
进入特权密码配置
全局模式下
特权明文密码
enable password 123 特权密文密码
enable secret 1234 enable password + 密码 （123就是我设置的密码）
enable secret + 密码 （123就是我设置的密码）
明文密文区别下边会说到
这时进入特权就要密码了
如果先配置明文密码再配置密文，密文会覆盖掉明文
--
console 口密码配置
line console 0 这个就是进入console 0 口如果真机还有别的接口也是和这个一样改下后边数字就行
password +密码 login 是启用
进入时候就要密码了
上边说到的明文密文
我们在特权模式下输入
show running-config 可以看到
配置信息中
明文就是我们写的密码而密文，是乱码
就连con 口 都是明文
如果我们想直接把明文加密成密文
在全局使用
service password-encryption 去加密明文
这时候我们再去查看
这时刚刚的明文都变成密文了
如果你要配置交换机也和这个一样
两者密码配置一样！！！！！！！！！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae1f728a5da7a957ec94fba6256db42f/" rel="bookmark">
			esp32cam与stm32如何进行串口通信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		STM32和ESP32Cam可以通过串口进行通信，可以使用UART(Universal Asynchronous Receiver/Transmitter)接口实现。 STM32和ESP32Cam需要设置相同的波特率和数据位，并使用相同的校验位和停止位，才能进行串口通信。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1518f66aa2657a5953c7296639f723e9/" rel="bookmark">
			osg间接绘制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		osg3.6（准确版本没有考证）开始引入了间接绘制。对应的opengl接口为：glMultiDrawElementsIndirect() ；
在例子Examples osgsimpleMDI中有对应的代码。
接口原形：
void glMultiDrawElementsIndirect(GLenum mode, GLenum type, const void* indirect, GLsizei drawcount, GLsizei stride); 相较于glDrawElements(),普通的绘制命令，间接绘制只需要提交一次drawcall，减少cpu的消耗，从而达到提高效率的效果。
osg的间接绘制也需要绘制单元：
struct DrawCmd { GLuint count; GLuint instanceCount; GLuint firstIndex; GLint baseVertex; GLuint baseInstance; }; 一个DrawCmd代表一个绘制单元，
count：索引个数
instanceCount：实例总数（一般情况下为1）
firstIndex：该单元的第一索引位置（单元的索引偏移量）
baseVertex：单元顶点总数
baseInstance：实例化的偏移量
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f102f1c2aaf27f7b3ab373eb8c8e7c4c/" rel="bookmark">
			python如何让一个列表的元素随机且不重复排列到另一个列表中
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 你可以使用 Python 的 random 模块中的 shuffle 函数来随机打乱一个列表中的元素。为了确保元素不重复，你可以使用 copy 函数创建一个原列表的副本，打乱副本的顺序，然后将其放入新列表中。以下是一个例子：
importrandom # 原始列表 original_list = [1, 2, 3, 4, 5] # 复制列表 shuffled_list = original_list.copy() # 打乱副本顺序 random.shuffle(shuffled_list) # 输出结果 print("原始列表:", original_list) print("随机列表:", shuffled_list) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7cdb4d7198e8d4b08c6a3373fb292afd/" rel="bookmark">
			stm32hal库串口重映射
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#ifdef __GNUC_ #define PUTCHAR_PROTOTYPE int __io_putchar(int ch) #else #define PUTCHAR_PROTOTYPE int fputc(int ch, FILE *f) #endif //重映射printf的功能 PUTCHAR_PROTOTYPE { HAL_UART_Transmit(&amp;huart1, (uint8_t *)&amp;ch, 1, 0xFFFF); return ch; } &amp;huart1改成对应的串口，keil里面记得选微库
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0d4dc284929b52da569f5c82417357c/" rel="bookmark">
			[NetBackup]客户端安装后server无法连通client
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		client name处填写客户端主机名，server to use for backups and restores处填写server端名字，与hosts文件内保持一致；source client for restores处填写client主机名，与server端hosts文件中保持一致，与主机实际名称保持一致。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69b9c062a94b2485e07cd5a6cda5285c/" rel="bookmark">
			torch_sparse安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在pytorch官网下载文件
https://pytorch-geometric.com/whl/
找到匹配自己的torch和cuda版本
其中cp后面的数字表示自己python的版本，比如cp37表示python3.7
将路径改变到文件所在文件夹，使用pip命令进行安装，格式为 pip install name.whl
pip install torch_sparse-0.6.10-cp37-cp37m-win_amd64.whl 如果出现下面的问题表示这个轮子不合适使用下面命令查看一下适配的版本 pip debug --verbose 因此，重新下载cp38的文件，在重新安装
安装成功 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c631961cbf7adce7c260cb4f6ac75045/" rel="bookmark">
			Python运算符（基础）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		包换几类 比如算术运算符 赋值运算符 逻辑运算符 以及位运算符
算数运算符就是为基础的 加+ 减- 乘 * 除/ 余% 整除// 次方**
以下为运行过程
运行结果如图所示:
算术运算符还可以用来给变量计算 :
运算结果如下:
2.赋值运算符
简单来说就是 将一个值赋予一个变量 举例说明
i0 = 100 i0+= 10 # 拆分就是 i0 = i0 + 10 print(i0) #输出结果就为110 公式即为 a+=10 等同于 a=a+10
加 减 乘 除 余 整除 次方 制用套公式即可
需要注意 在 余% 的时候给出的结果为浮点数；
3.逻辑运算符
逻辑运算符 只有三个 and, or, 以及 not
and 的含义是 and左右两侧都是真的才为真 如果左侧为真则关注右侧
如果左侧为假则回到左侧
or 表义 为 两侧有一个为真就为真
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c631961cbf7adce7c260cb4f6ac75045/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f8e93d5a82c3cd64a39c659ad306585/" rel="bookmark">
			Python五种基本数据类型以及类型转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. 整型int
整型就是表示没有小数点的整数，在python中用int表达，其中包括正整数负整数和0
python平时用到的为十进制整型，其中包括0~9，十进制整型不能以0开头(除非这个数本身就是0)
1.整形转浮点型floa(int),结果会保留小数点后一位
2.整形转布尔值 bool(int), 0会被转成False，除0之外都会被转成True
3.整形转字符串 str(int)，直接被当作字符输出，不再能参与运算
二.浮点型float
浮点型简单来说就是表示带有小数的数据，在python中用float表达
因为浮点数和整数在计算机内部存储的方式是不同的，所以整数运算永远是精确的，然而浮点数的运算则可能会有一些四舍五入的误差
1.浮点型转整形int(float),结果会删除小数点以及小数点后所有数字
2.浮点型转布尔值 bool(float), 0.0会被转成False，除0.0之外都会被转成True
3.浮点型转字符串 str(float)，直接被当作字符输出，不再能参与运算
三.布尔值bool
Python中布尔值表示以下两个：True（真）和False（假）
可用于数据之间的比较来获取True或者False
布尔值bool转整形int和浮点型float的时候 True--&gt;1，False--&gt;0
布尔值转字符串会被直接当作字符输出
所有类型皆可转为布尔值
四.字符串str
字符串简单来说就是由多个字符组成的串
字符串str转布尔值bool的时候，空意义的值转成False，其他都会被转成True
数字字符串可以转为整形或者浮点型，转换后可参与运算
所有类型皆可转为字符串
五.None
Python中空不等于0 ，空有意义
空转布尔值为False
空转字符串会被当做字符输出
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c67eb0b3d738634698a40f534d4742f/" rel="bookmark">
			Windows的torch &#43; Cuda &#43; cuDNN
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、CUDA下载
使用NVIDIA-SMI命令查看合适自己电脑的CUDA版本
nvidia-smi 进入NVIDIA官网下载CUDA
https://developer.nvidia.com/cuda-toolkit-archive
找到合适电脑版本的CUDA版本
点击CUDA Toolkit 10.2进入下载页面，选择操作系统版本，架构，电脑系统版本，安装类型选择local，然后选择base installer下载CUDA
2、 cuDNN下载
根据下载的CUDA版本选择cuDNN下载，CUDA版本一定要和cuDNN版本想对应 进入到NVIDIA官网，下载对应的cuDNN
https://developer.nvidia.com/rdp/cudnn-archive
选择cuDNN v8.1.0版本然后选择cuDNN Library for Windows 10
首次下载cuDNN要先使用邮箱注册，注册完在重新选择下载即可 3、CUDA安装
使用默认安装路径就可以，一定要安装在c盘
同意下一步
选择自定义安装
后面安装选项默认即可
4、cuDNN
将下载的压缩包解压，并将文件夹中的所有内容复制到cuda的文件夹，替换同名文件夹
CUDA和cuDNN安装完成
5、安装pytorch
（1）打开anaconda prompt
（2）创建一个使用pytorch的新环境
conda create -n pytorch-gpu python=3.7 （3）进入环境
根据提示进入环境
conda activate pytorch-gpu （4）进入pytorch官网查看安装命令 https://pytorch.org/get-started/previous-versions/
一定要和CUDA版本对应，否则会出现问题 pip install torch==1.8.1+cu102 torchvision==0.9.1+cu102 torchaudio==0.8.1 -f https://download.pytorch.org/whl/torch_stable.html （5）安装完成以后验证是否安装成功
import torch torch.__version__ torch.cuda.is_available() 结果返回true表示安装成功
6、torch-geometric安装
在pytorch官网找到下载地址
Installation — pytorch_geometric documentation
官网只有最新的两个版本的pytorch下载，因此找到历史版本，下载
点击torch-1.8.1+cu102，然后，选择参数与python版本相同的四个文件进行下载，其中cp37表示python版本3.7
，
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c67eb0b3d738634698a40f534d4742f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad880c67788e09ea5915881e0fafaa9d/" rel="bookmark">
			Python5种类型的基本数据转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一，Python5种数据类型汇总； python的五种基本类型 分别有 整数 ， 浮点数 ， 布尔值 ，字符串 ， 空;
整数就是由基本数值来表示 比如： 100 300 20 等等；
浮点数有两种表达方式 1 基本表达 比如：3.14 等有小数点的数值;
2 科学计数法 比如： 314e-2 e-2意为除以10的2次方 314/100=3.14
0.314e1 e1意为乘以10的1次方 0.314*10**1=3.14
两种表达方式都可以用来表达浮点数；
布尔值属于逻辑性的 只有两个值 Ture , flase 一般用来逻辑性运算
如 ：1&gt;2 那么结果就为 flase 1&lt;2 那么结果就为 Ture;
字符串类型 有三种类型 分别是 1.单引号 ' ' 2.双引号 "" 3. 三引号 """ """ 三种引号里面可以添加任何符号，字母，数字等来组成字符串；
比如
'qwrwe231#@#%%+-' "123+-*/abcdefg" 以上是单双引号使用的方法 而单双引号也可以进行串联使用
以上可以清楚的看到系统报错 是因为三个单引号 而系统认为前两个单引号里的代码或句子是一段完整的
而后面添加的单引号就失去了意义 加了双引号就可以这么用
意为双引号里面的为一个字符串 这就是单双引号的用法；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad880c67788e09ea5915881e0fafaa9d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/301e988ee9712a658674259531cc9094/" rel="bookmark">
			完美解决HAL库HAL_UART_Transmit_DMA（）不延时就发不了下一条的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题原因 在连续用HAL_UART_Transmit_DMA（）函数的时候，会遇到只能发出第一条的问题，原因是DMA传输数据到串口这个外设太快了，传输完后程序并不会在该处停留，但是串口发送需要时间，运行到下一条HAL_UART_Transmit_DMA（）函数的时候，上一条数据还没来得及发完，导致串处于BUZY（即 HAL_UART_STATE_BUSY ）状态
如果串口处于BUZY状态，则HAL_UART_Transmit_DMA（）不会进入发送程序，直接return HAL_BUSY;这就导致了HAL_UART_Transmit_DMA（）不能连续运行，
目前网上主流的解决办法是延时一定时间或while(HAL_DMA_GetState(&amp;hdma_usart1_tx) == HAL_DMA_STATE_BUZY)，等串口发完数据在执行下一条指令。但是这样让CPU卡在这里，让DMA和串口外设的速度优势荡然无存，并且，HAL_DMA_GetState（）好像只要初始化之后它的状态就不会生变化，要采用if((&amp;huart1)-&gt;gState == HAL_UART_STATE_READY)进行判断比较有用。
于是我采用了如下办法
解决方法 while (1) { if((&amp;huart1)-&gt;gState == HAL_UART_STATE_READY) { if(dma_uartThread == 4) dma_uartThread=0; dma_state=1; dma_uartThread++; } if(dma_state) { switch(dma_uartThread) { case 1: HAL_UART_Transmit_DMA(&amp;huart1,dma_sentTest1,sizeof(dma_sentTest1)); dma_state=0; break; case 2: HAL_UART_Transmit_DMA(&amp;huart1,dma_sentTest2,sizeof(dma_sentTest2)); dma_state=0; break; case 3: HAL_UART_Transmit_DMA(&amp;huart1,dma_sentTest3,sizeof(dma_sentTest3)); dma_state=0; break; case 4: HAL_UART_Transmit_DMA(&amp;huart1,dma_sentTest4,sizeof(dma_sentTest4)); dma_state=0; break; } } /* USER CODE END WHILE */ /* USER CODE BEGIN 3 */ } 解释说明： uint8_t dma_sentTest1[]="\r\n111AAABBBCCC\r\n"; //测试用字符串1 uint8_t dma_sentTest2[]="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/301e988ee9712a658674259531cc9094/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1559a5bcf4dd844167248a6f8005f55b/" rel="bookmark">
			vue前端项目引用高德离线地图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于上一篇下载离线地图瓦片的工具有问题，需要更换工具重新下载离线瓦片，步骤如下：
下载离线瓦片（后端） 1.1用MapDownloader,下载离线地图瓦片 工具提取码: mmdl
需要对工具作如下配置 ： MapDownloader.exe.config 文件进行修改
保存之后运行 MapDownloader.exe文件
1.2 选择mysql数据库，然后选择要下载得地图，下载数据量不易过大，我选择贵州省得8-11级地图，根据需求下载地图层级 数据越多下载越慢，还容易卡住，可以分层级下载，下载一个层级导出一个层级最后整合到一个文件夹下
1.3 生成静态的图片文件放在服务器 需要导出工具链接: GISMysqlToLoacal
提取码:gisc
运行其中的 GISMysqlToLocal.exe 配置数据库信息
选择本地储存目录（可以直接放到自己的项目里，也可以先放在其他文件下）
导出文件
文件夹里面是按顺序排列的地图层级
在前端代码中使用地图 AMapLoader.load({ key: "", // 申请好的Web端开发者Key，首次调用 load 时必填 version: "2.0", // 指定要加载的 JSAPI 的版本，缺省时默认为 1.4.15 plugins: ["AMap.Scale","AMap.DistrictSearch"], //需要使用的的插件列表，如比例尺'AMap.Scale'等 }) .then((AMap) =&gt; { var googleMapLayer = new AMap.TileLayer({ getTileUrl: function (x, y, z) { return "/788865972/" + z + "/" + x + "/" + y + "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1559a5bcf4dd844167248a6f8005f55b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7324174d3179ae40a2ed21e3a81230d6/" rel="bookmark">
			python exe文件解包方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		技术背景 目前针对Python中主流的加密方案有以下几种：
序号工具方法描述优缺点1Nuitka.py 文件先被转成了 .c 文件，然后被编译成 .o 文件，最后合并成 .bin 可执行文件，从 bin 到 C 是不可逆的，从 C 到 Python 也是不可逆的，因此代码是安全的工作量小，安全性高，使用加密之后的Python便捷；编译时间长，过程复杂2发行.pyc文件通过compileall模块将.py文件转为.pyc文件，该文件是二进制，无法直接看源代码，而python解释器可以直接执行.pyc文件台兼容性好，.py 能在哪里运行，.pyc 就能在哪里运行；解释器兼容性差，.pyc 只能在特定版本的解释器上运行。有现成的反编译工具，破解成本低3代码混淆（oxyry，pyobfuscate）让人看不懂代码，移除注释和文档，改变缩进，在tokens中间加入一定空格，重命名函数、类、变量，在空白行插入无效代码提高了一点源码破解门槛。兼容性好，只要源码逻辑能做到兼容，混淆代码亦能；只能对单个文件混淆，无法做到多个互相有联系的源码文件的联动混淆4py2exe将源码编译为 .pyc 文件，加之必要的依赖文件，一起打包成一个可执行文件。最终 py2exe 打包出的是二进制文件。直接打包成 exe，方便分发和执行。破解门槛比 .pyc 更高一些；兼容性差，只能运行在 Windows 系统上。生成的可执行文件内的布局是明确、公开的，可以找到源码对应的 .pyc 文件，进而反编译出源码。5Cython将 .py/.pyx 编译为 .c 文件，再将 .c 文件编译为 .so(Unix) 或 .pyd(Windows)生成的二进制 .so 或 .pyd 文件难以破解。同时带来了性能提升；兼容性稍差，对于不同版本的操作系统，可能需要重新编译。虽然支持大多数 Python 代码，但如果一旦发现部分代码不支持，完善成本较高。6Pyinstaller打包为exe文件，将Python文件转换为exe文件，以及dist文件夹和build文件夹，如果要移植到其他电脑上运行，也是只需要将这两个文件夹复制到对方电脑上，即使对方没有python环境，也可以运行程序，具有较好的兼容性；pyinstxtractor.py可以进行反编译 对于上述这些加密，在工作中，常见将一些Python写的脚本、程序使用Pyinstaller打包为exe文件的居多，因为即使对方没有python环境，也可以运行程序，具有较好的兼容性。
想要了解这些脚本、程序的逻辑、对其功能进行分析，最好的方法是其进行反编译解包。
解包思路 1.对exe文件进行解包 方法1：使用pyinstxtractor.py
执行python pyinstxtractor.py &lt;待解包文件名&gt; ，如果成功，即可获得&lt;待解包文件名&gt;_extracted 文件夹。
方法2：使用archive_viewer.py
执行python archive_viewer.py &lt;待解包文件名&gt; ，会打印EXE文件中包含的所有文件信息
使用x &lt;文件名&gt;命令将想要提取出的文件提取出来，q 命令退出。
区别：
方法1 可以一次性提取出所有文件，方法2只能逐个提取文件。但是在个人使用时，同时执行时会提示python版本问题，想要正常解包必须使用正确的python版本。
方法2 的成功率相对较高。可以先尝试用方法1，失败后用方法2。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7324174d3179ae40a2ed21e3a81230d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76b7a20c0b9f645451a0e77fd5a759d1/" rel="bookmark">
			Maven项目缺少jar的操作方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		maven配置settings.xml内容如下： &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;!-- Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to you under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/76b7a20c0b9f645451a0e77fd5a759d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d25d03375315e3ccfc7739998bb2bb5d/" rel="bookmark">
			java中的选择结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
本章目标
为什么需要if选择结构
什么是if选择结构 使用复杂条件下的if选择结构 使用if-else选择结构
为什么使用多重if选择结构
什么是多重if选择结构
如何使用多重if选择结构 为什么使用嵌套if选择结构
嵌套if选择结构
总结
本章目标 为什么需要if选择结构 什么是if选择结构 使用复杂条件下的if选择结构 使用if-else选择结构 为什么使用多重if选择结构 什么是多重if选择结构 如何使用多重if选择结构 为什么使用嵌套if选择结构 嵌套if选择结构 总结 选择结构二 为什么使用switch选择结构 什么是switch选择结构 如何使用switch选择结构 常见错误 比较switch和多重if选择结构 选择结构总结 补充： 总结 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4946faa13a6b59f76ca8ebf43673e5c/" rel="bookmark">
			vivado 抓取信号：mark debug 和 ILA
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一、通过 添加 mark debug
1、进行综合
2、抓取信号
3、保存
4、查看信号
二、通过 ILA IP核
1. 在Vivado 的 IP栏里添加ILA 2. 在需要用到的模块里例化 ILA
三、对比
总结
前言 在对FPGA编程时，我们经常需要从与FPGA相连的芯片中读取信号，可以用FPGA芯片特定的软件来抓取信号，下面是用vivado抓取信号的两个方法。
一、通过 添加 mark debug 在需要观察的信号前面加：(* MARK_DEBUG="true" *)
(* MARK_DEBUG="true" *)output CpSl_PLL1CE_o , (* MARK_DEBUG="true" *)output CpSl_PLL1CSB_o , (* MARK_DEBUG="true" *)output CpSl_PLL1CLK_o , (* MARK_DEBUG="true" *)output CpSl_PLL1SDI_o , (* MARK_DEBUG="true" *)input CpSl_PLL1SDI_i 1、进行综合 左击 run synthesis 进行综合。
2、抓取信号 左击如图所示的小三角，一定要是小三角。
左击set up debug，稍等一会儿，就能在出来的界面上选择要观察的信号了。
时钟标红的地方，右击标红的地方，选择 select clock domain ，选择要使用的时钟即可。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e4946faa13a6b59f76ca8ebf43673e5c/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/179/">«</a>
	<span class="pagination__item pagination__item--current">180/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/181/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>