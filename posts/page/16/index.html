<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab95a052be373f6f700e0278943f98c8/" rel="bookmark">
			CSS中元素设置定位，水平居中布局分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		水平布局的决定因素
left+margin-left+border-left+padding-left+width+padding-right+border-right+margin-right+right
-当开启决定定位后，水平方向的布局等式就会加上left，right两个值,此时规则和之前一样，只是多添加了两个值
-当发生过度约束时
1:如果9个值中没有auto，则自动调整right值以使等式满足
2:如果有auto，则自动调整auto的值以使等式满足
-可设置auto的值
margin width left right
-因为left和right的值默认是auto，所以如果不设置left和right，则等式不满足时，就会自动调整这两个值
-在left，right设置为0的时候，如果width设置auto，，无论margin如何设置，都是调整width
总结：优先级：right&gt;left&gt;margin-right,margin-left
垂直布局
等式也必须满足
top+margin-top+····+botoom
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge" /&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box1 { width: 400px; height: 400px; background-color: palegreen; position: relative; } .box2 { width: 100px; height: 100px; background-color: orange; position: absolute; left: 0; right: 0; top: 0; bottom: 0; margin: auto; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab95a052be373f6f700e0278943f98c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c26d168977fcf316592be67334c9fed/" rel="bookmark">
			[Note]Excel如何在无规律字符左端补零补齐到对应位数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		公式：
=REPT(0,8-LEN(A1))&amp;(A1) 实际效果：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67a08e813a55178646ef66a0d671b471/" rel="bookmark">
			如何设计前后端分离的系统架构？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何将前端页面和后端Java代码进行集成？ 将前端页面和后端Java代码进行集成通常需要使用一些特定的工具和技术。以下是一些常见的方法：
使用RESTful API：REST（Representational State Transfer）是一种基于HTTP协议构建的轻量级、可伸缩的Web服务架构。Java后端可以通过实现RESTful API来提供数据和服务，前端页面可以通过HTTP请求来调用这些API。常用的Java框架有Spring Boot、Jersey、Dropwizard等。使用Spring MVC框架：Spring MVC是一个Java Web框架，它实现了MVC设计模式，可以方便地将前端页面和后端Java代码进行集成。Spring MVC使用控制器来处理用户请求，并将结果返回给前端页面。常用的Java框架还有Spring、Spring Boot等。使用WebSocket：WebSocket是一种实现双向通信的协议，它可以在浏览器和服务器之间建立长连接，实现实时通信。Java后端可以通过实现WebSocket服务器来接收和响应前端页面的请求，常用的Java框架有Spring WebSocket、Tomcat WebSocket等。使用Ajax技术：Ajax（Asynchronous JavaScript and XML）是一种使用JavaScript向服务器发送异步请求的技术，可以在不刷新页面的情况下更新部分网页内容。前端页面可以通过Ajax向Java后端发送请求，并使用JavaScript处理返回的结果。常用的库有jQuery、Axios等。 总的来说，将前端页面和后端Java代码进行集成的技术有很多种，你可以根据具体的需求和场景选择适合的技术和框架。
如何设计前后端分离的系统架构？ 前后端分离的系统架构是指将系统的前端和后端部分分开设计和开发，通常采用独立的代码库、数据库和服务器部署，以实现更好的解耦和可扩展性。下面是设计前后端分离的系统架构的一些步骤：
确定系统需求和功能：首先需要明确系统的需求和功能，包括用户界面、业务逻辑、数据存储等。划分前后端职责：根据系统需求和功能，划分前后端的职责。前端主要负责用户交互和展示，后端主要负责数据处理和业务逻辑。设计API接口：前后端之间通过API接口进行通信。在设计API接口时，需要考虑接口的稳定性、可扩展性、安全性等因素。前端开发：前端可以使用任何适合的技术栈进行开发，如React、Vue、Angular等。前端通过API接口向后端发送请求，获取数据并展示给用户。后端开发：后端也可以使用任何适合的技术栈进行开发，如Spring Boot、Django、Flask等。后端处理前端发送的请求，处理数据并返回结果给前端。数据库设计：前后端分离的系统通常采用独立的数据库设计。需要根据系统需求和功能设计数据库表结构，并编写相应的SQL语句。服务器部署：前后端代码分别部署在不同的服务器上，以实现更好的负载均衡和可扩展性。可以使用云服务提供商的服务器实例或自建服务器。测试和调试：对前后端进行分别的测试和调试，确保系统的稳定性和正确性。部署上线：将前后端代码部署到生产环境中，并进行监控和维护，确保系统的正常运行。 总之，前后端分离的系统架构可以带来更好的可扩展性和可维护性，但也需要考虑一些额外的设计和开发成本。在实际应用中，需要根据具体情况进行权衡和选择。
如何实现分布式系统和微服务？ 实现分布式系统和微服务需要一些关键步骤和原则，以下是一些建议：
定义系统边界：首先需要确定系统的边界和功能，以便将系统划分为不同的服务和组件。这有助于将系统拆分为可独立部署和扩展的微服务。确定微服务架构：微服务架构是将系统拆分为一系列小型、独立的服务，每个服务都运行在自己的进程中，通过轻量级通信机制进行通信。确定微服务架构需要考虑系统的可伸缩性、可用性、容错性等因素。划分服务边界：根据系统需求和功能，将系统划分为不同的服务。每个服务应该具有单一职责，并通过API接口与其他服务通信。编写服务接口：为每个服务编写API接口，API接口应该遵循RESTful原则或gRPC等分布式服务框架，以确保不同服务之间的通信和互操作性。实现服务端逻辑：为每个服务编写后端逻辑代码，实现API接口定义的功能。实现客户端逻辑：在前端应用程序中编写客户端代码，调用API接口与后端服务进行通信，并处理返回的数据。数据库设计：为每个服务设计独立的数据库或共享数据库，并编写相应的SQL语句和ORM映射文件，以确保数据的正确性和一致性。部署和测试：将每个服务分别部署到不同的服务器或容器中，并进行测试和调试，以确保系统的稳定性和正确性。监控和维护：对系统进行监控和维护，确保系统的正常运行和可用性。 实现分布式系统和微服务需要深入的技术知识和经验，同时需要考虑系统的可扩展性、可用性、容错性等因素。在实际应用中，需要根据具体情况进行权衡和选择。
如何考虑系统的可扩展性和可维护性？ 系统的可扩展性和可维护性是设计分布式系统和微服务时需要考虑的重要因素。以下是一些建议：
单一职责原则：每个微服务应该具有单一职责，负责完成特定的功能。这有助于提高服务的可维护性和可扩展性。模块化设计：将代码划分为独立的模块，每个模块负责完成特定的功能。这有助于提高代码的可读性和可维护性，同时方便模块之间的替换和升级。分布式缓存：使用分布式缓存技术，如Redis或Memcached，可以提高系统的性能和可扩展性。缓存常用的数据和查询结果，可以减轻数据库的负载，提高系统的响应速度和可扩展性。负载均衡：使用负载均衡器，如Nginx或HAProxy，可以将请求分发到多个服务实例上，提高系统的可扩展性和可用性。当某个服务实例出现故障时，负载均衡器可以将其从服务列表中移除，避免故障扩散。服务发现：使用服务发现机制，如ZooKeeper或Consul，可以让服务实例动态地找到彼此的地址和端口号，避免手动配置的繁琐和容易出错的问题。这有助于提高系统的可维护性和可扩展性。自动化部署：使用自动化部署工具，如Jenkins或Docker，可以简化部署过程，提高系统的可维护性和可扩展性。当需要升级或替换某个服务时，可以通过自动化部署工具实现自动化编译、打包、部署和监控。监控和日志：对系统进行全面的监控和记录日志，以便及时发现和解决问题。使用监控工具和日志分析工具，如Prometheus、Grafana和ELK Stack（Elasticsearch、Logstash和Kibana），可以提高系统的可维护性和可扩展性。 总之，考虑系统的可扩展性和可维护性需要从多个方面入手，包括代码设计、数据库设计、部署和监控等方面。在实际应用中，需要根据具体情况进行权衡和选择。
如何设计系统的安全性和权限控制？ 设计系统的安全性和权限控制需要考虑多个方面，以下是一些建议：
身份认证和授权： 身份认证是权限控制的基础，可以通过用户名/密码、OAuth 2.0、JWT等方式进行身份认证。对于敏感操作，可能需要使用更强的身份认证方式，如多因素认证。授权是对用户或角色执行特定操作的权限控制。可以使用基于角色的访问控制（RBAC）或基于属性的访问控制（ABAC）等方式进行授权。 访问控制： 制定合适的访问控制策略，包括对资源的保护、对操作的控制等。使用令牌（token）来验证用户身份和授权信息，并限制令牌的访问范围和使用时间。 数据加密： 对于敏感数据，使用加密技术进行保护。例如，在传输数据时使用HTTPS或SSL等加密协议。在存储数据时，可以使用数据库加密或数据脱敏技术来保护敏感数据。 API安全： 确保API接口的安全性，防止恶意用户的攻击。可以添加身份认证、访问控制、日志记录和限流等功能。使用安全协议（如HTTPS）来保护API接口的数据传输。 敏感信息管理： 严格管理系统的敏感信息，如数据库密码、API密钥等。将这些信息存储在安全的地方，例如使用密码管理工具或专用的密钥管理服务。 日志和监控： 对系统进行全面的日志记录和监控，以便及时发现和应对安全事件。使用日志分析工具和监控工具，如ELK Stack、Prometheus和Grafana等，可以提高系统的可维护性和安全性。 安全审计： 定期进行安全审计，检查系统的安全性，识别潜在的安全风险和漏洞。及时修复已知的问题，并采取必要的措施来增强系统的安全性。 定期进行漏洞扫描和安全测试： 对系统进行定期的漏洞扫描和安全测试是发现和修复潜在安全问题的有效方法。可以使用专业的漏洞扫描工具和安全测试工具来评估系统的安全性。 限制不必要的暴露： 尽可能减少对系统内部细节的暴露，例如限制API接口返回的数据字段数量或隐藏敏感数据。对于外部接口或第三方集成，需要仔细考虑接口的安全性和授权控制方式。 安全培训和意识提升： 对开发人员、测试人员和运维人员进行安全培训和意识提升，提高他们对常见安全问题和最佳实践的认识。鼓励员工在日常工作中保持警惕，及时报告可疑行为或安全事件。 总之，设计系统的安全性和权限控制需要综合考虑多个方面，并采取综合措施来提高系统的安全性。在实际应用中，需要根据具体情况进行权衡和选择。
如何将多个框架进行整合？ 将多个框架进行整合可以通过以下步骤实现：
确定整合的框架和目的：首先需要确定要整合的框架和整合的目的。常见的框架包括Spring、Struts、MyBatis、Hibernate等。整合的目的可以是简化开发流程、提高开发效率、降低维护成本等。配置框架的依赖关系：根据框架的依赖关系，需要将它们按照一定的顺序进行配置。通常情况下，Spring是最底层的基础框架，MyBatis和Hibernate作为数据访问层框架，Struts作为表现层框架。配置整合的组件：根据整合的目的和需要，需要配置需要整合的组件。例如，如果需要整合Spring和MyBatis，需要在Spring配置文件中配置MyBatis的Mapper接口和SqlSessionFactoryBean。编写整合代码：根据整合的目的和需要，需要编写相应的整合代码。例如，如果需要整合Spring和Struts，需要在Struts的Action中注入Spring的Service或DAO组件，并调用其方法进行业务处理。测试和调试：在完成整合后，需要进行测试和调试，确保各个框架能够正常工作并协调一致。 需要注意的是，在整合多个框架时，需要考虑各个框架的特性和限制，以及整合后可能带来的问题。同时，需要结合具体的项目需求和情况进行选择和调整。
如何处理框架之间的冲突和集成问题？ 处理框架之间的冲突和集成问题可以采取以下措施：
了解框架之间的依赖关系：在整合多个框架之前，需要了解各个框架之间的依赖关系，包括框架之间的调用关系和依赖的版本号。这有助于避免冲突和集成问题。配置框架的依赖：在项目构建和配置文件中，需要明确各个框架的依赖关系，包括库的引入、路径配置等。这有助于确保框架之间的正确调用和集成。处理冲突：当多个框架之间存在冲突时，需要仔细分析并找出冲突的原因。可以采用以下几种方式解决冲突： 优先执行补充协议：如果框架合同和补充协议之间存在冲突，通常认为补充协议具有优先执行权。因为补充协议的目的是为了解决特殊情况下的问题，在执行的过程中必须考虑到补充协议的具体内容，及时作出适当的处理。修改框架合同：在补充协议中修改框架合同的条款时，通常需要将修改的内容充分地列出来。这包括修改文字、删除、新增和重组等方式。同时，还需要谨慎地考虑修改的内容是否会与原有的合同条款产生冲突以及是否会影响到合同履行。如果发现修改内容与原有的合同条款存在重大区别，应及时与对方协商解决，避免合同履行问题的发生。明确变更原因和范围：在补充协议中明确变更原因和范围非常重要。变更原因是指补充协议的制定目的，例如某个项目需要新增服务或者减少服务等。变更范围指的是修改内容所涵盖的具体条款或者是涉及整个合同的变更。只有明确了变更的原因和范围，双方才能更好地进行协商和签署补充协议，确保变更的合法性和有效性。 使用构建工具管理依赖：使用构建工具如Maven、Gradle等可以帮助管理项目的依赖关系。通过在项目配置文件（如pom.xml或build.gradle）中声明所需的框架依赖，构建工具会自动下载和安装这些依赖，避免了手动管理和配置的繁琐。同时，构建工具还可以自动解决依赖冲突问题，确保所使用的框架版本兼容。进行测试和调试：在完成框架整合后，需要进行测试和调试，确保各个框架能够正常工作并协调一致。这可以帮助及时发现和解决框架之间的冲突和集成问题。 总之，处理框架之间的冲突和集成问题需要仔细分析并采取适当的措施。通过了解框架之间的依赖关系、配置框架的依赖、处理冲突、使用构建工具管理依赖以及进行测试和调试等方法，可以有效地解决这些问题，确保项目的顺利进行。
如何使用第三方库和插件来增强系统的功能？ 使用第三方库和插件可以有效地增强系统的功能，以下是一些建议：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/67a08e813a55178646ef66a0d671b471/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d32d409f21566d5ba2a506c38a90ab8/" rel="bookmark">
			阿尔泰科技融合信息产业国产化成果，率先完成的全国产化测控系统软硬件构架。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		阿尔泰科技具有20多年测控系统自主研制软硬件的产品积累，在国产化需求的浪潮中，其软件的跨平台特性 ，得到最好的价值体现，基于近年来信息产业的国产化成果，经过大量的软硬件适配，可以为测控市场提供软、硬件全国产化的二次开发平台。
同一个功能使用统一的驱动层封装结构，若硬件型号更换或者升级换代，因为统一的接口管理，客户的二次开发应用程序可继续使用不用修改。 阿尔泰自主研发的ArtDAQ、 ArtScope、ArtSwitch驱动软件，是实现二次开发平台全国产化的核心技术，囊括了各种国产化板卡：AIO、DIO、计数器，声音振动，信号采集，高速数采集、矩阵开关、万用表等多种功能，统一管理多种型号的数据采集卡。 阿尔泰科技具有20多年测控系统自主研制软硬件的产品积累，在国产化需求的浪潮中，其软件的跨平台特性 ，得到最好的价值体现，基于近年来信息产业的国产化成果，经过大量的软硬件适配，可以为测控市场提供软、硬件全国产化的二次开发平台。
客户只需关注应用程序的开发，而不用关心底层硬件、驱动、操作系统的协同工作机制，这是二次开发平台的基本要求。作为全国产化的二次开发平台提供商，阿尔泰已经完成国产化的操作系统、计算机主板、总线、扩展板卡、驱动程序之间的适配工作。
并且签署三方联合认证证书，绑定生态厂家为客户提供协同有效的技术支持。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd7a403e872220babd6fcc2c31aa6655/" rel="bookmark">
			无线通讯干扰源分析及解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		“无线通讯设备稳定不稳定？”这个问题若是被工厂的技术人员提出的话，99%的人都希望得到一个关于无线产品可靠性的答案。如果单从技术层面来说明，由实验室出具的产品可靠性数据分析报告就可回答这个问题。但这些数据对于实际的现场状况来说， 实验室环境还是太纯粹了些。这种报告数据并不能提供给我们足够的信心去尝试和使用无线通讯设备。
若是站在一个无线通讯从业者的角度来讲，无线通讯受干扰因素远比有线通讯方式要不可控太多。但随着无线通讯技术的提高和现场经验的总结，我们发现的影响无线传输的干扰因素越多，那么无线通讯设备的可靠性也将成正比例提升。也就是需要给产品可靠性实验室数据加一个使用寿命的参考以及一个专门应对不可控事件发生的经验丰富的技术团队。
因此要将无线通讯产品做到稳定可靠，可以得出以下公式：无线产品可靠性=可靠性测试数据+平均使用寿命+技术服务团队
一 、产生干扰的因素
企业实际生产过程中，无论是外接电路、气候条件、环境电磁场或是人为干扰在产品不进行有效处理的情况下都会严重影响到所有电子仪器的传输数据精度以及产品内部的运行稳定性，这些因素主要分为以下几类：
1.地环流干扰
在工业生产过程中实现监视和控制需要用到各种自动化仪表、控制系统和执行机构，它们之间的信号传输既有微弱到毫伏级、微安级的小信号，又有几十伏，甚至数千伏、数百安培的大信号。既有低频直流信号，也有高频脉冲信号等等，构成系统后往往发现在仪表和设备之间信号传输互相干扰，造成系统不稳定甚至误操作。由于仪表和设备之间的参考点之间存在电势差(也就是各设备的共地点不同)因而形成“地环流”、“接地环流”问题。因此，要保证系统稳定和可靠的运行，“接地环路”问题是在系统信号处理过程中必须解决的问题。
2.环境干扰
工业现场的作业条件大多不符合精密仪器的运行条件，比如无线终端的安装地点大多在户外、粉尘较多的车间、存在机械振动的大型机械上等，这些工作环境对于电子产品的运行稳定性和使用寿命提出了严苛的考验。因此如何让精密仪器适应恶劣环境工作，一直是工业级无线通讯产品在技术上希望不断完善的地方。“无线”不再会因为稳定性而被不断质疑，能够让用户体验一次投入、运行稳定、无需维护并长期使用的特点。
3.电磁噪声干扰
自然界充满了各种来源和各种频段的电磁波，会影响仪器仪表的使用和无线通信的信息传输，因此分析电磁波特性和解决方式很有必要。宇宙噪音是电离辐射产生的，在一天中不断变化，噪声起源于地球大气层外的银河系中心部分以及太阳噪音，太阳噪音则随着太阳活动情况而剧烈变化。雷电是种主要的自然干扰源，雷电产生的干扰可以传输到数千公里以外的地方。雷电干扰的时域波形是叠加在一串随机脉冲背景上的一个大尖峰脉冲。电磁噪声主要会对通讯产生干扰，而雷屯能量尖蜂脉冲更可以对很多设备造成损坏，因此无线终端需要有效避免噪声对设备产生干扰和损坏设备的可能性，以尽可能避免用户的损失。
4.人为干扰
人为产生的电磁干扰根本原因是导体中有电压或电流的变化，即较大dv/dt或di/dt。dv/dt或di/dt能够使导体产生电磁波辐射。一方面，人们可以利用这一特点实现特定功能，例如，无线通信、雷达或其他功能，另方面，电子设备在工作时，由于导体中的dv/dt 或di/at会产生伴随电磁辐射。无论主观上出于什么目的，客观上对电磁环境造成了污染。还有工厂企业在生产过程中会经常有一些大型的设备(电机、变频器)频繁开关，他们也会造成一些容性、感性的干扰，也将影响仪器仪表正常显示或采集。凡是有电压电流突变的场合，肯定会有电磁干扰存在。数字脉冲电路就是一种典型的十扰源，随着电子技术的广泛应用，电磁污染情况会越来越严重。
二、干扰源处理方式
基于以上所提出的干扰问题，我们总结了如下几点的解决方法和处理意见。通过实际测验，可以有效的解决在一些工业场合中无线通讯设备所遇到的一部分干扰问题。
1.地环流处理方法
在各个过程环节中使用信号隔离器 ，断开过程环路，同时又不影响过程信号的正常传输，从而彻底解决地环路的问题。信号隔离器可以用DCS或PLC等隔离卡件或者现场带的隔离的变送器(部分设备可以做到)，也可以用信号隔离器来实现。
2.气候干扰的解决方法
终端箱体封闭设计，尽可能地隔离外界环境，使得内部仪器处于稳定的工作环境。
3.电磁噪声干扰解决方法
电磁干扰的三要素是干扰源、敏感源和耦合路径，寻找解决方法也需从这三要素入手。一般干扰源和敏感源是属于不可控因素，只能根据经验和对于工厂环境的了解给出一些有效的解决方法。因此，解决电磁干扰的方法，通常是从耦合路径上着手，这也是最常用的方法，如通过加屏蔽、加滤波等手段。解决方法如下:
1.箱体结构，可以有效屏蔽外界电磁干扰。
2.短波加密的无线传输技术，从传输方式上尽可能避免被干扰的可能性。
3.设备设计做避雷考虑，避免终端设备的损毁，终端外部箱体有效屏蔽了外部电磁场对终端内部电路的影响。
3.人为干扰的解决方法
将无线通讯终端做成一个装置，也就是箱体结构。无线设备起到的不仅仅是传输效果，也包含了数据处理能力，自己可以形成一套完整且独立的系统。外部电路与无线通讯装置均采用了完善的隔离电路，保证将外部电路包括容性、感性的干扰到对终端内部电路的运行降到最低。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4819fb0a0641982c25de02667b7eeaad/" rel="bookmark">
			HarmonyOS应用程序包快速修复
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		快速修复概述 快速修复是HarmonyOS系统提供给开发者的一种技术手段，支持开发者以远快于应用升级的方式对应用程序包进行缺陷修复。和全量应用升级软件版本相比，快速修复的主要优势在小、快和用户体验好。在较短的时间内不中断正在运行的应用的情况下（即不需要重启应用），修复应用的缺陷。
快速修复的使用规则 仅支持修复应用的TS和C++代码，对应的文件为.abc文件（TS编译后的文件）和.so文件（C++编译后的文件），不支持对资源的修复。不支持新增.abc文件和.so文件。快速修复包部署时要确保对应应用包已安装，如果未安装，则部署失败。快速修复包中配置的包名和应用版本号必须和已安装的包名和版本号应用相同，如果不同则部署失败。如果已经部署过快速修复包，新部署的快速修复包的版本号必须大于之前快速修复包的版本号，否则部署失败。快速修复包的签名信息和待修复的应用的签名信息必须一致，否则会部署失败。新的应用版本发布安装时，会清理掉快速修复包。 快速修复包结构 上图是HarmonyOS应用程序发布的快速修复的包格式
从图中可以看出包含两种包格式：
appqf（Application Quick Fix）
appqf与应用的app pack包是一一对应关系，具体可参考应用程序包结构的介绍。
appqf包是HarmonyOS应用用于发布到应用市场的单元，不能够直接安装到设备上。它是由一个或多个hqf（Harmony Ability Package Quick Fix）组成，这些hqf包在应用市场会从appqf包中拆分出来，再被分发到具体的设备上。appqf包上架到应用市场前要有开发者的签名信息。 hqf（Harmony Ability Package Quick Fix）
hqf包是修复HAP中问题的快速修复包，用于安装到设备上的快速修复单元。一个hqf可以包含.abc的快速修复文件，.so的快速修复文件和描述该包的配置文件。
.abc文件：应用中修改后的ts代码，编译后生成的字节码文件。
libs目录：存放.so库文件的差分文件，以.so.diff为后缀。区分的不同的系统cpu架构，例如arm平台、x86平台。
patch.json：
该文件用于描述hqf包版本信息的配置文件，由开发者填写，具体内容如下：
{ "app" : { "bundleName" : "com.ohos.quickfix", "versionCode" : 1000000, "versionName" : "1.0.0", "patchVersionCode" : 1000000, "patchVersionName" : "1.0.0" }, "module" : { "name" : "entry", "type" : "patch", "deviceTypes" : [ "default", "tablet" ], "originalModuleHash" : "11223344556677889900" } } 具体字段说明：
字段类型说明备注bundleNamestring对应应用的包名不可缺省versionCodeint对应应用版本号不可缺省versionNamestring对应应用的版本名称patch类型不可缺省patchVersionCodeint补丁包的版本号不可缺省patchVersionNamestring补丁包的版本名称patch类型不可缺省namestring对应应用的moduleName，用来修复该module的不可缺省typestring对应补丁包的类型，当前可选择为patch不可缺省deviceTypesarray补丁包支持的设备类型不可缺省originalModuleHashstring原始module Name对应包的哈希值不可缺省 快速修复TS编译后的文件 上图是通过TS代码编译工具生成快速修复.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4819fb0a0641982c25de02667b7eeaad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb26f1d2ba40cb6eba5acd6f2fe17d15/" rel="bookmark">
			软件科技巅峰：颠覆性技术的崛起与深远影响
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当我们深入探讨软件技术中一些引人瞩目的方面时，我们不仅能够欣赏到其精妙之处，同时也能够窥见其在不同领域的实际应用。
1. 人工智能和机器学习：
在人工智能领域，深度学习技术的崛起为机器学习注入了强大的活力。深度神经网络的架构使得计算机能够自主学习复杂的模式和规律，这种学习能力在图像识别中表现尤为出众。例如，ImageNet大规模图像识别竞赛中，深度学习模型的性能大幅超越传统方法，成为新的里程碑。
自然语言处理（NLP）领域也因为深度学习而有了质的飞跃。Transformer模型的提出使得语言模型的训练更加高效，BERT、GPT等模型在文本生成和理解方面达到了前所未有的水平。这些技术不仅改变了搜索引擎的工作方式，还在智能助手、翻译服务等方面发挥了关键作用。
2. 区块链技术：
区块链技术的革命性之处在于其去中心化和不可篡改的特性。比特币作为区块链技术的代表，通过共识算法解决了传统货币体系中的双花问题，实现了点对点的价值传递。在金融领域，智能合约的应用使得金融交易更加透明和高效，而且无需依赖传统中介机构。
在供应链管理中，区块链技术提供了一种可追溯性的解决方案，通过将生产和运输过程中的数据记录在区块链上，确保了产品溯源的可信度。这对于保障食品安全和防止假货流入市场具有重要意义。
3. 容器化和微服务架构：
容器化技术的流行使得软件开发和部署变得更加灵活和高效。Docker容器的轻量级特性允许开发者在不同环境中快速部署应用，而Kubernetes等容器编排工具则进一步简化了多容器应用的管理。微服务架构将应用程序划分成独立的服务单元，每个服务单元都可以独立开发、测试和部署，这为大型应用的维护和升级提供了更好的解决方案。
这种架构的采用使得开发团队更容易实现持续集成和持续交付（CI/CD），从而更加灵活地适应市场需求的变化。微服务的概念也促进了团队之间的协作，每个团队可以专注于特定服务的开发和维护，提高了整体开发效率。
4. 量子计算：
量子计算的崭新特性为解决某些复杂问题提供了突破口。量子比特的超位置和纠缠使得量子计算机能够在同一时间处理多个状态，这对于分子模拟、材料设计等领域具有潜在的巨大价值。
例如，在药物研发中，量子计算机能够模拟分子的三维结构和相互作用，加速新药的发现过程。在优化问题中，量子计算机能够通过量子并行计算找到更快的解决方案。尽管目前量子计算还处于实验阶段，但它已经引起了学术界和产业界的广泛关注。
5. 自动驾驶技术：
自动驾驶技术的实现离不开多个领域的融合。传感器技术，包括激光雷达、摄像头、雷达等，能够实时获取车辆周围环境的数据。机器学习算法能够对这些数据进行分析，并作出实时决策，例如避开障碍物、规划最优路径等。
同时，车辆控制系统通过与传感器和决策系统的协同工作，实现车辆的自主导航。这一技术的发展不仅提高了交通安全水平，还为未来交通系统的智能化和高效化奠定了基础。
总体而言，这些软件技术的卓越表现使得我们生活的方方面面都得以改善和创新。它们的影响远不止于技术领域，还深刻地改变了我们思考和解决问题的方式。这也是软件技术一直以来都备受瞩目的原因。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e9a552db96d84466bbf65b4226534b3/" rel="bookmark">
			【Bootstrap学习 day1】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Bootstrap5 网格的基本结构 等宽响应式列
Bootstrap 5 网格系统有6个类：
.col-针对所有设备
·col-sm平板-屏幕宽度等于或大于576px。
.col-md-桌面显示器，屏幕宽度等于或大于768px
·col-lg大桌面显示器，屏幕宽度等于或大于992px
·col-xl特大桌面显示器，屏幕宽度等于或大于1200px
·col-xxl超大桌面显示器，屏幕宽度等于或大于1400px
&lt;div class="container"&gt; &lt;!-- 等宽十二列 --&gt; &lt;div class="row"&gt; &lt;div calss="col-md-1"&gt;1&lt;/div&gt; &lt;div calss="col-md-1"&gt;2&lt;/div&gt; &lt;div calss="col-md-1"&gt;3&lt;/div&gt;	&lt;div calss="col-md-1"&gt;4&lt;/div&gt; &lt;div calss="col-md-1"&gt;5&lt;/div&gt; &lt;div calss="col-md-1"&gt;6&lt;/div&gt; &lt;div calss="col-md-1"&gt;7&lt;/div&gt; &lt;div calss="col-md-1"&gt;8&lt;/div&gt; &lt;div calss="col-md-1"&gt;9&lt;/div&gt;	&lt;div calss="col-md-1"&gt;10&lt;/div&gt; &lt;div calss="col-md-1"&gt;11&lt;/div&gt; &lt;div calss="col-md-1"&gt;12&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="container"&gt; &lt;!-- 等宽三列 --&gt; &lt;div class="row"&gt; &lt;div calss="col-md-4"&gt;1&lt;/div&gt; &lt;div calss="col-md-4"&gt;2&lt;/div&gt; &lt;div calss="col-md-4"&gt;3&lt;/div&gt;	&lt;/div&gt; &lt;/div&gt; 不等宽响应式列
&lt;div class="container"&gt; &lt;!-- 不等宽两列，两列分别占4格，8格 --&gt; &lt;div class="row"&gt; &lt;div calss="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e9a552db96d84466bbf65b4226534b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21f0cc380071825da7789019858e3c76/" rel="bookmark">
			git远程操作，推送【push】，拉取【pull】，忽略特殊文件，配置别名，标签管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言：新建远程仓库克隆推送【push】拉取【pull】 配置git忽略特殊文件给命令配置别名 标签管理理解标签创建标签操作标签 前言： 大家如果没有看过前几章git的基础操作的话，推荐先看一下，看完再来看这个远程操作，这样会对git有一个深的理解~~
GIT | 基础操作 | 初始化 | 添加文件 | 修改文件 | 版本回退 | 撤销修改 | 删除文件
git的分支的使用，创建分支，合并分支，删除分支，合并冲突，分支管理策略，bug分支，强制删除分支
接下来我们对本章的正题：
Git是一款分布式版本控制系统，它允许团队协同开发并追踪代码变更。远程操作是Git中的一个重要概念，它使得开发者能够在不同计算机之间共享和同步代码。这里也不多介绍，可以到百度上面自行寻找~~
本教程使用的是码云（gitee.com）来演示
新建远程仓库克隆 首先就是要先注册一个自己的账号然后新建仓库 这里有两种方法来clone仓库到本地，一个是https一个是ssh
我们不使用https,原因是https比较简单
首先就是配置用户名和邮箱然后（这里配置命令在初始git操作就讲述了）然后直接使用这个命令git clone 复制的仓库链接 接下来我们就使用这个ssh来配置一下
使用ssh方式克隆仓库，由于我们没有添加公钥到远端库中，所以会克隆失败，这里就不演示了，接下来我们就开始配置一下如何将公钥添加 首先打开设置-&gt;ssh公钥-&gt;公钥
那么这里的公钥在哪里获取呢，当然是在自己的电脑或者远端服务器上获取~~
我这里就在自己电脑上演示了，远端服务器获取也是一样的~~输入一下命令，注意： 这里改成自己的邮箱~~ ssh-keygen -t ed25519 -C "shilinnull@163.com" 然后会在上图的地址会显示地址，找到这个文件夹就可以了，其中第二个带有.pub的后缀是公钥，我们用记事本打开复制里面的内容 然后粘贴到刚刚的那个网站的公钥栏里就可以了，标题随便写就可 最后再使用ssh的方式克隆 OK，可以看到已经成功了~~ 推送【push】 我们对仓库里的文件进行修改 然后进行添加 最后一个关键的步骤，就是push git push origin master 然查看远端仓库，可以看到已经被修改了 拉取【pull】 我们首先对远端仓库直接进行了修改 而我们这次又对本地又进行了修改，然后再添加 最后进行提交操作，发现是无法提交的，会有冲突 这个时候就需要我们首先对远端仓库进行拉取 git pull origin master 这里又回到冲突那里了，然后我们需要进行手动修改一下然后再进行提交 然后再进行添加提交操作 可以看到也已经是有了~~ 配置git 忽略特殊文件 在日常开发中，我们有些文件不想提交到远程仓库，那么怎么做呢？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21f0cc380071825da7789019858e3c76/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b380d7695e71daa0d3dc1de76b69973/" rel="bookmark">
			华为电脑的IP地址：如何找到并管理？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​在现代科技的高速发展中，华为电脑已经成为了人们生活和工作中必不可少的重要工具。然而，对于很多用户来说，IP地址却是一个颇具挑战性的问题。在本文中，我们将会详细探讨华为电脑的IP地址在哪里找，并提供一些建议和技巧来更好地管理您的IP地址。
首先，我们需要明确什么是IP地址。IP地址是指互联网协议地址，它是用来唯一识别一个设备在网络中的位置的。每台华为电脑都会被分配一个IP地址，而这个地址对于网络连接和通信至关重要。
那么，华为电脑的IP地址究竟藏在哪里呢？答案是在操作系统的网络设置中。在Windows操作系统上，您可以按下Win+R组合键，然后输入"cmd"打开命令提示符窗口。在命令提示符窗口中，输入"ipconfig"命令，就可以显示出华为电脑的IP地址了。而对于Mac操作系统的用户来说，可以在"系统偏好设置"中的"网络"选项中找到IP地址。
不仅如此，华为电脑的IP地址还可以通过路由器进行查看和管理。路由器是连接您的电脑和网络的重要设备，它负责分配IP地址和管理网络流量。您可以通过打开浏览器，在地址栏中输入路由器的IP地址，然后登录路由器的管理界面。在管理界面中，您可以找到华为电脑连接的IP地址，并对其进行管理和设置。
当然，如果您想更深入地了解和管理华为电脑的IP地址，您还可以使用网络工具。例如，"IP扫描器"可以帮助您扫描和显示网络中的所有设备和其IP地址。它可以通过简单的操作，让您轻松地找到华为电脑的IP地址，并进行管理。
在管理IP地址时，我们还需要注意一些事项。首先，IP地址是动态的，它可能会在您重启电脑或重新连接网络时发生变化。如果您需要一个始终不变的IP地址，您可以考虑使用静态IP地址。其次，IP地址还可以用于网络安全，比如防火墙设置和端口映射。因此，如果您对网络安全有需求，您可能需要了解更多关于IP地址的知识。
总而言之，请牢记华为电脑的IP地址对于连接网络和进行通信的重要性。通过正确的方法和工具，您可以轻松地找到和管理华为电脑的IP地址，从而提升您的网络体验和安全性。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6294ddde6945ae8edfe1b09f5737906b/" rel="bookmark">
			Hive04_DDL操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Hive DDL操作 1 DDL 数据定义 1.1 创建数据库 CREATE DATABASE [IF NOT EXISTS] database_name [COMMENT database_comment] [LOCATION hdfs_path] [WITH DBPROPERTIES (property_name=property_value, ...)]; [IF NOT EXISTS] ：判断是否存在
[COMMENT database_comment] ：注释
[LOCATION hdfs_path]：指定数据库的创建位置
1）创建一个数据库，数据库在 HDFS 上的默认存储路径是/user/hive/warehouse/*.db。
hive (default)&gt; create database db_hive; 2）避免要创建的数据库已经存在错误，增加 if not exists 判断。（标准写法）
hive (default)&gt; create database db_hive; FAILED: Execution Error, return code 1 from org.apache.hadoop.hive.ql.exec.DDLTask. Database db_hive already exists hive (default)&gt; create database if not exists db_hive; 3）创建一个数据库，指定数据库在 HDFS 上存放的位置
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6294ddde6945ae8edfe1b09f5737906b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6779e11e2eb0b41d941765ff27d8ec0/" rel="bookmark">
			在ajax中使用callback
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 今天遇到个场景是在点击按钮时，调用请求，在请求完成后，获取到后台返回的某个值之后再去执行下一步操作，也就是要同步进行。其实用setTimeout也是可以实现的，但考虑到效果最好，决定使用callback。
getData = function(callback){ $.ajax({ url: configUrl+'/biote/blog/post', // 接口URL data: JSON.stringify(datas), success: function(data) { 执行你的操作... callback(); // 如果这个接口需要在页面加载后立即执行那需要改一下上面这句代码 callback ? callback() :''; // 或者在调用的时候传一个空方法也行 } }) } // 点击按钮的时候调用请求 $('.pro-nav').on('click','li',function(){ getData(function(){ 执行下一步操作... }); }) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/714be8ce2cd0a812cc2f665efbfe0271/" rel="bookmark">
			基于Java&#43;SpringBoot&#43;Vue扶农助农政策管理系统设计和实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博主介绍：✌全网粉丝30W+,csdn特邀作者、博客专家、CSDN新星计划导师、Java领域优质创作者,博客之星、掘金/华为云/阿里云/InfoQ等平台优质作者、专注于Java技术领域和学生毕业项目实战,高校老师/讲师/同行交流合作✌
主要内容：SpringBoot、Vue、SSM、HLMT、Jsp、PHP、Nodejs、Python、爬虫、数据可视化、小程序、安卓app、大数据、物联网、机器学习等设计与开发。
🍅文末获取源码联系🍅
👇🏻 精彩专栏推荐订阅👇🏻 不然下次找不到哟
2022-2024年最全的计算机软件毕业设计选题大全：1000个热门选题推荐✅
Java项目精品实战案例《100套》
Java微信小程序项目实战《100套》
Python项目实战《100套》
感兴趣的可以先收藏起来，还有大家在毕设选题，项目以及论文编写等相关问题都可以给我留言咨询，希望帮助更多的人
​ 系统介绍： 随着社会的发展，社会的各行各业都在利用信息化时代的优势。计算机的优势和普及使得各种信息系统的开发成为必需。
扶农助农政策管理系统，主要的模块包括首页、个人中心、用户管理、贫困户管理、扶贫政策管理、扶贫类型管理、志愿者招聘管理、用户应聘管理、留言板管理、系统管理等功能。系统中管理员主要是为了安全有效地存储和管理各类信息，还可以对系统进行管理与更新维护等操作，并且对后台有相应的操作权限。
要想实现扶农助农政策管理系统的各项功能，需要后台数据库的大力支持。管理员验证注册信息，收集的信息，并由此分析得出的关联信息等大量的数据都由数据库管理。本文中数据库服务器端采用了Mysql作为后台数据库，使Web与数据库紧密联系起来。在设计过程中，充分保证了系统代码的良好可读性、实用性、易扩展性、通用性、便于后期维护、操作方便以及页面简洁等特点。
本系统的开发使获取扶农助农政策管理系统信息能够更加方便快捷，同时也使扶农助农政策管理系统管理信息变的更加系统化、有序化。系统界面较友好，易于操作。
程序上交给用户进行使用时，需要提供程序的操作流程图，这样便于用户容易理解程序的具体工作步骤，现如今程序的操作流程都有一个大致的标准，即先通过登录页面提交登录数据，通过程序验证正确之后，用户才能在程序功能操作区页面操作对应的功能。
​ 程序操作流程图
功能截图： 系统功能模块 扶农助农政策管理系统，在系统的首页可以查看首页、贫困户、扶贫政策、志愿者招聘、留言反馈、个人中心、后台管理等信息进行详细操作，如图5-1所示。 图5-1系统首页界面图
贫困户，在贫困户页面中可以查看编号、家庭成员、成员人数、家庭住址、家庭状况、封面、人均收入、账号、姓名、详细介绍等信息，如图5-2所示。
图5-2贫困户界面图
扶贫政策，在扶贫政策页面中可以查看标题、扶贫类型、发布时间、封面、内容等信息，如图5-3所示。
图5-3扶贫政策界面图
志愿者招聘，在志愿者招聘页面中可以查看招聘标题、职位、工资待遇、工作地点、工作时间、招聘人数、招聘时间、截止时间、负责人、联系方式、图片、发布日期等信息，并进行收藏操作，如图5-4所示。
图5-4志愿者招聘界面图
留言反馈，在留言反馈页面输入留言内容并立即提交或重置操作，如图5-5所示。
图5-5留言反馈界面图
个人中心，在个人中心页面通过填写账号、密码、姓名、年龄、性别、手机、邮箱、上传图片等信息进行个人信息修改，还可对我的收藏进行详细操作，如图5-6所示。
图5-6个人中心界面图
管理员功能模块 管理员登录，管理员通过输入用户名、密码、选择角色等信息，然后点击登录就能登录到系统进行系统的使用了，如图5-7所示。
图5-7管理员登录界面图
管理员登录进入系统之后，就可以对所有的信息进行查看，可以查看到首页、个人中心、用户管理、贫困户管理、扶贫政策管理、扶贫类型管理、志愿者招聘管理、用户应聘管理、留言板管理、系统管理等，并且还可以对其进行相应的操作管理，如图5-8所示。
图5-8管理员功能界面图
用户管理，在用户管理页面中可以对索引、账号、姓名、年龄、性别、手机、邮箱、照片等信息进行详情或删除等操作，如图5-9所示。
图5-9用户管理界面图
贫困户管理，在贫困户管理页面中可以对索引、编号、家庭成员、成员人数、家庭住址、封面、人均收入、账号、姓名、审核回复、审核状态、审核等信息进行详情或删除等操作，如图5-10所示。
图5-10贫困户管理界面图
扶贫政策管理，在扶贫政策管理页面中可以对索引、标题、扶贫类型、发布时间、封面等信息进行详情，修改或删除等操作，如图5-11所示。
图5-11扶贫政策管理界面图
志愿者招聘管理，在志愿者招聘管理页面中可以对索引、招聘标题、职位、工资待遇、工作地点、工作时间、招聘人数、招聘时间、截止时间、负责人、联系方式、图片、发布日期等信息进行详情，修改或删除等操作，如图5-12所示。
图5-12志愿者招聘管理界面图
用户应聘管理，在用户应聘管理页面中可以对索引、招聘标题、职位、是否应聘、应聘时间、账号、姓名、手机、审核回复、审核状态、审核等信息进行详情或删除等操作，如图5-13所示。
图5-13用户应聘管理界面图
留言板管理，在留言板管理页面中可以对索引、用户名、留言内容、回复内容等信息进行详情，回复，修改或删除等操作，如图5-14所示。
图5-14留言板管理界面图
系统管理，在轮播图管理页面中可以对索引、名称、值等信息进行详情，修改等操作，如图5-15所示。
图5-15系统管理界面图
用户后台功能模块 用户注册，在注册页面中通过填写账号、密码、姓名、年龄、手机、邮箱等信息完成用户注册，如图5-16所示。
图5-16用户注册界面图
用户登录进入系统后台可以查看首页、个人中心、贫困户管理、用户应聘管理、我的收藏管理等信息进行详细操作，如图5-17所示。
图5-17用户后台功能界面图
个人中心，在个人信息页面中通过填写账号、姓名、年龄、性别、手机、邮箱、照片等信息对个人信息进行修改操作，如图5-18所示。
图5-18个人中心界面图
贫困户管理，在贫困户管理页面中可以对索引、编号、家庭成员、成员人数、家庭住址、封面、人均收入、账号、姓名、审核回复、审核状态等信息进行详情，修改或删除等操作，如图5-19所示。
图5-19贫困户管理界面图
代码实现： /** * 登录相关 */ @RequestMapping("users") @RestController public class UserController{ @Autowired private UserService userService; @Autowired private TokenService tokenService; /** * 登录 */ @IgnoreAuth @PostMapping(value = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/714be8ce2cd0a812cc2f665efbfe0271/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98f0f84b8833e825ffc93744035720ef/" rel="bookmark">
			MOS管电流方向能反吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		来源 | 硬件工程师炼成之路
今天来说 两个问题：
1、MOS管导通电流能否反着流？D到S，S到D方向随意？
2、MOS管体二极管能过多大的电流？
为啥会有这两个问题？
我们在最开始学习MOS管的时候，应该都是从NMOS开始的，电流的方向都是从D到S的。
而实际应用电路，NMOS会有电流从S到D的情况，比如下面这个NMOS管防电源反接电路（仅仅是个示意图，实际电路需要多考虑一些因素）。
原理我还是先大致说下。
1、在电源正常接入的时候
电源正极VCC经过后级负载电路接到体二极管，那么体二极管就会导通，于是此时S极的电压就约为0.7V左右（体二极管导通电压）。
同时栅极G极接的是VCC，所以Vgs=Vcc-0.7V&gt;Vgsth，NMOS管会导通。NMOS管导通之后，导通压降基本为0，那么Vgs=Vcc，MOS管维持导通状态。
这样整体电源通路就是通的，电源给后级负载供上了电，后级电路正常工作。
这里有一点需要特别注意，就是此时MOS管的电流是S到D的，与往常我们经常见的D到S是反的。
2、在电源接反的时候（电源和地接反了）
栅极G接电源负极，也就是0V，S极经过负载接到了电源负极，也就是0V，所以Vgs=0V，MOS管也不导通。
与此同时， D极为Vcc，S极为0V，体二极管反向偏置，也不导通，所以无法通过NMOS管流过电流。
对于负载来说，就是电源断开了。
接反的电源不会怼到后面的负载上面，所以后级电路就不会烧了，我们只要把前面的电源正负极接对，那么后级电路又能正常工作了，如此，便实现了防反接的功能。
需要说一点，这里的防反接并不是说电源接反了，后级电路也还能工作。而是电源接反了，后级电路不会冒烟烧坏了。
我以前乍一看到这个电路的时候，其实是心里打鼓的
这个MOS管导通时，电流能反着流？D到S，S到D无所谓吗？
除了这个电流的方向问题，还有就是MOS管的体二极管问题，这个二极管能过多大的电流？
如果不了解，会认为这个二极管能流过的电流非常小，因为它还有一个名称叫“寄生二极管”，很容易被它骗。
寄生二字，会很容易让人联想到寄生电感，寄生电容，而这两个东西一般都是很小的，所以很容易误认为这个寄生二极管也很弱，过不了比较大的电流。
问题解答
这两个问题，其实用一个电路就能解答了，就是下面这个BUCK电路。
应该都知道上面这是个buck电路吧，下管是NMOS管，在上管断开，下管导通的时候，电感的电流来源于下管。
也就是说，下管NMOS的电流方向是从S到D的，也就是反着流，并且这个电流可以是很大的，因为电感的电流是可以比较大的，跟负载有关。
除此之外，从之前的文章《BUCK的振铃实验与分析》里面我们也知道，BUCK在开关切换的时候，会存在死区时间（上管和下管都不导通的时候）。而电感的电流是不能断的，死区时间电感的电流就是走的下管的体二极管。
又因为电感的电流取决于负载电流，是可以到几安培的，所以说下管的体二极管的电流也是可以很大的。
那MOS管的体二极管电流最大能到多少呢？选型的时候需要考虑吗？
很多MOS管是不标注这个参数的，但是也有一些厂家标注了，比如这个NMOS管SI9804
从上面手册看到，可以通过的持续电流是2.1A。
这个是怎么来的呢？
这个我觉得可能是根据功耗限制来的。
如果通过的电流时间很短，那么可以通过更大一点的电流，如果时间比较长，那么流过的电流就不能太大。
从上图可以看到，环境温度25℃的最大功耗是2.5W。这么看的话，前面说的持续电流是2.1A，应该也是根据功耗限制来的。
根据常规硅二极管，通过2.1A电流时，导通压降大概是1V左右，那么功耗就是P=2.1A*1V=2.1W，跟2.5W也差不太多。
当然，以上只是我的猜测而已，并没有找到什么比较官方的说法。
一个更详细的手册
写到这里，我又找到一个更为详细的MOS管手册，英飞凌的NMOS管BSC059N04LS6，里面有详细介绍体二极管的过流能力，包括持续和瞬间的电流。
这个手册让我确信了上面的猜测。
下面是BSC059N04LS6手册里面的体二极管的参数
从上表直接可以看到，体二极管的持续电流是可以到38A，脉冲电流是可以到236A的，同时，也可以看到，二极管最大导通电压是1V。
可能会有些诧异，这个二极管持续电流能到38A这么大？
实际应用自然是到不了，我们需要注意上面是有个条件，那就是Tc=25℃的，c是case，也就是外壳保持25℃情况下的。
我们实际应用中，如果不加特别的散热措施，肯定是没法保证这个MOS外壳是这个温度，自然也就不能持续通过38A的电流。
不过这也无关紧要，我们仅仅是看这个参数的意义，想知道它是怎么来的。
我们再看看手册里面的功耗限制
可以看到，在Tc=25℃时，功耗限制是38W，前面知道导通电压是1V，电流限制是38A，正好功耗限制等于电压乘以电流，这也太巧了。
所以，体二极管能通过的电流就是根据功耗限制来的没跑了。
同时，我们看到，在Ta=25℃，功耗限制是3W，这个Ta就是环境温度了，这个与实际使用情况应该是更为接近的（不使用特别散热措施）。
如果用这个值计算，那么体二极管能持续通过的电流也就是3W/1V=3A左右，当然，这个是我的推测，手册里面没写。
到这里，至少我们应该知道了，体二极管还是能过比较大的电流的。
当然，还有一个问题，上面说的是持续的电流，必然还有瞬间电流的问题，瞬间电流能过多大呢？
这个问题反而更为重要一点，因为正常使用中，我们不会给MOS管的体二极管通过持续时间比较长的电流。如果有这个需要，我们直接让MOS管导通不就好了吗，功耗还能更低。
前面举例的BUCK中，体二极管也只是在死区时间才会有电流通过，这个时间是相当短暂的。
所以这个瞬间能过多大的电流反而更值得看一看。
我们还是看BSC059N04LS6的手册，因为它都直接标出来了。
这个管子导通电流可以到59A，在10us时间内能通过的电流是236A，而体二极管也是236A，二者是相同的，而且都很大，也就是说体二极管的瞬间电流根本就不会成为使用的瓶颈。
也许这就是为什么我们很少去关注MOS管的体二极管的电流，只看MOS管导通电流够不够大。
以上内容小结一下：
1、MOS导通后电流方向其实可以双向流动，可以从d到s，也可以从s到d。
2、MOS管体二极管的持续电流可以根据MOS管的功耗限制来计算，
3、MOS管体二极管瞬间可以通过的电流，等于NMOS管导通后瞬间可以通过的电流，一般不会是瓶颈
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98f0f84b8833e825ffc93744035720ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e6a2ac689679d0a7d1c979463ad6e43/" rel="bookmark">
			（附源码）基于Spring Boot企业报销审批系统的设计与实现 计算机毕设44362
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Springboot企业报销审批系统设计与实现 摘 要 企业报销系审批统是将企业财务报销和计算机技术结合起来的一种新型的办公方式，是信息化社会的产物。通过网络，组织机构内部的人员可跨越时间、空间进行操作。通过企业报销审批系统所实施的交换式网络应用,使信息的传递更加快捷和方便，从而极大地扩展了办事效率。
企业报销审批系统是采用java语言，基于MVVM模式进行开发，采取MySQL作为后台数据的主要存储单元，采用Springboot框架实现了本系统的全部功能。实现基于Springboot的企业报销审批系统，具有个人报销、专项购买报销、支出类型、个报主管审批、个报财务审批、专项主管审批、专项财务审批等功能，本系统代码的复用率高，系统维护代价小，具有方便、灵活、高效等特征。
关键词：报销系统；Springboot框架 ；数据库
Abstract The approval system of the enterprise reimbursement department is a new type of office mode combining the enterprise financial reimbursement and computer technology, and is the product of the information society. Through the network, personnel within the organization can operate across time and space. Through the exchange network application implemented by the enterprise reimbursement approval system, the information transmission is faster and more convenient, thus greatly expanding the efficiency.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e6a2ac689679d0a7d1c979463ad6e43/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7ea2119c0568c7e51f73fcdd88cb8d2/" rel="bookmark">
			3个.NET开源简单易用的任务调度框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 今天分享3个.NET开源、简单、易用的任务调度框架，帮助大家在做定时任务调度框架技术选型的时候有一个参考。
Quartz.Net Quartz.NET是一个功能齐全的开源作业调度系统，可用于从最小的应用程序到大规模企业系统。
Quartz.NetUI Quartz.NetUI是一个基于.NET Core + Quartz.NET + Vue + IView开箱即用的定时任务UI（不依赖数据库,只需在界面做简单配置）。
GitHub开源地址：https://github.com/cq-panda/Quartz.NetUI
文章详细介绍：https://mp.weixin.qq.com/s/kwke35lYqbHQXC5oTADOpg
Hangfire Hangfire 是一个非常简单易用的库，可以在 .NET 应用程序中执行后台的、延迟的和定期的任务。它支持 CPU 密集型、I/O 密集型、长时间运行和短时间运行的任务。无需使用 Windows 服务或任务计划程序。同时，Hangfire 可以与 Redis、SQL Server、SQL Azure 和 MSMQ 集成。
GitHub开源地址：https://github.com/HangfireIO/Hangfire
文章详细介绍：https://mp.weixin.qq.com/s/KchZwSnu8D817klvKvQFAQ
FreeScheduler FreeScheduler 是利用 IdleBus 实现的轻量化定时任务调度，支持临时的延时任务和重复循环任务(可持久化)，可按秒，每天/每周/每月固定时间，自定义间隔执行，支持 .NET Core 2.1+、.NET Framework 4.0+ 运行环境。
GitHub开源地址：https://github.com/2881099/FreeScheduler
文章详细介绍：https://mp.weixin.qq.com/s/9XYtauAe_qVcAj77G7eaLQ
优秀项目和框架精选 以上项目都已收录到C#/.NET/.NET Core优秀项目和框架精选中，关注优秀项目和框架精选能让你及时了解C#、.NET和.NET Core领域的最新动态和最佳实践，提高开发工作效率和质量。坑已挖，欢迎大家踊跃提交PR推荐或自荐（让优秀的项目和框架不被埋没🤞）。
https://github.com/YSGStudyHards/DotNetGuide/blob/main/docs/DotNet/DotNetProjectPicks.md
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97559c84009707bf7a6e0d93770ba250/" rel="bookmark">
			AntDesign Blazor 0.17.0发布，新增了antd v5的水印和 Flex 组件，还有更多新功能！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，忙完了为 .NET Conf China 大会准备的对 .NET 8 Blazor 的研究，在上周处理了一些issues，今天趁双旦的气氛，发布最新的功能版本。AntBlazor 祝大家新年快乐！2024更好！ 这次版本加入了两个antd v5才加入的组件，水印和Flex，水印是前年开始就有朋友提issue了，但是一直没做。看v5实现了，就加入吧。实不相瞒它是参考t-design的源码实现的，所以还比antd的多几个功能，比如类似老式电视机的屏幕保护功能，水印在背景游走上😅
Enjoy！
0.17.0 变更日志 🔥 新增 Watermark 水印组件 。#3441 @ElderJames
🔥 新增 Flex 组件。#3547 @ElderJames
🆕 新增 Mentions 的动态异步加载。#3503 @kooliokey
🆕 新增 Radio 在使用options时 RadioGroup 支持 RadioButton 样式。#3589 @ElderJames
🆕 新增 Menu 展开动画。#3395 @ElderJames
🆕 新增 Collapse 展开动画。#3562 @ElderJames
🆕 新增 JS initializers，自动加载组件库的 js 和 css。#3557 @ElderJames
🐞 修复 Upload 选择没有扩展名的文件时出现的异常。#3554 @SapientGuardian
🐞 修复 Tree 应在查询值清空时展开所有节点。#3587 @ElderJames
Select
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/97559c84009707bf7a6e0d93770ba250/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c75e6e98a16be7649924c4ddde4936e4/" rel="bookmark">
			ASP.NET Core 8 的内存占用可以更低吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 .NET 8 中，服务器 GC 现在支持动态堆计数，它们添加了一个被称为“动态适应应用程序大小”或 DATAS 的特性。它在 .NET 8 中通常是默认关闭的（尽管在为 Native AOT 发布时默认开启），但可以很容易地启用，要么通过将 DOTNET_GCDynamicAdaptationMode 环境变量设置为 1，要么通过 &lt;GarbageCollectionAdaptationMode&gt;1&lt;/GarbageCollectionAdaptationMode&gt; MSBuild 属性。所使用的算法能够随着时间的推移增加和减少堆计数，试图最大化其对吞吐量的视图，并在此和总体内存占用之间保持平衡。
Maoni Stephens 是 .NET 垃圾回收器 （GC） 的首席架构师之一，她在2023年8月份发表了一篇关于 .NET GC 新功能的博客文章，该功能称为 Dynamic Adaption To Application Sizes （DATAS），该功能将随 .NET 8 一起提供。此功能将在应用运行时自动增加或减少服务器 GC 模式下的托管堆数量。它减少了 .NET 应用使用的内存总量，使服务器 GC 模式成为内存受限环境（如 Docker 容器或 Kubernetes Pod）的可行选项，这些环境可以访问多个逻辑 CPU 内核。
服务器 GC 模式和工作站 GC 模式之间的差异 工作站模式最初是为客户端应用程序设计的。过去，执行应用代码的线程会停止，直到 GC 运行完成。在桌面应用程序中，您不希望在几毫秒甚至几秒钟内出现冻结，因此 Workstation GC 经过调整，可以更频繁地执行运行，并更快地完成单个运行。从 .NET Framework 4.0 开始，我们还具有后台 GC 运行模式，可最大程度地减少线程被阻塞的时间。
相比之下，服务器 GC 旨在最大限度地提高服务的吞吐量，这些服务将随着时间的推移接收短期请求。GC 运行频率较低，但可能需要更长的时间。最后，您将在 GC 上运行上花费更少的时间，而将更多的时间花在服务代码上。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c75e6e98a16be7649924c4ddde4936e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/333e1576bdd10ff9446292ffb69966d5/" rel="bookmark">
			Kernel Memory 入门系列：生成并获取文档摘要
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前面在RAG和文档预处理的流程中，我们得到一个解决方案，可以让用户直接获取最终的问题答案。
但是实际的业务场景中，仍然存在一些基础的场景，不需要我们获取文档的所有详情的，而只是了解的文档的大概信息，得到文章整体的摘要或者总结，此时仍然可以使用Kernel Memory来处理。
生成摘要 我们依然使用Kernel Memory的文件导入方法，不过此时不需要指定默认的处理流程，而只需要指定Summary流程即可。
await memory.ImportDocumentAsync(new Document("doc1") .AddFile("file4-SK-Readme.pdf") .AddFile("file5-NASA-news.pdf"), steps: Constants.PipelineOnlySummary); 其中PipelineOnlySummary 包含了一下步骤：
extract
summarize
gen_embeddings
save_records
相比较默认的流程，仅是将partition变更为了summarize, 但是实际存储的记录将不再是源文档的分片，而是经过LLM总结之后的内容摘要。
获取摘要 获取的摘要的方法更加直接，使用SearchSummariesAsync方法，通过文档过滤条件过滤需要获取文档摘要即可。
// Fetch the list of summaries. The API returns one summary for each file. var results = await memory.SearchSummariesAsync(filter: MemoryFilters.ByDocument("doc1")); // Print the summaries! foreach (var result in results) { Console.WriteLine($"== {result.SourceName} summary ==\n{result.Partitions.First().Text}\n"); } 检索生成数据 摘要的生成和检索在Kernel Memory中实际是数据类型标记和自定义筛选筛选的过程。
在生成摘要的过程中，将摘要内容作为生成内容，通过添加__synth:summary标记进行存储，筛选的时候也是类似。文档的标记和筛选，将会在后续【文档管理】中的详细讲解。
而摘要的检索的过程SearchSummariesAsync实际上也是调用SearchSyntheticsAsync过程，指定了__synth:summary标记的段落进行检索。
同理，生成摘要的过程也可以进行自定义的过程，例如文章分类，关键词提取，实体提取，题图生成等任何的文章处理流程。后续也会详细介绍【自定义流程】的处理。
参考 Summarizing documents
kernel-memory/service/Abstractions/KernelMemoryExtensions.cs
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5423f0ec41c6d55c5883880c923fd6de/" rel="bookmark">
			腾讯云音视频的创新技术、多元场景以及出海洞察
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		编者按
近年来，腾讯云音视频在音视频技术领域不断突破创新，从采集、编码、传输加速、云端媒体处理、分发到解码，不断探索前沿技术，并将其广泛应用于多元化的场景中。与此同时，在海外市场的实践中，腾讯云音视频积累了丰富的经验和对市场的深刻洞察。
LiveVideoStack2023深圳站邀请到腾讯云音视频的总经理李志成分享腾讯云音视频的创新技术、多元场景及出海洞察。
文/李志成
整理/LiveVideoStack
01
创新技术
现在互联网超过85%的流量都是音视频流量，传媒、8K、XR、游戏、Apple Vision对超高清视界的需求越来越强烈。腾讯视频云的终端采集编码、多网融合及全球传输加速、云端前处理的音视频画质增强修复、8K@120FPS 音视频实时编解码、边缘端的实时分发以及终端和云端协同实时云渲染的解决方案。
目前终端编码存在的最大的问题有两个：一是画质和码率控制做得不够理想；二是驱动或者系统集成原因，导致硬件编码稳定性也不够好，成功率在95%左右，还有5%左右比例需要软编解兜底容错。
例如图上左下角，客户反馈APP里用了很多推理和渲染，GPU负载高、功耗高，但CPU比较空闲。客户对视频画质的要求比较高，导致在终端采集用硬编时码率高，再到云端进行增强和压缩。经过这个流程，终端用户看到的画质会比较好，但云端音视频转码和增强的成本非常高，所以客户最终需求其实是能否把终端CPU的算力用起来，把视频编码、画质压缩做好。
这两年腾讯云在终端编码方面做了单核H.264、H.265实时编码支持，在工程优化以及算法设计上做了不少优化创新：
紧凑的数据结构设计、减少冗余内存消耗，重新设计数据结构，以及更高效的SIMD加速，总体的设计原则还是以空间换时间；
创新算法设计上，在块划分、模式选择、参考帧、滤波相关算法以及屏幕内容块算法上做了总共60多种算法创新；
弱网下支持灵活的上层APP调用，可以动态设置码率、帧率、分辨率以及SVC分层一些特性支持。
经过综合的数据结构、算法创新优化以后，在骁龙865、MT6769的长时间压测下，在零延迟、单核CPU下，H.265的CPU编码压缩性能相对硬编H.264基本上能提升35%，相对硬编H.265提升20%。总体来说，基本上硬件的硬编基准，在高通625、单核CPU上，可以做到720P@25FPS的稳定压缩出帧。
腾讯云音视频的终端编码SDK支持PC，安卓、iOS、IoT摄像头等，能做到单核CPU的实时编码。
腾讯云音视频近年一直在做多媒体场景下传输加速方面的优化。在P2P方面，腾讯云音视频在NAT全网的平均打洞成功率能够达到70%以上，支持IoT的RTOS，在摄像头、监控等行业应用也比较多。
首先，腾讯云在终端传输加速方面支持多运营商蜂窝网络/Wi-Fi/卫星网络上网多网融合实现移动网络加速增强。运营商有时会接到很多用户投诉说直播推流很卡，不知道怎么解决。腾讯云通过和运营商进行合作，在弱网、多网融合等方面做了传输优化，降低了用户投诉率。
其次，Stream Services媒体传输加速方案具备全球边缘加速能力，例如在游戏赛事直播方面，通过腾讯云全球Stream Link加速方案做到几百毫秒的延迟分发到全球各视频平台，在国内一些电视媒体上，在海外新闻采编方面也有采用腾讯云Stream Link方案，支持全球流媒体跨区传输。
最后，针对多媒体的ETC传输加速协议栈方案支持按RTT变化的拥塞控制，针对音视频场景以接收速率为指导，主要是引入ACK机制，参考QUIC的双序号模式，定时反馈ACK到发送端，可以实现快速的数据重传；这里的RTT用的是每一个回合的首包来计算RTT会更准确一些，拥塞控制使用了凸函数，低延时，稳定增长和降速;针对音视频场景的TQUIC传输加速的项目也在Github上开源，希望更多的开发者能够使用到。
点播文件上传方面，腾讯云支持全球多源站存储、代理/动态加速、分片传输、断点续传、TQUIC加速，多网聚合，支持SDK、云API、控制台等多种上传接入模式，弱网环境上传成功率超过99.5%。
云端媒体处理方面，实时画质增强修复，腾讯云音视频在双向训练数据集，以及局部、全局模型工程、帧间约束损失函数，多帧融合以及在插帧非线性运动二次函数拟合运动轨迹上都做了挺多创新，支持分布式算力池增强模型实时处理以及RTC/LIVE场景实时处理。
上图是去噪声、去伪影、去压缩块效应、人脸字体增强以及去划痕、超分等效果展示，在传媒、互联网以及教育、金融上都有比较成熟的解决方案和广泛的应用。
在插帧方面，图上的案例是一个海外客户，有很多体育赛事视频，视频源是1080P@25FPS的，目标是超分插帧到4K@50FPS，给用户提供一个高清付费频道。腾讯云音视频给客户提供了实时超分插帧的解决方案。通过插帧方案很好解决了插帧稳定性、闪烁、卡顿问题。特别是针对非匀速直线、复杂运动场景产生的形变导致的光流估计不准的问题都提供了比较成熟的解决方案，目前在一些体育和游戏赛事，包括直播实时场景中已经有了较多应用。
在视频编码方面，腾讯云音视频支持主流视频格式压缩，包括H.264、H.265、H.266、AV1、VP9和AVSx等。对于H.264、H.265、H.266、AV1编码内核，腾讯云每年都在持续优化，每年都有大约5%+压缩收益的进步。并且连续三年MSU关键赛道指标综合最佳，同时，在去年北美的SLC云厂商编码评测评中，腾讯云MPS也是全项最佳(Excellent)，支持8K@120FPS实时编码。
和最新版HM/AOM最慢档压缩数据相比，腾讯云音视频比HM/AOM bd-rate有20%+的收益，工程性能有HM 20倍+的提速。
目前在极高关注度的行业场景里面，全真互联、元宇宙、Apple Vision、XR/VR等穿戴设备，腾讯云音视频也全面支持MV-HEVC编码方案。常用的3D视频成像技术包括全息投影、裸眼3D屏幕和立体电影显示技术等目前常用3D视频内容，主要是VR头显和立体影视，大都基于左右视点图像的编码、传输和显示来完成。但长期以来，大量3D视频内容并没有使用专用的视频编码标准，而是使用通用的视频编码标准进行编码。主要的做法是将3D视频以SBS（Side by Side）的形式，把左右两个视点合并到一帧画面中，再将合并后的序列进行编码，比如常见的全景投影方式有ERP、CMP、SSP等。
以H.265为例，HEVC编码器并没有帧内远距离搜索，因此同一帧的左右半间无法相互预测；另一方面，由于运动估计搜索范围的限制，帧间预测也不能利用不同视点间的信息，而全景投影方式下，在播放解码拼接时，由于合并的帧压缩时左右视点视频图像分开合并的原因，拼接恢复时容易出现黑线，这是客户反馈最多的问题。
总体来看，3D MV-HEVC充分利用了左右视点图像间的冗余信息，进一步提高图像的压缩效率，压缩收益达到20%以上。腾讯云3D MV-HEVC编码压缩支持计划于24年Q1在官网上线，大家可以通过腾讯云媒体处理（MPS）产品进行体验。
在CDN分发方面，腾讯云最近两年在低延时WebRTC传输优化做了挺多创新和实践，支持WebRTC传输加速协议栈以及全终端SDK支持，支持H.265/H.266/AV1，支持AAC、支持0-RTT信令、自适应ABR/NACK以及灵活FEC(RLNC)以及多通道传输优化，支持FFmpeg插件、IJK、小程序、EXO、OBS插件等标准，在物理多路径、协议多通道上也支持灵活标准协议扩展。
如图是WebRTC的效果，左边使用的是标准浏览器H5 WebRTC的效果，右边是快直播SDK的效果。在50%丢包的情况下，浏览器WebRTC看上去比较流畅，延迟基本控制在500ms以内，快直播SDK则比浏览器更流畅。
很多人会认为，快直播SDK传输扩展协议都是私有扩展定义，传输协议加速比较容易实现。但其实目前LEB SDK的扩展、传输优化等对客户都是开源的，腾讯云音视频通过开源的形式，与大家的共建，把WebRTC传输加速优化越做越完善。
目前97%的浏览器已经支持WebRTC协议的传输和播放。在低延时传输方面，用户反馈的最大的问题就是定价和成本太高。腾讯云音视频在低延时WebRTC场景下支持500ms以内的P2P，分享率大约为30%，目前已经有不少平台使用，在1000ms以内延时的情况下，分享率能50%+。
在实时云渲染方面，腾讯云音视频希望终端更轻量，做到音视频端云协同，以及更复杂的推理和渲染算力能够在云端完成。腾讯云实时应用云渲染产品，所有渲染工作都在云端实时完成，渲染完毕的画面及声音以音视频流的方式通过网络实时传输给用户; 全网平均延时&lt;60ms,终端Decode、渲染和推理算力不再是瓶颈; 云端实时渲染X86/ARM/板卡全面支持。
云渲染支持全球混合云资源调度，算力和存储、网络分离、桌面(X86)、移动端(AOSP、板卡、ARM)全面支持，并支持XR以及全景(Apple Vision)视频渲染。
02
多元场景
腾讯云音视频的直播、媒体处理、云渲染等产品支持公有云、专用云、混合云、SDK LIB库灵活交付和集成模式，提供灵活的合作和交付模式。
另外，在直播和RTC的场景下，腾讯云目前能做到8K@120 FPS的实时编码及处理。在8K@120FPS实时编码低延迟场景下，腾讯云相比于x265 medium大约有15%以上的压缩收益。
腾讯云媒体处理支持MV-HEVC编码、帧/参数集解析、MP4封装/解封装、HLS|DASH分发，支持iPhone15Pro录制空间视频以及Vision Pro上播放。
在云端分享方面，时下火热的弹幕游戏，其前期解决方案是主播端本机安装弹幕游戏，一方面当游戏房间参与人数多以后直播编码画面基本糊得不行；另一方面本机弹幕游戏只能在PC端开播，手机端开弹幕游戏，加上渲染和编码画面，互动效果比较差，操作也不便利。
针对这些问题，我们推出实时云渲染的弹幕游戏方案，弹幕游戏运行在云端，主播可以一键开播，不需要在本地安装弹幕游戏。腾讯云在云端实时做推理、渲染、编码、主播摄像头画面上行到云端混流以及云端WebRTC低延迟直播推流分发，同时这也解决了在本地端渲染、编码以及硬件配置升级的问题。
实时云渲染的另一个常见运用场景就是3D特效。海外某TOP直播平台希望产品在进行直播的时候能够用Unity/UE制作出3D礼物特效，画面酷炫从而提高直播间用户打赏率，但如果将这种较为复杂的3D特效礼物全部放在终端去渲染就会导致安装包很大。
腾讯云实时云渲染将较为复杂的Unity做的3D礼物特效在云端做实时渲染，渲染完成后画面再与直播流做实时混流，这样就使得客户端不需要再下载特定的Unity安装包插件，用户APP也不需要下载3D视频特效资源包，很好地解决了客户3D视频礼物特效的问题，打赏率的提升也非常明显。
在互动游戏方面，包括现在比较火的AIGC视频特效，都可以通过实时的云渲染和直播进行混流再下发。
对于目前海外比较火的Fast Channel模式，Stream Services支持标准SSAI@SCTE 广告插入，支持APP用户个性广告插入和配置，千人千面。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5423f0ec41c6d55c5883880c923fd6de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1022412090b7080e54a78b43499f088/" rel="bookmark">
			揭秘Pod状态与生命周期管理的秘密(下）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上一篇文章中主要介绍了Pod的几种容器(Init、Pause)，本文主要介绍Pod当中Hook的概念与使用。
点击 这里 可以查看所有相关文章。
Pod hook Pod hook（钩子）是由 Kubernetes 管理的 kubelet 发起的，当容器中的进程启动前或者容器中的进程终止之前运行，这是包含在容器的生命周期之中。可以同时为 Pod 中的所有容器都配置 hook。
Hook 的类型包括两种：
exec：执行一段命令HTTP：发送 HTTP 请求。 参考如下的配置：
apiVersion: v1 kind: Pod metadata: name: lifecycle-demo spec: containers: - name: lifecycle-demo-container image: nginx lifecycle: postStart: exec: command: ["/bin/sh", "-c", "echo Hello from the postStart handler&gt; /usr/share/message"] preStop: exec: command: ["/usr/sbin/nginx","-s","quit"] postStart 在容器创建之后（但并不能保证钩子会在容器 ENTRYPOINT 之前）执行，这时候 Pod 已经被调度到某台 node 上，被某个 kubelet 管理了，这时候 kubelet 会调用 postStart 操作，该操作跟容器的启动命令是在同步执行的，也就是说在 postStart 操作执行完成之前，kubelet 会锁住容器，不让应用程序的进程启动，只有在 postStart 操作完成之后容器的状态才会被设置成为 RUNNING。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1022412090b7080e54a78b43499f088/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9f7e7660146332664291d073e331a0f/" rel="bookmark">
			知识笔记（五十九）———css 美化滚动条样式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ChatgGPT4.0国内站点: 海鲸AI-支持GPT(3.5/4.0)，文件分析，AI绘图
在CSS中，你可以使用伪元素::-webkit-scrollbar以及相关的伪元素来为Webkit浏览器（如Chrome和Safari）自定义滚动条的样式。以下是一些基本的CSS规则，用于美化滚动条：
/* 整个滚动条 */ ::-webkit-scrollbar { width: 12px; /* 滚动条的宽度 */ height: 12px; /* 滚动条的高度，对水平滚动条有效 */ background-color: #f9f9fd; /* 滚动条的背景颜色 */ } /* 滚动条轨道 */ ::-webkit-scrollbar-track { border-radius: 10px; background: #e1e1e1; /* 轨道的背景颜色 */ } /* 滚动条滑块 */ ::-webkit-scrollbar-thumb { border-radius: 10px; background-color: #c1c1c1; /* 滑块的背景颜色 */ border: 3px solid #e1e1e1; /* 滑块的边框和轨道相同的颜色，可以制造“边距”的效果 */ } /* 滚动条滑块：悬停效果 */ ::-webkit-scrollbar-thumb:hover { background-color: #a8a8a8; /* 滑块的悬停颜色 */ } /* 滚动条滑块：激活时的效果 */ ::-webkit-scrollbar-thumb:active { background-color: #888888; /* 滑块的激活颜色 */ } /* 滚动条按钮（上下箭头） */ ::-webkit-scrollbar-button { display: none; /* 通常情况下不显示滚动条按钮 */ } 请注意，::-webkit-scrollbar及其相关伪元素只适用于Webkit内核的浏览器。对于Firefox，你可以使用scrollbar-width和scrollbar-color属性来自定义滚动条的样式，但这些属性提供的自定义程度不如Webkit的伪元素。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d9f7e7660146332664291d073e331a0f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35830b025e3eea821a9fe605fec69492/" rel="bookmark">
			Java 如何导出CSV文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CSV和Excel区别 Excel可能会有一系列公式，格式等，csv时纯文本文档。可以理解csv是可以被excel打开的纯文本文档。csv占用资源较少，速度更快。
Java 如何导出CSV文件 主题思路 # 要导出的内容 List&lt;Person&gt; lines = Arrays.asList(new Person()); # 构造到导出到哪里 String fileName = FileIUtils.genFileName("D:\\projects\\", lines.get(0).getClass().getSimpleName(), ".csv"); # 构造csv的文件内容 String str = buildCsvFileTable(lines); # 执行导出 FileIUtils.writeFile2(fileName, str); 生成文件名字 // 生成文件名字 public static String genFileName(String path, String name, String suffix) { String time = LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyy-MM-dd_HHMMSS")); return path + "/" + name + time + suffix; } 构造csv的文件内容 public static String buildCsvFileTable(List dataList) { Map&lt;String, Object&gt; map = ReflectUtils.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/35830b025e3eea821a9fe605fec69492/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2457aa16af50dfa69f40e173e9dbd791/" rel="bookmark">
			flask文件夹列表改进版--Bug追踪
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		把当前文件夹下的所有文件夹和文件列出来，允许点击返回上层目录，允许点击文件夹进入下级目录并显示此文件夹内容
允许点击文件进行下载
from flask import Flask, render_template, send_file, request, redirect, url_for import os app = Flask(__name__) @app.route('/') def index(): files, folder_names, folder_name = getfile() return render_template('index.html', files=files, folder_names=folder_names, folder_name=folder_name) @app.route('/download/&lt;file_name&gt;') def download_file(file_name): return send_file(file_name, as_attachment=True) @app.route('/show_folder/&lt;folder_name&gt;') def show_folder(folder_name): files, folder_names, folder_name = getfile(folder_name) return render_template('index.html', files=files, folder_names=folder_names, folder_name=folder_name) # 这里是返回上一级的目录 @app.route('/return_folder/&lt;folder_name&gt;') def return_folder(folder_name): for root, dirs, files in os.walk(os.getcwd(), topdown=True): for dir in dirs: if folder_name == dir: folder_name = os.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2457aa16af50dfa69f40e173e9dbd791/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd87ea023b6b6f72b79878d595d16cc4/" rel="bookmark">
			华为OD机试（2023A卷&#43;B卷&#43;C卷）真题目录 &#43; 在线OJ入口 &#43; 通过率
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		声明 本专栏内所有博客均有两项内容组成：
题目描述、输入描述、输出描述、用例、备注题目解析、算法源码 其中：
第1项内容均收集自互联网，专栏博客付费内容不包含此项（第1项），如若此项（第1项）内容侵犯了原著者的合法权益，可联系我：（CSDN网站注册用户名：伏城之外）进行删除。第2项内容如无特殊说明或标注，均为本人原创，任何个人或组织，在未征得本人同意时，禁止复制、盗用、采集、发布本专栏任何博客的第2项内容到CSDN之外的任何网站、书籍等各类媒体平台，或者CSDN站内其他博客。 专栏介绍 题库&amp;OJ2023 A+B+C卷专栏 + OJ权限（￥59.9）支持答疑，提供OJ环境在线刷题，OJ环境介绍+使用说明2023 A+B+C卷专栏（￥49.9）支持答疑博客试读试读_构成正方形的数量专栏每篇博客都包含详细的算法考点解析，画图+文字+原型题帮助快速理解题意，包含Java、JS、Python三种语言实现。试读_需要打开多少监控器试读_最佳的出牌方法考点分类考点分类按照算法考点对题目进行划分整理，刷一题了解一类题型，短时间速通ACM输入输出处理常规ACM模式输入输出处理对Java、JS、Python的控制台输入输出做了详细的介绍，以及难点，易错点总结关于无输入截止条件的ACM输入逻辑 真题目录 C卷新加题 100分 序号题目考点 or 实现在线OJ通过率1模拟目录管理功能树形结构进入95%+2最富裕的小家庭逻辑分析进入100%3环中最长子串逻辑分析进入100%4找座位逻辑分析进入100%5密码输入检测数据结构 / 栈进入100%6分配土地几何问题进入100%7智能成绩表动态条件排序进入100%8转盘寿司数据结构 / 栈 / 单调栈进入100%9开源项目热度榜单多条件排序进入100%10最长合法表达式双指针+栈进入11机器人搬砖二分法进入100%12内存冷热标记多条件排序进入100%13爱吃蟠桃的孙悟空二分法进入100%14虚拟理财游戏暴力枚举进入93%+15游戏分组回溯算法 / 组合问题进入100%16围棋的气逻辑分析进入100%17万能字符单词拼写、掌握的单词个数逻辑分析进入100%18小明找位置二分法进入100%19分割均衡字符串逻辑分析进入100%20小华地图寻宝深度优先搜索 || 广度优先搜索进入100%21园区参观路径动态规划进入100%22执行任务赚积分数据结构 / 优先队列进入100%23计算三叉搜索树的高度树形结构进入100%24API集群负载统计字符串，数组，集合操作进入100%25剩余银饰的重量二分法 / 二分查找进入100%26最多购买宝石数目双指针进入100%27小明的幸运数逻辑分析进入95%+28悄悄话二叉树层序遍历进入100%29CPU算力分配逻辑分析进入30分披萨递归 + 缓存优化进入100%31机场航班调度程序字符串操作 + 排序进入90%+32攀登者1逻辑分析进入33生成哈夫曼树哈夫曼树的构建 + 中序遍历34密码解密字符串操作进入92%+35来自异国的客人进制转换36求幸存数之和动态数组 || 循环链表进入100%37会议室占用时间区间问题 / 区间合并进入100%38石头剪刀布游戏逻辑分析进入100%39手机App防沉迷系统逻辑分析≈100%40小朋友来自多少小区贪心思维进入100%41精准核酸检测数据结构 / 并查集进入42多段线数据压缩逻辑分析进入43测试用例执行计划多条件排序44堆内存申请逻辑分析进入≈100%45灰度图存储逻辑分析进入 C卷新加题 200分 序号题目考点 or 实现在线OJ通过率1电脑病毒感染图论 / 单源最短路径（dijkstra）进入2小朋友分组最少调整次数逻辑分析进入3二叉树计算二叉树前序、中序遍历进入≈100%4分月饼分治递归进入≈100%5最长连续手牌回溯算法进入100%65G网络建设最小生成树进入7攀登者2逻辑分析进入8数的分解数学问题进入≈100%9部门人力分配二分法 + 双指针进入10结队编程暴力枚举 || 二叉搜索树进入100%11数据单元的变化替换分治递归进入12高效货运暴力枚举 || 完全背包进入13找数字逻辑分析进入100%14中文分词模拟器逻辑分析15符号运算数据结构 / 栈进入100%16根据IP查找城市逻辑分析进入17文件缓存系统LFU缓存实现进入18员工派遣二分法进入19跳格子3动态规划 + 单调队列进入100%20贪吃的猴子逻辑分析进入21项目排期二分法 + 回溯算法进入≈100%22亲子游戏广度优先搜索进入≈100%23可以处理的最大任务数贪心思维 + 优先队列进入24推荐多样性逻辑分析进入 C卷复用题 100分 ✔️代表抽中
序号题目考点 or 实现在线OJ通过率1求字符串中所有整数的最小和✔️逻辑分析进入100%2求满足条件的最长子串的长度✔️滑动窗口进入100%3字符串分割(二)✔️字符串，数组，集合操作进入4一种字符串压缩表示的解压字符串，数组，集合操作进入5找出符合要求的字符串子串字符串，数组，集合操作进入6英文输入法✔️字符串，数组，集合操作进入100%7字符串筛选排序✔️字符串，数组，集合操作进入8连续字母长度✔️字符串，数组，集合操作进入≈100%9拼接URL✔️字符串，数组，集合操作 || 正则匹配进入10单词接龙字符串，数组，集合操作进入11字符串序列判定✔️双指针进入100%12最长的指定瑕疵度的元音子串✔️双指针进入100%13考勤信息✔️逻辑分析进入100%14寻找相同子串KMP算法进入15字符串变换最小字符串✔️字符串，数组，集合操作进入100%16找出经过特定点的路径长度深度优先搜索17密钥格式化字符串，数组，集合操作进入18数字字符串组合倒序字符串，数组，集合操作进入19查找接口成功率最优时间段✔️动态规划 + 前缀和应用进入≈100%20在字符串中找出连续最长的数字串(含“+-”号)双指针进入21执行时长✔️逻辑分析进入100%22用户调度问题逻辑分析进入23查找众数及中位数✔️逻辑分析进入100%24最大N个数与最小N个数的和✔️字符串，数组，集合操作进入25整数对最小和✔️逻辑分析进入100%26快递运输贪心思维进入27检查是否存在满足条件的数字组合暴力破解进入28ABR 车路协同场景逻辑分析 + 正则匹配进入29水仙花数逻辑分析进入30约瑟夫问题约瑟夫环问题进入31靠谱的车✔️位运算进入100%32数字涂色逻辑分析进入33勾股数元组数学问题进入34素数之积✔️数学问题进入≈100%35表达式括号匹配数据结构 / 栈进入36括号匹配数据结构 / 栈进入37最大括号深度数据结构 / 栈进入38消消乐游戏数据结构 / 栈进入39用连续自然数之和来表达整数✔️滑动窗口进入40滑动窗口最大和滑动窗口进入41火星文计算✔️正则匹配进入100%42猴子爬山动态规划进入43We Are A Team数据结构 / 并查集进入44寻找身高相近的小朋友✔️逻辑分析进入100%45数组组成的最小数字字符串，数组，集合操作进入46整型数组按个位值排序✔️字符串，数组，集合操作进入100%47字符统计及重排字符串，数组，集合操作进入48按身高和体重排队✔️字符串，数组，集合操作进入100%49字符串排序字符串，数组，集合操作进入50翻牌求最大分动态规划进入51冠亚军排名字符串，数组，集合操作进入52计算堆栈中的剩余数字数据结构 / 栈进入535键键盘的输出逻辑分析进入54报数游戏约瑟夫环问题进入55工号不够用了怎么办？数学问题进入56全排列数学问题进入57解密犯罪时间✔️深度优先搜索进入58数组连续和✔️动态规划进入100%59最大矩阵和动态规划进入60停车场车辆统计✔️逻辑分析进入100%61绘图机器、计算面积✔️逻辑分析进入100%62最大时间深度优先搜索进入63第k个排列分治递归进入64计算礼品发放的最小分组数目贪心思维进入65判断字符串子序列双指针进入66求最多可以派出多少支团队✔️双指针进入100%67找朋友✔️数据结构 / 栈进入100%68最大股票收益贪心思维进入69单词重量逻辑分析70输出指定字母在字符串的中的索引字符串，数组，集合操作71求解连续数列逻辑分析进入72免单统计字符串，数组，集合操作73求符合要求的结对方式逻辑分析74德州扑克逻辑分析75两数之和绝对值最小逻辑分析进入76单词加密正则匹配77报数问题约瑟夫环问题 + 循环链表进入 C卷复用题 200分 ✔️代表抽中
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd87ea023b6b6f72b79878d595d16cc4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3d47cf391dd406390081ce6e0e0bd28/" rel="bookmark">
			基于 eBPF 构建下一代智能可观测系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：梵登、千陆
本文基于 KubeCon China 2023 分享整理
我们今天分享的主题是基于 eBPF 构建下一代智能可观测系统。
在开始之前呢，我先介绍一下我们自己。我是刘恺，花名是千陆，目前是阿里云 ARMS K8s 监控子产品的负责人。这位是我的同事董善东博士，花名梵登，他是阿里云 ARMS 产品 AIOps 领域的负责人。
K8s 中的可观测挑战 本次的分享主要分为三部分内容。我们先来看第一部分，K8s 中的可观测挑战。
随着云原生、K8s、微服务等概念的兴起，我们的应用发生了很多变化，比如微服务化、容器化等等。那么一切都朝着统一的标准发展，这就带给我们非常多的好处。比如极致的弹性、高效的运维、标准的运行时环境等等。但同时，K8s 也为开发者带来了很多的问题。
我们在公有云上收集了 1000 多个 K8s 中的工单，开发者将自己的基础架构迁移到 K8s 之后，实际都遇到了哪些问题呢？
通过分析工单，我们可以分析出三大挑战：
第一个，K8s 基础设施问题不容乐观，从统计图中可以看到网络相关的问题占比在 56% 以上，那么开发者在遇到这些问题的时候，作为可观测系统，我们需要采集什么数据才能回答异常的原因呢？第二个，由于应用很大的一部分复杂度下沉到了基础设施中，那么我们不仅仅需要采集应用层指标、还需要采集容器、网络等观测数据，那么在 K8s 中，我们怎样能够优雅的采集这些数据呢？第三个，当我们采集到这么多的数据之后，我们又该如何去使用这些数据来协助开发者排查问题？ K8s 中的数据采集方案 好的，让我们带着这三个问题，我们进入后面的内容：K8s 中的数据采集方案。
我们通常来说 K8s 应用我们可以分为很多层。最上面一层是业务层，包括我们的一些前端页面、小程序；应用层就是对标我们的后端应用；容器层可以有很多种运行时，比如 containerd，docker 等；基础设施层包括 K8s。那么到此就结束了吗？其实并没有。因为 K8s 应用它的复杂度在不断的下降，所以说往往我们需要继续去深入。可能会涉及到网络插件、Linux 内核，甚至是一些硬件驱动等。到此我们就可以回答之前提到的第一个问题了。在 K8s 中我们到底需要哪些数据？答案就是我们****目之所及的所有数据。 无论在任何一层出现故障，都可能会导致我们整体系统的异常。
接下来我们再回顾第二个问题，就是我们怎样去采集这些数据。
其实目前来说，我们可观测领域在每一层都有很多独立的解决方案。比如在业务层，有拨测、前端监控、业务日志分析等方案；在应用层，有 Opentelemetry、Jaeger 等 APM 系统；对于容器层和基础设施层，有 Prometheus 搭配多种 Exporters 的观测方案。但是当他继续深入的时候，这些传统的可观测系统就很少涉及了。这就出现了观测盲区的问题。另外呢，虽然在很多层都有各自的观测方案，但是他们的数据缺乏关联性。它们彼此都是相对独立的，没有一个统一的关联维度能将各层的数据进行融合，因此存在数据孤岛现象。
那么有没有办法去解决这些问题呢？
答案就是 eBPF 技术。 我先简单介绍一下 eBPF 技术。eBPF 是一个运行在 Linux 内核中的虚拟机，它提供一套特殊的指令集并允许我们在不重新编译内核、也不需要重启应用的情况下加载自定义的逻辑。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a3d47cf391dd406390081ce6e0e0bd28/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a37624abe93ecc57b339c9b853a6e5da/" rel="bookmark">
			面试复盘5——后端开发——一面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 本文主要用于个人复盘学习，因此为保障公平，所以本文不指出公司名，题目编号只是为了自己区别而已。对待面经，望读者还是更多从其中学习总结，而不是去碰原题。
面试岗位信息 后端开发秋招，上海某大中厂，二次元。Boss投递，大约三天后约面。
一面（12.26） 总体1h，大约15分钟项目，15分钟语言基础，15分钟八股，15分钟笔试。面试官态度很好，会一直引导、给出提示。算是我目前冬招过程中，收益比较大的一场面试了。
这个面试的有点紧张了，自我介绍疯狂的“然后”…还是需要巩固一下这个稿。
先聊了项目1，该项目内容是一个kafka做的死信队列服务。 如何判断消息是否重发？——根据发送时候设置的参数。
自己消息发送失败时候如何做？——发回来这个主题再。（后续考虑一下这里）
服务的吞吐，大量信息时候如何处理——目前没考虑，因为死信收到大量数据，那其他地方早就挂的不能再挂了。
如何做？——， 增加消费者，利用kafka的分区。（这个后续再考虑完善一下，包括多个东西存数据库这种如何做）
你们这个项目使用到kratos，使用了他的哪些功能？——我只知道个依赖注入…wire
什么是依赖注入？
kafka消息消费可能会失败，失败涉及到重试，使用kafka重试是否会出现重复消费，丢消息情况？如何解决。
kratos的其他一些模块有了解吗？选一个讲一下。
接下来开始聊的是语言基础 先问了Python…我不理解为什么我go的他问我那么多Python呜呜呜。
Python问题 is和==的区别。
有哪些常见的数据结构？
list和集合区别。
Python常见的内置方法？比如map。
golang问题 开协程，其中出现了空指针导致panic，会怎么样？
对一个数组循环，for range，使用kv时候有什么要注意的吗？大概是这个东西的知识点k、v是对元素的引用，始终是一个变量。
函数传递值时候，不同数据结构（数组、切片、map、struct）入参时候，有什么区别？哪些是地址哪些不是。
（这里我struct不清楚，他帮我举例了一个参数struct在函数内修改时，是否会影响？答案是会根据struct内的内容来判断，看他是否是地址还是什么）
深浅拷贝参考这里修改拷贝的值，是否影响另一个？
浅拷贝什么时候影响，什么时候不影响？（浅拷贝只是拷贝了第一级，所以根据他内容判断，是值类型还是引用类型）(此部分没找见直接文章，待我回头研究一下源码。。)
八股 http的全称是什么？——超文本传输协议。我没记得…
是哪一层的？——应用层。应用层还有什么？
Http协议常用的状态码。
http和https的区别。
tls是怎么保障安全的。
Post和Get的区别。
发起请求时候，请求组成包里面第一行是请求方法和路由地址，第二部分是header，第三部分是body。——列举几个常见的header？
进程之间通信方式。
线程之间通信方式。
进程和线程的区别。
索引的优缺点。（这里缺点的时候回答是会变慢，面试官建议让我说再深入点。我补充了B+tree这些）
编程 LeetCode-1. 两数之和
for+hash表
之后顺带聊了一下hash表的底层结构
总结 1、发现自己基础还是很不扎实，很多面试高频都还没背完。
2、算法题还是手生。。简单题也能卡。
3、紧张了。。
4、有时候要尽可能深入的聊吧。
这个面试还是算我近期几场面试中，直接收益最高的一场了…给我带来的很多努力的方向。但自我感觉不好，有点泼天富贵接不住的感觉了，哎。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/408bef949f56200676ba4f102e1f18c7/" rel="bookmark">
			如何使用iframe嵌套跨域类型的网址？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本章教程，主要介绍一下，如何利用iframe嵌套一些存在跨域性的问题。
这里我们以百度首页网址进行举例说明。
如果我们直接嵌套百度的首页地址，如下
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;百度一下，你就知道了&lt;/title&gt; &lt;style&gt; #myFrame { width: 800px; height: 600px; margin: 0 auto; display: block } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;iframe src="https://www.baidu.com" id="myFrame" frameborder="0" scrolling="yes"&gt;&lt;/iframe&gt; &lt;/body&gt; &lt;/html&gt; 访问会出现一下的情形。
解决办法：
我的办法是利用nginx的反向代理来解决跨域问题。
server { listen 80; server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; location / { proxy_hide_header Content-Security-Policy; proxy_hide_header X-Frame-Options; proxy_pass https://www.baidu.com; } error_page 500 502 503 504 /50x.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/408bef949f56200676ba4f102e1f18c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f1e26f303c2131eb81a0e08ad4d34f7/" rel="bookmark">
			基于多反应堆的高并发服务器【C/C&#43;&#43;/Reactor】（中）EventLoop初始化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个Dispatcher是一个事件分发模型，通过这个模型,就能够检测对应的文件描述符的事件的时候,可以使用epoll/poll/select,前面说过三选一。另外不管是哪一个底层的检测模型,它们都需要使用一个数据块,这个数据块就叫做DispatcherData。除此之外,还有另外一个部分,因为在这个反应堆模型里边对应一系列的文件描述符,都属于epoll/poll/select,但是这些文件描述符,它们不是固定的。
可能我们和客户端新建立了一个连接,那么就需要把某个节点就是某个文件描述符添加到这个Dispatcher模型上边或者说服务器和客户端断开连接了,对应的这个文件描述符,就需要从Dispatcher对应的检测集合中删除还有一种情况就是要修改Dispatcher检测的这些文件描述符对应的事件 对于刚才描述的这三种情况，不管是哪一个,都可以把它们称为任务。既然是任务,如果产生了多个这样的任务，就需要把这些任务存储起来,所以对应的就需要有一个任务队列。在C语言里边是没有所谓现成的任务队列可直接拿来使用.C++中就有list,可以直接拿一个队列来直接用,或者说拿一个list来直接用,在C语言里边,我们只能自己写了。
既然它是一个任务队列,也就意味着这个队列里边的节点的个数是不固定的,所以我们就需要一个动态的模型,可以实现一个链表。这个链表的节点是什么类型的?是ChannelElement类型.所谓ChannelElement类型。它里边主要其实是一个Channel，还有下一个节点的指针。通过指向下一个节点的指针，就可以把每一个节点连接起来了。当这个任务队列里边有了任务之后，我们就需要通过一个循环，把链表里边所有的节点都读出来。
如果这是一个添加事件的节点，那么我们就把这个文件描述符添加到Dispatcher对应的检测集合中。 如果它是删除的，那么我们就把这个文件描述符从Dispatcher的检测集合中删除。 如果它是修改事件，那么我们就把这个节点在Dispatcher中的事件做一个修改。 这个EventLoop里边有一个任务队列，可以说这个EventLoop它是一个生产者和消费者模型，
消费者是谁呢？ 就是这个Dispatcher。生产者是谁呢？ 生产者有可能是其他的线程，比如说主线程和客户端建立了连接，剩下的事就是通信。如果要通信，就对应一个通信的文件描述符。主线程就把这个任务添加到了子线程对应的这个EventLoop里边。此时在taskQueue里边就多出来了一个节点。在遍历这个任务队列的时候，读到这个节点之后，就需要把当前的这个节点添加到Dispatcher对应的检测模型里边。 另外，在这个EventLoop里边，还有一个ChannelMap，这个ChannelMap也是我们实现的，是通过一个数组来实现的。基于这个ChannelMap，就能够通过一个文件描述符得到对应的那个channel，为什么要得到那个channel呢？因为在这个channel里边有文件描述符，它的读事件和写事件对应的回调函数，就是事件触发之后，执行什么样的处理动作。
【思考】什么时候用到了这个ChannelMap了呢？
在实现epoll/select/poll的时候，分别调用了epoll_wait函数/select函数/poll函数，通过遍历内核传出来的这个集合，就得到了触发对应事件的那个文件描述符。但我们现在处理不了，因为得不到对应的channel,我们可以通过EventLoop里边提供的这个ChannelMap就能够得到对应的Channel指针，这个Channel指针就可以调用事件对应的处理函数了。
这三大块之外，还有一些其他的数据成员，比如threadID。因为在当前的服务器里边有多个EventLoop，每个EventLoop都属于一个线程。所以我们可以记录一下这个EventLoop它所对应的那个子线程的线程ID。关于子线程的这个名字肯定是我们给它起的，因为子线程创建出来之后，它只有一个ID，这是系统分配的。关于它的名字，操作系统是没有告诉我们的。
ThreadCondition是条件变量，可用于阻塞线程
【思考】ThreadMutex这个互斥锁它保护的是什么？
其实它保护的是这个任务队列。为什么要保护任务队列呢？对于这个EventLoop来说，它能够被多少个线程操作呢？
如果是主线程的EventLoop，那就是一个。如果是子线程的EventLoop，那就有可能是两个，为什么是两个呢？ 当前，线程在执行这个EventLoop的时候，它肯定要遍历这个taskQueue吧，也就是当前线程需要读这个任务队列。除此之外，如果主线程和客户端建立了一个连接,主线程是有可能要把一个任务添加到这个EventLoop,对应的任务队列里边，就是额外的另一个线程了。如果涉及到两个线程操作，同一块共享资源，那么我们是要通过互斥锁来保护这个共享资源的。如果不保护，肯定就会出现数据混乱。 整个项目的结构，在当前这个多反应堆模型的服务器程序里边，它是有多个EventLoop模型的。首先，在主线程里边就有一个EventLoop主线程的，这个EventLoop去检测客户端有没有新的连接到达。如果有新连接，就建立新连接。之后，主线程把这个通信的任务给到线程池里边，把主线程的那个EventLoop也传进来。一定要注意这个EventLoop和主线程的EventLoop是同一个实例。也就是说，线程池里边的这个MainEventLoop和外边这个MainEventLoop它们对应的是同一块内存地址。
另外，在线程池里边还有若干个子线程，每个子线程里边都对应一个EventLoop。每个子线程里边的EventLoop它们主要是处理通信的文件描述符相关的操作。这些都是在子线程里边来完成的：
比如说要把一个通信的文件描述符添加到EventLoop里边。如果服务器和客户端断开连接了，那么就需要把通信的文件描述符从EventLoop里边删除或者要修改这个通信的文件描述符检测的事件 【思考】那么，为什么右侧的TcpConnection里边也有一个EventLoop呢？
关于这个TcpConnection，其实它是封装了用于通信的文件描述符，在这个模块里边，是把子线程里边那个EventLoop的地址传递给了TcpConnection。
在每个线程里边，都有一个EventLoop,也就是说EventLoop是属于线程的，不管是主线程还是子线程，里边都有一个EventLoop。然后在这个TcpConnection里边，也有一个EventLoop，但是不是说EventLoop属于TcpConnection，而是TcpConnection属于EventLoop。
如果TcpConnection，它属于EventLoop，那么这个TcpConnection就属于对应的某一个子线程。EventLoop属于哪个子线程，这个TcpConnection它就属于哪个子线程。它对应的那些任务处理就是和客户端通信，接收数据以及发送数据的操作就在哪个子线程里边来完成。在线程池里边传进来了一个主线程EventLoop，主线程的EventLoop也是一个反应堆实例。
【思考】为什么要把主线程的反应堆实例传递给线程池呢？
是因为我们在给线程池做初始化的时候，如果指定线程池的子线程个数为0，此时线程池就没有了，不能工作。
为了能够保证线程池能够工作，也就传进来了一个主线程的反应堆实例，在没有子线程的情况下，那么就借用主线程的反应堆实例来完成对应的这一系列的任务处理。在此时，客户端和服务器建立连接之后，得到了用于通信的文件描述符，这个通信的文件描述符被TcpConnection封装起来了。我们就需要把这个TcpConnection放到一个反应堆模型里边，就是放到主线程的EventLoop里边，这样客户端和服务器的通信操作也就能实现了。这种比较极端的情况，对于程序来说，它就是一个单反应堆模型。
如果在创建线程池的时候指定这个子线程的个数大于0，那么就是一个多反应堆的服务器模型。如果在创建线程池的时候指定线程的个数等于0，此时就是一个单反应堆的服务器模型。 &gt;&gt;总结
（1）反应堆模型中的EventLoop介绍 详细介绍了反应堆模型中的EventLoop，包括它的主要作用、如何被多个线程操作，以及它与任务队列和Dispatcher检测模型的关系。对于理解反应堆模型的工作原理至关重要。 （2）主线程与子线程的交互过程
主线程与子线程通过任务队列进行交互，子线程处理通信相关的文件描述符操作。主线程它只能负责和客户端建立连接，如果这个连接建立好了，剩下的事情都是需要由这个子线程来完成的。所以主线程肯定不会给你去处理任务队列里边的节点。在主线程里边，其实它是有一个反应堆模型的，在当前的这个子线程里边也有一个反应堆模型。每个反应堆模型里边都有一个Dispatcher。关于这个Dispatcher就是epoll、poll、或者select，所以主线程去处理的话，这个任务就放到主线程的那个Dispatcher里边了，这样很显然是不对的。故在子线程的任务队列里边有了任务之后，还需要交给子线程的Dispatcher去处理。因此这个节点的处理，还需要判断当前线程到底是什么线程。如果它是主线程不能让它去处理，如果是子线程，直接让它去处理。​​​​​​​ （3）EventLoop与任务队列的关系
当任务队列中有任务时，会通过循环遍历链表，将任务添加到Dispatcher对应的检测模型中。 （4）文件描述符的管理
新连接建立或断开时，或要修改Dispatcher检测的这些文件描述符对应的事件时，文件描述符的添加、删除和修改操作都与EventLoop紧密相关。 未完待续~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d8f748f35820bc38588a45aebbc76c2/" rel="bookmark">
			数模学习day01-层次分析法模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		已经一个多月没有更新过文章了，为了保住那绩点的意思微弱的优势，直接开摆，开始复习专业课和公共课考试了，结果虽然有遗憾但是还是算不错，至少没有掉到3.xx嘿嘿。
然后现在就要开始学习数学建模和算法同步了。接下来的文章也会更新这两个方面的内容。好了进入正题吧。
本文章根据B站UP：数学建模学习交流的正版视频编写
第一讲：层次分析法 这是建模比赛最基础的模型之一，其主要用于解决评价类问题（例如：选择哪种方案最好。哪位运动员或者员工的表现更优秀等）
问题一： 评价类问题可以使用打分解决 最终通过整理得到如下的权重表格
最终计算完成之后得到的得分是：华科：0.515、武大：0.485
华科的分数更高
总结 问题二： 层次分析法例题 一般有三个问题：
1.我们的评价目标是什么
2.达成这个目标有哪几种方案
3.评价的标准是什么
一般来说，评价指标题目中是不会告诉我们的，实质就是根据什么东西评判，比如显卡的显存，CPU的主频等。
那么如何回答这三个问题呢？
上网查询 可以选择：知网、万方、百度学术、谷歌学术等搜索相关的文献
找不到就直接和队友叫唤哈哈哈
然后这里搜索有一个很强的网站叫做==&gt;&gt;虫部落: https://search.chongbuluo.com/
然后回到我们的题目
现在已经确定了指标：
然后就可以想到下面的这张表格，也就是之前的权重表格
在确定影响某因素的诸因子在该因素中所占的比重时，遇到的主要困难是这些比重常常不易定量化。此外，当影响某因素的因子较多时，直接考虑各因子对该因素有多大程度的影响时，常常会因考虑不周全、顾此失彼而使决策者提出与他实际认为的重要性程度不相一致的数据，甚至有可能提出一组隐含矛盾的数据。
也就是说，直接思考权重可能会导致分析错误。那么如何避免这个问题呢？
分治思想：两个两个指标进行比较，最终根据两两比较的结果来推算出权重 。
那么层次分析法的思想就显现出来了：
通过将这个重要程度生成为一张矩阵表格可以得到。
但是小明在这里不是真正的小明，而是一个“专家”。后文会提到
那么再填完这个表格之后就可以得到如下判断矩阵（也可以称为正互反矩阵）
计算权重 题目：
通过询问“专家”的方式，获得一个个的判断矩阵
剩余矩阵如下
不一致问题 在填写之后，可能会出现一种问题
也就是前后大小值比较不一致，发生冲突的问题。
通过这两个公司可以得出如下的公式
然后可以先来观察一致矩阵的特点
通过观察发现：各行（各列）之间成倍数关系
那么可以得出一致性矩阵的定义如下：
上两幅图的差别就是一个4，一个是5，我们如何知道这个修改的差距大不大呢，那么就可以通过一致性检验判断了。
一致性检验原理：检验我们构造的判断矩阵和一致矩阵是否有太大的差别
这里tr是矩阵的迹
对应的特征向量也就是k的第一列。
一致性检验的标准步骤 最后判断CR&lt;0.1，则认为判断矩阵的一致性是可以接受的。否则进行修正
即：
一致矩阵计算权重 计算方法如下：
当然也可以使用第二列或者第三列算，由于每一列都是成比例的，所以权重是一样的
矩阵计算权重：算数平均法 和一致矩阵的方法是一样的，但是！！由于判断矩阵各列之间不一定成比例，所以每一列都需要分别计算权重，然后再求权重的平均值
其数学描述为：
可以体现在论文之中
矩阵计算权重：几何平均法 判断矩阵计算权重：特征值法 使用性质：一致矩阵有一个特征值为n，其他特征值都为0
特征向量刚好是矩阵的第一列
在计算完权重之后填入权重表，最多使用的还是特征值法，一般只将特征值法的权重填入
这里计算如果使用计数器来说也可以，但是比较麻烦，我们可以使用Excel表格来处理
这里要记得锁定单元格
按F4即可
问题三： 层次分析法第一步：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d8f748f35820bc38588a45aebbc76c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/adb97e3bb0e71d0f80edfa070bea9587/" rel="bookmark">
			【SpringCloud笔记】（11）消息驱动之Stream
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Stream 技术背景
底层不同模块可能使用不同的消息中间件，这就导致技术的切换，微服务的维护及开发变得麻烦起来
概述 官网：
https://spring.io/projects/spring-cloud-stream#overview
https://cloud.spring.io/spring-cloud-static/spring-cloud-stream/3.0.1.RELEASE/reference/html/
Spring Cloud Stream中文指导手册：
https://m.wang1314.com/doc/webapp/topic/20971999.html
什么是SpringCloudStream
官方定义Spring Cloud Stream是一个构建消息驱动微服务的框染。
应用程序通过inputs 或者 outputs来与Spring Cloud Stream中binder对象交互。
通过我们配置来binding(绑定)，而Spring Cloud Stream的binder对象负责与消息中间件交互。
所以，我们只需要搞清楚如何与Spring Cloud Stream交互就可以方便使用消息驱动的方式。
通过使用Spring Integration来连接消息代理中间件以实现消息事件驱动。
Spring Ccloud Stream为一些供应商的消息中间件产品提供了个性化的自动化配置实现，引用了发布-订阅、消费组、分区的三个核心概念。
目前仅支持RabbitMQ、Kafka。
Stream设计思想 标准MQ流程
生产者/消费者之间靠消息媒介传递信息内容（Message）
消息必须走特定的通道（消息通道MessageChannel）
消息通道里的消息如何被消费呢，谁负责收发处理（消息通道MessageChannel的子接口SubscribableChannel，由MessageHandler消息处理器所订阅）
为什么要引入Stream
比方说我们用到了RabbitMQ和Kafka，由于这两个消息中间件的架构上的不同，像RabbitMQ有exchange，kafka有Topic和Partitions分区
这些中间件的差异导致我们实际项目开发给我们造成了一定的困难，我们如果用了两个消息队列的其中一种，后面的业务需求，我们想往另外一种消息队列进行迁移，这时候无疑就是一个灾难性的，一大堆东西都要重新推倒重新做，因为它跟我们的系统耦合了，这时候SpringCloud Stream给我们提供了一种解耦合的方式。
在没有绑定器这个概念的情况下，我们的SpringBoot应用要直接与消息中间件进行信息交互的时候，由于各消息中间件构建的初衷不同，它们的实现细节上会有较大的差异性。
通过定义绑定器Binder作为中间层，完美地实现了应用程序与消息中间件细节之间的隔离。
Stream对消息中间件的进一步封装，可以做到代码层面对中间件的无感知，甚至于动态的切换中间件(rabbitmq切换为kafka)，使得微服务开发的高度解耦，服务可以关注更多自己的业务流程
Stream的消息通信方式遵循了发布-订阅模式
INPUT对应于生产者，OUTPUT对应于消费者
Stream标准流程套路 binder：很方便的连接中间件，屏蔽差异Channel：通道，是队列Queue的一种抽象，在消息通讯系统中就是实现存储和转发的媒介，通过channel对队列进行配置Source（生产）和sink（消费）：简单地可理解为参照对象是spring cloud stream自身，从stream发布消息就是输出，接收消息就是输入 常用注解
组成说明Middleware中间件，目前只支FRabbitMQ和KafkaBinderBinder是应用与消息中间件之间的封装，目前实行了KafKa和RabbitMQ的Binder,通过Binder可以很方便的连接中间件，可以动态的改变消息类型（对应kafka的topic，RabbitMQ的exchange)，这些都可以通过配置文件来实现@Input注解标识输入通道，通过该输入通接收到的消息息进入应用程序@Output注解标识输出通道，发布的消息将通过该通道离开应用程序@StreamListener监听队列，用于消费者的队列的消息接收@EnableBinding指信道channel和exchange绑定在一起 要新建3个子模块
cloud-stream-rabbitmq-consumer8802：作为消息接收模块
cloud-stream-rabbitmq-consumer8802：作为消息接收模块
消息驱动之生产者 新建cloud-stream-rabbitmq-provide8801：作为生产者进行发消息模块
pom文件
&lt;artifactId&gt;cloud-stream-rabbitmq-provide8801&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-stream-rabbit&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/adb97e3bb0e71d0f80edfa070bea9587/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11abac5117e1763774cdf7cffdda71d7/" rel="bookmark">
			【kubernetes】集群网络（一）：基础篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Flannel 1 路由表 &amp; arp &amp; fdb 1.1 路由表 任何网络设备都需要路由表，路由表用来决定，当收到数据包时，该向哪里进行转发。路由表项通常会包含以下几个字段：
Destination：目的地Gateway：网关Mask：掩码Interface：网络接口NextHop：下一跳 当设备收到网络数据时，从中解析出目的IP地址(假设为DEST_IP)，然后遍历Destination不是0.0.0.0的条目，并执行：DEST_IP&amp;Mask == Destination，如果为真说明找到一个转发条目。于是，可以从转发条目中获取到对应的网络接口，就会将数据包从该网络接口转发出去。如果没有找到对应的转发条目，就会转发到默认网关，也就是Destination为0.0.0.0的条目。
因此，路由表是从三层的层面解决包的转发问题，Linux中通过ip route或者route -n可以查看路由表。
1.2 arp表 当网络数据包转发时，底层还是要通过一个或者多个二层网络，在二层网络中就需要知道对方的MAC地址。于是，当内核的链路层收到包要进行转发时，就会去arp表查询接收方/网关的MAC地址。
arp表维护的就是ip-&gt;mac的对应关系，Linux中通过arp -a可以查看arp表。
1.3 fdb 前面的路由表是三层的转发信息，当需要跨网络转发时就需要查找路由表，然后将包转发给下一跳。如果在当前网络进行转发时就需要查找fdb表，fdb表主要包含的字段有：
MAC地址：用目的MAC地址在该字段查找老化时间：表项在一定时间如果没有被刷新则会被删除类型：permanent(永久)、temporary(临时) 使用bridge fdb show dev flannel.1可以查看flannel.1虚拟网络设备的fdb转发表。
2 Bridge &amp; veth 2.1 Bridge Bridge的中文含义是网桥，提到网桥就不得不提到类似的另外3种设备：集线器、交换机、路由器，它们的主要区别是对应的网络层次不一样，能够理解的信息不一样，从而导致转发行为有所不同。
集线器工作在物理层，由于物理层只是处理单纯的信号，无法理解数据包的内容，因此，它在收到数据后，只能向其他所有端口转发网桥工作在数据链路层，因此，网桥能够读懂数据链路帧的头部信息，也就是其中的MAC信息，因此，它在收到数据后，可以用查询MAC地址转发表，从而判断可以将数据包从哪个端口转发出去交换机有二层交换机和三层交换机之分，二层交换机相当于网桥，三层交换机工作在网络层，因此，三层交换机能够读懂IP包头的信息，因此，它能够通过查询路由表，从而将数据包转发给下一跳(常见的网络拓扑结构中，接入层一般使用二层交换机，它拥有较低的成本和较多的接口数量，而汇聚层和核心层一般使用三层交换机，它拥有较高的成本和较高的转发性能)路由器工作在三层，与三层交换机的主要区别在路由表项数量、转发性能上 Linux中的Bridge是个虚拟网桥，可以将网络接口加入该虚拟网桥。Linux中操作Bridge的命令有ip bridge、bridge、brctl。
brctl命令可以用于操作网桥：
brctl show 查看网桥brctl addbr $BRNAME 创建网桥brctl delbr $BRNAME 删除网桥brctl addif $BRNAME $DEV 将接口加入网桥brctl delif $BRNAME $DEV 将接口从网桥中删除 剩下的命令基本都是一些配置参数相关。
安装brctl命令的方式如下：
yum search -y bridge-utils echo 1 &gt; /proc/sys/net/ipv4/ip_forward bridge命令有两个常用的子命令：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/11abac5117e1763774cdf7cffdda71d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b825cfcd5cafc6323d2b66b4bdf9851b/" rel="bookmark">
			软件开发算法为王，编程语言各取所好——我看IT圈茶余饭后的“鄙视链”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IT圈茶余饭后的“鄙视链” IT圈茶余饭后的“鄙视链”，简直就是一场瞬间的情感大戏！“我们写xxx的看不起写xxxx“，无处不见这种互相鄙视的情绪就像一场刺激的游戏，每个人都觉得自己是鄙视链的最顶端。快来看看这个IT圈里的“鄙视链”究竟是怎样的吧！
一、书店感受 前几天到广西壮族自治区首府南宁出差，中午到南宁书城逛了一下。
现在去书店，一般是陪着小孩的，很久没去关注和翻阅IT行业的书籍了。这次出差，没有带小孩，所以特别到展销IT类书籍的书柜转了一下，感觉变化很大。
Visual Basic、Delphi、Visual C++是当年Windows系统应用程序开发工具的“三驾马车”，如今介绍它们的书籍均已了无踪影，当然C++ Prime这样介绍编程语言技术本身的经典书籍还是有的。介绍Java语言的书从数量上来看要比以前少介绍PHP、C#、Kotlin、HTML+CSS+JavaScript、等语言的书籍不算多比较多介绍Vue、angularJS、Spark、JQuery、Spring、微信息小程序开发等开发框架和平台的书籍比较多介绍AI、机器学习、Python的书籍是数量最多的网络安全、软考的书籍也比较多 二、回首往昔 （一）BASIC 我学习的第一个编程语言是GW Basic，Basic是Beginner’s All-purpose Symbolic Instruction Code 的缩写，意为初学者通用符号指令代码，这是一种解释型高级语言，用的教育是谭浩强、田淑清编著的《BASIC语言（四次修订本）》。微软后来又开发了Quick BASIC，集成在DOS中，我当老师时教学生用的就是这个Basic。进入Windows时代，微软又推出了Visual Basic，这时的Visual Basic是可编译可解释的语言，而在微软的办公软件OFFICE中，也集成了 Visual Basic for Applications（VBA）。
（二）PASCAL 我学习的第二个编程语言是PASCAL， 这是一种编译型高级语言，当时上课用的教材是郑启华编著的《PASCAL程序设计（第二版）》，上机使用的是Borland开发的Turbo PASCAL 5.0，第一次感受了调试程序的乐趣，不过感觉Begin——End输入费时。进入Windows后，Borland又推出了Delphi，这是一个基于Object Pascal的可视化快速开发环境，它的推出轰动 一时，也让Borland在Windows时代再度崛起。可惜的是由于对Delphi的发展路线有不同意见，主导开发Delphi 1 ~3开发的Anders Hejlsberg被微软挖角，去微软主导开发J++语言、C#语言以及.Net平台了。 （三）汇编语言 我学习的第三个编程语言是8086汇编语言，它属于低级语言，而之前学习的BASIC、PASCAL都属于高级语言。当时上机使用的是MASM，这个MASM没有像Turobo PASCAL那样的集成开发环境，通常是先用DOS系统自带的 文本编辑器edit来编辑源代码，保存为.asm文件，然后在命令行下使用masm命令进行汇编，生成.obj文件，再用link进行连接，生成.exe文件，如果源代码符合.com文件的要求，还可以用exe2bin将exe文件转换为com文件，最后用debug或symdeb来进行调试。学习汇编语言不仅可以帮助我们了解计算机的工作原理，其中的几种内存寻址方式也有助于我们理解高级语言中利器——指针，而且编写同样功能的程序，用汇编语言生成的可执行程序文件体积要比高级言生成的可执行程序小的多。后来也用过Borland开发的Turbo ASM（TASM），它的汇编效率又比MASM32高，同样的源代码，TASM生成的EXE文件通常会比MASM生成的小。进入Windows时代后，众多高手整出了MASM32，可以用来开发Windows下的应用程序。
（四）FoxBase+ 我学习的第四个编程语言是FoxBase+，严格来说，FoxBase+是Fox Software公司于1984年推出的一个关系型数据库系统，可以用来开发一些信息管理系统，比如图书管理系统，学籍管理系统。使用的教材是郑甫京、沈金发著的《FOXBASE+关系型数据库系统》后面微软公司件收购了Fox Software公司，陆续推出了Foxpro和Visual Foxpro，当年学校组织了一个课题小组，就是一边学一边用Foxpro来做系统，用的还是台湾人写的教材。可惜Visual Foxpro最终被微软放弃了。
（五）C语言 我学习的第五个编程语言是C语言，这也是一种编译型高级语言。有PASCAL和汇编语言做基础，学习起来还是很比较轻松的。特别喜欢C语言的++、--，以及{}，让代码看起来简捷明了。当时上课用的教材是谭浩强编著的《C程序设计》，上机用的是Borland 开发的Turbo C 2.0，里面带的一些图形演示代码让人惊叹不已。
后来参加工作，结合工作需要和自己的爱好，先后自学了Visual Basic（包括VBA）、Delphi、Visual C++、MASM32 、JavaScript、Jscript、Python等。当微软推出J++语言和Viusal J++开发工具时，我也去买了教程书回来学习，不料书还没看完，由于Sun提起诉讼，微软就终止了Visual J++的研发，这也让我和Java绝缘。
由于我最早接触的CPU为80286的电脑，对解释型语言和编译型语言编写代码的执行效率体会还是比较深的，所以一直青睐编译型语言。
三、当下之选 现在，Windows平台下的程序我还是喜欢用MASM32。
在进行数据处理分析时最喜欢用JavaScript，因为有电脑有浏览器就能运行，不需要像其它语言需要安装部署，而且它的++、--，以及{}让程序代码看起来像C/C++一样简捷。
为了从网站搜集数据信息，我也用Python写过程序，利用Python丰富的库，编写程序确实很方便，加上AI、机器学习上的广泛应用，让Python成为当前最热门的语言之一。
四、我的看法 在摩尔定律推动下，电脑硬件性能不断提升，解释型语言和编译型语言编写代码的执行效率不再像以前那样明显了。而且有新的编程语言不断涌现，为我们提供了新的选项。
所以，在我看来，软件开发算法为王，编程语言各取所好，无所谓IT圈茶余饭后的“鄙视链”。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce8095512f2942eea54f549f9065b537/" rel="bookmark">
			ini文件操作基于ini-parser-netstandard
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装操作类 ini-parser-netstandard ini基本操作 所有代码示例都需要以下 using 子句：
using IniParser; using IniParser.Model; NI 数据存储在嵌套字典中，因此访问与节中的键关联的值非常简单。使用提供的方法之一加载数据。
var parser = new FileIniDataParser(); IniData data = parser.ReadFile("Configuration.ini"); 检索命名节内键的值。值始终以 s 的形式检索。string
string useFullScreenStr = data["UI"]["fullscreen"]; // useFullScreenStr contains "true" bool useFullScreen = bool.Parse(useFullScreenStr); 修改字典中的值，而不是检索到的值，并保存到新文件或覆盖。
data["UI"]["fullscreen"] = "true"; parser.WriteFile("Configuration.ini", data); 合并 ini 文件 合并两个（或多个）ini 文件为一个单方法操作： var parser = new IniParser.Parser.IniDataParser(); IniData config = parser.Parse(File.ReadAllText("global_config.ini")); IniData user_config = parser.Parse(File.ReadAllText("user_config.ini")); config.Merge(user_config); // config now contains that data from both ini files, and the values of // the keys and sections are overwritten with the values of the keys and // sections that also existed in the user config file 合并部分 config["
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce8095512f2942eea54f549f9065b537/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0afd358792d0fda6a1ac1f92f931a0b/" rel="bookmark">
			CPU亲和性和NUMA架构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		何为CPU的亲和性
CPU的亲和性，进程要在某个给定的 CPU 上尽量长时间地运行而不被迁移到其他处理器的倾向性，进程迁移的频率小就意味着产生的负载小。亲和性一词是从affinity翻译来的，实际可以称为CPU绑定。
在多核运行的机器上，每个CPU本身自己会有缓存，在缓存中存着进程使用的数据，而没有绑定CPU的话，进程可能会被操作系统调度到其他CPU上，如此CPU cache（高速缓冲存储器）命中率就低了，也就是说调到的CPU缓存区没有这类数据，要先把内存或硬盘的数据载入缓存。而当缓存区绑定CPU后，程序就会一直在指定的CPU执行，不会被操作系统调度到其他CPU，性能上会有一定的提高。
另外一种使用CPU绑定考虑的是将关键的进程隔离开，对于部分实时进程调度优先级提高，可以将其绑定到一个指定CPU核上，可以保证实时进程的调度，也可以避免其他CPU上进程被该实时进程干扰。
我们可以手动地为其分配CPU核，而不会过多的占用同一个CPU，所以设置CPU亲和性可以使某些程序提高性能。
Linux操作系统的CPU亲和性特征
操作系统部分Linux的调度程序同时提供”软CPU亲和性”和”硬CPU亲和性”
软亲和性：进程要在指定的 CPU 上尽量长时间地运行而不被迁移到其他CPU。
Linux 内核进程调度器天生就具有被称为 软 CPU 亲和性（affinity） 的特性，因此linux通过这种软的亲和性试图使某进程尽可能在同一个CPU上运行。
硬亲和性：将进程或者线程绑定到某一个指定的cpu核运行
虽然Linux尽力通过一种软的亲和性试图使进程尽量在同一个处理器上运行，但它也允许用户强制指定进程无论如何都必须在指定的处理器上运行。
硬亲和性使用场景
硬亲和性场景：需要保持高CPU缓存命中率时、需要测试复杂的应用程序时。
保持高CPU缓存命中率：如果一个给定的进程迁移到其他地方去了，那么它就失去了利用 CPU 缓存的优势。实际上，如果正在使用的 CPU 需要为自己缓存一些特殊的数据，那么所有其他 CPU 都会使这些数据在自己的缓存中失效。因此，如果有多个线程都需要相同的数据，那么将这些线程绑定到一个特定的 CPU 上是非常有意义的，这样就确保它们可以访问相同的缓存数据（或者至少可以提高缓存的命中率）。否则，这些线程可能会在不同的 CPU 上执行，这样会频繁地使其他缓存项失效
NUMA的由来
NUMA(Non-Uniform Memory Access)，即非一致性内存访问，是一种关于多个CPU如何访问内存的架构模型。
NUMA出现之前，所有CPU对内存的访问都要通过北桥来完成。此时所有CPU访问内存都是“一致的”。
这样的架构称为UMA(Uniform Memory Access)，直译为“统一内存访问”，这样的架构对软件层面来说非常容易，总线模型保证所有的内存访问是一致的，即每个处理器核心共享相同的内存地址空间。但随着CPU核心数的增加，这样的架构难免遇到问题，比如对总线的带宽带来挑战、访问同一块内存的冲突问题。
为解决上述问题，NUMA架构出现了，即不同的内存器件和CPU核心从属不同的Node，每个Node都有自己的内存控制器。BIOS将收集到的Node信息通过ACPI报告给操作系统，OS就可以根据NUMA节点间的距离远近访问距离自己最近的内存，从而降低总线堵塞和提高性能。
NUMA距离
NUMA距离意指NUMA节点之间的逻辑距离，距离越近访问延迟越低。
Linux下可使用numactl -H查看NUMA距离
参考：
关于CPU亲和性，这篇讲得最全面 - 腾讯云开发者社区-腾讯云
https://forum.huawei.com/enterprise/zh/thread/590169249215823872
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c12e203244ba7c070f4f6f37f3fff904/" rel="bookmark">
			Unity中Shader裁剪空间推导（正交相机到裁剪空间的转化矩阵）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、正交相机视图空间 转化到 裁剪空间 干了什么1、正交相机裁剪的范围主要是这个方盒子2、裁剪了之后，需要把裁剪范围内的坐标值化到[-1,1]之间，这就是我们的裁剪空间。3、在Unity中，设置相机为正交相机4、在这里设置相机的近裁剪面和远裁剪面 二、把正交相机的方盒子内的坐标 转化到 裁剪空间1、我们在Unity创建两个游戏对象来解释2、正交相机坐标 到 裁剪坐标 的映射关系3、化简X轴坐标4、化简Y轴坐标5、化简Z坐标(OpenGL下 [-1,1])6、化简Z坐标(DirectX下 [0,1]) 三、把转化后的坐标转化为矩阵1、OpenGL下2、DirectX 前言 我们把顶点坐标信息转化为裁剪空间。有可能使用到正交相机信息 或 透视相机。我们在这篇文章中，推导一下正交相机视图空间下的坐标转化到裁剪空间的矩阵。
本地空间-&gt;世界空间-&gt;观察空间-&gt;裁剪空间-&gt;屏幕映射 一、正交相机视图空间 转化到 裁剪空间 干了什么 1、正交相机裁剪的范围主要是这个方盒子 因为使用的是右手坐标系。所以，摄像机的Z轴正方向是在X轴正方向右侧的。 2、裁剪了之后，需要把裁剪范围内的坐标值化到[-1,1]之间，这就是我们的裁剪空间。 在不同平台下裁剪空间的X 和 Y轴范围都是[-1，1]OpenGL下，Z范围[-1,1]DirectX下，Z范围[0,1]
3、在Unity中，设置相机为正交相机 Unity视图窗口使用了左手坐标系，Z轴正方向 在 X轴正方向左侧。但是，我们计算使用的是右手坐标系，这里需要注意。
4、在这里设置相机的近裁剪面和远裁剪面 二、把正交相机的方盒子内的坐标 转化到 裁剪空间 1、我们在Unity创建两个游戏对象来解释 我们的绿线Cube相当于我们的裁剪空间我们的大长方体相当于世界空间下的游戏对象当我们进行转化时，对大长方体进行缩放、平移即可转化到裁剪空间 2、正交相机坐标 到 裁剪坐标 的映射关系 l ≤ x ≤ r l \leq x \leq r l≤x≤r 化为 -1 ≤ x ≤ \leq x \leq ≤x≤ 1 b ≤ y ≤ t b \leq y \leq t b≤y≤t 化为 -1 ≤ x ≤ \leq x \leq ≤x≤ 1 f ≤ z ≤ n f\leq z \leq n f≤z≤n 化为 -1 ≤ x ≤ \leq x \leq ≤x≤ 1 3、化简X轴坐标 l ≤ x ≤ r l \leq x \leq r l≤x≤r
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c12e203244ba7c070f4f6f37f3fff904/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bbf660a6b4a73e43ed5750a85748457/" rel="bookmark">
			LLaMA-2 下载&amp;demo使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LLaMA-2 下载&amp;demo使用 1. LLaMA-2 下载&amp;demo使用1.1 meta官网1.2 huggingface1.3 其他源1.4 huggingface下载模型和数据加速 1. LLaMA-2 下载&amp;demo使用 1.1 meta官网 llama2下载
在meta的官网 Meta website 进行下载申请（注意地区不要选择China会被ban）
主要有三类模型的参数：
llama 2llama 2-codellama 2-guard 一般需要魔法下载
基本的步骤：
meta官网申请llama2的使用（一般是秒通过，可以把三类模型全部勾选）去 facebookresearch/llama: Inference code for LLaMA models 的GitHub中clone仓库到本地解压后运行download.sh脚本开始模型的下载复制邮件中给出的URL，选择需要的模型权重（7B 13B等）进行下载 下载原始的llama2-7b（13GB）和llama2-7b-chat（13G）
llama2使用
根据meta llama on GitHub的例子，我们可以按照以下步骤来运行llama2：
根据requirement.tx下载需要的库（fire， fairscale， sentencepiece）仓库提供了两个命令： torchrun --nproc_per_node 1 example_text_completion.py \ --ckpt_dir llama-2-7b/ \ --tokenizer_path tokenizer.model \ --max_seq_len 128 --max_batch_size 4 torchrun --nproc_per_node 1 example_chat_completion.py \ --ckpt_dir llama-2-7b-chat/ \ --tokenizer_path tokenizer.model \ --max_seq_len 512 --max_batch_size 6 会得到以下结果：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4bbf660a6b4a73e43ed5750a85748457/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0f5f3728d03aa54e541afdf2d0e1256/" rel="bookmark">
			PYTHON基础：最小二乘法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最小二乘法的拟合
最小二乘法是一种常用的统计学方法，用于通过在数据点中找到一条直线或曲线，使得这条直线或曲线与所有数据点的距离平方和最小化。在线性回归中，最小二乘法被广泛应用于拟合一条直线与数据点之间的关系。
对于线性回归，我们希望找到一条直线的方程式 y = mx + b，其中 m 是斜率，b 是截距，使得这条直线与数据点的距离最小。具体而言，我们希望找到使得观测数据点 (xi, yi) 与直线上对应点 (xi, mx + b) 的距离平方和最小的斜率 m 和截距 b。
最小二乘法的基本思想是，通过最小化观测数据点与拟合直线的距离平方和来确定最佳的斜率和截距。该距离可以使用欧几里得距离（即两点之间的直线距离）来衡量。通过最小化距离平方和，可以得到一组最优的斜率和截距，使得拟合直线与数据点的整体偏差最小。
最小二乘法通常使用最小二乘解来计算最佳的斜率和截距。最小二乘解是通过求解一个最小化误差平方和的优化问题而得到的。在线性回归中，最小二乘解可以通过求解正规方程式来获得，即通过求解矩阵方程 (X^T * X) * beta = X^T * y，其中 X 是输入变量矩阵，beta 是待求解的参数向量，y 是输出变量向量。
最小二乘法的拟合结果可以通过各种方式进行评估，例如计算拟合直线与数据点之间的残差和拟合优度等指标。拟合直线的斜率和截距可以提供有关数据点之间关系的定量信息，例如变量之间的相关性、趋势和预测能力等。
总结而言，最小二乘法是一种用于拟合一条直线或曲线与数据点之间关系的统计学方法。在线性回归中，最小二乘法被广泛应用于找到最佳的斜率和截距，以描述数据点之间的线性关系。该方法通过最小化观测数据点与拟合直线之间的距离平方和，提供了一种可靠的方式来分析和预测数据。
基本的数学形式这样子的：
这里我们只需要求出他的两个参数：斜率和截距，这里我们有专门的算法，具体的计算过程如下：
在这里因为计算太复杂了，我们还可以通过一系列的数学化简得到更加简洁的式子：
最后这里就变成了求众多数据点的x、y的一些相乘相加的一些关系。，在这里我用一个组数据作为例子分别用简单的数学计算和矩阵计算来讲解
假设有这么一组数据，这里一共是9个点，我们来看下
x = [0, 4, 8, 12, 16, 20, 24, 28, 32] y = [394.33, 329.50, 291.00, 255.17, 229.33, 204.83, 179.00, 163.83, 150.33] 我们先来看下第一种简单的数据计算
def calu(x,y,n):#这里输入三个值，x、y和一个有多少组树 #这里我们先定义初始的变量，等会用于求和 sumx=0 sumy=0 smulx=0 smuly=0 mulxy=0 #我们要用循环来求和 for value in range (0,n): sumx=sumx+x[value]#求所有x的加和 sumy=sumy+y[value] smulx=smulx+x[value]*x[value]#求所有x的平方和 smuly=smuly+y[value]*y[value] mulxy=mulxy+x[value]*y[value]#求所有x*y的平方和 avex=sumx/n#求平均值 avey=sumy/n sxx=smulx-(sumx*sumx)/n sxy=mulxy-(sumx*sumy)/n #求截距和斜率 m=sxy/sxx b=avey-m*avex print("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0f5f3728d03aa54e541afdf2d0e1256/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/879115f4a8940bbbb14072e67787b698/" rel="bookmark">
			保姆级系列：git的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 什么是git Git是—款免费、开源的分布式版本控制系统，主要用于敏捷高效地处理任何或小或大的项目。Git起源于Linus Torvalds为了帮助管理Linux内核开发而开发的开放源码的版本控制软件。
本文档主要学习代码的托管。
2.git下载安装地址 https://git-scm.com/downloads
3.git工作原理 4个专用名词：
workspace： 工作区
staging area： 暂存区/缓冲区
local repository： 本地仓库
remote repository: 远端仓库
常用命令：
add: 把当前文件放入暂存区域。
commit: 给暂存区域生成快照并提交。
push: 从本地仓库推送到远端仓库
fetch/clone: 从远端仓库提取/克隆到本地仓库
checkout: Checkout命令用于从历史提交（或者暂存区域）中拷贝文件到工作目录，也可用于切换分支。
pull: 从远端仓库拉取到工作区
4.实验操作 在桌面创建一个test_repostiory文件夹登录码云https://gitee.com/，没有账号先创建账号。在码云里面创建仓库，步骤如下：
1）点击右上角加号
2）新建仓库
3）选项介绍：
4）创建成功：
5）文件介绍：
其他文件可以百度一下，这里就不讲了。
下面的内容是命令操作：
5.git init lvshi@XiaoXinPro-16-ARP8 MINGW64 /d/test_repostory $ git init Initialized empty Git repository in D:/test_repostory/.git/ 在test_repositroy文件夹生成隐藏的.git文件，如下图：
6.配置用户名和邮箱。 用户名在码云上查看：点击个人主页，如下图红框中就是用户名：
在新建的test_repository文件夹下右键打开git batch here，并输入如下代码：
l@XiaoXinPro-16-ARP8 MINGW64 /d/test_repostory (master) $ git config --global user.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/879115f4a8940bbbb14072e67787b698/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10ab18a1cc59b12f96963778ca0293c2/" rel="bookmark">
			编码器TLE5012B使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言一、通信协议1.1 SSC 协议1.2 IIF协议1.3 其他协议 二、SSC寄存器2.1 SSC寄存器位型2.2 配置寄存器校验和2.3 寄存器说明2.3.1 状态寄存器2.3.2 激活状态寄存器2.3.3 角度值寄存器2.3.4 角速度寄存器2.3.5 角度转数寄存器2.3.6 帧同步寄存器2.3.7 接口模式1 寄存器2.3.8 SIL 寄存器2.3.9 接口模式2 寄存器2.3.10 接口模式3 寄存器2.3.11 X偏移寄存器2.3.12 Y偏移寄存器2.3.13 同步性寄存器2.3.14 IFAB寄存器（多功能）2.3.15 接口模式 4 寄存器（多功能）2.3.16 温度系数寄存器2.3.17 X原始值寄存器2.3.18 Y原始值寄存器2.3.19 增量式计数寄存器 2.4 通信示例（SSC 命令）2.4.1 读角度值2.4.2 读角速度和角转数2.4.3修改接口模式2 寄存器 2.5 引信值 三、代码示例 前言 TLE5012B 角度传感器基于 iGMR 技术，可检测平行于封装表面磁场 360°变 化。可应用于汽车和工业领域里转角位置检测如方向盘转角，电机位置等。
TLE5012B 内部集成角度计算模块，可以将原始值（sine 和 cosine）进行数字处理后输出绝对角度。集成自动标定和温度补偿功能，在温度范围和寿命周期里可以达到 1°精度。汽车级认证，可工作在-40℃至 150℃范围。
TLE5012B 具备极其精确的角度分辨率(15bit)以及快速的信号处理能力和较短的延时/更新率，极其适合精确测定高动态应用中的转子位置。同时TLE5012B 具有先进的诊断功能及安全特性,确保了产品高可靠性。
一、通信协议 TLE5012B支持多种通讯协议，即SSC(Synchronous Serial Communication)协议, PWM( Pulse-Width-Modulation）协议，SPC（Short-PWM-Code ，兼容SENT协议）协议,HSM（Hall Switch Mode）模式以及IIF（Incremental Interface）协议。本文主要介绍SSC和IIF协议。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/10ab18a1cc59b12f96963778ca0293c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b51b8adb1a55977a739f7f186719773/" rel="bookmark">
			机器学习部分相关概念
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据集(Data Set)即数据的集合，每一条单独的数据被称为样本(Sample)。
对于每个样本，它通常具有一些属性(Attribute)或者特征(Feature)，
特征所具体取得值被称为特征值(Feature Value)。
西瓜数据集 色泽根蒂纹理青绿稍蜷模糊乌黑蜷缩清晰 如上表所示的西瓜数据集中，色泽、根蒂、纹理就是西瓜的特征，乌黑、青绿为特征“色泽”的特征值。
训练集(Training Set)和测试集(Testing Set)：在建立机器学习模型过程中，通常将数据集分为训练集和测试集。其中，训练集用于对模型参数进行训练，测试集用于对训练好的模型进行测试，验证模型的性能好坏，包括准确率、泛化能力。
验证集(Validation Set)：用于在训练过程中检验模型的性能，以调整参数和超参数。
验证集是为了使最终模型在测试集上测试之前对模型有一个初步的评价，根据评价结果以调整参数，当模型在验证集上表现不错时，最后在测试集上验证模型的最终性能。若没有验证集，我们只能在最终的测试集上查看测试结果，而此时我们是不能再修改模型参数的，在测试集上验证只是查看模型的最终效果。而模型在训练出来后，根据训练集去调整参数，即使得到效果再好，模型也不一定会在测试集上表现最优。这种情况下，才需要划分出验证集。
评估(Assessment)：在训练出算法模型后，为了验证算法模型的好坏，需要对该算法在数据集上根据评价指标进行测试，这个测试过程就是算法的评估。在不同领域，有不一样的评估指标。例如，在信息检索和推荐系统领域，通常使用准确率、召回率作为衡量算法好坏的指标。
模型(Model)：模型是一种算法的表达，模型用于在海量数据中查找模式或进行预测。从数据中使用算法得到模型的过程称为学习(Learning)或训练(Training)。
过拟合(Overfitting)：过拟合和欠拟合是模型在训练过程中的两种不同状态。过拟合是指模型在训练集上表现很好，但在测试集上却表现很差。模型对训练集“死记硬背”，没有理解数据背后的规律，泛化能力差。过拟合的原因主要是数据噪声太大、特征太多、模型太复杂等造成的，可通过清洗数据、减少模型参数，降低模型复杂度、增加惩罚因子（正则化）等方法加以解决。 欠拟合(Underfitting)：模型在训练集上就表现很差，不能获得足够低的误差，无法学到数据背后的规律。欠拟合的原因主要是由于训练样本数量少、模型复杂度过低、参数还未收敛就停止循环等造成的，可通过增加样本数量、增加模型参数、提高模型复杂度、增加循环次数或改变学习率等方法加以解决。
正则化(Regularization)：正则化就是在原始模型中引入正则项或惩罚项，以防止过拟合和提高模型泛化性能的一类方法的统称。
交叉验证(Cross Validation)：就是通过各种组合切分方式，将数据集划分为不同的训练集和测试集，用训练集对模型进行训练，用测试集测试模型的好坏，由此得到的多个不同的训练集和测试集组合以验证模型的方式称为交叉验证。一般交叉验证用于数据不是很充分的情况下，或为了说明模型效果的稳定。有时，交叉验证也可用于模型选择。
特征选择(Feature Selection)：在构建机器学习模型时，选择最具代表性和影响力的特征是非常重要的。特征选择可以帮助提高模型的性能、减少过拟合的风险，并且可以加速模型训练的过程。
特征提取(Feature Extraction)：有时候原始数据的特征维度非常高或者包含了大量冗余信息，这时可以利用特征提取的方法将原始特征转换成更加简洁、有效表示的特征，例如主成分分析(PCA)等技术。
多样性(Diversity)：在构建集成学习(Ensemble Learning)模型时，多样性是指集成中各个基学习器之间的差异性。通过增加多样性，可以提高集成模型的泛化能力和稳定性。
偏差-方差权衡(Bias-Variance Tradeoff)：在机器学习中，模型的误差通常可以分解为偏差和方差两部分。偏差描述了模型预测值与真实值之间的差距，而方差描述了模型对训练数据的敏感程度。偏差-方差权衡是指在模型设计中需要平衡偏差和方差，以获得最优的泛化能力。
超参数调优(Hyperparameter Tuning)：在机器学习模型中，除了模型参数外，还存在一些超参数需要事先确定。超参数调优是指通过交叉验证等技术寻找最佳的超参数组合，以提高模型性能。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a0bb19d22101f913a787060874bea9a/" rel="bookmark">
			“Tab键”强制转换为“空格键”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		“Tab键”强制转换为“空格键”
除了Python，代码一般建议不要使用“Tab键”，而是用4个"空格键"代替。原因是不同编辑器对“Tab键”解释存在差异，有的编辑器解释为2个占位符，而其余的编辑器解释为4个占位符。如果代码中存在“Tab键”，会导致在编辑器A中对齐的代码，用编辑器B打开会显示为非对齐状态，影响代码阅读和代码整洁。
可以在编辑器中设置将“Tab键”自动转换为4个"空格键"。这样我们按下键盘上的“Tab键”时，实际输入的文本是4个“空格键”。
下面介绍SourceInsight、VsCode、Notepad++三种编辑器的设置方法。
1. SourceInsight
1.1 设置“Tab键”、“空格键”可见
打开Source Insight，选择“Options” -&gt; "File Type Options"； 勾选“Visible tabs”、“Visible spaces”，如图1所示； 设置完成，退回代码界面就可以看到“Tab键”显示为“&gt;&gt; ”，空格键显示为“....”，如图2所示 图1
图2
1.2 设置“Tab键”自动转换为4个“空格键”
打开Source Insight，选择“Options” -&gt; "File Type Options"； 勾选“Expand tabs to spaces”，如图3所示； 设置完成，退回代码界面，按下键盘上的“Tab键”，实际输入的文本是4个“空格键” 图3
2. Visual Studio Code
2.1 设置“Tab键”、“空格键”可见
打开 Visual Studio Code，点击菜单栏中的“File” -&gt; "Preferences" -&gt; "Settings"； 在设置搜索位置：搜一下 Whitespace，找到：【Editor：Render Whitespace】，把【selection】改为【all】，即可显示空格； 在设置搜索位置：搜一下 ControlCharacters，选中勾选框，即可显示tab。 2.2 设置“Tab键”自动转换为4个“空格键”
打开 Visual Studio Code，点击菜单栏中的“文件”（File）。 在弹出的菜单中选择“首选项”（Preferences）。 在“首选项”菜单中，选择“设置”（Settings）。 在“设置”菜单中，搜索“tabSize”选项，并将其值设置为 4。 点击“保存”（Save）按钮保存设置。 3. Notepad++
3.1 设置“Tab键”、“空格键”可见
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a0bb19d22101f913a787060874bea9a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/219267288f4bb89dbebd86c535f331a1/" rel="bookmark">
			【JavaWeb学习笔记】18 - 文件上传下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目代码 https://github.com/yinhai1114/JavaWeb_LearningCode/tree/main/fileupdown
目录
文件上传
一、基本介绍
二、文件上传的基本原理
​编辑
三、文件上传应用实例
四、文件上传的注意细节
1.解决中文乱码问题
2.分割文件夹
3.防止重名
4.百度WebUploader
5.空目录构建问题
文件下载
一、文件下载原理分析
二、文件下载案例
三、文件下载注意事项细节
文件上传 一、基本介绍 1.文件的上传和下载，是常见的功能。
2.后面项目就使用了文件上传下载。
3.如果是传输大文件，一般用专门工具或者插件
4.文件上传下载需要使用到两个包,需要导入
二、文件上传的基本原理 最后http请求走到servlet
三、文件上传应用实例 四、文件上传的注意细节 1.解决中文乱码问题 //解决接收到文件名是中文乱码问题 servletFileUpload.setHeaderEncoding("utf-8"); 2.分割文件夹 // // Source code recreated from a .class file by IntelliJ IDEA // (powered by FernFlower decompiler) // package com.yinhai.utils; import java.time.LocalDateTime; public class WebUtils { public WebUtils() { } public static String getYearMonthDay() { LocalDateTime ldt = LocalDateTime.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/219267288f4bb89dbebd86c535f331a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94bf500230a51c9690d8dc7a4b9dbd31/" rel="bookmark">
			深入Apache Commons Config：管理和使用配置文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第1章：引言 咱们都知道，在软件开发中，管理配置文件是一件既重要又让人头疼的事。想象一下，咱们的应用程序有一堆设置需要调整，比如数据库的连接信息、应用的端口号，或者是一些功能的开关。如果这些信息硬编码在代码里，每次改动都要重新编译整个程序，那岂不是太麻烦了？这时候，配置文件就派上用场了。它允许咱们在不修改代码的情况下，灵活地调整这些设置。
Apache Commons Config，正是这样一个强大的工具，它帮助Java开发者轻松管理应用配置。使用它，咱们可以优雅地加载、读取、写入和监控配置文件。不仅如此，它支持多种格式的配置文件，比如XML、Properties、JSON等，非常方便。小黑在这里就要给咱们详细介绍一下这个工具的魅力所在。
第2章：Apache Commons Config简介 让小黑来介绍一下Apache Commons Config是什么。它是Apache软件基金会提供的一个开源Java库，专门用于处理应用程序的配置。这个库不仅可以帮咱们处理不同格式的配置文件，还可以让咱们以统一的方式访问这些配置信息。这意味着不管配置信息是存储在Properties文件、XML文件还是数据库中，咱们都可以用相同的方式来获取这些信息。够聪明的，对吧？
让小黑来举个例子。假设咱们有一个Properties格式的配置文件，内容大概是这样的：
# application.properties database.url=jdbc:mysql://localhost:3306/mydb database.user=root database.password=123456 这是一个标准的数据库连接配置。使用Apache Commons Config，小黑可以轻松地读取这些信息。看看下面这段代码：
import org.apache.commons.configuration2.Configuration; import org.apache.commons.configuration2.builder.fluent.Configurations; public class AppConfig { public static void main(String[] args) { Configurations configs = new Configurations(); try { Configuration config = configs.properties("application.properties"); String dbUrl = config.getString("database.url"); String dbUser = config.getString("database.user"); String dbPassword = config.getString("database.password"); System.out.println("数据库URL: " + dbUrl); System.out.println("用户名: " + dbUser); System.out.println("密码: " + dbPassword); } catch (Exception e) { e.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94bf500230a51c9690d8dc7a4b9dbd31/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1d8d4058104416b5b3a411d8088355c/" rel="bookmark">
			关于大一上学期STM32培训的经验及教训（完全初学）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		主要是写出来给要直接学习STM32的人的一些经验或者是教训以及踩坑点，我后续也会开始写STM32的一些我已经学会的基础性的初学者应用型教程（如没有前置知识点亮LED，我会在这里说GPIO是个啥，怎么选口，怎么查手册等基础入门方法）
我也要期末考试后回家了，我想写这个文章是因为上学期的培训也结束了，我先说明我现在STM32会什么
1.点亮LED，使用蜂鸣器（GPIO的查找，配置，和应用）
2.用LED和蜂鸣器以一定周期交替响应（模块在代码上的配合）
3.雨雪传感器检测信号让LED亮（TIM配置，外部中断代码配置）
4.四按键模块制作三人抢答器，并且让LED亮（TIM捕获）
5.数码管显示HH
6.手机和单片机交互，让手机app上显示一个累加的数字（蓝牙模块）
7.设计一个0-99的计时器，要求能完成倒计时报警（TIM内部中断）
8.利用LCD1602设计时钟，要求能显示分秒，设定时间
9.电机调速八个挡位（PWM配置）
10.AD采集直流电压，DA转换
11.呼吸灯（PWM）
12.外部中断测量方波频率（内部终端加外部中断的配置）
我是上来就直接学习STM32，用的STM32F103ZET6，用的是B站的STM32教程加试验箱自带的视频学习，在学习过程中有很多问题。
一.STM32的前置知识是什么？需要学嘛？我该如何入门？
我自己学了这么久之后，我仅仅是会用，不理解不了解不通透。
1.首先是C语言，我们只需要学习C语言的入门基础就ok了，我自写有C语言 “入门” 章节的全知识点-CSDN博客
这里面我们需要学习的是，数组，函数，循环语句，选择语句，结构体，这几个很常用，我也有分批的写在我的博客里。
2.这里我说一下，我只会C语言，我现在要以身试险，在假期去补电路，电模数模等知识，这些一些基础，我查别人的文章的话，只需要了解是啥就ok了，我回头给大家总结需要用到的知识并且补到文章里。
3.看教程实操入门，基础知识的话，只是用的话，先C语言，就可以尝试去使用STM32，但是我强烈建议先去学51，因为51最简单也能形成更好的对单片机的认知。 我寒假会去补51的知识的因为32太痛苦了。
二.STM32的板子如何选择？
我查手册的时候，提供了各种各样的板子，我是因为手边有F103ZET6的板子，但是我建议是根据你选择的教程购买相应的板子使用，因为单片机的实操大于理论。但是我选ZET6的另一个原因是它的模块更多，我的教程也都能用。
三.STM32学习过程中不会了，没人教怎么办？
我在学习过程中，是有学长帮助的，但是实际上，我也没问什么，大部分都是自己摸索，找CSDN的平台，在B站上找硬件模块的电路讲解，利用别人的代码去理解和应用，学习别人的代码，根据教程一步一步理解代码的作用。总的来说我一般是跟着B站教程一个一个打代码的，当我真的不会或者不理解的时候我会去找学长，或者去找CSDN的帖子，实在不行你试试问我？
四.STM32学习的过程中有技术上的不理解（不知道教程中GPIO到底是个啥，是干嘛的，不明白定时器是个啥，不明白干嘛的，不会配置）
这些根本不需要担心，我提供我的思路，先看教程先应用先跟着教程配置，然后再回去看教程的电路，模式等的讲解，不会多看两遍，再不会就是去百度这个名字在百度百科找，或者在CSDN上找，因为我是大一上直接干STM，我自己也不会电路，看不懂什么是上拉什么是下拉，只能很抽象的记住，所以我建议如果你不急的话，先去学电路，电摩数模的基础知识，然后学51，或者从51下手去理解32，直接攻32虽然可以，但是对于我这个大一的我还是强烈不推荐。
我后期为了巩固知识我也会去写各个知识点的代码加应用，理解关键点，然后讲解基础，因为我补完基础再继续进行32，我大一下学期还是要学32的，实验室的任务罢了.
对大一想直接攻击单片机同学们的话：如果时间允许，学C语言基础，学51单片机，（学一点点的电路和数模电模），会用51再攻击32吧，我寒假要去补我的基础了。
我之后也会一个一个的把我学习32的过程应用无偿发出来的
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9dc5ce6d703abddc16c705b832f779b1/" rel="bookmark">
			Unity Text组件宽度自适应文本长度的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在某些应用场景，我们可能需要把不同的文本按照某种格式排序，并且使用同一个格式的预制体复制出来赋值。但是这样会存在组件宽度一样，但是文本长度不一样，导致文本堆叠的情况，如下图：
此时就需要文本自动由文本自身长度自适应宽度。
具体可以通过以下方法实现：
public TextMeshProUGUI text; void Start() { text.text = "你好呀!"; float preferredWidth = text.preferredWidth; RectTransform rectTransform = text.GetComponent&lt;RectTransform&gt;(); rectTransform.sizeDelta = new Vector2(preferredWidth, rectTransform.sizeDelta.y); } 通过以上方法，最终可实现如下效果：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/660a8d01cbef79e933c6d4d793da6a4a/" rel="bookmark">
			Java-Maven3.9.6：Maven依赖管理 / 安装-配置-使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、理解Maven Maven是一个开源的项目管理工具，主要用于构建和管理Java项目、依赖管理和文档生成，它可以自动下载所需的依赖库，并自动构建整个项目。理解Maven需要了解以下几个方面：
1. 项目对象模型（Project Object Model，POM）：Maven使用POM来描述项目的结构和依赖关系。POM是一个XML文件，包含了项目的元数据信息，如项目的组织结构、依赖项、构建配置等。
2. 项目生命周期（Build Lifecycle）：Maven定义了一套标准的构建生命周期，包括了clean、validate、compile、test、package、install和deploy等阶段。每个生命周期阶段都包含了一系列的插件目标，用于执行相应的任务。
3. 依赖管理：Maven能够自动下载和管理项目的依赖项。通过在POM文件中定义依赖项，Maven可以自动下载所需的库文件，并将其添加到项目的类路径中。
4. 插件机制：Maven的插件机制使得可以通过插件来扩展和定制构建过程。Maven提供了大量的常用插件，如编译插件、测试插件、打包插件等。同时，也可以编写自定义的插件来满足特定需求。
5. 构建过程和目录结构：Maven的构建过程是基于约定的，即项目的源代码和资源文件应该按照特定的标准目录结构进行组织。这样做可以使得构建过程更加简洁和可靠。
Maven是一个强大的项目管理工具，能够简化和规范Java项目的构建和管理过程。通过了解上述几个方面，可以更好地理解和使用Maven。
二、Maven 对 Java JDK 版本的要求 Maven 3.x.x 版本需要JDK 1.7及以上版本，Maven 2.x.x版本需要JDK 1.4及以上版本，Maven 1.x.x版本需要JDK 1.3及以上版本。
三、检测自己电脑java jdk的版本 JAVA_HOME指明JDK安装路径，此路径下包括lib，bin等文件夹
echo %java_home%
查看java版本
java -version 查看已安装的 Java 编译器（JDK）的版本号
在命令行中运行javac -version将显示当前安装的 JDK 的版本号。这个命令用于检查 JDK 是否正确安装并确定版本号，以确保可以编译和运行 Java 程序。
javac -version
四、JDK Release Notes 可以看到jdk版本已经到了21
JDK Release Notes
五、下载Maven 5.1、下载 Maven – Download Apache Maven
5.2、下载完成后，将安装文件解压到指定的目录下 5.3、设置环境变量 5.3.1、找到环境变量 此电脑--右键属性--高级系统设置--环境变量
5.3.2、设置Maven_Home环境变量 新建系统变量
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/660a8d01cbef79e933c6d4d793da6a4a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90717e1716536c5de2bb7f17fe63fb45/" rel="bookmark">
			Day72力扣打卡
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 打卡记录 参加考试的最大学生数（压缩状态DP） 链接
class Solution: def maxStudents(self, seats: List[List[str]]) -&gt; int: m, n = len(seats), len(seats[0]) # a[i] 是第 i 排可用椅子的下标集合 a = [sum((c == '.') &lt;&lt; j for j, c in enumerate(s)) for s in seats] f = [[0] * (1 &lt;&lt; n) for _ in range(m)] for j in range(1, 1 &lt;&lt; n): lb = j &amp; -j f[0][j] = f[0][j &amp; ~(lb * 3)] + 1 for i in range(1, m): j = a[i] while j: # 枚举 a[i] 的子集 j f[i][j] = f[i - 1][a[i - 1]] # 第 i 排空着 s = j while s: # 枚举 j 的子集 s if (s &amp; (s &gt;&gt; 1)) == 0: # s 没有连续的 1 t = a[i - 1] &amp; ~(s &lt;&lt; 1 | s &gt;&gt; 1) # 去掉不能坐人的位置 f[i][j] = max(f[i][j], f[i - 1][t] + f[0][s]) s = (s - 1) &amp; j j = (j - 1) &amp; a[i] f[i][0] = f[i - 1][a[i - 1]] return f[-1][a[-1]] 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c64c50a8c9e25df11c2d4e7efa2248b/" rel="bookmark">
			python读取xlsx格式的excel
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 读取excel表格数据最好用的还是pandas库
首先是安装pandas
pip install pandas 引入pandas
import pandas as pd 读取excel，xlsx格式数据
# 读取xlsx格式的数据 def readexcel(): df = pd.read_excel("./test.xlsx",header=None) df.columns = df.iloc[4] data = [] for index, row in df.iterrows(): if index &lt; 5: continue line = (generate_random_string(20),row['序号'],row['姓名'],row['性别'],row['年龄']) data.append(line) return data 说明
1、读取表格数据，header=None 因为pandas默认打开第一行为字段名称，可作为下标直接读取数据，加上header参数后，将不默认第一行为字段名称行。
df = pd.read_excel("./后续监管查询列表.xlsx",header=None) 2、我的表格第5行为字段名称行，以下代码配置字段名称行
df.columns = df.iloc[4] 3、按字段名称获取数据
line = (generate_random_string(20),row['序号'],row['姓名'],row['性别'],row['年龄']) 最后调用方法就ok了。
data = readexcel() 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31ebaa7ac0680f93655d792c739bed58/" rel="bookmark">
			使用pycharm虚拟环境和使用conda管理虚拟环境的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用 PyCharm 虚拟环境和使用 Conda 管理虚拟环境有一些区别，主要涉及到环境的创建、依赖管理、跨平台性等方面。以下是一些关键区别：
创建环境：
PyCharm 虚拟环境： PyCharm 使用其自己的虚拟环境管理器（通常是 venv），可以通过 PyCharm 的界面或者在命令行中使用 python -m venv 创建虚拟环境。Conda 管理虚拟环境： Conda 使用独立的环境管理器，可以通过 conda create 命令创建虚拟环境。Conda 的环境管理更为灵活，可以包含不同版本的 Python，并且可以安装非 Python 的软件包。 依赖管理：
PyCharm 虚拟环境： 使用 PyCharm 管理的虚拟环境可以通过 PyCharm 的界面或者在命令行中使用 pip 安装 Python 包。Conda 管理虚拟环境： Conda 负责管理所有包括 Python 在内的软件包。它可以用于安装 Python 包、系统工具、第三方软件等，这些都是在 Conda 环境中独立隔离的。 跨平台性：
PyCharm 虚拟环境： 虚拟环境的创建和管理方式在不同操作系统上可能有一些差异，但 PyCharm 提供了跨平台的界面。Conda 管理虚拟环境： Conda 是一个跨平台的包管理器，能够在不同操作系统上以相同的方式工作。这使得 Conda 管理的环境在 Windows、Linux 和 macOS 上更加一致。 包的来源：
PyCharm 虚拟环境： 使用 pip 安装 Python 包时，通常是从 Python Package Index（PyPI）上下载安装。Conda 管理虚拟环境： Conda 包括一个专门的仓库，称为 Conda Forge，以及 Anaconda 仓库。Conda 可以从这些仓库中获取软件包。 速度：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/31ebaa7ac0680f93655d792c739bed58/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/15/">«</a>
	<span class="pagination__item pagination__item--current">16/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/17/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>