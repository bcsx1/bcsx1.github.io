<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0c28b5b51ac3d98de686f6c3e38aa68/" rel="bookmark">
			ubuntu18.04安装gtsam
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、安装相关依赖：
sudo apt-get install libeigen3-dev sudo apt-get install libtbb-dev 2、gtsam (Georgia Tech Smoothing and Mapping library, 4.0.0-alpha2)
wget -O ~/Downloads/gtsam.zip https://github.com/borglab/gtsam/archive/4.0.0-alpha2.zip cd ~/Downloads/ &amp;&amp; unzip gtsam.zip -d ~/Downloads/ cd ~/Downloads/gtsam-4.0.0-alpha2/ mkdir build &amp;&amp; cd build cmake .. sudo make install 注意：
编译之前需要把系统关闭，防止冲突，后续实验无法安装好
cmake -DGTSAM_BUILD_WITH_MARCH_NAITVE=OFF -DGTSAM_USE_SYSTEM_EIGEN=ON .. 等待安装成功
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da8223837d83b87bad20e8e6004135ae/" rel="bookmark">
			服饰图像识别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		# TensorFlow and tf.keras import tensorflow as tf # Helper libraries import numpy as np import matplotlib.pyplot as plt print(tf.__version__) fashion_mnist = tf.keras.datasets.fashion_mnist #60,000 张图像来训练网络，使用 10,000 张图像来评估网络学习对图像进行分类的准确程度 (train_images, train_labels), (test_images, test_labels) = fashion_mnist.load_data() class_names = ['T-shirt/top', 'Trouser', 'Pullover', 'Dress', 'Coat', 'Sandal', 'Shirt', 'Sneaker', 'Bag', 'Ankle boot'] """ 0 T恤/上衣 1	裤子 2	套头衫 3	连衣裙 4	外套 5	凉鞋 6	衬衫 7	运动鞋 8	包 9	短靴 """ train_images.shape len(train_labels) train_labels test_images.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da8223837d83b87bad20e8e6004135ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/662e9984b28baa91622b1dc568b5bfaa/" rel="bookmark">
			在pycharm里安装pytorch环境-GPU版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、安装Anaconda
在官网下载安装：https://www.anaconda.com/download
2、安装pycharm
https://www.jetbrains.com/pycharm/download/#section=windows
使用社区版即可。
3、检查conda环境
按win+r，输入cmd回车打开命令窗
在命令窗内输入conda
环境无问题。
4、创建虚拟环境：
其中包括环境名称和python版本名称。
格式：
conda create -n 环境名称 python=版本 如，我的环境名称为pytorch_gpu_23.5.30 ，使用python3.8，输入：
conda create -n pytorch_gpu_23.5.30 python=3.8 输入conda activate pytorch_gpu_23.5.30激活当前环境后，输入python，检查所安装python版本是否正确，输入exit()退出
输入conda deactivate退出当前环境
5、设置解释器
打开pycharm，点击文件-设置
添加解释器
点击添加解释器，使用现有环境，把刚刚创建的添加进去
6、安装cuda
打开pytorch官网：https://pytorch.org/点击Get started
按照自己的需求选择好选项，我的电脑支持版本为CUDA11.7和CUDA11.8
打开CUDA官网下载地址：https://developer.nvidia.com/cuda-downloads
选择好自己的选项之后点击下载
下载完成后，直接双击安装，最好安装在默认路径，因为后面需要用到。
7、验证cuda是否安装成功
进入路径C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA查看自己的版本安装是否正确
进入文件夹v11.7-bin，并复制路径，在终端里输入：
cd C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v11.7\bin 然后输入：
nvcc -V 输出里显示出cuda版本
8、下载cudnn
官网地址：https://developer.nvidia.com/cudnn
下载解压完成后，分别打开三个文件夹，将文件夹里的复制到CUDA路径下同名文件夹中，注意是复制bin、include、lib文件夹里的内容，不是复制整个文件夹过去
9、验证是否安装成功
进入文件夹：C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v11.7\extras\demo_suite
复制路径，在命令行里输入：
cd C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v11.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/662e9984b28baa91622b1dc568b5bfaa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5117df266b0bb378d76533612793a41/" rel="bookmark">
			内网环路造成网络卡顿排查解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记一次内网故障，故障现象为网络卡顿，报障时发现大家都隶属同一个 VLAN，且其他 VLAN 用户正常使用，而我自己刚好属于这个VLAN下用户。
一、故障现象 所有该VLAN的人全部上不了网，或者网络断断续续，基本没法用，不管是我自己还是同网段其他人，打开电脑任务管理器，网络下载流量都在50-70Mb之间（百兆口），此时猜测出现了网络环路，抓包情况如下，基本全是ARP报文。
二、故障排查 从上述现象可以确认是环路问题，因为我们 Vlan 在核心层下发，所以从核心层开始往下排查。
1. 核心层 先在核心层开启环路监测，定位到具体端口，本次确认在7号口。然后在根据具体端口，定位下连交换机的管理IP。
system-view loopback-detection global enable vlan 1 to 4094 # 监测Vlan loopback-detection interval-time 250 # 设置循环检测的时间间隔 250ms一次 --- display arp Type: S-Static D-Dynamic O-Openflow R-Rule M-Multiport I-Invalid IP address MAC address VLAN/VSI name Interface Aging Type 169.254.181.240 642f-c72e-b5fb 1 BAGG1 393 D 169.254.214.233 5ca7-21bc-d6f4 1 BAGG1 389 D 10.10.11.32 882a-5e30-7ed9 110 BAGG1 387 D 10.10.11.33 882a-5e30-8fb9 110 BAGG1 387 D 10.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5117df266b0bb378d76533612793a41/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a7b1e9dddbb79c02f64748da473f029/" rel="bookmark">
			软件测试基础知识整理（九）-项目信息来源、项目测试流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
一、项目信息来源
1.1 熟悉项目步骤
1.2 熟悉项目的信息来源
二、项目测试流程
2.1 需求分析
2.2 测试计划
2.3 测试方案
2.4 测试用例设计
2.4.1 测试用例需求来源
2.4.2 编写测试用例步骤
2.4.3 编写测试用例的原则
2.4.4 执行测试用例原则
一、项目信息来源 1.1 熟悉项目步骤 了解项目的业务特性：项目是用来做什么的？了解项目的角色和用户：项目是给谁用的？了解项目的组织结构图：项目包括哪些功能模块？了解项目的技术栈：项目使用了哪些技术实现的？ 1.2 熟悉项目的信息来源 在软件测试项目中，项目的信息可以从多个来源获取，以帮助测试团队全面了解项目需求和测试目标。
项目中已存在的文档：需求说明书、用户使用手册、测试用例等。使用项目的现有环境：开发环境、测试环境、线上环境等。询问项目中的其他成员：测试组员/组长、开发人员、产品经理等。 二、项目测试流程 需求分析（评审）编写测试计划与测试方案测试用例设计与评审环境准备测试执行与BUG跟踪处理重复测试与回归测试编写测试报告 2.1 需求分析 需求评审的目的：
保证需求的完整和准备；保证项目中的相关人员对需求理解的一致性。 测试人员在需求评审的职责：
确认自己对需求要有清晰的理解；确认需求文档完整、准确，能够知道后期工作；对需求中不合理的地方提出修改意见。 2.2 测试计划 测试计划：是软件测试过程中的关键文档，它用于规划、安排和组织测试活动的执行。测试计划包含了测试的范围、目标、策略、资源、进度安排以及测试的风险评估等信息，旨在确保测试过程能够有效地进行并满足项目的需求和质量目标。
测试计划的核心内容：
明确的测试目标与测试范围执行计划的角色和职责任务的进度安排与资源分配风险评估和应急计划测试的准入/准出标准 2.3 测试方案 测试方案是从测试的角度去分析需求，在方向上明确要怎么测，分析结果重点在于测试策略与技术实现。
测试方案的核心内容：
测试策略：描述测试的方法、技术和策略，包括测试的级别（单元测试、集成测试、系统测试等）、测试的类型（功能测试、性能测试、安全测试等）以及测试用例设计方法。测试环境规划：说明测试所需的硬件、软件和网络环境，以及测试环境的搭建和配置。测试工具的设计和选择 2.4 测试用例设计 2.4.1 测试用例需求来源 文档：需求文档、产品原型图、UI图。从用户角度：测试软件的易用性 2.4.2 编写测试用例步骤 确定测试目标：明确测试的目标和测试的范围。了解要测试的功能或系统的预期行为和要求，以便在编写测试用例时能够覆盖相关的功能和场景。需求分析：以了解系统的功能和设计。确定测试技术和方法：根据项目的需求和测试目标，选择适合的测试技术和方法。常见的测试技术包括黑盒测试、白盒测试、灰盒测试、功能测试、性能测试、安全测试等。确定测试用例的类型和覆盖范围：根据系统的功能和需求，确定测试用例的类型，如正常流程测试、异常流程测试、边界值测试等。同时，确保测试用例能够覆盖系统的各个功能和场景。编写测试用例：根据已确定的测试目标和范围，开始编写测试用例。审查和验证测试用例 2.4.3 编写测试用例的原则 易于理解和执行：测试用例应该清晰、简洁，并且易于理解和执行。完整覆盖功能和需求：测试用例应该覆盖系统的各个功能和需求，包括正常流程、异常情况、边界情况等。独立性和可重复性：每个测试用例应该是独立的，不依赖于其他测试用例的执行结果。预期结果明确：测试用例应该明确指定预期结果，即测试执行后期望得到的结果。考虑边界条件和异常情况：测试用例应该考虑边界条件和异常情况，以验证系统在极限情况下的稳定性和正确性。可维护性和可扩展性：测试用例应该具有良好的可维护性和可扩展性，方便进行修改、更新和添加新的测试用例。有效性和高效性：测试用例应该是有效的，能够发现潜在的缺陷和问题。同时，测试用例应该是高效的，能够在有限的时间内完成执行。文档化和可追溯性：测试用例应该进行适当的文档化，并具有良好的可追溯性。可以记录测试用例的编写人员、编写日期、修改历史等信息，以便于跟踪和管理。 2.4.4 执行测试用例原则 准确性：确保按照测试用例中描述的步骤执行测试。仔细阅读每个步骤，准确执行，确保测试结果的准确性。及时记录：在执行测试用例的过程中，记录每个步骤的执行结果和观察到的现象。准确记录问题、缺陷和异常情况，以便后续分析和跟踪。不做假设：在执行测试用例时，不要做任何假设或推测。只根据实际观察到的结果来判断测试是否通过或失败。及时报告问题：如果在执行测试用例的过程中发现问题、缺陷或异常情况，及时报告给相关人员，确保问题能够被及时处理。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6723ed1a2d9ce521f50beaf56e5372c/" rel="bookmark">
			Linux下如何修改文件权限？（chmod/chown)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
chmod (全称：change mode) ： 修改文件的权限
最常见的修改权限的方式：
chown(全称change owner):改变文件所有权
chgrp:用于设置文件的属组
前言：Linux 系统是一种典型的多用户系统，不同的用户处于不同的地位，拥有不同的权限。
chmod (全称：change mode) ： 修改文件的权限 打开终端，可以通过ll或者ls -l的命令查看当前目录下的文件详细信息，如下所示：
drwxrwxrwx 3 root root 4096 2月 24 17:08 ../ -rw-rw-r-- 1 fengyun fengyun 265 2月 24 17:10 config.ini 解释： 前面10个长度的字符，代表的就是该文件的信息，以及对应的用户所拥有的操作权限。
接下来的字符中，以三个为一组，且均为 rwx 的三个参数的组合。其中， r 代表可读(read)、 w 代表可写(write)、 x 代表可执行(execute)。 要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号 - 而已
可以用数字来代表权限：r=4，表示可读；w=2，表示可写；x=1表示可执行，- 删除权限，用数字0表示 ；
最常见的修改权限的方式： 一、
chmod 777 文件名，即[4+2+1][4+2+1][4+2+1]=777
二、
user：用户（文件属主）group：组（文件属组）others：其他（其他人）all:所有人 我们就可以使用 u, g, o 来代表三种身份的权限。此外， a 则代表 all，即全部的身份。读写的权限可以写成 r, w, x。可以通过以下方式来修改文件或目录的权限
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6723ed1a2d9ce521f50beaf56e5372c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c13d71ba75c05198bc16b6d6aea5dd53/" rel="bookmark">
			window部署redis集群
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.下载Redis-x64-3.2.100.zip 下载网址：https://github.com/microsoftarchive/redis
百度网盘下载：百度网盘 请输入提取码 提取码：j2js
redis版本一定要大于3.0，原因：windows暂不支持redis-cli创建集群，只能使用redis-trib.rb，redis-trib.rb是redis官方推出的管理redis集群的工具，需要redis版本&gt;=3.0.6
2.解压Redis-x64-3.2.100.zip重命名为7000，修改redis.windows.conf配置文件 port 7000 cluster-enabled yes cluster-config-file nodes-7000.conf cluster-node-timeout 15000 3.复制7000文件夹5份，分别命名为7001到7005 修改redis.windows.conf配置文件，修改各自的port和cluster-config-file,如：
port 7001 cluster-enabled yes cluster-config-file nodes-7001.conf cluster-node-timeout 15000 4.启动redis 可以通过脚本启动
@echo off title redis-server0 set ENV_HOME="D:\program\redis-cluster\7000" D: color 0a cd %ENV_HOME% .\redis-server.exe .\redis.windows.conf exit 5.安装ruby 参考：windows 安装 Ruby 教程-百度经验
我安装ruby会报连接超时的问题，但并不影响
执行到这一步就不用管了
安装成功后，查看ruby版本，通过gem install redis来安装相关依赖 6.下载redis-trib.rb 地址：https://github.com/beebol/redis-trib.rb
7.创建集群 三主三从
.\redis-trib.rb create --replicas 1 127.0.0.1:7000 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005 出现[OK] All 16384 slots covered.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c13d71ba75c05198bc16b6d6aea5dd53/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/947736a104ba6dc0308fa4a1153ea0a0/" rel="bookmark">
			Linux安装配置Redis
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、下载Redis (1) 官网下载：Download | Redis
（2）百度网盘： 链接：https://pan.baidu.com/s/1Zu22HfBwDd4bEpEkPuvuSw 提取码：1234
2、 Redis 是基于C语言编写的，因此首先需要安装Redis所需的gcc依赖： yum install -y gcc tcl 安装gcc依赖
yum install -y gcc tcl 3、上传并解压 （1）把我们下载的Redis上传到Linux的任意目录，例如我把文件放在 /usr/local目录
（2）解压 tar -zxvf redis-6.2.7.tar.gz 4、编译安装 （1）进入Redis目录 cd redis-6.2.7/
（2）运行编译命令
make &amp;&amp; make install make 编译 make install 安装
cd redis-6.2.7/ make &amp;&amp; make install （3）默认安装目录实在 /usr/local/bin 目录下
cd /usr/local/bin/ ll 5、启动Redis的两种方式 （1）默认启动，可以在任意目录执行 redis-server 命令运行Redis
redis-server 注意: 这种方式叫做前台启动，如果当前页面关掉，那么Redis也会被停止。
（2）要让Redis后台启动，则必须修改Redis配置文件 就在我们解压的目录里面：
/usr/local/redis-6.2.7/redis.conf 注意：修改之前我们需要做好备份操作
cp /usr/local/redis-6.2.7/redis.conf /usr/local/redis-6.2.7/redis.conf.back
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/947736a104ba6dc0308fa4a1153ea0a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86d11d13eafdb6427f07b751260cf6e9/" rel="bookmark">
			Python最简单康威生命游戏Numpy
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		康威生命游戏其实很简单，如果不用花里胡哨的那么多函数调用，或者定义类的要求，最简单运用numpy的应该就是这种了。
一. 整体思路
首先，要清楚知道程序分为几个部分，我们需要熟悉规则，想要达到的效果就是细胞在不断死亡和活过来，也就是运用numpy，创建一个方阵，通过它的规则使其不断地迭代，直到最终稳定下来。
其次，我们还需要一个窗口去展示这个迭代的过程，这里运用的是pygame这个包，这个包可以设计窗口的大小，所编写程序的名字等等。
最后整合到一起去，完整的展示出整体过程。
游戏规则
当周围仅有1个或没有存活细胞时， 原来的存活细胞进入死亡状态。
当周围有2个或3个存活细胞时， 网格保持原样。
当周围有4个及以上存活细胞时，原来的存活细胞亦进入死亡状态。
当周围有3个存活细胞时，空白网格变成存活细胞。
二. 具体编写
1.设计窗口大小以及把其分为网格
首先确定窗口的大小是600×600，X,Y是网格的数量，这取决于你自己创建的矩阵的大小，这里是50×50的矩阵，矩阵里的元素就是占这里的一个网格的大小，后面就说是一个cell的大小。
其次确定大小后，细胞如何展示，这里通过定义颜色的RGB的值，来给细胞上色。如下所示，我们定义了活着的状态和死亡的状态，以便后面用到。
ALIVE = (124, 252, 0) # 括号里就是RGB的值，可以自己查找想要的颜色的值 绿色 DEAD = (0, 0, 0) # 黑色 SCREEN_WIDTH = 600 SCREEN_HEIGHT = 600 X = 50 # X方向的网格数量 Y = 50 # Y方向的网格数量 CELL_WIDTH = SCREEN_WIDTH / X CELL_HEIGHT = SCREEN_HEIGHT / Y 2. 导入模块
import pygame,sys, random import numpy as np 3. 初始化矩阵
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/86d11d13eafdb6427f07b751260cf6e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7469c34f3ace5eb8234ef965fca9fcc/" rel="bookmark">
			手把手带你学会Microchip代码配置器MCC——学习教程2 MCC操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上一篇博客介绍了如何安装MCC，这篇博客开始介绍整个MCC的界面，同时介绍如何使用MCC生成代码。如下图，是MCC用户界面，主要包括Resource Area（资源区）、Composer Area（设计区）、Pin Manager Area（引脚管理器区）。
首先，我们看下使用MCC生成外设驱动程序时的相关步骤，如下图
现在我们开始在MPLAB X IDE中使用MCC生成外设驱动程序，请按下列步骤操作：
1、新建MPLAB X IDE项目或打开现有项目。例如，在此处为PIC16LF1559器件创建名为mTouch_mcc的项目，如下图。
2、打开MCC插件工具。为此，在MPLAB X IDE的菜单栏中，转到Tools -&gt; Embedded（工具 -&gt; 嵌入式），然后单击MPLAB® Code Configurator（MPLAB®代码配置器）。请注意，对于MAC用户，“Embedded”选择位于“Preferences”（首选项）菜单下。随即会启动MCC GUI。或者也可以直接点击MCC图标进行启动，如下图。
3、单击Project Resources区中的system Module 、Pin Module、Interrupt Module，可以对相应模块的配置位进行修改，界面如下图。
4、从Device Resources 区中选择要使能以生成代码的外设，使能的方式很简单，只需要双击需要的外设即可。例如，此处已使能EUSART，使能外设后，注意外设现已显示在Project Resources 区中Peripherals。此外，还会根据使能的外设调用引脚管理器区中的引脚。如下图。
5、配置GPIO模块也非常容易，只需将所需的GPIO脚位在GUI界面上进行勾选即可。并且Microchip的GPIO目前基本都是支持PERIPHERAL PIN SELECT(PPS) MODULE，即数字信号的外设脚位可以配置在任意引脚上，前提是数字信号，同时此引脚没有被使用。同时在初始化状态，可以配置默认高低电平、输入输出、WPU上拉、IOC支持电平变化中断等等，只需在GUI界面上勾选即可。如下图。
6、在设计区中配置外设。例如，我们做一个支持接收发送，波特率为115200的UART。首先双击Peripherals中EUSART，就会跳转到EUSART模块配置界面，选择使能EUSART，使能接收，使能发送，选择相应波特率和接收发送的位数。如下图。
7、根据应用需求在引脚管理器区中配置引脚。表格视图可垂直或水平显示。封装视图会以图形方式显示相应的引脚配置。将EUSART中RX和TX脚位进行选择，如下图。
8、配置完所有使能的模块后，单击设计区顶部的Generate Code按钮来生成驱动程序和初始化程序。如下图。
9、生成的驱动程序将包含在活动的MPLAB X IDE项目中，生成的驱动程序包括模块配置、引脚配置、中断配置和系统配置。如下图。
mcc.h和mcc.c文件包含配置位的定义和oscillator_initializer 函数。这些定义基于在设计区中为系统模块所做的设置。另外还包含system_initializer函数，可在应用程序中调用该函数以调用所有其他默认初始化程序。
根据在引脚管理器GUI中进行的配置，pin_manager.h和pin_manager.c文件会包含引脚管理器初始化函数。
interrupt_manager.h和interrupt_manager.c文件为可选文件，仅在允许外设中断且其中包含中断初始化函数时才会生成这些文件。
.h和.c文件为模块特定文件，其中包含各个模块的外设配置函数。
仅在MCC检测到项目中不存在任何main.c文件时，才会生成main.c文件。如果项目中存在任何先前的main.c文件，则无论其创建者是用户还是MCC，都不会生成该文件或覆盖现有文件。使用并非由MCC生成的main.c文件时，需要将“#include“mcc_generated_files/mcc.h”和SYSTEM_Initializer()这两行添加到main.c文件中。
10、MCC还有Diff功能。Diff检查工具用于防止MCC代码生成器覆盖用户对MCC生成的文件所做的任何修改。当MCC在代码生成期间检测到用户对文件进行了修改时，将显示Diff检查工具。修改的代码显示在左侧，新生成的代码显示在右侧。用户可使用顶部的导航按钮在检测到的各个修改之间快速移动。沿中心边缘显示的箭头用于选择将哪些更改复制到新生成的代码中。单击箭头即可将用户修改复制到新生成的代码中。如果不单击箭头，MCC会使用生成的代码替换用户所做的修改。如下图。
此篇博客完成MCC操作介绍，后续博客将重点如何使用MCC对MCU相应外设进行操作设计，及相应MCC中外设的名词解释。
以上内容来源大大通官网，速戳了解更多精彩内容吧~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3d36c8c8cbd83317bfe4ee59d656750/" rel="bookmark">
			2022全国大学生数学建模大赛C题——古代玻璃制品的成分分析与鉴别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于随机森林分类的古代玻璃制品的成分分析与鉴别
摘要
本文主要针对古代玻璃制品成分分析与鉴别的问题，对因为受掩埋环境的影响，从而改变其原本的化学成分古代玻璃制品，建立随机森林分类模型对其风化前化学成分进行预测和分类。同时采用bp神经网络分类模型、相关性分析等分别对建立模型进行分析和求解，以此来对其类别进行正确的判断。
首先，我们对给出的数据进行预处理，剔除化学成分总含量不在85%-105%范围内的数据，对数据中的空缺值作置零处理。
对于问题一，首先我们采用卡方检验来对玻璃文物表面分化与其玻璃类型、纹饰和颜色的关系进行分析。部分结果如下表：
特征
名称
表面风化
总计
风化
无风化
颜色
nan
4
0
4
浅绿
1
2
3
浅蓝
16
8
24
其次，我们将高钾类型和铅钡类型分为风化和无风化，并可视化其各化学成分含量，对比分析其统计规律。利用独立样本t检验分析有无风化成分含量是否存在差异性，最后利用独立样本t检验结果计算有无风化的均值比例，利用该比例求得其不同类型玻璃文物风化前的化学成分含量。
对于问题二，我们建立随机森林分类模型，分析各个化学成分所占的特征比重，对两个类型的玻璃文物进行划分。在此基础上对不同类别分别进行聚类分析，划分出其亚分类，并对结果进行合理性和敏感性的分析。
对于问题三，我们在问题二的基础上，利用随机森林分类模型对未知类别玻璃文物的化学成分进行分析，并鉴别其所属类型。为保证预测结果的准确性，同时建立bp神经网络分类模型、决策树分类模型对其化学成分分析，鉴别类型。对比分析三个模型的预测结果，得到较为准确的求解方法，并对其结果进行灵敏性检验。部分结果如下表：
预测结果_Y
预测结果概率_铅钡
预测结果概率_高钾
氧化锶(SrO)
氧化钙(CaO)
二氧化硫(SO2)
氧化锡(SnO2)
氧化铅(PbO)
氧化铁(Fe2O3)
五氧化二磷(P2O5)
氧化铜(CuO)
氧化钡(BaO)
氧化镁(MgO)
氧化铝(Al2O3)
二氧化硅(SiO2)
高钾
0.13
0.87
0.03
6.08
0.51
0
0
2.15
1.06
2.11
0
1.86
7.23
78.45
铅钡
0.88
0.12
0
7.63
0
0
34.3
0
14.27
0
0
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3d36c8c8cbd83317bfe4ee59d656750/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9daa98228d3b6f568eef4bfa28162505/" rel="bookmark">
			代码随想录算法训练营第十天| 232.用栈实现队列 、 225. 用队列实现栈
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		232. 用栈实现队列
题目： 请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：
实现 MyQueue 类：
void push(int x) 将元素 x 推到队列的末尾
int pop() 从队列的开头移除并返回元素
int peek() 返回队列开头的元素
boolean empty() 如果队列为空，返回 true ；否则，返回 false
说明：
你 只能 使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。
你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。
示例 1：
输入：
["MyQueue", "push", "push", "peek", "pop", "empty"]
[[], [1], [2], [], [], []]
输出：
[null, null, null, 1, 1, false]
解释：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9daa98228d3b6f568eef4bfa28162505/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b176d54171648e8db9ff26b9777484c9/" rel="bookmark">
			微信小程序基于和风天气的天气预报（自动和手动定位）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
效果图
和风天气API获取
微信小程序后台配置域名
选择城市弹窗
页面代码
注意事项（谨记）
前言 最近在开发小程序，将自己写的分享给大家,希望能帮助到你们！
效果图 和风天气API获取 网址链接：dev.qweather.com
我用的是和风天气的API，打开该网址注册或登陆你的账号
点击进入开发服务平台，进入我们的控制台管理界面
点击项目管理，并且创建属于我们自己的KEY（我们选择免费订阅，并选择 Web API）
创建成功之后我们就可以看到 等会要用到的Key了（这个是关键）
微信小程序后台配置域名 登录小程序后台，点击开发设置
点击服务器域名 点击修改 将我们要用到的API的域名添加到request合法域名中 ，https://devapi.qweather.com和 https://geoapi.qweather.com
选择城市弹窗 网址链接：Vant Weapp (gitee.io)
我用的是Vant Weapp打开该网址后点击Popup弹出层
我们可以看到在引入中写着在app.json或index.json中引入组件
我们将代码复制到你的json文件中
将基本用法复制到你的WXML的文件中，并将红圈部分复制到你的JS文件中，然后根据你需要从哪边弹出进行top（顶部）、bottom（底部）、left（左侧）、right（右侧）的选择
页面代码 页面核心
.WXML
&lt;image class="bg-wave" src="/pages/images/bg_wave.gif"&gt;&lt;/image&gt; &lt;view class="top"&gt; &lt;view class="city" bindtap="showPopup"&gt; &lt;image class="icon" src="/pages/images/定位.png" bindtap="showPopup"&gt;&lt;/image&gt; &lt;text class="city" bindtap="showPopup"&gt;{{shi}}-{{xian}}&lt;/text&gt; &lt;/view&gt; &lt;view class="hourly_title"&gt;24小时预报&lt;/view&gt; &lt;scroll-view scroll-x="true" class="hourly"&gt; &lt;view class="hourly_item" wx:for="{{hourly}}" wx:key="index"&gt; &lt;text class="hourly_time"&gt;{{item.time}}&lt;/text&gt; &lt;text class="h_time"&gt;{{item.text}}&lt;/text&gt; &lt;view class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b176d54171648e8db9ff26b9777484c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d8d1ceb782316357a3c7fef8f8cb430/" rel="bookmark">
			12.ThreadLocal的那点小秘密
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		好久不见，不知道大家新年过得怎么样？有没有痛痛快快得放松？是不是还能收到很多压岁钱？好了，话不多说，我们开始今天的主题：ThreadLocal。
我收集了4个面试中出现频率较高的关于ThreadLocal的问题：
什么是ThreadLocal？什么场景下使用ThreadLocal？ThreadLocal的底层是如何实现的？ThreadLocal在什么情况下会出现内存泄漏？使用ThreadLocal要注意哪些内容？ 我们先从一个“谣言”开始，通过分析ThreadLocal的源码，尝试纠正“谣言”带来的误解，并解答上面的问题。
流传已久的“谣言” 很多文章都在说“ThreadLocal通过拷贝共享变量的方式解决并发安全问题”，例如：
这种说法并不准确，很容易让人误解为ThreadLocal会拷贝共享变量。来看个例子：
Java
复制代码
private static final DateFormat DATE_FORMAT = new SimpleDateFormat("yyyy-MM-dd"); public static void main(String[] args) throws InterruptedException { for (int i = 0; i &lt; 1000; i++) { new Thread(() -&gt; { try { System.out.println(DATE_FORMAT.parse("2023-01-29")); } catch (ParseException e) { e.printStackTrace(); } }).start(); } } 我们知道，多线程并发访问同一个DateFormat实例对象会产生严重的并发安全问题，那么加入ThreadLocal是不是能解决并发安全问题呢？修改下代码：
Java
复制代码
/** * 第一种写法 */ private static final ThreadLocal&lt;DateFormat&gt; DATE_FORMAT_THREAD_LOCAL = new ThreadLocal&lt;&gt;() { @Override protected DateFormat initialValue() { return DATE_FORMAT; } }; public static void main(String[] args) throws InterruptedException { for (int i = 0; i &lt; 1000; i++) { new Thread(() -&gt; { try { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d8d1ceb782316357a3c7fef8f8cb430/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b0b5e47d82717e6aa86c33de563ed09/" rel="bookmark">
			成功解决Android sdkmanager not found. Update to the latest Android SDK and ensure that the cmdline-tools
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		运行项目，执行flutter doctor 时出现下面的报错：
MacBook-Pro android % flutter doctor Doctor summary (to see all details, run flutter doctor -v): [✓] Flutter (Channel stable, 3.10.2, on macOS 13.0.1 22A400 darwin-arm64, locale zh-Hans-CN) [!] Android toolchain - develop for Android devices (Android SDK version 33.0.1) ✗ cmdline-tools component is missing Run `path/to/sdkmanager --install "cmdline-tools;latest"` See https://developer.android.com/studio/command-line for more details. ✗ Android license status unknown. Run `flutter doctor --android-licenses` to accept the SDK licenses.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b0b5e47d82717e6aa86c33de563ed09/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d6a6916e8b69090ae61a911b1fe7e7f/" rel="bookmark">
			用python爬取影评及影片信息(评论时间、用户ID、评论内容)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		爬虫入门：python爬取某瓣影评及影片信息：影片评分、评论时间、用户ID、评论内容 思路分析元素定位完整代码 某瓣网作为比较官方的电影评价网站，有很多对新上映影片的评价，不多说，直接进入正题。
因为版权问题不让放图片
思路分析 爬取的目标网站为某瓣网。可以看到最新上映的电影的相关信息，但是含有电影评论的网址是一个二级链接，需要点击电影进入详细信息才可以查看，所以第一步需要获得影片的链接。观察后可以看到链接如下：
使用BeautifulSoup和正则表达式re库可以解析这个网站所在的class以及确定具体链接所在的位置，具体方式如下：
bs = BeautifulSoup(html.text,'html.parser') movie_list = bs.find_all(class_='item') #定位链接元素 links = re.compile('class="nbg" href="(.*?)" title=') links = re.findall(links,str(movie_list)) 可以在控制台看到是否查询成功，得到的结果如下：
['https://movie.douban.com/subject/35118954/', 'https://movie.douban.com/subject/35414623/', 'https://movie.douban.com/subject/35230876/', 'https://movie.douban.com/subject/34477861/', 'https://movie.douban.com/subject/35507172/', 'https://movie.douban.com/subject/35700395/', 'https://movie.douban.com/subject/30362175/', 'https://movie.douban.com/subject/35240235/', 'https://movie.douban.com/subject/35073886/', 'https://movie.douban.com/subject/35056243/']在这里插入代码片 拿到这些链接之后，在分别请求这些链接，分析页面，就可以拿到最后所需要的数据。
for item in links: #TODO 解析页面 定位元素 ... pass 元素定位 分析页面 得到各个所需的信息所在位置 综合使用re和BeautifulSoup定位即可 以用户ID为例：（因为这里有短评和长评两种，所以分开查询）
#用户名称 user = comment.find_all(class_ = 'comment-info') user = re.findall('href.*?/"&gt;(.*?)&lt;/a&gt;',str(user)) subscriber = re.findall('class="name".*?href.*?/"&gt;(.*?)&lt;/a&gt;',str(long_comment)) #print(subscriber) 打印用户名称信息 #['CydenyLau', '斯宾诺莎画板', 'Zion', '莫选好片', '小小X', '今夜', 'Maggie_in_LA', 'Gary', '辉兔的爱与生活', '职业影迷'] 这里有一个小tips：查找元素的时候要由大到小查询，先查询大的包含的元素，在慢慢锁定自己需要的内容、有用的信息。理论上来说是可以直接用re精确定位到自己所需要的元素 但是这样定位的精度低、错误率高，不建议使用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d6a6916e8b69090ae61a911b1fe7e7f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a513662865d9d98ba704d34c0d522c4f/" rel="bookmark">
			vue-router
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		路由的核心：改变url，但是页面不进行整体刷新
路由理解为指向
路由是一个映射表，一个路由就是一组映射关系 key-value，
其中key：标示路由
value：表示function或者component（组建）
$router:全局路由 push forword go
$route:当前活跃的路由对象 path params query name
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45cfc0fb9a204f4efd663c8459f81238/" rel="bookmark">
			java多线程常见工具类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java多线程工具类简单使用
CyclicBarrier使用
Exchanger使用
Semaphore信号量
Condition交替打印123，共10次
线程main、线程0、线程1按照顺序依次执行
线程池内部线程执行任务报错处理execute提交的任务(无返回值)
submit提交的任务报错
CountDownLatch使用
import java.util.concurrent.CountDownLatch; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; public class CountDownLatchDemo { // 创建2个 static CountDownLatch countDownLatch = new CountDownLatch(2); // 线程池2个线程 static ExecutorService pool = Executors.newFixedThreadPool(2); public static void main(String[] args) { pool.submit(()-&gt;{ System.out.println("a thread ... "); try { Thread.sleep(2000); System.out.println("a thread ... end"); }catch (InterruptedException e){ } // 执行结束调用countDown countDownLatch.countDown(); }); pool.submit(()-&gt;{ System.out.println("b thread ... "); try { Thread.sleep(2000); System.out.println("b thread .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/45cfc0fb9a204f4efd663c8459f81238/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a54b28d8db1c3a5b10c4b9176af569d0/" rel="bookmark">
			centos7中python2升级到python3
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先最好先换yum源，方便后续操作
换源方法
https://juejin.cn/post/6883839564985663496
1，在usr文件夹里建立文件
(1)进入目录
cd /usr/local (2)创建文件夹
mkdir python3 2，安装依赖包
yum install -y libffi-devel yum install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gcc libffi-devel 3，在home目录下建立文件
(1)进入目录
cd /home/python3 (2)创建文件夹
mkdir python3 (3)进入目录
cd python3 4，下载并安装python
(1)下载
wget https://www.python.org/ftp/python/3.7.3/Python-3.7.3.tgz (2)解压
tar -zvxf Python-3.7.3.tgz (3)进入解压后的目录
cd Python-3.7.3 (4)编译
./configure --prefix=/usr/local/python3 (5)安装
make &amp;&amp; make install 5，安装支持python的gcc，要不然python3无法运行
(1)下载gcc
yum install make gcc gcc-c++ zlib* openssl* libffi-devel -y (2)执行
./configure (3)安装
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a54b28d8db1c3a5b10c4b9176af569d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56069b4c38107a73dd01128b57470aff/" rel="bookmark">
			【大数据分析】Yarn的工作流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、用户编写客户端程序，向 ResourceManager 提交程序，程序包括：ApplicationMaster、ApplicationMaster 的启动命令、用户程序等。
2、ResourceManager 负责接收和处理来自客户端的用户请求，收到请求后，ResourceManager 里面的 Resource Scheduler 会为应用程序分配一个 container，同时，ResourceManager 的 Applications Manager 会与 container 所在的 NodeManager 通信，为该应用程序在 container 中启动一个 ApplicationMaster
3、ApplicationMaster 被创建后会首先向 ResourceManager 注册，从而使得用户可以通过 ResourceManager 来直接查看应用程序的运行状态
4、ApplicationMaster 采用轮询的方式通过 RPC 通信向 ResourceManager 的 Resource Scheduler 申请资源。
5、ResourceManager 为提出申请的 ApplicationMaster 分配资源（以 “container” 的方式），ApplicationMaster 申请到资源后，就会与container 所在的 NodeManager 通信，要求启动任务。
6、当 ApplicationMatser 要求 container 启动任务前，NodeManager 会先设置好运行环境（包括环境变量、Jar包、二进制程度等），然后将任务启动命令写到一个脚本中，最后通过在容器中运行该脚本来启动任务。
7、各个任务通过 RPC 通信向 ApplicationMaster 汇报自己的状态和进度，让 ApplicationMaster 可以随时掌握各个任务的运行状态，从而可以在任务失败时重新启动任务。
8、应用程序运行完成后，ApplicationMaster 向 ResourceManager 的应用程序管理器注销并关闭自己，若 ApplicationMaster 失败，ResourceManager 中的 Application Manager 会检测到失败的情形，然后将其重新启动，直到所有的任务执行完毕。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae2c2d5c963d0070fd0974733feef85e/" rel="bookmark">
			【大数据分析】Hbase的基本原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 Hbase 架构ClientZooKeeperMasterRegionServerHRegionStoreMemStoreStoreFileHFileHLog Hbase数据模型关于数据模型的其他概念Name SpaceTableRowColumnTime StampCell Hbase 架构 Client （1）.META.表，记录了用户所有表拆分出来的 Region 的映射信息，.META.可以有多个Region。
（2）-ROOT- 表，记录了 .META. 表的 Region 信息，-ROOT- 自身只有一个 Region，无论如何不会分裂。
Client 访问用户数据前需要首先访问ZK，找到 -ROOT- 表的 Region 所在的位置，然后访问 -ROOT- 表，接着访问 .META. 表，最后找到具体的数据的位置。
ZooKeeper （1）为 HBase 提供 Failover 机制，选举 Master ，避免 Master 单点故障。
（2）存储所有 Region 的寻址入口：-ROOT- 表在哪台服务器上。-ROOT- 这张表的位置信息。
（3）实时监控 RegionServer 的状态，将 RegionServer 的上线和下线信息实时通知给 Master 。
（4）存储 HBase 的 schema，包括有哪些 table，每个table有哪些Column Family。
Master （1）为 RegionServer 分配 Region。
（2）负责 RegionServer 的负载均衡。
（3）发现失效的 RegionServer 并重新分配其中的 Region。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae2c2d5c963d0070fd0974733feef85e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22735ef5832946411eea2711f6c650bf/" rel="bookmark">
			Nacos服务注册时添加元数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.找到nacos对应的包,找到NacosDiscoveryClientConfiguration 2.将源码复制到java程序中并对元数据就行修改 3.修改成功 程序中有这个配置的话,会优先取程序里面的,也就是你自定义的
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b289126d47ddd65d21859b2eb20b5ada/" rel="bookmark">
			代码随想录算法训练营第八天| 344.反转字符串 、 541. 反转字符串II、剑指Offer 05.替换空格、151.翻转字符串里的单词 、剑指Offer58-II.左旋转字符串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		344. 反转字符串
题目： 编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。
不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。
示例 1：
输入：s = ["h","e","l","l","o"]
输出：["o","l","l","e","h"]
示例 2：
输入：s = ["H","a","n","n","a","h"]
输出：["h","a","n","n","a","H"]
思路： 对于字符串，我们定义两个指针（也可以说是索引下标），一个从字符串前面，一个从字符串后面，两个指针同时向中间移动，并交换元素。
代码： class Solution { public: void reverseString(vector&lt;char&gt;&amp; s) { char tmp; int left = 0, right = s.size() - 1; while(left &lt; right){ tmp = s[left]; s[left] = s[right]; s[right] = tmp; left++; right--; } } }; 541. 反转字符串 II
题目： 给定一个字符串 s 和一个整数 k，从字符串开头算起，每计数至 2k 个字符，就反转这 2k 字符中的前 k 个字符。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b289126d47ddd65d21859b2eb20b5ada/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33b6d2f77e3131828d4bd52f11360b5f/" rel="bookmark">
			python 科学计数法的小数转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python 科学计数法的小数转换 一. 问题 float转换str时,使用str()方法可以便捷的实现转换.但小数位太长的数会默认转换为科学计数法的格式,如:
&gt;print(str(0.000001)) 1e-06 实际应用中,这种形式的数据往往不是我们想要的.
本文要解决的问题是将一个str格式的带有科学计数法数值的二维数组转换为小数形式
输入数据(str) -999. 0. 0. 0. 0. 0. 0. 0. 0. 0. 5.00e-02 5.20e+01 2.55e+02 2.55e+02 2.55e+02 6.00e-02 6.90e+01 1.95e+02 2.53e+02 2.55e+02 8.00e-02 1.29e+02 2.21e+02 9.00e+01 2.55e+02 1.00e-01 2.55e+02 1.87e+02 1.50e+01 2.55e+02 1.50e-01 2.55e+02 6.90e+01 1.00e+00 2.55e+02 2.00e-01 2.55e+02 1.50e+02 1.50e+01 2.55e+02 0.4 255. 87. 15. 255. 期望输出(str) -999. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.05 52. 255. 255.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/33b6d2f77e3131828d4bd52f11360b5f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2133afc821655d724b1a6c7616e1873/" rel="bookmark">
			【六一为孩子建模吧】沐风老师3DMAX建模雕刻插件SculptTool使用教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		3DMAX建模雕刻插件，该工具旨在使对角色和地形等有机模型进行小型编辑成为可能，而无需离开3dMax并启动如ZBrush等专用雕刻应用程序，就可以在3DMAX中直接对小型模型进行简单的雕刻建模处理，这样会方便很多。
【适用版本】
3dMax2023及以上版本
【主要特性】
-可以在“可编辑多边形”和“编辑多边形”中进行雕刻编辑。
-您可以使用笔形平板电脑或鼠标进行雕刻。选择权在你。
-可以笔刷对象面选择。
-通过在刷动对象曲面的同时按Ctrl键，可以恢复雕刻修改。撤消可能会冻结您的应用程序。使用撤消操作时要小心！
-使用“重算”按钮时可用的布尔运算（并集、相减、交集）。
-使用“平滑组”（Smoothing Groups）和/或“材质ID”（Materials ID）来定义一个良好的拓扑，同时重新生成。
-切片工具现在集成在雕刻工具主UI中。
-材质ID稍后可以在ZBrush中用作多边形组（作为FBX导入）。
-任何时候，您都可以根据自己的需要选择完美的笔刷设置组合。
【安装方法】
将mzp文件拖到3DMAX视口，在弹出的面板中选择“Install”，然后等待，直到安装完成。
【安装成功的提示】
【插件打开方法】
点击3dmax主菜单-&gt;自定义-&gt;自定义用户界面-&gt;工具栏，点击“类别”列表，从中选择“MLtools”，然后在下面的列表中选择“soulptTool”命令，将其拖动到3dmax工具栏，创建工具按钮，以后使用该插件时直接点击该按钮打开即可。
【使用方法】
3DMAX建模雕刻插件操作方法相当简单，但是，要想得到理想的绘制效果，需要个人具用较好的艺术功力，雕刻工具就如同用笔作画一样，画的好坏全任个人水平。
1.将要雕刻的对象转化为可编辑多边形，并设置较高的分段（拓扑），注意模型尽量使用四边形多边形，以便得到更理想的雕刻效果。3DMAX建模雕刻插件右上角为你提供了一个快捷的工具“网格化”，选择要雕刻的对象，点击“网格化”按钮，自动对雕刻对象进行重新拓扑。
2.从笔刷列表中选择你当前要使用笔刷。
3.设置笔刷大小和强度：
4.在雕刻对象表面按下鼠标左键拖动进行绘制。
*按Ctrl+z键可以回退操作步骤。
是不是一个不错的小工具呢？！
感谢阅读，下次再见！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8577a64f4567ffd103863b292b402de/" rel="bookmark">
			Antd vue 中如何禁止a-tree-select选中父级
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 只需要给数据加一个属性selectable=false
&lt;template&gt; &lt;a-tree-select v-model:value="value" :fieldNames="{ children: 'metrics', label: 'name', value: 'id', }" style="width: 100%" :height="233" :tree-data="metricList" allow-clear /&gt; &lt;/template&gt; &lt;script setup&gt; import { onMounted, ref, toRefs, reactive, watch } from 'vue'; const metricList = ref([ { id:'aaa', name:'父级1', selectable:false, metrics:[ { id:1, name:'子级1', } ] } ]) &lt;/script&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2fe95bca540364d70dab03109d05dad0/" rel="bookmark">
			uniapp使用renderjs
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		renderjs 可以让uniapp调用dom的方法
&lt;template&gt; &lt;view class="content"&gt; &lt;!-- #ifdef APP-PLUS || H5 --&gt; &lt;view @click="echarts.onClick" :prop="option" :change:prop="echarts.updateEcharts" id="echarts" class="echarts"&gt;&lt;/view&gt; &lt;button @click="changeOption"&gt;更新数据&lt;/button&gt; &lt;!-- #endif --&gt; &lt;!-- #ifndef APP-PLUS || H5 --&gt; &lt;view&gt;非 APP、H5 环境不支持&lt;/view&gt; &lt;!-- #endif --&gt; &lt;/view&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { option: { title: { text: 'ECharts 入门示例' }, tooltip: {}, legend: { data: ['销量'] }, xAxis: { data: ["衬衫", "羊毛衫", "雪纺衫", "裤子", "高跟鞋", "袜子"] }, yAxis: {}, series: [{ name: '销量', type: 'bar', data: [5, 20, 36, 10, 10, 20] }] } } }, onLoad() { }, methods: { changeOption() { const data = this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2fe95bca540364d70dab03109d05dad0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b65bc8e3756d4c0ffb1c2a2918498ee7/" rel="bookmark">
			C&#43;&#43;内存泄漏排查经验分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++内存泄漏是程序中常见的问题之一，如果不加以处理，它可能会导致程序运行缓慢或崩溃。在这篇文章中，我们将介绍一些排查 C++内存泄漏的技术。
1.分析代码
首先，要找出内存泄漏的原因，必须分析代码。可以查看代码中创建的对象，尤其是动态分配的对象，查找是否有不当的释放或内存泄漏的迹象。检查代码中是否有一些潜在的问题，例如循环引用或不正确的对齐等。
2.使用调试器
使用调试器可以帮助找出内存泄漏的原因。可以使用 GDB 或 LLDB 等调试器来单步执行代码并查看内存使用情况。在调试过程中，可以查看堆栈和内存分配情况，以确定是否有内存泄漏。
3.检查内存分配
在 C++中，内存分配是非常关键的。在使用内存时，必须确保正确地分配和释放内存。要检查内存分配，可以使用调试器或内存分析工具来检查代码中的内存分配。确保所有内存分配都是正确的，并且正确地释放内存。
4.使用内存池
内存池是 C++中常用的内存管理技术之一。使用内存池可以确保正确地分配和释放内存，从而减少内存泄漏的风险。在使用内存池时，必须确保正确地配置和管理内存池，以确保其有效性和可靠性。
5.检查循环引用
循环引用是 C++内存泄漏的主要原因之一。如果一个对象引用另一个对象，而后者又引用前者，则形成了循环引用。循环引用可能导致内存无法释放，从而导致内存泄漏。要检查代码中的循环引用，可以使用调试器或内存分析工具来检查代码中的循环引用。
6.优化代码
最后，要确保代码是高效的，并且能够充分利用系统资源。在编写代码时，应该尽量避免不必要的内存分配和释放，尽可能缩短代码的执行时间。可以使用性能分析工具来检查代码的性能，并优化代码以提高性能。
总之，要找出 C++内存泄漏的原因，必须仔细分析代码并使用各种工具和技术来检查内存分配和释放情况。在开发过程中，应该始终注意内存管理，以确保代码的可靠性和高效性。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d74a3b3f630bc4e05b061023e0abda6f/" rel="bookmark">
			智能指针你用对了码？有啥优缺点？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		智能指针是 C++ 中的一种特殊类型指针，它提供了更加灵活和安全的内存管理功能。以下是智能指针的优缺点:
优点:
1.灵活性：智能指针可以根据需要自动管理内存，避免了手动管理内存时的繁琐和错误。这使得编写代码更加简单、灵活和易于维护。
2.安全性：智能指针会自动检测指针的使用情况，如果指针被非法访问，则会触发异常。这使得代码更加安全，避免了内存泄漏和悬挂指针等问题。
3.效率：智能指针可以自动管理内存，因此可以提高代码的效率，减少内存分配和释放的次数。
缺点:
1.使用难度：智能指针的使用需要一定的技巧和经验，使用不当可能会导致代码出现问题。因此，需要花时间学习和掌握智能指针的使用方法。
2.占用空间：智能指针需要维护一个指向原始对象的指针，因此会占用更多的空间。这对于小内存环境和精简代码时需要注意。
3.不适用于所有场景：智能指针主要适用于手动管理内存的场景，对于自动管理内存的场景可能不适用。例如，对于数组或对象池等场景，应该使用手动管理内存的方式。
总的来说，智能指针是 C++ 中一个非常重要的特性，可以提高代码的安全性和效率，但需要谨慎使用，避免出现不必要的问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e47f4751651822e3ce7fd91b9d45f1e/" rel="bookmark">
			linux 安装python3(亲测可用)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先安装python3所需的基础库
yum -y install openssl-devel bzip2-devel expat-devel gdbm-devel yum -y install readline-devel zlib-devel gcc wget 接着，下载python3版本并解压，此处以3.8.5为例
wget https://www.python.org/ftp/python/3.8.5/Python-3.8.5.tgz tar -zxvf Python-3.8.5.tgz 然后，编译、安装
cd Python-3.8.5 ./configure --prefix=/usr/local/python3 make -j4 #多核编译，减少等待时间 make install 最后创建软连接
#创建软链接 ln -s /usr/local/python3/bin/python3 /usr/bin/python3 ln -s /usr/local/python3/bin/pip3 /usr/bin/pip3 可在命令行运行python3命令，检验安装结果。
[root@sdx7 ~]# python3 Python 3.8.5 (default, Mar 20 2023, 13:49:12) [GCC 4.8.5 20150623 (Red Hat 4.8.5-36)] on linux Type "help", "copyright", "credits" or "license" for more information. &gt;&gt;&gt; 大功告成！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3b57a6c0dde56f6dfe74c66641a98ff/" rel="bookmark">
			完美解决ModuleNotFoundError: No module named ‘scipy‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、ModuleNotFoundError: No module named 'scipy'二、完美解决问题 一、ModuleNotFoundError: No module named ‘scipy’ 二、完美解决问题 pip install scipy -i https://pypi.tuna.tsinghua.edu.cn/simple -i https://pypi.tuna.tsinghua.edu.cn/simple是清华镜像
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/526d763cad34c1e0f62127145898d250/" rel="bookmark">
			C&#43;&#43; STL简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
一、STL的概念
二、STL的六大组件
三、STL的缺陷
一、STL的概念 STL 是指标准模板库（Standard Template Library）的缩写。它是 C++ 的一个标准库，提供了许多通用的模板类和函数，用于实现常用的数据结构和算法。STL 是 C++ 中广泛使用的一个库，被认为是 C++ 的核心之一。
二、STL的六大组件 容器（Containers）：包括向量（vector）、列表（list）、双端队列（deque）、栈（stack）、队列（queue）、优先队列（priority_queue）、集合（set）、映射（map）等，用于存储和管理数据。
迭代器（Iterators）：提供了一种访问容器中元素的通用方式，包括输入迭代器、输出迭代器、前向迭代器、双向迭代器和随机访问迭代器。
算法（Algorithms）：包括排序、查找、遍历、修改、复制、合并、反转、旋转等常用算法。
仿函数（函数对象）（Functors）：是可调用对象，可以像函数一样使用，用于定制算法的行为。
空间配置器（Allocator）：用于管理动态内存的分配和释放。
适配器（Adapters）：用于将容器或函数对象转换成其他类型，以适应不同的需求。包括容器适配器（如栈和队列的适配器）、迭代器适配器（如反向迭代器和插入迭代器）和函数适配器（如绑定器和取反器）。
三、STL的缺陷 STL库的更新太慢了。上一版靠谱是C++98，中间的C++03基本一些修订。C++11出来已经相隔了13年，STL才进一步更新。STL现在都没有支持线程安全。并发环境下需要我们自己加锁。且锁的粒度是比较大的。STL极度的追求效率，导致内部比较复杂。比如类型萃取，迭代器萃取。STL的使用会有代码膨胀的问题，比如使用vector/vector/vector这样会生成多份代码，当然这是模板语法本身导致的。 四、选择STL容器的基本原则 1）除非有很好的理由选择其他容器，否则使用vector是最好的选择。
2）如果程序有很多小元素且空间的额外开销很重要，不要使用list或forward_list。
3）要求随机访问元素，应该使用vector或deque。
4）要求中间插入或删除元素，应该使用list或forward_list。
5）要求在头尾插入或删除元素，且中间不进行插入或删除，应该使用deque。
6）如果只在读取输入时才需要在容器中间位置插入元素，随后需要随机访问元素。首先可以考虑在读取输入时使用vector，再调用sort函数重排容器中的元素，从而避免在中间位置添加元素。如果必须在中间位置插入元素，考虑在输入阶段使用list，输入完成将list拷贝到vector中。
注意：如果实在不确定使用哪种容器，可以在程序中只使用vector和list的公共操作迭代器而非下标，避免随机访问。这样可以在必要时选择使用vector或list。 五、STL容器的概要 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67baafe3ac10537d77205a8be951d9d3/" rel="bookmark">
			SpringFramework 中CollectionUtils 工具类的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CollectionUtils是Spring框架中的一个工具类，提供了一系列对集合的操作方法。
import org.springframework.util.CollectionUtils; import java.util.*; public class CollectionUtilDemo { public static void main(String[] args) { //判断一个集合或Map是否为空，返回布尔值 List&lt;String&gt; list = new ArrayList&lt;&gt;(); System.out.println(CollectionUtils.isEmpty(list)); // 输出true Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); System.out.println(CollectionUtils.isEmpty(map)); // 输出true list.add("apple"); System.out.println(CollectionUtils.isEmpty(list)); // 输出false //判断一个迭代器中是否包含某个元素。如果包含，则返回true，否则返回false。 List&lt;String&gt; list1 = new ArrayList&lt;&gt;(Arrays.asList("apple", "banana", "orange")); Iterator&lt;String&gt; it = list1.iterator(); System.out.println(CollectionUtils.contains(it, "banana")); // 输出true //断一个集合中是否包含某个元素的实例。如果包含，则返回true，否则返回false。 List&lt;String&gt; list2 = new ArrayList&lt;&gt;(Arrays.asList("apple", "banana", "orange")); String str = "apple"; System.out.println(CollectionUtils.containsInstance(list2, str)); // 输出true //判断一个集合source中是否包含candidates集合中的任意一个元素。如果找到任意一个匹配项，返回true，否则返回false。 List&lt;String&gt; list3 = new ArrayList&lt;&gt;(Arrays.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/67baafe3ac10537d77205a8be951d9d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ab13914d51d0bb8e07d75a8b01a6897/" rel="bookmark">
			Windows 10 LTSC微软商店 一键安装包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装好之后是19版商店 进行更新就可以正常使用了点击下载
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c14917784f04ac73ef8f69d7253fa242/" rel="bookmark">
			用ptp4l和phc2sys实现系统时钟同步
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		linuxptp用于时钟同步。
安装方法：
ubuntu平台上用apt,也可以用官方的github源码自行编译：
https://github.com/richardcochran/linuxptp
apt install linuxptp linuxptp主要包含2个程序：ptp4l和phc2sys
1.ptp4l 进行时钟同步，实时网卡时钟与远端的时钟同步(比如TSN交换机），支持1588 和 802.1AS 两种协议
2.phc2sys 将网卡上的时钟同步到操作系统，或者反之
时钟同步命令:
某主机P通过eth2连接TSN交换机，下列命令实现主机P的网卡与交换机进行时钟同步，并且将主机的操作系统的时钟也与TSN交换机同步。
ptp4l实现 网卡上的时钟与TSN交换机同步。
phc2sys实现网卡上的时钟 同步到操作系统（以网卡上的时钟为master）
（“同步到”这个词总是很难精确的表达清楚到底是以这为master还是slave）
ptp4l -i eth2 -2 –m -s -f gPTP.cfg phc2sys -a -r --transportSpecific=1 -m --step_threshold=1000 # phc2sys还可以写成这样，功能是一样的 phc2sys -s eth2 -c CLOCK_REALTIME --transportSpecific=1 -m --step_threshold=1000 -w 命令介绍：
ptp4l -2 指定用2层的以太网帧进行数据传输，而非UDP
-s 作为slave向外界同步（以外面的时间为准）
-f gPTP.cfg 配置更多内容，具体内容见下面。 此例中使用的是802.1AS协议
phc2sys
此处2种用法是一样的，-a -r会自动寻找当前运行的ptp4l程序，利用它的时钟，同步给操作系统时钟，操作系统时钟是slave。
如果用“-a -rr” 两个r，那么时钟同步的方向是相反的，操作系统的时钟是master主时钟，网卡的时钟是slave. 第二种用法中的-s eth2 -c CLOCK_REALTIME -w 不过是写的更清楚一点。 -s 指定master clock
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c14917784f04ac73ef8f69d7253fa242/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0506321623e94b384d837681f76b8baf/" rel="bookmark">
			redis的安装步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 Redis 概述和安装 1 Redis是一个开源的key-value存储系统。 2 和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set --有序集合)和hash（哈希类型）。 3 这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。 4 在此基础上，Redis支持各种不同方式的排序。 5 与memcached一样，为了保证效率，数据都是缓存在内存中。 6 区别的是Redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件。 7 并且在此基础上实现了master-slave(主从)同步。 1.1 Redis适用场景 1.1.1 配合关系型数据库做高速缓存 1 高频次，热门访问的数据，降低数据库IO
2 分布式架构，做session共享
1.1.2 多样的数据结构存储持久化数据 1.2 Redis安装 Redis官方网站Redis中文官方网站RedisCRUG网站 1.2.1 版本选择 6.2.1 for Linux（redis-6.2.1.tar.gz）或者安装新版本
不用考虑在windows环境下对Redis的支持
1.2.2 安装步骤 1.2.2.1 准备工作: 下载安装最新版本的gcc编译器
安装C语言环境
yum -y install gcc 测试安装是否成功
gcc --version 1.2.2.2 下载redis-6.2.1.tar.gz放/opt目录
1.2.2.3 解压命令：tar -zxvf redis-6.2.1.tar.gz
1.2.2.4 解压完成后进入目录：cd redis-6.2.1
1.2.2.5. 在redis-6.2.1目录下再次执行make命令（只是编译好）
1.2.2.6. 如果没有准备好C语言编译环境，make 会报错
Jemalloc/jemalloc.h：没有那个文件
此时解决方案:运行make distclean
make disclean 然后安装好 gcc后,再次make
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0506321623e94b384d837681f76b8baf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91e3888fc7f5d4fcffc3e59cceb8797a/" rel="bookmark">
			linq.js文档
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linqjs User Documentation
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aec9dd6d14e857cf9158d8bee57daa25/" rel="bookmark">
			Git cherry-pick命令详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 个人中心
DownLoad
Git中的cherry-pick命令用于选择一个提交并将其应用到当前分支上，而不必合并整个分支。这在需要在不影响其他代码的情况下将单个提交应用到其他分支时非常有用。以下是cherry-pick命令的详细介绍。
语法 复制代码
git cherry-pick &lt;commit-hash&gt; 参数 &lt;commit-hash&gt;：要应用的提交的完整哈希值。
如何使用 假设我们有一个名为master的分支和一个名为feature的分支。我们想要将feature分支中的最新提交应用到master分支，我们可以执行以下命令：
复制代码
git checkout master git cherry-pick &lt;commit-hash&gt; 这将应用特征分支中的最新提交到主分支上。请注意，在这种情况下，您必须在将提交应用到master分支之前先切换到该分支。
如果您要应用多个提交，请以相反的顺序运行cherry-pick命令：从最新的提交开始，从最老的提交结束。
常见用例 将某个分支上的提交应用到另一个分支或主分支上，而不必将整个分支合并。当您想要使用一个已提交的更改，但不想合并整个分支时，您可以使用cherry-pick。 cherry-pick时出现冲突解决方案：
1、继续执行cherry-pick用户手动先手动解决有冲突的文件，然后将文件重新加入暂存区(git add)，第二步使用如下命令让cherry-pick继续执行
git cherry-pick --continue
2、取消cherry-pick
如果认为冲突太多了，不想继续cherry-pick,那么可以使用如下命令取消cherry-pick,这个时候会恢复到cherry-pick前的样子
git cherry-pick --abort
3、发生代码冲突后，退出 cherry pick，但是不回到操作前的样子
git cherry-pick --quit
这种情况属于摆烂行为，一般不会这么用
注意事项 运行cherry-pick时，Git会在当前分支中创建一个新提交，以包含要应用的提交的更改。如果您需要进行更改并重新提交，您需要再次提交一个新的提交。如果要应用的提交在目标分支上已存在，则cherry-pick可能会失败。在这种情况下，您需要解决冲突并手动解决问题。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/373f44d530d9be0bd453a6e5ceb3f7e0/" rel="bookmark">
			Git——三大分区【工作区 / 暂存区 / 版本区】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：Git作为一个版本管理工具，最核心组成思想是它的三个分区：工作区、暂存区和工作区。
1. 工作区 Git的工作区也就是我们平时编辑代码的目录文件夹。
2. 暂存区 暂存区就是一个暂时放置修改文件记录的地方。以往仓库中放货物为例，向仓库中放货物总是一车车的拉，因为如果货物一件件的拉，当想回到之前某个状态时，需要把货物一件件往外撤，当数量很大时会加大管理难度。如果把货物一车车拉货拉进仓库，那么若想回到之前某个状态，只需要拿走几车货就好，减少了操作管理难度。
所以暂存区的作用是将要多个文件的多处修改暂时存储，最后将这些修改作为一个版本提交。
3. 版本区 版本区可以看作是一个仓库，每次将暂存区中打包好后修改的东西送到仓库中，是各种修改的版本信息最后存储的地方。
4. 三个区的切换命令 4.1 工作区 =&gt; 暂存区 —— git add git add可将多个文件添加到暂存区。
$ git add readme.md Test1.py 4.2 暂存区 =&gt; 版本区 —— git commit git commit将暂存区当中的所有文件一次性提交到版本区，-m参数后跟着每次提交说明，对哪些地方进行修改的简述。
$ git commit -m "commit the last Version" 4.3 版本区 =&gt; 暂存区 —— git reset --mixed git reset命令--mixed跟着版本号，是指把该版本号提交的内容从版本区位置回滚到暂存区。
$ git reset --mixed d5d43ff 4.4 暂存区 =&gt; 工作区 —— git reset --soft git reset命令--soft跟着版本号，是指把该版本号提交的内容从暂存区位置回滚到工作区。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/373f44d530d9be0bd453a6e5ceb3f7e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/118e930fb8d1d4985b0cf37eabf5bf6f/" rel="bookmark">
			C语言#if，#ifdef，#ifndef条件编译用法汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		条件编译是根据实际定义宏（某类条件）进行代码静态编译的手段。可根据表达式的值或某个特定宏是否被定义来确定编译条件。
最常见的条件编译是防止重复包含头文件的宏，几乎所有头文件都要采用下述的方法编辑以防止被重复包含，形式跟下面代码类似：
#ifndef ABCD_H #define ABCD_H // ... some declaration codes #endif // #ifndef ABCD_H 在C文件中通常有如下类似的定义：
#ifdef _DEBUG // ... do some operations #endif #ifdef _WIN32 // ... use Win32 API #endif 常见的条件编译指令 1、#if：如果条件为真，则执行相应的操作。
2、#elif：类似于 elseif 的用法，当前面条件为假，再判断该条件是否为真，如果是真，则执行相应操作。
3、#else：如果前面所有条件均为假，则执行相应操作。
4、#ifdef：如果该宏已定义，则执行相应操作。
5、#ifndef：如果该宏没有定义，则执行相应操作。
6、#endif ：结束对应的条件编译指令。(不能省略)
defined ：与#if, #elif配合使用，判断某个宏是否被定义
#if，#elif，#else与#endif #if 指令很像C语言中的 if 语句。#if 后面跟常量表达式，如果表达式为非0，则表达式为真，执行 #if 与 #endif 中间的所有C代码；如果表达式为0，则表达式为假，中间的代码不参与编译。
#if可与常量表达式配合使用。常用格式如下：
#if 常量表达式1 // ... some codes #elif 常量表达式2 // ... other codes #elif 常量表达式3 // .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/118e930fb8d1d4985b0cf37eabf5bf6f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9a650383fa8295f3ea314f580ef57d9/" rel="bookmark">
			C/C&#43;&#43; 位操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言实现将某位置为1或者0std::bitset 前言 假如我们想用一个char类型的个bit中每一个bit去代表某个用于，比如1代表占有0代表空，那么我们是不是要先打印这个char的每个bit
在开始之前我们要明白
&amp;: 0 &amp; 0 = 0 , 1 &amp; 1 = 1, 0 &amp; 1 = 0
|: 0 | 0 = 0 , 1 | 1 = 1 , 0 | 1 = 1
实现 首先我们知道char如果是数字转int就会直接转换，比如下面代码
#include &lt;stdio.h&gt; using namespace std; int main() { char a = 10; printf("char 10 convert to int is %d\n",a); return 0; } 发现转换后还是10，意味着我们可以直接转换成int
假如我们的char存储的是数字，我们将其转换成二进制代码如下
#include &lt;stdio.h&gt; //using namespace std; int main() { char a = 10; for(int i = 0; i &lt; 8; i++){ printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e9a650383fa8295f3ea314f580ef57d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3ba2994fa73e6289d359e5701a8a154/" rel="bookmark">
			Windows环境下部署GeoScene Enterprise 3.1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		特别声明：有幸加入GPN计划，感谢易智瑞强大的技术支持团队做后盾！ 计算机IP 10.0.4.21（样例）
强烈建议固定IP地址，不要修改；有兴趣的小伙伴探索下更改IP，配置文件修改方法。 多网卡计算机可能会导致couchdb与Protal绑定的IP不一致，安装时先禁用其他网卡。 域名 semap.cn（样例）
互联网https比较费劲，内网或局域网环境通过OpenSSL创建自签名证书即可。 不建议使用 arcgis.com， esri.com、 geoscene.cn 计算机名 Windows设置--系统--关于--重命名这台计算机
右键桌面图标【此电脑】--属性--重命名这台计算机
控制面板--系统和安全--系统--更改设置
右键桌面图标【此电脑】--属性--更改设置
更改--其他--修改【计算机名称】--其他--修改【此计算机的主DNS后缀】
计算机名称不能含有特殊字符，推荐纯英文字母 此计算机的主DNS后缀 即为“域名”，不能带www或*. Windows操作系统 .NET Framework运行库
Microsoft .NET Framework 4.8必须
*脱机安装程序适用于内网环境
Windows操作系统
Windows 10 专业版和企业版（64 位）
Windows Server 2016-2019 标准版和数据中心版（64 位）
*Windows Server 操作系统进行按用户安装，注册表项HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\Installer 必须包含 REG_DWORD 数据类型 DisableMSI，其值为 0（0安装所有程序，1禁用非托管安装，2禁用所有程序安装）
CPU
推荐：4 核；最佳：10 核
内存
推荐：16 GB；最佳：32 GB 及以上
存储
安装路径：推荐大于 32 GB 的固态硬盘
存储目录：∞
显存
推荐：4 GB（电脑无显卡不能浏览Web图形）
屏幕分辨率
1024x768 或更高分辨率
Java环境配置 安装JDK 8 双击安装JDK 8（jdk-8u-windows-x64.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e3ba2994fa73e6289d359e5701a8a154/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16af1576ab7e59fc89b5842f4702e28d/" rel="bookmark">
			vue-admin-template框架搭建及应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、框架介绍
vue-admin-template是基于vue-element-admin的一套后台管理系统基础模板（最少精简版），可作为模板进行二次开发；
可以把 vue-element-admin当做工具箱或者集成方案仓库，在 vue-admin-template 的基础上进行二次开发，想要什么功能或者组件就去 vue-element-admin 那里复制过来地址：vue-element-admin
二、框架目录结构介绍
三、文件夹分析
1、views：视图文件夹 ，新建一个vue页面，会有三个组成部分：template=&gt;相当与html页面，里面写div,ui组件等；script=&gt;jquery; style=&gt;页面的css样式
2、api: 向后端发送http请求，使用的是 /utils/request 里面的内容
可以指定请求的路径、类型、请求参数、请求体参数
3、utils/request.js: 主要作用
1、引入要调用的模块以及创建一个axios实例，其中有url已经请求超时的设置
2、创建一个请求拦截器：
作用：在请求发送前进行一些操作，例如在每个请求体里加上token，统一做了处理如果以后要改也非常容易
store.getters.token 首先从全局状态管理那里判断 token , 有的话就可以请求， 否则就抛出异常
3、创建一个响应拦截器：
作用：在接收到响应后再进行一些操作，例如在服务器返回登录状态失效的时候，需要重登录，跳转到登录页面
4、/store：
State提供唯一的公共数据源，所有共享的数据都要统一放到Store中的State中存储；
​ Mutation用于修改变更$store中的数据；
在mutations中不能编写异步的代码，会导致vue调试器的显示出错。在vuex中我们可以使用Action来执行异步操作；
Getter用于对Store中的数据进行加工处理形成新的数据；
它只会包装Store中保存的数据，并不会修改Store中保存的数据，当Store中的数据发生变化时，Getter生成的内容也会随之变化；
token的获取：
文件地址：store/modules/user.js
login 方法， 首先 传入 {commit} 以及在方法中 commit(‘SET_TOKEN’, data.token) 这两个的作用是执行 action 中异步方法的简写， 组用就是设置 token 的值， 我们知道修改 store中的数据需要使用 Mutation 就是会调用上面的 SET_TOKEN 把 后端返回的token 保存到vuex中， 并且使用 setToken(data.token) 方法把 token写入到 cookie中 以便我们每次请求都可以带上这个 cookie , 并且能够解析出当前登录的用户
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/16af1576ab7e59fc89b5842f4702e28d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c40b6d8dc4df0f08a9210305238a8fc/" rel="bookmark">
			【前端】vue项目打包Browserslist: caniuse-lite is outdated. Please run: npx update-browserslist-db@latest解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决方案 一、背景描述二、解决方案2.1 解决方案一：重新安装 caniuse-lite、browserslist2.2 解决方案二：npm update caniuse-lite browserslist 三、拓展 一、背景描述 最近项目打包的时候，本地打包没有问题，且能正常运行，但是一旦通过 CI/CD进行自动构建和发布的时候，就会报错Browserslist: caniuse-lite is outdated. Please run: npx update-browserslist-db@latest，并终止编译和打包
下图是本地电脑打包的时候报的错误信息，但是最终不影响项目构建和打包，可以打包成功。
但是，但是，如果一旦通过 CI/CD进行自动构建和发布的时候，就会报错并结束打包，最后会导致打包失败。
二、解决方案 2.1 解决方案一：重新安装 caniuse-lite、browserslist 在本地电脑上找到项目的node_modules文件夹下面：caniuse-lite、browserslist两个文件夹。并把caniuse-lite、browserslist这两个文件夹删除。
然后运行下面的命令重新安装caniuse-lite、browserslist。
在本地电脑重新打包项目，测试一下，测试好之后，把 package.json 文件提交到svn服务器，这样 jenkins 再次打包的时候就会重新获取依赖的包。
npm i caniuse-lite browserslist -S 可以参考以下示例图片：
执行完重新安装的命令，如果出现下图所示内容即表示重新安装两个文件成功。
重新安装后，项目中的 package.json 文件中会出现两个依赖包，如下图所示：
2.2 解决方案二：npm update caniuse-lite browserslist 这里提示我们需要npm update，需要注意的是，我们不能直接npm update，因为这会让我们所有的依赖包全部update,我们需要带上包名，所以应该这样写命令：
npm update caniuse-lite browserslist 三、拓展 caniuse-lite、browserslist 的介绍，如果想多学习相关的知识，请参考以下介绍。
browserslist：https://www.npmjs.com/package/browserslist
caniuse-lite：https://www.npmjs.com/package/caniuse-lite
本文完结！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2d793a8b9718134e7796226a05c6885/" rel="bookmark">
			DBeaver导出sql脚本，执行sql脚本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.DBeaver导出表为sql脚本 1. 首先选中要导出的表右键-》工具-》转储出数据库
2.在打开的面板中根据提示进行操作
红框部分选择导出文件的保存地址、名称，等待执行完成后即可在保存地址看到生成的sql脚本。
二、DBeaver导出表为sql脚本 1.选择要导入到的数据库右键-》工具-》执行脚本
2.根据提示框操作
选择自己要导入的sql脚本，点击开始即可。 最后 这是写给初次使用DBeaver的用户看的，个人总结，希望对各位有所帮助。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d510e5e24d6e0142a8eaefe76df8903/" rel="bookmark">
			Linux：shell脚本的介绍，创建与执行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		linux的shell脚本就是windows的bat脚本，也就是通常所说的批处理。更简洁地说，就是很多命令的结合体，就像编程一样。
windows脚本的扩展名是.bat，而linux脚本的扩展名则是.sh
centos在编写shell脚本的文件最上边，需要加上#！/bin/sh（bash）这里表示的是使用sh（bash）解释器。自己写的语言需要与解释器相匹配。
sh和bash可以认为是一个东西，因为bash内部是连接着sh的，因此两个都可以写。
还有其他不同的解释器，如zsh、ash、chs、tcsh，这些一般用在其他版本，如ubantu等等。但是一般系统都会默认用该系统适合的解释器，有的时候shell脚本头部不加显示器也不会出错。但是最好都加上，就像c语言都得加mian函数一样。
写一段shell脚本文件：
首先需要创建应该shell脚本文件：
touch hello.sh
这样就创建好了
然后vim hello.sh打开这个文件。
输入：
接下来就是执行了，执行命令的方式有三种：
①：
这里是利用bash解释器，去解释这个shell脚本，这样bash就会帮我们执行这个shell脚本文件。
②：
这里就是赋予可执行文件的权限，然后通过./去执行这个文件。
注意：可执行文件要执行，都得加个路径。否则会当做命令执行。
③：
可以通过source 文件名（可以直接写文件名source hello.sh这样也可以就如同直接bash一样）执行shell文件。
也可以通过. 文件名（中间是有空格的）执行shell文件。
这两个命令是一个意思，只是他们来源于不同解释器。被bash借鉴使用了。
那么是什么意思呢？
前两个执行方式其实是创建了一个子shell进程，这个子shell进程继承了父shell进程，然后由这个子shell进程一个一个执行shell文件内的命令，再带回父shell进程。但是子shell进程如果修改执行了修改环境变量等关键信息，这些父shell进程是不会响应的。
接下来就是source和.命令，这个两个命令是在父shell进程中直接执行shell文件。因此source和.通常会用来更新某些配置文件从而不用重启电脑，如：profile（环境变量文件）（解释一下，这些配置文件其实也是可执行文件，内部都是命令，如profile内部都是修改配置文件的命令export，这些命令只有被父shell进程执行后才会生效，在子shell进程执行是没有用的。）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3774d275aaf663d901e1dfbec03ee74/" rel="bookmark">
			计算机策略禁止更改系统时间及时区设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一步
按WIN＋r打开运行窗口，输入【gpedit.msc】然后回车
第二步
在组策略编辑器，依次找到【计算机配置】-【windows设置】-【安全设置】-【本地策略】-【用户权限分配】-【更改系统时间】/【更改时区】
第三步
双击【更改系统时间】/【更改时区】添加删除用户的更改系统时间权限
把不希望更改【更改系统时间】/【更改时区】的用户删除即可，单击确定退出，重新启动系统后策略即生效。
提示：如果你想修改系统时间，把自己的账户加进去就可以更改了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/178ee9d0423249794735bfaff5c1dee4/" rel="bookmark">
			使用代理下载ROS2humble源码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自从有了小鱼一键安装ROS工具，我就成了工具人。为了打破现状，突然想到要下个源码看看。
创建工作区并下载所有repo:
mkdir -p ~/ros2_humble/src
cd ~/ros2_humble
wget https://raw.githubusercontent.com/ros2/ros2/humble/ros2.repos
vcs import src &lt; ros2.repos
奈何网络原因导致下载不成功。
于是借鉴首飞的文章[ROS2]下载Navigation2源码来学习_ros源码下载_首飞爱玩机器人的博客-CSDN博客
使用代理下载
一、首先在GitHub下载ros2humble repo文件
GitHub - ros2/ros2 at humble
二、将repo文件中https://替换为： https://ghproxy.com/https://
三、执行$ vcs import src &lt; ros2.repos
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80e24340c5f031f25b411b759b5c4c22/" rel="bookmark">
			Python小程序 GUI猜数字大小
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这段代码是一个简单的猜数字游戏的实现。它使用了Python的Tkinter库来创建一个图形用户界面（GUI）窗口。玩家需要在输入框中猜一个1到100之间的整数，然后点击确定按钮进行猜测。程序会根据玩家的猜测给出相应的提示，直到玩家猜对或者猜测次数达到5次为止。游戏界面包括标题标签、时间标签、游戏次数标签、说明标签、输入框、确定按钮、底部提示标签以及重新开始和查看答案按钮。其中，时间标签会实时更新当前时间，游戏次数标签会显示玩家已经猜测的次数。玩家可以通过重新开始按钮重新开始游戏，通过查看答案按钮查看正确答案。整个游戏界面的布局和交互逻辑都由Tkinter库提供的功能来实现。
import tkinter as tk # 导入 tkinter 模块并将其别名为 'tk' from tkinter import messagebox # 从 tkinter 导入 'messagebox' 模块 import random # 导入 'random' 模块 import time # 导入 'time' 模块 # 生成随机数 def generate_random_number(): return random.randint(1, 100) number = generate_random_number() # 生成一个随机数并赋值给 'number' 变量 guess_count = 0 # 将 'guess_count' 变量初始化为 0 def check_guess(): # 定义一个函数用于检查用户的猜测 global guess_count # 访问全局变量 'guess_count' guess = int(entry.get()) # 从输入框中获取用户的猜测并将其转换为整数 guess_count += 1 # 将 'guess_count' 变量加 1 update_guess_count() # 调用函数更新猜测次数的标签 if guess == number: # 如果猜测正确 messagebox.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/80e24340c5f031f25b411b759b5c4c22/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6189f1a9f56b7008e80dd337567c3cc/" rel="bookmark">
			windows server 2016标准评估版升级完整版，并激活
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录 1、查看 Edition ID2、根据版本输入以下命令3、输入Y重启4、激活5、激活成功 1、查看 Edition ID DISM /online /Get-CurrentEdition 2、根据版本输入以下命令 标准版：ServerStandard
DISM /online /Set-Edition:ServerStandard /ProductKey:WC2BQ-8NRM3-FDDYY-2BFGV-KHKQY /AcceptEula 数据中心版：ServerDatacenter
DISM /online /Set-Edition:ServerDatacenter /ProductKey:CB7KF-BWN84-R7R2Y-793K2-8XDDG /AcceptEula 3、输入Y重启 4、激活 1.打开cmd控制台，按顺序输入以下命令，有报错不要管它。
slmgr /upk
slmgr.vbs /ipk CB7KF-BWN84-R7R2Y-793K2-8XDDG
slmgr.vbs /skms kms.lotro.cc
slmgr.vbs /ato
2.进入电脑属性激活服务器，根据版本输入下列密钥，需要联网。
Windows Server 2016 数据中心
CB7KF-BWN84-R7R2Y-793K2-8XDDG
Windows Server 2016 标准版
WC2BQ-8NRM3-FDDYY-2BFGV-KHKQY
Windows Server 2016 嵌入式版
JCKRF-N37P4-C2D82-9YXRT-4M63B
5、激活成功 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/133/">«</a>
	<span class="pagination__item pagination__item--current">134/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/135/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>