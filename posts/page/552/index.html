<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c72927aa0d43ac71fa5f8d82fc6b596/" rel="bookmark">
			Cannot access empty property in...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		比如属性是$a 那么访问属性一定要去掉$
即$this-&gt;a
否则会报告Cannot access empty property in。。。
转载于:https://my.oschina.net/u/2508417/blog/527165
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/130c904d7f6b03b0a0f825d7d85b3755/" rel="bookmark">
			FTP附件传输工具类-FtpUtil
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2019独角兽企业重金招聘Python工程师标准&gt;&gt;&gt; package com.test; import java.io.File; import java.io.FileInputStream; import java.io.IOException; import org.apache.commons.io.IOUtils; import org.apache.commons.lang.StringUtils; import org.apache.commons.net.ftp.FTPClient; /** * ftp附件传输工具类 * @since jdk1.6 * */ public class FtpUtil { public String ftpRootPath = ""; public String ftpIp = ""; public int ftpPort = 21; public String ftpUser = ""; public String ftpPassword = ""; /** * ftp附件传输方法，使用前需将FtpUtil的变量（ftpRootPath、ftpIp、ftpPort、ftpUser、ftpPassword）赋值 * 1.ftpRootPath： ftp根目录; * 2.ftpIp: ftp IP地址; * 3.ftpPort: ftp端口号; * 4.ftpUser: 用户名; * 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/130c904d7f6b03b0a0f825d7d85b3755/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04b3176d07f65d0fc14465d34bf977c5/" rel="bookmark">
			【Unity】 DoTween对UI进行DoFade操作存在问题及解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Unity DoTween对UI进行DoFade操作存在问题 Unity版本：5.2, 5.4
当使用this.GetComponent&lt;Image&gt;().material.DOFade(0, 2).SetEase(Ease.InBounce);来对UGUI的Image进行褪色操作的时候本质是对UI的Graphic对象（Text，Image等都为Graphic的子类）的material进行操作,下例是对Text组件进行褪色操作：Transform.GetComponent().material.DoFade(0,1)。虽然脚本只挂在一个Text组件的物体上，但1秒之后发现，整个UI界面全部变为透明。 （我也很纳闷，cube01.GetComponent&lt;Renderer&gt; ().material.color = Color.black;这样的代码照理说是这样执行的（http://www.jianshu.com/p/ababf547d992）：
Material lastMat = cube01.GetComponent&lt;Renderer&gt; ().material; Material m = Instantiate(lastMat) as Material; cube01.GetComponent&lt;Renderer&gt; ().material = m; m.color = Color.black; 应该是最自己持有的material进行操做。。。 ）
经测试发现，所有使用缺省material的组件都是使用的默认的material，而这个material只存在一份，所有UI组件使用的默认material都只是该material的引用，在DoTween对其进行褪色操作之后，该material的alpha值保持为0不变，且游戏重新开始也不会将其alpha值重置为1。
解决办法:
导入DoTween后请确保Setup DoTween， Tools/DoTween Utility Panel/Setup DoTween…。导入后就可以使用Image.DoFade了。使用Unity自带的Graphic.CrossFadeAlpha(float alpha, float duration, bool ignoreTimeScale)函数来操作自己扩展DoTween的方法，下面是我扩展的一个例子,可以参考DoTwen官网的Creating custom plugins example //// //// DoFadeTest.cs //// Project: GUITest //// //// Created by zhiheng.shao //// Copyright 2016年 zhiheng.shao. All rights reserved. //// //// Description using UnityEngine; using System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04b3176d07f65d0fc14465d34bf977c5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af2567890d06ec7793c49b789cd4919d/" rel="bookmark">
			POJ3159Candies（差分约束系统）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Description During the kindergarten days, flymouse was the monitor of his class. Occasionally the head-teacher brought the kids of flymouse’s class a large bag of candies and had flymouse distribute them. All the kids loved candies very much and often compared the numbers of candies they got with others. A kid A could had the idea that though it might be the case that another kid B was better than him in some aspect and therefore had a reason for deserving more candies than he did, he should never get a certain number of candies fewer than B did no matter how many candies he actually got, otherwise he would feel dissatisfied and go to the head-teacher to complain about flymouse’s biased distribution.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/af2567890d06ec7793c49b789cd4919d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c33778d0c60807c949352897600f943c/" rel="bookmark">
			WinAPI: FindWindow、FindWindowEx - 查找窗口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 FindWindow( lpClassName, {窗口的类名} lpWindowName: PChar {窗口的标题} ): HWND; {返回窗口的句柄; 失败返回 0} //FindWindowEx 比 FindWindow 多出两个句柄参数: FindWindowEx( Parent: HWND; {要查找子窗口的父窗口句柄} Child: HWND; {子窗口句柄} ClassName: PChar; {} WindowName: PChar {} ): HWND; { 如果 Parent 是 0, 则函数以桌面窗口为父窗口, 查找桌面窗口的所有子窗口; 如果 是 HWND_MESSAGE, 函数仅查找所有消息窗口; 子窗口必须是 Parent 窗口的直接子窗口; 如果 Child 是 0, 查找从 Parent 的第一个子窗口开始; 如果 Parent 和 Child 同时是 0, 则函数查找所有的顶层窗口及消息窗口. } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7673f2cbf0a986f1fbf47a54aca3b696/" rel="bookmark">
			android中drawable与bitmap的相互转化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		int arrowRes = R.drawable.bubble_arrow_light; Bitmap source = BitmapFactory.decodeResource(context.getResources(), arrowRes); drawable to bitmap
public static Bitmap drawableToBitmap (Drawable drawable) { Bitmap bitmap = null; if (drawable instanceof BitmapDrawable) { BitmapDrawable bitmapDrawable = (BitmapDrawable) drawable; if(bitmapDrawable.getBitmap() != null) { return bitmapDrawable.getBitmap(); } } if(drawable.getIntrinsicWidth() &lt;= 0 || drawable.getIntrinsicHeight() &lt;= 0) { bitmap = Bitmap.createBitmap(1, 1, Bitmap.Config.ARGB_8888); // Single color bitmap will be created of 1x1 pixel } else { bitmap = Bitmap.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7673f2cbf0a986f1fbf47a54aca3b696/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53e09bd318c47ea138a75e39aac67275/" rel="bookmark">
			Nagios（页面）报错: Return code of 13 is out of bounds
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		nagios出现这个错误，需检查脚本中是否有写入内容到文件，同时文件的权限是否正常。一般都是文件权限不正确写入失败导致。如果手工执行脚本成功，nagios调用就出错，可以查看运行nagios进程的用户是否同一个。
这边遇到脚本以nagios用户运行，操作root权属的文件失败，报了如上错误。 原文链接：http://blog.sina.com.cn/s/blog_6d40aa8e01013mvx.html
转载于:https://blog.51cto.com/hunkz/1708829
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e15adb99a11a953edc02e227292f1a99/" rel="bookmark">
			优化哈希策略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载地址：http://www.importnew.com/16932.html
概述 散列策略会对HashMap或HashSet之类的散列集合的性能产生直接的影响。
内置的散列（又称哈希）函数都是通用的，在大多数使用情况下都能表现很好。但是我们能不能做的更好呢，特别是当你对某个用例产生了很好的想法时？
测试一个散列策略 在先前的一篇文章中，我研究了一些测试散列策略的方法，其中特别注意了一种“正交位”优化的散列策略，它仅仅只是改变一个位就能确保每个散列结果尽可能的不同。.
然而，如果要对一个已知的元素或关键字集合进行散列，你就可以针对具体案例进行优化，而不是寻求一个通用方案。
减少冲突 一个散列集合中最主要的事情就是避免冲突了。所谓冲突，就是两个以上关键字映射到同一个散列槽中。这些冲突意味着当有多个关键字映射到同一个散列槽中时你必须要付出更多的努力来检查那些关键字是否是你想要的那个。理想状态下一个散列槽中最多有一个关键字。
我只需要唯一的散列码，是吗？ 通常的误解是只要散列码唯一就可以避免冲突。虽然都希望散列码是唯一的，但它还不够。
假设现在有一些关键字，每一个都有唯一的32位散列码。如果你有40亿散列槽，每个关键字都有自己的槽，那就没有冲突了。对于所有的散列集合，这样大的数组一般是不太现实的。事实上，HashMap和HashSet的大小都收到机器内存的限制，一般为2^30，大概刚刚超过10亿。
当你只能有一个规模上比较实际的哈希集合时又该如何呢？散列槽的数目需要更小一些，而散列码需对散列槽数目取模。如果散列槽数是2的幂值，你可以用最低位当掩码。
来看个例子，ftse350.csv。如果把第一列作为关键字或是元素，就有352个字符串。这些字符串有唯一的String().hashCode()码，但是假设我们只取这些散列码的低位。会不会有冲突呢？
Mask String.hashCode() masked HashMap.hash(
String.hashCode()) masked 32 bits No collisions No collisions 16 bits 1 collision 3 collisions 15 bits 2 collisions 4 collisions 14 bits 6 collisions 6 collisions 13 bits 11 collisions 9 collisions 12 bits 17 collisions 15 collisions 11 bits 29 collisions 25 collisions 10 bits 57 collisions 50 collisions 9 bits 103 collisions 92 collisions 一个装载因子是0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e15adb99a11a953edc02e227292f1a99/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/137355115bcfaf078156292203b04514/" rel="bookmark">
			浅析嵌入式OSEK配置器的设计与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在学习编程的过程中，我觉得不止要获得课本的知识，更多的是解决问题的方法，面对新问题该怎么解决，这样我们才能走在最前方，我是达内的学员，感谢你对本博客的支持； 随着汽车工业的快速发展，汽车对控制、通信、网络管理等方面的要求越来越高，基于32位微控制器的硬件平台、基于嵌入式实时操作系统的软件平台和基于CAN总线的网络通信平台逐渐成为当今汽车电子业的主流。 1 OSEK/VDX规范简介 在嵌入式实时操作系统方面，为了满足日益庞大、复杂的汽车电子控制软件的开发需要，实现应用软件的可移植性和不同厂商控制模块间的可兼容性，1993年德国汽车工业界联合推出了汽车电子的开放式系统及接口——OSEK/VDX规范(以下简称“OSEK规范”)，旨在为汽车上的分布控制单元提供一个开放结构的工业标准。OSEK规范从实时操作系统(RTOS)、软件接口、通信和网络管理等方面对汽车电子控制软件开发平台作了较为全面的定义与规定。尽管该规范还处在不断完善中，但它所提出的一整套解决方案将是未来汽车电子软件开发的发展方向。 为了达到OSEK软件可移植的目标，OSEK规范中定义了配置使用OSEK应用程序的方法——通用实现语言OIL。OSEK配置器就是使用图形化的用户接口，根据用户需求配置OIL文件，并最终生成OSEK实时操作系统初始化代码的工具。它是开发符合OSEK规范的实时操作系统的重要组成部分。 2 OSEK配置器的主要功能 OSEK应用程序的开发流程如图1所示。用户通过OSEK配置器根据软硬件的需求，对操作系统的属性和所有系统对象进行静态配置。配置完成后，OSEK配置器生成符合OSEK规范的OIL配置文件，并进一步生成与操作系统相关的C代码和头文件，以提供OSEK实时操作系统初始化时必备的系统参数。为保证软件的兼容性，OSEK配置器还能够从外部直接读取符合OSEK规范的OIL文件，完成生成OS静态系统文件的过程。 用户完成应用程序代码编写和OIL文件配置后，OSEK配置器所产生的代码、操作系统的部分内核和应用程序一起交叉编译，而其他操作系统内核代码作为一个库，被链接器整合在一起。本文主要研究通过OSEK配置器生成符合OSEK规范的OIL配置文件及静态系统文件的过程(如图1中虚线部分所示)。 3 OSEK配置器的实现 3.1 图形用户接口GUI的实现 OSEK应用程序的OIL语言描述包含一组OIL对象描述，分别是CPU、OS(操作系统)、APPMODE(应用程序模式)、ISR(中断服务)、RESOURCE(资源)、TASK(任务)、COUNTER(计数器)、EVENT(事件)、ALarm(警报)、COM(通信子系统)、MESSAGE(消息)、IPDU(外部通信)和NM(网络管理)。其中，CPU是其余OIL对象的容器。OIL为它的对象定义了标准类型，每一个对象都可以用一些属性和参数来描述。 对于不同的OSEK实现，生成OIL配置文件的方法是不同的。由于用户自己编写OIL文件具有一定的复杂性，因此，在集成开发环境中带有一个上下文相关帮助的、可视的图形用户接口GUI是非常必要的。在集成开发环境中，一个包含GUI的OSEK配置器需要包含以下组件： ◇一张遵循Windows Explorer格式的OSEK对象清单，用户可以根据需要添加和删除DIL对象; ◇一个图表，用于显示每个对象的属性(包括标准属性和与实现有关的属性)，用户可更改对象的属性并且实时更新OIL文件; ◇一个用于记录和显示的窗口。 知识就是力量，别人学用知识来赚钱的成本低，在达内学习到编程是铸造梦想的地方，如果你喜欢编程，这里，有我们共同语言，共同的故事，共同的梦想！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2dce3df69428b18befec14892af59d5/" rel="bookmark">
			javascript笔记之正则表达式ji
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RegExp
两种创建方法：1.字面量 var test=/\[bc\]at/i; 2、var test= new RegExp("\\[bc\\]at","i"); //双重转义的问题： var str = "\?"; alert(str);//只会输出? var re = /\?/;//将匹配? alert(re.test(str));//true re = new RegExp("\?");//出错,因为这相当于re = /\?/ re = new RegExp("\\?");//正确，将匹配？ alert(re.test(str));//true est.test(字符串)返回true和false est.exec(字符串)返回第一次匹配的内容。 RegExp对象属性： global、ignoreCase、
lastIndex（下一次匹配的开始位置，当设置的长度大于字符串长度使，下次执行exec（）重新设置为0）、lastMatch（即 $&amp;，最后匹配的字符串）、
leftContext （ 返回被查找的字符串中从字符串开始位置到最后匹配之前的位置之间的字符) 、
rigthContext（ 返回被搜索的字符串中从最后一个匹配位置开始到字符串结尾之间的字符）
multiline、source（正则表达式的字符串表示） 基本函数： exec() var str = "cat,bat,fat,dat"; var test = /.at/g; for(result =test.exec(str);result;result =test.exec(str)){ console.log(result); console.log(result[0]);//匹配的字符串&lt;span style="font-family: Arial, Helvetica, sans-serif;"&gt; }&lt;/span&gt; test() 返回true和false
基本匹配 （）捕获字符串，创建匹配子串 ^匹配开始位置，在[^]表示负字符集。 $以该字符串结束 \s匹配任何空白字符，包括空格、制表符、换页符等 []匹配指定范围内任意字符 \d表示数字 \b表示单词边界 search方法无需指定global属性，默认第一次匹配成功后返回正则表达式与match配合匹配指定字符串元字符 ( [ { \ ^ $ | ) ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2dce3df69428b18befec14892af59d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51eab03a4dc653846e6c6e6daac9e80a/" rel="bookmark">
			Unity中单例模式的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.单例模式的基本实现：
单例模式(singleton pattern)大家都不陌生，我今天主要是和大家探讨一下单例模式在unity中的实现，比起一般的单例，unity中有些他的特点。
最普通的单例：（样式一）
public class Singleton { static Singleton instance; public static Singleton Instance { get { if (instance == null) { instance = new Singleton (); } return instance; } } } unity单例模式二： 但是unity的所有脚本都必须挂在一个gameobject上，否则无法执行，你这个单例中若只是一些数据，那倒没关系，但我相信绝大多数单例模式都不会只包含数据，若只要实现包含数据的功能，用全局静态变量就行了，说到这里加一句，有些盆友喜欢用单例脚本当做全局脚本来用，那其实是违背单例模式的初衷的... 好，我们来实现以下挂到gameobject的单例（模式二）：
public class UnitySingleton : MonoBehaviour { static UnitySingleton instance; public static UnitySingleton Instance { get { if (instance == null) { instance = FindObjectOfType (typeof(UnitySingleton)) as UnitySingleton; if (instance == null) { GameObject obj = new GameObject (); instance = obj.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/51eab03a4dc653846e6c6e6daac9e80a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94ea3598f5c1075ad96103950ab0e602/" rel="bookmark">
			c语言实现几种排序算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常见排序算法（冒泡，选择，快速）的C语言实现 冒泡法（起泡法） 算法要求：用起泡法对10个整数按升序排序。
算法分析：如果有n个数，则要进行n-1趟比较。在第1趟比较中要进行n-1次相邻元素的两两比较，在第j趟比较中要进行n-j次两两比较。比较的顺序从前往后，经过一趟比较后，将最值沉底（换到最后一个元素位置），最大值沉底为升序，最小值沉底为降序。
算法源代码：
# include &lt;stdio.h&gt;
main()
{
int a[10],i,j,t;
printf("Please input 10numbers: ");
/*输入源数据*/
for(i=0;i&lt;10;i++)
scanf("%d",&amp;a[i]);
/*排序*/
for(i=0;i&lt;9;i++) /*外循环控制排序趟数，n个数排n-1趟*/
for(j=0;j&lt;9-i;j++) /*内循环每趟比较的次数，第j趟比较n-j次*/
if(a[j]&gt;a[j+1]) /*相邻元素比较，逆序则交换*/
{ t=a[j];
a[j]=a[j+1];
a[j+1]=t;
}
/*输出排序结果*/
printf("The sortednumbers: ");
for(i=0;i&lt;10;i++)
printf("%d ",a[i]);
printf("\n");
}
算法特点：相邻元素两两比较，每趟将最值沉底即可确定一个数在结果的位置，确定元素位置的顺序是从后往前，其余元素可能作相对位置的调整。可以进行升序或降序排序。
算法分析：定义n-1次循环，每个数字比较n-j次，比较前一个数和后一个数的大小。然后交换顺序
选择法
算法要求：用选择法对10个整数按降序排序。
算法分析：每趟选出一个最值和无序序列的第一个数交换，n个数共选n-1趟。第i趟假设i为最值下标，然后将最值和i+1至最后一个数比较，找出最值的下标，若最值下标不为初设值，则将最值元素和下标为i的元素交换。
算法源代码：
# include &lt;stdio.h&gt;
main()
{
int a[10],i,j,k,t,n=10;
printf("Please input 10numbers:");
for(i=0;i&lt;10;i++)
scanf("%d",&amp;a[i]);
for(i=0;i&lt;n-1;i++) /*外循环控制趟数，n个数选n-1趟*/
{
k=i; /*假设当前趟的第一个数为最值,记在k中 */
for(j=i+1;j&lt;n;j++) /*从下一个数到最后一个数之间找最值*/
{
if(a[k]&lt;a[j]) /*若其后有比最值更大的*/
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94ea3598f5c1075ad96103950ab0e602/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7409b9ff1cf85f515f6f31ac935b9151/" rel="bookmark">
			使用vmware converter转物理机linux的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2019独角兽企业重金招聘Python工程师标准&gt;&gt;&gt; 1、The specified parameter was not correct:"info.owner
converter机和源机器、目的机器都通，但是源机器、目的机器不通导致。解决办法：把三个机器都放到同一网段上，问题消失。
2、执行该操作的权限被拒绝
解决办法：执行converter时，使用管理员权限运行。
3、event.UnixP2VVolumeCloneFailedEvent.summary
配置时，选择minimal size时，报上述错误。解决办法：使用Type Size，填写一个略大实际大小的值库，成功。
4、FAILED: fault.HelperVmFailedToObtainIpFault.summary
配置页面，需要指定helper vm network为静态IP，并且该IP和源机器联通，保险点，在同一网段上。
转载于:https://my.oschina.net/u/2269414/blog/522969
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4e61b94df007b7092e3d3b20c598f12/" rel="bookmark">
			[D3.js] SVG-Axes（坐标轴）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		D3的轴 组件是为D3的quantitative, time 和 ordinal 标度所设计的。 # d3.svg.axis() 新建一个默认的坐标轴。 # aixs(selection) 轴线适用于selection 或 transition。选择器必须包含一个 svg 或者 g 元素。 例如: d3.select("body").append("svg") .attr("class", "axis") .attr("width", 1440) .attr("height", 30) .append("g") .attr("transform", "translate(0,30)") .call(axis); # axis.scale([scale])（量度） 若scale量度有指定，则设置相应量度并返回轴线。若没有指定，则返回当前量度，默认为线性量度。 # axis.orient([orientation])（方向） 若orientation方向有指定，则设置相应方向并返回。若没有指定，则返回默认方向“bottom”。支持的方向有： "top" - 横坐标的刻度标注位于轴上方 "bottom" - 横坐标的刻度标注位于轴下方 "left" - 纵坐标的刻度标注位于轴左边 "right" - 纵坐标的刻度标注位于轴右边 如果指定的方向不是以上四个支持的参数之一，则会自动恢复默认值。改变方向只能改变刻度标注和轴路径相关标签的位置，并不能改变轴线本身的位置；而要针对当前区域去改变轴的位置，则可以通过指定相应的g元素的transform属性。 # axis.ticks([arguments...])（刻度） 若arguments 参数有指定，则存储这些参数，然后在生成刻度时使用并返回。这些参数之后也会被传给 scale.ticks 去生成刻度值（除非刻度值有通过 axis.tickValues 明确地指定）。同时，这些参数也会被传进 scale 的 tickFormat 方法去生成默认的刻度格式。若没有指定参数，则返回默认的刻度参数，默认为[10]。 合适的参数依赖于相关的量度：对于一个线性量度来说，你可以像 axis.ticks(20) 这样去指定刻度数量；对于对数量度，你应该指定数量同时指定刻度格式；而对于时间量度，像 axis.ticks(d3.time.minutes, 15) 这样有一个时间间隔会更为恰当。 #axis.tickValues([values])（刻度值） 若指定了values 数组，这些值将会被用于刻度标注，而不会使用量度自动生成的刻度值。如果values 为空，将会清空所有之前设置的刻度值并恢复到原来生成的默认刻度值。若没有指定刻度值，返回当前设置好的刻度值，默认为空。例如，指定刻度值生成刻度尺： var xAxis = d3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e4e61b94df007b7092e3d3b20c598f12/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/167e47a2b1a01b167ea82eb50cd32dc2/" rel="bookmark">
			c语言编程中%g是什么格式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		%g用来输出实数，它根据数值的大小，自动选f格式或e格式（选择输出时占宽度较小的一种），且不输出无意义的0。即%g是根据结果自动选择科学记数法还是一般的小数记数法
printf("%g\n", 0.00001234);
printf("%g\n", 0.0001234);
printf("%.2g\n", 123.45);
printf("%.2g\n", 23.45);
上面四句输出结果为:
1.234e-05
0.0001234
1.2e+02
23
对于指数小于-4或者大于给定精度的数值,按照%e的控制输出,否则按照%f的控制输出.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6bb456bcd4db71448aab5fb2acf21866/" rel="bookmark">
			为什么要使用多线程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自：http://www.cnblogs.com/gguozhenqian/archive/2011/11/16/2251521.html
1．耗时的操作使用线程，提高应用程序响应
2．并行操作时使用线程，如C/S架构的服务器端并发线程响应用户的请求。
3．多CPU系统中，使用线程提高CPU利用率
4．改善程序结构。一个既长又复杂的进程可以考虑分为多个线程，成为几个独立或半独 立的运行部分，这样的程序会利于理解和修改。 使用多线程的理由之一是和进程相比，它是一种非常花销小，切换快，更"节俭"的多任务操作方式。在Linux系统下，启动一个新的进程必须分配给它独立的地址空间，建立众多的数据表来维护它的代码段、堆栈段和数据段，这是一种"昂贵"的多任务工作方式。而运行于一个进程中的多个线程，它们彼此之间使用相同的地址空间，共享大部分数据，启动一个线程所花费的空间远远小于启动一个进程所花费的空间，而且，线程间彼此切换所需的时间也远远小于进程间切换所需要的时间。 使用多线程的理由之二是线程间方便的通信机制。对不同进程来说，它们具有独立的数据空间，要进行数据的传递只能通过通信的方式进行，这种方式不仅费时，而且很不方便。线程则不然，由于同一进程下的线程之间共享数据空间，所以一个线程的数据可以直接为其它线程所用，这不仅快捷，而且方便。当然，数据的共享也带来其他一些问题，有的变量不能同时被两个线程所修改，有的子程序中声明为static的数据更有可能给多线程程序带来灾难性的打击，这些正是编写多线程程序时最需要注意的地方。 除了以上所说的优点外，不和进程比较，多线程程序作为一种多任务、并发的工作方式，当然有以下的优点：
1) 提高应用程序响应。这对图形界面的程序尤其有意义，当一个操作耗时很长时，整个系统都会等待这个操作，此时程序不会响应键盘、鼠标、菜单的操作，而使用多线程技术，将耗时长的操作（time consuming）置于一个新的线程，可以避免这种尴尬的情况。 2) 使多CPU系统更加有效。操作系统会保证当线程数不大于CPU数目时，不同的线程运行于不同的CPU上。 3) 改善程序结构。一个既长又复杂的进程可以考虑分为多个线程，成为几个独立或半独立的运行部分，这样的程序会利于理解和修改。 当前流行的Windows操作系统，它能同时运行几个程序(独立运行的程序又称之为进程)，对于同一个程序，它又可以分成若干个独立的执行流，我们称之为线程，线程提供了多任务处理的能力。用进程和线程的观点来研究软件是当今普遍采用的方法，进程和线程的概念的出现，对提高软件的并行性有着重要的意义。现在的应用软件无一不是多线程多任务处理，单线城的软件是不可想象的。因此掌握多线程多任务设计方法对每个程序员都是必需要掌握的。本文针对多线程技术在应用中经常遇到的问题，如线程间的通信、同步等，对它们分别进行探讨。 一、 理解线程 要讲解线程，不得不说一下进程，进程是应用程序的执行实例，每个进程是由私有的虚拟地址空间、代码、数据和其它系统资源组成。进程在运行时创建的资源随着进程的终止而死亡。线程的基本思想很简单，它是一个独立的执行流，是进程内部的一个独立的执行单元，相当于一个子程序，它对应Visual C++中的CwinThread类的对象。单独一个执行程序运行时，缺省的运行包含的一个主线程，主线程以函数地址的形式，如main或WinMain函数，提供程序的启动点，当主线程终止时，进程也随之终止，但根据需要，应用程序又可以分解成许多独立执行的线程，每个线程并行的运行在同一进程中。 一个进程中的所有线程都在该进程的虚拟地址空间中，使用该进程的全局变量和系统资源。操作系统给每个线程分配不同的CPU时间片，在某一个时刻，CPU只执行一个时间片内的线程，多个时间片中的相应线程在CPU内轮流执行，由于每个时间片时间很短，所以对用户来说，仿佛各个线程在计算机中是并行处理的。操作系统是根据线程的优先级来安排CPU的时间，优先级高的线程优先运行，优先级低的线程则继续等待。 线程被分为两种：用户界面线程和工作线程（又称为后台线程）。用户界面线程通常用来处理用户的输入并响应各种事件和消息，其实，应用程序的主执行线程CWinAPP对象就是一个用户界面线程，当应用程序启动时自动创建和启动，同样它的终止也意味着该程序的结束，进城终止。工作者线程用来执行程序的后台处理任务，比如计算、调度、对串口的读写操作等，它和用户界面线程的区别是它不用从CwinThread类派生来创建，对它来说最重要的是如何实现工作线程任务的运行控制函数。工作线程和用户界面线程启动时要调用同一个函数的不同版本；最后需要读者明白的是，一个进程中的所有线程共享它们父进程的变量，但同时每个线程可以拥有自己的变量。
随着拥有多个硬线程CPU（超线程、双核）的普及，多线程和异步操作等并发程序设计方法也受到了更多的关注和讨论。本文主要是想与各位高手一同探讨一下如何使用并发来最大化程序的性能。 多线程和异步操作的异同 多线程和异步操作两者都可以达到避免调用线程阻塞的目的，从而提高软件的可响应性。甚至有些时候我们就认为多线程和异步操作是等同的概念。但是，多线程和异步操作还是有一些区别的。而这些区别造成了使用多线程和异步操作的时机的区别。 异步操作的本质 所有的程序最终都会由计算机硬件来执行，所以为了更好的理解异步操作的本质，我们有必要了解一下它的硬件基础。 熟悉电脑硬件的朋友肯定对DMA这个词不陌生，硬盘、光驱的技术规格中都有明确DMA的模式指标，其实网卡、声卡、显卡也是有DMA功能的。DMA就是直接内存访问的意思，也就是说，拥有DMA功能的硬件在和内存进行数据交换的时候可以不消耗CPU资源。只要CPU在发起数据传输时发送一个指令，硬件就开始自己和内存交换数据，在传输完成之后硬件会触发一个中断来通知操作完成。这些无须消耗CPU时间的I/O操作正是异步操作的硬件基础。所以即使在DOS这样的单进程（而且无线程概念）系统中也同样可以发起异步的DMA操作。 线程的本质 线程不是一个计算机硬件的功能，而是操作系统提供的一种逻辑功能，线程本质上是进程中一段并发运行的代码，所以线程需要操作系统投入CPU资源来运行和调度。 异步操作的优缺点 因为异步操作无须额外的线程负担，并且使用回调的方式进行处理，在设计良好的情况下，处理函数可以不必使用共享变量（即使无法完全不用，最起码可以减少共享变量的数量），减少了死锁的可能。当然异步操作也并非完美无暇。编写异步操作的复杂程度较高，程序主要使用回调方式进行处理，与普通人的思维方式有些初入，而且难以调试。 多线程的优缺点 多线程的优点很明显，线程中的处理程序依然是顺序执行，符合普通人的思维习惯，所以编程简单，线程间的通信。但是多线程的缺点也同样明显，线程的使用（滥用）会给系统带来上下文切换的额外负担。并且线程间的共享变量可能造成死锁的出现。 适用范围 在了解了线程与异步操作各自的优缺点之后，我们可以来探讨一下线程和异步的合理用途。我认为：当需要执行I/O操作时，使用异步操作比使用线程+同步I/O操作更合适。I/O操作不仅包括了直接的文件、网络的读写，还包括数据库操作、Web Service、HttpRequest以及.net Remoting等跨进程的调用。 而线程的适用范围则是那种需要长时间CPU运算的场合，例如耗时较长的图形处理和算法执行。但是往往由于使用线程编程的简单和符合习惯，所以很多朋友往往会使用线程来执行耗时较长的I/O操作。这样在只有少数几个并发操作的时候还无伤大雅，如果需要处理大量的并发操作时就不合适了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8a1741521b6f20f58392ab01c54afea/" rel="bookmark">
			MYsql查询高速缓存设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自：http://blog.itpub.net/23682959/viewspace-631599/ 1:通过have_query_cache服务器系统变量指示查询缓存是否可用：
mysql&gt; SHOW VARIABLES LIKE 'have_query_cache';
2:为了设置查询缓存大小，设置query_cache_size系统变量。
设置为0表示禁用查询缓存。 默认缓存大小设置为0；也就是禁用查询缓存。
mysql&gt; SET GLOBAL query_cache_size =40000 ;
当设置query_cache_size变量为非零值时，应记住查询缓存至少大约需要40KB来分配其数据结构。(具体大小取决于系统结构）。
mysql&gt; SHOW WARNINGS\G
mysql&gt;SHOW VARIABLES LIKE 'query_cache_size';
如果查询缓存大小设置为大于0，query_cache_type变量影响其工作方式。这个变量可以设置为下面的值：
· 0或OFF将阻止缓存或查询缓存结果。
· 1或ON将允许缓存，以SELECT SQL_NO_CACHE开始的查询语句除外。
· 2或DEMAND，仅对以SELECT SQL_CACHE开始的那些查询语句启用缓存。
例如，一个客户可以禁用自己的查询缓存，方法如下：
mysql&gt; SET SESSION query_cache_type = OFF;
可以使用FLUSH QUERY CACHE语句来清理查询缓存碎片以提高内存使用性能。
该语句不从缓存中移出任何查询。
RESET QUERY CACHE语句从查询缓存中移出所有查询。
FLUSH TABLES语句也执行同样的工作。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3087eee74812d0851e5ea78c8c57a770/" rel="bookmark">
			数据库性能的优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自：http://www.cnblogs.com/kex1n/archive/2010/03/26/2286504.html
mysql执行脚本 首要步骤(一般可省略): 开启mysql服务(默认是开机时就自动运行了): 控制面板--&gt;管理工具--&gt;服务,在里面找到名称为mysql的项,双击就可看它的服务状态是启动还是停止,把它设为启动
连接mysql: 在命令行下输入 mysql -h localhost -u root -p回车,然后输入密码即可;或直接运行mysql自带的连接工具,然后输入密码即可.
1.编写sql脚本,假设内容如下:
create database dearabao; use dearabao; create table niuzi (name varchar(20));
保存脚本文件,假设我把它保存在F盘的hello world目录下,于是该文件的路径为:F:/hello world/niuzi.sql
2.执行sql脚本,可以有2种方法: 第一种方法: 在命令行下(未连接数据库),输入 mysql -h localhost -u root -p123456 &lt; F:/hello world/niuzi.sql (注意路径不用加引号的!!) 回车即可. 第二种方法: 在命令行下(已连接数据库,此时的提示符为 mysql&gt; ),输入 source F:/hello world/niuzi.sql (注意路径不用加引号的) 或者 /. F:/hello world/niuzi.sql (注意路径不用加引号的) 回车即可
SQL编写规范
1.书写格式最好统一 示例代码：
存储过程SQL文书写格式例 select c.dealerCode, round(sum(c.submitSubletAmountDLR + c.submitPartsAmountDLR + c.submitLaborAmountDLR) / count(*), 2) as avg, decode(null, 'x', 'xx', 'CNY') from ( select a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3087eee74812d0851e5ea78c8c57a770/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bad7b42697c7f369ea47189b1bc4a84b/" rel="bookmark">
			Android 蓝牙低能耗(BLE)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文翻译自：http://developer.android.com/guide/topics/connectivity/bluetooth-le.html
Android4.3（APILevel 18）引入了内建平台支持蓝牙低能耗的核心作用，提供给APP相应的API能够发现设备，查询服务，和提供读/写特性。与传统的蓝牙相比，蓝牙低能耗设计提供了明显地低电量消耗。它允许Android应用与对低能耗有要求的BLE设备进行通信，例如近距离传感器，心率监测设备，健康设备等等。
主要术语和概念 以下是BLE的关键术语和概念的总结：
l 通用属性配置（GATT）-------- GATT配置是一个通用的规范，用来发送和接收被称作“属性”的短片数据通过BLE连接。所有当前的低能耗应用配置都是基于GATT。
Ø 蓝牙技术联盟定义了许多低能耗设备的配置。一个配置是一个规范用来确定一个设备在特定的应用中如何运行。注意一个设备可以实现多个配置。例如，一个设备可以包含一个心率监测配置和电量监测配置。
l 属性协议（ATT）-------GATT建立在属性协议（ATT）基础上。这也可以被成为GATT/ATT。ATT可以在BLE设备上最佳运行。为此，它使用尽可能少的字节。每个属性通过一个全球唯一标识符（UUID）定义，UUID是一个标准的128位字符串ID用来唯一标识信息。通过ATT传送的属性被格式化为特征和服务。
l 特征----------特征包含一个单一的值和0-n个描述符描述特征的值。一个特征可以被认为是一种类型，类似于类。
l 描述符-------描述符被定义为属性用来描述特征的值。例如，一个描述符可能指定一个人类刻度的描述，一个特征值的可接受范围或者一个测量单元用来指定一个特征的值。
l 服务----------一个服务是一组特征的集合。例如，你可以有一个服务叫做“心率监测”包含例如“心率测量”的特征。你可以在bluetooth.org上找到一系列存在的GATT基础配置和服务。
角色与职责 以下是当一个Android设备与一个BLE设备交互时应用的角色和职责：
l 中央与外围。这适用于BLE连接本身。处于中心角色的设备扫描，查找广告，外围角色的设备制作广告。
l GATT服务器与GATT客户端。这取决于一旦两个设备建立连接之后，两个设备之间如何进行通信。
为了理解这个区别，假设你有一个Android手机和一个是BLE设备的活动跟踪器。手机支持中心角色；活动跟踪器支持外围角色（为了建立BLE连接，你需要其中一个设备仅支持外围不能够跟对方对话，而不是两台设备仅仅支持中心角色）。
一旦手机和活动跟踪器建立了连接，他们开始传送元数据给另一方。依赖于他们之间传输的数据类型，一个或者另一个会作为服务器。例如，如果活动跟踪器想要报告传感器数据给手机，那活动跟踪器可能会作为服务器。如果活动跟踪器想要接收手机端的更新，那么手机端将会作为服务端。
在这篇文档使用的例子中，这个Android应用（运行在Android设备上）是GATT客户端。这个应用从GATT服务端获取数据，该服务端是一个支持心率配置的心率监测设备。但是你能够选择设计你的Android应用扮演GATT服务端角色。查看BluetoothGattServer（http://developer.android.com/reference/android/bluetooth/BluetoothGattServer.html） 例子获取更多地信息。
BLE权限 为了在你的应用中使用蓝牙特性，你必须声明蓝牙的权限（http://developer.android.com/reference/android/Manifest.permission.html#BLUETOOTH）。你需要这些权限来执行任意的蓝牙通信，例如请求一个连接，接受一个连接，和传输数据。
如果你想要你的应用初始化设备发现或者操作蓝牙设置，你必须也声明BLUETOOTH_ADMIN（http://developer.android.com/reference/android/Manifest.permission.html#BLUETOOTH_ADMIN）权限。注意：如果你使用BLUETOOTH_ADMIN权限，那么你也必须声明BLUETOOTH权限。
在你应用的清单文件中声明蓝牙权限。例如：
&lt;uses-permission android:name="android.permission.BLUETOOTH"/&gt;
&lt;uses-permission android:name="android.permission.BLUETOOTH_ADMIN"/&gt;
如果你需要你的应用仅能运行在支持BLE的设备上，请在你的应用清单上包含以下权限：
&lt;uses-feature android:name="android.hardware.bluetooth_le" android:required="true"/&gt;
然而，如果你想要你的应用在不支持BLE的设备上可用，你仍然需要包含以上元素，但是设置required=”false”。然后在运行时通过使用Packagemanager.hasSystemFeature，你能够决定BLE是否可用。
// Use this check to determine whether BLE is supported on the device.Then
// you can selectively disableBLE-related features.
if (!getPackageManager().hasSystemFeature(PackageManager.FEATURE_BLUETOOTH_LE)) {
Toast.makeText(this, R.string.ble_not_supported, Toast.LENGTH_SHORT).show();
finish();
}
建立BLE 在你的应用能够通过BLE通信之前，你需要确保在此设备上支持BLE，同时如果是这样，确保BLE是启用的。注意仅当如果&lt;uses-feature…/&gt;设置为false时这项检查是必要的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bad7b42697c7f369ea47189b1bc4a84b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7a9639b5c0adaa062aed05c2f158dc3/" rel="bookmark">
			vm manager failed to contact configuration server
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当用virt-manager命令启动VM 管理工具是报错：vm manager failed to contact configuration server
如下办法解决了我的问题：
读取dbus uuid
dbus-uuidgen --get
查看旧的uuid
cat /var/lib/dbus/machine-id
重新创建uuid
dbus-uuidgen &gt; /var/lib/dbus/machine-id &lt;uuid&gt;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a00323b5254c4a7c680beb491d0dd195/" rel="bookmark">
			curl CURLOPT_WRITEFUNCTION的一些问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 这个参数所设置的回调函数原型是这样的: size_t function( char *ptr, size_t size, size_t nmemb, void *userdata). 这个回调函数被调用的时机是有响应数据到达,这些数据由ptr指向,大小是size*nmemb.到这里为止还是文档上的说法.从socket的角度考虑,响应数据自然不一定会是以0结尾的字符串,而应当被认为是流数据.只要服务端没有关闭连接,只要服务端还在发送响应数据,这个函数就会被调用,而被调用的次数不一定只是一次,也许会是许多次,每一次被调用所接收到的数据大小是size*nmemb,这些文档上似乎没有提到,因为这是理当如此的事情.所以在处理响应数据的时候不能想当然,必须要考虑到这个函数会被多次调用. 再说说 userdata,这是一个FILE *的指针,这个参数跟 CURLOPT_WRITEDATA 相关,如果已经自己写了回调函数,而不是用缺省的回调函数把接收到的数据写到用 CURLOPT_WRITEDATA 所设置的userdata所指向的文件当中去,那么就可以把这个指针设为NULL. 下面是个例子: char *res_buf = NULL; int shift; size_t copy_data(void *ptr, size_t size, size_t nmemb, void *stream) { int res_size; res_size = size * nmemb; res_buf = realloc(res_buf, shift+res_size + 1); memcpy(res_buf + shift, ptr, res_size); shift += res_size; return size * nmemb; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/703ef409aa257d5818aa5605ae372d2c/" rel="bookmark">
			VS2012 编译Librtmp
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		经过一天折腾，终于在WIN7 64位环境中编译Librtmp成功！
参考文章：
1.http://www.cnblogs.com/haibindev/archive/2011/12/29/2305712.html
2.http://blog.csdn.net/zqf_office/article/details/10112435
3.http://www.ithao123.cn/content-8350054.html
第一步 Openssl 1.下载Openssl.exe安装后即可使用，网上很多都使用源代码编译，结果折腾半年都不行。最终发现可以直接使用注意选择对应操作系统我选择的是Win64 OpenSSL v1.0.2d Light。
2.安装openssl到C盘下，C:\OpenSSL-Win64。后续使用到的内容为：
头文件目录： C:\OpenSSL-Win64\include 链接库文件：C:\OpenSSL-Win64\lib\libeay32.lib 和 C:\OpenSSL-Win64\lib\ssleay32.lib
第二步 zlib 1.下载zlib包，并解压。下载地址：http://zlib.net/ 2.运行VisualStudio Command Prompt，其实就是VS2012 X64 兼容工具命令提示符,按照网上专家们说的： 切到zlib-2.1.5目录，分别执行以下命令
&gt;cd contrib\masmx86
&gt;bld_ml32.bat
提示XXXml64.exe不是内部命令。恶心惨了。最终解决方式： 将C:\Program Files (x86)\Microsoft Visual Studio 11.0\VC\bin\x86_amd64\ml64.exe复制到zlib-1.2.8\contrib\masmx64下面，再按照命令执行即可。 PS：比如我zlib-1.2.8在F盘中，在命令提示符中 a. &gt;F: b. &gt;F:\DEMO\zlib-1.2.8\contrib\masmx64\ c. &gt;bld_ml64.bat 完成！ 3.编译 a.打开F:\DEMO\zlib-1.2.8\contrib\vstudio\vc11\zlibvc.sln b.按照网上说的，在zlibstat工程属性中，去掉预编译宏 ZLIB_WINAPI c.只编译，zlibstat项目即可。 头文件目录：F:\DEMO\zlib-1.2.8\下所有.H文件，简单点就是排除文件夹其他文件全部使用。 依赖库文件：F:\DEMO\zlib-1.2.8\contrib\vstudio\vc11\x64\ZlibStatDebug\zlibstat.lib 第三部编译librtmp库 1.下载rtmpdump ,下载地址：http://rtmpdump.mplayerhq.hu/ 2.在VS2012中创建C++项目中： a.WIN32控制台应用程序（命名Librtmp） b.下一步中选择静态库，取消勾选：预编译头和安全开发生命周期XXOO,完成。 c.在工程文件目录中(PS：在解决方案窗体中，点击项目右键，选择“在资源管理器中打开文件夹”)，创建include和lib文件夹。 3.解压下载的文件夹，将rtmpdump-2.3文件夹下的\rtmpdump-2.3\librtmp中的所有文件拷贝到2步骤C的选择的文件夹中。 4.在项目中设置对应的.H文件和C文件, 选择打开目录中的所有.h文件 按照对应的方式，在源文件中添加所有的.c文件。 5.添加应用库 a.将第一步中的头文件库以及第二步中的头文件库全部拷贝到include文件夹中 b.设置项目头文件引用 C.将第一步和第二步中的.lib文件复制到\Librtmp\Librtmp\lib文件夹中。 d.设置库引用, 库名称 最终项目样子 编译完成！！ 工程压缩包：http://download.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/703ef409aa257d5818aa5605ae372d2c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e15429d3670da288c1261954af85b1e3/" rel="bookmark">
			让不支持HTML5的老浏览器 “兼容”HTML5
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 为了能让那些陈旧的浏览器显示HTML5效果 我们需要做的是：
1、CSS属性 变成块元素
header, section, footer, aside, nav, main, article, figure { display: block; }
2、来自度娘的伟大贡献 让度娘解释给老版本的浏览器
&lt;!--[if lt IE 9]&gt; &lt;script src="http://apps.bdimg.com/libs/html5shiv/3.7/html5shiv.min.js"&gt;&lt;/script&gt; &lt;![endif]--&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9878243bc70df13c665cd231bdffaed2/" rel="bookmark">
			说说Spring MVC的工作原理、流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在整个Spring MVC框架中，DispatcherServlet处于核心位置，它负责协调和组织不同组件完成请求处理并返回响应的工作。具体流程为：
1）客户端发送http请求，web应用服务器接收到这个请求，如果匹配DispatcherServlet的映射路径（在web.xml中配置），web容器将请求转交给DispatcherServlet处理；
2）DispatcherServlet根据请求的信息及HandlerMapping的配置找到处理该请求的Controller；
3）Controller完成业务逻辑处理后，返回一个ModelAndView给DispatcherServlet；
4）DispatcherServlet借由ViewResolver完成ModelAndView中逻辑视图名到真实视图对象View的解析工作；
5）DispatcherServlet根据ModelAndView中的数据模型对View对象进行视图渲染，最终客户端得到的响应消息可能是一个普通的html页面，也可能是一个xml或json串，甚至是一张图片或一个PDF文档等不同的媒体形式。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4093bb60e8637e6947f548309d960cf8/" rel="bookmark">
			《深入理解Linux网络技术内幕》阅读笔记（三十三）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 路由代码只使用每个设备上的转发状态：改变全局配置只是一次性将该改变应用到所有设备的一种简便方法。 只有主机才能接收ICMP重定向消息，而路由器不能够接收。如果全局转发状态变为开启，意味着系统现在被视为一台路由器，因而必须禁止可敬的ICMP重定向的默认配置。 n%fz_divisor的结果与n&amp;fz_hashmask的结果相同（例如100%16 == 100&amp;15），而二进制按位与操作所花费的CPU时间要少。 RTNH_F_ONLINK:当该标识被设置时，要求内核不检查下一跳地址是否相连（即不检查下一跳地址通过流出设备是否可达）。例如，当定义隧道虚拟路由设备时，onlink关键字用于设置和使用该标识。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/657de3117477f4033a82fa2deb1f102c/" rel="bookmark">
			Spring Mvc中@ResponseBody中文乱码解决汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		﻿﻿ spring 3 mvc 的 @ResponseBody返回数据用起来很方便,但是中文乱码,而且返回的Content-Type不带编码信息,网上有很多解决方法，但是大部分都存在一些问题，这里只介绍一种，如下： 自己写一个继承StringHttpMessageConverter的类UTF8StringHttpMessageConverter,内容参考 StringHttpMessageConverter.java中的代码， 该类参考代码如下： package com.aikang.common; import java.io.IOException; import java.io.OutputStreamWriter; import java.nio.charset.Charset; import java.util.Arrays; import java.util.List; import org.springframework.http.HttpOutputMessage; import org.springframework.http.MediaType; import org.springframework.http.converter.StringHttpMessageConverter; import org.springframework.util.FileCopyUtils; public class UTF8StringHttpMessageConverter extends StringHttpMessageConverter { private static final MediaType utf8 = new MediaType("text", "plain", Charset.forName("UTF-8")); private boolean writeAcceptCharset = true; @Override protected MediaType getDefaultContentType(String t) { return utf8; } @Override protected List&lt;Charset&gt; getAcceptedCharsets() { return Arrays.asList(utf8.getCharSet()); } @Override protected void writeInternal(String s, HttpOutputMessage outputMessage) throws IOException { if (this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/657de3117477f4033a82fa2deb1f102c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e401ce6432d3237931e0ecb3f12aa323/" rel="bookmark">
			ifconfig,iwconfig,wpa_ctl的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一。各个命令的使用范围
ipconfig - windows
ifconfig - unix/linux interface config iwconfig - linux interface wireless config
wpa_ctl - linux interface wireless config
二。 linux wireless中 工具的区别：
内容:
介绍WPA SupplicantWireless Tools针对每个ESSID的网络配置 1. 介绍
目前您可以使用我们提供的wireless-tools 或wpa_supplicant工具来配置无线网络。请记住重要的一点是，您对无线网络的配置是全局性的，而非针对具体的接口。
wpa_supplicant是一个最好的选择，但缺点是它不支持所有的驱动。请浏览wpa_supplicant网站获得它所支持的驱动列表。另外，wpa_supplicant目前只能连接到那些你已经配置好ESSID的无线网络。
wireless-tools支持几乎所有的无线网卡和驱动，但它不能连接到那些只支持WPA的AP。
wpa_supplicant本是开源项目源码，被谷歌修改后加入android移动平台，它主要是用来支持WEP，WPA/WPA2和WAPI无线协议和加密认证的，而实际上的工作内容是通过socket（不管是wpa_supplicant与上层还是wpa_supplicant与驱动都采用socket通讯）与驱动交互上报数据给用户，而用户可以通过socket发送命令给wpa_supplicant调动驱动来对WiFi芯片操作。 简单的说，wpa_supplicant就是WiFi驱动和用户的中转站外加对协议和加密认证的支持。
目前可以使用wireless-tools 或wpa_supplicant工具来配置无线网络。请记住重要的一点是，对无线网络的配置是全局性的，而非针对具体的接口。
wpa_supplicant是一个较好的选择，但缺点是它不支持所有的驱动。请浏览wpa_supplicant网站获得它所支持的驱动列表。另外，wpa_supplicant目前只能连接到那些你已经配置好ESSID的无线网络。wireless-tools支持几乎所有的无线网卡和驱动，但它不能连接到那些只支持WPA的AP。
经过编译后的wpa_supplicant源程序可以看到两个主要的可执行工具：wpa_supplicant和wpa_cli。wpa_supplicant是核心程序，它和wpa_cli的关系就是服务和客户端的关系：后台运行wpa_supplicant，使用wpa_cli来搜索、设置、和连接网络。
警告: 由于linux-wlan-ng驱动有其自己特有的安装和配置方式，而且与其他软件的方式完全不同，因此目前它并不被baselayout所支持。有传闻说linux-wlan-ng的开发者要将它的设置方式改成wireless-tools的方式——到时候您就可以在baselayout中使用linux-wlan-ng了。
4.b. WPA Supplicant
WPA Supplicant工具包可以让您连接到那些使用WPA的AP。因为还只是beta版，所以它的配置方法仍会常常变化——尽管如此，在大部分情况下它已经能很好的工作。
代码 2.1: 安装wpa_supplicant
# emerge net-wireless/wpa_supplicant 重要: 要让wpa_supplicant正常工作，您必须在内核中打开CONFIG_PACKET支持。
现在我们需要配置一下/etc/conf.d/net文件以便我们可以选择使用wpa_supplicant而不用wireless-tools（两者都安装在系统中时，默认使用的是wireless-tools）。
代码 2.2: 在/etc/conf.d/net中配置wpa_supplicant
# 使用wpa_supplicant代替wireless-tools modules=( "wpa_supplicant" ) # 因为wpa_supplicant还不能很好的自动侦测驱动，所以需要我们为其指定正在使用的驱动。 wpa_supplicant_eth0="-Dmadwifi" 注意: 如果您用host-ap驱动，您首先要将无线设备卡设置成Managed模式以便能正确地配合wpa_supplicant工作。你可以在/etc/conf.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e401ce6432d3237931e0ecb3f12aa323/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1cb83b4f442011f9f2ee3d843d95e840/" rel="bookmark">
			Matlab矩阵转置注意事项
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Matlab中的转置分为共轭转置和非共轭转置，对任意复数C，其共轭转置为C’，非共轭转置为C.’，对实数二者相同。
复数C 1.共轭转置C’
&gt;&gt; [-1i 1i]' ans = 0 + 1.0000i 0 - 1.0000i 2.非共轭转置C.’
&gt;&gt; [-1i 1i].' ans = 0 - 1.0000i 0 + 1.0000i 实数R 1.共轭转置R’
&gt;&gt; [1 2]' ans = 1 2 2.非共轭转置R.’
&gt;&gt; [1 2].' ans = 1 2 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6035141f1a8c5c33c157e0b5bcb8217/" rel="bookmark">
			标签传播算法（Label Propagation）及Python实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		标签传播算法（Label Propagation）及Python实现
zouxy09@qq.com
http://blog.csdn.net/zouxy09
众所周知，机器学习可以大体分为三大类：监督学习、非监督学习和半监督学习。监督学习可以认为是我们有非常多的labeled标注数据来train一个模型，期待这个模型能学习到数据的分布，以期对未来没有见到的样本做预测。那这个性能的源头--训练数据，就显得非常感觉。你必须有足够的训练数据，以覆盖真正现实数据中的样本分布才可以，这样学习到的模型才有意义。那非监督学习就是没有任何的labeled数据，就是平时所说的聚类了，利用他们本身的数据分布，给他们划分类别。而半监督学习，顾名思义就是处于两者之间的，只有少量的labeled数据，我们试图从这少量的labeled数据和大量的unlabeled数据中学习到有用的信息。
一、半监督学习
半监督学习（Semi-supervised learning）发挥作用的场合是：你的数据有一些有label，一些没有。而且一般是绝大部分都没有，只有少许几个有label。半监督学习算法会充分的利用unlabeled数据来捕捉我们整个数据的潜在分布。它基于三大假设：
1）Smoothness平滑假设：相似的数据具有相同的label。
2）Cluster聚类假设：处于同一个聚类下的数据具有相同label。
3）Manifold流形假设：处于同一流形结构下的数据具有相同label。
例如下图，只有两个labeled数据，如果直接用他们来训练一个分类器，例如LR或者SVM，那么学出来的分类面就是左图那样的。如果现实中，这个数据是右图那边分布的话，猪都看得出来，左图训练的这个分类器烂的一塌糊涂、惨不忍睹。因为我们的labeled训练数据太少了，都没办法覆盖我们未来可能遇到的情况。但是，如果右图那样，把大量的unlabeled数据（黑色的）都考虑进来，有个全局观念，牛逼的算法会发现，哎哟，原来是两个圈圈（分别处于两个圆形的流形之上）！那算法就很聪明，把大圈的数据都归类为红色类别，把内圈的数据都归类为蓝色类别。因为，实践中，labeled数据是昂贵，很难获得的，但unlabeled数据就不是了，写个脚本在网上爬就可以了，因此如果能充分利用大量的unlabeled数据来辅助提升我们的模型学习，这个价值就非常大。
半监督学习算法有很多，下面我们介绍最简单的标签传播算法（label propagation），最喜欢简单了，哈哈。
二、标签传播算法
标签传播算法（label propagation）的核心思想非常简单：相似的数据应该具有相同的label。LP算法包括两大步骤：1）构造相似矩阵；2）勇敢的传播吧。
2.1、相似矩阵构建
LP算法是基于Graph的，因此我们需要先构建一个图。我们为所有的数据构建一个图，图的节点就是一个数据点，包含labeled和unlabeled的数据。节点i和节点j的边表示他们的相似度。这个图的构建方法有很多，这里我们假设这个图是全连接的，节点i和节点j的边权重为：
这里，α是超参。
还有个非常常用的图构建方法是knn图，也就是只保留每个节点的k近邻权重，其他的为0，也就是不存在边，因此是稀疏的相似矩阵。
2.2、LP算法
标签传播算法非常简单：通过节点之间的边传播label。边的权重越大，表示两个节点越相似，那么label越容易传播过去。我们定义一个NxN的概率转移矩阵P：
Pij表示从节点i转移到节点j的概率。假设有C个类和L个labeled样本，我们定义一个LxC的label矩阵YL，第i行表示第i个样本的标签指示向量，即如果第i个样本的类别是j，那么该行的第j个元素为1，其他为0。同样，我们也给U个unlabeled样本一个UxC的label矩阵YU。把他们合并，我们得到一个NxC的soft label矩阵F=[YL;YU]。soft label的意思是，我们保留样本i属于每个类别的概率，而不是互斥性的，这个样本以概率1只属于一个类。当然了，最后确定这个样本i的类别的时候，是取max也就是概率最大的那个类作为它的类别的。那F里面有个YU，它一开始是不知道的，那最开始的值是多少？无所谓，随便设置一个值就可以了。
千呼万唤始出来，简单的LP算法如下：
1）执行传播：F=PF
2）重置F中labeled样本的标签：FL=YL
3）重复步骤1）和2）直到F收敛。
步骤1）就是将矩阵P和矩阵F相乘，这一步，每个节点都将自己的label以P确定的概率传播给其他节点。如果两个节点越相似（在欧式空间中距离越近），那么对方的label就越容易被自己的label赋予，就是更容易拉帮结派。步骤2）非常关键，因为labeled数据的label是事先确定的，它不能被带跑，所以每次传播完，它都得回归它本来的label。随着labeled数据不断的将自己的label传播出去，最后的类边界会穿越高密度区域，而停留在低密度的间隔中。相当于每个不同类别的labeled样本划分了势力范围。
2.3、变身的LP算法
我们知道，我们每次迭代都是计算一个soft label矩阵F=[YL;YU]，但是YL是已知的，计算它没有什么用，在步骤2）的时候，还得把它弄回来。我们关心的只是YU，那我们能不能只计算YU呢？Yes。我们将矩阵P做以下划分：
这时候，我们的算法就一个运算：
迭代上面这个步骤直到收敛就ok了，是不是很cool。可以看到FU不但取决于labeled数据的标签及其转移概率，还取决了unlabeled数据的当前label和转移概率。因此LP算法能额外运用unlabeled数据的分布特点。
这个算法的收敛性也非常容易证明，具体见参考文献[1]。实际上，它是可以收敛到一个凸解的：
所以我们也可以直接这样求解，以获得最终的YU。但是在实际的应用过程中，由于矩阵求逆需要O(n3)的复杂度，所以如果unlabeled数据非常多，那么I – PUU矩阵的求逆将会非常耗时，因此这时候一般选择迭代算法来实现。
三、LP算法的Python实现
Python环境的搭建就不啰嗦了，可以参考前面的博客。需要额外依赖的库是经典的numpy和matplotlib。代码中包含了两种图的构建方法：RBF和KNN指定。同时，自己生成了两个toy数据库：两条长形形状和两个圈圈的数据。第四部分我们用大点的数据库来做实验，先简单的可视化验证代码的正确性，再前线。
算法代码：
#*************************************************************************** #* #* Description: label propagation #* Author: Zou Xiaoyi (zouxy09@qq.com) #* Date: 2015-10-15 #* HomePage: http://blog.csdn.net/zouxy09 #* #************************************************************************** import time import numpy as np # return k neighbors index def navie_knn(dataSet, query, k): numSamples = dataSet.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d6035141f1a8c5c33c157e0b5bcb8217/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f75b4c00383acd6eb5b766f39f4add0/" rel="bookmark">
			Cpp--字符串快速查找运用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于c++中字符操作，在c中已经有了完整强大的操作函数，首先从一个函数说起：c_str()。
const char *c_str(); c_str()函数返回一个指向正规C字符串的指针, 内容与本string串相同. 这是为了与c语言兼容，在c语言中没有string类型，故必须通过string类对象的成员函数c_str()把string 对象转换成c中的字符串样式。 注意：一定要使用strcpy()函数 等来操作方法c_str()返回的指针 使用这个函数可以接近许多c中头文件已经定义的函数; 1）字符串操作 strcpy(p, p1) 复制字符串 strncpy(p, p1, n) 复制指定长度字符串 strcat(p, p1) 附加字符串 strncat(p, p1, n) 附加指定长度字符串 strlen(p) 取字符串长度 strcmp(p, p1) 比较字符串 strcasecmp忽略大小写比较字符串
strncmp(p, p1, n) 比较指定长度字符串 strchr(p, c) 在字符串中查找指定字符 strrchr(p, c) 在字符串中反向查找 strstr(p, p1) 查找字符串 strpbrk(p, p1) 以目标字符串的所有字符作为集合，在当前字符串查找该集合的任一元素 strspn(p, p1) 以目标字符串的所有字符作为集合，在当前字符串查找不属于该集合的任一元素的偏移 strcspn(p, p1) 以目标字符串的所有字符作为集合，在当前字符串查找属于该集合的任一元素的偏移 * 具有指定长度的字符串处理函数在已处理的字符串之后填补零结尾符 2）字符串到数值类型的转换 strtod(p, ppend) 从字符串 p 中转换 double 类型数值，并将后续的字符串指针存储到 ppend 指向的 char* 类型存储。
strtol(p, ppend, base) 从字符串 p 中转换 long 类型整型数值，base 显式设置转换的整型进制，设置为 0 以根据特定格式判断所用进制，0x, 0X 前缀以解释为十六进制格式整型，0 前缀以解释为八进制格式整型
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f75b4c00383acd6eb5b766f39f4add0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d0933dceb844a773de87e8fc76b9a17/" rel="bookmark">
			onAttachedToWindow()在整个Activity生命周期的位置及使用 .
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上篇博客实现圆角对话框样式的Activity中提到，若需实现圆角对话框Activity，需要在Activity的onAttachedToWindow()函数中做文章，那么就想问：
onAttachedToWindow在整个Activity的生命周期中占据什么位置? 为什么要在onAttachedToWindow中修改窗口尺寸？ 一、onAttachedToWindow在Activity生命周期中的位置
根据之前分析API的套路，看onAttachedToWindow在Android文档中怎样介绍。
首先看Window.Callback中关于onAttachedToWindow的介绍。
public abstract void onAttachedToWindow () Called when the window has been attached to the window manager. See View.onAttachedToWindow() for more information.
好吧，官方把我引导到了View中，那么恭敬不如从命，看View中怎么说。
protected void onAttachedToWindow () This is called when the view is attached to a window. At this point it has a Surface and will start drawing. Note that this function is guaranteed to be called beforeonDraw(android.graphics.Canvas), however it may be called any time before the first onDraw -- including before or after onMeasure(int, int).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d0933dceb844a773de87e8fc76b9a17/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0938ed0d8138fd2d8d5a153fa91e1204/" rel="bookmark">
			Android重写view时onAttachedToWindow () 和 onDetachedFromWindow () .
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在重写View的时候，会遇到这两个方法 protected void onAttachedToWindow()
Description copied from class: View This is called when the view is attached to a window. At this point it has a Surface and will start drawing. Note that this function is guaranteed to be called before View.onDraw(android.graphics.Canvas), however it may be called any time before the first onDraw -- including before or after View.onMeasure(int, int).
Overrides: onAttachedToWindow in class View
当此view附加到窗体上时调用该方法。在这时，view有了一个用于显示的Surface，将开始绘制。注意，此方法要保证在调用onDraw(Canvas) 之前调用，但可能在调用 onDraw(Canvas) 之前的任何时刻，包括调用 onMeasure(int, int) 之前或之后。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0938ed0d8138fd2d8d5a153fa91e1204/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c33f9b5f76b3854711aeda66c07502f2/" rel="bookmark">
			setDescendantFocusability,在父View和子View间处理焦点关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		android:descendantFocusability用法简析 开发中很常见的一个问题，项目中的listview不仅仅是简单的文字，常常需要自己定义listview，自己的Adapter去继承BaseAdapter，在adapter中按照需求进行编写，问题就出现了，可能会发生点击每一个item的时候没有反应，无法获取的焦点。原因多半是由于在你自己定义的Item中存在诸如ImageButton，Button，CheckBox等子控件(也可以说是Button或者Checkable的子类控件)，此时这些子控件会将焦点获取到，所以常常当点击item时变化的是子控件，item本身的点击没有响应。
这时候就可以使用descendantFocusability来解决啦，API描述如下：
android:descendantFocusability Defines the relationship between the ViewGroup and its descendants when looking for a View to take focus.
Must be one of the following constant values.
该属性是当一个为view获取焦点时，定义viewGroup和其子控件两者之间的关系。
属性的值有三种：
beforeDescendants：viewgroup会优先其子类控件而获取到焦点
afterDescendants：viewgroup只有当其子类控件不需要获取焦点时才获取焦点
blocksDescendants：viewgroup会覆盖子类控件而直接获得焦点
*******************************************************************************************************
这个函数是在ViewGroup里定义的，主要用于控制child View获取焦点的能力，比如是否阻止child View获取焦点。
他有三个常量可供设置
FOCUS_BEFORE_DESCENDANTS ViewGroup本身先对焦点进行处理，如果没有处理则分发给child View进行处理FOCUS_AFTER_DESCENDANTS 先分发给Child View进行处理，如果所有的Child View都没有处理，则自己再处理FOCUS_BLOCK_DESCENDANTS ViewGroup本身进行处理，不管是否处理成功，都不会分发给ChildView进行处理 我们看下这个方法的实现 Setdescendantfocusability(int focusability)代码 public void setDescendantFocusability(int focusability) { switch (focusability) { case FOCUS_BEFORE_DESCENDANTS: case FOCUS_AFTER_DESCENDANTS: case FOCUS_BLOCK_DESCENDANTS: break; default: throw new IllegalArgumentException("must be one of FOCUS_BEFORE_DESCENDANTS, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c33f9b5f76b3854711aeda66c07502f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d095bcff042c1b5b2fa75b774b7e15d/" rel="bookmark">
			图像卷积与滤波的一些知识点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图像卷积与滤波的一些知识点
zouxy09@qq.com
http://blog.csdn.net/zouxy09
之前在学习CNN的时候，有对卷积进行一些学习和整理，后来就烂尾了，现在稍微整理下，先放上来，以提醒和交流。
一、线性滤波与卷积的基本概念
线性滤波可以说是图像处理最基本的方法，它可以允许我们对图像进行处理，产生很多不同的效果。做法很简单。首先，我们有一个二维的滤波器矩阵（有个高大上的名字叫卷积核）和一个要处理的二维图像。然后，对于图像的每一个像素点，计算它的邻域像素和滤波器矩阵的对应元素的乘积，然后加起来，作为该像素位置的值。这样就完成了滤波过程。
对图像和滤波矩阵进行逐个元素相乘再求和的操作就相当于将一个二维的函数移动到另一个二维函数的所有位置，这个操作就叫卷积或者协相关。卷积和协相关的差别是，卷积需要先对滤波矩阵进行180的翻转，但如果矩阵是对称的，那么两者就没有什么差别了。
Correlation 和 Convolution可以说是图像处理最基本的操作，但却非常有用。这两个操作有两个非常关键的特点：它们是线性的，而且具有平移不变性shift-invariant。平移不变性指我们在图像的每个位置都执行相同的操作。线性指这个操作是线性的，也就是我们用每个像素的邻域的线性组合来代替这个像素。这两个属性使得这个操作非常简单，因为线性操作是最简单的，然后在所有地方都做同样的操作就更简单了。
实际上，在信号处理领域，卷积有广泛的意义，而且有其严格的数学定义，但在这里不关注这个。
2D卷积需要4个嵌套循环4-double loop，所以它并不快，除非我们使用很小的卷积核。这里一般使用3x3或者5x5。而且，对于滤波器，也有一定的规则要求：
1）滤波器的大小应该是奇数，这样它才有一个中心，例如3x3，5x5或者7x7。有中心了，也有了半径的称呼，例如5x5大小的核的半径就是2。
2）滤波器矩阵所有的元素之和应该要等于1，这是为了保证滤波前后图像的亮度保持不变。当然了，这不是硬性要求了。
3）如果滤波器矩阵所有元素之和大于1，那么滤波后的图像就会比原图像更亮，反之，如果小于1，那么得到的图像就会变暗。如果和为0，图像不会变黑，但也会非常暗。
4）对于滤波后的结构，可能会出现负数或者大于255的数值。对这种情况，我们将他们直接截断到0和255之间即可。对于负数，也可以取绝对值。
二、神奇的卷积核
上面说到，对图像的滤波处理就是对图像应用一个小小的卷积核，那这个小小的卷积核到底有哪些魔法，能让一个图像从惨不忍睹变得秀色可餐。下面我们一起来领略下一些简单但不简单的卷积核的魔法。
2.1、啥也不做
哈哈，大家可以看到啥了吗？这个滤波器啥也没有做，得到的图像和原图是一样的。因为只有中心点的值是1。邻域点的权值都是0，对滤波后的取值没有任何影响。
下面我们动点真格的。
2.2、图像锐化滤波器Sharpness Filter
图像的锐化和边缘检测很像，首先找到边缘，然后把边缘加到原来的图像上面，这样就强化了图像的边缘，使图像看起来更加锐利了。这两者操作统一起来就是锐化滤波器了，也就是在边缘检测滤波器的基础上，再在中心的位置加1，这样滤波后的图像就会和原始的图像具有同样的亮度了，但是会更加锐利。
我们把核加大，就可以得到更加精细的锐化效果
另外，下面的滤波器会更强调边缘：
主要是强调图像的细节。最简单的3x3的锐化滤波器如下：
实际上是计算当前点和周围点的差别，然后将这个差别加到原来的位置上。另外，中间点的权值要比所有的权值和大于1，意味着这个像素要保持原来的值。
2.3、边缘检测Edge Detection
我们要找水平的边缘：需要注意的是，这里矩阵的元素和是0，所以滤波后的图像会很暗，只有边缘的地方是有亮度的。
为什么这个滤波器可以寻找到水平边缘呢？因为用这个滤波器卷积相当于求导的离散版本：你将当前的像素值减去前一个像素值，这样你就可以得到这个函数在这两个位置的差别或者斜率。下面的滤波器可以找到垂直方向的边缘，这里像素上和下的像素值都使用：
再下面这个滤波器可以找到45度的边缘：取-2不为了什么，只是为了让矩阵的元素和为0而已。
那下面这个滤波器就可以检测所有方向的边缘:
为了检测边缘，我们需要在图像对应的方向计算梯度。用下面的卷积核来卷积图像，就可以了。但在实际中，这种简单的方法会把噪声也放大了。另外，需要注意的是，矩阵所有的值加起来要是0.
2.4、浮雕Embossing Filter
浮雕滤波器可以给图像一种3D阴影的效果。只要将中心一边的像素减去另一边的像素就可以了。这时候，像素值有可能是负数，我们将负数当成阴影，将正数当成光，然后我们对结果图像加上128的偏移。这时候，图像大部分就变成灰色了。
下面是45度的浮雕滤波器
我们只要加大滤波器，就可以得到更加夸张的效果了
这种效果非常的漂亮，就像是将一副图像雕刻在一块石头上面一样，然后从一个方向照亮它。它和前面的滤波器不同，它是非对称的。另外，它会产生负数值，所以我们需要将结果偏移，以得到图像灰度的范围。
A：原图像。B：锐化。C：边缘检测。D：浮雕
2.5、均值模糊Box Filter (Averaging)
我们可以将当前像素和它的四邻域的像素一起取平均，然后再除以5，或者直接在滤波器的5个地方取0.2的值即可，如下图：
可以看到，这个模糊还是比较温柔的，我们可以把滤波器变大，这样就会变得粗暴了：注意要将和再除以13.
所以，如果你想要更模糊的效果，加大滤波器的大小即可。或者对图像应用多次模糊也可以。
2.6、高斯模糊
均值模糊很简单，但不是很平滑。高斯模糊就有这个优点，所以被广泛用在图像降噪上。特别是在边缘检测之前，都会用来移除细节。高斯滤波器是一个低通滤波器。
2.7、运动模糊Motion Blur
运动模糊可以通过只在一个方向模糊达到，例如下面9x9的运动模糊滤波器。注意，求和结果要除以9。
这个效果就好像，摄像机是从左上角移动的右下角。
三、卷积的计算
对图像处理而言，存在两大类的方法：空域处理和频域处理！空域处理是指直接对原始的像素空间进行计算，频率处理是指先对图像变换到频域，再做滤波等处理。
3.1、空域计算-直接2D卷积
3.1.1、2D卷积
直接2D卷积就是一开始说的那样，对于图像的每一个像素点，计算它的邻域像素和滤波器矩阵的对应元素的乘积，然后加起来，作为该像素位置的值。
直接的实现也称为暴力实现brute force，因为它严格按照定义来实现，没有任何优化。当然了，在并行实现里面，它也是比较灵活的。另外，也存在一个优化版本，如果我们的kernel是separable可分的，那么就可以得到一个快5倍左右的卷积方法。
2.1.2、边界处理
那卷积核遇到图像边缘怎么办？例如图像顶部的像素，它的上面已经没有像素了，那么它的值如何计算？目前有四种主流的处理方法，我们用一维卷积和均值滤波来说明下。
我们在1D图像中，用每个像素和它的二邻域的平均值来取代它的值。假设我们有个1D的图像I是这样的：
对非图像边界的像素的操作比较简单。假设我们对I的第四个像素3做局部平均。也就是我们用2,3和7做平均，来取代这个位置的像素值。也就是，平均会产生一副新的图像J，这个图像在相同位置J (4) = (I(3)+I(4)+I(5))/3 = (2+3+7)/3 = 4。同样，我们可以得到J(3) = (I(2)+I(3)+I(4))/3 =(4+2+3)/3 = 3。需要注意的是，新图像的每个像素都取决于旧的图像，在计算J (4)的时候用J (3)是不对的，而是用I(3)，I(4)和I(5)。所以每个像素都是它和它邻域两个像素的平均。平均是线性的操作，因为每个新的像素都是旧像素的线性组合。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d095bcff042c1b5b2fa75b774b7e15d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95a7da526f83b3e2508e88cab47a82f0/" rel="bookmark">
			discuz论坛图片无法显示之图片流问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在迁一个discuz论坛的时候，发现迁到另一个服务器上时候，图片都无法显示，缓存中都找得到图片，可以显示。在论坛系统设置中找了很久，没找到问题，就马上在iis服务器上找图片那个文件夹的权限，设置权限弄了好久，还是没弄好。最后自己又新装了一个论坛，发现图片路径都是xxx.aspx?linkid=xxx，原来图片不是直接路径，而是程序路径。
到自己论坛上看，显示的都是直接路径，所以马上反应过来去轮胎后台设置为显示程序路径。然后图片马上显示出来了。
然后看了一下，大多数网站，图片显示的都是通过二进制流或其他输入流来显示图片，而不是采用直接路径。但是也没找到两者差距。个人猜测应该是便于处理图片，裁剪、压缩等等，还有安全性问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a46bf5ff13ecf8e2d40c02848d8e167/" rel="bookmark">
			PAT1030 完美数列(25)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		给定一个正整数数列，和正整数p，设这个数列中的最大值是M，最小值是m，如果M &lt;= m * p，则称这个数列是完美数列。
现在给定参数p和一些正整数，请你从中选择尽可能多的数构成一个完美数列。
输入格式：
输入第一行给出两个正整数N和p，其中N（&lt;= 105）是输入的正整数的个数，p（&lt;= 109）是给定的参数。第二行给出N个正整数，每个数不超过109。
输出格式：
在一行中输出最多可以选择多少个数可以用它们组成一个完美数列。
输入样例： 10 8 2 3 20 4 5 1 6 7 8 9 输出样例： 8
一，找出数组中的最大值
int MaxPAT(int list[], int len){ int mx = list[0]; for (int i = 0; i &lt; len; ++i){ if (mx &lt; list[i]){ mx = list[i]; } } return mx; } 二，找出数组中最小值
int MinPAT(int list[], int len){ int mx = list[0]; for (int i = 0; i &lt; len; ++i){ if (mx &gt; list[i]){ mx = list[i]; } } return mx; } 三，主函数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a46bf5ff13ecf8e2d40c02848d8e167/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9cab281c6812da3ddd698b6c7d51c330/" rel="bookmark">
			传奇私服中检查人物穿戴指定装备的两种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在传奇私服中检查人物是否穿戴指定的装备，方法有两种，一种是使用GetUserItemName命令，另一种则是使用CHECKITEMW命令，这两个命令实现的功能都是一样的。
GetUserItemName 语法格式：GetUserItemName 装备位置(0-12) S变量(0-99)
命令含义：获取人物特定的装备栏位的装备名称，并将该装备名称赋值给一个游戏人物私有变量，以备用。
装备位置：
0：盔甲1：武器2：照明物（如蜡烛、勋章）3：项链4：头盔5：右手镯6：左手镯7：右戒指8：左戒指9：无（道士职业的话就是放毒、符那个位置）10：腰带11：鞋子12：宝石
S变量：游戏中的人物私有变量，共有编号0—99的100个可用变量，例如S1、S10、S88。
例子：获取人物的武器名称，并存入S10变量中
[@GetWeaponName] #IF #ACT GetUserItemName 1 10 ;SendMsg 5 武器的名字: &lt;$STR(S10)&gt; GOTO @是否手持屠龙 [@是否手持屠龙] #IF EQUAL S10 屠龙 #ACT messagebox 你已经手持屠龙刀了，威风无比啊！ #ELSEACT messagebox 你无屠龙刀！ CHECKITEMW 语法格式：CHECKITEMW 物品名称 [物品数量]
命令含义：查看人物所佩带装备中是否含有指定数量的装备， 该数量不写的话默认为1，即检查有没有该物品。 例子：检查人物是否装备了屠龙刀
[@是否手持屠龙] #IF CHECKITEMW 屠龙 #ACT messagebox 你已经手持屠龙刀了，威风无比啊！ #ELSEACT messagebox 你无屠龙刀！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b65b54a3311aad2abc9edc83dfb385c/" rel="bookmark">
			不定宽高的水平垂直居中实现方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 对于CSS3开发而言，不定宽高的水平垂直居中是我们经常要用到得，实现方式也有很多，下面给大家介绍一下我在众多项目中的一些实现方案，希望对大家有所帮助。
方案一：
.wraper{
position:absolute;
top:50%;
left:50%;
-webkit-transform:translate(-50%,-50%);
}
方案二：
.wraper{
display:-webkit-flex;
justify-content:center; //水平居中
align-items:center; //垂直居中
}
方案三：
.detailTitle{ width:100%; font-weight: bold; min-height:@defaultHeaderHeight; background: #F5F5F5; display:table; span{ width:100%; display:table-cell; vertical-align:middle; line-height:1; font-size:@defaultTextSize - 5px; text-align: center; } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a99f365e5434330681b7dddf9a01ad65/" rel="bookmark">
			archlinux 时间同步问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		装完archlinux，时间总是比实际快了8个小时，找了各种办法，最终使用了openNTPD的方法
设置时区：sudo ln sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime
安装openNTPD：sudo pacman -S openntpd
重启openNTPD：systemctl restart openntpd
设置开机启动：systemctl enable openntpd
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa437045c12422d29ef9521d65b8d488/" rel="bookmark">
			Python多核编程mpi4py实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python多核编程mpi4py实践
zouxy09@qq.com
http://blog.csdn.net/zouxy09
一、概述
CPU从三十多年前的8086，到十年前的奔腾，再到当下的多核i7。一开始，以单核cpu的主频为目标，架构的改良和集成电路工艺的进步使得cpu的性能高速上升，单核cpu的主频从老爷车的MHz阶段一度接近4GHz高地。然而，也因为工艺和功耗等的限制，单核cpu遇到了人生的天花板，急需转换思维，以满足无止境的性能需求。多核cpu在此登上历史舞台。给你的老爷车多加两个引擎，让你有法拉利的感觉。现时代，连手机都到处叫嚣自己有4核8核处理器的时代，PC就更不用说了。
扯远了，anyway，对于俺们程序员来说，如何利用如此强大的引擎完成我们的任务才是我们要考虑的。随着大规模数据处理、大规模问题和复杂系统求解需求的增加，以前的单核编程已经有心无力了。如果程序一跑就得几个小时，甚至一天，想想都无法原谅自己。那如何让自己更快的过度到高大上的多核并行编程中去呢？哈哈，广大人民的力量！
目前工作中我所接触到的并行处理框架主要有MPI、OpenMP和MapReduce(Hadoop)三个（CUDA属于GPU并行编程，这里不提及）。MPI和Hadoop都可以在集群中运行，而OpenMP因为共享存储结构的关系，不能在集群上运行，只能单机。另外，MPI可以让数据保留在内存中，可以为节点间的通信和数据交互保存上下文，所以能执行迭代算法，而Hadoop却不具有这个特性。因此，需要迭代的机器学习算法大多使用MPI来实现。当然了，部分机器学习算法也是可以通过设计使用Hadoop来完成的。（浅见，如果错误，希望各位不吝指出，谢谢）。
本文主要介绍Python环境下MPI编程的实践基础。
二、MPI与mpi4py
MPI是Message Passing Interface的简称，也就是消息传递。消息传递指的是并行执行的各个进程具有自己独立的堆栈和代码段，作为互不相关的多个程序独立执行，进程之间的信息交互完全通过显示地调用通信函数来完成。
Mpi4py是构建在mpi之上的python库，使得python的数据结构可以在进程（或者多个cpu）之间进行传递。
2.1、MPI的工作方式
很简单，就是你启动了一组MPI进程，每个进程都是执行同样的代码！然后每个进程都有一个ID，也就是rank来标记我是谁。什么意思呢？假设一个CPU是你请的一个工人，共有10个工人。你有100块砖头要搬，然后很公平，让每个工人搬10块。这时候，你把任务写到一个任务卡里面，让10个工人都执行这个任务卡中的任务，也就是搬砖！这个任务卡中的“搬砖”就是你写的代码。然后10个CPU执行同一段代码。需要注意的是，代码里面的所有变量都是每个进程独有的，虽然名字相同。
例如，一个脚本test.py，里面包含以下代码：
from mpi4py import MPI print("hello world'') print("my rank is: %d" %MPI.rank) 然后我们在命令行通过以下方式运行： #mpirun –np 5 python test.py
-np5 指定启动5个mpi进程来执行后面的程序。相当于对脚本拷贝了5份，每个进程运行一份，互不干扰。在运行的时候代码里面唯一的不同，就是各自的rank也就是ID不一样。所以这个代码就会打印5个hello world和5个不同的rank值，从0到4.
2.2、点对点通信
点对点通信（Point-to-PointCommunication）的能力是信息传递系统最基本的要求。意思就是让两个进程直接可以传输数据，也就是一个发送数据，另一个接收数据。接口就两个，send和recv，来个例子：
import mpi4py.MPI as MPI comm = MPI.COMM_WORLD comm_rank = comm.Get_rank() comm_size = comm.Get_size() # point to point communication data_send = [comm_rank]*5 comm.send(data_send,dest=(comm_rank+1)%comm_size) data_recv =comm.recv(source=(comm_rank-1)%comm_size) print("my rank is %d, and Ireceived:" % comm_rank) print data_recv 启动5个进程运行以上代码，结果如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa437045c12422d29ef9521d65b8d488/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d4fd0d3ecd2418e34e97b5f404fe608/" rel="bookmark">
			SetWindowPos &amp;&amp; FindWindowA
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SetWindowPos
SetWindowPos函数改变一个子窗口，弹出式窗口或顶层窗口的尺寸，位置和Z序。子窗口，弹出式窗口，及顶层窗口根据它们在屏幕上出现的顺序排序、顶层窗口设置的级别最高，并且被设置为Z序的第一个窗口。
函数原型
BOOL SetWindowPos(HWND hWnd, const CWnd* pWndInsertAfter, int x, int y,int cx, int cy, UINT nFlags);
参数 hWnd
窗口句柄。
hWndlnsertAfter
在z序中的位于被置位的窗口前的窗口句柄。该参数必须为一个窗口句柄，或下列值之一：
HWND_BOTTOM：将窗口置于Z序的底部。如果参数hWnd标识了一个顶层窗口，则窗口失去顶级位置，并且被置在其他窗口的底部。
HWND_NOTOPMOST：将窗口置于所有非顶层窗口之上（即在所有顶层窗口之后）。如果窗口已经是非顶层窗口则该标志不起作用。
HWND_TOP:将窗口置于Z序的顶部。
HWND_TOPMOST:将窗口置于所有非顶层窗口之上。即使窗口未被激活窗口也将保持顶级位置。
查看该参数的使用方法，请看说明部分。
x
以客户坐标指定窗口新位置的左边界。
Y
以客户坐标指定窗口新位置的顶边界。
cx
以像素指定窗口的新的宽度。
cy
以像素指定窗口的新的高度。
uFlags
窗口尺寸和定位的标志。该参数可以是下列值的组合：
SWP_ASYNCWINDOWPOS：如果调用进程不拥有窗口，系统会向拥有窗口的线程发出需求。这就防止调用线程在其他线程处理需求的时候发生死锁。
SWP_DEFERERASE：防止产生WM_SYNCPAINT消息。
SWP_DRAWFRAME：在窗口周围画一个边框（定义在窗口类描述中）。
SWP_FRAMECHANGED：给窗口发送WM_NCCALCSIZE消息，即使窗口尺寸没有改变也会发送该消息。如果未指定这个标志，只有在改变了窗口尺寸时才发送WM_NCCALCSIZE。
SWP_HIDEWINDOW;隐藏窗口。
SWP_NOACTIVATE：不激活窗口。如果未设置标志，则窗口被激活，并被设置到其他最高级窗口或非最高级组的顶部（根据参数hWndlnsertAfter设置）。
SWP_NOCOPYBITS：清除客户区的所有内容。如果未设置该标志，客户区的有效内容被保存并且在窗口尺寸更新和重定位后拷贝回客户区。
SWP_NOMOVE：维持当前位置（忽略X和Y参数）。
SWP_NOOWNERZORDER：不改变z序中的所有者窗口的位置。
SWP_NOREDRAW:不重画改变的内容。如果设置了这个标志，则不发生任何重画动作。适用于客户区和非客户区（包括标题栏和滚动条）和任何由于窗回移动而露出的父窗口的所有部分。如果设置了这个标志，应用程序必须明确地使窗口无效并区重画窗口的任何部分和父窗口需要重画的部分。
SWP_NOREPOSITION：与SWP_NOOWNERZORDER标志相同。
SWP_NOSENDCHANGING：防止窗口接收WM_WINDOWPOSCHANGING消息。
SWP_NOSIZE：维持当前尺寸（忽略cx和Cy参数）。
SWP_NOZORDER：维持当前Z序（忽略hWndlnsertAfter参数）。
SWP_SHOWWINDOW：显示窗口。
返回值 如果函数成功，返回值为非零；如果函数失败，返回值为零。若想获得更多错误消息，请调用GetLastError函数。 FindWindowA 这个函数检索处理顶级窗口的类名和窗口名称匹配指定的字符串, 这个函数不搜索子窗口。 函数原型
HWND FindWindow ( LPCSTR lpClassName , LPCSTR lpWindowName ); 参数 lpClassName 指向一个以null结尾的、用来指定类名的字符串或一个可以确定类名字符串的原子。如果这个参数是一个原子，那么它必须是一个在调用此函数前已经通过GlobalAddAtom函数创建好的 全局原子。这个原子（一个16bit的值），必须被放置在lpClassName的低位 字节中，lpClassName的高位字节置零。 如果该参数为null时，将会寻找任何与lpWindowName参数匹配的窗口。 lpWindowName 指向一个以null结尾的、用来指定窗口名（即窗口标题）的字符串。如果此参数为NULL，则匹配所有窗口名。 返回值 如果函数执行成功，则返回值是拥有指定窗口类名或窗口名的窗口的句柄。 如果函数执行失败，则返回值为 NULL 。可以通过调用GetLastError函数获得更加详细的错误信息。 应用实例 利用spy++ 工具查找QQ的窗口名和类名如下图所示： #include "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d4fd0d3ecd2418e34e97b5f404fe608/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a80adb6ae336fd7e69e37fa5ecf19d2b/" rel="bookmark">
			[Android通信]基于socket的聊天app(四)：实现一对一通信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要实现一对一通信，要解决两个问题：
1.发送消息时，要找到对方在服务器端的socket，然后在输出流输出消息。这样，对方的客户端输入流就会收到消息了。所以问题就是如何找到对方在服务器端的socket。
解决方法：在客户端登录时将服务器端socket和账号关联起来，用一个HashMap存储起来。当发送消息时，同时发送对方的账号就可以了。
2.接受消息时，要把消息显示在相应的窗口中。群聊的消息不能出现在通信双方的聊天窗口那里，而通信双方的消息也不能出现在群聊的窗口里。当消息送到对方的客户端时，对方可能已经打开了多个聊天窗口，那么就要解决消息要送到哪个窗口。
解决方法：每条聊天消息包含三部分内容，fromID，content，toID，表示发送方，内容，接受方，而每个聊天窗口有一个toID，且在打开时初始化，表示在这个窗口输入的东西会发给谁。这样就可以让聊天窗口挑选信息进行显示了。
同时，还有注意的是，因为app中有多个聊天窗口，在退出某个聊天窗口时，消息记录肯定是不能删除的，所以这里我选择了fragment，退出聊天窗口时隐藏即可。
由于截图不能说明些啥，所以没了！这里给出核心代码：
服务器端：
import java.io.BufferedReader; import java.io.BufferedWriter; import java.io.IOException; import java.io.InputStreamReader; import java.io.OutputStreamWriter; import java.io.UnsupportedEncodingException; import java.net.Socket; import org.json.JSONException; import org.json.JSONObject; public class ChatSocket extends Thread{ private Socket socket; private BufferedWriter bWriter; private BufferedReader bReader; public ChatSocket (Socket socket) { this.socket = socket; try { bWriter = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream(),"UTF-8")); bReader = new BufferedReader(new InputStreamReader(socket.getInputStream(),"UTF-8")); } catch (IOException e) { e.printStackTrace(); }	} public void out(String s) { s += "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a80adb6ae336fd7e69e37fa5ecf19d2b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b86620f883c59816c74167aaf3cd889c/" rel="bookmark">
			AVDD和DVDD
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AVCC：模拟部分电源供电；AGND：模拟地
DVCC：数字部分电源供电；DGND：数字地
这样区分是为了将数字部分和模拟部分隔离开，减小数字部分带给模拟电路部分的干扰。但这两部分不可能完全隔离开，
数字部分和模拟部分之间是有连接的所以，在供电时至少地应该是在一起的，所以AGND和DGND之间要用0欧姆的电阻或磁
珠或电感连接起来，这样的一点连接就能够减小干扰。同样，如果两部分的供电电源相同也应该采用这样的接法。 建议AVDD和DVDD分开单独供电，至于DGND和AGND应单点接地，可采用如3homer 友所说的磁珠连接、电感连接或者0欧姆电阻连接。
只是需要注意，磁珠的等效电路相当于带阻限波器，只对某一频点的噪声有明显地抑制作用，使用时需要预先估计噪生频率，以选用
适当规格型号。对于频率不确定或无法预知的情况，无可适从。同样，电感体积较大，杂散参数多，存在不稳定因素。0欧电阻相当于
很窄的电流通路，一定程度上可有效地限制环路电流，使噪声得到抑制。电阻在所有频带上都有衰减作用（应明白，0欧电阻也有阻抗），
这点比磁珠强。当然，这个电阻最好选用0欧贴片电阻。供参考。
转自：http://blog.sina.com.cn/s/blog_66399965010179jb.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f68b6a13033a8d248fc079c8ec2e2deb/" rel="bookmark">
			Android Material Design ：LinearLayoutCompat添加分割线divider
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		﻿﻿ Android Material Design ：LinearLayoutCompat添加分割线divider
Android Material Design 扩展支持包中的LinearLayoutCompat是过去的LinearLayout的扩展，可以为此布局中功德子View之间添加分割线divider。
其中比较关键的地方有两点：
（1）app:showDividers="beginning|middle|end"属性。
beginning，middle，end属性值分别指明将在何处添加分割线。
beginning表示从该LinearLayoutCompat布局的最顶一个子view的顶部开始。
middle表示在此LinearLayoutCompat布局内的子view之间添加。
end表示在此LinearLayoutCompat最后一个子view的底部添加分割线。
（2）app:divider="@drawable/line"
LinearLayoutCompat添加分割线需要为此分割线定义一个shape。
现给出一个例子加以说明。
&lt;android.support.v7.widget.LinearLayoutCompat xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" android:layout_width="match_parent" android:layout_height="match_parent" android:padding="20dip" android:orientation="vertical" app:divider="@drawable/line" app:dividerPadding="5dp" app:showDividers="beginning|middle|end" &gt; &lt;TextView android:layout_width="match_parent" android:layout_height="wrap_content" android:gravity="center" android:text="CSDN Zhang Phil" /&gt; &lt;ImageView android:layout_width="match_parent" android:layout_height="wrap_content" android:gravity="center" android:src="@drawable/ic_launcher"/&gt; &lt;TextView android:layout_width="match_parent" android:layout_height="wrap_content" android:gravity="center" android:text="CSDN Zhang Phil" /&gt; &lt;ImageView android:layout_width="match_parent" android:layout_height="wrap_content" android:gravity="center" android:src="@drawable/ic_launcher"/&gt; &lt;TextView android:layout_width="match_parent" android:layout_height="wrap_content" android:gravity="center" android:text="CSDN Zhang Phil" /&gt; &lt;/android.support.v7.widget.LinearLayoutCompat&gt; 位于drawable目录下的line.xml文件（定义的分割线属性）
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;shape xmlns:android="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f68b6a13033a8d248fc079c8ec2e2deb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2dddc7a115ad905f191909165af08f4/" rel="bookmark">
			C&#43;&#43;头文件相互引用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求是：类A中使用B， 类B中使用A 常见错误用法 ------------------------A.h--------------------- #ifndef HEADER_AAA #define HEADER_AAA #include "B.h" class A { public: A(void); virtual ~A(void); private: B b; //正确,因为此处已经知道B类的大小,且定义了B,可以为b分配空间 }; #endif --------------------------A.cpp----------------- #include "A.h" A::A(void) { } A::~A(void) { } ---------------------------B.h--------------------- #ifndef HEADER_BBB #define HEADER_BBB #include "A.h" class B { f iend class A; //error public: B(void); virtual ~B(void); A func(A g);
A g; //error }; #endif --------------------------B.cpp----------------- #include "B.h" B::B(void) { } B::~B(void) { } A B::Func(A g) { A o; return o; } 经过VC编译发现，编译始终不过，error C2146: 语法错误 : 缺少“;” 原因：在预编译时，出现循环嵌套。(.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2dddc7a115ad905f191909165af08f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/055a5d3eb400a5ee499318c67f6f7f8e/" rel="bookmark">
			《深入理解Linux网络技术内幕》阅读笔记（八）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 net_device数据结构插入在一个全局列表和两张hash表中。这些不同的结构可让内核按要求浏览或查询net_device数据库。 1.dev_base：内含所有net_device实例的全局列表能够让内核轻易浏览设备。 2.dev_name_head:以设备名称为索引的hash表。 3.dev_index_head:以设备ID dev-&gt;ifindex为索引的hash表。 内核组件和用户空间应用程序可能想知道何时发生网络设备注册，除名，关闭或者开启之事。这类事件的通知通过两种通道传送的： 1.netdev_chain。内核组件可以注册此通知链。 2.Netlink的RTMGPR_LINK多播群组。用户空间应用程序可以注册Rtnetlink的RTMGPR_LINK多播群组。 unregister_netdevice结束时调用dev_put不足以使net_device实例有删除的资格，内核仍然必须等待，直到所有引用都释放为止。但是，因为该设备除名后就不再能用，内核必须通知所有引用持有者，使其能释放其引用。其做法是送出一个NETDEV_UNREGISTER通知信息给netdev_chain通知链。也就是说，引用持有者应该对通知链注册，否则就无法接收这类通知信息而据此采取行动了。 网卡在物理上具有载波侦听的功能，当网络连接完整或者网络链接断开时，网卡芯片硬件会自动设置寄存器标志位来标识。 当NIC设备驱动程序侦测载波或信号是否存在时，可以分别利用netif_carrier_on和netif_carrier_off通知内核。当载波状态有变时，就可以调用这些函数。 以下是可能导致链接状态变更的一些常见情况： 1.电缆线插入NIC，或者从NIC中拔除。 2.电缆线另一端的设备电源关掉或关闭了。这类设备有Hub，桥接器，路由器以及PC NIC等。 自动协商： 802．3标准中的第28条是这样定义自动协商功能的：它允许一个设备向链路远端的设备通告自己所运行的工作方式，并且侦测远端通告的相应的运 行方式。自动协商的目的是给共享一条链路的两台设备提供一种交换信息的方法，并自动配置它们工作在最优能力下。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c561592efaa08bf59f037eff79a7b1c/" rel="bookmark">
			Unity抛物线AddForce计算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/**findInitialVelocity * Finds the initial velocity of a projectile given the initial positions and some offsets * @param Vector3 startPosition - the starting position of the projectile * @param Vector3 finalPosition - the position that we want to hit * @param float maxHeightOffset (default=0.6f) - the amount we want to add to the height for short range shots. We need enough clearance so the * ball will be able to get over the rim before dropping into the target position * @param float rangeOffset (default=0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c561592efaa08bf59f037eff79a7b1c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/254cb9165cf0058348b9fc670ebcdffc/" rel="bookmark">
			用Java生成字符画
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ASCII码艺术是一种技术，它利用ASCII标准中的可打印字符来产生视觉艺术效果。在历史上它有其存在的目的，当时的打印机还无法打印图片，并且当时在邮件中嵌入图像还无法实现，所以它也用于邮件中。本文中，我将为你呈现一个非常简单的ASCII码艺术产生器，它由Java语言编写，并可以配置字体和对比度。因为该产生器是我在周末用几个小时创建的，所以它还不完美，但却是一个有趣的实验。在下面你可以看到实现代码，并且我将解释它的工作原理。
算法 这个算法很简单。首先，我们将ASCII码艺术品中要用到的每一个字符转化成一张图片，并缓存它。然后，我们遍历原始图像，对于每个字符大小的图片块，找出能最佳匹配它的字符。为了实现这一步，我们首先对原始图像做一些预处理：我们先将图像转换为灰度图，然后让其通过一个阈值滤波器，此时就得到了一个黑白对比图，我们可以将其与每个字符对比并计算差值。接着，对每个图片块选取最相似的字符，一直进行下去，直到整个图像都转换完成。此外，我们还可以根据需要调 整阈值大小来影响对比度，并增强最终的结果。
为了实现这一点，一个非常简单的方法是将红、绿、蓝的值都设置成三种颜色的平均值：
红=绿=蓝 =(红+绿+蓝)/ 3 如果这个值低于阈值，我们就将它设置成白色，否则我们将其设置成黑色。最后，我们将图像与每个字符以像素为单位进行比较并计算出平均误差。如下面的图片和代码片段所示：
int r1 = (charPixel &gt;&gt; 16) &amp; 0xFF; int g1 = (charPixel &gt;&gt; 8) &amp; 0xFF; int b1 = charPixel &amp; 0xFF; int r2 = (sourcePixel &gt;&gt; 16) &amp; 0xFF; int g2 = (sourcePixel &gt;&gt; 8) &amp; 0xFF; int b2 = sourcePixel &amp; 0xFF; int thresholded = (r2 + g2 + b2) / 3 &lt; THRESHOLD ? 0 : 255; error = Math.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/254cb9165cf0058348b9fc670ebcdffc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb6c6d3c0f8ce339a3b9d995daa6aa53/" rel="bookmark">
			控制两个、LED灯交替闪烁【警灯】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/* 工程创建MCU选取，Atmel 89C55 单片机：STC12C4052AD，STC12C5A60S2 都可以 晶振：12M 功能：亮灭分开控制，修改延时可以频闪 控制两个等交替闪烁【警灯】 连接说明：LED1正极串接1K 电阻接VCC，负极接到 MCU的P1.7 ：LED2正极串接1K 电阻接VCC，负极接到 MCU的P1.6 编程思路与技巧：增加了同样的元器件，把变量的名字修改一下，看看工作是否正常 这样编程有信心！ */ #include &lt;REG51.h&gt; sbit LED1 = P1 ^ 6; sbit LED2 = P1 ^ 7; void DELAY_MS (unsigned int a) { unsigned int i; while ( --a != 0 ) { for (i=0;i&lt;=600;i++); } } void main (void) { while (1) { // 分开控制 LED1的亮灭时间，0亮，1灭 LED1 = 1; LED2 = 0; DELAY_MS(500); LED1 = 0; LED2 = 1; DELAY_MS(500); } } 转载于:https://blog.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb6c6d3c0f8ce339a3b9d995daa6aa53/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da6df2ad72714823889be2d50552e0fe/" rel="bookmark">
			OEM 11g在win7 ie11下报错“证书错误，导航已阻止”的恢复方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		﻿﻿ Microsoft Windows [版本 6.1.7601]
版权所有 (c) 2009 Microsoft Corporation。保留所有权利。
C:\Users\Administrator&gt;certutil -setreg chain\EnableWeakSignatureFlags 8
Software\Microsoft\Cryptography\OID\EncodingType 0\CertDllCreateCertificateChainEngine\Config\EnableWeakSignatureFlags:
新值:
EnableWeakSignatureFlags REG_DWORD = 8
CertUtil: -setreg 命令成功完成。
CertSvc 服务可能需要重新启动，以使更改生效。
C:\Users\Administrator&gt;
秘钥问题，win7对秘钥的长度的限制提高了。
再刷新https://10.108.226.207:1158/em就可以了。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/551/">«</a>
	<span class="pagination__item pagination__item--current">552/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/553/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>