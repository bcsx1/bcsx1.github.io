<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f7fc46f9917976b963b13a5aefd9388/" rel="bookmark">
			java 判断是否为整数_java判断是否为整数的几种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法一：用JAVA自带的函数public static boolean isNumeric(String str){
for (int i = str.length();--i&gt;=0;){
if (!Character.isDigit(str.charAt(i))){
return false;
}
}
return true;
}
方法二：/*
* 判断是否为整数
* @param str 传入的字符串
* @return 是整数返回true,否则返回false
*/
public static boolean isInteger(String str) {
Pattern pattern = Pattern.compile("^[-+]?[d]*$");
return pattern.matcher(str).matches();
}
方法三：public static boolean isNumeric(String str){
Pattern pattern = Pattern.compile("[0-9]*");
return pattern.matcher(str).matches();
}
方法四：public final static boolean isNumeric(String s) {
if (s != null &amp;&amp; !"".equals(s.trim()))
return s.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f7fc46f9917976b963b13a5aefd9388/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb2a5d32616ac30c28b16772f20718dc/" rel="bookmark">
			ai怎么让图片任意变形_为什么AI软件将图形等比例缩小会变形？如何样可以要图形不变形？...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		回答：
AI中么把图像等比例扩大或缩小尺寸步骤如下：
1、打开AI的软件，执行菜单栏中文件—新建，或者直接使用快捷键Ctrl+N新建一个画布。
2、选择工具箱中的心形工具，将填充设置为红色，描边设置为无
3、然后鼠标点击拖动不放，上下方向键控制角度的多少，我们画出一个的类似太阳的图形，如下图所示。选择我们来讲这个图形缩小或者是放大。
4、选择工具箱中的选择工具，选中这个图形，我们可以在四周看到一个方框，这个方框上每边都有三个锚点。如下图所示。
5、我们将鼠标放到锚点上，我们可以看到一个两个方向的箭头，直接点击向图形移动就是缩小，远离图形就是放大。
AI中等比缩小放大图片的步骤：
方法一
1、选择工具箱中的选择工具，在图形上点击一下，也就是选中图形，使图形四周出现一个方框，如下图所示。
2、在有方框的前提下，我们将鼠标放在锚点处，按住shift键不放，可以实现将图形等比例缩小和放大。
方法二
1、选中工具箱中的选择工具选中图形，让图形四周出现方框，然后右键单击图形，找到变换—缩放，如下图所示。
2、点击缩放后，弹出一个比例缩放框，这时候我们可以看到，有两种缩放，一种是等比缩放，一种是不等比缩放，我们选择等比缩放，然后输入数值，点击确定。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ff2476ee3774fc45a5f3e6ffd386eb6/" rel="bookmark">
			11.异常
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.异常概述 异常：就是程序出现了不正常的情况
异常体系：
Throwable
ErrorException RuntimeException非RuntimeException Error：严重问题，不需要处理
Exception：称为异常类，它表示程序本身可以处理的问题
RuntimeException：在编译期是不检查的，出现问题后，需要我们回来修改代码非RuntimeException：编译期就必须处理的，否则程序不能通过编译，就更不能正常运行了 2.JVM的默认处理方案 如果程序出现了问题，我们没有做任何处理，最终JVM会做默认的处理
把异常的名称，异常原因及异常出现的位置等信息输出在了控制台程序停止执行 3.异常处理 如果程序出现了问题，我们需要自己来处理，有两种方案：
1）try…catch… 格式：
try{ 可能出现异常的代码； }catch(异常类名 变量名){ 异常的处理代码; } 执行流程：
程序冲try里面的代码开始执行
出现异常，会自动生成一个异常类对象，该异常对象将被提交给java运行时系统
当java运行时系统接收到异常对象时，会到catch中去找匹配的异常类，找到后进行异常的处理
执行完毕之后，程序还可以继续往下执行
2）throws 格式：throws 异常类名；
【注】这个格式是跟在方法的括号后面的
编译时异常必须要进行处理，两种处理方案：try…catch…或者throws，如果采用throws这种方案，将来谁调用谁处理运行时异常可以不处理，出现问题后，需要我们回来修改代码 4.Throwable的成员方法 方法名说明public String getMessage()返回此Throwable的详细消息字符串public String toString()返回此可抛出的简短描述public void printStackTrace()把异常的错误信息输出在控制台 5.编译时异常和运行时异常的区别 java中的异常被分为两大类：编译时异常和运行时异常，也被称为受检异常和非受检异常
所有的RuntimeException类及其子类被称为运行时异常，其他的异常都是编译时异常
编译时异常：必须显示处理，否则程序就会发生错误，无法通过编译运行时异常：无需显示处理，也可以和编译时异常一样处理 6.自定义异常 格式： public class 异常类名 extends Exception{ 无参构造； 带参构造； } 范例： public class ScoreException extends Exception{ public ScoreException(){} public ScoreException(String message){ super(message); } } 7.throws和throw的区别 throws 用在方法声明后，跟的是异常类名表示抛出异常，由该方法的调用者来处理表示出现异常的一种可能性，并不一定会发生这些异常 throw 用在方法体内，跟的是异常对象名表示抛出异常，由方法体内的语句处理执行throw一定抛出了某些异常 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8cbc07530d2e4d3340b8deff23dbd99/" rel="bookmark">
			HTML-CSS小知识——translate基于自身移动、绝对定位基于父盒子
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 HTML-CSS小知识——translate是基于自身移动的、绝对定位基于父盒子 例子 无论是在标准流情况还是绝对定位下，translate都是基于自身移动的；绝对定位基于父盒子 例子 代码如下 &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; body&gt;div{ width: 800px; height: 500px; margin: 0 auto; background-color: red; position: relative; } .move{ width: 200px; height: 200px; position: absolute; left: 50%; top: 50%; background-color: green; transition: all 0.5s linear; } .move:active{ transform: translateX(50%); } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;div class="move"&gt;移动&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 静态界面：绝对定位是相对于父盒子，也就是上一个非标准流的祖先盒子。其中需注意那个50%产生的效果不是让这个盒子的中心居中的。
移动时：translateX(50%)的50%是基于自身的
此文章如有不足之处，希望大家在评论区一起交流哦！谢谢大家！！！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5083308f32a486c1cbf2ceb84fc4a21/" rel="bookmark">
			进制之间的转换（史上最全自己纯手工总结）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、十进制转二进制： 十进制数除2取余法，即十进制数除以2，余数为权位上的数，得到的商值继续除2，以此步骤直到商为0为止。
二、二进制转十进制： 把二进制数按权展开，相加即得十进制数
三、二进制转八进制： 3位二进制数按权展开相加得到1位八进制数（注：3位二进制转成八进制是从右到左开始转换，不足时补0）
四、八进制转二进制： 八进制数通过除2取余数，得到二进制数，对每个八进制为3个二进制，不足时在最左边补0
五、二进制转十六进制： （与二进制转成八进制方法近似）十六进制是取四舍一（注：4位二进制转成十六进制是从右到左开始转换，不足时补0）
六、十六进制转二进制： 十六进制数通过除2取余法，得到二进制数，对每个十六进制为4个二进制，不足时在最左边补0
七、八进制转十进制： 把八进制数按权展开，相加即得到十进制数
八、十进制转八进制： 将十进制数除以8，按权展开，直到商为0，然后将得到的各个余数从最后得到的那个开始向右排起就是八进制数
九、十六进制转八进制： 先转成二进制，再转成八进制
十、八进制转十六进制： 同上
*附加：
二进制：Binary（B） 由0、1组成
八进制：Octal（O） 由0-7组成（逢8进1）
十进制：Decimal（D） 由0-9组成
十六进制：Hexadecimal（H） 由ABCDEF组成，对应10-15
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/663aff02d3c00fa2c3dd3c2236c6ef6c/" rel="bookmark">
			（七）模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、内置模块 1.hashlib import hashlib def get_md5(str_to_code): obj = hashlib.md5() obj.update(str_to_code.encode("utf-8")) #明文 res = obj.hexdigest() return res val = get_md5('123') print(val) 2.random 3.getpass import getpass pwd = getpass.getpass('请输入密码：') if pwd == '123': print('success') 4.time/datetime【时间相关】 4.1 datetime # ======================获取datatime 格式的时间================ from datetime import datetime #获取当前本地时间，并将其转化成字符串格式的时间 ctime = datetime.now().strftime('%Y-%m-%d-%H-%M-%S') #当前utc时间/伦敦时间 utctime = datetime.utcnow() print(ctime,type(ctime)) #东2区的时间 tz = timezone(timedelta(hours=2)) v3 = datetime.now(tz) print(v3) ''' 2021-02-14-11-30-29 &lt;class 'str'&gt; 2021-02-14 03:30:29.510515 &lt;class 'datetime.datetime'&gt; 2021-02-14 05:30:29.510515+02:00 ''' # ======================字符串转换成datatime================ v1 = datetime.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/663aff02d3c00fa2c3dd3c2236c6ef6c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46fa67567e8f3a3c0851e3a2dba69839/" rel="bookmark">
			Python&#43;OpenCV颜色识别 物体追踪
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python+OpenCV颜色识别 物体追踪 对于颜色识别和imutils包的用法请浏览我得另一篇博客：OpenCV学习笔记
文章目录 Python+OpenCV颜色识别 物体追踪代码原理代码最终效果图 个人博客原址：OpenCV颜色识别 物体追踪
代码原理 这是个比较简单的代码。代码实现的就是简单的物体追踪，将物体用方框框出。
简单来讲就是先进行颜色识别，正确识别到物体后获取物体的外接矩形再画出外接矩形即可。
详细的解释可以看代码注释，应该是容易理解的。
代码 import cv2 import numpy as np import imutils from imutils import contours # 颜色阈值 lower = np.array([130, 62, 72]) upper = np.array([170, 255, 148]) # 内核 kernel = np.ones((5, 5), np.uint8) # 打开摄像头 vc = cv2.VideoCapture(0) if vc.isOpened(): flag, frame = vc.read() # 翻转图像 # 这一步可以忽略，博主的摄像头是反着的 # 所以加上这句话可以让摄像头的图像正过来 frame = imutils.rotate(frame, 180) cv2.imshow("frame", frame) else: flag = False while flag: flag, frame = vc.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/46fa67567e8f3a3c0851e3a2dba69839/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/353c3bf6e575c61fd952781c1011a7c1/" rel="bookmark">
			PlayerPrefs &#43; 反射 = 一个简单的自定义类数据类型存储读取管理器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PlayerPrefsManager 本文章只提供一种思路，思路来自于b站/泰课在线唐老狮unity课程。
using System; using System.Collections; using System.Reflection; using UnityEngine; /* Editor:Runto Version:1.0 The last time for modification:2021.2.13 Time for Creation:2021.2.13 */ namespace demo { /// &lt;summary&gt; /// PlayerPrefs管理类，主要负责自定义类数据保存，和读取。 /// &lt;/summary&gt; public class PlayerPrefsManager { private PlayerPrefsManager instance = new PlayerPrefsManager(); public PlayerPrefsManager Instance =&gt; instance; //私有化构造函数以防止调用者自行创建管理类。 private PlayerPrefsManager() { } /// &lt;summary&gt; /// PlayerPrefs自定义数据类型数据保存封装方法。 /// &lt;/summary&gt; /// &lt;param name="data"&gt;自定义数据类型&lt;/param&gt; /// &lt;param name="keyName"&gt;自定义键名&lt;/param&gt; public void SaveData(object data,string keyName) { //根据传进来的数据类型获取其type，以方便进而访问其所有字段。 Type type = data.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/353c3bf6e575c61fd952781c1011a7c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8dcfde478fce5d6a2ab6eb0832ce2da/" rel="bookmark">
			java string做除法_java字符串除法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import java.math.BigDecimal;
public class Stringcf {
public static void main(String[] args) {
String str1 = "1";
String str2 = "4";
//yang
//String jieguo = "";
//double nkbx06 = Double.valueOf(nkbx0606);
//jieguo = String.valueOf(nkbx06/10000);
Double n1 = new Double(str1);
BigDecimal num1 = new BigDecimal(str1);
BigDecimal num2 = new BigDecimal(str2);
BigDecimal result = num1.add(num2);
System.out.println(num1.divide(num2));
/*result = num1.subtract(num2);
result = num1.divide(num2); 除法
result = num1.multiply(num2);*/
}
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/089aa24d1128c32ef0a5cb19f745bea0/" rel="bookmark">
			DnCNN降噪器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里写自定义目录标题 DnCNN降噪器网络结构训练过程测试过程 DnCNN降噪器 本文主要介绍去噪的卷积神经网络(Denoising Convolutional Neural Network, DnCNN)的结构和功能，我第一次读到它是在《Learned D-AMP:Principled Neural Network Based compressive image recovery》文章中，它在DAMP算法中担任降噪器的功能，可以单独拿出来训练，也可以独自在DAMP算法中进行端到端训练。
网络结构 在DnCNN神经网络结构设计上，DnCNN源于对VGG网络的修改，包括去除了池化层和全连接层等，在卷积层Conv和ReLU之间加入了批量归一化BN，可以减轻内部协变量移位[ ]带来的影响，从而提高网络的学习收敛速度。在模型学习中，DnCNN借鉴了ResNet的残差学习方法[]，并将其与批处理归一化相结合，来提高训练速度和去噪性能。
图1为DnCNN深度卷积神经网络结构。输入矢量的维数为：d*d。给定深度为D的DnCNN网络，有三种不同的层，它们的具体排列顺序为：第1层为卷积层和修正线性单元 (Conv+ReLU)：使用64个大小为 的滤波器，生成64个特征图，然后，使用修正线性单元(max(0，·))进行非线性处理。第2~(D-1)层为卷积层+批处理归一化+修正线性单元(Conv+BN+ReLU)，使用64个大小为 的滤波器，在Conv层和ReLU层之间加入BN层。最后一层为卷积层(Conv)，使用1个大小为 的滤波器重构输出。
训练过程 在训练DnCNN时，本文使用了1267200个 的样本矩阵用于训练，140800个 的样本矩阵用于验证，和1408个样本矩阵用于测试。所有的样本矩阵在生成时都是无噪声样本，而在训练和测试时，会在对应的噪声水平范围内加入噪声。为了获取足够的空间信息进行去噪，我们将DnCNN神经网络的深度设置为10层或10层以上。在5.1节的实验中，我们需要改变神经网络的层数，因此我们训练了多个不同层数的DnCNN神经网络模型。我们采用[34]中的方法初始化DnCNN神经网络权值，并采用权值衰减为0.0001、动量为0.9、小批量尺寸为128的随机梯度下降法(Stochastic Gradient Descent，SGD)训练网络。我们为每个小范围噪声水平下的神经网络设置最大训练次数为50，最大允许无用训练次数(Max Bad Epochs, MBE)为2，初始无用训练次数(Bad Epochs, BE)为0。在训练过程中，初始最小验证误差采用验证集验证未训练的网络得到，后续过程中，网络训练一次就验证一次得到新的验证误差，并将新的验证误差与上一次的验证误差相比，如果小于上一次的验证误差就将此次验证误差设置为最小验证误差并将BE清零，否则最小验证误差不变并将BE加1。当BE大于等于MBE时，网络就减小学习速率，并将BE清零。学习速率变化过程为初始值0.001衰减为0.0001，最后衰减至0.00001。当学习速率衰减为0.00001且BE大于等于MBE时，DnCNN神经网络的训练结束。在实验中，我们使用MATLAB的工具箱MatCovNet来实现DnCNN神经网络。所有实验均在Intel® Core™ i7-8700K CPU 3.70GHz、NVIDIA GeForce GTX 1080 GPU的PC上运行的Matlab (R2018b)环境下进行。所有9个小范围噪声水平下的20层DnCNN网络的GPU训练时间需要59小时左右
图1：网络结构图
测试过程 图2为使用1408个随机样本矩阵分别测试9个小范围噪声水平下的训练后的20层DnCNN得到的误差曲线图。其中，红色实线表示测试前网络输入样本与对应的无噪声样本之间的平均均方误差MSE，虚线表示测试后网络输出样本与对应的无噪声样本之间的平均方误差MSE。蓝色实线是输出误差与输入误差之间的比值变化曲线。从图中可以看出，输出误差低于输入误差且随着噪声标准差的增加，输出误差与输入误差之间的比值逐渐减小，具体数值为从[0 0.005]区间的0.5956减小至[1 2]区间的0.0311。误差比值在低噪声水平下较大的原因主要是，输入误差接近于0，此时输出误差在低于输入误差的同时已经达到足够小的水平。这说明训练后的DnCNN网络拥有良好的去噪效果。
图2：测试误差结果图
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/006230dbdd7ed13393fec0c722025195/" rel="bookmark">
			java中hashtable通过键找值_哈希表(hashtable)通过值(value)获取查找键(key)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		哈希表的设计初衷就是通过键key来查找值value的，可以说对哈希表的操作内部机制实质上都是对键的操作。键不能为空且唯一，value值可以。键、值可以为任意数据类型。
通过键key查找值value可通过hstb.hstb.Contains(key)、 hstb.ContainsKey(key)查看是否包含指定的键，
hstb.ContainsValue(Value)是否包含指定的值，返回的都是true或false，体现查询结果。
在我的实际项目中却要实现值value查找key，这看似违背了hashtable的设计初衷，通过遍历元素、DictionaryEntry类型就可以轻松实现，写出来供有需要的朋友参考，下面是代码：
【VB.NET】
Dim SValue as string '已知value
Dim strID as string '要查找的key
Dim jzd As DictionaryEntry
For Each jzd In DevHashTable
If SValue= jzd.Value Then strID = jzd.Key
Next
【C#】
foreach (DictionaryEntry jzd in hstb)　{　Console.WriteLine("t{0}t{1}", jzd.Key, jzd.Value);　}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/741e4b05303eb8a205843ebc272e3740/" rel="bookmark">
			java main 如何不退出_介绍两种种方法，使main函数等待不退出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下面介绍两种种方法，使main函数等待不退出
一、等待输入
1.new BufferedReader(new InputStreamReader(System.in)).readLine();
2.System.in.read();
二、使用线程同步锁
1.object.wait();
区别：“等待输入”的方式在用户输入回车、esc时会退出，“同步锁”方式则会无限期等待。
package org.mavens.blls;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
/**
* Hello world!
*
*/
public class App //extends com.google.common.util.concurrent.AbstractIdleService
{
static Object lock = new Object();
public static void main( String[] args )
{
try {
//等待输入，读取回车前的所有字符
System.out.println( "0.等待输入，读取回车前的所有字符!" );
String str = new BufferedReader(new InputStreamReader(System.in)).readLine();
System.out.println( "0.输入内容："+str);
//等待输入，读取一个字符
System.out.println( "1.等待输入，读取一个字符!" );
int n = System.in.read();
System.out.println( "1.输入内容："+(char)n );
//无限期等待
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/741e4b05303eb8a205843ebc272e3740/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e281419c9c138edadc51be7794eb0b51/" rel="bookmark">
			java把jsp页面内容保存为pdf_JSP页面导出PDF格式文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JSP页面导出PDF格式文件基本在前端页面可以全部完成
添加下载链接的点击事件
var downPdf = document.getElementById("downLoad");
downPdf.onclick = function() {
downPdf.parentNode.removeChild(downPdf);
html2canvas(document.body, {
onrendered:function(canvas) {
var contentWidth = canvas.width;
var contentHeight = canvas.height;
//一页pdf显示html页面生成的canvas高度;
var pageHeight = contentWidth / 592.28 * 841.89;
//未生成pdf的html页面高度
var leftHeight = contentHeight;
//pdf页面偏移
var position = 0;
//a4纸的尺寸[595.28,841.89]，html页面生成的canvas在pdf中图片的宽高
var imgWidth = 595.28;
var imgHeight = 592.28/contentWidth * contentHeight;
var pageData = canvas.toDataURL('image/jpeg', 1.0);
var pdf = new jsPDF('', 'pt', 'a4');
//有两个高度需要区分，一个是html页面的实际高度，和生成pdf的页面高度(841.89)
//当内容未超过pdf一页显示的范围，无需分页
if (leftHeight &lt; pageHeight) {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e281419c9c138edadc51be7794eb0b51/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80a2f6616e364c44bf9f3cb1a683cf07/" rel="bookmark">
			为什么要配置java环境变量_为什么要设置Java环境变量（详解）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从开始接触Java，之后是断断续续的学习。真正开始Java之旅，估计大部分初学者在学Java时被Java的环境变量搞的晕头转向，虽然找到了正确设置环境变量的方式，但其中的原因一知半解，设置压根不知道是何原因。
今天为止对环境变量的设置还不是很懂，而且网上的大部分资料几乎都是设置方法，没有说原因。下面是我的个人见解，(难免有纰漏)：详细透彻讲解Java环境变量的设置。
“
1. PATH环境变量。作用是指定命令搜索路径，在shell下面执行命令时，它会到PATH变量所指定的路径中查找看是否能找到相应的命令程序。我们需要把 jdk安装目录下的bin目录增加到现有的PATH变量中，bin目录中包含经常要用到的可执行文件如javac/java/javadoc等待，设置好 PATH变量后，就可以在任何目录下执行javac/java等工具了。
2. CLASSPATH环境变量。作用是指定类搜索路径，要使用已经编写好的类，前提当然是能够找到它们了，JVM就是通过CLASSPTH来寻找类的。我们 需要把jdk安装目录下的lib子目录中的dt.jar和tools.jar设置到CLASSPATH中，当然，当前目录“.”也必须加入到该变量中。
3. JAVA_HOME环境变量。它指向jdk的安装目录，Eclipse/NetBeans/Tomcat等软件就是通过搜索JAVA_HOME变量来找到并使用安装好的jdk。
”
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/763db6981b6ba4fcc1f189f77b20c771/" rel="bookmark">
			java log输出到文件路径_基于web项目log日志指定输出文件位置配置方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先我们定义一个可以在运行时动态的找出项目的路径WebAppRootKey,这么做的原因是为了在后面配置log4j输出文件路径的时候能随心配置。
webAppRootKey
amt.root
然后要定义项目log配置文件的路径以及log4j监听器
log4jConfigLocation
classpath:conf/log4j.xml
org.springframework.web.util.Log4jConfigListener
这样web.xml文件的配置完毕，然后就是log配置文件的具体配置文件：
项目结构如下：
一切准备就绪之后，项目一旦启动你就能在你规定的输出位置找到你每天或者每个小时的日志文件，log配置文件还可以进行拓展配置每个文件的大小以及文件出错时的回滚事宜，这里不做赘述。
以上这篇基于web项目log日志指定输出文件位置配置方法就是小编分享给大家的全部内容了，希望能给大家一个参考，也希望大家多多支持脚本之家。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2284c26d5fcb3eef19d1126cf87cc9d6/" rel="bookmark">
			java jdk source_java – JDK8 with -source 1.7 [默认方法]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我有以下课
public class ZonedDateTimeToInstant {
public static void main(final String[] args)
throws NoSuchMethodException {
assert ChronoZonedDateTime.class.isAssignableFrom(ZonedDateTime.class);
final Method toInstant
= ChronoZonedDateTime.class.getMethod("toInstant");
final ZonedDateTime now = ZonedDateTime.now();
final Instant instant = now.toInstant();
System.out.println(instant);
}
}
它只是编译罚款.
&amp; javac ZonedDateTimeToInstant.java
并且它与-source 1.7失败.
&amp; javac -source 1.7 ZonedDateTimeToInstant.java
ZonedDateTimeToInstant.java:10: error: cannot find symbol
final Instant instant = now.toInstant();
^
symbol: method toInstant()
location: variable now of type ZonedDateTime
1 error
1 warning
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2284c26d5fcb3eef19d1126cf87cc9d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f891c2865397943ab0f0a55d44ae5a5a/" rel="bookmark">
			java 如何防止重复提交_Java后台防止客户端重复请求、提交表单实现原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这篇文章主要介绍了Java后台防止客户端重复请求、提交表单实现原理,文中通过示例代码介绍的非常详细，对大家的学习或者工作具有一定的参考学习价值,需要的朋友可以参考下
前言
在Web / App项目中，有一些请求或操作会对数据产生影响(比如新增、删除、修改)，针对这类请求一般都需要做一些保护，以防止用户有意或无意的重复发起这样的请求导致的数据错乱。
常见处理方案
1.客户端
例如表单提交后将提交按钮设为disable 等等方法...
2.服务端
前端的限制仅能解决少部分问题，且不够彻底，后端自有的防重复处理措施必不可少，义不容辞。
在此提供一个我在项目中用到的方案。简单来说就是判断请求url和数据是否和上一次相同。
方法步骤
1.主要逻辑：
给所有的url加一个拦截器，每次请求将url存入session，下次请求验证url数据是否相同，相同则拒绝访问。
当然，我在此基础上做了一些优化，比如：
使用session有局限性，用户量大了以后服务器会撑不住，在此我使用了redis来替换。
加入了token令牌机制。
2.实现步骤：
2.1自定义一个注解
/**
* @Title: SameUrlData
* @Description: 自定义注解防止表单重复提交
* @Auther: xhq
* @Version: 1.0
* @create 2019/3/26 10:43
*/
@Inherited
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface SameUrlData {
}
2.2自定义拦截器类
检查此接口调用的方法是否使用了SameUrlData注解，若没有使用，表示此接口不需要校验；
若使用了注解，获取请求url+参数，并去除一直在变化的参数(比如时间戳timeStamp和签名sign)
检查参数中是否有token参数(token代表不同的用户的唯一标识)，没有直接放行
有token参数，将token+url作为redis的key，url+参数作为value存入redis，并设定自动销毁时间
再次访问进行验证是否重复请求
import com.alibaba.fastjson.JSONObject;
import com.tuohang.hydra.framework.common.spring.SpringKit;
import com.tuohang.hydra.toolkit.basis.string.StringKit;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.stereotype.Component;
import org.springframework.web.method.HandlerMethod;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f891c2865397943ab0f0a55d44ae5a5a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c7dd137acfceab0923b0d2eb5d89f68/" rel="bookmark">
			java 强制gc_java应用性能调优之详解System的gc垃圾回收方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是System.gc()？
System.gc()是用Java，C＃和许多其他流行的高级编程语言提供的API。当它被调用时，它将尽最大努力从内存中清除垃圾(即未被引用的对象)。名词解释：GC，Garbage Collection，垃圾回收，下文会经常使用。
二、谁可以调用System.gc()？
System.gc() 可以从应用程序堆栈的各个部分调用：
您自己开发的应用程序可以显式的调用 System.gc() 方法。
System.gc() 也可以由您的第三方库，框架触发。
可以由外部工具(如VisualVM)通过使用JMX触发
如果您的应用程序使用了RMI，RMI会定期调用 System.gc() 。
三、调用System.gc()有什么弊端？
当 System.gc() 或 Runtime.getRuntime().gc()API被调用时，将触发完整的GC事件。在GC完成之前，整个JVM将冻结(即正在运行的所有服务将被暂停)，通常完整的GC需要很长时间才能完成。因此在不合适的时间运行GC，将导致不良的用户体验，甚至是崩溃。
JVM具有复杂的算法，该算法始终在后台运行，进行所有计算以及有关何时触发GC的计算。当您显式调用System.gc()调用时，所有这些计算都将被抛掉。
四、哪些场景适合显式调用System.gc()？
GC操作应该由JVM自行控制，在绝大部分的场景都不建议程序员手动写代码显式进行System.gc()操作，但是也不排除其中个别例外：在我们开发多个微服务时，每个服务都有多个备份节点。在非业务高峰时段，我们可以从微服务-负载均衡的节点池中取出其中一个JVM实例。然后通过该JVM上的JMX显式触发System.gc()调用，一旦GC事件完成并且从内存中清除了垃圾，将该JVM放回到微服务-负载均衡的节点池中。
当然这个过程需要很好的微服务管理及服务发布机制配合，这样既能保证JVM垃圾内存的有效清理，又不影响业务的正常运行。
五、如何检测您的应用程序正在进行System.gc()？
如第二小节所讲： System.gc() 可以从多个渠道进行的调用，而不仅仅是从您的应用程序源代码进行的调用。因此，搜索您的应用程序代码System.gc() 字符串，不足以知道 GC是否正在被调用。这就构成了一个挑战：如何检测应用程序是否正在进行垃圾回收？这就是GC日志派上用场的地方。
// java 8 启用GC日志：
// -XX:+PrintGCDetails -Xloggc: ,例如下面这行代码
-XX:+PrintGCDetails -Xloggc:/opt/tmp/myapp-gc.log
// java 9 启用GC日志：-Xlog:gc*:file= ,例如下面这行代码
-Xlog:gc*:file=/opt/tmp/myapp-gc.log
建议始终在所有生产服务器中始终启用GC日志，因为它有助于您排除故障并优化应用程序性能。启用GC日志只会增加微不足道的开销。还可以将您的GC日志上传到垃圾收集日志分析器工具，例如GCeasy，HP JMeter等。这些工具将生成丰富的垃圾收集分析报告。
上图摘自GCeasy生成的报告。
六、如何禁止GC显式调用或调整调用GC的频率？
如果我们就是想避免程序员显式调用GC，避免不成熟的程序员在不合适时间调用GC，避免人为造成的GC崩溃，该怎么办？可以通过如下方法：
搜索和替换
在代码库中搜索 System.gc() 和Runtime.getRuntime().gc()。如果看到匹配项，则将其删除。但是这种方法无法避免第三方库、框架或通过外部源进行调用，那么参考第二种方法。
通过JVM参数强制禁止
通过传递JVM参数 -XX:+DisableExplicitGC来强制禁止显式调用。这种方式强制、有效，应用程序内的任何GC显式代码调用System.gc() 都将被禁止生效。JVM自身的GC策略不受此参数影响，只禁止人为的触发GC。
RMI
如果您的应用程序正在使用RMI，则可以控制GC调用的频率 。启动应用程序时，可以使用以下JVM参数配置该频率：
-Dsun.rmi.dgc.server.gcInterval=n
-Dsun.rmi.dgc.client.gcInterval=n
这些属性的默认值在
JDK 1.4.2和5.0是60000毫秒(即60秒)
JDK 6和更高版本是3600000毫秒(即60分钟)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c7dd137acfceab0923b0d2eb5d89f68/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97072d0bc3176811419366b9c873b524/" rel="bookmark">
			VRTK与SteamVR版本对应问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Unity进行VR项目开发时候经常使用的插件为VRTK，现在商店中对应的VRTK版本为V3.3.0，对应SteamVR版本V1.2.3
VRTKv3.3不支持SteamVR2，好多小伙伴可能没有注意，之间在商店进行下载使用，会发现，有一些案例，尤其是VRTK中老版本的40多个案例没有办法运行，原因就是版本不对应。
SteamVR 2 plugin is not officially supported in VRTK v3.3 - There is a community fork that supports SteamVR 2, please ask in the VRTK slack channel for more details.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27bd32e1848c23b919e0593e130bc7fa/" rel="bookmark">
			java并发执行_Java并发执行任务的几种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景
在编写业务代码时经常遇到并发执行多个任务的需求，因为串行执行太慢，会影响业务代码性能。特别对于直接面向普通用户的业务来说用户体验至关重要，保证用户体验重要的一点是要“快”。业务代码中经常需要调用其它业务接口或者同时从多个数据源取数据再处理等，这种情况下势必要走网络请求，网络消耗必不可少，最好的情况是毫秒级别，一般情况下是几十毫秒级别，甚至几百毫秒，TimeoutException恐怕大家并不陌生。
例子
当你浏览微信朋友圈时，微信会把你朋友最近的动态展示在你朋友圈里，并且按照时间顺序最近的排在前面。你会发现，朋友圈里不会展示把你删除了或者你把他删除了的好友，不会展示被你设置过“不看他(她)的朋友圈”的好友或者对方把你设置过“不让他(她)看我的朋友圈”的好友，不会展示被你拉黑或把你拉黑的好友，不会展示被微信系统标记为spam的好友，等等。对于微信这种支持数亿人聊天的应用，其系统必定很复杂，解耦做得也比较好。
下面模拟下这个接口的实现：
public List lastestFeeds(String wxId) {
//串行执行
//1. 获取你得好友列表
//2. 去掉把你删除的好友
//3. 去掉被你删除的好友
//4. 去掉被你设置过"不看他(她)的朋友圈"的好友
//5. 去掉对你设置过"不让他(她)看我的朋友圈"的好友
//6. 去掉被你拉黑和把你拉黑的好友
//7. 去掉被微信系统标记为作弊的好友
//...
//8. 获取好友最近动态再返回
}
对于微信这种复杂的系统，通常不可能从一个接口获取到这些信息，必须从多个接口获取到这些信息后再处理。如果说串行实现这些功能，你可以想象一下是不是慢到吐血，相信微信也不会这么干，否则朋友圈会刷半天也没响应，那么这个用户体验就太糟糕了。那么这个时候并发执行这些子任务就可以很高效的处理掉这种情况。具体到这个接口也就是会把1-7拆解成单个子任务，再丢到线程池异步的执行。最后执行完了，再汇总处理。
public List lastestFeedsV2(String wxId) {
//并发运行，无先后先后执行
//1. 获取你得好友列表
//2. 去掉把你删除的好友
//3. 去掉被你删除的好友
//4. 去掉被你设置过"不看他(她)的朋友圈"的好友
//5. 去掉对你设置过"不让他(她)看我的朋友圈"的好友
//6. 去掉被你拉黑和把你拉黑的好友
//7. 去掉被微信系统标记为作弊的好友
//...
//等待所有子任务完成，汇总处理
//8. 获取好友最近动态再返回
}
那么如何实现并发运行呢，下面讨论几种实现。
CountDownLatch.await() VS ExecutorService.invokeAll()
从功能上讲这两者均可以实现并发执行多个任务并等待的功能。先看代码如何完成以上功能：
CountDownLatch实现：
public List lastestFeeds(String wxId) {
ThreadPoolExecutor executor = .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/27bd32e1848c23b919e0593e130bc7fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bed6f0b371e2dbe1d11838075835db13/" rel="bookmark">
			广度优先 java_算法学习java-广度优先搜索算法（BFS）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在学习算法，刚开始简单的时候有很多的例子和大神们写的博客可以参考，到后面越来难得时候虽然也有很多的博客可以参考，但自己水平有限，对c++不太了解，也不能为了学算法先把c++语言再学一遍。今天终于把这个拿下来了
广度优先搜索算法
广度优先搜索算法是先访问图中的一个节点，然后再访问所有和它相邻的符合条件的节点依次往后直到访问完图中所有的节点。
这些理论知识网上一搜都是一大把，就不详细赘述了。
/*
*访问所有数组里的值
*/
import java.util.LinkedList;
import java.util.Queue;
public class 广度优先搜索算法 {
private int r=4;//行
private int c=4;//列
//数组
private int[][] graph=new int[][]{{1,2,3,4},
{5,6,7,8},
{9,10,11,12},
{13,14,15,16}};
private int[][] gr=new int[r][c];//标记
int[][] rc=new int[][]{{0,-1},{-1,0},{0,1},{1,0}};//左上右下，四个方向
public static void main(String[] args) {
new 广度优先搜索算法().BFS();
}
//方法内部类，定义数据结构
class Node{
int r;//行
int c;//列
int k;//第几波被访问的
Node(int r,int c,int k){
this.r=r;
this.c=c;
this.k=k;
}
}
private void BFS() {
// TODO Auto-generated method stub
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bed6f0b371e2dbe1d11838075835db13/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/075b7dc63a5608f10f5ef41c76a32cb9/" rel="bookmark">
			要不要使用mysql8_居然是这么个尿性——记住：永远不要在MySQL中使用UTF-8！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原址：https://dwz.cn/QS4wLyjh来源：JAVA葵花宝典
最近我遇到了一个bug，我试着通过Rails在以“utf8”编码的MariaDB中保存一个UTF-8字符串，然后出现了一个离奇的错误：
Incorrect string value: ‘\\xF0\\x9F\\x98\\x83 我用的是UTF-8编码的客户端，服务器也是UTF-8编码的，数据库也是，就连要保存的这个字符串“ 问题的症结在于，MySQL的“utf8”实际上不是真正的UTF-8。
“utf8”只支持每个字符最多三个字节，而真正的UTF-8是每个字符最多四个字节。
MySQL一直没有修复这个bug，他们在2010年发布了一个叫作“utf8mb4”的字符集，绕过了这个问题。
当然，他们并没有对新的字符集广而告之(可能是因为这个bug让他们觉得很尴尬)，以致于现在网络上仍然在建议开发者使用“utf8”，但这些建议都是错误的。
简单概括如下：
1.MySQL的“utf8mb4”是真正的“UTF-8”。
2.MySQL的“utf8”是一种“专属的编码”，它能够编码的Unicode字符并不多。
我要在这里澄清一下：所有在使用“utf8”的MySQL和MariaDB用户都应该改用“utf8mb4”，永远都不要再使用“utf8”。
那么什么是编码？什么是UTF-8？
我们都知道，计算机使用0和1来存储文本。比如字符“C”被存成“01000011”，那么计算机在显示这个字符时需要经过两个步骤：
1.计算机读取“01000011”，得到数字67，因为67被编码成“01000011”。
2.计算机在Unicode字符集中查找67，找到了“C”。
同样的：
1.我的电脑将“C”映射成Unicode字符集中的67。
2.我的电脑将67编码成“01000011”，并发送给Web服务器。
几乎所有的网络应用都使用了Unicode字符集，因为没有理由使用其他字符集。
Unicode字符集包含了上百万个字符。最简单的编码是UTF-32，每个字符使用32位。这样做最简单，因为一直以来，计算机将32位视为数字，而计算机最在行的就是处理数字。但问题是，这样太浪费空间了。
UTF-8可以节省空间，在UTF-8中，字符“C”只需要8位，一些不常用的字符，比如“”需要32位。其他的字符可能使用16位或24位。一篇类似本文这样的文章，如果使用UTF-8编码，占用的空间只有UTF-32的四分之一左右。
MySQL的“utf8”字符集与其他程序不兼容，它所谓的“”，可能真的是一坨……
MySQL简史
为什么MySQL开发者会让“utf8”失效？我们或许可以从提交日志中寻找答案。
MySQL从4.1版本开始支持UTF-8，也就是2003年，而今天使用的UTF-8标准(RFC 3629)是随后才出现的。
旧版的UTF-8标准(RFC 2279)最多支持每个字符6个字节。2002年3月28日，MySQL开发者在第一个MySQL 4.1预览版中使用了RFC 2279。
同年9月，他们对MySQL源代码进行了一次调整：“UTF8现在最多只支持3个字节的序列”。
是谁提交了这些代码？他为什么要这样做？这个问题不得而知。在迁移到Git后(MySQL最开始使用的是BitKeeper)，MySQL代码库中的很多提交者的名字都丢失了。2003年9月的邮件列表中也找不到可以解释这一变更的线索。
不过我可以试着猜测一下。
2002年，MySQL做出了一个决定：如果用户可以保证数据表的每一行都使用相同的字节数，那么MySQL就可以在性能方面来一个大提升。为此，用户需要将文本列定义为“CHAR”，每个“CHAR”列总是拥有相同数量的字符。如果插入的字符少于定义的数量，MySQL就会在后面填充空格，如果插入的字符超过了定义的数量，后面超出部分会被截断。
MySQL开发者在最开始尝试UTF-8时使用了每个字符6个字节，CHAR(1)使用6个字节，CHAR(2)使用12个字节，并以此类推。
应该说，他们最初的行为才是正确的，可惜这一版本一直没有发布。但是文档上却这么写了，而且广为流传，所有了解UTF-8的人都认同文档里写的东西。
不过很显然，MySQL开发者或厂商担心会有用户做这两件事：
1.使用CHAR定义列(在现在看来，CHAR已经是老古董了，但在那时，在MySQL中使用CHAR会更快，不过从2005年以后就不是这样子了)。
2.将CHAR列的编码设置为“utf8”。
我的猜测是MySQL开发者本来想帮助那些希望在空间和速度上双赢的用户，但他们搞砸了“utf8”编码。
所以结果就是没有赢家。那些希望在空间和速度上双赢的用户，当他们在使用“utf8”的CHAR列时，实际上使用的空间比预期的更大，速度也比预期的慢。而想要正确性的用户，当他们使用“utf8”编码时，却无法保存像“”这样的字符。
在这个不合法的字符集发布了之后，MySQL就无法修复它，因为这样需要要求所有用户重新构建他们的数据库。最终，MySQL在2010年重新发布了“utf8mb4”来支持真正的UTF-8。
为什么这件事情会让人如此抓狂
因为这个问题，我整整抓狂了一个礼拜。我被“utf8”愚弄了，花了很多时间才找到这个bug。但我一定不是唯一的一个，网络上几乎所有的文章都把“utf8”当成是真正的UTF-8。
“utf8”只能算是个专有的字符集，它给我们带来了新问题，却一直没有得到解决。
总结
如果你在使用MySQL或MariaDB，不要用“utf8”编码，改用“utf8mb4”。这里( https://mathiasbynens.be/notes/mysql-utf8mb4#utf8-to-utf8mb4 )提供了一个指南用于将现有数据库的字符编码从“utf8”转成“utf8mb4”。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38f8e669ebd4307b9dadff96ba18bad6/" rel="bookmark">
			jdk和java什么关系_jdk与java的关系是什么
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		jdk是什么？
jdk是对java基础环境和相应开发平台标准和工具包的封装(zip)。
开发平台：
j2se、j2ee、j2me
环境：
虚拟机、运行环境
jdk与java的关系
JDK是整个JAVA的核心，包括了Java运行环境JRE(Java Runtime Envirnment)、一堆Java工具(javac/java/jdb等)和Java基础的类库(即Java API 包括rt.jar)。
1、SE(J2SE)，standard edition，标准版，是我们通常用的一个版本，从JDK 5.0开始，改名为Java SE。
2、EE(J2EE)，enterprise edition，企业版，使用这种JDK开发J2EE应用程序，从JDK 5.0开始，改名为Java EE。
3、ME(J2ME)，micro edition，主要用于移动设备、嵌入式设备上的java应用程序，从JDK 5.0开始，改名为Java ME。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc2d77fdb7b418ded2d907add160e2d9/" rel="bookmark">
			java返回泛型_Java返回泛型的方法-实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		package com.frank.app;
import java.io.UnsupportedEncodingException;
import java.lang.reflect.Type;
import java.net.URLEncoder;
import java.util.LinkedList;
import java.util.List;
public class App {
private static List demo1(Class clazz) {
T obj = null;
try {
obj = clazz.newInstance();
} catch (InstantiationException e) {
// TODO Auto-generated catch block
e.printStackTrace();
} catch (IllegalAccessException e) {
// TODO Auto-generated catch block
e.printStackTrace();
}
List result = new LinkedList();
result.add(obj);
return result;
}
public static void main(String[] args) {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc2d77fdb7b418ded2d907add160e2d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c7762b61313414b725f0ae59bc4f5e9/" rel="bookmark">
			java byte string_Java - byte[] 和 String互相转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通过用例学习Java中的byte数组和String互相转换，这种转换可能在很多情况需要，比如IO操作，生成加密hash码等等。
除非觉得必要，否则不要将它们互相转换，他们分别代表了不同的数据，专门服务于不同的目的，通常String代表文本字符串，byte数组针对二进制数据
通过String类将String转换成byte[]或者byte[]转换成String
用String.getBytes()方法将字符串转换为byte数组，通过String构造函数将byte数组转换成String
注意：这种方式使用平台默认字符集
package com.bill.example;
public class StringByteArrayExamples
{
public static void main(String[] args)
{
//Original String
String string = "hello world";
//Convert to byte[]
byte[] bytes = string.getBytes();
//Convert back to String
String s = new String(bytes);
//Check converted string against original String
System.out.println("Decoded String : " + s);
}
}
输出：
hello world
通过Base64 将String转换成byte[]或者byte[]转换成String[Java 8]
可能你已经了解 Base64 是一种将二进制数据编码的方式，正如UTF-8和UTF-16是将文本数据编码的方式一样，所以如果你需要将二进制数据编码为文本数据，那么Base64可以实现这样的需求
从Java 8 开始可以使用Base64这个类
import java.util.Base64;
public class StringByteArrayExamples
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c7762b61313414b725f0ae59bc4f5e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/810c81e1db3d8bf34fcd5e3eb1eb7a2a/" rel="bookmark">
			java 日期排序_java对日期实现排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		package com.anyitzy.web.action.guestbook;
import java.util.Comparator;
import com.anyitzy.web.entity.guestbook.Guestbook;
public class GuestbookComparator implements Comparator{
/**
* 如果o1小于o2,返回一个负数;如果o1大于o2，返回一个正数;如果他们相等，则返回0;
*/
@Override
public int compare(Guestbook o1, Guestbook o2) {
//对日期字段进行升序，如果欲降序可采用before方法
if(o1.getPubdate().after(o2.getPubdate())) return 1;
return -1;
}
}
//排序
GuestbookComparator comparator=new GuestbookComparator();
Collections.sort(promptList, comparator);
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57dbc63ed396e0a59fc166fe3b065d1a/" rel="bookmark">
			java生成证书_纯Java实现数字证书生成签名的简单实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		package com.ylsoft.cert;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.security.InvalidKeyException;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.NoSuchProviderException;
import java.security.PrivateKey;
import java.security.SecureRandom;
import java.security.Signature;
import java.security.SignatureException;
import java.security.UnrecoverableKeyException;
import java.security.cert.Certificate;
import java.security.cert.CertificateException;
import java.security.cert.X509Certificate;
import java.util.Date;
import java.util.Vector;
import sun.misc.BASE64Encoder;
import sun.security.util.ObjectIdentifier;
import sun.security.x509.AlgorithmId;
import sun.security.x509.CertAndKeyGen;
import sun.security.x509.CertificateAlgorithmId;
import sun.security.x509.CertificateExtensions;
import sun.security.x509.CertificateSerialNumber;
import sun.security.x509.CertificateValidity;
import sun.security.x509.CertificateVersion;
import sun.security.x509.CertificateX509Key;
import sun.security.x509.ExtendedKeyUsageExtension;
import sun.security.x509.Extension;
import sun.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57dbc63ed396e0a59fc166fe3b065d1a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e6e8f36a57cbb8d6d74ba47c0396b22/" rel="bookmark">
			java 基础面试_Java基础面试题总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、 面向对象和面向过程的区别
面向过程 ：面向过程性能比面向对象高。 因为类调用时需要实例化，开销比较大，比较消耗资源，所以当性能是最重要的考量因素的时候，比如单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发。但是，面向过程没有面向对象易维护、易复用、易扩展。
面向对象 ：面向对象易维护、易复用、易扩展。 因为面向对象有封装、继承、多态性的特性，所以可以设计出低耦合的系统，使系统更加灵活、更加易于维护。但是，面向对象性能比面向过程低。
2、Java 语言有哪些特点?
简单易学；
面向对象(封装，继承，多态)；
平台无关性( Java 虚拟机实现平台无关性)；
可靠性；
安全性；
支持多线程( C++ 语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 语言却提供了多线程支持)；
支持网络编程并且很方便( Java 语言诞生本身就是为简化网络编程设计的，因此 Java 语言不仅支持网络编程而且很方便)；
编译与解释并存；
3、JVM、JDK 、JRE
JVM：Java虚拟机(JVM)是运行 Java 字节码的虚拟机。JVM有针对不同系统的特定实现(Windows，Linux，macOS)，目的是使用相同的字节码，它们都会给出相同的结果。
什么是字节码?采用字节码的好处是什么?
在 Java 中，JVM可以理解的代码就叫做字节码(即扩展名为 .class 的文件)，它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效，而且，由于字节码并不针对一种特定的机器，因此，Java程序无须重新编译便可在多种不同操作系统的计算机上运行。
Java 程序从源代码到运行一般有下面3步：
我们需要格外注意的是 .class-&gt;机器码 这一步。在这一步 JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 JIT 编译器，而JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 Java 是编译与解释共存的语言。
JDK：(Java Development Kit)Java开发工具包，它拥有JRE所拥有的一切，还有编译器(javac)和工具(如javadoc和jdb)。它能够创建和编译程序。
JRE：(Java Runtime Environment)Java运行时环境，它是运行已编译 Java 程序所需的所有内容的集合，包括 Java虚拟机(JVM)，Java类库，java命令和其他的一些基础构件。但是，它不能用于创建新程序。
4、Java和C++的区别?
都是面向对象的语言，都支持封装、继承和多态。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e6e8f36a57cbb8d6d74ba47c0396b22/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d2bf9d67eda375310bf6aed4ca4d17d/" rel="bookmark">
			java多线程并发_java多线程并发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、多线程
1、操作系统有两个容易混淆的概念，进程和线程。
进程：一个计算机程序的运行实例，包含了需要执行的指令；有自己的独立地址空间，包含程序内容和数据；不同进程的地址空间是互相隔离的；进程拥有各种资源和状态信息，包括打开的文件、子进程和信号处理。
线程：表示程序的执行流程，是CPU调度执行的基本单位；线程有自己的程序计数器、寄存器、堆栈和帧。同一进程中的线程共用相同的地址空间，同时共享进进程锁拥有的内存和其他资源。
2、Java标准库提供了进程和线程相关的API，进程主要包括表示进程的java.lang.Process类和创建进程的java.lang.ProcessBuilder类；
表示线程的是java.lang.Thread类，在虚拟机启动之后，通常只有Java类的main方法这个普通线程运行，运行时可以创建和启动新的线程；还有一类守护线程(damon thread)，守护线程在后台运行，提供程序运行时所需的服务。当虚拟机中运行的所有线程都是守护线程时，虚拟机终止运行。
3、线程间的可见性：一个线程对进程中共享的数据的修改，是否对另一个线程可见
可见性问题：
a、CPU采用时间片轮转等不同算法来对线程进行调度
1 public classIdGenerator{2 private int value = 0;3 public intgetNext(){4 return value++;5 }6 }
对于IdGenerator的getNext()方法，在多线程下不能保证返回值是不重复的：各个线程之间相互竞争CPU时间来获取运行机会，CPU切换可能发生在执行间隙。
以上代码getNext()的指令序列：CPU切换可能发生在7条指令之间，多个getNext的指令交织在一起。
aload_0
dup
getfield #12
dup_x1
iconst_1
iadd
putfield #12
b、CPU缓存：
目前CPU一般采用层次结构的多级缓存的架构，有的CPU提供了L1、L2和L3三级缓存。当CPU需要读取主存中某个位置的数据时，会一次检查各级缓存中是否存在对应的数据。如果有，直接从缓存中读取，这比从主存中读取速度快很多。当CPU需要写入时，数据先被写入缓存中，之后再某个时间点写回主存。所以某些时间点上，缓存中的数据与主存中的数据可能是不一致。
c、指令顺序重排
出行性能考虑，编译器在编译时可能会对字节代码的指令顺序进行重新排列，以优化指令的执行顺序，在单线程中不会有问题，但在多线程可能产生与可见性相关的问题。
二、Java内存模型(JavaMemory Model)
屏蔽了CPU缓存等细节，只关注主存中的共享变量；关注对象的实例域、静态域和数组元素；关注线程间的动作。
1、volatile关键词：用来对共享变量的访问进行同步，上一次写入操作的结果对下一次读取操作是肯定可见的。(在写入volatile变量值之后，CPU缓存中的内容会被写回内存；在读取volatile变量时，CPU缓存中的对应内容会被置为失效，重新从主存中进行读取)，volatile不使用锁，性能优于synchronized关键词。
用来确保对一个变量的修改被正确地传播到其他线程中。
例子：A线程是Worker，一直跑循环，B线程调用setDone(true)，A线程即停止任务
1 public classWorker{2 private volatile booleandone;3 public void setDone(booleandone){4 this.done =done;5 }6 public voidwork(){7 while(!done){8 //执行任务；
9 }10 }11 }
例子：错误使用。因为没有锁的支持，volatile的修改不能依赖于当前值，当前值可能在其他线程中被修改。(Worker是直接赋新值与当前值无关)
1 public classCounter {2 public volatile static int count = 0;3 public static voidinc() {4 //这里延迟1毫秒，使得结果明显
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d2bf9d67eda375310bf6aed4ca4d17d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56ff97c7b05dc694fa0485c66737abf1/" rel="bookmark">
			工字型钢弹性截面模量计算公式_截面模量的计算公式是什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		展开全部
截面模量的不同的计算公式如下：e68a843231313335323631343130323136353331333365656538
1.矩形截面抵抗矩：
(其中b为与弯矩垂直方向的长度)。
2.圆形截面的抵抗矩：
抗弯时 (其中d为直径)
抗扭时 。
3.圆环截面抵抗矩：
抗弯时
抗扭时 拓展资料
截面模量又叫截面抵抗矩。被弯曲构件的横截面绕其中性轴的惯性矩除以由中性轴到截面最外边缘的距离。截面抵抗矩(W)就是截面对其形心轴惯性矩与截面上最远点至形心轴距离的比值。
被弯曲构件的横截面绕其中性轴的惯性矩除以由中性轴到截面最外边缘的距离。(单轴对称时，有一个最大截面模量和一个最小截面模量。)可以用来计算截面受弯时的正应力大小。
截面抵抗矩(W)就是截面对其形心轴惯性矩与截面上最远点至形心轴距离的比值。 工程实际中最常见的弯曲问题是横力弯曲，横截面上不仅有正应力，而且还有切应力。由于切应力的作用，横截面发生翘曲，平面假设不再成立。
但进一步的理论分析证明，对于跨长与截面高度比 l/h&gt;5 的长梁利用公式δ=My/I 来计算其横力弯曲的正应力，所得结果误差甚微，足够满足工程实际需要。其中W=I/y，W称为抗弯截面系数。 由于横力弯曲时，梁的弯矩随截面位置变化，Mmax所在截面称为危险截面，最大弯曲正应力发生在弯矩最大的截面上，且离中心轴最远处，该处为危险点。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42dd38296b46bbb725e8c5d09b46cc06/" rel="bookmark">
			mysql或navicat中删除一条记录后如何接着上面的id继续按顺序自增
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mysql或navicat中删除一条记录后如何接着上面的id继续按顺序自增 进入cmd启动mysql
使用数据库如：yang
如下图中的代码，就是user表中的id从5开始继续自增
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/acda0f72d84ed9f20d53761a20605318/" rel="bookmark">
			Anaconda&#43;python3环境下 安装RDkit
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 不创建虚拟环境的命令：
conda install -c conda-forge rdkit 创建虚拟环境的命令：
conda create -c rdkit -n my-rdkit-env rdkit 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0675c945c66efa67899f398f36baf5c/" rel="bookmark">
			Qt Designer UI 中的设计模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Qt UI文件的实现原理很简单。但是，如果做过C#或者Android的经验，会觉得Qt的实现方式还是更加复杂一些的。Java/C#中实现这种功能的时候，并不需要转换为代码。而是由代码直接读取ui文件的文本，由文本内的信息直接构建ui对象。为什么Java/C# 可以做到，C++不行，这是为什么呢？原因很简单，因为C++没有“反射”这个语言特性。如果没有反射，就不能简单的实现从字符串构造对象。那么就没有办法不修改代码、只修改ui文件而实现修改程序ui的目的。
在Qt中，每个UI文件就是一个工具类。针对它绑定的一个Widget实现类，初始化ui并绘制。所以，qt designer的作用，就是把构造UI，记录到文本（ui文件），通过一种工具（uic）转换为工具类的C++ 代码，也就是一个ui_前缀的头文件，这个文件的内容非常简单啊。只有两个接口：setupUI、retranslateUi。通过setupUI(QWidget* w) 接口来访问真正的QT view 对象 MySomeTypeWidget w，通过retranslateUi来实现多语言翻译。建议这里的w 使用字符串MySomeTypeWidget与Widget class同名这种规范。绘制一个widget，我们需要写的代码就是如下三个文件。
MySomeTypeWidget.h
MySomeTypeWidget.cpp
MySomeTypeWidget.ui
在C++中，我们包含 ui_MySomeTypeWidget.h。直接使用 MySomeTypeWidgetImpl 对象来辅助绘制widget。C++文件中，就没有widget 绘制的代码了。对于多数的静态页面，这种方式已经能够满足需求了。对于需要动态构建UI对象的情形，我们也只需要在ui文件中绘制好widget区域和layout，我们直接控制layout对象就可以了。
这里使用到的设计模式是桥接设计模式，算的上比较复杂的一种设计模式了。而且，对于桥接的定义，一般对于 Implementor 成员，多数时候只有一个。但是，一些时候，我们可能会使用两个。例如Qt view层编码，纯粹的widget绘制使用 ui文件这个 Implementor，对于widget上需要使用到的一些算法，那么就需要另外一个 Implementor。只是，这里的Implementor 稍微简单一些，并不需要接口，UI文件对应的都是具体的class。
对于该ui对象的使用，也可以使用ui对象作为成员，也可以使用指针。这里推荐使用指针方式。使用指针方式实现的桥接设计模式，能够显著的改善C++ 编译耗时问题。如果使用ui对象作为成员，那么就要求在头文件中增加ui头文件依赖，将会导致编译时间大大增加。在接口实现上，也要求使用指针方式的桥接设计模式。桥接模式的分析，在另一篇文章中介绍。
我这两年的工作中，指导了几个新来的同事或者实习生学习Qt。观察到一些现象，刚学习Qt的时候，可能会觉得Qt有点难，搞不清楚Qt的概念和工作原理。比如说Qt 自带了moc、uic、qrc工具编译器，这些东西是怎么在工程中起作用的？这说明我们的工作上，缺少一个Qt培训的步骤。这些工程上的原理，其实是非常简单的。只需要几次的培训课程，就能够完全覆盖了。我需要针对这个工作做一个完整的课程。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11da48e7beb70dc849c7ea77e50b4c64/" rel="bookmark">
			吴恩达深度学习学习笔记——C4W3——目标检测——作业——自动驾驶之车辆检测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里主要梳理一下作业的主要内容和思路，完整作业文件可参考:
https://github.com/pandenghuang/Andrew-Ng-Deep-Learning-notes/tree/master/assignments/C4W3/Assignment/Car_detection_for_Autonomous_Driving
作业完整截图，参考本文结尾：作业完整截图。
Autonomous driving - Car detection（自动驾驶之车辆检测） Welcome to your week 3 programming assignment. You will learn about object detection using the very powerful YOLO model. Many of the ideas in this notebook are described in the two YOLO papers: Redmon et al., 2016 (https://arxiv.org/abs/1506.02640) and Redmon and Farhadi, 2016 (https://arxiv.org/abs/1612.08242).
You will learn to:
Use object detection on a car detection datasetDeal with bounding boxes ...
1 - Problem Statement（问题陈述） You are working on a self-driving car.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/11da48e7beb70dc849c7ea77e50b4c64/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9693f902e7b251356583429d0088c097/" rel="bookmark">
			深入理解javascript原型和闭包（19）——补充：this
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		function Fn() { console.log('testThis') } Fn.printSelf = function(message) { console.log(this) console.log(message) } Fn.printSelf('happy new year') 上例中调用Fn.printSelf函数时，this值是函数Fn
实例运行结果：
ƒ Fn() { console.log('testThis') } VUE框架的use函数就是上例的原理：
// 当调用use函数时，this指向VUE构造函数 Vue.use = function (plugin) { var installedPlugins = (this._installedPlugins || (this._installedPlugins = [])); if (installedPlugins.indexOf(plugin) &gt; -1) { return this } } ... 上一篇：深入理解javascript原型和闭包（18）——补充：上下文环境和作用域的关系
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb69eba0ae85745f9e89ff66a915373f/" rel="bookmark">
			F2FS 基础知识二
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.文件索引树结构 大多数现代文件系统都喜欢使用 B-trees 或类似的结构来管理索引（index）以定位文件中的 blocks。大多数文件系统中通过使用“extents”来减少文件数据块的总索引大小。F2FS 不采用 B-tree 结构管理索引，也不使用extents减少文件数据块索引的大小（虽然F2FS为每个节点(node)维护一个extent作为提示）
所谓的extent指的是一段连续的物理磁盘块，这样，只需要一个extent数据结构我们就能描述一段很长的物理磁盘空间，性价比很高。ext4文件系统中的extent数据结构的主要作用是索引，即根据逻辑块号查询文件的extent能够准确定位逻辑块对应的物理块号，另外，ext4的extent在文件较小的时候存储在inode的i_data[]中，在文件较大的时候，所有的extent会被组织成一棵B+树
2.索引节点 管理数据位置的关键数据结构是“node”，与传统文件系统相似，F2FS 使用三种 node：inode，直接 node，间接 node。F2FS 分配4 KB 的空间给一个 inode，其中包括923个数据块索引指针，两个一级索引块(直接 node )指针，两个二级索引块(间接 node )指针，以及一个三级索引块(二级间接 node)指针。一个一级索引块(直接 node )包含1018个数据块指针，一个二级索引块(间接 node )包含1018个一级索引块(直接 node )指针，一个三级索引块(二级间接 node)包含1018个二级索引块(间接 node )指针。因此一个文件的最大大小是：
4 KB * (923 + 21018 + 210181018 + 10181018*1018) := 3.93 TB
3.文件数据块索引 文件系统一个重要功能是实现文件的保存以及读写。每个文件系统有不同的保存和读写方式，而F2FS则是通过Node-Data的形式将数据组织起来。其中最重要的结构就是f2fs_node结构，它实现了文件数据的组织和管理。
f2fs_node的结构以及作用
F2FS每一个文件，根据文件大小的不同，对应了一个或者多个f2fs_node结构，它实际存在于磁盘当中，并每一个f2fs_node结构都占据了4KB的磁盘空间，它的结构如下:
struct f2fs_node { union { struct f2fs_inode i; struct direct_node dn; struct indirect_node in; }; struct node_footer footer; // footer用于记录node的类型 } __packed; struct node_footer { __le32 nid;	/* node id */ __le32 ino;	/* inode nunmber */ __le32 flag;	/* include cold/fsync/dentry marks and offset */ __le64 cp_ver;	/* checkpoint version */ __le32 next_blkaddr;	/* next node page block address */ } __packed; /* 其中f2fs_inode、direct_node、indirect_inode、node_footer 在 f2fs_node 中起到不同的作用: f2fs_inode: 每一个文件仅存在一个f2fs_inode结构，用于提供给文件进行索引，保存了部分文件的元数据，以及923个页数据的物理地址，同时也保存了5个用于间接寻址的direct_node或indirect_node的node id(nid)，其中2个是direct_node的nid，2个是indirect_node的nid，以及1个double indirect node的nid; direct_node: 用于直接寻址，保存了1018个页数据的物理地址; indirect_inode: 用于间接寻址，保存了1018个direct_node的nid或者1018个indirect_inode的nid; node_footer: 用于区分该f2fs_node的类型 f2fs_inode和direct_inode以及indirect_inode的结构如下所示: */ struct f2fs_inode { .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb69eba0ae85745f9e89ff66a915373f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14f03b5eb703a60fa98e5564d21f5651/" rel="bookmark">
			Error:java: Annotation processing is not supported for module cycles.异常解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Error:java: Annotation processing is not supported for module cycles. Please ensure that all modules from cycle [wzhfunding-admin-webUI01,wzhfunding-admin-componet] are excluded from annotation processing
此类错误,大致意思就是说我wzhfunding-admin-webUI01模块和wzhfunding-admin-componet模块的依赖设置错了…，检查发现这两个模块的pom相互引用造成了死循环，即webUI01模块的pom引入了componet模块的依赖，componet模块的pom中引入了webUI01模块依赖。如图
webUI01模块
compoent模块
果不其然，两个模块设置成相互依赖，类似死循环
解决方案也很简单，把其中的一个依赖删了即可(也不能随便删，我删除的是componet模块中的webUI01依赖，因为componet本身就是作为webUI01的工具模块而被webUI01依赖的，大家处理前一定要先想好模块间的依赖关系)，但要注意没有配置maven自动更新的朋友启动web服务前先手动刷新一下maven
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb71d981f678f7c419fd677b6be6ad4a/" rel="bookmark">
			创建mysql备份用户_Oracle数据库创建用户与数据库备份小结(必看篇)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：使用Oracle开发系统过程中，会涉及到数据库用户的建立，及给该用户分配权限。刚开始接触开发的时候，对这些操作是一种茫茫然的状态。后，经过积累，对这方面有了一定的认识，现总结一些，一则，巩固自身，也希望收到大家的指正；再则，希望能帮助疑惑的童鞋，实现人生的小价值，嘿嘿嘿。
创建用户以及授权代码：
-- Create the user
create user myName -- 创建用户
identified by myPwd --设置密码
default tablespace USERS --默认表空间 USERS
temporary tablespace TEMP --默认临时表空间 TEMP
profile DEFAULT;
-- Grant/Revoke role privileges 给用户 授予/撤销 角色权限
grant ctxapp to myName; --没有搞清意思，但是没有这句话，运行时，语句好像报错
grant exp_full_database to myName; --赋给用户 exp_full_database权限 有这个权限 就可以执行全库方式的导出
grant imp_full_database to myName; --赋给用户 imp_full_database权限 有这个权限 就可以执行全库方式的导入
-- Grant/Revoke system privileges --给用户授予/撤销系统权限
grant change notification to myName;
grant create any directory to myName;--创建任何文件夹
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb71d981f678f7c419fd677b6be6ad4a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d1f7233baddb29ac4535db51a153827/" rel="bookmark">
			肝了很久，冰河整理出这份4万字的SpringCloud与SpringCloudAlibaba学习笔记！！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面 不少小伙伴让我整理下有关SpringCloud和SpringCloudAlibaba的知识点，经过3天的收集和整理，冰河整理出这份4万字的SpringCloud与SpringCloudAlibaba学习笔记！！
文章已收录到：
https://github.com/sunshinelyz/technology-binghe
https://gitee.com/binghe001/technology-binghe
SpringCloud 服务注册中心 eureka ap 高可用 分布式容错
&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; eureka: instance: hostname: eureka7003.com #eureka服务端的实例名称 instance-id: payment8001 prefer-ip-address: true client: register-with-eureka: false #false表示不向注册中心注册自己。 fetch-registry: false #false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务 service-url: #集群指向其它eureka #defaultZone: http://eureka7002.com:7002/eureka/ #单机就是7001自己 defaultZone: http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/ #server: #关闭自我保护机制，保证不可用服务被及时踢除 #enable-self-preservation: false #eviction-interval-timer-in-ms: 2000 Ribbon 启用负载均衡 @EnableEurekaServer @EnableDiscoveryClient @LoadBalanced public RestTemplate getTemp() { return new RestTemplate(); } zookepper cp 强一致 分布式容错
&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-zookeeper-discovery&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d1f7233baddb29ac4535db51a153827/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14e9364f79fd7c19a2101d8e7f03c464/" rel="bookmark">
			下载工具IDM之——无法下载此受保护的数据其他解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 现象描述 在使用IDM进行直播流数据下载时，可能会显示如下信息：
二 解决办法 2.1 使用ffmpeg 下载配置ffmpeg后，使用下面的指令合成视频
ffmpeg -i http://ivi.bupt.edu.cn/hls/cctv1hd.m3u8 -c copy cctv1.mp4 2.2 N_m3u8DL-CLI N_m3u8DL-CLI_v2.9.5.exe打开后，直接copy直播流地址，并回车进行下载
N_m3u8DL-CLI_v2.9.5_with_ffmpeg_and_SimpleG.zip：选择下载目录后，点击go进行下载
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3912aee98f8d2316d1ba972ec9643c35/" rel="bookmark">
			求n个数的极差
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 c++求n个数得极差 ​ 极差是指一组数据中，最大值与最小值之差。
​ 现在输出一组数字，计算这组数字的极差。
输入：
​ 第一行输入一个正整数 n。（1≤n≤100）
​ 第二行输入 n 个正整数 X1,X2……Xn。
输出：
​ 输出一个数字，表示这组数据的极差。
样例输入：
3
2 6 9
样例输出：
7
#include&lt;iostream&gt; using namespace std; int main(){ int n,t; int min=99999,max=0;//最大值和最小值赋初值，方便判断 cin&gt;&gt;n; for(int i = 0; i &lt; n; i++){//输入n个整数 cin&gt;&gt;t; if(t&lt;min){ min = t; } if(t&gt;max){ max = t; } } cout&lt;&lt;max-min&lt;&lt;endl; return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92e8dd8273c721ae5d678f6ba04b0a53/" rel="bookmark">
			985高校博士生发表21篇SCI论文！总结保持高效写作的科研心得
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击上方，选择星标或置顶，不定期资源大放送！
阅读大概需要11分钟
Follow小博主，每天更新前沿干货
仅做学术分享，如有侵权，联系删除
转载于 ：中南云麓谷、中南大学交通运输工程学院、CSU交通院研究生会
站在中国高速铁路发展的风口，每项科研成果的发现与实现，都有可能助力国家交通事业更进一步。而每一项科研成果背后，都离不开矢志科研的专家学者以及即将担起交通事业发展的青年人的努力。而我们今天的主人公郭子健，正是这批青年人之一。
郭子健，交通运输工程学院载运工具运用工程专业2018级全日制博士研究生，中南大学与伯明翰大学联合培养博士生，研究方向——列车空气动力学。
今年26岁的郭子健，已经共发表SCI论文21篇，总被引123次。其中，他以第一作者或通讯作者身份发表SCI一区论文8篇，三区1篇，四区1篇，有6篇发表在中科院一区期刊上；参与国家自然科学基金、国家十三五重大专项及其他纵横向科研项目近十项，多次参与国内外学术会议；荣获国家奖学金、茅以升铁路教育专项奖学金、中南大学优秀学生标兵等荣誉。
“年少有为”，郭子健是对于这四个字的高度诠释。而他荣誉的背后是什么？达成如此成就有何秘籍？让我们一起走近郭子健，听听他的故事。
文章担使命
2018年十一月份，郭子健成功发表了自己的第一篇SCI。他记得很清楚，其主题是探讨重联列车引起的列车风问题。作为开启研究生新阶段的第一个重磅课题，郭子健对其看得很重，每天都全身心扑在论文上面。而在这一个亟待解决的问题上，这篇论文算是发表最早的一个。
第一篇SCI论文的成功，给郭子健带来了巨大的满足感和成就感。而作为一名交通人，肩负着要推动我国的交通事业发展的使命，其光荣感与责任感成为郭子健坚持发表论文的源动力。
“一年内以第一作者的身份发表四篇SCI一区论文”，这听起来，好像是不可能完成的事，而郭子健做到了。四篇论文，方向迥异，时限一年，任务艰巨。对此，郭子健说：“我习惯于就写完一个再写另一个，没有刻意去规划每一篇要用多久去写，只能在时间上只争朝夕。”
而在发表SCI论文的撰写过程中，郭子健印象最深而且难度最大的一篇正是这四篇论文之中的最后一篇——关于用隧道中的列车风来产生可再生电能的新型理念研究。“我们传统的话只做列车空气动力学，但是这一篇涉及到其他的学科领域，对我来说就完全是陌生的。”交叉学科，范围广，难度大。为此，郭子健只能靠自己一点一点摸索，从基础开始，查阅论文，请教老师，逐渐理清了自己的思路。
从一个新手小白出发，在摸索之中慢慢进步，如今在发表多篇论文之后，郭子健给我们分享到：
1.论文最重要的就是要知道写论文的主题是什么，所以说第一步就要广读文献来确定主题；之后，根据主题精读相关文献；有了一些文献经验之后，理清这篇文章的结论是想阐述哪些方面的内容，列出相应提纲。很重要的一个部分是列图表，需要明白用哪些图和表来论证主题。完成上述步骤之后，论文的骨架便搭建完毕，然后再深层次的补充一些内容和分析就基本能完成论文工作。
2.科研工作中必然离不开阅读文献，一个初学者很可能面临着“看不太懂”、“不知道从何下手”等问题，对此，郭子健的心得体会是：文献阅读我们应该首先从自己身边人的文章出发，比如师兄师姐的文章，仔细研读并虚心请教，这样可以快速弄明白课题组的研究方法和流程，随后就可以去阅读其他优秀的论文专著，拓展自己对学科掌握的宽度。“这个过程一定不能急功近利，不能一味地去完成数量目标，而是要根据自己对文献的吸收情况来弹性地改变阅读进度，自己学到的才算是自己。”
3.看论文的过程很枯燥而且看完容易忘，请问师兄在阅读文献方面有什么实用的整理方法?
这个当然要推荐文献管理软件了，我自己在用的有Notexpress和Endnote。首先是笔记功能，在阅读每一篇文献的时候，最重要的是把我们的收获和疑问记录下来，然后有时间就去回顾，温习收获并尝试解决疑问。另外我很喜欢的一个功能就是标签，这个可以帮助我们快速索引某类文献，对我这个专业来说，我会加一些比如“横风”、“列车风”和“头型”等等这样的标签给对应的文献，在后续需要回顾或引用的时候就可以马上找到，对我来说是很实用的。在查阅大量文献的过程中，做好阅读笔记是十分必要且关键的环节，需要记录文章的重点研究内容和框架。
4.无论在哪一个领域，创新性都是科研工作中至关重要且最难以实现的一点。写论文，依旧如此。“从模仿开始，融百家所长，最后走出一条自己的路。”对于论文创作，郭子健依旧建议稳步进行。通过模仿优秀论文中写作的长处，来不断完善自己的文章，熟能生巧之后就会形成自己独特的写作风格。
因此，我们在文献阅读过程中读到值得学习的地方就应该及时做好笔记，同时对读过的文献进行标签分类，回顾时，通过标签可以迅速找到自己的目标，也有助于形成自己的体系。而这背后，潜藏着艰难的文献管理工作。在此，郭子健分享他平时经常使用的文献管理工具，如Endnote、Notexpress等。
以笔筑梦，循序渐进，21篇SCI论文成为郭子健硕博之路的一个见证，而这一路程仍在继续，等待着郭子健未来新的精彩。
参天科研树
“三，二，一，发射！”火箭升空的刹那间，强大的民族自豪感拨动着郭子健的心弦。从那时起，年少的他便暗暗对自己许诺：“未来，我也要成为科研人中的一员。”
“推动研究领域方面前进一小步，用自己的力量为社会做出改变，这就是我科研的初心。”郭子健不负少年时的许诺，踏上科研路。肩负起研博生做好科研的责任，砥砺自己作为科研人的初心，郭子健用的是一个个精准的数据与一篇篇严谨的论文。科研路上，风雨兼程，对他而言，唯责任与热爱不被辜负。
师者，所以传道受业解惑也。谈到他的导师刘堂红时，他分享到：“导师很严谨，也很严肃，在这些科研人格方面，我学到了很多。”有次做仿真分析，郭子健做出了他以为很不错的数据，刘老师却说：“这些数据看起来不错了，但是肯定还有更多的深层关系，你再做做看。”这种对待科研一丝不苟的态度深深地影响到了郭子健，也为他未来的科研之路奠定下了沉稳严谨的性格基础。
“老师也不是一直都很严肃的，上次我们一起去新疆，老师真的是一改风范……”那时去新疆做科研，他生病了，刘老师则对他细心地关怀照顾，像一个贴心的朋友陪伴在他身旁。也许，这就是亦师亦友。
黎明之前总是最黑暗的，这样才能显出日出的耀眼。郭子健的科研之旅并非一帆风顺。2018年，他已在英国交流学习，同时也要跟进一个十三五专项研究，他的任务是设计一个高速列车气动外形的优化平台。对于这个未接触过的领域，他的科研工作都是从零开始：学编程，做接口，一个按钮一个按钮去完善平台的功能……遇到棘手的学术难题，网上没有答案，他只能将说明书“翻烂”，进行头脑风暴去想新点子。
测试中的bug一次次挫败着他尝试与坚持的勇气，那时他已然落入困境，却因时差而无人可以倾诉。“那时，我想过甩手给别人，自己一走了之。但是，我知道，这是不负责任的表现，我无法允许自己这样做。”郭子健选择咬牙坚持到底，柳暗花明最是风景，他做到了。项目顺利结题，得到验收专家的好评，这也许就是为那完全靠自己敲出来的4100多行代码画上的最美的句号。
用比他人更多一点的努力换来自己满意的成绩，这叫做劳有所得。躬身实践，恶劣的天气无法阻挡奔赴科研的心，这叫做身体力行。提出新领域时的质疑，不会吵到自己宁静的三分田，这叫做大胆创新。
郭子健，他仍是那个看到火箭升空会心潮澎湃的少年，未来的科研路上，他会不负少年时的许诺，向着科研奔赴山海。如今，种子已破土，正参天。
坎坷留学路
每一次努力，都是幸运的伏笔。郭子健的公派留学之路并非一帆风顺，出国资格申请期间需要自己提前联系好国外院校的指导老师，但郭子健在联系校外导师时遇到了些许阻力。“我给列车空气动力学的许多教授发送了邮件，但大部分都石沉大海，收到的回复不多……”郭子健回忆到。值得庆幸的是，郭子健终于在公派留学申请的截止时间前几日收到了来自英国伯明翰大学Hassan教授的回信。有惊无险，郭子健翻开了去往伯明翰留学的第一页。
刚到伯明翰时，长沙还是穿短袖的季节。由于地域气候的改变，郭子健在英国生活的第一周便感冒发烧了，现在郭子健回想起来依旧是苦涩地说：“发烧的那一周太痛苦了！”同时，饮食方面也和国内天差地别，一时间难以完全适应，所以郭子健需要自己动手做饭。这样以来，生活上难免占用比较多的时间。之后，郭子健开始不断调整自己的生活节奏，很快，他便完成了生活模式的切换，成功适应了留学生活的方方面面。
少年的肩，想要担起草长莺飞和清风明月，郭子健意气风发地说到：“很想能在列车空气动力这个领域做出自己的一点点贡献。”在留学期间，郭子健也是从事列车空气动力学的研究。一直将这一方向坚持下去，只是因为一份纯粹而简单的热爱。被问到想毕业之后的打算时，郭子健表示后希望自己能继续在高校从事这一领域的工作。成为交通人的8年时光，值得郭子健用未来去回馈和感恩。
在科研生活之外，郭子健也找到了自己生活的亮色。自小就爱打乒乓球的郭子健一直没有放弃这一爱好，踊跃报名参加一些乒乓球比赛，并于2018年6月获得高速中心乒乓球男单季军。“当时非常开心，抱着试一试的态度去参赛没想到收获了意外之喜。”郭子健如是说。
发光不是太阳的权利，而是每个人都可以。郭子健在周围同龄人的眼中像舞台上一位闪闪发光的主角，但其实每个人都可以找到属于自己的那一束追光。“在本科阶段就要尽早确定好自己的职业规划，清晰自己未来的发展定位是什么，有时候会带来事半功倍的惊喜。”
郭子健一直在追光，在为梦想拼搏的路上，每个人都会遇到属于自己的点点星光，最终与光同航。与交通事业齐发展，砥砺自身成长，收获一路荣光。高歌猛进，玉汝于成，与呼啸而过的中国高铁一般，郭子健必然笃行致远，不负韶华。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58f71303cb94d38d1eb07860b058108a/" rel="bookmark">
			最大报文段长度——MSS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 概念 MSS（Maximum Segment Size，最大报文长度），是TCP协议定义的一个选项，MSS选项用于在TCP连接建立时，收发双方协商通信时每一个报文段所能承载的最大数据长度
在以太网环境下，MSS=MTU-20字节TCP报头-20字节IP报头，MSS值一般就是1500-20-20=1460字节。
2. MSS的确定 MSS值只会出现在SYN报文中，即SYN=1时，才会有MSS字段值。
如图所示，服务器访问某网站时进行TCP的三次握手。
1）首先客户端会发送一个SYN请求报文，这个SYN报文的“选项”字段中会有MSS值（MSS = MUT - IP首部长度 - TCP首部长度）。该MSS值是为了告知对方最大的发送数据大小。
2）当服务器端收到SYN报文后，会向请求端返回SYN+ACK（同步确认报文）报文，其中的“选项”字段也会有MSS值。
3）通信双方选择SYN和SYN+ACK报文中最小的MSS最为此次TCP连接的MSS，从而达到通信双发协商MSS的效果。
结论: 在第二次握手后就可以确定TCP中最大传输报文（MSS）大小。
3. 确定MSS作用 在tcp交互之前避免分片的产生。
4. MTU MTU 最大传输单元（Maximum Transmission Unit，MTU）用来通知对方所能接受数据服务单元的最大尺寸，说明发送方能够接受的有效载荷大小。
利用ifconfig命令可以查看当前mtu的大小。
5. MTU和MSS的区分 最大报文段长度（MSS）与最大传输单元（Maximum Transmission Unit, MTU）均是协议用来定义最大长度的。
MTU应用于OSI模型的第二层数据链接层，并无具体针对的协议。MTU限制了数据链接层上可以传输的数据包的大小，也因此限制了上层（网络层）的数据包大小。例如，如果已知某局域网的MTU为1500字节，则在网络层的因特网协议（Internet Protocol, IP）里，最大的数据包大小为1500字节（包含IP协议头）。
MSS针对的是OSI模型里第四层传输层的TCP协议。因为MSS应用的协议在数据链接层的上层，MSS会受到MTU的限制。
6. PMTUD(路径MTU) 作用: 通过由中间设备修改经过其转发的TCP SYN报文中的MSS值，让中间设备参与进TCP 三次握手时SYN报文的MSS协商来避免分片。
一张参考图
部分参考:
https://zhuanlan.zhihu.com/p/139537936
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e499caf3e3e194cce2a3d9ae2b847ab4/" rel="bookmark">
			voc数据集的map计算方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		相关概念 map mean average precision，表示各类别ap的平均值ap average precision，表示P-R曲线下的面积p precision，查准率，p = T P/ (T P + F P)r recall，召回率，r = T P/(T P + F N)TP true positive，在detection中，表示成功检测到某个ground truth bounding box的预测框的数量FP false positive，表示没能匹配到某个ground truth bounding box的预测框的数量FN false negative，表示没能检测出来的ground truth bounding box 注意FN和FP是不一样的判定阈值 表示判断预测框成功检测出某个gt bbox的iou阈值，即iou(dt, gt)大于该阈值时，才认为dt成功匹配到了gt，在coco style的map计算中，存在多个判定阈值0.5 , 0.55 , 0.6 , . . . , 0.95。IoU：交并比 VOC数据集map的计算方式 描述 voc数据集map的计算方式包括两个
Pascal Voc 2007 ，11点法求AP。voc 2010-2012 ，计算平滑后的曲线与recall轴围成的面积。 代码解析 检测出来的bbox包含score和bbox，按照score降序排序，所以每添加一个样本，就代表阈值降低一点（真实情况下score降低，iou不一定降低）。这样就是可以有很多种阈值，每个阈值情况下计算一个prec和recall。
d:对模型检测到的bbox循环：
j:对该bbox对应的图像(i)中所有的gt循环：
如果bb和bbgt有重叠：
计算ov=重叠部分面积/联合的面积，并记录ovmax,jmax
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e499caf3e3e194cce2a3d9ae2b847ab4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/121bc72f4e07f5b313a2ad0b203672a1/" rel="bookmark">
			StringUtils.isAlphanumeric(String)方法检查中文是通过的，需要注意。它不能用来检测字符串是否只包含英文和数字。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在org.apache.commons.lang3.StringUtils类中，有一个方法isAlphanumeric(String)。它的用途是判断字符串是否仅由字母和数字构成，如果含有特殊字符是不通过的。但是中文可以通过。原码如下：
/** * &lt;p&gt;Checks if the CharSequence contains only Unicode letters or digits.&lt;/p&gt; * * &lt;p&gt;{@code null} will return {@code false}. * An empty CharSequence (length()=0) will return {@code false}.&lt;/p&gt; * * &lt;pre&gt; * StringUtils.isAlphanumeric(null) = false * StringUtils.isAlphanumeric("") = false * StringUtils.isAlphanumeric(" ") = false * StringUtils.isAlphanumeric("abc") = true * StringUtils.isAlphanumeric("ab c") = false * StringUtils.isAlphanumeric("ab2c") = true * StringUtils.isAlphanumeric("ab-c") = false * &lt;/pre&gt; * * @param cs the CharSequence to check, may be null * @return {@code true} if only contains letters or digits, * and is non-null * @since 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/121bc72f4e07f5b313a2ad0b203672a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f6ea55041eebf413fd6183ad228bf27/" rel="bookmark">
			Base64编码原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微信搜索【NO编程】，关注这个不一样的公众号。
个人网站：www.newobject.cc
版权声明：本文为原创文章，转载请注明出处。
什么是 Base64 编码 Base64 编码是最常见的编码方式，基于 64 个可打印字符来表示任意二进制数据的方法，是从二进制转换到可见字符的过程。
使用场景 数据加密或签名通过 Base64 转换为字符串存储或传输。
不能传输文件的网络环境可以转换 Base64 进行网络传输。
在文本资源(如 HTML 和 CSS文件)中嵌入图片文件或其他二进制资源。
在 URL、网页中传输少量二进制数据等等。
Base64 编码原理 原理是把每 3 个字节（每个字节为 8 位, 3 个字节为 24 位）重新划为 4 组（每组为 6位，高位补两个 0 为 8 位后作为一个新字节，划分后的每个字节数值的范围是 00000000 - 00111111 即十进制的 0 - 63），然后将划分后的字节的数值作为索引查编码表，获得相应的字符，从而得到编码后的字符串。通过 64 个字符来对任意数据进行编码，因此称为 Base64。
Base64 标准编码表：
以字符串 “NEW” 为例，对其 Base64 编码：
如果要编码的字节数不能被 3 整除，最后会多出 1 个或 2 有效的字节。将这样处理，将其用 0 补充至 6 的最小倍数位后，剩余的空位将使用 “=” 填充处理。例如：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f6ea55041eebf413fd6183ad228bf27/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4832dca13f0f526df5ed9e2d7f977454/" rel="bookmark">
			VS2019多个main主函数的解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在同一个项目中创建了两个.cpp文件，其中的两个main主函数起了冲突，一开始的问题是
fatal error LNK1169: 找到一个或多个多重定义的符号
随后找到了这个bug的解决方法：
右击项目，属性，配置属性，链接器，命令行，其他选项中添加下行数据
/FORCE:MULTIPLE
但是紧接着又出现了一个bug，在第二个.cpp文件调试程序的过程发现，运行的代码是第一个.cpp文件。
所以花了一点时间去研究出了解决方法
1.
创建项目来调试程序的时候，如果有多个.cpp文件，可以将所有的.cpp文件加上注释，需要调试哪个文件的代码的时候再取消注释，从而做到多个.cpp文件可以放在同一个项目并且可以独立运行。
ps：快速注释Ctrl+K+C，取消注释Ctrl+K+U,可以同时按住三个一起，也可以先按ctrl+K，再按ctrl + C/U
2.
右键不需要参与调试的.cpp文件，属性，从生成中排除，点击是。
参考文章
1.
https://blog.csdn.net/panjielove/article/details/107646284
2.
https://blog.csdn.net/m0_46179147/article/details/105170477
3.
https://blog.csdn.net/qq_43807000/article/details/104803400
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70bc9c67a4efb1c39a4cfc4ac5f0ba46/" rel="bookmark">
			mysql里all什么意思_mysql中all的用法是什么
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mysql中all的用法：1、all是“对于子查询返回的列中的所有值，如果比较结果为true，则返回true”；2、all可以与【=、&gt;、&gt;=、】结合是来使用，分别表示等于、大于、大于等于、小于、小于等于、不等于。
mysql中all的用法：
最近一直在练习MYSQL的多表查询，基本上每个查询语句我都会写至少两次：一次join连接，一次子查询。来对比一下MYSQL在不同的查询方式下的工作方式和效率。在子查询有any、all、some这些关键词。
any,all关键字必须与一个比较操作符一起使用。any关键词可以理解为“对于子查询返回的列中的任一数值，如果比较结果为true，则返回true”。all的意思是“对于子查询返回的列中的所有值，如果比较结果为true，则返回true”
any 可以与=、&gt;、&gt;=、结合起来使用，分别表示等于、大于、大于等于、小于、小于等于、不等于其中的任何一个数据。
all可以与=、&gt;、&gt;=、结合是来使用，分别表示等于、大于、大于等于、小于、小于等于、不等于其中的其中的所有数据。
举个例子：
select s1 from t1 where s1 &gt; any (select s1 from t2);
假设any后面的s1返回了三个值，那其实就等价于
select s1 from t1 where s1 &gt; result1 or s1 &gt; result2 or s2 &gt; result3
而all的用法相当于把上述语句的‘or’缓冲‘and’
说道这你可能已经知道了any和or常用于两表的对比，当你不知道where后面具体值是可以用any，all帮你判定。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08308fe958b6bf87e1e07030dd4976e6/" rel="bookmark">
			vue手写双向绑定实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 认识Object.defineProperty() // Object.defineProperty 三个参数 // 第一个参数，属性所在的对象 // 第二个参数，要操作的属性 // 第三个参数，被操作属性的特性 // 格式是 {} //configurable,enumerable,value,writable // set 写入属性时触发 // get 读取属性 let obj = {value:'kk'} Object.defineProperty(obj, "value", { get: function() { console.log('get'); return 1;//这里不可以写obj.value会死循环，疯狂get，因为obj.value就是给一个读取操作 }, set: function(newValue) { console.log('set'); //obj.value = newValue 同理这里也会死循环 console.log(newValue) } }); Object.defineProperty()在MDN 详细介绍看这里
2. 简单了解发布订阅模式
本人也不是很懂设计模式，后期补充。
简单描述：这个模式就像是你订阅关注了科比，以后有科比的消息会主动推送给你。需要有一个订阅器，一个发布器。
订阅器：就像是存放当前订阅者信息的容器。 举个简单的例子： 我的手机，里面有我的身份讯息，比如我喜欢某岛国知名动作女星--深田某美，咳咳不对，是科比,我订阅了科比， 那么我的手机像是监听器一样，帮我盯着科比的动向，科比不单单是一个人的青春。别人也可以通过订阅器订阅科比 当然也可以订阅别人，但是手机作为订阅器记录了我的信息我的喜好，并且手机收到了我订阅的新闻之后会告诉我。 发布器：是存放所有订阅器的容器和发布装置。 里面存放了所有的订阅信息，有某美的,有科比的，有周星星的，这里他负责帮我监听科比的动向。 一旦有消息，便会给订阅器的订阅者发送消息 原理核心 1-5准备工作
6 代码部分
1.html部分
&lt;div id="app"&gt; &lt;span&gt;改变我：&lt;/span&gt; &lt;input type="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/08308fe958b6bf87e1e07030dd4976e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23194f47b3b0fe4f3bc1dffbe00cd36d/" rel="bookmark">
			mysql数据库事务索引_mysql数据库 索引 事务和事务回滚
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mysql索引
索引相当于书的目录
优点：加快数据的查询速度
缺点：占物理存储空间，添加，删除，会减慢写的速度
查看表使用的索引
mysql&gt; show index from 表名\G;(\G分行显示)
mysql&gt; show index from mysql.db;
+-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
| Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |
+-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
| db | 0 | PRIMARY | 1 | Host | A | NULL | NULL | NULL | | BTREE | | |
| db | 0 | PRIMARY | 2 | Db | A | NULL | NULL | NULL | | BTREE | | |
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23194f47b3b0fe4f3bc1dffbe00cd36d/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/383/">«</a>
	<span class="pagination__item pagination__item--current">384/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/385/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>