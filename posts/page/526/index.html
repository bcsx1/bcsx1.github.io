<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9abfd66c6af306aa0f6d156ceff737bf/" rel="bookmark">
			字典格式化字符串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 字典格式化字符串时，在转换说明符中的%字符后面加上键值，并用括号括起来，后面在跟上其他说明元素。只要所加上的键值可以在字典中找到，就可以获得任意数量得转换说明符。
&gt;&gt;&gt; x = {'name':'jack','age':'12','addr':'river road 12th'} &gt;&gt;&gt; print ("%s 's age is %s" %x) &gt;&gt;&gt; print ("%(name)s 's age is %(age)s" %x) jack 's age is 12 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/deb1324ef3331f14159f32d12df04430/" rel="bookmark">
			升级xcode9 自动打包失败问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于升级xcode9后，自动打包出现错误。
error: exportArchive: "xxx.app" requires a provisioning profile with the Push Notifications feature.
解决方案：
可以手动Archive打出ipa，然后查看 ExportOptions.plist内容，会发现和原来的plist，相差几组数据。
provisioningProfiles 和 signingCertificate 添加这两个key就可以。
这是我的debug option：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a521861efd748a8c5ae3379ea31c5d2/" rel="bookmark">
			【解题报告】Kattis - adjoin 树形dp
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目大意：有n个点，m条边，形成2颗以上的树，为了加上若干条边使得整个图连通后任意两点之间的最长距离最短，求该最短的最长距离。
解题思路：用树形dp求出初始每棵树中最长的链，最终答案只有两种情况，两点分别在两棵树上或两点在同一棵树上。如果两点在两棵树上，则将每棵树最长链的长度从大到小排序，计为a1,a2,a3...an，答案为(a1+1)/2+(a2+1)/2+1和a2+a3+2。因为我们把每棵树连到最长链的中点，则除了最长链所在的树，其余的树互相之间相互连通需要加两条边。那么答案就是两点所在树形成的链的一半(向上取整)加上2。而如果两点在同一颗树上，只需要在计算最长链的时候保存最长链即可。最后将两种情况的答案取较大值即可。
代码：
#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;#include&lt;cstdio&gt;#include&lt;stdio.h&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;sstream&gt;#include&lt;istream&gt;#include&lt;ostream&gt;#include&lt;sstream&gt;using namespace std;typedef long long ll;#define INF 0x3f3f3f3fconst int maxn = 100010;struct edge {int to, next;}e[maxn &lt;&lt; 1];int head[maxn], f[maxn], dp[maxn], tmp, ans, a[maxn];bool vis[maxn], ok;int cnt, sz;int getf(int x) { return f[x] == x ? x : f[x] = getf(f[x]); }bool cmp(int x, int y) { return x &gt; y; }void init(int n){memset(head, -1, sizeof head);memset(e, 0, sizeof e);memset(vis, 0, sizeof vis);memset(dp, 0, sizeof dp);ans = 0;for (int i = 0; i &lt; n; i++){f[i] = i;}}void add(int x, int y){e[cnt].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a521861efd748a8c5ae3379ea31c5d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f394adc89dc1ae40bfe47769a550c314/" rel="bookmark">
			pdf英文翻译中文
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		**软件技术书籍往往都是出英文版。英文不是很好的同学想要看就要等中文翻译后出版的书籍才能看。 这样的话，技术书籍已经更新了好几个版本了。因此想要看得懂英文书，现在有个方法。 下载好英文版的书籍。 这个是pdf的书籍，之后用word打开(好像要2013以后的版本)我自己装的是2017版的 打开之后 之后点击审阅，有个翻译 选好之后点击确定。 如果页数比较多的话会打开比较慢，翻译之后会弹出个框让你确认 点击确认会用浏览器打开 翻译过后的样式基本是按照pdf的格式 现在才翻译到38% 现在已经翻译了100%。 如果觉得翻译不对，鼠标移动上去，会显示出原来的英文
有时候会有些图片显示不出来，要参考英文版的一起看，当然有时候翻译也不全对。也要跟英文版结合着来看。 是不是感觉很棒，去试一试吧。**
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ee6a9e438673626f33b000269f01ed0/" rel="bookmark">
			jQuery对象的遍历的三种方法 之 对多选框select反选
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;jQuery对象的遍历&lt;/title&gt; &lt;script type="text/javascript" src='./js/jquery.js'&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;遍历jQuery对象的内部的DOM对象&lt;/h1&gt; &lt;input type="button" value="反选" οnclick="fan()" /&gt; &lt;p&gt;选择1:&lt;input type="checkbox" /&gt;&lt;/p&gt; &lt;p&gt;选择1:&lt;input type="checkbox" /&gt;&lt;/p&gt; &lt;p&gt;选择1:&lt;input type="checkbox" /&gt;&lt;/p&gt; &lt;p&gt;选择1:&lt;input type="checkbox" /&gt;&lt;/p&gt; &lt;p&gt;选择1:&lt;input type="checkbox" /&gt;&lt;/p&gt; &lt;/body&gt; &lt;script type="text/javascript"&gt; //方法一 面向过程的思路 function fan(){ var inp=$('input:checkbox');//获取input 取出的是jq对象 for(var i=0;i&lt;inp.length;i++){ //循环取出每一行的input //判断input是否有checked 这里inp[i]是dom对象,还要加$()转成dom对象 if($(inp[i]).prop('checked')==true){ $(inp[i]).prop('checked',false);//改checked值为folse }else { $(inp[i]).prop('checked',true); 改checked值为true } } } //方法二 面向函数式的思路， 回调函数 function fan(){ $('input:checkbox').each(function(){ console.log(this); //console.log($('input:checkbox')); if($(this).prop('checked')==true){ $(this).prop('checked',false);//改checked值为folse }else { $(this).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ee6a9e438673626f33b000269f01ed0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3bb5b598ebd3eb6bc4cf8d49bc4dd77/" rel="bookmark">
			JQ之事件委托 用on()给父级绑定委托事件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 &lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset="utf-8"&gt;
&lt;title&gt;JQ之事件委托&lt;/title&gt;
&lt;script type="text/javascript" src="./js/jquery.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;input type="button" name="" value="添加li"&gt;
&lt;ul&gt;
&lt;li&gt;春&lt;/li&gt;
&lt;li&gt;夏&lt;/li&gt;
&lt;li&gt;秋&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;script type="text/javascript"&gt;
$('ul').on('click','li',function(){ //给li的父标签绑定委托事件
alert($(this).text());//点击时候弹出JQ获取li里文本内容的 //alert(this.innerHTML);//JS里获取里文本内容的方法
console.log(this);
});
// $('ul').off('click','li');
$('input').bind('click',function(){
$('li:first').before('&lt;li&gt;冬&lt;/li&gt;');
});
&lt;/script&gt;
&lt;/html&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4e38bf733d1c975bc46bd8502eaf74b/" rel="bookmark">
			KITTI与Cityscapes简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		KITTI由德国卡尔斯鲁厄理工学院和丰田美国技术研究院联合创办，是目前国际上最大的自动驾驶场景下的计算机视觉算法评测数据集。用于评测目标（机动车、非机动车、行人等）检测、目标跟踪、路面分割等计算机视觉技术在车载环境下的性能。
KITTI包含市区、乡村和高速公路等场景采集的真实图像数据，每张图像中多达15辆车和30个行人，还有各种程度的遮挡。KITTI数据集中，目标检测包括了车辆检测、行人检测、自行车等三个单项，目标追踪包括车辆追踪、行人追踪等两个单项，道路分割包括urban unmarked、urban marked、urban multiple marked三个场景及前三个场景的平均值urban road等四个单项。
Cityscapes数据集则是由奔驰主推，提供无人驾驶环境下的图像分割数据集。用于评估视觉算法在城区场景语义理解方面的性能。Cityscapes包含50个城市不同场景、不同背景、不同季节的街景，提供5000张精细标注的图像、20000张粗略标注的图像、30类标注物体。用PASCAL VOC标准的 intersection-over-union （IoU）得分来对算法性能进行评价。 Cityscapes数据集共有fine和coarse两套评测标准，前者提供5000张精细标注的图像，后者提供5000张精细标注外加20000张粗糙标注的图像。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/345f6e47d2b6864e42c462a7536dfe10/" rel="bookmark">
			sql注入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、JDBC：使用PreparedStatement防止SQL注入 http://blog.csdn.net/javy_codercoder/article/details/49276653
2、mybatis深入理解之 # 与 $ 区别以及 sql 预编译 ${}方式无法防止sql注入; $一般用入传入数据库对象，比如数据库表名;注意：mybaties排序时使用order by 动态参数时需要注意，使用${}而不用#{}; xxxx： 将传入的数据直接显示生成在sql中，对于字符串数据，需要手动加上引号。 #{xxxx}：会给数据加双引号
mybatis 在对 sql 语句进行预编译之前，会对 sql 进行动态解析， ${ } 的变量的替换阶段是在动态 SQL 解析阶段，而 #{ }的变量的替换是在 DBMS 中。
原文：http://blog.csdn.net/hanchao_h/article/details/53640720
mybatis中的sql注入问题: –mybatis框架作为一款半自动化的持久层框架，其sql语句都要我们自己来手动编写，这个时候当然需要防止sql注入。其实Mybatis的sql是一个具有“输入+输出”功能，类似于函数的结构，如下：
&lt;select id=“getBlogById“ resultType=“Blog“ parameterType=”int”&gt; select id,title,author,content from blog where id=#{id} &lt;/select&gt; 这里，parameterType标示了输入的参数类型，resultType标示了输出的参数类型。回应上文，如果我们想防止sql注入，理所当然地要在输入参数上下功夫。上面代码中高亮部分即输入参数在sql中拼接的部分，传入参数后，打印出执行的sql语句，会看到sql是这样的： select id,title,author,content from blog where id = ? 不管输入什么参数，打印出的sql都是这样的。这是因为mybatis启用了预编译功能，在sql执行前，会先将上面的sql发送给数据库进行编译，执行时，直接使用编译好的sql，替换占位符“？”就可以了。因为sql注入只能对编译过程起作用，所以这样的方式就很好地避免了sql注入的问题。 mybatis是如何做到sql预编译的呢？其实在框架底层，是jdbc中的PreparedStatement类在起作用，PreparedStatement是我们很熟悉的Statement的子类，它的对象包含了编译好的sql语句。这种“准备好”的方式不仅能提高安全性，而且在多次执行一个sql时，能够提高效率，原因是sql已编译好，再次执行时无需再编译。 话说回来，是否我们使用mybatis就一定可以防止sql注入呢？当然不是，请看下面的代码：
&lt;select id=“orderBlog“ resultType=“Blog“ parameterType=”map”&gt; select id,title,author,content from blog order by ${orderParam} &lt;/select&gt; 仔细观察，内联参数的格式由“#{xxx}”变为了 xxx。如果我们给参数“orderParam”赋值为”id”,将sql打印出来，是这样的：selectid,title,author,contentfromblogorderbyid显然，这样是无法阻止sql注入的。在mybatis中，” {xxx}”这样格式的参数会直接参与sql编译，从而不能避免注入攻击。但涉及到动态表名和列名时，只能使用“{xxx}”这样的参数格式，所以，这样的参数需要我们在代码中手工进行处理来防止注入。 结论：在编写mybatis的映射语句时，尽量采用“#{xxx}”这样的格式。若不得不使用“{xxx}”这样的参数，要手工地做好过滤工作，来防止sql注入攻击。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/345f6e47d2b6864e42c462a7536dfe10/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7fa9794c55018bb18faae2d7c5fa3216/" rel="bookmark">
			分治法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分治算法 分治策略:对于一个规模为n的问题,若该问题比较容易解决(比如规模较小)则直接解决,否则将其分解为k个规模较小的子问题.这些子问题互相独立且与原问题形式相同,递归地解决这些子问题,然后将各子问题的解合并得到原问题解.这种算法设计策略叫做分治法. 分治法解决的问题: (1),二分搜索 (2),最大整数乘法 (3),Strassen矩阵乘法 (4),棋盘覆盖 (5),合并排序 (6),快速排序 (7),线性时间选择排序 (8),最接近点对问题 (9),循环赛日程表 (10),汉诺塔 例: 最大子数组问题 天数: 1 2 3 4 5 6 价格: 12 15 15 16 13 15 变化: 3 0 1 -3 2
3 0 1 -3 2 low mid high 共3种情况: 1,最大子数组开始下标,结束下标都在[low,mid]范围内 2,最大子数组开始下标,结束下标都在[mid,high]范围内 3,最大数组开始下标在mid前,结束下标在mid+1后. 相对3种情况: 相对于上面1 2两种情况采用递归方法。 分治法在每一层递归上都有三个步骤： 分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题； 解决：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题； 合并：将各个子问题的解合并为原问题的解。 第3种就直接for查找在mid前的开始下标和mid+1后的结束下标，然后把两个计算和相加就好了。 代码块: //最大子数组问题 class Program { //暴力求解 void Violence() { int[] priceArray = { 12, 15, 15, 16, 13, 15 }; int[] priceFluctuationArray = new int[priceArray.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7fa9794c55018bb18faae2d7c5fa3216/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce23913e27867d4b533168fd8e47fb62/" rel="bookmark">
			5类系统推荐算法,非常好使,非常全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文链接：http://blog.csdn.net/u010670689/article/details/71513133
◆ ◆ ◆
序言
最近因为PAC平台自动化的需求，开始探坑推荐系统。这个乍一听去乐趣无穷的课题，对于算法大神们来说是这样的：
而对于刚接触这个领域的我来说，是这样的：
在深坑外围徘徊了一周后，我整理了一些推荐系统的基本概念以及一些有代表性的简单的算法，作为初探总结，也希望能抛砖引玉，给同样想入坑的伙伴们提供一些思路。
◆ ◆ ◆
什么是推荐系统
1. 什么是推荐系统？
推荐系统是啥？
如果你是个多年电商（剁手）党，你会说是这个：
如果你是名充满文艺细胞的音乐发烧友，你会答这个：
如果你是位活跃在各大社交平台的点赞狂魔，你会答这个：
没错，猜你喜欢、个性歌单、热点微博，这些都是推荐系统的输出内容。从这些我们就可以总结出，推荐系统到底是做什么的。
目的1. 帮助用户找到想要的商品（新闻/音乐/……），发掘长尾
帮用户找到想要的东西，谈何容易。商品茫茫多，甚至是我们自己，也经常点开淘宝，面对眼花缭乱的打折活动不知道要买啥。在经济学中，有一个著名理论叫长尾理论（The Long Tail）。
套用在互联网领域中，指的就是最热的那一小部分资源将得到绝大部分的关注，而剩下的很大一部分资源却鲜少有人问津。这不仅造成了资源利用上的浪费，也让很多口味偏小众的用户无法找到自己感兴趣的内容。
目的2. 降低信息过载
互联网时代信息量已然处于爆炸状态，若是将所有内容都放在网站首页上用户是无从阅读的，信息的利用率将会十分低下。因此我们需要推荐系统来帮助用户过滤掉低价值的信息。
目的3. 提高站点的点击率/转化率
好的推荐系统能让用户更频繁地访问一个站点，并且总是能为用户找到他想要购买的商品或者阅读的内容。
目的4. 加深对用户的了解，为用户提供定制化服务
可以想见，每当系统成功推荐了一个用户感兴趣的内容后，我们对该用户的兴趣爱好等维度上的形象是越来越清晰的。当我们能够精确描绘出每个用户的形象之后，就可以为他们定制一系列服务，让拥有各种需求的用户都能在我们的平台上得到满足。
◆ ◆ ◆
推荐算法
算法是什么？我们可以把它简化为一个函数。函数接受若干个参数，输出一个返回值。
算法如上图，输入参数是用户和item的各种属性和特征，包括年龄、性别、地域、商品的类别、发布时间等等。经过推荐算法处理后，返回一个按照用户喜好度排序的item列表。
推荐算法大致可以分为以下几类[1]：
基于流行度的算法
协同过滤算法
基于内容的算法
基于模型的算法
混合算法
2.1 基于流行度的算法
基于流行度的算法非常简单粗暴，类似于各大新闻、微博热榜等，根据PV、UV、日均PV或分享率等数据来按某种热度排序来推荐给用户。
这种算法的优点是简单，适用于刚注册的新用户。缺点也很明显，它无法针对用户提供个性化的推荐。基于这种算法也可做一些优化，比如加入用户分群的流行度排序，例如把热榜上的体育内容优先推荐给体育迷，把政要热文推给热爱谈论政治的用户。
2.2 协同过滤算法
协同过滤算法(Collaborative Filtering, CF)是很常用的一种算法，在很多电商网站上都有用到。CF算法包括基于用户的CF(User-based CF)和基于物品的CF(Item-based CF)。
基于用户的CF原理如下：
分析各个用户对item的评价（通过浏览记录、购买记录等）；
依据用户对item的评价计算得出所有用户之间的相似度；
选出与当前用户最相似的N个用户；
将这N个用户评价最高并且当前用户又没有浏览过的item推荐给当前用户。
示意图如下：
基于物品的CF原理大同小异，只是主体在于物品：
分析各个用户对item的浏览记录。
依据浏览记录分析得出所有item之间的相似度；
对于当前用户评价高的item，找出与之相似度最高的N个item；
将这N个item推荐给用户。
示意图如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce23913e27867d4b533168fd8e47fb62/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f67d1986755f8e1d02ddcae65b295cc/" rel="bookmark">
			深度学习入门篇--手把手教你用 TensorFlow 训练模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		欢迎大家前往腾讯云技术社区，获取更多腾讯海量技术实践干货哦~
作者：付越 导语 Tensorflow在更新1.0版本之后多了很多新功能，其中放出了很多用tf框架写的深度网络结构（https://github.com/tensorflow/models ），大大降低了开发难度，利用现成的网络结构，无论fine-tuning还是重新训练方便了不少。最近笔者终于跑通TensorFlow Object Detection API的ssd_mobilenet_v1模型，这里记录下如何完整跑通数据准备到模型使用的整个过程，相信对自己和一些同学能有所帮助。
Object Detection API提供了5种网络结构的预训练的权重，全部是用COCO数据集进行训练，这五种模型分别是SSD+mobilenet、SSD+inception_v2、R-FCN+resnet101、faster RCNN+resnet101、faster RCNN+inception+resnet101。各个模型的精度和计算所需时间如下。下面及介绍下如何使用Object Detection去训练自己的模型。
这里TensorFlow的安装就不再说明了，网上的教程一大把，大家可以找到很详尽的安装TensorFlow的文档。
训练前准备： 使用protobuf来配置模型和训练参数，所以API正常使用必须先编译protobuf库，这里可以下载直接编译好的pb库（https://github.com/google/protobuf/releases ），解压压缩包后，把protoc加入到环境变量中：
$ cd tensorflow/models $ protoc object_detection/protos/*.proto --python_out=. （我是把protoc加到环境变量中，遇到找不到*.proto文件的报错，后来把protoc.exe放到models/object_detection目录下，重新执行才可以）
然后将models和slim（tf高级框架）加入python环境变量：
PYTHONPATH=$PYTHONPATH:/your/path/to/tensorflow/models:/your/path/to/tensorflow/models/slim 数据准备： 数据集需要转化成PASCAL VOC结构，API提供了create_pascal_tf_record.py，把VOC结构数据集转换成.record格式。不过我们发现更简单的方式，Datitran提供一种更简单生产.record格式的方法。
首先需要先要标注图像相应标签，这里可以使用labelImg工具。每标注一张样本，即生成一个xml的标注文件。然后，把这些标注的xml文件，按训练集与验证集分别放置到两个目录下，在Datitran提供了xml_to_csv.py脚本。这里只要指定标注的目录名即可。接下来，然后需要我们把对应的csv格式转换成.record格式。
def main(): # image_path = os.path.join(os.getcwd(), 'annotations') image_path = r'D:\training-sets\object-detection\sunglasses\label\test' xml_df = xml_to_csv(image_path) xml_df.to_csv('sunglasses_test_labels.csv', index=None) print('Successfully converted xml to csv.') 调用generate_tfrecord.py，注意要指定–csv_input与–output_path这两个参数。执行下面命令：
python generate_tfrecord.py --csv_input=sunglasses_test_labels.csv --output_path=sunglass_test.record 这样就生成了训练及验证用的train.record与test.record。接下来指定标签名称，仿照models/ object_detection/data/ pet_label_map.pbtxt，重新创建一个文件，指定标签名。
item { id: 1 name: 'sunglasses' } 训练： 根据自己的需要，选择一款用coco数据集预训练的模型，把前缀model.ckpt放置在待训练的目录，这里meta文件保存了graph和metadata，ckpt保存了网络的weights，这几个文件表示预训练模型的初始状态。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f67d1986755f8e1d02ddcae65b295cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1877d4d7c8a779286a9f16c10f03bdff/" rel="bookmark">
			ping 不通百度问题的解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ping 不通百度问题的解决 问题： 网络能够ping通百度的ip地址，115.239.210.27这个ip地址，但是ping www.baidu.com长时间等待无反应。 解决方式： 碰到这个问题两次了，每次都挺无奈的。第一次解决是通过回退快照的方式，昨晚上再次遇到这个问题了。然后用了一会儿虚拟机，发现又能ping通github，baidu了。奇怪。 这个错误是因为服务器无法识别www.baidu.com这个域名 然后尝试分别在windows和服务器上ping 了一下这个域名，果然windows上可以ping通，而linux上不行，又试了几个常用的域名，结果一样。。。
提示unknown host，可以帮助我们确定这是域名服务器并没有工作。今天在网上找了一下资料。找到解决途径。 1, 编辑/etc下面的文件resolv.conf,如果没有这个文件就新建一个。 2， 在文件的内容尾部添加一行：
nameserver:8.8.8.8 3, 保存，退出该文件，然后重启网络【注意：此步骤不能执行，不然会覆盖文件/etc/resolv.conf。这样你的修改就不起作用了】
systemctl restart network 然后就可以解决这个问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a44fa19c178d8380488727380354266/" rel="bookmark">
			maven导入jar包报错解决办法之一
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境：win10,由于要出差，并根据客户的要求修改调整代码，所以我把项目部署到我的笔记本上，我把自定义的maven仓库拷贝到我笔记本的maven仓库下，结果不管如何更新都显示找不到对应的jar，并报错
解决办法，找到报错的依赖，并到对应的仓库中删除掉配置文件（.lastUpdate）即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30afcc5b22e7ef8b87b3f9e0771f6d0b/" rel="bookmark">
			面试经验小点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：南极 链接：https://www.zhihu.com/question/23858584/answer/150506189 来源：知乎 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 注：适用于工作一到三年有一定经验的Java后端人员，我一共面试了五家公司，收到四个offer，每天跑来跑去也很累，最后的的offer很满意之后就把其他的面试和offer都推掉了。入职前把这段时间的一点经验写下来，希望能帮助到跟我境况差不多的兄弟姐妹。
准备
机会永远都是留给有准备的人 当你决定离职之前，你就应该开始为下一份工作做准备了。 那么，该准备什么呢？ 我建议是第一是跟语言无关的部分，也就是所谓的基本功。具体也就是我们大学本科里面最头疼的那些东西，数据结构算法，还有一些计算机网络的基本知识。 鉴于这个东西实在很枯燥，我不建议大家去看那些黑皮书，反正我是真的是看不下去啊。 那么问题来了，看什么？ 书籍我推荐：大话数据结构。 视频我推荐：小甲鱼的的课程。网易云课堂：数据结构和算法
首先，书里面的代码虽然是用C语言写的，但我相信语言大家都还是有一点c语言基础的，再者说语言里面很多东西都是通用的。而且正好可以尝试用java再写一遍，这样效果更好。如果不想买书的，可以上网找找pdf版本，找不到我这里也有，不过还是建议买一本。而视频为什么是这个呢？因为小甲鱼就是按照这个书来讲的，配合大话数据结构相得益彰，就是相当于教师加上教材。书里面看不懂的地方都可以好好再听一遍小甲鱼的讲解应该就差不多了。小甲鱼除了讲基本的数据结构，还穿插了很多的经典算法问题的解决方案，最棒的地方是都是c语言写的啊，我们想要现成的都没有，所以跟着看，自己写啦。
学习完基本的数据结构，就Java的数据结构相关的类实现原理，比如LinkedList，ArrayList，HashMap，TreeMap这一类的。结合api去看，很多你之前不懂得地方会恍然大悟。
除了数据结构，需要长时间准备还应该有设计模式。
虽然说有23种设计模式，但是我觉得大家掌握最常用和经典的十个左右就差不多了。剩下的大概了解即可。
书籍我推荐：head first 设计模式 ／大话设计模式 两者随意选一本即可，或者两本对照着看也是可以的。 看的时候记住最重要的一点： 不要光顾着看！不要光顾着看！不要光顾着看！
比如你学习完了观察者模式，已经大概了解了其实现原理。那么现在合上书本，仔细在你的项目中想一下，哪里是符合观察者模式的应用场景的？ 你又是怎么实现的？如果要改应该怎么改呢？ 如果你找到了符合的地方，那么你就把原来的设计用观察者模式重新写下来。 注意，不要随便用在生产上，你现在只是要充分理解这个模式，而和实际结合是最好的学习方式。而当你写完了到底要不要放在生产上，你可以先和你的技术组长说一下，设计模式切记不要生搬硬套。
如果你没有在你的项目中想到合适的应用场景，那么没关系，你就自己想一个区别于书上的例子，自己独立完成。
每个模式都自己写一遍实现逻辑，估计当你写的时候肯定有不理解的地方，这时候就是你撕开的地方了，到底为什么这么写，这么写好在哪里，完成了时候就已经基本掌握这个模式了。然后还有最后一步，那就是写博客。
不知道大家有没有听过学习的金字塔？ 简单来说，学习的方式不同最后能记住的东西差了很多。
第一种，“听讲”，这种我们最常用的方式，学习效果最低的，内容只能留下5%。 第二种，通过“阅读”方式学到的内容，可以保留10%。 第三种，用“声音、图片”的方式学习，可以达到20%。 第四种，是“示范”，采用这种学习方式，可以记住30%。 第五种，“小组讨论”，可以记住50%的内容。 第六种，“做中学”或“实际演练”，可以达到75%。 最后一种在金字塔基座位置的学习方式，是“教别人”或者“马上应用”，可以记住90%的学习内容。
看到这里明白了吧？ 写博客就是把你的理解交给别人，是最好的学习方式，而且你把你的博客放在电子简历上，绝对是很棒的加分项。 我的面试官最后跟我说，录用我的原因也有一部分是看了我的博客，觉得我是一个爱好学习的人，在我技术和其他人差不多的情况下，更加愿意给我机会。
简历
我一开始也忽略了简历的重要性。 随便花了十几分钟填了一个在线模板就开始投递了，结果是可以预料的。都石沉大海。 我们首先要知道一件事情，即使是一家小公司发布一个招聘的职位，那么收到的简历也可能几百个。HR会在这几百个甚至上千个里面选几个出来面试，所以哪怕你技术再好，如果简历不能体现出你的水平，连见到面试官的机会都没有，那怎么能找到理想的工作呢？
那么问题来了，简历怎么写呢？
我偷懒用的在线的模板，当然如果你的内容写的不错，问题还是不大的，但是建议还是不要用现成的模板，拉钩的就挺坑，最上面是一张大大的照片还有教育经历也占了很大地方，结果最重要的项目经验要到第二页才能看到。
简历一般都有几个模块，工作经历，教育经历，项目经验，自我描述，技能评价等等。
教育经历我就不说了，这个没什么技术含量。
工作经历 写上你的上一家公司，从事的职位（java后端开发），如果你在这三年的时间换了两家以上的公司，我建议你还不要都写上，HR是不喜欢那种经常跳槽的，在这个年限，一般最好是一家到两家。这些按照实际情况写就好了，都是死的东西，接下来就要写上你的职责了。
有的人和我最开始写的一样
java 后端开发，最多加上一句 负责接口的编写和实现。 这么写和没写一样这么写和没写一样这么写和没写一样
那应该怎么写呢？
1、根据业务需求调整数据模型，设计程序接口，实现接口业务逻辑，编写接口文档。 2、根据前端组html及css，编写jsp页面及js脚本。 3、日常版本的发布及紧急回退。 4、处理日常bug和在生产发生的紧急问题。 5、新同事及实习生的业务培训。 6、配合性能测试优化代码和sql。 7、参与新需求评审。 上面是我后来修改的的，你觉得两者差了多少呢？
一定要具体，并且分条陈述，作为一个技术岗位，要体现出你的专业素养。
项目经历 这个千万要写，当然工作也这么久了都会有项目经历，但是也要有一个主次。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/30afcc5b22e7ef8b87b3f9e0771f6d0b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f52c8afd7b5c11b7c720bf6a09be506b/" rel="bookmark">
			Android 360开源全面插件化框架RePlugin 实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 RePlugin 介绍 RePlugin是一套完整的、稳定的、适合全面使用的，占坑类插件化方案，由360手机卫士的RePlugin Team研发，也是业内首个提出”全面插件化“（全面特性、全面兼容、全面使用）的方案。
其主要优势有：
极其灵活：主程序无需升级（无需在Manifest中预埋组件），即可支持新增的四大组件，甚至全新的插件 **非常稳定：**Hook点仅有一处（ClassLoader），无任何Binder Hook！如此可做到其崩溃率仅为“万分之一”，并完美兼容市面上近乎所有的Android ROM 特性丰富：支持近乎所有在“单品”开发时的特性。包括静态Receiver、Task-Affinity坑位、自定义Theme、进程坑位、AppCompat、DataBinding等 易于集成：无论插件还是主程序，只需“数行”就能完成接入 管理成熟：拥有成熟稳定的“插件管理方案”，支持插件安装、升级、卸载、版本管理，甚至包括进程通讯、协议版本、安全校验等 数亿支撑：有360手机卫士庞大的数亿用户做支撑，三年多的残酷验证，确保App用到的方案是最稳定、最适合使用的
以上是官方的介绍，github地址如下： https://github.com/Qihoo360/RePlugin 总之，根据网上的反馈以及14日成都参加thoughtworks 的replugin分享活动来看，Replugin将会是一个比较有潜力和完善的差价化框架。今天就来根据官方的wiki自己来接入到程序中。
Replugin的接入个人觉得分为三部分： 宿主的接入：这个主要是决定你要将那么module作为你的宿主，用于加载插件 插架的接入：这里可以新建一个module作为插件，也可以将现有的module（APK）改造为插件 插架化的使用：主要讲宿主和插件之间组件的通信，以及宿主和插件的调用等。
本篇博文不讲插件化的原理，只讲最基础的如何接入Replugin。想要了解原理的可以阅读官方的源代码及参考以下的几篇博文： Replugin 全面解析 (1) http://www.jianshu.com/p/5994c2db1557 Replugin 全面解析 (2) http://www.jianshu.com/p/74a70dd6adc9 Replugin 全面解析 (3) http://www.jianshu.com/p/8465585b3507 Replugin 全面解析 (4) http://www.jianshu.com/p/f456f608aa92 Replugin 全面解析 (5) http://www.jianshu.com/p/fb9d40f4173c
2 宿主接入步骤 根据官方的文档，如下宿主的接入分为三个步骤： https://github.com/Qihoo360/RePlugin/wiki/%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B
第 1 步：添加 RePlugin Host Gradle 依赖 这一步没什么好说的。 在项目根目录的 build.gradle（注意：不是 app/build.gradle） 中添加 replugin-host-gradle 依赖：
buildscript { dependencies { classpath 'com.qihoo360.replugin:replugin-host-gradle:2.2.1' ... } } 第 2 步：添加 RePlugin Host Library依赖 在 app/build.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f52c8afd7b5c11b7c720bf6a09be506b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77b42a4ef5ed3538d168dff5db8c9291/" rel="bookmark">
			机器视觉之多坐标系标定与统一
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着机器视觉应用的日益广泛，大幅面多相机视觉系统的需求越来越多，主要应用方向为大幅面高精度的定位与测量和场景拼接等。多相机视觉系统的难点在于多相机坐标系的统一，可以分为两类，一是相机视野间无重叠部分，二是相机视野间有重叠部分。相机间无重叠部分的情况主要用于大幅面多相机高精度的定位和测量，相机间有重叠部分的情况主要用于场景的拼接等 使用大标定板统一坐标的方法 方案简介： 此方法采用一块大标定板来统一各个相机的坐标，每个大标定板中有若干小标定板，各个小标定板间的位置关系都是已知的，各个相机都能拍摄到一个小标定板。通过各个小标定板可以标定每个相机的内部参数和外部参数，每个相机的坐标都可以转换到各个小标定板的坐标系上，从而统一各个相机的坐标。 系统结构：
相机在各个位置拍摄mark图像，通过图像处理方法得到mark坐标
常用的标定板形式：
上图所示为单个标定板图像，大标定板由若干单个标定板组成，标定板的大小和数量根据实际测量情况而定。
多个标定板组合示意图：
案例分析：
（1）检测目标分析 测量产品需要若干个测量指标。如下图所示。
（2）图像获取 采用4只相机来完成所有项目的测量，分别拍到的照片如下图所示。
（3）检测流程 先分别利用每张图的两条垂直边计算出它们的交点，那么得到的4个交点就可以算出L1和L2的值，如下图所示。
利用4个边角图来测量4个角的L3，如下图所示，这里可以选择测量多个点，也可以取它们的平均值。
注意事项： 此种方法需要将多只相机的坐标统一到一个坐标系中，并且单一相机还要做自己的校准，保证精度。 根据检测要求，设置取多少个点作为参考，但是这影响测试的时间，需酌情考虑。 应用领域： 手机和平板电脑面板尺寸的检测。
相对运动统一坐标的方法 方案简介： 此方法采用相机和被测物之间的相对运动来统一相机的坐标，相机和被测物只要一方运动即可，记录各个位置的坐标，然后通过数学运算来统一坐标。通常情况下是相机位置固定，被测物通过机械手等运动装置进行移动，然后把相机坐标系统一到机械手等运动装置的原点。 总体结构：
方法介绍： 通过相机拍摄的图像对mark点进行定位，从而计算出被测物相对于标准位置的偏差，包含角度偏差和位移偏差，最终确定机械装置需要旋转的角度和平移的距离。选用手机触摸屏和手机外壳的定位系统来介绍算法原理。 手机触摸屏和手机外壳的定位系统，使用多支相机代替一支相机的方法进行定位，使手机触摸屏和手机外壳精确组装。相机分为两组，每组两支相机，一组拍摄手机外壳(组1)，一组拍摄触摸屏(组2)，两组相机标定方法相同，下面只介绍拍摄手机外壳的两支相机的标定。相机固定，机械手吸住手机外壳移动，两支相机分别拍摄手机外壳的两个定位孔，使用模板匹配的方法对两个定位孔进行识别，如下图所示：
（1）通过机械手的移动获取标定所用坐标 组1相机1： 把mark点移动到相机视野中，定相机的初始位置，得到初始mark点的中心坐标Point11(cRow11, cColumn11)，机械手沿X方向移动一定距离(5mm)后得到mark点的中心坐标Point12 (cRow12, cColumn12)，机械手沿Y方向移动一定距离(6mm)后得到mark点的中心坐标Point13(cRow13, cColumn13)，同时可以得到在上述三个位置机械手的空间坐标Robot11(X1[0]，Y1[0])、 Robot12(X1[1]，Y1[1]) 、Robot13(X1[2]，Y1[2])。 组1相机2： 同上，把相同mark点移动到相机视野中，通过相同的操作得到坐标：Point21 (cRow21, cColumn21)、Point22 (cRow22, cColumn22)、Point23 (cRow23, cColumn23)、Robot21 (X2[0]，Y2[0])、 Robot22(X2[1]，Y2[2])、Robot23(X2[2]，Y2[2])。 （2） 图像距离和实际距离之间转换比例关系的确定： 通过数学运算可计算得到比例关系。 （3） 标准线斜率求取： 需要在两个相机的视野中各选取一点作为标准线的起始点和终点，然后求取此标准线在机械手坐标系中的斜率。调整机械手到合适位置，确定此处为标准位置，此时组1的两支相机分别拍摄初始位置的两个不同的mark点的图像。通过模板匹配方法找到两个相机初始位置视野中两个mark点的中心坐标Point10(Row10,Column10)和Point20(Row20,Column20)，Point10和Point20确定为标准线的起始点和终点。求取Point10在机械手中的坐标如图6所示，下图中XOY是机械手坐标系，X1O1Y1是组1相机1的图像坐标。
通过点到直线的距离运算可以得到d14，d15和d16的实际长度，由于在移动过程中使用的是同一个mark点，d1，d2，d3在相机1和相机2的视野中的值是一样的。从而可以得到Point10在机械手坐标系中的实际坐标为： Point10X=X1[1]+d16+d2，Point10Y=Y1[1]+(d1-d15)。 同样可以得到Point20在机械手坐标系中的实际坐标： Point20X=X2[1]+d26+d2，Point20Y=Y2[1]+(d1-d25)。 求取该标准线斜率; K=(Point20Y-Point10Y)/(Ponit20X-Point20Y)=(Y2[1]-Y1[1]-d25+d15)/(X2[1]-X1[1]+d26-d16) 之后在每次定位时需要和此标准线的斜率进行比较，从而得到和标准线的夹角，最后进行旋转校正。 注意：由于Point10和Point20会落在不同的位置，在计算Point10和Point20的实际坐标时上述公式会有所变化，但原理相同。 （1） 旋转中心的确定 依据三个点就可以确定一个圆的原理，让机械手在初始位置旋转三次，得到Robot31，Robot32和Robot33三个相对于机械手坐标系的坐标点，三个点的坐标就可以求出旋转圆心的坐标。 定位校准 以后在每次进行检测时，得到的结果都和标准线进行比较，可以得到和标准线的夹角和相对于标准位置的位置偏差，根据得到的角度和位置偏差进行校正。在校正过程中需要先旋转后平移，做一个闭环反馈系统实时校正。 应用领域： 手机或平板电脑触摸屏和外壳的装配定位。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/77b42a4ef5ed3538d168dff5db8c9291/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27b7e3593781d413526272c281847708/" rel="bookmark">
			Python 中 pass的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		def sample(n_samples):	# Generate random samples from the fitted Gaussian distribution. pass 在python中有时候能看到定义一个def函数，函数内容部分填写为pass。
这里的pass主要作用就是占据位置，让代码整体完整。如果定义一个函数里面为空，
那么就会报错，当你还没想清楚函数内部内容，就可以用pass来进行填坑。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c618269517205d2f0d7a0250cf70b40/" rel="bookmark">
			梯度、散度、旋度的关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自 百度文库https://wenku.baidu.com/view/681228626137ee06eff918c4.html
知乎上一篇不错的文章 https://www.zhihu.com/question/24591127
麦克斯韦方程组
向量场 数量场
有源场 无源场 保守场（无旋场）有旋场（非保守场）
保守场=有势场=无旋场------环流等于零!
有源场-------闭合曲面的通量不等于零!------这些是指场的宏观特性!
3.含时磁场可以感生出电场 4.含时电场可以感生处磁场 上面四个方程可逐一说明如下：在电磁场中任一点处
（1）电位移的散度== 该点处自由电荷的体密度 ；
（2）磁感应强度的散度 --- 处处等于零。
（3）电场强度的旋度== 该点处磁感强度变化率的负值；
（4）磁场强度的旋度 == 该点处 传导电流密度与位移电流密度 的矢量和
\
把不明白的字母列举一下：
E 是电场强度矢量
D 是电位移矢量（也叫电感应强度） 应该还有一个电传导向量 E=D+?
B 是磁感应强度矢量
H 是磁场强度矢量 H=B+?
其中内在的联系是：
D=εE
B=μH
注意上面这些大写字母都是矢量
物理都是循序渐进的，你看看懂麦克斯韦方程组，必须学过微积分和数学物理方程。∮是环路积分，求是对闭合的回路求积分
▽是哈密顿算符，就是对XYZ三个方向求全导数（偏导数就是如果有几个变量，其他的不变，只求一个的导数，全导数就是把不同变量的偏导数全求出来，再加起来）
·是点乘，×是叉乘，不一样的，这是微积分里的
第一个说的是，电场的源是电荷。＜你看它的微分形式，是不是：电场三个方向都求散度后的结果是电荷的密度，（散度通俗理解就是对三个空间方向求微分）这样就说明了电场不能凭空产生，它是有一个源头的，源头就是电荷。这与我们通常的理解也是一样的，到目前为止我们也没有发现，单独的正电荷或负电荷，电场线都是从正电荷出发负电荷截止。
第二个方程，知道第一个方程的含义第二个就很好理解了，他就是说磁场是无源的，也就是说磁场是没有源头的，即磁场线是一条连续的曲线。它不像电场线一样，必须从一个东西发出到一个东西结束。
第三个公式，也是看微分形式。这里对电场取了旋度，＜旋度就相当于在电场线的垂直方向上求导＞我们看到最后它等于磁场对时间的求导。负号是方向。这是什么意思呢？它是说变化的磁场（含时磁场）能产生电场。这一个在日常生活中用的最多，发电厂就是用的这个发电的。
第四个公式，和上一个方程类似不过又有不同，这里除了变化的电场（含时电场）能产生磁外，还说恒定的电流也能产生磁场。＜j是电流的意思＞这一个也好理解，你想我们高中学的右手螺旋定则，其实就是用了这个。右手螺旋定则是由电流方向判断磁场方向，那么也就是说有电流就有磁场了。这个是帮助理解，其实是先有，麦克斯维再有右手螺旋定则的。
、
倒三角什么意思啊？我们一般把空间看成 X,Y,Z,的三维空间，这里的倒三角是对这，三个维度分别求导再相加的意思
梯度 1.坡度。 2.单位时间或单位距离内某种现象（如温度、气压、密度、速度等）变化的程度。 3.依照一定次序分层次地：我国经济发展由东向西～推进。 4.依照一定次序分出的层次：考试命题要讲究题型有变化，难易有～。
图像处理中，梯度的matlab求法：
K&gt;&gt; A
A =
2 5 1
2 3 7
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c618269517205d2f0d7a0250cf70b40/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/676ecf324acfe1d54e4aaace13a81477/" rel="bookmark">
			微信无法登陆，您绑定的QQ号疑似被盗解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 问题描述 我之前在用微信的时候，因为重置了一下手机，所以再次登录微信的时候，提示需要验证。在验证的时候提示要修改qq密码，修改之后，就提示被盗了。然后怎么也跳不过这个步骤。今天解决这个问题:
问题解决前提：你需要知道你的微信账号，并且该微信账号绑定了一张银行卡。
2. 解决方式如下： 1，首先，要选中微信登陆界面的三个点，然后选择找回密码。
2，然后选择获得密码的方式：
3，在这里选择通过申诉找到微信账号密码：
4，点击开始申诉，然后输入微信号和可用手机号。
5，根据提示发送短信。然后选中下一步。
6，在此页面填写你绑定的银行卡，身份证信息，姓名，点击确定就能找到微信密码了。
﻿﻿
﻿﻿
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2c4ab1ac8cd5bdec7bb8a38540871c6/" rel="bookmark">
			结合redis设计与实现的redis源码学习-7-ziplist（压缩列表）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		压缩列表是列表件和哈希键的底层实现之一，当一个列表件只包含少量列表项，并且每个列表项要么就是小整数值，要么就是长度比较短的字符串，那么redis就会使用压缩列表来做列表键的底层实现。 压缩列表的特点： 1、压缩列表是由一系列特殊编码的连续内存块组成的顺序型数据结构。 2、一个压缩列表可以包含任意多个节点，每个节点可以保存一个字节数组或者一个整数值。 3、添加新节点到压缩列表，或者从压缩列表中删除节点，可能会引发连锁更新操邹，但是出现的几率不高。 redis设计与实现中介绍了压缩列表的各个组成部分的详细说明： zlbytes：uint32_t,4字节长度，记录整个压缩列表占用的内存字节数：在对压缩列表进行内存重分配或者计算zlend的位置时使用。 zltail：uint32_t,4字节长度，记录压缩列表表尾节点距离压缩列表的起始地址有多少字节：通过这个值可以直接确定表尾节点的地址。 zllen：uint16_t,2字节长度，记录了压缩列表的节点数量：当值小于65535时，这个值就是节点数；当这个值大于65535时，真实数量需要遍历整个压缩列表才能得出。 entryX：列表节点：长度不定：由节点保存的内容决定。 zlend：uint8_t：1字节长度：为0xFF，表示压缩列表的末端。 ziplist.h中定义了压缩列表的方法，ziplist.c中定义了压缩列表的结构及方法实现。
#ifndef _ZIPLIST_H #define _ZIPLIST_H #define ZIPLIST_HEAD 0 #define ZIPLIST_TAIL 1 unsigned char *ziplistNew(void); unsigned char *ziplistMerge(unsigned char **first, unsigned char **second); unsigned char *ziplistPush(unsigned char *zl, unsigned char *s, unsigned int slen, int where); unsigned char *ziplistIndex(unsigned char *zl, int index); unsigned char *ziplistNext(unsigned char *zl, unsigned char *p); unsigned char *ziplistPrev(unsigned char *zl, unsigned char *p); unsigned int ziplistGet(unsigned char *p, unsigned char **sval, unsigned int *slen, long long *lval); unsigned char *ziplistInsert(unsigned char *zl, unsigned char *p, unsigned char *s, unsigned int slen); unsigned char *ziplistDelete(unsigned char *zl, unsigned char **p); unsigned char *ziplistDeleteRange(unsigned char *zl, int index, unsigned int num); unsigned int ziplistCompare(unsigned char *p, unsigned char *s, unsigned int slen); unsigned char *ziplistFind(unsigned char *p, unsigned char *vstr, unsigned int vlen, unsigned int skip); unsigned int ziplistLen(unsigned char *zl); size_t ziplistBlobLen(unsigned char *zl); #ifdef REDIS_TEST int ziplistTest(int argc, char *argv[]); #endif #endif /* _ZIPLIST_H */ ziplist.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2c4ab1ac8cd5bdec7bb8a38540871c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6b61fffabad99bb93c6b973acf8149f/" rel="bookmark">
			IntelliJ Idea 复制粘贴的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决思路有两个：
增加历史粘贴板的深度；将历史粘贴板中的部分内容删除，腾出空间来。 增加历史粘贴板的深度 要做这个调整需要修改设置了。选择File &gt; Settings &gt; Editor &gt; General，下拉右侧的滚动条，找到 Maximum number of contents to keep in clipboard，修改这个对应的值。默认是5，修改成50好了。
下次要找这个设置项可以直接在设置的搜索框中搜索“max clipboard”。
删除历史粘贴板中的内容 打开历史粘贴板比较简单：使用Ctrl+Shift+V组合键即可。但是要删除历史粘贴板中的内容时却不知道该如何下手。
查了些资料，也是使用一个快捷键：选中要删除的目标，使用Shift+Delete组合键即可完成删除。
在idea的默认KeyMap中，Shift+Delete执行的是cut（剪切）操作。而delete line的快捷键是Ctrl+Y。也都试验过，Ctrl+Y不起作用，只有Shift+Delete起作用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a546c62aafc7b2ffb7f6ce5ec2a4510f/" rel="bookmark">
			dom4j  生成  xml ，解析xml
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		xml 生成
Document dod =DocumentHelper.createDocument(); //创建xml Element ele = dod.addElement("student"); Element tet = ele.addElement("yyy");
Element nameElement = tet.addElement("name"); nameElement.addText("sss");
Element tets = ele.addElement("tets");
tets.addText("sssdd");
/* System.out.println(dod.asXML());*/ //生成 xml 字符串
try {
Writer fileWriter = new FileWriter("c:\\module.xml"); //dom4j提供了专门写入文件的对象XMLWriter XMLWriter xmlWriter = new XMLWriter(fileWriter); xmlWriter.write(dod); xmlWriter.flush(); xmlWriter.close();
} catch (IOException e) {
e.printStackTrace();
} xml 解析
SAXReader reader =new SAXReader();
try {
Document document = reader.read(new File("c:/module.xml"));
Element Ele = document.getRootElement();
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a546c62aafc7b2ffb7f6ce5ec2a4510f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4890b997f02e1a1067302cdfd973924f/" rel="bookmark">
			远程桌面不能复制粘贴解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http://blog.sina.com.cn/s/blog_61c07ac50101h92l.html 大家常常会遇到mstsc 远程桌面的时候，发现本地和远程之间不能够复制和粘贴文本内容，大家可能会很疑惑，我远程的时候明明在“本地资源”里面勾选了“剪贴板”，但为什么还不能用，原因就是因为“rdpclip.exe”这个进程没有正常工作。
解决办法：
在服务器上打开任务管理器（Ctrl+Alt+Del或者是Ctrl+Shift+Esc，也可以右键点击任务栏，选择任务管理器打开），查看进程，找到 rdpclip.exe 进程， 关闭此进程，然后
点击开始-&gt;运行-&gt;输入“rdpclip.exe ” 并回车，重新运行此程序，也可以在任务管理器里面点击“文件” ---“新任务”---输入“rdpclip.exe” 回车执行。
这个时候本地和远程服务器就可以使用复制和粘贴了，如果还不行，在客户端也执行上面“解决办法”里面的步骤
本文转自火地晋博客园博客，原文链接：http://www.cnblogs.com/yelaiju/p/4112337.html，如需转载请自行联系原作者
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31074a53617b2cf34ea37aa5491f60a0/" rel="bookmark">
			ubuntu maas 对物理服务器资源进行云化管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在搞openstack相关的事情，经常需要重装系统，之前用过cobbler，不过配置起来较为复杂，网上各个版本的文档也很难完整的走下来，故研究了一下ubuntu推出的maas平台（https://www.ubuntu.com/download/server/provisioning），这里完整记录下整个过程，希望能帮助到有类似需求的同学。
Maas采用了一种云化的思维来对物理服务器资源进行管理，基本上支持常见云平台中所有的基础功能，如资源预留、申请计算资源、释放计算资源、如果服务器有ipmi等功能，还可以控制资源的开关机，整体的功能和openstack中的baremetal非常类似，只不过各有侧重。
安装流程
（1）安装ubuntu server 16.04
（2）运行sudo apt-get update更新本地源
（3）sudo apt-get install maas
这里解释一下，maas平台包含多个服务模块，支持生产环境多节点分布式部署，canonical提供了名为maas的虚拟包，可以自动安装所有的服务（例如：rack server、region server等）
（4）sudo maas createadmin
设置管理portal的管理员账号
（5）到这里安装就基本结束了，可以直接访问portal的地址进行相关配置
http://&lt;your.maas.ip&gt;:5240/MAAS/
例如：http://192.168.10.148:5240/MAAS/
登录的用户名和密码为第（4）步里设置的
基本的配置
（1）导入常用的镜像，目前maas默认支持全系列的ubuntu和常用的centos，可以根据自己的需要勾选。由于这个过程涉及目标镜像的下载和导入，所以整个过程较慢。
（2）导入自己的ssh public key，maas会将这些public key注入最终发起的目标服务器实例，由于最终生成的目标服务器实例不支持用户名密码登录，所以这步是必须的，否则无法登录。你也可以选择导入自己github或者launchpad上的pub key。
导入路径：User preferences for admin-&gt;SSH keys
（3）配置DHCP服务，subnets-&gt;vlan-&gt;DHCP
在我使用的环境中，安装maas服务的机器有两块网卡，一个网卡eth1可以连接互联网，另外一个网卡eth2采用内部地址（192.168.100.1/24），采用iptable nat方式代理maas实例连接外网。
internet &lt;—&gt; eth1[maas server]eth2 &lt;——&gt; [swich] &lt;——&gt; maas instances
（4）为了使最终发起的maas instance可以连接外网，还需要在maas服务器上配置iptable nat规则，如下：
iptables -t nat -A POSTROUTING -s 192.168.100.0/24 -o enp0s3 -j MASQUERADE
完成以上基本的配置之后，设置需要被maas管理的各节点为从网卡启动，节点启动之后会以pxe的方式从maas server上拉取基本内核并注册基本信息到maas server，如下：
编辑该节点，设置正确的电源管理类型，如
这里选择手动方式管理节点的电源，然后在take action菜单中，对该节点进行commision，将其纳入maas平台进行管理，如
Commission完成之后，即可申请资源（acquire）、或者直接对该节点进行部署（特定的操作系统）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/31074a53617b2cf34ea37aa5491f60a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0693d525de23a922e4cbcab76df71139/" rel="bookmark">
			CSS中的px,em,rem设置字体大小
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Web中使用什么单位来定义页面的字体大小，至今天为止都还在激烈的争论着，有人说PX做为单位好，有人说EM优点多，还有人在说百分比方便，以至于出现了CSS Font-Size: em vs. px vs. pt vs. percent这样的PK大局。不幸的是，仍然有不同的利弊，使各种技术都不太理想，但又无法不去用。真是进也难，退也难呀。
最近在学习em的相关知识的时候，无意之间让我拾得一宝，就是使用rem来设置Web页面的字体大小。让我一下子就来劲了，一口气看完并测试了一回，还真是爽歪歪的呀。师傅说好东西不能吃独食，于我就在这里给大家吹吹这个从没见过的REM。
在详细介绍rem之前，我们先一起来回顾一下我们常用的两种记量单位，也是备受争论的两个：
PX为单位EM为单位 PX为单位 在Web页面初期制作中，我们都是使用“px”来设置我们的文本，因为他比较稳定和精确。但是这种方法存在一个问题，当用户在浏览器中浏览我们制作的Web页面时，他改变了浏览器的字体大小，这时会使用我们的Web页面布局被打破。这样对于那些关心自己网站可用性的用户来说，就是一个大问题了。因此，这时就提出了使用“em”来定义Web页面的字体。
em为单位 前面也说了，使用是“px”为单位是比较方便，而又一致，但在浏览器中放大或缩放浏览页面时会存在一个问题，要解决这个问题，我们可以使用“em”单位。Richard Rutter'在《How to size text using ems》一文中有做过详细的介绍，追至早一点，Richard Rutter也在《How to Size Text in CSS》中进行过深入的剖析。
这种技术需要一个参考点，一般都是以&lt;body&gt;的“font-size”为基准。比如说我们使用“1em”等于“10px”来改变默认值“1em=16px”，这样一来，我们设置字体大小相当于“14px”时，只需要将其值设置为“1.4em”。
body { font-size: 62.5%;/*10 ÷ 16 × 100% = 62.5%*/ } h1 { font-size: 2.4em; /*2.4em × 10 = 24px */ } p	{ font-size: 1.4em; /*1.4em × 10 = 14px */ } li { font-size: 1.4em; /*1.4 × ? = 14px ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0693d525de23a922e4cbcab76df71139/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da71a7c8b08da1ddba102342d1ad3f04/" rel="bookmark">
			python 把json数据导入mongodb数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、构造df数据，并导入数据库
from MongoDbHandler import MongoDbHandler from pandas import DataFrame finallyResult = {} finallyResult["aa"]="bb" finallyResult["cc"]="dd" df = DataFrame(finallyResult,index=[1]) data = df.to_dict('records') mongoSession = MongoDbHandler('A','B', 'C')#A为mongodb的name,B为用户名，C为密码 mongoSession.insert_many("D", "E", data)#D为数据库名，E为集合名 time.sleep(2) mongoSession.close() 2、上面代码用到的函数，脚本如下
# coding=utf-8 from pymongo import MongoClient import pandas as pd class MongoDbHandler(object): def __init__(self, ip, user=None, keyword=None): if user == None or keyword == None: URL = 'mongodb://{0}'.format(ip) else: URL = 'mongodb://{0}:{1}@{2}'.format(user, keyword, ip) print user,keyword print URL self.__Client = MongoClient(URL) def find_all(self, db, collection, condition = None): self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da71a7c8b08da1ddba102342d1ad3f04/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b16e3bce57e4c4bf2f7ec9b36bea971/" rel="bookmark">
			SpringMVC日期类型转换问题三大处理方法归纳
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前言 我们在SpringMVC开发中，可能遇到比较多的问题就是前台与后台实体类之间日期转换处理的问题了，说问题也不大，但很多人开发中经常会遇到这个问题，有时很令人头疼，有时间问题暴露的不是很明显，然后逐渐对问题进行跟踪，会发现是日期类型转换失败“映射”不到对应的持久类的日期属性上造成的。常见造成SpringMVC中出现" 400Bad Request "错误（用@ResponseBody处理ajax传过来的json数据转成bean）错误的主要原因，其中就很有可能是前台的字符串日期类型与后台的java日期类型匹配不上造成的。 今天我们来总结归纳出一下解决这个问题的三大方法，分享给大家。
方法一：实体类中加日期格式化注解
@DateTimeFormat(pattern = "yyyy-MM-dd") private DatereceiveAppTime; 如上，在对应的属性上，加上指定日期格式的注解，本人亲自测试过，轻松解决问题！ 方法二：控制器Action中加入一段数据绑定代码
@InitBinder publicvoid initBinder(WebDataBinder binder) { SimpleDateFormatdateFormat = newSimpleDateFormat("yyyy-MM-dd"); dateFormat.setLenient(false); binder.registerCustomEditor(Date.class, newCustomDateEditor(dateFormat, true)); //true:允许输入空值，false:不能为空值 附加方法三：适合页面把日期类型转换成字符串且JSP，Freemark页面 &lt;%@taglib uri="http://java.sun.com/jsp/jstl/fmt" prefix="fmt"%&gt; &lt;fmt:formatDate value="${job.jobtime }" pattern="yyyy-MM-ddHH:mm:ss"/&gt; &lt;input id="receiveAppTime" name="receiveAppTime" type="text" value="${(bean.receiveAppTime?string('yyyy-MM-dd'))!}" /&gt; 上面这个不太理解……自己是这样写的 &lt;input type="text" style="width:140px;" name="userInfo.birthday" οnclick="WdatePicker({el:this,isShowOthers:true,dateFmt:'yyyy-MM-dd'});" value="&lt;fmt:formatDate value='${ info.birthday }' pattern='yyyy-MM-dd'/&gt;"/&gt; 经常会碰到这样的问题，所以记录一下！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd09cecbd5f6f199397c6c1139395cad/" rel="bookmark">
			c&#43;&#43;一个数组的求和
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 #include "stdafx.h" #include&lt;iostream&gt; using namespace std; int addarray(int *array, int n); int main() { int data[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }; int size = sizeof(data) / sizeof(data[0]); cout &lt;&lt; "jieguo:"&lt;&lt;addarray(data, size) &lt;&lt; endl; return 0; } int addarray(int *array, int n) { int sum = 0; int i; for (i = 0; i &lt; n; i++) { sum += *array++; } return sum; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed080e3a3c35ce508dbfa219231ed539/" rel="bookmark">
			信号的采样以及matlab实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在matlab当中对一个连续信号进行采样，往往不是那么容易的理解，这是因为在matlab中画一条连续曲线其实已经进行了采样，matlab中所有的曲线都是用点拟合出来的，点越密，画出来的曲线也就越清晰，下面用程序说明
close;
clear all;
fd = 1000; %fd就是采样频率，只有fd取得越大，画出来的曲线越好看，因此干脆取1000
t= 1:1/fd:10;
f = 10; %信号的频率
y = sin(2*pi*f*t);%原始信号
n = 10; %设置采样点数为10
fd2 = 40; %采样频率为fd2
t1 = 1:1/fd2:10;
t2 = t1(1:n);%在时间轴上选取10个点
y2 = sin(2*pi*f*t2);
plot(t,y,t2,y2,'r-*');
axis([1 1.5 -1.5 1.5]);
由于采样点数为n,所以共有n=10个点用星形标出了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/906d607ed7928a8ae9a294e8fb14eddb/" rel="bookmark">
			Python基础知识笔试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python基础知识笔试
单选题（2.5分*20题） 1. 下列哪个表达式在Python中是非法的？ B
A. x = y = z = 1
B. x = (y = z + 1)
C. x, y = y, x
D. x += y
2. python my.py v1 v2 命令运行脚本，通过 from sys import argv如何获得v2的参数值? C
A. argv[0]
B. argv[1]
C. argv[2]
D. argv[3]
3. 如何解释下面的执行结果? B
print 1.2 - 1.0 == 0.2 False
A. Python的实现有错误
B. 浮点数无法精确表示
C. 布尔运算不能用于浮点数比较
D. Python将非0数视为False
4. 下列代码执行结果是什么?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/906d607ed7928a8ae9a294e8fb14eddb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39651da89018b50d0a6207ff7cafb2a3/" rel="bookmark">
			输入一个字符串,按字典序打印出该字符串中字符的所有排列。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41694cf38e137df4c21e222ef93176a3/" rel="bookmark">
			【算法】无序数组中求中位数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题 给定一个int数组A，为传入的数字序列，同时给定序列大小n，请返回一个int数组，代表每次传入后的中位数。保证n小于等于1000
或者
求一个无序数组的中位数。 如：{2,5,4,9,3,6,8,7,1}的中位数为5。 要求：不能使用排序，时间复杂度O(n)。
分析 因为题目指定不能使用排序算法，而且要求时间复杂度O(n)，也就是要求一次遍历就得给出结果。所以排序算法基本上没有用武之地。
寻寻觅觅之后终于找到一种使用大小堆的方式来实现，看着思路很不错。它通过建立两个堆
一个最大堆，用来存储比较小的那一半组元素，同时堆顶最大（也就是最靠近中位数的那个）。一个最小堆，用来存储比较大的后半组元组，同时堆顶最小（也是最靠近中位数的那个）。 这样只需遍历一遍，将元素分配到对应的堆，那么最后的中位数要么就是最大堆堆顶，要么就是最小堆的堆顶。具体步骤如下：
通过最大堆、最小堆来实现实时中位数的获取。最大堆中存放比最小堆小的元素。如果最大堆的堆头元素大于最小堆，则进行交换。偶数下标的元素存入最小堆，奇数下标的元素存入最大堆。 实现 我们借助Java中的PriorityQueue来建立堆，它就是一个完全二叉树实现的优先级队列，构造函数还支持传入Comparator来自定义大小顺序，省去了建堆的额外操作。大家想要深入了解的可以参考这篇文章：深入理解Java PriorityQueue。
/** * 1. 通过最大堆、最小堆来实现实时中位数的获取。 * 2. 最大堆中存放比最小堆小的元素。 * 3. 如果最大堆的对头元素大于最小堆，则进行交换。 * 4. 偶数下标的元素存入最小堆，奇数下标的元素存入最大堆。 * * @param arr * @param cmp 比较器 */ public static &lt;E&gt; List&lt;E&gt; findMedianFromRandomArray(E[] arr, Comparator cmp){ List&lt;E&gt; res = new ArrayList&lt;E&gt;(arr.length); PriorityQueue&lt;E&gt; maxHeap = new PriorityQueue&lt;E&gt;(cmp); PriorityQueue&lt;E&gt; minHeap = new PriorityQueue&lt;E&gt;(); for(int i = 0; i &lt; arr.length; i++){ if(i % 2 == 0){ // 存入最小堆前判断当前元素是否小于最大堆的堆顶元素 if(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/41694cf38e137df4c21e222ef93176a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9aa2855777e65245b7629a8ffb53c4b2/" rel="bookmark">
			Exponial Kattis - exponial
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		from Exponial Kattis - exponial NCPC 2016
题意 求 n(n−1)n−2...%m
分析 欧拉函数降幂公式 A^B(mod m)=A^{B \% ψ(m)+ψ(m)} (B&lt;=ψ(m)) 对于n &lt;= 5的直接暴力求，对于n &gt;= 5 递归求解 同类题
参考代码 #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; typedef long long LL; LL Euler(LL n)//欧拉函数 { LL ans = n; for(LL i = 2; i * i &lt;= n; ++i) { if(n % i == 0) { ans = ans / i *(i-1); while(n % i==0) n /= i; } } if(n !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9aa2855777e65245b7629a8ffb53c4b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d80debe33f92fc48637bdf953f368b0/" rel="bookmark">
			一文看懂ARM Cortex-M处理器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ARM Cortex-M处理器家族现在有8款处理器成员。在本文中，我们会比较Cortex-M系列处理器之间的产品特性，重点讲述如何根据产品应用选择正确的Cortex-M处理器。本文中会详细的对照Cortex-M 系列处理器的指令集和高级中断处理能力，以及 SoC系统级特性，调试和追踪功能和性能的比较。
1、简介
今天， ARM Cortex-M 处理器家族有8款处理器成员。除此之外，ARM的产品系列还有很多其他的处理器成员。对很多初学者，甚至某些芯片设计经验丰富但是不熟悉ARM系列处理器的设计者来说，也是很容易混淆这些产品的。不同的ARM 处理器有不同的指令集，系统功能和性能。本文会深入展现Cortex-M系列处理器之间的关键区别，以及它们和ARM其他系列处理器的不同。
1.1ARM处理器家族
多年来， ARM已经研发了相当多的不同的处理器产品。 如下图中（图1）: ARM 处理器产品分为经典ARM处理器系列和最新的Cortex处理器系列。并且根据应用范围的不同，ARM处理器可以分类成3个系列。
Application Processors（应用处理器）–面向移动计算，智能手机，服务器等市场的的高端处理器。这类处理器运行在很高的时钟频率（超过1GHz），支持像Linux，Android，MS Windows和移动操作系统等完整操作系统需要的内存管理单元（MMU）。 如果规划开发的产品需要运行上述其中的一个操作系统，你需要选择ARM 应用处理器.
Real-time Processors （实时处理器）–面向实时应用的高性能处理器系列，例如硬盘控制器，汽车传动系统和无线通讯的基带控制。多数实时处理器不支持MMU，不过通常具有MPU、Cache和其他针对工业应用设计的存储器功能。实时处理器运行在比较高的时钟频率（例如200MHz 到 &gt;1GHz ），响应延迟非常低。虽然实时处理器不能运行完整版本的Linux和Windows操作系统， 但是支持大量的实时操作系统（RTOS）。
Microcontroller Processors（微控制器处理器）–微控制器处理器通常设计成面积很小和能效比很高。通常这些处理器的流水线很短，最高时钟频率很低（虽然市场上有此类的处理器可以运行在200Mhz之上）。 并且，新的Cortex-M处理器家族设计的非常容易使用。因此，ARM 微控制器处理器在单片机和深度嵌入式系统市场非常成功和受欢迎。
图 1: 处理器家族
表1总结了三个处理器系列的主要特征。
表 1: 处理器特性总结
1.2Cortex-M 处理器家族
Cortex-M处理器家族更多的集中在低性能端，但是这些处理器相比于许多微控制器使用的传统处理器性能仍然很强大。例如，Cortex-M4和Cortex-M7处理器应用在许多高性能的微控制器产品中，最大的时钟频率可以达到400Mhz。
当然，性能不是选择处理器的唯一指标。在许多应用中，低功耗和成本是关键的选择指标。因此，Cortex-M处理器家族包含各种产品来满足不同的需求：
表 2: Cortex-M 处理器家族
不同于老的经典ARM处理器（例如，ARM7TDMI, ARM9）， Cortex-M处理器有一个非常不同的架构。例如：
-仅支持ARM Thumb®指令，已扩展到同时支持16位和32位指令Thumb-2版本
-内置的嵌套向量中断控制负责中断处理，自动处理中断优先级，中断屏蔽，中断嵌套和系统异常处理。
-中断处理函数可以使用标准的C语言编程，嵌套中断处理机制避免了使用软件判断哪一个中断需要响应处理。同时，中断响应速度是确定性的，低延迟的
-向量表从跳转指令变为中断和系统异常处理函数的起始地址。
-寄存器组和某些编程模式也做了改变。
这些变化意味着许多为经典ARM处理器编写的汇编代码需要修改，老的项目需要修改和重新编译才能迁移到Cortex-M的产品上。软件移植具体的细节记录在ARM文档：
ARM Cortex-M3 Processor Software Development for ARM7TDMI Processor Programmers
http://www.arm.com/files/pdf/Cortex-M3_programming_for_ARM7_developers.pdf
1.3Cortex-M系列处理器的共同特性
Cortex-M0, M0+, M3, M4 and M7之间有很多的相似之处，例如：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d80debe33f92fc48637bdf953f368b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe4e280e86038b0c2485e6f624f45bf4/" rel="bookmark">
			$$x^y&#43;y^x&gt;1$$
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果 x 和y是正数，求证： xy+yx&gt;1 。 证明：只考虑 x 和y都小于 1 。 因为a1−b=(1+a−1)1−b≤1+(a−1)(1−b)=a+b−ab 所以， ab≥aa+b−ab ， 所以， xy+yx≥x+yx+y−xy&gt;1 何万程的问题 设 a、b、c、d、e 均为正数，那么 ab+c+d+e+ba+c+d+e+ca+b+d+e+da+b+c+e+ea+b+c+d&gt;1 是否成立？ &lt;script type="math/tex; mode=display" id="MathJax-Element-43"&gt;&lt;/script&gt; 设 a、b、c、d、e 均为正数，那么 ab+c+d+e+ba+c+d+e+ca+b+d+e+da+b+c+e+ea+b+c+d 的取值范围是什么？
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09d00c458b3aca617f7d6dd37f9a3baa/" rel="bookmark">
			hashCode和identityHashCode的区别你知道吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		hashCode 关于hashCode参考之前的文章，点击参考之前文章。
identityHashCode identityHashCode是System里面提供的本地方法，java.lang.System#identityHashCode。
/** * Returns the same hash code for the given object as * would be returned by the default method hashCode(), * whether or not the given object's class overrides * hashCode(). * The hash code for the null reference is zero. * * @param x object for which the hashCode is to be calculated * @return the hashCode * @since JDK1.1 */ public static native int identityHashCode(Object x); identityHashCode和hashCode的区别是，identityHashCode会返回对象的hashCode，而不管对象是否重写了hashCode方法。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/09d00c458b3aca617f7d6dd37f9a3baa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94fab872cb3c407b57cf89c882d14f25/" rel="bookmark">
			XmlDocument节点遍历（C#）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C#遍历XmlDocument对象所有节点名称、类型、属性（Attribute） 源码下载
代码 static void Main(string[] args) { System.Xml.XmlDocument doc = new System.Xml.XmlDocument(); doc.Load("../../UpdateActivity2.xml");//doc.Load(文件）：从文件加载 doc。doc.LoadXml(字符串）从字符串加载 UpdateActivity2(doc); } /// &lt;summary&gt; /// 测试方法 /// &lt;/summary&gt; /// &lt;param name="doc"&gt;XmlDocument对象&lt;/param&gt; public static void UpdateActivity2(XmlDocument doc) { string xx = doc.InnerXml; //Activity2 string activity2ID = ""; string docid = ""; string docTypeid = ""; #region MyRegion //获取delete的节点 //doc.SelectNodes("//Relationships/Item[@action='delete' and @type='Activity2 Deliverable']/related_id[@type='Deliverable']/Item[@type='Document' or @type='CAD']") //获取add的节点 //doc.SelectNodes("//Relationships/Item[@action='add' and @type='Activity2 Deliverable']") #endregion XmlNodeList Activity2Nodes = doc.SelectNodes("//Item[@type='Activity2']"); ////遍历Activity2Nodes中的所有节点 //foreach (XmlNode node in Activity2Nodes) //{ // Console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94fab872cb3c407b57cf89c882d14f25/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41646fdcf58dd313d51548eab4412993/" rel="bookmark">
			Linux上安装ArcGIS Engine 10.4详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ArcGIS Engine的优势之一就是其跨平台性，既可以在Windows操作系统上使用，也可以在Linux操作系统上使用。但由于绝大部分用户都是在Windows上使用的，因此，对于Linux上如何安装ArcGIS Engine以及如何运行Engine应用程序并没有研究过。最近正好有用户问到Linux下ArcGIS Engine的安装问题，于是便动手搭建了Linux环境，进行了安装测试，过程有些曲折，于是写下本文，手把手教您在Linux上安装ArcGIS Engine 10.4，以便您在安装时少走弯路。
安装之前先看一下ArcGIS Engine 10.4的系统需求：
Engine 10.4支持下面Linux操作系统，本文以Red Hat Enterprise Linux Server 6.5为例。
准备工作： 本机安装Xmanager 4，虚拟机安装Redhat 6.5操作系统，并且将ArcGIS_Engine_Linux_104_149459.tar.gz安装文件和rhel-server-6.5-x86_64-dvd.iso操作系统光盘拷贝到该虚拟机上。
安装过程： 一、系统环境的准备 首先看下Engine 10.4在Redhat 6.5下的系统需求：
需要安装额外的package groups和packages，这里我直接挂载Redhat 6.5的系统盘，使用yum命令安装。步骤如下：
1，Xshell中连接该虚拟机，然后cd定位到该系统盘所在的文件夹，输入mount –o loop rhel-server-6.5-x86_64-dvd.iso /mnt(其中/mnt是光盘解压的路径，前面是光盘名称)。
2，输入cd /etc/yum.repos.d，vi rehl-source.repo文件，然后做如下修改：
baseurl=file:///mnt gpgkey=file:///mnt/RPM-GPG-KEY-redhat-release enabled=1 gpgcheck=0 注：/mnt为挂载.iso的路径，gpgcheck=0 代表从本地装，否则会从网上下载。
3，使用yum命令安装，上面链接中列出了安装ArcGIS Engine 10.4所需要的groups以及packages。
安装package groups：
所需要的groups如上图，可以先使用yum grouplist –v查看本机已经安装和可以安装但没有安装的group。其中X Window System已经装了，接下来装Compatibility Libraries，使用命令yum groupinstall “Compatibility libraries” ，注意libraries是小写，这也是为什么先使用yum grouplist –v查看的原因，可以直接拷贝查看的结果，这里要是使用大写的L会提示不存在；同样使用yum groupinstall “Development tools”安装下一个Group，最后一个X Software Development group，没有找到，于是我找到X Software Development group 包含的packages，然后把这里面的packages使用yum install name的方式都装了一下，其中有些包没有找到，就没装。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/41646fdcf58dd313d51548eab4412993/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7b4e36dbe04d56c9e30707fad872a50/" rel="bookmark">
			iOS 第三方库、插件、知名博客总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用到的组件
1、通过CocoaPods安装
项目名称
项目信息
AFNetworking
网络请求组件
FMDB
本地数据库组件
SDWebImage
多个缩略图缓存组件
UICKeyChainStore
存放用户账号密码组件
Reachability
监测网络状态
DateTools
友好化时间
MBProgressHUD
一款提示框第三方库
MWPhotoBrowser
一款简单的 iOS 照片浏览控件
CTAssetsPickerController
一个选择器组件, 支持从用户的相片库选择多张照片和视频。
QBPopupMenu
无需使用图片文件的 iOS 弹出式菜单
UAAppReviewManager
一个能够让你方便地将提醒用户评分的功能加入 App 的工具
Mantle
主要用来将 JSON 数据模型化为 Model 对象
MTLFMDBAdapter
Mantle 和 FMDB 的转换工具
FMDBMigrationManager
支持 iOS SQLite 数据库迁移
Bugsnag
集成 Bugsnag 到应用中
GVUserDefaults
对 NSUserDefaults 进行了封装, 方便的进行本地化存储操作
FCCurrentLocationGeocoder
对用户当前地理位置进行正向地址编码和反向地址编码
AFSwipeToHide
页面滚动时隐藏工具栏
BaiduTranslate
非官方百度翻译工具
JSBadgeView
添加带动画效果的未读消息数提醒
Masonry
一个轻量级的布局框架, 用于替换官方的 AutoLayout 写法
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c7b4e36dbe04d56c9e30707fad872a50/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7aa3b9da742ede0e0f633f1273f8ece7/" rel="bookmark">
			2000:最长公共子上升序列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http://blog.csdn.net/persuing_truth/article/details/57406259
总时间限制: 10000ms 内存限制: 65536kB 描述 给定两个整数序列，写一个程序求它们的最长上升公共子序列。 当以下条件满足的时候，我们将长度为N的序列S 1 , S 2 , . . . , S N 称为长度为M的序列A 1 , A 2 , . . . , A M的上升子序列： 存在 1 &lt;= i 1 &lt; i 2 &lt; . . . &lt; i N &lt;= M ，使得对所有 1 &lt;= j &lt;=N，均有S j = A ij，且对于所有的1 &lt;= j &lt; N，均有S j &lt; S j+1。 输入 每个序列用两行表示，第一行是长度M(1 &lt;= M &lt;= 500)，第二行是该序列的M个整数A i (-2 31 &lt;= A i &lt; 2 31 ) 输出 在第一行，输出两个序列的最长上升公共子序列的长度L。在第二行，输出该子序列。如果有不止一个符合条件的子序列，则输出任何一个即可。 样例输入 5 1 4 2 5 -12 4 -12 1 2 4 样例输出 2 1 4 查看 提交 统计 提问 /* * 关于LCIS的具体思路及时间和空间复杂度的优化见http://blog.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7aa3b9da742ede0e0f633f1273f8ece7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9830bbc9e22a9dd3fb0a13c1cce02ffe/" rel="bookmark">
			mycat2.0配置文件schema.yml参数说明（tableType）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		tableType：
总结如下：
schemas .table. tableType属性含义:
type值
解释
MASTER
SLAVE
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf3cabdad3a57acd51fc9355f74f7dbe/" rel="bookmark">
			OpenCV实现图片轮廓检测（Python实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		轮廓检测 轮廓检测也是图像处理中经常用到的。OpenCV-Python接口中使用cv2.findContours()函数来查找检测物体的轮廓。
例子：
import cv2 # 读取图片 img = cv2.imread("E:\\font\\bmp\\kaiti\\U_004E56.bmp") # 转灰度图片 gray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY) ret, binary = cv2.threshold(gray,127,255,cv2.THRESH_BINARY) # 轮廓检测 _ ,contours, hierarchy = cv2.findContours(binary, cv2.RETR_TREE, cv2.CHAIN_APPROX_NONE) # 新打开一个图片，我这里这张图片是一张纯白图片 newImg = cv2.imread("E:\\font\\aaa.bmp") newImg = cv2.resize(newImg, (300,300)) # 画图 cv2.drawContours(newImg, contours, -1, (0,0,0), 3) # 展示 cv2.imshow("img", newImg) cv2.waitKey(0) 原图：
检测结果图：
从上图中可以看出，当检测图片轮廓时，会将图片的边框也一同检测上；因此若仅需要图片中的文字的轮廓图，则需要修改部分代码，将上面代码中的：
cv2.drawContours(newImg, contours, -1, (0,0,0), 3) 修改为下面代码：
for i in range(len(contours)-1): cv2.drawContours(newImg, contours[i+1], -1, (0,0,0), 3) 再次执行结果：
这是由于contours中保存了字体各个部分的轮廓信息，其中contours[0]保存的是图片边界的轮廓数据，因此将边界轮廓去掉即可。（其他类型的图片也一样，此处仅是拿字体图片测试）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf3cabdad3a57acd51fc9355f74f7dbe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65692e015a1bd930b9f844701f4e934d/" rel="bookmark">
			selenium之浏览器弹出新窗口（新页面）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在一个页面上点击一个链接之后，并不是在当前页面上打开，而是重新打开一个新页面；这种情况下如何跳转到新的页面上操作？
首先，需要了解的是每个窗口都有句柄的，可以理解为浏览器窗口的唯一标识符，根据这个标识符来确定新打开的窗口：
先获取当前窗口的句柄，
String current_handle = driver.getWindowHandle();
打开新窗口后获取所有窗口的句柄，
Set&lt;String&gt; all_handles = driver.getWindowHandles();
通过循环判断是不是当前的窗口句柄，
Iterator&lt;String&gt; it = all_handles.iterator();
while(it.hasnext()){
if(it.next() == current_handle){
continue;
}
//跳入新窗口
WebDriver new_driver = driver.switchTo().window(it.next());
}
新窗口的driver为new_driver，若要跳回之前的窗口，则使用如下：
driver.switchTo().window(current_handle);
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28f671fcb317c6be32277f401eaefc0a/" rel="bookmark">
			一个牛逼的 字符串拷贝函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		size_t safe_strcpy(char *dst, const char *src, size_t siz) { char *d = dst; const char *s = src; size_t n = siz; /* Copy as many bytes as will fit */ if (n != 0 &amp;&amp; --n != 0) { do { if ((*d++ = *s++) == 0) break; } while (--n != 0); } /* Not enough room in dst, add NUL and traverse rest of src */ if (n == 0) { if (siz !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/28f671fcb317c6be32277f401eaefc0a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96048f0766da2c2f8ed555b64e2e99c3/" rel="bookmark">
			vue， vux调用微信点击图片，上传图片，删除图片，接口，其中选图接口，苹果手机显示有问题，查看不到图片，提交会提示fail not exist，解决如下...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;template&gt;
&lt;div v-cloak v-show="show"&gt;
&lt;div v-show="mailbox"&gt;
&lt;div class="deanMailbox" &gt;
&lt;div class="deanMailDiv"&gt;
&lt;div&gt;
&lt;ul class="uplodeUl"&gt;
&lt;li v-for="(item,index) in images" class="uplodeLi"&gt;
&lt;img :src="item.imgSrc" class="uplodeImg"/&gt;
&lt;div @click='remove_img(index)' class="imgA"&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;div class="uplodeDean" v-if="images.length != 10" @click="chooseImg"&gt;
&lt;img src="../assets/img/uolode.png" width="100%" height="100%"/&gt;
&lt;/div&gt;
&lt;span class="uplodeTxt font16" v-if="images.length&lt;2"&gt;上传问题照片&lt;/span&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="squadButton agencyBut" v-on:click="submit"&gt;提交&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
let $ = require('Jquery')
export default {
name: 'sommoProblem',
data () {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96048f0766da2c2f8ed555b64e2e99c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a0002e9af79f238a500404221ab31a3/" rel="bookmark">
			语义分割
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Introduction Semantic Segmentation:将图像中每个像素分配到某个对象类别。图像语义分割中存在3种挑战：（1）特征分辨率减少，（2）不同尺度下的物体的存在状况，（3）由于深度卷积神经网络的不变性造成的定位精度减少。
第一个挑战是由 基于分类的卷积神经网络包含重复最大池化和降采样（步长跨度）操作造成的。深度卷积神经网络采用全卷积方式的时候，会明显降低特征地图的空间分辨率。 第二个挑战是object以多尺度形式存在于图像中。 第三个挑战是object分类器要求对空间变换具有不变性，内在地限制了深度卷积神经网络的空间精度。
在深度学习应用到计算机视觉领域之前，开发的大多数成功的语义分割系统都是采用手工特征的单调分类器，比如，提升方法（论文【Textonboost for image understanding: Multi-class object recognition and segmentation by jointly modeling texture, layout, and context, IJCV,2009.】），随机森林（论文【Semantic texton forests for image categorization and segmentation, in CVPR, 2008】），或支持向量机（论文【Class segmentation and object localization with superpixel neighborhoods, in ICCV,2009】）。通过整合更丰富的信息，内容（论文【 Semantic segmentation with second-order pooling, in ECCV, 2012】）和结构化的预测技术（论文【Efficient inference in fully connected crfs with gaussian edge potentials, in NIPS, 2011】、【Multiscale conditional random fields for image labeling, in CVPR, 2004】、【Associative hierarchical crfs for object class image segmentation, in ICCV,2009】、【CPMC: Automatic object segmentation using constrained parametric min-cuts, PAMI, vol.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a0002e9af79f238a500404221ab31a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e617996e02d64f333edfea5295360672/" rel="bookmark">
			IDEA运行缓慢解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现象 IDEA多个几个工程后，会出现运行迟缓的情况IDEA在打开大工程后（该工程下几十个子模块）电脑风扇狂响，import了好久但是一直都没有响应，结束不了；工程使用的JDK版本是1.8，但是maven编译却检查不出来： 分析 该现象出现的问题是因为IDEA的运行堆栈太小，jvm不断的出现full gc，同时存在内存溢出的风险点。因为IDEA本身也是需要运行在jvm上面的，所以如果jvm的堆配置的过小，则会导致IDEA本身运行变慢；
解决方案 mac下在application中找到idea.vmoptions文件： 修改其中jvm配置项： -Xms1024m -Xmx3072m -XX:ReservedCodeCacheSize=512m -XX:+UseCompressedOops 最大堆设置为3GB。
结果 reimport，结果飞速，风扇也没声音了！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f29e26ce9b601d307809ea39de77cb6b/" rel="bookmark">
			Unity-Rigidbody【刚体】组件-Rigidbody.AddForce的ForceMode 力的模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ForceMode 力的模式 在unity中，Rigidbody.AddForce()实现对刚体物体施加力的效果，实现物体例如碰撞，爆炸等等效果 调用函数如下：
public void AddForce(Vector3 force, ForceMode mode = ForceMode.Force); public void AddForce(float x, float y, float z, ForceMode mode = ForceMode.Force); AddForce()函数有一个参数 ForceMode , 为枚举类型 Force 添加一个可持续力到刚体，使用它的质量Acceleration 添加一个可持续加速度到刚体，忽略它的质量。Impulse 添加一个瞬间冲击力到刚体 ，使用它的质量。( 爆炸或碰撞力量 )VelocityChange 添加一个瞬间速度变化给刚体，忽略它的质量。 具体介绍如下： 在以下举例中均设刚体质量为m=2.0f，力向量为f=(10.0f,0.0f,0.0f)。
1 . ForceMode.Force：默认方式，使用刚体的质量计算，时间间隔以系统帧频间隔计算（默认值为0.02s）。
则由动量定理 f • t = m • v 可得：10 * 0.02 = 2.0 * v1，从而可得 v1=0.1 m/s，即每秒刚体在X轴上值增加0.1米
2 . ForceMode.Acceleration：忽略刚体的实际质量而采用默认值m = 1.0f，时间间隔以系统帧频间隔计算（默认值为0.02s）
则 f • t = 1.0 • v 可得：10 * 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f29e26ce9b601d307809ea39de77cb6b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7aa71d94c42a572cf91301c2d66f884a/" rel="bookmark">
			玻尔兹曼机通俗理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 玻尔兹曼机特点：
• Boltzmann机是第一个受统计力学启发的多层学习机，它是一类典型的随机神经网络属于反馈神经网络类型 。其命名来源于Boltzmann在统计热力学中的早期工作和网络本身的动态分布行为 。
• 它在神经元状态变化中引入了统计概率，网络的平衡状态服从Boltzmann分布，网络运行机制基于模拟退火算法。
• Boltzmann机结合多层前馈神经网络和离散Hopfield网络在网络结构、学习算法和动态运行机制方面的优点，是建立在离散Hopfield网基础上的，具有学习能力，能够通过一个模拟退火过程寻求最优解。不过，其训练时间比BP网络要长。
• 离散Hopfield神经网络+模拟退火+隐单元=Boltzman机
关于 Hopfield的介绍可以参考。 http://blog.csdn.net/changdejie/article/details/78099410 下图是 Boltzmann的一个具体例子。 假如现在我们有这样一个玻尔兹曼机，下面我们将来说明如何运用边的权重来建模（就是算出v1、v2出现某种状态的概率）： 我们有两个可视层节点v1、v2，两个隐藏层节点h1、h2，每个节点的取值是0或者1，那么这4个节点共有16种状态，如上表所示 分别计算这16种状态下的能量。 计算出-E之后，再计算e−Ee−E值，并且得到总的e−Ee−E值，用红色数字表示 计算p(v, h)，相当于做了归一化，把前面的每一项都除以红色的39.70 把可视层状态相同的p(v, h)概率加起来，就得到p(v)，例如可视层出现11的概率为0.466
当网络很大的时候，我们需要用马尔可夫链蒙特卡罗方法进行模型的采样和学习。过程如下。其中概率 Pj的计算就是依赖于当前的温度。用的是模拟退火算法。
具体参考 Boltzmann(玻尔兹曼机)的算法实现 http://blog.sina.com.cn/s/blog_c0ea025f0102xhk0.html 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73a341acb4e1853b459317e6406656c9/" rel="bookmark">
			Python NetworkX/Community包进行网络划分和可视化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Whenever people agree with me, i always feel i must be wrong.
每次别人赞同我时，我都觉得自己一定错了。
Python NetworkX/Community包进行网络划分和可视化 networkx 提供画图的函数有：
draw（G，[pos,ax,hold]） draw_networkx(G，[pos,with_labels]) draw_networkx_nodes(G,pos,[nodelist]) 绘制网络G的节点图 draw_networkx_edges(G,pos[edgelist]) 绘制网络G的边图 draw_networkx_edge_labels(G, pos[, …]) 绘制网络G的边图，边有label —有layout 布局画图函数的分界线— draw_circular(G, **kwargs) Draw the graph G with a circular layout. draw_random(G, **kwargs) Draw the graph G with a random layout. draw_spectral(G, **kwargs) Draw the graph G with a spectral layout. draw_spring(G, **kwargs) Draw the graph G with a spring layout. draw_shell(G, **kwargs) Draw networkx graph with shell layout.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/73a341acb4e1853b459317e6406656c9/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/525/">«</a>
	<span class="pagination__item pagination__item--current">526/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/527/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>