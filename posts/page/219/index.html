<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a505cec3edd9ca387e588db5bd34e85a/" rel="bookmark">
			一、点亮LED和流水灯设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点亮LED和流水灯设计 参考书籍：51单片机C语言教程
视频链接：参考视频
单片机型号：巫妖王51单片机V2版
单片机概述 什么是单片机?
Micro Controller Unit简称MCU,即单片微型计算机，简称单片机。
用专业语言讲，单片机就是在一块硅片上集成了微处理器、存储器及各种输入/输出接口的芯片，这样一块芯片就具有了计算机的属性，因此称为单片微型机，也叫单片机。
通俗点来说，单片机就是一块集成芯片，但这块集成芯片具有一些特殊的功能，而功能的实现要靠我们使用者自己来编程完成。我们编程的目的就是控制这个芯片的各个引脚在不同时间输出不同的电平，进而控制单片机各个引脚相连接的外围电路的电气状态。
单片机能作什么
单片机属于控制类数字芯片，目前其应用领域非常广泛。
单片机如何学习
理论和实践需要相辅相成。
点亮LED LED介绍电阻阻值看法电平LED点亮的原理 LED原理图：
LED点亮代码如下：
#include &lt;REGX52.H&gt; void main() { P2=0xFE;	//对P2口的8个I/O口同时操作，0x代表后面的数据是以十六进制表示的，十六进制的FE //表示的是 1111 1110 //原理图上表示 P20对应的LED为D2，故D2亮，其余不亮 while(1) //用于程序的死循环 {	} } //书上的另外一种写法:9 /* #include &lt;REGX52.H&gt; sbit led1=P2^0; //声明单片机P2口的第一位（最低位），将单片机P2口的最低位定义为led1 void() { led1=0; //点亮第一个发光二极管,对P2口的最低位清0，由于没有操作其他位，所以其他位均保持原来的状态不变 } */ 头文件：reg51.h和reg52.h是定义51单片机或52单片机特殊功能寄存器和位寄存器的。
main()函数
格式：void main()
特点：无返回值，无参数。
无返回值，表示该函数执行之后不返回任何值，上面的main前面的void表示“空”，即不返回值的意思。
无参数表示该函数不带任何参数，即main后面的括号中没有任何参数，我们只写“（）”就可以，也可以在括号里写上void，表示“空”的意思，如void main(void)
任何一个单片程序有且仅有一个main函数，它是整个程序开始执行的入口。
电平特性：
单片机是一种数字集成芯片，数字电路中只有两种电平：高电平和低电平。常用的逻辑电平有TTL、CMOS、LVTTL、ECL、PECL、GTL等。其中TTL和CMOS的逻辑电平可分为四类：5V系列（5V TTL和5V CMOS）、3.3V系列、2.5V系列和1.8V系列。
常见的51单片机通常使用TTL电平信号，+5V等价逻辑1，0V等价逻辑0。
while（）语句
格式：
while（表达式） { 内部语句（内部可空） } 特点：先判断表达式，后执行内部语句。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a505cec3edd9ca387e588db5bd34e85a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/686e4394b4d38b08e4bb33977bf6ac2a/" rel="bookmark">
			超快全球任播OCSP：白嫖谷歌云免费SSL证书！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		起因 这次*.google.com被DNS污染，属于是让我增长了很多知识（污染详情：https://www.v2ex.com/t/884153 （需智能上网））
其中有提到，谷歌云签发的SSL证书也不可用，当时也没有多想，觉得可能是他们用了谷歌云的CDN吧（在我印象中能申请谷歌云SSL证书的好像只有负载均衡，至少2年前肯定是这样）
后来我才知道，谷歌居然推出了免费的SSL证书，属实是又2G网了。
介绍 谷歌官方的说明文档--&gt;https://cloud.google.com/blog/products/identity-security/automate-public-certificate-lifecycle-management-via--acme-client-api （需智能上网）
浅浅机翻一下（顺推销下自己：如果您的Chome浏览器翻译功能不可用，可以按照 谷歌翻译在中国大陆无法使用的临时解决方案 | Toms Project 官方博客 来免费解决哦！）
反正就是一些满正式的介绍，看多了对今天的文章似乎没有什么帮助。
到此，如果没有什么特性的话估计大家就不用他的证书了，毕竟还有LetsEncrypt呢。所以，谷歌云的证书还真有点特性。
特性(优缺点) 1.超快国内+全球任播OCSP 貌似是为数不多唯一在国内有节点的免费SSL证书提供商了吧。
与此同时，这也是一个缺点：一旦在发生这样子的智能事件，恭喜你，你的网站需要等待10秒以上才会加载（苹果好像是这样）
2.支持ECC 但不是全证书链，无法导入到AWS（别问我咋知道的呜呜呜）
3.兼容性 很多人担心谷歌云证书兼容性的问题，毕竟使用的是谷歌自己2016年的根证书，其实这样的担心是不必要的，因为谷歌的根证书有GlobalSign Root CA的交叉签名。而GlobalSign Root CA的兼容性就不用说了吧，Windows XP都支持。
申请教程 （官方教程，使用certbot：https://cloud.google.com/certificate-manager/docs/public-ca-tutorial）
1.GCP账号 这个就不用多说了吧，相信热爱白嫖的大家肯定都有个。
2.启用API/申请key 前往 https://console.cloud.google.com/apis/library/publicca.googleapis.com?project=你的GCP项目ID
点击启用
看到已启用后，打开 Google Cloud Shell。
输入
gcloud beta publicca external-account-keys create
点击授权
随即得到我们之后会用到的 EAB key ID 和 HMAC。
Created an external account key
[b64MacKey: BG9r4IuOijLdS5fyDOyVmRdV7r7SWdqEj3TKrrjwHYHqo阿巴阿巴PGuxc6PVktkxkhE5jKTHI8WeqZM-pSOxug
keyId: 50219939f4aa6tomsprff9adb161a49528c]
3.申请证书 这里我们使用acme.sh来申请，这里默认你已经安装了acme.sh并且大致会使用，如果是新手，请看烧饼博客的教程：https://u.sb/acme-sh-ssl/
命令行运行
acme.sh --register-account --server google -m "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/686e4394b4d38b08e4bb33977bf6ac2a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5beb2282a9ff6b602c28dddb52fa057e/" rel="bookmark">
			【C初阶】第一篇——初识C语言(万字篇,带你敲响C语言的大门)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		接受平凡，努力出众，承认普通,但拒绝沉沦于平庸。大家好，我是你们的老朋友,小KK。 满满的 ​前言
​什么C语言？ ​数据类型 ​变量和常量 ​定义变量的方法 ​变量的分类 ​变量的作用域和生命周期 ​常量 ​字符串 ​转义字符 ​选择语句 ​循环语句 ​函数 ​数组 ​操作符 ​常见关键字 ​#define 定义常量和宏 ​指针 ​指针变量的大小 ​结构体 此博客所用到的代码我存在了gitee，可以看初始C语言: 初始C语言
前言 原本打算是上一年写C语言这个系列的,由于本人比较懒，再加上学校的事比较多,所以就拖到了现在,前段时间是想着不更新这部分内容的,不过总感觉学的不踏实,缺了点什么,
所以打算利用10余天时间把C语言系列更新完,和大家一起学习进步！！！
话不多说,直接开卷(本篇会概述一下C语言的各个语法,后面细讲)
什么C语言？ C语言是一门通用计算机编程语言，广泛应用于底层开发。C语言的设计目标是提供一种能以简易的方式编译、处理低级存储器、产生少量的机器码以及不需要任何运行环境支持便能运行的编程语言。
尽管C语言提供了许多低级处理的功能，但仍然保持着良好跨平台的特性，以一个标准规格写出的C语言程序可在许多电脑平台上进行编译，甚至包含一些嵌入式处理器（单片机或称MCU）以及超级电脑等作业平台
C语言是一种面向过程的编程语言,与java,c++等面向对象的编程语言有所不同。
数据类型 char //字符数据类型
short //短整型
int //整形
long //长整形
long long //更长的整形
float //单精度浮点数
double //双精度浮点数
注:C语言中有字符串类型嘛?
C语言中没有字符串类型,C++中有
每种类型的大小
这里我简单拓展下,
bit 比特
byte 字节 =8bit
kb 1024byte
mb 1024kb
gb 1024mb
tb 1024gb
pb 1024tb
想更深入的了解其中的关系和取值范围,可以看我写的计算机组成原理.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5beb2282a9ff6b602c28dddb52fa057e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/606acb1b77573fabe1f7d12006a9c67e/" rel="bookmark">
			希尔排序详解及代码(Java)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、希尔排序原理
将数据区分成特定的间隔的几个小区块，以插入排序法排完区块内容的数据后再渐渐减少间隔的距离。下面以10、5、30、15、6等5位数进行图形演示。
代码：
package Sort; public class shell { //定义排序的数组并给予赋值 private static Integer[] nums = {10,5,30,15,6}; //定义扫描次数 private static Integer number = 1; //希尔排序法 public static void Shell_Sort(){ System.out.println("---希尔排序---"); //定义希尔增量 Integer gap = nums.length / 2; //当gap不等于0时也就是数据划分还可以再缩小间隔时继续循环 while (gap != 0){ //对数组进行分组 for (int i = 0;i &lt; gap;i++){ //for循环进行插叙排序 for (int j = i+gap;j &lt; nums.length; j += gap){ //获取当前值 Integer current = nums[j]; //从尾开始向前找，因为插入之前都是排好序的 for (int k = j - gap;k &gt;=i;k -= gap){ if (nums[k] &gt; current){ //插入排序 nums[k + gap] = nums[k]; nums[k] = current; } } } } gap /= 2; print(); } } public static void print(){ System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/606acb1b77573fabe1f7d12006a9c67e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/120715ede20819698553c47c87e83e6d/" rel="bookmark">
			插入排序详解及代码（Java）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、插入排序原理
将数组中的元素，逐一与已安排好的数据进行比较，前两个元素先排好，再将第三个元素插入适当的位置，所以这三个元素仍然是已排好的，接着再将第四个元素加入，重复此步骤，直到排序完成为止。下面以10、5、30、15、6等5位数进行图形演示。
代码:
package Sort; public class Sort { //定义排序的数组并给予赋值 private static Integer[] nums = {10,5,30,15,6}; //插入排序 private static void Insertion_Sort(){ System.out.println("---插入排序---"); // 预设数组空间大小。 Integer[] nums2 = new Integer[5]; //数组赋值 nums2[0] = nums[0]; //设数组第二位为空也就是下表为1 Integer nullPosition = 1; //外层循环插入数值 for (int i = 1;i &lt; nums.length;i++){ Boolean flag = false; //内层循环找到插入元素的位置 for (int j = 0;j &lt; nullPosition;j++){ //nums[i]代表要插入的元素 //num2[j]代表有序数组的元素 if (nums[i] &lt; nums2[j]){ //从尾到头的移动过程 for (int m = nullPosition;m &gt; j;m--){ //开始移动 nums2[m] = nums2[m - 1]; } //新元素插入 nums2[j] = nums[i]; //为下面的插入提供判断条件 flag = true; nullPosition++; //跳出内循环 break; } } if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/120715ede20819698553c47c87e83e6d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38be0f4b8396dbc7aa684f7187e9968b/" rel="bookmark">
			二分法查找（折半查找）算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一，什么是二分查找
二分查找，是一种在有序数组中查找某一特定元素的查找算法。
二，算法思路
(令左右下标分别为left,right，其中left初始值为0，rightd的初始值为sizeof(arr)/sizeof(arr[0])-1 令中间元素的下标mid为(right+left)/2)。查找从中间元素开始，若查找的元素大于或小于中间元素，则在数组元素大于或小于中间元素的那一半中查找。直到中间元素正好是要查找元素，若left&lt;=right,则表示找到了；若right&lt;left,则 表示找不到。 三，算法图解 我们以如图数组(arr)为例,假设元素7为我们要查找的元素。
四，代码实现
#include&lt;stdio.h&gt; int main() { int arr[] = { 1,3,5,7,9,11,13 }; int left = 0; int right = sizeof(arr) / sizeof(arr[0]) - 1; int mid = 0; printf("请输入要查找的数字：\n"); int n = 0; scanf("%d", &amp;n); while (left &lt;= right) { mid = (left + right) / 2; if (arr[mid] &lt; n) { left = mid + 1; } else if (arr[mid] &gt; n) { right = mid - 1; } else { break; } } if (left &lt;= right) printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/38be0f4b8396dbc7aa684f7187e9968b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/700ec397b5a262f5c76cde6503d0645d/" rel="bookmark">
			Pytorch预训练模型相同输入输出不同解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 设置随机种子。
2. 冻结BN层。
3. 模型参数得requires_grad设置为False。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74bbcb99de65298a4561f877299419e3/" rel="bookmark">
			列表与元组的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		列表与元组的区别主要体现在以下几个方面： 列表属于可变序列，它的元素可以随时修改或删除，元组是不可变序列，其中元素不可修改，只能整体替换。
列表可以使用append()、extend()、insert()、remove()和pop()等方法实现添加和修改，元组则没有这几个方法。
列表可以使用切片访问和修改列表中的元素，元组也支持切片，但是它只能通过切片访问。
元组比列表的访问和处理速度快，如果只需要访问不需要修改，建议使用元组。 列表不能作为字典的键，而元组则可以。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb5c1aa496d9768d66d3de88cff7bf3a/" rel="bookmark">
			pytorch实战——气温预测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		year,month,day,week 分别表示具体的时间temp_2:前天的最高温度值temp_1:昨天的最高温度值average:在历史中，每年这一天的平均最高温度值actual：这就是我们的标签值，当天的真实最高温度friend：你的朋友猜测的可能值 #coding=utf-8 from ast import increment_lineno from cProfile import label from pickletools import optimize from pyexpat import features import numpy as np import pandas as pd import matplotlib.pyplot as plt import torch import torch.optim as optim import warnings import datetime from sklearn import preprocessing # ***************************************读入数据********************************************# #读入数据 data=pd.read_csv('temps.csv') #展示前几行数据 print(data.head()) #数据维度,列表示特征值 # print("data_dim:",data.shape) # ******************************************************************************************# # *******************************************处理时间数据************************************# #处理时间数据 years =data['year'] months = data['month'] days = data['day'] #datetime格式 #必须把str转换为datetime。转换方法是通过datetime.strptime()实现 #datetime.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb5c1aa496d9768d66d3de88cff7bf3a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e7dd9168504b43a87d65d720369b4fb/" rel="bookmark">
			flutter 常用的插件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考
Skip to content Product Solutions Open Source Pricing Search Sign in Sign up jahnli / awesome-flutter-plugins Public Code Issues Pull requests Actions Projects Security Insights awesome-flutter-plugins/README.md @jahnli jahnli Update README.md Latest commit 3652348 3 days ago History 2 contributors @jahnli@lanzhu1993 6845 lines (5999 sloc) 253 KB awesome-flutter-plugins 🔥🔥 收集好用的Flutter插件以便更高效的开发， 如果有好用的插件或者建议，请Issue 或 PR ， 期待参与。 收录 941 个 10-01 webview_windows - 适用于 Windows 平台的基于 WebView2 的 webview 实现 flutter_webview_pro - 提供支持照片上传/拍照和地理定位的 WebView 小部件 flutter_web_auth - Flutter 插件，用于通过 Web 服务对用户进行身份验证 rich_clipboard - Flutter 插件，用于访问系统剪贴板中的富文本和其他数据类型 calendar_date_picker2 - 基于 Flutter CalendarDatePicker 的轻量级可定制日历选择器，支持单日期选择器、范围选择器和多选择器 web_view_tts - 在 Flutter WebView Android 中添加 Text-To-Speech 支持的 Flutter 插件 web_view_ble - 在适用于 Android 和 iOS 的 WebView Flutter 中添加低功耗蓝牙支持 flutter_side_menu - 完全可定制的侧边菜单 07-23 system_info2 - 提供对有关系统的有用信息（架构、位数、内核、内存、操作系统、CPU、用户）的轻松访问 moment_dart - 将 DateTime 转换为人类可读格式的包。灵感来自 moment.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e7dd9168504b43a87d65d720369b4fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60df7835bb2fed7aba881ffc0d882fb0/" rel="bookmark">
			为什么单线程的Redis那么快？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. Redis单线程的本质 其实，Redis并不是单线程，我们之所以会一直称Redis是单线程，这是因为Redis在处理客户端的读写请求时，只有一个主线程，而在处理以下这些操作时，Redis会fork出其他的子线程来处理：
主从数据同步切片集群数据同步过期键值异步删除AOF或RDB持久化 所以整体来看Redis并不是单线程。
在Redis6.0中引入的多线程机制，实际上只是将网络IO读写处理这块逻辑变成多线程，因为在Redis6.0以前的版本中， 网络IO请求也是在主线程中进行处理，随着互联网应用的高并发访问以及网络硬件性能的提升，在主线程中进行网络IO处理已经成为Redis的瓶颈，因此使用多线程来处理网络IO请求，可以显示提高Redis响应速度，而对于键值对的读写，仍然由主线程一个线程进行处理，这样可以仍然可以不用加锁也能保证读写操作的原子性，避免多线程互斥机制带来的性能损耗。
2. 单线程为什么那么快？ 通过前面的介绍，我们知道，Redis并非完全是单线程，但在处理网络IO和数据读写等Redis核心功能时，Redis确实是由主线程处理的，那么我们就不禁有个疑问，Redis的单线程为什么那么快呢？
总结了以下大概有以下四个方面的原因：
内存操作高效的底层数据结构多路复用IO模型避免多线程切换开销 2.1 内存操作 Redis是内存数据库，读写操作都在内存中，学过计算机基础的我们都知道，CPU读取内存的速度要比读取磁盘的速度快得多，所以单台Redis服务器每秒能处理数十万的读取也就不足为怪了，事实上，基于内存的读写操作，是Redis能这么快的最重要的原因。
2.2 高效的底层数据结构 我们都知道Redis提供了五种非常好用的数据类型：String，List，Hash，Set，Sorted Set。
Redis有六种底层数据结构，分别为哈希表，压缩列表，跳表，整数数组，简单动态字符串。
数据类型与其底层数据结构对应关系如下图所示
总结来说就是：
String：Redis没有使用C语言内置的字符数组，而是将字符数组封装为简单动态字符串(SDS)，虽然SDS比C语言原生字符数组更费内存，但通过空间换时间，可以将很多C语言字符数组时间复杂度为O(n)的操作转为O(1)，提高处理速度，比如strlen命令获取String长度时，对于C语言的字符数组，需要遍历数组才能知道，时间复杂度为O(n)，而简单动态字符串已经保存了字符串的长度，因此可以直接获取，时间复杂度为O(1)。
Hash：在数据量还不多的情况下，Hash类型使用压缩列表(ZipList)保存元素，因为元素不多，所以查找也比较快，如果数据增长到设定的值，就改为哈希表，而哈希表查找元素的时间复杂度为O(1)，所以也是相当快的。
List：List的底层数据结构为双向链表和压缩列表组合而成的，也称为快速链表(QuickList)，因此List类型非常适合头尾插入弹出的操作，因此如果要把Redis作为队列的话，选择List是非常高效的。
Sorted Set：当元素数量不多时，Sorted Set使用的是压缩列表，只有当元素超过设定值时，才使用跳表和哈希表。
Set：在元素的数值都是整数时，Set使用整数数组保存数据，如果元素数量达到设置的值，则改为哈希表。
Redis是一个Key-Value健值对数据库，我们上面介绍的五种类型是指Key-Value中的Value，对于所有Key到Value之间的映射，Redis也是采用哈希表，这个哈希表也叫全局哈希表，如下图所示：
2.3 多路复用IO模型 Redis高性能的另一个重要的原因是采用多路复用IO模型，由于Redis是单线程处理网络请求的，如果采用阻塞IO模型，那么对于每一个请求，Redis需要从接收连接-&gt;读取连接数据-&gt;处理命令-&gt;返回数据整个流程处理完成后才能处理处理下一个请求，如果是这样的话，那么Redis的快就无从谈起了。
而采用非阻塞模型IO，虽然可以避免阻塞，但这种模型会在内核空间与用户空间来回复制全部要监听的FD(文件描述符)，除了之外，我们还无法得知哪个FD已经就绪了，需要遍历所有的FD才能知道，同样是即费空间又费时间，因此对于需要支持高并发的Redis来说，显然也是不可接受的。
而多路复用IO模型则不同了，多路复用IO模型同样也是非阻塞的，其内置的红黑树可以高效地添加或查找FD，且只会将已经就绪的的FD从内核空间复制到用户空间，因此很多网络应用处理请求时都是使用多路复用IO模型，Redis也不例外。
多路复用IO模型在不同的操作系统有不同的实现，如selec和poll，还有更性能更好的epoll，Redis不同操作系统的多路复用IO模型都有封装。
2.4 避免多线程切换 因为将数据保存在内存中，并且有高效的数据结构和使用多路利用IO模型，所以Redis读取数据非常快速，这时候，你可能会想，是不是将Redis改为多线程，可以更好提升Redis的吞吐量，处理更多并发请求呢？
其实不然，正因为Redis读取非常快，所以如果采用多线程的话，会产生以下两个问题：
多线程切换带来的额外开销：因为Redis读写非常快速，因为如果采用多线程，那么线程切换就非常频繁，所以如果采用多线程的话，Redis大部分时间可能都在切换线程。数据加锁的性能损耗：多线程访问同一个数据的话，为了避免竞争，肯定需要加锁保证数据操作的原子性，而加锁与等待锁的释放，让多个线程在读取同一个数据需要排队等待，所以效率并不比单线程强多少。 3 怎么让Redis更快 单台Redis服务器，已经非常快了，那么，有什么办法能让Redis更快呢？
使用AOF或RDB数据备份：有了数据备份，可以在服务器宕机时，更快地恢复主从分离：让从服务器分担主服务器的压力，实现更快地响应切片集群：除了主从，切片集群让数据分散到不同服务器，多台服务器可分担读写的压力避免bigkey：bigkey是指键值过大或者集合元素过多，占用太多的带宽与CPU运算，导致主线程阻塞，所以要避免在Redis存储比较大的值，比如对于value来说，不要超过10KB，对于集合元素，元素的数量最好不要超过1000 4 小结 从上面的分析我们可以看，Redis并不是像我们认为的是单线程，在处理持久化等耗时任务时，Redis也是采用多线程的处理方式，不过，Redis在处理请求时只有一个主线程，但仍然做非常快速的响应，这是由于Redis的数据读写都在内存中，而内存的访问是非常快速的，另外Redis为每一种数据类型都精心设计了高效的底层数据结构，而在处理网络请求时，则采用基于多路复用的IO模型，使得Redis可以高并地处理更多的请求。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56187430c36cbd2a56f7e039f6233585/" rel="bookmark">
			Java常用到的6个加密技术，先收藏，总会用得到
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		加密，是以某种特殊的算法改变原有的信息数据，使得未授权的用户即使获得了已加密的信息，但因不知解密的方法，仍然无法了解信息的内容。大体上分为双向加密和单向加密，而双向加密又分为对称加密和非对称加密(有些资料将加密直接分为对称加密和非对称加密)。
双向加密大体意思就是明文加密后形成密文，可以通过算法还原成明文。而单向加密只是对信息进行了摘要计算，不能通过算法生成明文，单向加密从严格意思上说不能算是加密的一种，应该算是摘要算法吧。
代码混淆工具大全https://www.evget.com/category/30
目前市场上已经有很多比较成熟的代码加密的软件，企业已经可以通过购买很多技术来对自己的数据加以保护，加密是安全的一个方重要方面，特别是对于程序开发企业和个人来说，下面小编就给大家简单介绍下java常用的几个代码加密技术~
一、Base64算法
从现在加密算法的复杂性来看Base64这种都不好意思说自己是加密，不过对于完全不懂计算机的人来说也够用了。采用Base64编码具有不可读性，即所编码的数据不会被人用肉眼所直接看到。
Base64编码一般用于url的处理，或者说任何你不想让普通人一眼就知道是啥的东西都可以用Base64编码处理后再发布在网络上。
二、消息摘要算法（Message Digest）
消息摘要（Message Digest）又称为数字摘要(Digital Digest)。它是一个唯一对应一个消息或文本的固定长度的值，它由一个单向Hash加密函数对消息进行作用而产生。HASH函数的抗冲突性使得如果一段明文稍有变化，哪怕只更改该段落的一个字母，通过哈希算法作用后都将产生不同的值。而HASH算法的单向性使得要找到哈希值相同的两个不同的输入消息，在计算上是不可能的。所以数据的哈希值，即消息摘要，可以检验数据的完整性。
用大白话来说，任何一段数据应该都和人一样是唯一的，唯一的标识是什么，人类的话目前就是指纹，而数据的指纹是什么呢？没错，就是消息摘要算法产生的这一段String。比如我们在注册网站的时候，客户端向服务器传输的，应该是我们输入的密码进行消息摘要处理后的内容，这样就算服务器被攻破，Hack也无法知道用户真实的密码是什么。不过有说现在MD5和SHA已经被攻破了，具体大家可以谷歌。
三、对称加密
采用单钥密码系统的加密方法，同一个密钥可以同时用作信息的加密和解密，这种加密方法称为对称加密，也称为单密钥加密。而因为加密和解密都使用同一个密钥，如何把密钥安全地传递到解密者手上就成了必须要解决的问题。当然，安全性较低带来的优点就是优计算量小、加密速度快、加密效率高。然而现代计算机对这种级别的计算量早就不care了，安全才是最重要的。
（1） DES
DES，全称为“Data Encryption Standard”，中文名为“数据加密标准”，是一种使用密钥加密的块算法。DES 算法为密码体制中的对称密码体制，又被称为美国数据加密标准，是 1972 年美国 IBM 公司研制的对称密码体制加密算法。 明文按 64 位进行分组，密钥长 64 位，密钥事实上是 56 位参与 DES 运算（第8、16、24、32、40、48、56、64 位是校验位， 使得每个密钥都有奇数个 1）分组后的明文组和 56 位的密钥按位替代或交换的方法形成密文组的加密方法。
（2）Triple DES
3DES3DES，也就是“Triple DES”，中文名“三重数据加密算法”，它相当于是对每个数据块应用三次 DES 加密算法。由于计算机运算能力的增强，原版 DES 密码的密钥长度变得容易被暴力破解；3DES 即是设计用来提供一种相对简单的方法，即通过增加 DES 的密钥长度来避免类似的攻击，而不是设计一种全新的块密码算法。
（3）AESAES
AESAES，全称为“Advanced Encryption Standard”，中文名“高级加密标准”，在密码学中又称 Rijndael 加密法，是美国联邦政府采用的一种区块加密标准。AES 加密算法作为新一代的数据加密标准汇聚了强安全性、高性能、高效率、易用和灵活等优点。AES 设计有三个密钥长度：128，192，256 位。相对而言，AES 的 128 密钥比 DES 的 56 密钥强了 1021 倍。
（4）PBE
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/56187430c36cbd2a56f7e039f6233585/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c195cbb8d3d76e256102d2754b9736ca/" rel="bookmark">
			springboot&#43;mybatis拦截器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目需求，需要每个表添加一个机构标识， 由于来的分表合并为一个表中，通过机构标识来过滤数据。一个一个加太繁琐，所以使有了mybatis的拦截器。
先来说一下拦截器不生效的问题。开始想使用@component注解来注入拦截器，谁成想，拦截器确不生效。后来发现可能跟我的多数据源有问题。后来使用两个方法可解决，如有以下拦截器：
package com.zm.config; import com.alibaba.nacos.common.utils.StringUtils; import net.sf.jsqlparser.expression.operators.relational.ExpressionList; import net.sf.jsqlparser.schema.Column; import lombok.extern.slf4j.Slf4j; import net.sf.jsqlparser.expression.Expression; import net.sf.jsqlparser.parser.CCJSqlParserUtil; import net.sf.jsqlparser.schema.Table; import net.sf.jsqlparser.statement.Statement; import net.sf.jsqlparser.statement.select.FromItem; import net.sf.jsqlparser.statement.select.Join; import net.sf.jsqlparser.statement.select.PlainSelect; import net.sf.jsqlparser.statement.select.Select; import net.sf.jsqlparser.statement.update.Update; import net.sf.jsqlparser.util.deparser.ExpressionDeParser; import net.sf.jsqlparser.statement.insert.Insert; import org.apache.ibatis.executor.statement.StatementHandler; import org.apache.ibatis.mapping.BoundSql; import org.apache.ibatis.mapping.MappedStatement; import org.apache.ibatis.mapping.SqlCommandType; import org.apache.ibatis.plugin.*; import org.apache.ibatis.reflection.DefaultReflectorFactory; import org.apache.ibatis.reflection.MetaObject; import org.apache.ibatis.reflection.SystemMetaObject; import org.springframework.beans.factory.annotation.Value; import org.springframework.stereotype.Component; import org.springframework.web.context.request.RequestAttributes; import org.springframework.web.context.request.RequestContextHolder; import org.springframework.web.context.request.ServletRequestAttributes; import org.springframework.web.servlet.HandlerMapping; import javax.servlet.http.HttpServletRequest; import java.lang.ref.WeakReference; import java.lang.reflect.Field; import java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c195cbb8d3d76e256102d2754b9736ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9e1232b37b6f28f5f058321cec38b29/" rel="bookmark">
			kafka学习（五）：消费者分区策略（再平衡机制）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		kafka再平衡机制：指的是kafka consumer锁订阅的topic发生变化时 发生的一种分区重分配机制。
一般有三种情况会出发consumer的分区分配策略（再平衡机制）：
1、consumer group 中新增或删除某个consumer，导致其所消费的分区需要分配到组内其他的consumer上。
2、consumer订阅的topic发生变化，比如订阅的topic采用的是正则表达式的形式。如 test-* 此时如果有新建了一个topic test-user，那么这个topic的所有分区也是会自动分配给当前的consumer的，此时就会发生再平衡。
3、consumer所订阅的topic发生了新增分区的行为，那么新增的分区就会分配给当前的consumer，此时就会触发再平衡。
Kafka Consumer用来从Kafka集群拉取数据，通过consumer groups允许多个进程共同分担消费/处理数据的工作，这些进程可以运行在一台机器或者多台机器。而ConsumerPartitionAssignor接口用来定制consumer的分区分配策略。通过consumer配置项partition.assignment.strtegy指定分区分配策略类。消费者分区分配策略类的实现方法共有四种。 第一种分区策略：RoundRobinAssignor
第二种分区策略：RangeAssignor
第三种分区策略：StickyAssignor
第四种分区策略：CooperativeStickyAssignor（kafka2.4.0版本引入的策略）
修改kafka分区分配策略：
partition.assignment.strategy= range+CooperativeStucky或 roundrobin，kafka可以同时使用多个分区分配策略。
1、RangeAssignor ：范围分区分配策略 partition.assignment.strategy=]org.apache.kafka.clients.consumer.RangeAssignor 它是以单个Topic为一个维度来计算分配的, 只负责将每一个Topic的分区尽可能均衡的分配给消费者:
消费组里面所有消费者consumer按照字母排序，给Topic的分区按照分区号排序。
先计算每个分区最少平均分配多少个分区数, 然后余下的逐个分。
即：首先会计算每个consumer可以消费的分区个数，然后按照顺序将指定个数范围的分区分配给各个consumer。
示例：
如上图，有topic t1 和 消费组，t1 有四个分区，消费组有三个消费者。
分区依次为：p0、p1、p2、p3
假设 N = 分区数，M = 消费者数量
A = N/M = 4/3 = 1 -- 每个消费者最少的分区数
B = N%M = 4%3 = 1 -- 需要多消费分区的 消费者个数
分配：前B个消费者，分配A+1个分区，其余的消费者分配 A个分区。
所以，最终的分配结果就是:
c0：p0、p1
c1：p2
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d9e1232b37b6f28f5f058321cec38b29/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a315c5aeea26287ec3eff3d2b057d157/" rel="bookmark">
			shp数据中文乱码的一种恢复方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、准备 1、QGIS软件
2、乱码识别网站
二、转换步骤 （一）示例展示 如图，有一个不知道怎么产生的shp文件，在arcmap中，中文字段显示乱码，添加cpg文件后，仍然无法解决。
（二）恢复步骤 1.复制乱码，在乱码识别网站（http://www.mytju.com/classcode/tools/messyCodeRecover.asp）中识别其编码。发现原来的编码是UTF-8，现在的编码是GBK
2.使用QGIS软件恢复编码
（1）用QGIS加载乱码shp
（2）右键点击图层“属性”
源—UTF-8—OK
（3）设置完成后，查看属性是否乱码
（4）图层右键导出shp数据。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/efed474563d6c17267a08c5785a5a9c3/" rel="bookmark">
			【ROM定制】官改教程:super.img解打包！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		看到很多人貌似都不会1,特此简单的写一下，
此文参考了@上下五千年666666 和@tong1298 二位大佬的教程，特加提炼
需要用到的工具以及获取方式:
Termux：用来安装TIK，以及操作解打包
获取：https
://lecloud.lenovo.com/share/qHeZixSqRNLganZU（密码：i9qp）
解压后恢复备份，需要root权限
DNA-Android：用来合并Super分段和去除vb验证
获取：需要在大佬群文件内查找，入口在@tao1996 主页
在这里面需要用到最新版的工具箱和插件里的合并super文件包括去除vb插件
Tiny Fastboot Sript:可以不用自己写脚本。
获取：相信大家都有吧！
～～～～～～～～～～～～～～～～～～～～～～～～～～～～～
废话不多说，即刻开始讲解。
1,首先我以EU最新版为例
包都是现下
2,打开mt管理器解压Rom包，
3,打开DNA ANDROID，授予存储与root权限
之后新建工程，
之后打开mt管理器，把super分段镜像0-11移动到dna工程目录
打开Dna安卓工具，点击工程菜单，点击插件功能，点击合并分段super插件
这样就已经合并完了12g是正常的
然后新建打开dna工程，打开mt管理器把vbmeta和vbmeta_system.img两个文件移动到新工程目录，
再次打开dna安卓，插件功能里找到去除vb验证执行，out目录内是已经输出的去验证文件，然后把它们都移动回原压缩包
4,打开termux输入su获取权限
然后，退出应用长按应用图标进入设置，点击权限授予允许管理所有！！！
之后把应用强行停止再进入，输入ubuntu进入TIK
必须操作上一步，吧应用强行停止
5,打开mt管理器解压Rom包，实际在tik解压也行，楼主习惯使用mt。
6,在tik创建任务。注意不要使用中文！
我这里创建的是“0”
然后把dna安卓里合并的super移动到tik项目里
tik的项目目录是/data/data/com.termux/files/home/ubuntu/root/TIK/你创建的项目名称
之后输入2选择解包菜单
输入0,分解所有文件
分解完后是这样的
然后把b分区文件全删了，因为是白的！
只保留a区四个
之后再把这四个文件移动到项目目录！
现在可以把super.img删除了
之后到termux
还是解压所有文件
解压好后是这样的，
你可以到目录去删除一些用不到的软件，去除温控添加功能等等！我这里就不发图了接打包！
我也不知道这super哪里蹦出来的，所以逐个选择img格式打包把！
打包完后，建议新作一个工程目录！
然后把打包出来的img镜像移动到新目录
到目录里手动创建一个文件夹命名为super
之后把镜像移动到super文件夹
然后开始打包！
选择66打包super
按我的填写就行最后回车
出现类似提示，即打包成功！
最后你就可以把他移动到最开始解压的那个压缩包进行压缩啦
最后用tfs刷入我就不做过多解释啦
稍等我测试一下会放上本帖的栗子！
EU最新解锁分区版本！
测试🌰已经因误删文件报废！
#motorolaedgespro# #MotoedgeS30# #MotoedgeX30#
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7646bb9a133d8b8429e596f8f17bbadd/" rel="bookmark">
			Go常见错误系列的第13篇：init函数的常见错误和最佳实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 这是Go常见错误系列的第13篇：init函数的常见错误和最佳实践。
素材来源于Go布道者，现Docker公司资深工程师Teiva Harsanyi。
本文涉及的源代码全部开源在：Go常见错误源代码，欢迎大家关注，及时获取本系列最新更新。
常见错误和最佳实践 很多Go语言开发者会错误地使用package里的init函数，导致代码难懂，维护困难。
我们先回顾下package里init函数的概念，然后讲解init函数的常见错误和最佳实践。
init基本概念 Go语言里的init函数有如下特点：
init函数没有参数，没有返回值。如果加了参数或返回值，会编译报错。一个package下面的每个.go源文件都可以有自己的init函数。当这个package被import时，就会执行该package下的init函数。一个.go源文件里可以有一个或者多个init函数，虽然函数签名完全一样，但是Go允许这么做。.go源文件里的全局常量和变量会先被编译器解析，然后再执行init函数。 示例1 我们来看如下的代码示例：
package main import "fmt" func init() { fmt.Println("init") } func init() { fmt.Println(a) } func main() { fmt.Println("main") } var a = func() int { fmt.Println("var") return 0 }() go run main.go执行这段程序的结果是：
var init 0 main 全局变量a的定义虽然放在了最后面，但是先被编译器解析，然后执行init函数，最后执行main函数。
示例2 有2个package: main和redis，main这个package依赖了redis这个package。
package main import ( "fmt" "redis" ) func init() { // ... } func main() { err := redis.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7646bb9a133d8b8429e596f8f17bbadd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a705e929f67f29e517d8eecf4dad2e9/" rel="bookmark">
			games101——作业8
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 安装依赖连接绳子的约束显式/半隐式欧拉法显示欧拉法半隐式欧拉 显式 Verlet阻尼 安装依赖 本次作业需要预先安装 OpenGL, Freetype 还有 RandR 这三个库。可以通过以下命令进行安装：
$ sudo apt install libglu1-mesa-dev freeglut3-dev mesa-common-dev $ sudo apt install xorg-dev #会自动安装 libfreetype6-det 连接绳子的约束 在 rope.cpp 中, 实现 Rope 类的构造函数。这个构造函数应该可以创建一个新的绳子(Rope) 对象，该对象从 start 开始，end 结束，包含 num_nodes 个节点。也就是如下图所示：
每个结点都有质量，称为质点；质点之间的线段是一个弹簧。通过创建一系列的
质点和弹簧，你就可以创建一个像弹簧一样运动的物体。
pinned_nodes 设置结点的索引。这些索引对应结点的固定属性 (pinned attribute) 应该设置为真（他们是静止的）。对于每一个结点，你应该构造一个 Mass 对象，并在 Mass 对象的构造函数里设置质量和固定属性。（请仔细阅读代码，确定传递给构造函数的参数）。你应该在连续的两个结点之间创建一个弹簧，设置弹簧两端的结点索引和弹簧系数 k，请检查构造函数的签名以确定传入的参数。
Rope::Rope(Vector2D start, Vector2D end, int num_nodes, float node_mass, float k, vector&lt;int&gt; pinned_nodes) { // TODO (Part 1): Create a rope starting at `start`, ending at `end`, and containing `num_nodes` nodes.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5a705e929f67f29e517d8eecf4dad2e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04d93eda33f6d7813b6ff830cb920fb5/" rel="bookmark">
			PyTorch深度学习框架（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 pytorch安装步骤pytorch基本使用方法view操作（改变矩阵维度）格式转化（numpy&lt;-----&gt;torch)自动求导机制例子实现 线性回归模型常见的tensor格式 pytorch安装步骤 pip3 install torch torchvision torchaudio
pytorch基本使用方法 #创建一个矩阵 x=torch.empty(5,3) print(x) #来个随机数 y=torch.rand(5,3) print(y) #初始化全零矩阵 n=torch.zeros(5,3,dtype=torch.long) print(n) #矩阵的加法 w=torch.rand(5,3) print(w+y) view操作（改变矩阵维度） #View操作 x=torch.randn(4,4) y=x.view(16) #-1 使用自动计算 ,第二个维度为8，第一个维度自动计算 z=x.view(-1,8) print(x.size(),y.size(),z.size()) 格式转化（numpy&lt;-----&gt;torch) #将torch格式转化为numpy格式 a=torch.ones(5) b=a.numpy() print(b) #将numpy转为torch a=np.ones(5) b=torch.from_numpy(a) print(b) 自动求导机制 #方法一 x=torch.randn(3,4,requires_grad=True) #方法二 x=torch.randn(3,4) x.requires_grad=True print(x) 例子实现 x=torch.rand(1) b=torch.rand(1,requires_grad=True) w=torch.rand(1,requires_grad=True) y=w*x z=y+b #反向传播 z.backward(retain_graph=True) print(b.grad) 线性回归模型 机器学习最常见的场景是监督学习：给定一些数据，使用计算学习到一种模型，然后使用它来预测新的数据。一个简单的监督学习任务可以表示为，给定N个两两数据对（Xi,Yi)，使用某种机器学习模型对其进行建模，得到一个模型，其中某个给定的数据对为样本，X为特征，Y为真实值。
#coding=utf-8 from cProfile import label from pickletools import optimize from turtle import forward import torch import cv2 import torch import torch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04d93eda33f6d7813b6ff830cb920fb5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/505963cb800909371cd03f075b11d49a/" rel="bookmark">
			数据结构 | 【树与二叉树】考研相关结论与习题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		相关结论 二叉树遍历
1、在二叉树结点的先序序列,中序序列和后序序列中,所有叶子结点的先后顺序完全相同。
2、 L、D、R分别表示遍历左子树、访问根结点和遍历右子树， 则先(根)序遍历二叉树的顺序是DLR， 中(根)序遍历二叉树的顺序是LDR， 后(根)序遍历二叉树的顺序是LRD， 还有层次遍历二叉树。
这些方法的时间复杂度都是O(n)，n为结点个数。
3、设n，m为一棵二叉树上的两个结点，中序遍历时，n在m前的条件是n在m左方。
设n，m为一棵二叉树上的两个结点，后序遍历时，n在m前的充分条件是n是m子孙。
4、前序序列和中序序列相同的二叉树为空树或任一结点均无左孩子的非空二叉树； 中序序列和后序序列相同的二叉树为空树或任一结点均无右孩子的非空二叉树； 前序序列和后序序列相同的二叉树为空树或仅有一个结点的二叉树。
递归算法使用与树的高度成比例的栈空间。如果我们在每个结点中存储指向父结点的指针，那样可以使用迭代算法，只使用常数级空间实现所有这些遍历。然而，指向父结点的指针占用更多的空间。这只在需要指向父节点的指针或栈空间有限时才使用。
深度优先遍历在深度优先顺序中，我们希望从根结点访问最远的结点。和图的深度优先搜索不同的是，不需记住访问过的每一个结点，因为树中不会有环。前序，中序和后序遍历都是深度优先遍历的特例。
广度优先遍历和深度优先遍历不同，广度优先遍历会先访问离根节点最近的节点。 二叉树的广度优先遍历又称按层次遍历。算法借助队列实现。
有序树转化为二叉树
如果T2是由有序树T转换而来的二叉树，那么T中结点的前序就是T2中结点的前序，T中结点的后序就是T2中结点的中序。
线索二叉树 1、二叉树是一种逻辑结构。线索二叉树是一种物理结构。
2、线索二叉树明确指明了在存储过程中的数据存放方式，就是物理结构了。(物理结构=存储结构)
注意:既指明了存储结构，又指明了逻辑结构的情况就是单独的“物理结构”。
3、n个结点的线索二叉树含有的线索数为n+1。
4、一颗任意的二叉树，也任意使用先序/中序/后序线索化，则线索化后其空链域最多有2个。
5、两个结点，在前序和后序中的前后关系不同，证明二者是父子关系；如果相同，二者是兄弟关系 。
6、后序线索二叉树中不能求后序后继 ，先序线索二叉树中不能求先序前驱。
树与森林
1、设F是一个森林，B是由F变换得的二叉树。若F中有n个非终端结点，则B中右指针域为空的结点有n+1个。每一个非终端结点，一定会有且仅有一个孩子结点没有右邻兄弟，即右指针领域为空。
2、树与二叉树的转换：没有右侧指针的结点数 = 根节点 + 非叶节点数量
树转换为二叉树时，树中每一个分支结点的 所有子结点中最右子结点 无右孩子， 根结点转换后也 没有右孩子。因此，对应二叉树中无右孩子的结点个数=分支结点个数（ 非终端结点）+1
哈夫曼树与并查集
1、在有n个叶子结点的哈夫曼树（度为2）中，非叶子结点的个数为n-1。
相关例题 1、二叉树相关计算 1、一棵完全二叉树上有1001个结点，其中叶结点的个数是（）
A.250 B.500 C.254 D.501 解：法1： 结点总数为1001，奇数，故n1=0。由n=n0+n1+n2；n2=n0-1得：n=n0+n1+n0-1,即1001=2*n0-1,得 n0=1002/2=501.
法2： 完全二叉树的最后一个结点编号为1001，由于其为奇数，因此其双亲结点编号为(1001-1)/2=500（若为偶数则直接除以2），双亲之后的结点都是叶结点，因此总叶结点n0=最后一个编号-其双亲编号=1001-500=501.
法3： 此完全二叉树深度为:log2(n)向下取整+1=10.其前9层满数，第9层结点数为2^(9-1)=256，则前9层的总结点数为：(2^9)-1=511，因此第10层的叶结点数为：1001-511=490，则第9层非叶结点个数为490/2=245（2对1），则第9层结点个数为：256-245=11。因此总叶结点为：第9层的+第10层的=11+490=501
答案：D
总结一下：完全二叉树的最后一个结点的编号是n，则它的父结点的编号为[n/2]，则叶子结点个数为n-[n/2]。
2、一棵有n个结点采用链式存储的二叉树中，共有（ ）个指针域为空。
A.n+1 B.n C.n-1 D.n-2 解：每个节点有两个指针（左右指针），所以其有2n个指针用于指向孩子节点
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/505963cb800909371cd03f075b11d49a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9720480f3d8024df6fd52aee0056b58/" rel="bookmark">
			IDEA2021.3版本如何创建web项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、创建项目 填写项目名和项目存放文件夹路径 然后finish
项目已创建出来
2、导入依赖包 右键项目名 3. 创建两个包分别是classes和lib，classes用来存放out文件（等等用得上），lib用来存放依赖包 规范classes和lib路径，上下路径要一样
4、配置Tomact服务器 5. 配置artifacts: 六、启动项目 启动成功：
运行项目自带的index.jsp
结果：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/969e3e2dee4e81e222704eaadbba5dc6/" rel="bookmark">
			磁性元件介绍（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		磁性元件介绍 磁性元件的种类与角色变压器工艺流程相关计算公式 大家好，我是朱大昌，又和大家见面了。一般都对磁性元件比较陌生，那么今天大昌就给大家扫盲。 磁性元件的种类与角色 磁性元器件：利用电磁感应原理，将电能和磁能相互转换，从而达到能量转换、传输的电子元器件。
类别：主要分为变压器和电感器两大类。
功能：能量储存、能量转换、电气隔离、电磁滤波等功能。
结构：主要包括磁芯、绕组、绝缘料和固定件。
下面是一些磁件所担任的具体角色：
实物如下：
变压器工艺流程 平时大家变压器用的很多，那么是如何制作的呢？
相关计算公式 欧姆定律：
I=U/R
I：（电流）的单位是安培（A）
U：（电压）的单位是伏特（V）
R：（电阻）的单位是欧姆（Ω）
功率计算：
P=UI=I²R
P：（功率）的单位是瓦特（W）
I：（电流）的单位是安培（A）
U：（电压）的单位是伏特（V）
R：（电阻）的单位是欧姆（Ω）
导线直流电阻计算公式：
Rdc =ρ* [1+k (T-20)]L/S
ρ：导线的电阻率（纯铜0.0178Ω.mm2/m 20℃）
k：导线材料电阻率随温度变化的系数
T：导线的温度(℃)
L：导线的长度（m）
S：导线的截面积（mm²）
铜线电流密度计算：
J=Irms/S
J：电流密度，单位是A/ mm²。
视散热环境，一般取312，无风等散热较差情况下，取35。有风散热情况下取58。水冷液冷等散热非常好时取812。
Irms ：有效电流，单位是安培（A）
S：导线的截面积（mm²）
耦合电感串并联计算：
顺串：L=L1+L2+2M；
反串：L=L1+L2-2M；
同并：L=L1+L2-M²/（ L1+L2-2M ）
同串：L=L1+L2-M²/（ L1+L2+2M ）
M：耦合电感
感应电动势计算：
E=KfNAe△B
E：感应电动势，单位伏特（V）
K：波形系数，正弦波取4.44，方波取4
f：频率，单位赫兹（Hz）
N：线圈匝数，单位（Ts）
Ae：磁芯的有效截面积，单位平方米（m2）
△B：磁通密度变化量，单位特斯拉（T）
功率变压器Ap法计算公式：
Ap&gt;KtPo/(BmaxfsKJη)
AP：磁芯面积乘积mm4 Kt ：拓扑系数（√Dmax）
Po：变压器额定功率（W） η ：变压器效率
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/969e3e2dee4e81e222704eaadbba5dc6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19d344146e20f3d39d60373af3ee548e/" rel="bookmark">
			python实现多重排序(多级排序)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考链接: Python内置函数sorted()和列表的sort方法使用介绍
参考链接: Python中优先级队列的实现,heapq堆队列算法实现最小堆
参考链接: 排序指南
参考链接: sorted(iterable, *, key=None, reverse=False)
参考链接: sort(*, key=None, reverse=False)
参考链接: Operator 模块函数
参考链接: 使用 cmp 参数的旧方法
参考链接: 其它
代码实验展示:
# 实现多级排序,首先按成绩降序,再按年龄升序,最后按姓名字典序升序 stuTuple = tuple( [ (98, 23, 'mike'), (97, 37, 'steve'), (92, 18, 'james'), (91, 16, 'eric'), (99, 12, 'john'), (99, 12, 'dave'), (99, 14, 'jane'), (98, 25, 'jack'), (98, 25, 'bob'), ] ) def printInfo(ls): for item in ls: print(item) ls = list() for stu in stuTuple: ls.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/19d344146e20f3d39d60373af3ee548e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/734383128c231d58be20a70303f94035/" rel="bookmark">
			爬楼梯（c&#43;&#43;递归）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 描述
树老师爬楼梯，他可以每次走1级或者2级，输入楼梯的级数，求不同的走法数
例如：楼梯一共有3级，他可以每次都走一级，或者第一次走一级，第二次走两级
也可以第一次走两级，第二次走一级，一共3种方法。
输入
输入包含若干行，每行包含一个正整数N，代表楼梯级数，1 &lt;= N &lt;= 30
输出
不同的走法数，每一行输入对应一行输出
样例输入
5
8
10
样例输出
8
34
89
解题思路：
刚开始看到这题，首先我想到的是列举，将以1开头和2开头的各种答案列举出来，但用递归方法难以实现，所以就想到采取求以1开头和2开头的方法数。
代码如下
#include &lt;iostream&gt; using namespace std; int walk(int n) { if(n==1) return 1; else if(n==2) return 2; else return walk(n-1)+walk(n-2); } int main() { int n; while (cin &gt;&gt;n) { cout&lt;&lt;walk(n)&lt;&lt;endl; } return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/707ff382df6afcf740297f893e9cd352/" rel="bookmark">
			钉钉内网穿透工具 快捷执行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		已废弃
首先下载钉钉穿透工具，官网地址(https://github.com/open-dingtalk/pierced)
新建文本文档，后缀改为bat，输入下方命令后双击文件可执行穿透
cmd /k "d: &amp; cd D:\穿透工具路径\pierced\windows_64 &amp; ding -config=ding.cfg -subdomain=自定义域名 端口号" 下图为穿透成功，http://sssa.vaiwan.com为外网调用地址
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57b0d5c8df58e0c83aa9976b0d2f36a5/" rel="bookmark">
			idea导入web项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.File—&gt;Open—&gt;选择要打开的web项目； 2.打开项目后，File–&gt;Project Structure； 3.设置SDK选择已有的SDK（我的这里是JDK13）；设置Project language level（注意要和Project SDK 的版本一致（例如1.8对相应8））；Project compiler output这里可以选择默认的（项目名下\out），也可以不设置在第四点设置； 4.设置modules，点击“+”，add选择web； 这里一定要注意Deployment Descriptors 的Path一定是本项目下的web包中的WEB-INF的web.xml文件；Web Resource Directories 的一定是项目下的web文件，这里成功后会显示web的左边小文件夹标识会出现一个蓝色的小点 （这里一定要配置好，不然之后会出现，正常运行tomcat，但是网页报404的错误） 在之前设置了Project compiler output的可以直接选择第一个Inherit Project…，前面没有设置的可以选第二个在这里设 5.设置Libraries，点击“+”中的java，添加项目文件下/web/WEB-INF/lib目录（jar所放的位置）； 6.设置Facets，若上面操作都设置成功，则Facets已经好了； 7.设置Artifats，点击“+”，选择Web Application：Exploded—&gt;from Modules 记得Put into Output Root 8.全部配置结束以后点击OK； 9.接下来配置Tomcat，如图选择Tomcat Server —&gt;local 选择安装好的Tomcat 点击“+”,选择Artifact 点击ok，就可以运行了； 附加：10.我这里还报错了一个Servlet包不存在，我找了很久，找到问题 在这里把tomcat包导进来问题就解决了 附加：11.再多提一句要是src文件目录下的java文件不是蓝色的c符号，而是橘色的j这样的问题，或者src文件包是灰色的 在这里点击src再点击Sources就可以了 参考地址：https://blog.csdn.net/qq_46074512/article/details/112909518
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aaad183126994ba65d54e68e4c5bab9c/" rel="bookmark">
			docker-compose环境下搭建mysql8
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 version: "3" services: mysql: container_name: mysql image: mysql:8.0.31-debian restart: always volumes: # 挂载mysql文件 - ./mysql_data:/var/lib/mysql # 挂载mysql配置 - ./mysql_cnf:/etc/mysql # 挂载mysql错误日志 - ./mysql_error_log:/var/log ports: - "8806:3306" environment: TZ: Asia/Shanghai MYSQL_ROOT_PASSWORD: root command: --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci --max_connections=2000 --wait_timeout=20000 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc9b5727e6752dba216ad5c2dfdd6ab3/" rel="bookmark">
			Docker部署elasticsearch和kibana，以及Docker-compose一键启动并配置账号密码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Docker Docker部署elasticsearchDocker部署kibanaDocker-compose一键启动elasticsearch,kibanaelasticsearch设置密码Docker-compose一键启动elasticsearch,kibana 并且设置账号密码 其他文章:Elasticsearch入门进阶篇
Docker部署elasticsearch #下载镜像文件 docker pull elasticsearch:7.8.0 #配置路径 在 /usr/local/elasticsearch/config/目录创建elasticsearch.yml #在elasticsearch.yml中配置 http.cors.enabled: true http.cors.allow-origin: "*" http.host: 0.0.0.0 #运行es docker run --name elasticsearch -p 9200:9200 -p 9300:9300 -e "discovery.type=single-node" -e ES_JAVA_OPTS="-Xms64m -Xmx100m" -v /usr/local/elasticsearch/config/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml -v /usr/local/elasticsearch/data:/usr/share/elasticsearch/data -v /usr/local/elasticsearch/plugins:/usr/share/elasticsearch/plugins -d 121454ddad72 Docker部署kibana #下载镜像 docker pull kibana:7.8.0 #查看已经启动的 elasticsearch:7.8.0
docker inspect elasticsearch:7.8.0
#拿到es的ip地址
#通过命令启动 docker run --name kibana -e ELASTICSEARCH_HOSTS=http://172.17.0.2:9200 -p 5601:5601 -d a674d23325b0 Docker-compose一键启动elasticsearch,kibana # 创建es的文件夹 #创建docker-compose.yml文件 version: "3" volumes: data: config: plugin: networks: lxyes: services: elasticsearch: image: elasticsearch:7.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc9b5727e6752dba216ad5c2dfdd6ab3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6773eefbb85d39182e1aaa7bcb3a081/" rel="bookmark">
			celery 配置broker redis sentinel方式，集成到django
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、prj.py 存储celery的配置信息
注明：
有些队列处理时间比较长，虽然可以开启多个进程监听队列，但是如果发过来的任务都是时间比较长的，那所有进程都将被占用，
导致其他需要紧急处理的任务得不到处理，故这里演示启用不同的队列，不同的消费进程处理
# _*_ coding:utf-8 _*_ from redis.sentinel import Sentinel import time from celery import Celery import os from kombu import Exchange, Queue os.environ["DJANGO_SETTINGS_MODULE"] = "settings" app=Celery("mycelery") #集群哨兵版 username = "redis" #用户名 password = "m-SDFdfle90IUD&amp;)+U" #redis授权密码 app.conf.broker_url = 'sentinel://{usr}:{pwd}@127.0.0.1:9111;sentinel://{usr}:{pwd}@127.0.0.1:9222;sentinel://{usr}:{pwd}@127.0.0.1:9333'.format( usr = username, pwd = password, ) app.conf.broker_transport_options = { 'master_name': "mymaster",'visibility_timeout': 43200 } #配置结果数据存储 app.conf.result_backend = 'sentinel://{usr}:{pwd}@127.0.0.1:9111/0;sentinel://{usr}:{pwd}@127.0.0.1:9222/0;sentinel://{usr}:{pwd}@127.0.0.1:9333/0'.format( usr = username, pwd = password, ) app.conf.result_backend_transport_options = { 'master_name': "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f6773eefbb85d39182e1aaa7bcb3a081/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8cffeff4a6c33352dc2d852a8348b151/" rel="bookmark">
			Springbootg整合validation整合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		坚持年年写博客，不能断了，所以粘贴平时写的一份笔记吧
一、简介
校验参数在以前基本都是使用大量的if/else，稍微方便一点的可以使用反射+自定义注解的形式，但是复用性不是很好，并且每个人对于的自定义注解有着自己的使用习惯，不过好在spring开发了validated框架用于注解校验，可以节省很多的校验ifelse代码。 @PostMapping("/save") public Object save(@RequestBody User user) { String mobile = userVO.getMobile(); //手动逐个 参数校验~ 写法 if (StringUtils.isBlank(mobile)) { return R.bulid(ResultEnum.PARAM_FAIL_CODE,"mobile:手机号码不能为空"); } else if (!Pattern.matches("^[1][3,4,5,6,7,8,9][0-9]{9}$", mobile)) { return R.bulid(ResultEnum.PARAM_FAIL_CODE,"mobile:手机号码格式不对"); } //抛出自定义异常等~写法 if (StringUtils.isBlank(userVO.getUsername())) { throw new ParamException(ResultEnum.PARAM_FAIL_CODE, "用户名不能为空"); } // 比如写一个map返回 if (StringUtils.isBlank(userVO.getSex())) { Map&lt;String, Object&gt; result = new HashMap&lt;&gt;(5); result.put("code", Constant.PARAM_FAIL_CODE); result.put("msg", "性别不能为空"); return result; } //.........各种写法 ... userService.save(user); return R.success(); } 二、Spring Validation spring Validation 是一种参数检验工具,集成在spring-context包中, 常用于spring mvc中Controller的参数处理,主要针对整个实体类的多个可选域进行判定，对于不合格的数据信息springMVC会把它保存在错误对象中，这些错误信息我们也可以通过SpringMVC提供的标签或者前端的脚本等在前端页面上进行展示。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8cffeff4a6c33352dc2d852a8348b151/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/597eea92806a29f89b620b420a1740a2/" rel="bookmark">
			PTA C语言基础代码（10题）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		7-45 连年 给你一个数年份n，把1到n的每个年份都写出来连在一起，最后得到的是几位数？例如n=10，得到的数字是12345678910，因此是11位数。
输入格式: 首先输入一个整数T（1&lt;=T&lt;=10），表示测试组数。
每组测试输入一个整数n(1&lt;=n&lt;=10000)。
输出格式: 对于每组测试，在一行上输出把1到n的每个年份都写出来连在一起，最后得到的数据的位数。
输入样例: 2 10 1 输出样例: 11 1 #include&lt;stdio.h&gt; int main() { int T; scanf("%d",&amp;T); while((T--)!=0) { int n=0,i=0,j=0,count=0; scanf("%d",&amp;n); for(i=n;i&gt;0;i--) for(j=i;j&gt;0;j/=10) count++; printf("%d\n",count); } } 7-57 交换三个整数的次序 本题目要求输入3个整数值a、b、c，把b中的值赋给a，把c中的值赋给b，把a中的值赋给c，最后输出a、b、c的值。
输入格式: 输入在一行中给出3个整数a、b、c，中间用空格隔开。
输出格式: 对每一组输入，在一行中输出交换后的a、b、c的值，中间用空格隔开。
输入样例: 4 5 6 输出样例: 5 6 4 #include &lt;stdio.h&gt; int main() { int a,b,c; scanf("%d%d%d",&amp;a,&amp;b,&amp;c); int a1,b1,c1; a1=b; b1=c; c1=a; printf("%d %d %d",a1,b1,c1); return 0; } 7-58 求一元二次方程的根 求ax2+bx+c=0的根。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/597eea92806a29f89b620b420a1740a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d54f1ea2f0999fd01b4903bd1ec2d36a/" rel="bookmark">
			python更新pip后报异常
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、当pip的版本更新后，在使用pip install 命令时会提示python.exe -m pip install --upgrade pip，进行更新pip的版本：
但当执行完命令后会偶然出现报Unable to find resource t64.exe in package pip._vendor.distlib的异常提示情况：
2、碰见上述错误，则执行python -m pip uninstall pip setuptools，卸载老的setuptools安装包，再次进行pip的更新，结果正常：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49f16b0e998ff085d525f598865940aa/" rel="bookmark">
			YOLOV5 报错字体无法下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		def check_font(font='Arial.ttf', size=10): # Return a PIL TrueType Font, downloading to CONFIG_DIR if necessary font = Path(font) font = font if font.exists() else (CONFIG_DIR / font.name) try: return ImageFont.truetype(str(font) if font.exists() else font.name, size) except Exception as e: # download if missing url = "https://ultralytics.com/assets/" + font.name print(f'Downloading {url} to {font}...') torch.hub.download_url_to_file(url, str(font), progress=False) try: return ImageFont.truetype(str(font), size) except TypeError: check_requirements('Pillow&gt;=8.4.0') # known issue https://github.com/ultralytics/yolov5/issues/5374 class Annotator: if RANK in (-1, 0): check_font() # download TTF if necessary 因为要检查字体，
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49f16b0e998ff085d525f598865940aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49dfd72b74a1eedc1ee21837dc0c1270/" rel="bookmark">
			Django数据库报错相关问题总结（初始化、迁移等）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 整理学习Django过程中遇到的问题 如何新建用户 新建超级用户 python manage.py createsuperuser 在命令行中依次输入用户名、邮箱地址（选填，可为空）、密码、二次确认密码即可，命令行中输入密码不会显示*号，确保两次输入的密码相同。密码过短或是与账户名相同会出现提示，直接输入y即可强行生成。
新建普通用户 python manage.py shell 直接使用 Django 的 shell 命令对用户进行新建，具体操作如下
&gt;&gt;&gt;from django.contrib.auth.user import User &gt;&gt;&gt;user = User.objects.create_user('用户名', '邮箱地址', '密码') &gt;&gt;&gt;user.save() 邮箱地址可以为空，此方法适用于 Django 3.2 ，官方说明文档在此
数据库迁移相关报错 ProgrammingError: relation “django_content_type” already exists. 报错 在 Django 1.8 以后的版本中，可以使用虚拟初始化的方式，将已经存在的数据库表进行跳过操作，使用方法为：
python manage.py migrate --fake-initial 可以跳过所有已经生成的表，继续生成其他未生成的表。官方说明文档在此
项目迁移后不生成表（无法根据模型生成表，无法检测到数据库修改） 一般常见于直接删除数据库文件，正常删除数据库应按照以下顺序：
删除数据库中的表，使用drop table命令。注释掉model.py文件中不需要的模型。生成新的迁移文件并执行python manage.py makemigration,python manage.py migrate 其他情况下删除数据库可能出现无法生成表的问题，按照如下顺序排查问题：
删除应用下migrations文件夹中除了__init__.py以外的所有文件。使用工具打开目录中的db.sqlite3，找到django_migration表，并删除表中的所有数据重新使用命令生成迁移文件并执行python manage.py makemigration,python manage.py migrate 其中 macOS 可以使用自带的终端功能对数据库进行修改
&gt;&gt;&gt;sqlite3 数据库所在路径 &gt;&gt;&gt;.table #用于查看所有的表 &gt;&gt;&gt;delete * from django_migrations; #注意分号不能漏，执行完毕后即删除所有的迁移记录 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bceff40a9f972942beb5ae0bfb9853cc/" rel="bookmark">
			找出数组中的最大值并输出其下标
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		思路：1.用循环获得数组。
2.用循环遍历数组找出最大值。
3.再次使用循环及最大值找出下标。
代码及过程如下：
#include &lt;stdio.h&gt; int findMax(int arr[], int n) { int max=arr[0];//暂定最大值为数组第一位。 int i; for(i=0;i&lt;n;i++) { if(arr[i]&gt;max)//遍历数组获得最大值。 max=arr[i]; } for(i=0;i&lt;n;i++)//利用最大值获得下标。 if(max==arr[i]) return i;//通过函数返回下标。 } int main() { int a[100], i, n, index; scanf("%d", &amp;n);//输入数组个数。 for(i=0; i&lt;n; i++) { scanf("%d", &amp;a[i]);//通过键盘获得一组个数为n的数组。 } index = findMax(a, n);//调用函数 ，index即为最大值下标。 printf("index = %d, max = %d\n", index, a[index]); return 0; } 测试结果：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8205b47903a0c6d4358f2d305b17be6b/" rel="bookmark">
			【图像处理】python | 给图像添加噪声 | random_noise
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、random_noise函数介绍二、实际操作2.1.导入照片2.2.添加高斯噪声2.3.添加椒盐噪声2.4.对比 一、random_noise函数介绍 首先，我们看一下random_noise的构造：
floating-point image是浮点图的意思。**kwargs是关键字参数的意思，对这部分我也作一定的学习（之前不懂），改天写一个博客记录一下。它的作用：把多个关键字参数打包。
1.image:
输入的图像是n维数组，会转换为浮点型
2.mode:
除了高斯型，还有椒盐，泊松等等
3.关键字参数:
一些比较经典的，比如高斯噪声需要的均值，方差，就需要在这里设定
4.返回值:
最后返回的添加了噪声的n维数组
二、实际操作 首先，在使用前需要掉包：
from skimage.util import random_noise #添加噪声模块 skimage即是Scikit-Image,数字图像处理包
2.1.导入照片 这次我们用plt.imread来读取照片，读出来的格式直接就是ndarray的格式，格式为宽，高，通道；同时是uint8(8位无符号整数类型),范围在[0, 255]，2的8次方是256(按照网上的说法，为了节省空间，图像存储一般用的uint8)：
image=plt.imread('1.jpg'); print(type(image)) #图片种类 print(image.shape) #打印图片大小 print(image.dtype) #打印图片数据类型 plt.imshow(image) plt.show() imshow了之后 别忘了经典的show()永恒的经典
导入照片有好几种方式，有时间了我也写一篇博客总结一下
2.2.添加高斯噪声 代码如下（示例）：
from skimage.util import random_noise #添加噪声模块 import matplotlib.pyplot as plt image=plt.imread('1.jpg'); print(type(image)) #图片种类 print(image.shape) #打印图片大小 print(image.dtype) #打印图片数据类型 plt.subplot(2,2,1) plt.title('origin') plt.imshow(image) noise_gaussian_1=random_noise(image,mode="gaussian",clip=True) noise_gaussian_2=random_noise(image,mode="gaussian",var=0.1,clip=True) noise_gaussian_3=random_noise(image,mode="gaussian",var=1,clip=True) plt.subplot(2,2,2) plt.title('var=0.01') plt.imshow(noise_gaussian_1) plt.subplot(2,2,3) plt.title('var=0.1') plt.imshow(noise_gaussian_2) plt.subplot(2,2,4) plt.title('var=1') plt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8205b47903a0c6d4358f2d305b17be6b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96672c799fb80835174638f84319c36f/" rel="bookmark">
			Docker安装RocketMQ详细教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. rocketmq的部署架构 RocketMQ 网络部署特点
NameServer是一个几乎无状态节点，可集群部署，节点之间无任何信息同步。
Broker部署相对复杂，Broker分为Master与Slave，一个Master可以对应多个Slave，但是一个Slave只能对应一个Master，Master与Slave 的对应关系通过指定相同的BrokerName，不同的BrokerId 来定义，BrokerId为0表示Master，非0表示Slave。Master也可以部署多个。每个Broker与NameServer集群中的所有节点建立长连接，定时注册Topic信息到所有NameServer。 注意：当前RocketMQ版本在部署架构上支持一Master多Slave，但只有BrokerId=1的从服务器才会参与消息的读负载。
Producer与NameServer集群中的其中一个节点（随机选择）建立长连接，定期从NameServer获取Topic路由信息，并向提供Topic 服务的Master建立长连接，且定时向Master发送心跳。Producer完全无状态，可集群部署。
Consumer与NameServer集群中的其中一个节点（随机选择）建立长连接，定期从NameServer获取Topic路由信息，并向提供Topic服务的Master、Slave建立长连接，且定时向Master、Slave发送心跳。Consumer既可以从Master订阅消息，也可以从Slave订阅消息，消费者在向Master拉取消息时，Master服务器会根据拉取偏移量与最大偏移量的距离（判断是否读老消息，产生读I/O），以及从服务器是否可读等因素建议下一次是从Master还是Slave拉取。
集群工作流程：
启动NameServer，NameServer起来后监听端口，等待Broker、Producer、Consumer连上来，相当于一个路由控制中心。Broker启动，跟所有的NameServer保持长连接，定时发送心跳包。心跳包中包含当前Broker信息(IP+端口等)以及存储所有Topic信息。注册成功后，NameServer集群中就有Topic跟Broker的映射关系。
收发消息前，先创建Topic，创建Topic时需要指定该Topic要存储在哪些Broker上，也可以在发送消息时自动创建Topic。Producer发送消息，启动时先跟NameServer集群中的其中一台建立长连接，并从NameServer中获取当前发送的Topic存在哪些Broker上，轮询从队列列表中选择一个队列，然后与队列所在的Broker建立长连接从而向Broker发消息。Consumer跟Producer类似，跟其中一台NameServer建立长连接，获取当前订阅Topic存在哪些Broker上，然后直接跟Broker建立连接通道，开始消费消息。 2. 安装NameServer 搜索/拉取镜像 docker search rocketmq docker pull rocketmqinc/rocketmq 创建一个数据目录 mkdir -p /docker/rocketmq/nameserver/logs /docker/rocketmq/nameserver/store 运行 docker run -d --restart=always --name rmqnamesrv --privileged=true -p 9876:9876 -v /docker/rocketmq/nameserver/logs:/root/logs -v /docker/rocketmq/nameserver/store:/root/store -e "MAX_POSSIBLE_HEAP=100000000" rocketmqinc/rocketmq sh mqnamesrv 参数说明 参数说明-d以守护进程的方式启动- -restart=alwaysdocker重启时候容器自动重启- -name rmqnamesrv把容器的名字设置为rmqnamesrv-p 9876:9876把容器内的端口9876挂载到宿主机9876上面-v /docker/rocketmq/nameserver/logs:/root/logs目录挂载-v /docker/rocketmq/nameserver/store目录挂载rmqnamesrv容器的名字-e “MAX_POSSIBLE_HEAP=100000000”设置容器的最大堆内存为100000000rocketmqinc/rocketmq使用的镜像名称sh mqnamesrv启动namesrv服务 3. 安装broker 创建broker.conf配置文件，我的目录是/opt/docker/rocketmq/broker.conf，文件内容如下 brokerClusterName = DefaultCluster brokerName = broker-a brokerId = 0 deleteWhen = 04 fileReservedTime = 48 brokerRole = ASYNC_MASTER flushDiskType = ASYNC_FLUSH brokerIP1 = 主机的IP 启动broker docker run -d --restart=always --name rmqbroker --link rmqnamesrv:namesrv -p 10911:10911 -p 10909:10909 --privileged=true -v /docker/rocketmq/data/broker/logs:/root/logs -v /docker/rocketmq/data/broker/store:/root/store -v /docker/rocketmq/conf/broker.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96672c799fb80835174638f84319c36f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d5b029e7f0439c4c026a6b753df3a42/" rel="bookmark">
			TCL仿真Modelsim问题汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用Tcl而非vivado或者modelsim的图形界面进行仿真 1.首先建立.v文件2.编写do文件3.运行批处理文件4.问题 1.首先建立.v文件 2.编写do文件 其中包括建立库、编译.v文件、运行仿真文件、增加波形、设置仿真时间、退出仿真等。
示例如下：
vlib work vlog -f rtl.f vsim -voptargs=+acc work.test add wave * view wave run 1.5ms rtl.f文件内容如下：
E:/peixun/add/a.v E:/peixun/add/test.v 3.运行批处理文件 4.问题 1.运行批处理文件后，打开modelsim时出现如下问题：
sim.do文件如下
vlib work
vlog -f rtl.f
vsim -novopt work.test
run 1.5ms
经过查找可知：错误（可抑制）：（vlog-12110）所有优化都被禁用，因为-novopt选项有效。
●Modelsim2019以上版本不支持-novopt命令。
解决方法:去掉-novopt
2.添加波形时出现如下错误
发现是无objects，信号被优化掉了，解决方法是在simulation→start simulation→optimization options→Customized visibility→Add→apply to all modules→ok→重新仿真
但这种方法只能解决本次仿真问题，无法从根本上解决。
https://blog.csdn.net/dinghj3/article/details/122178805
经过查找并结合第一个问题的情况，将-novopt命令改为-voptargs=+acc，优化部分参数，用于保留某些类别的对象的可见性，具体解释可查看以下链接。
3.运行run.bat时出现如下问题
**Modelsim出错 Warning: (vdel-6) – Waiting for lock by… **
work文件夹里面有个_lock文件，删了它就继续跑
4.modelsim仿真ISE工程时出现# ** Error: (vlog-19) Failed to access library ‘rtl_work’ at "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d5b029e7f0439c4c026a6b753df3a42/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a817a1dfd74d5f77aa5cbb35d9467388/" rel="bookmark">
			双口RAM输出数据丢失问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		双口RAM输出数据丢失问题 1.写部分出错2.读数据出错（1）读使能作用于RAM（2）读使能同时作用于用来缓冲的寄存器 在实验室培训过程留下的作业中有一道题是用RAM实现乒乓操作，然后我们在设计完成进行仿真时，发现每次读数据的最后总会出问题，总会丢失最后一个写入的数据，经过不断地尝试和检查，在解决掉其他小问题后发现真双口RAM在输出数据时，会丢掉最后一个数据。（仿真写入5个数据，从向地址4写入11开始）
首先问题可能出现在两个地方,写部分或读部分出错。
1.写部分出错 该种情况下，我们将RAMA和RAMB读使能始终拉高，观察数据是否依然存在该情况，若没有丢失说明在读数据使能的时候出现问题，若问题依然出现那写数据部分出错，同时也不能保证读数据没有问题。
修改代码仿真后，观察doutA和doutB，可以发现数据是按预想中读出，且最后输出数据正确。因此将问题定位到读数据部分。
2.读数据出错 经过观察读地址和读数据会发现数据会晚于读使能信号两拍，正常情况下晚一拍即可。
观察发现读完第四个数据不读了，于是我们试图将读使能信号拉长一个cycle，操作方法是将读信号与读信号打拍之后的结果进行或，如此发现输出数据完整。
同时查阅资料后发现，在生成双口RAM时，勾选了Primitives Output Regeister，输出会进行一级寄存。
取消勾选重新生成IP核后，把读使能也改回原来的样子（不采用拉长一个cycle，读使能为高的时间依然是对应数据个数的cycle，实验中为5），输出数据完整。
再看看原来勾选时的波形，观察后发现，其实并不是丢掉数据，而是0被作为第一个读出来的数。
那么问题来了，如果只是进行一次寄存，那数据应该也只是晚一拍才到，为什么会直接丢掉最后一个数据15（从11开始写的）呢?并且在RAM里面其实并没有写入0这个数据。
我们猜想读使能信号的作用域可能有如下两种情况：
（1）读使能作用于RAM 这种情况下，进入寄存器的数据由如下数据构成{data4,…,data0}，这样每一个时钟边沿到来后，数据就会被送出到寄存器的输出端口，顺序依次是data0、data1、…、data4，这里不用管还没使能时寄存器的数据输入端口为0，因为复位后的下一个时钟沿数据已经被送出去，只要data数据到来下一个上升沿直接将{data4,…,data0}送出。这种情况下数据应该是正常的完整的，所以可能不是此种结构。
（2）读使能同时作用于用来缓冲的寄存器 这种结构下，读使能rd_en同时作用于寄存器，因此因此当rd_en到达后，寄存器将复位后或初始状态时寄存器数据输入端口的0读出来，同时data0从RAM中读到寄存器的输入端口，此时已经消耗掉rd_en的一个周期，因此接下来只剩下4个周期用来读数据，所以最终只能读出data0-data3。
最后可参考下文，其中也内嵌了其他参考文章的链接。
双口RAM的读数据延迟
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7dc94c9c95062122ff21cda7cf05dd0b/" rel="bookmark">
			XShell（Linux）下Nginx配置静态html（安装NGINX）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用工具：Xshell
首先应连接上服务器，能在xshell上面进行操作。
一、将项目放置到服务器中文件夹中
可以使用rz -y将本地文件进行上传到当前文件夹中，-y是替换同名文件 。上传可以上传多个文件，但是不能上传文件夹，只能手动mkdir文件夹。
上图详细操作
mkdir 文件夹名 #创建一个新目录命令 cd 文件夹名 #进入目录命令 rz -y # 把本地文件上传到服务器，sz指令是从服务器上将文件下载到本地 pwd # 查看当前文件绝对路径 二、NGINX下载安装
这里先默认大家都么有安装NGINX，如果已安装可以跳过此节。
①cd /usr/local ②wget http://nginx.org/download/nginx-1.21.0.tar.gz 下载
③tar -xvf nginx-1.21.0.tar.gz 解压
④进入目录安装NGINX
cd nginx-1.21.0
./configure --prefix=/usr/local/nginx
⑤执行make命令
⑥执行make install命令
详细可以查看Linux下搭建Nginx - Love小祝子 - 博客园
三、NGINX的配置（重点）
最近有点忙 先不写了 后续有空再写
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e984a2adde759eeadfa1a3cdcc92449e/" rel="bookmark">
			RPA拾取界面元素方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RPA鼠标点击组件的拾取元素方式
ESC：退出本次拾取
F2 ：智能拾取开启
开启后默认为系统智能判断所需拾取的页面并自动切换拾取方式。如不需要智能模式，则可以通过 F2 手动关闭。
F3 ：CS 拾取
技术选型：pywinauto，封装 Win32 的 api，适用于 MFC，VB6，VCL，简单的 WinForms 控件和大多数旧的遗留应用程序。
适用范围：大部分基于 win32 Control 设计开发的客户端软件；
优点：比较稳定、适用范围较广；
缺点：对于不是依赖 win32 Control 开发的客户端就无法拾取，如 EXCEL 的 cell 都是通过代码绘制的就无法拾取。
F4：UIA 拾取
技术选型：uiautomation，封装的 windows 中的 uia 框架，适用于 WinForms，WPF，商店应用，Qt5，浏览器应用。
适用范围：几乎可以适用于所有 C/S、B/S 页面（个别可能出现无法拾取的情况，但拾取范围大于 CS 拾取）；
优点：拾取范围大、适用性广；
缺点：部分软件控件属性可能随时间推移变化，导致第二次执行就无法执行。
F5：图片拾取
适用范围：适用于所有客户端、网页等。
优点：拾取范围大
缺点：受分辨率、缩放等影响，控件任何微小的变化都会导致图片点击无法点击。（一般换电脑就需要重新拾取）
F8：区域拾取
适用范围：适用于所有客户端、网页等。
优点：拾取范围大，可以和其他（除图片拾取）拾取方式配合使用。
缺点：受缩放，控件位置等影响，此功能主要基于拾取控件的相对位置点击，受限于拾取控件位置是否变化，需要点击控件位置是否变化。
先切换 F3（CS 拾取）拾取到一个控件后，再按 F8（区域拾取），就可以实现基于 CS 拾取的偏移拾取，其他拾取也同理。
F7：Java 拾取
适用范围：适用于 java 类的客户端，或网页;
优点：可以解决 Java 类产品的拾取，如 Oracle EBS 等产品;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e984a2adde759eeadfa1a3cdcc92449e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/598f3390acb3e4e5946352c1caf1dc58/" rel="bookmark">
			python&#43;django英语单词学习网站vue
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通过本系统，实现了不同权限的用户登录，包括用户和管理员。管理员:首页、个人中心、用户管理、每日任务管理、词汇单词管理、试卷管理、试题管理、交流论坛、系统管理、考试管理。用户：首页、个人中心、每日任务管理、我的收藏管理、考试管理，前台首页；首页、词汇单词、交流论坛、试卷列表、系统公告、个人中心、后台管理、客服等功能。本系统经过测试，运行效果稳定，操作方便、快捷，是一个功能全面、实用性好、安全性高，并具有良好的可扩展性、可维护性的英语单词学习网站。前端技术：nodejs+vue+elementui
我们最初的项目结构由五个文件组成：
manage.py：使用django-admin命令行工具的快捷方式。它用于运行与我们项目相关的管理命令。我们将使用它来运行开发服务器，运行测试，创建迁移等等。
__init.py：这个空文件告诉python这个文件夹是一个python包。
settings.py：这个文件包含了所有的项目配置。将来我们会一直提到这个文件！
urls.py：这个文件负责映射我们项目中的路由和路径。例如，如果你想在访问URL / about/ 时显示某些内容，则必须先在这里做映射关系。
wsgi.py：该文件是用于部署的简单网关接口。你可以暂且先不用关心她的内容，就先让他在那里就好了。
django自带了一个简单的网络服务器。在开发过程中非常方便，所以我们无需安装任何其他软件即可在本地运行项目。我们可以通过执行命令来测试一下它：
python manage.py runserver
开发语言：Python
框架：django
Python版本：python3.7.7
数据库：mysql 数据库工具：Navicat11
开发软件：PyCharm 本文研究的英语单词学习网站基于当前较为流行的B/S结构，采用python技术和MYSQL数据库进行开发设计。
越来越多的学生喜欢把前端Vue+python技术组合当做自己的毕业设计项目.其实是非常新颖的毕设了。在众多毕设项目中也算是给老师眼前一亮。也给自己的加不少分。总比那些jsp图书管理、进销存系统等几十年不变的系统强上几百倍，至少在老师看来你还算是跟的上互联网潮流了。
本软件是一款高智能化的英语学习软件，具备查阅复习内容，复习进度，以及复习提醒等功能；还需具有复习汇总等功能。用户可无限扩充自己的词库，能随心所欲地制作出适合自己的词库，达到快速记单词，读音，词义的效果。让你轻松提高学习英语单词的效率，短期内记住海量的单词不再是难事！
目 录
第一章 绪论 1
1.1 研究的背景和意义 1
1.1.1网站的研究背景 1
1.1.2 网站研究的意义 1
1.2 研究现状 2
1.3 论文的主要内容 2
1.4 论文主体结构 2
第二章 开发工具和相关技术介绍 4
2.1 平台开发工具 4
2.2 平台开发相关技术 4
2.2.1 B/S架构 4
2.2.3 mysql数据库介绍 5
第三章 系统需求分析 7
3.1 可行性分析 7
3.1.1 技术可行性 7
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/598f3390acb3e4e5946352c1caf1dc58/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43c4a4901fe7f016c45e00586f19dd70/" rel="bookmark">
			常用的网络命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一：ping命令
二：ipconfig命令
三：netstat命令
四：arp命令
五：net命令
六：at命令
七：tracert命令
八：rote命令
九：nbtstat命令
常见的网络命令有：ping命令，ipconfig命令，netstat命令，arp命令，net命令，at命令，tracert命令，rote命令，nbtstat命令等。下面简单了解一下这些网络命令如何操作以及其作用吧！
一：ping命令 ping命令是DOS命令，一般用于检测网络是否通畅以及网络连接速度，结果只越大，说明速度越慢。它使用网络层的ICMP协议。
ping命令分为：
1：ping 127.0.0.1
2：ping ip -t(例如：ping 127.0.0.1 -t）注意ping与IP地址之间存在一个空格。这是连续对IP地址执行ping命令，直到用户以&lt;control+c&gt;键强制中断，否则会一直出现数据。
3：ping ip -l 3000（注意每个之间都存在空格）：指定ping命令的数据长度为3000字节，而不是32字节。
4：ping ip -n count：执行特定次数的ping命令，注意操作时需要将count换成具体的数字。
二：ipconfig命令 ipconfig可用于显示当前的TCP/IP配置的设置值，这些信息一般用来检验人工配置的TCP/IP是否正确。
1：ipconfig 当使用该命令不带任何参数时，它为每个已经配置了的接口显示IP地址，子网掩码和默认网关值。
2：ipconfig /all 当使用all参数时，ipconfig能为DNS和WINS服务器显示它已经配置和所要使用的附加信息，并且显示内置于本地网卡中的物理地址（MAC）。ipconfig将显示DHCP服务器的IP地址和租用地址预计失效时间。
三：netstat命令 netstat命令用于显示IP、TCP、UDP、和ICMP协议相关的统计数据，一般用于检验本机各个端口的网络连接情况。
1：netstat -a 显示一个所有有效连接信息列表，包括已建立的连接和监听链接请求。
2：netstat -n 显示所有已建立的有效连接 3：netstat -r 显示关于路由表的信息，类似于route print命令所显示的信息，除了显示当前有效的路由外，还显示当前有效的连接
四：arp命令 arp是地址转换协议的意思，用于确定对应IP地址的网卡物理地址。该命令能够查看本地计算机或另一台计算机的arp高速缓存中当前的内容，也可以使用该命令用人工方式数输入静态的网卡物理/IP地址对，通常会使用这种方式为默认网关和本地服务器等常用主机进行设置，有助于减少网络上的信息量，最常用的arp -a或者 arp -g这种形式，用于查看高速缓存中的所有项目，这两种的执行结果是一样的。
五：net命令 net命令用于核查计算机之间的NetBIOS连接，可以查看管理网络环境、服务、用户、登录等信息内容。
1：net share 它的作用是创建、删除、或显示共享资源
2：net start 它的作用是启动服务，或显示已经启动服务的列表
六：at命令 at是windows系列操作系统中的内置命令。at命令可任意字指定时间和日期、在指定计算机上运行命令和程序
七：tracert命令 一般用来检测出现故障的位置，即在哪个环节上出现了问题。
这个命令显示于将数据包从计算机传递到目标位置的一组IP路由器，以及每个跃点所需要的时间。如果数据包不能传递到目标，tracert命令将显示成功转发数据包的最后一个路由器。
1：tracert IP或tracert URL 该命令返回到IP地址所经过的路由器列表，URL表示网址
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43c4a4901fe7f016c45e00586f19dd70/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97213e2f3fb7e846bbf00a32d30dac25/" rel="bookmark">
			Redis持久化的两种方式：RDB与AOF（详解）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、概述： RDB和AOF持久化的由来？
因为Redis中的数据是基于内存的，所以如果出现服务器断电或者服务器宕机，那么Redis中存放的数据就会直接丢失。RDB和AOF就是针对Redis提供的两种持久化机制，可以将Redis中的数据持久化到磁盘中。当Redis实例故障重启后，就可以根据备份的文件来进行数据的恢复
二、RDB 概述: RDB全称Redis Database Backup file，也被叫做Redis数据快照，简单来说就是把内存中所有的数据都记录在磁盘中，当Redis实例故障重启后，从磁盘读取快照文件，恢复数据。快照文件称为RDB文件，默认是保存在当前的运行目录（RDB可以理解为U盘拷贝，将Redis中的数据直接进行复制操作）
每次触发RDB的时候，就会重新生成一个新的RDB文件，覆盖旧的RDB文件文件，这样就可以确保备份得到最新的数据。
RDB的触发策略： ① 关闭Redis实例的时候，redis会在关闭之前主动的进行一次RDB（关闭不是宕机，宕机则数据丢失）
② 当你使用save/bgsave命令的时候，redis也会进行内存数据的持久化
③ 通过配置文件的配置触发：redis.conf配置文件
save 900 1
– 表示在900秒内，redis中有1个key发生改变，那么就进行一次bgsave
save 300 10
– 表示在300秒内，redis中有1个key发生改变，那么就进行一次bgsave
save 60 10000
– 表示在60秒内，redis中有10000个key发生改变，那么就进行一次bgsave
save/bgsave的不同 前面说到可以使用save命令或者bgsave命令来触发RDB，那么两者有什么区别呢？
如果使用的是save命令，数据备份就是由主线程来操作的，由于Redis是单线程的，所以如果使用save命令来进行内存的数据备份，那么在数据备份的时候redis是无法响应用户的请求的。当需要备份的数据非常大的时候，就可能导致请求被阻塞超时的情况如果使用的是bgsave命令，那么实际上是主线程fork个子线程，让子线程来进行RDB操作，主线程只是在fork子线程的时候阻塞，之后便可以继续响应用户的请求。接下来子进程即可读取内存数据并进行持久化，生成新的RDB文件替换旧的RDB文件 RDB缺点： RDB执行间隔时间长，两次RDB之间写入数据有丢失风险fork子进程、压缩、写出RDB文件都比较耗时 RDB优点： 使用RDB文件进行数据的恢复速度快、效率高（类似于文件拷贝）相比于AOF持久化的文件，RDB的文件更小 RDB的相关配置： 在redis.conf配置RDB文件压缩 # 表示的是是否开启压缩，不建议开启，虽然节省空间，但是会耗费CPU rdbcompression yes 在redis.conf配置RDB文件名 # 默认的rdb文件名称 dbfilename dump.rdb 在redis.conf配置rdb文件存放路径 dir ./ 在redis.conf配置触发策略 # 15分钟内有1个key发生改变，那么就保存 save 900 1 # 5分钟内有10个key发生改变，那么就保存 save 300 10 # 1分钟内有10000个key发生改变，那么就保存 save 60 10000 # 执行的都是bgsave 三、AOF 概述： AOF的全称叫做Append Only File（追加文件）Redis处理的每一个命令都会记录在AOF文件中，可以看做是命令日志文件（AOF存放的不是数据本身而是执行redis写操作的命令，类似于存放insert/update等这类命令而不是数据）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/97213e2f3fb7e846bbf00a32d30dac25/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1eb3745f5d16eb4bbea79beb4b3922c6/" rel="bookmark">
			（附源码）计算机毕业设计SSM连锁便民超市前端系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（附源码）计算机毕业设计SSM连锁便民超市前端系统
项目运行
环境配置：
Jdk1.8 + Tomcat7.0 + Mysql + HBuilderX（Webstorm也行）+ Eclispe（IntelliJ IDEA,Eclispe,MyEclispe,Sts都支持）。
项目技术：
SSM + mybatis + Maven + Vue 等等组成，B/S模式 + Maven管理等等。
环境需要
1.运行环境：最好是java jdk 1.8，我们在这个平台上运行的。其他版本理论上也可以。
2.IDE环境：IDEA，Eclipse,Myeclipse都可以。推荐IDEA;
3.tomcat环境：Tomcat 7.x,8.x,9.x版本均可
4.硬件环境：windows 7/8/10 1G内存以上；或者 Mac OS；
5.是否Maven项目: 否；查看源码目录中是否包含pom.xml；若包含，则为maven项目，否则为非maven项目 6.数据库：MySql 5.7/8.0等版本均可；
毕设帮助，指导，本源码分享，调试部署(见文末)
总体设计
连锁便民超市前端系统采用了结构化开发的方法。这种开发方法的优点是控制性比较强，开发过程中采用了结构化和模块化的设计思想，自顶向下，从总体到部分，合理划分系统的结构和模块。结构化开发时使用模块式开发，各模块之间互不影响，方便系统的开发与管理。 本系统的设计是基于 B/S架构的三层体系结构，也就是浏览器和服务器结构。计算机技术发展的速度非常快，以前的设计结构都以C/S的模式为主，也就是前台和后台模式。但随着网页技术的发展，越来越多的门店信息习惯于使用浏览器。现在的网页技术可以在浏览器中实现非常漂亮的效果，以前的单一低调的门店信息端页面已经无法满足门店信息的需求。在B/S这种结构下，技术人员可以很轻松的设计出门店信息所需要的工作界面，页面代码通过浏览器进行解析展示，在浏览器中不做过多的事务逻辑的处理。主要的事务逻辑放在服务端进行处理。这样门店信息的电脑就不会承载过多的东西，只需要浏览器展示即可。对于开发人员也很方便进行系统的维护和升级。开发人员只需要在服务端进行系统的维护就可以了。使用JSP这样的跨平台性非常好的技术，这样的开发模式更加的方便，高效。本系统合理的进行了模块划分和组合，因此由于各个模块之间基本上是相互独立的，所以每个模块都可以独立的被解释、执行、调试和修改，让繁琐的系统设计工作简单化。系统总体设计图如下图4-1所示：
图4-1系统总体设计图
4.2 数据库设计 4.2.1 概念模型设计 数据可设计要遵循职责分离原则，即在设计时应该要考虑系统独立性，即每个系统之间互不干预不能混乱数据表和系统关系。
数据库命名也要遵循一定规范，否则容易混淆，数据库字段名要尽量做到与表名类似。
概念模型是对现实中的问题出现的事物的进行描述，ER图是由实体及其关系构成的图，通过E-R图可以清楚地描述系统涉及到的实体之间的相互关系。
商品调货信息实体图如图4-2所示：
图4-2商品调货信息实体图
门店信息实体图如图4-3所示：
图4-3门店信息实体图
门店商品信息实体图如图4-4所示：
图4-4门店商品信息实体图
商品销售信息实体图如图4-5所示：
图4-5商品销售信息实体图
管理员功能模块
管理员要登录连锁便民超市前端系统，需要输入用户名和密码，选择登录角色进行登录，管理员登录界面如图5-1所示：
图5-1管理员登录界面
管理员功能：管理员登录系统后，能对首页、个人中心、门店信息管理、商品类型管理、库存商品管理、商品调货管理、门店商品管理、商品入库管理、商品销售管理进行操作。管理员功能如下图5-2所示：
图5-2管理员功能界面
门店信息管理：在门店信息管理页面，可以查看账号、门店名称、负责人、性别、联系电话、邮箱、门店地址等信息进行修改、删除等操作，如图5-3所示：
图5-3门店信息管理界面
商品类型管理：在商品类型管理页面，可以查看商品类型信息等内容，还能进行修改、删除等操作，如图5-4所示：
图5-4商品类型管理界面
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1eb3745f5d16eb4bbea79beb4b3922c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45dd0b4a2a55ad8c8b7374a3fa3e710d/" rel="bookmark">
			Java高级之HashMap中的哈希表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		哈希表中的“表” 当我们需要存储一种映射数据时，就需要用到哈希表，也称为散列表（Hash Table）。
该数据结构中存储的是键（key）和值（value），它们是对应关系。
只需要给出一个指定的key，那么就能高效查找到它所匹配的值，效率非常高，时间复杂度接近于O(1)。
这就是哈希表中的“表”，表中维护了key与value的映射关系。
哈希表中的“哈希” 思考下，那么该如何存储键值对（key—value）呢？
如果使用链式存储结构：
肯定是不行的，因为如果要查找到指定key对应的结点，就需要遍历整个链表，时间复杂度很大，不是O(1)。
考虑使用顺序存储结构：
即使用数组，但数组只能根据下标，像a[0]、a[1]、a[2]这样来访问，但哈希表的key通常不是整数型，而多是字符串类型。
像a["key1"]、a["key2"]这样访问是无法的，语法不允许。
所以考虑通过一个中介，将key和数组下标进行转换，也是一种映射，来达到访问对应值value的目的，而具有这种转换能力的就叫做哈希函数。
Hash，一般翻译做散列、杂凑，或音译为哈希，是把任意长度的输入（又叫做预映射pre-image）通过散列算法变换成固定长度的输出，该输出就是散列值。
这就是哈希表中的“哈希"。
在JDK1.8之前中HashMap使用的数组+链表结构。
在JDK1.8及之后中HashMap使用的数组+链表+红黑树结构。
哈希冲突 哈希冲突是发生在哈希表中插入新的键值对的时候。
像哈希表中添加键值对的步骤如下：
第一步：通过哈希函数，将key转换成数组下标。
第二步：如果数组下标位置没有元素，即为null，那么把该键值对添加到该位置。（在HashMap中使用Entry对象表示键值对）
但注意，数组的长度是有限的，当添加的元素越来越多，超过数组长度的时候，不同的key通过哈希函数获得的下标可能是相同的，但是在下标位置已经有元素了，那么这就发生了哈希冲突。
解决哈希冲突的方法有很多种，如开放寻址法、链表法（拉链法）。
在HashMap中就使用的是拉链法解决哈希冲突。
HashMap数组中每个元素都是一个Entry，同时是一个链表的头结点，Entry不仅保存了键和值
还有next指针，指向下一个结点。
源码HashMap中的putVal方法有所说明：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/466824e3897c8205fee311868bef335e/" rel="bookmark">
			深度学习基本概念
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		batch size 一个训练集过大(m个样例)，需要划分。
划分为1个： 名称：batch梯度下降batch_size = m用整个训练集进行梯度下降 划分为5个： 名称：mini-batch梯度下降batch_size = m/5 划分为m个： 名称：随机梯度下降batch_size = 1一次对一个样例数据进行梯度下降 epoch 对整个训练集进行一次梯度下降：即所有的训练样本完成一次forward和backward propagation。
对于训练集划分为5个子集：就是对5个子集都执行完。
一般样本要过很多次，多个epoch，直到收敛。
iteration 迭代，表示进行了一次梯度下降，更新了一次网络参数。
iteration=[batch_size]个训练数据forward+backward后更新参数过程
episode 一个状态、动作和回报的序列，以终止状态结束。对于围棋，从头到尾下一盘棋就是一个episode。
下采样 下采样层有两个作用，一是减少计算量，防止过拟合；二是增大感受野，使得后面的卷积核能够学到更多更加全面的信息。
下采样的方式主要有两种：
采用stride为2的池化层，如Max-pooling和Average-pooling ，目前通常使用Max-pooling，因为他计算简单而且能够更好的保留纹理特征；采用stride为2的卷积层，下采样的过程是一个信息损失的过程，而池化层是不可学习的，用stride为2的可学习卷积层来代替pooling可以得到更好的效果，当然同时也增加了一些计算量 卷积 一个尺寸 i n s i z e × i n s i z e \rm in_{size}\times in_{size} insize​×insize​ 的特征图，经过 c o n v s i z e × c o n v s i z e \rm conv_{size}\times conv_{size} convsize​×convsize​ 的卷积层，步幅为 s t r i d e \rm stride stride，填充为 p a d d i n g s i z e \rm padding_{size} paddingsize​，计算出输出的特征图尺寸：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/466824e3897c8205fee311868bef335e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d1ac0c476213d73575c95def67ff48f/" rel="bookmark">
			c语言常量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		c语言常量 常量整数常量浮点常量字符常量字符串常量 定义常量定义常量方法#define 预处理器const 关键字#define 和 const 的区别 常量 1.常量是固定值，在程序执行期间不会改变。这些固定的值，又叫做字面量。
2.常量可以是任何的基本数据类型，比如整数常量、浮点常量、字符常量，或字符串字面值，也有枚举常量。
3.常量就像是常规的变量，只不过常量的值在定义后不能进行修改。
整数常量 整数常量可以是十进制、八进制或十六进制的常量。前缀指定基数：0x 或 0X 表示十六进制，0 表示八进制，不带前缀则默认表示十进制。
整数常量也可以带一个后缀，后缀是 U 和 L 的组合，U 表示无符号整数（unsigned），L 表示长整数（long）。后缀可以是大写，也可以是小写，U 和 L 的顺序任意。
//整数常量常用实例 85 // 十进制 0213 // 八进制 0x4b // 十六进制 30 // 整数 30u // 无符号整数 30l // 长整数 30ul // 无符号长整数 浮点常量 浮点常量由整数部分、小数点、小数部分和指数部分组成。您可以使用小数形式或者指数形式来表示浮点常量。
当使用小数形式表示时，必须包含整数部分、小数部分，或同时包含两者。当使用指数形式表示时， 必须包含小数点、指数，或同时包含两者。带符号的指数是用 e 或 E 引入的。
//浮点常量常用实例 3.14159 // double常量 314159E-5 // 科学计数法 3.1f // float常量 字符常量 字符常量是括在单引号中，例如，‘x’ 可以存储在 char 类型的简单变量中。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d1ac0c476213d73575c95def67ff48f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/214003439bff2e69e46d0493daa97075/" rel="bookmark">
			微信小程序下的登录，并缓存token
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微信小程序下的登录，并缓存token,实现登录后渲染用户数据
登录
登录的接口
登录的小程序前端
登录后用户数据的渲染
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec42ca952056094107524f4c390f595d/" rel="bookmark">
			js中ASCII编码的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 大写字母A-Z对应的ASCII码值是65-90
小写字母a-z对应的ASCII码值是97-122
数字0-9对应的ASCII码值是 48-57
将ASCII码转换为对应的字母 let num = 65 let num2 = 66 String.fromCharCode(num) // A String.fromCharCode(num2) // B 将字母转换为对应的ASCII码 let str = 'A' let str2 = 'S' str.charCodeAt() // 65 str2.charCodeAt() // 83 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/218/">«</a>
	<span class="pagination__item pagination__item--current">219/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/220/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>