<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5daa46bf93f1665f5954a2a9dfc9882/" rel="bookmark">
			北京互联网公司、外企、国企大盘点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天来盘点北京的泛互联网公司。涵盖了综合类、外企类、硬件类、电商类、游戏类、娱乐类、生活类、工具类、人工智能类、金融类、教育类、招聘类、汽车类、外包类、信息化类以及国企央企类等多个领域。
综合类 字节跳动
美团
百度
阿里巴巴
腾讯
网易
外企类 微软
谷歌
亚马逊
Paypel
Canva
Shopee
Airbnb
IBM
苹果
三星
戴尔
宝马
印象笔记
思科
联发科
爱立信
Grab
Freewheel
特斯拉
Oracle
领英
Coupang
英特尔
Hulu
硬件类 华为
小米
联想
VIVO
OPPO
荣耀
京东方
国美电器
中兴
电商类 京东
拼多多
当当网
值得买科技
永辉大科技
便利蜂
爱回收
转转
多抓鱼
美菜
蜜芽
游戏类 完美世界
昆仑万维
三七互娱
趣加
乐元素
英雄互娱
搜狐畅游
祖龙娱乐
光宇
龙图游戏
莉莉丝
掌趣科技
点点互动
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5daa46bf93f1665f5954a2a9dfc9882/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7df316900dd49a0e32e70205736aa39f/" rel="bookmark">
			【Unity3D】UGUI物体世界坐标转屏幕坐标问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 如题： UGUI物体世界坐标转屏幕坐标问题，获取UI(UGUI)屏幕坐标问题等相关问题
思路：必须使用Canvas身上的Camera，进行Camera.WorldToScreenPoint(UI物体的世界坐标Vector3)，会返回一个Vector3(x,y,z)，我们要的是正常的2个分量作为屏幕坐标。
按道理屏幕坐标是Vector2，所以Vector3里会有一个异常的分量，一般是Z值，所以我们要用
正常API：使用摄像机将世界转屏幕坐标点Vector3 再转Vector2
Vector3 screenPointVec3 = camera.WorldToScreenPoint(uiGameObject.transform.position); Vector2 screenPosVec2 = new Vector2(screenPointVec3.x, screenPointVec3.y); //每次都new Vector2不太好，可以外部创一个成员Vector2, 然后使用vec2.Set(x,y); 扩展：RectTransformUtility会直接转成Vector2（未测试是否正常）
Vector2 vec2 = RectTransformUtility.WorldToScreenPoint(Camera, Vector3); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2a86222ec93c6bc6ecfe7c7770195e0/" rel="bookmark">
			Linux——补充点（进程切换及页表映射）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
补充点1：进程地址空间堆区管理
补充点2：Linux内核进程上下文切换
补充点3：页表映射
补充点4：两级页表
补充点1：进程地址空间堆区管理 Linux内核通过一个被称为进程描述符的task_struct结构体来管理进程，这个结构体包含了一个进程所需的所有信息。该结构体存放在叫做任务列表的双向循环列表中！
所学习过的包含：
进程标识符 - 进程优先级 - 进程状态 - 进程地址空间 - 文件描述符表 - 进程信号位图 - CPU寄存器的上下文数据 - 进程相关页表（内核级页表、用户级页表）
在进程地址空间中，栈区，代码区等一部分区域，是被整体所使用的！而堆区具有更细粒度的划分，包括使用者等（参考文章：Glibc——堆利用机制[拓展]_IfYouHave的博客-CSDN博客），因此堆是使用一个vm_area_struct小的结构体进行区分，使用双链表的形式进行管理！
（参考文章：linux内核学习笔记-struct vm_area_struct_struct vm_area_struct source code_带着耳机去梦游的博客-CSDN博客）
在进行堆区申请空间，上层调用malloc函数 - 底层调用brk系统调用，就会申请一个vm_area_struct，内有start表针虚拟地址起始，end表示虚拟地址结束，经过页表映射至内存。
堆区典型特征：申请的空间连续！
OS是可以做到让进程进行资源细粒度划分的
补充点2：Linux内核进程上下文切换 进程上下文是进程执行活动全过程的静态描述。我们把已执行过的进程指令和数据在相关寄存器与堆栈中的内容称为进程上文，把正在执行的指令和数据在寄存器与堆栈中的内容称为进程正文，把待执行的指令和数据在寄存器与堆栈中的内容称为进程下文。
实际上linux内核中，进程上下文包括进程的虚拟地址空间和硬件上下文。
进程硬件上下文包含了当前cpu的一组寄存器的集合，arm64中使用task_struct结构的thread成员的cpu_context成员来描述，包括x19-x28,sp, pc等。
进程上下文切换主要涉及到两部分主要过程：进程地址空间切换和处理器状态切换。地址空间切换主要是针对用户进程而言，而处理器状态切换对应于所有的调度单位。
进程地址空间切换：
进程地址空间内有进程运行的指令和数据，因此到调度器从其他进程重新切换到我的时候，为了保证当前进程访问的虚拟地址是自己的必须切换地址空间。
进程pcb内mm_struct结构体将各个vma组织起来进行管理，其中有一个成员pgd至关重要，地址空间切换中最重要的是pgd的设置。pgd中保存的是进程的页全局目录的虚拟地址，那么pgd的值是何时被设置的呢？
答案是fork的时候，如果是创建进程，需要分配设置mm_struct，其中会分配进程页全局目录所在的页，然后将首地址赋值给pgd，完成了这一步，也就完成了进程的地址空间切换，确切的说是进程的虚拟地址空间切换。
处理器状态（硬件上下文）切换：
处理器状态切换就是将前一个进程的sp,pc等寄存器的值保存到一块内存上，然后将即将执行的进程的sp,pc等寄存器的值从另一块内存中恢复到相应寄存器中，恢复sp完成了进程内核栈的切换，恢复pc完成了指令执行流的切换。
其中保存/恢复所用到的那块内存需要被进程所标识，这块内存这就是cpu_contex这个结构的位置（进程切换都是在内核空间完成）。
线程部分会学习：
内核线程，不需要切换地址空间，只进行硬件上下文切换
所有的进程线程之间进行切换都需要切换处理器状态。
对于普通的用户进程之间进行切换需要切换地址空间
同一个线程组中的线程之间切换不需要切换地址空间，因为他们共享相同的地址空间。
内核线程在上下文切换的时候不需要切换地址空间，仅仅是借用上一个进程mm_struct结构。（参考文章：深入理解Linux内核进程上下文的切换 - 知乎 (zhihu.com)）
补充点3：页表映射 MMU(Memory Management Unit)，即内存管理单元，是一个硬件，是现代CPU架构中不可或缺的一部分，MMU主要包含以下几个功能：
虚实地址翻译 在用户访问内存时，将用户访问的虚拟地址翻译为实际的物理地址，以便CPU对实际的物理地址进行访问。 访问权限控制 可以对一些虚拟地址进行访问权限控制，以便于对用户程序的访问权限和范围进行管理，如代码段一般设置为只读，如果有用户程序对代码段进行写操作，系统会触发异常。 引申的物理内存管理 对系统的物理内存资源进行管理，为用户程序提供物理内存的申请、释放等操作接口。 使用MMU带来的好处或者优势：
提升物理内存的利用率 物理内存按需申请，如代码段的内存在执行时进行映射和转换，进程fork后，t通过写时复制(Copy-On-Write)进行真正的物理内存分配。解决内存管理碎片化的问题，即在系统运行一段时间后，频繁的内存申请和释放会导致内存碎片化，无法申请到一块足够大的地址连续的内存。 对内存地址的访问进行控制 如上述代码段只读权限控制，多线程的栈内存之间的空洞页隔离可以防止栈溢出后改写其他线程的栈内存，不同进程之间的地址隔离等等。 将进程的地址空间隔离 不同进程之间可以使用相同的虚拟内存地址空间，而进程间的物理内存又可以做到隔离，这保证了进程的独立性同时，又简化了地址的访问方式，如在早期32位CPU上，为了支持4G以上的物理内存，一般物理地址有36-bit(如PowerPC-604系列)，但是用户的虚地址仍然使用32-bit，做法就是将用户的不同进程的32-bit虚地址在MMU转换时，转换为36-bit的物理地址，这样每个进程仍然能访问0-3G虚地址范围，将多个进程的3G空间映射到36-bit的物理内存空间中去。 上述参考文档（MMU原理 - page）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d2a86222ec93c6bc6ecfe7c7770195e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f0ed3b4c489a702d7825084d0438936/" rel="bookmark">
			深度学习——目标检测（R-CNN、Fast R-CNN、Faster R-CNN）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、RCNN
二、Fast R-CNN
三、Faster R-CNN
四、FPN(Feature Pyramid Networks)
一、RCNN 2000个框，每个框都得到4096个特征，把得到的输入svm，得出20个分类的结果
A svm分类后概率为 0.98，B 概率为 0.86，通过对边界框进行IOU计算，大于我们设定的阈值说明是同一个目标，就把概率低的删掉
回归那里，因变量就是高度、宽度、长度比例、宽度比例，一个四维的数据
二、Fast R-CNN RCNN是将候选区域输入网络，Fast R-CNN是将整个图像输入网络 目标检测architecture通常可以分为两个阶段：
（1）region proposal：给定一张输入image找出objects可能存在的所有位置。这一阶段的输出应该是一系列object可能位置的bounding box。这些通常称之为region proposals或者 regions of interest（ROI），在这一过程中用到的方法是基于滑窗的方式和selective search。
（2）final classification：确定上一阶段的每个region proposal是否属于目标一类或者背景。
ROI pooling具体操作如下：
根据输入image，将ROI映射到feature map对应位置；将映射后的区域划分为相同大小的sections（sections数量与输出的维度相同）；对每个sections进行max pooling操作； 从 2000 个候选框，采集64个候选区域，一部分是正样本，一部分是负样本
只要 IOU 大于0.5就是正样本，0.1 到 0.5是负样本
最后并联两个全连接层，一个用来 分类概率的预测，另一个用来 边界框参数的预测
每个类别都有4个参数
这里的分类损失其实就是交叉熵损失
[u≥1] 的意思是：当 u 满足 ≥1时，这一项 = 1，当u不满足≥1时，就是对应背景时，这一项 =0
真实框参数 v ，如 Vy = （Gy - Py）/ Ph
三、Faster R-CNN 投影方法：找到候选框ROI在原始图像上的位置，然后等比例缩放到特征图的相同位置上
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f0ed3b4c489a702d7825084d0438936/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2618f3e15d7253d39ba96b3b9d11881e/" rel="bookmark">
			算法笔记(栈模拟递归求阶乘问题)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include&lt;iostream&gt; #include&lt;stack&gt; using namespace std; typedef struct{ int n;//保存n值 int f;//保存f(x)值 int flag;//标记当前递归层是否可求出结果(1为已知，0为未知) }fst; int fun(int n){ fst e,e1,e2; stack&lt;fst&gt;st; e.n=n; e.flag=0; st.push(e);//f(n)入栈 while(!st.empty()){ if(st.top().flag==0)//当前栈顶元素值未知时 { if(st.top().n==1)//当前栈顶元素为f(1)时 { st.top().f=1; st.top().flag=1; } else { e1.n=st.top().n-1; e1.flag=0; st.push(e1);//f(n-1)入栈 } } else { e2=st.top(); st.pop();//退栈 st.top().f=st.top().n*e2.f;//f(n)=f(n-1)*n st.top().flag=1; } if(st.size()==1&amp;&amp;st.top().flag==1) break; } return(st.top().f); } int main(){ int n; cout&lt;&lt;"请输入n的值:"; cin&gt;&gt;n; cout&lt;&lt;n&lt;&lt;"的阶乘为"&lt;&lt;fun(n); } -------该算法摘自《算法设计与分析(第2版)》
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3deffcecd1ebce165df69dd08abc1f31/" rel="bookmark">
			python缩进规则&amp;标准输入输出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、python缩进规则 由于python中没有{...}来表示层次和结构，python必须通过缩进来对代码块的结构和层次进行区分。
python的缩进规则是针对逻辑行的，因此首先要区分物理行和逻辑行。
物理行：在python中，物理行是指在代码中实际占据一行的行。（空白行也是一个物理行）
a = 10 b = 3 c = a + b print(c)//一共有5个物理行 obj={ "a":1, "b":2 } //一共有4个物理行 逻辑行：逻辑行是指在代码中逻辑上相关联的语句组成的行。即完整执行一条逻辑语句的语句
obj={ "a":1, "b":2 } //一共有1条逻辑行 print("1\ 2\ 3") //一共有1条逻辑行 缩进的一般规则
1.逻辑行的首行应该顶格，无需缩进
2.同一层次的代码块缩进量应当相同
3.使用":"标记一个新的逻辑行（如if&lt;条件&gt;：）
4.代码块之间应相隔2个物理行（pycharm的缩进要求）
缩进报错
IndentationError: unexpected indent（缩进错误：意外的缩进）：当缩进不正确时，会出现此错误。例如，在一个代码块中的行没有正确对齐。
IndentationError: unindent does not match any outer indentation level（缩进错误：取消缩进与任何外部缩进级别不匹配）：当取消缩进的数量与外部缩进级别不匹配时，会出现此错误。例如，在一个代码块中的行没有正确对齐。
TabError: inconsistent use of tabs and spaces in indentation（制表符错误：缩进中使用了不一致的制表符和空格）：当在缩进中同时使用制表符和空格时，会出现此错误。Python要求在一个代码块中使用一致的缩进方式。
一般情况下将代码语句顶格，使用Tab键可以解决IndextationError问题
2、标准输入输出 2.1、标准输入（input） 一般的使用方法：
name = input("&lt;注释&gt;") input()函数是Python中用于从标准输入（通常是键盘）获取用户输入的函数。它会等待用户输入一行文本，并将其作为字符串返回。
输入一行数值：
a = list(map(&lt;函数&gt;, input().
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3deffcecd1ebce165df69dd08abc1f31/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b92c5246419dbe331f1e50ad4f65cb8/" rel="bookmark">
			ensp基础实验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
交换机远程登录路由器
配置eth-trunk 链路聚合
mstp
mux-vlan
单臂路由配置
DHCP配置
DHCP中继
浮动路由
VRRP配置
ACL
交换机远程登录路由器 拓扑图
R1 [R1]user-interface vty 0 4 # 创建会话 [R1-ui-vty0-4]authentication-mode aaaa # 开启aaa认证 [R1-ui-vty0-4]aaa [R1-aaa]local-user HCIE password cipher 123456 # 设置账户密码 [R1-aaa]local-user HCIE privilege level 15 # 设置用户权限 [R1-aaa]local-user HCIE service-type telnet # 开启远程登录 #端口配置ip [R1]int g0/0/0 [R1-GigabitEthernet0/0/0]ip add 192.168.1.254 24 SW1 [SW1]vlan 1 [SW1-Vlanif1]ip add 192.168.1.1 24 [SW1-Vlanif1]q [SW1]int e0/0/1 [SW1-Ethernet0/0/1]port link-type acc [SW1-Ethernet0/0/1]port def vlan 1 配置eth-trunk 链路聚合 拓扑图
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b92c5246419dbe331f1e50ad4f65cb8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15fd5f1a509a9e00af8706f6c4f1fadc/" rel="bookmark">
			Hadoop的启动和停止命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一，当我们遇到hadoop无法集群启动namenode或者Datanode的时候我们可以选择单个强制命令来分别启动他们 （1）单个启动namenode的指令如下
sbin/hadoop-daemon.sh start namenode
（2）单个启动Datanode的指令如下
sbin/hadoop-daemon.sh start datanode
注意：当我们在格式化之前一定要仔细检查我们之前配置的所有文件以及该主机的名字是否与我们配置的一样，从而避免后面格式化后集群启动会出现很多问题
二，hadoop三种集群启动方式 方式一：分开启动
start-dfs.sh start-yarn.sh
方式二：一起启动
start-all.sh(实际上是调用sbin/start-dfs.sh脚本和sbin/start-yarn.sh脚本)
方式三：逐一启动
hadoop-daemon.sh start|stop namenode |datanode
yarn-daemon.sh start |stop resourcemanager |nodemanager 三，hadoop 的启动和停止命令 sbin/start-dfs.sh 启动Hadoop HDFS守护进程 sbin/stop-dfs.sh 停止Hadoop HDFS守护进程 sbin /start/stop-all.sh 启动/停止所有的Hadoop守护进程
sbin/hadoop-daemons.sh start/stop namenode 单独启动/停止NameNode守护进程
sbin/yarn-daemon.sh start/stop resourcemanager 单独启动/停止ResourceManager
sbin/mr-jobhistory-daemon.sh start/ stop historyserver 手动启动/停止jobhistory
sbin/hadoop-daemons.sh start/stop datanode 单独启动/停止DataNode守护进程
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4862f3d7dbbfcabac59b3fc86515d027/" rel="bookmark">
			蜂鸣器应用之播放音乐（STC89C52RC为例）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		蜂鸣器原理 乐谱说明 #是升半音（右上角）
b为降半音
分为全音符，二分音符，四分音符。。。。
一般四分音符1为500ms，二分音符为1s=1000ms，数字下面加一根线是250ms
以四分音符为一拍，每小节有4拍
右边加一个点，相当于加上半拍
这左上角有个符号，表示需要按下右上角的升音键（#）黑键
上面这条线叫做延音线
C调音符与频率对照表 以a为基准频率是440Hz，左右两边都是倍数关系，中间是按照等比数列进行平分
，
以上一个为基准，然后按照这个公式算出结果（满足：12频分率）
算出周期(s)
因为一个周期是需要上去，再下来
然后就可以算出重装载值
完整代码（蜂鸣器播放提示音） //main.c #include &lt;REGX52.H&gt; #include "Key.h" #include "Delay.h" #include "Nixie.h" #include "Buzzer.h" unsigned char KeyNum; void main() { while(1){ KeyNum=Key(); if(KeyNum) { Buzzer_Time(1000); Nixie(1,KeyNum); } } } //Key.c #include &lt;REGX52.H&gt; #include "Delay.h" /** * @brief 获取独立按键码 * @param 无 * @retval 按下按键的键码，范围:0~4,无按键按下时返回值为0 */ unsigned char Key() { unsigned char KeyNumber=0; if(P3_1==0){Delay(20);while(P3_1==0);Delay(20);KeyNumber=1;} if(P3_0==0){Delay(20);while(P3_0==0);Delay(20);KeyNumber=2;} if(P3_2==0){Delay(20);while(P3_2==0);Delay(20);KeyNumber=3;} if(P3_3==0){Delay(20);while(P3_3==0);Delay(20);KeyNumber=4;} return KeyNumber; } //key.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4862f3d7dbbfcabac59b3fc86515d027/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10d2f18b466586f0b18530be567fc2fd/" rel="bookmark">
			【Java】Spring中事务的隔离级别和事务的传播机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring 中事务的实现编程式事务声明式事务@Transactional的作用范围@Transactional的参数注意事项 事务隔离级别MySQL的事务隔离级别Spring中事务的隔离级别 Spring事务传播机制事务传播机制有哪些Spring 事务传播机制使用和各种场景演示支持当前事务：REQUIRED不支持当前事务：REQUIRES_NEW不支持当前事务：NEVER 抛异常NESTED 嵌套事务嵌套事务和加入事务的区别 Spring 中事务的实现 Spring 中的事务操作分为两类：
编程式事务（手动写代码操作事务）声明式事务（利用注解自动开启和提交事务） 编程式事务 Spring 手动操作事务和MySQL 操作事务类似，它也是有 3 个重要操作步骤：
– 开启事务 start transaction;
//业务执行
– 提交事务 commit;
– 回滚事务 rollback;
SpringBoot 内置了两个对象，DataSourceTransactionManager 用来获取事务（开启事务）、提交或回滚事务的，而TransactionDefinition 是事务的属性，在获取事务的时候需要将TransactionDefinition 传递进去从而获得⼀个事务transaction。
@Slf4j @RequestMapping("/trans") @RestController public class TransactionController { @Autowired private UserService userService; //数据库的事务管理器 @Autowired private DataSourceTransactionManager dataSourceTransactionManager; private TransactionDefinition transactionDefinition; @RequestMapping("/addUser") public Integer addUser(String username,String password){ TransactionStatus transaction = dataSourceTransactionManager.getTransaction(transactionDefinition); User user = new User(username,password); Integer result = userService.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/10d2f18b466586f0b18530be567fc2fd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca479953f5e901372e9696527e415a7d/" rel="bookmark">
			python经典百题之画椭圆
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		程序分析 题目要求学习如何使用Python绘制椭圆（ellipse）。椭圆是一个常见的几何形状，可以通过数学表达式或绘图库来绘制。我们可以使用多种方法来实现这个任务，包括使用数学方程、绘图库等。
解题思路 我们可以使用三种不同的方法来实现绘制椭圆：
使用数学方程绘制椭圆：
使用椭圆的参数方程来计算椭圆上的点，并绘制。 使用绘图库绘制椭圆：
使用Python绘图库（如matplotlib）提供的椭圆绘制函数来绘制椭圆。 使用图像处理库绘制椭圆：
使用图像处理库（如PIL或OpenCV）来绘制椭圆。 1. 使用数学方程绘制椭圆 解题思路 椭圆的标准参数方程是：
[ x = a \cdot \cos(\theta) ]
[ y = b \cdot \sin(\theta) ]
其中，( a ) 和 ( b ) 是椭圆的长半轴和短半轴，( \theta ) 是角度。
我们可以在给定范围内选择 ( \theta )，然后计算对应的 ( x ) 和 ( y ) 坐标，从而绘制椭圆。
代码实现 import numpy as np import matplotlib.pyplot as plt def plot_ellipse(a, b): theta = np.linspace(0, 2 * np.pi, 1000) x = a * np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca479953f5e901372e9696527e415a7d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8033412f78ea1824c7681de317e3de45/" rel="bookmark">
			c&#43;&#43;【基础】动物简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		时间限制: 1.000 Sec 内存限制: 64 MB 题目描述 到了动物园，琦琦开心得跳起来。哗，这里好多动物呀，有老虎，有狮子……
在开心之余，琦琦也不忘妈妈的教导：观察动物时要认真仔细，还要看动物园除上的动物简介呀。
动物的简介原来还有英文版的呢！
为了卖弄自己的英文水平，琦琦就告诉妈妈每张动物简介里出现了多少次该动物的名称。
注意：琦琦只认识小写字母，而且只要是某部分连续的字母同动物名称完全一样，她就会认为这就是那动物的名称。
因此当简介中同时出现了monkeys、smonkey、smonkeys时，她就会说出现了3个猴子的名称。
你能编程完成琦琦的任务吗？
输入 共n+2行：
第1行为数字n（n&lt;=3000），表示该动物的简介共有n行。
第2行为一个单词，表示琦琦认识的动物名称。
接着是n行，每行为一个长度小于250个字符的字符串，表示动物的简介。
输出 共1行，为简介里出现了多少次琦琦能识别出的动物的单词。
样例 输入1 1 monkey She often jumps onto my knees. I like to give her a bath.
输出1 0
输入2 2 snake The snake is a long and thin animal. Snakes have no legs or feet.
输出2 1
输入3
3 bee ebe ebe eeb eeb eeb eebeebee
输出3
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8033412f78ea1824c7681de317e3de45/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c6b9e6fe9d4990f7eb5d4f6b9480669/" rel="bookmark">
			datax源码原理分析&amp;分布式 datax 架构设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 背景 DataX 是一个异构数据源离线同步工具，致力于实现包括关系型数据库(MySQL、Oracle 等)、HDFS、Hive、ODPS、HBase、FTP 等各种异构数据源之间稳定高效的数据同步功能。解决异构数据源同步问题，DataX 将复杂的网状的同步链路变成了星型数据链路，DataX 作为中间传输载体负责连接各种数据源。当需要接入一个新的数据源的时候，只需要将此数据源对接到 DataX，便能跟已有的数据源做到无缝数据同步。
分布式 DataX 基于 datax 开发的，支持分片分布式调度，分片容错，节点发现，增大数据交换吞吐，高可用，使用场景是线下一次性大规模数据同步*
*另一平台，云 datax 用于定时增量同步
2. 参考和术语 ETL 英文 Extract-Transform-Load 的缩写，用来描述将数据从来源端经过抽取（extract）、转换（transform）、加载（load）至目的端的过程
类热加载 利用自定义类加载器动态载入类，减少 metaspace 使用，减少进程启动时间，支持新类热载入
3. datax 规划 分两大平台，分布式 datax 和云 datax
分布式 datax 用于一次性大规模数据同步
云 datax paas 平台，用于周期性的增量同步, 小规模数据
4. datax 原理介绍 *官方图，Transport 处是 Channel，本人觉得不太准确，应为 Transport
&gt; 作业分解为任务，任务分组，最后调度器调度任务(组)
*作业分片和任务分组没有在高可用中
&gt; 调度器负责分派资源执行任务(组)，TaskEecutor 执行任务
&gt; transport 包括数据交换(exchanger)，转换(transformer)，交换数据字节数/记录(record)数的统计(channel)
5. datax 源码分析 原理源码分析点
5.1 配置组件 DataX 配置组件 Configuration 实质是 json 封装，用 path 获取 json 中的配置属性，与 spring boot 不同，spring boot 配置负责实例构建和初始化对象，DataX 的配置只是配置属性容器，对象获取 Configuration，使用 path 从中取出配置自身属性自行初始化
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c6b9e6fe9d4990f7eb5d4f6b9480669/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35df149bcd9e2668ad399a75e89f0435/" rel="bookmark">
			分享一个docker无法启动的小问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		准备看看docker服务怎么样
[root@localhost ~]# docker ps Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running? 这一看就是docker的进程崩了，我们启动下进程
[root@localhost ~]# systemctl start docker Failed to start docker.service: Unit is not loaded properly: Bad message. See system logs and 'systemctl status docker.service' for details. 启动不了，我们运行下 systemctl status docker.service 看看报错
[root@localhost ~]# systemctl status docker.service ● docker.service Loaded: error (Reason: Bad message) Active: inactive (dead) Sep 16 08:32:02 localhost.localdomain systemd[1]: [/usr/lib/systemd/system/docker.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/35df149bcd9e2668ad399a75e89f0435/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13448de5ac3156e305eee746891edcbe/" rel="bookmark">
			python实现科学计算器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 作业班级作业要求项目源码地址作业目标作业过程界面以及功能展示P2P表格解题思路描述问题1问题2问题3 核心代码展示接口设计与实现过程1. 用户界面设计：2. 按钮事件处理：3. 数学表达式计算：4. 错误处理：5. 用户体验和界面优化： 程序性能改进单元测试单元测试单元测试部分代码 异常处理心路历程和收获 作业班级 班级链接
作业要求 作业链接
项目源码地址 github地址
作业目标 通过GUI实现一个具有可视化界面的科学计算器
作业过程 界面以及功能展示 P2P表格 P2PPersonal Software Process Stages预估耗时（分钟）实际耗时（分钟）Planning计划3030• Estimate:• 估计这个任务需要多少时间55Development开发580480• Analysis• 需求分析 (包括学习新技术）6030• Design Spec• 生成设计文档1515• Design Review• 设计复审1515• Coding Standard:• 代码规范 (为目前的开发制定合适的规范)1010• Design• 具体设计3030• Coding• 具体编码100100• Code Review:• 代码复审2520• Test• 测试（自我测试，修改代码，提交修改）3020Reporting报告6040• Test Repor:• 测试报告:55:• Size Measurement• 计算工作量1010• Postmortem &amp; Process Improvement Plan• 事后总结, 并提出过程改进计划1010合计985820 解题思路描述 个人对python语言比较熟悉，所以这次作业采用python语言来进行编写科学计算器，在作业过程中主要问题如下，本次使用了第三方库PyQt5，运行前请先在终端运行
pip install PyQt5 -i http://mirrors.aliyun.com/pypi/simple/ --trusted-host mirrors.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13448de5ac3156e305eee746891edcbe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/446b7cf10b0e6d53d41b641b5b59895d/" rel="bookmark">
			wsl2迁移与恢复
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		wsl2迁移与恢复 wsl2迁移与恢复wsl2迁移重装系统恢复旧版wsl2 wsl2迁移与恢复 此处记录一下wsl2的迁移，以及当在系统C盘重置系统如何恢复旧版wsl2
wsl2迁移 这个是建立在已经安装wsl2的基础之上
1.查看当前wsl下的Linux是否为关闭状态，当state为Stopped才能进行下一步。
wsl -l -v 若state为Running时，利用下面的命令结束
wsl --shutdown 2.以.tar的形式导出到其他盘
wsl --export Ubuntu-20.04 e:\Ubuntu-20.04.tar 【注】此处导出的Ubuntu-20.04.tar文件可以作为备份文件，下次恢复时直接执行第4步的导入系统就行
3.注销原有的linux系统
wsl --unregister Ubuntu-20.04 4.导入系统
wsl --import Ubuntu-20.04 E:\ubuntu2004 E:\Ubuntu-20.04.tar 5.修改默认用户（因为不修改用户名，打开wsl ubuntu之后，默认以root身份登录。）
ubuntu.exe config --default-user &lt;--用户名--&gt; 用户名是原有wsl ubuntu的用户名称。
重装系统恢复旧版wsl2 此处是针对重置系统盘，同时旧版wsl2已经迁移到其他盘，如何恢复旧版wsl2
1.先重新安装一个新的wsl2，这个可以参照网上的wsl2安装教程，注意安装的Ubuntu的版本要和旧版的Ubuntu版本（即你想恢复的Ubuntu）一致
2.当安装wsl2成功后，此时wsl2默认安装在系统C盘，然后按照上面的wsl2迁移步骤把wsl2迁移到其他盘
3.迁移成功后，把新版的ext4.vhdx删除，拷贝成旧版的ext4.vhdx
4.启动wsl2，即可恢复旧版wsl2
【注】一定要把新版的ext4.vhdx删除，不能用旧版的去替换新版的ext4.vhdx（即如下图操作是不能恢复到旧版），否则替换成功后，当你启动wsl2会发现还是新版的Ubuntu。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6657b74696a02a3d0ff0cfcba63c6660/" rel="bookmark">
			JavaScript基础语法和知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JavaScript基础语法和知识 个人学习笔记
学习地址：JavaScript前端课程-dom-bom-js-es6新语法-jQuery-数据可视化echarts黑马pink老师前端入门基础视频教程(500多集)持续_哔哩哔哩_bilibili配套资料： 链接：https://pan.baidu.com/s/1KotiABx0CCj-X5kAdxG9yg提取码：aq9n P1 注意：
变量 var不确认数据类型，只有在赋值时候才确定js是动态语言，变量的数据类型是可以变化的进制 数字前面加0 表示八进制数字的前面加 0x 表示十六进制 字符串型 嵌套：外双内单，外单内双转义字符：要写到引号里面，eg. \t缩进（tab）,\b空格拼接：用+，字符串和其他类型拼接最终结果是字符串布尔型和数字型相加的时候，true 的值为 1 ，false 的值为 0使用表单、prompt 获取过来的数据默认是字符串类型的 类型转换 数字转成字符串型：console.log(num + '');//+空字符串字符型转成数字型： parseInt:取整，去掉px单位console.log(parseInt('3.14')); // 3 取整parseFloat：不取整，去掉px单位console.log(parseFloat('3.14')); // 3.14Number( )、隐式转换（-、 *、/） 其他类型转化为布尔值：(Boolean()，代表空、否定的值会被转换为 false ，如 ‘’、0、NaN、null、undefined，其他true console.log(Boolean('')); 常用：
console.log(num)：控制台输出一个变量num，eg. console.log(isNaN(12)); // false， console.log(str.length); //字符串长度,console.log(typeof num)alert()：弹出 eg.1 提示输入并弹出输入内容var age = prompt('请输入您的年龄'); //这是字符型 var str = '您今年已经' + age + '岁了'; alert(str); P2 运算符 2个浮点数相加有精度问题var result = 0.1 + 0.2; // 结果不是 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6657b74696a02a3d0ff0cfcba63c6660/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/166001a110595ae6eb641515046e5bfc/" rel="bookmark">
			大语言模型之十三 LLama2中文推理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在《大语言模型之十二 SentencePiece扩充LLama2中文词汇》一文中已经扩充好了中文词汇表，接下来就是使用整理的中文语料对模型进行预训练了。这里先跳过预训练环节。先试用已经训练好的模型，看看如何推理。
合并模型 这一步骤会合并LoRA权重，生成全量模型权重。此处可以选择输出PyTorch版本权重（.pth文件）或者输出HuggingFace版本权重（.bin文件）。执行以下命令：
$ python scripts/merge_llama2_with_chinese_lora_low_mem.py \ --base_model path_to_original_llama2_hf_dir \ --lora_model path_to_chinese_llama2_or_alpaca2_lora \ --output_type huggingface \ --output_dir path_to_output_dir 参数说明：
–base_model：存放HF格式的Llama-2模型权重和配置文件的目录，这可以在《大语言模型之十二 SentencePiece扩充LLama2中文词汇》的1.下载原版LLama-2模型小节找到如何将原始meta的LlaMA-2模型转为Huggingface的格式。–lora_model：中文LLaMA-2/Alpaca-2 LoRA解压后文件所在目录，也可使用🤗Model Hub模型调用名称（会自动下载），这里使用Chinese-LLaMA-Alpaca-2给出的预训练好的7B模型。–output_type：指定输出格式，可为pth或huggingface。若不指定，默认为huggingface–output_dir：指定保存全量模型权重的目录，默认为./（可选）–verbose：显示合并过程中的详细信息
转换好格式之后，内容如下（时间戳为11：28的即为转换生成文件)：
其中的ggml开头的事量化文件是用于模型推理。 推理 在attn_and_long_ctx_patches.py实现了基于NTK的自适应上下文适配方法，其中基于transformers的推理脚本。
当上下文小于4K时，默认关闭，因为原生的效果更好大于4K时开启NTK，AUTO_COEFF默认为1.0
以下是不同AUTO_COEFF下，在不同上下文长度上的PPL变化（越低越好），供使用参考。
对NTK方法熟悉的用户可直接修改代码中的ALPHA取值。12K以下：几乎和原生4K的PPL没有显著差异12K-16K：开始存在一定损失，大约是3比特量化级别的效果18K+：存在较大损失，大约是2比特量化级别效果，20K+不可用
以上结果仅供参考，应在实际场景中测试调整AUTO_COEFF或者ALPHA取值。 使用llama.cpp推理 Step 1: 克隆和编译llama.cpp
（可选）如果已下载旧版仓库，建议git pull拉取最新代码，并执行make clean进行清理拉取最新版llama.cpp仓库代码 $ git clone https://github.com/ggerganov/llama.cpp 对llama.cpp项目进行编译，生成./main（用于推理）和./quantize（用于量化）二进制文件。 $ make Step 2: 生成量化版本模型
目前llama.cpp已支持.pth文件以及huggingface格式.bin的转换。将完整模型权重转换为GGML的FP16格式，生成文件路径为zh-models/7B/ggml-model-f16.gguf。进一步对FP16模型进行4-bit量化，生成量化模型文件路径为zh-models/7B/ggml-model-q4_0.gguf。不同量化方法的性能对比见本Wiki最后部分。
python3 convert.py ../merged_chinese_llama_7b $ ./quantize ../merged_chinese_llama_7b/ggml-model-f16.gguf ../merged_chinese_llama_7b/ggml-model-q4_0.gguf q4_0 Step 3: 加载并启动模型
llama.cpp git:(master) ✗ ./main -s 1 -m ../merged_chinese_llama_7b/ggml-model-q4_0.gguf -p "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/166001a110595ae6eb641515046e5bfc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/023ce330f0936b58746e28be50c90ecf/" rel="bookmark">
			Python库: keyword
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import keyword
print(keyword.kwlist)
可以打印出python中的关键词
这些关键词不能作为变量名。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e424f13cb9e7394cfffb6fd6c232f5d1/" rel="bookmark">
			材料力学-剪力和弯矩方向规定及关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		剪力和弯矩的方向规定方法 对水平梁的某一指定截面来说，
剪力：在它左侧的向上外力，或右侧的向下外力，将产生正的剪力；反之，即产生负的剪力。 自己的记法（可以不按我的来）：取左侧来算剪力向下为正，取右侧来算剪力为上为正，如果取一段来看，剪力为正，剪力这时候应该是顺时针方向。
弯矩，则无论在指定截面的左侧或右侧，向上的外力产生正的弯矩，向下的外力产生负的弯矩。 正负方向怎么用？我们要知道截面的剪力等于所选对象上的所有力的代数和，如果截面是在右边，左边的力向上为正，向下为负；如果截面是在左边，右边的力向上为负，向下为正。
同理的，对于弯矩，截面的弯矩等于所选对象上所有力矩的代数和，如果截面在右边，左边的力矩顺时针为正，逆时针为负。如果截面是在左边，右边的力矩逆时针为正，顺时针为负。
剪力和弯矩间的关系 力平衡和对C点的力矩平衡有：
Q ( x ) − [ Q ( x ) + d Q ( x ) ] + q ( x ) d x = 0 − M ( x ) + [ M ( x ) + d M ( x ) ] − Q ( x ) d x − q ( x ) d x ⋅ d x 2 = 0 \begin{aligned} &amp;Q(x)-[Q(x)+\mathrm{d} Q(x)]+q(x) \mathrm{d} x=0 \\ &amp;-M(x)+[M(x)+\mathrm{d} M(x)]-Q(x) \mathrm{d} x-q(x) \mathrm{d} x \cdot \frac{\mathrm{d} x}{2}=0 \end{aligned} ​Q(x)−[Q(x)+dQ(x)]+q(x)dx=0−M(x)+[M(x)+dM(x)]−Q(x)dx−q(x)dx⋅2dx​=0​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e424f13cb9e7394cfffb6fd6c232f5d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d03be7c3c75e156af5db37d9a7dce8b4/" rel="bookmark">
			Python函数：chr()和ord()
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		两个函数是基于Unicode编码表进行进行字符与字码之间的转换。
chr()函数是通过字码转换成字符:
如图,坐标(1,4e10)丑
使用chr需要线将坐标相加得到：4e11
chr默认传入10进制的字码.
如图是各进制的字码。
也可以传入其他进制，不过需要在前面传入的参数最前吗加入两字符来表示，多少进制。
0x十六进制
0o八进制
0b二进制
一个例子：
ord函数只需要传入一个字符即可：
默认输出十进制。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9cecd0ce0a0c55c79804428428617d59/" rel="bookmark">
			prebuilts/clang/host/linux-x86/clang-3289846/bin/clang.real: error while loading shared libraries:
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ubuntu 20.04编译android源码时遇到问题，解决
sudo apt install libncurses5 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f7cb1b9f771309db40840e3514d2d3d/" rel="bookmark">
			计算机组成与体系结构第2版习题答案补完计划赵姝陈洁主编第2章存储系统 - 安徽大学出版社
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写这些答案的目的，是不希望以后看这本破书的人有连答案都没有学不下去的那种绝望心情了，这些答案是我一题一题搜出来的，有些实在是搜不到就空出来了。
文档链接百度云：https://pan.baidu.com/s/1scN1pksEXL4kx-Wsh7vGfg?pwd=1111
2.简述Cache、主存、辅存三者之间的关系。 （Chat生成，看看就行）
解；
Cache（高速缓存）、主存（内存）和辅存（外存）是计算机系统中不同层次的存储器，它们之间有着紧密的关系。这些存储器层次被设计用来在性能和存储容量之间找到平衡。
1). Cache（高速缓存）：
Cache是位于CPU和主存之间的一层存储器，它的作用是缓存主存中的数据和指令，以提高访问速度。Cache存储了CPU经常访问的数据和指令，因此可以更快地满足CPU的访问需求。Cache分为多级（L1、L2、L3等）并具有不同容量和访问速度。Cache的存储速度远高于主存和辅存，但容量有限，因此它只能存储一部分主存中的数据。
2). 主存（内存）：
主存是计算机系统中的主要存储器，用于存储运行中的程序和数据。它具有较大的容量，但相对于Cache来说访问速度较慢。CPU需要从主存中获取指令和数据进行处理。主存的容量相对较大，但访问速度较慢，因此Cache的引入可以减少CPU访问主存的次数，提高系统性能。
3). 辅存（外存）：
辅存是指计算机系统中的外部存储介质，如硬盘、固态硬盘（SSD）等。辅存容量很大，但访问速度相对较慢。它用于永久性地存储程序、数据和文件，当程序不在运行时，数据可以被存储在辅存中，而不会丢失。
三者之间的关系：
Cache、主存和辅存形成了存储器层次结构，这种层次结构充分利用了不同存储器的特点来平衡性能和存储容量。当CPU需要数据或指令时，首先会在Cache中查找，如果找到了就可以更快地进行访问，如果Cache中没有需要的数据，则会从主存中获取。如果主存中也没有，则需要从辅存中加载数据到主存中，再由主存传递给CPU。这个过程中，数据从辅存到主存再到Cache的传递称为数据的“移动”或“传输”。
总之，Cache、主存和辅存之间的关系是在性能和存储容量之间寻求平衡，通过不同层次的存储器来提高计算机系统的整体性能。
3.简述Cache和虚拟存储器的区别与联系。 (1）Cache和虚拟存储器的实现是基于程序的局部性原理。
(2) Cache是为了解快CPU和主存之间的速度不匹配，功能由硬件实现，对各类程序员是透明的。(3)虚拟存储器是为了解决主存容量的不足，功能由软，硬件相结合实现，对设计存储管理软件的系统程序员是不透明的，对应用程序员是透明的。
解；
区别：
1). 定义和作用：
- Cache：Cache是位于CPU和主存之间的高速缓存存储器，用于存储CPU经常访问的数据和指令，以提高访问速度。
- 虚拟存储器：虚拟存储器是一种将主存和辅存结合使用的技术，它允许程序使用比主存更大的地址空间，将不常用的数据从主存移至辅存，从而扩展了可用的内存空间。
2). 存储容量：
- Cache：Cache的容量相对较小，一般只能存储主存中的一部分数据。
- 虚拟存储器：虚拟存储器允许程序使用比主存更大的地址空间，可以超出主存容量。
3). 目的：
- Cache：Cache的目标是提高CPU的访问速度，减少CPU等待主存的时间。
- 虚拟存储器：虚拟存储器的目标是扩展可用内存空间，使得程序可以使用更大的地址空间，而不受实际主存容量的限制。
联系：
1). 提高访问速度：Cache和虚拟存储器都是为了提高数据访问的速度。Cache通过缓存常用的数据和指令，减少CPU访问主存的次数。虚拟存储器通过将不常用的数据放在辅存中，使得主存中可以留出更多空间供常用数据使用。
2). 存储层次：Cache可以被看作是主存和CPU之间的一个高速缓存层次，而虚拟存储器则扩展了主存的可用空间，利用辅存作为备用存储。
3). 数据迁移：Cache中的数据可能会根据使用情况进行替换或迁移。虚拟存储器中的数据也会根据需要从辅存加载到主存，或者根据页面置换算法进行调度。
总的来说，Cache和虚拟存储器在存储器管理中有不同的角色和功能，但它们都是为了提高系统性能和可用内存空间而设计的技术。
4.主存储器的地址寄存器和数据寄存器各自的作用是什么？设有一个1MB 容量的存储器，字长为32位，问：
（1）按字节编址，地址寄存器和数据寄存器各几位？编址范围为多大？ （2）按字编址，地址寄存器和数据寄存器各几位？编址范围为多大？ 解；
在主存储器中，地址寄存器MAR用来存放当前CPU访问的内存单元地址，或者存放CPU写入内存的内存单元地址。数据寄存器MDR用来存放由内存中读出的信息，或者写入内存的信息。
（1）按字节编址，1MB=bit=×8位，地址寄存器为20位，数据寄存器为8位，编址范围为00000H～FFFFFH(FFFFFH-00000H+1=100000H=)。
（2）按字编址，1MB=bit=×32位，地址寄存器为18位，数据寄存器为32位，编址范围为00000H～3FFFFH(3FFFFH-00000H+1=40000H=)。
5.用64K×1位的DRAM芯片构成256K×8位的存储器，假定芯片内部只有一个位平面。回答以下问题： （1）所需芯片数是多少？ （2）采用异步刷新方式，如每单元刷新间隔不超过2ms，则刷新信号周期是多少？ （3）如采用集中刷新方式，存储器刷新一遍最少用多少读/写周期? 解；
（1）该存储器所需芯片数=(256K×8)/(64K×1)=32片。
（2）DRAM芯片的容量为64K×1位，由于芯片内部存储阵列只有一个位平面（即1位），则存储阵列的结构为256×256（2⁸×2⁸=2¹⁶=64K），则存储器刷新一遍至少需要256次刷新操作。若采用异步刷新方式，则相邻两次刷新的时间间隔为2ms/256≈7.8μs，所以，刷新信号周期应为7.8μs。
（3）在与（2）同样的假定条件下，若采用集中刷新方式，则存储器刷新一遍最少需要256个读/写周期，在这个过程中，存储器不能进行读写操作。
6.某16K×1位的DRAM存储芯片的读/写周期=0.1 μs,芯片的最大刷 新间隔不允许超过2ms（1ms=μs)，否则有可能丢失信息。问： （1）刷新周期是多少？将DRAM存储芯片刷新一遍需要多少个刷新周期？ （2）若采用分散刷新方式，则刷新信号周期是多少？ （3）若采用集中刷新方式，则将DRAM芯片刷新一遍需要多少时间？不能提 供读写服务的百分比是多少？ 解；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f7cb1b9f771309db40840e3514d2d3d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ead11ee39e7c18a858403edb219860eb/" rel="bookmark">
			前端如何简单的防止xss攻击
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		工具js:
// xss跨站脚本防御机制 export function xssdefense(str) { // Javascript script src img { } ( ) &lt; &gt; = , . ; : " ‘ # ! / * \ ` // str = str.replace(/&lt;/g, '&amp;lt;') // str = str.replace(/&gt;/g, '&amp;gt;') // str = str.replace(/"/g, '&amp;quot;') const map = { // '&amp;': '&amp;amp;', '&lt;': '&amp;lt;', '&gt;': '&amp;gt;', '"': '&amp;quot;', "'": '&amp;#039;' }; str = str.replace(/[&amp;&lt;&gt;"']/g, function(m) { return map[m] ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ead11ee39e7c18a858403edb219860eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ee7d274f1d38ff3f6d1f30f4c8cff6e/" rel="bookmark">
			keepalived安装部署-主备节点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、**`keepalived.conf`配置文件说明**环境主节点一、安装部署二、配置文件查看当前要指定虚IP的网卡三、启动四、查看是否创建成功 [备节点]一、安装部署二、配置文件查看当前要指定虚IP的网卡三、启动四、查看是否创建成功 **`常见问题`**1 VRID 问题2 虚拟IP 无法ping通 vrrp_script详解1、vrrp_script能做什么2、优先级更新策略3、vrrp_script中节点权重改变算法3.1、不设置weight3.2、设置weight4、配置不抢占nopreempt带来的问题 一、keepalived.conf配置文件说明 ! Configuration File for keepalived # 第一部分： 全局块 global_defs { # 接收邮件的邮箱列表 notification_email { 123@163.com } # 指定发件人 notification_email_from eric@qq.com # 添加邮件服务器地址 smtp_server smtp.exmail.qq.com # 设置邮件服务器连接超时时长 smtp_connect_timeout 30 # 每个keepalived节点的唯一标识，建议设置为当前主机名，多个节点重名时是不受影响的,用于邮件通知； router_id keepalived126 # keepalived会以对所有通告报文检查，比较消耗性能，启用此配置后，如果收到的通告报文和上一个是同一个路由器则跳过检查，默认值为全检查 vrrp_skip_check_adv_addr # 可设置ARP接口之间发送免费报文的延迟时间，可以精确到毫秒，默认是0 vrrp_garp_interval 0 # 设置非请求消息的发送延迟时间，默认为0 vrrp_gna_interval 0 # 表示严格遵守VRRP协议，启用此项后以下状况将无法启动服务—— # a. 未设置VIP地址 # b. 配置了单播邻居 # c. 在VRRP的2版本中带有IPV6地址，如果开启了此项后没有设置vrrp_iptables则会自动开启iptables防火墙规则，导致VIP地址无法访问，建议不加此项 vrrp_strict # 与vrrp_strict同时设置时可禁止iptables规则的生成，注释或者无vrrp_strict时可不加此项 vrrp_iptables # 可指定组播IP范围，可选择224.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ee7d274f1d38ff3f6d1f30f4c8cff6e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb0e9fe9fec481babd84a25f60e03a08/" rel="bookmark">
			from rasterio. _base import gdal_version, DLL load failed: 找不到指定的模块”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题1：python 3.9下，导入rasterio和gdal出现错误。from rasterio. _base import gdal_version, DLL load failed: 找不到指定的模块”
解决办法：直接在pycharm中安装gdal==3.4.3，rasterio==1.3.8, rioxarray==0.15.0, xarray==2023.8.0.
问题2：in rasterio.crs.CRS.from_user_input rasterio.errors.CRSError: CRS is invalid
resampled_data = data2.rio.reproject("epsg:4326", resolution=[0.1, 0.1]) 问题3：reproject
raise MissingCRS(
rioxarray.exceptions.MissingCRS: CRS not found. Please set the CRS with 'rio.write_crs()'. Data variable
def set_crs(data): data.rio.write_crs("EPSG:4326", inplace=True) #要点，要加inplace=True set_crs(data2) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25ec5c7bf8e74298539bc90f66483af2/" rel="bookmark">
			前端配置完跨域之后，nginx配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前端跨域配置： 对应nginx配置： 打开 Nginx 的配置文件，通常位于 /etc/nginx/nginx.conf 或 /etc/nginx/conf.d/default.conf。
因为生产上的接口地址没有monitor这个字符串，但是nginx的转发会携带上monitor这个字段。所以上线后的接口路径都携带了monitor报的都是404，这个地方需要把monitor进行重写，重写成空，这样最后访问的地址不会携带monitor这个字段。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15ff9742a3a29c8773e0db47148b9cfb/" rel="bookmark">
			Zotero连续翻译设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需要个人申请秘钥，详情请见
https://zotero.yuque.com/staff-gkhviy/pdf-trans
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e490bf3deaba0e0520ee48df59034f03/" rel="bookmark">
			C&#43;&#43;全排列函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 直接看样例 // /* C++ STL 全排列函数详解 https://www.cnblogs.com/aiguona/p/7304945.html*/ #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; int main() { int arr[] = {3, 2, 1}; cout &lt;&lt; "用prev_permutation对3 2 1的全排列" &lt;&lt; endl; do { cout &lt;&lt; arr[0] &lt;&lt; ' ' &lt;&lt; arr[1] &lt;&lt; ' ' &lt;&lt; arr[2] &lt;&lt; '\n'; } while (prev_permutation(arr, arr + 3)); /// 获取上一个较大字典序排列，如果3改为2，只对前两个数全排列 int arr1[] = {1, 2, 3}; cout &lt;&lt; "用next_permutation对1 2 3的全排列" &lt;&lt; endl; do { cout &lt;&lt; arr1[0] &lt;&lt; ' ' &lt;&lt; arr1[1] &lt;&lt; ' ' &lt;&lt; arr1[2] &lt;&lt; '\n'; } while (next_permutation(arr1, arr1 + 3)); /// 获取下一个较大字典序排列，如果3改为2，只对前两个数全排列 //注意数组顺序，必要时要对数组先进行排序 return 0; } 运行输出 用prev_permutation对3 2 1的全排列 3 2 1 3 1 2 2 3 1 2 1 3 1 3 2 1 2 3 用next_permutation对1 2 3的全排列 1 2 3 1 3 2 2 1 3 2 3 1 3 1 2 3 2 1 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6b553d4849b822f274da84835ffc811/" rel="bookmark">
			dataGrip导出导入的方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		导出：选中需要导出的表
导入：选中导出的sql文件
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c0bdf0e55d74c47c6825878dc7e6eb9/" rel="bookmark">
			Android10 LocationListener的onStatusChanged被废弃
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Android10 LocationListener的onStatusChanged被废弃，此回调永远不会在Android Q及以上版本上调用，提供商可以被视为始终处于LocationProvider#AVAILABLE状态。
LocationListener | Android Developers
有以下解决方案：
① 使用LocationListenerCompat（设备必须搭载GMS）
② 使用高德sdk、百度sdk或第三方
但是有的项目，这些条件都不满足，这就导致，这个API被废弃，在GPS信号不好的地方，回调不了任何方法来让应用知道GPS信号不佳来进行响应的逻辑处理，本篇文章着重于解决这个问题。
1、创建请求位置的接口
public interface LocationChangeListener { void onLocationChanged(double latitude, double longitude); default void onProviderEnabled(String provider) {} default void onProviderDisabled(String provider) {} default void onStatusChanged(String provider, int status, Bundle extras) {} } 2、创建GpsLocationManager
public class GpsLocationManager { private static final String TAG = GpsLocationManager.class.getSimpleName(); private final LocationManager mLocationManager; private LocationChangeListener mLocationChangeListener; private LocationChangedListener mLocationChangedListener; public static SpUtils mGPSSpUtils = null; public void setLocationChangeListener(LocationChangeListener listener) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c0bdf0e55d74c47c6825878dc7e6eb9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1561f1dfcd7c2e7dcce933eec68a5c87/" rel="bookmark">
			使用注解的方式解决json数据类型不一致
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用高德的接口去获取城市信息的数据时，需要使用gson将传入的json转换成java bean，bean的属性的数据类型是唯一的。但是实际在解析json的时候，有的数据：有数据时是传入的是string类型，没有数据的时候，传入的是[]（list类型）；或者是有数据是[]（list类型），没有数据的时候，传入的是[[]]（object类型）。通常在解析的时候，会抛出异常。
09-26 18:29:58.735 2834 4082 W System.err: com.google.gson.JsonSyntaxException: java.lang.IllegalStateException: Expected a string but was BEGIN_ARRAY at line 1 column 225 path $.data.city.addressComponent.streetNumber.number 09-26 18:29:58.735 2834 4082 W System.err: at com.google.gson.internal.bind.ReflectiveTypeAdapterFactory$Adapter.read(ReflectiveTypeAdapterFactory.java:226) 09-26 18:29:58.735 2834 4082 W System.err: at com.google.gson.internal.bind.ReflectiveTypeAdapterFactory$1.read(ReflectiveTypeAdapterFactory.java:131) 09-26 18:29:58.735 2834 4082 W System.err: at com.google.gson.internal.bind.ReflectiveTypeAdapterFactory$Adapter.read(ReflectiveTypeAdapterFactory.java:222) 09-26 18:29:58.735 2834 4082 W System.err: at com.google.gson.internal.bind.ReflectiveTypeAdapterFactory$1.read(ReflectiveTypeAdapterFactory.java:131) 09-26 18:29:58.735 2834 4082 W System.err: at com.google.gson.internal.bind.ReflectiveTypeAdapterFactory$Adapter.read(ReflectiveTypeAdapterFactory.java:222) 09-26 18:29:58.735 2834 4082 W System.err: at com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1561f1dfcd7c2e7dcce933eec68a5c87/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a5f0358e3b995ac125403a8a477c224/" rel="bookmark">
			[转]Mybatis中实现批量更新的几种姿势，总有一款适合你
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Mybatis中实现批量更新的几种姿势，总有一款适合你 一、概述 mybatis中实现批量插入是很简单的，相比大家都知道，这里就不赘述，本文主要讲述如何实现批量更新。
下面介绍本文要讲的几种方式主要是在xml中实现，不包含需要改动代码逻辑的方法，这里，除了网上说的普通情况，还有适合mysql和oracle的批量更新方式： 1. case when 2. foreach成多条sql 3. ON DUPLICATE KEY UPDATE （mysql） 4. replace into （mysql）
这次，我要讲的就是这四种方式。
二、case when 这种方式实现的批量更新操作效率很低，而且，当更新的字段很多时，SQL语句会特别长。
&lt;update id="updateBatch"&gt; update t_calendar_extend &lt;trim prefix="set" suffixOverrides=","&gt; &lt;trim prefix="modify_time = case index" suffix="end,"&gt; &lt;foreach collection="list" item="item"&gt; when #{item.index} then #{item.modifyTime} &lt;/foreach&gt; &lt;/trim&gt; &lt;trim prefix="user_type = case index" suffix="end"&gt; &lt;foreach collection="list" item="item"&gt; when #{item.index} then #{item.type} &lt;/foreach&gt; &lt;/trim&gt; &lt;/trim&gt; &lt;where&gt; index in ( &lt;foreach collection="list" separator="," item="item"&gt; #{item.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a5f0358e3b995ac125403a8a477c224/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b64a6bc371ad789c48e3e9a5e663c8af/" rel="bookmark">
			SpringSecurity面试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题1：什么是Spring Security？
答案： Spring Security是一个基于Spring框架的安全性框架，用于处理身份验证（Authentication）和授权（Authorization）。它提供了一套强大的安全性功能，用于保护应用程序的资源，如URL、方法调用、页面等。Spring Security可以用于构建安全的Web应用程序和REST API。
问题2：Spring Security中的核心概念是什么？
答案： Spring Security中的核心概念包括：
认证（Authentication）： 确定用户的身份，通常需要用户名和密码。授权（Authorization）： 确定用户是否有权访问某个资源或执行某个操作。用户主体（Principal）： 表示已认证的用户，通常是一个包含用户名和角色的对象。角色（Role）： 定义了用户的权限级别，通常与访问控制相关。访问控制（Access Control）： 定义了谁可以访问应用程序的哪些资源和操作。 问题3：Spring Security如何处理身份验证？
答案： Spring Security使用AuthenticationManager来处理身份验证。通常，开发人员配置一个或多个AuthenticationProvider，每个提供者用于不同类型的身份验证，例如基于用户名密码、LDAP、OAuth等。当用户尝试登录时，Spring Security会选择合适的提供者来验证用户的身份。
问题4：Spring Security中的密码加密是如何处理的？
答案： Spring Security鼓励将密码存储为哈希值，以增加安全性。它提供了多种密码编码器（如BCryptPasswordEncoder、PasswordEncoder等）来对密码进行哈希处理。开发人员通常配置一个适当的密码编码器，并在用户进行身份验证时使用它来验证用户提供的密码。
问题5：如何配置Spring Security以保护Web应用程序的URL？
答案： Spring Security通过配置SecurityConfigurer来保护Web应用程序的URL。开发人员可以定义URL模式、角色要求和其他访问控制规则。例如，可以使用.antMatchers()方法定义URL模式，并使用.hasRole()或.hasAuthority()方法指定角色要求。
问题6：Spring Security如何处理跨站请求伪造（CSRF）攻击？
答案： Spring Security提供了内置的CSRF保护。它通过在每个表单中生成CSRF令牌（也称为同步令牌）来防止CSRF攻击。当用户提交表单时，Spring Security会验证令牌的有效性，只有有效令牌的请求才会被处理。
问题7：Spring Security支持哪些身份验证方式？
答案： Spring Security支持多种身份验证方式，包括：
基于用户名和密码的表单登录。基于LDAP的身份验证。基于OAuth的身份验证和授权。基于记住我功能的身份验证。基于OpenID Connect的身份验证。自定义身份验证提供者。 问题8：如何自定义Spring Security的配置？
答案： 可以通过扩展SecurityConfigurerAdapter类来自定义Spring Security的配置。开发人员可以在这个类中覆盖configure()方法，以定义自定义的安全配置规则。还可以通过实现UserDetailsService接口来提供自定义的用户详细信息服务。
问题9：什么是Spring Security的过滤器链（Filter Chain）？
答案： Spring Security的过滤器链是一组安全过滤器，它们按顺序处理每个HTTP请求。每个过滤器执行特定的安全任务，如身份验证、授权、CSRF保护等。过滤器链的配置可以通过SecurityConfigurer来定义，以满足应用程序的特定安全需求。
问题10：什么是Spring Security的会话管理？
答案： Spring Security提供了会话管理功能，用于管理用户的会话状态。它可以配置会话超时时间、会话固定失效策略、最大并发会话数等。会话管理还支持分布式会话，以便在多个服务器上共享会话状态。
问题11：如何实现自定义的用户认证（Authentication）流程？
答案： 可以通过创建自定义的AuthenticationProvider来实现自定义的用户认证流程。该提供者需要实现authenticate()方法来执行认证逻辑，并返回一个包含用户详细信息和授权信息的Authentication对象。
问题12：什么是Spring Security的方法级安全性？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b64a6bc371ad789c48e3e9a5e663c8af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1a3933167b59cb90fb9cf2401d38fb0/" rel="bookmark">
			Nginx反向代理和负载均衡的配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在nginx.conf或conf.d/default.conf文件中进行配置
upstream name{ server 127.0.0.1:8080 weight=1; server 127.0.0.1:8081 weight=1; } server { listen 80; server_name localhost; location /path/ { proxy_pass http://name; } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f74f432680aee669e29d25fac0ee599/" rel="bookmark">
			STM32CubeIDE——CAN中断接收、阻塞发送
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、CAN模块配置流程
1.1 图形化界面设置can的波特率和相关工作模式
1.2 代码设置can的滤波器和中断
二、代码详解
2.1 CAN信息发送函数
2.2 CAN信息接收函数
2.3 main()函数
2.4 CAN接收回调函数
三、 总结
硬件条件：带有CAN总线接口的STM32开发板/工控板。
实现功能：
stm32轮询发送can信息（数据帧、标准帧）；stm32在中断回调中接收刚刚自己发出的can信息。 本文默认读者已经有了如下的基本知识和技能：
对can协议和stm32的bxCAN有了一定的了解，如Time Quantum、四种工作模式、过滤器及其配置参数的意义等；会在stm32cubeide中图形化配置芯片的调试串口、时钟和代码自动生成。 下面直接开始工程（工程中只讲述与can有关的地方）。
一、CAN模块配置流程 本文以STM32F103C8T6芯片为例。
STM32中CAN的配置分为两大部分：图形化界面设置can的波特率、相关工作模式和中断优先级；代码设置can的滤波器和使能FIFO中断。现具体讲述着两大部分。
1.1 图形化界面设置can的波特率和相关工作模式 首先，使能can模块；接着调整“Prescaler（for Time Quantum）”参数、“Time Quanta in Bit Segment 1”参数和“Time Quanta in Bit Segment 2”参数，使得波特率Baud Rate达到合适的值；然后在Operating Mode选项中选择回环模式（当然工作模式的选择要看具体应用了）；之后，“Parameter Settings”页面里剩下的其它参数，如果没有什么特殊需求的话，保持默认就可以了。见图1-1。 图1-1 5. 进入"NVIC Settings"中勾选RX0的中断使能，如图1-2；并在软件左侧NVIC栏里设置它的中断优先级，如图1-3。
图1-2 图1-3 6. 到这里，图形化页面里能配置的都配置完了。当然，can滤波器的配置还没有进行，这是在下一个部分里。
1.2 代码设置can的滤波器和中断 在软件自动生成的代码里找到can.c文件，这里面是工程对can配置的部分信息，与刚才图形化界面里我们的配置信息保持一致。
图个方便，我们直接在void MX_CAN_Init(void)函数里添加上滤波器的配置并使能对应的接收FIFO中断，如图1-3。这里别忘了在该函数外面定义需要的结构体变量！！！
图1-3 到此，can的配置全部OK。
现在只需要在main()里调用函数HAL_StatusTypeDef HAL_CAN_Start(CAN_HandleTypeDef *hcan)，就可以开启can使它工作了。
二、代码详解 2.1 CAN信息发送函数 要想can发送信息，需要用到函数：HAL_StatusTypeDef HAL_CAN_AddTxMessage(CAN_HandleTypeDef *hcan, CAN_TxHeaderTypeDef *pHeader, uint8_t aData[], uint32_t *pTxMailbox)，我在这里把它进行再封装一下，变得更好用：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f74f432680aee669e29d25fac0ee599/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc1d77e097d32d356a97f5a714fe2686/" rel="bookmark">
			STM32CubeMX与Keil联动——USART的中断收发（DMA版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、STM32CubeMX下的图形化配置
1、配置调试下载接口、时钟源接口
2、配置串口外设
3、配置时钟树
4、工程基本设置
5、生成代码工程
二、Keil下的代码编辑
1、编辑usart.c文件
2、编辑stm32f1xx_it.c文件
三、烧录运行，观察试验现象
功能说明：USART1和USART3启动中断收发并开启DMA，实现二者之间的互传数据。
一、STM32CubeMX下的图形化配置 本文以STM32F103ZET6为例。
1、配置调试下载接口、时钟源接口 开启Debug功能 开启外部时钟源​​​​​​ 2、配置串口外设 如图配置USART1（USART3外设一样，没区别）
开启异步收发功能 开启接收和发送的DMA功能 启用中断功能 3、配置时钟树 外部输入时钟频率与板卡上的晶振保持一致，依次打开图示的路径选项 4、工程基本设置 代码编辑工具设置为Keil 勾选这两个选项（只拷贝用到的外设的库文件、将代码分开成为.h和.c） 5、生成代码工程 二、Keil下的代码编辑 1、编辑usart.c文件 在USART1的初始化函数中加入如下两行代码（USRT3同理，注意参数的改变）
/* USART1 init function */ void MX_USART1_UART_Init(void) { /* USER CODE BEGIN USART1_Init 0 */ /* USER CODE END USART1_Init 0 */ /* USER CODE BEGIN USART1_Init 1 */ /* USER CODE END USART1_Init 1 */ huart1.Instance = USART1; huart1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fc1d77e097d32d356a97f5a714fe2686/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31a2ffc0c851bdaa692f1ec4aaddfd96/" rel="bookmark">
			STM32CubeIDE——USART中断收发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、工程配置
二、使用USART中断收发前必知的两个函数的作用
2.1 HAL_UART_Transmit_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
2.2 HAL_UART_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
三、代码详解
3.1 main()函数
3.2 两个回调函数
四、总结
硬件条件：带有两个usart外设（引脚空闲）的STM32开发板/工控板，用杜邦线把它俩正确的连起来。
实现功能：
stm32的usart1发送信息，发送完成后立即执行“发送完成”回调函数；stm32的usart2发送信息，发送完成后立即执行“发送完成”回调函数；stm32的usart1中断接收usart2发送的信息，接收完成后立即执行“接收完成”回调函数；stm32的usart2中断接收usart1发送的信息，接收完成后立即执行“接收完成”回调函数； 本文默认读者已经有了如下的基本知识和技能：
对stm32的usart或uart有一定的了解，包括波特率、时序信息等；会在stm32cubeide中图形化配置芯片的调试串口、时钟和代码自动生成。 下面直接开始工程（工程中只讲述与usart有关的地方）。
一、工程配置 本文以STM32F103C8T6芯片为例。
图形化界面中，usart1和usart2的配置如图1-1、图1-2所示。它们的中断优先级配置如图1-3所示。
到此，两个usart的配置全部结束了（代码中不再添加多余的配置代码）。
图1-1 图1-2 图1-3 二、使用USART中断收发前必知的两个函数的作用 2.1 HAL_UART_Transmit_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size) 用户在 main() 中轮询调用该函数；执行中：发送pData指针指向空间的信息+使能“发送寄存器空”中断；执行结束后：立即进入中断； 在中断里，先自动调用 UART_EndTransmit_IT(UART_HandleTypeDef *huart) 函数（该函数会失能“发送完成”中断。不过无所谓，可以不用在意）；中断里，之后再自动调用 HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart) 回调函数（用户自定义其功能）；退出中断，等待下一次信息的发送。 2.2 HAL_UART_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size) 用户在 main() 和回调函数 HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart) 中都调用一次该函数；执行中：指定未来接收到的信息要存入的空间，即pData指针指向的空间就是之后接收到的信息要存入的空间+使能“奇偶校验错误”中断+使能“其它uart错误”中断+使能“接收寄存器非空”中断；（特别注意：该函数是不会接收信息的，只是指定信息要存入的空间）执行结束后：等待接收寄存器非空，然后进入中断； 在中断里，先自动调用 UART_Receive_IT(UART_HandleTypeDef *huart) 函数（该函数会接收信息并存入上一步已经预备好的空间中+失能“奇偶校验错误”中断+失能“其它uart错误”中断+失能“接收寄存器非空”中断）；中断里，之后再自动调用 HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart) 回调函数（用户自定义其功能，但是用户在该函数中必须自行添加 HAL_UART_Receive_IT() 函数，以指定下一次信息待存入的空间并再次使能对应的中断功能）；退出中断，等待下一次接收寄存器非空。 三、代码详解 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/31a2ffc0c851bdaa692f1ec4aaddfd96/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/387b56265f20d9c0a3e944720a222de9/" rel="bookmark">
			PPS Tester——实现系统同步精度测试仪器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		怿星科技近期推出了一款基于1PPS测量方法的系统时钟同步精度测试设备获得了广泛的关注。下面这个视频能让大家更加直观地了解PPS Tester究竟是什么，以及如何操作使用该设备。
产品视频| PPS Tester——实现系统同步精度测试仪器
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59be79c68a59d7a4b417a02b9b6612d3/" rel="bookmark">
			国密cfca的好处
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是国密SSL证书？ 国密SSL证书采用我国自主研发的SM2公钥算法体系，支持SM2,SM3,SM4等国产密码算法及国密SSL安全协议。国密SSL证书可以满足政府机构、事业单位、大型国企、金融银行等行业客户的国产化改造和国密算法合规需求。
国密SSL证书的好处有哪些？ 目前，SSL证书主要依赖于国外CA，一旦国外证书品牌对我们实行断供、吊销，我们将面临巨大的安全风险，因此国密SSL证书的应用至关重要。当我们部署了国密SSL证书，有哪些好处呢？
1.防止网站被钓鱼和假冒，并且对网站的数据进行加密和隐藏，保障双方的商业利益；
2.实现HTTPS加密通信，同时在网站搜索的排名也大有优势；
3.保护用户的隐私及信息安全，提升客户粘度和信任度，从而提高品牌知名度；
结合具体业务、客户功能等需求，解决现有从客户端至服务器端应用国产密码算法障碍；
满足国家政策监管要求，全面助力金融和重要领域完成国密升级改造。可以看出cfca数据不出境，保障了数据的安全，JoySSL平台就有和cfca机构进行合作，
性价比很高，可以参考一下CFCA_CFCA SSL证书_CFCA https证书-JoySSL
SM2/RSA双证书模式是否能解决浏览器兼容性？ 通过“SM2/RSA”双证书服务帮助网站系统自适应兼容所有浏览器（同时兼容国密算法浏览器和仅支持国际算法的浏览器），兼顾国密合规和全球通用。通过此模式，您使用任意浏览器都能正常访问网站，满足部署国密SSL证书的合规需求，同时满足网站可用性、易用性和全球通用性要求，解决了国密 SSL 应用的技术障碍。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d59994a73d9e0ffb3b8f74871b4ff158/" rel="bookmark">
			SpringBoot实现文件上传的多种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们平时在项目开发过程中，会遇到许多的文件上传与下载的需求，今天我们就来梳理一下文件上传的代码实现，基于SpringBoot 快速搭建服务，集成文件上传功能，包括传统的文件上传方式，也拓展OSS对象存储方式。项目类型是Maven项目
一、引入web依赖
org.springframework.boot
spring-boot-starter-web
二、application.yml配置
在application.yml设置文件上传大小，以及文件上传路径和显示路径。maxFileSize 是单个文件大小，maxRequestSize是设置总上传的数据大小，文件配置大小的规则就是根据你的需求来设置。比如，如果只是上传图片，不管是单图上传还是多图上传，几十兆基本都能满足要求，如果是上传视频，则文件大小基本都是上百兆。
这里有一个需要注意的就是application.yml里面的配置需要根据SpringBoot的版本来定，上面配置的是当前比较常用的版本，基于SpringBoot 2.x，但如果是SpringBoot 1.x，比如1.5版本，可以参考以下的配置（区别在于一个是http，一个是servlet）
除了在application.yml 中配置变量，也可以直接在Java代码里面配置：
/** * @Description 上传文件配置 * @author 编程侠 * @param * @param MultipartConfigElement */ public MultipartConfigElement multipartConfigElement() { MultipartConfigFactory factory = new MultipartConfigFactory(); //文件最大30M,DataUnit提供五种类型B,KB,MB,GB,TB factory.setMaxFileSize(DataSize.of(30, DataUnit.MEGABYTES)); /// 设置总上传数据总大小200M factory.setMaxRequestSize(DataSize.of(300, DataUnit.MEGABYTES)); return factory.createMultipartConfig(); }
三、文件上传
1、前端代码
最简单的就是使用经典的form表单和input上传。 设置form的aciton为后端请求，enctype=“multipart/form-data”，type=‘post’。
说明:
（1）enctype 设置 multipart/form-data ，原因：指定传输数据为二进制类型，比如图片、mp3、文件。 这个一般文件上传时用。它告诉我们传输的数据要用到多媒体传输协议，由于多媒体传输的都是大量的数据，所以规定上传文件必须是post方法，type=“file”，浏览器会把整个表单以控件为单位分割。
（2）一般的上传只需要上传文件即可，但时候我们需要额外传参，以此来绑定文件跟用户的关联关系等，这个时候你就可以设置隐藏域，然后在后端使用request.getParameter 接收。
2、后端代码
Controller层代码实现，主要思路就是上传文件到指定的目录下，上传成功拼接显示地址（直接使用上传的地址无法在前端展示，是通过显示路径拼接后展示的），就可以在页面上进行展示了。
如果是多文件上传，上传的方法做出适当的调整。因为接收的文件对象不再是一个了，改用数组接收。
四、对象oss存储
除了传统的存储方式，现在对象oss存储也非常的流行，市场上常用的有阿里云、华为云，七牛云等，为什么需要使用到对象存储呢？oss存储是很多大型互联网公司针对图片、文件以及其他内容的存储使用的一种较为流行的方式，它以响应快，性能高，成本低、安全系数高深受业界大佬推崇。我们这里以阿里云OSS文件存储为例，其他家的接入方法类似。
阿里云OSS上传文件步骤：
1、开通阿里云OSS服务，创建bucket,创建AccessKey，拿到阿里云OSS相关的配置文件，拿到配置文件后，我们就可以放入到项目的配置文件application.yml中。
2、引入项目需要的依赖，maven项目直接在pom.xml中添加依赖。
com.aliyun.oss
aliyun-sdk-oss
3、创建一个读取配置的类，后续业务处理上传到OSS时，从该配置类获取参数。
4、业务处理，一般完整的业务处理流程是：拿到生成文件的本地临时路径和文件数据。在本地临时目下生成文件。将本地文件上传到OSS，返回oss的全路径；删除本地临时目录、文件。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d59994a73d9e0ffb3b8f74871b4ff158/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c72dda6a6a387732fef6a82d166f2ac/" rel="bookmark">
			virtualBox虚拟机关于windows和linnux间共享文件夹设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因为需要从windows上传输一些文件，尝试了很多方法都很麻烦，最后决定用共享文件夹
1.再windows上设置一个文件夹Share（名字不限）
2.点击设置——》共享文件夹——》新建
在虚拟机页面应该也可以：
3.找到windows上共享文件夹的位置，点击“自动挂载”、“固定分配”，点击“ok”。
4.启动虚拟机，打开终端页面
sudo mkdir share-dir # 这里是新建挂载文件夹 5.启动挂载
sudo mount -t vboxsf Share share_dir 注：刚才发现每次重新启动时可能需要重新挂载，后续会看看有没有不需要重新挂载的方法。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4290a7437a6dde33e6cf101ddd5f92b/" rel="bookmark">
			kibana链接elasticsearch集群时，报错Authentication of [elastic] was terminated by realm [reserved]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		kibana链接elasticsearch集群时，报错Authentication of [elastic] was terminated by realm [reserved]
由于es集群服务所在虚拟机重启后，发下服务启动不起来了，经过多种尝试，又是改密码，又是重新签名，最后发现ip变了，nngt（不好听的话），好不容易，es集群起来了，kibana链接不上集群服务，最后发现，kibana.keystore没有重新生成，用重置后的密码重新生成后，完美启动。
现做如下总结，以备不忘：
1.密码重置和集群启动过程如下：
生成新的证书 问题处理流程：
停止es
xpack取消
启动，以无密码形式登录
删除.security
停es
xpack开启
删除elasticsearch/config目录下elasticsearch.keystore、elastic-certificates.p12
bin目录下执行 ./elasticsearch-certutil cert -out config/elastic-certificates.p12 -pass “”
如果是集群，需要把config/elastic-certificates.p12拷贝到其他节点的config目录下
es节点依次启动（划重点）
设置密码,等待cluster health is currently RED.变为green在下一步
./elasticsearch-setup-passwords interactive 如下图好多密码都输入一样的就行
出现这个就说明修改成功了。集群应该启动没问题了。
利用postman看下 启动状态，red变green后 说明启动成功了。
2.接下来困惑就来了，kibana启动不起来。
kibana server is not ready yet
看了下日志输出
又看了下 配置文件，账号密码没毛病啊，然后我就怀疑难道是某个节点密码没改成功？然后我就又走了一遍密码重置过程。然后启动kibana，我去，还是一样。。。。。
最后去官网瞅了瞅，查呀查，最后发现kibana中还有kibana.keystore，一想，既然密码重置了，这个文件是不是也得生成一遍（这不感觉就来了）。
然后开始实操如下：
/bin/kibana-keystore create 提示如下：成功生成。
执行密码添加：
./kibana-keystore add elasticsearch.password 输入重置的密码
生成后启动kibana
nohup ./kibana &amp; 终于看到了久违的画面，激动的都要哭了。。。。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/259aa85acd1c2e591a8ba8989e68ca2c/" rel="bookmark">
			大语言模型之十二 SentencePiece扩充LLama2中文词汇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大语言模型的发展潜力已经毋庸置疑了，如何让中文大语言模型更适合中小公司使用这是一道难题。在模型的选择上我们倾向于选择国外的LLama或者BLoom之类的，而不是百川之类的中文大模型，原因在于从基建到框架到数据国外的开源资料非常多，比如Huggingface Transformer、微软的DeepSpeed、meta的LLama、Pytorch，Google的colab、TensorFlow、BERT，这些公司提供了大量开源的技术工具以及成果。
国外的人才密度高，引领着大语言的发展，所以从国外优秀的开源大语言模型入手是非常不错的途径，减小了学习成本，也减少了公司的使用成本。
但是国外主要是英语系为主，对中文支持不是特别理想，比如原版LLaMA模型的词表大小是32K，LLaMA词表中的中文token比较少（只有几百个，常用汉字都有三千个）。LLaMA 原生tokenizer词表中仅包含少量中文字符，在对中文字进行tokenzation时，一个中文汉字往往被切分成多个token（2-3个Token才能组合成一个汉字），显著降低编解码的效率。
我试过源码中文LLama的推理，效果差很多，但是从头训练又是个庞大的工程，预训练数据集动辄几个T，成本太高，所以在现有优秀的模型基础上扩充中文词汇以及中文训练集以更好支持中文场景是个不错的选择。值得一提的是多语言模型（如：XLM-R、Bloom）的词表大小约为250K，会有更多优秀的模型出现。
为了提升中文场景的效果，需要做如下2~3件事：
1.扩充中文词汇表，提高中文编码效率；在中文语料库上训练一个中文tokenizer模型，然后将中文 tokenizer 与 LLaMA 原生的 tokenizer 进行合并，通过组合它们的词汇表，最终获得一个合并后的 tokenizer 模型。
2.使用增加的中文预训练数据集（Chinese-LLaMA-Alpaca使用了120GB），对模型进行中文预训练；
3.加入SFT指令微调训练，以及RLHF训练
本偏博客用于扩充LLama 2 的中文词汇表。因为LLaMA tokenizer 是使用sentencepiece基于 BPE算法得到的，所以这里也使用BPE方法训练中文模型。没了解过SentencePiece可以先看《大语言模型之十 SentencePiece》
1.下载原版LLama-2模型 以7B为例
首先下载meta的原始模型，需要注册Huggingface账号 git lfs install git clone https://huggingface.co/meta-llama/Llama-2-7b 使用Huggingface提供的转换脚本转换 python3 convert_llama_weights_to_hf.py --input_dir Llama-2-7b --model_size 7B --output_dir llama-2-7b-hf 其中convert_llama_weights_to_hf.py文件源于Huggingface的Transformer开源git库。
因为转换过程中使用到protobuffer
如果报错请按如下方式安装：
LlamaConverter requires the protobuf library but it was not found in your environment. Checkout the instructions on the installation page of its repo: https://github.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/259aa85acd1c2e591a8ba8989e68ca2c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9fee3f25463c59031519edb34b64b74b/" rel="bookmark">
			大语言模型之四-LlaMA-2从模型到应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近开源大语言模型LlaMA-2火出圈，从huggingface的Open LLM Leaderboard开源大语言模型排行榜可以看到LlaMA-2还是非常有潜力的开源商用大语言模型之一，相比InstructGPT，LlaMA-2在数据质量、培训技术、能力评估、安全评估和责任发布方面进行了大量的技术更新，此外在商业许可、huggingface等社区支持等方面也做的比较好，本篇文章以7B模型为例介绍LlaMA-2的推理、训练以及应用。
相对来说LlaMA-2模型结构比Transformer简单一些，关于Transformer可以参见博客《大语言模型之一 Attention is all you need —Transformer》本篇文章重点参考了LlaMA（Meta）的官方Paper。
LlaMA-2是基于Transformer的Decoder部分，其训练数据45TB、2万亿个token，预训练上下文长度为4096，采用了GQA（分组查询注意力机制）提高推理速度，使用了超过100万个人类注释训练对SFT模型模型，伯克利大学的人工智能专业博士Nathan Lambert 则在自己的博客表示，经过一些列基准测试，除了编程能力，LlaMA-2达到了ChatGPT水平，Meta提出了一种提高多轮一致性的新方法GAtt，灵感来源于上下文蒸馏法，论文中还有一些对于奖励模型、RLHF流程、安全评估和许可申明的观点。
奖励模型是强化学习的关键，为了得到一个好的奖励模型，Meta收集了大量偏好数据，量级远远超过了开源社区目前使用的数据量，Meta采用二分类得分模型评价指标，没有使用更加复杂的反馈模型，数据收集的重点在有用性和安全性，对每个数据源使用了不同的指导原则，添加了安全元数据，迭代式数据收集方式，每周分配收集人工注释，随着收集到更多偏好数据，奖励模型也得到改进，数据这一项LlaMA-2大概得花费大约是2000万美元，奖励模型部分Meta训练了两个独立的奖励模型，一个是针对有用性进行了优化，另一个是针对安全性进行了优化；
在训练硬件方面，Meta 在其研究超级集群（Research Super Cluster, RSC）以及内部生产集群上对模型进行了预训练。两个集群均使用了 NVIDIA A100。在 Meta 的评估中，多项测评结果显示，Llama 2 在包括推理、编码、精通性和知识测试等许多外部基准测试中都优于其他开源语言模型。
当然，对于今天的大模型来说，「安全」是一个重要性不亚于「性能」的指标。在 Llama 2 的研发过程中，Meta 使用了三个常用基准评估其安全性：
真实性，指语言模型是否会产生错误信息，采用 TruthfulQA 基准；毒性，指语言模型是否会产生「有毒」、粗鲁、有害的内容，采用 ToxiGen 基准；偏见，指语言模型是否会产生存在偏见的内容，采用 BOLD 基准。 huggingface构建了一个脚本，其中使用了 QLoRA 和 trl 中的 SFTTrainer 来对 Llama 2 进行指令微调。，现在可以用短短几行代码中对所有 Llama-2 模型使用自己的数据进行训练！通过使用 4-bit 和 PEFT，即使在单个 A100 GPU 上，这个脚本也可以用于 70B 模型的训练。你可以在 T4 GPU 上进行 7B 的训练（即在 Colab 上可以免费获取的资源），或者在 A100 GPU 上进行 70B 的训练。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9fee3f25463c59031519edb34b64b74b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf6f37a758c860e6355da29ff7ae77ad/" rel="bookmark">
			C语言入门Day_26 结构体
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言：
1.结构体的定义 2.结构体的使用
3.易错点
4.思维导图 前言： 变量只能表示单一的属性，比如用int去表示一个年龄，用float去表示一个身高或一个体重，一个字符串/字符数组去表示一个性别或一个名字。
int tony_age = 18; float tony_height = 172.0; float tony_weight = 74.0; 而真实世界里面的事物往往有多个属性。比如一个人它既有年龄，身高，体重，也有名字，性别，
在C语言中我们使用一种特殊的数据结构来表示它，它就叫做struct（结构体）。
1.结构体的定义 1.1
truct又叫结构，或者结构体，往往包含多个不同数据类型的变量。
下面我们来看一看一个struct的定义：
struct People { char name[20]; int age; float height; float weight; }; 1.struct关键字，声明这是一个struct结构体
struct
2.struct名，又叫结构名
People
3.struct中的第一个成员，一个字符数组name
char name[20];
4.struct中的第二个成员，一个整型变量int
int age;
struct People { char name[20]; int age; float height; float weight; }; 5.struct中的第三个成员，一个浮点型变量height
float height;
6.struct中的第四个成员，一个浮点型变量weight
float weight;
7.结构中的成员需要用花括号{}括起来
{
}
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf6f37a758c860e6355da29ff7ae77ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53e4b6703cf168f321ac320b837328cf/" rel="bookmark">
			python：进度条的使用（tqdm）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要：为python程序进度条，可以知道程序运行进度。
python中，常用的进度条模块是tqdm，将介绍tqdm的安装和使用
1、安装tqdm:
pip install tqdm 2、tqdm的使用：
（1）在for循环中的使用：
from tqdm import tqdm for i in tqdm(range(10000)): print(i) 在for循环中使用tqdm是最常见了，因为知道循环的次数
（2）在while中使用tqdm
from tqdm import tqdm count = 10000 pbar = tqdm(total = count) i = 0 while i &lt; count: print(i) i += 1 pbar.update(1) 在while中使用进度条，也需要知道循环的次数，本人常在opencv处理视频中使用tqdm， 可大概知道处理的进度。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c9eb9b04fe4d079d506e669d9aa6999/" rel="bookmark">
			matlab实践（七）：GM（1,1）灰色预测模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.过程 第一步：设原始数据序列：
用AGO生成一阶累加生成模块得到：
第二步：构造累加矩阵与常数项向量，即
上述方程组中，和为已知量，a为待定参数。由于变量只有a和u二个，而方程个数却有N-1个，而N-1&gt;2，故方程组无解。但可用最小二乘法得到最小二乘解。
第三步：用最小二乘法解灰参数
第四步：将灰参数代入时间参数
第五步：对求导还原得到
第六步：计算拟合误差
第七步：灰色GM（1，N）模型的检验分为三个方面：关联度检验、残差检验、后验差检验。后验差检验是残差分析统计特性的检验，模型诊断及应用模型进行预报。后验差比值C：残差方差S1与数据方差S2之比，即有：
计算残差方差S1
及数据方差S2
小误差概率
若对于给定的＞0，当＜时，称模型为均方差比合格模型；如对给定的＞0，当＞时，称模型为小残差概率合格模型。根据后验比C和小误差概率P对模型进行判断，预测模型的精度等级见表二所示：
2.代码实现 clc;clear; format short X=input('请输入原始数据:','s'); X=str2num(X); [m1 m2]=size(X); k0=input('请输入所要预测的阶数:'); %GM(1,1)模型 for i=1:m1 n=i; x0=X(i,:); disp('1.原始数据:'); Y=''; for z=1:m2 Y=strcat(Y,'(',num2str(x0(z)),')'); end disp(Y); % 1. 利用一次累加（1-AGO）生成新数列,m2是X的列数，triu返回上三角矩阵，x0是X的每行， E=triu(ones(m2)); x1=x0*E; disp('2.一次累加（1-AGO）生成的数据:'); Y=''; for z=1:m2 Y=strcat(Y,'(',num2str(x1(z)),')'); end disp(Y); % 2. 计算出发展系数a，灰作用量u b1=x1;b1(1)=[]; b2=x1;b2(m2)=[]; b=-0.5*(b1+b2); B=[b;ones(1,m2-1)]; B=B'; y0=x0;y0(1)=[]; y0=y0'; A=((inv(B'*B))*B')*y0; a=A(1);u=A(2); disp(a); disp(u); % 3. 确立模型且求出模拟值 u_a=u/a; format long syms t ppp=vpa((x0(1)-u_a)*exp(-t*a)+u_a); for k=0:m2+k0-1 x2(k+1)=(x0(1)-u_a)*exp(-k*a)+u_a; end x3=x2; x3(m2+k0)=[]; x4=[0 x3]; x5=x2-x4; % disp('3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c9eb9b04fe4d079d506e669d9aa6999/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0580b5602523fcb0d2e959a6dc53a3e7/" rel="bookmark">
			用XPath获取 HTML 元素的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网络爬虫是一种自动化程序，用于在互联网上浏览和抓取信息。它可以自动地从网页中提取数据，并且可以按照预定的规则进行操作，如抓取特定网站的所有页面或抓取特定内容等。其中在 HTML 文档中，每个元素都有自己的标签和属性。XPath 可以通过标签名和属性名来定位和提取元素
基本语法：
（1）XPath表达式通常以斜杠 / 开始，表示从根节点开始的路径。
（2）双斜杠 // 表示不考虑元素的层级位置，可以在整个文档中搜索匹配的元素。
（3）元素名称用于定位元素，例如 /bookstore/book 表示选择根节点下的所有 &lt;book&gt; 元素。
节点类型：
（1）在XPath中，节点可以是元素、属性、文本、注释等。
（2）常见的节点类型包括：element、attribute、text、comment、processing-instruction等。
谓词：
（1）谓词是XPath表达式中的条件，用于过滤或选择元素。
（2）可以使用方括号 [] 来添加谓词，例如 /bookstore/book[1] 表示选择第一个 &lt;book&gt; 元素。
通配符：
（1）* 表示匹配任何元素节点，例如 /bookstore/* 选择根节点下的所有子元素。
（2） @ 表示匹配任何属性节点，例如 /bookstore/book/@* 选择所有 &lt;book&gt; 元素的所有属性。
父节点和子节点：
（1） 使用 .. 表达式可以选择当前节点的父节点，例如 /bookstore/book/title/.. 选择 &lt;title&gt; 元素的父元素 &lt;book&gt;。
（2）使用 / 表示子节点关系，例如 /bookstore/book/title 选择 &lt;book&gt; 元素下的 &lt;title&gt; 子元素。
在开始数据采集之前我们应该首先加载库：for lxml import etree（在Temrinal中执行“pip install lxml”）
提取数据 因为xpath提取到的整个标签展现形式是这样的[&lt;Element h1 at 0x1eb1102b5c0&gt;]，所以先讲如何提取内容，之后讲如何提取标签时，才好根据输出内容来区分提出来的是什么东西。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0580b5602523fcb0d2e959a6dc53a3e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba2f6a790317c5082ed0d3346d4d24f1/" rel="bookmark">
			Nsenter 调取宿主机工具调试容器内程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		nsenter 是一个可以用来进入到目标程序所在 Namespace 中运行命令的工具，一般常用于在宿主机上调试容器中运行的程序。
nsenter 安装
nsenter 位于 util-linux 包中，一般常用的 Linux 发行版都已经默认安装。如果你的系统没有安装，可以使用以下命令进行安装：
nsenter 用途
一个比较典型的用途就是进入容器的网络命名空间。通常容器为了轻量级，大多都是不包含较为基础网络管理调试工具，比如：ip、ping、telnet、ss、tcpdump 等命令，给调试容器内网络带来相当大的困扰。
nsenter 命令可以很方便的进入指定容器的网络命名空间，使用宿主机的命令调试容器网络。
除此以外，nsenter 还可以进入 mnt、uts、ipc、pid、user 等命名空间，以及指定根目录和工作目录。
nsenter 用法
首先看下 nsenter 命令的语法：
$ yum install util-linux
如果没有给出 program，则默认执行 $SHELL。最常用的参数组合是:
$ nsenter [options] [program [arguments]]
options:
-a, --all enter all namespaces of the target process by the default /proc/[pid]/ns/* namespace paths.
-m, --mount[=]：进入 mount 命令空间。如果指定了 file，则进入 file 的命名空间
-u, --uts[=]：进入 UTS 命名空间。如果指定了 file，则进入 file 的命名空间
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba2f6a790317c5082ed0d3346d4d24f1/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/82/">«</a>
	<span class="pagination__item pagination__item--current">83/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/84/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>