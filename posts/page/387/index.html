<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69716a871f9f1d4da843137e3236ef9f/" rel="bookmark">
			mysql - explain/执行时间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.explain信息表
2.下面对这些字段出现的可能进行解释
explain命令用来查看SQL语句的执行计划
1.explain信息表 explain select * from emp where name = 'Jefabc';
-- expain出来的信息有10列，分别是id、select_type、table、type、possible_keys、key、key_len、ref、rows、Extra
-- 概要描述：
-- id:选择标识符
-- select_type:表示查询的类型。
-- table:输出结果集的表
-- partitions:匹配的分区
-- type:表示表的连接类型
-- possible_keys:表示查询时，可能使用的索引
-- key:表示实际使用的索引
-- key_len:索引字段的长度
-- ref:列与索引的比较
-- rows:扫描出的行数(估算的行数)
-- filtered:按表条件过滤的行百分比
-- Extra:执行情况的描述和说明
2.下面对这些字段出现的可能进行解释 1)id
-- 我的理解是SQL执行的顺序的标识，SQL从大到小的执行
-- 1. id相同时，执行顺序由上至下
-- 2. 如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行
-- 3. id如果相同，可以认为是一组，从上往下顺序执行；在所有组中，id值越大，优先级越高，越先执行
2)select_type
-- 示查询中每个select子句的类型
-- (1) SIMPLE(简单SELECT，不使用UNION或子查询等)
-- (2) PRIMARY(子查询中最外层查询，查询中若包含任何复杂的子部分，最外层的select被标记为PRIMARY)
-- (3) UNION(UNION中的第二个或后面的SELECT语句)
-- (4) DEPENDENT UNION(UNION中的第二个或后面的SELECT语句，取决于外面的查询)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/69716a871f9f1d4da843137e3236ef9f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/453cb0d316dc8cf4924c156ca69e61fc/" rel="bookmark">
			Python IDLE使用方法详解（包含常用快捷键
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python IDLE使用方法详解（包含常用快捷键） 在安装 Python后，会自动安装一个 IDLE，它是一个 Python Shell (可以在打开的 IDLE 窗口的标题栏上看到），程序开发人员可以利用 Python Shell 与 Python 交互。
本节将以 Windows7 系统中的 IDLE 为例，详细介绍如何使用 IDLE 开发 Python 程序。
单击系统的开始菜单，然后依次选择“所有程序 -&gt; Python 3.6 -&gt; IDLE (Python 3.6 64-bit)”菜单项，即可打开 IDLE 窗口，如图 1 所示。
图 1 IDLE主窗口
前面我们己经应用 IDLE 输出了简单的语句，但在实际开发中，通常不能只包含一行代码，当需要编写多行代码时，可以单独创建一个文件保存这些代码，在全部编写完成后一起执行。具体方法如下：
在 IDLE 主窗口的菜单栏上，选择“File -&gt; New File”菜单项，将打开一个新窗口，在该窗口中，可以直接编写 Python 代码。
在输入一行代码后再按下 键，将自动换到下一行，等待继续输入，如图 2 所示。
图 2 新创建的 Python 文件窗口
在代码编辑区中，编写多行代码。例如，输出由宋词《江城子》改编而成的《程序员之歌》，代码如下：
print(" "*5+"程序员之歌") print(" "*15+"——《江城子》改编\n") print("十年生死两茫茫，写程序，到天亮，") print("千行代码，Bug何处藏。") print("纵使上线又怎样，朝令改，夕断肠。") print("领导每天新想法，天天改，日日忙。") print("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/453cb0d316dc8cf4924c156ca69e61fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21a74d572c59bcfd7ed87f25e79de9ee/" rel="bookmark">
			【RecyclerView】 九、为 RecyclerView 设置不同的布局样式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、为 RecyclerView 设置不同的布局样式二、完整代码三、RecyclerView 相关资料 一、为 RecyclerView 设置不同的布局样式 为 RecyclerView 设置不同的布局样式流程 :
① 自定义 RecyclerView.Adapter 泛型类型 : 适配器的泛型类型需要设置为 RecyclerView.ViewHolder , 这是所有 ViewHolder 的基类 ;
public class Adapter extends RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt; ② 实现 getItemViewType( ) 方法 : 这里为不同位置的组件设置不同的布局类型 ;
@Override public int getItemViewType(int position) { // 返回 View 布局类型, 奇数序号组件类型为 VIEW_TYPE_2, 偶数序号组件类型为 VIEW_TYPE_1 return position % 2; } ③ 根据布局类型加载不同的布局文件 : 在 onCreateViewHolder( ) 方法中 , 根据当前的 int viewType 参数 , 加载不同的布局文件 ;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21a74d572c59bcfd7ed87f25e79de9ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6679fe827be4ec1e65eeff7f3e6ab02/" rel="bookmark">
			Altium designer中原理图导入PCB元器件没有网络标号的几种可能原因
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原理图元器件之间导线未连接，看起来连接了，实际上没有连接，如下图红框部分所示
元件封装错误。如原理图上的引脚编号是1,2,3,而PCB中引脚编号是其它内容
正确PCB图示
错误PCB图示
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dab13f6460f0008f20da02bcc8151c96/" rel="bookmark">
			C语言笔记——结构体struct
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、struct在使用的时候前面加.，表示不用考虑赋值顺序的赋值。
比如：
struct led_operations { int num; int (*init) (int which); /* 初始化LED, which-哪个LED */ int (*ctl) (int which, char status); /* 控制LED, which-哪个LED, status:1-亮,0-灭 */ }; 我可以直接这样写，任意赋值：
static struct led_operations board_demo_led_opr = { .num = 1, .init = board_demo_led_init, .ctl = board_demo_led_ctl, }; 我也可以这样写
static struct led_operations board_demo_led_opr = {1,board_demo_led_init,board_demo_led_ctl}; 2、struct和class的区别:class作为对象的实现体，它默认的成员变量访问控制是private的.
struct是public的，class是private的。
struct A
{
char a;
}；
struct B : A
{
char b;
}；
这个时候B是public继承A的。
如果都将上面的struct改成class，那么B是private继承A的。这就是默认的继承访问权限。 所以我们在平时写类继承的时候，通常会这样写：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dab13f6460f0008f20da02bcc8151c96/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e30977afe7eeb0f031f23c641ce9f0e/" rel="bookmark">
			每日一题 21.01.29 LeetCode 1631. 最小体力消耗路径 Java代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		气死我了 以为是dp或者回溯 没写出来
又是并查集
题目 https://leetcode-cn.com/problems/path-with-minimum-effort/
分析 代码 class Solution { public int minimumEffortPath(int[][] heights) { int m = heights.length; int n = heights[0].length; List&lt;int[]&gt; edges = new ArrayList&lt;int[]&gt;(); //edge:顶点1的编号，顶点2的编号，边的高度差绝对值 for (int i = 0; i &lt; m; ++i) { for (int j = 0; j &lt; n; ++j) { int id = i * n + j; //上面有边 if (i-1&gt;=0) { edges.add(new int[]{id - n, id, Math.abs(heights[i][j] - heights[i - 1][j])}); } //左面有边 if (j-1&gt;=0) { edges.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e30977afe7eeb0f031f23c641ce9f0e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60d8879f49fcff669b734145d7c27976/" rel="bookmark">
			Java实现超市管理系统（含数据库）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：AiY..来源：https://blog.csdn.net/qq_44859533 序言： 学Java已经有几个月了，上一次总结是针对GUI界面写的简易计算器，实现加减乘除功能以及计算器标准型和科学型之间的转换，有兴趣可以看看 Java混合计算器以及界面切换 . 这次写的超市管理系统，实现的功能有账户的注册、登录，超市商品类别的添加、修改和删除以及商品的添加、修改和删除的功能。用户注册之后把注册信息导入数据库；用户登录时候查询用户表，方可登录进去；商品类别和商品的增加也如注册信息一样，把信息导入商品类别表和商品表。由于快期末考试了，超市管理系统的一些功能还没有完善，后续还会更新顾客登录超市系统后，只能拥有查询商品的权限，并且还可以实现购买商品的功能，哈~哈 ~…
1、首先是建立数据库表： 2、实现主页面： 3、实现用户注册： 核心代码：
public static void main(String args[]) { java.awt.EventQueue.invokeLater(new Runnable() { public void run() { new Register().setVisible(true); } }); } private void jButton1ActionPerformed(java.awt.event.ActionEvent evt) { String name=this.jTextField1.getText(); String age=this.jTextField3.getText(); String QQ=this.jTextField4.getText(); String userName=this.jTextField5.getText(); String password1=this.jPasswordField1.getText(); String password2=this.jPasswordField2.getText(); if(StringUtil.isEmpty(name)){ JOptionPane.showMessageDialog(null,"姓名不能为空"); return; } if(StringUtil.isEmpty(age)){ JOptionPane.showMessageDialog(null,"年龄不能为空"); return; } if(StringUtil.isEmpty(QQ)){ JOptionPane.showMessageDialog(null,"QQ不能为空"); return; } if(StringUtil.isEmpty(userName)){ JOptionPane.showMessageDialog(null,"注册账号不能为空"); return; } if(StringUtil.isEmpty(password1)){ JOptionPane.showMessageDialog(null,"注册密码不能为空"); return; } if(StringUtil.isEmpty(password2)){ JOptionPane.showMessageDialog(null,"确认密码不能为空"); return; } if(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60d8879f49fcff669b734145d7c27976/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e54923df7080930b94d413f92290bce1/" rel="bookmark">
			python多分类画混淆矩阵_多分类问题中混淆矩阵(Confusion Matrix)的Matlab画法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【实例简介】
Matlab code for computing and visualization: Confusion Matrix, Precision/Recall, ROC, Accuracy, F-Measure etc. for Classification.
Matlab通过分类的label计算混淆矩阵Confusion Matrix并且显示的函数只要一句代码就行了，方便。
[confusion_matrix]=compute_confusion_matrix(predict_label,num_in_class,name_class);
【实例截图】
【核心代码】
PG_Curve-master
└── PG_Curve-master
├── AccuracyF
│ └── compute_accuracy_F.m
├── ConfusionMatrices
│ ├── compute_confusion_matrix.m
│ ├── draw_cm.m
│ └── rotateXLabels.m
├── PrecisionRecall
│ ├── compute_precision_recall.m
│ ├── draw_prc.m
│ ├── prc_stats.m
│ ├── prc_stats_binormal.m
│ └── prc_stats_empirical.m
├── ReadMe.txt
├── actual_label.mat
├── decision_values.mat
├── main.m
├── name_class.mat
├── num_in_class.mat
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e54923df7080930b94d413f92290bce1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7357ddb162a5b4d09a39685609cc2fb7/" rel="bookmark">
			js 只要一盒章鱼丸子的时间就能搞懂的日程时间段重叠
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		日程时间段重叠算法 不知道有没有老哥需要开发一个日程(别的日程图)。
这种重叠要怎么实现呢？就很好奇，所以我写了一段代码，用left right区分左右，id来进行辩别那些是合并的了。（注：仅针对当天的日程，跨天不适用。这里我引用了moment）
时间段的情况有三种：完全不重叠、包裹、半包裹如下图：
1是完全不重叠的，3、4是半包裹的， 5、6是全包裹的，2先不管。然后有一下思路，这个图片是对照上面的日程的。想要实现图片上面左右隔离的效果，首先经行一次粗的合并重叠时间，就是重叠的合并，把1和 2~8分开，然后再对 2~8细分，拆分成3 4一块 56一块 7和8。再处理的思路就是取出最大值，也就是时长最大的一块，然后再走一次合并，就会细分好。想好之后下面就是具体实现
第一步我们先要实现一个时间重叠算法，先把重叠的时间段合并 /** * 合并重叠的时间段 * * 思路为先排序，然后前一个和后一个比较如果是重叠就当场合并，并将前一个设置为空， * 然后过滤掉空值就得到重叠数组了 * 的也很简单，将开始时间或者结束时间赋值一下即可 * 重叠主要有两种情况，一种包裹着的，一种非包裹的 */ function getOverlapList( arr ) { //排序 let list = JSON.parse(JSON.stringify(arr)) //因为是字符串比较，但是正统点是1 -1这些，所以用了个三目 list.sort((a, b) =&gt; a.startTime &gt; b.startTime ? 1 : -1); //合并 for(let i = 0, len = list.length - 1, j = 1; i &lt; len; i ++, j++){ //遇到重叠 if (list[i].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7357ddb162a5b4d09a39685609cc2fb7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/821880b44cd5619943676ddcce30b7f9/" rel="bookmark">
			data: image/png； base64 用法详解 ( 作用，语法，优缺点 )
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家可能注意到了，网页上有些图片的 src 或 css 背景图片的 url 后面跟了一大串字符，如：
background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAAkCAYAAABIdFAMAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAHhJREFUeNo8zjsOxCAMBFB/KEAUFFR0Cbng3nQPw68ArZdAlOZppPFIBhH5EAB8b+Tlt9MYQ6i1BuqFaq1CKSVcxZ2Acs6406KUgpt5/LCKuVgz5BDCSb13ZO99ZOdcZGvt4mJjzMVKqcha68iIeP86GAiOv8CDADlIUQBs7MD3wAAAABJRU5ErkJggg%3D%3D） data:image/png;base64, 字符串... 这个表示什么意思，又有什么作用呢？ 其实这就是所谓的 Data URI scheme。 直译过来的意思是：URI 数据处理方案... 1. Data URI scheme 是什么 ？？？ Data URI scheme 是在 RFC2397 中定义的，目的是将一些小的数据，直接嵌入到网页中，从而不用再从外部文件载入。减少对 HTTP 的请求次数。达到优化网页的效果。
base64 后面那一串字符，其实是一张图片，将这些字符串复制粘贴到浏览器的中打开，就能看到图片了
假设你有的图像：A.jpg ，把它在网页上显示出来的标准方法是：
&lt;img src="http://sjolzy.cn/images/A.jpg"/&gt; 这种取得数据的方法称为 http URI scheme 。
&lt;img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAADCAIAAAA7ljmRAAAAGElEQVQIW2P4DwcMDAxAfBvMAhEQMYgcACEHG8ELxtbPAAAAAElFTkSuQmCC" /&gt; 这种取得数据的方法称为 Data URI scheme 。
2. Data URI scheme 的语法 在上面的 Data URI scheme 中：
data 表示取得数据的协定名称；
image/png 是数据类型名称；
base64 是数据的编码方法，逗号后面就是这个image/png文件base64编码后的数据。
目前，Data URI scheme支持的类型有：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/821880b44cd5619943676ddcce30b7f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50fa5a751b18de0bd093efce128bb841/" rel="bookmark">
			Simpy的学习与实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考博客
https://blog.csdn.net/mieleizhi0522/article/details/82142856
https://zhuanlan.zhihu.com/p/31526894
首先，要了解python中的几个语法
yield def foo(): print("starting...") while True: res = yield 4 print("res:",res) g = foo() print(next(g)) print("*"*20) print(next(g)) 1.程序开始执行以后，因为foo函数中有yield关键字，所以foo函数并不会真的执行，而是先得到一个生成器g(相当于一个对象)
2.直到调用next方法，foo函数正式开始执行，先执行foo函数中的print方法，然后进入while循环
3.程序遇到yield关键字，然后把yield想想成return,return了一个4之后，程序停止，并没有执行赋值给res操作，此时next(g)语句执行完成，所以输出的前两行（第一个是while上面的print的结果,第二个是return出的结果）是执行print(next(g))的结果，
4.程序执行print("*"20)，输出20个
5.又开始执行下面的print(next(g)),这个时候和上面那个差不多，不过不同的是，这个时候是从刚才那个next程序停止的地方开始执行的，也就是要执行res的赋值操作，这时候要注意，这个时候赋值操作的右边是没有值的（因为刚才那个是return出去了，并没有给赋值操作的左边传参数），所以这个时候res赋值是None,所以接着下面的输出就是res:None,
6.程序会继续在while里执行，又一次碰到yield,这个时候同样return 出4，然后程序停止，print函数输出的4就是这次return出的4.
def foo(): print("starting...") while True: res = yield 4 print("res:",res) g = foo() print(next(g)) print("*"*20) print(g.send(7)) 5.程序执行g.send(7)，程序会从yield关键字那一行继续向下运行，send会把7这个值赋值给res变量
6.由于send方法中包含next()方法，所以程序会继续向下运行执行print方法，然后再次进入while循环
7.程序执行再次遇到yield关键字，yield会返回后面的值后，程序再次暂停，直到再次调用next方法或send方法。
def foo(num): print("starting...") while num&lt;10: num=num+1 yield num for n in foo(0): print(n) for n in range(1000): a=n range需要一次性生成，很占内存，使用yield就可以
然后1. 拿for i in x举例， for循环首先要求in后面对象x是一个迭代器（内部实现了__next__方法的对象） 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/50fa5a751b18de0bd093efce128bb841/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac679e38543edf340a4e93f4de45ac1e/" rel="bookmark">
			树莓派做旁路网关 及 无法上网解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实现有两种方式，烧录 openwrt 系统或者 docker 镜像
烧录系统 https://github.com/SuLingGG/OpenWrt-Rpidocker https://github.com/SuLingGG/OpenWrt-Rpi-Docker 遇到的问题：设置后没网
原因：肯定是设置不对呗
说明：整个 openwrt 中，只有 网络 这一选项中的接口和防火墙有关于网络（其他的我不知道）
先说防火墙
出入站 是本机（docker 容器）的网络出入规则，都要选接受，不然就没网
转发 就是本机（docker 容器）接受到的 目的地 IP 不是本机的数据包，接受就是说我可以给你转发，丢弃和拒绝就是不管了，所以说必须要选接受。
下面的 区域 那一块，我是删掉了，没啥用
再说接口
我只留了一个，这个随意
主路由是 192.168.2.1，192.168.2.2 是网段不冲突的一个地址
值得注意的是，这里的这个桥接也是直接影响了你的上网
默认是勾选的好像，如果无法上网，可以不选它试试
本文主要讲述下如何解决我个人不能上网的问题，安装步骤项目文档里都有，推荐还是 docker 方式，拉取时注意下选择自己机器对应的 tag。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/600af9cead3997fed8b4542b8a5232da/" rel="bookmark">
			西门子smart plc恒压供水梯形图_PLC经典编程实例——双恒压无塔供水
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PLC和变频器都是工业控制中最常用的设备，二者可以单独使用，也可以密切配合，都能够达到自动化控制的目的，应用非常的广泛，今天就举一个具体的例子：双恒压无塔供水系统，这个系统是由变频器和PLC密切配合才能完成的，一般都在大的项目上使用。
来源：网络，版权归原作者所有，如有侵权请联系删除
往期精彩：
【70页PPT】精讲西门子S7-1200PLC通信全解
【西门子】用SCL语言设计的功能块，一键启停
史上最全的电力学公式及电工图，收藏起来一定用得上！
电气人必看！最全的电路基础知识讲解
PID入门读此文足以
PID调得好不好，它说了算！
电工进阶必备 | 电气控制原理图到梯形图转换
推荐丨进行逻辑控制顺序控制的编程方法
【详细步骤】S7-200smart 与台达变频器通讯，其实没那么难！
PLC必备知识：电气控制电路与PLC之间的梯形图转化，你都知道吗？
【科普】伺服电机的13种故障及维修知识汇总！
PLC模拟量那些事
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb803797fb911c3dbde7fa8016d25751/" rel="bookmark">
			C&#43;&#43;使用OpenCV开发带界面程序总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++使用OpenCV开发带界面程序总结 概述 OpencCV自身已经带了GUI界面，这个作处理结果检测是够用的，但是要产品化，界面就显得有点不专业(可能是自己研究不够)，所以就得使用一些相关的C#、MFC、QT等来完成用户交互界面。现在就对做一个比较。
C# ​ C#调用OpenCV需要使用OpenCVSharp库，是此库相对简单，但是如果需要在OpenCV定义自己的算法，就无法满足。想使用OpenCV原始的方法可以满足要求。如果项目侧重的是OpenCV算法优化，这个就无法满足。就需要你是先自己的C++动态库，再在C#中调用(这个可以参考C#调用C++动态库)。
private void OpenButton_Click(object sender, EventArgs e) { OpenFileDialog file = new OpenFileDialog(); file.InitialDirectory = "."; file.Filter = "所有文件(*.*)|*.*"; file.ShowDialog(); if (file.FileName != string.Empty) { try { pathname = file.FileName; //获得文件的绝对路径 this.pictureBox1.Load(pathname); //opencv加载图片 Mat src = new Mat(pathname, ImreadModes.Color); Cv2.ImShow("C#测试OpenCV",src); Cv2.WaitKey(0); } catch (Exception ex) { MessageBox.Show(ex.Message); } } } 具体实现可以参考链接(https://www.cnblogs.com/jsxyhelu/p/9669583.html)
MFC ​ MFC本身是使用C++开发的，OpenCV也是，可以做到无缝调用。但是要将OpenCV保存图片结构(Mat)转换成MFC图片结构(IplImage)感觉有点麻烦(可能是自己对MFC使用不多).
QT ​ QT本身也是使用C++开发的，可以直接调用OpenCV函数。自己感觉优点就是OpenCV转换成QT图片结构比较简单，一个函数就搞定，另外一个优点就是可以跨平台(如果没有跨平台要求，这个就不算优点，哈哈)。
Mat image = imread(str); cvtColor(image, image, COLOR_BGR2RGB); cv::resize(image, image, Size(300, 200)); QImage img = QImage((const unsigned char*)(image.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb803797fb911c3dbde7fa8016d25751/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e14a570d894c8ca34075454a1453d7d/" rel="bookmark">
			Objects.equals(a,b)与equals的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一：值是null的情况： a.equals(b), a 是null, 抛出NullPointException异常。 a.equals(b), a不是null,b是null, 返回false Objects.equals(a, b)比较时， 若a 和 b 都是null, 则返回 true,如果a 和 b 其中一个是null, 另一个不是null, 则返回false。注意：不会抛出空指针异常。 null.equals(“abc”) → 抛出 NullPointerException 异常
“abc”.equals(null) → 返回 false
null.equals(null) → 抛出 NullPointerException 异常
Objects.equals(null, “abc”) → 返回 false
Objects.equals(“abc”,null) → 返回 false
Objects.equals(null, null) → 返回 true
二：值是空字符串的情况： a 和 b 如果都是空值字符串："", 则 a.equals(b), 返回的值是true, 如果a和b其中有一个不是空值字符串，则返回false;
这种情况下 Objects.equals 与情况1 行为一致。
“abc”.equals("") → 返回 false
“”.equals(“abc”) → 返回 false
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e14a570d894c8ca34075454a1453d7d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b72ddce2ce635cd50f470027ad43049/" rel="bookmark">
			JVM栈（4）-----动态链接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是动态链接 每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用，包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接。比如: invokedynamic指令
在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用保存在class文件的常量池里，比如:描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用。
运行时常量池存储在方法区
方法的调用 方法的调用就是将符号引用转换为常量池中的直接引用过程，转换过程分为两种
静态链接 / 早期绑定
如果被调用的目标方法在编译期可知，并且在运行期保持不变，这种情况下将符号引用转换成直接引用的过程称为静态链接。如：构造方法的相互调用 动态链接 / 晚期绑定
如果被调用的目标方法在编译期无法确定下来，只能够在程序运行时将方法的符号引用转换为直接引用，这种转换过程具备动态性，所以被称之为动态链接。如：一般方法的调用，多态，接口的实现方法 对于面向过程的语言来说，是只有早期绑定特征的，对于面向过程的语言都是具备多态性，然具有早期绑定和晚期绑定，Java中任何一个普通的方法其实都具备虚函数的特征，它们相当于c++语言中的虚函数（C++中则需要使用关键字virtual来显式定义）。如果在Java程序中不希望某个方法拥有虚函数的特征时，则可以使用关键字final来标记这个方法。
虚方法表
在面向对象的编程中，会很频繁的使用到动态分配，如果在每次动态分配的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率。因此，为了提高性能，JVM采用在类的方法区建立一个虚方法表( virtual method table）(非虚方法不会出现在表中)来实现。使用索引表来代替查找。每个类中都有一个虚方法表，表中存放着各个方法的实际入口。 那么虚方法表什么时候被创建?
虚方法表会在类加载的链接阶段被创建并开始初始化，类的变量初始值准备完成之后，JVM会把该类的方法表也初始化完毕。 例：
public class MethodInvoke { public void methodA(){ } public void methodB(){ methodA(); } } 使用javap反编译后：
虚方法和非虚方法 非虚方法
如果方法在编译期就确定了具体的调用版本，且在运行时不可变，对应，则称为非虚方法如：静态方法（属于类，不可被重写）、私有方法、构造方法、父类方法、final修饰的方法 虚方法
除了上述的非虚方法，其他都为虚方法。 JVM提供的调用方法的字节码指令
普通调用指令:
invokestatic: 调用静态方法，解析阶段确定唯一方法版本invokespecial: 调用方法、私有及父类方法，解析阶段确定唯一方法版本invokevirtual: 调用所有虚方法invokeinterface: 调用接口方法 动态调用指令:
5. invokedynamic:动态解析出需要调用的方法，然后执行
前四条指令固化在虚拟机内部，方法的调用执行不可人为干预，而invokedynamic指令则支持由用户确定方法版本。
其中invokestatic指令和invokespecial指令调用的方法称为非虚方法，其余的(final修饰的除外，final修饰的方法通过invokevirtual指令调用）称为虚方浩。
关于invokedynamic指令
JVM字节码指令集一直比较稳定，一直到Java7中才增加了一个invokedynamic指令，这是Java为了实现『动态类型语言』支持而做的一种改进。但是在Java7中并没有提供直接生成invokedynamic指令的方法，需要借助ASM这种底层字节码工具来产生invokedynamic指令。直到Java8的JLambd表达式的出现,invokedynamic指令的生成，在Java中才有了直接的生成方式。Java7中增加的动态语言类型支持的本质是对Java虚拟机规范的修改，而不是对Java语言规则的修改，这一块相对来讲比较复杂，增加了虚拟机中的方法调用，最直接的受益者就是运行在Java平台的动态语言的编译器。 关于动态类型语言和静态类型语言
动态类型语言和静态类型语言两者的区别就在于对类型的检查是在编译期还是在运行期，满足前者就是静态类型语言，反之是动态类型语言。说的再直白一点就是，静态类型语言是判断变量自身的类型信息;动态类型语言是判断变量值的类型信息，变量没有类型信息，变量值才有类型信息，这是动态语言的一个重要特征。如JavaScript、python都是动态类型语言，Java、C#、C++都是静态类型语言。 方法重写的本质 过程：
1．找到操作数栈顶的第一个元素所执行的对象的实际类型，记作 c 。
2．如果不同类型c中找到与常量池中的描述符合简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过，则返回java. lang.IllegalAccessError异常。
3．否则，按照继承关系从下往上依次对c的各个父类进行第2步的搜索和验证过程。
4．如果始终没有找到合适的方法，则抛出java.lang.AbstractMetlodError异常。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b72ddce2ce635cd50f470027ad43049/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8d0f21df27f4300eba763e86dc0b21a/" rel="bookmark">
			python中什么是字典_Python中的字典是什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		字典是数据的无序集合，用于存储数据值。与其他仅将单个值作为项的数据类型不同，字典具有键-值对。字典中的键和值之间用冒号“:”分隔，而键-值对之间用逗号“,”分隔，所有键-值对用花括号“{}”括起来。字典的语法格式如下：
字典名 = {键1: 值1, 键2: 值2, …}
字典的工作方式类似于现实世界中的字典，字典的键必须是唯一的，并且是不可变的数据类型，如字符串、整数和元组，但是键的值可以重复，并且可以是任意类型。
1、创建字典
可以用花括号“{}”括起来的键-值对来直接创建字典：
也可以使用内建的工厂函数dict()创建字典：
只有不可变的数据类型才能作为字典的键，因此，列表不能作为字典的键：
2、访问字典中的值
字符串、元组和列表等序列类型都使用索引来访问值，而字典使用键来访问值。键可以放在方括号“[]”中使用：
也可以使用字典的get()方法来访问字典中的值，如果没有找到指定的键，get()方法会返回None：
3、更新字典
字典是可变的， 可以使用赋值运算符添加新项或更改现有项的值，如果键已经存在，那么值将更新，否则将新键-值对添加到字典中：
4、删除字典中的键-值对
可以使用del关键字删除单个键-值对或整个字典本身：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/497fed47a58ab88b3eb8e61ec7616745/" rel="bookmark">
			python中pass语句的作用是什么_Python中pass语句的作用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 Python 中，pass 是一个空语句，为了保持程序结构的完整性。一般情况下，pass 不做任何事情，被用作占位符。
它的作用如下：
1. 空语句 do nothing
2. 保证格式完整
3. 保证语义完整
pass语法格式：pass
如果写了一个循环或者函数，尚未实现(暂未想好如何实现或者交付给其他人)，但是会在将来的某个时候实现。这时，如果循环体或者函数体为空，解释器就会报错。此时，可以使用 pass 语句构造一个不做任何事情的主体。
pass 和注释之间的区别在于：解释器会完全忽略注释，但不会忽略 pass。然而，执行 pass 时什么都不会发生，导致无操作(NOP)。
例1，pass语句在 if 语句中的使用：:
:
()
例2，pass语句在函数中的使用：
当在编写一个函数时，执行语句部分思路还没有完成，但又不能空着不写内容，这时可以用pass语句来占位，也可以当做是一个标记，然后将来再实现代码。比如下面这样：():
例3，pass语句在循环中的使用：
pass也常用于为循环语句编写一个空的主体，比如说你想一个while语句的无限循环，每次迭代时不需要任何操作，你可以这样写：:
我们同样可以在使用for循环语句，定义类时使用pass语句。总之，pass 什么也不做，就是为了占位，防止语法错误。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e46893a889c930626e317252839b672/" rel="bookmark">
			python中opencv怎么检测双眼_使用OpenCV在Python中进行人脸和眼睛检测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用的模块：
python-opencv(cv2)
python-opencv(cv2)
Opencv(Open source computer vision) 是一个python库，可帮助我们解决计算机视觉问题。
下载python-opencv(cv2)通用方式：pip install python-opencv
Pycharm用户：Pycharm用户可以从项目解释器下载此模块。
在这里，我们将检测个人的脸部和眼睛。为此，我们使用系统的网络摄像头和XML文件来检测面部和眼睛。我们将在帧中检测到面部，然后将眼睛插入面部，因此我们将进入面部坐标并检测眼睛，并在检测到的面部和眼睛上绘制矩形。
与面部和眼睛检测相关的功能cv2.CascadeClassifier(“ ”)：此函数用于获取面部和眼睛的提取物，以及如何检测它们。
cv2.Videocapture()：这是用于通过我们系统的网络摄像头进行视频捕获。
.detectmultiscale(，1.3,5)：检测帧中的面部或眼睛。
cv2.rectangle(，(，，()，厚度= )
注意：面部和眼睛的检测将处于灰度模式。
用于面部和眼睛检测的XML文件的链接为：人脸： https : //github.com/abhinav0606/Face-and-Eyes-Tracker/blob/master/face.xml
眼睛： https ： //github.com/abhinav0606/Face-and-Eyes-Tracker/blob/master/eye.xml
用于检测人脸和眼睛的Python代码
# 导入模块
import cv2
# 现在我们有了haarcascades文件
# 检测脸部和眼睛检测脸部
faces=cv2.CascadeClassifier("face.xml")
# 侦测眼睛
eyes=cv2.CascadeClassifier("eye.xml")
# 通过网络摄像头捕获帧
capture=cv2.VideoCapture(0)
# 现在运行网络摄像头的循环
while True:
# 阅读网络摄像头
ret,frame=capture.read()
# 现在脸在框架中
# 检测是通过灰度框完成的
gray_frame=cv2.cvtColor(frame,cv2.COLOR_BGR2GRAY)
face=faces.detectMultiScale(gray_frame,1.3,5)
# 现在进入面部及其位置
for (x,y,w,h) in face:
# 在脸上绘制矩形
cv2.rectangle(frame,(x,y),(x+w,y+h),(0,0,255),thickness=4)
# 现在眼睛在脸上
# 所以我们必须将脸框设为灰色
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e46893a889c930626e317252839b672/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9ee92e19a98958fba962748b1b388a6/" rel="bookmark">
			2021-01-28
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 今晚给一台树莓派安装远程frpc开机启动，rc.loca,.desktop等方法都试了不行，service的方法找到一篇文章，大致内容如下，但是还是有很多问题，所以予以纠正，并列出真实多次验证可用的frpc在树莓派上的自开机启动程序，以节省开发人员时间
第一步
sudo cp frpc /usr/local/bin/frpc sudo mkdir /etc/frpc sudo cp frpc.ini /etc/frpc/frpc.ini 第二步
sudo vi /usr/lib/systemd/system/frpc.service 并填入如下内容，备注：After=很关键，Restart=on-failure也很关键，因为可能启动的时候电脑还没有连上网，而frpc不会自动重连
[Unit] Description=frpc Wants=network-online.target After=network.target After=multi-user.target [Service] TimeoutStartSec=30 ExecStart=/usr/local/bin/frpc -c /etc/frpc/frpc.ini ExecStop=/bin/kill $MAINPID Restart=on-failure RestartSec=3 [Install] WantedBy=multi-user.target 第三部，设置开机启动，并立即启动
sudo systemctl enable frpc sudo systemctl start frpc 备注：看日志
sudo systemctl status frpc 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0c12a013a381488e70528c758cf9113/" rel="bookmark">
			C&#43;&#43;/OpenCV:Error: Assertion failed ((unsigned)i0 ＜ (unsigned)(size.p[0] * size.p[1]))
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Error: Assertion failed ((unsigned)i0 &lt; (unsigned)(size.p[0] * size.p[1])) in cv::Mat::at, file d:\opencv\build\include\opencv2\core\mat.inl.hpp, line 1150 OpenCV中这种错误基本都是访问像素时指针越界造成的
解决办法：
1、检查指针下标是否正确
2、row和col是否写反了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91c6e3debcd6c4fb91fda10f874a70d5/" rel="bookmark">
			vue &#43; ts 项目中Prop的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要使vue支持ts写法，我们需要用到vue-property-decorator，这个组件完全依赖于vue-class-componet
首先安装：
npm i -D vue-property-decorator @Prop(options: (PropOptions | Constructor[] | Constructor) = {}) @Prop装饰器接收一个参数，这个参数可以有三种写法：
PropOptions ，包含以下选项：type(类型), required(必填), default(默认值), validator(验证函数) Constructor[]， 指定prop的可选类型；Constructor，如String，Number，Boolean，Array，Object，Date，Function，Symbol或自定义函数类型等，指定prop的类型 如下面例子：
import { Vue, Component, Prop } from 'vue-property-decorator' @Component export default class Component extends Vue { // number类型 @Prop(Number) readonly propA: number | undefined // 默认值为'default value' @Prop({ default: 'default value' }) readonly propB!: string @Prop([String, Boolean]) readonly propC: string | boolean | undefined @Prop({ default: () =&gt; { return []; } }) readonly propD: {}[] } 注：属性的类型后面需要加上undefined 类型；或者在属性名后面加上!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91c6e3debcd6c4fb91fda10f874a70d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/321e5a25fdaee50bb4dfeac9e3f5e683/" rel="bookmark">
			解决 Could not find com.android.tools.build:gradle 问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现在CSDN的文章也不靠谱，都是复制粘贴。回到问题
repositories 也设置了 下载 gradle-6.8.1-all.zip setting -》 gradle -》 use gradle from 选择 ‘gradle-wrapper.propertiers’ setting -》 gradle -》 gradle user home 选择解压 gradle-6.8.1-all.zip 后的目录
下面关键的来了
dependencies { classpath 'com.android.tools.build:gradle:4.0.0' } 这个是插件版本，并不是你的 gradle 的版本，
插件跟gradle版本对比看如下链接：
https://developer.android.google.cn/studio/releases/gradle-plugin.html
我之前一直把插件版本跟 gradle 写成一样，结果怎么都是报 Could not find com.android.tools.build:gradle 错误。希望你避免踩坑
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9dbb62cdbd075c610574bad112988bfd/" rel="bookmark">
			python datetime 时区,带有时区的Python datetime.now（）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		I have a timezone which is float (for example 4.0).
I want to construct datetime with given timezone.
I tried this,
datetime.now(timezone)
but it throws
TypeError: tzinfo argument must be None or of a tzinfo subclass, not type 'float'
So I wonder how can I make tzinfo from float?
解决方案
If you are using Python 3.2 or newer, you need to create a datetime.timezone() object; it takes an offset as a datetime.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9dbb62cdbd075c610574bad112988bfd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e22beeeefe46126d5e9e49ceca3187ca/" rel="bookmark">
			vue 加载展示md文件（markdown语法  .md后缀的文件）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. 安装依赖包
2. 在vue.config.js中添加配置
3. 导入样式
4. 导入md文件
5. 注册为组件
6. 在页面中使用
最终效果
1. 安装依赖包 npm i vue-markdown-loader -D npm i vue-loader vue-template-compiler -D npm i github-markdown-css -D npm i highlight.js -D 若报错 Vue packages version mismatch，则安装与 vue-template-compiler 版本一致的vue即可
npm install vue@2.6.12 --save 2. 在vue.config.js中添加配置 chainWebpack: config =&gt; { config.module.rule('md') .test(/\.md/) .use('vue-loader') .loader('vue-loader') .end() .use('vue-markdown-loader') .loader('vue-markdown-loader/lib/markdown-compiler') .options({ raw: true }) } 3. 导入样式 在 .vue 文件中局部导入，或在 main.js 中全局导入
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e22beeeefe46126d5e9e49ceca3187ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/649e93a2dbf9d6a334902aa10bb6783e/" rel="bookmark">
			CSS3 属性 transform 详解之（旋转:rotate,缩放:scale,倾斜:skew,移动:translate)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在CSS3中，可以利用 transform ( 变形 ) 功能来实现文字或图像的旋转、缩放、倾斜、移动这四种类型的变形处理，本文将对此做详细介绍。
一. 旋转 rotate 用法：transform: rotate(45deg);
共一个参数“角度”，单位deg为度的意思，正数为顺时针旋转，负数为逆时针旋转，上述代码作用是顺时针旋转45度。
二. 缩放 scale 用法：transform: scale(0.5) 或者 transform: scale(0.5, 2)
参数表示缩放倍数:
一个参数时：表示水平和垂直同时缩放该倍率
两个参数时：第一个参数指定水平方向的缩放倍率，第二个参数指定垂直方向的缩放倍率。
三. 倾斜 skew 用法：transform: skew(30deg) 或者 transform: skew(30deg, 30deg);
参数表示倾斜角度，单位deg
一个参数时：表示水平方向的倾斜角度；
两个参数时：第一个参数表示水平方向的倾斜角度，第二个参数表示垂直方向的倾斜角度。
关于skew倾斜角度的计算方式表面上看并不是那么直观，这里借鉴某大拿绘制的图举例说明一下：
首先需要说明的是skew的默认原点transform-origin是这个物件的中心点
四. 移动 translate 用法：transform: translate(45px) 或者 transform: translate(45px, 150px);
参数表示移动距离，单位px，
一个参数时：表示水平方向的移动距离；
两个参数时：第一个参数表示水平方向的移动距离，第二个参数表示垂直方向的移动距离。
五. 基准点 transform-origin 在使用 transform 方法进行文字或图像的变形时，是以元素的中心点为基准点进行的。使用transform-origin属性，可以改变变形的基准点。
用法：transform-origin: 10px 10px;
共两个参数，表示相对左上角原点的距离，单位px，第一个参数表示相对左上角原点水平方向的距离，第二个参数表示相对左上角原点垂直方向的距离；
两个参数除了可以设置为具体的像素值，其中第一个参数可以指定为left、center、right，第二个参数可以指定为top、center、bottom。
六. 多方法组合变形 上面我们介绍了使用 transform 对元素进行旋转、缩放、倾斜、移动的方法，这里讲介绍综合使用这几个方法来对一个元素进行多重变形。
用法：
transform: rotate (45deg)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/649e93a2dbf9d6a334902aa10bb6783e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7a4df3897739b44e3736263b5e2e162/" rel="bookmark">
			CentOS 8 安装问题记录Operating System not found
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 CentOS 8 安装问题记录Operating System not found 下载镜像安装方式安装问题汇总 博文搬迁：www.xiwenqin.com 随缘访问 下载镜像 每逢下载必提的事情是3大运营商对国外网站的访问速度：联通》电信》移动。假如你用的是移动，估计你会很遗憾。镜像下载地址从官网就可以了，一般都有国内代理站点，速度很快，官网会推荐快的下载链接，比如下面的，有阿里，华为，网易等：
http://mirrors.aliyun.com/centos/8.1.1911/isos/x86_64/CentOS-8.1.1911-x86_64-dvd1.iso
http://mirrors.163.com/centos/8.1.1911/isos/x86_64/CentOS-8.1.1911-x86_64-dvd1.iso
http://mirrors.huaweicloud.com/centos/8.1.1911/isos/x86_64/CentOS-8.1.1911-x86_64-dvd1.iso
安装方式 实体机，或者虚拟机：
推荐虚拟机 ，安装非常方便，本篇基于虚拟机安装实现，且有网情况下。选择镜像后，默认模式安装即可；实体机的化，需要一个U盘制作启动盘，我常用的软件是UltraISO，试用模式就可以了，制作方法超级简单，百度即可； 安装问题汇总 安装卡住，界面上的提示信息为：Operating System not found 原因是vmware自动识别镜像地址是错的，需要手工调整下，例如下图，我这边选了“使用ISO映像文件”，手动指定。
改好之后，再次启动虚拟机。不再报错，等待一段时间后，进入自动安装模式。在安装过程中，会询问语言设置。高手可用英文，一般人用中文会在后面的安装环节看懂一些。再接下来安装界面，会提示黄字警告，而且begin安装的按钮无法点击，哪里警告点哪里，无非就是确认下硬盘设置，以及设置root用户密码。安装过程，我没敢断网。内网同志也许会遇到更多问题吧。安装完成后，rebot按钮点一下。随后，有个 license information：许可证信息，提示黄色感叹号，仍是点进去看下，要勾选同意才行。会提示创建一个普通用户，而且不能用root，那就建一个。其实整个安装过程类似于windows了，都是图形化界面。做得算比较好的一个系统了。至此，安装完毕。后续会在使用过程中继续当小白鼠，记录各种问题 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbd49d00402b252a1449f5dfc82aa6ca/" rel="bookmark">
			CentOS8虚拟机vmware tools无法拖放文件的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CentOS8虚拟机vmware tools无法拖放文件的问题 原因解决办法步骤 自建博客地址：www.xiwenqin.com 随缘访问。这边的问题是发生于最小安装模式，另外还有一篇是推荐安装模式，问题少一些，但也不是完全没问题。可同时参考。 原因 貌似只是因为我没有开启网卡。因为测试一段文字，从本地复制后，是可以黏贴到centos8虚拟机的，然后一些文件，却不行。如果你把有线网络连上后，还是不能拖拽文件进去，就按下面的步骤重装下vmware-tools把。
解决办法 手工重新安装一下vmware tools 下载地址（官网）：https://my.vmware.com/cn/group/vmware/details?downloadGroup=VMTOOLS1032&amp;productId=353
步骤 卸载原有的VMware tools, sudo su 切换root，命令：yum remove open-vm-tools 就能完成卸载
用xshell 远程登陆centos8虚拟机，把下载的VMware tools 包传进去。我用的是SFTP方式，put命令即可。
注意，在put之前，请先解压，找到目标。这个安装包是既有windows，也有Linux，要解压好多层。linux.iso 这个镜像也要解压。直到发现这么个文件夹：vmware-tools-distrib 上述目录下，有个安装文件，直接敲命令./vmware-install.pl 就行了。如果遇到权限问题，自己想办法给目录赋予权限，因为我是拷贝到用户的下载文件夹下，所以没遇到权限问题。
注意上述截图还是差了一步，没切root，启动安装后，所有询问项都直接回车。全部默认安装。
然后报错了，如图：
不知有没有影响，就先重启下centos8，然后又重新安装了一遍，安装的时候会提示先卸载，哪就卸载再安装。然后，还是报这个错。但意外发现，已经可以拷贝文件了。所以，原因不明。可能跟需要重启一下有关。
理论上重装是可以的，网上也有类似的贴子。至于我这边的这个报错，也不懂为啥（也许之前的yum remove open-vm-tools没卸干净，也许是别的原因），反正一次安装不行，就再重装，加上重启。希望各位和我一样好运。
最后我发现我好像搞了一个乌龙。只能从里面拖文件到外面，无法从外面拖文件到里面，这个问题原因只是因为我有线网卡未开启，第五步骤的报错，也是这个原因。重启后，网卡又断了。CENTOS8默认安装完以后，竟然需要手动连接网卡。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe174e0edff39db0bc7ed8532258838a/" rel="bookmark">
			域名注册使用，的坑。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		个人网站的发布
上面说一样，其实是指备案的事情。域名备案是三大运营商进行的拦截，虽然页面链接能跳到阿里云，但并非阿里云做的拦截。 想要不备案，只有一个办法，就是购买境外的云服务器（阿里云有卖，价格嘛）。或者花钱备案，但是备案有个问题，不是一次备案终身靠谱。一旦将域名解析到备案信息以外的服务器+IP，也是会被取消备案的。所以会有风险，只能试试。 永久备案，就是永久使用确定的公网IP地址。去运营商那边买固定IP吧，听说最便宜的2M也要接近2000一年。不如云服务器划算。买个国内的，乖乖备案吧。
一般这样就行了，但是，DNS解析生效时间特别长。可以测试一下，cmd里 ping 目标域名。通了就能用了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/102796f53f05b6658a52c713aa71506b/" rel="bookmark">
			mysql sub-3_MySQL date_sub()函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在本教程中，您将学习如何使用MySQL DATE_SUB()函数从日期中减去时间值。
MySQL DATE_SUB函数简介
DATE_SUB()函数从DATE或DATETIME值中减去时间值(或间隔)。 下面说明了DATE_SUB()函数的语法：
DATE_SUB(start_date,INTERVAL expr unit);
DATE_SUB()函数接受两个参数：
start_date是DATE或DATETIME的起始值。
expr是一个字符串，用于确定从起始日期减去的间隔值。unit是expr可解析的间隔单位，例如DAY，HOUR等
以下语句使用DATE_SUB()函数从2017年7月4日减去1天：
mysql&gt; SELECT DATE_SUB('2017-09-04',INTERVAL 1 DAY) result;
+------------+
| result |
+------------+
| 2017-09-03 |
+------------+
1 row in set
-- 求昨天的日期值： 将今天的日期值减去 1 天
mysql&gt; SELECT DATE_SUB(curdate(),INTERVAL 1 DAY) result;
+------------+
| result |
+------------+
| 2017-08-09 |
+------------+
1 row in set
在这个例子中，开始日期是2017-09-04，它是yyyy-mm-dd格式。 INTERVAL 1 DAY被解析为1天的时间间隔。DATE_SUB()函数的结果是2017-09-03的字符串值。
类似于DATE_ADD()函数，DATE_SUB()函数的返回值的数据类型可以是：
如果第一个参数是DATETIME，则返回值应为DATETIME，或者该间隔具有时间元素，如小时，分钟，秒等。
否则返回一个字符串。
请参阅以下示例：
示例-1
mysql&gt; SELECT DATE_SUB('2017-09-04',INTERVAL 3 HOUR) result;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/102796f53f05b6658a52c713aa71506b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/612963719970e465c22f0d08466a3280/" rel="bookmark">
			MySQL数据库binlog恢复_mysql-binlog日志恢复数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		binlog日志用于记录所有更新了数据或者已经潜在更新了数据的所有语句。语句以“事件”的形式保存，它描述数据更改。当我们因为某种原因导致数据库出现故障时，就可以利用binlog日志来挽回(前提是已经配置好了binlog)，接下来我们来配置
一、开启mysql-binlog日志
在mysql配置文件my.cnf加上如下配置
[mysqld]
log-bin=mysql-bin
重启mysql
service mysqld restart
二、备份数据库
1)先查看一下当前数据库情况
mysql&gt; select * from t1;
+------+
| id |
+------+
| 1 |
| 2 |
+------+
2 rows in set (0.00 sec)
2)备份数据到/tmp/test.sql
[root@localhost ~]# whereis mysqldump
mysqldump: /usr/bin/mysqldump /usr/share/man/man1/mysqldump.1.gz
[root@localhost ~]# /usr/bin/mysqldump -uroot -p123456 test &gt; /tmp/test.sql
三、这时模拟误操作(插入3条数据，删除数据库)
mysql&gt; insert into t1 values(3);
Query OK, 1 row affected (0.00 sec)
mysql&gt; insert into t1 values(4);
Query OK, 1 row affected (0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/612963719970e465c22f0d08466a3280/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ddd37c78c167ce88760a93ae3940cdff/" rel="bookmark">
			Flink &#43; Iceberg  全场景实时数仓的建设实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		整理｜路培杰（Flink 社区志愿者）
摘要：Apache Flink 是目前大数据领域非常流行的流批统一的计算引擎，数据湖是顺应云时代发展潮流的新型技术架构，以 Iceberg、Hudi、Delta 为代表的解决方案应运而生，Iceberg 目前支持 Flink 通过 DataStream API /Table API 将数据写入 Iceberg 的表，并提供对 Apache Flink 1.11.x 的集成支持。
本文由腾讯数据平台部高级工程师苏舒分享，主要介绍腾讯大数据部门基于 Apache Flink 和 Apache Iceberg 构建实时数仓的应用实践，介绍主要包括如下几个方面：
背景及痛点
数据湖 Apache Iceberg 的介绍
Flink+Iceberg 构建实时数仓
未来规划
Tips：点击文末「阅读原文」即可回顾作者分析的原版视频～
一．背景及痛点
如图 1 所示，这是当前已经助力的一些内部应用的用户，其中小程序和视频号这两款应用每天或者每个月产生的数据量都在 PB 级或者 EB 级以上。
图1
这些应用的用户在构建他们自己的数据分析平台过程中，他们往往会采用图 2 这样的一个架构，相信大家对这个架构也非常的熟悉了。
1.数据平台架构
业务方比如腾讯看点或者视频号的用户，他们通常会采集应用前端的业务打点数据以及应用服务日志之类的数据，这些数据会通过消息中间件（Kafka/RocketMQ）或者数据同步服务 (flume/nifi/dataX) 接入数仓或者实时计算引擎。
在数仓体系中会有各种各样的大数据组件，譬如 Hive/HBase/HDFS/S3，计算引擎如 MapReduce、Spark、Flink，根据不同的需求，用户会构建大数据存储和处理平台，数据在平台经过处理和分析，结果数据会保存到 MySQL、Elasticsearch 等支持快速查询的关系型、非关系型数据库中，接下来应用层就可以基于这些数据进行 BI 报表开发、用户画像，或基于 Presto 这种 OLAP 工具进行交互式查询等。
图2
2.Lambda 架构的痛点
在整个过程中我们常常会用一些离线的调度系统，定期的（T+1 或者每隔几小时）去执行一些 Spark 分析任务，做一些数据的输入、输出或是 ETL 工作。离线数据处理的整个过程中必然存在数据延迟的现象，不管是数据接入还是中间的分析，数据的延迟都是比较大的，可能是小时级也有可能是天级别的。另外一些场景中我们也常常会为了一些实时性的需求去构建一个实时处理过程，比如借助 Flink+Kafka 去构建实时的流处理系统。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ddd37c78c167ce88760a93ae3940cdff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d97b85d66f5ab86462e24a7a69e2a751/" rel="bookmark">
			过滤器版本的Cookie,Session自动登录案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		过滤器版本的Cookie,Session自动登录案例
先写几个简单的html页面(主页,登录,注册,个人中心)
注册代码
@WebServlet("/register") public class RegisterServlet extends HttpServlet{ @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doPost(req, resp); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { String userName=req.getParameter("userName"); String password=req.getParameter("password"); String repassword=req.getParameter("repassword"); if(userName==null||userName.isEmpty()||password==null||password.isEmpty()) { System.out.println("对不起,用户名或密码不能为空"); req.getRequestDispatcher("pages/register.html").forward(req, resp); return; } BufferedReader br=new BufferedReader(new FileReader("d://demo.txt")); String str; while((str=br.readLine())!=null) { String[] strs=str.split("="); if(strs[0].equals(userName)) { System.out.println("对不起,用户名已存在"); req.getRequestDispatcher("pages/register.html").forward(req, resp); br.close(); return; } } br.close(); if(password.equals(repassword)) { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d97b85d66f5ab86462e24a7a69e2a751/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/007b325b6312cebff0dc25c5d8036e18/" rel="bookmark">
			Golang设计模式(抽象工厂模式)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		模式定义 为了更清晰地理解工厂方法模式，需要先引入两个概念：
产品等级结构 ：产品等级结构即产品的继承结构，如一个抽象类是电视机，其子类有海尔电视机、海信电视机、TCL电视机，则抽象电视机与具体品牌的电视机之间构成了一个产品等级结构，抽象电视机是父类，而具体品牌的电视机是其子类。
产品族 ：在抽象工厂模式中，产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品，如海尔电器工厂生产的海尔电视机、海尔电冰箱，海尔电视机位于电视机产品等级结构中，海尔电冰箱位于电冰箱产品等级结构中。
抽象工厂模式(Abstract Factory Pattern)：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，属于对象创建型模式。
模式结构 抽象工厂模式包含如下角色：
AbstractFactory：抽象工厂
ConcreteFactory：具体工厂
AbstractProduct：抽象产品
Product：具体产品
适用环境 在以下情况下可以使用抽象工厂模式：
一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有类型的工厂模式都是重要的。
系统中有多于一个的产品族，而每次只使用其中某一产品族。
属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来。
系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。
代码实现 //产品等级结构 ： //产品等级结构即产品的继承结构，如一个抽象类是电视机， //其子类有海尔电视机、海信电视机、TCL电视机，则抽象电视机与具体品牌的电视机之间构成了一个产品等级结构， //抽象电视机是父类，而具体品牌的电视机是其子类。 //产品族 ： //在抽象工厂模式中，产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品， //如海尔电器工厂生产的海尔电视机、海尔电冰箱，海尔电视机位于电视机产品等级结构中，海尔电冰箱位于电冰箱产品等级结构中。 //AbstractFactory：抽象工厂 //ConcreteFactory：具体工厂 //AbstractProduct：抽象产品 //Product：具体产品 package main import "fmt" type Ifactory interface { CreateTvFactory() TvFactory CreateRefrigeratorFactory() RefrigeratorFactory } type TvFactory interface { CreateTV() Tv } type RefrigeratorFactory interface { CreateRefrigerator() Refrigerator } type Tv interface { Wacht() } type Refrigerator interface { GetFood() } type tv struct { Name string } func (t *tv) Wacht() { fmt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/007b325b6312cebff0dc25c5d8036e18/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/910f295291eef992095ff1259ba302f4/" rel="bookmark">
			c&#43;&#43;函数,求每门课成绩
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在这里插入代码片 ```#include&lt;iostream&gt; #include&lt;stdio.h&gt; using namespace std; void chengji(int s[],int n){ for(int i=0;i&lt;n;i++){ cout&lt;&lt;"第"&lt;&lt;i+1&lt;&lt;"门课程:"&lt;&lt;s[i]&lt;&lt;endl; } } void scoreAdd(int s[],int n,int val){ for(int i=0;i&lt;n;i++){ s[i]+=val; } } int main(){ int s[3]={87,976,65}; //把数组作为函数的参数是,这个函数中,可以修改这个函数的值 chengji(s, 3); scoreAdd(s, 3, 5); chengji(s, 3); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9aff4afddf34022cac45195980dfa48f/" rel="bookmark">
			Pytorch-怎么让两个dataloader打乱顺序相同，自定义一个sampler
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		思路：自定义一个sampler，将采样方式传进不同的dataloader，则取出的数据一致
代码：
import torch from torch import nn from torch.utils.data import Dataset from torch.utils.data import DataLoader class MyDataset_v1(Dataset): def __init__(self): self.data = [1, 2, 3, 4] def __len__(self): return len(self.data) def __getitem__(self, item): return self.data[item] class MyDataset_v2(Dataset): def __init__(self): self.data = [1.1, 2.2, 3.3, 4.4] def __len__(self): return len(self.data) def __getitem__(self, item): return self.data[item] class SamplerDef(object): def __init__(self, data_source, indices): self.data_source = data_source self.indices = indices def __iter__(self): return iter(self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9aff4afddf34022cac45195980dfa48f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a17f0eee565741389afca1245cfe1c34/" rel="bookmark">
			mysql count 缓慢_mysql中使用count(*)查询非常慢的原因和解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在查询一个200多万的表中记录数量时，使用select count(*) from 表名时，需要50几秒才能看到结果，时间长的有点让人受不了。
于是先给表增加两个索引index_addtime和index_code，结果创建每个索引都用去一分多的时间，创建完成后，再查询记录数量，还是50多秒，索引没有太大作用。
再去检查了一下表结构，
CREATE TABLE `表名` (
`id` int(255) NOT NULL AUTO_INCREMENT,
`code` varchar(10) DEFAULT NULL,
`Close` decimal(20,2) DEFAULT '0.00',
`addtime` int(11) NOT NULL DEFAULT '0' COMMENT '时间',
PRIMARY KEY (`id`),
KEY `index_addtime` (`addtime`),
KEY `index_code` (`code`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
发现ENGINE=InnoDB这个，由于这个是用于事务处理才加这个，我的表没有用到事务处理，所以把这个改成ENGINE=MyISAM，然后再使用select count(*) from 【表名】查询记录数量，居然是0.000s秒得到记录数量，这两个速度相差太多了。原来问题出现在这里。
大家在创建表的时候，如果用不到事务的话，就不要使用InnoDB，不然太影响速度了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0cf0353c14efc37a6dbe53ac8fb636ce/" rel="bookmark">
			Warning: This Python interpreter is in a conda environment, but the environment has not been activat
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在cmd中输入python出现 Warning: This Python interpreter is in a conda environment, but the environment has
not been activated. Libraries may fail to load. To activate this environment
please see https://conda.io/activation
开始-&gt;设置-&gt;环境变量 点第一个
找到path，双击 新建两次，添加你存放的python的地址还有其中的Scripts的地址 例如我的是
D:\python3.8.5
D:\python3.8.5\Scripts
并且将两条都上移到最上面
然后一直确定就行了
再去cmd输入python，问题解决 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d829889fcaf3aad7d8b502952fead502/" rel="bookmark">
			java设计模式之单例设计模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java设计模式之单例设计模式 单例设计模式介绍 所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法(静态方法)
比如Hibernate的SessionFactory，它充当数据存储源的代理，并负责创建Session对象。SessionFactory并不是轻量级的，一般情况下，一个项目通常只需要一个SessionFactory就够，这是就会使用到单例模式。
单例设计模式八种方式 方式一: 饿汉式(静态常量) 步骤如下：
​ 1.构造器私有化 (防止 new )
​ 2.类的内部创建对象
​ 3.向外暴露一个静态的公共方法。getInstance
代码示例： package com.wxit.singleton; /** * @Author wj **/ public class SingletonTest01 { public static void main(String[] args) { //测试 Singleton instance1 = Singleton.getInstance(); Singleton instance2 = Singleton.getInstance(); System.out.println(instance1 == instance2); } } //饿汉式(静态变量) class Singleton { //1.构造器私有化，外部不能new private Singleton(){ } //2.本类内部创建对象实例 private final static Singleton instance = new Singleton(); //3.提供一个公有的静态方法，返回对象实例 public static Singleton getInstance(){ return instance; } } 优缺点说明 优点：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d829889fcaf3aad7d8b502952fead502/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9faf87333e630c6af432b0c1cba5f56/" rel="bookmark">
			Flink的一致性保证
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​前言介绍 Flink的检查点和恢复机制定期的会保存应用程序状态的一致性检查点。在故障的情况下，应用程序的状态将会从最近一次完成的检查点恢复，并继续处理。尽管如此，可以使用检查点来重置应用程序的状态无法完全达到令人满意的一致性保证。相反，source和sink的连接器需要和Flink的检查点和恢复机制进行集成才能提供有意义的一致性保证。
为了给应用程序提供恰好处理一次语义的状态一致性保证，应用程序的source连接器需要能够将source的读位置重置到之前保存的检查点位置。当处理一次检查点时，source操作符将会把source的读位置持久化，并在恢复的时候从这些读位置开始重新读取。支持读位置的检查点的source连接器一般来说是基于文件的存储系统，如：文件流或者Kafka source（检查点会持久化某个正在消费的topic的读偏移量）。如果一个应用程序从一个无法存储和重置读位置的source连接器摄入数据，那么当任务出现故障的时候，数据就会丢失。也就是说我们只能提供at-most-once）的一致性保证。
Fink的检查点和恢复机制和可以重置读位置的source连接器结合使用，可以保证应用程序不会丢失任何数据。尽管如此，应用程序可能会发出两次计算结果，因为从上一次检查点恢复的应用程序所计算的结果将会被重新发送一次（一些结果已经发送出去了，这时任务故障，然后从上一次检查点恢复，这些结果将被重新计算一次然后发送出去）。所以，可重置读位置的source和Flink的恢复机制不足以提供端到端的恰好处理一次语义，即使应用程序的状态是恰好处理一次一致性级别。
Flink 中的一个大的特性就是exactly-once的特性，我们在一般的流处理程序中，会有三种处理语义
AT-MOST-ONCE(最多一次)当故障发生的时候，什么都不干。就是说每条消息就只消费一次。
AT-LEAST-ONCE(至少一次)为了确保数据不丢失，确保每个时间都得到处理，一些时间可能会被处理多次。
EXACTLY-ONCE(精确一次)每个时间都精确处理一次
端到端的保证：
内部保证--- checkpoint
source端---可重设数据的读取位置
sink端---从故障恢复时，数据不会重复写入外部系统
Flink(checkpoint)和source端(Kafka)可以保证不出问题。但一个志在提供端到端恰好处理一次语义一致性的应用程序需要特殊的sink连接器。sink连接器可以在不同的情况下使用两种技术来达到恰好处理一次一致性语义：幂等性写入和事务性写入。
幂等与事务 1. 幂等性写入 一个幂等操作无论执行多少次都会返回同样的结果。例如，重复的向hashmap中插入同样的key-value对就是幂等操作，因为头一次插入操作之后所有的插入操作都不会改变这个hashmap，因为hashmap已经包含这个key-value对了。另一方面，append操作就不是幂等操作了，因为多次append同一个元素将会导致列表每次都会添加一个元素。在流处理程序中，幂等写入操作是很有意思的，因为幂等写入操作可以执行多次但不改变结果。所以它们可以在某种程度上缓和Flink检查点机制带来的重播计算结果的效应。
需要注意的是，依赖于幂等性sink来达到exactly-once语义的应用程序，必须保证在从检查点恢复以后，它将会覆盖之前已经写入的结果。例如，一个包含有sink操作的应用在sink到一个key-value存储时必须保证它能够确定的计算出将要更新的key值。同时，从Flink程序sink到的key-value存储中读取数据的应用，在Flink从检查点恢复的过程中，可能会看到不想看到的结果。当重播开始时，之前已经发出的计算结果可能会被更早的结果所覆盖（因为在恢复过程中）。所以，一个消费Flink程序输出数据的应用，可能会观察到时间回退，例如读到了比之前小的计数。也就是说，当流处理程序处于恢复过程中时，流处理程序的结果将处于不稳定的状态，因为一些结果被覆盖掉，而另一些结果还没有被覆盖。一旦重播完成，也就是说应用程序已经通过了之前出故障的点，结果将会继续保持一致性。
2. 事务性写入 实现端到端的恰好处理一次一致性语义的方法基于事务性写入。其思想是只将最近一次成功保存的检查点之前的计算结果写入到外部系统中去。这样就保证了在任务故障的情况下，端到端恰好处理一次语义。应用将被重置到最近一次的检查点，而在这个检查点之后并没有向外部系统发出任何计算结果。通过只有当检查点保存完成以后再写入数据这种方法，事务性的方法将不会遭受幂等性写入所遭受的重播不一致的问题。尽管如此，事务性写入却带来了延迟，因为只有在检查点完成以后，我们才能看到计算结果。
Flink提供了两种构建模块来实现事务性sink连接器：write-ahead-log（WAL，预写式日志）sink和两阶段提交sink。WAL式sink将会把所有计算结果写入到应用程序的状态中，等接到检查点完成的通知，才会将计算结果发送到sink系统。因为sink操作会把数据都缓存在状态后段，所以WAL可以使用在任何外部sink系统上。尽管如此，WAL还是无法提供刀枪不入的恰好处理一次语义的保证，再加上由于要缓存数据带来的状态后段的状态大小的问题，WAL模型并不十分完美。
与之形成对比的，2PC sink需要sink系统提供事务的支持或者可以模拟出事务特性的模块。对于每一个检查点，sink开始一个事务，然后将所有的接收到的数据都添加到事务中，并将这些数据写入到sink系统，但并没有提交（commit）它们。当事务接收到检查点完成的通知时，事务将被commit，数据将被真正的写入sink系统。这项机制主要依赖于一次sink可以在检查点完成之前开始事务，并在应用程序从一次故障中恢复以后再commit的能力。
2PC协议依赖于Flink的检查点机制。检查点屏障是开始一个新的事务的通知，所有操作符自己的检查点成功的通知是它们可以commit的投票，而作业管理器通知一个检查点成功的消息是commit事务的指令。于WAL sink形成对比的是，2PC sinks依赖于sink系统和sink本身的实现可以实现恰好处理一次语义。更多的，2PC sink不断的将数据写入到sink系统中，而WAL写模型就会有之前所述的问题。
事务写的方式能提供端到端的Exactly-Once一致性，它的代价也是非常明显的，就是牺牲了延迟。输出数据不再是实时写入到外部系统，而是分批次地提交。目前来说，没有完美的故障恢复和Exactly-Once保障机制，对于开发者来说，需要在不同需求之间权衡
开发理解
3. 开发过程的理解
3.1 Flink如何管理Kafka consumer offsets
checkpoint是Flink的内部机制，可以从故障中恢复。通俗的理解是checkpoint是Flink应用程序状态的一致性副本，包括输入的读取位置(offset)。如果发生故障，Flink将通过从checkpoint加载状态后端并从恢复的读取位置继续恢复应用程序，可以做到所谓的断点续传。
checkpoint使Flink具有容错能力，并确保在发生故障时具有容错的能力。应用程序可以定期触发检查点。
Flink中的Kafka消费者将Flink的检查点机制与有状态运算符集成在一起，其状态是所有Kafka分区中的读取偏移量。触发checkpoint时，每个分区的偏移量都存储在checkpoint中。Flink的checkpoint机制确保所有操作员任务的存储状态是一致的，即它们基于相同的输入数据。当所有操作员任务成功存储其状态时，检查点完成。因此，当从潜在的系统故障重新启动时，系统提供一次性状态更新保证。
3.2 两阶段提交
在分布式系统中，为了让每个节点都能够感知到其他节点的事务执行状况，需要引入一个中心节点来统一处理所有节点的执行逻辑，这个中心节点叫做协调者（coordinator），被中心节点调度的其他业务节点叫做参与者（participant）。
接下来正式介绍2PC。顾名思义，2PC将分布式事务分成了两个阶段，两个阶段分别为提交请求和提交。协调者根据参与者的响应来决定是否需要真正地执行事务
提交请求阶段
协调者向所有参与者发送prepare请求与事务内容，询问是否可以准备事务提交，并等待参与者的响应。
参与者执行事务中包含的操作，并记录undo日志（用于回滚）和redo日志（用于重放），但不真正提交。
参与者向协调者返回事务操作的执行结果，执行成功返回yes，否则返回no
提交执行阶段
分为成功与失败两种情况。
若所有参与者都返回yes，说明事务可以提交：
协调者向所有参与者发送commit请求。
参与者收到commit请求后，将事务真正地提交上去，并释放占用的事务资源，并向协调者返回ack。
协调者收到所有参与者的ack消息，事务成功完成。
若有参与者返回no或者超时未返回，说明事务中断，需要回滚：
协调者向所有参与者发送rollback请求
参与者收到rollback请求后，根据undo日志回滚到事务执行前的状态，释放占用的事务资源，并向协调者返回ack
协调者收到所有参与者的ack消息，事务回滚完成
3.3图解 通俗的理解过程：
从kafka获取数据源：(1，2，3)这个时候数据1会经过source，热后进行到算子阶段，jobmanager触发checkpoint操作，这个时候offset会记录source消费的位置
后续数据会继续跟进,1的数据进行算子操作(比如sum),这个时候数据继续往下走进行sink，jobmanager也会触发记录算子的状态
数据1走进sink阶段，然后sink值写到一个临时文件中去，这个时候也会记录sink的状态,然后发送到kafka去（预提交），这个时候不会正真地去消费使用，因为不确定两边是否同步，这个时候会告诉flink这边已经有了，这个时候会正在的进行提交(第二阶段提交)
这个时候整个checkpoint过程才算完整，如果某个过程失败，也即checkpoint过程不完整(jobmanager会丢弃)，flink重启后会记录offset继续消费即可
按照术语来讲的话，这样理解：每当需要做checkpoint时，JobManager就在数据流中打入一个屏障（barrier），作为检查点的界限。屏障随着算子链向下游传递，每到达一个算子都会触发将状态快照写入状态后端(state BackEnd)的动作。当屏障到达Kafka sink后，触发preCommit(实际上是KafkaProducer.flush())方法刷写消息数据，但还未真正提交。接下来还是需要通过检查点来触发提交阶段。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d9faf87333e630c6af432b0c1cba5f56/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8bfc5b306d9602651dc3c4457ea5f173/" rel="bookmark">
			【机器人】正运动学，如何建立机器人各连杆坐标系和D-H参数表——1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/*
*参考资料：《机器人学导论 Introduction to Robotics Mechanics and Control》——（美）John J.Craig等
*/
注意：不管是Standard DH法还是Modified DH法，下面这些知识都是共同的基础。
一、先介绍几个简单的专业术语
1、
Link0：地杆。
Link1：和地杆相连，第一个可动的杆件。
Link2：第二个可动的杆件。
…
Linkn：第n个可动的杆件。
如图1所示：
图1
一个连杆有2个轴线，对于Link(i-1)，其左右两端的轴为Axis(i-1)、Axis(i)，两个连杆就有三个轴,如图2。
图2 二、D-H表的四个参数
a(i-1)：轴(i-1)和轴i之间的距离，即公垂线。
α(i-1)：轴(i-1)和轴i之间的夹角。
di：a(i-1)与a(i)的距离。
θ ：a(i-1)与a(i)的夹角。
三、连杆坐标系X、Y、Z轴方向的确立
通过标题二的概念，可以确定各坐标系的主轴方向：
Zi ： 转动或移动轴的方向。逆时针为正。
Xi ： 当ai≠0时，Xi沿着ai方向； 当ai=0时，Xi与Zi、Zi+1两者垂直；
Yi ： 与Zi、 Xi相互垂直，右手定则。
原点：Zi 与ai的交点。
下面我们以Modified DH法来讲解如何建立坐标系和DH参数表 ：
有两个连杆比较特殊，所以单独说一下：
1.地杆Link0：我们将地杆的坐标系与Link1的坐标系建成一样，重合。则总有a0=0，α0=0。
2.最后一个杆件Linkn：其坐标系的Xn取和X(n-1)同方向。
通过坐标系可以更简单的确定DH的四个参数：
a(i-1)：沿着X(i-1)方向，Z(i-1)和Zi间的距离。
α(i-1)：以X(i-1)方向看，Z(i-1)和Zi间的夹角。
di：沿着Zi方向，X(i-1)和Xi间的距离。
θ ：以Zi方向看，X(i-1)和Xi间的夹角。
图3
四、以书中一个例子为例，建立坐标系
注意：坐标系可能不止一种建法，比如Z1的方向可以选择垂直纸面向上，也可以垂直纸面向里，都是正确的。
五、根据上述所建立的坐标系写出DH参数表
六、机器人正运动学
根据DH表，可以知道T01、T12、T23（由于这个编辑器没法写上下标，这样替代一下0是左上标，1是左下标）；
继而可以算出T03。
我们发现里面并没有L3这个位置信息，因为我们算出的T03只是姿态，所有还有加上最后一个连杆的位置P3={L3,0，0}。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c184ccb7349db0204f6b1c5f6a7d9889/" rel="bookmark">
			开发者营地 | Android消息机制详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Handler基础 1. Handler简介 在Android中使用消息机制，通常就是指Handler机制。Handler是Android消息机制的上层接口。
Handler的使用过程很简单，通过它可以轻松地将一个任务切换到Handler所在的线程中去执行。通常情况下，Handler的使用场景就是更新UI。
示例：
public class Activity extends android.app.Activity { private Handler mHandler = new Handler(){ @Override public void handleMessage(Message msg) { super.handleMessage(msg); System.out.println(msg.what); } }; @Override public void onCreate(Bundle savedInstanceState, PersistableBundle persistentState) { super.onCreate(savedInstanceState, persistentState); setContentView(R.layout.activity_main); new Thread(new Runnable() { @Override public void run() { //...耗时操作 Message message = Message.obtain(); message.what = 1; mHandler.sendMessage(message); } }).start(); } } 在子线程中，进行耗时操作，执行完操作后，发送消息，通知主线程更新UI。这便是消息机制的典型应用场景。
2. Handler模型 Android消息机制中的五大概念：
ThreadLocal：当前线程存储的数据仅能从当前线程取出。MessageQueue：具有时间优先级的消息队列（单链表）。因为单链表在插入和删除上比较有优势。主要功能向消息池投递消息MessageQueue.enqueueMessage和取走消息池的消息MessageQueue.next。Looper：保存在ThreadLocal中的轮询消息队列，不断循环执行Looper.loop，若有新的消息到来，从MessageQueue中读取消息，按分发机制将消息分发给目标处理者。Handler：具体处理逻辑的地方，主要功能向消息池发送各种消息事件Handler.sendMessage和处理相应消息事件Handler.handleMessage。Message：需要传递的消息，可以传递数据。 3. Handler架构 消息机制的运行流程：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c184ccb7349db0204f6b1c5f6a7d9889/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2642942e298b93d7e7bc1628af9e9f3/" rel="bookmark">
			kettle实验三：基于HTTP GET请求的导入与导出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 【实验目的】
1.利用Kettle的“自定义常量数据”，“HTTP Client”组件，获取具有一定结构的网页内容，并使用。
2.熟练掌握“自定义常量数据”，“HTTP Client”，“JSON Input”组件的使用，实现网页内容的获取以及解析。
【实验原理】
通过“自定义常量数据”将需要访问的URL（网页地址）设置为常量，并将该常量传递给“HTTP Client”步骤以获取具有一定结构的网页内容的相应数据，然后使用“JSON Input”对内容进行解析，选取需要的数据，最后使用“Excel输出”步骤传递到本地的网页上进行展示。
【实验环境】
操作系统：Windows10 Kettle版本：7.1.0.0
jdk版本：1.8.0及以上版本
【实验步骤】
一、建立转换 双击spoon.bat打开kettle。（1）点击新建按钮，在下拉菜单中点击选择“转换”即可创建；（2）然后点击“保存”重命名该转换文件，保存在某个指定的路径；（3）选择输入步骤、输出步骤和跳。
二、各组件的配置 1.“自定义常量数据”的配置
Step1：双击‘自定义常量数据’组件，配置‘元数据’选项卡,设置常量名称和类型
Step2：配置‘数据’选项卡，设置常量对应的网站地址
2.“HTTP client”的配置：
双击“HTTP client”组件，勾选‘字段中选取URL’（重中之重）的请求，填写‘URL的名称’、‘编码格式’以及‘结果的字段名’。
3.“JSON Input”的配置：
Step1：双击‘JSON Input’组件，配置‘文件’选项卡，这里选取源定义在一个字段里
Step2：配置‘字段’选项卡，输入Jsonpath的路径以及输出结果的字段名称
4.“Excel的输出”配置
Step1：配置‘文件’选项卡，选取输出文件的名称和类型
Step2：配置‘字段’选项卡，获取字段并设置其类型（多余的字段可以删除）
三、执行转换 点击按钮，执行转换，结果如下：
四、实验结果: 输入文件‘preview data’：
输出文件‘test3_2.xls’：
五、实验过程中遇到的困难 HTTP Client组件无法读取网站地址，以及自定义常量的网站结果如下所示：
解决办法：上网查询相关资料后，对‘自定义常量’的‘数据’选项卡下的网站地址内容稍微进行了修改，结果如下：
六、实验总结 本次实验的目的主要是对HTTP Client获取网址的内容数据信息这个过程进行进一步实践操作，并且对有一定结构的文件使用Json的路径解析，输出期望的那部分数据。
本次实验过程中，进一步掌握了使用类似断点的爬虫操作来分析问题的主要原因，并且进一步提高了自身对问题的解决和寻找办法的能力。
附 件： 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5f5218e53ba00c114b769d928540563/" rel="bookmark">
			除了mvc模式还有什么模式_理解ASP.NET Core的MVC模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在前面的文章中，我们已经讨论过了ASP.NET Core中的中间件以及路由等功能，在本文中，我们来讨论ASP.NET Core的MVC模式。
一、理解MVC模式
MVC全名是Model View Controller，是模型(Model)－视图(View)－控制器(Controller)的缩写，它是Web应用程序中一种常用的架构模式。
MVC模式最主要的特点是关注点分离，它将应用程序分离为三个独立的部分。ASP.NET Core MVC是构建在ASP.NET Core之上的MVC框架。
要在应用程序中使用MVC，首先需要添加MVC中间件：
public void ConfigureServices(IServiceCollection services){ services.AddMvc();}public void Configure(IApplicationBuilder app, IHostingEnvironment env){ app.UseMvc();} 在ASP.NET Core MVC框架中，除了Controller、Action外，它还包括路由、模型绑定、模型验证、过滤器等功能。在上一篇文章：理解ASP.NET Core中的路由 中，我们已经讨论了ASP.NET Core中的路由，通过路由能够将请求正确地映射到相应的Controller与Action。
二、Controller与Action
Controller是一个类，它具体如下特点：
1、它继承自Controller类，或ControllerBase类；
2、它的命名以Controller结尾，如HomeController；
3、一个Controller中可以包含一个或多个Action；
Action则是定义在Controller中的public类型的方法，根据实际情况，它可以包含参数，这些参数通常会从HTTP请求对象中获取；Action方法的返回值可以是void也可以是IActionResult类型或ActionResult类型的对象。
以下一个典型的Controller：
public class BlogsController : Controller{ public IActionResult Index() { } public IActionResult GetTopN(int n) { }} 三、Action方法的返回值
对于Action方法，它的返回值IActionResult或ActionResult用于表示当前Action的执行结果。
注意：IActionResult或ActionResult并非最终要返回给请求方的响应结果，这个结果还会由MVC进一步处理，处理之后，才会返回给请求方。
常见的返回结果包括状态码、重定向、内容等，如OkResult、BadRequestResult、RedirectResult、ViewResult、PartialViewResult、ContentResult等，这些类均实现了IActionResult接口。
在ControllerBase类中定义了一些比较方便返回上述结果的方法，比如要想返回一个OkResult对象，只要在当前Controller中调用基类的Ok()方法即可，类似的方法还有BadRequest()、NotFound()、View()等。
[HttpGet("{id}")]public ActionResult Get(long id){ if(id &lt;= 0) { return BadRequest(); } var employee = GetEmployee(id); if(employee == null) { return NotFound(); } return employee;} 上例中的Action返回值为ActionResult类型，相比IActionResult，它的优点是它既可以返回一个IActionResult类型的对象，如BadRequest()方法将会返回一个BadRequestResult对象，同时，它还可以返回一个T类型的对象，如employee对象。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d5f5218e53ba00c114b769d928540563/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ec518cf7695a29a7086921abc8fc726/" rel="bookmark">
			shell编写mysql全备和增备脚本_shell脚本：mysql全备与binlog增量备份
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		脚本功能：mysql库备份脚本，全备与binlog日志备份
脚本可以根据指定的参数进行全备，其余时间备份binlog日志
---------------#!/bin/bash
# description:Trian Server backup databases
# revision on 2016-02-18
# by colin
#
####################################
# 功能说明：该脚本运用于mysql每天备份与上传
#
# 使用说明：
# ./mysql_backup.sh /mysql/hlj/qqhr/
#+ 脚本后面的参数一表示备份文件在日志存储服务器上的存储路径
#
####################################
PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin
RUN_LOG=‘/var/log/cron_scripts_run.log‘
[ ! -f ${RUN_LOG} ] &amp;&amp; touch ${RUN_LOG}
EchoGoodLog ()
{
echo -e "\033[32m`date +%F" "%T":"%N` $*\033[0m" &gt;&gt; ${RUN_LOG}
}
EchoBadLog ()
{
echo -e "\033[31m`date +%F" "%T":"%N` $*\033[0m" &gt;&gt; ${RUN_LOG}
}
EchoGoodLog "Now, Script: `basename $0` run."
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ec518cf7695a29a7086921abc8fc726/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d32b61e4e1a847ebd4f5bc8b9ceee25e/" rel="bookmark">
			java 函数名调用_如何定义一个和库函数名一样的函数，并在函数中调用该库函数...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述： 某个函数fun_1()是在lib内，没法修改的，在程序中大量的使用了该函数，现在想把原本fun_1失效(现在失效的方法是#define fun_1(..)),用另外一个函数fun_2(),可是fun_2最后也需要调用fun_1,上面的失效方法感觉就不行了，请问怎么做才对？
问题
粉丝提问
我把问题简单整理下：
粉丝目标
问题
我们库文件里有个函数是read()我们现在要自己定义一个名字一样的函数read(),main()函数首先调用我们自己定义的函数read()自己定义的函数，要再定义库文件中的read()函数。 粉丝提问，必须安排！一口君实力宠粉！
想学习C语言、Linux、驱动、ARM的同学可以加一口君微信，拉你进群。
解决思路-static 如果我们要使用一个和库函数相同名字的函数，就要借助static关键字。
在函数的返回类型前加上static，就是静态函数。其特性如下：
静态函数只能在声明它的文件中可见，其他文件不能引用该函数不同的文件可以使用相同名字的静态函数，互不影响其他库如果有相同的函数名，优先使用本文件的静态函数 举例 系统调用函数read(),定义如下：
read系统调用
read
现在我们想定义一个自己的函数，名字也是read，要如何操作呢？
#include #include #include #include static void read(){ printf("my read func()");} int main(){ read();} 执行结果
执行结果
我们可以看到，虽然我们添加了系统调用read()的头文件，但是调用的是我们自己定义的read()函数。
下面我们来看下，如果我们定义的read函数又想调用系统调用read()函数应该怎么办呢？ 那就必须再增加一个文件，把相关功能放到另外一个文件中，在同一个文件中是没有办法实现的。
上代码，不上代码，没有论据的知识点都是耍流氓。一口君绝大部分文章都是有实例代码支撑，
//test.c 1 #include 2 #include 3 #include 4 #include 5 6 7 void test() 8 { 9 int fd; 10 char buf[128]={0}; 11 12 fd = open("123.c",O_RDWR); 13 if(fd&lt;0) 14 { 15 perror("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d32b61e4e1a847ebd4f5bc8b9ceee25e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a759065da438ec0b8eedfcb3cb5bbef3/" rel="bookmark">
			GAMES101图形学P8笔记（shading）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		镜面反射
指数p是，因为N•h是夹角余弦，p的话是控制高光究竟多大的
环境光
不讲究光照方向，也不管观测方向，和法线也没关系
Blinn-Phong反射模型
Shading Frequencies(着色频率)，分别是着色应用在每个面，每个顶点和每个像素的结果
Graphics(Real-time Rendering) Pipeline（渲染管线）
有像素着色器和顶点着色器
GPU:整个图形管线的硬件实现
Texture Mapping（纹理映射）
用于定义物体任何一点的不同属性，不只是漫反射系数。如何定义？定义在哪？
定义在物体表面，任何一个三维物体的表面都是二维的。
所以我们定义纹理就是一张图，蒙在三维物体的表面
纹理上的坐标系，用(u,v)来表示
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b047f0607533456166d817913219f699/" rel="bookmark">
			mysql不用max求最大值_一个简单的sql语句---不用Max函数求最大值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：
数据库表test 只有一个属性num test{num}
求num的最大值(不能用Max)
解答
1 select ta.num,tb.num from test as ta ,test as tb where ta.num
得到的结果是 两个两列的结果集 ，第一列小于第二列
除了最大的数外，其他的数都会出现在第一列中
2 select tc.num from test as tc where tc.num not in
(select ta.num from test as ta ,test as tb where ta.num
从test表中找到num不在1结果集中的那一项，这一项的num属性就是表中num的最大值
///补充一个其他的小问题///
select * from table where column = null;//该写法错误
这个语句本意是想找出column列为null的所有项
但是问题是column=null不能判断出其是否等于null(即使column就是null) column=null返回的很可能是unknown值
所以正确的写法是
select * from table where column is null;
select * from table where column is not null;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d8a7002c83a3ed15e87ef03d98c6a7a/" rel="bookmark">
			交通灯系统设计 educoder实训项目 logisim实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		交通灯系统设计 educoder实训项目 logisim实现 代码等文件下载
第1关：7段数码管驱动电路设计 实验内容
在 logisim 中打开实验资料包中的TrafficLight.circ 文件，在数码管驱动子电路中实现对应功能。
​ 框架内数码管驱动测试
根据引脚绑定设置好真值表，然后生成电路。完成后利用文本编辑工具打开TrafficLight.circ 文件，将所有文字信息复制粘贴到 Educoder 平台代码区域，再点击评测按钮即可进行本关测试。
第2关：四位无符号比较器设计 实验内容
设计实现四位无符号比较器，该电路有8个输入，真值表表项256项，用真值表实现过于繁琐，且容易出错，所以对于这类电路只能通过构建逻辑表达式的方式实现，仔细思考四位无符号比较器的逻辑表达式，利用logisim自动生成电路功能自动生成该电路。
L1=X3~Y3+~(X3^Y3)X2~Y2+~(X3^Y3)~(X2^Y2)X1~Y1+~(X3^Y3)~(X2^Y2)~(X1^Y1)X0~Y0 L2=(~X3)Y3+~(X3^Y3)(~X2)Y2+~(X3^Y3)~(X2^Y2)(~X1)Y1+~(X3^Y3)~(X2^Y2)~(X1^Y1)(~X0)Y0 L3=~(X3^Y3)~(X2^Y2)~(X1^Y1)~(X0^Y0) X3~Y3 : X3比Y3大则输出为1 ~(X3^Y3) : X3和Y3相等则输出为1 3关：8位无符号比较器设计 实验内容
利用已经设计完成的四位无符号比较器构建8位无符号比较器。
要注意每一个分线端口应该对应哪一位，可以通过测试看哪个端口对应的线亮了判断，与上图类似！
第4关：1位2路选择器设计 实验内容
利用基本逻辑门构成1位的2路选择器。
Y=~Sel D0 + Sel D1
第5关：8位2路选择器设计； 实验内容
利用一位的2路选择器构建8位的2路选择器，请认真思考如何进行电路并发，如何构建电路绘图最简单。
将1位选择信号Sel扩展到8位，然后根据表达式绘图
Y=~Sel D0 + Sel D1
第6关：双向BCD码计数器状态机设计 实验内容
设计BCD双向计数器的状态机。
)]
8421 0000，0001，0010，0011，0100 0101，0110，0111，1000，1001 余3码 0011~1100 2421 0000，0001，0010，0011，0100 1011，1100，1101，1110，1111 双向计数 Mode=0 0→1→2→3→4→5→6→7→8→9→0... Mode=1 9→8→7→6→5→4→3→2→1→0→9... 利用 BCD双向计数逻辑自动生成.xlsx 生成逻辑表达式，然后复制表达式自动生成电路
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d8a7002c83a3ed15e87ef03d98c6a7a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8dccf135cf2c62385e6ec04754e94fdd/" rel="bookmark">
			Cookie.Session的自动登录,注册的案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Cookie.Session的自动登录,注册的案例
首先先写几个简单的html页面(主页,登录,注册,个人中心)
然后,先写注册界面,需要在本地先创建一个文件,然后通过登录注册可以从本地文件读取或者写入
注册界面
@WebServlet("/register") public class RegisterServlet extends HttpServlet{ @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doPost(req, resp); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { String userName=req.getParameter("userName"); String password=req.getParameter("password"); String repassword=req.getParameter("repassword"); //判断用户名密码是否为空或者是null,如果是,就转发到注册页面 if(userName==null||userName.isEmpty()||password==null||password.isEmpty()) { req.getRequestDispatcher("pages/register.html").forward(req, resp); return; } //创建输入流读取本地文件 BufferedReader br=new BufferedReader(new FileReader("d://demo.txt")); String str; while((str=br.readLine())!=null) { String[] strs=str.split("="); //判断本地文件中的用户名是否已存在,如果存在,转发回注册页面 if(strs[0].equals(userName)) { req.getRequestDispatcher("pages/register.html").forward(req, resp); return; } } br.close(); //判断两次输入的密码是否一致,如果一致,写入到本地文件中去,并且重定向到登录界面,如果不一致,转发会注册界面 if(password.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8dccf135cf2c62385e6ec04754e94fdd/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/386/">«</a>
	<span class="pagination__item pagination__item--current">387/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/388/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>