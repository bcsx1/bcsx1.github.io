<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2cc55480e722cb7dbf69b59f79e30931/" rel="bookmark">
			ESP8266远程通信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		思路：借助云平台巴法创客云
AT+CWMODE=1 AT+CWJAP="xxx_1","xxx_2" AT+CIPSTART="TCP","bemfa.com",8344 AT+CIPMODE=1 AT+CIPSEND 然后按照巴法云平台接入协议进行通信，利用订阅发布模式：
cmd=1&amp;uid=xxx_3&amp;topic=xxx_4\r\n
cmd=2&amp;uid=xxx_3&amp;topic=xxx_4&amp;msg=Hello\r\n
PS：目前消息只能是字符串的形式
参考：
[1]巴法开放论坛：两个ESP8266通过云端实现远程数据交互
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46774c1cbfe9cbfacb22c90d7ad796ff/" rel="bookmark">
			ESP8266局域网通信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0、思路 所有8266都连接到同一热点，选取一个作为tcp server，其他作为tcp clint。
1、服务端配置 AT+CWMODE=1 AT+CWJAP="xxx_1","xxx_2" AT+CIFSR AT+CIPMUX=1 AT+CIPSERVER=1,8086 xxx_1：热点名称
xxx_2：热点密码
AT+CIFSR获取STA模式的IP地址，记为xxx_3
2、客户端配置 AT+CWMODE=1 AT+CWJAP="xxx_1","xxx_2" AT+CIPSTART="TCP","xxx_3",8086 AT+CIPMODE=1 AT+CIPSEND 3、客户端-&gt;服务端 AT+CIPSEND后直接发送数据
4、服务端-&gt;客户端 AT+CIPSEND=0,5表示发送5个字节
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d129d06d1a30f32028f439348db91ef/" rel="bookmark">
			字节型数据与16进制字符串互转
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		字节流转换为十六进制字符串
void ByteToHexStr(const unsigned char *source, char *dest, int sourceLen) { short i; unsigned char highByte, lowByte; for (i = 0; i &lt; sourceLen; i++) { highByte = source[i] &gt;&gt; 4; lowByte = source[i] &amp; 0x0f; highByte += 0x30; if (highByte &gt; 0x39) dest[i * 2] = highByte + 0x07; else dest[i * 2] = highByte; lowByte += 0x30; if (lowByte &gt; 0x39) dest[i * 2 + 1] = lowByte + 0x07; else dest[i * 2 + 1] = lowByte; } return; } 字节流转换为十六进制字符串的另一种实现方式
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d129d06d1a30f32028f439348db91ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c95870f3dd9981a1bd7e358874141f6/" rel="bookmark">
			机器学习中常见的编码形式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一. 常见的特征类型二. 编码2.1 序号编码（Ordinal Encoding）2.2独热编码（One-hot Encoding）2.3 标签编码 (Label Encoding)2.4 频数编码（Frequency Encoding/Count Encoding）2.5 目标编码（Target Encoding） 一. 常见的特征类型 一般特征可以分为两大类特征，连续型和离散型特征。而离散型特征既有是数值型的，也有类别型特征。例如性别（男、女）、成绩等级（A、B、C）等等。连续型特征的原始形态就可以作为模型的输入,无论是LR、神经网络,还是SVM、GBDT、xgboost等等。但是除了决策树等少数模型能直接处理字符串形式的类别型特征输入，逻辑回归、支持向量机等模型的输入必须是数值型特征才能正确工作。因此就需要将离散型特征中的类别型特征转换成数值型的。
二. 编码 2.1 序号编码（Ordinal Encoding） 序号编码通常用于处理类别间具有内在大小顺序关系的数据，对于一个具有m个类别的特征，我们将其对应地映射到 [0,m-1] 的整数。例如对于”学历”这样的类别，”学士”、”硕士”、”博士” 可以很自然地编码成 [0,2]，因为它们内在就含有这样的逻辑顺序。但如果对于“颜色”这样的类别，“蓝色”、“绿色”、“红色”分别编码成[0,2]是不合理的，因为我们并没有理由认为“蓝色”和“绿色”的差距比“蓝色”和“红色”的差距对于特征的影响是不同的。
sklearn.preprocessing中的OrdinalEncoder进行处理，可以通过两种方式进行编码：
方法1：先将数据categorical_df载入encoder中，再将载入的数据进行OrdinalEncoder编码方法2: 直接载入encoder并编码 import pandas as pd from sklearn.preprocessing import OrdinalEncoder categorical_df = pd.DataFrame({'my_id': ['101', '102', '103', '104'], 'name': ['allen', 'bob', 'chartten', 'dory'], 'place': ['third', 'second', 'first', 'second']}) print(categorical_df) print('--'*20) encoder = OrdinalEncoder() #创建OrdinalEncoder对象 # 方法1 encoder.fit(categorical_df) #将数据categorical_df载入encoder中 categorical_df = encoder.transform(categorical_df) #将载入的数据进行OrdinalEncoder # 方法2 categorical_df = encoder.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c95870f3dd9981a1bd7e358874141f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d748c1d8df659048f6ef78b4b808f02/" rel="bookmark">
			Selenium框架学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Selenium框架学习 参考资料：https://www.cnblogs.com/yyoba/p/12048866.html
一、简介 Selenium 是一个用于Web应用程序测试的工具。Selenium测试直接运行在浏览器中，就像真正的用户在操作一样。支持的浏览器包括IE（7, 8, 9, 10, 11），[Mozilla Firefox](https://baike.baidu.com/item/Mozilla Firefox/3504923)，Safari，Google Chrome，Opera，Edge等。这个工具的主要功能包括：测试与浏览器的兼容性——测试你的应用程序看是否能够很好得工作在不同浏览器和操作系统之上。测试系统功能——创建回归测试检验软件功能和用户需求。支持自动录制动作和自动生成[ .Net](https://baike.baidu.com/item/ .Net/156737)、Java、Perl等不同语言的测试脚本。
二、HelloWorld 1. 打开浏览器 /** * @Description: 第一个web自动化测试类 * @date:2021/4/5 上午10:28 * @author:Daniel */ public class FirstWebTest { public static void main(String[] args) { openChrome(); } /** * 打开Chrome浏览器 */ public static void openChrome() { // 1. 加载Chrome浏览器驱动 System.setProperty("webdriver.chrome.driver", "src/main/resources/chromedriver"); // 2. 打开chrome浏览器 ChromeDriver driver = new ChromeDriver(); // 3. 访问百度 driver.get("https://www.baidu.com"); } } 2. 基本元素定位 /** * @Description: 基本元素定位 * @date:2021/4/5 上午10:58 * @author:Daniel */ public class ElementLocate { private static ChromeDriver chromeDriver; public static void main(String[] args) { openChrome(); // 定位百度的搜索框元素，并且输入数据(ID定位) -- 唯一的 //chromeDriver.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d748c1d8df659048f6ef78b4b808f02/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8437f6d269721bedbd3c6695f5cbb95d/" rel="bookmark">
			C#将整个项目打包成.dll文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 上次提到单个.cs文件打包为.dll文件的操作，有点繁琐。这次我们用Visual Studio 2019这个强大的编译器进行辅助打包。 操作步骤 1、新建一个项目，如Test
我这里举例是窗体应用程序，同学们练习的时候这个项目创建成控制台应用程序也可以。
2、给项目添加一个类文件，如Student.cs[并给此类注明为公用类:public]，给它添加字段name、age、sex。以及对应属性。给它添加无参构造函数以及带参构造函数。
using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; namespace Test { /// &lt;summary&gt; /// 学生类 /// &lt;/summary&gt; public class Student { #region 字段区 /// &lt;summary&gt; /// 姓名 /// &lt;/summary&gt; private string name; /// &lt;summary&gt; /// 年龄 /// &lt;/summary&gt; private int age; /// &lt;summary&gt; /// 性别 /// &lt;/summary&gt; private string sex; #endregion #region 属性区 /// &lt;summary&gt; /// 姓名 /// &lt;/summary&gt; public String Name { set { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8437f6d269721bedbd3c6695f5cbb95d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a98178f13b8510e778a0b802b865001/" rel="bookmark">
			hi3516ev300 uboot烧录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ba4e9312c1d439e7b87b2be7b973fa7/" rel="bookmark">
			Oracle. .so文件,ld.so.conf.d配置文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ld.so.conf.d用来加载Linux系统中的动态库文件的：
在/etc下我们会发现下面三个文件
ld.so.conf.d
ld.so.conf
ld.so.cache
查看ld.so.conf以后可以看到是包含了ld.so.conf.d中的所有配置文件include ld.so.conf.d/*.conf
查看ld.so.conf.d中的内容可以看到配置文件很多[root@SH-021Y-SFXY mcrypt-2.6.8]# ll /etc/ld.so.conf.d/
total 16
-rw-r--r--. 1 root root 17 Feb 9 2012 atlas-x86_64.conf
-r--r--r--. 1 root root 324 Jan 30 2013 kernel-2.6.32-358.el6.x86_64.conf
-rw-r--r--. 1 root root 17 Dec 5 2012 mysql-x86_64.conf
-rw-r--r--. 1 root root 22 Jul 18 2011 qt-x86_64.conf
在查看配置可以看到如下配置[root@SH-021Y-SFXY mcrypt-2.6.8]# cat /etc/ld.so.conf.d/qt-x86_64.conf
/usr/lib64/qt-3.3/lib
我增加一个配置文件[root@SH-021Y-SFXY mcrypt-2.6.8]# vi /etc/ld.so.conf.d/userlocal.conf
/usr/local/lib
再次查看可以发现已经找到该目录下的动态库[root@SH-021Y-SFXY mcrypt-2.6.8]# ldconfig -p | grep libmcrypt
libmcrypt.so.4 (libc6,x86-64) =&gt; /usr/local/lib/libmcrypt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ba4e9312c1d439e7b87b2be7b973fa7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68b09c8a50932e09c68a9776b7f25039/" rel="bookmark">
			oracle update dec0de,?SQL中update与update select结合语法详解与实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SQL中update与update select结合语法详解与实例
1、通用update
一般简单的update语法比较通用
语法：
UPDATE table_name
SET column1=value1,
column2=value2,
...
WHERE some_column = some_value;
12345
注：若不加where条件则是更新表中的所有数据，
故执行没有where子句的update要慎重再慎重。
实例：
UPDATE subject
SET name=‘数学‘,
type=‘理学‘
WHERE id = 1;
1234
2、GreenPlum update与select结合
语法：
UPDATE [only] table [[as] alias]
SET {column = {expression | default} |
(column [, ...]) = ({expression | default}[, ...])}[, ...]
[FROM fromlist]
[WHERE condition | WHERE current of cursor_name];
12345
注：若不加where条件则是更新表中的所有数据，
故执行没有where子句的update要慎重再慎重。
实例：
UPDATE table1 t1
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/68b09c8a50932e09c68a9776b7f25039/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f43a20474b5e9f8331226d29e80b0ff2/" rel="bookmark">
			MyBatis-Plus-Generate代码生成器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引入的POM文件：
&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.4.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt; &lt;version&gt;3.4.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.freemarker&lt;/groupId&gt; &lt;artifactId&gt;freemarker&lt;/artifactId&gt; &lt;version&gt;2.3.31&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; package com.generate.generate; import com.baomidou.mybatisplus.core.exceptions.MybatisPlusException; import com.baomidou.mybatisplus.core.toolkit.StringPool; import com.baomidou.mybatisplus.core.toolkit.StringUtils; import com.baomidou.mybatisplus.generator.AutoGenerator; import com.baomidou.mybatisplus.generator.InjectionConfig; import com.baomidou.mybatisplus.generator.config.*; import com.baomidou.mybatisplus.generator.config.po.TableInfo; import com.baomidou.mybatisplus.generator.config.rules.DateType; import com.baomidou.mybatisplus.generator.config.rules.NamingStrategy; import com.baomidou.mybatisplus.generator.engine.FreemarkerTemplateEngine; import java.util.ArrayList; import java.util.List; import java.util.Scanner; // 演示例子，执行 main 方法控制台输入模块表名回车自动生成对应项目目录中 public class CodeGenerator { /** * &lt;p&gt; * 读取控制台内容 * &lt;/p&gt; */ public static String scanner(String tip) { Scanner scanner = new Scanner(System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f43a20474b5e9f8331226d29e80b0ff2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4522d53f7456954d1e65bd96aa17ba85/" rel="bookmark">
			无序数组找中位数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.无序数组找中位数 思路一
把无序数组排好序，取出中间的元素
时间复杂度 采用普通的比较排序法 O(N*logN)
如果采用非比较的计数排序等方法， 时间复杂度 O(N), 空间复杂度也是O(N).
思路二
（1）将前(n+1)/2个元素调整为一个小顶堆
（2）对后续的每一个元素，和堆顶比较，如果小于等于堆顶，丢弃之，取下一个元素。 如果大于堆顶，用该元素取代堆顶，调整堆，取下一元素。重复2.2步
（3）当遍历完所有元素之后，堆顶即是中位数。
注：如果数组元素的个数是奇数，取数组前(size+1)/2个元素建堆，如果是偶数则取前 size/2 个元素建堆。但如果是数据流，数据个数是动态变动的，则应采用小根堆+大根堆的办法，具体见本文第5点介绍。
思路三
找中位数也可以用快排分治的思想。具体如下：
（1）任意挑一个元素，以改元素为支点，划分集合为两部分，如果左侧集合长度恰为 (n-1)/2，那么支点恰为中位数。如果左侧长度&lt;(n-1)/2, 那么中位点在右侧，反之，中位数在左侧。
（2）进入相应的一侧继续寻找中位点。
注：可参考快排思想实现Top K
拓展：查找N个元素中的第K个小的元素，假设内存受限，仅能容下K/4个元素
分趟查找：
第一趟，用堆方法查找最小的K/4个小的元素，同时记录剩下的N-K/4个元素到外部文件。第二趟，用堆方法从第一趟筛选出的N-K/4个元素中查找K/4个小的元素，同时记录剩下的N-K/2个元素到外部文件。…第四趟，用堆方法从第一趟筛选出的N-K/3个元素中查找K/4个小的元素，这是的第K/4小的元素即使所求。 https://blog.csdn.net/zdl1016/article/details/4676882
2.将十进制数字转化为X 进制的字符串 //将十进制数转化为X进制字符串 string trans(int num, int base){ string str; while(num &gt; 0){ if(num % base &lt; 10) str += num % base + '0'; else str += num % base - 10 + 'A'; num = num / base; } reverse(str.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4522d53f7456954d1e65bd96aa17ba85/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3276d50ef73edd8ec24c4005565aed5/" rel="bookmark">
			快排思想实现Top K
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		快排实现Topk
时间复杂度：平均O(N)
利用快排的思想实现，每次可以得到一个元素下标，在这个元素下标左边，所有元素比这个元素小， 在这个元素右边，所有元素都比这个元素大：
如果右边的元素个数等于K-1，则加上当前元素，达到K个，可知TOPK的元素为这K个；如果右边的元素个数小于K-1, 则在左边范围寻找K-len个元素如果右边的元素个数大于K-1, 则在右边范围寻找K个元素 #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; //用快排的思想：例如找49个元素里面第24大的元素，那么按如下步骤： //1.进行一次快排（将大的元素放在前半段，小的元素放在后半段）, 假设得到的中轴为p //2.判断 k -1==p - low，如果成立，直接输出a[p]，（因为前半段有k - 1个大于a[p]的元素，故a[p]为第K大的元素） //3.如果 k -1 &lt; p - low， 则第k大的元素在前半段，此时更新high = p - 1，继续进行步骤1 //4.如果 k -1 &gt; p - low， 则第k大的元素在后半段，此时更新low = p + 1, 且 k = k - (p - low + 1)，继续步骤1. //由于常规快排要得到整体有序的数组，而此方法每次可以去掉“一半”的元素，故实际的复杂度不是o(nlgn), 而是o(n)。 class Finder { public: int partition(vector&lt;int&gt;&amp;a, int low, int high)//找枢纽 { int first = low; int	last = high; int key = a[first];//用字表的第一个记录作为枢轴 while (first &lt; last) { while (a[last] &gt;= key &amp;&amp; first &lt; last) --last; swap(a[first], a[last]); while (a[first] &lt;= key &amp;&amp; first &lt; last) ++first; swap(a[first], a[last]); } return first;//返回一个枢纽 } int findKth(vector&lt;int&gt;&amp; a, int low, int high, int k) { int p = partition(a, low, high); if (k == p - low + 1) return a[p]; else if (k - 1 &lt; p - low)//则第k大的元素在前半段 return findKth(a, low, p - 1, k); else //则第k大的元素在后半段 return findKth(a, p + 1, high, k - p + low - 1); } }; int main() { int k = 1; vector&lt;int&gt; v{ 6, 2, 7, 3, 8, 9, 11, 5, 78, 34, 13 }; Finder solution; //第k大元素=正序中第(nums.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a3276d50ef73edd8ec24c4005565aed5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61245b9be6f6f422400d8722813edeee/" rel="bookmark">
			Oracle获取当前时间的星期几,在SQL里通过语句得到当前日期是星期几
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们在实际在做数据库的操作的时候，经常会需要通过SQL语句来读取日期是星期几，
得到当前日期的函数是：getdate()
下面的几个函数都是使用的固定日期，可以修改成通过getdate()，来得到当前日期是星期几
1：在Oracle 通过下面语句
第一个：SELECT DECODE(dw,
0,
'星期天',
1,
'星期一',
2,
'星期二',
3,
'星期三',
4,
'星期四',
5,
'星期五',
6,
'星期六') WEEK_DAY
FROM (SELECT 7 -
TO_NUMBER(NEXT_DAY(TO_DATE('2012-12-12', 'yyyy-mm-dd'), 1) -
TO_DATE('2012-12-12', 'yyyy-mm-dd')) dw
FROM dual);
第二个语句：
SELECT TO_CHAR(TO_DATE('2012-12-12', 'YYYY-MM-DD'), 'DAY') WEEK_DAY
FROM DUAL
2：在SqlServer下面，实现的语句
select case datepart(weekday, getdate())
when 1 then
'星期天'
when 2 then
'星期一'
when 3 then
'星期二'
when 4 then
'星期三'
when 5 then
'星期四'
when 6 then
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61245b9be6f6f422400d8722813edeee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b645882b25dbdd40d42ef20f965c12f/" rel="bookmark">
			php 万能分页类,两款万能的php分页类_php技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文为大家分享个超级好用、万能的php分页类，具体的实现代码如下
第一款php分页类
init(1000, 20);
* $page-&gt;setNotActiveTemplate('{a}');
* $page-&gt;setActiveTemplate('{a}');
* echo $page-&gt;show();
*
*
* @author 风居住的地方
*/
class Page {
/**
* 总条数
*/
private $total;
/**
* 每页大小
*/
private $pageSize;
/**
* 总页数
*/
private $pageNum;
/**
* 当前页
*/
private $page;
/**
* 地址
*/
private $uri;
/**
* 分页变量
*/
private $pageParam;
/**
* LIMIT XX,XX
*/
private $limit;
/**
* 数字分页显示
*/
private $listnum = 8;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b645882b25dbdd40d42ef20f965c12f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8bacaf577e00eb57189a47f3f1ed375/" rel="bookmark">
			C语言自定义函数求三项数值中的最大数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 #include&lt;stdio.h&gt; //自定义max函数 double max(double a,double b,double c) { double z; z=a&lt;b?a:b; return (c&lt;z?c:z); } int main() { double a=0,b=0,c=0; printf("请输入a,b,c的值："); scanf("%lld%lld%lld",&amp;a,&amp;b,&amp;c); max(a,b,c); return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f400ca5e8a19dce7f2a0c01c451d4dd/" rel="bookmark">
			Apache 源码安装详细教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Apache 源码安装Apache 入门简介进程和线程概念进程和线程的区别目前主流的WEB服务器软件源码包安装 httpd 总结Apache 重启报错解决办法Apache 源码安装常见目录Apache bin目录下常用的命令http 常用参数tar 解压工具命令查看cpu信息源码安装心得体会: Apache 源码安装 Apache 入门简介 点击查看HTTP基础概念
点击查看HTTP工作模式
进程和线程概念 进程是操作系统分配资源的资本单位，进程是程序的实体进程是动态的，程序是静态的 进程和线程的区别 线程是进程的基本单位，范围比进程要小一个进程中包含一个线程或者多个线程，所有的线程共享该进程的内存空间如果进程挂掉，所有线程崩溃，如果一个线程异常退出，连同其他的线程或者进程会崩溃多线程的好处是提高访问效率、并发高网站采用多进程-多线程工作。 目前主流的WEB服务器软件 Apache 、Nginx、Lighttpd、IISResin、Tomcat、WebLogic、Jetty等 Apache 是一个古老的web服务器软件，基于Apahce 基金会开发的，默认只能发布静态网页Apache 是一个多模块式的软件、模块丰富Apache 有三种工作模式：Prefork、Worker、Event Prefork：Apche默认工作模式，多进程模型，预先生成进程，一个请求用一个进程响应,预先生成多个空闲进程，随时等待请求到达，最大不会超过1024个。 缺点：多进程方式，比较消耗内存和系统资源。 Worker MPM:工作模式。基于线程工作，一个请求用一个线程响应（启动多个进程，每个进程生成多个线程）内存占用量比较小，适合大并发、高流量的WEB服务器 缺点：一个线程崩溃，整个进程就会连同其任何线程一起挂掉 源码包安装 httpd 点击官网下载地址
下载http-2.4.46.tar.bz2:
https://downloads.apache.org/httpd/httpd-2.4.46.tar.bz2 [root@localhost usr]# cd src/ [root@localhost src]# wget https://downloads.apache.org/httpd/httpd-2.4.46.tar.bz2 --2021-04-03 15:53:32-- https://downloads.apache.org/httpd/httpd-2.4.46.tar.bz2 Resolving downloads.apache.org (downloads.apache.org)... 88.99.95.219, 2a01:4f8:10a:201a::2 Connecting to downloads.apache.org (downloads.apache.org)|88.99.95.219|:443... connected. HTTP request sent, awaiting response... 200 OK Length: 9363314 (8.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f400ca5e8a19dce7f2a0c01c451d4dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad3b9637e36df3b2e698c7aa975bf6d7/" rel="bookmark">
			Linux V4L2子系统分析（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.概述 Linux系统上的Video设备多种多样，如通过Camera Host控制器接口连接的摄像头，通过USB总线连接的摄像头等。为了兼容更多的硬件，Linux内核抽象了V4L2（Video for Linux Two）子系统。V4L2子系统是Linux内核中关于Video（视频）设备的API接口，是V4L（Video for Linux）子系统的升级版本。V4L2子系统向上为虚拟文件系统提供了统一的接口，应用程序可通过虚拟文件系统访问Video设备。V4L2子系统向下给Video设备提供接口，同时管理所有Video设备。Video设备又分为主设备和从设备，对于Camera来说，Camera Host控制器为主设备，负责图像数据的接收和传输，从设备为Camera Sensor，一般为I2C接口，可通过从设备控制Camera采集图像的行为，如图像的大小、图像的FPS等。主设备可通过v4l2_subdev_call的宏调用从设备提供的方法，反过来从设备可以调用主设备的notify方法通知主设备某些事件发生了。
2.V4L2子系统 V4L（Video for Linux）是Linux内核中关于视频设备的API接口，涉及视频设备的音频和视频信息采集及处理、视频设备的控制。V4L出现于Linux内核2.1版本，经过修改bug和添加功能，Linux内核2.5版本推出了V4L2（Video for Linux Two）子系统，功能更多且更稳定。V4L2的主设备号是81，次设备号范围0~255，这些次设备号又分为多类设备，如视频设备（次设备号范围0-63）、Radio（收音机）设备（次设备号范围64-127）、Teletext设备（次设备号范围192-223）、VBI设备（次设备号范围224-255）。V4L2设备对应的设备节点有/dev/videoX、/dev/vbiX、/dev/radioX。这里只讨论视频设备，视频设备对应的设备节点是/dev/videoX。视频设备以高频头或Camera为输入源，Linux内核驱动该类设备，接收相应的视频信息并处理。
2.1.V4L2主设备数据结构 V4L2主设备实例使用struct v4l2_device结构体表示，v4l2_device是V4L2子系统的入口，管理着V4L2子系统的主设备和从设备。简单设备可以仅分配这个结构体，但在大多数情况下，都会将这个结构体嵌入到一个更大的结构体中。需要与媒体框架整合的驱动必须手动设置dev-&gt;driver_data，指向包含v4l2_device结构体实例的驱动特定设备结构体。这可以在注册V4L2设备实例前通过dev_set_drvdata()函数完成。同时必须设置v4l2_device结构体的mdev域，指向适当的初始化并注册过的media_device实例。
对于视频设备，Camera控制器可以视为主设备，接在Camera控制器上的摄像头可以视为从设备。V4L2子系统使用v4l2_device结构体管理设备，设备的具体操作方法根据设备类型决定，若是视频设备，则需要注册video_device结构体，并提供相应的操作方法。
[include/media/v4l2-device.h] struct v4l2_device { struct device *dev; // 父设备指针 #if defined(CONFIG_MEDIA_CONTROLLER) // 多媒体设备配置选项 // 用于运行时数据流的管理， struct media_device *mdev; #endif // 注册的子设备的v4l2_subdev结构体都挂载此链表中 struct list_head subdevs; // 同步用的自旋锁 spinlock_t lock; // 独一无二的设备名称，默认使用driver name + bus ID char name[V4L2_DEVICE_NAME_SIZE]; // 被一些子设备回调的通知函数，但这个设置与子设备相关。子设备支持的任何通知必须在 // include/media/&lt;subdevice&gt;.h 中定义一个消息头。 void (*notify)(struct v4l2_subdev *sd, unsigned int notification, void *arg); // 提供子设备（主要是video和ISP设备）在用户空间的特效操作接口， // 比如改变输出图像的亮度、对比度、饱和度等等 struct v4l2_ctrl_handler *ctrl_handler; // 设备优先级状态 struct v4l2_prio_state prio; /* BKL replacement mutex.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad3b9637e36df3b2e698c7aa975bf6d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4590ab050c813cab2d3c084af880d262/" rel="bookmark">
			oracle数据库的dump,Oracle数据库数据导出dump方式-Oracle
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Oracle数据库数据导出dump方式
linux下 www.2cto.com
Java代码
[root@infodb111 ~]# su – oracle
[oracle@infodb111 /]$ mkdir /oracle/dump_dir
[oracle@infodb111 /]$ sqlplus / as sysdba
SQL&gt; create directory dump_dir as ‘/oracle/dump_dir’;
SQL&gt; grant read,write on directory dump_dir to scott;
Grant succeeded
SQL&gt; grant read,write on directory biappdump to maxthonbi;
创建脚本文件
www.2cto.com
Java代码
[root@infodb111 ~]# vim biappdbback.sh
#!/bin/sh
D=maxthon_$(date +%Y%m%d);
export D;
expdp ‘maxthon/maxthon@orcl’ directory=biappdump dumpfile=${D}.dmp
//保存退出
授权：
[root@infodb111 ~]# chown oracle:dba biappdbback.sh
[root@infodb111 ~]# chmod 775 biappdbback.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4590ab050c813cab2d3c084af880d262/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf71dd1b988f5da8a7d530501cabc449/" rel="bookmark">
			oracle启动shell脚本编写,Linux下的Oracle启动脚本及其开机自启动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说明：以下操作环境在CentOS 6.4 + Oracle 11gR2(Oracle安装在ORACLE_BASE=/opt/oracle中，其ORACLE_HOME=/opt/oracle/11g)
用OUI安装并配置Oracle数据库后，Oracle就开启了(包括：数据库实例、监听器、EM)。在重启操作系统之后，Oracle默认是没有启动的。使用如下命令查看Oracle相关服务是否已启动：
ps aux | grep ora_ #若无ora_**_**相关的进程，则oracle数据库实例未启动
netstat -tlnup | grep 1521 #若无任何显示，则监听器未启动
lsnrctl status #查看监听器状态
netstat -tlnup | grep 1158 #若无任何显示，则EM未启动
emctl status dbconsole #查看EM状态
手工启动Oracle实例，可用sqlplus建立一个idle instance，然后再用startup启动，如下：
数据库实例启动之后，需启动监听器，才能让远程用户建立连接。可使用如下命令启动监听器：
复制代码代码如下:
lsnrctl start
Oracle还提供网页版的管理器，要使用该管理器需启动相关服务，使用如下命令启动：
复制代码代码如下:
emctl start dbconsole
至此，可在web浏览器中输入：https://｛主机IP 或 主机名 或 本地localhost｝:1158/em，打开管理器，使用相关帐号登录进行数据库查看和管理。
如果每次重启操作系统都要进行以上操作好麻烦，那么如何让Oracle作为系统服务在开机的时候自动启动呢？
Oracle在$ORACLE_HOME/bin下提供许多对数据库进行操作的脚本，其中dbstart和dbshut可分别用来启动和关闭数据库。注意，这两个脚本已包含监听器的启动或关闭，但并未对EM进行相关的操作。使用如下命令：
复制代码代码如下:
/opt/oracle/11g/bin/dbstart /opt/oracle/11g #启动数据库实例(包含监听器)
/opt/oracle/11g/bin/dbshut /opt/oracle/11g #关闭数据库实例(包括监听器)
以上命令要成功启动数据库实例还得打开Oracle设置的一个关卡：vi /etc/oratab，修改行：
复制代码代码如下:
orcl:/opt/oracle/11g:Y #默认为orcl:/opt/oracle/11g:N
以root身份建立开机启动oracle服务的脚本：vi /etc/init.d/oracle，添加如下脚本：
复制代码代码如下:
#!/bin/sh
#chkconfig: 2345 20 80
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf71dd1b988f5da8a7d530501cabc449/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ba36e461760f1c99a49f5ef9879e95a/" rel="bookmark">
			oracle数据量多大,怎么查看oracle数据库数据量大小
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		查看方法：
1、查看所有表空间及表空间大小：select tablespace_name ,sum(bytes) / 1024 / 1024 as MB　from dba_data_files group by tablespace_name;
2、查看所有表空间对应的数据文件：select tablespace_name,file_name from dba_data_files;
3、修改数据文件大小：alter database datafile 'H:\ORACLE\PRODUCT\10.1.0\ORADATA\ORACLE\USERS01.DBF' RESIZE 10240M;
扩展资料
每张表都是作为“段”来存储的，可以通过user_segments视图查看其相应信息。段(segments)的定义：如果创建一个堆组织表，则该表就是一个段。sql：SELECT segment_name AS TABLENAME,BYTES FROM user_segments WHERE segment_name='表名'。
解释：segment_name 就是要查询的表名(大写)，BYTES 为表存储所占用的字节数。本sql的意思就是查询出表名和表所占的存储空间大小。
参考资料
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b880e348bea1eea1131e175dac16dd5/" rel="bookmark">
			意外的sql命令结尾oracle,oracle常用的一些sql命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		//查看系统当前时间 HH24 24小时制 MI是正确的分钟
select to_char(sysdate,'yyyy-mm-dd HH24:MI:SS') from dual
//HH非24 mm不区分大小写 日期中MM系统认为是月份
select to_char(sysdate,'yyyy-mm-dd HH:MM:SS') from dual
//报告TIMESTAMP数据类型格式的系统日期。
select SYSTIMESTAMP from dual;
//查询当前登录用户
select username from user_users
show user
//查看表结构(字段数据类型)
desc user_users
//查询当前用户所拥有的表
select table_name from user_tables
//忘记密码登录
打开cmd窗口，输入 sqlplus / as sysdba
//远程连接
gb/ruiyuan@192.168.0.210/orcl
//创建序列
create sequence 序列名
start with 起始序列
increment by 每次增加的值
序列名.nextval(下一个序列)
序列名.currval(当前序列)
//创建回话临时表数据
create global temporary table 表 as 另一张表数据 on commit preserve rows;(可以复制原表中数据，比较常用的就是这个。)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b880e348bea1eea1131e175dac16dd5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/898ec1361ff761c7391d4ffb8fe18f7c/" rel="bookmark">
			oracle 查询 历史数据,利用闪回查看oracle表历史时刻数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.查看表历史时刻数据select * from tab_test AS OF TIMESTAMP to_timestamp('20140917 10:00:00','yyyymmdd hh24:mi:ss');
2、利用flashback table恢复表到过去某一时刻alter table tab_test enable row movement;
flashback table tab_test to timestamp ('20140917 10:00:00','yyyymmdd hh24:mi:ss');
alter table tab_test disable row movement;
3、查看过去某一段时间内对表的操作，以确认需要恢复到的时间点select SQL_TEXT,LAST_ACTIVE_TIME from v$sqlarea where LAST_ACTIVE_TIME &gt;to_date('20140917 10:00:00','yyyymmdd hh24:mi:ss') and SQL_TEXT like '%tab_test%';
4、确认是否开启闪回select log_mode,flashback_on from v$database;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81e17bc53f4598f2619545fa83fc3c8b/" rel="bookmark">
			mongodb数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、年月查询（Aggregation）
Criteria criteria = new Criteria(); criteria.and("enId").in(organIds); criteria.and("updateBy").is(Integer.parseInt(year)); criteria.and("createBy").is(Integer.parseInt(month)); Aggregation aggregation = Aggregation.newAggregation( // 第一步：挑选所需的字段，类似select *，*所代表的字段内容 Aggregation.project("id","enId","enFilesId","createBy","updateBy") .andExpression("{$month: '$createTime'}").as("createBy") .andExpression("{$year: '$createTime'}").as("updateBy"), // 第二步：sql where 语句筛选符合条件的记录 Aggregation.match(criteria), // 第三步：分组条件，设置分组字段 id为enId，enId为数量，enFilesId Aggregation.group("enId").count().as("enId").first("enFilesId").as("enFilesId") // 第四步：重新挑选字段 // Aggregation.project("mn", "sn", "sumTp") ); AggregationResults&lt;AbInfo&gt; results_ = mongoTemplate.aggregate(aggregation, AbInfo.class, AbInfo.class); //循环 for(AbInfo abInfo : results_){ } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24fcad717739f57369b177dd50ab8f9d/" rel="bookmark">
			Visual Studio设置TFS工作项打开方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DevOps默认是网页版的浏览 如果想要集成在Visual Studio中打开，需要更改设置
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/334cbc6eec357e197304dd418e27cf9b/" rel="bookmark">
			Hexo配置命令运行出错：hexo init 博客名 解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Hexo配置命令运行出错：hexo init 博客名 解决办法 报错信息： D:\SanLangBlog&gt;hexo init SanLang INFO Cloning hexo-starter https://github.com/hexojs/hexo-starter.git fatal: unable to access 'https://github.com/hexojs/hexo-starter.git/': Failed to connect to github.com port 443: Timed out WARN git clone failed. Copying data instead FATAL { err: [Error: ENOENT: no such file or directory, scandir 'C:\Users\sanlang\AppData\Roaming\npm\node_modules\hexo-cli\assets'] { errno: -4058, code: 'ENOENT', syscall: 'scandir', path: 'C:\\Users\\sanlang\\AppData\\Roaming\\npm\\node_modules\\hexo-cli\\assets' } } Something's wrong. Maybe you can find the solution here: %s http://hexo.io/docs/troubleshooting.html 我的解决办法在环境变量path中新建三个变量：如下
配置完成之后在运行 命令成功
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/334cbc6eec357e197304dd418e27cf9b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a2646c36bc5aac62491e740e845749a/" rel="bookmark">
			一文了解差分进化算法的前世今生
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 综合表现流程概述初始化变异交叉选择 算法特点算法改进变异算子种群数量 N P NP NP缩放因子 F F F和变异率 C r Cr Cr改进DE排名 发展方向超参数改进变异算子改进应用范围扩展 差分进化算法（Differential Evolution，以下简称 DE）由Storn等人于1995年提出，其最初的设想是用于解决切比雪夫多项式问题，后来发现它也可用于求解复杂优化问题。当前，它已经成为求解 连续变量非线性全局优化问题的最有效方法之一。与遗传算法类似，DE是一种基于种群进化的元启发式算法。 PS：博主的博士课题以改进DE为主。研究过程中，走了很多弯路。以下内容，主要为这些年针对DE的相关总结。希望此文可以帮助朋友们降低了解和认识DE的准入门槛，若真如此，幸甚。若有相关问题，欢迎留言或私信讨论。
综合表现 下表列举了2005-2020年IEEE CEC 单目标参数优化竞赛的前三名优化算法。其中，2005年和2016年未针对算法进行总排名，不参与统计（用N/A表示）； 2007年为多目标优化问题，不参与统计（用N/A表示）；2009年和2014 年的第二名和第三名算法，未在网站上公布，表中也未列出（用N/A表示）。
上表中的DE算法和改进DE算法用黑体标注。从表中可以看出，DE在求解标准测试算例时，具有较为明显的优势。下图汇总了DE在各届IEEE CEC竞赛中的最优排名及其对应的改进DE。除了2013年排名第4外（图中未标出），DE在其他所有年份的排名都位列前三。在2006和2009等7个年份中，DE取得了第一名的成绩。在最近三年的竞赛中，即2018年、2019年和2020年，DE依然保持着领先的地位。
流程概述 设定优化问题如下：优化变量为 x \bm x x，变量维度为 D D D，表示为
x = ( x 1 , x 2 , . . . , x D ) {{\bm{x}}}=\left( {{x}^{1}},{{x}^{2}},...,{{x}^{D}} \right) x=(x1,x2,...,xD)
x \bm x x的上界 x m a x \bm x_{\rm{max}} xmax​和下界 x m i n \bm x_{\rm{min}} xmin​分别定义为
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a2646c36bc5aac62491e740e845749a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2b95cf23bde9fe01ca8ecc0ea7f0140/" rel="bookmark">
			复试导师问题——前沿科技
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前沿科技 自动问答技术 传送门
概念
自动问答（Question Answering, QA）是指利用计算机自动回答用户所提出的问题以满足用户知识需求的任务。不同于现有搜索引擎，问答系统是信息服务的一种高级形式，系统返回用户的不再是基于关键词匹配排序的文档列表，而是精准的自然语言答案
比如微软的小娜，苹果的siri，小米的小爱 研究内容
自动问答系统在回答用户问题时，需要正确理解用户所提的自然语言问题，抽取其中的关键语义信息，然后在已有语料库、知识库或问答库中通过检索、匹配、推理的手段获取答案并返回给用户。上述过程涉及词法分析、句法分析、语义分析、信息检索、逻辑推理、知识工程、语言生成等多项关键技术。 技术方法和研究现状
1）检索式问答；
这类方法是以检索和答案抽取为基本过程的问答系统，具体过程包括问题分析、篇章检索和答案抽取。
抽取方法分为基于模式匹配的问答方法和基于统计文本信息抽取的问答方法。
在运行阶段，系统首先判断当前提问属于哪一类，然后使用这类提问的模式来对抽取的候选答案进行验证。同时为了提高问答系统的性能，人们也引入自然语言处理技术。由于自然语言处理的技术还未成熟，现有大多数系统都基于浅层句子分析。
在一个限定问题类型、限定答案类型的知识比赛表现还行，面对开放式的场景和环境，已有检索式问答系统还有很长的路要走。
2）社区问答
社区问答系统应运而生，例如 知乎、百度知道等
社区问答系统有大量的用户参与，存在丰富的用户行为信息，例如用户投票信息、用户评价信息、回答者的问题采纳率、用户推荐次数、页面点击次数以及用户、问题、答案之间的相互关联信息等等，这些用户行为信息对于社区中问题和答案的文本内容分析具有重要的价值。
最好的检索系统在 Top 10 的准确率可以达到 40%。尽管社区问答系统相对于检索式问答和知识库问答技术简单，但是目前已经商业化
3）知识库问答。
检索式问答和社区问答尽管在某些特定领域或者商业领域有所应用，但是其核心还是关键词匹配和浅层语义分析技术，难以实现知识的深层逻辑推理，无法达到人工智能的高级目标。
其目标是把互联网文本内容组织成为以实体为基本语义单元（节点）的图结构，其中图上的边表示实体之间语义关系基于这样的结构化知识，问答系统的任务就是要根据用户问题的语义直接在知识库上查找、推理出相匹配的答案，这一任务称为面向知识库的问答系统或知识库问答。
评测主要针对于一些限定领域的知识库进行问答。已有方法也取得了不错的结果
未来方向
基于深度学习的端到端自动问答。
能将自然语言分析过程变为一个可学习的过程。但存在资源问题和算法实现问题 自动问答技术的效果怎么样？以后会用到什么算法：
采用自然语言处理技术，一方面完成对用户疑问的理解；另一方面完成正确答案的生成。综合运用了自然语言处理，信息检索，语义分析，机器学习，人工智能等技术的一种新型信息服务技术，自动问题系统将会自动分析和理解用户自然语言的提问，直接返回用户想要的答案。Pranking算法。 图像识别技术 概念：
图像识别，是指利用计算机对图像进行处理、分析和理解，以识别各种不同模式的目标和对象的技术，并对质量不佳的图像进行一系列的增强与重建技术手段，从而有效改善图像质量。
百度识图、人脸识别 原理
计算机的图像识别技术和人类的图像识别在原理上并没有本质的区别，人类的图像识别都是依靠图像所具有的本身特征分类，然后通过各个类别所具有的特征将图像识别出来的，当看到一张图片时，我们的大脑会迅速感应到是否见过此图片或与其相似的图片。
图像识别技术可能是以图像的主要特征为基础的。每个图像都有它的特征，如字母A有个尖，P有个圈、而Y的中心有个锐角等。对图像识别时眼动的研究表明，视线总是集中在图像的主要特征上，也就是集中在图像轮廓曲度最大或轮廓方向突然改变的地方，这些地方的信息量最大。而且眼睛的扫描路线也总是依次从一个特征转到另一个特征上。由此可见，在图像识别过程中，知觉机制必须排除输入的多余信息,抽出关键的信息。同时,在大脑里必定有一个负责整合信息的机制，它能把分阶段获得的信息整理成一个完整的知觉映象。 图像识别技术的过程分以下几步：
信息的获取预处理
预处理主要是指图像处理中的去噪、平滑、变换等的操作，从而加强图像的重要特征特征抽取和选择
简单的理解就是我们所研究的图像是各式各样的，如果要利用某种方法将它们区分开，就要通过这些图像所具有的本身特征来识别，而获取这些特征的过程就是特征抽取。分类器设计和分类决策。 模式识别是
人工智能和信息科学的重要组成部分。模式识别是指对表示事物或现象的不同形式的信息做分析和处理从而得到一个对事物或现象做出描述、辨认和分类等的过程。 图像识别在哪些方面的应用
图像识别技术可能是以图像的主要特征为基础的，每个图像都有它的特征。在人类图像识别系统中，对复杂图像的识别往往要通过不同层次的信息加工才能实现。图像识别技术是立体视觉、运动分析、数据融合等实用技术的基础，在导航、地图与地形配准、自然资源分析、天气预报、环境监测、生理病变研究等许多领域可广泛应用。
遥感图像识别
航空遥感和卫星遥感图像通常用图像识别技术进行加工以便提取有用的信息。该技术目前主要用于地形地质探查，森林、水利、海洋、农业等资源调查，灾害预测，环境污染监测，气象卫星云图处理以及地面军事目标识别等。
军事刑侦
图像识别技术在军事、公安刑侦方面的应用很广泛，例如军事目标的侦察、制导和警戒系统；自动灭火器的控制及反伪装；公安部门的现场照片、指纹、手迹、印章、人像等的处理和辨识；历史文字和图片档案的修复和管理等等。
生物医学
图像识别在现代医学中的应用非常广泛，它具有直观、无创伤、安全方便等特点。在临床诊断和病理研究中广泛借助图像识别技术，例如CT(ComputedTomography)技术等。
机器视觉
作为智能机器人的重要感觉器官，机器视觉主要进行3D图像的理解和识别，该技术也是目前研究的热门课题之一。
机器视觉的应用领域也十分广泛，例如用于军事侦察、危险环境的自主机器人，邮政、医院和家庭服务的智能机器人。此外机器视觉还可用于工业生产中的工件识别和定位，太空机器人的自动操作等。
数字图像处理：
是通过计算机对图像进行去除噪声、增强、复原、分割、提取特征等处理的方法和技术。 无人驾驶技术 传送门
无人驾驶使用的技术有哪些
无人驾驶技术是传感器、计算机、人工智能、通信、导航定位、模式识别、机器视觉、智能控制等多门前沿学科的综合体。按照无人驾驶汽车的职能模块，无人驾驶汽车的关键技术包括环境感知、导航定位、路径规划、决策控制等。 机器学习 通俗理解
概念
像豆瓣、淘宝、QQ音乐这些推荐系统，背后的秘密武器正是机器学习。机器学习有点像人类的决策过程 举例：挑橘子
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c2b95cf23bde9fe01ca8ecc0ea7f0140/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/268f1cbea279b66ab94e79f9ee7cc32e/" rel="bookmark">
			复试导师问题——专业课问题（408&#43;数据库&#43;程序语言）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		专业问题 算法 随机函数
rand函数产生的是伪随机数，也就是说它不是一个真实的随机数。从一个表里面选取，每次调rand都能拿到一个不同的数，只要整个序列的规律不明显，整个函数看起来就是随机的。但程序跑一遍退出后，再重新跑一遍，两次输出的结果是相同的。是根据一个数（我们可以称它为种子）为基准以某个递推公式推算出来的一系列数，当这系列数很大的时候，就符合正态公布，从而相当于产生了随机数，但这不是真正的随机数，当计算机正常开机后，这个种子的值是定了的在c语言中的rand函数中有一个定义叫做种子，rand函数是通过对这个种子进行一系列的运算来模拟出一个随机数的。我们直接调用rand函数，并不指定种子，系统就会调用默认的种子：1，来产生随机数。因为每次重新运行时的种子都是1，运行出来的结果自然就还是这几个数啦。用时间做种子 不使用循环，判断一个数是否是2的N次方
2，4，8，16这样的数转化成二进制是10，100，1000，10000。如果X减1后与X做与运算，答案若是0，则X是2N次方。 在字符串中找出只出现一次的数字，其余数字出现两次
列一个数组，0-9，出现就给数组加1，然后扫描这个数组即可 单淘汰相关算法
字符串匹配算法
KMP算法利用每次匹配完的结果和子串特性，跳着移动，主串指针不用回溯，子串指针回溯次数也变少，完了算NEXT数组，失匹则跳到子串的next位置重新与主串当前位置进行比较next数组计算：算部分匹配值：字符串的前缀和后缀最长相等前后缀的长度。然后右移+1改进，对next数组进行改进，，回溯时碰见相同数值就匹配值修改为最开始的那个 排序的时间、空间复杂度
01背包问题复杂度
有N件物品，每件物品的体积为wi，价值为ci，现有一个容量为v的背包，问如何选取物品放入背包，使得背包内物品的总价值最大。其中每件物品只有1件 f[i,j]代表前i个物品背包容量最大为j时最多能装的物品的总重量对第i 个物品，要么装要么不装。 完全背包问题就是物品改为无穷件其实就是构造一个二维数组，所以时间复杂度和空间复杂度为o(nv) 简述弗洛伊德算法求最短路径或如何求最短路径
如何判断无向图是树
不用加减乘除算加法
用异或运算实现无进位加法用与运算进位 class Solution { public: int Add(int num1, int num2) { int tmp = 0; while(num2) { tmp = num2 ^ num1;	//用于存储num1+num2的值 num2 = (num2 &amp; num1) &lt;&lt; 1; //用于存储进位值 num1 = tmp; } return num1; } }; 数据结构 图书管理系统，图书用什么结构保存？
迪杰斯特拉算法求最短路径
最小生成树算法
链表反转
深度优先遍历使用栈还是队列实现的？叙述一下遍历的过程。
简述快排算法的思想
快排的思想就是说，选定数组中第一个数参考值 key ，然后用两个指针，分别从前往后，从后往前，把比 key 大的放在后边，比 key 小的放在前边。两个指针相遇之后，把 key 和 这个停止点的值交换。至此完成一趟排序，到这里，比key大的都在key后面，比key小的都在key前面。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/268f1cbea279b66ab94e79f9ee7cc32e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80d42c52066787fa66bd85844cc084b8/" rel="bookmark">
			从零构建FLINK整合Drools动态规则实时运营系统（项目案例）-第6篇（V1.0版开发篇）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 项目介绍在线视频： https://www.bilibili.com/video/BV1zv41157yY
本案例是一个专注于flink动态规则计算的项目，核心技术组件涉及flink、hbase、clickhouse、drools等
项目可根据各类个性化需求进行二次开发后，直接用于实时运营，实时风控、交通监控等场景的线上生产
列位看官，为了能够更好地理解后续《动态规则版实时运营系统》的设计思想和代码实现，
我们先来开发一个简化版且没有动态规则功能的实时运营系统；
规则匹配state查询逻辑设计 行为数据state窗口设计 存储上线以来的所有用户明细（显然不合适，但是先从简单做起）
行为次数类条件查询设计 代码片段；详细完整代码请参见项目工程
/** * @author 涛哥 * @nick_name "deep as the sea" * @contact qq:657270652 wx:doit_edu * @site www.doitedu.cn * @date 2021-03-28 * @desc 用户行为次数类条件查询服务实现：在flink的state中统计行为次数 */ public class UserActionCountQueryServiceStateImpl implements UserActionCountQueryService { ​ ​ /** * 查询规则参数对象中，要求的用户行为次数类条件是否满足 * 同时，将查询到的真实次数，set回 规则参数对象中 * * @param eventState 用户事件明细存储state * @param ruleParam 规则整体参数对象 * @return 条件是否满足 */ public boolean queryActionCounts(ListState&lt;LogBean&gt; eventState, RuleParam ruleParam) throws Exception { ​ // 取出各个用户行为次数原子条件 List&lt;RuleAtomicParam&gt; userActionCountParams = ruleParam.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/80d42c52066787fa66bd85844cc084b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a28276076e2eef1626d9b5f5d97198c/" rel="bookmark">
			自动辅助驾驶Openpilot安装 乐视手机去电池改造
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自动辅助驾驶Openpilot安装 乐视手机去电池改造 Openpilot购买必要硬件乐视手机电池改造 Openpilot Openpilot 是一款开源的无人驾驶平台，而这款开源项目最终目的是希望透过开源的力量，让大家来共同维护开发，让市面上所有车款都支援此系统。汽车要求配备
但首要条件需要具备两种系统 : (1)ACC主动式定速巡航系统 (2)辅助转向或相似系统。
为什麽局限于这两款系统的车款呢? 原里十分简单。
首先需要控制汽车要确认可以控制汽车油门、刹车及方向盘，而这两个系统刚好可以证实一辆汽车是可控制的。
ACC主动式定速巡航系统 : 可以确认油门即刹车辅助转系统 : 可以确认方向盘。
详细可参阅 https://zhuanlan.zhihu.com/p/33659057
购买必要硬件 首先购买 Panda （黑熊） + Harness （切换器）+ 线束 + 乐视手机（乐视Pro3 x720）
具体参考国内教程： http://wiki.dragonpilot.cn/cn/how_to_buy_openpilot.html
第二代硬件相对比较便宜，对于车道保持辅助足够了，开起车来来很轻松，特别在高速等封闭路段，只要设好最高速度值，脚放到刹车上，处理加塞等紧急情况即可。
乐视手机电池改造 下面重点说下手机去电池改造
在闲鱼网上买二手乐视Pro3手机（250元左右），
把由于手机工作的时候温度很高，且车辆停在太阳底下曝晒温度很高，防止手机电池过热燃爆，电池拆掉手机电池比较安全，亲测如下改造
参考文章拆机
https://bbs.le.com/thread-2105726-1.html
将电池拆除，电池的保护板留着，
手机里面有一个排线，敷铜比较宽那两条就是电源的正负极，如图左边为正右边为负，连到保护板上串接一个二极管，由于手机工作电流比较大，需要在电源处并连一个大电容，开始时接个220uF的电容，打开摄像头后会自动重启，再并联一个220uF的电容，共440uF就工作正常了。
（实测发现存在浪涌现象，建议多并联几个容量大的钽电容）
由于电解电容体积大，屏幕装不上，买了钽电容装上
装上钽电容后，用透明胶缠下焊盘和保护板，防止短路
装上屏幕，整机感觉很轻盈
由于Openpilot运行相当耗资源，如果手机没散热器可以很快升温到六十多度，然后软件自动报警。
买一个半导体手机散热器，听说固态制冷效果很好
散热器制冷效果不错，摸上去冰凉冰凉的。
简化了一下电源连接线
根据dragonpilot教程安装对应版本的openpilot，我选择使用SSH的安装方法，这种方法安装成功率高，使用界面安装 openpilot 经常不成功。
http://wiki.dragonpilot.cn/cn/how_to_change_openpilot_fork_via_ui.html
中文汉化方法：
装上车后发现控制不了车辆，查找原因最后发现是手机散热器的数据连接线是不通的，又捣鼓一番，把散热器拆了，用USB线直接连接
装上汽车（雅阁混动），效果很好
感受轻松驾驶乐趣！
2021/5/8
最后实测发现，由于汽车刹车等情况会造成电源电压不稳定（浪涌现象），建议多并联几个容量大的钽电容，我自己并联了四个470uF的钽电容。哈哈哈！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c57baaa374f272db318ae832df6ed2cd/" rel="bookmark">
			从零构建FLINK整合Drools动态规则实时运营系统（项目案例）-第5篇（用户画像篇）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 项目介绍在线视频： https://www.bilibili.com/video/BV1zv41157yY
本案例是一个专注于flink动态规则计算的项目，核心技术组件涉及flink、hbase、clickhouse、drools等
项目可根据各类个性化需求进行二次开发后，直接用于实时运营，实时风控、交通监控等场景的线上生产
项目完整视频教程和资料代码等，可在易学在线 https://v.51doit.cn 获取
技术交流，可加微信： haitao-duan
画像标签体系 用户基本属性标签用户订单属性标签用户退换货属性标签用户购物车属性标签用户活跃属性标签用户偏好属性标签 用户基本属性标签 用户属性指标主要根据业务数据来源（业务系统中的用户信息）
尽可能全面地描述用户基础属性
这些基础属性值是短期内不会有改变的，如年龄、性别、手机号归属地、身份证归属地等
字段类型定义备注user_idbigint用户编码login_namestring登录名称user_namestring用户姓名user_status_idint用户状态gender_idint用户性别birthdayint用户生日user_ageint用户年龄constellation_namestring星座名称zodiac_namestring生肖名称cellphone_idstring手机号cert_idstring证件号source_idbigint注册来源is_real_name_authint是否实名认证标志is_valid_cellphoneint是否认证手机标志is_has_photoint是否有头像标志is_tmp_user_flagtimestamp注册时间create_timestring注册日期create_datetimestamp修改时间modify_timestring修改时间modify_datetimestamp修改日期date_idstring数据日期 用户登录活跃标签 看用户近期登录时间段、登录时长、登录频次、常登陆地等指标
字段类型定义备注user_idint用户id用户唯一idlogin_city_rationstring常登陆地用户近一个月常登陆的3个地点及比率last_online_datestring最近登陆时间用户最近一次登录日期online_frequencyint登录频次用户近一个月登录频次online_timeint登录时长用户近一个月登录时长 用户年龄段标签 在做营销活动或站内推送时，可对不同年龄段做针对性运营
字段类型定义备注user_idstring用户编码contact_idstring联系人编码user_sexstring用户性别user_age_crowdstring用户年龄群体儿童（0-10）少年（11-15）… 用户交互行为标签 记录用户在平台上每一次操作行为，及该次行为所带来的标签。后续可根据用户的行为标签计算用户的偏好标签，做推荐和营销等活动
字段类型定义备注user_idstring用户id用户唯一idorg_idstring原始id标签idorg_namestring标签中文名称标签对应标签的中文名称is_validstring是否有效1有效cntstring行为次数用户行为次数date_idstring行为日期产生用户该条标签对应日期act_type_idint用户行为类型1搜索2浏览3收藏4下单5支付6退货tag_type_idint频道类型1母婴2家电3美妆4美食5服装6鲜花 用户消费能力标签 看用户的消费金额、消费频次、最近消费时间。进一步结合用户登录活跃情况，可以对用户做RFM分层。
字段类型定义备注user_idstring用户编码sum_paystring累积付费金额sum_numdecimal累积付费次数paid_levelint付费分层1：[0,30) 用户订单画像标签 字段类型定义备注user_idbigint用户first_order_timestring首单日期last_order_timestring末单日期first_order_agobigint首单距今时间last_order_agobigint末单距今时间month1_order_cntbigint近30天购买次数month1_order_amtdouble近30天购买金额month2_order_cntbigint近60天购买次数month2_order_amtdouble近60天购买金额month3_order_cntbigint近90天购买次数month3_order_amtdouble近90天购买金额max_order_amtdouble最大订单金额min_order_amtdouble最小订单金额total_order_cntbigint累计消费次数（不含退拒）total_order_amtdouble累计消费金额（不含退拒）total_coupon_amtdouble累计使用代金券金额user_avg_order_amtdouble平均订单金额（含退拒）month3_user_avg_amtdouble近90天平均订单金额（含退拒）common_addressstring常用收货地址common_paytypestring常用支付方式month1_cart_cnt_30bigint最近30天加购次数month1_cart_goods_cnt_30bigint最近30天加购商品件数month1_cart_submit_cnt_30bigint最近30天提交件数month1_cart_submit_ratedouble最近30天商品提交占比month1_cart_cancel_cntbigint最近30天取消商品件数dw_datestring计算日期 用户退拒货行为画像标签 字段类型定义备注user_idbigint用户p_sales_cntbigint不含退拒商品购买数量p_sales_amtdouble不含退拒商品购买的商品总价p_sales_cut_amtdouble不含退拒实付金额（扣促销减免）h_sales_cntbigint含退拒购买数量h_sales_amtdouble含退拒购买金额h_sales_cut_amtdouble含退拒购买金额（扣促销减免）return_cntbigint退货商品数量return_amtdouble退货商品金额reject_cntbigint拒收商品数量reject_amtdouble拒收商品金额dw_datebigint数仓计算日期 用户购物偏好画像标签 字段类型定义备注user_idbigint用户common_first_catbigint最常购买一级类目名称common_second_catbigint最常购买二级类目名称common_third_catbigint最常购买三级类目名称common_brand_idbigint最常购买的品牌dw_datebigint数仓计算日期 画像标签存储及表结构 画像数据，行数基本与公司用户规模相同；
列数则众多（一个中型互联网企业，用户的画像标签通常都在1000-2000个之间），而且会在实际运营中，不断增加新的标签，则会不断增加新的列；
考虑到行数及列数规模巨大（数亿行*数千列），以及列的动态增加特性，业内通常将用户画像标签数据存于Hbase之中，再辅以elastic search做二级索引，以实现对hbase中画像数据的快速检索；
rowkey（deviceId）sexagevip…1200212132vip-1…1200213028vip-2… 用户画像整体技术架构 关于用户画像，限于本课程的侧重点和篇幅，这里就不详细展开了。
有兴趣的朋友，可以学习多易教育的数据分析类项目课程《Titan综合数据运营系统》
https://v.51doit.cn/detail/p_5fba7371e4b04db7c0903f2b/8
用户画像库数据模拟 假设公司已有的用户画像库，存储在hbase中，表结构为如下
列簇 f
rowkey（deviceId）sexagevip…1200212132vip-1…1200213028vip-2… 可用数据模拟器快速生成约100万个用户的画像标签数据（每个用户1000个标签）
/** * @author 涛哥 * @nick_name "deep as the sea" * @contact qq:657270652 wx:doit_edu * @site www.doitedu.cn * @date 2021-03-27 * @desc 用户画像数据模拟器 * &lt;p&gt; * deviceid,k1=v1 * &lt;p&gt; * hbase中需要先创建好画像标签表 * [root@hdp01 ~]# hbase shell * hbase&gt; create 'yinew_profile','f' */ public class UserProfileDataGen { public static void main(String[] args) throws IOException { Configuration conf = new Configuration(); conf.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c57baaa374f272db318ae832df6ed2cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1999ff5620959b3825ee775ec55f81e0/" rel="bookmark">
			java8中 Collectors.groupingBy用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、数据准备：
2、分组
按照类目分组：
按照几个属性拼接分组：
根据不同条件分组
3、多级分组
4、按子组收集数据
求总数
求和
把收集器的结果转换为另一种类型
联合其他收集器
Collectors.groupingBy根据一个或多个属性对集合中的项目进行分组
1、数据准备： public Product(Long id, Integer num, BigDecimal price, String name, String category) { this.id = id; this.num = num; this.price = price; this.name = name; this.category = category; } Product prod1 = new Product(1L, 1, new BigDecimal("15.5"), "面包", "零食"); Product prod2 = new Product(2L, 2, new BigDecimal("20"), "饼干", "零食"); Product prod3 = new Product(3L, 3, new BigDecimal("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1999ff5620959b3825ee775ec55f81e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/975402a45a5115e1c3b24dca38f59bc1/" rel="bookmark">
			访问控制相关概念及常见模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		访问控制旨在通过身份标识、身份验证和授权来允许，拒绝，限制和撤销对资源的访问。在讨论数据访问管理时，我们必须先把物理访问和逻辑访问弄明白。物理访问是指建筑物，设备和文档，而逻辑访问是指计算机或系统访问。
访问管理概念 让我们仔细探讨一下安全和身份管理概念，这些概念已包含在某些身份管理协会认证计划和考试的范围内了。
身份标识
身份标识是一种能够确保主体（用户、程序或进程）就是其所声称实体的方法。
身份验证
身份验证是将实体提供的凭据与存储在系统上的实体信息进行比较以验证身份的过程。
授权
授权发生在实体的标识和身份验证发生之后，以确定允许他们执行的操作。授权是通过使用访问控制来实现的。
最小特权原则
最小特权原则规定，我们应该只允许对一个实体的最小访问权限，这个实体可以是用户、设备、帐户或进程，使其能够执行所需功能的实体。该概念也适用于计算机服务，这些服务可能被授予比通过不当编程运行系统所需的更多的访问权限和功能。
职责分离原则
职责分离原则是企业各业务部门及业务操作人员之间责任和权限的相互分离机制。主要目的是通过允许两个人完成一项任务来防止剥削和欺诈。例如，为了确保在线转移资金时的安全性，系统可能需要两个人进入系统并批准交易。
访问控制列表
访问控制列表或ACL是一个文件，通常指计算机文件系统，它将权限附加到对象或实体。ACL指定向哪些用户或系统进程授予对对象的访问权限，以及允许对象进行哪些操作。典型ACL中的每个条目都指定一个主题和一个操作。例如，如果一个文件对象有一个包含（Alice:read，write；Bob:read）的ACL，这将授予Alice读写该文件的权限，而Bob只读取该文件。
功能
如果ACL在给定身份和一组权限的情况下定义权限，那么基于功能的访问提供了一种完全基于我们拥有的东西（如令牌，通行证或密码）授予访问权限的替代方法。在基于功能的系统中，应用程序可以与其他应用程序共享定义其访问级别的令牌。
访问控制方法 根据访问控制方法，可以基于我们已知，拥有和存在的事物来授予访问权限。
例如，我们知道的是密码或token，我们拥有的是通行证，一直存在的是指纹或其他生物识别数据。
访问控制模型 常见访问控制模型包括：自主访问控制，强制访问控制，基于角色的访问控制和基于属性的访问控制。
自主访问控制
自由访问控制（Discretionary Access Control，DAC）是一种基于目标资源所有者确定访问权限的访问控制模型。资源的拥有者可以决定谁拥有访问权限，以及他们到底拥有哪些资源的访问权限。
强制访问控制
强制访问控制（Mandatory Access Control，MAC）是一种访问控制模型，其中资源的所有者无法决定谁可以访问它，而是由有权设置资源访问权限的组织或个人来决定谁拥有访问权限。我们经常可以在政府组织中发现MAC的实施，在这些组织中，对给定资源的访问主要由以下因素决定：
应用于数据（机密，最高机密等）的敏感标签，根据个人被允许访问的敏感信息的级别，通过个人是否真的有必要访问资源，这是最小特权原则。 基于角色的访问控制
基于角色的访问控制（Role-Based Access Control ，RBAC）是一种访问控制模型，与MAC相似，它的功能是由权限而不是资源所有者设置的访问控制。RBAC和MAC之间的区别在于RBAC中的访问控制是基于访问资源的个体角色。
基于属性的访问控制
基于属性的访问控制（ABAC）是基于属性的。这些属性可以是特定人员、资源或环境的属性。属性可以是主体（游乐园中人的身高）、资源（仅在特定操作系统或网站上运行的软件）或环境（一天中的时间或经过的活动时间长度）。
军事和政府组织可以使用多级访问控制模型，我们刚才讨论的简单访问控制模型可能不足以保护我们控制访问的信息。
物理访问控制 在讨论物理访问控制时，我们通常主要关注个人，设备和车辆的访问控制。
个人的访问控制通常围绕着控制个人进出建筑物或设施。我们可以看到许多建筑物实施此类控制，它们以通行证的形式来控制对设施的门禁。此类通行证通常配置在ACL上，以允许或拒绝可以将其用于哪些门并规定一天中可以使用的时间。
车辆的物理访问控制通常围绕着阻止车辆进入限制区域。
尾随
物理访问控制最常见的问题之一是尾随问题。当我们对物理访问控制措施进行身份验证时（例如，使用通行证时），就有可能发生尾随，然后另一个人直接跟随我们而未对其自身进行身份验证。
文章来源：https://www.identitymanagementinstitute.org/access-control-types-and-models/
关于我们 「龙归科技」 是一个专注于低代码赋能企业级信息化服务提供商。核心创始人团队来自绿盟安全、红帽开源操作系统、知名游戏玩蟹科技、知名开源社区等专家共同创立。
「龙归科技」 致力于让中国每一个企业拥有专属的自动化办公操作系统，助力企业或政府拥抱 （Cloud Native First）云原生优先战略，帮助客户构筑以「身份与应用」为中心的现代化 IT 基础设施！从而实现 「数字化转型」 及 「软件行业工业化生产」 ！
主打产品：ArkOS方舟操作系统：一个企业级办公自动化操作系统 ，结合自研低代码应用开发平台，构建产业生态，专注为各类企业与组织机构打造一体化全栈云原生平台。系统自带应用包括：ArkID 统一身份认证，ArkIDE，ArkPlatform，App Store 等产品。截至目前，公司已经获得 15个 软件著作权、2个发明专利，并与2020年11月份，获得北京海淀区中关村国家高新技术企业认定。
相关链接： 官网：https://www.longguikeji.com/
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/975402a45a5115e1c3b24dca38f59bc1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/876e82c3603518e14617106fe5a6d8f9/" rel="bookmark">
			拉格朗日方法求最优解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、问题二、拉格朗日手工求解三、拉格朗日编程求解 一、问题 二、拉格朗日手工求解 1、拉格朗日函数
2、偏导解变量
3、带入
三、拉格朗日编程求解 代码
# 导入包 from sympy import * # 设置变量 x,y,z,k = symbols('x,y,z,k') a,b,c=symbols('a,b,c') f = 8*x*y*z g = x**2/a**2+y**2/b**2+z**2/c**2-1 #构造拉格朗日函数 L=f+k*g #求导 dx = diff(L, x) # 对x求偏导 print("dx=",dx) dy = diff(L,y) #对y求偏导 print("dy=",dy) dz = diff(L,z) #对z求偏导 print("dz=",dz) dk = diff(L,k) #对k求偏导 print("dk=",dk) dx= 8*y*z + 2*k*x/a**2 dy= 8*x*z + 2*k*y/b**2 dz= 8*x*y + 2*k*z/c**2 dk= -1 + z**2/c**2 + y**2/b**2 + x**2/a**2 #求出个变量解 m= solve([dx,dy,dz,dk],[x,y,z,k]) print(m) #变量赋值 x=sqrt(3)*a/3 y=sqrt(3)*b/3 z=sqrt(3)*c/3 k=-4*sqrt(3)*a*b*c/3 #计算方程的值 f = 8*x*y*z print("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/876e82c3603518e14617106fe5a6d8f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e57cfe55f27f5e21b255509116feb9a1/" rel="bookmark">
			Java进阶：Spring Boot连接MySQL8.0配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 spring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/springboot_test?characterEncoding=utf-8&amp;serverTimezone=UTC&amp;useSSL=false username: root password: 131415 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea0cac462f376d3ff49666b551fcfb0d/" rel="bookmark">
			分享 kettle pdi-ce-9.1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天找了一下最新的pdi
https://dev.zhidaohub.xyz/share/pdi-ce-9.1.0.0-324.zip 官方地址：下载较慢
https://sourceforge.net/projects/pentaho/files/Pentaho%208.1/client-tools/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7cbb1d454e95f964b5ef9763b00bd95a/" rel="bookmark">
			python在图片中绘制多边形区域，并判断点在不在此多边形区域内
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在图片中绘制多边形区域，并判断点在不在此多边形区域内 （自己学习使用）
1. 全部代码
import json import numpy as np import os from PIL import Image import matplotlib.pyplot as plt import cv2 ''' 在图片中绘制多边形区域 ''' def process_points(im_path,points,output_path): # 获取坐标信息, points = np.array([points], dtype=np.int32) # 读取图片名 img = cv2.imread(im_path) ###绘制mask zeros = np.zeros((img.shape), dtype=np.uint8) # # 原本thickness = -1表示内部填充,这里不知道为什么会报错,只好不填充了 改用函数cv2.polylines #cv2.polylines(img, points, isClosed=True, thickness=5, color=(144, 238, 144)) mask = cv2.fillPoly(zeros, points, color=color_light_green) ####填充颜色 ##绘制轮廓 cv2.drawContours(img, points, -1, (144, 238, 144), 5) ###绘制轮廓 ##叠加mask和普通图片 mask_img = 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7cbb1d454e95f964b5ef9763b00bd95a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dfb2fa8bc6a57e0c6382f7e09b3d2acf/" rel="bookmark">
			VSCode部分快捷键和使用设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VScode使用过程中一些设置和习惯记录一下。
一、编辑器中选择一个文件时，资源管理器中的光标会自动跳转过去并选中，体验很不好，可以选择关闭："explorer.autoReveal": false
二、关闭代码缩略图："editor.minimap.enabled": false
三、在json文件中使用注释，会显示错误，如下：
两种方案可以解决：
a、点击右下角的JSON，在配置框中输入jsonc，然后确定就可以了，这种方式可以禁用当前文件的错误提示。
b、可以在设置文件中添加以下配置：
"files.associations": { "*.json": "jsonc" },
这样所有的Json文件都会禁用这个提示。
四、回到前一个光标停留的位置，比如转到方法中后想再退回去，可以自定义快捷键：
在快捷键设置中查找"后退"，然后自定义为shift+space，这样一只手就能操作了，比ctl+箭头方便多了。
同时也可以自定义"前进"快捷键。
五、一些好用的快捷键
1、注释：
a) 行注释或取消（//a）：ctrl+/，也有组合的（注释[ctrl+k,ctrl+c]，取消[ctrl+k,ctrl+u]），当然是ctrl+/好用了
b) 部分注释（/*a*/）：[alt+shift+A]
2、移动行：alt+up/down
3、显示/隐藏左侧目录栏：ctrl + b，ctrl+q（打开资源管理器即工程目录，同时光标定位到当前选项卡处）
4、复制当前行：shift + alt +up/down
5、控制台终端显示与隐藏：ctrl + ~
6、代码格式化：shift + alt +f
7、打开最近打开的文件：ctrl + r
8、跳转到指定行：ctrl + g（输入行号）
9、显示代码提示：ctrl + i
10、
选中某个词时，会把相同的词都标记，使用alt+w切换全词匹配，alt+c切换区分大小写
11、速览定义：alt + f12(可自定义)，方法或者属性定义悬窗预览而不跳转
12、折叠函数：ctrl+k+0、ctrl+k+j折叠/展开所有内容，这会折叠类里面所有可折叠的部分包括类，如果只想折叠函数，可以使用ctrl+k+n(n表示折叠到某一级，比如ctrl+k+1只会折叠引用部分，ctrl+k+2只折叠函数，ctrl+k+3只折叠函数里的第一层{ })
六、Ctrl+鼠标滚动改变字体大小
"editor.mouseWheelZoom": true,
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4247388697ce89b7a67b000a2551d65c/" rel="bookmark">
			SharedPreferences存储bean
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SharedPreferences存储bean package com.alipayjf.game.util; import android.content.Context; import android.content.SharedPreferences; import android.util.Base64; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.Serializable; public class SharedPreferencesUtil { private static final String FILENAME = "CDJ"; private static String getFileName(Context context) { return context.getPackageName() + FILENAME; } private static SharedPreferences getSharedPreferences(Context context) { SharedPreferences sharedPreferences = context.getSharedPreferences( getFileName(context), Context.MODE_MULTI_PROCESS); return sharedPreferences; } /** * 存放实体类以及任意类型 * * @param context 上下文对象 * @param key * @param obj */ public static void putBean(Context context, String key, Object obj) { if (obj instanceof Serializable) {// obj必须实现Serializable接口，否则会出问题 try { ByteArrayOutputStream baos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(baos); oos.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4247388697ce89b7a67b000a2551d65c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1aa94c51b0119fba76adcfd48224185/" rel="bookmark">
			纯vue&#43;天气预报，不借助插件，大屏数据化展示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		做大屏项目的时候，在项目中遇到要展示天气预报。没有写过，以为很难。在百度了很多之后，自己摸索写出来了。
效果：
后台返的数据，拿自己要的数据就行：
代码：
&lt;template&gt; &lt;div &gt; &lt;div class="headText"&gt;天气预报&lt;/div&gt; &lt;div class="weather main_envir" v-loading="loading"&gt; &lt;div class="crb-tit"&gt; &lt;div class="wea_box" v-for="(item, i) in this.tianqi" :key="i" v-show="i &lt; 4" &gt; &lt;p&gt; //img这一块，src是http的，直接引入就行。其中有两个图片没有找到，从ui那里切图过来，引入就行 &lt;img src="./images/duoyunzhuanyin.png" alt="" v-if="item.type == '多云转阴'" /&gt; &lt;img src="http://api.map.baidu.com/images/weather/day/yin.png" alt="" v-if="item.type == '阴'" /&gt; &lt;img src="http://api.map.baidu.com/images/weather/day/leizhenyu.png" alt="" v-if="item.type == '雷阵雨'" /&gt; &lt;img src="http://api.map.baidu.com/images/weather/day/xiaoyu.png" alt="" v-if="item.type == '小雨' || item.type == '小雨转阴' || item.type == '阴转小雨'" /&gt; &lt;img src="http://api.map.baidu.com/images/weather/day/zhongyu.png" alt="" v-if="item.type == '中雨'"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d1aa94c51b0119fba76adcfd48224185/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/512a4aa61c783247c2dc5ac28a17cae0/" rel="bookmark">
			vector＜bool＞与bitset的大小对比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1，
#include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;bitset&gt; using namespace std; int main() { vector&lt;bool&gt; bv(63,false); bitset&lt;63&gt; bs; cout&lt;&lt;bs.size()&lt;&lt;" "&lt;&lt;sizeof(bs)&lt;&lt;endl; cout&lt;&lt;bv.size()&lt;&lt;" "&lt;&lt;bv.capacity()&lt;&lt;endl; return 0 ; } 输出结果：
./a.out
63 8
63 64
2，
int main() { vector&lt;bool&gt; bv(65,false); // 63 --&gt; 65 bitset&lt;65&gt; bs; // 63 --&gt; 65 cout&lt;&lt;bs.size()&lt;&lt;" "&lt;&lt;sizeof(bs)&lt;&lt;endl; cout&lt;&lt;bv.size()&lt;&lt;" "&lt;&lt;bv.capacity()&lt;&lt;endl; return 0 ; } ./a.out
65 16
65 128
相同的vector&lt;bool&gt; 和bitset 在内存占用上应该是差不多的，但是bitset 声明的时候必须用固定大小，这是一大缺陷；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90dc6bc8dd5c29ba39f7934aec809bfd/" rel="bookmark">
			BFS java实现,java实现dfs及bfs算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		dfs(深度优先搜索算法)主要是通过栈的方式来实现的，主要规则是
选择一个初始顶点，如果可能(若存在)，访问该顶点的一个邻接顶点，标记它，并把它放入栈中。
当不能执行 第一步时(原顶点不存在未访问的邻接顶点)，如果栈不空，就从栈中弹出一个顶点。
循环执行第一步、第二步，若栈空，则已完成了整个搜索过程。
bfs(广度优先搜索算法)主要是通过队列来实现的，其主要规则为：
遍历起始点的所有邻接点，并标记、入队。
所有邻接点都已入队后，即不存在未标记的邻接点时，从队头取一个顶点，并使其成为当前顶点。重复执行第一步、第二步。
直至因队列为空而不能执行第二步时，搜索结束。
栈的操作类：
//---------------------栈的操作
class stackX{
private final int size = 20;
private int[] st;
private int top;
public stackX(){
st = new int[size];
top = -1;
}
public void push(int i){
st[++top] = i;
}
public int pop(){
return st[top--];
}
public int peek(){
return st[top];
}
public boolean isEmpty(){
return (top==-1);
}
}
队列操作类：
//---------------队列操作类
class Queue{
private final int size = 20;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/90dc6bc8dd5c29ba39f7934aec809bfd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48cd75090b5fa3b81c8ea8bc3c47aa8c/" rel="bookmark">
			第十一届蓝桥杯（未完）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include &lt;iostream&gt; using namespace std; int main() { int i,j=0,k; for(i=1;i&lt;=2020;i++) { k=i; while(k!=0) { if(k%10==2) j++; k=k/10; } } printf("%d",j); return 0; }
#include &lt;iostream&gt; using namespace std; int gcd(int a,int b) { int t; while(b) { t=b; b=a%b; a=t; } if(a==1) return 1; return 0; } int main() { int i,j,k=0; int a,b,t; for(i=1;i&lt;=2020;i++) { for(j=1;j&lt;=2020;j++) { if(gcd(i,j)) k++; } } printf("%d",k); return 0; } #include &lt;iostream&gt; using namespace std; int main() { int i,j; long long k=0; long long a[100][100]; for(i=0;i&lt;100;i++) {	for(j=0;j&lt;=i;j++) { k++; if(i%2==1) a[j][i-j]=k; else a[i-j][j]=k;	} } printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/48cd75090b5fa3b81c8ea8bc3c47aa8c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fee1630758d7d706640aefb247415eb8/" rel="bookmark">
			c语言数组复制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		两种方法可以实现。
为方便说明，定义两个整型数组a,b，并实现将a中的值赋值到b中。
int a[4] = {1,2,3,4}, b[4];
1、 通过数组遍历，逐个赋值。
定义循环变量int i;
for(i = 0; i &lt; 4; i ++)
b[i] = a[i];
该程序功能为遍历数组a，逐个赋值到数组b对应元素中。
2、 借助内存复制函数memcpy，整体赋值。
void *memcpy(void *dst, void *src, size_t size);
这个函数的功能为将src上，大小为size字节的数据赋值到dst上。
调用该函数时需要引用头文件cstring,即
#include 赋值数组的代码为
memcpy(b,a,sizeof(a));
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9803c1ca2ef5c27c4e117d357824c0d/" rel="bookmark">
			3.3ADT
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Opration
InitList（*L）： 初始化操作，建立一个空的线性表L
ListEmpty（L）： 若线性表为空，返回ture，否则返回false
ClearList（*L）： 将线性表清空
GetElem（L，i，*e）： 将线性表L中的第i个位置元素值返回给e
LocateElem（L，e）： 在线性表L中查找与给定值e相等的元素，如果查找成功，返回该元素在在表中序号表示成功；
否则，返回0表示失败
ListInsert（*L，i，e）： 在线性表L中的第i个位置插入新元素e
ListDelete（*L，i，*e）： 删除线性表L中的第i个位置元素，并用e返回其值
ListLength（L）： 返回线性表L的元素个数
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8cd703abe12a4e1e2e240334696257c/" rel="bookmark">
			JS基础面经0331
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. document load 和 document ready 的区别 页面加载完成有两种事件 1.load是当页面所有资源全部加载完成后（包括DOM文档树，css文件，js文件，图片资源等），执行一个函数 问题：如果图片资源较多，加载时间较长，onload后等待执行的函数需要等待较长时间，所以一些效果可能受到影响 2.$(document).ready()是当DOM文档树加载完成后执行一个函数 （不包含图片，css等）所以会比load较快执行 在原生的js中不包括ready()这个方法，只有load方法也就是onload事件 总结：如果页面中要是没有图片之类的媒体文件的话ready与load是差不多的，但是页面中有文件就不一样了，所以还是推荐大家在工作中用ready。 补充知识：
DOM文档解析：
解析html结构
加载脚本和样式文件
解析并执行脚本
构造html的DOM模型 //ready
加载图片等外部资源文件
页面加载完毕 //load
2.JavaScript 中如何检测一个变量是一个 String 类型？ 答案：三种方法（typeof、constructor、Object. prototype. toString. call()）
解析：
① typeof typeof('123') === "string" // true typeof '123' === "string" // true ② constructor '123'.constructor === String // true ③ Object.prototype.toString.call() Object.prototype.toString.call('123') === '[object String]' // true 3.请用 js 去除字符串空格？ 答：replace 正则匹配方法、str. trim()方法、JQ 方法：$. trim(str)方法
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c8cd703abe12a4e1e2e240334696257c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b114740e687410d503a711887e493611/" rel="bookmark">
			锁相环初探 ——一定要看小结哦！！！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 工程实训，无意间问老师什么是锁相环？结果被骂回来。惨啊！自己探索出来的，有什么纰漏，还望见谅。
一、锁相环是什么？ 锁相环（PLL），就是为了锁定频率的，它能使受控振荡器的频率和相位均与输入参考信号保持同步。说白了，就例如，我要让别人和我保持一样的生活作息。它是一个以相位差为控制对象的反馈控制系统，是将参考信号与受控振荡器输出信号之间的相位进行比较，产生相位差电压来调整受控振荡器输出信号的相位，从而使受控振荡器的输出频率与参考信号保持一致。（反馈控制:可以理解为高中生物中的的负反馈调节）在两者频率相同而相位并不完全相同的情况下，两个信号之间的相位差能稳定在一个很小的范围里。（就是使外部晶振产生的信号与需要的信号匹配，提供时钟的控制）
借大佬的图
二、基本构成 1.鉴相器（PFD） 鉴相器:检测输入信号和输入信号的相位差。当两者的频率相同、相位不同时，鉴相器将输出误差信号，经过环路滤波器输出控制信号去控制压控振荡器（VCO),使其输出的频率与参考信号一致，而相位相差一个预定值。这个预定值就是恒定相位差（稳态相位差），此稳态相位差经鉴相器转变为直流误差信号，通过环路滤波器（低通滤波）过滤掉，控制VCO的输出频率和参考信号频率一致。
2.环路滤波器 环路滤波器从实质上讲也是低通滤波，其作用主要是滤除鉴相器输出误差电压中的高频及
干扰成分，得到控制电压U，因为控制电压U是决定VCO工作频率的电压，因此它的变化对锁相环路的性能参数有很大的影响。
3.压控振荡器 压控振荡器（VCO）是锁相环的被控对象。压控振荡器是一个电压——频率变换装置，在环路中作为频率可调振荡器，其振荡频率应随输入控制电压线性变化。
三.锁相环要控制的三大要素 相位噪声
要尽量降低相位噪声，因为相位噪声过高，会使得锁相环的效率降低，甚至完全无法工作。相噪值的计算公式：MKR Noise = MKR Value - 10log RBW。
参考杂散
锁相环中最常见的杂散信号就是参考杂散，这些杂散信号会由于电荷泵源电流与汇电流的失配、电荷泵漏电流。
锁定时间
锁相环从一个指定频率跳转到另一个指定频率（在给定的频率误差范围内）所用的时间就是锁定时间。
四.小结 其实说了这么多，大部分大家在网上都可以找到更好的讲解。那我就分享一下我个人理解的锁相环。
我感觉把锁相环三个字分开来更好理解。
锁：锁定
锁定什么？
锁定频率和相位，使得外界的输入信号锁定到和参考信号一致。这样才能完成后序的工作。
相：相位
谁的相位?
输入信号的相位
环：环路
因为不可能一次就可以完美的把输入信号与参考信号匹配完成，所以需要在环路进行不停地调整，因为鉴相器输出的误差电压总是在某一范围内摆动。这个误差电压通过环路滤波器变成控制电压加到压控振荡器上，使压控振荡器的频率趋向于参考信号的频率 ，直到压控振荡器的频率变化到与输入参考信号的频率相等，并满足一定条件，环路就在这个频率上稳定下来。两个频率之间的相位差不随时间变化而是一个恒定的常数，这时环路就进入“锁定”状态。
鉴相器详讲：https://blog.csdn.net/qq_38496973/article/details/108342879?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161718639616780266275284%2522%252C%2522scm%2522%253A%252220140713.130102334…%2522%257D&amp;request_id=161718639616780266275284&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2allsobaiduend~default-2-108342879.pc_search_result_hbase_insert&amp;utm_term=%E9%89%B4%E7%9B%B8%E5%99%A8
滤波器详讲：https://blog.csdn.net/qq_42113899/article/details/89060804?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161719304016780269871548%2522%252C%2522scm%2522%253A%252220140713.130102334…%2522%257D&amp;request_id=161719304016780269871548&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2allfirst_rank_v2~rank_v29-3-89060804.pc_search_result_hbase_insert&amp;utm_term=%E7%8E%AF%E8%B7%AF%E6%BB%A4%E6%B3%A2%E5%99%A8
压控振荡器详讲：https://blog.csdn.net/xutonghuang1986/article/details/5691085?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161719310916780357279192%2522%252C%2522scm%2522%253A%252220140713.130102334…%2522%257D&amp;request_id=161719310916780357279192&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2allsobaiduend~default-11-5691085.pc_search_result_hbase_insert&amp;utm_term=%E5%8E%8B%E6%8E%A7%E6%8C%AF%E8%8D%A1%E5%99%A8
更深入的学习还在继续，有什么新知识，再分享。
大佬的文章收益匪浅哦
http://www.360doc.com/content/16/0601/20/33813117_564266468.shtml
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa2db89d10f19ff4cb728efbfbb16701/" rel="bookmark">
			爬虫项目十一：用Python爬下微博博主所有视频、所有微博数据、获取评论数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、微博数据1.分析页面2.分析url3.解析数据4.实现翻页 二、爬取视频1.加载数据2.获取视频详情url3.获取视频url4.下载视频 三、评论数据 前言 用Python爬下微博博主的所有微博数据，下载所有视频，爬下单个微博的评论数据，以papi酱为例
提示：以下是本篇文章正文内容，下面案例可供参考
一、微博数据 用python爬下papi酱的所有原创微博数据，有标题、点赞数、评论数、转发数
1.分析页面 我们打开页面观察页面，向下滑动可以发现有部分数据属于动态加载
我尝试利用requests单纯的访问页面并且保存到本地html文件，发现一条数据都没有
所以对于爬取微博数据将会用selenium爬取
2.分析url 我们复制出前三页的url，观察一下
第一页：https://weibo.com/xiaopapi?profile_ftype=1&amp;is_ori=1#_0 第二页：https://weibo.com/xiaopapi?is_search=0&amp;visible=0&amp;is_ori=1&amp;is_tag=0&amp;profile_ftype=1&amp;page=2#feedtop 第三页：https://weibo.com/xiaopapi?is_search=0&amp;visible=0&amp;is_ori=1&amp;is_tag=0&amp;profile_ftype=1&amp;page=3#feedtop 我们尝试去除一些参数看看能不能正常的访问页面，最后 经过我的测试，精简后的url，其中is_ori表示的就是显示原创微博，page就是页数
https://weibo.com/xiaopapi?is_ori=1&amp;page=3 3.解析数据 我们明白了数据属于动态加载，找到了url的规律，现在我们来解析数据，右键检查元素，我们看到数据都在div中，其中有一点要注意，就是第一个div和第最后一个div是不表示数据的，所以再解析数据需要剔除
实例代码如下：
def Parser_Home_page_Data(self): html=etree.HTML(self.bro.page_source) div_list=html.xpath('//div/div[@module-type="feed"]/div')[1:-1] for div in div_list: dic={} try: dic["author"]=div.xpath('.//div[@class="WB_detail"]/div[@class="WB_info"]/a[1]/text()')[0] except: dic["author"]="" try: dic["icon_member"]=div.xpath('.//div[@class="WB_detail"]/div[@class="WB_info"]/a[last()]/em/@class')[0] except: dic["icon_member"]="" try: dic["title"]="".join(div.xpath('.//div[@class="WB_detail"]/div[@node-type="feed_list_content"]//text()')).replace("\n","").replace(" ","").replace("\u200b","") except: dic["title"]="" try: dic["forward_num"]=div.xpath('.//div[@class="WB_handle"]/ul[1]/li[2]//span[@class="line S_line1"]/span[1]/em[last()]/text()')[0] except: dic["forward_num"]="" try: dic["comment_num"]=div.xpath('.//div[@class="WB_handle"]/ul[1]/li[3]//span[@class="line S_line1"]/span[1]/em[last()]/text()')[0] except: dic["comment_num"]="" try: dic["like_num"]=div.xpath('.//div[@class="WB_handle"]/ul[1]/li[4]//span[@class="line S_line1"]/span[1]/em[last()]/text()')[0] except: dic["like_num"]="" try: dic["equipment"]=div.xpath('.//div[@class="WB_detail"]/div[@class="WB_from S_txt2"]/a[last()]/text()')[0] except: dic["equipment"]="" try: dic["time"]=div.xpath('.//div[@class="WB_detail"]/div[@class="WB_from S_txt2"]/a[1]/text()')[0] except: dic["
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa2db89d10f19ff4cb728efbfbb16701/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46f004959850731da47739399b12c352/" rel="bookmark">
			Altium Designer：AD重叠元器件报错提醒取消方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Altium Designer：AD重叠元器件报错提醒取消方法 设计-规则-Placement-Component Clearance中取消使能即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ed692bfc1db0122340a0b62944c164b/" rel="bookmark">
			深度图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		深度图 在3D计算机图形和计算机视觉中，深度图是一种图像或图像通道，其中包含与场景对象的表面到视点的距离有关的信息，用于模拟的3D形状或重建他们。深度图可以由3D扫描仪生成或从多个图像重建 例子 如图所示，就是一个深度图，它是单通道的灰度图，反映了物体到相机平面的距离，也反映了物体可见表面的几何形状。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/372/">«</a>
	<span class="pagination__item pagination__item--current">373/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/374/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>