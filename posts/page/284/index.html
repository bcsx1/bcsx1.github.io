<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d0651f5156c7e8a8dd8e5870c8858e3/" rel="bookmark">
			tensorflow2.4.1&#43;cuda11.0&#43;cudnn8.0.4安装记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大纲 原因开始安装基本环境操作 测试 原因 由于显卡是3090，安装cuda是11.3版本的，而tensorflow官网对应表里面，最高2.6 也不支持cuda11.3。
于是上网寻找帮助，便选择了tensorflow2.4.0+cuda11.0+cudnn8.0这样的配置（参考博客见末尾）。但是，想不到中间踩了各种坑。。。
开始安装 基本环境 Ubuntu 16.04+Anaconda
操作 按部就班，首先创建一个新的conda环境：
conda create -n tf2.4 python=3.6 激活新环境：
conda activate tf2.4 接下来先安装cuda，在conda环境下，提供了cudatoolkit的二进制分发包，故优先考虑使用conda安装：
conda install cudatoolkit=11.0 接下来安装cudnn，按照博主所说
需要注意的是，conda默认源是找不到 cudnn8.0版本的，但是在conda-forge这一channel中是存在的，因此使用-c来指定：
conda install -c conda-forge cudnn=8.0 但在我实际操作的时候，会提示找不到该版本。所以在https://anaconda.org/里搜索关键词手动去找适合的包。找到了cudnn8.4安装命令：
conda install -c nvidia cudnn 接下来的事情就简单了，安装pip install tensorflow-gpu=2.4.0。注意这里可能会遇见坑，报错Illegal instruction (core dumped)
原因：*
新版本(version &gt;= 1.6.0)的Tensorflow binary release是在avx指令环境下编译的。如果你的CPU不支持该类型指令，就不能使用新版本。*
解决方法：
2.4.0的问题，可以升级2.4.1，因为官方发布是这么说的
Release 2.4.1 This release removes the AVX2 requirement from TF 2.4.0.
pip install tensorflow-gpu=2.4.0 测试 import tensorflow as tf print(tf.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d0651f5156c7e8a8dd8e5870c8858e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29a7ac1848d6a35ad4cdfb50ef91b350/" rel="bookmark">
			记录一个小问题：切换CUDA版本后，nvcc --version版本仍不变
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记录一个小问题：切换CUDA版本后，nvcc --version版本仍不变 问题描述问题分析解决方案 问题描述 由于最近使用的项目有代码较老的项目，新装了较老版本的CUDA，然后在环境变量中通过更改CUDA_PATH来切换CUDA版本。但在更改CUDA_PATH后CUDA版本仍不变（更改环境变量后重新打开了新的cmd），如下图所示我需要从版本10.0换到版本11.3：
切换前版本10.0：
切换后版本还是10.0：
问题分析 nvcc.exe存在于CUDA的bin文件夹，在安装CUDA时，CUDA的bin文件夹的路径会加入Path中。在执行命令时，会优先命中Path中靠前的地址，所以如果要切换CUDA，不单单需要将CUDA_PATH更改，还需要将Path中的bin的地址放在靠前的位置（在另一个CUDA版本的bin文件夹地址的前面）。
解决方案 将Path中CUDA的bin文件夹与libnvvp文件夹地址上移到前面。例如：
原来是10.0版本的地址靠前，所以nvcc总是会先命中10.0版本的：
将11.3版本的bin与libnvvp上移后：
然后就切换成功了，如下图：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc19fcc414fe229bec9988f697bf7dd0/" rel="bookmark">
			spark词频统计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		spark词频统计 **最开始进入spark文件目录bin下输入“./pyspark”,就进入python交互式命令行，如果出现下图，表示成功，会显示spark的图表和版本号，我的版本是3.1.2
**
第一步、在尖括号右侧写代码sc是一种抽象接口，在pyspark中我们可以直接调用，不必写sc。sc.textFile(“输入自身文件地址”)获取文件数据。 lines = sc.textFile("输入自身文件地址") 第二步、得到数据后就需要分割数据,这里是按照空格分隔 lambda是python中的匿名函数也叫做表达式
wordCount_1 = lines.flatMap(lambda line:line.split(" ")) 第三步、数据按照空格分隔后，得到的是一个个的单词，现在需要把单词转换成KV类型的，方便下一步单词计数。 wordCount_2 = wordCount_1.map(lambda x:(x,1)) 第四步、接下来，需要把数据聚合了，用到reduceByKey算子，按照key进行分组 wordCount_3 = wordCount_2.reduceByKey(lambda a,b:a+b) #分组过程是两两合并，因为他们的key是相同的，只有它们的Value相加就会得到这个单词的总次数 第五步、所有计算工作都做好之后，可以使用collect方法查看完成的词频统计 print（wordCount_3.collect()） 在此附上我的结果图，因为我的数据文件很大，单词很多，有点乱
最后再附上课本中spark词频统计流程示意图，以便加深理解
到此spark 词频统计就结束了，这是最基本spark的入门实操，上图如有侵权，联系我删除
博客更新于2022.4.8日18点15分
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a68ddaeace65e03e7720a06ea8922d75/" rel="bookmark">
			中国电信中兴 B860AV 1.1-T线刷及卡刷固件和刷机教程.zip
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		内含中国电信中兴ZXV10 B860AV 1.1-T线刷及卡刷固件和刷机教程，
注意拆机提前使用双USB公头线，短接C125脚，
也有线刷固件
直接点击下载连接中国电信中兴B860AV1.1-T线刷及卡刷固件和刷机教程.zip_中兴ZXV10B860AV1.1-T-其它文档类资源-CSDN下载
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f6d907e7e9052f033e2d1bd52a37fbd/" rel="bookmark">
			地球经纬度与方位距离互转，以及标较方法等。已知地球上A,B两点经纬度，求B点相对于A点的北向方位角以及AB两点之间的距离,以及已知本地经纬度和目标方位距离计算目标经纬度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		地球经纬度与方位距离互转，以及标较方法等。
已知地球上A,B两点经纬度，求B点相对于A点的北向方位角以及AB两点之间的距离。
定义用到的值，以及弧度与度的转换函数
计算AB两点之间距离
完整代码可在此处下载：已知2点经纬度计算相对方位及距离_matlab计算经纬度距离-互联网文档类资源-CSDN下载
使用软件可在此处下载：
已知本地和目标经纬高度，计算目标北向方位角软件_-互联网文档类资源-CSDN下载
界面如图
如果已知AB两点的经纬度高度，可以一起计算俯仰角。也可以自己用三角函数自己算俯仰角。
计算B相对于A的北向方位角
如果已知一个点A的经纬度，B相对于A的北向方位及距离，也可以计算出B点的经纬度。（已知本地经纬度和目标方位距离计算目标经纬度 ）
详细代码可直接在此处下载已知本地经纬度和目标方位距离计算目标经纬度_方位距离计算经纬度-互联网文档类资源-CSDN下载
文中所讲的北向是指的地理正北，方位角范围0-360，以正北为0度，顺时针增大。遇到标较问题，如雷达，光电标较等。需要把两者的零点一至，都都指向正北。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e221478114f388157a4e2d70f0921c98/" rel="bookmark">
			Halcon图像拼接-算法速度优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考例程mosaicking_pyramid.hdev
原理简要说明：在上一篇的基础上，我们知道了在halcon中，图像拼接的大致原理，知道了算法运行的过程，其中一个关键步骤至关重要，那就是找角点。我们知道，在halcon中我们使用的harris算法来检测角点，这里涉及到一个问题，我们是全图遍历的方式来检测角点的，那么当一个图像过大时，相应的检测时间就要增加，再加上匹配，那总时间就是指数级的增长。 对于上述现象的解决办法，在halcon中的例程中也给出了方向，在讲解之前，我们先回忆一下，模板匹配中金字塔的作用，利用金字塔这个特性，可以让我们全图遍历的效率高出很多，即先在高层金字塔处找到匹配的点，因为在高层分辨率低，所以匹配速度不会慢，找到后，逐级递减往下，虽然分辨率越来越高，但是模板大致区域也被确定，那么我们就不用全图遍历了，只去遍历上一层确定的点即可； 对于检测角点这种需要全图遍历的活，我们也可以采用金字塔的特性，而halcon中也有这样的例子，大致原理就是，先在高等级的图像对中查找角点并进行匹配，那么这个时候会得到一个投影矩阵，将这个投影矩阵应用到下一级金字塔的图像对中，来限定查找范围(DistanceTolerance)，这样就可以做到优化速度 1读取拍摄图像 跳过，详情见上篇，此处只对两张图像进行拼接
2定义图像对 跳过，详情见上篇，此处只对两张图像进行拼接
3算法流程 该例程中算法全部都在proj_match_points_ransac_guided这个函数中
1取图像的各个等级金字塔图像
ImageF，ImageT分别对应图像对的两张图像 gen_gauss_pyramid (ImageF, ImageFPyramid, 'constant', 0.5) gen_gauss_pyramid (ImageT, ImageTPyramid, 'constant', 0.5) 2在循环中寻找角点做匹配，并且逐次递减金字塔等级
for Level := NumLevels to 1 by -1 *从高到低选择图像进行角点检测 * Select images from image pyramid select_obj (ImageFPyramid, ImageFLevel, Level) select_obj (ImageTPyramid, ImageTLevel, Level) * Extract interest points in both images *检测角点 points_harris (ImageFLevel, SigmaGrad, SigmaSmooth, Alpha, Threshold, RowsF, ColsF) points_harris (ImageTLevel, SigmaGrad, SigmaSmooth, Alpha, Threshold, RowsT, ColsT) * Calculate projection from point correspondences *如果是第一次，也就是最上层的图像，那么使用默认的ransac算法来进行角点匹配 if (|HomMat2DGuide| == 0) * On the highest pyramid level, use proj_mathc_points_ransac get_image_size (ImageFLevel, Width, Height) proj_match_points_ransac (ImageFLevel, ImageTLevel, RowsF, ColsF, RowsT, ColsT, 'ncc',\ 10, 0, 0, Height, Width, [rad(-40),rad(40)], 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e221478114f388157a4e2d70f0921c98/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3166f683b8e3adf530f3b3416e0f937d/" rel="bookmark">
			linux spi字符类驱动注册流程spi_register_driver和简单实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、用spi_register_driver函数注册spi驱动。spi的驱动在\kernel\drivers\spi\spi.c
二、这里初始化driver结构的总线类型，然后是调用driver_register注册一个driver，到这里可以回到总线驱动模型的知识，driver_register是所有总线注册一个driver进总线中的统一接口，在学习总线模型的时候知道，在调用driver_register注册一个driver会去遍历总线下的device，并调用总线提供的总线提供的match函数进行匹配，对应的spi总线，它的match函数为：
三、spi_match_device会进行三项比较，任意一项匹配成功则返回1，匹配成功后调用driver的probe函数，就是__spi_register_driver里面的spi_drv_probe函数。 四、spi_drv_probe函数里面会调用spi_driver里面的probe函数。
五，dts里面添加下面的内容就可以完成spi驱动注册了。
/* Firefly SPI demo */ &amp;spi1 { spi_demo: spi-demo@00{ status = "disabled"; compatible = "firefly,rk3399-spi"; reg = &lt;0x00&gt;; spi-max-frequency = &lt;48000000&gt;; /* rk3399 driver support SPI_CPOL | SPI_CPHA | SPI_CS_HIGH */ //spi-cpha; /* SPI mode: CPHA=1 */ //spi-cpol; /* SPI mode: CPOL=1 */ //spi-cs-high; }; }; status:如果要启用 SPI，则设为 okay，如不启用，设为 disable。 spi-demo@00:由于本例子使用 CS0，故此处设为 00，如果使用 CS1，则设为 01。 compatible:这里的属性必须与驱动中的结构体：of_device_id 中的成员 compatible 保持一致。 reg:此处与 spi-demo@00 保持一致，本例设为：0x00。 spi-max-frequency：此处设置 spi 使用的最高频率。Firefly-RK3399 最高支持 48000000。 spi-cpha，spi-cpol：SPI 的工作模式在此设置，本例所用的模块 SPI 工作模式为 SPI_MODE_0 或者 SPI_MODE_3，这里我们选用 SPI_MODE_0，如果使用 SPI_MODE_3，spi_demo 中打开 spi-cpha 和 spi-cpol 即可。 六、spi设备简单示例，读写W25Q128FV。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3166f683b8e3adf530f3b3416e0f937d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/711a4ce4fc1b8c367bc6e86cebfdd16c/" rel="bookmark">
			阻塞IO与非阻塞IO的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		阻塞IO 常见的有我们的 tomcat , java多线程，阻塞IO 是指，线程如果没执行完，就不能释放资源，处理下一个请求（tomcat线程池中的线程资源，一个线程没执行完，不释放，就不能会线程池，tomca就不能分配它去执行下一个请求，即线程的指令没有被cpu取完，线程不能 去 重新 存 其他 指令）
阻塞IO又分为单线程模式阻塞，和多线程阻塞，tomcat默认是 多线程阻塞，即一个主线程去接收请求，但是不处理，去线程池开启一个新的线程去执行，这样可以提供并发量，虽然解决了主线程阻塞问题，但是 你新线程 还是存在阻塞问题的，
NIO 非阻塞IO：Netty , Redis
基于IO多路复用技术，只需要一个线程或者少量线程，就可以处理大量请求，从性能上来说NIO实现的服务器并发性一般大于BIO
不是说 单线程 就是 非阻塞 IO了，只有单线程 是 非阻塞IO设计的时候，单线程才可以处理并发问题，即 线程中的 指令 不需要指令全部被 cpu取完才能去，存新的指令
一般支持多线程的应用，都是默认采用 阻塞IO的
网络通信本来也是 IO，不要把 IO 就等于 文件读写，http本来就是 开启通道，以流的形式完成 数据的传输
参考文章：阻塞IO和非阻塞IO
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2de3fc3e7d46b115985c0ff6c11bf76/" rel="bookmark">
			内存取证-Volatility安装使用以及一些CTF比赛题目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 、简介 Volatility是一款开源内存取证框架，能够对导出的内存镜像进行分析，通过获取内核数据结构，使用插件获取内存的详细情况以及系统的运行状态。
本文涉及附件下载：
链接：https://pan.baidu.com/s/1r0t5k4gFmiu12KHbZolKnA?pwd=6666 提取码：6666 二 、安装Volatility Volatility2.6需要python2，pip安装模块也需要2版本，具体命令根据实际情况调整。
下载源码 https://github.com/volatilityfoundation/volatility 解压 unzip volatility-master.zip 安装依赖 crypto pip2 install pycryptodome #如果安装失败，可使用以下命令切换国内源 pip2 install pycryptodome -i https://pypi.tuna.tsinghua.edu.cn/simple distorm3 https://github.com/vext01/distorm3 #下载解压后使用python2 setup.py install进行编译 可选插件 Distorm3（反编译库）：pip install distorm3 Yara（恶意软件分类工具）：pip install yara PyCrypto（加密工具集）：pip install pycrypto PIL（图片处理库）：pip install pil OpenPyxl（读写excel文件）：pip install openpyxl ujson（JSON解析）：pip install ujson 安装Volatility 在解压后的Volatility目录下进行编译
python2 setup.py install 输入vol.py进行测试
三 、安装插件 安装mimikatz，将mimikatz.py复制到volatility-master/volatility/plugins/目录下，使用时需要添加参数--plugins=./volatility-master/volatility/plugins。 2.运行时可能会出现如下错误，这是因为没有安装construct 模块：
Volatility Foundation Volatility Framework 2.6 *** Failed to import volatility.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2de3fc3e7d46b115985c0ff6c11bf76/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b316b984128c79f09e8fbb78da83cf7/" rel="bookmark">
			Vue-移动端适配rem、vw、vh
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、移动端适配rem 1、安装lib-flexible npm i lib-flexible --save 2、在main.js引入lib-flexible // main.js import 'lib-flexible/flexible' 3、安装postcss和postcss-pxtorem npm install postcss postcss-pxtorem --save-dev 4、配置postcss-pxtorem 在根目录下的.postcssrc.js文件中修改为以下示例，若没有该文件则手动添加：
// .postcssrc.js module.exports = { plugins: { "autoprefixer": {}, "postcss-pxtorem": { rootValue: 37.5, propList: ['*'] } } } 5、其他设计稿尺寸 如果设计稿的尺寸不是 375，而是 750 或其他大小：
module.exports = { plugins: { "autoprefixer": {}, "postcss-pxtorem": { rootValue({ file }) { return file.indexOf('vant') !== -1 ? 37.5 : 75; }, propList: ['*'] } } } 6、postcss-pxtorem参数说明 module.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b316b984128c79f09e8fbb78da83cf7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bfa3192f3e293f302f60dc8290125f9/" rel="bookmark">
			Java Math.max() 方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Java Math.max() 方法用于返回两个参数中的最大值 语法
double max(double arg1, double arg2) 或 float max(float arg1, float arg2) 或 int max(int arg1, int arg2) 或 long max(long arg1, long arg2) 参数
参数说明：
arg1	一个 int 、 long 、 float 、 double 类型的数值 arg2	类型跟 arg1 一样的数值 返回值
返回两个参数中的最大值 范例
下面的范例使用 Math.max() 方法返回两个数值中的较大值
public class Test{ public static void main(String args[]){ System.out.println(Math.max(12.123, 18.456)); System.out.println(Math.max(23.12, 23.0)); }} 编译运行以上 Java 代码，输出结果如下
18.456 23.12 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6da68089782ff03c98533dcf5ce03df5/" rel="bookmark">
			idea修改代码没有立即生效怎么解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		idea开发项目的时候，修改代码没有立即生效，只需修改2个地方，就可以解决这个问题。
1、设置项目开启自动编译： 文件--&gt;设置--&gt;编译器--&gt;自动构建项目（勾选这个选项）。 2、设置启动项自动更新类和资源：运行--&gt;运行--&gt;编辑配置--&gt;执行更新操作时，更新类和资源（勾选这个选项）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f5f0eb757c69cc96b6db8dd505b258b/" rel="bookmark">
			CTF赛题下载、复现、解题方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CTF练习–赛题下载、复现、解题方法 看过这篇文章，你将学会github中分享的赛题本地复现 我们以靶场其中的（web_gift）进行复现
一、操作系统准备 你需要一个linux操作系统并完成docker搭建。
系统：ubuntu 安装网上教程一大堆，这里不再阐述
二、ubuntu搭建docker环境 网上搭建docker一堆坑，对新手很不友好，建议看官网的最新命令 更新ubuntu apt-get update apt-get upgrade 安装docker apt-get install docker.io 安装pip（可选） sudo apt install python3-pip 安装docker-compose sudo apt install docker-compose 或者
pip install docker-compose 验证 三、github下载靶场 解压把web文件夹复制到ubuntu中 四、赛题复现 靶场中文件是dockerfile
使用以下两个重要命令： sudo docker build -t 容器名称 . 注意：有一个点，代表当前目录，
（普通用户使用命令sudo -s 切换为root）
sudo docker run --restart always --name 容器名 -p 8801:80 -d 构建的容器名
打开靶场
打开什么都没有，查看源码发现备份文件，下载打开代码审计发现需要gift与flag相等
构造http://127.0.0.1:8801/flag.php?gift=&amp;flag
获取flag值
靶场中文件是**.yml文件
进入到该文件目录下修改**.yml文件中的对应端口再运行命令。
docker-compose up -d #启动容器
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f5f0eb757c69cc96b6db8dd505b258b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1a27ca1f2a56426a7d66f8506963170/" rel="bookmark">
			分享一个小工具：gormt, 快速导出MySQL数据库golang struct模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		工具源地址
https://github.com/xxjwxc/gormt 下载安装：
go get -u -v github.com/xxjwxc/gormt 使用方法：
找到可执行的gormt文件，一般在gopath的bin目录下
在可执行文件所在目录下，新建配置文件config.yml，编辑内容，示例：
base: is_dev: false out_dir: ./model # 输出目录 url_tag: json # web url tag(json,db(https://github.com/google/go-querystring)) language: 中 文 # 语言(English,中 文) db_tag: gorm # 数据库标签(gorm,db) simple: true # 简单输出(默认gorm标签不输出) is_out_sql: false # 是否输出 sql 原信息 is_out_func: false # 是否输出 快捷函数 is_foreign_key: false # 是否导出外键关联 is_gui: false # 是否ui模式显示 is_table_name: false # 是否直接生成表名,列名 is_null_to_point: false # 数据库默认 'DEFAULT NULL' 时设置结构为指针类型 is_web_tag: true is_web_tag_pk_hidden: false table_prefix: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b1a27ca1f2a56426a7d66f8506963170/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71d52b453195c9acd92ed8c575958b00/" rel="bookmark">
			[AcWing] 3. 完全背包问题（C&#43;&#43;实现）完全背包问题模板题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[AcWing] 3. 完全背包问题（C++实现）完全背包问题模板题 1. 题目2. 读题（需要重点注意的东西）3. 解法4. 可能有帮助的前置习题5. 所用到的数据结构与算法思想6. 总结 1. 题目 2. 读题（需要重点注意的东西） 思路：
闫式dp分析法
用闫式dp分析法分析完全背包问题
按以上思路，最朴素的做法
#include&lt;iostream&gt; using namespace std; const int N = 1010; int n,m; int v[N],w[N]; int f[N][N]; int main(){ cin &gt;&gt; n &gt;&gt; m; for(int i = 1;i &lt;= n;i++){ cin &gt;&gt; v[i] &gt;&gt; w[i]; } // ------------------核心代码--------------- for(int i = 1;i &lt;= n;i++) for(int j = 0;j &lt;= m;j++) for(int k = 0;k &lt;= j/v[i];k++) f[i][j] = max(f[i][j],f[i-1][j-k*v[i]]+k*w[i]); // ------------------核心代码--------------- cout &lt;&lt; f[n][m] &lt;&lt; endl; return 0; } 对核心代码能不能进行优化？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/71d52b453195c9acd92ed8c575958b00/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2bfaec38f373dbbcec781a2539b0666a/" rel="bookmark">
			连接查询（多表查询）——MySQL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		连接查询（多表查询） 又称多表查询，当查询的字段涉及多个表的时候，就要用到连接查询
分类：
为表起别名：
提高语句的简洁度区分多个重名字段注意：如果为表起了别名，则查询的字段就不能使用原来的别名去限定 内连接 查询A、B 交集部分数据
语法：
隐式内连接
select 字段列表 from 表1，表2 where 筛选条件 ;
显式内连接
select 字段列表 from 表1 【inner】 join 表2 on 连接条件 ... ;
例题： 查询每一个员工的姓名 , 及关联的部门的名称
表结构: emp , dept
连接条件: emp.dept_id = dept.id
隐式内连接实现 select emp.name , dept.name from emp , dept where emp.dept_id = dept.id ; 若果有员工没有部门，则不会显示
显示内连接实现 select e.name, d.name from emp as e join dept as d on e.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2bfaec38f373dbbcec781a2539b0666a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c78c0b6ea922bf98c3b178eadf4826e/" rel="bookmark">
			最新超详细VMware虚拟机下载与安装(一篇足以带你上高速，附钥)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前期准备： 背景 D盘损坏了，之前需要的软件——反正脸很黑；
公司整体架构向DevOps-Cloud云原生平台转型，Docker+K8s就必须得会了；
于是再安装一下 vmware软件，方便学习k8s以及后期开发过程中，虚拟机 Linux 的使用。
当然嫌麻烦可以购买按量付费的服务器
阿里云 aliyun.com腾讯云 cloud.tencent.com华为云 cloud.huawei.com青云 qingcloud.com百度云 baidu.com… 温馨提示用完就关，不然肠子都悔青。
版本 不解释，上最新。
下载 百度网盘
链接：https://pan.baidu.com/s/1PaMDT8IIogoyueVQWFZIOQ
vmware官网(推荐)
首页：https://www.vmware.com
下载链接：https://www.vmware.com/cn/products/workstation-pro.html
温馨提示 /cn/ 是中文版，并且建议官网下载，快~
安装 温馨提示：安装路径尽量不要有中文。可勾选 增强型键盘驱动程序 ，此功能可更好地处理国际键盘和带有额外按键的键盘
从此刻起，如果想追求速度的小伙伴，那么一套龙服务走起来，直接下一步到许可证
安装成功后点击 许可证 输入密钥激活软件。
密钥 偷偷将密钥塞进你口袋，填写到文本框里，点击 输入。
帮助 -&gt; 关于 VMware Workstation，进行许可证信息状态的查看，如下图所示即为激活成功。
温馨提示：对于vmware可能出现的网络问题，小编也给大伙们准备了：前往
大伙们有什么问题，敬请评论哦~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/937b559194b40b57ce108a4165084aed/" rel="bookmark">
			VScode设置默认格式化程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vscode有许多插件可以格式化代码，那么怎么设置默认的格式化程序？
鼠标右击---使用...格式化文档---配置默认格式化程序
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8630b08a1d3b9ececa85e3286b1c2748/" rel="bookmark">
			单元测试、集成测试、系统测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8315d5e3622c4793014acdc322970f8/" rel="bookmark">
			【FPGA】ubuntu 16.04LTS 64bit下安装 questasim 10.7C笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		FPGA ubuntu 16.04LTS 64bit下安装 questasim 10.7C笔记
文章目录 FPGA前言一、安装questasim10.7C二、你懂得步骤1.安装wine2.生成license.txt3.更改环境变量4.运行vsim 总结后记 前言 提示：这里可以添加本文要记录的大概内容：
前后折腾了两天，才把环境配置好，这里做个记录。
提示：以下是本篇文章正文内容，下面案例可供参考
一、安装questasim10.7C 网上找资源下载如下安装包，解压后chmod -R 777 安装文件夹。
在安装文件夹下打开终端，运行以下命令，进去图形化界面安装qsim。
sudo ./install.linux64 我安装的路径为/opt/questasim/ ，安装完成后路径下有以下2个文件夹。文件都chmod -R 777一下
二、你懂得步骤 1.安装wine 生成license程序是exe文件，需要使用wine运行，首先需要折腾搞定wine环境，运行以下命令，如果安装失败则需要配合网上教程，先搞定wine环境。
sudo apt-get install wine 2.生成license.txt 将安装包linux_patch路径下的MentorKG.exe复制到安装路径下
，将安装包linux_patch/linux路径下的sfk文件复制到安装路径下：
cp MentorKG.exe /opt/questasim/questasim/linux_x86_64/mgls/lib/ cp sfk /opt/questasim/questasim/linux_x86_64/mgls/lib/ 在上面目录下，运行MentorKG.exe，生成的license.txt文件以UTF-8格式保存在/opt/questasim下：
wine MentorKG.exe 再输入以下命令执行sfk，
./sfk rep -yes -pat -bin /5589E557565381ECD00000008B5508/31C0C357565381ECD00000008B5508/ -bin /5589E557565381ECD8000000E8000000005B81C3/33C0C357565381ECD8000000E8000000005B81C3/ -bin /41574989FF415641554154554889CD534489C3/33C0C389FF415641554154554889CD534489C3/ -dir . 3.更改环境变量 gedit ~/.bashrc 在.bashrc中添加以下两行，保存退出，reboot下。
export MGLS_LICENSE_FILE=/opt/questasim/license.txt export PATH=$PATH:/opt/questasim/questasim/linux_x86_64/ 4.运行vsim 打开终端，输入vsim，即可打开qsim
vsim 总结 安装成功 关键应该是执行sfk的时候后面的参数。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b8315d5e3622c4793014acdc322970f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6a61536ed79039ef443db0aa5f6267c/" rel="bookmark">
			Docker 起源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2013 年的后端技术领域，已经太久没有出现过令人兴奋的东西了。曾经被人们寄予厚望的云计算技术，已经从当初虚无缥缈的概念蜕变成了实实在在的虚拟机和账单。而相比于如日中天的 AWS 和盛极一时的 OpenStack , 以 Cloud Foundry 为代表的开源 PaaS 项目，却成了当时云计算技术中的一股清流。
当时，Cloud Foundry 项目已经基本度过了最艰难的概念普及和用户教育阶段，吸引了百度、京东、华为、IBM 等一大批国内外技术厂商，开启了以开源 PaaS 为核心构建平台层服务能力的变革。如果你有机会问问当时的云计算从业者，他们十有八九会告诉你：PaaS 的时代就要来了！
这种说法其实一点儿也没错，如果不是后来一个叫 Docker 的开源项目突然冒出来的话。
事实上，当时还名叫 dotCloud 的 Docker 公司，也是这波 PaaS 热潮中的一份子。只不过相比于 Heroku、Pivotal、Red Hat 等 PaaS 弄潮儿，dotCloud 公司实在是太微不足道了，而它的主打产品由于跟主流的 Cloud Foundry 社区脱节，长期以来无人问津。眼看就要被如火如荼的 PaaS 风潮抛弃，这时 dotCloud 公司却做出了这样一个决定：将自己的容器项目 Docker 开源。
显然，这个决定在当时根本没人在乎。
“容器” 这个概念从来就不新鲜，也不是 Docker 公司发明的。即使在当时最热门的 Pass 项目 Cloud Foundry 中,容器也只是其最底层、最没人关注的那一部分。说到这里，我就以当时的事实标准 Cloud Foundry 为例来解说 PaaS 技术。
PaaS 项目被大家接纳的一个主要原因，就在于它提供了一种名为“应用托管”的能力。当时，虚拟机和云计算已经是比较普通的技术和服务了，主流用户的普通用法就是租一批 AWS 或者 OpenStack 的虚拟机，然后像以前管理物理服务器那样，用脚本或者手动的方式在这些机器上部署应用。
当然，在部署过程中难免会遇到云端虚拟机和本地环境不一致的问题，所以当时的云计算服务比的就是谁能更好地模拟本地服务器环境，提供更好的“上云”体验。而 PaaS 开源项目的出现就是当时这个问题的最佳解决方案。
举个例子，虚拟机创建好之后，运维人员只需在这些机器上部署一个 Cloud Foundry 项目，然后开发者只要执行一条命令就能把本地应用部署到云上，这条命令就是：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c6a61536ed79039ef443db0aa5f6267c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d277ed257e5613b9c9992681d908ea5/" rel="bookmark">
			服务器上数据库被删优化办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、最近在写一个小项目，MySQL 数据库使用 Docker 安装部署在租的服务器上，然后使用 Navicat 连接数据库时，发现：
ERROR 1045 (28000): Access denied for user ‘root‘@‘x.x.x.x‘ (using password: YES/NO)
之前一直是能连上的，并且最近开发一直在使用，开发过程中编写过 sql 执行都是没问题的。
2、百度发现这个错误是因为 root 账户没有远程访问权限（参考），即跨 ip 访问权限，但是之前安装部署时是打开了这个设置的（安装过程），支持远程访问的，而且最近使用也没有什么问题。
3、但是抱着试一试的心态，还是重新执行了授权的命令
grant all privileges on *.* to 'root'@'%' identified by 'root' with grant option; #这里第一个root是用户名，第二个是密码，% 代表对所有 IP 开放权限，也可以设置单独的 IP flush privileges; 执行完之后，发现确实可以登陆了。
4、登录之后，发现 mysql 数据库中的 user 表里面多了条 root，访问权限 Host 为localhost （也可能是之前就有的），另一条 root，访问权限 Host 为 %，这样就所有的 IP 都可以访问了。
5、然后启动微服务。数据库能够连接成功了，但是有出现了找不到数据，查看数据库发现上面的表都被人删掉了，而且多了一张 README 表，打开表发现里面内容如下：
以下数据库已被删除：xxx。 我们有一个完整的备份。 要恢复它，您必须将0.006比特币（BTC）支付给我们的比特币地址xxxxxx。 有关说明，请通过xxx@xxx.com通过电子邮件联系我们。 任何与付款无关的邮件都将被忽略！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d277ed257e5613b9c9992681d908ea5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20f260b0c590c4efd0e63284728bc32e/" rel="bookmark">
			CSS3变形transform
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2D移位: transform（x,y）;
transform：translate（10px,20px）;元素移位至x轴10像素，y轴20像素的坐标位置；
transform:translate（0,10px）;元素移位至y轴10像素的坐标位置，x轴不变；
transform:translateX（10px）；元素移位至x轴10像素的坐标位置；
transform:translateY（10px）；元素移位至y轴10像素的坐标位置；
注意！！X值可以为负值，会向左边移位；
2D倾斜：transform：skew(30deg,0deg); deg表示度数
transform：skew(30deg);只设置一个值表示X轴向左30度，Y轴不发生变化；
transform：skew(30deg,0deg);X轴倾斜30度，Y轴不变；
transform：skewX(30deg);X轴向左倾斜30度 水平方向左右；
transform：skewY(30deg);Y轴向下倾斜30度 垂直方向上下；
注意！！transform：skew（）倾斜函数会改变形状，不会旋转；
2D缩放：transform：scale（sx,sy）；
可以设一个值，也可以设两个值，只有一个值的时候默认第二个值和第一个值相等；
大于1表示放大至对应倍数，小于1表示缩小至对应倍数；
transform：scale（2,2）；表示宽高放大两倍
transform：scale（.5,.5）；表示宽高缩小一倍；
transform：scale（1,1）；表示宽高不放大也不缩小；
transform：scale（1,.5）；表示宽不变，高缩小一倍；
transform：scaleX（1）；表示宽不放大也不缩小；
transform：scaleY（1）；表示高不放大也不缩小；
注意！！缩小是从中心开始缩小的
2D旋转：transform：rotate（30deg）;
正值是绕着中心点顺时针方向旋转，负值是绕着中心点逆时针方向旋转；
注意！！transform：rotate（）;旋转函数不会改变形状，只会旋转；
transform：rotate（30deg）;
transform：skew(30deg,0deg);
以上这种写法只会显示倾斜，因为用了相同的属性，上面的会被下面的覆盖；
可以用transform：rotate（30deg） skew(30deg,0deg);这种写法，空格隔开；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a73824a24e0471489c6de380596be0b9/" rel="bookmark">
			蓝桥杯 计算年份有多少个2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法1：
public class Main{
public static void main(String[] args) {
int sum=0;
for(int i=2;i&lt;=2020;i++) {
String str=String.valueOf(i);
for(int j=0;j&lt;str.length();j++) {
if(str.charAt(j)=='2'){
sum++; break;
} } }
System.out.println(sum);
}
}
方法二：
public class Main{
public static void main(String[] args) {
int sum=0;
for(int i=2;i&lt;=2020;i++) {
String str=String.valueOf(i); if(str.contains("2")) {
sum++;
}
}
System.out.println(sum);
}
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9618e57581a6b20e615953d0b4492f5/" rel="bookmark">
			vue3.2 vite2 svgIcon组件引入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue3.2 vite2 svg引入 首先先创建svgIcon组件
&lt;template&gt; &lt;div v-if="external" :style="styleExternalIcon" class="svg-external-icon svg-icon" /&gt; &lt;svg v-else :class="svgClass" aria-hidden="true"&gt; &lt;use :href="iconName" /&gt; &lt;/svg&gt; &lt;/template&gt; &lt;script setup lang="ts"&gt; import { computed } from 'vue' import { isExternal } from '@/utils/filters' const props = defineProps({ iconClass: { type: String, required: true }, className: { type: String, default: '' } }) const external = computed(() =&gt; { return isExternal(props.iconClass) }) const iconName = computed(() =&gt; { return `#icon-${props.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d9618e57581a6b20e615953d0b4492f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a51149dce817fd5fc48683d8676d1cb/" rel="bookmark">
			解决pycharm添加python2.7解释器出现Failed to create virtual environment和添加python3.8解释器SDK无效问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、pycharm添加python3.8解释器SDK无效问题
解决方案：
二、pycharm添加python2.7解释器出现Failed to create virtual environment
解决方案：
一、pycharm添加python3.8解释器SDK无效问题 解决方案： 因为电脑上同时安装python3.8和python2.7，在安装时根据网上教程，分别把两个版本的python.exe更名为python2.exe和python3.exe。所以把python3.exe改回python.exe问题就解决了！
二、pycharm添加python2.7解释器出现Failed to create virtual environment 一开始效仿上述问题的解决，修改python2.exe为python.exe但并没有解决，依旧出现Failed to create virtual environment的提示，环境都没建立，问题一虽然提示SDK无效，但还是建立了环境。
解决方案： 解决方案其实很简单，因为我的环境位置路径中有中文，联想到很多软件使用时路径不能有中文和这个错误提示，就尝试修改全英文的位置路径，结果成功添加了解释器！
但添加python3.8时也有中文路径，还是成功添加了，所以这里还是没明白两个问题具体的原因，有大佬的话，球球可以解释下。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44b2a0b745dda55c2bd095abdca801a3/" rel="bookmark">
			idea无法使用ctrl&#43;c复制类的问题解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 引言 今天在使用IntelliJ IDEA的过程中发现了无法通过Ctrl+C快捷键来复制类，但是使用右键菜单中的复制按钮是可以进行正常复制的，且Ctrl+V快捷键也是可用的。所以初步估计是一些快捷键冲突了，所以前往idea的设置中，使用快捷键反向查找，找到了占用Ctrl+C的一个插件。
顺带一提，遇到问题最初我在网上查询了相关文章后得出的结果由于Vim Emulater插件修改了快捷键导致的，通过更改vim插件的一个开关即可解决。但是我的Idea并没有安装这个Vim Emulater插件。于是我通过禁用插件排查以及idea设置中的快捷键反向查找，最后确定是由于CodotaAI这个代码提示增强插件的快捷键冲突问题导致的。
2. 问题解决 如果你也安装了CodotaAI这个插件的话，可以尝试以下解决方法：
通过Ctrl+Alt+S打开Idea设置界面，在左侧项中找到键盘映射，在右侧列表中找到插件一栏，展开Codota AI Autocomplete for Java and JavaScript 这一栏，可以看到Copy这一项占用了Ctrl+C的快捷键，点击Copy，选择禁用Copy这一项的快捷键。
禁用完成后点击应用保存设置即可。
3. 解决方法图示 我这里已经将CodotaAI这个插件的快捷键移除了，所以这里看不到看不到它占用了Ctrl+C快捷键，不过可以看到他的所属条目是蓝色的，代表我已经修改了此条目下的快捷键默认设置。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1269fee4a5969a653cc436cfc51d3fb2/" rel="bookmark">
			感知机的学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 前言一、概念二、模型1.感知机模型2.几何解释 三、感知机算法的理论分析四、感知机学习的对偶形式总结 前言 感知机是1957年，由Rosenblatt提出会，是神经网络和支持向量机的基础。
一、概念 感知机是一种二类分类。
感知机的输入是实例的特征向量，输出则是类别，取值是：取+1和-1。
感知机是一个有监督的学习算法
假设训练数据集是线性可分的，感知机学习的目标是求得一个能够将训练数据集正实例点和负实例点完全正确分开的分离超平面。如果是非线性可分的数据，则最后无法获得超平面。
二、模型 1.感知机模型 输入：实例的特征向量
权重：模型计算期间需要计算的值
偏置：偏置神经元允许分类器向左或向右移动决策边界，有助于更快、更高质量的训练模型
加权：加权求和是我们与每个特征值相关的每个权重W相乘后得到的值得总和
2.几何解释 线性方程的几何解释：
线性方程：w x +b=0
对应超平面S，w为法向量，b为截距，分离正负类别；分离超平面。
（超平面指的是n维空间中n-1维的子空间）
三、感知机算法的理论分析 L(ω,b)常被称为感知机的损失函数。如果没有误分类点，损失函数等于0，误分类点越少，损失函数值就越小。所以感知机的学习策略就是选取参数: ω 和b 使L ( ω , b ) 达到最小值。误分类点的公式也在下图公式。
可以用一个实例（统计学习方法中的题目）来便于理解
四、感知机学习的对偶形式 Gram矩阵（格拉姆矩阵）
Gram矩阵的严格定义如下所示，Gram矩阵中的每一个元素衡量了此向量之间的相关关系，内积数值越大，相关关系越大，两个向量越相似。
Gram矩阵的用法在实例中有所演示。
对偶形式的基本思想
通过实例（统计学习方法中的题目）来理解：
总结 以上就是我对感知机的学习。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52ef3d12d2a5b647dd33a8731ec9756a/" rel="bookmark">
			【c&#43;&#43;复习笔记】——右值引用(概念，使用场景），移动拷贝构造函数，赋值拷贝构造函数。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		💂 个人主页:努力学习的少年🤟 版权: 本文由【努力学习的少年】原创、在CSDN首发、需要转载请联系博主💬 如果文章对你有帮助、欢迎关注、点赞、收藏(一键三连)和订阅专栏哦 目录
一. 左值和右值的概念
🚀 1. 左值概念
🚀 2. 右值概念
🚀 3. 左值引用
🚀 4.右值引用
二. 左值引用的使用场景和缺陷
🚀 1. 左值引用的使用场景
🚀 2. 左值引用的缺陷
三. 右值引用和移动拷贝构造函数
🚀 1. 移动拷贝构造函数
🚀 2. 移动赋值
四. 右值引用与STL容器
🚀 1. 移动拷贝构造函数和赋值重载函数
🚀 2.push_back和insert
🚀 3. 完美转发
一. 左值和右值的概念 🚀 1. 左值概念 左值是一个数据的表达式(如变量名或引用的指针），我们可以获取到它的地址，正常情况下是可以能够对它赋值，定义const修饰后的左值，不能给它赋值，但是可以取出它的地址。左值可以出现在赋值符号( " = " ）的左边，也可以出现在赋值符号(" = “ )的右边。左值具有持久的状态。 🚀 2. 右值概念 右值也是一个数据表达式，右值是字面常量或者是求值过程种创建的临时对象，右值的生命周期是短暂的，如：字面常量，表达式返回值，函数返回值（不是左值引用的返回值），临时变量，匿名对象等等，右值不能出现在赋值符号的左边，右值也不能取出地址，更不能对它赋值。 🚀 3. 左值引用 左值引用是对左值的一种引用，相当于给左值取别名。普通的左值引用不能引用右值，但是const的左值引用可以引用右值。引用方法: 类型+&amp;，例如： int&amp; pa=a;pa引用a变量。 🚀 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/52ef3d12d2a5b647dd33a8731ec9756a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33a5dab19b1026f72c0c44d3dcaa90e3/" rel="bookmark">
			A-Loam框架学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 激光入门之A-Loam Aloam将Loam中很多公式优化了，直接调运库进行实现，代码简洁易读，但是效率有所降低，代码风格较好，适合新手入门。在
unbuntu20.04进行了复现，过程较为坎坷，首先是ros安装，安装的博客很多，其中台式电脑初始化容易出问题，网上都建议换手机热点，但是不一定管事，有个好途径，去淘宝找人安装，十元二十元左右，有专门干这个的，可以节省你很多时间，主要原因就是网站被墙了，vpn可能能够解决。再就是pcl库的安装，不要安装太高版本，1.9就行，1.12容易出问题。ceres库安装还好，版本最好也别太高。3.3网上说问题也有，总之20.04的解决经验不多，最好用Ubuntu16.04或者18.04。
LOAM是一个激光里程计算法，没有闭环检测，也就没有加入图优化框架，该算法把SLAM问题分为两个算法并行运行：一个odometry算法，10Hz；另一个mapping算法，1Hz，最终将两者输出的pose做整合，实现10Hz的位姿实时输出。两个算法都是使用点云中提取出尖锐的边点和平整的面点作为特征点，然后进行特征点匹配，来估计lidar的位姿以及对位姿进行fine tune。匹配特征点时，不是简单的点到点，而是edge point到edge line（点到线）以及planar point到planar patch（点到面），在后续运动估计中建立的残差距离也就是点到线的距离以及点到面的距离，所以感觉LOAM匹配的过程就像是一个点到线以及点到面相结合的ICP算法；需要注意的是odometry和mapping算法的edge line和planar patch（即匹配时的target）的确定略有不同。
复现的A-LOAM
关于其代码，节点关系图如下：
kittiHelper
kittiHelper.cpp 的作用是将kitti数据集转为rosbag
代码的详细解释
讲的很细，了解数据集构成，以及转化过程。
https://blog.csdn.net/qq_32761549/article/details/120322726
scanRegistration.cpp
前端lidar点预处理及特征提取 https://www.guyuehome.com/35528
LOAM提出了一种简单而高效的特征点提取方式：根据点云点的曲率提取特征点。即把特别尖锐的边线点与特别平坦的平面点作为特征点。
公式看起来比较复杂，实际上就是同一条扫描线上的取目标点左右两侧各5个点，分别与目标点的坐标作差，得到的结果就是目标点的曲率。当目标点处在棱或角的位置时，自然与周围点的差值较大，得到的曲率较大；反之当目标点在平面上时，周围点与目标点的坐标相近，得到的曲率自然较小。 laserOdometry https://zhuanlan.zhihu.com/p/396331443
laserOdometry的订阅了5个话题：有序点云、极大平面点、次极小平面点、极小平面点、次极小平面点。发布了4个话题：有序点云、上一帧的平面点、上一帧的边线点、当前帧位姿粗估计。 while (ros::ok()) { // 帧间位姿估计过程 ... rate.sleep(); } 帧间匹配与位姿估计
目标：希望找到位姿变换T，使得第k帧点云左乘T得到第k+1帧点云，或者与第k+1帧点云的误差最小。边线点匹配方法 方法：现在在第k+1帧中发现了点边线点i，查询在第k帧中的最近邻点j（by KD-tree），查询j的附近扫描线上的最近邻点l，j与l相连形成一条直线l-j，让点i与这条直线的距离最短。
非线性优化：以点i与直线lj的距离为代价函数，以位姿变换T(四元数+t)为优化变量，构建非线性优化问题。
平面点匹配方法
方法：现在在第k+1帧中发现了平面点i，查询在第k帧（上一帧）中的最近邻点（by KD-tree）j，查询j的附近扫描线上的最近邻点l和同一条扫描线的最近邻点m，这三点确定一个平面，让点i与这个平面的距离最短
非线性优化：以点i与平面lmj的距离为代价函数，以位姿变换T(四元数+t)为优化变量，构建非线性优化问题。
由于LOAM原版应用的设备是机械式激光雷达，因此势必存在一定的运动畸变（即同一个点云中，各个点在采集时，LiDAR的位姿是不同的，就如同高速移动相机时拍摄的照片一样），为此LOAM提出假设：激光雷达的运动都是匀速的，由此对点云中的点进行去畸变。
laserMapping
https://zhuanlan.zhihu.com/p/396661160
这里涉及到几个坐标系的相互转换，需要理清关系：雷达坐标系（每帧扫描到的点云点的坐标point_curr都在雷达坐标系中），里程计坐标系（由laseOdometry节点粗估计得到的LiDAR位姿wodom_curr对应的坐标系），地图坐标系（真实的世界坐标系）laserOdometry中只能做到粗估计，而laserMapping能够做到精估计 laserMapping中使用scan to map的匹配方法，即最新的关键帧scan（绿色线）与其他所有帧组成的全部地图（黑色线）进行匹配，因此laserMapping中的位姿估计方法联系了所有帧的信息，而不是像laserOdometry中仅仅只利用了两个关键帧的信息，所以位姿估计更准确。
显然如果完全使用所有区域的点云这样做的效率很低，因此只截取scan附近的全部地图中的一个10m³的cube，用这两个cube的匹配的结果代替全局匹配结果。
显然，在submap的cube与全部地图的cube进行匹配时，在laserOdomerty中帧与帧之间的匹配方法就不太适用了（实际上cube中已经没有了帧的概念）。cube的匹配方法如下： 取当前帧的特征点（边线点/平面点）找到全部地图特征点中，当前特征点的5个最近邻点如果是边线点，则以这五个点的均值点为中心，以5个点的主方向向量（类似于PCA方法）为方向，作直线，令该边线点与直线距离最短，构建给非线性优化问题如果是平面点，则寻找五个点的法方向（反向的PCA），令这个平面点在法方向上与五个近邻点的距离最小，构建给非线性优化问题求解能够让非线性问题代价函数最小的LiDAR位姿 完成精位姿估计之后，还有几点工作要做：将当前帧的特征点加入到全部地图cube中，对全部地图cube中的点进行降采样，刷新附近点云地图，刷新全部点云地图，发布当前帧的精确位姿估计和平移估计。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad7be306825e7db0dc867a2806f5174d/" rel="bookmark">
			将博客搬至CSDN
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		将博客搬家至CSDN
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/833390c65f040fbb024c38155ac5b540/" rel="bookmark">
			Adaboost学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、boosting与bagging二、Adaboost1.原理介绍2.实例展示 总结 前言 这是我自己对于Adaboost算法的学习以及总结。
参考的博客：
https://blog.csdn.net/v_july_v/article/details/40718799
以下是本篇文章正文内容
一、boosting与bagging boosting就是随着学习的积累从弱到强。简而言之，每新加入一个弱学习器，整体能力就会得到提升。
代表算法：Adaboost、GBDT、XGBoost
Bagging与Boosting的差异在于：取样方式不同。Bagging采用均匀取样(比如在箱子中有100个球，80个黑球，20个白球，抽到黑球后再放回的抽)，而Boosting根据错误率来取样，因此Boosting的分类精度要优于Bagging。
Bagging的训练集的选择是随机的，各轮训练集之间相互独立，而BoostIng的各轮训练集的选择与前面各轮的学习结果有关；
bagging和boosting都可以有效地提高分类的准确性。在大多数数据集中，boosting的准确性比bagging高。在有些数据集中，boosting会引起退化。(随机森林的使用采取的是bagging)
Bagging是指采用Bootstrap（有放回的均匀抽样）的方式从训练数据中抽取部分数据训练多个分类器，每个分类器的权重是一致的，然后通过投票的方式取票数最高的分类结果最为最终结果
对于bagging的理解，可以用一个例子来说明
二、Adaboost 1.原理介绍 Adaboost原理：训练一组数据，调整数据分布，将之前错误的数据区域‘放大’，将正确的数据区域‘缩小’，然后接着训练第二个学习器，再次调整数据分布。每轮数据调整，将注意力集中在错误数据中。整个训练过程如此迭代下去。
Adaboost的关键点是确认投票权重。
Adaboost的算法流程（加法模型）：
1.初始化训练数据的权值分布。每一个训练样本最开始时都被赋予相同的权值：1/N
2.进行多轮迭代，用m = 1,2, …, M表示迭代的第多少轮
3.步骤3. 组合各个弱分类器
相关公式
具体细化的说：
1.初始化训练数据权重相等，训练第一个学习器
2.计算该学习器在训练中的错误率
3.计算学习器的权重
4.根据权重对数据在重新赋权
5.重复执行1-4次
6.对M个学习器进行加权投票
2.实例展示 这是我之前看到的一个例子，后来我具体的进行了尝试
这个问题在之前参考的博客中有体现，结合案例，在对过程进行分析，即可了解这一过程
当m=1，在权值分布为D1（10个数据，每个数据的权值为0.1），通过计算：
（v为阈值）
v取2.5时，误差率为0.3（x &lt; 2.5时取1，x &gt; 2.5时取-1，则6 7 8分错，误差率为0.3），
v取5.5时误差率最低为0.4（x &lt; 5.5时取1，x &gt; 5.5时取-1，则3 4 5 6 7 8皆分错，误差率0.6大于0.5，不可取。故令x &gt; 5.5时取1，x &lt; 5.5时取-1，则0 1 2 9分错，误差率为0.4），
v取8.5时误差率为0.3（x &lt; 8.5时取1，x &gt; 8.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/833390c65f040fbb024c38155ac5b540/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e27b264b006dc55c9e619414b9e1803f/" rel="bookmark">
			如何实现一个强大的MMO技能系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 如何实现一个强大的MMO技能系统——序章前言 如何实现一个强大的MMO技能系统——AOI前言正文总结 如何实现一个强大的MMO技能系统——技能前言正文总结示例 如何实现一个强大的MMO技能系统——BUFF前言正文第一节：Buff定义第二节：Buff执行流程第三节：Buff修改状态（ModifyState)第四节：Buff修改属性(ModifyAttribute)第五节：Buff修改运动(ModifyMotion)第六节：Buff监听事件 总结示例 如何实现一个强大的MMO技能系统——子弹前言正文总结示例 如何实现一个强大的MMO技能系统——特效前言正文总结 如何实现一个强大的MMO技能系统——序章 作者：kasan
链接：https://zhuanlan.zhihu.com/p/147681650
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
前言 技能系统可以说是游戏中广泛存在而又最重要的系统了，它是整个游戏战斗体验的核心。一套强大的技能系统可以让游戏的策略性，可玩性得到极大的提升。然而技能系统牵涉到的模块非常多，又会面对策划各种各样的奇葩需求，同时技能模块中很多系统的设计不仅仅对程序员的编码能力提出了一定的要求，而且还需要程序员对游戏机制有着深入的理解。可以说要实现一套强力的高可用高扩展的技能系统还是有一定复杂度的。
如果作为一个游戏玩家，谈论到技能系统，我们一定会对War3的技能编辑器印象深刻，通过设计一个高扩展的技能系统编辑器，它打造了无数的经典游戏。各种对战地图，RPG守图，TD塔防，趣味闯关，甚至产生了其中最经典的风靡全球的Dota，为我们展示了War3技能系统的强大。后来Valve甚至因此专门开发了Dota2，而且它提供了更强大的地图编辑器，基于该编辑器开发的自走棋更是开创了一个新的游戏品类。这就是技能系统所展现的魅力。
如果论网络游戏领域技能系统之集大成者，相信魔兽世界，守望先锋，Dota2都可占得一席之地。深入玩过这几款游戏的话，都会被他们技能系统之精巧所震撼。但是前两款游戏的技术分享实在太少，所流传在外的资料并不足以让人去深入研究他们的技能系统的架构是怎样的。而Dota2因为地图编辑器的存在，有大量的资料可以去获取[1][2]。你甚至可以直接写一个技能脚本去运行一下，验证自己的猜测是否正确。本人的技能系统实现，可以说极大的受益于此，正因为有着可以大量阅读的文档和技能示例，才让我对技能系统的认识有了质的飞跃，在此深表感谢。
互联网上关于游戏开发相关的技术文章浩若烟海，佳作繁多，本人也因此所获良多，受益匪浅。然而对于技能系统设计这块尚有遗珠之憾，本系列的文章将围绕如何打造一个强大的MMO技能系统这个主题展开，对技能系统涉及到的各个模块一一详细讲解，从而让读者对技能系统有深入的了解和认识。
本系列将技能系统分为如下模块依次讲解：
AOI系统
技能（Ability)
Buff
子弹（Projectile）
特效
运动
动画
如何实现一个强大的MMO技能系统——AOI 前言 AOI（area of interest），它是MMO游戏中一个极其重要的概念，主要解决游戏中多人同屏的问题。本文并不打算去讲AOI相关的算法，如九宫格，十字链表，六边形网格之类的具体算法实现，因为此类文章网络上已经有很多了。虽然大多数开发者都接触过AOI，但是我发现其中很多人并没有真正深入领会AOI的本质。因此本文会从设计的角度来阐释什么是AOI，为什么要有AOI，以及如何去设计一个高质量的AOI系统。
正文 很多开发者在设计AOI系统的时候通常是这样设计的（以最常见的九宫格为例），比如把场景按照一定的Size划分出很多格子，然后由AOI系统根据玩家位置来更新玩家的所在的网格索引，每个玩家获取周围9个格子的玩家信息来进行显示。
这样就在细节上出现了很多如下问题：
玩家位置变化的时候如何处理，立即更新或者等到下一帧update的时候更新？
玩家位置变化或者周边其他玩家变化导致所在网格索引变化后，带来的对象的增加、删除如何处理？
由于显示列表的容量限制，玩家A的显示列表里面添加了玩家B，但此时玩家B的显示列表满了，该怎么处理呢？
这样的问题林林总总，很多开发者都花了不少心思去处理这样的问题。但是请让我们更深入的考虑一下，为什么会出现这样的问题呢？这样的设计就够了吗？
又比如说某天策划脑洞大开，说我们来做个暗杀玩法吧。并绘声绘色地给你描绘了如下让人心潮澎湃的情境：
“你从酒馆老板处接到暗杀任务后，展开羊皮纸一看，上面只记录了目标所在的场景，并没有具体位置信息，你需要传送到目标场景之后，自己去发现目标的踪迹。于是你使用传送卷轴到达了目标所在的场景，然后站在高山之上，开启了鹰眼术，目光如电刺穿远方层层的迷雾，随着你细致地搜寻，突然间发现远方的天际一个黑点缓缓浮现，你知道他就是此次的任务目标了，随即你立刻翻身上马，向目标疾驰而去……”
那这个时候作为程序，你该如何实现这个需求呢？
很明显，此时目标离你的距离远超你九宫格的距离，你依然要将他显示出来。那这个时候该怎么办呢？
所以，我们顺其自然地有了一个新的概念——“关注者“，AOI搜寻到的列表并不能就完全等同于关注者列表。而客户端显示的就是关注者列表里面的内容。AOI搜寻到的列表只是用来获得关注者的手段。
为了让读者有个更直观的理解，我举个例子。大家都很熟悉微博，假如我们把游戏当作微博来看的话。
登录场景：当我们注册账号进入微博（游戏场景）的时候，大家都没有关注者。这个时候我的微博首页的时间线上没有任何其他人的动态（游戏中此时只看得到自己）。
获得其他玩家信息：这个时候为了让大家互相交互，微博提供了附近的人的选项（假设微信上的这个功能移动到了微博）。这个时候你点击附近的人（游戏中向AOI系统拉取周边九宫格的玩家列表），然后获得了一系列的用户信息列表。此时你一一关注，瞬间你的时间线动态就丰富了起来（关注者列表新增周边的玩家并显示在本地客户端）。
消息同步：假设你的用户名是A，并且你关注了B，C。那么此时你的关注者列表里面是BC。而BC此时并不会说就关注你了，而是收到系统通知，获得了新的粉丝A。那么我们现在看A的时间线，会不停的收到B和C的动态，如果是在游戏场景下，那么B和C最常发送的动态就是玩家B或C移动到了某位置P1（Obj:MultiCastPktPosChanged)，玩家B或C使用了技能（Obj:MultiCastPktCastAbility)等等（此处仅为让读者能够直观理解概念，实际上的同步优化处理有很多方法和技巧，在此并不展开）。
关注机制：虽然上例中A能收到B和C的各种动态，但是A发出来的动态只有自己看的到，B和C是看不到的，也就是说AOI并不需要双向连接。这并不仅仅只是为了解决前面提到的第3个问题（细细思考一下）。同时这也是符合现实感受的。比如说每天上班的时候地铁里面有很多人，你会关注谁呢，你关注的目标会关注你吗？但此时如果周围有人拍了一下你的肩膀，喊了你的名字，那么你就会立即关注他是谁，对吧。（以游戏场景为例的话，假如周边有很多玩家的话，你不一定需要严格按照位置远近来排序，而是需要把跟你关联度最高的玩家加到你的关注者列表中。比如不远处的某个玩家向你发起了切磋请求，那么此时的解决方案就应该是把他加入到你的关注者列表，而不会说根据距离远近再来把这个玩家增添移除掉）。
此时，回到最开始的问题，那么前面的问题的答案就显而易见了。
AOI的信息需要立即更新吗？不一定需要，我们未必需要时时刻刻关注离我最近的目标，附近的人这个功能里面的用户列表更新频率慢一点也没关系。
因为我们并不需要时时刻刻关心附近的人，所以自然也不会有某个玩家在边界进进出出导致的AOI不停的创建和删除的开销问题。（如果还需要优化就加上lazy time处理下吧）
这个问题已经显而易见了，没必要一定得互粉，看缘分啦。我附近如果没其他人，又太寂寞的话说不定也会关注你，关注列表满了就算了。
最后，策划的需求解决起来也很简单了。搜寻目标的过程就是使用技能给自己加了个Buff，Buff创建的时候将目标加到关注者列表中，目标死了后buff销毁，并将目标移除出关注者列表。 这在微博系统中相当于你直接搜索该玩家的账号，直接加关注，任务达成后再直接取关就行了。并不需要与”附近的人“这个功能发生任何关系。
总结 因此，当我们设计AOI系统的时候，并不需要严格只显示九宫格范围内的对象，九宫格只是一个手段，一个让我们获得关注者的手段，它只是个过程，并不是结果。大家在设计的时候多考虑这一点，使用起来就方便很多了。甚至我们可以让技能改变关注者列表，从而达成一些特殊效果。
如何实现一个强大的MMO技能系统——技能 前言 一个完整的技能系统逻辑层主要包括三个模块：技能模块，buff模块，projectile（子弹）模块。然而在很多项目中，这三个模块可能并不是同一个人负责的，所以会发现这些模块间的联系并不够紧密，然而技能的需求是非常复杂的，这样就有可能随着技能需求的越来越复杂，每个模块都搞了一套自己的脚本化的逻辑，最后维护难度急剧增加，导致开发成本大大提高。本章将主要讲述一个高扩展性的技能模块该如何设计，使得技能支持尽可能多的效果，同时又能够保持架构的精简和高扩展性。
正文 首先，我们大致思考一下平常玩的游戏，大致会发现有如下几种技能类型：
被动类型的技能(PassiveAblity)
主动施法技能（最常见的通用主动施法类技能，如普通攻击等一次性触发效果类技能（GeneralAbility），引导类持续施法技能(ChannelAbility)，如大法师暴风雪）
开关类技能（(ToggleAbility)点击技能开启/关闭效果，类似于恶魔猎手献祭）
激活类技能（(ActivateAbility)点下右键激活/停止，一般是给普通攻击附加特殊效果）
在这里我们采用标记位（可进行或操作）的形式来表明这些技能的类型。这意味着一个技能可能被检测既是被动又是引导类技能（我们将在最后的示例部分讲述为什么需要这样设计）。
下面我们一步步讲解这些技能类型该如何设计。在我们的技能系统中，所有的技能里面不包含任何具体技能效果及逻辑，每个技能根据其类型提供若干抽象接口，具体执行效果由策划去配置。
当**一个技能标记为被动技能时，则它是被动技能，被动技能一般会在技能初始化时生效，技能初始化时会有抽象行为接口Ability::OnAbilityInit()。**那么被动技能就可以在这个接口中执行一些行为，具体执行那些功能由策划配置，一般情况下策划会配置给角色添加Buff来监听各种事件以触发各种效果。那么技能的各种效果该如何实现呢？我们将在下一章buff系统中讲到。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e27b264b006dc55c9e619414b9e1803f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9dd5afd9e0a6d9bc89e1b2382385086/" rel="bookmark">
			五点差分法求解偏微分方程（PDE）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先以一个例题带大家了解五点差分法求解PDE
偏微分方程的解析解通常是非常难求的，即使是多数常微分方程，通常也难以计算解析解，即使可以计算，那也是相当复杂，因此，微分方程数值解的求解，是我们的一个重要的研究方向
求解微分方程数值解的核心，就是用差商来代替微商， 可以取一个比较小的值
二阶向前差商
二阶向后差商
二阶中心差商
差商有多种形式，我们选择中心差商
同理，y对x的二阶中心差商
由题目条件
可以确定边界取值，这是Dirchilet边界条件
下图是Dirchilet边界条件的直观解释，绿色点代表已知点。
由题目条件
可以确定 附近点的取值，这是Neumann边界条件
用差分可以近似表示成
下图是Neumann边界条件的直观解释，灰色点代表其他已知点，绿色点代表Neumann边界条件确定的点。
由题目条件
可以得出的近似关系
利用网格可视化
我们发现， 可以由左边的4个点近似计算,这就是五点差分法求解偏微分方程的思路,我们把视角放大到整体.
Step1：先看绿色的点1，根据1左侧个点的取值，由(*),可以推出点1的取值
Step2：再看绿色的点2，根据2左侧个点的取值，由(*),可以推出点2的取值，以此类推，可以得出每一列上下两点之外每个点的取值，第三列点的取值，用前两列的点就可以确定 由边界条件 ，我们可以发现，x=0和x=1的取值是确定的，
Step3: 重复这个过程，在 空间内的所有离散的近似解已经确定了
下面是本题的Matlab代码
注意，要单独编写一个M文件定义函数
flucfun.m
%y_tt=y_xx,0&lt;x&lt;1,t&gt;0 %y(x,0)=sin(pi*x),y_t(x,0)=x(1-x),0&lt;=x&lt;=1 %y(0,t)=y(1,t)=0,t&gt;0 %上面是某个波动方程 %这里定义了x范围在0~1，所以x的取值范围是确定的，我们需要t的取值范围 %这里利用五点差分法求解二阶偏微分方程，所以我们需要选择每个自变量的差分步长，分别用dx，dt表示 %yy是波动方程在给定的某个区域内各点的取值，trange是t的取值范围，dx，dt分别代表x，t分量差分的精度 function yy=flucfun(trange,dx,dt) xrange=1;%为了形式规范，还是写了xrange，xrange可有可无 numX=ceil(xrange/dx);%ceil是向上取整函数，由于matlab以矩阵的形式存储解集，矩阵的大小表示了在这个解集内的离散点数量 numT=ceil(trange/dt); yy=zeros(numX,numT); yy(1,:)=0;yy(numX,:)=0; %Dirchilet边界条件 for xx=1:numX yy(xx,1)=sin(pi*xx*xrange/numX);%Dirchilet边界条件 yy(xx,2)=yy(xx,1)+dt*(xx*xrange/numX)*(1-xx*xrange/numX);%Neumann边界条件 end for tt=2:numT-1 for xx=2:numX-1 %中间差分 yy(xx,tt+1)=((dt/dx)^2)*(yy(xx+1,tt)-2*yy(xx,tt)+yy(xx-1,tt))+2*yy(xx,tt)-yy(xx,tt-1); end end end Matlab主程序
xrange=1; trange=10;%我们想要0&lt;t&lt;10的求解函数图像 yy=flucfun(trange,0.03,0.03); [m,n]=size(yy);%m是x分量的向量长度，n是t分量的长度 %刚才我们求解的yy是一个矩阵，大小为m*n，解空间为[1,m]*[1,n]，我们需要把解空间映射到[0,1]*[0,10] xx=linspace(0,1,m);%xx的长度为m，取值范围从0到1，tt同理 tt=linspace(0,trange,n); [X,T]=meshgrid(tt,xx);%对tt和xx网格化 figure(1) surf(X,T,yy)%绘制三维网格图 xlabel('t') ylabel('x') zlabel('y') 这是Matlab的求解结果
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c9dd5afd9e0a6d9bc89e1b2382385086/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33f4861bbabe55044bbd97bf53f0bdbd/" rel="bookmark">
			Android OpenGL ES - 纹理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		纹理基本概念 纹理是一个2D图片（甚至也有1D和3D的纹理）
纹理坐标 为了能够把纹理映射(Map)到三角形上，我们需要指定三角形的每个顶点各自对应纹理的哪个部分.
这样每个顶点就会关联着一个纹理坐标(Texture Coordinate)，用来标明该从纹理图像的哪个部分采样（译注：采集片段颜色）。之后在图形的其它片段上进行片段插值(Fragment Interpolation)。
纹理坐标在x和y轴上，范围为0到1之间（注意我们使用的是2D纹理图像）。使用纹理坐标获取纹理颜色叫做采样(Sampling)。
纹理坐标起始于(0, 0)，也就是纹理图片的左下角，终始于(1, 1)，即纹理图片的右上角。
下面的图片展示了我们是如何把纹理坐标映射到三角形上的。
我们为三角形指定了3个纹理坐标点。如上图所示，我们希望三角形的左下角对应纹理的左下角，因此我们把三角形左下角顶点的纹理坐标设置为(0, 0)；三角形的上顶点对应于图片的上中位置所以我们把它的纹理坐标设置为(0.5, 1.0)；同理右下方的顶点设置为(1, 0)。
我们只要给顶点着色器传递这三个纹理坐标就行了，接下来它们会被传片段着色器中，它会为每个片段进行纹理坐标的插值。
纹理坐标看起来就像这样：
//纹理坐标
const GLfloat m_texture_coors[6] = { 0.0f, 0.0f, // 左下角 1.0f, 0.0f, // 右下角 0.5f, 1.0f//上 }; 2D纹理的坐标系是从左下角为原点向上为t轴,向右为s轴的坐标系。这个坐标系的y方向和GL坐标系相反，所以默认按顶点坐标系方向输入的图像是倒置的。
如果想要让纹理正向显示，我们需要做的一步工作便是将输入的纹理坐标或者顶点坐标进行y轴方向的倒置。
这些我们会在下面的示例中看到
加载图片 我们上面了解了纹理的坐标系之后，那么要做的第一件事自然是把它们加载到我们的应用中。
纹理图像可能被储存为各种各样的格式，每种都有自己的数据结构和排列，所以我们如何才能把这些图像加载到应用中呢？
我们这里采用Android上的API，
BitmapFactory.decodeResource(getResources(), R.mipmap.wall) 然后把得到的Bitmap对象传入Native进行处理
AndroidBitmapInfo info; // create a AndroidBitmapInfo int result; // 获取图片信息 result = AndroidBitmap_getInfo(env, bitmap, &amp;info); // 获取像素信息 unsigned char *data; result = AndroidBitmap_lockPixels(env, bitmap, reinterpret_cast&lt;void **&gt;(&amp;data)); size_t count = info.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/33f4861bbabe55044bbd97bf53f0bdbd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b58aedb72f661608daf4d231034b09fc/" rel="bookmark">
			线程安全的观察者模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 创建观察者 /** * @Author jet * @Description 观察者模式 * @Date 2022/4/6 * @Param * @return **/ public interface Observer { /** * @Author jet * @Description 更新 * @Date 2022/4/6 * @Param [o, arg] * @return void **/ void update(Subject subject, Object arg); } 2.主题 package com.jetluo.patterns.chapter02.theadsafe; /** * @Author jet * @Description //主题接口 * @Date 2022/3/31 * @Param * @return **/ public interface Subject { /** * @Author jet * @Description //订阅 * @Date 2022/4/6 * @Param [o] * @return void **/ public void addObserver(Observer observer); /** * @Author jet * @Description //删除订阅 * @Date 2022/3/31 * @Param [o] * @return void **/ public void removeObserver(Observer observer); /** * @Author jet * @Description //发布通知 * @Date 2022/4/6 * @Param [] * @return void **/ public void notifyObservers(); /** * @Author jet * @Description //发布通知 * @Date 2022/4/6 * @Param [] * @return void **/ public void notifyObservers(Object o); } 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b58aedb72f661608daf4d231034b09fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b677a18b738edbbb35d272a60a72734c/" rel="bookmark">
			遥感数字图像处理（实验一）——预处理、图像的真彩色和拉伸显示（包括图像的直方图显示、线性拉伸、与直方图匹配）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
实验目的：
实验内容一：
实验步骤：
一、影像的获取
二、影像的合成
三、对合成的影像进行不规则分幅裁剪
四、对裁剪的影像进行拉伸
五、直方图匹配
六、实验总结及扩展
实验目的： 理解遥感数字图像处理的过程和基本操作，能够通过实际专题应用，掌握所学理论、方法和技术，从而加深对专业软件的应用能力，培养动手操作的能力。
通过实践，掌握遥感数字图像处理的算法及应用，完成遥感图像的获取、预处理等图像处理实验内容。理解遥感数字图像的处理流程和主要处理方法，培养针对遥感数字图像处理相关问题的设计和分析评价能力。
实验内容一： 完成遥感图像的获取、预处理和显示。加载遥感数字图像，并对加载多源遥感图像进行图像的裁剪等预处理。并完成图像的真彩色和拉伸显示，包括图像的直方图显示、线性拉伸、与直方图匹配。
实验步骤： 一、影像的获取 登录地理空间数据云官方网站，选择数据集为Landsat8 OLI-TIRS卫星数字产品，空间位置为行政区--陕西省--西安市--碑林区，时间范围无要求，云量小于3%的影像，图1。
图1 影像获取
二、影像的合成 1.在Envi classic中添加Landsat8数据中的B1、B2、B3、B4、B5、B6、B7、B9、B10、B11（不添加B8全色波段数据），数据如图1。
补充：Landsat8卫星包含OLI（Operational Land Imager 陆地成像仪）和TIRS（Thermal Infrared Sensor 热红外传感器）两种传感器。OLI包括了ETM+的所有波段，为了避免大气吸收部分特征，OLI对波段进行了重新调整，比较大的调整：
(1)OLI Band5(0.845-0.885μm)，排除了0.825μm处水汽吸收特征；
(2)OLI全色波段Band8波段范围较窄，这种方式可以在全色图像上更好区分植被和无植被特征；
(3)新增两个波段：海蓝波段(band 1;0.433-0.453μm)主要应用海岸带观测；短波红外波段，又称卷云波段(band 9;1.360-1.390μm)包含水汽强吸收特征，可用于云检测；
(4)近红外band5和短波红外band 9与MODIS对应的波段更加接近。
图2 数据
2.在Envi classic中选择基本工具--图层堆栈（layer stacking），添加波段数据并且按波段由小至大的顺序进行排序，图3。
图3 layer stacking
3.查看MTL文件中的地理坐标系
图4 MTL文件部分参数
4.图层堆栈(Laying stacking）后进行RGB真彩色影像的显示，波段选择依次为B4、B3、B2，图5
图5 显示过程
补充： RGB 波段 主要用途
4、3、2 Red、Green、Blue 自然真彩色
7、6、4 SWIR2、SWIR1、Red 城市
5、4、3 NIR、Red、Green 标准假彩色图像，植被
6、5、2 SWIR1、NIR、Blue 农业
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b677a18b738edbbb35d272a60a72734c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0499223051558304cc22b7b141f0f641/" rel="bookmark">
			python2.X升级到python3.X
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 Linux自带的python版本是2.7.5，不能满足现阶段的开发需求，所以打算升级到python3.6.6
步骤 1、查看当前python版本
[root@kuick-k8s-Alpha-node2-63 ~]# python --version Python 2.7.5 2、下载python3.6.6的安装包
[root@kuick-k8s-Alpha-node2-63 opt]# wget https://www.python.org/ftp/python/3.6.6/Python-3.6.6.tgz 3、解压
tar -xvf Python-3.6.6.tgz 4、源码编译安装
cd ./Python-3.6.6/ ./configure --prefix=/opt/python3.6 ///opt/python3.6这个是打算安装python的目录 make make install 5、建立新版本python链接
mv /usr/bin/python /usr/bin/python2.7.5 //修改旧链接 ln -s /opt/python3.6/bin/python3 /usr/bin/python //创建新链接 6、修改环境变量
vim ~/.bash_profile
export PYTHONHOME=/opt/python-3.7 export PATH=$PYTHONHOME/bin:$PATH 7、安装成功，再次查看版本信息可以看到如下图
8、修改yum
yum的脚本是基于python2.x的，因此，这里将系统变量进行了python3的修改，那么就应该对yum的脚本做python2.x的指定
分别打开以下两个文件
vim /usr/bin/yum vim /usr/libexec/urlgrabber-ext-down 将头文件中的第一行修改为如下格式
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03442f482ddd8de07d444eefef9a27e9/" rel="bookmark">
			机器学习基础知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 概述一、机器学习分类1.1 主要任务1.2 分类方式1.3 监督学习1.3.1 判别式模型1.3.2 生成式模型 1.4 无监督学习1.4.1 聚类1.4.2 降维 1.5 深度学习1.6 强化学习 二、机器学习步骤三、模型评估指标3.1 分类问题3.2 回归问题 四、机器学习预备知识4.1 数学基础4.2 Python第三方库 概述 机器学习(Machine Learning, ML) 是使用计算机来彰显数据背后的真实含义，目的是把数据转换成有用的信息。机器学习是一门多领域交叉学科，专门研究计算机怎样模拟或实现人类的学习行为，以获取新的知识或技能，重新组织已有的知识结构使之不断改善自身的性能。 它是人工智能的核心，是使计算机具有智能的根本途径，其应用遍及人工智能的各个领域，它主要使用归纳、综合而不是演绎。
一、机器学习分类 1.1 主要任务 分类：将实例数据划分到合适的类别中。 应用实例：猫狗分类（二分类），手写数字的识别（多分类）回归：主要用于预测数值型数据。 应用实例：股票价格波动的预测，房屋价格的预测等。 1.2 分类方式 机器学习方法种类繁多，最常用的分类方式是根据是否在人类监督下学习分为：监督学习、非监督学习、深度学习和强化学习
1.3 监督学习 机器学习模型对历史数据进行训练，进而将训练好的模型用于分类或回归，监督学习训练的数据自身带着“标签（label）”，即：每一组特征变量对应的目标变量是确定的。
例如：手写数字的识别项目中，我们已知每一张手写图片对应的数字；股票价格波动的预测项目中，我们已知历史每一时刻对应的股票价格。
1.3.1 判别式模型 假设我们有训练数据 ( X , Y ) (X,Y) (X,Y)， X X X是特征集合， Y Y Y是类别标记。这时来了一个新的样本 x x x，我们想要预测它的类别 y y y。监督学习又根据件概率 P ( x ∣ y ) P(x|y) P(x∣y)作作为新样本的分类。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/03442f482ddd8de07d444eefef9a27e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d3a5128d8c776207470510ab3bdaabe/" rel="bookmark">
			linux常用压缩解压命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 tar格式gz格式tar.gz格式和tgz格式bz格式、bz2格式tar.z格式、tar.bz2格式zip格式rar格式tar.xz格式z格式 tar格式 解包：tar -vxf filename.tar 打包：tar -vcf filename.tar dirname gz格式 解压方式一：gunzip filename.gz 解压方式二：gzip -d filename.gz 压缩：gzip filename tar.gz格式和tgz格式 解压：tar -vxzf filename.tar.gz 压缩：tar -vczf filename.tar.gz dirname bz格式、bz2格式 解压方式一：bzip2 -d filename.bz、bzip2 -d filename.bz2 解压方式二：bunzip2 filename.bz、bunzip2 filename.bz2 压缩：bzip2 -z filename tar.z格式、tar.bz2格式 解压：tar -vxjf filename.tar.z、tar -vxjf filename.tar.bz2 压缩：tar -vcjf filename.tar.z dirname、tar -vcjf filename.tar.bz2 dirname zip格式 解压：unzip filename.zip 压缩：zip filename.zip dirname rar格式 解压：rar x filename.rar 压缩：rar a filename.rar dirname tar.xz格式 解压方式一： xz -d filename.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d3a5128d8c776207470510ab3bdaabe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc296dc0a0a670d623f538008388adb9/" rel="bookmark">
			机电一体化综合实训【1】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.PD称为（）控制算法
A.比例
B.比例微分
C.比例积分
D.比例积分微分
2.PWM指的是
A.机器人
B.计算机集成系统
C.脉宽调剂
D.可编程控制器
3.齿轮传动的总等效惯量随传动级数()
A.增加而减小
B.增加而增加
C.减小而减小
D.变化而不变
4.电压跟随器的输出电压()输入电压。
A.大于
B.大于等于
C.等于
D.小于
5.对于交流感应电动机，其转差率s的范围为（）。
A.1&lt;s&lt;2
B.0&lt;s1
C.-1〈s&lt;1
D.-1〈s&lt;0
6.滚珠丝杠螺母副结构类型有两类：外循环插管式和()
A.内循环插管式
B.外循环反向器式
C.内、外双循环
D.内循环反向器式
7.加速度传感器的基本力学模型是
A.阻尼一质量系统
B.弹黄一质量系统
C.弹黄一阻尼系统
D.弹黄系统
8.累计式定时器工作时有()
A.1个条件
B.2个条件
C.3个条件
D.4个条件
9.连续路径控制类中为了控制工具沿任意直线或曲线运动，必须同时控制每一个轴的()使得它们同步协调到达目标点。
A.位置和加速度
B.速度和加速度
C.位置和速度
D.位置和方向
10.某4极交流感应电动机，电源频率为50Hz，当转差率为0.02时，其转速为()
A.1450［r/min］
B.1470［r/min］
C.735［r/min］
D.2940［r/min］
11.某光栅的条纹密度是100条/mm，光栅条纹间的夹角θ=0.001孤度，则莫尔条纹的宽度是()
A.100mm
B.20mm
C.10mm
D.0.1mm
12.受控变量是机械运动的一种反馈控制系统称()
A.顺序控制系统
B.伺服系统
C.数控机床
D.工业机器人
13.伺服控制系统一般包括控制器、被控对象、执行环节、比较环节和（）等五个部分
A.换向结构
B.转换电路
C.存储电路
D.检测环节
14.一般说来，如果增大幅值穿越频率ωc的数值，则动态性能指标中的调整时间ts()
A.增大
B.减小
C.不变
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc296dc0a0a670d623f538008388adb9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34e18ffa3e2f231962be40318e6d03b4/" rel="bookmark">
			uniapp vue 身份证号校验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在utils文件夹中创建一个文件 passid.js
//身份证号严格校验 function identityIDCard(code) { //身份证号前两位代表区域 var city = { 11: "北京", 12: "天津", 13: "河北", 14: "山西", 15: "内蒙古", 21: "辽宁", 22: "吉林", 23: "黑龙江 ", 31: "上海", 32: "江苏", 33: "浙江", 34: "安徽", 35: "福建", 36: "江西", 37: "山东", 41: "河南", 42: "湖北 ", 43: "湖南", 44: "广东", 45: "广西", 46: "海南", 50: "重庆", 51: "四川", 52: "贵州", 53: "云南", 54: "西藏 ", 61: "陕西", 62: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/34e18ffa3e2f231962be40318e6d03b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa7be136d8b755fc5c05c24df735b239/" rel="bookmark">
			linux获取usb键盘、扫描枪输入数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当linux主机插入input输入设备后，会在/dev/input/目录下生成一个名为"eventX(X=0…n)"的文件，读取这个文件就能获取到设备的输入信息，如输入键值，类型等信息；
若输入设备为usb键盘或者扫描枪时，应用层就不好直接读取event数据来使用，此时可以读取/dev/ttyX(X=0...n)来获取对应数据。
接到不同的usb口，对应的ttyX(X=0…n)有所不同，测试时需注意。
直接使用cat命令测试:
cat /dev/tty1 或者在应用层直接read数据
int fd; uint8_t rcv_buf[64] = {0}; fd = open("/dev/tty1", O_RDONLY); if (-1 == fd) { printf("open tty error!\r\n"); return; } while (1) { read(fd, rcv_buf, sizeof(rcv_buf)); printf("recv: %s\r\n", rcv_buf); memset(rcv_buf, 0, sizeof(rcv_buf)); } 接入usb键盘、扫描枪后输入数据就能看到对应数据了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e4db03005edadbc543f750d0e7c9fc8/" rel="bookmark">
			anaconda3与rdkit安装教程（Linux系统）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、安装anaconda
1. 下载Anaconda Linux版本
wget https://repo.anaconda.com/archive/Anaconda3-2021.11-Linux-x86_64.sh
或下载后上传至服务器
附下载好的百度云资源：
链接：百度网盘 请输入提取码 提取码：nuwq
2. 执行sh Anaconda*.sh
根据提示，依次输入yes，ENTER
3. 执行vi /root/.bashrc
用vi打开.bashrc文件，默认进入命令模式，输入“i”进入插入模式，在文件的最后加上以下语句，按ESC键，执行: x命令保存并退出。
etup="$('/home/anaconda3/bin/conda' 'shell.bash' 'hook' 2&gt; /dev/null)"
if [ $? -eq 0 ]; then
eval "$__conda_setup"
else
if [ -f "/home/anaconda3/etc/profile.d/conda.sh" ]; then
. "/home/anaconda3/etc/profile.d/conda.sh"
else
export PATH="/home/anaconda3/bin:$PATH"
fi
fi
unset __conda_setup
# &lt;&lt;&lt; conda initialize &lt;&lt;&lt;
4. 关掉Terminal，重新打开，重新进入终端使以上内容生效
5. 进入conda环境
依次执行以下命令
cd anaconda3
cd bin
. ./activate
这两条指令是进入conda环境，其中第2条指令第一个点相当于source，第二个点代表当前路径
二、安装rdkit
更新conda：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e4db03005edadbc543f750d0e7c9fc8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9e2f7e8db583a48f9169b5864f31e86/" rel="bookmark">
			Linux启动时间优化-initramfs裁剪
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： Linux系统启动时使用initramfs（intram file system）在启动初期提供一个用户态环境，用来完成一些内核在启动阶段不容易做或者不必要做的事情，如加载模块，定制化启动过程，执行/init进程等；initramfs制作时通常使用gzip或xz将数据压缩，再通过cpio进行归档。
裁剪过程 前面说过，initramfs通常进行压缩后归档，而启动的时候解压的步骤由内核完成，因此原始initrootfs的大小决定了解压的速度，当然，xz在实现了高压缩比的情况下解压速度是比较慢的，我们讨论的前提是同一压缩方式，本次我们使用的是gzip。未优化前解压initramfs的日志如下：
[ 0.598371] Trying to unpack rootfs image as initramfs... [ 1.706403] Freeing initrd memory: 76116K 可以看到解压花费了1.1s左右的时间，initramfs大小为76116k。
系统启动后，可以在/boot目录查看initrd，具体的内容可以通过lsinitrd命令查看：
Image: initramfs.x86_64.img: 75M ======================================================================== Early CPIO image ======================================================================== drwxr-xr-x 3 root root 0 Jan 1 1970 . -rw-r--r-- 1 root root 2 Jan 1 1970 early_cpio drwxr-xr-x 3 root root 0 Jan 1 1970 kernel drwxr-xr-x 3 root root 0 Jan 1 1970 kernel/x86 drwxr-xr-x 2 root root 0 Jan 1 1970 kernel/x86/microcode -rw-r--r-- 1 root root 30546 Jan 1 1970 kernel/x86/microcode/AuthenticAMD.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f9e2f7e8db583a48f9169b5864f31e86/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0fe783ffa173f97245c96a39fd83aa76/" rel="bookmark">
			1.语音增强技术概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、语音增强发展历史 1987年：Lim和Oppenheim发表语音增强的维纳滤波方法；
1987年：Boll发表谱减法；
1980年：Maulay和Malpass提出软判决噪声一直方法；
1984年：Ephraim和Malah提出基于最小均方误差短时谱幅度估计的语音增强算法；
随后随着DSP发展，相继出现：最小均方（LMS）自适应滤波语音增强算法、基于短时谱（STS）估计的语音增强法、基于小波变换的语音增强算法、改进谱减法等。
二、语音信号特征以及语音信号模型 1.语音信号特征 语音生成过程与发音器官的运动过程密切相关。例如元音发音是气流不受口腔的阻碍发出的，辅音实在口腔阻碍气流时发出的音。同时根据声带的振动与否可以分为**清辅音（声带不振动）和浊辅音（声带振动）**两种。
清音的特点：
没有明显的时域和频域特征，看上去类似于白噪声
浊音的特点：
(1) 在时域上呈现出明显的周期性
(2) 频谱中有明显的几个凸起点，他们的出现频率与声道的谐振频率相对应，这些凸起点称为共振峰，其频率成为共振峰频率。
语音增强中可以利用浊音的明显周期性来区别一直非语音噪声。
2.语音信号模型 为了用计算机定量对语音信号进行模拟和处理，建立了语音发声模型 ， 语音增强信号模型
1）语音发声模型
Av和Au分别为浊音和清音的激励幅度
2）语音增强信号模型
表达式为 : y(n)=s(n)+d(n)
y(n) 表示带噪语音
s(n) 表示纯净语言
d(n) 表示干扰噪音
三、主要研究方法 1）谱减法
经典的谱减法通过假设噪声时平稳的加性噪声，且语音信号与噪声不相关，估计噪声频谱并减去该估计值得到估计的原声，从而实现语音增强。虽然这种方法容易实现，但这种方法在非平稳环境下处理效果不明显，并且在信噪比低的情况下，对语音的可懂度与自然度损害较大。
2）噪声对消法（自适应滤波技术）
需要采集背景噪声作为参考信号，易班采用自适应滤波技术，在输入信号与统计特征或变化未知的情况下，通过调整自身参数，来达到最佳滤波效果。有”自主学习“的过程。
四、效果评价参数 信噪比（SNR）与分段信噪比（segment-SNR）
信噪比=语音信号平均功率/噪声信号的平均功率
信噪比越大，说明噪声和失真越小，波形越接近纯净语音波形
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5074ad0de89acd4e40acb741c9cb8f2/" rel="bookmark">
			Redis学习总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Redis6 NoSQL技术 为什么引入NoSQL 网站开发技术分为功能型技术（java，mysql），扩展型技术（包括Spring和Mybatis等开发框架能够提升整个系统的可扩展性）和性能型技术（ElstackSearch，NoSQL，RocketMQ）
。也就是说Redis属于性能型技术，主要用于解决分布式信息存储。
什么是NoSQL NoSQL指的是Not Only SQL（不仅仅是关系型的数据库），也就是非关系型的数据库可以是像Redis一样的key - value键值对的方式存储数据信息。
列举几种常用的NoSQL数据库 ​
MemCache Redis MongoDB 不同NoSQL之间的区别 这里主要介绍的是memCache和Redis的区别：
①Redis比memCache支持的数据类型更多。
②Redis使用的是单线程+多路复用技术，memCache使用的是多线程加锁的机制
③持久化机制，memCache不支持持久化机制，Redis支持RDB和AOF两种持久化机制
使用场景 推荐 推荐使用Redis的使用场景其实可以归结为三高：
高数据量，高并发，高扩展性
不推荐 在对事务很依赖或者需要结构化的存储和查询数据的场景不推荐使用NoSQL
什么是Redis Redis（Remote Dicitionary Server远程字典服务），其实就是一款基于key - value键值对形式存储数据的数据库，他是用C语言编写的支持网络，支持在内存中运行并且有持久化机制的数据库
Redis的安装和启动 安装 ①Redis官方其实只支持Linux版本，但是微软提供了一款windows下的Redis。我们基于Linux安装。首先得去下载tar.gz包
②使用-zxvf 解压包
③编译使用make命令
思运行使用make install
启动 前台启动 直接运行redis安装目录下的redis-server
后台启动 ①首先修改redis的配置文件将deamonize修改为yes表示支持后台启动
②启动时带上配置文件的地址：
redis-server /etc/redis.conf
Redis为什么这么快 ①运行在内存中数据结构简单类似于一个Hash表读取和存储数据只需要O(1)的时间复杂度
②采用的IO模式是单线程+多路复用的机制，这样避免了多线程之间切换的损耗。通过轮训客户端IO处理，并且使用的是非阻塞IO
redis的默认启动端口号 根据Merz的9键输入法6379
redis的使用场景 redis主要用于分布式微服务的公用信息存储和管理。主要的使用分为作为计数器，作为缓存（缓存热点数据，缓存token甚至缓存整个页面），还可以使用Redis左一个分布式锁做分布式全局事务。另外redis中支持的set类型还可以用于求存储数据的交际并集或者随机抽奖。zset可用于作为一个排行榜
数据类型介绍 Redis是一个key - value类型的数据库其中key的数据类型就是一个字符串作为唯一识别一个value的标记。节介绍的数据类型主要是vakue相关的数据类型。而这些数据类型根据使用的频率分类又可以分为五大常用的出局类型和不常用的数据类型。
五大基本数据类型 String 底层数据结构 String数据类型的底层使用的是一个具有类似于ArrayList一样动态扩容功能的字符串。它的特点就是二进制安全并且最大的空间为512M
使用场景 字符串可用于缓存，缓存session，计数器等等
list 底层数据结构 list数据类型底层的数据结构quickList，当数据量较小的时候其实是一个ZipList类似于数组，当元素变多的时候其实相当于将多个数组使用前后指针连接起来构成一个quickList。其本质上是一个shuangxiang链表。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5074ad0de89acd4e40acb741c9cb8f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2cbc8dd52a81e71b11b8e31c8b623a27/" rel="bookmark">
			交换机命令行配置VLAN
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先，打开Cisco Packet Tracer
①点击下方的终端设备，选择终端并将其拖入空白区域，再重复五次，最终如下图
②点击下方的交换机，选择2960，将其拖入空白区域，如下图
③连线，点击闪电图标，点击直通线
④点击空白区域的终端PC-PT PC0，点击FastEthernet,再点击空白区域的交换机2960-24TTSwitch1,选择FastEthernet0/1
⑥重复⑤操作，将其它终端与交换机连接起来
⑥为各终端配置IP地址，例：
⑦点击交换机，选择命令行
⑧按一下回车，输入 enable //进入特权模式
输入 configure terminal //全局配置模式
输入 vlan 2 //创建VLAN
输入 name VLAN2 //将其名字命名为VLAN2
输入 exit //返回上一级
输入 interface fa0/1 //进入接口fa0/1
输入 switchport access vlan 2 //将fa0/1这个端口划分给 VLAN 2
此时，终端PC0已划分到VLAN 2 中。
输入 exit //返回上一级
输入 interface fa0/2 //进入接口fa0/2
输入 switchport access vlan 2 //将fa0/2这个端口划分给 VLAN 2
输入 exit //返回上一级
输入 interface fa0/3 //进入接口fa0/3
输入 switchport access vlan 2 //将fa0/3这个端口划分给 VLAN 2
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2cbc8dd52a81e71b11b8e31c8b623a27/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60bab8ca01ea9aaf7239d7206e1d054c/" rel="bookmark">
			ubuntu18.04使用kalibr安装以及标定相机的问题总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		按照教程：https://blog.csdn.net/weixin_45868890/article/details/123193276
安装kalibr时候遇到的问题
**问题一：usr/include/eigen3/Eigen/src/Core/util/Macros.h:885:23: error: ‘Eigen::MatrixBase::~MatrixBase() [with Derived = Eigen::Matrix&lt;double, -1, 1&gt;]’ is protected EIGEN_DEVICE_FUNC ~Derived() = default; 原文链接：https://blog.csdn.net/weixin_45868890/article/details/121722656
解决方法：
在/usr/include/eigen3/Eigen/src/Core/MatrixBase.h第466行将 protected改为public在/usr/local/include/eigen3/Eigen/src/Core/MatrixBase.h相应位置（根据终端的报错提醒位置）将 protected改为public关掉这个终端重新打开终端激活环境变量：source devel/setup.bash 一下接着编译
（另外，经美女学妈提示，还可以通过使用命令行reboot重启电脑再编译获得莫名buff加成） 按照教程https://blog.csdn.net/weixin_45868890/article/details/123197364标定相机的时候遇到的问题
问题一：kalibr_workspace/src/kalibr/aslam_offline_calibration/kalibr/python/kalibr_common/ConfigReader.py中的Python NameError: name ‘errList’ is not define！ 解决办法：相应位置的文件中errList全部换成途中的print语句
问题二：(Checkerboard corners:11771): GLib-GObject-CRITICAL **: 10:35:22.443: g_object_unref: assertion ‘G_IS_OBJECT (object)’ failed Attempt to unlock mutex that was not locked 执行命令kalibr_calibrate_cameras --target checkerboard.yaml --bag multicameras_calibration.bag --models pinhole-equi pinhole-equi pinhole-equi --topics /infra_left /infra_right /color --bag-from-to 10 100 --show-extraction --approx-sync 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60bab8ca01ea9aaf7239d7206e1d054c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01cf6c04675e217ce8d3e32be298dfb7/" rel="bookmark">
			RT-Thread移植（二）：CPU架构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 摘自官方文档：
在嵌入式领域有多种不同 CPU 架构，例如 Cortex-M、ARM920T、MIPS32、RISC-V 等等。为了使 RT-Thread 能够在不同 CPU 架构的芯片上运行，RT-Thread 提供了一个 libcpu 抽象层来适配不同的 CPU 架构。libcpu 层向上对内核提供统一的接口，包括全局中断的开关，线程栈的初始化，上下文切换等。
RT-Thread 的 libcpu 抽象层向下提供了一套统一的 CPU 架构移植接口，这部分接口包含了全局中断开关函数、线程上下文切换函数、时钟节拍的配置和中断函数、Cache 等等内容。下表是 CPU 架构移植需要实现的接口和变量。
函数和变量描述rt_base_t rt_hw_interrupt_disable(void);关闭全局中断void rt_hw_interrupt_enable(rt_base_t level);打开全局中断rt_uint8_t *rt_hw_stack_init(void *tentry, void *parameter, rt_uint8_t *stack_addr, void *texit);线程栈的初始化，内核在线程创建和线程初始化里面会调用这个函数void rt_hw_context_switch_to(rt_uint32_t to);没有来源线程的上下文切换，在调度器启动第一个线程的时候调用，以及在 signal 里面会调用void rt_hw_context_switch(rt_uint32_t from, rt_uint32_t to);从 from 线程切换到 to 线程，用于线程和线程之间的切换void rt_hw_context_switch_interrupt(rt_uint32_t from, rt_uint32_t to);从 from 线程切换到 to 线程，用于中断里面进行切换的时候使用rt_uint32_t rt_thread_switch_interrupt_flag;表示需要在中断里进行切换的标志rt_uint32_t rt_interrupt_from_thread, rt_interrupt_to_thread;在线程进行上下文切换时候，用来保存 from 和 to 线程 一共存在6个函数和3个变量，也就是说只要针对开发板的芯片，最多实现这6个函数和3个变量，就可以在RT-Thread架构下屏蔽掉芯片这一层的差异，对上层的代码提供统一的接口来实现与芯片相关的操作。
开关全局中断 摘自官方文档：
无论内核代码还是用户的代码，都可能存在一些变量，需要在多个线程或者中断里面使用，如果没有相应的保护机制，那就可能导致临界区问题。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/01cf6c04675e217ce8d3e32be298dfb7/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/283/">«</a>
	<span class="pagination__item pagination__item--current">284/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/285/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>