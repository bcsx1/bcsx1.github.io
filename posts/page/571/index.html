<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad86f64d5b56bac8ae601de861a1325a/" rel="bookmark">
			深入了解JAVA虚拟机和JVisualVM简单使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		jvm虚拟机参数设置说明: -Dcom.sun.management.jmxremote --JDK1.6 update7以前的平台需增加此参数才能开启JMX管理功能.
-Xverify:none --禁止字节码验证,可提高JDK类加载速度.
-Xmx512m --设置JAVA虚拟机堆内存的最大容量
-Xms256m --设置JAVA虚拟机堆内存的初始容量
-Xmn128m --新生代容量,新生代容量过小,会频繁GC.或者叫堆内存的最小容量,待确认.
-XX:NewSize=64m --设置Yong代内存的默认容量.
-XX:MaxNewSize=64m --设置Yong代内存的最大容量.
-XX:PermSize=96m --设置Permanent(永久)代内存的默认容量.
-XX:MaxPermSize=96m --设置Permanent(永久)代内存的最大容量.
-XX:MinHeapFreeRatio=40 --设置JAVA堆内存最小的空闲百分比,默认值40.
-XX:MaxHeapFreeRatio=40 --设置JAVA堆内存最大的空闲百分比,默认值70.
-XX:NewRatio=2 --设置Yong/old内存的比例.
-XX:SurvivorRatio=2 --设置Yong代中eden/survivor的比例.
-XX:DisableExplicitGC --屏蔽掉代码中显示调用垃圾回收方法System.gc().以下是生成GC日志参数:
-XX:+PrintGCTimeStamps --打印GC停顿时间
-XX:+PrintGCDetails --打印GC详细信息
-verbose:gc --打印GC信息,输出内容已被前一个参数包括,可以不写
-Xloggc:gc.log --指定日志文件
-XX:+HeapDumpOnOutOfMemoryError --在发生内存溢出异常时是否生成堆转储快照.默认关闭.
JVM默认的收集器是Client模式---默认的新生代和老年代串行收集器
如果垃圾回收时CPU资源还比较富余,可以使用CMS收集器,参数如下;
-XX:+UseConeMarkSweepGC --要求老年代使用CMS收集器进行垃圾回收.
-XX:+UseParNewGC --ParNew收集器是使用CMS收集器后的默认新生代收集器
-XX:CMSInitiatingOccupancyFraction=85 --CMS收集器默认老年代使用了68%就进行垃圾回收,这儿指定85%才进行可以减少Full GC次数.
-XX:+StringCache ---是否使用字符串缓存,默认开启.
用以上-XX:+StringCache 试了下,不能运行.如下错误提示
could not create the Java virtual machine
Unrecognized VM option '+StringCache'
-XX:-UseStringCache --这个就可以
JVM虚拟机性能监控与故障处理工具
1.JDK命令行工具---JDK安装bin目录下:
java.exe --JAVA类执行命令
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad86f64d5b56bac8ae601de861a1325a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee4579adf22a60f2e17fbbd43d99bf24/" rel="bookmark">
			关于网页中插入视频的几种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http://www.alixixi.com/web/a/2009080757363.shtml
http://zhidao.baidu.com/question/121711135.html
http://www.blueidea.com/tech/web/2006/3494.asp
http://www.blueidea.com/tech/web/2006/3494_2.asp
http://www.blueidea.com/tech/web/2006/3494_3.asp
http://www.blueidea.com/tech/web/2006/3494_4.asp
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4811ab902a1319434cfd1a21afc496b5/" rel="bookmark">
			地形LOD
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 看来NV的DX11的范例（海洋和岛屿）实际上我只是浏览下代码，我的9600根本不能运行它。感觉用UAV不停的每祯的刷新显存，简直是变态，做硬件的就巴不得你把显卡都烧了。我的笔记本显卡已经烧了，玩魔兽不超过三分钟保证蓝屏。所以把几年前的terrainLOD有翻出来用DX11从新改写了。 我的CPU后台的效能远高于用computeShader_ GPU的速度。 关键在于交换buffer即耗内存也耗显存还要达到CPU、GPU同步这些技术问题NV和微软也每彻底解决掉 computeShader根本无法胜任大批的变量输入 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba97a12987ddf0339a33b9cdade60f45/" rel="bookmark">
			C/C&#43;&#43;要点全掌握（五）——mutable、volatile
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上接C/C++要点全掌握（四）。
13、mutable和volatile 很少遇到这两个关键字，学嵌入式估计知道后者，深入研究C++的估计知道前者。
(1)mutable
在C++中，mutable是为了突破const的限制而设置的。被mutable修饰的变量，将永远处于可变的状态，即使在一个const函数中，甚至结构体变量或者类对象为const，其mutable成员也可以被修改。
struct ST{int a;mutable int b;};const ST st={1,2};st.a=11;//编译错误st.b=22;//允许mutable在类中只能够修饰非静态数据成员。mutable 数据成员的使用看上去像是骗术，因为它能够使const函数修改对象的数据成员。然而，明智地使用 mutable 关键字可以提高代码质量，因为它能够让你向用户隐藏实现细节，而无须使用不确定的东西。我们知道，如果类的成员函数不会改变对象的状态，那么这个成员函数一般会声明成const的。但是，有些时候，我们需要在const的函数里面修改一些跟类状态无关的数据成员，那么这个数据成员就应该被mutalbe来修饰。
class ST{int a;mutable int showCount;void Show()const;…};ST::Show(){…//显示代码a=1;//错误，不能在const成员函数中修改普通变量showCount++;//正确} const承诺的是一旦某个变量被其修饰，那么只要不使用强制转换(const_cast)，在任何情况下该变量的值都不会被改变，无论有意还是无意，而被const修饰的函数也一样，一旦某个函数被const修饰，那么它便不能直接或间接改变任何函数体以外的变量的值，即使是调用一个可能造成这种改变的函数都不行。这种承诺在语法上也作出严格的保证，任何可能违反这种承诺的行为都会被编译器检查出来。
mutable的承诺是如果某个变量被其修饰，那么这个变量将永远处于可变的状态，即使在一个const函数中。这与const形成了一个对称的定义，一个永远不变，而另外一个是永远可变。
看一个变量或函数是否应该是const，只需看它是否应该是constant或invariant，而看一个变量是否应该是mutable,也只需看它是否是forever mutative。
这里出现了令人纠结的3个问题：
1、为什么要保护类的成员变量不被修改？
2、为什么用const保护了成员变量，还要再定义一个mutable关键字来突破const的封锁线？
3、到底有没有必要使用const 和 mutable这两个关键字？
保护类的成员变量不在成员函数中被修改，是为了保证模型的逻辑正确，通过用const关键字来避免在函数中错误的修改了类对象的状态。并且在所有使用该成员函数的地方都可以更准确的预测到使用该成员函数的带来的影响。而mutable则是为了能突破const的封锁线，让类的一些次要的或者是辅助性的成员变量随时可以被更改。没有使用const和mutable关键字当然没有错，const和mutable关键字只是给了建模工具更多的设计约束和设计灵活性，而且程序员也可以把更多的逻辑检查问题交给编译器和建模工具去做，从而减轻程序员的负担。
(2)volatile 象const一样，volatile是一个类型修饰符。volatile修饰的数据,编译器不可对其进行执行期寄存于寄存器的优化。这种特性,是为了满足多线程同步、中断、硬件编程等特殊需要。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的直接访问。
volatile原意是“易变的”，但这种解释简直有点误导人，应该解释为“直接存取原始内存地址”比较合适。“易变”是相对与普通变量而言其值存在编译器(优化功能)未知的改变情况(即不是通过执行代码赋值改变其值的情况)，而是因外在因素引起的，如多线程，中断等。编译器进行优化时，它有时会取一些值的时候，直接从寄存器里进行存取，而不是从内存中获取，这种优化在单线程的程序中没有问题，但到了多线程程序中，由于多个线程是并发运行的，就有可能一个线程把某个公共的变量已经改变了，这时其余线程中寄存器的值已经过时，但这个线程本身还不知道，以为没有改变，仍从寄存器里获取，就导致程序运行会出现未定义的行为。并不是因为用volatile修饰了的变量就是“易变”了，假如没有外因，即使用volatile定义，它也不会变化。而加了volatile修饰的变量，编译器将不对其相关代码执行优化，而是生成对应代码直接存取原始内存地址。
一般说来，volatile用在如下的几个地方：
1、中断服务程序中修改的供其它程序检测的变量需要加volatile；
2、多任务环境下各任务间共享的标志应该加volatile；
3、存储器映射的硬件寄存器通常也要加volatile说明，因为每次对它的读写都可能有不同意义；
使用该关键字的例子如下：
volatile int i=10;int a = i;...//其他代码，并未明确告诉编译器，对i进行过操作int b = i;volatile 指出 i是随时可能发生变化的，每次使用它的时候必须从i的地址中读取，因而编译器生成的汇编代码会重新从i的地址读取数据放在b中。而优化做法是，由于编译器发现两次从i读数据的代码之间的代码没有对i进行过操作，它会自动把上次读的数据(即10)放在b中，而不是重新从i里面读。这样以来，如果i是一个寄存器变量或者表示一个端口数据就容易出错，所以说volatile可以保证对特殊地址的直接访问。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba97a12987ddf0339a33b9cdade60f45/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/170698cc195ebdf138202586d1712b7d/" rel="bookmark">
			Linux后台运行程序，输入输出重定向
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux后台运行程序，输入输出重定向 linux后台运行程序使用&amp;，如，python main.py &amp;，表示后台运行main.py, 即CTRL+C后此程序仍然在后台运行，ps aux|grep "python main.py"可以查看到。
但是当你的linux终端关闭后，此程序就不在运行了，它接受到你的终端断开连接的信号后就关闭了此程序。那么如何使系统忽略终端断开连接的信号呢，终端关闭后程序仍然运行？
很简单，在命令前加nohup，表示忽略终端断开连接的信号，此时如果想停止此程序运行，只能用kill命令。使用nohup时默认将输出到nohup.out文件中，如果想输入到其他文件中，就用到linux中的输入输出重定向。
Linux Shell 环境中支持输入输出重定向，用符号" &lt;"和"&gt;"来表示。0、1和2分别表示标准输入、标准输出和标准错误信息输出，可以用来指定需要重定向的标准输入或输出，比如 2&gt;a.txt 表示将错误信息输出到文件a.txt中。 同时，还可以在这三个标准输入输出之间实现重定向，比如将错误信息重定向到标准输出，可以用 2&gt;&amp;1来实现。 Linux下还有一个特殊的文件/dev/null，它就像一个无底洞，所有重定向到它的信息都会消失得无影无踪。这一点非常有用，当我们不需要回显程序的所有信息时，就可以将输出重定向到/dev/null。 如果想要正常输出和错误信息都不显示，则要把标准输出和标准错误都重定向到/dev/null， 例如： # ls 1&gt;/dev/null 2&gt;/dev/null 还有一种做法是将错误重定向到标准输出，然后再重定向到 /dev/null，例如： # ls &gt;/dev/null 2&gt;&amp;1 注意：此处的顺序不能更改，否则达不到想要的效果，此时先将标准输出重定向到 /dev/null，然后将标准错误重定向到标准输出，由于标准输出已经重定向到了/dev/null，因此标准错误也会重定向到/dev/null，于是一切静悄悄:-) 另外+: make &gt;&amp; make_log 意思是把标准输出和错误输出都重定向, make&gt;out 只重定向标准输出!!!!! &gt;log 表示把标准输出重新定向到文件log中 &gt;&amp; log 表示把标准输出和错误输出都定向到文件log中，相当于 &gt;log 2&gt;&amp;1
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa54a937314a533525fe1e8ff16e6309/" rel="bookmark">
			warning: creating output section vectors without SECTIONS specification
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		相信很多人都遇到过这个警告
警告1.&gt;&gt; warning: creating output section vectors without SECTIONS specification
这段的警告的意思是vectors 段没定义，vectors 是在rts55x.lib中定义的，一般都要用这个库，所有在cmd文件中添加上vectors 的定义就可以了
警告2.&gt;&gt; warning: creating output section .vectors without SECTIONS specification
这个警告一般是使用了 中断汇编文件 scr扩展名的文件，在这个文件中定义了段.vectors 注意 前面的 . ，如果你想用这个写中断向量也要在cmd 文件中 添加.vectors段，这样cmd文件就有 vectors 和 .vectors 其实可以不直接用中断汇编文件那么麻烦，可以使用csl库，
/* 声明 中断向量表开始函数 其实 _Reset 在rts55x.lib 中定义 */
extern void Reset(void);
在程序中只要执行下面的就可以，
/*初始化 CSL library */
CSL_init();
IRQ_setVecs((Uint32)(&amp;Reset));
//定时器中断初始化就像下面一样
void Timer0ini(void)
{
Uint16 eventId0;
/* 打开 Timer 0,设置为默认 */
mhTimer0 = TIMER_open(TIMER_DEV0, TIMER_OPEN_RESET);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa54a937314a533525fe1e8ff16e6309/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02910bbb0cdc1e716bebd6dc834d0808/" rel="bookmark">
			安装python package到指定目录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通过源码安装一个python包的时候，可通过 --home 或 --prefix 指定安装目录
python setup.py install --prefix=~/local 参看 http://docs.python.org/install/index.html alternate installation
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dcfa335cbeabe5a5c16b1a09f912e08d/" rel="bookmark">
			Introduction to the AMQP 0-9-1 Model
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		About This Guide This guide explains the AMQP 0-9-1 model used by RabbitMQ. The original version was written and kindly contributed by Michael Klishin and edited by Chris Duncan.
High-level Overview of AMQP 0-9-1 and the AMQP Model What is AMQP? AMQP (Advanced Message Queuing Protocol) is a networking protocol that enables conforming client applications to communicate with conforming messaging middleware brokers.
Brokers and Their Role brokers 从producers（产生消息的应用）接收消息然后转发给consumers（处理消息的应用）。
AMQP 0-9-1 Model in Brief AMQP 0-9-1 模型的世界观：生产者产生消息，并发送到交换机--可以类比邮局或者邮箱。交换机根据绑定规则将消息分发到队列。要么由AMQP broker将消息递送到订阅队列的消费者，要么由消费者按需主动的从队列中获取。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dcfa335cbeabe5a5c16b1a09f912e08d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10f747c84347facec2e293c8c98af9ff/" rel="bookmark">
			Android4.0 SDK功能详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我在eoe的论坛找到的，就复制过来了，跟大家分享一下。
Android 4.0 平台
API等级：14 Android 4.0 是一次重要的平台发布版，为用户和应用程序开发者增加了大量的新特性。在下面我们将讨论的所有新特性和API中，因为它将 Android 3.x 版本中广泛使用的API和全息图像主题带给了小屏幕设备，因此我们说 Android 4.0 是一次重要的平台发布版。作为一名开发者，现在你拥有了单一的平台和统一的 API 框架，使你可以开发，并通过一个APK 来发布你的应用程序，并且可以为运行相同版本 Android(Android 4.0[API级别14]或以上版本) 的手机、平板电脑和其他设备提供优化了的用户体验。
Social APIs in Contacts Provider
User Profile
最新的android包含了一个机主的个人档案，在 ContactsContract.Profile表里，通过新建一个ContactsContract.RawContacts记录， 社交应用程序可以维护一个用户个人资料数据。这个新的联系人数据表的定义不同于以往的联系人数据表的定义，你必须在 CONTENT_RAW_CONTACTS_URI表里新建1个内容。联系人资料在这个表中被加上了"Me"标签，只能单一用户可见。
增加一个新的联系人资料需要 WRITE_PROFILE权限，读取该联系人资料表需要READ_PROFILE权限。大多数的应用程序需要用户资料，甚至是提供数据给该资料。但是读取用户资料是一个敏感的权限，你应该期望用户对需要读取用户资料的应用保持怀疑态度。
Invite Intent
INVITE_CONTACT intent 允许一个应用按照用户意愿，邀请一个联系人进入某个社会网络的行为。接收程序通过它邀请指定的人加入社会网络。大部分的应用将会在这个操作的接收端。例如，内置的people应用程序里，用户详细信息列表上列出了该用户使用的社交应用，用户可以通过社交应用上的"添加联接"按钮调用 invite intent 连接两个人的社会网络。
为了让你的社交应用程序出现在“添加链接”按钮的列表里，你的应用必须提供一个同步适配器来同步你的社交网络中的联系人信息。你必须通过对你的应用程序的同步配置文件增加inviteContactActivity属性 告知系统你的应用回应 INVITE_CONTACT intent 。activity 必须包含一个完全合格的限定名系统才会给其发送invite intent，相关activity 才会检索意图响应的数据，邀请相关的人加入社会网络或者与手机使用者建立连接。
Large photos
android现在支持高分辨率的联系人照片，当你将一个照片放到联系人记录中的时候，系统会把它处理成96x96的缩略图（像之前那样），和一个256x256 文件形式的的显示图片（该系统选择的确切尺寸，在未来可能会有所不同）。你能够为联系人添加一个大的照片在PHOTO列，系统会再加工成相应的缩略图显示照片记录。
Contact Usage Feedback
新的ContactsContract.DataUsageFeedback APIs 允许你追踪用户使用特定的方法联系其他人的频度，例如用户多久使用每个电话号码或邮件。此信息有助于改善与每个人相关联的每个接触方法的排名，并提供更好的建议去联系每个人联系。
Calendar (日历) Provider
新的日历API允许我们读，增加，编辑和删除存储在Calendar Provider的日历、事件与会者，提醒和警示， 各种应用程序和部件可以使用这些API来读取和修改日历事件。然而，一些最引人注目的用例的是同步适配器能够通过Calendar Provider同步其他日历服务的用户的日历，能够一所有的用户事件提供一个统一的存放位置。例如，GOOGLE日历事件，是同步的google日历同步适配器，允许这些事件在android内置的日历软件中查看。
Event intent
如果你想要做的是用户的日历添加事件，你可以使用"vnd.android.cursor.item/event"类型 的ACTION_INSERT intent 开始在日历应用程序的活动，创建新的事件。使用的意图，不需要任何权限并且您可以指定下列额外的事件的详细信息：（事件名，事件开始时间，结束时间，地点，描述，等等。）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/10f747c84347facec2e293c8c98af9ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b66ce1158be8614a72128887fe40d6df/" rel="bookmark">
			erlang学习： mnesia的分布式功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 mnesia 是一个分布式的数据存储系统。 一个mnesia集群，有多个mnesia节点组成 mnesia节点之间互相联通 （如何联通？） 1、创建schema 在一个节点上，通过 mnesia:create_schema(NodeList)， 在整个集群中，创建空的schema。NodeList指定了集群中所有的节点。 注意： 1）、schema只能创建一次 2）、实际上，每个节点都保存一份schema拷贝 2、 创建表 在一个节点上，通过 mnesia:create_table()，则创建一个分布式的表。 mnesia会自动将该表同步到节点中其它节点上。 每个节点，实际上还是维护的本地的一个表。 3、 分布式的插入、删除、修改、查询操作。 在任意一个节点上进行如上操作，都会同步反映到集群中的其它节点上。 4、 事务和脏操作。 事务是同步的操作，性能低，但能确保一致性。 脏操作不能保证一致性，但是速度极快。 5、 change_config 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/353d16ce25787e6fed77a10ff90de488/" rel="bookmark">
			32位bmp转换成24位
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		读取视频帧出来的是32位bmp，由于要用到24位，所以要有个转换，方法很简单，就是去掉32位里的每个像素alpha值，
BYTE *pTemp; //已知 32位 数据
BYTE *pData24; DWORD dwSize32; //已知，32位大小
DWORD dwSize24;
dwSize24 = (dwSize32*3)/4; pData24 = new BYTE[dwSize24];
for(int index=0;index&lt;dwSize32/4;index++) //像素总个数
{
unsigned char r = *(pTemp++);
unsigned char g = *(pTemp++);
unsigned char b= *(pTemp++);
(pTemp++); //去掉alpha
*(pData24++) = r;
*(pData24++) = g;
*(pData24++) = b;
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27d8507b65b4004f9f6e6002ed03099d/" rel="bookmark">
			DVD光盘大解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、DVD-R与DVD+R有何区别?
要说区别，我想先说说关于DVD碟片的一些历史,让大家了解为什么DVD碟片会有+/-之分。 DVD-R LOGO
1997年，日本先锋公司发布了全球第一款DVD刻录机，当时的售价高达35000美元，想想现在199元人民币的价格，还是相当恐怖的。该款刻录机使用的碟片格式延续CD-R的标准称之为DVD-R。该碟片按照先锋公司的DVD-R规格1.0版设计 当时设计存储能力仅为3.95GB。99年底，先锋发布DVD-R 2.0版，此时DVD-R存储能力已达到4.7GB。DVD-R得到DVD论坛(领导厂商包括先锋、东芝、索尼、夏普、三星)的支持,并对-R格式的规格作出了详细的规定。 DVD+R LOGO
但由于利益问题（权利金等问题），导致具有技术优势的厂商出现的分歧。2001年秋冬季节，CD-R时代的霸主荷兰飞利浦公司先后发布了+RW、+R格式，该格式得到了以飞利浦，索尼，理光，惠普为主导厂商的DVD联盟的支持。 威宝DVD±RW光盘
虽然之前有各种纷争，但随着技术的不断进步，DVD-R光盘与DVD+R光盘的差距越来越小，简单而言，由于DVD-R光盘设计之初就是以影音娱乐为导向，因此在DVD影碟机上会显得兼容性更高。
索尼DVD±R盘
而DVD+R光盘设计之初更多是以数据存储为导向，并且在DVD-R发布之后才推出，技术必然有所提高，因此能够在追加写入方面优于DVD-R（追加写入即一次刻录没有刻满，还可以继续，直至刻满，但不能删除光盘上的数据，也不能格式化光盘）。DVD+R与DVD-R相同，也属于一次性刻录标准规格。
市面上DVD-R光盘相对更多
技术上，DVD-R被认为更成熟，而DVD+R被认为更先进，但到底技术成熟更重要还是先进重要就看您自己选择了。
2、DVD±RW光盘可以擦写多少次？
DVD-RW光盘的全称为Re-recordable DVD，而DVD+RW光盘的全称为DVD ReWritable，从名字上就可以看出，它们都代表着可重复擦写式DVD。
DVD±RW光盘
DVD－RW和DVD+RW这两种格式非常类似，他们都是在原有的CD-R/RW技术上发展演变而来的，因此他们会非常好的兼容现有的CD/DVD家用产品。1999年第一款DVD－RW产品在日本出现，但直到2001年才在欧美上市。DVD＋RW却没有这么顺利，在设计的过程中几经波折，最终面世是在2001年底。
DVD±RW光盘
DVD±RW光盘属于可擦写光盘，而擦写光盘也比较简单，只需要将光盘进行格式化，或选择Nero中的“抹除光盘”（擦除DVD）选项即可将光盘重置，可以再将准备好的数据刻录到光盘上。
Nero软件擦写DVD±RW光盘
DVD±RW光盘究竟可以反复擦写多少次，一直是网友非常关注的问题。事实上，虽然DVD±RW光盘理论峰值是可以反复擦写1000次，但实际使用上，大多数用户反应擦写30次左右就已经无法使用了，而据笔者使用的日产TDK DVD-RW光盘来看，在保养得当的情况下，一般支持40——50次应该是一个比较实际的数字。
3、DVD-RAM是什么？
DVD-RAM的全称为DVD- Random Access Memory（DVD随机存储器），它是由松下、日立与东芝全球三家知名光存储公司所开发的。DVD-RAM所使用的技术源于松下自己的Phase-change Dual(双相变)光盘技术，同时结合了硬盘、MO磁光盘（Magnetic Optical：在80年代初研制开发，从1989年开始投入使用，它是传统的磁盘技术与现代的光学技术结合的产物）的部分存储技术，针对于数据存储应用而开发。
DVD-RAM LOGO
在DVD刚推出时DVD视频格式还没有非常流行，而DVD-RAM在设计时更多的考虑作为数据存储媒体，这是导致DVD-RAM不能与其他几种DVD格式相兼容的根源。因为具有RAM（Random Access Memory，随机存储器）的能力，DVD-RAM素有“光硬盘”之称，使用DVD-RAM时我们在XP下不再需要什么刻录软件，随意复制粘贴就能完成文件存储与删除操作。
早期的DVD-RAM
兼容性是DVD-RAM和普通DVD之间主要的差异之一。早期的DVD－RAM刻录盘还有一个光盘匣。需要特殊类型的DVD刻录机才能使用。当然现在已经去掉卡匣，采用与普通DVD光盘一样的刻录方式。
卡匣式刻录机
与普通可擦写刻录格式相比，DVD-RAM拥有几大优点：一是高达10万次复写次数（实际使用据调查也是千次以上），保存年限更长(长达100年)；二是格式化时间很短，格式化好的光盘不需特殊的软件就可进行写入和擦写，也就是说它具有强大的本地直接裁剪与编辑的功能，用户可以像操作硬盘一样轻松使用它；三是具有强大的缺陷管理与纠错能力（写入时），可确保写入数据的万无一失；四是具有独一无二的读写可同时进行的能力；五是它支持版权保护技术。
另外，DVD-RAM是唯一能够实现录放同步的光学碟片格式。它可以使您在任何时候都能观赏所需要的节目，即便当正在录制其他节目时也不例外。在录制和播放过程中可对快进、快退和暂停等功能进行全面的控制。DVD-RAM的核心技术实现了高速数据传输和精确的随机存取等有创新意义的功能。
形形×××的DVD-RAM光盘
目前主流的DVD-RAM主要有2×、3×、5×、8×这几种速度，还分为4.7GB和9.4GB两种规格容量。但价格比起一般DVD就贵了不少。现在市场上最常见到的松下3×DVD-RAM，价格也要在9元以上。
4、D9和D5有什么区别？
DVD±R DL光盘简称D9，即单面双层光盘，最大容量8.5GB。而普通DVD为单面单层光盘，最大容量4.7GB，简称D5。
DVD±R DL LOGO
下面笔者来为您介绍下DVD±R DL的原理，它是相对于普通单面单层4.7G来说的单面双层刻录（DVD+/-Recordable Double layer），具有两个存储层，相比普通的单面单层刻录盘存储容量扩充到了8.5G，因此在研发和生产实力上有一定难度。
DVD±R DL光盘
DVD±R DL(Dual Layer)光盘，采用了一种嵌入双记录层（第一记录层L0和第二记录层L1），并在L0和L1之间添加隔离层的新的制造工艺，通过双记录层分别记录和保存数据，实现容量翻番。
DVD±R DL盘面解析
DVD±R DL光盘主要通过额外的储存层来增加数据储存容量，这个储存层是由刻录盘片的同一面来存取，不需要把刻录盘片换面以读取另一面的数据。惟一的差异是两者的技术有一些小的区别，例如定位的机制不同等，但实用的效果是一样的。
目前，新推出的DVD刻录机基本上都支持DVD+R DL和DVD-R DL，但由于刻录盘片较贵，2.4倍速的刻录盘片售价将近20元，速度较慢且价格较昂贵所以使用的人不多。但是在影碟店里，D9光盘却是非常常见的，因为其容量大，可以以D9光盘发行一般是AC3和DTS伴音制式的影片，或者是超过120分钟的长片。 总结点评：通过以上为大家介绍了目前光盘市场的主流规格和特色技术，大家如果需要保存重要数据可首先考虑一下DVD-RAM，观看影碟还是DVD±R DL，而普通刻录DVD±R则是最优惠的选择。总之，目前市场中盘片的品牌的品质鱼龙混杂，虽然差价都不大，但品质却是天壤之别，所以至少要对市场主流产品有所了解，挑选产品才能得心应手。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/27d8507b65b4004f9f6e6002ed03099d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56816e55e67ae9ca3b652750a00f4a52/" rel="bookmark">
			C&#43;&#43;递归用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自：http://bbs.ikaka.com/showtopic-664019.aspx
简单谈谈C++ 递归的思想实现以及和循环的关系
很多初学者往往对递归迷惑不解，也在这上面花了不少的时间。其实教材上的例子很经典，只是它说的有一些唠叨了。初学者会看的头大的。编程是解决问题的，而现实中很多的问题都是比较简单的，没有象汉诺塔那么复杂。我们也不必追究递归到底是怎样实现的，我们只是要会用递归，会用递归来为我们解决一些问题，这就行了。
首先来看一个例子：
有一个Febonacci序列：
1,1,2,3,5,8,13,,21,34........
它的问题是：求这个序列中的第N个数。
由于它的函数原形是：f(N)=f(n-1)+f(n-2)
这用递归很容易就可以写出代码来，一点都不费事：
int Febc(int n) {
if(n&lt;3) return (1);
else
return (Febc(n-1)+Febc(n-2));
}
噢~~~~~也许你会说递归真是太简单了，简直就是一个数学模型嘛，呵呵。
其实，递归函数的工作过程就是自己调用自己。有一些问题用递归就很容易解决，简单的你自己都会吃惊。
我们做事情，一般都是从头开始的，而递归却是从末尾开始的。比如上面的函数吧，当n&gt;3时，它显然只能求助于n-1,n-2。而(n-1)&gt;2,(n-2)&gt;2时，它们就求助于：(n-1)-1,(n-1)-2;(n-2)-1,(n-2)-2;然后··············直到（n-k)&lt;3,(n-k-1)&lt;3时，函数Febc终于有了返回值1 了，它再从头开始计算，然后一直算到n 为止。
通过上面的例子，我们知道递归一定要有一个停止的条件，否则递归就不知道停止了。在上面的例子中， if(n&lt;3) return (1); 就是停止的条件。
然而，使用递归的代价是十分巨大的：它会消耗大量的内存！！递归循环时它用的是堆栈，而堆栈的资源是十分有限的。上面的例子你只能用一个很小的n值。如果n=20，即Febc(20)的话，它将调用Febc(N)函数10000多次！！！而上面一个例子用循环也是十分容易写的：
/*using turboc2*/
int febc(int);
main()
{
int n;
scanf("%d",&amp;n);
febc(N);
}
int febc(int n)
{
int a[3],i;
a[0]=a[1]=a[2]=1;
for(i=3;i&lt;=n;i++)
a[i%3]=a[(i+1)%3]+a[(i+2)%3]; /*实现 Febc(I)=Febc(i-1)+Febc(i-2)*/
printf("\n%d\n",a[n%3]);
}
有兴趣者不妨输入一个较大的n值，然后比较比较这二个函数计算的速度。当然， 如果你使用的n太大的话，递归可能发生错误。如果死机了可别骂我哦~~~ 我已经提醒过你了 ：）
现在我们再来看看一个求从1 加到100的循环：
/*turboc2*/
main()
{ int i,n;
for(i=1;i&lt;101;i++)
n+=i; }
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/56816e55e67ae9ca3b652750a00f4a52/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/937f8b7c7a7a344e05d551ea7180dcb3/" rel="bookmark">
			macro redefinition警告或错误的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Windows下使用VS2008编译时经常遇到macro redefinition警告或错误，如：
c:\programme\microsoft sdks\windows\v6.0a\include\ws2def.h(91) : warning C4005: 'AF_IPX' : macro redefinition
解决方法：打开编译选项 /showIncludes Use the compiler option /showIncludes to find out how they are getting included.
看程序直接或者间接Include了哪些头文件，通过调整头文件顺序等办法解决。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb0ab3ff958e86c93580a05475effb94/" rel="bookmark">
			Jquery 获取多选下拉列表select multiple的文字和值 text val
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 var userids = ""; var usernames=""; $("#rightuser option").each(function() { userids += $(this).val()+','; usernames += $(this).text()+','; }); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b6389c6bad67be68c0bc49419e7104d/" rel="bookmark">
			Matlab环境下使用USB2.0摄像头编程image acquisition tools（读书笔记）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（1）Matlab环境下使用USB2.0摄像头编程
Matlab中的图像获取工具箱给我们提供了必要的函数，我们直接调用就可以了，主要就是简单的介绍如何使用该工具箱进行对USB2.0摄像头的编程。
TAG: USB摄像头 Matlab Matlab中的图像获取工具箱给我们提供了必要的函数，我们直接调用就可以了。在这帖中我们主要就是简单的介绍如何使用该工具箱进行对USB2.0摄像头的编程
废话不多说，我们开始言归正传了。但是一定记住你必须安装了PC摄像头才可以进行下面的东西，如果说首次安装摄像头最好重启下PC，否则可能出现没法识别摄像头。
整个过程我们需要做如下几件事情：
1、查询USB2.0Camera 的具体参数(imaqhwinfo)
2、创建视频输入对象(videoinput)
3、图像预览和显示(preview、stoppreview、closepreview和image)
4、获取视频图像(getsnapshot)
5、图像获取设备的获取和设置(get和set)
6、关闭视频对象(delete)
在正式讲解之前，我想说明下几个在图像获取工具箱中的术语：
图像获取设备：比如摄像头、扫描仪
图像获取适配器：主要的目的是通过驱动在Matlab和图像获取设备之间传递信息
ROI：region-of-interest 感兴趣区域
再说说几个常用的函数，我们这里只是说明它的作用，具体如何使用参考帮助系统
getselectedsource
imaqfind
isvalid
peekdata
getdata
imaqmontage
查询USB2.0Camera的具体参数
给我们一个摄像头我们必须知道他的相关参数，才可能进行我们的编程下。当然我们可以查询商家手册，但是那个累不累人呀。
Matlab的图像获取工具箱为我提供了imaqhwinfo()，来获取PC上以安装的图像获取硬件信息
没有输入参数时，返回一个结构体， 它包含了系统中存在的适配器和Matlab相关的版本信息( 第一次我们一般使用这个)
&gt;&gt; info=imaqhwinfo
info =
InstalledAdaptors: {'coreco' 'winvideo'}%这里可以看到我的PC上安装了两个适配器
MATLABVersion: '7.6 (R2008a)'
ToolboxName: 'Image Acquisition Toolbox'
ToolboxVersion: '3.1 (R2008a)'
复制代码
有输入参数的时候，返回一个结构体，包含了指定的适配器的数据信息
&gt;&gt; win_info=imaqhwinfo('winvideo')%我们看看第二适配器的具体参数
win_info =
AdaptorDllName: [1x81 char]%适配器dll文件绝对路径
AdaptorDllVersion: '3.1 (R2008a)'%适配器dll文件版本
AdaptorName: 'winvideo'%适配器名称
DeviceIDs: {[1]}%设备ID号，这个我们经常需要用到
DeviceInfo: [1x1 struct]%设备信息，这里主要是图像获取设备的一些参数，比较重要
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b6389c6bad67be68c0bc49419e7104d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/648f833c1d4eb871ff57ebe0cb1b0b79/" rel="bookmark">
			字符识别OCR研究一（模板匹配&amp;BP神经网络训练）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于机器学习的方法做OCR识别详见我其他博客：http://blog.csdn.net/zhubenfulovepoem/article/details/51165887 Abstract 2
一 引言：... 3
二 字符图像获取：... 3
三 字符预处理... 4
3.2 字符区域………………………………………………………………………….4
3.2 字符区域分割：... 4
3.3 单个字体分割：... 4
3.4 单个字体裁剪... 5
四 模板字符识别... 5
4.2 字符模板归一化... 5
五BP神经网络字符识别... 5
5.1 训练样本制作………………………………………………………………………………….6
5.2设计BP神经网络………………………………………………………………………………6
5.3 BP训练... 7
六 识别结果发送下位机... 7
5.1 MATLAB下的串口工具：... 7
5.2 下位机处理... 7
5.2. 3 串口通信图：... 9
七 总结：... 9
摘 要
在MATLAB环境下利用USB摄像头采集字符图像，读取一帧保存为图像，然后对读取保存的字符图像，灰度化，二值化，在此基础上做倾斜矫正，对矫正的图像进行滤波平滑处理，然后对字符区域进行提取分割出单个字符，识别方法一是采用模板匹配的方法逐个对字符与预先制作好的字符模板比较，如果结果小于某一阈值则结果就是模板上的字符；二是采用BP神经网络训练，通过训练好的net对待识别字符进行识别。最然后将识别结果通过MATLAB下的串口工具输出51单片机上用液晶显示出来。
关键字： 倾斜矫正，字符分割，模板匹配，BP神经网络，液晶显示
MATLAB代码下载地址：http://www.pudn.com/downloads386/sourcecode/graph/text_recognize/detail1655710.html
PC端MATLAB识别，然后通过串口发送到51单片机的代码下载地址：http://www.pudn.com/downloads386/sourcecode/embedded/detail1655716.html
Abstract
In the MATLAB environmentusing USB camera capture the character images, saved as an image reading, thenread the saved character images, grayscale, binary, on this basis do tilt correction,the correction image smoothing filter, and then extract the character regionsegmentation of a single character, and then one by one using a templatematching method of character with good character template is a pre-production,if the result is less than a certain threshold, the result is a template of thecharacter.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/648f833c1d4eb871ff57ebe0cb1b0b79/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e94fcdc8c2b40eb92848dc042713705/" rel="bookmark">
			udhcpc命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于要使用网络通讯，所以不可避免的要用到dhcp。理想的网络通讯方式是下面3种都要支持:
1,接入已有网络。这便要求可以作为dhcp客户端。
2,作为DHCP服务器，动态分配IP。
3,指定固定IP
第3种情况没有什么好说的，简单说下前2种情况。
使用步骤：
（1）在内核的网络项里面把DHCP配置上；
（2）在busybox里面把[*]udhcp server(udhcpd)
[*]udhcp client(udhcpc)都选上。
udhcpd就是终端设备作为DHCP服务器
udhcpc就是终端设备作为DHCP客户端
busybox里面对dhcp都已经给出例子了，
[zhh@localhost busybox-1.14.1]$ ls ./examples/udhcp/
sample.bound sample.deconfig sample.nak sample.renew sample.script simple.script udhcpd.conf
比如使用udhcpc时
就可以直接把simple.script拿来使用，改不改名字都可以，busybox里面默认的目录文件是/usr/share/udhcpc/default.script
可以查看下帮助
# udhcpc --help
BusyBox v1.14.1 (2010-01-22 10:35:16 CST) multi-call binary
Usage: udhcpc [-Cfbnqtvo] [-c CID] [-V VCLS] [-H HOSTNAME] [-i INTERFACE]
[-p pidfile] [-r IP] [-s script] [-O dhcp-option]... [-P N]
-V CLASSID Vendor class identifier
-i INTERFACE Interface to use (default: eth0)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e94fcdc8c2b40eb92848dc042713705/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0aa9d366bffcdd3d07cb8fa622c30b4/" rel="bookmark">
			Spring注解@Component、@Repository、@Service、@Controller区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很长时间没做web项目都把以前学的那点框架知识忘光了，今天把以前做的一个项目翻出来看一下发现用·@Component标记一个组件，而网上有的用@Service标记组件，我晕就查了一下资料：
Spring 2.5 中除了提供 @Component 注释外，还定义了几个拥有特殊语义的注释，它们分别是：@Repository、@Service 和 @Controller。
在目前的 Spring 版本中，这 3 个注释和 @Component 是等效的，但是从注释类的命名上，很容易看出这 3 个注释分别和持久层、业务层和控制层（Web 层）相对应。
虽然目前这3 个注释和 @Component 相比没有什么新意，但 Spring 将在以后的版本中为它们添加特殊的功能。
所以，如果 Web 应用程序采用了经典的三层分层结构的话，最好在持久层、业务层和控制层分别采用上述注解对分层中的类进行注释。
@Service用于标注业务层组件
@Controller用于标注控制层组件（如struts中的action）
@Repository用于标注数据访问组件，即DAO组件
@Component泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。
@Service public class VentorServiceImpl implements iVentorService { } @Repository public class VentorDaoImpl implements iVentorDao { } 在一个稍大的项目中，如果组件采用xml的bean定义来配置，显然会增加配置文件的体积，查找以及维护起来也不太方便。 Spring2.5为我们引入了组件自动扫描机制，他在类路径下寻找标注了上述注解的类，并把这些类纳入进spring容器中管理。
它的作用和在xml文件中使用bean节点配置组件时一样的。要使用自动扫描机制，我们需要打开以下配置信息：
代码
&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd"&gt; &lt;context:component-scan base-package=”com.eric.spring”&gt; &lt;/beans&gt; 1.component-scan标签默认情况下自动扫描指定路径下的包（含所有子包），将带有@Component、@Repository、@Service、@Controller标签的类自动注册到spring容器。对标记了 Spring's @Required、@Autowired、JSR250's @PostConstruct、@PreDestroy、@Resource、JAX-WS's @WebServiceRef、EJB3's @EJB、JPA's @PersistenceContext、@PersistenceUnit等注解的类进行对应的操作使注解生效（包含了annotation-config标签的作用）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a0aa9d366bffcdd3d07cb8fa622c30b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a126944b125d87d0cdfd5752f5087a12/" rel="bookmark">
			wince下IImage接口的使用，处理jpeg、bmp、png等格式图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 项目中使用了IImage接口，发现其功能很强大，现在感觉唯一的缺点是速度问题，本来要处理很多格式的图片，自己写编解码，就写了个bmp的，因为bmp的RGB数据很好读出，保存bmp文件也很容易，像jpeg这样的压缩文件的编解码就很麻烦，我水平有限，就偷懒，使用了IIMage接口，IImage接口可以用来转换各种格式图片，在wince下gdi绘图只支持bmp文件格式，要想加载jpeg、png格式的文件就只能把他们转换成bmp文件，幸好找到了IImage接口，IImage接口下的函数使用都在imaging.h下 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d45b4d2a599dd11245d802fbffd81948/" rel="bookmark">
			从CPU、内存和I/O深度理解IA架构服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文地址：http://server.it168.com/a2010/0803/1085/000001085698_all.shtml
【IT168 技术】从性能角度来看，处理器、内存和I/O这三个子系统在服务器中是最重要的，它们也是最容易出现性能瓶颈的地方。目前市场上主流的服务器大多使用英特尔Nehalem、Westmere微内核架构的三个家族处理器：Nehalem-EP，Nehalem-EX和Westmere-EP。下表总结了这些处理器的主要特性：
Nehalem-EP Westmere-EP Nehalem-EX Nehalem-EX 商业名称 至强5500 至强5600 至强6500 至强7500 支持的最插座数 2 2 2 8 每插座最大核心数 4 6 8 8 每插座最大线程数 8 12 16 16 MB缓存 (3级) 8 12 18 24 最大内存DIMM数 18 18 32 128 在本文中，我们将分别从处理器、内存、I/O三大子系统出发，带你一起来梳理和了解最新英特尔架构服务器的变化和关键技术。
一、处理器的演变
现代处理器都采用了最新的硅技术，但一个单die(构成处理器的半导体材料块)上有数百万个晶体管和数兆存储器。多个die组织到一起就形成了一个硅晶片，每个die都是独立切块，测试和用陶瓷封装的，下图显示了封装好的英特尔至强5500处理器外观。
图 1 英特尔至强5500处理器
插座
处理器是通过插座安装到主板上的，下图显示了一个英特尔处理器插座，用户可根据自己的需要，选择不同时钟频率和功耗的处理器安装到主板上。
图 2 英特尔处理器插座
主板上插座的数量决定了最多可支持的处理器数量，最初，服务器都只有一个处理器插座，但为了提高服务器的性能，市场上已经出现了包含2，4和8个插座的主板。
在处理器体系结构的演变过程中，很长一段时间，性能的改善都与提高时钟频率紧密相关，时钟频率越高，完成一次计算需要的时间越短，因此性能就越好。随着时钟频率接近4GHz，处理器材料物理性质方面的原因限制了时钟频率的进一步提高，因此必须找出提高性能的替代方法。
核心
晶体管尺寸不断缩小(Nehalem使用45nm技术，Westmere使用32nm技术)，允许在单块die上集成更多晶体管，利用这个优势，可在一块die上多次复制最基本的CPU(核心)，因此就诞生了多核处理器。
现在市场上多核处理器已经随处可见，每颗处理器包含多个CPU核心(通常是2，4，6，8个 )，每个核心都有一级缓存(L1)，通常所有的核心会共享二级(L2)、三级缓存(L3)、总线接口和外部连接，下图显示了一个双核心的CPU架构。
图 3 双核心CPU架构示意图
现代服务器通常提供了多个处理器插座，例如，基于英特尔至强5500系列(Nehalem-EP)的服务器通常包含两个插座，每个插座四个核心，总共可容纳八个核心，而基于英特尔至强7500系列(Nehalem-EX)的服务器通常包含八个插座，每个插座八个核心，总共可容纳64个核心。
下图显示了更详细的双核处理器架构示意图，CPU的主要组件(提取指令，解码和执行)都被复制，但系统总线是公用的。
图 4 双核处理器的详细架构示意图
线程
为了更好地理解多核架构的含义，我们先看一下程序是如何执行的，服务器会运行一个内核(如Linux，Windows的内核)和多个进程，每个进程可进一步细分为线程，线程是分配给核心的最小工作单元，一个线程需要在一个核心上执行，不能进一步分割到多个核心上执行。下图显示了进程和线程的关系。
图 5 进程和线程的关系
进程可以是单线程也可以是多线程的，单线程进程同一时间只能在一个核心上执行，其性能取决于核心本身，而多线程进程同一时间可在多个核心上执行，因此它的性能就超越了单一核心上的性能表现。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d45b4d2a599dd11245d802fbffd81948/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a71f8fcd8bc178ea63c7fe83288065b7/" rel="bookmark">
			lua学习： lua及函数式编程语言
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 无论 python, ruby， 还是 erlang, lua， 这几个比较新锐的语言，都支持函数式编程。 函数式编程到底具有哪些特点？ 相对于传统的命令式语言，其优势在什么地方？ 函数式编程，有如下几个特点： 1、 函数是第一类型。 函数像其它数据类型一样，可以被赋值，可以当做参数，也可以当做函数的返回值。 其实， C语言的函数，实质就是一种指针类型，因此我们可以说，C语言也是支持函数式编程的。 2、 函数的执行结果，只与传入的参数相关。 也就是说，只要传入的参数不变，那么函数的执行结果就是一定的，而不受其它条件影响。 这就要求我们，在函数内部，不要访问全局变量。 这点实质上是函数式编程的核心。 这个用术语表示，叫做“引用透明性” 3、 变量一旦被赋值，就永远不可修改。 C 语言如何表示？ 4、 惰性计算 将一个函数绑定到一个变量的时候，并不立刻计算； 而是在使用的时候才去计算。 5、 闭包 在其它函数内部定义的函数 6、 高阶函数 使用其它函数作为参数的函数，称为高阶函数 7、 匿名函数 lambda 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0fa3d1fd39f4d494da89a63290b18e2/" rel="bookmark">
			ICE介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		高清视频会议MCU
1关于ICE的10个事实
1 ICE使用STUN和TURN
2 ICE是一种P2P的NAT穿越方式
3 ICE只需要网络提供STUN或TURN服务器
4 ICE允许在很复杂的网路环境下传输媒体流
5 ICE只在确定媒体流可到达情况下才让电话进行振铃
6 ICE动态发现终端间媒体流的最短路径
7 ICE可以附带消除DoS攻击
8 ICE可以几乎和任意类型的NAT和防火墙设备一起工作
9 ICE不需要终端去发现NAT类型以及它们的存在
10 ICE只有在最坏的情况下才只用中继(两边都在对称NAT之后)
2 ICE的步骤
ICE 是一种探索、学习和更新式的解决方案。在ICE 算法的开始，通信的2 个代理并不知道自己的拓扑部署——在NAT 后还是不在NAT 后。
2.1 初始请求的发送
为了探索本地拓扑，代理 A 执行如下操作，收集 3 类候选地址(Candidates)：
(1)A 从本地接口上获得主机候选地址（Host Candidates）192.168.1.22: 8484；
(2)发送STUN 绑定请求到STUN 服务器获得服务器反射候选地址(Server Reflexive Candidates)202.199.112.102: 61866；
(3)发送TURN 分配请求到TURN 服务器获得中继候选地址(Relay Candidates)202.199.112.105: 5006，同时也获得了服务器反射候选地址202.199.112.102: 62072。
这些候选地址是随后可能用于接收媒体流的地址。
计算候选的优先级。设置主机候选的类型优先参数为最高值126，服务器反射候选的类型优先参数为100，中继候选的类型优先参数为最低值0。本地参数设为65 535，分组ID为1。经计算，主机候选的优先级为2 130 706 431，服务器反射候选的优先级为1 694 498 815，中继候选的优先级为16 777 215。按候选优先级高低排序。分配主机候选的基础(Foundation)属性为1，服务器反射候选的基础属性为2，中继候选的基础属性为3。
按中继候选、服务器反射候选、主机候选次序选择默认候选(该候选包含了默认用于接收媒体流的地址和端口)，由于A 获得了中继候选，因此优先选择连通概率较大的中继候选202.199.112.105:5006 作为默认候选。
将默认候选的 IP 地址和端口编辑进SDP 的c 行和m 行，并添加收集到的3 个候选地址到a 属性，形成发送请求Offer，通过信令信道传给B，请求消息内容如下所示，修改的参数和添加的属性值用粗体显示。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e0fa3d1fd39f4d494da89a63290b18e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63ceef832240ca075ebbefd2512403a2/" rel="bookmark">
			unix shell &#34;$&#34;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 linux shell $ $0 shell的命令本身(包括完整路径) $1到$9 数字表示shell 的第几个参数 $# 传递到脚本的参数个数 $* 以一个单字符串显示所有向脚本传递的参数 $$ 脚本运行的ID号 $! 后台运行的最后一个进程的ID号 $@ 与$*相同。 $- 显示shell使用的当前选项。 $? 显示最后命令的执行状况。0表示没有错误。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46215e24caf3a25bb5c9f3e5078423b7/" rel="bookmark">
			lua学习： 为什么学习lua？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 如果把Lua当做一门纯粹的脚本语言来使用，那它肯定比不上 python 强大高效；很多事情它也干不了。 使用Lua的唯一理由，是可以方便的潜入到其它语言中，特别是 C/C++，在提高复杂逻辑的开发效率的同时，性能上也不会损失太多。 因为Lua的解释器性能上非常好，Lua本身依赖的库也比较小。 Lua目前最适合的应用领域是游戏开发中的脚本 学习Lua，重点应该是研究如何配合C/C++提高开发效率。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3510ed8c5ae953609bddfb558ad1518/" rel="bookmark">
			win7管理员打开组策略,拒绝访问
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		管理员打开组策略,拒绝访问。
把 C:\WINDOWS\system32\GroupPolicy\gpt.ini 删了，再运行 gpedit.msc 就OK 了
（感谢帖作者！）：
http://social.microsoft.com/Foru ... b-990b-972252436985
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42a0891ebd538335d7c3af845eec634c/" rel="bookmark">
			SD/MMC插口的规范之三：初始化及热插拔检测机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SD卡的技术是基于MultiMedia卡（MMC）格式上发展而来，SD卡与MMC卡保持着向上兼容。SD卡的内部结构主要分两部分：SD控制器和NAND存储器。
SD卡类型总共分成三种：MMC卡，结构类似SD卡，采用MMC协议；SD1.0，SD1.0卡最大支持2Gbyte；SD2.0，SD2.0卡最大容量HCSD可达32Gbyte。从MMC到SD1.0再到SD2.0协议是向上兼容的。即MMC协议的指令可以操作SD1.0,Sd2.0，同理SD1.0协议的命令可以操作sd2.0卡。
（1）硬件引脚封装
SD卡接口：SD卡接口支持SPI模式和SD模式。SD模式采用4线并行模式，作为多媒体存储设备为提高传输速度都会采用这种接口。而SPI更方便低端MCU访问传输速度有限。
（2）SD协议命令格式
我们来了解一下SD卡协议命令的格式，MMC卡只有基本命令，即CMD0-CMD38，当然这中间不是连续。SD卡有基本命令和特定命令，特定命令必须跟在基本命令CMD55后面，即要想用特定命令，必须先发一条CMD55通知SD卡，然后才能发送特定的命令。每条命令由6BYTE组成，分三部分，1字节为操作码，2-5字节为参数，有的命令没有参数，那就填0，有参数的根据参数说明而定，最后一字节为CRC校验，不过SPI模式不需要CRC校验，故可以任意填写，不过有几个特殊命令有指定的CRC校验码，必须加上。每条命令都有响应，根据命令的不同可能有R1，R1B，R2，R3（OCR）寄存器响应，通过它们判断命令是否操作成功。
（3）初始化及读操作、写操作、擦操作
对命令有了解后，只要知道各个操作的过程就可以操作SD卡了，主要操作有初始化、读、写、擦除等，下面分别介绍：
A，初始化：
1，延时至少74clock，等待SD卡内部操作完成，在MMC协议中有明确说明。
2，CS低电平选中SD卡。
3，发送CMD0，需要返回0x01，进入Idle状态。
4，为了区别SD卡是2.0还是1.0，或是MMC卡，这里根据协议向上兼容的原理，首先发送只有SD2.0才有的命令CMD8，如果CMD8返回无错误，则初步判断为2.0卡，进一步发送命令循环发送CMD55+ACMD41，直到返回0x00，确定SD2.0卡初始化成功，进入Ready状态，再发送CMD58命令来判断是HCSD还是SCSD，到此SD2.0卡初始化成功。如果CMD8返回错误则进一步判断为1.0卡还是MMC卡，循环发送CMD55+ACMD41，返回无错误，则为SD1.0卡，到此SD1.0卡初始成功，如果在一定的循环次数下，返回为错误，则进一步发送CMD1进行初始化，如果返回无错误，则确定为MMC卡，如果在一定的次数下，返回为错误，则不能识别该卡，初始结束。
5，CS拉高。
B，读步骤：
1，发送CMD17（单块）或CMD18（多块）读命令，返回0x00。
2，接收数据开始令牌0xfe（或0xfc）+正式数据512Bytes + CRC校验2Bytes，默认正式传输的数据长度是512Bytes，可用CMD16设置块长度。
C，写步骤：
1，发送CMD24（单块）或CMD25（多块）写命令，返回0x00。
2，发送数据开始令牌0xfe（或0xfc）+正式数据512Bytes + CRC校验2Bytes。
D，擦除步骤：
1，发送CMD32，跟一个参数来指定首个要擦除的起始地址（SD手册上说是块号）。
2，发送CMD33,，指定最后的地址。
3，发送CMD38，擦除指定区间的内容。
E，总之，SD卡就是一个存储器，只不过用命令的方式来进行操作，我们只要掌握了各条命令及操作方式，就可以灵活的操作SD卡了。
（4）热插拔检测
SD卡的检测一共有三种方法： 1， 在开机的时候通过CMD发送命令检测T卡是否存在，这种方式不支持热插拔。 2，通过T卡座来检测，信号TCARD_DETECT连在中断控制器上。在没有插卡时，TCARD_DETECT信号为低电平。插入T卡后，信号 TCARD_DETECT 被拉高为高电平，从而产生一个中断。即实现了热插拔。注意：由低到高或者由高到低的触发，是由硬件和软件共同协作，是可以设定的。
3，通过CD/DAT3 信号来检测，CD/DAT3 信号连在中断控制器上，并通过470K电阻下拉，在没有T卡插入时，该信号为低电平，一但有T卡插入，T卡内部通过50Kohm把 DATA3 信号拉高至高电平，随即产生一个中断，实现了热插拔。该PIN脚的说明如下：
具体到实践中，我们会发现DAT3/CD不同的应用场合。有的电路图中CD/DAT3 信号有下拉，有的没有下拉。如果T卡卡座设计在电池下面的话，就没有热插拔的需求，只要在开机的时候检测一下有没有T卡就可以了，这时候 CD/DAT3 信号就不需要下拉电阻了，如图A。当T卡卡座设计在机身外面的时候，就需要支持热插拔了，需要接下拉电阻，如图B。
A， B， 这样就比较清晰。
参考原文：http://blog.csdn.net/cuitianxiang/article/details/5503173
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/157b031d47b325f9c650d01b12cc39cf/" rel="bookmark">
			服务不支持 chkconfig　的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 服务不支持 chkconfig　的解决方法
这两天一直在研究系统服务，在chkconfig --add servername的时候老是提示服务不支持 chkconfig　经过查找，解决办法如下。
示例，auto_run的前三行如下：
#!/bin/sh
#chkconfig: 2345 80 90
#description:auto_run
第一行，告诉系统使用的shell,所以的shell脚本都是这样。
第 二行，chkconfig后面有三个参数2345,80和90告诉chkconfig程序，需要在rc2.d~rc5.d目录下，创建名字为 S80auto_run的文件连接，连接到/etc/rc.d/init.d目录下的的auto_run脚本。第一个字符是S，系统在启动的时候，运行脚 本auto_run，就会添加一个start参数，告诉脚本，现在是启动模式。同时在rc0.d和rc6.d目录下，创建名字为K90auto_run的 文件连接，第一个字符为K，个系统在关闭系统的时候，会运行auto_run，添加一个stop，告诉脚本，现在是关闭模式。
注意上面的三行是中，地二，第三行是必须的，否则在运行chkconfig --add auto_run时，会报错。常见的错误
“服务不支持 chkconfig”：
请注意检查脚本的前面，是否有完整的两行：
#chkconfig: 2345 80 90
#description:auto_run
在脚本前面这两行是不能少的，否则不能chkconfig命令会报错误。
如果运行chkconfig老是报错，如果脚本没有问题，我建议，直接在rc0.d~rc6.d下面创建到脚本的文件连接来解决，原理都是一样的。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2e7774a63eec3ae8cac5d02b948043e/" rel="bookmark">
			Stars （星星）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		poj 2352
题目大意：
解决：树状数组，关键是要将x轴的下标从一开始可以将x都加1
#include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; const int N=32005; int n; int c[N]; int lev[N]; int lowbit(int x) { return x&amp;(-x); } void updata(int pos,int inc) { for(int i=pos;i&lt;N;i+=lowbit(i)) c[i]+=inc; } int getsum(int pos) { int sum=0; for(int i=pos;i;i-=lowbit(i)) sum+=c[i]; return sum; } int main() { int i, a,b; scanf("%d",&amp;n); for(i=0;i&lt;n;i++) { scanf("%d%d",&amp;a,&amp;b); lev[getsum(a+1)]++; updata(a+1,1); } for(i=0;i&lt;n;i++) printf("%d\n",lev[i]); system("pause"); return 0; } 转载于:https://www.cnblogs.com/hpustudent/archive/2011/08/21/2147728.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70188e1b849b73e225097217c0285694/" rel="bookmark">
			Linux路由设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux路由设置
一：使用 route 命令添加
使用route 命令添加的路由，机器重启或者网卡重启后路由就失效了，方法：
//添加到主机的路由
# route add –host 192.168.1.11 dev eth0
# route add –host 192.168.1.12 gw 192.168.1.1
//添加到网络的路由
# route add –net 192.168.1.11 netmask 255.255.255.0 eth0
# route add –net 192.168.1.11 netmask 255.255.255.0 gw 192.168.1.1
# route add –net 192.168.1.0/24 eth1
//添加默认网关
# route add default gw 192.168.2.1
//删除路由
# route del –host 192.168.1.11 dev eth0
二：在linux下设置永久路由的方法：
1.在/etc/rc.local里添加
方法： route add -net 192.168.3.0/24 dev eth0
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70188e1b849b73e225097217c0285694/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aace8794ba49d5e20b62211c30b86735/" rel="bookmark">
			SQL常用函数--转换函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		INSTR： 例子：返回从第二个字符开始、搜索并返回第一个以O开头的罪犯的位置。
SELECT LASTNAME,INSTR(LASTNAME,'O',2,1) FROM CHARACTERS;
输出：
PURVIS 0
TAYLOR 5
CHRISTINE 0
ADAMS 0
COSTALES 2
KONG 2
LENGTH：返回指定字符串的长度。
转换函数
TO_CHAR：将一个数字或日期型转换为字符型。
TO_NUMBER：将一个字符串型数字转换为数值型。
TO_DATE：把一个表示日期的字符串转换成日期。
GREATEST和LEAST：这两个函数将返回几个表达式中最大的和最小的（这两个函数也可以对数字进行处理）。
例子：
SELECT GREATEST('ALPHA','BRAVO','FOXTROT','DELTA') FROM DUAL;
输出：FOXTROT
分析：GREATEST将会返回在字母表中最靠后的字符开头的字符串。
SELECT LEAST(34,567,3,45,1090) FROM DUAL;
输出：3
USER：该函数返回当前使用数据库的用户的名字。
SELECT USER FROM DUAL;
输出：SCOTT
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c24b4e54a0e09aaa646fb03cb2d884f/" rel="bookmark">
			伯克利套接字（BSD Socket）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		伯克利套接字 ----------维基百科，自由的百科全书 伯克利套接字（Berkeley sockets），也称为BSD Socket。伯克利套接字的应用编程接口（API）是采用C语言的进程间通信的库，经常用在计算机网络间的通信。 BSD Socket的应用编程接口已经是网络套接字的事实上的抽象标准。大多数其他程序语言使用一种相似的编程接口。
BSD Socket作为一种API，允许不同主机或者同一个计算机上的不同进程之间的通信。它支持多种I/O设备和驱动，但是具体的实现是依赖操作系统的。这种接口对于TCP/IP是必不可少的，所以是互联网的基础技术之一。它最初是由加州伯克利大学为Unix系统开发出来的。所有现代的操作系统都都实现了伯克利套接字接口，因为它已经是连接互联网的标准接口了。
目录 1 使用伯克利套接字的系统2 头文件3 API函数 3.1 socket()3.2 bind()3.3 listen()3.4 accept()3.5 connect()3.6 gethostbyname() 和 gethostbyaddr() 4 协议和地址5 使用TCP的服务器客户机举例 5.1 服务器5.2 客户机 6 使用UDP的服务器客户机举例 6.1 服务器6.2 客户机 7 参见8 外部链接 使用伯克利套接字的系统 由于伯克利套接字是第一个socket，大多数程序员很熟悉它们，所以大量系统把伯克利套接字作为其主要的网络API。 一个不完整的列表如下：
Windows Sockets (Winsock) ，和Berkeley Sockets很相似，最初是为了便于移植Unix程序。Java SocketsPython sockets 头文件 主要的头文件如下，不同的系统可能具体不同。
&lt;sys/socket.h&gt; BSD socket 核心函数和数据结构。
&lt;netinet/in.h&gt; AF_INET 和AF_INET6 地址家族和他们对应的协议家族 PF_INET 和 PF_INET6。在互联网编程中广泛使用，包括IP地址以及TCP和UDP端口号。
&lt;sys/un.h&gt; PF_UNIX/PF_LOCAL 地址家族。用于运行在一台计算机上的程序间的本地通信，不用在网络中。
&lt;arpa/inet.h&gt; 和IP地址相关的一些函数。
&lt;netdb.h&gt; 把协议名和主机名转化成数字的一些函数。
API函数 这些是伯克利套接字提供的库函数。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c24b4e54a0e09aaa646fb03cb2d884f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0bca823559bb63239a798c1fe5f0d649/" rel="bookmark">
			unicode编码表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自：http://www.cnblogs.com/whiteyun/archive/2010/07/06/1772218.html
unicode编码表
1 unicode编码表 Unicode只有一个字符集，中、日、韩的三种文字占用了Unicode中0x3000到0x9FFF的部分。 Unicode目前普遍采用的是UCS-2,它用两个字节来编码一个字符, 比如汉字"经"的编码是0x7ECF,注意字符编码一般用十六进制来表示,为了与十进制区分,十六进制以0x开头,0x7ECF转换成十进制就是32463,UCS-2用两个字节来编码字符,两个字节就是16位二进制, 2的16次方等于65536,所以UCS-2最多能编码65536个字符。编码从0到127的字符与ASCII编码的字符一样,比如字母"a"的Unicode 编码是0x0061,十进制是97,而"a"的ASCII编码是0x61,十进制也是97,对于汉字的编码,事实上Unicode对汉字支持不怎么好,这也是没办法的,简体和繁体总共有六七万个汉字,而UCS-2最多能表示65536个,才六万多个,所以Unicode只能排除一些几乎不用的汉字,好在常用的简体汉字也不过七千多个,为了能表示所有汉字,Unicode也有UCS-4规范,就是用4个字节来编码字符,不过现在普遍采用的还是UCS-2，只用两个字节来编码,看一下Unicode对汉字的编码: ------------------------------------------------------------------------
2 汉字编码表 U+ 0 1 2 3 4 5 6 7 8 9 A B C D E F ----------------------------------------------------- 4e00 一 丁 丂 七 丄 丅 丆 万 丈 三 上 下 丌 不 与 丏 4e10 丐 丑 丒 专 且 丕 世 丗 丘 丙 业 丛 东 丝 丞 丟 4e20 丠 両 丢 丣 两 严 並 丧 丨 丩 个 丫 丬 中 丮 丯 4e30 丰 丱 串 丳 临 丵 丶 丷 丸 丹 为 主 丼 丽 举 丿 4e40 乀 乁 乂 乃 乄 久 乆 乇 么 义 乊 之 乌 乍 乎 乏 4e50 乐 乑 乒 乓 乔 乕 乖 乗 乘 乙 乚 乛 乜 九 乞 也 4e60 习 乡 乢 乣 乤 乥 书 乧 乨 乩 乪 乫 乬 乭 乮 乯 4e70 买 乱 乲 乳 乴 乵 乶 乷 乸 乹 乺 乻 乼 乽 乾 乿 4e80 亀 亁 亂 亃 亄 亅 了 亇 予 争 亊 事 二 亍 于 亏 4e90 亐 云 互 亓 五 井 亖 亗 亘 亙 亚 些 亜 亝 亞 亟 4ea0 亠 亡 亢 亣 交 亥 亦 产 亨 亩 亪 享 京 亭 亮 亯 4eb0 亰 亱 亲 亳 亴 亵 亶 亷 亸 亹 人 亻 亼 亽 亾 亿 4ec0 什 仁 仂 仃 仄 仅 仆 仇 仈 仉 今 介 仌 仍 从 仏 4ed0 仐 仑 仒 仓 仔 仕 他 仗 付 仙 仚 仛 仜 仝 仞 仟 4ee0 仠 仡 仢 代 令 以 仦 仧 仨 仩 仪 仫 们 仭 仮 仯 4ef0 仰 仱 仲 仳 仴 仵 件 价 仸 仹 仺 任 仼 份 仾 仿 4f00 伀 企 伂 伃 伄 伅 伆 伇 伈 伉 伊 伋 伌 伍 伎 伏 4f10 伐 休 伒 伓 伔 伕 伖 众 优 伙 会 伛 伜 伝 伞 伟 4f20 传 伡 伢 伣 伤 伥 伦 伧 伨 伩 伪 伫 伬 伭 伮 伯 ------------------------------------------------------
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0bca823559bb63239a798c1fe5f0d649/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1607769b64e80f13ed468274b769fe3b/" rel="bookmark">
			在csdn博客首页中插入图片并链接一个网站地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		费了九牛二虎之力才把一张图片插入进去，并且插入该图片的一个链接地址。
插入一个链接地址的代码：&lt;A href="http://xhf123456789plain.blog.163.com/" target=_blank&gt;添加自己要添加的文字&lt;/A&gt;
插入一个站内的（把图片存到站内的相册内）图片：&lt;p&gt;&lt;img src="http://hi.csdn.net/attachment/201108/14/9984847_13133653963Ps4.png" width="204" height="240" longdesc="myphoto" /&gt;&lt;/p&gt;
插入一张站内的图片，并且将图片链接到自己想要的网站的地址：&lt;A href="链接地址" target=_blank&gt;&lt;IMG alt=题目 src="图片地址" width=204 height=140&gt;&lt;/A&gt;
这样就可以在csdn博客的首页上显示自己想要显示的了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bfa7ddab8c32abad3ef3e7a2984c8034/" rel="bookmark">
			textarea文本域宽度和高度（width、height）自动适应变化处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章来源：http://www.cnblogs.com/jice/archive/2011/08/07/2130069.html
&lt;HTML&gt; &lt;HEAD&gt; &lt;TITLE&gt;textarea宽度、高度自动适应处理方法&lt;/TITLE&gt; &lt;!-- 控制宽度的自动适应 --&gt; &lt;style type="text/css"&gt; .comments { width:100%;/*自动适应父布局宽度*/ overflow:auto; word-break:break-all;/*在ie中解决断行问题(防止自动变为在一行显示，主要解决ie兼容问题，ie8中当设宽度为100%时，文本域类容超过一行时，当我们双击文本内容就会自动变为一行显示，所以只能用ie的专有断行属性“word-break或word-wrap”控制其断行)*/ } &lt;/style&gt; &lt;/HEAD&gt; &lt;BODY&gt; &lt;FORM METHOD=POST ACTION= " "&gt; &lt;!-- 主要控制高度的自动适应 --&gt; &lt;!-- 第一个是普通textarea --&gt; &lt;textarea class="comments" rows="10" cols="10"&gt; &lt;/textarea&gt; &lt;!-- 以下两种方式都可以解决textarea行高自动适应类容的高度 --&gt; &lt;textarea class="comments" rows=1 name=s1 cols=27 onpropertychange= "this.style.posHeight=this.scrollHeight "&gt;&lt;/textarea&gt; &lt;textarea class="comments" style="height:expression((this.scrollHeight&gt;150)?'150px':(this.scrollHeight+5)+'px');overflow:auto;"&gt;&lt;/textarea&gt; &lt;/FORM&gt; &lt;/BODY&gt; &lt;/HTML&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d3253a66732bb2d1e325dc5f38ba7a7/" rel="bookmark">
			WTL入门（4）--- 对话框和控件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[源代码下载:http://download.csdn.net/source/3522801]
MFC中，对话框和控件的封装节省了我们大量的时间和成本，否则我们需要编写大量的消息处理来管理各个控件。MFC提供了Dialog Data Exchange（DDX，对话框数据交换，对话框和变量之间的数据传输）的功能。WTL同样支持这些特性，并且在一写公共控件的封装类中做了一些改进。本文用一个给予对话框的程序来展示过去使用的MFC的一些特性，以及WTL的一些消息处理的增强功能，对于高级UI特性和WTL中新增的控件，下章将会讲到。
Refresher on ATL Dialogs ATL有两个对话框类，CDialogImpl 和 CAxDialogImpl，后者用于ActiveX控件，本章暂不涉及。
创建一个对话框必须要做的三件事情：
1）创建对话框资源
2）创建一个派生于CDialogImpl的新类
3）创建一个共有成员的对话框ID
然后，就可像在前几章的框架窗口中一样添加消息处理。
Control Wrapper Classes WTL有用大量的控件封装类，它们的命名和方法与MFC中很像。我们可以使用MFC的相关文档来帮助我们使用WTL。按F12键也可以很方便的转到类和方法的定义处。
内置控件的封装类有：
1）User Controls：CStatic, CButton, CListBox,CComboBox,CEdit,CScrollBar,CDragListBox
2）Common controls：CImageList, CListViewCtrl (CListCtrl in MFC),CTreeViewCtrl (CTreeCtrl in MFC),CHeaderCtrl,CToolBarCtrl,CStatusBarCtrl,CTabCtrl,CToolTipCtrl,CTrackBarCtrl (CSliderCtrl in MFC),CUpDownCtrl (CSpinButtonCtrl in MFC),CProgressBarCtrl,CHotKeyCtrl,CAnimateCtrl,CRichEditCtrl,CReBarCtrl,CComboBoxEx,CDateTimePickerCtrl,CMonthCalendarCtrl,CIPAddressCtrl
3）不在MFC中的公共控件：CPagerCtrl, CFlatScrollBar, CLinkCtrl (可点击的超链接，在XP系统及其之后有效)
4）WTL特有的封装类：CBitmapButton, CCheckListViewCtrl (list view control with check boxes),CTreeViewCtrlEx andCTreeItem (used together,CTreeItem wraps anHTREEITEM),CHyperLink (可点击的超链接，所有操作系统有效)
注意：大部分的封装类是一个窗口类，像CWindow。它们封装一个窗口句柄以及一些消息处理，如CListBox::GetCurSel() 封装了消息LB_GETCURSEL。因此像CWindow一样，我们可以创建为一个已存在控件创建一个临时的控件封装类。同样，当控件封装类析构时，控件本身并不销毁。其中，CBitmapButton,CCheckListViewCtrl, 和CHyperLink除外。
本篇文章是针对有MFC开发经验的人员，因此，不花费大量的时间去讲解这些封装类的细节。
Creating a Dialog-Based App with the AppWizard 创建一个模态对话框，过程略。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d3253a66732bb2d1e325dc5f38ba7a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f260acdd6b7610d84bbf064150b64e81/" rel="bookmark">
			win7图标突然变小了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1. 打开电脑，发现桌面图标突然变小了。
解决：在桌面的空地方处右键--》查看---》中等图标
2.如果发现不仅是图标变小了，文字也变小了，感觉整个系统的框架都变小了
解决：在桌面的空地方处右键---》屏幕分辨率--》放大或缩小文本和其它项目----》会有“较小、中等、较大”的选择 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c86fbf7fa38ed7c54c864526a6ac9db/" rel="bookmark">
			A Simple Problem with Integers（关于整数的问题）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		poj 3468
题目大意：给定Q(1 ≤ Q≤ 100,000)个数A1,A2… AQ,，以及可能多次进行的两个操作:
1)对某个区间Ai … Aj的个数都加n(n可变）2) 求某个区间Ai … Aj的数的和
2) 求某个区间Ai … Aj的数的和
解决：线段树
/* 线段树的区间有两种形式，第一种是[1,2][2,3]，第二种是[1,1],[2,2]，在这里，由于我们查询的区间和是不能相交的，所以只能采用第二中形式， */ #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; typedef long long intt; struct node { int l,r; intt sum,inc; }; #define L(x) (x&lt;&lt;1) #define R(x) ((x&lt;&lt;1)+1) #define M(x,y) ((x+y)&gt;&gt;1) const int N=1000005; node tree[2*N]; int num[N];//保存第i个数的值 /*第二种形式的建树过程*/ void build(int t,int l,int r) { tree[t].l=l; tree[t].r=r; tree[t].inc=0; if(l==r){tree[t].sum=num[l];return;}//判断为叶子节点的话，我们直接通过num中的数据给sum int mid=M(l,r); build(L(t),l,mid); build(R(t),mid+1,r);//建立右子树是为mid+1 tree[t].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c86fbf7fa38ed7c54c864526a6ac9db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/025cf106cc55898f84d60dcb44eb9500/" rel="bookmark">
			Android OnTouchListener触屏事件接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OnTouchListener接口是用来处理手机屏幕事件的监听接口，当为View的范围内触摸按下、抬起或滑动等动作时都会触发该事件。该接口中的监听方法签名如下。 Java代码： public boolean onTouch(View v, MotionEvent event) 参数v：参数v同样为事件源对象。
参数event：参数event为事件封装类的对象，其中封装了触发事件的详细信息，同样包括事件的类型、触发时间等信息。
节中介绍了一个在屏幕中拖动矩形移动的案例，本节将继续采用该案例的思路，通过监听接口的方式实现在屏幕上拖动按钮移动的案例。开发步骤如下。
创建一个名为Sample的Android项目。
准备字符串资源，打开strings.xml文件，用下列代码替换原有代码。
Java代码：
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;!-- XML的版本及编码方式 --&gt; &lt;resources&gt; &lt;string name="hello"&gt;Hello World, Sample&lt;/string&gt; &lt;!--定义hello字符串 --&gt; &lt;string name="app_name"&gt;Sample&lt;/string&gt; &lt;!--定义app_name字符串--&gt; &lt;string name="location"&gt;位置&lt;/string&gt; &lt;!--定义location字符串--&gt; &lt;/resources&gt; 说明：与前面介绍的案例相同，对程序中用到的字符串资源进行定义。
开发布局文件。打开res/layout目录下的main.xml，用下列代码替换其原有代码。
Java代码：
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;!-- XML的版本及编码方式 --&gt; &lt;AbsoluteLayout android:id="@+id/AbsoluteLayout01"
android:layout_width="fill_parent" android:layout_height="fill_parent" xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;!-- XML的版本及编码方式 --&gt; &lt;Button android:layout_y="123dip" android:layout_x="106dip" android:text="@string/location" android:layout_height="wrap_content" android:id="@+id/Button01" android:layout_width="wrap_content"/&gt; &lt;!-- XML的版本及编码方式 --&gt; &lt;/AbsoluteLayout&gt; 说明：该布局文件非常简单，只是在一个绝对布局中添加一个按钮控件即可，需要注意的是应该为该按钮指定ID，以便在Java代码中可以得到该按钮的引用。
接下来开始开发主要的逻辑代码。编写Sample.java文件，其代码如下所示。
Java代码：
package wyf.ytl; //声明所在包 import android.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/025cf106cc55898f84d60dcb44eb9500/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/720e51911dccf3886b5c40cb5d1ad183/" rel="bookmark">
			三棋益智游戏规则
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		三棋益智游戏规则：1.棋盘各线交叉点叫“下棋点”，共二十四个。2.比赛由双人对弈，一方执黑子，另一方执白子。3.比赛分两部分进行，分为下棋部分和走棋部分。4.下棋部分，由黑白双方依次把棋子下到“下棋点”，每一个“下棋点”只能下一个棋子。5.双方要努力争取自己的棋子“成三”并阻止对方“成三”。6.某方所下（走）棋子在横、竖、斜时任一种方式能三子相连，叫“成三”，“成三”可以吃掉对方任一棋子，当在下棋部分时，用已方棋子压在对方棋子上表示，该“下棋点”不能再下其它棋子，当下棋完毕时，两个棋子一起拿走，当在走棋部分时，被吃掉的棋子立即拿走，该“下棋点”可以走其它的棋子。7.如果同时能成两个或以上“成三”，也只算一次“成三”。8.走棋部分由后下棋方先走棋。9.走棋时每次只能选择已方一个棋子，每次只能向旁边的“下棋点”移动一步。10.比赛以最后棋多者或能逼使对方不能继续走动者为胜。 （版权所有，未经许可，严禁用于商业活动，违法必究）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79ecaae2f9050d1fd9e0506b13d47378/" rel="bookmark">
			网络编程：优雅关闭socket/TIME_WAIT/CLOSE_WAIT/SoLinger
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网络编程：优雅关闭socket/TIME_WAIT/CLOSE_WAIT/SoLinger 一个很特别的参数，影响关闭socket后的行为，是立即释放，还是进入TIME_WAIT状态并等 待一段时间（单位：秒）才释放。这个参数，在Socket中可以设置，在Mina2的IoService中也有setSoLinger设置。对于新bs3 框架的Service4Mina2s组件，可以通过以下两种方法设置。 &lt;prop key="m_solinger"&gt;1&lt;/prop&gt;&lt;!-- ={-1 | 0 | nSec}--&gt; &lt;property name="soLinger"&gt;&lt;value&gt;1&lt;/value&gt;&lt;/property&gt;&lt;!--仅仅针对服务器 ={-1 | 0 | nSec}--&gt; 取值：-1表示使用OS缺省参数，0表示立即释放，nSec表示等待n秒后释放。 优雅关闭的几个步骤：1）shutdown(SEND)；2）recv(EOF, 5s)；3) closeSocket()；4) TIME_WAIT 参考：http://hi.baidu.com/xingfengsoft/blog/item/021b03ce872e0430b700c89d.html 【转自文静】减少Linux服务器过多的TIME_WAIT (2009/08/24 22:45) TIME_WAIT状态的意义： 客户端与服务器端建立TCP/IP连接后关闭SOCKET后，服务器端连接的端口状态为TIME_WAIT 是不是所有执行主动关闭的socket都会进入TIME_WAIT状态呢？ 有没有什么情况使主动关闭的socket直接进入CLOSED状态呢？ 主动关闭的一方在发送最后一个 ack 后，就会进入 TIME_WAIT 状态 停留2MSL（max segment lifetime）时间，这个是TCP/IP必不可少的，也就是“解决”不了的。 也就是TCP/IP设计者本来是这么设计的 主要有两个原因 1。防止上一次连接中的包，迷路后重新出现，影响新连接（经过2MSL，上一次连接中所有的重复包都会消失） 2。可靠的关闭TCP连接。在主动关闭方发送的最后一个 ack(fin) ，有可能丢失，这时被动方会重新发 fin, 如果这时主动方处于 CLOSED 状态 ，就会响应 rst 而不是 ack。所以主动方要处于 TIME_WAIT 状态，而不能是 CLOSED 。 TIME_WAIT 并不会占用很大资源的，除非受到攻击。 在Squid服务器中可输入如下命令: #netstat -n | awk '/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}' LAST_ACK 14 SYN_RECV 348 ESTABLISHED 70 FIN_WAIT1 229 FIN_WAIT2 30 CLOSING 33 TIME_WAIT 18122 状态：描述 CLOSED：无连接是活动的或正在进行 LISTEN：服务器在等待进入呼叫 SYN_RECV：一个连接请求已经到达，等待确认 SYN_SENT：应用已经开始，打开一个连接 ESTABLISHED：正常数据传输状态 FIN_WAIT1：应用说它已经完成 FIN_WAIT2：另一边已同意释放 ITMED_WAIT：等待所有分组死掉 CLOSING：两边同时尝试关闭 TIME_WAIT：另一边已初始化一个释放 LAST_ACK：等待所有分组死掉 也就是说，这条命令可以把当前系统的网络连接状态分类汇总。 下面解释一下为啥要这样写： 一个简单的管道符连接了netstat和awk命令。 —————————————————————— 先来看看netstat： netstat -n Active Internet connections (w/o servers) Proto Recv-Q Send-Q Local Address Foreign Address State tcp 0 0 123.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/79ecaae2f9050d1fd9e0506b13d47378/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f0d0d78bf632dde537efbfba5ab51e5/" rel="bookmark">
			PHP 转义与反转义函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 php向mysql数据库插入数据进行转义包括两方面的操作，第一方面需要在添加数据时通过数据转义将数据写入库中，第二方面在将数据显示在页面时需要再次将数据恢复为原始状态，即反转义。
一、数据转义 mysql_escape_string($content)二、反转义 stripslashes($content)以上两行代码即可实现php向mysql数据库插入数据转义操作。
get_magic_quotes_gpc()
在PHP中get_magic_quotes_gpc()函数是内置的函数，这个函数的作用就是得到php.ini设置中magic_quotes_gpc选项的值。
那么就先说一下magic_quotes_gpc选项：
如果magic_quotes_gpc=On，PHP解析器就会自动为post、get、cookie过来的数据增加转义字符“\”，以确保这些数据不会引起程序，特别是数据库语句因为特殊字符引起的污染而出现致命的错误。
在magic_quotes_gpc=On的情况下，如果输入的数据有
单引号（’）、双引号（”）、反斜线（\）与 NUL（NULL 字符）等字符都会被加上反斜线。这些转义是必须的，如果这个选项为off，那么我们就必须调用addslashes这个函数来为字符串增加转义。
正是因为这个选项必须为On，但是又让用户进行配置的矛盾，在PHP6中删除了这个选项，一切的编程都需要在 magic_quotes_gpc=Off下进行了。在这样的环境下如果不对用户的数据进行转义，后果不仅仅是程序错误而已了。同样的会引起数据库被注入攻击的危险。所以从现在开始大家都不要再依赖这个设置为On了，以免有一天你的服务器需要更新到PHP6而导致你的程序不能正常工作。
当magic_quotes_gpc=On的时候，函数get_magic_quotes_gpc()就会返回1
当magic_quotes_gpc=Off的时候，函数get_magic_quotes_gpc()就会返回0
因此可以看出这个get_magic_quotes_gpc()函数的作用就是得到环境变量magic_quotes_gpc的值。既然在PHP6中删除了magic_quotes_gpc这个选项，那么在PHP6中这个函数我想也已经不复存在了。
addslashes()
addslashes() 函数在指定的预定义字符前添加反斜杠。
这些预定义字符是：
* 单引号 (')
* 双引号 (")
* 反斜杠 (\)
* NULL
语法
addslashes(string)
StripSlashes()
去掉反斜线字符。
语法: string stripslashes(string str);
返回值: 字符串
函数种类: 资料处理
本函数可去掉字符串中的反斜线字符。若是连续二个反斜线，则去掉一个，留下一个。若只有一个反斜线，就直接去掉。
如果不知道有没有设置可以这样做：
function stringFilter($str){ if (!empty($str)) { if (ini_set('magic_quotes_gpc')) { return $str; }else{ return addslashes($str); } }else{ return false; } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76dd0e4202448fc27a81ce0812a158eb/" rel="bookmark">
			VI/VIM常用命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写道 Vi是“Visual interface”的简称，它在Linux上的地位就仿佛Edit程序在Dos上一样。它可以执行输出、删除、查找、替换、块操作等众多文本操作，而且用户可以根据自己的需要对其进行定制，这是其他编辑程序所没有的。 Vi不是一个排版程序，它不象Word或WPS那样可以对字体、格式、段落等其他属性进行编排，它只是一个文本编辑程序。 Vi没有菜单，只有命令，且命令繁多。Vi有三种基本工作模式：命令行模式、文本输入模式和末行模式。 命令行模式 （command mode/一般模式） 任何时候，不管用户处于何种模式，只要按一下键，即可使Vi进入命令行模式；我们在shell环境（提示符为$）下输入启动Vi命令，进入编辑器时，也是处于该模式下。 在该模式下，用户可以输入各种合法的Vi命令，用于管理自己的文档。此时从键盘上输入的任何字符都被当做编辑命令来解释，若输入的字符是合法的Vi命令，则Vi在接受用户命令之后完成相应的动作。但需注意的是，所输入的命令并不在屏幕上显示出来。若输入的字符不是Vi的合法命令，Vi会响铃报警。 文本输入模式 （input mode/编辑模式） 在命令模式下输入插入命令i、附加命令a 、打开命令o、修改命令c、取代命令r或替换命令s都可以进入文本输入模式。在该模式下，用户输入的任何字符都被Vi当做文件内容保存起来，并将其显示在屏幕上。在文本输入过程中，若想回到命令模式下，按键即可。 末行模式 （last line mode/指令列命令模式） 末行模式也称ex转义模式。 Vi和Ex编辑器的功能是相同的，二者主要区别是用户界面。在Vi中，命令通常是单个键，例如i、a、o等；而在Ex中，命令是以按回车键结束的正文行。Vi有一个专门的“转义”命令，可访问很多面向行的Ex命令。在命令模式下，用户按“:”键即可进入末行模式下，此时Vi会在显示窗口的最后一行（通常也是屏幕的最后一行）显示一个“:”作为末行模式的提示符，等待用户输入命令。多数文件管理命令都是在此模式下执行的（如把编辑缓冲区的内容写到文件中等）。末行命令执行完后，Vi自动回到命令模式。 一、由一般模式转到输入模式的命令 1〉光标移动命令 0 移动到光标所在列的最前面[Home] $ 移动到光标所在列的最後面[End] [CTRL][d] 向下半页 [CTRL][f] 向下一页[PageDown] [CTRL][u] 向上半页 [CTRL][b] 向上一页[PageUp] H移动到视窗的第一列 M移动到视窗的中间列 L移动到视窗的最后列 G移动到文件最后列 nG直接用数字 n 加上大写 G 移动到第 n 行 （等同于命令“：n”） fx往右移动到 x 字符上 tx往右移动到 x 字符前 shift +g 跳到文件尾 (等同于G) gg 跳到文件头 xp 交换两个字符位置 ddp 上下两行调换 [ 移到文件开始位置 ] 移到文件结束位置 nk向上移n行 n↑向上移n行 n-向上移n行，光标在该行的起始 ni 向下移n行 n+向下移n行，光标在该行的起始 n↓向下移动n行 w 向前移动一个word nw 向前移动n个word → 向右移动一个字符【l】 ← 向左移动一个字符【h】 ↑ 向上移动一行【k】 ↓ 向下移动一行【j】 2〉删除操作命令 x 删除光标所在的字符【delete】 dw 删除光标所在的单词 d $ 删除光标至行尾的所有字符 /d d 同/d d $ dd 删除当前行 dnd 删除当前n行 dG 删除当前行到最后一行 可在删除命令前加上数字，如&lt;5x表示删除5行。 3〉改变与替换操作命令 r 替换光标所在的字符 /rr 替换字符序列 c $ 替换自光标位置至行尾的所有字符 cl 修改当前字符 cc 修改当前行 c$ 修改到行尾的内容 :%s#abc#123#g 将文中的所有abc都替换为123 ddp 上下两行交换（其实是先dd，然后执行p） 4〉查询命令 /string 往前搜索string【支持正则】 n 查找下一个 ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/76dd0e4202448fc27a81ce0812a158eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/812edfde97f5f4e44114bd835dd1f8c9/" rel="bookmark">
			linux 命令参数列表过长
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、在一个目录下删除大批量的文件时，当使用 rm -rf 或者rm *会提示参数列表过长
通过修改命令为 :find . -name "*" | xargs rm -rf '*'，成功删除
2、需要把一个目录下的所有文件mv到另外一个目录，如果当前目录文件特别多，简单使用mv 源目录 目的目录会提示参数列表过长
通过修改命令为 :ls | xargs -t -I {} mv {} ../matchres/ 可以把当前目录下的所有文件移到 "../matchres"下
3、另外cp 命令也会存在这种情况，解决办法跟 mv的一样。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29b2a75f591ee8a38767b7e659779e7d/" rel="bookmark">
			IE被www.537.com,www.COXDX.INFO劫持，修复~
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一位同事的电脑中IE一直使用265网址导航作首页，这天忽然变成hxxp://www.COXDX.INFO/?z012了，修改不回来，请我帮忙检修。
打开Internet选项，手动修改首页为http://www.265.com/，但总不能生效。将该电脑中的360杀毒软件的实时监控禁用，下载安装金山卫士检修，没有检查出问题。
使用pe_xscan扫描日志并分析，发现如下可疑项：
pe_xscan 11-03-17 by Purple Endurer
2011-6-30 11:35:23
Windows XP Service Pack 3(5.1.2600)
MSIE:6.0.2900.5512
管理员用户组
正常模式
O2 - IeAddOn(PPLive Lite Class) - {EF0D1A14-1033-41A2-A589-240C01EDC078}
= C:\Program Files\Internet Explorer\PPLite\plugin\pplugin2.dll | 2011-6-9 11:14:36 | pplugin Module | 1, 1, 0, 24 | pplugin Module | Copyright 2008 | 1, 1, 0, 24 | | | pplugin | pplugin.DLL
O4 - HKLM\..\run: [duoduobox] C:\Program Files\duoduobox\duoduotray.exe
O9 - IE工具栏扩展按钮HKLM： - {8EF13CF9-5B58-4125-BB67-F6C9C3DE1E72} - C:\Program Files\Baidu\banlv\inside.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29b2a75f591ee8a38767b7e659779e7d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da6b93500c664adef4172567ba8e9339/" rel="bookmark">
			个人学习,运维架构图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/865b93fcdeeae127e1c1ec6ba286689b/" rel="bookmark">
			web应用的表单查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在开发web应用程序中，表单查询是一个非常常见的功能，但是需求五花八门，各种各样，更重要的是，后端的SQL/hql要根据页面的输入动态变化。常常形成一个庞大的拼sql的方法，并且各个方法都不一样，为开发，维护带来了不少困难。本人在总结了常用需求的基础上，再结合SSH，想出一个比较通用的方案，以此抛砖引玉。
实现的思路是这样的，根据页面输入，自动将页面输入转化成一组查询条件，数据访问层再根据这些查询条件自动组装SQL/hql。这个是查询条件类。
import java.io.Serializable; /** * 表单上的查询条件封装类 * 封装表单的查询条件 * * @auther: XXX * Date: 11-4-22 * Time: 下午2:16 * @version: 1.0 */ public class QueryCondition implements Serializable { /** * 查询主实体名称 */ private String enityName; /** * 实体对应的属性名称 */ private String propertyName; /** * 实体对应的属性类型 */ private String propertyType; /** * 查询关系符号 */ private Operator operator; /** * like查询时候的匹配模式 */ private MatchMode matchMode; /** * 条件的值 */ private String value; /** * 输入的第二个值 */ private String value2; /** * 多个值 */ private String[] multipleValue; public MatchMode getMatchMode() { return matchMode; } public void setMatchMode(MatchMode matchMode) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/865b93fcdeeae127e1c1ec6ba286689b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41244a3a691daccf24c2fda7d6fb3f70/" rel="bookmark">
			利用后缀树求多个字符串的最长公共连续子串(Longest Common Substring)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：
有N个字符串，计算它们公共的最长连续子串。例如，字符串集合{abcd,bcca,aabc}，它们公共的最长连续子串是bc。又如{abcfd，bcabca，aabcf}的公共的最长连续子串是abc。
针对本问题，可以用特殊的字符（该字符必须是N个串中没有出现的字符）将N个字符串连起来形成一个新串，然后构建这个新串的后缀树。比如对字符串集合 {abcd,bcca,aabc}，可以连成新串abcd$bcca@aabc%，其中子串之间的分隔符为 '$','@','%'。满足条件的最长子串就是最深的分叉结点，而且该分叉结点下面的后缀的suffix（注意是后缀的后缀！）包含了这三个分隔字符：即至少有一个后缀的suffix为xxx$.....，至少有一个后缀的suffix为yyy@....（这里字符串yyy中没有字符$），至少有一个后缀的suffix为zzz%...（其中字符串zzz中没有$和@字符）。以下代码中，判断分隔字符是否在子树中的函数为 containTerminators（）。
利用这种方式生成的后缀树有一个特点：带终结字符的结点都是叶子结点，不可能为内部结点，这一点跟前缀树和不带分隔符的单个子串后缀树是不同的（类似于Ukkonen构造法中末尾添加一个特殊字符将隐式后缀树自动转换成真正的后缀树）。利用这个特点，只需要考虑：非叶子结点的情况，因为满足条件的分叉结点不会是叶子结点。
在下面的实现中，首先采用蛮力法insert()构造后缀树；然后调用findLCS()查找最长公共子串。只需要考虑非叶子结点(child.terminal = false)。findLCS函数返回的是currNode的子树中满足条件的LCS。
实现：
import java.util.LinkedList;import java.util.List;/*** * Find LCS(Longest Common Substring) of N strings (N&gt;=2)* * Copyright (c) 2011 ljs (http://blog.csdn.net/ljsspace/)* Licensed under GPL (http://www.opensource.org/licenses/gpl-license.php) * * @author ljs* 2011-06-29**/public class LCS {private class SuffixNode {	private String key;private List&lt;SuffixNode&gt; children = new LinkedList&lt;SuffixNode&gt;();//use "#" for terminal charprivate boolean terminal; public SuffixNode(){	this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/41244a3a691daccf24c2fda7d6fb3f70/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/795b096aa0a908deac0e34fda6a93058/" rel="bookmark">
			增量备份和累积备份包括0,1,2,3,4,5五个备份级别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		10g,仍然保留了这五种备份级别，但将来的版本会逐步淘汰2，3，4三个级别。其中，级别0相当于完全备份，会备份数据文件的所有已用数据块，而其它级别只会备份相应级别最近一次备份以来变化的数据块。增量级别的数据字值越大，备份的数据块相对越少。当制定备份策略时，如果要采用增量备份和累积备份，则必须首先进行增量0级备份。
增量备份：增加备份是指备份更低级别和相同级别最近一次备份以来变化的数据块，增量备份的基础是增量0级备份。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec85c20aa531c60a42b58b4402704842/" rel="bookmark">
			关于音乐播放器中歌词同步显示的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		做项目，用到显示歌词，现在一般听歌MP3是最普遍的，歌词文件就是对应的lrc文件，有的MP3文件包含歌词，但说实话还真没碰到，我就是在播放MP3文件时收索对应的lrc文件，然后把歌词读出来，分离处时间标签和歌词，根据时间标签来显示歌词，我用到的directshow接口播放的音视频，能够获得当前进度，转化成秒和时间标签对比，如果相等就把那行歌词显示出来，读取歌词是按行读取的，歌词文件和MP3文件放在一个目录下，当播放某个MP3文件时，只需把MP3文件的后缀换成lrc，找到歌词文件就读取，其中要注意歌词文件名要和MP3文件同名才行，读取lrc就要按lrc文件的标准读取，其中涉及时间标签补偿，空行等细节，读取要考虑很多，有空会说一下，具体怎样读取显示。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/570/">«</a>
	<span class="pagination__item pagination__item--current">571/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/572/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>