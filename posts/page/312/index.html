<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78947de5ea5ac4c02ed4d6ce71fb66e4/" rel="bookmark">
			一文解决JAVA并发安全问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目场景： 并发的应用场景，在开发过程会经常遇到。 例如：服务应用启动后，需要简单统计接口的总访问量；实时更新订单状态，成交总额。
问题描述： 比如统计接口访问次数，如下的实现，在并发访问下，统计是不准确的 。
private int viewCount = 0; private void addViewCount(){ viewCount++; } 复制代码 比如A、B两个线程同时访问，各自从JVM主存中加载变量viewCount到线程内存里viewCount的值都是0，各自+1，更新会JVM主存的也是1。实际A、B执行完毕后，JVM的值应该是2才对。
解决方案： 并发问题解决，实际有2种方式：有锁、无锁。 有锁的就是关键字synchronized，以及可重入锁ReentrantLock。 无锁的，就是局部变量、不可变对象、CAS原子类、ThreadLocal，共四种。
具体解决方案分析： 一.无锁方式 1.局部变量 /** * 局部变量，多线程更新count的时候，各自在线程内存中创建i变量。 */ public void localParam(){ int count = 0; /*本次处理业务，统计*/ count++; System.out.println(count); } 复制代码 2.不可变对象 车辆位置实时更新，传统的setY,setY，在并发过程会出差错。定义一个final localtion类，并且构造函数直接初始化x,y。
/** * 车辆位置经纬度值 */ public final class Location { private final double x; private final double y; public Location(double x, double y) { this.x = x; this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/78947de5ea5ac4c02ed4d6ce71fb66e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4be93af7c54cba9752a4910bbf66eb78/" rel="bookmark">
			织梦漏洞复现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、影响版本 DeDeCMSV5.7SP2 正式版(2018-01-09)DeDeCMS 前台任意用户密码修改漏洞 2、复现环境 PHP 5.6 DeDeCMSV5.7SP2 正式版(2018-01-09) 2 复现过程及结果 ①建立好网站，安装好DeDeCMS并注册好一个账号
②查看好MID，test的mid=2
③利用抓包软件抓到key
④key就是临时验证码，利用临时验证码即可修改密码，复现完成
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f872648fe64e7abd4b1fcbdff78a9b73/" rel="bookmark">
			音视频入门系列-服务器篇（nginx-rtmp 的部署）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇文章，我们详细介绍下使用nginx-rtmp来部署一套流媒体服务器，并用FFmpeg来推流，VLC来拉流。
RTMP是Real Time Messaging Protocol（实时消息传输协议）的首字母缩写。该协议基于TCP，是一个协议族，包括RTMP基本协议及RTMPT/RTMPS/RTMPE等多种变种。RTMP是一种设计用来进行实时数据通信的网络协议，主要用来在Flash/AIR平台和支持RTMP协议的流媒体/交互服务器之间进行音视频和数据通信。支持该协议的软件包括Adobe Media Server/Ultrant Media Server/red5等。RTMP与HTTP一样，都属于TCP/IP四层模型的应用层。
1.下载nginx 和 nginx-rtmp-module
https://nginx.org/en/download.html https://github.com/arut/nginx-rtmp-module.git 2.解压压缩包
$tar xvf nginx-1.20.1.tar.gz $unzip nginx-rtmp-module-master.zip 3.创建build目录
$cd nginx-1.20.1 $mkdir build 4.config &amp; make &amp; make install
$./configure --prefix=/home/fly/work/nginx-rtmp/nginx-1.20.1/build --add-module=/home/fly/work/nginx-rtmp/nginx-rtmp-module-master $make $make install 5.config过程中错误及错误处理
error : ./configure: error: the HTTP rewrite module requires the PCRE library. error :./configure: error: SSL modules require the OpenSSL library. error :./configure: error: the HTTP gzip module requires the zlib library.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f872648fe64e7abd4b1fcbdff78a9b73/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17f0958c2cf9bc259676de768a53435c/" rel="bookmark">
			音视频入门系列-服务器篇（介绍）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		“音视频入门系列-服务器”系列，主要介绍下目前常用的流媒体服务器，并实际部署下部分服务器，和小伙伴们一起感受下流媒体服务器是如何工作的。
市面上优秀的流媒体服务器解决方案有很多，比如SRS，Red5，EasyDarwin，nginx-rtmp，live555，mediasoup等等。
这些服务器框架各有优缺点，但你需要明白的是，世上没有一款完美的流媒体服务器解决方案，在流媒体选型的时候，需要根据自己的业务选择适合的流媒体服务器。
音视频入门系列文章已同步在微信公众号（可扫下方二维码关注）：八小时码字员
音视频入门系列，同步录制了学习视频，已上传至bilibili（八小时码字员）：音视频入门系列（图像、音频、字幕、视频封装格式，FFmpeg、ffplay源码分析，解码、编码、转码，流媒体协议，服务器部署）_哔哩哔哩_bilibili
音视频学习交流QQ群：693316541
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d1dd4ca412e2253c05c1f9fa84ea162/" rel="bookmark">
			堆的特殊实现（向下调整算法）及排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
什么是堆
向下调整算法
如何实现
实现代码
不是特殊情况下的实现
实现代码
完整代码
堆排序
实现代码
什么是堆 堆是数据结构中的一种完全二叉树，其性质：堆中某个节点的值总是不大于（大堆）或不小于（小堆）其父节点的值 如下示例
向下调整算法 （前提）左右子树都是小堆才能实现
例如下面给出的数组 int a[] = {27,15,19,18,28,34,65,49,25,37};
逻辑上看做一颗完全二叉树
父(根)节点和孩子(叶)节点的下标关系
如何实现 向下调整算法的实现
1、选出左右孩子中小的那一个（15）
2、小的这个孩子跟父亲比
a、如果小的孩子比父亲小，则跟父亲交换，并且把原来孩子的位置当成父亲继续往下调整。直到p走到叶子节点
b、如果小的孩子比父亲大，则不需要处理，调整完成，整个树已经是小堆
实现代码 #include&lt;stdio.h&gt; void Swap(int* p1, int* p2) { int tmp = *p1; *p1 = *p2; *p2 = tmp; } void AdjustDownward(int*a ,int n, int parent) { int child = parent * 2 + 1; //比较两个(左右)孩子的大小 while (child &lt; n)//在数组下标范围内比较 { //选出左右孩子较小的那个【建小堆】{建大堆选出大的那个} if (child+1 &lt; n &amp;&amp; a[child+1] &lt; a[child])//假如没有右孩子chile可能越界 { child++;//右孩子比左孩子小 ++child加到右孩子下标 } //parent和较小的孩子交换 //较小的孩子比父亲小交换，比父亲大跳出（此时已经是小堆） //【建小堆】 if (a[child] &lt; a[parent]) { Swap(&amp;a[child], &amp;a[parent]); parent = child; child = parent * 2 + 1; } else { break; } } } int main() { int a[] = { 27,15,19,18,28,34,65,49,25,37 }; int n = sizeof(a) / sizeof(a[0]); AdjustDownward(a,n,0); return 0; } 不是特殊情况下的实现 既左右子树都不是小堆
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d1dd4ca412e2253c05c1f9fa84ea162/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7db14c6ed9e247a04c81341bca44dfa0/" rel="bookmark">
			用 Flutter 仿写微信“发现 &#43; 我”的页面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		↓推荐关注↓
发现页面实现
这里我们仿照微信的发现页面用 Flutter 类实现这页面的简单布局及每个 cell 的点击效果及点击每条 cell 之后跳转到一个新的页面。这里我们分几步分别来实现这些功能。
自定义 cell 针对 cell 的布局我们可以分为两部分，左边跟右边，左边是主图片加标题，右边是子标题、 子图片加箭头。主图片名称、主标题、子标题、子图片名称这些都可以由于 cell 初始化的时候由外部传进来。这里主图片、标题跟箭头是固定的每个 cell 都有的，子标题、 子图片是可选的。针对 cell 布局的代码如下。
String title; String imageName; String subTitle; String subImageName; DiscoverCell(this.title, this.imageName, this.subTitle, this.subImageName); Container( color: _currentColor, height: 55, child: Row( mainAxisAlignment: MainAxisAlignment.spaceBetween, children: [ // left Container( padding: EdgeInsets.all(10), child: Row( children: [ // 图标 Image(image: AssetImage(widget.imageName), width: 20,), // 间隙 SizedBox(width: 15,), // Title Text(widget.title), ], ), ), // right Container( padding: EdgeInsets.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7db14c6ed9e247a04c81341bca44dfa0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92082b105824913e769459f5ee306b4b/" rel="bookmark">
			解决“图片因为CSS样式缩放导致变糊问题”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 对于图片的放大缩小，我们都会自然而然的认为：图片放大，会变得模糊，图片变小会变得较为清晰。放大，会把瑕疵更明显的暴露出来；缩小，可以让瑕疵难以发觉。这是生活中的自然现象。但是，这个现象放到网页上的图片就“变了味”。
变成什么“味”了呢？
通过CSS样式对图片做等比例的放大缩小操作，图片都会变模糊，和通过滚轮对图片做放大缩小操作差异很大。
问题演示 假设有这样一张图：
通过win11的“图片”软件对其放大缩小。
通过编写HTML将三者在浏览器中显示。
代码：
&lt;div style="text-align: center"&gt; &lt;img src="/image_600px.png" /&gt; &lt;img src="/image.png" /&gt; &lt;img src="/image_300px.png" /&gt; &lt;/div&gt; 结果如下：
接下来，通过CSS样式调整中间原图的大小。
可以看到，无论是放大还是缩小，中间的原图都变模糊了。从这里我们可以推断出，在浏览器通过CSS的样式对图片做放大缩小操作是不同于专门的图片处理软件的。其效果远不如专门的图片软件处理结果好。
但是在网页上使用图片时是无法避免CSS样式对图片进行放大缩小的（我们总不能为每个尺寸都设置相应的图片吧！）。对于这个问题，前端可以通过CSS样式属性image-rendering来优化。
前端的优化方法 —— image-rendering 在网页上通过CSS样式对图片进行缩放从而导致图片模糊，究其原因是因为浏览器的缩放算法和图片处理软件的不同导致的差异。所以，要解决这个问题，就需要优化浏览器的缩放算法。CSS属性image-rendering正是为此而存在的。
image-rendering CSS 属性 image-rendering 用于设置图像缩放算法。它适用于元素本身，适用于元素其他属性中的图像，也应用于子元素。
举个例子，如果有一张尺寸为 100×100px 的图片，但作者有意将尺寸设置为 200×200px（或50×50px），然后，图片便会根据 image-rendering 指定的算法，缩小或放大到新尺寸。此属性对于未缩放的图像没有影响。
截取自——《MDN——image-rendering》
image-rendering可选属性值如下表：
属性值说明auto自 Gecko 1.9 （Firefox 3.0）起，Gecko 使用双线性（bilinear）算法进行重新采样（高质量）。crisp-edges必须使用可有效保留对比度和图像中的边缘的算法来对图像进行缩放，并且，该算法既不会平滑颜色，又不会在处理过程中为图像引入模糊。合适的算法包括最近邻居（nearest-neighbor）算法和其他非平滑缩放算法，比如 2×SaI 和 hqx-* 系列算法。此属性值适用于像素艺术作品，例如一些网页游戏中的图像。pixelated放大图像时, 使用最近邻居算法，因此，图像看着像是由大块像素组成的。缩小图像时，算法与 auto 相同。 auto是浏览器默认的缩放算法；放大图像时，crisp-edges的效果和auto一致，缩小时，crisp-edges的效果比auto更好；如果设置了pixelated，无论放大还是缩小图像，看起来都比auto更明亮了，只不过锯齿也高了。
设置crisp-edges的效果图：
设置 pixelated的效果图：
crisp-edges属性说明：
大多数浏览器不再支持image-rendering: crisp-edges;这种写法了。需要通过非标准写法来实现设置，兼容性写法如下：
.crisp-edges { image-rendering: -moz-crisp-edges; image-rendering: -o-crisp-edges; image-rendering: -webkit-optimize-contrast; image-rendering: crisp-edges; -ms-interpolation-mode: nearest-neighbor; } image-rendering兼容性问题：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/92082b105824913e769459f5ee306b4b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/203db4563fb13f518d649d3bfd77648c/" rel="bookmark">
			了解什么是BFS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第十三讲 BFS DFS复习 DFS深度优先搜索，是将问题抽象成一种树结构，带着目的性的进行搜索，一路走到底，直到达到目标。深度优先搜索借助递归来实现，递归下去，回溯上来，如果没有走到底就发现下面的元素都无法满足题目要求时，则停止对该路的搜索。
DFS遍历步骤（图示） 从根节点1开始搜索 找出与此点邻接的且尚未遍历的点
遍历完所有节点后，将栈中元素弹出，DFS完成
例题 面积计算（深搜）
分析：因为是要求闭合*围成的曲线，第一步把四周的0，以及该0的四周的0变成*号，之后再枚举0的个数即可。
#include&lt;iostream&gt; #include&lt;cstring&gt; using namespace std; char a[55][55]; int dx[]={0,-1,1,0},dy[]={1,0,0,-1};//搜索上下左右，可以少写几个if int len=0; void dfs(int x,int y){//参数为 为'0' 点的横纵坐标 a[x][y]='*'; for(int i=0;i&lt;4;i++){ if(a[x+dx[i]][y+dy[i]]=='0') dfs(x+dx[i],y+dy[i]); } return; } int main(){ cin&gt;&gt;a[0]; int m=1; int len=strlen(a[0]); while(cin&gt;&gt;a[m]) ++m; for(int i=0;i&lt;m;i++){//从边界开始搜索，将外围的染黑 if(a[i][0]=='0') dfs(i,0); if(a[i][len-1]=='0') dfs(i,len-1); } for(int i=0;i&lt;len;i++){ if(a[0][i]=='0') dfs(0,i); if(a[m-1][i]=='0') dfs(m-1,i); } int sum=0; for(int i=0;i&lt;m;i++) for(int j=0;j&lt;len;j++) if(a[i][j]=='0') sum++; cout&lt;&lt;sum; } BFS BFS与DFS的区别与联系 BFS和DFS都属于优先搜索算法，BFS又称宽度优先搜索，它们的主要区别在于搜索方式不同，DFS是一个劲往下搜索并带有目的性的搜索，当不满足条件时就回溯，而BFS是一层一层的遍历。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/203db4563fb13f518d649d3bfd77648c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c17b7008caee591e557e22b36f23440/" rel="bookmark">
			推荐系统（十八）推荐系统中的MMOE
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		契机 多任务学习一开始比较流行的模型是share-bottom模型，即不同的任务共享一份底层特征（如下图所示），这样做能够令不同任务之间共享信息，但如果任务之间相关度不高，不同塔相似度较低，这样做的效果就会大打折扣。MMOE模型能通过gates和experts的配合来解决上述问题。
模型结构 MMOE结构是由MOE衍化而来的，因而下文会先讲解MOE，然后再具体解释MMOE的工作原理。
MOE MOE的全称为Mixture of Experts，其底层由一个长度为N的gate向量 G ( x ) G(x) G(x)和N个expert向量 E i ( x ) E_i(x) Ei​(x)组成，运行流程如下：
每个expert共享底层输入 x x x，其中第 i i i个expert经过若干全连接层后得到对应的 E i ( x ) E_i(x) Ei​(x) E i ( x ) E_i(x) Ei​(x)与gate向量的第 i i i维向量相乘得到加权输出 G ( x ) i ∗ E i ( x ) G(x)_i * E_i(x) G(x)i​∗Ei​(x)将所有的加权输出相加得到最终的输出， y = ∑ i N G ( x ) i ∗ E i ( x ) y=\sum_i^N G(x)_i * E_i(x) y=∑iN​G(x)i​∗Ei​(x)将 y y y输入到指定塔，经过若干全连接层后得到塔的最终输出。 这里需要注意的是，某一个 x x x计算的结果只会输出到某一个塔上（例如towerA），且不同的 x x x会对应不同的 G ( x ) G(x) G(x)和 E ( x ) E(x) E(x)。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c17b7008caee591e557e22b36f23440/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a7eb2cb0649565a6eb3facc5235af0d/" rel="bookmark">
			Hadoop免密登录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、在每个节点生成公钥和私钥，并将公钥拷贝到其他两个目标机器 Hadoop100生成公钥和私钥 ssh-keygen -t rsa 按三次回车 将Hadoop100的公钥拷贝到其他两个目标机器上 ssh-copy-id hadoop100 回车然后输入密码 ssh-copy-id hadoop101 回车然后输入密码 ssh-copy-id hadoop102 回车然后输入密码 Hadoop101生成公钥和私钥 ssh-keygen -t rsa 按三次回车 将Hadoop101的公钥拷贝到其他两个目标机器上 ssh-copy-id hadoop100 回车然后输入密码 ssh-copy-id hadoop101 回车然后输入密码 ssh-copy-id hadoop102 回车然后输入密码 Hadoop102生成公钥和私钥 ssh-keygen -t rsa 按三次回车 将Hadoop102的公钥拷贝到其他两个目标机器上 ssh-copy-id hadoop100 回车然后输入密码 ssh-copy-id hadoop101 回车然后输入密码 ssh-copy-id hadoop102 回车然后输入密码 2、Hadoop100免密登录Hadoop101 ssh+主机名 登录Hadoop102也是如此，到此免密登录就完成了。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1fe72b2bc8a22012b3dcc4e1febb53fc/" rel="bookmark">
			【离散数学】命题逻辑 带你快速学完离散数学
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 逻辑与证明 文章目录 逻辑与证明1.1命题逻辑命题否命题：非合取命题：且析取命题：或异或：蕴涵：双蕴涵：逻辑运算符的优先级： 1.1命题逻辑 命题 定义1：一个命题就是一条陈述句。
​ 要么针、要么假，不能既真又假。
定义2：命题的真假叫做命题的真值。
​ 只有两种真值：真、假。
注意：在判断陈述句真假时，需要明确其所在的场景。
原子命题：其真假独立于其他命题的最小命题。
一般用小写字母表示。
复合命题：已有命题用逻辑运算符组合成的新命题。
逻辑运算符：用于组合命题的符号
基本的逻辑运算符包含：
否定合取析取蕴涵双蕴涵亦或¬∧∨→⇿⊕ 否命题：非 合取命题：且 -只有p与q同时为真时，才为真
析取命题：或 –只有当p与q同为假时，p∨q才为假，否则为真
异或： –只有当p、q其中一个为真时，p⊕q才为真，否则为假
蕴涵： –只有当 p 为真 q 为假时，p→q 才为假，否则为真
蕴涵的逆、逆否、反命题
原命题：p→q
逆：q→p反：¬p→ ¬q逆否：¬q→ ¬p 蕴涵命题的等价形式：
¬p ⋁ ¬q
双蕴涵： –当p→q、q→p同真时，p ⇿ q为真
逻辑运算符的优先级： 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3fa211484537b9fbc748e59aef8c18ce/" rel="bookmark">
			输入一个字符串，删除汉字字符或者西文字符(C语言)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		西文字符就是ASCII码
删除字符串中的汉字
#include&lt;stdio.h&gt;
void main()
{
char s[81];
int i, j;
gets(s);
for (i = j=0; s[i] != '\0'; i++)
{
if ((s[i] &amp; 0x80) != 0x80)
{
s[j++] = s[i++];
s[j++] = s[i];
}
}
s[j] = '\0';
puts(s);
}
删除字符串中的西文字符
#include&lt;stdio.h&gt;
void main()
{
char s[81] = "Microsoft 微软公司 Computer\n杭州分公司";
int i, j;
for (i = j = 0; s[i] != '\0'; i++)
{
if ((s[i] &amp; 0x80) == 0x80)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3fa211484537b9fbc748e59aef8c18ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/330890898632b7aabb5fe025283da1cb/" rel="bookmark">
			element-ui 日期选择器 限制结束时间不能大于开始时间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 demo地址
&lt;el-date-picker :picker-options='pickerStartOptions(endReleaseTime)' v-model="startReleaseTime" type="date" value-format="yyyy-MM-dd" placeholder="选择开始日期"&gt; &lt;/el-date-picker&gt; &lt;el-date-picker :picker-options='pickerEndOptions(startReleaseTime)' v-model="endReleaseTime" type="date" value-format="yyyy-MM-dd" placeholder="选择结束日期"&gt; &lt;/el-date-picker&gt; export default { data(){ return{ /** 开始时间 */ startReleaseTime:'', /** 结束时间 */ endReleaseTime:'', pickerStartOptions(endTime){ return { disabledDate(time){ if(endTime){ // 拼接 00:00:00 是为了统一日期从0点开始 return time.getTime() &gt; new Date(endTime +' 00:00:00').getTime(); } } } }, pickerEndOptions(startTime){ return { disabledDate(time){ if(startTime){ // 拼接 00:00:00 是为了统一日期从0点开始 return time.getTime() &lt; new Date(startTime +' 00:00:00').getTime(); } } } } } } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d764521a64c2ddddee04a77c2906664/" rel="bookmark">
			WebRTC中线程模型和常见线程模型介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		WebRTC中线程模型和常见线程模型介绍 WebRTC中线程模型和常见线程模型介绍 WebRTC中线程模型和常见线程模型介绍前言一、WebRTC线程模式和常见线程模式1、WebRTC线程模式2、常见线程模型 二、WebRTC线程模型部分源码走读1、 Thread①、 任务放到队列中函数Post②、 执行任务接口 Dispatch 2、 WebRTC中线程切换 （SynchronousMethodCall）①、使用信号量通知的②、 WebRTC中线程同步绑定函数 MethodCall0 总结 WebRTC专题开嗨鸭 ！！！ 一、 WebRTC 线程模型
1、WebRTC中线程模型和常见线程模型介绍
2、WebRTC网络PhysicalSocketServer之WSAEventselect模型使用
二、 WebRTC媒体协商
三、 WebRTC 音频数据采集
四、 WebRTC 音频引擎(编解码和3A算法)
五、 WebRTC 视频数据采集
六、 WebRTC 视频引擎( 编解码)
七、 WebRTC 网络传输
八、 WebRTC服务质量(Qos)
九、 NetEQ
十、 Simulcast与SVC
前言 WebRTC是音视频行业的标杆， 如果要学习音视频， WebRTC是进入音视频行业最好方法， 里面可以有成熟方案， 例如：音频中3A 算法、网络评估、自适应码流、Simulcast、SVC等等 ， 非常适合刚刚进入音视频行业小伙伴哈_ 我也是哦， 以后再音视频行业长期打算的小伙伴的学习项目。 里面有大量知识点 提示：以下是本篇文章正文内容，下面案例可供参考
一、WebRTC线程模式和常见线程模式 1、WebRTC线程模式 上图就是WebRTC中三大线程模式： 分别是网络线程、工作线程、信号线程
webrtc -&gt; api
webrtc -&gt;proxy
webrtc -&gt; core
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d764521a64c2ddddee04a77c2906664/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46b6ccf3ef69e40cfa9a5f0d7224e1d4/" rel="bookmark">
			PacketTracer—Onenet云平台
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目标：实现PacketTracer中的设备连接到MCU芯片，并通过MCU微控制器实现数据上传至云平台、通过云平台控制设备、云平台应用搭建等功能。
1：进入Onenet官网
2：注册登录
3：点击首页控制台
4：点击旧版
5：点击左侧全部产品→多协议接入
6：点击TCP透传→添加产品
7：设置您的产品名称，其余根据下图进行选择，然后点击确定
8：点击立即添加设备
9：鼠标放在脚本解析旁的问号上，下载脚本验证工具
10：下载后找到sample.lua文件，不需要打开，这个文件就是我们需要的文件
11：点击上传脚本解析，选择sample.lua文件
12：点击添加设备
13：设备名称根据需要填写，鉴权信息一定要记住，勾选私有，添加
14：按照实验，构造拓扑图如下
15：编写如下代码，并根据图示修改为自己的信息
补充：
1）创建文件
2）编辑代码
3）获取产品ID
4）获取鉴权信息
5）获取api-key
6）开启
7）代码：
from gpio import * from time import * from realtcp import * url = 'http://api.heclouds.com/devices/xx/datapoints?type=3' head={"api-key":"xx","Content-Type":"application/json"} serverIP="dtu.heclouds.com" serverPort=1811 auth='*xx#xx#xx*' client=RealTCPClient() on=[1] def onTCPConnectionChange(type): if int(type)==3: client.send(auth) def onTCPReceive(data): if data=="Open": on[0]=1 elif data=="Close": on[0]=0 client.onConnectionChange(onTCPConnectionChange) client.onReceive(onTCPReceive) client.connect(serverIP,serverPort) sleep(1) while True: switch=analogRead(3) tem=analogRead(2) print("Switch:",switch) tem=round((tem-511)/5.12,2) print("tem:",tem) s1=str(tem) s="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/46b6ccf3ef69e40cfa9a5f0d7224e1d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49953c601bb153b38b6435484ca7964c/" rel="bookmark">
			uniapp微信小程序ios真机上测试页面下拉出现白边
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决方法一：
在page.json ,单个页面中的样式设置背景
全局设置
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5fc74af8cf185e6e8537d2bd61e57848/" rel="bookmark">
			postman环境变量设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、设置
2、 添加，保存
3、使用，{{}}引用
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8a249e059795b119b3014c2047b56e9/" rel="bookmark">
			计算机组成原理-Verilog课程设计制作8位CPU简析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
课设时间已经过去一周了，有人还是不甚了解自己在写什么（QwQ），我说一些我对需要我们做的部分的见解吧。整个文章分为模块篇、信号篇、top连线篇和查错篇。（很多人不会以为我只会传C++的实验吧）
一、模块篇
Verilog语言和常规语言有很大的不同，常规语言我们做的是一个顺序执行的过程，从头往后写就完事了，Verilog，与其说是语言，不如说是“电路连线模拟器”。
连线之前我们应该干什么？应该了解每个模块的作用，先写模块。很多人上来就跟风写信号，最后发现信号改了又改加了又加，那肯定更容易出问题。
根据这个数据通路，我们可以整理一下，M是ram、rom（写在ram中了）存储器，老师已经写好给我们了，而剩下的就是AR、PC、DR、IR、TR、R、AC、ALU、Z，什么顺序无所谓，我们一个个分析过来。他们有什么用，我们需要知道吗？啊不需要，我们现在在写模块，有什么用，以后再说。（以下过程暂不赘述clk和rst信号）
AR需要输入选择信号arload、自增信号arinc、输入数据（其实是指令，不过无所谓，后面再说）来自哪？来自dbus（16位总线）。输出什么？addr（这些是老师已经写了的，有什么用？现在不用知道）
PC信号输入选择信号pcload、自增信号pcinc、输入数据来自哪？还是dbus，那会不会和AR抢起来了？关我x事，不管。然后输出给pcdbus。那眼尖的人就看到了，啊这个pcbus是什么，pcbus不在PC里，和我们有关系吗？没有关系。
那可能聪明的人可能就发现了（可能是悟到的也可能是看老师给的代码看懂了），xxload代表选择信号，当xxload=1的时候，那个寄存器可以把输入的值存进去，不然就不理输入数据。xxinc就是能让他被选择的时候自增一位，然后输出信号；输出会给xxdbus，不会直接给dbus，如果遇到xxbus挡住了（为0）就卡在那里不动，等xxbus同意输出了再进入dbus。
这里注意了，我们的信号不是电流，是数据，数据就像爱情（bushi），他不会凭空消失，他只会转移（准确地说是只会复制，比如xxdbus的数据给dbus之后原先的数据一直都在）。不是说我PC输出了一下，后面没有继续输入了，我的pcdbus就没有数据了。
那么看不懂没关系，后面讲到信号也都懂了。言归正传讲寄存器。
DR寄存器：输入信号：选择信号drload、输入数据dbus[7:0]，输出信号drdbus。
IR寄存器：输入信号：选择信号irload、输入数据drdbus，输出信号是谁？老师没给，我们就暂时定义为irdbus，有用吗？下回再说！
TR寄存器：输入信号：选择信号trload、输入数据drdbus，输出信号trdbus。
R寄存器：输入信号：选择信号rload、输入数据dbus[7:0]，输出信号rdbus。
AC寄存器：输入信号：选择信号acload、输入数据来自ALU的。。。贵客，既然他是alu的输出，我们就叫他aludbus吧。输出信号acdbus。
Z寄存器：输入信号：选择信号zload、输入数据aludbus，输出信号老师没给，但是根据我们的命名规则我们应该叫他什么？没错，zdbus。
ALU：输入信号：选择（选择运算）信号alus、输入数据acdbus、dbus[7:0],输出aludbus。有人说：啊，图上有两根输出啊。但是你仔细想想，这两根输出不是一样的值嘛？而至于怎么通过alus（运算符）和两个输入的数据得到输出的数据（像极了给你一个符号和两个数字算结果），可以“复习”一下实验四，这里不做赘述。
那么全部的小模块都完成了，这个数据通路图就出来了，实验已经完成了四分之一（哦耶~）。但是为什么我都把上面的数据通路弄出来了，还不能得到正确的结果呢？图上的控制信号（各种load、bus、alus）什么时候是什么应该怎么判断呢？很明显，我们需要一个新的模块（你可以理解为一个比较大的，盖在这个数据通路上的名叫control的模块，所有控制信号都从他出来），所有的选择信号都由他输出，那么他通过什么样的输入来判断这些输出呢？马上进入下一章。
二、信号篇
在讲巨大的control模块之前，我们先来说一个不在这个模块中的信号，也是困扰了一些人一章的信号（dbus）。
dbus有6条来源：membus守卫的数据、pcbus守卫的数据、drlbus、drhbus守卫的数据、trbus守卫的数据、rbus守卫的数据和acbus守卫的数据。当其中任何一个bus为1时，bus所控制的信号就会覆盖掉dbus中的值（如果dbus是16位，我想覆盖低8位，那么高8位还是原来的值）。所以老师已经在cpu.v最下面给了我们6行描述dbus的内容的语句，如果控制信号全部正确，我们应让同一时刻所有xxbus只有0-2（2是同时覆盖低高8位）个为1。
那么初步了解后，我们对于control所面对的任务也有了些许了解。我们先做一个小小的练习热热身。请问：如何将PC寄存器的低八位的内容传递给IR，即实现IR&lt;-PC[7:0]?（大家不用考虑每个寄存器具体用途）
从PC到IR需要经过寄存器DR，那么DR寄存器和IR寄存器的内容肯定都要被选中，即drload和irload都为1。PC的数据需要出来，那么pcbus=1，放他进入总线，然后dr就能接收并传递给IR。总结：PC到IR需要令pcbus=1,drload=1,irload=1。
了解之后我们就可以尝试去理解每个寄存器的功能（通过老师已经给我们的部分代码）。注意：以下正式开始control的编写。
首先，我们的行为分为两部分：取值阶段、执行阶段。即：把指令取过来，执行指令。取指阶段大家都是一样的（有人会问三字指令呢？也是一样的，虽然要取三次，但是只有第一次取的八位是用于区分我们要执行什么命令的，后面两次取的八位仅仅是数据而不是命令）。
我们可以直接白嫖老师的分析并且稍作理解！
我就直白一点说吧，通过PC-&gt;AR,PC+1-&gt;PC,PC-&gt;AR，我们可以看出，PC是一个计数器，用来确定我们现在应该读取第几个指令，而AR的作用则是沟通M存储器，这个地方，看看就好。然后M的数据经过DR最后传递到了IR。IR叫什么？指令存储器！破案了！control的输入数据是什么？是IR的数据，代表什么？代表指令。
control的实例化就可以完成了，输入irdbus，输出一大堆。
那么每个指令应该做什么呢？比如从ir获得的指令是00000011，查表我们就知道了要执行AC-&gt;R，我们也知道了要打开acbus，并且让rload=1。
那么我们怎么让我们的CPU在正确的时间做正确的事情呢？这就要引入节拍的概念了。我们定义了三组wire信号，用于分别控制正确的时间、正确的事情、正确的时间+正确的事情。
正确的时间：t0,t1,t2...t7。
正确的事情：inop、iread、iinac...所有指令加个i即可，表示的意思就是正确的事情！这个信号根据输入的irdbus信号定，老师已经给出模板。
正确的时间+正确的事情：fetch1、fetch2、add1、ldac1、ldac2、ldac3......。
那么打个比方，我们已经知道fetch1阶段pcbus和arload都要等于1了，就可以让pcbus和arload=fetch1，那有人问了，如果其他阶段也要这个信号等于1呢？比如fetch3，那么就让pcbus=fetch1||fetch3。即fetch1和fetch3，都是我pcbus打开的正确时间，打开这个事情也是正确的！
注意：暂时没有使用到的信号要定义其等于0，后面再做更改，这很重要。比如drhbus和drlbus没有定义为0也没有初始化，那么他们的状态就是不确定的，那么取指令的时候dbus中的内容就很可能引用到drdbus，而此时drdbus还没有赋值，即访问空的区域！（数据结构：空指针恐吓）最后输出的结果就是一堆蓝线加一堆红线。
那么我们剩下的事情就是化身勤劳码农，把所有的ixxx信号、xxx1、xxx2等信号写完，并且根据自己总结出来的控制信号的表格对每个控制信号单独寻找他能工作的时间事件就行了。
附各小模块功能：TR寄存器（没记错的话）在选做指令中使用，用于得到16位的地址（先读低八位，通过DR给TR，然后再读高八位，DR吃独食，然后一起给dbus总线，并传递给PC）
PC：存储吓一条指令地址（计数器）。
AR：存储需要读取的信息（包括指令、数据）的地址
DR：传递指令、地址。
IR：存储指令
ALU：计算
AC：存储计算结果
R：一个存储数据的工具罢了、
Z：判断AC是否为0
关于PC和AR，一般情况下，他们的值可能是只差1或0的，比如我现在进行第0条指令，那么我的AR就是0，读取第0条指令的内容，同时我的PC是1，代表我接下来要读第1条指令了，把PC的值直接给AR（1），然后执行第0条指令。
但是在涉及跳转指令的时候，比如我要实现M[16]-&gt;AC(第0条指令），那么我的fetch周期内让我的PC=1,AR=1了，那么接下来就要获取第1、2号位置存储的00010000（16）和00000000，这代表存储器地址的低八位和高八位，读取完后PC则到了3，AR则等于16（获取第16号空间的数据），然后再传递给AC。具体的流程大家可以结合数据通路和老师给的流程看看。
看什么信号？
很多人还是不清楚看什么信号。首先我们要知道CPUState，这个信号把整个过程分为三块，in（01） check（10） run（11）。check阶段check_out指令会输出所有你存入的指令信息。run阶段，acdbus是我们的AC输出结果，rdbus是R的输出结果，是必看的，如果出了问题，可以看一下rambus。（每次从M取出的值，包括数据、高8位地址和低8位地址）理论上讲，rambus的数据和check_out变化顺序是相同的，但是每次变化的长短可能不同（涉及三字指令的话）。
然后就是看各个节拍的控制信号，这里建议把所有的控制信号led先连上，如果不想连的话也可以每次打开仿真的时候额外加一下control/cpu内的控制信号。
如果出现某一块的总线红了的情况，可以将dbus和各个三态门的控制信号（xxbus）取出，看看也没有出现错误导致访问未知。
三、top连线篇
top怎么连线？老师没有给我们画这部分的数据通路图，我们可以想象一下，一共三个模块：CPU、ram（M）、light_show。
ram功能：存储数据的工具罢了，通过输入cpu中read信号和AR给的地址信号读取相应的信息并输出到rambus中。并通过cpu给的write信号和输出的来自dbus的信号存储数据（貌似是选做）
light_show功能：将所有信号和LED灯相连接，比如irload=1，那么irload_led=1。比如acdbus=00000011=（3），那么我的某两个HEX信号就为对应能让开发板输出数字3的信号（不懂没事，给他就完事了）
那么我们的cpu怎么实例化？输出什么？全部控制信号（light要用）以及data_out等信号。
注意：如果有选做用到Z的同学，我们的top里面已经定义了一个Z信号了，直接在实例化的时候.zdbus(Z)就完事了。
然后我们需要修改一下light_show的实例化和内容。其实老师注释里面应该是全部的信号内容，照着补充就行。内容则仿照light_show底部的几个信号写一下就行。HEX相关的已经全部帮我们写好。
四、查错篇
我提供两种很好用的查错方式：
第一，我们可以使用老师提供的增加输入样例的方式查看波形图。打个比方，我这输出的irload_led怎么有问题啊？那我看谁？cpu里面的irload信号、control里面的irload信号，从他出生到应用都看清楚看明白，就知道在哪个地方连线有问题了，如果出生之前就有问题，至少我们能知道control里面他写错了。
点击左边的加号可以打开具体的模块，选中后可以在右上角这里选择这个模块内的对应的信号，非常好用！
我看到有些同学班里没有发这种方式，我就在这里补充一下具体流程。
首先肯定是选择我们想要的模块，然后选择右上角选择信号，右键 Add Wave（可以使用Ctrl和shift快速选择多个），这时候波形图的最下方就出现了我们想看到的信号。但是这个信号没有任何的波形，我们点击左上角工具栏Simulation-&gt;Restart 直接OK，然后Simulation-&gt;Run-&gt;Run_All，点击否。接下来会给你弹出你的文件，让你感觉，啊？我是不是写错了。没有，点击弹出的文件右上角的一个小叉叉就行了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c8a249e059795b119b3014c2047b56e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55b1facebfe2d096a8c7918e1b7208cd/" rel="bookmark">
			React与Redux Toolkit的简单使用、ts环境中一些常见问题的解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装 创建react+redux的TS环境（最佳实践） 无须再安装redux、redux-thunk、react-redux、immer等，默认就已经集成了@reduxjs/toolkit的Redux架构。
create-react-app react-admin --template redux-typescript 参考链接：https://github.com/reduxjs/cra-template-redux-typescript
使用Redux Toolkit完成react的状态管理 demo效果演示如下
生成一个子reducer （createAsyncThunk, createSlice） /** src/store/test/testSlice.ts */ import { createAsyncThunk, createSlice } from '@reduxjs/toolkit'; // 异步请求 import { fetchIp } from './testAPI'; // 设置类型 export interface testState { value: number; ip: object } // 设置初始化state const initialState: testState = { value: 1, ip:{} }; // createAsyncThunk这个API可以用来设置异步方法,我们可以通过这个API来让redux支持异步。 export const getIpAsync = createAsyncThunk( 'test/fetchIp', async () =&gt; { const response = await fetchIp(); console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/55b1facebfe2d096a8c7918e1b7208cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59a6bde868f4edf77c4705fc0fac8c2d/" rel="bookmark">
			XSX和PS5对标的电脑配置（2021年12月10日分析）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Xbox Series X对标电脑配置（2021年12月10日下午） 前言 最近买了台小米电视86，光看电视感觉不过瘾，想玩点游戏。
但是专门买一个XSX或者PS5又感觉没必要，因为我也不是游戏重度爱好者，于是想了一个折中的办法，DIY一台主机去玩XSX上的游戏。
到网上找这个答案要么过时，要么不全面，于是想自己推导一下。
XSX显卡相当于2080S，CPU相当于R7 3700X，1T固态，16G内存
文章目录 Xbox Series X对标电脑配置（2021年12月10日下午）前言内容网上结论参考我推导的主机配置两个配置表 结尾 内容 网上结论参考 《参考一》发布与2020年11月19日。
主要观点就是：XSX的显卡相当于2080S的显卡，CPU和3700差不多。
《参考二》发布于2021年6月22日。
主要观点就是：ps4por 可以对标pc端GTX1060；ps5可以对标pc端RX5700 or GTX2070；XBOX Series X对标pc端GTX2080；
里面还有一张图，很直观。
《参考三》发布与2021年6月12日。这个最详细，逻辑最清晰。
总结：XSX的CPU相当于r7 3700，GPU相当于RTX2080s。
然后我搜了一下近期显卡和CPU的价格
《显卡性能天梯图》
配置价格微星RX6700XT12G6000蓝宝石RX6600 8G4000（配T650铜牌电源）七彩虹RTX3070TI6799七彩虹RTX30604199影驰GTX1070 8G2049七彩虹GTX1060 3G1149GTX1050 2G740 对标XSX的显卡在4千元以上。
《CPU性能天梯图》
配置价格R9 5900X2969R7 5800X2099R5 5600X1659R7 3700X1599R5 36001299i7 12700K2524i5 12600KF1634i7 10700K2119i5 10400F849i3 10105644 对标XSX的CPU价格在1600以上。
emm，好吧，虽然现在XSX标价3899，但是要5099才买到。配RXT3060（RX6600）和R7 3700X（i5-12600KF）就需要5千8了。
我推导的主机配置 CPU和GPU已经确定好了，剩下就是内存条，固态，主板，散热、电源和机箱了。
参考我去年11月12写的《分析整装台式机是否物有所值》
内存条
目前内存主要购买DDR4，频率主要2666、3200、3600三种，性价比最高的是3200MHZ。
目前标配内存会是8G*2双通道，不过明年后年应该是32G内存组合了，再加2条妥妥。未来DDR5内存也会上市，但整体而言，内存对机器的性能并不会有过高的影响。新出的内存价格也会贵的飞起。一些视频编辑的，就特别吃内存，建议直接32/64G这点要注意了。
所以我选金士顿8G 3200 两根，预算400。如果减配置也能用金士顿 8G 2666 一根，预算200
固态硬盘
目前固态硬盘已经全面取代机械硬盘， 随着NAND闪存价格的不断下降，现在SSD的价格已经便宜到白菜价，不过2020年因为特殊原因，停工影响固态硬盘也大幅度上涨，比如东芝的RC500几乎涨了一倍。按照技术发质，固态硬盘长期而言是降价的。
目前主要有两种技术：M.2 SATA、M.2 NVMe；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/59a6bde868f4edf77c4705fc0fac8c2d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ffc59699c8e8f762abe16aad55de517/" rel="bookmark">
			Java多线程——三个线程交替打印ABC
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		三个线程交替打印ABC，例如ABCABCABC，代码如下：
/** * GEEK * Description:爱学Java * @author :LiGer */ public class Test { public static void main(String[] args) { printABC print = new printABC(100); new Thread(new Runnable() { @Override public void run() { try { print.printA(); } catch (InterruptedException e) { e.printStackTrace(); } } }).start(); new Thread(new Runnable() { @Override public void run() { try { print.printB(); } catch (InterruptedException e) { e.printStackTrace(); } } }).start(); new Thread(new Runnable() { @Override public void run() { try { print.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ffc59699c8e8f762abe16aad55de517/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97934c17f87a1d312d05964aa1538862/" rel="bookmark">
			Android动态画线 坐标画线动画
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		效果图如下
根据相对于图片本身的坐标xy数组 基于view的左上角为原点 在图片上动态画线 //参考数据类型 //pointList [PointEntity(pointX=1, pointY=1), PointEntity(pointX=2, pointY=2), PointEntity(pointX=3, pointY=3)] //lineList [LinePointEntity(startX=1, startY=1, endX=2, endY=2), LinePointEntity(startX=2, startY=2, endX=3, endY=3)] //协程 implementation "org.jetbrains.kotlinx:kotlinx-coroutines-core:1.3.5" import android.content.Context import android.graphics.Canvas import android.graphics.Paint import android.util.AttributeSet import android.util.Log import android.widget.FrameLayout import kotlinx.coroutines.* import java.util.concurrent.CopyOnWriteArrayList import kotlin.math.absoluteValue class DrawLineView : FrameLayout { private val TAG = "DrawLineView" private var mWidth = 0 private var mHeight = 0 private var drawJob: Job? = null private var threadWorking = false private var mPaint: Paint?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/97934c17f87a1d312d05964aa1538862/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bceb9c41505feb208c9683758ea6738/" rel="bookmark">
			单片机笔记三：打开keil5遇到提示device not found
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、打开软件报错应该怎么处理 具体到我这里，我提示的是没有找到这个特定芯片
我看了一下，这里果然是没有识别出来
按照这个博客写的操作之后，一下子就解决了，非常棒，这里附在后面
KEIL5添加STC芯片库_Initdev的博客-CSDN博客_keil5 stc
现在打开程序不再有这个提示了，而且芯片也识别到了
keil5和keil4的安装有些不同
网上已经有很多说明了，我这里稍微补充一下
2、keil5要单独导入一些芯片的安装包 可以从pack里点去安装
也可以把安装包下好之后直接双击安装 3、安装keil5的时候为什么会安装名字叫mdk的软件？ 简单理解就是：keil不含mdk就是一个工程 代码编辑器
mdk是arm芯片的开发环境 包含了编译器 一些库文件 以及一些调试模拟支持
如果没有mdk的话 单纯keil5不能编译烧录程序的
mdk5和keil5的区别：mdk5是扩展版本，包含了部分ARM。为基于Cortex-M、Cortex-R4、ARM7、ARM9处理器设备提供了一个完整的开发环境。keil5是普通版本，只能适用于单片机，主要是基于8051系列单片机的开发环境。
我们要区别的概念：KEIL uVision，KEIL MDK，KEIL For ARM，RealView MDK，KEIL C51，KEIL C166，KEIL C251
从接触MCS-51单片机开始，我们就知道有一个叫KEIL的软件。在开发单片机时，使用的是C语言或者汇编语言，我们知道，这两种语言都不能直接烧写到单片机里面，执不执行暂且不说，光是代码的体积，就足以撑破整个单片机。
所以，我们需要一个软件，把C语言或者汇编语言编译生成单片机可执行的二进制代码，而且它的体积也非常的小，足够存放在单片机的存储器里面。KEIL公司（现在是ARM公司的一个公司）的软件恰好可以提供这样的功能，并且它还有很多优点，比如工程易于管理，自动加载启动代码，集编辑、编译、仿真一体，调试功能强大等等。因此，不管是初学单片机的爱好者，还是经验丰富的工程师，都非常喜欢使用这些软件。 但是，即使熟练使用了KEIL软件，有些概念我们还是不容易理清，常常混淆。KEIL、uVision、RealView、MDK、KEIL C51，它们到底有什么区别，又有什么联系？下面我们就做一个详细的分析。
KEIL是公司的名称，有时候也指KEIL公司的所有软件开发工具，目前2005年Keil由ARM公司收购，成为ARM的公司之一。
uVision是KEIL公司开发的一个集成开发环境（IDE），和Eclipse类似。它包括工程管理，源代码编辑，编译设uVision置，下载调试和模拟仿真等功能，uVision有uVision2、uVision3、uVision4、uVision5四个版本，目前最新的版本是uVision5。它提供一个环境，让开发者易于操作，并不提供能具体的编译和下载功能，需要软件开发者添加。uVisionu通用于KEIL的开发工具中，例如MDK，PK51，PK166，DK251等。
RealView是一系列开发工具集合的称呼，简称RV，包括有RVD（RealView Debugger），RVI（RealView ICE），RVT（RealView Trace），RVDS（RealView Development Suite），RV MDK（RealView Microcontroller Development Kit）这些产品。这些都是为了让客户容易记住，采取的一个宣传策略。
举个例子说，米尔科技是一家主营优质ARM工控板的企业，其产品系列由工控板（开发板）、单板机和核心板组成，虽然本来可以都叫工控板，但是为了让客户清晰了解产品的功能，进行选型，所以就分为3个系列。不过2009年ARM又宣布停止使用Realview品牌，所以目前ARM就剩下了ARM和KEIL两个品牌了。
MDK（Microcontroller Development Kit），也称MDK-ARM、KEIL MDK、RealView MDK、KEIL For ARM，都是同一个东西。ARM公司现在统一使用MDK-ARM的称呼，MDK的设备数据库中有很多厂商的芯片，是专为微控制器开发的工具，为满足基于MCU进行嵌入式软件开发的工程师需求而设计，支持ARM7，ARM9，Cortex-M4/M3/M1，Cortex-R0/R3/R4等ARM微控制器内核。
KEIL C51，亦即PK51，KEIL公司开发的基于uVision IDE，支持绝大部分8051内核的微控制器开发工具。
KEIL C166，亦即PK166，KEIL公司开发的基于uVision IDE，支持绝大部分XC16x，C16x和ST10系列的微控制器开发工具。
KEIL C251，亦即DK251，是KEIL公司开发的基于uVision IDE，支持绝大部分基于251核的微控制器的开发工具。
总结来说，KEIL公司目前有四款独立的嵌入式软件开发工具，即MDK、KEIL C51、KEIL C166、KEIL C251，它们都是KEIL公司品牌下的产品，都基于uVision集成开发环境，其中MDK是RealView系列中的一员。
转自
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4bceb9c41505feb208c9683758ea6738/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2887cf51580ba0f0cde8bc1611dc1339/" rel="bookmark">
			网络安全学习网址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天刚翻出朋友一年前发给我的一些学习网址，特地在CSDN分享一下，其中有些地址已不能使用
微信公众号：运维开发故事
http://www.sec-wiki.com/skill/安全技能(里面渗透逆向编程都有介绍)
http://blog.knownsec.com/Knownsec_RD_Checklist/ 知道创宇研发技能表v3.0
https://www.shentoushi.top/network 渗透师 （网络安全学习网址导航）
https://www.anquanquan.info/ 安全圈info（网络安全学习导航网址）
综合学习平台：
https://secquan.org 圈子社区
https://github.com/cxf210/Scanners-Box
http://edu.gooann.com/ 谷安网校
https://edu.aqniu.com/ 安全牛课堂
http://www.jikexueyuan.com/ 极客学院http://www.hetianlab.com/ 合天http://www.moonsos.com/ 米安网http://www.ichunqiu.com/ i 春秋http://www.honyaedu.com/ 红亚http://www.baimaoxueyuan.com/ 白帽学院http://www.simplexue.com/ctf/index 西普学院http://www.imooc.com/course/list 慕课http://www.secbox.cn/ 安全盒子
http://www.freebuf.com/ freebuf
http://bobao.360.cn/ 360安全播报
https://github.com/cxf210/Scanners-Box github上的资源库
https://github.com/cxf210/docker
https://github.com/cxf210/fuzzdb
https://github.com/cxf210/webshell github上的webshellhttp://drops.wooyun.org/ 乌云知识库
http://wiki.wooyun.org/ WooYun WiKi
https://www.91ri.org/ 91ri
https://www.t00ls.NET/tools 土司
https://bbs.77169.com/forum.php 华盟网
http://www.ijiandao.com/ 爱尖刀
http://www.secist.com/ 即刻安全
http://www.secwk.com/article/index.html 威客众测http://bluereader.org/ 深蓝阅读http://www.shentou.org/ 黑客安全军火库http://netsecurity.51cto.com/ 51cto
http://security.csdn.net/ csdn
http://www.80sec.com/ 80sec team
https://security.alibaba.com/blog.htm?spm=0.0.0.0.knOqaI 阿里巴巴安全响应中心
http://security.tencent.com/index.PHP/blog腾讯安全应急响应中心博客
http://security.360.cn/blog 360安全应急响应中心博客http://sec.baidu.com/index.php?research/list 百度安全应急响应中心博客
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2887cf51580ba0f0cde8bc1611dc1339/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/027ef70ea25c829b7ab9125568d88a42/" rel="bookmark">
			C &#43;&#43; STL中列出pop_front()函数用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在本文中，我们将讨论C ++中pop_front()函数的工作，语法和示例。
什么是STL中的列表 列表是一种数据结构，允许按时间顺序在任意位置进行插入和删除。列表被实现为双向链接列表。列表允许非连续的内存分配。与数组，向量和双端队列相比，列表在容器中的任何位置执行元素的插入提取和移动效果更好。在列表中，对元素的直接访问很慢，并且列表与forward_list相似，但是转发列表对象是单个链接列表，并且只能迭代转发。
什么是pop_front() pop_front()是C ++ STL中的内置函数，在头文件中声明。pop_front()用于从列表容器的开头弹出（删除）元素。该函数删除列表容器的第一个元素，意味着该容器的第二个元素成为第一个元素，并且该容器中的第一个元素从该容器中删除。此功能将容器的尺寸减小1。
语法 void pop_front (); 此函数不接受任何参数
返回值 此函数不返回任何内容，只是从容器中删除/弹出第一个元素。
示例 #include &lt;bits/stdc++.h&gt; using namespace std; int main(){ //创建一个列表 list&lt;int&gt; myList; //将元素插入列表 myList.push_back(1); myList.push_back(2); myList.push_back(3); myList.push_back(4); //应用pop_front()函数之前列出 cout&lt;&lt;"List contains : "; for(auto i = myList.begin(); i != myList.end(); i++) cout &lt;&lt; *i &lt;&lt; " "; //删除第一个元素 myList.pop_front(); //从前面删除元素后的列表 cout&lt;&lt;"\nList after removing an element from front: "; for (auto i = myList.begin(); i != myList.end(); i++) cout &lt;&lt; *i &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/027ef70ea25c829b7ab9125568d88a42/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff2dda624af44678a91a3fef85a56301/" rel="bookmark">
			UserWarning: CUDA initialization: CUDA unknown error - this may be due to an incorrectly set up……
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在服务器上新建一个conda环境后，遇到了此问题
UserWarning: CUDA initialization: CUDA unknown error - this may be due to an incorrectly set up environment, e.g. changing env variable CUDA_VISIBLE_DEVICES after program start. Setting the available devices to be zero. (Triggered internally at /opt/conda/conda-bld/pytorch_1623448255797/work/c10/cuda/CUDAFunctions.cpp:115.) return torch._C._cuda_getDeviceCount() &gt; 0 首先检查显卡驱动，CUDA，cudnn，以及pytorch的版本是否匹配，如果不匹配，需要卸载之后重装对应的版本。
注意：nvidia-smi命令输出的CUDA Version应该是要求的最高版本，不能高于那个。
其实我的实际原因是服务器出问题了，最终通过重启服务器解决。
参考资料：
1.是否需要配置.bashrc，我本地是直接装了没有配置的，也有网友说要配置，但是多个CUDA时候，就得配置了。这个文件是个隐藏文件，在计的home文件夹下一层，可以vim编辑
# 前三行是安装CUDA的时候需要设置的 export PATH=/usr/local/cuda-11.2/bin${PATH:+:${PATH}} export LD_LIBRARY_PATH=/usr/local/cuda-11.2/lib64${LD_LIBRARY_PATH:+:${LD_LIBRARY_PATH}} export CUDA_HOME=/usr/local/cuda-11.2/bin export CUDA_VISIBLE_DEVICES=0,1,2,3 保存退出，完了source .bashrc一下后生效。
参考：pytorch学习笔记-UserWarning: CUDA initialization: CUDA unknown error - 简书
【Linux】环境变量设置.bashrc及相关_summer的博客-CSDN博客_bashrc
2.查看本地Pytorch是否可用命令
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ff2dda624af44678a91a3fef85a56301/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22838a4042cd7434bbf51aa098a2dc36/" rel="bookmark">
			python中将奇数和偶数分列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python中将奇数和偶数分列 方法一方法二方法三拓展：列表翻倍 随机创建一个数列，如何将里面的奇数和偶数分列呢？今天我们就来试试。 方法一 写出代码，
nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] m1 = [] m2 = [] for num in nums: if num % 2 == 0: m1.append(num) else: m2.append(num) print(m1) print(m2) 运行程序，查看结果。
方法简单，相信小伙伴们看了就能了解。
方法二 代码如下，
nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] m1 = [] m2 = [] m1 = [x for x in nums if x % 2 == 1] m2 = [x for x in nums if x % 2 == 0] print(m1) print(m2) 运行结果，
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/22838a4042cd7434bbf51aa098a2dc36/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2241ef8734112e5fd9b64d8acf64e8e8/" rel="bookmark">
			第五章 循环结构程序设计习题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		填空（5）
1.定义整型k，x；
2.k=0，x=0；
3.若k&lt;=9&amp;&amp;x！=10，转第4步，否则转第6步；
4.x=x+2；
5.k++，转第3步；
6.输出k，x
1. 定义字符型c；
2.c=getchar（）；
3.若c！='#'，转第4步，否则转第6步；
4.putchar（c）；
5.c=getchar（）；转第4步；
6.输出c；
1.定义字符型ch；
2.ch=getchar；
3.若ch='\n'，转第4步，否则转第5步；
4.输出ch，转第3步；
5.输出ch；
.
1.定义整型i，a=1；
2.无符号整型j；
3.i=15；
4.若i&gt;0，转第5步，否则转第7步；
5.a++；
6.i-=2，转第4步；
7.输出i；
阅读（1）
1.定义整型i；
2.i=1；
3.若i&lt;6，转第4步，否则转第8步；
4.若i%2，转第5步，否则转第6步；
5.输出*，转第7步；
6.输出#，转第7步；
7.i++，转第3步；
8.输出，结束；
阅读（2）
1.定义整型m=1，n，i；
2.i=0；
3.若i&lt;5，转第4步，否则转第9步；
4.int m=1；
5.m++；
6.若i==4，转第7步，否则转第8步；
7.n=m； 8.i++，转第3步；
9.输出m，n；
阅读（3）
1.定义整型i；
2.i='a'；
3.若i&lt;'f'，转第4步，否则转第6步；
4.输出i-'a'+'A'；
5.i++，i++，转第3步
6.输出，结束；
阅读（4）
1.定义整型f，f1，f2，i；
2.f1=1；f1=1；
3.i=3；
4.若i&lt;=5，转第5步，否则转第8步；
5.输出f；
6.f1=f2；f2=f；
7.i++，转第4步；
8.输出，结束；
阅读（5）
1.定义整型n=5；
2.n%2 ；
3.若case 0:，转第4步，否则转第5步；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2241ef8734112e5fd9b64d8acf64e8e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14996d80e7328aab1dbdd747d53ab498/" rel="bookmark">
			软件工程：需求分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 需求是整个产品的源头，需求分析的结果决定了产品的成败。如果没有正确的把握客户需求，可能会一步错，步步错。
什么是需求？ 我们日常在项目中，经常会听到“需求”这个词，比如说：
项目经理对产品经理说：用户给我们提了一个需求，想要一个给三个孩子玩的秋千，你分析一下；产品经理对架构师说：我们现在有一个需求，在树上栓两绳子，再吊一块板子，你做一下设计。 很明显，这两个需求的意思不一样，前面这个需求是用户需求，后面这个需求是产品需求。
用户需求是由用户提出来的，期望满足自身一定需要的要求，例如用户说：“想要一个给三个孩子玩的秋千。”这种原始的用户需求通常是不能直接做成产品的，需要对其进行分析提炼，最终形成产品需求。产品需求就是在分析提炼用户真实需求后，提出的符合产品定位的解决方案。就像上面“在树上栓两绳子，再吊一块板子”，就是产品经理针对用户需求提出的解决方案。 需求分析是要分析什么 其实对用户需求的分析，不是一个动作，而是一个过程。需求分析，就是对用户需求进行提炼分析，最终形成产品需求的过程。
而针对每个用户需求的需求分析过程，需要讲过三个步骤
第一步：挖掘真实需求 大部分用户提的需求，都不见得是真实的需求，需要透过现象看本质，去挖掘其背后真实的需求。就像福特汽车创始人亨利福特说过的：如果我最初是问消费者他们想要什么，他们应该是会告诉我，“要一辆更快的马车。
这里“要一辆更快的马车”就是一个典型的用户需求，但这并非是用户的真实需求，用户的真实需求，需要通过分析才能得到。
要分析用户的真实需求，可以从三个角度入手：
目标用户：用户不同，诉求也不一样使用场景：使用场景不一样，解决方案也不一样想要解决的问题：用户背后想要解决的问题是什么 我们假设目标用户是普通乘客，使用场景是日常出行，那么用户想要解决的问题其实并不简单是“要一辆更快的马车”，想要更快的马车只是用户自己能想到的解决方案，而他想解决的问题是“更快更舒适的出行方式”。
而现实项目中，大多数人需求分析的不正确，就是因为没有挖掘出用户的真实需求。
我们再看之前的秋千项目，目标用户是三个孩子，使用场景是一起户外玩耍，想解决的问题其实是能有一起玩的娱乐设施。
第二步：提出解决方案 我们知道了目标用户，其使用场景和想要解决的问题，就可以结合产品定位，提出相应的解决方案。
比如针对想要“更快更舒适的出行方式”日常出行的乘客，我们就可以提出汽车的解决方案，而不一定要局限于马车，汽车能更好的满足用户需求。
针对三个孩子想有一个在户外一起玩的娱乐设施这个需求，我们可以提供一个轮胎式的秋千，就可以很好的满足他们的需求，我们甚至可以建一个小型游乐园。
第三步：筛选和验证方案 在提出方案后，我们需要对方案进行筛选，比如对于秋千项目，建小型游乐园的方案虽然能满足需求，但是成本太高，需要排除掉。
在选好方案后，还需要对方案进行验证，以确保方案能解决用户需求。
在传统瀑布模型中，选定方案中，会写成产品设计文档，走相应的评审流程，评审完成后再进行设计、开发和测试，测试完成后会让客户再进行验收。而敏捷开发，在整个开发过程中，每个迭代或者关键的里程碑，也一样需要客户进行验收。
通过以上三步，就可以对用户需求进行提炼分析，最终形成产品需求。
所以在需求分析过程中，分析的就是一个个用户的需求，找出背后的真实诉求，再有针对性的提出解决方案
对于解决方案，要进行筛选和验证，有些不可行的用户需求不会变成产品需求，可行的用户需求会按照优先级进行实施阶段，最终变成产品
怎样做需求分析？ 上面介绍了对单个用户需求的分析，主要经过三个步骤：
第一步：挖掘真实需求；第二步：提出解决方案；第三步：筛选和验证方案。 而软件项目的用户需求，从来就不是单一的，而是一系列需求，所以对于软件项目的需求分析，还需要增加收集整理的步骤。整个过程是迭代进行的，如下所示：
收集需求：对用户需求进行收集整理；分析需求：对需求进行分析，挖掘用户真实需求；需求评估：筛选过滤掉不可行的需求；需求设计：针对用户需求提出解决方案，设计成产品方案；验证需求：验证方案是否可行。 收集用户需求有很多方法，这里列举部分：
头脑风暴：就是大家一起开会头脑风暴讨论；用户调研：通过调查问卷或者访谈，通过问用户一些问题收集反馈；竞品分析：通过分析其他同类产品的功能获得需求；快速原型：通过原型来收集反馈，收集确认需求。 收集了需求，就要分析用户的真实需求，这是最难的部分，也是最体现产品经理需求分析水平的地方。用户需求背后的真实需求有三个层次：
表层需求：用户对解决问题的期望，例如马车更快；深层需求：用户的深层次动机，诉求产生的原因，例如乘客对出行速度的要求；底层需求：人性本能的需求，例如对安全感对舒适的追求。 要分析好用户需求背后的真实需求，就是要结合“目标用户”和“使用场景”，按照上面三个层次去思考。
需求收集分析完了后，还需要进一步评估，以决定做还是不做，优先级如何，先做哪些再做哪些。需求评估考虑的因素有：
可行性：技术能否实现；成本：人力成本、时间成本；商业风险和收益：有没有商业上的风险，收益是否合理；紧急性与重要性：是不是用户迫切的需求。 如果确定可行，还需要评估其优先级。评估优先级一个简单的方案就是用“紧急重要四象限”的方法来区分：
复杂一点的有 KANO 模型，如下图所示：
红色曲线，是用户认为必须要有的功能；绿色曲线，就是用户明确提出的需求；黄色曲线，属于兴奋型需求，就是用户自己没想到，超出预期的功能。
在分析和评估完需求后，还需要提出解决方案，也就是对需求进行设计，做出来有效的产品设计方案。
在需求设计的时候，可以用草图、原型设计工具、界面设计工具进行设计。在需求设计阶段，可以参考其他成熟的产品。 在需求设计好后，还需要进行验证，看解决方案是否能满足用户的需求。
对需求的验证方式其实是贯穿整个软件项目生命周期的，在需求分析阶段，会反复验证确认设计好的需求是否满足用户的真实需求，比如各种设计评审产品开发完成之后，也需要有需求的验收，以确保开发出来的软件产生是客户想要的，满足客户需求的现在很多互联网产品，还有一种基于数据的验证需求方式，也就是AB测试： 设计好一个功能上线后，并不直接让所有用户使用，而是先给一小部分用户使用，然后分析数据，看使用这个功能的用户群和不使用这个功能的用户群，在营收、访问量、活跃度等关键数据上是更好还是更坏。如果好，就加大比例，如果数据不好，可能就会调整甚至取消这个功能。 需求分析 VS UML 不建议把需求分析和UML放一起理解，UML是一种用来做设计时的手段，是偏向对已经设计好的产品需求进行建模分析的。
收集需求通常是指的用户原始需求，产品经理需要进一步分析处理才能变成最终的产品需求。
用例模型一般是针对已经设计好的产品需求，对用例进行建模。
原型设计只是对产品设计的一种有效手段，但也不是唯一的手段，比如有的程序员，自己在脑子里就能构建出产品的模型，然后代码实现，都不需要借助原型。
总结 需求分析，就是一个将用户需求变成产品需求的过程。要做好用户需求的分析，需要找出来隐藏在用户需求背后的真实需求，还要针对用户的真实需求提出解决方案，最终验证方案是否能满足用户需求需求是整个产品的源头，很多软件项目失败的原因就是因为没有做好需求分析，软件中很多浪费也来源与需求没想清楚导致的返工。做好需求分析对软件项目来说非常重要要做好软件项目的需求分析，需要做好需求的收集整理工作，然后对收集好的需求进行科学的分析，评估是不是可行以及划分优先级，对可行的需求项进行设计，最后还要验证设计出的结果是不是满足需求 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ede7191dd03974872b598b44b00960ea/" rel="bookmark">
			第五章 循环程序设计示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 【例5.34】
1.定义整型i，j；
2.若i&lt;=5;转第3步,则转第步；
3.若i&lt;=20-i;转第4步;则转第5步；
4.输出" ";
5.j++;转第3步；
6.若j&lt;=2*i-1;转第7步；则转第9步；
7.输出"*";
8.j++；转第6步；
9.输出\n;
10.i++，转第2步；
9.结束；
【例5.35】
1.定义m，n，count；
2.m=rand()%(80-10+1)+10;
3.输入一个10—80之间的整数；
4.判断是否为真，转第5步，则转第13步；
5.count++；
6.若m==n；转第7步；则转第9步；
7.m&gt;n&amp;&amp;count&lt;5;
8.输出"对不起!你猜对了！再来一次！"；
9.m&lt;n&amp;&amp;count&lt;5;
10.输出"对不起！你猜大了！再来一次！"；
11.若count==5；转第12步，则转第4步；
12.输出"对不起!n你没有机会！"
13.结束；
【例5.36】
【例5.37】
1.定义x，t；
2.输入"i|tpower\n";
3.若x&lt;1000;转第4步；则第10步；
4.t=x*x;
5.若t!=0;转第6步；则转第9步；
6.若x==t%1000;转第7步；则转第8步；
7.输出x；x*x;
8.t=t/10;
9.x++，转第3步；
10.结束； 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8248df0ea8ec173ea3cec8790c7e5ec4/" rel="bookmark">
			JVM之TLAB
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、提出：
堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据，由于对象实例的创建再jvm中非常频繁，因此再并发环境下堆区中划分内存空间是线程不安全的，为了避免多个线程操作同一地址，需要使用加锁等机制，从而影响分配速度。
二、什么是TLAB；
三、图解：
四、TLAB详细说明：
a、尽管不是所有的对象实例都能够在TLAB中成功分配内存，但JVM确实是将TLAB作为内存分配的首选
b.在程序中，开发人员可以通过选项：“-XX:UserTLAB” 设置是否开启TLAB空间
c.默认情况下，TLAB空间的内存非常小，仅占整个Eden空间的1%，当然我们可以通过选项“-XX：TLABWasteTarget'Percent” 设置TLAB空间所占用Eden 空间的百分比大小。
d、一旦对象在TLAB空间分配内存失败时，JVM就会尝试通过使用加锁机制确保数据的原子性，从而直接在Eden空间中分配内存。
四、对象分配图解过程：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/743a6f817b3b1da9481cd3fb619c60d3/" rel="bookmark">
			通信与网络技术笔记（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一章 概述 1.1数据通信概述 通信——指人与人或人与自然之间通过某种行为或媒体进行的信息交流与传递。
电(光)通信指由一地向另一地进行信息的传输与交换 的传递过程。通信的目的是传递消息(messsage)中包含的信息(information)
连续消息 指消息的状态随时间是连续变化的，如话 音等。
离散消息 指消息的状态是离散的，如符号、数据等。
信号的基本形式：
模拟信号 指该信号的波形可以表示为时间的函数。
数字信号 指该信号的幅度只能取有限离散值，如0和1。
数字通信与模拟通信相比较 ：
优点抗干扰性强，保密性好，设备易于集成， 便于计算机处理等。
缺点：占用较多的带宽，信道利用率低。
1.2 数据通信系统 1.2.1 数据通信系统的模型 一个数据通信系统包括三大部分：源系统（或发送端、发送方）、 传输系统（或传输网络）和目的系统（或接收端、接收方）。
源系统
源点　它是生成数据的设备。如计算机输出的数字比特流。
发送器　通常源点生成的数据要通过发送器编码后才能够成为在 传输系统中进行传输的电磁信号。典型的发送器是调制器，它将计算机输出的数字比特流转换成可在电话网上传输的模拟信号。
传输系统
传输线或网络系统。
目的系统
接收器　接收来自传输系统的信号，并将其转换成终点可处理的信息。典型的接收器是解调器，它把来自传输线路上的模拟信号进行解调，还原出发送端产生的数字比特流。
终点　获取来自接收器数据的设备。
1.2.2 数据通信系统的主要性能指标 有效性指标 指衡量数据通信系统的传输能力的指标。常用带宽、传输速率和频带利用率等指 标来表示。
特征性指标 指衡量数据通信系统的传输质量的指标。这些指标与有效性指标有很大关系。常 用有差错率、可靠性、通信的建立时间、适应 性和可维性、经济性、标准性。
1.3 数据通信网络 按照其覆盖范围的地理范围划分为一下3种主要类型
1、广域网 广域网采用分组交换技术
2. 局域网 覆盖范围小，局域网之间相连的设备均属同一个单位
目前应用较普遍的是以太网和无线局域网
3. 城域网 1.4计算机网络概述 1.4.1 计算机网络的发展过程 internet与Internet的区别 以小写字母 “i” 开始的 internet（互连网）是一 个通用名词，它泛指由多个计算机网络通过路由器互连而成的网络。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/743a6f817b3b1da9481cd3fb619c60d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c49cb747f9da575e4f752dd17129d37/" rel="bookmark">
			CentOS 7.6的64位安装JAVA JDK
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		操作系统: 操作系统：CentOS 7.6 64位
一、卸载
1、检查自带JDK或者使用yum安装的JDK
1.1 检查jdk
rpm -qa | grep jdk 1.2 检查java
rpm -qa | grep java 1.3 结果
1.4 卸载
rpm -e --nodeps java-1.8.0-openjdk-devel-1.8.0.312.b07-1.el7_9.x86_64 rpm -e --nodeps xxxxx 1.5 全部卸载，即可完成
2、卸载离线安装的JDK(gz文件)
2.1 删除环境变量
vim /etc/profile 2.2 去掉JDK环境变量
2.3 操作生效
source /etc/profile 2.4 到对应目录把解压的jdk文件删除
2.5 打开新的终端命令界面
java -version 2.6 到对应目录把解压的jdk文件删除
2.7完成卸载离线安装的jdk
二、安装
yum命令安装 1.1 检索包含java的列表
yum list java* 1.2 结果类似于下面
1.3 选择需要的JDK版本yum命令安装
yum install -y java-1.8.0-openjdk-devel.x86_64 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c49cb747f9da575e4f752dd17129d37/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30127a229b3b6701c5d5f54b5435ca57/" rel="bookmark">
			使用ffmpeg将h264格式的RTSP实时视频流转Mp4格式保存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自己写的demo，也是在官方demo的基础上改的，做个记录 ，以后说不定用得上，转存的文件用软件看了一下格式，目测没问题
int VideoWork::saveVideoToMp4(const char *rtspUrl) { m_bStop = false; int id = (int)QThread::currentThreadId(); emit signal_sendLog(u8"子线程编码:" + QString::number(id)); /* should set to NULL so that avformat_open_input() allocate a new one */ m_pFmtContext = NULL; // char rtspUrl[] = "rtsp://admin:Overseas123@192.168.50.236:554/h264/ch33/main/av_stream"; QString name = "./" + QDateTime::currentDateTime().toString("yyyyMMdd_hhmmsszzz") + ".mp4"; char cname[256] = {0}; std::strcpy(cname,name.toStdString().c_str()); const char *filename = cname; if (avformat_open_input(&amp;m_pFmtContext, rtspUrl, NULL, NULL)!=0) { emit signal_sendLog( "could not open input file\n"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/30127a229b3b6701c5d5f54b5435ca57/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b73f3b672467b33b6e5aaa54936ee362/" rel="bookmark">
			IDEA报错IllegalStateException: No primary or default constructor found for interface……Pageable
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		报错如题 IDEA报错java.lang.IllegalStateException: No primary or default constructor found for interface org.springframework.data.domain.Pageable改前改后参考 IDEA报错java.lang.IllegalStateException: No primary or default constructor found for interface org.springframework.data.domain.Pageable 报错信息是说：找不到Pageable的主要或默认构造器
查了一下报错信息，发现相关回答比较少，有说加配置文件的。后来采用了stackoverflow上的一个solution，就解决啦！
改前 为了实现翻页，使用Spring Data库中的Pageable接口。改前在Controller中写的方法是
@RequestMapping("/page/T") public Page&lt;T&gt; getPageData(Pageable pageable) throws ParseException { return service.findAll(pageable); } 运行之后报错，报错信息如题
改后 参考了stackoverflow上的solution(链接贴在下面)
没有多写WebMvcConfig配置文件，而是把函数传参Pageable改成传翻页要用到的pageNumber和pageSize，然后在方法体中用Pageable的实现类PageRequest实现
@RequestMapping("/page/T") public Page&lt;T&gt; getPageData(@RequestParam("number") int pageNumber, @RequestParam("size") int pageSize) throws ParseException { return service.findAll(PageRequest.of(pageNumber, pageSize)); } 返回成功！
参考 stackoverflow提问下面user10367961的解决方法
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e504b99ecf84af17746babf9c517318/" rel="bookmark">
			Qt绘制直箭头和平滑的曲线箭头
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先看绘制效果：
直线箭头
曲线箭头：
直线箭头 #pragma once #include &lt;QVector&gt; #include &lt;QPointF&gt; #include "DrawGeoBase.h" //当前标绘要素 - 直箭头 class DrawGeoStraightArrow :public DrawGeoBase { public: DrawGeoStraightArrow(); ~DrawGeoStraightArrow(); virtual void draw(QPainter* p)override; virtual void mousePress(QMouseEvent * event)override; virtual void mouseRelease(QMouseEvent *event)override; virtual void mouseMove(QMouseEvent * event)override; protected: int _countOfLeftClick = 0;//鼠标左键点击的次数 QPointF _arrowBottomPt, _arrowTopPt; }; #include "DrawGeoStraightArrow.h" #include &lt;QPainter&gt; #include &lt;QMouseEvent&gt; #include &lt;QDateTime&gt; #include "CoordSysManager\CoordSysManager.h" #include "CfgProp\GeoStraightArrowProp.h" #include "UserDefineDraw\CfgProp\UserGeoCfgManager.h" #include "FileStorage\StorageStraightArrowGeo.h" #include "UserDefineDraw\Model\UserDefineDataManager.h" #include "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e504b99ecf84af17746babf9c517318/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1005eedb4bbb722142fc10f0579e0fb/" rel="bookmark">
			Attention is all you need -- 阅读笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这篇文章是2017年发表在NIPS会议上的论文，也是Transformer的开山之作。最先应用是在NLP领域的机器翻译任务上，由于其简单的结构、强悍的表现，经过几年的发展，越来越多的领域开始使用基于Transformer的深度学习网络。下面是我自己的一点学习笔记，记录下来方便以后复习。（中间有很多是在原文的基础上进行翻译的，有不准确的地方希望大家见谅，也希望大家不吝指正）
论文链接：Attention is All you Need (nips.cc)
模型代码：https://github.com/ tensorflow/tensor2tensor（代码链接在原文的第7个章节）
Abstract 目前主流（2017年以前）主流的序列转换模型基于复杂的循环或卷积神经网络，其中包含编码器和解码器。性能表现最好的模型还通过使用注意力机制将编码器和解码器连接起来。我们提出一种新的简单的网络架构——Transformer，仅仅使用注意力机制，完全抛弃了循环和卷积结构。在两个机器学习任务上的实验表明，这些模型在质量上优于其他模型，同时具有更强的并行性和更少的训练时间。我们的模型在2014年的WMT中英语转法语的翻译任务中达到了28.4的BLEU分数，比现有的最好的结果提高了2BLEU分数。在WMT 2014英法翻译任务中，我们的模型在8个gpu上进行3.5天的训练后，建立了新的单模型最先进的BLEU得分为41.8，这只是文献中最佳模型训练成本的一小部分。我们通过将Transformer成功地应用于具有大量和有限训练数据的英语选区解析，证明了Transformer可以很好地推广到其他任务。
Introduction 在引言这一部分，作者介绍的很简单，主要是说明了传统的循环模型在处理序列数据时的缺点以及Transformer在处理序列数据的优点。
循环模型的缺点：循环模型在处理序列时根据输入和输出序列的符号位置进行运算，根据时间序列一步一步的进行运算，每一步的隐藏状态都是上一步隐藏状态和位置信息的函数。简单来说，就是循环模型每进行一步都需要对上一步计算完成，这样影响了序列信息处理的并行性，也因此产生了一个问题：无法解决长时依赖。
Transformer的优点：Transformer完全基于注意力机制，构建了一种多头注意力机制（Multi-Head Attention）层，注意力机制在允许建模依赖性，不考虑元素在序列中的距离，即可以实现全局的依赖检测，解决了传统循环模型的长时依赖问题。
Model Architecture 下图是Transformer的架构图，包含两个部分：Encoder和Decoder。
图1 Transformer的结构图 上图中的Encoder和Decoder旁边都有一个的标记，这个代表的是Encoder和Decoder块的个数，原文中给的是，即Encoder和Decoder以完全相同的方式堆叠6次。
Encoder 首先是Encoder Block。它的输入是一个一个的单词，使用Input Embedding将输入词向量转换成一维的词向量表示（这里不做过多解释了，本身不是做NLP方向的，读这篇文章是为了了解Transformer的基本结构）。经过Embedding后，为输入向量添加位置编码（Positional Encoding），在原文中，使用和函数进行位置编码，公式如下所示：
其中表示维度，表示位置。也就是说，位置编码的每个维度都对应一个正弦信号（这一段是直接翻译的）。
进入到Transformer的Encoder模块，从图中可以看到，它主要有两个子层：Multi-Head Attention和Feed Forward层，辅以Layer Norm以及残差网络的跳跃连接。其中，最核心的是文章中使用了多头注意力（Multi-Head Attention）机制。
Dot-Product Attention 多头注意力机制是将单个注意力层（Head）经过堆叠得到的，在Transformer中，这里借计算机视觉中关于Transformer中Self-Attention解释的一张图片进行说明。假设将输入序列经过Input Embedding转换成维度为的向量集合，其中表示序列中元素的个数，表示每一个元素经过Embedding后的向量长度。自注意的目标是通过编码每个实体的全局上下文信息来捕获个实体之间的交互关系。为了得到个元素之间的关系
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8371f65b8727896c0bf887416ec15b80/" rel="bookmark">
			第二章 数据类型、运算符和表达式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		%c 字符 %d 整数 %f小数
2.1 引例
求体积和表面积
2.2 c语言的数据类型
数据类型包括以下
基本类型：整型、字符型、实型【浮点型】
构造类型：数组类型、结构体类型 、共用体类型、枚举类型
指针类型
空类型
2.3 c语言的常量
2.3.1 直接常量
1、整型常量
十进制：由数字0到9组成
八进制：以0为前缀，由数字0到7组成
十六进制：以ox或OX为点缀，由数字0到9和字母A到F组成
注意：
1.在一个整型常量后面加一个字母u或U,认为是unsigned int型
2.在一个整型常量后面加一个字母l或L，认为是long nt
2.实型常量
1.小数形式：由整数部分、小数点和小数部分组成，当整数部分和小数部分为0时，可以省略不写，但是小数点不可省略
2.指数形式：由尾部、字母E或e和指数部分组成，格式为：正负尾部E指数
注意：
1、以小数形式表示形式时，必须有小数，并且小数点的前、后至少一边要有数字
2、以指数形式表示实数时，字母E的前后必须有数字，并且指数部分只能是整数
3、字符型常量
1.字符常量只能用单引号括起来，不能用双引号或其它括号
2.字符常量只能是单字符，不能是字符串
3.字符可以是ASCll字符集中的任意字符
转义字符
转义字符使用示例
双引号表示字符串，单引号表示字符 4、字符串常量
字符串：空格字符、转义字符、其他字符和汉字等文字符号
2.3.2 符号常量
#define 是一条编译预处理命令，称为宏定义命令
利用符号常量计算价格
符号常量的优点
1、增加程序的可读性
2、提高程序的可维护性
3、简化程序代码
4、方便数组的定义
2.4 c语言的变量
2.4.1 变量的定义
变量名一般使用小写字母
变量的使用时，应该先赋值，后引用
不同类型的整型变量的定义与使用示例
短整型变量的溢出 实型变量的使用示例 单精度浮点型有效数字位数位7，双精度小数后最多保留6位 逗号表达式应用示例
2.5.4 求字节数运算符
不同数据类型字节数示例
求字节数运算符示例 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8371f65b8727896c0bf887416ec15b80/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5fdd9772d1a6431ac0fa4f9c336d1d39/" rel="bookmark">
			【击穿、穿透、雪崩】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我是🌟廖志伟🌟，一名🌕Java开发工程师🌕、📝Java领域优质创作者📝、🎉CSDN博客专家🎉、🌹幕后大佬社区创始人🌹。拥有多年一线研发经验，研究过各种常见框架及中间件的底层源码，对于大型分布式、微服务、三高架构（高性能、高并发、高可用）有过实践架构经验。
🍊博主：java_wxid
🍊博主：Java廖志伟
🍊社区：幕后大佬
文章目录 缓存雪崩缓存穿透缓存击穿 本文内容： 缓存雪崩 一个系统，高峰期请求为5000次/秒，4000次走了缓存，只有1000次落到了数据库上，数据库每秒1000的并发是一个正常的指标，完全可以正常工作，但如果缓存宕机了，或者缓存设置了相同的过期时间，导致缓存在同一时刻同时失效，每秒5000次的请求会全部落到数据库上，数据库立马就死掉了，因为数据库一秒最多抗2000个请求，如果DBA重启数据库，立马又会被新的请求打死了，这就是缓存雪崩。
解决方案：
事前：redis高可用，主从+哨兵，redis cluster，避免全盘崩溃 事中：本地ehcache缓存 + hystrix限流&amp;降级，避免MySQL被打死
事后：redis持久化RDB+AOF，快速恢复缓存数据 缓存的失效时间设置为随机值，避免同时失效
缓存穿透 客户端每秒发送5000个请求，其中4000个为黑客的恶意攻击，即在数据库中也查不到。举个例子，用户id为正数，黑客构造的用户id为负数，如果黑客每秒一直发送这4000个请求，缓存就不起作用，数据库也很快被打死。
解决方案：
对请求参数进行校验，不合理直接返回 查询不到的数据也放到缓存，value为空，如 set -999 “” 使用布隆过滤器，快速判断key是否在数据库中存在，不存在直接返回
缓存击穿 设置了过期时间的key，承载着高并发，是一种热点数据。从这个key过期到重新从MySQL加载数据放到缓存的一段时间，大量的请求有可能把数据库打死。缓存雪崩是指大量缓存失效，缓存击穿是指热点数据的缓存失效。
解决方案：
设置key永远不过期，或者快过期时，通过另一个异步线程重新设置key 当从缓存拿到的数据为null，重新从数据库加载数据的过程上分布式锁
总结
以上就是今天要讲的内容，还希望各位读者大大能够在评论区积极参与讨论，给文章提出一些宝贵的意见或者建议📝，合理的内容，我会采纳更新博文，重新分享给大家。
🙏四连 关注🔎点赞👍收藏⭐️留言📝
感谢大家的支持，用心写博文分享给大家，你的支持（🔎点赞👍收藏⭐️留言📝）是对我创作的最大帮助。
🍊微信公众号：南北踏尘
🍊主页地址：java_wxid
🍊社区地址：幕后大佬
给读者大大的话
我本身是一个很普通的程序员，放在人堆里，除了与生俱来的🌹盛世美颜🌹、所剩不多的发量，就剩下180的大高个了。就是我这样的一个人，默默坚持写博文也有好多年了，有句老话说的好，🌕牛逼之前都是傻逼式的坚持🌕。希望自己可以通过大量的作品，时间的积累，个人魅力、运气和时机，可以打造属于自己的🌟技术影响力🌟。同时也希望自己可以成为一个🎄懂技术🎄，🎄懂业务🎄，🎄懂管理🎄的综合型人才，作为项目架构路线的总设计师，掌控全局的🌕团队大脑🌕，技术团队中的🍊绝对核心🍊是我未来几年不断前进的目标。
提示：以下都是资源分享，求个一键三连。 面试资料
福利大放送，🎉欢迎关注🔎点赞👍收藏⭐️留言📝，拜托了🙏，这对我真的很重要。
点击：面试资料
提取码：2021
200套PPT模板
福利大放送，🎉欢迎关注🔎点赞👍收藏⭐️留言📝，拜托了🙏，这对我真的很重要。
点击：200套PPT模板
提取码：2021
提问的智慧
福利大放送，🎉欢迎关注🔎点赞👍收藏⭐️留言📝，拜托了🙏，这对我真的很重要。
点击：提问的智慧
提取码：2021
Java开发学习路线
名称链接JavaSE点击： JavaSE MySQL专栏点击： MySQL专栏JDBC专栏点击： JDBC专栏MyBatis专栏点击： MyBatis专栏Web专栏点击： Web专栏Spring专栏点击： Spring专栏SpringMVC专栏点击： SpringMVC专栏SpringBoot专栏点击： SpringBoot专栏SpringCould专栏点击： SpringCould专栏Redis专栏点击： Redis专栏Linux专栏点击： Linux专栏Maven3专栏点击： Maven3专栏 Spring Security5专栏点击： Spring Security5专栏更多专栏更多专栏，请到 java_wxid主页 查看 P5学习路线图
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5fdd9772d1a6431ac0fa4f9c336d1d39/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77ab227a4b43408996d685507581d493/" rel="bookmark">
			python----time模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、了解历史 1.计算机元年：1970年1月1日 00时00分00秒 以前计算机操作系统是32位，一个int类型的数据是32位，它表示的范围是：-2147483648 ~ 2147483647，用它来代表秒钟数进行计算：只有68.1年的时间。也就是说用这个数来表示时间如果从公元元年开始算显然不够用，所以综合当时UNIX的发展历程，取了1970年1月1日0时0分0秒做为计算机元年，用于计时的开始。
2.2038年问题 32位表示最后时间到了2038年1月19日03时14分07秒，便达到了最大值，过了这个时间点，数据越界变成最小值：-2147483648。代表的时间就是1901年12月13日20时45分52秒，出现时间回归的现象，很多依赖时间的软件就会出现异常。发展所导致的问题只能通过进一步发展解决，随着64为操作系统的普及，现在用64位操作 系统可以表示到292277026596年12月4日15时30分08秒了。也就是2900亿年以后。
3.UTC时间 在1884年，为了克服时间上的混乱，在华盛顿召开了一次国际经度会议（又称国际子午线会议），当时将全球划分为24个时区。规定英国（格林尼治天文台）为中时区，每个时区跨15经度，时间正好时1小时，最后东、西的第12时区各跨7.5度。至于为什么英国时0时区，因为当时人家牛p，是日不落。
二、常用函数 使用import time来调用time模块
1. time.time() 返回从计算机元年到现在的时间（以秒为单位）。如果系统时钟提供小数秒，则可能会出现小数秒
print(time.time()) # 输出：1638348236.3917518 2. time.thread_time() 分析线程时间：内核和用户空间CPU时间之和
print(time.thread_time()) # 输出：0.0625 3. time.clock() 返回自进程开始或之后的CPU时间或实时时间对clock（）的第一次调用。这与系统的精度一样高。
在Python 3.3中，time.clock已被弃用，并将从Python 3.8中删除：改用time.perf_counter或time.process_time
print(time.clock()) # 输出：0.0338435 4. time.sleep(secnd) 将执行延迟给定的秒数,就是让程序睡一会再跑，具体睡多久，括号里面给具体时间
print(time.sleep(2)) # 括号里是2，程序睡两秒再执行，打印会显示None 5. time.time_ns() 返回自历元以来的当前时间（以纳秒为单位）
print(time.time_ns()) # 输出：1638348716267450500 6. time.gmtime(second) 括号里不加参数，显示当前的格林尼治时间，也就是UTC时间
括号里加参数，显示从计算机元年过了（参数）秒的时间
print(time.gmtime()) 输出：time.struct_time(tm_year=1974, tm_mon=12, tm_mday=15, tm_hour=1, tm_min=6, tm_sec=0, tm_wday=6, tm_yday=349, tm_isdst=0) print(time.gmtime(10000000)) 输出： time.struct_time(tm_year=1970, tm_mon=4, tm_mday=26, tm_hour=17, tm_min=46, tm_sec=40, tm_wday=6, tm_yday=116, tm_isdst=0) 7.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/77ab227a4b43408996d685507581d493/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc247dd679fcb6fd2b8c3f9be503c6b6/" rel="bookmark">
			使用Qt&#43;Opencv实现打开图片和摄像头
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在这里演示了做一个打开图片和采用opencv打开摄像头的界面的例子。
我的环境是：Qt 5.12 + Opencv 4.5.3 + vs2017
界面效果 代码 代码还是比较简单清晰的，就直接贴上了。
MainWindow.h
#ifndef MAINWINDOW_H #define MAINWINDOW_H #include &lt;QMainWindow&gt; #include &lt;QApplication&gt; #include &lt;QTimer&gt; #include &lt;QFileDialog&gt; #include &lt;QMessageBox&gt; #include &lt;qlabel.h&gt; #include &lt;opencv2/opencv.hpp&gt; #include &lt;opencv2/core/core.hpp&gt; #include &lt;opencv2/highgui/highgui.hpp&gt; #include &lt;opencv2/imgproc/imgproc.hpp&gt; #include &lt;opencv2/imgproc/types_c.h&gt; #include "ui_MainWindow.h" using namespace cv; using namespace std; namespace Ui { class myMainWindow; } class myMainWindow : public QMainWindow { Q_OBJECT public: myMainWindow(QWidget *parent = Q_NULLPTR); //MatתQLabel QImage MatImageToQt(const Mat &amp;src); ~myMainWindow(); private slots: void readFrame(); void on_OpenImageBtn_clicked(); void on_OpenCameraBtn_clicked(); private: Ui::myMainWindowClass ui; Mat src; QImage img; QString img_name; VideoCapture cap; Mat src_image; QTimer *timer; QImage *image; }; #endif 这里注意.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc247dd679fcb6fd2b8c3f9be503c6b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8440b0e321dd867c17bdfb58e5e3246/" rel="bookmark">
			两种方法：实现输入一行字符，统计数字字符、英文字母和其他字符的个数（C语言）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C语言中：gets和getchar的区别以及指针的运用
方法一：
使用gets实现
#include&lt;stdio.h&gt;
void main()
{
char str[80], * p;
int digit,letter,other;
gets(str);
p = str;
digit = letter = other = 0;
while (*p != '\0')
{
if ((*p &gt;= 'A' &amp;&amp; *p &lt;= 'Z')|| (*p &gt;= 'a' &amp;&amp; *p &lt;= 'z'))
letter++;
else if (*p &gt;= '0' &amp;&amp; *p &lt;= '9')
digit++;
else
other;
p++;
}
printf("digit=%d letter=%d other=%d\n", digit, letter, other);
}
方法二：
使用getchar实现
#include&lt;stdio.h&gt;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b8440b0e321dd867c17bdfb58e5e3246/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7961910e752f3c73a5ecfde94fd866e/" rel="bookmark">
			解决Elsevier cas-dc Class, 在双栏情况下并排图片出现的标题错位问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Elsevier 新出的cas-dc 的双栏模板中，如果插入并排图片会出现标题错位的情况，如下图：
之前想修复，参考了以下回答也没用。
Placing three figures side by side, each with its own caption
\begin{figure*} \begin{minipage}[t]{0.48\linewidth} \includegraphics[width=\linewidth]{figs/Fig1.pdf} \caption{Problems due to rivet aging} \label{fig-problemofrivet} \end{minipage} \hfill \begin{minipage}[t]{0.48\linewidth} \includegraphics[width=\linewidth]{figs/Fig1.pdf} \caption{Example of rivet replacement by the bolt} \label{fig-rivetrepla} \end{minipage} \end{figure*} 解决方案 这是由于Elsevier cas-dc 的硬性设计有缺陷而导致的
具体的构造包是→cas-common.sty
在导言区加入以下补丁，可以解决这个问题，如下：
虽然不太建议这么做。
\ExplSyntaxOn \exp_args:NNno \exp_args:Nno \use:n { \cs_gset:Npn \__make_fig_caption:nn #1#2 } { \exp_after:wN \use_ii_i:nn \exp_after:wN { \__make_fig_caption:nn {#1} {#2} } { \dim_set:Nn \l_fig_width_dim \linewidth } } \exp_args:NNno \exp_args:Nno \use:n { \cs_gset:Npn \__make_tbl_caption:nn #1#2 } { \exp_after:wN \use_ii_i:nn \exp_after:wN { \__make_tbl_caption:nn {#1} {#2} } { \dim_set:Nn \l_tbl_width_dim \linewidth } } \ExplSyntaxOff 修复实例 \documentclass[]{cas-dc} \newlength\bibsep % class is broken.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d7961910e752f3c73a5ecfde94fd866e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/090477c1b460bd05d7c94665752ecee7/" rel="bookmark">
			mysql主从同步时,多库同步到一个库时,表结构同步失败
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目上有一个mysql主从,是将过个master同步到一个slave上.所以会使用到
--replicate-rewrite-db=old_name-&gt;new_name 修改数据库名称.
前期配置好以后,同步数据正常,一切参数也很正常.知道有一次修改了master上一个表的结构.发现,表的结构并没有同步到slave上.然后就开启了排除问题的道路.
一 ,期初以为是主从同步异常了,然后通过名称
show slave status; 发现状态都是正常
二, 查看binlog日志
通过命令
how binlog events; show binlog events in 'mysql-bin.000002'; 查看master上binlog日志,找到修改表结构时,记录下来的日志记录.
在查看slave上,记录的日志
show RELAYLOG EVENTS; show RELAYLOG events in 'mysql-bin.000002'; 也找到了表修改结构执行的语句.
这个就尴尬了......
查看执行的语句,发现有这么一句
use `ylzx_purchase_order`; ALTER TABLE `ylzx_purchase_order`.`p_order_check` MODIFY COLUMN `djzq` varchar(60) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL COMMENT '描述' AFTER `enter_id` 前面有一句 use '库名';这是进库的操作,但因为我是将多个数据源同步到一个地方,所以使用--replicate-rewrite-db=old_name-&gt;new_name 将原始库名修改为了新的库名,但这里执行的语句,使用的是原始库名.感觉像是找到了问题所在.但转念一下,不对啊.其他更新也是正常的,为什么这个就不行,抱着试一试的想法,我更新了一条数据来看具体的执行语句.
悲催的发现,更新数据时,也是带的原始库名称,虽然没有进库的操作语句,但不能证明是这个的进库操作导致的同步失败,因为没有办法绕过这个进库操作.无奈之下又开始找其他原因.
三,从官网上找问题
后来实在没有办法.想到去看看官网上市如何解释 --replicate-rewrite-db=old_name-&gt;new_name配置项用法的,结果还真有这么一句话.
翻译过来就是
--replicate-rewrite-db=old_name-&gt;new_name这个配置项,在替换库名时,只对部分语句起作用,像如 CREATE ,DROP,ALTER DATABASE这类语句,是不起作用的.所以在执行时,不会去替换为配置的新库名执行.所以导致同步失败了.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba5e5af301c24545a5d5b0b8e5c21de3/" rel="bookmark">
			ArrayList集合---案例斗地主（注意：里面的List.of不是错了是jdk9以后的新特性，jdk9以前没有）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		package anliti; import java.util.ArrayList; import java.util.Collection; import java.util.Collections; import java.util.Random; /* 斗地主案例： 1准备牌 2洗牌 3发牌 4看牌 */ public class DouDiZhu { public static void main(String[] args) { //1准备牌 //定义一个存储54张牌的ArrayList集合 泛型使用String ArrayList&lt;String&gt; poker = new ArrayList&lt;&gt;(); //定义两个数组 一个存储牌的花色 一个数组存储牌的序号 String[] colors ={"♠","♥","♣","♦"}; String[] numbers ={"2","A","K","Q","J","10","9","8","7","6","5","4","3",}; // 先把大王存储到poker中 poker.add("大王"); poker.add("小王"); //循环嵌套遍历两个数组，组装52张牌 for(String number:numbers){ for (String color : colors) { // System.out.println(color+number); //把组装好的牌存储到poker中 poker.add(color+number); } } //System.out.println(poker); /* 洗牌 使用集合工具类Collections中的方法 static void shuffle(List&lt;?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba5e5af301c24545a5d5b0b8e5c21de3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f7199aef72345f57251d4d4be0e2415/" rel="bookmark">
			Vue页面不销毁
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 定义路由
{ path: 'endpoint', name: '终端sm', meta: { keepAlive: true }, component: () =&gt; import ('@/pages/scan/newScan') }, 路由出口
&lt;keep-alive&gt; &lt;router-view ref="page" v-if="$route.meta.keepAlive" /&gt; &lt;/keep-alive&gt; &lt;router-view ref="page" v-if="!$route.meta.keepAlive" /&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95f367e59d122395f243e89d6e7f9d28/" rel="bookmark">
			Git stash深解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们随手做的 git stash，究竟干了什么？
git stash 是程序员的至宝。老板 biangbiang 甩来一个 case，说这个要下班之前 hot fix
，咋办，stash，切到 release 对应的分支，缝缝补补；产品 kuangkuang 砸来一个需求更新，说这个简单，小哥哥帮帮我先做了，咋办，stash 切一个新的 feature 分支，撸袖子干。如果没有 git stash，人生至少要灰暗一半。
git 执拗，如果你手头上的活没提交，它拒绝切换分支的请求 —— 这挺合情合理，因为切换分支（其实就是切换到历史上的某个 commit，如果 git checkout -b 就建立一个 ref 指向当前 HEAD）涉及到工作目录的更新，以及 git 索引的重建，如果当前的工作目录修改了，git 总不能将你辛辛苦苦的成果抹去吧。
所以 git stash 显得格外亲切。它帮你把手头未完成还不好提交（提交必然牵扯 commit-hook，又是运行单元测试又是静态检查的）的活收拢到一个暂存区，等新任务完成了可以再 git stash pop 恢复之前的工作。它的产品机理，像极了 CPU 的 exception，所以说程序员来来回回就那么几出戏，只不过在不同的场景下粉饰一下改头换面上演而已。
那么，git stash 背后究竟干了什么？这其实是我在推进 gitrocks 需要探索的。来来来，动次打次，动次打次，敲起你的茶柚，抖起你的肩儿，我们一起 type（wow, you can really type~）。
第一遍尝试 建立一个新的 repo，git add hello.txt (内容：hello world!\n)，然后 git commit -a -m "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/95f367e59d122395f243e89d6e7f9d28/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4023388bd88a0107f5190ac121a9ad29/" rel="bookmark">
			CSS 语法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 CSS 规则集（rule-set）由选择器和声明块组成：
选择器指向您需要设置样式的 HTML 元素。
声明块包含一条或多条用分号分隔的声明。
每条声明都包含一个 CSS 属性名称和一个值，以冒号分隔。
多条 CSS 声明用分号分隔，声明块用花括号括起来。
实例 在此例中，所有 &lt;p&gt; 元素都将居中对齐，并带有红色文本颜色：
p { color: red; text-align: center; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d068088785ba05214e473b671fd8b00/" rel="bookmark">
			关于进程和线程知识点梳理（万字文章）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在看《现代操作系统》这本书的第二章“进程和线程”，同时结合网上查找资料的学习，将进程和线程以及常见的一些问题整理如下：
进程 概念 一个进程是一个正在执行程序的实例的抽象，包括程序计数器、寄存器和程序变量的当前值等操作系统的其他所有内容都是围绕着进程展开的进程是操作系统进行资源分配和调度的一个基本单位 多道程序设计 多道程序设计是在计算机内存中同时存放几道相互独立的程序，使它们在管理程序控制之下，相互穿插的运行，宏观上让人感觉程序是并行执行的、微观上其实是串行执行的：
CPU 从一个进程切换到另外一个进程，使每个进程在一段时间内都可以获得运行的机会单个 CPU 可以被若干进程共享，通过调度算法进行进程间的切换在多核系统中，每一个核只能一次运行一个进程多道程序设计可以使系统中的各种资源尽可能地满负荷工作，从而提高整个计算机系统的使用效率 进程的创建 方式: 系统初始化时创建 守护进程前台进程 正在执行的进程通过系统调用创建另外一个进程用户请求创建一个新进程批处理创建 操作系统决定它有资源来运行另一个任务时，它将创建一个新进程并从其中的输入队列中运行下一个作业 本质: 执行了一个用于创建进程的系统调用 UNIX 系统调用 fork 函数创建windows 调用 CreateProcess 函数创建 父进程和子进程拥有各自的地址空间，不可以相互修改不可写的内存区是可以共享的 进程的关闭 正常退出: UNIX 执行 exitwindows 执行 ExitProcess 异常退出: 可预先感知的错误退出（自愿的）代码异常等不可以预先感知的严重错误（非自愿的） 被其它进程杀死: windows 中 TerminateProcessUNIX 执行 kill 系统调用 进程间的结构 UNIX 进程体系: 进程有父子关系，成树状结构，所有的进程都属于 init 为根的一棵树进程和它的所有子进程以及子进程的子进程共同组成一个进程组 Windows 进程体系: Windows 中没有进程层次的概念，Windows 中所有进程都是平等的 进程的状态 三种状态: 运行 进程实际占用 CPU 就绪 可运行，因为其他进程占用 CPU 而停止运行 阻塞 除非某种外部事件发生，否则进程不能运行 状态之间的转换: 运行 -&gt; 阻塞: 等待输入而阻塞 阻塞 -&gt; 就绪: 出现有效输入 就绪 -&gt; 运行: 调度程序选择当前进程 运行 -&gt; 就绪: 调度程序选择另外一个进程 进程的实现 操作系统为每个进程分配一个进程控制块（PCB），用来保存与该进程有关的各种状态信息，PCB 是进程存在的唯一标志，操作系统用 PCB 来描述进程的基本情况以及运行变化的过程，进程的任何状态变化都会通过 PCB 来体现，PCB 中主要包括下面内容：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d068088785ba05214e473b671fd8b00/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07154fcdbe62f1b81929f9fecdaebc9b/" rel="bookmark">
			【高并发/高可用/哨兵机制/集群模式/高可用与主备切换/主从复制/断点续传】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我是🌟廖志伟🌟，一名🌕Java开发工程师🌕、📝Java领域优质创作者📝、🎉CSDN博客专家🎉、🌹幕后大佬社区创始人🌹。拥有多年一线研发经验，研究过各种常见框架及中间件的底层源码，对于大型分布式、微服务、三高架构（高性能、高并发、高可用）有过实践架构经验。
🍊博主：java_wxid
🍊博主：Java廖志伟
🍊社区：幕后大佬
文章目录 高并发/高可用/哨兵机制/集群模式/高可用与主备切换/主从复制/断点续传高并发高可用哨兵机制Redis 哨兵主备切换的数据丢失问题异步复制导致的数据丢失 集群模式集群协议集中式gossip 协议 Redis cluster 的高可用与主备切换原理主从复制原理主从架构下的数据部分复制（断点续传） 本文内容： 高并发/高可用/哨兵机制/集群模式/高可用与主备切换/主从复制/断点续传 高并发 单机的 Redis，能够承载的 QPS大概就在上万到几万不等。对于缓存来说，一般都是用来支撑读高并发的。因此架构做成主从(master-slave)架构，一主多从，主负责写，并且将数据复制到其它的slave 节点，从节点负责读。所有的读请求全部走从节点。这样也可以很轻松实现水平扩容，支撑读高并发。
高可用 Redis哨兵集群实现高可用，哨兵是一个分布式系统,你可以在一个架构中运行多个哨兵进程,这些进程使用流言协议来接收关于主节点是否下线的信息,并使用投票协议来决定是否执行自动故障迁移,以及选择哪个备节点作为新的主节点。每个哨兵会向其它哨兵、主节点、备节点定时发送消息,以确认对方是否”活”着,如果发现对方在指定时间(可配置)内未回应,则暂时认为对方已挂.若“哨兵群”中的多数哨兵,都报告某一主节点没响应,系统才认为该主节点"彻底死亡",通过算法,从剩下的备节点中,选一台提升为主节点,然后自动修改相关配置。
哨兵机制 哨兵是一个分布式系统，你可以在一个架构中运行多个哨兵进程，这些进程使用流言协议来接收关于主节点是否下线的信息，并使用投票协议来决定是否执行自动故障迁移，以及选择哪个备节点作为新的主节点。每个哨兵会向其它哨兵、主节点、备节点定时发送消息，以确认对方是否”活”着，如果发现对方在指定时间(可配置)内未回应,则暂时认为对方已挂。
若“哨兵群”中的多数哨兵，都报告某一主节点没响应，系统才认为该主节点"彻底死亡"，通过算法，从剩下的备节点中，选一台提升为主节点，然后自动修改相关配置。可以通过修改sentinel.conf配置文件，配置主节点名称，IP，端口号，选举次数，主服务器的密码，心跳检测毫秒数，做多少个节点等。
Redis 哨兵主备切换的数据丢失问题 异步复制导致的数据丢失 master-&gt;slave 的复制是异步的，所以可能有部分数据还没复制到 slave，master 就宕机了，此时这部分数据就丢失了。 脑裂导致的数据丢失：某个 master 所在机器突然脱离了正常的网络，跟其他 slave 机器不能连接，但是实际上 master还运行着。此时哨兵可能就会认为 master 宕机了，然后开启选举，将其他 slave 切换成了 master。这个时候，集群里就会有两个master ，也就是所谓的脑裂。 此时虽然某个 slave 被切换成了 master，但是可能 client 还没来得及切换到新的master，还继续向旧 master 写数据。因此旧 master 再次恢复的时候，会被作为一个 slave 挂到新的 master上去，自己的数据会清空，重新从新的 master 复制数据。而新的 master 并没有后来 client写入的数据，因此，这部分数据也就丢失了
解决方案：
进行配置：min-slaves-to-write 1 min-slaves-max-lag 10
通过配置至少有 1 个 slave，数据复制和同步的延迟不能超过 10 秒，超过了master 就不会再接收任何请求了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07154fcdbe62f1b81929f9fecdaebc9b/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/311/">«</a>
	<span class="pagination__item pagination__item--current">312/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/313/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>