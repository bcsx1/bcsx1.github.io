<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4cdc643f0bbdbbc0eaa95d7f3851a407/" rel="bookmark">
			L1-8最佳情侣身高差
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 L1-8. 最佳情侣身高差 时间限制 400 ms 内存限制 65536 kB 代码长度限制 8000 B 判题程序 Standard 作者 陈越 专家通过多组情侣研究数据发现，最佳的情侣身高差遵循着一个公式：（女方的身高）×1.09=（男方的身高）。如果符合，你俩的身高差不管是牵手、拥抱、接吻，都是最和谐的差度。
下面就请你写个程序，为任意一位用户计算他/她的情侣的最佳身高。
输入格式：
输入第一行给出正整数N（&lt;=10），为前来查询的用户数。随后N行，每行按照“性别 身高”的格式给出前来查询的用户的性别和身高，其中“性别”为“F”表示女性、“M”表示男性；“身高”为区间 [1.0, 3.0] 之间的实数。
输出格式：
对每一个查询，在一行中为该用户计算出其情侣的最佳身高，保留小数点后2位。
输入样例： 2 M 1.75 F 1.8 输出样例： 1.61 1.96 #include&lt;iostream&gt; #include&lt;stdio.h&gt; using namespace std; int main() { int N; cin&gt;&gt;N; for(int i=0;i&lt;N;i++){ string sex; float H; cin&gt;&gt;sex&gt;&gt;H; if(sex=="M"){ printf("%.2f\n",H/1.09); }else{ printf("%.2f\n",H*1.09); } } return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae14b06c44895963d8d0e175fcde1d80/" rel="bookmark">
			【图论】欧拉图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		所谓的欧拉图，就是我们小时候经常玩的一种"一笔画"游戏，从任意一个点出发，经过所有的边。而我们将这个模型抽象出来，对边和起点加了不同的限制，就得到了不同的定义。
欧拉通路: 通过图中每条边且只通过一次，并且经过每一顶点的通路。
欧拉回路: 通过图中每条边且只通过一次，并且经过每一顶点的回路。
欧拉回路相关定理： 1、无向图为欧拉图（欧拉回路），当且仅当为连通图且所有顶点的度为偶数。 2、无向图为半欧拉图（欧拉通路），当且仅当为连通图且除了两个顶点的度为奇数之外，其它所有顶点的度为偶数。 3、有向图为欧拉图（欧拉回路），当且仅当的基图连通，且所有顶点的入度等于出度。（忽略有向图所有边的方向，得到的无向图称为该有向图的基图。） 4、有向图为半欧拉图（欧拉通路），当且仅当的基图连通，且存在顶点的入度比出度大1、的入度比出度小1，其它所有顶点的入度等于出度。 求无向图的欧拉回路：
Hdu1878 题意：欧拉回路是指不令笔离开纸面，可画过图中每条边仅一次，且可以回到起点的一条回路。现给定一个图，问是否存在欧拉回路？若欧拉回路存在则输出1，否则输出0。
思路：：1、底图是连通的，可用并查集判断。2、不存在度数为奇数的点。 #include &lt;cstdio&gt; #include &lt;cstring&gt; const int N=1005; int father[N],degree[N]; int find (int x) { if (x==father[x]) return x; return father[x]=find(father[x]); } int main () { int n,m,i; while (scanf("%d",&amp;n),n) { scanf("%d",&amp;m); for (i=1;i&lt;=n;i++) father[i]=i; memset(degree,0,sizeof(degree)); while (m--) { int a,b; scanf("%d%d",&amp;a,&amp;b); father[find(b)]=find(a); degree[a]++; degree[b]++; } int p=father[1],flag=1; for (i=1;i&lt;=n;i++) if (father[i]!=p||degree[i]&amp;1) { flag=0; break; } printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae14b06c44895963d8d0e175fcde1d80/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc22966494bfbc6963f65f51c3417c29/" rel="bookmark">
			Linux Kernel设备驱动模型之class 查找设备
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/** * class_find_device - device iterator for locating a particular device * @class: the class we're iterating * @start: Device to begin with * @data: data for the match function * @match: function to check device * * This is similar to the class_for_each_dev() function above, but it * returns a reference to a device that is 'found' for later use, as * determined by the @match callback. * * The callback should return 0 if the device doesn't match and non-zero * if it does.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc22966494bfbc6963f65f51c3417c29/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2160e10d926473b19d2ead88298c7505/" rel="bookmark">
			删除链表中指定的元素
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 删除链表中的元素 问题描述 ：删除链表中等于给定值val的所有节点 如给定1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;NULL和val=3，返回1-&gt;2-&gt;4-&gt;NULL。 解题思路 ：遍历单链表，若有结点的值等于给定的值val，则让此结点前一个结点的指针指向此结点后面的结点。 实现代码 ： class Solution {
public:
/**
* @param head a ListNode
* @param val an integer
* @return a ListNode
*/ } ListNode *removeElements(ListNode *head, int val) { // Write your code here ListNode *dummy=new ListNode(0); //创建新结点 dummy-&gt;next=head; head=dummy; while(head-&gt;next!=NULL) { if(head-&gt;next-&gt;val==val) { head-&gt;next=head-&gt;next-&gt;next; } else {head=head-&gt;next;} } return dummy-&gt;next; } }; A题感悟：由于长时间没有编程，所以此题虽然简单但是A过却不简单。对刚学过的知识点理解不透彻，导致出现了不少编译错误。最大的感想是熟能生巧！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3206fc9c1b93dca23ed679c0f2bc3ae/" rel="bookmark">
			Linux shell脚本的建立与执行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在进行 linux 测试时编写脚本是必不可少的。最近经常使用 Linux，感觉太频繁地敲击键盘有些累了，于是想到了 Shell 脚本。可以把太多的命令写成一个脚本，这样每次执行一遍 shell 文件，就可以省去了敲击键盘的时间。于是在网上搜了一些有关 Linux 下脚本编程的内容。
Shell 不仅仅是命令的收集，而且是一门非常棒的编程语言。您可以通过使用 shell 使大量的任务自动化，shell 特别擅长系统管理任务，尤其适合那些易用性、可维护性和便携性比效率更重要的任务。
用户可以使用任何文本编辑器编辑 shell 脚本文件，例如 VI、gedit 等。
Shell 脚本的名称可以随便定义，也不要什么后缀名，例如可以写 abc，smartzip 这类名称。
下面我们开始编写一个 Shell 脚本：
1. 程序必须以下面的行开始（必须放在文件的第一行）： #!/bin/sh 符号 #! 用来告诉系统它后面的参数是用来执行该文件的程序。在这个例子中我们使用 / bin/sh 来执行程序。
2. 注释 在进行 shell 编程时，以 #开头的句子表示注释，直到这一行的结束。如同其他编程语言一样，我们在编写脚本时也应该尽可能地添加注释，那么即使相当长的时间内没有使用该脚本，我们也能在很短的时间内明白该脚本的作用及工作原理。
3. 变量 在其他编程语言中您必须使用变量。在 shell 编程中，所有的变量都由字符串组成，并且您不需要对变量进行声明。要赋值给一个变量，您可以这样写：变量名 = 值 取出变量值可以加一个美元符号（$）在变量前面： #!/bin/sh #对变量赋值： a="hello world" # 现在打印变量 a 的内容： echo "A is:" echo $a
4. Shell 命令和流程控制 在 shell 脚本中可以使用三类命令： 1)Unix 命令: 虽然在 shell 脚本中可以使用任意的 unix 命令，但是还是由一些相对更常用的命令。这些命令通常是用来进行文件和文字操作的。 常用命令语法及功能 echo "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c3206fc9c1b93dca23ed679c0f2bc3ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c795bed9ff2e09b41accddd402e0e2ad/" rel="bookmark">
			php 支付宝用户信息授权
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好 这是我的第一篇文章 我是一名非常菜鸟的PHP程序员 今天做了一下支付宝的授权接口分享一下 希望能帮助大家
首先进入支付宝沙箱环境应用页
https://openhome.alipay.com/platform/appDaily.htm?tab=info
然后下载支付宝的SDK 下面是CI框架下的代码
class Authorize extends CI_Controller { //沙盒环境参数 private $appid = '2016080400164499'; private $url = "https://openauth.alipaydev.com/oauth2/publicAppAuthorize.htm"; private $alipay_api = "https://openapi.alipaydev.com/gateway.do"; public function __construct () { parent::__construct(); include_once APPPATH.'libraries/Alipay/AopSdk.php'; $this-&gt;AopClient = new AopClient(); $this-&gt;load-&gt;helper('function'); } //授权和回调 public function auth() { //获取url参数 $params = $this-&gt;input-&gt;get(NULL,true); //首次进入跳转到支付宝授权口 if(!isset($params['auth_code'])) { $redirect_url = urlencode('http://bxu2442160182.my3w.com/index.php/Authorize/auth'); $auth_url = $this-&gt;url ."?app_id={$this-&gt;appid}&amp;scope=auth_user&amp;redirect_uri={$redirect_url}&amp;state=test"; $this-&gt;load-&gt;view('Authorize', array('auth_url'=&gt;$auth_url)); //支付宝回调处理 } else { //获取支付宝回传的参数 $auth_code = $params['auth_code']; //组装请求支付宝获取会员ID $this-&gt;AopClient-&gt;gatewayUrl = $this-&gt;alipay_api; $this-&gt;AopClient-&gt;appId = $this-&gt;appid; $this-&gt;AopClient-&gt;rsaPrivateKey = 'MIIEowIBAAKCAQEAr9BL7Ec7LXugVmonLu4r4CUEbSoQVr+vkcVZFnypdaW1sT0ywK1mlLtgIUTtwpFveNO5O0O2p5i79HXrNq2Ca/VvR+hM5QvmDv/g5pEMYJBpj06T9LD7/B9pByob0a77IiUmUMNYJOADdlE4r0yUekO0A7hswbeB2HDOFVjPLn17jQCiMrCZmn4K8OD25BDB5P64R1C71CDcs5kzLhuOI7kQPPg9e5P/mDt03lugPP/2t0xLGuY6eHmtSLrA8su7TjknXy+CNCv0OouynV+M12vwaGR0KxUaZxiQnFXUoRfHS/B+5xi5hTX5mF+yl8qrUAQRvJ7CYTXSTZgNJvxY4QIDAQABAoIBAGS5JuYEoQibrO4U/sHKPWS6kGCiGp44TzNqJnHVlZgLCZ6y+uKb9Qr8lkQ5IyW3AG/ujE5BquE1hWi2Lb0zhmanQ8ukcHlAadrqCUTOkJK56V/qmqUyyApXTGqIW0uzvbiAJAVdBKCLnjAotBrp+p5ZL0Z6YARTR5Zieg6MxJVS50+VfJ1euQ3SHaU20IRvCKdCs5YQ8GBSzTFiVEyl12g9L6q0bbcb4oj2CDbHmuI2aUhuL1zneKpCraVbdZ+acE68u7g+RHVl86Bcv2eAleJnqg7ZoEF7IDMnEE18h86D9z+IkFOJ9Oer0YJrsCIrc8hmoUzt47Moz7/nQJ+WTOECgYEA2U7gAFEI03OrE8l9+LwkOWd8qQL3hdtlH+tQqT3rgvZd8LhyCgRAwEMh4Do2UYQIcChyFeT4XVzBZAD3BlClkY3DmLfZ3p3kCoKavOqeUXDRep8MBlb7X/PI3Bg6UvqymhaNIYAGMCB9cLGFE7gZ9Bkng6v4aIOjnyRHCPe81q0CgYEAzx4P95FsDnMA+p9DURlSfJVgYpTXfxUd4iU4VzePiloDBISXfUjCR3DAR7YpMjylkrPWpm2PkcuOA27y2be1R6YbLzDVH3Na0egoYWl/wNQGzL5ev7VzGtUCTrcMUfEnE70g0bVisIvyy8Kq+/HQ8HY24sdU0EBZ5tiYNaALNYUCgYBAknF5ZprqykohnRPzn2RcMmYWiq0md2T7MR9Myvt6dN7BMu2gEFd1Sf189Y9CdatUOJB99QXgKDnHD4pXtAsezzM55Be3UM98WAbG8CiPJqj4eN5H2/ziLDyZOhHKqnf71YumUraEAoODwxw6GdCMehUFyUoNNGCgX1VEUukoGQKBgQCdReGwBzA7ZJ64sNkoKwdU7QUMtqNQr9NKVyMKL3mDAEjMVHbIPsiwAPExQyTTLfQ4ivES3Z0og55qAwTLyFESgBKiaf1b7Xdob1bCaZ8F6LrlHCXMg1dNZ7Rh22OykWEv/ux98bNoBk0u5rp5qC0Ve17AI8bGgCcEQTKLfeUlFQKBgER/srWy87C64lTmhctdNBjUrUjJOXQcN5uk8nIE1qigiAEmQT08X4Z0xDpY9ejpDQviLC1sIrEfY2TY9890wjJ499ZYrqbcx0yJ+FgiuADm/NX0331O69MnxfNUKmsYNP1abONzNFjhY/HEDiOIlxjX2C/UUJmlXzTpowexZkon'; $this-&gt;AopClient-&gt;alipayrsaPublicKey='MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAr9BL7Ec7LXugVmonLu4r4CUEbSoQVr+vkcVZFnypdaW1sT0ywK1mlLtgIUTtwpFveNO5O0O2p5i79HXrNq2Ca/VvR+hM5QvmDv/g5pEMYJBpj06T9LD7/B9pByob0a77IiUmUMNYJOADdlE4r0yUekO0A7hswbeB2HDOFVjPLn17jQCiMrCZmn4K8OD25BDB5P64R1C71CDcs5kzLhuOI7kQPPg9e5P/mDt03lugPP/2t0xLGuY6eHmtSLrA8su7TjknXy+CNCv0OouynV+M12vwaGR0KxUaZxiQnFXUoRfHS/B+5xi5hTX5mF+yl8qrUAQRvJ7CYTXSTZgNJvxY4QIDAQAB'; $this-&gt;AopClient-&gt;apiVersion = '1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c795bed9ff2e09b41accddd402e0e2ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4459f0be084ddc7b558e5d0c4ea5046a/" rel="bookmark">
			同一台机器如何同时使用多个Git账号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 转载链接：http://blog.csdn.net/wj2030/article/details/46763477?ref=myread
说说关于一台机器如何支持多个Git帐号，我的情况是这样。通常，我开发的项目都是托管在Oschina上，因为感觉Github有时候网络不是很好，所以方便起见，就申请了一个Oschina的帐号，平时也可以去上面看看优秀的项目。但是，自己还有一个Github的帐号。这个时候在本地使用git时就非常尴尬了，很久之前配置过同时支持两个Git帐号的，最新实验室给配置了台新电脑，就得重新折腾一下，现在做个记录。当前电脑环境为Win7具体ubuntu上应该和这个类似。
1.如果本机上已经有添加过自己的git帐号，找到git生成的密钥的目录,如果没有调到第三步：
C:\Users\WJ\.ssh
2.修改当前目录下的密钥文件的名字，
id_rsa_oschina id_rsa_oschina.pub
3. 为自己的github帐号创建相应的密钥
ssh-keygen -t rsa -C "my_github_emial"
Enter file in which to save the key (/c/Users/WJ/.ssh/id_rsa): id_rsa_github (这里输入我们定义的名字以便和oschina的有区别, 然后一路回车)
4. 生成完成后，会在本地的ssh目录下出现刚刚生成的密钥文件:
可以看到名字是有相应的区别。
5. 编写配置文件，支持两个帐号自动登录
在改目录下创建config文件，并编写以下内容：
可以参考我的内容，填写自己的相应的个人信息。
6.删除本地全局设置
如果之前使用过程中使用过git config --global user.name "" 或者 git config --global user.email 命令，git会在C盘目下产生一个.gitconfig文件，这个文件中保存了全局的git帐号信息，应该删除掉。
7.测试设置是否正确：
至此，设置已经ok，具体后面使用中什么问题，待我探索后再来编写。
﻿﻿ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19361415d16834a64c64484233f46a19/" rel="bookmark">
			用hibernate调用存储过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		存储过程是将一组需要重复执行的操作封装在一起存放在服务器中,支持用户提供的变量,具有强大的编程功能, 可以使用各种sql语句和过程式语句的组合，来封装数据库应用中复杂的业务逻辑和处理规则.
使用存储过程的优点就是: 1.存储过程是预编译的可执行代码,提高效率 2.将常用的操作集编写成存储过程,一次编写可多次使用,程度可重用
Hibernate中使用存储过程有很多种方法, 1. 使用hibernate命名查询 2. 使用JDBC的方法 大概方法如下 a) 获取hibernatesession b) 用session获取Connection c) 实例化ResultSet d) CallableStatement call= conn.prepareCall(“{ 存储过程执行语句}”); e) 返回数据,关闭数据库连接,和session连接
使用Hibernate中的SQLQuery接口执行 这个方法获取数据比较简单,今天就使用这个方法来查询数据 详细过程: a) 创建表,使用DDL语句
代码部分: DROP TABLE IF EXISTS t_user; CREATE TABLE t_user ( user_id int(11) NOT NULL AUTO_INCREMENT, user_name varchar(30) NOT NULL, user_pwd varchar(20) DEFAULT NULL, PRIMARY KEY (user_id) ) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8;
b) 向表内插入数据使用DML语句 代码部分 INSERT INTO t_user VALUES(数值1,数值2,….);
c) 创建存储过程 代码部分:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/19361415d16834a64c64484233f46a19/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92c4bc7228231c48b58aff360c5fa5ca/" rel="bookmark">
			基于OpenCV的车牌识别系统之二 ——字符分割与识别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于OpenCV的车牌识别系统之二——字符分割与识别
车牌定位完之后就是车牌的字符识别，字符识别又分为字符分割和字符识别。字符分割的步骤采用OpenCV中寻找外轮廓函数，并根据字符轮廓在车牌图像上分割出字符图像。字符识别采用三层神经网络。本程序中采用OCR最常见的特征提取方法：首先将每个字符归一化为20*20的字符，然后在每个字符中提取出一个1*440的特征向量，这440个特征中400为统计每行和每列的像素值个数并保存到新的数据组中，采用minMaxLoc得出数据组中最大的像素值，然后这个数据组中每个像素除此这个值。40为20行和20列统计的非零像素值得个数。这就是特征向量的结构解析。知道这个特征向量是怎么来的，这样就可以写自己ANN离线训练的数据集了。
本程序最初的方法也是采用的书上--《深入理解Opencv实用计算机视觉项目解析》的字符分割方法，首先得到一张车牌图片，然后根据最大类间法（Otsu）得到一张较好的车牌二值化图像，之后采用findCounters寻找最外围轮廓并计算其最小外接矩形的大小--这些轮廓所包围的区域全部最为粗选的字符备选区域。然后将这些备选区域依次送入字符验证函数（下面单独介绍字符函数），当统计的通过字符验证函数有且只有7个字符时，则进行下一步—在原图上裁剪出字符区域。得到字符区域之后采用直方图均质化等等预处理。然后依次对7个字符排序，最后在将每个字符归一为20*20的图像。字符识别使用ANN算法采用三层神经网络，输入层经元数是离线训练数据集的行数，隐含层的神经元个数是20，输出层的神经元是类别的种类数。然后依次对每个字符运用ANN.predict函数得出1*类别数的数据组（数据组中是记录这个字符跟每个类别的“相似度”），使用minMaxLoc函数才找出最大概率的类别。返回其位置。根据返回数据打印出字符。但是这个程序前提的是要能精准的找到车牌位置，但是实例中很难精准的找到车牌位置。其系统结构图如图下所示：
该系统在实际的实现的过程中存在有几个问题：
1. 车牌的二值化图像边框和柳钉没有清除干净会直接影响到后续的寻找轮廓。
2. 车牌的第一个字符，各种省份汉字（例如：粤，鄂字符）根本在20*20分辨率下的字符无法精确区分。
3. 车牌的第一个字符，例如川、沪等字时，字体容易分开，导致往往通不过验证函数。
那么怎么解决这些问题呢？
首先第一个问题比较容易解决，但解决的效果有待进一步加强。其想法是对车牌二值化图像行和列扫描。当行扫描时跳变小于某个阈值时，则认为这行数据中不包含字符信息，这行的像素直接置0。这样去除掉上、下边框和铆钉的影响。当扫描完行之后，直接在前端和末端抹掉两列（经验值）信息。这是为了去掉左右边框的影响。左图为含有边框噪声之图像，右图为消除边框噪声之后的图像，但是还有少量的噪点信息。
其次第二问题，这些车牌的首个汉字怎么解决，本程序是采用双ANN，将汉字分为一类，字母和数字为一类。分别使用神经网络模型，这样有效的提高了对汉字的识别率。作者在后期过程中对汉字字符处理的时，将其归一为40*40的分辨率，其效果也不是很理想。其原因是在原始图像中，字符的信息只有20*20像素，将其放大到40*40也是线性插值。如果想进一步提高汉字识别率，则需要更高的质量图像。
最后一个问题，由于作者C++语言水平能力有限所以这个问题也没有得到解决，但作者翻过几篇硕士论文筛选出两种方法：第一种办法是通过确定“特殊字符”来确定省份汉字的位置并直接进行截取。特殊字符是通过第二字符在车牌中大概位置（经验值），寻找其轮廓并画出凸包的外接矩形，根据“特殊字符”的外接矩阵进行窗口滑动。向前滑动一个间隙寻找到省份汉字。第二种方法是通过间隙阈值来确定两者为一个整体。这个两个办法，第一个方法过程虽然复杂且寻找得到的字符都会有点残缺，但此方法对二值化的图像质量要求不高且残缺的部分对字符识别影响较小。第二种方法对二值化后的图像质量要求较高，如果边缘没有处理好直接导致将第一个字符夹杂着大量的噪点信息，这样会在很大层度上影响到字符识别。针对以上问题我对原先的程序进行修改。这三张图片是我的实验结果截图：
PS：字符验证函数几乎是根据先验条件得到的,但是这里为什么不能用到先验条件呢？在我国的车牌上字符是比例是45/90，但这个比例是在图片正常的前提下。前面的文章将得到的车牌归一化为33*144，这样至多至少的已经将图片进行压缩或放大，且是不等比例的压缩或放大。这样字符比例已经不能作为的筛选条件。作者根据图像比例（实际的调试过程中的经验），设置字符的高度应在15-25个像素之间。本来想设置其字符宽度与高度之比，但是字符的宽度相差很大，例—字符为“1”时其宽度为3个像素值。故此这个验证函数的筛选条件还有待进一步的商榷。这个是值的改进的地方。调整期车牌的大小，具体根据摄像头定点拍摄时，车牌在图像中所占的像素个数来决定的。
代码：http://download.csdn.net/detail/chengchaopeng520/9808253
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b98df17129ed9fbcfac32d2718b18c98/" rel="bookmark">
			Yii2 实现计数器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求 文章一般都有统计浏览次数的需求，一般小型项目的做法就是直接 update 数据库中的某个字段。在 Yii 中怎么实现呢？请往下看：
实现 方式一
Yii2 中有这个 updateAllCounters 静态方法，这种方式是最快并且最省事的实现方式，代码示例如下：
Topic::updateAllCounters(['view_count' =&gt; 1], ['id' =&gt; $id]); // 实现的效果就是 view_count + 1，1根据你的需求可以是正数也可以是负数。 如果你的条件比较复杂你可以这样写：
Topic::updateAllCounters(['view_count' =&gt; 1], ['and', ['xxx' =&gt; 0, 'yyy' =&gt; 2], ['&gt;', 'zzz', $time]); 如果你现在的需求是：更新一个字段的值，一个字段的值 +1，你可以试着用这种方式去实现：
Topic::updateAll( ['view_count' =&gt; new Expression('`view_count` + 1'), 'updated_at' =&gt; time()], ['id' =&gt; $id] ); PS：此处的 view_count 字段默认值切记不能设置为 null。
Expression 是表达式的意思，可以实现更多特殊 SQL，想了解更多，可以去搜索一下文档。
方式二
当然你还可以这样去实现：
$model = Post::findOne($id); $model-&gt;updateCounters(['view_count' =&gt; 1]); 总结 写代码的时候推荐使用 IDE，因为有自动提示，写代码效率很高，而且可以很方便的查看源码，只有多阅读源码，理解是如何实现的，才可以达到灵活运用的境界。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71a11e2c49e072d6cd70bec0a5839e7d/" rel="bookmark">
			Android的编译环境--Build系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android是一个庞大的系统，包含太多的模块，各种模块的类型也有10多种。为了管理整套源码的编译，Android专门开发了自己的Build系统。从大的方面讲，Android的Build系统可分为3大块：第一块是位于build/core目录下的文件，这是Android Build系统的框架和核心；第二块是位于device目录下的文件，存放的是具体产品的配置文件；第三块是各模块的编译文件：Android.mk，位于模块的源文件目录下。 Android Build系统核心 核心位于build/core，这个目录中有几十个mk文件，以及一些shell脚本和perl脚本，构成了Android Build系统的基础和框架。 通常使用下面的命令来编译Android系统： # . build/envsetup.sh # lunch # make 那么我们以此作为入口，进行解析。 编译环境的建立 1、envsetup.sh文件的作用 执行Android系统的编译，必须先运行envsetup.sh脚本，这个脚本会建立Android的编译环境。envsetup.sh文件定义了很多shell命令，这些命令在envsetup.sh脚本之后就可以从shell环境中调用了。envsetup.sh 脚本还定义了一些其他有用的shell 命令，这些命令可以单独使用。例如： lunch	当前编译的产品 croot	跳转到根目录 m	编译整个源码 mm	编译当前目录所有模块，不编译依赖模块 mmm	编译指定模块，不编译依赖模块 mma	编译当前目录所有模块，编译依赖模块 mmma	编译指定模块，编译依赖模块 cgrep	对所有的c/c++文件执行grep命令 ggrep	对所有的Gradle文件执行grep命令 jgrep	对所有的java文件执行grep命令 resgrep	对所有的资源文件执行grep命令 sgrep	对所有的文件执行grep命令 godir	查找目录，并切换。 2、lunch命令的功能 lunch 命令没有参数，打印产品列表，以供选择；如果有名称，格式为“&lt;product_name&gt;--&lt; build_variant &gt;”，其中前半部分是产品名称，后面是“build_variant”必须是eng /user/userdebug 三者之一。
lunch主要作用就是根据用户输入或选择的产品的名来设置与产品相关的环境变量。这些环境变量与产品编译相关的主要有： TARGET_PRODUCT：所编译的产品名称。 TARGET_BUILD_VARIANT:表示编译产品的类型。可能值有 eng ,user .userdebug。 TARGET_BUILD_TYPE:表示编译的类型，可选值为release和debug当选择debug版本时，系统会加入调式信息，方便追踪。 Build相关环境变量 PLATFORM_VERSION_CODENAME：平台版本名称，通常是AOSP（Android OpenSource Project的缩写）
PLATFORM_ VERSION：Android平台的版本号。
TARGET_PRODUCT：所编译的产品名称。
TARGET_BUILD_VARIANT：表示编译产品的类型，可能值有 eng、user、userdebug。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/71a11e2c49e072d6cd70bec0a5839e7d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58ea4230d99783073e3534dbea31e562/" rel="bookmark">
			MATLAB resample函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		resample为信号降采样处理，理解如下：
B=resample(x,90,250); % 采样从250Hz降到90Hz，如果250在前,就是插值从90到250,可
以看B的长度,250Hz采样4000个数据等于90hz采样1440个数据,这就是降采样。
转自：http://blog.sina.com.cn/s/blog_9e2972d50101eqhp.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c69faa40e95021229409b9be9b1a4344/" rel="bookmark">
			浅谈Android响应式编程与Rxjava
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、响应式编程 响应式编程一种面向数据流和变化传播的编程范式。这意味着可以在编程语言中很方便地表达静态或动态的数据流，而相关的计算模型会自动将变化的值通过数据流进行传播。
例如，在命令式编程环境中，a:=b+c表示将表达式的结果赋给a，而之后改变b或c的值不会影响a。但在响应式编程中，a的值会随着b或c的更新而更新。
电子表格程序就是响应式编程的一个例子。单元格可以包含字面值或类似"=B1+C1"的公式，而包含公式的单元格的值会依据其他单元格的值的变化而变化 。
另一个例子是硬件描述语言，比如Verilog，这里响应式编程可以对电路中传播的信号变化进行建模。
二、RxJava与RxAndroid的使用
参见两个项目的GitHub首页：
https://github.com/ReactiveX/RxJava
https://github.com/ReactiveX/RxAndroid
三、Rxjava
什么是Rxjava？按照Rxjava在GitHub首页上的介绍：RxJava – Reactive Extensions for the JVM – a library for composing asynchronous and event-based programs using observable sequences for the Java VM.
一个在 JVM 上使用的可观测的序列来组成异步的、基于事件的程序的库，三个关键字：可观测序列、异步、基于事件。
即可以使用链式调用来完成异步操作，底层基于事件传递机制。
为什么要使用RxJava？逻辑更清晰，代码更简洁（配合lambda表达式），能够消除回调地狱。
以消除回调地狱为例： //The "Nested Callbacks" Way public void fetchUserDetails() { //first, request the users... mService.requestUsers(new Callback&lt;GithubUsersResponse&gt;() { @Override public void success(final GithubUsersResponse githubUsersResponse, final Response response) { Timber.i(TAG, "Request Users request completed"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c69faa40e95021229409b9be9b1a4344/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8477db49d64dc7548b4893c67ac18b2/" rel="bookmark">
			搭建WebSocketpp环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		WebSocketpp只是一个库，本身不需要搭建什么环境，只要新建的项目引入相关的库就行。但是WebSocketpp依赖于boost库，因此开发之前还是有点东西要做的。
1、下载boost库和WebSocketpp库 本来直接去对应的官网下载就行，但都是国外网站，有时下载速度真是蛋疼（反正我是下了很久）。因此我把他上传到网盘，有需要的直接下载
点我下载
2、安装boost库 说是安装，其实只是编译一下而已。
在boost根目录下打开命令行，执行bootstrap.bat脚本。
生成bjam.exe和b2.exe，在命令行执行bjam.exe，坐等编译完成。
（这两步只是按照默认的编译参数编译，十分简单，也可以自定义很多编译参数，我比较懒就没看了）
3、可以开始创建项目了 创建一个控制台空项目
然后新建一个main.cpp
把下面代码复制进去
#include &lt;boost/lexical_cast.hpp&gt; #include &lt;iostream&gt; using namespace std; int main() { using boost::lexical_cast; int a = lexical_cast&lt;int&gt;("123"); double b = lexical_cast&lt;double&gt;("123.0123456789"); string s0 = lexical_cast&lt;string&gt;(a); string s1 = lexical_cast&lt;string&gt;(b); cout &lt;&lt; "number: " &lt;&lt; a &lt;&lt; " " &lt;&lt; b &lt;&lt; endl; cout &lt;&lt; "string: " &lt;&lt; s0 &lt;&lt; " " &lt;&lt; s1 &lt;&lt; endl; int c = 0; try { c = lexical_cast&lt;int&gt;("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b8477db49d64dc7548b4893c67ac18b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d568eb2a1dc177f5f81dba43da1200e/" rel="bookmark">
			单页面mui返回的问题的箭头返回的是哪个页面。点击头部左边按钮返回上一页
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 单页面，返回的是上一个打开页面，而不是他们整体跳出这个页面。需要代码
//初始化单页view
var viewApi = mui('#app').view({
defaultPage: '#setting'
}); var view = viewApi.view;
(function($) {
//处理view的后退与webview后退
var oldBack = $.back;
$.back = function() {
if (viewApi.canBack()) { //如果view可以后退，则执行view的后退
viewApi.back();
} else { //执行webview后退
oldBack();
}
};
})(mui); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9774ae84db3d434c08612d2bbc46abc1/" rel="bookmark">
			Ubuntu通过命令行设置无线网络连接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于Ubuntu的Linux内核对于WPA的加密方式支持不是很好，所有使用普通方式的命令行无法连接WPA2类型的路由器。解决方法如下： 这里假设你的无线设备的名字为wlan0，可以通过ifconfig命令查看。
1、安装wpasupplicant 由于Ubuntu 10.04 Server已经集成了这个包，所以无需安装。如果是其他版本的Ubuntu Server，可以使用下面的命令进行安装：
apt-get install wpasupplicant
2、生成无线路由密钥 这一步就是根据你无线网络的SSID和密码，来生成WLAN需要的配置文件。命令如下：
wpa_passphrase ESSID PWD &gt; xxx.conf
ESSID是你连接的无线网络的SSID，PWD是该网络的密码。然后将生成的xxx.conf放到一个确定的目录下，这个配置文件名字可以随便取。
3、设置无线网络 编辑/etc/network/interfaces文件，将wlan0添加到其中：
vim /etc/network/interfaces
在里面加上以下配置信息：
auto wlan0 iface wlan0 inet dhcp wpa-conf /…/…/xxx.conf
注意如果你的路由器没有开启DHCP，则需要手动配置address、netmask、gateway、network和broadcast几项参数。另外就是wpa-conf后面跟着你刚才产生的密钥配置文件的全路径名。 如果一直不需要使用有线网络，可以连有线网络一起禁用掉，将auto eth0注释掉即可。
3、检查是否已经连接上路由器 运行以下命令：
sudo wpa_supplicant -B -i wlan0 -Dwext -c /…/…/xxx.conf iwconfig wlan0
4、设置自动获取IP
dhclient wlan0
OK，搞定。通过以上步骤就可以连接上无线网络了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d22435e706c326b519a36df9dc36576/" rel="bookmark">
			echarts中数据的循环
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 echats中的数据循环
echarts中的xAxis中的data和series中的data都是数组格式、都是数组格式、都是数组格式（重要事情说三遍），只有知道需要什么类型的数据才能数据异步加载中创建出与之对应的数据。
第一步、第二步没有什么不同，下面以柱状图的数据循环为例
第一步初始化 var myChart = echarts.init(document.getElementById(Chartid)); 第二步、设置标题、图例、空的坐标 myChart.setOption({ title:{ text:title }, tooltip: {}, legend:{ orient:'vertical', x:'right', data:['版本A','版本B'] }, xAxis:{ data:[] }, yAxis: {}, series:[ { name:'版本A', type:'bar', data:[] }, { name:'版本B', type:'bar', data:[] }] }); 第三步、数据异步加载，数据循环 $.get(url).done(function(data){ var obj = JSON.parse(data); var sxAxis=[]; var aseries=[]; var bseries=[]; //坐标和数据都push到数组中 for(var i=0;i&lt;obj.length;i++){ sxAxis.push( obj[i].option// ); aseries.push( obj[i].edita ); bseries.push( obj[i].editb ); } myChart.setOption({ xAxis:{ type : 'category', data:sxAxis//使用数组 }, series:[{ name:'版本A', data:aseries //使用数组 }, { name:'版本B', data:bseries //使用数组 }] }); }); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0caa7bc6b9fbdf0390573e2534bd2c14/" rel="bookmark">
			docker中centos7安装ssh服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		docker安装好后，自己动手做个自己的docker镜像，首先需要从服务器pull下一个基础的镜像，这里用centos7 （最好是root用户下，我虚拟机中的docker普通用户运行docker提示服务没有运行，奇怪） 一、下载官方原始镜像
docker pull centos:7 稍等一会下载完成，使用
docker images 查看本地的镜像列表，如图，centos那个就是刚才下载的
接着用以下命令启动，使用image创建container并进入交互模式, login shell是/bin/bash
docker run -i -t centos:7 /bin/bash 接着终端就是容器中的centos的了，默认是root用户登录，接下来的操作都在容器中了 二、容器中安装passwd,openssl,openssh-server
yum install passwd openssl openssh-server -y 安装完成后 启动sshd:
# /usr/sbin/sshd -D 这时报以下错误： [root@ b3426410ff43 /]# /usr/sbin/sshd Could not load host key: /etc/ssh/ssh_host_rsa_key Could not load host key: /etc/ssh/ssh_host_ecdsa_key Could not load host key: /etc/ssh/ssh_host_ed25519_key
执行以下命令解决：
[root@b3426410ff43 /]# ssh-keygen -q -t rsa -b 2048 -f /etc/ssh/ssh_host_rsa_key -N '' [root@b3426410ff43 /]# ssh-keygen -q -t ecdsa -f /etc/ssh/ssh_host_ecdsa_key -N '' [root@b3426410ff43 /]# ssh-keygen -t dsa -f /etc/ssh/ssh_host_ed25519_key -N '' 然后，修改 /etc/ssh/sshd_config 配置信息： UsePAM yes 改为 UsePAM no UsePrivilegeSeparation sandbox 改为 UsePrivilegeSeparation no 可以用vi改，也可以用下面命令
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0caa7bc6b9fbdf0390573e2534bd2c14/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4eed4d3b420d2ba7841190d41e63a3f1/" rel="bookmark">
			待机电流过高bug解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： 待机电流达到30ma 用cat d/rpm_stats查看，结果如下：
root@msm8916_64:/ # cat d/rpm_stats cat d/rpm_stats RPM Mode:xosd count:0 time in last mode(msec):0 time since last mode(sec):481 actual last sleep(msec):0 client votes: 0x03030303
RPM Mode:vmin count:0 time in last mode(msec):0 time since last mode(sec):481 actual last sleep(msec):0 client votes: 0x00000000
检查rpm_stats是否进入vdd min或者xo/no shutdown。 如果vmin的count是0，则表明设备从来没有进入vdd min；non-zero则说明设备进入过vdd_min。 现在是0，表明没有进入过vdd min模式，就是最低功耗模式。
1.因为此项目只有wifi，不需要射频 因此：把msm8916-regulator.dtsi中的ldoa18，配置为status = “disable”;同时去掉regulator-always-on; 虽然不用modem，但是仍旧要刷qcn来配置其中的参数来使得modem可以正常休眠。否则休眠电流仍旧会达到30ma之大。
2.抓一份dump的log，用qpst 步骤如下： 2.1把设备配置为可以进入dump模式，依照配置log 2.2接上usb，敲入以下命令 执行： adb root; adb shell; cd /sys/kernel/debug/spmi/spmi-0; echo 0x844 &gt; address; echo 4 &gt; count; echo 0x00 0x00 0x01 0x00 &gt; data; echo 0x00 0x00 0x01 0x80 &gt; data; 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4eed4d3b420d2ba7841190d41e63a3f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/100002702c67ce0622bdd8f7506a9f64/" rel="bookmark">
			贝叶斯公式在生活中的应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在我们的生活中有很多事情可以追溯其因果关系。而在一定的条件下，我们可以根据贝叶斯公式由果去追溯它的因。贝叶斯公式在生活中的应用主要有疾病诊断，企业的资质评判，诉讼，市场预测，邮件过滤等方面。贝叶斯公式的推断是一种统计学的方法，可以用来估计统计量的发生概率的作用。本文举了两个例子，探讨了我们在生活对事件的判断的可靠性，从而使我们更加的知道我们平时一些概率问题要怎样去理性的判断与推测。
那么什么是贝叶斯公式呢？
贝叶斯公式可以这样描述：
若事件 ， ，…… 是一个样本空间的划分，P( ) &gt; 0 (i= 1，2，……n)，A是任一事件且P(A) =&gt; 0，则有
P( | A) = (j = 1，2，……，n)
其中，P(A) 可由全概率公式得到，即
P（A）= ( ) P(A | )
贝叶斯公式可以写为：P(B|A)=P(AB) /P(A) P(A|B) = (AB) / P(B)
贝叶斯公式应用之一——重症肌无力 概率分析
重症肌无力（myasthenia gravis，MG）是一种主要累及神经肌肉接头突触后膜上乙酰胆碱受体 (acetylcholine receptor，AchR)的自身免疫性疾病。临床主要表现为部分或全身骨骼肌无力和易疲劳，活动后症状加重，经休息和胆碱酯酶抑制剂（cholinesterase inhibitors，ChEI）治疗后症状减轻。
当前医学对于重症肌无力的诊断方法主要有肌电图检查，血液检查，免疫病理学检查，胸腺影像学检查、药物检查、重复神经刺激（ＲＮＳ）、疲劳试验等。
现在我们讨论其中的一种检查方法的可靠性——疲劳试验。
我们得知，在这项疲劳试验检测中，患有重症肌无力中人中检测呈阳性的准确率是93.79%，而对于没有患重症肌无力的人检测呈阴性的准确率是99%，根据市场调查，重症肌无力的患病率是50/10万，也就是说，重症肌无力的患病率是0.05%，
接下来用贝叶斯公式分析这种诊断方法的可靠性。
设A = {检测结果为阳性(前提是不知道这个检测的人是否患有重症肌无力)}; B = {一个患有重症肌无力的人};
根据搜到的资料可知：P(B) = 0.0005，P(A|B) = 0.9379，P( ) =1-0.0005 = 0.9995，
P(A| ) = 1-0.99= 0.01
由：P(AB) = P(B|A) P(A) = P(A|B) P(B)，P(A ) = P(A| ) P( )， 得：P(A) = P(AB) + P(A ) = P(A|B) P(B) + P(A| ) P( ) = 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/100002702c67ce0622bdd8f7506a9f64/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3cd350e1caa66f9175b304664437514a/" rel="bookmark">
			Sublime Text 设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 菜单栏里点击 Preferences-&gt; Setting-User
// 注意只有一个大括号，如果之前有属性，如在之前的属性前确保有 ，(逗号) { //显示tab和空格标示（方便Python编写格式） "draw_white_space": "all", //一行内容超过显示窗口，自动换行 "word_wrap": true, //tab键长度为4 "tab_size": 4, //tab键转为空格 "translate_tabs_to_spaces": true, //保存时转换tab为空格 "expand_tabs_on_save": true } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eac827e2e1c1d78c5cd9c217a16feebd/" rel="bookmark">
			bootstrap多次弹窗导致页面左移，body上多了样式&#34;padding-right: 17px&#34; 解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		body { padding-right: 0px !important; } *.modal-open { overflow-y: scroll; padding-right: 0 !important; } 在引入bootstrap样式后，页面增加上述样式。
参考：
https://segmentfault.com/q/1010000002945721
http://www.uedbox.com/bootstrap-modal-bug/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4038223109a2a644104c93a5f153183/" rel="bookmark">
			独热编码（One-Hot Encoding）介绍及实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、介绍
在数据处理和特征工程中，经常会遇到类型数据，如性别分为[男，女]（暂不考虑其他。。。。），手机运营商分为[移动，联通，电信]等，我们通常将其转为数值带入模型，如[0,1], [-1,0,1]等，但模型往往默认为连续型数值进行处理，这样其实是违背我们最初设计的，也会影响模型效果。
独热编码便是解决这个问题，其方法是使用N位状态寄存器来对N个状态进行编码，每个状态都由他独立的寄存器位，并且在任意时候，其中只有一位有效。
如自然编码为：0，1
独热编码为：10，01 可以理解为对有m个取值的特征，经过独热编码处理后，转为m个二元特征，每次只有一个激活。
如数字字体识别0~9中，6的独热编码为：
0000001000
二、优点
独热编码的优点为：
1.能够处理非连续型数值特征。 2.在一定程度上也扩充了特征。比如性别本身是一个特征，经过one hot编码以后，就变成了男或女两个特征。
当然，当特征类别较多时，数据经过独热编码可能会变得过于稀疏。
·
三、实现 我们可以自己根据实际问题实现独热编码，如0~9数字识别中
# labels 变成one-hot encoding, [2] -&gt; [0, 0, 1, 0, 0, 0, 0, 0, 0, 0]
# digit 0 , representedas 10
# labels 变成one-hot encoding, [10] -&gt; [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]
labels =np.array([x[0] for x in labels]) one_hot_labels= []
for numin labels:
one_hot= [0.0] * 10
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a4038223109a2a644104c93a5f153183/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1146bd96e64ccad30f414e051b59fe21/" rel="bookmark">
			CSS：字体倾斜
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CSS：字体倾斜（个人理解）
在CSS样式中，总会出现斜体字，斜体字一共分为两部分：
1、倾斜角度是固定的
在浏览器中，&lt;em&gt;默认用斜体表示。 语法&lt;em&gt;文本&lt;/em&gt;css样式：font-style:italic; font-style:oblique; 2、倾斜角度不固定
用CSS3中的transform中的skew属性值实现文字的倾斜效果skew(30deg,30deg)表示水平方向上倾斜30度，垂直方向上倾斜30度。例：.style{ -webkit-transform: skew(-10deg); /* for Chrome||Safari */ -ms-transform: skew(-10deg); /* for IE */ -moz-transform:skew(-10deg);/* for Firefox */ -o-transform:skew(-10deg);/* for Opera */ } &lt;p class="style"&gt;about&lt;/p&gt; &lt;p class="style"&gt;technologe&lt;/p&gt;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/689fe29387e96b39a7df14f8017a9233/" rel="bookmark">
			idea debugger console 不见了。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 找了好久，也找不到，调试的时候挺麻烦的。
2 最后发现 有个一个重置，视图的按钮。点击一下就恢复 。 如下图。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5c8cd8554ca460d87529d966d1114cf/" rel="bookmark">
			Keil C51之Const对象声明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Keil C51中，可以使用const来对变量进行声明修饰，但自己在认识和使用上一直存在两方面的问题:1、和另一款很流行的MCU C语言开发环境IAR中的意义有一些混淆;2、和Keil C51提供的code类型作用也有一些混淆，这里来进行一下仔细区别和笔记。
一、概述:
通过查询Keil C51 Help-&gt;uVision Help手册，搜寻const主题，在主题为"const"的一篇文章中，有详细说明了const的用法:
In ANSI C, the const type qualifier is used to define and access objects that are constant and that may not be changed. A variable that is declared with const may not be assigned to in the program. (1、Const用于修饰那些固定，不需要改变的对象;2、以Const修饰的对象不能在程序中被重新赋值)【注意:前提是在ANSI C中】
二、说明:
The Cx51 Compiler conforms to the ANSI definition of const objects.【注意:这里讨论const前提是在Cx51 编译器中，在其它编译器就不一定如此了】
1)、Variables declared with the const type qualifier alone are stored in the memory area (data, idata, xdata, and so on) associated with their definition.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5c8cd8554ca460d87529d966d1114cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f42d28d49c7851d27529f153ca823aa0/" rel="bookmark">
			软考复习 Internet及应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Internet 和 internet Internet 译为“因特网”，是一个专用名词，代表全球最大的互联网络，其前身为ARPNET，采用TCP/IP协议族。
interner 则是“互联网”的意思，是一个通用名词，泛指由多个计算机网络互连而成的网络。网络之间通信协议可以是任意的。
Internet地址 Internet地址格式有两种主要形式：域名格式和IP地址格式。
域名就是我们经常用到的类似：www.baidu.com、www.csdn.net等这些易于理解和记忆的地址形式。
IP地址是在Internet中对主机的唯一标识，因为Internet中使用的是TCP/IP协议，所以Internet中每个主机必须用IP地址来标识。IP地址共 32 位，4个字节。IP地址也有两种表示，一种是二进制格式，还一种是为了记忆使用点分十进制法，将IP地址分成4个小于256的数字组成，数字之间用“.”分开。
二进制表示 11000000 10000000 00100000 00000000 十进制表示 192 . 128 . 32 . 0 域名和IP地址的转换是通过DNS来解决的，我们一般都是说DNS将域名解析成IP地址，但要记住DNS也是可以将IP地址转换为域名的。 分类IP地址 最早使用的是分类IP地址的方法，将IP地址分为A、B、C、D、E五类。 A类——网络地址占1个字节，最高位为0来标识此类地址，余下七位为真正的网络地址。全0表示本网络，127号网络是留做环回测试的。网络指派范围：1~126
B类——网络地址占2个字节，最高位为10来表示此类地址，余下14位为真正的网络地址。网络指派范围：128.1~191.255
C类——网络地址占3个字节，最高位为110来表示此类地址，余下21位为真正的网络地址。网络指派范围：192.0.1~223.255.255
D类——以1110开头，用于组播、路由器修改
E类——以1111开头，用于试验。
我们主要关注前面3类地址即可。
划分子网 因为分类IP地址的地址空间利用率很低，而且分配很不灵活。所以有了划分子网做法。
划分子网 就是向主机号位借位来作为子网号。
划分子网后为了能够识别出子网，就有了子网掩码。子网掩码就是用来指明一个IP地址的哪些位标识的是主机所在的网络，哪些位标识的是主机的位掩码。
子网掩码必须和IP地址一起使用，子网掩码也是32位，对应IP地址网络号部分用1填上，对应主机部分用0填上。规定了所有网络都必须使用子网掩码，对于没有划分子网的网络则使用默认子网掩码。
A类地址的默认子网掩码：255.0.0.0 B类地址的默认子网掩码：255.255.0.0 C类地址的默认子网掩码：255.255.255.0 将IP地址和子网掩码逐位相与就可得到网络地址。
对一个没有划分子网的A类地址 5.64.32.1，我们来看下怎么求网络地址
IP地址 5 .64.32.1（实际要转换成二进制运算，但都是与全1或全0相于，比较简单，所以这里省略） 子网掩码 11111111.0.0.0相与 5 .0.0.0 所以可以知道这个IP的网络地址为5.0.0.0，也就是说5。64.32.1这个IP地址是属于5.0.0.0这个网络的。 对于一个划分了子网的B类地址 142.32.128.0，给定子网掩码为255.255.224.0，求网络地址
IP地址 142.32. 128 .2子网掩码 255.255.11100000.0相与 142.32.128.0可以看到网络地址为142.32.128.0，我们知道B类地址的默认子网掩码是255.255.0.0，但这里因为要划分出子网，所以给定的子网掩码为255.255.224.0。我们分析下 上面提到过B类网络指派范围是 128.1 ~ 191.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f42d28d49c7851d27529f153ca823aa0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1726178addc5259fdc3187295e0c90bf/" rel="bookmark">
			UOJ #228(基础数据结构练习题-区间开根&#43;区间加&#43;区间求和)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		给出一个长度为 n 的数列 A，接下来有 m 次操作，操作有三种：
对于所有的 i∈[l,r]，将 Ai 变成 Ai+x。 对于所有的 i∈[l,r]，将 Ai 变成 √Ai（向下取整）。 对于所有的 i∈[l,r]，询问 Ai 的和。 作为一个不怎么熟练的初学者，sylvia 想了好久都没做出来。而可怜酱又外出旅游去了，一时间联系不上。于是她决定向你寻求帮助：你能帮她解决这个问题吗。
#include&lt;bits/stdc++.h&gt; using namespace std; #define For(i,n) for(int i=1;i&lt;=n;i++) #define Fork(i,k,n) for(int i=k;i&lt;=n;i++) #define Rep(i,n) for(int i=0;i&lt;n;i++) #define ForD(i,n) for(int i=n;i;i--) #define ForkD(i,k,n) for(int i=n;i&gt;=k;i--) #define RepD(i,n) for(int i=n;i&gt;=0;i--) #define Forp(x) for(int p=Pre[x];p;p=Next[p]) #define Forpiter(x) for(int &amp;p=iter[x];p;p=Next[p]) #define Lson (o&lt;&lt;1) #define Rson ((o&lt;&lt;1)+1) #define MEM(a) memset(a,0,sizeof(a)); #define MEMI(a) memset(a,0x3f,sizeof(a)); #define MEMi(a) memset(a,128,sizeof(a)); #define MEMx(a,b) memset(a,b,sizeof(a)); #define INF (0x3f3f3f3f) #define F (1000000007) #define pb push_back #define mp make_pair #define fi first #define se second #define vi vector&lt;int&gt; #define pi pair&lt;int,int&gt; #define SI(a) ((a).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1726178addc5259fdc3187295e0c90bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a33354724c1fb168967304012379616e/" rel="bookmark">
			SIM800系列模块GSM/GPRS建立TCP连接到远端服务器过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		from:http://blog.sina.com.cn/s/blog_b315f69b0102wowb.html
SIM800系列模块GSM/GPRS建立TCP连接到远端服务器过程 (2016-12-20 18:25:29) 转载▼ 标签： it 分类：技术笔记 SIM800模块 是全球领先的M2M模块及解决方案供应商芯讯通无线科技有限公司的一个产品系列，使用AT指令的GSM/GPRS无线通讯模块，就自己的使用过程记录下SIM800C系列模块 建立TCP连接到远端服务器过程，模块基本使用通用异步串口通讯，模块内部TCP/IP应用程序用于GPRS服务。 先对AT命令做一个简单介绍吧： AT命令以AT开头，一回车符结束。 一个简单命令如：AT回车符， 模块对命令的响应为：回车符、换行符response回车符、换行符 AT命令大致可分为三类： 1、基本AT命令：AT&lt;&gt;&lt;&gt;或者AT&amp;&lt;&gt;&lt;&gt;，如：ATE1（打开串口回显），AT&amp;D1（开启DTR低电平切换）。 2、S参数型AT命令：ATS&lt;&gt;=&lt;&gt;，如：ATS0=1（设置模块来电一声自动接起）。 3、扩展型AT命令（四种）： a）、AT+&lt;&gt;=? 用于查看此命令在模块中允许设置的参数范围，如发送命令：AT+CREG=? 正常时响应：+CREG：（0-2） OK b）、AT+&lt;&gt;? 用于查看此命令在模块中的当前设置值，如发送命令：AT+IPR? 正常时响应：+IPR：0 OK c）、AT+&lt;&gt;=&lt;&gt; 用于设置当前AT命令x的参数值。如发送命令：AT+CMGF=0 正常时 响应：OK d）、AT+&lt;&gt; 查看模块内部的一些状态值。如发送命令：AT+CSQ 正常时响应：+CSQ：29，0 OK 现在利用上述格式的一些命令描述模块建立TCP连接到远端服务器的过程，先介绍模块建立一路链接的过程，建立多路连接时，方法基本相同。 目前SIM800系列模块共支持6路链接。从模块开机到建立TCP链接过程如下： 1、等待模块开机后，向模块 串口 发送“AT”指令，让模块自适应主机串口波特率，设置成功时，返回：OK 2、向模块串口发送“AT+CPIN?”指令，检查SIM状态，SIM正常时， 返回：+CPIN：READY OK 3、向模块串口发送“AT+CSQ”指令，检查网络信号强度，命令发送成功时， 返回：+CSQ：29，0 OK 4、 向模块串口发送“AT+CREG” 指令，检查GSM网络注册状态，发送成功时， 返回：+CREG：0，1 OK 其中1代表已注册本网，若为2代表未注册。 5、 向模块串口发送“AT+CGREG” 指令，检查GPRS网络注册状态，发送成功时， 返回：+CGREG：0，1 OK 其中1代表已注册本网，若为2代表未注册。 （若已设置命令“AT+CREG=1”和 “AT+CGREG=1”时，模块在注册GSM和PGRS网络成功或发生变化时，将主动上报其注册状态，如上报结果：+CREG：2或+CGREG：2。其中2表示GSM和GPRS网络未注册 ） 6、（可选命令） 向模块串口发送“AT+CMGF=0” 指令，设置短消息为PDU模式，发送成功时， 返回： OK 7、 （可选命令） 向模块串口发送“AT+CNMI=2，1，0，0，0” 指令，设置新短消息URC上报格式，发送成功时， 返回：+CMTI：“SM”，1 （此返回结果为收到新短消息，1为此新短消息在存储器中的序号） 8、 向模块串口发送“AT+CGATT=1” 指令，使模块附着GPRS网络，发送成功时， 返回： OK （此时模块内部TCP协议栈的状态为：IPIINITIAL） 9、 向模块串口发送“AT+CIPMODE=1” 指令，设置GPRS的TCP/IP透传模式，发送成功时， 返回： OK （其中1为透传模式，0为分透传模式，及命令模式） 10、 向模块串口发送“AT+CSTT="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a33354724c1fb168967304012379616e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea71bdd77a467b77b1d755f672561077/" rel="bookmark">
			IP地址分类与子网掩码有关计算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载自：http://blog.csdn.net/zhangliangzi/article/details/51263337
一、IP地址
1、IP地址基本概念 IP地址在网络层将不同的物理网络地址统一到了全球唯一的IP地址上（屏蔽物理网络差异），是唯一标识互联网上计算机的逻辑地址（相当于手机号码，可以通过唯一的手机号码找到手机），所以IP地址也被称为互联网地址（可见其重要性）。
2、IP地址格式 我们目前常用的IPv4中规定，IP地址长度为32位二进制，在表示时，一般将32位地址拆分为4个8位二进制，再转为4个十进制数表示，每个数字之间用点隔开，如127.0.0.1（localhost），这种描述方式被称为“点-数表示法”。 IP地址层次：分为网络号和主机号两个层次。网络号表示主机所属网络，主机号表示主机本身。网络号与主机号的位数与IP地址分类有关。
3、IP地址分配 IP地址分配的基本原则是：要为同一网络（子网、网段）内不同主机分配相同的网络号，不同的主机号。
4、IP地址常见分类 A类IP地址 一个A类IP地址由1字节的网络地址和3字节主机地址组成，网络地址的最高位必须是“0”， 地址范围从1.0.0.0 到126.0.0.0。可用的A类网络有126个，每个网络能容纳1亿多个主机。
B类IP地址 一个B类IP地址由2个字节的网络地址和2个字节的主机地址组成，网络地址的最高位必须是“10”，地址范围从128.0.0.0到191.255.255.255。可用的B类网络有16382个，每个网络能容纳6万多个主机 。
C类IP地址 一个C类IP地址由3字节的网络地址和1字节的主机地址组成，网络地址的最高位必须是“110”。范围从192.0.0.0到223.255.255.255。C类网络可达209万余个，每个网络能容纳254个主机。
D类地址用于多点广播（Multicast）。 D类IP地址第一个字节以“1110”开始，它是一个专门保留的地址。它并不指向特定的网络，目前这一类地址被用在多点广播（Multicast）中。多点广播地址用来一次寻址一组计算机，它标识共享同一协议的一组计算机。
E类IP地址 以“llll0”开始，为将来使用保留。
5、特殊的IP地址
**受限的广播地址：**32位全“1”的IP地址，只能做目的地址，用于向本网内部所有主机发送数据包（路由器拒绝向外网发送广播，隔离数据包在本网内）。
直接广播地址：网络号全“1”，只能作目的地址，用于向目标网内所有主机发送数据包（路由器接受向外网转发数据包，意为广播在全网有效），如C类IP所有主机255.255.255.主机号、B类IP所有主机255.255.主机号。
**本网络本主机地址：**32位全零的IP地址对应于当前主机，只能做源地址。
本网特定主机地址：网络号全零的IP地址表示本网络内的特定主机（路由器拒绝目的地址为本网特定主机的数据包，意为只能向本网内特定主机发送数据包），只能做目的地址。
环回地址就是网络ID为127的IP地址，用于一台主机的客户端与服务器端通过TCP\IP进行通信或者本机进程间通信，一般在自己的主机上进行软件开发测试时候会用到的localhost(127.0.0.1)就是环回地址。
在IP地址3种主要类型里，各保留了3个区域作为私有地址，其地址范围如下： A类地址：10.0.0.0～10.255.255.255 B类地址：172.16.0.0～172.31.255.255 C类地址：192.168.0.0～192.168.255.255
二、子网掩码 上面我们说到IP地址分为网络号与主机号，但是路由如何区分网络号与主机号呢？就需要通过子网掩码。子网掩码必须与IP地址结合使用，A、B、C类的子网掩码分别为255.0.0.0，255.255.0.0与255.255.255.0（网络号字节为255，主机号字节为0）。
以C类IP地址192.168.1.2为例使用子网掩码划分网络号与主机号。
子网掩码还可以用来将网络划分为更小的子网，将IP的两极结构扩充成三级结构，节约地址空间，减轻路由器负担。（未完待续）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98218d3d3c8c4b674a4b59c5f1f32444/" rel="bookmark">
			PHP empty函数测试对象使用魔术方法获取的属性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 从PHP官方文档可以看到，empty用于测试一个变量是否为空，empty($var)等价于
!isset($var) || $var == false empty方法的参数只能是一个变量，当传入一个对象的属性时，如果该属性是真实存在的，empty可以正常工作。 如果该属性是通过魔术方法获取的，empty的返回结果不是期望中的，而总是返回true。
PHP版本为5.6.24
# php --version PHP 5.6.24 (cli) (built: Aug 1 2016 14:48:54) Copyright (c) 1997-2016 The PHP Group Zend Engine v2.6.0, Copyright (c) 1998-2016 Zend Technologies class Test1 { protected $attributes = [ 'name' =&gt; 'Test1', ]; public function __get($attr) { return isset($this-&gt;attributes[$attr]) ? $this-&gt;attributes[$attr] : null; } } class Test2 { public $name = 'Test2'; } $test1 = new Test1(); print $test1-&gt;name ; //-- Test1 if (empty($test1-&gt;name)) { print 'test1\'s name is empty'; } else { print 'test1\' name is not empty'; } //-- test1's name is empty $test2 = new Test2(); print $test2-&gt;name ; //-- Test2 if (empty($test2-&gt;name)) { print 'test2\'s name is empty'; } else { print 'test2\' name is not empty'; } //-- test2's name is not empty 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a7d247b2d3581bdb1df949c6c4c1b01/" rel="bookmark">
			作业1 对该课程期望
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作为编程语言的基础，C语言是我们应该熟练掌握运用的， 我们应该花更多时间去学习C语言，扎实我们的基础，为我们以后的学习铺下更加方便的通道，希望通过老师的细致讲解和我们的努力，会让我们的成绩更加好。
转载于:https://www.cnblogs.com/jokerq/p/6561753.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a15bb2d48692c2a5f9ce4e7934dc5bf6/" rel="bookmark">
			运算符的优先级（由高到低）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		运算符的优先级（由高到低） 优先级 描述 运算符
1.括号() []
2.正负号 + -
3.自增自减非 ++ -- ！
4.乘除取余 */%
5.加减 + -
6.移位运算 &lt;&lt; &gt;&gt;
7.大小关系 &gt; &lt; &lt;= &gt;=
8.相等关系 = !=
9.按位与 &amp;
10.按位异或 ^
11.按位或 |
12.逻辑与 &amp;&amp;
13.逻辑或 ||
14.条件运算？：
15.赋值运算 = += -= *= /= %=
16.位赋值运算 &amp;= |= &lt;&lt;= &gt;&gt;=
若要改变运算顺序，可以使用（）。
按位或：只要对应的两个二进位有1个为1时，结果就为1.当参与运算的是负数时，参与两个数均以补码出现。
按位或：参与运算的两数各对应的二进位相与。只要对应的两个二进位都是1.负数时，参与运算的两个数均以补码出现。
异或运算（^）：参与运算的两个对象，如果两个相应位为“异”，则该结果为1，否则为0
取反运算（~）：对一个二进制数按位取反，即0变1,1变0.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e5eac2df4e5cfe129ab91d2f2e88a76/" rel="bookmark">
			条件变量基本概念和原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http://hipercomer.blog.51cto.com/4415661/914841
条件变量的作用是用于多线程之间关于共享数据状态变化的通信。当一个动作需要另外一个动作完成时才能进行，即：当一个线程的行为依赖于另外一个线程对共享数据状态的改变时，这时候就可以使用条件变量
假设没有条件变量，对于一个生产者消费者问题，消费线程在得知队列中没有产品时，将阻塞自己。生产线程给队列中放入产品，但是没有办法激活消费线程，而消费线程处于阻塞状态也没有办法自激活。如果消费线程使用忙等的方式，通过不断地查询来判断是否有产品将大量的浪费CPU时间。消费线程可以使用睡眠+查询的方式，即发现队列中没有产品时，sleep一段时间，然后再查询。问题是睡眠多长时间？时间太长，实时性不好，时间太短，还是浪费CPU时间。
所以，通过生产线程通过唤醒消费线程时最好的方式。现在我们考虑一种实现，消费线程在阻塞之前要先解锁，同时还要将自己的标识符放入一个地方，以便生产线程通过这个标识符来激活自己。这样看起来是没问题了，然而不要忘记了，线程之间是并发/并行的。消费线程可能刚完成解锁的操作，就被生产线程获取到了并开始执行，这时，因为消费线程还未挂起自己，来不及将自己的标识符保存在某个位置，所以生产线程不认为有正在等待的线程。这时，切换到消费线程后，消费线程将永远的等待下去，虽然队列中有产品。而生产线程因为队列中有产品可能也一直的等待下去，形成了死锁。
解决方法是必须让解锁、保存线程标识符、挂起这一系列操作成为原子操作。这中解决方案就是条件变量，所以不难想到使用条件变量的时候必须要“伴随”一个互斥量。
条件变量是与互斥量相关联的一种用于多线程之间关于共享数据状态改变的通信机制。它将解锁和挂起封装成为原子操作。等待一个条件变量时，会解开与该条件变量相关的锁，因此，使用条件变量等待的前提之一就是保证互斥量加锁。线程醒来之后，该互斥量会被自动加锁，所以，在完成相关操作之后需要解锁。
条件变量总是和谓语相关，学过《离散数学》应该还记得谓语表达式吧。谓语是具有唯一真假值的句子。程序中，可以用谓语来描述当前线程需要的状态。如果该谓语值为假，需要使用条件变量等待。醒来之后，由于系统的并发性，一般需要再次判断谓语值是否为真，如果不为真，则再次使用条件变量进行等待。
互斥量是用来防止对不变量的破坏，换句话说，是用来规范线程对共享数据的竞争使用。而条件变量是用来对线程同步，即用来协调各个线程合作完成某个任务。比如：足球场上，两个足球队对一个球的使用叫做竞争，可以使用“马赛回旋”这种“互斥量”对球加锁，防止被抢。而传球这个动作就是使用“条件变量”进行唤醒，它的作用是保证一个球队的各个成员能协作起来将球踢进对方的球门。
条件变量的关注对象是共享数据状态的变化，这一变化可以使用谓语来描述。因为涉及到共享数据，所以需要互斥量。互斥量和条件变量的对应关系为1:N.就是说一个互斥量可以对应多个条件变量，一个条件变量只能对应一个互斥量。这个可以这样理解：因为共享数据有很多种状态，描述这些状态就需要多个谓语，所以需要用多个条件变量。
条件变量和谓语的对应关系一般最好为1:1、1：N或者N：1并不是不可以，但是容易引起死锁和竞争问题，要特别注意。若1个条件变量对应于多个谓语时，唤醒应采用广播的方式而不是signal的方式。
本文出自 “相信并热爱着” 博客，请务必保留此出处http://hipercomer.blog.51cto.com/4415661/914841
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f65ae3d72e85b5e8663689183fc50121/" rel="bookmark">
			AWS S3的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 这两天Web这边有一个功能需求，使用到了AWS 的S3服务，这个东西在国内访问很慢，所以，一般也少有人使用，我们的业务主要在美国，所以，使用这个服务还是非常好的。国内的阿里云做到了云计算的龙头，我还是希望AWS北京数据中心能够尽快的开放出来，从去年中就开始公测，现在依然也没有个信儿，国内的境外企业的管制可真是严格。希望两方的加快工作进度吧。亚马逊给出的SDK实在是很多，各种语言的都有，不愧是大厂。人家这写的SDK也很好弄，只要搞清楚几个概念，也是很快就能够集成到自己的代码中的。AWS对资源的访问做了很好的权限控制。在CLI和SDK中操作AWS的EC2、S3等各种资源，需要一个独立的账号，账号需要隶属于一个组。组对资源的访问权限可以在管理控制台分配，该组的成员继承组的权限，也可以单独分配权限。
第一步，在IAM页面中，先创建组，再创建一个s3的用户，最好把用户的权限控制了小一点。注意有几个概念，生成用户后，最后会给出用户的“访问密钥 ID”，“私有访问密钥”，这两个相当于临时的用户名和访问密码，需要把页面内的CSV下载下来保存好。给用户“添加权限”，选择“直接附加现有策略”，在搜索框内输入“AmazonS3FullAccess”，就给用户赋予了S3的全部访问权限。
第二布，创建S3 Bucket。这个很好操作，注意选择好所在region的代码和bucket的名字，选择访问速度最快的区域us-west-1(加利福尼亚北)，比如说你起名字myBucket，将来对外公开的url就是https://s3-us-west-1.amazonaws.com/myBucket/。
第三部，配置CLI和SDK。现在，我们可以在本地机器配置CLI信息了。我们可以使用类似Linux Shell的方式来控制在亚马逊上所有的资源。可以写Shell脚本来完成你的工作，也可以使用PHP或Python的SDK来写程序，做到更精细的控制。需要pip，安装命令很简单 pip install --upgrade --user awscli。运行aws configure 来配置认证信息，填入上面创建用户页面的“访问密钥 ID”，“私有访问密钥”。先在CLI里测试一下，比如aws s3 sync myLocalDir s3://myBucket/。如果能够在正确运行，就表示可以继续了。PHP的SDK很简单，如果使用Laravel，也可以使用composer来引入这个SDK。PHP的SDK可能会用到当前机器上的CLI配置信息，如~/.aws/config 或者~/.aws/credentials文件，这里面存放的就是上面提到的用户名和密码，还有s3 桶所在的区域，也可以把这些信息直接写到PHP文件里，如创建的S3 Client对象时传入。
在EC2的虚拟机上上传文件到S3，速度快的飞起。S3的文件夹删除速度太慢了，慢的让人受不了。（后来一看，发现我在老版本的S3控制页面的删除操作异常的慢，在新的页面就很快，这是什么鬼？使用的内部接口不一样？）
文档还是要好好读的。aws的文档写的很容易懂。国内用户想要使用aws，推荐试一试韩国的数据中心，速度还是很快的。搭个梯子什么的，可以搞一搞的。
http://docs.aws.amazon.com/aws-sdk-php/v3/api/ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6209acc930ab38b2b72d400dedf87aba/" rel="bookmark">
			解决PL/SQL Dev连接Oracle弹出空白提示框
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文地址：http://www.cnblogs.com/Smith-/archive/2014/08/10/3903226.html
第一次安装Oracle，装在虚拟机中，用PL/SQL Dev连接远程数据库的时候老是弹出空白提示框，网上找了很久，解决方法也很多，可是就是没法解决我这种情况的。
没办法，只能自己研究，经过大概一天时间吧，还是搞好了，写个总结。
出现这种问题，解决方法大概有这几种：
1.权限不够，导致弹出空吧提示框。（直接上链接）
http://jingyan.baidu.com/article/066074d6760959c3c21cb0d6.html
就PL/SQL图标上点右键---属性---兼容性--管理员身份运行此程序的勾打上，即可
2.环境变量没设对。
①在安装oracle服务器的机器上搜索下列文件， oci.dll ocijdbc10.dll（其中10代表oracle版本，若是其他版本，则需要修改之，例如改成ocijdbc9.dll或者ocijdbc11.dll） ociw32.dll orannzsbb10.dll（其中10代表oracle服务器版本，若是其他版本，则需要修改之，例如改成orannzsbb9.dll或者orannzsbb11.dll） oraocci10.dll（其中10代表oracle服务器版本，若是其他版本，则需要修改之，例如改成oraocci9.dll或者oraocci11.dll） oraociei10.dll（可能服务器没有，如果没有，就不用找了) sqlnet.ora，tnsnames.ora，classes12.jar，ojdbc14.jar 把这些找到的文件复制放到一个文件夹,如 oraclient，将此文件夹复制到客户端机器上。如放置路径为 D:\oraclient ②配置tnsnames.ora，修改其中的数据库连接串。 oracledata = (DESCRIPTION = (ADDRESS_LIST = (ADDRESS = (PROTOCOL = TCP)(HOST = 192.168.0.58)(PORT = 1521)) ) (CONNECT_DATA = (SERVICE_NAME = oracledata) ) ) 其中，oracledata是要连接的服务名；HOST = 192.168.0.58，是服务器IP地址；PORT = 1521是端口号。 ③添加第一个环境变量，名为TNS_ADMIN，值为tnsnames.ora文件所在路径（如：D:\oraclient，特别是重装后或其它操作，忘了TNS_ADMIN变量，plsql登陆就会报无法解析指定的连接标识符)，这是为了能够 找到上面说的tnsnames.ora。这步是最重要的。 添加第二个环境变量（可有可无）： “NLS_LANG = SIMPLIFIED CHINESE_CHINA.ZHS16GBK”，(AMERICAN_AMERICA.US7ASCII 是ASCII编码类型，其它类型可自己到服务器看一下或网上查找一下)（本步骤暂时要做对，如果编码不对，会产生乱码） ④下载并安装 PL SQL Developer配置应用： 打开 PL SQL Developer，登入界面点取消，进入后选择菜单栏 tools-&gt;preferences-&gt;connection 设置： Oracle Home=D:\oracleclient OCI library=D:\oracleclient\oci.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6209acc930ab38b2b72d400dedf87aba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68a0820034e13bcf62015e70637213d2/" rel="bookmark">
			jquery.fly.js实现添加购物车效果、实现抛物线运动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、JQuery.fly.js整理
1.Git源代码地址：
https://github.com/amibug/fly
2.Demo演示地址：http://codepen.io/hzxs1990225/full/ogLaVp
3.Api使用：
&lt;script src="jquery.js"&gt;&lt;/script&gt; &lt;script src="dist/jquery.fly.min.js"&gt;&lt;/script&gt; &lt;script&gt; jQuery(function($) { $('#fly').fly({ start:{ left: 11, //开始位置（必填）#fly元素会被设置成position: fixed top: 600, //开始位置（必填） }, end:{ left: 500, //结束位置（必填） top: 130, //结束位置（必填） width: 100, //结束时高度 height: 100, //结束时高度 }, autoPlay: false, //是否直接运动,默认true speed: 1.1, //越大越快，默认1.2 vertex_Rtop：100, //运动轨迹最高点top值，默认20 onEnd: function(){} //结束回调 }); $('#fly').play(); //autoPlay: false后，手动调用运动 $('#fly').destroy(); //移除dom }); &lt;/script&gt;二、使用实例 1.HTMl页面
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/68a0820034e13bcf62015e70637213d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e7e6e0e5215b164b340d98a6e075b78/" rel="bookmark">
			OpenCV：imwrite函数保存图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		imwrite函数功能：用于将图像保存到指定的文件，可以为各种格式的图像。
函数原型：
bool cv::imwrite(const String &amp; filename, InputArray img, const std::vector&lt;int&gt; &amp; params = std::vector&lt;int&gt;() )	函数参数：
filename：需要保存图像的文件名，要保存图片为哪种格式，就带什么后缀。img：要保存的图像。params：表示为特定格式保存的参数编码。 注意：
imwrite函数是基于文件扩展名选择图像的格式。通常，使用此功能只能保存8位单通道或3通道（带有BGR通道顺序）图像，但有以下例外：
对于PNG，JPEG2000和TIFF格式，可以保存16位无符号（CV_16U）图像。32位浮点（CV_32F）图像可以保存为PFM，TIFF，OpenEXR和Radiance HDR格式; 使用LogLuv高动态范围编码（每像素4个字节）保存3通道（CV_32FC3）TIFF图像可以使用此功能保存带有Alpha通道的PNG图像。为此，创建8位（或16位）4通道图像BGRA，其中alpha通道最后。完全透明的像素应该将alpha设置为0，完全不透明的像素应该将alpha设置为255/65535。 如果格式，深度或通道顺序不同，请在保存之前使用Mat :: convertTo和cv :: cvtColor进行转换。或者，使用通用FileStorage I / O函数将图像保存为XML或YAML格式。
编码参数：
IMWRITE_JPEG_QUALITY Python：cv.IMWRITE_JPEG_QUALITY
对于JPEG，它可以是从0到100的质量（越高越好）。默认值为95。
IMWRITE_JPEG_PROGRESSIVE Python：cv.IMWRITE_JPEG_PROGRESSIVE
启用JPEG功能，0或1，默认为False。
IMWRITE_JPEG_OPTIMIZE Python：cv.IMWRITE_JPEG_OPTIMIZE
启用JPEG功能，0或1，默认为False。
IMWRITE_JPEG_RST_INTERVAL Python：cv.IMWRITE_JPEG_RST_INTERVAL
JPEG重启间隔，0 - 65535，默认为0 - 无重启。
IMWRITE_JPEG_LUMA_QUALITY Python：cv.IMWRITE_JPEG_LUMA_QUALITY
单独的亮度质量等级，0 - 100，默认为0 - 不使用。
IMWRITE_JPEG_CHROMA_QUALITY Python：cv.IMWRITE_JPEG_CHROMA_QUALITY
单独的色度质量等级，0 - 100，默认为0 - 不使用。
IMWRITE_PNG_COMPRESSION Python：cv.IMWRITE_PNG_COMPRESSION
对于PNG，它可以是从0到9的压缩级别。值越高意味着更小的尺寸和更长的压缩时间。如果指定，则策略更改为IMWRITE_PNG_STRATEGY_DEFAULT（Z_DEFAULT_STRATEGY）。默认值为1（最佳速度设置）。
IMWRITE_PNG_STRATEGY Python：cv.IMWRITE_PNG_STRATEGY
其中一个品种:: ImwritePNGFlags，默认为IMWRITE_PNG_STRATEGY_RLE。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e7e6e0e5215b164b340d98a6e075b78/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75f56a1e60b6fb7c350f1ce1323a44db/" rel="bookmark">
			编译ijkplayer
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、环境 以下工具请到移动硬盘下载，或者参考笔记：尝试ijkplayer环境搭建工具下载地址 腾讯云 Ubuntu Server 16.04.1 LTS 64位 可通过管理平台的登录打开用户界面版 jdk-8u112-linux-x64.tar.gz android-studio-ide-145.3276617-linux.zip android-ndk-r10e-linux-x86_64.bin android-sdk_r24.4.1-linux.tgz gradle-2.14.1-bin.zip 上述工具整到一个目录下如/data，解压缩即可。如下： 但注意，最后几部执行./compile-ffmpeg.sh all时，会报错，export: (64-bit): bad variable name。这里就需要把ANDROID_NDK/RELEASE.TXT的r10e-rc4 (64-bit)的(64-bit)去掉才不错的 2、命令执行 执行sudo -s ，之后可以不带sudo执行。 修改文本使用sudo gedit /etc/profile 环境变量同时需要修改sudo gedit ~/.bashrc 3、环境变量 /etc/profile 和 ~/.bashrc 最后加上下面的环境变量，并且source /etc/profile , source ~/.bashrc 此时不用带sudo，因为执行了sudo -s export JAVA_HOME=/home/ubuntu/Documents/jdk1.8.0_112 export CLASSPATH=.:$JAVA_HOME/lib:$JAVA_HOME/jre/lib:$CLASSPATH export PATH=$JAVA_HOME/bin:$JAVA_HOME/jre/bin:$PATH export NDK=/home/ubuntu/Documents/android-ndk-r10e export PATH=$NDK:$PATH export ANDROID_NDK=/home/ubuntu/Documents/android-ndk-r10e export PATH=$ANDROID_NDK:$PATH export ANDROID_SDK=/home/ubuntu/Documents/android-sdk-linux export PATH=$ANDROID_SDK:$PATH 4、安卓环境问题 需要执行sudo apt-get install lib32z1 lib32ncurses5 lib32stdc++6 sudo apt-get install git sudo apt-get install yasm 并修改 /opt/ Android-studio/bin/studio.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/75f56a1e60b6fb7c350f1ce1323a44db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d899b2a7efe9922a53daa78969dc3b04/" rel="bookmark">
			jumpserver 堡垒机环境搭建（图文详解）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Jumpserver 是一款由Python编写开源的跳板机(堡垒机)系统，实现了跳板机应有的功能。基于ssh协议来管理，客户端无需安装agent。
特点：
完全开源，GPL授权 Python编写，容易再次开发 实现了跳板机基本功能，认证、授权、审计 集成了Ansible，批量命令等 支持WebTerminal Bootstrap编写，界面美观 自动收集硬件信息 录像回放 命令搜索 实时监控 批量上传下载
jumpserver 3.0 安装
相对于 jumpserver 2.0 版本，在新的版本 3.0 中取消了LDAP授权，取而代之的是ssh进行推送；界面也有所变化，功能更完善，安装更简单，不像 2.0 的版本，难住了好多人。下面通过两台主机来搭建 jumpserver堡垒机！
环境： Centos 6.5 x86_64 关闭 iptables，关闭 selinux jumpserver：192.168.1.200 clients：192.168.1.210 ps：操作只针对 jumpserver，clients 不会进行操作，只是环境需求。
一、安装依赖包 yum -y install epel-release yum clean all &amp;&amp; yum makecache yum -y update yum -y install git python-pip mysql-devel gcc automake autoconf python-devel vim sshpass lrzsz readline-devel
二、下载 jumpserver cd /opt git clone https://github.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d899b2a7efe9922a53daa78969dc3b04/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfd16c4aecd4d77982faa96db6aed2ca/" rel="bookmark">
			linux内核驱动之USB设备添加pid，vid
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		添加usb设备的pid，vid的位置为：
/drivers/usb/serial/option.c
static const struct usb_device_id option_ids[] = {
{ HW_USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x01, 0x01) },
{ HW_USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x01, 0x02) },
{ HW_USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x01, 0x03) },
{ HW_USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x01, 0x04) },
{ HW_USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x01, 0x05) },
{ USB_DEVICE(0x05C6, 0x9025) },
{ USB_DEVICE(0x05C6, 0x9625) },
......
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f13b380b89d350d71bd000fb28516098/" rel="bookmark">
			2.6.5 实例化绘制glDrawArraysInstanced()
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 高级话题
OpenGL 3.1（尤其是GLSL 1.40）增加了对实例化绘制的支持，它提供了另一个额外的值gl_InstanceID（叫做实例ID，并且它只在顶点着色器中可用），对于指定的每一组图元，该ID相应递增。
glDrawArraysInstanced()的运行和glMultiDrawArrays()类似，只不过对于glDrawArrays()的每次调用，开始索引和顶点计数是相同的（分别由first和count指定）。
void glDrawArraysInstanced(GLenum mode, GLint first, GLsizei count, GLsizei primcount); primcount次有效地调用glDrawArrays()，在每次调用前设置GLSL顶点着色器值gl_InstanceID。mode指定了图元类型。first和count指定了传递给glDrawArrays()的数组元素的范围。
glDrawArraysInstanced()和如下的连续调用具有相同的效果（只不过我们的应用程序不必手动更新gl_InstanceID）：
for (i = 0; i &lt; primcount; i++) { gl_InstanceID = i; glDrawArrays(mode, first, count); } gl_InstanceID = 0; 同样，glDrawElementsInstanced()执行同样的操作，但是允许随机访问顶点数组中的数据。
void glDrawElementsInstanced(GLenum mode, GLsizei count, GLenum type, const void *indicies, GLsizei primcount); primcount次有效地调用glDrawElements()，在每次调用前设置GLSL顶点着色器值gl_InstanceID。mode指定了图元类型。type指定了数组索引的数据类型，并且必须是如下之一：GL_UNSIGNED_BYTE、GL_UNSIGNED_SHORT或GL_UNSIGNED_INT。indicies和count指定了传递给glDrawElements()的数组元素的范围。
glDrawElementsInstanced()的实现如下所示：
for (i = 0; i &lt; primcount; i++) { gl_InstanceID = i; glDrawElements(mode, count, type, indicies); } gl_InstanceID = 0; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f778fdbcc4d9eda2a4fdb7d6ba87c5a/" rel="bookmark">
			web.config中customErrors节点的配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、customErrors节点在web.config中的位置
configuration -&gt; system.web -&gt; customerErrors
二、customErrors节点常见用法
&lt;configuration&gt; &lt;system.web&gt; &lt;customErrors defaultRedirect="defaultErrorURL" mode="RemoteOnly"&gt; &lt;error statusCode="500" redirect="500ErrorURL"/&gt; &lt;error statusCode="403" redirect="403URL" /&gt; &lt;error statusCode="404" redirect="404URL" /&gt; &lt;/customErrors&gt; &lt;/system.web&gt; &lt;/configuration&gt; 三、customErrors节点属性值介绍
1、defaultRedirect
(1)、可选的属性。
(2)、指定出错时将浏览器定向到的默认 URL。如果未指定该属性，则显示一般性错误。
(3)、URL 可以是绝对的（如 http://www.studyofnet.com/news/1328.html）或相对的。相对 URL是相对于为该属性指定 URL 的 Web.config 文件，而不是相对于发生错误的网页。以字符 (~) 开头的 URL（如 ~/news/1328.html）表示指定的 URL 是相对于应用程序的根路径。
2、mode （必选属性），值有如下三种
值
说明
On
指定启用自定义错误。如果未指定 defaultRedirect，用户将看到一般性错误。
Off
指定禁用自定义错误。这允许显示标准的详细错误。
RemoteOnly
指定仅向远程客户端显示自定义错误并且向本地主机显示 ASP.NET 错误。这是默认值。
备注
在开发调试阶段为了便于查找错误Mode属性建议设置为Off，而在部署阶段应将Mode属性设置为On或者RemoteOnly，以避免这些详细的错误信息暴露了程序代码细节
文章转载自：web.config中customErrors节点的配置 http://www.studyofnet.com/news/1329.html 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/157ed6d973a78117aa0fd9ac4923c2c4/" rel="bookmark">
			ubuntu关于docker一些事
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装 这里使用的是阿里云Docker-Engine： [(http://mirrors.aliyun.com/help/docker-engine)]
curl -sSL http://acs-public-mirror.oss-cn-hangzhou.aliyuncs.com/docker-engine/internet | sh - 使用命令 1. docker version 显示 Docker 版本信息。
2. docker info 显示 Docker 系统信息，包括镜像和容器数。
3. docker search docker search [options “o”&gt;] term docker search -s django
从 Docker Hub 中搜索符合条件的镜像。
–automated 只列出 automated build 类型的镜像；
–no-trunc 可显示完整的镜像描述；
-s 40 列出收藏数不小于40的镜像。
4. docker pull docker pull [-a “o”&gt;] [user/ “o”&gt;]name[:tag “o”&gt;] docker pull laozhu/telescope:latest
从 Docker Hub 中拉取或者更新指定镜像。
-a 拉取所有 tagged 镜像 。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/157ed6d973a78117aa0fd9ac4923c2c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9495148049e6a6c9f318e84e599af374/" rel="bookmark">
			matlab中switch函数用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一 用途 用于变量的多分支选择问题
二 语法
switch-case-end
switch 变量
case 常量1
语句序列1；
case 常量2
语句序列2；
........
case 常量n
语句序列n;
otherwise
语句序列；
end
三 注意
1.otherwise 语句可选
2.找到匹配的case后，执行完就自动退出，不必像c语言一样，必须用break结束. 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7de92acaecea0e901e44bda750258031/" rel="bookmark">
			自动化测试框架PatatiumWebUi
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PatatiumWebUi 官网：https://git.oschina.net/zhengshuheng/PatatiumWebUi
这是Java编写的框架，基于Selenium、TestNG等技术。
mark一下，留备学习。
转载于:https://www.cnblogs.com/dreamyu/p/6551002.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e869774629a7db9cac8ba18611eaa42b/" rel="bookmark">
			Opencv 图像边缘拉伸
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求如下图，需要将绿色点围成的区域（记做inside）到红色点围成的区域（记做outside）拉伸到蓝色点（图片中有两圈蓝点，本文以内圈蓝点为准）围成的区域（记做affine），并且绿色区域内部的图像保持不变，仅拉伸边缘区域，原图中红色区域以外的图像信息忽略。
原理：将红点与绿点间的区域切分为多个三角形，记住srcTriangles， 将蓝点与绿点间的区域也切分为多个三角形，记住dstTriangles。使用仿射变换，将srcTriangles变换为dstTriangles即可实现边缘拉伸的效果。
注意三角形切分时，srcTriangles与dstTriangles一一对应
涉及Opencv API：getAffineTransform（仿射变换）
仿射变换的用法：（三点确定仿射矩阵）
src_tri[0] = Point2f(srcTriangles[i].p1.x, srcTriangles[i].p1.y); src_tri[1] = Point2f(srcTriangles[i].p2.x, srcTriangles[i].p2.y); src_tri[2] = Point2f(srcTriangles[i].p3.x, srcTriangles[i].p3.y); dst_tri[0] = Point2f(dstTriangles[i].p1.x, dstTriangles[i].p1.y); dst_tri[1] = Point2f(dstTriangles[i].p2.x, dstTriangles[i].p2.y); dst_tri[2] = Point2f(dstTriangles[i].p3.x, dstTriangles[i].p3.y); Mat warp_mat_org_inv = cv::getAffineTransform(dst_tri, src_tri); 实现需求的核心代码：
Mat deform(std::vector&lt;Triangle&gt; srcTriangles, std::vector&lt;Triangle&gt; dstTriangles, Mat srcImage) { int nIsoSize = 512; Mat result = Mat::zeros(nIsoSize, nIsoSize, CV_8UC3); for (int i = 0; i &lt; srcTriangles.size(); i++) { cv::Point2f src_tri[3]; cv::Point2f dst_tri[3]; src_tri[0] = Point2f(srcTriangles[i].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e869774629a7db9cac8ba18611eaa42b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f251a526356ab289b97a8f0a1d189046/" rel="bookmark">
			scp命令与expect脚本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 expect用法 shell expect的简单用法
通过expect写的脚本就可实现自动复制，免除手动输入密码
#!/usr/bin/expect -f spawn scp root@192.168.250.190:/home/1.txt　/tmp/2.txt expect { -re ".*es.*o.*" { exp_send "yes\r" exp_continue } -re ".*sword.*" { exp_send "your_password\r" } } interact 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c44008b0af2d3c6df9cfbf835045b48a/" rel="bookmark">
			Android网络权限汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		﻿﻿ android.permission.ACCESS_CHECKIN_PROPERTIES //允许读写访问”properties”表在checkin数据库中，改值可以修改上传
android.permission.ACCESS_COARSE_LOCATION //允许一个程序访问CellID或WiFi热点来获取粗略的位置
android.permission.ACCESS_FINE_LOCATION //允许一个程序访问精良位置(如GPS)
android.permission.ACCESS_LOCATION_EXTRA_COMMANDS //允许应用程序访问额外的位置提供命令
android.permission.ACCESS_MOCK_LOCATION //允许程序创建模拟位置提供用于测试
android.permission.ACCESS_NETWORK_STATE //允许程序访问有关GSM网络信息
android.permission.ACCESS_SURFACE_FLINGER //允许程序使用SurfaceFlinger底层特性
android.permission.ACCESS_WIFI_STATE //允许程序访问Wi-Fi网络状态信息
android.permission.ADD_SYSTEM_SERVICE //允许程序发布系统级服务
android.permission.BATTERY_STATS //允许程序更新手机电池统计信息
android.permission.BLUETOOTH //允许程序连接到已配对的蓝牙设备
android.permission.BLUETOOTH_ADMIN //允许程序发现和配对蓝牙设备
android.permission.BRICK //请求能够禁用设备(非常危险
android.permission.BROADCAST_PACKAGE_REMOVED //允许程序广播一个提示消息在一个应用程序包已经移除后
android.permission.BROADCAST_STICKY //允许一个程序广播常用intents
android.permission.CALL_PHONE //允许一个程序初始化一个电话拨号不需通过拨号用户界面需要用户确认
android.permission.CALL_PRIVILEGED //允许一个程序拨打任何号码，包含紧急号码无需通过拨号用户界面需要用户确认
android.permission.CAMERA //请求访问使用照相设备
android.permission.CHANGE_COMPONENT_ENABLED_STATE //允许一个程序是否改变一个组件或其他的启用或禁用
android.permission.CHANGE_CONFIGURATION //允许一个程序修改当前设置，如本地化
android.permission.CHANGE_NETWORK_STATE //允许程序改变网络连接状态
android.permission.CHANGE_WIFI_STATE //允许程序改变Wi-Fi连接状态
android.permission.CLEAR_APP_CACHE //允许一个程序清楚缓存从所有安装的程序在设备中
android.permission.CLEAR_APP_USER_DATA //允许一个程序清除用户设置
android.permission.CONTROL_LOCATION_UPDATES //允许启用禁止位置更新提示从无线模块
android.permission.DELETE_CACHE_FILES //允许程序删除缓存文件
android.permission.DELETE_PACKAGES //允许一个程序删除包
android.permission.DEVICE_POWER //允许访问底层电源管理
android.permission.DIAGNOSTIC //允许程序RW诊断资源
android.permission.DISABLE_KEYGUARD //允许程序禁用键盘锁
android.permission.DUMP //允许程序返回状态抓取信息从系统服务
android.permission.EXPAND_STATUS_BAR //允许一个程序扩展收缩在状态栏,android开发网提示应该是一个类似Windows Mobile中的托盘程序
android.permission.FACTORY_TEST //作为一个工厂测试程序，运行在root用户
android.permission.FLASHLIGHT //访问闪光灯,android开发网提示HTC Dream不包含闪光灯
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c44008b0af2d3c6df9cfbf835045b48a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/608594f54db256a55480d5c05c5a4519/" rel="bookmark">
			JAVA复制数组和重置数组大小
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 翻看印象笔记发现自己整理过arraycopy()这样一个方法，码字放到这里: System.arraycopy()是一个静态方法，用来实现重置数组操作
数组复制方法调用和参数列表：
System.arraycopy(src, srcPos, dest, destPos, length);
src:原数组
srcPos：原数组的开始位置
dest：目标数组
destPos：目的数组的开始位置
length：复制长度
数组复制代码示例：
//originalArray 数组全部复制到targetArray数组 int [] originalArray = new int[10]; int [] targetArray = new int [10]; System.arraycopy(originalArray, 0, targetArray, 0, originalArray.length);通过入参的长度 限制是全部复制还是部分复制 重置数组大小代码示例：
int [] originalArray = new int[10]; int [] temp =new int [originalArray.length + 10]; System.arraycopy(originalArray, 0, temp, 0, originalArray.length); //数组重新复制 originalArray=temp; 以后建议在重置数组或者数组复制时用这个静态方法，效率要比for循环高（来自某本技术书籍） 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/535/">«</a>
	<span class="pagination__item pagination__item--current">536/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/537/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>